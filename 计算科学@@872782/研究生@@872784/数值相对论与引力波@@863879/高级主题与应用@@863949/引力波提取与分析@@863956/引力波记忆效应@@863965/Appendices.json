{"hands_on_practices": [{"introduction": "非线性或“Christodoulou”记忆效应源于一个深刻的物理原理：引力波自身携带能量和动量，因此它们也产生引力。这个练习将通过一个亲身实践的数值实验来揭示这一概念，您将通过对一个简化的引力波暴的能量通量进行积分，直接计算出测试质量永久性的位移。这个过程清晰地展示了引力波能量的持续流出如何导致时空的永久性变形 [@problem_id:2399205]。", "problem": "要求您编写一个完整、可运行的程序，通过对给定引力波信号的能量流进行数值积分，来模拟类致密双星暴产生的引力波记忆效应，从而确定测试质量的永久位移。请从基本且经过充分检验的基础出发：广义相对论（GR）中远场引力波的Isaacson有效应力-能量张量，以及自由臂对“+”偏振应变准静态变化的测地线偏离响应。不要先验地假设任何关于记忆效应的专门公式；请从这些基础出发推导出您所需要的关系。\n\n假设和基本原理：\n- 在远场、平面波、横向无迹近似下进行计算。令 $h_+(t)$ 和 $h_\\times(t)$ 表示在探测器位置沿正入射波束测得的两个度规偏振应变。\n- 使用引力波携带的Isaacson能量流（单位面积的功率），\n$$\nF(t) \\;=\\; \\frac{c^3}{16\\pi G}\\Big(\\dot{h}_+^2(t)+\\dot{h}_\\times^2(t)\\Big),\n$$\n其中 $G$ 是牛顿引力常数，$c$ 是光速，$\\dot{h}$ 表示 $h$ 的时间导数。\n- 对于一个与“+”偏振基准对齐的探测器臂，在“+”偏振应变中的准静态净变化 $\\Delta h_+$ 会产生一个永久位移 $\\Delta L$，由下式给出：\n$$\n\\frac{\\Delta L}{L} \\;=\\; \\frac{1}{2}\\,\\Delta h_+,\n$$\n其中 $L$ 是臂长。假设探测器平面与传播方向正交，且探测器臂与“+”偏振方向完全对齐。\n\n请根据上述基本原理、远场区域的 $1/R$ 振幅标度以及零无穷处的能量守恒，推导出连接所测能量流的时间积分与视线方向上“+”偏振的非线性（Christodoulou）记忆效应的最简视线平面波关系。使用该关系计算永久位移 $\\Delta L$。\n\n信号模型和数值规格：\n- 使用均匀时间网格 $t \\in [-0.5,\\,0.5]$ 秒，步长为 $\\Delta t = 10^{-4}$ 秒。\n- 对于给定情况，定义\n$$\nh_+(t) \\;=\\; A\\,\\exp\\!\\Big(-\\frac{t^2}{2\\sigma^2}\\Big)\\cos\\!\\big(2\\pi f_0 t\\big),\\qquad\nh_\\times(t) \\;=\\; \\epsilon\\,A\\,\\exp\\!\\Big(-\\frac{t^2}{2\\sigma^2}\\Big)\\sin\\!\\big(2\\pi f_0 t\\big),\n$$\n其中 $A$ 是应变振幅（无量纲），$\\sigma$ 是高斯宽度（单位为秒），$f_0$ 是载波频率（单位为赫兹），$\\epsilon \\in \\{0,1\\}$ 用于切换是否存在交叉偏振。\n- 计算 $\\dot{h}_+$ 和 $\\dot{h}_\\times$ 相对于时间 $t$（单位为秒）的导数。您可以通过上述公式进行解析计算，或使用稳定的有限差分格式进行数值计算。\n- 使用梯形法则对所有时间积分进行数值计算。\n- 使用以下国际单位制（SI）中的常数：$G = 6.67430\\times 10^{-11}\\,\\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$，$c = 2.99792458\\times 10^8\\,\\mathrm{m\\,s^{-1}}$，$1\\,\\mathrm{pc} = 3.085677581491367\\times 10^{16}\\,\\mathrm{m}$。\n\n输出量和单位：\n- 对于每个测试用例，以浮点数形式输出最终的永久位移 $\\Delta L$，单位为米。\n\n测试套件：\n对于所有情况，使用臂长 $L = 4000$ 米和距离 $R = 100$ 百万秒差距，其中 $1\\,\\mathrm{Mpc} = 10^6\\,\\mathrm{pc}$。四个测试用例如下：\n1. 情况A（圆偏振暴）：$A = 1.0\\times 10^{-21}$，$f_0 = 150$，$\\sigma = 0.05$，$\\epsilon = 1$，$R = 100$。\n2. 情况B（无信号）：$A = 0.0$，$f_0 = 150$，$\\sigma = 0.05$，$\\epsilon = 1$，$R = 100$。\n3. 情况C（仅“+”偏振暴）：$A = 1.0\\times 10^{-21}$，$f_0 = 150$，$\\sigma = 0.05$，$\\epsilon = 0$，$R = 100$。\n4. 情况D（更强的圆偏振暴）：$A = 2.0\\times 10^{-21}$，$f_0 = 150$，$\\sigma = 0.05$，$\\epsilon = 1$，$R = 100$。\n\n除以百万秒差距为单位的距离外，所有物理输入均采用国际单位制。您必须使用上面给出的秒差距定义将距离转换为米。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个结果，格式为方括号内的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4]$）。每个 $x_i$ 必须是给出 $\\Delta L$（单位为米）的浮点数。", "solution": "所提出的问题是计算物理学中的一个有效练习，其基础是广义相对论的原理。它要求对一个简化的暴信号进行非线性引力波记忆效应的数值计算。我们将首先建立理论基础和要实现的具体公式，然后按照规定进行数值求解。\n\n该问题要求推导所测得的引力波能量流与应变的永久变化 $\\Delta h_+$（即Christodoulou记忆）之间的关系。这种效应源于引力波自身携带能量和动量，因此会产生引力。由Isaacson张量描述的波的应力-能量在爱因斯坦场方程中充当源，产生度规扰动的一个二阶非振荡分量，该分量在波通过后仍然存在。\n\nIsaacson能量流由下式给出：\n$$\nF(t) = \\frac{c^3}{16\\pi G}\\left(\\dot{h}_+^2(t)+\\dot{h}_\\times^2(t)\\right)\n$$\n这表示波携带的单位面积、单位时间内的总能量。然而，记忆效应对辐射的各向异性很敏感。对于沿传播方向的观测者，“+”偏振应变的永久变化 $\\Delta h_+$ 是由波应力的各向异性部分引起的。\n\n严格的推导涉及以Isaacson张量为源求解二阶爱因斯坦方程。这个过程很复杂。然而，问题要求的是“最简视线平面波关系”。从此类分析中得到的一个公认结果，可以通过启发式方法加以论证，它将记忆效应与两种偏振“功率”之差的时间积分联系起来。这种表述正确地捕捉了物理预期，即纯圆偏振波（其围绕传播方向是轴对称的）不应沿其轴线产生这种类型的记忆。\n\n用距源头距离为 $R$ 处测得的应变分量表示的适当关系式是：\n$$\n\\Delta h_+ = \\frac{R}{2c} \\int_{-\\infty}^{\\infty} \\left( \\dot{h}_+^2(t) - \\dot{h}_\\times^2(t) \\right) dt\n$$\n该公式在量纲上是正确的。应变 $h$ 是无量纲的，所以 $\\dot{h}$ 的单位是 $s^{-1}$。积分的单位也是 $s^{-1}$。前置因子 $R/c$ 的单位是 $s$，使得 $\\Delta h_+$ 成为无量纲量。物理标度也是正确的：对于距离为 $R$ 的源，应变振幅 $h \\propto 1/R$，因此 $\\dot{h}^2 \\propto 1/R^2$。积分项因此按 $1/R^2$ 比例缩放，总体的 $\\Delta h_+ \\propto (R) \\cdot (1/R^2) = 1/R$，这与来自遥远源的度规扰动的预期相符。\n\n建立了关键公式后，我们开始进行数值实现。\n信号分量为：\n$$\nh_+(t) = A\\,\\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)\\cos\\left(\\omega_0 t\\right)\n$$\n$$\nh_\\times(t) = \\epsilon\\,A\\,\\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)\\sin\\left(\\omega_0 t\\right)\n$$\n其中 $\\omega_0 = 2\\pi f_0$。设包络为 $E(t) = A\\,\\exp(-t^2/(2\\sigma^2))$。\n它们的时间导数使用乘法法则解析计算得出：\n$$\n\\dot{h}_+(t) = \\dot{E}(t)\\cos(\\omega_0 t) - \\omega_0 E(t)\\sin(\\omega_0 t)\n$$\n$$\n\\dot{h}_\\times(t) = \\epsilon \\left( \\dot{E}(t)\\sin(\\omega_0 t) + \\omega_0 E(t)\\cos(\\omega_0 t) \\right)\n$$\n其中 $\\dot{E}(t) = - \\frac{t}{\\sigma^2} E(t)$。\n\n算法如下：\n1.  定义物理常数 $G$、$c$ 以及秒差距到米的转换因子。\n2.  设置时间网格 $t$，范围从 $-0.5\\,s$ 到 $0.5\\,s$，步长为 $\\Delta t = 10^{-4}\\,s$。\n3.  对于每个具有参数 $(A, f_0, \\sigma, \\epsilon, R, L)$ 的测试用例：\n    a. 将距离 $R$ 从百万秒差距转换为米。\n    b. 在时间网格上定义包络函数 $E(t)$ 及其导数 $\\dot{E}(t)$。\n    c. 使用上述解析公式计算 $\\dot{h}_+(t)$ 和 $\\dot{h}_\\times(t)$ 的数组。\n    d. 计算被积函数 $I(t) = \\dot{h}_+^2(t) - \\dot{h}_\\times^2(t)$。\n    e. 使用梯形法则在时间网格上对 $I(t)$ 进行数值积分，以求得 $\\int I(t) dt$。\n    f. 计算永久应变变化 $\\Delta h_+ = \\frac{R}{2c} \\int I(t) dt$。\n    g. 最后，计算探测器臂的永久位移：$\\Delta L = \\frac{1}{2} L \\Delta h_+$。\n4.  收集所有测试用例的结果，并按指定格式呈现。\n\n对于情况A（圆偏振，$\\epsilon=1$），被积函数 $\\dot{h}_+^2 - \\dot{h}_\\times^2$ 变成由 $\\cos(2\\omega_0 t)$ 和 $\\sin(2\\omega_0 t)$ 调制的项之和。由于载波频率 $f_0=150\\,Hz$ 远高于包络的特征频率（$1/\\sigma = 20\\,Hz$），对这些快速振荡项的积分预期将非常接近于零。同样的情况也适用于情况D。对于情况B，振幅 $A=0$，因此结果显然为零。对于情况C（线偏振，$\\epsilon=0$），$\\dot{h}_\\times=0$，被积函数就是 $\\dot{h}_+^2$，它严格非负。其积分将不为零，从而产生可测量的记忆效应。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the gravitational-wave memory effect for several test cases.\n    \"\"\"\n\n    # Physical Constants in SI units\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    c = 2.99792458e8   # m s^-1\n    PC_TO_M = 3.085677581491367e16  # meters per parsec\n\n    # Shared parameters for all test cases\n    L_arm = 4000.0  # meters\n    R_dist_mpc = 100.0  # megaparsecs\n    R_dist_m = R_dist_mpc * 1e6 * PC_TO_M\n\n    # Numerical grid specifications\n    t_start = -0.5  # seconds\n    t_end = 0.5    # seconds\n    dt = 1e-4      # seconds\n    t = np.arange(t_start, t_end + dt, dt)\n\n    # Test suite: (A, f0, sigma, epsilon)\n    test_cases = [\n        # Case A: Circularly polarized burst\n        (1.0e-21, 150.0, 0.05, 1.0),\n        # Case B: No signal\n        (0.0, 150.0, 0.05, 1.0),\n        # Case C: Plus-only burst\n        (1.0e-21, 150.0, 0.05, 0.0),\n        # Case D: Stronger circular burst\n        (2.0e-21, 150.0, 0.05, 1.0),\n    ]\n\n    results = []\n    \n    for A, f0, sigma, epsilon in test_cases:\n        # If amplitude is zero, result is trivially zero\n        if A == 0.0:\n            results.append(0.0)\n            continue\n            \n        omega0 = 2.0 * np.pi * f0\n\n        # Define Gaussian envelope and its derivative\n        # E(t) = A * exp(-t^2 / (2*sigma^2))\n        envelope_t = A * np.exp(-t**2 / (2.0 * sigma**2))\n        \n        # dE/dt = - (t/sigma^2) * E(t)\n        envelope_dot_t = -(t / sigma**2) * envelope_t\n\n        # Calculate time derivatives of h_plus and h_cross\n        # h_plus(t) = envelope(t) * cos(omega0 * t)\n        # h_cross(t) = epsilon * envelope(t) * sin(omega0 * t)\n        \n        cos_t = np.cos(omega0 * t)\n        sin_t = np.sin(omega0 * t)\n        \n        # dh_plus/dt = dE/dt * cos(omega0*t) - omega0 * E(t) * sin(omega0*t)\n        h_plus_dot_t = envelope_dot_t * cos_t - omega0 * envelope_t * sin_t\n        \n        # dh_cross/dt = epsilon * (dE/dt * sin(omega0*t) + omega0 * E(t) * cos(omega0*t))\n        h_cross_dot_t = epsilon * (envelope_dot_t * sin_t + omega0 * envelope_t * cos_t)\n\n        # Integrand for memory calculation\n        # I(t) = (dh_plus/dt)^2 - (dh_cross/dt)^2\n        integrand = h_plus_dot_t**2 - h_cross_dot_t**2\n\n        # Numerically integrate using the trapezoidal rule\n        integral_val = np.trapz(integrand, t, dx=dt)\n        \n        # Calculate the permanent strain change (memory)\n        # Delta_h_plus = (R / (2*c)) * integral_val\n        delta_h_plus = (R_dist_m / (2.0 * c)) * integral_val\n\n        # Calculate the permanent arm displacement\n        # Delta_L = (1/2) * L * Delta_h_plus\n        delta_L = 0.5 * L_arm * delta_h_plus\n        \n        results.append(delta_L)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2399205"}, {"introduction": "在数值相对论中，从模拟输出（如Weyl标量 $\\Psi_4$）中提取物理引力波应变是一个核心任务，但这充满了挑战。由于需要进行两次时间积分，重构出的应变信号往往会受到未知积分常数导致的线性漂移伪影的污染，这可能会掩盖或错误地模仿真实的记忆效应。这个练习模拟了这一关键的数据处理步骤，指导您如何通过最小二乘法拟合并减去这些数值漂移，从而准确地恢复记忆信号 [@problem_id:3476243]。", "problem": "你的任务是设计并实现一个数值程序，以评估在从Newman–Penrose标量重构应变时，由数值漂移引起的引力波记忆污染。其物理和数值背景如下。\n\n基本基础和定义：\n- 在横向无迹（TT）规范下，于类光将来无穷远处，Newman–Penrose标量$\\,\\Psi_4(u)\\,$等于复引力波应变$\\,h(u) = h_+(u) - i h_\\times(u)\\,$的负二阶时间导数，即\n$$\\Psi_4(u) \\;=\\; -\\,\\frac{d^2 h(u)}{du^2}.$$\n- 引力波记忆是由爆发期间应变实部的净变化所表征的永久位移：\n$$\\Delta h \\;=\\; \\lim_{u\\to +\\infty} \\mathrm{Re}\\,h(u) \\;-\\; \\lim_{u\\to -\\infty} \\mathrm{Re}\\,h(u).$$\n- 在数值相对论中，人们通过二次时间积分从$\\,\\Psi_4(u)\\,$重构$\\,h(u)\\,$，但未知的积分常数会在重构的应变中引入一个线性趋势（数值漂移）$\\,d_0 + d_1 u\\,$。一种标准的缓解方法是使用爆发之外的数据（无信号窗口）来拟合并减去此漂移。\n\n你的程序必须：\n1.  从一个包含平滑记忆阶跃和可选振荡分量且具有物理动机的$\\,h(u)\\,$构建合成测试数据$\\,\\Psi_4(u)\\,$，然后向$\\,\\Psi_4(u)\\,$添加高斯噪声。\n2.  通过以零初始条件（即因果积分，其中$\\,h(u_0)=0\\,$和$\\,\\dot{h}(u_0)=0\\,$）对$\\,\\Psi_4(u)\\,$进行二次积分，来重构一个初步应变$\\,h_{\\mathrm{raw}}(u)\\,$。\n3.  在排除爆发信号的两个无信号时间窗口的并集上，使用最小二乘法对$\\,h_{\\mathrm{raw}}(u)\\,$拟合线性漂移模型$\\,d_0 + d_1 u\\,$，并将其减去。\n4.  将在晚期和早期时间点的平均校正应变$\\,h_{\\mathrm{corr}}(u)\\,$之间的差异作为恢复的记忆进行估计，并将恢复的记忆与真实记忆振幅之间的绝对误差作为污染的量化。\n\n信号模型和构建细节：\n- 使用以秒为单位的推迟时$\\,u\\,$，并产生无量纲的应变量。\n- 使用误差函数定义平滑记忆阶跃：\n$$S(u) \\;=\\; \\tfrac{1}{2}\\,\\Bigl[1 + \\mathrm{erf}\\Bigl(\\frac{u-u_c}{\\sqrt{2}\\,\\sigma}\\Bigr)\\Bigr].$$\n令真实记忆为$\\,\\Delta h\\,$，则对应变的记忆贡献为$\\,h_{\\mathrm{mem}}(u) = \\Delta h\\,S(u)\\,$。其二阶导数为\n$$\\frac{d^2 h_{\\mathrm{mem}}}{du^2}(u) \\;=\\; \\Delta h\\,\\frac{d^2 S}{du^2}(u) \\;=\\; -\\,\\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr),$$\n所以$\\,\\Psi_4(u)\\,$的记忆部分是\n$$\\Psi_{4,\\mathrm{mem}}(u) \\;=\\; -\\,\\frac{d^2 h_{\\mathrm{mem}}}{du^2}(u) \\;=\\; \\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr).$$\n- 可选地，在应变中包含一个振荡贡献\n$$h_{\\mathrm{osc}}(u) \\;=\\; A\\,\\sin(\\omega u)\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\Bigr),$$\n其高斯包络的宽度为$\\,\\tau\\,$。记$\\,f(u) = \\exp\\!\\bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\bigr)\\,$，$\\,s(u)=\\sin(\\omega u)\\,$，则有$\\,f'(u) = -\\frac{u-u_c}{\\tau^2} f(u)\\,$和$\\,f''(u) = \\bigl(\\frac{(u-u_c)^2}{\\tau^4}-\\frac{1}{\\tau^2}\\bigr)f(u)\\,$，以及$\\,s''(u) = -\\omega^2 s(u)\\,$。因此，\n$$\\frac{d^2 h_{\\mathrm{osc}}}{du^2}(u) \\;=\\; A\\Bigl[f''(u)\\,s(u) + 2 f'(u)\\,\\omega\\cos(\\omega u) - \\omega^2 f(u)\\,s(u)\\Bigr],$$\n而$\\,\\Psi_4(u)\\,$的振荡部分是\n$$\\Psi_{4,\\mathrm{osc}}(u) \\;=\\; -\\,\\frac{d^2 h_{\\mathrm{osc}}}{du^2}(u) \\;=\\; -A\\,f''(u)\\,s(u)\\;-\\;2A\\,\\omega f'(u)\\cos(\\omega u)\\;+\\;A\\,\\omega^2 f(u)\\,s(u).$$\n- 总的$\\,\\Psi_4(u)\\,$是\n$$\\Psi_4(u) \\;=\\; \\Psi_{4,\\mathrm{mem}}(u) \\;+\\; \\Psi_{4,\\mathrm{osc}}(u) \\;+\\; n(u),$$\n其中$\\,n(u)\\,$是零均值高斯噪声，其标准差为$\\,\\sigma_n\\,$，单位为$\\,\\mathrm{s}^{-2}\\,$。\n\n数值重构和漂移移除：\n- 通过梯形累积积分计算$\\,v(u) = \\int_{u_0}^u \\Psi_4(u')\\,du'\\,$，其中$\\,v(u_0) = 0\\,$，然后通过第二次累积梯形积分计算\n$$h_{\\mathrm{raw}}(u) \\;=\\; \\int_{u_0}^u v(u')\\,du'$$\n其中$\\,h_{\\mathrm{raw}}(u_0) = 0\\,$。由于未知的积分常数，这会引入一个任意的线性趋势$\\,d_0 + d_1 u\\,$，必须对其进行估计和移除。\n- 对于给定的中心时间$\\,u_c\\,$和排除半宽$\\,L\\,$（秒），将无信号窗口定义为$[u_{\\min},\\,u_c-L]$和$[u_c+L,\\,u_{\\max}]$的并集。在这些窗口内，通过最小二乘法将$\\,d_0 + d_1 u\\,$拟合到$\\,h_{\\mathrm{raw}}(u)\\,$，并将其减去以获得$\\,h_{\\mathrm{corr}}(u)\\,$。\n- 通过以下方式估计恢复的记忆：\n$$\\Delta h_{\\mathrm{rec}} \\;=\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_c+L,\\,u_{\\max}]} \\;-\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_{\\min},\\,u_c-L]},$$\n其中上划线表示在指定区间内的算术平均值。\n- 将记忆污染度量定义为绝对误差：\n$$\\varepsilon \\;=\\; \\bigl|\\Delta h_{\\mathrm{rec}} - \\Delta h\\bigr|.$$\n\n实现要求：\n- 所有时间$\\,u\\,$必须以秒为单位，所有输出均为无量纲应变。三角函数的角度使用弧度。最终答案必须是无量纲的。\n- 使用梯形累积积分进行数值积分。你可以使用一个稳健的库例程来进行累积梯形积分。\n- 使用固定的随机数生成器种子，以使噪声可复现。\n\n测试套件：\n为以下四种情况实现上述程序。每种情况都定义了一个均匀的时间网格$\\,u \\in [u_{\\min}, u_{\\max}]\\,$，其间距为$\\,\\Delta u\\,$，以及信号模型和漂移拟合的参数。所有量都是实数值。\n\n- 情况$\\,1\\,$（理想路径）：\n  - $\\,u_{\\min} = -0.5\\,$, $\\,u_{\\max} = 0.5\\,$, $\\,\\Delta u = 10^{-3}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.02\\,$, $\\,\\Delta h = 2\\times 10^{-22}\\,$.\n  - $\\,A = 5\\times 10^{-22}\\,$, $\\,\\omega = 500\\,$, $\\,\\tau = 0.05\\,$.\n  - $\\,\\sigma_n = 10^{-23}\\,$, $\\,L = 0.08\\,$.\n\n- 情况$\\,2\\,$（更强的振荡和噪声，更短的窗口）：\n  - $\\,u_{\\min} = -0.2\\,$, $\\,u_{\\max} = 0.2\\,$, $\\,\\Delta u = 5\\times 10^{-4}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.01\\,$, $\\,\\Delta h = 1\\times 10^{-22}\\,$.\n  - $\\,A = 8\\times 10^{-22}\\,$, $\\,\\omega = 800\\,$, $\\,\\tau = 0.03\\,$.\n  - $\\,\\sigma_n = 3\\times 10^{-23}\\,$, $\\,L = 0.04\\,$.\n\n- 情况$\\,3\\,$（无振荡，更粗的采样，宽窗口）：\n  - $\\,u_{\\min} = -1.0\\,$, $\\,u_{\\max} = 1.0\\,$, $\\,\\Delta u = 2\\times 10^{-3}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.05\\,$, $\\,\\Delta h = 5\\times 10^{-22}\\,$.\n  - $\\,A = 0\\,$, $\\,\\omega = 0\\,$, $\\,\\tau = 0.1\\,$.\n  - $\\,\\sigma_n = 5\\times 10^{-24}\\,$, $\\,L = 0.2\\,$.\n\n- 情况$\\,4\\,$（窄记忆，高频率，高噪声密度）：\n  - $\\,u_{\\min} = -0.05\\,$, $\\,u_{\\max} = 0.05\\,$, $\\,\\Delta u = 2\\times 10^{-4}\\,$.\n  - $\\,u_c = 0\\,$, $\\,\\sigma = 0.005\\,$, $\\,\\Delta h = 5\\times 10^{-23}\\,$.\n  - $\\,A = 2\\times 10^{-22}\\,$, $\\,\\omega = 1000\\,$, $\\,\\tau = 0.01\\,$.\n  - $\\,\\sigma_n = 5\\times 10^{-23}\\,$, $\\,L = 0.015\\,$.\n\n最终输出要求：\n- 对于每种情况，计算上面定义的污染度量$\\,\\varepsilon\\,$。\n- 你的程序应生成单行输出，其中包含用方括号括起来的四个结果的逗号分隔列表。每个数字必须以科学记数法打印，并保留六位有效数字（例如，$\\,1.234560\\mathrm{e}{-22}\\,$）。输出必须具有以下形式：\n$$\\texttt{[}\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4\\texttt{]}.$$\n\n所有计算必须使用浮点算术完成。不允许用户输入；所有参数如上所述。为高斯噪声使用固定的随机种子，以便结果是确定性的。", "solution": "该问题陈述已经过验证，被认为是科学上合理、适定且客观的。它为执行引力波记忆污染的定量分析提供了一套完整且一致的定义、物理模型、数值程序和参数。该问题与数值相对论领域直接相关，代表了一项标准的数据分析任务。因此，将提供一个解决方案。\n\n目标是实现一个数值程序，以量化在存在数值漂移和噪声的情况下，当从Newman-Penrose标量$\\Psi_4(u)$重构应变$h(u)$时，引力波记忆效应$\\Delta h$的污染。该程序涉及合成一个真实的引力波信号，通过数值积分重构应变，校正伪影，然后测量恢复记忆中的误差。这个过程将对四个不同的测试案例执行。\n\n步骤如下：\n\n1.  **信号合成**：对于每个测试案例，我们首先构建Newman-Penrose标量$\\Psi_4(u)$的离散时间序列。\n    时间网格$u$在区间$[u_{\\min}, u_{\\max}]$上定义，具有均匀间距$\\Delta u$。\n    总标量$\\Psi_4(u)$是三个分量的总和：\n    $$\\Psi_4(u) \\;=\\; \\Psi_{4,\\mathrm{mem}}(u) \\;+\\; \\Psi_{4,\\mathrm{osc}}(u) \\;+\\; n(u)$$\n    -   记忆分量$\\Psi_{4,\\mathrm{mem}}(u)$，源于总振幅为$\\Delta h$的应变中一个平滑阶跃的二阶导数。其函数形式由下式给出：\n        $$\\Psi_{4,\\mathrm{mem}}(u) \\;=\\; \\Delta h\\,\\frac{u-u_c}{\\sqrt{2\\pi}\\,\\sigma^3}\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\sigma^2}\\Bigr)$$\n        其中$u_c$是中心时间，$\\sigma$控制过渡的持续时间。\n    -   振荡分量$\\Psi_{4,\\mathrm{osc}}(u)$，模拟并合事件期间的辐射。它是一个带有高斯包络的正弦信号的负二阶时间导数：\n        $$h_{\\mathrm{osc}}(u) \\;=\\; A\\,\\sin(\\omega u)\\,\\exp\\!\\Bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\Bigr)$$\n        使用微分的乘法法则以及为包络$f(u) = \\exp\\!\\bigl(-\\frac{(u-u_c)^2}{2\\tau^2}\\bigr)$及其导数$f'(u)$和$f''(u)$提供的定义，$\\Psi_4(u)$的振荡部分是：\n        $$\\Psi_{4,\\mathrm{osc}}(u) \\;=\\; -A\\Bigl[f''(u)\\,\\sin(\\omega u) + 2 f'(u)\\,\\omega\\cos(\\omega u) - \\omega^2 f(u)\\,\\sin(\\omega u)\\Bigr]$$\n        对于给定的测试案例，如果振幅$A$为零，则该分量恒等于零。\n    -   噪声分量$n(u)$，被建模为从均值为$0$、标准差为$\\sigma_n$的高斯（正态）分布中抽取的独立随机变量序列。为确保可复现性，对随机数生成器使用固定的种子。\n\n2.  **应变重构**：复应变$h(u)$通过$\\Psi_4(u) = -d^2h/du^2$与$\\Psi_4(u)$相关。由于问题指定所有量都是实数，我们考虑单个实数极化。我们通过对$\\Psi_4(u)$执行两次连续的不定积分来重构应变。对于未知的积分常数，这将得到$h(u) = -\\iint \\Psi_4(u') du' du' + d_0 + d_1 u$。在数值上，我们将初始条件设置为零，这对应于从$u_0 = u_{\\min}$开始的因果积分。这将得到一个原始、未校正的应变$h_{\\mathrm{raw}}(u)$。积分使用累积梯形法则执行。\n    首先，我们计算第一个积分，$v(u)$：\n    $$v(u) = \\int_{u_{\\min}}^u \\Psi_4(u')\\,du'$$\n    然后，我们计算第二个积分，即原始应变$h_{\\mathrm{raw}}(u)$：\n    $$h_{\\mathrm{raw}}(u) \\;=\\; \\int_{u_{\\min}}^u v(u')\\,du'$$\n    这些积分是使用累积梯形积分例程在数值上执行的。零初始条件$v(u_{\\min})=0$和$h_{\\mathrm{raw}}(u_{\\min})=0$通过因果积分边界的选择被隐式处理。\n\n3.  **漂移校正**：原始应变$h_{\\mathrm{raw}}(u)$被一个线性漂移项$d_0 + d_1 u$污染，这是未知真实积分常数的伪影。必须估计并移除此漂移。我们对模型$y(u) = d_0 + d_1 u$与原始应变$h_{\\mathrm{raw}}(u)$进行线性最小二乘拟合。拟合仅在“无信号”窗口内的数据上执行，这些窗口定义为时间区间$[u_{\\min}, u_c - L]$和$[u_c + L, u_{\\max}]$的并集。假定这些区域主要由漂移和噪声主导，因为主要的爆发信号局限在$u_c$周围。\n    令$(u_i, y_i)$为这些窗口中的离散数据对，其中$y_i = h_{\\mathrm{raw}}(u_i)$。通过最小化残差平方和$\\sum_i (y_i - (d_0 + d_1 u_i))^2$来找到系数$d_0$和$d_1$。\n    一旦找到最优的$d_0$和$d_1$，就从整个原始应变时间序列中减去漂移，以获得校正后的应变：\n    $$h_{\\mathrm{corr}}(u) \\;=\\; h_{\\mathrm{raw}}(u) - (d_0 + d_1 u)$$\n\n4.  **记忆恢复与污染测量**：引力波记忆是爆发过去之后应变中的永久偏移。我们通过比较校正后应变$h_{\\mathrm{corr}}(u)$在晚期时间的平均值与在早期时间的平均值来估计它。这些时间区间与用于漂移拟合的无信号窗口相同。\n    恢复的记忆$\\Delta h_{\\mathrm{rec}}$计算如下：\n    $$\\Delta h_{\\mathrm{rec}} \\;=\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_c+L,\\,u_{\\max}]} \\;-\\; \\overline{h_{\\mathrm{corr}}(u)}\\bigm|_{u \\in [u_{\\min},\\,u_c-L]}$$\n    其中上划线表示算术平均值。\n    最后，污染度量$\\varepsilon$定义为恢复的记忆与用于生成信号的真实记忆振幅$\\Delta h$之间的绝对误差：\n    $$\\varepsilon \\;=\\; \\bigl|\\Delta h_{\\mathrm{rec}} - \\Delta h\\bigr|$$\n\n这整个四步程序被实现并应用于问题陈述中提供的四个测试案例中的每一个，为每个案例得出一个$\\varepsilon$值。然后按要求格式化最终结果。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # A fixed seed for the random number generator ensures reproducibility.\n    rng = np.random.default_rng(42)\n\n    test_cases = [\n        # Case 1\n        {\n            \"u_min\": -0.5, \"u_max\": 0.5, \"du\": 1e-3,\n            \"u_c\": 0.0, \"sigma\": 0.02, \"delta_h\": 2e-22,\n            \"A\": 5e-22, \"omega\": 500.0, \"tau\": 0.05,\n            \"sigma_n\": 1e-23, \"L\": 0.08,\n        },\n        # Case 2\n        {\n            \"u_min\": -0.2, \"u_max\": 0.2, \"du\": 5e-4,\n            \"u_c\": 0.0, \"sigma\": 0.01, \"delta_h\": 1e-22,\n            \"A\": 8e-22, \"omega\": 800.0, \"tau\": 0.03,\n            \"sigma_n\": 3e-23, \"L\": 0.04,\n        },\n        # Case 3\n        {\n            \"u_min\": -1.0, \"u_max\": 1.0, \"du\": 2e-3,\n            \"u_c\": 0.0, \"sigma\": 0.05, \"delta_h\": 5e-22,\n            \"A\": 0.0, \"omega\": 0.0, \"tau\": 0.1,\n            \"sigma_n\": 5e-24, \"L\": 0.2,\n        },\n        # Case 4\n        {\n            \"u_min\": -0.05, \"u_max\": 0.05, \"du\": 2e-4,\n            \"u_c\": 0.0, \"sigma\": 0.005, \"delta_h\": 5e-23,\n            \"A\": 2e-22, \"omega\": 1000.0, \"tau\": 0.01,\n            \"sigma_n\": 5e-23, \"L\": 0.015,\n        },\n    ]\n\n    results = []\n    for case_params in test_cases:\n        epsilon = calculate_memory_contamination(case_params, rng)\n        results.append(epsilon)\n\n    # Format the final output string as specified.\n    output_str = \"[\" + \",\".join([f\"{res:.6e}\" for res in results]) + \"]\"\n    print(output_str)\n\ndef calculate_memory_contamination(params, rng):\n    \"\"\"\n    Performs the full analysis for a single test case.\n    \"\"\"\n    # Unpack parameters for clarity\n    u_min, u_max, du = params[\"u_min\"], params[\"u_max\"], params[\"du\"]\n    u_c, sigma, delta_h = params[\"u_c\"], params[\"sigma\"], params[\"delta_h\"]\n    A, omega, tau = params[\"A\"], params[\"omega\"], params[\"tau\"]\n    sigma_n, L = params[\"sigma_n\"], params[\"L\"]\n\n    # 1. Signal Synthesis\n    # Create time grid\n    num_points = int(round((u_max - u_min) / du)) + 1\n    u = np.linspace(u_min, u_max, num=num_points)\n\n    # Memory component of Psi_4\n    u_rel = u - u_c\n    psi4_mem_prefactor = delta_h / (np.sqrt(2 * np.pi) * sigma**3)\n    psi4_mem = psi4_mem_prefactor * u_rel * np.exp(-u_rel**2 / (2 * sigma**2))\n\n    # Oscillatory component of Psi_4\n    if A != 0:\n        f = np.exp(-u_rel**2 / (2 * tau**2))\n        f_prime = -u_rel / tau**2 * f\n        f_double_prime = (u_rel**2 / tau**4 - 1 / tau**2) * f\n        \n        s = np.sin(omega * u)\n        c = np.cos(omega * u)\n        \n        d2h_osc_du2 = A * (f_double_prime * s + 2 * f_prime * omega * c - omega**2 * f * s)\n        psi4_osc = -d2h_osc_du2\n    else:\n        psi4_osc = np.zeros_like(u)\n\n    # Noise component\n    noise = rng.normal(loc=0.0, scale=sigma_n, size=len(u))\n\n    # Total Psi_4\n    psi4 = psi4_mem + psi4_osc + noise\n\n    # 2. Strain Reconstruction\n    # Double cumulative trapezoidal integration\n    v = cumulative_trapezoid(psi4, x=u, initial=0.0)\n    h_raw = cumulative_trapezoid(v, x=u, initial=0.0)\n\n    # 3. Drift Correction\n    # Define no-signal windows for fitting\n    early_fit_mask = u = (u_c - L)\n    late_fit_mask = u >= (u_c + L)\n    fit_mask = early_fit_mask | late_fit_mask\n\n    # Get data points for the fit\n    u_fit = u[fit_mask]\n    h_raw_fit = h_raw[fit_mask]\n\n    # Perform linear least-squares fit: h_raw = d0 + d1*u\n    # The model matrix columns correspond to d0 (ones) and d1 (u)\n    A_matrix = np.vstack([np.ones_like(u_fit), u_fit]).T\n    coeffs, _, _, _ = np.linalg.lstsq(A_matrix, h_raw_fit, rcond=None)\n    d0, d1 = coeffs[0], coeffs[1]\n\n    # Subtract the fitted drift\n    h_corr = h_raw - (d0 + d1 * u)\n    \n    # 4. Memory Recovery and Contamination Measurement\n    # The averaging windows are the same as the fit windows\n    mean_early = np.mean(h_corr[early_fit_mask])\n    mean_late = np.mean(h_corr[late_fit_mask])\n    \n    delta_h_rec = mean_late - mean_early\n    \n    # Calculate contamination metric\n    epsilon = np.abs(delta_h_rec - delta_h)\n    \n    return epsilon\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3476243"}, {"introduction": "对任何物理测量进行稳健的验证是科学分析的基石。引力波记忆效应在时域中表现为永久性的应变偏移，而在频域的低频端则具有一个独特的 $1/(i\\omega)$ 行为特征。本练习将引导您实现一个强大的交叉检验技术，通过对信号傅里叶变换的低频部分进行拟合来估计记忆幅度，并将其与直接在时域中测量的结果进行比较，从而验证您结果的一致性 [@problem_id:3476217]。", "problem": "给定一个引力波应变的合成模型，该模型表现出一个非振荡（记忆）分量和一个局域化的振荡分量。您的任务是通过将时域阶跃 $\\Delta h$ 与使用已定义误差模型的频域低频外推进行交叉比对，来验证引力波记忆幅度。最终程序必须以方括号括起来的单个逗号分隔列表形式输出所提供测试套件的验证结果，其中每个结果都表示为布尔值。\n\n从以下基础出发：\n- 引力波应变 $h(t)$ 是无量纲的，定义在一个有限的观测区间上，时间单位为秒。\n- 角频率 $\\omega$ 的单位为弧度/秒。\n- 函数 $h(t)$ 的傅里叶变换定义为\n$$\nH(\\omega) = \\int_{-\\infty}^{\\infty} h(t)\\,e^{-i \\omega t}\\,dt.\n$$\n- 记忆幅度定义为\n$$\n\\Delta h \\equiv \\lim_{t \\to +\\infty} h(t) - \\lim_{t \\to -\\infty} h(t).\n$$\n\n由此，推导具有平滑阶跃（非零 $\\Delta h$）的波形 $H(\\omega)$ 的低频主导行为。利用分部积分法，并假设 $h(t)$ 在渐近值之间平滑过渡，证明在低频区域，\n$$\nH(\\omega) \\approx \\frac{\\Delta h}{i\\,\\omega} + R(\\omega),\n$$\n其中 $R(\\omega)$ 是一个在 $\\omega \\to 0$ 时正则的函数。因此，虚部的近似行为是\n$$\n\\operatorname{Im}\\,H(\\omega) \\approx -\\frac{\\Delta h}{\\omega} + \\operatorname{Im}\\,R(\\omega).\n$$\n利用此关系为低频下的 $H(\\omega)$ 虚部构建一个双参数模型：\n$$\ny(\\omega) \\equiv \\operatorname{Im}\\,H(\\omega) \\approx -\\frac{b}{\\omega} + d,\n$$\n其中 $b$ 是 $\\Delta h$ 的估计值，$d$ 则捕捉了正则的低频贡献。\n\n实现一个加权最小二乘（WLS）拟合，根据一组低频频箱 $\\{\\omega_i\\}_{i=1}^M$ 来估计 $b$ 和 $d$，其中权重由指定的低频误差模型导出：\n$$\n\\sigma_{\\text{low-f}}(\\omega) = \\sigma_0 + \\sigma_1\\,\\omega,\n$$\n其中 $\\sigma_0$ 和 $\\sigma_1$ 由每个测试用例提供。WLS拟合最小化以下表达式：\n$$\n\\sum_{i=1}^M \\frac{\\left(y(\\omega_i) + \\frac{b}{\\omega_i} - d\\right)^2}{\\sigma_{\\text{low-f}}(\\omega_i)^2}.\n$$\n推导正规方程并求解 $b$ 和 $d$。使用 WLS 估计量的协方差矩阵，给出 $b$ 的估计 $1\\sigma$ 不确定度：\n$$\n\\mathrm{Cov}(\\theta) = \\left(X^\\top W X\\right)^{-1}, \\quad \\theta = \\begin{bmatrix} b \\\\ d \\end{bmatrix},\n$$\n其中 $X$ 的行是 $[-1/\\omega_i,\\,1]$，$W$ 是对角矩阵，其对角元为 $1/\\sigma_{\\text{low-f}}(\\omega_i)^2$，数据向量是 $y(\\omega_i) = \\operatorname{Im}\\,H(\\omega_i)$。\n\n在数值上，在一个均匀网格 $t_n$（$n=0,\\dots,N-1$）上构建合成应变 $h(t)$，其中 $t_n$ 覆盖区间 $[-T, T]$，采样步长为 $\\Delta t$。应变模型为\n$$\nh(t) = \\frac{\\Delta h}{2}\\left(1 + \\tanh\\left(\\frac{t - t_0}{\\tau}\\right)\\right) + A\\,\\exp\\left(-\\frac{(t - t_0)^2}{2\\,\\sigma_{\\text{env}}^2}\\right)\\cos\\left(\\omega_0 (t - t_0) + \\phi\\right),\n$$\n所有参数均由每个测试用例指定。将时域记忆计算为\n$$\n\\Delta h_{\\text{time}} = h(t_{\\max}) - h(t_{\\min}),\n$$\n其中 $t_{\\min} = -T$ 且 $t_{\\max} = T$。使用快速傅里叶变换（FFT）并进行适当缩放来计算离散傅里叶变换，以近似连续变换：\n$$\nH(\\omega_k) \\approx \\Delta t \\sum_{n=0}^{N-1} h(t_n) e^{-i \\omega_k t_n},\n$$\n其中离散的 $\\omega_k$ 值对应于 FFT 频箱。仅使用正的低频频箱 $0  \\omega_k \\le \\omega_{\\max}^{\\text{low}}$，并排除最低的频箱以减轻奇异行为。将 $y(\\omega_k) = \\operatorname{Im}\\,H(\\omega_k)$ 拟合到模型，并提取 $b$ 及其不确定度 $\\sigma_b = \\sqrt{\\mathrm{Cov}_{bb}}$。\n\n每个测试用例的验证标准：返回一个布尔值，指示是否满足\n$$\n\\left|\\Delta h_{\\text{freq}} - \\Delta h_{\\text{time}}\\right| \\le \\sigma_b,\n$$\n其中 $\\Delta h_{\\text{freq}} \\equiv b$。\n\n单位和约定：\n- 时间 $t$ 的单位必须是秒。\n- 角频率 $\\omega$ 的单位必须是弧度/秒。\n- 应变 $h$ 和记忆幅度 $\\Delta h$ 是无量纲的。\n- 振荡分量中的角度使用弧度。\n\n您的程序必须实现上述过程，并生成一行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果（例如，“[true,false,true,false]”），布尔值使用小写字母。\n\n测试套件参数（每个元组定义一个测试用例）：\n1. $\\left(T=2.0\\,\\mathrm{秒},\\,\\Delta t=\\frac{1}{4096}\\,\\mathrm{秒},\\,t_0=0.0\\,\\mathrm{秒},\\,\\Delta h=1.0\\times 10^{-22},\\,\\tau=0.05\\,\\mathrm{秒},\\,A=5.0\\times 10^{-23},\\,\\omega_0=100\\,\\mathrm{rad/s},\\,\\sigma_{\\text{env}}=0.2\\,\\mathrm{秒},\\,\\phi=0,\\,\\omega_{\\max}^{\\text{low}}=20\\,\\mathrm{rad/s},\\,\\sigma_0=1.0\\times 10^{-24},\\,\\sigma_1=1.0\\times 10^{-26}\\,\\mathrm{秒}\\right)$。\n2. $\\left(T=0.5\\,\\mathrm{秒},\\,\\Delta t=\\frac{1}{2048}\\,\\mathrm{秒},\\,t_0=0.0\\,\\mathrm{秒},\\,\\Delta h=7.0\\times 10^{-22},\\,\\tau=0.02\\,\\mathrm{秒},\\,A=1.0\\times 10^{-22},\\,\\omega_0=300\\,\\mathrm{rad/s},\\,\\sigma_{\\text{env}}=0.1\\,\\mathrm{秒},\\,\\phi=0,\\,\\omega_{\\max}^{\\text{low}}=50\\,\\mathrm{rad/s},\\,\\sigma_0=3.0\\times 10^{-24},\\,\\sigma_1=5.0\\times 10^{-26}\\,\\mathrm{秒}\\right)$。\n3. $\\left(T=1.5\\,\\mathrm{秒},\\,\\Delta t=\\frac{1}{8192}\\,\\mathrm{秒},\\,t_0=0.0\\,\\mathrm{秒},\\,\\Delta h=0.0,\\,\\tau=0.05\\,\\mathrm{秒},\\,A=2.0\\times 10^{-22},\\,\\omega_0=150\\,\\mathrm{rad/s},\\,\\sigma_{\\text{env}}=0.15\\,\\mathrm{秒},\\,\\phi=0,\\,\\omega_{\\max}^{\\text{low}}=30\\,\\mathrm{rad/s},\\,\\sigma_0=1.0\\times 10^{-24},\\,\\sigma_1=1.0\\times 10^{-26}\\,\\mathrm{秒}\\right)$。\n4. $\\left(T=1.0\\,\\mathrm{秒},\\,\\Delta t=\\frac{1}{4096}\\,\\mathrm{秒},\\,t_0=0.8\\,\\mathrm{秒},\\,\\Delta h=3.0\\times 10^{-22},\\,\\tau=0.05\\,\\mathrm{秒},\\,A=5.0\\times 10^{-23},\\,\\omega_0=200\\,\\mathrm{rad/s},\\,\\sigma_{\\text{env}}=0.2\\,\\mathrm{秒},\\,\\phi=0,\\,\\omega_{\\max}^{\\text{low}}=40\\,\\mathrm{rad/s},\\,\\sigma_0=1.0\\times 10^{-24},\\,\\sigma_1=1.0\\times 10^{-26}\\,\\mathrm{秒}\\right)$。\n\n您的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果（例如，“[true,false,true,false]”）。", "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于广义相对论和信号分析的原理，所提供的所有必要参数和条件使其成为一个适定问题，并且其表述是客观的。任务是通过比较直接的时域测量值和从低频拟合中得到的频域估计值来验证引力波记忆幅度。\n\n解决方案分为三部分。首先，我们推导引力波记忆（应变的永久性变化，$\\Delta h$）与其傅里叶变换的低频行为之间的理论关系。其次，我们构建加权最小二乘（WLS）程序，以从频域数据中估计 $\\Delta h$。第三，我们概述了为给定测试用例实现此验证过程的数值算法。\n\n**1. 引力波应变的低频行为**\n\n时域记忆与频域谱之间的关系是一个基本结果。设 $h(t)$ 是作为时间 $t$ 的函数的引力波应变。记忆效应定义为在事件整个持续时间内的应变净变化：\n$$\n\\Delta h \\equiv \\lim_{t \\to +\\infty} h(t) - \\lim_{t \\to -\\infty} h(t)\n$$\n我们假设应变从一个初始恒定值演化到一个最终恒定值，并且其时间导数 $\\dot{h}(t)$ 是一个行为良好、可积的函数，在 $t \\to \\pm\\infty$ 时趋于零。\n\n$\\dot{h}(t)$ 的傅里叶变换与 $h(t)$ 的傅里叶变换（表示为 $H(\\omega)$）通过傅里叶微分定理相关联：\n$$\n\\mathcal{F}[\\dot{h}(t)](\\omega) = \\int_{-\\infty}^{\\infty} \\dot{h}(t)\\,e^{-i \\omega t}\\,dt = i\\,\\omega\\,H(\\omega)\n$$\n现在，考虑当角频率 $\\omega$ 趋近于零时此变换的行为：\n$$\n\\lim_{\\omega \\to 0} \\mathcal{F}[\\dot{h}(t)](\\omega) = \\int_{-\\infty}^{\\infty} \\dot{h}(t)\\,e^{-i (0) t}\\,dt = \\int_{-\\infty}^{\\infty} \\dot{h}(t)\\,dt\n$$\n导数 $\\dot{h}(t)$ 在所有时间上的积分就是 $h(t)$ 的总变化量：\n$$\n\\int_{-\\infty}^{\\infty} \\dot{h}(t)\\,dt = \\left[h(t)\\right]_{-\\infty}^{+\\infty} = \\lim_{t \\to +\\infty} h(t) - \\lim_{t \\to -\\infty} h(t) = \\Delta h\n$$\n通过令极限相等，我们找到了 $\\dot{h}(t)$ 的“零阶频率矩”：\n$$\n\\lim_{\\omega \\to 0} \\left[i\\,\\omega\\,H(\\omega)\\right] = \\Delta h\n$$\n这意味着对于小的、非零的 $\\omega$，傅里叶变换 $H(\\omega)$ 必须具有以下的主导行为：\n$$\nH(\\omega) \\approx \\frac{\\Delta h}{i\\,\\omega} + R(\\omega) = -i\\,\\frac{\\Delta h}{\\omega} + R(\\omega)\n$$\n其中 $R(\\omega)$ 是一个在 $\\omega \\to 0$ 时保持正则（即有限且平滑）的函数。因此，$H(\\omega)$ 的虚部由下式给出：\n$$\n\\operatorname{Im}\\,H(\\omega) \\approx \\operatorname{Im}\\left(-i\\,\\frac{\\Delta h}{\\omega}\\right) + \\operatorname{Im}\\,R(\\omega) = -\\frac{\\Delta h}{\\omega} + \\operatorname{Im}\\,R(\\omega)\n$$\n由于 $\\operatorname{Im}\\,R(\\omega)$ 在 $\\omega=0$ 处是正则的，对于低频，我们可以用一个常数 $d$ 来近似它。这导出了谱的虚部 $y(\\omega) = \\operatorname{Im}\\,H(\\omega)$ 的双参数拟合模型：\n$$\ny(\\omega) \\approx -\\frac{b}{\\omega} + d\n$$\n在这里，参数 $b$ 作为记忆幅度 $\\Delta h$ 的估计值，我们将它表示为 $\\Delta h_{\\text{freq}}$。\n\n**2. 加权最小二乘（WLS）估计**\n\n给定一组 $M$ 个离散频域数据点 $(\\omega_i, y_i)$，其中 $y_i = \\operatorname{Im}\\,H(\\omega_i)$，以及一个误差模型 $\\sigma_{\\text{low-f}}(\\omega_i)$，我们可以通过最小化加权残差平方和 $\\chi^2$ 来估计参数 $b$ 和 $d$：\n$$\n\\chi^2(b, d) = \\sum_{i=1}^M \\frac{\\left(y_i - (-\\frac{b}{\\omega_i} + d)\\right)^2}{\\sigma_{\\text{low-f}}(\\omega_i)^2} = \\sum_{i=1}^M w_i \\left(y_i + \\frac{b}{\\omega_i} - d\\right)^2\n$$\n其中权重为 $w_i = 1/\\sigma_{\\text{low-f}}(\\omega_i)^2$。\n\n这是一个线性最小二乘问题。我们可以将模型写成矩阵形式。设参数向量为 $\\theta = \\begin{bmatrix} b \\\\ d \\end{bmatrix}$。数据向量 $Y = [y_1, \\dots, y_M]^\\top$ 的模型为 $Y \\approx X\\theta$，其中设计矩阵 $X$ 由下式给出：\n$$\nX = \\begin{bmatrix} -1/\\omega_1  1 \\\\ -1/\\omega_2  1 \\\\ \\vdots  \\vdots \\\\ -1/\\omega_M  1 \\end{bmatrix}\n$$\n最小化 $\\chi^2$ 的 WLS 解 $\\hat{\\theta}$ 由以下正规方程给出：\n$$\n\\left(X^\\top W X\\right)\\hat{\\theta} = X^\\top W Y\n$$\n其中 $W$ 是权重的对角矩阵，$W = \\text{diag}(w_1, \\dots, w_M)$。参数的解为：\n$$\n\\hat{\\theta} = \\begin{bmatrix} \\hat{b} \\\\ \\hat{d} \\end{bmatrix} = \\left(X^\\top W X\\right)^{-1} X^\\top W Y\n$$\n估计参数的统计不确定性由协方差矩阵捕获，该矩阵是 $\\chi^2$ 函数的海森矩阵的逆（按比例缩放了因子2，这在线性模型的协方差矩阵定义中是惯例）：\n$$\n\\mathrm{Cov}(\\hat{\\theta}) = \\left(X^\\top W X\\right)^{-1}\n$$\n估计值 $\\hat{b}$ 的方差是该矩阵的左上角元素 $\\mathrm{Cov}(\\hat{\\theta})_{11}$。因此，记忆估计值 $b$ 的标准（$1\\sigma$）不确定度为：\n$$\n\\sigma_b = \\sqrt{\\mathrm{Cov}(\\hat{\\theta})_{11}}\n$$\n\n**3. 数值实现算法**\n\n对每个测试用例，验证过程按如下方式实现：\n1.  **网格设置：** 在区间 $[-T, T)$ 上构建一个均匀时间网格 $t_n$，包含 $N = 2T/\\Delta t$ 个点，间距为 $\\Delta t$。时间数组为 $t_n = -T + n\\Delta t$，其中 $n = 0, \\dots, N-1$。\n2.  **应变合成：** 使用给定的模型方程在时间网格上生成合成应变信号 $h(t_n)$：\n    $$\n    h(t) = \\frac{\\Delta h}{2}\\left(1 + \\tanh\\left(\\frac{t - t_0}{\\tau}\\right)\\right) + A\\,\\exp\\left(-\\frac{(t - t_0)^2}{2\\,\\sigma_{\\text{env}}^2}\\right)\\cos\\left(\\omega_0 (t - t_0) + \\phi\\right)\n    $$\n3.  **时域记忆：** 时域记忆 $\\Delta h_{\\text{time}}$ 计算为最后一个和第一个时间步的应变之差：$\\Delta h_{\\text{time}} = h(t_{N-1}) - h(t_0)$。\n4.  **离散傅里叶变换：** 使用快速傅里叶变换（FFT）算法计算信号 $h(t_n)$ 的离散傅里叶变换。为近似连续傅里叶变换，结果需乘以时间步长 $\\Delta t$：\n    $$\n    H(\\omega_k) \\approx \\Delta t \\cdot \\text{FFT}[h(t_n)]\n    $$\n    相应的角频率 $\\omega_k$ 从 FFT 频箱获得。\n5.  **数据选择：** 对于 WLS 拟合，我们选择落在指定低频范围 $0  \\omega_i \\le \\omega_{\\max}^{\\text{low}}$ 内的数据点 $(y_i, \\omega_i)$。这排除了直流分量（$\\omega=0$），因为模型在该点是奇异的。\n6.  **WLS 拟合与不确定度：** 对所选数据进行 WLS 拟合。计算权重 $w_i = (\\sigma_0 + \\sigma_1 \\omega_i)^{-2}$。构建矩阵系统并求解 $\\hat{b} = \\Delta h_{\\text{freq}}$ 及其不确定度 $\\sigma_b$。\n7.  **验证：** 应用验证标准，检查频域估计值与时域测量值之间的绝对差是否在估计值的 $1\\sigma$ 不确定度范围内：\n    $$\n    |\\Delta h_{\\text{freq}} - \\Delta h_{\\text{time}}| \\le \\sigma_b\n    $$\n    为每个测试用例记录一个布尔结果（`true` 或 `false`）。\n最终输出是这些布尔值的列表，并按要求格式化。", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the gravitational wave memory validation for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # (T, dt, t0, delta_h, tau, A, omega0, sigma_env, phi, omega_max_low, sigma0, sigma1)\n        (2.0, 1.0/4096, 0.0, 1.0e-22, 0.05, 5.0e-23, 100, 0.2, 0.0, 20.0, 1.0e-24, 1.0e-26),\n        (0.5, 1.0/2048, 0.0, 7.0e-22, 0.02, 1.0e-22, 300, 0.1, 0.0, 50.0, 3.0e-24, 5.0e-26),\n        (1.5, 1.0/8192, 0.0, 0.0, 0.05, 2.0e-22, 150, 0.15, 0.0, 30.0, 1.0e-24, 1.0e-26),\n        (1.0, 1.0/4096, 0.8, 3.0e-22, 0.05, 5.0e-23, 200, 0.2, 0.0, 40.0, 1.0e-24, 1.0e-26),\n    ]\n\n    results = []\n\n    for params in test_cases:\n        T, dt, t0, delta_h, tau, A, omega0, sigma_env, phi, omega_max_low, sigma0, sigma1 = params\n\n        # 1. Setup Time and Frequency Grids\n        # Ensure N is an integer, which is true for all test cases.\n        N = int(2 * T / dt)\n        # Time array from -T to T-dt\n        t = np.arange(-N // 2, N // 2) * dt\n        \n        # 2. Generate Strain Data\n        memory_term = (delta_h / 2.0) * (1.0 + np.tanh((t - t0) / tau))\n        burst_term_envelope = A * np.exp(-(t - t0)**2 / (2.0 * sigma_env**2))\n        burst_term_oscillation = np.cos(omega0 * (t - t0) + phi)\n        h_t = memory_term + burst_term_envelope * burst_term_oscillation\n\n        # 3. Calculate Time-Domain Memory\n        # Use the first and last points of the generated time series.\n        delta_h_time = h_t[-1] - h_t[0]\n\n        # 4. Compute FFT\n        # Scale by dt to approximate the continuous Fourier transform integral\n        h_f = fft.fft(h_t) * dt\n        # Angular frequencies\n        omega = 2.0 * np.pi * fft.fftfreq(N, d=dt)\n\n        # 5. Select Low-Frequency Bins for Fitting\n        mask = (omega > 0)  (omega = omega_max_low)\n        omega_fit = omega[mask]\n        # Imaginary part of the spectrum for fitting\n        y_fit = np.imag(h_f[mask])\n\n        # 6. Perform Weighted Least Squares (WLS) Fit\n        # Model for the imaginary part: y(w) = -b/w + d\n        # Design matrix X has rows [-1/w_i, 1]\n        \n        # Calculate weights from the error model\n        sigma_low_f = sigma0 + sigma1 * omega_fit\n        weights = 1.0 / (sigma_low_f**2)\n\n        # Construct the matrix X^T * W * X\n        sum_w_over_om2 = np.sum(weights / omega_fit**2)\n        sum_w_over_om = np.sum(weights / omega_fit)\n        sum_w = np.sum(weights)\n        \n        XTWX = np.array([\n            [sum_w_over_om2, -sum_w_over_om],\n            [-sum_w_over_om, sum_w]\n        ])\n\n        # Construct the vector X^T * W * y\n        sum_wy_over_om = np.sum(weights * y_fit / omega_fit)\n        sum_wy = np.sum(weights * y_fit)\n\n        XTWy = np.array([-sum_wy_over_om, sum_wy])\n        \n        # Solve for parameters [b, d]\n        try:\n            params_fit = np.linalg.solve(XTWX, XTWy)\n            delta_h_freq = params_fit[0]  # This is the estimate for 'b'\n\n            # Calculate uncertainty on b\n            cov_matrix = np.linalg.inv(XTWX)\n            sigma_b_sq = cov_matrix[0, 0]\n            sigma_b = np.sqrt(sigma_b_sq) if sigma_b_sq >= 0 else float('inf')\n\n        except np.linalg.LinAlgError:\n            # In case of a singular matrix, the fit fails.\n            delta_h_freq = float('nan')\n            sigma_b = float('inf')\n\n        # 7. Apply Validation Criterion\n        is_valid = np.abs(delta_h_freq - delta_h_time) = sigma_b\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\nsolve()\n```", "id": "3476217"}]}