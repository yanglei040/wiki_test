{"hands_on_practices": [{"introduction": "从曲率中重建引力波应变的核心在于对给定的外尔标量 $\\Psi_4$ 进行两次时间积分。这个过程可以通过两种基本途径实现：直接在时域中使用数值积分方法，或者转换到频域中利用傅里叶变换的性质。本练习 [@problem_id:3488153] 为您提供了一个在受控环境中比较这些基础方法的平台，您将从一个解析已知的应变信号出发，精确计算其对应的 $\\Psi_4$，然后运用不同的数值积分器（如梯形法则和辛普森法则）以及频域方法来重建原始应变。通过量化每种方法的误差，您将直观地理解它们各自的精度、优势和局限性，为构建更复杂的重建流程打下坚实的基础。", "problem": "您的任务是在受控设置下从曲率重建引力波应变，并量化在实际采样约束下的数值误差传播。在广义相对论的弱场极限下，Newman–Penrose Weyl标量 $\\Psi_4$ 等于复应变 $h_+ - i h_\\times$ 的二阶时间导数。对于单个实偏振分量 $h(t)$，这简化为关系式 $\\Psi_4(t) = \\frac{\\mathrm{d}^2 h}{\\mathrm{d} t^2}(t)$，其中 $h(t)$ 是无量纲的，$t$ 是时间，单位为秒。在频域中，对于角频率 $\\omega = 2\\pi f$（其中 $f$ 的单位为赫兹），根据标准连续傅里叶变换约定，此关系变为 $\\tilde{h}(\\omega) = -\\tilde{\\Psi}_4(\\omega)/\\omega^2$。您的目标是使用不同的数值积分器实现时域双重积分，并将结果与受离散采样影响的频域重建进行比较。\n\n构建一个合成的、物理上合理的应变 $h_{\\mathrm{true}}(t)$，其振幅为 $A$，载波频率为 $f_0$，在持续时间 $T$ 内以速率 $F_s$ 采样，使用由 Hann 窗提供的光滑紧支撑来防止边界处出现不连续性：\n$$\nh_{\\mathrm{true}}(t) = A \\, \\sin(2\\pi f_0 t) \\, w(t), \\quad w(t) = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi t}{T}\\right)\\right),\n$$\n其中 $t \\in [0, T]$ 且角度以弧度为单位。使用乘法法则和 $w(t)$ 的精确导数，从 $h_{\\mathrm{true}}(t)$ 解析地推导出 $\\Psi_4(t)$：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d} t} w(t) = \\tfrac{1}{2} \\left(\\tfrac{2\\pi}{T}\\right) \\sin\\left(\\tfrac{2\\pi t}{T}\\right), \\quad\n\\frac{\\mathrm{d}^2}{\\mathrm{d} t^2} w(t) = \\tfrac{1}{2} \\left(\\tfrac{2\\pi}{T}\\right)^2 \\cos\\left(\\tfrac{2\\pi t}{T}\\right),\n$$\n并使用这些来精确地获得 $\\Psi_4(t) = \\frac{\\mathrm{d}^2 h_{\\mathrm{true}}}{\\mathrm{d} t^2}(t)$。\n\n在均匀网格 $t_n = n\\,\\Delta t$（其中 $\\Delta t = 1/F_s$，$n = 0,1,\\ldots,N$，$N = \\lfloor F_s T \\rfloor$，且网格包含两个端点 $t=0$ 和 $t=T$）上采样 $\\Psi_4(t)$，并实现三种 $h(t)$ 的重建方法：\n\n1. 使用累积应用的梯形法则进行时域双重积分，以近似第一个积分 $\\int_0^t \\Psi_4(\\tau)\\,\\mathrm{d}\\tau$，然后再次应用以近似 $\\int_0^t \\mathrm{d}\\tau \\int_0^{\\tau} \\Psi_4(s)\\,\\mathrm{d}s$。通过减去一个线性漂移 $\\alpha t$（选择 $\\alpha$ 使得 $h(0)=h(T)=0$）来强制重建的 $h(t)$ 端点为零。\n\n2. 使用累积应用的 Simpson 法则进行时域双重积分，端点漂移处理与方法1相同。确保累积 Simpson 积分对所有样本索引都有良好定义，在需要时对最后一个奇数间隔使用梯形校正。\n\n3. 使用具有 $N+1$ 个样本的离散傅里叶变换进行频域重建，在离散频率网格 $\\omega_k = 2\\pi f_k$ 上计算 $\\hat{\\Psi}_4(\\omega_k)$，其中 $f_k$ 是右手离散变换的标准实值傅里叶频率。对于每个 $k\\ge 1$，设置\n$$\n\\hat{h}(\\omega_k) = \\frac{\\hat{\\Psi}_4(\\omega_k)}{-\\omega_k^2},\n$$\n并设置 $\\hat{h}(\\omega_0)=0$ 以避免除以零。然后进行逆变换以在原始网格上获得 $h(t)$。所有三角函数和角度运算必须使用弧度。\n\n使用两种度量来量化每种方法相对于 $h_{\\mathrm{true}}(t)$ 的误差：\n- 相对 $L^2$ 误差,\n$$\n\\varepsilon_{\\mathrm{rel}} = \\frac{\\| h_{\\mathrm{num}} - h_{\\mathrm{true}} \\|_2}{\\| h_{\\mathrm{true}} \\|_2}, \\quad \\| x \\|_2 = \\sqrt{\\Delta t \\sum_{n=0}^{N} x_n^2},\n$$\n- 最大绝对误差,\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le n \\le N} | h_{\\mathrm{num}}(t_n) - h_{\\mathrm{true}}(t_n) |.\n$$\n\n设计并实现一个完整的程序，对以下测试套件执行此构建和计算，所有量均使用其指定单位：\n- 测试用例1（正常路径）：$A = 1\\times 10^{-21}$（无量纲），$f_0 = 150$ 赫兹，$F_s = 4096$ 赫兹，$T = 0.5$ 秒。\n- 测试用例2（低频内容）：$A = 1\\times 10^{-21}$（无量纲），$f_0 = 10$ 赫兹，$F_s = 256$ 赫兹，$T = 2.0$ 秒。\n- 测试用例3（近奈奎斯特内容）：$A = 5\\times 10^{-22}$（无量纲），$f_0 = 0.9 \\times (F_s/2)$ 赫兹，$F_s = 2048$ 赫兹，$T = 0.25$ 秒。\n\n为每个测试用例计算一个包含六个浮点数的列表：$[\\varepsilon_{\\mathrm{rel}}^{\\mathrm{trap}}, \\varepsilon_{\\mathrm{rel}}^{\\mathrm{simp}}, \\varepsilon_{\\mathrm{rel}}^{\\mathrm{freq}}, \\varepsilon_{\\max}^{\\mathrm{trap}}, \\varepsilon_{\\max}^{\\mathrm{simp}}, \\varepsilon_{\\max}^{\\mathrm{freq}}]$。\n\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为这些列表的逗号分隔列表，不含空格，并用方括号括起来。例如，输出格式必须完全是\n$$\n[ [x_{11},x_{12},x_{13},x_{14},x_{15},x_{16}], [x_{21},x_{22},x_{23},x_{24},x_{25},x_{26}], [x_{31},x_{32},x_{33},x_{34},x_{35},x_{36}] ],\n$$\n但没有任何空格：$[[x_{11},x_{12},x_{13},x_{14},x_{15},x_{16}],[x_{21},x_{22},x_{23},x_{24},x_{25},x_{26}],[x_{31},x_{32},x_{33},x_{34},x_{35},x_{36}]]$。所有三角函数运算必须使用弧度，所有频率单位为赫兹，所有时间单位为秒，应变为无量纲。输出值为浮点数，且必须只打印一次。", "solution": "用户请求解决一个引力波数据分析中的数值问题，即从 Newman-Penrose 标量 $\\Psi_4(t)$ 重建应变 $h(t)$，其中 $\\Psi_4 = \\mathrm{d}^2h/\\mathrm{d}t^2$。该问题被验证为科学上合理、适定且客观的。它提供了一个合成的、物理上合理的真实信号，并要求比较三种重建方法：两种在时域（累积梯形积分和 Simpson 积分），一种在频域（使用快速傅里叶变换）。目标是使用定义的误差度量来量化每种方法的数值精度。\n\n解决方案首先推导 $\\Psi_4(t)$ 的解析形式，然后详细说明每种重建算法的实现和误差计算，如问题陈述中所指定。\n\n从真实应变 $h_{\\mathrm{true}}(t)$ 推导出 Weyl 标量 $\\Psi_4(t)$ 的精确表达式。应变被给出为正弦波和 Hann 窗的乘积：\n$$\nh_{\\mathrm{true}}(t) = A \\sin(\\omega_0 t) w(t)\n$$\n其中 $\\omega_0 = 2\\pi f_0$ 是载波角频率，窗函数 $w(t)$ 及其导数为：\n$$\n\\begin{align*}\nw(t) = \\tfrac{1}{2}\\left(1 - \\cos(\\omega_T t)\\right) \\\\\n\\dot{w}(t) = \\tfrac{1}{2} \\omega_T \\sin(\\omega_T t) \\\\\n\\ddot{w}(t) = \\tfrac{1}{2} \\omega_T^2 \\cos(\\omega_T t)\n\\end{align*}\n$$\n其中 $\\omega_T = 2\\pi/T$。\n\n使用乘积求导法则 $(fg)'' = f''g + 2f'g' + fg''$ 来求 $h_{\\mathrm{true}}(t)$ 的二阶时间导数。令 $f(t) = A \\sin(\\omega_0 t)$ 且 $g(t) = w(t)$。$f(t)$ 的导数是 $f'(t) = A \\omega_0 \\cos(\\omega_0 t)$ 和 $f''(t) = -A \\omega_0^2 \\sin(\\omega_0 t)$。\n将这些代入乘积法则，得到 $\\Psi_4(t)$ 的精确表达式：\n$$\n\\Psi_4(t) = \\ddot{h}_{\\mathrm{true}}(t) = -A\\omega_0^2 \\sin(\\omega_0 t) w(t) + 2 A\\omega_0 \\cos(\\omega_0 t) \\dot{w}(t) + A\\sin(\\omega_0 t) \\ddot{w}(t)\n$$\n这个解析表达式用于在时间网格 $t_n = n \\Delta t$ 上生成离散样本 $\\Psi_4(t_n)$。\n\n三种重建方法的实现如下：\n1.  **时域（梯形）**：此方法近似计算从 $\\ddot{h}(t) = \\Psi_4(t)$ 恢复 $h(t)$ 所需的双重积分。第一步积分，即求速度 $\\dot{h}(t) = \\int_0^t \\Psi_4(\\tau)\\mathrm{d}\\tau$，是使用累积梯形法则进行的。第二步积分，$h(t) = \\int_0^t \\dot{h}(\\tau)\\mathrm{d}\\tau$，也使用累积梯形法则进行。在 Python 中，`scipy.integrate.cumulative_trapezoid` 非常适合此任务。这种原始积分隐式地假设了初始条件 $h(0) = 0$ 和 $\\dot{h}(0) = 0$。因此，得到的原始应变 $h_{\\mathrm{raw}}(t)$ 将满足 $h_{\\mathrm{raw}}(0)=0$，但不一定满足 $h_{\\mathrm{raw}}(T)=0$。为了强制执行 $t=T$ 处的边界条件，减去一个线性漂移项 $\\alpha t$。常数 $\\alpha$ 的选择使得校正后的应变 $h_{\\mathrm{num}}(t) = h_{\\mathrm{raw}}(t) - \\alpha t$ 在 $t=T$ 时为零：\n    $$\n    h_{\\mathrm{raw}}(T) - \\alpha T = 0 \\implies \\alpha = \\frac{h_{\\mathrm{raw}}(T)}{T}\n    $$\n    因此，最终重建的应变为 $h_{\\mathrm{num}}(t_n) = h_{\\mathrm{raw}}(t_n) - \\frac{h_{\\mathrm{raw}}(t_N)}{T} t_n$。\n\n2.  **时域（Simpson 法则）**：此方法与梯形法类似，但采用更精确的 Simpson 法则进行积分。实现了一种使用 Simpson 法则并带有梯形校正的高效 $O(N)$ 累积积分算法。令 $I_n = \\int_0^{t_n} y(\\tau) \\mathrm{d}\\tau$ 为在点 $y_k$ 采样的函数 $y$ 的累积积分。值 $I_n$ 计算如下：\n    - 偶数索引点 $n=2, 4, \\dots$ 通过递归计算：$I_n = I_{n-2} + \\frac{\\Delta t}{3}(y_{n-2} + 4y_{n-1} + y_n)$，从 $I_0=0$ 开始。这在连续的区间对上应用 Simpson 1/3 法则。\n    - 奇数索引点 $n=1, 3, \\dots$ 通过将最后一个区间的梯形校正加到先前计算的偶数索引点上得到：$I_n = I_{n-1} + \\frac{\\Delta t}{2}(y_{n-1} + y_n)$。\n    此算法应用两次以计算 $\\Psi_4(t)$ 的双重积分。应用与梯形法中相同的漂移校正程序来强制 $h(T)=0$。\n\n3.  **频域（FFT）**：此方法利用了卷积定理。微分关系 $\\ddot{h}(t) = \\Psi_4(t)$ 在频域中转化为代数关系：$(i\\omega)^2 \\hat{h}(\\omega) = \\hat{\\Psi}_4(\\omega)$，或 $\\hat{h}(\\omega) = \\hat{\\Psi}_4(\\omega) / (-\\omega^2)$。算法如下：\n    - 计算采样信号 $\\Psi_4(t_n)$ 的离散傅里叶变换（DFT），得到 $\\hat{\\Psi}_4(\\omega_k)$。对于实值信号，使用 `numpy.fft.rfft` 是高效的。\n    - 从 `numpy.fft.rfftfreq` 获取相应的角频率 $\\omega_k = 2\\pi f_k$。\n    - 对于每个频率箱 $k$（其中 $\\omega_k \\neq 0$），重建应变的傅里叶系数计算为 $\\hat{h}(\\omega_k) = \\hat{\\Psi}_4(\\omega_k) / (-\\omega_k^2)$。\n    - 直流分量（$k=0$, $\\omega_0=0$）被显式设置为零，即 $\\hat{h}(\\omega_0)=0$，以避免除以零，并强制重建信号的均值为零。\n    - 通过对系数 $\\hat{h}(\\omega_k)$ 应用逆 DFT（例如 `numpy.fft.irfft`）来恢复时域应变 $h(t_n)$。此方法不需要显式的漂移校正，因为信号的加窗特性和直流分量的置零已经很好地近似了物理边界条件。\n\n最后，对于三种重建信号（$h_{\\mathrm{trap}}$、$h_{\\mathrm{simp}}$、$h_{\\mathrm{freq}}$）中的每一种，相对于真实信号 $h_{\\mathrm{true}}$ 计算两种误差度量：\n-   相对 $L^2$ 误差：$\\varepsilon_{\\mathrm{rel}} = \\| h_{\\mathrm{num}} - h_{\\mathrm{true}} \\|_2 / \\| h_{\\mathrm{true}} \\|_2$，其中离散 $L^2$ 范数定义为 $\\| x \\|_2 = \\sqrt{\\Delta t \\sum_{n=0}^{N} x_n^2}$。\n-   最大绝对误差：$\\varepsilon_{\\max} = \\max_{0 \\le n \\le N} | h_{\\mathrm{num}}(t_n) - h_{\\mathrm{true}}(t_n) |$。\n\n整个过程被封装在一个 Python 脚本中，用于处理给定的测试用例并以指定格式生成最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef cumulative_simpson(y, dx):\n    \"\"\"\n    Calculates the cumulative integral of y using Simpson's rule.\n    This implementation is O(N) and handles an arbitrary number of points by\n    applying a trapezoidal rule for the final interval if the total\n    number of intervals up to that point is odd.\n    \"\"\"\n    n = len(y)\n    result = np.zeros(n, dtype=float)\n\n    # First, calculate integrals up to even-indexed points using Simpson's 1/3 rule.\n    for i in range(2, n, 2):\n        # I_n = I_{n-2} + integral from n-2 to n\n        result[i] = result[i-2] + (dx / 3.0) * (y[i-2] + 4*y[i-1] + y[i])\n\n    # Second, calculate integrals up to odd-indexed points.\n    # This uses the integral up to the previous (even) point and adds a\n    # trapezoidal step for the last interval.\n    for i in range(1, n, 2):\n        result[i] = result[i-1] + (dx / 2.0) * (y[i-1] + y[i])\n        \n    return result\n\ndef process_case(A, f0, Fs, T):\n    \"\"\"\n    Processes a single test case for strain reconstruction.\n    \"\"\"\n    # 1. Setup grid and analytical signals\n    N = int(Fs * T)\n    dt = 1.0 / Fs\n    t = np.linspace(0.0, T, N + 1)\n    \n    omega0 = 2.0 * np.pi * f0\n    omegaT = 2.0 * np.pi / T\n\n    # True strain h_true(t)\n    w = 0.5 * (1.0 - np.cos(omegaT * t))\n    h_true = A * np.sin(omega0 * t) * w\n    \n    # Exact Psi_4(t) = d^2h/dt^2\n    s_t = A * np.sin(omega0 * t)\n    s_dot_t = A * omega0 * np.cos(omega0 * t)\n    s_ddot_t = -A * omega0**2 * np.sin(omega0 * t)\n    \n    w_dot_t = 0.5 * omegaT * np.sin(omegaT * t)\n    w_ddot_t = 0.5 * omegaT**2 * np.cos(omegaT * t)\n\n    psi4_true = s_ddot_t * w + 2.0 * s_dot_t * w_dot_t + s_t * w_ddot_t\n\n    # 2. Reconstruct strain using three methods\n    # Method 1: Trapezoidal Integration\n    v_trap = cumulative_trapezoid(psi4_true, dx=dt, initial=0.0)\n    h_raw_trap = cumulative_trapezoid(v_trap, dx=dt, initial=0.0)\n    drift_trap = h_raw_trap[-1] / T\n    h_trap = h_raw_trap - drift_trap * t\n\n    # Method 2: Simpson's Rule Integration\n    v_simp = cumulative_simpson(psi4_true, dx=dt)\n    h_raw_simp = cumulative_simpson(v_simp, dx=dt)\n    drift_simp = h_raw_simp[-1] / T\n    h_simp = h_raw_simp - drift_simp * t\n\n    # Method 3: Frequency Domain Reconstruction\n    psi4_hat = np.fft.rfft(psi4_true)\n    freqs = np.fft.rfftfreq(N + 1, dt)\n    omega = 2.0 * np.pi * freqs\n    \n    h_hat = np.zeros_like(psi4_hat)\n    # Avoid division by zero at omega=0\n    # The non-zero frequencies start at index 1\n    # -omega**2 can be written as -(omega*omega) or -omega**2\n    with np.errstate(divide='ignore', invalid='ignore'):\n        h_hat[1:] = psi4_hat[1:] / (-omega[1:]**2)\n    h_hat[0] = 0.0 # Set DC component to zero\n    \n    h_freq = np.fft.irfft(h_hat, n=N + 1)\n\n    # 3. Quantify errors\n    def l2_norm(x, dx):\n        return np.sqrt(dx * np.sum(x**2))\n\n    def relative_l2_error(h_num, h_ref, dx):\n        norm_ref = l2_norm(h_ref, dx)\n        if norm_ref == 0:\n            return 0.0\n        return l2_norm(h_num - h_ref, dx) / norm_ref\n\n    def max_abs_error(h_num, h_ref):\n        return np.max(np.abs(h_num - h_ref))\n\n    errors = [\n        relative_l2_error(h_trap, h_true, dt),\n        relative_l2_error(h_simp, h_true, dt),\n        relative_l2_error(h_freq, h_true, dt),\n        max_abs_error(h_trap, h_true),\n        max_abs_error(h_simp, h_true),\n        max_abs_error(h_freq, h_true)\n    ]\n    return errors\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: A, f0, Fs, T\n        (1e-21, 150.0, 4096.0, 0.5),\n        # Case 2: A, f0, Fs, T\n        (1e-21, 10.0, 256.0, 2.0),\n        # Case 3: A, f0, Fs, T\n        (5e-22, 0.9 * (2048.0 / 2.0), 2048.0, 0.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, f0, Fs, T = case\n        errors = process_case(A, f0, Fs, T)\n        results.append(errors)\n\n    # Format the output string as specified\n    result_str = str(results).replace(\" \", \"\")\n    print(result_str)\n\nsolve()\n```", "id": "3488153"}, {"introduction": "在理想情况下，从 $\\Psi_4$ 重建应变是直接的。然而，来自真实数值相对论模拟的 $\\Psi_4$ 数据往往会受到低频数值噪声的污染。这些看似微小的偏差在经过两次积分后，会导致重建出的应变 $h(t)$ 出现非物理性的长期漂移，这种现象被称为“伪记忆效应”（spurious memory）。本练习 [@problem_id:3488161] 模拟了这一真实世界中的挑战，要求您实施并评估一种旨在抑制伪记忆效应的物理约束方法。通过强制要求邦迪新闻函数 $N(u)$ 在整个时间窗口内的积分为零，您可以有效地消除由数值偏差累积产生的非物理性漂移，从而显著提高重建波形的物理保真度。", "problem": "您的任务是使用适用于数值相对论的形式体系，从渐近平直时空未来类光无穷远处的曲率分量重构无量纲的引力波应变 $h(u)$。设 $u$ 表示以秒为单位的推迟时，并考虑应变的单个极化。基本关系如下：Bondi 新闻函数 $N(u)$ 满足 $N(u) = \\dfrac{dh(u)}{du}$，辐射 Weyl 标量 $\\psi_4(u)$ 满足 $\\psi_4(u) = \\dfrac{d^2 h(u)}{du^2}$。在真实的数值相对论数据中，当进行长时间积分时，$\\psi_4(u)$ 中的微小低频偏置会在重构的 $h(u)$ 中产生非物理的长期增长（伪记忆）。可以使用一个有原则的约束来抑制这种漂移。具体来说，通过选择第一个积分常数来施加零净记忆条件，使得在模拟窗口内的净应变变化为零，即 $\\int_{u_0}^{u_1} du\\,N(u) = 0$，以减轻由数值偏置引起的伪记忆累积。角度必须以弧度处理。\n\n构建一个独立的程序，该程序：\n- 使用一个基于物理动机的合成信号来生成测试曲率数据。通过 $h_{\\mathrm{true}}(u) = A(u)\\sin\\phi(u)$ 定义应变模型，其中 $A(u) = A_0(1+\\beta u)$ 且 $\\phi(u) = 2\\pi\\left(f_0 u + \\dfrac{g}{2}u^2\\right)$，$A_0$、$\\beta$、$f_0$ 和 $g$ 为常数。由此，利用 $A'(u)$、$A''(u)$、$\\phi'(u)$ 和 $\\phi''(u)$ 的基本关系，通过对 $h_{\\mathrm{true}}(u)$ 进行两次解析微分来构建 $\\psi_4^{\\mathrm{true}}(u)$。然后，通过 $\\psi_4^{\\mathrm{NR}}(u) = \\psi_4^{\\mathrm{true}}(u) + b + d_0\\sin\\left(2\\pi f_d u\\right)$ 形成一个合成的数值相对论信号，其中 $b$ 是一个小的常数偏置，$d_0$ 和 $f_d$ 代表表示低频数值污染的慢漂移分量。\n- 在给定的时间区间 $[0,T]$ 上，使用数值时间积分从 $\\psi_4^{\\mathrm{NR}}(u)$ 以两种方式重构 $h(u)$：\n    1. 基线重构，忽略对 $N(u)$ 的任何约束，即从 $\\psi_4^{\\mathrm{NR}}(u)$ 到 $N(u)$ 再到 $h(u)$ 的连续数值积分，积分常数均为零。\n    2. 约束重构，在第一次积分后通过适当地选择第一个积分常数来强制执行 $\\int_0^T du\\,N(u)=0$。具体来说，通过对 $\\psi_4^{\\mathrm{NR}}(u)$ 积分一次得到初步的 $N_0(u)$ 后，设置 $N(u) = N_0(u) + c$，并选择常数 $c$ 使得 $\\int_0^T du\\,N(u)=0$ 在该窗口上成立，然后积分得到 $h(u)$，第二次积分的积分常数为零。\n- 在从两个信号中移除任何常数偏移后，通过在归一化均方根意义上比较约束重构与真实应变来量化约束的有效性。令 $\\overline{x}$ 表示信号 $x(u)$ 在 $[0,T]$ 上的时间平均值，并定义去均值信号 $\\tilde{h}_{\\mathrm{corr}}(u) = h_{\\mathrm{corr}}(u) - \\overline{h_{\\mathrm{corr}}}$ 和 $\\tilde{h}_{\\mathrm{true}}(u) = h_{\\mathrm{true}}(u) - \\overline{h_{\\mathrm{true}}}$。类似地定义 $\\tilde{h}_{\\mathrm{uncorr}}(u) = h_{\\mathrm{uncorr}}(u) - \\overline{h_{\\mathrm{uncorr}}}$。计算每种重构的归一化均方根误差如下：\n$$\n\\mathrm{NRMSE}_{\\mathrm{corr}} = \\frac{\\sqrt{\\frac{1}{T}\\int_0^T \\left(\\tilde{h}_{\\mathrm{corr}}(u) - \\tilde{h}_{\\mathrm{true}}(u)\\right)^2 du}}{\\sqrt{\\frac{1}{T}\\int_0^T \\left(\\tilde{h}_{\\mathrm{true}}(u)\\right)^2 du}},\\quad\n\\mathrm{NRMSE}_{\\mathrm{uncorr}} = \\frac{\\sqrt{\\frac{1}{T}\\int_0^T \\left(\\tilde{h}_{\\mathrm{uncorr}}(u) - \\tilde{h}_{\\mathrm{true}}(u)\\right)^2 du}}{\\sqrt{\\frac{1}{T}\\int_0^T \\left(\\tilde{h}_{\\mathrm{true}}(u)\\right)^2 du}}.\n$$\n报告有效性比率\n$$\nR(T) = \\frac{\\mathrm{NRMSE}_{\\mathrm{corr}}}{\\mathrm{NRMSE}_{\\mathrm{uncorr}}}.\n$$\n$R(T)  1$ 的值表明施加的约束带来了改善。\n\n使用以下参数值和单位：\n- 时间单位为秒，应变为无量纲，角度单位为弧度。\n- 采样率为 $4096$ Hz（即时间步长 $\\Delta u = 1/4096$ s）。\n- 模型参数：$A_0 = 1\\times 10^{-21}$，$f_0 = 50$ Hz，$g = 50$ Hz/s，以及 $\\beta = \\dfrac{0.2}{T}$。\n- 偏置和漂移参数：$b = 5\\times 10^{-18}$ s$^{-2}$，$d_0 = 2\\times 10^{-17}$ s$^{-2}$，$f_d = 0.2$ Hz。\n\n测试套件：\n- 案例 1：$T = 0.5$ s（短时运行，少量周期）。\n- 案例 2：$T = 1.0$ s（中等时长）。\n- 案例 3：$T = 2.0$ s（长时运行，伪记忆累积更强）。\n\n您的程序必须生成单行输出，其中包含三个测试案例的结果，格式为方括号内以逗号分隔的列表，即 $[R(T_1),R(T_2),R(T_3)]$，其中每个条目都是一个浮点数。不应打印任何其他文本。", "solution": "用户要求解决一个涉及从曲率数据重构引力波应变的问题，这是数值相对论中的一项常见任务。问题的核心是演示一种方法，用于减轻因输入曲率数据中的数值偏置而产生的非物理长期漂移（伪记忆）。\n\n该问题被评估为 **有效**。它在科学上基于广义相对论和引力波物理学的原理，特别是未来类光无穷远处的各种关系。问题定义明确，提供了所有必要的定义、常数和清晰的算法路径。参数是现实的，该任务是基于物理的数据分析中一个标准但并非无足轻重的练习。\n\n**1. 引力波信号的解析模型**\n\n问题定义了一个合成的“真实”引力波应变信号 $h_{\\mathrm{true}}(u)$，它作为评估重构方法的基准真相。该信号被建模为一个振幅随时间变化的啁啾信号。\n\n真实应变由 $h_{\\mathrm{true}}(u) = A(u)\\sin\\phi(u)$ 给出，其中：\n- 振幅：$A(u) = A_0(1+\\beta u)$\n- 相位：$\\phi(u) = 2\\pi\\left(f_0 u + \\dfrac{g}{2}u^2\\right)$\n\n此处，$u$ 是推迟时，$A_0$ 是初始振幅，$\\beta$ 控制振幅的线性增长，$f_0$ 是初始频率，$g$ 是啁啾率。\n\n连接应变 $h(u)$、Bondi 新闻函数 $N(u)$ 和 Weyl 标量 $\\psi_4(u)$ 的基本关系是：\n$$\nN(u) = \\frac{dh(u)}{du} = \\dot{h}(u)\n$$\n$$\n\\psi_4(u) = \\frac{dN(u)}{du} = \\frac{d^2h(u)}{du^2} = \\ddot{h}(u)\n$$\n\n为了生成合成曲率数据，我们必须解析计算 $h_{\\mathrm{true}}(u)$ 的二阶时间导数。我们首先列出振幅和相位函数的导数：\n- $A'(u) = \\dfrac{dA}{du} = A_0\\beta$\n- $A''(u) = \\dfrac{d^2A}{du^2} = 0$\n- $\\phi'(u) = \\dfrac{d\\phi}{du} = 2\\pi(f_0 + gu)$\n- $\\phi''(u) = \\dfrac{d^2\\phi}{du^2} = 2\\pi g$\n\n使用乘法法则和链式法则，$h_{\\mathrm{true}}(u)$ 的一阶导数是：\n$$\n\\dot{h}_{\\mathrm{true}}(u) = A'(u)\\sin\\phi(u) + A(u)\\phi'(u)\\cos\\phi(u)\n$$\n\n二阶导数 $\\psi_4^{\\mathrm{true}}(u) = \\ddot{h}_{\\mathrm{true}}(u)$ 是：\n$$\n\\ddot{h}_{\\mathrm{true}}(u) = \\frac{d}{du} \\left[ A'(u)\\sin\\phi(u) + A(u)\\phi'(u)\\cos\\phi(u) \\right]\n$$\n$$\n\\ddot{h}_{\\mathrm{true}}(u) = \\left[ A''(u)\\sin\\phi(u) + A'(u)\\phi'(u)\\cos\\phi(u) \\right] + \\left[ A'(u)\\phi'(u)\\cos\\phi(u) + A(u)\\phi''(u)\\cos\\phi(u) - A(u)(\\phi'(u))^2\\sin\\phi(u) \\right]\n$$\n代入 $A''(u) = 0$ 并合并项，我们得到真实 Weyl 标量的解析表达式：\n$$\n\\psi_4^{\\mathrm{true}}(u) = \\left[ 2A'(u)\\phi'(u) + A(u)\\phi''(u) \\right]\\cos\\phi(u) - A(u)(\\phi'(u))^2\\sin\\phi(u)\n$$\n这个表达式使我们能够生成理想的曲率信号。\n\n合成的数值相对论信号 $\\psi_4^{\\mathrm{NR}}(u)$ 是通过用一个常数偏置 $b$ 和一个低频漂移项来破坏这个真实信号而形成的，这代表了常见的数值误差来源：\n$$\n\\psi_4^{\\mathrm{NR}}(u) = \\psi_4^{\\mathrm{true}}(u) + b + d_0\\sin\\left(2\\pi f_d u\\right)\n$$\n\n**2. 应变重构算法**\n\n任务的核心是通过在时间区间 $[0, T]$ 上对 $\\psi_4^{\\mathrm{NR}}(u)$ 进行两次数值积分来重构应变 $h(u)$。我们比较两种方法。\n\n**2.1. 基线（未校正）重构**\n\n该方法代表一种朴素的二次积分，其中每一步的积分常数都设置为零。\n1. 积分 $\\psi_4^{\\mathrm{NR}}(u)$ 以求得新闻函数，假设 $N(0)=0$：\n   $$\n   N_{\\mathrm{uncorr}}(u) = \\int_0^u \\psi_4^{\\mathrm{NR}}(u') du'\n   $$\n2. 积分 $N_{\\mathrm{uncorr}}(u)$ 以求得应变，假设 $h(0)=0$：\n   $$\n   h_{\\mathrm{uncorr}}(u) = \\int_0^u N_{\\mathrm{uncorr}}(u') du'\n   $$\n$\\psi_4^{\\mathrm{NR}}(u)$ 中的偏置项将导致 $N_{\\mathrm{uncorr}}(u)$ 随时间线性增长，因此，$h_{\\mathrm{uncorr}}(u)$ 将呈平方级增长，这是一种被称为伪记忆的非物理伪影。\n\n**2.2. 约束（校正）重构**\n\n此方法引入一个物理约束来抑制伪记忆。该约束是在观测时间 $T$ 内应变的净变化为零，这等价于要求净积分新闻为零：$\\int_0^T N(u) du = 0$。\n\n1. 对 $\\psi_4^{\\mathrm{NR}}(u)$ 进行一次初步积分，得到一个中间新闻函数 $N_0(u)$：\n   $$\n   N_0(u) = \\int_0^u \\psi_4^{\\mathrm{NR}}(u') du'\n   $$\n2. 校正后的新闻函数 $N_{\\mathrm{corr}}(u)$ 通过加上一个未知的积分常数 $c$ 来定义：\n   $$\n   N_{\\mathrm{corr}}(u) = N_0(u) + c\n   $$\n3. 常数 $c$ 通过强制执行零净记忆约束来确定：\n   $$\n   \\int_0^T N_{\\mathrm{corr}}(u) du = \\int_0^T (N_0(u) + c) du = \\int_0^T N_0(u) du + cT = 0\n   $$\n   解出 $c$：\n   $$\n   c = -\\frac{1}{T}\\int_0^T N_0(u) du\n   $$\n4. 积分校正后的新闻函数 $N_{\\mathrm{corr}}(u)$ 以获得最终应变，第二次积分的积分常数同样为零：\n   $$\n   h_{\\mathrm{corr}}(u) = \\int_0^u N_{\\mathrm{corr}}(u') du'\n   $$\n\n**3. 有效性量化**\n\n为了评估改善效果，我们将两种重构 $h_{\\mathrm{uncorr}}(u)$ 和 $h_{\\mathrm{corr}}(u)$ 与基准真相 $h_{\\mathrm{true}}(u)$ 进行比较。由于我们关心的是振荡动力学而非恒定偏移，我们首先对所有信号进行去均值处理。去均值信号 $\\tilde{x}(u)$ 定义为 $\\tilde{x}(u) = x(u) - \\overline{x}$，其中 $\\overline{x}$ 是在 $[0, T]$ 上的时间平均值：\n$$\n\\overline{x} = \\frac{1}{T}\\int_0^T x(u) du\n$$\n比较是使用归一化均方根误差 (NRMSE)进行的，对于一个通用的重构信号 $h_{\\mathrm{rec}}(u)$，其定义为：\n$$\n\\mathrm{NRMSE} = \\frac{\\sqrt{\\frac{1}{T}\\int_0^T \\left(\\tilde{h}_{\\mathrm{rec}}(u) - \\tilde{h}_{\\mathrm{true}}(u)\\right)^2 du}}{\\sqrt{\\frac{1}{T}\\int_0^T \\left(\\tilde{h}_{\\mathrm{true}}(u)\\right)^2 du}} = \\frac{\\left\\|\\tilde{h}_{\\mathrm{rec}} - \\tilde{h}_{\\mathrm{true}}\\right\\|_{\\mathrm{RMS}}}{\\left\\|\\tilde{h}_{\\mathrm{true}}\\right\\|_{\\mathrm{RMS}}}\n$$\n最终的度量标准是校正后重构的 NRMSE 与未校正重构的 NRMSE 之比：\n$$\nR(T) = \\frac{\\mathrm{NRMSE}_{\\mathrm{corr}}}{\\mathrm{NRMSE}_{\\mathrm{uncorr}}}\n$$\n$R(T)  1$ 的值表示约束重构比基线方法更准确。预期是随着 $T$ 的增加，该比率会减小，因为在未校正的情况下，伪记忆会随着积分时间的延长而恶化，而约束方法旨在抑制这种增长。数值积分使用梯形法则执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Solves the problem of gravitational wave strain reconstruction from curvature,\n    comparing a baseline method with a constrained method designed to mitigate\n    spurious memory.\n    \"\"\"\n\n    # --- Define physical and numerical parameters ---\n    # Strain model parameters\n    A0 = 1.0e-21  # Initial strain amplitude (dimensionless)\n    f0 = 50.0     # Initial frequency (Hz)\n    g = 50.0      # Chirp rate (Hz/s)\n\n    # Numerical error model parameters\n    b = 5.0e-18   # Constant bias (s^-2)\n    d0 = 2.0e-17  # Drift amplitude (s^-2)\n    fd = 0.2      # Drift frequency (Hz)\n\n    # Numerical parameters\n    fs = 4096.0   # Sampling rate (Hz)\n\n    # --- Test Cases ---\n    test_cases = [0.5, 1.0, 2.0]  # Durations T in seconds\n\n    results = []\n\n    for T in test_cases:\n        # --- 1. Generate Synthetic Data ---\n\n        # Set up time grid for the given duration T\n        # np.linspace is used for precision and to include the endpoint T.\n        num_points = int(T * fs) + 1\n        u = np.linspace(0, T, num=num_points)\n        dt = u[1] - u[0]\n\n        # Case-dependent parameter\n        beta = 0.2 / T  # Amplitude growth rate (s^-1)\n\n        # Define analytical functions and their derivatives\n        # Amplitude\n        A_u = A0 * (1 + beta * u)\n        A_prime_u = A0 * beta\n        # Phase (already in radians)\n        phi_u = 2 * np.pi * (f0 * u + 0.5 * g * u**2)\n        phi_prime_u = 2 * np.pi * (f0 + g * u)\n        phi_double_prime_u = 2 * np.pi * g\n\n        # Generate true strain h_true(u)\n        h_true = A_u * np.sin(phi_u)\n\n        # Generate true curvature psi4_true(u) using the analytical formula\n        # psi4 = (2*A'*phi' + A*phi'')*cos(phi) - A*(phi')^2*sin(phi)\n        cos_phi = np.cos(phi_u)\n        sin_phi = np.sin(phi_u)\n        term1 = (2 * A_prime_u * phi_prime_u + A_u * phi_double_prime_u) * cos_phi\n        term2 = -A_u * (phi_prime_u**2) * sin_phi\n        psi4_true = term1 + term2\n\n        # Generate corrupted curvature signal psi4_NR(u)\n        bias_drift = b + d0 * np.sin(2 * np.pi * fd * u)\n        psi4_nr = psi4_true + bias_drift\n\n        # --- 2. Reconstruct Strain from Corrupted Data ---\n\n        # Method 1: Baseline (Uncorrected) Reconstruction\n        # Integrate psi4_nr - N_uncorr, with N(0)=0\n        N_uncorr = cumulative_trapezoid(psi4_nr, x=u, initial=0)\n        # Integrate N_uncorr - h_uncorr, with h(0)=0\n        h_uncorr = cumulative_trapezoid(N_uncorr, x=u, initial=0)\n\n        # Method 2: Constrained (Corrected) Reconstruction\n        # First integration to get preliminary news N0\n        N0 = cumulative_trapezoid(psi4_nr, x=u, initial=0)\n        # Calculate the correction constant c to enforce zero net memory\n        integral_N0 = np.trapz(N0, x=u)\n        c = -integral_N0 / T\n        # Apply correction\n        N_corr = N0 + c\n        # Second integration to get corrected strain h_corr\n        h_corr = cumulative_trapezoid(N_corr, x=u, initial=0)\n        \n        # --- 3. Quantify Efficacy ---\n\n        # Demean all signals by subtracting their time-average\n        # Averages are computed via numerical integration (trapezoidal rule)\n        mean_h_true = np.trapz(h_true, x=u) / T\n        mean_h_uncorr = np.trapz(h_uncorr, x=u) / T\n        mean_h_corr = np.trapz(h_corr, x=u) / T\n\n        h_true_tilde = h_true - mean_h_true\n        h_uncorr_tilde = h_uncorr - mean_h_uncorr\n        h_corr_tilde = h_corr - mean_h_corr\n\n        # Calculate the squared integrals for NRMSE\n        # Note: The 1/T factor in the NRMSE formula cancels out.\n        # err_sq_integral = integral( (h_rec_tilde - h_true_tilde)^2 du )\n        # norm_sq_integral = integral( h_true_tilde^2 du )\n        # NRMSE = sqrt(err_sq_integral / norm_sq_integral)\n\n        integral_norm_sq = np.trapz(h_true_tilde**2, x=u)\n        \n        # Uncorrected NRMSE\n        integral_err_uncorr_sq = np.trapz((h_uncorr_tilde - h_true_tilde)**2, x=u)\n        nrmse_uncorr = np.sqrt(integral_err_uncorr_sq / integral_norm_sq)\n\n        # Corrected NRMSE\n        integral_err_corr_sq = np.trapz((h_corr_tilde - h_true_tilde)**2, x=u)\n        nrmse_corr = np.sqrt(integral_err_corr_sq / integral_norm_sq)\n        \n        # Compute the efficacy ratio R(T)\n        R_T = nrmse_corr / nrmse_uncorr\n        results.append(R_T)\n        \n    # --- Final Output ---\n    # Print the results in the required format: [R(T1),R(T2),R(T3)]\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3488161"}, {"introduction": "从数学上看，对 $\\ddot{h}(t) = \\psi_4(t)$ 进行积分会引入两个未定的积分常数，$c_0$ 和 $c_1$，它们分别代表了应变的初始偏移和线性漂移。传统方法通常对这些常数做出简单假设（例如，设为零），但这可能与物理实际不符。本练习 [@problem_id:3488180] 引入了一种更先进、更严谨的处理方法：贝叶斯推断。您将不再把积分常数视为需要“修正”的麻烦，而是将其作为模型中需要推断的未知参数。通过构建一个贝叶斯线性模型，您可以将来自数据的证据（似然）与关于探测器基线稳定性和早期时间物理行为的先验知识相结合，从而得到对这些常数的最可能估计及其不确定性，实现了从确定性校正到概率性推断的认知升级。", "problem": "您需要设计并实现一个贝叶斯重建方案，用于在横向无迹（Transverse–Traceless）规范下，从 Newman–Penrose 标量曲率分量 $\\Psi_4(t)$ 重建无量纲的引力波应变 $h(t)$，重点是推断积分常数。基本出发点是经过充分检验的关系式，该关系式在弱场辐射区有效，即复数外尔（Weyl）标量满足 $\\Psi_4(t) = \\ddot{h}_+(t) - i \\ddot{h}_\\times(t)$，其中 $h_+(t)$ 和 $h_\\times(t)$ 是应变的两个偏振分量。在此问题中，您将仅关注单个实偏振，将 $\\psi_4(t) = \\ddot{h}(t)$ 视为已知的输入函数。\n\n以此为基础，我们使用一个恒等式，即任何满足 $\\ddot{h}(t) = \\psi_4(t)$ 的可二次积分函数 $h(t)$ 都可以表示为\n$$\nh(t) = c_0 + c_1\\,t + \\int_0^t (t - \\tau)\\,\\psi_4(\\tau)\\,d\\tau,\n$$\n其中 $c_0 = h(0)$ 和 $c_1 = \\dot{h}(0)$ 是积分常数，它们编码了探测器的基线和漂移。这些常数不受 $\\psi_4(t)$ 的直接约束，必须根据数据和物理约束进行推断。\n\n您将构建一个贝叶斯线性模型，其中 $c_0$ 和 $c_1$ 的高斯先验由探测器基线信息提供，并包含一个物理约束，即在早期时间近似为零净位移。该约束通过伪观测实现，在信号前区间内倾向于 $h(t) \\approx 0$。似然函数为高斯分布，且噪声方差已知。所有计算必须在均匀采样的时间序列上执行。\n\n数学规格：\n- 设采样间隔为 $\\Delta t$（单位：秒），采样时间为 $t_i = i\\,\\Delta t$，其中 $i = 0, 1, \\dots, N-1$。\n- 通过累积积分定义双重积分核：设 $F(t) = \\int_0^t \\psi_4(\\tau)\\,d\\tau$ 和 $G(t) = \\int_0^t F(\\tau)\\,d\\tau$。那么 $G(t)$ 满足 $G(0)=0$，$\\dot{G}(0)=0$ 和 $\\ddot{G}(t) = \\psi_4(t)$。应变模型为\n$$\nh(t_i) = G(t_i) + c_0 + c_1\\,t_i.\n$$\n- 观测值建模为 $y_i = h(t_i) + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma_i^2)$ 且相互独立。\n- 常数的高斯先验为 $(c_0, c_1)^\\top \\sim \\mathcal{N}(\\mu, \\Sigma)$，其中 $\\mu = (\\mu_0, \\mu_1)^\\top$ 且 $\\Sigma = \\mathrm{diag}(\\sigma_{c_0}^2, \\sigma_{c_1}^2)$。\n- 早期时间的物理约束通过在信号前区间 $[0, T_{\\mathrm{pre}}]$ 上添加伪观测来实现，目标值为 $y_i^{\\mathrm{pre}} = 0$，方差较小，为 $\\sigma_{\\mathrm{pre}}^2$。这些伪观测在线性高斯框架下与真实观测的处理方式完全相同。\n\n以矩阵形式，定义设计矩阵 $X \\in \\mathbb{R}^{M \\times 2}$，其行向量为 $[1, t_i]$，包含所有真实观测和伪观测；定义向量 $d \\in \\mathbb{R}^M$，它堆叠了真实数据的 $y_i - G(t_i)$ 和伪数据的 $y_i^{\\mathrm{pre}} - G(t_i)$；以及一个对角权重矩阵 $W = \\mathrm{diag}(\\sigma_i^{-2})$，覆盖所有 $M$ 个条目。$(c_0, c_1)$ 的后验分布是高斯分布，其精度和均值由下式给出：\n$$\n\\Lambda_{\\mathrm{post}} = \\Sigma^{-1} + X^\\top W X,\\quad\n\\mu_{\\mathrm{post}} = \\Lambda_{\\mathrm{post}}^{-1}\\left(\\Sigma^{-1}\\mu + X^\\top W d\\right).\n$$\n您必须实现此计算并报告 $(c_0, c_1)$ 的后验均值 $\\mu_{\\mathrm{post}}$。\n\n单位和角度规格：\n- 时间必须以秒表示，所有时域量的角频率必须使用弧度。\n- 应变 $h(t)$ 和常数 $c_0$ 是无量纲的。常数 $c_1$ 的单位是 $\\mathrm{s}^{-1}$。曲率 $\\psi_4(t)$ 的单位是 $\\mathrm{s}^{-2}$。\n\n数值离散化：\n- 在均匀网格上使用梯形累积积分计算 $F(t)$ 和 $G(t)$。\n- 如果您从一个已知的应变模板 $h_{\\mathrm{base}}(t)$ 生成 $\\psi_4(t)$，您可以通过二阶有限差分来近似 $\\ddot{h}_{\\mathrm{base}}(t)$。\n\n必需的程序行为：\n- 实现贝叶斯推断，计算下述三个测试案例中 $(c_0, c_1)$ 的后验均值。\n- 所有输出均使用上述指定单位。最终输出必须是程序打印的单行内容，包含一个逗号分隔的 Python 浮点数列表，顺序为 $[c_{0,\\mathrm{case\\,1}}, c_{1,\\mathrm{case\\,1}}, c_{0,\\mathrm{case\\,2}}, c_{1,\\mathrm{case\\,2}}, c_{0,\\mathrm{case\\,3}}, c_{1,\\mathrm{case\\,3}}]$。\n- 不允许用户输入或外部文件。\n\n测试套件（所有数值均为 LaTeX 格式，必须按规定精确使用）：\n\n案例 1（正弦高斯爆发，理想情况）：\n- 采样：$N = 1200$, $\\Delta t = 2.5\\times 10^{-4}\\,\\mathrm{s}$。\n- 爆发模板：$h_{\\mathrm{base}}(t) = H\\,\\exp\\!\\left(-\\frac{(t - t_0)^2}{2\\sigma^2}\\right)\\sin\\!\\left(\\omega\\,(t - t_0)\\right)$，其中 $H = 3.0\\times 10^{-22}$, $t_0 = 0.10\\,\\mathrm{s}$, $\\sigma = 8.0\\times 10^{-3}\\,\\mathrm{s}$, $\\omega = 2\\pi \\times 150\\,\\mathrm{rad/s}$。\n- 真实常数：$c_0^{\\mathrm{true}} = 2.0\\times 10^{-23}$ (无量纲), $c_1^{\\mathrm{true}} = -1.0\\times 10^{-23}\\,\\mathrm{s}^{-1}$。\n- 观测噪声：对于所有 $i$, $\\sigma_{\\mathrm{obs}} = 3.0\\times 10^{-23}$。\n- 先验：$\\mu_0 = 0$, $\\mu_1 = 0$, $\\sigma_{c_0} = 1.0\\times 10^{-22}$, $\\sigma_{c_1} = 5.0\\times 10^{-23}\\,\\mathrm{s}^{-1}$。\n- 早期时间约束：$T_{\\mathrm{pre}} = 0.05\\,\\mathrm{s}$, $\\sigma_{\\mathrm{pre}} = 1.0\\times 10^{-23}$，目标值 $y_i^{\\mathrm{pre}} = 0$。\n\n案例 2（边界条件，无曲率信号）：\n- 采样：$N = 1200$, $\\Delta t = 2.5\\times 10^{-4}\\,\\mathrm{s}$。\n- 曲率：对于所有 $t$, $\\psi_4(t) = 0$。\n- 真实常数：$c_0^{\\mathrm{true}} = 1.0\\times 10^{-22}$, $c_1^{\\mathrm{true}} = 0\\,\\mathrm{s}^{-1}$。\n- 观测噪声：对于所有 $i$, $\\sigma_{\\mathrm{obs}} = 2.0\\times 10^{-23}$。\n- 先验：$\\mu_0 = 0$, $\\mu_1 = 0$, $\\sigma_{c_0} = 1.5\\times 10^{-22}$, $\\sigma_{c_1} = 5.0\\times 10^{-23}\\,\\mathrm{s}^{-1}$。\n- 早期时间约束：$T_{\\mathrm{pre}} = 0.05\\,\\mathrm{s}$, $\\sigma_{\\mathrm{pre}} = 1.0\\times 10^{-23}$，目标值 $y_i^{\\mathrm{pre}} = 0$。\n\n案例 3（边缘案例，类记忆斜坡）：\n- 采样：$N = 1200$, $\\Delta t = 2.5\\times 10^{-4}\\,\\mathrm{s}$。\n- 记忆模板：$h_{\\mathrm{base}}(t) = H_{\\mathrm{mem}}\\times \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{t - t_0}{\\tau}\\right)\\right)$，其中 $H_{\\mathrm{mem}} = 2.0\\times 10^{-22}$, $t_0 = 0.12\\,\\mathrm{s}$, $\\tau = 1.0\\times 10^{-2}\\,\\mathrm{s}$。\n- 真实常数：$c_0^{\\mathrm{true}} = -4.0\\times 10^{-23}$, $c_1^{\\mathrm{true}} = 1.0\\times 10^{-23}\\,\\mathrm{s}^{-1}$。\n- 观测噪声：对于所有 $i$, $\\sigma_{\\mathrm{obs}} = 3.0\\times 10^{-23}$。\n- 先验：$\\mu_0 = 0$, $\\mu_1 = 0$, $\\sigma_{c_0} = 1.0\\times 10^{-22}$, $\\sigma_{c_1} = 5.0\\times 10^{-23}\\,\\mathrm{s}^{-1}$。\n- 早期时间约束：$T_{\\mathrm{pre}} = 0.05\\,\\mathrm{s}$, $\\sigma_{\\mathrm{pre}} = 1.0\\times 10^{-23}$，目标值 $y_i^{\\mathrm{pre}} = 0$。\n\n实现要求：\n- 对于具有非零基础应变 $h_{\\mathrm{base}}(t)$ 的案例，通过对均匀网格上的 $\\ddot{h}_{\\mathrm{base}}(t)$ 进行二阶有限差分近似来生成 $\\psi_4(t)$。对于无信号案例，恒定设置 $\\psi_4(t) = 0$。\n- 将观测应变构造为 $h_{\\mathrm{true}}(t_i) = h_{\\mathrm{base}}(t_i) + c_0^{\\mathrm{true}} + c_1^{\\mathrm{true}}\\,t_i$ 和 $y_i = h_{\\mathrm{true}}(t_i) + \\epsilon_i$，其中 $\\epsilon_i$ 从均值为零、方差指定的高斯分布中抽样。\n- 通过在网格上进行累积梯形积分来构造 $F(t)$ 和 $G(t)$。\n- 严格按照上述描述实现后验计算。\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，顺序和单位均按规定。\n\n最终输出必须是一个包含 6 个浮点数的 Python 列表，顺序为 $[c_{0,\\mathrm{case\\,1}}, c_{1,\\mathrm{case\\,1}}, c_{0,\\mathrm{case\\,2}}, c_{1,\\mathrm{case\\,2}}, c_{0,\\mathrm{case\\,3}}, c_{1,\\mathrm{case\\,3}}]$，其中 $c_0$ 无量纲，$c_1$ 单位为 $\\mathrm{s}^{-1}$。", "solution": "该问题要求实现一个贝叶斯推断方案，以确定在从 Newman–Penrose 曲率标量 $\\psi_4(t)$ 重建引力波应变 $h(t)$ 时产生的积分常数 $c_0$ 和 $c_1$。问题被限制在单个实偏振上，其控制微分方程为 $\\ddot{h}(t) = \\psi_4(t)$。\n\n解决方案分几个阶段进行：建模、离散化和贝叶斯线性回归的应用。所有数学实体均按要求使用 LaTeX 表示。\n\n### 1. 物理和统计模型\n\n应变 $h(t)$ 和曲率 $\\psi_4(t)$ 之间的关系由一个二阶常微分方程给出。$h(t)$ 的通解可以通过对 $\\psi_4(t)$ 进行两次积分来表示：\n$$\nh(t) = \\int_0^t \\left( \\int_0^s \\psi_4(\\tau) \\,d\\tau \\right) ds + c_1 t + c_0\n$$\n这里，$c_0 = h(0)$ 和 $c_1 = \\doth(0)$ 是积分常数，分别代表应变的初始偏移和速度（漂移）。这些常数不能仅由 $\\psi_4(t)$ 确定。\n\n我们定义一个对应于零初始条件的特解 $G(t)$：\n$$\nG(t) = \\int_0^t \\left( \\int_0^s \\psi_4(\\tau) \\,d\\tau \\right) ds\n$$\n使得 $G(0)=0$ 和 $\\dot{G}(0)=0$。应变模型随后可以写成未知常数 $(c_0, c_1)$ 的一个线性函数：\n$$\nh(t) = G(t) + c_0 + c_1 t\n$$\n我们在离散时间 $t_i$ 的观测值 $y_i$ 被建模为真实应变加上独立的高斯噪声：\n$$\ny_i = h(t_i) + \\epsilon_i, \\quad \\epsilon_i \\sim \\mathcal{N}(0, \\sigma_i^2)\n$$\n代入 $h(t_i)$ 的模型，我们得到一个线性回归问题：\n$$\ny_i - G(t_i) = c_0 + c_1 t_i + \\epsilon_i\n$$\n\n贝叶斯框架融合了关于常数 $(c_0, c_1)$ 的先验知识以及对应变早期行为的物理约束。\n常数的先验是一个多元高斯分布：\n$$\n\\begin{pmatrix} c_0 \\\\ c_1 \\end{pmatrix} \\sim \\mathcal{N}\\left(\\mu, \\Sigma\\right), \\quad \\text{其中 } \\mu = \\begin{pmatrix} \\mu_0 \\\\ \\mu_1 \\end{pmatrix}, \\Sigma = \\begin{pmatrix} \\sigma_{c_0}^2  0 \\\\ 0  \\sigma_{c_1}^2 \\end{pmatrix}\n$$\n在信号到达之前（即信号前区间 $[0, T_{\\mathrm{pre}}]$），应变应接近于零的物理约束通过一组伪观测实现。对于此区间内的每个时间 $t_i$，我们添加一个数据点 $y_i^{\\mathrm{pre}} = 0$，并为其指定一个小的方差 $\\sigma_{\\mathrm{pre}}^2$。这会惩罚那些在信号前区域 $h(t_i)$ 显著偏离零的解。\n\n### 2. 数值离散化\n\n连续模型在一个均匀的时间网格 $t_i = i\\,\\Delta t$（其中 $i = 0, 1, \\dots, N-1$）上实现。\n\n- **曲率生成 ($\\psi_4(t_i)$)**：对于由基础应变模板 $h_{\\mathrm{base}}(t)$ 定义的测试案例，曲率 $\\psi_4(t_i)$ 通过 $h_{\\mathrm{base}}(t_i)$ 的二阶有限差分来近似。这通过数值上应用两次标准的梯度函数来计算：$\\psi_4 \\approx \\mathtt{gradient}(\\mathtt{gradient}(h_{\\mathrm{base}}, \\Delta t), \\Delta t)$。\n\n- **应变积分 ($G(t_i)$)**：双重积分项 $G(t_i)$ 通过连续两次应用累积梯形法则来计算。首先，我们计算 $F(t_i) = \\int_0^{t_i} \\psi_4(\\tau) \\,d\\tau$，然后计算 $G(t_i) = \\int_0^{t_i} F(\\tau) \\,d\\tau$。这确保了数值上的 $G(t_i)$ 满足 $G(t_0)=0$ 并且初始导数为零。\n\n- **数据生成**：测试案例的“观测”数据 $y_i$ 是从真实应变 $h_{\\mathrm{true}}(t_i) = h_{\\mathrm{base}}(t_i) + c_0^{\\mathrm{true}} + c_1^{\\mathrm{true}} t_i$ 生成的。为确保确定性解，噪声实现被设为其均值，即 $\\epsilon_i=0$，因此 $y_i = h_{\\mathrm{true}}(t_i)$。\n\n### 3. 矩阵形式的贝叶斯线性回归\n\n推断 $(c_0, c_1)$ 的问题是一个标准的贝叶斯线性回归。我们将 $N$ 个真实观测与 $N_{\\mathrm{pre}}$ 个伪观测组合成一个大小为 $M = N + N_{\\mathrm{pre}}$ 的单一系统。\n\n- **设计矩阵 ($X$)**：设计矩阵 $X \\in \\mathbb{R}^{M \\times 2}$ 将参数 $(c_0, c_1)$ 映射到模型化的数据。每一行对应一个观测（真实的或伪的），形式为 $[1, t_i]$。\n\n- **数据向量 ($d$)**：响应向量 $d \\in \\mathbb{R}^{M}$ 包含观测值减去模型的非线性部分 $G(t_i)$。它通过堆叠真实观测的 $d_i = y_i - G(t_i)$ 和伪观测的 $d_i^{\\mathrm{pre}} = y_i^{\\mathrm{pre}} - G(t_i) = 0 - G(t_i)$ 构成。\n\n- **权重矩阵 ($W$)**：权重矩阵 $W \\in \\mathbb{R}^{M \\times M}$ 是对角矩阵，包含每个观测的逆方差（精度）。对角线元素为 $\\sigma_i^{-2}$，对于真实数据对应 $\\sigma_{\\mathrm{obs}}^{-2}$，对于伪数据对应 $\\sigma_{\\mathrm{pre}}^{-2}$。\n\n参数 $\\mathbf{c} = (c_0, c_1)^\\top$ 的后验分布是高斯分布，$p(\\mathbf{c}|y) \\sim \\mathcal{N}(\\mu_{\\mathrm{post}}, \\Lambda_{\\mathrm{post}}^{-1})$。其精度矩阵 $\\Lambda_{\\mathrm{post}}$ 和均值向量 $\\mu_{\\mathrm{post}}$ 通过结合先验和似然给出：\n$$\n\\Lambda_{\\mathrm{post}} = \\Sigma^{-1} + X^\\top W X\n$$\n$$\n\\mu_{\\mathrm{post}} = \\Lambda_{\\mathrm{post}}^{-1} \\left( \\Sigma^{-1}\\mu + X^\\top W d \\right)\n$$\n目标是计算 $\\mu_{\\mathrm{post}}$，它代表了 $(c_0, c_1)$ 的贝叶斯估计。\n\n### 4. 测试案例的实现\n\n将所述算法应用于问题陈述中指定的三个测试案例中的每一个。采样、信号模板、噪声水平、先验和物理约束的参数均按给定值使用。最终输出由每个案例计算出的后验均值的分量 $(\\mu_{\\mathrm{post},0}, \\mu_{\\mathrm{post},1})$ 组成。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to run the Bayesian inference for all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Sine-Gaussian burst\n        {\n            \"N\": 1200, \"dt\": 2.5e-4,\n            \"h_base_func\": lambda t: 3.0e-22 * np.exp(-(t - 0.10)**2 / (2 * (8.0e-3)**2)) * np.sin(2 * np.pi * 150 * (t - 0.10)),\n            \"c0_true\": 2.0e-23, \"c1_true\": -1.0e-23,\n            \"sigma_obs\": 3.0e-23,\n            \"mu0\": 0.0, \"mu1\": 0.0,\n            \"sigma_c0\": 1.0e-22, \"sigma_c1\": 5.0e-23,\n            \"T_pre\": 0.05, \"sigma_pre\": 1.0e-23\n        },\n        # Case 2: No curvature signal\n        {\n            \"N\": 1200, \"dt\": 2.5e-4,\n            \"h_base_func\": lambda t: np.zeros_like(t),\n            \"c0_true\": 1.0e-22, \"c1_true\": 0.0,\n            \"sigma_obs\": 2.0e-23,\n            \"mu0\": 0.0, \"mu1\": 0.0,\n            \"sigma_c0\": 1.5e-22, \"sigma_c1\": 5.0e-23,\n            \"T_pre\": 0.05, \"sigma_pre\": 1.0e-23\n        },\n        # Case 3: Memory-like ramp\n        {\n            \"N\": 1200, \"dt\": 2.5e-4,\n            \"h_base_func\": lambda t: 2.0e-22 * 0.5 * (1 + np.tanh((t - 0.12) / 1.0e-2)),\n            \"c0_true\": -4.0e-23, \"c1_true\": 1.0e-23,\n            \"sigma_obs\": 3.0e-23,\n            \"mu0\": 0.0, \"mu1\": 0.0,\n            \"sigma_c0\": 1.0e-22, \"sigma_c1\": 5.0e-23,\n            \"T_pre\": 0.05, \"sigma_pre\": 1.0e-23\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        c0_est, c1_est = compute_posterior_mean(params)\n        results.extend([c0_est, c1_est])\n\n    # Format the final output string exactly as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_posterior_mean(params):\n    \"\"\"\n    Performs Bayesian inference to find the posterior mean of (c0, c1) for a single test case.\n    \n    Args:\n        params (dict): A dictionary containing all parameters for the test case.\n\n    Returns:\n        tuple: A tuple containing the posterior mean of (c0, c1).\n    \"\"\"\n    # 1. Setup time grid and generate base signals\n    N, dt = params[\"N\"], params[\"dt\"]\n    t = np.arange(N) * dt\n    \n    h_base = params[\"h_base_func\"](t)\n    \n    # 2. Generate curvature psi4 and true data y\n    # For the zero-signal case, psi4 will be all zeros.\n    # np.gradient(f, dx) is used twice to get the second derivative.\n    if np.all(h_base == 0):\n        psi4 = np.zeros_like(h_base)\n    else:\n        psi4 = np.gradient(np.gradient(h_base, dt), dt)\n    \n    h_true = h_base + params[\"c0_true\"] + params[\"c1_true\"] * t\n    y = h_true  # Assuming zero noise realization for a deterministic result\n\n    # 3. Compute the integral term G(t) via cumulative trapezoidal integration\n    F = integrate.cumulative_trapezoid(psi4, t, initial=0)\n    G = integrate.cumulative_trapezoid(F, t, initial=0)\n\n    # 4. Set up the Bayesian linear model components (X, d, W)\n    # Identify indices for the pre-signal constraint\n    pre_indices = np.where(t = params[\"T_pre\"])[0]\n    N_pre = len(pre_indices)\n    \n    # Real observations\n    d_real = y - G\n    t_real = t\n    X_real = np.vstack([np.ones(N), t_real]).T\n    w_real = np.full(N, 1.0 / params[\"sigma_obs\"]**2)\n\n    # Pseudo-observations for pre-signal constraint\n    y_pre = 0.0\n    G_pre = G[pre_indices]\n    d_pre = y_pre - G_pre\n    t_pre = t[pre_indices]\n    X_pre = np.vstack([np.ones(N_pre), t_pre]).T\n    w_pre = np.full(N_pre, 1.0 / params[\"sigma_pre\"]**2)\n\n    # Combine real and pseudo observations\n    X = np.concatenate([X_real, X_pre])\n    d = np.concatenate([d_real, d_pre])\n    w_diag = np.concatenate([w_real, w_pre])\n\n    # 5. Set up the prior\n    mu_prior = np.array([params[\"mu0\"], params[\"mu1\"]])\n    Sigma_inv_prior = np.diag([1.0 / params[\"sigma_c0\"]**2, 1.0 / params[\"sigma_c1\"]**2])\n\n    # 6. Compute the posterior mean\n    # Lambda_post = Sigma_inv_prior + X^T W X\n    # The term X^T W X can be computed efficiently since W is diagonal.\n    XT_W_X = X.T @ (w_diag[:, np.newaxis] * X)\n    Lambda_post = Sigma_inv_prior + XT_W_X\n    \n    # Right-hand side of the equation for the mean:\n    # rhs = Sigma_inv_prior @ mu_prior + X^T W d\n    rhs = (Sigma_inv_prior @ mu_prior) + (X.T @ (w_diag * d))\n    \n    # mu_post = Lambda_post^-1 * rhs\n    mu_post = np.linalg.inv(Lambda_post) @ rhs\n    \n    return mu_post[0], mu_post[1]\n\n# Run the solver.\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3488180"}]}