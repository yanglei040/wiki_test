{"hands_on_practices": [{"introduction": "在动态演化的时空中，事件视界是一个“遥远未来”的概念，因为它需要整个时空的未来信息才能确定，这在数值模拟的逐步演化过程中是不现实的。因此，数值相对论学家使用准局域的定义，如“视界面”（apparent horizon），它是一个边缘外陷面（marginally outer-trapped surface, MOTS）。本练习 [@problem_id:3464688] 将引导你从 $3+1$ 分解下的第一性原理出发，推导视界面的基本条件，将抽象的几何概念与视界面求解器所使用的具体方程联系起来。", "problem": "考虑一个在广义相对论 (GR) 框架下，通过数值演化得到的双黑洞时空，并将其进行 $3+1$ 分解。设 $\\Sigma_{t}$ 是坐标时为 $t$ 的一个空间超曲面，其单位类时法向量为 $n^{a}$，诱导空间度规为 $\\gamma_{ab} = g_{ab} + n_{a} n_{b}$，外曲率为 $K_{ab} = - \\gamma_{a}^{\\ c} \\gamma_{b}^{\\ d} \\nabla_{c} n_{d}$。在 $\\Sigma_{t}$ 内部，考虑一个光滑的闭合二维面 $\\mathcal{S}$，其朝外的单位空间法向量为 $s^{a}$，满足 $s^{a} s_{a} = 1$ 和 $n^{a} s_{a} = 0$。$\\mathcal{S}$ 上的诱导二维度规为 $q_{ab} = \\gamma_{ab} - s_{a} s_{b}$。定义出射零法向量为 $l^{a} = n^{a} + s^{a}$。\n\n出射零测地线汇的膨胀定义为 $\\theta_{(l)} = q^{ab} \\nabla_{a} l_{b}$，其中 $\\nabla_{a}$ 是时空协变导数。仅使用上述定义和与 $\\gamma_{ab}$ 相关的空间列维-奇维塔联络 $D_{a}$，推导 $\\theta_{(l)}$ 的一个显式表达式，该表达式应完全用 $\\Sigma_{t}$ 上的 $3+1$ 变量表示，即 $D_{i}$、$K_{ij}$、其迹 $K = \\gamma^{ij} K_{ij}$ 和 $s^{i}$，其中指标 $i,j$ 是 $\\Sigma_{t}$ 上的空间指标。\n\n你的最终答案必须是 $\\theta_{(l)}$ 的一个关于 $D_{i}$、$K_{ij}$、$K$ 和 $s^{i}$ 的封闭形式解析表达式。最终答案中不要提供中间步骤。不需要进行数值计算或四舍五入，也无需报告单位。该表达式隐式地定义了 $\\Sigma_{t}$ 上边缘外陷获面 (MOTS) 的视界条件 $\\theta_{(l)} = 0$。", "solution": "用户希望在广义相对论的 $3+1$ 分解中，推导嵌入空间超曲面 $\\Sigma_t$ 的闭合二维面 $\\mathcal{S}$ 上的出射零测地线汇的膨胀 $\\theta_{(l)}$。最终表达式必须用空间协变导数 $D_i$、外曲率 $K_{ij}$ 及其迹 $K$、以及该二维面的空间法向量 $s^i$ 来表示。\n\n问题陈述已经过验证，被认为是有效的。这是一个数值相对论和微分几何应用于广义相对论中的标准推导。所有定义和上下文在科学上都是合理且适定的。\n\n我们从给定的膨胀定义开始推导：\n$$\n\\theta_{(l)} = q^{ab} \\nabla_{a} l_{b}\n$$\n已知条件如下：\n1.  出射零法向量：$l^{a} = n^{a} + s^{a}$，这意味着 $l_{b} = n_{b} + s_{b}$。\n2.  到二维面 $\\mathcal{S}$ 上的投影算符：$q_{ab} = \\gamma_{ab} - s_{a} s_{b}$。其在曲面切空间上的逆可以写为 $q^{ab} = \\gamma^{ab} - s^{a} s^{b}$，其中 $\\gamma^{ab}$ 是空间度规 $\\gamma_{ab}$ 的逆。注意，像 $s^a$ 和 $\\gamma_{ab}$ 这样的空间张量的指标可以用 $\\gamma_{ab}$ 和 $\\gamma^{ab}$ 来升降。\n\n将 $l_b$ 的定义代入膨胀公式，我们得到：\n$$\n\\theta_{(l)} = q^{ab} \\nabla_{a} (n_{b} + s_{b}) = q^{ab} \\nabla_{a} n_{b} + q^{ab} \\nabla_{a} s_{b}\n$$\n我们将分别分析右侧的两项。\n\n**第一项：$q^{ab} \\nabla_{a} n_{b}$**\n\n这一项涉及空间超曲面 $\\Sigma_t$ 的类时单位法向量 $n_b$ 的时空协变导数。在 $3+1$ 形式中，$\\nabla_a n_b$ 的分解由魏恩加滕方程给出：\n$$\n\\nabla_a n_b = -K_{ab} + n_a a_b\n$$\n其中 $K_{ab} = - \\gamma_{a}^{\\ c} \\gamma_{b}^{\\ d} \\nabla_{c} n_{d}$ 是外曲率（一个空间张量），$a_b = n^c \\nabla_c n_b$ 是其世界线与 $\\Sigma_t$ 正交的基准观测者的加速度。\n\n将此代入第一项：\n$$\nq^{ab} \\nabla_{a} n_{b} = q^{ab} (-K_{ab} + n_a a_b) = - q^{ab} K_{ab} + q^{ab} n_a a_b\n$$\n张量 $q^{ab}$ 是到二维面 $\\mathcal{S}$ 上的投影算符，该二维面位于空间超曲面 $\\Sigma_t$ 内。根据构造，$\\mathcal{S}$ 的切空间中的任何向量都与 $n^a$ 正交。因此，投影算符 $q^{ab}$ 是一个空间张量，意味着它没有沿 $n^a$ 的分量。这可以表示为 $q^{ab} n_a = 0$ 和 $q^{ab} n_b = 0$。\n属性 $q^{ab} n_a = 0$ 直接意味着表达式的第二部分为零：$q^{ab} n_a a_b = 0$。\n\n第一部分变为：\n$$\n-q^{ab} K_{ab} = -(\\gamma^{ab} - s^a s^b) K_{ab} = -(\\gamma^{ab} K_{ab} - s^a s^b K_{ab})\n$$\n根据定义，$\\gamma^{ab} K_{ab}$ 是外曲率的迹，记为 $K$。项 $s^a s^b K_{ab}$ 是外曲率在法向 $s^a$ 上的两次投影。由于此表达式中的所有张量（$K_{ab}$、$\\gamma^{ab}$、$s^a$）都是空间的，我们可以使用空间指标 $i, j, \\ldots$：\n$$\nq^{ab} \\nabla_{a} n_{b} = -K + K_{ij} s^i s^j\n$$\n\n**第二项：$q^{ab} \\nabla_{a} s_{b}$**\n\n这一项涉及二维面 $\\mathcal{S}$ 的空间单位法向量 $s_b$ 的时空协变导数。我们需要将其与和空间度规 $\\gamma_{ab}$ 相关的空间协变导数 $D_a$ 联系起来。\n算符 $D_a$ 的定义是通过它对空间张量的作用，这是将四维协变导数投影到空间超曲面上得到的结果。对于像 $s_b$ 这样的空间协矢量，关系式为：\n$$\nD_a s_b = \\gamma_a^c \\gamma_b^d \\nabla_c s_d\n$$\n其中 $\\gamma_a^c = g_a^c + n_a n^c$ 是到空间切片 $\\Sigma_t$ 上的投影算符。我们想计算 $q^{ab} \\nabla_a s_b$。由于 $q^{ab}$ 是一个空间张量，它满足 $q^{ab} = \\gamma_c^a \\gamma_d^b q^{cd}$。因此我们可以写出：\n$$\nq^{ab} \\nabla_a s_b = (\\gamma_c^a \\gamma_d^b q^{cd}) \\nabla_a s_b\n$$\n$\\nabla_a s_b$ 和 $D_a s_b$ 之间的关系可以通过将 $\\nabla_a s_b$ 分解为与 $\\Sigma_t$ 相切和正交的部分来找到。任何张量 $T_{ab}$ 都可以分解为 $T_{ab} = \\gamma_a^c \\gamma_b^d T_{cd} + \\dots$，其中其余项至少包含一个 $n_a$ 或 $n_b$。当我们与 $q^{ab}$ 进行缩并时，由于 $q^{ab}n_a=0$ 和 $q^{ab}n_b=0$，这些附加项会消失。因此：\n$$\nq^{ab} \\nabla_a s_b = q^{ab} (\\gamma_a^c \\gamma_b^d \\nabla_c s_d) = q^{ab} D_a s_b\n$$\n这表明，为了我们的目的，我们可以用空间导数代替时空导数。该表达式现在是纯空间的，因此我们切换到空间指标：\n$$\nq^{ij} D_i s_j = (\\gamma^{ij} - s^i s^j) D_i s_j = \\gamma^{ij} D_i s_j - s^i s^j D_i s_j\n$$\n第一部分是 $s^j$ 的空间散度：$\\gamma^{ij} D_i s_j = D_i (\\gamma^{ij} s_j) - s_j (D_i \\gamma^{ij})$。由于 $D_i$ 是度规相容的（$D_i \\gamma^{ij} = 0$），这简化为 $D_i s^i$。这一项 $D_i s^i$ 表示二维面 $\\mathcal{S}$ 作为嵌入在三维空间 $\\Sigma_t$ 中的外曲率，通常用 $\\mathcal{K}$ 表示。\n\n对于第二部分 $-s^i s^j D_i s_j$，我们利用 $s^i$ 是空间切片中的单位向量这一事实：$s_j s^j = \\gamma_{jk} s^j s^k = 1$。让我们沿 $s^i$ 方向取协变导数：\n$$\ns^i D_i (s_j s^j) = s^i D_i (1) = 0\n$$\n使用乘法法则和 $D_i$ 的度规相容性：\n$$\ns^i ( (D_i s_j)s^j + s_j(D_i s^j) ) = 0\n$$\n整理项可得：\n$$\ns^j (s^i D_i s_j) + s_j (s^i D_i s^j) = 0 \\implies 2 s^j (s^i D_i s_j) = 0\n$$\n项 $s^i D_i s_j$ 是与 $\\mathcal{S}$ 正交的曲线汇的加速度。结果 $s^j (s^i D_i s_j) = 0$ 意味着该加速度与 $s^j$ 正交。我们需要计算的量是 $-s^j(s^i D_i s_j)$，而我们刚刚证明了它恰好为零。\n因此，第二项为零：$-s^i s^j D_i s_j = 0$。\n\n所以，我们有：\n$$\nq^{ab} \\nabla_{a} s_{b} = D_i s^i\n$$\n\n**合并结果**\n\n我们现在可以将推导出的两部分相加，得到膨胀 $\\theta_{(l)}$ 的最终表达式：\n$$\n\\theta_{(l)} = (q^{ab} \\nabla_{a} n_{b}) + (q^{ab} \\nabla_{a} s_{b}) = (-K + K_{ij} s^i s^j) + (D_i s^i)\n$$\n为清晰起见，重新整理各项，我们得到：\n$$\n\\theta_{(l)} = D_i s^i + K_{ij} s^i s^j - K\n$$\n这个方程用空间切片的内蕴几何（$D_i$）、其外曲率（$K_{ij}$ 和 $K$）以及切片内二维面的几何（$s^i$）给出了出射零测地线汇的膨胀。视界（边缘外陷获面）的条件是 $\\theta_{(l)} = 0$。", "answer": "$$\n\\boxed{D_{i} s^{i} + K_{ij} s^{i} s^{j} - K}\n$$", "id": "3464688"}, {"introduction": "任何数值解的可靠性都必须通过收敛性测试来保证，即证明当网格分辨率提高时，数值解会趋近于真实的连续解。这个编码练习 [@problem_id:3464789] 将实现数值相对论中最核心的验证方法：测量收敛阶。通过分析约束违反或物理观测量如何随网格间距变化，你将验证数值格式是否达到了预期的精度，这是确保代码正确性的基石。", "problem": "考虑在几何单位制（$G = c = 1$ 且总质量 $M = 1$）下，使用 Baumgarte–Shapiro–Shibata–Nakamura (BSSN) 形式体系和协变共形Z4 (CCZ4) 形式体系，对双黑洞的旋近、并合与铃振过程进行数值演化。在此类演化中，人们将约束违背（例如，哈密顿约束和Z4约束）和视界性质（例如，质量和无量纲自旋）作为网格分辨率 $h$ 的函数进行监测，其中 $h$ 是以总质量 $M$ 为单位表示的均匀空间网格间距。\n\n数值分析的基本原理是，$p$ 阶的一致且稳定的数值离散化方案所产生的截断误差，在渐近情况下会随网格间距呈幂律关系变化，因此一个可观测误差 $\\varepsilon$ 在渐近区域内遵循 $\\varepsilon \\sim \\kappa \\, h^{p}$，其中 $\\kappa$ 是一个不依赖于 $h$ 的常数。因此，通过识别误差代理量与 $h$ 之间的幂律关系，可以从它们的测量值中推断出经验收敛阶 $p$。\n\n你需要实现一个程序，该程序接收几组分辨率 $h$ 和相应测量值的数据集，通过估计经验收敛阶 $p$ 来执行收敛性测试。对于约束测量值，你需要将所提供的约束范数 $\\lVert \\mathcal{C} \\rVert$ 直接视为误差代理量。对于视界测量值，你需要将测量性质与连续极限目标值的绝对偏差作为误差代理量。你的程序必须使用一种鲁棒的方法，通过对给定数据集中的所有分辨率拟合幂律关系 $\\varepsilon \\propto h^{p}$ 来估计 $p$，并返回指数 $p$。\n\n你的程序必须为以下每个测试用例计算经验收敛阶 $p$：\n\n- 测试用例 A（BSSN 约束范数，理想情况）：分辨率 $h = [1/48,\\, 1/64,\\, 1/80,\\, 1/96]$，测得的约束范数 $\\lVert \\mathcal{C} \\rVert = [1.884\\times 10^{-4},\\, 5.960\\times 10^{-5},\\, 2.442\\times 10^{-5},\\, 1.178\\times 10^{-5}]$。\n- 测试用例 B（CCZ4 约束范数，不同阶）：分辨率 $h = [1/40,\\, 1/56,\\, 1/72,\\, 1/88]$，测得的约束范数 $\\lVert \\mathcal{C} \\rVert = [9.766\\times 10^{-3},\\, 1.815\\times 10^{-3},\\, 5.168\\times 10^{-4},\\, 1.894\\times 10^{-4}]$。\n- 测试用例 C（视界质量，二阶行为）：连续极限目标质量 $M_{\\infty} = 0.951$，分辨率 $h = [1/48,\\, 1/64,\\, 1/80,\\, 1/96]$，测得的视界质量 $M(h) = [0.9510173611,\\, 0.951009765625,\\, 0.95100625,\\, 0.9510043402778]$。使用绝对偏差 $\\lvert M(h) - M_{\\infty} \\rvert$ 作为误差代理量。\n- 测试用例 D（视界无量纲自旋，高阶行为）：连续极限目标自旋 $\\chi_{\\infty} = 0.686$，分辨率 $h = [1/44,\\, 1/60,\\, 1/88,\\, 1/100]$，测得的视界自旋 $\\chi(h) = [0.6861334,\\, 0.68603858,\\, 0.68600834,\\, 0.686005]$。使用绝对偏差 $\\lvert \\chi(h) - \\chi_{\\infty} \\rvert$ 作为误差代理量。\n- 测试用例 E（接近底噪的约束范数，边界情况）：分辨率 $h = [1/96,\\, 1/100,\\, 1/120,\\, 1/160]$，测得的约束范数 $\\lVert \\mathcal{C} \\rVert = [1.05\\times 10^{-6},\\, 1.02\\times 10^{-6},\\, 1.01\\times 10^{-6},\\, 1.00\\times 10^{-6}]$。\n\n要求：\n- 对于每个测试用例，通过对该用例提供的所有分辨率下的误差代理量与 $h$ 之间的幂律关系进行拟合来估计经验收敛阶 $p$。估计必须使用数学上可靠的算法完成，该算法对误差代理量的缩放应具有不变性，且不单独依赖于任何单一的成对比例。\n- 不涉及角度；不需要角度单位。\n- 如果任何计算出的误差代理值为非正数，程序必须通过不尝试对非正数取对数来优雅地处理这种情况。\n- 最终输出是无量纲的，不需要物理单位。但是，你必须以几何单位制来解释测量的质量和自旋，并将与指定连续极限目标值的绝对偏差构成误差代理量。\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的估计收敛阶列表，四舍五入到三位小数，顺序为 $[p_{A},\\, p_{B},\\, p_{C},\\, p_{D},\\, p_{E}]$。\n- 你的程序必须是自包含的，不需要任何输入，并且只使用 Python 标准库以及指定的数值库。", "solution": "该问题已经过审查，被认为是有效的。它在科学上基于应用于计算相对论的数值分析原理，问题设定良好，目标明确，数据充分，并以精确、客观的语言表述。该问题是收斂性测试中的一个标准练习，这是科学计算中验证数值代码的一项基本实践。\n\n目标是为几组数值数据集确定经验收敛阶，记为 $p$。其基本原理是，一个 $p$ 阶数值近似方案的截断误差 $\\varepsilon$ 随网格分辨率 $h$ 的变化遵循以下幂律关系：\n$$ \\varepsilon(h) \\approx \\kappa h^p $$\n其中 $\\kappa$ 是一个比例常数，它取决于具体问题和数值方法，但至少在 $h$ 足够小的渐近极限下，它不依赖于分辨率 $h$。\n\n为了从一组在相应分辨率 $h_i$ 下的误差代理量 $\\varepsilon_i$ 的测量值中确定指数 $p$，我们可以通过对两边取自然对数，将幂律关系转化为线性关系：\n$$ \\ln(\\varepsilon) \\approx \\ln(\\kappa) + p \\ln(h) $$\n这个方程的形式是 $y = c + mx$，其中变量为 $y = \\ln(\\varepsilon)$ 和 $x = \\ln(h)$，y轴截距为 $c = \\ln(\\kappa)$，最重要的是，斜率就是收敛阶 $m = p$。\n\n该问题要求对每个案例使用所有可用的数据点对 $p$ 进行鲁棒的估计。线性最小二乘回归方法非常适合这项任务。给定一组 $N$ 个数据点 $(x_i, y_i)$，该方法可以找到一条直线，使得所有数据点到该直线的垂直距离的平方和最小。这条直线的斜率提供了对 $p$ 的一个鲁棒估计。给定 $N$ 个数据点 $(x_i, y_i) = (\\ln(h_i), \\ln(\\varepsilon_i))$，斜率 $p$ 的显式公式为：\n$$ p = \\frac{N \\sum_{i=1}^{N}(x_i y_i) - (\\sum_{i=1}^{N} x_i)(\\sum_{i=1}^{N} y_i)}{N \\sum_{i=1}^{N}(x_i^2) - (\\sum_{i=1}^{N} x_i)^2} $$\n这种方法满足了问题的要求：它使用了所有可用的数据，并且对误差代理量 $\\varepsilon$ 的缩放具有不变性，因为将 $\\varepsilon$ 乘以一个常数只会改变截距 $\\ln(\\kappa)$，而不会影响斜率 $p$。\n\n要实现的算法如下：\n$1$. 对于每个测试用例，整理分辨率 $\\{h_i\\}$ 和相应测量值的列表。\n$2$. 构建误差代理值 $\\{\\varepsilon_i\\}$。\n    - 对于约束范数，$\\varepsilon_i$ 是给定的范数值 $\\lVert \\mathcal{C} \\rVert_i$。\n    - 对于视界性质，$\\varepsilon_i$ 是与连续极限目标值的绝对偏差，例如 $\\varepsilon_i = \\lvert M(h_i) - M_{\\infty} \\rvert$。\n$3$. 筛选数据，只保留误差代理量 $\\varepsilon_i$ 严格为正的点，因为对数对于非正值没有定义。这确保了按要求进行的优雅处理。所提供的测试数据不包含非正误差，但此步骤对于稳健的实现至关重要。\n$4$. 通过对每个分辨率 $h_i$ 和每个误差代理量 $\\varepsilon_i$ 取自然对数来转换筛选后的数据，以获得点集 $(\\ln(h_i), \\ln(\\varepsilon_i))$。\n$5$. 对这些经过对数转换的点应用线性最小二乘回归来计算斜率，该斜率即为收敛阶 $p$ 的估计值。\n$6$. 收集所有测试用例计算出的收敛阶，并按指定格式进行格式化。\n\n对于测试用例 E，测量的约束范数几乎是恒定的，并接近一个底值，这可能是由于有限的浮点精度或其他不随分辨率降低而减小的系统效应所致。在这种情况下，误差 $\\varepsilon$ 近似为常数，因此 $\\varepsilon \\propto h^0$。因此，拟合过程预计将得出一个接近于0的收敛阶 $p$。\n\n此程序将应用于所提供的五个测试用例中的每一个。\n- 用例 A：BSSN 约束范数。$\\varepsilon_i = \\lVert \\mathcal{C} \\rVert_i$。预期 $p \\approx 4$。\n- 用例 B：CCZ4 约束范数。$\\varepsilon_i = \\lVert \\mathcal{C} \\rVert_i$。预期 $p \\approx 6$。\n- 用例 C：视界质量。$\\varepsilon_i = \\lvert M(h_i) - M_{\\infty} \\rvert$。预期 $p \\approx 2$。\n- 用例 D：视界自旋。$\\varepsilon_i = \\lvert \\chi(h_i) - \\chi_{\\infty} \\rvert$。预期 $p \\approx 4$。\n- 用例 E：处于底噪的约束范数。$\\varepsilon_i = \\lVert \\mathcal{C} \\rVert_i$。预期 $p \\approx 0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats # Scipy is allowed but numpy.polyfit is sufficient and used here.\n\ndef solve():\n    \"\"\"\n    Computes the empirical order of convergence for several numerical relativity test cases\n    by fitting a power law to the error proxy vs. grid resolution data.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: BSSN constraint norm\n        {\n            \"name\": \"A\",\n            \"resolutions\": np.array([1/48, 1/64, 1/80, 1/96]),\n            \"measurements\": np.array([1.884e-4, 5.960e-5, 2.442e-5, 1.178e-5]),\n            \"target\": None\n        },\n        # Case B: CCZ4 constraint norm\n        {\n            \"name\": \"B\",\n            \"resolutions\": np.array([1/40, 1/56, 1/72, 1/88]),\n            \"measurements\": np.array([9.766e-3, 1.815e-3, 5.168e-4, 1.894e-4]),\n            \"target\": None\n        },\n        # Case C: Apparent horizon mass\n        {\n            \"name\": \"C\",\n            \"resolutions\": np.array([1/48, 1/64, 1/80, 1/96]),\n            \"measurements\": np.array([0.9510173611, 0.951009765625, 0.95100625, 0.9510043402778]),\n            \"target\": 0.951\n        },\n        # Case D: Apparent horizon dimensionless spin\n        {\n            \"name\": \"D\",\n            \"resolutions\": np.array([1/44, 1/60, 1/88, 1/100]),\n            \"measurements\": np.array([0.6861334, 0.68603858, 0.68600834, 0.686005]),\n            \"target\": 0.686\n        },\n        # Case E: Constraint norm near floor\n        {\n            \"name\": \"E\",\n            \"resolutions\": np.array([1/96, 1/100, 1/120, 1/160]),\n            \"measurements\": np.array([1.05e-6, 1.02e-6, 1.01e-6, 1.00e-6]),\n            \"target\": None\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        h = case[\"resolutions\"]\n        measurements = case[\"measurements\"]\n        target = case[\"target\"]\n\n        # Calculate the error proxy\n        if target is not None:\n            # For apparent horizon properties, error is the absolute deviation from the continuum target\n            error_proxy = np.abs(measurements - target)\n        else:\n            # For constraint norms, the norm itself is the error proxy\n            error_proxy = measurements\n\n        # Gracefully handle non-positive error proxies by filtering them out.\n        # This is a robustness measure; the given data has only positive errors.\n        valid_indices = np.where(error_proxy > 0)\n        \n        h_filtered = h[valid_indices]\n        error_proxy_filtered = error_proxy[valid_indices]\n\n        # A linear fit requires at least 2 points.\n        if len(h_filtered)  2:\n            # Convergence order is undefined with fewer than 2 points.\n            # Storing as NaN (Not a Number) for this edge case.\n            p = np.nan\n        else:\n            # Transform to log-log space for linear fitting\n            log_h = np.log(h_filtered)\n            log_error = np.log(error_proxy_filtered)\n\n            # Perform a linear least-squares fit (degree 1 polynomial)\n            # np.polyfit returns the coefficients [slope, intercept]\n            # The slope is the desired convergence order 'p'.\n            p, _ = np.polyfit(log_h, log_error, 1)\n\n        results.append(p)\n\n    # Format the final output as a comma-separated list of orders,\n    # rounded to three decimal places, enclosed in square brackets.\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\nsolve()\n```", "id": "3464789"}, {"introduction": "数值模拟在有限的计算区域内进行，但引力波的观测者实际上处于无穷远处。因此，将在有限半径处提取的引力波信号外推至零无穷（null infinity）是至关重要的一步。这个编码实践 [@problem_id:3464669] 聚焦于这一关键的数据分析环节，你将通过实现一个简单的外推方案并量化其精度，来理解如何将物理辐射与近场效应及规范效应分离开来。", "problem": "您将接触一个用于从双黑洞（BBH）模拟中提取引力波应变的简化但科学上一致的数值相对论（NR）模型。在大的提取半径处，在半径为 $R$ 的坐标球面上测得的应变具有一个与主导阶辐射衰减一致的渐近展开，其形式可简写为\n$$\nh(t,R) = h_\\infty(t) + \\frac{c(t)}{R} + \\frac{d(t)}{R^2} + \\mathcal{O}\\!\\left(\\frac{1}{R^3}\\right),\n$$\n其中 $h_\\infty(t)$ 是零无穷远处的应变，$c(t)$ 包含了按 $1/R$ 标度的次主导辐射和规范贡献，$d(t)$ 则捕捉了按 $1/R^2$ 标度的高阶有限半径效应。目标是实现一个仅使用主导阶模型 $h(t,R) \\approx h_\\infty(t) + c(t)/R$ 的时间局域外推方案，并根据已知的基准真相 $h_\\infty(t)$ 来量化外推残差。使用纯数学和算法操作来构建应变数据并评估方法性能。\n\n按如下方式构建合成的、确定性的应变数据。定义一个在零无穷远处的无量纲应变\n$$\nh_\\infty(t) = A(t)\\cos\\big(\\phi(t)\\big),\n$$\n其振幅 $A(t)$ 模拟了旋进增长和铃振衰减，\n$$\nA(t) = \\begin{cases}\nA_0 \\big(1 + \\eta t\\big),  0 \\le t \\le t_m, \\\\\nA_0 \\big(1 + \\eta t_m\\big) \\exp\\big(-\\lambda (t - t_m)\\big),  t > t_m,\n\\end{cases}\n$$\n相位 $\\phi(t)$ 模拟了啁啾信号，\n$$\n\\phi(t) = \\phi_0 + \\omega_0 t + \\gamma t^2.\n$$\n令 $c(t)$ 和 $d(t)$ 为相干的次主导项，\n$$\nc(t) = \\alpha_c A(t)\\cos\\big(\\phi(t) + \\delta_c\\big), \\quad d(t) = \\alpha_d A(t)\\cos\\big(\\phi(t) + \\delta_d\\big).\n$$\n对于每个提取半径 $R_i$，通过以下公式构建有限半径应变时间序列 $h_i(t)$：\n$$\nh_i(t) = h_\\infty(t) + \\frac{c(t)}{R_i} + \\frac{d(t)}{R_i^2} + \\epsilon \\sin\\big(2\\pi f_i t\\big),\n$$\n其中 $f_i$ 是每个半径对应的不同确定性频率，$\\epsilon$ 是一个确定性的小振幅。所有量都是无量纲的。\n\n在每个时间样本 $t_k$ 处，通过对所有半径 $\\{R_i\\}$ 上的值 $\\{h_i(t_k)\\}$ 进行模型 $h(t,R) \\approx h_\\infty(t) + c(t)/R$ 的线性最小二乘拟合，来估计 $\\hat{h}_\\infty(t_k)$ 和 $\\hat{c}(t_k)$，忽略 $1/R^2$ 及更高阶项。同时，通过选取在最大半径处测得的应变，构建一个朴素近似 $h_{\\max R}(t)$。\n\n在一个共同的均匀时间网格 $\\{t_k\\}_{k=1}^N$ 上，定义以下度量指标来量化相对于基准真相 $h_\\infty(t)$ 的外推残差：\n- 相对均方根误差，\n$$\n\\mathrm{relL2}(x,y) = \\frac{\\sqrt{\\sum_{k=1}^N \\big(x_k - y_k\\big)^2}}{\\sqrt{\\sum_{k=1}^N x_k^2}}.\n$$\n- 失配，\n$$\n\\mathrm{mismatch}(x,y) = 1 - \\frac{\\sum_{k=1}^N x_k y_k}{\\sqrt{\\sum_{k=1}^N x_k^2}\\sqrt{\\sum_{k=1}^N y_k^2}}.\n$$\n- 在对所有半径和时间进行拟合后的归一化残差均方根，\n$$\n\\mathrm{residRMS} = \\frac{\\sqrt{\\sum_{i,k} \\big[h_i(t_k) - \\big(\\hat{h}_\\infty(t_k) + \\hat{c}(t_k)/R_i\\big)\\big]^2}}{\\sqrt{\\sum_k h_\\infty(t_k)^2}}.\n$$\n\n使用以下在所有测试用例中共享的固定、确定性选择来实现上述过程：\n- 使用一个在区间 $[0,1)$ 秒内有 $N = 2048$ 个样本的均匀时间网格 $t_k$，即 $t_k = k/N$，$k = 0,1,\\dots,N-1$。\n- 使用 $A_0 = 1$, $\\eta = 1.5$, $t_m = 0.7$, $\\lambda = 8$, $\\phi_0 = 0$, $\\omega_0 = 50$, $\\gamma = 80$, $\\delta_c = 0.3$ 和 $\\delta_d = -0.6$。\n- 对于每个半径索引 $i$（第一个半径的索引为 $i=0$），设置 $f_i = 3 + i$。\n\n您的程序必须为每个测试用例计算四个浮点数：\n- $\\mathrm{relL2}\\big(h_\\infty, \\hat{h}_\\infty\\big)$,\n- $\\mathrm{relL2}\\big(h_\\infty, h_{\\max R}\\big)$,\n- $\\mathrm{mismatch}\\big(h_\\infty, \\hat{h}_\\infty\\big)$,\n- $\\mathrm{residRMS}$。\n\n设计一个包含三个用例的测试套件：\n- 用例1（常规顺利路径）：$\\{R_i\\} = [100, 150, 200, 300, 400]$，$\\alpha_c = 0.25$，$\\alpha_d = 0.05$，$\\epsilon = 10^{-4}$。\n- 用例2（边界条件，使用最少半径且无高阶项或噪声）：$\\{R_i\\} = [100, 300]$，$\\alpha_c = 0.30$，$\\alpha_d = 0$，$\\epsilon = 0$。\n- 用例3（边缘用例，使用较小半径、更强的高阶污染和更大的确定性噪声）：$\\{R_i\\} = [50, 75, 100]$，$\\alpha_c = 0.20$，$\\alpha_d = 0.20$，$\\epsilon = 5\\times 10^{-4}$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例贡献其四个计算出的浮点数，作为一个嵌套列表，顺序与上文指定相同。例如，输出格式必须为 $[\\,[r_{11},r_{12},r_{13},r_{14}],\\,[r_{21},r_{22},r_{23},r_{24}],\\,[r_{31},r_{32},r_{33},r_{34}]\\,]$。\n\n所有量均为无量纲，无需物理单位。角度以弧度为单位。将所有计算出的数字表示为十进制浮点数。程序必须可独立运行，不得读取输入或写入文件。", "solution": "所提出的问题是一个在数值数据分析领域定义明确的计算练习，专门针对数值相对论中的一个常见任务：将在有限半径处计算的引力波信号外推至零无穷远。所有提供的方程、参数和程序在科学上与该领域使用的简化模型一致，在数学上是合理的，并且在计算上是可行的。该问题是自洽的，没有歧义。因此，该问题被认为是有效的，并将构建一个解决方案。\n\n核心任务是在多个有限提取半径上生成合成的引力波数据，然后使用线性外推模型来估计零无穷远处的波形。之后，根据已知的基准真相来量化此外推的准确性。\n\n首先，我们根据提供的解析模型构建必要的时域波形。定义一个在区间 $[0, 1)$ 上有 $N = 2048$ 个点的均匀时间网格 $\\{t_k\\}_{k=0}^{N-1}$，使得 $t_k = k/N$。\n\n零无穷远处的基准真值波形 $h_\\infty(t)$ 由一个振幅 $A(t)$ 和一个相位 $\\phi(t)$ 定义。振幅 $A(t)$ 模拟了双黑洞并合的旋进和铃振过程：\n$$\nA(t) = \\begin{cases}\nA_0 \\big(1 + \\eta t\\big),  0 \\le t \\le t_m \\\\\nA_0 \\big(1 + \\eta t_m\\big) \\exp\\big(-\\lambda (t - t_m)\\big),  t  t_m\n\\end{cases}\n$$\n相位 $\\phi(t)$ 模拟了信号的“啁啾”特性，即频率随时间增加：\n$$\n\\phi(t) = \\phi_0 + \\omega_0 t + \\gamma t^2\n$$\n使用给定的参数 $A_0 = 1$, $\\eta = 1.5, t_m = 0.7, \\lambda = 8, \\phi_0 = 0, \\omega_0 = 50$ 和 $\\gamma = 80$，我们计算 $A(t_k)$、$\\phi(t_k)$ 的时间序列，并随后计算基准真值波形 $h_\\infty(t_k) = A(t_k)\\cos(\\phi(t_k))$。\n\n接下来，我们生成次主导贡献 $c(t)$ 和 $d(t)$，它们代表了在有限半径处污染信号的物理效应和规范效应。它们被建模为与主信号相干，但具有相移 $\\delta_c$ 和 $\\delta_d$：\n$$\nc(t) = \\alpha_c A(t)\\cos\\big(\\phi(t) + \\delta_c\\big)\n$$\n$$\nd(t) = \\alpha_d A(t)\\cos\\big(\\phi(t) + \\delta_d\\big)\n$$\n此处，$\\delta_c = 0.3$ 和 $\\delta_d = -0.6$，而 $\\alpha_c$ 和 $\\alpha_d$ 对每个测试用例是特定的。\n\n对于给定集合 $\\{R_i\\}$ 中的每个提取半径 $R_i$，合成的应变数据 $h_i(t)$ 被构建出来。它包括基准真相、按 $1/R_i$ 的幂次标度的次主导项，以及每个半径独有的确定性高频噪声项：\n$$\nh_i(t_k) = h_\\infty(t_k) + \\frac{c(t_k)}{R_i} + \\frac{d(t_k)}{R_i^2} + \\epsilon \\sin\\big(2\\pi f_i t_k\\big)\n$$\n噪声频率为 $f_i = 3 + i$，其中 $i$ 是半径的从零开始的索引。参数 $\\epsilon$、$\\{R_i\\}$、$\\alpha_c$ 和 $\\alpha_d$ 是为三个测试用例中的每一个提供的。\n\n下一步是外推过程。在每个时间样本 $t_k$，我们都有一组在不同半径 $\\{R_i\\}$ 上的测量值 $\\{h_i(t_k)\\}$。我们用一个形如 $y = a + bx$ 的线性模型来拟合这些数据，其中 $y_i = h_i(t_k)$，自变量是 $x_i = 1/R_i$，待定系数是 $a = \\hat{h}_\\infty(t_k)$ 和 $b = \\hat{c}(t_k)$。这是一个线性最小二乘问题。对于一组 $M$ 个半径，在每个时间 $t_k$ 的问题是找到能使 $\\sum_{i=1}^M [h_i(t_k) - (\\hat{h}_\\infty + \\hat{c}/R_i)]^2$ 最小化的 $(\\hat{h}_\\infty, \\hat{c})$。对所有 $k=0, \\dots, N-1$ 执行此操作，以获得外推波形 $\\hat{h}_\\infty(t)$ 和次主导项 $\\hat{c}(t)$ 的完整时间序列。此外，一个朴素波形近似 $h_{\\max R}(t)$ 被取为最大可用半径处的数据，即 $h_{\\max R}(t_k) = h_i(t_k)$，其中 $R_i = \\max(\\{R_j\\})$。\n\n最后，我们计算四个度量指标来评估外推的性能。\n1.  外推波形的相对L2误差：$\\mathrm{relL2}\\big(h_\\infty, \\hat{h}_\\infty\\big) = \\frac{\\sqrt{\\sum_{k} (h_\\infty(t_k) - \\hat{h}_\\infty(t_k))^2}}{\\sqrt{\\sum_{k} h_\\infty(t_k)^2}}$。这衡量了整体的振幅差异。\n2.  朴素波形的相对L2误差：$\\mathrm{relL2}\\big(h_\\infty, h_{\\max R}\\big) = \\frac{\\sqrt{\\sum_{k} (h_\\infty(t_k) - h_{\\max R}(t_k))^2}}{\\sqrt{\\sum_{k} h_\\infty(t_k)^2}}$。这作为比较的基线。\n3.  外推波形的失配：$\\mathrm{mismatch}\\big(h_\\infty, \\hat{h}_\\infty\\big) = 1 - \\frac{\\sum_{k} h_\\infty(t_k) \\hat{h}_\\infty(t_k)}{\\sqrt{\\sum_k h_\\infty(t_k)^2}\\sqrt{\\sum_k \\hat{h}_\\infty(t_k)^2}}$。这对信号之间的相位误差很敏感。\n4.  拟合的归一化残差均方根：$\\mathrm{residRMS} = \\frac{\\sqrt{\\sum_{i,k} [h_i(t_k) - (\\hat{h}_\\infty(t_k) + \\hat{c}(t_k)/R_i)]^2}}{\\sqrt{\\sum_k h_\\infty(t_k)^2}}$。该量度衡量了线性模型 $h_\\infty+c/R$ 对包含 $1/R^2$ 项和噪声的完整数据集的描述程度。一个大的值表明存在显著的模型设定错误。\n\n对三个指定的测试用例中的每一个都执行这些计算，并收集每个用例得到的四个标量度量指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave extrapolation problem for three test cases.\n    \"\"\"\n\n    # Global fixed parameters\n    N = 2048\n    A0 = 1.0\n    eta = 1.5\n    t_m = 0.7\n    lmbda = 8.0  # 'lambda' is a reserved keyword\n    phi0 = 0.0\n    omega0 = 50.0\n    gamma = 80.0\n    delta_c = 0.3\n    delta_d = -0.6\n\n    # Time grid\n    t = np.arange(N) / N\n\n    # Construct ground truth waveform h_infty(t)\n    # Amplitude A(t)\n    A_t_inspiral = A0 * (1 + eta * t)\n    A_t_ringdown = A0 * (1 + eta * t_m) * np.exp(-lmbda * (t - t_m))\n    A_t = np.where(t = t_m, A_t_inspiral, A_t_ringdown)\n    \n    # Phase phi(t)\n    phi_t = phi0 + omega0 * t + gamma * t**2\n    \n    # Ground truth strain h_infty(t)\n    h_inf_t = A_t * np.cos(phi_t)\n    norm_h_inf = np.linalg.norm(h_inf_t)\n\n    # Test cases\n    test_cases = [\n        {\n            \"R_vals\": np.array([100, 150, 200, 300, 400]),\n            \"alpha_c\": 0.25,\n            \"alpha_d\": 0.05,\n            \"epsilon\": 1e-4,\n        },\n        {\n            \"R_vals\": np.array([100, 300]),\n            \"alpha_c\": 0.30,\n            \"alpha_d\": 0.0,\n            \"epsilon\": 0.0,\n        },\n        {\n            \"R_vals\": np.array([50, 75, 100]),\n            \"alpha_c\": 0.20,\n            \"alpha_d\": 0.20,\n            \"epsilon\": 5e-4,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        R_vals = case[\"R_vals\"]\n        alpha_c = case[\"alpha_c\"]\n        alpha_d = case[\"alpha_d\"]\n        epsilon = case[\"epsilon\"]\n\n        # 1. Generate synthetic strain data for all radii\n        c_t = alpha_c * A_t * np.cos(phi_t + delta_c)\n        d_t = alpha_d * A_t * np.cos(phi_t + delta_d)\n        \n        num_radii = len(R_vals)\n        H_data = np.zeros((num_radii, N))\n\n        for i, R_i in enumerate(R_vals):\n            f_i = 3.0 + i\n            noise_term = epsilon * np.sin(2 * np.pi * f_i * t)\n            H_data[i, :] = h_inf_t + c_t / R_i + d_t / R_i**2 + noise_term\n\n        # 2. Perform extrapolation using linear least squares\n        # The independent variable for the fit is 1/R\n        x_fit = 1 / R_vals\n        \n        # np.polyfit fits for each column of y if y is 2D.\n        # H_data is (num_radii, N), x_fit is (num_radii,).\n        # This will perform N fits, one for each time step.\n        # The result 'coeffs' will have shape (2, N).\n        # coeffs[0, :] will be the slopes (c_hat_t)\n        # coeffs[1, :] will be the intercepts (h_inf_hat_t)\n        coeffs = np.polyfit(x_fit, H_data, 1)\n        c_hat_t = coeffs[0, :]\n        h_inf_hat_t = coeffs[1, :]\n\n        # 3. Get the naive approximation from the largest radius\n        idx_max_R = np.argmax(R_vals)\n        h_maxR_t = H_data[idx_max_R, :]\n\n        # 4. Calculate the performance metrics\n        # Metric 1: relL2(h_infty, h_inf_hat)\n        relL2_h_inf_hat = np.linalg.norm(h_inf_t - h_inf_hat_t) / norm_h_inf\n\n        # Metric 2: relL2(h_infty, h_maxR)\n        relL2_h_maxR = np.linalg.norm(h_inf_t - h_maxR_t) / norm_h_inf\n\n        # Metric 3: mismatch(h_infty, h_inf_hat)\n        norm_h_inf_hat = np.linalg.norm(h_inf_hat_t)\n        inner_product = np.dot(h_inf_t, h_inf_hat_t)\n        mismatch_h_inf_hat = 1.0 - inner_product / (norm_h_inf * norm_h_inf_hat)\n\n        # Metric 4: residRMS\n        # Reconstruct the fitted model values at all radii and times\n        # H_fit[i, k] = h_inf_hat_t[k] + c_hat_t[k] / R_vals[i]\n        H_fit = h_inf_hat_t[np.newaxis, :] + c_hat_t[np.newaxis, :] / R_vals[:, np.newaxis]\n        \n        # Sum of squared residuals over all radii and times\n        total_residual_sq_sum = np.sum((H_data - H_fit)**2)\n        residRMS_val = np.sqrt(total_residual_sq_sum) / norm_h_inf\n        \n        case_results = [\n            relL2_h_inf_hat,\n            relL2_h_maxR,\n            mismatch_h_inf_hat,\n            residRMS_val,\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The format requires nested lists, so we format each sublist.\n    formatted_results = [f\"[{','.join(f'{x:.17g}' for x in res)}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3464669"}]}