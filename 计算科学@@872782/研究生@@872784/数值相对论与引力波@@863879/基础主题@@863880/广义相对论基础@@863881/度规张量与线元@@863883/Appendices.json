{"hands_on_practices": [{"introduction": "在数值相对论中，度规张量 $g_{\\mu\\nu}$ 不仅仅是一个静态的数学对象，它是在时空演化过程中动态变化的。因此，验证演化中的度规是否始终保持其物理有效性至关重要。本练习将指导你编写一个诊断工具，用于检查度规张量是否满足两个基本物理条件：正确的洛伦兹符号和正定的空间度规，这些是确保时空因果结构正确的必要条件。[@problem_id:3493424]", "problem": "时空度规张量 $g_{\\mu\\nu}$ 决定了线元 $ds^2 = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}$ 以及数值相对论模拟中向量的因果特性。在与引力波建模相关的、物理上有效的洛伦兹时空中，度规必须具有 $(-,+,+,+)$ 符号差，其诱导的空间 $3\\times 3$ 子块必须是正定的，并且线元必须一致地对代表性向量进行分类：在光速 $c=1$ 的单位制下，一个类时向量 $u^{\\mu}$ 必须产生 $ds^2  0$，而一个类空向量 $s^{\\mu}$ 必须产生 $ds^2 > 0$。您的任务是编写一个程序，为给定的度规和向量测试套件验证这些性质，这在模拟中捕捉符号差或正定性违规时是必需的。\n\n使用的基本和核心定义：\n- 度规张量 $g_{\\mu\\nu}$ 是对称的，并为任意切向量 $v^{\\mu}$ 定义了线元 $ds^2 = g_{\\mu\\nu} \\, v^{\\mu} \\, v^{\\nu}$ 的双线性形式。\n- 根据西尔维斯特惯性定理 (Sylvester’s law of inertia)，如果对称矩阵 $g_{\\mu\\nu}$ 的负、正、零特征值的数量是不变的，且等于一个负特征值和三个正特征值，没有零特征值（非简并），那么该度规具有洛伦兹符号差 $(-,+,+,+)$。\n- 在 $3+1$ 分解中，诱导空间度规 $\\gamma_{ij} \\equiv g_{ij}$（在坐标 $(t,x,y,z)$ 中，索引 $i,j \\in \\{1,2,3\\}$ 对应的空间 $3\\times 3$ 子块）必须是正定的，即其所有特征值必须严格为正。\n- 对于符号差 $(-,+,+,+)$ 的因果分类：对于一个物理上可实现的类时向量 $u^{\\mu}$，有 $ds^2 = g_{\\mu\\nu} u^{\\mu} u^{\\nu}  0$；对于一个类空向量 $s^{\\mu}$，有 $ds^2 = g_{\\mu\\nu} s^{\\mu} s^{\\nu} > 0$。\n\n数值分类规则：\n- 为了模拟浮点效应，使用一个容差 $\\epsilon = 10^{-10}$ 来对特征值和线元进行分类。如果一个特征值小于 $-\\epsilon$，则计为负；如果大于 $\\epsilon$，则计为正；如果其绝对值小于或等于 $\\epsilon$，则计为零（简并）。对于线元分类，要求类时向量满足 $g_{\\mu\\nu} u^{\\mu} u^{\\nu}  -\\epsilon$，类空向量满足 $g_{\\mu\\nu} s^{\\mu} s^{\\nu} > \\epsilon$。\n\n测试套件：\n- 案例 A (闵可夫斯基时空): $g^{(A)}_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1,\\,1,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$。\n- 案例 B (横向无迹 (TT) 加偏振引力波，弱场快照): $h=10^{-3}$, $g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1+h,\\,1-h,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$。\n- 案例 C (欧几里得度规，对相对论无效): $g^{(C)}_{\\mu\\nu} = \\mathrm{diag}(1,\\,1,\\,1,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$。\n- 案例 D (近简并边界情况): $g^{(D)}_{\\mu\\nu} = \\mathrm{diag}(-10^{-12},\\,1,\\,1,\\,1)$, $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,0,\\,0)$。\n- 案例 E (TT 交叉偏振引力波，带有非对角空间项的弱场快照): $h=0.05$, 分量 $g^{(E)}_{00}=-1$, $g^{(E)}_{11}=1$, $g^{(E)}_{22}=1$, $g^{(E)}_{33}=1$, $g^{(E)}_{12}=g^{(E)}_{21}=h$, 所有其他分量为零; $u^{\\mu}=(1,\\,0,\\,0,\\,0)$, $s^{\\mu}=(0,\\,1,\\,1,\\,0)$。\n\n程序要求：\n- 对每个案例，计算：\n    1. 完整度规是否在容差 $\\epsilon$ 内具有洛伦兹符号差 $(-,+,+,+)$。\n    2. 空间 $3\\times 3$ 子块 $g_{ij}$ 是否在容差 $\\epsilon$ 内是正定的。\n    3. $u^{\\mu}$ 和 $s^{\\mu}$ 的线元是否满足 $g_{\\mu\\nu} u^{\\mu} u^{\\nu}  -\\epsilon$ 和 $g_{\\mu\\nu} s^{\\mu} s^{\\nu} > \\epsilon$。\n- 每个案例返回一个布尔值，当且仅当该案例的所有三项检查都通过时，该值为真。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是对应于案例 $k \\in \\{A,B,C,D,E\\}$ 的布尔值。", "solution": "该问题要求根据数值相对论和引力波建模中物理相关性所需的一组基本性质，验证几个给定的时空度规 $g_{\\mu\\nu}$。对于一个给定的案例，如果一个度规同时满足三个特定标准，即具有正确的洛伦兹符号差、诱导一个正定的空间度规、以及正确分类代表性测试向量的因果特性，则该度规被认为是有效的。\n\n每个案例的验证过程通过实施基于所提供定义的三个顺序检查来进行。所有浮点比较均使用数值容差 $\\epsilon = 10^{-10}$。\n\n1.  **洛伦兹符号差验证**：一个 $4 \\times 4$ 的度规张量 $g_{\\mu\\nu}$ 具有洛伦兹符号差 $(-,+,+,+)$ 当且仅当其特征值恰好包含一个负值、三个正值且没有零值。为验证这一点，我们计算 $g_{\\mu\\nu}$ 矩阵表示的特征值。使用指定的容差 $\\epsilon$，如果特征值 $\\lambda  -\\epsilon$，则计为负；如果 $\\lambda > \\epsilon$，则计为正；如果 $|\\lambda| \\le \\epsilon$，则计为零。如果计数结果为一个负特征值、三个正特征值和零个“零”特征值，则度规是非简并的洛伦兹度规。\n\n2.  **正定空间度规验证**：在时空的 $3+1$ 分解中，诱导空间度规 $\\gamma_{ij}$ 是 $g_{\\mu\\nu}$ 中对应于空间索引 $i, j \\in \\{1, 2, 3\\}$（对于坐标 $(x^0, x^1, x^2, x^3)$）的 $3 \\times 3$ 子矩阵。对于一个物理上有效的时空，$\\gamma_{ij}$ 必须是正定的，意味着它的所有特征值都必须严格为正。我们通过计算 $\\gamma_{ij}$ 的三个特征值并确保每个特征值都大于容差 $\\epsilon$ 来检查这一点。\n\n3.  **因果特性验证**：线元 $ds^2 = g_{\\mu\\nu} v^{\\mu} v^{\\nu}$ 决定了向量 $v^{\\mu}$ 的因果性质。对于给定的测试向量，一个类时向量 $u^{\\mu}$ 必须满足 $g_{\\mu\\nu} u^{\\mu} u^{\\nu}  -\\epsilon$，一个类空向量 $s^{\\mu}$ 必须满足 $g_{\\mu\\nu} s^{\\mu} s^{\\nu} > \\epsilon$。这可通过矩阵-向量乘法计算为 $(v)^T g v$。\n\n一个案例当且仅当所有这三项检查都成功时才通过整体验证。我们现在将此程序应用于每个测试案例。\n\n**案例 A：闵可夫斯基时空**\n-   度规：$g^{(A)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1, 1, 1)$。\n-   向量：$u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$。\n\n1.  **符号差**：对角矩阵 $g^{(A)}_{\\mu\\nu}$ 的特征值是其对角线元素：$\\{-1, 1, 1, 1\\}$。有一个负特征值和三个正特征值。所有值都远在容差区域之外。此项检查**通过**。\n2.  **空间度规**：空间子块为 $\\gamma^{(A)}_{ij} = \\mathrm{diag}(1, 1, 1)$。其特征值为 $\\{1, 1, 1\\}$，所有值都大于 $\\epsilon$。此项检查**通过**。\n3.  **因果特性**：\n    -   对于 $u^{\\mu}$，$ds^2 = g_{00} (u^0)^2 = (-1)(1)^2 = -1$。由于 $-1  -\\epsilon$，此项检查**通过**。\n    -   对于 $s^{\\mu}$，$ds^2 = g_{11} (s^1)^2 = (1)(1)^2 = 1$。由于 $1 > \\epsilon$，此项检查**通过**。\n\n所有三项检查均通过。案例 A 的结果为**真 (True)**。\n\n**案例 B：TT 加偏振引力波**\n-   度规：$g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1+h, 1-h, 1)$，其中 $h = 10^{-3}$。所以，$g^{(B)}_{\\mu\\nu} = \\mathrm{diag}(-1, 1.001, 0.999, 1)$。\n-   向量：$u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$。\n\n1.  **符号差**：特征值为 $\\{-1, 1.001, 0.999, 1\\}$。有一个负特征值和三个正特征值。此项检查**通过**。\n2.  **空间度规**：空间子块为 $\\gamma^{(B)}_{ij} = \\mathrm{diag}(1.001, 0.999, 1)$。其特征值为 $\\{1.001, 0.999, 1\\}$，均为正。此项检查**通过**。\n3.  **因果特性**：\n    -   对于 $u^{\\mu}$，$ds^2 = g_{00} (u^0)^2 = -1  -\\epsilon$。此项检查**通过**。\n    -   对于 $s^{\\mu}$，$ds^2 = g_{11} (s^1)^2 = (1+h)(1)^2 = 1.001 > \\epsilon$。此项检查**通过**。\n\n所有三项检查均通过。案例 B 的结果为**真 (True)**。\n\n**案例 C：欧几里得度规**\n-   度规：$g^{(C)}_{\\mu\\nu} = \\mathrm{diag}(1, 1, 1, 1)$。\n-   向量：$u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$。\n\n1.  **符号差**：特征值为 $\\{1, 1, 1, 1\\}$。有零个负特征值和四个正特征值。这违反了 $(-,+,+,+)$ 符号差的要求。此项检查**失败**。\n\n由于第一项检查失败，该案例的总体结果已确定。案例 C 的结果为**假 (False)**。\n\n**案例 D：近简并度规**\n-   度规：$g^{(D)}_{\\mu\\nu} = \\mathrm{diag}(-10^{-12}, 1, 1, 1)$。\n-   向量：$u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 0, 0)$。\n\n1.  **符号差**：特征值为 $\\{-10^{-12}, 1, 1, 1\\}$。我们将特征值 $\\lambda_0 = -10^{-12}$ 与容差 $\\epsilon = 10^{-10}$ 进行比较。由于 $|\\lambda_0| = 10^{-12} \\le 10^{-10}$，该特征值被分类为零。计数结果为零个负特征值、三个正特征值和一个零特征值。这违反了非简并洛伦兹符号差的要求。此项检查**失败**。\n\n该案例无效。为完整起见，我们注意到对 $u^{\\mu}$ 的因果检查也失败了：$ds^2 = g_{00}(u^0)^2 = -10^{-12}$。条件 $ds^2  -\\epsilon$ 变为 $-10^{-12}  -10^{-10}$，这是错误的。案例 D 的结果为**假 (False)**。\n\n**案例 E：TT 交叉偏振引力波**\n-   度规：$g^{(E)}_{\\mu\\nu}$ 的分量为 $g_{00}=-1$, $g_{11}=g_{22}=g_{33}=1$, $g_{12}=g_{21}=h=0.05$。以矩阵形式表示：\n$$g^{(E)}_{\\mu\\nu} = \\begin{pmatrix} -1  0  0  0 \\\\ 0  1  0.05  0 \\\\ 0  0.05  1  0 \\\\ 0  0  0  1 \\end{pmatrix}$$\n-   向量：$u^{\\mu} = (1, 0, 0, 0)$, $s^{\\mu} = (0, 1, 1, 0)$。\n\n1.  **符号差**：该矩阵是块对角矩阵。特征值是各子块的特征值：$\\{-1\\}$，$\\{1\\}$，以及子矩阵 $\\begin{pmatrix} 1  0.05 \\\\ 0.05  1 \\end{pmatrix}$。这个 $2 \\times 2$ 子矩阵的特征值为 $\\lambda = 1 \\pm 0.05$，即 $1.05$ 和 $0.95$。$g^{(E)}_{\\mu\\nu}$ 的完整特征值集合为 $\\{-1, 1.05, 0.95, 1\\}$。有一个负特征值和三个正特征值。此项检查**通过**。\n2.  **空间度规**：空间子块为 $\\gamma^{(E)}_{ij} = \\begin{pmatrix} 1  0.05  0 \\\\ 0.05  1  0 \\\\ 0  0  1 \\end{pmatrix}$。其特征值为 $\\{1.05, 0.95, 1\\}$，均为正值。此项检查**通过**。\n3.  **因果特性**：\n    -   对于 $u^{\\mu}$，$ds^2 = g_{00} (u^0)^2 = -1  -\\epsilon$。此项检查**通过**。\n    -   对于 $s^{\\mu}$，$ds^2 = g_{\\mu\\nu} s^{\\mu} s^{\\nu} = g_{11}(s^1)^2 + g_{22}(s^2)^2 + 2g_{12}s^1 s^2 = (1)(1)^2 + (1)(1)^2 + 2(0.05)(1)(1) = 1 + 1 + 0.1 = 2.1$。由于 $2.1 > \\epsilon$，此项检查**通过**。\n\n所有三项检查均通过。案例 E 的结果为**真 (True)**。\n\n最终布尔值摘要：\n- 案例 A: 真\n- 案例 B: 真\n- 案例 C: 假\n- 案例 D: 假\n- 案例 E: 真", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates a test suite of spacetime metrics against physical criteria.\n\n    For each case, the program checks:\n    1. If the 4x4 metric has Lorentzian signature (-,+,+,+).\n    2. If the 3x3 spatial sub-metric is positive-definite.\n    3. If representative time-like and space-like vectors are correctly classified.\n\n    A case is valid (True) if and only if all three checks pass.\n    \"\"\"\n    \n    # Define the tolerance for floating-point comparisons as per the problem.\n    epsilon = 1e-10\n\n    # Test Case A: Minkowski spacetime\n    g_A = np.diag([-1.0, 1.0, 1.0, 1.0])\n    u_A = np.array([1.0, 0.0, 0.0, 0.0])\n    s_A = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case B: Transverse-Traceless (TT) plus-polarized gravitational wave\n    h_B = 1e-3\n    g_B = np.diag([-1.0, 1.0 + h_B, 1.0 - h_B, 1.0])\n    u_B = np.array([1.0, 0.0, 0.0, 0.0])\n    s_B = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case C: Euclidean metric (invalid for relativity)\n    g_C = np.diag([1.0, 1.0, 1.0, 1.0])\n    u_C = np.array([1.0, 0.0, 0.0, 0.0])\n    s_C = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case D: Near-degenerate boundary case\n    g_D = np.diag([-1e-12, 1.0, 1.0, 1.0])\n    u_D = np.array([1.0, 0.0, 0.0, 0.0])\n    s_D = np.array([0.0, 1.0, 0.0, 0.0])\n\n    # Test Case E: TT cross-polarized gravitational wave\n    h_E = 0.05\n    g_E = np.array([\n        [-1.0, 0.0, 0.0, 0.0],\n        [0.0, 1.0, h_E, 0.0],\n        [0.0, h_E, 1.0, 0.0],\n        [0.0, 0.0, 0.0, 1.0]\n    ])\n    u_E = np.array([1.0, 0.0, 0.0, 0.0])\n    s_E = np.array([0.0, 1.0, 1.0, 0.0])\n\n    test_cases = [\n        (g_A, u_A, s_A),\n        (g_B, u_B, s_B),\n        (g_C, u_C, s_C),\n        (g_D, u_D, s_D),\n        (g_E, u_E, s_E),\n    ]\n\n    results = []\n    for g, u, s in test_cases:\n        # Check 1: Lorentzian signature\n        # Use np.linalg.eigvalsh as the metrics are real symmetric matrices.\n        eigs_g = np.linalg.eigvalsh(g)\n        \n        neg_count = np.sum(eigs_g  -epsilon)\n        pos_count = np.sum(eigs_g > epsilon)\n        zero_count = np.sum(np.abs(eigs_g) = epsilon)\n        \n        is_lorentzian = (neg_count == 1 and pos_count == 3 and zero_count == 0)\n\n        # Check 2: Positive-definite spatial metric\n        gamma = g[1:, 1:]\n        eigs_gamma = np.linalg.eigvalsh(gamma)\n        \n        is_spatial_pos_def = np.all(eigs_gamma > epsilon)\n\n        # Check 3: Causal classification\n        # Calculate line elements using matrix multiplication: v.T @ g @ v\n        ds2_u = u @ g @ u\n        ds2_s = s @ g @ s\n        \n        is_causal_correct = (ds2_u  -epsilon and ds2_s > epsilon)\n        \n        # A case is valid if and only if all three checks pass.\n        case_result = is_lorentzian and is_spatial_pos_def and is_causal_correct\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3493424"}, {"introduction": "度规张量是一个几何对象，其分量表示依赖于所选的坐标系。然而，它所描述的物理内涵，即时空间隔 $ds^2$，在坐标变换下必须保持不变。本练习将通过一个弱引力波的例子，让你亲手实现坐标变换下的度规张量转换，并数值验证线元 $ds^2$ 的不变性，从而加深对张量变换法则和雅可比矩阵作用的理解。[@problem_id:3493437]", "problem": "考虑一个在横向无迹规范 (transverse-traceless gauge) 下沿 $+z$ 方向传播的弱场平面引力波。在光速 $c = 1$ 的几何化单位中，笛卡尔坐标 $(t,x,y,z)$ 中的线元由度规张量 $g_{\\mu\\nu}(t,x,y,z)$ 的分量定义，使得线元满足 $ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu$，其中指数 $\\mu,\\nu \\in \\{0,1,2,3\\}$ 分别对应于 $(t,x,y,z)$。度规的非零分量由 $g_{00} = -1$，$g_{11} = 1 + h_+(u)$，$g_{22} = 1 - h_+(u)$，$g_{33} = 1$ 给出，其中 $u = t - z$，$h_+(u)$ 是一个给定的可微函数，用于编码引力波的“加”偏振。在本问题中，取 $h_+(u) = \\varepsilon \\sin(\\omega u)$，其中 $\\varepsilon$ 是一个无量纲小振幅，$\\omega$ 是以弧度/单位时间为单位的角频率。\n\n您将使用基于雅可比矩阵的变换来检验坐标片之间的匹配，并验证线元在坐标变换下的不变性。基本出发点是线元 $ds^2$ 的定义、其在光滑坐标变换下的不变性要求，以及微分的链式法则。您不能假设或使用任何变换度规的快捷公式；您必须从 $ds^2$ 的不变性和链式法则推导出所有必要的关系。\n\n考虑两个坐标片：\n\n1.  一个旋转的笛卡尔坐标片 $(t',x',y',z')$，由在 $x$–$y$ 平面内旋转角度 $\\alpha$ 定义，角度以弧度为单位，具体规定如下：\n    $$\n    t = t', \\quad z = z', \\quad x = x' \\cos\\alpha - y' \\sin\\alpha, \\quad y = x' \\sin\\alpha + y' \\cos\\alpha.\n    $$\n\n2.  一个球空间坐标片 $(t,r,\\theta,\\phi)$，其中角度以弧度为单位，由以下关系指定：\n    $$\n    t = t, \\quad x = r \\sin\\theta \\cos\\phi, \\quad y = r \\sin\\theta \\sin\\phi, \\quad z = r \\cos\\theta.\n    $$\n\n对于每个坐标片，通过链式法则构建从该坐标片坐标到笛卡尔坐标变换相关的雅可比矩阵项，用它们计算与 $ds^2$ 不变性一致的坐标片坐标中的度规分量，然后通过计算在两个坐标系中表示的相同物理位移的 $ds^2$ 来验证线元的不变性。\n\n将给定测试案例的偏差定义为在原始笛卡尔坐标中计算的线元与在变换后的坐标片坐标中计算的相同物理位移的线元之间的绝对差值。具体来说，给定坐标片坐标中的一个小位移向量，使用雅可比矩阵计算相应的笛卡尔坐标位移，在同一事件点评估两个线元，并将绝对差值报告为浮点数。角度必须以弧度为单位指定。\n\n您的程序必须为以下测试套件实现此验证。在所有情况下，角度均以弧度为单位，您应将偏差报告为无量纲的浮点数。\n\n- 测试案例1（旋转笛卡尔坐标，一般情况）：\n  - 参数：$\\varepsilon = 10^{-3}$，$\\omega = 100$，$\\alpha = \\pi/6$。\n  - 旋转坐标中的事件点：$(t',x',y',z') = (0.3, 0.1, -0.2, 0.5)$。\n  - 旋转坐标中的位移：$(dt', dx', dy', dz') = (10^{-3}, 2\\times 10^{-3}, -10^{-3}, 1.5\\times 10^{-3})$。\n\n- 测试案例2（旋转笛卡尔坐标，接近单位旋转的边界情况）：\n  - 参数：$\\varepsilon = 10^{-3}$，$\\omega = 100$，$\\alpha = 10^{-8}$。\n  - 旋转坐标中的事件点：$(t',x',y',z') = (0.3, 0.1, -0.2, 0.5)$。\n  - 旋转坐标中的位移：$(dt', dx', dy', dz') = (10^{-3}, -10^{-3}, 1.5\\times 10^{-3}, -2\\times 10^{-3})$。\n\n- 测试案例3（球坐标片，接近极轴的边界情况）：\n  - 参数：$\\varepsilon = 10^{-4}$，$\\omega = 250$。\n  - 球坐标中的事件点：$(t,r,\\theta,\\phi) = (0.25, 1.2, 10^{-6}, 1.0)$。\n  - 球坐标中的位移：$(dt, dr, d\\theta, d\\phi) = (10^{-3}, 5\\times 10^{-4}, 10^{-6}, 10^{-3})$。\n\n- 测试案例4（球坐标片，赤道情况）：\n  - 参数：$\\varepsilon = 10^{-3}$，$\\omega = 50$。\n  - 球坐标中的事件点：$(t,r,\\theta,\\phi) = (0.1, 2.0, \\pi/2, 2.0)$。\n  - 球坐标中的位移：$(dt, dr, d\\theta, d\\phi) = (5\\times 10^{-4}, -10^{-3}, 2\\times 10^{-3}, -10^{-3})$。\n\n您的程序应生成单行输出，其中包含四个测试案例的偏差，格式为用方括号括起来的逗号分隔列表（例如，$\\,[result_1, result_2, result_3, result_4]$，其中每个 $result_i$ 是一个浮点数）。不需要单位，因为使用了几何化单位且偏差是无量纲的。在整个过程中，角度必须以弧度处理。", "solution": "目标是通过从第一性原理构建新坐标系中的度规来验证线元 $ds^2$ 在光滑坐标变换下的不变性。基本依据是线元 $ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu$ 的定义，$ds^2$ 代表相邻事件间不变的平方间隔的要求，以及微分的链式法则。\n\n出发点：\n\n1.  笛卡尔坐标 $(t,x,y,z)$ 中的线元由以下度规分量指定：\n    $$\n    g_{00} = -1, \\quad g_{11} = 1 + h_+(u), \\quad g_{22} = 1 - h_+(u), \\quad g_{33} = 1,\n    $$\n    其中 $u = t - z$，对于给定的参数 $\\varepsilon$ 和 $\\omega$，$h_+(u) = \\varepsilon \\sin(\\omega u)$。\n\n2.  线元在坐标变换下的不变性表明，如果引入新坐标 $x'^a$（指数 $a \\in \\{0,1,2,3\\}$），那么在带撇坐标系中计算的平方间隔等于在同一时空事件点上不带撇坐标系中计算的平方间隔：\n    $$\n    ds^2 = g_{\\mu\\nu}(x) \\, dx^\\mu \\, dx^\\nu = g'_{ab}(x') \\, dx'^a \\, dx'^b.\n    $$\n    对象 $g'_{ab}(x')$ 是带撇坐标系中的度规张量。\n\n3.  微分的链式法则通过变换 $x^\\mu(x')$ 的雅可比矩阵将两个系统中的坐标微分联系起来：\n    $$\n    dx^\\mu = \\frac{\\partial x^\\mu}{\\partial x'^a} \\, dx'^a.\n    $$\n    将此代入不带撇的 $ds^2$ 表达式中，并与带撇的表达式进行比较，得到度规的变换法则：\n    $$\n    ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu = g_{\\mu\\nu} \\left( \\frac{\\partial x^\\mu}{\\partial x'^a} \\, dx'^a \\right) \\left( \\frac{\\partial x^\\nu}{\\partial x'^b} \\, dx'^b \\right) = \\left( \\frac{\\partial x^\\mu}{\\partial x'^a} \\frac{\\partial x^\\nu}{\\partial x'^b} g_{\\mu\\nu} \\right) dx'^a dx'^b,\n    $$\n    这意味着\n    $$\n    g'_{ab}(x') = \\frac{\\partial x^\\mu}{\\partial x'^a} \\frac{\\partial x^\\nu}{\\partial x'^b} g_{\\mu\\nu}(x).\n    $$\n    以矩阵形式，如果用 $J$ 表示雅可比矩阵，其元素为 $J^\\mu{}_a = \\partial x^\\mu / \\partial x'^a$，用 $g$ 表示度规矩阵，其元素为 $g_{\\mu\\nu}$，则带撇的度规为 $g' = J^\\top g J$。\n\n基于这些原理，我们为这两个坐标片构建雅可比矩阵，并通过比较在两个坐标系中表示的相同物理位移的线元来数值上验证不变性。\n\n旋转的笛卡尔坐标片：\n\n- 变换由下式给出\n  $$\n  t = t', \\quad z = z', \\quad x = x' \\cos\\alpha - y' \\sin\\alpha, \\quad y = x' \\sin\\alpha + y' \\cos\\alpha,\n  $$\n  这产生了雅可比矩阵的元素：\n  $$\n  \\frac{\\partial t}{\\partial t'} = 1, \\quad \\frac{\\partial t}{\\partial x'} = \\frac{\\partial t}{\\partial y'} = \\frac{\\partial t}{\\partial z'} = 0,\n  $$\n  $$\n  \\frac{\\partial x}{\\partial x'} = \\cos\\alpha, \\quad \\frac{\\partial x}{\\partial y'} = -\\sin\\alpha, \\quad \\frac{\\partial x}{\\partial z'} = 0, \\quad \\frac{\\partial x}{\\partial t'} = 0,\n  $$\n  $$\n  \\frac{\\partial y}{\\partial x'} = \\sin\\alpha, \\quad \\frac{\\partial y}{\\partial y'} = \\cos\\alpha, \\quad \\frac{\\partial y}{\\partial z'} = 0, \\quad \\frac{\\partial y}{\\partial t'} = 0,\n  $$\n  $$\n  \\frac{\\partial z}{\\partial z'} = 1, \\quad \\frac{\\partial z}{\\partial t'} = \\frac{\\partial z}{\\partial x'} = \\frac{\\partial z}{\\partial y'} = 0.\n  $$\n  因此，雅可比矩阵 $J$ 相对于 $(x',y',z')$ 是常数，除了它对 $\\alpha$ 的依赖。给定一个事件 $(t',x',y',z')$，使用旋转公式将其映射到 $(t,x,y,z)$，计算 $u = t - z$，计算 $h_+(u)$，构造 $g_{\\mu\\nu}(t,x,y,z)$，然后计算 $g'_{ab} = J^\\top g J$。\n\n- 为验证不变性，取一个位移 $dx'^a = (dt',dx',dy',dz')$，通过 $dx^\\mu = J^\\mu{}_a \\, dx'^a$ 计算相应的笛卡尔位移，并构造\n  $$\n  ds'^2 = g'_{ab} \\, dx'^a \\, dx'^b, \\quad ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu.\n  $$\n  报告的偏差为 $|ds'^2 - ds^2|$。\n\n球空间坐标片：\n\n- 变换由下式给出\n  $$\n  t = t, \\quad x = r \\sin\\theta \\cos\\phi, \\quad y = r \\sin\\theta \\sin\\phi, \\quad z = r \\cos\\theta.\n  $$\n  非零的雅可比矩阵元素可由偏导数得出：\n  $$\n  \\frac{\\partial t}{\\partial t} = 1, \\quad \\frac{\\partial t}{\\partial r} = \\frac{\\partial t}{\\partial \\theta} = \\frac{\\partial t}{\\partial \\phi} = 0,\n  $$\n  $$\n  \\frac{\\partial x}{\\partial r} = \\sin\\theta \\cos\\phi, \\quad \\frac{\\partial x}{\\partial \\theta} = r \\cos\\theta \\cos\\phi, \\quad \\frac{\\partial x}{\\partial \\phi} = -r \\sin\\theta \\sin\\phi,\n  $$\n  $$\n  \\frac{\\partial y}{\\partial r} = \\sin\\theta \\sin\\phi, \\quad \\frac{\\partial y}{\\partial \\theta} = r \\cos\\theta \\sin\\phi, \\quad \\frac{\\partial y}{\\partial \\phi} = r \\sin\\theta \\cos\\phi,\n  $$\n  $$\n  \\frac{\\partial z}{\\partial r} = \\cos\\theta, \\quad \\frac{\\partial z}{\\partial \\theta} = -r \\sin\\theta, \\quad \\frac{\\partial z}{\\partial \\phi} = 0.\n  $$\n  有了这些，就可以在事件点 $(t,r,\\theta,\\phi)$ 处构造 $J^\\mu{}_a$。通过上述关系将事件点映射到笛卡尔坐标，计算 $u = t - z$，评估 $h_+(u)$，并形成 $g_{\\mu\\nu}$。然后 $g'_{ab} = J^\\top g J$ 得到球坐标度规。\n\n- 为验证不变性，对于一个位移 $dx^a = (dt,dr,d\\theta,d\\phi)$，计算 $dx^\\mu = J^\\mu{}_a \\, dx^a$，构造\n  $$\n  ds'^2 = g'_{ab} \\, dx^a \\, dx^b, \\quad ds^2 = g_{\\mu\\nu} \\, dx^\\mu \\, dx^\\nu,\n  $$\n  并报告偏差 $|ds'^2 - ds^2|$。\n\n数值考虑：\n\n- 因为变换是光滑的，且度规是根据 $ds^2$ 的不变性构建的，所以偏差应在浮点舍入误差的量级上。在坐标奇异点附近（例如 $\\theta \\approx 0$），雅可比矩阵可能变得病态，有限精度算术会放大误差；然而，对于小位移，不变性应在数值容差范围内成立。\n\n算法设计：\n\n- 实现函数 $h_+(u) = \\varepsilon \\sin(\\omega u)$。\n- 实现一个函数来构建笛卡尔坐标下的 $g_{\\mu\\nu}(t,x,y,z)$。\n- 实现函数来为旋转的笛卡尔坐标片和球坐标片构建雅可比矩阵，并在坐标片和笛卡尔坐标之间映射坐标。\n- 对于每个测试案例，计算 $J$，将事件点映射到笛卡尔坐标，构造 $g$，计算 $g'$，然后为给定的位移在两个坐标系中计算 $ds^2$ 并报告绝对差值。\n- 将四个偏差汇总到指定格式的单行输出中。\n\n所有角度都以弧度处理，所有报告的偏差都是无量纲的浮点数，与几何化单位一致。", "answer": "```python\n# Python 3.12 program to verify invariance of the line element across coordinate patches\n# under Jacobian transformations for a weak-field plane gravitational wave metric.\n# Uses numpy 1.23.5; no other external libraries are required.\n\nimport numpy as np\n\ndef h_plus(u, eps, omega):\n    \"\"\"Plus polarization of the gravitational wave: h_+(u) = eps * sin(omega * u).\"\"\"\n    return eps * np.sin(omega * u)\n\ndef metric_cartesian(t, x, y, z, eps, omega):\n    \"\"\"\n    Construct the 4x4 metric tensor in Cartesian coordinates for the plane gravitational wave\n    in transverse-traceless gauge with plus polarization, in geometrized units (c=1).\n    Coordinates: (t, x, y, z) - indices (0,1,2,3).\n    \"\"\"\n    u = t - z\n    hp = h_plus(u, eps, omega)\n    g = np.zeros((4, 4), dtype=float)\n    g[0, 0] = -1.0\n    g[1, 1] = 1.0 + hp\n    g[2, 2] = 1.0 - hp\n    g[3, 3] = 1.0\n    return g\n\ndef jacobian_rotation(alpha):\n    \"\"\"\n    Jacobian J^mu{}_a = ∂x^mu/∂x'^a for rotation in the x-y plane:\n    t = t', z = z', x = x' cos α - y' sin α, y = x' sin α + y' cos α.\n    Coordinates ordering: (t,x,y,z) for mu; (t',x',y',z') for a.\n    \"\"\"\n    ca = np.cos(alpha)\n    sa = np.sin(alpha)\n    J = np.zeros((4, 4), dtype=float)\n    # t row\n    J[0, 0] = 1.0\n    # x row\n    J[1, 1] = ca\n    J[1, 2] = -sa\n    # y row\n    J[2, 1] = sa\n    J[2, 2] = ca\n    # z row\n    J[3, 3] = 1.0\n    return J\n\ndef map_event_rotation(t_p, x_p, y_p, z_p, alpha):\n    \"\"\"\n    Map event from rotated coordinates (t', x', y', z') to Cartesian (t, x, y, z)\n    using the rotation relations.\n    \"\"\"\n    ca = np.cos(alpha)\n    sa = np.sin(alpha)\n    t = t_p\n    x = x_p * ca - y_p * sa\n    y = x_p * sa + y_p * ca\n    z = z_p\n    return t, x, y, z\n\ndef jacobian_spherical(t, r, theta, phi):\n    \"\"\"\n    Jacobian J^mu{}_a = ∂x^mu/∂x^a for spherical spatial coordinates:\n    t = t, x = r sinθ cosφ, y = r sinθ sinφ, z = r cosθ.\n    Coordinates ordering: mu=(t,x,y,z), a=(t,r,theta,phi).\n    \"\"\"\n    st = np.sin(theta)\n    ct = np.cos(theta)\n    cf = np.cos(phi)\n    sf = np.sin(phi)\n    J = np.zeros((4, 4), dtype=float)\n    # t row\n    J[0, 0] = 1.0\n    # x row\n    J[1, 1] = st * cf\n    J[1, 2] = r * ct * cf\n    J[1, 3] = -r * st * sf\n    # y row\n    J[2, 1] = st * sf\n    J[2, 2] = r * ct * sf\n    J[2, 3] = r * st * cf\n    # z row\n    J[3, 1] = ct\n    J[3, 2] = -r * st\n    # J[3, 3] remains 0\n    return J\n\ndef map_event_spherical(t_s, r, theta, phi):\n    \"\"\"\n    Map event from spherical coordinates (t, r, theta, phi) to Cartesian (t, x, y, z).\n    \"\"\"\n    st = np.sin(theta)\n    ct = np.cos(theta)\n    cf = np.cos(phi)\n    sf = np.sin(phi)\n    x = r * st * cf\n    y = r * st * sf\n    z = r * ct\n    return t_s, x, y, z\n\ndef ds2_from_metric_and_displacement(g, dx):\n    \"\"\"Compute ds^2 = dx^T g dx.\"\"\"\n    return float(dx.T @ (g @ dx))\n\ndef run_rotation_case(eps, omega, alpha, event_p, disp_p):\n    \"\"\"\n    Compute discrepancy |ds'^2 - ds^2| for rotated Cartesian patch.\n    event_p: (t', x', y', z'), disp_p: (dt', dx', dy', dz').\n    \"\"\"\n    t_p, x_p, y_p, z_p = event_p\n    dt_p, dx_p, dy_p, dz_p = disp_p\n    J = jacobian_rotation(alpha)\n    t, x, y, z = map_event_rotation(t_p, x_p, y_p, z_p, alpha)\n    g = metric_cartesian(t, x, y, z, eps, omega)\n    g_p = J.T @ g @ J\n    dxp = np.array([dt_p, dx_p, dy_p, dz_p], dtype=float)\n    dx = J @ dxp\n    ds2_p = ds2_from_metric_and_displacement(g_p, dxp)\n    ds2 = ds2_from_metric_and_displacement(g, dx)\n    return abs(ds2_p - ds2)\n\ndef run_spherical_case(eps, omega, event_s, disp_s):\n    \"\"\"\n    Compute discrepancy |ds'^2 - ds^2| for spherical spatial patch.\n    event_s: (t, r, theta, phi), disp_s: (dt, dr, dtheta, dphi).\n    \"\"\"\n    t_s, r, theta, phi = event_s\n    dt_s, dr, dtheta, dphi = disp_s\n    J = jacobian_spherical(t_s, r, theta, phi)\n    t, x, y, z = map_event_spherical(t_s, r, theta, phi)\n    g = metric_cartesian(t, x, y, z, eps, omega)\n    g_s = J.T @ g @ J\n    dxs = np.array([dt_s, dr, dtheta, dphi], dtype=float)\n    dx = J @ dxs\n    ds2_s = ds2_from_metric_and_displacement(g_s, dxs)\n    ds2 = ds2_from_metric_and_displacement(g, dx)\n    return abs(ds2_s - ds2)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: rotated Cartesian, general case\n        (\"rotation\", {\"eps\": 1e-3, \"omega\": 100.0, \"alpha\": np.pi / 6,\n                      \"event_p\": (0.3, 0.1, -0.2, 0.5),\n                      \"disp_p\": (1e-3, 2e-3, -1e-3, 1.5e-3)}),\n        # Test Case 2: rotated Cartesian, near-identity rotation boundary\n        (\"rotation\", {\"eps\": 1e-3, \"omega\": 100.0, \"alpha\": 1e-8,\n                      \"event_p\": (0.3, 0.1, -0.2, 0.5),\n                      \"disp_p\": (1e-3, -1e-3, 1.5e-3, -2e-3)}),\n        # Test Case 3: spherical patch, near polar axis boundary\n        (\"spherical\", {\"eps\": 1e-4, \"omega\": 250.0,\n                       \"event_s\": (0.25, 1.2, 1e-6, 1.0),\n                       \"disp_s\": (1e-3, 5e-4, 1e-6, 1e-3)}),\n        # Test Case 4: spherical patch, equatorial case\n        (\"spherical\", {\"eps\": 1e-3, \"omega\": 50.0,\n                       \"event_s\": (0.1, 2.0, np.pi / 2.0, 2.0),\n                       \"disp_s\": (5e-4, -1e-3, 2e-3, -1e-3)}),\n    ]\n\n    results = []\n    for kind, params in test_cases:\n        if kind == \"rotation\":\n            result = run_rotation_case(params[\"eps\"], params[\"omega\"], params[\"alpha\"],\n                                       params[\"event_p\"], params[\"disp_p\"])\n        elif kind == \"spherical\":\n            result = run_spherical_case(params[\"eps\"], params[\"omega\"],\n                                        params[\"event_s\"], params[\"disp_s\"])\n        else:\n            result = float(\"nan\")\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3493437"}, {"introduction": "度规张量 $g_{\\mu\\nu}$ 包含了时空几何的全部信息，而曲率是描述时空弯曲的关键。本练习将引导你从度规张量及其导数出发，通过编写一个张量计算核心程序，来计算时空的里奇曲率张量 $R_{\\mu\\nu}$。通过对几个已知的解析解（如史瓦西和引力波时空）进行检验，你将能够验证它们是否满足真空中的爱因斯坦场方程，这是验证数值相对论代码正确性的基本步骤之一。[@problem_id:3493362]", "problem": "要求您实现一个程序，使用数值相对论中的标准解析度规来测试一个张量计算核心。核心量是度规张量和线元。在几何化单位制（$G=c=1$）下工作，并将所有量视为无量纲的。所有角度必须以弧度为单位进行解释。您的程序必须针对几个解析时空、指定的坐标点和位移，计算线元平方，并通过Ricci张量验证真空Einstein方程。您的输出必须将所有测试结果汇总到一行中，以方括号括起来的逗号分隔列表形式打印。\n\n使用的基本原理：\n\n- 线元由 $ds^{2} = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}$ 定义，其中 $g_{\\mu\\nu}$ 是度规张量，$dx^{\\mu}$ 是一个无穷小的坐标位移。\n\n- 对于度规适配、无挠的联络，其Levi-Civita联络（Christoffel符号）为\n$$\n\\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\sigma} g_{\\mu\\nu} \\right),\n$$\n其中 $g^{\\mu\\nu}$ 是 $g_{\\mu\\nu}$ 的逆。\n\n- 逆度规的导数可由 $g^{\\mu\\alpha} g_{\\alpha\\nu} = \\delta^{\\mu}{}_{\\nu}$ 推导得出：\n$$\n\\partial_{\\lambda} g^{\\mu\\nu} = - \\, g^{\\mu\\alpha} \\, (\\partial_{\\lambda} g_{\\alpha\\beta}) \\, g^{\\beta\\nu}.\n$$\n\n- Ricci张量是Riemann曲率张量的缩并：\n$$\nR_{\\mu\\nu} = \\partial_{\\alpha} \\Gamma^{\\alpha}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\alpha}{}_{\\mu\\alpha} + \\Gamma^{\\alpha}{}_{\\alpha\\beta} \\Gamma^{\\beta}{}_{\\mu\\nu} - \\Gamma^{\\alpha}{}_{\\mu\\beta} \\Gamma^{\\beta}{}_{\\alpha\\nu}.\n$$\n\n您的程序必须实现以下要求：\n\n1. 实现通用例程，给定一个点上的度规 $g_{\\mu\\nu}(x^{\\lambda})$ 及其一阶和二阶偏导数 $\\partial_{\\lambda} g_{\\mu\\nu}$ 和 $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$，计算：\n   - 逆度规 $g^{\\mu\\nu}$ 及其一阶导数 $\\partial_{\\lambda} g^{\\mu\\nu}$。\n   - Christoffel符号 $\\Gamma^{\\rho}{}_{\\mu\\nu}$ 及其一阶导数 $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$。\n   - 根据上述定义计算Ricci张量 $R_{\\mu\\nu}$。\n\n2. 通过提供 $g_{\\mu\\nu}$、$\\partial_{\\lambda} g_{\\mu\\nu}$ 和 $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$ 的闭合形式，实现三种解析度规：\n   - 笛卡尔坐标 $(t,x,y,z)$ 下的Minkowski度规，号差为 $(-,+,+,+)$：\n     $$\n     g_{\\mu\\nu} = \\mathrm{diag}(-1,\\,1,\\,1,\\,1).\n     $$\n   - Schwarzschild坐标 $(t,r,\\theta,\\phi)$ 下的Schwarzschild度规，质量参数为 $M$：\n     $$\n     g_{tt} = -(1 - 2M/r), \\quad g_{rr} = (1 - 2M/r)^{-1}, \\quad g_{\\theta\\theta} = r^{2}, \\quad g_{\\phi\\phi} = r^{2} \\sin^{2}\\theta,\n     $$\n     所有非对角分量均为 $0$。\n   - Brinkmann坐标 $(u,v,x,y)$ 下的平行射线平面引力波（pp-wave）：\n     $$\n     ds^{2} = -2 \\, du \\, dv + H(u,x,y) \\, du^{2} + dx^{2} + dy^{2},\n     $$\n     其中\n     $$\n     H(u,x,y) = \\sin u \\,(x^{2} - y^{2}).\n     $$\n     非零分量为 $g_{uu} = H$, $g_{uv}=g_{vu}=-1$, $g_{xx}=1$, $g_{yy}=1$。\n\n3. 对每个指定的测试用例，计算：\n   - 对于给定的无穷小位移 $dx^{\\mu}$，计算线元平方 $ds^{2} = g_{\\mu\\nu} dx^{\\mu} dx^{\\nu}$。\n   - 一个由下式定义的真空检验布尔值\n     $$\n     \\mathrm{vacuum\\_ok} = \\left( \\max_{\\mu,\\nu} |R_{\\mu\\nu}|  \\varepsilon \\right),\n     $$\n     使用阈值 $\\varepsilon = 10^{-9}$。\n\n4. 测试套件。请精确使用以下参数值和位移：\n\n   - 测试A (Minkowski):\n     - 坐标 $(t,x,y,z) = (0,\\,1,\\,2,\\,3)$。\n     - 位移 $dx^{\\mu} = (1,\\,0.5,\\,0,\\,0)$。\n     - 预期的定性行为：平直时空，$R_{\\mu\\nu} = 0$。\n\n   - 测试B (Schwarzschild):\n     - 质量 $M = 1$。\n     - 坐标 $(t,r,\\theta,\\phi) = (0,\\,10,\\,\\pi/2,\\,0)$。\n     - 位移 $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$。\n     - 预期的定性行为：真空区域，$R_{\\mu\\nu} = 0$。\n\n   - 测试C (Schwarzschild，靠近视界):\n     - 质量 $M = 1$。\n     - 坐标 $(t,r,\\theta,\\phi) = (0,\\,2.1,\\,\\pi/2,\\,0)$。\n     - 位移 $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$。\n     - 预期的定性行为：真空区域，$R_{\\mu\\nu} = 0$；接近视界用于测试数值稳定性。\n\n   - 测试D (pp-wave，对称横向坐标):\n     - 坐标 $(u,v,x,y) = (0.3,\\,0,\\,1,\\,1)$。\n     - 位移 $dx^{\\mu} = (1,\\,0,\\,0.5,\\,-0.5)$。\n     - 预期的定性行为：在该点 $H=0$，因此横向贡献在 $ds^{2}$ 中占主导地位；真空解意味着 $R_{\\mu\\nu}=0$。\n\n   - 测试E (pp-wave，非平凡轮廓):\n     - 坐标 $(u,v,x,y) = (1.0,\\,0,\\,2,\\,1)$。\n     - 位移 $dx^{\\mu} = (1,\\,0,\\,0,\\,0)$。\n     - 预期的定性行为：$ds^{2} = H(u,x,y)$；真空解意味着 $R_{\\mu\\nu}=0$。\n\n5. 输出格式。您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，按以下顺序将两项附加到列表中：\n   - 计算出的 $ds^{2}$，作为一个浮点数（除了语言默认值外没有四舍五入要求）。\n   - 真空检验布尔值 $\\mathrm{vacuum\\_ok}$。\n\n因此，您的程序必须打印包含十个条目的单行：\n$$\n[\\; ds^{2}_{A},\\ \\mathrm{vacuum\\_ok}_{A},\\ ds^{2}_{B},\\ \\mathrm{vacuum\\_ok}_{B},\\ ds^{2}_{C},\\ \\mathrm{vacuum\\_ok}_{C},\\ ds^{2}_{D},\\ \\mathrm{vacuum\\_ok}_{D},\\ ds^{2}_{E},\\ \\mathrm{vacuum\\_ok}_{E} \\;].\n$$", "solution": "用户问题是数值相对论和张量计算领域中一个定义明确的计算任务，要求实现广义相对论的核心量，并针对已知的Einstein场方程解析解进行验证。该问题具有科学依据，形式规范，且没有任何使其无效的缺陷。可以通过遵循系统化、基于原理的方法来构建一个完整的解决方案。\n\n该解决方案由两个主要部分构成：\n1. 一组表示解析时空的类，这些类以闭合形式提供度规张量 $g_{\\mu\\nu}$ 及其一阶偏导数 $\\partial_{\\lambda}g_{\\mu\\nu}$ 和二阶偏导数 $\\partial_{\\kappa}\\partial_{\\lambda}g_{\\mu\\nu}$。\n2. 一个通用的张量计算引擎，它在给定某一点上的这些导数后，计算所有派生量，包括线元平方 $ds^2$ 和Ricci张量 $R_{\\mu\\nu}$。\n\n坐标的索引始终从 $0$ 到 $3$。例如，在Schwarzschild坐标 $(t,r,\\theta,\\phi)$ 中，$t$ 的索引为 $\\mu=0$，$r$ 的索引为 $\\mu=1$，$\\theta$ 的索引为 $\\mu=2$，$\\phi$ 的索引为 $\\mu=3$。所有数组都遵循此约定，例如，张量 $T_{\\lambda\\mu\\nu}$ 存储在NumPy数组 `T` 中，其分量通过 `T[l,m,n]` 访问。\n\n核心计算步骤如下：\n\n1.  **度规及其导数**：对于每个测试用例，实例化相应的度规类。该类在指定的坐标点提供度规张量 $g_{\\mu\\nu}$、其一阶导数 $\\partial_{\\lambda} g_{\\mu\\nu}$ 和二阶导数 $\\partial_{\\kappa}\\partial_{\\lambda} g_{\\mu\\nu}$ 的数值。这些是所有后续计算的基本输入。\n\n2.  **线元平方 $ds^2$**：线元平方是根据度规 $g_{\\mu\\nu}$ 和给定的坐标位移矢量 $dx^{\\mu}$，使用Einstein求和约定，按照定义计算的：\n    $$\n    ds^{2} = g_{\\mu\\nu} \\, dx^{\\mu} \\, dx^{\\nu}\n    $$\n    这是一个张量缩并，使用矩阵-向量运算高效实现。\n\n3.  **逆度规 $g^{\\mu\\nu}$ 及其导数 $\\partial_{\\lambda}g^{\\mu\\nu}$**：逆度规 $g^{\\mu\\nu}$ 通过数值方法对 $g_{\\mu\\nu}$ 的矩阵表示求逆来计算。然后，使用从 $\\partial_{\\lambda}(g^{\\mu\\alpha}g_{\\alpha\\nu}) = 0$ 推导出的恒等式，从度规的导数计算逆度规的导数：\n    $$\n    \\partial_{\\lambda} g^{\\mu\\nu} = -g^{\\mu\\alpha} (\\partial_{\\lambda} g_{\\alpha\\beta}) g^{\\beta\\nu}\n    $$\n    这个公式使用张量积（具体来说是 `numpy.einsum`）来实现。\n\n4.  **Christoffel符号 $\\Gamma^{\\rho}{}_{\\mu\\nu}$ 及其导数 $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$**：第二类Christoffel符号是使用度规适配、无挠联络的标准公式计算的：\n    $$\n    \\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\sigma} g_{\\mu\\nu} \\right)\n    $$\n    Christoffel符号的导数 $\\partial_{\\lambda}\\Gamma^{\\rho}{}_{\\mu\\nu}$ 是通过对上述表达式应用乘法法则得到的：\n    $$\n    \\partial_{\\lambda} \\Gamma^{\\rho}{}_{\\mu\\nu} = \\frac{1}{2} (\\partial_{\\lambda} g^{\\rho\\sigma}) \\left( \\dots \\right) + \\frac{1}{2} g^{\\rho\\sigma} \\left( \\partial_{\\lambda}\\partial_{\\mu} g_{\\sigma\\nu} + \\partial_{\\lambda}\\partial_{\\nu} g_{\\sigma\\mu} - \\partial_{\\lambda}\\partial_{\\sigma} g_{\\mu\\nu} \\right)\n    $$\n    这些计算依赖于步骤1中计算的度规导数和步骤3中的逆度规导数。所有的张量缩并都使用 `numpy.einsum` 来实现，以提高效率和清晰度。\n\n5.  **Ricci张量 $R_{\\mu\\nu}$**：Ricci张量是根据其定义，由Christoffel符号及其导数组合而成：\n    $$\n    R_{\\mu\\nu} = \\partial_{\\alpha} \\Gamma^{\\alpha}{}_{\\mu\\nu} - \\partial_{\\nu} \\Gamma^{\\alpha}{}_{\\mu\\alpha} + \\Gamma^{\\alpha}{}_{\\alpha\\beta} \\Gamma^{\\beta}{}_{\\mu\\nu} - \\Gamma^{\\alpha}{}_{\\mu\\beta} \\Gamma^{\\beta}{}_{\\alpha\\nu}\n    $$\n    每一项都涉及一个或两个指标的缩并，这些缩并再次使用 `numpy.einsum` 实现，或者在 `einsum` 符号变得模糊的地方使用显式循环以求清晰。\n\n6.  **真空检验**：计算出的Ricci张量 $R_{\\mu\\nu}$ 用于验证该时空在指定点是否为真空解。所有给定的时空（Minkowski、质量外部的Schwarzschild以及pp-wave）都是精确的真空解，这意味着它们的Ricci张量应该恒等于零，$R_{\\mu\\nu}=0$。由于浮点运算，计算出的分量会接近于零，但不会精确为零。因此，真空条件通过数值方法进行检验：\n    $$\n    \\mathrm{vacuum\\_ok} = \\left( \\max_{\\mu,\\nu} |R_{\\mu\\nu}|  \\varepsilon \\right)\n    $$\n    其中阈值给定为 $\\varepsilon = 10^{-9}$。\n\n通过为问题中指定的每个测试用例实现这些步骤，我们生成所需的结果序列：每个测试的线元平方 $ds^2$ 和布尔值的真空检验状态。然后将结果汇总到单个列表中并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n#   - name: scipy\n#     version: 1.11.4\n\nclass TensorAnalysis:\n    \"\"\"\n    Performs tensor calculus computations given a metric and its derivatives.\n    \"\"\"\n    def __init__(self, g, dg, ddg):\n        self.dim = g.shape[0]\n        self.g = g          # g_mn\n        self.dg = dg        # d_l g_mn\n        self.ddg = ddg      # d_k d_l g_mn\n\n        # Pre-compute all derived quantities\n        self.g_inv = np.linalg.inv(self.g) # g^rs\n        self.dg_inv = self._compute_dg_inv() # d_l g^mn\n        self.gamma = self._compute_gamma() # Gamma^r_mn\n        self.dgamma = self._compute_dgamma() # d_l Gamma^r_mn\n        self.ricci = self._compute_ricci() # R_mn\n\n    def _compute_dg_inv(self):\n        # d_l g^mn = -g^ma (d_l g_ab) g^bn\n        return -np.einsum('ma,lab,bn-lmn', self.g_inv, self.dg, self.g_inv)\n\n    def _compute_gamma(self):\n        # Gamma^r_mn = 1/2 g^rs (d_m g_sn + d_n g_sm - d_s g_mn)\n        christoffel_part_lower = self.dg.transpose(1, 2, 0) + self.dg.transpose(2, 1, 0) - self.dg\n        # The above is a compact way of writing:\n        # christoffel_part_lower[s,m,n] = dg[m,s,n] + dg[n,s,m] - dg[s,m,n]\n        return 0.5 * np.einsum('rs,smn-rmn', self.g_inv, christoffel_part_lower)\n\n    def _compute_dgamma(self):\n        # d_l Gamma^r_mn = 1/2 (d_l g^rs)(...) + 1/2 g^rs (d_l d_m g_sn + ...)\n        christoffel_part_lower = self.dg.transpose(1, 2, 0) + self.dg.transpose(2, 1, 0) - self.dg\n        term1 = 0.5 * np.einsum('lrs,smn-lrmn', self.dg_inv, christoffel_part_lower)\n\n        christoffel_deriv_part_lower = self.ddg.transpose(0, 2, 1, 3) + self.ddg.transpose(0, 3, 1, 2) - self.ddg.transpose(0, 2, 3, 1)        \n        # Above is equivalent to:\n        # cdpl[l,s,m,n] = ddg[l,m,s,n] + ddg[l,n,s,m] - ddg[l,s,m,n]\n        term2 = 0.5 * np.einsum('rs,lsmn-lrmn', self.g_inv, christoffel_deriv_part_lower)\n        \n        return term1 + term2\n\n    def _compute_ricci(self):\n        # R_mn = d_a G^a_mn - d_n G^a_ma + G^a_ab G^b_mn - G^a_mb G^b_an\n        term1 = np.einsum('aamn-mn', self.dgamma)\n        \n        # term2 = d_n G^a_ma. Loop is clearer than tricky einsum.\n        term2 = np.zeros((self.dim, self.dim))\n        for m in range(self.dim):\n            for n in range(self.dim):\n                for a in range(self.dim):\n                    term2[m, n] += self.dgamma[n, a, m, a]\n\n        term3 = np.einsum('aab,bmn-mn', self.gamma, self.gamma)\n        term4 = np.einsum('amb,ban-mn', self.gamma, self.gamma)\n        return term1 - term2 + term3 - term4\n\n    def compute_ds2(self, dx):\n        # ds^2 = g_mn dx^m dx^n\n        return np.einsum('ij,i,j-', self.g, dx, dx)\n\n    def get_ricci_tensor(self):\n        return self.ricci\n\nclass AnalyticMetric:\n    def __init__(self, dim=4, **kwargs):\n        self.dim = dim\n\n    def get_derivatives(self, coords):\n        raise NotImplementedError\n\nclass MinkowskiMetric(AnalyticMetric):\n    def get_derivatives(self, coords):\n        g = np.diag([-1.0, 1.0, 1.0, 1.0])\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n        return g, dg, ddg\n\nclass SchwarzschildMetric(AnalyticMetric):\n    def __init__(self, M, dim=4):\n        super().__init__(dim)\n        self.M = M\n\n    def get_derivatives(self, coords):\n        _t, r, th, _p = coords\n        M = self.M\n        g = np.zeros((self.dim, self.dim))\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, self.dim))\n\n        f = 1.0 - 2.0 * M / r\n        sin_th = np.sin(th)\n        cos_th = np.cos(th)\n        sin_2th = np.sin(2.0 * th)\n        cos_2th = np.cos(2.0 * th)\n\n        # Metric components (non-zero)\n        g[0, 0] = -f\n        g[1, 1] = 1.0 / f\n        g[2, 2] = r**2\n        g[3, 3] = r**2 * sin_th**2\n\n        # First derivatives (only w.r.t r=1 and th=2 are non-zero)\n        # partial_r\n        df_dr = 2.0 * M / r**2\n        gtt_r = -df_dr\n        grr_r = -1.0 / f**2 * df_dr\n        dg[1, 0, 0] = gtt_r\n        dg[1, 1, 1] = grr_r\n        dg[1, 2, 2] = 2.0 * r\n        dg[1, 3, 3] = 2.0 * r * sin_th**2\n        # partial_theta\n        gpp_th = r**2 * sin_2th\n        dg[2, 3, 3] = gpp_th\n\n        # Second derivatives\n        # partial_r partial_r\n        d2f_dr2 = -4.0 * M / r**3\n        gtt_rr = -d2f_dr2\n        grr_rr = (2.0 / f**3) * df_dr**2 - (1.0 / f**2) * d2f_dr2\n        ddg[1, 1, 0, 0] = gtt_rr\n        ddg[1, 1, 1, 1] = grr_rr\n        ddg[1, 1, 2, 2] = 2.0\n        ddg[1, 1, 3, 3] = 2.0 * sin_th**2\n        # partial_th partial_th\n        gpp_thth = r**2 * 2.0 * cos_2th\n        ddg[2, 2, 3, 3] = gpp_thth\n        # partial_r partial_th (mixed)\n        gpp_rth = 2.0 * r * sin_2th\n        ddg[1, 2, 3, 3] = gpp_rth\n        ddg[2, 1, 3, 3] = gpp_rth\n        \n        return g, dg, ddg\n\nclass PPWaveMetric(AnalyticMetric):\n    def get_derivatives(self, coords):\n        u, _v, x, y = coords\n        g = np.zeros((self.dim, self.dim))\n        dg = np.zeros((self.dim, self.dim, self.dim))\n        ddg = np.zeros((self.dim, self.dim, self.dim, selfdim))\n\n        sin_u = np.sin(u)\n        cos_u = np.cos(u)\n        \n        H = sin_u * (x**2 - y**2)\n        \n        # Metric components\n        g[0, 0] = H\n        g[0, 1] = g[1, 0] = -1.0\n        g[2, 2] = 1.0\n        g[3, 3] = 1.0\n\n        # First derivatives (only g_00 depends on coords)\n        dg[0, 0, 0] = cos_u * (x**2 - y**2) # d_u g_uu\n        dg[2, 0, 0] = sin_u * (2.0 * x)     # d_x g_uu\n        dg[3, 0, 0] = sin_u * (-2.0 * y)    # d_y g_uu\n\n        # Second derivatives\n        ddg[0, 0, 0, 0] = -sin_u * (x**2 - y**2) # d_u d_u g_uu\n        ddg[2, 2, 0, 0] = sin_u * 2.0             # d_x d_x g_uu\n        ddg[3, 3, 0, 0] = sin_u * -2.0            # d_y d_y g_uu\n        \n        # Mixed derivatives\n        ddg[0, 2, 0, 0] = ddg[2, 0, 0, 0] = cos_u * (2.0 * x)     # d_u d_x g_uu\n        ddg[0, 3, 0, 0] = ddg[3, 0, 0, 0] = cos_u * (-2.0 * y)    # d_u d_y g_uu\n        # d_x d_y g_uu is zero\n\n        return g, dg, ddg\n\ndef solve():\n    test_cases = [\n        {\n            'name': 'A',\n            'metric_class': MinkowskiMetric,\n            'params': {},\n            'coords': np.array([0.0, 1.0, 2.0, 3.0]),\n            'dx': np.array([1.0, 0.5, 0.0, 0.0]),\n        },\n        {\n            'name': 'B',\n            'metric_class': SchwarzschildMetric,\n            'params': {'M': 1.0},\n            'coords': np.array([0.0, 10.0, np.pi/2, 0.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n        {\n            'name': 'C',\n            'metric_class': SchwarzschildMetric,\n            'params': {'M': 1.0},\n            'coords': np.array([0.0, 2.1, np.pi/2, 0.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n        {\n            'name': 'D',\n            'metric_class': PPWaveMetric,\n            'params': {},\n            'coords': np.array([0.3, 0.0, 1.0, 1.0]),\n            'dx': np.array([1.0, 0.0, 0.5, -0.5]),\n        },\n        {\n            'name': 'E',\n            'metric_class': PPWaveMetric,\n            'params': {},\n            'coords': np.array([1.0, 0.0, 2.0, 1.0]),\n            'dx': np.array([1.0, 0.0, 0.0, 0.0]),\n        },\n    ]\n\n    results = []\n    vacuum_threshold = 1e-9\n\n    for case in test_cases:\n        metric_instance = case['metric_class'](**case['params'])\n        g, dg, ddg = metric_instance.get_derivatives(case['coords'])\n        \n        analysis = TensorAnalysis(g, dg, ddg)\n        \n        ds2 = analysis.compute_ds2(case['dx'])\n        ricci = analysis.get_ricci_tensor()\n        \n        max_abs_ricci = np.max(np.abs(ricci))\n        vacuum_ok = max_abs_ricci  vacuum_threshold\n        \n        results.append(ds2)\n        results.append(vacuum_ok)\n    \n    # Format boolean as lowercase 'true'/'false' for consistency, then join.\n    formatted_results = [str(r).lower() if isinstance(r, bool) else str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n\n```", "id": "3493362"}]}