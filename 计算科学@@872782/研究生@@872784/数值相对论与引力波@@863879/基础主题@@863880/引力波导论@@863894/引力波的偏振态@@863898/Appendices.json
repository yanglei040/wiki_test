{"hands_on_practices": [{"introduction": "与光学中的应用类似，斯托克斯参数是描述引力波等横波偏振态的强大工具。这个练习将指导你实现从引力波应变数据 $h_+(t)$ 和 $h_\\times(t)$ 计算斯托克斯参数的过程。你将通过在一个旋转的测量基底下验证其不变量，来确认该表述的稳健性，这对于解释来自旋进双星等复杂系统的信号至关重要。[@problem_id:3483111]", "problem": "在线性化的横向无迹规范中，一个横向传播的弱引力波由两个实数应变分量来描述，即 plus 偏振 $h_{+}(t)$ 和 cross 偏振 $h_{\\times}(t)$。在窄带近似下，偏振可以通过一个由 $h_{+}(t)$ 和 $h_{\\times}(t)$ 的复解析表示构建的偏振相干矩阵来表征。从这个相干矩阵，可以定义四个实值偏振 Stokes 参数 $(I,Q,U,V)$，它们量化了引力波的总强度、线性偏振分量和圆偏振。由于引力波的自旋为2的特性，围绕传播轴将偏振基旋转一个物理角度 $\\psi(t)$，会引起实数应变分量发生两倍该角度的变换。稳健的偏振表征要求此变换的不变量得以保持：总强度和圆偏振应当是基不变量，而线性偏振分量应在自身之间旋转，其大小保持不变。\n\n基于这些基础：\n- 在横向无迹规范下，单个探测器测得的实值应变 $h_{+}(t)$ 和 $h_{\\times}(t)$。\n- 与实数信号 $x(t)$ 相关联的复解析信号 $a(t)$ 定义为 $a(t) = x(t) + i\\,\\mathcal{H}\\{x(t)\\}$，其中 $\\mathcal{H}\\{\\cdot\\}$ 表示希尔伯特变换 (Hilbert transform)。\n- 偏振相干矩阵由与 $h_{+}(t)$ 和 $h_{\\times}(t)$ 相关联的解析信号构建。\n- 在旋转角度 $\\psi(t)$（以弧度为单位）下，物理偏振轴旋转 $2\\psi(t)$，影响作为双分量场的 $(h_{+},h_{\\times})$。\n\n实现一个程序，以科学上自洽的方式执行以下任务：\n\n1. 对于每个给定的测试用例，构建时间序列 $h_{+}(t)$ 和 $h_{\\times}(t)$。采样率 $f_{\\mathrm{s}} = $ $4096$ 样本/秒，持续时间 $T = $ $1$ 秒，即 $t = 0, 1/f_{\\mathrm{s}}, 2/f_{\\mathrm{s}}, \\dots, T-1/f_{\\mathrm{s}}$。所有计算中角度必须以弧度为单位。\n\n2. 计算与 $h_{+}(t)$ 和 $h_{\\times}(t)$ 相关联的复解析信号 $a_{+}(t)$ 和 $a_{\\times}(t)$，构建偏振相干矩阵，并由此计算 Stokes 参数的时间序列 $(I(t), Q(t), U(t), V(t))$。\n\n3. 通过使用 $2\\psi(t)$ 的旋转变换实数应变，将偏振基按指定的时间相关角度 $\\psi(t)$ 旋转，然后在旋转后的基中重新计算解析信号和 Stokes 参数 $(I'(t), Q'(t), U'(t), V'(t))$。\n\n4. 通过为每个测试用例计算以下无量纲误差度量，来量化在进动和模式混合下的稳健性：\n   - $e_{I} = \\displaystyle \\frac{\\max_{t} \\left| I(t) - I'(t) \\right|}{\\max_{t} \\left| I(t) \\right| + \\epsilon}$，\n   - $e_{V} = \\displaystyle \\frac{\\max_{t} \\left| V(t) - V'(t) \\right|}{\\max_{t} \\left| V(t) \\right| + \\epsilon}$，\n   - $e_{L} = \\displaystyle \\frac{\\max_{t} \\left| \\sqrt{Q(t)^{2} + U(t)^{2}} - \\sqrt{Q'(t)^{2} + U'(t)^{2}} \\right|}{\\max_{t} \\left( \\sqrt{Q(t)^{2} + U(t)^{2}} \\right) + \\epsilon}$，\n   其中 $\\epsilon = $ $10^{-30}$ 是一个小的正常数，以避免除以零。这些度量旨在测试强度和圆偏振在基旋转下的不变性，以及线性偏振的大小在混合 $Q$ 和 $U$ 的旋转下的不变性。所有输出均为无量纲实数。\n\n5. 使用以下科学上合理的测试套件，其设计旨在探究一个理想路径情况、一个边界情况以及一个带有模式混合的边缘情况：\n   - 测试用例 1（理想路径，缓慢变化的进动，近圆偏振）：\n     - 振幅 $A = $ $10^{-21}$，\n     - 频率 $f = $ $150$ 赫兹，\n     - $h_{+}(t) = A \\cos(2\\pi f t)$，\n     - $h_{\\times}(t) = A \\sin(2\\pi f t)$，\n     - 进动角 $\\psi(t) = 0.5 \\sin(2\\pi \\cdot 1 \\cdot t)$ 弧度。\n   - 测试用例 2（边界情况，线性偏振）：\n     - 振幅 $A = $ $10^{-21}$，\n     - 频率 $f = $ $100$ 赫兹，\n     - $h_{+}(t) = A \\cos(2\\pi f t)$，\n     - $h_{\\times}(t) = 0$，\n     - 旋转角 $\\psi(t) = 0.25\\, t$ 弧度。\n   - 测试用例 3（边缘情况，模式混合和更快的进动）：\n     - 基础振幅 $A = $ $10^{-21}$，\n     - 频率 $f_{1} = $ $90$ 赫兹 和 $f_{2} = $ $130$ 赫兹，\n     - 振幅 $A_{1} = A$，$A_{2} = 0.6 A$，$B_{1} = 0.8 A$，\n     - 相位 $\\phi_{2} = $ $0.3$ 弧度 和 $\\phi_{\\times} = -0.2$ 弧度，\n     - $h_{+}(t) = A_{1} \\cos(2\\pi f_{1} t) + A_{2} \\cos(2\\pi f_{2} t + \\phi_{2})$，\n     - $h_{\\times}(t) = B_{1} \\sin(2\\pi f_{1} t + \\phi_{\\times})$，\n     - 进动角 $\\psi(t) = 0.8 \\sin(2\\pi \\cdot 3 \\cdot t)$ 弧度。\n\n你的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号内以逗号分隔的列表，顺序为 $[e_{I}^{(1)}, e_{V}^{(1)}, e_{L}^{(1)}, e_{I}^{(2)}, e_{V}^{(2)}, e_{L}^{(2)}, e_{I}^{(3)}, e_{V}^{(3)}, e_{L}^{(3)}]$，其中上标表示测试用例编号。所有输出必须表示为无量纲浮点数。角度必须以弧度处理，时间以秒为单位。不允许外部输入；测试套件如上固定，并且必须嵌入到程序中。", "solution": "问题陈述已经过评估并被确定为有效。它在科学上基于广义相对论和引力波数据分析的原理，定义和参数完整一致，表述客观，是一个适定问题。因此，我们可以着手解决。\n\n这个问题的核心是验证引力波 Stokes 参数在偏振基旋转下的变换性质。Stokes 参数 $(I, Q, U, V)$ 提供了横波偏振状态的完整描述。对于像引力波这样的自旋为2的场，由这些参数构建的某些量在探测器坐标系物理旋转角度 $\\psi(t)$ 时必须保持不变。具体来说，总强度 $I(t)$ 和净圆偏振 $V(t)$ 必须是标量，因此是不变的。线性偏振分量 $Q(t)$ 和 $U(t)$ 在一个概念性的“偏振平面”中形成一个矢量，并预期会在它们之间发生旋转，但这个线性偏振矢量的大小 $L(t) = \\sqrt{Q(t)^2 + U(t)^2}$ 必须是不变的。\n\n解决方案框架对每个测试用例包含以下步骤序列：\n1.  将连续时间变量 $t$ 离散化。\n2.  生成 plus 偏振 $h_+(t)$ 和 cross 偏振 $h_\\times(t)$ 的时间序列。\n3.  计算相关的复解析信号 $a_+(t)$ 和 $a_\\times(t)$。\n4.  计算初始的 Stokes 参数集 $(I(t), Q(t), U(t), V(t))$。\n5.  对指定的随时间变化的旋转应用于应变分量，以获得旋转后的应变 $h'_+(t)$ 和 $h'_\\times(t)$。\n6.  为旋转后的系统重新计算解析信号和 Stokes 参数 $(I'(t), Q'(t), U'(t), V'(t))$。\n7.  计算误差度量 $e_I$、 $e_V$ 和 $e_L$ 以量化理论上不变的量的不变性。\n\n**步骤1：时间离散化**\n连续时间变量 $t$ 在持续时间 $T = 1$ 秒内以 $f_s = 4096$ 赫兹的采样频率进行采样。这产生 $N = T \\cdot f_s = 4096$ 个离散时间点。时间向量由 $t_k = k / f_s$ 给出，其中 $k = 0, 1, \\dots, N-1$。\n\n**步骤2：波形生成**\n对每个测试用例，我们使用提供的函数形式和参数生成离散时间序列 $h_+(t_k)$ 和 $h_\\times(t_k)$。\n\n**步骤3：复解析信号**\n对应于实数信号 $x(t)$ 的解析信号 $a(t)$ 是一个复数信号，定义为 $a(t) = x(t) + i\\mathcal{H}\\{x(t)\\}$，其中 $\\mathcal{H}\\{\\cdot\\}$ 是希尔伯特变换 (Hilbert transform)。函数的希尔伯特变换可以使用快速傅里叶变换 (FFT) 高效计算。具体来说，如果 $X(f) = \\mathcal{F}\\{x(t)\\}$ 是 $x(t)$ 的傅里叶变换，那么其希尔伯特变换的傅里叶变换是 $\\mathcal{F}\\{\\mathcal{H}\\{x(t)\\}\\}(f) = -i \\cdot \\text{sgn}(f) \\cdot X(f)$。然后，通过对 $f>0$ 的 $2X(f)$ 和 $f=0$ 的 $X(f)$（以及 $f<0$ 的零）进行傅里叶逆变换来构建解析信号。在计算上，这由 `scipy.signal.hilbert` 函数处理。我们从实数应变数据 $h_+(t_k)$ 和 $h_\\times(t_k)$ 计算 $a_+(t_k)$ 和 $a_\\times(t_k)$。\n\n**步骤4：Stokes 参数的计算**\n瞬时 Stokes 参数是根据解析信号 $a_+(t)$ 和 $a_\\times(t)$ 定义的。这些定义源于瞬时偏振相干矩阵的分量。\n- 总强度：$I(t) = |a_+(t)|^2 + |a_\\times(t)|^2$\n- 线性偏振 (水平/垂直)：$Q(t) = |a_+(t)|^2 - |a_\\times(t)|^2$\n- 线性偏振 (对角)：$U(t) = 2 \\operatorname{Re}[a_+^*(t) a_\\times(t)]$\n- 圆偏振：$V(t) = 2 \\operatorname{Im}[a_+^*(t) a_\\times(t)]$\n\n这里，$a_+^*(t)$ 是 $a_+(t)$ 的复共轭。将这些公式应用于时间序列 $a_+(t_k)$ 和 $a_\\times(t_k)$，以获得 $I(t_k)$、$Q(t_k)$、$U(t_k)$ 和 $V(t_k)$ 的离散时间序列。\n\n**步骤5：偏振基的旋转**\n探测器轴围绕波的传播方向物理旋转角度 $\\psi(t)$，会导致应变分量的变换。由于引力场的自旋为2的性质，在新基中测量的分量 $(h'_+, h'_\\times)$ 与原始分量通过一个旋转角为 $\\theta(t) = 2\\psi(t)$ 的旋转矩阵相关联。\n$$\n\\begin{pmatrix} h'_+(t) \\\\ h'_\\times(t) \\end{pmatrix} = \\begin{pmatrix} \\cos(2\\psi(t)) & \\sin(2\\psi(t)) \\\\ -\\sin(2\\psi(t)) & \\cos(2\\psi(t)) \\end{pmatrix} \\begin{pmatrix} h_+(t) \\\\ h_\\times(t) \\end{pmatrix}\n$$\n我们将此变换应用于原始应变时间序列 $h_+(t_k)$ 和 $h_\\times(t_k)$，以生成旋转后的时间序列 $h'_+(t_k)$ 和 $h'_\\times(t_k)$。\n\n**步骤6：重新计算 Stokes 参数**\n遵循与步骤3和4相同的程序，我们首先计算对应于旋转后实数应变 $h'_+(t_k)$ 和 $h'_\\times(t_k)$ 的解析信号 $a'_+(t_k)$ 和 $a'_\\times(t_k)$。然后，我们使用相同的公式计算新的 Stokes 参数 $(I'(t_k), Q'(t_k), U'(t_k), V'(t_k))$：\n- $I'(t) = |a'_+(t)|^2 + |a'_\\times(t)|^2$\n- $Q'(t) = |a'_+(t)|^2 - |a'_\\times(t)|^2$\n- $U'(t) = 2 \\operatorname{Re}[a'^*_+(t) a'_\\times(t)]$\n- $V'(t) = 2 \\operatorname{Im}[a'^*_+(t) a'_\\times(t)]$\n\n**步骤7：误差度量的计算**\n最后一步是量化与理论不变量的数值一致性。我们计算三个指定的误差度量，它们测量计算出的不变量的相对偏差。\n- $e_I = \\displaystyle \\frac{\\max_{t} | I(t) - I'(t) |}{\\max_{t} | I(t) | + \\epsilon}$\n- $e_V = \\displaystyle \\frac{\\max_{t} | V(t) - V'(t) |}{\\max_{t} | V(t) | + \\epsilon}$\n- $e_L = \\displaystyle \\frac{\\max_{t} \\left| \\sqrt{Q(t)^2 + U(t)^2} - \\sqrt{Q'(t)^2 + U'(t)^2} \\right|}{\\max_{t} (\\sqrt{Q(t)^2 + U(t)^2}) + \\epsilon}$\n常数 $\\epsilon = 10^{-30}$ 确保在某些量理论上为零（例如，纯线性偏振波的 $V(t)$）的情况下的数值稳定性。预期结果是这些误差将在机器精度的数量级上，从而证实 Stokes 参数表述在基旋转下的稳健性。\n\n对三个测试用例中的每一个都执行这整个过程，并将得到的九个误差度量收集起来作为最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy.signal import hilbert\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave polarization problem by generating waveforms,\n    computing Stokes parameters, applying basis rotations, and calculating\n    invariance error metrics for three test cases.\n    \"\"\"\n    \n    # Global parameters\n    f_s = 4096.0  # Sampling rate in Hz\n    T = 1.0       # Duration in seconds\n    epsilon = 1e-30 # Small constant for numerical stability\n\n    # Time vector\n    t = np.arange(0, T, 1 / f_s)\n    \n    # Test case definitions\n    A = 1e-21\n    \n    test_cases = [\n        {\n            \"name\": \"Case 1: Near-circular polarization, slow precession\",\n            \"h_plus_func\": lambda t: A * np.cos(2 * np.pi * 150 * t),\n            \"h_cross_func\": lambda t: A * np.sin(2 * np.pi * 150 * t),\n            \"psi_func\": lambda t: 0.5 * np.sin(2 * np.pi * 1 * t)\n        },\n        {\n            \"name\": \"Case 2: Linear polarization\",\n            \"h_plus_func\": lambda t: A * np.cos(2 * np.pi * 100 * t),\n            \"h_cross_func\": lambda t: np.zeros_like(t),\n            \"psi_func\": lambda t: 0.25 * t\n        },\n        {\n            \"name\": \"Case 3: Mode-mixing, fast precession\",\n            \"h_plus_func\": lambda t: (A * np.cos(2 * np.pi * 90 * t) + \n                                     0.6 * A * np.cos(2 * np.pi * 130 * t + 0.3)),\n            \"h_cross_func\": lambda t: 0.8 * A * np.sin(2 * np.pi * 90 * t - 0.2),\n            \"psi_func\": lambda t: 0.8 * np.sin(2 * np.pi * 3 * t)\n        }\n    ]\n\n    all_results = []\n\n    def compute_stokes(h_plus, h_cross):\n        \"\"\"Computes instantaneous Stokes parameters from real strain data.\"\"\"\n        a_plus = hilbert(h_plus)\n        a_cross = hilbert(h_cross)\n        \n        a_plus_conj = np.conj(a_plus)\n        \n        I = np.abs(a_plus)**2 + np.abs(a_cross)**2\n        Q = np.abs(a_plus)**2 - np.abs(a_cross)**2\n        U = 2 * np.real(a_plus_conj * a_cross)\n        V = 2 * np.imag(a_plus_conj * a_cross)\n        \n        return I, Q, U, V\n\n    for case in test_cases:\n        # 1. Generate original waveforms\n        h_plus = case[\"h_plus_func\"](t)\n        h_cross = case[\"h_cross_func\"](t)\n        \n        # 2. Compute original Stokes parameters\n        I, Q, U, V = compute_stokes(h_plus, h_cross)\n        \n        # 3. Generate rotated waveforms\n        psi = case[\"psi_func\"](t)\n        theta = 2 * psi\n        cos_theta = np.cos(theta)\n        sin_theta = np.sin(theta)\n        \n        h_plus_rot = h_plus * cos_theta + h_cross * sin_theta\n        h_cross_rot = -h_plus * sin_theta + h_cross * cos_theta\n        \n        # 4. Compute rotated Stokes parameters\n        I_rot, Q_rot, U_rot, V_rot = compute_stokes(h_plus_rot, h_cross_rot)\n        \n        # 5. Compute error metrics\n        # Error for I\n        numerator_I = np.max(np.abs(I - I_rot))\n        denominator_I = np.max(np.abs(I)) + epsilon\n        e_I = numerator_I / denominator_I\n        \n        # Error for V\n        numerator_V = np.max(np.abs(V - V_rot))\n        denominator_V = np.max(np.abs(V)) + epsilon\n        e_V = numerator_V / denominator_V\n        \n        # Error for L = sqrt(Q^2 + U^2)\n        L = np.sqrt(Q**2 + U**2)\n        L_rot = np.sqrt(Q_rot**2 + U_rot**2)\n        numerator_L = np.max(np.abs(L - L_rot))\n        denominator_L = np.max(L) + epsilon\n        e_L = numerator_L / denominator_L\n        \n        all_results.extend([e_I, e_V, e_L])\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "3483111"}, {"introduction": "在数值相对论模拟中，引力波信号可以通过不同的形式提取，最常见的是度规微扰（应变 $h$）和纽曼-彭罗斯（Newman-Penrose）曲率标量（$\\Psi_4$）。本练习旨在探索它们之间的基本关系 $\\Psi_4 = \\ddot{h}$，并解决将一种形式转换为另一种形式时遇到的实际挑战，例如处理积分常数和数值漂移。执行这种交叉检验是验证模拟工作流程自洽性的关键一步。[@problem_id:3483091]", "problem": "给定一个在广义相对论（GR）的线性化机制下，沿 $z$ 轴传播的人工合成的真空平面波引力信号。在横向无迹（TT）规范中，两种极化态由应变分量 $h_{+}(t)$ 和 $h_{\\times}(t)$ 表示，复应变定义为 $h(t) = h_{+}(t) - i\\,h_{\\times}(t)$。在未来类光无穷远的 Newman-Penrose（NP）形式体系中，曲率标量 $\\Psi_{4}(t)$ 等于复应变的二阶时间导数，即 $\\Psi_{4}(t) = \\ddot{h}(t)$。您的任务是实现两个独立的处理流程，从两种数据产品中恢复 $h_{+}(t)$ 和 $h_{\\times}(t)$，并通过相位对齐来协调积分常数和漂移，然后量化其一致性。\n\n基本原理：\n- 真空中的线性化 GR，TT 规范中的平面波解，其中空间度规为 $g_{ij}(t) = \\delta_{ij} + h_{ij}^{\\mathrm{TT}}(t)$，且 $h_{ij}^{\\mathrm{TT}}$ 是无迹和横向的。\n- 对于沿 $z$ 轴传播的 TT 规范，$h_{ij}^{\\mathrm{TT}}(t)$ 编码了两种极化 $h_{+}(t)$ 和 $h_{\\times}(t)$。\n- 在未来类光无穷远处的 Newman-Penrose 标量 $\\Psi_{4}(t)$ 等于复应变 $h(t)$ 的二阶时间导数。\n- 离散时间序列将使用快速傅里叶变换（FFT）及其逆变换（IFFT）进行处理，利用频域运算来执行时间积分和微分。\n\n给定以下三个测试案例，您必须：\n- 合成一个具有指定振幅包络和相位演化的复应变 $h(t)$。\n- 根据应变在 TT 规范中构建空间度规分量 $g_{xx}(t)$、$g_{yy}(t)$、$g_{xy}(t)$。\n- 通过在频域中对复应变应用二阶时间导数来构建 $\\Psi_{4}(t)$。\n- 通过在频域中使用高通正则化进行双重时间积分，从 $\\Psi_{4}(t)$ 中恢复 $h(t)$：对于傅里叶角频率 $\\omega$ 满足 $|\\omega| < \\omega_{\\mathrm{cut}}$ 的情况，将相应的复应变傅里叶模式设置为零；对于 $|\\omega| \\ge \\omega_{\\mathrm{cut}}$ 的情况，则除以 $-\\omega^{2}$。使用 $f_{\\mathrm{cut}} = 5$ 赫兹的截止频率，即 $\\omega_{\\mathrm{cut}} = 2\\pi f_{\\mathrm{cut}}$。角度以弧度为单位。\n- 通过识别与沿 $z$ 轴的平面波一致的 TT 分量，直接从度规中恢复 $h(t)$，即从空间度规中提取 $h_{+}(t)$ 和 $h_{\\times}(t)$，并构建 $h(t) = h_{+}(t) - i\\,h_{\\times}(t)$。\n- 通过使用复数最小二乘法将基于曲率的重建 $h_{\\mathrm{curv}}(t)$ 对齐到基于度规的重建 $h_{\\mathrm{metric}}(t)$，以确定复常数 $c_{0}$ 和 $c_{1}$，从而最小化时域平方误差，来协调积分常数和可能的残余漂移\n$$\n\\sum_{k=0}^{N-1} \\left| \\left(h_{\\mathrm{curv}}(t_{k}) + c_{0} + c_{1}\\,t_{k}\\right) - h_{\\mathrm{metric}}(t_{k}) \\right|^{2},\n$$\n并将对齐后的重建定义为 $h_{\\mathrm{aligned}}(t) = h_{\\mathrm{curv}}(t) + c_{0} + c_{1}\\,t$。\n- 对于每个测试案例，报告最大绝对差\n$$\n\\Delta_{\\infty} = \\max_{k} \\left| h_{\\mathrm{aligned}}(t_{k}) - h_{\\mathrm{metric}}(t_{k}) \\right|.\n$$\n\n人工合成信号规格（所有振幅均为无量纲；时间单位为秒；频率单位为赫兹；角度单位为弧度）：\n- 复应变由下式给出\n$$\nh(t) = A(t)\\,\\exp\\!\\left( i\\,\\phi(t) \\right)\\,\\exp\\!\\left(-2i\\,\\psi\\right),\n$$\n其中极化角为 $\\psi$，相位为\n$$\n\\phi(t) = 2\\pi\\left(f_{0}\\,t + \\tfrac{1}{2}\\,\\dot{f}\\,t^{2}\\right) + \\phi_{0},\n$$\n振幅包络为 $A(t) = A_{0}\\,\\left(1 + \\alpha\\,t\\right)$。\n- 通过 $h_{+}(t) = \\Re[h(t)]$ 和 $h_{\\times}(t) = -\\Im[h(t)]$ 构建 TT 空间度规分量\n$g_{xx}(t) = 1 + h_{+}(t)$，$g_{yy}(t) = 1 - h_{+}(t)$，以及 $g_{xy}(t) = h_{\\times}(t)$。\n- 通过在频域中对 $h(t)$ 应用二阶时间导数来构建 $\\Psi_{4}(t)$。\n\n相位对齐和漂移处理：\n- 从 $\\Psi_{4}(t)$ 重建 $h_{\\mathrm{curv}}(t)$ 后，通过最小化上述最小二乘目标来确定复常数 $c_{0}$ 和 $c_{1}$，并用它们来定义 $h_{\\mathrm{aligned}}(t)$。\n- 对于测试案例 3，通过在比较前向基于度规的应变添加一个复仿射趋势 $d_{0} + d_{1}\\,t$ 来模拟类规范漂移；此漂移必须被对齐阶段吸收。\n\n测试套件：\n- 使用以下三组参数来合成数据。设时间样本为 $t_{k} = k\\,\\Delta t$，其中 $k = 0,1,\\dots,N-1$，且 $N = \\lfloor T/\\Delta t \\rfloor$。\n    1. 测试案例 1（恒定频率，恒定振幅）：\n       - $T = 0.5$, $\\Delta t = 1/4096$, $A_{0} = 1.0\\times 10^{-21}$, $\\alpha = 0.0$, $f_{0} = 100.0$, $\\dot{f} = 0.0$, $\\psi = 0.3$, $\\phi_{0} = 0.2$。\n    2. 测试案例 2（线性啁啾，振幅上升）：\n       - $T = 1.0$, $\\Delta t = 1/4096$, $A_{0} = 5.0\\times 10^{-22}$, $\\alpha = 0.8$, $f_{0} = 50.0$, $\\dot{f} = 120.0$, $\\psi = -0.5$, $\\phi_{0} = 0.1$。\n    3. 测试案例 3（线性啁啾，振幅上升，度规漂移）：\n       - $T = 1.0$, $\\Delta t = 1/4096$, $A_{0} = 8.0\\times 10^{-22}$, $\\alpha = 0.5$, $f_{0} = 80.0$, $\\dot{f} = 80.0$, $\\psi = 0.8$, $\\phi_{0} = -0.3$。\n       - 度规漂移：向基于度规的复应变添加 $d_{0} + d_{1}\\,t$，其中 $d_{0} = 3.0\\times 10^{-23}\\,\\exp(i\\,0.2)$ 且 $d_{1} = 1.0\\times 10^{-23}\\,\\exp(-i\\,0.5)$。\n\n数值方法要求：\n- 对均匀采样的时间序列使用 FFT/IFFT 对，在频域中实现微分和积分。设角频率为 $\\omega_{k} = 2\\pi\\,k/T$，并根据 FFT 频率约定进行映射。\n- 要从 $h(t)$ 构建 $\\Psi_{4}(t)$，将 $h(t)$ 的傅里叶变换乘以 $-\\omega^{2}$，然后应用 IFFT。\n- 要从 $\\Psi_{4}(t)$ 重建 $h(t)$，将 $\\Psi_{4}(t)$ 的傅里叶变换在 $|\\omega| \\ge \\omega_{\\mathrm{cut}}$ 的地方除以 $-\\omega^{2}$，对于 $|\\omega| < \\omega_{\\mathrm{cut}}$ 的模式设置为零，然后应用 IFFT。\n- 通过对整个时间区间进行线性回归，独立求解 $c_{0}$ 和 $c_{1}$ 的实部和虚部，以执行复数最小二乘对齐。\n\n输出规格：\n- 对于三个测试案例中的每一个，计算如上定义的 $\\Delta_{\\infty}$。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为测试案例 1、测试案例 2、测试案例 3，例如：\"[result1,result2,result3]\"。\n- 输出必须是十进制浮点数。不打印任何单位；所有量在几何化单位制中都是无量纲的，其中 $G=c=1$，时间单位为秒，角度单位为弧度。", "solution": "所提出的问题是有效的。这是一个定义明确、有科学依据的数值相对论和引力波数据分析练习。其前提基于广义相对论线性化的既定原则，并且数值任务已清晰定义并提供了所有必要参数。我们将继续提供完整解决方案。\n\n核心任务是协调从一个合成数据集中对引力波（GW）应变 $h(t) = h_{+}(t) - i h_{\\times}(t)$ 的两种独立重建。第一种重建 $h_{\\mathrm{metric}}(t)$ 直接从空间度规张量的分量导出。第二种重建 $h_{\\mathrm{curv}}(t)$ 是通过对 Newman-Penrose 曲率标量 $\\Psi_{4}(t)$ 进行积分得到的。关系式 $\\Psi_{4}(t) = \\ddot{h}(t)$ 对于未来类光无穷远处的真空中平面波是基础性的。两种重建之间的差异源于数值方法和引入的漂移，这些差异将通过最小二乘对齐程序来解决。最终的一致性通过对齐后的信号与基于度规的信号之间的最大绝对差来量化。\n\n该过程针对三个不同的测试案例执行，遵循以下步骤：\n\n1.  **人工合成信号生成**\n    首先，我们合成了沿 $z$ 轴传播的平面波的“真实”复引力波应变 $h_{\\mathrm{true}}(t)$。该信号由其振幅包络 $A(t)$、时间相位 $\\phi(t)$ 和一个恒定的极化角 $\\psi$ 定义：\n    $$\n    h_{\\mathrm{true}}(t) = A(t) \\exp(i\\phi(t)) \\exp(-2i\\psi)\n    $$\n    振幅包络随时间线性变化，$A(t) = A_{0}(1 + \\alpha t)$，相位代表一个瞬时频率线性变化的信号（“啁啾”），$\\phi(t) = 2\\pi\\left(f_{0}t + \\frac{1}{2}\\dot{f}t^{2}\\right) + \\phi_{0}$。\n    信号在均匀的时间网格 $t_k = k\\Delta t$上采样，其中 $k = 0, \\dots, N-1$，$N = \\lfloor T/\\Delta t \\rfloor$。\n\n2.  **处理流程 1：基于度规的应变重建**\n    第一个重建处理流程使用横向无迹（TT）规范中的空间度规分量。从真实的复应变 $h_{\\mathrm{true}}(t)$，我们定义两个实数极化分量：\n    $$\n    h_{+}(t) = \\Re[h_{\\mathrm{true}}(t)]\n    $$\n    $$\n    h_{\\times}(t) = -\\Im[h_{\\mathrm{true}}(t)]\n    $$\n    然后，通过组合这些极化来构建基于度规的重建 $h_{\\mathrm{metric}}(t)$，这等同于原始的真实应变 $h_{\\mathrm{true}}(t)$。\n    $$\n    h_{\\mathrm{metric}}(t) = h_{+}(t) - i h_{\\times}(t) = h_{\\mathrm{true}}(t)\n    $$\n    对于测试案例 3，在此重建中添加了一个人工合成的复仿射漂移 $d(t) = d_{0} + d_{1}t$，以模拟在真实数值模拟中可能出现的规范伪影。\n    $$\n    h_{\\mathrm{metric}}(t)|_{\\text{Case 3}} = h_{\\mathrm{true}}(t) + d_{0} + d_{1}t\n    $$\n    这个 $h_{\\mathrm{metric}}(t)$ 作为对齐过程的“基准”或目标。\n\n3.  **处理流程 2：基于曲率的应变重建**\n    第二个处理流程从 Newman-Penrose 标量 $\\Psi_{4}(t)$ 开始。该标量是通过对真实应变 $h_{\\mathrm{true}}(t)$ 取二阶时间导数来构建的。使用快速傅里叶变换（FFT），此操作在频域中最为方便。函数 $f(t)$ 的二阶导数的傅里叶变换与其自身的傅里叶变换 $\\tilde{f}(\\omega)$ 的关系为：\n    $$\n    \\mathcal{F}[\\ddot{f}(t)](\\omega) = (i\\omega)^2 \\tilde{f}(\\omega) = -\\omega^2 \\tilde{f}(\\omega)\n    $$\n    因此，我们通过对 $h_{\\mathrm{true}}(t)$ 进行 FFT，将离散频谱中的每个角频率 $\\omega_k$ 乘以 $-\\omega^2$，然后应用逆 FFT（IFFT），来计算 $\\Psi_{4}(t)$。\n\n    接下来，我们通过反转此过程来恢复应变 $h_{\\mathrm{curv}}(t)$，即对 $\\Psi_{4}(t)$ 执行双重积分。在频域中，这对应于将 $\\Psi_{4}(t)$ 的傅里叶变换（记为 $\\tilde{\\Psi}_{4}(\\omega)$）除以 $-\\omega^2$。这种除法在 $\\omega=0$ 时是未定义的，并且会放大低频噪声。为了处理这个问题，应用了高通正则化：\n    $$\n    \\tilde{h}_{\\mathrm{curv}}(\\omega) =\n    \\begin{cases}\n    \\tilde{\\Psi}_{4}(\\omega) / (-\\omega^2) & \\text{if } |\\omega| \\ge \\omega_{\\mathrm{cut}} \\\\\n    0 & \\text{if } |\\omega| < \\omega_{\\mathrm{cut}}\n    \\end{cases}\n    $$\n    其中截止角频率为 $\\omega_{\\mathrm{cut}} = 2\\pi f_{\\mathrm{cut}}$，且 $f_{\\mathrm{cut}} = 5$ 赫兹。对 $\\tilde{h}_{\\mathrm{curv}}(\\omega)$ 应用 IFFT 得到时域波形 $h_{\\mathrm{curv}}(t)$。该正则化有效地丢弃了关于积分信号的常数项和线性项的信息，而这些恰好是二次不定积分的积分常数。\n\n4.  **协调与对齐**\n    由于正则化移除了低频内容，以及 $h_{\\mathrm{metric}}(t)$ 中存在的任何额外低频漂移（如测试案例 3 中），基于曲率的重建 $h_{\\mathrm{curv}}(t)$ 将与基于度规的重建 $h_{\\mathrm{metric}}(t)$ 不同。这些差异预计可以很好地由一个复仿射函数 $C(t) = c_{0} + c_{1}t$ 来近似。我们通过最小化时域平方误差来确定复系数 $c_0$ 和 $c_1$：\n    $$\n    \\min_{c_0, c_1} \\sum_{k=0}^{N-1} \\left| h_{\\mathrm{metric}}(t_k) - (h_{\\mathrm{curv}}(t_k) + c_{0} + c_{1}t_k) \\right|^{2}\n    $$\n    这等效于为残差信号 $\\Delta h(t) = h_{\\mathrm{metric}}(t) - h_{\\mathrm{curv}}(t)$ 寻找一条最佳拟合直线 $c_0 + c_1 t$。这个复数线性最小二乘问题解耦为两个独立的实数线性最小二乘问题，分别针对系数的实部和虚部：\n    $$\n    \\min_{c_{0r}, c_{1r}} \\sum_{k=0}^{N-1} \\left( \\Re[\\Delta h(t_k)] - (c_{0r} + c_{1r} t_k) \\right)^{2}\n    $$\n    $$\n    \\min_{c_{0i}, c_{1i}} \\sum_{k=0}^{N-1} \\left( \\Im[\\Delta h(t_k)] - (c_{0i} + c_{1i} t_k) \\right)^{2}\n    $$\n    这些问题使用标准的线性回归技术求解。一旦找到 $c_0 = c_{0r} + i c_{0i}$ 和 $c_1 = c_{1r} + i c_{1i}$，对齐后的基于曲率的应变定义为 $h_{\\mathrm{aligned}}(t) = h_{\\mathrm{curv}}(t) + c_0 + c_1 t$。\n\n5.  **一致性量化**\n    最后，通过计算整个时间序列上的最大绝对差来量化对齐后两个处理流程之间的一致性：\n    $$\n    \\Delta_{\\infty} = \\max_{k} \\left| h_{\\mathrm{aligned}}(t_{k}) - h_{\\mathrm{metric}}(t_{k}) \\right|\n    $$\n    该值表示未被仿射拟合捕获的最大残余误差的大小，为两种重建方法之间的内在一致性提供了一个度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational wave strain reconstruction and alignment problem\n    for three test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (constant frequency, constant amplitude)\n        {\n            \"T\": 0.5, \"dt\": 1/4096, \"A0\": 1.0e-21, \"alpha\": 0.0,\n            \"f0\": 100.0, \"f_dot\": 0.0, \"psi\": 0.3, \"phi0\": 0.2,\n            \"drift\": None\n        },\n        # Test Case 2 (linear chirp, rising amplitude)\n        {\n            \"T\": 1.0, \"dt\": 1/4096, \"A0\": 5.0e-22, \"alpha\": 0.8,\n            \"f0\": 50.0, \"f_dot\": 120.0, \"psi\": -0.5, \"phi0\": 0.1,\n            \"drift\": None\n        },\n        # Test Case 3 (linear chirp, rising amplitude, metric drift)\n        {\n            \"T\": 1.0, \"dt\": 1/4096, \"A0\": 8.0e-22, \"alpha\": 0.5,\n            \"f0\": 80.0, \"f_dot\": 80.0, \"psi\": 0.8, \"phi0\": -0.3,\n            \"drift\": {\n                \"d0\": 3.0e-23 * np.exp(1j * 0.2),\n                \"d1\": 1.0e-23 * np.exp(1j * -0.5)\n            }\n        },\n    ]\n\n    f_cut = 5.0  # Cutoff frequency in Hz for regularization\n\n    results = []\n    for params in test_cases:\n        # 1. Setup\n        T = params[\"T\"]\n        dt = params[\"dt\"]\n        N = int(T / dt)  # Per problem spec, floor is implicit with int cast\n        t = np.arange(N) * dt\n        \n        # 2. Synthesize Ground Truth Signal\n        A0, alpha = params[\"A0\"], params[\"alpha\"]\n        f0, f_dot = params[\"f0\"], params[\"f_dot\"]\n        psi, phi0 = params[\"psi\"], params[\"phi0\"]\n\n        amplitude = A0 * (1 + alpha * t)\n        phase = 2 * np.pi * (f0 * t + 0.5 * f_dot * t**2) + phi0\n        polarization_phase = -2 * psi\n\n        h_true = amplitude * np.exp(1j * phase) * np.exp(1j * polarization_phase)\n\n        # 3. Pipeline 1: Metric-based Reconstruction\n        h_metric = h_true.copy()\n        if params[\"drift\"]:\n            d0 = params[\"drift\"][\"d0\"]\n            d1 = params[\"drift\"][\"d1\"]\n            h_metric += d0 + d1 * t\n\n        # 4. Pipeline 2: Curvature-based Reconstruction\n        # 4a. Construct Psi4 from h_true\n        freq = np.fft.fftfreq(N, dt)\n        omega = 2 * np.pi * freq\n        \n        h_true_tilde = np.fft.fft(h_true)\n        psi4_tilde = -(omega**2) * h_true_tilde\n        psi4 = np.fft.ifft(psi4_tilde)\n\n        # 4b. Reconstruct h_curv from Psi4\n        psi4_tilde_recomp = np.fft.fft(psi4) # Recompute for clarity\n        omega_cut = 2 * np.pi * f_cut\n\n        # Create integration kernel with regularization\n        integration_kernel = np.zeros_like(omega, dtype=np.complex128)\n        valid_indices = np.abs(omega) >= omega_cut\n        # Use np.divide to handle division by zero safely\n        integration_kernel[valid_indices] = np.divide(\n            -1.0, \n            omega[valid_indices]**2, \n            where=(omega[valid_indices] != 0)\n        )\n\n        h_curv_tilde = psi4_tilde_recomp * integration_kernel\n        h_curv = np.fft.ifft(h_curv_tilde)\n\n        # 5. Reconciliation and Alignment\n        delta_h = h_metric - h_curv\n        \n        # Design matrix for linear fit (constant and linear term)\n        X = np.vstack([np.ones(N), t]).T\n\n        # Solve for real and imaginary parts of coefficients c0, c1\n        c_real, _, _, _ = np.linalg.lstsq(X, np.real(delta_h), rcond=None)\n        c_imag, _, _, _ = np.linalg.lstsq(X, np.imag(delta_h), rcond=None)\n\n        c0 = c_real[0] + 1j * c_imag[0]\n        c1 = c_real[1] + 1j * c_imag[1]\n        \n        h_aligned = h_curv + c0 + c1 * t\n        \n        # 6. Quantify Agreement\n        delta_inf = np.max(np.abs(h_aligned - h_metric))\n        results.append(f\"{delta_inf:.10e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3483091"}, {"introduction": "掌握了提取和表征波形的方法后，我们可以应用这些技能来诊断数值模拟中的非物理效应。这个练习模拟了模拟区域不完美的外边界条件如何导致虚假的波形反射和偏振态混合，从而污染物理信号。量化这种效应对于评估数值相对论波形的准确性至关重要，是确保模拟结果可靠性的核心环节。[@problem_id:3483032]", "problem": "您将实现并分析一个简化但有科学依据的模型，该模型描述了数值相对论中外部边界条件如何影响引力波的偏振内容。请在线性化真空引力框架和横向无迹 (TT) 规范下进行研究，其中两个独立的偏振振幅 $h_+(z,t)$ 和 $h_\\times(z,t)$ 服从解耦的一维波动方程。在光速 $c=1$ 的几何单位制中，每个偏振的控制方程为\n$$\n\\partial_t^2 h(z,t) = c^2 \\,\\partial_z^2 h(z,t),\n$$\n单色平面波的色散关系为 $\\,\\omega = c\\,k\\,$，其中 $\\,\\omega\\,$ 是角频率，$\\,k\\,$ 是波数。考虑一个在位置 $z=L$ 处有外部边界的有限计算区域。\n\n边界条件通过一个线性一阶 (Sommerfeld 型) 算子施加在双分量场矢量 $\\,\\mathbf{h}(z,t) = \\begin{bmatrix}h_+(z,t) \\\\ h_\\times(z,t)\\end{bmatrix}\\,$ 上：\n$$\n\\mathcal{B}[\\mathbf{h}](L,t) \\equiv \\partial_t \\mathbf{h}(L,t) + C_b\\,\\partial_z \\mathbf{h}(L,t) = \\mathbf{0},\n$$\n其中 $\\,C_b\\,$ 是一个表征所选边界条件的常数 $2\\times 2$ 矩阵。需要比较两种边界条件族：\n\n- Sommerfeld 边界条件：为偏振选择一个旋转角为 $\\,\\theta\\,$ (单位为弧度) 的旋转基，由矩阵定义：\n$$\nR(\\theta) = \\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta \\\\\n\\sin\\theta & \\cos\\theta\n\\end{bmatrix},\n$$\n并在该旋转基中规定不同的特征边界速度 $\\,c_{b1}\\,$ 和 $\\,c_{b2}\\,$. 在物理 $+$/$\\times$ 基中，这得到\n$$\nC_b = R(\\theta)^\\top \\begin{bmatrix} c_{b1} & 0 \\\\ 0 & c_{b2} \\end{bmatrix} R(\\theta).\n$$\n这模拟了一种真实情况，即一个朴素的 Sommerfeld 条件被应用于具有不同有效传播速度的场的混合体，可能同时导致反射和偏振混合。\n\n- 约束保持边界条件 (CPBC)：在这个简化的 TT 模型中，理想的 CPBC 对应于将所有出射引力波特征场与正确的物理速度相匹配，并精确地保持约束，在此简化为选择\n$$\nC_b = c\\,I,\n$$\n其中 $\\,I\\,$ 是 $2\\times 2$ 单位矩阵。这不会产生反射，并且对于平面波解，在边界处保持了 TT 特性。\n\n假设一个振幅矢量为 $\\,\\mathbf{A}_{\\text{out}}\\,$ 的单色出射平面波向边界传播：\n$$\n\\mathbf{h}_{\\text{out}}(z,t) = \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)}.\n$$\n向计算区域内反向传播的反射波的振幅矢量为 $\\,\\mathbf{A}_{\\text{in}}\\,$：\n$$\n\\mathbf{h}_{\\text{in}}(z,t) = \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)}.\n$$\n施加 $\\,\\mathcal{B}[\\mathbf{h}_{\\text{out}} + \\mathbf{h}_{\\text{in}}](L,t) = \\mathbf{0}\\,$ 会得到一个关于 $\\,\\mathbf{A}_{\\text{in}}\\,$ 的、以 $\\,\\mathbf{A}_{\\text{out}}\\,$ 表示的线性系统，该系统可以从第一性原理推导出来。定义反射矩阵\n$$\n\\mathsf{R} \\equiv \\left(-\\omega I - k\\,C_b\\right)^{-1}\\left(\\omega I - k\\,C_b\\right),\n$$\n和边界相位因子 $\\,\\xi \\equiv e^{2 i k L}\\,$. 那么入射振幅为\n$$\n\\mathbf{A}_{\\text{in}} = \\xi\\,\\mathsf{R}\\,\\mathbf{A}_{\\text{out}}.\n$$\n我们感兴趣的量是反射回计算区域的伪偏振。对于一个纯 $+$-偏振的出射波，$\\,\\mathbf{A}_{\\text{out}} = \\begin{bmatrix}A_+ \\\\ 0\\end{bmatrix}\\,$ 且 $\\,A_+ \\neq 0\\,$，定义无量纲反射比\n$$\nr_+ \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_+\\right|}{|A_+|}, \\qquad r_\\times \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_\\times\\right|}{|A_+|},\n$$\n它们分别测量反射的 $+$ 分量的模和伪反射的 $\\times$ 分量的模，两者都用出射 $+$ 振幅进行归一化。由于 $\\,|\\xi|=1\\,$，这些比率仅取决于 $\\,\\mathsf{R}\\,$ 和 $\\,\\mathbf{A}_{\\text{out}}\\,$.\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 忠实地实现上述模型。\n- 为下方的每个测试用例计算 $\\,r_+\\,$ 和 $\\,r_\\times\\,$.\n- 以指定格式返回结果。\n\n使用几何单位制，其中 $\\,c\\,$ 和所有速度都是无量纲的；波数 $\\,k\\,$ 的单位是与 $\\,c=1\\,$ 一致的逆长度单位；角度 $\\,\\theta\\,$ 的单位是弧度。所有输出都必须是无量纲的。将每个比率表示为十进制数，四舍五入到十位小数。\n\n测试套件：\n- 用例 $1$ (Sommerfeld，轻度失配和混合)：\n  - $c=1$, $c_{b1}=0.9$, $c_{b2}=1.1$, $\\theta=\\pi/6$, $k=2\\pi$, $L=1$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$.\n- 用例 $2$ (CPBC，完美匹配)：\n  - $c=1$, $C_b=c\\,I$, $\\theta$ 任意 (未使用), $k=2\\pi$, $L=1$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$.\n- 用例 $3$ (Sommerfeld，速度正确但基已旋转)：\n  - $c=1$, $c_{b1}=1$, $c_{b2}=1$, $\\theta=\\pi/4$, $k=2\\pi$, $L=1$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$.\n- 用例 $4$ (Sommerfeld，强失配和混合)：\n  - $c=1$, $c_{b1}=0.5$, $c_{b2}=1.5$, $\\theta=\\pi/3$, $k=\\pi$, $L=0.5$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$.\n- 用例 $5$ (Sommerfeld，物理基中无混合)：\n  - $c=1$, $c_{b1}=0.8$, $c_{b2}=1.2$, $\\theta=0$, $k=\\pi$, $L=1.25$, $\\mathbf{A}_{\\text{out}}=\\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$.\n\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例必须贡献一个包含两个十进制数 $[r_+,r_\\times]$ 的列表，并四舍五入到十位小数，因此最终输出必须具有以下形式\n$$\n\\left[\\,[r_+,r_\\times],\\,[r_+,r_\\times],\\,[r_+,r_\\times],\\,[r_+,r_\\times],\\,[r_+,r_\\times]\\,\\right],\n$$\n不打印任何额外文本。", "solution": "问题陈述经确认为具有科学依据、数学上一致且适定。它提出了一个来自数值相对论的简化但具有物理意义的模型，该模型关于边界条件对引力波偏振的影响。唯一解所需的所有必要组成部分都已清晰定义并提供。\n\n问题的核心是确定单色平面波在数值边界上的反射。总波场 $\\mathbf{h}(z,t)$ 是出射波 $\\mathbf{h}_{\\text{out}}(z,t)$ 和反射（入射）波 $\\mathbf{h}_{\\text{in}}(z,t)$ 的线性叠加：\n$$\n\\mathbf{h}(z,t) = \\mathbf{h}_{\\text{out}}(z,t) + \\mathbf{h}_{\\text{in}}(z,t) = \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)} + \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)}\n$$\n其中 $\\mathbf{A}_{\\text{out}}$ 和 $\\mathbf{A}_{\\text{in}}$ 分别是出射波和入射波的恒定振幅矢量。边界条件由作用在边界 $z=L$ 处总场上的一阶算子 $\\mathcal{B}$ 指定：\n$$\n\\mathcal{B}[\\mathbf{h}](L,t) \\equiv \\partial_t \\mathbf{h}(L,t) + C_b\\,\\partial_z \\mathbf{h}(L,t) = \\mathbf{0}\n$$\n为应用此条件，我们首先计算 $\\mathbf{h}(z,t)$ 的偏导数：\n$$\n\\partial_t \\mathbf{h}(z,t) = -i\\omega \\left( \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)} + \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)} \\right)\n$$\n$$\n\\partial_z \\mathbf{h}(z,t) = ik \\left( \\mathbf{A}_{\\text{out}}\\,e^{i(k z - \\omega t)} - \\mathbf{A}_{\\text{in}}\\,e^{i(-k z - \\omega t)} \\right)\n$$\n在 $z=L$ 处计算这些表达式，并将它们代入边界条件算子，得到：\n$$\n-i\\omega \\left( \\mathbf{A}_{\\text{out}}e^{ikL} + \\mathbf{A}_{\\text{in}}e^{-ikL} \\right)e^{-i\\omega t} + C_b \\left( ik \\left( \\mathbf{A}_{\\text{out}}e^{ikL} - \\mathbf{A}_{\\text{in}}e^{-ikL} \\right) \\right)e^{-i\\omega t} = \\mathbf{0}\n$$\n我们可以消去公共的非零因子 $i e^{-i\\omega t}$，这给出：\n$$\n-\\omega \\left( \\mathbf{A}_{\\text{out}}e^{ikL} + \\mathbf{A}_{\\text{in}}e^{-ikL} \\right) + k C_b \\left( \\mathbf{A}_{\\text{out}}e^{ikL} - \\mathbf{A}_{\\text{in}}e^{-ikL} \\right) = \\mathbf{0}\n$$\n这个方程是关于 $\\mathbf{A}_{\\text{in}}$ 的、以 $\\mathbf{A}_{\\text{out}}$ 表示的线性系统。为了求解它，我们将乘以 $\\mathbf{A}_{\\text{in}}$ 和 $\\mathbf{A}_{\\text{out}}$ 的项组合在一起：\n$$\n(-\\omega I - kC_b) \\mathbf{A}_{\\text{in}}e^{-ikL} = (-\\omega I + kC_b) \\mathbf{A}_{\\text{out}}e^{ikL}\n$$\n其中 $I$ 是 $2 \\times 2$ 单位矩阵。求解 $\\mathbf{A}_{\\text{in}}$，我们得到：\n$$\n\\mathbf{A}_{\\text{in}} = (-\\omega I - kC_b)^{-1} (-\\omega I + kC_b) e^{2ikL} \\mathbf{A}_{\\text{out}}\n$$\n这个关系与问题中给出的形式 $\\mathbf{A}_{\\text{in}} = \\xi\\,\\mathsf{R}\\,\\mathbf{A}_{\\text{out}}$ 相匹配，其中相位因子 $\\xi \\equiv e^{2ikL}$，反射矩阵 $\\mathsf{R}$ 定义为 $\\mathsf{R} \\equiv (-\\omega I - kC_b)^{-1} (-\\omega I + kC_b)$。该矩阵可以等价地写为 $\\mathsf{R} = (\\omega I + kC_b)^{-1} (\\omega I - kC_b)$。\n\n在 $c=1$ 的几何单位制下，色散关系简化为 $\\omega=k$。将此代入 $\\mathsf{R}$ 的表达式中，可以得到显著的简化：\n$$\n\\mathsf{R} = (kI + kC_b)^{-1}(kI - kC_b) = [k(I+C_b)]^{-1}[k(I-C_b)] = (I+C_b)^{-1}(I-C_b)\n$$\n问题要求计算反射比 $r_+$ 和 $r_\\times$，它们是反射波各分量的模，并用初始出射波的振幅进行归一化。对于纯 $+$-偏振的出射波，我们有 $\\mathbf{A}_{\\text{out}} = \\begin{bmatrix}A_+ \\\\ 0\\end{bmatrix}$。比率为：\n$$\nr_+ \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_+\\right|}{|A_+|}, \\qquad r_\\times \\equiv \\frac{\\left|(\\mathbf{A}_{\\text{in}})_\\times\\right|}{|A_+|}\n$$\n由于相位因子 $\\xi$ 的模为单位一 ($|\\xi|=|e^{2ikL}|=1$)，它不影响反射分量的模。因此，我们可以从矢量 $\\mathbf{A}'_{\\text{in}} = \\mathsf{R} \\mathbf{A}_{\\text{out}}$ 计算这些比率。不失一般性，我们可以设 $A_+=1$，因此 $\\mathbf{A}_{\\text{out}} = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$。矢量 $\\mathbf{A}'_{\\text{in}}$ 随后就是矩阵 $\\mathsf{R}$ 的第一列。如果 $\\mathsf{R}$ 的分量为 $\\mathsf{R}_{ij}$，那么 $\\mathbf{A}'_{\\text{in}} = \\begin{bmatrix}\\mathsf{R}_{11}\\\\\\mathsf{R}_{21}\\end{bmatrix}$，比率变为 $r_+ = |\\mathsf{R}_{11}|$ 和 $r_\\times = |\\mathsf{R}_{21}|$。\n\n对每个测试用例，计算算法如下：\n1.  构造矩阵 $C_b$。对于 Sommerfeld 条件，$C_b = R(\\theta)^\\top \\text{diag}(c_{b1}, c_{b2}) R(\\theta)$，其中 $R(\\theta) = \\begin{bmatrix}\\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta\\end{bmatrix}$。对于 CPBC，$C_b=cI=I$。\n2.  计算反射矩阵 $\\mathsf{R} = (I+C_b)^{-1}(I-C_b)$。这涉及到标准的矩阵代数：加法、求逆和乘法。\n3.  提取 $\\mathsf{R}$ 的第一列，它对应于 $\\mathbf{A}'_{\\text{in}}$。\n4.  计算此列向量各分量的绝对值以求得 $r_+$ 和 $r_\\times$。\n\n此过程应用于每个测试用例。\n- 对于用例 2 (CPBC) 和用例 3 (Sommerfeld 条件，$c_{b1}=c_{b2}=1$)，$C_b$ 变为单位矩阵 $I$。这导致 $I-C_b=\\mathbf{0}$，使得 $\\mathsf{R}$ 为零矩阵。因此，$r_+$ 和 $r_\\times$ 均为 $0$，表明完美吸收。\n- 对于用例 5 (Sommerfeld 条件，$\\theta=0$)，$R(0)=I$，所以 $C_b$ 是对角矩阵。这使得 $\\mathsf{R}$ 为对角矩阵，因此 $r_\\times=0$，因为偏振分量之间没有混合。\n- 对于用例 1 和 4，$C_b$ 是一个非对角矩阵，导致反射 ($r_+ > 0$) 和伪偏振混合 ($r_\\times > 0$)。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes spurious polarization reflection ratios for gravitational waves\n    at a numerical boundary.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        # Case 1 (Sommerfeld, mild mismatch and mixing)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": 2 * np.pi, \"L\": 1.0,\n            \"bc_params\": {\"cb1\": 0.9, \"cb2\": 1.1, \"theta\": np.pi / 6},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 2 (CPBC, perfect match)\n        {\n            \"type\": \"cpbc\",\n            \"c\": 1, \"k\": 2 * np.pi, \"L\": 1.0,\n            \"bc_params\": {\"c\": 1.0},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 3 (Sommerfeld, correct speeds but rotated basis)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": 2 * np.pi, \"L\": 1.0,\n            \"bc_params\": {\"cb1\": 1.0, \"cb2\": 1.0, \"theta\": np.pi / 4},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 4 (Sommerfeld, strong mismatch and mixing)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": np.pi, \"L\": 0.5,\n            \"bc_params\": {\"cb1\": 0.5, \"cb2\": 1.5, \"theta\": np.pi / 3},\n            \"A_out\": np.array([1.0, 0.0])\n        },\n        # Case 5 (Sommerfeld, no mixing in the physical basis)\n        {\n            \"type\": \"sommerfeld\",\n            \"c\": 1, \"k\": np.pi, \"L\": 1.25,\n            \"bc_params\": {\"cb1\": 0.8, \"cb2\": 1.2, \"theta\": 0.0},\n            \"A_out\": np.array([1.0, 0.0])\n        }\n    ]\n\n    all_results = []\n\n    for i, case in enumerate(test_cases):\n        # Identity matrix\n        I = np.identity(2)\n        \n        # Construct the boundary condition matrix C_b\n        if case[\"type\"] == \"sommerfeld\":\n            p = case[\"bc_params\"]\n            cb1, cb2, theta = p[\"cb1\"], p[\"cb2\"], p[\"theta\"]\n            \n            # Rotation matrix\n            cos_t, sin_t = np.cos(theta), np.sin(theta)\n            R_theta = np.array([[cos_t, -sin_t], [sin_t, cos_t]])\n            \n            # Diagonal matrix of boundary speeds\n            D = np.array([[cb1, 0], [0, cb2]])\n            \n            # C_b = R^T D R\n            C_b = R_theta.T @ D @ R_theta\n            \n        elif case[\"type\"] == \"cpbc\":\n            # C_b = c * I\n            C_b = case[\"bc_params\"][\"c\"] * I\n\n        # Simplified reflection matrix for c=1 (omega=k)\n        # R_mat = (I + C_b)^-1 * (I - C_b)\n        M_inv = np.linalg.inv(I + C_b)\n        R_mat = M_inv @ (I - C_b)\n        \n        # Reflected amplitude (without phase factor, as it doesn't affect magnitude)\n        A_out = case[\"A_out\"]\n        A_in_prime = R_mat @ A_out\n        \n        # Magnitude of the outgoing + polarization amplitude\n        A_plus_mag = np.abs(A_out[0])\n\n        # Calculate reflection ratios\n        # Note: A_plus_mag is 1 for all test cases, but we include it for generality.\n        # This handles cases where A_out could be complex or not normalized.\n        r_plus = np.abs(A_in_prime[0]) / A_plus_mag if A_plus_mag != 0 else 0\n        r_cross = np.abs(A_in_prime[1]) / A_plus_mag if A_plus_mag != 0 else 0\n        \n        all_results.append((r_plus, r_cross))\n\n    # Format the final output string exactly as specified.\n    output_parts = [f\"[{r_p:.10f},{r_x:.10f}]\" for r_p, r_x in all_results]\n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\n```", "id": "3483032"}]}