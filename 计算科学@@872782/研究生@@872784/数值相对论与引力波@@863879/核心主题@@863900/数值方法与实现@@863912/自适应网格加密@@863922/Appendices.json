{"hands_on_practices": [{"introduction": "在自适应网格加密（AMR）中，不同层级的网格具有不同的空间分辨率。根据著名的 Courant–Friedrichs–Lewy (CFL) 条件，这意味着更精细的网格需要更小的时间步长来维持数值稳定性。本练习将指导你计算不同 AMR 层级上允许的最大时间步长，并设计一个子步进（subcycling）策略，以确保所有层级在计算过程中保持同步。掌握这项技能对于理解和实现任何显式时间演化的 AMR 代码至关重要。[@problem_id:3503472]", "problem": "考虑一个用于计算天体物理模拟中双曲守恒律的一维显式有限体积求解器，该求解器采用自适应网格加密 (AMR) 技术。网格层级结构包含三个级别：一个粗网格层 $\\ell = 0$，一个相对于 $\\ell=0$ 层以因子 $r_{1} = 3$ 加密的细网格层 $\\ell=1$，以及一个相对于 $\\ell=1$ 层以因子 $r_{2} = 2$ 加密的最细网格层 $\\ell=2$。粗网格层的空间步长为 $\\Delta x_{0} = 9.6 \\times 10^{9}$ 米，因此 $\\Delta x_{1} = \\Delta x_{0}/r_{1}$ 且 $\\Delta x_{2} = \\Delta x_{1}/r_{2}$。在各层上解析的最大特征速度（即通量雅可比矩阵特征值的最大绝对值）分别为：在 $\\ell=0$ 层上 $a_{0} = 2.0 \\times 10^{7}$ 米/秒，在 $\\ell=1$ 层上 $a_{1} = 3.3 \\times 10^{7}$ 米/秒，在 $\\ell=2$ 层上 $a_{2} = 4.0 \\times 10^{7}$ 米/秒。Courant–Friedrichs–Lewy (CFL) 数为 $C_{\\mathrm{CFL}} = 0.45$。\n\n使用适用于双曲系统显式有限体积离散的 Courant–Friedrichs–Lewy 稳定性要求，首先计算每个 AMR 层级上允许的时间步长，记为 $\\Delta t_{\\ell}^{\\max}$（其中 $\\ell \\in \\{0,1,2\\}$）。然后，假设粗网格层前进一个长度为 $\\Delta t_{0} = \\Delta t_{0}^{\\max}$ 的时间步。通过选择整数 $n_1$ 和 $n_2$ 在细网格层上实现层级同步子循环，使得在一个粗网格层步长内，$\\ell=1$ 层执行 $n_1$ 个子步，$\\ell=2$ 层执行 $n_2$ 个子步，且满足 $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$ 和 $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$，同时 $n_2$ 是 $n_1$ 的正整数倍以确保嵌套同步。在所有允许的选择中，选取满足这些约束的最小 $n_1$ 和最小倍数 $n_2$。\n\n将在区间 $[0,\\Delta t_{0}]$ 内的同步时间定义为所有细网格层同时完成其整数个子步、从而可以与其父层级进行通量修正的时刻集合；在上述 $n_2$ 是 $n_1$ 的倍数的约束下，这些时刻即为 $\\ell=1$ 层的子步边界。列出这些时间，包括粗网格层步长的开始和结束时刻。所有时间量均以秒为单位表示。\n\n在您的最终答案中，按顺序以单行形式提供三元组 $\\left(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}\\right)$、实际的子循环时间步长 $\\left(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}\\right)$，以及一个粗网格层步长内的有序同步时间 $\\left(t_{0}, t_{1}, t_{2}, t_{3}, t_{4}, t_{5}\\right)$。无需进行四舍五入。", "solution": "用户提供了一个计算天体物理学领域的问题，该问题涉及自适应网格加密 (AMR) 模拟中的时间步进。问题要求基于 Courant-Friedrichs-Lewy (CFL) 稳定性条件计算时间步长，并确定子循环参数和同步时间。\n\n首先根据所需标准对问题进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- AMR 层级：$\\ell \\in \\{0, 1, 2\\}$。\n- 从 $\\ell=0$ 层到 $\\ell=1$ 层的加密因子：$r_{1} = 3$。\n- 从 $\\ell=1$ 层到 $\\ell=2$ 层的加密因子：$r_{2} = 2$。\n- 粗网格层空间步长：$\\Delta x_{0} = 9.6 \\times 10^{9}$ 米。\n- 空间步长关系：$\\Delta x_{1} = \\Delta x_{0}/r_{1}$ 且 $\\Delta x_{2} = \\Delta x_{1}/r_{2}$。\n- 各层级上的最大特征速度：$a_{0} = 2.0 \\times 10^{7}$ 米/秒, $a_{1} = 3.3 \\times 10^{7}$ 米/秒, $a_{2} = 4.0 \\times 10^{7}$ 米/秒。\n- Courant-Friedrichs-Lewy (CFL) 数：$C_{\\mathrm{CFL}} = 0.45$。\n- 用于推进的粗网格层时间步长：$\\Delta t_{0} = \\Delta t_{0}^{\\max}$。\n- 子循环约束：\n  - $\\ell=1$ 层执行 $n_{1}$ 个子步，其中 $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$。\n  - $\\ell=2$ 层执行 $n_{2}$ 个子步，其中 $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$。\n- 同步约束：$n_{2}$ 是 $n_{1}$ 的正整数倍。\n- 最小性约束：$n_{1}$ 是满足其约束的最小整数，而 $n_{2}$ 是满足其约束的 $n_{1}$ 的最小倍数。\n- 同步时间：在粗网格层步长区间 $[0, \\Delta t_{0}]$ 内，$\\ell=1$ 层的子步边界。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学基础**：该问题基于 CFL 条件，这是双曲方程显式数值方法稳定性的一个基本原理。带子循环的 AMR 是计算流体动力学和天体物理学中的一项标准的、科学上有效的技术。该问题牢固地建立在成熟的数值分析基础之上。\n- **适定性**：所有必需的参数（$\\Delta x_0$, $r_1$, $r_2$, $a_\\ell$, $C_{\\mathrm{CFL}}$）均已提供。对子循环整数（$n_1$, $n_2$）的约束定义清晰，并能导出一个唯一的最小解。该问题是自洽且数学上适定的。\n- **客观性**：该问题使用精确、无歧义的数学术语和物理量进行表述，不含主观性语言。\n\n**步骤 3：结论与行动**\n该问题是有效的，因为它在科学上是合理的、适定的且客观的。将提供一个完整的解。\n\n### 解\n\n求解过程分为以下几个步骤：\n1.  计算每个层级 $\\ell$ 的空间步长 $\\Delta x_{\\ell}$。\n2.  使用 CFL 条件计算每个层级的最大允许时间步长 $\\Delta t_{\\ell}^{\\max}$。\n3.  确定满足给定约束的子循环整数 $n_{1}$ 和 $n_{2}$。\n4.  计算用于子循环推进的实际时间步长 $\\Delta t_{\\ell}$。\n5.  列出一个粗网格层步长内的同步时间。\n\n**1. 空间步长**\n细网格层的空间步长由给定的加密因子确定。\n- $\\ell=0$ 层：$\\Delta x_{0} = 9.6 \\times 10^{9} \\, \\text{m}$。\n- $\\ell=1$ 层：$\\Delta x_{1} = \\frac{\\Delta x_{0}}{r_{1}} = \\frac{9.6 \\times 10^{9}}{3} = 3.2 \\times 10^{9} \\, \\text{m}$。\n- $\\ell=2$ 层：$\\Delta x_{2} = \\frac{\\Delta x_{1}}{r_{2}} = \\frac{3.2 \\times 10^{9}}{2} = 1.6 \\times 10^{9} \\, \\text{m}$。\n\n**2. 最大允许时间步长**\n对于一维显式有限体积格式，CFL 条件指出，为保证稳定性，时间步长 $\\Delta t$ 必须满足 $\\Delta t \\le C_{\\mathrm{CFL}} \\frac{\\Delta x}{a}$，其中 $a$ 是最大特征速度。因此，$\\ell$ 层上的最大允许时间步长为 $\\Delta t_{\\ell}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{\\ell}}{a_{\\ell}}$。\n\n- $\\ell=0$ 层：\n$$ \\Delta t_{0}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{0}}{a_{0}} = 0.45 \\times \\frac{9.6 \\times 10^{9} \\, \\text{m}}{2.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (4.8 \\times 10^{2} \\, \\text{s}) = 216 \\, \\text{s} $$\n- $\\ell=1$ 层：\n$$ \\Delta t_{1}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{1}}{a_{1}} = 0.45 \\times \\frac{3.2 \\times 10^{9} \\, \\text{m}}{3.3 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times \\frac{3.2}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{1.44}{3.3} \\times 10^{2} \\, \\text{s} = \\frac{144}{3.3} \\, \\text{s} = \\frac{1440}{33} \\, \\text{s} = \\frac{480}{11} \\, \\text{s} $$\n- $\\ell=2$ 层：\n$$ \\Delta t_{2}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{2}}{a_{2}} = 0.45 \\times \\frac{1.6 \\times 10^{9} \\, \\text{m}}{4.0 \\times 10^{7} \\, \\text{m/s}} = 0.45 \\times (0.4 \\times 10^{2} \\, \\text{s}) = 18 \\, \\text{s} $$\n第一组要求的值是 $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$。\n\n**3. 子循环整数**\n粗网格层以大小为 $\\Delta t_{0} = \\Delta t_{0}^{\\max} = 216 \\, \\text{s}$ 的步长前进一-步。\n对于 $\\ell=1$ 层，子步数 $n_{1}$ 必须满足 $\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} \\le \\Delta t_{1}^{\\max}$。这意味着：\n$$ n_{1} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{1}^{\\max}} = \\frac{216}{\\frac{480}{11}} = \\frac{216 \\times 11}{480} = \\frac{9 \\times 24 \\times 11}{20 \\times 24} = \\frac{99}{20} = 4.95 $$\n由于 $n_{1}$ 必须为整数，因此 $n_{1}$ 的最小值为 $\\lceil 4.95 \\rceil = 5$。\n\n对于 $\\ell=2$ 层，子步数 $n_{2}$ 必须满足 $\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} \\le \\Delta t_{2}^{\\max}$。这意味着：\n$$ n_{2} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{2}^{\\max}} = \\frac{216}{18} = 12 $$\n此外，$n_{2}$ 必须是 $n_{1}=5$ 的正整数倍。我们必须找到大于或等于 $12$ 的 $5$ 的最小倍数。$5$ 的相关倍数是 $5, 10, 15, \\dots$。这样的最小倍数是 $15$。\n因此，选定的子循环整数为 $n_{1} = 5$ 和 $n_{2} = 15$。\n\n**4. 实际的子循环时间步长**\n每个层级的实际时间步长根据子循环整数计算。\n- $\\ell=0$ 层：$\\Delta t_{0} = 216 \\, \\text{s}$。\n- $\\ell=1$ 层：$\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} = \\frac{216}{5} = 43.2 \\, \\text{s}$。\n- $\\ell=2$ 层：$\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} = \\frac{216}{15} = \\frac{72}{5} = 14.4 \\, \\text{s}$。\n第二组要求的值是 $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$。\n\n**5. 同步时间**\n同步时间是 $\\ell=1$ 层子步的边界。由于 $\\ell=1$ 层执行 $n_1=5$ 个时长为 $\\Delta t_1 = 43.2 \\, \\text{s}$ 的子步，同步时间 $t_j$ 由 $t_j = j \\cdot \\Delta t_1$ 给出，其中 $j=0, 1, \\dots, 5$。\n- $t_{0} = 0 \\times 43.2 = 0 \\, \\text{s}$\n- $t_{1} = 1 \\times 43.2 = 43.2 \\, \\text{s}$\n- $t_{2} = 2 \\times 43.2 = 86.4 \\, \\text{s}$\n- $t_{3} = 3 \\times 43.2 = 129.6 \\, \\text{s}$\n- $t_{4} = 4 \\times 43.2 = 172.8 \\, \\text{s}$\n- $t_{5} = 5 \\times 43.2 = 216.0 \\, \\text{s}$\n第三组要求的值是 $(0, 43.2, 86.4, 129.6, 172.8, 216.0)$。\n\n将这三组结果合并为单行矩阵，作为最终答案。\n- $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$\n- $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$\n- $(t_0, \\dots, t_5) = (0, 43.2, 86.4, 129.6, 172.8, 216)$", "answer": "$$\n\\boxed{\\begin{pmatrix} 216 & \\frac{480}{11} & 18 & 216 & 43.2 & 14.4 & 0 & 43.2 & 86.4 & 129.6 & 172.8 & 216 \\end{pmatrix}}\n$$", "id": "3503472"}, {"introduction": "当 AMR 算法决定创建一个更精细的网格时，我们必须从其父级粗网格的数据中为其“填充”初始值，这个过程称为延拓（prolongation）。本练习将让你动手实现一个基于分段线性重构的延拓方案，并探索多种斜率限制器（slope limiters）的使用。通过这个实践，你将深刻理解为何以及如何避免在插值过程中引入非物理的振荡，这对于确保数值解在接触间断或激波附近的稳定性和准确性至关重要。[@problem_id:3503480]", "problem": "考虑在计算天体物理学背景下，具有接触间断的可压缩流的一维有限体积密度表示。自适应网格加密（AMR）旨在从粗网格单元平均值构造细网格初始数据，同时保持守恒并避免伪极值。其基本基础是单元平均值的有限体积定义和带有斜率限制器的总变差递减（TVD）重构。\n\n设粗网格为均匀网格，单元中心位于 $x_i$，宽度为 $\\Delta x$。粗网格单元平均密度为 $\\bar{\\rho}_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho(x)\\,dx$。对于延长（prolongation），每个粗单元 $i$被细分为 $r$ 个细子单元，索引为 $j \\in \\{0,1,\\dots,r-1\\}$，每个子单元的宽度为 $\\Delta x / r$。在每个粗单元 $i$ 内使用分段线性重构，\n$$\n\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x},\n$$\n其中 $s_i$ 是根据相邻粗网格平均值计算出的限制斜率，以强制执行 TVD 属性。定义后向和前向差分\n$$\n\\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1}, \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i,\n$$\n以及以下斜率限制器：\n- Minmod 限制器: $s_i = \\mathrm{mm}(\\Delta_-,\\Delta_+)$，其中 $\\mathrm{mm}(a,b) = \\begin{cases}\\mathrm{sign}(a)\\min(|a|,|b|),  \\text{若 } ab > 0 \\\\ 0,  \\text{其他情况}\\end{cases}$。\n- Monotonized Central (MC) 限制器: $s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)$，其中，如果 $a, b, c$ 符号相同，$\\mathrm{mm}_3(a,b,c)$ 返回 $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$，否则返回 $0$。\n- Van Leer 限制器: $s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+},  \\text{若 } \\Delta_- \\Delta_+ > 0 \\\\ 0,  \\text{其他情况}\\end{cases}$。\n\n在区域边界处，当邻近单元不可用时，设置 $s_i = 0$ 以保持守恒。粗单元 $i$ 内子单元 $j$ 的子单元平均密度为\n$$\n\\bar{\\rho}_{i,j} = \\frac{r}{\\Delta x}\\int_{x_{i-1/2} + \\frac{j}{r}\\Delta x}^{x_{i-1/2} + \\frac{j+1}{r}\\Delta x} \\rho_i(x)\\,dx.\n$$\n对于上述分段线性的 $\\rho_i(x)$，子单元平均值等于其在子单元中点处的值，得到\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j,\\quad c_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right).\n$$\n为避免在接触间断处产生伪极值，对每个粗单元 $i$ 施加一个保持边界的裁剪，其局部边界为\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\\quad \\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\n$$\n在边界处仅使用可用的邻近单元。强制执行\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right).\n$$\n\n实现一个程序，该程序：\n1. 根据指定的限制器计算限制斜率 $s_i$。\n2. 使用上述公式，为给定的加密比率 $r$ 计算细网格子单元平均值 $\\bar{\\rho}_{i,j}$。\n3. 对每个粗单元应用保持边界的裁剪。\n4. 将每个测试用例的加密后子单元平均值输出为浮点数列表。\n\n所有密度均为无量纲的代码单位；无需进行物理单位转换。不涉及角度。程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身又是对应测试用例的加密后单元平均密度的方括号逗号分隔列表，且不含空格。例如：$[[a_1,a_2,\\dots],[b_1,b_2,\\dots]]$。\n\n使用以下测试套件，其设计旨在覆盖平滑行为、急剧的接触间断、振荡模式和边界效应：\n- 测试 $1$（平滑单调递增，Minmod，$r=2$）：粗网格平均值 $\\left[\\,1.0,\\,1.1,\\,1.2,\\,1.3\\,\\right]$。\n- 测试 $2$（接触间断，MC，$r=2$）：粗网格平均值 $\\left[\\,1.0,\\,1.0,\\,5.0,\\,5.0\\,\\right]$。\n- 测试 $3$（振荡模式，Van Leer，$r=4$）：粗网格平均值 $\\left[\\,3.0,\\,1.0,\\,3.0,\\,1.0\\,\\right]$。\n- 测试 $4$（具有对称邻居的孤立跳跃，Minmod，$r=2$）：粗网格平均值 $\\left[\\,0.5,\\,0.5,\\,2.0,\\,0.5,\\,0.5\\,\\right]$。\n\n对于每个测试用例，输出应为指定格式的扁平化细网格列表 $\\left[\\,\\bar{\\rho}_{0,0},\\dots,\\bar{\\rho}_{0,r-1},\\bar{\\rho}_{1,0},\\dots,\\bar{\\rho}_{1,r-1},\\dots\\,\\right]$。最终输出必须是形如 $[ \\text{case1\\_list}, \\text{case2\\_list}, \\text{case3\\_list}, \\text{case4\\_list} ]$ 的单行文本，且不含任何空格。", "solution": "问题陈述经评估有效。它提出了一个明确定义的计算任务，该任务基于流体动力学数值方法的既定原则，特别是关于自适应网格加密（AMR）。所提供的分段线性重构、斜率限制器和子单元平均的公式是标准且正确的。该问题是自包含的，指定了所有必要的数据和边界条件，从而使每个测试用例都有唯一的解。\n\n将粗网格单元平均密度 $\\bar{\\rho}_i$ 延长（prolong）到加密比为 $r$ 的细化网格上的过程包括三个主要步骤：斜率计算、子单元平均值计算和保持边界的裁剪。\n\n### 1. 限制斜率计算\n对于每个粗单元 $i$，计算一个斜率 $s_i$ 来定义一个分段线性重构，$\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x}$，其中 $x_i$ 是单元 $i$ 的中心，$\\Delta x$ 是其宽度。为了防止在急剧特征附近引入伪振荡（这一特性被称为总变差递减或 TVD），斜率 $s_i$ 根据局部数据进行限制。\n\n计算取决于单元的位置：\n-   **边界单元**：对于域中的第一个（$i=0$）和最后一个（$i=N-1$）单元，无法获得完整的邻近单元集。为保持守恒和简化处理，斜率设为零，即 $s_0 = 0$ 和 $s_{N-1} = 0$。这对应于在边界处的分段常数重构。\n-   **内部单元**：对于任何内部单元 $i$，斜率由其直接邻居确定。我们首先计算后向和前向差分：\n    $$\n    \\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1} \\quad ; \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i\n    $$\n    然后将这些差分传递给斜率限制器函数。问题指定了三种此类限制器：\n\n    1.  **Minmod 限制器**：这是耗散性最强的限制器，能有效抑制振荡。斜率由下式给出：\n        $$\n        s_i = \\mathrm{mm}(\\Delta_-, \\Delta_+) = \\begin{cases}\\mathrm{sign}(\\Delta_-)\\min(|\\Delta_-|,|\\Delta_+|),  \\text{若 } \\Delta_- \\Delta_+ > 0 \\\\ 0,  \\text{其他情况}\\end{cases}\n        $$\n        仅当数据局部单调时（即 $\\Delta_-$ 和 $\\Delta_+$ 符号相同），斜率才为非零。在局部极值处，斜率为零。\n\n    2.  **Monotonized Central (MC) 限制器**：该限制器设计用于在平滑区域比 Minmod 更精确。它使用一个三参数的 minmod 函数定义：\n        $$\n        s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)\n        $$\n        其中，如果 $a, b, c$ 符号全部相同，$\\mathrm{mm}_3(a,b,c)$ 返回 $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$，否则返回 $0$。该限制器考虑中心差分斜率 $(\\Delta_- + \\Delta_+)/2$，并用两倍的单边差分来限制它。\n\n    3.  **Van Leer 限制器**：该限制器在单边差分之间提供平滑过渡，并以能很好地解析接触间断而闻名。它是两个差分的调和平均值：\n        $$\n        s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+},  \\text{若 } \\Delta_- \\Delta_+ > 0 \\\\ 0,  \\text{其他情况}\\end{cases}\n        $$\n\n### 2. 子单元平均值延长\n一旦每个粗单元 $i$ 的斜率 $s_i$ 已知，我们就可以确定其中 $r$ 个子单元中每个子单元的平均密度 $\\bar{\\rho}_{i,j}$。子单元的索引为 $j \\in \\{0, 1, \\dots, r-1\\}$。线性函数在区间上的平均值等于该函数在区间中点的值。这将积分定义简化为代数定义。粗单元 $i$ 中子单元 $j$ 的中点与粗单元中心 $x_i$ 之间存在一个距离因子。这引出以下公式：\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j\n$$\n其中系数 $c_j$ 仅取决于子单元索引 $j$ 和加密比 $r$：\n$$\nc_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right)\n$$\n这些系数表示每个子单元中心与父单元中心的归一化距离。例如，对于 $r=2$，我们有 $c_0 = -0.25$ 和 $c_1 = 0.25$。\n\n### 3. 保持边界的裁剪\nTVD 斜率限制器旨在防止在单元界面上重构的点值产生新的极值。然而，为了严格确保新的*单元平均值*也不会产生新的局部极值，会应用一个额外的裁剪步骤。对于每个粗单元 $i$，我们根据单元平均值本身及其可用邻居定义局部边界：\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n$$\n\\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n对于边界单元 $i=0$，邻域为 $\\{0, 1\\}$。对于内部单元，邻域为 $\\{i-1, i, i+1\\}$。\n\n然后，每个计算出的子单元平均值 $\\bar{\\rho}_{i,j}$ 被强制限制在这些边界内：\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right)\n$$\n这确保了加密后的数据场在局部上仍受原始粗糙数据的限制，这对于稳定性和物理真实性至关重要，尤其是在接触间断处。\n\n### 示例演练：测试用例 1\n-   **输入**：粗网格平均值 $\\bar{\\rho} = [1.0, 1.1, 1.2, 1.3]$，限制器：Minmod，$r=2$。\n-   **斜率**：\n    -   $s_0 = 0$（边界）。\n    -   $i=1$：$\\Delta_- = 1.1-1.0=0.1$，$\\Delta_+ = 1.2-1.1=0.1$。$\\mathrm{mm}(0.1, 0.1) = 0.1$。所以，$s_1=0.1$。\n    -   $i=2$：$\\Delta_- = 1.2-1.1=0.1$，$\\Delta_+ = 1.3-1.2=0.1$。$\\mathrm{mm}(0.1, 0.1) = 0.1$。所以，$s_2=0.1$。\n    -   $s_3 = 0$（边界）。\n    -   斜率向量为 $s = [0, 0.1, 0.1, 0]$。\n-   **子单元平均值 ($r=2 \\implies c_0=-0.25, c_1=0.25$)**：\n    -   $i=0$：$\\bar{\\rho}_{0,0} = 1.0 + 0 \\cdot (-0.25) = 1.0$；$\\bar{\\rho}_{0,1} = 1.0 + 0 \\cdot (0.25) = 1.0$。\n    -   $i=1$：$\\bar{\\rho}_{1,0} = 1.1 + 0.1 \\cdot (-0.25) = 1.075$；$\\bar{\\rho}_{1,1} = 1.1 + 0.1 \\cdot (0.25) = 1.125$。\n    -   $i=2$：$\\bar{\\rho}_{2,0} = 1.2 + 0.1 \\cdot (-0.25) = 1.175$；$\\bar{\\rho}_{2,1} = 1.2 + 0.1 \\cdot (0.25) = 1.225$。\n    -   $i=3$：$\\bar{\\rho}_{3,0} = 1.3 + 0 \\cdot (-0.25) = 1.3$；$\\bar{\\rho}_{3,1} = 1.3 + 0 \\cdot (0.25) = 1.3$。\n-   **裁剪**：\n    -   $i=0$：边界为 $[\\min(1.0, 1.1), \\max(1.0, 1.1)] = [1.0, 1.1]$。值 $[1.0, 1.0]$ 在边界内。\n    -   $i=1$：边界为 $[\\min(1.0, 1.1, 1.2), \\max(1.0, 1.1, 1.2)] = [1.0, 1.2]$。值 $[1.075, 1.125]$ 在边界内。\n    -   $i=2$：边界为 $[\\min(1.1, 1.2, 1.3), \\max(1.1, 1.2, 1.3)] = [1.1, 1.3]$。值 $[1.175, 1.225]$ 在边界内。\n    -   $i=3$：边界为 $[\\min(1.2, 1.3), \\max(1.2, 1.3)] = [1.2, 1.3]$。值 $[1.3, 1.3]$ 在边界内。\n    -   在这种情况下，裁剪步骤不会改变任何值，因为 Minmod 限制器已经确保了重构是非振荡的。\n-   **最终结果**：扁平化的细单元平均值列表为 $[1.0, 1.0, 1.075, 1.125, 1.175, 1.225, 1.3, 1.3]$。", "answer": "```python\nimport numpy as np\n\ndef minmod_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Minmod limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        return np.sign(delta_minus) * min(abs(delta_minus), abs(delta_plus))\n    return 0.0\n\ndef mm3(a, b, c):\n    \"\"\"Generalized minmod function for three arguments.\"\"\"\n    sa, sb, sc = np.sign(a), np.sign(b), np.sign(c)\n    if sa == sb and sa == sc:\n        return sa * min(abs(a), abs(b), abs(c))\n    return 0.0\n\ndef mc_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Monotonized Central (MC) limited slope.\"\"\"\n    return mm3((delta_minus + delta_plus) / 2.0, 2.0 * delta_minus, 2.0 * delta_plus)\n\ndef van_leer_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Van Leer limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        # The check for d- * d+ > 0 prevents division by zero,\n        # as d- + d+ could only be zero if both were zero.\n        return (2.0 * delta_minus * delta_plus) / (delta_minus + delta_plus)\n    return 0.0\n\ndef process_case(coarse_rho, limiter_name, r):\n    \"\"\"\n    Performs AMR prolongation for a given set of coarse cell averages.\n\n    Args:\n        coarse_rho (list[float]): The coarse-level cell averages.\n        limiter_name (str): The name of the slope limiter to use ('Minmod', 'MC', 'Van Leer').\n        r (int): The refinement ratio.\n\n    Returns:\n        list[float]: The flattened list of fine-level cell averages after clipping.\n    \"\"\"\n    limiter_funcs = {\n        'Minmod': minmod_limiter,\n        'MC': mc_limiter,\n        'Van Leer': van_leer_limiter\n    }\n    \n    n_coarse = len(coarse_rho)\n    slopes = np.zeros(n_coarse)\n    limiter_func = limiter_funcs[limiter_name]\n\n    # 1. Compute limited slopes for interior cells\n    for i in range(1, n_coarse - 1):\n        delta_minus = coarse_rho[i] - coarse_rho[i-1]\n        delta_plus = coarse_rho[i+1] - coarse_rho[i]\n        slopes[i] = limiter_func(delta_minus, delta_plus)\n    # Slopes at boundaries (i=0, i=n_coarse-1) remain 0\n\n    # 2. Compute fine-level subcell averages with bound-preserving clipping\n    c_j_coeffs = (np.arange(r, dtype=float) + 0.5) / r - 0.5\n    fine_rho = []\n    \n    for i in range(n_coarse):\n        # Determine local bounds from available neighbors\n        neighbors = [coarse_rho[i]]\n        if i > 0:\n            neighbors.append(coarse_rho[i-1])\n        if i  n_coarse - 1:\n            neighbors.append(coarse_rho[i+1])\n        \n        rho_min_i = min(neighbors)\n        rho_max_i = max(neighbors)\n\n        # Compute, clip, and store subcell values\n        for j in range(r):\n            # Calculate value from piecewise linear reconstruction\n            val = coarse_rho[i] + slopes[i] * c_j_coeffs[j]\n            # Apply bound-preserving clipping\n            clipped_val = min(rho_max_i, max(rho_min_i, val))\n            fine_rho.append(clipped_val)\n            \n    return fine_rho\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        {'coarse_rho': [1.0, 1.1, 1.2, 1.3], 'limiter': 'Minmod', 'r': 2},\n        {'coarse_rho': [1.0, 1.0, 5.0, 5.0], 'limiter': 'MC', 'r': 2},\n        {'coarse_rho': [3.0, 1.0, 3.0, 1.0], 'limiter': 'Van Leer', 'r': 4},\n        {'coarse_rho': [0.5, 0.5, 2.0, 0.5, 0.5], 'limiter': 'Minmod', 'r': 2},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        result = process_case(case['coarse_rho'], case['limiter'], case['r'])\n        # Format the list of floats into a string \"[f1,f2,...]\"\n        result_str = '[' + ','.join(map(str, result)) + ']'\n        all_results_str.append(result_str)\n\n    # Combine all case strings into the final output format \"[[...],[...],...]\"\n    # with no spaces.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3503480"}, {"introduction": "AMR 的效率和稳定性不仅取决于其空间和时间的处理方式，还取决于“何时”及“何处”进行加密和解密的决策逻辑。现实世界中的加密指标往往受到数值噪声的干扰，可能导致“网格抖动”（refinement thrashing）——即在同一区域反复进行加密和解密，造成计算资源的极大浪费。本练习通过一个包含随机噪声的简化模型，探讨了如何利用滞后效应（hysteresis）来设计一个稳健的加密策略，从而有效抑制这种抖动现象。[@problem_id:3503452]", "problem": "在用于计算天体物理学的自适应网格加密（AMR）流体动力学求解器中，一个标量加密指示器 $I_t$ 在离散时间步 $t \\in \\mathbb{Z}$ 上被评估。如果 $I_t \\ge \\theta_r$，一个网格单元被加密；如果 $I_t \\le \\theta_d$，则被解密。其中 $\\theta_r > \\theta_d$ 是实现迟滞的固定阈值。假设该网格单元在接下来 $3$ 个时间步内的潜在缓变信号由一个常数 $S$（代表真实的平滑度或特征幅度）建模，而测量和离散化噪声由一个方差为 $\\sigma^2$、滞后-1 相关系数为 $\\rho \\in (-1,1)$ 的平稳零均值高斯一阶自回归过程（AR($1$)) $X_t$ 建模，因此有\n$$\nI_t = S + X_t, \\quad X_{t+1} = \\rho\\, X_t + \\eta_{t+1}, \\quad \\eta_{t+1} \\sim \\mathcal{N}(0,(1-\\rho^2)\\sigma^2), \\quad \\eta_{t+1} \\text{ is independent of } X_t.\n$$\n假设在时间 $t$，该网格单元是粗糙的（即当前未被加密）。将加密抖动事件定义为：在真实信号 $S$ 位于阈值之间（$S \\in [\\theta_d,\\theta_r]$）时，仅因噪声波动而在时间 $t+1$ 做出加密决策，并紧接着在时间 $t+2$ 做出解密决策。为进行最坏情况设计，采用标准的对称性假设，即最易发生抖动的均值位于中点 $S^\\star = (\\theta_r+\\theta_d)/2$。\n\n设迟滞间隙为 $h = \\theta_r - \\theta_d > 0$。对于用户指定的容差 $\\delta \\in (0,1/2)$，推导出一个关于 $h$ 的充分条件，该条件保证对于任何相关性 $\\rho \\in (-1,1)$ 且当 $S=S^\\star$ 时，两步抖动事件\n$$\n\\{I_{t+1} \\ge \\theta_r,\\; I_{t+2} \\le \\theta_d\\}\n$$\n的概率至多为 $\\delta$。确定保证此界限对所有 $\\rho \\in (-1,1)$ 一致成立的最小迟滞间隙 $h_{\\min}$，并使用标准正态累积分布函数 $\\Phi$ 及其反函数 $\\Phi^{-1}$ 以闭式形式表示。提供 $h_{\\min}$ 的最终表达式，不要对结果进行近似或四舍五入。以无单位的符号形式表示最终答案。", "solution": "用户提供了一个有效的问题陈述。所有列出的已知条件都清晰、独立且科学合理。该问题是适定的、客观的。因此，我们可以进行形式化的求解。\n\n问题要求在最坏情况信号假设下，并对所有可能的时间相关性 $\\rho \\in (-1,1)$ 一致地，求出能确保加密抖动事件概率不大于给定容差 $\\delta$ 的最小迟滞间隙 $h_{\\min}$。\n\n抖动事件定义为在时间步 $t+1$ 进行加密，随后在时间步 $t+2$ 进行解密。这对应于联合事件 $\\{I_{t+1} \\ge \\theta_r, \\; I_{t+2} \\le \\theta_d\\}$。指示器变量 $I_t$ 由常数真实信号 $S$ 和噪声项 $X_t$ 的和给出，即 $I_t = S + X_t$。\n\n问题指定使用最坏情况的信号值 $S = S^\\star = (\\theta_r+\\theta_d)/2$。将此代入抖动事件的不等式中，我们得到：\n$$\n\\left\\{ \\frac{\\theta_r+\\theta_d}{2} + X_{t+1} \\ge \\theta_r, \\quad \\frac{\\theta_r+\\theta_d}{2} + X_{t+2} \\le \\theta_d \\right\\}\n$$\n我们可以简化这两个不等式。第一个不等式变为：\n$$\nX_{t+1} \\ge \\theta_r - \\frac{\\theta_r+\\theta_d}{2} = \\frac{2\\theta_r - \\theta_r - \\theta_d}{2} = \\frac{\\theta_r - \\theta_d}{2}\n$$\n第二个不等式变为：\n$$\nX_{t+2} \\le \\theta_d - \\frac{\\theta_r+\\theta_d}{2} = \\frac{2\\theta_d - \\theta_r - \\theta_d}{2} = \\frac{\\theta_d - \\theta_r}{2}\n$$\n迟滞间隙定义为 $h = \\theta_r - \\theta_d$。使用此定义，该事件可以纯粹用噪声过程 $X_t$ 和间隙 $h$ 来表示：\n$$\n\\{ X_{t+1} \\ge \\frac{h}{2}, \\quad X_{t+2} \\le -\\frac{h}{2} \\}\n$$\n我们关心的是此事件的概率，我们将其记为 $P_{\\text{thrash}}$。\n$$\nP_{\\text{thrash}}(h, \\rho, \\sigma) = P\\left( X_{t+1} \\ge \\frac{h}{2}, \\; X_{t+2} \\le -\\frac{h}{2} \\right)\n$$\n噪声 $X_t$ 是一个方差为 $\\sigma^2$、滞后-1 相关系数为 $\\rho$ 的平稳零均值高斯 AR($1$) 过程。这意味着对于任何时间 $t$，都有 $X_t \\sim \\mathcal{N}(0, \\sigma^2)$。$(X_{t+1}, X_{t+2})$ 的联合分布是二元正态分布。该分布的参数是：\n- 均值向量：$[\\mu_1, \\mu_2] = [E[X_{t+1}], E[X_{t+2}]] = [0, 0]$。\n- 协方差矩阵：方差为 $Var(X_{t+1}) = Var(X_{t+2}) = \\sigma^2$。协方差为 $Cov(X_{t+1}, X_{t+2}) = E[X_{t+1}X_{t+2}]$。根据 AR($1$) 的定义，$X_{t+2} = \\rho X_{t+1} + \\eta_{t+2}$。因此，$Cov(X_{t+1}, X_{t+2}) = E[X_{t+1}(\\rho X_{t+1} + \\eta_{t+2})] = \\rho E[X_{t+1}^2] + E[X_{t+1}\\eta_{t+2}]$。由于 $\\eta_{t+2}$ 独立于 $X_{t+1}$ 且均值为零，所以 $E[X_{t+1}\\eta_{t+2}]=0$。因此，$Cov(X_{t+1}, X_{t+2}) = \\rho E[X_{t+1}^2] = \\rho \\sigma^2$。\n\n所以，$(X_{t+1}, X_{t+2})$ 服从均值为 $[0, 0]$、协方差矩阵为 $\\Sigma_X = \\begin{pmatrix} \\sigma^2  \\rho\\sigma^2 \\\\ \\rho\\sigma^2  \\sigma^2 \\end{pmatrix}$ 的二元正态分布。\n\n为了使概率计算与 $\\sigma$ 无关，我们对随机变量进行标准化。令 $Z_1 = X_{t+1}/\\sigma$ 和 $Z_2 = X_{t+2}/\\sigma$。向量 $(Z_1, Z_2)$ 服从均值为 $[0, 0]$、相关系数为 $\\rho$ 的标准二元正态分布。不等式变为：\n$$\nP_{\\text{thrash}} = P\\left( \\sigma Z_1 \\ge \\frac{h}{2}, \\; \\sigma Z_2 \\le -\\frac{h}{2} \\right) = P\\left( Z_1 \\ge \\frac{h}{2\\sigma}, \\; Z_2 \\le -\\frac{h}{2\\sigma} \\right)\n$$\n我们定义一个归一化的迟滞间隙 $k = h/(2\\sigma)$。概率是 $k$ 和 $\\rho$ 的函数：\n$$\np(k, \\rho) = P(Z_1 \\ge k, \\; Z_2 \\le -k)\n$$\n问题要求对于任何 $\\rho \\in (-1,1)$，此概率至多为 $\\delta$。这意味着我们必须满足条件：\n$$\n\\sup_{\\rho \\in (-1,1)} p(k, \\rho) \\le \\delta\n$$\n为了找到上确界，我们分析 $p(k, \\rho)$ 如何随 $\\rho$ 变化。让我们考虑新的随机变量 $Y_1 = Z_1$ 和 $Y_2 = -Z_2$。向量 $(Y_1, Y_2)$ 也是零均值、单位方差的二元正态分布。其相关性为 $Cov(Y_1, Y_2) = Cov(Z_1, -Z_2) = -Cov(Z_1, Z_2) = -\\rho$。概率可以重写为：\n$$\np(k, \\rho) = P(Y_1 \\ge k, \\; Y_2 \\ge k)\n$$\n根据高斯随机向量的 Slepian 不等式，对于给定的阈值，所有分量都超过其各自阈值的概率是两两相关性的单调递增函数。在我们的例子中，$P(Y_1 \\ge k, \\; Y_2 \\ge k)$ 是相关性 $Cov(Y_1, Y_2) = -\\rho$ 的增函数。\n由于概率随 $-\\rho$ 递增，它必然随 $\\rho$ 递减。\n\n因此，$p(k, \\rho)$ 在 $\\rho \\in (-1,1)$ 上的上确界在 $\\rho$ 接近其定义域下界时达到，即 $\\rho \\to -1$。\n$$\n\\sup_{\\rho \\in (-1,1)} p(k, \\rho) = \\lim_{\\rho \\to -1^+} P(Z_1 \\ge k, \\; Z_2 \\le -k)\n$$\n当 $\\rho \\to -1$ 时，$(Z_1, Z_2)$ 的联合分布变得奇异，并集中在直线 $Z_2 = -Z_1$ 上。在此极限下，事件 $\\{Z_1 \\ge k, \\; Z_2 \\le -k\\}$ 变得等价于事件 $\\{Z_1 \\ge k, \\; -Z_1 \\le -k\\}$。第二个不等式 $-Z_1 \\le -k$ 等价于 $Z_1 \\ge k$。因此，联合事件简化为仅仅 $\\{Z_1 \\ge k\\}$。极限概率为：\n$$\n\\lim_{\\rho \\to -1^+} p(k, \\rho) = P(Z_1 \\ge k)\n$$\n其中 $Z_1 \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量。\n\n关于 $k$ 的条件变为 $P(Z_1 \\ge k) \\le \\delta$。令 $\\Phi(z)$ 为标准正态分布的累积分布函数 (CDF)。那么 $P(Z_1 \\ge k) = 1 - P(Z_1  k) = 1 - \\Phi(k)$。不等式为：\n$$\n1 - \\Phi(k) \\le \\delta \\implies \\Phi(k) \\ge 1 - \\delta\n$$\n由于 $\\Phi$ 是一个单调递增函数，我们可以将其反函数 $\\Phi^{-1}$ 应用于不等式两边：\n$$\nk \\ge \\Phi^{-1}(1 - \\delta)\n$$\n问题要求满足此条件的最小迟滞间隙 $h_{\\min}$。这对应于 $k$ 的最小值，即 $k_{\\min} = \\Phi^{-1}(1-\\delta)$。由于给定 $\\delta \\in (0, 1/2)$，我们有 $1-\\delta \\in (1/2, 1)$，因此 $k_{\\min} = \\Phi^{-1}(1-\\delta) > 0$。这与 $h > 0$ 和 $\\sigma > 0$ 一致。\n\n最后，我们使用关系式 $k = h/(2\\sigma)$ 将这个最小归一化间隙 $k_{\\min}$ 转换回最小物理间隙 $h_{\\min}$：\n$$\n\\frac{h_{\\min}}{2\\sigma} = k_{\\min} = \\Phi^{-1}(1 - \\delta)\n$$\n求解 $h_{\\min}$，我们得到最终表达式：\n$$\nh_{\\min} = 2\\sigma \\Phi^{-1}(1 - \\delta)\n$$\n这就是对迟滞间隙 $h$ 的充分条件（具体来说，是所需的最小值），以确保抖动概率被 $\\delta$ 界定，且对所有可能的噪声相关性 $\\rho \\in (-1,1)$ 一致成立。", "answer": "$$\\boxed{2\\sigma \\Phi^{-1}(1 - \\delta)}$$", "id": "3503452"}]}