{"hands_on_practices": [{"introduction": "ADM 形式主义为定义时空的全局属性（例如其总能量）提供了强有力的工具。本练习的重点是从空间无穷远处的面积分中数值计算 ADM 质量，这是一个基本的守恒量。通过对一个已知的黑洞解实施此计算，您将获得数值相对论中一项关键诊断工具的实践经验，该工具用于验证模拟时空的物理一致性。[@problem_id:3489121]", "problem": "您将为一个在 Kerr–Schild 坐标下表示的渐近平坦真空黑洞时空，实现并验证 Arnowitt–Deser–Misner (ADM) 能量的曲面积分。目标量是 ADM 质量，它由空间无穷远处的曲面积分定义，是度规的一个全局不变量。严格在几何单位制（$G=c=1$）下进行计算，因此质量、长度和时间都以相同的单位度量，并且在此单位制下是无量纲的。角度必须以弧度为单位。\n\n基本原理和定义：\n- 在一个等时切片上，对于一个渐近平坦的三维-度规 $\\gamma_{ij}$，其 ADM 质量由下式给出\n$$\nM_{\\mathrm{ADM}} = \\frac{1}{16\\pi}\\lim_{r\\to\\infty}\\oint_{S_r} \\left(\\partial_j \\gamma_{ij} - \\partial_i \\gamma_{jj}\\right)n^i\\,dS,\n$$\n其中 $n^i$ 是球面 $S_r$ 的向外单位法向量，$dS$ 是面积元，$\\partial_i$ 是对笛卡尔坐标 $x^i$ 的空间偏导数。\n- 在 Kerr–Schild 坐标系中，时空度规的形式为\n$$\ng_{\\mu\\nu} = \\eta_{\\mu\\nu} + 2H\\,\\ell_{\\mu}\\ell_{\\nu},\n$$\n其中 $\\eta_{\\mu\\nu}$ 是 Minkowski 度规，$H$ 是一个标量函数，$\\ell_\\mu$ 是一个相对于 $g_{\\mu\\nu}$ 和 $\\eta_{\\mu\\nu}$ 均为零的协变矢量场。在等时切片上，诱导三维-度规为\n$$\n\\gamma_{ij} = \\delta_{ij} + 2H\\,\\ell_i \\ell_j,\n$$\n其中 $\\delta_{ij}$ 是欧几里得三维-度规。\n- 对于质量为 $M$、比角动量为 $a$（自旋参数）的 Kerr 黑洞，定义：\n$$\n\\rho^2 = x^2 + y^2 + z^2,\n\\qquad\nr^2 = \\frac{1}{2}\\left(\\rho^2 - a^2\\right) + \\frac{1}{2}\\sqrt{\\left(\\rho^2 - a^2\\right)^2 + 4a^2 z^2},\n$$\n$$\nH = \\frac{M r^3}{r^4 + a^2 z^2},\n\\qquad\n\\ell_i = \\left(\\frac{r x + a y}{r^2 + a^2},\\ \\frac{r y - a x}{r^2 + a^2},\\ \\frac{z}{r}\\right).\n$$\n对于 Schwarzschild 极限 $a=0$，这些简化为 $r = \\sqrt{x^2+y^2+z^2}$，$H = M/r$ 和 $\\ell_i = (x/r, y/r, z/r)$。\n\n您的任务：\n1. 从 ADM 质量曲面积分的定义出发，在一个坐标半径为 $R$ 的球面上设计一个离散近似。使用一个在极角 $\\theta\\in[0,\\pi]$ 上有 $N_\\theta$ 个点、在方位角 $\\phi\\in[0,2\\pi)$ 上有 $N_\\phi$ 个点的均匀角向网格。使用中点法则\n$$\n\\theta_k = \\left(k+\\frac{1}{2}\\right)\\frac{\\pi}{N_\\theta},\\quad k=0,\\ldots,N_\\theta-1,\n\\qquad\n\\phi_m = \\left(m+\\frac{1}{2}\\right)\\frac{2\\pi}{N_\\phi},\\quad m=0,\\ldots,N_\\phi-1,\n$$\n角增量为 $\\Delta\\theta = \\pi/N_\\theta$ 和 $\\Delta\\phi = 2\\pi/N_\\phi$。\n2. 对于笛卡尔坐标为\n$$\nx = R \\sin\\theta \\cos\\phi,\\quad y = R \\sin\\theta \\sin\\phi,\\quad z = R \\cos\\theta,\n$$\n的每个曲面点，通过上述 Kerr–Schild 公式计算三维-度规 $\\gamma_{ij}(x,y,z)$。在每个笛卡尔方向上，使用步长为 $h=\\epsilon R$ 的二阶中心有限差分来近似所需的空间导数，其中 $\\epsilon$ 是一个小的无量纲参数。具体近似如下：\n$$\n\\partial_x \\gamma_{ij} \\approx \\frac{\\gamma_{ij}(x+h,y,z) - \\gamma_{ij}(x-h,y,z)}{2h},\n\\quad\n\\partial_y \\gamma_{ij} \\approx \\frac{\\gamma_{ij}(x,y+h,z) - \\gamma_{ij}(x,y-h,z)}{2h},\n\\quad\n\\partial_z \\gamma_{ij} \\approx \\frac{\\gamma_{ij}(x,y,z+h) - \\gamma_{ij}(x,y,z-h)}{2h}.\n$$\n使用这些来构建被积函数的离散近似 $\\mathcal{I}(x,y,z)$：\n$$\n\\mathcal{I}(x,y,z) \\approx \\sum_{i\\in\\{x,y,z\\}} \\left[ \\left(\\sum_{j\\in\\{x,y,z\\}} \\partial_j \\gamma_{ij}\\right) - \\partial_i \\left(\\sum_{k\\in\\{x,y,z\\}}\\gamma_{kk}\\right) \\right] \\hat{n}^i,\n$$\n其中 $\\hat{n}^i = x^i / R$ 是向外单位法向量，索引 $i, j, k$ 对应于笛卡尔分量 $(x,y,z)$。\n3. 通过下式近似曲面积分\n$$\n\\oint_{S_R} \\left(\\partial_j \\gamma_{ij} - \\partial_i \\gamma_{jj}\\right)\\hat{n}^i\\,dS\n\\approx\n\\sum_{k=0}^{N_\\theta-1}\\sum_{m=0}^{N_\\phi-1} \\mathcal{I}(\\theta_k,\\phi_m)\\, R^2 \\sin\\theta_k\\,\\Delta\\theta\\,\\Delta\\phi.\n$$\n最后计算\n$$\nM_{\\mathrm{ADM}}(R, N_\\theta, N_\\phi, \\epsilon) = \\frac{1}{16\\pi}\\times\\text{(上述离散曲面积分)}.\n$$\n\n科学真实性和推导要求：\n- 从给定的 ADM 定义和 Kerr–Schild 度规形式开始；不允许使用其他快捷公式。\n- 证明角向离散和有限差分离散是自洽的二阶近似。\n- 解释在 Schwarzschild 情况（$a=0$）下，解析导数如何表明被积函数在球面上为常数，以及为什么这会得到与 $R$ 无关的精确 ADM 质量，而数值计算结果会随着角向和有限差分分辨率的提高而收敛。\n\n单位和输出：\n- 使用几何单位制（$G=c=1$）；在此单位制下所有量均为无量纲。角度必须以弧度为单位。\n- 对于每个测试用例，以浮点数形式输出绝对误差 $|M_{\\mathrm{ADM}} - M|$。\n\n测试套件和要求的最终输出格式：\n- 为以下五个测试用例实现程序，每个用例由元组 $(M,a,R,N_\\theta,N_\\phi,\\epsilon)$ 指定：\n    1. $(1.0, 0.0, 10.0, 64, 128, 10^{-3})$。\n    2. $(1.0, 0.7, 2.0, 64, 128, 10^{-3})$。\n    3. $(1.0, 0.7, 10.0, 64, 128, 10^{-3})$。\n    4. $(1.0, 0.7, 50.0, 64, 128, 10^{-3})$。\n    5. $(1.0, 0.0, 2.0, 64, 128, 10^{-3})$。\n- 您的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”），每个结果对应于上面所列顺序的相应测试用例的绝对误差。", "solution": "*   **引言：** 我将首先陈述问题的目标：基于所提供的 Kerr-Schild 度规形式和指定的离散化方案，通过在有限半径处的曲面积分来数值计算 Kerr 黑洞的 ADM 质量。\n    *   **解析基础与 Schwarzschild 情况：**\n        *   ADM 质量定义为 $M_{\\mathrm{ADM}} = \\frac{1}{16\\pi}\\lim_{r\\to\\infty}\\oint_{S_r} V_i n^i\\,dS$，其中矢量场 $V_i = \\partial_j \\gamma_{ij} - \\partial_i \\gamma_{jj}$。索引 i,j 是笛卡尔坐标索引，取值范围为 1 到 3，并隐含对重复索引求和。\n        *   按照要求，我将首先分析 Schwarzschild 情况（$a=0$）。在此极限下，Kerr-Schild 各量简化为：$r=\\rho=\\sqrt{x^2+y^2+z^2}$，$H = M/r$，且零矢量分量为 $\\ell_i = x_i/r$。\n        *   三维-度规为 $\\gamma_{ij} = \\delta_{ij} + 2H \\ell_i \\ell_j = \\delta_{ij} + \\frac{2M}{r} \\frac{x_i x_j}{r^2} = \\delta_{ij} + \\frac{2M x_i x_j}{r^3}$。\n        *   我将计算被积函数所需的导数。度规的偏导数为 $\\partial_k \\gamma_{ij} = \\frac{2M}{r^3}(\\delta_{ki}x_j + \\delta_{kj}x_i) - \\frac{6M x_i x_j x_k}{r^5}$。\n        *   然后，计算矢量 $V_i$ 的两项。\n            *   第一项是类散度项 $\\partial_j \\gamma_{ij} = \\sum_j \\partial_j \\gamma_{ij}$。使用上述导数，此项简化为 $\\partial_j \\gamma_{ij} = \\frac{2M x_i}{r^3}$。\n            *   第二项需要迹 $\\gamma_{jj} = \\sum_j \\gamma_{jj} = 3 + 2H \\ell_j \\ell_j = 3 + 2M/r$。其梯度为 $\\partial_i \\gamma_{jj} = \\partial_i (3 + 2M/r) = - \\frac{2M x_i}{r^3}$。\n        *   将这些结合起来得到矢量场 $V_i = \\frac{2M x_i}{r^3} - (-\\frac{2M x_i}{r^3}) = \\frac{4M x_i}{r^3}$。\n        *   被积函数是 $V_i$ 在坐标半径为 $R$ 的球面上的向外法向量 $n^i = x^i/R$ 上的投影。在此球面上，$r=R$，被积函数为 $V_i n^i = (\\frac{4M x_i}{R^3})(\\frac{x_i}{R}) = \\frac{4M}{R^4}\\sum_i x_i^2 = \\frac{4M R^2}{R^4} = \\frac{4M}{R^2}$。\n        *   由于被积函数在球面上是常数，积分就是被积函数乘以球的面积（$4\\pi R^2$）：$\\oint_{S_R} V_i n^i dS = \\frac{4M}{R^2} (4\\pi R^2) = 16\\pi M$。\n        *   最后，$M_{\\mathrm{ADM}} = \\frac{1}{16\\pi} (16\\pi M) = M$。\n        *   这个推导表明，对于这些坐标下的 Schwarzschild 度规，ADM 积分在任何有限半径 $R$ 处都能得到精确的质量 $M$，而不仅仅是在无穷远处。这为数值代码提供了一个关键的基准。由有限差分和有限网格引起的数值误差将导致计算值偏离 $M$，但随着数值分辨率的提高，它应该会收敛到 $M$。\n    *   **数值实现策略：**\n        *   目标是近似计算 $M_{\\mathrm{ADM}}(R) = \\frac{1}{16\\pi} \\sum_{k=0}^{N_\\theta-1}\\sum_{m=0}^{N_\\phi-1} \\mathcal{I}(\\theta_k,\\phi_m)\\, R^2 \\sin\\theta_k\\,\\Delta\\theta\\,\\Delta\\phi$，其中 $\\mathcal{I}$ 是被积函数。\n        *   算法流程如下：\n            1.  使用中点法则和增量 $\\Delta\\theta, \\Delta\\phi$ 定义角向网格点 $(\\theta_k, \\phi_m)$。\n            2.  遍历网格上的每个点。对于每个 $(\\theta_k, \\phi_m)$，计算相应的笛卡尔坐标 $(x,y,z)$。\n            3.  在每个点 $(x,y,z)$，计算被积函数 $\\mathcal{I}$。这是计算量最大的一步。\n            4.  为了计算 $\\mathcal{I} = (\\partial_j \\gamma_{ij} - \\partial_i \\gamma_{jj})n^i$，使用步长为 $h = \\epsilon R$ 的二阶中心有限差分来近似空间导数。这需要计算在点 $(x\\pm h, y, z)$、$(x, y\\pm h, z)$ 和 $(x, y, z\\pm h)$ 处的度规 $\\gamma_{ij}$。\n            5.  将设计一个辅助函数，根据给定的 Kerr-Schild 公式计算 $\\gamma_{ij}(x,y,z)$。这涉及计算 $\\rho^2, r^2, H$ 和矢量 $\\ell_i$。\n            6.  导数的近似值将用于计算两个矢量：$A_i = \\partial_j \\gamma_{ij}$ 和 $B_i = \\partial_i \\gamma_{jj}$。被积矢量是 $V_i = A_i - B_i$。\n            7.  然后通过将 $V_i$ 与法向量 $n^i = x^i/R$ 做点积来得到标量被积函数。\n            8.  将当前网格点的贡献 $\\mathcal{I}(\\theta_k, \\phi_m) \\times R^2 \\sin\\theta_k\\,\\Delta\\theta\\,\\Delta\\phi$ 添加到一个累加和中。\n            9.  遍历所有网格点后，将最终的和乘以 $1/(16\\pi)$，得到数值近似值 $M_{\\mathrm{ADM}}$。\n    *   **离散化的合理性证明：** 该方法的自洽性通过选择二阶方案得到保证。用于数值积分的中点法则在角向步长上提供二阶精度，即误差 $\\propto (\\Delta\\theta)^2, (\\Delta\\phi)^2$。用于导数的中心有限差分方案在空间步长上提供二阶精度，即误差 $\\propto h^2$。因此，随着网格分辨率的增加和有限差分步长的减小，总体数值误差预计将具有二阶收敛性。\n\n这种建立在解的解析性质之上、并通过自洽数值方案实现的结构化方法，将被用来生成所需的 Python 程序。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for ADM mass calculation.\n    \"\"\"\n    # Test cases: (M, a, R, N_theta, N_phi, epsilon)\n    test_cases = [\n        (1.0, 0.0, 10.0, 64, 128, 1e-3),\n        (1.0, 0.7, 2.0, 64, 128, 1e-3),\n        (1.0, 0.7, 10.0, 64, 128, 1e-3),\n        (1.0, 0.7, 50.0, 64, 128, 1e-3),\n        (1.0, 0.0, 2.0, 64, 128, 1e-3),\n    ]\n\n    results = []\n    for M, a, R, N_theta, N_phi, epsilon in test_cases:\n        m_adm = calculate_adm_mass(M, a, R, N_theta, N_phi, epsilon)\n        error = abs(m_adm - M)\n        results.append(error)\n    \n    # Format the output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_gamma(x: float, y: float, z: float, M: float, a: float) -> np.ndarray:\n    \"\"\"\n    Calculates the 3-metric gamma_ij at a given Cartesian point (x, y, z)\n    for a Kerr black hole with mass M and spin a.\n    \"\"\"\n    rho2 = x**2 + y**2 + z**2\n    a2 = a**2\n    \n    if a == 0:\n        # Schwarzschild case\n        if rho2 == 0:\n            return np.identity(3) # Origin, not hit on integration surface\n        r = np.sqrt(rho2)\n        H = M / r\n        l_vec = np.array([x, y, z]) / r\n    else:\n        # Kerr case\n        term = rho2 - a2\n        # The term inside sqrt is non-negative.\n        sq_term = np.sqrt(term**2 + 4 * a2 * z**2)\n        r2 = 0.5 * (term + sq_term)\n        \n        # Avoid division by zero at the ring singularity, though not expected on surface.\n        if r**4 + a2 * z**2 == 0:\n             return np.identity(3)\n        \n        r = np.sqrt(r2)\n        \n        # Denominator in H can be zero only at r=0 and z=0 (singularity).\n        H = M * r**3 / (r**4 + a2 * z**2)\n        \n        # Denominator in l_vec components can be zero if r=0 and a=0. Handled by a==0 case.\n        l0 = (r * x + a * y) / (r2 + a2)\n        l1 = (r * y - a * x) / (r2 + a2)\n        l2 = z / r\n        l_vec = np.array([l0, l1, l2])\n        \n    # gamma_ij = delta_ij + 2*H*l_i*l_j\n    gamma = np.identity(3) + 2 * H * np.outer(l_vec, l_vec)\n    return gamma\n\ndef calculate_adm_mass(M: float, a: float, R: float, N_theta: int, N_phi: int, epsilon: float) -> float:\n    \"\"\"\n    Numerically computes the ADM mass using a surface integral on a sphere\n    of coordinate radius R.\n    \"\"\"\n    h = epsilon * R\n    d_theta = np.pi / N_theta\n    d_phi = 2 * np.pi / N_phi\n    \n    integral_sum = 0.0\n    \n    dir_vectors = np.array([[h, 0, 0], [0, h, 0], [0, 0, h]])\n\n    # Loop over the spherical grid points (midpoint rule)\n    for k in range(N_theta):\n        theta = (k + 0.5) * d_theta\n        for m in range(N_phi):\n            phi = (m + 0.5) * d_phi\n            \n            # Cartesian coordinates of the grid point\n            x = R * np.sin(theta) * np.cos(phi)\n            y = R * np.sin(theta) * np.sin(phi)\n            z = R * np.cos(theta)\n            \n            p = np.array([x, y, z])\n            \n            # Calculate numerical derivatives_\n            # dgamma[i, j, k] will hold the numerical approximation of partial_k(gamma_ij)\n            dgamma = np.zeros((3, 3, 3))\n            \n            # grad_trace_gamma[k] will hold partial_k(trace(gamma))\n            grad_trace_gamma = np.zeros(3)\n\n            for k_dim in range(3):  # Corresponds to derivatives w.r.t. x, y, z\n                p_plus = p + dir_vectors[k_dim]\n                p_minus = p - dir_vectors[k_dim]\n                \n                gamma_plus = get_gamma(p_plus[0], p_plus[1], p_plus[2], M, a)\n                gamma_minus = get_gamma(p_minus[0], p_minus[1], p_minus[2], M, a)\n                \n                # Finite difference for the tensor gamma_ij\n                dgamma[:, :, k_dim] = (gamma_plus - gamma_minus) / (2 * h)\n                \n                # Finite difference for the trace of gamma\n                trace_plus = np.trace(gamma_plus)\n                trace_minus = np.trace(gamma_minus)\n                grad_trace_gamma[k_dim] = (trace_plus - trace_minus) / (2 * h)\n\n            # Construct the integrand vector V_i = partial_j(gamma_ij) - partial_i(gamma_jj)\n            # A_i = partial_j(gamma_ij) summed over j\n            # A = np.einsum('ijj->i', dgamma) # Sums dgamma[i,j,j]\n            A = np.array([np.sum(dgamma[i, j, j] for j in range(3)) for i in range(3)])\n\n            # B_i = partial_i(gamma_jj)\n            B = grad_trace_gamma\n            \n            V = A - B\n            \n            # Dot product with the unit normal vector n_hat\n            n_hat = p / R\n            integrand_val = np.dot(V, n_hat)\n            \n            # Surface element dS\n            dS = R**2 * np.sin(theta) * d_theta * d_phi\n            \n            integral_sum += integrand_val * dS\n            \n    # Final ADM mass calculation\n    M_adm = integral_sum / (16 * np.pi)\n    \n    return M_adm\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3489121"}, {"introduction": "虽然物理定律与所选的坐标系无关，但其数值表示却并非如此。本实践探讨了选择规范的实际后果，特别是决定空间坐标如何随时间演化的移位矢量 $\\beta^i$。您将模拟不同的移位条件如何导致坐标系漂移，从而直接影响提取出的引力波相位，这揭示了将模拟结果与观测数据联系起来时的一个关键挑战。[@problem_id:3489100]", "problem": "考虑在渐近平坦时空中，单个、孤立、旋转黑洞 (BH) 的 Arnowitt-Deser-Misner (ADM) 形式主义，并重点关注移位矢量的规范选择对波形提取的影响。在一个标准的 $3+1$ 分解中，时空度规被分解为一个空间度规 $ \\gamma_{ij} $、一个 lapse 函数 $ \\alpha $ 和一个移位矢量 $ \\beta^{i} $。移位矢量 $ \\beta^{i} $ 决定了空间坐标如何在超曲面之间输运，因此直接影响了诸如提取球面等结构的坐标位置的演化。\n\n从以下经过充分检验的基本出发点开始：\n- 广义相对论在 Arnowitt-Deser-Misner (ADM) 形式主义下的 $3+1$ 分解，其线元表达式为 $ ds^{2} = -\\alpha^{2} dt^{2} + \\gamma_{ij} (dx^{i} + \\beta^{i} dt)(dx^{j} + \\beta^{j} dt) $。\n- 由质量为 $ M $、有量纲自旋参数为 $ a $ 的旋转黑洞引起的惯性系拖拽所产生的远场、线性化 Lense-Thirring 角速度，在几何单位制 $ G = c = 1 $ 下由 $ \\omega_{\\mathrm{LT}}(r) = \\dfrac{2 a M}{r^{3}} $ 给出，在 $ r \\gg M $ 时有效。\n\n您将比较两种移位约定：\n- 最小畸变移位，在静态、轴对称、远场极限下，它与冻结畸变和恢复渐近惯性系拖拽相一致。在此近似下，移位的方位角分量由 $ \\beta^{\\phi}_{\\mathrm{MD}}(r) \\approx \\omega_{\\mathrm{LT}}(r) $ 建模。\n- 在 Baumgarte-Shapiro-Shibata-Nakamura (BSSN) 演化系统中使用的 Gamma-driver 移位，这里简化为对目标轮廓的阻尼趋近。在这个简化模型中，方位角移位由常微分方程 $ \\dfrac{d}{dt} \\beta^{\\phi}(t) = -\\eta \\left( \\beta^{\\phi}(t) - \\lambda \\, \\omega_{\\mathrm{LT}}(r) \\right) $ 控制，其中 $ \\eta $ 是一个正阻尼系数，$ \\lambda \\in [0,1] $ 参数化了驱动器强制执行渐近惯性系拖拽目标的强度。取初始条件为 $ \\beta^{\\phi}(0) = 0 $。\n\n将提取球面视为一个固定坐标半径 $ r_{e} $ 处的坐标球面，其关联的坐标方位角漂移角 $ \\varphi(t) $ 完全由方位角规范移位 $ \\beta^{\\phi}(t) $ 通过 $ \\dfrac{d}{dt} \\varphi(t) = \\beta^{\\phi}(t) $ 和 $ \\varphi(0) = 0 $ 引起。假设径向移位可忽略不计，且 lapse 函数 $ \\alpha $ 在提取半径处保持在 1 附近，因此由 $ \\alpha $ 变化引起的推迟时修正在此模型的量级上可以忽略。在提取球面坐标系绕对称轴进行角度为 $ \\varphi(t) $ 的被动旋转下，自旋加权球谐模 $ h_{22} $ 会获得一个由规范引起的相位偏移 $ \\Delta \\Phi_{22}(t) = m \\, \\varphi(t) $，其中 $ m = 2 $。\n\n任务：\n1. 基于上述基本点和假设，推导出 Gamma-driver 模型的 $ \\beta^{\\phi}_{\\mathrm{MD}}(r_{e}) $ 和 $ \\beta^{\\phi}_{\\mathrm{GD}}(t; r_{e}) $ 的表达式，在持续时间为 $ T $ 的观测窗口内对应的漂移角 $ \\varphi_{\\mathrm{MD}}(T) $ 和 $ \\varphi_{\\mathrm{GD}}(T) $，以及相关的相位偏移 $ \\Delta \\Phi_{22,\\mathrm{MD}}(T) $ 和 $ \\Delta \\Phi_{22,\\mathrm{GD}}(T) $。\n2. 在一个程序中实现这些表达式，对于每个测试用例，返回在时间 $ T $ 评估的列表 $ [\\varphi_{\\mathrm{MD}}, \\varphi_{\\mathrm{GD}}, \\Delta \\Phi_{22,\\mathrm{MD}}, \\Delta \\Phi_{22,\\mathrm{GD}}, \\Delta \\Phi_{22,\\mathrm{GD}} - \\Delta \\Phi_{22,\\mathrm{MD}}] $。\n\n使用几何单位制 $ G = c = 1 $。角度 $ \\varphi $ 和相位 $ \\Delta \\Phi $ 以弧度表示。时间 $ T $、半径 $ r_{e} $ 和黑洞质量 $ M $ 以 $ M $ 为单位。阻尼 $ \\eta $ 以 $ 1/M $ 为单位。自旋由无量纲自旋 $ \\chi = a/M $ 参数化。\n\n测试套件：\n- 用例 $1$ (正常路径)：$ \\chi = 0.5 $, $ r_{e} = 50 $, $ T = 1000 $, $ \\eta = 0.02 $, $ \\lambda = 0.7 $。\n- 用例 $2$ (小自旋)：$ \\chi = 0.1 $, $ r_{e} = 100 $, $ T = 500 $, $ \\eta = 0.01 $, $ \\lambda = 0.5 $。\n- 用例 $3$ (近极值自旋和更强阻尼)：$ \\chi = 0.9 $, $ r_{e} = 30 $, $ T = 2000 $, $ \\eta = 0.1 $, $ \\lambda = 1.0 $。\n- 用例 $4$ (自旋和目标消失的边界情况)：$ \\chi = 0.0 $, $ r_{e} = 80 $, $ T = 1000 $, $ \\eta = 0.05 $, $ \\lambda = 0.0 $。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个子列表，顺序如上所述。每个子列表必须是在时间 $ T $ 评估的 $ [\\varphi_{\\mathrm{MD}}, \\varphi_{\\mathrm{GD}}, \\Delta \\Phi_{22,\\mathrm{MD}}, \\Delta \\Phi_{22,\\mathrm{GD}}, \\Delta \\Phi_{22,\\mathrm{GD}} - \\Delta \\Phi_{22,\\mathrm{MD}}] $ (以弧度为单位)。例如，输出应类似于 $ [[x_{11},x_{12},x_{13},x_{14},x_{15}],[x_{21},x_{22},x_{23},x_{24},x_{25}],\\ldots] $，其中每个 $ x_{ij} $ 是一个浮点数。", "solution": "问题陈述已经过评估并被确定为有效。它在科学上基于广义相对论的 Arnowitt-Deser-Misner (ADM) 形式主义，提法适定，信息充足，可得出唯一解，并使用客观、正式的语言进行表述。所提供的模型和参数在数值相对论和引力波提取的背景下是标准且合理的。\n\n主要任务是为两种不同的移位矢量约定——最小畸变 (MD) 移位和 Gamma-driver (GD) 移位——推导并实现规范引起的漂移角以及对引力波模式产生的相应相位偏移的表达式。所有计算都在几何单位制 ($G = c = 1$) 中进行。\n\n首先，我们建立提取半径 $r_e$ 处的基准 Lense-Thirring 角速度。这代表了移位条件旨在建模或响应的物理惯性系拖拽效应。有量纲自旋参数 $a$ 通过 $a = \\chi M$ 与无量纲自旋 $\\chi$ 和黑洞质量 $M$ 相关联。\nLense-Thirring 角速度由下式给出：\n$$ \\omega_{\\mathrm{LT}}(r) = \\frac{2 a M}{r^3} $$\n代入 $a = \\chi M$，在提取半径 $r_e$ 处的值为：\n$$ \\omega_{\\mathrm{LT},e} \\equiv \\omega_{\\mathrm{LT}}(r_e) = \\frac{2 \\chi M^2}{r_e^3} $$\n由于所有的长度和时间尺度（$r_e, T$）都以 $M$ 为单位给出，阻尼系数 $\\eta$ 以 $1/M$ 为单位，我们可以在数值计算中设置 $M=1$。由此产生的角速度表达式为 $\\omega_{\\mathrm{LT},e} = 2 \\chi / r_e^3$。$\\omega_{\\mathrm{LT},e}$ 的单位是 $1/M$，这对于角速度是合适的。\n\n**1. 最小畸变 (MD) 移位约定**\n\n在该模型中，方位角移位分量被假定为静态的，并且等于渐近 Lense-Thirring 角速度。\n$$ \\beta^{\\phi}_{\\mathrm{MD}}(r_e) = \\omega_{\\mathrm{LT},e} = \\frac{2 \\chi M^2}{r_e^3} $$\n坐标方位角漂移角 $\\varphi_{\\mathrm{MD}}(t)$ 是通过对移位矢量随时间积分得到的，初始条件为 $\\varphi_{\\mathrm{MD}}(0) = 0$。\n$$ \\frac{d\\varphi_{\\mathrm{MD}}}{dt} = \\beta^{\\phi}_{\\mathrm{MD}}(r_e) $$\n$$ \\varphi_{\\mathrm{MD}}(T) = \\int_0^T \\beta^{\\phi}_{\\mathrm{MD}}(r_e) \\, dt = \\beta^{\\phi}_{\\mathrm{MD}}(r_e) T = \\omega_{\\mathrm{LT},e} T $$\n代入 $\\omega_{\\mathrm{LT},e}$ 的表达式，我们得到：\n$$ \\varphi_{\\mathrm{MD}}(T) = \\left( \\frac{2 \\chi M^2}{r_e^3} \\right) T $$\n对于 $m=2$ 模式，对应的相位偏移为：\n$$ \\Delta \\Phi_{22,\\mathrm{MD}}(T) = m \\, \\varphi_{\\mathrm{MD}}(T) = 2 \\varphi_{\\mathrm{MD}}(T) = \\left( \\frac{4 \\chi M^2}{r_e^3} \\right) T $$\n\n**2. Gamma-Driver (GD) 移位约定**\n\n该模型描述了移位矢量的动态演化，其中它被“驱动”至一个目标轮廓，这里由 $\\lambda \\, \\omega_{\\mathrm{LT},e}$ 给出。该演化由一个一阶常微分方程 (ODE) 控制：\n$$ \\frac{d}{dt} \\beta^{\\phi}_{\\mathrm{GD}}(t) = -\\eta \\left( \\beta^{\\phi}_{\\mathrm{GD}}(t) - \\lambda \\, \\omega_{\\mathrm{LT},e} \\right) $$\n这是一个形式为 $y' + \\eta y = \\eta K$ 的标准线性常微分方程，其中 $y(t) = \\beta^{\\phi}_{\\mathrm{GD}}(t)$ 且 $K = \\lambda \\, \\omega_{\\mathrm{LT},e}$。其通解为 $y(t) = K + C e^{-\\eta t}$，其中 $C$ 是一个积分常数。使用初始条件 $\\beta^{\\phi}_{\\mathrm{GD}}(0) = 0$：\n$$ 0 = K + C e^0 \\implies C = -K $$\n因此，随时间变化的移位为：\n$$ \\beta^{\\phi}_{\\mathrm{GD}}(t; r_e) = \\lambda \\, \\omega_{\\mathrm{LT},e} \\left( 1 - e^{-\\eta t} \\right) $$\n为了找到总漂移角 $\\varphi_{\\mathrm{GD}}(T)$，我们将 $\\beta^{\\phi}_{\\mathrm{GD}}(t)$ 从 $t=0$ 积分到 $t=T$，初始条件为 $\\varphi_{\\mathrm{GD}}(0)=0$：\n$$ \\varphi_{\\mathrm{GD}}(T) = \\int_0^T \\beta^{\\phi}_{\\mathrm{GD}}(t) \\, dt = \\int_0^T \\lambda \\, \\omega_{\\mathrm{LT},e} \\left( 1 - e^{-\\eta t} \\right) \\, dt $$\n$$ \\varphi_{\\mathrm{GD}}(T) = \\lambda \\, \\omega_{\\mathrm{LT},e} \\left[ t + \\frac{1}{\\eta} e^{-\\eta t} \\right]_0^T $$\n$$ \\varphi_{\\mathrm{GD}}(T) = \\lambda \\, \\omega_{\\mathrm{LT},e} \\left( \\left( T + \\frac{e^{-\\eta T}}{\\eta} \\right) - \\left( 0 + \\frac{e^0}{\\eta} \\right) \\right) $$\n$$ \\varphi_{\\mathrm{GD}}(T) = \\lambda \\, \\omega_{\\mathrm{LT},e} \\left( T - \\frac{1 - e^{-\\eta T}}{\\eta} \\right) $$\n对于 $m=2$ 模式，对应的相位偏移为：\n$$ \\Delta \\Phi_{22,\\mathrm{GD}}(T) = m \\, \\varphi_{\\mathrm{GD}}(T) = 2 \\varphi_{\\mathrm{GD}}(T) = 2 \\lambda \\, \\omega_{\\mathrm{LT},e} \\left( T - \\frac{1 - e^{-\\eta T}}{\\eta} \\right) $$\n\n**用于实现的表达式总结**\n\n对于每个具有参数 $(\\chi, r_e, T, \\eta, \\lambda)$ 的测试用例，并设置 $M=1$:\n1.  计算 Lense-Thirring 角速度：$\\omega_{\\mathrm{LT},e} = \\frac{2 \\chi}{r_e^3}$。\n2.  计算最小畸变漂移角：$\\varphi_{\\mathrm{MD}} = \\omega_{\\mathrm{LT},e} T$。\n3.  计算 Gamma-driver 漂移角：$\\varphi_{\\mathrm{GD}} = \\lambda \\, \\omega_{\\mathrm{LT},e} \\left( T - \\frac{1 - e^{-\\eta T}}{\\eta} \\right)$。\n4.  计算最小畸变相位偏移：$\\Delta \\Phi_{22,\\mathrm{MD}} = 2 \\varphi_{\\mathrm{MD}}$。\n5.  计算 Gamma-driver 相位偏移：$\\Delta \\Phi_{22,\\mathrm{GD}} = 2 \\varphi_{\\mathrm{GD}}$。\n6.  计算相位差：$\\Delta \\Phi_{22, \\text{diff}} = \\Delta \\Phi_{22,\\mathrm{GD}} - \\Delta \\Phi_{22,\\mathrm{MD}}$。\n\n这些表达式将被实现，以计算每个测试用例所需的值列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates gauge-induced phase drifts in gravitational waveforms for different\n    shift conditions in the ADM formalism.\n    \"\"\"\n    # Test cases from the problem statement.\n    # Each case is a tuple: (chi, r_e, T, eta, lambda)\n    # chi: dimensionless spin (a/M)\n    # r_e: extraction radius in units of M\n    # T: observation duration in units of M\n    # eta: Gamma-driver damping coefficient in units of 1/M\n    # lambda: Gamma-driver target strength parameter (dimensionless)\n    test_cases = [\n        # Case 1 (happy path)\n        (0.5, 50.0, 1000.0, 0.02, 0.7),\n        # Case 2 (small spin)\n        (0.1, 100.0, 500.0, 0.01, 0.5),\n        # Case 3 (near-extremal spin and stronger damping)\n        (0.9, 30.0, 2000.0, 0.1, 1.0),\n        # Case 4 (boundary case with vanishing spin and target)\n        (0.0, 80.0, 1000.0, 0.05, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        chi, r_e, T, eta, lam = case\n        \n        # We work in geometrized units with M=1.\n        # All input parameters are already given in terms of M.\n\n        # Calculate the Lense-Thirring angular velocity at the extraction radius.\n        # This is the target for frame dragging.\n        # omega_LT = (2 * chi * M^2) / r_e^3. With M=1, this is 2 * chi / r_e^3.\n        if r_e == 0:\n            omega_lt_e = float('inf') if chi != 0 else 0.0\n        else:\n            omega_lt_e = (2.0 * chi) / (r_e**3)\n\n        # 1. Minimal-Distortion (MD) model\n        # The shift is constant and equals the LT angular velocity.\n        # The drift angle is beta * T.\n        phi_md = omega_lt_e * T\n        \n        # The phase offset for the m=2 mode is 2 * phi.\n        delta_phi_22_md = 2.0 * phi_md\n\n        # 2. Gamma-Driver (GD) model\n        # The shift evolves according to a damped ODE toward a target lam * omega_lt_e.\n        # The integrated drift angle is given by the derived formula.\n        \n        # Handle the chi=0 or lam=0 case to avoid unnecessary computation.\n        if chi == 0.0 or lam == 0.0:\n            phi_gd = 0.0\n        else:\n            # The formula is lambda * omega_LT * (T - (1 - exp(-eta*T))/eta)\n            # The problem states eta is a positive damping coefficient, so no division by zero.\n            term_in_parentheses = T - (1.0 - np.exp(-eta * T)) / eta\n            phi_gd = lam * omega_lt_e * term_in_parentheses\n        \n        # The phase offset for the m=2 mode is 2 * phi.\n        delta_phi_22_gd = 2.0 * phi_gd\n        \n        # 3. Phase difference\n        delta_phi_diff = delta_phi_22_gd - delta_phi_22_md\n\n        # Assemble the list of results for this case.\n        case_results = [\n            phi_md,\n            phi_gd,\n            delta_phi_22_md,\n            delta_phi_22_gd,\n            delta_phi_diff\n        ]\n        results.append(case_results)\n\n    # Format the output string to match the required format: [[...],[...],...]\n    outer_list_str = []\n    for sub_list in results:\n        # Convert each number in the sub-list to a string\n        inner_list_str = \",\".join(map(str, sub_list))\n        # Enclose in brackets\n        outer_list_str.append(f\"[{inner_list_str}]\")\n\n    final_output = f\"[{','.join(outer_list_str)}]\"\n    print(final_output)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3489100"}, {"introduction": "数值相对论的一个核心挑战是在数千个时间步长上演化后仍能保持约束方程。本练习深入探讨时间演化算法的核心，通过比较一个标准的数值积分器和一个辛积分器，后者旨在尊重方程的哈密顿结构。通过将这些方法应用于一个简化的宇宙学模型，您将直接观察到积分器的选择如何影响模拟的长期稳定性和物理准确性。[@problem_id:3489062]", "problem": "考虑一个在 Arnowitt-Deser-Misner (ADM) 形式下的均匀、对角、各向异性的广义相对论微超空间模型，具体而言，是增加了正宇宙学常数的 Bianchi I 型宇宙学。在 Misner 变量 $(\\alpha,\\beta_{+},\\beta_{-})$ 及其共轭动量 $(p_{\\alpha},p_{+},p_{-})$ 下，采用普朗克单位制，其中 $c=1$ 且 $8\\pi G=1$，因此所有量均为无量纲。哈密顿约束由下式给出：\n$$\nC(\\alpha,\\beta_{+},\\beta_{-},p_{\\alpha},p_{+},p_{-};\\Lambda)\n=\n-p_{\\alpha}^{2} + p_{+}^{2} + p_{-}^{2} + \\Lambda\\, e^{6\\alpha},\n$$\n物理轨迹满足 $C \\approx 0$。总哈密顿量为 $H = N\\,C$，在时间规范 $N=1$ 下，哈密顿方程为：\n$$\n\\dot{\\alpha} = \\frac{\\partial C}{\\partial p_{\\alpha}},\\quad\n\\dot{\\beta}_{+} = \\frac{\\partial C}{\\partial p_{+}},\\quad\n\\dot{\\beta}_{-} = \\frac{\\partial C}{\\partial p_{-}},\n$$\n$$\n\\dot{p}_{\\alpha} = -\\frac{\\partial C}{\\partial \\alpha},\\quad\n\\dot{p}_{+} = -\\frac{\\partial C}{\\partial \\beta_{+}},\\quad\n\\dot{p}_{-} = -\\frac{\\partial C}{\\partial \\beta_{-}}.\n$$\n该系统是可分离的，即 $C = T(p_{\\alpha},p_{+},p_{-}) + V(\\alpha)$，其中：\n$$\nT(p_{\\alpha},p_{+},p_{-}) = -p_{\\alpha}^{2} + p_{+}^{2} + p_{-}^{2},\\quad\nV(\\alpha) = \\Lambda\\, e^{6\\alpha}.\n$$\n\n您的任务是为此系统实现两种数值时间积分器，并比较哈密顿约束 $C \\approx 0$ 的长期稳定性：\n\n1.  一种基于分解 $C = T + V$ 的辛分裂 (Strang/Stormer–Verlet) 积分器，使用正则更新：\n    -   用 $V$ 对动量进行半步“踢” (kick)：$p \\leftarrow p - \\tfrac{\\Delta t}{2}\\,\\nabla_{q} V(q)$。\n    -   用 $T$ 对坐标进行整步“漂移” (drift)：$q \\leftarrow q + \\Delta t\\,\\nabla_{p} T(p)$。\n    -   在更新后的 $q$ 处，用 $V$ 对动量进行另一次半步“踢”。\n    此处，$q=(\\alpha,\\beta_{+},\\beta_{-})$ 且 $p=(p_{\\alpha},p_{+},p_{-})$，并且 $\\nabla_{q} V$ 仅在 $\\alpha$ 分量上非零：$\\partial V/\\partial \\alpha = 6\\Lambda e^{6\\alpha}$。\n\n2.  一种应用于哈密顿常微分方程 (ODE) 的非辛显式经典四阶龙格－库塔方法 (Runge-Kutta (RK) 4)。\n\n从初始数据 $(\\alpha_{0},\\beta_{+,0},\\beta_{-,0},p_{\\alpha,0},p_{+,0},p_{-,0})$ 开始，通过选择 $p_{\\alpha,0}$ 如下，使得约束在初始时在浮点误差范围内得到满足：\n$$\np_{\\alpha,0} = \\sqrt{p_{+,0}^{2} + p_{-,0}^{2} + \\Lambda\\, e^{6\\alpha_{0}}}.\n$$\n\n对于每个测试用例，使用固定的时间步长 $\\Delta t$ 将两种方法积分至总时间 $T$，并记录约束的最大绝对漂移：\n$$\n\\Delta C_{\\max} = \\max_{n\\in\\{0,1,\\dots,N\\}} \\left| C(\\text{state}(t_{n})) - C(\\text{state}(t_{0})) \\right|,\n$$\n其中 $t_{n} = n\\,\\Delta t$ 且 $N = \\lfloor T/\\Delta t \\rfloor$。计算辛方法和 RK4 方法的此量，并报告辛方法的漂移是否小于或等于 RK4 方法。\n\n实现您的程序，为以下测试套件生成结果。每个测试用例指定 $(\\Lambda, T, \\Delta t, \\alpha_{0}, \\beta_{+,0}, \\beta_{-,0}, p_{+,0}, p_{-,0})$：\n\n-   情况 1 (真空边界): $(\\Lambda=\\;0,\\; T=\\;100,\\;\\Delta t=\\;0.1,\\;\\alpha_{0}=\\;0,\\;\\beta_{+,0}=\\;0,\\;\\beta_{-,0}=\\;0,\\;p_{+,0}=\\;0.01,\\;p_{-,0}=\\;-0.015)$。\n-   情况 2 (长时，小势): $(\\Lambda=\\;10^{-3},\\; T=\\;1000,\\;\\Delta t=\\;0.5,\\;\\alpha_{0}=\\;0.2,\\;\\beta_{+,0}=\\;0.05,\\;\\beta_{-,0}=\\;-0.03,\\;p_{+,0}=\\;0.02,\\;p_{-,0}=\\;-0.01)$。\n-   情况 3 (中等势): $(\\Lambda=\\;10^{-2},\\; T=\\;500,\\;\\Delta t=\\;0.5,\\;\\alpha_{0}=\\;-0.2,\\;\\beta_{+,0}=\\;0,\\;\\beta_{-,0}=\\;0,\\;p_{+,0}=\\;0.02,\\;p_{-,0}=\\;0.015)$。\n-   情况 4 (大步长压力测试): $(\\Lambda=\\;10^{-2},\\; T=\\;500,\\;\\Delta t=\\;1.5,\\;\\alpha_{0}=\\;0.4,\\;\\beta_{+,0}=\\;0,\\;\\beta_{-,0}=\\;0,\\;p_{+,0}=\\;0.03,\\;p_{-,0}=\\;-0.025)$。\n\n在这些单位制中，所有量均为无量纲。您的程序应为每种情况计算一个三元组：\n$$\n\\left[\\Delta C_{\\max}^{\\text{symp}},\\ \\Delta C_{\\max}^{\\text{RK4}},\\ \\text{symp\\_better}\\right],\n$$\n其中 $\\Delta C_{\\max}^{\\text{symp}}$ 和 $\\Delta C_{\\max}^{\\text{RK4}}$ 是浮点数 (无量纲单位)，$\\text{symp\\_better}$ 是一个布尔值，指示是否 $\\Delta C_{\\max}^{\\text{symp}} \\le \\Delta C_{\\max}^{\\text{RK4}}$。\n\n最终输出格式：您的程序应生成单行输出，包含一个由四个用例结果组成的逗号分隔列表，每个用例结果本身是如上所述的列表，且整个输出用方括号括起来，例如：\n$[\\,[x_{1},y_{1},b_{1}],\\,[x_{2},y_{2},b_{2}],\\,[x_{3},y_{3},b_{3}],\\,[x_{4},y_{4},b_{4}]\\,]$，\n并用实际数值替换。", "solution": "该问题被评估为 **有效**。它在科学上基于广义相对论的 Arnowitt-Deser-Misner (ADM) 形式，具体来说是一个已被充分理解的 Bianchi I 微超空间模型。该问题在数学上是良定的，提供了一套完整的微分方程、初始条件、数值积分参数以及明确、客观的比较指标。术语精确，所要求的任务——比较一个哈密顿系统的辛积分器和非辛积分器——是计算物理学中一个标准的、有意义的练习。没有发现科学或逻辑上的缺陷、歧义或矛盾。\n\n解决方案首先定义系统的动力学，然后详细说明两种所需数值积分器的实现，最后对指定的测试用例执行比较。\n\n设系统的状态由正则坐标 $q = (\\alpha, \\beta_{+}, \\beta_{-})$ 及其共轭动量 $p = (p_{\\alpha}, p_{+}, p_{-})$ 描述。在 $8\\pi G = 1$ 的单位制下，哈密顿约束由下式给出：\n$$\nC(q, p; \\Lambda) = -p_{\\alpha}^{2} + p_{+}^{2} + p_{-}^{2} + \\Lambda e^{6\\alpha}\n$$\n物理轨迹是该约束的水平集，特别是 $C \\approx 0$。在 lapse 函数为 $N=1$ 的规范中，总哈密顿量为 $H = C$。哈密顿方程 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = - \\partial H / \\partial q$ 控制着时间演化：\n\\begin{align*}\n\\dot{\\alpha} = \\frac{\\partial C}{\\partial p_{\\alpha}} = -2p_{\\alpha} \\\\\n\\dot{\\beta}_{+} = \\frac{\\partial C}{\\partial p_{+}} = 2p_{+} \\\\\n\\dot{\\beta}_{-} = \\frac{\\partial C}{\\partial p_{-}} = 2p_{-} \\\\\n\\dot{p}_{\\alpha} = -\\frac{\\partial C}{\\partial \\alpha} = -6\\Lambda e^{6\\alpha} \\\\\n\\dot{p}_{+} = -\\frac{\\partial C}{\\partial \\beta_{+}} = 0 \\\\\n\\dot{p}_{-} = -\\frac{\\partial C}{\\partial \\beta_{-}} = 0\n\\end{align*}\n这些方程定义了需要进行数值积分的常微分方程 (ODE) 系统。通过设置 $p_{\\alpha,0} = \\sqrt{p_{+,0}^{2} + p_{-,0}^{2} + \\Lambda e^{6\\alpha_0}}$ 来完全指定初始状态 $(\\alpha_0, \\beta_{+,0}, \\beta_{-,0}, p_{\\alpha,0}, p_{+,0}, p_{-,0})$，以确保初始状态满足 $C=0$。\n\n任务的核心是实现和比较两种数值积分器。\n\n**1. 辛分裂 (Strang/Stormer-Verlet) 积分器**\n\n此方法利用了哈密顿量的可分离结构，$C(q,p) = T(p) + V(q)$，其中：\n$$\nT(p) = -p_{\\alpha}^{2} + p_{+}^{2} + p_{-}^{2}\n\\qquad\nV(q) = \\Lambda e^{6\\alpha}\n$$\n该积分器是由 $T$ 和 $V$ 生成的精确流的二阶精确组合。从状态 $(q_n, p_n)$ 到 $(q_{n+1}, p_{n+1})$ 的单个时间步长 $\\Delta t$ 通过“踢-漂移-踢”序列执行：\n\n- **步骤 1：半步“踢” (Half Kick)**。在势 $V$ 的作用下，将动量更新半个时间步 $\\Delta t/2$。演化为 $\\dot{p} = -\\nabla_q V$。\n  $$\n  p_{n+1/2} = p_n - \\frac{\\Delta t}{2} \\nabla_q V(q_n)\n  $$\n  由于 $V$ 仅依赖于 $\\alpha$，只有 $p_{\\alpha}$ 发生改变：\n  \\begin{align*}\n  p_{\\alpha, n+1/2} = p_{\\alpha, n} - \\frac{\\Delta t}{2} \\left( 6\\Lambda e^{6\\alpha_n} \\right) \\\\\n  p_{+, n+1/2} = p_{+, n} \\\\\n  p_{-, n+1/2} = p_{-, n}\n  \\end{align*}\n\n- **步骤 2：整步“漂移” (Full Drift)**。在动能项 $T$ 的作用下，使用半更新后的动量，将坐标更新一个完整的时间步 $\\Delta t$。演化为 $\\dot{q} = \\nabla_p T$：\n  $$\n  q_{n+1} = q_n + \\Delta t \\, \\nabla_p T(p_{n+1/2})\n  $$\n  具体而言：\n  \\begin{align*}\n  \\alpha_{n+1} = \\alpha_n + \\Delta t (-2p_{\\alpha, n+1/2}) \\\\\n  \\beta_{+, n+1} = \\beta_{+, n} + \\Delta t (2p_{+, n+1/2}) \\\\\n  \\beta_{-, n+1} = \\beta_{-, n} + \\Delta t (2p_{-, n+1/2})\n  \\end{align*}\n\n- **步骤 3：半步“踢” (Half Kick)**。使用新计算的坐标 $q_{n+1}$，将漂移步骤后的动量再更新半个时间步 $\\Delta t/2$：\n  $$\n  p_{n+1} = p_{n+1/2} - \\frac{\\Delta t}{2} \\nabla_q V(q_{n+1})\n  $$\n  同样，只有 $p_{\\alpha}$ 受到影响：\n  \\begin{align*}\n  p_{\\alpha, n+1} = p_{\\alpha, n+1/2} - \\frac{\\Delta t}{2} \\left( 6\\Lambda e^{6\\alpha_{n+1}} \\right) \\\\\n  p_{+, n+1} = p_{+, n+1/2} = p_{+,n} \\\\\n  p_{-, n+1} = p_{-, n+1/2} = p_{-,n}\n  \\end{align*}\n注意，$p_{+}$ 和 $p_{-}$ 是该系统的运动常数，精确解会保持这一点。辛积分器正确地反映了这一事实，因为它们在更新步骤中保持不变。\n\n**2. 龙格－库塔 4 (RK4) 积分器**\n\n这是一种通用的、非辛的四阶显式积分器。我们定义一个状态向量 $Y = (\\alpha, \\beta_{+}, \\beta_{-}, p_{\\alpha}, p_{+}, p_{-})^T$。ODE 系统写作 $\\dot{Y} = \\vec{f}(Y)$，其中：\n$$\n\\vec{f}(Y) = \\begin{pmatrix} -2p_{\\alpha} \\\\ 2p_{+} \\\\ 2p_{-} \\\\ -6\\Lambda e^{6\\alpha} \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n从 $Y_n$ 到 $Y_{n+1}$ 的单个时间步计算如下：\n\\begin{align*}\n  k_1 = \\vec{f}(Y_n) \\\\\n  k_2 = \\vec{f}(Y_n + \\frac{\\Delta t}{2} k_1) \\\\\n  k_3 = \\vec{f}(Y_n + \\frac{\\Delta t}{2} k_2) \\\\\n  k_4 = \\vec{f}(Y_n + \\Delta t k_3) \\\\\n  Y_{n+1} = Y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n\n**数值实现**\n\n程序结构如下：\n- 函数 `hamiltonian_constraint` 计算给定状态下 $C$ 的值。\n- 函数 `ode_rhs` 计算 RK4 方法的向量 $\\vec{f}(Y)$。\n- 函数 `run_symplectic` 和 `run_rk4` 分别实现各自的积分方案。每个函数接受初始状态和模拟参数，迭代 $N=\\lfloor T/\\Delta t \\rfloor$ 步，并返回哈密顿约束在整个轨迹上的最大绝对漂移 $\\Delta C_{\\max} = \\max_n |C_n - C_0|$。\n- 主函数 `solve` 设置测试用例，为每个用例计算初始状态，调用两种积分器，比较它们产生的 $\\Delta C_{\\max}$，并按要求格式化输出字符串。\n\n预计辛积分器将通过近似守恒哈密顿量 $C$ 来展现出优越的长期稳定性，即使它只是一个二阶方法。RK4 方法尽管阶数更高，但并非为保持此类几何结构而设计，因此在长时间积分中，其 $C$ 值通常会表现出长期漂移。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hamiltonian_constraint(state, Lambda):\n    \"\"\"\n    Computes the Hamiltonian constraint C for a given state.\n    state: numpy array [alpha, beta_p, beta_m, p_alpha, p_p, p_m]\n    Lambda: cosmological constant\n    \"\"\"\n    alpha, _, _, p_alpha, p_p, p_m = state\n    return -p_alpha**2 + p_p**2 + p_m**2 + Lambda * np.exp(6.0 * alpha)\n\ndef ode_rhs(state, Lambda):\n    \"\"\"\n    Computes the right-hand side of Hamilton's equations for the RK4 method.\n    state: numpy array [alpha, beta_p, beta_m, p_alpha, p_p, p_m]\n    Lambda: cosmological constant\n    \"\"\"\n    alpha, _, _, p_alpha, p_p, p_m = state\n    d_alpha = -2.0 * p_alpha\n    d_beta_p = 2.0 * p_p\n    d_beta_m = 2.0 * p_m\n    d_p_alpha = -6.0 * Lambda * np.exp(6.0 * alpha)\n    d_p_p = 0.0\n    d_p_m = 0.0\n    return np.array([d_alpha, d_beta_p, d_beta_m, d_p_alpha, d_p_p, d_p_m])\n\ndef run_symplectic(initial_state, Lambda, T, dt):\n    \"\"\"\n    Integrates the system using the symplectic splitting (Stormer-Verlet) method.\n    Returns the maximum absolute drift of the constraint C.\n    \"\"\"\n    alpha, beta_p, beta_m, p_alpha, p_p, p_m = initial_state\n\n    C0 = hamiltonian_constraint(initial_state, Lambda)\n    max_drift = 0.0\n    \n    num_steps = int(np.floor(T / dt))\n\n    for _ in range(num_steps):\n        # 1. Half kick on momenta (only p_alpha changes)\n        p_alpha_half = p_alpha - (dt / 2.0) * (6.0 * Lambda * np.exp(6.0 * alpha))\n        \n        # 2. Full drift on coordinates\n        alpha_new = alpha + dt * (-2.0 * p_alpha_half)\n        beta_p_new = beta_p + dt * (2.0 * p_p) # p_p is constant\n        beta_m_new = beta_m + dt * (2.0 * p_m) # p_m is constant\n        \n        # 3. Second half kick on momenta\n        p_alpha_new = p_alpha_half - (dt / 2.0) * (6.0 * Lambda * np.exp(6.0 * alpha_new))\n        \n        # Update state variables\n        alpha, beta_p, beta_m = alpha_new, beta_p_new, beta_m_new\n        p_alpha = p_alpha_new\n        \n        current_state = np.array([alpha, beta_p, beta_m, p_alpha, p_p, p_m])\n        Cn = hamiltonian_constraint(current_state, Lambda)\n        drift = np.abs(Cn - C0)\n        if drift > max_drift:\n            max_drift = drift\n            \n    return max_drift\n\ndef run_rk4(initial_state, Lambda, T, dt):\n    \"\"\"\n    Integrates the system using the classical 4th order Runge-Kutta method.\n    Returns the maximum absolute drift of the constraint C.\n    \"\"\"\n    Y = np.copy(initial_state)\n    C0 = hamiltonian_constraint(Y, Lambda)\n    max_drift = 0.0\n    \n    num_steps = int(np.floor(T / dt))\n    \n    for _ in range(num_steps):\n        k1 = ode_rhs(Y, Lambda)\n        k2 = ode_rhs(Y + (dt / 2.0) * k1, Lambda)\n        k3 = ode_rhs(Y + (dt / 2.0) * k2, Lambda)\n        k4 = ode_rhs(Y + dt * k3, Lambda)\n        Y += (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n        \n        Cn = hamiltonian_constraint(Y, Lambda)\n        drift = np.abs(Cn - C0)\n        if drift > max_drift:\n            max_drift = drift\n            \n    return max_drift\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Format: (Lambda, T, dt, alpha0, beta_p0, beta_m0, p_p0, p_m0)\n    test_cases = [\n        (0.0, 100.0, 0.1, 0.0, 0.0, 0.0, 0.01, -0.015),\n        (1e-3, 1000.0, 0.5, 0.2, 0.05, -0.03, 0.02, -0.01),\n        (1e-2, 500.0, 0.5, -0.2, 0.0, 0.0, 0.02, 0.015),\n        (1e-2, 500.0, 1.5, 0.4, 0.0, 0.0, 0.03, -0.025)\n    ]\n\n    results = []\n    for case in test_cases:\n        Lambda, T, dt, a0, bp0, bm0, pp0, pm0 = case\n        \n        # Calculate initial p_alpha to satisfy the constraint C=0\n        pa0_sq = pp0**2 + pm0**2 + Lambda * np.exp(6.0 * a0)\n        pa0 = np.sqrt(pa0_sq)\n        \n        initial_state = np.array([a0, bp0, bm0, pa0, pp0, pm0])\n\n        # Run both integrators\n        delta_C_symp = run_symplectic(initial_state, Lambda, T, dt)\n        delta_C_rk4 = run_rk4(initial_state, Lambda, T, dt)\n        \n        # Compare and store results\n        symp_better = delta_C_symp = delta_C_rk4\n        results.append([delta_C_symp, delta_C_rk4, symp_better])\n\n    # Final print statement in the exact required format.\n    case_strings = []\n    for r in results:\n        # Format: [float,float,bool] without extra spaces and with capitalized booleans\n        case_strings.append(f\"[{r[0]},{r[1]},{str(r[2])}]\")\n    print(f\"[{','.join(case_strings)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3489062"}]}