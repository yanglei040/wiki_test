{"hands_on_practices": [{"introduction": "瓦伦西亚表述演化一组“守恒”变量（$D, S_i, \\tau$），因为它们在数值格式中具有理想的性质。然而，流体的物理状态由“原始”变量（$\\rho, v, p$）描述，计算状态方程和通量时也需要这些变量。本练习 [@problem_id:3496824] 聚焦于关键的“从守恒量到原始量”的恢复步骤，要求您实现并评估两种用于求解该非线性系统的稳健数值算法，这是任何基于瓦伦西亚表述的流体动力学代码的核心任务。", "problem": "考虑在狭义相对论极限下的瓦伦西亚表述中的广义相对论流体动力学（GRHD）系统，该系统具有闵可夫斯基度规、单位递减函数、零移位矢量和笛卡尔空间度规。在几何化单位制下进行计算，其中光速为1。在一维空间中，瓦伦西亚守恒变量由以下基本关系从原始变量定义：静止质量密度 $\\,\\rho\\,$，流体三维速度 $\\,v\\,$，压力 $\\,p\\,$，比内能 $\\,\\epsilon\\,$，洛伦兹因子 $\\,W = 1/\\sqrt{1 - v^2}\\,$，以及比焓 $\\,h = 1 + \\epsilon + p/\\rho\\,$。守恒变量为 $\\,D = \\rho W\\,$，$\\,S = \\rho h W^2 v\\,$，以及 $\\,\\tau = \\rho h W^2 - p - D\\,$。假设采用伽马律状态方程（EOS），$\\,p = (\\Gamma - 1)\\rho \\epsilon\\,$，这意味着 $\\,h = 1 + \\Gamma p / \\big((\\Gamma - 1)\\rho\\big)\\,$，其中绝热指数 $\\,\\Gamma\\,$ 为常数。\n\n您的任务是根据这些基本关系，实现两种不同的原始变量恢复算法：\n\n- 方法 A（直接求解比焓 $\\,h\\,$）：直接求解 $\\,h\\,$ 作为主要未知数，通过守恒变量代数消去洛伦兹因子 $\\,W\\,$，然后根据状态方程（EOS）一致地恢复 $\\,v\\,$、$\\,\\rho\\,$ 和 $\\,p\\,$。该构建过程必须严格从上述基本定义推导得出。\n\n- 方法 B（直接求解压力 $\\,p\\,$）：仅使用基本定义，求解 $\\,p\\,$ 作为主要未知数，从守恒变量关系中获取 $\\,v\\,$，然后通过状态方程（EOS）恢复 $\\,W\\,$、$\\,\\rho\\,$ 和 $\\,h\\,$。\n\n对于这两种方法，您的算法必须能够稳健地处理具有大 $\\,W\\,$ 值的超相对论性情况。数值求解器必须强制执行物理上的可采纳性，即 $\\,p \\ge 0\\,$，$\\,\\rho \\ge 0\\,$ 和 $|v|  1$。\n\n构建一个基准测试套件，代表撞击中子星壳的超相对论性喷流和一个硬物质边缘案例。对于每个测试，首先使用基本定义从给定的原始变量构建内部一致的守恒变量，然后使用两种方法执行原始变量恢复。使用以下测试：\n\n- 测试 $\\,1\\,$（超相对论性喷流，辐射类气体）：$\\,\\Gamma = 4/3\\,$，$\\,\\rho = 10^{-4}\\,$，$\\,v = 0.999\\,$，$\\,p = 10^{-2}\\,$。\n- 测试 $\\,2\\,$（极端的超相对论性喷流）：$\\,\\Gamma = 4/3\\,$，$\\,\\rho = 5 \\times 10^{-5}\\,$，$\\,v = 0.999999\\,$，$\\,p = 2\\times 10^{-2}\\,$。\n- 测试 $\\,3\\,$（硬壳状物质）：$\\,\\Gamma = 2\\,$，$\\,\\rho = 10^{-1}\\,$，$\\,v = 10^{-1}\\,$，$\\,p = 10^{-3}\\,$。\n\n对于每个测试，使用以下度量标准计算两种方法在一组恢复的原始变量 $\\{\\rho, v, p, h\\}$ 上的最大相对差异\n$$\n\\Delta_{\\max} \\equiv \\max_{x \\in \\{\\rho, v, p, h\\}} \\frac{|x_A - x_B|}{\\max(|x_A|, |x_B|, 10^{-14})},\n$$\n其中下标 $\\,A\\,$ 指方法 A，下标 $\\,B\\,$ 指方法 B。\n\n所有量在几何化单位制下均为无量纲。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $\\,\\big[\\Delta_1,\\Delta_2,\\Delta_3\\big]\\,$，其中 $\\,\\Delta_i\\,$ 是测试 $\\,i\\,$ 的 $\\,\\Delta_{\\max}\\,$ 值。输出必须是且仅是 $\\,\\big[\\Delta_1,\\Delta_2,\\Delta_3\\big]\\,$ 格式的单行文本。不应打印任何其他文本。", "solution": "用户希望解决一个相对论流体动力学问题，具体关注瓦伦西亚表述中从守恒变量到原始变量的转换。这是演化广义相对论流体动力学（GRHD）方程的数值代码中的关键步骤。该问题设定在平直时空背景下的狭义相对论简化情境中。\n\n### 问题验证\n\n首先，对问题陈述进行细致的验证。\n\n**步骤 1：提取已知条件**\n- **系统**：在狭义相对论（SR）极限下的瓦伦西亚表述中的广义相对论流体动力学（GRHD）。\n- **时空**：闵可夫斯基度规（$\\eta_{\\mu\\nu}$），单位递减函数（$\\alpha=1$），零移位矢量（$\\beta^i=0$），以及笛卡尔空间度规（$\\gamma_{ij}=\\delta_{ij}$）。\n- **单位**：几何化单位制，其中光速 $c=1$。\n- **原始变量**：静止质量密度 $\\rho$，流体三维速度 $v$，以及压力 $p$。\n- **辅助变量**：洛伦兹因子 $W = 1/\\sqrt{1 - v^2}$，比内能 $\\epsilon$，以及比焓 $h = 1 + \\epsilon + p/\\rho$。\n- **守恒变量**：\n  - $D = \\rho W$ （守恒静止质量密度）\n  - $S = \\rho h W^2 v$ （守恒动量密度）\n  - $\\tau = \\rho h W^2 - p - D$ （守恒总能量密度减去静止质量密度）\n- **状态方程（EOS）**：伽马律，$p = (\\Gamma - 1)\\rho \\epsilon$，这意味着关系 $h = 1 + \\frac{\\Gamma p}{(\\Gamma - 1)\\rho}$。\n- **任务**：实现两种不同的恢复算法：\n  - **方法 A**：求解比焓 $h$ 作为主要未知数。\n  - **方法 B**：求解压力 $p$ 作为主要未知数。\n- **物理可采纳性**：解必须满足 $\\rho \\ge 0$，$p \\ge 0$ 和 $|v|  1$。\n- **基准测试**：\n  - 测试 1：$\\Gamma = 4/3, \\rho = 10^{-4}, v = 0.999, p = 10^{-2}$。\n  - 测试 2：$\\Gamma = 4/3, \\rho = 5 \\times 10^{-5}, v = 0.999999, p = 2\\times 10^{-2}$。\n  - 测试 3：$\\Gamma = 2, \\rho = 10^{-1}, v = 10^{-1}, p = 10^{-3}$。\n- **误差度量**：计算方法 A ($x_A$) 和方法 B ($x_B$) 结果之间的最大相对差异：\n  $$ \\Delta_{\\max} \\equiv \\max_{x \\in \\{\\rho, v, p, h\\}} \\frac{|x_A - x_B|}{\\max(|x_A|, |x_B|, 10^{-14})} $$\n- **输出**：一行，包含一个用方括号括起来的三个 $\\Delta_{\\max}$ 值的逗号分隔列表。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估。\n- **科学基础**：该问题是计算相对论天体物理学的核心，并基于标准且成熟的 SRHD 瓦伦西亚表述。所有定义和伽马律状态方程都是该领域的标准。\n- **适定性**：已知对于伽马律状态方程，将守恒变量与原始变量联系起来的方程组具有唯一的物理可行解。该问题要求实现两种标准的数值方法来找到这个解。\n- **客观性**：问题以精确的数学术语陈述，没有主观或模糊的语言。\n- **结论**：该问题在科学上是合理的、适定的、完整的并且可以形式化。没有矛盾、事实错误或不可行的要求。\n\n**步骤 3：判定与行动**\n该问题是**有效的**。将着手开发解决方案。\n\n### 恢复算法的推导\n\n任务的核心是为原始变量恢复推导并实现两个单变量求根问题。\n\n**方法 A：求解比焓 ($h$)**\n\n目标是仅使用守恒变量 $D, S, \\tau$ 和常数 $\\Gamma$ 找到一个关于 $h$ 的方程。\n\n1.  从 $D$ 和 $S$ 的定义中，我们可以用 $h$ 和 $W$ 来表示速度 $v$：\n    $$ \\frac{S}{D} = \\frac{\\rho h W^2 v}{\\rho W} = h W v \\implies v = \\frac{S}{D h W} $$\n2.  将此代入洛伦兹因子定义 $W^{-2} = 1 - v^2$：\n    $$ W^{-2} = 1 - \\frac{S^2}{D^2 h^2 W^2} \\implies 1 = W^2 - \\frac{S^2}{D^2 h^2} $$\n    这得到了 $W$ 和 $h$ 之间的一个关键关系：\n    $$ W^2 = 1 + \\frac{S^2}{D^2 h^2} $$\n3.  接下来，使用 $\\tau$ 的定义。为了消去 $p$，我们使用状态方程关系 $h-1 = \\frac{\\Gamma p}{(\\Gamma-1)\\rho}$，这给出 $p = \\frac{(\\Gamma-1)\\rho(h-1)}{\\Gamma}$。\n    $$ \\tau = \\rho h W^2 - p - D = \\rho h W^2 - \\frac{(\\Gamma-1)\\rho(h-1)}{\\Gamma} - D $$\n4.  代入 $\\rho = D/W$：\n    $$ \\tau = \\frac{D}{W} h W^2 - \\frac{(\\Gamma-1)D(h-1)}{\\Gamma W} - D = D h W - \\frac{D(\\Gamma-1)(h-1)}{\\Gamma W} - D $$\n5.  重新整理方程：\n    $$ \\frac{\\tau+D}{D} = h W - \\frac{(\\Gamma-1)(h-1)}{\\Gamma W} $$\n6.  两边乘以 $W$ 以消除分母，并代入步骤 2 中 $W^2$ 的表达式：\n    $$ \\frac{(\\tau+D)W}{D} = h W^2 - \\frac{\\Gamma-1}{\\Gamma}(h-1) = h \\left(1 + \\frac{S^2}{D^2 h^2}\\right) - \\frac{\\Gamma-1}{\\Gamma}(h-1) $$\n    $$ \\frac{(\\tau+D)W}{D} = h + \\frac{S^2}{D^2 h} - \\frac{\\Gamma-1}{\\Gamma}(h-1) $$\n7.  为了消去左侧剩余的 $W$，我们将两边平方并再次代入 $W^2$：\n    $$ \\frac{(\\tau+D)^2}{D^2} W^2 = \\left( h + \\frac{S^2}{D^2 h} - \\frac{\\Gamma-1}{\\Gamma}(h-1) \\right)^2 $$\n    $$ \\frac{(\\tau+D)^2}{D^2} \\left(1 + \\frac{S^2}{D^2 h^2}\\right) = \\left( \\frac{h}{\\Gamma} + \\frac{S^2}{D^2 h} + \\frac{\\Gamma-1}{\\Gamma} \\right)^2 $$\n8.  这产生了一个非线性代数方程 $f(h)=0$。令 $j^2=(S/D)^2$ 和 $Y=(\\tau+D)/D$。该方程为：\n    $$ f(h) = \\left( \\frac{h}{\\Gamma} + \\frac{j^2}{h} + \\frac{\\Gamma-1}{\\Gamma} \\right)^2 - Y^2\\left(1 + \\frac{j^2}{h^2}\\right) = 0 $$\n    可以使用数值求根器求解此方程以获得 $h \\ge 1$。一旦找到 $h$，其他原始变量可以恢复为：$W = \\sqrt{1+j^2/h^2}$，$\\rho=D/W$，$v=S/(DhW)$，以及 $p=\\rho(h-1)(\\Gamma-1)/\\Gamma$。\n\n**方法 B：求解压力 ($p$)**\n\n目标是找到一个关于 $p$ 的方程。\n\n1.  通过组合 $S$ 和 $\\tau$ 的定义，可以找到 $v$ 的一个关键关系：\n    $$ \\tau+p+D = \\rho h W^2 \\implies S = (\\tau+p+D)v \\implies v = \\frac{S}{\\tau+p+D} $$\n2.  由此，我们用 $p$ 来表示 $W$ 和 $W^2$：\n    $$ W = \\frac{1}{\\sqrt{1-v^2}} = \\frac{\\tau+p+D}{\\sqrt{(\\tau+p+D)^2 - S^2}} $$\n    $$ W^2 = \\frac{(\\tau+p+D)^2}{(\\tau+p+D)^2 - S^2} $$\n3.  我们从方法 A 的步骤 4 中推导出的关系开始，但这次我们消去 $\\rho$ 和 $h$：\n    $$ (\\tau+D) = D h W - \\frac{\\Gamma-1}{\\Gamma}\\frac{D(h-1)}{W} $$\n    方程 $\\rho h W^2 = \\tau+p+D$ 更直接。使用 $h = 1 + \\frac{\\Gamma p}{(\\Gamma-1)\\rho}$：\n    $$ \\rho \\left(1 + \\frac{\\Gamma p}{(\\Gamma-1)\\rho}\\right) W^2 = \\tau+p+D \\implies \\left(\\rho + \\frac{\\Gamma p}{\\Gamma-1}\\right)W^2 = \\tau+p+D $$\n4.  代入 $\\rho=D/W$：\n    $$ \\left(\\frac{D}{W} + \\frac{\\Gamma p}{\\Gamma-1}\\right)W^2 = \\tau+p+D \\implies D W + \\frac{\\Gamma p}{\\Gamma-1} W^2 = \\tau+p+D $$\n5.  令 $A = \\tau+D$。方程变为：$DW + \\frac{\\Gamma p}{\\Gamma-1}W^2 = A+p$。现在，我们代入步骤 2 中 $W$ 和 $W^2$ 的表达式：\n    $$ D \\frac{A+p}{\\sqrt{(A+p)^2-S^2}} + \\frac{\\Gamma p}{\\Gamma-1} \\frac{(A+p)^2}{(A+p)^2-S^2} = A+p $$\n    对于任何物理速度 $|v|1$，我们有 $(A+p)^2 > S^2$，因此我们可以除以一个因子 $(A+p)$（对于非平凡的 $p$, $A$）。或者更直接地，重新整理成一个求根问题 $f(p)=0$：\n    $$ f(p) = (A+p)^2 - S^2 - \\frac{\\Gamma p(A+p)}{\\Gamma-1} - D\\sqrt{(A+p)^2 - S^2} = 0 $$\n    可以使用数值求根器求解此方程以获得 $p \\ge 0$（且 $A+p>|S|$）。一旦已知 $p$，其他原始变量为：$v=S/(A+p)$，$W=1/\\sqrt{1-v^2}$，$\\rho=D/W$，以及 $h=1+\\Gamma p/((\\Gamma-1)\\rho)$。\n\n### 实现策略\n\n- 需要一个数值求根算法。`scipy.optimize.root_scalar` 函数与 Brent 方法（`brentq`）是一个稳健的选择，前提是可以确定一个根的包围区间 $[a, b]$（其中 $f(a)$ 和 $f(b)$ 符号相反）。\n- 对于方法 A（$h$ 求解器），物理域为 $h \\in [1, \\infty)$。我们可以证明 $f_h(1) \\le 0$ 且当 $h \\to \\infty$ 时 $f_h(h) > 0$，因此像 $[1, 10^{12}]$ 这样的区间是安全的。\n- 对于方法 B（$p$ 求解器），物理域要求 $p \\ge 0$ 且 $\\tau+D+p > |S|$。因此最小压力为 $p_{\\min} = \\max(0, |S|-(\\tau+D))$。我们可以证明 $f_p(p_{\\min}) \\ge 0$ 且当 $p \\to \\infty$ 时 $f_p(p)  0$。因此，像 $[p_{\\min}+\\epsilon, \\tau+D+|S|]$ 这样的区间是合适的。\n- 两种方法都将被实现，对于每个测试用例，首先从给定的原始变量计算守恒变量。然后，应用两种恢复方法，并计算它们输出之间的最大相对差异。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef compute_conserved_variables(gamma, rho, v, p):\n    \"\"\"\n    Computes conserved variables (D, S, tau) from given primitive variables.\n    All quantities are dimensionless in geometrized units (c=1).\n    \"\"\"\n    if rho  0 or p  0 or abs(v) >= 1:\n        raise ValueError(\"Invalid primitive variables: non-physical values.\")\n    \n    # Handle the rho=0 case explicitly to avoid division by zero.\n    if rho == 0.0:\n        return 0.0, 0.0, 0.0\n    \n    W = 1.0 / np.sqrt(1.0 - v**2)\n    epsilon = p / ((gamma - 1.0) * rho)\n    h = 1.0 + epsilon + p / rho\n    \n    D = rho * W\n    S = rho * h * W**2 * v\n    # This definition of tau is standard\n    tau = rho * h * W**2 - p - D\n    \n    return D, S, tau\n\ndef recover_primitives_A(D, S, tau, gamma):\n    \"\"\"\n    Recovers primitive variables using Method A (solving for specific enthalpy h).\n    \"\"\"\n    # Handle the vacuum case where D is numerically zero.\n    if D  1e-16:\n        return 0.0, 0.0, 0.0, 1.0\n\n    j_sq = (S / D)**2\n    Y = (tau + D) / D\n\n    def f_h(h):\n        # The equation f(h)=0 to be solved.\n        # Derived from the Valencia SRHD equations and gamma-law EOS.\n        if h  1.0:\n            # Physical domain for specific enthalpy is h >= 1.\n            h = 1.0\n        \n        term1 = h / gamma + j_sq / h + (gamma - 1.0) / gamma\n        term2 = Y**2 * (1.0 + j_sq / h**2)\n        return term1**2 - term2\n    \n    # Find the root for h. Based on analysis, the root is bracketed.\n    # f(1) = 0 and f(h->inf) > 0.\n    h_min_bracket = 1.0\n    h_max_bracket = 1e12  # A sufficiently large number.\n    \n    try:\n        sol = root_scalar(f_h, bracket=[h_min_bracket, h_max_bracket], method='brentq')\n        h = sol.root\n    except ValueError:\n        return np.nan, np.nan, np.nan, np.nan\n\n    # Recover other primitives from h\n    W_sq = 1.0 + j_sq / h**2\n    W = np.sqrt(W_sq)\n    v = S / (D * h * W)\n    rho = D / W\n    p = rho * (h - 1.0) * (gamma - 1.0) / gamma\n\n    return rho, v, p, h\n\n\ndef recover_primitives_B(D, S, tau, gamma):\n    \"\"\"\n    Recovers primitive variables using Method B (solving for pressure p).\n    \"\"\"\n    # Handle the vacuum case.\n    if D  1e-16:\n        return 0.0, 0.0, 0.0, 1.0\n        \n    A = tau + D\n    S_sq = S**2\n\n    # Physicality requires (A+p)^2 > S^2 and p >= 0.\n    p_min = max(0.0, abs(S) - A)\n    \n    def f_p(p):\n        # The equation f(p)=0 to be solved.\n        if p  p_min:\n            p = p_min\n        \n        Ap = A + p\n        X = Ap**2 - S_sq\n\n        # This should not be triggered if p is in the valid domain.\n        if X  0.0:\n            return np.inf  # Return a large number to guide solver\n            \n        sqrt_X = np.sqrt(X)\n        \n        # f(p) = (A+p)^2 - S^2 - (gamma*p*(A+p))/(gamma-1) - D*sqrt((A+p)^2-S^2) = 0\n        # The original derivation had a sign error in the D term. It should be:\n        # DW + Gamma p / (Gamma - 1) W^2 = A+p\n        # D(A+p)/sqrt(X) + Gamma p / (Gamma-1) (A+p)^2/X = A+p\n        # D(A+p)sqrt(X) + Gamma p / (Gamma-1) (A+p)^2 = (A+p)X\n        # D sqrt(X) + Gamma p / (Gamma-1) (A+p) = X\n        # f(p) = X - Gamma p / (Gamma-1) * Ap - D * sqrt_X\n        term1 = X\n        term2 = (gamma * p * Ap) / (gamma - 1.0)\n        term3 = D * sqrt_X\n        \n        return term1 - term2 - term3\n\n    # Find the root for p. Analysis shows f(p_min) >= 0 and f(p->inf)  0.\n    # Add a small epsilon to the lower bound for safety with the solver.\n    p_min_bracket = p_min * (1.0 + 1e-10) + 1e-14\n    # Heuristic but safely large upper bound.\n    p_max_bracket = tau + D + abs(S)\n    \n    try:\n        sol = root_scalar(f_p, bracket=[p_min_bracket, p_max_bracket], method='brentq')\n        p = sol.root\n    except ValueError:\n        return np.nan, np.nan, np.nan, np.nan\n\n    # Recover other primitives from p\n    v = S / (A + p)\n    W = 1.0 / np.sqrt(1.0 - v**2)\n    rho = D / W\n    \n    if rho > 1e-16:\n        h = 1.0 + p * gamma / ((gamma - 1.0) * rho)\n    else:\n        h = 1.0\n\n    return rho, v, p, h\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        # Test 1 (ultra-relativistic jet, radiation-like gas)\n        {\"gamma\": 4.0/3.0, \"rho\": 1e-4, \"v\": 0.999, \"p\": 1e-2},\n        # Test 2 (extremely ultra-relativistic jet)\n        {\"gamma\": 4.0/3.0, \"rho\": 5e-5, \"v\": 0.999999, \"p\": 2e-2},\n        # Test 3 (stiff crust-like matter)\n        {\"gamma\": 2.0, \"rho\": 1e-1, \"v\": 1e-1, \"p\": 1e-3},\n    ]\n\n    delta_max_results = []\n    \n    for case in test_cases:\n        # 1. Compute conserved variables from the initial primitives.\n        D, S, tau = compute_conserved_variables(case[\"gamma\"], case[\"rho\"], case[\"v\"], case[\"p\"])\n        \n        # 2. Recover primitives using both methods.\n        prims_A = recover_primitives_A(D, S, tau, case[\"gamma\"])\n        prims_B = recover_primitives_B(D, S, tau, case[\"gamma\"])\n        \n        # Unpack for comparison\n        rho_A, v_A, p_A, h_A = prims_A\n        rho_B, v_B, p_B, h_B = prims_B\n        \n        primitives_set_A = {'rho': rho_A, 'v': v_A, 'p': p_A, 'h': h_A}\n        primitives_set_B = {'rho': rho_B, 'v': v_B, 'p': p_B, 'h': h_B}\n\n        # 3. Compute the maximum relative difference.\n        max_rel_diff = 0.0\n        floor = 1e-14\n        \n        for key in primitives_set_A.keys():\n            xA = primitives_set_A[key]\n            xB = primitives_set_B[key]\n            \n            diff = abs(xA - xB)\n            # Use a floor in the denominator for robustness against small numbers\n            norm = max(abs(xA), abs(xB), floor)\n            rel_diff = diff / norm\n            \n            if rel_diff > max_rel_diff:\n                max_rel_diff = rel_diff\n        \n        delta_max_results.append(max_rel_diff)\n\n    # 4. Print the final results in the specified format. The default string representation\n    # of a float will be used.\n    print(f\"[{','.join(map(str, delta_max_results))}]\")\n\n# Execute the solution\nsolve()\n\n```", "id": "3496824"}, {"introduction": "有限体积法需要单元交界面的变量值来计算通量，但我们只知道单元的平均值。简单地内插这些值可能会导致伪振荡和数值不稳定性，尤其是在天体物理学中常见的激波附近。本练习 [@problem_id:3496822] 将指导您实现并比较两种先进的“重构”格式——强制总变差递减（TVD）的MUSCL格式和高阶的WENO格式。这些格式旨在平滑区域实现高精度，同时在间断处防止振荡。", "problem": "考虑在相对论流体动力学的瓦伦西亚（Valencia）公式中，用于一维空间双曲守恒律的形式，其中守恒场需要在单元面上通过重构的原始场计算通量。在实践中，数值相对论和引力波模拟从单元中心的估计值重构原始变量（如静止质量密度），以得到界面处的左右状态。本问题的目标是设计并实现两种高分辨率无振荡重构格式，并使用精心选择的、能反映瓦伦西亚公式需求的测试来评估它们的无振荡行为和准确性。\n\n从以下基本基础开始：\n- 一个标量场 $q(x)$ 代表一个原始变量，在均匀网格上通过单元中心 $x_i$ 处的值 $q_i$ 进行近似，其中 $x_i = i \\Delta x$ 且 $\\Delta x = L/N$，$L$ 为域长度，$N$ 为单元数。施加周期性边界条件，使得对所有整数 $i$ 都有 $q_{i+N} = q_i$。\n- 在有限体积法中，界面 $x_{i+1/2} = x_i + \\Delta x/2$ 处的左右重构状态 $(q_{i+1/2}^{L}, q_{i+1/2}^{R})$ 被提供给一个黎曼求解器以获得数值通量。在瓦伦西亚公式中，适定的数值流体动力学要求重构在光滑区域是高阶精确的，在间断附近是无振荡的。\n- 无振荡行为通过控制总变分来评估，对于网格函数，总变分定义为 $\\mathrm{TV}(q) = \\sum_{i} |q_{i+1} - q_i|$；并通过测量相对于局部界的、间断附近的类吉布斯过冲是否存在来评估。\n\n您的任务是实现两种重构格式，并对四个测试案例计算定量诊断指标：\n1. 一种带有单调中心（MC）限制器的守恒律单调上游中心格式（MUSCL）。这是一种总变分递减（TVD）格式。您必须确保重构状态服从局部离散极值原理，将重构的界面值投影到局部邻居界限内，使得 $q_{i+1/2}^{L} \\in [\\min(q_{i-1}, q_i, q_{i+1}), \\max(q_{i-1}, q_i, q_{i+1})]$ 并且 $q_{i+1/2}^{R}$ 服从使用 $q_{i+1}$ 邻居的类似界限。\n2. 一种五阶加权基本无振荡格式（WENO5），其 WENO-Z 权重由光滑度指示器构建。该格式应使权重适应模板的光滑度，并在光滑数据上实现高阶精度，而无需显式限制。\n\n实现要求：\n- 网格在 $[0,1]$ 上是均匀的，具有周期性边界，单元中心为 $x_i = (i+0.5)\\Delta x$，其中 $i = 0, 1, \\dots, N-1$，且 $\\Delta x = 1/N$。\n- 对于每个界面 $i+1/2$，从单元中心值 $q_i$ 重构 $q_{i+1/2}^{L}$ 和 $q_{i+1/2}^{R}$。\n- 对于 MUSCL 格式，使用三参数 minmod 操作实现单调中心限制器，以在每个单元获得一个斜率，然后如上所述将重构状态投影到局部界限内。\n- 对于 WENO5-Z 格式，实现依赖于光滑度指示器和全局光滑度度量的非线性权重，并在每个面上重构左右界面状态。\n\n需要计算的诊断指标：\n- 对于光滑函数测试，在 $[0,1]$ 上定义 $q(x) = \\sin(2\\pi x)$。使用 $N = 200$，计算每种格式左状态的最大范数重构误差为 $E_{\\infty} = \\max_i |q_{i+1/2}^{L} - q(x_{i+1/2})|$。将这两个误差报告为浮点数。\n- 对于间断（类激波管）测试，定义 $q(x) = 1$（当 $x  0.5$）和 $q(x) = 0$（其他情况），使用 $N = 200$。计算每种格式左重构状态的过冲幅度为 $O = \\max\\left(\\max_i \\max(q_{i+1/2}^{L} - 1, 0), \\max_i \\max(-q_{i+1/2}^{L}, 0)\\right)$，并将这两个过冲幅度报告为浮点数。\n- 对于常数状态测试，定义 $q(x) = 0.7$，使用 $N = 200$。计算 WENO5-Z 左重构状态与常数值的绝对偏差之和 $R = \\sum_i |q_{i+1/2}^{L} - 0.7|$，并将 $R$ 报告为浮点数。\n- 对于近真空光滑测试，定义 $q(x) = 10^{-12} + 10^{-13}\\sin(2\\pi x)$，使用 $N = 200$。检查每种格式所有重构的左右状态的正定性：报告两个布尔值，分别指示带有局部界限投影的 MUSCL 和没有显式正定性强制的 WENO5-Z 的所有重构状态是否为非负。\n\n单位和数据类型：\n- 所有报告的数值都是无单位的浮点数或布尔值。三角函数中使用的角度以弧度为单位。\n- 最终输出应为单行，包含一个用方括号括起来的逗号分隔列表，其中包含按以下顺序排列的七个结果：光滑案例 WENO5-Z 误差（浮点数）、光滑案例 MUSCL 误差（浮点数）、阶跃案例 WENO5-Z 过冲（浮点数）、阶跃案例 MUSCL 过冲（浮点数）、常数案例 WENO5-Z 残差（浮点数）、近真空 MUSCL 正定性（布尔值）、近真空 WENO5-Z 正定性（布尔值）。\n\n测试套件规范：\n- 光滑案例：$N = 200$，$q(x) = \\sin(2\\pi x)$，按所述报告两个浮点数。\n- 间断案例：$N = 200$，$q(x) = 1$（当 $x  0.5$），$q(x) = 0$（其他情况），按所述报告两个浮点数。\n- 常数案例：$N = 200$，$q(x) = 0.7$，按所述报告一个浮点数。\n- 近真空案例：$N = 200$，$q(x) = 10^{-12} + 10^{-13}\\sin(2\\pi x)$，按所述报告两个布尔值。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5,result6,result7]”）。不应打印其他任何文本。", "solution": "用户提供的问题被评估为有效，因为它在科学上是合理的、适定的、客观的且自包含的。它描述了计算物理学中的一个标准验证任务，特别是针对相对论流体动力学中使用的数值格式。该问题要求实现和评估两种成熟的数值重构方法——带有 MC 限制器的 MUSCL 和 WENO5-Z——并用一系列基准测试来检验它们。所有的定义、参数和诊断指标都得到了清晰明确的规定。\n\n解决方案首先实现两种所需的重构格式：\n1.  实现了守恒律单调上游中心格式（MUSCL）。该格式在光滑区域达到二阶精度。为了控制间断附近的振荡，需要一个斜率限制器。按照规定，使用了单调中心（MC）限制器。每个单元 $i$ 的斜率 $\\delta q_i$ 通过对中心差分斜率和两倍的单边差分斜率应用 `minmod` 函数来计算：\n    $$\n    \\delta q_i = \\mathrm{minmod}\\left(\\frac{q_{i+1} - q_{i-1}}{2}, 2(q_{i+1} - q_i), 2(q_i - q_{i-1})\\right)\n    $$\n    如果所有参数符号相同，`minmod` 函数返回绝对值最小的参数；否则返回 $0$。然后，界面 $x_{i+1/2}$ 处的左右重构状态计算如下：\n    $$\n    q_{i+1/2}^{L, \\text{raw}} = q_i + \\frac{1}{2}\\delta q_i \\\\\n    q_{i+1/2}^{R, \\text{raw}} = q_{i+1} - \\frac{1}{2}\\delta q_{i+1}\n    $$\n    问题要求的一个关键步骤是强制执行局部离散极值原理。计算出的原始状态被投影到由局部相邻单元值定义的区间内。对于 $q_{i+1/2}^{L}$，这是：\n    $$\n    q_{i+1/2}^{L} = \\max\\left( \\min(q_{i-1}, q_i, q_{i+1}), \\min(\\max(q_{i-1}, q_i, q_{i+1}), q_{i+1/2}^{L, \\text{raw}}) \\right)\n    $$\n    使用单元 $i+1$ 的邻居（即 $q_i, q_{i+1}, q_{i+2}$）对 $q_{i+1/2}^{R}$ 应用类似的投影。此过程确保了格式的无振荡性。\n\n2.  实现了五阶加权基本无振荡（WENO5）格式，特别是带有 WENO-Z 权重。该格式通过组合三个基于三个不同 3-单元模板的三阶重构 $\\hat{q}^{(k)}$ 来实现高阶精度。组合是一个加权平均值，$q_{i+1/2} = \\sum_{k=0}^2 \\omega_k \\hat{q}^{(k)}$。WENO 的关键思想是权重 $\\omega_k$ 依赖于每个模板的光滑度指示器 $\\beta_k$。标准的 WENO 权重为 $\\omega_k \\propto d_k/(\\beta_k + \\epsilon)^2$，其中 $d_k$ 是在光滑区域产生五阶精度的最优权重，$\\epsilon$ 是一个防止除以零的小数。问题指定了 WENO-Z 权重，这是一种为提高临界点附近精度而设计的修改。Z-权重由下式给出：\n    $$\n    \\alpha_k^Z = d_k \\left(1 + \\left(\\frac{\\tau_5}{\\beta_k + \\epsilon}\\right)^p\\right), \\quad \\omega_k^Z = \\frac{\\alpha_k^Z}{\\sum_j \\alpha_j^Z}\n    $$\n    其中 $\\tau_5 = |\\beta_0 - \\beta_2|$ 是一个全局光滑度度量，$p=1$ 是一个典型选择。左状态 $q_{i+1/2}^{L}$ 使用以单元 $i$ 为中心的模板进行重构，而右状态 $q_{i+1/2}^{R}$ 使用以单元 $i+1$ 为中心的模板进行重构。\n\n在实现这两种格式之后，在域 $[0,1]$ 上使用 $N=200$ 个单元和周期性边界的网格上执行了四个指定的诊断测试。\n-   **光滑测试**：$q(x) = \\sin(2\\pi x)$。对两种格式计算最大范数误差 $E_{\\infty} = \\max_i |q_{i+1/2}^{L} - q(x_{i+1/2})|$。\n-   **间断测试**：$q(x) = 1$（当 $x  0.5$）和 $q(x) = 0$（其他情况）。对两种格式计算过冲幅度 $O$，以量化无振荡性能。\n-   **常数状态测试**：$q(x) = 0.7$。对于 WENO5-Z 格式，计算与常数的绝对偏差之和 $R = \\sum_i |q_{i+1/2}^{L} - 0.7|$，以验证其保持常数状态的能力。\n-   **近真空测试**：$q(x) = 10^{-12} + 10^{-13}\\sin(2\\pi x)$。对两种格式检查所有重构状态（$q^L$ 和 $q^R$）的正定性。带有局部界限投影的 MUSCL 格式有望保持正定性，而标准的 WENO5-Z 格式则不保证如此。\n\n所有计算均使用向量化的 `numpy` 操作以提高效率。收集结果并将其格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements MUSCL and WENO5-Z reconstruction schemes, runs four test cases,\n    and computes the specified diagnostics.\n    \"\"\"\n    # Grid and problem parameters\n    N = 200\n    DX = 1.0 / N\n    X_CELLS = (np.arange(N) + 0.5) * DX\n    X_FACES = (np.arange(N) + 1.0) * DX\n\n    def vectorized_minmod(data_list):\n        \"\"\"\n        Vectorized minmod function for multiple arguments.\n        \"\"\"\n        matrix = np.array(data_list)\n        s = np.sign(matrix)\n        # Check if all elements in a column have the same sign.\n        # This is true if the absolute value of the sum of signs equals the number of arguments.\n        all_same_sign = np.abs(np.sum(s, axis=0)) == len(data_list)\n        # The sign of the result is the sign of the arguments, or 0 if they differ.\n        signs = np.sign(np.sum(s, axis=0)) * all_same_sign\n        mags = np.min(np.abs(matrix), axis=0)\n        return signs * mags\n    \n    def muscl_reconstruction(q):\n        \"\"\"\n        MUSCL reconstruction with MC limiter and local bound projection.\n        \"\"\"\n        q_pad = np.pad(q, (2, 2), 'wrap')\n\n        # Slices for vectorized computation\n        q_im2 = q_pad[0:-4]\n        q_im1 = q_pad[1:-3]\n        q_i   = q_pad[2:-2]\n        q_ip1 = q_pad[3:-1]\n        q_ip2 = q_pad[4:]\n\n        # Compute slopes with Monotonized Central (MC) limiter\n        delta_plus = q_ip1 - q_i\n        delta_minus = q_i - q_im1\n        delta_central = (q_ip1 - q_im1) / 2.0\n        \n        limited_slopes = vectorized_minmod([delta_central, 2.0 * delta_plus, 2.0 * delta_minus])\n        \n        # Raw reconstruction\n        qL_raw = q_i + 0.5 * limited_slopes\n        slopes_ip1 = np.roll(limited_slopes, -1)\n        qR_raw = q_ip1 - 0.5 * slopes_ip1\n        \n        # Projection to local bounds\n        min_bound_L = np.minimum(q_im1, np.minimum(q_i, q_ip1))\n        max_bound_L = np.maximum(q_im1, np.maximum(q_i, q_ip1))\n        qL = np.maximum(min_bound_L, np.minimum(max_bound_L, qL_raw))\n\n        min_bound_R = np.minimum(q_i, np.minimum(q_ip1, q_ip2))\n        max_bound_R = np.maximum(q_i, np.maximum(q_ip1, q_ip2))\n        qR = np.maximum(min_bound_R, np.minimum(max_bound_R, qR_raw))\n        \n        return qL, qR\n\n    def weno5z_reconstruction(q):\n        \"\"\"\n        Fifth-order WENO reconstruction with WENO-Z weights.\n        \"\"\"\n        epsilon = 1e-40\n        p = 1.0\n        \n        q_pad = np.pad(q, (3, 3), 'wrap')\n        \n        d_L = np.array([0.1, 0.6, 0.3])\n        d_R = np.array([0.3, 0.6, 0.1])\n        \n        # --- Left states qL_{i+1/2} ---\n        v1, v2, v3, v4, v5 = (q_pad[shift:shift+N] for shift in range(1, 6))\n\n        beta0_L = (13./12.)*(v1 - 2*v2 + v3)**2 + (1./4.)*(v1 - 4*v2 + 3*v3)**2\n        beta1_L = (13./12.)*(v2 - 2*v3 + v4)**2 + (1./4.)*(v2 - v4)**2\n        beta2_L = (13./12.)*(v3 - 2*v4 + v5)**2 + (1./4.)*(3*v3 - 4*v4 + v5)**2\n\n        tau5_L = np.abs(beta0_L - beta2_L)\n        alpha0_L = d_L[0] * (1. + (tau5_L / (beta0_L + epsilon))**p)\n        alpha1_L = d_L[1] * (1. + (tau5_L / (beta1_L + epsilon))**p)\n        alpha2_L = d_L[2] * (1. + (tau5_L / (beta2_L + epsilon))**p)\n        alpha_sum_L = alpha0_L + alpha1_L + alpha2_L\n        w0_L, w1_L, w2_L = alpha0_L/alpha_sum_L, alpha1_L/alpha_sum_L, alpha2_L/alpha_sum_L\n        \n        q_hat0_L = (2.*v1 - 7.*v2 + 11.*v3) / 6.\n        q_hat1_L = (-v2 + 5.*v3 + 2.*v4) / 6.\n        q_hat2_L = (2.*v3 + 5.*v4 - v5) / 6.\n        \n        qL = w0_L * q_hat0_L + w1_L * q_hat1_L + w2_L * q_hat2_L\n\n        # --- Right states qR_{i+1/2} ---\n        v0, v1, v2, v3, v4 = (q_pad[shift:shift+N] for shift in range(2, 7))\n\n        beta0_R = (13./12.)*(v0-2*v1+v2)**2 + (1./4.)*(v0-4*v1+3*v2)**2\n        beta1_R = (13./12.)*(v1-2*v2+v3)**2 + (1./4.)*(v1-v3)**2\n        beta2_R = (13./12.)*(v2-2*v3+v4)**2 + (1./4.)*(3*v2-4*v3+v4)**2\n        \n        tau5_R = np.abs(beta0_R - beta2_R)\n        alpha0_R = d_R[0] * (1. + (tau5_R / (beta0_R + epsilon))**p)\n        alpha1_R = d_R[1] * (1. + (tau5_R / (beta1_R + epsilon))**p)\n        alpha2_R = d_R[2] * (1. + (tau5_R / (beta2_R + epsilon))**p)\n        alpha_sum_R = alpha0_R + alpha1_R + alpha2_R\n        w0_R, w1_R, w2_R = alpha0_R/alpha_sum_R, alpha1_R/alpha_sum_R, alpha2_R/alpha_sum_R\n\n        q_hat0_R = (-v0 + 5.*v1 + 2.*v2) / 6.\n        q_hat1_R = (2.*v1 + 5.*v2 - v3) / 6.\n        q_hat2_R = (11.*v2 - 7.*v3 + 2.*v4) / 6.\n        \n        qR = w0_R * q_hat0_R + w1_L * q_hat1_R + w2_R * q_hat2_R\n\n        return qL, qR\n\n    # --- Run Test Cases and Collect Results ---\n    results = []\n\n    # 1. Smooth case: q(x) = sin(2*pi*x)\n    q_smooth = np.sin(2 * np.pi * X_CELLS)\n    q_exact_faces = np.sin(2 * np.pi * X_FACES)\n    \n    qL_weno_smooth, _ = weno5z_reconstruction(q_smooth)\n    err_weno_smooth = np.max(np.abs(qL_weno_smooth - q_exact_faces))\n    \n    qL_muscl_smooth, _ = muscl_reconstruction(q_smooth)\n    err_muscl_smooth = np.max(np.abs(qL_muscl_smooth - q_exact_faces))\n    results.extend([err_weno_smooth, err_muscl_smooth])\n\n    # 2. Discontinuity case\n    q_step = np.where(X_CELLS  0.5, 1.0, 0.0)\n    \n    qL_weno_step, _ = weno5z_reconstruction(q_step)\n    overshoot_pos_weno = np.max(np.maximum(qL_weno_step - 1.0, 0.0))\n    overshoot_neg_weno = np.max(np.maximum(-qL_weno_step, 0.0))\n    overshoot_weno = np.max([overshoot_pos_weno, overshoot_neg_weno])\n\n    qL_muscl_step, _ = muscl_reconstruction(q_step)\n    overshoot_pos_muscl = np.max(np.maximum(qL_muscl_step - 1.0, 0.0))\n    overshoot_neg_muscl = np.max(np.maximum(-qL_muscl_step, 0.0))\n    overshoot_muscl = np.max([overshoot_pos_muscl, overshoot_neg_muscl])\n    results.extend([overshoot_weno, overshoot_muscl])\n    \n    # 3. Constant case\n    q_const = np.full(N, 0.7)\n    qL_weno_const, _ = weno5z_reconstruction(q_const)\n    residual_weno = np.sum(np.abs(qL_weno_const - 0.7))\n    results.append(residual_weno)\n    \n    # 4. Near-vacuum case\n    q_vac = 1e-12 + 1e-13 * np.sin(2 * np.pi * X_CELLS)\n    \n    qL_muscl_vac, qR_muscl_vac = muscl_reconstruction(q_vac)\n    positivity_muscl = np.all(qL_muscl_vac >= 0) and np.all(qR_muscl_vac >= 0)\n    \n    qL_weno_vac, qR_weno_vac = weno5z_reconstruction(q_vac)\n    positivity_weno = np.all(qL_weno_vac >= 0) and np.all(qR_weno_vac >= 0)\n    results.extend([positivity_muscl, positivity_weno])\n\n    # Final output formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3496822"}, {"introduction": "在每个单元交界面，重构出的左右状态定义了一个局域黎曼问题。对于大规模模拟而言，精确求解该问题代价过高，因此近似黎曼求解器提供了一种高效且稳定的方法来计算时间演化所需的数值通量。这最后一个练习 [@problem_id:3496789] 要求您实现广泛使用的Harten-Lax-van Leer-Einfeldt (HLLE)求解器。这是一种稳健的方法，它能捕捉基本的波结构以提供可靠的通量估计，从而完成有限体积格式的核心计算步骤。", "problem": "请考虑在数值相对论中使用的瓦伦西亚表述（Valencia formulation）下，平直时空中的一维狭义相对论流体动力学。在光速 $c=1$ 的几何化单位中，建立一个具有伽马定律状态方程的理想流体模型。设流体的原始变量为静质量密度 $\\,\\rho\\,$、压力 $\\,p\\,$ 和沿 $x$ 方向的欧拉三维速度 $\\,v\\,$。假设状态方程为伽马定律，且具有恒定的绝热指数 $\\,\\gamma\\,$，并将比内能 $\\,\\epsilon\\,$ 和比焓 $\\,h\\,$ 定义为 $\\,\\epsilon = \\dfrac{p}{(\\gamma - 1)\\rho}\\,$ 和 $\\,h = 1 + \\epsilon + \\dfrac{p}{\\rho}\\,$。设洛伦兹因子为 $\\,W = \\dfrac{1}{\\sqrt{1 - v^2}}\\,.$\n\n瓦伦西亚表述引入了由原始变量定义的守恒变量 $\\,D\\,$、$\\,S_x\\,$ 和 $\\,\\tau\\,$，以及沿 $x$ 方向对应的物理通量 $\\,F^x(D)\\,$、$\\,F^x(S_x)\\,$ 和 $\\,F^x(\\tau)\\,$。从质量守恒 $\\,\\nabla_\\mu(\\rho u^\\mu)=0\\,$ 和能量-动量守恒 $\\,\\nabla_\\mu T^{\\mu\\nu}=0\\,$（其中理想流体的应力-能量张量在闵可夫斯基时空中为 $\\,T^{\\mu\\nu} = \\rho h u^\\mu u^\\nu + p g^{\\mu\\nu}\\,$）出发，推导一个算法，用于计算两个状态之间界面上的 Harten–Lax–van Leer–Einfeldt (HLLE) 数值通量。您的推导必须以守恒变量的形式确定物理通量矢量的分量，并使用局域声速估算狭义相对论中的左右极限特征速度。\n\n将推导出的算法实现为一个完整的、可运行的程序。对于每个测试用例，该程序接收一个左状态 $(\\rho_L, p_L, v_L)$ 和一个右状态 $(\\rho_R, p_R, v_R)$ 以及 $\\,\\gamma\\,$，并输出界面处的 HLLE 数值通量矢量 $[F_D, F_{S_x}, F_{\\tau}]$。使用伽马定律理想流体的狭义相对论声速 $\\,c_s\\,$，以及基于 $\\,v\\,$ 和 $\\,c_s\\,$ 的沿 $x$ 方向的适当相对论信号速度公式。确保所有状态在物理上都是允许的：$\\,\\rho > 0\\,$、$\\,p > 0\\,$ 和 $|v|  1$。\n\n单位：使用几何化单位，令 $c=1$。不使用角度。将每个通量分量表示为四舍五入到八位小数的浮点数。\n\n测试套件：\n- 情况 A（中等亚音速状态）：\n  - 左侧：$\\,\\rho_L = 1.0\\,$, $\\,p_L = 1.0\\,$, $\\,v_L = 0.0\\,$。\n  - 右侧：$\\,\\rho_R = 0.125\\,$, $\\,p_R = 0.1\\,$, $\\,v_R = 0.0\\,$。\n  - 绝热指数：$\\,\\gamma = 1.4\\,$。\n- 情况 B（朝向更高压力的超音速左状态）：\n  - 左侧：$\\,\\rho_L = 1.0\\,$, $\\,p_L = 0.1\\,$, $\\,v_L = 0.8\\,$。\n  - 右侧：$\\,\\rho_R = 1.0\\,$, $\\,p_R = 1.0\\,$, $\\,v_R = 0.0\\,$。\n  - 绝热指数：$\\,\\gamma = 1.4\\,$。\n- 情况 C（接近真空的右状态）：\n  - 左侧：$\\,\\rho_L = 0.5\\,$, $\\,p_L = 0.5\\,$, $\\,v_L = 0.3\\,$。\n  - 右侧：$\\,\\rho_R = 10^{-6}\\,$, $\\,p_R = 10^{-8}\\,$, $\\,v_R = 0.0\\,$。\n  - 绝热指数：$\\,\\gamma = 1.4\\,$。\n- 情况 D（强相对论性反向流动）：\n  - 左侧：$\\,\\rho_L = 1.0\\,$, $\\,p_L = 10.0\\,$, $\\,v_L = 0.9\\,$。\n  - 右侧：$\\,\\rho_R = 1.0\\,$, $\\,p_R = 1.0\\,$, $\\,v_R = -0.5\\,$。\n  - 绝热指数：$\\,\\gamma = 1.4\\,$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是一个包含三个浮点数 $[F_D, F_{S_x}, F_{\\tau}]$ 的列表，四舍五入到八位小数。例如，输出应类似于 $[[f_{D,A}, f_{S,A}, f_{\\tau,A}], [f_{D,B}, f_{S,B}, f_{\\tau,B}], [f_{D,C}, f_{S,C}, f_{\\tau,D}]]$，其中 $\\,f_{D,A}\\,$ 是情况 A 的 $\\,F_D\\,$ 值，以此类推。", "solution": "用户希望解决一个狭义相对论流体动力学问题。\n\n### 第 1 步：提取给定信息\n问题提供了以下信息：\n- **物理模型**：平直时空（闵可夫斯基时空）中的一维狭义相对论流体动力学。\n- **流体**：理想流体。\n- **状态方程 (EoS)**：伽马定律，$p = (\\gamma - 1)\\rho\\epsilon$，具有恒定的绝热指数 $\\gamma$。\n- **原始变量**：静质量密度 $\\rho$、压力 $p$ 和 $x$ 方向的欧拉三维速度 $v$。\n- **派生量**：\n    - 比内能：$\\epsilon = \\frac{p}{(\\gamma - 1)\\rho}$\n    - 比焓：$h = 1 + \\epsilon + \\frac{p}{\\rho}$\n    - 洛伦兹因子：$W = \\frac{1}{\\sqrt{1 - v^2}}$\n- **框架**：瓦伦西亚表述。\n- **守恒变量**：$D$、$S_x$、$\\tau$。\n- **物理通量**：$F^x(D)$、$F^x(S_x)$、$F^x(\\tau)$。\n- **控制方程**：质量守恒 $\\nabla_\\mu(\\rho u^\\mu)=0$ 和能量-动量守恒 $\\nabla_\\mu T^{\\mu\\nu}=0$，其中应力-能量张量为 $T^{\\mu\\nu} = \\rho h u^\\mu u^\\nu + p g^{\\mu\\nu}$。\n- **数值方法**：Harten–Lax–van Leer–Einfeldt (HLLE) 数值通量。\n- **任务**：推导一个计算界面处 HLLE 数值通量的算法并加以实现。\n- **信号速度估算**：使用狭义相对论声速 $c_s$ 和相对论信号速度公式。\n- **物理可容许性**：所有状态必须满足 $\\rho > 0$、$p > 0$ 和 $|v|  1$。\n- **单位**：几何化单位，令 $c=1$。\n- **测试用例**：\n    - **情况 A**：左状态 $(\\rho_L, p_L, v_L) = (1.0, 1.0, 0.0)$，右状态 $(\\rho_R, p_R, v_R) = (0.125, 0.1, 0.0)$，$\\gamma = 1.4$。\n    - **情况 B**：左状态 $(\\rho_L, p_L, v_L) = (1.0, 0.1, 0.8)$，右状态 $(\\rho_R, p_R, v_R) = (1.0, 1.0, 0.0)$，$\\gamma = 1.4$。\n    - **情况 C**：左状态 $(\\rho_L, p_L, v_L) = (0.5, 0.5, 0.3)$，右状态 $(\\rho_R, p_R, v_R) = (10^{-6}, 10^{-8}, 0.0)$，$\\gamma = 1.4$。\n    - **情况 D**：左状态 $(\\rho_L, p_L, v_L) = (1.0, 10.0, 0.9)$，右状态 $(\\rho_R, p_R, v_R) = (1.0, 1.0, -0.5)$，$\\gamma = 1.4$。\n- **输出格式**：包含列表的列表的单行，例如 `[[f_DA, f_SA, f_tauA], [f_DB, f_SB, f_tauB], ...]`，每个通量分量四舍五入到八位小数。\n\n### 第 2 步：使用提取的给定信息进行验证\n1.  **科学依据**：该问题牢固地植根于已建立的狭义相对论和流体动力学理论。瓦伦西亚表述和 HLLE 格式是数值相对论中标准且广泛使用的工具。所有定义和方程都是该领域的标准。\n2.  **适定性**：该问题是适定的。它提供了两个明确定义的物理状态，并要求使用指定的算法 (HLLE) 计算它们之间的数值通量。所有必要的参数 ($\\gamma$) 和状态变量都已给出。给定一个确定性算法，解是唯一的且有意义的。\n3.  **客观性**：该问题以精确、客观的语言陈述。术语是物理学和数值方法中的标准术语。没有主观或基于意见的内容。\n4.  **自包含与一致性**：问题包含所有必要信息。原始变量和守恒变量的定义以及状态方程彼此一致，并与标准文献一致。没有矛盾之处。\n5.  **现实性/可行性**：测试用例中的物理参数是可容许的（$\\rho>0, p>0, |v|1$），并且代表了相对论天体物理模拟中遇到的场景（例如，激波管）。\n\n该问题没有显示说明中列出的任何缺陷。这是一个标准的、可验证的计算物理问题。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。我们将继续推导和实现解决方案。\n\n### 基于原理的设计与推导\n\n一维狭义相对论流体动力学方程组可以写成守恒律形式：\n$$\n\\frac{\\partial \\mathbf{U}}{\\partial t} + \\frac{\\partial \\mathbf{F}}{\\partial x} = 0\n$$\n其中 $\\mathbf{U}$ 是守恒变量的矢量，$\\mathbf{F}$ 是其对应通量的矢量。\n\n**1. 守恒变量和通量**\n\n在平直时空的瓦伦西亚表述中，守恒变量 $\\mathbf{U} = [D, S_x, \\tau]^T$ 是根据原始变量 $(\\rho, p, v)$ 定义的。\n\n-   **守恒静质量密度 ($D$)**：这是在实验室参考系中测量的静质量密度。它源于守恒四维流 $J^\\mu = \\rho u^\\mu$ 的时间分量，其中 $u^\\mu = W(1, v, 0, 0)$ 是四维速度。\n    $$D = \\rho W$$\n-   **守恒动量密度 ($S_x$)**：这是 $x$ 方向的动量密度。它是应力-能量张量的混合时空分量，$S_x = T^{tx}$。\n    $$S_x = \\rho h W^2 v$$\n-   **守恒能量密度 ($\\tau$)**：这被定义为欧拉观察者测量的总能量密度 $E=T^{tt}$ 减去守恒静质量密度 $D$。\n    $$E = T^{tt} = \\rho h W^2 - p$$\n    $$\\tau = E - D = \\rho h W^2 - p - \\rho W$$\n\n对于伽马定律气体，比焓 $h$ 为：\n$$h = 1 + \\epsilon + \\frac{p}{\\rho} = 1 + \\frac{p}{(\\gamma - 1)\\rho} + \\frac{p}{\\rho} = 1 + \\frac{\\gamma p}{(\\gamma-1)\\rho}$$\n\n通量矢量 $\\mathbf{F}(\\mathbf{U}) = [F_D, F_{S_x}, F_\\tau]^T$ 从相应张量的空间分量推导得出。\n-   **质量通量 ($F_D$)**：这是四维流的空间分量 $J^x$。\n    $$F_D = \\rho u^x = \\rho W v = D v$$\n-   **动量通量 ($F_{S_x}$)**：这是应力-能量张量的空间分量 $T^{xx}$。\n    $$F_{S_x} = \\rho h u^x u^x + p g^{xx} = \\rho h (Wv)^2 + p = S_x v + p$$\n-   **能量通量 ($F_\\tau$)**：$\\tau$ 的守恒定律是 $\\partial_t \\tau + \\partial_x F_\\tau = 0$。由 $\\partial_t \\tau = \\partial_t(E-D) = \\partial_t E - \\partial_t D$ 和基本守恒定律 $\\partial_t E + \\partial_x S_x = 0$ 和 $\\partial_t D + \\partial_x F_D = 0$，我们得到 $\\partial_t \\tau = - \\partial_x S_x - (-\\partial_x F_D) = - \\partial_x(S_x - F_D)$。因此，\n    $$F_\\tau = S_x - F_D = S_x - D v$$\n    一个等效且计算上更简单的表达式是 $F_\\tau = (\\tau+p)v$。\n\n**2. HLLE 数值通量**\n\n在左状态 $(\\mathbf{U}_L, \\mathbf{F}_L)$ 和右状态 $(\\mathbf{U}_R, \\mathbf{F}_R)$ 之间的界面处，HLLE 数值通量 $\\mathbf{F}^{\\text{HLLE}}$ 由下式给出：\n$$\n\\mathbf{F}^{\\text{HLLE}} = \\frac{S_R \\mathbf{F}_L - S_L \\mathbf{F}_R + S_L S_R (\\mathbf{U}_R - \\mathbf{U}_L)}{S_R - S_L}\n$$\n这里，$S_L$ 和 $S_R$ 是对从界面出现的黎曼扇中最快的左行和右行信号速度的估计。\n\n**3. 信号速度估算**\n\n系统的特征速度是雅可比矩阵 $\\partial \\mathbf{F} / \\partial \\mathbf{U}$ 的特征值。对于一维狭义相对论流体动力学，这些特征值是一个以流体速度移动的接触波 $\\lambda_0 = v$，以及两个速度为 $\\lambda_\\pm$ 的声波。在平直时空中，实验室参考系中测量的声波速度由相对论速度叠加公式给出：\n$$\n\\lambda_\\pm = \\frac{v \\pm c_s}{1 \\pm v c_s}\n$$\n其中 $c_s$ 是流体静止参考系中的声速。对于伽马定律气体，声速的平方是：\n$$\nc_s^2 = \\frac{\\gamma p}{\\rho h}\n$$\n其中 $e = \\rho(1+\\epsilon)$ 是静止参考系中的总能量密度。声速必须小于光速 ($c_s  1$)，这对于 $\\gamma \\in (1, 2]$ 是成立的。\n\n信号速度 $S_L$ 和 $S_R$ 通过取左右状态上的最小和最大特征速度来估计。一个常见且稳健的选择是：\n$$\nS_L = \\min(0, \\lambda_{-,L}, \\lambda_{-,R})\n$$\n$$\nS_R = \\max(0, \\lambda_{+,L}, \\lambda_{+,R})\n$$\n其中 $\\lambda_{\\pm,L}$ 和 $\\lambda_{\\pm,R}$ 分别是为左右状态计算的声波速度。这种选择确保了该方法是正确的迎风格式。如果所有波都向右移动（$\\lambda_{-,L} > 0, \\lambda_{-,R} > 0$），则 $S_L=0$ 且 $\\mathbf{F}^{\\text{HLLE}} = \\mathbf{F}_L$。如果所有波都向左移动（$\\lambda_{+,L}  0, \\lambda_{+,R}  0$），则 $S_R=0$ 且 $\\mathbf{F}^{\\text{HLLE}} = \\mathbf{F}_R$。\n\n**4. 算法**\n\n对于给定的左状态 $(\\rho_L, p_L, v_L)$ 和右状态 $(\\rho_R, p_R, v_R)$，计算 HLLE 通量矢量的算法如下：\n\n1.  **对于左状态**：\n    a.  计算洛伦兹因子 $W_L = (1 - v_L^2)^{-1/2}$。\n    b.  计算比焓 $h_L = 1 + \\frac{\\gamma p_L}{(\\gamma-1)\\rho_L}$。\n    c.  计算声速 $c_{s,L} = \\sqrt{\\frac{\\gamma p_L}{\\rho_L h_L}}$。\n    d.  计算特征速度 $\\lambda_{\\pm,L} = \\frac{v_L \\pm c_{s,L}}{1 \\pm v_L c_{s,L}}$。\n    e.  使用上述公式计算守恒状态矢量 $\\mathbf{U}_L = [D_L, S_{x,L}, \\tau_L]^T$。\n    f.  使用上述公式计算通量矢量 $\\mathbf{F}_L = [F_{D,L}, F_{S_x,L}, F_{\\tau,L}]^T$。\n\n2.  **对于右状态**：对右状态变量重复步骤 1，以获得 $\\lambda_{\\pm,R}$、$\\mathbf{U}_R$ 和 $\\mathbf{F}_R$。\n\n3.  **估算信号速度**：计算 $S_L = \\min(0, \\lambda_{-,L}, \\lambda_{-,R})$ 和 $S_R = \\max(0, \\lambda_{+,L}, \\lambda_{+,R})$。\n\n4.  **计算 HLLE 通量**：如果 $S_R - S_L$ 非零，则应用 HLLE 公式：\n    $$\n    \\mathbf{F}^{\\text{HLLE}} = \\frac{S_R \\mathbf{F}_L - S_L \\mathbf{F}_R + S_L S_R (\\mathbf{U}_R - \\mathbf{U}_L)}{S_R - S_L}\n    $$\n    如果 $S_R - S_L \\approx 0$，则意味着 $S_L=S_R=0$。在这种情况下，状态处于所有特征速度均为零的区域，这是非物理的，除非流体是冷尘埃（$p=0, c_s=0$）。在实践中，为了稳定的数值实现，通常会在分母上加一个小的正值或处理特殊情况。对于给定的测试用例，预计不会出现这种退化情况。\n\n5.  **输出**：返回结果通量矢量 $\\mathbf{F}^{\\text{HLLE}} = [F_D, F_{S_x}, F_\\tau]$，每个分量按要求格式化。\n\n该算法将在最终程序中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_hlle_flux(rho_L, p_L, v_L, rho_R, p_R, v_R, gamma):\n    \"\"\"\n    Calculates the HLLE numerical flux for 1D special relativistic hydrodynamics.\n\n    Args:\n        rho_L (float): Rest-mass density of the left state.\n        p_L (float): Pressure of the left state.\n        v_L (float): Velocity of the left state.\n        rho_R (float): Rest-mass density of the right state.\n        p_R (float): Pressure of the right state.\n        v_R (float): Velocity of the right state.\n        gamma (float): Adiabatic index.\n\n    Returns:\n        list[float]: The HLLE flux vector [F_D, F_Sx, F_tau].\n    \"\"\"\n\n    def get_state_properties(rho, p, v, gamma):\n        \"\"\"\n        Computes derived physical quantities from primitive variables.\n        \"\"\"\n        # Ensure physical admissibility of the state\n        if rho = 0 or p = 0 or abs(v) >= 1:\n            raise ValueError(f\"Physically inadmissible state: rho={rho}, p={p}, v={v}\")\n\n        # Lorentz factor\n        W = 1.0 / np.sqrt(1.0 - v**2)\n        \n        # Specific enthalpy\n        h = 1.0 + gamma * p / ((gamma - 1.0) * rho)\n        \n        # Sound speed squared and sound speed\n        # This must be  1 for a causal EOS\n        cs2 = (gamma * p) / (rho * h)\n        if cs2 >= 1.0:\n            raise ValueError(f\"Acausal sound speed detected: cs^2 = {cs2} >= 1\")\n        cs = np.sqrt(cs2)\n        \n        # Characteristic speeds (eigenvalues)\n        lambda_p = (v + cs) / (1.0 + v * cs)\n        lambda_m = (v - cs) / (1.0 - v * cs)\n        \n        # Conservative variables\n        D = rho * W\n        Sx = rho * h * W**2 * v\n        tau = rho * h * W**2 - p - D\n        \n        U = np.array([D, Sx, tau])\n        \n        # Flux vector\n        F_D = D * v\n        F_Sx = Sx * v + p\n        F_tau = (tau + p) * v # Equivalent to Sx - D*v\n        \n        F = np.array([F_D, F_Sx, F_tau])\n        \n        return lambda_p, lambda_m, U, F\n\n    # Calculate properties for Left and Right states\n    lambda_p_L, lambda_m_L, U_L, F_L = get_state_properties(rho_L, p_L, v_L, gamma)\n    lambda_p_R, lambda_m_R, U_R, F_R = get_state_properties(rho_R, p_R, v_R, gamma)\n    \n    # Estimate signal speeds\n    S_L = min(0.0, lambda_m_L, lambda_m_R)\n    S_R = max(0.0, lambda_p_L, lambda_p_R)\n    \n    # Denominator of the HLLE flux formula\n    S_R_minus_S_L = S_R - S_L\n    \n    # Handle the case where S_R == S_L to avoid division by zero\n    if np.isclose(S_R_minus_S_L, 0.0):\n        # This implies S_L = S_R = 0. All waves are stationary or move away from the interface.\n        # This means the flux is determined solely by the upwind state.\n        # However, a simple average is often used for robustness, or we can check conditions.\n        # The HLLE formula becomes ill-defined. If S_L=S_R=0, it means that for both L and R states,\n        # the waves are either static or moving outwards from the interface.\n        # If lambda_m > 0 (all waves right-moving), flux should be F_L.\n        # If lambda_p  0 (all waves left-moving), flux should be F_R.\n        # But this is already handled by S_L=0 and S_R=0 in the formula.\n        # Let's take the flux to be 0 in this special case as is sometimes done for stationary contact.\n        return [0.0, 0.0, 0.0]\n\n    # Calculate the HLLE flux\n    F_HLLE = (S_R * F_L - S_L * F_R + S_L * S_R * (U_R - U_L)) / S_R_minus_S_L\n    \n    return F_HLLE.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (moderate subsonic states)\n        {'L': (1.0, 1.0, 0.0), 'R': (0.125, 0.1, 0.0), 'gamma': 1.4},\n        # Case B (supersonic left state toward higher pressure)\n        {'L': (1.0, 0.1, 0.8), 'R': (1.0, 1.0, 0.0), 'gamma': 1.4},\n        # Case C (near-vacuum right state)\n        {'L': (0.5, 0.5, 0.3), 'R': (1e-6, 1e-8, 0.0), 'gamma': 1.4},\n        # Case D (strongly relativistic opposing flows)\n        {'L': (1.0, 10.0, 0.9), 'R': (1.0, 1.0, -0.5), 'gamma': 1.4},\n    ]\n\n    results = []\n    for case in test_cases:\n        rho_L, p_L, v_L = case['L']\n        rho_R, p_R, v_R = case['R']\n        gamma = case['gamma']\n        \n        flux_vector = calculate_hlle_flux(rho_L, p_L, v_L, rho_R, p_R, v_R, gamma)\n        \n        # Format each component to 8 decimal places\n        formatted_flux = [f\"{float(x):.8f}\" for x in flux_vector]\n        results.append(f\"[{','.join(formatted_flux)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3496789"}]}