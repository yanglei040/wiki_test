{"hands_on_practices": [{"introduction": "在数值相对论中，我们总是在有限半径 $R$ 处提取引力波，而非在理想的无穷远处。即便是使用如Sommerfeld条件这样简单的出射波边界条件，波的球形传播特性仍会引入系统误差。本练习将引导你推导在这种设置下，提取的波形与无穷远处的真实波形之间的前导阶系统性相位误差，并揭示其如何随半径 $R$ 变化[@problem_id:3482117]。掌握这种误差分析是进行有限半径修正和将结果外推至零无穷远的关键一步。", "problem": "在引力辐射的数值相对论中，波形提取通常在施加了外行边界条件的有限半径球面上进行。考虑一个远区多极引力波波形模式，其传播在辐射区的主导阶上可以通过每个球谐模式的平直时空标量波方程的解来建模，该解捕捉了相同的径向衰减和外行特性。外边界实施索末菲边界条件 (SBC)，定义为在大半径处 $(\\partial_{t} + \\partial_{r}) \\psi = 0$。提取的波形相位是在半径为 $R$ 的球面上，使用推迟时 $u_{R} = t - R$ 来测量的。假设主导模式的球谐指数为 $l = 2$，单色角频率为 $\\omega$（因此在光速为1的单位制中，波数满足 $k = \\omega$），并且波形由一个允许良定义相位的复数模式振幅表示。\n\n从球坐标下的标量波方程\n$$\n\\partial_{t}^{2} \\psi - \\partial_{r}^{2} \\psi - \\frac{2}{r} \\partial_{r} \\psi + \\frac{1}{r^{2}} \\Delta_{\\mathbb{S}^{2}} \\psi = 0,\n$$\n以及球谐分解 $\\psi(t,r,\\Omega) = \\sum_{l,m} \\frac{1}{r} \\chi_{lm}(t,r) Y_{lm}(\\Omega)$（其中 $\\Delta_{\\mathbb{S}^{2}} Y_{lm}(\\Omega) = - l(l+1) Y_{lm}(\\Omega)$）出发，推导与主导阶上的索末菲边界条件一致的 $l=2$ 单色模式的大 $R$ 渐近外行解。基于此渐近解，计算在有限半径 $R$ 处测量的相位与在类光无穷远处的相位之间的主导阶系统性相位误差 $\\Delta \\phi(R)$，并用 $\\omega$ 和 $R$ 表示。最后，为相位设计一个一阶 $1/R$ 外推方案，通过将有限半径的相位测量值拟合到一个关于 $1/R$ 的多项式来恢复类光无穷远处的值，并写出 $\\phi_{\\infty}$ 关于 $\\phi(R_{1})$、$\\phi(R_{2})$ 以及相应半径 $R_{1}$ 和 $R_{2}$ 的显式双半径公式。\n\n你的最终答案必须是仅用 $\\omega$ 和 $R$ 表示的主导阶系统性相位误差 $\\Delta \\phi(R)$ 的单一闭式解析表达式。不需要进行数值计算。", "solution": "该问题要求计算在有限半径 $R$ 处提取的引力波波形模式与其在类光无穷远处的值相比的主导阶系统性相位误差。该波形模式被建模为标量波方程的一个解。\n\n首先，我们验证问题陈述的有效性。\n\n### 步骤1：提取已知条件\n-   **场方程**：球坐标下的标量波方程由下式给出：\n    $$\n    \\partial_{t}^{2} \\psi - \\partial_{r}^{2} \\psi - \\frac{2}{r} \\partial_{r} \\psi + \\frac{1}{r^{2}} \\Delta_{\\mathbb{S}^{2}} \\psi = 0\n    $$\n-   **球谐分解**：解被分解为：\n    $$\n    \\psi(t,r,\\Omega) = \\sum_{l,m} \\frac{1}{r} \\chi_{lm}(t,r) Y_{lm}(\\Omega)\n    $$\n-   **角向本征值方程**：球谐函数 $Y_{lm}(\\Omega)$ 是单位2-球面上的拉普拉斯算子 $\\Delta_{\\mathbb{S}^{2}}$ 的本征函数：\n    $$\n    \\Delta_{\\mathbb{S}^{2}} Y_{lm}(\\Omega) = -l(l+1) Y_{lm}(\\Omega)\n    $$\n-   **关注的模式**：主导模式的球谐指数为 $l=2$。\n-   **时间依赖性**：该模式是单色的，角频率为 $\\omega$。在光速 $c=1$ 的单位制中，波数为 $k=\\omega$。\n-   **边界条件**：索末菲边界条件 (SBC) 在大半径处施加：$(\\partial_{t} + \\partial_{r}) \\psi = 0$。此条件将波是纯外行的要求形式化。\n-   **相位测量**：相位在半径为 $R$ 的球面上，于推迟时 $u_{R} = t - R$ 进行测量。\n-   **目标**：推导主导阶相位误差 $\\Delta \\phi(R)$ 和一个外推公式。最终需要的答案是 $\\Delta \\phi(R)$ 的表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，是适定且客观的。它利用了远场中波传播的标准数学物理框架，特别是标量波方程、球谐函数和外行波条件。这些是辐射研究中的基本工具，它们在数值相对论中引力波提取的应用是一个标准但简化的模型。给定的条件是自洽且一致的。该问题没有违反任何物理原理，也不包含任何事实性错误。它在指定领域内是一个可形式化和可解的问题。\n\n### 步骤3：结论与行动\n该问题是 **有效的**。我们继续进行求解。\n\n所给的标量波方程是球坐标下的标准形式，可以写为 $\\partial_t^2 \\psi - \\nabla^2 \\psi = 0$。对于频率为 $\\omega$ 的单色波，我们假设其时间依赖性形式为 $e^{-i\\omega t}$。波函数的空间部分则满足亥姆霍兹方程 $(\\nabla^2 + k^2)\\psi = 0$，其中 $k=\\omega$。\n\n对于单个球谐模式 $(l,m)$，解可以写为 $\\psi_{lm}(t,r,\\Omega) = \\mathcal{R}_l(r) Y_{lm}(\\Omega) e^{-i\\omega t}$。将此代入亥姆霍兹方程，得到径向函数 $\\mathcal{R}_l(r)$ 的球贝塞尔微分方程：\n$$\n\\frac{d^2 \\mathcal{R}_l}{dr^2} + \\frac{2}{r} \\frac{d\\mathcal{R}_l}{dr} + \\left(k^2 - \\frac{l(l+1)}{r^2}\\right) \\mathcal{R}_l = 0\n$$\n该方程的通解是球贝塞尔函数 $j_l(kr)$ 和 $y_l(kr)$ 的线性组合。对于外行波解（这在物理上是辐射问题所要求的，并且与大 $r$ 处的索末菲条件一致），合适的基是球汉克尔函数。具体来说，外行解由第一类球汉克尔函数 $h_l^{(1)}(kr) = j_l(kr) + i y_l(kr)$ 描述。\n\n因此，外行单色 $l=2$ 模式具有以下形式：\n$$\n\\psi(t,r) \\propto h_2^{(1)}(\\omega r) e^{-i\\omega t}\n$$\n其中我们省略了角向依赖性 $Y_{2m}(\\Omega)$，因为它对于一个给定的模式是常数。\n\n为了找到相位误差，我们必须比较此解在有限半径 $R$ 处的相位与其在类光无穷远（$R \\to \\infty$）处的相位。这需要汉克尔函数在大宗量（$z \\gg l$）下的渐近展开。其展开式由下式给出：\n$$\nh_l^{(1)}(z) \\sim \\frac{e^{i(z - (l+1)\\pi/2)}}{z} \\sum_{j=0}^{\\infty} \\frac{i^j}{j!(2z)^j} \\frac{(l+j)!}{(l-j)!}\n$$\n对于 $l=2$，求和式中的多项式在 $j=l=2$ 处终止。仅当 $j \\le l$ 时系数非零。\n$$\nh_2^{(1)}(z) \\sim \\frac{e^{i(z - 3\\pi/2)}}{z} \\left[ \\frac{i^0}{0!(2z)^0}\\frac{2!}{0!} + \\frac{i^1}{1!(2z)^1}\\frac{3!}{1!} + \\frac{i^2}{2!(2z)^2}\\frac{4!}{0!} \\right]\n$$\n$$\nh_2^{(1)}(z) \\sim \\frac{e^{i(z - 3\\pi/2)}}{z} \\left( 1 + \\frac{3i}{z} - \\frac{3}{z^2} \\right)\n$$\n代入 $z = \\omega R$，大半径 $R$ 处的波形为：\n$$\n\\psi(t,R) \\propto \\frac{e^{i(\\omega R - 3\\pi/2)}}{ \\omega R} \\left( 1 + \\frac{3i}{\\omega R} - \\frac{3}{(\\omega R)^2} \\right) e^{-i\\omega t}\n$$\n这个复数量的相位 $\\phi(R)$ 是其各因子相位之和：\n$$\n\\phi(R) = \\arg(\\psi(t,R)) = \\omega R - \\omega t - \\frac{3\\pi}{2} + \\arg\\left(1 + \\frac{3i}{\\omega R} - \\frac{3}{(\\omega R)^2}\\right)\n$$\n类光无穷远处的相位 $\\phi_{\\infty}$ 由此渐近展开的主导项定义，该主导项对应于 $R \\to \\infty$ 的极限。在此极限下，括号中项的辐角变为 $\\arg(1) = 0$。因此，类光无穷远处的相位为：\n$$\n\\phi_{\\infty} = \\omega R - \\omega t - \\frac{3\\pi}{2}\n$$\n相位误差 $\\Delta \\phi(R)$ 是有限半径 $R$ 处的相位与类光无穷远处相位之差：\n$$\n\\Delta \\phi(R) = \\phi(R) - \\phi_{\\infty} = \\arg\\left(1 + \\frac{3i}{\\omega R} - \\frac{3}{(\\omega R)^2}\\right)\n$$\n为了计算这个值，我们将该复数写成笛卡尔形式 $X+iY$：\n$$\nX = 1 - \\frac{3}{(\\omega R)^2}, \\quad Y = \\frac{3}{\\omega R}\n$$\n辐角由 $\\arctan(Y/X)$ 给出，因为对于大 $R$，$X>0$（第一象限）。\n$$\n\\Delta \\phi(R) = \\arctan\\left(\\frac{\\frac{3}{\\omega R}}{1 - \\frac{3}{(\\omega R)^2}}\\right) = \\arctan\\left(\\frac{3\\omega R}{(\\omega R)^2 - 3}\\right)\n$$\n问题要求的是*主导阶*系统性相位误差。对于大 $R$，反正切函数的自变量很小。我们可以对小的 $x$ 使用近似 $\\arctan(x) \\approx x$。\n对于大 $R$，反正切函数的自变量为：\n$$\n\\frac{3\\omega R}{(\\omega R)^2 - 3} = \\frac{3\\omega R}{(\\omega R)^2\\left(1 - \\frac{3}{(\\omega R)^2}\\right)} \\approx \\frac{3}{\\omega R} \\left(1 + \\frac{3}{(\\omega R)^2} + \\dots\\right) = \\frac{3}{\\omega R} + \\mathcal{O}(R^{-3})\n$$\n因此，主导阶行为是：\n$$\n\\Delta \\phi(R) \\approx \\frac{3}{\\omega R}\n$$\n这就是所求的表达式。\n\n作为检验，我们可以推导外推公式。结果 $\\phi(R) \\approx \\phi_\\infty + \\frac{C}{R}$（其中 $C=3/\\omega$）表明，可以将相位测量值 $\\phi(R_1)$ 和 $\\phi(R_2)$ 拟合成一条关于 $1/R$ 的直线。\n$$\n\\phi(R_1) = \\phi_\\infty + \\frac{C}{R_1}\n$$\n$$\n\\phi(R_2) = \\phi_\\infty + \\frac{C}{R_2}\n$$\n求解 $\\phi_\\infty$ 得到双半径外推公式：\n$$\n\\phi_\\infty = \\frac{R_2 \\phi(R_2) - R_1 \\phi(R_1)}{R_2 - R_1}\n$$\n这是一种标准的一阶 Richardson 外推，证实了我们推导的相位误差的一致性。", "answer": "$$\\boxed{\\frac{3}{\\omega R}}$$", "id": "3482117"}, {"introduction": "实际的数值边界条件总是不完美的，会导致一部分出射波被反射回计算区域，从而污染真实的物理信号。本练习将让你通过微扰分析，建立一个从边界反射系数 $|R(\\omega)|$ 到测量波形振幅和相位误差的直接映射。你将通过编写代码，将这个微扰模型的预测与一个直接的时域模拟结果进行比较，从而验证模型的有效性[@problem_id:3482144]。这项实践将具体展示边界条件的缺陷是如何转化为可量化的波形测量误差的。", "problem": "考虑通过 Newman–Penrose 标量 $\\Psi_4$ 从数值相对论模拟中提取的渐近引力辐射。在远离源的区域，当时空曲率可忽略不计时，辐射自由度以线性波的形式传播，其主导阶可由一维标量波动方程建模：\n$$\n\\partial_t^2 \\psi(t,x) - c^2 \\, \\partial_x^2 \\psi(t,x) = 0,\n$$\n其中 $c$ 是光速，$t$ 是时间（单位为秒），$x$ 是一维坐标（单位为米）。设一个外部计算边界位于 $x = L$ 处，一个探测器位于 $x = x_d$ 处，且 $0  x_d  L$。一个 Sommerfeld 型外行边界条件是不完美的，会产生一个小的反射波，其特征是测得的、依赖于频率的边界反射幅度 $\\lvert R(\\omega) \\rvert$，其中 $\\omega$ 是角频率（单位为弧度/秒）。反射波从探测器传播到边界再返回，产生一个往返时间延迟\n$$\n\\tau = \\frac{2 (L - x_d)}{c},\n$$\n单位为秒。我们假设 $\\lvert R(\\omega) \\rvert \\ll 1$，因此微扰分析适用。探测器记录的信号由真实的向外传播分量和一个具有上述延迟和幅度的小反射分量组成。\n\n您的任务是，从标量波动方程和线性叠加出发，推导出一个微扰映射，该映射将测得的边界反射幅度 $\\lvert R(\\omega) \\rvert$ 映射到探测器处 $\\Psi_4$ 中产生的相对振幅误差和相位误差，两者都是 $\\omega$ 和 $\\tau$ 的函数。相位误差必须以弧度表示，相对振幅误差必须是无量纲的。然后，通过与直接时域模拟进行对比来验证该微扰映射。在模拟中，对于每个角频率 $\\omega$，探测器时间序列被建模为单色真实信号与一个延迟的、反射分量的叠加。\n\n为进行验证，对每个 $\\omega$ 定义时域探测器信号如下：\n$$\ns_{\\text{true}}(t;\\omega) = A \\, \\cos(\\omega t), \\quad s_{\\text{meas}}(t;\\omega) = A \\, \\cos(\\omega t) + A \\, \\lvert R(\\omega) \\rvert \\, \\cos\\!\\big(\\omega (t - \\tau)\\big),\n$$\n其中 $A$ 是一个常数振幅（不妨设 $A = 1$）。对于每个 $\\omega$，在为所有测试的 $\\omega$ 选取的、包含整数个周期的有限时间窗口内，提取 $s_{\\text{meas}}(t;\\omega)$ 在该角频率下的复傅里叶系数，并将其与 $s_{\\text{true}}(t;\\omega)$ 的系数进行比较。使用此比较获得探测器处的精确相对振幅误差和精确相位误差。将这些精确误差与您推导的微扰预测进行比较，并报告在测试的 $\\omega$ 值范围内的最大绝对差。\n\n您必须实现以下测试套件。在所有情况下，使用 $A = 1$。在构建用于傅里叶提取的时间窗口时，请确保窗口长度包含该案例中每个 $\\omega$ 的整数个周期，并使用足够精细的采样以确保数值积分的准确性。所有角度必须以弧度处理，所有时间以秒处理，所有频率以弧度/秒处理。\n\n测试用例1（理想情况，反射非常小）：\n- $\\omega$ 值：$[100, 200, 300, 400]$ 弧度/秒。\n- $\\tau = 0.01$ 秒。\n- $\\lvert R(\\omega) \\rvert = 0.01$（不随频率变化）。\n\n测试用例2（中等反射幅度）：\n- $\\omega$ 值：$[100, 400, 700, 1000]$ 弧度/秒。\n- $\\tau = 0.0125$ 秒。\n- $\\lvert R(\\omega) \\rvert = 0.2$（不随频率变化）。\n\n测试用例3（频率相关的反射，延迟较大）：\n- $\\omega$ 值：$[100, 300, 500, 700]$ 弧度/秒。\n- $\\tau = 0.05$ 秒。\n- $\\lvert R(\\omega) \\rvert = \\dfrac{r_0}{1 + (\\omega/\\omega_c)^2}$，其中 $r_0 = 0.1$ 且 $\\omega_c = 200$ 弧度/秒。\n\n测试用例4（边界情况，零反射）：\n- $\\omega$ 值：$[100, 200, 400, 800]$ 弧度/秒。\n- $\\tau = 0.02$ 秒。\n- $\\lvert R(\\omega) \\rvert = 0$。\n\n对于每个测试用例，计算：\n1. 该案例中每个 $\\omega$ 的微扰相对振幅误差和微扰相位误差（以弧度为单位）。\n2. 该案例中每个 $\\omega$ 通过时域模拟和傅里叶分析提取的精确相对振幅误差和精确相位误差（以弧度为单位）。\n3. 在该案例的 $\\omega$ 值范围内，微扰与精确相对振幅误差之间的最大绝对差，以及相位误差的最大绝对差。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含两个浮点数的子列表 $[\\Delta A_{\\max}, \\Delta \\phi_{\\max}]$，分别对应于相对振幅和相位的最大绝对差。最终格式必须为：\n[[case1_amp_diff,case1_phase_diff],[case2_amp_diff,case2_phase_diff],[case3_amp_diff,case3_phase_diff],[case4_amp_diff,case4_phase_diff]]", "solution": "该问题要求推导一个微扰模型，用于描述由不完美外行波边界条件引起的测量波信号中的误差，并根据直接数值模拟对该模型进行验证。物理背景是在探测器上测量引力波，引力波由标量场 $\\psi(t,x)$ 建模。\n\n首先，我们着手推导微扰映射。对于单一角频率 $\\omega$，探测器处的真实信号是一个纯粹向外传播的单色波，我们用复数形式表示为 $\\tilde{s}_{\\text{true}}(t; \\omega) = A e^{i\\omega t}$，其中 $A$ 是一个实振幅。测量到的信号 $\\tilde{s}_{\\text{meas}}(t; \\omega)$ 是这个真实信号与一个反射分量的叠加。反射分量有一次往返时间延迟 $\\tau$，其振幅按边界反射幅度 $|R(\\omega)|$ 缩放。因此，测量到的信号由下式给出：\n$$\n\\tilde{s}_{\\text{meas}}(t; \\omega) = A e^{i\\omega t} + A |R(\\omega)| e^{i\\omega (t - \\tau)}\n$$\n我们可以提出真实信号分量，以确定复误差因子 $E(\\omega)$，该因子修正了真实信号的振幅和相位：\n$$\n\\tilde{s}_{\\text{meas}}(t; \\omega) = A e^{i\\omega t} \\left(1 + |R(\\omega)| e^{-i\\omega\\tau}\\right) = \\tilde{s}_{\\text{true}}(t; \\omega) \\cdot E(\\omega)\n$$\n复误差因子为 $E(\\omega) = 1 + |R(\\omega)| e^{-i\\omega\\tau}$。展开复指数，我们得到：\n$$\nE(\\omega) = 1 + |R(\\omega)| (\\cos(\\omega\\tau) - i\\sin(\\omega\\tau)) = \\big(1 + |R(\\omega)|\\cos(\\omega\\tau)\\big) - i \\big(|R(\\omega)|\\sin(\\omega\\tau)\\big)\n$$\n测得的复振幅为 $A'_{\\text{complex}} = A \\cdot E(\\omega)$。测得的振幅大小与真实振幅之比为 $|E(\\omega)|$，相位误差是 $E(\\omega)$ 的辐角。\n\n为了找到微扰误差，我们假设 $|R(\\omega)| \\ll 1$ 并对 $|R(\\omega)|$ 进行一阶泰勒展开。\n\n相对振幅误差为 $\\frac{|A'|}{A} - 1 = |E(\\omega)| - 1$。$|E(\\omega)|$ 的大小是：\n$$\n|E(\\omega)| = \\sqrt{\\left(1+|R(\\omega)|\\cos(\\omega\\tau)\\right)^2 + \\left(-|R(\\omega)|\\sin(\\omega\\tau)\\right)^2} = \\sqrt{1 + 2|R(\\omega)|\\cos(\\omega\\tau) + |R(\\omega)|^2}\n$$\n对于小的 $x$，使用一阶泰勒展开 $\\sqrt{1+x} \\approx 1 + \\frac{1}{2}x$，其中 $x = 2|R(\\omega)|\\cos(\\omega\\tau) + |R(\\omega)|^2$，我们得到：\n$$\n|E(\\omega)| \\approx 1 + \\frac{1}{2}\\left(2|R(\\omega)|\\cos(\\omega\\tau) + |R(\\omega)|^2\\right) \\approx 1 + |R(\\omega)|\\cos(\\omega\\tau) + \\mathcal{O}(|R(\\omega)|^2)\n$$\n因此，一阶微扰相对振幅误差 $\\delta A_{\\text{frac}}$ 为：\n$$\n\\delta A_{\\text{frac}}(\\omega) = |E(\\omega)| - 1 \\approx |R(\\omega)|\\cos(\\omega\\tau)\n$$\n相位误差 $\\delta\\phi(\\omega)$ 是 $E(\\omega)$ 的辐角。对于小的 $y$，使用一阶泰勒展开 $\\arctan(y) \\approx y$：\n$$\n\\delta\\phi(\\omega) = \\arg(E(\\omega)) = \\arctan\\left(\\frac{-|R(\\omega)|\\sin(\\omega\\tau)}{1+|R(\\omega)|\\cos(\\omega\\tau)}\\right) \\approx \\frac{-|R(\\omega)|\\sin(\\omega\\tau)}{1} + \\mathcal{O}(|R(\\omega)|^2)\n$$\n因此，一阶微扰相位误差为：\n$$\n\\delta\\phi(\\omega) \\approx -|R(\\omega)|\\sin(\\omega\\tau)\n$$\n这两个表达式构成了所要求的微扰映射。\n\n接下来，我们概述数值验证过程。对于测试用例中的每个角频率 $\\omega$，我们必须将微扰公式的预测与从时域模拟中提取的“精确”误差进行比较。问题将真实和测量的实值信号定义为：\n$$\ns_{\\text{true}}(t;\\omega) = A \\cos(\\omega t) \\quad \\text{and} \\quad s_{\\text{meas}}(t;\\omega) = A \\cos(\\omega t) + A |R(\\omega)| \\cos(\\omega (t - \\tau))\n$$\n“精确”误差是通过在频率 $\\omega$ 处提取 $s_{\\text{meas}}(t;\\omega)$ 的复振幅来找到的。复振幅 $A'_{\\text{complex}}$ 可以通过将信号在一个包含整数个 $\\omega$ 周期的时间区间 $[0, T]$ 内投影到复基函数 $e^{i\\omega t}$ 上来获得。相应的公式是：\n$$\nA'_{\\text{complex}} = \\frac{2}{T} \\int_0^T s_{\\text{meas}}(t;\\omega) e^{-i\\omega t} dt\n$$\n此积分通过数值方法计算。时间长度 $T$ 选择为 $T = 2\\pi / \\text{gcd}(\\{\\omega_k\\})$，其中 $\\{\\omega_k\\}$ 是给定测试用例中的频率，这确保了 $T$ 是每个 $\\omega_k$ 周期的整数倍。时域信号被精细采样，以确保数值积分的准确性（例如，使用梯形法则）。\n\n真实信号 $s_{\\text{true}}(t;\\omega)$ 的复振幅为 $A$（我们设为 $1$）。然后，从数值方法获得的 $A'_{\\text{complex}}$ 计算出精确的相对振幅误差和相位误差：\n$$\n\\Delta A_{\\text{frac, exact}} = \\frac{|A'_{\\text{complex}}|}{|A|} - 1, \\quad \\Delta\\phi_{\\text{exact}} = \\arg(A'_{\\text{complex}})\n$$\n对于每个测试用例，我们为每个指定的 $\\omega$ 计算这些精确误差，并将它们与微扰误差 $\\delta A_{\\text{frac}}$ 和 $\\delta\\phi$ 进行比较。最终报告的值是该案例中所有频率上精确误差与微扰误差之间的最大绝对差：\n$$\n\\Delta A_{\\max} = \\max_{\\omega} |\\Delta A_{\\text{frac, exact}}(\\omega) - \\delta A_{\\text{frac}}(\\omega)|\n$$\n$$\n\\Delta \\phi_{\\max} = \\max_{\\omega} |\\Delta\\phi_{\\text{exact}}(\\omega) - \\delta\\phi(\\omega)|\n$$\n此过程验证了微扰近似的准确性，预计在 $|R(\\omega)|$ 较小时能很好地成立，并随着 $|R(\\omega)|$ 的增大而变差。下面的 Python 代码实现了这整个验证过程。", "answer": "```python\nimport numpy as np\nfrom math import gcd\nfrom functools import reduce\n\ndef solve():\n    \"\"\"\n    Derives and validates a perturbative model for errors in a measured wave signal\n    due to imperfect outgoing wave boundary conditions.\n    \"\"\"\n\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (omegas, tau, R_function)\n    # R_function is a callable that returns the reflection magnitude |R(omega)|.\n    test_cases = [\n        # Test Case 1\n        (\n            np.array([100, 200, 300, 400], dtype=int),\n            0.01,\n            lambda omega: 0.01\n        ),\n        # Test Case 2\n        (\n            np.array([100, 400, 700, 1000], dtype=int),\n            0.0125,\n            lambda omega: 0.2\n        ),\n        # Test Case 3\n        (\n            np.array([100, 300, 500, 700], dtype=int),\n            0.05,\n            lambda omega, r0=0.1, wc=200.0: r0 / (1.0 + (omega / wc)**2)\n        ),\n        # Test Case 4\n        (\n            np.array([100, 200, 400, 800], dtype=int),\n            0.02,\n            lambda omega: 0.0\n        )\n    ]\n\n    # The constant amplitude A can be set to 1.0 without loss of generality.\n    A = 1.0\n    all_case_results = []\n\n    for omegas, tau, R_func in test_cases:\n        \n        # Calculate the GCD of all integer frequencies in the case.\n        omega_gcd = reduce(gcd, omegas)\n        \n        # The integration window T must contain an integer number of cycles for all omegas.\n        T = 2.0 * np.pi / omega_gcd\n        \n        # Determine sampling rate for numerical integration.\n        # Ensure high resolution for the highest frequency (shortest period).\n        omega_max = np.max(omegas)\n        samples_per_min_period = 1000  # High number for accuracy\n        num_points = int(omega_max / omega_gcd * samples_per_min_period) + 1\n        t = np.linspace(0, T, num_points)\n\n        max_amp_diff = 0.0\n        max_phase_diff = 0.0\n\n        for omega in omegas:\n            # Reflection magnitude for the current frequency\n            R_val = R_func(omega)\n\n            # 1. Calculate perturbative errors\n            pert_amp_err = R_val * np.cos(omega * tau)\n            pert_phase_err = -R_val * np.sin(omega * tau)\n\n            # 2. Calculate \"exact\" errors from time-domain simulation\n            # Define the measured signal in the time domain.\n            s_meas_t = A * np.cos(omega * t) + A * R_val * np.cos(omega * (t - tau))\n            \n            # Project the signal onto the complex exponential to find the complex amplitude.\n            # The factor 2/T normalizes the result to the physical amplitude.\n            integrand = s_meas_t * np.exp(-1j * omega * t)\n            C_meas_complex = (2.0 / T) * np.trapz(integrand, t)\n            \n            # The true signal's complex amplitude is A.\n            C_true_complex = A\n            \n            # Extract fractional amplitude and phase errors.\n            exact_frac_amp_err = np.abs(C_meas_complex) / np.abs(C_true_complex) - 1.0\n            exact_phase_err = np.angle(C_meas_complex)\n\n            # 3. Compute absolute differences and update maximums for the case.\n            amp_diff = np.abs(exact_frac_amp_err - pert_amp_err)\n            phase_diff = np.abs(exact_phase_err - pert_phase_err)\n            \n            if amp_diff > max_amp_diff:\n                max_amp_diff = amp_diff\n            \n            if phase_diff > max_phase_diff:\n                max_phase_diff = phase_diff\n                \n        all_case_results.append([max_amp_diff, max_phase_diff])\n\n    # Format the final output string as specified in the problem statement.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in all_case_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3482144"}, {"introduction": "在设计大规模数值模拟时，我们必须在物理精度和计算成本之间做出权衡。精确的无反射边界条件虽然效果好，但其计算开销巨大，尤其是在需要处理大量球谐模式时。本练习将模拟一个真实世界中的优化问题：设计一种混合边界条件策略[@problem_id:3482103]。你将对能量贡献大的低阶模式（$\\ell \\le \\ell_c$）使用精确但昂贵的边界条件，而对高阶模式（$\\ell > \\ell_c$）则使用更简单、计算成本更低的近似条件。你的目标是根据给定的精度容忍度和计算预算，找到最优的“切换”模式 $\\ell_c$，以在保证物理结果可靠性的前提下最大限度地提高计算效率。", "problem": "考虑在渐近平坦时空中的双黑洞（BBH）模拟的标量线性化引力波内容，其在远区通过针对每个球谐多极子的球对称标量波动方程进行建模。在几何单位制中（光速 $c=1$ 且总质量标度被吸收到无量纲化中），由整数 $\\ell \\geq 2$ 索引的每个多极模根据标准的球谐分解波动方程演化，并且在半径为 $R$ 的外部球面边界附近的场可以表示为出射和入射球面波的叠加。在外部边界 $r=R$ 处，您必须施加一个出射波边界条件。考虑两种类型的边界条件：\n\n- 一种时域精确卷积核辐射边界条件（RBC），对于给定的多极子指数 $\\ell$ 是精确的。在频域中，这对应于从第一类球汉克尔函数导出的精确出射阻抗。在对角频率为 $\\omega$ 的单色分量进行的频域稳态分析中，此精确RBC消除了该多极子的反射。\n- 一种简单的 Sommerfeld 出射边界条件，在时域中于 $r=R$ 处强制执行 $\\partial_t u_\\ell + \\partial_r u_\\ell = 0$。此条件对平面波是精确的，但对球谐多极子 $\\ell \\geq 2$ 会产生非零反射。\n\n您将实现一种混合边界条件策略：对于低阶多极子（$\\ell \\leq \\ell_c$），使用精确卷积核RBC；对于高阶多极子（$\\ell > \\ell_c$），使用 Sommerfeld 条件。设计目标是选择交叉多极子 $\\ell_c$，以控制伪反射，同时平衡计算成本。\n\n从基本定义出发：\n\n- 出射和入射的频域球解分别正比于球汉克尔函数 $h_\\ell^{(1)}(\\kappa)$ 和 $h_\\ell^{(2)}(\\kappa)$，其中 $\\kappa = k R$，在几何单位制中 $k=\\omega$。\n- 在频域中，$r=R$ 处的 Sommerfeld 条件将 $\\partial_r u_\\ell$ 替换为 $i k u_\\ell$。\n- 对于 $r=R$ 处的纯出射解，精确阻抗条件将 $\\partial_r u_\\ell$ 替换为 $\\left[k \\, h_\\ell^{(1)\\prime}(\\kappa) / h_\\ell^{(1)}(\\kappa)\\right] u_\\ell$。\n\n利用这些事实，从第一性原理推导在 $r=R$ 处，对于给定的 $\\ell$ 和 $\\kappa$，Sommerfeld 条件下的复反射振幅，并定义一个非负反射度量 $R_\\ell$，用于衡量在 Sommerfeld 条件下该振幅的绝对值。相比之下，对于精确卷积核RBC，在频域稳态近似中，假设 $R_\\ell = 0$。\n\n为跨越多极子 $\\ell = 2,3,\\dots,L_{\\max}$ 的 BBH 波形内容定义一个具有物理动机的权重 $W_\\ell$，由 $W_\\ell \\propto \\exp\\left(-\\alpha(\\ell-2)\\right)$ 给出，其中 $\\alpha>0$，并对 $\\{W_\\ell\\}$ 进行归一化，使得 $\\sum_{\\ell=2}^{L_{\\max}} W_\\ell = 1$。定义加权混合反射度量\n$$\nE(\\ell_c) = \\sum_{\\ell=2}^{L_{\\max}} W_\\ell \\, \\tilde{R}_\\ell(\\ell_c),\n$$\n其中，如果 $\\ell \\leq \\ell_c$（精确RBC），则 $\\tilde{R}_\\ell(\\ell_c) = 0$；如果 $\\ell > \\ell_c$（Sommerfeld），则 $\\tilde{R}_\\ell(\\ell_c) = R_\\ell$。\n\n按如下方式对计算成本进行建模。设 $c_0>0$ 为每个多极子每个卷积核阶数的成本系数，设 $s_0>0$ 为 Sommerfeld 条件下每个多极子的成本系数。假设多极子 $\\ell$ 的精确卷积核RBC每个时间步需要与 $\\ell$ 成正比的计算功，而 Sommerfeld 条件每个多极子的成本是恒定的。混合策略的总成本为\n$$\nC_{\\text{tot}}(\\ell_c) = c_0 \\sum_{\\ell=2}^{\\ell_c} \\ell + s_0 \\sum_{\\ell=\\ell_c+1}^{L_{\\max}} 1 = c_0\\left(\\frac{\\ell_c(\\ell_c+1)}{2} - 1\\right) + s_0\\left(L_{\\max} - \\ell_c\\right).\n$$\n\n给定一个反射容差 $\\varepsilon>0$ 和一个计算预算 $B>0$，优化问题是：\n- 找到最小的整数 $\\ell_c \\in \\{2,3,\\dots,L_{\\max}\\}$，使得 $E(\\ell_c) \\leq \\varepsilon$ 且 $C_{\\text{tot}}(\\ell_c) \\leq B$。\n- 如果不存在这样的 $\\ell_c$，则选择整数 $\\ell_c \\in \\{2,3,\\dots,L_{\\max}\\}$，在 $C_{\\text{tot}}(\\ell_c) \\leq B$ 的约束下最小化 $E(\\ell_c)$。如果有多个极小值点，则选择其中最大的 $\\ell_c$。\n\n实现一个程序，该程序：\n- 使用频域球汉克尔函数及其在 $\\kappa = \\omega R$ 处的导数，为 Sommerfeld 边界条件计算 $R_\\ell$。\n- 根据给定的 $\\alpha$ 和 $L_{\\max}$ 构建归一化权重 $W_\\ell$。\n- 对每个 $\\ell_c \\in \\{2,3,\\dots,L_{\\max}\\}$ 计算 $E(\\ell_c)$ 和 $C_{\\text{tot}}(\\ell_c)$。\n- 根据上述优化规则选择 $\\ell_c$。\n- 对每个测试用例，返回序对 $[\\ell_c^\\star, E(\\ell_c^\\star)]$，其中 $\\ell_c^\\star$ 是选定的交叉点，$E(\\ell_c^\\star)$ 是对应的加权反射度量。\n\n所有量都是无量纲的，必须在几何单位制中处理。最终的数值输出必须是无单位的实数。角度单位是弧度。答案以小数表示。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果编码为一个二元列表 $[\\ell_c^\\star, E(\\ell_c^\\star)]$，例如 $[[3,0.012345],[2,0.004321]]$。\n\n使用以下测试套件，它涵盖了典型的BBH设置、远边界行为、高频内容和紧张的预算约束。每个测试用例是一个元组 $(L_{\\max}, R, \\omega, \\varepsilon, c_0, s_0, B, \\alpha)$：\n\n- 测试 $1$：$(8, 100, 0.1, 0.05, 10, 1, 300, 0.7)$。\n- 测试 $2$：$(8, 500, 0.1, 0.01, 10, 1, 150, 0.7)$。\n- 测试 $3$：$(10, 50, 0.2, 0.02, 8, 1, 120, 0.5)$。\n- 测试 $4$：$(12, 100, 0.15, 0.015, 12, 2, 80, 0.6)$。\n\n您的程序必须将这四个测试用例的结果聚合到上述的单行输出格式中。", "solution": "所提出的问题是一个定义明确的优化任务，其根源在于引力波传播的物理学以及用于模拟它们的数值方法。它在科学上是合理的，内部是一致的，并提供了所有必要的信息。因此，我将着手提供一个完整的解决方案。\n\n问题的核心是在数值模拟中为混合边界条件策略选择一个最佳的交叉多极子 $\\ell_c$。这一选择必须在计算成本 $C_{\\text{tot}}(\\ell_c)$ 与由加权反射度量 $E(\\ell_c)$ 衡量的物理精度之间取得平衡。该解决方案需要两个主要部分：首先，从第一性原理推导反射度量 $R_\\ell$；其次，实现指定的优化算法。\n\n### 1. 反射度量 $R_\\ell$ 的推导\n\n反射度量 $R_\\ell$ 量化了简单 Sommerfeld 边界条件的误差。它被定义为对于给定的球谐多极子 $\\ell$ 和频率 $\\omega$ 的复反射振幅 $\\mathcal{R}_\\ell$ 的绝对值。\n\n在频域中，考虑一个角频率为 $\\omega$ 的单色波分量。在远区，靠近半径为 $r=R$ 的外部边界处的标量场径向部分 $u_\\ell(r)$，可以表示为一个物理上的出射波和一个数值生成的、非物理的入射波的叠加：\n$$\nu_\\ell(R) = A_{\\text{out}} h_\\ell^{(1)}(\\kappa) + A_{\\text{in}} h_\\ell^{(2)}(\\kappa)\n$$\n在这里，$A_{\\text{out}}$ 和 $A_{\\text{in}}$ 分别是出射波和入射波的复振幅。函数 $h_\\ell^{(1)}(\\kappa)$ 和 $h_\\ell^{(2)}(\\kappa)$ 是第一类和第二类球汉克尔函数，它们代表出射和入射球面波。无量纲参数 $\\kappa$ 定义为 $\\kappa = kR = \\omega R$，因为我们在几何单位制中工作，其中光速 $c=1$，因此波数为 $k=\\omega$。\n\n在 $r=R$ 处场的径向导数是：\n$$\n\\frac{\\partial u_\\ell}{\\partial r}\\bigg|_{r=R} = k \\left( A_{\\text{out}} h_\\ell^{(1)\\prime}(\\kappa) + A_{\\text{in}} h_\\ell^{(2)\\prime}(\\kappa) \\right)\n$$\n其中撇号表示对自变量的微分，因子 $k$ 来自链式法则 $\\partial_r = k \\partial_\\kappa$。\n\n时域中的 Sommerfeld 边界条件是 $\\partial_t u_\\ell + \\partial_r u_\\ell = 0$。对于具有时间依赖性 $e^{-i\\omega t}$ 的单色波，这变换为频域条件：\n$$\n-i\\omega u_\\ell(R) + \\frac{\\partial u_\\ell}{\\partial r}\\bigg|_{r=R} = 0 \\implies \\frac{\\partial u_\\ell}{\\partial r}\\bigg|_{r=R} = i\\omega u_\\ell(R) = ik u_\\ell(R)\n$$\n将 $u_\\ell(R)$ 及其导数的表达式代入此边界条件，我们得到：\n$$\nk \\left( A_{\\text{out}} h_\\ell^{(1)\\prime}(\\kappa) + A_{\\text{in}} h_\\ell^{(2)\\prime}(\\kappa) \\right) = ik \\left( A_{\\text{out}} h_\\ell^{(1)}(\\kappa) + A_{\\text{in}} h_\\ell^{(2)}(\\kappa) \\right)\n$$\n因子 $k$ 被消去。我们现在可以重排方程以求解复反射振幅 $\\mathcal{R}_\\ell = A_{\\text{in}} / A_{\\text{out}}$，它是非物理入射波振幅与出射波振幅之比：\n$$\nA_{\\text{in}} \\left( h_\\ell^{(2)\\prime}(\\kappa) - i h_\\ell^{(2)}(\\kappa) \\right) = -A_{\\text{out}} \\left( h_\\ell^{(1)\\prime}(\\kappa) - i h_\\ell^{(1)}(\\kappa) \\right)\n$$\n$$\n\\mathcal{R}_\\ell = \\frac{A_{\\text{in}}}{A_{\\text{out}}} = - \\frac{h_\\ell^{(1)\\prime}(\\kappa) - i h_\\ell^{(1)}(\\kappa)}{h_\\ell^{(2)\\prime}(\\kappa) - i h_\\ell^{(2)}(\\kappa)}\n$$\n问题将反射度量 $R_\\ell$ 定义为此复振幅的绝对值：\n$$\nR_\\ell = |\\mathcal{R}_\\ell| = \\left| \\frac{h_\\ell^{(1)\\prime}(\\kappa) - i h_\\ell^{(1)}(\\kappa)}{h_\\ell^{(2)\\prime}(\\kappa) - i h_\\ell^{(2)}(\\kappa)} \\right|\n$$\n此公式是我们数值计算由 Sommerfeld 条件为每个多极子 $\\ell > \\ell_c$ 产生的反射的基础。对于使用精确边界条件的多极子 $\\ell \\le \\ell_c$，根据定义 $R_\\ell = 0$。\n\n### 2. 优化算法\n\n目标是根据一个两级优化规则，从整数集合 $\\{2, 3, \\dots, L_{\\max}\\}$ 中找到最佳的交叉点 $\\ell_c^\\star$。\n\n首先，我们必须为每个可能的 $\\ell_c$ 选择计算所有必要的量。\n多极子权重 $W_\\ell$ 按 $W_\\ell = N \\exp(-\\alpha(\\ell-2))$ 计算，其中 $\\ell \\in \\{2, \\dots, L_{\\max}\\}$，$N$ 是一个归一化常数，使得 $\\sum_{\\ell=2}^{L_{\\max}} W_\\ell = 1$。\n总成本 $C_{\\text{tot}}(\\ell_c)$ 和加权混合反射度量 $E(\\ell_c)$ 由下式给出：\n$$\nC_{\\text{tot}}(\\ell_c) = c_0\\left(\\frac{\\ell_c(\\ell_c+1)}{2} - 1\\right) + s_0\\left(L_{\\max} - \\ell_c\\right)\n$$\n$$\nE(\\ell_c) = \\sum_{\\ell=\\ell_c+1}^{L_{\\max}} W_\\ell R_\\ell\n$$\n算法流程如下：\n1. 对于一个给定的测试用例 $(L_{\\max}, R, \\omega, \\varepsilon, c_0, s_0, B, \\alpha)$，我们首先预计算从 $2$ 到 $L_{\\max}$ 的所有多极子 $\\ell$ 的反射度量 $R_\\ell$ 和权重 $W_\\ell$。球汉克尔函数 $h_\\ell^{(1)}, h_\\ell^{(2)}$ 及其导数使用 `scipy.special` 函数和标准的递推关系计算，例如 $f'_\\ell(z) = f_{\\ell-1}(z) - \\frac{\\ell+1}{z} f_\\ell(z)$，该关系对 $j_\\ell, y_\\ell$ 成立，因此也对 $h_\\ell^{(1,2)}$ 成立。\n2. 我们遍历交叉多极子 $\\ell_c$ 的所有可能选择，$\\ell_c \\in \\{2, 3, \\dots, L_{\\max}\\}$。对于每个 $\\ell_c$，我们计算 $C_{\\text{tot}}(\\ell_c)$ 和 $E(\\ell_c)$。\n3. **主优化：** 我们识别出“有效”解的集合，即所有满足 $E(\\ell_c) \\le \\varepsilon$ 和 $C_{\\text{tot}}(\\ell_c) \\le B$ 的 $\\ell_c$ 值。如果这个集合非空，最优选择 $\\ell_c^\\star$ 是该集合中*最小*的 $\\ell_c$。\n4. **次级优化：** 如果没有 $\\ell_c$ 满足这两个条件，我们退回到一个约束更少的问题。我们识别出“符合预算”解的集合，即所有满足 $C_{\\text{tot}}(\\ell_c) \\le B$ 的 $\\ell_c$。从这个集合中，我们找到可实现的最小反射度量 $E_{\\min} = \\min_{\\ell_c} E(\\ell_c)$。然后，最优选择 $\\ell_c^\\star$ 是在那些达到此最小误差 $E_{\\min}$ 的 $\\ell_c$ 中*最大*的一个。这条平局决胜规则倾向于在误差相同时将更精确的边界条件应用于更多的多极子。\n5. 该测试用例的最终结果是序对 $[\\ell_c^\\star, E(\\ell_c^\\star)]$。对所有测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Main function to solve the hybrid boundary condition optimization problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L_max, R, omega, epsilon, c0, s0, B, alpha)\n        (8, 100, 0.1, 0.05, 10, 1, 300, 0.7),\n        (8, 500, 0.1, 0.01, 10, 1, 150, 0.7),\n        (10, 50, 0.2, 0.02, 8, 1, 120, 0.5),\n        (12, 100, 0.15, 0.015, 12, 2, 80, 0.6),\n    ]\n\n    results = []\n    for case in test_cases:\n        L_max, R, omega, epsilon, c0, s0, B, alpha = case\n        \n        # Define the range of multipoles to consider\n        ls = np.arange(2, L_max + 1)\n        kappa = omega * R\n\n        # 1. Pre-compute Reflection Metric R_l and Weights W_l\n        \n        # Compute R_l for l in ls\n        Rs = {}\n        for l_val in ls:\n            # We need h_l and its derivative. The derivative can be found via a\n            # recurrence relation involving h_{l-1}.\n            # h_l'(z) = h_{l-1}(z) - (l+1)/z * h_l(z)\n            \n            # Spherical Hankel function of the first kind, h^(1)_l(kappa)\n            j_l = special.spherical_jn(l_val, kappa)\n            y_l = special.spherical_yn(l_val, kappa)\n            h1_l = j_l + 1j * y_l\n\n            # Spherical Hankel function of the first kind, h^(1)_{l-1}(kappa)\n            j_lm1 = special.spherical_jn(l_val - 1, kappa)\n            y_lm1 = special.spherical_yn(l_val - 1, kappa)\n            h1_lm1 = j_lm1 + 1j * y_lm1\n\n            # Derivative of h^(1)_l(kappa)\n            h1_l_prime = h1_lm1 - ((l_val + 1.0) / kappa) * h1_l\n\n            # Numerator of reflection coefficient formula\n            # Num = h_l^(1)' - i * h_l^(1)\n            num = h1_l_prime - 1j * h1_l\n            \n            # The denominator involves h^(2) and its derivative.\n            # h^(2) is the complex conjugate of h^(1).\n            h2_l = np.conj(h1_l)\n            h2_lm1 = np.conj(h1_lm1)\n            h2_l_prime = h2_lm1 - ((l_val + 1.0) / kappa) * h2_l\n            \n            # Denominator = h_l^(2)' - i * h_l^(2)\n            den = h2_l_prime - 1j * h2_l\n            \n            # Complex reflection amplitude and its magnitude (the metric R_l)\n            reflection_coeff = -num / den\n            Rs[l_val] = np.abs(reflection_coeff)\n\n        # Compute weights W_l for l in ls\n        unnormalized_Ws = np.exp(-alpha * (ls - 2))\n        normalization_factor = np.sum(unnormalized_Ws)\n        Ws = {l: w for l, w in zip(ls, unnormalized_Ws / normalization_factor)}\n        \n        # 2. Iterate through all possible l_c and evaluate cost and error\n        lc_candidates = np.arange(2, L_max + 1)\n        evaluated_options = []\n        for lc in lc_candidates:\n            # Total Cost C_tot(l_c)\n            sum_l = lc * (lc + 1) / 2.0 - 1.0 # Sum of l from 2 to lc\n            cost = c0 * sum_l + s0 * (L_max - lc)\n            \n            # Weighted Hybrid Reflection Metric E(l_c)\n            # Sum is over l > l_c\n            error = 0.0\n            for l_val in range(lc + 1, L_max + 1):\n                error += Ws[l_val] * Rs[l_val]\n\n            evaluated_options.append({'lc': lc, 'error': error, 'cost': cost})\n\n        # 3. Apply the optimization logic to find l_c_star\n\n        # Primary optimization: find smallest lc meeting both criteria\n        pass1_candidates = [opt for opt in evaluated_options if opt['cost'] = B and opt['error'] = epsilon]\n        \n        if pass1_candidates:\n            # Find the minimum lc among the valid candidates\n            best_lc = min(c['lc'] for c in pass1_candidates)\n            best_option = next(opt for opt in pass1_candidates if opt['lc'] == best_lc)\n        else:\n            # Secondary optimization: no candidate met both criteria\n            # Find lc that minimizes error, subject to budget, with tie-breaking\n            pass2_candidates = [opt for opt in evaluated_options if opt['cost'] = B]\n            \n            # This set is guaranteed to be non-empty for the given test cases\n            if not pass2_candidates:\n                # Fallback, though not expected to be reached.\n                # If no lc is within budget, the problem is ill-defined.\n                # For this implementation, this branch will not be hit.\n                results.append(None) \n                continue\n\n            # Find the minimum error among budget-compliant options\n            min_error = min(c['error'] for c in pass2_candidates)\n            \n            # Find all candidates that achieve this minimum error\n            min_error_candidates = [c for c in pass2_candidates if np.isclose(c['error'], min_error)]\n            \n            # Tie-breaking: choose the one with the largest lc\n            best_lc = max(c['lc'] for c in min_error_candidates)\n            best_option = next(opt for opt in min_error_candidates if opt['lc'] == best_lc)\n            \n        results.append([best_option['lc'], best_option['error']])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]},{res[1]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3482103"}]}