{"hands_on_practices": [{"introduction": "科恩-沈方程构成了一个复杂的非线性系统，其中有效势取决于电子密度，而电子密度又由求解该势得到的轨道所决定。这种相互依赖性使得迭代求解成为必需，这一过程被称为自洽场（Self-Consistent Field, SCF）循环。第一个实践练习将挑战你梳理出 SCF 过程的逻辑顺序，这是所有 DFT 软件核心的计算引擎。[@problem_id:1768566]", "problem": "在计算材料科学领域，Kohn-Sham密度泛函理论（DFT）是确定材料电子结构的一种强大方法。DFT计算的一个核心部分是一个称为自洽场（SCF）循环的迭代过程，其目的是找到基态电子密度。\n\n这个迭代循环包含一系列特定的计算步骤，这些步骤会重复执行，直到满足收敛标准。以下是在单次迭代中执行的三个核心任务，按字母顺序列出：\n\n(A) 通过对已占据的单粒子轨道的模平方求和，计算输出电子密度 $n_{\\text{out}}(\\mathbf{r})$。\n(B) 构建有效的Kohn-Sham势 $v_{\\text{eff}}(\\mathbf{r})$，该势是当前或上一次迭代的输入电子密度 $n_{\\text{in}}(\\mathbf{r})$ 的函数。\n(C) 针对当前的有效势，求解单粒子Kohn-Sham方程，以确定一组新的单粒子轨道 $\\{\\psi_j(\\mathbf{r})\\}$。\n\n给定在一次迭代开始时的输入密度 $n_{\\text{in}}(\\mathbf{r})$，请确定这三个任务的正确时间顺序，以便在该单次迭代内产生输出密度 $n_{\\text{out}}(\\mathbf{r})$。请从以下选项中选择正确的顺序。\n\nA. (A) $\\rightarrow$ (B) $\\rightarrow$ (C)\n\nB. (B) $\\rightarrow$ (A) $\\rightarrow$ (C)\n\nC. (C) $\\rightarrow$ (A) $\\rightarrow$ (B)\n\nD. (B) $\\rightarrow$ (C) $\\rightarrow$ (A)\n\nE. (A) $\\rightarrow$ (C) $\\rightarrow$ (B)\n\nF. (C) $\\rightarrow$ (B) $\\rightarrow$ (A)", "solution": "在密度泛函理论（DFT）中，自洽场（SCF）循环的目标是找到一个“自洽”的基态电子密度 $n(\\mathbf{r})$。这意味着，如果我们将此密度用作计算的输入，计算产生的输出密度将与输入密度相同。这个过程是迭代的，从一个初始猜测开始，并在每一步中优化密度，直到满足这个条件。让我们分析这三个任务之间的逻辑依赖关系，以确定它们的正确顺序。\n\n迭代循环从对电子密度的一个猜测开始，我们称之为输入密度 $n_{\\text{in}}(\\mathbf{r})$。\n\n步骤1：循环中的第一个任务必须是使用这个输入密度 $n_{\\text{in}}(\\mathbf{r})$ 来构建下一步所需的量。Kohn-Sham形式理论指出，有效势 $v_{\\text{eff}}(\\mathbf{r})$ 是电子密度的泛函。具体来说，$v_{\\text{eff}}[n](\\mathbf{r}) = v_{\\text{ext}}(\\mathbf{r}) + v_{\\text{H}}[n](\\mathbf{r}) + v_{\\text{xc}}[n](\\mathbf{r})$，其中Hartree势 $v_{\\text{H}}$ 和交换关联势 $v_{\\text{xc}}$ 都依赖于密度 $n(\\mathbf{r})$。因此，第一个逻辑步骤是使用 $n_{\\text{in}}(\\mathbf{r})$ 来计算 $v_{\\text{eff}}(\\mathbf{r})$。这对应于任务(B)。\n\n步骤2：一旦知道了有效势 $v_{\\text{eff}}(\\mathbf{r})$，就可以用它来定义单粒子Kohn-Sham哈密顿量 $\\hat{H}_{\\text{KS}} = -\\frac{\\hbar^2}{2m}\\nabla^2 + v_{\\text{eff}}(\\mathbf{r})$。下一步是求解该哈密顿量的本征值问题，即Kohn-Sham方程组：$\\hat{H}_{\\text{KS}} \\psi_j(\\mathbf{r}) = \\epsilon_j \\psi_j(\\mathbf{r})$。求解这些方程可以得到一组单粒子轨道 $\\{\\psi_j(\\mathbf{r})\\}$ 及其对应的能量 $\\{\\epsilon_j\\}$。这对应于任务(C)。任务(C)必须在任务(B)之后，因为它需要(B)中计算出的势。\n\n步骤3：求解Kohn-Sham方程后，我们就得到了轨道 $\\{\\psi_j(\\mathbf{r})\\}$。DFT的基本原理是电子密度可以由这些轨道构建。对于一个有 $N$ 个电子的体系，密度是通过对 $N$ 个能量最低的（已占据的）轨道的概率密度求和来计算的。这就得到了输出电子密度 $n_{\\text{out}}(\\mathbf{r}) = \\sum_{j=1}^{N} |\\psi_j(\\mathbf{r})|^2$。这对应于任务(A)。任务(A)必须在任务(C)之后，因为它需要(C)中计算出的轨道。\n\n总结一下单次迭代内的流程：\n1.  从 $n_{\\text{in}}(\\mathbf{r})$ 开始。\n2.  执行任务(B)：使用 $n_{\\text{in}}(\\mathbf{r})$ 构建 $v_{\\text{eff}}(\\mathbf{r})$。\n3.  执行任务(C)：使用 $v_{\\text{eff}}(\\mathbf{r})$ 求解轨道 $\\{\\psi_j(\\mathbf{r})\\}$。\n4.  执行任务(A)：使用轨道 $\\{\\psi_j(\\mathbf{r})\\}$ 计算输出密度 $n_{\\text{out}}(\\mathbf{r})$。\n\n因此，任务的正确顺序是 (B) $\\rightarrow$ (C) $\\rightarrow$ (A)。在此序列之后，SCF过程会将 $n_{\\text{out}}(\\mathbf{r})$ 与 $n_{\\text{in}}(\\mathbf{r})$ 进行比较，以检查是否收敛。如果没有收敛，将会生成一个新的 $n_{\\text{in}}(\\mathbf{r})$（通常通过混合旧的输入密度和新的输出密度），然后循环会重复。\n\n查看给出的选项，序列 (B) $\\rightarrow$ (C) $\\rightarrow$ (A) 对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1768566"}, {"introduction": "在建立了迭代式的 SCF 过程之后，我们现在将直面 DFT 最大的挑战之一：描述强电子关联。本实践将通过氢分子解离这一静态关联的经典例子，来探索科恩-沈近似方法的局限性，以及对称性破缺作为一种部分补救措施的概念。通过反演精确密度以找到相应的科恩-沈势，你将亲身体会到精确交换相关泛函为正确描述这类体系所必须具备的复杂结构，例如势阶和势峰。[@problem_id:3493930]", "problem": "考虑范式性的双格点哈伯德二聚体（Hubbard dimer）作为氢分子解离的最小模型，其中在拉伸过程中出现强电子关联。在科恩-沈密度泛函理论的格点表述框架内进行研究。全过程使用无量纲模型单位；无需进行物理单位转换。从以下基础出发：\n\n1. Hohenberg-Kohn 定理确立了在固定相互作用下，外部势与基态电子密度之间的一一对应关系（不计一个附加常数），而科恩-沈映射引入了一个无相互作用体系，该体系能够重现精确的有相互作用体系的基态密度。\n2. 具有自旋的两个电子的双格点哈伯德哈密顿量为\n$$\n\\hat{H} = -t \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( \\hat{c}_{1\\sigma}^\\dagger \\hat{c}_{2\\sigma} + \\hat{c}_{2\\sigma}^\\dagger \\hat{c}_{1\\sigma} \\right) + U \\sum_{i=1}^{2} \\hat{n}_{i\\uparrow} \\hat{n}_{i\\downarrow} + \\sum_{i=1}^{2} \\sum_{\\sigma} \\varepsilon_i \\hat{n}_{i\\sigma},\n$$\n其中 $\\varepsilon_1 = -\\Delta_{\\mathrm{ext}}/2$ 且 $\\varepsilon_2 = +\\Delta_{\\mathrm{ext}}/2$，跃迁振幅 $t \\ge 0$，在位相互作用 $U \\ge 0$，以及外势差 $\\Delta_{\\mathrm{ext}} \\in \\mathbb{R}$。自旋分辨的粒子数算符为 $\\hat{n}_{i\\sigma} = \\hat{c}_{i\\sigma}^\\dagger \\hat{c}_{i\\sigma}$。\n\n您的任务是通过比较限制性与对称性破缺的科恩-沈解，并识别交换关联势阶跃及其与解离的关系，来算法化地研究拉伸极限下的强关联。按以下步骤进行。\n\nA. 精确的有相互作用参考系：\n- 对于两个电子，通过在零温下对给定的 $(t, U, \\Delta_{\\mathrm{ext}})$ 对角化多体哈密顿量来计算精确基态。\n- 根据精确基态，计算格点占据数 $n_1$ 和 $n_2$ 以及格点占据数之差\n$$\n\\delta \\equiv n_1 - n_2,\n$$\n其中 $n_1 + n_2 = 2$。\n\nB. 采用仅哈特里近似的限制性科恩-沈（自旋非极化）：\n- 始终强制 $n_{i\\uparrow} = n_{i\\downarrow} = n_i/2$ 并构建有效科恩-沈势差\n$$\n\\Delta_{\\mathrm{eff}}(\\delta) = \\Delta_{\\mathrm{ext}} + \\Delta_H(\\delta),\n$$\n其中对势差的哈特里贡献为\n$$\n\\Delta_H(\\delta) = v_H(2) - v_H(1) = -\\frac{U}{2}\\,\\delta,\n$$\n这可由 $v_{H,\\sigma}(i) = U \\langle \\hat{n}_{i\\bar{\\sigma}} \\rangle = U n_i / 2$ 推导得出。\n- 势差为 $\\Delta_{\\mathrm{eff}}$、跃迁为 $t$ 的自旋非极化无相互作用双电子科恩-沈二聚体，其基态占据数之差由解析关系式给出\n$$\n\\delta_{\\mathrm{KS}}(\\Delta) = \\frac{2\\,\\Delta}{\\sqrt{\\Delta^2 + 4 t^2}}.\n$$\n- 通过施加 $\\delta_{\\mathrm{RKS}} = \\delta_{\\mathrm{KS}}(\\Delta_{\\mathrm{eff}}(\\delta_{\\mathrm{RKS}}))$，自洽求解限制性科恩-沈解 $\\delta_{\\mathrm{RKS}}$。\n\nC. 采用仅哈特里近似的非限制性科恩-沈（允许自旋对称性破缺）：\n- 允许 $n_{i\\uparrow}$ 和 $n_{i\\downarrow}$ 不同，并用自旋相关的势 $v_{i\\sigma} = \\varepsilon_i + U n_{i\\bar{\\sigma}}$ 求解自洽单粒子问题。用两个电子填充能量最低的两个科恩-沈本征态。\n- 迭代至不动点，并报告所得的非限制性科恩-沈格点占据数之差 $\\delta_{\\mathrm{UKS}} = (n_{1\\uparrow} + n_{1\\downarrow}) - (n_{2\\uparrow} + n_{2\\downarrow})$ 和最大自旋极化大小 $m_{\\max} = \\max\\{|m_1|, |m_2|\\}$，其中 $m_i = n_{i\\uparrow} - n_{i\\downarrow}$。定义一个布尔型对称性破缺标志 $\\mathrm{broken}$，如果 $m_{\\max} > 10^{-6}$ 则为真，否则为假。\n\nD. 科恩-沈反演与交换关联势阶跃：\n- 将精确的有相互作用格点占据数之差 $\\delta$ 反演为具有相同跃迁 $t$ 的无相互作用科恩-沈势差 $\\Delta_s$，使用\n$$\n\\delta = \\frac{2\\,\\Delta_s}{\\sqrt{\\Delta_s^2 + 4 t^2}},\n$$\n对于 $|\\delta|  2$，可得到显式反演\n$$\n\\Delta_s = \\frac{2\\,\\delta\\, t}{\\sqrt{4 - \\delta^2}}.\n$$\n- 将交换关联势阶跃计算为在考虑了外势和哈特里贡献后，为重现精确密度所需的残余部分：\n$$\n\\Delta_{xc} = \\Delta_s - \\Delta_{\\mathrm{ext}} - \\Delta_H(\\delta).\n$$\n\nE. 输出规格与测试套件：\n- 实现一个单一程序，对每个测试用例计算并返回元组\n$$\n\\left[ \\delta,\\ \\delta_{\\mathrm{RKS}},\\ \\delta_{\\mathrm{UKS}},\\ \\Delta_{xc},\\ \\mathrm{broken} \\right].\n$$\n- 您的程序应生成单行输出，其中包含一个由这些元组组成的、用方括号括起来的列表（例如 $[ \\ldots ]$）。\n- 使用以下旨在探测不同区域的测试套件：\n    1. 案例 1：$t = 1.0$, $U = 4.0$, $\\Delta_{\\mathrm{ext}} = 0.0$ (中等关联，对称)。\n    2. 案例 2：$t = 0.05$, $U = 4.0$, $\\Delta_{\\mathrm{ext}} = 0.5$ (拉伸，强关联，轻微不对称)。\n    3. 案例 3：$t = 0.5$, $U = 0.5$, $\\Delta_{\\mathrm{ext}} = 0.5$ (弱关联，不对称)。\n    4. 案例 4：$t = 0.05$, $U = 4.0$, $\\Delta_{\\mathrm{ext}} = 3.5$ (在拉伸极限下接近电荷转移阈值，但低于 $t \\to 0$ 的离子跃迁)。\n\n所有量均以哈密顿量定义的无量纲模型单位报告。本问题不涉及角度。请勿使用百分比；所有比率（若有）必须以小数形式给出。最终输出必须是单行，包含一个由四个案例结果组成的列表，每个案例结果本身也是一个按上述顺序排列的列表。", "solution": "用户提供了一个在理论材料科学领域内定义明确的计算问题，具体涉及格点密度泛函理论（DFT）在双格点哈伯德模型上的应用。\n\n### 步骤1：提取给定信息\n- **模型**：双电子的双格点哈伯德模型。\n- **哈密顿量**：$\\hat{H} = -t \\sum_{\\sigma \\in \\{\\uparrow,\\downarrow\\}} \\left( \\hat{c}_{1\\sigma}^\\dagger \\hat{c}_{2\\sigma} + \\hat{c}_{2\\sigma}^\\dagger \\hat{c}_{1\\sigma} \\right) + U \\sum_{i=1}^{2} \\hat{n}_{i\\uparrow} \\hat{n}_{i\\downarrow} + \\sum_{i=1}^{2} \\sum_{\\sigma} \\varepsilon_i \\hat{n}_{i\\sigma}$。\n- **参数**：跃迁振幅 $t \\ge 0$，在位相互作用 $U \\ge 0$，格点上的外势 $\\varepsilon_1 = -\\Delta_{\\mathrm{ext}}/2$ 和 $\\varepsilon_2 = +\\Delta_{\\mathrm{ext}}/2$。\n- **目标量**：\n    - 格点占据数：$n_1$, $n_2$。\n    - 格点占据数之差：$\\delta \\equiv n_1 - n_2$。约束条件：$n_1 + n_2 = 2$。\n    - 自旋极化：$m_i = n_{i\\uparrow} - n_{i\\downarrow}$。\n    - 对称性破缺标志：如果 $\\max\\{|m_1|, |m_2|\\} > 10^{-6}$，则 `broken` 为真。\n- **方法（A部分）**：精确对角化多体哈密顿量，求得基态并计算精确的格点占据数之差 $\\delta$。\n- **方法（B部分）**：采用仅哈特里近似的限制性科恩-沈（RKS）。\n    - 约束条件：$n_{i\\uparrow} = n_{i\\downarrow} = n_i/2$。\n    - 有效势差：$\\Delta_{\\mathrm{eff}}(\\delta) = \\Delta_{\\mathrm{ext}} + \\Delta_H(\\delta)$。\n    - 哈特里势差：$\\Delta_H(\\delta) = -\\frac{U}{2}\\,\\delta$。\n    - 自洽方程：$\\delta_{\\mathrm{RKS}} = \\delta_{\\mathrm{KS}}(\\Delta_{\\mathrm{eff}}(\\delta_{\\mathrm{RKS}}))$，其中 $\\delta_{\\mathrm{KS}}(\\Delta) = \\frac{2\\,\\Delta}{\\sqrt{\\Delta^2 + 4 t^2}}$。\n- **方法（C部分）**：采用仅哈特里近似的非限制性科恩-沈（UKS）。\n    - 求解具有自旋相关势 $v_{i\\sigma} = \\varepsilon_i + U n_{i\\bar{\\sigma}}$ 的自洽单粒子问题。\n- **方法（D部分）**：科恩-沈反演。\n    - 从精确的 $\\delta$ 反演到无相互作用势差 $\\Delta_s$：$\\Delta_s = \\frac{2\\,\\delta\\, t}{\\sqrt{4 - \\delta^2}}$，对于 $|\\delta|  2$。\n    - 计算交换关联势阶跃：$\\Delta_{xc} = \\Delta_s - \\Delta_{\\mathrm{ext}} - \\Delta_H(\\delta)$。\n- **测试套件**：\n    1. $t = 1.0, U = 4.0, \\Delta_{\\mathrm{ext}} = 0.0$\n    2. $t = 0.05, U = 4.0, \\Delta_{\\mathrm{ext}} = 0.5$\n    3. $t = 0.5, U = 0.5, \\Delta_{\\mathrm{ext}} = 0.5$\n    4. $t = 0.05, U = 4.0, \\Delta_{\\mathrm{ext}} = 3.5$\n- **输出格式**：单行元组列表：$[\\left[ \\delta,\\ \\delta_{\\mathrm{RKS}},\\ \\delta_{\\mathrm{UKS}},\\ \\Delta_{xc},\\ \\mathrm{broken} \\right], \\dots]$。\n\n### 步骤2：使用提取的给定信息进行验证\n- **科学上合理**：该问题是凝聚态物理和量子化学中的一个标准、经典的练习，用于阐释电子关联、DFT和对称性破缺等基本概念。所有原理和方程（哈伯德模型、科恩-沈方程、哈特里近似）都已得到公认。\n- **定义明确**：问题结构清晰，每个部分都有唯一解。提供了方程，任务是顺序的，测试用例定义明确。\n- **客观性**：问题以精确的数学语言陈述。没有歧义、主观性或个人观点。\n- **完整性**：为进行计算提供了所有必要的公式、参数和条件。\n- **一致性**：定义和约束是自洽的。例如，总电子数守恒（$n_1+n_2=2$），并且明确定义了各种势之间的关系。\n\n### 步骤3：判断与行动\n该问题是**有效的**。它是一个严谨且定义明确的科学问题。我现在将提供完整的解决方案。\n\n### 解决方案\n\n该解决方案通过将问题分解为指定的A、B、C和D部分，然后为每个测试用例执行这些步骤来实现。\n\n**A. 精确的有相互作用参考系**\n该双电子体系的基态是一个自旋单重态。哈密顿量可以表示为一个在单重态基矢 $\\{|\\psi_{\\text{ion},1}\\rangle, |\\psi_{\\text{ion},2}\\rangle, |\\psi_{\\text{cov}}\\rangle\\}$ 下的 $3 \\times 3$ 矩阵，其中 $|\\psi_{\\text{ion},1}\\rangle = \\hat{c}_{1\\uparrow}^\\dagger\\hat{c}_{1\\downarrow}^\\dagger|0\\rangle$（两个电子都在格点1上），$|\\psi_{\\text{ion},2}\\rangle = \\hat{c}_{2\\uparrow}^\\dagger\\hat{c}_{2\\downarrow}^\\dagger|0\\rangle$（两个电子都在格点2上），以及 $|\\psi_{\\text{cov}}\\rangle = \\frac{1}{\\sqrt{2}}(\\hat{c}_{1\\uparrow}^\\dagger\\hat{c}_{2\\downarrow}^\\dagger - \\hat{c}_{1\\downarrow}^\\dagger\\hat{c}_{2\\uparrow}^\\dagger)|0\\rangle$（每个格点上有一个电子）。哈密顿量矩阵为：\n$$\nH_S = \\begin{pmatrix}\nU - \\Delta_{\\mathrm{ext}}  0  \\sqrt{2}t \\\\\n0  U + \\Delta_{\\mathrm{ext}}  -\\sqrt{2}t \\\\\n\\sqrt{2}t  -\\sqrt{2}t  0\n\\end{pmatrix}\n$$\n我们通过数值对角化找到基态本征矢量 $|\\Psi_{GS}\\rangle = c_1 |\\psi_{\\text{ion},1}\\rangle + c_2 |\\psi_{\\text{ion},2}\\rangle + c_3 |\\psi_{\\text{cov}}\\rangle$。格点占据数为 $n_1 = \\langle \\Psi_{GS} |\\hat{n}_1|\\Psi_{GS} \\rangle = 2|c_1|^2 + |c_3|^2$ 和 $n_2 = 2|c_2|^2 + |c_3|^2$。精确的格点占据数之差为 $\\delta = n_1 - n_2 = 2(|c_1|^2 - |c_2|^2)$。\n\n**B. 限制性科恩-沈（RKS）**\nRKS解 $\\delta_{\\mathrm{RKS}}$ 是通过求解自洽方程 $\\delta = \\delta_{\\mathrm{KS}}(\\Delta_{\\mathrm{eff}}(\\delta))$ 找到的。这可以重写为关于 $\\delta$ 的求根问题：\n$$\nf(\\delta) = \\frac{2t\\delta}{\\sqrt{4 - \\delta^2}} - \\left(\\Delta_{\\mathrm{ext}} - \\frac{U\\delta}{2}\\right) = 0\n$$\n在区间 $(-2, 2)$ 内对 $\\delta_{\\mathrm{RKS}}$ 进行数值求解。\n\n**C. 非限制性科恩-沈（UKS）**\nUKS 计算允许自旋极化（$n_{i\\uparrow} \\neq n_{i\\downarrow}$）。我们迭代求解自洽场（SCF）问题。\n1. 初始化自旋密度 $n_{i\\sigma}$，通常带有一个小的对称性破缺微扰。\n2. 构建自旋相关的科恩-沈哈密顿量 $H_{\\mathrm{KS},\\sigma}$，其中格点 $i$ 上自旋为 $\\sigma$ 的势为 $v_{i\\sigma} = \\varepsilon_i + U n_{i\\bar{\\sigma}}$。\n3. 对角化两个 $2 \\times 2$ 矩阵 $H_{\\mathrm{KS},\\uparrow}$ 和 $H_{\\mathrm{KS},\\downarrow}$，得到四个自旋轨道及其能量。\n4. 用两个电子占据能量最低的两个自旋轨道。\n5. 从占据的轨道计算新的自旋密度 $n_{i\\sigma}$。\n6. 将新密度与旧密度混合，并从步骤2开始重复，直到收敛。\n从收敛的密度中，我们计算 $\\delta_{\\mathrm{UKS}}=(n_{1\\uparrow}+n_{1\\downarrow}) - (n_{2\\uparrow}+n_{2\\downarrow})$ 和最大自旋极化 $m_{\\max} = \\max_i |n_{i\\uparrow}-n_{i\\downarrow}|$。\n\n**D. 科恩-沈反演与交换关联势阶跃**\n使用A部分得到的精确密度差 $\\delta$，我们首先计算在无相互作用体系中产生此 $\\delta$ 所需的相应科恩-沈势差 $\\Delta_s$：\n$$\n\\Delta_s = \\frac{2\\,\\delta\\, t}{\\sqrt{4 - \\delta^2}}\n$$\n交换关联势阶跃 $\\Delta_{xc}$ 是 $\\Delta_s$ 中未被外势 $\\Delta_{\\mathrm{ext}}$ 或哈特里势 $\\Delta_H(\\delta) = -U\\delta/2$ 解释的部分：\n$$\n\\Delta_{xc} = \\Delta_s - \\Delta_{\\mathrm{ext}} - \\Delta_H(\\delta)\n$$\n这个量是DFT中诊断强关联效应的关键指标。\n\n最终的程序为每个测试用例实现这四个步骤，并按规定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve_case(t, U, delta_ext):\n    \"\"\"\n    Solves the two-site Hubbard model problem for a given parameter set.\n    \n    Args:\n        t (float): Hopping amplitude.\n        U (float): On-site interaction strength.\n        delta_ext (float): External potential difference.\n    \n    Returns:\n        list: A list containing [delta_exact, delta_rks, delta_uks, delta_xc, is_broken].\n    \"\"\"\n    # Part A: Exact interacting reference\n    delta_exact = calculate_exact_delta(t, U, delta_ext)\n\n    # Part B: Restricted Kohn-Sham (RKS)\n    delta_rks = solve_rks(t, U, delta_ext)\n\n    # Part C: Unrestricted Kohn-Sham (UKS)\n    delta_uks, m_max = solve_uks(t, U, delta_ext)\n    is_broken = m_max > 1e-6\n\n    # Part D: Kohn-Sham inversion and exchange-correlation step\n    delta_xc = calculate_xc_potential(t, U, delta_ext, delta_exact)\n\n    return [delta_exact, delta_rks, delta_uks, delta_xc, is_broken]\n\ndef calculate_exact_delta(t, U, delta_ext):\n    \"\"\"\n    Part A: Computes the exact ground state and site-occupation difference.\n    \"\"\"\n    H_S = np.array([\n        [U - delta_ext, 0, np.sqrt(2) * t],\n        [0, U + delta_ext, -np.sqrt(2) * t],\n        [np.sqrt(2) * t, -np.sqrt(2) * t, 0]\n    ])\n    \n    eigvals, eigvecs = np.linalg.eigh(H_S)\n    \n    gs_index = np.argmin(eigvals)\n    c_ion1, c_ion2, _ = eigvecs[:, gs_index]\n    \n    delta = 2 * (c_ion1**2 - c_ion2**2)\n    return delta\n\ndef solve_rks(t, U, delta_ext):\n    \"\"\"\n    Part B: Solves the self-consistent restricted Kohn-Sham equation.\n    \"\"\"\n    def rks_equation(delta, t, U, delta_ext):\n        if abs(abs(delta) - 2.0)  1e-14:\n            return np.sign(delta) * 1e14\n        \n        delta_s = (2 * t * delta) / np.sqrt(4 - delta**2)\n        delta_eff = delta_ext - (U * delta / 2.0)\n        return delta_s - delta_eff\n\n    try:\n        result = root_scalar(rks_equation, args=(t, U, delta_ext), bracket=(-1.99999999, 1.99999999))\n        return result.root\n    except ValueError:\n        # Fallback for cases where root is not bracketed, e.g. multiple solutions.\n        # Simple fixed-point iteration with mixing can be more robust.\n        delta_k = 0.0\n        for _ in range(500):\n            delta_eff = delta_ext - U * delta_k / 2.0\n            if abs(t)  1e-15:\n                delta_new = 2.0 * np.sign(delta_eff) if delta_eff != 0 else 0.0\n            else:\n                denominator = np.sqrt(delta_eff**2 + 4 * t**2)\n                delta_new = (2 * delta_eff) / denominator if denominator > 0 else 0.0\n            \n            if abs(delta_new - delta_k)  1e-10:\n                return delta_new\n            delta_k = 0.5 * delta_k + 0.5 * delta_new\n        return delta_k\n\n\ndef solve_uks(t, U, delta_ext):\n    \"\"\"\n    Part C: Solves the self-consistent unrestricted Kohn-Sham problem.\n    \"\"\"\n    # Initial guess with a small antiferromagnetic perturbation to break symmetry\n    n = np.array([0.50001, 0.49999, 0.49999, 0.50001])\n    eps1, eps2 = -delta_ext / 2.0, delta_ext / 2.0\n    \n    for _ in range(500):\n        n_old = n.copy()\n        n_1_up, n_1_down, n_2_up, n_2_down = n\n        \n        v_1_up, v_2_up = eps1 + U * n_1_down, eps2 + U * n_2_down\n        v_1_down, v_2_down = eps1 + U * n_1_up, eps2 + U * n_2_up\n        \n        H_up = np.array([[v_1_up, -t], [-t, v_2_up]])\n        H_down = np.array([[v_1_down, -t], [-t, v_2_down]])\n        \n        evals_up, evecs_up = np.linalg.eigh(H_up)\n        evals_down, evecs_down = np.linalg.eigh(H_down)\n        \n        ks_states = [\n            (evals_up[0], evecs_up[:, 0], 'up'), (evals_up[1], evecs_up[:, 1], 'up'),\n            (evals_down[0], evecs_down[:, 0], 'down'), (evals_down[1], evecs_down[:, 1], 'down'),\n        ]\n        \n        ks_states.sort(key=lambda x: x[0])\n        occupied = ks_states[:2]\n        \n        n_new = np.zeros(4)\n        for _, evec, spin in occupied:\n            idx_offset = 0 if spin == 'up' else 1\n            n_new[idx_offset] += evec[0]**2\n            n_new[idx_offset+2] += evec[1]**2\n        \n        if np.linalg.norm(n_new - n_old)  1e-10:\n            n = n_new\n            break\n            \n        n = 0.5 * n_new + 0.5 * n_old\n    \n    n_1_up, n_1_down, n_2_up, n_2_down = n\n    delta_uks = (n_1_up + n_1_down) - (n_2_up + n_2_down)\n    m_max = max(abs(n_1_up - n_1_down), abs(n_2_up - n_2_down))\n    \n    return delta_uks, m_max\n\ndef calculate_xc_potential(t, U, delta_ext, delta_exact):\n    \"\"\"\n    Part D: Computes the exchange-correlation potential step.\n    \"\"\"\n    sqrt_arg = 4 - delta_exact**2\n    if sqrt_arg = 1e-14:\n        delta_s = np.inf * np.sign(delta_exact) if delta_exact != 0 else 0\n    else:\n        delta_s = (2 * delta_exact * t) / np.sqrt(sqrt_arg)\n        \n    delta_H = -U * delta_exact / 2.0\n    delta_xc = delta_s - delta_ext - delta_H\n    \n    return delta_xc\n\ndef solve():\n    test_cases = [\n        (1.0, 4.0, 0.0),  # Case 1\n        (0.05, 4.0, 0.5), # Case 2\n        (0.5, 0.5, 0.5),  # Case 3\n        (0.05, 4.0, 3.5), # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        t, U, delta_ext = case\n        result = solve_case(t, U, delta_ext)\n        results.append(result)\n\n    # Format output to match requested string representation of a list of lists.\n    # Eg: [[-0.0, 0.0, 0.0, -0.0, False], ...]\n    list_of_strs = []\n    for res_tuple in results:\n        # Convert each item in the tuple to a string, format floats\n        item_strs = []\n        for item in res_tuple:\n            if isinstance(item, bool):\n                item_strs.append(str(item))\n            else: # float\n                # Use a format that avoids -0.0 for small numbers\n                if abs(item)  1e-12: item = 0.0\n                item_strs.append(f\"{item:.15g}\")\n        \n        list_of_strs.append(f\"[{','.join(item_strs)}]\")\n\n    print(f\"[{','.join(list_of_strs)}]\")\n\nsolve()\n```", "id": "3493930"}, {"introduction": "除了静态关联，近似 DFT 中另一个普遍存在的问题是离域误差（delocalization error），其根源在于电子自相互作用未能被完全抵消。该误差表现为总能量在整数粒子数之间偏离了精确的逐段线性条件。在此练习中，你将为一个模型体系和一个简单的局域泛函定量地评估这种偏离，并将能量曲线的曲率与交换相关势的空间非均匀性行为直接联系起来，后者是这一基本缺陷的标志。[@problem_id:3493889]", "problem": "考虑一个简化的Kohn-Sham密度泛函理论(DFT)公式，应用于一个石墨烯纳米带。该纳米带被模型化为一个具有$M$个格点、开放边界条件以及大小为$t>0$的最近邻跃迁的一维紧束缚链。Kohn-Sham (KS) 单粒子哈密顿量由下式给出\n$$\n\\hat{H}_{\\mathrm{KS}}[n] = \\hat{H}_0 + \\sum_{i=1}^{M} v_{\\mathrm{s},i}[n] \\, \\lvert i \\rangle \\langle i \\rvert,\n$$\n其中动能（紧束缚）部分为\n$$\n\\hat{H}_0 = -t \\sum_{i=1}^{M-1} \\left( \\lvert i \\rangle \\langle i+1 \\rvert + \\lvert i+1 \\rangle \\langle i \\rvert \\right),\n$$\n并且KS势是局域的，定义为\n$$\nv_{\\mathrm{s},i}[n] = v_{\\mathrm{ext},i} + v_{\\mathrm{H},i}[n] + v_{\\mathrm{xc},i}[n].\n$$\n假设外势为零，因此对于所有格点$i$，$v_{\\mathrm{ext},i}=0$。采用一个局域Hartree模型$v_{\\mathrm{H},i}[n] = U \\, n_i$（其中$U \\ge 0$）和一个局域交换相关(XC)势。该势由一个格点局域的交换相关能$E_{\\mathrm{xc}}[n]$导出，其定义为\n$$\nE_{\\mathrm{xc}}[n] = -\\alpha \\sum_{i=1}^{M} n_i^{\\beta},\n$$\n参数为$\\alpha \\ge 0$和$\\beta > 1$。相应的交换相关势由泛函导数给出\n$$\nv_{\\mathrm{xc},i}[n] = \\frac{\\partial E_{\\mathrm{xc}}[n]}{\\partial n_i} = -\\alpha \\beta \\, n_i^{\\beta - 1}.\n$$\n将电子视为无自旋的，并使用系综Kohn-Sham理论来处理分数电子数$N$。对于给定的总电子数$N$，定义$N = \\lfloor N \\rfloor + f$，其中$f \\in [0,1)$，并完全占据能量最低的$\\lfloor N \\rfloor$个Kohn-Sham轨道，同时以占据数$f$分数占据下一个轨道。格点密度为\n$$\nn_i = \\sum_{k} f_k \\, \\lvert \\psi_k(i) \\rvert^2,\n$$\n其中$\\psi_k(i)$是归一化的第$k$个Kohn-Sham本征矢量的第$i$个分量，而$f_k$是其占据数。\n\n总能量泛函的计算公式为\n$$\nE[n] = T_{\\mathrm{s}}[n] + E_{\\mathrm{H}}[n] + E_{\\mathrm{xc}}[n],\n$$\n其中无相互作用动能为\n$$\nT_{\\mathrm{s}}[n] = \\sum_{k} f_k \\, \\langle \\psi_k \\lvert \\hat{H}_0 \\rvert \\psi_k \\rangle,\n$$\nHartree能量为\n$$\nE_{\\mathrm{H}}[n] = \\frac{U}{2} \\sum_{i=1}^{M} n_i^2,\n$$\n以及如上定义的交换相关能$E_{\\mathrm{xc}}[n]$。所有能量都以$t$为单位表示，因此是无量纲的；所有输出都应报告为无量纲数。\n\n实现一个自洽场(SCF)算法：对于给定的$N$，从一个初始猜测$n^{(0)}_i$（例如，均匀分布$n^{(0)}_i = N/M$）开始，迭代计算$v_{\\mathrm{s},i}[n^{(m)}]$，对角化$\\hat{H}_{\\mathrm{KS}}[n^{(m)}]$以获得$\\{ \\psi_k^{(m)}, \\varepsilon_k^{(m)} \\}$，根据轨道占据数重新计算$n^{(m+1)}_i$，并对某个混合参数$0  \\lambda  1$使用密度混合$n^{(m+1)} \\leftarrow (1-\\lambda) n^{(m)} + \\lambda \\, \\tilde{n}^{(m+1)}$，直到收敛$\\max_i \\lvert n^{(m+1)}_i - n^{(m)}_i \\rvert  \\epsilon$。\n\n使用系综DFT，已知精确能量$E(N)$在整数之间是分段线性的。对分段线性的偏离表明交换相关(XC)势$v_{\\mathrm{xc}}$中存在离域误差。为对上述局域泛函进行数值量化，通过中心有限差分近似计算在整数$N_0$处的曲率\n$$\n\\kappa(N_0) \\approx \\frac{E(N_0 + \\delta) - 2 E(N_0) + E(N_0 - \\delta)}{\\delta^2},\n$$\n其中$0  \\delta  1$是一个小数。此外，通过以下方式量化在增加/移除一个分数电子时交换相关势变化的空间非均匀性\n$$\nS_{\\mathrm{xc}}(N_0,\\delta) = \\mathrm{StdDev}\\left( \\Delta v_{\\mathrm{xc},i} \\right), \\quad \\Delta v_{\\mathrm{xc},i} = v_{\\mathrm{xc},i}(N_0+\\delta) - v_{\\mathrm{xc},i}(N_0-\\delta),\n$$\n其中$\\mathrm{StdDev}$表示对所有格点$i=1,\\dots,M$的标准差。在精确理论中，交换相关势表现出空间上恒定的导数不连续性；因此，较大的$S_{\\mathrm{xc}}$意味着更大的离域误差。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 为给定参数实现上述KS-SCF方案。\n- 在$N_0 - \\delta$、$N_0$和$N_0 + \\delta$处计算$E(N)$。\n- 计算$\\kappa(N_0)$和$S_{\\mathrm{xc}}(N_0,\\delta)$。\n- 汇总多个测试用例的结果。\n\n测试套件（所有能量均以$t$为单位，是无量纲的）：\n1. $M=16$, $t=1.0$, $U=1.0$, $\\alpha=0.6$, $\\beta=1.5$, $N_0=8.0$, $\\delta=0.25$, $\\lambda=0.25$, $\\epsilon=10^{-8}$。\n2. $M=16$, $t=1.0$, $U=0.0$, $\\alpha=0.0$, $\\beta=1.5$, $N_0=8.0$, $\\delta=0.25$, $\\lambda=0.25$, $\\epsilon=10^{-8}$。\n3. $M=16$, $t=1.0$, $U=2.0$, $\\alpha=0.3$, $\\beta=1.3$, $N_0=8.0$, $\\delta=0.25$, $\\lambda=0.25$, $\\epsilon=10^{-8}$。\n4. $M=16$, $t=1.0$, $U=1.5$, $\\alpha=0.9$, $\\beta=1.7$, $N_0=8.0$, $\\delta=0.25$, $\\lambda=0.25$, $\\epsilon=10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是对应测试用例的双元素列表$[\\kappa, S_{\\mathrm{xc}}]$（例如，$[[\\kappa_1,S_1],[\\kappa_2,S_2],\\dots]$）。", "solution": "该问题被评估为有效，因为它科学地基于Kohn-Sham密度泛函理论（KS-DFT）的原理，问题设定良好，目标明确，信息充分，并且没有矛盾或含糊之处。任务是为一个一维模型系统实现自洽场（SCF）计算，并使用计算结果来量化一个近似交换相关泛函的离域误差。\n\n该解决方案通过以下步骤实现：\n1.  设计一个函数，用于对一组给定的系统参数（$M, t, U, \\alpha, \\beta$）和一个特定的总电子数$N$执行SCF计算。该函数返回收敛的总能量$E(N)$和收敛的交换相关（XC）势$\\{v_{\\mathrm{xc},i}\\}$。\n2.  对每个测试用例，该SCF函数被调用三次，以获得电子数为$N_0 - \\delta$、$N_0$和$N_0 + \\delta$时的必要量。\n3.  使用得到的能量和势，通过所提供的有限差分公式计算曲率$\\kappa(N_0)$和XC势的非均匀性$S_{\\mathrm{xc}}(N_0, \\delta)$。\n4.  汇总所有测试用例的结果，并将其格式化为所需的输出字符串。\n\n解决方案的核心是SCF过程，它迭代地求解Kohn-Sham方程。\n\n**1. Kohn-Sham哈密顿量构建**\n\n对于SCF循环的每次迭代$m$，从一个格点电子密度$n^{(m)} = \\{n_i^{(m)}\\}_{i=1}^M$开始，构建Kohn-Sham势$v_{\\mathrm{s},i}[n^{(m)}]$。在外势为零（$v_{\\mathrm{ext},i}=0$）的情况下，它是Hartree势和XC势的和：\n$$\nv_{\\mathrm{s},i}[n^{(m)}] = v_{\\mathrm{H},i}[n^{(m)}] + v_{\\mathrm{xc},i}[n^{(m)}] = U n_i^{(m)} - \\alpha \\beta (n_i^{(m)})^{\\beta - 1}\n$$\n然后组装Kohn-Sham哈密顿矩阵$\\mathbf{H}_{\\mathrm{KS}}$。它是一个$M \\times M$矩阵，其中$M$是格点数。其矩阵元由下式给出：\n$$\n(\\mathbf{H}_{\\mathrm{KS}}[n^{(m)}])_{ij} = \\langle i \\rvert \\hat{H}_0 \\rvert j \\rangle + \\delta_{ij} v_{\\mathrm{s},j}[n^{(m)}]\n$$\n第一项是紧束缚动能哈密顿量，它是一个三对角矩阵，其对角元为0，最近邻的非对角元为$-t$。第二项将局域KS势加到对角线上。\n\n**2. 对角化与密度更新**\n\n对KS哈密顿矩阵进行对角化，以找到其本征值$\\{\\varepsilon_k^{(m)}\\}$（Kohn-Sham轨道能）和本征矢量$\\{\\psi_k^{(m)}\\}$（Kohn-Sham轨道）。\n$$\n\\mathbf{H}_{\\mathrm{KS}}[n^{(m)}] \\psi_k^{(m)} = \\varepsilon_k^{(m)} \\psi_k^{(m)}\n$$\n这些轨道的占据数$f_k$是根据总电子数$N$并使用系综DFT方法确定的。我们找到整数部分$N_{\\mathrm{int}} = \\lfloor N \\rfloor$和分数部分$f_{\\mathrm{frac}} = N - N_{\\mathrm{int}}$。能量最低的$N_{\\mathrm{int}}$个轨道被完全占据（$f_k=1$），下一个轨道（最高已占分子轨道，即HOMO）被分数占据，占据数为$f_{\\mathrm{HOMO}} = f_{\\mathrm{frac}}$，所有能量更高的轨道都是空的（$f_k=0$）。\n\n通过对已占轨道的贡献求和，计算出一个新的试探密度，记为$\\tilde{n}^{(m+1)}$：\n$$\n\\tilde{n}_i^{(m+1)} = \\sum_{k=1}^{M} f_k \\lvert \\psi_k^{(m)}(i) \\rvert^2\n$$\n其中$\\psi_k^{(m)}(i)$是第$k$个本征矢量的第$i$个分量。\n\n**3. 密度混合与收敛**\n\n为稳定SCF过程并确保收敛，下一次迭代的密度$n^{(m+1)}$通过将旧密度$n^{(m)}$和新的试探密度$\\tilde{n}^{(m+1)}$进行线性混合得到：\n$$\nn^{(m+1)}_i = (1 - \\lambda) n^{(m)}_i + \\lambda \\tilde{n}^{(m+1)}_i\n$$\n其中$\\lambda$是一个混合参数（$0  \\lambda  1$）。迭代过程持续进行，直到连续迭代之间的密度变化小于阈值$\\epsilon$：\n$$\n\\max_{i} \\lvert n_i^{(m+1)} - n_i^{(m)} \\rvert  \\epsilon\n$$\n\n**4. 总能量计算**\n\n一旦密度收敛到$n_{\\mathrm{conv}}$，就计算总能量$E[n_{\\mathrm{conv}}]$。使用一个计算上更高效的公式，该公式由给定的能量分量（$T_s, E_H, E_{xc}$）以及动能和KS本征值之间的关系（$T_s = \\sum_k f_k \\varepsilon_k - \\sum_i v_{s,i} n_i$）推导得出：\n$$\nE[n] = \\sum_{k} f_k \\varepsilon_k - E_{\\mathrm{H}}[n] + \\left( E_{\\mathrm{xc}}[n] - \\sum_{i=1}^{M} v_{\\mathrm{xc},i}[n] \\, n_i \\right)\n$$\n代入Hartree和XC泛函的具体形式：\n$$\nE[n] = \\sum_{k} f_k \\varepsilon_k - \\frac{U}{2} \\sum_{i=1}^{M} n_i^2 - \\alpha \\sum_{i=1}^{M} n_i^{\\beta} - \\sum_{i=1}^{M} \\left(-\\alpha \\beta n_i^{\\beta-1}\\right) n_i\n$$\n$$\nE[n] = \\sum_{k} f_k \\varepsilon_k - \\frac{U}{2}\\sum_{i=1}^{M} n_i^2 + \\alpha(\\beta-1)\\sum_{i=1}^{M} n_i^\\beta\n$$\n这里，$\\{\\varepsilon_k\\}$和$\\{n_i\\}$是对应于完全收敛状态的本征值和格点密度。\n\n**5. 最终分析**\n\n在对$N_0 - \\delta$、$N_0$和$N_0 + \\delta$执行SCF计算以获得$E(N_0 - \\delta)$、$E(N_0)$、$E(N_0 + \\delta)$以及相应的XC势之后，计算最终的量。\n曲率$\\kappa(N_0)$使用中心有限差分公式近似计算：\n$$\n\\kappa(N_0) \\approx \\frac{E(N_0 + \\delta) - 2 E(N_0) + E(N_0 - \\delta)}{\\delta^2}\n$$\nXC势变化的非均匀性$S_{\\mathrm{xc}}(N_0,\\delta)$是在$N_0+\\delta$和$N_0-\\delta$计算中收敛的XC势之差的标准差：\n$$\n\\Delta v_{\\mathrm{xc},i} = v_{\\mathrm{xc},i}[n(N_0+\\delta)] - v_{\\mathrm{xc},i}[n(N_0-\\delta)]\n$$\n$$\nS_{\\mathrm{xc}}(N_0,\\delta) = \\mathrm{StdDev}(\\{\\Delta v_{\\mathrm{xc},i}\\}_{i=1}^M)\n$$\n对问题陈述中指定的每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It orchestrates the SCF calculations and computes the final metrics.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (M, t, U, alpha, beta, N0, delta, lambda, epsilon)\n        (16, 1.0, 1.0, 0.6, 1.5, 8.0, 0.25, 0.25, 1e-8),\n        (16, 1.0, 0.0, 0.0, 1.5, 8.0, 0.25, 0.25, 1e-8),\n        (16, 1.0, 2.0, 0.3, 1.3, 8.0, 0.25, 0.25, 1e-8),\n        (16, 1.0, 1.5, 0.9, 1.7, 8.0, 0.25, 0.25, 1e-8),\n    ]\n\n    def run_scf_calculation(M, t, U, alpha, beta, N, lamb, epsilon, max_iter=500):\n        \"\"\"\n        Performs a self-consistent field (SCF) calculation for a given set of\n        parameters and a total electron number N.\n\n        Returns:\n            tuple: A tuple containing the converged total energy (float) and\n                   the converged exchange-correlation potential (1D numpy array).\n        \"\"\"\n        # Kinetic Hamiltonian matrix (time-independent part)\n        H0 = -t * (np.diag(np.ones(M - 1), 1) + np.diag(np.ones(M - 1), -1))\n\n        # Initial guess for the site-electron density\n        n = np.full(M, N / M, dtype=np.float64)\n\n        for _ in range(max_iter):\n            n_old = n.copy()\n\n            # 1. Construct KS potential and Hamiltonian from current density n\n            v_H = U * n_old\n            # The condition beta > 1 ensures beta-1 > 0, so n=0 is handled correctly.\n            v_xc = -alpha * beta * np.power(n_old, beta - 1, where=n_old > 0, out=np.zeros_like(n_old))\n            v_s = v_H + v_xc\n            H_ks = H0 + np.diag(v_s)\n\n            # 2. Diagonalize to get orbitals (eigenvectors) and orbital energies (eigenvalues)\n            eigvals, eigvecs = np.linalg.eigh(H_ks)\n\n            # 3. Determine orbital occupations and calculate the new trial density\n            N_int = int(np.floor(N))\n            f_frac = N - N_int\n            occupations = np.zeros(M)\n            if N_int > 0:\n                occupations[:N_int] = 1.0\n            if N_int  M:\n                occupations[N_int] = f_frac\n            \n            n_tilde = np.sum(eigvecs**2 * occupations, axis=1)\n\n            # 4. Mix densities for the next iteration\n            n = (1 - lamb) * n_old + lamb * n_tilde\n            \n            # 5. Check for convergence\n            if np.max(np.abs(n - n_old))  epsilon:\n                break\n        \n        # After convergence, calculate final quantities using the converged density 'n'\n        # to ensure all components are consistent.\n        \n        # Final KS potential and Hamiltonian\n        v_H_final = U * n\n        v_xc_final = -alpha * beta * np.power(n, beta - 1, where=n > 0, out=np.zeros_like(n))\n        v_s_final = v_H_final + v_xc_final\n        H_ks_final = H0 + np.diag(v_s_final)\n        \n        # Final diagonalization to get consistent eigenvalues\n        eigvals_final, _ = np.linalg.eigh(H_ks_final)\n        \n        # Final occupations (determined by N, constant throughout the SCF for a given N)\n        N_int_final = int(np.floor(N))\n        f_frac_final = N - N_int_final\n        occupations_final = np.zeros(M)\n        if N_int_final > 0:\n            occupations_final[:N_int_final] = 1.0\n        if N_int_final  M:\n            occupations_final[N_int_final] = f_frac_final\n            \n        # Calculate Total Energy using the derived efficient formula:\n        # E = sum(f_k*eps_k) - E_H_double_counting + (E_xc - sum(v_xc*n))\n        sum_e = np.sum(occupations_final * eigvals_final)\n        E_H_dc = 0.5 * U * np.sum(n**2)\n        E_xc_corr = alpha * (beta - 1) * np.sum(np.power(n, beta, where=n > 0, out=np.zeros_like(n)))\n\n        total_energy = sum_e - E_H_dc + E_xc_corr\n        \n        return total_energy, v_xc_final\n\n    results = []\n    for case in test_cases:\n        M, t, U, alpha, beta, N0, delta, lamb, epsilon = case\n        \n        # Calculate quantities for N = N0 + delta\n        E_plus, vxc_plus = run_scf_calculation(M, t, U, alpha, beta, N0 + delta, lamb, epsilon)\n        \n        # Calculate quantities for N = N0\n        E_zero, _ = run_scf_calculation(M, t, U, alpha, beta, N0, lamb, epsilon)\n        \n        # Calculate quantities for N = N0 - delta\n        E_minus, vxc_minus = run_scf_calculation(M, t, U, alpha, beta, N0 - delta, lamb, epsilon)\n        \n        # Compute curvature kappa using the finite-difference formula\n        kappa = (E_plus - 2 * E_zero + E_minus) / (delta**2)\n        \n        # Compute XC potential non-uniformity S_xc\n        delta_vxc = vxc_plus - vxc_minus\n        S_xc = np.std(delta_vxc)\n        \n        results.append([kappa, S_xc])\n\n    # Final print statement in the exact required format.\n    # We build the string manually to avoid spaces introduced by default list-to-string conversion.\n    print(f\"[{','.join(f'[{k},{s}]' for k, s in results)}]\")\n\nsolve()\n```", "id": "3493889"}]}