{"hands_on_practices": [{"introduction": "要掌握任何一种数值方法，最好的方式莫过于从一个基础而经典的问题开始。泊松方程是描述众多物理现象（如热传导、静电学和稳态扩散）的基石。本练习 [@problem_id:3502725] 将指导你完成有限元方法 (FEM) 的核心流程：从偏微分方程的强形式出发，推导出其弱形式，然后将其离散化为单元级的矩阵和向量，最后组装成全局系统并施加边界条件。通过亲手实现这一过程，你将为构建更复杂的计算模型打下坚实的基础。", "problem": "考虑一个二维空间多边形域 $\\Omega \\subset \\mathbb{R}^2$ 上的标量泊松边值问题，其边界为 $\\Gamma = \\overline{\\Gamma}_{\\mathrm{D}} \\cup \\overline{\\Gamma}_{\\mathrm{N}}$ 且 $\\Gamma_{\\mathrm{D}} \\cap \\Gamma_{\\mathrm{N}} = \\emptyset$。令 $u: \\Omega \\to \\mathbb{R}$ 为未知场，$f: \\Omega \\to \\mathbb{R}$ 为体积源，$t: \\Gamma_{\\mathrm{N}} \\to \\mathbb{R}$ 为给定的诺伊曼通量，$\\kappa: \\Omega \\to \\mathbb{R}$ 为传导率。控制方程和边界条件的强形式为\n$$\n-\\nabla \\cdot (\\kappa \\nabla u) = f \\quad \\text{in } \\Omega,\\qquad u = u_{\\mathrm{D}} \\quad \\text{on } \\Gamma_{\\mathrm{D}},\\qquad -\\kappa \\nabla u \\cdot \\mathbf{n} = t \\quad \\text{on } \\Gamma_{\\mathrm{N}},\n$$\n其中 $\\mathbf{n}$ 是 $\\Gamma$ 上的外单位法向量，$u_{\\mathrm{D}}$ 是给定的狄利克雷边界值。\n\n以此为基础，推导弱形式并使用一阶（线性）三角形单元构建有限元离散化。将测试函数空间定义为 $V_0 = \\{ w \\in H^1(\\Omega) \\mid w = 0 \\text{ on } \\Gamma_{\\mathrm{D}} \\}$，试探函数空间定义为 $V = \\{ v \\in H^1(\\Omega) \\mid v = u_{\\mathrm{D}} \\text{ on } \\Gamma_{\\mathrm{D}} \\}$。将 $u$ 近似为 $u_h(\\mathbf{x}) = \\sum_{a=1}^{N} N_a(\\mathbf{x})\\, U_a$，其中 $N_a$ 是与网格节点关联的形函数，$U_a$ 是节点值。\n\n您的任务是：\n- 从弱形式推导单元级刚度矩阵贡献 $K^{(e)}$ 和单元级载荷向量贡献 $F^{(e)}$。单元 $e$ 的刚度由 $\\nabla N_i \\cdot \\nabla N_j$ 的面积分乘以 $\\kappa$ 给出，载荷向量有一个来自 $f$ 的体积部分和一个来自 $t$ 的边界（诺伊曼）部分。对于线性的三角形和常数 $\\kappa$，单元级形函数的梯度在单元上是恒定的，对于常数 $f$，体积载荷贡献简化为单元面积的倍数。在长度为 $L$ 的边界边上，对于常数 $t$ 和边上的线性形函数，诺伊曼边界贡献是对两个边节点的一致分布，其大小与 $\\int_{\\text{edge}} N_i \\, \\mathrm{d}\\Gamma$ 成正比。\n- 通过对单元贡献求和来组装全局刚度矩阵和载荷向量。通过遍历 $\\Gamma_{\\mathrm{N}}$ 上的边界边并将它们的贡献加到全局载荷向量中来组装诺伊曼边界积分。\n- 使用标准的分块方法施加狄利克雷边界条件：将全局系统分解为自由和约束自由度，并从缩减系统 $K_{ff} U_f = F_f - K_{fc} U_c$ 中求解自由未知数 $U_f$，其中 $U_c$ 是在 $\\Gamma_{\\mathrm{D}}$ 上的给定节点值。\n\n此问题中的所有量都是无量纲的；最终输出应不带物理单位。角度不会出现在输出中，也不需要单位。程序必须以浮点值和列表的形式生成数值输出。\n\n为以下测试套件实现计算，其中节点从 $0$ 开始索引，单元由构成具有线性形函数的三角形的节点索引三元组 $(i,j,k)$ 给出：\n\n- 测试用例1（单个三角形，混合边界）：\n    - 节点：$(0,0)$、$(1,0)$、$(0,1)$。\n    - 单元：$(0,1,2)$。\n    - 传导率：$\\kappa = 1$（常数）。\n    - 体积源：$f(\\mathbf{x}) = 1$（常数）。\n    - 狄利克雷边界：节点 $0 \\mapsto 0$，$1 \\mapsto 0$。\n    - 诺伊曼边界边：$(1,2)$，其中 $t = 2$。\n    - 预期的组装行为：由于面积而产生非零体积载荷，以及由于诺伊曼边而产生非零边界载荷。\n\n- 测试用例2（两个三角形组成单位正方形，仅顶部为诺伊曼边界）：\n    - 节点：$(0,0)$、$(1,0)$、$(1,1)$、$(0,1)$。\n    - 单元：$(0,1,2)$ 和 $(0,2,3)$。\n    - 传导率：$\\kappa = 1$（常数）。\n    - 体积源：$f(\\mathbf{x}) = 0$（常数）。\n    - 狄利克雷边界：节点 $0 \\mapsto 0$，$1 \\mapsto 0$，$3 \\mapsto 0$。\n    - 诺伊曼边界边：$(2,3)$，其中 $t = 1$。\n    - 预期的组装行为：零体积载荷，来自顶边的非零边界载荷。\n\n- 测试用例3（两个三角形组成单位正方形，非零狄利克雷和顶部诺伊曼边界）：\n    - 节点：$(0,0)$、$(1,0)$、$(1,1)$、$(0,1)$。\n    - 单元：$(0,1,2)$ 和 $(0,2,3)$。\n    - 传导率：$\\kappa = 1$（常数）。\n    - 体积源：$f(\\mathbf{x}) = 1$（常数）。\n    - 狄利克雷边界：节点 $0 \\mapsto 5$，$3 \\mapsto 5$，$1 \\mapsto 0$。\n    - 诺伊曼边界边：$(2,3)$，其中 $t = 3$。\n    - 预期的组装行为：非零体积载荷和非零边界载荷。\n\n您的程序应为每个测试用例计算：\n- 总体积载荷贡献 $S_{\\mathrm{vol}} = \\sum_{a=1}^{N} F^{\\mathrm{vol}}_a$。\n- 总诺伊曼边界载荷贡献 $S_{\\mathrm{bnd}} = \\sum_{a=1}^{N} F^{\\Gamma}_a$。\n- 解出的节点值列表 $[U_0, U_1, \\dots, U_{N-1}]$，这是在通过分块施加狄利克雷边界条件并求解自由节点的缩减系统后汇总的结果。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是 $[S_{\\mathrm{vol}}, S_{\\mathrm{bnd}}, [U_0, U_1, \\dots]]$ 形式的列表。例如：$[[S_{\\mathrm{vol}}^{(1)}, S_{\\mathrm{bnd}}^{(1)}, [\\dots]], [S_{\\mathrm{vol}}^{(2)}, S_{\\mathrm{bnd}}^{(2)}, [\\dots]], [S_{\\mathrm{vol}}^{(3)}, S_{\\mathrm{bnd}}^{(3)}, [\\dots]]]$。", "solution": "该问题要求为二维标量泊松边值问题制定和实现有限元法（FEM）解。该过程涉及推导控制偏微分方程的弱形式，使用线性三角形单元对其进行离散化，组装全局方程组，并在施加指定的边界条件后求解。\n\n### 弱形式推导\n控制方程的强形式为：\n$$\n-\\nabla \\cdot (\\kappa \\nabla u) = f \\quad \\text{in } \\Omega\n$$\n边界条件为 $\\Gamma_{\\mathrm{D}}$ 上的 $u = u_{\\mathrm{D}}$ 和 $\\Gamma_{\\mathrm{N}}$ 上的 $-\\kappa \\nabla u \\cdot \\mathbf{n} = t$。\n\n为了推导弱形式，我们将控制方程乘以一个来自测试空间 $V_0 = \\{ w \\in H^1(\\Omega) \\mid w = 0 \\text{ on } \\Gamma_{\\mathrm{D}} \\}$ 的任意测试函数 $w$，并在域 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} w \\left( -\\nabla \\cdot (\\kappa \\nabla u) \\right) \\, \\mathrm{d}\\Omega = \\int_{\\Omega} w f \\, \\mathrm{d}\\Omega\n$$\n对左侧项应用散度定理（多维分部积分），我们得到：\n$$\n\\int_{\\Omega} \\nabla w \\cdot (\\kappa \\nabla u) \\, \\mathrm{d}\\Omega - \\int_{\\Gamma} w (\\kappa \\nabla u \\cdot \\mathbf{n}) \\, \\mathrm{d}\\Gamma = \\int_{\\Omega} w f \\, \\mathrm{d}\\Omega\n$$\n在 $\\Gamma = \\overline{\\Gamma}_{\\mathrm{D}} \\cup \\overline{\\Gamma}_{\\mathrm{N}}$ 上的边界积分可以分解为：\n$$\n\\int_{\\Gamma} w (\\kappa \\nabla u \\cdot \\mathbf{n}) \\, \\mathrm{d}\\Gamma = \\int_{\\Gamma_{\\mathrm{D}}} w (\\kappa \\nabla u \\cdot \\mathbf{n}) \\, \\mathrm{d}\\Gamma + \\int_{\\Gamma_{\\mathrm{N}}} w (\\kappa \\nabla u \\cdot \\mathbf{n}) \\, \\mathrm{d}\\Gamma\n$$\n根据测试空间 $V_0$ 的定义，$w=0$ 在 $\\Gamma_{\\mathrm{D}}$ 上，因此在 $\\Gamma_{\\mathrm{D}}$ 上的积分为零。在诺伊曼边界 $\\Gamma_{\\mathrm{N}}$ 上，我们有条件 $-\\kappa \\nabla u \\cdot \\mathbf{n} = t$。将其代入在 $\\Gamma_{\\mathrm{N}}$ 上的边界积分得到：\n$$\n\\int_{\\Gamma_{\\mathrm{N}}} w (\\kappa \\nabla u \\cdot \\mathbf{n}) \\, \\mathrm{d}\\Gamma = \\int_{\\Gamma_{\\mathrm{N}}} w (-t) \\, \\mathrm{d}\\Gamma = -\\int_{\\Gamma_{\\mathrm{N}}} w t \\, \\mathrm{d}\\Gamma\n$$\n将其代回积分方程中得到：\n$$\n\\int_{\\Omega} \\nabla w \\cdot (\\kappa \\nabla u) \\, \\mathrm{d}\\Omega - \\left( -\\int_{\\Gamma_{\\mathrm{N}}} w t \\, \\mathrm{d}\\Gamma \\right) = \\int_{\\Omega} w f \\, \\mathrm{d}\\Omega\n$$\n重新整理，我们得到弱形式：找到 $u \\in V = \\{ v \\in H^1(\\Omega) \\mid v = u_{\\mathrm{D}} \\text{ on } \\Gamma_{\\mathrm{D}} \\}$，使得对于所有 $w \\in V_0$：\n$$\n\\int_{\\Omega} \\nabla w \\cdot (\\kappa \\nabla u) \\, \\mathrm{d}\\Omega = \\int_{\\Omega} w f \\, \\mathrm{d}\\Omega + \\int_{\\Gamma_{\\mathrm{N}}} w t \\, \\mathrm{d}\\Gamma\n$$\n\n### 有限元离散化\n使用伽辽金法，我们使用同一组形函数 $N_a(\\mathbf{x})$ 来近似试探函数 $u$ 和测试函数 $w$：\n$$\nu(\\mathbf{x}) \\approx u_h(\\mathbf{x}) = \\sum_{a=1}^{N} N_a(\\mathbf{x}) U_a \\qquad \\text{和} \\qquad w(\\mathbf{x}) \\approx w_h(\\mathbf{x}) = \\sum_{b=1}^{N} N_b(\\mathbf{x}) W_b\n$$\n其中 $U_a$ 和 $W_b$ 是场的节点值。由于这必须对任何 $w_h \\in V_0$ 成立，它必须对每个对应于自由（非狄利克雷）自由度的基函数 $N_b$ 成立。将近似值代入弱形式，得到矩阵系统 $K U = F$：\n$$\n\\sum_{a=1}^{N} \\left( \\int_{\\Omega} \\kappa (\\nabla N_b \\cdot \\nabla N_a) \\, \\mathrm{d}\\Omega \\right) U_a = \\int_{\\Omega} f N_b \\, \\mathrm{d}\\Omega + \\int_{\\Gamma_{\\mathrm{N}}} t N_b \\, \\mathrm{d}\\Gamma\n$$\n因此，全局刚度矩阵 $K$ 和载荷向量 $F$ 的分量为：\n$$\nK_{ba} = \\int_{\\Omega} \\kappa (\\nabla N_b \\cdot \\nabla N_a) \\, \\mathrm{d}\\Omega \\qquad \\text{和} \\qquad F_b = \\int_{\\Omega} f N_b \\, \\mathrm{d}\\Omega + \\int_{\\Gamma_{\\mathrm{N}}} t N_b \\, \\mathrm{d}\\Gamma\n$$\n\n### 单元级公式（线性三角形）\n全局矩阵是通过对每个单元 $\\Omega_e$ 的贡献求和来组装的。对于具有节点 $i, j, k$ 的单个线性三角形单元：\n- **单元刚度矩阵 $K^{(e)}$**：对于单元上恒定的传导率 $\\kappa$，积分得以简化。线性形函数的梯度在单元内是恒定的。\n$$\nK_{rs}^{(e)} = \\int_{\\Omega_e} \\kappa (\\nabla N_r \\cdot \\nabla N_s) \\, \\mathrm{d}\\Omega = \\kappa A_e (\\nabla N_r \\cdot \\nabla N_s) \\quad \\text{for } r, s \\in \\{i, j, k\\}\n$$\n其中 $A_e$ 是单元的面积。对于按逆时针顺序排列的节点 $(x_i, y_i), (x_j, y_j), (x_k, y_k)$，形函数梯度为 $\\nabla N_r = \\frac{1}{2A_e} [b_r, c_r]^T$，其中 $b_i = y_j - y_k , c_i = x_k - x_j$，对于索引 $j, k$ 进行循环置换。这导致 $K_{rs}^{(e)} = \\frac{\\kappa}{4A_e}(b_r b_s + c_r c_s)$。\n\n- **单元体积载荷向量 $F^{\\mathrm{vol},(e)}$**：对于恒定的源项 $f$，其贡献为：\n$$\nF_r^{\\mathrm{vol},(e)} = \\int_{\\Omega_e} f N_r \\, \\mathrm{d}\\Omega = f \\int_{\\Omega_e} N_r \\, \\mathrm{d}\\Omega\n$$\n线性形函数在其三角形单元上的积分为 $A_e/3$。因此：\n$$\nF_r^{\\mathrm{vol},(e)} = \\frac{f A_e}{3} \\quad \\text{对于单元的每个节点 } r。\n$$\n\n- **诺伊曼边界载荷**：诺伊曼贡献不是基于单元的面积积分，而是基于边的长度积分。对于节点 $r$ 和 $s$ 之间长度为 $L$ 的边界边和恒定的通量 $t$，载荷分布到两个节点上：\n$$\nF_r^{\\Gamma} = \\int_{L} t N_r \\, \\mathrm{d}\\Gamma = t \\int_0^L (1-\\xi/L) \\, \\mathrm{d}\\xi = \\frac{t L}{2}\n$$\n$$\nF_s^{\\Gamma} = \\int_{L} t N_s \\, \\mathrm{d}\\Gamma = t \\int_0^L (\\xi/L) \\, \\mathrm{d}\\xi = \\frac{t L}{2}\n$$\n其中 $\\xi$ 是沿边的局部坐标。\n\n### 系统组装与求解\n全局刚度矩阵 $K$ 和总载荷向量 $F = F^{\\mathrm{vol}} + F^{\\Gamma}$ 是通过对单元级贡献求和来构建的。通过对系统进行分块来施加狄利克雷边界条件。设自由度（DoFs）分为自由（$f$）和约束（$c$）集。系统 $KU=F$ 被重排为：\n$$\n\\begin{pmatrix} K_{ff} & K_{fc} \\\\ K_{cf} & K_{cc} \\end{pmatrix} \\begin{pmatrix} U_f \\\\ U_c \\end{pmatrix} = \\begin{pmatrix} F_f \\\\ F_c \\end{pmatrix}\n$$\n未知自由度 $U_f$ 是通过求解从第一行块导出的缩减系统来找到的：\n$$\nK_{ff} U_f + K_{fc} U_c = F_f \\implies K_{ff} U_f = F_f - K_{fc} U_c\n$$\n在求解出 $U_f$ 后，从已知的给定值 $U_c$ 和计算出的值 $U_f$ 组装出完整的解向量 $U$。下面的程序为所提供的测试用例实现了此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(nodes, elements, kappa, f, dirichlet_bcs, neumann_bcs):\n    \"\"\"\n    Solves a single 2D Poisson FEM problem case.\n\n    Args:\n        nodes (list of tuples): Nodal coordinates, e.g., [(x0, y0), (x1, y1), ...].\n        elements (list of tuples): Element connectivity, e.g., [(n0, n1, n2), ...].\n        kappa (float): Thermal conductivity.\n        f (float): Volumetric source term.\n        dirichlet_bcs (dict): Prescribed nodal values, e.g., {node_idx: value}.\n        neumann_bcs (list of tuples): Neumann edges and flux, e.g., [((n0, n1), t)].\n\n    Returns:\n        tuple: (S_vol, S_bnd, U_list) where S_vol is total volumetric load,\n               S_bnd is total Neumann boundary load, and U_list is the list of\n               solved nodal values.\n    \"\"\"\n    num_nodes = len(nodes)\n    K = np.zeros((num_nodes, num_nodes))\n    F_vol = np.zeros(num_nodes)\n\n    # Assemble element stiffness matrix and volumetric load vector\n    for elem_nodes in elements:\n        # Get nodal coordinates for the current element\n        p_indices = list(elem_nodes)\n        p_coords = [nodes[i] for i in p_indices]\n        \n        # Calculate element area and ensure CCW ordering\n        area = 0.5 * (p_coords[0][0]*(p_coords[1][1]-p_coords[2][1]) + \n                      p_coords[1][0]*(p_coords[2][1]-p_coords[0][1]) + \n                      p_coords[2][0]*(p_coords[0][1]-p_coords[1][1]))\n        if area  0:\n             p_indices[1], p_indices[2] = p_indices[2], p_indices[1]\n             p_coords[1], p_coords[2] = p_coords[2], p_coords[1]\n             area = -area\n\n        # Calculate shape function gradient components (b and c vectors)\n        b = np.array([p_coords[1][1] - p_coords[2][1], \n                      p_coords[2][1] - p_coords[0][1], \n                      p_coords[0][1] - p_coords[1][1]])\n        c = np.array([p_coords[2][0] - p_coords[1][0], \n                      p_coords[0][0] - p_coords[2][0], \n                      p_coords[1][0] - p_coords[0][0]])\n        \n        # Element stiffness matrix\n        Ke = kappa / (4.0 * area) * (np.outer(b, b) + np.outer(c, c))\n        \n        # Assemble Ke into global K\n        for i_local, i_global in enumerate(p_indices):\n            for j_local, j_global in enumerate(p_indices):\n                K[i_global, j_global] += Ke[i_local, j_local]\n\n        # Element volumetric load vector (for constant f)\n        if f != 0:\n            Fe_vol = (f * area / 3.0) * np.ones(3)\n            for i_local, i_global in enumerate(p_indices):\n                F_vol[i_global] += Fe_vol[i_local]\n\n    S_vol = np.sum(F_vol)\n\n    # Assemble boundary load vector from Neumann conditions\n    F_bnd = np.zeros(num_nodes)\n    for edge, t in neumann_bcs:\n        p0_idx, p1_idx = edge\n        p0, p1 = nodes[p0_idx], nodes[p1_idx]\n        \n        length = np.sqrt((p1[0] - p0[0])**2 + (p1[1] - p0[1])**2)\n        \n        load_val = t * length / 2.0\n        F_bnd[p0_idx] += load_val\n        F_bnd[p1_idx] += load_val\n\n    S_bnd = np.sum(F_bnd)\n\n    # Total load vector\n    F = F_vol + F_bnd\n\n    # Apply Dirichlet boundary conditions via partitioning\n    all_dofs = set(range(num_nodes))\n    constrained_dofs = sorted(list(dirichlet_bcs.keys()))\n    free_dofs = sorted(list(all_dofs - set(constrained_dofs)))\n\n    U = np.zeros(num_nodes)\n    \n    # Handle the case where all DoFs are constrained\n    if not free_dofs:\n        for dof, val in dirichlet_bcs.items():\n            U[dof] = val\n        return S_vol, S_bnd, U.tolist()\n\n    U_c = np.array([dirichlet_bcs[i] for i in constrained_dofs])\n    \n    F_f = F[free_dofs]\n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n    \n    # Calculate right-hand side for the reduced system\n    rhs = F_f\n    if constrained_dofs:\n        K_fc = K[np.ix_(free_dofs, constrained_dofs)]\n        rhs -= K_fc @ U_c\n        \n    # Solve for free DOFs\n    U_f = np.linalg.solve(K_ff, rhs)\n\n    # Assemble full solution vector U\n    for i, dof in enumerate(free_dofs):\n        U[dof] = U_f[i]\n    for i, dof in enumerate(constrained_dofs):\n        U[dof] = U_c[i]\n\n    return S_vol, S_bnd, U.tolist()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { # Test Case 1\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2)],\n            \"kappa\": 1.0,\n            \"f\": 1.0,\n            \"dirichlet_bcs\": {0: 0.0, 1: 0.0},\n            \"neumann_bcs\": [((1, 2), 2.0)]\n        },\n        { # Test Case 2\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"kappa\": 1.0,\n            \"f\": 0.0,\n            \"dirichlet_bcs\": {0: 0.0, 1: 0.0, 3: 0.0},\n            \"neumann_bcs\": [((2, 3), 1.0)]\n        },\n        { # Test Case 3\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)],\n            \"elements\": [(0, 1, 2), (0, 2, 3)],\n            \"kappa\": 1.0,\n            \"f\": 1.0,\n            \"dirichlet_bcs\": {0: 5.0, 3: 5.0, 1: 0.0},\n            \"neumann_bcs\": [((2, 3), 3.0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_vol, s_bnd, u_list = solve_case(\n            case[\"nodes\"], \n            case[\"elements\"], \n            case[\"kappa\"], \n            case[\"f\"], \n            case[\"dirichlet_bcs\"], \n            case[\"neumann_bcs\"]\n        )\n        # Format the list of U values into a string\n        u_str = f\"[{','.join(f'{x:.8f}' for x in u_list)}]\"\n        # Store result for final printing\n        results.append(f\"[{s_vol:.8f},{s_bnd:.8f},{u_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3502725"}, {"introduction": "在材料科学中，许多关键现象（如相分离）是由高阶偏微分方程描述的，例如包含四阶空间导数的 Cahn-Hilliard 方程，这给数值求解带来了挑战。本练习 [@problem_id:3502772] 引入了一种优雅而强大的技术——混合有限元法。通过引入一个辅助变量（化学势 $\\mu$），我们将原始的四阶方程巧妙地分解为一个耦合的二阶方程组，从而可以使用标准的、$C^0$ 连续性的简单单元进行求解。这个实践充分展示了变分原理和弱形式在处理复杂物理模型时的灵活性与实用性。", "problem": "考虑一个标量浓度场 $c(\\mathbf{x},t)$ 的质量守恒相场演化，该演化由 Cahn–Hilliard 方程控制，定义在一个一维域 $\\Omega=[0,L]$ 上，浓度和化学势均采用齐次 Neumann 边界条件。控制定律为：(i) 质量守恒，即 $\\partial c / \\partial t + \\nabla \\cdot \\mathbf{J} = 0$；(ii) 具有化学势梯度的 Fickian 通量，$\\mathbf{J} = -\\mathcal{M} \\nabla \\mu$，其中 $\\mathcal{M}$ 是一个常数迁移率，$\\mu$ 是化学势。化学势由一个自由能泛函的变分导数得到，该泛函包含体能量密度 $f(c)$ 和梯度惩罚项 $\\kappa \\lvert \\nabla c \\rvert^2 / 2$，从而得出 $\\mu = f'(c) - \\kappa \\nabla^2 c$。使用双阱能量密度 $f(c) = \\tfrac{1}{4}(c^2 - 1)^2$，因此 $f'(c) = c^3 - c$。所有量均为无量纲；无需物理单位。\n\n你的任务是根据第一性原理来：\n- 通过为质量平衡方程选择检验函数 $w \\in H^1(\\Omega)$、为化学势方程选择检验函数 $v \\in H^1(\\Omega)$，并在齐次 Neumann 边界条件下适当时进行分部积分，来推导混合格式的弱形式。\n- 解释引入辅助变量 $\\mu$ 如何允许使用 $C^0$（连续、分段线性）有限元，并避免了在试探空间中直接处理四阶空间导数。\n- 使用有限元方法 (FEM) 和 $C^0$ 线性 Lagrange 基函数，在包含 $N$ 个单元的均匀网格上对弱形式进行空间离散化。令一致质量矩阵为 $M_{ij} = \\int_\\Omega \\phi_i \\phi_j \\, \\mathrm{d}x$，刚度矩阵为 $K_{ij} = \\int_\\Omega \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, \\mathrm{d}x$。\n- 使用时间步长为 $\\Delta t$ 的后向欧拉法进行时间离散，并通过在前一时间层 $c^n$ 处计算非线性项 $f'(c)$ 来对其进行显式处理，这样就可以求解一个单一的线性系统来得到 $c^{n+1}$ 和 $\\mu^{n+1}$。组装耦合两个场的最终分块线性系统。\n\n然后，实现一个程序，该程序：\n- 在 $[0,L]$ 上建立包含 $N$ 个均匀单元的一维网格，并组装全局矩阵 $M$ 和 $K$。\n- 在节点处通过 $c^n(x) = 0.2 \\cos\\left(2\\pi x / L\\right) + 0.1 \\cos\\left(\\pi x / L\\right)$ 初始化 $c^n(x)$。\n- 构建并求解线性化的混合系统，以执行单个后向欧拉步骤，计算 $c^{n+1}$ 和 $\\mu^{n+1}$。\n- 求解后评估三个标量指标：\n  1. 绝对质量变化 $\\left|\\int_\\Omega c^{n+1} \\, \\mathrm{d}x - \\int_\\Omega c^{n} \\, \\mathrm{d}x\\right|$，通过有限元内积 $ \\mathbf{1}^\\top M \\mathbf{c}$ 近似，其中 $\\mathbf{1}$ 是节点值为1的向量，$\\mathbf{c}$ 是 $c$ 的节点向量。\n  2. 化学势方程残差的欧几里得范数，$\\left\\| M \\boldsymbol{\\mu}^{n+1} - M \\mathbf{f}'( \\mathbf{c}^{n}) + \\kappa K \\mathbf{c}^{n+1} \\right\\|_2$。\n  3. 质量平衡方程残差的欧几里得范数，$\\left\\| \\frac{1}{\\Delta t} M(\\mathbf{c}^{n+1} - \\mathbf{c}^{n}) + \\mathcal{M} K \\boldsymbol{\\mu}^{n+1} \\right\\|_2$。\n\n使用以下参数集测试套件，每个集合指定为 $(L,N,\\Delta t,\\kappa,\\mathcal{M})$：\n- 情况 A（通用）：$(1,16,10^{-4},10^{-2},1)$。\n- 情况 B（更粗的网格，更大的步长）：$(1,8,10^{-3},10^{-2},1)$。\n- 情况 C（零迁移率边缘情况）：$(1,8,10^{-3},10^{-2},0)$。\n\n你的程序应生成单行输出，其中包含九个浮点指标，这些指标聚合为一个逗号分隔的列表，并用方括号括起来，顺序为 $[\\text{A.质量变化},\\text{A.mu-残差},\\text{A.质量-残差},\\text{B.质量变化},\\text{B.mu-残差},\\text{B.质量-残差},\\text{C.质量变化},\\text{C.mu-残差},\\text{C.质量-残差}]$，每个值都以默认的 Python 浮点数格式打印。如果出现任何三角函数，角度均以弧度为单位。无需物理单位；所有量均为无量纲。", "solution": "该问题要求推导一维混合格式下的 Cahn–Hilliard 方程，并对其进行单时间步的数值求解。我们首先陈述控制方程，然后继续推导弱形式、其离散化以及待求解线性系统的构建。\n\n在域 $\\Omega=[0,L]$ 上的控制方程强形式由一个耦合的二阶偏微分方程组给出：\n1.  质量守恒方程：$\\frac{\\partial c}{\\partial t} + \\nabla \\cdot \\mathbf{J} = 0$，其中通量为 $\\mathbf{J} = -\\mathcal{M} \\nabla \\mu$。这可以合并为 $\\frac{\\partial c}{\\partial t} = \\nabla \\cdot (\\mathcal{M} \\nabla \\mu)$。\n2.  化学势 $\\mu$ 的定义：$\\mu = f'(c) - \\kappa \\nabla^2 c$，其中 $f'(c) = c^3 - c$。\n\n对两个场都应用齐次 Neumann 边界条件：在 $\\partial\\Omega = \\{0, L\\}$ 上 $\\nabla c \\cdot \\mathbf{n} = 0$ 和 $\\nabla \\mu \\cdot \\mathbf{n} = 0$。\n\n**1. 弱形式的推导**\n\n为了推导弱形式，我们为质量平衡方程和化学势方程分别引入两个检验函数，$w \\in H^1(\\Omega)$ 和 $v \\in H^1(\\Omega)$。Sobolev 空间 $H^1(\\Omega)$ 包含平方可积且其一阶导数也平方可积的函数，这是二阶偏微分方程弱形式的自然空间。\n\n对于质量平衡方程，我们乘以检验函数 $w$ 并在域 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} \\frac{\\partial c}{\\partial t} w \\, \\mathrm{d}x = \\int_{\\Omega} \\nabla \\cdot (\\mathcal{M} \\nabla \\mu) w \\, \\mathrm{d}x\n$$\n我们对右侧应用分部积分（Green 第一恒等式）：\n$$\n\\int_{\\Omega} \\nabla \\cdot (\\mathcal{M} \\nabla \\mu) w \\, \\mathrm{d}x = \\left[ (\\mathcal{M} \\nabla \\mu) w \\right]_{\\partial\\Omega} - \\int_{\\Omega} (\\mathcal{M} \\nabla \\mu) \\cdot \\nabla w \\, \\mathrm{d}x\n$$\n由于在 $\\mu$ 上施加了齐次 Neumann 边界条件（即在 $x=0$ 和 $x=L$ 处 $\\nabla \\mu = 0$），边界项 $\\left[ (\\mathcal{M} \\nabla \\mu) w \\right]_{\\partial\\Omega}$ 消失。这得到第一个弱形式方程：\n$$\n\\int_{\\Omega} \\frac{\\partial c}{\\partial t} w \\, \\mathrm{d}x + \\int_{\\Omega} \\mathcal{M} \\nabla \\mu \\cdot \\nabla w \\, \\mathrm{d}x = 0\n$$\n\n对于化学势方程，我们首先将其重新排列为 $\\mu - f'(c) + \\kappa \\nabla^2 c = 0$。然后我们乘以检验函数 $v$ 并在 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} \\mu v \\, \\mathrm{d}x - \\int_{\\Omega} f'(c) v \\, \\mathrm{d}x + \\int_{\\Omega} \\kappa (\\nabla^2 c) v \\, \\mathrm{d}x = 0\n$$\n对包含 $c$ 的二阶导数的项应用分部积分：\n$$\n\\int_{\\Omega} \\kappa (\\nabla^2 c) v \\, \\mathrm{d}x = \\left[ \\kappa (\\nabla c) v \\right]_{\\partial\\Omega} - \\int_{\\Omega} \\kappa \\nabla c \\cdot \\nabla v \\, \\mathrm{d}x\n$$\n由于在 $c$ 上施加了齐次 Neumann 边界条件，边界项消失。这得到第二个弱形式方程：\n$$\n\\int_{\\Omega} \\mu v \\, \\mathrm{d}x + \\int_{\\Omega} \\kappa \\nabla c \\cdot \\nabla v \\, \\mathrm{d}x = \\int_{\\Omega} f'(c) v \\, \\mathrm{d}x\n$$\n\n完整的弱形式是：找到 $c(\\cdot, t) \\in H^1(\\Omega)$ 和 $\\mu(\\cdot, t) \\in H^1(\\Omega)$，使得对于所有检验函数 $w, v \\in H^1(\\Omega)$：\n$$\n\\int_{\\Omega} \\frac{\\partial c}{\\partial t} w \\, \\mathrm{d}x + \\int_{\\Omega} \\mathcal{M} \\nabla \\mu \\cdot \\nabla w \\, \\mathrm{d}x = 0\n$$\n$$\n\\int_{\\Omega} \\mu v \\, \\mathrm{d}x + \\int_{\\Omega} \\kappa \\nabla c \\cdot \\nabla v \\, \\mathrm{d}x = \\int_{\\Omega} f'(c) v \\, \\mathrm{d}x\n$$\n请注意，由于将 $-\\kappa \\nabla c \\cdot \\nabla v$ 积分移到等式另一边，第二个方程中刚度项的符号发生了变化。\n\n**2. 混合格式的原理**\n\n原始的 Cahn–Hilliard 方程，通过将 $\\mu$ 代入质量平衡方程得到，是 $\\frac{\\partial c}{\\partial t} = \\nabla \\cdot (\\mathcal{M} \\nabla (f'(c) - \\kappa \\nabla^2 c))$，这是一个关于 $c$ 的四阶偏微分方程。四阶偏微分方程的标准 Galerkin 有限元格式要求试探函数和检验函数都位于 Sobolev 空间 $H^2(\\Omega)$ 中。这对基函数施加了 $C^1$ 连续性要求，意味着函数本身及其一阶导数必须在单元边界上连续。标准的 Lagrange 基函数，例如这里使用的分段线性函数，仅为 $C^0$ 连续（函数是连续的，但其导数不连续），并且属于 $H^1(\\Omega)$，而非 $H^2(\\Omega)$。构建 $C^1$ 连续的单元要复杂得多。\n\n通过引入化学势 $\\mu$ 作为辅助变量，我们将单个四阶偏微分方程分解为一个二阶偏微分方程组。如弱形式推导所示，此过程将任何积分中的最高导数阶数降为一。因此，两个场（$c$ 和 $\\mu$）的试探函数和检验函数仅需位于 $H^1(\\Omega)$ 中。这允许使用简单的、标准的 $C^0$ 有限元基函数，从而大大简化了实现。\n\n**3. 离散化与线性系统**\n\n我们将域 $\\Omega=[0,L]$ 离散化为 $N$ 个均匀单元，并使用 $C^0$ 线性 Lagrange 基函数 $\\phi_j(x)$ 来近似场 $c$ 和 $\\mu$：\n$$\nc(x,t) \\approx c_h(x,t) = \\sum_{j=1}^{N_{nodes}} c_j(t) \\phi_j(x) \\quad \\text{和} \\quad \\mu(x,t) \\approx \\mu_h(x,t) = \\sum_{j=1}^{N_{nodes}} \\mu_j(t) \\phi_j(x)\n$$\n其中 $c_j(t)$ 和 $\\mu_j(t)$ 是随时间变化的节点值。Galerkin 方法使用基函数 $\\phi_i(x)$ 作为检验函数，即 $w = \\phi_i$ 和 $v = \\phi_i$。\n\n将这些近似代入弱形式，得到一个常微分方程组 (ODEs)。这些积分变成了涉及一致质量矩阵 $M_{ij} = \\int_\\Omega \\phi_i \\phi_j \\, \\mathrm{d}x$ 和刚度矩阵 $K_{ij} = \\int_\\Omega \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, \\mathrm{d}x$ 的矩阵向量乘积。非线性项 $\\int_\\Omega f'(c_h) \\phi_i \\, \\mathrm{d}x$ 近似为 $(M \\mathbf{f}'(\\mathbf{c}))_i$，其中 $\\mathbf{f}'(\\mathbf{c})$ 是节点处 $f'(c_j)$ 的向量。半离散系统为：\n$$\nM \\frac{d\\mathbf{c}}{dt} + \\mathcal{M} K \\boldsymbol{\\mu} = \\mathbf{0}\n$$\n$$\nM \\boldsymbol{\\mu} - \\kappa K \\mathbf{c} = M \\mathbf{f}'(\\mathbf{c})\n$$\n\n我们使用后向欧拉格式进行时间离散化，其中变量在新时间层 $n+1$ 处求值，但非线性项除外，该项被显式处理（在前一时间层 $n$ 处求值）以使系统线性化。时间导数近似为 $\\frac{d\\mathbf{c}}{dt} \\approx \\frac{\\mathbf{c}^{n+1} - \\mathbf{c}^n}{\\Delta t}$。待求解未知向量 $\\mathbf{c}^{n+1}$ 和 $\\boldsymbol{\\mu}^{n+1}$ 的全离散系统是：\n$$\n\\frac{1}{\\Delta t} M (\\mathbf{c}^{n+1} - \\mathbf{c}^n) + \\mathcal{M} K \\boldsymbol{\\mu}^{n+1} = \\mathbf{0}\n$$\n$$\nM \\boldsymbol{\\mu}^{n+1} - \\kappa K \\mathbf{c}^{n+1} = M \\mathbf{f}'(\\mathbf{c}^n)\n$$\n\n将其重排为单个分块线性系统，形式为 $\\mathbf{A} \\mathbf{x} = \\mathbf{b}$：\n$$\n\\begin{bmatrix}\n\\frac{1}{\\Delta t} M  \\mathcal{M} K \\\\\n-\\kappa K  M\n\\end{bmatrix}\n\\begin{Bmatrix}\n\\mathbf{c}^{n+1} \\\\\n\\boldsymbol{\\mu}^{n+1}\n\\end{Bmatrix}\n=\n\\begin{Bmatrix}\n\\frac{1}{\\Delta t} M \\mathbf{c}^n \\\\\nM \\mathbf{f}'(\\mathbf{c}^n)\n\\end{Bmatrix}\n$$\n在每个时间步求解此系统，以将解从 $(\\mathbf{c}^n, \\boldsymbol{\\mu}^n)$ 推进到 $(\\mathbf{c}^{n+1}, \\boldsymbol{\\mu}^{n+1})$。程序将组装并求解此系统一个步长。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as sp_solve\n\ndef perform_single_step(L, N, dt, kappa, M_val):\n    \"\"\"\n    Performs a single backward Euler step for the mixed Cahn-Hilliard system.\n\n    Args:\n        L (float): Domain length.\n        N (int): Number of elements.\n        dt (float): Time step size.\n        kappa (float): Gradient penalty coefficient.\n        M_val (float): Mobility.\n\n    Returns:\n        tuple: A tuple containing the three scalar metrics:\n               (mass_change, mu_residual_norm, mass_residual_norm).\n    \"\"\"\n    N_nodes = N + 1\n    h = L / float(N)\n\n    # 1. Assemble 1D FEM matrices (Mass M and Stiffness K)\n    M = np.zeros((N_nodes, N_nodes))\n    K = np.zeros((N_nodes, N_nodes))\n\n    # Element matrices for linear Lagrange basis functions\n    m_e = (h / 6.0) * np.array([[2.0, 1.0], [1.0, 2.0]])\n    k_e = (1.0 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n    for i in range(N):\n        # Global node indices for element i\n        n1, n2 = i, i + 1\n        nodes = np.array([n1, n2])\n        \n        # Assemble element matrices into global matrices\n        for local_i in range(2):\n            for local_j in range(2):\n                global_i, global_j = nodes[local_i], nodes[local_j]\n                M[global_i, global_j] += m_e[local_i, local_j]\n                K[global_i, global_j] += k_e[local_i, local_j]\n\n    # 2. Set initial condition\n    x_nodes = np.linspace(0.0, L, N_nodes)\n    c_n = 0.2 * np.cos(2 * np.pi * x_nodes / L) + 0.1 * np.cos(np.pi * x_nodes / L)\n\n    # 3. Form the block linear system Ax = b\n    # System size\n    sys_size = 2 * N_nodes\n    A = np.zeros((sys_size, sys_size))\n    b = np.zeros(sys_size)\n\n    # Block matrix A\n    A[:N_nodes, :N_nodes] = (1.0 / dt) * M\n    A[:N_nodes, N_nodes:] = M_val * K\n    # Correction from original derivation: The sign of the kappa*K term in the block matrix\n    # depends on how the weak form is written. The solution text derivation\n    # `M*mu + kappa*K*c = M*f'(c)` would lead to +kappa*K.\n    # The code implements this corrected form, not the one with -kappa*K in the final matrix.\n    # Let's check the derivation in the solution text again.\n    # Second weak form: integral(mu*v) - integral(kappa*nabla_c . nabla_v) = integral(f'*v)\n    # This discretizes to M*mu - kappa*K*c = M*f'.\n    # Transposing to the RHS: M*mu = M*f' + kappa*K*c\n    # In the block system, we want unknowns on the left:\n    # M*mu - kappa*K*c = M*f'\n    # The provided block matrix in the solution text seems to have a sign error on kappa*K.\n    # The original equation `mu = f'(c) - kappa*nabla^2 c` leads to `mu + kappa*nabla^2 c = f'(c)`.\n    # Weak form: `integral(mu*v) + integral(kappa*nabla^2 c * v) = integral(f'*v)`.\n    # Integration by parts: `integral(mu*v) - integral(kappa*nabla_c . nabla_v) = integral(f'*v)`.\n    # This discretizes to `M*mu - kappa*K*c = M*f'(c)`.\n    # In the final block system, moving `kappa*K*c` to the LHS of the block row gives `-kappa*K`.\n    # It appears the original XML's solution text and matrix were inconsistent.\n    # The provided code seems to follow a different sign convention, let's analyze it.\n    # The python code uses `A[N_nodes:, :N_nodes] = kappa * K`. Let's assume this is correct and adjust the solution text.\n    # Let's re-derive: `mu = f'(c) - kappa*nabla^2 c`. -> `mu - f'(c) + kappa*nabla^2 c = 0`.\n    # Weak form: `integral(mu*v) - integral(f'*v) + integral(kappa*nabla^2 c * v) = 0`.\n    # After IBP: `integral(mu*v) - integral(f'*v) - integral(kappa*nabla_c . nabla_v) = 0`.\n    # Discrete: `M*mu - M*f' - kappa*K*c = 0`.\n    # System row: `-kappa*K*c + M*mu = M*f'`.\n    # So the block should have `-kappa*K`. The solution derivation was correct, but the final block matrix representation\n    # had a different sign. And the code has yet another sign.\n    # Let's stick to the most plausible derivation: `M*mu + kappa*K*c = M*f'(c)` is incorrect.\n    # `M*mu - kappa*K*c = M*f'(c)` is correct from `mu + kappa*nabla^2 c = f'(c)`.\n    # Block row: `-kappa*K*c_np1 + M*mu_np1 = M*f'(c_n)`.\n    # So the block matrix in the final solution text is correct: `[-kappa K, M]`.\n    # The code `A[N_nodes:, :N_nodes] = kappa * K` is therefore incorrect based on the problem physics.\n    # I must correct the code to `-kappa * K`.\n    # Wait, the problem description states `mu = f'(c) - \\kappa \\nabla^2 c`.\n    # Weak form derivation in solution text: `mu + kappa nabla^2 c = f'(c)` which is a re-arrangement.\n    # `integral(mu*v) + integral(kappa(nabla^2 c)v) = integral(f'*v)`.\n    # `integral(mu*v) - integral(kappa nabla c . nabla v) = integral(f'*v)`.\n    # Discrete: `M*mu - kappa*K*c = M*f'(c)`.\n    # This means the block `[-kappa*K, M]` is correct.\n    # Let me re-read the solution text one more time.\n    # The solution text derivation `int(mu*v) + int(kappa*nabla c . nabla v) = int(f'*v)`\n    # This derivation is inconsistent with `mu = f'(c) - kappa*nabla^2 c`. It assumes `mu = f'(c) + kappa*nabla^2 c`.\n    # The problem description is the source of truth.\n    # `mu = f'(c) - \\kappa \\nabla^2 c` -> `\\kappa \\nabla^2 c = f'(c) - \\mu`.\n    # Weak form: `integral(v * kappa * nabla^2 c) = integral(v * (f'(c) - mu))`.\n    # IBP: `-integral(kappa * nabla v . nabla c) = integral(v * f'(c)) - integral(v * mu)`.\n    # Discrete: `-kappa * K * c = M*f'(c) - M*mu`.\n    # Rearrange for block system (unknowns on left): `kappa*K*c - M*mu = -M*f'(c)`.\n    # Or `M*mu - kappa*K*c = M*f'(c)`. This matches my derivation and the solution text's discrete equation, but not the final block matrix.\n    # Let's check the solution's block matrix: `[kappa K, M]`. This corresponds to `kappa*K*c_np1 + M*mu_np1 = M*f'(c_n)`. This is incorrect.\n    # Let's check the code: `A[N_nodes:, :N_nodes] = kappa * K`. This corresponds to the incorrect block matrix.\n    #\n    # Okay, there's a definite scientific error here spanning the solution text and code. The derivation is inconsistent.\n    # I will correct the `solution` and `answer` to be consistent with the problem statement.\n    # Correct discrete equation for the second PDE: `M*mu_np1 - kappa*K*c_np1 = M*f'(c_n)`.\n    # This means the block row should be `[-kappa*K, M]` acting on `[c_np1, mu_np1]`.\n    # So in the code, `A[N_nodes:, :N_nodes] = -kappa * K`.\n    # I will also correct the `solution` text's derivation and final block matrix.\n    # I am changing the solution text to correct the derivation and the final block matrix.\n    # I am changing the code to use `-kappa * K`.\n    # The original solution text has: `int(mu*v) + int(kappa*nabla c . nabla v) = int(f'*v)`. And `[kappa K, M]`. Both are wrong.\n    # I will fix both.\n    \n    A[N_nodes:, :N_nodes] = -kappa * K\n    A[N_nodes:, N_nodes:] = M\n\n    # Block vector b\n    f_prime_c_n = c_n**3 - c_n\n    b[:N_nodes] = (1.0 / dt) * (M @ c_n)\n    b[N_nodes:] = M @ f_prime_c_n\n\n    # 4. Solve the linear system\n    solution_vec = sp_solve(A, b, assume_a='gen')\n    c_np1 = solution_vec[:N_nodes]\n    mu_np1 = solution_vec[N_nodes:]\n\n    # 5. Evaluate the metrics\n    # Metric 1: Absolute mass change\n    ones_vec = np.ones(N_nodes)\n    mass_n = ones_vec @ M @ c_n\n    mass_np1 = ones_vec @ M @ c_np1\n    mass_change = np.abs(mass_np1 - mass_n)\n\n    # Metric 2: Euclidean norm of the chemical potential equation residual\n    # Residual from M*mu - kappa*K*c = M*f'(c)\n    res_mu = M @ mu_np1 - kappa * K @ c_np1 - M @ f_prime_c_n\n    mu_residual_norm = np.linalg.norm(res_mu)\n\n    # Metric 3: Euclidean norm of the mass balance residual\n    # Residual from (1/dt)*M*(c_np1-c_n) + M_val*K*mu_np1 = 0\n    res_mass = (1.0 / dt) * M @ (c_np1 - c_n) + M_val * K @ mu_np1\n    mass_residual_norm = np.linalg.norm(res_mass)\n\n    return mass_change, mu_residual_norm, mass_residual_norm\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (L, N, dt, kappa, M_val)\n    test_cases = [\n        (1.0, 16, 1e-4, 1e-2, 1.0),  # Case A\n        (1.0, 8, 1e-3, 1e-2, 1.0),   # Case B\n        (1.0, 8, 1e-3, 1e-2, 0.0),   # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, dt, kappa, M_val = case\n        metrics = perform_single_step(L, N, dt, kappa, M_val)\n        results.extend(metrics)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3502772"}, {"introduction": "真实的材料行为往往涉及多个物理场的非线性耦合，例如化学扩散与机械变形之间的相互作用。为了求解这类复杂的非线性系统，例如通过牛顿-拉弗森 (Newton-Raphson) 方法，关键一步是精确地线性化控制方程。本练习 [@problem_id:3502753] 聚焦于此核心任务：通过对弱形式残差进行方向导数，系统地推导耦合问题的一致切线矩阵（雅可比矩阵）。掌握这一技能，意味着你将能够构建和求解模拟真实世界中复杂多物理场现象的先进模型。", "problem": "考虑一根无量纲长度为 $L$ 的一维、小应变、线性弹性杆，其内部存在一种扩散物质，该物质的无量纲浓度场为 $c(x)$，通过线性固有应变与位移场 $u(x)$ 准静态耦合。\n\n本问题中所有量均为无量纲；请勿在答案中附加任何物理单位。该杆使用下文定义的有限元法 (FEM) 进行离散化。\n\n基本原理和假设：\n- 线性动量守恒（无惯性项、无外部面力或体力），以及包含固有应变的线性弹性本构律：Cauchy 应力为 $\\sigma = E\\left(\\varepsilon - \\alpha c\\right)$，其中 $\\varepsilon = \\frac{du}{dx}$，$E  0$ 是杨氏模量，$\\alpha$ 是一个无量纲耦合系数（Vegard 型固有应变）。\n- 物质守恒，采用从已知前一时刻浓度 $c^{n}$ 开始的隐式欧拉时间积分（时间步长 $\\Delta t  0$），具有恒定迁移率 $M \\ge 0$、Fick 型扩散以及一个与应变成正比的线性产生项：$\\dot{c} + \\frac{d}{dx} J = s$，其中 $J = - M \\frac{dc}{dx}$ 且 $s = \\chi \\frac{du}{dx}$，$\\chi$ 是一个无量纲耦合系数。这一选择避免了高阶空间导数，同时引入了双向化学-力学耦合。\n- 通过将控制方程乘以容许试函数并在域上积分，并在适当时使用标准的分部积分法，得到弱形式。\n\n令 $\\mathcal{V}_u$ 和 $\\mathcal{V}_c$ 分别表示 $u$ 和 $c$ 的试探空间和检验空间，并令 $\\delta u \\in \\mathcal{V}_u$ 和 $\\delta c \\in \\mathcal{V}_c$ 为试函数。弱形式残差定义如下：\n- 力学残差（虚功原理）：求解 $u \\in \\mathcal{V}_u$，使得对于所有 $\\delta u \\in \\mathcal{V}_u$，\n$$\n\\mathcal{R}_u(\\delta u; u, c) = \\int_0^L \\left( \\frac{d \\delta u}{dx} \\right) E \\left( \\frac{du}{dx} - \\alpha c \\right) \\, dx = 0.\n$$\n- 扩散残差（隐式时间积分和含源项的 Fick 定律）：求解 $c \\in \\mathcal{V}_c$，使得对于所有 $\\delta c \\in \\mathcal{V}_c$，\n$$\n\\mathcal{R}_c(\\delta c; u, c) = \\int_0^L \\delta c \\, \\frac{c - c^{n}}{\\Delta t} \\, dx + \\int_0^L \\left( \\frac{d \\delta c}{dx} \\right) M \\left( \\frac{dc}{dx} \\right) dx - \\int_0^L \\delta c \\, \\chi \\left( \\frac{du}{dx} \\right) dx = 0.\n$$\n\n将一致切线块定义为残差关于主场变量沿着试函数方向的 Fréchet 导数：\n- $K_{uu}[\\delta u, \\hat{u}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_u(\\delta u; u + \\epsilon \\hat{u}, c)\\right|_{\\epsilon=0}$,\n- $K_{uc}[\\delta u, \\hat{c}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_u(\\delta u; u, c + \\epsilon \\hat{c})\\right|_{\\epsilon=0}$,\n- $K_{cu}[\\delta c, \\hat{u}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_c(\\delta c; u + \\epsilon \\hat{u}, c)\\right|_{\\epsilon=0}$,\n- $K_{cc}[\\delta c, \\hat{c}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_c(\\delta c; u, c + \\epsilon \\hat{c})\\right|_{\\epsilon=0}$.\n\n离散化细节：\n- 在 $[0, L]$ 上使用由 $N_e$ 个两节点线性单元组成的均匀网格，共计 $N = N_e + 1$ 个节点。令单元长度为 $h = L / N_e$。\n- 在每个单元上使用标准的 $C^0$ 两节点线性形函数 $N_1(\\xi) = \\frac{1}{2}(1-\\xi)$ 和 $N_2(\\xi) = \\frac{1}{2}(1+\\xi)$，其中 $\\xi \\in [-1, 1]$，通过仿射映射 $dx = \\frac{h}{2} d\\xi$ 映射到物理坐标。\n- 对力学场 $u$ 和浓度场 $c$ 使用相同的形函数。令离散试探函数为 $u^h(x) = \\sum_{a=1}^{N} N_a(x) \\, u_a$ 和 $c^h(x) = \\sum_{a=1}^{N} N_a(x) \\, c_a$，试函数为 $\\delta u^h(x) = \\sum_{a=1}^{N} N_a(x) \\, \\delta u_a$ 和 $\\delta c^h(x) = \\sum_{a=1}^{N} N_a(x) \\, \\delta c_a$。\n- 使用两节点线性单元的精确单元级矩阵来近似所有积分（等效地，使用 2 点高斯求积，它对这里出现的多项式是精确的）。\n\n任务：\n1. 从弱形式残差出发，推导单个长度为 $h$ 的单元的一致切线块的离散单元矩阵形式：\n   - 证明力学切线块 $K^{e}_{uu}$、耦合块 $K^{e}_{uc}$、耦合块 $K^{e}_{cu}$ 和扩散切线块 $K^{e}_{cc}$ 可以表示为依赖于 $E$、$\\alpha$、$M$、$\\chi$、$h$ 和 $\\Delta t$ 的单元矩阵。不要假设任何边界条件；保留完整的单元矩阵。\n2. 通过标准的有限元组装方法，由单元矩阵组装整个网格的大小为 $N \\times N$ 的全局切线块 $K_{uu}$、$K_{uc}$、$K_{cu}$、$K_{cc}$。构成大小为 $2N \\times 2N$ 且具有以下分块结构的完整雅可比矩阵 $J$：\n$$\nJ = \\begin{bmatrix}\nK_{uu}  K_{uc} \\\\\nK_{cu}  K_{cc}\n\\end{bmatrix}.\n$$\n3. 对于下面列出的每个测试用例，计算四个全局块和完整雅可比矩阵的 Frobenius 范数，\n$$\n\\|K_{uu}\\|_F, \\quad \\|K_{uc}\\|_F, \\quad \\|K_{cu}\\|_F, \\quad \\|K_{cc}\\|_F, \\quad \\|J\\|_F,\n$$\n并将每个范数报告为一个四舍五入到恰好 $8$ 位小数的浮点数。\n4. 所有量均为无量纲；请勿在任何地方提供任何物理单位。\n\n测试套件：\n- 用例 A (一般耦合): $L = 1$, $N_e = 2$, $E = 10$, $\\alpha = 0.3$, $M = 2$, $\\chi = 0.5$, $\\Delta t = 0.1$.\n- 用例 B (无耦合): $L = 1$, $N_e = 2$, $E = 10$, $\\alpha = 0$, $M = 2$, $\\chi = 0$, $\\Delta t = 0.1$.\n- 用例 C (刚性瞬态扩散): $L = 1$, $N_e = 2$, $E = 10$, $\\alpha = 0.3$, $M = 2$, $\\chi = 0.5$, $\\Delta t = 10^{-6}$.\n- 用例 D (弱扩散，强力学): $L = 1.5$, $N_e = 2$, $E = 50$, $\\alpha = 0.1$, $M = 10^{-6}$, $\\chi = 0.8$, $\\Delta t = 0.2$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表的列表形式的结果，每个内部列表按 A、B、C、D 的顺序对应一个测试用例，并按任务 3 中指定的顺序包含五个四舍五入后的 Frobenius 范数。例如，格式必须是\n$[\\,[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5],[c_1,c_2,c_3,c_4,c_5],[d_1,d_2,d_3,d_4,d_5]\\,]$\n，不含任何额外文本。每个 $a_i$、$b_i$、$c_i$、$d_i$ 必须四舍五入到恰好 8 位小数。", "solution": "该问题要求推导和计算一个使用有限元法 (FEM) 离散化的一维耦合化学-力学系统的一致切线雅可比矩阵。求解过程分两个主要阶段进行：首先，从给定的弱形式推导单元级切线矩阵；其次，实现一个程序，将这些单元矩阵组装成全局雅可比矩阵，并为一组给定的测试用例计算指定的 Frobenius 范数。\n\n### 任务 1：单元切线矩阵的推导\n\n让我们考虑一个长度为 $h$ 的单个两节点线性有限元。该单元内的位移场 $u(x)$ 和浓度场 $c(x)$ 使用线性形函数 $N_1(x)$ 和 $N_2(x)$ 进行近似。场及其导数可以用节点值 $(u_1, u_2)$ 和 $(c_1, c_2)$ 来表示。\n有限元近似为 $u^h(x) = \\mathbf{N}(x) \\mathbf{u}^e$ 和 $c^h(x) = \\mathbf{N}(x) \\mathbf{c}^e$，其中 $\\mathbf{N} = [N_1, N_2]$ 是形函数向量，$\\mathbf{u}^e = [u_1, u_2]^T$ 和 $\\mathbf{c}^e = [c_1, c_2]^T$ 是节点自由度向量。形函数的空间导数汇集在矩阵 $\\mathbf{B} = \\frac{d\\mathbf{N}}{dx}$ 中。对于一维线性单元，$\\mathbf{B} = \\frac{1}{h}[-1, 1]$。\n导数的离散近似为 $\\frac{du^h}{dx} = \\mathbf{B} \\mathbf{u}^e$ 和 $\\frac{dc^h}{dx} = \\mathbf{B} \\mathbf{c}^e$。\n\n一致切线块是通过求弱形式残差的 Fréchet 导数得到的，正如问题陈述中定义的那样。\n\n**1. 力学切线块, $K_{uu}$**\n定义为 $K_{uu}[\\delta u, \\hat{u}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_u(\\delta u; u + \\epsilon \\hat{u}, c)\\right|_{\\epsilon=0}$。\n$$\nK_{uu}[\\delta u, \\hat{u}] = \\frac{d}{d\\epsilon} \\left[ \\int_0^L \\left( \\frac{d \\delta u}{dx} \\right) E \\left( \\frac{d(u + \\epsilon \\hat{u})}{dx} - \\alpha c \\right) \\, dx \\right]_{\\epsilon=0} = \\int_0^L \\left( \\frac{d \\delta u}{dx} \\right) E \\left( \\frac{d\\hat{u}}{dx} \\right) \\, dx\n$$\n对单个单元进行离散化，并代入有限元近似 $\\frac{d\\delta u^h}{dx} = \\mathbf{B} \\delta\\mathbf{u}^e$ 和 $\\frac{d\\hat{u}^h}{dx} = \\mathbf{B} \\hat{\\mathbf{u}}^e$，我们得到单元矩阵 $K_{uu}^e$：\n$$\n(\\delta \\mathbf{u}^e)^T K_{uu}^e \\hat{\\mathbf{u}}^e = \\int_{e} (\\delta \\mathbf{u}^e)^T \\mathbf{B}^T E \\mathbf{B} \\hat{\\mathbf{u}}^e \\, dx = (\\delta \\mathbf{u}^e)^T \\left( E \\int_e \\mathbf{B}^T \\mathbf{B} \\, dx \\right) \\hat{\\mathbf{u}}^e\n$$\n由于 $\\mathbf{B}$ 在单元上是常数，该积分的计算结果为 $\\mathbf{B}^T \\mathbf{B} h$。\n$$\nK_{uu}^e = E h \\mathbf{B}^T \\mathbf{B} = E h \\left( \\frac{1}{h} \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} \\right) \\left( \\frac{1}{h} [-1, 1] \\right) = \\frac{E}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n\n**2. 力学-浓度耦合块, $K_{uc}$**\n定义为 $K_{uc}[\\delta u, \\hat{c}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_u(\\delta u; u, c + \\epsilon \\hat{c})\\right|_{\\epsilon=0}$。\n$$\nK_{uc}[\\delta u, \\hat{c}] = \\frac{d}{d\\epsilon} \\left[ \\int_0^L \\left( \\frac{d \\delta u}{dx} \\right) E \\left( \\frac{du}{dx} - \\alpha (c + \\epsilon \\hat{c}) \\right) \\, dx \\right]_{\\epsilon=0} = \\int_0^L \\left( \\frac{d \\delta u}{dx} \\right) E (-\\alpha \\hat{c}) \\, dx\n$$\n对一个单元进行离散化，其中 $\\frac{d\\delta u^h}{dx} = \\mathbf{B} \\delta\\mathbf{u}^e$ 和 $\\hat{c}^h = \\mathbf{N} \\hat{\\mathbf{c}}^e$：\n$$\n(\\delta \\mathbf{u}^e)^T K_{uc}^e \\hat{\\mathbf{c}}^e = \\int_{e} (\\delta \\mathbf{u}^e)^T \\mathbf{B}^T (-E \\alpha) \\mathbf{N} \\hat{\\mathbf{c}}^e \\, dx = (\\delta \\mathbf{u}^e)^T \\left( -E\\alpha \\int_e \\mathbf{B}^T \\mathbf{N} \\, dx \\right) \\hat{\\mathbf{c}}^e\n$$\n该积分在参考坐标系 $\\xi \\in [-1, 1]$ 中计算，其中 $dx = h/2 \\, d\\xi$：\n$$\n\\int_e \\mathbf{B}^T \\mathbf{N} \\, dx = \\frac{1}{h} \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} \\int_{-1}^{1} \\frac{1}{2}[1-\\xi, 1+\\xi] \\, \\frac{h}{2} d\\xi = \\frac{1}{4} \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} \\int_{-1}^{1} [1-\\xi, 1+\\xi] \\, d\\xi = \\frac{1}{4} \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix} [2, 2] = \\frac{1}{2} \\begin{bmatrix} -1  -1 \\\\ 1  1 \\end{bmatrix}\n$$\n因此，单元矩阵为：\n$$\nK_{uc}^e = -E\\alpha \\left( \\frac{1}{2} \\begin{bmatrix} -1  -1 \\\\ 1  1 \\end{bmatrix} \\right) = \\frac{E\\alpha}{2} \\begin{bmatrix} 1  1 \\\\ -1  -1 \\end{bmatrix}\n$$\n\n**3. 浓度-力学耦合块, $K_{cu}$**\n定义为 $K_{cu}[\\delta c, \\hat{u}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_c(\\delta c; u + \\epsilon \\hat{u}, c)\\right|_{\\epsilon=0}$。\n$$\nK_{cu}[\\delta c, \\hat{u}] = \\frac{d}{d\\epsilon} \\left[ \\dots - \\int_0^L \\delta c \\, \\chi \\left( \\frac{d(u + \\epsilon \\hat{u})}{dx} \\right) dx \\right]_{\\epsilon=0} = - \\int_0^L \\delta c \\, \\chi \\left( \\frac{d\\hat{u}}{dx} \\right) \\, dx\n$$\n对一个单元进行离散化，其中 $\\delta c^h = \\mathbf{N} \\delta\\mathbf{c}^e$ 和 $\\frac{d\\hat{u}^h}{dx} = \\mathbf{B} \\hat{\\mathbf{u}}^e$：\n$$\n(\\delta \\mathbf{c}^e)^T K_{cu}^e \\hat{\\mathbf{u}}^e = \\int_e (\\delta \\mathbf{c}^e)^T \\mathbf{N}^T (-\\chi) \\mathbf{B} \\hat{\\mathbf{u}}^e \\, dx = (\\delta \\mathbf{c}^e)^T \\left( -\\chi \\int_e \\mathbf{N}^T \\mathbf{B} \\, dx \\right) \\hat{\\mathbf{u}}^e\n$$\n积分部分是 $K_{uc}$ 推导中积分的转置：$\\left( \\frac{1}{2} \\begin{bmatrix} -1  -1 \\\\ 1  1 \\end{bmatrix} \\right)^T = \\frac{1}{2} \\begin{bmatrix} -1  1 \\\\ -1  1 \\end{bmatrix}$。\n因此，单元矩阵为：\n$$\nK_{cu}^e = -\\chi \\left( \\frac{1}{2} \\begin{bmatrix} -1  1 \\\\ -1  1 \\end{bmatrix} \\right) = \\frac{\\chi}{2} \\begin{bmatrix} 1  -1 \\\\ 1  -1 \\end{bmatrix}\n$$\n\n**4. 扩散切线块, $K_{cc}$**\n定义为 $K_{cc}[\\delta c, \\hat{c}] = \\left. \\frac{d}{d\\epsilon} \\mathcal{R}_c(\\delta c; u, c + \\epsilon \\hat{c})\\right|_{\\epsilon=0}$。\n$$\nK_{cc}[\\delta c, \\hat{c}] = \\frac{d}{d\\epsilon} \\left[ \\int_0^L \\delta c \\frac{(c+\\epsilon\\hat{c})-c^n}{\\Delta t} dx + \\int_0^L \\frac{d\\delta c}{dx} M \\frac{d(c+\\epsilon\\hat{c})}{dx} dx - \\dots \\right]_{\\epsilon=0}\n$$\n$$\nK_{cc}[\\delta c, \\hat{c}] = \\int_0^L \\frac{1}{\\Delta t} \\delta c \\hat{c} \\, dx + \\int_0^L M \\frac{d\\delta c}{dx} \\frac{d\\hat{c}}{dx} \\, dx\n$$\n单元矩阵 $K_{cc}^e$ 是两项贡献之和：一项是来自时间导数项的类质量矩阵，另一项是来自扩散项的类刚度矩阵。\n$$\nK_{cc}^e = \\frac{1}{\\Delta t} \\int_e \\mathbf{N}^T \\mathbf{N} \\, dx + M \\int_e \\mathbf{B}^T \\mathbf{B} \\, dx\n$$\n第一个积分是线性单元的标准一致质量矩阵：\n$$\n\\int_e \\mathbf{N}^T \\mathbf{N} \\, dx = \\int_{-1}^1 \\begin{bmatrix} N_1^2  N_1 N_2 \\\\ N_1 N_2  N_2^2 \\end{bmatrix} \\frac{h}{2} d\\xi = \\frac{h}{2} \\begin{bmatrix} 2/3  1/3 \\\\ 1/3  2/3 \\end{bmatrix} = \\frac{h}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}\n$$\n第二个积分是扩散刚度矩阵，其形式与 $K_{uu}^e$ 相同：\n$$\nM \\int_e \\mathbf{B}^T \\mathbf{B} \\, dx = \\frac{M}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n合并两项贡献，我们得到：\n$$\nK_{cc}^e = \\frac{M}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} + \\frac{h}{6 \\Delta t} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}\n$$\n\n### 任务 2 和 3：组装与计算\n\n推导出的 $2 \\times 2$ 单元矩阵使用标准的直接刚度组装法组装成全局 $N \\times N$ 矩阵（$N=N_e+1$）。对于一个包含 $N_e$ 个单元的网格，单元 $i$（连接节点 $i$ 和 $i+1$）的单元矩阵被加到对应于这些节点的全局矩阵子块中。然后，由四个全局块 $K_{uu}$、$K_{uc}$、$K_{cu}$、$K_{cc}$ 构造完整的 $2N \\times 2N$ 雅可比矩阵 $J$。最后，对四个块中的每一个以及完整的雅可比矩阵计算 Frobenius 范数 $\\|A\\|_F = \\sqrt{\\sum_{i,j} |A_{ij}|^2}$。对每个测试用例都执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled chemo-mechanical problem by deriving element matrices,\n    assembling the global Jacobian, and computing Frobenius norms for specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (general coupled)\n        {'L': 1.0, 'Ne': 2, 'E': 10.0, 'alpha': 0.3, 'M': 2.0, 'chi': 0.5, 'dt': 0.1},\n        # Case B (no coupling)\n        {'L': 1.0, 'Ne': 2, 'E': 10.0, 'alpha': 0.0, 'M': 2.0, 'chi': 0.0, 'dt': 0.1},\n        # Case C (stiff transient diffusion)\n        {'L': 1.0, 'Ne': 2, 'E': 10.0, 'alpha': 0.3, 'M': 2.0, 'chi': 0.5, 'dt': 1e-6},\n        # Case D (weak diffusion, stronger mechanics)\n        {'L': 1.5, 'Ne': 2, 'E': 50.0, 'alpha': 0.1, 'M': 1e-6, 'chi': 0.8, 'dt': 0.2},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        L = case['L']\n        Ne = case['Ne']\n        E = case['E']\n        alpha = case['alpha']\n        M = case['M']\n        chi = case['chi']\n        dt = case['dt']\n\n        N = Ne + 1  # Number of nodes\n        h = L / Ne  # Element length\n\n        # 1. Compute element-level tangent matrices (2x2)\n        \n        # K_uu^e = (E/h) * [[1, -1], [-1, 1]]\n        K_uu_e = (E / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # K_uc^e = (E*alpha/2) * [[1, 1], [-1, -1]]\n        K_uc_e = (E * alpha / 2.0) * np.array([[1.0, 1.0], [-1.0, -1.0]])\n\n        # K_cu^e = (chi/2) * [[1, -1], [1, -1]]\n        K_cu_e = (chi / 2.0) * np.array([[1.0, -1.0], [1.0, -1.0]])\n\n        # K_cc^e = (M/h) * [[1, -1], [-1, 1]] + (h / (6*dt)) * [[2, 1], [1, 2]]\n        K_diff_e = (M / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        K_mass_e = (h / (6.0 * dt)) * np.array([[2.0, 1.0], [1.0, 2.0]])\n        K_cc_e = K_diff_e + K_mass_e\n\n        # 2. Assemble global tangent blocks (NxN)\n        K_uu = np.zeros((N, N))\n        K_uc = np.zeros((N, N))\n        K_cu = np.zeros((N, N))\n        K_cc = np.zeros((N, N))\n\n        for e in range(Ne):\n            # Get the degrees of freedom for the current element\n            dof_map = [e, e + 1]\n            # Use np.ix_ to index the submatrices for assembly\n            ix = np.ix_(dof_map, dof_map)\n            \n            K_uu[ix] += K_uu_e\n            K_uc[ix] += K_uc_e\n            K_cu[ix] += K_cu_e\n            K_cc[ix] += K_cc_e\n\n        # Form the full Jacobian (2N x 2N)\n        J = np.zeros((2 * N, 2 * N))\n        J[0:N, 0:N] = K_uu\n        J[0:N, N:2*N] = K_uc\n        J[N:2*N, 0:N] = K_cu\n        J[N:2*N, N:2*N] = K_cc\n\n        # 3. Compute Frobenius norms\n        norm_K_uu = np.linalg.norm(K_uu, 'fro')\n        norm_K_uc = np.linalg.norm(K_uc, 'fro')\n        norm_K_cu = np.linalg.norm(K_cu, 'fro')\n        norm_K_cc = np.linalg.norm(K_cc, 'fro')\n        norm_J = np.linalg.norm(J, 'fro')\n\n        case_results = [norm_K_uu, norm_K_uc, norm_K_cu, norm_K_cc, norm_J]\n        all_results.append(case_results)\n\n    # Final output formatting\n    # Format each number to 8 decimal places\n    formatted_cases = []\n    for case_res in all_results:\n        formatted_nums = [f\"{num:.8f}\" for num in case_res]\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(formatted_cases)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3502753"}]}