{"hands_on_practices": [{"introduction": "量子体系的许多宏观性质，如粒子数和能量，是通过对所有可能状态的微观量进行积分来确定的。这个过程自然引出了包含费米-狄拉克或玻色-爱因斯坦分布函数以及态密度的积分。本练习 [@problem_id:3482692] 提供了从第一性原理推导这些基本的无量纲积分，并实现一个数值稳健的算法来计算它们的第一手实践，这是计算物理学中的一项基石技能。", "problem": "您将基于第一性原理，实现一个程序，用于数值计算在计算材料科学中由量子统计产生的无量纲积分。从费米-狄拉克（FD）占据函数、玻色-爱因斯坦（BE）占据函数以及三维自由粒子态密度的定义出发。仅使用这些定义，推导出依赖于简约化学势和实数阶参数的无量纲积分表达式。具体而言：\n\n- 费米-狄拉克占据函数定义为 $f_{\\mathrm{FD}}(E; \\mu, T) = \\left[\\exp\\!\\left(\\frac{E - \\mu}{k_{\\mathrm{B}} T}\\right) + 1\\right]^{-1}$，其中 $E$ 是能量，$\\mu$ 是化学势，$T$ 是温度，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n\n- 玻色-爱因斯坦占据函数定义为 $f_{\\mathrm{BE}}(E; \\mu, T) = \\left[\\exp\\!\\left(\\frac{E - \\mu}{k_{\\mathrm{B}} T}\\right) - 1\\right]^{-1}$，对于非凝聚的玻色子，有物理约束 $\\mu \\le 0$。\n\n- 三维自由粒子态密度随能量的变化关系为 $D(E) \\propto E^{1/2}$。\n\n从这些基本要素出发，引入无量纲能量变量 $x = E/(k_{\\mathrm{B}} T)$ 和无量纲简约化学势 $\\eta = \\mu/(k_{\\mathrm{B}} T)$（对于费米子）以及 $\\alpha = \\mu/(k_{\\mathrm{B}} T)$（对于玻色子）。然后，通过将 $f_{\\mathrm{FD}}$ 或 $f_{\\mathrm{BE}}$ 与 $D(E)$ 结合，并对变量进行替换为 $x$ 的变换，推导出由实数阶 $j > 0$ 参数化的相应无量纲积分。您的程序必须通过数值积分，计算在指定 $\\eta$ 值下的 $j$ 阶无量纲FD积分，以及在指定 $\\alpha  0$ 值下的 $j$ 阶无量纲BE积分。推导过程应基于原理，且不应使用任何预先制表的特殊函数恒等式。\n\n算法要求：\n\n- 为半无限区间 $x \\in [0, \\infty)$ 上的积分实现自适应数值求积，并谨慎处理以避免指数函数中的数值溢出。您的实现必须在各种情况下都具有鲁棒性，包括费米子的简并极限（大的正 $\\eta$）、费米子的非简并极限（大的负 $\\eta$）以及玻色子的近临界区（$\\alpha \\to 0^{-}$）。\n\n- 您的数值积分应计算到高精度。设计您的算法，以在小参数和大参数极限下都能稳定地计算诸如 $\\left[1 + \\exp\\!\\left(x - \\eta\\right)\\right]^{-1}$ 和 $\\left[\\exp\\!\\left(x - \\alpha\\right) - 1\\right]^{-1}$ 的表达式。\n\n测试套件：\n\n评估以下情况，每种情况产生一个浮点数结果：\n\n- 在 $\\eta = -10.0$ 时的 $j = 1/2$ 阶费米-狄拉克积分。\n- 在 $\\eta = 0.0$ 时的 $j = 1/2$ 阶费米-狄拉克积分。\n- 在 $\\eta = 2.0$ 时的 $j = 1/2$ 阶费米-狄拉克积分。\n- 在 $\\eta = 10.0$ 时的 $j = 1/2$ 阶费米-狄拉克积分。\n- 在 $\\alpha = -5.0$ 时的 $j = 3/2$ 阶玻色-爱因斯坦积分。\n- 在 $\\alpha = -1.0$ 时的 $j = 3/2$ 阶玻色-爱因斯坦积分。\n- 在 $\\alpha = -1 \\times 10^{-6}$ 时的 $j = 3/2$ 阶玻色-爱因斯坦积分（即 $\\alpha = -0.000001$）。\n\n所有积分都是无量纲的，因此无需指定物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与上面列出的完全一致，每个浮点数四舍五入到$8$位小数。例如：$[r_1,r_2,r_3,r_4,r_5,r_6,r_7]$。", "solution": "所述问题具有科学依据，提法得当且客观。它基于量子统计力学的基本原理，提出了一个计算物理学中标准的、可解的问题。所有必要的定义和参数均已提供。因此，该问题是有效的，并将在此给出解答。\n\n目标是推导并数值计算量子统计中的核心无量綱积分。这个过程从统计力学的第一性原理开始。\n\n一个无相互作用粒子系统的宏观性质 $G$ 是通过将微观的能量依赖量 $g(E)$ 对所有可用态进行积分来计算的。这涉及到态密度 $D(E)$ 和统计占据函数 $f(E; \\mu, T)$：\n$$\nG = \\int_0^\\infty g(E) D(E) f(E; \\mu, T) dE\n$$\n问题指明，对于三维自由粒子气体，态密度与能量的关系为 $D(E) \\propto E^{1/2}$。我们可以用一个比例常数 $C_D$ 将其写为 $D(E) = C_D E^{1/2}$。在此背景下，我们感兴趣的量，如粒子数或能量，通常对应于 $g(E) = C_g E^k$ 的形式，其中 $C_g$ 为某个常数，$k$ 为指数。$G$ 的积分于是呈如下形式：\n$$\nG = C \\int_0^\\infty E^k \\cdot E^{1/2} \\cdot f(E; \\mu, T) dE = C \\int_0^\\infty E^{k+1/2} f(E; \\mu, T) dE\n$$\n其中 $C$ 整合了所有比例常数。\n\n为了获得无量纲形式，我们引入无量纲能量变量 $x = E/(k_{\\mathrm{B}} T)$，这意味着 $E = x k_{\\mathrm{B}} T$ 和 $dE = k_{\\mathrm{B}} T dx$。将这些代入积分可得：\n$$\nG = C \\int_0^\\infty (x k_{\\mathrm{B}} T)^{k+1/2} f(x k_{\\mathrm{B}} T; \\mu, T) (k_{\\mathrm{B}} T dx)\n$$\n$$\nG = C (k_{\\mathrm{B}} T)^{k+3/2} \\int_0^\\infty x^{k+1/2} f(x k_{\\mathrm{B}} T; \\mu, T) dx\n$$\n积分部分现在是无量綱的。这类积分的标准“阶数”（记作 $j$）对应于无量纲变量 $x$ 的指数。我们确定阶数为 $j = k+1/2$。因此，一个与 $E^k$ 成正比的物理量会产生一个阶数为 $j = k+1/2$ 的无量纲积分。例如，总粒子数（$k=0$）对应于阶数为 $j=1/2$ 的积分，而总能量（$k=1$）对应于阶数为 $j=3/2$ 的积分。\n\n占据函数 $f$ 也发生了变换。其自变量变为：\n$$\n\\frac{E - \\mu}{k_{\\mathrm{B}} T} = \\frac{E}{k_{\\mathrm{B}} T} - \\frac{\\mu}{k_{\\mathrm{B}} T} = x - \\xi\n$$\n其中 $\\xi$ 是无量纲简约化学势，对于费米子记作 $\\eta = \\mu/(k_{\\mathrm{B}} T)$，对于玻色子记作 $\\alpha = \\mu/(k_{\\mathrm{B}} T)$。\n\n基于此推导，阶数为 $j$ 的无量纲积分具有通用形式：\n$$\nI_j(\\xi) = \\int_0^\\infty \\frac{x^j}{\\exp(x-\\xi) \\pm 1} dx\n$$\n其中分母中的符号对于费米-狄拉克统计为‘$+$’，对于玻色-爱因斯坦统计为‘$-$’。\n\n**费米-狄拉克积分**\n费米-狄拉克（FD）占据函数为 $f_{\\mathrm{FD}} = [\\exp((E-\\mu)/(k_{\\mathrm{B}} T)) + 1]^{-1}$。相应的 $j$ 阶无量綱积分，我们记作 $\\mathcal{F}_j(\\eta)$，是：\n$$\n\\mathcal{F}_j(\\eta) = \\int_0^\\infty \\frac{x^j}{\\exp(x-\\eta)+1} dx\n$$\n对于测试用例，我们必须计算在不同 $\\eta$ 值下 $j=1/2$ 时的该积分。\n\n**玻色-爱因斯坦积分**\n玻色-爱因斯坦（BE）占据函数为 $f_{\\mathrm{BE}} = [\\exp((E-\\mu)/(k_{\\mathrm{B}} T)) - 1]^{-1}$。对于非凝聚玻色子，$\\mu \\le 0$，这意味着 $\\alpha \\le 0$。相应的 $j$ 阶无量纲积分，记作 $\\mathcal{G}_j(\\alpha)$，是：\n$$\n\\mathcal{G}_j(\\alpha) = \\int_0^\\infty \\frac{x^j}{\\exp(x-\\alpha)-1} dx\n$$\n问题要求在不同的 $\\alpha  0$ 值下计算 $j=3/2$ 时的该积分。条件 $\\alpha  0$ 确保对于任何 $x \\ge 0$，指数的自变量 $x-\\alpha$ 都是正数，从而防止分母在 $x > 0$ 时出现奇点。\n\n**数值计算**\n积分在半无限区间 $[0, \\infty)$ 上使用自适应数值求积进行计算，`scipy.integrate.quad` 函数适用于此目的。实现的一个关键方面是对被积函数进行鲁棒的计算，以防止数值溢出和精度损失。\n\n对于FD被积函数 $g(x) = x^j / (\\exp(x-\\eta)+1)$:\n- 如果自变量 $x-\\eta$ 是一个大的正数，$\\exp(x-\\eta)$ 可能会溢出。在这种情况下，$\\exp(x-\\eta)+1 \\approx \\exp(x-\\eta)$，因此被积函数可以精确地近似为 $g(x) \\approx x^j \\exp(-(x-\\eta))$。\n- 如果 $x-\\eta$ 是一个大的负数，$\\exp(x-\\eta) \\to 0$，分母趋近于 $1$。被积函数就是 $x^j$，这是数值稳定的。\n使用条件实现：如果 $x-\\eta$ 超过一个安全阈值（例如，$30$），则使用数值稳定的近似。否则，计算直接表达式。\n\n对于BE被积函数 $h(x) = x^j / (\\exp(x-\\alpha)-1)$:\n- 如果自变量 $x-\\alpha$ 是大的正数，则会发生与FD情况相同的溢出问题，并使用相同的近似 $h(x) \\approx x^j \\exp(-(x-\\alpha))$。\n- 如果 $x-\\alpha$ 接近于零（当 $\\alpha$ 接近于 $0^-$ 且 $x$ 很小时发生），分母 $\\exp(x-\\alpha)-1$ 会遭受灾难性抵消，导致精度严重损失。这是一个经典的数值陷阱，可以通过使用专门的函数 `numpy.expm1(z)` 来解决，该函数旨在为小的 $|z|$ 精确计算 $e^z-1$。\n因此，BE被积函数的实现将结合使用对大自变量的条件检查和对所有其他情况使用 `expm1` 函数，以确保在所有情况下的稳定性。\n\nPython实现将为每种积分类型定义函数，并融入这些数值策略。主 `solve` 函数随后将遍历指定的测试用例，调用相应的积分函数，并将结果格式化为所需精度。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Derives and numerically evaluates dimensionless Fermi-Dirac and Bose-Einstein integrals\n    based on first principles of quantum statistics.\n    \"\"\"\n\n    def _integrand_fd(x, j, eta):\n        \"\"\"\n        Numerically stable integrand for the Fermi-Dirac integral.\n        Integrand is x^j / (exp(x - eta) + 1).\n\n        Args:\n            x (float): Dimensionless energy variable.\n            j (float): Order of the integral.\n            eta (float): Reduced chemical potential.\n\n        Returns:\n            float: Value of the integrand at x.\n        \"\"\"\n        if x == 0.0 and j  0:\n            return np.inf  # Handle singularity for negative j at x=0\n        if x == 0.0 and j == 0:\n            # Special case for j=0 to avoid 0^0 issues, though not used in tests.\n            # The limit depends on eta. For eta > 0, limit is 1. For eta  0, limit is exp(eta).\n             pass \n\n        arg = x - eta\n        # For large positive arguments, exp(arg) overflows.\n        # In this regime, exp(arg) + 1 is numerically identical to exp(arg).\n        # We can rewrite the fraction as x**j * exp(-arg) to avoid overflow.\n        # A threshold of 30 is safe as exp(30) is very large but within float64 limits.\n        if arg > 30.0:\n            return (x**j) * np.exp(-arg)\n        else:\n            return (x**j) / (np.exp(arg) + 1.0)\n\n    def _integrand_be(x, j, alpha):\n        \"\"\"\n        Numerically stable integrand for the Bose-Einstein integral.\n        Integrand is x^j / (exp(x - alpha) - 1).\n\n        Args:\n            x (float): Dimensionless energy variable.\n            j (float): Order of the integral.\n            alpha (float): Reduced chemical potential (must be = 0).\n\n        Returns:\n            float: Value of the integrand at x.\n        \"\"\"\n        if x == 0.0:\n            # For j > 1, the limit is 0.\n            # For j = 1, the limit is -1/alpha if alpha is not 0.\n            # Here j=1.5, so x^1.5 / (exp(x-alpha)-1) -> x^1.5 / (x-alpha) -> 0.\n            return 0.0\n\n        arg = x - alpha\n        # For large positive arguments, exp(arg) overflows.\n        # The approximation exp(arg) - 1 approx exp(arg) holds.\n        # We use the same stable form as in the FD case.\n        if arg > 30.0:\n            return (x**j) * np.exp(-arg)\n        else:\n            # For small arguments, exp(arg) - 1 suffers from catastrophic cancellation.\n            # np.expm1(arg) is designed to compute exp(arg) - 1 accurately.\n            return (x**j) / np.expm1(arg)\n\n    def compute_fd_integral(j, eta):\n        \"\"\"\n        Computes the Fermi-Dirac integral of order j at reduced potential eta.\n        \"\"\"\n        result, _ = integrate.quad(_integrand_fd, 0, np.inf, args=(j, eta))\n        return result\n\n    def compute_be_integral(j, alpha):\n        \"\"\"\n        Computes the Bose-Einstein integral of order j at reduced potential alpha.\n        \"\"\"\n        result, _ = integrate.quad(_integrand_be, 0, np.inf, args=(j, alpha))\n        return result\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'type': 'FD', 'j': 1/2, 'param': -10.0},\n        {'type': 'FD', 'j': 1/2, 'param': 0.0},\n        {'type': 'FD', 'j': 1/2, 'param': 2.0},\n        {'type': 'FD', 'j': 1/2, 'param': 10.0},\n        {'type': 'BE', 'j': 3/2, 'param': -5.0},\n        {'type': 'BE', 'j': 3/2, 'param': -1.0},\n        {'type': 'BE', 'j': 3/2, 'param': -1.0e-6},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'FD':\n            res = compute_fd_integral(case['j'], case['param'])\n        elif case['type'] == 'BE':\n            res = compute_be_integral(case['j'], case['param'])\n        results.append(f\"{res:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3482692"}, {"introduction": "在掌握了评估统计积分的能力之后，本练习 [@problem_id:3482724] 将这些概念应用于一个具体的物理现象：自由电子气中的等离激元色散。你的目标是运用严格的费米-狄拉克统计来计算一种材料属性，并将其与经典的麦克斯韦-玻尔兹曼近似进行比较。这个练习让你深刻理解如何量化经典物理学的失效边界，并认识到量子效应在何种条件下于材料中变得至关重要。", "problem": "考虑一种用于计算材料科学的三维、各向同性、非相对论的自由电子气。令 $n$ 为电子数密度，$m$ 为电子质量，$e$ 为元电荷，$\\varepsilon_0$ 为真空介电常数，$\\hbar$ 为约化 Planck 常数，$k_B$ 为 Boltzmann 常数。将长波长纵向等离激元色散定义为线性响应理论的解 $\\omega(q,T)$，在该理论中，分布仅通过其速度二阶矩进入。在此近似下，波矢大小为 $q$ 和温度为 $T$ 时的等离激元角频率可以用电子等离激元频率 $\\omega_p$ 和平衡分布 $f(\\epsilon)$ 的速度矩来表示，\n$$\n\\omega_p = \\sqrt{\\frac{n e^2}{m \\varepsilon_0}},\\quad \n\\omega^2(q,T;f) = \\omega_p^2 + q^2\\,\\langle v^2 \\rangle_f(T),\n$$\n其中 $\\langle v^2 \\rangle_f(T)$ 表示在三维空间中对平衡分布 $f(\\epsilon)$ 求得的 $v^2$ 的平均值。\n\n需对比以下两种 $f(\\epsilon)$ 的选择：\n1. 适用于自旋为 $\\tfrac{1}{2}$、自旋简并度为 $g_s=2$ 的电子的 Fermi-Dirac 分布，\n$$\nf_{\\mathrm{FD}}(\\epsilon; \\mu,T) = \\frac{1}{1+\\exp\\!\\left(\\frac{\\epsilon-\\mu}{k_B T}\\right)},\n$$\n其中化学势 $\\mu(T)$ 由自由电子的三维态密度 $g(\\epsilon)$ 和电子数密度约束条件确定，\n$$\nn = \\int_0^\\infty g(\\epsilon)\\, f_{\\mathrm{FD}}(\\epsilon;\\mu,T)\\, d\\epsilon,\\quad\ng(\\epsilon) = \\frac{g_s}{2\\pi^2}\\left(\\frac{2 m}{\\hbar^2}\\right)^{3/2}\\sqrt{\\epsilon}.\n$$\n\n2. Maxwell-Boltzmann 分布，\n$$\nf_{\\mathrm{MB}}(\\epsilon; \\mu,T) = \\exp\\!\\left(-\\frac{\\epsilon-\\mu}{k_B T}\\right),\n$$\n其化学势 $\\mu(T)$ 由相同的数密度约束条件 $n = \\int_0^\\infty g(\\epsilon)\\, f_{\\mathrm{MB}}(\\epsilon;\\mu,T)\\, d\\epsilon$ 确定。\n\n对于各向同性分布 $f(\\epsilon)$，速度二阶矩可以通过单粒子动能 $\\langle \\epsilon \\rangle_f(T)$ 计算得出，即 $\\langle v^2 \\rangle_f(T) = \\tfrac{2}{m}\\langle \\epsilon \\rangle_f(T)$，其中\n$$\n\\langle \\epsilon \\rangle_f(T) = \\frac{1}{n}\\int_0^\\infty \\epsilon\\, g(\\epsilon)\\, f(\\epsilon;\\mu,T)\\, d\\epsilon.\n$$\n\n通过将 $\\langle v^2 \\rangle_{f_{\\mathrm{MB}}}(T)$ 和 $\\langle v^2 \\rangle_{f_{\\mathrm{FD}}}(T)$ 代入上述关于 $\\omega^2(q,T;f)$ 的色散关系，定义依赖于温度的 Maxwell-Boltzmann 和 Fermi-Dirac 等离激元频率，分别为 $\\omega_{\\mathrm{MB}}(q,T)$ 和 $\\omega_{\\mathrm{FD}}(q,T)$。\n\n对于给定的容差 $\\delta$（以小数表示）和给定的 $(n,q)$，将失效温度 $T^\\star$ 定义为从高温向下扫描时，用 $f_{\\mathrm{FD}}(\\epsilon)$ 和 $f_{\\mathrm{MB}}(\\epsilon)$ 计算的等离激元色散的相对差异超过 $\\delta$ 的最小温度：\n$$\n\\frac{\\left|\\omega_{\\mathrm{FD}}(q,T) - \\omega_{\\mathrm{MB}}(q,T)\\right|}{\\omega_{\\mathrm{FD}}(q,T)} > \\delta.\n$$\n如果在指定的扫描范围内未找到这样的温度，则返回 $-1$。\n\n您必须实现一个程序，该程序能够：\n- 使用给定的态密度，根据数密度约束求解 Fermi-Dirac 化学势 $\\mu(T)$。\n- 通过上述积分，从第一性原理计算 $\\langle v^2 \\rangle_{f_{\\mathrm{FD}}}(T)$ 和 $\\langle v^2 \\rangle_{f_{\\mathrm{MB}}}(T)$。\n- 构建 $\\omega_{\\mathrm{FD}}(q,T)$ 和 $\\omega_{\\mathrm{MB}}(q,T)$，并评估相对差异判据。\n- 从高温到低温进行对数扫描，高低温均选择为与电子气的费米温度 $T_F$ 成比例，其中 $T_F = \\epsilon_F/k_B$ 且 $\\epsilon_F = \\tfrac{\\hbar^2}{2m}(3\\pi^2 n)^{2/3}$。\n- 输出扫描中（从高到低）第一个不满足容差的温度 $T^\\star$，如果在扫描范围内未找到，则输出 $-1$。\n\n物理单位和输出要求：\n- 对所有量和计算均使用国际单位制 (SI)。\n- 将每个失效温度 $T^\\star$ 以开尔文为单位表示，并四舍五入到最接近的整数。\n- 本问题不使用角度单位。\n- 不得使用百分比；容差必须是小数。\n\n测试套件规范：\n评估以下参数集的失效温度，这些参数集共同探究了典型的金属密度、各种波矢以及一个边界情况：\n1. $n = 8.5\\times 10^{28}\\ \\mathrm{m}^{-3}$，$q = 1.0\\times 10^{9}\\ \\mathrm{m}^{-1}$，$\\delta = 0.05$。\n2. $n = 8.5\\times 10^{28}\\ \\mathrm{m}^{-3}$，$q = 5.0\\times 10^{9}\\ \\mathrm{m}^{-1}$，$\\delta = 0.05$。\n3. $n = 1.0\\times 10^{26}\\ \\mathrm{m}^{-3}$，$q = 1.0\\times 10^{9}\\ \\mathrm{m}^{-1}$，$\\delta = 0.05$。\n4. $n = 1.0\\times 10^{23}\\ \\mathrm{m}^{-3}$，$q = 1.0\\times 10^{9}\\ \\mathrm{m}^{-1}$，$\\delta = 0.05$。\n5. 边界情况：$n = 1.0\\times 10^{28}\\ \\mathrm{m}^{-3}$，$q = 1.0\\times 10^{8}\\ \\mathrm{m}^{-1}$，$\\delta = 0.50$。\n\n温度扫描范围：\n对于每个测试用例，在从 $T_{\\max} = 5\\,T_F$ 到 $T_{\\min} = 0.05\\,T_F$ 的 $N=64$ 个点的对数网格上扫描 $T$。算法必须在此降序列表中找出使上述不等式成立的最小温度 $T$，并返回该温度值（以开尔文为单位，四舍五入到最接近的整数）。如果未找到这样的 $T$，则返回 $-1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的结果，格式为方括号内由逗号分隔的整数列表（例如，\"[T1,T2,T3,T4,T5]\"），其中每个 $T_i$ 是相应测试用例的失效温度（以开尔文为单位），如果在扫描范围内未找到，则为 $-1$。", "solution": "问题要求确定“失效温度”$T^\\star$，该温度定义为自由电子气中等离激元色散的经典近似结果与正确的量子力学结果的偏差达到指定容差 $\\delta$ 时的阈值。解决方案需要基于量子统计学原理进行详尽分析，特别是对比 Fermi-Dirac (FD) 分布与经典的 Maxwell-Boltzmann (MB) 极限。\n\n在线性化的长波长近似下，等离激元色散关系为：\n$$\n\\omega^2(q,T;f) = \\omega_p^2 + q^2\\,\\langle v^2 \\rangle_f(T)\n$$\n其中 $q$ 是波矢大小，$T$ 是温度，$\\omega_p = \\sqrt{n e^2 / (m \\varepsilon_0)}$ 是电子等离激元频率。项 $\\langle v^2 \\rangle_f(T)$ 代表电子的均方速度，其大小取决于平衡能量分布函数 $f(\\epsilon)$。对于各向同性气体，动能为 $\\epsilon = \\frac{1}{2} m v^2$，由此可得关系式 $\\langle v^2 \\rangle_f(T) = \\frac{2}{m}\\langle \\epsilon \\rangle_f(T)$，其中 $\\langle \\epsilon \\rangle_f(T)$ 是每个粒子的平均动能。\n\n问题的核心在于计算 Fermi-Dirac 分布和 Maxwell-Boltzmann 分布下的 $\\langle \\epsilon \\rangle_f(T)$。平均能量定义为：\n$$\n\\langle \\epsilon \\rangle_f(T) = \\frac{1}{n}\\int_0^\\infty \\epsilon\\, g(\\epsilon)\\, f(\\epsilon;\\mu,T)\\, d\\epsilon\n$$\n其中 $n$ 是电子数密度，$\\mu$ 是化学势，$g(\\epsilon)$ 是自旋简并度 $g_s=2$ 的自由电子气的三维态密度：\n$$\ng(\\epsilon) = \\frac{g_s}{2\\pi^2}\\left(\\frac{2 m}{\\hbar^2}\\right)^{3/2}\\sqrt{\\epsilon} = C \\sqrt{\\epsilon}\n$$\n常数 $C$ 是 $C = \\frac{g_s}{2\\pi^2}\\left(\\frac{2 m}{\\hbar^2}\\right)^{3/2}$ 的简写。对于每种分布，化学势 $\\mu(T)$ 由数密度约束条件确定：\n$$\nn = \\int_0^\\infty g(\\epsilon)\\, f(\\epsilon;\\mu,T)\\, d\\epsilon\n$$\n\n首先，我们分析 Maxwell-Boltzmann（经典）情况。分布为 $f_{\\mathrm{MB}}(\\epsilon) = \\exp(-(\\epsilon-\\mu)/(k_B T))$。平均能量 $\\langle \\epsilon \\rangle_{\\mathrm{MB}}(T)$ 被发现是 $\\frac{3}{2} k_B T$，这是能量均分定理的直接推论。这可以通过计算 $n$ 和总能量密度 $U_{\\mathrm{MB}} = \\int \\epsilon g(\\epsilon) f_{\\mathrm{MB}} d\\epsilon$ 的积分来推导，这些都是标准的伽马函数积分。在比值 $U_{\\mathrm{MB}}/n$ 中，化学势项被消去，从而得到这个简单的结果。因此，经典速度矩为：\n$$\n\\langle v^2 \\rangle_{\\mathrm{MB}}(T) = \\frac{2}{m} \\left(\\frac{3}{2} k_B T\\right) = \\frac{3 k_B T}{m}\n$$\n相应的经典等离激元频率为 $\\omega_{\\mathrm{MB}}(q,T) = \\sqrt{\\omega_p^2 + q^2 \\frac{3 k_B T}{m}}$。\n\n接下来，我们讨论 Fermi-Dirac（量子）情况。分布为 $f_{\\mathrm{FD}}(\\epsilon) = (1+\\exp((\\epsilon-\\mu)/(k_B T)))^{-1}$。涉及此分布的积分通常没有简单的闭式解，必须用 Fermi-Dirac 积分表示，其定义为：\n$$\nF_j(\\eta) = \\frac{1}{\\Gamma(j+1)} \\int_0^\\infty \\frac{x^j}{1+e^{x-\\eta}} dx\n$$\n其中 $\\eta = \\mu/(k_B T)$ 是约化化学势，$\\Gamma(z)$ 是伽马函数。\n通过变量替换 $x = \\epsilon / (k_B T)$，数密度约束变为：\n$$\nn = C (k_B T)^{3/2} \\Gamma(3/2) F_{1/2}(\\eta)\n$$\n费米能 $\\epsilon_F = k_B T_F = \\frac{\\hbar^2}{2m}(3\\pi^2 n)^{2/3}$ 是根据 $T=0$ 的极限定义的，在该极限下 $n = \\frac{2}{3}C \\epsilon_F^{3/2}$。将有限温度 $T$ 下的 $n$ 的表达式与包含 $\\epsilon_F$ 的表达式相等，得到关于 $\\eta$ 的条件：\n$$\n\\left(\\frac{T_F}{T}\\right)^{3/2} = \\frac{3\\sqrt{\\pi}}{4} F_{1/2}(\\eta)\n$$\n对于给定的温度 $T$，必须数值求解该方程以得到 $\\eta$。\n类似地，每个粒子的平均能量为：\n$$\n\\langle \\epsilon \\rangle_{\\mathrm{FD}}(T) = \\frac{3}{2} k_B T \\frac{F_{3/2}(\\eta)}{F_{1/2}(\\eta)}\n$$\n因此，量子速度矩为：\n$$\n\\langle v^2 \\rangle_{\\mathrm{FD}}(T) = \\frac{2}{m} \\langle \\epsilon \\rangle_{\\mathrm{FD}}(T) = \\frac{3 k_B T}{m} \\frac{F_{3/2}(\\eta)}{F_{1/2}(\\eta)}\n$$\n量子等离激元频率为 $\\omega_{\\mathrm{FD}}(q,T) = \\sqrt{\\omega_p^2 + q^2 \\langle v^2 \\rangle_{\\mathrm{FD}}(T)}$。\n\n计算算法如下：\n1.  对每个测试用例 $(n, q, \\delta)$，计算派生的常数：费米能 $\\epsilon_F$、费米温度 $T_F$ 和等离激元频率 $\\omega_p$。\n2.  建立一个包含 $N=64$ 个点的对数温度网格，从 $T_{\\max} = 5\\,T_F$ 降序排列到 $T_{\\min} = 0.05\\,T_F$。\n3.  从高到低遍历此网格中的温度 $T$。对于每个 $T$：\n    a.  使用其简单的解析形式计算 $\\omega_{\\mathrm{MB}}(q,T)$。\n    b.  为计算 $\\omega_{\\mathrm{FD}}(q,T)$：\n        i.   确定目标值 $C_{target} = \\frac{4}{3\\sqrt{\\pi}} (T_F/T)^{3/2}$。\n        ii.  数值求解方程 $F_{1/2}(\\eta) = C_{target}$ 以获得约化化学势 $\\eta$。这需要一个求根算法（例如，二分法或 Brent 方法）以及一个用于函数 $F_{1/2}(\\eta)$ 的数值积分器。\n        iii. 使用得到的 $\\eta$，数值计算 $F_{3/2}(\\eta)$ 的积分。\n        iv.  计算 $\\langle v^2 \\rangle_{\\mathrm{FD}}(T)$ 并随后计算 $\\omega_{\\mathrm{FD}}(q,T)$。\n    c.  评估相对差异判据：$\\frac{|\\omega_{\\mathrm{FD}}(q,T) - \\omega_{\\mathrm{MB}}(q,T)|}{\\omega_{\\mathrm{FD}}(q,T)} > \\delta$。\n4.  如果满足该判据，则当前温度 $T$ 即为失效温度 $T^\\star$。记录其值（四舍五入到最接近的整数），然后继续处理下一个测试用例。\n5.  如果循环完成而未满足判据，则表示在指定范围内未找到失效温度。为此情况记录 $-1$。\n6.  最后，将所有测试用例的结果以指定的列表格式收集并呈现。\n此过程系统地比较了量子模型和经典模型，确定了量子效应（由 Fermi-Dirac 统计封装）对等离激元动力学变得显著的温度范围。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import constants, optimize, integrate, special\n\ndef solve():\n    \"\"\"\n    Solves the breakdown temperature problem for a set of test cases.\n    \"\"\"\n    # Physical constants from scipy.constants in SI units\n    m_e = constants.m_e\n    e = constants.e\n    hbar = constants.hbar\n    k_B = constants.k\n    epsilon_0 = constants.epsilon_0\n    \n    # Spin degeneracy for electrons\n    g_s = 2\n\n    def fermi_dirac_integral(j, eta):\n        \"\"\"\n        Computes the complete Fermi-Dirac integral F_j(eta).\n        F_j(eta) = 1/Gamma(j+1) * integral from 0 to inf of x^j / (1 + exp(x-eta)) dx\n        \"\"\"\n        # Numerically stable integrand for the Fermi-Dirac integral\n        def integrand(x):\n            # The term exp(x - eta) can overflow for large x-eta.\n            # When x - eta is large and positive, the denominator is ~exp(x-eta),\n            # so the integrand is x^j * exp(-(x-eta)).\n            if x - eta > 700: # np.log(np.finfo(float).max) ~ 709\n                return 0.0 # Effectively zero\n            return x**j / (1.0 + np.exp(x - eta))\n\n        integral_val, _ = integrate.quad(integrand, 0, np.inf)\n        return integral_val / special.gamma(j + 1)\n\n    def solve_one_case(n, q, delta):\n        \"\"\"\n        Calculates the breakdown temperature T* for a single parameter set.\n        \"\"\"\n        # Calculate derived physical quantities\n        try:\n            # Fermi energy\n            epsilon_F = (hbar**2 / (2 * m_e)) * (3 * np.pi**2 * n)**(2/3)\n            # Fermi temperature\n            T_F = epsilon_F / k_B\n            # Plasma frequency squared\n            omega_p_sq = (n * e**2) / (m_e * epsilon_0)\n        except (ValueError, ZeroDivisionError):\n            # Handles cases with non-physical n\n            return -1\n\n        # Temperature scan range parameters\n        T_max = 5.0 * T_F\n        T_min = 0.05 * T_F\n        N_pts = 64\n        \n        # Avoid issues with T_F=0 for n=0\n        if T_F == 0:\n            return -1\n        \n        # Logarithmic temperature grid, scanned from high to low\n        temp_scan = np.logspace(np.log10(T_min), np.log10(T_max), N_pts)[::-1]\n\n        # Iterate through temperatures from high to low\n        for T in temp_scan:\n            # 1. Maxwell-Boltzmann (classical) calculation\n            v2_MB = (3 * k_B * T) / m_e\n            omega_MB_sq = omega_p_sq + q**2 * v2_MB\n            omega_MB = np.sqrt(omega_MB_sq)\n\n            # 2. Fermi-Dirac (quantum) calculation\n            # Find reduced chemical potential eta = mu / (k_B * T)\n            # Target value for F_{1/2}(eta)\n            target_F_half = (4 / (3 * np.sqrt(np.pi))) * (T_F / T)**(1.5)\n\n            def root_func(eta):\n                # We need to solve F_{1/2}(eta) - target = 0\n                return fermi_dirac_integral(0.5, eta) - target_F_half\n            \n            # Find the root eta. Bracket needs to be wide enough.\n            # For low T/TF, eta is large positive. For high T/TF, eta is large negative.\n            # A bracket like [-40, 400] is robust for the given scan range.\n            try:\n                sol = optimize.root_scalar(root_func, bracket=[-40, 400], method='brentq')\n                eta = sol.root\n            except ValueError:\n                # If root is not bracketed, something is wrong, skip this temp\n                continue\n            \n            # Calculate F_{3/2}(eta) with the found eta\n            F_three_halves = fermi_dirac_integral(1.5, eta)\n\n            # Calculate average energy and velocity squared for FD\n            #", "id": "3482724"}, {"introduction": "在现代计算材料科学中，效率与准确性同等重要，尤其是在高通量筛选或多尺度建模中。本练习 [@problem_id:3482720] 通过引入代理模型的概念，解决了重复计算费米积分所带来的计算瓶颈问题。你将学习构建一个快速而精确的多项式插值函数来替代耗时的直接积分，这项技术对于加速大规模模拟至关重要。", "problem": "你的任务是为无量纲费米积分构建并验证一个代理模型。该积分出现在计算材料科学的占据数和载流子统计计算中。在约化化学势为 $\\eta$ 时，$j$ 阶费米积分定义为积分\n$$\nF_j(\\eta) = \\int_{0}^{\\infty} \\frac{x^j}{1 + e^{x - \\eta}} \\, dx,\n$$\n其中 $j > -1$ 确保了在 $x = 0$ 附近的可积性。在需要聚合大量能带集贡献的电子结构工作流中，对许多 $\\eta$ 值重复计算 $F_j(\\eta)$ 会导致计算成本非常高昂。你必须通过在一组插值节点上进行训练，在指定范围内构建一个代理映射 $\\eta \\mapsto F_j(\\eta)$，然后在独立点上测试该代理模型的保真度。\n\n仅从上面给出的费米-狄拉克分布 $f(x;\\eta) = \\frac{1}{1 + e^{x-\\eta}}$ 和费米积分 $F_j(\\eta)$ 的定义，以及紧区间上的连续函数可以被多项式一致逼近这一事实出发，设计一个算法，该算法能够：\n- 通过直接求积法评估 $F_j(\\eta)$ 的数值稳健的基准值，防止 $e^{x-\\eta}$ 中的溢出，并处理 $j \\in (-1, 0)$ 时的可积端点行为。\n- 在有界区间 $[\\eta_{\\min}, \\eta_{\\max}]$ 上，使用为减轻龙格振荡而选择的 $N$ 个训练节点，为 $F_j(\\eta)$ 训练一个代理插值函数。\n- 通过计算同一区间内 $M$ 个测试点上的最大绝对误差来评估插值保真度。\n\n你的程序必须为以下参数案例测试套件实现这个端到端的流程，每个案例由 $(j, \\eta_{\\min}, \\eta_{\\max}, N, M)$ 表征：\n1. 案例 1：$j = 0.5$, $\\eta_{\\min} = -5$, $\\eta_{\\max} = 5$, $N = 31$, $M = 61$。\n2. 案例 2：$j = -0.5$, $\\eta_{\\min} = -10$, $\\eta_{\\max} = 0$, $N = 31$, $M = 61$。\n3. 案例 3：$j = 1.5$, $\\eta_{\\min} = 0$, $\\eta_{\\max} = 15$, $N = 41$, $M = 81$。\n4. 案例 4：$j = 0.5$, $\\eta_{\\min} = -12$, $\\eta_{\\max} = 12$, $N = 41$, $M = 81$。\n\n要求与说明：\n- 所有量都是无量纲的；不涉及物理单位。\n- 基准积分必须使用对尾部和端点行为稳健的数值求积法在 $(0, \\infty)$ 上进行高精度评估。\n- 必须选择训练节点以最小化等距多项式插值中典型的振荡误差；选择从 $T_N$（第一类切比雪夫多项式）的零点映射而来的节点是可以接受的。\n- 代理模型可以是建立在所选节点上的任何光滑插值函数，并优先考虑在 $[\\eta_{\\min}, \\eta_{\\max}]$ 上的一致逼近；如果能在这些节点上进行适当拟合，使用多项式基是可以接受的。\n- 对于每种情况，计算一个标量，该标量等于相应区间内 $M$ 个测试点上的最大绝对误差：\n$$\n\\max_{k \\in \\{1, \\dots, M\\}} \\left| \\widehat{F}_j(\\eta_k) - F_j(\\eta_k) \\right|,\n$$\n其中 $\\widehat{F}_j$ 是你的代理模型，$\\{ \\eta_k \\}$ 是测试点。\n- 你的程序应生成单行输出，其中包含案例1-4的四个最大绝对误差，形式为用方括号括起来的逗号分隔列表（例如，$[e_1,e_2,e_3,e_4]$），其中每个 $e_i$ 是一个浮点数。\n\n你的实现必须是自包含的，且不应需要任何用户输入或外部文件。最终输出必须是严格符合指定格式的单行文本。", "solution": "该问题要求为 $j$ 阶无量纲费米积分构建并验证一个代理模型，其定义如下：\n$$\nF_j(\\eta) = \\int_{0}^{\\infty} \\frac{x^j}{1 + e^{x - \\eta}} \\, dx\n$$\n这项任务对于计算材料科学中计算电子性质至关重要。代理模型旨在用一个在约化化学势 $\\eta$ 的指定范围内可快速评估的近似，来替代计算成本高昂的直接积分。解决方案分为三个逻辑上不同的阶段：(1) 通过稳健的数值求积为积分建立一个高保真度的“基准”值；(2) 在一组精心选择的节点上构建一个多项式插值函数作为代理模型；(3) 通过在一组密集的测试点上计算与基准值相比的最大绝对误差来评估代理模型的准确性。\n\n**1. 基准值数值评估**\n$F_j(\\eta)$ 的准确评估是此项任务的基础。该积分存在三个主要的数值挑战：\n-   **无穷积分域**：积分为半无限区间 $(0, \\infty)$。\n-   **数值溢出**：当自变量为大的正值时，分母中的项 $e^{x - \\eta}$ 可能会溢出到无穷大，这在 $x \\to \\infty$ 时发生。\n-   **可积奇点**：对于 $j = -0.5$ 的测试案例，项 $x^j$ 变为 $x^{-0.5}$，在积分下限 $x = 0$ 处存在一个可积奇点。\n\n为了应对这些挑战，我们采用 `scipy.integrate.quad` 中实现的自适应求积法。该程序非常适合处理无穷积分域，并且能够处理可积奇点。\n\n为了防止数值溢出，我们重新构造了被积函数的分母，它代表费米-狄拉克分布因子。标准形式是 $f(x;\\eta) = (1 + e^{x-\\eta})^{-1}$。当指数 $z = x - \\eta$ 为大的正值时，我们可以使用数学上等价的形式 $f(x;\\eta) = e^{-(x-\\eta)} / (1 + e^{-(x-\\eta)})$。当 $x-\\eta$ 很大且为正时，$e^{-(x-\\eta)}$ 趋近于 $0$，该表达式能稳健地计算出近似等于 $e^{-(x-\\eta)}$ 的值。因此，我们采用了一种被积函数的混合实现：\n$$\ng(x, j, \\eta) = \\frac{x^j}{1 + e^{x - \\eta}} = \n\\begin{cases} \nx^j e^{-(x-\\eta)}  \\text{if } x-\\eta > C \\\\\nx^j / (1 + e^{x - \\eta})  \\text{if } x-\\eta \\le C \n\\end{cases}\n$$\n其中 $C$ 是一个阈值，其选择要足够大，以至于在浮点精度内 $1 + e^C \\approx e^C$（例如，$C=30$）。这确保了在大 $x$ 值下的稳定性。`scipy.integrate.quad` 函数足够稳健，可以在无需进一步修改的情况下处理 $j \\in (-1, 0)$ 时在 $x=0$ 处的 $x^j$ 奇点。\n\n**2. 通过多项式插值构建代理模型**\n问题指出，紧区间上的连续函数可以由多项式一致逼近。我们将为 $F_j(\\eta)$ 在区间 $[\\eta_{\\min}, \\eta_{\\max}]$ 上构建这样一个多项式插值函数。天真地选择等距插值节点会导致在区间端点附近出现大的振荡误差，这一现象被称为龙格现象。\n\n为了减轻这种情况，我们选择第一类切比雪夫节点作为插值节点。这些节点是半圆上等距点在其直径上的投影，它们在区间端点附近更为密集。对于一个 $N-1$ 次（使用 $N$ 个节点）的插值多项式，在规范区间 $[-1, 1]$ 上的切比雪夫节点由下式给出：\n$$\nz_k = \\cos\\left(\\frac{2k+1}{2N}\\pi\\right), \\quad k = 0, 1, \\dots, N-1\n$$\n然后将这些节点线性映射到目标区间 $[\\eta_{\\min}, \\eta_{\\max}]$：\n$$\n\\eta^{\\text{train}}_k = \\frac{\\eta_{\\max} - \\eta_{\\min}}{2} z_k + \\frac{\\eta_{\\max} + \\eta_{\\min}}{2}\n$$\n在每个训练节点 $\\eta^{\\text{train}}_k$ 处，我们计算基准积分值 $y^{\\text{train}}_k = F_j(\\eta^{\\text{train}}_k)$。\n\n利用这 $N$ 个训练点对 $(\\eta^{\\text{train}}_k, y^{\\text{train}}_k)$，我们构建插值多项式。为保证数值稳定性和效率，我们将此多项式表示为切比雪夫级数，即第一类切比雪夫多项式 $T_n(z)$ 的和。我们使用 `numpy.polynomial.chebyshev.Chebyshev.fit` 来找到穿过这些训练点的 $N-1$ 次切比雪夫级数的系数。这个拟合得到的级数 $\\widehat{F}_j(\\eta)$ 即为我们的代理模型。\n\n**3. 保真度评估**\n最后一步是量化代理模型 $\\widehat{F}_j(\\eta)$ 的准确性。保真度通过代理模型与基准函数在整个区间上的最大绝对误差来衡量。该误差通过在跨越 $[\\eta_{\\min}, \\eta_{\\max}]$ 的 $M$ 个等距分布的测试点 $\\{\\eta^{\\text{test}}_k\\}$ 上评估差值来估计：\n$$\n\\eta^{\\text{test}}_k = \\eta_{\\min} + k \\frac{\\eta_{\\max} - \\eta_{\\min}}{M-1}, \\quad k = 0, 1, \\dots, M-1\n$$\n然后，最大绝对误差计算如下：\n$$\nE_{\\max} = \\max_{k \\in \\{0, \\dots, M-1\\}} \\left| \\widehat{F}_j(\\eta^{\\text{test}}_k) - F_j(\\eta^{\\text{test}}_k) \\right|\n$$\n其中 $F_j(\\eta^{\\text{test}}_k)$ 使用第一节中描述的稳健数值求积方法计算。对四个指定的测试案例中的每一个都执行这整个流程。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to solve the Fermi integral surrogate modeling problem for all test cases.\n    \"\"\"\n\n    def robust_integrand(x, j, eta):\n        \"\"\"\n        Numerically robust integrand for the Fermi integral F_j(eta).\n        Handles overflow in the exponential term.\n        \"\"\"\n        # The term x^j can cause a RuntimeWarning for x=0 if j0, but this is expected\n        # and handled by quad.\n        with np.errstate(divide='ignore'):\n            power_term = x**j\n\n        # Handle overflow in the Fermi-Dirac distribution factor\n        exponent_arg = x - eta\n        if exponent_arg > 30: # Threshold for overflow prevention\n            # For large positive exponent, 1/(1+e^z) -> e^-z\n            return power_term * np.exp(-exponent_arg)\n        else:\n            return power_term / (1.0 + np.exp(exponent_arg))\n\n    def compute_fermi_integral(j, eta):\n        \"\"\"\n        Computes the ground-truth Fermi integral F_j(eta) using numerical quadrature.\n        \"\"\"\n        # quad returns a tuple (result, error_estimate)\n        result, _ = quad(robust_integrand, 0, np.inf, args=(j, eta))\n        return result\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (j, eta_min, eta_max, N, M)\n        (0.5, -5.0, 5.0, 31, 61),\n        (-0.5, -10.0, 0.0, 31, 61),\n        (1.5, 0.0, 15.0, 41, 81),\n        (0.5, -12.0, 12.0, 41, 81),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        j, eta_min, eta_max, N, M = case\n\n        # 1. Generate N Chebyshev training nodes in the interval [eta_min, eta_max]\n        # These are the roots of the Chebyshev polynomial T_N, also known as\n        # Chebyshev points of the first kind.\n        cheb_nodes_unit = np.polynomial.chebyshev.chebpts1(N) # Nodes in [-1, 1]\n        \n        # Map nodes to the target interval\n        eta_train = 0.5 * (eta_max - eta_min) * cheb_nodes_unit + 0.5 * (eta_max + eta_min)\n        \n        # 2. Compute ground-truth values at training nodes\n        # Vectorize the ground-truth function for efficient evaluation\n        v_compute_fermi_integral = np.vectorize(compute_fermi_integral)\n        y_train = v_compute_fermi_integral(j, eta_train)\n\n        # 3. Build the surrogate model by fitting a Chebyshev polynomial\n        # A polynomial of degree N-1 interpolates N points.\n        surrogate_model = np.polynomial.chebyshev.Chebyshev.fit(\n            eta_train, y_train, deg=N - 1, domain=[eta_min, eta_max]\n        )\n\n        # 4. Generate M equispaced test points\n        eta_test = np.linspace(eta_min, eta_max, M)\n\n        # 5. Evaluate both surrogate and ground-truth at test points\n        y_surrogate = surrogate_model(eta_test)\n        y_truth = v_compute_fermi_integral(j, eta_test)\n\n        # 6. Compute the maximum absolute error\n        max_error = np.max(np.abs(y_surrogate - y_truth))\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.10e}' for err in results)}]\")\n\nsolve()\n\n```", "id": "3482720"}]}