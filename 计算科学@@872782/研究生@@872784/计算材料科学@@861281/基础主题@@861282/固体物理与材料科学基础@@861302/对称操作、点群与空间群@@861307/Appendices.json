{"hands_on_practices": [{"introduction": "点群是描述分子和晶体对称性的数学语言。相比于记忆群的乘法表，一种更基本的方法是理解如何从一小组“生成元”操作构建出整个群。本练习 [@problem_id:3491365] 提供了从两个生成元出发，通过算法枚举出 $C_{4v}$ 点群的所有元素并将其划分为共轭类的实践，从而帮助你掌握群的内在结构。", "problem": "在计算材料科学中，二维方格网的点群对称性是晶格动力学、电子结构采样和空间群构建中约束条件的基础。考虑平面中一个完美正方形的点群，它由绕平面外轴旋转 $90^\\circ$ 的旋转操作和穿过正方形中心的竖直线进行的镜面反映操作生成。分别用 $C_{4}$ 和 $\\sigma_{v}$ 表示这些生成元。仅使用欧几里得等距变换复合下的群操作基本定义、将 $C_{4}$ 与自身复合四次得到单位元、将任何镜面反映与自身复合得到单位元，以及用镜面反映共轭一个旋转会反转其旋转方向这些事实，执行以下任务：\n- 通过复合和求逆运算的闭包，算法化地枚举出由 $\\{C_{4},\\sigma_{v}\\}$ 生成的群的所有不同元素。\n- 在共轭运算 $g : x \\mapsto g x g^{-1}$ 下，将所得元素划分为共轭类，并为每个类提供至少一个代表元。\n- 根据你的枚举确定群的阶。\n\n仅提供最终的群阶作为答案。不包含任何单位。不要四舍五入。最终答案必须是单个数字。", "solution": "用户提供了一个问题，要求枚举由两个特定对称操作生成的有限群中的元素，将这些元素划分为共轭类，并确定该群的阶。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- **系统**：二维平面中完美正方形的点群。\n- **生成元**：$C_4$（绕中心旋转 $90^\\circ$）和 $\\sigma_v$（穿过中心的竖直线的镜面反映）。\n- **公理化性质**：\n    - 群操作是欧几里得等距变换的复合。\n    - $C_4^4 = E$，其中 $E$ 是单位元。\n    - 对于任何镜面反映 $\\sigma$，有 $\\sigma^2 = E$。特别地，$\\sigma_v^2 = E$，这意味着 $\\sigma_v^{-1} = \\sigma_v$。\n    - 用镜面反映共轭一个旋转会反转其旋转方向：$\\sigma C_n \\sigma^{-1} = C_n^{-1}$。对于本问题，其形式为 $\\sigma_v C_4 \\sigma_v^{-1} = C_4^{-1}$。\n- **任务**：\n    - 枚举由 $\\{C_4, \\sigma_v\\}$ 生成的所有不同元素。\n    - 将元素划分为共轭类。\n    - 确定群的阶。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学依据**：该问题在有限群的数学理论（特别是点群）中有很好的基础，这是物理学、化学和材料科学中的一个基本概念。所描述的群是二面体群 $D_4$，在晶体学符号中也称为点群 $4mm$。为生成元给出的性质是该群的正确定义关系。\n- **良定性**：该问题是良定的。生成元及其关系足以唯一地定义一个有限群。枚举元素、划分为共轭类和求阶是群论中具有唯一解的标准过程。\n- **客观性**：问题陈述完全客观，并使用了精确的数学术语。\n\n**1.3. 结论与行动**\n该问题是有效的。它在科学上是合理的、良定的和客观的。没有缺陷、矛盾或缺失的信息。我将继续提供完整解答。\n\n### 步骤 2：解答推导\n\n群 $G$ 由元素集合 $\\{C_4, \\sigma_v\\}$ 生成。我们已知关系：\n1. $C_4^4 = E$\n2. $\\sigma_v^2 = E$\n3. $\\sigma_v C_4 \\sigma_v^{-1} = C_4^{-1}$\n\n由于 $\\sigma_v^2 = E$，我们有 $\\sigma_v^{-1} = \\sigma_v$。第三个关系可以改写为 $\\sigma_v C_4 \\sigma_v = C_4^{-1}$。在右边乘以 $\\sigma_v$ 得到对易关系：\n$$\n\\sigma_v C_4 = C_4^{-1} \\sigma_v = C_4^3 \\sigma_v\n$$\n这个规则是关键，因为它允许我们将任何生成元的乘积重写为一种规范形式，通常是 $C_4^k \\sigma_v^m$ 的形式。\n\n**2.1. 群元素的枚举**\n\n我们从单位元 $E$ 开始，通过重复应用生成元来算法化地生成所有不同的元素，直到元素集合在复合运算下是封闭的。\n\n首先，考虑由 $C_4$ 生成的循环子群：\n- $C_4^0 = E$ (单位元)\n- $C_4^1 = C_4$ (旋转 $90^\\circ$)\n- $C_4^2 = C_2$ (旋转 $180^\\circ$)\n- $C_4^3 = C_4^{-1}$ (旋转 $270^\\circ$)\n- $C_4^4 = E$ (闭合)\n这给出了四个不同旋转元素的集合：$\\{E, C_4, C_2, C_4^3\\}$。这是循环群 $C_4$。\n\n接下来，我们引入第二个生成元 $\\sigma_v$，并通过将其与 $C_4$ 子群的现有元素复合来形成新元素。我们可以形成陪集 $C_4 \\sigma_v = \\{g\\sigma_v | g \\in C_4\\}$：\n- $E \\sigma_v = \\sigma_v$。这是初始的竖直反映。\n- $C_4 \\sigma_v$。让我们识别这个操作。使用中心为 $(0,0)$ 的坐标系，$C_4$ 将 $(x, y)$ 映射到 $(-y, x)$，而 $\\sigma_v$（关于 $y$ 轴的反映）将 $(x, y)$ 映射到 $(-x, y)$。复合操作 $C_4 \\sigma_v$ 将 $(x, y) \\xrightarrow{\\sigma_v} (-x, y) \\xrightarrow{C_4} (-y, -x)$。这是关于直线 $y = -x$ 的反映。我们将其表示为 $\\sigma_{d'}$。\n- $C_2 \\sigma_v$。复合操作 $C_2 \\sigma_v$ 将 $(x, y) \\xrightarrow{\\sigma_v} (-x, y) \\xrightarrow{C_2} (-(-x), -y) = (x, -y)$。这是关于 $x$ 轴的反映，我们将其表示为 $\\sigma_h$。\n- $C_4^3 \\sigma_v$。复合操作 $C_4^3 \\sigma_v$ 将 $(x, y) \\xrightarrow{\\sigma_v} (-x, y) \\xrightarrow{C_4^3} (y, x)$。这是关于直线 $y=x$ 的反映。我们将其表示为 $\\sigma_d$。\n\n所有元素的集合是旋转子群及其陪集的并集：\n$$\nG = \\{E, C_4, C_2, C_4^3\\} \\cup \\{\\sigma_v, \\sigma_h, \\sigma_d, \\sigma_{d'}\\}\n$$\n$8$个不同元素的完整列表是：\n$G = \\{E, C_4, C_2, C_4^3, \\sigma_v, \\sigma_h, \\sigma_d, \\sigma_{d'}\\}$。\n该群是封闭的。从此集合中任意两个元素的乘积都将得到集合内的另一个元素，这可以通过使用对易关系 $\\sigma_v C_4 = C_4^3 \\sigma_v$ 和基本关系来验证。例如，$\\sigma_h \\sigma_d = (C_2 \\sigma_v)(C_4^3 \\sigma_v) = C_2 (\\sigma_v C_4^3) \\sigma_v = C_2 (C_4 \\sigma_v) \\sigma_v = C_2 C_4 \\sigma_v^2 = C_2 C_4 E = C_4^2 C_4 = C_4^3$。\n\n群的阶，记为 $|G|$，是不同元素的总数。通过枚举，我们得到 $|G| = 8$。\n\n**2.2. 划分为共轭类**\n\n一个元素 $x \\in G$ 的共轭类是集合 $Cl(x) = \\{gxg^{-1} | g \\in G\\}$。\n\n1.  **$E$ 的类**：对于任何 $g \\in G$，$gEg^{-1} = gg^{-1} = E$。因此，$Cl(E) = \\{E\\}$。\n2.  **$C_2$ 的类**：\n    - 对于任何旋转 $g = C_4^k$：$C_4^k C_2 (C_4^k)^{-1} = C_4^k C_4^2 C_4^{-k} = C_2$，因为旋转构成一个阿贝尔子群。\n    - 对于任何反映 $g = \\sigma$：$\\sigma C_2 \\sigma^{-1} = C_2^{-1} = C_2$。\n    因此，$C_2$ 只与自身共轭。$Cl(C_2) = \\{C_2\\}$。\n3.  **$C_4$ 的类**：\n    - 对于任何旋转 $g = C_4^k$：$C_4^k C_4 (C_4^k)^{-1} = C_4$。\n    - 对于任何反映 $g = \\sigma$：$\\sigma C_4 \\sigma^{-1} = C_4^{-1} = C_4^3$。\n    因此，$C_4$ 与 $C_4^3$ 共轭。$Cl(C_4) = \\{C_4, C_4^3\\}$。\n4.  **$\\sigma_v$ 的类**：\n    - $C_4 \\sigma_v C_4^{-1} = C_4 \\sigma_v C_4^3$。使用关系式 $\\sigma_v C_4 = C_4^3 \\sigma_v$，我们有 $C_4 \\sigma_v = \\sigma_v C_4^3$。这是不正确的。正确的关系是 $C_4 \\sigma_v = (\\sigma_v C_4^{-1})^{-1}$，但这没有用。\n    - 让我们使用对易关系 $\\sigma_v C_4 = C_4^3 \\sigma_v$。那么 $C_4 \\sigma_v C_4^3 = (C_4 \\sigma_v) C_4^3 = (\\sigma_v^{-1} C_4^3) C_4^3 = \\sigma_v C_4^6 = \\sigma_v C_2 = C_2 \\sigma_v = \\sigma_h$。这似乎过于复杂了。\n    - 关系式 $\\sigma_v C_4 = C_4^3 \\sigma_v$ 给出 $C_4 \\sigma_v = \\sigma_v C_4^3$。\n    - 让我们重新考虑 $C_4 \\sigma_v C_4^{-1} = C_4 \\sigma_v C_4^3$。我们之前推导出 $\\sigma_h = C_2 \\sigma_v$，并且 $\\sigma_v$ 与 $C_2$ 可交换。所以 $C_4 \\sigma_v C_4^{-1} = C_4 (\\sigma_v C_4^3) = C_4 (C_4 \\sigma_v) = C_2 \\sigma_v = \\sigma_h$。\n    - 用 $C_4$ 对 $\\sigma_v$ 进行共轭得到 $\\sigma_h$。因此，$\\sigma_v$ 和 $\\sigma_h$ 在同一个类中。\n    - 让我们用 $\\sigma_d = C_4^3 \\sigma_v$ 对 $\\sigma_v$ 进行共轭。$ \\sigma_d \\sigma_v \\sigma_d^{-1} = (C_4^3 \\sigma_v) \\sigma_v (C_4^3 \\sigma_v)^{-1} = C_4^3 \\sigma_v^2 \\sigma_v^{-1} (C_4^3)^{-1} = C_4^3 E \\sigma_v^{-1} C_4 = C_4^3 \\sigma_v C_4 = C_4^3 (C_4^3 \\sigma_v) = C_4^6 \\sigma_v = C_2 \\sigma_v = \\sigma_h$。\n    - 这证实了反映 $\\sigma_v$ 和 $\\sigma_h$ 构成一个单一的共轭类。$Cl(\\sigma_v) = \\{\\sigma_v, \\sigma_h\\}$。\n5.  **$\\sigma_d$ 的类**：\n    - 剩下的元素是 $\\sigma_d$ 和 $\\sigma_{d'}$。它们必须构成最后一个类。我们来检验一下：\n    - 用 $C_4$ 对 $\\sigma_d$ 进行共轭：$C_4 \\sigma_d C_4^{-1} = C_4 (C_4^3 \\sigma_v) C_4^3 = C_4^4 \\sigma_v C_4^3 = E \\sigma_v C_4^3 = \\sigma_v C_4^3 = C_4 \\sigma_v = \\sigma_{d'}$。\n    - 因此，$Cl(\\sigma_d) = \\{\\sigma_d, \\sigma_{d'}\\}$。\n\n共轭类是：\n- $\\{E\\}$ (大小为 $1$)\n- $\\{C_2\\}$ (大小为 $1$)\n- $\\{C_4, C_4^3\\}$ (大小为 $2$)\n- $\\{\\sigma_v, \\sigma_h\\}$ (大小为 $2$)\n- $\\{\\sigma_d, \\sigma_{d'}\\}$ (大小为 $2$)\n各类的大小之和为 $1 + 1 + 2 + 2 + 2 = 8$，等于群的阶，为我们的枚举提供了一个必要的一致性检验。\n\n**2.3. 群的阶**\n基于由 $\\{C_4, \\sigma_v\\}$ 生成的所有不同元素的枚举，该群包含 $8$ 个元素。\n因此，该群的阶为 $8$。", "answer": "$$\\boxed{8}$$", "id": "3491365"}, {"introduction": "在计算材料科学中，来自模拟或实验的原子坐标由于数值噪声或热振动，永远不会是完美对称的。这给对称性检测算法带来了挑战。本实践 [@problem_id:3491404] 将指导你实现一个基于容差的对称性分析程序，这是一个用于稳健地识别正确空间群并诊断“赝对称”（即结构接近更高对称性构型）情况的关键工具。", "problem": "实现一个程序，该程序给定一个作用于周期性晶体原子分数坐标的有限候选对称操作集，扫描一个位置容差列表，在每个容差下从一个固定的目录中指派最高对称性的空间群，量化该指派在不同容差下的稳定性，并通过识别指派群的复杂度首次严格增加时的容差来检测赝对称性。该问题必须在以下基于晶体学对称性核心定义的严格数学规范下解决。\n\n一个晶体由以下部分表示：\n- 一个晶格矩阵 $\\mathbf{L}\\in\\mathbb{R}^{3\\times 3}$，其列是实空间基矢 $\\mathbf{a},\\mathbf{b},\\mathbf{c}$，单位为埃（Angstrom），记作 $\\text{\\AA}$。\n- 一组 $N$ 个分数坐标 $\\{\\mathbf{f}_i\\in [0,1)^3\\}_{i=1}^N$ 以及物种标签（对于此问题，所有原子使用单一物种）。从分数坐标到笛卡尔坐标的映射为 $\\mathbf{r}=\\mathbf{L}\\,\\mathbf{f}$，其中 $\\mathbf{f}$ 是一个列向量。\n\n在此问题中，一个对称操作被限制为无平移的同构操作，并由一个整数正交旋转（或旋转反射）矩阵 $\\mathbf{R}\\in\\mathrm{O}(3,\\mathbb{Z})$ 表示。如果对于一个结构，在位置容差 $\\varepsilon$（单位为 $\\text{\\AA}$）下，在变换后的分数坐标位置 $\\{\\mathbf{f}'_i=\\mathbf{R}\\mathbf{f}_i\\ \\mathrm{mod}\\ 1\\}$ 与原始集合 $\\{\\mathbf{f}_j\\}$ 之间存在一一对应关系，使得每一对匹配的原子在最小镜像度量下的距离都在 $\\varepsilon$ 以内，则称操作 $\\mathbf{R}$ 被该结构满足：对于每一对匹配，其笛卡尔距离\n$$\nd_{ij} \\equiv \\min_{\\mathbf{n}\\in\\mathbb{Z}^3} \\left\\| \\mathbf{L}\\left(\\mathbf{f}'_i-\\mathbf{f}_j+\\mathbf{n}\\right) \\right\\|_2 \\le \\varepsilon,\n$$\n其中 $\\|\\cdot\\|_2$ 为欧几里得范数。最小镜像搜索必须通过检查所有分量在 $\\{-1,0,1\\}$ 内的整数平移 $\\mathbf{n}$ 并选择最小范数来精确执行。\n\n给定一个固定的候选操作目录，每个操作由其关于原点的矩阵 $\\mathbf{R}$ 指定（以下所有角度均以度为单位）：\n- 恒等操作 $E$：$\\mathbf{R}=\\mathrm{diag}(1,1,1)$。\n- 反演操作 $I$：$\\mathbf{R}=\\mathrm{diag}(-1,-1,-1)$。\n- 绕 $z$ 轴的二次旋转 $C_{2z}$：$\\mathbf{R}=\\mathrm{diag}(-1,-1,1)$。\n- 绕 $z$ 轴的四次旋转 $C_{4z}$：\n$$\n\\mathbf{R}=\\begin{bmatrix}\n0  -1  0\\\\\n1  0  0\\\\\n0  0  1\n\\end{bmatrix}。\n$$\n- 关于 $x=0$ 平面的镜面反射 $m_x$：$\\mathbf{R}=\\mathrm{diag}(-1,1,1)$。\n- 关于 $y=0$ 平面的镜面反射 $m_y$：$\\mathbf{R}=\\mathrm{diag}(1,-1,1)$。\n- 关于 $z=0$ 平面的镜面反射 $m_z$：$\\mathbf{R}=\\mathrm{diag}(1,1,-1)$。\n\n定义以下空间群代理目录（每个由一个整数编码和必需满足的最小操作集合标识）。在给定容差下指派的群是那个其必需操作全部被满足且必需操作数量最多的群；平局必须由较大的编码打破：\n- 编码 $1$：$P1$，要求 $\\{E\\}$。\n- 编码 $2$：$P\\bar{1}$，要求 $\\{E,I\\}$。\n- 编码 $3$：$P2(z)$，要求 $\\{E,C_{2z}\\}$。\n- 编码 $4$：$Pm(x)$，要求 $\\{E,m_x\\}$。\n- 编码 $5$：$P4$，要求 $\\{E,C_{4z},C_{2z}\\}$。\n- 编码 $6$：$P4/m$，要求 $\\{E,C_{4z},C_{2z},m_z\\}$。\n- 编码 $7$：$Pmm$，要求 $\\{E,m_x,m_y\\}$。\n- 编码 $8$：$P4mm$，要求 $\\{E,C_{4z},C_{2z},m_x,m_y\\}$。\n\n给定一个容差列表 $\\{\\varepsilon_k\\}_{k=1}^K$（单位为 $\\text{\\AA}$），定义指派序列 $\\{G_k\\}_{k=1}^K$，其中 $G_k$ 是在 $\\varepsilon_k$ 下指派的群编码。令 $c(G)$ 表示群 $G$ 的必需操作数量（例如，$c(8)=5$）。如果在某个索引 $k^\\star$ 处，$c(G_{k^\\star})>c(G_{k^\\star-1})$ 且该 $k^\\star\\in\\{2,\\dots,K\\}$ 是满足此条件的最小值，则称发生了赝对称性跳变。令 $\\varepsilon^\\star=\\varepsilon_{k^\\star}$，$G=G_{k^\\star-1}$，以及 $H=G_{k^\\star}$。若不存在此索引，则没有跳变。\n\n定义稳定性得分 $s$ 为众数群（在 $\\{G_k\\}$ 中出现最频繁的编码；若频率相同，则选择 $c(G)$ 较大的群，若仍相同，则选择编码较大的群）在整个容差列表中出现的比例。\n\n仅使用指定的操作和群，并遵循这些核心定义来实现上述功能。所有角度必须以度为单位处理，所有位置容差和晶格长度必须以 $\\text{\\AA}$ 为单位。\n\n输入数据通过以下测试套件嵌入程序中（无用户输入）。晶格矩阵 $\\mathbf{L}$ 将使用标准的三斜晶系约定，根据长度和角度构建，其中列为晶格矢量：\n- 结构 $S_1$（近似四次对称但有轻微各向异性；赝对称的）：\n    - 晶格参数：$a=b=3.5\\,\\text{\\AA}$，$c=10.0\\,\\text{\\AA}$，$\\alpha=\\beta=\\gamma=90^\\circ$。\n    - 分数坐标位置：四个原子位于 $(0.5+u,0.5,0)$, $(0.5-u,0.5,0)$, $(0.5,0.5+v,0)$, $(0.5,0.5-v,0)$，其中 $u=0.2$，$v=0.196$。\n- 结构 $S_2$（普通倾斜，无超越恒等的对称性）：\n    - 晶格参数：$a=3.2\\,\\text{\\AA}$，$b=4.7\\,\\text{\\AA}$，$c=12.0\\,\\text{\\AA}$，$\\alpha=90^\\circ$，$\\beta=90^\\circ$，$\\gamma=80^\\circ$。\n    - 分数坐标位置：三个原子位于 $(0.1,0.2,0.0)$, $(0.33,0.73,0.0)$, $(0.81,0.27,0.0)$。\n- 结构 $S_3$（完美的四次对称）：\n    - 晶格参数：与 $S_1$ 相同。\n    - 分数坐标位置：四个原子位于 $(0.5+u,0.5,0)$, $(0.5-u,0.5,0)$, $(0.5,0.5+v,0)$, $(0.5,0.5-v,0)$，其中 $u=0.2$，$v=0.2$。\n\n容差扫描（单位为 $\\text{\\AA}$）固定为 $\\{\\varepsilon_k\\}=\\{0.0005,\\,0.005,\\,0.02,\\,0.05\\}$。\n\n您的程序必须：\n- 对于每个结构和每个容差 $\\varepsilon_k$，确定满足的操作集合，根据上述规则从目录中指派群编码 $G_k$，并生成序列 $\\{G_k\\}$。\n- 计算赝对称性标志 $p$，如果发生跳变则等于 $1$，否则为 $0$。\n- 计算第一个跳变容差 $\\varepsilon^\\star$（单位为 $\\text{\\AA}$），四舍五入到四位小数；如果没有跳变，输出 $-1.0$。\n- 计算跳变对 $(G,H)$（整数形式）；如果没有跳变，输出 $(-1,-1)$。\n- 计算稳定性得分 $s$（一个在 $[0,1]$ 范围内的十进制数），四舍五入到三位小数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含 $S_1$，$S_2$ 和 $S_3$ 的结果，形式为一个逗号分隔的列表，并用方括号括起来。其中每个测试用例的结果是列表 $[p,\\varepsilon^\\star,G,H,s]$。例如，一个语法模板是 $[[p_1,\\varepsilon^\\star_1,G_1,H_1,s_1],[p_2,\\varepsilon^\\star_2,G_2,H_2,s_2],[p_3,\\varepsilon^\\star_3,G_3,H_3,s_3]]$。角度必须以度为单位，距离和容差必须以 $\\text{\\AA}$ 为单位。", "solution": "该问题要求实现一个计算流程来分析三维周期性晶体结构的对称性。这涉及到确定给定目录中的哪些对称操作在指定的位置容差 $\\varepsilon$ 内被一个结构所满足，基于这些满足的操作指派一个空间群代理，并分析当容差变化时该指派如何改变。最终输出包括对赝对称性的表征和指派稳定性的度量。\n\n该方法遵循问题陈述中提供的精确数学定义。\n\n首先，我们建立晶体的几何表示。晶格由三个基矢 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 定义。根据给定的晶格参数——长度 $a$、$b$、$c$ 和角度 $\\alpha$、$\\beta$、$\\gamma$——我们构建晶格矩阵 $\\mathbf{L} = \\begin{bmatrix} \\mathbf{a}  \\mathbf{b}  \\mathbf{c} \\end{bmatrix}$。该矩阵通过线性变换 $\\mathbf{r} = \\mathbf{L}\\mathbf{f}$ 将分数坐标 $\\mathbf{f} \\in [0,1)^3$ 变换为笛卡尔坐标 $\\mathbf{r} \\in \\mathbb{R}^3$。此构建过程使用标准的三斜晶系约定，并将角度从度转换为弧度以进行三角计算。\n\n分析的核心是确定一个由整数正交矩阵 $\\mathbf{R}$ 表示的给定对称操作是否在位置容差 $\\varepsilon$ 内被晶体结构所遵守。如果可以在原始原子分数坐标集 $\\{\\mathbf{f}_j\\}$ 和变换后的坐标集 $\\{\\mathbf{f}'_i = \\mathbf{R}\\mathbf{f}_i \\pmod 1\\}$ 之间建立一一对应关系（一个排列），则认为该操作被满足。模1操作确保变换后的坐标被映射回主晶胞内。为了使对应关系有效，每对匹配原子 $(\\mathbf{f}'_i, \\mathbf{f}_j)$ 之间的笛卡尔距离必须不大于 $\\varepsilon$。此距离使用最小镜像约定计算，以考虑晶体的周期性。该距离定义为 $d_{ij} = \\min_{\\mathbf{n}\\in\\{-1,0,1\\}^3} \\| \\mathbf{L}(\\mathbf{f}'_i - \\mathbf{f}_j + \\mathbf{n}) \\|_2$。通过检查所有27个分量在 $\\{-1, 0, 1\\}$ 内的整数平移向量 $\\mathbf{n}$ 来精确地执行最小值搜索。\n\n为了找到原始原子位置和变换后原子位置之间的一一映射，我们将其构建为一个线性分配问题（或最小权重二分图匹配问题）。构建一个大小为 $N \\times N$ 的代价矩阵 $\\mathbf{D}$，其中 $D_{ij}$ 是第 $i$ 个变换后原子 $\\mathbf{f}'_i$ 和第 $j$ 个原始原子 $\\mathbf{f}_j$ 之间的最小镜像距离。采用匈牙利算法（可通过`scipy.optimize.linear_sum_assignment`获得）来找到使总距离最小化的原子排列。一旦找到这个最优配对，当且仅当此最优指派中的每个距离都小于或等于容差 $\\varepsilon$ 时，操作 $\\mathbf{R}$ 才被视为满足。\n\n通过这个流程，对于所提供列表中的每个容差 $\\varepsilon_k$，我们可以确定目录中所有被满足的操作的完整集合。下一步是指派一个空间群代理。问题提供了一个包含八个群代理的目录，每个代理由一个编码、一个名称和一组必需的最小对称操作定义。在给定的容差下，我们从目录中找出所有其必需操作都存在于我们已满足操作集合中的群代理。在这些有效候选者中，我们选择具有最大必需操作数量（记为 $c(G)$）的那个。任何平局都通过选择具有较大整数编码的群来解决。\n\n对扫描中的每个容差 $\\varepsilon_k$ 重复此过程，生成一个群指派序列 $\\{G_k\\}$。然后分析此序列以提取两个关键指标：一个赝对称性指示符和一个稳定性得分。\n\n如果在容差扫描的某个点，指派群的复杂度（以 $c(G)$ 衡量）严格增加，则检测到赝对称性跳变。我们识别出第一个索引 $k^\\star \\in \\{2, \\dots, K\\}$，使得 $c(G_{k^\\star}) > c(G_{k^\\star-1})$。如果存在这样的跳变，我们报告标志 $p=1$、发生跳变时的容差 $\\varepsilon^\\star = \\varepsilon_{k^\\star}$，以及参与转变的群编码对 $(G, H) = (G_{k^\\star-1}, G_{k^\\star})$。如果没有找到这样的跳变，我们报告 $p=0$ 和占位符值。\n\n稳定性得分 $s$ 量化了对称性指派的稳健性。它被计算为“众数群”被指派的容差所占的比例。众数群是在序列 $\\{G_k\\}$ 中出现最频繁的群。如果频率出现平局，则通过选择具有更高复杂度 $c(G)$ 的群来打破平局。如果仍然平局，则通过选择具有更高编码的群来打破。\n\n最终的实现封装了这整个逻辑，处理三个给定的晶体结构（$S_1, S_2, S_3$）中的每一个，通过容差扫描并计算五个必需的输出值：赝对称性标志 $p$、跳变容差 $\\varepsilon^\\star$、跳变对 $(G,H)$ 和稳定性得分 $s$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Main function to perform symmetry analysis on a suite of test structures.\n    \"\"\"\n\n    def get_lattice_matrix(a, b, c, alpha, beta, gamma):\n        \"\"\"\n        Constructs the lattice matrix L from lattice parameters a, b, c, alpha, beta, gamma.\n        The columns of L are the lattice vectors a, b, c in Cartesian space.\n        \"\"\"\n        alpha_rad = np.deg2rad(alpha)\n        beta_rad = np.deg2rad(beta)\n        gamma_rad = np.deg2rad(gamma)\n\n        cos_a, cos_b, cos_g = np.cos(alpha_rad), np.cos(beta_rad), np.cos(gamma_rad)\n        sin_g = np.sin(gamma_rad)\n\n        # Volume term, handle case of sin_g=0 if gamma is 0 or 180\n        vol_sq_term = 1.0 - cos_a**2 - cos_b**2 - cos_g**2 + 2.0 * cos_a * cos_b * cos_g\n        if vol_sq_term  0: vol_sq_term = 0 # handle minor floating point issues\n        \n        # Standard triclinic cell construction\n        # a is along x\n        # b is in xy plane\n        # c is general\n        ax, ay, az = a, 0.0, 0.0\n        bx, by, bz = b * cos_g, b * sin_g, 0.0\n        cx = c * cos_b\n        cy = c * (cos_a - cos_b * cos_g) / sin_g if sin_g != 0 else 0.0\n        cz = c * np.sqrt(vol_sq_term) / sin_g if sin_g != 0 else 0.0\n\n        return np.array([[ax, bx, cx], [ay, by, cy], [az, bz, cz]])\n\n    def is_op_satisfied(L, f_coords, R, epsilon):\n        \"\"\"\n        Checks if a symmetry operation R is satisfied for a given structure and tolerance.\n        \"\"\"\n        num_atoms = f_coords.shape[0]\n        # Transform coordinates: f' = R * f (mod 1)\n        f_prime = (R @ f_coords.T).T\n        f_prime = f_prime - np.floor(f_prime)\n\n        # Build distance matrix D_ij = d(f'_i, f_j) using minimum image convention\n        dist_matrix = np.zeros((num_atoms, num_atoms))\n        \n        # Pre-generate the 27 shift vectors n\n        shifts = np.array([\n            (i, j, k) for i in [-1, 0, 1] for j in [-1, 0, 1] for k in [-1, 0, 1]\n        ])\n\n        for i in range(num_atoms):\n            for j in range(num_atoms):\n                delta_f = f_prime[i] - f_coords[j]\n                \n                # Minimum image distance calculation\n                # Add all 27 shifts to delta_f and find coord with minimum norm\n                all_shifted_f = delta_f + shifts\n                cart_coords = all_shifted_f @ L.T\n                dists_sq = np.sum(cart_coords**2, axis=1)\n                min_dist_sq = np.min(dists_sq)\n                dist_matrix[i, j] = np.sqrt(min_dist_sq)\n\n        # Use Hungarian algorithm to find the optimal one-to-one mapping\n        row_ind, col_ind = linear_sum_assignment(dist_matrix)\n        \n        # Check if all pairs in the optimal assignment are within tolerance\n        max_dist_in_mapping = np.max(dist_matrix[row_ind, col_ind])\n        \n        return max_dist_in_mapping = epsilon\n\n    # Static data as defined in the problem\n    test_suite = [\n        {\n            \"name\": \"S1\",\n            \"lattice_params\": {\"a\": 3.5, \"b\": 3.5, \"c\": 10.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0},\n            \"frac_coords\": np.array([\n                [0.5 + 0.2, 0.5, 0.0], [0.5 - 0.2, 0.5, 0.0],\n                [0.5, 0.5 + 0.196, 0.0], [0.5, 0.5 - 0.196, 0.0]\n            ])\n        },\n        {\n            \"name\": \"S2\",\n            \"lattice_params\": {\"a\": 3.2, \"b\": 4.7, \"c\": 12.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 80.0},\n            \"frac_coords\": np.array([[0.1, 0.2, 0.0], [0.33, 0.73, 0.0], [0.81, 0.27, 0.0]])\n        },\n        {\n            \"name\": \"S3\",\n            \"lattice_params\": {\"a\": 3.5, \"b\": 3.5, \"c\": 10.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0},\n            \"frac_coords\": np.array([\n                [0.5 + 0.2, 0.5, 0.0], [0.5 - 0.2, 0.5, 0.0],\n                [0.5, 0.5 + 0.2, 0.0], [0.5, 0.5 - 0.2, 0.0]\n            ])\n        }\n    ]\n    tolerances = [0.0005, 0.005, 0.02, 0.05]\n    ops_catalog = {\n        'E': np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]], dtype=int),\n        'I': np.array([[-1, 0, 0], [0, -1, 0], [0, 0, -1]], dtype=int),\n        'C2z': np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]], dtype=int),\n        'C4z': np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]], dtype=int),\n        'mx': np.array([[-1, 0, 0], [0, 1, 0], [0, 0, 1]], dtype=int),\n        'my': np.array([[1, 0, 0], [0, -1, 0], [0, 0, 1]], dtype=int),\n        'mz': np.array([[1, 0, 0], [0, 1, 0], [0, 0, -1]], dtype=int)\n    }\n    space_groups_catalog = {\n        1: {'reqs': {'E'}}, 2: {'reqs': {'E', 'I'}},\n        3: {'reqs': {'E', 'C2z'}}, 4: {'reqs': {'E', 'mx'}},\n        5: {'reqs': {'E', 'C4z', 'C2z'}}, 6: {'reqs': {'E', 'C4z', 'C2z', 'mz'}},\n        7: {'reqs': {'E', 'mx', 'my'}}, 8: {'reqs': {'E', 'C4z', 'C2z', 'mx', 'my'}}\n    }\n    for code in space_groups_catalog:\n        space_groups_catalog[code]['c'] = len(space_groups_catalog[code]['reqs'])\n\n    final_results = []\n    \n    for structure in test_suite:\n        lattice_matrix = get_lattice_matrix(**structure[\"lattice_params\"])\n        frac_coords = structure[\"frac_coords\"]\n        \n        G_sequence = []\n        for eps in tolerances:\n            satisfied_ops = {op_name for op_name, R in ops_catalog.items()\n                             if is_op_satisfied(lattice_matrix, frac_coords, R, eps)}\n\n            best_group_code = -1\n            max_ops = -1\n            for code, group_data in sorted(space_groups_catalog.items()):\n                if group_data['reqs'].issubset(satisfied_ops):\n                    if group_data['c'] > max_ops:\n                        max_ops = group_data['c']\n                        best_group_code = code\n                    elif group_data['c'] == max_ops:\n                        best_group_code = max(best_group_code, code)\n            G_sequence.append(best_group_code)\n\n        # Analyze G_sequence\n        p, eps_star, G, H = 0, -1.0, -1, -1\n        for k in range(1, len(G_sequence)):\n            c_prev = space_groups_catalog[G_sequence[k-1]]['c']\n            c_curr = space_groups_catalog[G_sequence[k]]['c']\n            if c_curr > c_prev:\n                p = 1\n                eps_star = tolerances[k]\n                G, H = G_sequence[k-1], G_sequence[k]\n                break\n        \n        # Stability score calculation\n        if not G_sequence:\n            s = 0.0\n        else:\n            counts = Counter(G_sequence)\n            max_freq = max(counts.values())\n            candidates = [code for code, freq in counts.items() if freq == max_freq]\n            \n            if len(candidates) == 1:\n                majority_group_code = candidates[0]\n            else:\n                # Tie-breaking: higher complexity c(G), then higher code\n                candidates.sort(key=lambda code: (space_groups_catalog[code]['c'], code), reverse=True)\n                majority_group_code = candidates[0]\n\n            s = counts[majority_group_code] / len(G_sequence)\n\n        # Format results as specified\n        result = [p, round(eps_star, 4), G, H, round(s, 3)]\n        final_results.append(result)\n\n    # Print final result in specified format\n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n\n```", "id": "3491404"}, {"introduction": "在材料模拟中，对称性分析的主要好处是它能带来巨大的计算节省。通过利用对称性，可以将在整个布里渊区的计算简化到在一个小的、独特的楔形区域内进行，这个区域被称为不可约布里渊区（IBZ）。这项高级练习 [@problem_id:3491394] 涉及为六方晶格开发一个k点简约程序，教你如何在倒易空间中应用群操作来确定IBZ并理解其高对称性点。", "problem": "您的任务是实现一个程序，在非点式六方空间群（具体为Hermann–Mauguin符号为 $P6_3/mmc$ 的群）的对称性下，将倒易空间中的一组波矢简约为其不可约代表。目标是为指定的测试用例计算不可约布里渊区（IBZ）的代表元和相应小协群的阶。您的实现必须正确处理非点式群中由螺旋及滑移操作引起的等价性，即需要认识到空间群操作可能将一个波矢 $\\mathbf{k}$ 映射到 $\\mathbf{k} + \\mathbf{G}$，其中 $\\mathbf{G}$ 是一个倒易格矢。角度必须以弧度为单位处理，在应用旋转时向量必须在笛卡尔坐标系中处理，而模倒易格矢的等价性必须在相对于倒易基矢的分数（简约）坐标中强制执行。\n\n请使用以下有科学依据的基础：\n- Bloch定理指出，晶体哈密顿量的本征态可以由倒易空间中的波矢 $\\mathbf{k}$ 来标记，并且在加上任意倒易格矢后保持等价：$\\mathbf{k} \\sim \\mathbf{k} + \\mathbf{G}$。\n- 空间群操作由一个Seitz算符 $(R \\mid \\mathbf{t})$ 表示，其中 $R$ 是一个旋转或旋转反演矩阵，$\\mathbf{t}$ 是一个（可能是分数的）平移矢量。为了将 $\\mathbf{k}$ 点分为等价类，只有旋转部分 $R$ 决定了 $\\mathbf{k}$ 作为倒易空间中一个点的映射，但非点式操作中分数平移 $\\mathbf{t}$ 的存在，要求对 $R\\,\\mathbf{k}$ 进行模倒易格矢的相容性简约，因为对布洛赫波的作用会产生相位因子 $\\exp(-i\\,\\mathbf{k}\\cdot\\mathbf{t})$，这并不改变 $\\mathbf{k}$ 作为矢量的等价类。\n- 不可约布里渊区定义为在点群作用下，从 $\\mathbf{k}$ 的等价类中选出的一组代表元，其等价关系为 $\\mathbf{k} \\equiv R\\,\\mathbf{k} + \\mathbf{G}$，其中 $\\mathbf{G}$ 是某个倒易格矢。\n- 倒易格基矢 $\\{ \\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3 \\}$ 由正格基矢 $\\{ \\mathbf{a}_1, \\mathbf{a}_2, \\mathbf{a}_3 \\}$ 通过关系式 $$B = 2\\pi\\,A^{-T},$$ 构建，其中 $A$ 是以 $\\mathbf{a}_1$、$\\mathbf{a}_2$ 和 $\\mathbf{a}_3$ 为列向量的 $3\\times 3$ 矩阵，而 $B$ 是以 $\\mathbf{b}_1$、$\\mathbf{b}_2$ 和 $\\mathbf{b}_3$ 为列向量的 $3\\times 3$ 矩阵。\n\n实现要求：\n- 使用六方晶格，其正格基矢定义为 $\\mathbf{a}_1 = (a, 0, 0)$、$\\mathbf{a}_2 = \\left(\\frac{a}{2}, \\frac{\\sqrt{3}\\,a}{2}, 0\\right)$ 和 $\\mathbf{a}_3 = (0, 0, c)$，晶格参数 $a$ 和 $c$ 在测试套件中给出。\n- 通过组合二面体群 $D_6$ 的 $12$ 个真旋转（包括绕 $z$ 轴旋转角度为 $0$、$\\pm \\frac{\\pi}{3}$、$\\pm \\frac{2\\pi}{3}$ 和 $\\pi$，以及绕位于基面内、角度为 $\\phi = 0$、$\\frac{\\pi}{6}$、$\\frac{\\pi}{3}$、$\\frac{\\pi}{2}$、$\\frac{2\\pi}{3}$ 和 $\\frac{5\\pi}{6}$ 的六个轴旋转 $\\pi$）与反演（乘以 $-I$）来构建与六方点群 $D_{6h}$ 对应的全套 $24$ 个笛卡尔旋转矩阵，从而得到 $D_{6h} = D_6 \\times C_i$ 的 $24$ 个元素。\n- 将每个旋转 $R$ 应用于笛卡尔坐标系中的波矢 $\\mathbf{k}$，转换回相对于倒易基矢的分数（简约）坐标，并使用 $$h_i \\mapsto \\left((h_i + \\tfrac{1}{2}) \\bmod 1\\right) - \\tfrac{1}{2},$$ 将分数坐标分量映射到区间 $[-\\frac{1}{2}, \\frac{1}{2})$ 以简约到主区域，其中 $h_i$ 表示 $\\mathbf{k}$ 相对于倒易基矢的分数坐标分量。\n- 将两个分数坐标矢量 $\\mathbf{h}$ 和 $\\mathbf{h}'$ 之间的等价关系实现为模整数平移相等：如果存在 $\\mathbf{n} \\in \\mathbb{Z}^3$ 使得 $\\mathbf{h} - \\mathbf{h}' - \\mathbf{n}$ 在规定的容差内数值上为零，则它们是等价的。这强制了 $\\mathbf{k} \\equiv \\mathbf{k} + \\mathbf{G}$ 的一致性。\n- 对于每个输入波矢 $\\mathbf{k}$，计算其在所有群操作下的轨道（“星”），并选择其等价类的典范代表元，例如，将分数矢量四舍五入到固定小数位数后字典序最小的矢量，以定义不可约代表。\n- 对于一个波矢 $\\mathbf{k}$，计算其小协群（稳定子群）的阶，即满足 $R\\,\\mathbf{k} \\equiv \\mathbf{k}$ 模倒易格矢的群操作 $R$ 的数量。注意：非点式操作的平移部分不会移动 $\\mathbf{k}$ 作为倒易空间中的点；然而，它们在 $P6_3/mmc$ 中的存在意味着将 $R\\,\\mathbf{k}$ 简约到所选主区域时必须始终模倒易格矢进行，尤其是在像 $k_z = \\pm \\tfrac{1}{2}$ 这样的边界上，其中诸如水平镜面之类的操作实际上将 $k_z \\to -k_z$，并且需要加上一个倒易格矢才能返回主区域。\n\n角度单位必须是弧度。$\\mathbf{k}$ 的分数坐标必须相对于倒易基矢定义并且是无量纲的。\n\n测试套件和输出：\n- 使用晶格参数 $a = 2.5$ 和 $c = 4.1$。\n- 测试用例 1（一般“理想路径”简约）：将在 $D_{6h}$ 对称性下，将以下分数波矢列表简约为其IBZ代表元，并以整数形式返回唯一的不可约代表元的数量：\n  $$\\left[\\,(0,0,0),\\ (0,0,0.5),\\ \\left(\\tfrac{1}{3},\\tfrac{1}{3},0\\right),\\ \\left(\\tfrac{1}{3},\\tfrac{1}{3},0.5\\right),\\ (0.5,0,0),\\ (0.25,0.25,0.1),\\ (-0.44,0.22,-0.49),\\ (0.17,-0.21,0.3),\\ (0.12,0.07,0.5),\\ (0.11,-0.11,-0.5),\\ \\left(-\\tfrac{1}{3},-\\tfrac{1}{3},0\\right),\\ (0.5,-0.5,0)\\,\\right].$$\n- 测试用例 2（高对称性边界条件）：计算波矢 $\\mathbf{k} = (0,0,0)$（$\\Gamma$ 点）的小协群的大小，并以整数形式返回。\n- 测试用例 3（涉及非点式处理的重要边缘情况）：计算波矢 $\\mathbf{k} = \\left(\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{2}\\right)$（位于 $k_z = \\tfrac{1}{2}$ 边界平面上的 $H$ 点）的小协群的大小，并以整数形式返回。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容按上述测试用例的顺序排列。例如，它应该精确打印一行，格式如下 $$[\\text{result}_1,\\text{result}_2,\\text{result}_3],$$ 其中 $\\text{result}_1$、$\\text{result}_2$ 和 $\\text{result}_3$ 是对应于上述三个测试用例的整数。", "solution": "用户问题是实现一个程序，在非点式空间群 $P6_3/mmc$ 的对称性下，将六方晶格中的波矢（$\\mathbf{k}$点）简约为其不可约代表元。这涉及两个主要任务：为给定的$\\mathbf{k}$点列表找到唯一的不可约布里渊区（IBZ）代表元的数量，以及为特定的高对称性$\\mathbf{k}$点计算小协群的阶。\n\n### 步骤 0：问题验证\n\n问题陈述已根据所需标准进行了验证。\n\n1.  **提取已知条件**：\n    -   空间群：$P6_3/mmc$（非点式六方）。\n    -   点群：$D_{6h}$（24个旋转操作）。\n    -   正格基矢：$\\mathbf{a}_1 = (a, 0, 0)$，$\\mathbf{a}_2 = (a/2, \\sqrt{3}a/2, 0)$，$\\mathbf{a}_3 = (0, 0, c)$。\n    -   倒易格基矢：通过 $B = 2\\pi (A^{-T})$ 推导，其中 $A$ 和 $B$ 是列向量分别为正格基矢和倒易格基矢的矩阵。\n    -   $\\mathbf{k}$点等价性：$\\mathbf{k} \\equiv R\\mathbf{k} + \\mathbf{G}$，其中 $R$ 是点群旋转，$\\mathbf{G}$ 是倒易格矢。\n    -   分数坐标 $\\mathbf{h}$ 的主区域：$h_i \\in [-\\frac{1}{2}, \\frac{1}{2})$。简约规则为 $h_i \\mapsto ((h_i + 0.5) \\pmod 1) - 0.5$。\n    -   IBZ代表元：$\\mathbf{k}$ 的轨道（星）中字典序最小的矢量。\n    -   小协群：满足 $R\\mathbf{k} \\equiv \\mathbf{k} \\pmod{\\mathbf{G}}$ 的旋转 $R$ 的集合。\n    -   晶格参数：$a = 2.5$，$c = 4.1$。\n    -   测试用例：（1）从一个包含12个分数k矢量的列表中计算唯一的IBZ代表元的数量。（2）计算 $\\mathbf{k}=(0,0,0)$ 的小协群的阶。（3）计算 $\\mathbf{k}=(1/3, 1/3, 1/2)$ 的小协群的阶。\n\n2.  **使用提取的已知条件进行验证**：\n    -   **科学依据**：该问题基于固态物理学和晶体学的基本、公认的原理，包括布洛赫定理、空间群理论和倒易空间分析。$P6_3/mmc$ 空间群的性质和所需的计算是计算材料科学中的标准内容。\n    -   **适定性**：问题定义清晰，包含所有必要的输入、定义和约束。每个测试用例的目标都是具体的，并允许一个唯一的、可计算的解决方案。\n    -   **客观性**：问题以精确、正式的语言陈述，没有主观性或歧义。\n    -   **结论**：该问题在科学上是合理的、适定的、客观的和完整的。不存在使其无效的缺陷。\n\n### 步骤 1：理论框架和算法设计\n\n解决方案将通过首先建立坐标系和变换的数学框架，然后生成所需的对称操作，最后实现简约和分析的算法来开发。\n\n#### 1. 晶格和坐标变换\n正格矢在笛卡尔坐标系中给出。它们构成了矩阵 $A$ 的列：\n$$\nA = \\begin{pmatrix} a  a/2  0 \\\\ 0  \\sqrt{3}a/2  0 \\\\ 0  0  c \\end{pmatrix}\n$$\n构成矩阵 $B$ 的列的倒易格基矢，是使用标准关系 $B = 2\\pi(A^{-1})^T = 2\\pi(A^T)^{-1}$ 从 $A$ 推导出来的。\n$$\nA^T = \\begin{pmatrix} a  0  0 \\\\ a/2  \\sqrt{3}a/2  0 \\\\ 0  0  c \\end{pmatrix} \\quad\\implies\\quad (A^T)^{-1} = \\begin{pmatrix} 1/a  0  0 \\\\ -1/(\\sqrt{3}a)  2/(\\sqrt{3}a)  0 \\\\ 0  0  1/c \\end{pmatrix}\n$$\n因此，倒易格矩阵为：\n$$\nB = 2\\pi \\begin{pmatrix} 1/a  0  0 \\\\ -1/(\\sqrt{3}a)  2/(\\sqrt{3}a)  0 \\\\ 0  0  1/c \\end{pmatrix}\n$$\n波矢 $\\mathbf{k}$ 可以用笛卡尔坐标表示，也可以用相对于倒易基矢的分数（简约）坐标 $\\mathbf{h}=(h_1, h_2, h_3)$ 表示：\n-   分数坐标到笛卡尔坐标：$\\mathbf{k}_{\\text{cart}} = B \\mathbf{h}$\n-   笛卡尔坐标到分数坐标：$\\mathbf{h} = B^{-1} \\mathbf{k}_{\\text{cart}}$。逆矩阵 $B^{-1}$ 可以方便地通过 $B^{-1} = \\frac{1}{2\\pi}A^T$ 找到。\n\n#### 2. 点群对称操作\n$P6_3/mmc$ 的点群是 $D_{6h}$，它有 $24$ 个对称操作。这些操作可以由二面体群 $D_6$ 和反演生成。$D_6$ 群本身可以由绕 $z$ 轴的六重旋转 $C_6$ 和绕 $x$ 轴的二重旋转 $C_2$ 生成。\n$24$ 个笛卡尔旋转矩阵 $\\{R_i\\}$ 将按如下方式生成：\n1.  生成循环群 $C_6$ 的 6 个矩阵，对应于绕 $z$ 轴旋转角度 $\\theta = k\\pi/3$，其中 $k \\in \\{0, 1, ..., 5\\}$。\n2.  通过将 $C_6$ 操作与绕 $x$ 轴的 $C_2$ 旋转复合，生成另外 6 个矩阵，从而构成 $D_6$ 的 12 个操作。\n3.  通过将前 12 个矩阵与反演矩阵 $-I$ 相乘，生成最后的 12 个矩阵。\n\n#### 3. $\\mathbf{k}$点简约与等价性\n问题的核心是应用对称操作并处理等价关系 $\\mathbf{k} \\equiv R\\mathbf{k} + \\mathbf{G}$。这通过以下步骤实现：\n1.  将给定的分数坐标 $\\mathbf{h}$ 的 $\\mathbf{k}$ 点转换为笛卡尔坐标：$\\mathbf{k}_{\\text{cart}} = B \\mathbf{h}$。\n2.  应用对称操作：$\\mathbf{k}'_{\\text{cart}} = R \\mathbf{k}_{\\text{cart}}$。\n3.  将结果转换回分数坐标：$\\mathbf{h}' = B^{-1} \\mathbf{k}'_{\\text{cart}}$。\n4.  使用规则 $x \\mapsto ((x + 0.5) \\pmod 1) - 0.5$ 按分量将分数矢量 $\\mathbf{h}'$ 简约到主区域 $[-\\frac{1}{2}, \\frac{1}{2})$。此步骤隐式地处理了加上倒易格矢 $\\mathbf{G}$ 的情况，因为分数坐标中的整数平移等同于加上一个 $\\mathbf{G}$ 矢量。\n\n#### 4. IBZ代表元和小协群\n-   **IBZ代表元**：对于给定的 $\\mathbf{k}$ 点，其轨道（或“星”）是通过应用所有 $24$ 个对称操作并简约到主区域所获得的所有唯一 $\\mathbf{k}$ 点的集合。典范IBZ代表元定义为此轨道内字典序最小的矢量。\n-   **小协群的阶**：对于给定的 $\\mathbf{k}$ 点，其小协群是点群操作中将 $\\mathbf{k}$ 映射到等价点（$\\mathbf{k} \\equiv R\\mathbf{k} \\pmod{\\mathbf{G}}$）的子群。其阶就是此类操作的数量。为计算此值，我们首先将输入的 $\\mathbf{k}$ 简约到其在主区域中的表示 $\\mathbf{h}_{\\text{red}}$。然后，我们应用 $24$ 个操作 $R_i$ 中的每一个，并检查得到的简约矢量是否在数值上与 $\\mathbf{h}_{\\text{red}}$ 相同。\n\n### 步骤 2：实现细节\n\n程序将按以下结构组织：\n-   一个 `solve` 函数封装了整个逻辑。\n-   定义了常数 `a` 和 `c`，以及数值容差 `TOL`。\n-   构建晶格矩阵 $A$、$B$ 和 $B^{-1}$。\n-   预先计算 $D_{6h}$ 的 24 个旋转矩阵。\n-   实现以下辅助函数：\n    -   `reduce_k_vector`：将分数矢量简约到主区域。\n    -   `get_ibz_representative`：为给定的k点找到典范代表元。\n    -   `get_little_co_group_order`：计算稳定子群的大小。\n-   使用这些辅助函数按顺序处理三个测试用例。\n-   最终结果被格式化并打印为单行。\n这种结构化方法通过分离不同的逻辑组件（晶格几何、群论和简约算法）来确保正确性。通过使用容差进行浮点数比较来保持数值稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of reducing wavevectors to their irreducible representatives\n    for the P6_3/mmc space group and computing little co-group orders.\n    \"\"\"\n    \n    # Define constants and tolerance\n    a = 2.5\n    c = 4.1\n    TOL = 1e-6\n\n    # --- Step 1: Setup Lattice and Coordinate Transformations ---\n    sqrt3 = np.sqrt(3)\n\n    # Direct lattice matrix A (columns are a1, a2, a3 in Cartesian)\n    A = np.array([\n        [a, a / 2.0, 0],\n        [0, sqrt3 * a / 2.0, 0],\n        [0, 0, c]\n    ])\n\n    # Reciprocal lattice matrix B = 2*pi*(A^T)^-1\n    # B_inv = (1/(2*pi)) * A^T\n    A_T = A.T\n    B_inv = (1.0 / (2.0 * np.pi)) * A_T\n    B = np.linalg.inv(B_inv)\n\n    # --- Step 2: Generate Point Group Symmetry Operations ---\n    def generate_d6h_rotations():\n        \"\"\"Generates the 24 Cartesian rotation matrices for the D6h point group.\"\"\"\n        rots = []\n        # Generate D6 ops first\n        d6_ops = []\n        # C6-subgroup part (rotations about z)\n        c6_z_ops = []\n        for i in range(6):\n            angle = i * np.pi / 3.0\n            cos_a, sin_a = np.cos(angle), np.sin(angle)\n            c6_z_ops.append(np.array([\n                [cos_a, -sin_a, 0],\n                [sin_a, cos_a, 0],\n                [0, 0, 1]\n            ]))\n        \n        d6_ops.extend(c6_z_ops)\n        \n        # C2 part (rotations about axes in xy-plane)\n        # These are generated by combining C6_z ops with a C2_x op\n        c2x_op = np.array([[1, 0, 0], [0, -1, 0], [0, 0, -1]])\n        for op in c6_z_ops:\n            d6_ops.append(op @ c2x_op)\n\n        # Generate D6h by adding inversion\n        for op in d6_ops:\n            rots.append(op)\n            rots.append(-op)\n\n        # Remove potential duplicates due to floating point arithmetic\n        unique_rots = []\n        for r in rots:\n            is_unique = True\n            for ur in unique_rots:\n                if np.allclose(r, ur, atol=TOL):\n                    is_unique = False\n                    break\n            if is_unique:\n                unique_rots.append(r)\n        return unique_rots\n\n    rotations = generate_d6h_rotations()\n\n    # --- Step 3: k-point Reduction and Analysis Functions ---\n    def reduce_k_vector(h_frac):\n        \"\"\"Reduces a fractional k-vector to the principal domain [-0.5, 0.5).\"\"\"\n        return np.mod(h_frac + 0.5, 1.0) - 0.5\n\n    def get_star(h_frac, reduced=True):\n        \"\"\"Computes the star (orbit) of a k-vector.\"\"\"\n        if reduced:\n            h_frac = reduce_k_vector(h_frac)\n        \n        k_cart = B @ h_frac\n        \n        star_h_frac = []\n        for R in rotations:\n            k_rot_cart = R @ k_cart\n            h_rot_frac = B_inv @ k_rot_cart\n            star_h_frac.append(reduce_k_vector(h_rot_frac))\n        \n        # Make the list unique\n        unique_star = []\n        for h in star_h_frac:\n            is_unique = True\n            for uh in unique_star:\n                if np.allclose(h, uh, atol=TOL):\n                    is_unique = False\n                    break\n            if is_unique:\n                unique_star.append(h)\n\n        return unique_star\n\n    def get_ibz_representative(h_frac):\n        \"\"\"Finds the canonical IBZ representative (lexicographically smallest).\"\"\"\n        star = get_star(h_frac)\n        # Round for stable lexicographical sort\n        star_rounded = [np.round(h, 8) for h in star]\n        # Sort based on tuple representation\n        lex_min_rep = min(star_rounded, key=lambda v: tuple(v))\n        return lex_min_rep\n\n    def get_little_co_group_order(h_frac):\n        \"\"\"Computes the order of the little co-group (stabilizer).\"\"\"\n        h_start = reduce_k_vector(h_frac)\n        k_start_cart = B @ h_start\n        count = 0\n        for R in rotations:\n            k_rot_cart = R @ k_start_cart\n            h_rot_frac = B_inv @ k_rot_cart\n            h_rot_reduced = reduce_k_vector(h_rot_frac)\n            if np.allclose(h_rot_reduced, h_start, atol=TOL):\n                count += 1\n        return count\n\n    # --- Step 4: Execute Test Cases ---\n    results = []\n\n    # Test Case 1: Number of unique IBZ representatives\n    test_k_vectors_frac = [\n        (0, 0, 0), (0, 0, 0.5), (1/3, 1/3, 0), (1/3, 1/3, 0.5), (0.5, 0, 0),\n        (0.25, 0.25, 0.1), (-0.44, 0.22, -0.49), (0.17, -0.21, 0.3),\n        (0.12, 0.07, 0.5), (0.11, -0.11, -0.5), (-1/3, -1/3, 0), (0.5, -0.5, 0)\n    ]\n    ibz_reps = set()\n    for h_tuple in test_k_vectors_frac:\n        h_frac = np.array(h_tuple)\n        rep = get_ibz_representative(h_frac)\n        # Convert to tuple for hashability in the set\n        ibz_reps.add(tuple(np.round(rep, 8)))\n\n    results.append(len(ibz_reps))\n\n    # Test Case 2: Little co-group order of Gamma point (0,0,0)\n    k_gamma = np.array([0.0, 0.0, 0.0])\n    results.append(get_little_co_group_order(k_gamma))\n\n    # Test Case 3: Little co-group order of H point (1/3, 1/3, 1/2)\n    k_h = np.array([1/3, 1/3, 1/2])\n    results.append(get_little_co_group_order(k_h))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3491394"}]}