{"hands_on_practices": [{"introduction": "许多重要的材料特性，如铁电性和某些形式的磁性，都由结构畸变所控制。姜-泰勒（Jahn-Teller）效应是其中一个经典的例子。本练习将提供一个实践机会，让您从一个简化的物理模型出发，构建此类畸变的势能面（PES），并识别其关键的拓扑特征，例如能量极小点的数量和位置 ([@problem_id:3479238])。通过这项实践，您将学会如何将底层的量子力学相互作用转化为宏观的能量形貌，并对其进行分析。", "problem": "考虑一个钙钛矿晶格，其中单个过渡金属位点上存在电子简并的 $e_g$ 多重态。在 Born–Oppenheimer 近似下，势能面 (PES) 是晶格弹性能与电子基态能量之和，它是对称匹配的 Jahn–Teller 简正坐标 $Q_2$ 和 $Q_3$（单位均为 $\\mathrm{\\AA}$）的函数。假设存在线性电子–晶格耦合、由四次项稳定的谐波弹性，以及一个可选的三角晶体场项。$e_g$ 子空间中的两能级电子哈密顿量建模为 $H_{\\mathrm{el}}(Q_2,Q_3) = - g \\left( Q_2 \\tau_x + Q_3 \\tau_z \\right) - \\Delta \\tau_z$，其中 $g$ 是电子–晶格耦合强度，单位为 $\\mathrm{eV}/\\mathrm{\\AA}$；$\\Delta$ 是三角晶体场能量，单位为 $\\mathrm{eV}$；$\\tau_x$ 和 $\\tau_z$ 是作用于轨道赝自旋基上的 Pauli 矩阵。设晶格能量为 $E_{\\mathrm{lat}}(Q_2,Q_3) = \\tfrac{1}{2} k_2 Q_2^2 + \\tfrac{1}{2} k_3 Q_3^2 + \\tfrac{1}{4} \\beta \\left( Q_2^4 + Q_3^4 \\right) + \\tfrac{1}{2} \\kappa Q_2^2 Q_3^2$，其中 $k_2$ 和 $k_3$ 的单位为 $\\mathrm{eV}/\\mathrm{\\AA}^2$，$\\beta$ 和 $\\kappa$ 的单位为 $\\mathrm{eV}/\\mathrm{\\AA}^4$。假设每个位点的 $e_g$ 子空间中的电子占据数为 $n_{\\mathrm{occ}} \\in \\{0,1,2\\}$，并忽略填充可用能级之外的电子–电子相互作用。\n\n从这些定义和物理定律出发，势能面为 $E(Q_2,Q_3) = E_{\\mathrm{lat}}(Q_2,Q_3) + E_{\\mathrm{el,gs}}(Q_2,Q_3;n_{\\mathrm{occ}})$，其中 $E_{\\mathrm{el,gs}}$ 是电子基态能量，必须通过对角化 $H_{\\mathrm{el}}(Q_2,Q_3)$ 并填充最低的 $n_{\\mathrm{occ}}$ 个本征值来获得。您的任务是实现一个程序，对于下面测试套件中的每一组参数，该程序能在方形网格 $Q_2,Q_3 \\in [-Q_{\\max}, Q_{\\max}]$ 上构建 $E(Q_2,Q_3)$，检测出不同的局域最小值，判断是否存在双阱拓扑结构，并计算连接两个最低能量最小值之间的直线路径上的能垒高度。\n\n定义和计算要求：\n- $H_{\\mathrm{el}}(Q_2,Q_3)$ 的本征值对为 $\\pm \\sqrt{(g Q_2)^2 + (g Q_3 + \\Delta)^2}$，单位为 $\\mathrm{eV}$。通过对这些本征值中最低的 $n_{\\mathrm{occ}}$ 个求和来定义 $E_{\\mathrm{el,gs}}(Q_2,Q_3;n_{\\mathrm{occ}})$：当 $n_{\\mathrm{occ}} = 0$ 时，$E_{\\mathrm{el,gs}} = 0$；当 $n_{\\mathrm{occ}} = 1$ 时，$E_{\\mathrm{el,gs}} = - \\sqrt{(g Q_2)^2 + (g Q_3 + \\Delta)^2}$；当 $n_{\\mathrm{occ}} = 2$ 时，$E_{\\mathrm{el,gs}} = 0$。\n- 网格上的局域最小值是指其值严格小于其八个相邻网格点值的任意网格点（使用标准的 $3 \\times 3$ 邻域）。将欧几里得距离小于容差 $d_{\\mathrm{tol}} = 0.05$ $\\mathrm{\\AA}$ 的多个最小值合并为一个最小值，方法是保留能量最低的代表点。\n- 当存在至少两个不同的局域最小值，并且下面计算出的能垒高度严格为正时，存在双阱拓扑结构。\n- 能垒高度定义为连接两个最低能量最小值的直线段上 $E(Q_2(t), Q_3(t))$ 的最大值减去这两个最小值中能量较低者的能量，其中 $(Q_2(t), Q_3(t)) = (1-t)(Q_2^{(1)}, Q_3^{(1)}) + t (Q_2^{(2)}, Q_3^{(2)})$ 并且 $t \\in [0,1]$ 在 $N_{\\mathrm{path}} = 1001$ 个点上均匀采样。\n\n对于每个测试用例，您的程序必须输出一个包含五个条目的列表：\n$[\\text{is\\_double\\_well}, E_{\\min}, B, Q_2^{\\min}, Q_3^{\\min}]$，其中 $\\text{is\\_double\\_well}$ 是一个布尔值，$E_{\\min}$ 是最小势能面能量（单位 $\\mathrm{eV}$），$B$ 是能垒高度（单位 $\\mathrm{eV}$），$(Q_2^{\\min}, Q_3^{\\min})$ 是最低能量最小值的坐标（单位 $\\mathrm{\\AA}$）。将 $E_{\\min}$ 和 $B$ 以 $\\mathrm{eV}$ 表示，$(Q_2^{\\min}, Q_3^{\\min})$ 以 $\\mathrm{\\AA}$ 表示，每个值都四舍五入到六位小数。本问题不要求计算角度。\n\n测试套件参数，以元组 $(n_{\\mathrm{occ}}, g, k_2, k_3, \\beta, \\kappa, \\Delta, Q_{\\max}, N_{\\mathrm{grid}})$ 的形式给出：\n- 案例 A（理想路径，单电子占据下清晰的协同 Jahn–Teller 双阱）：$(1,\\, 1.6,\\, 1.0,\\, 0.8,\\, 0.25,\\, 0.20,\\, 0.0,\\, 2.5,\\, 201)$。\n- 案例 B（弱耦合边界，单阱）：$(1,\\, 0.2,\\, 1.0,\\, 0.8,\\, 0.25,\\, 0.20,\\, 0.0,\\, 1.0,\\, 201)$。\n- 案例 C（双电子占据抑制 Jahn–Teller效应，单阱）：$(2,\\, 1.6,\\, 1.0,\\, 0.8,\\, 0.25,\\, 0.20,\\, 0.0,\\, 2.5,\\, 201)$。\n- 案例 D（由三角场引起的非对称双阱）：$(1,\\, 1.6,\\, 1.0,\\, 0.8,\\, 0.25,\\, 0.20,\\, 0.3,\\, 2.5,\\, 201)$。\n- 案例 E（无电子，纯弹性单阱）：$(0,\\, 1.6,\\, 1.0,\\, 0.8,\\, 0.25,\\, 0.20,\\, 0.0,\\, 2.5,\\, 201)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表。每个案例的结果本身是一个形式为 $[\\text{boolean}, \\text{float}, \\text{float}, \\text{float}, \\text{float}]$ 的列表，例如 $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。不应打印任何其他文本。数值必须遵循上述单位说明和指定的四舍五入要求。", "solution": "该问题科学基础扎实、内容自洽、计算上明确定义。它提出了一个在固态物理背景下的 Jahn-Teller 效应的标准模型，这是材料物理学中的一个关键概念。势能面 (PES) 模型 $E(Q_2, Q_3)$ 结合了具有物理动机的晶格能量 $E_{\\mathrm{lat}}$ 和源自一个两能级量子系统的电子能量 $E_{\\mathrm{el,gs}}$。所有参数、定义和计算过程都明确无误地指定，从而可以得到唯一且可验证的解。因此，该问题被判定为**有效**。\n\n解决此问题需要实现一系列计算步骤，以分析不同物理参数集下势能面 $E(Q_2, Q_3)$ 的拓扑结构。\n\n总势能面 (PES) 由晶格能量和电子基态能量之和给出：\n$$E(Q_2,Q_3) = E_{\\mathrm{lat}}(Q_2,Q_3) + E_{\\mathrm{el,gs}}(Q_2,Q_3;n_{\\mathrm{occ}})$$\n其中晶格能量是一个四次多项式：\n$$E_{\\mathrm{lat}}(Q_2,Q_3) = \\tfrac{1}{2} k_2 Q_2^2 + \\tfrac{1}{2} k_3 Q_3^2 + \\tfrac{1}{4} \\beta \\left( Q_2^4 + Q_3^4 \\right) + \\tfrac{1}{2} \\kappa Q_2^2 Q_3^2$$\n电子基态能量取决于占据数 $n_{\\mathrm{occ}}$：\n$$E_{\\mathrm{el,gs}}(Q_2,Q_3;n_{\\mathrm{occ}}) = \\begin{cases} 0  \\text{if } n_{\\mathrm{occ}}=0 \\\\ - \\sqrt{(g Q_2)^2 + (g Q_3 + \\Delta)^2}  \\text{if } n_{\\mathrm{occ}}=1 \\\\ 0  \\text{if } n_{\\mathrm{occ}}=2 \\end{cases}$$\n\n寻找此势能面所要求属性的算法步骤如下：\n\n1.  **网格离散化和势能面评估**：对于每个测试用例，我们首先在 $(Q_2, Q_3)$ 平面上建立一个离散网格。每个轴上的网格点坐标使用 `numpy.linspace` 从 $-Q_{\\max}$ 到 $Q_{\\max}$ 生成 $N_{\\mathrm{grid}}$ 个点。然后创建一个网格（meshgrid）来表示所有的 $(Q_2, Q_3)$ 对。使用提供的公式计算该网格上每个点的总能量 $E(Q_2, Q_3)$，得到一个二维能量值数组。\n\n2.  **局域最小值识别**：问题将局域最小值定义为能量值严格小于其八个直接邻居的网格点。为了高效地找到这些点，采用了向量化的方法。能量网格 $E$ 的所有边都用 `infinity` 进行填充。然后，对于原始网格中的每个点，我们将其与其八个邻居进行布尔比较，这些邻居通过切片从填充后的网格中访问。只有当所有八个比较都为真时，一个点才是局域最小值。对生成的布尔掩码使用 `numpy.argwhere` 函数来检索所有局域最小值的索引。\n\n3.  **最小值合并**：鉴于网格的离散性，一个连续的最小值可能会被检测为几个相邻的网格点。为了合并这些点，应用一个合并程序。首先，将检测到的局域最小值列表（每个包含其能量和坐标）按能量升序排序。然后，我们遍历这个排序后的列表，构建一个新的不同最小值的列表。一个候选最小值只有在它与所有先前接受的最小值的欧几里得距离都大于容差 $d_{\\mathrm{tol}} = 0.05 \\, \\mathrm{\\AA}$ 时，才会被添加到新列表中。这确保了对于任何距离小于 $d_{\\mathrm{tol}}$ 的最小值簇，只保留绝对能量最低的那个。\n\n4.  **分析与输出计算**：\n    -   全局最小能量 $E_{\\min}$ 及其坐标 $(Q_2^{\\min}, Q_3^{\\min})$ 取自最终合并列表中的最低能量最小值。如果没有找到局域最小值，则通过搜索整个能量网格 $E$ 来确定全局最小值。\n    -   为了确定是否存在双阱拓扑结构并计算能垒高度 $B$，我们检查是否找到了至少两个不同的最小值。\n    -   如果存在的最小值少于两个，则系统不是双阱（`is_double_well = False`），且能垒高度定义为 $B=0$。\n    -   如果存在两个或更多最小值，我们考虑能量最低的两个，称其坐标为 $(Q_2^{(1)}, Q_3^{(1)})$ 和 $(Q_2^{(2)}, Q_3^{(2)})$。它们之间的直线路径由 $t \\in [0,1]$ 参数化：\n    $$(Q_2(t), Q_3(t)) = (1-t)(Q_2^{(1)}, Q_3^{(1)}) + t (Q_2^{(2)}, Q_3^{(2)})$$\n    -   该路径在 $N_{\\mathrm{path}} = 1001$ 个点上采样。在每个 $(Q_2(t), Q_3(t))$ 坐标点上评估解析的势能面函数 $E(Q_2, Q_3)$。\n    -   能垒高度 $B$ 计算为该路径上的最大能量减去全局最小能量 $E_{\\min}$（即两个阱中较深者的能量）。\n    -   如果找到至少两个最小值且计算出的能垒高度 $B$ 严格为正，则双阱拓扑结构 `is_double_well` 被确认为 `True`。\n\n5.  **格式化**：最后，对于每个测试用例，收集结果 $[\\text{is\\_double\\_well}, E_{\\min}, B, Q_2^{\\min}, Q_3^{\\min}]$。浮点数四舍五入到六位小数，并将所有结果的集合格式化为所要求的单行列表之列表的字符串表示。\n\n将此系统性程序应用于五个测试用例中的每一个，以生成最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It iterates through each parameter set, processes it, and prints the final result.\n    \"\"\"\n\n    def process_case(params):\n        \"\"\"\n        Processes a single test case: builds the PES, finds minima, and calculates barrier.\n        \"\"\"\n        n_occ = params['n_occ']\n        g = params['g']\n        k2 = params['k2']\n        k3 = params['k3']\n        beta = params['beta']\n        kappa = params['kappa']\n        delta = params['delta']\n        Q_max = params['Q_max']\n        N_grid = params['N_grid']\n        d_tol = 0.05\n        N_path = 1001\n\n        def calculate_pes(q2, q3):\n            \"\"\"Analytic function for the Potential Energy Surface.\"\"\"\n            E_lat = 0.5 * k2 * q2**2 + 0.5 * k3 * q3**2 + \\\n                    0.25 * beta * (q2**4 + q3**4) + 0.5 * kappa * q2**2 * q3**2\n\n            if n_occ == 1:\n                E_el_gs = -np.sqrt((g * q2)**2 + (g * q3 + delta)**2)\n            else:  # n_occ = 0 or 2\n                E_el_gs = np.zeros_like(q2) if isinstance(q2, np.ndarray) else 0.0\n\n            return E_lat + E_el_gs\n\n        # 1. Grid Discretization and PES Evaluation\n        q_coords = np.linspace(-Q_max, Q_max, N_grid)\n        Q2, Q3 = np.meshgrid(q_coords, q_coords)\n        E = calculate_pes(Q2, Q3)\n\n        # 2. Local Minima Identification\n        padded_E = np.pad(E, pad_width=1, mode='constant', constant_values=np.inf)\n        minima_mask = (E  padded_E[0:-2, 0:-2])  (E  padded_E[0:-2, 1:-1])  \\\n                      (E  padded_E[0:-2, 2:])    (E  padded_E[1:-1, 0:-2])  \\\n                      (E  padded_E[1:-1, 2:])    (E  padded_E[2:,   0:-2])  \\\n                      (E  padded_E[2:,   1:-1])  (E  padded_E[2:,   2:])\n        \n        min_indices = np.argwhere(minima_mask)\n        \n        local_minima = []\n        if min_indices.size > 0:\n            for i, j in min_indices:\n                local_minima.append({'E': E[i, j], 'Q2': Q2[i, j], 'Q3': Q3[i, j]})\n        \n        # 3. Minima Merging\n        sorted_minima = []\n        if local_minima:\n            local_minima.sort(key=lambda m: m['E'])\n            merged_minima = []\n            for min_candidate in local_minima:\n                is_close = any(\n                    np.sqrt((min_candidate['Q2'] - em['Q2'])**2 + (min_candidate['Q3'] - em['Q3'])**2)  d_tol\n                    for em in merged_minima\n                )\n                if not is_close:\n                    merged_minima.append(min_candidate)\n            sorted_minima = merged_minima\n\n        # 4. Analysis and Output Calculation\n        is_double_well = False\n        barrier_height = 0.0\n\n        if not sorted_minima:\n            min_idx = np.unravel_index(np.argmin(E), E.shape)\n            E_min = E[min_idx]\n            Q2_min, Q3_min = Q2[min_idx], Q3[min_idx]\n        else:\n            min1 = sorted_minima[0]\n            E_min, Q2_min, Q3_min = min1['E'], min1['Q2'], min1['Q3']\n\n            if len(sorted_minima) >= 2:\n                min2 = sorted_minima[1]\n                q2_1, q3_1 = min1['Q2'], min1['Q3']\n                q2_2, q3_2 = min2['Q2'], min2['Q3']\n                \n                t = np.linspace(0, 1, N_path)\n                path_q2 = (1 - t) * q2_1 + t * q2_2\n                path_q3 = (1 - t) * q3_1 + t * q3_2\n                \n                path_E = calculate_pes(path_q2, path_q3)\n                \n                E_path_max = np.max(path_E)\n                B = E_path_max - E_min \n                \n                if B > 1e-9:  # Use tolerance for floating point > 0 check\n                    barrier_height = B\n                    is_double_well = True\n\n        return [is_double_well, E_min, barrier_height, Q2_min, Q3_min]\n\n    test_cases = [\n        # Case A\n        {'n_occ': 1, 'g': 1.6, 'k2': 1.0, 'k3': 0.8, 'beta': 0.25, 'kappa': 0.20, 'delta': 0.0, 'Q_max': 2.5, 'N_grid': 201},\n        # Case B\n        {'n_occ': 1, 'g': 0.2, 'k2': 1.0, 'k3': 0.8, 'beta': 0.25, 'kappa': 0.20, 'delta': 0.0, 'Q_max': 1.0, 'N_grid': 201},\n        # Case C\n        {'n_occ': 2, 'g': 1.6, 'k2': 1.0, 'k3': 0.8, 'beta': 0.25, 'kappa': 0.20, 'delta': 0.0, 'Q_max': 2.5, 'N_grid': 201},\n        # Case D\n        {'n_occ': 1, 'g': 1.6, 'k2': 1.0, 'k3': 0.8, 'beta': 0.25, 'kappa': 0.20, 'delta': 0.3, 'Q_max': 2.5, 'N_grid': 201},\n        # Case E\n        {'n_occ': 0, 'g': 1.6, 'k2': 1.0, 'k3': 0.8, 'beta': 0.25, 'kappa': 0.20, 'delta': 0.0, 'Q_max': 2.5, 'N_grid': 201},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        all_results.append(process_case(params))\n\n    # 5. Formatting\n    result_strings = []\n    for res in all_results:\n        bool_val, e_min, b, q2, q3 = res\n        result_strings.append(\n            f\"[{str(bool_val).lower()},{e_min:.6f},{b:.6f},{q2:.6f},{q3:.6f}]\"\n        )\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3479238"}, {"introduction": "一旦我们知道了势能面上的稳定态（极小点），下一个关键问题就是系统如何在它们之间进行转变。本练习将指导您实现“微动弹性带”（Nudged Elastic Band, NEB）方法，这是一种寻找最小能量路径（Minimum Energy Path, MEP）和定位过渡态的核心算法 ([@problem_id:3479294])。掌握NEB方法的实现对于计算化学和材料科学中的反应速率、扩散系数以及理解相变机制至关重要。", "problem": "你需要设计并实现一个独立的微动弹性带（Nudged Elastic Band, NEB）计算，以确定在一个面心立方（fcc）$(111)$ 表面上，吸附原子在相邻的空心位点之间的扩散势垒。计算需使用一个简化的、物理上合理的解析势能面（Potential Energy Surface, PES）。你的程序必须计算多个测试用例的最小能量路径和能量势垒，并以单行输出结果。\n\n背景和模型如下。\n\n- 基本原理：\n  - 势能面是一个标量场 $V(\\mathbf{r})$，它为每个构型坐标 $\\mathbf{r}$ 指定一个势能。对于约束在表面上的吸附原子，$\\mathbf{r} = (x,y)$ 是二维坐标。\n  - 一个由离散构型（镜像点）组成的链条近似一条连续路径。一个由 $N$ 个镜像点组成的弹性带 $\\{\\mathbf{r}_0,\\ldots,\\mathbf{r}_{N-1}\\}$（其端点 $\\mathbf{r}_0$ 和 $\\mathbf{r}_{N-1}$ 固定）被用来模拟一个过渡路径。端点是 $V(\\mathbf{r})$ 的极小值点，对应于相邻的空心位点。\n  - 弹性力维持镜像点之间大致均匀的间距，而物理势能梯度则驱动弹性带朝向最小能量路径移动。路径上的鞍点对应于收敛后能量最高的镜像点。\n\n- 表面晶格与解析势能面模型：\n  - 考虑一个适用于 fcc $(111)$ 表面的三角形布拉菲晶格。设实空间表面晶格参数为 $a$（单位为埃）。定义第一壳层倒格矢的模长为 $G = \\frac{4\\pi}{\\sqrt{3} a}$。\n  - 使用一阶谐波六方“蛋格”势能面\n    $$V(x,y) = V_1 \\left[\\cos(G x) + 2 \\cos\\!\\left(\\frac{G x}{2}\\right)\\cos\\!\\left(\\frac{\\sqrt{3} G y}{2}\\right)\\right],$$\n    其中 $V_1$ 是一个能量尺度（单位为电子伏特）。取 $a = 2.5\\ \\text{\\AA}$ 和 $V_1 = 0.4\\ \\text{eV}$。能量必须以电子伏特计算和报告，距离以埃为单位。三角函数中的所有角度均为弧度。\n  - 沿高对称线 $y=0$ 的两个相邻空心位点位于\n    $$x_1 = \\frac{4\\pi}{3 G} = \\frac{a}{\\sqrt{3}},\\quad x_2 = \\frac{8\\pi}{3 G} = \\frac{2 a}{\\sqrt{3}},\\quad y_1=y_2=0.$$\n    使用 $\\mathbf{r}_0=(x_1,0)$ 和 $\\mathbf{r}_{N-1}=(x_2,0)$作为固定端点。\n\n- NEB 设计要求：\n  - 构建一个包含端点在内的 $N$ 个镜像点的弹性带。内部镜像点的初始猜测必须是：\n    - 沿 $x$ 轴线性插值且 $y=0$ 的“线性”路径，在路径参数 $t \\in [0,1]$ 上均匀分布，其中镜像点索引为 $i$ 时 $t_i = \\frac{i}{N-1}$；或\n    - 具有横向位移 $y_i = A \\sin(\\pi t_i)$ 的“正弦”路径，其中 $A$ 是给定的振幅（单位为埃）。使用 $y_0=y_{N-1}=0$ 来保持端点固定。正弦函数中的角度为弧度。\n  - 在相邻镜像点之间使用劲度系数为 $k$（单位为 $\\text{eV}/\\text{\\AA}^2$）的相同胡克弹簧，以促进间距均匀。\n  - 使用标准的 NEB 力分解方法，该方法只保留真实力（势能面的负梯度）的垂直分量和弹簧力沿相邻镜像点定义的切线方向的平行分量。你可以选择性地采用爬山镜像修正方法，该方法将作用在能量最高的内部镜像点上的真实力的平行分量反向，以精确收敛到鞍点。\n  - 对镜像点使用最速下降法进行更新，位置更新公式为 $\\Delta \\mathbf{r}_i = \\alpha \\mathbf{F}^{\\text{NEB}}_i$，其中 $\\alpha$ 是步长（单位为 $\\text{\\AA}^2/\\text{eV}$），$\\mathbf{F}^{\\text{NEB}}_i$ 是作用在镜像点 $i$ 上的 NEB 力。\n  - 收敛判据为所有非端点镜像点上的最大 NEB 力的大小低于指定的容差 $\\tau$（单位为 $\\text{eV}/\\text{\\AA}$）。\n\n- 需报告的量：\n  - 对于每个测试用例，计算扩散势垒能量，其定义为 $E^\\ddagger - E_\\text{min}$，其中 $E^\\ddagger$ 是收敛后能量最高的镜像点的能量，$E_\\text{min} = \\min\\{V(\\mathbf{r}_0), V(\\mathbf{r}_{N-1})\\}$。以电子伏特为单位表示每个势垒，并四舍五入到六位小数。\n\n测试套件。你的程序必须严格使用以下测试用例和参数：\n\n- 用例 1 (理想路径): $N=7$，$k=5.0\\ \\text{eV}/\\text{\\AA}^2$，$\\tau=1.0\\times 10^{-3}\\ \\text{eV}/\\text{\\AA}$，$\\alpha=0.02\\ \\text{\\AA}^2/\\text{eV}$，$N_\\text{max}=5000$，初始路径类型“linear”，启用爬山镜像。\n- 用例 2 (粗糙离散化与爬山镜像): $N=3$，$k=5.0\\ \\text{eV}/\\text{\\AA}^2$，$\\tau=1.0\\times 10^{-4}\\ \\text{eV}/\\text{\\AA}$，$\\alpha=0.02\\ \\text{\\AA}^2/\\text{eV}$，$N_\\text{max}=8000$，初始路径类型“linear”，启用爬山镜像。\n- 用例 3 (硬弹簧，无爬山镜像): $N=9$，$k=50.0\\ \\text{eV}/\\text{\\AA}^2$，$\\tau=1.0\\times 10^{-3}\\ \\text{eV}/\\text{\\AA}$，$\\alpha=0.01\\ \\text{\\AA}^2/\\text{eV}$，$N_\\text{max}=6000$，初始路径类型“linear”，禁用爬山镜像。\n- 用例 4 (弯曲初始路径): $N=7$，$k=1.0\\ \\text{eV}/\\text{\\AA}^2$，$\\tau=2.0\\times 10^{-3}\\ \\text{eV}/\\text{\\AA}$，$\\alpha=0.03\\ \\text{\\AA}^2/\\text{eV}$，$N_\\text{max}=6000$，初始路径类型“sinusoidal”，振幅 $A=0.3\\ \\text{\\AA}$，启用爬山镜像。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个逗号分隔的四个势垒能量列表，四舍五入到六位小数，并用方括号括起来，顺序为用例 1 到 4（例如，$[0.200000,0.199876,0.201234,0.200001]$）。能量必须以电子伏特报告。", "solution": "该问题要求实现微动弹性带（NEB）方法，以寻找模型表面上吸附原子的最小能量路径（MEP）并计算其扩散势垒。解决方案首先定义系统的势能面（PES），然后详细说明 NEB 算法，最后将其应用于指定的测试用例。\n\n首先，我们定义物理系统。吸附原子在面心立方（fcc）$(111)$ 表面上的势能由一个二维解析势 $V(x,y)$ 建模。该表面的实空间晶格参数为 $a = 2.5\\ \\text{\\AA}$。势能面（PES）由一阶谐波六方“蛋格”势给出：\n$$V(x,y) = V_1 \\left[\\cos(G x) + 2 \\cos\\!\\left(\\frac{G x}{2}\\right)\\cos\\!\\left(\\frac{\\sqrt{3} G y}{2}\\right)\\right]$$\n此处，$V_1 = 0.4\\ \\text{eV}$ 是能量尺度，$G = \\frac{4\\pi}{\\sqrt{3} a}$ 是第一壳层倒格矢的模长。三角函数中的所有角度参数均为弧度。\n\n在位置 $\\mathbf{r} = (x,y)$ 的吸附原子上所受的真实力是该势的负梯度，$\\mathbf{F}^{\\text{true}}(\\mathbf{r}) = -\\nabla V(\\mathbf{r})$。梯度的分量为：\n$$ \\frac{\\partial V}{\\partial x} = -V_1 G \\left[ \\sin(G x) + \\sin\\left(\\frac{G x}{2}\\right)\\cos\\left(\\frac{\\sqrt{3} G y}{2}\\right) \\right] $$\n$$ \\frac{\\partial V}{\\partial y} = -V_1 G \\sqrt{3} \\cos\\left(\\frac{G x}{2}\\right)\\sin\\left(\\frac{\\sqrt{3} G y}{2}\\right) $$\n\n扩散路径被离散化为一条由 $N$ 个构型（称为镜像点）组成的链，记为 $\\{\\mathbf{r}_0, \\mathbf{r}_1, \\dots, \\mathbf{r}_{N-1}\\}$。端点 $\\mathbf{r}_0$ 和 $\\mathbf{r}_{N-1}$ 固定在两个相邻的空心位点上，这些位点是势能面（PES）的极小值点。其坐标给出如下：\n$$ \\mathbf{r}_0 = \\left(\\frac{a}{\\sqrt{3}}, 0\\right) \\quad \\text{and} \\quad \\mathbf{r}_{N-1} = \\left(\\frac{2a}{\\sqrt{3}}, 0\\right) $$\n在这些极小值点处的能量为 $E_{\\text{min}} = V(\\mathbf{r}_0) = V(\\mathbf{r}_{N-1}) = -1.5 V_1 = -0.6\\ \\text{eV}$。内部镜像点 $\\{\\mathbf{r}_1, \\dots, \\mathbf{r}_{N-2}\\}$ 通过端点之间的线性插值或正弦路径进行初始化，然后通过弛豫来寻找最小能量路径（MEP）。\n\nNEB 方法计算引导镜像点朝向最小能量路径（MEP）的力。作用在镜像点 $i$ 上的总 NEB 力 $\\mathbf{F}^{\\text{NEB}}_i$ 是两个分量的和：真实力的垂直分量和弹簧力的平行分量。弹簧力确保镜像点之间大致等距。\n对于每个内部镜像点 $i \\in \\{1, \\dots, N-2\\}$，我们定义一个路径的局部切向矢量 $\\hat{\\tau}_i$。我们采用一个稳健的定义，即使用连接相邻镜像点的归一化矢量：\n$$ \\hat{\\tau}_i = \\frac{\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}}{||\\mathbf{r}_{i+1} - \\mathbf{r}_{i-1}||} $$\n\n真实力 $\\mathbf{F}^{\\text{true}}_i = -\\nabla V(\\mathbf{r}_i)$ 被分解为平行于和垂直于该切线的两个分量：\n$$ \\mathbf{F}^{\\text{true, }\\|}_i = (\\mathbf{F}^{\\text{true}}_i \\cdot \\hat{\\tau}_i) \\hat{\\tau}_i $$\n$$ \\mathbf{F}^{\\text{true, }\\perp}_i = \\mathbf{F}^{\\text{true}}_i - \\mathbf{F}^{\\text{true, }\\|}_i $$\nNEB 算法仅使用垂直分量 $\\mathbf{F}^{\\text{true, }\\perp}_i$，它使路径向最小能量路径（MEP）弛豫，而不会导致镜像点沿路径滑动。\n\n在相邻镜像点之间放置劲度系数为 $k$ 的虚拟弹簧。作用在镜像点 $i$ 上的完整弹簧力为 $\\mathbf{F}^{\\text{spring-full}}_i = k(\\mathbf{r}_{i+1} - \\mathbf{r}_i) - k(\\mathbf{r}_i - \\mathbf{r}_{i-1})$。只保留该力平行于切线的分量：\n$$ \\mathbf{F}^{\\text{spring, }\\|}_i = (\\mathbf{F}^{\\text{spring-full}}_i \\cdot \\hat{\\tau}_i) \\hat{\\tau}_i $$\n这个分量用于均衡路径上镜像点之间的间距。\n\n在标准 NEB 计算中，总力是这些选定分量的和：\n$$ \\mathbf{F}^{\\text{NEB}}_i = \\mathbf{F}^{\\text{true, }\\perp}_i + \\mathbf{F}^{\\text{spring, }\\|}_i $$\n\n为了更精确地确定鞍点，使用了爬山镜像 NEB (CI-NEB) 修正方法。具有最高势能的内部镜像点，$i_{\\text{max}} = \\arg\\max_{j \\in \\{1,\\dots,N-2\\}} V(\\mathbf{r}_j)$，被指定为“爬山”镜像点。对于这个特定的镜像点，弹簧力被移除，并且真实力的平行分量被反转。力变为：\n$$ \\mathbf{F}^{\\text{CI-NEB}}_{i_{\\text{max}}} = \\mathbf{F}^{\\text{true, }\\perp}_{i_{\\text{max}}} - \\mathbf{F}^{\\text{true, }\\|}_{i_{\\text{max}}} = \\mathbf{F}^{\\text{true}}_{i_{\\text{max}}} - 2 \\mathbf{F}^{\\text{true, }\\|}_{i_{\\text{max}}} $$\n这种修正将镜像点沿路径向上推，以精确收敛到最小能量路径（MEP）的最高点，即鞍点。\n\n内部镜像点的位置使用简单的最速下降算法进行迭代更新：\n$$ \\mathbf{r}_i(t+1) = \\mathbf{r}_i(t) + \\alpha \\mathbf{F}^{\\text{NEB/CI-NEB}}_i(t) $$\n其中 $\\alpha$ 是一个恒定的步长。重复此过程，直到任何内部镜像点上的最大力的模量低于指定的容差 $\\max_i ||\\mathbf{F}_i||  \\tau$，或达到最大迭代次数 $N_{\\text{max}}$。\n\n收敛后，计算最小能量路径（MEP）上每个镜像点的能量。沿路径找到的最高能量记为 $E^\\ddagger = \\max_{i \\in \\{0,\\dots,N-1\\}} V(\\mathbf{r}_i)$。扩散势垒就是该鞍点能量与初始/最终态能量之差：\n$$ E_b = E^\\ddagger - E_{\\text{min}} $$\n对四个指定的测试用例中的每一个都执行此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {'N': 7, 'k': 5.0, 'tau': 1.0e-3, 'alpha': 0.02, 'N_max': 5000, \n         'initial_path': 'linear', 'A': 0.0, 'climbing_image': True},\n        # Case 2 (coarse discretization with climbing image)\n        {'N': 3, 'k': 5.0, 'tau': 1.0e-4, 'alpha': 0.02, 'N_max': 8000, \n         'initial_path': 'linear', 'A': 0.0, 'climbing_image': True},\n        # Case 3 (stiff springs, no climbing image)\n        {'N': 9, 'k': 50.0, 'tau': 1.0e-3, 'alpha': 0.01, 'N_max': 6000, \n         'initial_path': 'linear', 'A': 0.0, 'climbing_image': False},\n        # Case 4 (curved initial path)\n        {'N': 7, 'k': 1.0, 'tau': 2.0e-3, 'alpha': 0.03, 'N_max': 6000, \n         'initial_path': 'sinusoidal', 'A': 0.3, 'climbing_image': True},\n    ]\n\n    results = []\n    for params in test_cases:\n        barrier = run_neb(**params)\n        results.append(barrier)\n\n    # Format output as specified\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\n\ndef run_neb(N, k, tau, alpha, N_max, initial_path, A, climbing_image):\n    \"\"\"\n    Performs a Nudged Elastic Band calculation for a single test case.\n    \n    Args:\n        N (int): Number of images in the band.\n        k (float): Spring constant in eV/Å^2.\n        tau (float): Convergence tolerance for force in eV/Å.\n        alpha (float): Step size for steepest descent in Å^2/eV.\n        N_max (int): Maximum number of iterations.\n        initial_path (str): 'linear' or 'sinusoidal'.\n        A (float): Amplitude for sinusoidal path in Å.\n        climbing_image (bool): Whether to use the climbing-image modification.\n\n    Returns:\n        float: The calculated diffusion barrier in eV.\n    \"\"\"\n    #\n    # --- 1. System Setup: Constants and PES ---\n    #\n    a = 2.5  # Surface lattice parameter in Å\n    V1 = 0.4  # PES energy scale in eV\n    G = 4.0 * np.pi / (np.sqrt(3.0) * a)\n\n    def potential(r):\n        \"\"\"Calculates the potential energy V(x, y).\"\"\"\n        x, y = r\n        cos1 = np.cos(G * x)\n        cos2 = np.cos(0.5 * G * x)\n        cos3 = np.cos(0.5 * np.sqrt(3.0) * G * y)\n        return V1 * (cos1 + 2.0 * cos2 * cos3)\n\n    def grad_potential(r):\n        \"\"\"Calculates the gradient of the potential energy nabla V(x, y).\"\"\"\n        x, y = r\n        g_x_half = 0.5 * G * x\n        g_y_term = 0.5 * np.sqrt(3.0) * G * y\n        \n        sin_gx = np.sin(G * x)\n        sin_g_x_half = np.sin(g_x_half)\n        cos_g_x_half = np.cos(g_x_half)\n        sin_g_y_term = np.sin(g_y_term)\n        cos_g_y_term = np.cos(g_y_term)\n\n        dv_dx = -V1 * G * (sin_gx + sin_g_x_half * cos_g_y_term)\n        dv_dy = -V1 * G * np.sqrt(3.0) * cos_g_x_half * sin_g_y_term\n        return np.array([dv_dx, dv_dy])\n\n    #\n    # --- 2. Initialize the Band ---\n    #\n    r_start = np.array([a / np.sqrt(3.0), 0.0])\n    r_end = np.array([2.0 * a / np.sqrt(3.0), 0.0])\n    \n    band = np.zeros((N, 2))\n    band[0] = r_start\n    band[-1] = r_end\n    \n    for i in range(1, N - 1):\n        t_i = i / (N - 1.0)\n        band[i, 0] = r_start[0] + t_i * (r_end[0] - r_start[0])\n        if initial_path == 'sinusoidal':\n            band[i, 1] = A * np.sin(np.pi * t_i)\n\n    #\n    # --- 3. NEB Optimization Loop ---\n    #\n    for step in range(N_max):\n        # Calculate energies of all images\n        energies = np.array([potential(r) for r in band])\n        \n        # Find index of climbing image (if applicable)\n        climb_idx = -1\n        if climbing_image and N > 2:\n            # Only interior images can climb\n            climb_idx = np.argmax(energies[1:-1]) + 1\n        \n        forces_neb = np.zeros_like(band)\n        \n        # Calculate forces for all interior images\n        for i in range(1, N - 1):\n            # Define tangent vector\n            tau_vec = band[i + 1] - band[i - 1]\n            tau_norm = np.linalg.norm(tau_vec)\n            if tau_norm  1e-9:\n                tau_hat = np.zeros(2)\n            else:\n                tau_hat = tau_vec / tau_norm\n\n            # True force from potential gradient\n            F_true = -grad_potential(band[i])\n            \n            # --- Climbing image force calculation ---\n            if climbing_image and i == climb_idx:\n                F_true_parallel_comp = np.dot(F_true, tau_hat)\n                F_true_parallel = F_true_parallel_comp * tau_hat\n                # Force is true force with inverted parallel component\n                forces_neb[i] = F_true - 2.0 * F_true_parallel\n            # --- Standard NEB force calculation ---\n            else:\n                # Perpendicular component of true force\n                F_true_parallel_comp = np.dot(F_true, tau_hat)\n                F_true_perp = F_true - F_true_parallel_comp * tau_hat\n                \n                # Parallel component of spring force\n                len_segment_plus = np.linalg.norm(band[i + 1] - band[i])\n                len_segment_minus = np.linalg.norm(band[i] - band[i - 1])\n                F_spring_parallel_comp = k * (len_segment_plus - len_segment_minus)\n                F_spring_parallel = F_spring_parallel_comp * tau_hat\n\n                forces_neb[i] = F_true_perp + F_spring_parallel\n\n        # Update positions of interior images\n        band[1:-1] += alpha * forces_neb[1:-1]\n\n        # Check for convergence\n        max_force_mag = np.max(np.linalg.norm(forces_neb[1:-1], axis=1))\n        if max_force_mag  tau:\n            break\n\n    #\n    # --- 4. Calculate Final Barrier ---\n    #\n    final_energies = np.array([potential(r) for r in band])\n    E_min = final_energies[0]\n    E_dagger = np.max(final_energies)\n    barrier = E_dagger - E_min\n    \n    return barrier\n\nsolve()\n```", "id": "3479294"}, {"introduction": "计算出的活化能本身并非最终目的，其价值在于预测宏观现象。这项高级练习探讨了通过第一性原理（如密度泛函理论，DFT）计算出的扩散势垒与可观测性质（如离子电导率）之间的联系 ([@problem_id:3479253])。更关键的是，它引入了不确定性传播的概念，使我们能够量化地评估我们的预测对计算模型（例如交换关联泛函的选择）中不可避免的误差的敏感程度，这是严谨计算研究的关键一步。", "problem": "考虑晶格上的离子扩散，其中通过密度泛函理论（DFT）获得的势能面（PES）控制着离子的激活跳跃。比较了两种交换相关泛函：Perdew–Burke–Ernzerhof（PBE）和强约束适当范数（SCAN）。由于系统性的PES建模误差，每种泛函预测的扩散势垒 $ \\Delta E $ 被建模为一个正态随机变量。您将通过在固定温度下将这些势垒不确定性通过过渡态理论（TST）进行传播，来评估离子电导率对这些不确定性的敏感性。目标是定量评估预测的离子电导率对交换相关选择的稳健性。\n\n在以下基于物理的条件和常数下进行工作：\n- 固定绝对温度 $ T = 800\\,\\mathrm{K} $。\n- 尝试频率 $ \\nu = 1.0 \\times 10^{13}\\,\\mathrm{s}^{-1} $。\n- 跳跃长度 $ l = 3.0 \\times 10^{-10}\\,\\mathrm{m} $。\n- 空间维度 $ d = 3 $。\n- 等效最近邻跳跃方向数 $ z = 6 $。\n- 相关因子（假定为1） $ f = 1 $。\n- 可移动离子数密度 $ n = 5.0 \\times 10^{27}\\,\\mathrm{m}^{-3} $。\n- 基本电荷 $ q = 1.602\\,176\\,634 \\times 10^{-19}\\,\\mathrm{C} $。\n- 在涉及势垒统计时，使用单位为电子伏特每开尔文的玻尔兹曼常数 $ k_{\\mathrm{B}}^{\\mathrm{(eV/K)}} = 8.617\\,333\\,262\\,145 \\times 10^{-5}\\,\\mathrm{eV/K} $，在关联扩散与电导率时，使用单位为焦耳每开尔文的玻尔兹曼常数 $ k_{\\mathrm{B}}^{\\mathrm{(J/K)}} = 1.380\\,649 \\times 10^{-23}\\,\\mathrm{J/K} $。\n\n推导和计算的基本依据：\n- 经典过渡态理论（TST）：在固定温度 $ T $ 下，由热激活控制的势垒介导的跳跃。\n- 在 $ d $ 维晶格上，具有 $ z $ 个等效邻居和有限跳跃长度 $ l $ 的无偏随机行走。\n- 通过能斯特-爱因斯坦关系建立的扩散与电响应之间的热力学-动力学联系。\n- 通过平滑映射转换正态随机变量的基本概率理论。\n\n计算任务和输出：\n1. 对每种泛函，将势垒 $ \\Delta E $ 视为 $ \\Delta E \\sim \\mathcal{N}(\\mu, \\sigma^2) $，其中 $ \\mu $ 和 $ \\sigma $ 以电子伏特（eV）为单位。不使用蒙特卡洛模拟，通过TST和随机行走扩散将势垒不确定性传播到离子电导率。计算每种泛函的平均离子电导率和离子电导率的标准差。电导率以西门子每米（$ \\mathrm{S/m} $）表示。\n2. 计算在固定温度下，考虑到两种势垒的不确定性，SCAN预测的离子电导率高于PBE的概率，以小数形式表示。\n3. 为此比较定义一个稳健性谓词，如下所示：如果SCAN产生更高电导率的概率至少为 $ 0.8 $，并且两种电导率的变异系数（标准差除以平均值）中较大者不超过 $ 0.5 $，则预测被认为是稳健的。将此谓词作为布尔值输出。\n\n测试套件：\n对于以下每个案例，使用上面列出的通用常数和固定温度。每个案例提供 $ (\\mu_{\\mathrm{PBE}}, \\sigma_{\\mathrm{PBE}}, \\mu_{\\mathrm{SCAN}}, \\sigma_{\\mathrm{SCAN}}) $，单位为 eV。\n- 案例 $ 1 $: $ (0.35, 0.05, 0.28, 0.03) $。\n- 案例 $ 2 $: $ (0.15, 0.02, 0.18, 0.01) $。\n- 案例 $ 3 $: $ (0.90, 0.12, 0.80, 0.10) $。\n- 案例 $ 4 $: $ (0.40, 0.08, 0.40, 0.01) $。\n- 案例 $ 5 $ (边界，无不确定性): $ (0.30, 0.00, 0.25, 0.00) $。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例由一个方括号括起来的逗号分隔子列表表示，顺序如下：$ [\\text{mean}_{\\mathrm{PBE}}, \\text{std}_{\\mathrm{PBE}}, \\text{mean}_{\\mathrm{SCAN}}, \\text{std}_{\\mathrm{SCAN}}, \\text{prob}(\\sigma_{\\mathrm{SCAN}} > \\sigma_{\\mathrm{PBE}}), \\text{robust}] $。所有电导率必须以 $ \\mathrm{S/m} $ 为单位，所有概率均为小数，最后一个元素是布尔值。例如，总输出应类似于 $ [[a,b,c,d,e,f],[\\dots],\\dots] $，不含空格。", "solution": "问题陈述已经过严格审查，并被确定为有效。它具有科学依据，问题设定良好，并包含足够的信息来推导出唯一的解决方案。该问题要求定量分析密度泛函理论（DFT）计算的扩散势垒中的不确定性如何传播到离子电导率，以及这如何影响两种常见交换相关泛函 PBE 和 SCAN 之间的比较。存在一个轻微的符号歧义，即要求的输出格式中提到了 `prob(σ_SCAN > σ_PBE)`。在问题中，指代符 `σ` 已被用于表示能量势垒的标准差。然而，任务2明确要求计算SCAN预测的*离子电导率*高于PBE的概率。在此背景下，我们将把输出格式中的 '`σ`' 解释为离子电导率的符号，这是一种常见的惯例。根据规定，解决方案将通过解析方式推导，不使用蒙特卡洛模拟。\n\n推导过程主要分三个阶段：\n1.  建立扩散能垒 $ \\Delta E $ 和离子电导率（我们用 $ \\kappa $ 表示）之间的函数关系。\n2.  从正态分布的随机变量 $ \\Delta E $ 传播不确定性，以找到 $ \\kappa $ 结果分布的矩（平均值和标准差）。\n3.  比较两个随机变量 $ \\kappa_{\\mathrm{PBE}} $ 和 $ \\kappa_{\\mathrm{SCAN}} $，以计算所需概率并评估稳健性谓词。\n\n**1. 从扩散势垒到离子电导率**\n\n扩散激活势垒 $ \\Delta E $ 和离子电导率 $ \\kappa $ 之间的关系是通过连接三个物理模型建立的：过渡态理论（TST）、随机行走扩散和能斯特-爱因斯坦关系。\n\n根据TST，离子的热激活跳跃频率 $ \\Gamma $ 由阿伦尼乌斯方程给出：\n$$ \\Gamma = \\nu \\exp\\left(-\\frac{\\Delta E}{k_{\\mathrm{B}} T}\\right) $$\n其中 $ \\nu $ 是尝试频率，$ T $ 是绝对温度，$ k_{\\mathrm{B}} $ 是玻尔兹曼常数。由于 $ \\Delta E $ 以电子伏特（$ \\mathrm{eV} $）为单位，我们必须使用单位为 $ \\mathrm{eV/K} $ 的玻尔兹曼常数，记为 $ k_{\\mathrm{B}}^{\\mathrm{(eV/K)}} $。我们定义逆热能 $ \\beta_{\\mathrm{eV}} = \\frac{1}{k_{\\mathrm{B}}^{\\mathrm{(eV/K)}} T} $。方程变为：\n$$ \\Gamma = \\nu \\exp\\left(-\\beta_{\\mathrm{eV}} \\Delta E\\right) $$\n\n接下来，宏观扩散系数 $ D $ 与微观跳跃参数相关。对于在具有 $ z $ 个等效最近邻位点、维度为 $ d $、跳跃长度为 $ l $ 和相关因子为 $ f $ 的晶格上的无偏随机行走，扩散系数为：\n$$ D = \\frac{1}{2d} z f l^2 \\Gamma $$\n使用给定值 $ d=3 $，$ z=6 $ 和 $ f=1 $，这简化为：\n$$ D = \\frac{1}{2 \\cdot 3} \\cdot 6 \\cdot 1 \\cdot l^2 \\Gamma = l^2 \\Gamma = l^2 \\nu \\exp\\left(-\\beta_{\\mathrm{eV}} \\Delta E\\right) $$\n\n最后，能斯特-爱因斯坦关系将扩散系数 $ D $ 与离子电导率 $ \\kappa $ 联系起来：\n$$ \\kappa = \\frac{n q^2 D}{k_{\\mathrm{B}} T} $$\n其中 $ n $ 是可移动离子数密度，$ q $ 是基本电荷。在这个最终关系中，能量项必须使用国际单位制（焦耳）。因此，我们必须使用单位为 $ \\mathrm{J/K} $ 的玻尔兹曼常数，记为 $ k_{\\mathrm{B}}^{\\mathrm{(J/K)}} $。\n\n代入 $ D $ 的表达式，得到 $ \\kappa $ 和 $ \\Delta E $ 之间的完整关系：\n$$ \\kappa(\\Delta E) = \\left(\\frac{n q^2 l^2 \\nu}{k_{\\mathrm{B}}^{\\mathrm{(J/K)}} T}\\right) \\exp\\left(-\\frac{\\Delta E}{k_{\\mathrm{B}}^{\\mathrm{(eV/K)}} T}\\right) $$\n我们定义一个指数前常数 $ C = \\frac{n q^2 l^2 \\nu}{k_{\\mathrm{B}}^{\\mathrm{(J/K)}} T} $。该常数的单位是电导率（$ \\mathrm{S/m} $）。表达式简化为：\n$$ \\kappa(\\Delta E) = C \\exp(-\\beta_{\\mathrm{eV}} \\Delta E) $$\n\n**2. 不确定性传播和电导率的矩**\n\n问题陈述指出，对于每种泛函，扩散势垒 $ \\Delta E $ 是一个正态随机变量，$ \\Delta E \\sim \\mathcal{N}(\\mu_E, \\sigma_E^2) $。我们必须找到平均值 $ \\mu_\\kappa = E[\\kappa] $ 和标准差 $ \\sigma_\\kappa = \\sqrt{\\mathrm{Var}(\\kappa)} $。\n\n设随机变量为 $ X = \\Delta E $。那么 $ \\kappa = C e^{-\\beta_{\\mathrm{eV}} X} $。如果 $ X $ 是正态分布的，那么 $ Y = e^X $ 服从对数正态分布。\n我们定义一个新的随机变量 $ Z = -\\beta_{\\mathrm{eV}} X $。由于 $ X $ 是正态的，$ Z $ 也是正态的。其均值和方差为：\n$$ \\mu_Z = E[-\\beta_{\\mathrm{eV}} X] = -\\beta_{\\mathrm{eV}} \\mu_E $$\n$$ \\sigma_Z^2 = \\mathrm{Var}(-\\beta_{\\mathrm{eV}} X) = (-\\beta_{\\mathrm{eV}})^2 \\mathrm{Var}(X) = (\\beta_{\\mathrm{eV}} \\sigma_E)^2 $$\n电导率为 $ \\kappa = C e^Z $。由于 $ C $ 是一个常数，$ \\kappa $ 服从一个缩放的对数正态分布。对于 $ Z \\sim \\mathcal{N}(\\mu_Z, \\sigma_Z^2) $，$ e^Z $ 的矩是众所周知的：\n$$ E[e^Z] = \\exp(\\mu_Z + \\sigma_Z^2/2) $$\n$$ \\mathrm{Var}(e^Z) = (\\exp(\\sigma_Z^2) - 1)\\exp(2\\mu_Z + \\sigma_Z^2) $$\n将这些应用于 $ \\kappa $：\n平均离子电导率为：\n$$ \\mu_\\kappa = E[C e^Z] = C E[e^Z] = C \\exp(\\mu_Z + \\sigma_Z^2/2) = C \\exp\\left(-\\beta_{\\mathrm{eV}} \\mu_E + \\frac{(\\beta_{\\mathrm{eV}} \\sigma_E)^2}{2}\\right) $$\n离子电导率的方差是：\n$$ \\sigma_\\kappa^2 = \\mathrm{Var}(C e^Z) = C^2 \\mathrm{Var}(e^Z) = C^2 \\left(\\exp(\\sigma_Z^2) - 1\\right)\\exp(2\\mu_Z + \\sigma_Z^2) $$\n一个更直接表示标准差 $ \\sigma_\\kappa $ 的方法是通过变异系数（CV），$ \\mathrm{CV}_\\kappa = \\sigma_\\kappa / \\mu_\\kappa $：\n$$ \\mathrm{CV}_\\kappa = \\sqrt{\\exp(\\sigma_Z^2) - 1} = \\sqrt{\\exp((\\beta_{\\mathrm{eV}} \\sigma_E)^2) - 1} $$\n因此，标准差为：\n$$ \\sigma_\\kappa = \\mu_\\kappa \\sqrt{\\exp((\\beta_{\\mathrm{eV}} \\sigma_E)^2) - 1} $$\n这些公式允许根据PBE和SCAN泛函各自的 $ \\mu_E $ 和 $ \\sigma_E $ 计算电导率的平均值和标准差。\n\n**3. 概率比较和稳健性**\n\n任务2要求计算概率 $ P(\\kappa_{\\mathrm{SCAN}} > \\kappa_{\\mathrm{PBE}}) $。我们用下标 $ S $ 表示SCAN，用下标 $ P $ 表示PBE，来标记势垒和电导率。假设势垒 $ \\Delta E_S \\sim \\mathcal{N}(\\mu_{E,S}, \\sigma_{E,S}^2) $ 和 $ \\Delta E_P \\sim \\mathcal{N}(\\mu_{E,P}, \\sigma_{E,P}^2) $ 是独立的。\n不等式 $ \\kappa_S > \\kappa_P $ 可以写成：\n$$ C \\exp(-\\beta_{\\mathrm{eV}} \\Delta E_S) > C \\exp(-\\beta_{\\mathrm{eV}} \\Delta E_P) $$\n由于 $ C > 0 $ 且指数函数是单调的，这等价于：\n$$ -\\beta_{\\mathrm{eV}} \\Delta E_S > -\\beta_{\\mathrm{eV}} \\Delta E_P $$\n除以 $ -\\beta_{\\mathrm{eV}} $（一个负常数）会反转不等号：\n$$ \\Delta E_S  \\Delta E_P $$\n因此，我们需要计算 $ P(\\Delta E_S - \\Delta E_P  0) $。设 $ Y = \\Delta E_S - \\Delta E_P $。由于 $ \\Delta E_S $ 和 $ \\Delta E_P $ 是独立的诺模变量，它们的差 $ Y $ 也是一个诺模变量，其均值和方差为：\n$$ \\mu_Y = E[\\Delta E_S] - E[\\Delta E_P] = \\mu_{E,S} - \\mu_{E,P} $$\n$$ \\sigma_Y^2 = \\mathrm{Var}(\\Delta E_S) + \\mathrm{Var}(\\Delta E_P) = \\sigma_{E,S}^2 + \\sigma_{E,P}^2 $$\n期望的概率是 $ P(Y  0) $。我们将 $ Y $ 标准化为一个标准正态变量 $ Z_{\\mathrm{std}} \\sim \\mathcal{N}(0, 1) $：\n$$ P(Y  0) = P\\left(\\frac{Y - \\mu_Y}{\\sigma_Y}  \\frac{0 - \\mu_Y}{\\sigma_Y}\\right) = \\Phi\\left(-\\frac{\\mu_Y}{\\sigma_Y}\\right) $$\n其中 $ \\Phi $ 是标准正态分布的累积分布函数（CDF）。代入 $ \\mu_Y $ 和 $ \\sigma_Y $ 的表达式：\n$$ P(\\kappa_S > \\kappa_P) = \\Phi\\left(-\\frac{\\mu_{E,S} - \\mu_{E,P}}{\\sqrt{\\sigma_{E,S}^2 + \\sigma_{E,P}^2}}\\right) = \\Phi\\left(\\frac{\\mu_{E,P} - \\mu_{E,S}}{\\sqrt{\\sigma_{E,S}^2 + \\sigma_{E,P}^2}}\\right) $$\n这个概率可以使用标准的科学计算库来计算。\n\n最后，根据两个条件评估稳健性谓词：\n1.  SCAN产生更高电导率的概率至少为 $ 0.8 $：$ P(\\kappa_S > \\kappa_P) \\ge 0.8 $。\n2.  两个变异系数中较大者不超过 $ 0.5 $：$ \\max(\\mathrm{CV}_{\\kappa,P}, \\mathrm{CV}_{\\kappa,S}) \\le 0.5 $。\n如果两个条件都满足，则谓词为 `True`，否则为 `False`。\n\n**计算步骤摘要：**\n对于每个测试案例 $(\\mu_{E,P}, \\sigma_{E,P}, \\mu_{E,S}, \\sigma_{E,S})$：\n1.  计算常数：$ \\beta_{\\mathrm{eV}} = \\frac{1}{k_{\\mathrm{B}}^{\\mathrm{(eV/K)}} T} $ 和 $ C = \\frac{n q^2 l^2 \\nu}{k_{\\mathrm{B}}^{\\mathrm{(J/K)}} T} $。\n2.  对于PBE和SCAN，使用推导出的矩公式计算平均电导率 $ \\mu_\\kappa $ 和标准差 $ \\sigma_\\kappa $。\n3.  使用正态分布的CDF计算概率 $ P(\\kappa_S > \\kappa_P) $。\n4.  计算变异系数 $ \\mathrm{CV}_{\\kappa,P} $ 和 $ \\mathrm{CV}_{\\kappa,S} $。\n5.  评估稳健性谓词的两个条件，并用逻辑与（AND）组合它们。\n6.  格式化六个结果值以备最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the ionic diffusion sensitivity analysis problem.\n    \"\"\"\n\n    # --- Physical Constants and Given Parameters ---\n    T = 800.0  # Absolute temperature in K\n    nu = 1.0e13  # Attempt frequency in s^-1\n    l = 3.0e-10  # Jump length in m\n    d = 3  # Spatial dimensionality (unused as z is given)\n    z = 6  # Number of jump directions\n    f = 1.0  # Correlation factor\n    n = 5.0e27  # Mobile ion number density in m^-3\n    q = 1.602176634e-19  # Elementary charge in C\n    k_B_eV = 8.617333262145e-5  # Boltzmann constant in eV/K\n    k_B_J = 1.380649e-23  # Boltzmann constant in J/K\n\n    # --- Derived Constants ---\n    # Inverse thermal energy in eV^-1\n    beta_eV = 1.0 / (k_B_eV * T)\n    # Pre-exponential factor for conductivity in S/m\n    C = (n * q**2 * l**2 * nu) / (k_B_J * T)\n\n    # --- Test Cases ---\n    # Each case is (mu_PBE, sigma_PBE, mu_SCAN, sigma_SCAN) in eV.\n    test_cases = [\n        (0.35, 0.05, 0.28, 0.03),\n        (0.15, 0.02, 0.18, 0.01),\n        (0.90, 0.12, 0.80, 0.10),\n        (0.40, 0.08, 0.40, 0.01),\n        (0.30, 0.00, 0.25, 0.00),\n    ]\n\n    all_results = []\n\n    def calculate_conductivity_stats(mu_E, sigma_E):\n        \"\"\"\n        Calculates mean, std dev, and CV of conductivity.\n        \n        Args:\n            mu_E (float): Mean of the energy barrier (eV).\n            sigma_E (float): Standard deviation of the energy barrier (eV).\n\n        Returns:\n            tuple: (mean_conductivity, std_dev_conductivity, coeff_of_variation)\n        \"\"\"\n        if sigma_E == 0.0:\n            mean_kappa = C * np.exp(-beta_eV * mu_E)\n            std_kappa = 0.0\n            cv_kappa = 0.0\n            return mean_kappa, std_kappa, cv_kappa\n\n        term_sigma_sq = (beta_eV * sigma_E)**2\n        \n        mean_kappa = C * np.exp(-beta_eV * mu_E + term_sigma_sq / 2.0)\n        \n        # CV = sqrt(exp(sigma_Z^2) - 1)\n        cv_kappa = np.sqrt(np.exp(term_sigma_sq) - 1)\n        \n        std_kappa = mean_kappa * cv_kappa\n        \n        return mean_kappa, std_kappa, cv_kappa\n\n    for case in test_cases:\n        mu_E_pbe, sigma_E_pbe, mu_E_scan, sigma_E_scan = case\n\n        # Task 1: Calculate moments of conductivity\n        mean_kappa_pbe, std_kappa_pbe, cv_pbe = calculate_conductivity_stats(mu_E_pbe, sigma_E_pbe)\n        mean_kappa_scan, std_kappa_scan, cv_scan = calculate_conductivity_stats(mu_E_scan, sigma_E_scan)\n\n        # Task 2: Calculate probability P(kappa_SCAN > kappa_PBE)\n        # This is equivalent to P(delta_E_SCAN  delta_E_PBE)\n        mu_diff = mu_E_scan - mu_E_pbe\n        sigma_sum_sq = sigma_E_scan**2 + sigma_E_pbe**2\n\n        if sigma_sum_sq == 0.0:\n            # Deterministic case\n            prob = 1.0 if mu_E_scan  mu_E_pbe else 0.0\n        else:\n            sigma_diff = np.sqrt(sigma_sum_sq)\n            # P(Y  0) = CDF at (0 - mu_Y) / sigma_Y = CDF at -mu_Y / sigma_Y\n            prob = norm.cdf(-mu_diff / sigma_diff)\n        \n        # Task 3: Evaluate robustness predicate\n        cond1 = prob >= 0.8\n        cond2 = max(cv_pbe, cv_scan) = 0.5\n        is_robust = cond1 and cond2\n\n        # Format results for the current case\n        case_results = [\n            mean_kappa_pbe,\n            std_kappa_pbe,\n            mean_kappa_scan,\n            std_kappa_scan,\n            prob,\n            str(is_robust).lower() # Output 'true' or 'false'\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3479253"}]}