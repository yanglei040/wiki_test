{"hands_on_practices": [{"introduction": "在任何第一性原理计算中，确保结果的数值收敛性是首要任务。本练习将指导您如何为平面波密度泛函理论（DFT）计算设计一个系统性的收敛测试方案[@problem_id:3458680]。通过控制平面波截断能、k点密度和电子展宽这三个主要数值误差源，您将掌握获得可靠计算结果的关键技能。", "problem": "请考虑如下定义的晶体硅的内聚能。每个原子的内聚能，记作 $E_{\\mathrm{coh}}$，是孤立硅原子的总能量 $E_{\\mathrm{atom}}$ 与体硅中每个原子的总能量 $E_{\\mathrm{bulk}}/N$ 之差，即 $E_{\\mathrm{coh}} = E_{\\mathrm{atom}} - E_{\\mathrm{bulk}}/N$。在平面波密度泛函理论 (DFT) 计算中，计算出的内聚能会受到三种主要的可控数值误差的影响：由有限平面波截断引起的基组截断误差，由有限 $k$ 点密度引起的布里渊区积分不完全误差，以及由非零电子展宽宽度引起的展宽偏差。您的任务是设计一个系统性的、定量的收敛方案，以处理 $E_{\\mathrm{coh}}$ 相对于这三个参数的收敛问题。\n\n请使用以下基本物理和数值基础作为出发点：\n- Rayleigh–Ritz 变分原理意味着更大的基组（更高的截断能）不会增加基态能量，并且对于平滑赝势，平面波展开的基组不完备性误差通常随平面波动能截断 $E_{\\mathrm{cut}}$ 以幂律形式衰减。\n- 使用 Monkhorst–Pack 采样对平滑函数进行布里渊区积分的行为类似于黎曼和，其积分误差随着 $k$ 点数量 $N_k$ 的增加而衰减。\n- 对于半导体，一个小的有限电子展宽宽度 $\\sigma$（例如，费米-狄拉克展宽）会在内能中引入一个系统性偏差，该偏差在小 $\\sigma$ 处是解析的，并与 $\\sigma$呈二次方关系。\n\n采用一个与这些基础一致的、用于硅内聚能的代理、可加误差模型：\n$$\n\\Delta E_{\\mathrm{coh}}(E_{\\mathrm{cut}}, N_k, \\sigma) \\;=\\; \\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) \\;+\\; \\Delta E_{k}(N_k) \\;+\\; \\Delta E_{\\mathrm{sm}}(\\sigma),\n$$\n其渐进行为和正的前置因子如下：\n$$\n\\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) \\;=\\; A_{\\mathrm{pw}} \\, E_{\\mathrm{cut}}^{-\\tfrac{3}{2}}, \\qquad\n\\Delta E_{k}(N_k) \\;=\\; \\frac{A_{k}}{N_k}, \\qquad\n\\Delta E_{\\mathrm{sm}}(\\sigma) \\;=\\; A_{\\mathrm{sm}} \\, \\sigma^{2}.\n$$\n假设以下固定的、依赖于材料和方法的常数，这些常数适用于使用平滑赝势的模守恒或投影缀加波的硅计算：\n- $A_{\\mathrm{pw}} = 12.0$（当 $E_{\\mathrm{cut}}$ 单位为电子伏特，缩写为 eV 时），\n- $A_{k} = 0.6$（单位为 eV），\n- $A_{\\mathrm{sm}} = 0.1$（单位为 eV$^{-1}$），\n以及一个参考内聚能 $E_{\\mathrm{coh}}^{\\mathrm{true}} = 4.63$ eV/原子，该值仅用于解释误差的大小。所有能量必须以 eV 表示，$\\sigma$ 必须以 eV 表示。\n\n设计一个方案，给定一个目标绝对误差预算 $\\tau$ 和一组满足 $b_{\\mathrm{pw}} + b_{k} + b_{\\mathrm{sm}} \\le \\tau$ 的非负子预算 $(b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}})$，该方案能产生最小的参数集，以分别满足以下三个不等式：\n$$\n\\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) \\le b_{\\mathrm{pw}}, \\quad\n\\Delta E_{k}(N_k) \\le b_{k}, \\quad\n\\Delta E_{\\mathrm{sm}}(\\sigma) \\le b_{\\mathrm{sm}}.\n$$\n为使结果具有实际可操作性且明确无误，请施加以下离散化和报告规则：\n- $E_{\\mathrm{cut}}$ 必须选择为满足其不等式的最小整数（单位为 eV）；报告 $E_{\\mathrm{cut}}$ 时，以 eV 为单位，四舍五入到三位小数。\n- $N_k$ 必须选择为满足其不等式的最小正整数；报告 $N_k$ 时，应为整数。\n- $\\sigma$ 必须选择为仍满足其不等式的最大值，然后向下取整到最接近的 $0.001$ eV，以避免取整后超出误差子预算；报告 $\\sigma$ 时，以 eV 为单位，四舍五入到三位小数。\n\n最后，对于每个测试用例，使用实际选择的 $(E_{\\mathrm{cut}}, N_k, \\sigma)$（在应用离散化和取整规则后），计算并报告所达到的总绝对误差\n$$\n\\Delta E_{\\mathrm{tot}} \\;=\\; \\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) + \\Delta E_{k}(N_k) + \\Delta E_{\\mathrm{sm}}(\\sigma)\n$$\n报告 $\\Delta E_{\\mathrm{tot}}$ 时，以 eV 为单位，四舍五入到六位小数。\n\n测试套件。将您的方案应用于以下四个案例，它们共同探讨了一般情况、紧凑边界、宽松容差和不平衡的展宽预算。每个案例由 $(\\tau, b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}})$ 指定：\n- 案例 A（一般情况）：$(\\tau, b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}}) = (0.005, 0.0025, 0.0015, 0.001)$。\n- 案例 B（紧凑边界）：$(\\tau, b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}}) = (0.001, 0.0005, 0.00025, 0.00025)$。\n- 案例 C（宽松容差）：$(\\tau, b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}}) = (0.020, 0.015, 0.003, 0.002)$。\n- 案例 D（不平衡的展宽预算）：$(\\tau, b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}}) = (0.003, 0.0015, 0.0014, 0.0001)$。\n\n您的程序必须为每个案例计算推荐的 $(E_{\\mathrm{cut}}, N_k, \\sigma)$ 以及使用上述模型和指定取整规则所达到的 $\\Delta E_{\\mathrm{tot}}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含汇总为单个类 Python 的列表字面量的四个案例结果，其中每个内部列表为\n$$\n[E_{\\mathrm{cut}} \\text{ (eV, 浮点数, 三位小数)},\\; N_k \\text{ (整数)},\\; \\sigma \\text{ (eV, 浮点数, 三位小数)},\\; \\Delta E_{\\mathrm{tot}} \\text{ (eV, 浮点数, 六位小数)}].\n$$\n例如，整体输出必须具有以下形式\n$[[e_1, n_1, s_1, d_1],[e_2, n_2, s_2, d_2],[e_3, n_3, s_3, d_3],[e_4, n_4, s_4, d_4]]$\n在单行上，无任何附加文本，并且所有能量单位均为 eV。本问题不涉及角度。任何地方都不得使用百分比；仅可使用小数。", "solution": "经评估，问题陈述是有效的。它在科学上基于计算材料科学的原理，特别是密度泛函理论（DFT）。所提供的关于平面波截断能、$k$ 点采样和电子展宽的误差模型是收敛性研究中使用的标准、适定的近似方法。该问题是自洽的、客观的，并提供了所有必要的数据和规则，以得出一个唯一的、可验证的解决方案。因此，我们可以着手推导计算方案。\n\n目标是确定满足一组单独误差预算 $(b_{\\mathrm{pw}}, b_{k}, b_{\\mathrm{sm}})$ 的最小计算参数 $(E_{\\mathrm{cut}}, N_k, \\sigma)$。误差模型如下：\n$$\n\\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) = A_{\\mathrm{pw}} \\, E_{\\mathrm{cut}}^{-\\tfrac{3}{2}}\n$$\n$$\n\\Delta E_{k}(N_k) = \\frac{A_{k}}{N_k}\n$$\n$$\n\\Delta E_{\\mathrm{sm}}(\\sigma) = A_{\\mathrm{sm}} \\, \\sigma^{2}\n$$\n常数为 $A_{\\mathrm{pw}} = 12.0$（单位 $\\text{eV}^{5/2}$）、$A_{k} = 0.6$（单位 $\\text{eV}$）和 $A_{\\mathrm{sm}} = 0.1$（单位 $\\text{eV}^{-1}$）。对于每个参数，我们将求解相应的不等式，并应用指定的离散化和取整规则。\n\n首先，我们确定所需的平面波截断能 $E_{\\mathrm{cut}}$。条件是 $\\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut}}) \\le b_{\\mathrm{pw}}$。代入模型并重新整理不等式以求解 $E_{\\mathrm{cut}}$ 可得：\n$$\nA_{\\mathrm{pw}} \\, E_{\\mathrm{cut}}^{-\\tfrac{3}{2}} \\le b_{\\mathrm{pw}} \\implies E_{\\mathrm{cut}}^{\\tfrac{3}{2}} \\ge \\frac{A_{\\mathrm{pw}}}{b_{\\mathrm{pw}}} \\implies E_{\\mathrm{cut}} \\ge \\left(\\frac{A_{\\mathrm{pw}}}{b_{\\mathrm{pw}}}\\right)^{\\tfrac{2}{3}}\n$$\n由于 $\\Delta E_{\\mathrm{pw}}$ 是 $E_{\\mathrm{cut}}$ 的单调递减函数，此不等式定义了 $E_{\\mathrm{cut}}$ 的下界。问题要求满足此条件的最小整数值 $E_{\\mathrm{cut}}$。这可以通过计算下界并对其取上取整（ceiling）得到。\n$$\nE_{\\mathrm{cut,final}} = \\left\\lceil \\left(\\frac{A_{\\mathrm{pw}}}{b_{\\mathrm{pw}}}\\right)^{\\tfrac{2}{3}} \\right\\rceil\n$$\n\n其次，我们确定所需的 $k$ 点数量 $N_k$。条件是 $\\Delta E_{k}(N_k) \\le b_{k}$。代入 $k$ 点积分误差的模型并求解 $N_k$：\n$$\n\\frac{A_{k}}{N_k} \\le b_{k} \\implies N_k \\ge \\frac{A_{k}}{b_{k}}\n$$\n误差 $\\Delta E_{k}$ 是 $N_k$ 的单调递减函数。我们需要 $N_k$ 的最小正整数，这可以通过对下界取上取整得到。\n$$\nN_{k,\\text{final}} = \\left\\lceil \\frac{A_{k}}{b_{k}} \\right\\rceil\n$$\n\n第三，我们确定电子展宽宽度 $\\sigma$。条件是 $\\Delta E_{\\mathrm{sm}}(\\sigma) \\le b_{\\mathrm{sm}}$。误差 $\\Delta E_{\\mathrm{sm}}$ 随 $\\sigma$ 的增大而增大，因此该条件为 $\\sigma$ 设定了上界。\n$$\nA_{\\mathrm{sm}} \\, \\sigma^{2} \\le b_{\\mathrm{sm}} \\implies \\sigma^2 \\le \\frac{b_{\\mathrm{sm}}}{A_{\\mathrm{sm}}} \\implies \\sigma \\le \\sqrt{\\frac{b_{\\mathrm{sm}}}{A_{\\mathrm{sm}}}}\n$$\n方案要求满足此不等式的最大 $\\sigma$ 值，即其上界本身 $\\sigma_{\\mathrm{max}} = \\sqrt{b_{\\mathrm{sm}}/A_{\\mathrm{sm}}}$。然后该值必须向下取整到最接近的 $0.001$ eV。这可以用数学方式表示为：\n$$\n\\sigma_{\\text{final}} = \\frac{\\left\\lfloor 1000 \\cdot \\sqrt{\\frac{b_{\\mathrm{sm}}}{A_{\\mathrm{sm}}}} \\right\\rfloor}{1000}\n$$\n此取整规则确保最终的误差 $\\Delta E_{\\mathrm{sm}}(\\sigma_{\\text{final}})$ 不会超过子预算 $b_{\\mathrm{sm}}$。\n\n最后，在确定了离散的、可操作的参数 $(E_{\\mathrm{cut,final}}, N_{k,\\text{final}}, \\sigma_{\\text{final}})$ 之后，我们通过将这些值代入各自的误差函数并求和来计算总的实现误差 $\\Delta E_{\\mathrm{tot}}$。\n$$\n\\Delta E_{\\mathrm{tot}} = \\Delta E_{\\mathrm{pw}}(E_{\\mathrm{cut,final}}) + \\Delta E_{k}(N_{k,\\text{final}}) + \\Delta E_{\\mathrm{sm}}(\\sigma_{\\text{final}})\n$$\n$$\n\\Delta E_{\\mathrm{tot}} = A_{\\mathrm{pw}} \\, E_{\\mathrm{cut,final}}^{-\\tfrac{3}{2}} + \\frac{A_{k}}{N_{k,\\text{final}}} + A_{\\mathrm{sm}} \\, \\sigma_{\\text{final}}^{2}\n$$\n然后根据每个测试用例指定的格式规则报告 $(E_{\\mathrm{cut,final}}, N_{k,\\text{final}}, \\sigma_{\\text{final}})$ 的值和最终的 $\\Delta E_{\\mathrm{tot}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the convergence parameters for DFT calculations based on a\n    surrogate error model and a set of test cases.\n    \"\"\"\n    \n    # Define the constants from the problem statement.\n    A_pw = 12.0  # Units: eV^(5/2)\n    A_k = 0.6    # Units: eV\n    A_sm = 0.1   # Units: eV^(-1)\n\n    # Define the test cases from the problem statement.\n    # Each case is (tau, b_pw, b_k, b_sm).\n    test_cases = [\n        # Case A (general)\n        (0.005, 0.0025, 0.0015, 0.001),\n        # Case B (tight)\n        (0.001, 0.0005, 0.00025, 0.00025),\n        # Case C (loose)\n        (0.020, 0.015, 0.003, 0.002),\n        # Case D (imbalanced smearing)\n        (0.003, 0.0015, 0.0014, 0.0001),\n    ]\n\n    all_results_formatted = []\n\n    for case in test_cases:\n        _, b_pw, b_k, b_sm = case\n\n        # 1. Determine E_cut\n        # E_cut >= (A_pw / b_pw)^(2/3)\n        # We need the smallest integer satisfying this.\n        e_cut_bound = (A_pw / b_pw)**(2.0/3.0)\n        e_cut_final = int(np.ceil(e_cut_bound))\n\n        # 2. Determine N_k\n        # N_k >= A_k / b_k\n        # We need the smallest positive integer satisfying this.\n        n_k_bound = A_k / b_k\n        n_k_final = int(np.ceil(n_k_bound))\n\n        # 3. Determine sigma\n        # sigma = sqrt(b_sm / A_sm)\n        # We need the largest value, rounded down to the nearest 0.001 eV.\n        sigma_bound = np.sqrt(b_sm / A_sm)\n        sigma_final = np.floor(sigma_bound * 1000) / 1000.0\n\n        # 4. Calculate the total achieved error with the final parameters\n        delta_e_pw = A_pw * (e_cut_final**(-1.5))\n        delta_e_k = A_k / n_k_final\n        delta_e_sm = A_sm * (sigma_final**2)\n        delta_e_tot = delta_e_pw + delta_e_k + delta_e_sm\n\n        # Format the inner list as a string according to output rules.\n        inner_list_str = (\n            f\"[{e_cut_final:.3f},\"\n            f\"{n_k_final},\"\n            f\"{sigma_final:.3f},\"\n            f\"{delta_e_tot:.6f}]\"\n        )\n        all_results_formatted.append(inner_list_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_formatted)}]\")\n\nsolve()\n```", "id": "3458680"}, {"introduction": "掌握了数值收敛性测试后，我们便可以应用这些技能来计算重要的材料属性。本练习将引导您计算空位形成能，这是一个决定材料缺陷化学和性能的关键参数[@problem_id:3458666]。通过一个简化的势函数模型，您将学习使用超胞方法来模拟点缺陷，并探索计算结果随超胞尺寸的收敛性，这是处理有限尺寸效应的一个核心概念。", "problem": "您的任务是实现一个计算工作流，使用超胞方法估算面心立方（FCC）铝中的空位形成能，并考察其相对于胞体尺寸的有限尺寸收敛性。计算应在固定体积和周期性边界条件下进行。\n\n使用的基本原理：\n- 空位形成被定义为从理想晶体中移除一个原子，并将其置于具有相同化学势的储存库中，整个过程在固定体积和边界条件下进行。\n- 系统的总能量是在一个物理上合理的截断半径内对所有对相互作用求和，并对周期性边界条件使用最小镜像约定。\n- 在固定体积的大型均匀晶体中，化学势与单个原子的能量之间的关系。\n\n按如下方式构建FCC铝晶格：\n- 使用常规立方晶格参数 $a_0 = 4.05\\,\\mathrm{\\AA}$。\n- 常规立方晶胞的FCC基矢在分数坐标下为 $\\{(0,0,0), (0, \\tfrac{1}{2}, \\tfrac{1}{2}), (\\tfrac{1}{2}, 0, \\tfrac{1}{2}), (\\tfrac{1}{2}, \\tfrac{1}{2}, 0)\\}$，乘以 $a_0$ 可得到其笛卡尔坐标位置。\n- 通过将常规晶胞复制 $n \\times n \\times n$ 次来构建一个立方超胞，其中 $n$ 为整数。\n\n使用Morse对势来模拟原子间的相互作用：\n- 对势为 $V(r) = D\\left(e^{-2 a (r - r_0)} - 2 e^{-a (r - r_0)}\\right)$。\n- 使用 $D = 0.35\\,\\mathrm{eV}$，$a = 1.2\\,\\mathrm{\\AA^{-1}}$ 和 $r_0 = a_0/\\sqrt{2}\\,\\mathrm{\\AA}$。\n- 施加一个实空间截断半径 $r_c = 8.0\\,\\mathrm{\\AA}$；当 $r \\ge r_c$ 时的相互作用将被忽略。\n- 在边长为 $L = n a_0$ 的立方盒子中，使用Born–von Karman周期性边界条件下的最小镜像约定。\n\n将理想超胞能量 $E_{\\mathrm{perf}}(n)$ 定义为 $n \\times n \\times n$ FCC超胞中所有原子的总对势能。通过在同一盒子中移除一个原子以产生一个空位来定义缺陷超胞能量 $E_{\\mathrm{def}}(n)$。移除在笛卡尔坐标系下距离盒子中心 $(L/2, L/2, L/2)$ 最近的那个原子。\n\n仅从上述基本原理和定义出发，推导用 $E_{\\mathrm{perf}}(n)$ 和 $E_{\\mathrm{def}}(n)$ 表示的空位形成能 $E_f(n)$ 的表达式，并在您的程序中实现它。清晰地论证化学势的作用以及在这种有限超胞方法中如何对其进行近似。基于弹性和电子有限尺寸效应，以及缺陷-镜像相互作用随 $n$ 的标度关系，讨论当 $n$ 增大时 $E_f(n)$ 预计将如何收敛。\n\n您的程序必须：\n- 为每个给定的 $n$ 构建FCC原子位置。\n- 按上述方法计算 $E_{\\mathrm{perf}}(n)$ 和 $E_{\\mathrm{def}}(n)$。\n- 使用您推导的表达式计算空位形成能 $E_f(n)$。\n- 长度单位使用 $\\mathrm{\\AA}$，能量单位使用 $\\mathrm{eV}$。\n- 将每个最终的空位形成能以电子伏特（eV）为单位表示，并四舍五入到三位小数。\n\n测试集：\n- 使用复制尺寸 $n \\in \\{1, 2, 3, 4\\}$ 来展示有限尺寸收敛性。\n- 边界情况：$n = 1$ 代表了由最小周期性镜像相互作用主导的情况。\n- 增大的 $n$ 值提供了趋向大胞体极限的趋势。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含空位形成能 $[E_f(1), E_f(2), E_f(3), E_f(4)]$，形式为一个用方括号括起来的逗号分隔列表，每个值都以 $\\mathrm{eV}$ 为单位并四舍五入到三位小数（例如，\"[0.123,0.456,0.789,1.234]\"）。", "solution": "该问题要求计算面心立方（FCC）铝在不同超胞尺寸 $n$ 下的空位形成能 $E_f$，以研究有限尺寸收敛性。这将通过在固定体积的周期性超胞框架内，使用对势Morse势来完成。\n\n**1. 理论框架：空位形成能**\n\n空位形成能 $E_f$ 定义为在原本理想的晶体中创建一个空位所需的能量代价。该过程涉及从一个体相位置移除一个原子，并将其转移到一个概念上的能量储存库中，该储存库代表了一个原子在理想无限晶体中的状态。处于该储存库中的原子的能量即为化学势 $\\mu$。\n\n设理想超胞包含 $N$ 个原子，总能量为 $E_{\\mathrm{perf}}(N)$。移除一个原子后，系统变为一个包含 $N-1$ 个原子的缺陷超胞，其总能量为 $E_{\\mathrm{def}}(N-1)$。能量变化，即空位形成能，由下式给出：\n$$E_f = [E_{\\mathrm{def}}(N-1) + \\mu] - E_{\\mathrm{perf}}(N)$$\n\n在 使用有限超胞的计算模型中，必须对无限晶体的化学势 $\\mu$ 进行近似。最常见且物理上合理的近似是使用现有“最佳”理想晶体（即理想超胞本身）中每个原子的平均能量。因此，对于一个包含 $N$ 个原子的超胞，我们近似 $\\mu$ 为：\n$$\\mu \\approx \\frac{E_{\\mathrm{perf}}(N)}{N}$$\n\n将此近似代入 $E_f$ 的定义，得到超胞模型中的空位形成能公式：\n$$E_f(N) = E_{\\mathrm{def}}(N-1) + \\frac{E_{\\mathrm{perf}}(N)}{N} - E_{\\mathrm{perf}}(N)$$\n$$E_f(N) = E_{\\mathrm{def}}(N-1) - \\left(1 - \\frac{1}{N}\\right) E_{\\mathrm{perf}}(N) = E_{\\mathrm{def}}(N-1) - \\frac{N-1}{N} E_{\\mathrm{perf}}(N)$$\n对于一个常规FCC晶胞（包含4个原子）的 $n \\times n \\times n$ 超胞，总原子数为 $N = 4n^3$。因此，使用该 $N$ 值应用此公式。此计算在恒定的超胞体积下进行，意味着不考虑空位周围的原子弛豫或胞体体积变化，这是一种常见的一阶近似。\n\n**2. 计算方法**\n\n该实现遵循对所定义物理系统的直接模拟。\n\n**FCC超胞构建**：通过将晶格参数为 $a_0 = 4.05\\,\\mathrm{\\AA}$ 的常规立方晶胞沿三个笛卡尔轴各复制 $n$ 次来构建FCC超胞。常规晶胞在分数坐标 $\\{(0,0,0), (0, \\tfrac{1}{2}, \\tfrac{1}{2}), (\\tfrac{1}{2}, 0, \\tfrac{1}{2}), (\\tfrac{1}{2}, \\tfrac{1}{2}, 0)\\}$ 处包含4个原子。最终得到的超胞是一个边长为 $L = n a_0$ 的立方盒子，包含 $N = 4n^3$ 个原子，并受周期性边界条件约束。\n\n**总能量计算**：一个原子构型的总能量通过对所有由Morse势决定的对相互作用求和来计算：\n$$V(r) = D\\left(e^{-2 a (r - r_0)} - 2 e^{-a (r - r_0)}\\right)$$\n参数为 $D = 0.35\\,\\mathrm{eV}$，$a = 1.2\\,\\mathrm{\\AA^{-1}}$ 和 $r_0 = a_0/\\sqrt{2}\\,\\mathrm{\\AA}$。一个原子系统的总能量 $E_{\\mathrm{total}}$ 为：\n$$E_{\\mathrm{total}} = \\sum_{i<j, r_{ij} < r_c} V(r_{ij})$$\n其中 $r_{ij}$ 是原子 $i$ 和 $j$ 之间的距离，通过应用最小镜像约定在周期性边界条件下计算得出。$r_c = 8.0\\,\\mathrm{\\AA}$ 是相互作用的截断半径。\n\n**3. 收敛性讨论**\n\n$E_f(n)$ 对超胞尺寸 $n$ 的依赖性源于有限尺寸效应。主要贡献来自：\n1.  **弹性相互作用**：在真实材料中，空位周围的原子会弛豫，产生一个应力场。在周期性超胞中，这个应力场会与其周期性镜像相互作用。根据弹性理论，这种相互作用能随超胞尺寸以 $L^{-3}$（即 $n^{-3}$）的量级衰减。\n2.  **电子相互作用**：对于金属，缺陷会改变局域电子密度，这种扰动通过导带电子被屏蔽。屏蔽是不完美的，导致剩余的缺陷-镜像相互作用，其衰减速度通常也与 $n^{-1}$ 到 $n^{-3}$ 有关，具体取决于系统的维度和性质。对于绝缘体，缺陷可能带电，导致更长程的 $n^{-1}$ 库仑相互作用。\n3.  **直接相互作用**：如果截断半径 $r_c$ 相对于超胞尺寸 $L$ 不够小，一个原子可能会直接与其周期性镜像相互作用。然而，问题中 $n=1$ 时 $L=4.05\\AA$，而 $r_c=8.0\\AA$，这意味着 $L2r_c$。因此，对于小 $n$ 值，原子可能会与其在相邻镜像胞中的镜像相互作用，这是有限尺寸效应的另一个来源。\n\n综合来看，$E_f(n)$ 与 $E_f(\\infty)$（无限大胞体极限）之间的偏差预计会随着 $n$ 的增加而减小，通常遵循 $C/n^3$ 或其他类似的幂律关系。因此，通过计算一系列增大的 $n$ 值的 $E_f(n)$ 并进行外推，可以得到收敛的空位形成能。\n\n**4. 实现细节**\n\n代码将为每个 $n \\in \\{1, 2, 3, 4\\}$ 迭代：\n- 生成包含 $N=4n^3$ 个原子的理想超胞原子坐标。\n- 计算其总能量 $E_{\\mathrm{perf}}(n)$。\n- 移除离盒子中心最近的原子，得到包含 $N-1$ 个原子的缺陷超胞。\n- 计算其总能量 $E_{\\mathrm{def}}(n)$。\n- 使用推导出的公式 $E_f(n) = E_{\\mathrm{def}}(n) - \\frac{N-1}{N} E_{\\mathrm{perf}}(n)$ 计算空位形成能。\n- 将结果存储并按要求格式化输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the vacancy formation energy in FCC aluminum for various supercell sizes\n    using a Morse pair potential and a fixed-volume supercell approach.\n    \"\"\"\n\n    # --- Problem Constants and Parameters ---\n    A0 = 4.05  # Lattice parameter in Angstroms\n    D_MORSE = 0.35  # Morse parameter D in eV\n    A_MORSE = 1.2   # Morse parameter a in Angstrom^-1\n    RC = 8.0     # Cutoff radius in Angstroms\n    R0_MORSE = A0 / np.sqrt(2.0)  # Morse parameter r0 in Angstroms\n\n    # --- Test Suite ---\n    N_REPLICATIONS = [1, 2, 3, 4]\n\n    # --- FCC Lattice Basis ---\n    # Basis vectors in fractional coordinates for a conventional cell\n    fcc_basis_frac = np.array([\n        [0.0, 0.0, 0.0],\n        [0.0, 0.5, 0.5],\n        [0.5, 0.0, 0.5],\n        [0.5, 0.5, 0.0]\n    ])\n    # Basis vectors in Cartesian coordinates\n    fcc_basis_cart = fcc_basis_frac * A0\n\n    def calculate_total_energy(positions, L, rc, D, a_p, r0):\n        \"\"\"\n        Calculates the total potential energy of a system of atoms using a Morse potential.\n        \n        Args:\n            positions (np.ndarray): Array of atomic positions (num_atoms, 3).\n            L (float): Side length of the cubic simulation box.\n            rc (float): Cutoff radius for the pair potential.\n            D, a_p, r0 (float): Morse potential parameters.\n        \n        Returns:\n            float: Total potential energy of the system in eV.\n        \"\"\"\n        num_atoms = positions.shape[0]\n        total_energy = 0.0\n        rc_sq = rc * rc\n\n        for i in range(num_atoms):\n            for j in range(i + 1, num_atoms):\n                # Calculate displacement vector between atom i and atom j\n                dr = positions[i] - positions[j]\n                \n                # Apply Minimum Image Convention for periodic boundary conditions\n                dr -= L * np.rint(dr / L)\n                \n                r_sq = np.dot(dr, dr)\n                \n                # Check if the pair is within the cutoff radius\n                if r_sq  rc_sq:\n                    r = np.sqrt(r_sq)\n                    # The r > 0 check is implicitly handled by the j > i loop\n                    exp_term = np.exp(-a_p * (r - r0))\n                    pair_energy = D * (exp_term**2 - 2.0 * exp_term)\n                    total_energy += pair_energy\n        return total_energy\n\n    vacancy_formation_energies = []\n\n    for n in N_REPLICATIONS:\n        # 1. Construct the perfect supercell by replicating the conventional cell\n        L = n * A0  # Supercell box length\n        \n        perfect_positions = []\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    # Translation vector for this replica of the conventional cell\n                    translation = np.array([i, j, k]) * A0\n                    for basis_pos in fcc_basis_cart:\n                        perfect_positions.append(basis_pos + translation)\n        \n        perfect_positions = np.array(perfect_positions)\n        N = perfect_positions.shape[0]\n        \n        # 2. Calculate the total energy of the perfect supercell, E_perf(n)\n        E_perf = calculate_total_energy(perfect_positions, L, RC, D_MORSE, A_MORSE, R0_MORSE)\n        \n        # 3. Create a vacancy by removing the atom closest to the box center\n        box_center = np.array([L/2.0, L/2.0, L/2.0])\n        \n        # Find the index of the atom to remove\n        distances_to_center = np.linalg.norm(perfect_positions - box_center, axis=1)\n        idx_to_remove = np.argmin(distances_to_center)\n        \n        # Create the defective positions array by removing the identified atom\n        defective_positions = np.delete(perfect_positions, idx_to_remove, axis=0)\n\n        # 4. Calculate the total energy of the defective supercell, E_def(n)\n        E_def = calculate_total_energy(defective_positions, L, RC, D_MORSE, A_MORSE, R0_MORSE)\n\n        # 5. Calculate the vacancy formation energy E_f(n) using the derived formula\n        if N > 0:\n            E_f = E_def - ((N - 1) / N) * E_perf\n        else:\n            E_f = 0.0 # This case will not be reached for n >= 1\n        \n        vacancy_formation_energies.append(E_f)\n\n    # 6. Format and print the final output as specified\n    # The results are rounded to three decimal places.\n    formatted_results = [f\"{val:.3f}\" for val in vacancy_formation_energies]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function to solve the problem\nsolve()\n```", "id": "3458666"}, {"introduction": "计算得出的原子位置和能量固然强大，但将其与化学概念联系起来进行解读也同样重要。本练习旨在通过校准键价和（Bond Valence Sum）模型，搭建起量子力学计算与传统化学直觉之间的桥梁[@problem_id:3458658]。您将利用一组经DFT优化的结构数据来确定模型参数，并用其预测和验证复杂氧化物中的氧化态，这是材料表征中的一项常见任务。", "problem": "您的任务是开发并验证一个用于混合价态复杂氧化物中键价的计算模型，该模型需从与固态物理导论概念和化学键合一致的第一性原理出发。核心要求是校准一个基于参考长度的双参数映射，该映射将距离映射到键价，并用它来验证通过密度泛函理论（DFT）优化的局部环境所得出的氧化态。推导必须基于以下基本原则：价态的可加性，即价态是单个键序的总和；每个键序都是无量纲的，并随键长的增加而单调递减；存在一个参考键长；以及需要一对普适参数来描述给定数据集中3d过渡金属阳离子与氧之间的键合。\n\n您的程序必须实现一个校准过程，通过最小化在科学上合理的、经DFT优化的局部环境训练数据集上，预测价态总和与给定目标氧化态之间的偏差平方和，来确定参数对 $(R_0, b)$。校准后，将该模型应用于一个测试集，以预测氧化态并验证局部键合环境。所有距离都必须视为以埃（Ångström）为单位的物理量，所有价态均为无量纲。您必须以埃（Ångström）为单位表示 $R_0$ 和 $b$，并将它们四舍五入到4位小数。测试集的预测氧化态必须四舍五入到3位小数。验证布尔值应通过检查预测价态与目标氧化态之间的绝对偏差是否小于或等于容差 $\\tau$ 来计算，容差 $\\tau$ 在价态单位下设为 $\\tau = 0.2$。\n\n使用以下DFT优化的阳离子环境训练数据集，每个环境由一组阳离子-氧距离（单位为埃）和一个整数氧化态定义：\n\n- 环境 A（标称$+3$氧化态，八面体）：距离 $[1.98, 2.01, 1.99, 2.00, 2.02, 2.00]$，目标价态 $3$。\n- 环境 B（标称$+2$氧化态，八面体）：距离 $[2.13, 2.17, 2.15, 2.14, 2.16, 2.15]$，目标价态 $2$。\n- 环境 C（标称$+4$氧化态，八面体）：距离 $[1.90, 1.89, 1.91, 1.92, 1.90, 1.89]$，目标价态 $4$。\n- 环境 D（标称$+3$氧化态，Jahn-Teller畸变八面体）：距离 $[1.92, 1.93, 1.91, 1.94, 2.17, 2.18]$，目标价态 $3$。\n- 环境 E（标称$+3$氧化态，八面体）：距离 $[1.91, 1.92, 1.93, 1.90, 1.91, 1.92]$，目标价态 $3$。\n- 环境 F（标称$+2$氧化态，八面体）：距离 $[2.05, 2.06, 2.04, 2.07, 2.05, 2.06]$，目标价态 $2$。\n\n您的程序必须通过最小化预测价态总和与给定目标价态之间的偏差平方和，从上述训练数据集中校准 $(R_0, b)$。校准后的 $(R_0, b)$ 必须满足 $R_0  0$ 和 $b  0$，并保持在与氧键合的3d过渡金属阳离子的物理合理范围内；将 $R_0$ 限制在区间 $[1.40, 2.00]$ Å，将 $b$ 限制在 $[0.20, 0.60]$ Å。\n\n校准后，使用以下测试集进行验证（所有距离单位均为埃）。对于每个测试用例，计算预测价态，四舍五入到3位小数，并确定它是否在目标氧化态的 $\\tau = 0.2$ 容差范围内（输出一个布尔值）：\n\n- 测试用例 $1$（八面体，标称$+3$）：$[2.00, 2.00, 2.00, 2.00, 2.00, 2.00]$，目标价态 $3$。\n- 测试用例 $2$（八面体，标称$+2$）：$[2.12, 2.14, 2.15, 2.16, 2.17, 2.18]$，目标价态 $2$。\n- 测试用例 $3$（畸变八面体，混合短键和长键，标称$+3.5$）：$[1.88, 1.90, 1.91, 1.92, 2.10, 2.12]$，目标价态 $3.5$。\n- 测试用例 $4$（五配位，标称$+3$）：$[1.94, 1.95, 1.96, 1.97, 1.98]$，目标价态 $3$。\n- 测试用例 $5$（四面体配位，标称$+3$）：$[1.84, 1.86, 1.87, 1.85]$，目标价态 $3$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含：校准后的 $R_0$（单位Å，四舍五入到4位小数），校准后的 $b$（单位Å，四舍五入到4位小数），然后是每个测试用例的预测价态（四舍五入到3位小数）和验证布尔值。因此，输出的形式应为 $[R_0,b,v_1,\\mathrm{ok}_1,v_2,\\mathrm{ok}_2,v_3,\\mathrm{ok}_3,v_4,\\mathrm{ok}_4,v_5,\\mathrm{ok}_5]$。本问题不使用角度。不出现百分比；所有量均为无量纲数或以埃（Ångström）为单位的长度。", "solution": "用户提供的问题陈述已被评估并确定为有效。该问题在科学上基于固态化学和材料科学中广泛应用的键价和（Bond Valence Sum, BVS）模型。该问题定义明确，为一个数值优化任务提供了完整的数据集、约束条件和明确的目标。其语言客观，要求可以形式化为一个可解的计算问题。\n\n该问题要求校准并应用一个键价模型。其基本原理是，中心阳离子的形式氧化态（或价态 $V$）可以通过对其与相邻阴离子的每个键的“价” $s_i$ 求和来近似。单个键的价 $s_i$ 是其键长 $R_i$ 的函数。问题指定了一个双参数模型，该模型与BVS模型的标准指数形式一致：\n$$ s_i(R_i; R_0, b) = \\exp\\left(\\frac{R_0 - R_i}{b}\\right) $$\n在此式中，$s_i$ 是键 $i$ 的无量纲价，$R_i$ 是键 $i$ 的长度（单位为埃，Å），$R_0$ 是单位价键的参考键长，$b$ 是一个“软度”参数，两者的单位也都是 Å。\n\n对于处于环境 $j$ 中、具有多个键长 $\\{R_{ij}\\}$ 的阳离子，其总价态和 $V_j^{\\text{pred}}$ 是对其所有键的求和：\n$$ V_j^{\\text{pred}}(R_0, b) = \\sum_{i} s_{ij} = \\sum_{i} \\exp\\left(\\frac{R_0 - R_{ij}}{b}\\right) $$\n\n第一个任务是使用提供的DFT优化训练数据集，为3d过渡金属-氧键校准普适参数 $(R_0, b)$。这是一个参数拟合问题。我们的目标是找到能最好地再现给定训练环境下已知目标价态 $V_j^{\\text{target}}$ 的 $R_0$ 和 $b$ 值。这通过最小化一个目标函数来实现，该目标函数定义为训练集中所有 $N$ 个环境下，预测价态总和与目标价态之间的误差（或偏差）平方和：\n$$ \\mathcal{L}(R_0, b) = \\sum_{j=1}^{N} \\left( V_j^{\\text{pred}}(R_0, b) - V_j^{\\text{target}} \\right)^2 $$\n最小化必须在指定的物理边界条件下进行：$R_0 \\in [1.40, 2.00]$ Å 和 $b \\in [0.20, 0.60]$ Å。\n\n这是一个二维的非线性有界优化问题。我们将采用数值优化算法来寻找 $\\mathcal{L}(R_0, b)$ 的最小值。具体来说，我们使用 `scipy.optimize` 库中的 `minimize` 函数，该库为此类任务提供了稳健的算法。L-BFGS-B（带箱式约束的有限内存Broyden–Fletcher–Goldfarb–Shanno）方法非常适合此目的。需要一个在规定边界内的 $(R_0, b)$ 初始猜测值来启动优化过程。此次优化的结果将是校准后的参数对 $(R_0^*, b^*)$。这些值将四舍五入到4位小数进行报告。\n\n第二个任务是将校准后的模型应用于一组配位环境测试集。使用确定的参数 $(R_0^*, b^*)$，我们计算每个测试用例 $k$ 的预测价态总和 $V_k^{\\text{pred}}$：\n$$ V_k^{\\text{pred}} = \\sum_{i} \\exp\\left(\\frac{R_0^* - R_{ik}}{b^*}\\right) $$\n计算出的 $V_k^{\\text{pred}}$ 随后四舍五入到3位小数。\n\n最后，对每个测试用例，我们执行一次验证检查。如果预测价态与目标价态之间的绝对差值在指定的容差 $\\tau$ 之内，则模型的预测被认为是有效的。问题定义了 $\\tau=0.2$。因此，测试用例 $k$ 的验证检查是对以下条件的布尔求值：\n$$ |V_k^{\\text{pred}} - V_k^{\\text{target}}| \\le \\tau $$\n注意：为确保验证步骤中的最高精度，比较是在未四舍五入的预测价态和目标价态之间进行的。\n\n最终输出是校准参数和测试集结果的集合，按规定格式化为单个逗号分隔的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Calibrates Bond Valence Sum parameters (R0, b) from a training dataset\n    and applies the calibrated model to a test suite.\n    \"\"\"\n    \n    # Define the training dataset from the problem statement.\n    # Each entry is a tuple: (list of cation-oxygen distances in Å, target integer oxidation state).\n    training_data = [\n        ([1.98, 2.01, 1.99, 2.00, 2.02, 2.00], 3),  # Environment A\n        ([2.13, 2.17, 2.15, 2.14, 2.16, 2.15], 2),  # Environment B\n        ([1.90, 1.89, 1.91, 1.92, 1.90, 1.89], 4),  # Environment C\n        ([1.92, 1.93, 1.91, 1.94, 2.17, 2.18], 3),  # Environment D\n        ([1.91, 1.92, 1.93, 1.90, 1.91, 1.92], 3),  # Environment E\n        ([2.05, 2.06, 2.04, 2.07, 2.05, 2.06], 2),  # Environment F\n    ]\n\n    def objective_function(params):\n        \"\"\"\n        Calculates the sum of squared errors between predicted valence sums\n        and target valences for the training dataset.\n        \n        Args:\n            params (list or tuple): A list [R0, b] of the parameters to optimize.\n            \n        Returns:\n            float: The sum of squared errors.\n        \"\"\"\n        R0, b = params\n        sse = 0.0\n        for distances, target_valence in training_data:\n            distances_arr = np.array(distances)\n            bond_valences = np.exp((R0 - distances_arr) / b)\n            predicted_valence_sum = np.sum(bond_valences)\n            sse += (predicted_valence_sum - target_valence)**2\n        return sse\n\n    # Define bounds and initial guess for the optimization.\n    bounds = [(1.40, 2.00), (0.20, 0.60)]\n    initial_guess = [1.70, 0.40] # A point in the middle of the search space.\n\n    # Perform the minimization.\n    result = minimize(\n        objective_function,\n        initial_guess,\n        method='L-BFGS-B',\n        bounds=bounds\n    )\n\n    # Extract and round the calibrated parameters.\n    R0_calibrated, b_calibrated = result.x\n    R0_rounded = round(R0_calibrated, 4)\n    b_rounded = round(b_calibrated, 4)\n\n    # Define the test suite and validation tolerance.\n    test_suite = [\n        # (list of distances, target valence)\n        ([2.00, 2.00, 2.00, 2.00, 2.00, 2.00], 3.0),\n        ([2.12, 2.14, 2.15, 2.16, 2.17, 2.18], 2.0),\n        ([1.88, 1.90, 1.91, 1.92, 2.10, 2.12], 3.5),\n        ([1.94, 1.95, 1.96, 1.97, 1.98], 3.0),\n        ([1.84, 1.86, 1.87, 1.85], 3.0),\n    ]\n    tolerance = 0.2\n\n    # Container for all final results.\n    final_results = [R0_rounded, b_rounded]\n\n    # Apply the calibrated model to the test suite.\n    for distances, target_valence in test_suite:\n        distances_arr = np.array(distances)\n        # Use un-rounded parameters for calculation to maintain precision.\n        bond_valences = np.exp((R0_calibrated - distances_arr) / b_calibrated)\n        predicted_valence_sum = np.sum(bond_valences)\n        \n        # Round the predicted valence for output.\n        valence_rounded = round(predicted_valence_sum, 3)\n        \n        # Perform validation check using the un-rounded predicted valence.\n        is_valid = abs(predicted_valence_sum - target_valence) = tolerance\n        \n        # Append results for this test case.\n        final_results.extend([valence_rounded, is_valid])\n\n    # Format the final output as a single comma-separated list string.\n    # Python's str() for booleans produces \"True\" and \"False\", which is acceptable.\n    output_string = f\"[{','.join(map(str, final_results))}]\"\n\n    # Final print statement in the exact required format.\n    print(output_string)\n\nsolve()\n```", "id": "3458658"}]}