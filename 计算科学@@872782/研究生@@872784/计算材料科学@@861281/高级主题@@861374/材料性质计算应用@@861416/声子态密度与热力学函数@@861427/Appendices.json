{"hands_on_practices": [{"introduction": "任何可靠的计算研究都始于一个关键步骤：确保数值结果的收敛性。从声子色散关系计算热力学性质，核心在于对布里渊区（Brillouin zone）的积分，而积分的准确性直接取决于所用 $\\mathbf{q}$ 点网格的密度。这个练习将带你亲手实践如何系统地分析积分结果（如内能和热容）随网格密度的收敛行为，这是评估计算精度和成本效益的基本功，也是计算材料科学家必须掌握的核心技能之一。[@problem_id:3477074]", "problem": "你需要编写一个完整的、可运行的程序，数值研究声子态密度及派生的热力学积分，相对于简立方晶格第一布里渊区 (BZ) 中均匀波矢网格密度的收敛性。目标是量化对于光滑被积函数，数值误差如何随网格间距缩放。\n\n使用以下物理上自洽且计算上可行的设置。\n\n1. 考虑在简立方布里渊区 (BZ) 上的一个具有光滑带隙色散的单支光学声子。设波矢域为 $$\\mathbf{q}\\in[-\\pi,\\pi]^3,$$，角频率定义为\n$$\n\\omega(\\mathbf{q}) = \\sqrt{\\omega_0^2 + v^2\\left[\\sin^2\\left(\\frac{q_x}{2}\\right) + \\sin^2\\left(\\frac{q_y}{2}\\right) + \\sin^2\\left(\\frac{q_z}{2}\\right)\\right]},\n$$\n参数为 $$\\omega_0 = 0.4$$ 和 $$v = 1.0$$。所有角度必须以弧度处理。使用约化单位，其中约化普朗克常数 $$\\hbar = 1$$，玻尔兹曼常数 $$k_B = 1$$，因此频率和温度是无量纲的。\n\n2. 声子态密度 $$g(\\omega)$$ 定义为 $$\\omega(\\mathbf{q})$$ 在布里渊区上的归一化分布，使得\n$$\n\\int g(\\omega)\\,d\\omega = 1.\n$$\n通过在均匀网格上采样的 $$\\omega(\\mathbf{q})$$ 的直方图来近似 $$g(\\omega)$$，在 $$[\\omega_{\\min},\\omega_{\\max}]$$ 范围内使用 $$M$$ 个等距的区间（bin），其中\n$$\n\\omega_{\\min} = \\omega_0,\\quad \\omega_{\\max} = \\sqrt{\\omega_0^2 + 3v^2}.\n$$\n设置 $$M=200$$。对均匀网格使用中点采样规则：\n$$\nq_\\alpha(k) = -\\pi + \\left(k + \\frac{1}{2}\\right)\\Delta,\\quad \\Delta = \\frac{2\\pi}{N},\\quad k=0,1,\\dots,N-1,\\quad \\alpha\\in\\{x,y,z\\}.\n$$\n这里 $$N$$ 是每个方向上的点数，总波矢量数为 $$N^3$$。\n\n3. 定义玻色—爱因斯坦占据数\n$$\nn_B(\\omega,T) = \\frac{1}{\\exp\\left(\\frac{\\omega}{T}\\right) - 1},\n$$\n以及每模式内能\n$$\nU(T) = \\langle \\omega\\,n_B(\\omega,T)\\rangle_{\\mathbf{q}},\n$$\n其中 $$\\langle\\cdot\\rangle_{\\mathbf{q}}$$ 表示在 $$\\mathbf{q}$$ 的离散网格上的均匀平均。定义每模式定容热容为\n$$\nC_V(T) = \\frac{dU(T)}{dT}.\n$$\n\n4. 对于在大小为 $$N$$ 的网格上计算的每个量，定义网格间距 $$h = \\frac{2\\pi}{N}$$。使用高密度参考网格 $$N_{\\mathrm{ref}}=64$$ 来获得 $$g_{\\mathrm{ref}}(\\omega),\\,U_{\\mathrm{ref}}(T),\\,C_{V,\\mathrm{ref}}(T)$$。对于任意目标网格 $$N\\in\\{8,12,16,24,32,48\\}$$，定义数值误差度量如下：\n- 对于态密度，使用直方图区间上的 $$L^2$$ 误差：\n$$\n\\varepsilon_g(N) = \\left(\\sum_{m=1}^{M}\\left[g_N(\\omega_m) - g_{\\mathrm{ref}}(\\omega_m)\\right]^2\\,\\Delta\\omega\\right)^{1/2},\n$$\n其中 $$\\omega_m$$ 是区间的中心，$$\\Delta\\omega$$ 是均匀的区间宽度。\n- 对于内能和热容，使用绝对误差\n$$\n\\varepsilon_U(N,T) = \\left|U_N(T) - U_{\\mathrm{ref}}(T)\\right|,\\quad \\varepsilon_{C_V}(N,T) = \\left|C_{V,N}(T) - C_{V,\\mathrm{ref}}(T)\\right|.\n$$\n\n5. 估计由关系式定义的误差缩放指数 $$p$$\n$$\n\\varepsilon \\approx C\\,h^p,\n$$\n通过对 $$N$$ 值集合上的 $$\\log\\varepsilon$$ 与 $$\\log h$$ 进行线性最小二乘拟合。拟合线的斜率即为估计的 $$p$$。\n\n你的程序必须实现以上内容，并为以下参数值测试套件生成估计的指数：\n- 情况 A（正常路径）：温度 $$T=0.1$$ 时的内能。\n- 情况 B：温度 $$T=0.5$$ 时的内能。\n- 情况 C：温度 $$T=0.5$$ 时的热容。\n- 情况 D：使用 $$L^2$$ 误差的态密度 $$g(\\omega)$$。\n\n所有输出均为无量纲。角度必须以弧度为单位。输出必须是单行，包含一个用方括号括起来的逗号分隔列表，顺序为 $$[p_{U}(0.1),\\,p_{U}(0.5),\\,p_{C_V}(0.5),\\,p_{g}]$$，其中每个条目都是一个浮点数。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$$[0.0,0.0,0.0,0.0]$$）。", "solution": "用户提供了一个来自计算材料科学的问题，要求对声子相关性质相对于均匀波矢网格密度的收敛性进行数值研究。在尝试解决问题之前，需要根据一系列严格的标准对该问题进行验证。\n\n### 第 1 步：提取已知条件\n\n- **色散关系**：简立方布里渊区 $\\mathbf{q}\\in[-\\pi,\\pi]^3$ 上的单支光学声子由角频率给出：\n$$\n\\omega(\\mathbf{q}) = \\sqrt{\\omega_0^2 + v^2\\left[\\sin^2\\left(\\frac{q_x}{2}\\right) + \\sin^2\\left(\\frac{q_y}{2}\\right) + \\sin^2\\left(\\frac{q_z}{2}\\right)\\right]}\n$$\n- **参数**：$\\omega_0 = 0.4$, $v = 1.0$。\n- **常数**：约化普朗克常数 $\\hbar = 1$，玻尔兹曼常数 $k_B = 1$。角度以弧度为单位。\n- **声子态密度 (DOS)**：$g(\\omega)$ 是一个归一化分布，$\\int g(\\omega)\\,d\\omega = 1$。它通过 $\\omega(\\mathbf{q})$ 值的直方图来近似。\n- **直方图**：在 $[\\omega_{\\min},\\omega_{\\max}]$ 范围内有 $M=200$ 个等距区间，其中 $\\omega_{\\min} = \\omega_0$ 且 $\\omega_{\\max} = \\sqrt{\\omega_0^2 + 3v^2}$。\n- **波矢网格**：由中点采样规则定义的均匀网格：\n$$\nq_\\alpha(k) = -\\pi + \\left(k + \\frac{1}{2}\\right)\\Delta,\\quad \\Delta = \\frac{2\\pi}{N},\\quad k=0,1,\\dots,N-1,\\quad \\alpha\\in\\{x,y,z\\}.\n$$\n总波矢量数为 $N^3$。\n- **热力学定义**：\n    - 玻色—爱因斯坦占据数：$n_B(\\omega,T) = \\frac{1}{\\exp\\left(\\frac{\\omega}{T}\\right) - 1}$。\n    - 每模式内能：$U(T) = \\langle \\omega\\,n_B(\\omega,T)\\rangle_{\\mathbf{q}}$，其中 $\\langle\\cdot\\rangle_{\\mathbf{q}}$ 是离散网格上的均匀平均。\n    - 每模式定容热容：$C_V(T) = \\frac{dU(T)}{dT}$。\n- **误差分析**：\n    - 网格间距：$h = \\frac{2\\pi}{N}$。\n    - 参考网格：$N_{\\mathrm{ref}}=64$。\n    - 目标网格：$N \\in \\{8, 12, 16, 24, 32, 48\\}$。\n    - DOS 误差：$\\varepsilon_g(N) = \\left(\\sum_{m=1}^{M}\\left[g_N(\\omega_m) - g_{\\mathrm{ref}}(\\omega_m)\\right]^2\\,\\Delta\\omega\\right)^{1/2}$。\n    - 热力学性质误差：$\\varepsilon_U(N,T) = |U_N(T) - U_{\\mathrm{ref}}(T)|$ 和 $\\varepsilon_{C_V}(N,T) = |C_{V,N}(T) - C_{V,\\mathrm{ref}}(T)|$。\n- **收敛指数**：指数 $p$ 由 $\\varepsilon \\approx C\\,h^p$ 定义，并通过 $\\log\\varepsilon$ 对 $\\log h$ 的线性最小二乘拟合的斜率来估计。\n- **要求计算**：估计四种情况下的 $p$：(A) $U(T=0.1)$，(B) $U(T=0.5)$，(C) $C_V(T=0.5)$，和 (D) $g(\\omega)$。\n- **输出**：包含四个指数的单行逗号分隔列表：$[p_{U}(0.1),\\,p_{U}(0.5),\\,p_{C_V}(0.5),\\,p_{g}]$。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n- **科学依据**：该问题是计算凝聚态物理学中的一个标准数值练习。声子色散关系是一个简化但物理上合理的模型。态密度、玻色—爱因斯坦统计、内能和热容的定义都是标准且正确的。\n- **适定性**：该问题以数学精度进行了规定。所有必要的常数、函数和数值过程（网格生成、平均、误差计算、拟合）都已明确定义。任务是执行这个定义明确的数值实验并报告结果。对于所描述的过程，保证存在一个唯一且有意义的解（收敛指数集）。\n- **客观性**：问题陈述完全是定量的和数学的，没有任何主观或模棱两可的语言。\n\n该问题不违反任何无效标准。它在科学上是合理的，形式上是明确的，并且在计算上是可行的。内能和热容的被积函数是关于波矢 $\\mathbf{q}$ 的光滑周期函数。对于此类函数，已知中点规则（即指定的网格采样方法）具有很高的准确性。布里渊区积分的误差由 Euler-Maclaurin 公式决定，该公式预测主要误差项随网格间距 $h$ 以 $h^2$ 的形式缩放。因此，我们预计 $U(T)$ 和 $C_V(T)$ 的收敛指数 $p \\approx 2$。然而，已知态密度 $g(\\omega)$ 包含不可微的特征（van Hove 奇点），其中 $\\nabla_{\\mathbf{q}}\\omega = \\mathbf{0}$。非光滑函数或其分布的数值近似预计收敛较慢，导致较小的指数 $p$。该问题为探索这种对比提供了良好的设定。\n\n### 第 3 步：结论与行动\n\n问题陈述是**有效的**。将提供一个解决方案。\n\n### 基于原则的设计\n\n该解决方案将作为一个遵循指定环境的 Python 程序来实现。程序的核心是一个函数，用于计算给定网格密度 $N$ 下感兴趣的物理性质。该函数封装了物理模型和数值方法。\n\n1.  **波矢网格与色散**：对于给定的网格大小 $N$，使用指定的中点规则在第一布里渊区 $[-\\pi, \\pi]^3$ 中生成一个三维均匀波矢 $\\mathbf{q}$ 网格。然后，利用 NumPy 的矢量化操作为网格上的每个点计算声子频率 $\\omega(\\mathbf{q})$，以提高效率。\n\n2.  **态密度 (DOS)**：使用一个具有 $M=200$ 个区间的直方图，在解析确定的频率范围 $[\\omega_{\\min}, \\omega_{\\max}]$ 内计算出所计算的 $\\omega(\\mathbf{q})$ 值的分布。该直方图被归一化以表示概率密度函数，满足 $\\int g(\\omega) d\\omega = 1$。\n\n3.  **热力学平均**：内能 $U(T)$ 和热容 $C_V(T)$ 作为 $N^3$ 个离散波矢点上的平均值进行计算。\n    - 内能的被积函数是 $f_U = \\omega \\, n_B(\\omega, T)$。\n    - 热容为 $C_V(T) = dU/dT$。在进行数值平均之前，对被积函数进行解析微分：\n      $$\n      C_V(T) = \\left\\langle \\frac{d}{dT} \\left(\\omega \\, n_B(\\omega, T)\\right) \\right\\rangle_{\\mathbf{q}} = \\left\\langle \\omega \\frac{d n_B}{dT} \\right\\rangle_{\\mathbf{q}}\n      $$\n      其中\n      $$\n      \\frac{d n_B(\\omega, T)}{dT} = \\frac{\\omega}{T^2} \\frac{\\exp(\\omega/T)}{[\\exp(\\omega/T) - 1]^2}\n      $$\n    这两项计算都作为对 $\\omega$ 值数组的 NumPy 矢量化操作来实现。\n\n4.  **误差计算与收敛性分析**：\n    - 使用 $N_{\\mathrm{ref}}=64$ 进行高密度参考计算。\n    - 对于一系列较粗的网格尺寸 $N \\in \\{8, 12, 16, 24, 32, 48\\}$，重新计算这些性质，并根据指定的误差度量计算相对于参考值的误差（$\\varepsilon_g$, $\\varepsilon_U$, $\\varepsilon_{C_V}$）。\n    - 收敛指数 $p$ 由关系式 $\\varepsilon \\approx C h^p$ 决定，该关系式线性化为 $\\log\\varepsilon \\approx \\log C + p \\log h$。对误差的对数与网格间距 $h=2\\pi/N$ 的对数进行线性最小二乘拟合。该拟合的斜率即为所需的指数 $p$。这通过使用 `numpy.polyfit` 来完成。\n\n这种结构化的方法确保了计算完全按照规定执行，从而确定所要求的四个收敛指数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically investigates the convergence of phonon properties with respect to\n    k-point mesh density, calculates convergence exponents, and prints the result.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    omega_0 = 0.4\n    v = 1.0\n    M = 200  # Number of histogram bins for DOS\n\n    # --- Mesh Definitions ---\n    N_ref = 64\n    N_vals = np.array([8, 12, 16, 24, 32, 48])\n    T_cases = {'U': [0.1, 0.5], 'Cv': [0.5]}\n\n    # --- Frequency range for DOS histogram ---\n    omega_min = omega_0\n    omega_max = np.sqrt(omega_0**2 + 3.0 * v**2)\n    omega_bins = np.linspace(omega_min, omega_max, M + 1)\n    delta_omega = (omega_max - omega_min) / M\n\n    def compute_properties(N, temperatures):\n        \"\"\"\n        Calculates phonon DOS, internal energy, and heat capacity for a given\n        mesh size N.\n        \n        Args:\n            N (int): Number of q-points per dimension.\n            temperatures (dict): Dictionary with keys 'U' and 'Cv' holding\n                                 lists of temperatures to compute.\n        \n        Returns:\n            dict: A dictionary containing the computed properties.\n        \"\"\"\n        # 1. Generate q-mesh and compute omega(q)\n        delta_q = 2.0 * np.pi / N\n        q_1d = -np.pi + (np.arange(N) + 0.5) * delta_q\n        qx, qy, qz = np.meshgrid(q_1d, q_1d, q_1d, indexing='ij')\n\n        omega_q_sq_term = np.sin(qx / 2.0)**2 + np.sin(qy / 2.0)**2 + np.sin(qz / 2.0)**2\n        omega_vals = np.sqrt(omega_0**2 + v**2 * omega_q_sq_term)\n        omega_flat = omega_vals.flatten()\n\n        results = {}\n\n        # 2. Compute DOS histogram\n        dos, _ = np.histogram(omega_flat, bins=omega_bins, density=True)\n        results['dos'] = dos\n\n        # 3. Compute thermodynamic properties\n        with np.errstate(over='ignore'): # exp can overflow for large omega/T\n            for T in temperatures.get('U', []):\n                # Using a numerically stable check for large arguments\n                exp_arg = omega_flat / T\n                exp_term = np.exp(exp_arg)\n                n_b = np.divide(1.0, exp_term - 1.0, where=(exp_term > 1.0))\n                U = np.mean(omega_flat * n_b)\n                results[f'U_{T}'] = U\n\n            for T in temperatures.get('Cv', []):\n                exp_arg = omega_flat / T\n                exp_term = np.exp(exp_arg)\n                # Handle potential division by zero if exp_term is 1\n                denom = (exp_term - 1.0)**2\n                # Calculate integrand, setting it to 0 where denom is 0\n                cv_integrand = np.divide(\n                    (omega_flat**2 / T**2) * exp_term,\n                    denom,\n                    out=np.zeros_like(denom),\n                    where=(denom != 0)\n                )\n                Cv = np.mean(cv_integrand)\n                results[f'Cv_{T}'] = Cv\n                \n        return results\n\n    # --- Main Calculation Logic ---\n\n    # 1. Compute high-resolution reference values\n    ref_data = compute_properties(N_ref, T_cases)\n\n    # 2. Loop over target meshes to compute errors\n    h_vals = 2.0 * np.pi / N_vals\n    errors = {\n        'U_0.1': [],\n        'U_0.5': [],\n        'Cv_0.5': [],\n        'dos': []\n    }\n\n    for N in N_vals:\n        current_data = compute_properties(N, T_cases)\n\n        # DOS L2 error\n        err_g = np.sqrt(np.sum((current_data['dos'] - ref_data['dos'])**2) * delta_omega)\n        errors['dos'].append(err_g)\n\n        # Internal energy errors\n        errors['U_0.1'].append(np.abs(current_data['U_0.1'] - ref_data['U_0.1']))\n        errors['U_0.5'].append(np.abs(current_data['U_0.5'] - ref_data['U_0.5']))\n\n        # Heat capacity error\n        errors['Cv_0.5'].append(np.abs(current_data['Cv_0.5'] - ref_data['Cv_0.5']))\n\n    # 3. Perform linear fits to get convergence exponents\n    log_h = np.log(h_vals)\n    exponents = {}\n    \n    # Filter out zero errors before taking log for fitting\n    for key, err_list in errors.items():\n        valid_indices = [i for i, e in enumerate(err_list) if e > 0]\n        if len(valid_indices) < 2:\n            # Not enough points for a fit, assign NaN or a sensible default\n            p = np.nan\n        else:\n            log_err = np.log(np.array(err_list)[valid_indices])\n            log_h_fit = log_h[valid_indices]\n            p, _ = np.polyfit(log_h_fit, log_err, 1)\n        exponents[key] = p\n\n    # 4. Format and print the final output\n    # Order: [p_U(0.1), p_U(0.5), p_CV(0.5), p_g]\n    final_results = [\n        exponents['U_0.1'],\n        exponents['U_0.5'],\n        exponents['Cv_0.5'],\n        exponents['dos']\n    ]\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3477074"}, {"introduction": "声子态密度不仅仅是一个抽象的物理量，更是连接微观振动与宏观热力学的桥梁。这个练习将展示如何利用声子态密度 $g(\\omega)$ 来计算晶体的亥姆霍兹自由能 $F_{\\mathrm{vib}}(T)$ 和吉布斯自由能 $G(T,P)$。通过比较不同晶体结构（多晶型）的自由能，你将能预测在给定温度和压力下哪一个相更为稳定，甚至确定相变发生的温度，这体现了从第一性原理预测材料相图的核心思想。[@problem_id:3477028]", "problem": "给定两种晶体多形体，分别标记为相 $A$ 和相 $B$，每种多形体都由一个振动声子态密度 (DoS) 函数 $g(\\omega)$ 描述，该函数是角频率 $\\omega$ 的函数。振动声子态密度的定义满足每个化学式单元包含 $\\int_{0}^{\\infty} g(\\omega)\\,d\\omega = 3n$ 个模式，其中 $n$ 是每个化学式单元中的原子数。假设 $n=1$。在谐波近似下，绝对温度为 $T$ 时每个化学式单元的振动亥姆霍兹自由能由以下公式定义\n$$\nF_{\\mathrm{vib}}(T) = \\int_{0}^{\\infty} g(\\omega)\\left[\\tfrac{1}{2}\\hbar\\omega + k_{\\mathrm{B}}T\\ln\\!\\left(1 - e^{-\\hbar\\omega/(k_{\\mathrm{B}}T)}\\right)\\right]\\,d\\omega,\n$$\n其中需要理解的是，当 $T=0$ 时，第二项消失，且 $F_{\\mathrm{vib}}(0)=\\int_{0}^{\\infty} g(\\omega)\\,\\tfrac{1}{2}\\hbar\\omega\\,d\\omega$。在固定压力 $P$ 下，吉布斯自由能近似为\n$$\nG(T,P) = E_{0} + F_{\\mathrm{vib}}(T) + PV,\n$$\n其中 $E_{0}$ 是 $T=0$ 时的静态晶格内能（不包括振动零点贡献），$V$ 是每个化学式单元的体积，两者均为特定相的参数。物理常数为普朗克约化常数 $\\hbar$ 和玻尔兹曼常数 $k_{\\mathrm{B}}$。请始终使用国际单位制 (SI)，中间步骤中的能量单位为焦耳，并按下文指示以电子伏特 (eV) 每化学式单元报告指定输出。\n\n对于无需外部输入的数值实现，将每个 $g(\\omega)$ 建模为对数正态分量的加权和，\n$$\ng(\\omega) = \\sum_{i=1}^{m} w_{i}\\,\\phi(\\omega;\\mu_{i},\\sigma_{i}),\\quad\n\\phi(\\omega;\\mu,\\sigma) = \\frac{1}{\\omega\\,\\sigma\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(\\ln\\omega - \\mu)^{2}}{2\\sigma^{2}}\\right),\\quad \\omega>0,\n$$\n其中每个分量在 $(0,\\infty)$ 上归一化为1，$w_{i}$ 是分量权重。对数参数 $\\mu_{i}$ 和 $\\sigma_{i}$ 与指定的中值角频率相关，关系为 $\\mu_{i} = \\ln \\omega_{i}^{\\mathrm{med}}$，其中 $\\sigma_{i}>0$ 控制谱宽。为方便起见，下面的测试套件通过循环频率 $f_{i}$（单位为太赫兹）指定中值，其与角频率的关系为 $\\omega_{i}^{\\mathrm{med}} = 2\\pi f_{i}\\times 10^{12}\\,\\mathrm{rad/s}$。构建后，对每个 $g(\\omega)$ 进行数值重新归一化，以使 $\\int_{0}^{\\infty} g(\\omega)\\,d\\omega = 3$，从而满足 $n=1$ 时的模式数要求。\n\n任务。对于测试套件中的每个测试用例，计算两个量：\n1. 在指定评估温度 $T_{\\mathrm{eval}}$ 下的振动亥姆霍兹自由能差，定义为 $\\Delta F_{\\mathrm{vib}}(T_{\\mathrm{eval}}) = F_{\\mathrm{vib}}^{(B)}(T_{\\mathrm{eval}}) - F_{\\mathrm{vib}}^{(A)}(T_{\\mathrm{eval}})$，以每个化学式单元的 $\\mathrm{eV}$ 为单位，表示为浮点数。\n2. 吉布斯自由能相等的最小非负温度 $T_{\\mathrm{tr}}$（单位为 $\\mathrm{K}$），即满足 $\\Delta G(T) = G^{(B)}(T,P)-G^{(A)}(T,P) = 0$ 的最小 $T\\ge 0$。如果在采样范围内 $\\Delta G(T)$ 在数值上与零无法区分（见下文数值公差要求），则报告 $T_{\\mathrm{tr}}=0$。如果在闭区间 $[0, T_{\\max}]$ 内不存在这样的温度，则报告 $T_{\\mathrm{tr}}=-1$ 作为浮点哨兵值。\n\n使用单一、一致的数值方案，在有限角频率网格 $(\\omega_{j})_{j=1}^{N}$ 上评估定义 $F_{\\mathrm{vib}}(T)$ 的积分。该网格应覆盖当前情况下指定对数正态分量的支撑集，并具有足够的分辨率以确保在 $[0,T_{\\max}]$ 中采样的所有温度下数值稳定。对于 $T>0$，使用数值稳定的公式来评估包含对数的积分项。通过零点极限显式处理 $T=0$ 的情况。对于求根，在 $[0,T_{\\max}]$ 的温度网格上搜索 $\\Delta G(T)$ 的符号变化，然后使用稳健的区间法（bracketing method）进行优化，以找到存在的最小根。使用 $T_{\\max} = 2000\\,\\mathrm{K}$。\n\n单位和数值要求。\n- 将 $\\Delta F_{\\mathrm{vib}}(T_{\\mathrm{eval}})$ 以每个化学式单元的 $\\mathrm{eV}$ 为单位、将 $T_{\\mathrm{tr}}$ 以 $\\mathrm{K}$ 为单位，表示为浮点数。\n- 对所有测试用例使用 $T_{\\mathrm{eval}}=300\\,\\mathrm{K}$。\n- 当评估 $\\max_{T\\in[0,T_{\\max}]}|\\Delta G(T)|$ 是否有效为零时，使用 $\\varepsilon = 10^{-6}\\,\\mathrm{eV}$ 的数值公差来判断“数值上与零无法区分”；在这种情况下返回 $T_{\\mathrm{tr}}=0$。\n- 如果没有发生符号变化且未满足上述“全零”条件，则返回 $T_{\\mathrm{tr}}=-1$。\n\n测试套件。实现以下三个用例，每个用例都有特定相的参数。每个态密度由三元组 $(f_{i},\\sigma_{i},w_{i})$ 指定，其中 $f_{i}$ 的单位为 $\\mathrm{THz}$，需要通过 $\\omega_{i}^{\\mathrm{med}} = 2\\pi f_{i}\\times 10^{12}\\,\\mathrm{rad/s}$ 转换为角频率中值。压力 $P$ 的单位为 $\\mathrm{Pa}$，静态能量 $E_{0}$ 的单位为每个化学式单元的 $\\mathrm{eV}$，体积 $V$ 的单位为每个化学式单元的 $\\mathrm{m}^{3}$。\n\n- 用例1（预期在有限温度 $T$ 下出现交叉）：\n  - $P = 10^{9}\\,\\mathrm{Pa}$，$T_{\\mathrm{eval}}=300\\,\\mathrm{K}$，$T_{\\max}=2000\\,\\mathrm{K}$。\n  - 相 $A$：$E_{0}^{(A)} = -1.000\\,\\mathrm{eV}$，$V^{(A)} = 2.0\\times 10^{-29}\\,\\mathrm{m}^{3}$，$g^{(A)}$: $\\{(2,\\;0.25,\\;1),\\;(5,\\;0.25,\\;1),\\;(10,\\;0.25,\\;1)\\}$。\n  - 相 $B$：$E_{0}^{(B)} = -0.995\\,\\mathrm{eV}$，$V^{(B)} = 1.9\\times 10^{-29}\\,\\mathrm{m}^{3}$，$g^{(B)}$: $\\{(3,\\;0.25,\\;1),\\;(7,\\;0.25,\\;1),\\;(13,\\;0.25,\\;1)\\}$。\n\n- 用例2（预期在范围内无交叉；在所有温度 $T$ 下一个相始终更有利）：\n  - $P = 0\\,\\mathrm{Pa}$，$T_{\\mathrm{eval}}=300\\,\\mathrm{K}$，$T_{\\max}=2000\\,\\mathrm{K}$。\n  - 相 $A$：$E_{0}^{(A)} = -1.000\\,\\mathrm{eV}$，$V^{(A)} = 2.0\\times 10^{-29}\\,\\mathrm{m}^{3}$，$g^{(A)}$: $\\{(8,\\;0.25,\\;1),\\;(12,\\;0.25,\\;1),\\;(18,\\;0.25,\\;1)\\}$。\n  - 相 $B$：$E_{0}^{(B)} = -1.050\\,\\mathrm{eV}$，$V^{(B)} = 2.0\\times 10^{-29}\\,\\mathrm{m}^{3}$，$g^{(B)}$: $\\{(4,\\;0.25,\\;1),\\;(8,\\;0.25,\\;1),\\;(12,\\;0.25,\\;1)\\}$。\n\n- 用例3（简并情况；相同的输入意味着 $G^{(A)}=G^{(B)}$）：\n  - $P = 0\\,\\mathrm{Pa}$，$T_{\\mathrm{eval}}=300\\,\\mathrm{K}$，$T_{\\max}=2000\\,\\mathrm{K}$。\n  - 相 $A$：$E_{0}^{(A)} = -1.000\\,\\mathrm{eV}$，$V^{(A)} = 2.0\\times 10^{-29}\\,\\mathrm{m}^{3}$，$g^{(A)}$: $\\{(6,\\;0.25,\\;1),\\;(9,\\;0.25,\\;1),\\;(15,\\;0.25,\\;1)\\}$。\n  - 相 $B$：$E_{0}^{(B)} = -1.000\\,\\mathrm{eV}$，$V^{(B)} = 2.0\\times 10^{-29}\\,\\mathrm{m}^{3}$，$g^{(B)}$: $\\{(6,\\;0.25,\\;1),\\;(9,\\;0.25,\\;1),\\;(15,\\;0.25,\\;1)\\}$。\n\n最终输出格式。您的程序应生成一行输出，其中包含一个逗号分隔的列表的列表形式的结果，格式如下\n$$\n\\big[\\,[\\Delta F_{\\mathrm{vib}}^{(1)}(300\\,\\mathrm{K}),\\,T_{\\mathrm{tr}}^{(1)}],\\;[\\Delta F_{\\mathrm{vib}}^{(2)}(300\\,\\mathrm{K}),\\,T_{\\mathrm{tr}}^{(2)}],\\;[\\Delta F_{\\mathrm{vib}}^{(3)}(300\\,\\mathrm{K}),\\,T_{\\mathrm{tr}}^{(3)}]\\,\\big],\n$$\n其中每个 $\\Delta F_{\\mathrm{vib}}^{(i)}(300\\,\\mathrm{K})$ 的单位是每个化学式单元的 $\\mathrm{eV}$，每个 $T_{\\mathrm{tr}}^{(i)}$ 的单位是 $\\mathrm{K}$。程序必须精确打印此单行表示，例如 $[[x_{1},y_{1}],[x_{2},y_{2}],[x_{3},y_{3}]]$，不得包含额外文本。此处所有角度均不相关；如果出现任何角度，应以弧度为单位给出，但本任务中未使用角度。", "solution": "该问题要求基于两种晶相（A 和 B）的振动声子态密度 (DoS) $g(\\omega)$ 来计算它们的热力学性质。主要任务是计算在特定温度 $T_{\\mathrm{eval}}$ 下的振动亥姆霍兹自由能差 $\\Delta F_{\\mathrm{vib}}$，并找出两相吉布斯自由能相等时的相变温度 $T_{\\mathrm{tr}}$。\n\n解决方案通过一系列逻辑步骤展开：定义物理模型，为必要的计算建立数值框架，然后实施计算策略，为每个测试用例找到所需的量。所有计算都将以国际单位制 (SI) 进行，仅在最终输出时根据指定要求转换为其他单位，如电子伏特 (eV)。\n\n**1. 物理常数和单位**\n使用以下国际单位制 (SI) 的物理常数：\n-   约化普朗克常数：$\\hbar \\approx 1.054571817 \\times 10^{-34}\\,\\mathrm{J}\\cdot\\mathrm{s}$\n-   玻尔兹曼常数：$k_{\\mathrm{B}} \\approx 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$\n\n以电子伏特 (eV) 提供的能量值使用基本电荷 $e$ 转换为焦耳：\n-   $1\\,\\mathrm{eV} \\approx 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$\n\n**2. 振动声子态密度 (DoS) 模型**\n每个相的 DoS $g(\\omega)$ 被建模为 $m$ 个对数正态分布的加权和：\n$$\ng(\\omega) = \\sum_{i=1}^{m} w_{i}\\,\\phi(\\omega;\\mu_{i},\\sigma_{i})\n$$\n其中 $\\phi(\\omega;\\mu,\\sigma)$ 是对数正态概率密度函数，定义于角频率 $\\omega > 0$：\n$$\n\\phi(\\omega;\\mu,\\sigma) = \\frac{1}{\\omega\\,\\sigma\\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(\\ln\\omega - \\mu)^{2}}{2\\sigma^{2}}\\right)\n$$\n参数 $\\mu_i$ 是变量对数的均值，与中值频率 $\\omega_i^{\\mathrm{med}}$ 的关系为 $\\mu_i = \\ln \\omega_i^{\\mathrm{med}}$。中值频率由循环频率 $f_i$（以 THz 给出）通过 $\\omega_{i}^{\\mathrm{med}} = 2\\pi f_{i}\\times 10^{12}\\,\\mathrm{rad/s}$ 导出。\n\n问题规定，必须对每个 DoS 进行数值重新归一化，以满足每个化学式单元有 $n=1$ 个原子的条件：\n$$\n\\int_{0}^{\\infty} g(\\omega)\\,d\\omega = 3\n$$\n这可以通过首先使用所提供的权重 $w_i$ 构建一个未归一化的 DoS，$g_{\\mathrm{un}}(\\omega)$ 来实现。然后我们对其在足够大的频率范围内进行数值积分，$I_{\\mathrm{un}} = \\int_{0}^{\\infty} g_{\\mathrm{un}}(\\omega)\\,d\\omega$。最终，归一化的 DoS 通过缩放得到：\n$$\ng(\\omega) = g_{\\mathrm{un}}(\\omega) \\times \\frac{3}{I_{\\mathrm{un}}}\n$$\n所有涉及 DoS 的积分都在一个离散的角频率网格 $(\\omega_j)$ 上进行数值计算，该网格的选择应能覆盖给定测试用例的所有对数正态分量的有效支撑集。对于密集网格，梯形法则可提供足够的精度。\n\n**3. 热力学函数**\n振动亥姆霍兹自由能 $F_{\\mathrm{vib}}(T)$ 由下式给出：\n$$\nF_{\\mathrm{vib}}(T) = \\int_{0}^{\\infty} g(\\omega)\\left[\\tfrac{1}{2}\\hbar\\omega + k_{\\mathrm{B}}T\\ln\\!\\left(1 - e^{-\\hbar\\omega/(k_{\\mathrm{B}}T)}\\right)\\right]\\,d\\omega\n$$\n该表达式可以分为与温度无关的零点能 (ZPE) 贡献和与温度相关的热贡献 $F_{\\mathrm{vib,th}}(T)$：\n$$\nF_{\\mathrm{vib}}(T) = \\mathrm{ZPE} + F_{\\mathrm{vib,th}}(T)\n$$\n其中\n$$\n\\mathrm{ZPE} = \\int_{0}^{\\infty} g(\\omega)\\,\\tfrac{1}{2}\\hbar\\omega\\,d\\omega\n$$\n$$\nF_{\\mathrm{vib,th}}(T) = \\int_{0}^{\\infty} g(\\omega)\\,k_{\\mathrm{B}}T\\ln\\!\\left(1 - e^{-\\hbar\\omega/(k_{\\mathrm{B}}T)}\\right)\\,d\\omega\n$$\n对于 $T=0\\,\\mathrm{K}$，$F_{\\mathrm{vib,th}}(0) = 0$ 且 $F_{\\mathrm{vib}}(0) = \\mathrm{ZPE}$。对于 $T > 0\\,\\mathrm{K}$，其中对数项 $\\ln(1-e^{-x})$（$x=\\hbar\\omega/(k_{\\mathrm{B}}T)$）在 $x$ 很小时需要进行仔细的数值计算，以避免精度损失。`numpy.log(-numpy.expm1(-x))` 表达式提供了一种数值上比 `numpy.log(1-numpy.exp(-x))` 更稳定的替代方法。\n\n吉布斯自由能 $G(T,P)$ 近似为：\n$$\nG(T,P) = E_{0} + F_{\\mathrm{vib}}(T) + PV\n$$\n其中 $E_0$ 是静态晶格能，$V$ 是每个化学式单元的体积。\n\n**4. 计算策略**\n\n**4.1. $\\Delta F_{\\mathrm{vib}}(T_{\\mathrm{eval}})$ 的计算**\n在 $T_{\\mathrm{eval}}=300\\,\\mathrm{K}$ 时的振动亥姆霍兹自由能差为 $\\Delta F_{\\mathrm{vib}}(300\\,\\mathrm{K}) = F_{\\mathrm{vib}}^{(B)}(300\\,\\mathrm{K}) - F_{\\mathrm{vib}}^{(A)}(300\\,\\mathrm{K})$。我们通过在共享的角频率网格上数值积分各自的 ZPE 和热贡献来计算每个相的 $F_{\\mathrm{vib}}(300\\,\\mathrm{K})$。最终结果从焦耳转换为 eV。\n\n**4.2. 相变温度 $T_{\\mathrm{tr}}$ 的计算**\n相变温度 $T_{\\mathrm{tr}}$ 是吉布斯自由能差 $\\Delta G(T) = G^{(B)}(T,P) - G^{(A)}(T,P) = 0$ 的最小非负根。\n$$\n\\Delta G(T) = (E_0^{(B)} - E_0^{(A)}) + (F_{\\mathrm{vib}}^{(B)}(T) - F_{\\mathrm{vib}}^{(A)}(T)) + P(V^{(B)} - V^{(A)}) = 0\n$$\n令 $\\Delta E_0 = E_0^{(B)} - E_0^{(A)}$，$\\Delta V = V^{(B)} - V^{(A)}$，且 $\\Delta F_{\\mathrm{vib}}(T) = F_{\\mathrm{vib}}^{(B)}(T) - F_{\\mathrm{vib}}^{(A)}(T)$。需要求解的方程是：\n$$\n\\Delta G(T) = \\Delta E_0 + \\Delta F_{\\mathrm{vib}}(T) + P\\Delta V = 0\n$$\n搜索 $T_{\\mathrm{tr}}$ 遵循一个特定协议：\n1.  建立一个从 $T=0\\,\\mathrm{K}$到 $T=T_{\\max}=2000\\,\\mathrm{K}$的温度网格。\n2.  在此网格上的每个温度点计算 $\\Delta G(T)$。\n3.  找到网格上 $\\Delta G(T)$ 的绝对最大值。如果此值（转换为 eV）小于公差 $\\varepsilon = 10^{-6}\\,\\mathrm{eV}$，则认为这些相是简并的，且 $T_{\\mathrm{tr}} = 0.0\\,\\mathrm{K}$。\n4.  否则，扫描 $\\Delta G(T)$值的网格以寻找符号变化。一个区间 $[T_i, T_{i+1}]$ 若满足 $\\Delta G(T_i) \\cdot \\Delta G(T_{i+1}) < 0$ 则包含一个根。\n5.  找到的第一个这样的区间（对应最小的相变温度）使用一个稳健的求根算法 `scipy.optimize.brentq` 来进行优化，以高精度确定 $T_{\\mathrm{tr}}$。\n6.  如果在整个温度范围 $[0, T_{\\max}]$ 内未检测到符号变化，则断定没有发生相变，并返回 $T_{\\mathrm{tr}} = -1.0\\,\\mathrm{K}$。同时也会显式检查 $T=0\\,\\mathrm{K}$ 处是否存在根。\n\n将此方法应用于问题陈述中指定的三个测试用例，得出所需的 $[\\Delta F_{\\mathrm{vib}}(300\\,\\mathrm{K}), T_{\\mathrm{tr}}]$ 对。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases described in the prompt.\n    \"\"\"\n    \n    # Physical constants in SI units\n    HBAR = 1.054571817e-34  # J*s\n    K_B = 1.380649e-23        # J/K\n    E_CHARGE = 1.602176634e-19 # C (for eV to J conversion)\n\n    def get_g_of_omega(omega_grid, dos_params):\n        \"\"\"\n        Constructs the vibrational density of states (DoS) on a given frequency grid.\n        \n        Args:\n            omega_grid (np.ndarray): Grid of angular frequencies (rad/s).\n            dos_params (list): List of tuples (f_i, sigma_i, w_i) for each lognormal component.\n                               f_i is in THz.\n\n        Returns:\n            np.ndarray: The normalized DoS g(omega) on the grid.\n        \"\"\"\n        g_unnormalized = np.zeros_like(omega_grid)\n        for f, sigma, w in dos_params:\n            omega_med = 2 * np.pi * f * 1e12\n            mu = np.log(omega_med)\n            \n            # Avoid log(0) at omega_grid[0] if it's 0\n            safe_omega = np.maximum(omega_grid, 1e-30)\n            \n            exponent = -((np.log(safe_omega) - mu)**2) / (2 * sigma**2)\n            phi = (1 / (safe_omega * sigma * np.sqrt(2 * np.pi))) * np.exp(exponent)\n            g_unnormalized += w * phi\n\n        # Numerically renormalize so that integral(g(omega) d_omega) = 3\n        integral_unnormalized = np.trapz(g_unnormalized, omega_grid)\n        if integral_unnormalized > 1e-9: # Avoid division by zero\n            g_normalized = g_unnormalized * (3.0 / integral_unnormalized)\n        else:\n            g_normalized = g_unnormalized\n        \n        return g_normalized\n\n    def calculate_F_vib(T, omega_grid, g_omega):\n        \"\"\"\n        Calculates the vibrational Helmholtz free energy F_vib at temperature T.\n\n        Args:\n            T (float): Temperature in Kelvin.\n            omega_grid (np.ndarray): Grid of angular frequencies (rad/s).\n            g_omega (np.ndarray): Normalized DoS on the omega_grid.\n\n        Returns:\n            float: Vibrational Helmholtz free energy in Joules.\n        \"\"\"\n        # Zero-Point Energy (ZPE)\n        zpe_integrand = 0.5 * HBAR * omega_grid * g_omega\n        zpe = np.trapz(zpe_integrand, omega_grid)\n\n        if T < 1e-9: # T=0 case\n            return zpe\n\n        # Thermal contribution\n        # Use numerically stable form for log(1 - exp(-x))\n        x = HBAR * omega_grid / (K_B * T)\n        # np.log(-np.expm1(-x)) is a stable way to compute np.log(1-np.exp(-x))\n        log_term = np.log(-np.expm1(-x))\n        \n        thermal_integrand = K_B * T * g_omega * log_term\n        thermal_contrib = np.trapz(thermal_integrand, omega_grid)\n\n        return zpe + thermal_contrib\n\n    def solve_case(case_params):\n        \"\"\"\n        Solves for a single test case.\n        \"\"\"\n        P = case_params['P']\n        T_eval = case_params['T_eval']\n        T_max = case_params['T_max']\n        \n        # Phase A parameters\n        E0_A_eV = case_params['A']['E0']\n        V_A = case_params['A']['V']\n        dos_params_A = case_params['A']['g']\n        \n        # Phase B parameters\n        E0_B_eV = case_params['B']['E0']\n        V_B = case_params['B']['V']\n        dos_params_B = case_params['B']['g']\n\n        # Setup numerical grid for omega\n        # A wide and dense grid to ensure accuracy for all cases.\n        omega_min = 0.1 * 1e12\n        omega_max = 500 * 1e12\n        num_points = 10000\n        omega_grid = np.linspace(omega_min, omega_max, num_points)\n\n        # Calculate DoS for both phases\n        g_A = get_g_of_omega(omega_grid, dos_params_A)\n        g_B = get_g_of_omega(omega_grid, dos_params_B)\n\n        # --- Task 1: Calculate Delta_F_vib at T_eval ---\n        F_vib_A_eval = calculate_F_vib(T_eval, omega_grid, g_A)\n        F_vib_B_eval = calculate_F_vib(T_eval, omega_grid, g_B)\n        delta_F_vib_eval_J = F_vib_B_eval - F_vib_A_eval\n        delta_F_vib_eval_eV = delta_F_vib_eval_J / E_CHARGE\n\n        # --- Task 2: Calculate transition temperature T_tr ---\n        E0_A_J = E0_A_eV * E_CHARGE\n        E0_B_J = E0_B_eV * E_CHARGE\n        \n        delta_E0_J = E0_B_J - E0_A_J\n        delta_V = V_B - V_A\n        PV_term = P * delta_V\n\n        memo_F_vib = {}\n        def get_F_vib(T, g_omega):\n            T_key = round(T, 8) # Avoid recomputing for same T in brentq\n            if (T_key, tuple(g_omega)) in memo_F_vib:\n                 return memo_F_vib[(T_key, tuple(g_omega))]\n            res = calculate_F_vib(T, omega_grid, g_omega)\n            memo_F_vib[(T_key, tuple(g_omega))] = res\n            return res\n\n        def delta_G(T):\n            F_vib_A = get_F_vib(T, g_A)\n            F_vib_B = get_F_vib(T, g_B)\n            delta_F_vib = F_vib_B - F_vib_A\n            return delta_E0_J + delta_F_vib + PV_term\n        \n        # Search for T_tr\n        T_grid = np.linspace(0, T_max, 201)\n        delta_G_values_J = np.array([delta_G(T) for T in T_grid])\n        delta_G_values_eV = delta_G_values_J / E_CHARGE\n        \n        # Check for numerically degenerate case\n        tolerance_eV = 1e-6\n        if np.max(np.abs(delta_G_values_eV)) < tolerance_eV:\n            T_tr = 0.0\n            return [delta_F_vib_eval_eV, T_tr]\n\n        # Search for roots\n        T_tr = -1.0\n        # Check for T=0 root explicitly\n        if abs(delta_G_values_J[0]) < tolerance_eV * E_CHARGE:\n            T_tr = 0.0\n            return [delta_F_vib_eval_eV, T_tr]\n            \n        for i in range(len(T_grid) - 1):\n            T1, T2 = T_grid[i], T_grid[i+1]\n            G1, G2 = delta_G_values_J[i], delta_G_values_J[i+1]\n            if G1 * G2 < 0:\n                try:\n                    root = brentq(delta_G, T1, T2)\n                    T_tr = root\n                    break # Found the smallest non-negative root\n                except ValueError:\n                    # Should not happen if G1*G2  0\n                    continue\n        \n        return [delta_F_vib_eval_eV, T_tr]\n\n    test_cases = [\n        {\n            'P': 1e9, 'T_eval': 300, 'T_max': 2000,\n            'A': {'E0': -1.000, 'V': 2.0e-29, 'g': [(2, 0.25, 1), (5, 0.25, 1), (10, 0.25, 1)]},\n            'B': {'E0': -0.995, 'V': 1.9e-29, 'g': [(3, 0.25, 1), (7, 0.25, 1), (13, 0.25, 1)]}\n        },\n        {\n            'P': 0, 'T_eval': 300, 'T_max': 2000,\n            'A': {'E0': -1.000, 'V': 2.0e-29, 'g': [(8, 0.25, 1), (12, 0.25, 1), (18, 0.25, 1)]},\n            'B': {'E0': -1.050, 'V': 2.0e-29, 'g': [(4, 0.25, 1), (8, 0.25, 1), (12, 0.25, 1)]}\n        },\n        {\n            'P': 0, 'T_eval': 300, 'T_max': 2000,\n            'A': {'E0': -1.000, 'V': 2.0e-29, 'g': [(6, 0.25, 1), (9, 0.25, 1), (15, 0.25, 1)]},\n            'B': {'E0': -1.000, 'V': 2.0e-29, 'g': [(6, 0.25, 1), (9, 0.25, 1), (15, 0.25, 1)]}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    print(f\"[{','.join([str(r) for r in results])}]\")\n\nsolve()\n```", "id": "3477028"}, {"introduction": "除了自由能和相稳定性，声子谱还决定了材料的其他重要热力学性质，如热膨胀。格林艾森参数 $\\gamma_{\\mathbf{q}}$ 是理解热膨胀现象的关键，它描述了声子频率如何随晶体体积变化。本练习将指导你使用有限差分法这一强大的通用数值技术，从声子色散关系中计算出模式格林艾森参数，并进一步得到与宏观热膨胀系数直接相关的热容加权平均值 $\\Gamma_C(T)$。[@problem_id:3477037]", "problem": "考虑一个具有单一声子分支的三维各向同性晶体。设声子角频率的模型为 $$\\omega(\\mathbf{q},V)=\\sqrt{\\omega_0(V)^2+v(V)^2\\lVert \\mathbf{q}\\rVert^2}$$，其中 $$\\omega_0(V)=A_0 V^{-\\eta_0}$$ 且 $$v(V)=A_1 V^{-\\eta_1}$$。此处，$$\\mathbf{q}$$ 是布里渊区 (BZ) 内的波矢，$$V$$ 是晶体体积，$$A_0$$ 和 $$A_1$$ 是无量纲正常数，$$\\eta_0$$ 和 $$\\eta_1$$ 是无量纲正指数。对于由波矢 $$\\mathbf{q}$$ 和分支指数 $$\\nu$$ 索引的模式（此处为单分支，故 $$\\nu$$ 可省略），其格林爱森参数由基本关系 $$\\gamma_{\\mathbf{q}\\nu}=-\\frac{V}{\\omega_{\\mathbf{q}\\nu}}\\frac{\\partial \\omega_{\\mathbf{q}\\nu}}{\\partial V}$$ 定义。任务是使用在基准体积 $$V_0$$ 处对 $$\\partial \\omega/\\partial V$$ 的对称有限差分近似来数值计算 $$\\gamma_{\\mathbf{q}\\nu}$$，评估其相对于体积微扰幅度的收敛性，并通过改变均匀 $$\\mathbf{q}$$ 网格分辨率来评估布里渊区采样的收敛性。\n\n使用约化普朗克常数和玻尔兹曼常数均为1的单位制，即 $$\\hbar=1$$ 和 $$k_{\\mathrm{B}}=1$$，因此所有量均为无量纲。使用一个在每个笛卡尔方向上于 $$[-\\pi,\\pi)$$ 区间内取 $$N$$ 个点的均匀网格来对简单立方晶格的布里渊区进行采样，并用离散求和来近似积分。使用对称有限差分公式 $$\\frac{\\partial \\omega}{\\partial V}\\bigg|_{V_0}\\approx \\frac{\\omega(\\mathbf{q},V_0+\\Delta V)-\\omega(\\mathbf{q},V_0-\\Delta V)}{2\\Delta V}$$，然后得到 $$\\gamma_{\\mathbf{q}}\\approx -\\frac{V_0}{\\omega(\\mathbf{q},V_0)}\\cdot\\frac{\\omega(\\mathbf{q},V_0+\\Delta V)-\\omega(\\mathbf{q},V_0-\\Delta V)}{2\\Delta V}$$。\n\n为进行误差量化，使用所提供的色散模型和微积分方法，推导出在 $$V_0$$ 处 $$\\gamma_{\\mathbf{q}}$$ 的精确解析表达式。然后通过均方根误差 $$\\mathrm{RMSE}=\\sqrt{\\frac{1}{M}\\sum_{i=1}^{M}\\left(\\gamma_{\\mathbf{q}_i}^{\\mathrm{FD}}-\\gamma_{\\mathbf{q}_i}^{\\mathrm{exact}}\\right)^2}$$ 来量化有限差分误差，其中 $$M=N^3$$ 是 $$\\mathbf{q}$$ 采样点的总数，$$\\gamma_{\\mathbf{q}_i}^{\\mathrm{FD}}$$ 表示有限差分值，$$\\gamma_{\\mathbf{q}_i}^{\\mathrm{exact}}$$ 表示精确解析值。此外，为了与声子态密度 (DOS) 和热力学函数相关联，使用玻色-爱因斯坦统计公式 $$C(\\omega,T)=\\left(\\frac{\\omega}{T}\\right)^2\\frac{e^{\\omega/T}}{\\left(e^{\\omega/T}-1\\right)^2}$$（在这些无量纲单位下）计算温度 $$T$$ 下的单模比热，并对比热加权平均格林爱森参数 $$\\Gamma_C(T)=\\frac{\\sum_{i=1}^{M}\\gamma_{\\mathbf{q}_i} C\\!\\left(\\omega(\\mathbf{q}_i,V_0),T\\right)}{\\sum_{i=1}^{M}C\\!\\left(\\omega(\\mathbf{q}_i,V_0),T\\right)}$$ 进行评估，此评估需同时使用有限差分和精确解析的 $$\\gamma_{\\mathbf{q}_i}$$，并报告绝对误差 $$\\left|\\Gamma_C^{\\mathrm{FD}}(T)-\\Gamma_C^{\\mathrm{exact}}(T)\\right|$$。\n\n使用固定的参数值 $$A_0=2.0$$, $$A_1=1.0$$, $$\\eta_0=1.2$$, $$\\eta_1=0.3$$ 和 $$V_0=1.0$$。所有计算均按规定在无量纲单位下执行。\n\n测试套件：\n为以下每一组表示为元组 $$\\left(\\Delta V/V_0,\\,N,\\,T\\right)$$ 的参数集，计算度量对 $$\\left[\\mathrm{RMSE},\\,\\left|\\Gamma_C^{\\mathrm{FD}}(T)-\\Gamma_C^{\\mathrm{exact}}(T)\\right|\\right]$$：\n\n$$\\left(0.01,\\,30,\\,0.5\\right)$$\n$$\\left(0.01,\\,8,\\,0.5\\right)$$\n$$\\left(0.10,\\,30,\\,0.5\\right)$$\n$$\\left(10^{-6},\\,30,\\,0.5\\right)$$\n$$\\left(0.01,\\,60,\\,0.5\\right)$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个双元素列表 $$\\left[\\mathrm{RMSE},\\,\\left|\\Gamma_C^{\\mathrm{FD}}-\\Gamma_C^{\\mathrm{exact}}\\right|\\right]$$。例如：$$\\left[\\left[r_1,e_1\\right],\\left[r_2,e_2\\right],\\ldots\\right]$$，所有数字都以无量纲单位的标准十进制浮点数形式呈现。", "solution": "用户提供的问题经评估有效。它在科学上合理、适定、客观且自洽，提出了一个计算材料科学中的标准问题，涉及推导解析表达式、实现数值近似和量化误差。\n\n### 1. 理论框架与解析推导\n\n主要目标是计算模式格林爱森参数 $\\gamma_{\\mathbf{q}}$，它量化了声子模式频率 $\\omega_{\\mathbf{q}}$ 相对于晶体体积 $V$ 的对数变化。其基本定义为：\n$$\n\\gamma_{\\mathbf{q}} = -\\frac{\\partial \\ln \\omega_{\\mathbf{q}}}{\\partial \\ln V} = -\\frac{V}{\\omega_{\\mathbf{q}}} \\frac{\\partial \\omega_{\\mathbf{q}}}{\\partial V}\n$$\n问题提供了一个针对单一各向同性分支的声子色散关系模型：\n$$\n\\omega(\\mathbf{q},V) = \\sqrt{\\omega_0(V)^2 + v(V)^2 \\lVert \\mathbf{q} \\rVert^2}\n$$\n其中 $q = \\lVert \\mathbf{q} \\rVert$ 是波矢的模，依赖于体积的参数由幂律给出：\n$$\n\\omega_0(V) = A_0 V^{-\\eta_0} \\quad \\text{和} \\quad v(V) = A_1 V^{-\\eta_1}\n$$\n为推导 $\\gamma_{\\mathbf{q}}$ 的精确解析表达式，我们首先计算 $\\omega(\\mathbf{q},V)$ 对 $V$ 的偏导数。先对 $\\omega^2$ 求导会更方便：\n$$\n\\frac{\\partial (\\omega^2)}{\\partial V} = \\frac{\\partial}{\\partial V} \\left( \\omega_0(V)^2 + v(V)^2 q^2 \\right) = 2\\omega_0 \\frac{d\\omega_0}{dV} + 2v \\frac{dv}{dV} q^2\n$$\n参数的导数是：\n$$\n\\frac{d\\omega_0}{dV} = A_0(-\\eta_0)V^{-\\eta_0-1} = -\\frac{\\eta_0}{V} (A_0 V^{-\\eta_0}) = -\\frac{\\eta_0 \\omega_0(V)}{V}\n$$\n$$\n\\frac{dv}{dV} = A_1(-\\eta_1)V^{-\\eta_1-1} = -\\frac{\\eta_1}{V} (A_1 V^{-\\eta_1}) = -\\frac{\\eta_1 v(V)}{V}\n$$\n将这些代入 $\\omega^2$ 的导数中：\n$$\n\\frac{\\partial (\\omega^2)}{\\partial V} = 2\\omega_0 \\left(-\\frac{\\eta_0 \\omega_0}{V}\\right) + 2v \\left(-\\frac{\\eta_1 v}{V}\\right) q^2 = -\\frac{2}{V} \\left( \\eta_0 \\omega_0^2 + \\eta_1 v^2 q^2 \\right)\n$$\n使用链式法则 $\\frac{\\partial (\\omega^2)}{\\partial V} = 2\\omega \\frac{\\partial \\omega}{\\partial V}$，我们得到 $\\frac{\\partial \\omega}{\\partial V}$：\n$$\n\\frac{\\partial \\omega}{\\partial V} = \\frac{1}{2\\omega} \\frac{\\partial (\\omega^2)}{\\partial V} = -\\frac{1}{\\omega V} \\left( \\eta_0 \\omega_0^2 + \\eta_1 v^2 q^2 \\right)\n$$\n最后，将此代入 $\\gamma_{\\mathbf{q}}$ 的定义中：\n$$\n\\gamma_{\\mathbf{q}}(V) = -\\frac{V}{\\omega} \\left( -\\frac{1}{\\omega V} \\left( \\eta_0 \\omega_0(V)^2 + \\eta_1 v(V)^2 q^2 \\right) \\right) = \\frac{\\eta_0 \\omega_0(V)^2 + \\eta_1 v(V)^2 q^2}{\\omega^2}\n$$\n用 $\\omega^2$ 的定义替换它，我们得到格林爱森参数的精确解析表达式：\n$$\n\\gamma_{\\mathbf{q}}^{\\mathrm{exact}}(V) = \\frac{\\eta_0 \\omega_0(V)^2 + \\eta_1 v(V)^2 \\lVert \\mathbf{q}\\rVert^2}{\\omega_0(V)^2 + v(V)^2 \\lVert \\mathbf{q}\\rVert^2}\n$$\n该表达式将在基准体积 $V_0$ 处进行求值，并作为量化数值误差的参考。\n\n### 2. 数值步骤与误差度量\n\n问题的数值部分涉及几个步骤：布里渊区 (BZ) 采样、有限差分近似，以及热力学平均值和误差度量的计算。\n\n#### a. 布里渊区采样\n简单立方晶格的布里渊区是倒易空间中的一个立方体。我们使用一个 $N \\times N \\times N$ 点的均匀网格对其进行采样。波矢分量 $q_x, q_y, q_z$ 在区间 $[-\\pi, \\pi)$ 上进行采样。对于给定的 $N$，构建采样波矢集 $\\mathbf{q}_i$，并对每个波矢计算其模的平方 $\\lVert \\mathbf{q}_i \\rVert^2$。总点数为 $M=N^3$。\n\n#### b. 有限差分近似\n导数 $\\partial \\omega / \\partial V$ 在 $V_0$ 处使用带有体积微扰 $\\Delta V$ 的对称（中心）有限差分格式进行近似：\n$$\n\\frac{\\partial \\omega(\\mathbf{q}, V)}{\\partial V}\\bigg|_{V_0} \\approx \\frac{\\omega(\\mathbf{q}, V_0+\\Delta V) - \\omega(\\mathbf{q}, V_0-\\Delta V)}{2\\Delta V}\n$$\n格林爱森参数的相应近似为：\n$$\n\\gamma_{\\mathbf{q}}^{\\mathrm{FD}} \\approx -\\frac{V_0}{\\omega(\\mathbf{q}, V_0)} \\cdot \\frac{\\omega(\\mathbf{q}, V_0+\\Delta V) - \\omega(\\mathbf{q}, V_0-\\Delta V)}{2\\Delta V}\n$$\n对每个采样波矢 $\\mathbf{q}_i$ 执行此计算。\n\n#### c. 热力学平均与比热\n在温度 $T$ 下，频率为 $\\omega$ 的单一声子模式的比热容由玻色-爱因斯坦统计给出（其中 $k_B = 1$）：\n$$\nC(\\omega, T) = \\left(\\frac{\\omega}{T}\\right)^2 \\frac{e^{\\omega/T}}{\\left(e^{\\omega/T}-1\\right)^2}\n$$\n为了进行稳健的数值评估，可以将其重写。令 $x = \\omega/T$，我们有：\n$$\nC(x) = \\frac{x^2 e^x}{(e^x-1)^2} = \\frac{x^2}{e^{-x}(e^x-1)^2} = \\frac{x^2}{(e^{x/2}-e^{-x/2})^2} = \\frac{x^2}{4\\sinh^2(x/2)}\n$$\n一个等价的稳定形式是 $C(x) = \\frac{x^2}{2(\\cosh(x)-1)}$，它对于非常小和非常大的 $x$ 都表现良好。\n\n比热加权平均格林爱森参数 $\\Gamma_C(T)$ 是通过在布里渊区上对模式相关的 $\\gamma_{\\mathbf{q}_i}$ 值进行平均来计算的，权重为其各自对比热的贡献：\n$$\n\\Gamma_C(T) = \\frac{\\sum_{i=1}^{M} \\gamma_{\\mathbf{q}_i} C(\\omega(\\mathbf{q}_i, V_0), T)}{\\sum_{i=1}^{M} C(\\omega(\\mathbf{q}_i, V_0), T)}\n$$\n该平均值使用 $\\gamma_{\\mathbf{q}_i}^{\\mathrm{exact}}$ 和 $\\gamma_{\\mathbf{q}_i}^{\\mathrm{FD}}$ 两者进行计算。\n\n#### d. 误差量化\n使用两种度量来评估数值精度：\n1.  **均方根误差 (RMSE)**：这衡量了在所有采样模式上，有限差分近似值与精确值之间的平均偏差。\n    $$\n    \\mathrm{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{i=1}^{M} \\left(\\gamma_{\\mathbf{q}_i}^{\\mathrm{FD}} - \\gamma_{\\mathbf{q}_i}^{\\mathrm{exact}}\\right)^2}\n    $$\n2.  **加权平均的绝对误差**：这衡量了因使用近似的 $\\gamma_{\\mathbf{q}_i}^{\\mathrm{FD}}$ 而导致的宏观热力学量 $\\Gamma_C(T)$ 的误差。\n    $$\n    \\text{Error} = \\left| \\Gamma_C^{\\mathrm{FD}}(T) - \\Gamma_C^{\\mathrm{exact}}(T) \\right|\n    $$\n\n### 3. 实现计划\n\n该解决方案通过使用 `numpy` 库进行高效矢量化计算，实现为一个 Python 脚本。\n1.  定义所有物理和模型常数：$A_0, A_1, \\eta_0, \\eta_1, V_0$。\n2.  为 $\\omega_0(V)$、 $v(V)$ 和 $\\omega(\\mathbf{q}, V)$ 定义辅助函数。\n3.  遍历每个测试用例元组 $(\\Delta V/V_0, N, T)$。\n4.  对于每种情况：\n    a. 生成 $\\mathbf{q}$ 向量的三维网格并计算其模的平方。\n    b. 使用推导出的解析公式，在 $V_0$ 处计算精确格林爱森参数数组 $\\gamma^{\\mathrm{exact}}$。\n    c. 通过在 $V_0$、$V_0+\\Delta V$ 和 $V_0-\\Delta V$ 处计算 $\\omega$ 的值，来计算有限差分格林爱森参数数组 $\\gamma^{\\mathrm{FD}}$。\n    d. 计算 $\\gamma^{\\mathrm{exact}}$ 和 $\\gamma^{\\mathrm{FD}}$ 数组之间的均方根误差。\n    e. 使用在 $V_0$ 处的声子频率计算比热值数组 $C_i$。\n    f. 计算加权平均值 $\\Gamma_C^{\\mathrm{exact}}(T)$ 和 $\\Gamma_C^{\\mathrm{FD}}(T)$。\n    g. 计算这两个平均值之间的绝对误差。\n    h. 存储得到的度量对 `[RMSE, 绝对误差]`。\n5.  按规定将最终结果集合格式化为单个字符串并打印。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes numerical errors in the Grüneisen parameter calculation for a model\n    phonon dispersion, as a function of finite-difference step size and Brillouin\n    Zone sampling density.\n    \"\"\"\n    # Fixed parameter values from the problem statement.\n    A0 = 2.0\n    A1 = 1.0\n    ETA0 = 1.2\n    ETA1 = 0.3\n    V0 = 1.0\n\n    # Test suite: tuples of (dV/V0, N, T)\n    test_cases = [\n        (0.01, 30, 0.5),\n        (0.01, 8, 0.5),\n        (0.10, 30, 0.5),\n        (1e-6, 30, 0.5),\n        (0.01, 60, 0.5),\n    ]\n\n    # Helper functions for the dispersion model\n    def omega0_func(V, A0_val=A0, eta0_val=ETA0):\n        return A0_val * V ** (-eta0_val)\n\n    def v_func(V, A1_val=A1, eta1_val=ETA1):\n        return A1_val * V ** (-eta1_val)\n\n    def omega_func(q_norm_sq, V):\n        w0_sq = omega0_func(V) ** 2\n        v_sq = v_func(V) ** 2\n        return np.sqrt(w0_sq + v_sq * q_norm_sq)\n\n    # Numerically stable specific heat function C(omega, T)\n    def specific_heat_func(omega, T):\n        # x = omega / T\n        x = omega / T\n        # Handle the case where T is extremely low or omega is 0, making x large or 0.\n        # The form x^2 / (2 * (cosh(x) - 1)) is stable.\n        # Add a small epsilon to the denominator to prevent division by zero if x is exactly 0,\n        # though with the given model omega is always positive.\n        denominator = 2 * (np.cosh(x) - 1)\n        # For very small x, cosh(x) ~ 1 + x^2/2, so denom ~ x^2, and C ~ 1.\n        # The limit as x->0 is 1. We can use a condition to avoid 0/0.\n        c = np.ones_like(x)\n        mask = denominator > 0\n        c[mask] = (x[mask]**2) / denominator[mask]\n        return c\n\n    results = []\n\n    for dv_ratio, N, T in test_cases:\n        dV = V0 * dv_ratio\n\n        # 1. Generate q-points grid\n        q_coords = np.linspace(-np.pi, np.pi, N, endpoint=False)\n        qx, qy, qz = np.meshgrid(q_coords, q_coords, q_coords, indexing='ij')\n        q_norm_sq = qx**2 + qy**2 + qz**2\n\n        # 2. Calculate exact analytical Grüneisen parameter at V0\n        omega0_V0_sq = omega0_func(V0)**2\n        v_V0_sq = v_func(V0)**2\n        \n        numerator_exact = ETA0 * omega0_V0_sq + ETA1 * v_V0_sq * q_norm_sq\n        denominator_exact = omega0_V0_sq + v_V0_sq * q_norm_sq\n        gamma_exact = numerator_exact / denominator_exact\n\n        # 3. Calculate finite-difference Grüneisen parameter\n        V_plus = V0 + dV\n        V_minus = V0 - dV\n\n        omega_at_V0 = omega_func(q_norm_sq, V0)\n        omega_at_Vplus = omega_func(q_norm_sq, V_plus)\n        omega_at_Vminus = omega_func(q_norm_sq, V_minus)\n\n        d_omega_d_V_fd = (omega_at_Vplus - omega_at_Vminus) / (2 * dV)\n        gamma_fd = -V0 / omega_at_V0 * d_omega_d_V_fd\n\n        # 4. Calculate RMSE\n        rmse = np.sqrt(np.mean((gamma_fd - gamma_exact)**2))\n\n        # 5. Calculate specific-heat-weighted average Grüneisen params and their error\n        C_q = specific_heat_func(omega_at_V0, T)\n        \n        sum_C = np.sum(C_q)\n\n        Gamma_C_exact = np.sum(gamma_exact * C_q) / sum_C\n        Gamma_C_fd = np.sum(gamma_fd * C_q) / sum_C\n        \n        abs_error_Gamma_C = np.abs(Gamma_C_fd - Gamma_C_exact)\n\n        results.append([rmse, abs_error_Gamma_C])\n\n    # Format the final output string to match the required format: [[r1,e1],[r2,e2],...]\n    # without spaces inside the inner lists.\n    result_strings = [f\"[{r},{e}]\" for r, e in results]\n    final_output_string = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3477037"}]}