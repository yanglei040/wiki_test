{"hands_on_practices": [{"introduction": "在进行任何复杂的计算之前，首要任务是根据体材料的晶体结构正确地构建表面模型。这个基础练习 ([@problem_id:3487610]) 将指导您完成从晶体中切割表面、选择对称的终端以避免人为偶极矩，并精确计算原子数量的全过程。这是一个至关重要的“纸上谈兵”练习，它将晶体学概念与可直接用于模拟的表面模型的实际构建联系起来，为您后续的计算工作打下坚实的几何基础。", "problem": "一个化学式为 $A B O_{3}$ 的立方钙钛矿晶体，其常规晶格常数为 $a$，常规立方晶胞中的原子基底为：$A$ 阳离子位于立方体角点，$B$ 阳离子位于体心，$O$ 阴离子位于面心。考虑沿 $(001)$ 方向构建一个表面平板，其横向平移取自常规立方晶格，平板法线沿 $[001]$ 方向。该平板将用于包含真空区域的、在周期性边界条件下进行的表面第一性原理模拟。为防止人为静电场，并使静电势在两侧能够明确地与真空能级对齐，应选择一个相对于平板中间平面对称的终止面。使用 $A B O_{3}$ 堆叠结构所隐含的沿 $[001]$ 方向的最小化学计量重复单元，并假设理想解理，不发生重构或弛豫，推导构建一个厚度为 $N$ 个原子层、横向面积为 $A$ 的平板所需的总原子数，其中使用原始的 $(001)$ 表面晶胞作为重复的横向单元。假设 $N$ 是一个奇数正整数，从而使得顶面和底面具有相同的终止面。将你的最终答案表示为包含 $N$、$A$ 和 $a$ 的闭式符号表达式。不需要四舍五入。最终答案必须是方框中的单个解析表达式，不带单位。", "solution": "用户希望确定一个立方钙钛矿晶体对称平板模型中的总原子数。\n\n### 第一步：问题验证\n\n**1.1. 提取已知条件**\n- 晶体结构：化学式为 $A B O_{3}$ 的立方钙钛矿。\n- 常规晶格常数：$a$。\n- 常规晶胞中的原子基底：$A$ 在角点，$B$ 在体心，$O$ 在面心。\n- 平板取向：法线沿 $[001]$ 方向。\n- 横向周期性：基于常规立方晶格。\n- 模拟约束：带有真空区域的周期性边界条件。平板必须相对于其中心平面对称，以防止人为电场。\n- 平板构建：\n    - 基于沿 $[001]$ 方向的最小化学计量重复单元。\n    - 假设理想解理，无重构或弛豫。\n    - 厚度为 $N$ 个原子层，其中 $N$ 是一个奇数正整数。\n    - 重复的横向单元是原始的 $(001)$ 表面晶胞。\n- 平板的总横向面积：$A$。\n- 要求输出：总原子数的闭式符号表达式，用 $N$、$A$ 和 $a$ 表示。\n\n**1.2. 使用提取的已知条件进行验证**\n该问题在科学上是合理的、定义明确的且客观的。它描述了计算材料科学中创建表面模型的标准程序。钙钛矿结构有明确定义，且约束条件（理想解理、奇数 $N$、对称性）是针对特定几何构造的清晰指令。该问题隐含地依赖于所选构造的非极性性质，这对于像 $SrTiO_3$ ($A^{2+}B^{4+}O_3$) 这样的常见钙钛矿是成立的，其中构成的 $AO$ 和 $BO_2$ 层是电中性的。对于极性情况（如 $LaAlO_3$，$A^{3+}B^{3+}O_3$），这种“理想解理”模型在物理上是不稳定的，但问题要求的是基于此几何构造进行形式上的原子计数，这是一个有效且定义明确的数学问题。构建对称平板以对齐真空势的指令是合理的。奇数层数 $N$ 允许平板具有对称性，且顶部和底部有相同的终止面。该问题是自洽且无矛盾的。\n\n**1.3. 结论与行动**\n该问题被判定为**有效**。我们可以继续进行求解。\n\n### 第二步：求解推导\n\n求解过程需要分析 $A B O_3$ 钙钛矿结构沿 $[001]$ 方向的原子堆叠方式，然后计算指定平板几何模型中的原子数量。\n\n**2.1. 沿 [001] 方向的原子堆叠**\n让常规立方晶胞由沿笛卡尔坐标轴的晶格矢量定义，原点位于一个 $A$ 阳离子处。基底原子的分数坐标是：\n- $A$: $(0, 0, 0)$\n- $B$: $(\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$\n- $O$: $(\\frac{1}{2}, \\frac{1}{2}, 0)$、$(\\frac{1}{2}, 0, \\frac{1}{2})$、$(0, \\frac{1}{2}, \\frac{1}{2})$\n\n我们检查垂直于 $[001]$ 方向的原子平面（即恒定 $z$ 坐标的平面）。\n- 在 $z=0$ 处，有一个包含 $A$ 阳离子（来自晶胞的角点）和位于面心 $(\\frac{1}{2}, \\frac{1}{2}, 0)$ 的一个 $O$ 阴离子的平面。该层的化学计量为 $AO$。\n- 在 $z=\\frac{a}{2}$ 处，有一个包含位于体心 $(\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$ 的 $B$ 阳离子和位于面心 $(\\frac{1}{2}, 0, \\frac{1}{2})$ 与 $(0, \\frac{1}{2}, \\frac{1}{2})$ 的两个 $O$ 阴离子的平面。该层的化学计量为 $BO_2$。\n- 在 $z=a$ 处，结构重复，是另一个 $AO$ 层。\n\n沿 $[001]$ 方向的堆叠序列是 $AO$ 和 $BO_2$ 平面的交替，两平面间相距 $\\frac{a}{2}$。沿 $[001]$ 方向的最小化学计量重复单元由一个 $AO$ 层和一个 $BO_2$ 层组成，它们共同构成 $ABO_3$ 的化学式。\n\n**2.2. 每个表面原胞中的原子数**\n问题指定使用原始的 $(001)$ 表面晶胞作为横向单元。对于简单立方晶格，这是一个面积为 $a \\times a = a^2$ 的正方形。我们计算每种类型的层在此单元内的原子数。\n\n- **对于一个 $AO$ 层：**\n    - 每个单元有一个 $A$ 原子。（$a \\times a$ 正方形角上的 $4$ 个 $A$ 原子中的每一个都由 $4$ 个相邻单元共享，因此 $4 \\times \\frac{1}{4} = 1$）。\n    - 每个单元有一个 $O$ 原子（位于 $a \\times a$ 正方形的中心）。\n    - 每个 $a^2$ 面积的一个 $AO$ 层中的总原子数：$1+1 = 2$。\n\n- **对于一个 $BO_2$ 层：**\n    - 每个单元有一个 $B$ 原子（位于 $a \\times a$ 单元的中心，对应于体心位置的投影）。\n    - 每个单元有两个 $O$ 原子。（两个相关的氧原子位于分数坐标 $(\\frac{1}{2}, 0, \\frac{1}{2})$ 和 $(0, \\frac{1}{2}, \\frac{1}{2})$。每个原子位于 $a \\times a$ 单元的一条边上，并由 $2$ 个单元共享。所以，单元周围有 $4$ 个这样的边位置，每个贡献 $\\frac{1}{2}$，但在该平面的基底中只有 $2$ 个独特的原子类型。总计数是基底原子投影到边上的 $2 \\times (\\frac{1}{2}) + 2 \\times (\\frac{1}{2}) = 2$ 个原子，或者更简单地说，一个B原子在单元内，与之关联的有两个O原子，得到2个O原子）。\n    - 每个 $a^2$ 面积的一个 $BO_2$ 层中的总原子数：$1+2 = 3$。\n\n**2.3. 平板构建与原子计数**\n平板必须是对称的，并且有奇数层数 $N$。这意味着平板顶部和底部的终止平面必须相同。我们有两种终止选择：$AO$ 或 $BO_2$。标准的晶体学惯例将原点置于高对称性位点，即 $A$ 阳离子。这使得 $AO$ 层成为 $z=0$ 处的自然起始平面，因此我们选择以 $AO$ 为终止面的平板。\n\n一个具有 $N$ 层（其中 $N=2k+1$，对于某个整数 $k \\ge 0$）的以 $AO$ 为终止面的对称平板，其中心和两个表面都将是 $AO$ 层。结构为 $AO - BO_2 - AO - \\dots - AO - BO_2 - AO$。\n- 位于奇数位置（$1, 3, \\dots, N$）的层是 $AO$ 层。\n- 位于偶数位置（$2, 4, \\dots, N-1$）的层是 $BO_2$ 层。\n\n对于奇数 $N$，从 $1$ 到 $N$ 的奇数个数是 $\\frac{N+1}{2}$。这是 $AO$ 层的数量。\n从 $1$ 到 $N$ 的偶数个数是 $\\frac{N-1}{2}$。这是 $BO_2$ 层的数量。\n\n每个原始单元面积（$a^2$）的总原子数是：\n$$ N_{\\text{tile}} = (AO \\text{ 层的数量}) \\times (\\text{每个 } AO \\text{ 层的原子数}) + (BO_2 \\text{ 层的数量}) \\times (\\text{每个 } BO_2 \\text{ 层的原子数}) $$\n$$ N_{\\text{tile}} = \\left(\\frac{N+1}{2}\\right) \\times 2 + \\left(\\frac{N-1}{2}\\right) \\times 3 $$\n$$ N_{\\text{tile}} = (N+1) + \\frac{3(N-1)}{2} $$\n$$ N_{\\text{tile}} = \\frac{2(N+1) + 3(N-1)}{2} $$\n$$ N_{\\text{tile}} = \\frac{2N+2+3N-3}{2} $$\n$$ N_{\\text{tile}} = \\frac{5N-1}{2} $$\n\n这是一个横向面积为 $a^2$ 的平板的总原子数。问题说明总横向面积为 $A$。形成这个面积所需的原始单元数量是 $\\frac{A}{a^2}$。\n\n整个平板的总原子数 $N_{\\text{total}}$ 是每个单元的原子数乘以单元的数量：\n$$ N_{\\text{total}} = N_{\\text{tile}} \\times \\left(\\frac{A}{a^2}\\right) $$\n$$ N_{\\text{total}} = \\left(\\frac{5N-1}{2}\\right) \\times \\left(\\frac{A}{a^2}\\right) $$\n$$ N_{\\text{total}} = \\frac{A(5N-1)}{2a^2} $$\n\n这是总原子数的最终闭式符号表达式。", "answer": "$$\n\\boxed{\\frac{A(5N-1)}{2a^{2}}}\n$$", "id": "3487610"}, {"introduction": "构建完几何模型后，我们必须确保电子结构计算本身的准确性。固体的连续电子能带是在布里渊区中的离散点（$k$点）上进行采样的，而这种采样的密度是决定计算精度的关键参数。这项动手实践 ([@problem_id:3487639]) 提供了模拟的计算数据，引导您完成计算表面能和功函数等关键表面性质的过程，并分析它们相对于$k$点网格密度的收敛性，这是确保任何板模型计算可靠性的核心技能。", "problem": "一个晶体表面的板坯模型在横向方向上使用周期性边界条件进行模拟，并在表面法线方向上设置一个厚度为 $t_{\\text{vac}}$ 的真空区。在此类模型中，单位面积的表面能和功函数取决于倒易空间的采样，该采样由二维布里渊区中的 $k$点数量来量化。一个 $k$点网格表示为 $(n_x,n_y,n_z)$，对于板坯，$n_z=1$，平面内的总 $k$点数为 $N_k=n_x n_y$。您将编写的程序必须应用 $k$点收敛性分析，以评估单位面积的表面能和功函数在 $k$点网格密度变化下的稳定性，并合理解释在密集和稀疏网格之间观察到的差异，同时明确强制单位一致性。\n\n使用以下基本依据：\n- 单位面积的表面能源于在对称板坯超胞中创建两个表面所产生的能量代价，其定义涉及板坯总能量、原子数量、每个原子的体相参考能量以及表面积。\n- 功函数定义为真空区中的宏观平均静电势与板坯的费米能之间的差值。\n- 使用精确换算关系 $1\\,\\text{electron volt} = 1.602176634\\times 10^{-19}\\,\\text{joule}$。\n\n您的任务是：\n1. 对于每个提供的测试用例和每个提供的 $k$网格，使用给定的总能量、体相参考能量、原子计数、表面积、真空势和费米能，根据与真空能级对齐的板坯模型相关的基本原理和核心定义，计算单位为 $\\text{J}/\\text{m}^2$ 的单位面积表面能和单位为 $\\text{eV}$ 的功函数。除了这些定义之外，不要假设任何预先推导的快捷公式。\n2. 将最密集的 $k$网格（最大的 $N_k$）视为参考，最稀疏的 $k$网格（最小的 $N_k$）视为粗略基线。按如下方式定义一个量的稳定性：如果一个量在稀疏网格下的值与在密集网格下的值之间的绝对差小于或等于指定的容差，则该量是稳定的。使用 $0.05\\,\\text{J}/\\text{m}^2$ 的表面能容差和 $0.05\\,\\text{eV}$ 的功函数容差。\n3. 对于每个测试用例，计算以下由相应容差归一化的灵敏度分数，以合理解释稀疏和密集网格之间的差异：\n   - $s_{\\gamma} = \\frac{\\left|\\gamma_{\\text{sparse}} - \\gamma_{\\text{dense}}\\right|}{0.05\\,\\text{J}/\\text{m}^2}$，\n   - $s_{W} = \\frac{\\left|W_{\\text{sparse}} - W_{\\text{dense}}\\right|}{0.05\\,\\text{eV}}$。\n   然后通过测试 $s_{W} > s_{\\gamma}$ 是否成立，评估在给定容差下功函数是否比表面能更敏感，为每个测试用例生成一个布尔值。\n4. 对于单位处理，表面积 $A$ 以平方埃给出，必须使用 $A_{\\text{m}^2} = A_{\\text{\\AA}^2}\\times 10^{-20}$ 转换为平方米。总能量和体相能量以电子伏特给出，必须一致处理以产生单位为 $\\text{J}/\\text{m}^2$ 的表面能。功函数必须以电子伏特报告。本问题不涉及角度。\n5. 将密集网格下的单位面积表面能以 $\\text{J}/\\text{m}^2$ 为单位表示，四舍五入到三位小数；将密集网格下的功函数以 $\\text{eV}$ 为单位表示，四舍五入到三位小数。将灵敏度分数 $s_{\\gamma}$ 和 $s_W$ 四舍五入到三位小数。稳定性和灵敏度比较结果是布尔值。\n6. 实现程序以处理以下测试套件。每个测试用例包括原子数 $N$、以平方埃为单位的表面积 $A$、以电子伏特为单位的每个原子的体相能量 $E_{\\text{bulk}}$、以埃为单位的真空厚度 $t_{\\text{vac}}$、三个 $k$-网格 $(n_x,n_y,n_z)$（其中 $n_z=1$）、每个 $k$-网格对应的板坯总能量 $E_{\\text{slab}}$（单位为电子伏特），以及每个 $k$-网格对应的真空势 $V_{\\text{vac}}$ 和费米能 $E_F$（单位为电子伏特）。\n\n测试用例1（金属板坯）：\n- $N = 14$，$A = 8.0$（平方埃，即 $8.0\\times 10^{-20}\\,\\text{m}^2$），$E_{\\text{bulk}} = -3.600$（电子伏特/原子），$t_{\\text{vac}} = 20.0$（埃）。\n- $k$-网格：$(4,4,1)$、$(8,8,1)$、$(16,16,1)$，对应的 $N_k$ 分别为 $16$、$64$、$256$。\n- $E_{\\text{slab}}$ 值：$-48.56$, $-48.60$, $-48.603$（电子伏特）。\n- $E_F$ 值：$7.00$, $7.00$, $7.00$（电子伏特）。\n- $V_{\\text{vac}}$ 值：$11.96$, $11.99$, $12.00$（电子伏特）。\n\n测试用例2（半导体板坯）：\n- $N = 18$，$A = 10.0$（平方埃，即 $1.0\\times 10^{-19}\\,\\text{m}^2$），$E_{\\text{bulk}} = -5.000$（电子伏特/原子），$t_{\\text{vac}} = 12.0$（埃）。\n- $k$-网格：$(4,4,1)$、$(8,8,1)$、$(16,16,1)$，对应的 $N_k$ 分别为 $16$、$64$、$256$。\n- $E_{\\text{slab}}$ 值：$-88.86$, $-88.88$, $-88.877$（电子伏特）。\n- $E_F$ 值：$6.15$, $6.15$, $6.15$（电子伏特）。\n- $V_{\\text{vac}}$ 值：$11.88$, $11.82$, $11.80$（电子伏特）。\n\n测试用例3（薄真空层的绝缘体板坯）：\n- $N = 20$，$A = 12.0$（平方埃，即 $1.2\\times 10^{-19}\\,\\text{m}^2$），$E_{\\text{bulk}} = -10.000$（电子伏特/原子），$t_{\\text{vac}} = 8.0$（埃）。\n- $k$-网格：$(4,4,1)$、$(8,8,1)$、$(16,16,1)$，对应的 $N_k$ 分别为 $16$、$64$、$256$。\n- $E_{\\text{slab}}$ 值：$-199.476$, $-199.520$, $-199.550$（电子伏特）。\n- $E_F$ 值：$1.00$, $1.00$, $1.00$（电子伏特）。\n- $V_{\\text{vac}}$ 值：$7.20$, $7.60$, $7.90$（电子伏特）。\n\n您的程序必须生成以下单行输出格式：一个包含三个内部列表的顶级列表（每个测试用例一个），每个内部列表按顺序包含七个值\n$[\\gamma_{\\text{dense}}\\ \\text{in}\\ \\text{J}/\\text{m}^2,\\ W_{\\text{dense}}\\ \\text{in}\\ \\text{eV},\\ \\text{is\\_}\\gamma\\_\\text{stable},\\ \\text{is\\_}W\\_\\text{stable},\\ s_{\\gamma},\\ s_{W},\\ \\text{is\\_}W\\_\\text{more\\_sensitive}]$，\n并按指定要求进行四舍五入。最终的单行必须是一个用方括号括起来的逗号分隔列表，例如 $[[\\dots],[\\dots],[\\dots]]$。", "solution": "该问题已经过验证，被认为是科学上合理、定义明确且客观的。它提出了一个材料科学中的标准计算练习，要求计算和分析板坯模型在不同倒易空间采样（$k$点网格）下的表面能和功函数。所有必要的数据、定义和约束条件都已提供。该问题没有矛盾或含糊之处。\n\n本文基于固态物理学和计算材料科学的基本原理，给出了一个完整、分步的解答。\n\n### 1. 理论框架\n\n#### 1.1. 单位面积的表面能（$\\gamma$）\n表面能 $\\gamma$ 量化了通过解理体相晶体来创造一个表面所需的单位面积额外能量。在使用对称超胞的板坯模型模拟中，会产生两个表面。板坯的总能量 $E_{\\text{slab}}$ 与等量原子 $N$ 在体相参考态下的能量进行比较。体相参考态的能量为 $N \\times E_{\\text{bulk}}$，其中 $E_{\\text{bulk}}$ 是体相晶体中每个原子的能量。\n\n创建两个面积为 $A$ 的表面所花费的总能量成本是板坯总能量与体相参考能量之间的差值：\n$$ \\Delta E = E_{\\text{slab}} - N E_{\\text{bulk}} $$\n由于该能量与两个表面相关，单位面积的表面能由下式给出：\n$$ \\gamma = \\frac{E_{\\text{slab}} - N E_{\\text{bulk}}}{2A} $$\n能量单位（$E_{\\text{slab}}$、$E_{\\text{bulk}}$）以电子伏特（$\\text{eV}$）给出，面积 $A$ 以平方埃（$\\text{\\AA}^2$）给出。$\\gamma$ 的最终结果要求以焦耳/平方米（$\\text{J}/\\text{m}^2$）表示。这需要进行单位换算。使用提供的换算因子：\n- $1\\,\\text{eV} = C_{J} = 1.602176634 \\times 10^{-19}\\,\\text{J}$\n- $1\\,\\text{\\AA}^2 = C_{m^2} = 10^{-20}\\,\\text{m}^2$\n\n所需单位下 $\\gamma$ 的计算公式变为：\n$$ \\gamma \\, [\\text{J}/\\text{m}^2] = \\frac{(E_{\\text{slab}}[\\text{eV}] - N \\cdot E_{\\text{bulk}}[\\text{eV}]) \\times C_{J}}{2 \\times A[\\text{\\AA}^2] \\times C_{m^2}} $$\n\n#### 1.2. 功函数（$W$）\n功函数 $W$ 是将一个电子从固体内部移到紧邻表面外一点所需的最小能量。在板坯模型计算的背景下，它被定义为真空区的静电势 $V_{\\text{vac}}$ 与板坯的费米能 $E_F$ 之间的差值。费米能代表电子的化学势。\n$$ W = V_{\\text{vac}} - E_F $$\n量 $V_{\\text{vac}}$ 和 $E_F$ 以电子伏特（$\\text{eV}$）给出，因此功函数 $W$ 也以 $\\text{eV}$ 表示。\n\n### 2. 收敛性分析流程\n\n该问题要求分析 $\\gamma$ 和 $W$ 相对于 $k$点网格密度的收敛性，该网格用于对板坯的二维布里渊区进行采样。\n\n1.  **识别网格**：对于每个测试用例，从提供的列表中确定最稀疏的网格（最小的 $N_k = n_x n_y$）和最密集的网格（最大的 $N_k$）。它们分别对应于 $N_k=16$ 的 $(4,4,1)$ 和 $N_k=256$ 的 $(16,16,1)$。\n\n2.  **计算物理量**：使用上述定义的公式和相应的输入数据（$E_{\\text{slab}}$、$V_{\\text{vac}}$、$E_F$），分别计算稀疏网格和密集网格下的 $\\gamma$ 和 $W$。将这些量表示为 $\\gamma_{\\text{sparse}}$、$W_{\\text{sparse}}$、$\\gamma_{\\text{dense}}$ 和 $W_{\\text{dense}}$。\n\n3.  **评估稳定性**：通过将稀疏网格和密集网格值之间的绝对差与给定的容差进行比较来评估稳定性。\n    - 如果 $|\\gamma_{\\text{sparse}} - \\gamma_{\\text{dense}}| \\le \\tau_{\\gamma}$，则 $\\gamma$ 是稳定的，其中 $\\tau_{\\gamma} = 0.05\\,\\text{J}/\\text{m}^2$。\n    - 如果 $|W_{\\text{sparse}} - W_{\\text{dense}}| \\le \\tau_{W}$，则 $W$ 是稳定的，其中 $\\tau_{W} = 0.05\\,\\text{eV}$。\n\n4.  **计算灵敏度分数**：为了量化每个物理量对 $k$点网格密度变化的敏感性，计算归一化的灵敏度分数：\n    - $s_{\\gamma} = \\frac{|\\gamma_{\\text{sparse}} - \\gamma_{\\text{dense}}|}{\\tau_{\\gamma}}$\n    - $s_{W} = \\frac{|W_{\\text{sparse}} - W_{\\text{dense}}|}{\\tau_{W}}$\n    分数大于1表示该量在指定容差内未收敛。\n\n5.  **比较灵敏度**：通过比较两个分数来确定相对灵敏度。如果 $s_{W} > s_{\\gamma}$，则认为功函数比表面能更敏感。\n\n### 3. 应用于测试用例1\n\n让我们将此流程应用于测试用例1：\n- **给定值**：$N = 14$，$A = 8.0\\,\\text{\\AA}^2$，$E_{\\text{bulk}} = -3.600\\,\\text{eV}$。\n- **稀疏网格数据（$N_k=16$）**：$E_{\\text{slab,sparse}} = -48.56\\,\\text{eV}$，$E_{F,\\text{sparse}} = 7.00\\,\\text{eV}$，$V_{\\text{vac,sparse}} = 11.96\\,\\text{eV}$。\n- **密集网格数据（$N_k=256$）**：$E_{\\text{slab,dense}} = -48.603\\,\\text{eV}$，$E_{F,\\text{dense}} = 7.00\\,\\text{eV}$，$V_{\\text{vac,dense}} = 12.00\\,\\text{eV}$。\n\n#### 计算：\n- **表面能（$\\gamma$）**：\n    - $\\Delta E_{\\text{sparse}} = -48.56 - 14(-3.600) = 1.84\\,\\text{eV}$。\n    - $\\gamma_{\\text{sparse}} = \\frac{1.84 \\times 1.602176634 \\times 10^{-19}}{2 \\times 8.0 \\times 10^{-20}} \\approx 1.84250\\,\\text{J}/\\text{m}^2$。\n    - $\\Delta E_{\\text{dense}} = -48.603 - 14(-3.600) = 1.797\\,\\text{eV}$。\n    - $\\gamma_{\\text{dense}} = \\frac{1.797 \\times 1.602176634 \\times 10^{-19}}{2 \\times 8.0 \\times 10^{-20}} \\approx 1.79945\\,\\text{J}/\\text{m}^2$。\n\n- **功函数（$W$）**：\n    - $W_{\\text{sparse}} = 11.96 - 7.00 = 4.96\\,\\text{eV}$。\n    - $W_{\\text{dense}} = 12.00 - 7.00 = 5.00\\,\\text{eV}$。\n\n#### 分析：\n- **密集网格值（四舍五入后）**：$\\gamma_{\\text{dense}} \\approx 1.799\\,\\text{J}/\\text{m}^2$ 且 $W_{\\text{dense}} = 5.000\\,\\text{eV}$。\n- **稳定性**：\n    - $|\\gamma_{\\text{sparse}} - \\gamma_{\\text{dense}}| = |1.84250 - 1.79945| = 0.04305\\,\\text{J}/\\text{m}^2$。由于 $0.04305 \\le 0.05$，$\\gamma$ 是稳定的（True）。\n    - $|W_{\\text{sparse}} - W_{\\text{dense}}| = |4.96 - 5.00| = 0.04\\,\\text{eV}$。由于 $0.04 \\le 0.05$，$W$ 是稳定的（True）。\n- **灵敏度分数**：\n    - $s_{\\gamma} = \\frac{0.04305}{0.05} \\approx 0.861$。\n    - $s_{W} = \\frac{0.04}{0.05} = 0.800$。\n- **灵敏度比较**：$s_{W} > s_{\\gamma}$ 是否成立？即 $0.800 > 0.861$ 是否成立？否（False）。\n\n对所有测试用例应用相同的步骤，从而得出最终的程序化解决方案。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs k-point convergence analysis for surface energy and work function\n    on a set of test cases for slab models.\n    \"\"\"\n    # Fundamental constants and tolerances\n    EV_TO_JOULE = 1.602176634e-19\n    ANGSTROM_SQ_TO_M_SQ = 1e-20\n    GAMMA_TOLERANCE = 0.05  # J/m^2\n    W_TOLERANCE = 0.05      # eV\n\n    test_cases = [\n        {\n            \"name\": \"Test Case 1 (metallic slab)\",\n            \"N\": 14, \"A\": 8.0, \"E_bulk\": -3.600,\n            \"E_slab\": [-48.56, -48.60, -48.603],\n            \"E_F\": [7.00, 7.00, 7.00],\n            \"V_vac\": [11.96, 11.99, 12.00]\n        },\n        {\n            \"name\": \"Test Case 2 (semiconductor slab)\",\n            \"N\": 18, \"A\": 10.0, \"E_bulk\": -5.000,\n            \"E_slab\": [-88.86, -88.88, -88.877],\n            \"E_F\": [6.15, 6.15, 6.15],\n            \"V_vac\": [11.88, 11.82, 11.80]\n        },\n        {\n            \"name\": \"Test Case 3 (insulator slab with thin vacuum)\",\n            \"N\": 20, \"A\": 12.0, \"E_bulk\": -10.000,\n            \"E_slab\": [-199.476, -199.520, -199.550],\n            \"E_F\": [1.00, 1.00, 1.00],\n            \"V_vac\": [7.20, 7.60, 7.90]\n        }\n    ]\n\n    all_results = []\n\n    def calculate_gamma(E_slab_val, N, E_bulk, A):\n        \"\"\"Calculates surface energy per unit area in J/m^2.\"\"\"\n        delta_E_eV = E_slab_val - N * E_bulk\n        delta_E_J = delta_E_eV * EV_TO_JOULE\n        area_m2 = A * ANGSTROM_SQ_TO_M_SQ\n        # Factor of 2 accounts for the two surfaces in a symmetric slab model.\n        return delta_E_J / (2 * area_m2)\n\n    def calculate_work_function(V_vac_val, E_F_val):\n        \"\"\"Calculates work function in eV.\"\"\"\n        return V_vac_val - E_F_val\n\n    for case in test_cases:\n        N = case[\"N\"]\n        A = case[\"A\"]\n        E_bulk = case[\"E_bulk\"]\n        \n        # Convert lists to numpy arrays for convenient indexing\n        E_slab = np.array(case[\"E_slab\"])\n        E_F = np.array(case[\"E_F\"])\n        V_vac = np.array(case[\"V_vac\"])\n        \n        # Data for sparse (first element) and dense (last element) meshes\n        E_slab_sparse, E_slab_dense = E_slab[0], E_slab[-1]\n        E_F_sparse, E_F_dense = E_F[0], E_F[-1]\n        V_vac_sparse, V_vac_dense = V_vac[0], V_vac[-1]\n\n        # Calculate quantities for sparse and dense meshes\n        gamma_sparse = calculate_gamma(E_slab_sparse, N, E_bulk, A)\n        gamma_dense = calculate_gamma(E_slab_dense, N, E_bulk, A)\n        \n        w_sparse = calculate_work_function(V_vac_sparse, E_F_sparse)\n        w_dense = calculate_work_function(V_vac_dense, E_F_dense)\n\n        # Perform stability and sensitivity analysis\n        gamma_diff = np.abs(gamma_sparse - gamma_dense)\n        is_gamma_stable = gamma_diff = GAMMA_TOLERANCE\n        \n        w_diff = np.abs(w_sparse - w_dense)\n        is_w_stable = w_diff = W_TOLERANCE\n        \n        s_gamma = gamma_diff / GAMMA_TOLERANCE\n        s_w = w_diff / W_TOLERANCE\n        \n        is_w_more_sensitive = s_w > s_gamma\n        \n        case_result = [\n            gamma_dense,\n            w_dense,\n            is_gamma_stable,\n            is_w_stable,\n            s_gamma,\n            s_w,\n            is_w_more_sensitive\n        ]\n        all_results.append(case_result)\n\n    # Format the final output string as specified\n    output_str_parts = []\n    for res in all_results:\n        part = (\n            f\"[{res[0]:.3f},\"\n            f\"{res[1]:.3f},\"\n            f\"{str(bool(res[2]))},\"\n            f\"{str(bool(res[3]))},\"\n            f\"{res[4]:.3f},\"\n            f\"{res[5]:.3f},\"\n            f\"{str(bool(res[6]))}]\"\n        )\n        output_str_parts.append(part)\n        \n    print(f\"[{','.join(output_str_parts)}]\")\n\nsolve()\n```", "id": "3487639"}, {"introduction": "除了倒空間采样，模拟中有限的板层厚度和真空层厚度是另一个主要的误差来源，它们会引入量子限制效应和周期性镜像之间的伪相互作用。这个练习 ([@problem_id:3487626]) 提出了一个更高级且实用的方案，不仅是为了收敛这些参数，更是为了利用渐近展开将结果外推到具有物理意义的无限厚板层和真空的极限。掌握这项技术，您将能够在有效管理计算成本的同时，获得高精度的预测结果。", "problem": "您正在使用周期性边界条件下具有有限真空区的板坯模型来模拟晶体表面的功函数。该板坯具有可变数量的原子层，真空区具有可变的厚度。由于有限尺寸和周期性镜像效应，计算出的功函数取决于板坯厚度和真空厚度。您将实施一个收敛协议，以确定达到目标功函数容差所需的最小板坯厚度和真空厚度，并且您将推导并拟合一个关于板坯厚度倒数和真空厚度倒数的外推定律，以估算在无限厚板坯和无限厚真空极限下的功函数。\n\n使用以下符合上下文的基本原理：\n- 功函数定义为真空能级与费米能级之间的差值。在周期性边界条件下，真空能级是通过真空区中的静电势对齐获得的。\n- 板坯及其周期性镜像的静电学由泊松方程控制，这意味着在三维周期性边界条件下，分离偶极子的相互作用能随分离距离成反比衰减。因此，由于跨越真空的偶极-偶极耦合，由板坯-镜像相互作用在真空中引起的功函数的前导有限尺寸修正常数与真空厚度的倒数成正比。有限的板坯厚度引入了量子限制效应和板坯两个表面之间的残余相互作用，这与板坯厚度的倒数成正比。当两种效应共存时，会出现一个混合修正项，其与板坯厚度和真空厚度的乘积成反比。这些陈述在密度泛函理论计算中被广泛观察到，并且与渐近区域中的线性响应一致。\n\n任务：\n1. 假设计算出的功函数（以电子伏特为单位）作为板坯层数和真空厚度的函数具有以下渐近展开式：\n   $$\\Phi(N,L_{\\text{vac}}) = \\Phi_{\\infty} + \\frac{A_N}{N} + \\frac{A_L}{L_{\\text{vac}}} + \\frac{A_{NL}}{N\\,L_{\\text{vac}}},$$\n   其中 $N$ 是板坯厚度的原子层数（一个整数），$L_{\\text{vac}}$ 是真空厚度（单位为埃），$\\Phi_{\\infty}$ 是无限板坯无限真空的功函数（单位为电子伏特），$A_N$、$A_L$、$A_{NL}$ 是未知系数，其单位使得每一项的单位都是电子伏特。\n\n2. 对于每个测试用例，执行线性最小二乘拟合，从提供的数据点 $\\{(N_i, L_{\\text{vac},i}, \\Phi_i)\\}$ 中确定 $\\Phi_{\\infty}$、$A_N$、$A_L$、$A_{NL}$。\n\n3. 设计一个收敛协议，以推荐最小整数 $N$ 和最小整数 $L_{\\text{vac}}$，使得估计的总残余有限尺寸修正\n   $$E_{\\text{res}}(N,L_{\\text{vac}}) = \\left|\\frac{A_N}{N}\\right| + \\left|\\frac{A_L}{L_{\\text{vac}}}\\right| + \\left|\\frac{A_{NL}}{N\\,L_{\\text{vac}}}\\right|$$\n   小于或等于一个指定的目标容差 $\\tau$（单位为电子伏特）。为避免将误差过度分配给任何单个项，使用相等的分配权重，即分配部分目标\n   $$\\left|\\frac{A_N}{N}\\right| \\leq \\frac{\\tau}{3}, \\quad \\left|\\frac{A_L}{L_{\\text{vac}}}\\right| \\leq \\frac{\\tau}{3}, \\quad \\left|\\frac{A_{NL}}{N\\,L_{\\text{vac}}}\\right| \\leq \\frac{\\tau}{3}.$$\n   从满足前两个不等式的最小整数开始，最小化地调整 $N$ 和 $L_{\\text{vac}}$ 以同时满足第三个不等式，然后，如果需要，进一步增加一个或两者以确保 $E_{\\text{res}}(N,L_{\\text{vac}}) \\leq \\tau$。\n\n4. 对于每个测试用例，报告：\n   - 拟合得到的 $\\Phi_{\\infty}$，四舍五入到 $3$ 位小数，单位为电子伏特。\n   - 推荐的最小整数 $N$（原子层数）。\n   - 推荐的最小整数 $L_{\\text{vac}}$（埃）。\n   - 一个布尔值，指示起始构型 $(N_0, L_{\\text{vac},0})$ 是否满足容差，即 $E_{\\text{res}}(N_0, L_{\\text{vac},0}) \\leq \\tau$ 是否成立。\n\n物理和数值单位：\n- 所有功函数必须以电子伏特为单位。\n- 真空厚度必须以埃为单位。\n- 板坯厚度必须是整数个原子层。\n\n角度单位不相关，不得出现。将布尔值输出表示为 $True$ 或 $False$，不带任何其他文本。将浮点数表示为十进制数。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的每个测试用例列表的列表，每个测试用例列表包含 $[\\Phi_{\\infty}, N, L_{\\text{vac}}, \\text{boolean}]$，所有内容都用方括号括起来，如下所示：\n“您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[[\\phi_1,N_1,L_1,True],[\\phi_2,N_2,L_2,False]]$）。”\n\n测试套件：\n- 测试用例 $1$（具有非零交叉项的一般情况）：\n  - 数据点 $(N, L_{\\text{vac}}, \\Phi)$:\n    - $(6, 12, 5.3573611)$,\n    - $(8, 12, 5.3521875)$,\n    - $(10, 12, 5.3490833)$,\n    - $(6, 16, 5.3530208)$,\n    - $(8, 16, 5.3478906)$,\n    - $(10, 16, 5.3448125)$,\n    - $(6, 20, 5.3504167)$,\n    - $(8, 20, 5.3453125)$,\n    - $(10, 20, 5.34225)$.\n  - 目标容差 $\\tau = 0.02$ 电子伏特。\n  - 起始构型 $(N_0, L_{\\text{vac},0}) = (10, 16)$。\n\n- 测试用例 $2$（交叉项为零的边界情况）：\n  - 数据点 $(N, L_{\\text{vac}}, \\Phi)$:\n    - $(3, 8, 4.9708333)$,\n    - $(3, 10, 4.9633333),\n    - $(3, 12, 4.958333),\n    - $(4, 8, 4.9375)$,\n    - $(4, 10, 4.93)$,\n    - $(4, 12, 4.925)$,\n    - $(5, 8, 4.9175)$,\n    - $(5, 10, 4.91)$,\n    - $(5, 12, 4.905)$.\n  - 目标容差 $\\tau = 0.05$ 电子伏特。\n  - 起始构型 $(N_0, L_{\\text{vac},0}) = (5, 10)$。\n\n- 测试用例 $3$（具有强交叉项和中等真空效应的边缘情况）：\n  - 数据点 $(N, L_{\\text{vac}}, \\Phi)$:\n    - $(5, 10, 5.165)$,\n    - $(5, 20, 5.1525)$,\n    - $(5, 30, 5.1483333)$,\n    - $(7, 10, 5.1507143)$,\n    - $(7, 20, 5.1396429)$,\n    - $(7, 30, 5.1359524)$,\n    - $(9, 10, 5.1427778)$,\n    - $(9, 20, 5.1325)$,\n    - $(9, 30, 5.1290741)$.\n  - 目标容差 $\\tau = 0.03$ 电子伏特。\n  - 起始构型 $(N_0, L_{\\text{vac},0}) = (7, 20)$。\n\n您的程序应计算拟合参数，根据指定的收敛协议确定推荐的最小 $N$ 和 $L_{\\text{vac}}$，并根据容差评估起始构型。最终的单行输出必须是：\n- 一个包含三个每个测试用例列表 $[\\Phi_{\\infty}, N, L_{\\text{vac}}, \\text{boolean}]$ 的单一列表，精确打印为一行，具有嵌套的方括号和逗号分隔的值，其中 $\\Phi_{\\infty}$ 四舍五入到 $3$ 位小数。", "solution": "该问题要求分析板坯模型中功函数计算的有限尺寸效应，并实施一个收敛协议。解决方案涉及两个主要阶段：首先，通过对给定数据进行线性最小二乘拟合，确定给定渐近模型的参数；其次，应用指定的收敛协议，找到满足给定误差容差的最小板坯和真空厚度。\n\n功函数 $\\Phi$ 作为原子层数 $N$ 和真空厚度 $L_{\\text{vac}}$ 函数的给定渐近展开式为：\n$$ \\Phi(N,L_{\\text{vac}}) = \\Phi_{\\infty} + \\frac{A_N}{N} + \\frac{A_L}{L_{\\text{vac}}} + \\frac{A_{NL}}{N\\,L_{\\text{vac}}} $$\n该方程对于未知系数 $\\mathbf{c} = [\\Phi_{\\infty}, A_N, A_L, A_{NL}]^T$ 是线性的。给定一组 $M$ 个数据点 $\\{(N_i, L_{\\text{vac},i}, \\Phi_i)\\}_{i=1}^M$，我们可以构建一个线性方程组。对于每个数据点 $i$，我们定义一个特征向量 $\\mathbf{x}_i = [1, 1/N_i, 1/L_{\\text{vac},i}, 1/(N_i L_{\\text{vac},i})]$。然后，模型可以表示为矩阵形式 $\\mathbf{y} \\approx \\mathbf{X}\\mathbf{c}$，其中 $\\mathbf{y}$ 是观测到的功函数 $\\Phi_i$ 的向量，$\\mathbf{X}$ 是一个 $M \\times 4$ 的设计矩阵，其行是特征向量 $\\mathbf{x}_i$。\n\n最佳拟合系数 $\\mathbf{c}$ 是通过最小化残差平方和 $\\|\\mathbf{y} - \\mathbf{X}\\mathbf{c}\\|^2$ 来找到的。这是一个标准的线性最小二乘问题。其解的正式形式为 $\\mathbf{c} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$，我们为了稳健性而数值求解它，例如，使用 `numpy.linalg.lstsq` 中实现的奇异值分解。\n\n一旦确定了系数 $\\Phi_{\\infty}$、$A_N$、$A_L$ 和 $A_{NL}$，我们便进入收敛协议，以找到最小的整数板坯厚度 $N$ 和真空厚度 $L_{\\text{vac}}$，确保总残余有限尺寸修正 $E_{\\text{res}}$ 低于目标容差 $\\tau$。残余误差定义为：\n$$ E_{\\text{res}}(N,L_{\\text{vac}}) = \\left|\\frac{A_N}{N}\\right| + \\left|\\frac{A_L}{L_{\\text{vac}}}\\right| + \\left|\\frac{A_{NL}}{N\\,L_{\\text{vac}}}\\right| $$\n该协议指定使用均等误差分配，这意味着要满足三个部分目标：\n$$ \\left|\\frac{A_N}{N}\\right| \\leq \\frac{\\tau}{3}, \\quad \\left|\\frac{A_L}{L_{\\text{vac}}}\\right| \\leq \\frac{\\tau}{3}, \\quad \\left|\\frac{A_{NL}}{N\\,L_{\\text{vac}}}\\right| \\leq \\frac{\\tau}{3} $$\n确定最小 $N$ 和 $L_{\\text{vac}}$ 的协议执行如下：\n$1$. 从第一个不等式确定最小整数 $N$。由于 $N$ 必须至少为 $1$，我们有：\n$$ N_{\\text{rec}} = \\max\\left(1, \\left\\lceil \\frac{3|A_N|}{\\tau} \\right\\rceil\\right) $$\n$2$. 确定满足第二个不等式的最小整数 $L_{\\text{vac}}$。由于 $L_{\\text{vac}}$ 必须至少为 $1$，我们有一个初始候选值：\n$$ L_{\\text{vac},1} = \\max\\left(1, \\left\\lceil \\frac{3|A_L|}{\\tau} \\right\\rceil\\right) $$\n$3$. 给定步骤 $1$ 中的 $N_{\\text{rec}}$ 值，调整 $L_{\\text{vac}}$ 以同时满足第三个不等式。根据计算材料科学中的常见做法，“最小化地调整”被解释为保持 $N$ 固定（因为它对计算成本影响更大）并根据需要增加 $L_{\\text{vac}}$。这导致 $L_{\\text{vac}}$ 的第二个候选值：\n$$ L_{\\text{vac},2} = \\left\\lceil \\frac{3|A_{NL}|}{N_{\\text{rec}}\\,\\tau} \\right\\rceil $$\n所需的最小 $L_{\\text{vac}}$ 必须满足两个约束条件，因此我们取两个候选值的最大值：\n$$ L_{\\text{vac,rec}} = \\max(L_{\\text{vac},1}, L_{\\text{vac},2}) $$\n$4$. 对 $(N_{\\text{rec}}, L_{\\text{vac,rec}})$ 通过构造已经满足了所有三个部分目标不等式。将这些不等式相加可以保证总残余误差 $E_{\\text{res}}(N_{\\text{rec}}, L_{\\text{vac,rec}}) \\leq \\tau/3 + \\tau/3 + \\tau/3 = \\tau$。因此，“如果需要，进一步增加一个或两者”这一条款不需要额外的步骤，因为条件已经满足。对 $(N_{\\text{rec}}, L_{\\text{vac,rec}})$ 是推荐的最小构型。\n\n最后，对于每个测试用例，我们通过计算 $E_{\\text{res}}(N_0, L_{\\text{vac},0})$ 并将其与 $\\tau$ 进行比较，来评估所提供的起始构型 $(N_0, L_{\\text{vac},0})$ 是否满足容差。拟合得到的 $\\Phi_{\\infty}$ 值报告时四舍五入到 $3$ 位小数。\n\n为每个提供的测试用例实施这整个过程。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"data\": [\n                (6, 12, 5.3573611), (8, 12, 5.3521875), (10, 12, 5.3490833),\n                (6, 16, 5.3530208), (8, 16, 5.3478906), (10, 16, 5.3448125),\n                (6, 20, 5.3504167), (8, 20, 5.3453125), (10, 20, 5.34225),\n            ],\n            \"tau\": 0.02,\n            \"start_config\": (10, 16)\n        },\n        {\n            \"data\": [\n                (3, 8, 4.9708333), (3, 10, 4.9633333), (3, 12, 4.958333),\n                (4, 8, 4.9375), (4, 10, 4.93), (4, 12, 4.925),\n                (5, 8, 4.9175), (5, 10, 4.91), (5, 12, 4.905),\n            ],\n            \"tau\": 0.05,\n            \"start_config\": (5, 10)\n        },\n        {\n            \"data\": [\n                (5, 10, 5.165), (5, 20, 5.1525), (5, 30, 5.1483333),\n                (7, 10, 5.1507143), (7, 20, 5.1396429), (7, 30, 5.1359524),\n                (9, 10, 5.1427778), (9, 20, 5.1325), (9, 30, 5.1290741),\n            ],\n            \"tau\": 0.03,\n            \"start_config\": (7, 20)\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        result = _solve_single_case(case[\"data\"], case[\"tau\"], case[\"start_config\"])\n        \n        phi_inf, N_rec, Lvac_rec, is_converged_0 = result\n        \n        # Format the sublist string to match the required output format exactly.\n        sub_result_str = f\"[{phi_inf:.3f},{N_rec},{Lvac_rec},{str(is_converged_0)}]\"\n        results_as_strings.append(sub_result_str)\n\n    # Print the final combined string.\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef _solve_single_case(data, tau, start_config):\n    \"\"\"\n    Solves a single test case according to the problem description.\n    \"\"\"\n    points = np.array(data)\n    N_vals = points[:, 0]\n    Lvac_vals = points[:, 1]\n    Phi_vals = points[:, 2]\n\n    # 1. Linear Least Squares Fit\n    # Construct the design matrix X\n    X = np.zeros((len(points), 4))\n    X[:, 0] = 1.0\n    X[:, 1] = 1.0 / N_vals\n    X[:, 2] = 1.0 / Lvac_vals\n    X[:, 3] = 1.0 / (N_vals * Lvac_vals)\n    \n    # Solve the linear system Xc = y for the coefficients c\n    coeffs, _, _, _ = np.linalg.lstsq(X, Phi_vals, rcond=None)\n    Phi_inf, A_N, A_L, A_NL = coeffs\n\n    # 2. Convergence Protocol\n    # Minimal N from the first partial target\n    # N is an integer number of layers, so it must be at least 1.\n    N_rec = math.ceil(3 * abs(A_N) / tau) if tau > 0 else float('inf')\n    N_rec = max(1, N_rec)\n\n    # Minimal L_vac from the second partial target\n    # L_vac must be at least 1 Angstrom.\n    Lvac_rec_1 = math.ceil(3 * abs(A_L) / tau) if tau > 0 else float('inf')\n    Lvac_rec_1 = max(1, Lvac_rec_1)\n    \n    # L_vac required by the third partial target, given N_rec\n    if abs(A_NL) > 1e-12 and N_rec > 0 and tau > 0:\n        Lvac_rec_2 = math.ceil(3 * abs(A_NL) / (N_rec * tau))\n    else:\n        Lvac_rec_2 = 1 # Minimal Lvac is 1\n\n    # The final L_vac must satisfy both constraints.\n    Lvac_rec = max(Lvac_rec_1, Lvac_rec_2)\n    \n    # The condition E_res = tau is guaranteed by construction. The \"further increase\"\n    # step is not necessary as explained in the solution.\n    \n    # 3. Check Starting Configuration\n    N0, Lvac0 = start_config\n    \n    def calculate_residual(N, Lvac):\n        if N == 0 or Lvac == 0:\n            return float('inf')\n        return abs(A_N)/N + abs(A_L)/Lvac + abs(A_NL)/(N * Lvac)\n\n    err0 = calculate_residual(N0, Lvac0)\n    is_converged_0 = err0 = tau\n\n    return [Phi_inf, int(N_rec), int(Lvac_rec), is_converged_0]\n\nsolve()\n```", "id": "3487626"}]}