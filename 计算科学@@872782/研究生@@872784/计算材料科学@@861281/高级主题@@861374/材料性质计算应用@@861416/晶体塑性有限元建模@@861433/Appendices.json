{"hands_on_practices": [{"introduction": "在晶体塑性有限元建模中，精确追踪晶格的旋转是至关重要的，因为材料的各向异性属性是相对于晶格方向定义的。本练习旨在通过推导和实现晶格旋转的更新算法，来加深对变形运动学核心概念的理解。通过这个实践 ([@problem_id:3441906])，您将学习如何确保旋转矩阵在数值积分过程中始终保持其在特殊正交群 $SO(3)$ 中的特性，这是保证模拟物理真实性的关键一步。", "problem": "您的任务是在晶体塑性有限元法（CPFEM; Crystal Plasticity Finite Element Method）背景下，推导、实现并测试一个晶格旋转更新方案。从乘法运动学和经典的时间变化率定义出发，并演示斜对称晶格自旋是如何产生的。然后，构建一个离散积分程序，该程序在更新晶格旋转的同时，保持其在三维特殊正交群（SO(3); Special Orthogonal Group of degree three）中的成员资格。\n\n推导任务：\n- 从运动学乘法分解 $F = F^{e} F^{p}$ 开始，其中 $F$ 是变形梯度，$F^{e}$ 是弹性变形梯度，$F^{p}$ 是塑性变形梯度。\n- 使用物质时间导数 $\\,\\dot{(\\cdot)}\\,$ 定义弹性速度梯度 $L^{e} = \\dot{F}^{e} (F^{e})^{-1}$。\n- 引入极分解 $F^{e} = R^{e} U^{e}$，其中 $R^{e} \\in \\mathrm{SO}(3)$ 是晶格旋转，$U^{e}$ 是对称正定的弹性右拉伸张量。\n- 将晶格自旋推导为弹性速度梯度的斜对称部分。您的推导必须明确使用 $R^{e}$ 的正交性和 $U^{e}$ 的对称性，并且必须从上述基本定义出发，不使用这些基础之外的任何捷径公式。\n\n积分任务：\n- 构建一个积分方案，用于在时间步长 $\\Delta t$ 内更新 $R^{e}$，并保证在步长结束时 $R^{e} \\in \\mathrm{SO}(3)$。该方案必须基于应用于晶格自旋的 $\\mathfrak{so}(3)$（$\\mathrm{SO}(3)$ 的李代数）上的矩阵指数，并且可以使用步长内的前向评估或中点评估。\n- 更新必须以 $\\mathbb{R}^{3 \\times 3}$ 中的斜对称矩阵形式写出，并且必须在数学上证明为什么更新过程会保持 $R^{e}$ 的正交性。\n\n实现与测试套件：\n- 在一个程序中实现您的方案，为以下四个测试用例计算旋转更新。角度必须以弧度为单位，时间以秒为单位。\n- 使用的定义：\n    - 对于向量 $\\omega \\in \\mathbb{R}^{3}$，将其关联的斜对称映射 $[\\omega]_{\\times} \\in \\mathbb{R}^{3 \\times 3}$ 定义为\n      $$[\\omega]_{\\times} = \\begin{bmatrix} 0  -\\omega_{3}  \\omega_{2} \\\\ \\omega_{3}  0  -\\omega_{1} \\\\ -\\omega_{2}  \\omega_{1}  0 \\end{bmatrix}。$$\n    - 对于任何 $A \\in \\mathbb{R}^{3 \\times 3}$，定义 $\\operatorname{skw}(A) = \\tfrac{1}{2}(A - A^{\\top})$。\n    - $\\mathbb{R}^{3 \\times 3}$ 上的矩阵指数 $\\exp(\\cdot)$ 是线性代数中的标准定义。\n\n- 测试用例：\n    1. 恒定晶格自旋（正常路径）：$\\omega = [0.1,\\,0.2,\\,-0.05]$，其中 $R^{e}(0) = I$，$\\Delta t = 0.01$ s，$N = 100$ 步。使用自旋的中点评估；$T = N \\Delta t$ 后的精确旋转为 $\\exp(T [\\omega]_{\\times})$。\n    2. 零晶格自旋（边界情况）：$\\omega(t) \\equiv [0,\\,0,\\,0]$，其中 $R^{e}(0) = \\exp(0.3\\,[e_{y}]_{\\times})$，$\\Delta t = 0.05$ s，$N = 10$ 步。旋转必须保持恒定。\n    3. 弹性拉伸与旋转共存（检查 $\\operatorname{skw}(L^{e})$ 的边缘情况）：设 $U^{e}(t) = \\mathrm{diag}(\\exp(\\alpha t),\\,\\exp(\\beta t),\\,\\exp(\\gamma t))$，其中 $(\\alpha,\\beta,\\gamma) = (0.2,-0.1,0.0)$，单位为 $\\mathrm{s}^{-1}$。设 $R^{e}(t)$ 是绕 $e_{z}$ 的旋转，角速率恒为 $\\omega_{z} = 0.5$ $\\mathrm{rad/s}$，因此 $R^{e}(t) = \\exp(t\\,[e_{z}]_{\\times}\\,\\omega_{z})$。定义 $L^{e}(t) = \\dot{F}^{e}(t)\\,(F^{e}(t))^{-1}$，其中 $F^{e}(t) = R^{e}(t)\\,U^{e}(t)$；计算 $\\operatorname{skw}(L^{e}(t))$ 并用其更新 $R^{e}$。使用 $\\Delta t = 0.02$ s，$N = 100$，$R^{e}(0) = I$。在 $T$ 时刻的精确旋转是 $\\exp(T\\,[e_{z}]_{\\times}\\,\\omega_{z})$。\n    4. 绕固定轴的时间相关晶格自旋（可交换情况，大步长）：$\\omega(t) = [\\omega_{0}\\sin(\\nu t),\\,0,\\,0]$，其中 $\\omega_{0}=1.2$ $\\mathrm{rad/s}$，$\\nu=0.8$ $\\mathrm{rad/s}$，$R^{e}(0) = I$，$\\Delta t = 0.2$ s，$N = 25$。使用中点评估。在 $T$ 时刻的精确旋转是 $\\exp(\\theta(T)\\,[e_{x}]_{\\times})$，其中 $\\theta(T) = \\int_{0}^{T}\\omega_{0}\\sin(\\nu t)\\,dt = \\frac{\\omega_{0}}{\\nu}\\bigl(1 - \\cos(\\nu T)\\bigr)$。\n\n- 对于每个测试用例，计算并返回两个误差度量：\n    - 数值更新的旋转与最终时刻 $T$ 的精确旋转之差的弗罗贝尼乌斯范数，即 $\\|R^{e}_{\\text{num}}(T) - R^{e}_{\\text{exact}}(T)\\|_{F}$。\n    - 最终时刻正交性破坏的弗罗贝尼乌斯范数，即 $\\|R^{e}_{\\text{num}}(T)^{\\top} R^{e}_{\\text{num}}(T) - I\\|_{F}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个包含两个浮点数的列表，顺序与上述规定相同。例如，输出格式必须类似于“[[e11,e12],[e21,e22],[e31,e32],[e41,e42]]”，其中 $e_{i1}$ 是测试用例 $i$ 的旋转误差，$e_{i2}$ 是正交性误差。\n\n所有角度必须以弧度为单位，所有时间必须以秒为单位，每个误差值必须作为浮点数返回。", "solution": "推导始于晶体塑性的运动学框架。变形梯度 $F$ 接受乘法分解 $F = F^{e} F^{p}$，该分解区分了弹性晶格畸变 $F^{e}$ 和塑性畸变 $F^{p}$。弹性速度梯度由 $L^{e} = \\dot{F}^{e} (F^{e})^{-1}$ 定义，其中 $\\dot{(\\cdot)}$ 表示物质时间导数。弹性变形梯度接受极分解 $F^{e} = R^{e} U^{e}$，其中 $R^{e} \\in \\mathrm{SO}(3)$ 是一个正交旋转，满足 $\\det(R^{e}) = 1$，$U^{e}$ 是一个对称正定的右拉伸张量。\n\n对 $F^{e} = R^{e} U^{e}$ 关于时间求导，得到 $\\dot{F}^{e} = \\dot{R}^{e} U^{e} + R^{e} \\dot{U}^{e}$。乘以 $(F^{e})^{-1} = (U^{e})^{-1} R^{e\\top}$ 得到\n$$\nL^{e} = \\dot{F}^{e} (F^{e})^{-1} = \\dot{R}^{e} U^{e} (U^{e})^{-1} R^{e\\top} + R^{e}\\left(\\dot{U}^{e} (U^{e})^{-1}\\right)R^{e\\top}\n= \\dot{R}^{e} R^{e\\top} + R^{e}\\left(\\dot{U}^{e} (U^{e})^{-1}\\right)R^{e\\top}.\n$$\n第一项 $\\dot{R}^{e} R^{e\\top}$ 是斜对称的。要证明这一点，注意到 $R^{e}$ 的正交性意味着 $R^{e\\top} R^{e} = I$，因此求导得到 $\\dot{R}^{e\\top} R^{e} + R^{e\\top} \\dot{R}^{e} = 0$，所以\n$$\n\\left(\\dot{R}^{e} R^{e\\top}\\right)^{\\top} = R^{e} \\dot{R}^{e\\top} = - \\dot{R}^{e} R^{e\\top}.\n$$\n第二项 $R^{e}\\left(\\dot{U}^{e} (U^{e})^{-1}\\right)R^{e\\top}$ 是对称的，因为 $U^{e}$ 是对称正定的。确实，$U^{e}$ 允许正交谱分解 $U^{e} = Q \\Lambda Q^{\\top}$，其中 $Q \\in \\mathrm{SO}(3)$ 且 $\\Lambda$ 为正对角矩阵。在同旋主基中，求导并构造 $\\dot{U}^{e} (U^{e})^{-1}$ 会得到一个对角算子（主拉伸率除以主拉伸），因此是对称的；通过 $R^{e}$ 的正交合同变换保持对称性。因此，取其斜对称部分，\n$$\n\\operatorname{skw}(L^{e}) = \\operatorname{skw}\\bigl(\\dot{R}^{e} R^{e\\top}\\bigr) = \\dot{R}^{e} R^{e\\top},\n$$\n晶格自旋被确定为与晶格旋转速率相关的斜对称张量。该对象位于由 $3 \\times 3$ 斜对称矩阵构成的李代数 $\\mathfrak{so}(3)$ 中。\n\n接下来，$R^{e}$ 的演化遵循旋转运动学。定义角速度张量 $W^{e} = \\operatorname{skw}(L^{e}) \\in \\mathfrak{so}(3)$。与群结构一致的旋转速率方程为\n$$\n\\dot{R}^{e} = W^{e} R^{e}.\n$$\n左乘 $R^{e\\top}$ 得到 $R^{e\\top}\\dot{R}^{e} = R^{e\\top} W^{e} R^{e}$，且左侧是斜对称的，因为 $R^{e\\top}\\dot{R}^{e} = - \\bigl(R^{e\\top}\\dot{R}^{e}\\bigr)^{\\top}$，这与 $W^{e} \\in \\mathfrak{so}(3)$ 一致。在大小为 $\\Delta t$ 的时间步长上的解由李群指数更新给出\n$$\nR^{e}(t+\\Delta t) = \\exp\\bigl(\\Delta t\\, W^{e}_{\\star}\\bigr)\\, R^{e}(t),\n$$\n其中 $W^{e}_{\\star}$ 是在该区间上对 $W^{e}$ 的适当近似，例如 $W^{e}(t)$（前向欧拉法）或 $W^{e}(t+\\Delta t/2)$（中点法）。因为 $W^{e}_{\\star}$ 是斜对称的，所以 $\\exp(\\Delta t\\,W^{e}_{\\star})$ 是一个单位行列式的正交矩阵，因此该更新保持 $R^{e} \\in \\mathrm{SO}(3)$。这源于以下事实：对于任何斜对称矩阵 $A$，$\\exp(A)$ 是正交的，因为 $\\exp(A)^{\\top}\\exp(A) = \\exp(A^{\\top}) \\exp(A) = \\exp(-A)\\exp(A) = I$，并且 $\\det(\\exp(A)) = \\exp(\\operatorname{tr}(A)) = 1$ 因为 $\\operatorname{tr}(A)=0$。\n\n实现的算法设计：\n- 通过斜对称矩阵 $W^{e}(t) \\in \\mathbb{R}^{3 \\times 3}$ 来表示自旋，该矩阵可以直接通过 $[\\cdot]_{\\times}$ 算子从指定的角速度向量生成，或者在 $L^{e}(t)$ 已知时通过 $W^{e}(t) = \\operatorname{skw}(L^{e}(t))$ 生成。\n- 为提高精度，使用中点评估 $W^{e}_{\\star} = W^{e}(t+\\Delta t/2)$。计算增量旋转 $R_{\\Delta} = \\exp(\\Delta t\\, W^{e}_{\\star})$ 并更新 $R^{e} \\leftarrow R_{\\Delta} R^{e}$。\n- 矩阵指数可以通过标准的线性代数方法进行稳健评估。对于斜对称矩阵，也可以等效地使用从 $\\mathfrak{so}(3)$ 到 $\\mathrm{SO}(3)$ 的映射推导出的 Rodrigues’ formula，但直接的指数计算更通用且简洁。\n\n测试用例构造：\n- 测试用例 1：恒定自旋 $\\omega = [0.1, 0.2, -0.05]$ 产生 $W^{e}(t) \\equiv [\\omega]_{\\times}$ 和精确解 $R^{e}(T) = \\exp(T [\\omega]_{\\times})$。\n- 测试用例 2：零自旋，$R^{e}(0) = \\exp(0.3\\,[e_{y}]_{\\times})$ 且 $W^{e}(t) \\equiv 0$，得到 $R^{e}(T) = R^{e}(0)$。\n- 测试用例 3：$F^{e}(t) = R^{e}(t)\\,U^{e}(t)$，其中 $R^{e}(t)$ 是绕 $e_{z}$ 的恒定速率旋转，$U^{e}(t) = \\mathrm{diag}(\\exp(\\alpha t),\\,\\exp(\\beta t),\\,\\exp(\\gamma t))$。计算\n$$\nL^{e}(t) = \\dot{F}^{e}(t)\\,(F^{e}(t))^{-1} = \\dot{R}^{e}(t)\\,R^{e}(t)^{\\top} + R^{e}(t)\\,\\bigl(\\dot{U}^{e}(t)\\,(U^{e}(t))^{-1}\\bigr)\\,R^{e}(t)^{\\top},\n$$\n然后 $W^{e}(t) = \\operatorname{skw}(L^{e}(t))$。对于所选的对角 $U^{e}$ 和绕 $e_{z}$ 的旋转，第二项是对称的，而第一项是 $\\omega_{z}[e_{z}]_{\\times}$，从而恢复预期的自旋。\n- 测试用例 4：绕 $e_{x}$ 的时间相关自旋 $\\omega(t) = [\\omega_{0}\\sin(\\nu t), 0, 0]$。由于生成元是固定的，精确解为 $R^{e}(T) = \\exp(\\theta(T)\\,[e_{x}]_{\\times})$，其中 $\\theta(T) = \\frac{\\omega_{0}}{\\nu}(1 - \\cos(\\nu T))$。\n\n误差度量：\n- 对于每种情况，计算 $\\|R^{e}_{\\text{num}}(T) - R^{e}_{\\text{exact}}(T)\\|_{F}$ 以衡量积分精度，计算 $\\|R^{e}_{\\text{num}}(T)^{\\top} R^{e}_{\\text{num}}(T) - I\\|_{F}$ 以衡量正交性保持情况。\n- 最终输出是这四种情况下这些误差对的列表，以指定格式打印为单行。\n\n这种方法确保了更新尊重旋转的群结构，并将晶格自旋锚定为弹性速度梯度的斜对称部分，这是严格地从乘法分解和极坐标运动学推导出来的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef hat(omega):\n    \"\"\"Return the skew-symmetric matrix [omega]_x for omega in R^3.\"\"\"\n    wx, wy, wz = omega\n    return np.array([[0.0, -wz,  wy],\n                     [wz,  0.0, -wx],\n                     [-wy, wx,  0.0]])\n\ndef skew(A):\n    \"\"\"Return the skew-symmetric part of a 3x3 matrix.\"\"\"\n    return 0.5 * (A - A.T)\n\ndef fro_norm(A):\n    \"\"\"Frobenius norm.\"\"\"\n    return float(np.linalg.norm(A, 'fro'))\n\ndef update_rotation(R0, W_func, dt, N, scheme='midpoint'):\n    \"\"\"\n    Update rotation R in SO(3) using exponential map with midpoint or forward scheme.\n\n    Parameters:\n    - R0: initial 3x3 rotation matrix\n    - W_func: function of time t returning a 3x3 skew-symmetric matrix W^e(t)\n    - dt: time step (seconds)\n    - N: number of steps\n    - scheme: 'midpoint' or 'forward'\n\n    Returns:\n    - R: final rotation matrix after N steps\n    \"\"\"\n    R = R0.copy()\n    t = 0.0\n    for _ in range(N):\n        if scheme == 'midpoint':\n            W = W_func(t + 0.5 * dt)\n        elif scheme == 'forward':\n            W = W_func(t)\n        else:\n            raise ValueError(\"Unknown scheme\")\n        R_delta = expm(dt * W)\n        R = R_delta @ R\n        t += dt\n    return R\n\ndef rotation_about_axis(axis, angle):\n    \"\"\"\n    Return rotation matrix exp(angle * [axis]_x), axis must be a 3-vector.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    return expm(angle * hat(axis))\n\ndef test_case_1():\n    # Constant lattice spin (happy path)\n    omega = np.array([0.1, 0.2, -0.05])  # rad/s\n    W_const = hat(omega)\n    R0 = np.eye(3)\n    dt = 0.01\n    N = 100\n    T = dt * N\n\n    def W_func(t):\n        return W_const\n\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    R_exact = expm(T * W_const)\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef test_case_2():\n    # Zero lattice spin (boundary case)\n    def W_func(t):\n        return np.zeros((3, 3))  # W^e(t) = 0\n\n    R0 = rotation_about_axis([0.0, 1.0, 0.0], 0.3)  # initial rotation about y\n    dt = 0.05\n    N = 10\n    T = dt * N\n\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    R_exact = R0.copy()  # No change expected\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef test_case_3():\n    # Coexistent elastic stretch and rotation (edge case checking skw(L^e))\n    # U^e(t) = diag(exp(alpha t), exp(beta t), exp(gamma t))\n    alpha, beta, gamma = 0.2, -0.1, 0.0  # s^{-1}\n    D_diag = np.array([alpha, beta, gamma])  # Udot U^{-1} in principal frame (constant)\n    D = np.diag(D_diag)  # symmetric\n    omega_z = 0.5  # rad/s\n    ez = np.array([0.0, 0.0, 1.0])\n\n    def R_of_t(t):\n        return expm((omega_z * t) * hat(ez))\n\n    def L_e_of_t(t):\n        # L^e(t) = Rdot R^T + R D R^T\n        # For rotation about ez at constant rate, Rdot R^T = omega_z [ez]_x\n        R = R_of_t(t)\n        W_rot = omega_z * hat(ez)\n        return W_rot + R @ D @ R.T\n\n    def W_func(t):\n        # W^e(t) = skw(L^e(t))\n        return skew(L_e_of_t(t))\n\n    R0 = np.eye(3)\n    dt = 0.02\n    N = 100\n    T = dt * N\n\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    R_exact = R_of_t(T)\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef test_case_4():\n    # Time-dependent lattice spin about a fixed axis (commuting case, large step)\n    omega0 = 1.2  # rad/s\n    nu = 0.8      # rad/s\n    ex = np.array([1.0, 0.0, 0.0])\n\n    def W_func(t):\n        return hat(np.array([omega0 * np.sin(nu * t), 0.0, 0.0]))\n\n    dt = 0.2\n    N = 25\n    T = dt * N\n\n    R0 = np.eye(3)\n    R_num = update_rotation(R0, W_func, dt, N, scheme='midpoint')\n    # Exact rotation: theta(T) = (omega0/nu) * (1 - cos(nu T))\n    theta_T = (omega0 / nu) * (1.0 - np.cos(nu * T))\n    R_exact = rotation_about_axis(ex, theta_T)\n\n    rot_err = fro_norm(R_num - R_exact)\n    orth_err = fro_norm(R_num.T @ R_num - np.eye(3))\n    return [rot_err, orth_err]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    results = []\n    results.append(test_case_1())\n    results.append(test_case_2())\n    results.append(test_case_3())\n    results.append(test_case_4())\n\n    # Final print statement in the exact required format.\n    # Print as a single line: list of four [rotation_error, orthogonality_error] pairs.\n    # Ensure default string conversion yields comma-separated floats within nested lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3441906"}, {"introduction": "在掌握了晶体变形的运动学描述后，我们必须探究其发生塑性滑移的内在驱动力，即动力学。本练习超越了经典的施密特（Schmid）定律，引导您设计一个计算基准，以隔离并研究非施密特应力分量在滑移启动过程中的具体作用。通过构建这个虚拟实验 ([@problem_id:3441899])，您将分析不同的应力路径如何选择性地激活滑移系，从而深入理解更精细的材料本构模型。", "problem": "为晶体塑性有限元 (CPFE) 建模构建一个计算基准，该基准用于在小应变条件下分离非施密特效应在滑移激活中的作用。考虑一个具有两个滑移系的单晶，索引为 $\\alpha \\in \\{1,2\\}$。沿指定的偏载荷方向，这两个滑移系的经典施密特贡献相同，但它们的非施密特敏感性不同。目标是设计一族能够区分首先激活的滑移系的应力加载路径，并实现一个程序，用于预测在给定路径下首先激活的滑移系。\n\n从以下基本原理出发：\n- 柯西应力张量为 $\\boldsymbol{\\sigma}$，静水压力为 $p = \\tfrac{1}{3} \\operatorname{tr}(\\boldsymbol{\\sigma})$。\n- 对于滑移系 $\\alpha$，滑移方向是单位向量 $\\boldsymbol{s}^\\alpha$，滑移面单位法向量是 $\\boldsymbol{m}^\\alpha$，且 $\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 0$。\n- 分解切应力为 $\\tau^\\alpha = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$。\n- 滑移面上的正应力为 $\\sigma_{nn}^\\alpha = \\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$。\n- 用于激活的非施密特增广驱动应力为 $\\psi^\\alpha = \\tau^\\alpha + a^\\alpha p + b^\\alpha \\sigma_{nn}^\\alpha$，其中 $a^\\alpha$ 和 $b^\\alpha$ 是可能取决于 $\\alpha$ 的无量纲非施密特系数。\n- 当 $|\\psi^\\alpha| = g^\\alpha$ 时，滑移系 $\\alpha$ 激活，其中 $g^\\alpha$ 是临界分解切应力。\n\n将加载设计为一个单参数族，该族混合了一个固定的偏张量和一个可调的静水压力分量。设总应力为\n$$\n\\boldsymbol{\\sigma}(\\lambda; r) = \\lambda \\,\\boldsymbol{D} + r \\,\\lambda \\,\\boldsymbol{I},\n$$\n其中 $\\lambda \\ge 0$ 缩放总应力的大小（单位为兆帕），$\\boldsymbol{I}$ 是单位张量，$\\boldsymbol{D}$ 是一个固定的偏张量，$r$ 是一个实值路径比，用于设定静水压力与偏应力的比例。由于 $\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{I} \\cdot \\boldsymbol{m}^\\alpha = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 0$，静水压力分量对经典施密特项没有贡献。\n\n使用以下具体的、科学上合理的设定：\n- 使用规范偏张量\n$$\n\\boldsymbol{D} = \\operatorname{diag}\\!\\big(1,\\,-\\tfrac{1}{2},\\,-\\tfrac{1}{2}\\big).\n$$\n- 定义两个沿 $\\boldsymbol{D}$ 方向具有相同施密特贡献的滑移系：\n  - 滑移系 1：$\\boldsymbol{m}^1 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,1)$，$\\boldsymbol{s}^1 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,-1)$。\n  - 滑移系 2：$\\boldsymbol{m}^2 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,-1)$，$\\boldsymbol{s}^2 = \\tfrac{1}{\\sqrt{2}}(1,\\,0,\\,1)$。\n- 验证 $ \\boldsymbol{s}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\boldsymbol{s}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2$。\n- 指定非施密特系数和临界分解切应力：\n  - $a^1 = 0.3$， $b^1 = 0.1$， $g^1 = 50$（单位为兆帕）。\n  - $a^2 = -0.1$， $b^2 = 0.25$， $g^2 = 50$（单位为兆帕）。\n\n在此加载下，对每个滑移系 $\\alpha$，推导其线性关系\n$$\n\\psi^\\alpha(\\lambda; r) = \\big[\\, \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha \\,+\\, a^\\alpha r \\,+\\, b^\\alpha \\big(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r \\big) \\,\\big] \\,\\lambda \\equiv K^\\alpha(r)\\,\\lambda,\n$$\n并计算激活载荷水平\n$$\n\\lambda_c^\\alpha(r) = \\frac{g^\\alpha}{|K^\\alpha(r)|},\n$$\n以兆帕为单位。首先激活的滑移系是 $\\lambda_c^\\alpha(r)$ 值最小的那个。在罕见情况下，如果 $\\lambda_c^1(r)$ 和 $\\lambda_c^2(r)$ 在数值容差范围内相等，则将其视为首次激活的精确平局。\n\n你的程序必须：\n- 使用指定的 $\\boldsymbol{D}$、$\\boldsymbol{s}^\\alpha$、$\\boldsymbol{m}^\\alpha$、$a^\\alpha$、$b^\\alpha$ 和 $g^\\alpha$ 实现上述定义。\n- 对于每个提供的测试用例值 $r$，计算 $K^\\alpha(r)$，然后计算 $\\lambda_c^\\alpha(r)$（单位为兆帕），并确定首先激活的滑移系。\n- 使用以下路径比 $r$ 的测试套件：\n  - 用例 1：$r = 0$。\n  - 用例 2：$r = 0.15$。\n  - 用例 3：$r = 0.5$。\n  - 用例 4：$r = -0.5$。\n- 在 $|\\lambda_c^1(r) - \\lambda_c^2(r)|$ 上应用 $\\varepsilon = 10^{-9}$ 的平局容差来判定平局。\n\n最终输出格式：\n- 对于每个测试用例，输出一个整数，表示在 $\\{1,2\\}$ 中首先激活的滑移系索引；如果出现平局，则输出整数 $0$。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如，$[2,0,1,2]$ 依次对应四个测试用例。\n- 所有涉及应力大小的中间计算必须以兆帕为单位进行，但最终报告的整数是无量纲的索引。", "solution": "问题陈述已经过严格验证，并被确定为 **有效**。它以晶体塑性原理为科学基础，参数集完整且一致，提法恰当，并且呈现客观。该任务是一项定义明确的计算基准设计，是计算材料科学中的一项合理实践。\n\n目标是确定在指定的应力路径族下，两个滑移系 $\\alpha \\in \\{1,2\\}$ 中哪一个首先激活。首先激活的滑移系是需要最小应力大小 $\\lambda$ 来达到其激活阈值的那个。这对应于具有最小临界载荷水平 $\\lambda_c^\\alpha$ 的滑移系。\n\n施加的宏观柯西应力张量 $\\boldsymbol{\\sigma}$ 由以下单参数族给出：\n$$\n\\boldsymbol{\\sigma}(\\lambda; r) = \\lambda \\,\\boldsymbol{D} + r \\,\\lambda \\,\\boldsymbol{I}\n$$\n其中 $\\lambda \\ge 0$ 是载荷大小（单位为兆帕，MPa），$\\boldsymbol{D}$ 是固定的偏张量，$\\boldsymbol{I}$ 是单位张量，$r$ 是一个控制静水应力分量的无量纲路径比。\n\n滑移系 $\\alpha$ 的激活由非施密特准则决定，其中驱动应力 $\\psi^\\alpha$ 必须达到临界值 $g^\\alpha$。驱动应力定义为：\n$$\n\\psi^\\alpha = \\tau^\\alpha + a^\\alpha p + b^\\alpha \\sigma_{nn}^\\alpha\n$$\n此处，$\\tau^\\alpha = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$ 是分解切应力，$p = \\frac{1}{3} \\operatorname{tr}(\\boldsymbol{\\sigma})$ 是静水压力，而 $\\sigma_{nn}^\\alpha = \\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{\\sigma} \\cdot \\boldsymbol{m}^\\alpha$ 是滑移面法向的应力分量。系数 $a^\\alpha$ 和 $b^\\alpha$ 是用于非施密特效应的材料参数。\n\n我们首先用加载参数 $\\lambda$ 和 $r$ 来表示驱动应力的各个分量。\n静水压力为：\n$$\np = \\frac{1}{3} \\operatorname{tr}(\\lambda \\boldsymbol{D} + r\\lambda \\boldsymbol{I}) = \\frac{\\lambda}{3} \\operatorname{tr}(\\boldsymbol{D}) + \\frac{r\\lambda}{3} \\operatorname{tr}(\\boldsymbol{I})\n$$\n由于 $\\boldsymbol{D}$ 是偏张量，$\\operatorname{tr}(\\boldsymbol{D}) = 0$。又因 $\\operatorname{tr}(\\boldsymbol{I}) = 3$，这可简化为 $p = r\\lambda$。\n\n分解切应力为：\n$$\n\\tau^\\alpha = \\boldsymbol{s}^\\alpha \\cdot (\\lambda \\boldsymbol{D} + r\\lambda \\boldsymbol{I}) \\cdot \\boldsymbol{m}^\\alpha = \\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha) + r\\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{I} \\cdot \\boldsymbol{m}^\\alpha)\n$$\n鉴于滑移系的正交性，$\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 0$，第二项消失，剩下 $\\tau^\\alpha = \\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha)$。\n\n滑移面正应力为：\n$$\n\\sigma_{nn}^\\alpha = \\boldsymbol{m}^\\alpha \\cdot (\\lambda \\boldsymbol{D} + r\\lambda \\boldsymbol{I}) \\cdot \\boldsymbol{m}^\\alpha = \\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha) + r\\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{I} \\cdot \\boldsymbol{m}^\\alpha)\n$$\n由于 $\\boldsymbol{m}^\\alpha$ 是单位向量，$\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{m}^\\alpha = 1$，这得到 $\\sigma_{nn}^\\alpha = \\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r)$。\n\n将这些代入 $\\psi^\\alpha$ 的表达式中：\n$$\n\\psi^\\alpha(\\lambda; r) = \\lambda(\\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha) + a^\\alpha(r\\lambda) + b^\\alpha \\left[\\lambda(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r)\\right]\n$$\n提出因子 $\\lambda$ 后得到 $\\psi^\\alpha(\\lambda; r) = K^\\alpha(r)\\lambda$，其中有效驱动应力系数 $K^\\alpha(r)$ 为：\n$$\nK^\\alpha(r) = \\boldsymbol{s}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + a^\\alpha r + b^\\alpha(\\boldsymbol{m}^\\alpha \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^\\alpha + r)\n$$\n这证实了问题陈述中提供的表达式。当 $|\\psi^\\alpha| = g^\\alpha$ 时发生滑移激活，因此 $|\\lambda K^\\alpha(r)| = g^\\alpha$。所以临界载荷水平为 $\\lambda_c^\\alpha(r) = \\frac{g^\\alpha}{|K^\\alpha(r)|}$。\n\n我们现在使用所提供的数据计算恒定的几何因子：\n- 偏张量：$\\boldsymbol{D} = \\operatorname{diag}(1, -1/2, -1/2)$。\n- 滑移系 1：$\\boldsymbol{m}^1 = \\frac{1}{\\sqrt{2}}(1, 0, 1)$，$\\boldsymbol{s}^1 = \\frac{1}{\\sqrt{2}}(1, 0, -1)$。\n- 滑移系 2：$\\boldsymbol{m}^2 = \\frac{1}{\\sqrt{2}}(1, 0, -1)$，$\\boldsymbol{s}^2 = \\frac{1}{\\sqrt{2}}(1, 0, 1)$。\n\n对于滑移系 1：\n- 施密特因子：$\\boldsymbol{s}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1/2 \\end{pmatrix} = \\frac{1}{2}(1 + 1/2) = \\frac{3}{4}$。\n- 正应力因子：$\\boldsymbol{m}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1/2 \\end{pmatrix} = \\frac{1}{2}(1 - 1/2) = \\frac{1}{4}$。\n\n对于滑移系 2：\n- 施密特因子：$\\boldsymbol{s}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1/2 \\end{pmatrix} = \\frac{1}{2}(1 + 1/2) = \\frac{3}{4}$。\n- 正应力因子：$\\boldsymbol{m}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ 0  -1/2  0 \\\\ 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 1/2 \\end{pmatrix} = \\frac{1}{2}(1 - 1/2) = \\frac{1}{4}$。\n\n正如所要求，施密特因子是相同的，$\\boldsymbol{s}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\boldsymbol{s}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = 0.75$。正应力因子也恰好相同，$\\boldsymbol{m}^1 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^1 = \\boldsymbol{m}^2 \\cdot \\boldsymbol{D} \\cdot \\boldsymbol{m}^2 = 0.25$。激活的差异将完全源于非施密特系数。\n\n我们使用系数 $a^1=0.3$、$b^1=0.1$、$a^2=-0.1$、$b^2=0.25$ 组合 $K^\\alpha(r)$ 的表达式：\n- $K^1(r) = 0.75 + a^1 r + b^1 (0.25 + r) = 0.75 + 0.3r + 0.1(0.25 + r) = 0.75 + 0.3r + 0.025 + 0.1r = 0.775 + 0.4r$。\n- $K^2(r) = 0.75 + a^2 r + b^2 (0.25 + r) = 0.75 - 0.1r + 0.25(0.25 + r) = 0.75 - 0.1r + 0.0625 + 0.25r = 0.8125 + 0.15r$。\n\n当 $g^1 = g^2 = 50$ MPa 时，我们有：\n$\\lambda_c^1(r) = \\frac{50}{|0.775 + 0.4r|}$ 且 $\\lambda_c^2(r) = \\frac{50}{|0.8125 + 0.15r|}$。\n\n我们现在为每个测试用例进行评估：\n\n用例 1：$r = 0$\n- $K^1(0) = 0.775$，$\\lambda_c^1(0) = 50/0.775 \\approx 64.516$ MPa。\n- $K^2(0) = 0.8125$，$\\lambda_c^2(0) = 50/0.8125 \\approx 61.538$ MPa。\n- $\\lambda_c^2(0)  \\lambda_c^1(0)$，所以滑移系 2 首先激活。结果：$2$。\n\n用例 2：$r = 0.15$\n- $K^1(0.15) = 0.775 + 0.4(0.15) = 0.775 + 0.06 = 0.835$。\n- $K^2(0.15) = 0.8125 + 0.15(0.15) = 0.8125 + 0.0225 = 0.835$。\n- $K^1(0.15) = K^2(0.15)$，这意味着 $\\lambda_c^1(0.15) = \\lambda_c^2(0.15)$。\n- 差值 $|\\lambda_c^1 - \\lambda_c^2| = 0$，小于容差 $\\varepsilon=10^{-9}$。这是一个精确平局。结果：$0$。\n\n用例 3：$r = 0.5$\n- $K^1(0.5) = 0.775 + 0.4(0.5) = 0.775 + 0.2 = 0.975$。$\\lambda_c^1(0.5) = 50/0.975 \\approx 51.282$ MPa。\n- $K^2(0.5) = 0.8125 + 0.15(0.5) = 0.8125 + 0.075 = 0.8875$。$\\lambda_c^2(0.5) = 50/0.8875 \\approx 56.338$ MPa。\n- $\\lambda_c^1(0.5)  \\lambda_c^2(0.5)$，所以滑移系 1 首先激活。结果：$1$。\n\n用例 4：$r = -0.5$\n- $K^1(-0.5) = 0.775 + 0.4(-0.5) = 0.775 - 0.2 = 0.575$。$\\lambda_c^1(-0.5) = 50/0.575 \\approx 86.957$ MPa。\n- $K^2(-0.5) = 0.8125 + 0.15(-0.5) = 0.8125 - 0.075 = 0.7375$。$\\lambda_c^2(-0.5) = 50/0.7375 \\approx 67.796$ MPa。\n- $\\lambda_c^2(-0.5)  \\lambda_c^1(-0.5)$，所以滑移系 2 首先激活。结果：$2$。\n\n给定测试用例的最终结果序列是 $[2, 0, 1, 2]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the first-activating slip system for a single crystal under\n    various mixed deviatoric-hydrostatic loading paths, considering\n    non-Schmid effects.\n    \"\"\"\n    \n    # Define problem parameters\n    \n    # Deviatoric stress tensor D\n    D = np.diag([1.0, -0.5, -0.5])\n\n    # Parameters for slip system 1\n    m1 = np.array([1.0, 0.0, 1.0]) / np.sqrt(2)\n    s1 = np.array([1.0, 0.0, -1.0]) / np.sqrt(2)\n    a1 = 0.3\n    b1 = 0.1\n    g1 = 50.0  # in MPa\n\n    # Parameters for slip system 2\n    m2 = np.array([1.0, 0.0, -1.0]) / np.sqrt(2)\n    s2 = np.array([1.0, 0.0, 1.0]) / np.sqrt(2)\n    a2 = -0.1\n    b2 = 0.25\n    g2 = 50.0  # in MPa\n    \n    # Test suite of path ratios r\n    test_cases_r = [0.0, 0.15, 0.5, -0.5]\n    \n    # Tie tolerance\n    epsilon = 1e-9\n    \n    results = []\n\n    # Pre-compute constant geometric factors\n    # For system 1\n    tau1_D = np.dot(s1, D @ m1)\n    sigma_nn1_D = np.dot(m1, D @ m1)\n    \n    # For system 2\n    tau2_D = np.dot(s2, D @ m2)\n    sigma_nn2_D = np.dot(m2, D @ m2)\n\n    for r in test_cases_r:\n        # Calculate the effective driving stress coefficient K(r) for each system\n        \n        # System 1: K^1(r) = s^1.D.m^1 + a^1*r + b^1*(m^1.D.m^1 + r)\n        K1_r = tau1_D + a1 * r + b1 * (sigma_nn1_D + r)\n        \n        # System 2: K^2(r) = s^2.D.m^2 + a^2*r + b^2*(m^2.D.m^2 + r)\n        K2_r = tau2_D + a2 * r + b2 * (sigma_nn2_D + r)\n        \n        # Calculate the critical activation load lambda_c = g / |K(r)|\n        # Avoid division by zero, though not expected for these test cases.\n        # If K(r) is zero, the system never activates, so lambda_c is infinite.\n        if abs(K1_r)  epsilon:\n            lambda_c1 = np.inf\n        else:\n            lambda_c1 = g1 / abs(K1_r)\n\n        if abs(K2_r)  epsilon:\n            lambda_c2 = np.inf\n        else:\n            lambda_c2 = g2 / abs(K2_r)\n            \n        # Determine the first-activating system\n        if abs(lambda_c1 - lambda_c2) = epsilon:\n            # Activation thresholds are equal within tolerance: it's a tie.\n            results.append(0)\n        elif lambda_c1  lambda_c2:\n            # System 1 activates at a lower stress magnitude.\n            results.append(1)\n        else:\n            # System 2 activates at a lower stress magnitude.\n            results.append(2)\n\n    # Print the final result in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n```", "id": "3441899"}]}