{"hands_on_practices": [{"introduction": "本练习是任何簇展开研究的起点。我们将通过为几个简单的、假设性的合金构型手动计算相关函数，并求解由此产生的线性方程组，来演示拟合有效簇相互作用（ECI）的核心原理。这项实践练习 [@problem_id:3437949] 旨在建立一个基础直觉，帮助理解抽象的理论框架如何将原子构型、簇相关性和构型能联系起来。", "problem": "考虑一个建立在一维周期性环上的二元合金模型，该环有 $N=6$ 个晶格点和类伊辛（Ising-like）占据变量 $\\sigma_{i}\\in\\{+1,-1\\}$，其中 $\\sigma_{i}=+1$ 表示A物种，$\\sigma_{i}=-1$ 表示B物种。每个晶格点的构型能由一个截断的团簇展开表示，该展开只保留到次近邻的对团簇。对于给定的构型，定义壳层 $\\alpha$ 的对相关性 $\\Pi_{\\alpha}$ 为\n$$\n\\Pi_{\\alpha} \\equiv \\frac{1}{M_{\\alpha}}\\sum_{\\langle i,j\\rangle_{\\alpha}} \\sigma_{i}\\sigma_{j},\n$$\n其中 $M_{\\alpha}$ 是壳层 $\\alpha$ 中不同对的数量，求和遍及所有以第 $\\alpha$ 近邻距离分隔的对称等效对。在 $N=6$ 的环上，每个点有 $z_{1}=2$ 个最近邻和 $z_{2}=2$ 个次近邻，因此 $M_{1}=M_{2}=6$。假设组分为等原子比，且形成能使得空团簇和点贡献为常数，这些常数被吸收到参考能量中（设为零），因此每个点的能量 $E$ 线性地依赖于对相关性，并带有两个未知的有效团簇相互作用（ECI）$J_{1}$ 和 $J_{2}$：\n$$\nE = J_{1}\\,\\Pi_{1} + J_{2}\\,\\Pi_{2}.\n$$\n考虑环上的以下三种不同的等原子比构型，由环上 $\\sigma_{i}$ 的序列指定：\n- 构型 $\\mathcal{A}$：$+1,-1,+1,-1,+1,-1$（$A$ 和 $B$ 交替排列），\n- 构型 $\\mathcal{B}$：$+1,+1,+1,-1,-1,-1$（三个 $A$ 后面跟着三个 $B$），\n- 构型 $\\mathcal{C}$：$+1,-1,-1,+1,+1,-1$。\n\n对于这三种构型，假设每个点测得的形成能（来自一个假设的第一性原理数据集）为\n$$\nE_{\\mathcal{A}}=1\\ \\text{eV},\\quad E_{\\mathcal{B}}=-\\frac{1}{3}\\ \\text{eV},\\quad E_{\\mathcal{C}}=-1\\ \\text{eV}.\n$$\n从上述定义出发，不使用任何未引入的简化公式，显式计算每种构型的对相关性 $\\Pi_{1}$ 和 $\\Pi_{2}$，建立关联 $\\{E_{\\mathcal{A}},E_{\\mathcal{B}},E_{\\mathcal{C}}\\}$ 与 $\\{J_{1},J_{2}\\}$ 的线性方程组，并精确求解这两个对有效团簇相互作用 $J_{1}$ 和 $J_{2}$。$J_{1}$ 和 $J_{2}$ 的最终值以电子伏特表示。无需四舍五入；请提供精确值。", "solution": "该问题要求计算一个在一维周期性环上的二元合金的两个有效团簇相互作用（ECI），即 $J_{1}$ 和 $J_{2}$，该环有 $N=6$ 个晶格点。每个点的构型能 $E$ 由一个截断的团簇展开模型表示：\n$$\nE = J_{1}\\,\\Pi_{1} + J_{2}\\,\\Pi_{2}\n$$\n其中 $\\Pi_{\\alpha}$ 是第 $\\alpha$ 近邻壳层的对相关性。点 $i$ 的占据由变量 $\\sigma_{i} \\in \\{+1, -1\\}$ 描述。对相关性定义为：\n$$\n\\Pi_{\\alpha} \\equiv \\frac{1}{M_{\\alpha}}\\sum_{\\langle i,j\\rangle_{\\alpha}} \\sigma_{i}\\sigma_{j}\n$$\n其中求和遍及 $M_{\\alpha}$ 个不同的第 $\\alpha$ 近邻对。对于一个有 $N=6$ 个点的一维周期性环，点 $i$ 的最近邻是点 $i+1$ 和 $i-1$，次近邻是点 $i+2$ 和 $i-2$（索引以 $6$ 为模）。不同的最近邻对的总数为 $M_1=6$，不同的次近邻对的总数为 $M_2=6$。对于周期性环，所有不同对 $\\langle i,j\\rangle_{\\alpha}$ 的求和可以通过对所有点 $i$ 从 $1$ 到 $N$ 求和 $\\sigma_i \\sigma_{i+\\delta}$ 来计算，其中 $\\delta$ 是近邻距离（对于最近邻 $\\delta=1$，对于次近邻 $\\delta=2$），并应用周期性边界条件（$\\sigma_{N+k} = \\sigma_k$）。\n\n解题步骤是首先计算三种给定构型的对相关性 $\\Pi_{1}$ 和 $\\Pi_{2}$，然后使用给定的能量 $\\{E_{\\mathcal{A}}, E_{\\mathcal{B}}, E_{\\mathcal{C}}\\}$ 建立一个关于 $J_{1}$ 和 $J_{2}$ 的线性方程组，最后解这个方程组。\n\n**1. 对相关性的计算**\n\n**构型 $\\mathcal{A}$：$(\\sigma_{1}, \\sigma_{2}, \\sigma_{3}, \\sigma_{4}, \\sigma_{5}, \\sigma_{6}) = (+1, -1, +1, -1, +1, -1)$**\n对于最近邻（$\\delta=1$）：\n乘积之和为 $\\sum_{i=1}^{6} \\sigma_{i}\\sigma_{i+1} = \\sigma_1\\sigma_2 + \\sigma_2\\sigma_3 + \\sigma_3\\sigma_4 + \\sigma_4\\sigma_5 + \\sigma_5\\sigma_6 + \\sigma_6\\sigma_1$。\n代入数值：$(+1)(-1) + (-1)(+1) + (+1)(-1) + (-1)(+1) + (+1)(-1) + (-1)(+1) = -1 -1 -1 -1 -1 -1 = -6$。\n最近邻相关性为 $\\Pi_{1,\\mathcal{A}} = \\frac{1}{M_1}\\sum \\sigma_i\\sigma_{i+1} = \\frac{1}{6}(-6) = -1$。\n\n对于次近邻（$\\delta=2$）：\n乘积之和为 $\\sum_{i=1}^{6} \\sigma_{i}\\sigma_{i+2} = \\sigma_1\\sigma_3 + \\sigma_2\\sigma_4 + \\sigma_3\\sigma_5 + \\sigma_4\\sigma_6 + \\sigma_5\\sigma_1 + \\sigma_6\\sigma_2$。\n代入数值：$(+1)(+1) + (-1)(-1) + (+1)(+1) + (-1)(-1) + (+1)(+1) + (-1)(-1) = 1 + 1 + 1 + 1 + 1 + 1 = 6$。\n次近邻相关性为 $\\Pi_{2,\\mathcal{A}} = \\frac{1}{M_2}\\sum \\sigma_i\\sigma_{i+2} = \\frac{1}{6}(6) = 1$。\n\n**构型 $\\mathcal{B}$：$(\\sigma_{1}, \\sigma_{2}, \\sigma_{3}, \\sigma_{4}, \\sigma_{5}, \\sigma_{6}) = (+1, +1, +1, -1, -1, -1)$**\n对于最近邻：\n$\\sum \\sigma_i\\sigma_{i+1} = (+1)(+1) + (+1)(+1) + (+1)(-1) + (-1)(-1) + (-1)(-1) + (-1)(+1) = 1 + 1 - 1 + 1 + 1 - 1 = 2$。\n$\\Pi_{1,\\mathcal{B}} = \\frac{1}{6}(2) = \\frac{1}{3}$。\n\n对于次近邻：\n$\\sum \\sigma_i\\sigma_{i+2} = (+1)(+1) + (+1)(-1) + (+1)(-1) + (-1)(-1) + (-1)(+1) + (-1)(+1) = 1 - 1 - 1 + 1 - 1 - 1 = -2$。\n$\\Pi_{2,\\mathcal{B}} = \\frac{1}{6}(-2) = -\\frac{1}{3}$。\n\n**构型 $\\mathcal{C}$：$(\\sigma_{1}, \\sigma_{2}, \\sigma_{3}, \\sigma_{4}, \\sigma_{5}, \\sigma_{6}) = (+1, -1, -1, +1, +1, -1)$**\n对于最近邻：\n$\\sum \\sigma_i\\sigma_{i+1} = (+1)(-1) + (-1)(-1) + (-1)(+1) + (+1)(+1) + (+1)(-1) + (-1)(+1) = -1 + 1 - 1 + 1 - 1 - 1 = -2$。\n$\\Pi_{1,\\mathcal{C}} = \\frac{1}{6}(-2) = -\\frac{1}{3}$。\n\n对于次近邻：\n$\\sum \\sigma_i\\sigma_{i+2} = (+1)(-1) + (-1)(+1) + (-1)(+1) + (+1)(-1) + (+1)(+1) + (-1)(-1) = -1 - 1 - 1 - 1 + 1 + 1 = -2$。\n$\\Pi_{2,\\mathcal{C}} = \\frac{1}{6}(-2) = -\\frac{1}{3}$。\n\n**2. 建立并求解线性方程组**\n\n我们现在对每种构型使用能量表达式 $E = J_{1}\\Pi_{1} + J_{2}\\Pi_{2}$ 以及它们给定的能量：$E_{\\mathcal{A}}=1$ eV，$E_{\\mathcal{B}}=-\\frac{1}{3}$ eV 和 $E_{\\mathcal{C}}=-1$ eV。\n\n对于 $\\mathcal{A}$：$1 = J_{1}(-1) + J_{2}(1) \\implies -J_{1} + J_{2} = 1$。（方程1）\n对于 $\\mathcal{B}$：$-\\frac{1}{3} = J_{1}(\\frac{1}{3}) + J_{2}(-\\frac{1}{3}) \\implies J_{1} - J_{2} = -1$。（方程2）\n对于 $\\mathcal{C}$：$-1 = J_{1}(-\\frac{1}{3}) + J_{2}(-\\frac{1}{3}) \\implies J_{1} + J_{2} = 3$。（方程3）\n\n得到的线性方程组是：\n$$\n\\begin{cases}\n-J_{1} + J_{2} = 1 \\\\\nJ_{1} - J_{2} = -1 \\\\\nJ_{1} + J_{2} = 3\n\\end{cases}\n$$\n方程（2）在数学上与方程（1）是相同的，因为将方程（2）乘以 $-1$ 就得到方程（1）。这证实了构型 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的数据在相关性空间中是一致且共线的，但这意味着我们必须使用来自构型 $\\mathcal{C}$ 的独立信息来找到唯一解。我们求解由方程（1）和方程（3）组成的方程组：\n$$\n\\begin{cases}\n-J_{1} + J_{2} = 1 \\\\\nJ_{1} + J_{2} = 3\n\\end{cases}\n$$\n将两个方程相加：\n$(-J_{1} + J_{2}) + (J_{1} + J_{2}) = 1 + 3$\n$2J_{2} = 4$\n$J_{2} = 2$。\n\n将 $J_{2}$ 的值代入方程（3）：\n$J_{1} + 2 = 3$\n$J_{1} = 1$。\n\n解为 $J_{1} = 1$ eV 和 $J_{2} = 2$ eV。我们可以使用方程（2）（来自构型 $\\mathcal{B}$）来验证此解：$(1) - (2) = -1$，这是正确的。这些值与所有三个数据点都一致。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1  2 \\end{pmatrix}}\n$$", "id": "3437949"}, {"introduction": "一个拟合好的模型只有在能够准确预测训练集之外的构型能量时才是有用的。本练习将介绍 K 折交叉验证法，这是一种评估模型预测能力和防止过拟合的标准技术。通过一项计算练习 [@problem_id:3437890]，你将探索数据质量（特别是共线或不一致数据点的存在）如何影响交叉验证得分，从而强调严格验证过程的重要性。", "problem": "给定一个最小线性团簇展开（CE）设置，其中每个结构的构型能量被建模为预先计算的团簇相关函数的线性组合。具体来说，对于一个由 $i \\in \\{0,1,\\dots,N-1\\}$ 索引的结构数据集，每个结构都有一个相关向量 $\\boldsymbol{\\phi}_i \\in \\mathbb{R}^p$（作为设计矩阵 $X \\in \\mathbb{R}^{N \\times p}$ 的行收集），以及一个能量 $y_i \\in \\mathbb{R}$（收集到一个向量 $\\mathbf{y} \\in \\mathbb{R}^N$ 中）。该模型假定\n$$\nE_i \\equiv y_i \\approx \\sum_{\\alpha=0}^{p-1} J_{\\alpha} \\, \\phi_{i,\\alpha} \\quad \\text{或以矩阵形式} \\quad \\mathbf{y} \\approx X \\mathbf{J},\n$$\n其中 $\\mathbf{J} \\in \\mathbb{R}^p$ 是未知的有效团簇相互作用（ECIs）。ECIs 通过普通最小二乘法（OLS）获得，定义为残差平方和的最小化器。当 $X$ 由于共线行而导致秩亏或病态时，解取为通过摩尔-彭若斯伪逆（MPP）（记为 $X^{+}$）计算的最小范数 OLS 解，因此\n$$\n\\widehat{\\mathbf{J}} = X^{+} \\mathbf{y}.\n$$\n\n为了评估预测性能，您将实现 $K$-折交叉验证（K-FCV）。在 $K$-折交叉验证（K-FCV）中，索引集 $\\{0,1,\\dots,N-1\\}$ 根据规则确定性地划分为 $K$ 个折：如果 $i \\bmod K = f$，则索引 $i$ 被分配到折 $f$，其中 $f \\in \\{0,1,\\dots,K-1\\}$。对于每个折 $f$，模型在折 $f$ 的补集上进行训练，并在折 $f$ 上进行评估。交叉验证分数（CVS）定义为在所有折的全部留出预测上聚合的均方根误差（RMSE）：\n$$\n\\mathrm{CVS}_K(X,\\mathbf{y}) = \\sqrt{ \\frac{1}{N} \\sum_{f=0}^{K-1} \\ \\sum_{i \\in \\mathcal{I}_f} \\left( y_i - \\widehat{y}_i^{(f)} \\right)^2 },\n$$\n其中 $\\mathcal{I}_f$ 是折 $f$ 中的索引集，而 $\\widehat{y}_i^{(f)} = \\boldsymbol{\\phi}_i^{\\mathsf{T}} \\, \\widehat{\\mathbf{J}}^{(f)}$，其中\n$$\n\\widehat{\\mathbf{J}}^{(f)} = X_{-f}^{+} \\, \\mathbf{y}_{-f},\n$$\n且 $(X_{-f}, \\mathbf{y}_{-f})$ 表示排除折 $f$ 的训练数据。\n\n您的任务是数值上展示当一个共线的训练结构（一个现有相关向量的精确副本）被添加到数据集中时，$K$-折交叉验证分数（CVS）如何变化。您将计算添加前后的 CVS，并报告其变化。所有计算都必须使用通过摩尔-彭若斯伪逆计算的 OLS 估计器。\n\n使用以下包含 $N = 6$ 个结构和 $p = 4$ 个特征的基础数据集（第一个特征是等于 $1$ 的截距）。设计矩阵 $X_0 \\in \\mathbb{R}^{6 \\times 4}$ 和能量向量 $\\mathbf{y}_0 \\in \\mathbb{R}^6$ 为：\n$$\nX_0 = \\begin{bmatrix}\n1  -1.0  -0.2  0.5 \\\\\n1  -0.5  \\phantom{-}0.1  -0.3 \\\\\n1  \\phantom{-}0.0  -0.4  \\phantom{-}0.2 \\\\\n1  \\phantom{-}0.5  \\phantom{-}0.2  -0.1 \\\\\n1  -0.3  \\phantom{-}0.4  -0.5 \\\\\n1  \\phantom{-}0.8  -0.1  \\phantom{-}0.4\n\\end{bmatrix},\n\\quad\n\\mathbf{y}_0 = \\begin{bmatrix}\n1.05 \\\\ 0.56 \\\\ 0.06 \\\\ -0.13 \\\\ 0.49 \\\\ -0.37\n\\end{bmatrix}.\n$$\n\n在下面的每个测试用例中，您将：\n- 为指定的 $K$ 计算 $\\mathrm{CVS}_K(X_0,\\mathbf{y}_0)$。\n- 通过附加一个与 $X_0$ 的行索引 $d = 1$（从零开始的索引）共线的额外行来构建一个增广数据集 $(X', \\mathbf{y}')$；也就是说，将相同的特征向量 $\\boldsymbol{\\phi}_{1}$ 作为新的第 $(N+1)$ 行附加。附加的能量是该测试用例的指定标量 $y_{\\mathrm{dup}}$。明确地，$X' = \\begin{bmatrix} X_0 \\\\ \\boldsymbol{\\phi}_1^{\\mathsf{T}} \\end{bmatrix}$ 且 $\\mathbf{y}' = \\begin{bmatrix} \\mathbf{y}_0 \\\\ y_{\\mathrm{dup}} \\end{bmatrix}$。\n- 为相同的 $K$ 计算 $\\mathrm{CVS}_K(X',\\mathbf{y}')$。\n- 报告这两个值以及它们的差值 $\\Delta \\mathrm{CVS} = \\mathrm{CVS}_K(X',\\mathbf{y}') - \\mathrm{CVS}_K(X_0,\\mathbf{y}_0)$。\n\n仅使用确定性操作实现上述过程，不含随机性，并对折分配和重复索引 $d = 1$ 使用从零开始的索引。\n\n测试套件：\n- 测试用例 1：$K = 3$，$y_{\\mathrm{dup}} = 0.56$（一致的重复项）。\n- 测试用例 2：$K = 3$，$y_{\\mathrm{dup}} = 0.62$（轻微不一致的重复项）。\n- 测试用例 3：$K = 6$，$y_{\\mathrm{dup}} = 0.86$（强烈不一致的重复项）。\n- 测试用例 4：$K = 2$，$y_{\\mathrm{dup}} = 0.56$（边界折数与一致的重复项）。\n\n输出规格：\n- 对于每个测试用例 $t \\in \\{1,2,3,4\\}$，计算三元组\n$$\n\\big( \\mathrm{CVS}^{\\mathrm{before}}_t, \\ \\mathrm{CVS}^{\\mathrm{after}}_t, \\ \\Delta \\mathrm{CVS}_t \\big).\n$$\n- 将报告的 12 个标量值中的每一个都四舍五入到 6 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下：\n$$\n\\big[ \\mathrm{CVS}^{\\mathrm{before}}_1, \\ \\mathrm{CVS}^{\\mathrm{after}}_1, \\ \\Delta \\mathrm{CVS}_1, \\ \\mathrm{CVS}^{\\mathrm{before}}_2, \\ \\mathrm{CVS}^{\\mathrm{after}}_2, \\ \\Delta \\mathrm{CVS}_2, \\ \\mathrm{CVS}^{\\mathrm{before}}_3, \\ \\mathrm{CVS}^{\\mathrm{after}}_3, \\ \\Delta \\mathrm{CVS}_3, \\ \\mathrm{CVS}^{\\mathrm{before}}_4, \\ \\mathrm{CVS}^{\\mathrm{after}}_4, \\ \\Delta \\mathrm{CVS}_4 \\big].\n$$\n\n注意：\n- 明确地通过 $i \\bmod K$ 实现 $K$-折分配。\n- 使用摩尔-彭若斯伪逆进行 OLS 计算，以确保在共线性下的数值稳定性。\n- 此计算不涉及物理单位。", "solution": "问题陈述是有效的。它在科学上基于线性回归和交叉验证的原理，并应用于计算材料科学，特别是团簇展开方法。该问题是适定的，所有必要的数据、参数和确定性程序都已明确定义。使用摩尔-彭若斯伪逆是处理实验设置中引入的共线性的适当且标准的技术。该问题是客观且可形式化的，没有歧义或矛盾。\n\n任务是计算一个线性模型在向数据集中添加一个共线数据点之前和之后的 $K$-折交叉验证分数（CVS）。模型的参数，称为有效团簇相互作用（ECIs），是使用通过摩尔-彭若斯伪逆（MPP）计算的普通最小二乘法（OLS）估计器来确定的。\n\n整体算法设计基于所描述的 $K$-折交叉验证过程的直接实现。CVS 定义为在所有留出预测上聚合的均方根误差（RMSE）：\n$$\n\\mathrm{CVS}_K(X,\\mathbf{y}) = \\sqrt{ \\frac{1}{N} \\sum_{f=0}^{K-1} \\ \\sum_{i \\in \\mathcal{I}_f} \\left( y_i - \\widehat{y}_i^{(f)} \\right)^2 }\n$$\n其中 $N$ 是结构的总数，$\\mathcal{I}_f$ 是折 $f$ 中的索引集，而 $\\widehat{y}_i^{(f)}$ 是当结构 $i$ 作为折 $f$ 的留出集的一部分时的预测能量。\n\n该过程可以分解为以下步骤：\n\n1.  **数据划分**：数据索引集 $\\{0, 1, \\dots, N-1\\}$ 被确定性地划分为 $K$ 个折。根据问题的规则，索引为 $i$ 的结构被分配到折 $f$，其中 $f = i \\bmod K$。\n\n2.  **迭代训练和测试**：该过程从 $0$ 到 $K-1$ 遍历每个折 $f$。在每次迭代中，与折 $f$ 对应的数据作为测试集，而来自所有其他 $K-1$ 个折的数据构成训练集。\n    - 设 $(X_{-f}, \\mathbf{y}_{-f})$ 为训练数据（设计矩阵和能量向量），$(X_f, \\mathbf{y}_f)$ 为折 $f$ 的测试数据。\n    - 该折的 ECI 向量 $\\widehat{\\mathbf{J}}^{(f)}$ 使用基于 MPP 的 OLS 估计器从训练数据计算得出：\n    $$\n    \\widehat{\\mathbf{J}}^{(f)} = X_{-f}^{+} \\, \\mathbf{y}_{-f}\n    $$\n    摩尔-彭若斯伪逆 $X_{-f}^{+}$ 至关重要。当使用增广数据集时，某些折的训练集 $X_{-f}$ 将包含两个相同的行，导致矩阵秩亏。在这种情况下，标准矩阵逆 $(X_{-f}^{\\mathsf{T}}X_{-f})^{-1}$ 将是未定义的。MPP 提供了一个唯一的最小范数解，确保了数值稳定性。这是通过 `numpy.linalg.pinv` 实现的。\n\n3.  **预测和误差累积**：拟合的模型 $\\widehat{\\mathbf{J}}^{(f)}$ 用于在留出测试集 $X_f$ 上进行预测：\n    $$\n    \\widehat{\\mathbf{y}}_f = X_f \\, \\widehat{\\mathbf{J}}^{(f)}\n    $$\n    将预测的能量 $\\widehat{\\mathbf{y}}_f$（包含对于 $i \\in \\mathcal{I}_f$ 的元素 $\\widehat{y}_i^{(f)}$）与真实能量 $\\mathbf{y}_f$（包含元素 $y_i$）进行比较。计算当前折的残差平方和（SSE），即 $\\sum_{i \\in \\mathcal{I}_f} (y_i - \\widehat{y}_i^{(f)})^2$，并将其加到一个运行总和中。\n\n4.  **CVS 计算**：在遍历所有 $K$ 个折的循环完成后，每个数据点都恰好被用作测试一次。将总 SSE 除以数据点的总数 $N$，然后取该值的平方根，即可得到最终的 CVS。\n\n整个过程被封装在一个函数中。对于每个测试用例，首先使用初始数据集 $(X_0, \\mathbf{y}_0)$ 和指定的 $K$ 调用此函数以找到 $\\mathrm{CVS}^{\\mathrm{before}}$。然后，通过附加 $X_0$ 中索引为 $d=1$ 的行的副本及其对应的能量 $y_{\\mathrm{dup}}$ 来创建增广数据集 $(X', \\mathbf{y}')$，使样本总数增加到 $N'=N+1$。再次使用 $(X', \\mathbf{y}')$ 调用 CVS 函数以找到 $\\mathrm{CVS}^{\\mathrm{after}}$。然后计算差值 $\\Delta \\mathrm{CVS} = \\mathrm{CVS}^{\\mathrm{after}} - \\mathrm{CVS}^{\\mathrm{before}}$。最终输出整理了所有测试用例的这三个值，每个值都四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_cvs(X: np.ndarray, y: np.ndarray, K: int) -> float:\n    \"\"\"\n    Computes the K-fold Cross-Validation Score (CVS) for a linear model.\n    The model is trained using the Moore-Penrose Pseudoinverse.\n    \"\"\"\n    N = X.shape[0]\n    total_sse = 0.0\n\n    for f in range(K):\n        # Create boolean masks for the train/test split for the current fold.\n        # An index i belongs to fold f if i mod K == f.\n        test_mask = np.array([i % K == f for i in range(N)])\n        \n        # Guard against empty test folds, though not expected with the problem's parameters.\n        if not np.any(test_mask):\n            continue\n            \n        train_mask = ~test_mask\n\n        # Guard against empty training folds.\n        if not np.any(train_mask):\n            # If the training set is empty, no model can be fit.\n            # Predictions are undefined, so we can't calculate error.\n            # For this problem's constraints (K = N), this case will not occur.\n            continue\n            \n        X_train, y_train = X[train_mask], y[train_mask]\n        X_test, y_test = X[test_mask], y[test_mask]\n\n        # Compute the Effective Cluster Interactions (ECIs) using the Moore-Penrose Pseudoinverse.\n        # This is robust to collinearity/rank-deficiency in X_train.\n        X_train_pinv = np.linalg.pinv(X_train)\n        J_hat_f = X_train_pinv @ y_train\n\n        # Predict energies for the held-out test set.\n        y_pred_f = X_test @ J_hat_f\n\n        # Calculate and accumulate the sum of squared errors for this fold.\n        fold_sse = np.sum((y_test - y_pred_f)**2)\n        total_sse += fold_sse\n    \n    # The CVS is the root mean square error over all N out-of-sample predictions.\n    cvs = np.sqrt(total_sse / N)\n    return cvs\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating CVS before and after adding a collinear row.\n    \"\"\"\n    # Define the base dataset from the problem statement.\n    X0 = np.array([\n        [1.0, -1.0, -0.2,  0.5],\n        [1.0, -0.5,  0.1, -0.3],\n        [1.0,  0.0, -0.4,  0.2],\n        [1.0,  0.5,  0.2, -0.1],\n        [1.0, -0.3,  0.4, -0.5],\n        [1.0,  0.8, -0.1,  0.4]\n    ])\n    y0 = np.array([1.05, 0.56, 0.06, -0.13, 0.49, -0.37])\n\n    # Define the test cases.\n    test_cases = [\n        # (K, y_dup)\n        (3, 0.56),\n        (3, 0.62),\n        (6, 0.86),\n        (2, 0.56)\n    ]\n\n    # The row to be duplicated is at index d=1 (zero-based).\n    row_to_dup = X0[1:2, :]  # Slicing keeps it as a 2D array for vstack.\n    \n    results = []\n    for K, y_dup in test_cases:\n        # 1. Compute CVS for the original base dataset.\n        cvs_before = calculate_cvs(X0, y0, K)\n\n        # 2. Construct the augmented dataset by appending the duplicate row.\n        X_prime = np.vstack([X0, row_to_dup])\n        y_prime = np.append(y0, y_dup)\n        \n        # 3. Compute CVS for the augmented dataset.\n        cvs_after = calculate_cvs(X_prime, y_prime, K)\n        \n        # 4. Calculate the change in CVS.\n        delta_cvs = cvs_after - cvs_before\n        \n        # 5. Store the triplet of results.\n        results.extend([cvs_before, cvs_after, delta_cvs])\n    \n    # Format the final list of results for printing.\n    # Each value is rounded to 6 decimal places as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n\n    # Print the final output in the required single-line format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3437890"}, {"introduction": "拟合簇展开模型的最终目的通常是预测热力学性质，例如在零开尔文温度下确定稳定的基态结构。这项高级实践将演示如何将最小化簇展开能量的问题转化为一个混合整数线性规划（MILP）问题。通过构建并求解这个 MILP 问题 [@problem_id:3437877]，我们能够在一个巨大的组合空间中高效、精确地搜寻并确定基态构型。", "problem": "考虑一个二维方形布拉维晶格上的二元合金，其具有周期性边界条件，并由一个仅保留对相互作用的最小团簇展开（CE）模型来建模。设方形超胞包含 $L_x \\times L_y$ 个晶格点，用 $i = 1, \\dots, N$ 索引这些格点，其中 $N = L_x L_y$。用二元变量 $x_i \\in \\{0,1\\}$ 表示 A 物种在格点 $i$ 上的占据情况。定义一个伊辛自旋变量 $s_i = 2 x_i - 1 \\in \\{-1, +1\\}$。仅含对相互作用的CE能量（以无量纲约化单位表示）由下式给出：\n$$\nE = \\sum_{\\langle i,j \\rangle_{1}} J_1 \\, s_i s_j + \\sum_{\\langle i,j \\rangle_{2}} J_2 \\, s_i s_j + h \\sum_{i=1}^{N} s_i,\n$$\n其中，$\\langle i,j \\rangle_{1}$ 和 $\\langle i,j \\rangle_{2}$ 分别表示在周期性边界条件下的第一近邻和第二近邻（对角线）对，$J_1$ 和 $J_2$ 是对有效团簇相互作用系数，而 $h$ 是一个偏置占据情况的均匀在位场。物理单位已设定，使得能量是无量纲的。第一近邻由偏移量 $(\\Delta x, \\Delta y) \\in \\{(1,0), (0,1), (-1,0), (0,-1)\\}$ 定义，第二近邻（对角线）由偏移量 $(\\Delta x, \\Delta y) \\in \\{(1,1), (1,-1), (-1,1), (-1,-1)\\}$ 定义，所有位移都对 $(L_x, L_y)$ 取模以强制周期性。\n\n从上述定义出发，仅使用关于二元合金的伊辛表示和周期性晶格上仅含对相互作用的CE结构的一般性事实，推导出一个混合整数线性规划（MILP）公式，该公式能精确表示此CE的基态搜索问题。您的公式必须：\n- 使用 $x_i$ 和辅助变量表示能量，且仅使用线性的项和线性约束。\n- 强制 $x_i \\in \\{0,1\\}$。\n- 在给定的有限超胞上精确表示周期性的第一和第二近邻相互作用。\n- 允许施加一个可选的固定组分约束 $\\sum_{i=1}^{N} x_i = f N$，其中 $f \\in [0,1]$ 是一个预设的分数，且 $f N$ 为整数。\n\n实现一个分支定界求解器，该求解器使用线性规划（LP）松弛来求解MILP，从而为给定的小超胞找到全局最优解。LP松弛问题必须由标准的LP求解器来解决。分支定界算法必须：\n- 使用LP松弛解作为下界。\n- 对分数值的 $x_i$ 变量进行分支，直到达到整数性。\n- 剪掉那些LP下界超过当前最佳整数能量的节点。\n\n您的程序必须在周期性边界条件下构建晶格近邻对，构造MILP，并为下面的每个测试用例计算基态能量。能量必须以无量纲单位报告，并四舍五入到六位小数。\n\n测试套件：\n- 案例1（理想路径）：$L_x = 2$, $L_y = 2$, $J_1 = -1.0$, $J_2 = 0.0$, $h = 0.0$，无组分约束（$f$ 缺失）。\n- 案例2（反铁磁性且固定组分）：$L_x = 2$, $L_y = 2$, $J_1 = +1.0$, $J_2 = 0.0$, $h = 0.0$，固定组分 $f = 0.5$。\n- 案例3（阻挫边缘情况）：$L_x = 2$, $L_y = 2$, $J_1 = +1.0$, $J_2 = -0.4$, $h = 0.0$，无组分约束。\n- 案例4（边界组分）：$L_x = 2$, $L_y = 2$, $J_1 = +1.0$, $J_2 = 0.0$, $h = 0.0$，固定组分 $f = 0.0$。\n\n输出规格：\n- 您的程序应产生单行输出，其中包含四个基态能量，按上述测试用例的顺序排列，形式为方括号内以逗号分隔的列表，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_k$ 是一个浮点数，四舍五入到六位小数，以无量纲单位表示。\n\n不允许有其他输出。", "solution": "用户希望使用团簇展开（CE）模型来寻找二维方格上二元合金的基态能量。该能量表达式等价于一个具有第一和第二近邻相互作用的伊辛哈密顿量，并受周期性边界条件约束。任务是将其表述为一个混合整数线性规划（MILP）问题，并使用一个利用标准线性规划（LP）求解器的自定义分支定界（Branch-and-Bound, B&B）算法求解。\n\n### 步骤1：MILP公式的推导\n\n系统的能量由伊辛自旋变量 $s_i \\in \\{-1, +1\\}$ 给出：\n$$\nE = \\sum_{\\langle i,j \\rangle_{1}} J_1 \\, s_i s_j + \\sum_{\\langle i,j \\rangle_{2}} J_2 \\, s_i s_j + h \\sum_{i=1}^{N} s_i\n$$\n问题要求使用二元占据变量 $x_i \\in \\{0,1\\}$ 进行公式化，这些变量通过 $s_i = 2x_i - 1$ 与自旋变量相关联。\n\n首先，将 $s_i = 2x_i - 1$ 代入能量方程。在位项变为：\n$$\nh \\sum_{i=1}^{N} s_i = h \\sum_{i=1}^{N} (2x_i - 1) = 2h \\sum_{i=1}^{N} x_i - hN\n$$\n该项对于 $x_i$ 是线性的，并带有一个常数偏移量 $-hN$。\n\n对相互作用项 $s_i s_j$ 是二次的：\n$$\ns_i s_j = (2x_i - 1)(2x_j - 1) = 4x_i x_j - 2x_i - 2x_j + 1\n$$\n该表达式包含一个二次项 $x_i x_j$，必须为MILP公式将其线性化。我们为每个相互作用对 $\\langle i,j \\rangle$ 引入一个辅助连续变量 $z_{ij}$，并将其定义为等于乘积 $z_{ij} = x_i x_j$。由于 $x_i$ 和 $x_j$ 是二元的，它们的乘积 $z_{ij}$ 也是二元的。这个等式可以被一组对于二元变量是精确的线性不等式所替代（称为McCormick线性化）：\n1. $z_{ij} \\le x_i$\n2. $z_{ij} \\le x_j$\n3. $z_{ij} \\ge x_i + x_j - 1$\n\n通过此代换，单个对相互作用的能量贡献在 $x_i, x_j$ 和 $z_{ij}$ 上变为线性的：\n$$\nJ_{\\langle i,j \\rangle} s_i s_j = J_{\\langle i,j \\rangle} (4z_{ij} - 2x_i - 2x_j + 1)\n$$\n对所有对求和并包括在位项，总能量为：\n$$\nE = \\sum_{\\langle i,j \\rangle} J_{\\langle i,j \\rangle} \\left(4z_{ij} - 2x_i - 2x_j + 1\\right) + 2h \\sum_i x_i - hN\n$$\n其中 $J_{\\langle i,j \\rangle}$ 是 $J_1$ 或 $J_2$。为了获得MILP的最终线性目标函数，我们按变量重新排列各项：\n$$\nE = \\sum_{\\langle i,j \\rangle} (4 J_{\\langle i,j \\rangle}) z_{ij} + \\sum_i \\left( 2h - 2 \\sum_{j \\in \\text{N}(i)} J_{\\langle i,j \\rangle} \\right) x_i + \\left( \\sum_{\\langle i,j \\rangle} J_{\\langle i,j \\rangle} - hN \\right)\n$$\n这里，$\\text{N}(i)$ 表示格点 $i$ 的所有近邻的集合。最后一项是一个常数偏移量 $E_{\\text{const}}$，可以加到MILP求解器找到的目标值上。\n\n完整的MILP公式是：\n**最小化：**\n$$\nE_{\\text{MILP}} = \\sum_{\\langle i,j \\rangle} c_{ij} z_{ij} + \\sum_i d_i x_i\n$$\n其中 $c_{ij} = 4 J_{\\langle i,j \\rangle}$ 且 $d_i = 2h - 2 \\sum_{j \\in \\text{N}(i)} J_{\\langle i,j \\rangle}$。基态能量为 $E_{GS} = E_{\\text{MILP}}^* + E_{\\text{const}}$。\n\n**约束条件：**\n- 对于每个相互作用对 $\\langle i,j \\rangle$：\n    - $z_{ij} - x_i \\le 0$\n    - $z_{ij} - x_j \\le 0$\n    - $x_i + x_j - z_{ij} \\le 1$\n- 对于每个格点 $i$：\n    - $x_i \\in \\{0, 1\\}$ （由分支定界过程强制执行）\n- 可选的组分约束：\n    - $\\sum_{i=1}^N x_i = fN$ （对于给定的分数 $f$）\n\n### 步骤2：分支定界求解器的算法设计\n\n该MILP将使用分支定界（Branch-and-Bound, B&B）算法求解。\n1.  **晶格和MILP构造**：首先，一个函数为给定的 $L_x \\times L_y$ 晶格构造具有周期性边界条件的第一和第二近邻对列表。然后，它组装MILP矩阵：目标向量 $c$，不等式约束矩阵 $A_{ub}$ 和向量 $b_{ub}$，等式约束矩阵 $A_{eq}$ 和向量 $b_{eq}$（如果组分固定），以及常数能量偏移量 $E_{\\text{const}}$。\n\n2.  **分支定界核心逻辑**：\n    - **节点表示**：B&B树中的每个节点代表一个LP子问题，该问题由原始LP松弛问题加上一组额外的分支约束（即 $x_i$ 变量固定为 $0$ 或 $1$）定义。这些约束通过调整变量的 `bounds` 来管理。\n    - **初始化**：算法从代表原始问题LP松弛（所有 $x_i \\in [0, 1]$）的单个节点（根节点）开始。最小能量的上界初始化为无穷大。使用一个栈来管理待探索的节点（深度优先搜索）。\n    - **迭代**：算法按以下步骤进行：\n        a. 从栈中弹出一个节点（子问题）。\n        b. 使用 `scipy.optimize.linprog` 解决相应的LP松弛问题。\n        c. **剪枝**：\n            i. 如果LP不可行，则剪掉此分支。\n            ii. 如果LP的目标值（此分支的下界）大于当前最佳的全局上界，则剪掉此分支。\n        d. **解分析**：\n            i. 如果所有 $x_i$ 变量的LP解都是整数（在小的容差范围内），则找到了一个有效的整数解。计算其总能量，如果更优，则用于更新全局上界。此分支被剪枝，因为它是整数解树的一个叶节点。\n            ii. 如果至少有一个 $x_k$ 是小数，则这是一个**分支**点。创建两个新的子节点并推入栈中：一个附加约束 $x_k=0$，另一个附加约束 $x_k=1$。\n\n3.  **终止**：当节点栈为空时，算法终止。最终存储的上界是全局最优的基态能量。\n\n此过程保证找到指定CE模型的精确基态能量。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def _build_milp(Lx, Ly, J1, J2, h):\n        \"\"\"\n        Builds the MILP formulation for the given cluster expansion problem.\n        Returns the components needed for the LP solver and B&B algorithm.\n        \"\"\"\n        N = Lx * Ly\n        \n        # 1. Generate neighbor lists and counts\n        sites_coords = {i: (i % Lx, i // Ly) for i in range(N)}\n        coords_sites = {(c, r): i for i, (c, r) in sites_coords.items()}\n\n        first_neighbor_offsets = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        second_neighbor_offsets = [(1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n        adj = [set() for _ in range(N)]\n        adj_type = {} # To store pair type (1 or 2)\n\n        for i in range(N):\n            c, r = sites_coords[i]\n            # First neighbors\n            for dc, dr in first_neighbor_offsets:\n                nc, nr = (c + dc) % Lx, (r + dr) % Ly\n                j = coords_sites[(nc, nr)]\n                if i != j:\n                    adj[i].add(j)\n                    pair = tuple(sorted((i, j)))\n                    if pair not in adj_type:\n                        adj_type[pair] = 1\n            # Second neighbors\n            for dc, dr in second_neighbor_offsets:\n                nc, nr = (c + dc) % Lx, (r + dr) % Ly\n                j = coords_sites[(nc, nr)]\n                if i != j:\n                    adj[i].add(j)\n                    pair = tuple(sorted((i, j)))\n                    # J1 dominates if a pair is both 1st and 2nd nbr\n                    if pair not in adj_type:\n                        adj_type[pair] = 2\n\n        all_pairs = sorted(list(adj_type.keys()))\n        pairs1 = [p for p in all_pairs if adj_type[p] == 1]\n        pairs2 = [p for p in all_pairs if adj_type[p] == 2]\n        \n        # 2. Construct MILP matrices\n        num_x_vars = N\n        num_z_vars = len(all_pairs)\n        num_total_vars = num_x_vars + num_z_vars\n        \n        pair_to_z_idx = {pair: i + num_x_vars for i, pair in enumerate(all_pairs)}\n\n        # Objective function vector `c`\n        c = np.zeros(num_total_vars)\n        for i in range(N):\n            c_i = 2 * h\n            for j in adj[i]:\n                pair = tuple(sorted((i, j)))\n                pair_type = adj_type[pair]\n                J = J1 if pair_type == 1 else J2\n                c_i -= 2 * J\n            c[i] = c_i\n        \n        for pair in all_pairs:\n            z_idx = pair_to_z_idx[pair]\n            pair_type = adj_type[pair]\n            J = J1 if pair_type == 1 else J2\n            c[z_idx] = 4 * J\n            \n        # Constant energy term\n        E_const = len(pairs1) * J1 + len(pairs2) * J2 - h * N\n        \n        # Inequality constraints A_ub * x = b_ub\n        num_ineq_constraints = 3 * num_z_vars\n        A_ub = np.zeros((num_ineq_constraints, num_total_vars))\n        b_ub = np.zeros(num_ineq_constraints)\n\n        row_idx = 0\n        for i, j in all_pairs:\n            z_idx = pair_to_z_idx[(i, j)]\n            # z_ij - x_i = 0\n            A_ub[row_idx, z_idx] = 1\n            A_ub[row_idx, i] = -1\n            row_idx += 1\n            # z_ij - x_j = 0\n            A_ub[row_idx, z_idx] = 1\n            A_ub[row_idx, j] = -1\n            row_idx += 1\n            # x_i + x_j - z_ij = 1\n            A_ub[row_idx, i] = 1\n            A_ub[row_idx, j] = 1\n            A_ub[row_idx, z_idx] = -1\n            b_ub[row_idx] = 1\n            row_idx += 1\n            \n        return c, A_ub, b_ub, E_const, N, num_total_vars\n\n    def _solve_milp_with_bb(c, A_ub, b_ub, A_eq, b_eq, E_const, N, num_total_vars):\n        \"\"\"\n        Solves the MILP using a branch-and-bound algorithm.\n        \"\"\"\n        initial_bounds = [(0, 1)] * num_total_vars\n        stack = [initial_bounds]\n        \n        upper_bound = float('inf')\n\n        while stack:\n            current_bounds = stack.pop()\n            \n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=current_bounds, method='highs-ds')\n            \n            if not res.success:\n                continue\n                \n            lp_min_val = res.fun\n            \n            if lp_min_val + E_const >= upper_bound:\n                continue\n                \n            x_vars = res.x[:N]\n            \n            # Find a fractional variable to branch on\n            frac_idx = -1\n            for i in range(N):\n                if not np.isclose(x_vars[i], round(x_vars[i]), atol=1e-8):\n                    frac_idx = i\n                    break\n                    \n            if frac_idx == -1: # All integer solution\n                current_energy = lp_min_val + E_const\n                if current_energy  upper_bound:\n                    upper_bound = current_energy\n            else: # Branch\n                # Create two new subproblems by copying bounds and adding constraints\n                bounds_0 = list(current_bounds)\n                bounds_0[frac_idx] = (0, 0)\n                stack.append(bounds_0)\n\n                bounds_1 = list(current_bounds)\n                bounds_1[frac_idx] = (1, 1)\n                stack.append(bounds_1)\n\n        return upper_bound\n\n    def run_case(Lx, Ly, J1, J2, h, f=None):\n        \"\"\"\n        Sets up and solves one test case configuration.\n        \"\"\"\n        c, A_ub, b_ub, E_const, N, num_total_vars = _build_milp(Lx, Ly, J1, J2, h)\n        \n        A_eq = None\n        b_eq = None\n        \n        if f is not None:\n            target_sum = f * N\n            A_eq = np.zeros((1, num_total_vars))\n            A_eq[0, :N] = 1\n            b_eq = np.array([target_sum])\n\n        min_energy = _solve_milp_with_bb(c, A_ub, b_ub, A_eq, b_eq, E_const, N, num_total_vars)\n        \n        if min_energy == float('inf'):\n            return np.nan # Should not happen for these test cases\n            \n        return min_energy\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'Lx': 2, 'Ly': 2, 'J1': -1.0, 'J2': 0.0, 'h': 0.0, 'f': None},\n        {'Lx': 2, 'Ly': 2, 'J1': +1.0, 'J2': 0.0, 'h': 0.0, 'f': 0.5},\n        {'Lx': 2, 'Ly': 2, 'J1': +1.0, 'J2': -0.4, 'h': 0.0, 'f': None},\n        {'Lx': 2, 'Ly': 2, 'J1': +1.0, 'J2': 0.0, 'h': 0.0, 'f': 0.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        energy = run_case(**case)\n        results.append(f\"{energy:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3437877"}]}