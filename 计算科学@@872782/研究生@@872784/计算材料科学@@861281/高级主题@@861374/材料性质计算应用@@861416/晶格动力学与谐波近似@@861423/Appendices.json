{"hands_on_practices": [{"introduction": "在计算晶格动力学中，一个核心挑战是用有限的计算模型（超胞）来模拟无限晶体的性质。这种近似不可避免地会引入系统误差。本练习将引导你探索两种关键的误差来源：由有限超胞尺寸导致的力常数实空间截断，以及由离散$q$点网格导致的倒易空间混叠效应。通过亲手实现和对比，你将对声子谱计算中的收敛性问题建立起深刻的直觉。[@problem_id:3460323]", "problem": "考虑一个一维单原子 Bravais 晶格，其晶格常数为 $a$，原子质量均为 $m$。令 $u_n(t)$ 表示位于晶格格点 $n \\in \\mathbb{Z}$ 的原子沿链的标量位移。在谐振近似下，假设任何原子所受的力与位移呈线性关系，且源于仅依赖于整数分离 $|n|$ 的成对中心相互作用，这与晶格的平移不变性一致。令非格点谐波力常数序列为 $\\{\\Phi(n)\\}_{n\\ge 1}$，其中对于所有 $n \\ge 1$ 都有 $\\Phi(n) \\ge 0$。格点上的元素必须满足声学求和规则，从而对于任何均匀平移，净力为零。\n\n你需要从第一性原理（牛顿第二定律、小振动的胡克定律和晶格平移对称性）出发，推导具有波矢 $q$ 和角频率 $\\omega(q)$ 的简正模的晶格动力学运动方程。推导应从实空间中的离散运动方程开始，引入与 Born-von Kármán 周期性边界条件一致的平面波解，并最终得到简正模问题的倒易空间表示，而无需先验地假设 $\\Phi(n)$ 的任何特定衰减规律。从此表示中，确定一个可用力常数的实空间表达式来计算 $\\omega(q)$ 的可实现计算表达式。\n\n为了本次计算任务，特化到一个使用简约单位的模型，其中 $a = 1$，$m = 1$，且力常数标度为1。令非格点力常数由以下物理上合理、短程、严格为正的序列给出\n$$\n\\Phi(n) = \\exp\\!\\left(-\\frac{n}{\\xi}\\right), \\quad n \\in \\mathbb{N},\n$$\n其中 $\\xi > 0$ 是一个范围参数。所有角度必须以弧度处理。所有频率必须以角频率（单位为 $\\mathrm{rad/s}$）报告。使用 $a = 1$ 作为长度单位，并以 $\\mathrm{rad}$ 为单位报告任何波数 $q$。\n\n在实践中，使用沿链方向含 $N$ 个原胞的超胞进行的有限位移计算，会返回对无限大晶体声子的近似。必须评估两种系统误差的来源：\n\n- 实空间截断误差：有限的超胞实际上截断了超出实空间截断半径 $R_c$ 的原子间力常数，对于长度为 $N$ 的一维超胞，该截断半径为 $R_c = \\left\\lfloor \\frac{N-1}{2} \\right\\rfloor$（以 $a$ 为单位）。\n\n- 倒易空间混叠（源于 $q$ 网格截断）：在 $N$ 个等间距波矢的离散网格上对任何倒易空间量进行采样，然后变换回实空间，这对应于将无限范围的实空间序列卷绕成周期为 $N$ 的周期性镜像和，从而将长程贡献折叠回 $[1,\\ldots,\\lfloor N/2 \\rfloor]$ 范围。这会产生对真实晶格格林函数以及目标 $q$ 处声子频率的混叠近似。\n\n您的程序必须从基本的实空间谐波方程和你推导的倒易空间表示出发，实现以下内容：\n\n1. 通过对 $n \\in \\mathbb{N}$ 求和，将你的推导所蕴含的精确无限晶体表达式计算至数值收敛的容差，从而定义给定 $q$ 和 $\\xi$ 的“参考”角频率 $\\omega_{\\mathrm{ref}}(q;\\xi)$。\n\n2. 通过计算相同的表达式，但在 $n = R_c = \\left\\lfloor \\frac{N-1}{2} \\right\\rfloor$ 处截断实空间求和，来定义“超胞截断”角频率 $\\omega_{\\mathrm{cut}}(q;\\xi,N)$。\n\n3. 通过为距离 $n \\in \\{1,\\ldots,\\lfloor N/2 \\rfloor\\}$ 构建一个有效的混叠力常数序列（该序列等于真实 $\\Phi(n)$ 以周期 $N$ 的周期性镜像和），然后使用此混叠序列计算相同的倒易空间表达式，来定义“$q$-混叠”角频率 $\\omega_{\\mathrm{alias}}(q;\\xi,N)$。\n\n4. 对于一个预设的频率容差 $\\varepsilon_\\omega > 0$（单位为 $\\mathrm{rad/s}$），计算一个“最优”实空间截断建议 $R_\\star(\\xi,\\varepsilon_\\omega)$，它是最小的非负整数 $R_c$，使得被忽略的力常数 $\\{ \\Phi(n) : n > R_c \\}$ 对角频率平方的贡献的一个严格的、与 $q$ 无关的上界小于或等于 $\\varepsilon_\\omega^2$。你的推导应从你获得的精确频率的基本表示开始，并且必须只使用对所有 $q$ 都有效的不等式来限定被忽略的尾部的效应。\n\n数值细节和单位：\n\n- 使用 $a = 1$，$m = 1$ 和单位力常数标度，因此角频率单位为 $\\mathrm{rad/s}$。\n\n- 所有波矢 $q$ 均以弧度处理。\n\n- 报告浮点数输出时，四舍五入到恰好 $8$ 位小数。\n\n测试套件：\n\n对于以下每一组参数 $(\\xi, N, q, \\varepsilon_\\omega)$，计算：\n\n- 绝对误差 $|\\omega_{\\mathrm{cut}}(q;\\xi,N) - \\omega_{\\mathrm{ref}}(q;\\xi)|$（单位 $\\mathrm{rad/s}$）。\n\n- 绝对误差 $|\\omega_{\\mathrm{alias}}(q;\\xi,N) - \\omega_{\\mathrm{ref}}(q;\\xi)|$（单位 $\\mathrm{rad/s}$）。\n\n- 推荐的截断半径 $R_\\star(\\xi,\\varepsilon_\\omega)$，作为一个非负整数。\n\n使用测试套件：\n- $(\\xi, N, q, \\varepsilon_\\omega) = (3.0, 5, \\frac{\\pi}{3}, 0.02)$\n- $(\\xi, N, q, \\varepsilon_\\omega) = (3.0, 31, \\frac{\\pi}{3}, 0.02)$\n- $(\\xi, N, q, \\varepsilon_\\omega) = (0.5, 5, \\frac{\\pi}{3}, 0.02)$\n- $(\\xi, N, q, \\varepsilon_\\omega) = (3.0, 31, \\frac{\\pi}{50}, 0.005)$\n- $(\\xi, N, q, \\varepsilon_\\omega) = (3.0, 7, \\pi, 0.02)$\n- $(\\xi, N, q, \\varepsilon_\\omega) = (1.5, 9, \\frac{2\\pi}{3}, 0.02)$\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的列表的列表。每个内部列表对应一个测试用例，并且必须是 $[\\mathrm{err\\_cut}, \\mathrm{err\\_alias}, R_\\star]$ 的形式，其中前两个条目是四舍五入到 $8$ 位小数的浮点数（单位为 $\\mathrm{rad/s}$），第三个是整数。例如：\n$[[x_1,y_1,z_1],[x_2,y_2,z_2],\\ldots]$。", "solution": "该问题被认定为有效，因为它科学地基于固态物理学的原理，问题定义良好、客观且内部一致。因此，我们可以进行完整的推导和求解。\n\n此问题的核心是推导一维单原子晶格的色散关系，然后用它来分析计算声子计算中两种常见的误差来源：实空间截断和倒易空间混叠。最后，推导出一个实用的截断建议。\n\n**第一部分：色散关系的推导**\n\n我们考虑一个一维 Bravais 晶格，其原子质量为 $m$，晶格常数为 $a$。令 $u_n(t)$ 为位于格点 $n$ 的原子偏离其平衡位置 $na$ 的位移。我们在谐振近似下进行研究，其中每个原子所受的力与原子位移成线性关系。问题指定了成对中心相互作用，因此原子 $n$ 上的力取决于所有其他原子 $k$ 的相对位移 $(u_k - u_n)$。考虑到晶格的平移不变性，位于格点 $n$ 和 $n+k$ 的原子之间的力常数仅取决于分离距离 $k$。\n\n令 $\\Phi(k)$（对于 $k \\in \\mathbb{N}$，即 $k \\ge 1$）为相距 $ka$ 的原子之间相互作用的谐波力常数（弹簧常数）。原子 $n+k$ 施加在原子 $n$ 上的力是 $\\Phi(k)(u_{n+k} - u_n)$，原子 $n-k$ 施加的力是 $\\Phi(k)(u_{n-k} - u_n)$。原子 $n$ 上的总力 $F_n$ 是来自所有其他原子的力之和：\n$$ F_n = \\sum_{k=1}^{\\infty} \\Phi(k)(u_{n+k} - u_n) + \\sum_{k=1}^{\\infty} \\Phi(k)(u_{n-k} - u_n) $$\n$$ F_n = \\sum_{k=1}^{\\infty} \\Phi(k) \\left( u_{n+k} + u_{n-k} - 2u_n \\right) $$\n该公式内在地满足了声学求和规则，因为均匀平移（对所有 $n$，$u_n = c$）导致每个原子上的净力为零。\n\n应用牛顿第二定律 $m\\ddot{u}_n = F_n$，我们得到原子 $n$ 的运动方程：\n$$ m \\frac{d^2 u_n}{dt^2} = \\sum_{k=1}^{\\infty} \\Phi(k) \\left( u_{n+k} + u_{n-k} - 2u_n \\right) $$\n我们寻求简正模解，这是一种集体振荡，其中所有原子都以相同的频率 $\\omega$ 和一个明确的波矢 $q$ 运动。这些解由平面波描述。我们对原子 $n$ 的位移做出如下拟设：\n$$ u_n(t) = A e^{i(q(na) - \\omega t)} $$\n其中 $A$ 是振幅。其邻近原子的位移为：\n$$ u_{n\\pm k}(t) = A e^{i(q(n\\pm k)a - \\omega t)} = u_n(t) e^{\\pm iqka} $$\n时间的二阶导数是 $\\ddot{u}_n(t) = -\\omega^2 u_n(t)$。将这些代入运动方程得到：\n$$ -m\\omega^2 u_n(t) = \\sum_{k=1}^{\\infty} \\Phi(k) \\left( u_n(t)e^{iqka} + u_n(t)e^{-iqka} - 2u_n(t) \\right) $$\n两边同除以 $u_n(t)$（非零），我们得到：\n$$ -m\\omega^2 = \\sum_{k=1}^{\\infty} 2\\Phi(k) (\\cos(qka) - 1) $$\n$$ m\\omega^2(q) = 2 \\sum_{k=1}^{\\infty} \\Phi(k) (1 - \\cos(qka)) $$\n这个方程就是色散关系，它将频率 $\\omega$ 与波矢 $q$ 联系起来。使用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，我们得到一个等价且常用的形式：\n$$ m\\omega^2(q) = 4 \\sum_{k=1}^{\\infty} \\Phi(k) \\sin^2\\left(\\frac{qka}{2}\\right) $$\n这就是简正模问题所期望的倒易空间表示。\n\n**第二部分：计算实现**\n\n现在我们特化到使用简约单位 $m=1, a=1$ 以及力常数为 $\\Phi(n) = \\exp(-n/\\xi)$（对于 $n \\in \\mathbb{N}$）的模型。色散关系变为：\n$$ \\omega^2(q;\\xi) = 4 \\sum_{n=1}^{\\infty} e^{-n/\\xi} \\sin^2\\left(\\frac{qn}{2}\\right) $$\n\n1.  **参考频率，$\\omega_{\\mathrm{ref}}(q;\\xi)$**：\n    这是从无限求和中得到的精确频率。对于给定的指数形式 $\\Phi(n)$，该无穷级数可以解析求和。我们使用形式 $\\omega^2(q) = 2 \\sum_{n=1}^{\\infty} e^{-n/\\xi} (1 - \\cos(qn))$。\n    这可以分解为两个几何级数：\n    $$ \\omega_{\\mathrm{ref}}^2(q;\\xi) = 2 \\left( \\sum_{n=1}^{\\infty} (e^{-1/\\xi})^n - \\Re\\left[\\sum_{n=1}^{\\infty} (e^{-1/\\xi}e^{iq})^n\\right] \\right) $$\n    使用几何级数求和公式 $\\sum_{n=1}^{\\infty} z^n = z/(1-z)$（对于 $|z|<1$）：\n    $$ \\sum_{n=1}^{\\infty} (e^{-1/\\xi})^n = \\frac{e^{-1/\\xi}}{1 - e^{-1/\\xi}} = \\frac{1}{e^{1/\\xi} - 1} $$\n    $$ \\sum_{n=1}^{\\infty} (e^{-1/\\xi}e^{iq})^n = \\frac{e^{-1/\\xi}e^{iq}}{1 - e^{-1/\\xi}e^{iq}} $$\n    取第二项和的实部并合并，得到用于实现的最终解析表达式：\n    $$ \\omega_{\\mathrm{ref}}^2(q;\\xi) = 2 \\left( \\frac{1}{e^{1/\\xi}-1} - \\frac{e^{-1/\\xi}\\cos q - e^{-2/\\xi}}{1 - 2e^{-1/\\xi}\\cos q + e^{-2/\\xi}} \\right) $$\n\n2.  **超胞截断频率，$\\omega_{\\mathrm{cut}}(q;\\xi,N)$**：\n    这种近似对应于在截断半径 $R_c = \\lfloor (N-1)/2 \\rfloor$ 之外截断实空间相互作用。求和只计算到 $n=R_c$：\n    $$ \\omega_{\\mathrm{cut}}^2(q;\\xi,N) = 4 \\sum_{n=1}^{R_c} e^{-n/\\xi} \\sin^2\\left(\\frac{qn}{2}\\right) $$\n    这是一个直接计算的有限和。\n\n3.  **$q$-混叠频率，$\\omega_{\\mathrm{alias}}(q;\\xi,N)$**：\n    这种近似源于用一个尺寸为 $N$ 且具有周期性边界条件的有限超胞来建模系统。这实际上将长程相互作用“折叠”回超胞内。对于距离 $n < N/2$ 的相互作用，其混叠力常数 $\\Phi_{\\mathrm{alias}}(n)$ 是所有与周期性相关的距离（即 $n, N-n, N+n, 2N-n, \\ldots$）上的真实力常数之和。\n    对于 $n \\in \\{1, \\ldots, \\lfloor (N-1)/2 \\rfloor\\}$：\n    $$ \\Phi_{\\mathrm{alias}}(n) = \\sum_{j=-\\infty}^{\\infty} \\Phi(|n+jN|) = \\sum_{j=0}^{\\infty} \\Phi(n+jN) + \\sum_{j=1}^{\\infty} \\Phi(jN-n) $$\n    对于 $\\Phi(k) = e^{-k/\\xi}$，这些和是几何级数：\n    $$ \\Phi_{\\mathrm{alias}}(n) = e^{-n/\\xi}\\sum_{j=0}^{\\infty}(e^{-N/\\xi})^j + e^{n/\\xi}\\sum_{j=1}^{\\infty}(e^{-N/\\xi})^j = \\frac{e^{-n/\\xi}}{1-e^{-N/\\xi}} + \\frac{e^{n/\\xi}e^{-N/\\xi}}{1-e^{-N/\\xi}} $$\n    $$ \\Phi_{\\mathrm{alias}}(n) = \\frac{e^{-n/\\xi} + e^{-(N-n)/\\xi}}{1 - e^{-N/\\xi}} $$\n    然后，使用这些有效力常数在超胞晶格的第一布里渊区范围内计算混叠频率：\n    $$ \\omega_{\\mathrm{alias}}^2(q;\\xi,N) = 4 \\sum_{n=1}^{\\lfloor(N-1)/2\\rfloor} \\Phi_{\\mathrm{alias}}(n) \\sin^2\\left(\\frac{qn}{2}\\right) $$\n\n**第三部分：最优实空间截断建议， $R_\\star(\\xi,\\varepsilon_\\omega)$**\n\n我们寻求最小的非负整数截断值 $R_c$，使得对于所有 $n > R_c$ 的被忽略项 $\\Phi(n)$ 对 $\\omega^2$ 的贡献被 $\\varepsilon_\\omega^2$ 所界定，且与波矢 $q$ 无关。\n对 $\\omega^2$ 的误差贡献是：\n$$ \\Delta\\omega^2(q, R_c) = \\omega_{\\mathrm{ref}}^2 - \\omega_{\\mathrm{cut}}^2 = 4 \\sum_{n=R_c+1}^{\\infty} e^{-n/\\xi} \\sin^2\\left(\\frac{qn}{2}\\right) $$\n为了找到一个与 $q$ 无关的上界，我们使用不等式 $\\sin^2(\\theta) \\le 1$：\n$$ \\Delta\\omega^2(q, R_c) \\le 4 \\sum_{n=R_c+1}^{\\infty} e^{-n/\\xi} $$\n这个和是一个几何级数：$\\sum_{n=R_c+1}^{\\infty} (e^{-1/\\xi})^n = \\frac{(e^{-1/\\xi})^{R_c+1}}{1-e^{-1/\\xi}} = \\frac{e^{-(R_c+1)/\\xi}}{1-e^{-1/\\xi}}$。\n我们施加条件，使这个上界小于或等于 $\\varepsilon_\\omega^2$：\n$$ 4 \\frac{e^{-(R_c+1)/\\xi}}{1-e^{-1/\\xi}} \\le \\varepsilon_\\omega^2 $$\n解出 $R_c$：\n$$ e^{-(R_c+1)/\\xi} \\le \\frac{\\varepsilon_\\omega^2(1-e^{-1/\\xi})}{4} $$\n$$ -(R_c+1)/\\xi \\le \\ln\\left( \\frac{\\varepsilon_\\omega^2(1-e^{-1/\\xi})}{4} \\right) $$\n$$ R_c + 1 \\ge -\\xi \\ln\\left( \\frac{\\varepsilon_\\omega^2(1-e^{-1/\\xi})}{4} \\right) $$\n$$ R_c \\ge -\\xi \\ln\\left( \\frac{\\varepsilon_\\omega^2(1-e^{-1/\\xi})}{4} \\right) - 1 $$\n满足此条件的最小非负整数 $R_c$ 是 $R_\\star$。结果通过对右侧取上整并确保其不为负来获得。\n$$ R_\\star(\\xi, \\varepsilon_\\omega) = \\max\\left(0, \\left\\lceil -\\xi \\ln\\left( \\frac{\\varepsilon_\\omega^2(1-e^{-1/\\xi})}{4} \\right) - 1 \\right\\rceil\\right) $$\n这提供了一种严格且计算成本低廉的方法，来为期望的频率精度确定一个足够的实空间截断。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the lattice dynamics problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3.0, 5, np.pi/3, 0.02),\n        (3.0, 31, np.pi/3, 0.02),\n        (0.5, 5, np.pi/3, 0.02),\n        (3.0, 31, np.pi/50, 0.005),\n        (3.0, 7, np.pi, 0.02),\n        (1.5, 9, 2*np.pi/3, 0.02)\n    ]\n\n    results = []\n    for xi, N, q, eps_omega in test_cases:\n        # 1. Reference frequency omega_ref\n        # An exact analytical expression is used for the infinite sum.\n        # This is equivalent to summing to convergence.\n        # Formula used: omega_ref^2 = 2 * (sum(r^n) - Re[sum((r*e^iq)^n)])\n        # where r = exp(-1/xi).\n        r = np.exp(-1.0 / xi)\n        \n        # Sum of r^n from n=1 to inf\n        sum_r_n = r / (1.0 - r)\n        \n        # Sum of r^n * cos(n*q) from n=1 to inf\n        sum_r_n_cos_nq = (r * np.cos(q) - r**2) / (1.0 - 2.0 * r * np.cos(q) + r**2)\n\n        # omega_ref^2 with m=1\n        omega_ref_sq = 2.0 * (sum_r_n - sum_r_n_cos_nq)\n        omega_ref = np.sqrt(omega_ref_sq)\n\n        # 2. Supercell-truncated frequency omega_cut\n        # The sum for force constants is truncated at Rc.\n        Rc = (N - 1) // 2\n        omega_cut_sq = 0.0\n        # Sum is performed using the 4*sin^2 form for numerical stability at q=0 although not strictly needed here.\n        for n in range(1, Rc + 1):\n            phi_n = np.exp(-n / xi)\n            omega_cut_sq += 4.0 * phi_n * (np.sin(q * n / 2.0))**2\n        omega_cut = np.sqrt(omega_cut_sq)\n        err_cut = abs(omega_cut - omega_ref)\n\n        # 3. q-aliasing frequency omega_alias\n        # Uses aliased force constants due to periodic image summation.\n        Rc_alias = (N - 1) // 2\n        omega_alias_sq = 0.0\n        denom_phi_alias = 1.0 - np.exp(-N / xi)\n        \n        # Since all test N are odd, the sum is straightforward.\n        for n in range(1, Rc_alias + 1):\n            # Aliased force constant Phi_alias(n)\n            phi_alias_n = (np.exp(-n / xi) + np.exp(-(N - n) / xi)) / denom_phi_alias\n            omega_alias_sq += 4.0 * phi_alias_n * (np.sin(q * n / 2.0))**2\n        omega_alias = np.sqrt(omega_alias_sq)\n        err_alias = abs(omega_alias - omega_ref)\n\n        # 4. Optimal cutoff R_star\n        # Derived from bounding the tail of the force constant sum.\n        # Condition: 4 * (e^-(Rc+1)/xi / (1-e^-1/xi)) = eps_omega^2\n        log_argument = (eps_omega**2 * (1.0 - r)) / 4.0\n        \n        if log_argument >= 1.0:\n            # The bound is satisfied even for Rc = -1, so the smallest\n            # non-negative integer cutoff is 0.\n            R_star = 0\n        else:\n            # Rc >= -xi * log(log_argument) - 1\n            R_star_float = -xi * np.log(log_argument) - 1.0\n            # R_star is the smallest non-negative integer satisfying the condition.\n            R_star = max(0, math.ceil(R_star_float))\n            \n        # Append results, rounding floats to 8 decimal places.\n        results.append([round(err_cut, 8), round(err_alias, 8), R_star])\n\n    # Final print statement in the exact required format.\n    # The format string ensures that floats are printed with 8 decimal places.\n    output_str = \"[\" + \",\".join([f\"[{r[0]:.8f},{r[1]:.8f},{r[2]}]\" for r in results]) + \"]\"\n\n    print(output_str)\n\nsolve()\n```", "id": "3460323"}, {"introduction": "在确保了计算的数值收敛性之后，我们必须检验结果的物理一致性。本练习聚焦于声学求和规则（Acoustic Sum Rule, ASR），它是平移不变性最直接的推论，规定了声学支声子在布里渊区中心（$\\Gamma$点）的频率必须为零。你将学习如何诊断和修正对ASR的违反，这是获得有物理意义声子谱的关键一步。[@problem_id:3460360]", "problem": "您的任务是设计并实现一种诊断程序，用于检测和量化由于谐振原子间力常数矩阵 $\\Phi(R)$ 中平移不变性（也称为声学求和规则，Acoustic Sum Rule, ASR）被违反而在布里渊区中心（$\\Gamma$ 点）产生的声学声子支中的伪能隙。\n\n请从以下基本原理开始：\n- 在谐振近似中，晶格振动的运动方程由牛顿第二定律应用于小位移给出，这导致了波矢为 $q$ 的动力学矩阵的质量加权本征值问题：\n$$\nD(q)\\,e_\\nu(q) \\;=\\; \\omega_\\nu(q)^2\\, e_\\nu(q),\n$$\n其中 $D(q)$ 是质量加权的动力学矩阵，$\\omega_\\nu(q)$ 是角频率。\n- 在布里渊区中心 $q = \\Gamma$，由于平移不变性，整个晶体的刚性平移必须不产生恢复力，这意味着声学求和规则：三个声学支必须满足 $\\omega_\\nu(\\Gamma)=0$ (对于 $\\nu\\in\\{1,2,3\\}$)。\n\n当在 $\\Gamma$ 点求和的原子间力常数矩阵中平移不变性被放宽（不强制执行）时，该诊断程序必须量化三个声学支在 $\\Gamma$ 点出现的任何伪能隙的大小。然后，您将通过仅调整在位（on-site）的 $3\\times 3$ 矩阵块来强制执行平移不变性，使每个原子的块行和（block-row sum）变为 $3\\times 3$ 的零矩阵，并重新计算诊断值。当伪能隙较大时，诊断值应较大；当在数值稳定的系统中 $\\Gamma$ 点的三个声学支恰好为零时，诊断值应为零。\n\n您的程序必须：\n- 实现 $\\Gamma$ 点的质量加权动力学矩阵：\n$$\nD(\\Gamma) \\;=\\; M^{-\\frac{1}{2}}\\; \\Phi_\\Gamma\\; M^{-\\frac{1}{2}},\n$$\n其中 $M$ 是一个块对角质量矩阵，其对角线上的 $3\\times 3$ 块为 $m_i I_3$（对于原子索引 $i$），$\\Phi_\\Gamma$ 是对周期性镜像求和的 $\\Gamma$ 点原子间力常数矩阵。\n- 计算 $D(\\Gamma)$ 的所有本征值 $\\lambda_k$，它们对应于 $\\omega_k^2$。\n- 定义一个惩罚诊断函数，通过取绝对值最小的三个本征值的平均绝对值来针对 $\\Gamma$ 点的伪声学能隙：\n$$\np \\;=\\; \\frac{1}{3}\\sum_{k=1}^{3} \\left| \\lambda_{(k)} \\right|,\n$$\n其中 $\\lambda_{(k)}$ 是 $D(\\Gamma)$ 的三个绝对值最小的本征值。此诊断函数惩罚三个声学支中任何非零的 $\\omega$，并因为 $\\lambda=\\omega^2$ 而对称地处理小的虚频率。\n- 对提供的测试套件，在不强制执行平移不变性（放宽）和强制执行平移不变性（强制）两种情况下评估 $p$。强制执行是通过最小化地仅修改在位 $3\\times 3$ 矩阵块来实现的，使得对于每个原子 $i$，块行和 $\\sum_j \\Phi_{ij}$ 变为 $3\\times 3$ 的零矩阵。\n\n单位和数值要求：\n- 所有数据均以约化单位提供。设约化时间单位为 $\\tau$。本征值 $\\lambda_k$ 的单位为 $\\tau^{-2}$，诊断值 $p$ 必须以 $\\tau^{-2}$ 报告。所有输出均以标准十进制表示法表示为浮点数，单位为 $\\tau^{-2}$。\n- 此问题不涉及角度，因此不需要角度单位。\n- 此问题不涉及百分比。\n\n测试套件：\n对于每个测试用例，您将获得原子数 $N$、质量向量 $m \\in \\mathbb{R}^N$ 和在 $\\Gamma$ 点求和的原子间力常数矩阵 $\\Phi_\\Gamma \\in \\mathbb{R}^{3N\\times 3N}$（以约化单位表示）。在以下所有情况中，矩阵 $\\Phi_\\Gamma$ 都是对称的。$3\\times 3$ 单位矩阵表示为 $I_3$。\n\n- 测试用例 1（单原子，故意破坏 ASR）：\n  - $N = 1$。\n  - $m = [\\,1.0\\,]$。\n  - $\\Phi_\\Gamma$ 是一个 $3\\times 3$ 矩阵：\n    $$\n    \\Phi_\\Gamma^{(1)} \\;=\\;\n    \\begin{bmatrix}\n    0.02  0.001  -0.002\\\\\n    0.001  -0.01  0.0005\\\\\n    -0.002  0.0005  0.005\n    \\end{bmatrix}.\n    $$\n\n- 测试用例 2（双原子，各向同性弹簧，在原子 1 上有小的在位微扰）：\n  - $N = 2$。\n  - $m = [\\,1.0,\\;2.0\\,]$。\n  - 定义 $K=0.5$，$I_3$ 为单位矩阵。令\n    $$\n    A \\;=\\; K\\,I_3,\\quad\n    B \\;=\\; -K\\,I_3,\\quad\n    C \\;=\\; K\\,I_3,\\quad\n    \\Delta \\;=\\; \\mathrm{diag}(0.01,\\,-0.02,\\;0.005).\n    $$\n    则\n    $$\n    \\Phi_\\Gamma^{(2)} \\;=\\;\n    \\begin{bmatrix}\n      A + \\Delta  B\\\\\n      B  C\n    \\end{bmatrix},\n    $$\n    是一个由 $3\\times 3$ 矩阵块构成的 $6\\times 6$ 矩阵。\n\n- 测试用例 3（双原子，各向异性耦合，不同质量，且两个原子上都有在位微扰）：\n  - $N = 2$。\n  - $m = [\\,1.5,\\;1.0\\,]$。\n  - 定义\n    $$\n    K_{\\mathrm{diag}} \\;=\\; \\mathrm{diag}(0.8,\\;0.6,\\;0.4),\n    $$\n    和对称的在位微扰\n    $$\n    E \\;=\\; \\begin{bmatrix}\n      0.05  0.01  0.0\\\\\n      0.01  -0.03  0.005\\\\\n      0.0  0.005  0.02\n    \\end{bmatrix},\\quad\n    F \\;=\\; \\begin{bmatrix}\n      -0.02  -0.005  0.0\\\\\n      -0.005  0.015  -0.004\\\\\n      0.0  -0.004  -0.01\n    \\end{bmatrix}.\n    $$\n    构造\n    $$\n    A \\;=\\; K_{\\mathrm{diag}} + E,\\quad\n    B \\;=\\; -K_{\\mathrm{diag}},\\quad\n    C \\;=\\; K_{\\mathrm{diag}} + F,\n    $$\n    并组装\n    $$\n    \\Phi_\\Gamma^{(3)} \\;=\\;\n    \\begin{bmatrix}\n      A  B\\\\\n      B  C\n    \\end{bmatrix},\n    $$\n    是一个由 $3\\times 3$ 矩阵块构成的 $6\\times 6$ 矩阵。\n\n在每个测试用例的两次评估之间应用平移不变性（ASR）的强制执行：\n- 对每个原子索引 $i \\in \\{1,\\dots,N\\}$，计算 $3\\times 3$ 的块行和 $S_i = \\sum_{j=1}^N \\Phi_{ij}$，其中 $\\Phi_{ij}$ 表示 $\\Phi_\\Gamma$ 在块行 $i$ 和块列 $j$ 的 $3\\times 3$ 矩阵块。\n- 仅修改每个原子的在位矩阵块为 $\\Phi_{ii} \\leftarrow \\Phi_{ii} - S_i$，以确保每个原子 $i$ 的新块行和变为 $3\\times 3$ 的零矩阵。\n\n您的程序必须计算每个测试用例在两种模式下的惩罚值 $p$：不强制执行 ASR（放宽）和强制执行 ASR（强制）。最终输出必须是单行，包含一个方括号内的逗号分隔浮点数列表。该序列必须按顺序为每个测试用例首先列出放宽的诊断值，然后是强制的诊断值。对于上述三个测试用例，输出格式必须是：\n\"[p1_relaxed,p1_enforced,p2_relaxed,p2_enforced,p3_relaxed,p3_enforced]\"\n其中每个 $p$ 都以 $\\tau^{-2}$ 为单位，表示为浮点数。", "solution": "该问题要求设计并实现一个诊断程序，用于量化在布里渊区中心（$\\Gamma$ 点）声学声子支中出现的伪能隙。这些能隙是由于原子间力常数矩阵中违反平移不变性（也称为声学求和规则，ASR）而产生的。解决方案包括为一个给定的力常数矩阵计算一个定义的惩罚诊断值 `$p$`，然后在应用一个强制执行 ASR 的校正后重新计算它。\n\n其理论基础在于谐振近似下的晶格动力学。晶格中原子的运动方程通过一个质量加权的本征值问题来描述：\n$$\nD(q)\\,e_\\nu(q) = \\omega_\\nu(q)^2\\, e_\\nu(q)\n$$\n在这里，`$q$` 是第一布里渊区中的波矢，`$\\omega_\\nu(q)$` 是第 `$\\nu$` 个声子模式的角频率，`$e_\\nu(q)$` 是相应的极化矢量（本征矢量），`$D(q)$` 是 `$3N \\times 3N$` 的质量加权动力学矩阵，其中 `$N$` 是晶胞中的原子数。\n\n在布里渊区中心（`$q=\\Gamma$`，对应于 `$q=(0,0,0)$`），动力学矩阵定义为：\n$$\nD(\\Gamma) = M^{-\\frac{1}{2}}\\; \\Phi_\\Gamma\\; M^{-\\frac{1}{2}}\n$$\n`$\\Phi_\\Gamma$` 是一个 `$3N \\times 3N$` 的实对称原子间力常数矩阵，它是在晶胞的所有周期性镜像上求和得到的。`$M$` 是一个 `$3N \\times 3N$` 的块对角质量矩阵，其中对角线上的第 `$i$` 个 `$3 \\times 3$` 矩阵块是 `$m_i I_3$`，`$m_i$` 是第 `$i$` 个原子的质量，`$I_3$` 是 `$3 \\times 3$` 的单位矩阵。因此，`$M^{-\\frac{1}{2}}$` 是一个对角矩阵，其第 `$k$` 个对角元素是 `$1/\\sqrt{m_i}$`，其中原子 `$i$` 与笛卡尔坐标 `$k$` 相关联。`$D(\\Gamma)$` 的本征值 `$\\lambda_k$` 是频率的平方，即 `$\\lambda_k = \\omega_k^2$`。\n\n晶体物理学的一个基本原理是平移不变性：整个晶体的刚性平移不能产生任何恢复力。在 `$\\Gamma$` 点，这一原理表现为声学求和规则（ASR）。它规定，对应于晶体沿三个正交方向均匀平移的三个声子支（即声学支）必须具有零频率。在数学上，对于一个满足 ASR 的系统：\n$$\n\\omega_\\nu(\\Gamma) = 0 \\quad \\text{for } \\nu \\in \\{1, 2, 3\\}\n$$\n这意味着 `$D(\\Gamma)$` 的本征值中必须恰好有三个为零。ASR 得以满足的充分必要条件是，对于任何给定原子，其与其他所有原子的原子间力常数之和为零。对于在 `$\\Gamma$` 点求和的矩阵 `$\\Phi_\\Gamma$`，这转化为对其块行和的条件：\n$$\n\\sum_{j=1}^N \\Phi_{ij} = \\mathbf{0}_{3\\times3} \\quad \\text{for all } i \\in \\{1, \\dots, N\\}\n$$\n其中 `$\\Phi_{ij}$` 是耦合原子 `$i$` 和 `$j$` 的 `$3 \\times 3$` 矩阵块，`$\\mathbf{0}_{3\\times3}$` 是 `$3 \\times 3$` 的零矩阵。\n\n在计算实践中，由于数值近似（例如，相互作用的有限截断半径），`$\\Phi_\\Gamma$` 可能无法完美满足此条件。这种违反会导致 `$\\Gamma$` 点的声学模式频率不为零，从而产生一个虚假的、非物理的能隙。\n\n所提出的诊断值 `$p$` 量化了这种违反的程度。它被定义为 `$D(\\Gamma)$` 的三个绝对值最小的本征值的平均绝对值：\n$$\np = \\frac{1}{3}\\sum_{k=1}^{3} \\left| \\lambda_{(k)} \\right|\n$$\n其中 `$\\lambda_{(k)}$` 是三个具有最小 `$\\left| \\lambda \\right|$` 的本征值。这个选择正确地锁定了声学模式，其本征值应为 `$0$`。使用绝对值确保了小的负本征值（对应于虚频率并指示结构不稳定性），这些可能由数值噪声引起，与小的正本征值被对称处理。`$p$` 值越大，表示 ASR 的违反越严重。\n\n计算流程如下：\n1.  **放宽计算** (Relaxed Calculation)：\n    a. 对于给定的测试用例（`$N$`、`$m$`、`$\\Phi_\\Gamma$`），构造 `$3N \\times 3N$` 矩阵 `$M^{-\\frac{1}{2}}$`。这是一个对角矩阵，其对角元素为 `$(m_0^{-1/2}, m_0^{-1/2}, m_0^{-1/2}, m_1^{-1/2}, \\dots)$`。\n    b. 构造动力学矩阵 `$D(\\Gamma) = M^{-\\frac{1}{2}} \\Phi_\\Gamma M^{-\\frac{1}{2}}$`。由于 `$\\Phi_\\Gamma$` 是对称的，`$M^{-\\frac{1}{2}}$` 是对角的，因此 `$D(\\Gamma)$` 也是对称的。\n    c. 计算 `$D(\\Gamma)$` 的所有 `$3N$` 个本征值。\n    d. 找出三个绝对值最小的本征值。\n    e. 使用定义的公式计算 `$p_{\\text{relaxed}}$`。\n\n2.  **ASR 强制执行和强制计算** (ASR Enforcement and Enforced Calculation)：\n    a. 为强制执行 ASR，需要修改 `$\\Phi_\\Gamma$` 矩阵。对每个原子 `$i$`，计算其块行和 `$S_i = \\sum_{j=1}^N \\Phi_{ij}$`。\n    b. 然后校正在位矩阵块 `$\\Phi_{ii}$`：`$\\Phi_{ii}^{\\text{enforced}} = \\Phi_{ii} - S_i$`。这种最小化的调整确保了新的块行和 `$\\sum_{j=1}^N \\Phi_{ij}^{\\text{enforced}}$` 是 `$3 \\times 3$` 的零矩阵，从而满足 ASR。所有其他矩阵块 `$\\Phi_{ij}$` (`$i \\neq j$`) 保持不变。\n    c. 使用校正后的力常数矩阵 `$\\Phi_\\Gamma^{\\text{enforced}}$` 构造一个新的动力学矩阵 `$D(\\Gamma)^{\\text{enforced}}$`。\n    d. 从这个新动力学矩阵的本征值计算惩罚值 `$p_{\\text{enforced}}$`。对于正确实现的强制执行，`$p_{\\text{enforced}}$` 应该为零（或在数值上与零无法区分）。\n\n通过比较 `$p_{\\text{relaxed}}$` 和 `$p_{\\text{enforced}}$`，可以量化初始的 ASR 违反程度并确认其已被校正。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the diagnostic calculations for all test cases.\n    \"\"\"\n\n    def calculate_penalty(N, m, Phi_Gamma):\n        \"\"\"\n        Calculates the diagnostic penalty p for a given system.\n\n        Args:\n            N (int): Number of atoms.\n            m (np.ndarray): Array of atomic masses of shape (N,).\n            Phi_Gamma (np.ndarray): Gamma-summed force-constant matrix of shape (3N, 3N).\n\n        Returns:\n            float: The penalty diagnostic p.\n        \"\"\"\n        if N == 0:\n            return 0.0\n\n        # Construct the inverse square root of the mass matrix M.\n        # This is a diagonal matrix.\n        m_inv_sqrt_diag = np.repeat(1.0 / np.sqrt(m), 3)\n        M_inv_sqrt = np.diag(m_inv_sqrt_diag)\n\n        # Construct the dynamical matrix D(Gamma).\n        # D = M_inv_sqrt @ Phi_Gamma @ M_inv_sqrt\n        # Since M_inv_sqrt is diagonal, this is equivalent to element-wise multiplication\n        # of rows and columns.\n        D_Gamma = Phi_Gamma * np.outer(m_inv_sqrt_diag, m_inv_sqrt_diag)\n        \n        # D_Gamma is real and symmetric, so we can use eigh for numerical stability.\n        eigenvalues = np.linalg.eigh(D_Gamma)[0]\n\n        # The problem asks for the three eigenvalues with the smallest absolute magnitude.\n        # Find the indices that would sort the eigenvalues by their absolute value.\n        sorted_indices = np.argsort(np.abs(eigenvalues))\n        \n        # Select the three smallest magnitude eigenvalues.\n        smallest_three_eigs = eigenvalues[sorted_indices[:3]]\n\n        # Calculate the penalty diagnostic p.\n        p = (1.0 / 3.0) * np.sum(np.abs(smallest_three_eigs))\n        \n        return p\n\n    def enforce_asr(N, Phi_Gamma):\n        \"\"\"\n        Enforces the Acoustic Sum Rule (ASR) on the Phi_Gamma matrix.\n\n        Args:\n            N (int): Number of atoms.\n            Phi_Gamma (np.ndarray): The force-constant matrix to be corrected.\n\n        Returns:\n            np.ndarray: The ASR-enforced force-constant matrix.\n        \"\"\"\n        Phi_enforced = Phi_Gamma.copy()\n        dim = 3 * N\n        \n        # Loop over each atom i to calculate the block-row sum\n        for i in range(N):\n            row_start = 3 * i\n            row_end = 3 * (i + 1)\n            \n            # The block-row sum S_i = sum_j Phi_{ij}\n            block_row_sum = np.sum(Phi_enforced[row_start:row_end, :], axis=1)\n            # Reshape it to 3x3 block sum\n            # We are summing up all columns, so we get a 3-element vector.\n            # To get a 3x3 block-row sum, we must sum blocks.\n            S_i = np.zeros((3, 3))\n            for j in range(N):\n                col_start = 3 * j\n                col_end = 3 * (j + 1)\n                S_i += Phi_enforced[row_start:row_end, col_start:col_end]\n            \n            # Modify the on-site block Phi_ii\n            # Phi_{ii} - Phi_{ii} - S_i\n            Phi_enforced[row_start:row_end, row_start:row_end] -= S_i\n            \n        return Phi_enforced\n\n    # --- Test Case Definitions ---\n\n    # Test Case 1\n    N1 = 1\n    m1 = np.array([1.0])\n    Phi_Gamma_1 = np.array([\n        [0.02, 0.001, -0.002],\n        [0.001, -0.01, 0.0005],\n        [-0.002, 0.0005, 0.005]\n    ])\n\n    # Test Case 2\n    N2 = 2\n    m2 = np.array([1.0, 2.0])\n    K2 = 0.5\n    I3 = np.identity(3)\n    A2 = K2 * I3\n    B2 = -K2 * I3\n    C2 = K2 * I3\n    Delta2 = np.diag([0.01, -0.02, 0.005])\n    Phi_Gamma_2 = np.block([\n        [A2 + Delta2, B2],\n        [B2, C2]\n    ])\n\n    # Test Case 3\n    N3 = 2\n    m3 = np.array([1.5, 1.0])\n    K_diag3 = np.diag([0.8, 0.6, 0.4])\n    E3 = np.array([\n        [0.05, 0.01, 0.0],\n        [0.01, -0.03, 0.005],\n        [0.0, 0.005, 0.02]\n    ])\n    F3 = np.array([\n        [-0.02, -0.005, 0.0],\n        [-0.005, 0.015, -0.004],\n        [0.0, -0.004, -0.01]\n    ])\n    A3 = K_diag3 + E3\n    B3 = -K_diag3\n    C3 = K_diag3 + F3\n    Phi_Gamma_3 = np.block([\n        [A3, B3],\n        [B3, C3]\n    ])\n\n    test_cases = [\n        (N1, m1, Phi_Gamma_1),\n        (N2, m2, Phi_Gamma_2),\n        (N3, m3, Phi_Gamma_3),\n    ]\n\n    results = []\n    for N, m, Phi_relaxed in test_cases:\n        # Calculate penalty for the relaxed (original) matrix\n        p_relaxed = calculate_penalty(N, m, Phi_relaxed)\n        results.append(p_relaxed)\n        \n        # Enforce ASR\n        Phi_enforced = enforce_asr(N, Phi_relaxed)\n        \n        # Calculate penalty for the ASR-enforced matrix\n        p_enforced = calculate_penalty(N, m, Phi_enforced)\n        results.append(p_enforced)\n\n    # Format and print the final results\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3460360"}, {"introduction": "一个收敛且满足ASR的计算仍可能揭示一个深层问题：虚频模式，它标志着晶格的力学不稳定性。这个高级练习将超越简单的诊断。你将学习如何将不稳定性追溯到特定的原子间相互作用，并构建一个最小修正方案来恢复晶格的稳定性，从而将一个非物理的模型转化为有效的模型。[@problem_id:3460382]", "problem": "考虑一个一维布拉菲晶格，每个原胞中有一个原子，并且位移是沿着链方向的标量。在谐振近似和周期性边界条件下，运动方程遵循牛顿第二定律和线性的力-位移关系。实空间中的原子间力常数由一组对相互作用 $\\,\\{\\Phi(R)\\}\\,$ 指定，该相互作用耦合了位于位置 $\\,0\\,$ 的原子与位于位置 $\\,\\pm R\\,$ 的原子，其中 $\\,R \\in \\{a,2a,3a,\\dots\\}\\,$。由于反演对称性，假设 $\\,\\Phi(R)=\\Phi(-R)\\,$，并且在位项满足由对表示所隐含的平移不变性（声学求和规则）。\n\n使用简正模的布洛赫拟设和倒易空间中动力学矩阵的定义，可以推导出角频率的平方 $\\,\\omega^2(k)\\,$ 是该一维动力学矩阵 $\\,D(k)\\,$ 的标量本征值除以质量。您必须：\n- 为具有对称对相互作用 $\\,\\Phi(R)\\,$ 的一维单原子链推导标量 $\\,D(k)\\,$，用 $\\,\\{\\Phi(R)\\}\\,$ 和波矢 $\\,k\\,$ 表示，\n- 识别表征虚模的 $\\,D(k)\\,$ 上的条件，\n- 并构建一个最小修正问题，通过 $\\,\\{\\delta \\Phi(R)\\}\\,$ 扰动给定的 $\\,\\{\\Phi(R)\\}\\,$，以消除在指定的 $\\,k\\,$ 网格上的虚模，同时尊重对称性 $\\,\\Phi(R)=\\Phi(-R)\\,$ 并确保对相互作用强度对于 $\\,R>0\\,$ 满足物理非负性 $\\,\\Phi(R) \\ge 0\\,$。\n\n您的程序必须为每个提供的测试用例实现以下内容：\n1) 给定邻居距离列表 $\\,\\{R_i\\}\\,$ 和初始对力常数 $\\,\\{\\Phi_i\\}\\,$（对于 $\\,i=1,\\dots,N\\,$），在指定的 $\\,k\\,$ 网格上计算 $\\,D(k)\\,$（角度以弧度为单位）。使用无量纲单位，其中质量 $\\,m=1\\,$ 且晶格常数 $\\,a=1\\,$。\n2) 诊断虚模：收集所有满足 $\\,D(k) < 0\\,$ 的网格点。为进行诊断，在每个不稳定的 $\\,k\\,$ 处计算灵敏度 $\\,\\partial D(k)/\\partial \\Phi_i\\,$，并建立一个非负最小二乘估计 $\\,\\delta \\Phi^{\\mathrm{diag}}\\,$，以近似满足每个点的稳定化要求。将具有 $\\,\\delta \\Phi^{\\mathrm{diag}}\\,$ 最大分量的 $\\,i\\,$（从零开始）定义为致错邻居索引。如果不存在虚模，则致错索引必须为 $\\,-1\\,$。\n3) 通过求解以下凸优化问题，计算恢复稳定性的最小修正 $\\,\\{\\delta \\Phi_i\\}\\,$：最小化欧几里得范数 $\\,\\sqrt{\\sum_i (\\delta \\Phi_i)^2}\\,$，约束条件为线性不等式，强制网格中所有 $\\,k\\,$ 的 $\\,D(k) \\ge 0\\,$，以及所有 $\\,i\\,$ 的物理约束 $\\,\\Phi_i + \\delta \\Phi_i \\ge 0\\,$。修正后的力常数为 $\\,\\Phi_i' = \\Phi_i + \\delta \\Phi_i\\,$。角度以弧度为单位。所有量均为无量纲。\n4) 对于每个测试用例，输出一个结果列表，其中包含致错索引，后跟修正后的力常数 $\\,\\{\\Phi_i'\\}\\,$，每个都四舍五入到 $\\,6\\,$ 位小数。\n\n用作基本依据的定义和要求：\n- 牛顿第二定律：$\\,m \\,\\ddot{u}_n = F_n\\,$，其中 $\\,u_n\\,$ 是原子 $\\,n\\,$ 的位移。\n- 谐振近似中的线性力响应：通过原子间力常数 $\\,\\Phi(R)\\,$，力与位移成线性关系。\n- 晶格振动的布洛赫定理：形式为 $\\,u_n \\propto e^{i(kn a - \\omega t)}\\,$ 的试探解。\n- 虚模对应于 $\\,\\omega^2(k) < 0\\,$，在 $\\,m=1\\,$ 时等价于负的标量 $\\,D(k)\\,$。\n\n您的程序必须使用以下测试套件。对于每种情况，都提供了邻居集 $\\,\\{R_i\\}\\,$、初始力常数 $\\,\\{\\Phi_i\\}\\,$ 和 $\\,k\\,$ 网格。角度以弧度为单位。不涉及物理单位；将所有量视为无量纲。\n\n- 测试用例 $\\,1\\,$（由第二邻居驱动的普遍不稳定性）：\n  - $\\,\\{R_i\\} = [1, 2]\\,$\n  - $\\,\\{\\Phi_i\\} = [1.0, -1.2]\\,$\n  - $\\,k\\,$ 网格 $\\,\\mathcal{K} = [\\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]\\,$\n- 测试用例 $\\,2\\,$（第三邻居软化）：\n  - $\\,\\{R_i\\} = [1, 2, 3]\\,$\n  - $\\,\\{\\Phi_i\\} = [0.2, 0.05, -0.1]\\,$\n  - $\\,k\\,$ 网格 $\\,\\mathcal{K} = [\\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]\\,$\n- 测试用例 $\\,3\\,$（边缘情况，除了一个弱的不稳定第三邻居外，刚度接近于零）：\n  - $\\,\\{R_i\\} = [1, 2, 3]\\,$\n  - $\\,\\{\\Phi_i\\} = [0.0, 0.0, -0.01]\\,$\n  - $\\,k\\,$ 网格 $\\,\\mathcal{K} = [\\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]\\,$\n- 测试用例 $\\,4\\,$（已经稳定的参考）：\n  - $\\,\\{R_i\\} = [1, 2]\\,$\n  - $\\,\\{\\Phi_i\\} = [0.8, 0.2]\\,$\n  - $\\,k\\,$ 网格 $\\,\\mathcal{K} = [\\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]\\,$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的结果列表。每个测试用例结果必须是形如 $\\,[$culprit$,\\Phi_1',\\Phi_2',\\dots]$ 的列表，所有浮点数四舍五入到 $\\,6\\,$ 位小数。将它们聚合到一个用方括号括起来的列表中，测试用例结果之间用逗号分隔，不含空格。例如：$\\,[[i_1,\\phi_{1,1}',\\dots],[i_2,\\phi_{2,1}',\\dots],[i_3,\\dots],[i_4,\\dots]]\\,$。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上是合理的、自洽的且定义明确的。它提出了一个计算材料科学中关于晶格稳定性的标准问题，并将其构建为一个凸优化问题，这是一种公认且适当的方法。所有必要的数据和定义均已提供。\n\n解决方案按照问题所描绘的三个阶段进行：首先，推导一维链的动力学矩阵；其次，制定一个诊断程序以识别不稳定性的来源；第三，指定一个基于凸优化的最小修正算法。\n\n**1. 动力学矩阵 $\\,D(k)\\,$ 的推导**\n\n我们考虑一个一维单原子布拉菲晶格，其晶格常数 $\\,a=1\\,$，原子质量 $\\,m=1\\,$。设 $\\,u_n\\,$ 为晶格位置 $\\,n\\,$ 处原子的标量位移。在谐振近似下，该原子的运动方程由牛顿第二定律给出：$\\,m \\ddot{u}_n = F_n\\,$。\n\n作用在原子 $\\,n\\,$ 上的力 $\\,F_n\\,$ 源于其与其他原子的相互作用。对于由力常数 $\\,\\Phi(R_i)\\,$ 表征的对称对相互作用，其中 $\\,R_i\\,$ 是到第 $\\,i\\,$ 个邻居壳层的距离，力为：\n$$\nF_n = \\sum_i \\Phi(R_i) \\left[ (u_{n+R_i} - u_n) + (u_{n-R_i} - u_n) \\right]\n$$\n这里，我们使用了问题是在无量纲单位下的事实，即 $\\,a=1\\,$，所以位于胞腔 $\\,p\\,$ 的原子位置就是 $\\,p\\,$。与距离 $\\,R_i\\,$ 处的原子的相互作用对应于与位置 $\\,n \\pm R_i\\,$ 处原子的相互作用。运动方程变为：\n$$\nm \\ddot{u}_n = \\sum_i \\Phi(R_i) \\left( u_{n+R_i} + u_{n-R_i} - 2u_n \\right)\n$$\n我们寻求布洛赫定理给出的简正模解形式：\n$$\nu_n(t) = A e^{i(kna - \\omega t)} = A e^{i(kn - \\omega t)}\n$$\n因为 $\\,a=1\\,$。位于 $\\,n \\pm R_i\\,$ 位置的邻居原子的位移是：\n$$\nu_{n \\pm R_i}(t) = A e^{i(k(n \\pm R_i) - \\omega t)} = u_n(t) e^{\\pm ikR_i}\n$$\n将这些代入运动方程得到：\n$$\nm (-\\omega^2) u_n = \\sum_i \\Phi(R_i) \\left( u_n e^{ikR_i} + u_n e^{-ikR_i} - 2u_n \\right)\n$$\n除以 $\\,u_n\\,$（非零）得到：\n$$\n-m \\omega^2 = \\sum_i \\Phi(R_i) (e^{ikR_i} + e^{-ikR_i} - 2)\n$$\n使用恒等式 $\\,2\\cos(\\theta) = e^{i\\theta} + e^{-i\\theta}\\,$，我们有：\n$$\n-m \\omega^2 = \\sum_i \\Phi(R_i) (2\\cos(kR_i) - 2)\n$$\n重新整理各项，我们找到色散关系 $\\,\\omega^2(k)\\,$：\n$$\n\\omega^2(k) = \\frac{1}{m} \\sum_i 2\\Phi(R_i) (1 - \\cos(kR_i))\n$$\n问题将标量动力学矩阵 $\\,D(k)\\,$ 定义为 $\\,\\omega^2(k) = D(k)/m\\,$。利用提供的邻居距离列表 $\\,\\{R_i\\}\\,$ 和力常数 $\\,\\{\\Phi_i\\}\\,$，并设 $\\,m=1\\,$，我们得到 $\\,D(k)\\,$ 的表达式：\n$$\nD(k) = \\sum_i 2\\Phi_i (1 - \\cos(kR_i))\n$$\n该表达式固有地满足声学求和规则，确保当 $\\,k \\to 0\\,$ 时 $\\,D(k) \\to 0\\,$，这对应于晶体的平移不变性。\n\n**2. 虚模的条件和诊断程序**\n\n晶格不稳定性由虚频率 $\\,\\omega \\in i\\mathbb{R}\\,$ 的存在所指示。这发生在 $\\,\\omega^2(k) < 0\\,$ 时。由于质量 $\\,m\\,$ 是正的，此条件等价于动力学矩阵的负本征值：\n$$\nD(k) < 0\n$$\n为了诊断这种不稳定性的原因，我们分析力常数 $\\,\\{\\Phi_i\\}\\,$ 的变化如何影响 $\\,D(k)\\,$。$\\,D(k)\\,$ 关于 $\\,\\Phi_i\\,$ 的灵敏度是偏导数：\n$$\n\\frac{\\partial D(k)}{\\partial \\Phi_i} = 2(1 - \\cos(kR_i))\n$$\n设 $\\,\\mathcal{K}_{unstable} = \\{k_j \\mid D(k_j) < 0\\}\\,$ 为网格上系统不稳定的波矢集合。对于每个 $\\,k_j \\in \\mathcal{K}_{unstable}\\,$，我们寻求一个能恢复稳定性的修正 $\\,\\delta\\Phi \\ge 0\\,$，即 $\\,D'(k_j) \\ge 0\\,$。一阶近似下，即为 $\\,D(k_j) + \\sum_i \\frac{\\partial D(k_j)}{\\partial \\Phi_i} \\delta\\Phi_i \\approx 0\\,$。这导致一个线性方程组 $\\,A \\delta\\Phi \\approx b\\,$，其中 $\\,A_{ji} = \\frac{\\partial D(k_j)}{\\partial \\Phi_i}\\,$ 且 $\\,b_j = -D(k_j)\\,$，$\\,b_j > 0\\,$。\n问题指定使用非负最小二乘（NNLS）估计 $\\,\\delta\\Phi^{\\mathrm{diag}}\\,$ 的诊断程序。我们求解问题：\n$$\n\\min_{\\delta\\Phi \\ge 0} \\| A \\delta\\Phi - b \\|_2^2\n$$\n“致错”相互作用被识别为对应于所得向量 $\\,\\delta\\Phi^{\\mathrm{diag}}\\,$ 的最大分量的那个。如果不存在不稳定性，致错索引被指定为 $\\,-1\\,$。\n\n**3. 通过凸优化进行最小修正**\n\n完全修正需要找到最小的扰动 $\\,\\delta\\Phi\\,$，以确保在整个 $\\,k\\,$ 网格上的稳定性，同时满足物理约束。这被构建为一个凸优化问题。\n\n目标是最小化修正的大小，用 $\\,\\delta\\Phi\\,$ 的欧几里得范数来衡量。最小化 $\\,\\|\\delta\\Phi\\|_2\\,$ 等价于最小化其平方 $\\,\\|\\delta\\Phi\\|_2^2 = \\sum_i (\\delta\\Phi_i)^2\\,$，这是一个二次目标函数。\n\n解决方案必须满足两组约束条件：\n1.  **稳定性约束**：修正后的动力学矩阵 $\\,D'(k) = D(k) + \\sum_i \\delta\\Phi_i \\frac{\\partial D(k)}{\\partial \\Phi_i}\\,$，对于提供的网格 $\\,\\mathcal{K}\\,$ 上的所有 $\\,k\\,$ 都必须是非负的。这给出了一组线性不等式约束：\n    $$\n    \\sum_i \\delta\\Phi_i \\cdot 2(1 - \\cos(kR_i)) \\ge -D(k) \\quad \\forall k \\in \\mathcal{K}\n    $$\n2.  **物理性约束**：修正后的力常数 $\\,\\Phi_i' = \\Phi_i + \\delta\\Phi_i\\,$ 对于所有相互作用 $\\,i\\,$ 都必须是非负的。这是另一组线性不等式约束：\n    $$\n    \\delta\\Phi_i \\ge -\\Phi_i \\quad \\forall i\n    $$\n因此，该问题是一个二次规划（QP）问题：\n$$\n\\begin{align*}\n\\text{minimize} \\quad  \\sum_i (\\delta\\Phi_i)^2 \\\\\n\\text{subject to} \\quad  \\sum_i \\delta\\Phi_i \\cdot 2(1 - \\cos(kR_i)) + D(k) \\ge 0, \\quad \\forall k \\in \\mathcal{K} \\\\\n \\Phi_i + \\delta\\Phi_i \\ge 0, \\quad \\forall i\n\\end{align*}\n$$\n这个 QP 问题可以使用标准算法（如序列最小二乘规划，SLSQP）进行数值求解，以找到最优修正向量 $\\,\\delta\\Phi^*\\,$. 最终的、稳定的力常数为 $\\,\\Phi' = \\Phi + \\delta\\Phi^*\\,$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls, minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the lattice stability problem for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        (np.array([1.0, 2.0]), np.array([1.0, -1.2]), np.array([np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi])),\n        # Test Case 2\n        (np.array([1.0, 2.0, 3.0]), np.array([0.2, 0.05, -0.1]), np.array([np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi])),\n        # Test Case 3\n        (np.array([1.0, 2.0, 3.0]), np.array([0.0, 0.0, -0.01]), np.array([np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi])),\n        # Test Case 4\n        (np.array([1.0, 2.0]), np.array([0.8, 0.2]), np.array([np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi])),\n    ]\n\n    results = []\n    for R, Phi, k_grid in test_cases:\n        result = process_case(R, Phi, k_grid)\n        results.append(result)\n\n    # Format the final output string as specified\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        culprit = res[0]\n        phis_prime = res[1:]\n        phi_str = ','.join(f\"{x:.6f}\" for x in phis_prime)\n        output_str += f\"[{culprit},{phi_str}]\"\n        if i < len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\ndef process_case(R, Phi, k_grid):\n    \"\"\"\n    Processes a single test case: diagnoses instability and computes the minimal correction.\n    \"\"\"\n    N = len(Phi)\n\n    # Helper function to compute D(k)\n    def compute_D_values(phi_vec, k_vec, R_vec):\n        # S_matrix[j, i] = 2 * (1 - cos(k_j * R_i))\n        S_matrix = 2.0 * (1.0 - np.cos(np.outer(k_vec, R_vec)))\n        # D_values[j] = sum_i(phi_i * S_ji)\n        return np.dot(S_matrix, phi_vec)\n\n    # 1. Initial Stability Check and Diagnosis\n    D_initial = compute_D_values(Phi, k_grid, R)\n    unstable_indices = np.where(D_initial < 0)[0]\n\n    if len(unstable_indices) == 0:\n        # System is already stable\n        culprit_index = -1\n        Phi_prime = Phi\n    else:\n        # System is unstable, proceed with diagnosis and correction\n        \n        # 2. Diagnosis\n        k_unstable = k_grid[unstable_indices]\n        # Sensitivity matrix A for unstable k-points\n        A = 2.0 * (1.0 - np.cos(np.outer(k_unstable, R)))\n        # Target vector b\n        b = -D_initial[unstable_indices]\n        \n        # Nonnegative least squares to find diagnostic correction\n        delta_phi_diag, _ = nnls(A, b)\n        culprit_index = int(np.argmax(delta_phi_diag))\n\n        # 3. Correction via Convex Optimization\n        # Objective function: minimize ||delta_Phi||^2\n        objective_fun = lambda delta_phi: np.sum(delta_phi**2)\n\n        # Initial guess for the correction\n        delta_phi_0 = np.zeros(N)\n\n        # Build constraints for the optimizer\n        # The use of default arguments in lambda (e.g., k=k_val) is crucial\n        # to capture the value from the loop iteration correctly.\n        constraints = []\n        \n        # Stability constraints: D'(k) >= 0 for all k in the grid\n        for i in range(len(k_grid)):\n            k_val = k_grid[i]\n            D_k_val = D_initial[i]\n            S_k_vec = 2.0 * (1.0 - np.cos(k_val * R))\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, d=D_k_val, s=S_k_vec: d + np.dot(s, x)\n            })\n\n        # Physicality constraints: Phi'_i = Phi_i + delta_Phi_i >= 0\n        for i in range(N):\n            phi_val = Phi[i]\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda x, idx=i, p_val=phi_val: p_val + x[idx]\n            })\n\n        # Solve the Quadratic Programming problem\n        opt_result = minimize(\n            objective_fun,\n            delta_phi_0,\n            method='SLSQP',\n            constraints=constraints,\n            options={'ftol': 1e-9, 'maxiter': 200}\n        )\n\n        delta_phi_optimal = opt_result.x\n        Phi_prime = Phi + delta_phi_optimal\n\n    return [culprit_index] + list(Phi_prime)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3460382"}]}