{"hands_on_practices": [{"introduction": "物理学的一个基石是全同粒子的不可区分性原理。本练习将指导您为任何原子间势实现一个至关重要的验证测试：验证预测的能量在全同原子置换下保持不变。通过比较一个正确设计的势和一个故意违反此对称性的势，您将对如何强制执行和测试这一基本物理约束获得具体的理解 [@problem_id:3498423]。", "problem": "您在计算材料科学领域有一个任务，涉及机器学习原子间势（MLIP）的训练和验证。任何原子间势的一个基本物理要求是，预测的总能量在化学性质相同的原子的置换下应保持不变，因为系统的势能仅取决于原子的位置和化学特性，而不取决于任意的标记。具体来说，考虑一个由 $N$ 个原子组成的系统，其位置为 $\\mathbf{r}_i \\in \\mathbb{R}^3$，物种标签为 $s_i \\in \\{\\text{A}, \\text{B}, \\dots\\}$，其中 $i \\in \\{1,\\dots,N\\}$。目标是构建并实现一个测试，以验证预测能量 $E$ 在化学性质相同的原子组内重新标记下的置换不变性。\n\n从牛顿力学和经典势能框架出发：总势能是位置集合和物种集合的函数，$E = E(\\{\\mathbf{r}_i\\}, \\{s_i\\})$，它必须尊重相同原子的不可区分性。在此基础上，形式化一个算法测试，该测试：\n- 识别与化学性质相同的原子（相同的 $s_i$）相对应的索引组，\n- 在每个组内应用确定性置换（即，在相同物种的原子间重新排序索引，同时保持其他索引不变），\n- 计算每次置换前后的能量，\n- 检查能量是否在规定的容差范围内保持不变，从而确定置换不变性。\n\n为了使测试可执行且在数值上具体，请在相同的构型上使用两个简化的 MLIP 能量模型：\n- 一个置换不变模型 $E_{\\mathrm{PI}}$，定义为\n$$\nE_{\\mathrm{PI}}(\\{\\mathbf{r}_i\\}, \\{s_i\\}) = \\sum_{i=1}^N w_{s_i} \\left( \\sum_{\\substack{j=1 \\\\ j \\neq i}}^N \\exp\\!\\left(-\\frac{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2}{\\sigma^2}\\right) \\right)^2,\n$$\n其中 $w_{s}$ 是一个依赖于物种的权重，$\\sigma$ 是一个正的长度尺度。这个构造使用了对邻居的求和以及一个依赖于物种的权重，并且对于相同物种内原子的重新排序是对称的。\n- 一个刻意设计的非置换不变模型 $E_{\\mathrm{NPI}}$，定义为\n$$\nE_{\\mathrm{NPI}}(\\{\\mathbf{r}_i\\}, \\{s_i\\}) = \\sum_{i=1}^N \\alpha_i \\left( \\sum_{\\substack{j=1 \\\\ j \\neq i}}^N \\exp\\!\\left(-\\frac{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2}{\\sigma^2}\\right) \\right),\n$$\n其中 $\\alpha_i$ 是一个依赖于索引的系数，它只取决于原子索引 $i$ 而不取决于物种；当相同物种的原子在不同索引间重新标记时，这会破坏置换不变性。\n\n对所有测试用例使用以下参数值：\n- 物种权重：$w_{\\text{A}} = 0.7$, $w_{\\text{B}} = 1.2$，\n- 长度尺度：$\\sigma = 0.8$，\n- 不变性检查容差：$\\varepsilon = 10^{-10}$，\n- 索引权重：$\\alpha_i = i$（对 $\\{1,\\dots,N\\}$ 中的 $i$ 使用 1-基索引）。\n\n原子位置以埃（angstrom）为单位指定，但在这些简化模型中，能量通过构造是无量纲的。因为输出是布尔值，所以最终答案不需要单位转换。\n\n构建一套构型测试集，这些构型在科学上是合理的（原子间距在几埃的量级），并覆盖多种情况。对于每个构型，您必须在每个物种组内测试多个确定性置换，具体包括：\n- 每个组内的恒等置换，\n- 每个组内索引顺序的反转，\n- 每个组内循环旋转一个位置（当组的大小至少为 2 时）。\n\n对于一个给定的模型，一个构型是置换不变的，当且仅当所有这些置换构型计算出的能量在容差 $\\varepsilon$ 范围内与原始能量相等。\n\n测试集：\n- 情况 1（理想路径）：$N = 4$，物种 $[\\text{A}, \\text{A}, \\text{B}, \\text{B}]$，位置\n  - $\\mathbf{r}_1 = (0.00, 0.00, 0.00)$,\n  - $\\mathbf{r}_2 = (1.10, 0.00, 0.00)$,\n  - $\\mathbf{r}_3 = (0.50, 0.80, 0.00)$,\n  - $\\mathbf{r}_4 = (1.60, 1.25, 0.30)$.\n- 情况 2（所有物种相同，非对称几何）：$N = 3$，物种 $[\\text{A}, \\text{A}, \\text{A}]$，位置\n  - $\\mathbf{r}_1 = (0.00, 0.00, 0.00)$,\n  - $\\mathbf{r}_2 = (1.00, 0.20, 0.10)$,\n  - $\\mathbf{r}_3 = (0.30, 0.70, 0.40)$.\n- 情况 3（两个相同物种靠近，第三个不同）：$N = 3$，物种 $[\\text{B}, \\text{B}, \\text{A}]$，位置\n  - $\\mathbf{r}_1 = (0.00, 0.00, 0.00)$,\n  - $\\mathbf{r}_2 = (0.30, 0.00, 0.00)$,\n  - $\\mathbf{r}_3 = (0.10, 0.40, 0.20)$.\n- 情况 4（混合组，数量不同）：$N = 5$，物种 $[\\text{A}, \\text{B}, \\text{A}, \\text{B}, \\text{A}]$，位置\n  - $\\mathbf{r}_1 = (0.00, 0.00, 0.00)$,\n  - $\\mathbf{r}_2 = (0.90, 0.10, 0.00)$,\n  - $\\mathbf{r}_3 = (0.30, 1.10, 0.20)$,\n  - $\\mathbf{r}_4 = (1.30, 0.80, 0.20)$,\n  - $\\mathbf{r}_5 = (0.60, 0.40, 1.00)$.\n\n您的程序必须：\n- 实现两个能量模型 $E_{\\mathrm{PI}}$ 和 $E_{\\mathrm{NPI}}$，\n- 为每个测试用例，在每个物种组内生成指定的置换，\n- 计算原始构型和置换后构型的能量，\n- 为每种情况确定两个布尔值：构型对于 $E_{\\mathrm{PI}}$ 是否是置换不变的，以及对于 $E_{\\mathrm{NPI}}$ 是否是置换不变的。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且是一个包含两个布尔值 $[b_{\\mathrm{PI}}, b_{\\mathrm{NPI}}]$ 的列表。例如，输出应类似于 $[[\\text{True},\\text{False}],[\\text{True},\\text{False}],\\dots]$，不含空格。", "solution": "该问题要求创建并实现一个计算测试，以验证一个基本物理原理：势能的置换不变性。在任何由经典力学或量子力学支配的系统中，总势能 $E$ 取决于粒子集合，该集合由其属性（如质量、电荷、物种）和状态变量（如位置、动量）定义。它必须独立于分配给相同粒子的任意标签或索引。对于一个由 $N$ 个原子组成的系统，其位置为 $\\{\\mathbf{r}_i\\}$，化学物种为 $\\{s_i\\}$，其中 $i \\in \\{1, \\dots, N\\}$，这意味着如果我们对索引应用一个仅交换相同物种原子的置换 $P$，能量必须保持不变。形式上，如果对于所有 $i$ 都有 $s_{P(i)} = s_i$，那么能量函数必须满足 $E(\\{\\mathbf{r}_{P(i)}\\}, \\{s_{P(i)}\\}) = E(\\{\\mathbf{r}_i\\}, \\{s_i\\})$。这是一个关键的对称性约束，任何物理上真实的原子间势，包括机器学习模型，都必须满足。\n\n任务是使用提供的两个简化能量模型 $E_{\\mathrm{PI}}$ 和 $E_{\\mathrm{NPI}}$，在一组给定的原子构型上，为此原理形式化一个算法测试。\n\n验证算法流程如下：\n1.  **识别物种组**：对于一个给定的包含 $N$ 个原子、物种为 $\\{s_1, s_2, \\dots, s_N\\}$ 的构型，第一步是将原子索引集合 $\\{0, 1, \\dots, N-1\\}$ 划分为不相交的子集，其中每个子集包含单一化学物种的原子的索引。例如，对于物种 $[\\text{A}, \\text{B}, \\text{A}]$，分组将是 $I_{\\text{A}} = \\{0, 2\\}$ 和 $I_{\\text{B}} = \\{1\\}$。\n\n2.  **生成置换**：对于每个包含至少两个原子的物种组，我们生成一组确定性的、非平凡的置换。问题指定了要为每个组考虑的三种置换类型：恒等、反转和循环旋转。恒等置换作为基准。测试置换是指在一个物种组内重新排序索引，同时保持所有其他索引不变的置换。具体来说，对于每个物种组 $I_s$：\n    *   通过反转 $I_s$ 中索引的顺序来创建反转置换映射。\n    *   通过将 $I_s$ 中的每个索引移动到前一个索引的位置来创建循环置换映射，其中第一个索引移动到最后一个位置。对于大小为 2 的组，这与反转相同。\n\n3.  **计算和比较能量**：测试的核心在于比较原始构型的能量与置换后构型的能量。\n    *   首先，计算原始未置换构型的能量 $E_0$。\n    *   然后，对于每个生成的置换映射 $p$，通过根据 $p$ 重新排序原子的位置和物种数组来构造一个新的构型。设置换后的位置为 $\\{\\mathbf{r}'_i\\}$，物种为 $\\{s'_i\\}$。计算这个新构型的能量 $E_p$。\n    *   不变性检查通过测试原始能量和置换后能量之间的绝对差是否在给定的数值容差 $\\varepsilon$ 内进行：$|E_p - E_0| \\le \\varepsilon$。\n    *   如果对于*所有*生成的测试置换，该条件都成立，则认为模型对于给定的构型是置换不变的。如果只要有一个置换导致了显著的能量变化，该模型就未通过该构型的测试。\n\n这两个能量模型旨在演示这一原理：\n\n-   **置换不变模型 ($E_{\\mathrm{PI}}$)**：\n    $$E_{\\mathrm{PI}}(\\{\\mathbf{r}_i\\}, \\{s_i\\}) = \\sum_{i=1}^N w_{s_i} \\left( \\sum_{\\substack{j=1 \\\\ j \\neq i}}^N \\exp\\!\\left(-\\frac{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2}{\\sigma^2}\\right) \\right)^2$$\n    该模型的不变性源于权重因子 $w_{s_i}$ 依赖于原子的物种 $s_i$，这是一个物理属性。当相同的原子被置换时（例如，交换索引 $k$ 和 $l$，其中 $s_k=s_l$），它们对应的权重也是相同的（$w_{s_k} = w_{s_l}$）。一个原子的能量贡献取决于其物种及其几何环境。置换仅仅是重新排列了外层求和 $\\sum_{i=1}^N$ 中的项，因为被求和的几何环境集合得以保留，所以总和保持不变。该模型预计将通过所有构型的不变性测试。\n\n-   **非置换不变模型 ($E_{\\mathrm{NPI}}$)**：\n    $$E_{\\mathrm{NPI}}(\\{\\mathbf{r}_i\\}, \\{s_i\\}) = \\sum_{i=1}^N \\alpha_i \\left( \\sum_{\\substack{j=1 \\\\ j \\neq i}}^N \\exp\\!\\left(-\\frac{\\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2}{\\sigma^2}\\right) \\right)$$\n    该模型被刻意构造成违反置换不变性。系数 $\\alpha_i = i$ 直接依赖于分配给原子的任意数字索引 $i$，而不是其内在的物理属性（如物种）或其位置。当两个索引为 $k$ 和 $l$ 的原子被置换时，它们的几何环境被交换，但依赖于索引的系数 $\\alpha_k$ 和 $\\alpha_l$ 仍然保留在它们原来的索引位置。现在位于索引 $k$ 的原子的能量贡献变为 $\\alpha_k$ 乘以原先与索引 $l$ 相关联的环境总和。除非两个交换的原子的几何环境偶然相同（对于给定的非对称构型，情况并非如此）或 $\\alpha_k = \\alpha_l$（一个平凡的置换），否则总能量将会改变。该模型预计将无法通过不变性测试。\n\n实现将把此逻辑应用于四个测试用例中的每一个，评估 $E_{\\mathrm{PI}}$ 和 $E_{\\mathrm{NPI}}$，并为每个模型生成一对布尔值，指示测试结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Main function to run the permutation invariance tests.\n    \"\"\"\n    # Define parameters from the problem statement.\n    params = {\n        'w': {'A': 0.7, 'B': 1.2},\n        'sigma': 0.8,\n        'epsilon': 1e-10\n    }\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (positions, species).\n    test_cases = [\n        (\n            [[0.00, 0.00, 0.00], [1.10, 0.00, 0.00], [0.50, 0.80, 0.00], [1.60, 1.25, 0.30]],\n            ['A', 'A', 'B', 'B']\n        ),\n        (\n            [[0.00, 0.00, 0.00], [1.00, 0.20, 0.10], [0.30, 0.70, 0.40]],\n            ['A', 'A', 'A']\n        ),\n        (\n            [[0.00, 0.00, 0.00], [0.30, 0.00, 0.00], [0.10, 0.40, 0.20]],\n            ['B', 'B', 'A']\n        ),\n        (\n            [[0.00, 0.00, 0.00], [0.90, 0.10, 0.00], [0.30, 1.10, 0.20], [1.30, 0.80, 0.20], [0.60, 0.40, 1.00]],\n            ['A', 'B', 'A', 'B', 'A']\n        )\n    ]\n    \n    def energy_pi(positions: np.ndarray, species: np.ndarray, p: dict) -> float:\n        \"\"\"Computes energy using the permutation-invariant model.\"\"\"\n        n_atoms = len(positions)\n        if n_atoms  2:\n            return 0.0\n        \n        dist_sq = cdist(positions, positions, 'sqeuclidean')\n        gauss_terms = np.exp(-dist_sq / (p['sigma']**2))\n        np.fill_diagonal(gauss_terms, 0)\n        \n        local_env_sums = np.sum(gauss_terms, axis=1)\n        weights = np.array([p['w'][s] for s in species])\n        \n        energy = np.sum(weights * (local_env_sums**2))\n        return energy\n\n    def energy_npi(positions: np.ndarray, species: np.ndarray, p: dict) - float:\n        \"\"\"Computes energy using the non-permutation-invariant model.\"\"\"\n        n_atoms = len(positions)\n        if n_atoms  2:\n            return 0.0\n            \n        alphas = np.arange(1, n_atoms + 1)\n        \n        dist_sq = cdist(positions, positions, 'sqeuclidean')\n        gauss_terms = np.exp(-dist_sq / (p['sigma']**2))\n        np.fill_diagonal(gauss_terms, 0)\n        \n        local_env_sums = np.sum(gauss_terms, axis=1)\n        \n        energy = np.sum(alphas * local_env_sums)\n        return energy\n\n    def get_permutation_maps(species: np.ndarray) - list:\n        \"\"\"Generates permutation maps for reversal and cyclic shifts within species groups.\"\"\"\n        n_atoms = len(species)\n        species_groups = {}\n        for i, s_atom in enumerate(species):\n            species_groups.setdefault(s_atom, []).append(i)\n        \n        perm_maps = []\n        original_map = list(range(n_atoms))\n        \n        for group_indices in species_groups.values():\n            if len(group_indices)  2:\n                continue\n            \n            # Create a full permutation map from a permutation of subgroup indices\n            def create_full_map(subgroup_perm):\n                full_map = original_map[:]\n                for i_orig, i_perm in zip(group_indices, subgroup_perm):\n                    full_map[i_orig] = i_perm\n                return full_map\n\n            # Reversal permutation for this group\n            rev_indices = group_indices[::-1]\n            p_map_rev = create_full_map(rev_indices)\n            \n            # The permutation map itself should permute indices, not values.\n            # Let's fix the logic. The permutation p applied to a list x is x[p].\n            # We want to find a map `p` such that `new_pos = pos[p]` etc.\n            # Example: pos = [pA1, pA2, pB1], species = [A, A, B], indices = [0, 1, 2]\n            # Group A indices: [0, 1]. Reverse: [1, 0].\n            # We want to swap atom 0 and 1. So the permutation map is [1, 0, 2].\n            # Original: [A, A, B]. Permuted: [A, A, B]. pos: [pA2, pA1, pB1].\n            perm_map_template = list(range(n_atoms))\n            \n            # Reversal\n            p_map_rev = perm_map_template[:]\n            reversed_group_indices = group_indices[::-1]\n            for i in range(len(group_indices)):\n                p_map_rev[group_indices[i]] = reversed_group_indices[i]\n            if p_map_rev != original_map:\n                perm_maps.append(p_map_rev)\n\n            # Cyclic\n            p_map_cyc = perm_map_template[:]\n            cycled_group_indices = group_indices[-1:] + group_indices[:-1]\n            for i in range(len(group_indices)):\n                p_map_cyc[group_indices[i]] = cycled_group_indices[i]\n            if p_map_cyc != original_map and p_map_cyc not in perm_maps:\n                perm_maps.append(p_map_cyc)\n\n        # The permutation map should be what you index the array with.\n        # If original indices for species A are [i, j], a permutation exchanges them.\n        # So the new array at index i should be the old array at index j.\n        # `new_array[i] = old_array[j]`, `new_array[j] = old_array[i]`.\n        # This corresponds to `new_array = old_array[p]`, where p is the permutation map.\n        # e.g., p = [0, 2, 1, 3] for N=4, swapping atoms 1 and 2.\n        \n        # Let's re-implement get_permutation_maps with the correct logic.\n        final_perm_maps = []\n        id_map = list(range(n_atoms))\n\n        for group_indices in species_groups.values():\n            if len(group_indices)  2:\n                continue\n\n            # Reversal\n            rev_map = id_map[:]\n            group_rev = group_indices[::-1]\n            for k in range(len(group_indices)):\n                rev_map[group_indices[k]] = group_rev[k]\n            if rev_map != id_map:\n                final_perm_maps.append(rev_map)\n\n            # Cyclic shift\n            cyc_map = id_map[:]\n            group_cyc = group_indices[-1:] + group_indices[:-1]\n            for k in range(len(group_indices)):\n                cyc_map[group_indices[k]] = group_cyc[k]\n            if cyc_map != id_map and cyc_map not in final_perm_maps:\n                 final_perm_maps.append(cyc_map)\n\n        return final_perm_maps\n\n\n    def check_invariance_for_case(positions: np.ndarray, species: np.ndarray, p: dict) - list:\n        \"\"\"Checks permutation invariance for a single case for both models.\"\"\"\n        # Calculate original energies\n        e0_pi = energy_pi(positions, species, p)\n        e0_npi = energy_npi(positions, species, p)\n\n        perm_maps = get_permutation_maps(species)\n        \n        is_pi_invariant = True\n        is_npi_invariant = True\n        \n        # If there are no non-trivial permutations, both are invariant by definition\n        if not perm_maps:\n            return [True, True]\n\n        for p_map in perm_maps:\n            # A permutation map p means the new element at index i comes from old index p[i]\n            # This is how numpy advanced indexing works.\n            perm_pos = positions[p_map]\n            perm_species = species[p_map]\n            \n            # Test PI model\n            e_pi = energy_pi(perm_pos, perm_species, p)\n            if abs(e_pi - e0_pi)  p['epsilon']:\n                is_pi_invariant = False\n                \n            # Test NPI model\n            e_npi = energy_npi(perm_pos, perm_species, p)\n            if abs(e_npi - e0_npi)  p['epsilon']:\n                is_npi_invariant = False\n        \n        return [is_pi_invariant, is_npi_invariant]\n\n    results = []\n    for pos_list, species_list in test_cases:\n        positions_np = np.array(pos_list)\n        species_np = np.array(species_list)\n        result = check_invariance_for_case(positions_np, species_np, params)\n        results.append(result)\n\n    # Format output string as [[Bool,Bool],[Bool,Bool],...] with no spaces\n    result_str = \",\".join([str(r).replace(\" \", \"\") for r in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3498423"}, {"introduction": "除了粒子身份，物理定律还必须独立于观察者的坐标系。本练习探讨了这一原理对能量和力的影响，即它们在刚体运动（平移和旋转）下的不变性和等变性。您将构建一个测试，以验证势能保持不变，并且其力能随原子结构正确旋转，这是在各向同性空间中模拟材料的关键属性 [@problem_id:3498502]。", "problem": "构建一个合成数据集，以探究与训练和验证机器学习原子间势相关的等变性与不变性特性。目标是验证对于一个各向同性、可微的成对势，其总能量在三维欧几里得群（E(3)）的旋转和平移下保持不变，而力在三维特殊正交群（SO(3)）下是等变的，即它们与构型的旋转保持一致。从以下基本概念开始：刚性运动由一个满足 $R^{\\top} R = I$ 的旋转矩阵 $R \\in SO(3)$ 和一个平移向量 $t \\in \\mathbb{R}^{3}$ 定义；原子位置 $x_i \\in \\mathbb{R}^{3}$ 的变换方式为 $x'_i = R x_i + t$。原子间距离 $r_{ij} = \\lVert x_i - x_j \\rVert$ 在此类刚性运动下是不变的，一个仅依赖于成对距离的标量势能必须在 $E(3)$ 下保持不变。定义为 $F_i = -\\nabla_{x_i} E$ 的力，在应用于旋转后的构型时，其旋转变换遵循 $F'_i = R F_i$。程序必须实现一个特定的各向同性对势，以使测试完全量化和可复现：使用 Lennard-Jones $12$-$6$ 势，其能量为\n$$\nE_{\\mathrm{LJ}}(X;\\epsilon,\\sigma) = \\sum_{1 \\le i  j \\le N} 4 \\epsilon \\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right],\n$$\n其中 $X = (x_1,\\dots,x_N)$，$N$ 是原子数，$\\epsilon$ 是以 $\\mathrm{eV}$ 为单位的深度参数，$\\sigma$ 是以 $\\text{\\AA}$ 为单位的长度尺度，$r_{ij} = \\lVert x_i - x_j \\rVert$ 的单位是 $\\text{\\AA}$。力必须计算为 $F_i = -\\nabla_{x_i} E_{\\mathrm{LJ}}$，单位为 $\\mathrm{eV}/\\text{\\AA}$。\n\n为了探究违规情况，可选择性地为能量增加一个与取向相关、平移不变的项\n$$\nE_{\\mathrm{orient}}(X; \\alpha, n) = \\alpha \\sum_{i=1}^{N} \\left((x_i - \\bar{x}) \\cdot n\\right)^2,\n$$\n其中 $\\bar{x} = \\frac{1}{N} \\sum_{k=1}^{N} x_k$ 是质心，$n \\in \\mathbb{R}^{3}$ 是实验室坐标系中的一个固定单位向量，$\\alpha$ 的单位是 $\\mathrm{eV}/\\text{\\AA}^2$。总能量则为 $E_{\\mathrm{tot}} = E_{\\mathrm{LJ}} + E_{\\mathrm{orient}}$，总力为 $F_i = -\\nabla_{x_i} E_{\\mathrm{tot}}$。\n\n数据集的构建和评估必须逻辑上遵循基本定义。对于给定的基本构型 $X$，通过应用随机刚性运动 $(R,t)$ 生成一组构型，采样方式如下：旋转必须使用从独立标准正态分量生成的归一化四元数，在 $SO(3)$ 上进行均匀采样（在转换为旋转矩阵之前将四元数归一化为单位长度）；平移必须在一个指定的振幅 $A \\ge 0$ 的区间 $[-A,A]$（单位为 $\\text{\\AA}$）内按分量进行均匀采样。对于纯旋转测试，设置 $A=0$。对于纯平移测试，设置 $R=I$。对于固定角度旋转测试，使用 Rodrigues 旋转公式，并指定旋转轴和角度，其中角度必须以弧度表示。\n\n对于每个变换后的构型 $X'$，计算能量不变性误差\n$$\n\\delta_E = \\frac{\\left|E_{\\mathrm{tot}}(X') - E_{\\mathrm{tot}}(X)\\right|}{\\max\\left(\\lvert E_{\\mathrm{tot}}(X)\\rvert, 10^{-12}\\right)},\n$$\n以及力等变性误差\n$$\n\\delta_F = \\frac{\\left\\lVert F(X') - R F(X)\\right\\rVert_F}{\\max\\left(\\lVert F(X)\\rVert_F, 10^{-12}\\right)},\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示在 $N \\times 3$ 力矩阵上的 Frobenius 范数。通过取最大值 $\\max \\delta_E$ 和 $\\max \\delta_F$ 来聚合数据集中所有运动产生的误差。如果对于指定的容差 $\\tau_E$ 和 $\\tau_F$，同时满足 $\\max \\delta_E \\le \\tau_E$ 和 $\\max \\delta_F \\le \\tau_F$，则该测试用例通过。\n\n所有距离必须以 $\\text{\\AA}$ 计算，能量以 $\\mathrm{eV}$ 计算，力以 $\\mathrm{eV}/\\text{\\AA}$ 计算。角度必须是弧度。程序必须对每个测试用例输出布尔值，以指示其通过或失败。\n\n实现以下测试套件，以确保覆盖度、科学真实性和边缘情况。对于每个用例，将 Lennard-Jones 参数设置为 $\\epsilon = 0.0103\\,\\mathrm{eV}$ 和 $\\sigma = 3.4\\,\\text{\\AA}$：\n\n用例 $1$（一般的 $E(3)$ 不变性/等变性）：$N = 8$，使用随机种子 $1234$ 在边长 $L = 10.0\\,\\text{\\AA}$ 的立方体中均匀采样基本位置，运动次数为 $25$，旋转类型为在 $SO(3)$ 上的“随机”旋转，平移振幅 $A = 5.0\\,\\text{\\AA}$，运动种子 $5678$，无取向项（设置 $\\alpha = 0$），容差为 $\\tau_E = 10^{-12}$ 和 $\\tau_F = 10^{-11}$。\n\n用例 $2$（纯平移边界）：$N = 6$，使用种子 $42$ 在边长 $L = 12.0\\,\\text{\\AA}$ 的立方体中均匀采样基本位置，运动次数为 $10$，旋转设置为单位矩阵 $R = I$，平移振幅 $A = 10.0\\,\\text{\\AA}$，运动种子 $101$，无取向项，容差为 $\\tau_E = 10^{-12}$ 和 $\\tau_F = 10^{-11}$。\n\n用例 $3$（纯旋转边界）：$N = 7$，使用种子 $7$ 在边长 $L = 8.0\\,\\text{\\AA}$ 的立方体中均匀采样基本位置，运动次数为 $12$，使用 Rodrigues 公式设置绕轴 $a = (1,1,2)$ 的固定角度旋转 $\\theta = \\pi/3$，平移振幅 $A = 0.0\\,\\text{\\AA}$，运动种子 $77$，无取向项，容差为 $\\tau_E = 10^{-12}$ 和 $\\tau_F = 10^{-11}$。\n\n用例 $4$（使用与取向相关的项导致的违规）：$N = 8$，使用种子 $99$ 在边长 $L = 9.0\\,\\text{\\AA}$ 的立方体中均匀采样基本位置，运动次数为 $15$，旋转类型为在 $SO(3)$ 上的“随机”旋转，平移振幅 $A = 3.0\\,\\text{\\AA}$，运动种子 $123$，包含与取向相关的项，参数为 $\\alpha = 1.0\\,\\mathrm{eV}/\\text{\\AA}^2$ 和固定单位向量 $n = (0,0,1)$，容差为 $\\tau_E = 10^{-12}$ 和 $\\tau_F = 10^{-11}$。\n\n用例 $5$（近简并距离）：$N = 3$，位置明确定义为 $x_1 = (0,0,0)$、$x_2 = (0.9\\,\\sigma, 0, 0)$ 和 $x_3 = (6\\,\\sigma, 6\\,\\sigma, 0)$（单位为 $\\text{\\AA}$），运动次数为 $5$，旋转类型为在 $SO(3)$ 上的“随机”旋转，平移振幅 $A = 2.0\\,\\text{\\AA}$，运动种子 $909$，无取向项，容差为 $\\tau_E = 10^{-12}$ 和 $\\tau_F = 10^{-11}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是一个布尔值，表示用例 $k$ 是否在其容差范围内通过。不允许有其他输出。", "solution": "用户在计算材料科学领域提供了一个定义明确的问题。该问题具有科学依据，要求对物理原理进行严格实现，并且没有致命缺陷。因此，它被判定为**有效**。\n\n### 基于原理的设计\n\n问题的核心是构建一个计算测试，以验证原子间势的几何对称性。对于均匀且各向同性的空间中任何相互作用的粒子系统，基本物理定律规定，总势能 $E$ 必须在构成欧几里得群 $E(3)$ 的刚体运动（平移和旋转）下保持不变。因此，作用于每个粒子 $i$ 上的力 $F_i = -\\nabla_{x_i} E$ 在这些变换下必须是等变的。这意味着，如果整个原子位置系统 $x_i$ 被一个矩阵 $R \\in SO(3)$ 旋转，那么每个力矢量 $F_i$ 也必须被同一个矩阵 $R$ 旋转，即 $F'_i = R F_i$。这些性质对于任何物理上真实的原子间势都是必不可少的，包括那些由机器学习方法生成的势。\n\n我们的解决方案使用一个众所周知的、各向同性的成对势——Lennard-Jones ($12$-$6$) 势——作为基准真相，来直接测试这些性质。还实现了一个可选的非各向同性项作为阴性对照，以展示该测试如何正确识别违反这些基本对称性的势。\n\n#### 1. 势能和力的计算\n\n总能量 $E_{\\mathrm{tot}}$ 是 Lennard-Jones 势 $E_{\\mathrm{LJ}}$ 和一个可选的与取向相关的项 $E_{\\mathrm{orient}}$ 的和。\n\n**Lennard-Jones (LJ) 项：** LJ 势定义为：\n$$\nE_{\\mathrm{LJ}}(X) = \\sum_{1 \\le i  j \\le N} 4 \\epsilon \\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right]\n$$\n其中 $r_{ij} = \\lVert x_i - x_j \\rVert$ 是原子 $i$ 和 $j$ 之间的距离。由于 $E_{\\mathrm{LJ}}$ 仅依赖于原子间距离，而原子间距离在 $E(3)$ 变换下是不变的，所以 $E_{\\mathrm{LJ}}$ 本身也是不变的。原子 $i$ 上的力是通过能量对其位置 $x_i$ 取负梯度得出的：\n$$\nF_i^{\\mathrm{LJ}} = -\\nabla_{x_i} E_{\\mathrm{LJ}} = \\sum_{j \\neq i} \\frac{24\\epsilon}{r_{ij}^2} \\left[2\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right] (x_i - x_j)\n$$\n此表达式通过遍历所有唯一的原子对，计算成对力，并根据牛顿第三定律（$F_{ij} = -F_{ji}$）为每个原子累加结果来实现。\n\n**与取向相关的项：** 为了测试框架检测违规的能力，增加了一个非各向同性项：\n$$\nE_{\\mathrm{orient}}(X) = \\alpha \\sum_{i=1}^{N} \\left((x_i - \\bar{x}) \\cdot n\\right)^2\n$$\n其中 $\\bar{x}$ 是原子的几何中心，$n$ 是实验室坐标系中的一个固定向量。该项在平移下不变，但在旋转下可变，因为系统的旋转会改变点积 $(x_i - \\bar{x}) \\cdot n$。相应的力为：\n$$\nF_i^{\\mathrm{orient}} = -\\nabla_{x_i} E_{\\mathrm{orient}} = -2\\alpha \\left( \\sum_{j=1}^N \\frac{\\partial}{\\partial x_i} ((x_j - \\bar{x}) \\cdot n) \\right) ((x_j - \\bar{x}) \\cdot n) = -2\\alpha \\left( (x_i - \\bar{x}) \\cdot n \\right) \\left( n - \\frac{1}{N}\\sum_j n \\right) = -2\\alpha \\left(1-\\frac{1}{N}\\right) \\left( (x_i - \\bar{x}) \\cdot n \\right) n\n$$\n总力为 $F_i = F_i^{\\mathrm{LJ}} + F_i^{\\mathrm{orient}}$。\n\n#### 2. 几何变换\n\n该测试涉及对一个基本原子构型 $X$ 应用刚性运动 $(R, t)$ 以生成新的构型 $X'$：\n$$\nx'_i = R x_i + t\n$$\n实现的一个关键部分是生成旋转矩阵 $R \\in SO(3)$。\n-   **均匀随机旋转：** 为了从 $SO(3)$ 中均匀采样，我们从一个标准正态分布中抽取四个独立的随机数来生成一个四元数。这个四维向量被归一化以产生一个单位四元数，然后将其转换为一个 $3 \\times 3$ 的旋转矩阵。这是一种标准的、稳健的无偏采样方法。\n-   **固定轴旋转：** 对于特定的确定性测试，我们使用 Rodrigues' 旋转公式来构建与给定旋转轴 $u$ 和角度 $\\theta$ 相对应的旋转矩阵 $R$：\n    $$\n    R(\\theta, u) = I \\cos\\theta + (1-\\cos\\theta) u u^\\top + [u]_\\times \\sin\\theta\n    $$\n    其中 $I$ 是单位矩阵，$u u^\\top$ 是轴与自身的外积，$[u]_\\times$ 是其叉积矩阵。\n\n#### 3. 误差度量与验证\n\n对于每个变换后的构型 $X'$，我们使用两种相对误差度量来量化对称性的破坏程度。\n\n**能量不变性误差（$\\delta_E$）：**\n$$\n\\delta_E = \\frac{\\left|E_{\\mathrm{tot}}(X') - E_{\\mathrm{tot}}(X)\\right|}{\\max\\left(\\lvert E_{\\mathrm{tot}}(X)\\rvert, 10^{-12}\\right)}\n$$\n对于一个完全不变的势，此误差应为零，仅受浮点精度的限制。\n\n**力等变性误差（$\\delta_F$）：**\n$$\n\\delta_F = \\frac{\\left\\lVert F(X') - R F(X)\\right\\rVert_F}{\\max\\left(\\lVert F(X)\\rVert_F, 10^{-12}\\right)}\n$$\n这里，$F(X)$ 是基本构型的 $N \\times 3$ 力矢量矩阵。$R F(X)$ 代表正确旋转后的力的矩阵，计算为 $F(X) R^\\top$。该误差度量了在旋转结构上计算出的力 $F(X')$ 与原始结构旋转后的力之间的偏差。一个小的 $\\delta_F$ 表示力是等变的。Frobenius 范数 $\\lVert \\cdot \\rVert_F$ 用于聚合所有原子的误差。\n\n分母中包含一个小的常数（$10^{-12}$），以防止在总能量或总力为零的情况下出现除以零的错误。最终的测试结果是通过将一组变换中观察到的最大误差与用户指定的容差 $\\tau_E$ 和 $\\tau_F$ 进行比较来确定的。\n\n#### 4. 算法实现\n\n解决方案的结构是一个遍历预定义测试用例集的循环。对于每个用例：\n1.  生成一个初始原子构型 $X$，可以是在一个立方体内均匀分布生成，也可以是明确定义的坐标。\n2.  计算基本能量 $E_{\\mathrm{tot}}(X)$ 和力 $F(X)$。\n3.  一个循环运行指定的运动次数。在每次迭代中，根据用例的规范生成一个刚性运动 $(R, t)$。\n4.  应用该运动创建 $X'$，并计算其能量 $E_{\\mathrm{tot}}(X')$ 和力 $F(X')$。\n5.  计算误差 $\\delta_E$ 和 $\\delta_F$，并用它们来更新观察到的最大误差。\n6.  最后，将这些最大误差与阈值 $\\tau_E$ 和 $\\tau_F$进行比较，得出布尔值的 `pass`（通过）或 `fail`（失败）结果。\n\n这种结构化的方法确保了物理定律中的基本对称性原理在给定的势模型上得到严格和定量的测试，完全符合问题的严格要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_system_properties(positions, epsilon, sigma, alpha, n_vec):\n    \"\"\"\n    Calculates total energy and forces for a system of atoms.\n    \n    Args:\n        positions (np.ndarray): Nx3 array of atomic positions in Angstroms.\n        epsilon (float): LJ energy depth in eV.\n        sigma (float): LJ length scale in Angstroms.\n        alpha (float): Strength of the orientation-dependent term in eV/Angstrom^2.\n        n_vec (np.ndarray or None): 3-element unit vector for the orientation term.\n\n    Returns:\n        tuple: A tuple containing:\n            - total_energy (float): Total potential energy in eV.\n            - total_forces (np.ndarray): Nx3 array of forces in eV/Angstrom.\n    \"\"\"\n    n_atoms = positions.shape[0]\n    total_energy = 0.0\n    total_forces = np.zeros_like(positions)\n\n    # Lennard-Jones part\n    if n_atoms > 1:\n        dist_matrix = np.linalg.norm(positions[:, np.newaxis, :] - positions[np.newaxis, :, :], axis=2)\n        # Prevent division by zero for i=j\n        dist_matrix[np.arange(n_atoms), np.arange(n_atoms)] = np.inf\n        \n        sig_over_r = sigma / dist_matrix\n        sr6 = sig_over_r ** 6\n        sr12 = sr6 ** 2\n        \n        # Sum over upper triangle for energy\n        total_energy_lj = np.sum(np.triu(4.0 * epsilon * (sr12 - sr6)))\n        total_energy += total_energy_lj\n        \n        # Calculate forces\n        # Force magnitude / r_ij\n        f_mag_over_r = (24.0 * epsilon / dist_matrix**2) * (2.0 * sr12 - sr6)\n        # Set diagonal to zero to avoid self-force\n        np.fill_diagonal(f_mag_over_r, 0)\n        \n        # Force vectors\n        r_ij_vec = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        # Sum forces from all other atoms\n        total_forces_lj = np.sum(f_mag_over_r[:, :, np.newaxis] * r_ij_vec, axis=1)\n        total_forces += total_forces_lj\n\n    # Orientation-dependent part\n    if alpha > 0 and n_vec is not None:\n        centroid = np.mean(positions, axis=0)\n        positions_centered = positions - centroid\n        \n        projections = positions_centered @ n_vec\n        \n        total_energy += alpha * np.sum(projections**2)\n        \n        force_term = -2.0 * alpha * projections\n        # Derivative of x_bar w.r.t x_i is 1/N\n        # F_i = -2*alpha * ( (x_i-x_bar).n ) * ( n - 1/N * n ) => This is incorrect, let's re-derive\n        # d/dx_i (x_j - x_bar) = delta_ij - 1/N\n        # dE/dx_i = 2 * alpha * sum_j ( (x_j-x_bar).n ) * ( (delta_ij - 1/N) . n )\n        # dE/dx_i = 2 * alpha * [ (x_i-x_bar).n * n - 1/N * sum_j ((x_j-x_bar).n) * n ]\n        # sum_j(x_j-x_bar) is zero, so the second term vanishes.\n        force_orient = -2.0 * alpha * np.outer(projections, n_vec)\n        total_forces += force_orient\n\n    return total_energy, total_forces\n\ndef generate_random_rotation(rng):\n    \"\"\"Generates a random SO(3) rotation matrix from a uniform distribution.\"\"\"\n    q = rng.standard_normal(4)\n    q /= np.linalg.norm(q)\n    w, x, y, z = q\n    \n    return np.array([\n        [1 - 2*(y*y + z*z), 2*(x*y - w*z),     2*(x*z + w*y)],\n        [2*(x*y + w*z),     1 - 2*(x*x + z*z), 2*(y*z - w*x)],\n        [2*(x*z - w*y),     2*(y*z + w*x),     1 - 2*(x*x + y*y)]\n    ])\n\ndef rodrigues_rotation(axis, angle):\n    \"\"\"Generates a rotation matrix using Rodrigues' formula.\"\"\"\n    axis = axis / np.linalg.norm(axis)\n    ux, uy, uz = axis\n    c = np.cos(angle)\n    s = np.sin(angle)\n    c1 = 1 - c\n    K = np.array([[0, -uz, uy], [uz, 0, -ux], [-uy, ux, 0]])\n    return np.identity(3) + s * K + c1 * (K @ K)\n\ndef solve():\n    epsilon = 0.0103  # eV\n    sigma = 3.4      # Angstrom\n\n    test_cases = [\n        # Case 1\n        {'N': 8, 'pos_type': 'uniform', 'L': 10.0, 'pos_seed': 1234,\n         'motions_count': 25, 'rot_type': 'random', 'A': 5.0, 'motion_seed': 5678,\n         'alpha': 0.0, 'n': None, 'tau_E': 1e-12, 'tau_F': 1e-11},\n        # Case 2\n        {'N': 6, 'pos_type': 'uniform', 'L': 12.0, 'pos_seed': 42,\n         'motions_count': 10, 'rot_type': 'identity', 'A': 10.0, 'motion_seed': 101,\n         'alpha': 0.0, 'n': None, 'tau_E': 1e-12, 'tau_F': 1e-11},\n        # Case 3\n        {'N': 7, 'pos_type': 'uniform', 'L': 8.0, 'pos_seed': 7,\n         'motions_count': 12, 'rot_type': 'fixed', 'rot_axis': np.array([1.0, 1.0, 2.0]),\n         'rot_angle': np.pi/3, 'A': 0.0, 'motion_seed': 77,\n         'alpha': 0.0, 'n': None, 'tau_E': 1e-12, 'tau_F': 1e-11},\n        # Case 4\n        {'N': 8, 'pos_type': 'uniform', 'L': 9.0, 'pos_seed': 99,\n         'motions_count': 15, 'rot_type': 'random', 'A': 3.0, 'motion_seed': 123,\n         'alpha': 1.0, 'n': np.array([0.0, 0.0, 1.0]), 'tau_E': 1e-12, 'tau_F': 1e-11},\n        # Case 5\n        {'N': 3, 'pos_type': 'explicit',\n         'base_pos_values': np.array([[0.0, 0.0, 0.0], [0.9 * sigma, 0.0, 0.0], [6.0 * sigma, 6.0 * sigma, 0.0]]),\n         'motions_count': 5, 'rot_type': 'random', 'A': 2.0, 'motion_seed': 909,\n         'alpha': 0.0, 'n': None, 'tau_E': 1e-12, 'tau_F': 1e-11}\n    ]\n\n    results = []\n    for case in test_cases:\n        pos_rng = np.random.default_rng(case.get('pos_seed'))\n        motion_rng = np.random.default_rng(case['motion_seed'])\n\n        # Generate base configuration\n        if case['pos_type'] == 'uniform':\n            side = case['L']\n            X_base = pos_rng.uniform(-side / 2, side / 2, size=(case['N'], 3))\n        else: # explicit\n            X_base = case['base_pos_values']\n\n        # Calculate properties for the base configuration\n        E_base, F_base = calculate_system_properties(\n            X_base, epsilon, sigma, case['alpha'], case.get('n')\n        )\n\n        max_delta_E = 0.0\n        max_delta_F = 0.0\n\n        for _ in range(case['motions_count']):\n            # Generate transformation (R, t)\n            if case['rot_type'] == 'random':\n                R = generate_random_rotation(motion_rng)\n            elif case['rot_type'] == 'identity':\n                R = np.identity(3)\n            else: # fixed\n                R = rodrigues_rotation(case['rot_axis'], case['rot_angle'])\n            \n            translation_amp = case['A']\n            if translation_amp > 0:\n                t = motion_rng.uniform(-translation_amp, translation_amp, size=3)\n            else:\n                t = np.zeros(3)\n\n            # Apply transformation\n            X_prime = X_base @ R.T + t\n\n            # Calculate properties for the transformed configuration\n            E_prime, F_prime = calculate_system_properties(\n                X_prime, epsilon, sigma, case['alpha'], case.get('n')\n            )\n\n            # Calculate errors\n            # Energy invariance error\n            denom_E = np.maximum(np.abs(E_base), 1e-12)\n            delta_E = np.abs(E_prime - E_base) / denom_E\n            max_delta_E = np.maximum(max_delta_E, delta_E)\n            \n            # Force equivariance error\n            F_base_rotated = F_base @ R.T\n            denom_F = np.maximum(np.linalg.norm(F_base, 'fro'), 1e-12)\n            delta_F = np.linalg.norm(F_prime - F_base_rotated, 'fro') / denom_F\n            max_delta_F = np.maximum(max_delta_F, delta_F)\n\n        # Check against tolerances\n        passed = (max_delta_E = case['tau_E']) and (max_delta_F = case['tau_F'])\n        results.append(str(passed).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3498502"}, {"introduction": "虽然物理对称性提供了一个理想的蓝图，但它们在计算模型中的实现受到数值限制的影响。最后的这个练习从理想原理转向实际后果，研究模型参数和输入的有限精度（量化）如何引入非物理的人为效应。通过使用量化势运行分子动力学模拟，您将直接测量虚假摩擦和能量漂移，揭示数值细节如何影响模拟的物理真实性 [@problem_id:3498461]。", "problem": "您将在一个受控的一维环境中研究，机器学习原子间势的模型系数和输入描述符的量化如何影响力的连续性，并在微正则动力学过程中引入诸如伪摩擦和能量漂移等非保守性赝象。任务是实现一个完整的、可运行的程序，该程序构建一个在已知解析势数据上训练的简单线性势模型，应用指定的量化方案，通过有限差分从量化能量中推导出力，然后沿轨迹测量三个量化指标。\n\n构建过程基于以下基本定义和经过充分检验的公式。考虑一个质量为 $m$ 的单个粒子，在一维空间中、在真实解析势能 $U(x)$ 及其对应的真实保守力 $F_{\\mathrm{true}}(x) = -\\frac{dU}{dx}$ 的作用下演化。在保守且足够光滑的力场下，使用辛积分的微正则动力学（恒定能量分子动力学，MD）允许有界的能量误差。相比之下，用于传播轨迹的非保守力 $F_{\\mathrm{ml}}(x)$ 通常会导致真实哈密顿量 $H(x,v) = \\frac{1}{2} m v^{2} + U(x)$ 发生能量漂移。沿由 $F_{\\mathrm{ml}}$ 驱动的轨迹 $(x(t), v(t))$， $H$ 的瞬时变化率满足\n$$\n\\frac{dH}{dt} = \\frac{d}{dt}\\left(\\frac{1}{2} m v^{2} + U(x)\\right) = v \\left( F_{\\mathrm{ml}}(x) - F_{\\mathrm{true}}(x) \\right).\n$$\n此外，当力误差系统地投影到与速度相反的方向上时，动力学过程会经历一种有效的伪摩擦，这可以通过将力误差投影到一个线性摩擦模型 $F_{\\mathrm{diss}}(t) = -\\gamma_{\\mathrm{eff}} v(t)$ 并匹配平均功率来量化：\n$$\n\\gamma_{\\mathrm{eff}} = - \\frac{\\langle v \\, (F_{\\mathrm{ml}} - F_{\\mathrm{true}}) \\rangle}{\\langle v^{2} \\rangle},\n$$\n其中 $\\langle \\cdot \\rangle$ 表示沿轨迹的时间平均。\n\n按如下方式设置真实势和一个机器学习线性能量模型。\n\n1. 真实势。使用无量纲的解析势\n$$\nU(x) = \\tfrac{1}{2} k x^{2} + a \\cos(2 \\pi x),\n$$\n参数为 $m = 1$，$k = 1$，$a = 2 \\times 10^{-1}$。三角函数中的角度以弧度为单位。对应的真实力是\n$$\nF_{\\mathrm{true}}(x) = -\\frac{dU}{dx} = -k x + 2 \\pi a \\sin(2 \\pi x).\n$$\n\n2. 线性机器学习能量模型。定义一个描述符向量\n$$\nd(x) = \\begin{bmatrix} x \\\\ x^{2} \\\\ \\cos(2 \\pi x) \\\\ \\sin(2 \\pi x) \\\\ 1 \\end{bmatrix}.\n$$\n通过最小二乘法拟合一个权重向量 $w \\in \\mathbb{R}^{5}$，以在一个训练网格上最小化经验误差 $\\sum_{j} \\left(w^{\\top} d(x_{j}) - U(x_{j})\\right)^{2}$。使用一个包含 $N_{\\mathrm{train}} = 2001$ 个点的均匀间隔训练网格，这些点跨越 $x \\in [-x_{\\max}, x_{\\max}]$，其中 $x_{\\max} = 3 \\times 10^{-1} \\times 5 = 1.5$。未量化的模型是 $E_{\\mathrm{ml}}(x) = w^{\\top} d(x)$。\n\n3. 量化。对于量化步长 $\\Delta  0$，定义均匀中置型量化器 $q_{\\Delta}(z) = \\Delta \\, \\mathrm{round}(z/\\Delta)$，该量化器按元素应用。考虑两种独立的量化机制：\n   - 步长为 $\\Delta_{d}$ 的描述符量化：$d_{q}(x) = q_{\\Delta_{d}}(d(x))$。\n   - 步长为 $\\Delta_{w}$ 的模型权重量化：$w_{q} = q_{\\Delta_{w}}(w)$。\n当两者都应用时，定义量化能量\n$$\nE_{q}(x) = w_{q}^{\\top} d_{q}(x).\n$$\n通过量化能量的对称有限差分导数来定义模型力\n$$\nF_{\\mathrm{ml}}(x) = -\\frac{E_{q}(x+\\delta) - E_{q}(x-\\delta)}{2 \\delta},\n$$\n有限差分步长为 $\\delta = 10^{-4}$。为了在存在不连续性的情况下保持数值稳定性，将力的大小限制在 $|F_{\\mathrm{ml}}(x)| \\le F_{\\max}$，其中 $F_{\\max} = 5 \\times 10^{1}$。\n\n4. 轨迹生成。对于每个指定的 $(\\Delta_{d}, \\Delta_{w})$，从 $x_{0} = 3 \\times 10^{-1}$ 和 $v_{0} = 5 \\times 10^{-1}$ 开始，使用速度-Verlet算法运行一条微正则轨迹，时间步长为 $\\Delta t = 10^{-3}$，共 $N_{\\mathrm{steps}} = 5000$ 步。仅使用 $F_{\\mathrm{ml}}$ 来演化动力学，但为了诊断目的，使用真实势评估 $H(t) = \\frac{1}{2} m v(t)^{2} + U(x(t))$ 并计算 $F_{\\mathrm{true}}(x(t))$。\n\n5. 每个测试用例需报告的指标：\n   - 有效伪摩擦：\n   $$\n   \\gamma_{\\mathrm{eff}} = - \\frac{\\frac{1}{N}\\sum_{n=1}^{N} v_{n} \\left(F_{\\mathrm{ml}}(x_{n}) - F_{\\mathrm{true}}(x_{n})\\right)}{\\frac{1}{N}\\sum_{n=1}^{N} v_{n}^{2}},\n   $$\n   其中 $(x_{n}, v_{n})$ 是每个完整时间步长的相空间样本，且 $N = N_{\\mathrm{steps}}$。\n   - 能量漂移率（每单位时间）：\n   $$\n   r_{E} = \\frac{H(T) - H(0)}{T}, \\quad T = N_{\\mathrm{steps}} \\, \\Delta t.\n   $$\n   - 平均力跳跃幅度：\n   $$\n   J = \\frac{1}{N-1} \\sum_{n=1}^{N-1} \\left| F_{\\mathrm{ml}}(x_{n+1}) - F_{\\mathrm{ml}}(x_{n}) \\right|.\n   $$\n\n所有量均为无量纲。\n\n实现以上内容，并评估以下包含描述符和权重量化步长 $(\\Delta_{d}, \\Delta_{w})$ 的测试套件：\n- 情况 1：$(0, 0)$。\n- 情况 2：$(0, 10^{-3})$。\n- 情况 3：$(10^{-3}, 0)$。\n- 情况 4：$(10^{-3}, 10^{-3})$。\n- 情况 5：$(5 \\times 10^{-2}, 10^{-2})$。\n\n您的程序应产生单行输出，其中包含用方括号括起来的结果，格式为逗号分隔的列表。每个情况对应一个包含三个十进制数 $[\\gamma_{\\mathrm{eff}}, r_{E}, J]$ 的列表，小数点后保留六位数字。例如，整体输出格式必须是\n$$\n\\left[ [\\gamma_{1}, r_{1}, J_{1}], [\\gamma_{2}, r_{2}, J_{2}], [\\gamma_{3}, r_{3}, J_{3}], [\\gamma_{4}, r_{4}, J_{4}], [\\gamma_{5}, r_{5}, J_{5}] \\right],\n$$\n打印在单行上，逗号后没有空格。", "solution": "问题陈述已被解析和验证。我们发现该问题具有科学依据、提法恰当且客观。所有参数、定义和流程均以完整和一致的方式提供，从而能够得出一个唯一且有意义的解。该问题植根于计算材料科学，对机器学习原子间势的量化效应进行了严谨的研究，这是一个相关且重要的课题。所有的物理和数学公式都是合理的。因此，该问题被判定为 **有效**。\n\n解答是按照问题陈述中概述的任务顺序构建的。实现分为四个主要阶段：模型训练、量化力模型的构建、通过分子动力学模拟生成轨迹以及诊断指标的计算。\n\n首先，训练机器学习线性势模型。真实解析势由 $U(x) = \\frac{1}{2} k x^{2} + a \\cos(2 \\pi x)$ 给出，参数为 $k=1$ 和 $a=0.2$。使用区间 $[-1.5, 1.5]$ 内 $N_{\\mathrm{train}} = 2001$ 个均匀间隔的点 $x_j$ 生成一个训练集。在每个点 $x_j$ 处，我们计算真实势能 $y_j = U(x_j)$ 和描述符向量 $d(x_j) = [x_j, x_j^2, \\cos(2\\pi x_j), \\sin(2\\pi x_j), 1]^{\\top}$。目标是找到权重向量 $w \\in \\mathbb{R}^{5}$，以最小化平方误差之和 $\\sum_{j} (w^{\\top} d(x_j) - y_j)^2$。这是一个标准的线性最小二乘问题，可以用矩阵形式表示为最小化 $\\|Dw - y\\|^2$，其中 $D$ 是以 $d(x_j)^{\\top}$ 为行的设计矩阵。最优权重向量 $w$ 是使用数值最小二乘求解器，具体来说是 `numpy.linalg.lstsq`，找到的。这个训练好的向量 $w$ 构成了高精度参考模型。\n\n其次，实现量化的能量和力模型。量化的核心是函数 $q_{\\Delta}(z) = \\Delta \\cdot \\mathrm{round}(z/\\Delta)$，它将一个实数 $z$ 映射到给定步长 $\\Delta$ 的最近倍数。对于 $\\Delta=0$ 的情况，此函数为恒等函数，$q_0(z)=z$。对于由一对量化步长 $(\\Delta_d, \\Delta_w)$ 定义的每个测试用例，量化能量计算为 $E_q(x) = w_q^{\\top} d_q(x)$。在这里，权重被量化，$w_q = q_{\\Delta_w}(w)$，描述符向量也被量化，$d_q(x) = q_{\\Delta_d}(d(x))$。由机器学习势施加的力 $F_{\\mathrm{ml}}(x)$ 是使用步长为 $\\delta = 10^{-4}$ 的对称有限差分格式从该量化能量中导出的：\n$$\nF_{\\mathrm{ml}}(x) = -\\frac{E_q(x+\\delta) - E_q(x-\\delta)}{2\\delta}.\n$$\n能量的量化可能导致尖锐的阶梯状特征，在求导时会产生非常大的、非物理的力。为确保模拟过程中的数值稳定性，计算出的力的大小上限设为 $F_{\\max} = 50$。\n\n第三，为每个测试用例执行分子动力学模拟。一个质量为 $m=1$ 的单个粒子在力 $F_{\\mathrm{ml}}(x)$ 的作用下在一维空间中演化。轨迹使用速度-Verlet积分算法进行传播，时间步长为 $\\Delta t = 10^{-3}$，总共 $N_{\\mathrm{steps}} = 5000$ 步。模拟从初始条件 $(x_0, v_0) = (0.3, 0.5)$ 开始。对于每个步骤 $n$，算法按以下方式进行：\n1. $v_{n+1/2} = v_n + \\frac{1}{m} F_{\\mathrm{ml}}(x_n) \\frac{\\Delta t}{2}$\n2. $x_{n+1} = x_n + v_{n+1/2} \\Delta t$\n3. $v_{n+1} = v_{n+1/2} + \\frac{1}{m} F_{\\mathrm{ml}}(x_{n+1}) \\frac{\\Delta t}{2}$\n完整的位移轨迹 $\\{x_n\\}_{n=0}^{N_{\\mathrm{steps}}}$ 和速度轨迹 $\\{v_n\\}_{n=0}^{N_{\\mathrm{steps}}}$ 被存储起来以供后续分析。\n\n最后，根据生成的轨迹数据计算三个指定的指标。这些指标量化了由量化引入的非保守性赝象。设 $N = N_{\\mathrm{steps}}$。\n1. 有效伪摩擦 $\\gamma_{\\mathrm{eff}}$ 衡量了与速度方向相反的系统性力误差分量。它的计算公式为：\n$$\n\\gamma_{\\mathrm{eff}} = - \\frac{\\sum_{n=1}^{N} v_{n} (F_{\\mathrm{ml}}(x_{n}) - F_{\\mathrm{true}}(x_{n}))}{\\sum_{n=1}^{N} v_{n}^{2}},\n$$\n其中 $F_{\\mathrm{true}}(x) = -x + 0.4\\pi \\sin(2\\pi x)$ 是从真实势 $U(x)$ 推导出的解析力。求和范围是轨迹上从步骤 $n=1$ 到 $n=N$ 的点。\n2. 能量漂移率 $r_E$ 量化了由于 $F_{\\mathrm{ml}}$ 的非保守性，真实总能量 $H(t) = \\frac{1}{2}mv(t)^2 + U(x(t))$ 发生变化的速率。它是在总模拟时间 $T = N \\Delta t$ 内计算的：\n$$\nr_E = \\frac{H(t=T) - H(t=0)}{T}.\n$$\n3. 平均力跳跃幅度 $J$ 衡量了连续时间步之间力分布的不连续性，这是量化能量面分段常数特性的直接结果。它的计算公式为：\n$$\nJ = \\frac{1}{N-1} \\sum_{n=1}^{N-1} |F_{\\mathrm{ml}}(x_{n+1}) - F_{\\mathrm{ml}}(x_n)|.\n$$\n对五个测试用例中的每一个重复此过程，并将每个用例得到的三元指标组 $[\\gamma_{\\mathrm{eff}}, r_E, J]$ 编译成最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of analyzing quantization effects in a 1D machine-learned potential.\n    The process involves:\n    1. Training a linear model on an analytic potential.\n    2. Looping through test cases with different quantization parameters.\n    3. For each case, running a molecular dynamics simulation using the quantized force.\n    4. Calculating metrics (spurious friction, energy drift, force jumps) from the trajectory.\n    5. Formatting and printing the results.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    m = 1.0\n    k = 1.0\n    a = 2.0e-1\n    pi = np.pi\n\n    N_train = 2001\n    x_max = 3.0e-1 * 5.0\n    delta = 1.0e-4\n    F_max = 5.0e1\n\n    dt = 1.0e-3\n    N_steps = 5000\n    x0 = 3.0e-1\n    v0 = 5.0e-1\n\n    test_cases = [\n        (0.0, 0.0),             # Case 1\n        (0.0, 1.0e-3),          # Case 2\n        (1.0e-3, 0.0),          # Case 3\n        (1.0e-3, 1.0e-3),       # Case 4\n        (5.0e-2, 1.0e-2)        # Case 5\n    ]\n\n    # --- Helper Functions ---\n    def U_true(x):\n        return 0.5 * k * x**2 + a * np.cos(2.0 * pi * x)\n\n    def F_true(x):\n        return -k * x + 2.0 * pi * a * np.sin(2.0 * pi * x)\n\n    def descriptor_vec(x):\n        return np.array([x, x**2, np.cos(2.0 * pi * x), np.sin(2.0 * pi * x), 1.0])\n\n    def descriptor_matrix(x_vals):\n        return np.vstack([descriptor_vec(x).T for x in x_vals])\n    \n    def quantizer(z, q_step):\n        if q_step == 0.0:\n            return z\n        return q_step * np.round(z / q_step)\n\n    # --- 1. Model Training ---\n    x_train = np.linspace(-x_max, x_max, N_train)\n    U_train = U_true(x_train)\n    D_train = descriptor_matrix(x_train)\n    w_fit, _, _, _ = np.linalg.lstsq(D_train, U_train, rcond=None)\n\n    # --- Main Loop over Test Cases ---\n    all_results = []\n    for delta_d, delta_w in test_cases:\n\n        # --- 2. Define Quantized Force Model for the current case ---\n        w_q = quantizer(w_fit, delta_w)\n\n        def E_q(x):\n            d_x = descriptor_vec(x)\n            d_q = quantizer(d_x, delta_d)\n            return np.dot(w_q, d_q)\n\n        def F_ml(x):\n            force = -(E_q(x + delta) - E_q(x - delta)) / (2.0 * delta)\n            return np.clip(force, -F_max, F_max)\n\n        # --- 3. Trajectory Generation ---\n        x_traj = np.zeros(N_steps + 1)\n        v_traj = np.zeros(N_steps + 1)\n        x_traj[0], v_traj[0] = x0, v0\n        \n        # Velocity-Verlet Integration\n        F_current = F_ml(x_traj[0])\n        for n in range(N_steps):\n            v_half_step = v_traj[n] + (F_current / m) * (dt / 2.0)\n            x_traj[n+1] = x_traj[n] + v_half_step * dt\n            F_next = F_ml(x_traj[n+1])\n            v_traj[n+1] = v_half_step + (F_next / m) * (dt / 2.0)\n            F_current = F_next\n            \n        # --- 4. Metric Calculation ---\n        # Select trajectory points from step 1 to N_steps for averaging\n        x_eval = x_traj[1:]\n        v_eval = v_traj[1:]\n        F_ml_eval = np.array([F_ml(x) for x in x_eval])\n        F_true_eval = F_true(x_eval)\n\n        # a) Effective spurious friction (gamma_eff)\n        force_error = F_ml_eval - F_true_eval\n        numerator_gamma = np.sum(v_eval * force_error)\n        denominator_gamma = np.sum(v_eval**2)\n        gamma_eff = -numerator_gamma / denominator_gamma if denominator_gamma != 0 else 0.0\n\n        # b) Energy drift rate (r_E)\n        H0 = 0.5 * m * v_traj[0]**2 + U_true(x_traj[0])\n        H_final = 0.5 * m * v_traj[-1]**2 + U_true(x_traj[-1])\n        T = N_steps * dt\n        r_E = (H_final - H0) / T\n\n        # c) Mean force jump magnitude (J)\n        # Force jumps are between consecutive steps n and n+1, starting from n=1\n        F_ml_for_J_calc = F_ml_eval\n        force_jumps = np.abs(np.diff(F_ml_for_J_calc))\n        J = np.mean(force_jumps) if len(force_jumps) > 0 else 0.0\n        \n        all_results.append([gamma_eff, r_E, J])\n    \n    # --- Final Output Formatting ---\n    formatted_cases = []\n    for res_case in all_results:\n        formatted_cases.append(f\"[{res_case[0]:.6f},{res_case[1]:.6f},{res_case[2]:.6f}]\")\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```", "id": "3498461"}]}