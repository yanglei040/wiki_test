{"hands_on_practices": [{"introduction": "在晶体学中，同一个周期性结构可以由无数种不同的晶胞来描述。为了在材料数据库中进行有效的数据检索和比较，我们必须为每个晶体结构建立一个唯一的、规范的表示形式。本实践将指导您实现Niggli约化算法，这是一种寻找这种规范晶胞的基础技术，它能帮助您深入理解晶格变换背后的数学原理，并掌握处理晶体结构数据的核心技能。[@problem_id:3463942]", "problem": "您会获得一组测试用例，每个用例都由一个实空间晶格基矢（一个由三个线性无关的笛卡尔坐标表示的晶格矢量构成的矩阵）和一组以分数坐标表示的原子位置指定。您的任务是编写一个完整且可运行的程序，仅从关于布拉菲晶格和整数基变换操作的核心定义出发，构建一个尼格利（Niggli）约化原胞，并将所有原子分数坐标一致地转换到该约化表示中。\n\n需要使用的基本依据和定义：\n- 三维布拉菲晶格是由基矢矩阵 $\\mathbf{L} \\in \\mathbb{R}^{3 \\times 3}$ 生成的矢量集合 $\\{\\mathbf{r} = \\mathbf{L}\\mathbf{f} \\mid \\mathbf{f} \\in \\mathbb{Z}^3\\}$，其中 $\\mathbf{L}$ 的列是晶格矢量 $\\mathbf{a}$、$\\mathbf{b}$、$\\mathbf{c}$。度规张量为 $\\mathbf{G} = \\mathbf{L}^{\\mathsf{T}}\\mathbf{L}$，其元素为 $G_{ij} = \\mathbf{v}_i \\cdot \\mathbf{v}_j$，其中 $\\mathbf{v}_1=\\mathbf{a}$、$\\mathbf{v}_2=\\mathbf{b}$、$\\mathbf{v}_3=\\mathbf{c}$。\n- 两个基矢 $\\mathbf{L}$ 和 $\\mathbf{L}'$ 生成同一个晶格，当且仅当存在一个整数矩阵 $\\mathbf{S} \\in \\mathrm{GL}(3,\\mathbb{Z})$（整数上的一般线性群 (GL)，其行列式为 $\\det(\\mathbf{S}) = \\pm 1$），使得 $\\mathbf{L}' = \\mathbf{L}\\mathbf{S}$。在这种基变换下，分数坐标 $\\mathbf{f}$ 进行逆变变换，即 $\\mathbf{f}' = \\mathbf{S}^{-1}\\mathbf{f}$。\n- 晶胞的六维（G6）度规表示是一个六元组 $(A,B,C,D,E,F)$，定义为 $A = \\mathbf{a}\\cdot\\mathbf{a}$，$B = \\mathbf{b}\\cdot\\mathbf{b}$，$C = \\mathbf{c}\\cdot\\mathbf{c}$，$D = 2\\,\\mathbf{b}\\cdot\\mathbf{c}$，$E = 2\\,\\mathbf{a}\\cdot\\mathbf{c}$，$F = 2\\,\\mathbf{a}\\cdot\\mathbf{b}$。\n- 就本问题而言，一个标准的尼格利（Niggli）约化原胞可以被描述为任何一个可以通过整数幺模变换 $\\mathbf{S}\\in\\mathrm{GL}(3,\\mathbb{Z})$ 到达的基矢，且该基矢满足：(i) 边长平方非递减，即 $A \\leq B \\leq C$；(ii) 轴间角为非锐角，因此 $D \\leq 0$，$E \\leq 0$，$F \\leq 0$（角度 $\\geq 90$ 度）；以及 (iii) 在所有此类变换中，六元组 $(A,B,C,D,E,F)$ 在字典序上是最小的。您必须仅使用整数幺模变换来完成此任务。您可以假设，对于所提供的测试集，仅需在元素为 $\\{-1,0,1\\}$ 的整数幺模变换中搜索，并结合基矢的列置换和独立的符号反转，就足以找到这样一个标准表示。\n\n推导目标：\n- 从上述定义出发，推导一个算法，该算法搜索 $\\mathrm{GL}(3,\\mathbb{Z})$ 的一个有限子集，将诱导的基变换应用于候选晶格，并通过强制执行 $A \\leq B \\leq C$ 的排序、强制执行非锐角轴间角（等效于 $D \\leq 0$，$E \\leq 0$，$F \\leq 0$），并从满足这些条件的晶格中选择字典序最小的 $(A,B,C,D,E,F)$ 来选出标准约化晶胞。然后，通过 $\\mathbf{f}'=\\mathbf{S}^{-1}\\mathbf{f}$ 变换所有原子分数坐标，并通过应用模 $1$ 的小数部分映射，将其各分量约化到半开区间 $[0,1)$ 内。\n\n单位与数值约定：\n- 晶格矢量以埃（ångström）为单位给出。在所有涉及长度的内部计算中，请一致地使用埃。轴间角必须以度为单位进行解释，并在需要时进行计算。您的程序的最终报告输出仅为布尔值和整数，因此输出中无需单位注释。\n\n需为每个用例计算的验证标准：\n- 边长排序检查：返回一个布尔值，指示约化晶胞是否在数值容差范围内满足 $A \\leq B \\leq C$。\n- 非锐角检查：返回一个布尔值，指示所有三个轴间角是否均不小于 $90$ 度（等效于在容差范围内满足 $D \\leq 0$，$E \\leq 0$，$F \\leq 0$）。\n- 体积保持检查：返回一个布尔值，指示 $|\\det(\\mathbf{L})|$ 是否在容差范围内等于 $|\\det(\\mathbf{L}')|$。\n- 原子计数：返回变换后的原子位置的整数数量（当仅使用幺模变换时，它必须等于输入数量）。\n- 单位立方体包含检查：返回一个布尔值，指示所有变换后的分数坐标是否在容差范围内按分量位于 $[0,1)$ 内。\n\n程序要求：\n- 仅使用此处陈述的定义和事实来实现上述算法。\n- 对所有比较使用一个固定的较小数值容差（例如，$10^{-8}$）。\n- 对于每个用例，生成一个形式为 $[\\text{sorted\\_edge},\\ \\text{non\\_acute\\_angles},\\ \\text{volume\\_preserved},\\ \\text{atom\\_count},\\ \\text{coords\\_in\\_unit}]$ 的结果列表。\n- 下面的测试集应硬编码在您的程序中。您的程序应生成单行输出，其中包含所有用例的结果，形式为一个以逗号分隔的列表，并用方括号括起（例如，$\\texttt{[[...],[...],...]}$），每个用例的结果列表按顺序排列。\n\n测试集（每个晶格由其三个列矢量给出；原子位置为分数坐标）：\n- 用例 1（简单立方，已约化）：\n  - $\\mathbf{L}_1$ 的列为 $(3,0,0)$、$(0,3,0)$、$(0,0,3)$，单位均为埃。\n  - 分数坐标位置：$(0,0,0)$ 和 $(0.5,0.5,0.5)$。\n- 用例 2（正交晶胞，经过置换和符号翻转）：\n  - 从 $(3,0,0)$、$(0,4,0)$、$(0,0,5)$ 开始，将列重新排列为 $(0,4,0)$、$(0,0,-5)$、$(3,0,0)$ 以形成 $\\mathbf{L}_2$，单位为埃。\n  - 分数坐标位置：$(0.25,0.4,0.6)$ 和 $(0.9,0.1,0.3)$。\n- 用例 3（锐角 $\\gamma$ 角，必须变为非锐角）：\n  - $\\mathbf{L}_3$ 的列为 $(3,0,0)$、$(1.5,2.598076211,0)$、$(0,0,4)$，单位为埃。\n  - 分数坐标位置：$(0,0,0)$ 和 $(1.2,-0.1,0.5)$。\n- 用例 4（边长相等 $a=b$ 且夹角为直角；包含超出范围的分数分量以测试环绕处理）：\n  - $\\mathbf{L}_4$ 的列为 $(3,0,0)$、$(0,3,0)$、$(0,0,4)$，单位为埃。\n  - 分数坐标位置：$(-0.25,1.75,0.0)$、$(0.5,0.5,0.5)$ 和 $(1.000000001, -1\\times 10^{-9}, 0.999999999)$。\n\n最终输出格式：\n- 您的程序应只产生一行输出：一个大的外部列表，其中包含每个用例的一个内部列表，顺序与上述相同。每个内部列表的形式必须为 $[\\text{布尔值},\\ \\text{布尔值},\\ \\text{布尔值},\\ \\text{整数},\\ \\text{布尔值}]$，并且外部列表必须以标准的 Python 列表语法打印，元素之间用逗号分隔，无额外文本。", "solution": "用户提供的问题被评估为**有效**。其科学基础在于晶体学和线性代数的原理，问题设定良好，目标和约束清晰，且表述客观。该问题要求实现一个算法，为给定的晶格寻找一个尼格利（Niggli）约化原胞，并将原子坐标变换到这个新基矢下，同时遵循一组特定的简化约化规则。\n\n该算法方法基于布拉菲晶格中的基变换原理和字典序下的优化。\n\n布拉菲晶格由一组点 $\\mathbf{r} = n_1\\mathbf{a} + n_2\\mathbf{b} + n_3\\mathbf{c}$ 定义，其中 $n_i \\in \\mathbb{Z}$，$\\{\\mathbf{a}, \\mathbf{b}, \\mathbf{c}\\}$ 是三个线性无关的晶格矢量。这些矢量构成了基矢矩阵 $\\mathbf{L} = [\\mathbf{a}\\ \\mathbf{b}\\ \\mathbf{c}] \\in \\mathbb{R}^{3 \\times 3}$ 的列。晶格中的任意点可由 $\\mathbf{r} = \\mathbf{L}\\mathbf{f}$ 给出，其中 $\\mathbf{f} \\in \\mathbb{Z}^3$。晶胞的几何结构完全由度规张量 $\\mathbf{G} = \\mathbf{L}^{\\mathsf{T}}\\mathbf{L}$ 描述，其元素是基矢的点积，$G_{ij} = \\mathbf{v}_i \\cdot \\mathbf{v}_j$。\n\n有无数个基矢矩阵 $\\mathbf{L}$ 可以生成同一个晶格。两个基矢 $\\mathbf{L}$ 和 $\\mathbf{L}'$ 描述同一个晶格，如果它们通过一个幺模整数变换矩阵 $\\mathbf{S} \\in \\mathrm{GL}(3,\\mathbb{Z})$ 相关联，使得 $\\mathbf{L}' = \\mathbf{L}\\mathbf{S}$。矩阵 $\\mathbf{S}$ 必须具有整数元素且行列式为 $\\det(\\mathbf{S}) = \\pm 1$。单位晶胞的体积由 $|\\det(\\mathbf{L})|$ 给出，在该变换下是不变的，因为 $|\\det(\\mathbf{L}')| = |\\det(\\mathbf{L}\\mathbf{S})| = |\\det(\\mathbf{L})||\\det(\\mathbf{S})| = |\\det(\\mathbf{L})|$。当基矢通过 $\\mathbf{S}$ 变换时，任何分数坐标矢量 $\\mathbf{f}$ 必须进行逆变变换，即 $\\mathbf{f}' = \\mathbf{S}^{-1}\\mathbf{f}$，以确保实空间位置 $\\mathbf{r} = \\mathbf{L}\\mathbf{f} = \\mathbf{L}'\\mathbf{f}'$ 保持不变。\n\n该问题要求根据一组简化的规则找到一个“标准”的尼格利（Niggli）约化晶胞。这是通过搜索一个最优的变换矩阵 $\\mathbf{S}$ 来实现的，该矩阵将给定的初始基矢 $\\mathbf{L}$ 映射到一个满足特定标准的约化基矢 $\\mathbf{L}'$。问题提供了一个关键的简化：对 $\\mathbf{S}$ 的搜索可以限制在一个有限集合内，即元素在 $\\{-1, 0, 1\\}$ 中且行列式为 $\\pm 1$ 的 $3 \\times 3$ 矩阵。\n\n算法流程如下：\n首先，生成一个包含所有候选变换矩阵的静态集合 $\\mathcal{S}$。这是通过遍历所有 $3^9 = 19,683$ 个可能的元素在 $\\{-1, 0, 1\\}$ 中的 $3 \\times 3$ 矩阵，并只保留那些行列式在小的数值容差范围内接近 $\\pm 1$ 的矩阵来完成的。这个集合 $\\mathcal{S}$ 被预先计算并用于所有测试用例。\n\n对于每个由初始晶格 $\\mathbf{L}_{\\text{initial}}$ 和一组初始分数坐标 $\\{\\mathbf{f}_{\\text{initial}}\\}$ 指定的测试用例：\n1.  初始化一个变量 `best_g6`，用于保存迄今为止找到的字典序最小的合格 G6 矢量，以及相应的 `best_L` 和 `best_S`。\n2.  遍历集合 $\\mathcal{S}$ 中的每个变换矩阵 $\\mathbf{S}$。\n3.  对于每个 $\\mathbf{S}$，计算候选的变换后基矢 $\\mathbf{L}_{\\text{cand}} = \\mathbf{L}_{\\text{initial}}\\mathbf{S}$。\n4.  根据 $\\mathbf{L}_{\\text{cand}}$，计算度规张量 $\\mathbf{G}_{\\text{cand}} = \\mathbf{L}_{\\text{cand}}^{\\mathsf{T}}\\mathbf{L}_{\\text{cand}}$ 和相应的 G6 矢量 $(A,B,C,D,E,F)$，其中 $A=\\mathbf{a}'\\cdot\\mathbf{a}'$，$B=\\mathbf{b}'\\cdot\\mathbf{b}'$，$C=\\mathbf{c}'\\cdot\\mathbf{c}'$，$D=2\\,\\mathbf{b}'\\cdot\\mathbf{c}'$，$E=2\\,\\mathbf{a}'\\cdot\\mathbf{c}'$，以及 $F=2\\,\\mathbf{a}'\\cdot\\mathbf{b}'$。\n5.  将问题陈述中的约化标准应用于候选 G6 矢量：\n    a.  排序的边长平方：$A \\le B \\le C$。\n    b.  非锐角的轴间角：$D \\le 0, E \\le 0, F \\le 0$。\n    数值比较使用容差 $\\epsilon = 10^{-8}$ 进行。\n6.  如果一个候选者满足这些条件，它的 G6 矢量将与 `best_g6` 进行字典序比较。如果 `best_g6` 尚未设置或候选 G6 严格更小，则用当前候选者的属性更新 `best_g6`、`best_L` 和 `best_S`。\n7.  在搜索完所有 $\\mathbf{S} \\in \\mathcal{S}$ 后，最终的 `best_L` 和 `best_S` 分别代表了尼格利（Niggli）约化晶胞以及产生它的变换。\n\n一旦找到最优变换 $\\mathbf{S}_{\\text{final}}$，就执行验证检查：\n1.  **边长排序检查**：验证最终晶胞的 G6 参数是否在容差范围内满足 $A \\le B \\le C$。\n2.  **非锐角检查**：验证是否在容差范围内满足 $D \\le 0, E \\le 0, F \\le 0$。\n3.  **体积保持检查**：确认 $|\\det(\\mathbf{L}_{\\text{initial}})|$ 在容差范围内等于 $|\\det(\\mathbf{L}_{\\text{final}})|$。\n4.  **原子计数**：原子数就是初始分数坐标矢量的数量。\n5.  **单位立方体包含检查**：初始分数坐标通过 $\\mathbf{f}_{\\text{final}} = \\mathbf{S}_{\\text{final}}^{-1}\\mathbf{f}_{\\text{initial}}$ 进行变换。然后使用模运算符 $f'' = f' \\pmod 1$ 将 $\\mathbf{f}_{\\text{final}}$ 的每个分量映射到区间 $[0, 1)$。一个布尔检查确认所有最终坐标矢量的所有分量是否在适当的数值容差范围内位于 $[0, 1)$ 内，具体检查每个环绕后的坐标 $c$ 是否满足 $c \\ge -\\epsilon$ 和 $c  1.0$。\n\n这个系统化的过程保证了能够找到问题所定义的标准晶胞，并正确地变换所有相关属性以进行验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import product\n\n# Define a global tolerance for floating point comparisons.\nTOL = 1e-8\n\ndef get_s_matrices():\n    \"\"\"\n    Generates and returns the set of all 3x3 matrices with entries in {-1, 0, 1}\n    and determinant of +/-1. This set is pre-calculated once.\n    \"\"\"\n    s_matrices = []\n    for p in product([-1, 0, 1], repeat=9):\n        s = np.array(p, dtype=np.int32).reshape(3, 3)\n        det_s = np.linalg.det(s)\n        if np.isclose(det_s, 1.0) or np.isclose(det_s, -1.0):\n            s_matrices.append(s)\n    return s_matrices\n\n# Pre-compute the set of valid transformation matrices.\nS_MATRICES = get_s_matrices()\n\ndef get_g6_from_L(L):\n    \"\"\"\n    Calculates the 6-dimensional metric representation (G6) from a basis matrix L.\n    G6 = (a*a, b*b, c*c, 2*b*c, 2*a*c, 2*a*b)\n    \"\"\"\n    G = L.T @ L\n    A = G[0, 0]\n    B = G[1, 1]\n    C = G[2, 2]\n    D = 2 * G[1, 2]\n    E = 2 * G[0, 2]\n    F = 2 * G[0, 1]\n    return (A, B, C, D, E, F)\n\ndef solve_case(L_initial, f_initial):\n    \"\"\"\n    Finds the Niggli-reduced cell for a given lattice and performs validation checks.\n    \"\"\"\n    best_g6 = None\n    best_L = None\n    best_S = None\n\n    for s_matrix in S_MATRICES:\n        L_candidate = L_initial @ s_matrix\n        g6_candidate = get_g6_from_L(L_candidate)\n        A, B, C, D, E, F = g6_candidate\n\n        # Condition (i): Sorted edge-length squares (A = B = C)\n        if not (A = B + TOL and B = C + TOL):\n            continue\n        \n        # Condition (ii): Non-acute interaxial angles (D, E, F = 0)\n        if not (D = TOL and E = TOL and F = TOL):\n            continue\n\n        # Condition (iii): Lexicographically minimal G6 vector\n        if best_g6 is None or g6_candidate  best_g6:\n            best_g6 = g6_candidate\n            best_L = L_candidate\n            best_S = s_matrix\n    \n    # After checking all S, we have the best reduced cell\n    L_final = best_L\n    S_final = best_S\n    g6_final = best_g6\n\n    # --- Perform Validation Checks ---\n    \n    # 1. Sorted-edge check\n    A_f, B_f, C_f, _, _, _ = g6_final\n    sorted_edge = (A_f = B_f + TOL) and (B_f = C_f + TOL)\n\n    # 2. Non-acute-angles check\n    _, _, _, D_f, E_f, F_f = g6_final\n    non_acute_angles = (D_f = TOL) and (E_f = TOL) and (F_f = TOL)\n\n    # 3. Volume preservation check\n    vol_initial = np.abs(np.linalg.det(L_initial))\n    vol_final = np.abs(np.linalg.det(L_final))\n    volume_preserved = np.isclose(vol_initial, vol_final, atol=TOL, rtol=TOL)\n\n    # 4. Atom count\n    f_initial_arr = np.array(f_initial)\n    if f_initial_arr.ndim == 1:\n        atom_count = 1 if f_initial_arr.size > 0 else 0\n    else:\n        atom_count = f_initial_arr.shape[0]\n\n    # 5. Unit-cube containment check\n    coords_in_unit = True # Default to True for case with no atoms\n    if atom_count > 0:\n        S_inv = np.linalg.inv(S_final)\n        # Transform coords: S_inv is 3x3, f_initial_arr.T is 3xN_atoms\n        f_transformed = (S_inv @ f_initial_arr.T).T\n        # Reduce components to [0, 1) interval\n        f_wrapped = np.mod(f_transformed, 1.0)\n        # Check if all components are in [0, 1) within tolerance\n        # Check >= -TOL for lower bound robustness, and  1.0 for upper bound\n        coords_in_unit = bool(np.all((f_wrapped >= -TOL)  (f_wrapped  1.0)))\n\n    return [sorted_edge, non_acute_angles, volume_preserved, atom_count, coords_in_unit]\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": np.array([[3, 0, 0], [0, 3, 0], [0, 0, 3]], dtype=float).T,\n            \"f\": [[0, 0, 0], [0.5, 0.5, 0.5]]\n        },\n        {\n            \"L\": np.array([[0, 4, 0], [0, 0, -5], [3, 0, 0]], dtype=float).T,\n            \"f\": [[0.25, 0.4, 0.6], [0.9, 0.1, 0.3]]\n        },\n        {\n            \"L\": np.array([[3, 0, 0], [1.5, 2.598076211, 0], [0, 0, 4]], dtype=float).T,\n            \"f\": [[0, 0, 0], [1.2, -0.1, 0.5]]\n        },\n        {\n            \"L\": np.array([[3, 0, 0], [0, 3, 0], [0, 0, 4]], dtype=float).T,\n            \"f\": [[-0.25, 1.75, 0.0], [0.5, 0.5, 0.5], [1.000000001, -1e-9, 0.999999999]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L_initial = case[\"L\"]\n        f_initial = case[\"f\"]\n        result_list = solve_case(L_initial, f_initial)\n        results.append(result_list)\n\n    # Final print statement in the exact required format.\n    print(results)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3463942"}, {"introduction": "基于对规范化表示的需求，这个思想实验将挑战您深入思考“两个晶体结构完全相同”意味着什么。仅仅比较晶格参数（如$a, b, c, \\alpha, \\beta, \\gamma$）可能会产生误导，导致“假阴性”（将相同结构误判为不同）或“假阳性”（将不同结构误判为相同）的错误。通过本练习，您将分析并理解简单比较方法的缺陷，并体会一个鲁棒的结构匹配度量衡所需满足的关键性质：它必须对表示选择具有不变性，并对微小的数值扰动保持稳定性，这是构建可靠材料数据库和实现结构去重的基石。[@problem_id:3463967]", "problem": "材料数据库中的一个晶体条目由其晶格基底矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$ (列向量为晶格矢量，单位为埃) 和带物种标签的分数原子位置 $\\{ \\boldsymbol{s}_j \\}_{j=1}^N$ 来表示。如果两个条目在平移、原子置换、原点移动、空间旋转以及晶格基底的幺模整数变换 $U \\in \\mathrm{GL}(3,\\mathbb{Z})$ (即 $A$ 替换为 $A U$)下等价，则它们代表相同的结构。在实践中，许多去重流程通过对长度和角度使用固定容差来比较晶胞参数 $(a,b,c,\\alpha,\\beta,\\gamma)$ 和已排序的原子间距列表。\n\n考虑以下思想实验，以分析容差选择对假阳性和假阴性的影响。\n\n1. 设 $A_{\\mathrm{cub}} = \\mathrm{diag}(a,a,a)$，其中 $a = 4.000$ (埃)，分数坐标 $\\{ \\boldsymbol{s}_j \\}$ 定义了一个基底，其中单个原子位于 $\\boldsymbol{s}_1 = (0,0,0)$。定义 $U = \\begin{pmatrix} 1  1  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$。变换后的晶格 $A' = A_{\\mathrm{cub}} U$ 是对同一周期性结构的有效描述。其晶胞参数为 $(a',b',c',\\alpha',\\beta',\\gamma')$，其中 $a' = \\| \\boldsymbol{a} + \\boldsymbol{b} \\|$, $b' = \\| \\boldsymbol{b} \\|$, $c' = \\| \\boldsymbol{c} \\|$，而 $\\alpha'$, $\\beta'$, $\\gamma'$ 是新基矢之间的夹角。假设一个去重规则：如果 $|a-a'|$, $|b-b'|$, $|c-c'|$ 均低于长度容差 $\\tau_{\\ell}$，且 $|\\alpha-\\alpha'|$, $|\\beta-\\beta'|$, $|\\gamma-\\gamma'|$ 均低于角度容差 $\\tau_{\\theta}$，则宣布两个条目为重复。\n2. 现在考虑两个条目，它们的晶胞分别为 $A_1 = \\mathrm{diag}(a_1,a_1,a_1)$ 和 $A_2 = \\mathrm{diag}(a_2,a_2,a_2)$，具有相同的分数坐标 $\\{ \\boldsymbol{s}_j \\}$，其中 $a_1 = 3.999$ 而 $a_2 = 4.001$。两者名义上是同一结构，但受到了微小数值噪声和测量差异的扰动。\n3. 最后，考虑两个晶胞为 $A_3 = \\mathrm{diag}(4.000, 4.000, 4.000)$ 和 $A_4 = \\mathrm{diag}(4.000, 4.000, 4.000)$ 的条目，但它们的原子集合不同：条目3的原子位于分数坐标 $\\{ (0,0,0), (1/2,1/2,1/2) \\}$ (两个原子)，而条目4的原子位于 $\\{ (0,0,0), (1/2,0,0) \\}$ (两个原子)。这两组基底定义了真正不同的结构，尽管它们使用了相同的立方晶胞。\n\n仅使用基本定义（晶格基底变换下的等价性、通过内积定义矢量间夹角、以及位置函数的连续性），分析：\n\n- 为什么 $\\tau_{\\ell}$ 和 $\\tau_{\\theta}$ 的选择会在情况1中导致假阴性，在情况3中导致假阳性。\n- 为什么仅比较 $(a,b,c,\\alpha,\\beta,\\gamma)$ 或仅比较已排序的原子间距可能稳定性或区分度不足。\n- 提出一个条目间的比较度量，该度量在微小数值扰动（如 $A_1$ 和 $A_2$ 之间的差异）下是稳定的，并且对于真正不同的结构（如情况3中的结构）具有区分度，同时尊重上述等价性。你的提议应引用不变性原理和连续性，而不是启发式阈值。\n\n以下哪个选项在保持对晶胞选择和对称性的不变性的同时，最好地满足了稳定性和区分度的要求？\n\nA. 当存储的常规晶胞计算出的 $(a,b,c,\\alpha,\\beta,\\gamma)$ 在固定的绝对容差 $(\\tau_{\\ell},\\tau_{\\theta})$ 内匹配时，宣布为重复。\n\nB. 当晶胞内所有成对原子间距的排序列表在固定容差内匹配时，宣布为重复，忽略晶格约化和物种加权。\n\nC. 当Niggli约化后的晶胞在容差范围内，并且在固定散射矢量范围内的经过高斯平滑的粉末X射线衍射(PXRD)强度谱 $I(|\\boldsymbol{q}|)$ 之间的归一化 $L^2$ 距离低于一个阈值时，宣布为重复。\n\nD. 在进行规范晶格归一化（例如Niggli约化）后，通过计算由晶格诱导的三维环面上具有特征高斯核的局部原子环境经验度量之间的物种加权最大均值差异(MMD)，并要求MMD低于一个阈值时，宣布为重复。\n\nE. 当舍入到固定小数位的分数坐标和角度的哈希值发生碰撞时，宣布为重复。\n\n选择唯一的最佳选项。", "solution": "问题陈述具有科学依据，提问得当且客观。它使用标准的晶体学和数学定义，准确地描述了计算材料科学中定义和验证结构等价性的基本问题。所提供的案例是说明朴素比较方法缺陷的绝佳原型。该问题是有效的。\n\n一个稳健的比较晶体结构的度量必须满足问题阐明的三个主要标准：\n1.  **不变性 (Invariance)**：对于两个物理上等价的结构，该度量必须产生相同的结果。这包括对晶格基底选择（$A$ 与 $A U$，其中 $U \\in \\mathrm{GL}(3, \\mathbb{Z})$）、原点选择、同种原子置换以及刚性空间旋转/平移的不变性。\n2.  **区分度 (Discriminativity)**：该度量必须能够区分真正不同的结构，即使它们表面上相似（例如，具有相同的晶胞但原子排列不同）。\n3.  **稳定性 (Stability)**：该度量应该是结构参数（晶格矢量和原子坐标）的连续函数。输入结构的微小扰动（由于数值噪声或热涨落）应该只导致测量到的差异度的微小变化。\n\n我们分析思想实验中提出的案例，以理解为什么简单的度量会失败。\n\n**案例1分析：不变性失效和假阴性**\n问题考虑一个简单立方晶格 $A_{\\mathrm{cub}} = \\mathrm{diag}(4, 4, 4)$，其基矢为 $\\boldsymbol{a} = (4, 0, 0)^T$, $\\boldsymbol{b} = (0, 4, 0)^T$ 和 $\\boldsymbol{c} = (0, 0, 4)^T$。晶胞参数为 $(a, b, c, \\alpha, \\beta, \\gamma) = (4.000, 4.000, 4.000, 90^\\circ, 90^\\circ, 90^\\circ)$。\n应用幺模变换 $U = \\begin{pmatrix} 1  1  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$。新的基底矩阵是 $A' = A_{\\mathrm{cub}} U$，对应于新的基矢：\n$\\boldsymbol{a}' = \\boldsymbol{a} = (4, 0, 0)^T$\n$\\boldsymbol{b}' = \\boldsymbol{a} + \\boldsymbol{b} = (4, 4, 0)^T$\n$\\boldsymbol{c}' = \\boldsymbol{c} = (0, 0, 4)^T$\n根据定义，$A'$ 描述的是完全相同的晶格。然而，从此新基底计算出的晶胞参数为：\n- $a' = \\|\\boldsymbol{a}'\\| = 4.000$\n- $b' = \\|\\boldsymbol{b}'\\| = \\sqrt{4^2 + 4^2} = \\sqrt{32} \\approx 5.657$\n- $c' = \\|\\boldsymbol{c}'\\| = 4.000$\n- $\\alpha' = \\arccos\\left(\\frac{\\boldsymbol{b}' \\cdot \\boldsymbol{c}'}{b'c'}\\right) = \\arccos(0) = 90^\\circ$\n- $\\beta' = \\arccos\\left(\\frac{\\boldsymbol{a}' \\cdot \\boldsymbol{c}'}{a'c'}\\right) = \\arccos(0) = 90^\\circ$\n- $\\gamma' = \\arccos\\left(\\frac{\\boldsymbol{a}' \\cdot \\boldsymbol{b}'}{a'b'}\\right) = \\arccos\\left(\\frac{16}{4 \\cdot \\sqrt{32}}\\right) = \\arccos\\left(\\frac{1}{\\sqrt{2}}\\right) = 45^\\circ$\n基于晶胞参数的比较会发现巨大差异：$|b - b'| \\approx 1.657$ Å 和 $|\\gamma - \\gamma'| = 45^\\circ$。如果容差 $\\tau_{\\ell}$ 和 $\\tau_{\\theta}$ 小于这些值，比较算法会错误地判定结构不同，从而导致**假阴性**。这表明比较任意选择的基底的晶胞参数不是一个不变的过程。\n\n**案例3分析：区分度失效和假阳性**\n在这里，两个条目具有相同的晶胞 $A_3 = A_4 = \\mathrm{diag}(4, 4, 4)$，但原子基底不同。\n- 结构3：原子位于分数坐标 $\\{ (0,0,0), (1/2,1/2,1/2) \\}$。这是常规晶胞中的体心立方(BCC)排列。\n- 结构4：原子位于 $\\{ (0,0,0), (1/2,0,0) \\}$。这是一个具有双原子基底的简单立方晶格。\n这些是配位数和物理性质都不同的真正独特的晶体结构。一个只考虑晶格参数 $(a,b,c,\\alpha,\\beta,\\gamma)$ 的比较方法会认为它们是相同的，从而导致**假阳性**。这表明一个有区分度的度量必须考虑分数原子位置和物种。\n\n**原子间距与稳定性的分析**\n比较已排序的原子间距列表比比较晶胞参数更具区分度，因为它能区分案例3中的结构。然而，“晶胞内的原子间距”这一说法定义不清。距离的集合取决于晶胞的选择（例如，原胞与常规晶胞），因此除非使用更严格的定义（例如，从每个原子到固定半径内所有邻近原子的距离，而不论晶胞边界），否则该方法对基底的选择不是不变的。\n稳定性，如案例2 ($a_1 = 3.999$ vs. $a_2=4.001$)所强调，要求对结构的微小扰动只导致其表示或指纹的微小变化。任何依赖于舍入或哈希（不连续函数）的度量都将是不稳定的。\n\n因此，一个稳健的方法必须首先将晶格表示规范化（例如，通过Niggli约化）以确保不变性，然后以一种在微小扰动下稳定的方式，比较一个编码了原子完整周期性排列（包括晶格和基底）的指纹。\n\n现在，我们评估每个选项：\n\n**A. 当存储的常规晶胞计算出的 $(a,b,c,\\alpha,\\beta,\\gamma)$ 在固定的绝对容差 $(\\tau_{\\ell},\\tau_{\\theta})$ 内匹配时，宣布为重复。**\n该方法未能满足不变性要求，如案例1所示。它也未能满足区分度要求，如案例3所示。它是问题旨在批判的典型朴素方法。**不正确。**\n\n**B. 当晶胞内所有成对原子间距的排序列表在固定容差内匹配时，宣布为重复，忽略晶格约化和物种加权。**\n该方法未能满足不变性要求，因为“晶胞内”的原子集合取决于非唯一的晶胞选择。“忽略晶格约化”正是问题所在。此外，“忽略物种加权”是一个关键缺陷，因为它会将像$\\mathrm{NaCl}$这样的结构与$\\mathrm{ZnS}$的闪锌矿多晶型物等同起来。**不正确。**\n\n**C. 当Niggli约化后的晶胞在容差范围内，并且在固定散射矢量范围内的经过高斯平滑的粉末X射线衍射(PXRD)强度谱 $I(|\\boldsymbol{q}|)$ 之间的归一化 $L^2$ 距离低于一个阈值时，宣布为重复。**\n该方法解决了核心要求。Niggli约化提供了一个规范晶胞，确保了晶格不变性。PXRD图谱是整个结构（晶格和基底）的指纹，对原点选择和旋转（通过平均）是不变的，并且具有区分度。高斯平滑和谱线上的 $L^2$ 距离确保了稳定性。这是一种有效且广泛使用的方法。**原理正确。**\n\n**D. 在进行规范晶格归一化（例如Niggli约化）后，通过计算由晶格诱导的三维环面上具有特征高斯核的局部原子环境经验度量之间的物种加权最大均值差异(MMD)，并要求MMD低于一个阈值时，宣布为重复。**\n这个选项代表了一种更复杂且在根本上更强大的方法。\n- **不变性**：它明确包括“规范晶格归一化”（如Niggli约化）。局部原子环境本身由旋转不变的描述符来描述。比较这些环境的*分布*（通过经验度量上的MMD）使得比较对同种原子的置换是不变的。\n- **区分度**：该方法具有高度区分度。它比较局部化学环境的完整分布，捕捉了成键和配位的精细细节。“物种加权”方面正确处理了多组分系统。\n- **稳定性**：使用高斯核来描述环境并使用MMD进行比较，确保了整个度量对于微小的原子位移是连续和稳定的。“三维环面”是处理周期性的数学上严格的方式。\n这种方法，它是像SOAP（原子位置光滑重叠）等方法的形式化描述，被认为是业界顶尖水平。它通常比PXRD更具区分度，因为PXRD将三维结构信息投影到一维图谱上，可能导致偶然的简并。该方法在局部原子几何的基本层面上比较结构。**原理正确，且可以说优于C。**\n\n**E. 当舍入到固定小数位的分数坐标和角度的哈希值发生碰撞时，宣布为重复。**\n这种方法存在根本性缺陷。舍入是一种不连续的操作，这使得哈希值对微小扰动（案例2）不稳定。跨越舍入边界的微小变化会导致完全不同的哈希值。此外，分数坐标是依赖于基底的，因此该方法对晶胞选择不是不变的（案例1）。**不正确。**\n\n**结论**\nC和D都描述了有效且稳健的方法。然而，问题要求选择*最佳*选项。选项D更优越，因为它基于对结构更基本、更详细的表示——其局部原子环境的分布。这提供了比C中全局平均的PXRD图谱更高的区分能力。D中的语言也更具数学严谨性和完整性，引用了所有必要的原理（规范化、不变性、通过核函数实现稳定性、在环面上正确处理周期性）来定义一个理想的度量。因此，D是所提出的最佳且最全面的解决方案。", "answer": "$$\\boxed{D}$$", "id": "3463967"}, {"introduction": "当数据被正确地表示和清理后，下一步通常是构建机器学习预测模型。然而，材料数据集具有独特的结构，例如同一化学成分可能存在多种晶型（polymorphs），这给模型评估带来了挑战。本实践将引导您实现分组交叉验证（grouped cross-validation），这是一种防止“信息泄露”的关键技术，确保模型性能的评估结果能够真实反映其对全新、未见过的化学成分的预测能力。[@problem_id:3463892]", "problem": "给定一个合成材料数据集，该数据集旨在模拟一个材料数据库，其中每种化学成分包含多种多晶型物（polymorph）。多晶型物是具有相同化学成分但晶体结构不同的物质。任务目标是实现分组交叉验证，以确保相同成分的所有多晶型物都保留在同一数据折（fold）中，然后训练一个用于预测生成能的回归模型，并报告带有 $95\\%$ 置信区间的平均绝对误差 (MAE)。此任务的设计是为了防止信息泄露，确保共享成分级描述符的多晶型物不会被分割到不同的训练集和测试集中。\n\n数据集构建与物理真实性：\n- 数据集中有 $12$ 种不同的化学成分（组），由整数 $0,1,\\dots,11$ 索引。\n- 每种成分恰好有 $6$ 种多晶型物，因此总共有 $72$ 个样本。\n- 每种成分 $g$ 都有一个成分级描述符 $\\mathbf{c}_g \\in \\mathbb{R}^3$，该描述符在其所有多晶型物中保持不变，并通过使用固定的随机种子从 $[0,1]^3$ 的均匀分布中生成，以保证可复现性。\n- 成分 $g$ 中的每种多晶型物都有一个结构级描述符 $\\mathbf{s}_{g,j} \\in \\mathbb{R}^2$，该描述符同样使用固定的随机种子从 $[0,1]^2$ 的均匀分布中独立生成，以保证可复现性。\n- 每个原子的真实生成能由一个带有截距和加性噪声的线性模型生成：\n$$\nE_f(g,j) = b + \\mathbf{c}_g \\cdot \\mathbf{w}_c + \\mathbf{s}_{g,j} \\cdot \\mathbf{w}_s + \\varepsilon_{g,j},\n$$\n其中 $b=-2.0$ (单位 $\\mathrm{eV/atom}$)，$\\mathbf{w}_c = [0.8,-0.6,0.4]$ (单位 $\\mathrm{eV}$/描述符单位)，$\\mathbf{w}_s = [0.5,-0.3]$ (单位 $\\mathrm{eV}$/描述符单位)，$\\varepsilon_{g,j} \\sim \\mathcal{N}(0,\\sigma^2)$ 是加性高斯噪声，其标准差 $\\sigma$ 在每个测试用例中指定。所有能量单位均为电子伏特/原子 ($\\mathrm{eV/atom}$)。\n\n建模与评估要求：\n- 实现分组 $K$-折交叉验证 (CV)，其中分组依据是成分索引。属于相同成分的所有多晶型物必须被分配到同一个数据折中。\n- 对每一折，训练一个生成能的线性回归模型。该模型通过最小化残差平方和来求解，并对权重施加一个强度为 $\\lambda$ 的 $\\ell_2$ (欧几里得) 惩罚，但不惩罚截距。训练好的模型必须在留出折上预测生成能。使用标准线性代数方法求解；截距必须被正确处理并从正则化中排除。\n- 计算每折的平均绝对误差 (MAE)，即测试折中所有样本的 $|E_f^{\\mathrm{pred}} - E_f^{\\mathrm{true}}|$ 的平均值。通过对各折的 MAE 求平均，将其聚合成一个总 MAE。\n- 将每折的 MAE 视为 $K$ 个样本，并使用具有 $K-1$ 自由度的学生 $t$-分布，为总 MAE 计算一个 $95\\%$ 置信区间。具体来说，如果 $m_k$ 是第 $k=1,\\dots,K$ 折的 MAE，样本均值为 $\\bar{m}$，样本标准差为 $s$，则报告区间 $\\left[\\bar{m} - t^\\star \\frac{s}{\\sqrt{K}}, \\bar{m} + t^\\star \\frac{s}{\\sqrt{K}}\\right]$，其中 $t^\\star$ 是具有 $K-1$ 自由度的学生 $t$-分布的 $0.975$ 分位数。\n- 所有误差度量的单位必须为 $\\mathrm{eV/atom}$。本问题不使用角度；如果您的实现中出现任何三角函数，其角度单位必须是弧度。\n\n实现细节与可复现性：\n- 使用固定的种子 $0$ 生成所有成分和结构描述符，以确保所有测试用例的特征相同。\n- 在每个测试用例中为加性高斯噪声使用不同的噪声种子，以在改变噪声水平的同时保证目标值的可复现性。\n- 使用固定的种子 $99$ 来打乱分组并将其划分为 $K$ 折。\n\n测试套件：\n实现您的程序以运行以下三个测试用例，每个用例由元组 $(K,\\lambda,\\sigma,\\text{noise\\_seed})$ 指定：\n1. $K=3$, $\\lambda=0.1$, $\\sigma=0.05$, $\\text{noise\\_seed}=11$.\n2. $K=2$, $\\lambda=0.0$, $\\sigma=0.10$, $\\text{noise\\_seed}=22$.\n3. $K=4$, $\\lambda=1.0$, $\\sigma=0.20$, $\\text{noise\\_seed}=33$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中按顺序包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。每个测试用例的结果是一个三元列表 $[\\bar{m}, \\mathrm{lower}, \\mathrm{upper}]$，其中包含单位为 $\\mathrm{eV/atom}$ 的浮点数。例如，输出必须类似于\n$$\n[[\\bar{m}_1,\\mathrm{lower}_1,\\mathrm{upper}_1],[\\bar{m}_2,\\mathrm{lower}_2,\\mathrm{upper}_2],[\\bar{m}_3,\\mathrm{lower}_3,\\mathrm{upper}_3]]\n$$\n打印在单行上，无任何附加文本。", "solution": "核心科学原理是通过确保共享相同成分级描述符的多晶型物不被分割到训练集和测试集中，从而避免信息泄露。因为如果分割，模型将能通过其他多晶型物间接访问到留出成分的描述符。分组 $K$-折交叉验证 (CV) 通过根据组标签（此处为化学成分）划分数据来直接强制执行这一点。\n\n我们从经验风险最小化开始。令 $\\mathbf{x}_{i} \\in \\mathbb{R}^{d}$ 表示样本 $i$ 的描述符向量，它由成分描述符 $\\mathbf{c}_g \\in \\mathbb{R}^{3}$ 和结构描述符 $\\mathbf{s}_{g,j} \\in \\mathbb{R}^{2}$ 拼接而成，因此 $d=5$。令 $y_{i} \\in \\mathbb{R}$ 为以 $\\mathrm{eV/atom}$ 为单位的生成能。带有截距 $b$ 和权重 $\\mathbf{w} \\in \\mathbb{R}^{d}$ 的岭回归目标函数为\n$$\nJ(b,\\mathbf{w}) = \\sum_{i=1}^{n} \\left(y_i - b - \\mathbf{x}_i^\\top \\mathbf{w}\\right)^2 + \\lambda \\lVert \\mathbf{w} \\rVert_2^2,\n$$\n其中 $\\lambda \\ge 0$ 是正则化强度，截距 $b$ 不受惩罚。这是一个凸二次问题，其最小化器满足正规方程。定义增广设计矩阵\n$$\n\\mathbf{X}_{\\mathrm{aug}} = \\begin{bmatrix}\n\\mathbf{1}  \\mathbf{X}\n\\end{bmatrix},\n$$\n其中 $\\mathbf{X} \\in \\mathbb{R}^{n \\times d}$ 堆叠了 $\\mathbf{x}_i^\\top$，$\\mathbf{1} \\in \\mathbb{R}^{n}$ 是一个全为1的列向量；以及增广参数向量\n$$\n\\boldsymbol{\\beta} = \\begin{bmatrix}\nb \\\\ \\mathbf{w}\n\\end{bmatrix} \\in \\mathbb{R}^{d+1},\n$$\n一阶最优性条件得出\n$$\n\\left(\\mathbf{X}_{\\mathrm{aug}}^\\top \\mathbf{X}_{\\mathrm{aug}} + \\mathbf{L}\\right)\\boldsymbol{\\beta} = \\mathbf{X}_{\\mathrm{aug}}^\\top \\mathbf{y},\n$$\n其中 $\\mathbf{L} \\in \\mathbb{R}^{(d+1)\\times(d+1)}$ 是一个对角矩阵，其截距对应项为 $0$，其余 $d$ 个对角线项为 $\\lambda$。当 $\\lambda0$ 时，求解此线性系统可得到唯一的最小化器；当 $\\lambda=0$ 且 $\\mathbf{X}_{\\mathrm{aug}}^\\top \\mathbf{X}_{\\mathrm{aug}}$ 可逆时，得到普通最小二乘法 (OLS) 解。对测试集的预测通过 $\\hat{\\mathbf{y}} = \\mathbf{X}_{\\mathrm{aug,test}} \\boldsymbol{\\beta}$ 获得。\n\n对于分组 $K$-折 CV，假设数据集由 $i=1,\\dots,n$ 索引，令 $g(i)$ 为样本 $i$ 的组标签（成分索引）。我们使用一个固定的种子随机排列 $G$ 个唯一的组，并将它们划分为 $K$ 个大小基本相等的不相交折 $\\mathcal{G}_1,\\dots,\\mathcal{G}_K$。对每一折 $k$，训练集是组标签不在 $\\mathcal{G}_k$ 中的所有样本，测试集是组标签在 $\\mathcal{G}_k$ 中的所有样本。这确保了对于任何成分 $g$，其所有多晶型物在给定的一折中要么全部在训练集中，要么全部在测试集中。\n\n第 $k$ 折上的平均绝对误差 (MAE) 定义为\n$$\nm_k = \\frac{1}{|\\mathcal{I}_k|} \\sum_{i \\in \\mathcal{I}_k} \\left| \\hat{y}_i - y_i \\right|,\n$$\n其中 $\\mathcal{I}_k$ 是测试折 $k$ 中样本的索引集。总 MAE 是各折的平均值，\n$$\n\\bar{m} = \\frac{1}{K} \\sum_{k=1}^{K} m_k.\n$$\n为获得 $\\bar{m}$ 的 $95\\%$ 置信区间，我们将 $\\{m_k\\}_{k=1}^K$ 视为 $K$ 个样本，并依赖于学生 $t$-分布。计算样本标准差\n$$\ns = \\sqrt{\\frac{1}{K-1}\\sum_{k=1}^{K} \\left(m_k - \\bar{m}\\right)^2},\n$$\n并令 $t^\\star$ 为具有 $K-1$ 自由度的学生 $t$-分布的 $0.975$ 分位数。则 $95\\%$ 置信区间为\n$$\n\\left[\\bar{m} - t^\\star \\frac{s}{\\sqrt{K}}, \\bar{m} + t^\\star \\frac{s}{\\sqrt{K}}\\right].\n$$\n所有误差值的单位均为 $\\mathrm{eV/atom}$。\n\n与上述原则一致的算法步骤：\n1. 使用种子 $0$ 从 $[0,1]^3$ 上的均匀分布中为 $g=0,\\dots,11$ 生成成分描述符 $\\mathbf{c}_g$。使用相同种子从 $[0,1]^2$ 上的均匀分布中为 $j=1,\\dots,6$ 生成结构描述符 $\\mathbf{s}_{g,j}$，以固定特征。构建 $\\mathbf{x}_{g,j} = [\\mathbf{c}_g; \\mathbf{s}_{g,j}] \\in \\mathbb{R}^{5}$。\n2. 对于每个测试用例，使用指定的 $\\sigma$ 和噪声种子，通过公式 $E_f(g,j) = b + \\mathbf{c}_g \\cdot \\mathbf{w}_c + \\mathbf{s}_{g,j} \\cdot \\mathbf{w}_s + \\varepsilon_{g,j}$ 生成目标值，得到单位为 $\\mathrm{eV/atom}$ 的 $y_{g,j}$。\n3. 使用种子 $99$ 将组划分为 $K$ 折。对每一折，通过求解 $\\left(\\mathbf{X}_{\\mathrm{aug}}^\\top \\mathbf{X}_{\\mathrm{aug}} + \\mathbf{L}\\right)\\boldsymbol{\\beta} = \\mathbf{X}_{\\mathrm{aug}}^\\top \\mathbf{y}$ 在训练集上拟合岭回归，其中 $\\mathbf{L}=\\mathrm{diag}(0,\\lambda,\\dots,\\lambda)$ 以将截距从正则化中排除。\n4. 计算每折的 MAE $m_k$，然后使用具有 $K-1$ 自由度的学生 $t$-分布计算 $\\bar{m}$、$s$ 和 $95\\%$ 置信区间。\n5. 对所有测试用例重复上述步骤，并在单行上打印这三个用例的三元组列表 $[\\bar{m},\\mathrm{lower},\\mathrm{upper}]$。\n\n该设计基于带 $\\ell_2$ 正则化的经验风险最小化、对截距的正确处理、通过学生 $t$ 分布进行的统计推断，以及用于防止共享成分描述符的多晶型物之间信息泄露的分组感知验证。以 $\\mathrm{eV/atom}$ 为单位报告 MAE 及其置信区间，符合计算材料科学中有物理意义的单位。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import t\n\ndef generate_features(num_groups=12, polymorphs_per_group=6, comp_dim=3, struct_dim=2, seed=0):\n    \"\"\"\n    Generate fixed composition and structure descriptors for reproducibility.\n    Returns:\n        X: (N, d) feature matrix where d = comp_dim + struct_dim\n        groups: (N,) array of group labels (composition indices)\n        comp_desc: (num_groups, comp_dim) array of composition descriptors\n        struct_desc: (N, struct_dim) array of structure descriptors\n    \"\"\"\n    rng = np.random.RandomState(seed)\n    comp_desc = rng.uniform(0.0, 1.0, size=(num_groups, comp_dim))\n    N = num_groups * polymorphs_per_group\n    struct_desc = rng.uniform(0.0, 1.0, size=(N, struct_dim))\n\n    # Build full features by concatenating composition and structure descriptors\n    d = comp_dim + struct_dim\n    X = np.zeros((N, d))\n    groups = np.zeros(N, dtype=int)\n\n    idx = 0\n    for g in range(num_groups):\n        c = comp_desc[g]\n        for j in range(polymorphs_per_group):\n            s = struct_desc[idx]\n            X[idx, :] = np.concatenate([c, s])\n            groups[idx] = g\n            idx += 1\n    return X, groups, comp_desc, struct_desc\n\ndef generate_targets(comp_desc, struct_desc, num_groups=12, polymorphs_per_group=6,\n                     w_c=np.array([0.8, -0.6, 0.4]),\n                     w_s=np.array([0.5, -0.3]),\n                     b=-2.0, sigma=0.05, noise_seed=11):\n    \"\"\"\n    Generate formation energy targets based on ground-truth linear model and Gaussian noise.\n    Returns:\n        y: (N,) target vector in eV/atom\n    \"\"\"\n    N = num_groups * polymorphs_per_group\n    y = np.zeros(N)\n    rng = np.random.RandomState(noise_seed)\n    idx = 0\n    for g in range(num_groups):\n        c = comp_desc[g]\n        for j in range(polymorphs_per_group):\n            s = struct_desc[idx]\n            mean_val = b + np.dot(c, w_c) + np.dot(s, w_s)\n            noise = rng.normal(loc=0.0, scale=sigma)\n            y[idx] = mean_val + noise\n            idx += 1\n    return y\n\ndef grouped_kfold(groups, K, seed=99):\n    \"\"\"\n    Create grouped K-fold splits: returns list of (train_indices, test_indices).\n    Ensures all samples of the same group are in the same fold.\n    \"\"\"\n    unique_groups = np.unique(groups)\n    rng = np.random.RandomState(seed)\n    shuffled = unique_groups.copy()\n    rng.shuffle(shuffled)\n    n_groups = len(shuffled)\n    # Partition groups into K folds as evenly as possible\n    fold_sizes = np.full(K, n_groups // K, dtype=int)\n    fold_sizes[: (n_groups % K)] += 1\n    folds = []\n    start = 0\n    for fs in fold_sizes:\n        folds.append(shuffled[start:start+fs])\n        start += fs\n\n    # Map groups to sample indices\n    group_to_indices = {g: np.where(groups == g)[0] for g in unique_groups}\n    splits = []\n    all_indices = np.arange(len(groups))\n    for test_groups in folds:\n        test_idx_list = []\n        for g in test_groups:\n            test_idx_list.append(group_to_indices[g])\n        test_indices = np.concatenate(test_idx_list)\n        train_mask = np.ones(len(groups), dtype=bool)\n        train_mask[test_indices] = False\n        train_indices = all_indices[train_mask]\n        splits.append((train_indices, test_indices))\n    return splits\n\ndef ridge_fit(X, y, lam):\n    \"\"\"\n    Fit ridge regression with intercept unpenalized.\n    Solve (X_aug^T X_aug + L) beta = X_aug^T y, where L has 0 for intercept and lam for weights.\n    Returns:\n        beta: (d+1,) parameter vector [intercept, weights...]\n    \"\"\"\n    n, d = X.shape\n    X_aug = np.hstack([np.ones((n, 1)), X])\n    # Regularization matrix L: 0 for intercept, lam for other coefficients\n    L = np.diag(np.concatenate(([0.0], np.full(d, lam))))\n    A = X_aug.T @ X_aug + L\n    b = X_aug.T @ y\n    beta = np.linalg.solve(A, b)\n    return beta\n\ndef evaluate_case(K, lam, sigma, noise_seed,\n                  num_groups=12, polymorphs_per_group=6,\n                  comp_dim=3, struct_dim=2):\n    \"\"\"\n    Evaluate grouped K-fold CV for one case.\n    Returns:\n        (mae_mean, ci_lower, ci_upper)\n    \"\"\"\n    # Fixed features across cases\n    X, groups, comp_desc, struct_desc = generate_features(\n        num_groups=num_groups,\n        polymorphs_per_group=polymorphs_per_group,\n        comp_dim=comp_dim,\n        struct_dim=struct_dim,\n        seed=0\n    )\n    # Targets for this case\n    y = generate_targets(\n        comp_desc=comp_desc,\n        struct_desc=struct_desc,\n        num_groups=num_groups,\n        polymorphs_per_group=polymorphs_per_group,\n        b=-2.0,\n        w_c=np.array([0.8, -0.6, 0.4]),\n        w_s=np.array([0.5, -0.3]),\n        sigma=sigma,\n        noise_seed=noise_seed\n    )\n\n    splits = grouped_kfold(groups, K=K, seed=99)\n    fold_maes = []\n    for train_idx, test_idx in splits:\n        X_train, y_train = X[train_idx], y[train_idx]\n        X_test, y_test = X[test_idx], y[test_idx]\n        beta = ridge_fit(X_train, y_train, lam=lam)\n        # Predict\n        X_test_aug = np.hstack([np.ones((X_test.shape[0], 1)), X_test])\n        y_pred = X_test_aug @ beta\n        mae = float(np.mean(np.abs(y_pred - y_test)))\n        fold_maes.append(mae)\n\n    # Aggregate MAE and compute 95% CI via Student's t\n    K_float = float(K)\n    mae_mean = float(np.mean(fold_maes))\n    if K > 1:\n        s = float(np.std(fold_maes, ddof=1))\n        t_star = float(t.ppf(0.975, df=K - 1))\n        margin = t_star * s / np.sqrt(K_float)\n    else:\n        # Degenerate case; no CI with a single fold, margin set to 0\n        margin = 0.0\n\n    ci_lower = mae_mean - margin\n    ci_upper = mae_mean + margin\n    return [mae_mean, ci_lower, ci_upper]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (K, lambda, sigma, noise_seed)\n    test_cases = [\n        (3, 0.1, 0.05, 11),\n        (2, 0.0, 0.10, 22),\n        (4, 1.0, 0.20, 33),\n    ]\n\n    results = []\n    for case in test_cases:\n        K, lam, sigma, noise_seed = case\n        result = evaluate_case(K=K, lam=lam, sigma=sigma, noise_seed=noise_seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(results)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3463892"}]}