{"hands_on_practices": [{"introduction": "进化算法的核心是适应度函数，它引导搜索走向最优解。在晶体结构预测中，虽然计算出的总能量是决定适应度的主要因素，但我们可以通过将化学知识直接整合到适应度景观中，来显著加速发现物理上真实的结构。此练习 [@problem_id:3450416] 演示了如何构建一个带罚分的适应度函数，该函数不鼓励合金中出现化学上不利的局部环境，利用鲍林（Pauling）电负性这一基本化学概念来量化和惩罚不同种类原子间的成键。", "problem": "您正在为应用于计算材料科学中晶体结构预测的演化算法（EA）设计一个适应度函数。其基本原则是，低能量结构应被优先选择，而具有大电负性差异的局部化学环境应受到惩罚，以促进合金中物理上真实的有序排列。请使用以下基本依据，为候选结构推导一个数学上一致的惩罚适应度能量，并予以实现：\n\n- 需要最小化的基准量是形成能 $E$，单位为电子伏特（eV）。\n- Pauling 电负性 $\\chi$ 是一个经过充分检验的、描述原子吸引电子趋势的描述符。\n- 局部失配应在结构中所有唯一的最近邻对 $\\langle i,j\\rangle$ 上累加。\n- 对一个原子对的惩罚应随电负性差异的绝对值增大而增大，并与一个具有能量单位的可调谐系数 $\\alpha$ 成正比，以确保量纲一致性。\n- 只包括唯一的最近邻对；不要重复计数或包括自身对。\n\n根据这些原则，推导出惩罚适应度能量的显式表达式，并实现一个程序，为下方的每个测试用例计算该值。所有最终能量均以 eV 表示，并四舍五入至六位小数。\n\n原子种类由符号标记，其 Pauling 电负性如下：\n- 种类 $A$：$\\chi_A = $ $1.60$\n- 种类 $B$：$\\chi_B = $ $3.00$\n- 种类 $C$：$\\chi_C = $ $2.50$\n\n每个测试用例提供：\n- 基准能量 $E$ (eV)。\n- 系数 $\\alpha$ (eV)。\n- 分配到晶格位点的原子种类列表，索引从 0 开始。\n- 一个由位点索引给出的唯一无向最近邻对 $(i,j)$ 的邻接表，其中 $i \\neq j$，且每个无序对仅出现一次。\n\n测试套件：\n- 用例 $1$（正常路径，方形基元上的二元有序结构）：\n  - $E = $ $-0.25$\n  - $\\alpha = $ $0.05$\n  - 位点 $\\{0,1,2,3\\}$ 上的种类：$[A,B,B,A]$\n  - 最近邻对：$\\{(0,1),(0,2),(1,3),(2,3)\\}$\n- 用例 $2$（边界情况，均匀组分无失配）：\n  - $E = $ $-0.10$\n  - $\\alpha = $ $0.20$\n  - 位点 $\\{0,1,2,3\\}$ 上的种类：$[A,A,A,A]$\n  - 最近邻对：$\\{(0,1),(0,2),(1,3),(2,3)\\}$\n- 用例 $3$（边界情况，不施加惩罚）：\n  - $E = $ $-0.25$\n  - $\\alpha = $ $0.00$\n  - 位点 $\\{0,1,2,3\\}$ 上的种类：$[A,B,B,A]$\n  - 最近邻对：$\\{(0,1),(0,2),(1,3),(2,3)\\}$\n- 用例 $4$（具有不同失配的三元链）：\n  - $E = $ $0.15$\n  - $\\alpha = $ $0.10$\n  - 位点 $\\{0,1,2,3\\}$ 上的种类：$[A,C,B,A]$\n  - 最近邻对：$\\{(0,1),(1,2),(2,3)\\}$\n- 用例 $5$（边缘情况，邻居列表为空）：\n  - $E = $ $-1.00$\n  - $\\alpha = $ $0.50$\n  - 位点 $\\{0,1\\}$ 上的种类：$[B,C]$\n  - 最近邻对：$\\{\\}$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_k$ 是用例 $k$ 的惩罚适应度能量（eV），四舍五入到六位小数。", "solution": "用户提供了一个问题，要求推导并实现一个用于晶体结构预测中演化算法的适应度函数。该过程始于对问题陈述的强制性验证。\n\n### 第 1 步：提取已知条件\n\n问题提供了以下定义、常数和数据：\n\n*   **目标**：推导并实现一个惩罚适应度能量函数。\n*   **基准量**：形成能 $E$，单位为电子伏特（eV）。\n*   **惩罚原则**：应惩罚具有大电负性差异的局部化学环境，该差异由 Pauling 电负性 $\\chi$ 量化。\n*   **惩罚结构**：\n    *   惩罚在所有唯一的最近邻对 $\\langle i,j\\rangle$ 上累加。\n    *   单个原子对的惩罚与一个可调谐系数 $\\alpha$（单位为 eV）成正比。\n    *   单个原子对的惩罚随电负性差异的绝对值增大而增大。\n    *   仅考虑唯一的、无向的最近邻对 $(i,j)$，其中 $i \\neq j$。\n*   **Pauling 电负性（$\\chi$）**：\n    *   种类 $A$：$\\chi_A = 1.60$\n    *   种类 $B$：$\\chi_B = 3.00$\n    *   种类 $C$：$\\chi_C = 2.50$\n*   **测试用例**：\n    *   **用例 1**：$E = -0.25$ eV, $\\alpha = 0.05$ eV, 种类 = $[A,B,B,A]$ 位于位点 $\\{0,1,2,3\\}$, 邻居 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n    *   **用例 2**：$E = -0.10$ eV, $\\alpha = 0.20$ eV, 种类 = $[A,A,A,A]$ 位于位点 $\\{0,1,2,3\\}$, 邻居 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n    *   **用例 3**：$E = -0.25$ eV, $\\alpha = 0.00$ eV, 种类 = $[A,B,B,A]$ 位于位点 $\\{0,1,2,3\\}$, 邻居 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n    *   **用例 4**：$E = 0.15$ eV, $\\alpha = 0.10$ eV, 种类 = $[A,C,B,A]$ 位于位点 $\\{0,1,2,3\\}$, 邻居 = $\\{(0,1),(1,2),(2,3)\\}$。\n    *   **用例 5**：$E = -1.00$ eV, $\\alpha = 0.50$ eV, 种类 = $[B,C]$ 位于位点 $\\{0,1\\}$, 邻居 = $\\{\\}$。\n*   **输出格式**：一个单行的逗号分隔值列表，`[x_1,x_2,x_3,x_4,x_5]`，每个结果四舍五入到六位小数。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n根据指定的验证标准对问题进行评估。\n\n*   **科学性基础**：该问题在计算材料科学中有充分的依据。最小化形成能是晶体结构预测的主要目标。使用电负性来惩罚不利的局部成键环境是合金理论和材料建模中一种标准的、具有物理意义的启发式方法。\n*   **适定性**：该问题是适定的。所提供的原则足以推导出适应度函数的唯一数学表达式。在物理模型的背景下，且没有其他具体说明时，“随……增大”这一术语意味着最简单的线性关系，即正比关系。这种解释导出了一个单一、明确的公式。每个测试用例都提供了所有必要的数据。\n*   **客观性**：语言精确、量化，并且没有主观或含糊的术语。\n*   **完整性与一致性**：问题是自洽且内部一致的。没有遗漏任何基本信息，也没有相互矛盾的约束。\n*   **现实性与可行性**：所提供的能量和电负性数值是现实的。结构基元虽然简单，但是对局部原子排列的有效表示。\n\n**结论**：该问题是**有效的**。它具有科学依据、适定、客观且完整。\n\n### 第 3 步：推导与求解\n\n基于所提供的原则，推导出惩罚适应度能量 $E_{penalized}$ 的数学表达式。\n\n总适应度能量是基准形成能 $E$ 和总惩罚项 $P_{total}$ 的和。\n$$ E_{penalized} = E + P_{total} $$\n\n总惩罚项是在邻居集合 $\\mathcal{N}$ 中每个唯一的最近邻对 $\\langle i,j \\rangle$ 的惩罚的累加和。\n$$ P_{total} = \\sum_{\\langle i,j \\rangle \\in \\mathcal{N}} P_{ij} $$\n\n单个原子对的惩罚 $P_{ij}$ 与系数 $\\alpha$ 以及位点 $i$ 和 $j$ 上的原子种类 $S_i$ 和 $S_j$ 之间的电负性差异的绝对值成正比。对此最直接的数学表示是：\n$$ P_{ij} = \\alpha \\cdot |\\chi(S_i) - \\chi(S_j)| $$\n其中 $\\chi(S_k)$ 是位点 $k$ 上原子种类的电负性。\n\n将这些部分组合起来，得到惩罚适应度能量的最终表达式：\n$$ E_{penalized} = E + \\alpha \\sum_{\\langle i,j \\rangle \\in \\mathcal{N}} |\\chi(S_i) - \\chi(S_j)| $$\n\n现在将此公式应用于每个测试用例。电负性值为 $\\chi_A = 1.60$，$\\chi_B = 3.00$ 和 $\\chi_C = 2.50$。\n\n**用例 1**：\n$E = -0.25$, $\\alpha = 0.05$, 种类 = $[A,B,B,A]$, 邻居 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n原子对为 $(A,B)$、$(A,B)$、$(B,A)$、$(B,A)$。\n一个 $A-B$ 对的电负性差异为 $|\\chi_A - \\chi_B| = |1.60 - 3.00| = 1.40$。\n差异之和为 $\\sum |\\Delta\\chi| = 1.40 + 1.40 + 1.40 + 1.40 = 4 \\times 1.40 = 5.60$。\n$E_{penalized} = -0.25 + 0.05 \\times 5.60 = -0.25 + 0.28 = 0.03$。\n\n**用例 2**：\n$E = -0.10$, $\\alpha = 0.20$, 种类 = $[A,A,A,A]$, 邻居 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n所有原子对都是 $(A,A)$。电负性差异为 $|\\chi_A - \\chi_A| = |1.60 - 1.60| = 0.00$。\n差异之和为 $\\sum |\\Delta\\chi| = 0$。\n$E_{penalized} = -0.10 + 0.20 \\times 0.00 = -0.10 + 0.00 = -0.10$。\n\n**用例 3**：\n$E = -0.25$, $\\alpha = 0.00$, 种类 = $[A,B,B,A]$, 邻居 = $\\{(0,1),(0,2),(1,3),(2,3)\\}$。\n原子种类和邻居与用例 1 相同，所以 $\\sum |\\Delta\\chi| = 5.60$。\n惩罚系数为 $\\alpha = 0.00$。\n$E_{penalized} = -0.25 + 0.00 \\times 5.60 = -0.25 + 0.00 = -0.25$。\n\n**用例 4**：\n$E = 0.15$, $\\alpha = 0.10$, 种类 = $[A,C,B,A]$, 邻居 = $\\{(0,1),(1,2),(2,3)\\}$。\n原子对为 $(A,C)$、$(C,B)$、$(B,A)$。\n- 原子对 $(A,C)$：$|\\chi_A - \\chi_C| = |1.60 - 2.50| = 0.90$。\n- 原子对 $(C,B)$：$|\\chi_C - \\chi_B| = |2.50 - 3.00| = 0.50$。\n- 原子对 $(B,A)$：$|\\chi_B - \\chi_A| = |3.00 - 1.60| = 1.40$。\n差异之和为 $\\sum |\\Delta\\chi| = 0.90 + 0.50 + 1.40 = 2.80$。\n$E_{penalized} = 0.15 + 0.10 \\times 2.80 = 0.15 + 0.28 = 0.43$。\n\n**用例 5**：\n$E = -1.00$, $\\alpha = 0.50$, 种类 = $[B,C]$, 邻居 = $\\{\\}$。\n邻居集合 $\\mathcal{N}$ 为空。对空集的求和结果为 $0$。\n$\\sum |\\Delta\\chi| = 0$。\n$E_{penalized} = -1.00 + 0.50 \\times 0.00 = -1.00 + 0.00 = -1.00$。\n\n最终结果四舍五入到六位小数后为：\n$0.030000$, $-0.100000$, $-0.250000$, $0.430000$, $-1.000000$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes a penalized fitness energy for crystal structures\n    based on formation energy and electronegativity mismatch of nearest neighbors.\n    \"\"\"\n\n    # Define the Pauling electronegativity values for each atomic species.\n    # These are dimensionless quantities.\n    CHI_VALS = {\n        'A': 1.60,\n        'B': 3.00,\n        'C': 2.50\n    }\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (E, alpha, species_list, neighbor_list)\n    # E: baseline formation energy in eV\n    # alpha: tunable penalty coefficient in eV\n    # species_list: list of species symbols at indexed lattice sites\n    # neighbor_list: list of unique, undirected first-neighbor pairs (i, j)\n    test_cases = [\n        # Case 1: happy path, binary ordering on a square motif\n        (-0.25, 0.05, ['A', 'B', 'B', 'A'], [(0, 1), (0, 2), (1, 3), (2, 3)]),\n        # Case 2: boundary, uniform composition with no mismatch\n        (-0.10, 0.20, ['A', 'A', 'A', 'A'], [(0, 1), (0, 2), (1, 3), (2, 3)]),\n        # Case 3: boundary, no penalty applied (alpha = 0)\n        (-0.25, 0.00, ['A', 'B', 'B', 'A'], [(0, 1), (0, 2), (1, 3), (2, 3)]),\n        # Case 4: ternary chain with varied mismatches\n        (0.15, 0.10, ['A', 'C', 'B', 'A'], [(0, 1), (1, 2), (2, 3)]),\n        # Case 5: edge case, empty neighbor list\n        (-1.00, 0.50, ['B', 'C'], [])\n    ]\n\n    results = []\n    for E, alpha, species, neighbors in test_cases:\n        # The penalty term is the sum of electronegativity differences\n        # over all first-neighbor pairs.\n        delta_chi_sum = 0.0\n        for i, j in neighbors:\n            # Retrieve the species at each site of the pair.\n            species_i = species[i]\n            species_j = species[j]\n\n            # Retrieve the corresponding electronegativity values.\n            chi_i = CHI_VALS[species_i]\n            chi_j = CHI_VALS[species_j]\n\n            # The penalty increases with the magnitude of the difference.\n            delta_chi_sum += abs(chi_i - chi_j)\n\n        # The total penalty is the sum of differences scaled by the coefficient alpha.\n        # This ensures dimensional consistency as alpha is in eV.\n        total_penalty = alpha * delta_chi_sum\n\n        # The final penalized energy is the baseline energy plus the total penalty.\n        penalized_energy = E + total_penalty\n\n        # Format the result to six decimal places as required.\n        results.append(f\"{penalized_energy:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3450416"}, {"introduction": "除了化学启发式方法，进化算法还必须尊重基本的物理定律。对于离子材料而言，体相晶体中的电中性原则是一条严格且不可违背的约束。此实践 [@problem_id:3450424] 挑战您从第一性原理推导该约束，并实现两种强有力的强制执行策略：为非电中性候选者在适应度函数中增加一个罚分项，以及设计一个“修复”算符，该算符能确定性地修改无效的化学成分使其变为电中性。", "problem": "您正在为晶体结构预测（CSP）的演化算法（EA）设计一个组件，该组件用于生成候选的离子组分。这些组分由非负整数化学计量数表示。您的任务是从静电学原理出发，推导出一个电中性约束，为违反该约束的行为定义一个数学上合理的罚函数，并实现一个确定性的修复策略，在可能的情况下通过最小程度地修改化学计量数来强制实现电中性。\n\n从基本原理开始推导该约束。从以下事实开始：在静电平衡状态下，一个周期性体单胞内包含的总自由电荷必须为零，且总电荷是所有离子电荷的总和。考虑一个候选组分，由化学计量数向量 $\\mathbf{n} = (n_{1}, n_{2}, \\dots, n_{k})$ 和相关的离子电荷数向量 $\\mathbf{z} = (z_{1}, z_{2}, \\dots, z_{k})$ 指定，其中每个 $z_{i}$ 是以基本电荷单位计量的整数氧化态，每个 $n_{i}$ 是一个非负整数。表达净电荷 $Q(\\mathbf{n};\\mathbf{z})$ 并推导在单胞中强制实现电中性的精确线性约束。然后，提出：\n\n- 一个非负罚函数 $P(\\mathbf{n};\\mathbf{z})$，该函数当且仅当满足电中性时为零，并随电荷违背的量级单调增加。该罚函数必须是无量纲的，并应包含一个通过总原子数进行的显式归一化，以避免偏向于更大的超胞。您可以引入一个小的正标量 $\\varepsilon$ 以防止在总原子数为零时出现除以零的情况。\n- 一个修复算子，它将给定的 $\\mathbf{n}$ 映射到一个新的整数向量 $\\mathbf{n}^{\\prime} \\ge \\mathbf{0}$，使得只要存在这样的非空修复，中性约束就得到满足。该算子必须被明确定义为一个离散优化问题的解，该问题在满足电中性和非负性约束的条件下，最小化逐项 $\\ell_{1}$ 距离 $\\|\\mathbf{n}^{\\prime} - \\mathbf{n}\\|_{1}$。如果存在多个最小化向量，则通过选择总原子数 $\\sum_{i} n_{i}^{\\prime}$ 最小的一个来解决平局；如果仍然平局，则选择字典序（升序）最小的 $\\mathbf{n}^{\\prime}$。如果在这些约束下不存在非空的修复，该算子必须返回一个表示不可能的显式指示。\n\n您的程序必须实现所推导的罚函数和修复算子，并在以下测试集上对其进行评估。对于每个测试用例，输入为整数列表形式的 $\\mathbf{z}$ 和 $\\mathbf{n}$。本问题中不涉及物理单位。\n\n测试集：\n- 情况 A（已中性）：$\\mathbf{z} = [\\, +1, -1 \\,]$, $\\mathbf{n} = [\\, 4, 4 \\,]$。\n- 情况 B（二元非化学计量）：$\\mathbf{z} = [\\, +2, -2 \\,]$, $\\mathbf{n} = [\\, 5, 4 \\,]$。\n- 情况 C（二元体系中的类三元价态模式）：$\\mathbf{z} = [\\, +3, -2 \\,]$, $\\mathbf{n} = [\\, 2, 2 \\,]$。\n- 情况 D（所有电荷同号，非平凡）：$\\mathbf{z} = [\\, +1, +2 \\,]$, $\\mathbf{n} = [\\, 1, 1 \\,]$。\n- 情况 E（最小修复需要多次编辑）：$\\mathbf{z} = [\\, +2, -3 \\,]$, $\\mathbf{n} = [\\, 2, 1 \\,]$。\n\n需要实现的定义：\n- 净电荷：$Q(\\mathbf{n};\\mathbf{z}) = \\sum_{i=1}^{k} z_{i} n_{i}$。\n- 中性约束：$\\sum_{i=1}^{k} z_{i} n_{i} = 0$。\n- 罚函数（无量纲）：$P(\\mathbf{n};\\mathbf{z}) = \\dfrac{Q(\\mathbf{n};\\mathbf{z})^{2}}{\\sum_{i=1}^{k} n_{i} + \\varepsilon}$，固定 $\\varepsilon = 10^{-9}$。\n- 修复算子：找到求解以下问题的 $\\mathbf{n}^{\\prime} \\in \\mathbb{Z}_{\\ge 0}^{k}$\n  $$\\min_{\\mathbf{n}^{\\prime} \\in \\mathbb{Z}_{\\ge 0}^{k}} \\left\\| \\mathbf{n}^{\\prime} - \\mathbf{n} \\right\\|_{1} \\quad \\text{约束条件为} \\quad \\sum_{i=1}^{k} z_{i} n_{i}^{\\prime} = 0 \\quad \\text{和} \\quad \\sum_{i=1}^{k} n_{i}^{\\prime}  0,$$\n  并使用上述的平局决胜规则。如果不存在可行的非空 $\\mathbf{n}^{\\prime}$，则对该情况返回空列表 $[\\,]$ 作为修复结果。\n\n您的程序应硬编码上述测试集，并为每个用例计算：\n- 一个布尔标志，指示原始 $\\mathbf{n}$ 是否中性，\n- 罚函数值 $P(\\mathbf{n};\\mathbf{z})$，四舍五入到六位小数，\n- 修复后的化学计量列表 $\\mathbf{n}^{\\prime}$（如果不可能，则为空列表 $[\\,]$），\n\n并输出一行内容，该行包含一个按 A 到 E 顺序排列的各用例结果列表，其中每个用例的结果是列表 $[\\,\\text{neutral\\_flag}, P, \\mathbf{n}^{\\prime}\\,]$。您的程序应生成单行输出，其中包含一个用方括号括起来、以逗号分隔的结果列表（例如，$[\\,\\text{result1},\\text{result2},\\text{result3}\\,]$）。", "solution": "为晶体结构预测生成有效的离子组分是计算材料科学中演化算法的核心组成部分。所给任务是形式化电中性约束，为其违背设计一个罚函数，并实现一个确定性的修复算子。该问题是有效的，具有静电学的科学依据，并且在算法上是适定的。\n\n### 1. 电中性约束的推导\n\n推导始于应用于周期性固体的静电学基本原理。在稳定的体相晶体材料中，不存在宏观的内部电场。根据高斯定律的微分形式 $\\nabla \\cdot \\mathbf{E} = \\rho / \\epsilon_0$，零电场（$\\mathbf{E}=0$）意味着处处为零的净电荷密度（$\\rho=0$）。\n\n将电荷密度在单个单胞的体积上积分，即可得到该单胞内包含的总电荷 $Q_{\\text{cell}}$，单胞代表了晶体的重复结构单元。为了使晶体在宏观上呈电中性，单胞本身必须是电中性的。\n\n设晶体由 $k$ 种不同类型的离子组成。\n- 设 $\\mathbf{n} = (n_{1}, n_{2}, \\dots, n_{k})$ 为化学计量数向量，其中 $n_{i} \\in \\mathbb{Z}_{\\ge 0}$ 是单胞中类型 $i$ 的离子数量。\n- 设 $\\mathbf{z} = (z_{1}, z_{2}, \\dots, z_{k})$ 为相应的离子电荷数（或氧化态）向量，其中 $z_{i} \\in \\mathbb{Z}$ 是类型 $i$ 的离子电荷，以基本电荷 $e$ 为单位。\n\n类型 $i$ 的离子贡献的总电荷为 $n_i z_i e$。单胞中的总电荷是所有离子类型的总和：\n$$Q_{\\text{cell}} = \\sum_{i=1}^{k} n_i z_i e$$\n电中性的条件是 $Q_{\\text{cell}} = 0$。由于基本电荷 $e$ 是一个非零常数，这等价于电荷数的总和为零。我们将组分的净电荷数定义为：\n$$Q(\\mathbf{n};\\mathbf{z}) = \\sum_{i=1}^{k} n_{i} z_{i}$$\n因此，强制实现电中性的精确线性约束是一个线性丢番图方程：\n$$\\sum_{i=1}^{k} n_{i} z_{i} = 0$$\n\n### 2. 罚函数\n\n在演化算法中，罚函数用于惩罚违反硬约束的候选解。一个合适的罚函数 $P(\\mathbf{n};\\mathbf{z})$ 应满足以下标准：\n- **非负性**：$P \\ge 0$。\n- **当且仅当中性时为零**：$P = 0 \\iff Q(\\mathbf{n};\\mathbf{z}) = 0$。\n- **单调性**：$P$ 应随电荷违背的量级 $|Q|$ 的增加而增加。\n\n所提出的函数是：\n$$P(\\mathbf{n};\\mathbf{z}) = \\frac{Q(\\mathbf{n};\\mathbf{z})^{2}}{\\sum_{i=1}^{k} n_{i} + \\varepsilon}$$\n该函数满足这些标准：\n- 将净电荷 $Q$ 平方确保了非负性，并保证了罚函数仅在中性条件满足时为零。其二次型也提供了平滑的梯度，这对于许多优化方法都是有益的。\n- 分母 $\\sum n_i$ 代表组分中的总原子数。这种归一化使得罚函数无量纲，并考虑了体系的大小，从而对具有相同绝对电荷不平衡的小体系施加比大体系更重的惩罚。\n- 小的正标量 $\\varepsilon = 10^{-9}$ 是一个标准的正则化项，用于防止在空组分（其中 $\\sum n_i = 0$）情况下出现除以零的错误。\n\n### 3. 修复算子\n\n修复算子是一个确定性过程，用于将电荷不平衡的组分 $\\mathbf{n}$ 映射到一个中性的组分 $\\mathbf{n}^{\\prime}$。修复必须是最小的，以尽可能保留原始候选解的信息。这被表述为一个离散优化问题。\n\n**目标**：找到一个新的化学计量向量 $\\mathbf{n}^{\\prime} \\in \\mathbb{Z}_{\\ge 0}^{k}$，它最小化与原始向量 $\\mathbf{n}$ 之间的 $\\ell_1$ 距离（曼哈顿距离）。$\\ell_1$ 距离对应于单个原子增加或移除的总数。\n$$\\min_{\\mathbf{n}^{\\prime} \\in \\mathbb{Z}_{\\ge 0}^{k}} \\left\\| \\mathbf{n}^{\\prime} - \\mathbf{n} \\right\\|_{1} = \\min_{\\mathbf{n}^{\\prime} \\in \\mathbb{Z}_{\\ge 0}^{k}} \\sum_{i=1}^{k} |n_{i}^{\\prime} - n_{i}|$$\n\n**约束条件**：\n1.  **电中性**：$\\sum_{i=1}^{k} z_{i} n_{i}^{\\prime} = 0$。\n2.  **非负性**：对于所有 $i=1, \\dots, k$，$n_{i}^{\\prime} \\ge 0$。\n3.  **非空性**：$\\sum_{i=1}^{k} n_{i}^{\\prime}  0$。这防止了平凡解 $\\mathbf{n}^{\\prime} = \\mathbf{0}$（该解是中性的，但作为晶体在物理上没有意义）。\n\n**不可能性**：只有当可用离子电荷集合中同时包含正值和负值时，才能形成非空的电中性组分。如果所有 $z_i$ 都具有相同的符号（或为零），那么在 $n_i' \\ge 0$ 的条件下满足 $\\sum z_i n_i' = 0$ 的唯一方法是，对于所有 $z_i \\ne 0$ 的 $i$，都有 $n_i' = 0$。如果所有 $z_i$ 都是非零且同号，或者只含有零电荷物种，这将导致一个空的组分。算子必须检测到这种不可能性并发出信号，为此返回一个空列表 `[]`。\n\n**求解算法**：这个优化问题可以通过在化学计量数的状态空间上使用广度优先搜索（BFS）来解决。从起始状态 $\\mathbf{n}$ 出发的距离是编辑次数（即 $\\ell_1$ 距离）。\n1.  搜索从距离 $d=0$ 的初始化学计量 $\\mathbf{n}$ 开始。\n2.  搜索按层级进行，其中层级 $d$ 包含所有可以从 $\\mathbf{n}$ 通过恰好 $d$ 次单原子编辑（增加或减少）达到的化学计量。\n3.  通过从前一个层级取出一个状态并应用一次编辑来生成一个新状态（化学计量向量）。维护一个 `visited` 集合以避免冗余计算。\n4.  找到一个或多个满足所有约束的有效化学计量的第一个层级 $d_{\\text{min}}$ 决定了最小的 $\\ell_1$ 距离。\n5.  收集所有距离为 $d_{\\text{min}}$ 的有效解。\n6.  对这组解顺序应用平局决胜规则以选择一个唯一的修复：\n    a.  选择总原子数 $\\sum n_{i}^{\\prime}$ 最小的解。\n    b.  从剩余的候选解中，选择字典序最小的向量 $\\mathbf{n}^{\\prime}$。\n\n这种逐层广度优先搜索保证了能找到具有最小 $\\ell_1$ 距离的解，而严格的平局决胜规则确保了结果的唯一性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for crystal composition validation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Already neutral\n        {'z': [1, -1], 'n': [4, 4]},\n        # Case B: Binary off-stoichiometry\n        {'z': [2, -2], 'n': [5, 4]},\n        # Case C: Ternary-like valence pattern in binary\n        {'z': [3, -2], 'n': [2, 2]},\n        # Case D: All charges same sign, nontrivial\n        {'z': [1, 2], 'n': [1, 1]},\n        # Case E: Minimal repair requires more than one edit\n        {'z': [2, -3], 'n': [2, 1]},\n    ]\n    epsilon = 1e-9\n\n    def repair_stoichiometry(z_vec, n_vec):\n        \"\"\"\n        Finds the minimally edited, charge-neutral stoichiometry.\n\n        This function implements a Breadth-First Search (BFS) to find a new\n        stoichiometry vector n' that minimizes the L1 distance to n, subject\n        to charge neutrality and non-negativity.\n        \"\"\"\n        # If already neutral and non-empty, no repair needed.\n        initial_charge = sum(zi * ni for zi, ni in zip(z_vec, n_vec))\n        if initial_charge == 0 and sum(n_vec)  0:\n            return list(n_vec)\n\n        # Check for impossibility: need both positive and negative valences.\n        has_pos = any(z  0 for z in z_vec if z != 0)\n        has_neg = any(z  0 for z in z_vec if z != 0)\n        if not (has_pos and has_neg):\n            return []\n\n        # BFS setup: level-by-level search\n        queue = [list(n_vec)]\n        visited = {tuple(n_vec)}\n\n        # Limit search depth to prevent extremely long runs on pathological cases.\n        max_edits = 20  \n        for _ in range(max_edits):\n            next_queue = []\n            solutions = []\n\n            for current_n in queue:\n                # Generate neighbors by one edit (increment/decrement)\n                for i in range(len(z_vec)):\n                    # Increment atom count\n                    next_n_inc = current_n[:]\n                    next_n_inc[i] += 1\n                    if tuple(next_n_inc) not in visited:\n                        visited.add(tuple(next_n_inc))\n                        charge = sum(z * n for z, n in zip(z_vec, next_n_inc))\n                        if charge == 0:  # sum(next_n_inc) is guaranteed  0\n                            solutions.append(next_n_inc)\n                        next_queue.append(next_n_inc)\n\n                    # Decrement atom count\n                    if current_n[i]  0:\n                        next_n_dec = current_n[:]\n                        next_n_dec[i] -= 1\n                        if tuple(next_n_dec) not in visited:\n                            visited.add(tuple(next_n_dec))\n                            charge = sum(z * n for z, n in zip(z_vec, next_n_dec))\n                            if charge == 0 and sum(next_n_dec)  0:\n                                solutions.append(next_n_dec)\n                            next_queue.append(next_n_dec)\n            \n            if solutions:\n                # Apply tie-breaking rules\n                # 1. Minimum total atom count\n                min_atom_count = min(sum(s) for s in solutions)\n                candidates = [s for s in solutions if sum(s) == min_atom_count]\n                \n                # 2. Lexicographically smallest\n                candidates.sort()\n                return candidates[0]\n            \n            queue = next_queue\n            if not queue:\n                break # Search space exhausted\n        \n        return [] # No solution found within search limit\n\n    results = []\n    for case in test_cases:\n        z, n = case['z'], case['n']\n\n        # Calculate net charge and neutrality flag\n        net_charge = sum(zi * ni for zi, ni in zip(z, n))\n        is_neutral = (net_charge == 0)\n\n        # Calculate penalty\n        total_atoms = sum(n)\n        penalty = net_charge**2 / (total_atoms + epsilon) if total_atoms  0 else float(net_charge**2 / epsilon)\n\n        # Perform repair\n        repaired_n = repair_stoichiometry(z, n)\n        \n        # Format list string without spaces for consistency\n        repaired_n_str = f\"[{','.join(map(str, repaired_n))}]\" if repaired_n else '[]'\n\n        # Format the result string for the current case\n        result_str = f\"[{is_neutral}, {penalty:.6f}, {repaired_n_str}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3450424"}]}