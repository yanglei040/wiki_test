{"hands_on_practices": [{"introduction": "本实践的核心是建立原子结构的实空间与倒易空间描述之间的基本联系。您将通过数值方法，验证由粒子坐标直接计算的静态结构因子 $S(k)$ 与通过径向分布函数 $g(r)$ 计算的 $S(k)$ 的等价性。这项练习旨在构建分析模拟数据的核心计算技能，并加深对局部原子排布（由 $g(r)$ 捕捉）如何产生可观测衍射图谱（与 $S(k)$ 相关）的理解 [@problem_id:3486874]。", "problem": "您需要编写一个完整、可运行的程序，该程序针对一个包含N个点粒子的三维周期性系统（位于边长为L的立方盒子中，采用周期性边界条件），通过两种独立的途径计算静态结构因子（表示为 $S(\\mathbf{k})$），并通过各向同性比较来验证它们的一致性。所有距离必须以纳米 (nm) 为单位，所有波矢量以逆纳米 (nm$^{-1}$) 为单位，所有角度以弧度为单位。最终输出必须是格式完全符合Python布尔值列表的单行文本，每个测试用例对应一个布尔值，该布尔值表示是否满足指定的数值验证标准。\n\n使用的基本原理：\n- 对于粒子位置 $\\{\\mathbf{r}_j\\}$，三维微观数密度场由 $\\,\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} \\delta(\\mathbf{r} - \\mathbf{r}_j)\\,$ 定义。\n- 在周期性边界条件下，静态结构因子 $\\,S(\\mathbf{k})\\,$ 是倒易空间中密度涨落的傅里叶变换。\n- 径向分布函数 $\\,g(r)\\,$ 由各向同性系统的双粒子密度定义，并通过三维各向同性变换与 $\\,S(k)\\,$ 相关联。\n\n您的程序必须：\n- 从这些核心定义出发，推导、实现并数值评估：\n  1. 通过对周期性边界条件下的粒子位置进行离散傅里叶变换（即，使用与立方盒子兼容的倒易晶格波矢）获得的 $\\,S(k)\\,$ 的角平均估计。通过将波矢分箱到宽度为 $\\Delta k$ 的球壳中，并对每个壳内的 $\\,S(\\mathbf{k})\\,$ 作为 $k = \\lVert \\mathbf{k} \\rVert$ 的函数进行平均，来执行各向同性平均。\n  2. 一种独立的 $\\,S(k)\\,$ 各向同性估计，首先使用最小镜像约定根据粒子对距离计算径向分布函数 $\\,g(r)\\,$，然后应用 $\\,S(k)\\,$ 和 $\\,g(r)\\,$ 之间的三维各向同性关系（表示为涉及球贝塞尔核的一维变换）。使用宽度为 $\\Delta r$ 的直方图分箱来估计 $r \\in (0, L/2]$ 上的 $\\,g(r)\\,$，并对每个感兴趣的k值执行数值稳定的求积法来评估积分。\n\n- 使用一致的单位（长度为 nm，波矢为 nm$^{-1}$），采用周期性边界条件，并以弧度处理角度变量。确保在比较中排除 $k=0$ 模式。在倒易空间中对 $\\,S(\\mathbf{k})\\,$ 进行分箱时，忽略任何波矢数量少于指定最小计数的k壳层，以保证有意义的角平均。\n\n- 实现一个定量验证指标，在公共的k网格上直接比较两种 $\\,S(k)\\,$ 估计。具体来说，对于两种估计都有定义的k分箱中心集合，计算两条曲线之间的相对 $\\ell_2$ 误差，\n  $$\\varepsilon = \\sqrt{\\frac{\\sum_{m} \\left(S_{\\text{DFT}}(k_m) - S_{g}(k_m)\\right)^2}{\\sum_{m} \\left(S_{g}(k_m)\\right)^2}},$$\n  并且当且仅当 $\\,\\varepsilon \\le \\text{tol}\\,$ 时，宣布测试通过，其中 $\\text{tol}$ 是每个测试用例指定的容差。\n\n- 程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[True,False,True]”）。\n\n测试套件：\n实现以下四个测试用例。对于每个用例，按规定生成粒子构型，然后计算两种各向同性的 $\\,S(k)\\,$ 估计并评估验证指标。使用给定的参数和容差。所有随机数生成必须通过提供的种子使其可复现。\n\n- 用例 A（理想气体，仅有短程无序）：\n  - $N = 512$，$L = 10.0\\,\\text{nm}$，在 $[0,L)^3$ 范围内随机均匀分布的位置，使用种子 $= 1$。\n  - 实空间直方图：$\\Delta r = 0.05\\,\\text{nm}$，粒子对距离最高到 $r_{\\max} = L/2$。\n  - 倒易空间波矢：所有映射到 $\\mathbf{k} = (2\\pi/L)\\,\\mathbf{n}$ 的整数三元组 $\\mathbf{n} \\in \\mathbb{Z}^3$，其中 $\\lVert \\mathbf{k} \\rVert \\le k_{\\max}$，$k_{\\max} = 6.0\\,\\text{nm}^{-1}$。\n  - k壳层分箱宽度：$\\Delta k = 0.4\\,\\text{nm}^{-1}$，排除 $\\mathbf{k}=\\mathbf{0}$ 模式以及任何包含少于5个波矢的壳层。\n  - 容差：$\\text{tol} = 0.18$。\n\n- 用例 B（具有小热位移的简单立方晶体，长程有序）：\n  - 在边长为 $L = 12.0\\,\\text{nm}$ 的立方盒子中，沿每个方向构建 $n_{\\text{cell}} = 6$ 个晶胞的简单立方晶格，生成位于晶格点上的 $N = n_{\\text{cell}}^3 = 216$ 个粒子，晶格常数为 $a = L/n_{\\text{cell}}$。\n  - 在每个笛卡尔方向上添加均值为零、标准差为 $\\sigma = 0.05\\,a$ 的独立高斯位移；将位置包裹回盒子内；随机种子 $= 2$。\n  - 实空间直方图：$\\Delta r = 0.03\\,\\text{nm}$，粒子对距离最高到 $r_{\\max} = L/2$。\n  - 倒易空间同用例 A，其中 $k_{\\max} = 6.0\\,\\text{nm}^{-1}$ 且 $\\Delta k = 0.4\\,\\text{nm}^{-1}$；排除 $\\mathbf{k}=\\mathbf{0}$ 模式以及任何包含少于5个波矢的壳层。\n  - 容差：$\\text{tol} = 0.28$。\n\n- 用例 C（具有排除体积的硬核流体，短程有序）：\n  - $N = 200$，$L = 10.0\\,\\text{nm}$，在周期性边界条件下通过随机顺序添加生成位置，最小对间距为 $d_{\\min} = 0.8\\,\\text{nm}$；随机种子 $= 3$。\n  - 实空间直方图：$\\Delta r = 0.05\\,\\text{nm}$，最高到 $r_{\\max} = L/2$。\n  - 倒易空间同用例 A，其中 $k_{\\max} = 6.0\\,\\text{nm}^{-1}$ 且 $\\Delta k = 0.4\\,\\text{nm}^{-1}$；排除 $\\mathbf{k}=\\mathbf{0}$ 模式以及任何包含少于5个波矢的壳层。\n  - 容差：$\\text{tol} = 0.25$。\n\n- 用例 D（小N边缘情况，含噪声统计）：\n  - $N = 64$，$L = 10.0\\,\\text{nm}$，在 $[0,L)^3$ 范围内随机均匀分布的位置，使用种子 $= 4$。\n  - 实空间直方图：$\\Delta r = 0.10\\,\\text{nm}$，最高到 $r_{\\max} = L/2$。\n  - 倒易空间，其中 $k_{\\max} = 6.0\\,\\text{nm}^{-1}$，$\\Delta k = 0.5\\,\\text{nm}^{-1}$；排除 $\\mathbf{k}=\\mathbf{0}$ 模式以及任何包含少于5个波矢的壳层。\n  - 容差：$\\text{tol} = 0.40$。\n\n实现要求：\n- 对粒子对距离使用最小镜像约定。\n- 对径向分布函数 $\\,g(r)\\,$ 直方图使用一致且正确的归一化。\n- 在三维空间中，使用数值稳定的球形核将 $\\,g(r)\\,$ 进行各向同性变换为 $\\,S(k)\\,$，确保在 $\\,k \\to 0\\,$ 时的行为正确，并处理有限上限 $\\,r_{\\max} = L/2\\,$。\n- 对于每个测试用例，汇总一个布尔值，表示是否满足相对 $\\ell_2$ 误差标准。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按 A、B、C、D 的顺序排列，例如：“[True,False,True,True]”。", "solution": "所给问题是计算统计物理学中一个有效、适定的练习。它要求实现并比较两种计算多粒子系统静态结构因子 $S(k)$ 的基本方法。该问题具有科学依据，形式上明确，并且在计算上是可行的。所有必要的参数和定义都已提供。\n\n解决方案首先按照测试用例中的规定，为几种物理情景生成粒子构型。然后，对每种构型，通过两种不同的途径计算各向同性平均的静态结构因子 $S(k)$。最后，使用指定的误差度量比较两种途径的结果，以验证其一致性。\n\n### 方法1：从粒子位置直接计算\n\n第一种方法直接从体积为 $V=L^3$ 的立方盒子中的粒子位置 $\\{\\mathbf{r}_j\\}_{j=1}^N$ 计算结构因子。对于单个粒子构型，在特定波矢量 $\\mathbf{k}$ 处的结构因子由下式给出：\n$$S(\\mathbf{k}) = \\frac{1}{N} \\left| \\sum_{j=1}^{N} \\exp(-i\\mathbf{k}\\cdot\\mathbf{r}_j) \\right|^2$$\n其中 N 是粒子数。由于系统施加了周期性边界条件，允许的波矢量 $\\mathbf{k}$ 必须与模拟盒子的倒易晶格兼容。对于边长为 L 的立方盒子，这些矢量是：\n$$\\mathbf{k} = \\frac{2\\pi}{L}\\mathbf{n}, \\quad \\text{其中} \\quad \\mathbf{n} = (n_x, n_y, n_z) \\in \\mathbb{Z}^3$$\n分析仅限于模长 $k = \\lVert\\mathbf{k}\\rVert$ 直到最大值 $k_{\\max}$ 的波矢量，并排除了 $\\mathbf{k} = \\mathbf{0}$ 的情况，因为它对应于平均密度，通常不属于 $S(k)$ 的一部分。\n\n为了获得各向同性的结构因子 $S(k)$，需要进行角平均。这在计算上是通过将计算出的 $S(\\mathbf{k})$ 值根据其模长 $k = \\lVert\\mathbf{k}\\rVert$ 分箱到倒易空间中的球壳中来实现的。对于每个对应于球壳 $[k_m - \\Delta k/2, k_m + \\Delta k/2)$ 的分箱 m，平均结构因子 $S_{\\text{DFT}}(k_m)$ 为：\n$$S_{\\text{DFT}}(k_m) = \\frac{1}{C_m} \\sum_{\\mathbf{k} \\in \\text{shell } m} S(\\mathbf{k})$$\n其中 $k_m$ 是分箱的中心，$C_m$ 是落入该壳层的离散 $\\mathbf{k}$ 矢量的数量。计数 $C_m$ 低于指定最小阈值的分箱将被丢弃，以确保统计上有意义的平均。\n\n### 方法2：通过径向分布函数计算\n\n第二种获得 $S(k)$ 的独立途径首先计算径向分布函数 $g(r)$。对于各向同性系统，$g(r)$ 与在距离一个参考粒子 $r$ 处找到另一个粒子的概率有关，该概率通过相同密度下理想气体的概率进行归一化。\n\n在数值上，$g(r)$ 的计算步骤如下：\n1. 使用最小镜像约定计算所有唯一的粒子对距离 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$，以正确处理周期性边界条件。\n2. 将这些距离以指定的箱宽 $\\Delta r$ 分箱到一个直方图 $H(r)$ 中。\n3. 将每个分箱 i（中心在 $r_i$）中的直方图计数，用在相应球壳体积 $V_{\\text{shell},i}$ 内理想气体所期望的粒子对数进行归一化。使用的公式是：\n$$g(r_i) = \\frac{H_i}{\\frac{N(N-1)}{2V} V_{\\text{shell},i}} \\quad \\text{其中} \\quad V_{\\text{shell},i} = \\frac{4\\pi}{3}((r_i+\\Delta r/2)^3 - (r_i-\\Delta r/2)^3)$$\n计算执行到距离 $r$ 的截断值为 $r_{\\max} = L/2$。\n\n对于三维各向同性系统，$S(k)$ 通过对关联函数 $h(r) = g(r) - 1$ 的傅里叶变换与 $g(r)$ 相关联：\n$$S(k) = 1 + \\rho_0 \\int_0^\\infty [g(r)-1] 4\\pi r^2 \\frac{\\sin(kr)}{kr} dr$$\n其中 $\\rho_0 = N/V$ 是平均数密度。项 $\\frac{\\sin(x)}{x}$ 是零阶球贝塞尔函数 $j_0(x)$。该积分通过在计算出的 $g(r_i)$ 值上使用简单的求积法（矩形法则）进行数值评估，直到 $r_{\\max}$：\n$$S_{g}(k_m) \\approx 1 + 4\\pi\\rho_0 \\sum_{i} [g(r_i)-1] r_i^2 \\frac{\\sin(k_m r_i)}{k_m r_i} \\Delta r$$\n这提供了第二种估计 $S_{g}(k)$，其计算基于从直接方法中得到的同一组波矢量模长 $k_m$。\n\n### 验证\n\n最后一步是在通过了统计筛选的公共分箱中心集合 $\\{k_m\\}$ 上，定量比较两种估计 $S_{\\text{DFT}}(k_m)$ 和 $S_{g}(k_m)$。一致性通过相对 $\\ell_2$ 误差来评估：\n$$\\varepsilon = \\sqrt{\\frac{\\sum_{m} \\left(S_{\\text{DFT}}(k_m) - S_{g}(k_m)\\right)^2}{\\sum_{m} \\left(S_{g}(k_m)\\right)^2}}$$\n如果此误差 $\\varepsilon$ 不超过指定的容差 $\\text{tol}$，则认为该测试用例成功（通过）。\n\n所提供的测试用例（理想气体、受扰动的晶体、硬核流体）旨在检验算法在具有不同类型结构有序度（从完全无序到准长程有序）以及在不同统计条件下的系统的正确性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and validates the static structure factor S(k) via two routes\n    for multiple test cases as specified in the problem.\n    \"\"\"\n\n    def generate_hard_core_positions(N, L, d_min, seed):\n        \"\"\"\n        Generates particle positions for a hard-core fluid using Random Sequential Addition.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        positions = np.zeros((N, 3))\n        if N == 0:\n            return positions\n        \n        positions[0] = rng.uniform(0, L, 3)\n        n_particles = 1\n        \n        max_total_attempts = N * N * 100 \n        total_attempts = 0\n\n        while n_particles  N:\n            total_attempts += 1\n            if total_attempts > max_total_attempts:\n                raise RuntimeError(\n                    f\"Failed to place all {N} particles for the hard-core case \"\n                    f\"with d_min={d_min}. The packing might be too dense for RSA.\"\n                )\n\n            trial_pos = rng.uniform(0, L, 3)\n            \n            is_valid = True\n            for i in range(n_particles):\n                dist_vec = trial_pos - positions[i]\n                # Minimum Image Convention\n                dist_vec -= L * np.round(dist_vec / L)\n                if np.linalg.norm(dist_vec)  d_min:\n                    is_valid = False\n                    break\n            \n            if is_valid:\n                positions[n_particles] = trial_pos\n                n_particles += 1\n                \n        return positions\n\n    def process_case(N, L, positions, dr, k_max, dk, min_k_count, tol):\n        \"\"\"\n        Performs the full calculation and validation for a single test case.\n        \"\"\"\n        V = L**3\n        rho_0 = N / V if L > 0 else 0\n\n        # --- Method 1: Direct DFT Calculation of S(k) ---\n        n_max = int(np.ceil(L * k_max / (2 * np.pi)))\n        n_vals = np.arange(-n_max, n_max + 1)\n        nx, ny, nz = np.meshgrid(n_vals, n_vals, n_vals, indexing='ij')\n        n_vectors = np.stack([nx.ravel(), ny.ravel(), nz.ravel()], axis=1)\n\n        n_vectors = n_vectors[np.any(n_vectors != 0, axis=1)]\n        k_vectors = (2 * np.pi / L) * n_vectors\n        k_mags = np.linalg.norm(k_vectors, axis=1)\n        \n        valid_k_indices = k_mags = k_max\n        k_vectors = k_vectors[valid_k_indices]\n        k_mags = k_mags[valid_k_indices]\n\n        if N > 0:\n            k_dot_r = positions @ k_vectors.T\n            rho_k = np.sum(np.exp(-1j * k_dot_r), axis=0)\n            S_k_values = (1/N) * np.abs(rho_k)**2\n        else:\n            S_k_values = np.zeros_like(k_mags)\n            \n        k_bins = np.arange(0, k_max + dk, dk)\n        bin_indices = np.digitize(k_mags, k_bins) - 1\n        \n        num_bins = len(k_bins) - 1\n        S_k_sum = np.bincount(bin_indices, weights=S_k_values, minlength=num_bins)\n        k_counts = np.bincount(bin_indices, minlength=num_bins)\n        \n        S_dft_vals = np.zeros_like(S_k_sum, dtype=float)\n        has_counts = k_counts > 0\n        S_dft_vals[has_counts] = S_k_sum[has_counts] / k_counts[has_counts]\n        \n        S_dft_k_centers = k_bins[:-1] + dk / 2\n\n        valid_mask = k_counts >= min_k_count\n        k_common = S_dft_k_centers[valid_mask]\n        S_dft_common = S_dft_vals[valid_mask]\n\n        if k_common.size == 0:\n            return True\n\n        # --- Method 2: S(k) via g(r) ---\n        r_max = L / 2\n        \n        if N > 1:\n            dists = []\n            for i in range(N):\n                for j in range(i + 1, N):\n                    diff = positions[i] - positions[j]\n                    diff -= L * np.round(diff / L) # MIC\n                    dists.append(np.linalg.norm(diff))\n            \n            r_bins = np.arange(0, r_max + dr, dr)\n            hist, _ = np.histogram(dists, bins=r_bins)\n            g_r_r_centers = r_bins[:-1] + dr / 2\n            \n            shell_vols = (4/3) * np.pi * (r_bins[1:]**3 - r_bins[:-1]**3)\n            ideal_gas_counts_factor = N * (N - 1) / (2 * V)\n            ideal_gas_counts = ideal_gas_counts_factor * shell_vols\n\n            g_r_vals = np.zeros_like(g_r_r_centers)\n            non_zero_ideal = ideal_gas_counts > 1e-9\n            g_r_vals[non_zero_ideal] = hist[non_zero_ideal] / ideal_gas_counts[non_zero_ideal]\n        else:\n            g_r_vals = np.array([])\n            g_r_r_centers = np.array([])\n        \n        if g_r_r_centers.size > 0:\n            kr_matrix = k_common[:, None] * g_r_r_centers[None, :]\n            j0_matrix = np.sinc(kr_matrix / np.pi)\n            integrand_matrix = (g_r_vals - 1) * (g_r_r_centers**2) * j0_matrix\n            integral_vals = np.sum(integrand_matrix, axis=1) * dr\n            S_g_common = 1 + 4 * np.pi * rho_0 * integral_vals\n        else:\n            S_g_common = np.ones_like(k_common)\n        \n        # --- Validation ---\n        denom = np.sum(S_g_common**2)\n        if denom  1e-12:\n            return np.sum(S_dft_common**2)  1e-12\n\n        numerator = np.sum((S_dft_common - S_g_common)**2)\n        error = np.sqrt(numerator / denom)\n\n        return error = tol\n\n    test_cases = [\n        # Case A: Ideal Gas\n        {'type': 'ideal_gas', 'N': 512, 'L': 10.0, 'seed': 1, 'dr': 0.05, 'k_max': 6.0, 'dk': 0.4, 'min_k_count': 5, 'tol': 0.18},\n        # Case B: Crystal\n        {'type': 'crystal', 'n_cell': 6, 'L': 12.0, 'sigma_frac': 0.05, 'seed': 2, 'dr': 0.03, 'k_max': 6.0, 'dk': 0.4, 'min_k_count': 5, 'tol': 0.28},\n        # Case C: Hard-core Fluid\n        {'type': 'hard_core', 'N': 200, 'L': 10.0, 'd_min': 0.8, 'seed': 3, 'dr': 0.05, 'k_max': 6.0, 'dk': 0.4, 'min_k_count': 5, 'tol': 0.25},\n        # Case D: Small-N Ideal Gas\n        {'type': 'ideal_gas', 'N': 64, 'L': 10.0, 'seed': 4, 'dr': 0.10, 'k_max': 6.0, 'dk': 0.5, 'min_k_count': 5, 'tol': 0.40},\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L = 0, 0\n        if case['type'] == 'ideal_gas':\n            N, L, seed = case['N'], case['L'], case['seed']\n            rng = np.random.default_rng(seed)\n            positions = rng.uniform(0, L, size=(N, 3))\n        elif case['type'] == 'crystal':\n            n_cell, L, sigma_frac, seed = case['n_cell'], case['L'], case['sigma_frac'], case['seed']\n            a = L / n_cell\n            N = n_cell**3\n            ix, iy, iz = np.meshgrid(np.arange(n_cell), np.arange(n_cell), np.arange(n_cell), indexing='ij')\n            lattice_sites = np.stack([ix.ravel(), iy.ravel(), iz.ravel()], axis=1) * a\n            rng = np.random.default_rng(seed)\n            sigma = sigma_frac * a\n            displacements = rng.normal(0, sigma, size=(N, 3))\n            positions = (lattice_sites + displacements) % L\n        elif case['type'] == 'hard_core':\n            N, L, d_min, seed = case['N'], case['L'], case['d_min'], case['seed']\n            positions = generate_hard_core_positions(N, L, d_min, seed)\n\n        validation_passed = process_case(N, L, positions, case['dr'], case['k_max'], case['dk'], case['min_k_count'], case['tol'])\n        results.append(validation_passed)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3486874"}, {"introduction": "除了简单的位置序，材料还可以表现出更精细的有序形式，例如键取向序。本练习将指导您通过分析键取向关联函数 $g_6(r)$ 的衰减行为，来识别二维系统中的不同物相——晶体、六角相和液体。这项实践引入了一种更高级的有序概念，以及一种基于关联函数衰减形式来分类物相的强大数据分析技术，这对于研究复杂流体、胶体和低维材料至关重要 [@problem_id:3486855]。", "problem": "给定一个在周期性网格上的二维局部键取向角场，角度单位为弧度。任务是计算作为间距函数的六重键取向关联，并根据其衰减形式，将基本状态分类为类晶体、类六方相或类液体。计算必须基于第一性原理和实空间中相关的定义，且不得依赖任何预先制成的表格结果。所有步骤的表述方式必须能让通用程序在不使用特定领域库的情况下实现。\n\n定义与基本原理：\n- 考虑一个维度为 $N_x \\times N_y$ 的周期性二维网格，其坐标为整数 $(x,y)$，单位网格间距。令 $\\theta(x,y)$ 表示局部键取向角场（单位为弧度），其中角度对 $2\\pi$ 取模。\n- 定义每个网格点上的六重局部复序参量为 $\\psi_6(x,y) = \\exp\\left(i \\cdot 6 \\cdot \\theta(x,y)\\right)$，其中 $i$ 是虚数单位。\n- 对于晶格位移矢量 $\\Delta \\mathbf{r}$，六重键取向两点关联函数定义为 $G_6(\\Delta \\mathbf{r}) = \\langle \\psi_6(\\mathbf{r}) \\psi_6^\\ast(\\mathbf{r} + \\Delta \\mathbf{r}) \\rangle$，其中 $\\langle \\cdot \\rangle$ 表示在周期性边界条件下对 $\\mathbf{r}$ 的空间平均，${}^\\ast$ 表示复共轭。\n- 径向关联 $g_6(r)$ 是对所有欧几里得范数约等于 $r$ 的 $\\Delta \\mathbf{r}$ 进行的壳层平均。\n- 短程有序与长程有序通过 $g_6(r)$ 如何依赖于 $r$ 来探测，其中 $r$ 以网格单位计量（无量纲）。角度必须使用弧度。\n\n程序任务：\n1. 对每个测试用例，使用指定的生成模型在周期性 $N_x \\times N_y$ 网格上构建 $\\theta(x,y)$。然后构建 $\\psi_6(x,y)$，并通过空间平均计算完整的周期性两点关联图 $G_6(\\Delta \\mathbf{r})$。执行径向壳层平均以获得 $r \\in [r_{\\min}, r_{\\max}]$ 范围内的 $g_6(r)$，其中 $r_{\\min} = 2$ 且 $r_{\\max} = \\lfloor \\min(N_x, N_y)/2 \\rfloor$。使用壳层厚度 $\\Delta r = 1$。\n2. 仅使用计算出的 $g_6(r)$，确定以下哪个衰减族最能描述其对 $r$ 的依赖关系：\n   - 相对于 $r$ 为常数（表示长程取向有序）。\n   - $r$ 的指数函数（表示短程取向有序）。\n   - $r$ 的幂律函数（表示准长程取向有序）。\n   分类必须通过在适当的变换域上使用普通最小二乘法拟合线性模型来执行，并基于残差通过定量信息准则选择最佳族。角度必须是弧度，距离是无量纲的网格单位。不提供相的外部标签；您必须仅从 $g_6(r)$ 推断类别。\n3. 对于每个测试用例，将识别出的衰减族的整数编码输出为一行中的单个列表。使用以下映射：类晶体（常数）$\\to 2$，类六方相（幂律）$\\to 1$，类液体（指数）$\\to 0$。\n\n测试套件（四个用例），所有随机抽样均使用提供的种子执行，并且所有网格操作均假定为周期性的。谱合成在指定的网格上使用离散傅里叶变换：\n- 用例 A（类晶体平台区）：\n  - 网格：$N_x = 48$，$N_y = 48$。\n  - 角场：$\\theta(x,y) = \\theta_0 + \\varepsilon(x,y)$，其中 $\\theta_0 = 0$，$\\varepsilon(x,y)$ 是独立的、均值为零、标准差 $\\sigma = 0.03$（弧度）的高斯分布。\n  - 种子：$11$。\n- 用例 B（类六方相，缓慢衰减的相关性）：\n  - 网格：$N_x = 64$，$N_y = 64$。\n  - 通过谱合成生成角场：在傅里叶空间中，对于离散网格上的每个波矢量 $\\mathbf{k} = (k_x, k_y)$，当 $\\lVert \\mathbf{k} \\rVert \\geq 1$ 时，设置复振幅包络 $A(\\mathbf{k}) = \\lVert \\mathbf{k} \\rVert^{-\\gamma}$，且 $A(\\mathbf{0}) = 0$。抽取具有独立标准正态实部和虚部的复高斯系数，乘以 $A(\\mathbf{k})$，然后应用逆离散傅里叶变换以获得实场（如果需要，取实部）。将 $\\theta(x,y)$ 的均值移至零，并将其缩放至标准差 $\\tau = 0.6$（弧度）。使用 $\\gamma = 2.5$。\n  - 种子：$7$。\n- 用例 C（类液体，短相关长度）：\n  - 网格：$N_x = 64$，$N_y = 64$。\n  - 通过具有洛伦兹谱的谱合成生成角场：在傅里葉空間中，设置 $A(\\mathbf{k}) = \\left(\\lVert \\mathbf{k} \\rVert^2 + \\kappa^2 \\right)^{-1}$，且 $A(\\mathbf{0}) = 0$。抽取具有独立标准正态实部和虚部的复高斯系数，乘以 $A(\\mathbf{k})$，然后进行逆变换以获得实场（如果需要，取实部）。将 $\\theta(x,y)$ 的均值移至零，并将其缩放至标准差 $\\tau = 1.0$（弧度）。使用 $\\kappa = 1.0$。\n  - 种子：$5$。\n- 用例 D（噪声更大的类晶体平台区）：\n  - 网格：$N_x = 48$，$N_y = 48$。\n  - 角场：$\\theta(x,y) = \\theta_0 + \\varepsilon(x,y)$，其中 $\\theta_0 = 0$，$\\varepsilon(x,y)$ 是独立的、均值为零、标准差 $\\sigma = 0.10$（弧度）的高斯分布。\n  - 种子：$19$。\n\n实现约束和细节：\n- 所有角度都必须以弧度处理。距离 $r$ 以无量纲的网格单位计量。\n- 必须全程使用周期性边界条件。\n- 为高效计算 $G_6(\\Delta \\mathbf{r})$，可使用离散卷积定理：$\\psi_6(\\mathbf{r}) \\psi_6^\\ast(\\mathbf{r} + \\Delta \\mathbf{r})$ 在 $\\mathbf{r}$ 上的空间平均是 $\\psi_6$ 的循环自相关，它可以通过对 $\\psi_6$ 的离散傅里叶变换的幅度平方进行逆离散傅里叶变换来计算。对自相关进行归一化，使其在每个位移处都等于在 $\\mathbf{r}$ 上的空间平均。\n- 径向壳层平均必须排除 $r = 0$ 的 bin，并使用厚度为 $\\Delta r = 1$ 的壳层。丢弃位移矢量贡献数少于 $50$ 的壳层。\n- 对于模型拟合，请在每个族的自然域中操作：\n  - 对于常数族，在有效 $r$ 的线性空间中将常数拟合到 $g_6(r)$。\n  - 对于指数族，在 $g_6(r)  0$ 的有效 $r$ 上，将直线拟合到 $\\ln g_6(r)$ 与 $r$ 的关系。\n  - 对于幂律族，在 $g_6(r)  0$ 的有效 $r$ 上，将直线拟合到 $\\ln g_6(r)$ 与 $\\ln r$ 的关系。\n  在每个变换域中使用普通最小二乘法。为了数值稳定性，在取对数时，可以用一个小的正数下限替换非正的 $g_6(r)$，但将这些点从拟合中排除。\n- 使用信息准则来选择最佳族。对于每个族，计算其各自拟合域中的残差平方和、拟合点数 $n$ 以及自由参数数量 $k$（常数模型 $k=1$，直线拟合 $k=2$）。在相应的域中计算赤池信息准则 $\\mathrm{AIC} = n \\cdot \\ln(\\mathrm{SSE}/n) + 2k$，并选择 $\\mathrm{AIC}$ 最小的族。约束指数族和幂律族的拟合斜率为负；如果它们的最佳拟合斜率为非负，则不得选择它们。作为稳健性检查，如果在有效 $r$ 上的 $g_6(r)$ 的相对标准差小于 $0.05$，则无论 $\\mathrm{AIC}$ 如何，都选择常数族。\n- 最终输出格式：您的程序应生成一行输出，其中包含四个测试用例（按 A, B, C, D 顺序）的整数编码族，形式为方括号内以逗号分隔的列表，例如，“[2,1,0,2]”。不应打印额外的空白或文本。\n\n角度单位要求：角度单位为弧度。输出中不出现其他物理单位。最终输出必须严格遵守上述规定，只有一行。", "solution": "该问题要求基于六重键取向关联函数 $g_6(r)$ 的衰减特性，将二维取向有序分为类晶体、类六方相或类液体相。解决方案旨在遵循第一性原理计算方法，包括三个主要阶段：角场的生成、关联函数的计算以及基于模型的相关联衰减分类。\n\n### 1. 角场 $\\theta(x,y)$ 的生成\n\n初始步骤是为每个测试用例在周期性 $N_x \\times N_y$ 网格上构建局部角场 $\\theta(x,y)$。指定了两种不同的生成模型：\n\n**a) 直接高斯噪声（类晶体用例 A 和 D）：**\n对于具有长程取向有序的状态（类晶体），角度围绕一个共同的取向微弱波动。这通过将独立同分布的高斯噪声 $\\varepsilon(x,y)$ 添加到一个恒定的基准角 $\\theta_0$ 来建模。每个位点 $(x,y)$ 的角度由下式给出：\n$$\n\\theta(x,y) = \\theta_0 + \\varepsilon(x,y)\n$$\n其中 $\\varepsilon(x,y) \\sim \\mathcal{N}(0, \\sigma^2)$ 从均值为 $0$、标准差较小为 $\\sigma$ 的正态分布中抽取。对于给定的测试用例，$\\theta_0=0$。\n\n**b) 谱合成（类六方相和类液体用例 B 和 C）：**\n对于具有更复杂关联结构的状态，我们使用谱合成。该方法通过定义其傅里叶谱来构建具有预定空间关联性的实空间场。步骤如下：\n1.  在与实空间网格对应的离散傅里叶（或 $k$）空间中，生成一个复高斯随机数网格 $Z(\\mathbf{k})$。每个 $Z(\\mathbf{k})$ 的实部和虚部都是从标准正态分布 $\\mathcal{N}(0,1)$ 中独立抽取的。\n2.  定义一个依赖于波矢量的振幅包络 $A(\\mathbf{k})$。此包络塑造了最终场的功率谱。对于用例 B（类六方相），使用幂律包络 $A(\\mathbf{k}) = \\lVert \\mathbf{k} \\rVert^{-\\gamma}$。对于用例 C（类液体），使用洛伦兹包络 $A(\\mathbf{k}) = (\\lVert \\mathbf{k} \\rVert^2 + \\kappa^2)^{-1}$。两种情况下，$A(\\mathbf{0}) = 0$。\n3.  角场的傅里叶表示 $\\hat{\\theta}(\\mathbf{k})$ 通过将噪声与包络相乘得到：$\\hat{\\theta}(\\mathbf{k}) = Z(\\mathbf{k}) \\cdot A(\\mathbf{k})$。\n4.  通过对 $\\hat{\\theta}(\\mathbf{k})$ 应用二维逆离散傅里叶变换（IDFT）并取结果的实部，得到实空间场 $\\theta(x,y)$。\n5.  最后，通过将其均值移至零并将其标准差缩放到目标值 $\\tau$ 来对场进行归一化。\n\n### 2. 关联函数 $g_6(r)$ 的计算\n\n在建立角场 $\\theta(x,y)$ 后，我们计算径向键取向关联函数 $g_6(r)$。\n\n**a) 局部序参量：**\n首先，在每个网格点上计算复数六重键取向序参量 $\\psi_6(x,y)$：\n$$\n\\psi_6(x,y) = \\exp\\left(i \\cdot 6 \\cdot \\theta(x,y)\\right)\n$$\n其中 $i$ 是虚数单位。\n\n**b) 二维自相关联函数 $G_6(\\Delta \\mathbf{r})$：**\n两点关联函数 $G_6(\\Delta \\mathbf{r}) = \\langle \\psi_6(\\mathbf{r}) \\psi_6^\\ast(\\mathbf{r} + \\Delta \\mathbf{r}) \\rangle$ 是 $\\psi_6$ 场的空间自相关。对于周期性系统，这可以使用离散卷积定理（维纳-辛钦定理的一个变体）高效地计算。自相关是功率谱密度的逆傅里叶变换：\n$$\nG_6(\\Delta \\mathbf{r}) = \\mathcal{F}^{-1}\\left[ |\\mathcal{F}[\\psi_6(\\mathbf{r})]|^2 \\right]\n$$\n这里，$\\mathcal{F}$ 和 $\\mathcal{F}^{-1}$ 分别表示二维正向和逆向离散傅里叶变换。$|\\cdot|^2$ 操作给出功率谱。需要通过网格点总数 $N_x N_y$ 进行归一化，以匹配空间平均 $\\langle \\cdot \\rangle$ 的定义。\n\n**c) 径向平均以获得 $g_6(r)$：**\n通过壳层平均将二维关联图 $G_6(\\Delta \\mathbf{r})$ 简化为一维径向函数 $g_6(r)$。\n1.  计算以 $\\Delta \\mathbf{r} = (0,0)$ 为中心的位移矢量大小 $r = \\lVert \\Delta \\mathbf{r} \\rVert$ 的网格。\n2.  根据对应的距离 $r$ 对关联值 $G_6(\\Delta \\mathbf{r})$ 进行分箱（binning）。我们使用厚度为 $\\Delta r = 1$ 的壳层，因此第 $j$ 个箱对应于距离 $r \\in [j, j+1)$。\n3.  对于给定的壳层（由其整数半径 $j$ 表示），$g_6(r)$ 的值是落入该壳层内的所有 $G_6(\\Delta \\mathbf{r})$ 值的平均值。\n4.  分析在 $r$ 从 $r_{\\min}=2$ 到 $r_{\\max} = \\lfloor \\min(N_x, N_y)/2 \\rfloor$ 的范围内进行。包含少于 $50$ 个数据点的壳层被丢弃以确保统计稳健性。\n\n### 3. 衰减形式的分类\n\n最后阶段是分类计算出的 $g_6(r)$ 的衰减，以确定系统的相。这是一个模型选择问题。\n\n**a) 候选模型：**\n三种候选衰减形式对应于三种相：\n1.  **类晶体（常数）：** $g_6(r) \\approx C$。长程取向有序。\n2.  **类液体（指数）：** $g_6(r) \\propto \\exp(-r/\\xi)$。短程有序，关联长度为 $\\xi$。\n3.  **类六方相（幂律）：** $g_6(r) \\propto r^{-\\eta_6}$。准长程有序。\n\n**b) 通过线性化进行模型拟合：**\n在关系为线性的域中，使用普通最小二乘（OLS）回归将每个模型拟合到数据 $(r, g_6(r))$：\n-   **常数：** 将 $y=C$ 拟合到 $y=g_6(r)$。最佳拟合是均值，$C = \\langle g_6(r) \\rangle$。\n-   **指数：** 将直线 $y = mx+c$ 拟合到变换后的数据 $y = \\ln g_6(r)$ 和 $x=r$。\n-   **幂律：** 将直线 $y = mx+c$ 拟合到变换后的数据 $y = \\ln g_6(r)$ 和 $x=\\ln r$。\n\n对于指数和幂律拟合，仅使用 $g_6(r) > 0$ 的点。此外，施加了一个物理约束：拟合的斜率 $m$ 必须为负，因为关联不能随距离增加。斜率非负的模型被视为无效。\n\n**c) 使用 AIC 进行模型选择：**\n使用赤池信息准则（AIC）来定量选择最佳模型。对于每个拟合模型，AIC 计算如下：\n$$\n\\mathrm{AIC} = n \\cdot \\ln\\left(\\frac{\\mathrm{SSE}}{n}\\right) + 2k\n$$\n其中 $n$ 是拟合中使用的数据点数，$k$ 是模型中的自由参数数量（常数模型为 $k=1$，线性拟合为 $k=2$），$\\mathrm{SSE}$ 是在其各自变换域中拟合的误差（残差）平方和。选择 AIC最低的模型作为对数据最合理的描述。应用一个初步的稳健性检查：如果 $g_6(r)$ 的相对标准差小于 $0.05$，则直接选择常数模型。\n\n最后，将所选模型映射到一个整数代码：常数（类晶体）$\\to 2$，幂律（类六方相）$\\to 1$，指数（类液体）$\\to 0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print the results.\n    \"\"\"\n\n    def linear_regression(x, y):\n        \"\"\"\n        Performs a simple Ordinary Least Squares regression.\n        Returns: slope, intercept, Sum of Squared Errors (SSE), and number of points.\n        \"\"\"\n        n = x.size\n        # A model with 2 parameters (slope, intercept) needs at least 2 points.\n        if n  2:\n            return np.nan, np.nan, np.inf, n\n\n        x_mean, y_mean = np.mean(x), np.mean(y)\n        S_xy = np.sum((x - x_mean) * (y - y_mean))\n        S_xx = np.sum((x - x_mean)**2)\n\n        # If all x values are identical, slope is undefined.\n        if S_xx  1e-12:\n            return np.nan, np.nan, np.inf, n\n\n        m = S_xy / S_xx\n        c = y_mean - m * x_mean\n        y_pred = m * x + c\n        sse = np.sum((y - y_pred)**2)\n        return m, c, sse, n\n\n    def generate_angles_gaussian(Nx, Ny, sigma, seed):\n        \"\"\"\n        Generates an angle field with white Gaussian noise.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        theta = rng.normal(loc=0.0, scale=sigma, size=(Ny, Nx))\n        return theta\n\n    def generate_angles_spectral(Nx, Ny, kernel_func, tau, seed):\n        \"\"\"\n        Generates an angle field using spectral synthesis.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        noise_k = rng.standard_normal((Ny, Nx)) + 1j * rng.standard_normal((Ny, Nx))\n\n        kx = np.fft.fftfreq(Nx) * Nx\n        ky = np.fft.fftfreq(Ny) * Ny\n        ky_grid, kx_grid = np.meshgrid(ky, kx, indexing='ij')\n        k_norm = np.sqrt(kx_grid**2 + ky_grid**2)\n\n        A_k = kernel_func(k_norm)\n        A_k[0, 0] = 0.0\n\n        theta_k = noise_k * A_k\n        theta_real = np.real(np.fft.ifft2(theta_k))\n\n        theta_real -= np.mean(theta_real)\n        std_dev = np.std(theta_real)\n        if std_dev > 1e-9:\n            theta_real *= (tau / std_dev)\n        return theta_real\n\n    def compute_g6(theta):\n        \"\"\"\n        Computes the radial correlation function g6(r) from the angle field.\n        \"\"\"\n        Ny, Nx = theta.shape\n        psi6 = np.exp(1j * 6 * theta)\n\n        psi6_k = np.fft.fft2(psi6)\n        power_spectrum = np.abs(psi6_k)**2\n        autocorr_map = np.real(np.fft.ifft2(power_spectrum)) / (Nx * Ny)\n        G6_map = np.fft.fftshift(autocorr_map)\n\n        r_min = 2\n        r_max = int(np.floor(min(Nx, Ny) / 2))\n\n        dx = np.fft.fftshift(np.fft.fftfreq(Nx) * Nx)\n        dy = np.fft.fftshift(np.fft.fftfreq(Ny) * Ny)\n        dy_grid, dx_grid = np.meshgrid(dy, dx, indexing='ij')\n        dist_grid = np.sqrt(dx_grid**2 + dy_grid**2)\n\n        r_vals, g6_vals = [], []\n        for r_int in range(r_min, r_max + 1):\n            mask = (dist_grid >= r_int)  (dist_grid  r_int + 1)\n            if np.sum(mask) >= 50:\n                shell_avg = np.mean(G6_map[mask])\n                # Use midpoint of the shell for the radial coordinate\n                r_vals.append(r_int + 0.5)\n                g6_vals.append(shell_avg)\n\n        return np.array(r_vals), np.array(g6_vals)\n\n    def classify_decay(r, g6):\n        \"\"\"\n        Classifies the decay form of g6(r) using model fitting and AIC.\n        Returns integer code: 2 (crystal), 1 (hexatic), 0 (liquid).\n        \"\"\"\n        if r.size  2:\n            return 0  # Default to liquid-like if not enough data points\n\n        g6_mean = np.mean(g6)\n        if g6_mean != 0:\n            rel_std_dev = np.std(g6) / np.abs(g6_mean)\n            if rel_std_dev  0.05:\n                return 2  # Crystal-like by robustness check\n\n        aics = {}\n        \n        # Model 2: Constant (crystal-like)\n        n_const = g6.size\n        k_const = 1\n        sse_const = np.sum((g6 - g6_mean)**2)\n        if sse_const = 1e-12:\n            aics[2] = -np.inf\n        else:\n            aics[2] = n_const * np.log(sse_const / n_const) + 2 * k_const\n        \n        # Filter data for log-based fits\n        pos_mask = g6 > 1e-12\n        r_pos, g6_pos = r[pos_mask], g6[pos_mask]\n\n        if r_pos.size > 0:\n            # Model 0: Exponential (liquid-like)\n            m_exp, _, sse_exp, n_exp = linear_regression(r_pos, np.log(g6_pos))\n            k_exp = 2\n            if n_exp >= k_exp and m_exp  0:\n                if sse_exp = 1e-12:\n                    aics[0] = -np.inf\n                else:\n                    aics[0] = n_exp * np.log(sse_exp / n_exp) + 2 * k_exp\n            else:\n                aics[0] = np.inf\n\n            # Model 1: Power-law (hexatic-like)\n            m_pow, _, sse_pow, n_pow = linear_regression(np.log(r_pos), np.log(g6_pos))\n            k_pow = 2\n            if n_pow >= k_pow and m_pow  0:\n                if sse_pow = 1e-12:\n                    aics[1] = -np.inf\n                else:\n                    aics[1] = n_pow * np.log(sse_pow / n_pow) + 2 * k_pow\n            else:\n                aics[1] = np.inf\n        else: # No positive g6 values\n            aics[0] = np.inf\n            aics[1] = np.inf\n\n        if not aics or all(v == np.inf for v in aics.values()):\n            return 0  # Default if no model is valid\n\n        best_class = min(aics, key=aics.get)\n        return best_class\n\n    test_cases = [\n        # Case A: Crystal-like\n        {'type': 'gaussian', 'Nx': 48, 'Ny': 48, 'params': {'sigma': 0.03, 'seed': 11}},\n        # Case B: Hexatic-like\n        {'type': 'spectral', 'Nx': 64, 'Ny': 64, 'params': {'gamma': 2.5, 'tau': 0.6, 'seed': 7}},\n        # Case C: Liquid-like\n        {'type': 'spectral', 'Nx': 64, 'Ny': 64, 'params': {'kappa': 1.0, 'tau': 1.0, 'seed': 5}},\n        # Case D: Noisier crystal\n        {'type': 'gaussian', 'Nx': 48, 'Ny': 48, 'params': {'sigma': 0.10, 'seed': 19}},\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case['Nx'], case['Ny']\n        params = case['params']\n        \n        if case['type'] == 'gaussian':\n            theta = generate_angles_gaussian(Nx, Ny, params['sigma'], params['seed'])\n        else: # case['type'] == 'spectral'\n            if 'gamma' in params:\n                gamma = params['gamma']\n                kernel = lambda k: np.power(k, -gamma, where=k != 0, out=np.zeros_like(k, dtype=float))\n            else: # 'kappa' in params\n                kappa = params['kappa']\n                kernel = lambda k: 1.0 / (k**2 + kappa**2)\n            theta = generate_angles_spectral(Nx, Ny, kernel, params['tau'], params['seed'])\n        \n        r, g6 = compute_g6(theta)\n        classification = classify_decay(r, g6)\n        results.append(classification)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3486855"}, {"introduction": "在计算机模拟中，区分真正的长程序与有限尺寸效应是一个关键挑战。本实践介绍有限尺寸标度，这是一个强大的理论和计算框架，用于分析相变并从有限系统数据中提取普适性质。通过对合成数据进行数据坍缩分析，您将学习如何识别临界点、确定临界指数，并理解小系统中的短程关联如何使尖锐的相变变得圆滑 [@problem_id:3486915]。", "problem": "你的任务是设计并评估一种在临界温度附近对热力学可观测量进行有限尺寸标度分析的方法。你的程序必须从有限尺寸标度假设和基本统计定义的第一性原理出发，实现以下功能。核心计算任务是：(i) 针对一系列系统尺寸和温度，为序参量和磁化率生成类似蒙特卡洛的合成数据；(ii) 使用指定的临界参数估计值进行标度坍缩；(iii) 通过归一化方差度量来量化坍缩的质量；(iv) 通过基于相关长度的准则来量化短程有序在小系统尺寸下占主导地位的程度。\n\n基本定义与假设：\n- 对于一个标量序参量 $m$ 和磁化率 $\\chi$，在临界温度 $T_c$ 附近的有限尺寸标度假设假定存在标度不变形式，这些形式用标度变量 $u$ 表示，其定义为\n$$u = (T - T_c)\\,L^{1/\\nu},$$\n以及标度律\n$$m(L,T) = L^{-\\beta/\\nu}\\,f_m(u), \\quad \\chi(L,T) = L^{\\gamma/\\nu}\\,f_\\chi(u),$$\n其中 $L$ 是线性系统尺寸，$T$ 是温度，$\\beta$、$\\nu$ 和 $\\gamma$ 是临界指数，$f_m$ 和 $f_\\chi$ 是标度函数。\n- 在有限系统中，短程有序 (SRO) 与长程有序 (LRO) 可以通过相关长度 $\\xi(T)$ 来评估，假设其遵循发散关系 $\\xi(T)=\\xi_0\\,|t|^{-\\nu}$，其中约化温度 $t=(T-T_c)/T_c$。实际上，这种发散受到有限系统范围的限制。当 $\\xi(T)$ 占 $L$ 的很大一部分时，有限尺寸的修约效应可能会掩盖真实 LRO 的缺失。我们通过条件 $\\xi(T)  r_0\\,L$ 来操作化地定义在系统尺寸 $L$ 下的“SRO主导”，其中 $r_0$ 是一个预设的阈值比率。\n\n合成数据模型：\n- 为专注于算法方面，你将生成与标度假设一致的合成可观测量。对于每个系统尺寸 $L$ 和温度 $T$，定义无量纲标度变量 $u=(T-T_c^{\\text{true}})\\,L^{1/\\nu^{\\text{true}}}$。使用以下平滑、正值的标度函数：\n$$f_m(u)=\\frac{A_m}{1+\\exp\\!\\left(\\frac{u}{w_m}\\right)}, \\qquad f_\\chi(u)=\\frac{A_\\chi}{1+\\left(\\frac{u}{w_\\chi}\\right)^2}.$$\n然后生成带噪声的合成可观测量\n$$m(L,T)=L^{-\\beta^{\\text{true}}/\\nu^{\\text{true}}}\\,f_m(u)+\\epsilon_m, \\qquad \\chi(L,T)=L^{\\gamma^{\\text{true}}/\\nu^{\\text{true}}}\\,f_\\chi(u)+\\epsilon_\\chi,$$\n其中 $\\epsilon_m$ 和 $\\epsilon_\\chi$ 是独立的、均值为零的高斯噪声项，其标准差分别等于 $\\sigma_m \\times \\left(L^{-\\beta^{\\text{true}}/\\nu^{\\text{true}}}\\,f_m(u)\\right)$ 和 $\\sigma_\\chi \\times \\left(L^{\\gamma^{\\text{true}}/\\nu^{\\text{true}}}\\,f_\\chi(u)\\right)$。由噪声产生的任何负值都必须被截断为 $0$。\n- 使用 $A_m=A_\\chi=1$，$w_m=w_\\chi=2$，以及由固定伪随机数生成器播种的独立标准正态偏离值，以确保可复现性。\n\n标度坍缩程序：\n- 给定估计参数 $T_c^{\\text{est}}$、$\\beta^{\\text{est}}$、$\\nu^{\\text{est}}$ 和 $\\gamma^{\\text{est}}$，定义标度化变量\n$$x=(T-T_c^{\\text{est}})\\,L^{1/\\nu^{\\text{est}}}, \\quad y_m = m(L,T)\\,L^{\\beta^{\\text{est}}/\\nu^{\\text{est}}}, \\quad y_\\chi = \\chi(L,T)\\,L^{-\\gamma^{\\text{est}}/\\nu^{\\text{est}}}.$$\n- 对于给定的 $L$ 值集合，在所有曲线的 $x$ 范围的重叠区域内，构建一个包含 $K$ 个在 $x$ 上等间距点的公共网格。使用 $K=50$。\n- 对于每个 $L$，使用线性插值将 $y_m$ 和 $y_\\chi$ 插值到公共 $x$ 网格上。\n- 将每个可观测量的坍缩质量度量定义为跨尺寸的归一化均方偏差：\n$$Q(y)=\\frac{\\sum_{k=1}^{K}\\sum_{i=1}^{N_L}\\left(y_i(x_k)-\\overline{y}(x_k)\\right)^2}{\\sum_{k=1}^{K}\\sum_{i=1}^{N_L}\\overline{y}(x_k)^2+\\varepsilon},$$\n其中 $N_L$ 是系统尺寸的数量，$\\overline{y}(x_k)$ 是在网格点 $x_k$ 处对所有尺寸的算术平均值，$\\varepsilon=10^{-12}$ 用于防止除以零。计算 $Q_m=Q(y_m)$ 和 $Q_\\chi=Q(y_\\chi)$。较小的 $Q$ 值表示更好的坍缩。\n\nSRO 主导度量：\n- 对于集合中最小的系统尺寸 $L_{\\min}$，计算相关长度\n$$\\xi(T)=\\xi_0\\,|t|^{-\\nu^{\\text{true}}}, \\quad t=\\frac{T-T_c^{\\text{true}}}{T_c^{\\text{true}}},$$\n使用下限 $|t|\\leftarrow \\max(|t|,t_{\\min})$，其中 $t_{\\min}=10^{-12}$，以避免在 $t=0$ 处发散。\n- SRO掩蔽分数是指在抽样温度列表中，满足条件 $\\xi(T)r_0\\,L_{\\min}$ 的温度所占的比例。以 $[0,1]$ 范围的小数形式报告此值。\n\n测试套件：\n针对以下三个测试用例实现上述内容。对于所有用例，使用相同的温度网格，该网格包含 $N_T=81$ 个点，从 $T_c^{\\text{true}}-\\Delta T$ 到 $T_c^{\\text{true}}+\\Delta T$（包含两端）线性间隔，其中 $\\Delta T=0.4$。对于噪声，使用 $\\sigma_m=\\sigma_\\chi=0.02$，并用种子 $12345$ 初始化伪随机数生成器以抽取独立标准正态样本。对于SRO准则，使用 $\\xi_0=0.5, r_0=0.5$。以下所有常数必须完全按照规定使用。\n\n- 用例A（理想路径，预期良好坍缩）：\n  - 真实参数：$T_c^{\\text{true}}=2.269185$, $\\beta^{\\text{true}}=0.125$, $\\nu^{\\text{true}}=1.0$, $\\gamma^{\\text{true}}=1.75$。\n  - 估计参数：$T_c^{\\text{est}}=2.269185$, $\\beta^{\\text{est}}=0.125$, $\\nu^{\\text{est}}=1.0$, $\\gamma^{\\text{est}}=1.75$。\n  - 系统尺寸：$L\\in\\{16,32,64\\}$。\n\n- 用例B（边界情况，小尺寸；预期在最小的 $L$ 上SRO占主导）：\n  - 真实参数：$T_c^{\\text{true}}=2.269185$, $\\beta^{\\text{true}}=0.125$, $\\nu^{\\text{true}}=1.0$, $\\gamma^{\\text{true}}=1.75$。\n  - 估计参数：$T_c^{\\text{est}}=2.269185$, $\\beta^{\\text{est}}=0.125$, $\\nu^{\\text{est}}=1.0$, $\\gamma^{\\text{est}}=1.75$。\n  - 系统尺寸：$L\\in\\{8,12,16\\}$。\n\n- 用例C（边缘情况，临界参数指定错误；预期坍缩效果差）：\n  - 真实参数：$T_c^{\\text{true}}=2.269185$, $\\beta^{\\text{true}}=0.125$, $\\nu^{\\text{true}}=1.0$, $\\gamma^{\\text{true}}=1.75$。\n  - 估计参数：$T_c^{\\text{est}}=2.24$, $\\beta^{\\text{est}}=0.14$, $\\nu^{\\text{est}}=0.9$, $\\gamma^{\\text{est}}=1.6$。\n  - 系统尺寸：$L\\in\\{24,48,96\\}$。\n\n不涉及角度单位。输出不需要物理单位。\n\n必需输出：\n- 对于每个用例，计算并返回三元组 $\\left[Q_m,Q_\\chi,\\phi_{\\text{SRO}}\\right]$，其中 $\\phi_{\\text{SRO}}$ 是该用例中最小 $L$ 的SRO掩蔽分数。\n- 你的程序应生成单行输出，包含所有三个三元组，它们被展平为一个包含9个浮点数的列表，每个值四舍五入到6位小数，顺序如下：$\\left[Q_m^{(A)},Q_\\chi^{(A)},\\phi_{\\text{SRO}}^{(A)},Q_m^{(B)},Q_\\chi^{(B)},\\phi_{\\text{SRO}}^{(B)},Q_m^{(C)},Q_\\chi^{(C)},\\phi_{\\text{SRO}}^{(C)}\\right]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $\\left[\\text{result1},\\text{result2},\\ldots,\\text{result9}\\right]$。", "solution": "用户提供了一个基于计算统计物理学原理的问题，特别是临界现象和有限尺寸标度理论。问题陈述科学上合理，内容自洽，且算法上定义明确。所有必要的参数、方程和程序都已指定，从而可以得到一个唯一且可验证的解。因此，该问题被认为是有效的，下面提供了完整的解决方案。\n\n核心任务是实现并测试一个有限尺寸标度分析流程。这涉及三个主要阶段：生成模拟临界点附近可观测量的合成数据，对这些数据进行标度坍缩，并定量评估坍缩的质量。一个次要分析是量化短程有序效应对小系统尺寸的主导作用。\n\n### 1. 合成数据生成\n\n该分析的基础是有限尺寸标度假设，它描述了对于有限线性尺寸为 $L$ 的系统，热力学量在临界温度 $T_c$ 附近的行为。对于标量序参量 $m$ 及其对应的磁化率 $\\chi$，该假设假定：\n$$m(L,T) = L^{-\\beta/\\nu}\\,f_m(u)$$\n$$\\chi(L,T) = L^{\\gamma/\\nu}\\,f_\\chi(u)$$\n其中 $\\beta$、$\\gamma$ 和 $\\nu$ 是普适临界指数，$f_m$ 和 $f_\\chi$ 是标度变量 $u = (T - T_c)\\,L^{1/\\nu}$ 的普适标度函数。\n\n为了测试我们的分析算法，我们首先生成在构造上就遵循这些标度律的合成数据。我们使用一组“真实”参数（$T_c^{\\text{true}}$, $\\beta^{\\text{true}}$, $\\nu^{\\text{true}}$, $\\gamma^{\\text{true}}$）和标度函数的特定形式：\n$$f_m(u)=\\frac{A_m}{1+\\exp(u/w_m)}, \\quad f_\\chi(u)=\\frac{A_\\chi}{1+(u/w_\\chi)^2}$$\n其中常数 $A_m=1$, $A_\\chi=1$, $w_m=2$, $w_\\chi=2$。\n\n对于每一对系统尺寸 $L$ 和温度 $T$，我们首先计算理想的、无噪声的可观测量。然后，我们引入随机性来模拟蒙特卡洛模拟中固有的统计涨落。这通过添加高斯噪声来实现，其中噪声的标准差与可观测量本身的大小成正比，相对噪声水平为 $\\sigma_m=0.02$ 和 $\\sigma_\\chi=0.02$。带噪声的可观测量为：\n$$m(L,T) = L^{-\\beta^{\\text{true}}/\\nu^{\\text{true}}}\\,f_m(u) + \\epsilon_m$$\n$$\\chi(L,T) = L^{\\gamma^{\\text{true}}/\\nu^{\\text{true}}}\\,f_\\chi(u) + \\epsilon_\\chi$$\n这里，$\\epsilon_m$ 和 $\\epsilon_\\chi$ 从均值为 $0$、标准差与理想值成比例的高斯分布中抽取。对于 $m$ 或 $\\chi$ 这类物理量，任何由此产生的负值都是无意义的，因此被截断为 $0$。使用固定种子的伪随机数生成器确保了可复现性。\n\n### 2. 标度坍缩与质量度量\n\n有限尺寸标度分析的核心目标是将来自不同系统尺寸 $L$ 的数据“坍缩”到一条单一的普适曲线上。这是通过使用一组*估计*的参数（$T_c^{\\text{est}}$, $\\beta^{\\text{est}}$, $\\nu^{\\text{est}}$, $\\gamma^{\\text{est}}$）来反转标度关系实现的。我们定义标度化变量：\n$$x=(T-T_c^{\\text{est}})\\,L^{1/\\nu^{\\text{est}}}$$\n$$y_m = m(L,T)\\,L^{\\beta^{\\text{est}}/\\nu^{\\text{est}}}$$\n$$y_\\chi = \\chi(L,T)\\,L^{-\\gamma^{\\text{est}}/\\nu^{\\text{est}}}$$\n如果估计的参数与真实的潜在参数相匹配，那么对于所有不同的尺寸 $L$，$y_m$ 对 $x$（以及 $y_\\chi$ 对 $x$）的曲线图应该重叠，分别形成主曲线 $f_m(x)$ 和 $f_\\chi(x)$。\n\n为了定量评估这种坍缩的质量，我们遵循一个数值程序。首先，由于不同 $L$ 的数据点不共享公共的 $x$ 坐标，我们建立一个公共网格。该网格由 $K=50$ 个点组成，在所有系统尺寸共有的 $x$ 值范围内线性间隔。然后，我们使用线性插值来获取每个 $L$ 在这个公共网格上的 $y_m$ 和 $y_\\chi$ 值。\n\n在将数据插值到公共基准上之后，我们可以计算一个质量因子 $Q$。该度量被定义为各个曲线与其均值的归一化均方偏差：\n$$Q(y)=\\frac{\\sum_{k=1}^{K}\\sum_{i=1}^{N_L}\\left(y_i(x_k)-\\overline{y}(x_k)\\right)^2}{\\sum_{k=1}^{K}\\sum_{i=1}^{N_L}\\overline{y}(x_k)^2+\\varepsilon}$$\n其中 $y_i(x_k)$ 是第 $i$ 个系统尺寸在第 $k$ 个网格点上的插值，$ \\overline{y}(x_k)$ 是在该网格点上对所有 $N_L$ 个系统尺寸的平均值，而 $\\varepsilon=10^{-12}$ 是一个小的正则化项。一个小的 $Q$ 值表示一次好的坍缩，表明估计的参数可能接近真实值。我们为序参量（$Q_m$）和磁化率（$Q_\\chi$）都计算这个度量。\n\n### 3. 短程有序 (SRO) 主导\n\n在无限系统中，相关长度 $\\xi(T)$ 在临界点 $T_c$ 处根据 $\\xi(T) = \\xi_0\\,|t|^{-\\nu}$ 发散，其中 $t = (T-T_c)/T_c$ 是约化温度。在尺寸为 $L$ 的有限系统中，相关性不能超出系统的边界。当理论相关长度 $\\xi(T)$ 变得与 $L$ 相当或更大时，系统的行为就由其有限范围决定。这种“有限尺寸修约”会模糊真实的临界行为，并模仿有序，即使真正的长程有序尚未建立。这个区域可以被描述为由短程有序 (SRO) 主导。\n\n我们对给定集合中最小系统尺寸 $L_{\\min}$ 的这种效应的普遍性进行量化。我们定义，如果在温度 $T$ 下满足条件 $\\xi(T)  r_0\\,L_{\\min}$，则发生“SRO 主导”，其中使用提供的参数 $\\xi_0=0.5$ 和 $r_0=0.5$。然后，SRO掩蔽分数 $\\phi_{\\text{SRO}}$ 被计算为满足此条件的模拟温度所占的比例。为避免在 $T=T_c$ 处出现奇异点，在计算 $\\xi(T)$ 时，约化温度 $|t|$ 被赋予一个数值下限 $t_{\\min}=10^{-12}$。较高的 $\\phi_{\\text{SRO}}$ 表示，在 $T_c$ 附近的很大一部分温度范围内，最小系统尺寸的物理特性由有限尺寸效应主导，而非真实的临界标度行为。\n\n### 4. 测试用例的实现\n\n所描述的程序被应用于三个不同的测试用例。\n- **用例A**作为一个基准，其中用于坍缩的估计参数与用于数据生成的真实参数相同。预期会得到高质量的坍缩（低的 $Q$ 值）。\n- **用例B**使用正确的参数，但侧重于更小的系统尺寸。预期这将显示出良好的坍缩，但同时也有更高的SRO掩蔽分数，从而证明了在较小的模拟中有限尺寸效应的重要性增加。\n- **用例C**使用故意错误的估计参数。这预期将导致数据坍缩效果差，从而产生大的 $Q$ 值，证明该方法对临界参数选择的敏感性。\n\n对于每个用例，算法计算三元组 $[Q_m, Q_\\chi, \\phi_{\\text{SRO}}]$，最终输出是所有三个用例的这些结果的展平列表。", "answer": "```python\nimport numpy as np\n\ndef _generate_synthetic_data(L_list, T_grid, true_params, noise_params, rng):\n    \"\"\"Generates synthetic data for m and chi based on scaling laws.\"\"\"\n    data = {'m': {}, 'chi': {}}\n    \n    A_m, w_m = 1.0, 2.0\n    A_chi, w_chi = 1.0, 2.0\n    \n    Tc_true = true_params['Tc']\n    beta_true = true_params['beta']\n    nu_true = true_params['nu']\n    gamma_true = true_params['gamma']\n    \n    sigma_m_rel = noise_params['sigma_m']\n    sigma_chi_rel = noise_params['sigma_chi']\n\n    for L in L_list:\n        u = (T_grid - Tc_true) * (L**(1.0 / nu_true))\n        \n        f_m_u = A_m / (1.0 + np.exp(u / w_m))\n        f_chi_u = A_chi / (1.0 + (u / w_chi)**2)\n        \n        m_true = (L**(-beta_true / nu_true)) * f_m_u\n        chi_true = (L**(gamma_true / nu_true)) * f_chi_u\n        \n        noise_m_std = sigma_m_rel * m_true\n        noise_chi_std = sigma_chi_rel * chi_true\n        \n        epsilon_m = rng.normal(loc=0.0, scale=noise_m_std)\n        epsilon_chi = rng.normal(loc=0.0, scale=noise_chi_std)\n        \n        m_noisy = m_true + epsilon_m\n        chi_noisy = chi_true + epsilon_chi\n        \n        # Clip to 0 for non-physical negative values\n        data['m'][L] = np.maximum(0, m_noisy)\n        data['chi'][L] = np.maximum(0, chi_noisy)\n        \n    return data\n\ndef _calculate_collapse_quality(data_obs, L_list, T_grid, est_params, K=50, epsilon=1e-12):\n    \"\"\"Performs scaling collapse and computes the quality metric Q.\"\"\"\n    \n    Tc_est = est_params['Tc']\n    beta_est = est_params['beta']\n    nu_est = est_params['nu']\n    gamma_est = est_params['gamma']\n    \n    scaled_curves_m = {}\n    scaled_curves_chi = {}\n    x_ranges = []\n\n    for L in L_list:\n        m_L = data_obs['m'][L]\n        chi_L = data_obs['chi'][L]\n        \n        x = (T_grid - Tc_est) * (L**(1.0 / nu_est))\n        y_m = m_L * (L**(beta_est / nu_est))\n        y_chi = chi_L * (L**(-gamma_est / nu_est))\n        \n        scaled_curves_m[L] = {'x': x, 'y': y_m}\n        scaled_curves_chi[L] = {'x': x, 'y': y_chi}\n        x_ranges.append((np.min(x), np.max(x)))\n        \n    # Find common x range for interpolation\n    x_min_common = max(r[0] for r in x_ranges)\n    x_max_common = min(r[1] for r in x_ranges)\n    x_common_grid = np.linspace(x_min_common, x_max_common, K)\n    \n    # Calculate Q for order parameter m\n    N_L = len(L_list)\n    y_m_interp = np.zeros((N_L, K))\n    for i, L in enumerate(L_list):\n        y_m_interp[i, :] = np.interp(x_common_grid, scaled_curves_m[L]['x'], scaled_curves_m[L]['y'])\n    \n    y_m_mean = np.mean(y_m_interp, axis=0)\n    num_m = np.sum((y_m_interp - y_m_mean)**2)\n    den_m = N_L * np.sum(y_m_mean**2) + epsilon\n    Qm = num_m / den_m\n    \n    # Calculate Q for susceptibility chi\n    y_chi_interp = np.zeros((N_L, K))\n    for i, L in enumerate(L_list):\n        y_chi_interp[i, :] = np.interp(x_common_grid, scaled_curves_chi[L]['x'], scaled_curves_chi[L]['y'])\n        \n    y_chi_mean = np.mean(y_chi_interp, axis=0)\n    num_chi = np.sum((y_chi_interp - y_chi_mean)**2)\n    den_chi = N_L * np.sum(y_chi_mean**2) + epsilon\n    Qchi = num_chi / den_chi\n\n    return Qm, Qchi\n\ndef _calculate_sro_fraction(L_min, T_grid, true_params, sro_params):\n    \"\"\"Calculates the SRO-masking fraction for the smallest system size.\"\"\"\n    \n    Tc_true = true_params['Tc']\n    nu_true = true_params['nu']\n    \n    xi_0 = sro_params['xi_0']\n    r_0 = sro_params['r_0']\n    t_min = sro_params['t_min']\n    \n    t = (T_grid - Tc_true) / Tc_true\n    t_abs_floored = np.maximum(np.abs(t), t_min)\n    \n    xi_T = xi_0 * (t_abs_floored**(-nu_true))\n    \n    sro_dominant_count = np.sum(xi_T > r_0 * L_min)\n    \n    sro_fraction = sro_dominant_count / len(T_grid)\n    \n    return sro_fraction\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the finite-size scaling analysis for all test cases.\n    \"\"\"\n    \n    # Define test cases\n    test_cases = [\n        # Case A\n        {\n            \"true_params\": {'Tc': 2.269185, 'beta': 0.125, 'nu': 1.0, 'gamma': 1.75},\n            \"est_params\": {'Tc': 2.269185, 'beta': 0.125, 'nu': 1.0, 'gamma': 1.75},\n            \"L_list\": [16, 32, 64]\n        },\n        # Case B\n        {\n            \"true_params\": {'Tc': 2.269185, 'beta': 0.125, 'nu': 1.0, 'gamma': 1.75},\n            \"est_params\": {'Tc': 2.269185, 'beta': 0.125, 'nu': 1.0, 'gamma': 1.75},\n            \"L_list\": [8, 12, 16]\n        },\n        # Case C\n        {\n            \"true_params\": {'Tc': 2.269185, 'beta': 0.125, 'nu': 1.0, 'gamma': 1.75},\n            \"est_params\": {'Tc': 2.24, 'beta': 0.14, 'nu': 0.9, 'gamma': 1.6},\n            \"L_list\": [24, 48, 96]\n        }\n    ]\n\n    # Global parameters\n    NT = 81\n    delta_T = 0.4\n    noise_params = {'sigma_m': 0.02, 'sigma_chi': 0.02}\n    sro_params = {'xi_0': 0.5, 'r_0': 0.5, 't_min': 1e-12}\n    K = 50\n    rng = np.random.default_rng(12345)\n    \n    results = []\n\n    for case in test_cases:\n        true_params = case[\"true_params\"]\n        est_params = case[\"est_params\"]\n        L_list = case[\"L_list\"]\n        L_min = min(L_list)\n        \n        # Temperature grid is centered on the true critical temperature\n        T_grid = np.linspace(true_params['Tc'] - delta_T, true_params['Tc'] + delta_T, NT)\n        \n        # Generate synthetic data\n        data = _generate_synthetic_data(L_list, T_grid, true_params, noise_params, rng)\n        \n        # Calculate collapse quality\n        Qm, Qchi = _calculate_collapse_quality(data, L_list, T_grid, est_params, K=K)\n        \n        # Calculate SRO fraction\n        sro_frac = _calculate_sro_fraction(L_min, T_grid, true_params, sro_params)\n        \n        results.extend([Qm, Qchi, sro_frac])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3486915"}]}