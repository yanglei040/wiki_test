{"hands_on_practices": [{"introduction": "在分子动力学模拟中，周期性边界条件（PBC）是模拟无限大块体材料的有效工具。然而，在模拟位移级联等局部高能事件时，必须小心设置模拟盒子尺寸，以防止级联区域与其周期性镜像发生非物理的相互作用。这个练习将指导你通过一个简化的物理模型，结合弹道阶段和热峰阶段的特征，来推导并计算避免有限尺寸效应所需的最小模拟盒子长度 $L_{\\min}$ [@problem_id:3484027]，这是确保级联模拟结果可靠性的关键一步。", "problem": "在晶体固体中，使用周期性边界条件 (PBC) 进行了一次位移级联的分子动力学模拟。为了避免级联与其周期性镜像之间的伪相互作用，模拟单元必须足够大，以确保在整个事件期间，级联引起的原子重新分布区域不会与其最近的周期性镜像的相应区域重叠。考虑以下基于物理动机建立的模型：\n\n- 级联的弹道阶段会瞬时地在一个半径为 $R_{c}$ 的近似球形区域内产生一个位移核心。\n- 在随后的持续时间为 $\\tau_{\\mathrm{ts}}$ 的热峰期间，瞬时无序区域内的原子经历类液体的自扩散过程，该过程可以很好地近似为菲克扩散，其有效自扩散系数为 $D_{\\mathrm{liq}}$，并假定在 $\\tau_{\\mathrm{ts}}$ 期间为常数。\n- 模拟盒子是边长为 $L$ 的立方体，因此最近镜像间距为 $L$。\n\n采用以下非重叠准则：级联的有效径向范围，定义为弹道半径加上在热峰期间累积的一个均方根扩散长度，必须严格小于最近镜像间距的一半。从扩散方程和均方位移的定义出发，推导满足此准则的最小盒子长度 $L_{\\min}$ 关于 $R_{c}$、$D_{\\mathrm{liq}}$ 和 $\\tau_{\\mathrm{ts}}$ 的表达式。然后，使用参数 $R_{c} = 4.2 \\ \\text{nm}$、$D_{\\mathrm{liq}} = 2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}$ 和 $\\tau_{\\mathrm{ts}} = 12 \\ \\text{ps}$ 计算 $L_{\\min}$ 的值。以纳米为单位表示您的最终结果，并将答案四舍五入到三位有效数字。", "solution": "首先对问题进行验证，以确保其科学上合理、提法恰当且信息完整。\n\n### 步骤 1：提取已知条件\n- **系统**：晶体固体中位移级联的分子动力学模拟。\n- **边界条件**：周期性边界条件 (PBC)。\n- **模拟盒子**：边长为 $L$ 的立方体。\n- **最近镜像间距**：$L$。\n- **级联模型**：\n    - 初始弹道阶段产生一个半径为 $R_{c}$ 的球形位移核心。\n    - 随后发生持续时间为 $\\tau_{\\mathrm{ts}}$ 的热峰阶段。\n    - 在热峰期间，原子自扩散被建模为菲克扩散，其扩散系数 $D_{\\mathrm{liq}}$ 为常数。\n- **非重叠准则**：级联的有效径向范围必须严格小于最近镜像间距的一半。\n- **有效径向范围的定义**：$R_{\\mathrm{eff}} = R_{c} + \\ell_{\\mathrm{rms}}$，其中 $\\ell_{\\mathrm{rms}}$ 是在热峰期间累积的一个均方根扩散长度。\n- **任务**：\n    1. 推导最小盒子长度 $L_{\\min}$ 关于 $R_{c}$、$D_{\\mathrm{liq}}$ 和 $\\tau_{\\mathrm{ts}}$ 的表达式。\n    2. 使用参数 $R_{c} = 4.2 \\ \\text{nm}$、$D_{\\mathrm{liq}} = 2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}$ 和 $\\tau_{\\mathrm{ts}} = 12 \\ \\text{ps}$ 计算 $L_{\\min}$ 的值。\n- **最终结果要求**：以纳米为单位表示最终数值答案，并四舍五入到三位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题很好地基于计算材料科学和统计物理学的原理。所描述的模型（弹道阶段后接一个具有菲克扩散的热峰）是用于分析位移级联的标准且有物理动机的简化模型。使用周期性边界条件以及对有限尺寸效应（伪镜像相互作用）的关注是分子动力学模拟实践的核心。\n- **提法恰当**：该问题提法恰当。它提供了一个清晰、定量的准则和足够的数据来推导 $L_{\\min}$ 的唯一表达式，并计算其数值。\n- **客观性**：该问题使用客观、精确的科学语言陈述。\n- **完整性和一致性**：该问题是自洽的。所有必要的变量和常数都已定义，并为数值计算部分提供了它们的值。单位是一致的，尽管在最终计算时需要进行转换。没有矛盾之处。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整的解决方案。\n\n### 解题推导\n\n问题要求基于非重叠准则推导最小模拟盒子长度 $L_{\\min}$ 的表达式。\n\n非重叠准则指出，级联的有效径向范围 $R_{\\mathrm{eff}}$ 必须严格小于最近镜像间距的一半，即 $\\frac{L}{2}$。\n$$ R_{\\mathrm{eff}}  \\frac{L}{2} $$\n有效径向范围定义为弹道核心半径 $R_{c}$ 与一个均方根扩散长度 $\\ell_{\\mathrm{rms}}$ 之和。\n$$ R_{\\mathrm{eff}} = R_{c} + \\ell_{\\mathrm{rms}} $$\n将此定义代入准则中得到：\n$$ R_{c} + \\ell_{\\mathrm{rms}}  \\frac{L}{2} $$\n最小盒子长度 $L_{\\min}$ 对应于此条件的边界情况：\n$$ \\frac{L_{\\min}}{2} = R_{c} + \\ell_{\\mathrm{rms}} $$\n$$ L_{\\min} = 2(R_{c} + \\ell_{\\mathrm{rms}}) $$\n为了继续推导，我们必须找到 $\\ell_{\\mathrm{rms}}$ 的表达式。均方根扩散长度是均方位移 (MSD) $\\langle r^{2} \\rangle$ 的平方根。对于在时间 $\\tau_{\\mathrm{ts}}$ 内发生的扩散，我们有：\n$$ \\ell_{\\mathrm{rms}} = \\sqrt{\\langle r^{2}(\\tau_{\\mathrm{ts}}) \\rangle} $$\n问题指出，我们必须从扩散方程出发来确定 MSD。扩散方程，即菲克第二定律，描述了扩散粒子浓度 $C(\\mathbf{r}, t)$ 的变化：\n$$ \\frac{\\partial C(\\mathbf{r}, t)}{\\partial t} = D_{\\mathrm{liq}} \\nabla^{2} C(\\mathbf{r}, t) $$\n三维空间中的均方位移定义为位置矢量 $\\mathbf{r}$ 的二阶矩：\n$$ \\langle r^{2}(t) \\rangle = \\int r^{2} C(\\mathbf{r}, t) \\, dV $$\n其中积分遍及整个空间。我们假设浓度分布是归一化的，使得 $\\int C(\\mathbf{r}, t) \\, dV = 1$。为了求出 MSD 的时间演化，我们对其随时间求导：\n$$ \\frac{d}{dt} \\langle r^{2}(t) \\rangle = \\int r^{2} \\frac{\\partial C(\\mathbf{r}, t)}{\\partial t} \\, dV $$\n代入扩散方程：\n$$ \\frac{d}{dt} \\langle r^{2}(t) \\rangle = \\int r^{2} (D_{\\mathrm{liq}} \\nabla^{2} C) \\, dV = D_{\\mathrm{liq}} \\int r^{2} (\\nabla \\cdot \\nabla C) \\, dV $$\n我们使用三维分部积分法，其形式为 $\\int u (\\nabla \\cdot \\mathbf{F}) dV = \\oint_{\\partial V} u \\mathbf{F} \\cdot d\\mathbf{S} - \\int (\\nabla u) \\cdot \\mathbf{F} dV$。令 $u = r^{2}$ 且 $\\mathbf{F} = \\nabla C$。积分为全空间积分，因此边界 $\\partial V$ 在无穷远处。由于对于局域分布，$C$ 及其梯度 $\\nabla C$ 在无穷远处必须为零，所以面积分为零。\n$$ \\int r^{2} (\\nabla \\cdot \\nabla C) \\, dV = - \\int (\\nabla r^{2}) \\cdot (\\nabla C) \\, dV $$\n$r^{2} = x^{2} + y^{2} + z^{2}$ 的梯度为 $\\nabla r^{2} = 2x\\hat{\\mathbf{i}} + 2y\\hat{\\mathbf{j}} + 2z\\hat{\\mathbf{k}} = 2\\mathbf{r}$。\n$$ \\int r^{2} (\\nabla^{2} C) \\, dV = - \\int (2\\mathbf{r}) \\cdot (\\nabla C) \\, dV = -2 \\int \\mathbf{r} \\cdot (\\nabla C) \\, dV $$\n我们对余下的积分再次应用分部积分法。令 $u=C$ 且 $\\mathbf{F}=\\mathbf{r}$。其形式为 $\\int \\mathbf{F} \\cdot (\\nabla u) dV = \\oint_{\\partial V} u\\mathbf{F} \\cdot d\\mathbf{S} - \\int u(\\nabla \\cdot \\mathbf{F}) dV$。同样，无穷远处的面积分为零。\n$$ \\int \\mathbf{r} \\cdot (\\nabla C) \\, dV = - \\int C (\\nabla \\cdot \\mathbf{r}) \\, dV $$\n三维空间中位置矢量的散度为 $\\nabla \\cdot \\mathbf{r} = \\frac{\\partial x}{\\partial x} + \\frac{\\partial y}{\\partial y} + \\frac{\\partial z}{\\partial z} = 1+1+1 = 3$。\n$$ \\int \\mathbf{r} \\cdot (\\nabla C) \\, dV = - \\int C (3) \\, dV = -3 \\int C \\, dV $$\n由于浓度是归一化的，$\\int C \\, dV = 1$。因此，$\\int \\mathbf{r} \\cdot (\\nabla C) \\, dV = -3$。\n将此结果代回，我们得到：\n$$ \\int r^{2} (\\nabla^{2} C) \\, dV = -2(-3) = 6 $$\n现在我们可以完成 MSD 时间导数的表达式：\n$$ \\frac{d}{dt} \\langle r^{2}(t) \\rangle = D_{\\mathrm{liq}} (6) = 6D_{\\mathrm{liq}} $$\n将此常微分方程从 $t=0$ 积分到 $t=\\tau_{\\mathrm{ts}}$，并假设初始位移为零（对于扩散部分，$\\langle r^{2}(0) \\rangle = 0$），我们得到三维空间中的爱因斯坦-斯摩洛霍夫斯基关系：\n$$ \\langle r^{2}(\\tau_{\\mathrm{ts}}) \\rangle = 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} $$\n因此，均方根扩散长度为：\n$$ \\ell_{\\mathrm{rms}} = \\sqrt{6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}}} $$\n最后，我们将此表达式代入 $L_{\\min}$ 的方程中：\n$$ L_{\\min} = 2(R_{c} + \\sqrt{6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}}}) $$\n这就是所要求的最小盒子长度的符号表达式。\n\n### 数值计算\n接下来，我们使用给定的参数计算 $L_{\\min}$。首先，我们必须确保所有单位都一致。我们将所有量都转换为国际单位制（米、秒）。\n\n- $R_{c} = 4.2 \\ \\text{nm} = 4.2 \\times 10^{-9} \\ \\text{m}$\n- $D_{\\mathrm{liq}} = 2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}$\n- $\\tau_{\\mathrm{ts}} = 12 \\ \\text{ps} = 12 \\times 10^{-12} \\ \\text{s}$\n\n首先，我们计算平方根内的参数：\n$$ 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} = 6 \\times (2.5 \\times 10^{-8} \\ \\text{m}^{2} \\ \\text{s}^{-1}) \\times (12 \\times 10^{-12} \\ \\text{s}) $$\n$$ 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} = (15 \\times 10^{-8}) \\times (12 \\times 10^{-12}) \\ \\text{m}^{2} $$\n$$ 6 D_{\\mathrm{liq}} \\tau_{\\mathrm{ts}} = 180 \\times 10^{-20} \\ \\text{m}^{2} = 1.8 \\times 10^{-18} \\ \\text{m}^{2} $$\n现在，我们计算均方根扩散长度 $\\ell_{\\mathrm{rms}}$：\n$$ \\ell_{\\mathrm{rms}} = \\sqrt{1.8 \\times 10^{-18} \\ \\text{m}^{2}} = \\sqrt{1.8} \\times 10^{-9} \\ \\text{m} $$\n$$ \\ell_{\\mathrm{rms}} \\approx 1.34164 \\times 10^{-9} \\ \\text{m} = 1.34164 \\ \\text{nm} $$\n现在我们可以计算 $L_{\\min}$：\n$$ L_{\\min} = 2(R_{c} + \\ell_{\\mathrm{rms}}) = 2(4.2 \\ \\text{nm} + 1.34164 \\ \\text{nm}) $$\n$$ L_{\\min} = 2(5.54164 \\ \\text{nm}) $$\n$$ L_{\\min} \\approx 11.08328 \\ \\text{nm} $$\n问题要求答案四舍五入到三位有效数字。\n$$ L_{\\min} \\approx 11.1 \\ \\text{nm} $$\n最终结果是 $11.1$。", "answer": "$$\n\\boxed{11.1}\n$$", "id": "3484027"}, {"introduction": "一次成功的级联模拟不仅需要正确的模拟设置，还必须精确地描述其核心物理过程。在辐射损伤的初始阶段，高能粒子（PKA）的能量主要通过与材料中电子系统的相互作用而耗散，即电子阻止过程，其阻止本领通常表示为 $S_e(v)$。本练习是一个完整的计算物理任务，它将引导你从实验数据出发，标定并实现一个速度相关的电子阻止力，并将其应用于一个简化的一维模型中 [@problem_id:3484083]。通过显式追踪耗散到电子子系统中的能量，你将学会如何验证非保守力实现的正确性，这是高能粒子模拟的一项核心技能。", "problem": "您被要求在一个最小化的分子动力学 (MD) 环境中，针对纯元素中的自离子，推导、校准和测试一个与速度成正比的电子阻止力。您将实现一个单一的铁 (Fe) 射弹原子，该原子在一个模拟电子阻止效应的耗散力作用下运动，并通过将传递给电子的能量显式地计为一个汇变量来分析数值能量守恒。\n\n基本原理和定义：\n- 电子阻止力被定义为一种与速度成正比的拖曳力，其形式为 $\\mathbf{F}_{\\mathrm{stop}}=-S_{e}(v)\\,\\hat{\\mathbf{v}}$，其中 $v=\\lVert \\mathbf{v}\\rVert$ 是速率，$\\hat{\\mathbf{v}}=\\mathbf{v}/\\lVert \\mathbf{v}\\rVert$ 是单位速度方向，$S_{e}(v)$ 是电子阻止本领。\n- 阻止本领定义为单位路径长度上的能量损失，因此对于射弹动能 $E$，有 $\\mathrm{d}E/\\mathrm{d}x=-S_{e}(v)$。\n- 质量为 $m$、速率为 $v$ 的质点的动能为 $E=\\tfrac{1}{2} m v^{2}$。\n- 阻止力的做功速率等于 $\\mathrm{d}E/\\mathrm{d}t=\\mathbf{F}_{\\mathrm{stop}}\\cdot \\mathbf{v}=-S_{e}(v)\\,v$，这意味着 $\\mathrm{d}E/\\mathrm{d}x = (\\mathrm{d}E/\\mathrm{d}t)/(\\mathrm{d}x/\\mathrm{d}t)=-S_{e}(v)$，与定义一致。\n\n单位和数值系统：\n- 使用电子伏特 ($\\mathrm{eV}$)作为能量单位，埃 ($\\mathrm{\\AA}$)作为长度单位，飞秒 ($\\mathrm{fs}$)作为时间单位。在这些单位中，质量将以 $\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$ 表示。转换因子为 $1\\,\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2} = 1.602176634\\times 10^{-29}\\,\\mathrm{kg}$。铁的质量为 $m_{\\mathrm{Fe}}=55.845\\,\\mathrm{amu}$，其中 $1\\,\\mathrm{amu}=1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$。您必须在程序中将 $m_{\\mathrm{Fe}}$ 转换为 $\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$。\n- 所有涉及物理量的答案必须使用上述指定的单位表示。所有角度（如有）必须以弧度为单位。本问题不涉及角度。如果需要分数，请将其表示为小数。\n\n铁中电子阻止的校准数据（铁中的自离子，一个合理的数值数据集）：\n- 该表提供了数据对 $\\left(E_{\\mathrm{kin}}, S_{e}\\right)$，其中 $E_{\\mathrm{kin}}$ 是射弹动能，$S_{e}$ 是电子阻止本领。动能和阻止本领在以下点给出：\n  - $\\left(1\\,\\mathrm{keV},\\,0.6\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$，\n  - $\\left(5\\,\\mathrm{keV},\\,1.8\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$，\n  - $\\left(10\\,\\mathrm{keV},\\,2.8\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$，\n  - $\\left(20\\,\\mathrm{keV},\\,4.0\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$，\n  - $\\left(50\\,\\mathrm{keV},\\,5.5\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$，\n  - $\\left(100\\,\\mathrm{keV},\\,6.5\\,\\mathrm{eV}/\\mathrm{\\AA}\\right)$。\n- 您必须根据这些数据校准 $S_{e}(v)$，方法是将每个列表中的动能 $E_{\\mathrm{kin}}$ 使用指定单位映射到速率 $v=\\sqrt{2E_{\\mathrm{kin}}/m_{\\mathrm{Fe}}}$，然后为 $S_{e}$ 构建一个关于 $v$ 的光滑、正值、保形的插值函数。为提高鲁棒性和确保正值，请在对数-对数空间中构建此插值函数，即使用保形三次方法拟合 $\\log S_{e}$ 作为 $\\log v$ 的函数，然后定义 $S_{e}(v)=\\exp\\!\\left[\\text{interpolant}(\\log v)\\right]$。在列表速率范围之外，求值 $S_{e}$ 前需将 $v$ 限制在校准域的边界内。\n\nMD 模型和数值任务：\n- 考虑一个单一的 Fe 射弹，初始速率为 $v_{0}0$，初始位置为 $x_{0}=0$，沿 x 轴进行一维运动。唯一的力是电子阻止力 $\\mathbf{F}_{\\mathrm{stop}}=-S_{e}(v)\\,\\hat{\\mathbf{v}}$，在一维情况下对于 $v\\ge 0$ 简化为 $F_{\\mathrm{stop}}(v)=-S_{e}(v)$。运动方程为 $\\mathrm{d}v/\\mathrm{d}t=-S_{e}(v)/m_{\\mathrm{Fe}}$ 和 $\\mathrm{d}x/\\mathrm{d}t=v$。\n- 定义电子汇能量 $E_{\\mathrm{el}}(t)$，使得 $\\mathrm{d}E_{\\mathrm{el}}/\\mathrm{d}t=S_{e}(v)\\,v$ 且 $E_{\\mathrm{el}}(0)=0$。根据构造，在连续方程中，总能量 $E_{\\mathrm{tot}}(t)=E_{\\mathrm{kin}}(t)+E_{\\mathrm{el}}(t)$ 应该是守恒的，其中 $E_{\\mathrm{kin}}(t)=\\tfrac{1}{2}m_{\\mathrm{Fe}} v(t)^{2}$。\n- 使用二阶显式方法（例如，Heun 方法）为该系统实现一个时间积分器，该积分器以时间步长 $\\Delta t$ 更新 $x(t)$ 和 $v(t)$，并使用二阶精度求积法（例如，梯形法则）累积 $E_{\\mathrm{el}}$。确保强制执行 $v(t)\\ge 0$，以避免因后期数值过冲而导致不符合物理的负速率。\n\n测试套件和要求的输出：\n- 校准后的阻止本领查询：使用您拟合的 $S_{e}(v)$，通过首先将每个能量通过 $v=\\sqrt{2E/m_{\\mathrm{Fe}}}$ 映射到速率，计算在以下动能处的 $S_{e}$：\n  - $E=\\{2,15,80\\}\\,\\mathrm{keV}$。以浮点数形式报告这三个阻止本领值，单位为 $\\mathrm{eV}/\\mathrm{\\AA}$。\n- 能量守恒诊断：对于以下每个三元组 $(E_{0},\\Delta t,T_{\\mathrm{end}})$，使用您的积分器模拟射弹，从初始动能 $E_{0}$ 开始，直到时间 $T_{\\mathrm{end}}$。对于每次模拟，计算由下式定义的最大总能量相对漂移：\n  $$\\max_{0\\le t\\le T_{\\mathrm{end}}}\\frac{\\left|E_{\\mathrm{kin}}(t)+E_{\\mathrm{el}}(t)-E_{0}\\right|}{E_{0}}.$$\n  使用以下情况：\n  - $(E_{0},\\Delta t,T_{\\mathrm{end}})=(10\\,\\mathrm{keV},\\,0.1\\,\\mathrm{fs},\\,2000\\,\\mathrm{fs})$，\n  - $(E_{0},\\Delta t,T_{\\mathrm{end}})=(20\\,\\mathrm{keV},\\,0.01\\,\\mathrm{fs},\\,2000\\,\\mathrm{fs})$，\n  - $(E_{0},\\Delta t,T_{\\mathrm{end}})=(50\\,\\mathrm{keV},\\,1.0\\,\\mathrm{fs},\\,2000\\,\\mathrm{fs})$。\n  以小数形式报告这三个最大相对漂移值。\n- 到阈值的射程：从 $E_{0}=50\\,\\mathrm{keV}$ 和时间步长 $\\Delta t=0.1\\,\\mathrm{fs}$ 开始模拟，直到动能衰减到 $E_{\\mathrm{th}}=1\\,\\mathrm{keV}$ 或达到 $T_{\\max}=50000\\,\\mathrm{fs}$ 的硬上限，以先到者为准。以浮点数形式报告总行进距离 $R$，单位为 $\\mathrm{\\AA}$。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下\n  $$\\left[\\;S_{e}(2\\,\\mathrm{keV}),\\;S_{e}(15\\,\\mathrm{keV}),\\;S_{e}(80\\,\\mathrm{keV}),\\;\\delta_{1},\\;\\delta_{2},\\;\\delta_{3},\\;R\\;\\right],$$\n  其中 $\\delta_{i}$ 是三个能量守恒模拟的最大相对能量漂移。所有七个条目都必须是使用指定单位的数值。\n\n科学真实性约束：\n- 校准和模拟必须使用提供的数据集、物理质量转换和所述的单位系统。\n- 积分器设计和能量计算必须与上述定义一致。\n- 不要使用任何外部数据或文件。所有内容必须是自包含且可运行的。\n\n您的最终程序必须遵守单独说明的执行环境和输出格式要求，并为整个测试套件生成单行结果。不应打印任何额外文本。", "solution": "用户要求在一个分子动力学 (MD) 背景下，推导、校准和测试一个针对单个 Fe 射弹的、与速度成正比的电子阻止力模型。该问题定义明确，有科学依据，并为获得唯一解提供了所有必要的数据和约束。因此，该问题被认为是有效的。\n\n解决方案分几个阶段进行：\n1.  **单位系统和常数**：所有物理量都在一个一致的单位系统中处理，即能量单位为电子伏特 ($\\mathrm{eV}$)，长度单位为埃 ($\\mathrm{\\AA}$)，时间单位为飞秒 ($\\mathrm{fs}$)。给定的铁 (Fe) 原子质量 $m_{\\mathrm{Fe}}=55.845\\,\\mathrm{amu}$，被转换为 MD 的质量单位 $\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$。\n    -   $1\\,\\mathrm{amu}=1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$\n    -   $m_{\\mathrm{Fe}} = 55.845\\,\\mathrm{amu} \\times (1.66053906660\\times 10^{-27}\\,\\mathrm{kg}/\\mathrm{amu}) \\approx 9.2731\\times 10^{-26}\\,\\mathrm{kg}$。\n    -   质量的转换因子为 $1\\,\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2} = 1.602176634\\times 10^{-29}\\,\\mathrm{kg}$。\n    -   因此，$m_{\\mathrm{Fe}} \\approx \\frac{9.2731\\times 10^{-26}\\,\\mathrm{kg}}{1.602176634\\times 10^{-29}\\,\\mathrm{kg}/(\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2})} \\approx 5787.855\\,\\mathrm{eV}\\cdot \\mathrm{fs}^{2}/\\mathrm{\\AA}^{2}$。\n\n2.  **电子阻止本领 $S_e(v)$ 的校准**：电子阻止本领 $S_e$ 被校准为射弹速率 $v$ 的函数。提供的数据集由数据对 $(E_{\\mathrm{kin}}, S_e)$ 组成。\n    -   来自校准表的每个动能 $E_{\\mathrm{kin}}$（单位为 $\\mathrm{keV}$）都使用关系式 $v = \\sqrt{2E_{\\mathrm{kin}}/m_{\\mathrm{Fe}}}$ 转换为速率 $v$（单位为 $\\mathrm{\\AA}/\\mathrm{fs}$）。所有能量首先被转换为 $\\mathrm{eV}$。\n    -   问题指定了在对数-对数空间中的保形三次插值。这是通过使用 `scipy.interpolate.PchipInterpolator` 拟合 $\\log(S_e)$ 作为 $\\log(v)$ 的函数来实现的。该方法确保了单调性并避免了伪振荡。\n    -   生成的插值器被包装在函数 $S_e(v)$ 中，该函数计算 $S_e(v) = \\exp\\!\\left[\\text{interpolant}(\\log v)\\right]$。为保证数值稳定性和物理真实性，如果 $v \\le 0$，$S_e(v)$ 被设为 $0$。根据问题要求，对于校准范围之外的速率，在求值前输入速率 $v$ 会被限制在范围的边界内。\n\n3.  **运动方程的数值积分**：执行 Fe 射弹的一维模拟。唯一的力是电子阻止力，$F_{\\mathrm{stop}}(v)=-S_{e}(v)$ (对于 $v \\ge 0$)。运动方程为：\n    $$ \\frac{\\mathrm{d}v}{\\mathrm{d}t} = \\frac{F_{\\mathrm{stop}}(v)}{m_{\\mathrm{Fe}}} = -\\frac{S_{e}(v)}{m_{\\mathrm{Fe}}} $$\n    $$ \\frac{\\mathrm{d}x}{\\mathrm{d}t} = v $$\n    这些方程使用二阶显式积分器 Heun 方法进行积分。对于系统 $\\mathbf{y}' = \\mathbf{f}(\\mathbf{y})$，更新规则是：\n    $$ \\mathbf{y}_{\\text{pred}} = \\mathbf{y}_n + \\Delta t \\, \\mathbf{f}(\\mathbf{y}_n) $$\n    $$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{2} \\left[ \\mathbf{f}(\\mathbf{y}_n) + \\mathbf{f}(\\mathbf{y}_{\\text{pred}}) \\right] $$\n    对于我们的状态向量 $\\mathbf{y} = [x, v]^T$，这转化为对位置 $x$ 和速度 $v$ 的更新。在每一步都强制执行非负约束 $v \\ge 0$，以防止因数值过冲而导致不符合物理的负速率。\n\n4.  **能量守恒和汇项**：系统的总能量是射弹动能 $E_{\\mathrm{kin}}(t) = \\frac{1}{2}m_{\\mathrm{Fe}}v(t)^2$ 和耗散到电子子系统中的能量 $E_{\\mathrm{el}}(t)$ 之和。电子能量汇的变化率由阻止力耗散的功率给出：\n    $$ \\frac{\\mathrm{d}E_{\\mathrm{el}}}{\\mathrm{d}t} = S_{e}(v)v $$\n    该方程使用二阶梯形法则进行数值积分，这与用于运动方程的 Heun 积分器的阶数一致：\n    $$ E_{\\mathrm{el}}(t_{n+1}) = E_{\\mathrm{el}}(t_n) + \\frac{\\Delta t}{2} \\left[ S_e(v_n)v_n + S_e(v_{n+1})v_{n+1} \\right] $$\n    总能量 $E_{\\mathrm{tot}}(t) = E_{\\mathrm{kin}}(t) + E_{\\mathrm{el}}(t)$ 应该守恒。通过监测与初始能量 $E_0$ 的偏差来评估模拟的数值精度。\n\n5.  **测试套件的执行**：应用该实现来解决指定的三个任务：\n    -   **$S_e$ 查询**：使用校准后的 $S_e(v)$ 函数，找到动能为 $2$、$15$ 和 $80\\,\\mathrm{keV}$ 的射弹的阻止本领。\n    -   **能量守恒诊断**：使用不同的初始能量 $E_0$ 和时间步长 $\\Delta t$ 运行三次模拟。为每种情况计算总能量的最大相对漂移 $\\max |E_{\\mathrm{tot}}(t) - E_0|/E_0$。\n    -   **射程计算**：从 $E_0=50\\,\\mathrm{keV}$ 开始运行一次模拟，直到射弹的能量降至 $E_{\\mathrm{th}}=1\\,\\mathrm{keV}$ 的阈值以下。记录总行进距离，即射程 $R$。\n\n最终输出按要求将这三个任务的结果连接成一个单一列表。该实现在一个单独的 Python 脚本中是自包含的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the problem of simulating a projectile under electronic stopping,\n    including calibration, integration, and analysis tasks.\n    \"\"\"\n\n    # Define physical constants and conversion factors as per the problem statement.\n    AMU_IN_KG = 1.66053906660e-27\n    EV_FS2_PER_A2_IN_KG = 1.602176634e-29\n    FE_MASS_AMU = 55.845\n\n    # Calculate the mass of an iron atom in the specified MD units (eV*fs^2/A^2).\n    m_Fe_kg = FE_MASS_AMU * AMU_IN_KG\n    m_Fe = m_Fe_kg / EV_FS2_PER_A2_IN_KG\n\n    def calibrate_stopping_power(mass_fe):\n        \"\"\"\n        Calibrates the electronic stopping power S_e as a function of speed v,\n        based on provided (E_kin, S_e) data. The calibration is performed\n        via shape-preserving cubic interpolation in log-log space.\n\n        Args:\n            mass_fe (float): Mass of the projectile in MD units.\n\n        Returns:\n            A function S_e(v) that returns the stopping power.\n        \"\"\"\n        # Calibration data: (E_kin [keV], S_e [eV/A])\n        cal_data = np.array([\n            (1.0, 0.6), (5.0, 1.8), (10.0, 2.8), (20.0, 4.0),\n            (50.0, 5.5), (100.0, 6.5)\n        ], dtype=float)\n\n        E_kin_keV = cal_data[:, 0]\n        Se_cal = cal_data[:, 1]\n\n        # Convert kinetic energy E_kin [keV] to speed v [A/fs]\n        E_kin_eV = E_kin_keV * 1000.0\n        v_cal = np.sqrt(2 * E_kin_eV / mass_fe)\n\n        # Prepare for log-log interpolation\n        log_v_cal = np.log(v_cal)\n        log_Se_cal = np.log(Se_cal)\n\n        # Create the shape-preserving (monotonic) cubic interpolator\n        pchip = PchipInterpolator(log_v_cal, log_Se_cal)\n        min_log_v, max_log_v = log_v_cal[0], log_v_cal[-1]\n\n        def Se_function(v):\n            \"\"\"\n            Computes electronic stopping power S_e for a given speed v.\n            Handles v = 0 and clamps v to the calibration range.\n            \"\"\"\n            if v = 0:\n                return 0.0\n            log_v = np.log(v)\n            clamped_log_v = np.clip(log_v, min_log_v, max_log_v)\n            log_Se = pchip(clamped_log_v)\n            return np.exp(log_Se)\n\n        return Se_function\n\n    def run_simulation(E0_keV, dt_fs, Se_func, mass_fe, t_end_fs=None, E_th_keV=None, t_max_fs=None):\n        \"\"\"\n        Simulates the 1D motion of a projectile under electronic stopping.\n        Can run in two modes:\n        1. Energy conservation check: Runs for a fixed time.\n        2. Range calculation: Runs until energy drops to a threshold or time limit is reached.\n        \"\"\"\n        E0_eV = E0_keV * 1000.0\n        v0 = np.sqrt(2 * E0_eV / mass_fe)\n        E_kin0 = E0_eV\n\n        t, x, v, E_el = 0.0, 0.0, v0, 0.0\n        max_rel_drift = 0.0\n        \n        is_range_calc = (E_th_keV is not None and t_max_fs is not None)\n        \n        t_limit = t_max_fs if is_range_calc else t_end_fs\n        E_th_eV = E_th_keV * 1000.0 if is_range_calc else None\n        \n        num_steps = int(np.ceil(t_limit / dt_fs))\n\n        for _ in range(num_steps):\n            if is_range_calc:\n                current_E_kin = 0.5 * mass_fe * v**2 if v > 0 else 0.0\n                if current_E_kin = E_th_eV:\n                    break\n            \n            # Heun's method for velocity and position\n            v_n = v\n            Se_n = Se_func(v_n)\n            accel_n = -Se_n / mass_fe if v_n > 0 else 0.0\n            \n            v_tilde = v_n + dt_fs * accel_n\n            \n            Se_tilde = Se_func(v_tilde)\n            accel_tilde = -Se_tilde / mass_fe if v_tilde > 0 else 0.0\n            \n            v_next = v_n + 0.5 * dt_fs * (accel_n + accel_tilde)\n            v_next = max(0.0, v_next)\n\n            x_next = x + 0.5 * dt_fs * (v_n + v_tilde)\n            \n            # Trapezoidal rule for energy sink\n            Se_next = Se_func(v_next)\n            E_el_next = E_el + 0.5 * dt_fs * ((Se_n * v_n) + (Se_next * v_next))\n\n            x, v, E_el = x_next, v_next, E_el_next\n\n            if not is_range_calc:\n                E_kin_next = 0.5 * mass_fe * v**2\n                E_tot_next = E_kin_next + E_el\n                if E_kin0 > 0:\n                    rel_drift = abs(E_tot_next - E_kin0) / E_kin0\n                    max_rel_drift = max(max_rel_drift, rel_drift)\n        \n        return x if is_range_calc else max_rel_drift\n\n    all_results = []\n    \n    Se_func = calibrate_stopping_power(m_Fe)\n\n    # Task 1: Calibrated stopping power queries\n    query_energies_keV = [2.0, 15.0, 80.0]\n    for E_keV in query_energies_keV:\n        E_eV = E_keV * 1000.0\n        v_query = np.sqrt(2 * E_eV / m_Fe)\n        all_results.append(Se_func(v_query))\n\n    # Task 2: Energy conservation diagnostics\n    conservation_cases = [\n        (10.0, 0.1, 2000.0), # (E0_keV, dt_fs, T_end_fs)\n        (20.0, 0.01, 2000.0),\n        (50.0, 1.0, 2000.0)\n    ]\n    for E0, dt, Tend in conservation_cases:\n        drift = run_simulation(E0, dt, Se_func, m_Fe, t_end_fs=Tend)\n        all_results.append(drift)\n    \n    # Task 3: Range-to-threshold\n    final_range = run_simulation(\n        E0_keV=50.0, dt_fs=0.1, Se_func=Se_func, mass_fe=m_Fe,\n        E_th_keV=1.0, t_max_fs=50000.0\n    )\n    all_results.append(final_range)\n    \n    # Final output format: [Se_1, Se_2, Se_3, drift_1, drift_2, drift_3, Range]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3484083"}, {"introduction": "位移级联模拟的最终产物是原子尺度的缺陷构型，但真正的科学洞见来自于对这些复杂结构进行定量分析。简单地计算缺陷数量是不够的；缺陷团簇的形态（例如，是形成平面的位错环还是三维的聚集体）对材料的宏观性能有着决定性影响。本练习将向你介绍一种基于图论的先进分析方法，你将学习如何将缺陷的原子坐标转化为图结构，并计算其平均局部集聚系数 $\\bar{C}$，从而对缺陷团簇的形态进行定量分类 [@problem_id:3484085]。这项技能对于从大规模原子模拟中提取高级别的科学见解至关重要。", "problem": "你的任务是实现一个完整、可运行的程序，该程序根据位移级联模拟构建点缺陷团簇的图表示，并计算图度量，以在不同初级撞出原子能量和温度下，将团簇形貌分类为平面位错环或三维聚集体。该程序必须是完全确定性的，并针对指定的测试套件产生单行、可机器校验的输出。下述所有数学定义都必须精确实现，所有物理量和数值量均已标明单位。\n\n基本原理和定义：\n\n- 令团簇为一个有限的位置集合 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$，其中 $\\mathbf{x}_i \\in \\mathbb{R}^3$，单位为埃（Angstrom）。\n- 根据这些位置，通过基于距离的截断构建一个无向简单图 $G = (V,E)$，其节点集为 $V = \\{1,\\dots,N\\}$。对于用户指定的整数 $m \\ge 2$ 和比例因子 $\\eta  0$，为每个节点 $i$ 计算其到第 $m$ 个最近邻的距离 $d_i^{(m)}$，并定义全局截断半径\n  $$ r_{\\mathrm{c}} = \\eta \\cdot \\mathrm{median}\\left(\\{d_i^{(m)}\\}_{i=1}^{N}\\right). $$\n  邻接矩阵 $A \\in \\{0,1\\}^{N \\times N}$ 定义为\n  $$ A_{ij} = \\begin{cases}1, 0  \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2 \\le r_{\\mathrm{c}},\\\\ 0, \\text{其他情况},\\end{cases} $$\n  其中 $A_{ii} = 0$ 且 $A_{ij} = A_{ji}$。\n- 节点 $i$ 的度为 $k_i = \\sum_{j=1}^{N} A_{ij}$。度分布是多重集 $\\{k_i\\}_{i=1}^{N}$。\n- 对于度 $k_i \\ge 2$ 的节点 $i$，其局部聚类系数（三元闭包）为\n  $$ C_i = \\frac{2 t_i}{k_i (k_i - 1)}, $$\n  其中 $t_i$ 是节点 $i$ 的邻居之间边的数量，\n  $$ t_i = \\sum_{1 \\le p  q \\le N} A_{ip} A_{iq} A_{pq}. $$\n  对于 $k_i  2$，定义 $C_i = 0$。平均局部聚类系数为\n  $$ \\bar{C} = \\frac{1}{|\\{i \\,:\\, k_i \\ge 2\\}|} \\sum_{i : k_i \\ge 2} C_i, $$\n  并约定如果 $\\{i : k_i \\ge 2\\} = \\emptyset$，则 $\\bar{C} = 0$。\n\n分类的科学依据：\n\n- 当边由几何邻近规则形成时，得到的图是一个受嵌入维度约束的随机几何图。在邻居数量相当的情况下，二维嵌入（平面圆盘）的邻域重叠区域比三维嵌入（球形体积）的更大，这导致二维情况下的 $\\bar{C}$ 大于三维情况。这种效应可以从基本几何学角度理解：对于固定的邻居数量（此处由自适应截断控制），成对邻域交集的度量与邻域度量的比值在较低维度中更大，从而提高了形成闭合三元组的概率，因此 $\\bar{C}$ 也更大。\n- 因此，我们使用 $\\bar{C}$ 的一个阈值来对团簇进行分类：\n  $$ \\text{label} = \\begin{cases} 0, \\bar{C} \\ge C_{\\mathrm{thr}} \\quad \\text{(平面环)},\\\\ 1, \\bar{C}  C_{\\mathrm{thr}} \\quad \\text{(三维聚集体)}.\\end{cases} $$\n\n基于物理动机、从初级撞出原子能量和温度生成坐标的合成团簇生成器：\n\n- 初级撞出原子 (PKA) 能量记为 $E_{\\mathrm{PKA}}$，单位为千电子伏 (kilo-electronvolt)，温度 $T$ 的单位为开尔文 (Kelvin)。\n- 固定参考能量 $E_{\\mathrm{ref}} = 20$ 千电子伏，并定义一个尺寸比例因子 $s_E = (E_{\\mathrm{PKA}}/E_{\\mathrm{ref}})^{1/3}$（无量纲），其动机源于级联中的能量-体积标度关系。\n- 一个温度-能量转换规则决定是生成平面环还是体积型团簇：\n  $$ T_{\\mathrm{switch}}(E_{\\mathrm{PKA}}) = T_0 + \\alpha \\left(E_{\\mathrm{PKA}} - E_{\\mathrm{ref}}\\right), $$\n  其中 $T_0 = 800$ 开尔文，$\\alpha = 4$ 开尔文/千电子伏。如果 $T \\ge T_{\\mathrm{switch}}(E_{\\mathrm{PKA}})$，则生成一个类平面环团簇；否则，生成一个三维团簇。\n- 类平面环团簇的合成：在 $z=0$ 平面内，半径为 $R_{\\mathrm{loop}} = 12 \\, s_E$ 埃的圆盘中均匀采样 $N$ 个点。径向采样必须使用 $r = R_{\\mathrm{loop}} \\sqrt{U}$（其中 $U \\sim \\mathrm{Uniform}(0,1)$），角度采样必须使用 $\\theta \\sim \\mathrm{Uniform}(0,2\\pi)$（角度单位为弧度）。添加小的平面外扰动 $\\delta z \\sim \\mathcal{N}(0,\\sigma_z^2)$，其中 $\\sigma_z = 0.15 \\cdot (T/1000)$ 埃。\n- 三维团簇的合成：在半径为 $R_{\\mathrm{3D}} = 10 \\, s_E$ 埃的球体内，使用半径定律 $r = R_{\\mathrm{3D}} \\, U^{1/3}$（其中 $U \\sim \\mathrm{Uniform}(0,1)$）和 $\\mathbb{R}^3$ 中的均匀随机方向向量，均匀采样 $N$ 个点。\n- 使用等于 $12345$ 的固定随机种子，以使所有坐标都是可复现的。\n\n图构建超参数和分类阈值：\n\n- 对自适应截断使用 $m = 6$ 和 $\\eta = 1.05$。如果 $N-1  m$，则使用 $m_{\\mathrm{eff}} = N-1$ 代替 $m$。\n- 使用 $C_{\\mathrm{thr}} = 0.50$ 作为分类阈值。\n- 所有距离必须以埃（Angstrom）计算，所有角度必须以弧度计算。\n\n测试套件：\n\n提供以下五个测试用例，形式为有序元组 $(N, E_{\\mathrm{PKA}} \\, [\\mathrm{keV}], T \\, [\\mathrm{K}])$：\n\n- 案例 A (理想情况下的平面构型): $(80, 10, 1000)$。\n- 案例 B (理想情况下的三维构型): $(120, 40, 500)$。\n- 案例 C (位于转换线上的边界情况): $(60, 20, 800)$。\n- 案例 D (小团簇边缘情况): $(12, 25, 850)$。\n- 案例 E (接近转换点的三维构型): $(90, 30, 820)$。\n\n程序要求：\n\n- 精确地按照定义实现生成器、图构建、度分布和平均局部聚类系数的计算。\n- 对于每个测试用例，构建图并计算度分布 $\\{k_i\\}$ 和 $\\bar{C}$，然后输出形貌标签（整数形式），其中 $0$ 表示类环形貌，$1$ 表示三维形貌。\n- 最终的程序输出必须是单行文本，包含一个逗号分隔的列表，其中是按给定顺序排列的五个测试用例的标签，并用方括号括起来。例如，输出格式必须与 $[x_1,x_2,x_3,x_4,x_5]$ 完全一样，其中每个 $x_i$ 是一个整数。", "solution": "该问题要求实现一个计算工作流，用于将人工合成的点缺陷团簇的形貌分类为平面型（标签 $0$）或三维型（标签 $1$）。这是通过将团簇建模为图，并使用一个图论度量——平均局部聚类系数——作为判别性特征来完成的。由于使用了固定的随机种子，从数据生成到分类的整个过程都是确定性的。\n\n该解决方案分三个主要阶段实现：合成团簇生成、图的构建与分析，以及最终分类。\n\n**1. 合成团簇生成**\n\n团簇坐标 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ 的生成具有物理动机，它模仿了材料中位移级联的后果。其形貌由初级撞出原子 (PKA) 能量 $E_{\\mathrm{PKA}}$ 和温度 $T$ 之间的竞争决定。\n\n首先，计算尺寸缩放因子 $s_E = (E_{\\mathrm{PKA}}/E_{\\mathrm{ref}})^{1/3}$，其中参考能量 $E_{\\mathrm{ref}} = 20$ keV。这个 $1/3$ 次幂律与理论模型一致，在这些模型中，级联影响区域的体积与能量成线性关系。\n\n接着，计算一个温度阈值 $T_{\\mathrm{switch}}$，它是 PKA 能量的线性函数：\n$$ T_{\\mathrm{switch}}(E_{\\mathrm{PKA}}) = T_0 + \\alpha (E_{\\mathrm{PKA}} - E_{\\mathrm{ref}}) $$\n其中基础温度 $T_0 = 800$ K，斜率 $\\alpha = 4$ K/keV。如果环境温度 $T$ 大于或等于此阈值 ($T \\ge T_{\\mathrm{switch}}(E_{\\mathrm{PKA}})$)，则生成一个平面的、类似环的团簇。否则，形成一个三维的、类似聚集体的团簇。这个规则模拟了一种物理趋势，即在温度较高、热迁移能力增强时，缺陷倾向于排列成低维结构（位错环）。\n\n- **平面环合成 ($T \\ge T_{\\mathrm{switch}}$)**：从半径为 $R_{\\mathrm{loop}} = 12 \\, s_E$ 埃的圆盘中均匀采样 $N$ 个点。为确保空间密度均匀，径向坐标 $r$ 根据 $r = R_{\\mathrm{loop}} \\sqrt{U}$ 进行采样，其中 $U$ 是一个服从 $\\mathrm{Uniform}(0,1)$ 分布的随机变量。角坐标 $\\theta$ 从 $\\mathrm{Uniform}(0,2\\pi)$ 中采样。为了模拟热振动和与理想平面的微小偏离，向 $z$ 坐标添加一个小的、与温度相关的、标准差为 $\\sigma_z = 0.15 \\cdot (T/1000)$ 埃的高斯噪声。\n\n- **三维聚集体合成 ($T  T_{\\mathrm{switch}}$)**：从半径为 $R_{\\mathrm{3D}} = 10 \\, s_E$ 埃的球体中均匀采样 $N$ 个点。均匀体积采样要求径向坐标 $r$ 按 $r = R_{\\mathrm{3D}} \\, U^{1/3}$ 采样，其中 $U \\sim \\mathrm{Uniform}(0,1)$。方向从单位球面 $\\mathbb{S}^2$ 上均匀采样。\n\n使用一个以固定种子 $12345$ 初始化的伪随机数生成器，确保整个生成过程是可复现的。\n\n**2. 图的构建与度量计算**\n\n给定 $N$ 个坐标的集合，构建一个无向图 $G=(V, E)$。该过程的核心是确定连通性的自适应截断半径 $r_{\\mathrm{c}}$。\n\n首先，对每个点 $\\mathbf{x}_i$，我们找到它到第 $m$ 个最近邻的距离 $d_i^{(m)}$，其中 $m=6$。一个特殊情况处理小团簇，即其他点的数量小于 $m$ 时：如果 $N-1  m$，我们使用 $m_{\\mathrm{eff}} = N-1$ 代替。然后全局截断半径定义为：\n$$ r_{\\mathrm{c}} = \\eta \\cdot \\mathrm{median}\\left(\\{d_i^{(m)}\\}_{i=1}^{N}\\right) $$\n其中 $\\eta = 1.05$ 是一个缩放因子。这种自适应方法确保了所得图中每个节点的连接数对点云整体密度的变化具有鲁棒性。\n\n图的邻接矩阵 $A$ 是基于此截断半径构建的。如果节点 $i$ 和 $j$ 之间的欧几里得距离为正且不超过 $r_{\\mathrm{c}}$，则它们之间存在一条边：\n$$ A_{ij} = 1 \\quad \\text{if} \\quad 0  \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2 \\le r_{\\mathrm{c}}, \\quad \\text{and} \\quad A_{ij}=0 \\quad \\text{otherwise}. $$\n根据定义，$A_{ii}=0$ 且矩阵是对称的，$A_{ij}=A_{ji}$。\n\n用于分类的主要图度量是平均局部聚类系数 $\\bar{C}$。对每个节点 $i$，其局部聚类系数 $C_i$ 衡量了其直接邻居之间的连接密度。它为度 $k_i = \\sum_{j} A_{ij} \\ge 2$ 的节点定义：\n$$ C_i = \\frac{2 t_i}{k_i (k_i - 1)} $$\n其中 $t_i$ 是包含节点 $i$ 的三角形（由相连节点组成的闭合三元组）的数量。对于度 $k_i  2$ 的节点，$C_i$ 定义为 $0$。三角形数量 $t_i$ 可以通过组合方法计算，但一个计算效率更高的方法是利用矩阵代数：从节点 $i$ 出发回到自身的长度为3的路径数量由矩阵立方的第 $i$ 个对角元素 $(A^3)_{ii}$ 给出。由于每个涉及节点 $i$ 的三角形对应两条这样的路径（一条顺时针，一条逆时针），我们有 $2t_i = (A^3)_{ii}$。\n\n平均局部聚类系数 $\\bar{C}$ 是所有度 $k_i \\ge 2$ 的节点的 $C_i$ 的平均值：\n$$ \\bar{C} = \\frac{1}{|\\{i \\,:\\, k_i \\ge 2\\}|} \\sum_{i : k_i \\ge 2} C_i $$\n如果没有节点的度大于或等于 $2$，则定义 $\\bar{C}$ 为 $0$。\n\n**3. 形貌分类**\n\n使用 $\\bar{C}$ 的科学依据是几何学的。对于一个节点平均拥有相似数量邻居的图（由自适应截断保证），嵌入在二维空间中的节点将比三维空间中的节点有更高的 $\\bar{C}$。这是因为邻域（二维中的圆盘，三维中的球体）在较低维度中具有更大的相对交集度量，这增加了某个节点的两个邻居也互为邻居的概率。\n\n最终的分类通过将 $\\bar{C}$ 与一个固定阈值 $C_{\\mathrm{thr}} = 0.50$ 进行比较来执行：\n- 如果 $\\bar{C} \\ge C_{\\mathrm{thr}}$，团簇被分类为平面环（标签 $0$）。\n- 如果 $\\bar{C}  C_{\\mathrm{thr}}$，团簇被分类为三维聚集体（标签 $1$）。\n\n所提供的程序实现了这一完整的流程，处理指定套件中的每个测试用例，并生成相应的分类标签。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import pdist, squareform\n\ndef solve():\n    \"\"\"\n    Main function to run the full simulation and classification pipeline.\n    It orchestrates cluster generation, graph construction, and metric-based\n    classification for a predefined suite of test cases.\n    \"\"\"\n    \n    # Initialize a single random number generator with a fixed seed for reproducibility.\n    # This generator is passed to any function that requires random numbers.\n    rng = np.random.default_rng(12345)\n\n    # Define physical constants and model hyperparameters as specified.\n    E_REF = 20.0  # Reference PKA energy in keV\n    T0 = 800.0    # Base temperature in K\n    ALPHA = 4.0   # Temperature-Energy coupling in K/keV\n    M_PARAM = 6   # Neighbor parameter for adaptive cutoff\n    ETA = 1.05    # Scale factor for adaptive cutoff\n    C_THR = 0.50  # Threshold for classification\n\n    # Define the five test cases as (N, E_pka [keV], T [K]).\n    test_cases = [\n        (80, 10.0, 1000.0),  # Case A: Happy path planar\n        (120, 40.0, 500.0),  # Case B: Happy path volumetric\n        (60, 20.0, 800.0),   # Case C: Boundary at switching line\n        (12, 25.0, 850.0),   # Case D: Small cluster edge case\n        (90, 30.0, 820.0),   # Case E: Near-switch volumetric\n    ]\n\n    results = []\n    for N, E_pka, T in test_cases:\n        # For each case, generate the coordinates based on the physical model.\n        coords = _generate_cluster(N, E_pka, T, E_REF, T0, ALPHA, rng)\n        # Classify the generated cluster using the graph-based method.\n        label = _classify_cluster(coords, M_PARAM, ETA, C_THR)\n        results.append(label)\n\n    # Print the final output in the specified format \"[label1,label2,...]\".\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _generate_cluster(N, E_pka, T, E_ref, T0, alpha, rng):\n    \"\"\"\n    Generates a synthetic point-defect cluster based on PKA energy and temperature.\n    \"\"\"\n    s_E = (E_pka / E_ref)**(1/3.0)\n    T_switch = T0 + alpha * (E_pka - E_ref)\n\n    if T >= T_switch:\n        # Generate a planar, loop-like cluster.\n        R_loop = 12.0 * s_E\n        sigma_z = 0.15 * (T / 1000.0)\n        \n        # Uniform sampling in a disk requires a square-root transformation of the radial uniform variate.\n        u_rad = rng.uniform(0, 1, size=N)\n        radii = R_loop * np.sqrt(u_rad)\n        \n        thetas = rng.uniform(0, 2 * np.pi, size=N)\n        \n        x = radii * np.cos(thetas)\n        y = radii * np.sin(thetas)\n        z = rng.normal(0, sigma_z, size=N)\n        \n        return np.vstack((x, y, z)).T\n    else:\n        # Generate a three-dimensional, aggregate-like cluster.\n        R_3d = 10.0 * s_E\n        \n        # Uniform sampling in a sphere requires a cube-root transformation of the radial uniform variate.\n        u_rad = rng.uniform(0, 1, size=N)\n        radii = R_3d * (u_rad**(1/3.0))\n        \n        # Generate uniformly distributed random direction vectors on the unit sphere.\n        vecs = rng.normal(0, 1, size=(N, 3))\n        norms = np.linalg.norm(vecs, axis=1, keepdims=True)\n        # Avoid division by zero for a zero-vector, though highly improbable.\n        norms[norms == 0] = 1\n        unit_vecs = vecs / norms\n        \n        # Scale unit vectors by the sampled radii.\n        return radii[:, np.newaxis] * unit_vecs\n\ndef _classify_cluster(coords, m_param, eta, C_thr):\n    \"\"\"\n    Classifies a cluster by constructing a graph and computing its mean local clustering coefficient.\n    \"\"\"\n    N = coords.shape[0]\n    \n    # Handle trivial cases (e.g., N = 2) where a graph is ill-defined.\n    if N = 1:\n        return 1  # Cannot form edges, C_bar is 0, classified as 3D.\n\n    # Adjust m for small clusters as per problem spec.\n    m_eff = min(m_param, N - 1)\n    if m_eff  1:\n        return 1 # Not enough neighbors to define m-th nearest.\n\n    # 1. Compute pairwise Euclidean distance matrix.\n    dist_matrix = squareform(pdist(coords, 'euclidean'))\n    \n    # 2. Find m-th nearest neighbor distances for each point.\n    sorted_dist = np.sort(dist_matrix, axis=1)\n    # sorted_dist[:, 0] is always 0 (distance to self).\n    # sorted_dist[:, k] is the k-th nearest neighbor distance.\n    d_m_list = sorted_dist[:, m_eff]\n    \n    # 3. Compute the adaptive cutoff radius.\n    r_c = eta * np.median(d_m_list)\n    \n    # 4. Construct the adjacency matrix.\n    adj_matrix = ((dist_matrix > 0)  (dist_matrix = r_c)).astype(int)\n    \n    # 5. Compute node degrees (k_i).\n    k = adj_matrix.sum(axis=1)\n\n    # 6. Compute mean local clustering coefficient (C_bar).\n    k_ge_2_mask = k = 2\n    \n    if not np.any(k_ge_2_mask):\n        C_bar = 0.0\n    else:\n        # Efficiently compute number of triangles t_i using matrix exponentiation.\n        # (A^3)_ii = 2 * t_i\n        adj_matrix_cubed = np.linalg.matrix_power(adj_matrix, 3)\n        two_ti = np.diag(adj_matrix_cubed)\n        \n        # Denominators for C_i: k_i * (k_i - 1).\n        denominators = k * (k - 1)\n        \n        # Calculate C_i only for nodes where the denominator is non-zero (k_i >= 2).\n        valid_two_ti = two_ti[k_ge_2_mask]\n        valid_denominators = denominators[k_ge_2_mask]\n        \n        C_i_list = valid_two_ti / valid_denominators\n        C_bar = np.mean(C_i_list)\n        \n    # 7. Classify based on C_bar and the threshold C_thr.\n    label = 1 if C_bar  C_thr else 0\n    \n    return label\n\nsolve()\n```", "id": "3484085"}]}