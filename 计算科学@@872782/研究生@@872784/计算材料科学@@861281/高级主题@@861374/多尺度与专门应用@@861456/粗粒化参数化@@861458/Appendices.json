{"hands_on_practices": [{"introduction": "粗粒化建模的一个核心任务是构建能够准确描述系统有效相互作用的势函数。本练习 [@problem_id:3438346] 将指导您掌握力匹配 (Force Matching, FM) 方法中的一项基本技能：使用 B-样条基函数来表示对势。通过从头开始构建 B-样条及其导数，并组装力匹配方法中的设计矩阵，您将深入理解如何为复杂相互作用势创建一个灵活、系统且数学上稳健的表示。", "problem": "在计算材料科学中，考虑一个粗粒化对相互作用模型，其中粒子系统通过仅依赖于两个粗粒化位点之间标量距离 $r$ 的对势 $u(r)$ 来建模。粒子上的力由势的负梯度给出，这与牛顿第二定律一致。具体来说，对于由索引 $i$ 和 $j$ 标记的粒子，作用于粒子 $i$ 的成对力贡献为 $-\\dfrac{d u(r_{ij})}{d r} \\hat{\\boldsymbol{r}}_{ij}$，其中 $\\boldsymbol{r}_{ij} = \\boldsymbol{x}_{j} - \\boldsymbol{x}_{i}$, $r_{ij} = \\|\\boldsymbol{r}_{ij}\\|$, 且 $\\hat{\\boldsymbol{r}}_{ij} = \\boldsymbol{r}_{ij} / r_{ij}$。在力匹配（Force Matching, FM）中，这是一种用于粗粒化参数化的线性回归方法，我们将 $u(r)$ 在一个固定基中展开，并求解一个线性系统以匹配采样的微观力。\n\n您的任务是为一个指定的节点向量构建一个用于对势 $u(r)$ 的三次B样条基，该节点向量具有适当的端点重复度以达到所需的连续性，然后构建用于力匹配的线性设计矩阵。您必须从基本原理和经过充分检验的公式出发，以一种物理和数学上都有根据的方式来解决这个问题。不要假定任何启发式的捷径。\n\n使用以下基本依据：\n\n- 由中心势产生的粒子上的力为 $-\\nabla u(r)$，对于粗粒化模型中的对相互作用，粒子 $i$ 上的合力为 $\\boldsymbol{F}_{i} = \\sum_{j \\neq i} -\\dfrac{d u(r_{ij})}{d r} \\hat{\\boldsymbol{r}}_{ij}$。\n- 将对势表示为基函数的线性组合：$u(r) = \\sum_{k=0}^{K-1} c_{k} B_{k}(r)$，其中 $B_{k}(r)$ 是定义在开放、钳位节点向量上的三次B样条基函数，而 $c_{k}$ 是待由力匹配确定的系数。\n- 三次B样条基函数 $B_{k}(r)$ 必须在内部节点处满足 $C^{2}$ 连续性。这通过使用一个次数为 $p = 3$ 的样条和一个开放节点向量来实现，即端点重复 $p+1$ 次。\n- Cox–de Boor 递推是在给定节点向量上构建任意次数的B样条基函数的经过充分检验的公式。在您的推导和实现中，使用此公式来定义 $B_{k}(r)$ 及其导数 $\\dfrac{d B_{k}(r)}{d r}$。\n\n按如下方式定义样条的节点向量（单位为纳米）。设域为 $[r_{\\min}, r_{\\max}]$，其中 $r_{\\min} = 0.3$，$r_{\\max} = 1.1$。设内部节点位于 $0.5$、$0.7$ 和 $0.9$。通过将端点重复 $p+1 = 4$ 次来构建一个开放、钳位的节点向量：\n$$\n\\{t_{i}\\} = \\{0.3, 0.3, 0.3, 0.3, 0.5, 0.7, 0.9, 1.1, 1.1, 1.1, 1.1\\}。\n$$\n根据这个节点向量和次数 $p = 3$，确定基函数的数量 $K$，并构建满足内部节点处连续性约束的 $B_{k}(r)$ 和 $\\dfrac{d B_{k}(r)}{d r}$。然后，用这些导数和几何向量表示FM设计矩阵 $\\boldsymbol{A}$。对于一个在三维空间中有 $N$ 个粒子的系统，线性系统形式为\n$$\n\\boldsymbol{A} \\boldsymbol{c} = \\boldsymbol{y},\n$$\n其中 $\\boldsymbol{c} \\in \\mathbb{R}^{K}$ 是未知系数，$\\boldsymbol{A}$ 的每一行对应于一个粒子上的合力的一个笛卡尔分量。具体来说，对于粒子 $i$ 和分量 $\\alpha \\in \\{x,y,z\\}$，\n$$\nA_{(3i+\\alpha),\\,k} = \\sum_{j \\neq i} \\left( - \\frac{d B_{k}(r_{ij})}{d r} \\right) \\hat{r}_{ij, \\alpha}。\n$$\n\n您的程序必须实现：\n\n1.  通过在指定的节点向量上使用Cox–de Boor递推，构建三次B样条基函数 $B_{k}(r)$ 及其导数 $\\dfrac{d B_{k}(r)}{d r}$，确保在内部节点处具有 $C^{2}$ 连续性以及开放-钳位端点条件。\n2.  针对指定的粒子构型，使用上述公式组装FM设计矩阵 $\\boldsymbol{A}$。\n\n使用以下测试套件，所有距离单位为纳米，所有涉及导数或范数的输出单位为逆纳米 ($\\text{nm}^{-1}$)。不使用角度。对于每个案例，计算所要求的标量结果：\n\n- 测试案例1（一般情况）：使用 $N = 3$ 个粒子，位置为\n$$\n\\boldsymbol{x}_{0} = (0.0, 0.0, 0.0),\\quad \\boldsymbol{x}_{1} = (0.6, 0.0, 0.0),\\quad \\boldsymbol{x}_{2} = (0.0, 0.8, 0.0).\n$$\n构建 $\\boldsymbol{A}$ 并报告 $\\boldsymbol{A}$ 的弗罗贝尼乌斯范数，即 $\\|\\boldsymbol{A}\\|_{F}$，作为一个浮点数，单位为 $\\text{nm}^{-1}$。\n\n- 测试案例2（内部节点的连续性）：设 $r_{k} = 0.7$ 和 $\\varepsilon = 10^{-8}$。计算跨节点处导数基的最大绝对跳跃：\n$$\nJ = \\max_{k} \\left| \\left.\\frac{d B_{k}(r)}{d r}\\right|_{r = r_{k} - \\varepsilon} - \\left.\\frac{d B_{k}(r)}{d r}\\right|_{r = r_{k} + \\varepsilon} \\right|。\n$$\n报告 $J$ 作为一个浮点数，单位为 $\\text{nm}^{-1}$。\n\n- 测试案例3（支集外的边界情况）：使用 $N = 2$ 个粒子，位置为\n$$\n\\boldsymbol{x}_{0} = (0.0, 0.0, 0.0),\\quad \\boldsymbol{x}_{1} = (1.3, 0.0, 0.0).\n$$\n构建 $\\boldsymbol{A}$ 并报告 $\\boldsymbol{A}$ 的最大绝对值元素，即 $\\max_{i,k} |A_{i,k}|$，作为一个浮点数，单位为 $\\text{nm}^{-1}$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_{1}, r_{2}, r_{3}]$），其中 $r_{1}$、$r_{2}$ 和 $r_{3}$ 分别是对应于测试案例1、2和3的浮点数结果，单位为 $\\text{nm}^{-1}$。不应打印任何其他文本。所有计算都应是自包含且数值稳健的。[@problem_id:454]", "solution": "用户要求解决一个计算材料科学问题，该问题涉及使用力匹配（FM）方法对粗粒化势进行参数化。该势在一个三次B样条基中展开。任务的核心是使用Cox-de Boor递推实现B样条基函数及其导数，然后为几个测试案例组装FM设计矩阵。\n\n### 问题验证\n\n根据指定标准对问题陈述进行审查。\n\n-   **已知信息提取**：\n    -   模型：粗粒化系统的对势 $u(r)$。\n    -   力定律：$\\boldsymbol{F}_{i} = \\sum_{j \\neq i} -\\dfrac{d u(r_{ij})}{d r} \\hat{\\boldsymbol{r}}_{ij}$，其中 $\\boldsymbol{r}_{ij} = \\boldsymbol{x}_{j} - \\boldsymbol{x}_{i}$, $r_{ij} = \\|\\boldsymbol{r}_{ij}\\|$, 且 $\\hat{\\boldsymbol{r}}_{ij} = \\boldsymbol{r}_{ij} / r_{ij}$。\n    -   势基：$u(r) = \\sum_{k=0}^{K-1} c_{k} B_{k}(r)$，其中 $B_{k}(r)$ 是三次（$p=3$）B样条基函数。\n    -   样条属性：内部节点处具有 $C^{2}$ 连续性，通过使用端点重复度为 $p+1=4$ 的开放、钳位节点向量实现。\n    -   节点向量 $\\{t_i\\}$：$\\{0.3, 0.3, 0.3, 0.3, 0.5, 0.7, 0.9, 1.1, 1.1, 1.1, 1.1\\}$ nm。\n    -   B样条构造：使用Cox-de Boor递推计算值 $B_{k}(r)$ 和导数 $d B_{k}(r)/dr$。\n    -   FM设计矩阵：$\\boldsymbol{A} \\boldsymbol{c} = \\boldsymbol{y}$，其元素为 $A_{(3i+\\alpha),\\,k} = \\sum_{j \\neq i} \\left( - \\frac{d B_{k}(r_{ij})}{d r} \\right) \\hat{r}_{ij, \\alpha}$。\n    -   测试用例：特定的粒子构型以及关于基和矩阵 $\\boldsymbol{A}$ 属性的查询。\n\n-   **验证结论**：\n    -   **科学依据**：该问题在计算统计力学和数值方法的原理方面有坚实的基础。力匹配、B样条表示和Cox-de Boor算法都是该领域的标准且成熟的技术。\n    -   **适定性**：问题是自包含的，并提供了所有必要的信息：物理模型、数学公式、特定的节点向量、样条次数、粒子构型以及要精确计算的量。基函数的数量 $K$ 可以从节点向量长度（$m+1=11$）和次数（$p=3$）唯一确定为 $K = m-p = (11-1)-3 = 7$。\n    -   **客观性**：问题以精确、客观和数学的语言陈述，没有模糊或主观的元素。\n\n该问题被认为是**有效的**，因为它是科学合理的、适定的和客观的。可以构建一个解决方案。\n\n### 基于原理的解决方案\n\n解决方案首先建立B样条及其在力匹配方法中应用的理论和算法基础，然后进行测试案例的具体计算。\n\n**1. 力匹配框架**\n\n力匹配的目标是通过最小化由 $u(r)$ 预测的力与参考力（通常从更精细的模拟，如全原子模拟中获得）之间的差异，来确定粗粒化势 $u(r)$ 的最优系数 $c_k$。势表示为基函数的线性组合：\n$$\nu(r) = \\sum_{k=0}^{K-1} c_{k} B_{k}(r)\n$$\n粒子 $i$ 上的力是总势能的负梯度，$\\boldsymbol{F}_{i} = -\\nabla_{\\boldsymbol{x}_i} U$。对于由对势描述的系统，这变为：\n$$\n\\boldsymbol{F}_{i} = \\sum_{j \\neq i} -\\frac{d u(r_{ij})}{d r} \\hat{\\boldsymbol{r}}_{ij}\n$$\n代入势的基展开式，我们得到力的线性关系：\n$$\n\\boldsymbol{F}_{i} = \\sum_{j \\neq i} -\\frac{d}{d r} \\left( \\sum_{k=0}^{K-1} c_{k} B_{k}(r_{ij}) \\right) \\hat{\\boldsymbol{r}}_{ij} = \\sum_{k=0}^{K-1} c_{k} \\left( \\sum_{j \\neq i} - \\frac{d B_{k}(r_{ij})}{d r} \\hat{\\boldsymbol{r}}_{ij} \\right)\n$$\n这可以写成一个线性方程组 $\\boldsymbol{A} \\boldsymbol{c} = \\boldsymbol{y}$，其中 $\\boldsymbol{y}$ 是参考力向量，$\\boldsymbol{c}$ 是未知系数向量 $[c_0, \\dots, c_{K-1}]^T$，$\\boldsymbol{A}$ 是设计矩阵。$\\boldsymbol{A}$ 中对应于粒子 $i$ 上的力的第 $\\alpha$ 个笛卡尔分量且与基函数 $B_k$ 相关的元素是：\n$$\nA_{(3i+\\alpha),\\,k} = \\sum_{j \\neq i} \\left( - \\frac{d B_{k}(r_{ij})}{d r} \\right) \\hat{r}_{ij, \\alpha}\n$$\n\n**2. 三次B样条基函数**\n\n基函数 $B_{k}(r)$ 被选为定义在给定节点向量 $T = \\{t_0, t_1, \\dots, t_m\\}$ 上的三次B样条（$p=3$）。基函数的数量是 $K=m-p=7$。样条基的定义域是 $[t_p, t_{m-p}] = [t_3, t_7] = [0.3, 1.1]$。\n\n**Cox-de Boor递推：**\n次数为 $p$ 的B样条基函数 $B_{k,p}(r)$ 通过Cox-de Boor公式构建：\n-   基例（$p=0$）：\n    $$\n    B_{k,0}(r) = \\begin{cases} 1  \\text{if } t_k \\le r  t_{k+1} \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    在域的右边界 $r=t_{m-p}$ 处需要一个特殊约定，其中区间定义严格导致值为0。数学上，样条由其左极限定义。在数值上，可以通过在 $r_{max} - \\epsilon$（对于一个小的 $\\epsilon>0$）处求值来处理。\n-   递推步骤（$p > 0$）：\n    $$\n    B_{k,p}(r) = \\frac{r - t_k}{t_{k+p} - t_k} B_{k,p-1}(r) + \\frac{t_{k+p+1} - r}{t_{k+p+1} - t_{k+1}} B_{k+1,p-1}(r)\n    $$\n    约定是，如果分母为零（由于重复的节点），则相应的项为零。\n\n**B样条的导数：**\nB样条的导数也递归定义：\n$$\n\\frac{d}{dr} B_{k,p}(r) = p \\left( \\frac{B_{k,p-1}(r)}{t_{k+p} - t_k} - \\frac{B_{k+1,p-1}(r)}{t_{k+p+1} - t_{k+1}} \\right)\n$$\n关于零分母的相同约定适用。使用具有单内部节点的钳位节点向量确保样条具有 $C^{p-1} = C^2$ 连续性，其一阶导数在内部节点处具有 $C^1$ 连续性。\n\n**3. 实现与测试用例**\n\n解决方案需要实现这些递推公式，并将其应用于给定的测试用例。对递推函数采用记忆化以避免为相同的输入 `(k, p, r)` 重复计算值。\n\n-   **测试用例1**：一个包含 $N=3$ 个粒子的系统，位置给定。对间距离为 $r_{01} = 0.6$ nm、$r_{02} = 0.8$ nm 和 $r_{12} = 1.0$ nm。通过在这些距离处评估B样条导数，并对每个粒子和力分量求和贡献，来构建 $9 \\times 7$ 的设计矩阵 $\\boldsymbol{A}$。最终结果是弗罗贝尼乌斯范数 $\\|\\boldsymbol{A}\\|_{F} = \\sqrt{\\sum_{i,j} |A_{ij}|^2}$。\n\n-   **测试用例2**：此案例验证B样条导数的连续性。节点向量在 $r_k=0.7$ 处有一个单内部节点。对于在此类向量上定义的三次样条基，每个基函数的导数必须是连续的。测试计算了导数值在节点两侧的跳跃，即 $\\left| \\frac{d B_{k}}{dr}(r_k - \\varepsilon) - \\frac{d B_{k}}{dr}(r_k + \\varepsilon) \\right|$，对于一个小的 $\\varepsilon=10^{-8}$。正如样条理论所预期的，这个跳跃应该在机器精度范围内为零。\n\n-   **测试用例3**：一个包含 $N=2$ 个粒子的系统，间距为 $r_{01} = 1.3$ nm。这个距离位于样条基的支集 $[0.3, 1.1]$ nm 之外。根据定义，任何B样条基函数 $B_k(r)$ 及其导数在其支集之外的 $r$ 值处均为零。因此，所有 $\\frac{d B_k(1.3)}{dr}$ 项都为零。这导致设计矩阵 $\\boldsymbol{A}$ 的所有元素都为零。因此，最大绝对值元素为 $0.0$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the B-spline Force Matching problem.\n    \"\"\"\n    \n    # Global parameters\n    KNOTS = np.array([0.3, 0.3, 0.3, 0.3, 0.5, 0.7, 0.9, 1.1, 1.1, 1.1, 1.1])\n    DEGREE = 3 # p\n    \n    # Memoization caches\n    memo_B = {}\n    memo_dB = {}\n\n    def get_B_spline(k, p, r, knots):\n        \"\"\"\n        Computes the value of the k-th B-spline of degree p at r.\n        Uses the Cox-de Boor recursion with memoization.\n        \"\"\"\n        if (k, p, r) in memo_B:\n            return memo_B[(k, p, r)]\n        \n        # Handle evaluation at the right boundary of the domain\n        # The limit from the left is used, emulated by a small perturbation.\n        if r == knots[-1]:\n            r = r - 1e-12\n\n        if p == 0:\n            val = 1.0 if knots[k] = r  knots[k+1] else 0.0\n            memo_B[(k, p, r)] = val\n            return val\n\n        # First term of the recursion\n        term1 = 0.0\n        den1 = knots[k + p] - knots[k]\n        if den1 != 0.0:\n            term1 = ((r - knots[k]) / den1) * get_B_spline(k, p - 1, r, knots)\n        \n        # Second term of the recursion\n        term2 = 0.0\n        den2 = knots[k + p + 1] - knots[k + 1]\n        if den2 != 0.0:\n            term2 = ((knots[k + p + 1] - r) / den2) * get_B_spline(k + 1, p - 1, r, knots)\n\n        val = term1 + term2\n        memo_B[(k, p, r)] = val\n        return val\n\n    def get_dB_spline(k, p, r, knots):\n        \"\"\"\n        Computes the derivative of the k-th B-spline of degree p at r.\n        Uses the standard formula with memoization.\n        \"\"\"\n        if (k, p, r) in memo_dB:\n            return memo_dB[(k, p, r)]\n\n        # Derivative is zero outside the support [t_k, t_{k+p+1}]\n        if r  knots[k] or r > knots[k+p+1]:\n             memo_dB[(k, p, r)] = 0.0\n             return 0.0\n\n        # Term 1 of the derivative formula\n        term1 = 0.0\n        den1 = knots[k + p] - knots[k]\n        if den1 != 0.0:\n            term1 = get_B_spline(k, p - 1, r, knots) / den1\n\n        # Term 2 of the derivative formula\n        term2 = 0.0\n        den2 = knots[k + p + 1] - knots[k + 1]\n        if den2 != 0.0:\n            term2 = get_B_spline(k + 1, p - 1, r, knots) / den2\n        \n        val = p * (term1 - term2)\n        memo_dB[(k, p, r)] = val\n        return val\n\n    def assemble_A(positions, knots, p):\n        \"\"\"\n        Assembles the Force Matching design matrix A.\n        \"\"\"\n        n_particles = positions.shape[0]\n        m = len(knots) - 1\n        n_basis = m - p\n\n        A = np.zeros((3 * n_particles, n_basis))\n\n        # Clear memoization caches for new assembly\n        memo_B.clear()\n        memo_dB.clear()\n\n        for i in range(n_particles):\n            for k in range(n_basis):\n                sum_vec = np.zeros(3)\n                for j in range(n_particles):\n                    if i == j:\n                        continue\n                    \n                    r_vec = positions[j] - positions[i]\n                    r_norm = np.linalg.norm(r_vec)\n                    \n                    # Handle case where r_norm is 0, though not in test cases\n                    if r_norm == 0:\n                        continue\n                    \n                    r_hat = r_vec / r_norm\n                    \n                    db_dr = get_dB_spline(k, p, r_norm, knots)\n                    \n                    sum_vec += -db_dr * r_hat\n\n                A[3 * i : 3 * i + 3, k] = sum_vec\n        return A\n\n    results = []\n\n    # Test Case 1\n    positions_1 = np.array([\n        [0.0, 0.0, 0.0],\n        [0.6, 0.0, 0.0],\n        [0.0, 0.8, 0.0]\n    ])\n    A1 = assemble_A(positions_1, KNOTS, DEGREE)\n    result_1 = np.linalg.norm(A1, 'fro')\n    results.append(result_1)\n\n    # Test Case 2\n    r_knot = 0.7\n    epsilon = 1e-8\n    m = len(KNOTS) - 1\n    n_basis = m - DEGREE\n    max_jump = 0.0\n    memo_B.clear()\n    memo_dB.clear()\n    for k in range(n_basis):\n        d_left = get_dB_spline(k, DEGREE, r_knot - epsilon, KNOTS)\n        d_right = get_dB_spline(k, DEGREE, r_knot + epsilon, KNOTS)\n        jump = abs(d_left - d_right)\n        if jump > max_jump:\n            max_jump = jump\n    result_2 = max_jump\n    results.append(result_2)\n\n    # Test Case 3\n    positions_3 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.3, 0.0, 0.0]\n    ])\n    A3 = assemble_A(positions_3, KNOTS, DEGREE)\n    result_3 = np.max(np.abs(A3))\n    results.append(result_3)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3438346"}, {"introduction": "迭代玻尔兹曼反演 (Iterative Boltzmann Inversion, IBI) 是一种强大的结构-基粗粒化方法，它通过迭代修正势函数来复现目标径向分布函数 $g(r)$。本练习 [@problem_id:3438347] 不仅介绍了 IBI 的核心思想，更重要的是，它揭示了粗粒化建模中的一个关键挑战——“可表示性”问题，即一个能够精确复现结构的势函数，不一定能保证复现其他热力学性质（如压强）。通过亲手实践，您将学会如何诊断并修正这种由粗粒化引起的热力学性质偏差。", "problem": "您需要对一个二元Lennard–Jones混合物进行完整的粗粒化参数化数值研究，该研究使用迭代玻尔兹曼反演（IBI）方法，并随后进行基于物理的压力校正。目标是复现目标径向分布函数，并诊断该方法为何无法复现压力，然后提出并计算一个用于势能的校正振幅，以匹配指定的压力偏差。\n\n基本原理：\n- 物种 $i$ 和 $j$ 之间的Lennard-Jones对势定义为\n$$\nU_{ij}(r) = 4 \\varepsilon_{ij} \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6 \\right].\n$$\n- 在低密度极限下，径向分布函数与对势的关系为\n$$\ng_{ij}(r) \\approx \\exp\\left(-\\beta U_{ij}(r)\\right), \\quad \\beta = \\frac{1}{k_B T}.\n$$\n- 用于对势的迭代玻尔兹曼反演（IBI）更新规则为\n$$\nU^{(n+1)}_{ij}(r) = U^{(n)}_{ij}(r) + \\Delta U^{(n)}_{ij}(r), \\quad \\Delta U^{(n)}_{ij}(r) = k_B T \\ln\\left(\\frac{g^{(n)}_{ij}(r)}{g_{\\mathrm{target},ij}(r)}\\right),\n$$\n初始猜测为\n$$\nU^{(0)}_{ij}(r) = -k_B T \\ln g_{\\mathrm{target},ij}(r).\n$$\n- 均匀二元混合物的维里路径压力近似为\n$$\nP = \\rho k_B T - \\frac{2\\pi}{3} \\rho^2 \\sum_{i,j \\in \\{A,B\\}} x_i x_j \\int_0^{r_c} r^3 \\frac{dU_{ij}(r)}{dr} g_{ij}(r) \\, dr,\n$$\n其中 $\\rho$ 是数密度，$x_i$ 是摩尔分数，$r_c$ 是截断半径。\n\n研究设置：\n1. 使用约化单位，其中能量单位为 $\\varepsilon_{AA}$，长度单位为 $\\sigma_{AA}$，温度采用传统约化形式 $T^\\star = k_B T / \\varepsilon_{AA}$。在所有计算中，压力以 $\\varepsilon_{AA}/\\sigma_{AA}^3$ 为单位表示，最终的校正振幅以 $\\varepsilon_{AA}$ 为单位表示。\n2. 二元混合物的参数为\n   - $\\varepsilon_{AA} = 1.0$, $\\sigma_{AA} = 1.0$,\n   - $\\varepsilon_{BB} = 0.5$, $\\sigma_{BB} = 0.8$,\n   - $\\varepsilon_{AB} = \\sqrt{\\varepsilon_{AA}\\varepsilon_{BB}}$, $\\sigma_{AB} = (\\sigma_{AA} + \\sigma_{BB})/2$。\n3. 目标结构数据由低密度映射定义\n$$\ng_{\\mathrm{target},ij}(r) = \\exp\\left(-\\beta U_{ij}(r)\\right).\n$$\n4. 在IBI过程中，使用相同的低密度闭合来模拟结构响应\n$$\ng^{(n)}_{ij}(r) = \\exp\\left(-\\beta U^{(n)}_{ij}(r)\\right),\n$$\n并使用混合参数 $0  \\lambda \\leq 1$ 来稳定更新过程，如下所示\n$$\nU^{(n+1)}_{ij}(r) = U^{(n)}_{ij}(r) + \\lambda \\, k_B T \\ln\\left(\\frac{g^{(n)}_{ij}(r)}{g_{\\mathrm{target},ij}(r)}\\right).\n$$\n使用 $\\lambda = 0.2$，进行迭代，直到 $U^{(n)}_{ij}(r)$ 在整个网格上的最大绝对变化小于 $10^{-9}$ 或达到最大迭代次数50次。将 $r \\in [r_{\\min}, r_c]$ 均匀离散化，其中 $r_{\\min} = 0.7 \\, \\sigma_{AA}$，$r_c = 3.0 \\, \\sigma_{AA}$，并使用至少1000个网格点。\n\n诊断与压力校正：\n- 在IBI收敛后，使用上述公式计算维里路径压力 $P_{\\mathrm{calc}}$，其中 $g_{ij}(r) = g_{\\mathrm{target},ij}(r)$。在粗粒化模型下，由于忽略了多体贡献，通过维里路径得到的压力通常会偏离同一状态点下的原子级参考压力。\n- 通过在截断半径内向对势中添加一个平滑的、最小扰动的斜坡项来提出压力校正：\n$$\n\\delta U_{ij}(r) = a \\, s(r), \\quad s(r) = \\frac{r}{r_c}, \\quad 0 \\le r \\le r_c.\n$$\n这会产生一个恒定的导数贡献 $d\\,\\delta U_{ij}/dr = a/r_c$，它可以在不严重扭曲短程结构的情况下修正维里压力。由 $a$ 引起的压力偏移为\n$$\n\\Delta P(a) = -\\frac{2\\pi}{3} \\rho^2 \\sum_{i,j} x_i x_j \\int_0^{r_c} r^3 \\frac{d\\,\\delta U_{ij}(r)}{dr} g_{ij}(r) \\, dr\n= -\\frac{a}{r_c} \\frac{2\\pi}{3} \\rho^2 \\sum_{i,j} x_i x_j \\int_0^{r_c} r^3 g_{ij}(r) \\, dr.\n$$\n给定为每个测试用例定义的目标压力偏移 $\\Delta P_{\\mathrm{ref}}$，选择 $a$ 使得 $\\Delta P(a) = \\Delta P_{\\mathrm{ref}}$，即\n$$\na^\\star = - \\frac{r_c \\, \\Delta P_{\\mathrm{ref}}}{\\frac{2\\pi}{3} \\rho^2 \\displaystyle \\sum_{i,j} x_i x_j \\int_0^{r_c} r^3 g_{ij}(r) \\, dr }.\n$$\n\n测试套件：\n为以下测试用例实现上述过程，每个用例由 $(\\rho, T^\\star, x_A, \\Delta P_{\\mathrm{ref}})$ 指定，其中 $x_B = 1 - x_A$。参考压力偏移 $\\Delta P_{\\mathrm{ref}}$ 是在IBI收敛后，需要加到维里路径压力上的目标校正值，单位为 $\\varepsilon_{AA}/\\sigma_{AA}^3$。\n\n- 用例1（理想路径）：$(\\rho = 0.6, T^\\star = 1.0, x_A = 0.5, \\Delta P_{\\mathrm{ref}} = 0.4)$。\n- 用例2（边界情况：极低密度）：$(\\rho = 0.05, T^\\star = 0.7, x_A = 0.2, \\Delta P_{\\mathrm{ref}} = -0.05)$。\n- 用例3（极端情况：高度不对称组分，零校正）：$(\\rho = 0.85, T^\\star = 1.5, x_A = 0.9, \\Delta P_{\\mathrm{ref}} = 0.0)$。\n\n输出规范：\n- 您的程序必须为每个测试用例计算校正振幅 $a^\\star$，并生成一行包含一个逗号分隔的Python列表，其中包含按所列顺序排列的相应测试用例的三个浮点数值，单位为 $\\varepsilon_{AA}$。例如：“[a1,a2,a3]”。", "solution": "本问题要求实现一个数值研究，以确定二元Lennard-Jones（LJ）混合物的压力校正。该过程涉及分析一个迭代玻尔兹曼反演（IBI）方案，理解其在问题简化假设下的结果，然后计算一个校正振幅 $a^\\star$ 以匹配目标压力偏移 $\\Delta P_{\\mathrm{ref}}$。所有计算都在约化单位下进行，其中 $\\varepsilon_{AA}=1$，$\\sigma_{AA}=1$，温度为 $T^\\star = k_B T / \\varepsilon_{AA}$。\n\n首先，我们定义基本物理模型。物种 $i$ 和 $j$ 的粒子之间的对相互作用由Lennard-Jones势描述：\n$$\nU_{ij}(r) = 4 \\varepsilon_{ij} \\left[\\left(\\frac{\\sigma_{ij}}{r}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r}\\right)^6 \\right]\n$$\n该二元混合物的参数为 $\\varepsilon_{AA} = 1.0$，$\\sigma_{AA} = 1.0$，$\\varepsilon_{BB} = 0.5$，以及 $\\sigma_{BB} = 0.8$。交叉相互作用参数由Lorentz-Berthelot混合定则确定：$\\varepsilon_{AB} = \\sqrt{\\varepsilon_{AA}\\varepsilon_{BB}}$ 和 $\\sigma_{AB} = (\\sigma_{AA} + \\sigma_{BB})/2$。\n\n问题引入了一个迭代玻尔兹曼反演（IBI）程序来确定粗粒化势。IBI更新规则如下：\n$$\nU^{(n+1)}_{ij}(r) = U^{(n)}_{ij}(r) + \\lambda \\, k_B T \\ln\\left(\\frac{g^{(n)}_{ij}(r)}{g_{\\mathrm{target},ij}(r)}\\right)\n$$\n这个问题的一个关键方面是目标径向分布函数 $g_{\\mathrm{target},ij}(r)$ 和模拟的结构响应 $g^{(n)}_{ij}(r)$ 的特定选择。两者都使用将RDF与对势相关联的低密度近似来定义：\n$$\ng_{\\mathrm{target},ij}(r) = \\exp\\left(-\\beta U_{ij}(r)\\right)\n$$\n$$\ng^{(n)}_{ij}(r) = \\exp\\left(-\\beta U^{(n)}_{ij}(r)\\right)\n$$\n其中 $U_{ij}(r)$ 是基本的LJ势，$\\beta = 1/(k_B T)$，$U^{(n)}_{ij}(r)$ 是第 $n$ 次迭代时的势。\n\n让我们在这些假设下分析IBI程序。势的初始猜测为 $U^{(0)}_{ij}(r) = -k_B T \\ln g_{\\mathrm{target},ij}(r)$。代入 $g_{\\mathrm{target},ij}(r)$ 的定义：\n$$\nU^{(0)}_{ij}(r) = -k_B T \\ln\\left(\\exp\\left(-\\beta U_{ij}(r)\\right)\\right) = -k_B T \\left(-\\frac{1}{k_B T} U_{ij}(r)\\right) = U_{ij}(r)\n$$\n初始猜测与作为目标RDF基础的基本LJ势完全相同。现在，我们将 $g^{(n)}_{ij}(r)$ 和 $g_{\\mathrm{target},ij}(r)$ 的关系式代入IBI更新规则中：\n$$\nU^{(n+1)}_{ij}(r) = U^{(n)}_{ij}(r) + \\lambda k_B T \\ln\\left(\\frac{\\exp(-\\beta U^{(n)}_{ij}(r))}{\\exp(-\\beta U_{ij}(r))}\\right) = U^{(n)}_{ij}(r) + \\lambda k_B T \\beta \\left(U_{ij}(r) - U^{(n)}_{ij}(r)\\right)\n$$\n由于 $k_B T \\beta = 1$，这简化为一个线性递推关系：\n$$\nU^{(n+1)}_{ij}(r) = U^{(n)}_{ij}(r) + \\lambda \\left(U_{ij}(r) - U^{(n)}_{ij}(r)\\right) = (1-\\lambda)U^{(n)}_{ij}(r) + \\lambda U_{ij}(r)\n$$\n由于起始势 $U^{(0)}_{ij}(r)$ 已经是 $U_{ij}(r)$，迭代立即收敛：\n$$\nU^{(1)}_{ij}(r) = (1-\\lambda)U_{ij}(r) + \\lambda U_{ij}(r) = U_{ij}(r)\n$$\n因此，在这种情况下，IBI过程是平凡的；“收敛”的粗粒化势就是原始的原子级LJ势 $U_{ij}(r)$。问题的设置虽然看起来需要一个复杂的迭代解，但实际上它被简化了，以至于不需要进行迭代。这突显了一个关键概念：如果系统的结构响应（由 $U(r)$ 得到的 $g(r)$）遵循用于定义目标的相同函数形式，那么像IBI这样基于结构的粗粒化方法可以完美地复现目标势。\n\n主要任务是计算压力校正振幅 $a^\\star$。需要进行这种校正，是因为一个能够复现对结构（RDF）的势并不能保证复现其他热力学性质（如压力），这是粗粒化中一个众所周知的“可表示性”问题。压力 $P$ 通过维里路径计算，对于二元混合物，其表达式为：\n$$\nP = \\rho k_B T - \\frac{2\\pi}{3} \\rho^2 \\sum_{i,j \\in \\{A,B\\}} x_i x_j \\int_0^{r_c} r^3 \\frac{dU_{ij}(r)}{dr} g_{ij}(r) \\, dr\n$$\n问题指定压力计算使用目标RDF，$g_{ij}(r) = g_{\\mathrm{target},ij}(r)$。\n\n所提出的压力校正涉及在 $r \\in [0, r_c]$ 的范围内向势中添加一个简单的线性斜坡项 $\\delta U_{ij}(r) = a (r/r_c)$。此校正的导数是一个常数，$d(\\delta U_{ij})/dr = a/r_c$。由此产生的压力偏移 $\\Delta P(a)$ 为：\n$$\n\\Delta P(a) = -\\frac{2\\pi}{3} \\rho^2 \\sum_{i,j} x_i x_j \\int_0^{r_c} r^3 \\frac{d(\\delta U_{ij}(r))}{dr} g_{ij}(r) \\, dr = -\\frac{a}{r_c} \\frac{2\\pi}{3} \\rho^2 \\sum_{i,j} x_i x_j \\int_0^{r_c} r^3 g_{ij}(r) \\, dr\n$$\n我们需要找到能产生期望压力偏移 $\\Delta P_{\\mathrm{ref}}$ 的振幅 $a^\\star$，使得 $\\Delta P(a^\\star) = \\Delta P_{\\mathrm{ref}}$。求解 $a^\\star$ 可得到问题中提供的公式：\n$$\na^\\star = - \\frac{r_c \\, \\Delta P_{\\mathrm{ref}}}{\\frac{2\\pi}{3} \\rho^2 \\displaystyle \\sum_{i,j \\in \\{A,B\\}} x_i x_j \\int_0^{r_c} r^3 g_{ij}(r) \\, dr }\n$$\n计算步骤如下：\n1. 对于每个测试用例 $(\\rho, T^\\star, x_A, \\Delta P_{\\mathrm{ref}})$，确定计算所需的参数。\n2. 如果 $\\Delta P_{\\mathrm{ref}}=0$，则 $a^\\star=0$ 是一个平凡解。\n3. 为 $r$ 定义一个从 $r_{\\min} = 0.7$ 到 $r_c = 3.0$ 的数值网格。\n4. 在此网格上计算LJ势 $U_{AA}(r)$、$U_{BB}(r)$ 和 $U_{AB}(r)$。\n5. 计算相应的目标RDF，$g_{\\mathrm{target},ij}(r) = \\exp(-U_{ij}(r)/T^\\star)$。\n6. 对每种对类型，数值计算积分 $I_{ij} = \\int_{r_{\\min}}^{r_c} r^3 g_{\\mathrm{target},ij}(r) \\, dr$。积分在定义的网格 $[r_{\\min}, r_c]$ 上进行，这是一个有效的近似，因为当 $r  r_{\\min}$ 时，由于强排斥作用，$g_{ij}(r) \\approx 0$。\n7. 计算这些积分的加权和：$\\mathcal{I}_{\\Sigma} = x_A^2 I_{AA} + 2x_A x_B I_{AB} + x_B^2 I_{BB}$，其中 $x_B = 1-x_A$。\n8. 计算分母 $D = \\frac{2\\pi}{3} \\rho^2 \\mathcal{I}_{\\Sigma}$。\n9. 最后，计算 $a^\\star = - (r_c \\Delta P_{\\mathrm{ref}}) / D$。\n\n将此过程应用于提供的三个测试用例中的每一个，以找到相应的校正振幅。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the pressure correction amplitude for a binary Lennard-Jones mixture.\n    The implementation follows the analysis that the IBI procedure is trivialized\n    by the problem setup, and directly computes the correction amplitude a_star\n    based on the provided formula.\n    \"\"\"\n\n    def lj_potential(r, epsilon, sigma):\n        \"\"\"\n        Calculates the Lennard-Jones potential.\n        Args:\n            r (np.ndarray): Array of distances.\n            epsilon (float): LJ energy parameter.\n            sigma (float): LJ length parameter.\n        Returns:\n            np.ndarray: Potential values.\n        \"\"\"\n        # To avoid overflow with small r, we use a cutoff, though the grid r_min prevents this.\n        # r is guaranteed to be >= 0.7.\n        sig_over_r = sigma / r\n        sig_over_r_6 = sig_over_r**6\n        sig_over_r_12 = sig_over_r_6**2\n        return 4.0 * epsilon * (sig_over_r_12 - sig_over_r_6)\n\n    # Define the test cases from the problem statement.\n    # Format: (rho, T_star, x_A, delta_P_ref)\n    test_cases = [\n        (0.6, 1.0, 0.5, 0.4),   # Case 1\n        (0.05, 0.7, 0.2, -0.05), # Case 2\n        (0.85, 1.5, 0.9, 0.0),  # Case 3\n    ]\n\n    # Global parameters in reduced units\n    eps_AA = 1.0\n    sig_AA = 1.0\n    eps_BB = 0.5\n    sig_BB = 0.8\n\n    # Apply Lorentz-Berthelot mixing rules\n    eps_AB = math.sqrt(eps_AA * eps_BB)\n    sig_AB = (sig_AA + sig_BB) / 2.0\n\n    # Grid parameters\n    r_min = 0.7 * sig_AA\n    r_c = 3.0 * sig_AA\n    num_points = 2000\n    r_grid = np.linspace(r_min, r_c, num_points)\n\n    # Pre-calculate potentials on the grid as they are constant for all tests\n    U_AA = lj_potential(r_grid, eps_AA, sig_AA)\n    U_BB = lj_potential(r_grid, eps_BB, sig_BB)\n    U_AB = lj_potential(r_grid, eps_AB, sig_AB)\n\n    results = []\n    for case in test_cases:\n        rho, T_star, x_A, delta_P_ref = case\n        x_B = 1.0 - x_A\n\n        # Trivial case: if desired pressure correction is zero, amplitude is zero.\n        if delta_P_ref == 0.0:\n            results.append(0.0)\n            continue\n\n        # Calculate target RDFs for the current state point (T_star)\n        # g_target(r) = exp(-beta * U(r)) = exp(-U(r) / (k_B*T)) = exp(-U(r) / T_star)\n        g_target_AA = np.exp(-U_AA / T_star)\n        g_target_BB = np.exp(-U_BB / T_star)\n        g_target_AB = np.exp(-U_AB / T_star)\n\n        # Calculate the integrands for the denominator of a_star\n        integrand_AA = r_grid**3 * g_target_AA\n        integrand_BB = r_grid**3 * g_target_BB\n        integrand_AB = r_grid**3 * g_target_AB\n\n        # Perform numerical integration using the trapezoidal rule\n        I_AA = np.trapz(integrand_AA, r_grid)\n        I_BB = np.trapz(integrand_BB, r_grid)\n        I_AB = np.trapz(integrand_AB, r_grid)\n\n        # Calculate the weighted sum of integrals\n        # Sum = x_A^2 * I_AA + x_A*x_B*I_AB + x_B*x_A*I_BA + x_B^2*I_BB\n        # Since I_AB = I_BA, this simplifies to:\n        integral_sum = x_A**2 * I_AA + 2.0 * x_A * x_B * I_AB + x_B**2 * I_BB\n        \n        # Calculate the denominator of the a_star formula\n        denominator = (2.0 * np.pi / 3.0) * rho**2 * integral_sum\n\n        # Calculate a_star. The denominator should be non-zero for any physical system.\n        if denominator == 0:\n            # This case is highly unlikely given the integrand is positive\n            a_star = float('inf') if delta_P_ref != 0 else 0.0\n        else:\n            numerator = -r_c * delta_P_ref\n            a_star = numerator / denominator\n        \n        results.append(a_star)\n\n    # Format and print the final results as specified\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3438347"}, {"introduction": "真实的分子系统，例如聚合物，通常包含多种类型的相互作用，如键合与非键合相互作用。为了构建一个准确的粗粒化模型，我们必须协同优化所有这些作用势，以同时匹配多个结构性质。本综合练习 [@problem_id:3438326] 将引导您设计并实现一个混合 IBI/FM 的参数化流程，以同时优化对势和弯曲角势，从而确保局部结构和全局链统计量（如末端距）的准确性。这反映了粗粒化建模在面对复杂系统时所面临的真实挑战。", "problem": "考虑一个采用约化无量纲单位的粗粒化单链聚合物模型，其热能满足 $k_{\\mathrm{B}} T = 1$。该粗粒化表示法使用两种相互作用组分：一个用于描述非键合粗粒化珠子之间在标量距离 $r$ 处的中心对势 $U(r)$，以及一个用于控制链上连续键角 $\\theta$ 的谐波弯曲角势 $V(\\theta) = \\tfrac{1}{2} k_{\\theta} (\\theta - \\theta_{0})^{2}$。假设 $\\theta_{0} = 0$（倾向于直线构型）。\n\n聚合物处于正则系综中，您的推导和实现必须从 Boltzmann 分布出发。对于径向距离，假设在低数密度下观测到的约化径向分布函数 $g(r)$ 可以很好地被由 Boltzmann 权重和三维雅可比行列式导出的归一化概率密度 $p_{r}(r)$ 近似，即在有限区间 $r \\in [r_{\\min}, r_{\\max}]$ 上，$p_{r}(r) \\propto r^{2} \\exp\\!\\left(- U(r)\\right)$。对于弯曲角，归一化的角分布 $p_{\\theta}(\\theta)$ 必须包含三维角向雅可比行列式，即在 $\\theta \\in [0,\\pi]$ 上，$p_{\\theta}(\\theta) \\propto \\sin(\\theta)\\, \\exp\\!\\left(- V(\\theta)\\right)$。\n\n您必须设计并实现一个混合参数化工作流，在每次迭代中交替进行两个更新：\n- 使用 Iterative Boltzmann Inversion (IBI) 方法更新对势 $U(r)$。该方法源自 $U(r)$ 与目标径向分布函数之间的 Boltzmann 关系。使用标量步长 $0  \\lambda \\leq 1$ 来正则化更新。\n- 使用 Force Matching (FM) 方法更新弯曲刚度 $k_{\\theta}$。该方法通过寻找在期望上匹配目标参考弯曲力的最小二乘最优参数来推导。使用标量混合因子 $0  \\alpha \\leq 1$ 来正则化更新。\n\n为监控聚合物链的统计数据，在每次迭代中，根据当前的 $p_{\\theta}(\\theta)$ 计算最近邻键相关性 $c = \\langle \\cos(\\theta) \\rangle$，并由此计算一个由 $N$ 个长度为 $b$ 的键组成的离散链的均方末端距：\n$$\n\\langle R^{2} \\rangle = b^{2} \\left[ N + 2 \\sum_{s=1}^{N-1} (N-s) c^{s} \\right].\n$$\n使用此表达式构建一个联合收敛度量，该度量汇总了径向分布、角分布和链末端距统计的结构偏差。具体来说，定义以下三个组分：\n- 径向差异 $D_{r} = \\left( \\int_{r_{\\min}}^{r_{\\max}} \\left[ g_{\\mathrm{model}}(r) - g_{\\mathrm{target}}(r) \\right]^{2}\\, \\mathrm{d}r \\right)^{1/2}$。\n- 角向差异 $D_{\\theta} = \\left( \\int_{0}^{\\pi} \\left[ p_{\\theta,\\mathrm{model}}(\\theta) - p_{\\theta,\\mathrm{target}}(\\theta) \\right]^{2}\\, \\mathrm{d}\\theta \\right)^{1/2}$。\n- 相对末端距误差 $E_{R} = \\left| \\langle R^{2} \\rangle_{\\mathrm{model}} - \\langle R^{2} \\rangle_{\\mathrm{target}} \\right| / \\langle R^{2} \\rangle_{\\mathrm{target}}$。\n\n使用权重 $w_{r} = w_{\\theta} = w_{R} = 1$ 构成一个联合度量 $M = w_{r} D_{r} + w_{\\theta} D_{\\theta} + w_{R} E_{R}$。提出并实现一个基于联合结构度量的停止准则：当 $D_{r}  \\varepsilon_{r}$、$D_{\\theta}  \\varepsilon_{\\theta}$ 和 $E_{R}  \\varepsilon_{R}$，并且在 $m$ 次迭代的滚动窗口内 $M$ 的绝对变化量低于 $\\delta_{\\min}$ 时终止，或者当达到最大迭代次数 $n_{\\max}$ 时终止。\n\n您的程序必须在 $r$ 和 $\\theta$ 的离散化网格上实现此工作流，并使用以下约化单位测试套件。对于每个测试用例，计算满足停止准则所需的迭代次数。所有物理量都是无量纲的；将迭代次数报告为整数。\n\n使用球形 Lennard-Jones 目标对势\n$$\nU_{\\mathrm{LJ}}(r; \\varepsilon, \\sigma) = 4 \\varepsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6} \\right],\n$$\n其中 $\\sigma = 1$。通过归一化的 $r^{2} \\exp\\!\\left( - U_{\\mathrm{LJ}}(r; \\varepsilon_{\\mathrm{target}}, 1) \\right)$ 在 $[r_{\\min}, r_{\\max}]$ 上定义 $g_{\\mathrm{target}}(r)$，并通过归一化的 $\\sin(\\theta) \\exp\\!\\left( - \\tfrac{1}{2} k_{\\theta,\\mathrm{target}} \\theta^{2} \\right)$ 在 $[0,\\pi]$ 上定义 $p_{\\theta,\\mathrm{target}}(\\theta)$。\n\n在所有情况下，设置 $r_{\\min} = 0.8$，$r_{\\max} = 3.0$，均匀间距 $\\Delta r = 0.005$，$\\Delta \\theta = 0.001$，$b = 1$ 以及 $k_{\\mathrm{B}} T = 1$。在每次迭代中，应用 IBI 更新\n$$\nU_{n+1}(r) = U_{n}(r) + \\lambda \\ln\\!\\left( \\frac{g_{n}(r)}{g_{\\mathrm{target}}(r)} \\right),\n$$\n以及通过对参考力 $F_{\\mathrm{target}}(\\theta) = - \\partial_{\\theta} V_{\\mathrm{target}}(\\theta) = - k_{\\theta,\\mathrm{target}} (\\theta - \\theta_{0})$ 进行最小二乘的 FM 更新来更新 $k_{\\theta}$：\n$$\nk_{\\theta}^{\\ast} = - \\frac{ \\int_{0}^{\\pi} (\\theta - \\theta_{0}) F_{\\mathrm{target}}(\\theta)\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta }{ \\int_{0}^{\\pi} (\\theta - \\theta_{0})^{2}\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta },\n\\quad\nk_{\\theta, n+1} = (1-\\alpha)\\, k_{\\theta, n} + \\alpha\\, k_{\\theta}^{\\ast}.\n$$\n在计算概率密度的比率或对数时，通过添加一个小的常数 $\\eta = 10^{-12}$ 来进行正则化，以避免除以零。\n\n测试套件：\n- 情况 1（一般情况）：$(\\varepsilon_{\\mathrm{target}} = 1.0,\\; k_{\\theta,\\mathrm{target}} = 5.0,\\; N = 20,\\; \\lambda = 0.5,\\; \\alpha = 0.5,\\; \\varepsilon_{r} = 10^{-3},\\; \\varepsilon_{\\theta} = 10^{-3},\\; \\varepsilon_{R} = 5\\times 10^{-3},\\; m = 5,\\; \\delta_{\\min} = 10^{-4},\\; n_{\\max} = 100)$，初始猜测为 $U_{0}(r) = 0$ 和 $k_{\\theta,0} = 0.5$。\n- 情况 2（对相互作用消失的边界情况）：$(\\varepsilon_{\\mathrm{target}} = 0.0,\\; k_{\\theta,\\mathrm{target}} = 2.0,\\; N = 10,\\; \\lambda = 0.7,\\; \\alpha = 0.7,\\; \\varepsilon_{r} = 10^{-4},\\; \\varepsilon_{\\theta} = 10^{-3},\\; \\varepsilon_{R} = 10^{-3},\\; m = 5,\\; \\delta_{\\min} = 10^{-5},\\; n_{\\max} = 100)$，初始猜测为 $U_{0}(r) = 4 \\times 2.0 \\left[ (1/r)^{12} - (1/r)^{6} \\right]$（即 $\\varepsilon = 2.0$）和 $k_{\\theta,0} = 0.2$。\n- 情况 3（角度非常刚性的边缘情况）：$(\\varepsilon_{\\mathrm{target}} = 0.5,\\; k_{\\theta,\\mathrm{target}} = 20.0,\\; N = 30,\\; \\lambda = 0.4,\\; \\alpha = 0.3,\\; \\varepsilon_{r} = 10^{-3},\\; \\varepsilon_{\\theta} = 10^{-4},\\; \\varepsilon_{R} = 10^{-3},\\; m = 5,\\; \\delta_{\\min} = 10^{-4},\\; n_{\\max} = 150)$，初始猜测为 $U_{0}(r) = 4 \\times 1.5 \\left[ (1/r)^{12} - (1/r)^{6} \\right]$（即 $\\varepsilon = 1.5$）和 $k_{\\theta,0} = 1.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[n_{1},n_{2},n_{3}]$），其中每个 $n_{i}$ 是相应测试用例执行至终止的整数迭代次数。不允许有任何其他输出。", "solution": "该问题要求为粗粒化聚合物模型设计并实现一个混合迭代参数化方案。其目标是优化对势 $U(r)$ 和弯曲刚度常数 $k_{\\theta}$，以重现从参考系统派生的目标结构特性。该工作流结合了用于对势的 Iterative Boltzmann Inversion (IBI) 和用于弯曲刚度的 Force Matching (FM)。整个过程在热能 $k_{\\mathrm{B}} T = 1$ 的约化无量纲单位中进行。\n\n该方法的基础在于统计力学原理，特别是 Boltzmann 分布，它将微观相互作用势与宏观、可观测的概率分布联系起来。\n\n1.  **目标系统和性质定义**\n\n参考或“目标”系统由一组特定的势定义：Lennard-Jones 对势 $U_{\\mathrm{LJ}}(r; \\varepsilon_{\\mathrm{target}}, \\sigma)$ 和谐波角势 $V_{\\mathrm{target}}(\\theta) = \\frac{1}{2} k_{\\theta,\\mathrm{target}} (\\theta - \\theta_{0})^2$。在给定条件 $\\theta_{0}=0$ 下，这简化为 $V_{\\mathrm{target}}(\\theta) = \\frac{1}{2} k_{\\theta,\\mathrm{target}} \\theta^2$。\n\n从这些势中，我们推导出目标结构性质。目标径向分布函数 $g_{\\mathrm{target}}(r)$ 是在距离 $r$ 处找到两个非键合珠子的归一化概率密度。它源自 Boltzmann 权重，并包含了球坐标下的三维雅可比行列式 ($4\\pi r^2$)。\n$$\ng_{\\mathrm{target}}(r) = \\frac{r^2 \\exp(-U_{\\mathrm{LJ}}(r; \\varepsilon_{\\mathrm{target}}, \\sigma=1) / (k_{\\mathrm{B}}T))}{\\int_{r_{\\min}}^{r_{\\max}} r'^2 \\exp(-U_{\\mathrm{LJ}}(r'; \\varepsilon_{\\mathrm{target}}, \\sigma=1) / (k_{\\mathrm{B}}T)) \\, \\mathrm{d}r'}\n$$\n类似地，目标键角分布 $p_{\\theta,\\mathrm{target}}(\\theta)$ 是三个连续珠子之间夹角 $\\theta$ 的归一化概率密度。它包含了三维角向雅可比行列式 ($\\sin(\\theta)$)。\n$$\np_{\\theta,\\mathrm{target}}(\\theta) = \\frac{\\sin(\\theta) \\exp(-V_{\\mathrm{target}}(\\theta) / (k_{\\mathrm{B}}T))}{\\int_{0}^{\\pi} \\sin(\\theta') \\exp(-V_{\\mathrm{target}}(\\theta') / (k_{\\mathrm{B}}T)) \\, \\mathrm{d}\\theta'}\n$$\n从 $p_{\\theta,\\mathrm{target}}(\\theta)$，我们计算目标键相关性 $c_{\\mathrm{target}} = \\langle \\cos(\\theta) \\rangle_{\\mathrm{target}} = \\int_0^\\pi \\cos(\\theta) p_{\\theta,\\mathrm{target}}(\\theta) \\mathrm{d}\\theta$。这又决定了由 $N$ 个长度为 $b$ 的键组成的链的目标均方末端距 $\\langle R^2 \\rangle_{\\mathrm{target}}$。\n$$\n\\langle R^{2} \\rangle_{\\mathrm{target}} = b^{2} \\left[ N + 2 \\sum_{s=1}^{N-1} (N-s) c_{\\mathrm{target}}^{s} \\right]\n$$\n这三个量——$g_{\\mathrm{target}}(r)$、$p_{\\theta,\\mathrm{target}}(\\theta)$ 和 $\\langle R^2 \\rangle_{\\mathrm{target}}$——构成了我们的模型必须重现的参考数据。\n\n2.  **迭代优化算法**\n\n解决方案的核心是一个迭代循环，它逐步优化模型参数 $U(r)$ 和 $k_{\\theta}$。\n从初始猜测 $U_0(r)$ 和 $k_{\\theta,0}$ 开始，算法通过由 $n$ 索引的迭代进行。在每次迭代 $n$ 中，我们有一个由 $(U_n, k_{\\theta,n})$ 定义的模型。\n\n**用于 $U(r)$ 的 Iterative Boltzmann Inversion (IBI) 更新**：\nIBI 方法根据当前模型的径向分布函数 $g_n(r)$ 与目标 $g_{\\mathrm{target}}(r)$ 之间的差异来优化势。更新规则源自反演 Boltzmann 关系 $g(r) \\propto \\exp(-U(r))$，并通过向势添加一个校正项来实现。在 $k_{\\mathrm{B}} T = 1$ 的情况下，下一次迭代的势 $U_{n+1}(r)$ 的更新为：\n$$\nU_{n+1}(r) = U_{n}(r) + \\lambda \\ln\\left( \\frac{g_{n}(r)}{g_{\\mathrm{target}}(r)} \\right)\n$$\n这里，$g_n(r)$ 是从 $U_n(r)$ 生成的径向分布函数。参数 $0  \\lambda \\le 1$ 是一个步长或阻尼因子，用于控制更新的幅度，从而提高稳定性并防止过度校正。为避免分布接近零时出现数值问题，该比率被正则化为 $\\ln\\left( (g_{n}(r) + \\eta) / (g_{\\mathrm{target}}(r) + \\eta) \\right)$，其中 $\\eta$ 是一个小的常数。\n\n**用于 $k_{\\theta}$ 的 Force Matching (FM) 更新**：\nForce Matching 旨在在最小二乘意义上找到最能重现一组参考力的参数。对于谐波势 $V(\\theta) = \\frac{1}{2} k_{\\theta} (\\theta - \\theta_0)^2$，相应的力（广义力矩）是 $F(\\theta) = - \\partial V / \\partial \\theta = -k_{\\theta}(\\theta - \\theta_0)$。问题给出了最小二乘最优刚度 $k_{\\theta}^{\\ast}$：\n$$\nk_{\\theta}^{\\ast} = - \\frac{ \\int_{0}^{\\pi} (\\theta - \\theta_{0}) F_{\\mathrm{target}}(\\theta)\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta }{ \\int_{0}^{\\pi} (\\theta - \\theta_{0})^{2}\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta }\n$$\n关键的是，将目标力 $F_{\\mathrm{target}}(\\theta) = -k_{\\theta,\\mathrm{target}}(\\theta-\\theta_0)$ 代入此表达式会导致一个显著的简化：\n$$\nk_{\\theta}^{\\ast} = - \\frac{ \\int (\\theta - \\theta_{0}) [-k_{\\theta,\\mathrm{target}}(\\theta-\\theta_0)]\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta }{ \\int (\\theta - \\theta_{0})^{2}\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta } = k_{\\theta,\\mathrm{target}} \\frac{ \\int (\\theta - \\theta_{0})^{2}\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta }{ \\int (\\theta - \\theta_{0})^{2}\\, p_{\\theta,\\mathrm{target}}(\\theta)\\, \\mathrm{d}\\theta } = k_{\\theta, \\mathrm{target}}\n$$\n这种简化之所以出现，是因为期望值是相对于目标分布本身计算的。因此，最优参数就是目标参数。$k_{\\theta}$ 的更新规则变成了一个朝向这个已知目标值的指数松弛：\n$$\nk_{\\theta, n+1} = (1-\\alpha)\\, k_{\\theta, n} + \\alpha\\, k_{\\theta}^{\\ast} = (1-\\alpha)\\, k_{\\theta, n} + \\alpha\\, k_{\\theta, \\mathrm{target}}\n$$\n混合因子 $0  \\alpha \\le 1$ 控制了这种松弛的速率。\n\n3.  **收敛监控和终止**\n\n在每次迭代 $n$ 中，我们使用三个定量度量来评估当前模型 $(U_n, k_{\\theta,n})$ 的质量：\n-   径向差异：$D_{r} = \\left( \\int_{r_{\\min}}^{r_{\\max}} \\left[ g_{n}(r) - g_{\\mathrm{target}}(r) \\right]^{2}\\, \\mathrm{d}r \\right)^{1/2}$\n-   角向差异：$D_{\\theta} = \\left( \\int_{0}^{\\pi} \\left[ p_{\\theta,n}(\\theta) - p_{\\theta,\\mathrm{target}}(\\theta) \\right]^{2}\\, \\mathrm{d}\\theta \\right)^{1/2}$\n-   相对末端距误差：$E_{R} = \\left| \\langle R^{2} \\rangle_{n} - \\langle R^{2} \\rangle_{\\mathrm{target}} \\right| / \\langle R^{2} \\rangle_{\\mathrm{target}}$\n\n这些被组合成一个单一的联合度量 $M = D_r + D_\\theta + E_R$（使用单位权重）。迭代过程基于一个复合准则终止：如果 (1) 所有三个单独的度量都低于它们各自的阈值（$D_r  \\varepsilon_r$、$D_\\theta  \\varepsilon_\\theta$、$E_R  \\varepsilon_R$），并且 (2) 优化过程已停滞，即联合度量 $M$ 在 $m$ 次迭代的滚动窗口内的绝对变化小于一个最小值 $\\delta_{\\min}$，则宣布收敛。如果达到最大迭代次数 $n_{\\max}$，过程也会停止。\n\n4.  **数值策略**\n\n连续函数和积分通过数值方法处理。$r \\in [r_{\\min}, r_{\\max}]$ 和 $\\theta \\in [0, \\pi]$ 的域被离散化为均匀网格。所有积分随后使用数值积分（特别是梯形法则）计算，这对于细密间隔的网格是合适的。$\\langle R^2 \\rangle$ 的表达式通过直接求和来计算。整个算法实现为一个循环，对于每个测试用例，该循环迭代地优化势并检查收敛性，最终报告所需的迭代次数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef U_lj(r, eps, sigma=1.0):\n    \"\"\"Calculates the Lennard-Jones potential.\"\"\"\n    # The grid starts at r_min > 0, so r=0 is not a concern.\n    inv_r = sigma / r\n    inv_r6 = inv_r**6\n    inv_r12 = inv_r6**2\n    return 4.0 * eps * (inv_r12 - inv_r6)\n\ndef V_harmonic(theta, k, theta0=0.0):\n    \"\"\"Calculates the harmonic angle potential.\"\"\"\n    return 0.5 * k * (theta - theta0)**2\n\ndef calculate_R2(N, b, c):\n    \"\"\"\n    Calculates the mean-squared end-to-end distance for a discrete chain.", "id": "3438326"}]}