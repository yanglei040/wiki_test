{"hands_on_practices": [{"introduction": "本次首个实践为热力学积分方法提供了一个关键的验证。我们将对一维伊辛模型应用热力学积分，这是一个统计力学中的基石模型，其自由能可以通过传递矩阵法得到精确的解析解。通过将数值积分得到的热力学积分结果与精确答案进行比较，您可以验证自己对核心TI原理的理解和实现。[@problem_id:3495938]", "problem": "考虑一个一维二元自旋晶格（类伊辛模型），该晶格具有周期性边界条件和最近邻相互作用，并采用约化单位，其中玻尔兹曼常数 $k_{\\mathrm{B}}$ 等于 $1$。设该晶格有 $N$ 个格点，自旋为 $s_i \\in \\{-1, +1\\}$，并通过耦合参数 $\\lambda \\in [0,1]$ 缩放相互作用强度来定义一个参数化势能 $U(\\lambda)$：\n$$\nU(\\lambda) = -\\lambda J \\sum_{i=1}^{N} s_i s_{i+1},\n$$\n其中 $s_{N+1} \\equiv s_1$，相互作用能标为 $J \\in \\mathbb{R}$，温度为 $T > 0$。正则配分函数为\n$$\nZ(\\lambda) = \\sum_{\\{s_i\\}} \\exp\\left(-\\beta U(\\lambda)\\right),\n$$\n其中 $\\beta = 1/T$，亥姆霍兹自由能为\n$$\nF(\\lambda) = -T \\ln Z(\\lambda).\n$$\n热力学积分将 $\\lambda = 0$ 和 $\\lambda = 1$ 之间的自由能差与势能对 $\\lambda$ 的导数的系综平均值关联起来：\n$$\nF(1) - F(0) = \\int_{0}^{1} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda.\n$$\n在 $\\lambda = 0$ 时，格点之间无相互作用；因此，配分函数可以因子分解，每格点自由能 $f(0) \\equiv F(0)/N$ 可以直接从 $Z(\\lambda)$ 的定义中获得。\n\n另外，转移矩阵法通过构建一个由最近邻自旋对的玻尔兹曼权重组成的 $2 \\times 2$ 转移矩阵，并取该矩阵的最大特征值 $\\Lambda_{\\max}$，从而在热力学极限下给出了每格点自由能的精确解。在 $N \\to \\infty$ 极限下，精确的每格点自由能为\n$$\nf_{\\mathrm{TM}} = -\\frac{T}{N} \\lim_{N \\to \\infty} \\ln \\operatorname{Tr}\\left(\\mathbf{T}^N\\right) = -T \\ln \\Lambda_{\\max}.\n$$\n你的任务是：\n- 从正则系综定义和导数 $\\partial U/\\partial \\lambda$ 出发，推导热力学积分中每格点被积函数（即系综平均 $\\left\\langle \\partial U(\\lambda)/\\partial \\lambda \\right\\rangle_{\\lambda}$ 除以 $N$）的闭式表达式，该表达式是 $\\lambda$、$J$ 和 $T$ 的函数。然后，用此被积函数的积分加上解析已知的 $f(0)$ 来表示在 $\\lambda = 1$ 时通过热力学积分得到的每格点自由能（记为 $f_{\\mathrm{TI}}$）。\n- 独立地，为一维最近邻相互作用且无外场的情况构建转移矩阵，并从其最大特征值计算在 $\\lambda = 1$ 时的精确每格点自由能 $f_{\\mathrm{TM}}$。\n- 在一个程序中用数值方法实现这两种计算：通过对 $\\lambda \\in [0,1]$ 上的被积函数进行数值积分来计算 $f_{\\mathrm{TI}}$，以及从转移矩阵的最大特征值计算 $f_{\\mathrm{TM}}$。通过报告绝对差 $|f_{\\mathrm{TI}} - f_{\\mathrm{TM}}|$ 来验证数值上的一致性。\n\n使用约化单位，其中 $k_{\\mathrm{B}} = 1$，并以能量单位报告每格点自由能。不使用角度。所有输出必须是浮点数。你的程序必须计算并在一行内打印一个用方括号括起来的逗号分隔列表，其中包含针对以下 $(J, T)$ 值测试组的绝对差 $|f_{\\mathrm{TI}} - f_{\\mathrm{TM}}|$：\n- 情况 1：$J = 1.2$，$T = 2.5$。\n- 情况 2：$J = 0.0$，$T = 1.0$。\n- 情况 3：$J = 3.0$，$T = 0.5$。\n- 情况 4：$J = -1.5$，$T = 1.3$。\n- 情况 5：$J = 0.7$，$T = 100.0$。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是四舍五入到 $12$ 位小数的绝对差（即，在 $10^{-12}$ 的绝对容差内）。", "solution": "问题陈述经评估有效。其科学基础是统计力学原理，具体来说是一维伊辛模型。该问题提法明确、客观且内部一致，为推导和数值比较计算亥姆霍兹自由能的两种方法提供了所有必要信息。\n\n求解过程分为三个部分：第一，通过热力学积分得到的每格点自由能的表达式 $f_{\\mathrm{TI}}$；第二，通过转移矩阵法得到的表达式 $f_{\\mathrm{TM}}$；第三，数值实现和比较的策略。\n\n### 1. 热力学积分自由能 ($f_{\\mathrm{TI}}$)\n\n由 $\\lambda=1$ 和 $\\lambda=0$ 描述的状态之间的每格点自由能差 $f(\\lambda) = F(\\lambda)/N$ 由热力学积分公式给出：\n$$\nf(1) - f(0) = \\frac{1}{N} \\int_{0}^{1} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda\n$$\n参数化势能为 $U(\\lambda) = -\\lambda J \\sum_{i=1}^{N} s_i s_{i+1}$。其对耦合参数 $\\lambda$ 的导数为：\n$$\n\\frac{\\partial U(\\lambda)}{\\partial \\lambda} = -J \\sum_{i=1}^{N} s_i s_{i+1}\n$$\n每格点的被积函数是该导数的系综平均值除以格点数 $N$：\n$$\n\\frac{1}{N} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} = \\frac{1}{N} \\left\\langle -J \\sum_{i=1}^{N} s_i s_{i+1} \\right\\rangle_{\\lambda}\n$$\n由于系统在周期性边界条件下的平移不变性，最近邻自旋关联 $\\langle s_i s_{i+1} \\rangle_{\\lambda}$ 对所有格点 $i$ 都是相同的。因此，表达式简化为：\n$$\n\\frac{1}{N} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} = -J \\langle s_1 s_2 \\rangle_{\\lambda}\n$$\n对于一维伊辛模型，在热力学极限（$N \\to \\infty$）下，最近邻关联函数是一个标准结果，由下式给出：\n$$\n\\langle s_1 s_2 \\rangle_{\\lambda} = \\tanh(\\beta \\lambda J) = \\tanh\\left(\\frac{\\lambda J}{T}\\right)\n$$\n其中 $\\beta = 1/T$ 且 $k_B=1$。因此，每格点被积函数的闭式表达式为：\n$$\n\\frac{1}{N} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} = -J \\tanh\\left(\\frac{\\lambda J}{T}\\right)\n$$\n接下来，我们确定初始的每格点自由能 $f(0)$。在 $\\lambda=0$ 时，势能为 $U(0)=0$。自旋之间无相互作用。配分函数 $Z(0)$ 是对所有可能的 $2^N$ 种自旋构型的求和：\n$$\nZ(0) = \\sum_{\\{s_i\\}} \\exp(-\\beta U(0)) = \\sum_{\\{s_i\\}} e^0 = 2^N\n$$\n相应的自由能为 $F(0) = -T \\ln Z(0) = -T \\ln(2^N) = -NT \\ln(2)$。每格点自由能为：\n$$\nf(0) = \\frac{F(0)}{N} = -T \\ln(2)\n$$\n结合这些结果，在 $\\lambda=1$ 时的每格点自由能（记为 $f_{\\mathrm{TI}}$）表示为：\n$$\nf_{\\mathrm{TI}} = f(1) = f(0) + \\int_{0}^{1} \\left(-J \\tanh\\left(\\frac{\\lambda J}{T}\\right)\\right) \\, d\\lambda = -T \\ln(2) - J \\int_{0}^{1} \\tanh\\left(\\frac{\\lambda J}{T}\\right) \\, d\\lambda\n$$\n该表达式将通过数值计算积分来求值。\n\n### 2. 转移矩阵自由能 ($f_{\\mathrm{TM}}$)\n\n转移矩阵法为一维伊辛模型在热力学极限下的自由能提供了一个精确解。转移矩阵 $\\mathbf{T}$ 连接相邻自旋，其元素是相互作用能的玻尔兹曼权重。对于自旋 $s_i, s_{i+1} \\in \\{-1, +1\\}$ 且 $\\lambda=1$，矩阵元素由 $T_{s_i, s_{i+1}} = \\exp(-\\beta(-J s_i s_{i+1})) = \\exp(\\beta J s_i s_{i+1})$ 给出。这得到一个 $2 \\times 2$ 的矩阵：\n$$\n\\mathbf{T} = \\begin{pmatrix} T_{1,1} & T_{1,-1} \\\\ T_{-1,1} & T_{-1,-1} \\end{pmatrix} = \\begin{pmatrix} e^{\\beta J} & e^{-\\beta J} \\\\ e^{-\\beta J} & e^{\\beta J} \\end{pmatrix}\n$$\n特征值 $\\Lambda$ 通过求解特征方程 $\\det(\\mathbf{T} - \\Lambda \\mathbf{I}) = 0$ 得到：\n$$\n(e^{\\beta J} - \\Lambda)^2 - (e^{-\\beta J})^2 = 0 \\implies \\Lambda = e^{\\beta J} \\pm e^{-\\beta J}\n$$\n两个特征值为 $\\Lambda_1 = e^{\\beta J} + e^{-\\beta J} = 2 \\cosh(\\beta J)$ 和 $\\Lambda_2 = e^{\\beta J} - e^{-\\beta J} = 2 \\sinh(\\beta J)$。最大特征值为 $\\Lambda_{\\max} = \\Lambda_1 = 2 \\cosh(\\beta J)$，因为对于所有实数 $x$，都有 $\\cosh(x) \\ge |\\sinh(x)|$。\n\n在热力学极限 $N \\to \\infty$ 下，每格点自由能与转移矩阵的最大特征值相关：\n$$\nf_{\\mathrm{TM}} = -T \\ln(\\Lambda_{\\max})\n$$\n代入 $\\Lambda_{\\max}$ 的表达式，得到精确的解析结果：\n$$\nf_{\\mathrm{TM}} = -T \\ln\\left(2 \\cosh\\left(\\frac{J}{T}\\right)\\right)\n$$\n\n### 3. 数值计算策略\n\n问题要求对两种方法进行数值比较。\n对于 $f_{\\mathrm{TI}}$：$f_{\\mathrm{TI}}$ 表达式中的积分将使用数值积分计算，具体来说，是使用 `scipy.integrate` 库中的 `quad` 函数。初始自由能 $f(0) = -T \\ln(2)$ 会加到积分的数值结果上。为确保高精度，积分程序的容差将设置为比所需输出精度更小的值（例如，$10^{-15}$）。\n对于 $f_{\\mathrm{TM}}$：对于给定的 $J$ 和 $T$，将数值构建转移矩阵 $\\mathbf{T}$。其特征值使用 `numpy.linalg.eigvalsh` 计算，该函数针对实对称矩阵进行了优化。确定最大特征值 $\\Lambda_{\\max}$ 后，使用公式 $f_{\\mathrm{TM}} = -T \\ln(\\Lambda_{\\max})$ 计算 $f_{\\mathrm{TM}}$。\n最后，对每个测试用例计算绝对差 $|f_{\\mathrm{TI}} - f_{\\mathrm{TM}}|$。这个差值应接近于零，代表了数值积分的误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes and prints the absolute difference between the free energy per site\n    of a 1D Ising model calculated via thermodynamic integration (TI) and the transfer\n    matrix (TM) method for a suite of test cases.\n    \"\"\"\n\n    def solve_case(J, T):\n        \"\"\"\n        Computes the absolute difference |f_TI - f_TM| for a given pair (J, T).\n\n        Args:\n            J (float): The interaction energy scale.\n            T (float): The temperature.\n\n        Returns:\n            float: The absolute difference |f_TI - f_TM|.\n        \"\"\"\n        # Common parameter beta = 1/(k_B * T) with k_B = 1\n        beta = 1.0 / T\n\n        # --- Thermodynamic Integration (TI) Calculation ---\n        \n        # The free energy per site at lambda=0 (non-interacting system)\n        f0 = -T * np.log(2.0)\n\n        # The integrand for TI is the ensemble average of dU/d(lambda) per site,\n        # which evaluates to -J * tanh(lambda * J / T).\n        # We integrate this from lambda = 0 to 1.\n        if J == 0.0:\n            # If J is 0, the integrand is always 0.\n            integral_val = 0.0\n        else:\n            K = beta * J\n            integrand = lambda lam: -J * np.tanh(lam * K)\n            # Use high precision for quadrature for an accurate comparison.\n            integral_val, _ = quad(integrand, 0, 1, epsabs=1e-15, epsrel=1e-15)\n\n        # The TI free energy at lambda=1\n        f_TI = f0 + integral_val\n\n        # --- Transfer Matrix (TM) Calculation ---\n\n        # The transfer matrix connects states of adjacent spins. For lambda=1:\n        # T_ij = exp(beta * J * s_i * s_j)\n        # T = [[exp(beta*J), exp(-beta*J)], [exp(-beta*J), exp(beta*J)]]\n        # Instead of forming the matrix, we use the analytical eigenvalue solution.\n        # Lambda_max = 2 * cosh(beta * J)\n        K_full = beta * J\n        lambda_max = 2.0 * np.cosh(K_full)\n\n        # The TM free energy per site is f_TM = -T * ln(Lambda_max).\n        f_TM = -T * np.log(lambda_max)\n        \n        # Calculate the absolute difference between the two methods.\n        abs_diff = np.abs(f_TI - f_TM)\n        \n        return abs_diff\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.2, 2.5),   # Case 1\n        (0.0, 1.0),   # Case 2\n        (3.0, 0.5),   # Case 3\n        (-1.5, 1.3),  # Case 4\n        (0.7, 100.0)  # Case 5\n    ]\n\n    results = []\n    for J, T in test_cases:\n        difference = solve_case(J, T)\n        results.append(difference)\n\n    # Format the results as strings rounded to 12 decimal places.\n    results_str = [f\"{r:.12f}\" for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3495938"}, {"introduction": "在基础框架之上，本练习展示了热力学积分在探索材料对外界刺激响应方面的强大能力。我们将进入一个二维参数空间，同时改变一个炼金术耦合参数和一个外部场。这项实践将使您掌握计算场依赖自由能的方法，这是预测材料极化或压电系数等性质的关键一步。[@problem_id:3495969]", "problem": "你需要使用热力学积分 (Thermodynamic Integration, TI)，从正则系综的配分函数和玻尔兹曼概率的定义出发，形式化并计算场相关的亥姆霍兹自由能差。你的任务是：(i) 从第一性原理出发，推导与外场的耦合如何改变依赖于参数的势能及由此产生的 TI 被积函数；(ii) 提出沿参数空间中预定路径的同时参数 TI 方法；(iii) 实现一个程序，以完全自洽的方式评估指定代理模型的自由能变化。\n\n你必须使用并基于以下基本原理：\n- 逆温为 $\\beta$ 的正则系综，其配分函数为 $Z(\\alpha) = \\int \\exp\\!\\left[-\\beta \\, U(\\boldsymbol{r};\\alpha)\\right] \\, d\\boldsymbol{r}$，亥姆霍兹自由能为 $F(\\alpha) = -\\beta^{-1} \\ln Z(\\alpha)$。\n- 玻尔兹曼概率密度与 $\\exp\\!\\left[-\\beta \\, U(\\boldsymbol{r};\\alpha)\\right]$ 成正比。\n- 对 $Z(\\alpha)$ 进行积分号下微分，以及在固定 $\\alpha$ 下，相对于玻尔兹曼权重的系综平均 $\\langle \\cdot \\rangle_{\\alpha}$ 的定义。\n- 外场与其在哈密顿量中的共轭广义坐标的线性响应式耦合（未提供明确公式；你必须推导其结果）。\n\n待分析和计算的模型系统：\n- 考虑一个一维代理自由度 $x \\in \\mathbb{R}$，它代表材料中的一个粗粒化模式。其势能为\n$$\nU(x;\\lambda,h) \\;=\\; \\tfrac{1}{2}\\,\\big(k_0 + \\lambda\\,\\Delta k\\big)\\,x^2 \\;-\\; h\\,c\\,x,\n$$\n其中 $k_0>0$ 和 $\\Delta k$ 是刚度参数，$c>0$ 是耦合振幅，$\\lambda \\in [0,1]$ 是一个改变刚度的炼金参数，$h$ 是一个外部标量场，可以在标量化设置中代表电场或均匀应变场。状态点由 $(\\lambda,h,\\beta)$ 指定，其中 $\\beta = 1/(k_{\\mathrm{B}}T)$。\n\n在实现之前你必须完成的推导目标：\n1. 从正则系综的定义出发，严格推导自由能 $F(\\lambda,h)$ 是 $(\\lambda,h)$ 的状态函数，并且其全微分 $dF$ 可以用在固定 $(\\lambda,h)$ 下 $U$ 对 $\\lambda$ 和 $h$ 的偏导数的系综平均值来表示。不要假设任何 TI 公式的形式；从 $Z$ 和 $F$ 推导出它。\n2. 将通用表达式具体化到给定的二次模型，获得必要系综平均值的闭合形式表达式，用 $k(\\lambda) \\equiv k_0 + \\lambda \\Delta k$, $c$, $h$ 和 $\\beta$ 表示。仅使用可从玻尔兹曼权重推导出的高斯积分恒等式。\n\n待实现的同步参数 TI：\n- 设目标状态为 $(\\lambda_\\star,h_\\star)$，参考状态为 $(0,0)$。用单个标量 $\\zeta \\in [0,1]$ 参数化 $(\\lambda,h)$ 平面中的一条直线路径：\n$$\n\\lambda(\\zeta) = \\lambda_\\star\\,\\zeta, \\qquad h(\\zeta) = h_\\star\\,\\zeta.\n$$\n- 将自由能变化 $\\Delta F = F(\\lambda_\\star,h_\\star) - F(0,0)$ 表示为一个关于 $\\zeta$ 的一维积分，该积分涉及在 $(\\lambda(\\zeta),h(\\zeta))$ 处评估的系综平均值以及路径导数 $d\\lambda/d\\zeta$ 和 $dh/d\\zeta$。\n- 为进行数值评估，使用高精度的复合辛普森法则 (composite Simpson rule) 来近似 $\\zeta$-积分。你的程序必须以 $k_{\\mathrm{B}}T$ 为单位计算并报告 $\\Delta F$，即报告无量纲数 $\\beta\\,\\Delta F$。\n\n用于验证的解析基准：\n- 对于这个特定的二次模型，通过计算 $(\\lambda_\\star,h_\\star)$ 和 $(0,0)$ 的配分函数的闭合形式并求差，来计算精确的 $\\Delta F$。然后除以 $k_{\\mathrm{B}}T$ 得到 $\\beta\\,\\Delta F$。你不能在 TI 步骤中使用这个闭合形式；仅将其用作基准。\n\n程序行为要求：\n- 按照描述实现同步参数 TI，使用为给定二次模型推导出的系综平均值的闭合形式。\n- 独立计算 $\\beta\\,\\Delta F$ 的解析基准以及 TI 估算值与基准之间的绝对误差。\n- 你的程序必须处理以下测试套件，其中每个案例都是一个元组 $(k_0,\\Delta k,c,\\beta,\\lambda_\\star,h_\\star)$：\n  - 案例 A (正常路径): $(2.0,\\,1.0,\\,0.8,\\,1.0,\\,1.0,\\,0.5)$\n  - 案例 B (边界，零场): $(5.0,\\,3.0,\\,1.2,\\,1.0,\\,1.0,\\,0.0)$\n  - 案例 C (边界，无刚度变化): $(3.0,\\,0.0,\\,0.9,\\,1.0,\\,1.0,\\,0.8)$\n  - 案例 D (边缘，软化但稳定): $(3.0,\\,-1.5,\\,1.0,\\,1.0,\\,1.0,\\,1.1)$\n  - 案例 E (温度变化): $(2.5,\\,1.0,\\,0.6,\\,2.0,\\,0.75,\\,0.9)$\n- 所有能量必须以 $k_{\\mathrm{B}}T$ 为单位报告为无量纲浮点数。不出现角度。不使用百分比。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个案例，按顺序输出以下三个浮点数：$\\beta\\,\\Delta F$ 的 TI 估算值、$\\beta\\,\\Delta F$ 的解析基准和绝对误差。因此，最终输出必须是一个包含 $3\\times 5 = 15$ 个浮点数的扁平列表，顺序如下：\n$$\n[\\;(\\beta\\Delta F)_{\\mathrm{TI}}^{(A)},\\;(\\beta\\Delta F)_{\\mathrm{exact}}^{(A)},\\;|\\cdot|^{(A)},\\;(\\beta\\Delta F)_{\\mathrm{TI}}^{(B)},\\;(\\beta\\Delta F)_{\\mathrm{exact}}^{(B)},\\;|\\cdot|^{(B)},\\;\\ldots,\\;(\\beta\\Delta F)_{\\mathrm{TI}}^{(E)},\\;(\\beta\\Delta F)_{\\mathrm{exact}}^{(E)},\\;|\\cdot|^{(E)}\\;].\n$$", "solution": "用户提供的问题被评估为**有效**。这是一个在统计力学和计算物理学领域有科学依据、定义明确且客观的问题。它要求从第一性原理出发，对热力学积分进行标准推导，并将其应用于一个简单的、可解析求解的模型，然后进行数值实现。\n\n**步骤 1：提取已知条件**\n-   正则系综配分函数：$Z(\\alpha) = \\int \\exp\\!\\left[-\\beta \\, U(\\boldsymbol{r};\\alpha)\\right] \\, d\\boldsymbol{r}$\n-   亥姆霍兹自由能：$F(\\alpha) = -\\beta^{-1} \\ln Z(\\alpha)$\n-   $x$ 的一维自由度的模型势能：$U(x;\\lambda,h) \\;=\\; \\tfrac{1}{2}\\,\\big(k_0 + \\lambda\\,\\Delta k\\big)\\,x^2 \\;-\\; h\\,c\\,x$，参数为 $k_0>0$, $\\Delta k$, $c>0$, $\\lambda \\in [0,1]$ 和外场 $h$。逆温为 $\\beta$。\n-   积分路径：从 $(\\lambda,h) = (0,0)$ 到 $(\\lambda_\\star,h_\\star)$ 的一条直线，由 $\\zeta \\in [0,1]$ 参数化为 $\\lambda(\\zeta) = \\lambda_\\star\\,\\zeta$ 和 $h(\\zeta) = h_\\star\\,\\zeta$。\n-   数值任务：使用复合辛普森法则对热力学积分进行计算，求得 $\\beta\\,\\Delta F = \\beta(F(\\lambda_\\star,h_\\star) - F(0,0))$。\n-   解析任务：推导 $\\beta\\,\\Delta F$ 的精确闭合形式表达式，作为基准。\n-   测试案例：\n    -   A: $(k_0, \\Delta k, c, \\beta, \\lambda_\\star, h_\\star) = (2.0,\\,1.0,\\,0.8,\\,1.0,\\,1.0,\\,0.5)$\n    -   B: $(5.0,\\,3.0,\\,1.2,\\,1.0,\\,1.0,\\,0.0)$\n    -   C: $(3.0,\\,0.0,\\,0.9,\\,1.0,\\,1.0,\\,0.8)$\n    -   D: $(3.0,\\,-1.5,\\,1.0,\\,1.0,\\,1.0,\\,1.1)$\n    -   E: $(2.5,\\,1.0,\\,0.6,\\,2.0,\\,0.75,\\,0.9)$\n-   输出：每个测试案例包含三个浮点数的列表：$\\beta\\,\\Delta F$ 的 TI 估算值、$\\beta\\,\\Delta F$ 的解析基准和绝对误差。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上基于统计力学的原理。它定义明确，目标清晰，并提供了足够的信息来推导出唯一解。语言客观而正式。该模型系统虽然简单，但在物理上是合理的，并可作为热力学积分方法的一个极佳的教学示例。任务具体且可验证。该问题满足所有有效性标准。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整解决方案。\n\n**热力学积分公式的推导**\n\n亥姆霍兹自由能 $F$ 是参数 $\\lambda$ 和 $h$ 的状态函数，即 $F(\\lambda, h)$。其全微分为：\n$$\ndF = \\frac{\\partial F}{\\partial \\lambda} d\\lambda + \\frac{\\partial F}{\\partial h} dh\n$$\n为了求偏导数，我们从定义 $F(\\lambda,h) = -\\beta^{-1} \\ln Z(\\lambda,h)$ 出发。使用链式法则：\n$$\n\\frac{\\partial F}{\\partial \\lambda} = -\\frac{1}{\\beta Z} \\frac{\\partial Z}{\\partial \\lambda}\n$$\n配分函数 $Z(\\lambda,h) = \\int \\exp(-\\beta U(x;\\lambda,h)) dx$ 对 $\\lambda$ 的导数通过在积分号下微分得到：\n$$\n\\frac{\\partial Z}{\\partial \\lambda} = \\int \\frac{\\partial}{\\partial \\lambda} e^{-\\beta U(x;\\lambda,h)} dx = \\int \\left(-\\beta \\frac{\\partial U}{\\partial \\lambda}\\right) e^{-\\beta U(x;\\lambda,h)} dx\n$$\n将此代入 $\\partial F/\\partial \\lambda$ 的表达式中：\n$$\n\\frac{\\partial F}{\\partial \\lambda} = -\\frac{1}{\\beta Z} \\int \\left(-\\beta \\frac{\\partial U}{\\partial \\lambda}\\right) e^{-\\beta U(x;\\lambda,h)} dx = \\frac{\\int \\frac{\\partial U}{\\partial \\lambda} e^{-\\beta U(x;\\lambda,h)} dx}{\\int e^{-\\beta U(x;\\lambda,h)} dx}\n$$\n根据定义，右侧是 $\\partial U/\\partial \\lambda$ 的正则系综平均值。因此，我们得到基本关系式：\n$$\n\\frac{\\partial F}{\\partial \\lambda} = \\left\\langle \\frac{\\partial U}{\\partial \\lambda} \\right\\rangle_{\\lambda,h}\n$$\n对参数 $h$ 进行相同的推导，得到：\n$$\n\\frac{\\partial F}{\\partial h} = \\left\\langle \\frac{\\partial U}{\\partial h} \\right\\rangle_{\\lambda,h}\n$$\n因此，自由能的全微分为：\n$$\ndF = \\left\\langle \\frac{\\partial U}{\\partial \\lambda} \\right\\rangle_{\\lambda,h} d\\lambda + \\left\\langle \\frac{\\partial U}{\\partial h} \\right\\rangle_{\\lambda,h} dh\n$$\n两个状态 $(\\lambda_0, h_0)$ 和 $(\\lambda_1, h_1)$ 之间的自由能变化 $\\Delta F$ 是通过沿连接 $(\\lambda, h)$ 参数空间中这两点的任意路径对 $dF$ 进行积分得到的：\n$$\n\\Delta F = F(\\lambda_1,h_1) - F(\\lambda_0,h_0) = \\int_{(\\lambda_0,h_0)}^{(\\lambda_1,h_1)} \\left\\langle \\frac{\\partial U}{\\partial \\lambda} \\right\\rangle d\\lambda + \\left\\langle \\frac{\\partial U}{\\partial h} \\right\\rangle dh\n$$\n这就是热力学积分的一般公式。\n\n**对二次模型的具体化**\n\n模型势能为 $U(x;\\lambda,h) = \\frac{1}{2}k(\\lambda)x^2 - hcx$，其中 $k(\\lambda) = k_0 + \\lambda\\Delta k$。我们首先计算 $U$ 的偏导数：\n$$\n\\frac{\\partial U}{\\partial \\lambda} = \\frac{1}{2} \\frac{d k(\\lambda)}{d\\lambda} x^2 = \\frac{1}{2}\\Delta k\\,x^2 \\quad\\quad \\text{和} \\quad\\quad \\frac{\\partial U}{\\partial h} = -cx\n$$\n所需的系综平均值为 $\\langle \\frac{1}{2}\\Delta k\\,x^2 \\rangle = \\frac{1}{2}\\Delta k \\langle x^2 \\rangle_{\\lambda,h}$ 和 $\\langle -cx \\rangle = -c \\langle x \\rangle_{\\lambda,h}$。为了计算 $\\langle x \\rangle$ 和 $\\langle x^2 \\rangle$，我们分析玻尔兹曼概率密度 $p(x) \\propto \\exp(-\\beta U(x))$。势能是 $x$ 的二次函数，因此我们进行配方：\n$$\nU(x;\\lambda,h) = \\frac{1}{2}k(\\lambda)\\left(x^2 - \\frac{2hc}{k(\\lambda)}x\\right) = \\frac{1}{2}k(\\lambda)\\left(x - \\frac{hc}{k(\\lambda)}\\right)^2 - \\frac{(hc)^2}{2k(\\lambda)}\n$$\n概率分布是高斯分布，$p(x) \\propto \\exp\\left[-\\frac{\\beta k(\\lambda)}{2}\\left(x - \\frac{hc}{k(\\lambda)}\\right)^2\\right]$。这是一个均值为 $\\mu$、方差为 $\\sigma^2$ 的正态分布：\n$$\n\\mu = \\frac{hc}{k(\\lambda)} \\quad\\quad \\text{和} \\quad\\quad \\sigma^2 = \\frac{1}{\\beta k(\\lambda)}\n$$\n因此，所需的矩为：\n$$\n\\langle x \\rangle_{\\lambda,h} = \\mu = \\frac{hc}{k(\\lambda)}\n$$\n$$\n\\langle x^2 \\rangle_{\\lambda,h} = \\sigma^2 + \\mu^2 = \\frac{1}{\\beta k(\\lambda)} + \\left(\\frac{hc}{k(\\lambda)}\\right)^2\n$$\n将这些代入 $F$ 的偏导数表达式中：\n$$\n\\frac{\\partial F}{\\partial \\lambda} = \\frac{1}{2}\\Delta k \\left[ \\frac{1}{\\beta k(\\lambda)} + \\frac{(hc)^2}{k(\\lambda)^2} \\right]\n$$\n$$\n\\frac{\\partial F}{\\partial h} = -c \\left[ \\frac{hc}{k(\\lambda)} \\right] = - \\frac{h c^2}{k(\\lambda)}\n$$\n\n**同步参数 TI 的公式化**\n\n我们沿路径 $\\lambda(\\zeta) = \\lambda_\\star\\zeta$ 和 $h(\\zeta) = h_\\star\\zeta$（其中 $\\zeta \\in [0,1]$）从参考状态 $(0,0)$ 积分到目标状态 $(\\lambda_\\star, h_\\star)$。路径导数为 $d\\lambda/d\\zeta = \\lambda_\\star$ 和 $dh/d\\zeta = h_\\star$。自由能变化是线积分：\n$$\n\\Delta F = \\int_0^1 \\left( \\frac{\\partial F}{\\partial \\lambda}\\bigg|_{\\zeta} \\frac{d\\lambda}{d\\zeta} + \\frac{\\partial F}{\\partial h}\\bigg|_{\\zeta} \\frac{dh}{d\\zeta} \\right) d\\zeta\n$$\n我们计算无量纲量 $\\beta \\Delta F$：\n$$\n\\beta \\Delta F = \\int_0^1 \\left( \\beta\\frac{\\partial F}{\\partial \\lambda}\\bigg|_{\\zeta} \\lambda_\\star + \\beta\\frac{\\partial F}{\\partial h}\\bigg|_{\\zeta} h_\\star \\right) d\\zeta\n$$\n被积函数，我们称之为 $f(\\zeta)$，是通过代入沿路径计算的推导表达式得到的：\n$$\nk(\\zeta) = k_0 + \\lambda(\\zeta)\\Delta k = k_0 + \\lambda_\\star\\zeta\\Delta k\n$$\n$$\nh(\\zeta) = h_\\star\\zeta\n$$\n$$\nf(\\zeta) = \\beta \\left( \\frac{1}{2}\\Delta k \\left[ \\frac{1}{\\beta k(\\zeta)} + \\frac{(h(\\zeta)c)^2}{k(\\zeta)^2} \\right] \\right) \\lambda_\\star + \\beta \\left( - \\frac{h(\\zeta) c^2}{k(\\zeta)} \\right) h_\\star\n$$\n$$\nf(\\zeta) = \\frac{\\Delta k \\lambda_\\star}{2 k(\\zeta)} + \\frac{\\beta \\Delta k \\lambda_\\star (h_\\star\\zeta c)^2}{2 k(\\zeta)^2} - \\frac{\\beta c^2 (h_\\star\\zeta) h_\\star}{k(\\zeta)}\n$$\n$$\nf(\\zeta) = \\frac{\\Delta k \\lambda_\\star}{2 k(\\zeta)} + \\frac{\\beta c^2 h_\\star^2 \\zeta}{k(\\zeta)^2} \\left[ \\frac{1}{2}\\Delta k \\lambda_\\star \\zeta - k(\\zeta) \\right]\n$$\n将 $k(\\zeta) = k_0 + \\lambda_\\star\\zeta\\Delta k$ 代入方括号中的项，得到：\n$$\n\\frac{1}{2}\\Delta k \\lambda_\\star \\zeta - (k_0 + \\lambda_\\star\\zeta\\Delta k) = -k_0 - \\frac{1}{2}\\Delta k \\lambda_\\star \\zeta\n$$\n因此，用于数值评估的最终被积函数是：\n$$\nf(\\zeta) = \\frac{\\Delta k \\lambda_\\star}{2(k_0 + \\lambda_\\star\\zeta\\Delta k)} - \\frac{\\beta c^2 h_\\star^2 \\zeta(k_0 + \\frac{1}{2}\\Delta k \\lambda_\\star \\zeta)}{(k_0 + \\lambda_\\star\\zeta\\Delta k)^2}\n$$\n积分 $\\beta \\Delta F = \\int_0^1 f(\\zeta) d\\zeta$ 将被数值计算。\n\n**解析基准的推导**\n\n配分函数 $Z$ 通过对高斯概率密度进行积分来求得：\n$$\nZ(\\lambda,h) = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\beta U(x;\\lambda,h)\\right) dx = \\int_{-\\infty}^{\\infty} \\exp\\left[-\\beta\\left( \\frac{k(\\lambda)}{2}\\left(x - \\frac{hc}{k(\\lambda)}\\right)^2 - \\frac{(hc)^2}{2k(\\lambda)} \\right)\\right] dx\n$$\n$$\nZ(\\lambda,h) = \\exp\\left(\\frac{\\beta(hc)^2}{2k(\\lambda)}\\right) \\int_{-\\infty}^{\\infty} \\exp\\left[-\\frac{\\beta k(\\lambda)}{2}\\left(x - \\frac{hc}{k(\\lambda)}\\right)^2\\right] dx\n$$\n使用标准高斯积分结果 $\\int_{-\\infty}^{\\infty} e^{-ax^2}dx = \\sqrt{\\pi/a}$，该积分计算结果为 $\\sqrt{2\\pi/(\\beta k(\\lambda))}$。\n$$\nZ(\\lambda,h) = \\sqrt{\\frac{2\\pi}{\\beta k(\\lambda)}} \\exp\\left(\\frac{\\beta(hc)^2}{2k(\\lambda)}\\right)\n$$\n自由能为 $F = -\\beta^{-1}\\ln Z$：\n$$\nF(\\lambda,h) = -\\frac{1}{\\beta} \\left[ \\frac{1}{2}\\ln\\left(\\frac{2\\pi}{\\beta k(\\lambda)}\\right) + \\frac{\\beta(hc)^2}{2k(\\lambda)} \\right] = -\\frac{1}{2\\beta}\\ln\\left(\\frac{2\\pi}{\\beta k(\\lambda)}\\right) - \\frac{(hc)^2}{2k(\\lambda)}\n$$\n我们需要 $\\Delta F = F(\\lambda_\\star,h_\\star) - F(0,0)$。\n在 $(\\lambda,h) = (0,0)$ 处，我们有 $k(0)=k_0$ 和 $h=0$：\n$$\nF(0,0) = -\\frac{1}{2\\beta}\\ln\\left(\\frac{2\\pi}{\\beta k_0}\\right)\n$$\n在 $(\\lambda,h) = (\\lambda_\\star,h_\\star)$ 处，我们有 $k(\\lambda_\\star)=k_0+\\lambda_\\star\\Delta k$：\n$$\nF(\\lambda_\\star,h_\\star) = -\\frac{1}{2\\beta}\\ln\\left(\\frac{2\\pi}{\\beta(k_0+\\lambda_\\star\\Delta k)}\\right) - \\frac{(h_\\star c)^2}{2(k_0+\\lambda_\\star\\Delta k)}\n$$\n差值为：\n$$\n\\Delta F = F(\\lambda_\\star,h_\\star) - F(0,0) = -\\frac{(h_\\star c)^2}{2(k_0+\\lambda_\\star\\Delta k)} - \\frac{1}{2\\beta}\\left[ \\ln\\left(\\frac{2\\pi}{\\beta(k_0+\\lambda_\\star\\Delta k)}\\right) - \\ln\\left(\\frac{2\\pi}{\\beta k_0}\\right) \\right]\n$$\n$$\n\\Delta F = -\\frac{(h_\\star c)^2}{2(k_0+\\lambda_\\star\\Delta k)} + \\frac{1}{2\\beta}\\ln\\left(\\frac{k_0+\\lambda_\\star\\Delta k}{k_0}\\right)\n$$\n所需的无量纲量为 $\\beta \\Delta F$：\n$$\n\\beta\\Delta F_{\\text{exact}} = \\frac{1}{2}\\ln\\left(1 + \\frac{\\lambda_\\star \\Delta k}{k_0}\\right) - \\frac{\\beta (h_\\star c)^2}{2(k_0 + \\lambda_\\star\\Delta k)}\n$$\n这是用于比较的解析基准。\n\n**数值实现策略**\n代码将实现一个函数，用于计算上面推导出的被积函数 $f(\\zeta)$。积分 $\\int_0^1 f(\\zeta)d\\zeta$ 将使用 `scipy.integrate.simpson` 函数中的复合辛普森法则进行评估，这是一个稳健且准确的实现。将使用大量的积分点 ($N+1 = 10001$) 来确保高精度。代码还将实现为 $\\beta\\Delta F$ 推导的解析基准公式。对于每个测试案例，将计算这两个值，并按照指定的输出格式报告绝对差值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import simpson\n\ndef solve():\n    \"\"\"\n    Computes field-dependent Helmholtz free-energy differences using\n    Thermodynamic Integration (TI) and compares with an analytical benchmark.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (k0, delta_k, c, beta, lambda_star, h_star)\n    test_cases = [\n        (2.0, 1.0, 0.8, 1.0, 1.0, 0.5),      # Case A\n        (5.0, 3.0, 1.2, 1.0, 1.0, 0.0),      # Case B\n        (3.0, 0.0, 0.9, 1.0, 1.0, 0.8),      # Case C\n        (3.0, -1.5, 1.0, 1.0, 1.0, 1.1),     # Case D\n        (2.5, 1.0, 0.6, 2.0, 0.75, 0.9),      # Case E\n    ]\n\n    results = []\n    \n    # Number of points for numerical integration (N intervals, N+1 points)\n    # Using an even number of intervals for Simpson's rule.\n    num_points = 10001\n    zeta_points = np.linspace(0.0, 1.0, num_points)\n\n    for case in test_cases:\n        k0, delta_k, c, beta, lambda_star, h_star = case\n\n        # 1. Thermodynamic Integration (TI) Calculation\n        \n        # Define the integrand for beta * dF along the path\n        def ti_integrand(zeta, k0, delta_k, c, beta, lambda_star, h_star):\n            \"\"\"\n            Calculates the value of the TI integrand f(zeta) for beta * dF.\n            f(zeta) = beta * (dF/d_lambda * d_lambda/d_zeta + dF/dh * dh/d_zeta)\n            \"\"\"\n            k_zeta = k0 + lambda_star * zeta * delta_k\n            \n            # If k_zeta = 0, the model is unstable. Test cases are stable.\n            if k_zeta = 0:\n                return np.nan\n\n            term1 = (delta_k * lambda_star) / (2.0 * k_zeta)\n            \n            term2_factor = (beta * c**2 * h_star**2) / (k_zeta**2)\n            term2_inner = zeta * (k0 + 0.5 * delta_k * lambda_star * zeta)\n            term2 = term2_factor * term2_inner\n            \n            return term1 - term2\n\n        integrand_values = ti_integrand(zeta_points, k0, delta_k, c, beta, lambda_star, h_star)\n        \n        beta_delta_F_ti = simpson(integrand_values, zeta_points)\n\n        # 2. Analytical Benchmark Calculation\n        \n        k_star = k0 + lambda_star * delta_k\n        log_term = 0.0\n        # Protect against log(non-positive)\n        if k_star > 0 and k0 > 0:\n            log_term = 0.5 * np.log(k_star / k0)\n        \n        field_term = 0.0\n        if k_star > 0:\n            field_term = (beta * (h_star * c)**2) / (2.0 * k_star)\n        \n        beta_delta_F_exact = log_term - field_term\n        \n        # 3. Calculate absolute error\n        error = np.abs(beta_delta_F_ti - beta_delta_F_exact)\n        \n        results.extend([beta_delta_F_ti, beta_delta_F_exact, error])\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3495969"}, {"introduction": "我们的最终实践将解决一个代表现代计算材料科学的问题：计算柔性分子晶体的绝对自由能。这个高级练习涉及构建一个复合的热力学路径，并应用必要的解析校正，包括对坐标变换（雅可比行列式）和移除人为施加的模拟约束的校正。掌握这一过程是将模拟与实验热力学数据联系起来的关键。[@problem_id:3496016]", "problem": "您的任务是构建一个完整的、复合的热力学积分 (TI) 流程，用于计算由柔性分子组成的分子晶体的绝对亥姆霍兹自由能。该计算必须使用两个独立的耦合参数分支：一个分支开启选定内坐标上的分子内谐波限制，另一个分支开启分子间的相互作用。该计算必须包含针对广义内坐标的适当雅可比校正，并解析地移除分子内限制和外部锚定场，以在指定温度下生成物理晶体的绝对自由能。所有量必须以每摩尔分子表示，单位为千焦/摩尔，并且角度在内部必须以弧度处理。您的程序产生的最终答案必须是单行，包含一个针对所提供测试套件的自由能结果的逗号分隔列表，用方括号括起来，每个值四舍五入到六位小数。\n\n基本原理：\n- 亥姆霍兹自由能 $F$ 定义为 $F = -k_B T \\ln Z$，其中 $Z$ 是正则配分函数，$k_B$ 是 Boltzmann 常数，$T$ 是绝对温度。\n- 对于连接两个态的耦合参数 $\\lambda$，热力学积分公式为 $\\Delta F = \\int_{0}^{1} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda$，其中 $U(\\lambda)$ 是一个可微的势能函数，$\\langle \\cdot \\rangle_{\\lambda}$ 表示在固定 $\\lambda$ 下的正则系综平均。\n- 对于施加于广义坐标 $q$（其坐标空间度量因子为 $M(q)$）的一维谐波限制 $U(q) = \\frac{1}{2} k (q - q_0)^2$，在窄限制极限下，相应的配分函数贡献为 $Z_{\\text{harm}} \\approx M(q_0) \\sqrt{\\frac{2\\pi}{\\beta k}}$，其中 $\\beta = 1/(k_B T)$。度量因子 $M(q)$ 解释了从笛卡尔坐标到广义坐标变换的雅可比行列式。对于三维标准内坐标，键长 $r$ 使用 $M(r) = r^2$，键角 $\\theta$ 使用 $M(\\theta) = \\sin\\theta$，二面角 $\\phi$ 使用 $M(\\phi) = 1$。\n- 当从哈密顿量中消除谐波限制时，移除该限制对自由能的贡献为 $+\\Delta F_{\\text{remove}} = +k_B T \\ln Z_{\\text{harm}}$。\n- 建模为三维空间中独立的、各向同性的谐波势的平移和旋转锚定场，每个分子贡献的解析移除项为：$+\\Delta F_{\\text{remove,trans}} = \\frac{3}{2} k_B T \\ln\\left(\\frac{\\pi k_B T}{\\kappa_t}\\right)$ 和 $+\\Delta F_{\\text{remove,rot}} = \\frac{3}{2} k_B T \\ln\\left(\\frac{\\pi k_B T}{\\kappa_r}\\right)$，其中 $\\kappa_t$ 和 $\\kappa_r$ 分别是平移和旋转谐波弹簧常数。\n\n设计规范：\n- 分支 $1$（分子内限制）：将指定内坐标上的谐波限制从 $\\lambda = 0$ 缩放到 $\\lambda = 1$。系综平均 $\\left\\langle \\frac{\\partial U_{\\text{rest}}(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda}$ 在离散的 $\\lambda$ 值处作为输入数据提供。通过在 $\\lambda \\in [0,1]$ 上进行数值积分来计算 $\\Delta F_1$。\n- 分支 $2$（分子间相互作用）：将分子间相互作用从 $\\lambda = 0$ 缩放到 $\\lambda = 1$。系综平均 $\\left\\langle \\frac{\\partial U_{\\text{inter}}(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda}$ 在离散的 $\\lambda$ 值处作为输入数据提供。通过在 $\\lambda \\in [0,1]$ 上进行数值积分来计算 $\\Delta F_2$。\n- 雅可比校正：使用在目标值 $r_0$ 和 $\\theta_0$ 处计算的 $M(r) = r^2$ 和 $M(\\theta) = \\sin\\theta$ 来为受限的广义坐标构建正确的移除项。为确保对数内的参数无量纲，用指定的长度标度 $\\ell_{\\text{ref}}$（使用下面明确提供的 $\\ell_{\\text{ref}}$）对每个键长进行归一化，即将 $M(r_0)$ 视为 $(r_0/\\ell_{\\text{ref}})^2$。\n- 限制移除：在两个 TI 分支之后，使用带有适当度量因子的窄限制极限，为分支 1 中开启的所有分子内谐波限制添加解析移除贡献。对于一组具有弹簧常数 $k_{\\text{bond}}$ 的 $b$ 个键长 $\\{ r_{0,i} \\}$、具有弹簧常数 $k_{\\text{angle}}$ 的 $a$ 个键角 $\\{ \\theta_{0,j} \\}$ 和具有弹簧常数 $k_{\\text{dihedral}}$ 的 $d$ 个二面角，每摩尔的总限制移除量为：\n$$\n\\Delta F_{\\text{remove,rest}} = R T \\left[ \\sum_{i=1}^{b} \\left( 2 \\ln\\frac{r_{0,i}}{\\ell_{\\text{ref}}} + \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{bond}}} \\right) + \\sum_{j=1}^{a} \\left( \\ln\\sin\\theta_{0,j} + \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{angle}}} \\right) + \\sum_{k=1}^{d} \\left( \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{dihedral}}} \\right) \\right],\n$$\n其中 $R$ 是通用气体常数，使用 $R T = N_A k_B T$ 以每摩尔能量表示。\n- 锚定移除：为每个分子的各向同性三维平移和旋转锚定添加解析移除贡献：\n$$\n\\Delta F_{\\text{remove,anchor}} = R T \\left[ \\frac{3}{2} \\ln\\left(\\frac{\\pi R T}{\\kappa_t}\\right) + \\frac{3}{2} \\ln\\left(\\frac{\\pi R T}{\\kappa_r}\\right) \\right].\n$$\n- 总自由能：每摩尔晶体的绝对亥姆霍兹自由能为：\n$$\nF_{\\text{abs}} = \\Delta F_1 + \\Delta F_2 + \\Delta F_{\\text{remove,rest}} + \\Delta F_{\\text{remove,anchor}}.\n$$\n\n计算要求：\n- 对每个分支，在提供的 $\\lambda$ 离散网格和相应的系综平均值上，使用复合辛普森法则进行数值积分。如果网格不能被视为均匀间隔，或区间数不是偶数，则为保证正确性，回退使用复合梯形法则。\n- 在计算三角函数之前，将所有角度从度转换为弧度。\n- 使用 $R = 0.008314462618$ 千焦/摩尔/开尔文。\n- 所有输出必须以千焦/摩尔为单位，并四舍五入到六位小数。\n\n测试套件：\n您的程序必须为以下三个参数集计算 $F_{\\text{abs}}$。每个平均导数数组均以千焦/摩尔为单位给出。\n\n- 情况 1（一般柔性分子，典型条件）：\n    - 温度 $T = 300$ 开尔文。\n    - 参考长度 $\\ell_{\\text{ref}} = 1.0$ 埃。\n    - 每个分子的分子内限制：\n        - 键 $b = 3$，其中 $r_{0} = [1.09, 1.41, 1.52]$ 埃。\n        - 角 $a = 2$，其中 $\\theta_{0} = [109.5, 120.0]$ 度。\n        - 二面角 $d = 2$。\n        - 弹簧常数：$k_{\\text{bond}} = 5000$ 千焦/摩尔/平方埃，$k_{\\text{angle}} = 1000$ 千焦/摩尔/弧度平方，$k_{\\text{dihedral}} = 200$ 千焦/摩尔/弧度平方。\n    - 锚定常数：$\\kappa_t = 1000$ 千焦/摩尔/平方埃，$\\kappa_r = 500$ 千焦/摩尔/弧度平方。\n    - 分支 1 网格：$\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$，系综平均 $\\left\\langle \\frac{\\partial U_{\\text{rest}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, 1.6, 3.0, 4.1, 4.3]$ 千焦/摩尔。\n    - 分支 2 网格：$\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$，系综平均 $\\left\\langle \\frac{\\partial U_{\\text{inter}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, -25.0, -55.0, -80.0, -95.0]$ 千焦/摩尔。\n\n- 情况 2（无分子内限制，仅相互作用分支，中等强度锚定）：\n    - 温度 $T = 300$ 开尔文。\n    - 参考长度 $\\ell_{\\text{ref}} = 1.0$ 埃。\n    - 每个分子的分子内限制：$b = 0$, $a = 0$, $d = 0$；弹簧常数可以忽略。\n    - 锚定常数：$\\kappa_t = 500$ 千焦/摩尔/平方埃，$\\kappa_r = 200$ 千焦/摩尔/弧度平方。\n    - 分支 1 网格：$\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$，系综平均 $\\left\\langle \\frac{\\partial U_{\\text{rest}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, 0.0, 0.0, 0.0, 0.0]$ 千焦/摩尔。\n    - 分支 2 网格：$\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$，系综平均 $\\left\\langle \\frac{\\partial U_{\\text{inter}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, -10.0, -30.0, -40.0, -50.0]$ 千焦/摩尔。\n\n- 情况 3（低温，强限制，更强的锚定）：\n    - 温度 $T = 100$ 开尔文。\n    - 参考长度 $\\ell_{\\text{ref}} = 1.0$ 埃。\n    - 每个分子的分子内限制：\n        - 键 $b = 1$，其中 $r_{0} = [0.95]$ 埃。\n        - 角 $a = 1$，其中 $\\theta_{0} = [90.0]$ 度。\n        - 二面角 $d = 0$。\n        - 弹簧常数：$k_{\\text{bond}} = 10000$ 千焦/摩尔/平方埃，$k_{\\text{angle}} = 2000$ 千焦/摩尔/弧度平方，$k_{\\text{dihedral}}$ 未使用。\n    - 锚定常数：$\\kappa_t = 2000$ 千焦/摩尔/平方埃，$\\kappa_r = 1000$ 千焦/摩尔/弧度平方。\n    - 分支 1 网格：$\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$，系综平均 $\\left\\langle \\frac{\\partial U_{\\text{rest}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, 0.8, 1.5, 2.2, 2.5]$ 千焦/摩尔。\n    - 分支 2 网格：$\\lambda = [0.0, 0.25, 0.5, 0.75, 1.0]$，系综平均 $\\left\\langle \\frac{\\partial U_{\\text{inter}}}{\\partial \\lambda} \\right\\rangle_{\\lambda} = [0.0, -5.0, -20.0, -35.0, -50.0]$ 千焦/摩尔。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[f_1,f_2,f_3]$，其中 $f_i$ 是情况 $i$ 计算出的绝对亥姆霍兹自由能，单位为千焦/摩尔，四舍五入到六位小数。", "solution": "我们从亥姆霍兹自由能 $F = -k_B T \\ln Z$ 的定义开始，其中 $Z$ 是正则配分函数。为了计算固体的绝对自由能，我们通过耦合参数热力学积分 (TI) 构建一条可逆路径，将一个易于处理的参考体系连接到物理体系。在当前用于柔性分子组成的分子晶体的复合 TI 方法中，我们使用两个由 $\\lambda$ 参数化的分支：分支 1 开启选定内坐标上的分子内谐波限制，分支 2 开启分子间的相互作用。\n\n根据热力学积分恒等式，对于可微势能 $U(\\lambda)$ 和正则系综平均，$\\lambda=0$ 和 $\\lambda=1$ 之间的自由能变化为：\n$$\n\\Delta F = \\int_{0}^{1} \\left\\langle \\frac{\\partial U(\\lambda)}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda.\n$$\n我们将此分别应用于两个分支：\n- 分支 1，分子内限制缩放：$U(\\lambda) = U_{\\text{phys}} + \\lambda U_{\\text{rest}}$，其中 $U_{\\text{phys}}$ 是物理分子内哈密顿量（保持不变），$U_{\\text{rest}}$ 是施加于广义内坐标的谐波限制之和。因此 $\\frac{\\partial U}{\\partial \\lambda} = U_{\\text{rest}}$，被积函数是在固定 $\\lambda$ 和分布 $\\propto \\exp[-\\beta(U_{\\text{phys}} + \\lambda U_{\\text{rest}} + U_{\\text{anchor}})]$ 下的限制能的系综平均，其中 $U_{\\text{anchor}}$ 是使分子保持在其晶格位置和取向附近的外部锚定势。提供的数据直接以千焦/摩尔为单位给出 $\\left\\langle \\frac{\\partial U}{\\partial \\lambda} \\right\\rangle_{\\lambda}$。分支 1 的自由能为：\n$$\n\\Delta F_1 = \\int_0^1 \\left\\langle U_{\\text{rest}} \\right\\rangle_{\\lambda} d\\lambda.\n$$\n- 分支 2，分子间相互作用缩放：$U(\\lambda) = U_{\\text{phys}} + U_{\\text{rest}}^{\\star} + \\lambda U_{\\text{inter}}$，其中 $U_{\\text{rest}}^{\\star}$ 表示在分支 2 期间保持固定的、来自分支 1 的全强度分子内限制，$U_{\\text{inter}}$ 是分子间的相互作用能。那么 $\\partial U / \\partial \\lambda = U_{\\text{inter}}$，被积函数是 $\\left\\langle U_{\\text{inter}} \\right\\rangle_{\\lambda}$。分支 2 的自由能为：\n$$\n\\Delta F_2 = \\int_0^1 \\left\\langle U_{\\text{inter}} \\right\\rangle_{\\lambda} d\\lambda.\n$$\n\n完成这两个分支后，路径的当前终点是一个同时具有全强度分子间相互作用和全强度分子内限制的体系，且仍然受到外部锚定场的影响。为了获得物理晶体（没有人工分子内限制和锚定场）的绝对自由能，我们必须解析地移除这些附加项。\n\n对于由谐波势 $U(q) = \\frac{1}{2} k (q - q_0)^2$ 限制的广义坐标 $q$，其正则配分函数贡献在窄限制极限（对刚性限制有效）下为：\n$$\nZ_{\\text{harm}} \\approx M(q_0) \\sqrt{\\frac{2\\pi}{\\beta k}},\n$$\n其中 $M(q)$ 是从笛卡尔坐标到广义坐标 $q$ 变换产生的雅可比因子。对于三维内坐标，我们使用公认的度量：\n- 对于键长 $r$，$M(r) = r^2$。\n- 对于键角 $\\theta$，$M(\\theta) = \\sin\\theta$。\n- 对于二面角 $\\phi$，$M(\\phi) = 1$。\n\n为确保对数内的参数无量纲，必须用适当的参考标度对量进行归一化。对于键长，我们用参考长度 $\\ell_{\\text{ref}}$ 对 $r_0$ 进行归一化，得到无量纲的 $(r_0/\\ell_{\\text{ref}})^2$。使用单位为千焦/摩尔的 $R T = N_A k_B T$，移除一个谐波限制后自由能的增加量为：\n$$\n\\Delta F_{\\text{remove}} = +k_B T \\ln Z_{\\text{harm}} = R T \\left[ \\ln M(q_0) + \\frac{1}{2} \\ln \\left(\\frac{2\\pi R T}{k} \\right) \\right].\n$$\n对所有受限的坐标求和，得到键、角和二面角的总分子内限制移除量：\n$$\n\\Delta F_{\\text{remove,rest}} = R T \\left[ \\sum_{i=1}^{b} \\left( 2 \\ln\\frac{r_{0,i}}{\\ell_{\\text{ref}}} + \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{bond}}} \\right) + \\sum_{j=1}^{a} \\left( \\ln\\sin\\theta_{0,j} + \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{angle}}} \\right) + \\sum_{k=1}^{d} \\left( \\frac{1}{2} \\ln\\frac{2\\pi R T}{k_{\\text{dihedral}}} \\right) \\right].\n$$\n这个移除公式通过 $M(r_0)$ 和 $M(\\theta_0)$ 内在地包含了适当的雅可比校正。\n\n在 TI 过程中，外部锚定用于控制质心平移和分子取向，但必须将其移除以获得真实晶体的绝对自由能。对于质心位置上弹簧常数为 $\\kappa_t$ 的各向同性三维谐波锚定，配分函数为 $Z_{\\text{trans}} = \\left(\\frac{\\pi}{\\beta \\kappa_t}\\right)^{3/2}$，移除项为：\n$$\n\\Delta F_{\\text{remove,trans}} = k_B T \\ln Z_{\\text{trans}} = R T \\cdot \\frac{3}{2} \\ln\\left(\\frac{\\pi R T}{\\kappa_t}\\right).\n$$\n类似地，对于旋转坐标上弹簧常数为 $\\kappa_r$ 的各向同性三维谐波锚定，我们写出：\n$$\n\\Delta F_{\\text{remove,rot}} = R T \\cdot \\frac{3}{2} \\ln\\left(\\frac{\\pi R T}{\\kappa_r}\\right).\n$$\n两者结合得到总的锚定移除量：\n$$\n\\Delta F_{\\text{remove,anchor}} = R T \\left[ \\frac{3}{2} \\ln\\left(\\frac{\\pi R T}{\\kappa_t}\\right) + \\frac{3}{2} \\ln\\left(\\frac{\\pi R T}{\\kappa_r}\\right) \\right].\n$$\n\n因此，在指定温度下，每种情况下每摩尔的绝对亥姆霍兹自由能为：\n$$\nF_{\\text{abs}} = \\Delta F_1 + \\Delta F_2 + \\Delta F_{\\text{remove,rest}} + \\Delta F_{\\text{remove,anchor}}.\n$$\n\n程序实现的算法步骤：\n1. 对每种情况，读取温度 $T$ 并用 $R = 0.008314462618$ 千焦/摩尔/开尔文计算 $R T$。\n2. 在计算 $\\sin \\theta_0$ 之前，将所有提供的键角 $\\theta_0$ 从度转换为弧度。\n3. 如果网格是均匀间隔且区间数为偶数，则使用复合辛普森法则对分支 1 和分支 2 的离散 $\\lambda$ 网格和系综平均值进行数值积分；否则，回退使用复合梯形法则。这会得到 $\\Delta F_1$ 和 $\\Delta F_2$。\n4. 使用窄限制公式和雅可比度量 $M(r_0) = (r_0/\\ell_{\\text{ref}})^2$、$M(\\theta_0) = \\sin\\theta_0$ 和 $M(\\phi) = 1$ 来计算 $\\Delta F_{\\text{remove,rest}}$。\n5. 使用平移和旋转锚定的解析各向同性三维公式计算 $\\Delta F_{\\text{remove,anchor}}$。\n6. 将四项贡献相加，得到每种情况的 $F_{\\text{abs}}$。\n7. 输出单行结果，格式为用方括号括起来的逗号分隔列表，每个结果四舍五入到六位小数。\n\n该方法基于第一性原理，通过自由能的配分函数定义、耦合参数的热力学积分公式，以及谐波配分函数及其坐标空间雅可比度量的正则解析表达式。对 $\\lambda$ 的离散积分对应于典型实践，即使用在一组耦合参数值下测量或模拟的系综平均值；解析移除项确保绝对自由能是针对没有人工限制和锚定的物理晶体而言的。所有输出都以千焦/摩尔计算，与公式中 $R T$ 的使用保持一致。", "answer": "```python\n# Thermodynamic integration for absolute free energy of a molecular crystal\n# Python 3.12, numpy 1.23.5, scipy not used.\nimport numpy as np\n\nR_kJ_per_mol_K = 0.008314462618  # Gas constant in kJ/(mol*K)\n\ndef to_radians(degrees_array):\n    return np.deg2rad(np.array(degrees_array, dtype=float))\n\ndef is_uniform_grid(x, tol=1e-12):\n    x = np.array(x, dtype=float)\n    if len(x)  2:\n        return True\n    diffs = np.diff(x)\n    return np.all(np.abs(diffs - diffs[0])  tol)\n\ndef numerical_integral(x, y):\n    # Composite Simpson's rule over uniform grid with even number of intervals.\n    # Fallback to trapezoidal rule otherwise.\n    x = np.array(x, dtype=float)\n    y = np.array(y, dtype=float)\n    n = len(x) - 1\n    if n  1:\n        return 0.0\n    if is_uniform_grid(x) and n % 2 == 0 and n = 2:\n        h = (x[-1] - x[0]) / n\n        s = y[0] + y[-1] + 4.0 * np.sum(y[1:-1:2]) + 2.0 * np.sum(y[2:-2:2])\n        return (h / 3.0) * s\n    else:\n        # Fallback: composite trapezoidal rule\n        return np.trapz(y, x)\n\ndef restraint_removal_F(T, l_ref, r0_list, theta0_deg_list, k_bond, k_angle, k_dihedral, num_dihedrals):\n    RT = R_kJ_per_mol_K * T\n    total = 0.0\n    # Bonds: M(r0) = (r0 / l_ref)^2\n    for r0 in r0_list:\n        M_term = 2.0 * np.log(r0 / l_ref)\n        thermo_term = 0.5 * np.log((2.0 * np.pi * RT) / k_bond)\n        total += (M_term + thermo_term)\n    # Angles: M(theta0) = sin(theta0)\n    if len(theta0_deg_list)  0:\n        theta0_rad_list = to_radians(theta0_deg_list)\n        for th in theta0_rad_list:\n            sin_th = np.sin(th)\n            if sin_th = 0.0:\n                sin_th = 1e-300\n            M_term = np.log(sin_th)\n            thermo_term = 0.5 * np.log((2.0 * np.pi * RT) / k_angle)\n            total += (M_term + thermo_term)\n    # Dihedrals: M(phi) = 1\n    for _ in range(num_dihedrals):\n        thermo_term = 0.5 * np.log((2.0 * np.pi * RT) / k_dihedral)\n        total += thermo_term\n    return RT * total\n\ndef anchor_removal_F(T, kappa_t, kappa_r):\n    RT = R_kJ_per_mol_K * T\n    term_t = 1.5 * np.log((np.pi * RT) / kappa_t)\n    term_r = 1.5 * np.log((np.pi * RT) / kappa_r)\n    return RT * (term_t + term_r)\n\ndef solve():\n    test_cases = [\n        # Case 1\n        {\n            \"T\": 300.0, \"l_ref\": 1.0, \"bonds_r0\": [1.09, 1.41, 1.52], \"angles_theta0_deg\": [109.5, 120.0],\n            \"num_dihedrals\": 2, \"k_bond\": 5000.0, \"k_angle\": 1000.0, \"k_dihedral\": 200.0,\n            \"kappa_t\": 1000.0, \"kappa_r\": 500.0,\n            \"lambda_leg1\": [0.0, 0.25, 0.5, 0.75, 1.0], \"avg_dUdl_leg1\": [0.0, 1.6, 3.0, 4.1, 4.3],\n            \"lambda_leg2\": [0.0, 0.25, 0.5, 0.75, 1.0], \"avg_dUdl_leg2\": [0.0, -25.0, -55.0, -80.0, -95.0],\n        },\n        # Case 2\n        {\n            \"T\": 300.0, \"l_ref\": 1.0, \"bonds_r0\": [], \"angles_theta0_deg\": [], \"num_dihedrals\": 0,\n            \"k_bond\": 1.0, \"k_angle\": 1.0, \"k_dihedral\": 1.0,\n            \"kappa_t\": 500.0, \"kappa_r\": 200.0,\n            \"lambda_leg1\": [0.0, 0.25, 0.5, 0.75, 1.0], \"avg_dUdl_leg1\": [0.0, 0.0, 0.0, 0.0, 0.0],\n            \"lambda_leg2\": [0.0, 0.25, 0.5, 0.75, 1.0], \"avg_dUdl_leg2\": [0.0, -10.0, -30.0, -40.0, -50.0],\n        },\n        # Case 3\n        {\n            \"T\": 100.0, \"l_ref\": 1.0, \"bonds_r0\": [0.95], \"angles_theta0_deg\": [90.0],\n            \"num_dihedrals\": 0, \"k_bond\": 10000.0, \"k_angle\": 2000.0, \"k_dihedral\": 1.0,\n            \"kappa_t\": 2000.0, \"kappa_r\": 1000.0,\n            \"lambda_leg1\": [0.0, 0.25, 0.5, 0.75, 1.0], \"avg_dUdl_leg1\": [0.0, 0.8, 1.5, 2.2, 2.5],\n            \"lambda_leg2\": [0.0, 0.25, 0.5, 0.75, 1.0], \"avg_dUdl_leg2\": [0.0, -5.0, -20.0, -35.0, -50.0],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Integrate the two legs\n        dF1 = numerical_integral(case[\"lambda_leg1\"], case[\"avg_dUdl_leg1\"])\n        dF2 = numerical_integral(case[\"lambda_leg2\"], case[\"avg_dUdl_leg2\"])\n\n        # Restraint removal\n        if not case[\"bonds_r0\"] and not case[\"angles_theta0_deg\"] and case[\"num_dihedrals\"] == 0:\n            dF_remove_rest = 0.0\n        else:\n            dF_remove_rest = restraint_removal_F(\n                T=case[\"T\"], l_ref=case[\"l_ref\"], r0_list=case[\"bonds_r0\"],\n                theta0_deg_list=case[\"angles_theta0_deg\"], k_bond=case[\"k_bond\"],\n                k_angle=case[\"k_angle\"], k_dihedral=case[\"k_dihedral\"],\n                num_dihedrals=case[\"num_dihedrals\"]\n            )\n\n        # Anchor removal\n        dF_remove_anchor = anchor_removal_F(\n            T=case[\"T\"], kappa_t=case[\"kappa_t\"], kappa_r=case[\"kappa_r\"]\n        )\n\n        F_abs = dF1 + dF2 + dF_remove_rest + dF_remove_anchor\n        results.append(F_abs)\n\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3496016"}]}