{"hands_on_practices": [{"introduction": "一次成功的Car-Parrinello分子动力学 (CPMD) 模拟，其关键在于维持虚拟电子运动与真实离子运动之间的绝热分离。本练习 [@problem_id:3436526] 提供了一个基础实践，用于设置最关键的参数——虚拟质量 $\\mu$。你将通过应用电子运动频率必须远高于离子振动频率的原则，推导 $\\mu$ 的上限，从而确保电子始终保持在Born-Oppenheimer势能面上。", "problem": "考虑一个对绝缘固体进行的Car-Parrinello分子动力学 (CPMD) 模拟。虚拟电子质量参数，记为 $\\mu$，控制着Car-Parrinello拉格朗日量中电子自由度的惯性。为确保快速的电子振荡与较慢的离子运动之间的绝热解耦，要求电子角频率与最高离子角频率的目标分离因子满足 $\\omega_{e}/\\omega_{\\mathrm{ion}} \\geq 10$。假设该材料的电子能隙为 $\\Delta = 3\\,\\mathrm{eV}$，最高离子振动波数为 $\\tilde{\\nu}_{\\mathrm{ion}} = 1500\\,\\mathrm{cm}^{-1}$。在一致的单位制下进行计算，并且计算中需将离子振动波数转换为角频率。\n\n使用基本原理推导由该解耦准则所隐含的 $\\mu$ 的上限。然后使用以下常数对该上限进行数值计算：光速 $c = 2.99792458 \\times 10^{8}\\,\\mathrm{m\\,s^{-1}}$ 和电子伏特到焦耳的转换关系 $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$。将 $\\mu$ 的最终上限以 $\\mathrm{J\\,s^{2}}$ 为单位表示。将答案四舍五入至三位有效数字。", "solution": "问题陈述已被验证，并被认为是合理的、适定的和有科学依据的。它提出了计算材料科学领域中关于Car-Parrinello分子动力学 (CPMD) 模拟参数选择的一个标准情景。所有必要的数据均已提供，且目标明確。在给出波数之后，表述“将离子频率视为角频率”存在一个微小的歧义。这将被以物理上正确的方式来解释，即使用基本关系 $\\omega = 2\\pi c \\tilde{\\nu}$ 从给定的波数 $\\tilde{\\nu}_{\\mathrm{ion}}$ 计算角频率 $\\omega_{\\mathrm{ion}}$。直接的数值等价在物理上是无意义的，因为它将对应于一个极低的振动频率，与所提供的波数不一致。有了这一澄清，该问题是完全有效的。\n\nCar-Parrinello分子动力学方法通过为电子自由度引入一个虚拟动能，来同时演化离子位置和电子轨道。这种虚拟动力学由一个用户定义的参数，即虚拟质量 $\\mu$ 所控制。总拉格朗日量具有以下形式：\n$$L_{CP} = \\frac{1}{2}\\mu \\sum_i \\int |\\dot{\\psi}_i(\\mathbf{r},t)|^2 d\\mathbf{r} + \\frac{1}{2}\\sum_I M_I |\\dot{\\mathbf{R}}_I(t)|^2 - E[\\{\\psi_i\\}, \\{\\mathbf{R}_I\\}]$$\n其中 $\\psi_i$ 是电子轨道，$\\mathbf{R}_I$ 是离子位置，而 $E[\\{\\psi_i\\}, \\{\\mathbf{R}_I\\}]$ 是来自密度泛函理论的总势能。\n\n为使CPMD方案有效，对于任何给定的离子构型，电子子系统必须保持在其基态附近。这就是绝热解耦原理。它要求虚拟电子运动的特征频率 $\\omega_e$ 显著高于物理离子运动的最高频率 $\\omega_{\\mathrm{ion}}$。问题通过准则 $\\omega_e / \\omega_{\\mathrm{ion}} \\geq 10$ 指定了这种分离。\n\n对于一个在最高占据分子轨道和最低未占据分子轨道（或价带和导带）之间存在电子能隙 $\\Delta$ 的绝缘系统，可以证明其虚拟电子动力学的最低频率与 $\\Delta$ 和 $\\mu$ 的关系如下：\n$$\\omega_e = \\sqrt{\\frac{2\\Delta}{\\mu}}$$\n虚拟质量 $\\mu$ 的单位是能量 $\\times$ 时间$^2$，在国际单位制（SI）中为 $\\mathrm{J\\,s^2}$，这保证了量纲的一致性。\n\n最高的物理离子振动角频率 $\\omega_{\\mathrm{ion}}$，由给定的最高离子振动波数 $\\tilde{\\nu}_{\\mathrm{ion}}$ 使用以下关系式计算得出：\n$$\\omega_{\\mathrm{ion}} = 2\\pi c \\tilde{\\nu}_{\\mathrm{ion}}$$\n其中 $c$ 是光速。\n\n我们现在可以结合这些关系来求出 $\\mu$ 的上限。绝热条件是：\n$$\\frac{\\omega_e}{\\omega_{\\mathrm{ion}}} \\geq 10$$\n代入 $\\omega_e$ 的表达式：\n$$\\frac{\\sqrt{\\frac{2\\Delta}{\\mu}}}{\\omega_{\\mathrm{ion}}} \\geq 10$$\n为了找到对 $\\mu$ 的约束，我们整理该不等式：\n$$\\sqrt{\\frac{2\\Delta}{\\mu}} \\geq 10\\,\\omega_{\\mathrm{ion}}$$\n两边平方得：\n$$\\frac{2\\Delta}{\\mu} \\geq 100\\,\\omega_{\\mathrm{ion}}^2$$\n最后，解出 $\\mu$ 得到其上限：\n$$\\mu \\leq \\frac{2\\Delta}{100\\,\\omega_{\\mathrm{ion}}^2} = \\frac{\\Delta}{50\\,\\omega_{\\mathrm{ion}}^2}$$\n因此，虚拟质量的最大允许值为 $\\mu_{\\mathrm{max}} = \\frac{\\Delta}{50\\,\\omega_{\\mathrm{ion}}^2}$。\n\n接下来，我们代入 $\\omega_{\\mathrm{ion}}$ 的表达式：\n$$\\mu_{\\mathrm{max}} = \\frac{\\Delta}{50\\,(2\\pi c \\tilde{\\nu}_{\\mathrm{ion}})^2}$$\n\n我们现在使用提供的常数数值计算这个表达式，并确保所有量都采用国际单位制（SI）的基本单位。\n给定的数值为：\n- 电子能隙：$\\Delta = 3\\,\\mathrm{eV}$\n- 最高离子振动波数：$\\tilde{\\nu}_{\\mathrm{ion}} = 1500\\,\\mathrm{cm}^{-1}$\n- 光速：$c = 2.99792458 \\times 10^{8}\\,\\mathrm{m\\,s^{-1}}$\n- 转换因子：$1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$\n\n首先，我们将给定值转换为国际单位制（SI）单位：\n$$\\Delta = 3\\,\\mathrm{eV} \\times 1.602176634 \\times 10^{-19}\\,\\frac{\\mathrm{J}}{\\mathrm{eV}} = 4.806529902 \\times 10^{-19}\\,\\mathrm{J}$$\n$$\\tilde{\\nu}_{\\mathrm{ion}} = 1500\\,\\mathrm{cm}^{-1} \\times \\frac{100\\,\\mathrm{cm}}{1\\,\\mathrm{m}} = 1.5 \\times 10^{5}\\,\\mathrm{m}^{-1}$$\n\n现在，我们计算最高离子角频率 $\\omega_{\\mathrm{ion}}$：\n$$\\omega_{\\mathrm{ion}} = 2\\pi (2.99792458 \\times 10^{8}\\,\\mathrm{m\\,s^{-1}})(1.5 \\times 10^{5}\\,\\mathrm{m}^{-1})$$\n$$\\omega_{\\mathrm{ion}} \\approx 2.82539066 \\times 10^{14}\\,\\mathrm{s}^{-1}$$\n\n有了 $\\omega_{\\mathrm{ion}}$，我们可以计算它的平方：\n$$\\omega_{\\mathrm{ion}}^2 \\approx (2.82539066 \\times 10^{14}\\,\\mathrm{s}^{-1})^2 \\approx 7.9828333 \\times 10^{28}\\,\\mathrm{s}^{-2}$$\n\n最后，我们计算 $\\mu$ 的上限：\n$$\\mu_{\\mathrm{max}} = \\frac{\\Delta}{50\\,\\omega_{\\mathrm{ion}}^2} = \\frac{4.806529902 \\times 10^{-19}\\,\\mathrm{J}}{50 \\times (7.9828333 \\times 10^{28}\\,\\mathrm{s}^{-2})}$$\n$$\\mu_{\\mathrm{max}} = \\frac{4.806529902 \\times 10^{-19}}{3.99141665 \\times 10^{30}}\\,\\mathrm{J\\,s^2}$$\n$$\\mu_{\\mathrm{max}} \\approx 1.204207 \\times 10^{-49}\\,\\mathrm{J\\,s^2}$$\n将结果四舍五入到三位有效数字，我们得到：\n$$\\mu_{\\mathrm{max}} \\approx 1.20 \\times 10^{-49}\\,\\mathrm{J\\,s^2}$$\n这个值表示在满足指定的绝热解耦准则的前提下，模拟中可以使用的最大虚拟电子质量。更大的 $\\mu$ 值会导致较慢的虚拟电子动力学，从而有能量从物理的离子子系统虚假地转移到虚拟的电子子系统的风险，并可能导致Born-Oppenheimer近似的失效。", "answer": "$$\\boxed{1.20 \\times 10^{-49}}$$", "id": "3436526"}, {"introduction": "虽然CPMD方法对于有带隙的体系非常有效，但将其应用于能隙 $E_g$ 趋于零的金属体系时会面临重大挑战。本计算实验 [@problem_id:3436495] 将引导你构建一个模型，以模拟其关键的失效模式：离子与电子子系统间的共振能量转移。通过实现一个简化的耦合振子模型，你将亲身体验这种失效过程，并评估常用修正方案的有效性。", "problem": "要求您设计并实现一个最小化的、完全指定的计算实验，以捕捉当能隙趋近于零时，金属性体系中 Car–Parrinello 分子动力学 (CPMD) 崩溃的本质。目标现象是当虚拟电子固有频率与离子振动频率近似匹配时，离子与电子自由度之间的共振能量转移，以及评估诸如分数占据展宽和减小虚拟电子质量等补救措施的效果。该实验必须被构建为一个纯粹的数学模型，从经典拉格朗日力学和线性响应的第一性原理推导得出，并实现为单个可运行的程序。\n\n从以下符合背景的基础性依据出发：\n- Car–Parrinello 方法引入了一个虚拟电子质量，记为 $\\mu$，并将电子自由度与离子坐标一起作为动态变量处理，以近似绝热分离。当体系是金属性时，即电子能隙 $E_g$ 趋近于零时，绝热分离会失效，从而允许虚假的能量从离子运动流向电子模式。\n- 在线性响应近似下，从带有双线性耦合的二次拉格朗日量推导出的欧拉-拉格朗日方程，会得到关于离子坐标和一个有效电子坐标的耦合谐振子方程。\n- 一个质量为 $m$、劲度系数为 $k$ 的谐振子的固有频率为 $\\omega = \\sqrt{k/m}$。\n\n构建以下能够捕捉共振机制和补救措施的无量纲代理模型：\n1. 考虑单个离子坐标 $x(t)$（质量为 $M$，振动角频率为 $\\omega_i$）与单个有效电子坐标 $y(t)$（虚拟质量为 $\\mu$，内禀劲度系数与能隙 $E_g$ 成正比）相耦合。在能量对小偏离的二次展开中，取势能为\n$$\nV(x,y) = \\frac{1}{2} M \\omega_i^2 x^2 + \\frac{1}{2} k_{\\mathrm{el}} y^2 + \\kappa x y,\n$$\n其中耦合常数为 $\\kappa$ 且 $k_{\\mathrm{el}} \\propto E_g$。\n2. 在无量纲单位下，令电子劲度系数为 $k_{\\mathrm{el}} = E_g$，因此虚拟电子角频率为\n$$\n\\omega_{\\mathrm{el}} = \\sqrt{\\frac{k_{\\mathrm{el}}}{\\mu}} = \\sqrt{\\frac{E_g}{\\mu}}.\n$$\n3. 为了表示在有限电子温度下分数占据展宽 $f(\\epsilon)$ 的效应，为电子模式引入一个唯象的瑞利耗散函数，\n$$\n\\mathcal{R} = \\frac{1}{2} \\eta \\dot{y}^2,\n$$\n其中 $\\eta$ 是一个有效阻尼系数，它随着展宽宽度（或电子温度）单调增加。这将在电子运动方程中产生一个线性摩擦项 $\\eta \\dot{y}$。\n\n在这些假设下，并设定 $M = 1$（无量纲化），耦合运动方程变为\n$$\n\\ddot{x} + \\omega_i^2 x + \\frac{\\kappa}{M} y = 0, \\quad \\ddot{y} + \\frac{\\eta}{\\mu} \\dot{y} + \\omega_{\\mathrm{el}}^2 y + \\frac{\\kappa}{\\mu} x = 0,\n$$\n初始条件为\n$$\nx(0) = x_0, \\quad \\dot{x}(0) = v_{x,0}, \\quad y(0) = y_0, \\quad \\dot{y}(0) = v_{y,0}.\n$$\n将瞬时离子能量（不包括耦合项）定义为\n$$\nE_i(t) = \\frac{1}{2} M \\dot{x}(t)^2 + \\frac{1}{2} M \\omega_i^2 x(t)^2,\n$$\n并相应地定义初始离子能量 $E_i(0)$。将用于诊断 CP 崩溃的量定义为离子能量转移分数\n$$\n\\Phi = \\frac{E_i(0) - \\min_{t \\in [0,T]} E_i(t)}{E_i(0)},\n$$\n在有限的模拟时程 $[0,T]$ 上。较大的 $\\Phi$ 值表示有显著的能量从离子模式流向电子模式（CP 崩溃），而补救措施应能减小 $\\Phi$。\n\n实现一个四阶龙格-库塔时间积分方法来求解上述系统，以计算一系列测试用例的 $\\Phi$ 值。整个过程使用无量纲单位，其中 $M = 1$，$x_0 = 1$, $v_{x,0} = 0$, $y_0 = 0$, $v_{y,0} = 0$。在所有用例中，使用固定的均匀时间步长 $\\Delta t$ 和总时间 $T$。如果在 $E_g \\to 0$ 的边界情况下振幅变得数值不稳定，当 $|x|$ 或 $|y|$ 超过一个较大的阈值时应提早终止，并报告截至该点计算出的 $\\Phi$ 值。\n\n您的程序必须为以下测试套件计算 $\\Phi$ 值，该套件旨在探究共振、补救措施和边界情况：\n- A用例（共振基线）：$\\omega_i = 0.2$, $E_g = 0.2$, $\\mu = 5.0$, $\\kappa = 0.05$, $\\eta = 0.0$, $T = 50.0$, $\\Delta t = 0.01$。这使得 $\\omega_{\\mathrm{el}} \\approx \\omega_i$，应该会表现出强烈的共振转移。\n- B用例（减小 $\\mu$ 的补救措施）：$\\omega_i = 0.2$, $E_g = 0.2$, $\\mu = 0.5$, $\\kappa = 0.05$, $\\eta = 0.0$, $T = 50.0$, $\\Delta t = 0.01$。减小 $\\mu$ 会增加 $\\omega_{\\mathrm{el}}$，使共振失谐。\n- C用例（展宽补救措施）：$\\omega_i = 0.2$, $E_g = 0.2$, $\\mu = 5.0$, $\\kappa = 0.05$, $\\eta = 0.1$, $T = 50.0$, $\\Delta t = 0.01$。有限的 $\\eta$ 模拟了来自分数占据展宽 $f(\\epsilon)$ 的阻尼，从而减少共振转移。\n- D用例（无能隙边界）：$\\omega_i = 0.2$, $E_g = 0.0$, $\\mu = 5.0$, $\\kappa = 0.05$, $\\eta = 0.0$, $T = 50.0$, $\\Delta t = 0.01$。这探究了 $E_g \\to 0$ 的极限情况；可能会发生不稳定性。\n- E用例（弱耦合）：$\\omega_i = 0.2$, $E_g = 0.2$, $\\mu = 5.0$, $\\kappa = 0.001$, $\\eta = 0.0$, $T = 50.0$, $\\Delta t = 0.01$。这测试了即使在接近共振时，趋于零的耦合也会抑制能量转移。\n\n您的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[resultA,resultB,resultC,resultD,resultE]\"），列表中的每个条目是对应测试用例计算出的 $\\Phi$ 值（表示为浮点数）。不应打印任何额外文本。所有量都是无量纲的；不需要物理单位。", "solution": "该问题提出了一个有效且适定的计算实验，用于模拟金属性体系中 Car–Parrinello 分子动力学 (CPMD) 的崩溃。它以经典力学和线性响应理论的原理为科学依据，为一个复杂的量子现象提供了一个简化但机理正确的代理模型。该问题是自洽的，所有必需的参数、方程和初始条件都已明确指定。我将开始进行解答。\n\n问题的核心是求解一个耦合线性二阶常微分方程组 (ODEs)，并分析模式之间的能量转移。求解方法包括四个主要步骤：将运动方程形式化为状态空间表示法，对这些方程进行随时间变化的数值积分，计算代表能量转移的诊断量，并将此过程应用于指定的测试用例。\n\n### 1. 运动方程的状态空间公式化\n\n所提供的动力学系统由关于离子坐标 $x(t)$ 和虚拟电子坐标 $y(t)$ 的两个耦合二阶常微分方程组成：\n$$\n\\ddot{x} + \\omega_i^2 x + \\frac{\\kappa}{M} y = 0\n$$\n$$\n\\ddot{y} + \\frac{\\eta}{\\mu} \\dot{y} + \\omega_{\\mathrm{el}}^2 y + \\frac{\\kappa}{\\mu} x = 0\n$$\n其中 $\\omega_{\\mathrm{el}} = \\sqrt{E_g/\\mu}$。\n为了进行数值积分，标准做法是将该系统转换为一组一阶常微分方程。我们定义一个状态向量 $S(t)$，它包含两个坐标的位置和速度：\n$$\nS(t) = \\begin{bmatrix} s_0(t) \\\\ s_1(t) \\\\ s_2(t) \\\\ s_3(t) \\end{bmatrix} = \\begin{bmatrix} x(t) \\\\ \\dot{x}(t) \\\\ y(t) \\\\ \\dot{y}(t) \\end{bmatrix}\n$$\n系统的 时间演化随后由矩阵方程 $\\dot{S}(t) = f(t, S(t))$ 描述，其中 $f$ 是一个返回状态向量时间导数的函数。根据定义，$\\dot{s}_0 = \\dot{x} = s_1$ 且 $\\dot{s}_2 = \\dot{y} = s_3$。二阶导数由运动方程给出：\n$$\n\\dot{s}_1 = \\ddot{x} = -\\omega_i^2 s_0 - \\frac{\\kappa}{M} s_2\n$$\n$$\n\\dot{s}_3 = \\ddot{y} = -\\frac{\\kappa}{\\mu} s_0 - \\omega_{\\mathrm{el}}^2 s_2 - \\frac{\\eta}{\\mu} s_3\n$$\n这就给出了需要求解的完整一阶系统，其指定的初始条件向量为 $S(0) = [x_0, v_{x,0}, y_0, v_{y,0}]^T = [1, 0, 0, 0]^T$ 且 $M=1$。\n\n### 2. 通过四阶龙格-库塔 (RK4) 方法进行数值积分\n\n状态向量 $S(t)$ 从初始时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的时间演化使用四阶龙格-库塔 (RK4) 方法计算。这是一个稳健且广泛使用的数值方案，对于给定的时间步长 $\\Delta t$ 能提供高精度。对于一个通用常微分方程 $\\dot{S} = f(S)$，单个 RK4 步骤计算如下：\n$$\n\\begin{align*}\nk_1 = \\Delta t \\cdot f(S_n) \\\\\nk_2 = \\Delta t \\cdot f(S_n + k_1/2) \\\\\nk_3 = \\Delta t \\cdot f(S_n + k_2/2) \\\\\nk_4 = \\Delta t \\cdot f(S_n + k_3) \\\\\nS_{n+1} = S_n + \\frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\n此算法被实现用于以 $\\Delta t$ 的离散步长将状态向量 $S(t)$ 从 $t=0$ 传播到最终时间 $T$。其中包含一个检查，如果任一坐标的振幅 $|x(t)|$ 或 $|y(t)|$ 超过一个大阈值（例如 $100$），则终止模拟，这表示出现了数值不稳定性，尤其与无能隙情况 ($E_g=0$) 相关。\n\n### 3. 诊断量 $\\Phi$ 的计算\n\n主要诊断量 $\\Phi$ 衡量从离子振子转移走的能量分数。离子模式的瞬时能量定义为：\n$$\nE_i(t) = \\frac{1}{2} M \\dot{x}(t)^2 + \\frac{1}{2} M \\omega_i^2 x(t)^2\n$$\n$\\Phi$ 的值在模拟时间 $[0, T]$ 内计算：\n$$\n\\Phi = \\frac{E_i(0) - \\min_{t \\in [0,T]} E_i(t)}{E_i(0)}\n$$\n算法流程如下：\n1.  使用初始条件 $x(0)=1, \\dot{x}(0)=0$ 计算初始离子能量 $E_i(0)$。这得到 $E_i(0) = \\frac{1}{2} M \\omega_i^2$。\n2.  初始化一个变量 $\\min E_i$ 为 $E_i(0)$。\n3.  在 RK4 时间步进循环中，每步之后，使用新计算出的状态分量 $x(t)$ 和 $\\dot{x}(t)$ 计算当前的离子能量 $E_i(t)$。\n4.  更新 $\\min E_i = \\min(\\min E_i, E_i(t))$。\n5.  模拟完成（或因不稳定性而终止）后，使用记录的初始和最小离子能量计算 $\\Phi$ 的最终值。如果 $E_i(0)=0$（此处情况并非如此），则 $\\Phi$ 将为 $0$。\n\n### 4. 测试套件的实现\n\n上述过程被封装到一个函数中，该函数接受物理参数（$\\omega_i, E_g, \\mu, \\kappa, \\eta$）和模拟参数（$T, \\Delta t$）作为输入。然后对问题陈述中指定的五个测试用例（A-E）中的每一个调用该函数。每个用例得到的 $\\Phi$ 值被存储起来。最后，将收集到的结果按照最终输出的要求格式化为单个用方括号括起来的逗号分隔字符串。该实现使用 `numpy` 库进行高效的向量和矩阵运算，这对于状态空间表示和 RK4 计算是理想的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the coupled oscillator model for Car-Parrinello breakdown\n    and computes the fractional ionic energy transfer for a suite of test cases.\n    \"\"\"\n\n    def run_simulation(params):\n        \"\"\"\n        Runs a single simulation for a given set of parameters.\n\n        Args:\n            params (tuple): A tuple containing the parameters\n                            (wi, Eg, mu, kappa, eta, T, dt).\n\n        Returns:\n            float: The computed value of the fractional energy transfer Phi.\n        \"\"\"\n        # Unpack parameters from the input tuple\n        wi, Eg, mu, kappa, eta, T, dt = params\n\n        # Fixed physical and initial conditions from the problem statement\n        M = 1.0\n        x0, vx0, y0, vy0 = 1.0, 0.0, 0.0, 0.0\n\n        # Derived parameters for the equations of motion\n        # Handles the case Eg = 0 correctly, where wel_sq = 0.\n        if mu == 0:\n            # Fictitious mass must be positive.\n            # This case is not in the test suite but is a necessary check.\n            raise ValueError(\"Fictitious mass mu must be positive.\")\n        wel_sq = Eg / mu\n\n        # Define the system of first-order ODEs: S' = f(S)\n        # where S = [x, vx, y, vy]\n        def f(S):\n            x, vx, y, vy = S\n            x_dot = vx\n            vx_dot = -wi**2 * x - (kappa/M) * y\n            y_dot = vy\n            vy_dot = -(kappa/mu) * x - wel_sq * y - (eta/mu) * vy\n            return np.array([x_dot, vx_dot, y_dot, vy_dot])\n\n        # Initial state vector\n        S = np.array([x0, vx0, y0, vy0], dtype=float)\n\n        # Simulation time steps\n        num_steps = int(T / dt)\n\n        # Calculate initial ionic energy\n        E_i_initial = 0.5 * M * vx0**2 + 0.5 * M * wi**2 * x0**2\n        \n        # If initial energy is zero, no transfer can be measured.\n        if E_i_initial == 0:\n            return 0.0\n            \n        min_E_i = E_i_initial\n\n        # Define a large threshold for numerical instability\n        instability_threshold = 100.0\n\n        # Main RK4 integration loop\n        for _ in range(num_steps):\n            # Check for numerical instability before the next step\n            x, _, y, _ = S\n            if abs(x) > instability_threshold or abs(y) > instability_threshold:\n                break\n\n            # Fourth-Order Runge-Kutta (RK4) step\n            k1 = dt * f(S)\n            k2 = dt * f(S + 0.5 * k1)\n            k3 = dt * f(S + 0.5 * k2)\n            k4 = dt * f(S + k3)\n            S += (k1 + 2*k2 + 2*k3 + k4) / 6.0\n            \n            # Extract current ionic position and velocity from state vector\n            x_current, vx_current = S[0], S[1]\n            \n            # Calculate current ionic energy\n            E_i_current = 0.5 * M * vx_current**2 + 0.5 * M * wi**2 * x_current**2\n            \n            # Update the minimum ionic energy observed\n            if E_i_current  min_E_i:\n                min_E_i = E_i_current\n                \n        # Calculate the final diagnostic quantity Phi\n        phi = (E_i_initial - min_E_i) / E_i_initial\n        return phi\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (omega_i, E_g, mu, kappa, eta, T, dt)\n    test_cases = [\n        (0.2, 0.2, 5.0, 0.05, 0.0, 50.0, 0.01),   # Case A: Resonant baseline\n        (0.2, 0.2, 0.5, 0.05, 0.0, 50.0, 0.01),   # Case B: Reduced mu remedy\n        (0.2, 0.2, 5.0, 0.05, 0.1, 50.0, 0.01),   # Case C: Smearing remedy\n        (0.2, 0.0, 5.0, 0.05, 0.0, 50.0, 0.01),   # Case D: Gapless boundary\n        (0.2, 0.2, 5.0, 0.001, 0.0, 50.0, 0.01),  # Case E: Weak coupling\n    ]\n\n    results = []\n    for case_params in test_cases:\n        phi_value = run_simulation(case_params)\n        results.append(phi_value)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3436495"}, {"introduction": "从CPMD模拟中提取精确的热力学量，需要通过细致的后处理来移除模拟引入的非物理因素。本问题 [@problem_id:3436552] 旨在解决两个关键的校正：一是扣除虚拟电子动能 $K_e$ 这一非物理贡献，二是对偏置采样产生的数据进行重加权。通过实施这些校正，你将练习如何将原始模拟输出转化为有物理意义的自由能差，这是研究相变等问题的一项核心技能。", "problem": "考虑使用Car-Parrinello分子动力学（CPMD）估算两种多晶型物之间的自由能差。Car-Parrinello动力学通过引入一个由虚拟质量参数控制的额外虚拟电子自由度来增强物理离子-电子系统，这引入了一个虚拟电子动能。为了从可能包含集体变量偏置势的CPMD采样中获得无偏的物理自由能，必须同时校正虚拟电子动能和采样偏置。\n\n起点和定义：\n- Car-Parrinello分子动力学（CPMD）引入了一个与轨道速度相关的虚拟电子动能 $K_e$，它以相加的方式贡献给总能量。该虚拟能量不是我们感兴趣的离子自由能形貌的物理贡献。\n- 在温度为 $T$ 的正则系综中，逆热能为 $\\beta = 1/(k_B T)$，其中 $k_B$ 是玻尔兹曼常数。物理（无偏）系统的两个盆地 $A$ 和 $B$ 之间的自由能差定义为 $\\Delta F_{B\\leftarrow A} = F_B - F_A = -k_B T \\ln \\left(\\frac{Z_B}{Z_A}\\right)$，其中 $Z_A$ 和 $Z_B$ 分别是盆地 $A$ 和 $B$ 的受限配分函数贡献。\n- 当在采样过程中施加一个作为集体变量 $s$ 函数的偏置势 $U_{\\text{bias}}(s)$ 时，偏置系综的权重被修改为与 $\\exp\\left(-\\beta (E_{\\text{phys}} + U_{\\text{bias}}(s))\\right)$ 成正比。为了从偏置哈密顿量下生成的样本中恢复无偏系综平均值，每个带有偏置 $U_{\\text{bias}}(s_n)$ 的样本 $n$ 都必须通过因子 $\\exp(+\\beta U_{\\text{bias}}(s_n))$ 进行重加权。\n- 为与指令保持一致，定义 $\\Delta E_{\\text{bias}}(n) \\equiv -U_{\\text{bias}}(s_n)$，因此重加权因子为 $\\exp(-\\beta \\Delta E_{\\text{bias}}(n)) = \\exp(+\\beta U_{\\text{bias}}(s_n))$。\n- CPMD中的虚拟电子动能 $K_e$ 与物理离子-电子构型能是可分离的。在正则系综中，其每个盆地的平均贡献 $\\langle K_e \\rangle$ 作为自由能的加性偏移。因此，要将CPMD自由能差校正到其物理值，必须减去盆地平均虚拟动能的差值。\n\n基本原理：\n- 正则系综：$p(x) \\propto \\exp(-\\beta E(x))$，其中 $E(x)$ 为物理能量。\n- 自由能差：$\\Delta F_{B\\leftarrow A} = -k_B T \\ln\\left(\\frac{Z_B}{Z_A}\\right)$，其中 $Z_i = \\int_{\\Omega_i} \\mathrm{d}x \\exp(-\\beta E(x))$，$\\Omega_i$ 表示构型空间中的盆地区域 $i$。\n- 偏置采样重加权：如果采样使用 $E'(x) = E(x) + U_{\\text{bias}}(s(x))$ 进行，则配分函数的一个无偏估计量为 $Z_i \\propto \\sum_{n \\in i} \\exp(+\\beta U_{\\text{bias}}(s_n))$，其中求和遍及分配给盆地 $i$ 的样本 $n$。\n\n任务：\n- 给定离散的CPMD轨迹样本，包括集体变量 $s_n$、每个样本的偏置势 $U_{\\text{bias}}(s_n)$（单位为电子伏特）以及每个样本的虚拟电子动能 $K_{e,n}$（单位为电子伏特）。\n- 通过阈值 $s_0$ 定义两个多晶型盆地，使得盆地 A 包含 $s_n  s_0$ 的样本，盆地 B 包含 $s_n \\ge s_0$ 的样本。\n- 对每个测试用例，计算从 $A$ 到 $B$ 的校正后自由能差：\n$$\n\\Delta F_{B\\leftarrow A}^{\\text{corr}} = -k_B T \\left[ \\ln\\left(\\sum_{n \\in B} \\exp(-\\beta \\Delta E_{\\text{bias}}(n))\\right) - \\ln\\left(\\sum_{n \\in A} \\exp(-\\beta \\Delta E_{\\text{bias}}(n))\\right) \\right] - \\left( \\langle K_e \\rangle_B - \\langle K_e \\rangle_A \\right),\n$$\n其中 $\\Delta E_{\\text{bias}}(n) \\equiv -U_{\\text{bias}}(s_n)$，$\\langle K_e \\rangle_i$ 是盆地 $i$ 中样本 $K_{e,n}$ 的算术平均值。使用自然对数。\n- 以电子伏特（eV）表示最终的自由能差，并四舍五入到六位小数。\n\n角度单位说明：\n- 未使用角度，因此不需要角度单位说明。\n\n测试套件：\n- 玻尔兹曼常数：使用 $k_B = 8.617333262\\times 10^{-5}\\,\\mathrm{eV/K}$。\n- 对所有测试用例使用 $s_0 = 0.5$。\n- 测试用例1（正常路径）：温度 $T = 1000\\,\\mathrm{K}$，样本：\n    - $s$ 值：$[0.1, 0.2, 0.3, 0.45, 0.6, 0.7, 0.8, 0.55, 0.4, 0.65, 0.35, 0.75]$。\n    - 与 $s$ 对齐的偏置势 $U_{\\text{bias}}$（单位 $\\mathrm{eV}$）：$[0.1, 0.1, 0.1, 0.1, -0.05, -0.05, -0.05, -0.05, 0.1, -0.05, 0.1, -0.05]$。\n    - 与 $s$ 对齐的虚拟电子动能 $K_e$（单位 $\\mathrm{eV}$）：$[0.038, 0.041, 0.039, 0.040, 0.049, 0.051, 0.050, 0.048, 0.042, 0.052, 0.037, 0.047]$。\n- 测试用例2（边界：零偏置）：温度 $T = 800\\,\\mathrm{K}$，样本：\n    - $s$ 值：$[0.1, 0.2, 0.6, 0.7, 0.8, 0.4, 0.5, 0.55, 0.35, 0.65]$。\n    - 与 $s$ 对齐的偏置势 $U_{\\text{bias}}$（单位 $\\mathrm{eV}$）：$[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$。\n    - 与 $s$ 对齐的虚拟电子动能 $K_e$（单位 $\\mathrm{eV}$）：$[0.028, 0.032, 0.050, 0.049, 0.051, 0.031, 0.052, 0.048, 0.029, 0.050]$。\n- 测试用例3（边缘：零虚拟动能下的极强偏置）：温度 $T = 300\\,\\mathrm{K}$，样本：\n    - $s$ 值：$[0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 0.4]$。\n    - 与 $s$ 对齐的偏置势 $U_{\\text{bias}}$（单位 $\\mathrm{eV}$）：$[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3]$。\n    - 与 $s$ 对齐的虚拟电子动能 $K_e$（单位 $\\mathrm{eV}$）：$[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含测试用例1、2和3的校正后自由能差 $\\Delta F_{B\\leftarrow A}^{\\text{corr}}$，按此顺序排列，格式为方括号内以逗号分隔的列表，例如 $[x_1,x_2,x_3]$，其中每个 $x_i$ 是一个以电子伏特为单位、四舍五入到六位小数的浮点数。", "solution": "目标是设计一个有原则的估计器，用于从Car-Parrinello分子动力学（CPMD）轨迹数据中计算两个多晶型盆地之间的自由能差，并对虚拟电子动能和采样偏置进行校正。推导过程基于经典统计力学和CPMD公式。\n\n从温度为 $T$ 的正则系综开始。对于具有构型态 $x$ 和物理能量 $E_{\\text{phys}}(x)$ 的物理系统，概率密度为 $p(x) \\propto \\exp(-\\beta E_{\\text{phys}}(x))$，其中 $\\beta = 1/(k_B T)$。限制在盆地 $i \\in \\{A,B\\}$ 内的自由能由下式给出\n$$\nF_i = -k_B T \\ln Z_i + \\text{constant}, \\quad \\text{其中} \\quad Z_i = \\int_{\\Omega_i} \\mathrm{d}x\\, \\exp(-\\beta E_{\\text{phys}}(x)),\n$$\n其中 $\\Omega_i$ 表示由集体变量准则定义的与盆地 $i$ 相对应的构型空间区域。物理上有意义的自由能差为\n$$\n\\Delta F_{B\\leftarrow A} = F_B - F_A = -k_B T \\ln\\left(\\frac{Z_B}{Z_A}\\right),\n$$\n它与 $F_i$ 中的加性常数无关。\n\n在偏置采样方法中，一个偏置势 $U_{\\text{bias}}(s(x))$被显式地添加到哈密顿量中，以增强对某些区域的采样，\n$$\nE'(x) = E_{\\text{phys}}(x) + U_{\\text{bias}}(s(x)).\n$$\n在 $E'(x)$ 下生成的样本遵循 $p'(x) \\propto \\exp(-\\beta E'(x)) = \\exp(-\\beta E_{\\text{phys}}(x))\\exp(-\\beta U_{\\text{bias}}(s(x)))$ 的分布。为了恢复无偏系综平均值，每个样本必须通过 $\\exp(+\\beta U_{\\text{bias}}(s(x)))$ 进行重加权，以便\n$$\nZ_i \\propto \\sum_{n \\in i} \\exp(+\\beta U_{\\text{bias}}(s_n)).\n$$\n为了与指令表示法匹配，定义 $\\Delta E_{\\text{bias}}(n) \\equiv -U_{\\text{bias}}(s_n)$，从而得到重加权因子 $\\exp(-\\beta \\Delta E_{\\text{bias}}(n)) = \\exp(+\\beta U_{\\text{bias}}(s_n))$。\n\nCar-Parrinello分子动力学（CPMD）通过带有虚拟质量的虚拟电子自由度 $\\{\\psi_j\\}$ 来增强物理系统。CPMD拉格朗日量包含一个虚拟动能\n$$\nK_e = \\sum_j \\frac{\\mu}{2} \\left\\| \\dot{\\psi}_j \\right\\|^2,\n$$\n它在虚拟速度上是二次的，并且与 $E_{\\text{phys}}(x)$ 可分离。在正则系综中，可分离的二次自由度对自由能有加性贡献。因此，限制在盆地 $i$ 内的总CPMD自由能为\n$$\nF_i^{\\text{CP}} = F_i^{\\text{phys}} + \\langle K_e \\rangle_i + \\text{constant}.\n$$\n因此，盆地间的CPMD自由能差与物理自由能差相差一个盆地平均虚拟动能的差值，\n$$\n\\Delta F_{B\\leftarrow A}^{\\text{CP}} = \\Delta F_{B\\leftarrow A}^{\\text{phys}} + \\left( \\langle K_e \\rangle_B - \\langle K_e \\rangle_A \\right).\n$$\n为了校正CPMD估计并获得物理自由能差，需减去虚拟动能差，\n$$\n\\Delta F_{B\\leftarrow A}^{\\text{corr}} = \\Delta F_{B\\leftarrow A}^{\\text{phys}} = \\Delta F_{B\\leftarrow A}^{\\text{CP}} - \\left( \\langle K_e \\rangle_B - \\langle K_e \\rangle_A \\right).\n$$\n\n结合偏置采样重加权和虚拟动能校正，我们从离散样本中获得了可计算的估计器：\n$$\n\\Delta F_{B\\leftarrow A}^{\\text{corr}} = -k_B T \\left[ \\ln\\left(\\sum_{n \\in B} \\exp(-\\beta \\Delta E_{\\text{bias}}(n))\\right) - \\ln\\left(\\sum_{n \\in A} \\exp(-\\beta \\Delta E_{\\text{bias}}(n))\\right) \\right] - \\left( \\langle K_e \\rangle_B - \\langle K_e \\rangle_A \\right),\n$$\n其中 $\\Delta E_{\\text{bias}}(n) \\equiv -U_{\\text{bias}}(s_n)$，$\\langle K_e \\rangle_i$ 是分配给盆地 $i$ 的样本 $K_{e,n}$ 的算术平均值。\n\n算法设计：\n- 通过阈值 $s_0$ 将样本划分为盆地 $A$ 和 $B$：$A$ 对应 $s_n  s_0$，$B$ 对应 $s_n \\ge s_0$。\n- 计算 $\\beta = 1/(k_B T)$，其中 $k_B = 8.617333262 \\times 10^{-5}\\,\\mathrm{eV/K}$。\n- 为保证数值稳定性，使用log-sum-exp恒等式计算指数和的对数。对于一个集合 $\\{x_i\\}$，\n$$\n\\ln\\left(\\sum_i \\exp(x_i)\\right) = m + \\ln\\left(\\sum_i \\exp(x_i - m)\\right), \\quad \\text{其中} \\quad m = \\max_i x_i,\n$$\n以防止当 $\\beta U_{\\text{bias}}$ 的量级很大时发生上溢或下溢。\n- 令盆地 $i$ 中样本的 $x_n^{(i)} = -\\beta \\Delta E_{\\text{bias}}(n) = +\\beta U_{\\text{bias}}(s_n)$。通过log-sum-exp方法计算\n$$\nL_i = \\ln\\left(\\sum_{n \\in i} \\exp(x_n^{(i)})\\right)\n$$\n。\n- 计算虚拟动能的盆地平均值：\n$$\n\\langle K_e \\rangle_i = \\frac{1}{N_i} \\sum_{n \\in i} K_{e,n}.\n$$\n- 组合得到校正后的自由能差：\n$$\n\\Delta F_{B\\leftarrow A}^{\\text{corr}} = -k_B T \\left( L_B - L_A \\right) - \\left( \\langle K_e \\rangle_B - \\langle K_e \\rangle_A \\right).\n$$\n- 对每个测试用例重复此过程，并以电子伏特为单位，按要求的单行格式呈现结果，四舍五入到六位小数。\n\n测试套件覆盖范围：\n- 测试用例1使用中等大小的正偏置和负偏置值，以确保两个盆地都被采样；重加权改变了表观的布居数比例，而虚拟动能差则产生一个小的加性校正。\n- 测试用例2使用零偏置，因此重加权因子为1；校正仅来自于虚拟动能差。\n- 测试用例3在低温下对盆地 $A$ 使用强正偏置，产生大的指数项；log-sum-exp计算确保了数值稳定性。虚拟动能值为零，因此校正简化为纯粹的重加权。\n\n最终的程序使用所提供的数据确定性地实现了这个估计器，并以电子伏特为单位，将三个测试用例的校正后自由能差打印为单个方括号括起来的、以逗号分隔的列表，四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef logsumexp(x: np.ndarray) - float:\n    \"\"\"\n    Numerically stable log-sum-exp computation.\n    Returns log(sum(exp(x))) for a 1D array x.\n    \"\"\"\n    if x.size == 0:\n        # Should not happen for provided test cases; return -inf if empty.\n        return -np.inf\n    m = np.max(x)\n    return float(m + np.log(np.sum(np.exp(x - m))))\n\ndef corrected_free_energy(T_K, s0, s_values, U_bias_values, Ke_values):\n    \"\"\"\n    Compute corrected free energy difference ΔF_{B-A}^{corr} in eV at temperature T_K.\n    Inputs:\n        T_K: temperature in Kelvin\n        s0: threshold defining basins (A: s  s0, B: s >= s0)\n        s_values: list of collective variable samples\n        U_bias_values: list of bias potential energies U_bias(s) in eV, aligned to s_values\n        Ke_values: list of fictitious electronic kinetic energies K_e in eV, aligned to s_values\n    Output:\n        ΔF_corr (float): corrected free energy difference in eV\n    \"\"\"\n    k_B_eV_per_K = 8.617333262e-5  # eV/K\n    kBT = k_B_eV_per_K * T_K\n    beta = 1.0 / kBT\n\n    s = np.array(s_values, dtype=float)\n    U_bias = np.array(U_bias_values, dtype=float)\n    Ke = np.array(Ke_values, dtype=float)\n\n    # Basin masks\n    mask_A = s  s0\n    mask_B = ~mask_A  # s >= s0\n\n    # Reweighting exponent x_n = -beta * ΔE_bias(n) = +beta * U_bias(n)\n    x_A = beta * U_bias[mask_A]\n    x_B = beta * U_bias[mask_B]\n\n    # Log-sum-exp for each basin\n    L_A = logsumexp(x_A)\n    L_B = logsumexp(x_B)\n\n    # Basin-averaged fictitious kinetic energies\n    Ke_A_avg = float(np.mean(Ke[mask_A])) if np.any(mask_A) else 0.0\n    Ke_B_avg = float(np.mean(Ke[mask_B])) if np.any(mask_B) else 0.0\n\n    # Corrected free energy difference ΔF_{B-A}^{corr}\n    deltaF_corr = -kBT * (L_B - L_A) - (Ke_B_avg - Ke_A_avg)\n    return deltaF_corr\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"T_K\": 1000.0,\n            \"s0\": 0.5,\n            \"s_values\": [0.1, 0.2, 0.3, 0.45, 0.6, 0.7, 0.8, 0.55, 0.4, 0.65, 0.35, 0.75],\n            \"U_bias_values\": [0.1, 0.1, 0.1, 0.1, -0.05, -0.05, -0.05, -0.05, 0.1, -0.05, 0.1, -0.05],\n            \"Ke_values\": [0.038, 0.041, 0.039, 0.040, 0.049, 0.051, 0.050, 0.048, 0.042, 0.052, 0.037, 0.047],\n        },\n        # Test Case 2 (zero bias)\n        {\n            \"T_K\": 800.0,\n            \"s0\": 0.5,\n            \"s_values\": [0.1, 0.2, 0.6, 0.7, 0.8, 0.4, 0.5, 0.55, 0.35, 0.65],\n            \"U_bias_values\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n            \"Ke_values\": [0.028, 0.032, 0.050, 0.049, 0.051, 0.031, 0.052, 0.048, 0.029, 0.050],\n        },\n        # Test Case 3 (strong bias, zero Ke)\n        {\n            \"T_K\": 300.0,\n            \"s0\": 0.5,\n            \"s_values\": [0.55, 0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 0.4],\n            \"U_bias_values\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.3],\n            \"Ke_values\": [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        deltaF = corrected_free_energy(\n            T_K=case[\"T_K\"],\n            s0=case[\"s0\"],\n            s_values=case[\"s_values\"],\n            U_bias_values=case[\"U_bias_values\"],\n            Ke_values=case[\"Ke_values\"],\n        )\n        # Round to six decimal places\n        results.append(f\"{deltaF:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3436552"}]}