{"hands_on_practices": [{"introduction": "自由能微扰 (FEP) 的核心是 Zwanzig 方程，它将两个态之间的自由能差与系综平均联系起来。这个练习 [@problem_id:3453627] 旨在提供实现这一核心公式的直接实践，指导你如何利用模拟产生的能量数据计算自由能差。更重要的是，本练习还将介绍一项至关重要的技能：使用 delta 方法估计统计误差，这是任何定量科学研究都不可或缺的一步。", "problem": "给定一组从由参考势 $U_0(\\mathbf{x})$ 定义的正则系综中采样的独立构型 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$，以及在绝对温度 $T$（单位：开尔文）下，相应的能量差 $\\Delta U_i = U_1(\\mathbf{x}_i) - U_0(\\mathbf{x}_i)$（单位：千焦每摩尔，kJ mol$^{-1}$）。使用自由能微扰（FEP）框架，$U_0$ 和 $U_1$ 之间的 Helmholtz 自由能变化 $\\Delta F$ 可以通过在 $U_0$ 下的统计期望与摩尔正则配分函数相关联。摩尔逆温度为 $\\beta = (R T)^{-1}$，其中 $R$ 是摩尔气体常数。您的任务是实现一个程序，对每个测试用例执行以下操作：\n- 计算权重 $w_i = e^{-\\beta \\Delta U_i}$。\n- 计算 $\\{w_i\\}$ 的样本均值 $\\bar{w}$ 和无偏样本方差 $s_w^2$。\n- 使用自由能的正则定义以及配分函数之比所蕴含的对数关系，将 $\\bar{w}$ 转换为摩尔自由能变化 $\\Delta F$（单位：kJ mol$^{-1}$）。\n- 通过对数变换 $f(m)$（其中 $m$ 表示 $\\{w_i\\}$ 的样本均值）的一阶泰勒展开（delta 方法），线性传播均值的不确定度，以估算 $\\Delta F$ 的标准误差（单位：kJ mol$^{-1}$）。\n\n使用摩尔气体常数 $R = 8.314462618 \\times 10^{-3}$ kJ mol$^{-1}$ K$^{-1}$。对于任何 $N=1$ 的情况，定义 $s_w^2=0$ 并返回标准误差 $0$ kJ mol$^{-1}$。将所有最终的自由能变化及其标准误差以 kJ mol$^{-1}$ 为单位表示，并四舍五入到六位小数。\n\n实现程序以处理以下参数值的测试套件：\n- 测试用例 1：$T = 300$ K, $\\{\\Delta U_i\\} = \\{-1.2, 0.5, 0.0, 1.3, -0.7, 0.2\\}$ kJ mol$^{-1}$。\n- 测试用例 2：$T = 298.15$ K, $\\{\\Delta U_i\\} = \\{0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1\\}$ kJ mol$^{-1}$。\n- 测试用例 3：$T = 300$ K, $\\{\\Delta U_i\\} = \\{12.0, 0.0, 5.0, -1.0, 3.0, 8.0, -2.0\\}$ kJ mol$^{-1}$。\n- 测试用例 4：$T = 100$ K, $\\{\\Delta U_i\\} = \\{0.5, 1.0, -0.2, 0.3, -0.1, 0.0\\}$ kJ mol$^{-1}$。\n- 测试用例 5：$T = 1000$ K, $\\{\\Delta U_i\\} = \\{5.0, -5.0, 2.0, -2.0, 0.0\\}$ kJ mol$^{-1}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是对应测试用例的一个双元素列表 $\\left[\\Delta F, \\text{SE}\\right]$，两者均以 kJ mol$^{-1}$ 为单位，并四舍五入到六位小数。例如：$\\left[[a,b],[c,d],\\dots\\right]$，其中 $a、b、c、d$ 是浮点数。", "solution": "该问题要求在统计力学中，基于自由能微扰（FEP）原理实现一项计算。任务的核心是估算由势能 $U_0$ 和 $U_1$ 定义的两个状态之间的 Helmholtz 自由能变化 $\\Delta F$，并量化此估算的统计不确定性。\n\n在正则系综（粒子数 $N$、体积 $V$ 和温度 $T$ 恒定）中，连接自由能与系统微观状态的基本关系由下式给出：\n$$ F = -k_{\\mathrm{B}} T \\ln Z $$\n其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$Z$ 是正则配分函数。对于问题中指定的摩尔量，这表示为：\n$$ F = -RT \\ln Q $$\n其中 $R$ 是摩尔气体常数，$Q$ 是摩尔配分函数。自由能的变化 $\\Delta F = F_1 - F_0$ 则为：\n$$ \\Delta F = -RT \\ln \\left( \\frac{Q_1}{Q_0} \\right) $$\n具有势能函数 $U_1(\\mathbf{x})$ 和 $U_0(\\mathbf{x})$ 的两个系统的配分函数之比，可以写成在参考态（系统 0）上的系综平均值：\n$$ \\frac{Q_1}{Q_0} = \\frac{\\int e^{-\\beta U_1(\\mathbf{x})} d\\mathbf{x}}{\\int e^{-\\beta U_0(\\mathbf{x})} d\\mathbf{x}} = \\frac{\\int e^{-\\beta (U_1(\\mathbf{x}) - U_0(\\mathbf{x}))} e^{-\\beta U_0(\\mathbf{x})} d\\mathbf{x}}{\\int e^{-\\beta U_0(\\mathbf{x})} d\\mathbf{x}} = \\langle e^{-\\beta \\Delta U} \\rangle_0 $$\n此处，$\\beta = (RT)^{-1}$ 是摩尔逆温度，$\\Delta U = U_1 - U_0$ 是势能差。将此代入 $\\Delta F$ 的表达式中，得到作为 FEP 基石的 Zwanzig 方程：\n$$ \\Delta F = -RT \\ln \\langle e^{-\\beta \\Delta U} \\rangle_0 $$\n在计算环境中，我们无法访问完整的系综。取而代之的是，我们给定从参考系综（由 $U_0$ 定义）中采样的有限数量的 $N$ 个构型 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$。因此，系综平均 $\\langle \\dots \\rangle_0$ 通过样本均值来估计。我们首先为每个构型计算权重 $w_i$：\n$$ w_i = e^{-\\beta \\Delta U_i} $$\n其中 $\\Delta U_i = U_1(\\mathbf{x}_i) - U_0(\\mathbf{x}_i)$ 是所提供的能量差。这些权重的样本均值 $\\bar{w}$ 作为系综平均的估计量：\n$$ \\bar{w} = \\frac{1}{N} \\sum_{i=1}^{N} w_i $$\n这导出了估算自由能变化的计算公式：\n$$ \\Delta F = -RT \\ln \\bar{w} $$\n下一步是估算 $\\Delta F$ 中的统计误差。由于 $\\Delta F$ 是样本均值 $\\bar{w}$ 的函数，我们可以将不确定性从 $\\bar{w}$ 传播到 $\\Delta F$。均值的标准误差 $\\text{SE}(\\bar{w})$ 由下式给出：\n$$ \\text{SE}(\\bar{w}) = \\frac{s_w}{\\sqrt{N}} $$\n其中 $s_w$ 是权重的样本标准差。对于 $N > 1$，样本方差 $s_w^2$ 使用无偏估计量计算：\n$$ s_w^2 = \\frac{1}{N-1} \\sum_{i=1}^{N} (w_i - \\bar{w})^2 $$\n对于 $N=1$ 的特殊情况，问题指定 $s_w^2=0$，这意味着 $s_w=0$，因此 $\\text{SE}(\\bar{w})=0$。\n\n为了找到 $\\Delta F$ 的标准误差，记为 $\\text{SE}(\\Delta F)$，我们使用 delta 方法，该方法应用一阶泰勒展开来传播方差。对于一个通用函数 $f(m)$，$f(\\bar{w})$ 的方差近似为：\n$$ \\text{Var}(f(\\bar{w})) \\approx [f'(\\mathbb{E}[\\bar{w}])]^2 \\text{Var}(\\bar{w}) $$\n在我们的例子中，函数是 $f(m) = -RT \\ln m$。它对 $m$ 的导数是：\n$$ f'(m) = \\frac{d}{dm}(-RT \\ln m) = -\\frac{RT}{m} $$\n我们在样本均值 $\\bar{w}$ 处评估此导数，并使用均值的估计方差 $\\widehat{\\text{Var}}(\\bar{w}) = (\\text{SE}(\\bar{w}))^2 = s_w^2/N$。那么 $\\Delta F$ 的方差是：\n$$ \\text{Var}(\\Delta F) \\approx \\left( -\\frac{RT}{\\bar{w}} \\right)^2 \\frac{s_w^2}{N} = \\left( \\frac{RT}{\\bar{w}} \\right)^2 \\frac{s_w^2}{N} $$\n$\\Delta F$ 的标准误差是其方差的平方根：\n$$ \\text{SE}(\\Delta F) = \\sqrt{\\text{Var}(\\Delta F)} = \\left| \\frac{RT}{\\bar{w}} \\right| \\frac{s_w}{\\sqrt{N}} $$\n由于 $R$、$T$ 和 $\\bar{w}$（作为正数 $w_i > 0$ 的均值）都是正数，因此绝对值是不必要的。\n$$ \\text{SE}(\\Delta F) = \\frac{RT}{\\bar{w}} \\frac{s_w}{\\sqrt{N}} $$\n此公式用于 $N > 1$ 的情况。对于 $N=1$，由于 $s_w=0$，标准误差 $\\text{SE}(\\Delta F)$ 也为 $0$。\n\n每个测试用例的算法如下：\n1.  给定温度 $T$ 和一组能量差 $\\{\\Delta U_i\\}$，确定样本大小 $N$。\n2.  使用提供的常数 $R = 8.314462618 \\times 10^{-3}$ kJ mol$^{-1}$ K$^{-1}$ 来计算热能 $RT$ 和摩尔逆温度 $\\beta = (RT)^{-1}$。\n3.  使用 $w_i = e^{-\\beta \\Delta U_i}$ 计算权重集合 $\\{w_i\\}$。\n4.  计算权重的样本均值 $\\bar{w}$。\n5.  计算自由能变化 $\\Delta F = -RT \\ln \\bar{w}$。\n6.  如果 $N > 1$，计算无偏样本方差 $s_w^2 = \\frac{1}{N-1}\\sum(w_i - \\bar{w})^2$。然后，计算标准误差 $\\text{SE}(\\Delta F) = \\frac{RT}{\\bar{w}} \\sqrt{\\frac{s_w^2}{N}}$。\n7.  如果 $N \\le 1$，设置 $\\text{SE}(\\Delta F) = 0$。\n8.  将 $\\Delta F$ 和 $\\text{SE}(\\Delta F)$ 四舍五入到六位小数，并将其格式化为双元素列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the free energy change and its standard error using the Free\n    Energy Perturbation (FEP) method for a suite of test cases.\n    \"\"\"\n    # Molar gas constant in kJ mol^-1 K^-1\n    R = 8.314462618e-3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (300.0, np.array([-1.2, 0.5, 0.0, 1.3, -0.7, 0.2])),\n        (298.15, np.array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1])),\n        (300.0, np.array([12.0, 0.0, 5.0, -1.0, 3.0, 8.0, -2.0])),\n        (100.0, np.array([0.5, 1.0, -0.2, 0.3, -0.1, 0.0])),\n        (1000.0, np.array([5.0, -5.0, 2.0, -2.0, 0.0])),\n    ]\n\n    results = []\n    for T, delta_U_values in test_cases:\n        # Number of samples\n        N = len(delta_U_values)\n\n        # Thermal energy in kJ mol^-1\n        RT = R * T\n        \n        # Molar inverse temperature in mol kJ^-1\n        if RT == 0:\n            # Avoid division by zero, although not expected for T > 0\n            # If RT is zero, FEP is ill-defined. We can treat this as an edge case.\n            # However, all given T are positive. This is for robustness.\n            # A very large beta would lead to weights being 0 or inf.\n            # For simplicity, we proceed, but np.exp will handle large args.\n            beta = np.inf\n        else:\n            beta = 1.0 / RT\n\n        # Calculate weights w_i = exp(-beta * deltaU_i)\n        weights = np.exp(-beta * delta_U_values)\n\n        # Calculate the sample mean of the weights\n        w_bar = np.mean(weights)\n\n        # Calculate free energy change in kJ mol^-1\n        # np.log is the natural logarithm\n        if w_bar == 0:\n            # Logarithm of non-positive number is undefined.\n            # Weights are always positive, so w_bar should be positive.\n            # This is a safeguard.\n            delta_F = np.nan\n        else:\n            delta_F = -RT * np.log(w_bar)\n\n        # Estimate the standard error of the free energy change\n        if N > 1:\n            # Unbiased sample variance of weights (ddof=1)\n            s_w_sq = np.var(weights, ddof=1)\n            \n            # Standard error of Delta F using the delta method\n            # SE(ΔF) = (RT/w_bar) * SE(w_bar)\n            # SE(w_bar) = s_w / sqrt(N) = sqrt(s_w_sq / N)\n            if w_bar > 0:\n                se_delta_F = (RT / w_bar) * np.sqrt(s_w_sq / N)\n            else:\n                 se_delta_F = np.nan\n        else:\n            # As per problem statement for N=1\n            se_delta_F = 0.0\n\n        # Round to six decimal places\n        delta_F_rounded = round(delta_F, 6)\n        se_delta_F_rounded = round(se_delta_F, 6)\n\n        results.append(f\"[{delta_F_rounded},{se_delta_F_rounded}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3453627"}, {"introduction": "在掌握了基本的 FEP 计算之后，下一步是学习如何评估其可靠性，因为 FEP 估计的准确性严重依赖于初末态之间充分的相空间重叠。这个练习 [@problem_id:3453645] 引入了一个强大的诊断工具——重叠矩阵，用于定量评估这种重叠程度。通过完成这项实践，你将能够判断一个简单的 FEP 计算何时可能是不可靠的，这是在实际研究中避免错误结论的关键。", "problem": "给定一个炼金路径，它被离散化为 $\\lambda$ 窗，索引为 $i \\in \\{0,1,\\dots,L-1\\}$。对于每对窗口 $(i,j)$，我们将诊断重叠矩阵的元素定义为在窗口 $i$ 下的系综平均值，\n$$\nW_{ij} \\equiv \\left\\langle \\exp\\left(-\\beta \\left(U_j - U_i\\right)\\right) \\right\\rangle_i,\n$$\n其中 $U_i$ 和 $U_j$ 分别是在窗口 $i$ 和 $j$ 下评估的相同构象的势能，$\\beta = \\frac{1}{k_{\\mathrm{B}} T}$，温度 $T$ 的单位为 $\\mathrm{K}$，玻尔兹曼常数 $k_{\\mathrm{B}}$ 的单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。该设置用于自由能微扰（FEP）诊断中，以评估构象空间重叠情况。\n\n假设沿炼金路径的能量差符合以下理想化但科学上合理的模型：\n- 该路径由 $L$ 个窗口组成，当视为能量差时，由 $\\lambda$ 的连续增量引起的相邻窗口间的能量差是独立同分布的。\n- 对于相邻窗口之间的单步，在系综 $i$ 下采样的能量差 $\\Delta U_{i \\to i+1} \\equiv U_{i+1} - U_i$ 被建模为一个正态随机变量，其均值为 $a$（单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$），方差为 $s^2$（单位为 $(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^2$），记为 $\\mathcal{N}(a, s^2)$。\n- 根据增量的独立性，当在系综 $i$ 下采样时，$n$ 步差遵循 $\\Delta U_{i \\to j} \\sim \\mathcal{N}\\!\\left((j-i)\\,a, |j-i|\\,s^2\\right)$。\n\n任务：\n1. 从 $W_{ij}$ 的定义和给定的 $\\Delta U_{i \\to j}$ 高斯模型出发，推导出一个用 $a$、$s$、$i$、$j$ 和 $\\beta$ 表示 $W_{ij}$ 的显式表达式，过程中不得使用任何未经证明的简化公式。请清楚地陈述你使用的每个数学步骤和原理。\n2. 使用你推导出的表达式，为给定的 $L$、$a$、$s$ 和 $T$ 构建完整的矩阵 $W \\in \\mathbb{R}^{L \\times L}$。\n3. 定义一个用于判断相邻窗口间重叠不足的自动标记规则：当且仅当两个方向的重叠都满足 $\\min\\{W_{i,i+1}, W_{i+1,i}\\} \\ge \\tau$ 时，段 $(i,i+1)$ 被认为具有足够的重叠，其中 $\\tau$ 是一个给定的阈值（无量纲）。否则，该段被标记为重叠不足。对于每组参数，生成所有被标记的段 $(i,i+1)$ 的索引 $i \\in \\{0,1,\\dots,L-2\\}$ 的列表。\n4. 物理单位：使用 $k_{\\mathrm{B}} = 0.00831446261815324$（单位 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$）和 $T$（单位 $\\mathrm{K}$）。所有能量 $a$ 和 $s$ 的单位必须是 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。诊断重叠 $W_{ij}$ 是无量纲的。\n5. 实现一个完整、可运行的程序，为以下测试套件计算所需的输出。你的程序不应读取输入；它必须在内部使用这些参数集。\n\n测试套件（每个案例为 $(L, T, a, s, \\tau)$）：\n- 案例 A（典型的良好重叠）：$(L=\\;5,\\; T=\\;300,\\; a=\\;0.5,\\; s=\\;1.0,\\; \\tau=\\;0.03)$。\n- 案例 B（因均值不匹配过大导致的重叠不良）：$(L=\\;6,\\; T=\\;300,\\; a=\\;9.0,\\; s=\\;1.0,\\; \\tau=\\;0.03)$。\n- 案例 C（选择边界条件，使得相邻的前向重叠在一个步骤中等于阈值）：$(L=\\;4,\\; T=\\;300,\\; a=\\;\\text{选择使得单步前向重叠等于}\\tau,\\; s=\\;1.0,\\; \\tau=\\;0.03)$。你必须使用你推导的表达式，在给定的 $T$ 和 $s$ 条件下，确定对应的 $a$ 值。\n- 案例 D（更高温度改善有效重叠）：$(L=\\;3,\\; T=\\;600,\\; a=\\;9.0,\\; s=\\;1.0,\\; \\tau=\\;0.03)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个 Python 列表的逗号分隔列表形式的结果，每个内部列表对应一个测试案例，并包含该案例中被标记的相邻段 $(i,i+1)$ 的索引 $i$（整数）。例如，一个包含四个案例的输出可能看起来像 $[[],[0,1,2],[],[1]]$。\n- 不应打印任何额外文本；只应生成包含该列表的单行。", "solution": "该问题要求推导炼金路径的诊断重叠矩阵，利用该矩阵评估相邻模拟窗口间的采样质量，并将此逻辑实现为一个程序。对问题陈述的验证确认了其科学上的合理性、问题的良定性和完整性。因此，我们可以着手提供一个完整的解决方案。\n\n### 第一部分：重叠矩阵元素 $W_{ij}$ 的推导\n\n诊断重叠矩阵元素 $W_{ij}$ 由系综平均值定义：\n$$\nW_{ij} \\equiv \\left\\langle \\exp\\left(-\\beta \\left(U_j - U_i\\right)\\right) \\right\\rangle_i\n$$\n其中平均值是在窗口 $i$ 的统计系综上计算的。当在从系综 $i$ 采样的构象上进行评估时，$\\Delta U_{i \\to j} \\equiv U_j - U_i$ 项是一个随机变量。问题陈述指出 $\\Delta U_{i \\to j}$ 服从正态（高斯）分布：\n$$\n\\Delta U_{i \\to j} \\sim \\mathcal{N}(\\mu, \\sigma^2)\n$$\n其均值为 $\\mu = (j-i)a$，方差为 $\\sigma^2 = |j-i|s^2$。\n\n为了计算 $W_{ij}$，我们需要求 $\\exp(-\\beta X)$ 的期望值，其中 $X$ 是一个正态分布的随机变量 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$。这是正态分布的矩生成函数（MGF）的直接应用。随机变量 $X$ 的矩生成函数定义为 $M_X(t) = E[\\exp(tX)]$。对于正态分布变量，其矩生成函数是一个标准结果：\n$$\nM_X(t) = \\exp\\left(\\mu t + \\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n我们可以通过对期望值的定义进行积分来推导它：\n$$\nE[\\exp(tX)] = \\int_{-\\infty}^{\\infty} \\exp(tx) \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right) dx\n$$\n合并后的指数的参数是：\n$$\ntx - \\frac{(x-\\mu)^2}{2\\sigma^2} = -\\frac{1}{2\\sigma^2} [ (x^2 - 2x\\mu + \\mu^2) - 2\\sigma^2tx ] = -\\frac{1}{2\\sigma^2} [ x^2 - 2x(\\mu + t\\sigma^2) + \\mu^2 ]\n$$\n通过对包含 $x$ 的项进行配方：\n$$\nx^2 - 2x(\\mu + t\\sigma^2) = (x - (\\mu+t\\sigma^2))^2 - (\\mu+t\\sigma^2)^2\n$$\n指数的参数变为：\n$$\n-\\frac{1}{2\\sigma^2} [ (x - (\\mu+t\\sigma^2))^2 - (\\mu+t\\sigma^2)^2 + \\mu^2 ] = -\\frac{(x - (\\mu+t\\sigma^2))^2}{2\\sigma^2} + \\frac{(\\mu+t\\sigma^2)^2 - \\mu^2}{2\\sigma^2}\n$$\n第二项简化为：\n$$\n\\frac{\\mu^2 + 2\\mu t\\sigma^2 + t^2\\sigma^4 - \\mu^2}{2\\sigma^2} = \\mu t + \\frac{1}{2}\\sigma^2 t^2\n$$\n因此，矩生成函数的积分可以分为：\n$$\nM_X(t) = \\exp\\left(\\mu t + \\frac{1}{2}\\sigma^2 t^2\\right) \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(x - (\\mu+t\\sigma^2))^2}{2\\sigma^2}\\right) dx\n$$\n该积分是针对一个均值为 $\\mu' = \\mu + t\\sigma^2$、方差为 $\\sigma^2$ 的正态分布的概率密度函数（PDF）进行的。任何 PDF 在其定义域上的积分都为 1。因此，矩生成函数被证明为 $M_X(t) = \\exp(\\mu t + \\frac{1}{2}\\sigma^2 t^2)$。\n\n为了求出 $W_{ij}$，我们令 $X = \\Delta U_{i \\to j}$ 并在 $t = -\\beta$ 处计算其矩生成函数：\n$$\nW_{ij} = E[\\exp(-\\beta \\Delta U_{i \\to j})] = M_{\\Delta U_{i \\to j}}(-\\beta)\n$$\n将 $\\mu = (j-i)a$、$\\sigma^2 = |j-i|s^2$ 和 $t = -\\beta$ 代入矩生成函数公式，我们得到 $W_{ij}$ 的最终表达式：\n$$\nW_{ij} = \\exp\\left( (j-i)a(-\\beta) + \\frac{1}{2}|j-i|s^2(-\\beta)^2 \\right) = \\exp\\left( -(j-i)a\\beta + \\frac{1}{2}|j-i|s^2\\beta^2 \\right)\n$$\n\n### 第二和第三部分：相邻窗口的标记规则\n\n问题定义了一个用于判断相邻窗口 $(i, i+1)$ 之间重叠不足的标记规则。如果 $\\min\\{W_{i,i+1}, W_{i+1,i}\\}  \\tau$，则该段被标记。要应用此规则，我们需要前向重叠 $W_{i,i+1}$ 和后向重叠 $W_{i+1,i}$ 的表达式。\n\n对于前向重叠 $W_{i,i+1}$，我们在推导出的公式中令 $j=i+1$。此时，$j-i=1$ 且 $|j-i|=1$：\n$$\nW_{i,i+1} = \\exp\\left( -a\\beta + \\frac{1}{2}s^2\\beta^2 \\right)\n$$\n对于后向重叠 $W_{i+1,i}$，$i$ 和 $j$ 的角色互换。我们计算的是 $\\langle \\exp(-\\beta(U_i - U_{i+1})) \\rangle_{i+1}$。此时的随机变量是从系综 $i+1$ 中采样的 $\\Delta U_{i+1 \\to i}$。根据模型，其分布为 $\\mathcal{N}((i-(i+1))a, |i-(i+1)|s^2) = \\mathcal{N}(-a, s^2)$。我们使用矩生成函数的结果，其中 $\\mu = -a$，$\\sigma^2 = s^2$，并在 $t=-\\beta$ 处求值：\n$$\nW_{i+1,i} = \\exp\\left( (-a)(-\\beta) + \\frac{1}{2}s^2(-\\beta)^2 \\right) = \\exp\\left( a\\beta + \\frac{1}{2}s^2\\beta^2 \\right)\n$$\n$W_{i,i+1}$ 和 $W_{i+1,i}$ 都与索引 $i$ 无关，这是能量增量沿路径同分布这一假设的结果。\n\n标记条件基于这两个值的最小值。项 $\\exp(\\frac{1}{2}s^2\\beta^2)$ 是一个公共因子。指数部分的区别在于 $a\\beta$ 项的符号。假设 $\\beta > 0$，最小值由 $|a|$ 的负系数项决定：\n$$\n\\min\\{W_{i,i+1}, W_{i+1,i}\\} = \\exp\\left( \\frac{1}{2}s^2\\beta^2 - |a|\\beta \\right)\n$$\n如果这个量小于 $\\tau$，则段 $(i, i+1)$ 被标记。由于此检查与 $i$ 无关，对于任何给定的参数集 $(T, a, s, \\tau)$，要么所有相邻段都被标记，要么都无。\n\n对于案例 C，我们必须确定使单步前向重叠等于阈值 $\\tau$ 的 $a$ 值。假设 $a \\ge 0$，则有 $W_{i,i+1} = \\tau$：\n$$\n\\exp\\left( -a\\beta + \\frac{1}{2}s^2\\beta^2 \\right) = \\tau\n$$\n取自然对数并求解 $a$：\n$$\n-a\\beta + \\frac{1}{2}s^2\\beta^2 = \\ln(\\tau) \\implies a\\beta = \\frac{1}{2}s^2\\beta^2 - \\ln(\\tau) \\implies a = \\frac{1}{2}s^2\\beta - \\frac{\\ln(\\tau)}{\\beta}\n$$\n使用这个 $a$ 值，标记条件是 $\\min\\{W_{i,i+1}, W_{i+1,i}\\}  \\tau$。由于我们有 $a \\ge 0$，最小值是 $W_{i,i+1}$，我们已将其精确设置为 $\\tau$。因此条件变为 $\\tau  \\tau$，这是不成立的。所以，在案例 C 中不会有段被标记。\n\n### 第四和第五部分：实现\n\n上述逻辑在 Python 中实现。对于每个测试案例，我们计算 $\\beta = 1/(k_B T)$，然后评估最小重叠 $\\min\\{W_{i,i+1}, W_{i+1,i}\\}$。如果该值小于 $\\tau$，我们生成一个从 $0$ 到 $L-2$ 的所有可能索引 $i$ 的列表。否则，我们返回一个空列表。对于案例 C，首先按照上面推导的方式计算 $a$ 的值。\n\n所有计算都使用提供的物理常数和参数进行。最终输出是一个列表，其中包含每个测试案例的被标记索引的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FEP overlap problem for a suite of test cases.\n    \"\"\"\n    KB_KJ_PER_MOL_K = 0.00831446261815324\n\n    # Test suite: (L, T, a, s, tau)\n    # For Case C, 'a' is a placeholder string that signals its calculation.\n    test_cases = [\n        (5, 300.0, 0.5, 1.0, 0.03),   # Case A\n        (6, 300.0, 9.0, 1.0, 0.03),   # Case B\n        (4, 300.0, \"calculate\", 1.0, 0.03), # Case C\n        (3, 600.0, 9.0, 1.0, 0.03),   # Case D\n    ]\n\n    results = []\n    for L, T, a_val, s, tau in test_cases:\n        # Calculate inverse temperature beta\n        beta = 1.0 / (KB_KJ_PER_MOL_K * T)\n\n        a = a_val\n        # Special handling for Case C to determine 'a'\n        if a_val == \"calculate\":\n            # We solve for 'a' from the condition W_forward = tau, assuming a >= 0.\n            # exp(-a*beta + 0.5*s^2*beta^2) = tau\n            # -a*beta + 0.5*s^2*beta^2 = log(tau)\n            # a = (0.5*s^2*beta^2 - log(tau)) / beta\n            a = (0.5 * s**2 * beta**2 - np.log(tau)) / beta\n\n        # The flagging rule is based on min(W_i,i+1, W_i+1,i)  tau.\n        # This minimum is given by exp(0.5*s^2*beta^2 - |a|*beta).\n        # Since 'a' is non-negative in all test cases, |a| = a.\n        min_overlap = np.exp(0.5 * s**2 * beta**2 - np.abs(a) * beta)\n\n        flagged_indices = []\n        # The condition min_overlap  tau is independent of the index i.\n        # If it's true, all segments are flagged. Otherwise, none are.\n        if min_overlap  tau:\n            flagged_indices = list(range(L - 1))\n        \n        results.append(flagged_indices)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3453645"}, {"introduction": "作为对前面讨论的采样重叠问题的先进解决方案，多态贝内特接受率 (MBAR) 方法应运而生。这最后一个练习 [@problem_id:3453638] 将指导你实现数值稳定的 MBAR 方程，该方法通过优化组合来自多个中间态的全部数据，来获得统计上最精确的自由能估计。掌握 MBAR 是至关重要的，因为它代表了现代计算科学中自由能计算的黄金标准。", "problem": "给你一个场景，其中三个由 $k \\in \\{0,1,2\\}$ 索引的热力学态在温度 $T$ 下通过正则系综进行采样。对于每个状态 $k$，你有 $N_k$ 个独立的分子构型样本。对于所有状态下的每个构型，所有三个状态的约化势 $u_k(x)$ 都是已知的。约化势定义为 $u_k(x) = \\beta U_k(x)$，其中 $U_k(x)$ 是势能，$\\beta = 1/(k_{\\mathrm{B}} T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。目标是通过迭代求解多态 Bennett 接受率 (MBAR) 自洽方程，来估计无量纲自由能偏移量 $f_k$（满足 $Z_k = \\exp(-f_k)$，其中 $Z_k$ 是状态 $k$ 的配分函数）。根据这些 $f_k$，计算自由能差 $\\Delta F_{0\\to 2} = k_{\\mathrm{B}} T (f_2 - f_0)$，并以千焦耳每摩尔为单位报告其值，同时报告通过对每个状态块内的构型进行非参数 bootstrap 重采样获得的 $95\\%$ 置信区间。\n\n仅从平衡统计力学的核心原理和正则系综混合模型中的最大似然推理出发，实现一个用于求解 MBAR 方程的数值稳定的迭代求解器，不使用任何预先推导的快捷公式。使用稳定的计算策略（例如，log-sum-exp 变换）来避免数值下溢或上溢。当迭代过程中 $f_k$ 的最大绝对变化小于 $10^{-12}$ 时，或在最多 $10^{4}$ 次迭代后（以先到者为准），应宣告收敛。通过报告相对于状态 $k=0$ 的自由能来固定规范（即报告 $f_k - f_0$ 的值，尽管在内部计算中任何一致的规范都是可接受的，因为只有差值有意义）。\n\n置信区间必须通过在每个状态的构型块内进行有放回的 bootstrap 重采样来计算。对于每个 bootstrap 复制样本，从最初与状态 $k$ 关联的行中重采样 $N_k$ 行，按原始顺序拼接重采样的块以形成复制数据集，重新求解 MBAR 以获得复制样本的 $\\Delta F_{0\\to 2}$，并收集这些复制样本自由能差的经验分布。使用 $300$ 个 bootstrap 复制样本和固定的随机种子 $123$ 以确保可复现性。$95\\%$ 置信区间应报告为 bootstrap 分布的经验第 $2.5$ 和第 $97.5$ 百分位数。对每个测试用例，使用 $R = N_A k_{\\mathrm{B}}$（其中 $R = 8.314462618 \\times 10^{-3}$ $\\mathrm{kJ/(mol\\cdot K)}$）和提供的温度 $T$ 将 $\\Delta F_{0\\to 2}$ 表示为 $\\mathrm{kJ/mol}$，并将所有报告的浮点输出四舍五入到六位小数。\n\n构建并求解以下包含三个案例的测试套件。在每个案例中，矩阵 $U$ 的形状为 $N_{\\mathrm{tot}} \\times 3$，其行按状态块排序：前 $N_0$ 行是源自状态 $0$ 的样本，接下来的 $N_1$ 行源自状态 $1$，最后的 $N_2$ 行源自状态 $2$。每一行包含该构型在所有三个状态下的约化势 $[u_0(x), u_1(x), u_2(x)]$。\n\n- 案例 A（平衡采样，中等分离）：\n  - 温度：$T = 300.0$ $\\mathrm{K}$。\n  - 样本数量：$(N_0, N_1, N_2) = (12,12,12)$。\n  - 约化能量矩阵 $U \\in \\mathbb{R}^{36 \\times 3}$ 由以下确定性序列分块定义：\n    - 对于状态 $0$ 块 ($j = 0,1,\\dots,11$): $[u_0, u_1, u_2] = [0.20 + 0.05 j,\\; 1.10 + 0.04 j,\\; 2.00 + 0.03 j]$。\n    - 对于状态 $1$ 块 ($j = 0,1,\\dots,11$): $[u_0, u_1, u_2] = [0.30 + 0.03 j,\\; 0.90 + 0.05 j,\\; 1.80 + 0.06 j]$。\n    - 对于状态 $2$ 块 ($j = 0,1,\\dots,11$): $[u_0, u_1, u_2] = [0.40 + 0.06 j,\\; 0.80 + 0.04 j,\\; 1.60 + 0.05 j]$。\n\n- 案例 B（高度不平衡采样）：\n  - 温度：$T = 310.0$ $\\mathrm{K}$。\n  - 样本数量：$(N_0, N_1, N_2) = (5,20,5)$。\n  - 约化能量矩阵 $U \\in \\mathbb{R}^{30 \\times 3}$ 由以下确定性序列分块定义：\n    - 对于状态 $0$ 块 ($j = 0,1,\\dots,4$): $[u_0, u_1, u_2] = [0.50 + 0.02 j,\\; 0.70 + 0.03 j,\\; 1.20 + 0.04 j]$。\n    - 对于状态 $1$ 块 ($j = 0,1,\\dots,19$): $[u_0, u_1, u_2] = [0.60 + 0.04 j,\\; 0.65 + 0.02 j,\\; 1.00 + 0.03 j]$。\n    - 对于状态 $2$ 块 ($j = 0,1,\\dots,4$): $[u_0, u_1, u_2] = [0.55 + 0.03 j,\\; 0.75 + 0.02 j,\\; 1.15 + 0.03 j]$。\n\n- 案例 C（跨状态的简并相同能量）：\n  - 温度：$T = 298.0$ $\\mathrm{K}$。\n  - 样本数量：$(N_0, N_1, N_2) = (10,10,10)$。\n  - 约化能量矩阵 $U \\in \\mathbb{R}^{30 \\times 3}$ 的每一行都等于 $[1.50, 1.50, 1.50]$。\n\n你的程序必须：\n- 使用数值稳定的 log-sum-exp 程序实现一个迭代式 MBAR 求解器。\n- 按照规定，通过 bootstrap 重采样计算每个案例的 $\\Delta F_{0\\to 2}$（单位 $\\mathrm{kJ/mol}$）及其 $95\\%$ 置信区间。\n- 生成单行输出，包含一个由列表组成的逗号分隔列表的结果，每个内部列表为三个案例的 $[\\Delta F_{0\\to 2}, \\mathrm{CI}_{\\mathrm{low}}, \\mathrm{CI}_{\\mathrm{high}}]$，所有值四舍五入到六位小数。例如，输出格式必须严格为：“[[x1,y1,z1],[x2,y2,z2],[x3,y3,z3]]”（用数值代替符号）。\n\n所有答案必须以 $\\mathrm{kJ/mol}$ 为单位表示，并四舍五入到六位小数。不涉及角度。不得使用百分比；分位数应通过数值以小数形式给出。你的实现必须完全自包含，无需用户输入或外部文件即可运行。", "solution": "该问题要求实现多态 Bennett 接受率 (MBAR) 方法，以根据模拟数据计算自由能差，其中包含使用 bootstrap 程序对统计不确定性进行稳健估计。该实现必须从统计力学和最大似然理论的基本原理推导得出，并且必须是数值稳定的。\n\n**1. MBAR 的理论基础**\n\n问题的核心在于为一组 $K$ 个热力学态估计无量纲自由能 $f_k = -\\ln Z_k$，其中 $Z_k$ 是状态 $k$ 的正则配分函数。在状态 $k$ 中观察到微观构型 $x$ 的概率密度由玻尔兹曼分布给出：\n$$ p_k(x) = \\frac{\\exp(-u_k(x))}{Z_k} = \\exp(f_k - u_k(x)) $$\n其中 $u_k(x) = \\beta U_k(x)$ 是在逆温度 $\\beta = 1/(k_B T)$ 下的约化势能。\n\n输入数据包含 $N_{\\mathrm{tot}} = \\sum_{k=0}^{K-1} N_k$ 个构型 $\\{x_n\\}_{n=1}^{N_{\\mathrm{tot}}}$。对于每个构型 $x_n$，我们知道其采样来源的状态 $s_n \\in \\{0, \\ldots, K-1\\}$，并且我们获得了对所有状态 $j=0, \\ldots, K-1$ 的约化势矩阵 $u_j(x_n)$。\n\nMBAR 方法通过组合所有数据，提供了对自由能的最优估计。它是通过将观察到完整数据集的似然对数作为未知自由能 $\\{f_k\\}$ 的函数并将其最大化而推导出来的。将样本视为从正则系综的混合中抽取，其对数似然函数由下式给出：\n$$ \\ln \\mathcal{L}(\\mathbf{f}) = \\sum_{n=1}^{N_{\\mathrm{tot}}} \\ln \\left( \\frac{\\exp(f_{s_n} - u_{s_n}(x_n))}{\\sum_{j=0}^{K-1} N_j \\exp(f_j)} \\right) $$\n对这组自由能 $\\mathbf{f} = \\{f_0, \\dots, f_{K-1}\\}$ 最大化此对数似然函数，会产生一组耦合的自洽方程。经过一些代数操作，这些方程可以写成便于迭代求解的形式：\n$$ \\exp(-f_k) = \\sum_{n=1}^{N_{\\mathrm{tot}}} \\frac{\\exp(-u_k(x_n))}{\\sum_{j=0}^{K-1} N_j \\exp(f_j - u_j(x_n))} \\quad \\text{for } k=0, \\ldots, K-1 $$\n这是 MBAR 的核心方程组。\n\n**2. 算法实现**\n\nMBAR 方程的形式为 $\\mathbf{f} = G(\\mathbf{f})$，可以使用不动点迭代方案 $\\mathbf{f}^{(m+1)} = G(\\mathbf{f}^{(m)})$ 来求解，从一个初始猜测（例如 $\\mathbf{f}^{(0)} = \\mathbf{0}$）开始。\n\n**数值稳定性：**\n由于势能的典型取值范围很大，直接计算 MBAR 方程中的指数在数值上是有风险的，可能导致浮点数上溢或下溢。为确保稳定性，我们使用对数和 log-sum-exp (LSE) 函数重新构建计算，LSE 函数定义为 $\\mathrm{LSE}(\\mathbf{v}) = \\ln(\\sum_i e^{v_i})$。该函数可以通过以下方式稳健地计算：\n$$ \\mathrm{LSE}(\\mathbf{v}) = v_{\\max} + \\ln\\left(\\sum_i e^{v_i - v_{\\max}}\\right) $$\n其中 $v_{\\max} = \\max_i v_i$。\n\n我们可以将 $f_k$ 的迭代更新重写为数值稳定的形式。首先，我们为每个样本 $n$ 定义一个对数空间中的分母项：\n$$ \\log S_n = \\ln\\left(\\sum_{j=0}^{K-1} N_j \\exp(f_j - u_j(x_n))\\right) = \\mathrm{LSE}_j(\\ln N_j + f_j - u_j(x_n)) $$\n$\\mathrm{LSE}_j$ 的下标表示该操作是针对状态索引 $j$ 进行的。有了它，$\\exp(-f_k)$ 的方程变为：\n$$ \\exp(-f_k) = \\sum_{n=1}^{N_{\\mathrm{tot}}} \\exp(-u_k(x_n) - \\log S_n) $$\n对两边取负对数，得到 $f_k$ 的更新规则：\n$$ f_k^{(m+1)} = -\\ln\\left(\\sum_{n=1}^{N_{\\mathrm{tot}}} \\exp(-u_k(x_n) - \\log S_n^{(m)})\\right) = -\\mathrm{LSE}_n(-u_k(x_n) - \\log S_n^{(m)}) $$\n其中 $\\log S_n^{(m)}$ 是使用上一次迭代的自由能 $\\mathbf{f}^{(m)}$ 计算得出的。\n\n**规范固定：**\nMBAR 方程仅能确定自由能，但会相差一个任意的加法常数。这是因为将一个常数 $C$ 加到所有 $f_k$ 值上并不会改变方程。为了获得唯一解，我们必须固定这个“规范”。一个常见的选择是将某个状态（例如状态 $0$）的自由能设为零。在迭代求解器中，这在每个更新步骤之后通过平移所有自由能来强制执行：$f_k \\leftarrow f_k - f_0$。\n\n**收敛性：**\n迭代持续进行直到解收敛。当连续两次迭代之间任何自由能估计值的最大绝对变化小于指定的容差 $\\tau = 10^{-12}$ 时，宣告收敛：\n$$ \\max_k |f_k^{(m+1)} - f_k^{(m)}|  \\tau $$\n同时设置了最大迭代次数 $10^4$，以防止在不收敛的情况下出现无限循环。\n\n**3. 通过 Bootstrap 进行不确定性量化**\n\n为了估计计算出的自由能差 $\\Delta F_{0\\to 2}$ 的统计不确定性，我们使用非参数 bootstrap 方法。\n\n**步骤：**\n1.  **重采样**：对于指定数量的复制样本（本问题中为 $300$ 个），我们生成一个新的“bootstrap”数据集。该数据集通过对原始构型进行*有放回*采样来构建。重采样是按状态分层的：对于每个状态 $k$，我们从属于该状态的原始 $N_k$ 个构型块中随机抽取 $N_k$ 个构型。\n2.  **重新求解**：对于 $300$ 个 bootstrap 数据集中的每一个，我们求解 MBAR 方程以获得一组复制样本的自由能 $\\{f_{k, \\text{boot}}\\}$。\n3.  **分布**：从每个复制样本中，我们计算目标量 $\\Delta F_{0\\to 2, \\text{boot}} = R T (f_{2, \\text{boot}} - f_{0, \\text{boot}})$，其中 $R = 8.314462618 \\times 10^{-3} \\; \\mathrm{kJ/(mol \\cdot K)}$。这个过程产生了 $\\Delta F_{0\\to 2}$ 的经验概率分布。\n4.  **置信区间**：通过找到排序后的 $\\Delta F_{0\\to 2}$ 值的 bootstrap 分布的第 $2.5$ 和第 $97.5$ 百分位数来构建 $95\\%$ 置信区间。为了确保可复现性，重采样过程使用固定的随机种子（$123$）。\n\n这种综合方法不仅为自由能差提供了一个点估计，而且还提供了一个对其统计精度的稳健度量，该度量基于基础采样数据的变异性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import logsumexp\n\ndef solve():\n    \"\"\"\n    Main function to solve the MBAR problem for the three specified test cases.\n    \"\"\"\n    R_KJ_MOL_K = 8.314462618e-3\n    N_BOOTSTRAP = 300\n    RANDOM_SEED = 123\n\n    def generate_test_cases():\n        \"\"\"Generates the data for the three test cases as specified in the problem.\"\"\"\n        # Case A\n        T_A = 300.0\n        N_A = np.array([12, 12, 12])\n        u_A_blocks = []\n        j_vals_A = np.arange(12)\n        u_A_blocks.append(np.array([[0.20 + 0.05*j, 1.10 + 0.04*j, 2.00 + 0.03*j] for j in j_vals_A]))\n        u_A_blocks.append(np.array([[0.30 + 0.03*j, 0.90 + 0.05*j, 1.80 + 0.06*j] for j in j_vals_A]))\n        u_A_blocks.append(np.array([[0.40 + 0.06*j, 0.80 + 0.04*j, 1.60 + 0.05*j] for j in j_vals_A]))\n        U_A = np.vstack(u_A_blocks)\n\n        # Case B\n        T_B = 310.0\n        N_B = np.array([5, 20, 5])\n        u_B_blocks = []\n        u_B_blocks.append(np.array([[0.50 + 0.02*j, 0.70 + 0.03*j, 1.20 + 0.04*j] for j in np.arange(5)]))\n        u_B_blocks.append(np.array([[0.60 + 0.04*j, 0.65 + 0.02*j, 1.00 + 0.03*j] for j in np.arange(20)]))\n        u_B_blocks.append(np.array([[0.55 + 0.03*j, 0.75 + 0.02*j, 1.15 + 0.03*j] for j in np.arange(5)]))\n        U_B = np.vstack(u_B_blocks)\n\n        # Case C\n        T_C = 298.0\n        N_C = np.array([10, 10, 10])\n        U_C = np.full((sum(N_C), 3), 1.50)\n        \n        return [\n            (U_A, N_A, T_A),\n            (U_B, N_B, T_B),\n            (U_C, N_C, T_C)\n        ]\n\n    def compute_f_k(u_nk, N_k, tol=1e-12, max_iter=10000):\n        \"\"\"\n        Solves the MBAR equations iteratively to find the dimensionless free energies.\n        \n        Args:\n            u_nk (np.ndarray): The reduced potential energy matrix of shape (N_tot, K).\n            N_k (np.ndarray): An array of sample counts for each state.\n            tol (float): Convergence tolerance.\n            max_iter (int): Maximum number of iterations.\n\n        Returns:\n            np.ndarray: The converged dimensionless free energies, with f_0 fixed to 0.\n        \"\"\"\n        K = len(N_k)\n        log_N_k = np.log(N_k)\n        f_k = np.zeros(K)\n\n        for _ in range(max_iter):\n            f_old = np.copy(f_k)\n            \n            # log_S_n[n] = log(sum_j N_j exp(f_j - u_jn)) via LSE\n            # The argument to logsumexp for each sample n is an array over states j:\n            # [log(N_0)+f_0-u_0n, log(N_1)+f_1-u_1n, ...]\n            log_S_n_arg = log_N_k + f_k - u_nk\n            log_S_n = logsumexp(log_S_n_arg, axis=1)\n\n            # Update f_k using LSE over samples n\n            # f_k_new[k] = -log(sum_n exp(-u_kn - log_S_n))\n            for k in range(K):\n                arg = -u_nk[:, k] - log_S_n\n                f_k[k] = -logsumexp(arg)\n            \n            # Apply gauge f_0 = 0 for stability\n            f_k -= f_k[0]\n\n            if np.max(np.abs(f_k - f_old))  tol:\n                break\n        \n        return f_k\n\n    test_cases = generate_test_cases()\n    all_results = []\n    \n    for u_nk, N_k, T in test_cases:\n        # 1. Calculate the point estimate\n        f_k_point = compute_f_k(u_nk, N_k)\n        delta_F_point = (f_k_point[2] - f_k_point[0]) * R_KJ_MOL_K * T\n\n        # 2. Perform bootstrap analysis for confidence interval\n        rng = np.random.default_rng(RANDOM_SEED)\n        delta_F_boots = np.zeros(N_BOOTSTRAP)\n        \n        # Prepare indices for stratified resampling\n        N_tot = sum(N_k)\n        state_indices_blocks = []\n        start_idx = 0\n        for count in N_k:\n            state_indices_blocks.append(np.arange(start_idx, start_idx + count))\n            start_idx += count\n\n        for i in range(N_BOOTSTRAP):\n            # Create bootstrap sample indices\n            bootstrap_indices = []\n            for k in range(len(N_k)):\n                indices_for_state_k = rng.choice(\n                    state_indices_blocks[k], size=N_k[k], replace=True\n                )\n                bootstrap_indices.append(indices_for_state_k)\n            \n            final_boot_indices = np.concatenate(bootstrap_indices)\n            u_nk_boot = u_nk[final_boot_indices, :]\n            \n            # Solve MBAR for the bootstrap sample\n            f_k_boot = compute_f_k(u_nk_boot, N_k)\n            delta_F_boots[i] = (f_k_boot[2] - f_k_boot[0]) * R_KJ_MOL_K * T\n\n        # 3. Calculate 95% CI from bootstrap distribution\n        ci_low = np.percentile(delta_F_boots, 2.5)\n        ci_high = np.percentile(delta_F_boots, 97.5)\n\n        # 4. Store results rounded to 6 decimal places\n        all_results.append([\n            round(delta_F_point, 6),\n            round(ci_low, 6),\n            round(ci_high, 6)\n        ])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "3453638"}]}