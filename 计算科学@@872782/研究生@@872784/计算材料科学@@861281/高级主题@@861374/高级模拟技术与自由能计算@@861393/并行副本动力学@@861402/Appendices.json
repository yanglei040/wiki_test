{"hands_on_practices": [{"introduction": "并行副本动力学（ParRep）的效率取决于使用多个副本带来的加速效果与固有开销成本之间的平衡。第一个练习将指导您为 ParRep 的性能建立一个基础分析模型。通过推导预期的加速比，您将定量地理解散相时间和同步开销等因素如何影响最佳副本数量，这是设计高效模拟时的关键考量。[@problem_id:3473181]", "problem": "考虑一个原子模型中的亚稳态，其中在单副本串行模拟中，从该状态的逃逸时间被建模为一个速率参数为 $\\lambda  0$ 的指数随机变量。并行副本动力学 (ParRep) 通过在一个散相阶段后运行 $N \\in \\mathbb{N}$ 个独立副本，来加速逃逸事件的采样。在 ParRep 中，工作流程如下：一个持续时间为 $\\tau_{d}  0$ 的散相阶段，在亚稳态内部产生 $N$ 个去相关且准稳态的初始条件；然后一个并行阶段运行 $N$ 个独立副本，直到检测到第一个逃逸事件；最后，算法执行一个同步和选择阶段，其开销随 $N$ 线性扩展，系数为 $\\tau_{s}  0$，代表每个副本的通信和协调成本。\n\n假设如下：\n- 串行逃逸时间是速率为 $\\lambda$ 的指数分布，均值为 $1/\\lambda$。\n- $N$ 个并行副本具有独立同分布的指数逃逸时间，速率同为 $\\lambda$，并且检测/选择阶段在第一个副本逃逸时停止所有副本。\n- 对于一个统计上正确的逃逸事件，总的期望 ParRep 墙钟时间是散相时间、 $N$ 个副本中直到第一次逃逸的期望时间、以及随 $N$ 线性扩展且系数为 $\\tau_{s}$ 的同步开销之和。\n\n仅使用指数等待时间过程和独立性的第一性原理，推导期望加速比 $\\mathbb{E}[S(N)]$ 的闭式表达式，该加速比定义为期望串行时间与单个逃逸事件的期望 ParRep 墙钟时间之比。然后，在给定的线性同步开销模型下，确定使 $\\mathbb{E}[S(N)]$ 最大化的值 $N^{\\star}$（为优化的目的，将其视为正实数）。将您的最终答案表示为闭式解析表达式。不需要数值。加速比是无量纲的，答案中不应使用单位。", "solution": "在进行求解之前，对问题陈述进行严格验证。\n\n### 步骤 1：提取已知条件\n- 串行逃逸时间 $T_{serial}$ 是一个速率参数为 $\\lambda  0$ 的指数随机变量。\n- 副本数量为 $N \\in \\mathbb{N}$。\n- 副本是独立的。\n- 散相阶段的持续时间为 $\\tau_{d}  0$。\n- 并行阶段运行 $N$ 个独立副本，直到第一次逃逸。\n- 每个副本的同步开销为 $\\tau_{s}  0$，总开销为 $N\\tau_s$。\n- $N$ 个副本中每个副本的逃逸时间 $T_i$（其中 $i=1, 2, ..., N$）是一个速率为 $\\lambda$ 的指数随机变量。它们是独立同分布 (i.i.d.) 的。\n- 一次逃逸事件的总期望 ParRep 墙钟时间为 $\\mathbb{E}[T_{ParRep}(N)] = \\tau_{d} + \\mathbb{E}[\\text{首次逃逸时间}] + N\\tau_{s}$。\n- 期望加速比定义为 $\\mathbb{E}[S(N)] = \\frac{\\mathbb{E}[T_{serial}]}{\\mathbb{E}[T_{ParRep}(N)]}$。\n- 任务是推导 $\\mathbb{E}[S(N)]$ 的闭式表达式，并找到使其最大化的值 $N^{\\star}$（作为一个正实数）。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据（关键）：** 该问题基于计算科学中用于研究稀有事件的成熟方法——并行副本动力学 (ParRep)。将逃逸时间建模为指数随机变量是源于过渡态理论和泊松过程性质的标准基本假设。线性开销模型是对并行算法中通信成本的基本且有效的表示。该问题在科学上是合理的。\n- **良定性：** 问题定义清晰，包含了所有必要的参数（$\\lambda, \\tau_d, \\tau_s$）和变量（$N$）。目标函数（加速比及其最大化）已明确说明。数学框架为获得唯一且有意义的解提供了一条清晰的路径。\n- **客观性（关键）：** 问题以精确、正式且无偏见的语言陈述。不存在主观或基于观点的论断。\n\n### 步骤 3：结论与行动\n该问题具有科学依据、良定、客观且内部一致。判定其为**有效**。将推导解答。\n\n### 解答的推导\n\n解答的推导分为两部分：首先，期望加速比 $\\mathbb{E}[S(N)]$ 的表达式；其次，使该加速比最大化的最优副本数 $N^{\\star}$。\n\n**第一部分：期望加速比 $\\mathbb{E}[S(N)]$**\n\n期望加速比是单副本模拟观察到一次逃逸事件的期望时间与 ParRep 算法观察到一次统计上正确的逃逸事件的期望墙钟时间之比。\n\n1.  **期望串行时间：** 串行逃逸时间 $T_{serial}$ 被说明为一个速率为 $\\lambda$ 的指数随机变量。这类变量的期望值是其速率的倒数。\n    $$\n    \\mathbb{E}[T_{serial}] = \\frac{1}{\\lambda}\n    $$\n\n2.  **期望 ParRep 墙钟时间：** 总的期望 ParRep 时间 $\\mathbb{E}[T_{ParRep}(N)]$ 是三个部分之和：\n    - 散相时间，给定为常数 $\\tau_d$。\n    - 并行阶段中直到第一次逃逸事件的期望时间。设 $T_1, T_2, \\ldots, T_N$ 为 $N$ 个副本的独立同分布逃逸时间，每个都服从速率为 $\\lambda$ 的指数分布。并行阶段的时间为 $T_{parallel} = \\min(T_1, T_2, \\ldots, T_N)$。$N$ 个速率为 $\\lambda$ 的独立同分布指数随机变量的最小值本身是一个指数随机变量，其速率等于各个速率之和，即 $N\\lambda$。\n    单个副本 $T_i$ 在时间 $t$ 之前没有逃逸的概率是 $P(T_i  t) = \\exp(-\\lambda t)$。由于副本是独立的，所有副本在时间 $t$ 之前都没有逃逸的概率是：\n    $$\n    P(T_{parallel}  t) = P(T_1  t, \\ldots, T_N  t) = \\prod_{i=1}^{N} P(T_i  t) = (\\exp(-\\lambda t))^N = \\exp(-N\\lambda t)\n    $$\n    这是速率为 $N\\lambda$ 的指数分布的生存函数。该分布的期望值为：\n    $$\n    \\mathbb{E}[T_{parallel}] = \\frac{1}{N\\lambda}\n    $$\n    - 同步开销，给定为 $N$ 的线性函数：$N\\tau_s$。\n\n    将这三部分结合起来，得到总的期望 ParRep 墙钟时间：\n    $$\n    \\mathbb{E}[T_{ParRep}(N)] = \\tau_d + \\mathbb{E}[T_{parallel}] + N\\tau_s = \\tau_d + \\frac{1}{N\\lambda} + N\\tau_s\n    $$\n\n3.  **期望加速比表达式：** 期望加速比 $\\mathbb{E}[S(N)]$ 是期望串行时间与期望 ParRep 时间之比。\n    $$\n    \\mathbb{E}[S(N)] = \\frac{\\mathbb{E}[T_{serial}]}{\\mathbb{E}[T_{ParRep}(N)]} = \\frac{1/\\lambda}{\\tau_d + \\frac{1}{N\\lambda} + N\\tau_s}\n    $$\n    为了简化此表达式，我们可以将分子和分母同乘以 $N\\lambda$：\n    $$\n    \\mathbb{E}[S(N)] = \\frac{N\\lambda(1/\\lambda)}{N\\lambda(\\tau_d + \\frac{1}{N\\lambda} + N\\tau_s)} = \\frac{N}{N\\lambda\\tau_d + 1 + N^2\\lambda\\tau_s}\n    $$\n    这可以重新排列为分母是标准多项式形式：\n    $$\n    \\mathbb{E}[S(N)] = \\frac{N}{N^2\\lambda\\tau_s + N\\lambda\\tau_d + 1}\n    $$\n    这是第一个要求的结果。\n\n**第二部分：最优副本数 $N^{\\star}$**\n\n为了找到使加速比 $\\mathbb{E}[S(N)]$ 最大化的副本数 $N^{\\star}$，我们将 $N$ 视为一个连续的正实数变量，并求函数 $\\mathbb{E}[S(N)]$ 的最大值。最大化 $\\mathbb{E}[S(N)]$ 等价于最小化其倒数乘以一个常数，这简化为最小化原始分数的分母 $\\mathbb{E}[T_{ParRep}(N)]$。我们将这个待最小化的函数定义为 $f(N)$：\n$$\nf(N) = \\mathbb{E}[T_{ParRep}(N)] = \\tau_d + \\frac{1}{N\\lambda} + N\\tau_s\n$$\n我们通过求 $f(N)$ 关于 $N$ 的一阶导数并将其设为零来找到临界点。\n$$\n\\frac{df}{dN} = \\frac{d}{dN} \\left( \\tau_d + \\frac{1}{N\\lambda} + N\\tau_s \\right) = 0 - \\frac{1}{N^2\\lambda} + \\tau_s\n$$\n将导数设为零：\n$$\n\\tau_s - \\frac{1}{N^2\\lambda} = 0 \\implies \\tau_s = \\frac{1}{N^2\\lambda}\n$$\n求解 $N^2$：\n$$\nN^2 = \\frac{1}{\\lambda\\tau_s}\n$$\n由于 $N$ 必须为正，我们取正平方根：\n$$\nN^{\\star} = \\sqrt{\\frac{1}{\\lambda\\tau_s}} = \\frac{1}{\\sqrt{\\lambda\\tau_s}}\n$$\n为了确认该值对应于加速比的最大值（即时间 $f(N)$ 的最小值），我们检查 $f(N)$ 的二阶导数：\n$$\n\\frac{d^2f}{dN^2} = \\frac{d}{dN} \\left( -\\frac{1}{N^2\\lambda} + \\tau_s \\right) = - \\left( \\frac{-2}{N^3\\lambda} \\right) = \\frac{2}{N^3\\lambda}\n$$\n由于 $\\lambda  0$，$\\tau_s  0$，最优的 $N^{\\star}$ 是正的。因此，对于任何 $N  0$，我们有 $\\frac{d^2f}{dN^2}  0$。这个正的二阶导数表明 $f(N)$ 对于 $N0$ 是一个凸函数，并且 $N^{\\star}$ 对应于 $f(N)$ 的一个局部和全局最小值。因此，$N^{\\star}$ 产生加速比 $\\mathbb{E}[S(N)]$ 的最大值。这是第二个要求的结果。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{N}{N^2\\lambda\\tau_s + N\\lambda\\tau_d + 1}  \\frac{1}{\\sqrt{\\lambda\\tau_s}} \\end{pmatrix}}\n$$", "id": "3473181"}, {"introduction": "虽然我们的第一个模型假设了理想条件，但现实世界的高性能计算环境通常是异构的，处理器速度各不相同。本练习将探讨如何使 ParRep 适应该类场景，比较简单的同步方案与更高级的异步方法。通过推导出一个最优的静态调度策略，您将掌握在保持模拟统计完整性的同时，最大化计算吞吐量所需的设计原则。[@problem_id:3473158]", "problem": "给定一个简化的、基于第一性原理的并行副本动力学（Parallel Replica Dynamics, ParRep）模型，用于处理亚稳态逃逸问题。假设以下基本前提：如果单个副本在一个亚稳态势阱的准静态分布中初始化，那么其物理逃逸时间服从速率参数为 $\\lambda$（单位为逆时间单位）的指数分布，即逃逸时间 $\\tau$ 满足 $\\tau \\sim \\mathrm{Exp}(\\lambda)$ 且 $\\mathbb{E}[\\tau] = 1/\\lambda$。现有 $N$ 个独立的副本，每个副本单位物理时间的确定性、异构计算成本为 $c_i  0$（单位为秒/单位物理时间）。只要副本 $i$ 在执行，它就以每秒挂钟时间 $1/c_i$ 个物理时间单位的速率推进物理时间。\n\n定义两种方案，并推导通过累加所有副本在首次逃逸前所演进的物理时间，从而获得单个轨迹逃逸时间的一个无偏样本（即，一个在物理时间上与 $\\mathrm{Exp}(\\lambda)$ 具有相同分布的样本）所需的预期挂钟时间：\n\n- 带同步屏障的同步方案：所有副本同步推进。每个副本的挂钟时间速度受限于最慢的副本，因此总物理时间推进速率为 $N / c_{\\max}$，其中 $c_{\\max} = \\max_i c_i$。设 $T_{\\mathrm{sync}}$ 为同步方案提供一个无偏物理逃逸时间样本所需的预期挂钟时间。\n\n- 异步非阻塞方案：所有副本以各自的速度独立推进，没有同步屏障。总物理时间推进速率为 $\\sum_{i=1}^N (1/c_i)$。设 $T_{\\mathrm{async}}$ 为异步方案提供一个无偏物理逃逸时间样本所需的预期挂钟时间。\n\n对于这两种方案，无偏性要求指的是在物理时间上保持逃逸时间定律，即报告的物理逃逸时间分布为 $\\mathrm{Exp}(\\lambda)$，这是通过将加速物理时间定义为在首次观测到逃逸之前所有运行副本所演进的物理时间之和来实现的。\n\n接下来，考虑一个广义调度问题，其中在任何时刻最多可以同时运行 $K$ 个副本，其中 $1 \\leq K \\leq N$。在任何给定时间，您可以选择一个大小为 $|S| = K$ 的子集 $S \\subset \\{0,1,\\dots,N-1\\}$ 来执行，每个选定的副本 $i \\in S$ 以 $1/c_i$ 的速率贡献物理时间进度。调度可以是静态的（始终使用固定的子集）或动态的（随时间变化的子集），但停止时间是任何运行中的副本首次观测到逃逸的时刻。无偏性要求保持不变，即报告的物理逃逸时间在物理单位上呈速率为 $\\lambda$ 的指数分布，这是通过累加所有运行副本在首次逃逸前所演进的物理时间来实现的。\n\n- 在任何时候最多运行 $K$ 个副本并保持上述意义上的无偏逃逸时间统计特性的约束下，为最小化 $\\mathbb{E}[T_{\\mathrm{wall}}]$ 的最优调度策略建立预期挂钟时间 $T_{\\mathrm{opt}}$ 的公式。\n\n- 当调度器仅限于静态子集时，用纯数学术语给出一个选择最优静态子集 $S^\\star$ 的规则，并计算此 $S^\\star$ 的 $T_{\\mathrm{opt}}$。论证为什么在所有静态调度中，您提出的规则能最小化预期挂钟时间。\n\n您的程序必须为一组测试用例实现所推导的公式和策略。所有物理单位必须按规定使用：成本 $c_i$ 的单位是秒/单位物理时间，$\\lambda$ 的单位是逆物理时间。所有预期挂钟时间以秒为单位表示，并四舍五入到六位小数。\n\n测试套件规范。对于每个测试用例，给定 $(\\lambda, \\{c_i\\}_{i=0}^{N-1}, K)$。您必须计算四个输出：\n\n- $T_{\\mathrm{sync}}$，单位为秒，\n- $T_{\\mathrm{async}}$，单位为秒（这对应于 $K=N$ 且所有副本无屏障运行的情况），\n- 针对给定 $K$ 的最优静态调度的 $T_{\\mathrm{opt}}$，单位为秒，\n- 所选最优静态子集 $S^\\star$ 的索引列表，为升序排列的从0开始的索引。\n\n使用以下测试用例：\n\n- 案例 1：$\\lambda = $ $0.2$，$\\{c_i\\} = [$ $1.0$, $1.5$, $0.8$, $2.0$ $]$，$K = $ $2$。\n- 案例 2：$\\lambda = $ $1.0$，$\\{c_i\\} = [$ $1.0$, $1.0$, $1.0$ $]$，$K = $ $3$。\n- 案例 3：$\\lambda = $ $0.05$，$\\{c_i\\} = [$ $10.0$, $10.0$, $0.1$, $0.1$, $0.1$ $]$，$K = $ $3$。\n- 案例 4：$\\lambda = $ $2.0$，$\\{c_i\\} = [$ $3.0$ $]$，$K = $ $1$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个测试用例贡献一个形如 $[T_{\\mathrm{sync}}, T_{\\mathrm{async}}, T_{\\mathrm{opt}}, S^\\star]$ 的列表。例如，整体输出应类似于 $[[\\cdot,\\cdot,\\cdot,[\\cdot]], [\\cdot,\\cdot,\\cdot,[\\cdot]], \\dots]$，所有时间以秒为单位，四舍五入到六位小数。", "solution": "该问题陈述已经过验证，被认为是科学上合理、适定且客观的。它提出了一个简化但标准的并行副本动力学（ParRep）模型，我们可以据此推导出所要求的性能指标。\n\nParRep 的核心原理依赖于指数分布的性质。如果单个过程的逃逸时间 $\\tau$ 服从 $\\mathrm{Exp}(\\lambda)$ 分布，其期望时间为 $\\mathbb{E}[\\tau] = 1/\\lambda$。如果我们运行该过程的 $M$ 个独立副本，它们中首次逃逸的时间 $\\tau_{\\text{first}}$ 将服从速率大 $M$ 倍的指数分布，即 $\\tau_{\\text{first}} \\sim \\mathrm{Exp}(M\\lambda)$，其期望值为 $\\mathbb{E}[\\tau_{\\text{first}}] = 1/(M\\lambda)$。\n\nParRep 方法通过将总加速物理时间 $\\mathcal{T}_{\\text{phys}}$ 定义为所有副本在首次逃逸事件发生前模拟的物理时间之和，来生成原始单轨迹逃逸时间分布的一个无偏样本。对于 $M$ 个副本运行了物理时间 $\\tau_{\\text{first}}$，这个总时间是 $\\mathcal{T}_{\\text{phys}} = M \\tau_{\\text{first}}$。$\\mathcal{T}_{\\text{phys}}$ 的分布是 $\\mathrm{Exp}((M\\lambda)/M) = \\mathrm{Exp}(\\lambda)$，这与原始分布相同。因此，为获得一个这样的样本需要模拟的期望总物理时间是 $\\mathbb{E}[\\mathcal{T}_{\\text{phys}}] = 1/\\lambda$。\n\n物理时间与挂钟时间之间的联系由每个副本 $i$ 的计算成本 $c_i$ 决定。成本 $c_i$ 的单位是秒/单位物理时间。因此，副本 $i$ 推进物理时间的速率是 $r_i = 1/c_i$，单位是物理时间单位/秒挂钟时间。\n\n设 $S$ 为某一时刻正在运行的副本的索引集合。总物理时间演进速率 $R_S$ 是运行中副本各自速率的总和：\n$$\nR_S = \\sum_{i \\in S} r_i = \\sum_{i \\in S} \\frac{1}{c_i}\n$$\n这个速率 $R_S$ 的单位是物理时间/秒。如果该速率恒定，模拟总物理时间 $\\mathcal{T}_{\\text{phys}}$ 所需的挂钟时间 $T_{\\text{wall}}$ 就是 $T_{\\text{wall}} = \\mathcal{T}_{\\text{phys}} / R_S$。\n\n我们寻求期望挂钟时间 $\\mathbb{E}[T_{\\text{wall}}]$。由于 $\\mathbb{E}[\\mathcal{T}_{\\text{phys}}] = 1/\\lambda$，并且对于固定的运行副本集合，挂钟时间与物理时间之间的关系是线性的，我们可以写出：\n$$\n\\mathbb{E}[T_{\\text{wall}}(S)] = \\frac{\\mathbb{E}[\\mathcal{T}_{\\text{phys}}]}{R_S} = \\frac{1/\\lambda}{\\sum_{i \\in S} \\frac{1}{c_i}} = \\frac{1}{\\lambda \\sum_{i \\in S} \\frac{1}{c_i}}\n$$\n这是对于一个静态运行副本集合 $S$ 的期望挂钟时间的通用公式。我们现在将其应用于具体的方案。\n\n**1. 同步方案 ($T_{\\mathrm{sync}}$)**\n在此方案中，所有 $N$ 个副本都运行，但它们被一个屏障同步，导致所有副本都以最慢副本的步调进行。最慢的副本是计算成本最高的那个，即 $c_{\\max} = \\max_i c_i$。其速率为 $1/c_{\\max}$。因此，每个副本实际上都以这个相同的速率推进物理时间。总物理时间推进速率是这 $N$ 个副本有效速率的总和：\n$$\nR_{\\mathrm{sync}} = \\sum_{i=1}^N \\frac{1}{c_{\\max}} = \\frac{N}{c_{\\max}}\n$$\n期望挂钟时间 $T_{\\mathrm{sync}}$ 于是为：\n$$\nT_{\\mathrm{sync}} = \\frac{1/\\lambda}{R_{\\mathrm{sync}}} = \\frac{1/\\lambda}{N/c_{\\max}} = \\frac{c_{\\max}}{N\\lambda}\n$$\n\n**2. 异步非阻塞方案 ($T_{\\mathrm{async}}$)**\n在此方案中，所有 $N$ 个副本都以各自的最大速度独立运行。活动副本的集合是 $S = \\{0, 1, \\dots, N-1\\}$。总物理时间推进速率是所有单个速率的总和：\n$$\nR_{\\mathrm{async}} = \\sum_{i=0}^{N-1} \\frac{1}{c_i}\n$$\n期望挂钟时间 $T_{\\mathrm{async}}$ 为：\n$$\nT_{\\mathrm{async}} = \\frac{1/\\lambda}{R_{\\mathrm{async}}} = \\frac{1}{\\lambda \\sum_{i=0}^{N-1} \\frac{1}{c_i}}\n$$\n这对应于有 $K=N$ 个可用处理器时的通用公式。\n\n**3. $K$ 个副本的最优调度 ($T_{\\mathrm{opt}}$)**\n问题要求找到一个最优策略，以在最多可同时运行 $K$ 个副本（$1 \\leq K \\leq N$）的情况下最小化期望挂钟时间 $\\mathbb{E}[T_{\\text{wall}}]$。\n对于任何 $K$ 个副本的静态集合 $S$，期望时间为 $T(S) = (\\lambda \\sum_{i \\in S} c_i^{-1})^{-1}$。为了最小化 $T(S)$，我们必须最大化分母，特别是总速率 $R_S = \\sum_{i \\in S} c_i^{-1}$。\n由于逃逸过程是无记忆的（源于指数分布的性质），运行哪些副本的最优选择不会随时间改变。在任何时刻，为了最大化演进速率，必须使用那 $K$ 个自身速度最快的副本。最快的副本是那些具有最高速率 $r_i = 1/c_i$ 的副本，这对应于最低的计算成本 $c_i$。\n\n**最优静态选择规则：**最优静态子集 $S^\\star$ 由对应于 $K$ 个最小成本 $c_i$ 的 $K$ 个副本组成。\n\n这个静态策略也是全局最优策略（在静态和动态调度中）。动态策略会涉及交换副本。然而，由于系统的状态在概率上是时刻相同的（无记忆性），因此无法获得任何可以证明改变运行副本集合是合理的额外信息。为了在任何挂钟时间 $T_w$ 最大化累积物理时间，即 $\\int_0^{T_w} R_{S(t')} dt'$，必须在每个时刻 $t'$ 最大化被积函数 $R_{S(t')}$。这通过始终选择相同的集合 $S^\\star$ 来实现。\n\n因此，最小期望挂钟时间 $T_{\\mathrm{opt}}$ 是通过这个静态集合 $S^\\star$ 实现的：\n$$\nT_{\\mathrm{opt}} = \\frac{1}{\\lambda \\sum_{i \\in S^\\star} \\frac{1}{c_i}}\n$$\n其中 $S^\\star$ 是对应于 $\\{c_0, c_1, \\dots, c_{N-1}\\}$ 中 $K$ 个最小值的索引集合。根据问题规范，提供的 $S^\\star$ 索引列表将按升序排序。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Parallel Replica Dynamics scheduling problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (lambda, c_i_list, K)\n        (0.2, [1.0, 1.5, 0.8, 2.0], 2),\n        (1.0, [1.0, 1.0, 1.0], 3),\n        (0.05, [10.0, 10.0, 0.1, 0.1, 0.1], 3),\n        (2.0, [3.0], 1),\n    ]\n\n    # A list to hold the string representation of each case's result\n    all_results_str = []\n\n    for case in test_cases:\n        lam, c_list, K = case\n        c = np.array(c_list)\n        N = len(c)\n\n        # 1. Synchronous scheme (T_sync)\n        c_max = np.max(c)\n        t_sync = c_max / (N * lam)\n\n        # 2. Asynchronous scheme (T_async, all N replicas running)\n        async_rate_sum = np.sum(1.0 / c)\n        t_async = 1.0 / (lam * async_rate_sum)\n\n        # 3. Optimal static schedule for K replicas (T_opt, S_star)\n        # Find the indices of the K replicas with the smallest costs c_i.\n        # np.argsort returns the indices that would sort the array.\n        sorted_indices = np.argsort(c)\n        s_star_indices = sorted_indices[:K]\n        \n        # Calculate T_opt using the costs of the optimal subset\n        optimal_subset_costs = c[s_star_indices]\n        optimal_rate_sum = np.sum(1.0 / optimal_subset_costs)\n        t_opt = 1.0 / (lam * optimal_rate_sum)\n\n        # The output requires the index list to be sorted\n        s_star_indices.sort()\n        s_star_list = s_star_indices.tolist()\n\n        # Format the results for this case into a string\n        # Round times to 6 decimal places as required.\n        # Manually format the list string to avoid spaces.\n        s_star_str = f\"[{','.join(map(str, s_star_list))}]\"\n        \n        result_str = (\n            f\"[{t_sync:.6f},\"\n            f\"{t_async:.6f},\"\n            f\"{t_opt:.6f},\"\n            f\"{s_star_str}]\"\n        )\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3473158"}, {"introduction": "ParRep 方法建立在一个基本假设之上：系统在势阱内达到热平衡的速度远快于其逃离该势阱的速度。最后的这个动手练习是一项计算任务，旨在通过提交函数（committor function）的概念来严格检验这一假设。通过编写程序计算一个多势阱系统的提交函数，您将学习一种强有力的诊断技术，以判断一个系统是否适合使用 ParRep，并对稀有事件理论获得更深刻的见解。[@problem_id:3473222]", "problem": "考虑一个粒子在束缚性三阱势中演化，其在一维空间中的动力学由过阻尼朗之万动力学描述。该动力学由随机微分方程 $dx_t = -D \\beta U'(x_t) \\, dt + \\sqrt{2D} \\, dW_t$ 描述，其中 $x_t$ 是作为时间 $t$ 函数的位置，$D$ 是常数扩散系数，$\\beta$ 是逆温度，$U(x)$ 是势能函数，$U'(x)$ 是 $U(x)$ 的空间导数，$W_t$ 是标准维纳过程。在无量纲单位下，取 $D = 1$。势函数指定为 $U(x) = a x^6 - b x^4 + c x^2$，其中参数 $a  0$、$b  0$、$c  0$ 的选择使得 $U(x)$ 具有三个由两个局域极大值分隔的局域极小值。这种情况在 $b^2  3 a c$ 时发生。将计算域定义为区间 $\\left[-L, L\\right]$，其中 $L  0$ 足够大，以包含外部的势阱。\n\n并行副本动力学 (Parallel Replica Dynamics, PRD) 的一个关键假设是阱内混合和阱间穿越之间存在时间尺度分离：一旦系统进入一个势阱，它会在发生离开该势阱的稀有过渡事件之前，迅速弛豫到准静态分布。验证此假设的一种方法是通过提交函数。对于一对不相交的边界 $x_\\ell, x_r$，提交函数 $q(x)$ 定义为从位置 $x$ 开始的轨迹在到达边界 $x_\\ell$ 之前先到达边界 $x_r$ 的概率。\n\n您的任务是：\n\n1. 使用 $U(x)$ 的局域极小值和局域极大值将区域划分为多个势阱。具体来说：\n   - 通过求解 $U'(x) = 0$ 计算 $U(x)$ 的所有临界点，并根据 $U''(x)$ 的符号对其进行分类，以确定局域极小值和局域极大值。\n   - 令 $x = 0$ 为中心极小值（对于 $c  0$）。利用其余临界点，确定位于 $x = -x_{\\min}$ 和 $x = +x_{\\min}$ 的左右局域极小值，以及位于 $x = -x_{\\mathrm{sad}}$ 和 $x = +x_{\\mathrm{sad}}$ 的左右局域极大值（一维中的鞍点），其中 $x_{\\mathrm{sad}}  x_{\\min}$。\n   - 将三个势阱定义为区间：左势阱 $\\left[-L, -x_{\\mathrm{sad}}\\right]$，中心势阱 $\\left[-x_{\\mathrm{sad}}, +x_{\\mathrm{sad}}\\right]$，以及右势阱 $\\left[+x_{\\mathrm{sad}}, +L\\right]$。\n\n2. 对每个势阱，定义一个与阱间穿越事件方向一致的适当的提交函数：\n   - 在左势阱中，将 $q_{\\mathrm{left}}(x)$ 定义为在到达 $-L$ 之前先到达 $-x_{\\mathrm{sad}}$ 的概率。\n   - 在中心势阱中，将 $q_{\\mathrm{center}}(x)$ 定义为在到达 $-x_{\\mathrm{sad}}$ 之前先到达 $+x_{\\mathrm{sad}}$ 的概率。\n   - 在右势阱中，将 $p_{\\mathrm{right}}(x)$ 定义为在到达 $+L$ 之前先到达 $+x_{\\mathrm{sad}}$ 的概率。\n   在所有情况下，使用与朗之万动力学相关的后向方程来计算这些提交函数，并对与势阱相关的边界对 $\\left(x_\\ell, x_r\\right)$ 使用吸收边界条件 $q(x_\\ell) = 0$ 和 $q(x_r) = 1$。以无量纲单位作答。\n\n3. 为验证阱内混合相对于穿越事件是快速的，通过计算提交函数值位于阈值 $0.1$ 和 $0.9$ 之间的区域宽度，来量化每个势阱内提交函数过渡层的陡峭程度。具体而言，对每个势阱，计算提交函数分别等于 $0.1$ 和 $0.9$ 时的位置 $x_{0.1}$ 和 $x_{0.9}$，并将过渡宽度定义为 $w = x_{0.9} - x_{0.1}$。将势阱宽度定义为 $W = x_r - x_\\ell$。对于右势阱，将此方法应用于 $p_{\\mathrm{right}}(x)$ 而非 $q_{\\mathrm{right}}(x)$，以便阈值的解释与向中心穿越的方向保持一致。报告每个势阱的比率 $r = w / W$，并最终对每个参数集，报告这三个势阱比率中的最大值。较小的 $r$ 值表示过渡区域相对于势阱尺寸较窄，因此阱内混合相对于穿越是快速的。\n\n4. 实现一个完整的程序，执行上述步骤，并为以下测试套件生成结果。全程使用无量纲单位。对于每个测试用例，输出一个浮点数，其值等于三个势阱中最大的过渡比率：\n   - 测试用例 1：$a = 1.0$, $b = 3.0$, $c = 2.0$, $\\beta = 10.0$, $L = 3.0$。\n   - 测试用例 2：$a = 1.0$, $b = 2.8$, $c = 2.0$, $\\beta = 5.0$, $L = 3.0$。\n   - 测试用例 3：$a = 1.0$, $b = 3.5$, $c = 2.0$, $\\beta = 25.0$, $L = 3.5$。\n\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$）。每个结果必须是浮点数。不应打印任何其他文本。", "solution": "The user wants me to solve a multi-step computational problem related to validating an assumption in Parallel Replica Dynamics (PRD) for a particle in a one-dimensional triple-well potential.\n\n### Step 1: Extract Givens\n- **Governing Equation**: Overdamped Langevin dynamics, $dx_t = -D \\beta U'(x_t) \\, dt + \\sqrt{2D} \\, dW_t$.\n- **Diffusion Coefficient**: $D=1$ (nondimensional).\n- **Potential Energy**: $U(x) = a x^6 - b x^4 + c x^2$.\n- **Potential Parameters**: $a  0$, $b  0$, $c  0$.\n- **Condition for 3 Minima**: $b^2  3ac$.\n- **Computational Domain**: $\\left[-L, L\\right]$, $L  0$.\n- **PRD Assumption**: Timescale separation between fast intra-basin relaxation and slow inter-basin transitions.\n- **Validation Method**: Compute committor functions $q(x)$ and analyze their transition widths.\n- **Task 1: Basin Definition**:\n    - Critical points: solve $U'(x)=0$.\n    - Classify points using $U''(x)$ into minima ($\\pm x_{\\min}$, $0$) and maxima ($\\pm x_{\\mathrm{sad}}$).\n    - Establish basin boundaries using the saddle points $\\pm x_{\\mathrm{sad}}$:\n        - Left basin: $\\left[-L, -x_{\\mathrm{sad}}\\right]$.\n        - Central basin: $\\left[-x_{\\mathrm{sad}}, +x_{\\mathrm{sad}}\\right]$.\n        - Right basin: $\\left[+x_{\\mathrm{sad}}, +L\\right]$.\n- **Task 2: Committor Functions**:\n    - Committor $q(x)$ on $[x_\\ell, x_r]$ is the probability to hit $x_r$ before $x_\\ell$.\n    - Governed by the backward equation: $q''(x) - \\beta U'(x) q'(x) = 0$ (with $D=1$).\n    - Boundary Conditions: $q(x_\\ell) = 0$, $q(x_r) = 1$.\n    - Specific committors:\n        - Left, $q_{\\mathrm{left}}(x)$: on $\\left[-L, -x_{\\mathrm{sad}}\\right]$, hit $-x_{\\mathrm{sad}}$ before $-L$.\n        - Center, $q_{\\mathrm{center}}(x)$: on $\\left[-x_{\\mathrm{sad}}, +x_{\\mathrm{sad}}\\right]$, hit $+x_{\\mathrm{sad}}$ before $-x_{\\mathrm{sad}}$.\n        - Right, $p_{\\mathrm{right}}(x)$: on $\\left[+x_{\\mathrm{sad}}, +L\\right]$, hit $+x_{\\mathrm{sad}}$ before $+L$.\n- **Task 3: Transition Ratio**:\n    - Find positions $x_{0.1}$ and $x_{0.9}$ where the relevant committor is $0.1$ and $0.9$.\n    - Transition width: $w = x_{0.9} - x_{0.1}$. (Interpreted as $|x_{0.9} - x_{0.1}|$ to ensure physical width is positive).\n    - Basin width: $W = x_r - x_\\ell$.\n    - Ratio: $r = w / W$.\n    - Final result per test case: Maximum of the three basin ratios.\n- **Task 4: Test Cases**:\n    1. $a = 1.0$, $b = 3.0$, $c = 2.0$, $\\beta = 10.0$, $L = 3.0$.\n    2. $a = 1.0$, $b = 2.8$, $c = 2.0$, $\\beta = 5.0$, $L = 3.0$.\n    3. $a = 1.0$, $b = 3.5$, $c = 2.0$, $\\beta = 25.0$, $L = 3.5$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard physical model (Langevin dynamics in a multi-well potential) and uses established mathematical tools (committor functions, backward Fokker-Planck equation) to investigate a core concept in computational chemistry (timescale separation). The parameters and conditions are self-consistent and complete. For example, the condition $b^2  3ac$ ensures the existence of five distinct real critical points, which is necessary for a triple-well structure. The tasks are defined algorithmically and lead to a unique, computable solution. The only minor imprecision is in the definition of the transition width $w = x_{0.9} - x_{0.1}$ for the right basin, where the committor function $p_{\\mathrm{right}}(x)$ is decreasing. A literal interpretation would yield a negative width. The physically meaningful interpretation is that width is a positive quantity, i.e., $|x_{0.9} - x_{0.1}|$. This clarification does not invalidate the problem but is necessary for a meaningful solution that compares the sharpness of transitions across basins.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will now proceed with the solution.\n\n### Principle-Based Design\nThe solution proceeds through a sequence of logical steps derived from the theory of stochastic processes.\n\n**1. Basin Identification**\n\nThe potential is given by $U(x) = a x^6 - b x^4 + c x^2$. The basins of attraction are separated by local maxima of the potential (saddle points in 1D). To find these, we first compute the critical points by solving $U'(x) = 0$:\n$$ U'(x) = 6ax^5 - 4bx^3 + 2cx = 2x(3ax^4 - 2bx^2 + c) = 0 $$\nOne critical point is $x=0$. The others are found by solving the quadratic equation in $x^2$: $3a(x^2)^2 - 2b(x^2) + c = 0$. The solutions for $x^2$ are:\n$$ x^2 = \\frac{2b \\pm \\sqrt{4b^2 - 12ac}}{6a} = \\frac{b \\pm \\sqrt{b^2 - 3ac}}{3a} $$\nThe condition $b^2  3ac$ ensures two distinct, positive solutions for $x^2$. Let these be $x_{\\min}^2$ and $x_{\\mathrm{sad}}^2$. We classify them using the aign of the second derivative, $U''(x) = 30ax^4 - 12bx^2 + 2c$.\n- For $x^2 = x_{\\mathrm{sad}}^2 = \\frac{b - \\sqrt{b^2 - 3ac}}{3a}$, $U''(x)  0$, corresponding to local maxima (saddles) at $\\pm x_{\\mathrm{sad}}$.\n- For $x=0$, $U''(0) = 2c  0$, corresponding to the central local minimum.\n- For $x^2 = x_{\\min}^2 = \\frac{b + \\sqrt{b^2 - 3ac}}{3a}$, $U''(x)  0$, corresponding to the side-well local minima at $\\pm x_{\\min}$.\nThe basins are then defined by the saddle points: Left: $\\left[-L, -x_{\\mathrm{sad}}\\right]$, Central: $\\left[-x_{\\mathrm{sad}}, +x_{\\mathrm{sad}}\\right]$, and Right: $\\left[+x_{\\mathrm{sad}}, L\\right]$.\n\n**2. Committor Function Solution**\n\nThe committor function $q(x)$ for a process on an interval $[x_\\ell, x_r]$ is governed by the backward equation, which for the given overdamped Langevin dynamics with $D=1$ is:\n$$ \\frac{d^2q}{dx^2} - \\beta U'(x) \\frac{dq}{dx} = 0 $$\nwith boundary conditions $q(x_\\ell) = 0$ and $q(x_r) = 1$. This is a second-order linear ODE. Letting $v(x) = q'(x)$, we get a first-order separable equation $v'(x) = \\beta U'(x) v(x)$, which solves to $v(x) = C_1 e^{\\beta U(x)}$. Integrating $q'(x)$ from $x_\\ell$ to $x$ and applying the boundary conditions yields the well-known solution:\n$$ q(x) = \\frac{\\displaystyle \\int_{x_\\ell}^{x} e^{\\beta U(y)} \\,dy}{\\displaystyle \\int_{x_\\ell}^{x_r} e^{\\beta U(y)} \\,dy} $$\nThis formula applies directly to $q_{\\mathrm{left}}(x)$ and $q_{\\mathrm{center}}(x)$. For the right basin, the committor $p_{\\mathrm{right}}(x)$ is the probability to reach $+x_{\\mathrm{sad}}$ before $+L$. This corresponds to setting $x_\\ell = +L$ and $x_r = +x_{\\mathrm{sad}}$, resulting in $p_{\\mathrm{right}}(+L)=0$ and $p_{\\mathrm{right}}(+x_{\\mathrm{sad}})=1$. The solution is:\n$$ p_{\\mathrm{right}}(x) = \\frac{\\displaystyle \\int_{+L}^{x} e^{\\beta U(y)} \\,dy}{\\displaystyle \\int_{+L}^{+x_{\\mathrm{sad}}} e^{\\beta U(y)} \\,dy} = 1 - \\frac{\\displaystyle \\int_{+x_{\\mathrm{sad}}}^{x} e^{\\beta U(y)} \\,dy}{\\displaystyle \\int_{+x_{\\mathrm{sad}}}^{+L} e^{\\beta U(y)} \\,dy} $$\n\n**3. Numerical Implementation**\n\nThe core of the problem is to compute the ratio $r = w/W$ for each basin. This requires finding the positions $x_{0.1}$ and $x_{0.9}$ for each committor.\nFor an increasing committor $q(x)$, we must solve $q(x) = 0.1$ and $q(x) = 0.9$. This is equivalent to solving for $x$ in:\n$$ \\int_{x_\\ell}^{x} e^{\\beta U(y)} \\,dy = C \\cdot \\int_{x_\\ell}^{x_r} e^{\\beta U(y)} \\,dy $$\nwhere $C$ is $0.1$ or $0.9$. This is a root-finding problem.\n\nA significant numerical challenge arises from the term $e^{\\beta U(y)}$. For large $\\beta$ or large $|x|$, this term can cause floating-point overflow. We circumvent this by noting that the committor formula is a ratio. We can shift the potential by a constant $U_0$ without changing the result:\n$$ q(x) = \\frac{\\displaystyle \\int_{x_\\ell}^{x} e^{\\beta (U(y)-U_0)} \\,dy}{\\displaystyle \\int_{x_\\ell}^{x_r} e^{\\beta (U(y)-U_0)} \\,dy} $$\nBy choosing $U_0$ as the minimum value of $U(y)$ in the interval $[x_\\ell, x_r]$, we ensure that the exponent $\\beta(U(y)-U_0)$ is always non-negative and its minimum is $0$. This maximizes numerical stability.\n\nThe overall algorithm for each basin is:\n1. Define the basin boundaries $(x_\\ell, x_r)$.\n2. Find the minimum of the potential $U_0 = \\min_{y \\in [x_\\ell, x_r]} U(y)$ using a numerical optimization routine.\n3. Define the stabilized integrand $f(y) = e^{\\beta(U(y)-U_0)}$.\n4. Compute the total integral $I_{\\mathrm{tot}} = \\int_{x_\\ell}^{x_r} f(y) \\,dy$ using numerical quadrature.\n5. Solve for $x_{0.1}$ and $x_{0.9}$ by finding the roots of the equations $\\int_{x_\\ell}^{x} f(y) \\,dy - C \\cdot I_{\\mathrm{tot}} = 0$ for $C=0.1$ and $C=0.9$ using a numerical root-finder.\n6. For all basins, the transition width is taken as the positive distance $w = |x_{0.9}-x_{0.1}|$. This is consistent with the physical meaning of width and correctly handles both increasing ($q_{\\text{left}}, q_{\\text{center}}$) and decreasing ($p_{\\text{right}}$) committor functions.\n7. Compute the ratio $r = w / (x_r - x_\\ell)$.\nFinally, the maximum ratio among the three basins is selected as the result for the given parameter set.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import brentq, minimize_scalar\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # (a, b, c, beta, L)\n        (1.0, 3.0, 2.0, 10.0, 3.0),\n        (1.0, 2.8, 2.0, 5.0, 3.0),\n        (1.0, 3.5, 2.0, 25.0, 3.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        a, b, c, beta, L = case\n        max_ratio = calculate_max_transition_ratio(a, b, c, beta, L)\n        results.append(max_ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_max_transition_ratio(a, b, c, beta, L):\n    \"\"\"\n    Calculates the maximum transition ratio across the three basins for a given set of parameters.\n    \"\"\"\n    \n    # Define the potential energy function U(x)\n    U = lambda x: a * x**6 - b * x**4 + c * x**2\n    \n    # 1. Find critical points to define basins\n    # The saddles are roots of 3a*z^2 - 2b*z + c = 0 where z = x^2.\n    # We only need the smaller positive root for x^2, which corresponds to the saddle points.\n    discriminant = (2 * b)**2 - 4 * (3 * a) * c\n    # The x^2 value for the saddle point\n    x_sad_sq = (2 * b - np.sqrt(discriminant)) / (2 * 3 * a)\n    x_sad = np.sqrt(x_sad_sq)\n    \n    # Define the three basins based on the saddle points\n    basins = [\n        (-L, -x_sad),       # Left basin\n        (-x_sad, x_sad),    # Central basin\n        (x_sad, L),         # Right basin\n    ]\n    \n    ratios = []\n    for xl, xr in basins:\n        ratio = compute_ratio_for_basin(xl, xr, U, beta)\n        ratios.append(ratio)\n        \n    return max(ratios)\n\ndef compute_ratio_for_basin(xl, xr, U_func, beta):\n    \"\"\"\n    Computes the transition width to basin width ratio for a single basin.\n\n    This function calculates the width of the region where the normalized integral\n    of exp(beta*U(x)) is between 0.1 and 0.9. This corresponds to the physical\n    transition width of the committor function.\n    \"\"\"\n    \n    # 1. Numerical stabilization by shifting the potential\n    # Find the minimum of the potential U(x) in the interval [xl, xr]\n    res = minimize_scalar(U_func, bounds=(xl, xr), method='bounded')\n    U_min = res.fun\n    \n    # Define the numerically stable integrand\n    stable_integrand = lambda y: np.exp(beta * (U_func(y) - U_min))\n    \n    # 2. Compute the total integral for normalization\n    total_integral, _ = quad(stable_integrand, xl, xr, epsabs=1e-12, epsrel=1e-12)\n    \n    # 3. Define functions for the root-finder\n    # The root of this function gives the position x where the partial integral\n    # is 0.1 of the total integral.\n    def root_func_01(x):\n        integral_part, _ = quad(stable_integrand, xl, x, epsabs=1e-12, epsrel=1e-12)\n        return integral_part - 0.1 * total_integral\n    \n    # The root of this function gives the position x for the 0.9 threshold.\n    def root_func_09(x):\n        integral_part, _ = quad(stable_integrand, xl, x, epsabs=1e-12, epsrel=1e-12)\n        return integral_part - 0.9 * total_integral\n        \n    # 4. Find the positions x_0.1 and x_0.9 by finding the roots\n    # The brentq algorithm requires an interval where the function changes sign.\n    # The functions are monotonic, so [xl, xr] is a valid bracket.\n    try:\n        x_sol_01 = brentq(root_func_01, xl, xr)\n        x_sol_09 = brentq(root_func_09, xl, xr)\n    except ValueError:\n        # This may happen if the function does not change sign,\n        # e.g., if the integral is numerically zero. Return a default value.\n        return 0.0\n\n    # 5. Calculate widths and the final ratio\n    # W_basin is the total width of the basin\n    W_basin = xr - xl\n    \n    # w_transition is the width of the transition region (0.1 to 0.9)\n    # The width is a positive quantity, |x_0.9 - x_0.1|.\n    # Since the integral is monotonically increasing, x_sol_09  x_sol_01.\n    w_transition = x_sol_09 - x_sol_01\n    \n    if W_basin == 0:\n        return 0.0\n\n    return w_transition / W_basin\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3473222"}]}