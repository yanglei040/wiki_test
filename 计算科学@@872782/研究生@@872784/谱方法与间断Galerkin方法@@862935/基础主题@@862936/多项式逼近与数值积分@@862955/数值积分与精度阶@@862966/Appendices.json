{"hands_on_practices": [{"introduction": "高斯求积是谱方法和间断 Galerkin (DG) 方法中高效积分的基石。其强大之处在于，对于给定数量的求积点，它能达到最高的积分精度。本练习将引导你从第一性原理出发，通过求解矩条件方程组来推导一个三点高斯-勒让德求积法则，而不是直接使用现成的公式。这个过程将揭示其最优性的数学基础，帮助你深入理解求积精度这一核心概念。[@problem_id:3405879]", "problem": "在高阶间断伽辽金（DG）方法和谱元法中，参考单元上的体积分通过数值求积进行计算。区间 $[a,b]$ 上的一个求积法则是形如 $\\int_{a}^{b} f(x)\\,\\mathrm{d}x \\approx \\sum_{j=1}^{m} w_{j} f(x_{j})$ 的近似，其中 $x_{j}$ 是节点，$w_{j}$ 是权重。一个求积法则的代数精度是指该法则对于次数至多为 $n$ 的所有多项式都精确成立的最大整数 $n$。在对称区间 $[-1,1]$ 上，与勒让德多项式相关的高斯求积法则被广泛使用，因为它们在给定节点数目的情况下可以最大化代数精度。\n\n从以上定义和区间 $[-1,1]$ 的对称性考虑出发，构造一个在 $[-1,1]$ 上的高斯-勒让德类型的三点求积法则，通过确定其节点 $x_{1}, x_{2}, x_{3}$ 和权重 $w_{1}, w_{2}, w_{3}$，使得该法则对所有 $k \\in \\{0,1,2,3,4,5\\}$ 的单项式 $x^{k}$ 都精确成立。仅使用由单项式精确性所蕴含的矩条件和区间的对称性，而不引用任何关于高斯求积节点或权重的预先推导的闭式公式。然后通过检验对 $x^{k}$ ($k=0,1,2,3,4,5$) 的精确性来验证所构造的法则达到了5次代数精度。\n\n你的最终答案必须在单行中列出三个节点和三个权重，按节点递增的顺序排列，并以精确解析表达式的形式给出。不需要进行四舍五入。", "solution": "问题要求在区间 $[-1, 1]$ 上构造一个三点求积法则，其形式为 $\\int_{-1}^{1} f(x)\\,\\mathrm{d}x \\approx \\sum_{j=1}^{3} w_{j} f(x_{j})$，且该法则对所有次数最高为5的多项式都精确成立。这意味着该法则必须对 $k \\in \\{0, 1, 2, 3, 4, 5\\}$ 的单项式基 $\\{x^k\\}$ 精确成立。我们必须确定六个未知数：三个节点 $x_1, x_2, x_3$ 和三个权重 $w_1, w_2, w_3$。\n\n对 $f(x) = x^k$ 的精确性条件产生了一个包含六个方程的方程组：\n$$\n\\sum_{j=1}^{3} w_{j} x_{j}^{k} = \\int_{-1}^{1} x^{k}\\,\\mathrm{d}x \\quad \\text{对于 } k = 0, 1, 2, 3, 4, 5\n$$\n首先，我们计算这些方程的右边，即区间 $[-1, 1]$ 的矩。该积分由以下公式给出：\n$$\n\\int_{-1}^{1} x^{k}\\,\\mathrm{d}x = \\left[ \\frac{x^{k+1}}{k+1} \\right]_{-1}^{1} = \\frac{1^{k+1} - (-1)^{k+1}}{k+1}\n$$\n如果 $k$ 是奇数，$k+1$ 是偶数，积分为 $\\frac{1-1}{k+1} = 0$。\n如果 $k$ 是偶数，$k+1$ 是奇数，积分为 $\\frac{1-(-1)}{k+1} = \\frac{2}{k+1}$。\n\n这给了我们矩的以下值：\n$k=0: \\int_{-1}^{1} 1\\,\\mathrm{d}x = 2$\n$k=1: \\int_{-1}^{1} x\\,\\mathrm{d}x = 0$\n$k=2: \\int_{-1}^{1} x^2\\,\\mathrm{d}x = \\frac{2}{3}$\n$k=3: \\int_{-1}^{1} x^3\\,\\mathrm{d}x = 0$\n$k=4: \\int_{-1}^{1} x^4\\,\\mathrm{d}x = \\frac{2}{5}$\n$k=5: \\int_{-1}^{1} x^5\\,\\mathrm{d}x = 0$\n\n用于求解节点和权重的六个方程组是：\n1.  $w_1 x_1^0 + w_2 x_2^0 + w_3 x_3^0 = w_1 + w_2 + w_3 = 2$\n2.  $w_1 x_1^1 + w_2 x_2^1 + w_3 x_3^1 = 0$\n3.  $w_1 x_1^2 + w_2 x_2^2 + w_3 x_3^2 = \\frac{2}{3}$\n4.  $w_1 x_1^3 + w_2 x_2^3 + w_3 x_3^3 = 0$\n5.  $w_1 x_1^4 + w_2 x_2^4 + w_3 x_3^4 = \\frac{2}{5}$\n6.  $w_1 x_1^5 + w_2 x_2^5 + w_3 x_3^5 = 0$\n\n按照问题的建议，我们利用积分区间 $[-1, 1]$ 的对称性。对于一个最优的求积法则，其节点和权重应表现出对称性。我们假设一个对称的配置：一个节点在原点，另外两个节点关于原点对称。设节点排序为 $x_1  x_2  x_3$。我们设 $x_2 = 0$ 以及 $x_1 = -\\xi, x_3 = \\xi$ (对于某个 $\\xi  0$)。节点的对称性意味着权重也相应地对称：$w_1 = w_3$。\n\n将这些对称性假设代入我们的方程组，可以极大地简化它。未知数减少到三个：$\\xi$, $w_1$ 和 $w_2$。\n\n让我们重新审视这些方程：\n1.  $w_1 + w_2 + w_1 = 2w_1 + w_2 = 2$\n2.  $w_1(-\\xi) + w_2(0) + w_1(\\xi) = -w_1\\xi + w_1\\xi = 0$。这个方程被我们的对称性假设自动满足，不提供任何新信息。\n3.  $w_1(-\\xi)^2 + w_2(0)^2 + w_1(\\xi)^2 = w_1\\xi^2 + w_1\\xi^2 = 2w_1\\xi^2 = \\frac{2}{3}$\n4.  $w_1(-\\xi)^3 + w_2(0)^3 + w_1(\\xi)^3 = -w_1\\xi^3 + w_1\\xi^3 = 0$。这个也自动满足了。\n5.  $w_1(-\\xi)^4 + w_2(0)^4 + w_1(\\xi)^4 = w_1\\xi^4 + w_1\\xi^4 = 2w_1\\xi^4 = \\frac{2}{5}$\n6.  $w_1(-\\xi)^5 + w_2(0)^5 + w_1(\\xi)^5 = -w_1\\xi^5 + w_1\\xi^5 = 0$。这个也自动满足了。\n\n对应于奇函数在对称区间上的积分的 $x$ 的奇次幂方程被自动满足，这一事实验证了我们的对称性假设。我们得到了一个由 $x$ 的偶次幂导出的包含三个方程的方程组：\n(A) $2w_1 + w_2 = 2$\n(B) $2w_1\\xi^2 = \\frac{2}{3} \\implies w_1\\xi^2 = \\frac{1}{3}$\n(C) $2w_1\\xi^4 = \\frac{2}{5} \\implies w_1\\xi^4 = \\frac{1}{5}$\n\n我们可以求解这个方程组来得到 $\\xi$、$w_1$ 和 $w_2$。通过将方程(C)除以方程(B)，我们可以消去 $w_1$：\n$$\n\\frac{w_1\\xi^4}{w_1\\xi^2} = \\frac{1/5}{1/3}\n$$\n$$\n\\xi^2 = \\frac{3}{5}\n$$\n因为我们定义了 $\\xi  0$，我们得到 $\\xi = \\sqrt{\\frac{3}{5}}$。\n\n因此，节点为：\n$x_1 = -\\sqrt{\\frac{3}{5}}$\n$x_2 = 0$\n$x_3 = \\sqrt{\\frac{3}{5}}$\n\n现在我们确定权重。从方程(B)中，我们求得 $w_1$：\n$$\nw_1 = \\frac{1}{3\\xi^2} = \\frac{1}{3 \\left(\\frac{3}{5}\\right)} = \\frac{1}{\\frac{9}{5}} = \\frac{5}{9}\n$$\n根据对称性，$w_3 = w_1 = \\frac{5}{9}$。\n\n最后，我们从方程(A)中求得 $w_2$：\n$$\nw_2 = 2 - 2w_1 = 2 - 2\\left(\\frac{5}{9}\\right) = 2 - \\frac{10}{9} = \\frac{18 - 10}{9} = \\frac{8}{9}\n$$\n\n所以，这个三点求积法则由以下定义：\n节点： $x_1 = -\\sqrt{\\frac{3}{5}}$, $x_2 = 0$, $x_3 = \\sqrt{\\frac{3}{5}}$\n权重： $w_1 = \\frac{5}{9}$, $w_2 = \\frac{8}{9}$, $w_3 = \\frac{5}{9}$\n\n问题要求验证该法则对 $k \\in \\{0,1,2,3,4,5\\}$ 精确成立。\n令 $S_k = \\sum_{j=1}^{3} w_j x_j^k$ 且 $I_k = \\int_{-1}^{1} x^k\\,\\mathrm{d}x$。\n\n- 对 $k=0$： $S_0 = \\frac{5}{9}(1) + \\frac{8}{9}(1) + \\frac{5}{9}(1) = \\frac{18}{9} = 2$。 $I_0 = 2$。精确。\n- 对 $k=1$： $S_1 = \\frac{5}{9}(-\\sqrt{\\frac{3}{5}}) + \\frac{8}{9}(0) + \\frac{5}{9}(\\sqrt{\\frac{3}{5}}) = 0$。 $I_1 = 0$。精确。\n- 对 $k=2$： $S_2 = \\frac{5}{9}(-\\sqrt{\\frac{3}{5}})^2 + \\frac{8}{9}(0)^2 + \\frac{5}{9}(\\sqrt{\\frac{3}{5}})^2 = \\frac{5}{9}(\\frac{3}{5}) + 0 + \\frac{5}{9}(\\frac{3}{5}) = \\frac{1}{3} + \\frac{1}{3} = \\frac{2}{3}$。 $I_2 = \\frac{2}{3}$。精确。\n- 对 $k=3$： $S_3 = \\frac{5}{9}(-\\sqrt{\\frac{3}{5}})^3 + \\frac{8}{9}(0)^3 + \\frac{5}{9}(\\sqrt{\\frac{3}{5}})^3 = \\frac{5}{9}(-\\frac{3}{5}\\sqrt{\\frac{3}{5}}) + 0 + \\frac{5}{9}(\\frac{3}{5}\\sqrt{\\frac{3}{5}}) = 0$。 $I_3 = 0$。精确。\n- 对 $k=4$： $S_4 = \\frac{5}{9}(-\\sqrt{\\frac{3}{5}})^4 + \\frac{8}{9}(0)^4 + \\frac{5}{9}(\\sqrt{\\frac{3}{5}})^4 = \\frac{5}{9}(\\frac{9}{25}) + 0 + \\frac{5}{9}(\\frac{9}{25}) = \\frac{1}{5} + \\frac{1}{5} = \\frac{2}{5}$。 $I_4 = \\frac{2}{5}$。精确。\n- 对 $k=5$： $S_5 = \\frac{5}{9}(-\\sqrt{\\frac{3}{5}})^5 + \\frac{8}{9}(0)^5 + \\frac{5}{9}(\\sqrt{\\frac{3}{5}})^5 = \\frac{5}{9}(-\\frac{9}{25}\\sqrt{\\frac{3}{5}}) + 0 + \\frac{5}{9}(\\frac{9}{25}\\sqrt{\\frac{3}{5}}) = 0$。 $I_5 = 0$。精确。\n\n该验证确认了此法则对所有次数最高为5的单项式都精确成立。代数精度是该法则对所有次数至多为 $n$ 的多项式都精确成立的最大整数 $n$。由于该法则对 $x^5$ 精确，但对 $x^6$ 不精确（m点高斯求积的一个普遍性质是其代数精度为 $2m-1$），这个3点法则的代数精度是 $2(3)-1=5$。我们的验证与此理论结果一致。\n\n最终答案由按指定顺序排列的节点和权重组成。\n按递增顺序排列的节点：$x_1 = -\\sqrt{\\frac{3}{5}}$，$x_2 = 0$，$x_3 = \\sqrt{\\frac{3}{5}}$。\n对应的权重：$w_1 = \\frac{5}{9}$，$w_2 = \\frac{8}{9}$，$w_3 = \\frac{5}{9}$。\n列表为：$-\\sqrt{\\frac{3}{5}}, 0, \\sqrt{\\frac{3}{5}}, \\frac{5}{9}, \\frac{8}{9}, \\frac{5}{9}$。", "answer": "$$\n\\boxed{\\begin{pmatrix} -\\sqrt{\\frac{3}{5}}  0  \\sqrt{\\frac{3}{5}}  \\frac{5}{9}  \\frac{8}{9}  \\frac{5}{9} \\end{pmatrix}}\n$$", "id": "3405879"}, {"introduction": "在了解了如何构建一个最优的求积法则之后，一个自然的问题是：如果选择其他非最优的节点会发生什么？本练习探讨了基于一组任意指定的节点所构建的插值型求积法则的性质，重点关注其求积权重。这个实践将求积法则的抽象属性（特别是权重的符号）与间断 Galerkin 方法中的一个关键实际问题——当使用质量集中技术时显式时间步进格式的稳定性——联系起来。它深刻地揭示了求积节点的选择对数值方法稳定性的重要影响，其意义远超简单的积分精度。[@problem_id:3405819]", "problem": "考虑在区间 $[-1,1]$ 上的一个插值型求积法则，它有四个不同的节点 $x_{1}=-1$，$x_{2}=-\\frac{1}{2}$，$x_{3}=0$ 和 $x_{4}=1$。根据定义，如果一个有 $n$ 个节点的插值型求积法则的权重 $w_{1},\\dots,w_{n}$ 被选择，使得该法则对所有次数最高为 $n-1$ 的多项式都精确，那么它的精度阶至少为 $n-1$。这通过匹配单项式的矩来实现：对于整数 $k=0,1,\\dots,n-1$，权重必须满足 $\\sum_{i=1}^{n} w_{i} x_{i}^{k} = \\int_{-1}^{1} x^{k}\\,\\mathrm{d}x$。仅使用这些基本定义和事实，计算出唯一的权重 $w_{1},w_{2},w_{3},w_{4}$，使得该求积法则对 $[-1,1]$ 上所有次数至多为 $3$ 的多项式都精确，并判断是否所有权重都为正。然后，基于第一性原理，推断当使用质量集中求积法对质量矩阵进行对角化时，这些权重的符号模式对非连续伽辽金 (DG) 方法中显式时间步进的影响。作为最终的数值答案，报告 $w_{1},w_{2},w_{3},w_{4}$ 中最小的权重值 $w_{\\min}$。", "solution": "该问题要求计算在区间 $[-1, 1]$ 上的一个特定四节点插值型求积法则的权重，并分析其性质，特别是在非连续伽辽金 (DG) 方法的背景下。\n\n该求积法则定义在区间 $[-1, 1]$ 上，有 $n=4$ 个不同的节点：$x_{1}=-1$，$x_{2}=-\\frac{1}{2}$，$x_{3}=0$ 和 $x_{4}=1$。\n该法则被指定为一个插值型求积法则，它对所有次数最高为 $n-1 = 3$ 的多项式都精确。这个条件是通过要求该求积法则能精确积分单项式 $x^k$（其中 $k=0, 1, 2, 3$）来强制执行的。这为未知权重 $w_1, w_2, w_3, w_4$ 导出了一个线性方程组：\n$$ \\sum_{i=1}^{4} w_{i} x_{i}^{k} = \\int_{-1}^{1} x^{k}\\,\\mathrm{d}x \\quad \\text{对于 } k=0, 1, 2, 3 $$\n\n首先，我们计算这些方程的右边，即单项式在 $[-1, 1]$ 上的矩。\n对于 $k=0$：\n$$ \\int_{-1}^{1} x^{0}\\,\\mathrm{d}x = \\int_{-1}^{1} 1\\,\\mathrm{d}x = [x]_{-1}^{1} = 1 - (-1) = 2 $$\n对于 $k=1$：\n$$ \\int_{-1}^{1} x^{1}\\,\\mathrm{d}x = \\left[\\frac{x^{2}}{2}\\right]_{-1}^{1} = \\frac{1^{2}}{2} - \\frac{(-1)^{2}}{2} = 0 $$\n对于 $k=2$：\n$$ \\int_{-1}^{1} x^{2}\\,\\mathrm{d}x = \\left[\\frac{x^{3}}{3}\\right]_{-1}^{1} = \\frac{1^{3}}{3} - \\frac{(-1)^{3}}{3} = \\frac{1}{3} - \\left(-\\frac{1}{3}\\right) = \\frac{2}{3} $$\n对于 $k=3$：\n$$ \\int_{-1}^{1} x^{3}\\,\\mathrm{d}x = \\left[\\frac{x^{4}}{4}\\right]_{-1}^{1} = \\frac{1^{4}}{4} - \\frac{(-1)^{4}}{4} = 0 $$\n\n现在，我们通过代入节点值 $x_1=-1, x_2=-1/2, x_3=0, x_4=1$ 和计算出的积分值来构建线性系统。\n对于 $k=0$： $w_1(x_1)^0 + w_2(x_2)^0 + w_3(x_3)^0 + w_4(x_4)^0 = w_1 + w_2 + w_3 + w_4 = 2$\n对于 $k=1$： $w_1(x_1)^1 + w_2(x_2)^1 + w_3(x_3)^1 + w_4(x_4)^1 = -w_1 - \\frac{1}{2}w_2 + 0 \\cdot w_3 + w_4 = 0$\n对于 $k=2$： $w_1(x_1)^2 + w_2(x_2)^2 + w_3(x_3)^2 + w_4(x_4)^2 = w_1 + \\frac{1}{4}w_2 + 0 \\cdot w_3 + w_4 = \\frac{2}{3}$\n对于 $k=3$： $w_1(x_1)^3 + w_2(x_2)^3 + w_3(x_3)^3 + w_4(x_4)^3 = -w_1 - \\frac{1}{8}w_2 + 0 \\cdot w_3 + w_4 = 0$\n\n方程组为：\n1. $w_1 + w_2 + w_3 + w_4 = 2$\n2. $-w_1 - \\frac{1}{2}w_2 + w_4 = 0$\n3. $w_1 + \\frac{1}{4}w_2 + w_4 = \\frac{2}{3}$\n4. $-w_1 - \\frac{1}{8}w_2 + w_4 = 0$\n\n由方程 (2) 和 (4)，我们得到：\n$$ -w_1 - \\frac{1}{2}w_2 + w_4 = -w_1 - \\frac{1}{8}w_2 + w_4 $$\n$$ -\\frac{1}{2}w_2 = -\\frac{1}{8}w_2 $$\n$$ \\left(\\frac{1}{8} - \\frac{1}{2}\\right)w_2 = 0 \\implies -\\frac{3}{8}w_2 = 0 \\implies w_2 = 0 $$\n\n将 $w_2=0$ 代入系统，可将其简化为：\n1. $w_1 + w_3 + w_4 = 2$\n2. $-w_1 + w_4 = 0 \\implies w_1 = w_4$\n3. $w_1 + w_4 = \\frac{2}{3}$\n\n由 (2) 和 (3)，我们将 $w_4=w_1$ 代入 (3)：\n$$ w_1 + w_1 = \\frac{2}{3} \\implies 2w_1 = \\frac{2}{3} \\implies w_1 = \\frac{1}{3} $$\n因为 $w_1=w_4$，我们也有 $w_4 = \\frac{1}{3}$。\n\n最后，我们使用方程 (1) 来求 $w_3$：\n$$ \\frac{1}{3} + w_3 + \\frac{1}{3} = 2 $$\n$$ w_3 + \\frac{2}{3} = 2 \\implies w_3 = 2 - \\frac{2}{3} = \\frac{6-2}{3} = \\frac{4}{3} $$\n\n唯一的权重是 $w_1 = \\frac{1}{3}$，$w_2 = 0$，$w_3 = \\frac{4}{3}$ 和 $w_4 = \\frac{1}{3}$。\n\n问题的第二部分询问是否所有权重都为正。权重集为 $\\{\\frac{1}{3}, 0, \\frac{4}{3}, \\frac{1}{3}\\}$。由于 $w_2 = 0$，并非所有权重都严格为正。它们都是非负的。\n\n问题的第三部分涉及对 DG 方法的影响。在 DG 方法中，对每个单元，都会组装一个质量矩阵 $M$，其元素为 $M_{ij} = \\int_K \\phi_i \\phi_j \\,\\mathrm{d}x$，其中 $\\phi_i$ 是单元 $K$ 上的基函数。对于显式时间步进格式，每一步都需要计算 $M^{-1}u$ 这一项，这使得 $M$ 的求逆成为一个计算瓶颈。\n\n质量集中是一种将 $M$ 近似为一个对角矩阵 $\\tilde{M}$ 的技术，而对角矩阵的求逆是微不足道的。这通常通过选择基函数 $\\phi_i$ 为与一组求积节点 $x_k$ 相关联的拉格朗日多项式（即 $\\phi_i(x_k) = \\delta_{ik}$），然后使用相同的求积法则来近似积分来实现：\n$$ \\tilde{M}_{ij} = \\sum_{k=1}^n w_k \\phi_i(x_k) \\phi_j(x_k) = \\sum_{k=1}^n w_k \\delta_{ik} \\delta_{jk} $$\n（这里，权重 $w_k$ 会乘以从参考单元到物理单元映射的雅可比行列式，这是一个正常数）。这会得到一个对角矩阵，其对角元素为 $\\tilde{M}_{ii} = w_i$。\n\n对于一个半离散系统 $\\frac{du}{dt} = M^{-1}F(u)$，经过质量集中后，其显式时间步进格式变为 $\\frac{du}{dt} = \\tilde{M}^{-1}F(u)$。这意味着第 $i$ 个自由度的更新与 $(\\tilde{M}^{-1})_{ii} = 1/w_i$ 成正比。\n\n权重的符号模式具有关键影响：\n- 如果所有 $w_i  0$，则集中质量矩阵 $\\tilde{M}$ 是对角且正定的。这通常是理想情况，因为它往往能保持原始连续问题的稳定性。\n- 如果任何权重 $w_i  0$，$\\tilde{M}$ 就不是正定的，这会引入不稳定性并导致非物理行为，可能使时间步进格式无条件不稳定。\n- 如果任何权重 $w_i = 0$（如此处的 $w_2=0$），$\\tilde{M}$ 相应的对角元素为零。这使得矩阵 $\\tilde{M}$ 成为奇异矩阵，其逆矩阵不存在。相应自由度的更新将是未定义的，因为它会涉及到除以零。因此，对于需要在显式时间步进中求逆质量矩阵的 DG 方法，该求积法则不适用于质量集中。数值格式将会失败。\n\n最终的数值答案是最小的权重值 $w_{\\min}$。\n$$ w_{\\min} = \\min\\left\\{\\frac{1}{3}, 0, \\frac{4}{3}, \\frac{1}{3}\\right\\} = 0 $$", "answer": "$$\n\\boxed{0}\n$$", "id": "3405819"}, {"introduction": "在求解非线性偏微分方程时，我们经常需要处理依赖于数值解本身的非线性项的积分，这比对已知函数进行积分要复杂得多。本练习将研究一种被称为“混叠误差”的现象，当求积法则的精度不足以精确计算由非线性通量产生的高次多项式时，就会出现这种误差。通过一个计算性测试，你将验证二次非线性项的 $m=2p$ 精度法则的有效性，并观察到它在三次非线性情况下的失效，从而理解为何需要采用“过积分”或“去混叠”策略来确保数值模拟的稳定性和准确性。[@problem_id:3405861]", "problem": "考虑参考区间 $\\left[-1,1\\right]$ 上的一个一维谱方法或间断 Galerkin 单元，并设近似解 $u(x)$ 是一个在单项式基下次数至多为 $p$ 的多项式。重点关注非线性通量函数 $f(u)$ 在该单元上的体积分，这是谱方法和间断 Galerkin 方法中体积项的常见运算。\n\n使用以下基本依据：\n- 一个精度阶为 $m$ 的数值求积法则，对于任意次数至多为 $m$ 的多项式的积分是精确的。\n- 一个次数至多为 $p$ 的多项式 $u(x)$ 与一个多项式非线性 $f(u)=u^q$ 的复合，会产生一个次数至多为 $q\\,p$ 的多项式 $f(u(x))$。\n- 对于在 $\\left[-1,1\\right]$ 上有 $N$ 个节点的 Gauss-Legendre 求积，其精度阶为 $m=2N-1$。\n\n任务：\n1. 从上述核心定义出发，证明如果 $u \\in \\mathbb{P}_p$（次数至多为 $p$ 的多项式空间）且 $f(u)=u^q$，那么体积分 $\\int_{-1}^{1} f(u(x))\\,dx$ 可以被任何精度阶 $m \\ge q\\,p$ 的求积法则精确计算。解释为什么这意味着对于二次非线性 $f(u)=\\tfrac{1}{2}u^2$，$m=2p$ 的精度阶是足够的，但当 $p \\ge 1$ 时，对于三次非线性 $f(u)=u^3$ 则是不足够的，并解释为什么 $m=3p$ 能消除三次非线性情况下的混叠。\n\n2. 基于以上分析，设计一个计算测试，该测试：\n   - 构造特定的多项式 $u(x)=x^p$，其次数恰好为 $p$，对于整数 $q \\ge 1$，$f(u)$ 的次数恰好为 $q\\,p$。\n   - 通过在单项式基中展开 $f(u)$ 并逐项积分，解析地计算精确积分 $I_{q}=\\int_{-1}^{1} f(u(x))\\,dx$（由于积分域对称，只有偶次幂项有贡献）。\n   - 使用 Gauss-Legendre 求积来近似 $I_{q}$，其中节点数 $N$ 的选择是为了通过 $m=2N-1$ 实现目标精度阶 $m$。\n   - 通过将求积近似值与解析值进行比较，报告是否存在混叠。使用 $\\varepsilon=10^{-12}$ 的相对容差来判断相等。\n\n3. 实现下面的测试套件，并按末尾指定的方式汇总布尔结果：\n   - 测试 1 (二次非线性的理想情况)：$p=4$，$q=2$，目标 $m=2p$。如果没有检测到混叠，即求积结果在容差范围内与解析积分一致，则声明测试通过。\n   - 测试 2 (三次非线性的不足情况)：$p=4$，$q=3$，目标 $m=2p$。如果检测到混叠，即求积结果在容差范围内与解析积分不一致，则声明测试通过。\n   - 测试 3 (三次非线性的过积分情况)：$p=4$，$q=3$，目标 $m=3p$。如果没有检测到混叠，则声明测试通过。\n   - 测试 4 (边界次数检查)：$p=2$，$q=3$，目标 $m=2p$。如果检测到混叠，则声明测试通过。\n   - 测试 5 (低次数二次非线性)：$p=2$，$q=2$，目标 $m=2p$。如果没有检测到混叠，则声明测试通过。\n\n实现要求：\n- 您必须通过操作多项式系数来精确计算解析积分：给定 $u(x)=x^p$，在单项式基下使用重复的多项式乘法构造 $f(u)$ 作为单项式多项式，并根据奇数 $k$ 时 $\\int_{-1}^{1} x^k\\,dx = 0$ 和偶数 $k$ 时 $\\int_{-1}^{1} x^k\\,dx = \\dfrac{2}{k+1}$ 进行逐项积分。\n- 您必须通过选择满足 $2N-1 \\ge m$ 的最小整数 $N$ 来实现目标精度阶 $m$，然后使用 $N$ 点 Gauss-Legendre 求积来计算 $f(u)$ 的数值积分。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[result1,result2,result3,result4,result5]`）。\n- 每个结果都应为一个布尔值：“True”表示测试根据上述标准通过，“False”则表示未通过。\n- 此问题不涉及任何物理单位或角度；所有计算都是无量纲的。", "solution": "问题陈述经评估有效。其科学依据扎根于数值分析原理，特别是数值求积和多项式逼近理论。问题提法得当、客观，并包含推导解决方案和实现所需计算测试的全部必要信息。\n\n### 1. 求积精确度的理论分析\n\n问题要求分析在何种条件下，数值求积法则能够精确地计算谱方法或间断 Galerkin 方法中的体积分项 $\\int_{-1}^{1} f(u(x))\\,dx$。\n\n已知条件如下：\n- 积分域为参考区间 $I = [-1, 1]$。\n- 近似解 $u(x)$ 是次数至多为 $p$ 的多项式，记作 $u \\in \\mathbb{P}_p$。\n- 非线性通量函数形式为 $f(u) = u^q$，其中 $q \\ge 1$ 为整数。\n- 精度阶为 $m$ 的数值求积法则能精确积分任何次数至多为 $m$ 的多项式。\n- 具有 $N$ 个节点的 Gauss-Legendre 求积，其精度阶为 $m = 2N-1$。\n\n首先，我们确定被积函数 $f(u(x))$ 的性质。由于 $u(x)$ 是一个次数至多为 $p$ 的多项式，它可以写成 $u(x) = \\sum_{k=0}^{p} c_k x^k$。其复合函数 $f(u(x))$ 则为 $(u(x))^q = (\\sum_{k=0}^{p} c_k x^k)^q$。此表达式中 $x$ 的最高次幂来自于 $u(x)$ 中 $x$ 的最高次幂，即 $x^p$。因此，$f(u(x))$展开式中的最高次项是 $(c_p x^p)^q = c_p^q x^{pq}$。这意味着 $f(u(x))$ 是一个次数至多为 $p \\cdot q$ 的多项式。\n\n根据精度阶的定义，如果 $g(x)$ 是一个多项式且其次数 $\\text{deg}(g)$ 满足 $\\text{deg}(g) \\le m$，那么一个求积法则就能精确计算积分 $\\int_{-1}^{1} g(x)\\,dx$。在我们的例子中，被积函数是 $g(x) = f(u(x))$，它是一个次数至多为 $pq$ 的多项式。因此，为了实现精确积分，我们必须选择一个精度阶为 $m$ 的求积法则，使得 $m \\ge pq$。\n\n现在，我们将此一般性结论应用于提到的具体情况：\n\n- **二次非线性 ($q=2$):** 通量为 $f(u) = u^2$（或 $\\frac{1}{2}u^2$，常数因子不影响多项式次数）。被积函数 $f(u(x))$ 是一个次数至多为 $2p$ 的多项式。如果我们使用一个目标精度阶为 $m=2p$ 的求积法则，那么精确性条件 $m \\ge 2p$ 得到满足。这意味着精度阶为 $m=2p$ 的求积法则足以精确计算该积分，不会产生混叠误差。\n\n- **三次非线性 ($q=3$):** 通量为 $f(u) = u^3$。被积函数 $f(u(x))$ 是一个次数至多为 $3p$ 的多项式。如果我们使用一个目标精度阶为 $m=2p$ 的求积法则，那么对于任何 $p \\ge 1$，精确性条件 $m \\ge 3p$ 都*不*满足，因为 $2p  3p$。该求积法则的能力不足以精确积分由三次非线性产生的高次多项式。这种无法解析多项式中最高次项的情况会导致混叠误差，即这些高次项的贡献被错误地映射到结果中，从而导致数值积分不准确。\n\n- **消除三次情况的混叠：** 为了消除三次非线性带来的混叠误差，必须使用满足精确性条件 $m \\ge 3p$ 的求积法则。通过选择一个精度阶为 $m=3p$ 的法则，我们确保了积分被精确计算。这种技术通常被称为过积分或去混叠。\n\n### 2. 计算测试的设计\n\n计算测试旨在验证上述理论结论。\n\n**a. 多项式构造与解析积分：**\n我们选择特定多项式 $u(x) = x^p$，其次数恰好为 $p$。通量函数 $f(u) = u^q$ 于是变为 $f(u(x)) = (x^p)^q = x^{pq}$。这是一个次数恰好为 $pq$ 的单项式。问题要求通过展开 $f(u)$ 并逐项积分来计算解析积分。在这个简化的情况下，只有一项，即 $x^{pq}$。\n\n精确积分 $I_{q,p} = \\int_{-1}^{1} x^{pq}\\,dx$ 使用在对称区间上对 $x$ 的幂进行积分的标准公式计算：\n$$\nI_{q,p} = \\int_{-1}^{1} x^{k}\\,dx = \\begin{cases} 0  \\text{if } k \\text{ is odd} \\\\ \\frac{2}{k+1}  \\text{if } k \\text{ is even} \\end{cases}\n$$\n这里，$k=pq$。因此，如果 $pq$ 是偶数，精确的解析积分是 $I_{q,p} = \\frac{2}{pq+1}$；如果 $pq$ 是奇数，则 $I_{q,p} = 0$。对于所有指定的测试用例，$p$ 和 $q$ 的取值使得 $pq$ 为偶数，因此积分将非零。\n\n**b. 数值积分：**\n数值积分使用 Gauss-Legendre 求积计算。给定一个目标精度阶 $m$，我们需要找到实现此精度的最小求积节点数 $N$。关系式为 $2N-1 \\ge m$。解出 $N$ 得 $N \\ge \\frac{m+1}{2}$。由于 $N$ 必须是整数，我们选择 $N = \\lceil \\frac{m+1}{2} \\rceil$。在整数算术中，这可以计算为 $N = (m+2)//2$。\n\n确定 $N$ 后，我们获得 $N$ 个 Gauss-Legendre 节点 $\\{x_i\\}_{i=1}^N$ 和权重 $\\{w_i\\}_{i=1}^N$。积分的数值近似值则为：\n$$\n\\tilde{I}_{q,p} = \\sum_{i=1}^{N} w_i f(u(x_i)) = \\sum_{i=1}^{N} w_i (x_i)^{pq}\n$$\n\n**c. 混叠检测：**\n如果数值积分 $\\tilde{I}_{q,p}$ 与解析积分 $I_{q,p}$ 不匹配，则存在混叠。我们使用 $\\varepsilon = 10^{-12}$ 的相对容差来比较这些值。如果满足以下条件，则检测到混叠：\n$$\n\\frac{|I_{q,p} - \\tilde{I}_{q,p}|}{|I_{q,p}|} \\ge \\varepsilon\n$$\n这等价于检查 $I_{q,p}$ 和 $\\tilde{I}_{q,p}$ 是否在给定的相对容差内不“接近”。\n\n### 3. 测试用例实现\n\n对于五个测试用例中的每一个，实现将遵循上述逻辑。一个辅助函数将对给定的参数集 $(p, q, m_{\\text{target}})$ 执行计算，并返回一个布尔值，指示是否满足测试的特定条件（例如，“检测到混叠”）。\n\n- **测试 1 ($p=4, q=2, m=2p=8$):** 被积函数次数为 $pq=8$。目标精度为 $m=8$。该法则应是精确的 ($m \\ge pq$)。如果未检测到混叠，则测试通过。\n- **测试 2 ($p=4, q=3, m=2p=8$):** 被积函数次数为 $pq=12$。目标精度为 $m=8$。该法则不充分 ($m  pq$)。如果检测到混叠，则测试通过。\n- **测试 3 ($p=4, q=3, m=3p=12$):** 被积函数次数为 $pq=12$。目标精度为 $m=12$。该法则应是精确的 ($m \\ge pq$)。如果未检测到混叠，则测试通过。\n- **测试 4 ($p=2, q=3, m=2p=4$):** 被积函数次数为 $pq=6$。目标精度为 $m=4$。该法则不充分 ($m  pq$)。如果检测到混叠，则测试通过。\n- **测试 5 ($p=2, q=2, m=2p=4$):** 被积函数次数为 $pq=4$。目标精度为 $m=4$。该法则应是精确的 ($m \\ge pq$)。如果未检测到混叠，则测试通过。\n\n最终程序将执行这些测试，并将表示通过/失败的布尔结果格式化为逗号分隔的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for quadrature aliasing and print results.\n    \"\"\"\n    \n    # Test cases defined as (p, q, m_name, m_func, expected_aliasing) tuples.\n    # m_name is for clarity, m_func calculates target m from p.\n    # expected_aliasing: True if the test passes when aliasing is detected.\n    test_cases = [\n        # Test 1: p=4, q=2, m=2p. Should be exact. Pass if no aliasing.\n        {'p': 4, 'q': 2, 'm_target': 2 * 4, 'pass_if_aliasing_detected': False},\n        # Test 2: p=4, q=3, m=2p. Insufficient. Pass if aliasing.\n        {'p': 4, 'q': 3, 'm_target': 2 * 4, 'pass_if_aliasing_detected': True},\n        # Test 3: p=4, q=3, m=3p. Sufficient. Pass if no aliasing.\n        {'p': 4, 'q': 3, 'm_target': 3 * 4, 'pass_if_aliasing_detected': False},\n        # Test 4: p=2, q=3, m=2p. Insufficient. Pass if aliasing.\n        {'p': 2, 'q': 3, 'm_target': 2 * 2, 'pass_if_aliasing_detected': True},\n        # Test 5: p=2, q=2, m=2p. Sufficient. Pass if no aliasing.\n        {'p': 2, 'q': 2, 'm_target': 2 * 2, 'pass_if_aliasing_detected': False},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        p = case['p']\n        q = case['q']\n        m_target = case['m_target']\n        pass_if_aliasing_detected = case['pass_if_aliasing_detected']\n\n        # 1. ANALYTIC INTEGRAL\n        # The integrand is f(u(x)) = (x^p)^q = x^(p*q).\n        integrand_degree = p * q\n        \n        # Analytic integral I = integral from -1 to 1 of x^k dx.\n        # I = 2/(k+1) if k is even, I = 0 if k is odd.\n        # For all test cases, p*q is even.\n        if integrand_degree % 2 != 0:\n            analytic_integral = 0.0\n        else:\n            analytic_integral = 2.0 / (integrand_degree + 1)\n            \n        # 2. NUMERICAL INTEGRAL\n        # Determine number of quadrature points N for target precision m.\n        # The degree of precision for N-point Gauss-Legendre is 2N-1.\n        # We need 2N-1 >= m_target => N >= (m_target + 1)/2.\n        # As N must be an integer, N = ceil((m_target + 1)/2).\n        num_points_N = int(np.ceil((m_target + 1) / 2.0))\n\n        # Get Gauss-Legendre nodes and weights.\n        nodes, weights = roots_legendre(num_points_N)\n        \n        # Evaluate the integrand at the nodes.\n        integrand_values = nodes ** integrand_degree\n        \n        # Compute the numerical integral by summing weighted values.\n        numeric_integral = np.sum(weights * integrand_values)\n\n        # 3. ALIASING DETECTION AND TEST VERDICT\n        # Aliasing is detected if the numerical result is not close to the analytic one.\n        # Using a relative tolerance of 1e-12 as specified.\n        # atol is a failsafe for cases where the analytic integral is zero.\n        is_exact = np.isclose(analytic_integral, numeric_integral, rtol=1e-12, atol=1e-15)\n        aliasing_detected = not is_exact\n        \n        # The test passes if the aliasing detection matches the expectation.\n        test_passes = (aliasing_detected == pass_if_aliasing_detected)\n        results.append(test_passes)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3405861"}]}