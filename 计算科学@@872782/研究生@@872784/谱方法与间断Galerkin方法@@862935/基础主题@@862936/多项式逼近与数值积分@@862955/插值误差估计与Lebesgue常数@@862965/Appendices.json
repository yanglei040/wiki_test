{"hands_on_practices": [{"introduction": "理论的价值在于其能够指导实践。本节的第一个练习将抽象的插值误差理论应用到一个具体的计算问题中。通过为一个低阶谱元显式计算由弯曲几何引起的混叠误差以及相应的勒贝格常数，您将亲手体验到勒贝格常数是如何量化并放大几何表示不精确所带来的误差的。[@problem_id:3392355]", "problem": "考虑在参考区间 $[-1,1]$ 上的一个一维曲线谱元，其光滑、保向的映射 $x(\\xi)$ 由 $x(\\xi) = \\xi + \\alpha \\,\\xi^{4}$ 给出，其中 $\\alpha \\in \\mathbb{R}$ 满足 $|\\alpha|  1/4$ 以确保雅可比为正。令雅可比（度量项）为 $J(\\xi) = \\dfrac{dx}{d\\xi} = 1 + 4\\alpha\\,\\xi^{3}$。假设在 Legendre–Gauss–Lobatto (LGL) 节点上使用 $p=2$ 次的节点多项式逼近。定义 Lebesgue 常数 $\\Lambda_{p}$ 为与 $p$ 次 LGL 节点相关的 Lebesgue 函数的 $L^{\\infty}$ 范数，并定义几何混叠界为 $E_{\\mathrm{geo}} := \\|J - I_{p}J\\|_{L^{\\infty}([-1,1])}$，其中 $I_{p}$ 表示 LGL 节点上的 $p$ 次 Lagrange 插值算子。\n\n在一个间断 Galerkin (DG) 或节点谱配置格式中，该格式在微分之前将节点场与插值的度量项相乘，由几何引起的主阶节点场扰动可由乘积 $\\Lambda_{p}\\,E_{\\mathrm{geo}}$ 作为上界。在 LGL 节点上，使用 $p=2$ 次，并仅利用上述定义以及多项式在 $[-1,1]$ 上的基本性质，计算\n$$\nC(\\alpha) \\;:=\\; \\Lambda_{2}\\,\\big\\|J - I_{2}J\\big\\|_{L^{\\infty}([-1,1])}\n$$\n作为 $\\alpha$ 的显式函数的闭式表达式。\n\n你的最终答案必须是 $C(\\alpha)$ 的一个不含不等号的单一简化解析表达式。无需四舍五入。最终答案请表示为无单位形式。", "solution": "该问题要求计算量 $C(\\alpha) = \\Lambda_{2} \\|J - I_{2}J\\|_{L^{\\infty}([-1,1])}$，其中 $J(\\xi) = 1 + 4\\alpha\\xi^3$ 是坐标变换的雅可比，$I_{2}$ 是 Legendre–Gauss–Lobatto (LGL) 节点上的 2 次 Lagrange 插值算子，$\\Lambda_{2}$ 是相应的 Lebesgue 常数。\n\n计算可分为两个主要部分：确定 Lebesgue 常数 $\\Lambda_{2}$，以及计算插值误差范数 $\\|J - I_{2}J\\|_{L^{\\infty}([-1,1])}$。\n\n第1部分：计算 Lebesgue 常数 $\\Lambda_{2}$。\n\n$p$ 次的 LGL 节点是方程 $(1-\\xi^2)P'_{p}(\\xi) = 0$ 的根，其中 $P_p(\\xi)$ 是 $p$ 次 Legendre 多项式。对于 $p=2$，Legendre 多项式为 $P_2(\\xi) = \\frac{1}{2}(3\\xi^2 - 1)$，其导数为 $P'_2(\\xi) = 3\\xi$。$p=2$ 时的 LGL 节点是方程 $(1-\\xi^2)(3\\xi) = 0$ 的根，即 $\\xi_0 = -1$，$\\xi_1 = 0$ 和 $\\xi_2 = 1$。\n\n这些节点的 Lagrange 基多项式 $l_j(\\xi)$ 为：\n$l_0(\\xi) = \\frac{(\\xi - \\xi_1)(\\xi - \\xi_2)}{(\\xi_0 - \\xi_1)(\\xi_0 - \\xi_2)} = \\frac{(\\xi - 0)(\\xi - 1)}{(-1 - 0)(-1 - 1)} = \\frac{\\xi(\\xi-1)}{2} = \\frac{1}{2}(\\xi^2 - \\xi)$。\n$l_1(\\xi) = \\frac{(\\xi - \\xi_0)(\\xi - \\xi_2)}{(\\xi_1 - \\xi_0)(\\xi_1 - \\xi_2)} = \\frac{(\\xi - (-1))(\\xi - 1)}{(0 - (-1))(0 - 1)} = \\frac{(\\xi+1)(\\xi-1)}{-1} = 1 - \\xi^2$。\n$l_2(\\xi) = \\frac{(\\xi - \\xi_0)(\\xi - \\xi_1)}{(\\xi_2 - \\xi_0)(\\xi_2 - \\xi_1)} = \\frac{(\\xi - (-1))(\\xi - 0)}{(1 - (-1))(1 - 0)} = \\frac{\\xi(\\xi+1)}{2} = \\frac{1}{2}(\\xi^2 + \\xi)$。\n\nLebesgue 函数定义为 $L_2(\\xi) = \\sum_{j=0}^{2} |l_j(\\xi)| = |\\frac{1}{2}(\\xi^2 - \\xi)| + |1 - \\xi^2| + |\\frac{1}{2}(\\xi^2 + \\xi)|$。\nLebesgue 常数是 $\\Lambda_2 = \\max_{\\xi \\in [-1,1]} L_2(\\xi)$。\n在区间 $[-1,1]$ 上，项 $1-\\xi^2$ 总是非负的。我们通过划分定义域来分析该函数。\n\n对于 $\\xi \\in [0,1]$：\n$\\xi^2 - \\xi = \\xi(\\xi-1) \\le 0$，所以 $|\\xi^2 - \\xi| = -(\\xi^2 - \\xi) = \\xi - \\xi^2$。\n$\\xi^2 + \\xi = \\xi(\\xi+1) \\ge 0$，所以 $|\\xi^2 + \\xi| = \\xi^2 + \\xi$。\n$L_2(\\xi) = \\frac{1}{2}(\\xi - \\xi^2) + (1 - \\xi^2) + \\frac{1}{2}(\\xi^2 + \\xi) = \\frac{1}{2}\\xi - \\frac{1}{2}\\xi^2 + 1 - \\xi^2 + \\frac{1}{2}\\xi^2 + \\frac{1}{2}\\xi = 1 + \\xi - \\xi^2$。\n为了求 $f(\\xi) = 1 + \\xi - \\xi^2$ 在 $[0,1]$ 上的最大值，我们计算其导数：$f'(\\xi) = 1 - 2\\xi$。令 $f'(\\xi) = 0$ 得到 $\\xi = 1/2$。在此临界点的值为 $f(1/2) = 1 + 1/2 - (1/2)^2 = 3/2 - 1/4 = 5/4$。在端点处，$f(0) = 1$ 且 $f(1) = 1$。在 $[0,1]$ 上的最大值为 $5/4$。\n\n对于 $\\xi \\in [-1,0]$：\n$\\xi^2 - \\xi = \\xi(\\xi-1) \\ge 0$，所以 $|\\xi^2 - \\xi| = \\xi^2 - \\xi$。\n$\\xi^2 + \\xi = \\xi(\\xi+1) \\le 0$，所以 $|\\xi^2 + \\xi| = -(\\xi^2 + \\xi)$。\n$L_2(\\xi) = \\frac{1}{2}(\\xi^2 - \\xi) + (1 - \\xi^2) - \\frac{1}{2}(\\xi^2 + \\xi) = \\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi + 1 - \\xi^2 - \\frac{1}{2}\\xi^2 - \\frac{1}{2}\\xi = 1 - \\xi - \\xi^2$。\n为了求 $g(\\xi) = 1 - \\xi - \\xi^2$ 在 $[-1,0]$ 上的最大值，我们计算其导数：$g'(\\xi) = -1 - 2\\xi$。令 $g'(\\xi) = 0$ 得到 $\\xi = -1/2$。该值为 $g(-1/2) = 1 - (-1/2) - (-1/2)^2 = 1 + 1/2 - 1/4 = 5/4$。在端点处，$g(-1) = 1$ 且 $g(0) = 1$。在 $[-1,0]$ 上的最大值为 $5/4$。\n\n结合两个区间的结果，$L_2(\\xi)$ 在 $[-1,1]$ 上的最大值为 $\\Lambda_2 = 5/4$。\n\n第2部分：计算插值误差范数 $\\|J - I_{2}J\\|_{L^{\\infty}([-1,1])}$。\n\n被插值的函数是雅可比 $J(\\xi) = 1 + 4\\alpha\\xi^3$。算子 $I_2$ 通过在节点 $\\xi_0 = -1$, $\\xi_1 = 0$, $\\xi_2 = 1$ 上进行插值，将 $J(\\xi)$ 投影到次数至多为 2 的多项式空间上。\n$J(\\xi)$ 在这些节点上的值为：\n$J(-1) = 1 + 4\\alpha(-1)^3 = 1 - 4\\alpha$。\n$J(0) = 1 + 4\\alpha(0)^3 = 1$。\n$J(1) = 1 + 4\\alpha(1)^3 = 1 + 4\\alpha$。\n\n插值多项式 $I_2J(\\xi)$ 可以使用 Lagrange 基来构造：\n$I_2J(\\xi) = J(-1)l_0(\\xi) + J(0)l_1(\\xi) + J(1)l_2(\\xi)$\n$I_2J(\\xi) = (1 - 4\\alpha)\\frac{\\xi^2 - \\xi}{2} + (1)(1 - \\xi^2) + (1 + 4\\alpha)\\frac{\\xi^2 + \\xi}{2}$\n$I_2J(\\xi) = \\frac{1}{2}(\\xi^2 - \\xi - 4\\alpha\\xi^2 + 4\\alpha\\xi) + 1 - \\xi^2 + \\frac{1}{2}(\\xi^2 + \\xi + 4\\alpha\\xi^2 + 4\\alpha\\xi)$\n$I_2J(\\xi) = (\\frac{1}{2} - 1 + \\frac{1}{2})\\xi^2 + (-\\frac{1}{2} + \\frac{1}{2})\\xi + (\\frac{-4\\alpha}{2} + \\frac{4\\alpha}{2})\\xi^2 + (\\frac{4\\alpha}{2} + \\frac{4\\alpha}{2})\\xi + 1$\n$I_2J(\\xi) = 0 \\cdot \\xi^2 + 0 \\cdot \\xi + 0 \\cdot \\xi^2 + 4\\alpha\\xi + 1 = 1 + 4\\alpha\\xi$。\n\n插值误差为 $E(\\xi) = J(\\xi) - I_2J(\\xi) = (1 + 4\\alpha\\xi^3) - (1 + 4\\alpha\\xi) = 4\\alpha(\\xi^3 - \\xi)$。\n我们必须求这个误差在 $[-1,1]$ 上的 $L^{\\infty}$ 范数：\n$\\|J - I_{2}J\\|_{L^{\\infty}([-1,1])} = \\max_{\\xi \\in [-1,1]} |4\\alpha(\\xi^3 - \\xi)| = |4\\alpha| \\max_{\\xi \\in [-1,1]} |\\xi^3 - \\xi|$。\n\n令 $h(\\xi) = \\xi^3 - \\xi$。为了求其在 $[-1,1]$ 上的最大绝对值，我们求其临界点：$h'(\\xi) = 3\\xi^2 - 1$。令 $h'(\\xi)=0$ 得到 $\\xi^2 = 1/3$，所以 $\\xi = \\pm 1/\\sqrt{3}$。\n我们在这些点和端点 $\\pm 1$ 处计算 $|h(\\xi)|$ 的值：\n$|h(1)| = |1^3 - 1| = 0$。\n$|h(-1)| = |(-1)^3 - (-1)| = 0$。\n$|h(1/\\sqrt{3})| = |(1/\\sqrt{3})^3 - 1/\\sqrt{3}| = |\\frac{1}{3\\sqrt{3}} - \\frac{1}{\\sqrt{3}}| = |\\frac{1-3}{3\\sqrt{3}}| = \\frac{2}{3\\sqrt{3}}$。\n$|h(-1/\\sqrt{3})| = |(-1/\\sqrt{3})^3 - (-1/\\sqrt{3})| = |-\\frac{1}{3\\sqrt{3}} + \\frac{1}{\\sqrt{3}}| = |\\frac{-1+3}{3\\sqrt{3}}| = \\frac{2}{3\\sqrt{3}}$。\n$|\\xi^3 - \\xi|$ 在 $[-1,1]$ 上的最大值为 $2/(3\\sqrt{3})$。\n\n因此，几何混叠界为：\n$E_{\\mathrm{geo}} = \\|J - I_2J\\|_{L^{\\infty}([-1,1])} = |4\\alpha| \\frac{2}{3\\sqrt{3}} = \\frac{8|\\alpha|}{3\\sqrt{3}}$。\n\n第3部分：$C(\\alpha)$ 的最终计算。\n\n现在我们将第1部分和第2部分的结果结合起来：\n$C(\\alpha) = \\Lambda_2 \\cdot E_{\\mathrm{geo}} = \\frac{5}{4} \\cdot \\frac{8|\\alpha|}{3\\sqrt{3}} = \\frac{40|\\alpha|}{12\\sqrt{3}} = \\frac{10|\\alpha|}{3\\sqrt{3}}$。\n为了使分母有理化，我们将分子和分母同乘以 $\\sqrt{3}$：\n$C(\\alpha) = \\frac{10|\\alpha|}{3\\sqrt{3}} \\cdot \\frac{\\sqrt{3}}{\\sqrt{3}} = \\frac{10\\sqrt{3}|\\alpha|}{9}$。\n\n这是 $C(\\alpha)$ 的最终闭式表达式。约束 $|\\alpha|  1/4$ 确保了映射是良定义的，但它不改变此表达式的形式。", "answer": "$$\n\\boxed{\\frac{10\\sqrt{3}}{9}|\\alpha|}\n$$", "id": "3392355"}, {"introduction": "在实际的科学计算中，误差的来源是多种多样的，不仅包括几何近似，还可能包括谱系数中的噪声或截断。本练习引导您从第一性原理出发，推导一个全面的前向误差界，它将谱系数的扰动、最佳逼近误差和勒贝格常数联系在一起。这个练习旨在深化您对勒贝格常数在谱方法稳定性分析中扮演核心角色的理解。[@problem_id:3392296]", "problem": "考虑一个实值函数 $f:[-1,1]\\to\\mathbb{R}$ 及其在勒让德多项式基 $\\{P_k(x)\\}_{k=0}^{p}$ 中的 $p$ 阶模态表示，其中计算得到的模态系数 $\\tilde{c}_k$ 是理想系数 $c_k$ 的扰动，满足 $\\tilde{c}_k=c_k+\\delta c_k$。令 $\\{\\xi_j\\}_{j=0}^{p}$ 表示 $[-1,1]$ 上的勒让德-高斯-洛巴托 (LGL) 节点，并令 $\\{l_j(x)\\}_{j=0}^{p}$ 表示相关的拉格朗日基多项式。将 LGL 插值的勒贝格常数 $\\Lambda_p$ 定义为 $\\Lambda_p:=\\sup_{x\\in[-1,1]}\\sum_{j=0}^{p}|l_j(x)|$，它是从节点数据（在一致范数下）到插值多项式（在一致范数下）的 $p$ 阶插值映射的算子范数。假设模态到节点的转换是通过在 LGL 节点上计算扰动后的多项式 $\\tilde{p}(x):=\\sum_{k=0}^{p}\\tilde{c}_k P_k(x)$ 以获得 $\\tilde{y}_j:=\\tilde{p}(\\xi_j)$ 来执行的，并且点态计算是使用节点向量 $(\\tilde{y}_j)_{j=0}^{p}$ 通过重心拉格朗日公式进行的。令 $E_p(f):=\\inf_{q\\in\\mathbb{P}_p}\\|f-q\\|_{\\infty}$ 表示用次数至多为 $p$ 的多项式对 $f$ 进行一致最佳逼近的误差。\n\n从基本原理和上述定义出发，推导一个解析上界，用于衡量通过由扰动后的模态系数构建的重心插值多项式来计算 $f(\\xi_i)$ 的相对前向误差，即量\n$$\n\\mathcal{R}_i:=\\frac{|I_p[\\tilde{y}](\\xi_i)-f(\\xi_i)|}{|f(\\xi_i)|},\n$$\n其中 $I_p[\\tilde{y}]$ 是通过点 $(\\xi_j,\\tilde{y}_j)$ 的 $p$ 阶拉格朗日插值多项式，该上界需用 $\\Lambda_p$、系数扰动 $(\\delta c_k)_{k=0}^{p}$ 和 $E_p(f)$ 明确表示。你的上界必须对每个节点索引 $i\\in\\{0,1,\\dots,p\\}$ 都有效，并且除了 $[-1,1]$ 上的勒让德多项式界之外，不得假定任何特殊的代数结构。此外，请提出一个考虑稳定性的模态滤波器 $\\sigma_k\\in[0,1]$（以乘法方式应用于模态表示），以减小高阶系数扰动对所推导上界的影响。滤波器的设计应由你的上界来证明其合理性，并应明确指出 $\\Lambda_p$ 和 $p$ 是如何影响 $\\sigma_k$ 的选择的。\n\n将你推导的最终上界表示为单个闭式解析表达式。不需要进行数值计算，也无需四舍五入。如果出现角度，应以弧度为单位。最终上界中不应包含任何物理单位。", "solution": "该问题要求为在勒让德-高斯-洛巴托 (LGL) 节点上计算函数 $f(x)$ 时的相对前向误差给出一个上界，其中计算是使用由扰动后的模态系数构建的多项式插值进行的。问题还要求设计一个模态滤波器。\n\n### 第一步：问题验证\n\n**提取已知条件：**\n- 一个实值函数 $f:[-1,1]\\to\\mathbb{R}$。\n- 次数至多为 $p$ 的多项式空间（记为 $\\mathbb{P}_p$）的勒让德多项式基 $\\{P_k(x)\\}_{k=0}^{p}$。\n- 理想模态系数 $c_k$ 和扰动后的系数 $\\tilde{c}_k=c_k+\\delta c_k$。\n- 扰动后的多项式表示：$\\tilde{p}(x):=\\sum_{k=0}^{p}\\tilde{c}_k P_k(x)$。\n- $[-1,1]$ 上的 LGL 节点 $\\{\\xi_j\\}_{j=0}^{p}$。\n- 与 LGL 节点相关的拉格朗日基多项式 $\\{l_j(x)\\}_{j=0}^{p}$。\n- 勒贝格常数：$\\Lambda_p:=\\sup_{x\\in[-1,1]}\\sum_{j=0}^{p}|l_j(x)|$。这是一致范数下插值算子 $I_p: C[-1,1] \\to \\mathbb{P}_p$ 的范数。\n- 由扰动系数得到的节点值：$\\tilde{y}_j:=\\tilde{p}(\\xi_j)$。\n- 插值多项式 $I_p[\\tilde{y}]$ 是通过点 $(\\xi_j,\\tilde{y}_j)$ 的 $p$ 阶拉格朗日多项式。根据多项式插值的唯一性，且由于 $\\tilde{p}(x)$ 是一个通过这些点的次数至多为 $p$ 的多项式，我们有 $I_p[\\tilde{y}](x) \\equiv \\tilde{p}(x)$。\n- 一致最佳逼近误差：$E_p(f):=\\inf_{q\\in\\mathbb{P}_p}\\|f-q\\|_{\\infty}$，其中 $\\|\\cdot\\|_{\\infty}$ 是 $[-1,1]$ 上的上确界范数。\n- 需要界定的量是在 LGL 节点 $\\xi_i$ 处的相对误差：$\\mathcal{R}_i:=\\frac{|I_p[\\tilde{y}](\\xi_i)-f(\\xi_i)|}{|f(\\xi_i)|}$，其中 $i\\in\\{0,1,\\dots,p\\}$。\n\n**验证：**\n该问题在数值分析领域，特别是在谱方法的误差分析中，具有坚实的数学和科学基础。所有使用的术语（$f$, $P_k$, $c_k$, $\\Lambda_p$, $E_p(f)$ 等）都是逼近论中的标准定义。该设定描述了一个常见的计算场景：一个通过其谱系数（可能包含误差）已知的函数需要被求值。任务是推导一个解析误差上界，这是数值分析中的标准步骤。该问题是自洽的、客观的，并且不违反任何科学原理或包含逻辑矛盾，前提是对“理想系数”做出合理的解释。一个关键步骤是解释“理想系数”$c_k$ 的性质。在计算背景下，能够得出一个包含所有指定项的有意义上界的最一致的解释是，“理想多项式”$p^*(x) = \\sum_{k=0}^p c_k P_k(x)$ 是在 LGL 节点上插值真实函数 $f(x)$ 的多项式，即 $p^*(x) = I_p[f](x)$。任何其他解释（例如，$p^*$ 是 L2 投影或最佳一致逼近）都会导致上界中缺少所需项（$\\Lambda_p$, $E_p(f)$）或导致循环论证。在此解释下，该问题是有效且适定的。\n\n### 第二步：误差上界的推导\n\n需要界定的量是 $\\mathcal{R}_i$ 的分子，即节点 $\\xi_i$ 处的绝对误差，我们称之为 $\\mathcal{E}_i$：\n$$\n\\mathcal{E}_i = |I_p[\\tilde{y}](\\xi_i) - f(\\xi_i)|\n$$\n如前所述，$I_p[\\tilde{y}](x) \\equiv \\tilde{p}(x)$，因此 $I_p[\\tilde{y}](\\xi_i) = \\tilde{p}(\\xi_i)$。在特定节点 $\\xi_i$ 处的误差受整个区间 $[-1,1]$ 上的最大误差的限制：\n$$\n\\mathcal{E}_i \\le \\sup_{x \\in [-1,1]} |\\tilde{p}(x) - f(x)| = \\|\\tilde{p} - f\\|_{\\infty}\n$$\n我们现在推导这个一致误差 $\\|\\tilde{p} - f\\|_{\\infty}$ 的一个上界。我们使用三角不等式，并引入真实函数的插值多项式 $I_p[f](x)$ 作为一个中间量：\n$$\n\\|\\tilde{p} - f\\|_{\\infty} = \\|\\tilde{p}(x) - I_p[f](x) + I_p[f](x) - f(x)\\|_{\\infty} \\le \\|\\tilde{p} - I_p[f]\\|_{\\infty} + \\|I_p[f] - f\\|_{\\infty}\n$$\n右侧的两项分别对应于系数扰动引起的传播误差和该方法固有的插值误差。\n\n**1. 界定插值误差 $\\|I_p[f] - f\\|_{\\infty}$：**\n这是逼近论中的一个标准结果。多项式插值的一致误差由最佳逼近误差 $E_p(f)$ 和勒贝格常数 $\\Lambda_p$ 界定：\n$$\n\\|I_p[f] - f\\|_{\\infty} \\le (1 + \\Lambda_p) E_p(f)\n$$\n\n**2. 界定传播误差 $\\|\\tilde{p} - I_p[f]\\|_{\\infty}$：**\n我们来分析传播误差 $\\|\\tilde{p} - I_p[f]\\|_{\\infty}$。由于 $\\tilde{p}(x)$ 是对节点值 $\\tilde{y}_j$ 的插值，而 $I_p[f](x)$ 是对节点值 $f(\\xi_j)$ 的插值，根据插值算子的线性性质，它们的差就是对节点误差 $\\delta y_j = \\tilde{p}(\\xi_j) - f(\\xi_j)$ 的插值。我们称此误差多项式为 $I_p[\\delta y](x)$。\n$$\n\\|\\tilde{p} - I_p[f]\\|_{\\infty} = \\|I_p[\\delta y]\\|_{\\infty}\n$$\n勒贝格常数 $\\Lambda_p$ 界定了从最大节点误差到最大插值多项式值的放大。因此，\n$$\n\\|I_p[\\delta y]\\|_{\\infty} \\le \\Lambda_p \\max_{j=0,\\dots,p} |\\delta y_j| = \\Lambda_p \\max_{j=0,\\dots,p} |\\tilde{p}(\\xi_j) - f(\\xi_j)|\n$$\n现在我们必须界定节点处的最大误差 $\\max_j |\\tilde{p}(\\xi_j) - f(\\xi_j)|$。如在验证阶段所论证的，我们将“理想系数” $c_k$ 解释为多项式 $p^*(x) = I_p[f](x)$ 的系数。在此解释下，对于所有节点 $j \\in \\{0, \\dots, p\\}$，有 $p^*(\\xi_j) = I_p[f](\\xi_j) = f(\\xi_j)$。\n扰动后的多项式为 $\\tilde{p}(x) = \\sum_{k=0}^p (c_k + \\delta c_k) P_k(x) = p^*(x) + \\sum_{k=0}^p \\delta c_k P_k(x)$。那么在节点 $\\xi_j$ 处的误差为：\n$$\n|\\tilde{p}(\\xi_j) - f(\\xi_j)| = |\\tilde{p}(\\xi_j) - p^*(\\xi_j)| = \\left| \\sum_{k=0}^{p} \\delta c_k P_k(\\xi_j) \\right|\n$$\n使用三角不等式以及性质 $|P_k(x)| \\le 1$ 对所有 $x \\in [-1,1]$ 成立：\n$$\n|\\tilde{p}(\\xi_j) - f(\\xi_j)| \\le \\sum_{k=0}^{p} |\\delta c_k| |P_k(\\xi_j)| \\le \\sum_{k=0}^{p} |\\delta c_k|\n$$\n这个界对所有节点 $j$ 都是一致的。因此，$\\max_j |\\tilde{p}(\\xi_j) - f(\\xi_j)| \\le \\sum_{k=0}^{p} |\\delta c_k|$。将其代回到传播误差的上界中：\n$$\n\\|\\tilde{p} - I_p[f]\\|_{\\infty} \\le \\Lambda_p \\left( \\sum_{k=0}^{p} |\\delta c_k| \\right)\n$$\n\n**3. 组合上界：**\n组合两个误差分量的上界，我们得到一致绝对误差的上界：\n$$\n\\|\\tilde{p} - f\\|_{\\infty} \\le \\Lambda_p \\sum_{k=0}^{p} |\\delta c_k| + (1 + \\Lambda_p) E_p(f)\n$$\n由于 $\\mathcal{E}_i \\le \\|\\tilde{p} - f\\|_{\\infty}$，这可作为任意节点 $\\xi_i$ 处绝对误差的一个上界。因此，相对误差 $\\mathcal{R}_i$ 的界为：\n$$\n\\mathcal{R}_i = \\frac{|\\tilde{p}(\\xi_i) - f(\\xi_i)|}{|f(\\xi_i)|} \\le \\frac{1}{|f(\\xi_i)|} \\left( \\Lambda_p \\sum_{k=0}^{p} |\\delta c_k| + (1 + \\Lambda_p) E_p(f) \\right)\n$$\n\n### 第三步：考虑稳定性的模态滤波器设计\n\n推导出的误差界有两个主要组成部分：一个来自系数扰动 $\\Lambda_p \\sum |\\delta c_k|$，另一个来自 $\\mathbb{P}_p$ 的基本逼近能力 $(1+\\Lambda_p)E_p(f)$。勒贝格常数 $\\Lambda_p$ 对来自系数的噪声起到放大作用。对于许多问题，扰动 $\\delta c_k$ 对于高阶模态（较大的 $k$）更为显著。模态滤波器 $\\sigma_k$ 的目的是减小这种影响。\n\n我们对扰动后的系数应用一个滤波器 $\\sigma_k \\in [0,1]$，得到新的系数 $\\hat{c}_k = \\sigma_k \\tilde{c}_k$。新的多项式是 $\\hat{p}(x) = \\sum_{k=0}^p \\sigma_k \\tilde{c}_k P_k(x)$。这种滤波同时修改了信号和噪声。必须对 $\\hat{p}(x)$ 重复进行误差分析。\n滤波后多项式的总误差界变为：\n$$\n\\|\\hat{p} - f\\|_{\\infty} \\le \\|\\hat{p} - I_p[f]\\|_{\\infty} + \\|I_p[f] - f\\|_{\\infty}\n$$\n第二项不变。第一项变为：\n$\\|\\hat{p} - I_p[f]\\|_\\infty = \\|\\sum \\sigma_k \\tilde{c}_k P_k - \\sum c_k P_k\\|_\\infty = \\|\\sum (\\sigma_k(c_k+\\delta c_k) - c_k)P_k\\|_\\infty = \\|\\sum ((\\sigma_k-1)c_k + \\sigma_k \\delta c_k)P_k\\|_\\infty$.\n这引入了一个权衡：减小 $\\sigma_k$ 会减小 $\\delta c_k$ 的影响，但会增加由 $(\\sigma_k-1)c_k$ 项表示的类似截断的误差。\n\n一个好的滤波器应该减小高阶扰动的影响，这些扰动被 $\\Lambda_p$ 放大。因此，滤波器的强度应与这种放大的幅度相关。我们希望对于 $|c_k|$ 占主导的低 $k$ 值，$\\sigma_k \\approx 1$；对于 $|\\delta c_k|$ 可能占主导的高 $k$ 值，$\\sigma_k \\to 0$。对于更大的 $\\Lambda_p$，衰减率应该更剧烈。\n\n一个合适的、由误差界结构证明其合理性的、考虑稳定性的滤波器，可以设计为 $k$、$p$ 和 $\\Lambda_p$ 的函数。一个通用形式是有理函数：\n$$\n\\sigma_k = \\frac{1}{1 + \\alpha f(k, p, \\Lambda_p)}\n$$\n其中 $\\alpha$ 是一个可调参数，$f$ 是其参数的增函数。一个具体的、有充分理由的选择是：\n$$\n\\sigma_k = \\frac{1}{1 + \\alpha \\Lambda_p \\left(\\frac{k}{p}\\right)^{\\gamma}}\n$$\n其中 $\\gamma  0$ 是一个控制滤波器强度（aggressivity）的幂（例如，对于平滑滤波器，$\\gamma=2$），$\\alpha$ 是一个非负参数。该滤波器具有所需的性质：\n- $\\sigma_0 = 1$（保持均值）。\n- 当 $k \\to p$ 时，$\\sigma_k$ 减小。\n- 对于更大的不稳定性度量 $\\Lambda_p$ 值，衰减更快。\n- 其行为由多项式次数 $p$ 参数化。\n\n为了按要求提供单个表达式，我们可以选择典型的数值，如 $\\gamma=2$，并将 $\\alpha$ 留作一个参数，代表未提供的假定信噪比。一个常见的选择是将 $\\alpha=1$ 作为默认值。\n提议的滤波器：\n$$ \\sigma_k = \\frac{1}{1 + \\Lambda_p \\left(\\frac{k}{p}\\right)^{2}} $$\n\n问题只要求在方框中给出最终的上界表达式，而不是滤波器表达式。为 $\\mathcal{R}_i$ 推导出的上界即为最终答案。\n$$\n\\frac{1}{|f(\\xi_i)|} \\left( \\Lambda_p \\sum_{k=0}^{p} |\\delta c_k| + (1 + \\Lambda_p) E_p(f) \\right)\n$$", "answer": "$$\n\\boxed{\\frac{1}{|f(\\xi_i)|} \\left( \\Lambda_p \\sum_{k=0}^{p} |\\delta c_k| + (1 + \\Lambda_p) E_p(f) \\right)}\n$$", "id": "3392296"}, {"introduction": "最后一个练习将理论知识转化为实际的算法设计。在理解了勒贝格常数如何影响误差后，我们将利用这一知识构建一个用于hp-自适应的后验误差指示器。您将实现一个决策逻辑，该逻辑利用局部勒贝格监视器来判断是应该增加插值阶数（p-refinement），还是应该进行节点重分布（node redistribution）以抑制由节点选择不当引起的数值不稳定性。[@problem_id:3392318]", "problem": "考虑一个一维参考区间 $[-1,1]$ 及其在物理域中的仿射像（单元）$K=[a,b]$。对于一个配备了 $N+1$ 个插值节点 $\\{x_i\\}_{i=0}^{N}$ 及相关拉格朗日基函数 $\\{l_i(x)\\}_{i=0}^{N}$ 的单元 $K$，定义局部勒贝格监视器 $\\mu_K(x)=\\sum_{i=0}^N \\lvert l_i(x)\\rvert$ 和局部勒贝格常数 $\\Lambda_K=\\sup_{x\\in K}\\mu_K(x)$。令 $I_N$ 表示目标函数 $f$ 在单元 $K$ 上的 $N$ 次节点拉格朗日插值算子。在谱元或间断伽辽金方法中，插值算子 $I_N$ 局部作用于每个单元，而勒贝格常数控制了 $I_N$ 在最大范数下的算子范数。\n\n您将实现以下用于 hp-自适应的后验指标，该指标融合了局部勒贝格监视器。对于一个当前使用 $N$ 次等距节点的单元 $K$：\n- 定义分层盈余 $s_K(x)=I_{N+1}^{\\mathrm{eq}}f(x)-I_{N}^{\\mathrm{eq}}f(x)$，即两个连续等距节点插值之差。\n- 定义加权指标 $\\eta_K=\\sup_{x\\in K}\\mu_K^{\\mathrm{eq},N}(x)\\,\\lvert s_K(x)\\rvert$，其中 $\\mu_K^{\\mathrm{eq},N}$ 是用当前 $N$ 次等距节点计算的勒贝格监视器。\n- 定义节点敏感度比 $R_K=\\Lambda_K^{\\mathrm{eq},N}/\\Lambda_K^{\\mathrm{GLL},N}$，其中 $\\Lambda_K^{\\mathrm{eq},N}=\\sup_{x\\in K}\\mu_K^{\\mathrm{eq},N}(x)$ 是等距节点的勒贝格常数，而 $\\Lambda_K^{\\mathrm{GLL},N}=\\sup_{x\\in K}\\mu_K^{\\mathrm{GLL},N}(x)$ 是相同次数 $N$ 的 Gauss–Lobatto–Legendre 节点的勒贝格常数。\n\n您将采用以下局部自适应决策规则。给定固定阈值 $\\gamma1$ 和 $\\tau0$：\n- 如果 $R_K\\ge \\gamma$ 且 $\\eta_K\\ge \\tau$，则推荐在相同次数 $N$ 下进行节点重分布（切换到 Gauss–Lobatto–Legendre 节点）。\n- 否则，如果 $\\eta_K\\ge \\tau$，则推荐进行 p-加密（将次数从 $N$ 增加到 $N+2$），同时保持等距节点。\n- 否则推荐不作更改。\n\n为评估勒贝格监视器预测需要节点重分布区域的能力，为每个当前使用 $N$ 次等距节点的单元定义以下真实分类。设 $\\alpha1$ 为一个固定因子。计算最大范数下的实际插值误差：\n- $E_{\\mathrm{GLL},N}(K)=\\Vert f-I_{N}^{\\mathrm{GLL}}f\\Vert_{L^\\infty(K)}$,\n- $E_{\\mathrm{eq},N+2}(K)=\\Vert f-I_{N+2}^{\\mathrm{eq}}f\\Vert_{L^\\infty(K)}$.\n如果 $E_{\\mathrm{GLL},N}(K)\\le E_{\\mathrm{eq},N+2}(K)/\\alpha$，则将该单元分类为确实需要节点重分布；否则将其分类为不需要节点重分布（此时 p-加密至少同样有效）。\n\n您的程序必须：\n- 实现重心拉格朗日插值以计算任意节点的 $I_N f$，并通过密集采样计算勒贝格监视器 $\\mu_K(x)$ 和常数 $\\Lambda_K$。\n- 对每个测试用例，当单元使用等距节点时，逐单元应用决策规则，并生成一个推荐进行节点重分布的预测单元集。\n- 使用上述误差比较，为等距节点单元逐单元计算真实分类。\n- 每个测试用例返回一个布尔值，表示在该用例中，所有单元的节点重分布预测建议是否与真实分类相匹配。对于已使用 Gauss–Lobatto–Legendre 节点的单元，预测必须是“无重分布”，且这些单元被排除在真实分类比较之外。\n\n采用以下测试套件，阈值为 $\\gamma=1.6$、$\\tau=10^{-4}$ 和 $\\alpha=1.2$。所有范数和评估都在每个单元的 $4001$ 个等距采样点上计算：\n1. 单单元“Runge”情况：\n   - 定义域：$[-1,1]$，\n   - 单元：一个单元 $K_1=[-1,1]$，使用等距节点，次数 $N=12$，\n   - 函数：$f(x)=\\dfrac{1}{1+25x^2}$。\n2. 双单元端点层情况：\n   - 定义域：$[-1,1]$，\n   - 单元：$K_1=[-1,-0.2]$ 和 $K_2=[-0.2,1]$，均使用等距节点，次数 $N=10$，\n   - 函数：$f(x)=\\sqrt{x+1.000001}$。\n3. 单单元已为 Gauss–Lobatto–Legendre 情况：\n   - 定义域：$[-1,1]$，\n   - 单元：一个单元 $K_1=[-1,1]$，使用 Gauss–Lobatto–Legendre 节点，次数 $N=10$，\n   - 函数：$f(x)=\\cos(20x)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），每个结果是一个布尔值，对应于上述每个测试用例的成功条件。不涉及物理单位或角度。", "solution": "该问题要求在谱元和间断伽辽金方法的背景下，实现并评估一个用于 `hp`-自适应的后验指标。该指标旨在以逐个单元为基础，在 `p`-加密（增加多项式次数）和节点重分布（从等距节点切换到 Gauss-Lobatto-Legendre 节点）之间做出决策。然后将此决策与基于插值误差实际减少量的真实分类进行比较。\n\n该解决方案需要实现数值逼近理论中的几个核心概念，下文将逐步详述。\n\n**1. 基础概念和数值工具**\n\n谱元和间断伽辽金方法的核心是在单个单元上的多项式插值。这种插值的质量对整体数值解的精度至关重要。\n\n**1.1. 节点集**\n在单元 $K=[a,b]$ 上选择插值节点 $\\{x_i\\}_{i=0}^N$ 会深刻影响插值的稳定性和精度。该问题考虑了两种类型的节点。\n\n- **等距节点**：这是最直观的选择，在单元 $[a,b]$ 上定义为：\n$$x_j = a + j \\frac{b-a}{N}, \\quad j = 0, 1, \\dots, N$$\n虽然简单，但众所周知，对于高多项式次数 $N$，它们会在边界附近导致灾难性的大误差和振荡，这一现象以 Runge 命名。\n\n- **Gauss-Lobatto-Legendre (GLL) 节点**：这些节点源自正交多项式理论，旨在最小化插值误差。在参考区间 $\\hat{K}=[-1,1]$ 上，$N+1$ 个 GLL 节点 $\\{\\hat{x}_j\\}_{j=0}^N$ 是多项式 $(1-\\xi^2)P'_N(\\xi)$ 的根，其中 $P_N(\\xi)$ 是 $N$ 次勒让德多项式。这些节点包含端点 $\\pm 1$ 并向端点聚集，从而缓解了 Runge 现象。然后通过仿射变换将这些参考节点映射到物理单元 $K=[a,b]$ 上：\n$$x_j = \\frac{a+b}{2} + \\frac{b-a}{2}\\hat{x}_j$$\n\n**1.2. 重心拉格朗日插值**\n给定一组 $N+1$ 个节点 $\\{x_j\\}$ 和对应的函数值 $\\{y_j=f(x_j)\\}$，可以使用重心公式高效且稳定地计算拉格朗日插值多项式 $I_N f(x)$：\n$$I_N f(x) = \\frac{\\sum_{j=0}^{N} \\frac{w_j}{x-x_j} y_j}{\\sum_{j=0}^{N} \\frac{w_j}{x-x_j}}$$\n其中，重心权重 $w_j$ 是为给定的节点集预先计算的：\n$$w_j = \\frac{1}{\\prod_{k=0, k \\neq j}^{N} (x_j - x_k)}$$\n该公式对任何非节点的 $x$ 都有效。如果 $x=x_k$ (对于某个节点 $k$)，则插值就是 $y_k$。\n\n**1.3. 勒贝格监视器与常数**\n插值过程的稳定性由勒贝格常数 $\\Lambda_K$ 来量化。它是插值算子 $I_N$（映射 $C(K) \\to C(K)$）在最大范数下的算子范数。它通过勒贝格函数（或监视器）$\\mu_K(x)$ 定义：\n$$\\mu_K(x) = \\sum_{i=0}^{N} |l_i(x)|$$\n其中 $\\{l_i(x)\\}$ 是拉格朗日基多项式。勒贝格常数是该函数在单元上的最大值：\n$$\\Lambda_K = \\sup_{x \\in K} \\mu_K(x)$$\n较小的勒贝格常数确保插值 $I_N f$ 不会比 $f$ 的最佳多项式逼近大很多。插值误差的界为：\n$$\\|f - I_N f\\|_{L^\\infty(K)} \\le (1 + \\Lambda_K) \\inf_{p \\in \\mathcal{P}_N} \\|f - p\\|_{L^\\infty(K)}$$\n其中 $\\mathcal{P}_N$ 是次数最多为 $N$ 的多项式空间。对于等距节点，$\\Lambda_K^{\\mathrm{eq},N}$ 随 $N$ 指数级增长（$\\sim 2^N/N\\log N$），而对于 GLL 节点，$\\Lambda_K^{\\mathrm{GLL},N}$ 仅对数级增长（$\\sim \\log N$）。\n\n勒贝格监视器 $\\mu_K(x)$ 可以使用重心权重计算。单个拉格朗日基函数 $l_j(x)$ 可表示为：\n$$l_j(x) = \\frac{\\frac{w_j}{x-x_j}}{\\sum_{k=0}^{N} \\frac{w_k}{x-x_k}}$$\n对 $j=0, \\dots, N$ 的这些表达式的绝对值求和即可得到 $\\mu_K(x)$。\n\n**2. 后验自适应指标**\n问题定义了一套规则，用以判断一个使用等距节点的单元 $K$ 会更多地受益于节点重分布还是 `p`-加密。该决策基于三个量。\n\n- **分层盈余, $s_K(x)$**：这个量, $s_K(x) = I_{N+1}^{\\mathrm{eq}}f(x) - I_{N}^{\\mathrm{eq}}f(x)$，近似了当前插值 $I_{N}^{\\mathrm{eq}}f(x)$ 的误差。它使用层次结构中两个连续插值之间的差异作为真实误差的代理，这是后验误差估计中的一种常用技术。\n\n- **节点敏感度比, $R_K$**：定义为 $R_K = \\Lambda_K^{\\mathrm{eq},N} / \\Lambda_K^{\\mathrm{GLL},N}$，该比率直接衡量了切换到 GLL 节点可能带来的稳定性改善。较大的 $R_K$ 值表明与 GLL 节点相比，当前的等距节点是病态的。\n\n- **加权指标, $\\eta_K$**：其定义为 $\\eta_K = \\sup_{x \\in K} \\mu_K^{\\mathrm{eq},N}(x) |s_K(x)|$。它将估计误差（通过 $s_K$）与插值的局部不稳定性（通过 $\\mu_K^{\\mathrm{eq},N}$）相结合，提供了一种对“放大”误差的度量。\n\n**3. 决策规则与真实分类**\n决策过程如下，对于给定的阈值 $\\gamma  1$ 和 $\\tau  0$：\n\n- **预测**：\n  1. 如果 $R_K \\ge \\gamma$ 且 $\\eta_K \\ge \\tau$：预测**节点重分布**是最佳策略。大的敏感度比 $R_K$ 表明切换节点有很高的潜在增益，而大的指标 $\\eta_K$ 表明需要进行某种形式的自适应。\n  2. 否则，如果 $\\eta_K \\ge \\tau$：预测进行 `p`-加密（将次数增加到 $N+2$）。\n  3. 否则：预测不作更改。\n\n- **真实情况**：为验证预测，我们比较两种竞争策略的实际误差。对于一个因子 $\\alpha  1$：\n  1. 计算`节点重分布`的误差：$E_{\\mathrm{GLL},N}(K) = \\|f - I_{N}^{\\mathrm{GLL}}f\\|_{L^\\infty(K)}$。\n  2. 计算 `p`-加密的误差：$E_{\\mathrm{eq},N+2}(K) = \\|f - I_{N+2}^{\\mathrm{eq}}f\\|_{L^\\infty(K)}$。\n  3. 如果误差减少足够显著，即 $E_{\\mathrm{GLL},N}(K) \\le E_{\\mathrm{eq},N+2}(K) / \\alpha$，则将该单元分类为确实需要**节点重分布**。否则，则不然。\n\n最终任务是为每个测试用例验证，对于所有初始使用等距节点的单元，“节点重分布”的指标预测是否与真实分类相匹配。已使用 GLL 节点的单元被预测为需要“无重分布”，且不参与真实分类的比较。\n\n**4. 实现策略**\n该解决方案的实现首先以矢量化方式构建所需的数值工具，以提高效率。核心函数是：\n- `get_equidistant_nodes` 和 `get_gll_nodes` 用于生成节点集。GLL 节点是通过使用 `scipy.special.legendre` 得到多项式及其导数的根来找到的。\n- `barycentric_weights` 用于为给定的节点集预先计算权重。\n- `barycentric_interpolate` 和 `lebesgue_monitor` 用于在每个单元上的密集点网格上评估插值和勒贝格监视器。\n一个主分析函数根据每个单元的初始节点类型对其进行处理。对于等距单元，它计算指标 $R_K$ 和 $\\eta_K$ 来进行预测，计算真实误差 $E_{\\mathrm{GLL},N}$ 和 $E_{\\mathrm{eq},N+2}$ 用于分类，并比较两者。对于 GLL 单元，根据问题陈述，其逻辑是平凡的。一个测试用例中每个单元的结果被汇总，以生成该用例的最终布尔成功标志。所有的上确界（对于 $\\Lambda_K$、$\\eta_K$ 和 $L^\\infty$ 误差）都是通过在单元上的 $4001$ 个等距点上取最大值来近似的。", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\n# Define global constants from the problem description\nGAMMA = 1.6\nTAU = 1e-4\nALPHA = 1.2\nNUM_SAMPLES = 4001\n\ndef get_equidistant_nodes(N, a, b):\n    \"\"\"Generates N+1 equidistant nodes on the interval [a, b].\"\"\"\n    return np.linspace(a, b, N + 1)\n\ndef get_gll_nodes(N, a, b):\n    \"\"\"Generates N+1 Gauss-Lobatto-Legendre nodes on the interval [a, b].\"\"\"\n    if N == 0:\n        return np.array([(a+b)/2.0])\n    if N == 1:\n        return np.array([a, b])\n    \n    # Roots of the derivative of the N-th Legendre polynomial for interior nodes\n    p_N = legendre(N)\n    p_N_deriv = p_N.deriv(1)\n    interior_nodes_ref = p_N_deriv.roots\n    \n    # GLL nodes on the reference interval [-1, 1] include the endpoints\n    nodes_ref = np.concatenate(([-1.0], interior_nodes_ref, [1.0]))\n    nodes_ref.sort()\n    \n    # Affine mapping from [-1, 1] to [a, b]\n    return (b - a) / 2.0 * nodes_ref + (a + b) / 2.0\n\ndef barycentric_weights(nodes):\n    \"\"\"Computes barycentric weights for a given set of nodes.\"\"\"\n    N = len(nodes) - 1\n    weights = np.ones(N + 1)\n    for j in range(N + 1):\n        # Product over k != j of (xj - xk)\n        prod = np.prod([nodes[j] - nodes[k] for k in range(N + 1) if k != j])\n        weights[j] = 1.0 / prod\n    return weights\n\ndef barycentric_interpolate(nodes, f_values, weights, x_eval):\n    \"\"\"Evaluates the Lagrange interpolant using the barycentric formula.\"\"\"\n    y_interp = np.zeros_like(x_eval, dtype=float)\n    x_eval_b = x_eval[:, np.newaxis]\n    nodes_b = nodes[np.newaxis, :]\n    \n    # Find points in x_eval that are numerically close to a node\n    close_matrix = np.isclose(x_eval_b, nodes_b)\n    is_node_mask = np.any(close_matrix, axis=1)\n    \n    # Handle points that are not nodes via vectorized barycentric formula\n    if not np.all(is_node_mask):\n        non_node_x = x_eval[~is_node_mask]\n        diffs = non_node_x[:, np.newaxis] - nodes_b\n        terms = weights[np.newaxis, :] / diffs\n        numerator = np.sum(terms * f_values[np.newaxis, :], axis=1)\n        denominator = np.sum(terms, axis=1)\n        y_interp[~is_node_mask] = numerator / denominator\n\n    # Handle points that are nodes\n    if np.any(is_node_mask):\n        row_indices, col_indices = np.where(close_matrix)\n        y_interp[row_indices] = f_values[col_indices]\n\n    return y_interp\n\ndef lebesgue_monitor(nodes, weights, x_eval):\n    \"\"\"Computes the Lebesgue monitor function mu(x) = sum(|l_i(x)|).\"\"\"\n    mu_vals = np.zeros_like(x_eval, dtype=float)\n    x_eval_b = x_eval[:, np.newaxis]\n    nodes_b = nodes[np.newaxis, :]\n\n    close_matrix = np.isclose(x_eval_b, nodes_b)\n    is_node_mask = np.any(close_matrix, axis=1)\n\n    # Handle non-node points\n    if not np.all(is_node_mask):\n        non_node_x = x_eval[~is_node_mask]\n        diffs = non_node_x[:, np.newaxis] - nodes_b\n        terms = weights[np.newaxis, :] / diffs\n        denominator = np.sum(terms, axis=1, keepdims=True)\n        # individual li_vals for each non-node x\n        li_vals = terms / denominator\n        mu_vals[~is_node_mask] = np.sum(np.abs(li_vals), axis=1)\n\n    # At nodes, the Lebesgue function value is 1\n    mu_vals[is_node_mask] = 1.0\n    \n    return mu_vals\n\ndef analyze_element(element_params, f):\n    \"\"\"Analyzes a single element according to the problem rules.\"\"\"\n    a, b, N, node_type = element_params\n    \n    if node_type == 'GLL':\n        # Per problem, prediction is \"no redistribution\" and these are excluded\n        # from ground-truth comparison. This element passes by definition.\n        return True\n\n    x_eval = np.linspace(a, b, NUM_SAMPLES)\n    f_eval = f(x_eval)\n\n    # --- 1. Calculate indicators and make prediction ---\n    # Current setup (eq, N)\n    nodes_eq_N = get_equidistant_nodes(N, a, b)\n    weights_eq_N = barycentric_weights(nodes_eq_N)\n    \n    # Calculate mu_K^{eq, N}(x) and Lambda_K^{eq, N}\n    mu_K_eq_N_vals = lebesgue_monitor(nodes_eq_N, weights_eq_N, x_eval)\n    Lambda_K_eq_N = np.max(mu_K_eq_N_vals)\n\n    # Calculate s_K(x) = I_{N+1}^{eq}f - I_{N}^{eq}f\n    f_eq_N = f(nodes_eq_N)\n    I_N_eq_f = barycentric_interpolate(nodes_eq_N, f_eq_N, weights_eq_N, x_eval)\n    \n    nodes_eq_N_plus_1 = get_equidistant_nodes(N + 1, a, b)\n    weights_eq_N_plus_1 = barycentric_weights(nodes_eq_N_plus_1)\n    f_eq_N_plus_1 = f(nodes_eq_N_plus_1)\n    I_N_plus_1_eq_f = barycentric_interpolate(nodes_eq_N_plus_1, f_eq_N_plus_1, weights_eq_N_plus_1, x_eval)\n    s_K_vals = I_N_plus_1_eq_f - I_N_eq_f\n\n    # Calculate eta_K\n    eta_K = np.max(mu_K_eq_N_vals * np.abs(s_K_vals))\n\n    # Calculate R_K = Lambda_K^{eq,N} / Lambda_K^{GLL,N}\n    nodes_gll_N = get_gll_nodes(N, a, b)\n    weights_gll_N = barycentric_weights(nodes_gll_N)\n    mu_K_gll_N_vals = lebesgue_monitor(nodes_gll_N, weights_gll_N, x_eval)\n    Lambda_K_gll_N = np.max(mu_K_gll_N_vals)\n    R_K = Lambda_K_eq_N / Lambda_K_gll_N\n\n    # Apply decision rule\n    prediction_needs_redistribution = (R_K = GAMMA and eta_K = TAU)\n\n    # --- 2. Calculate ground truth classification ---\n    # E_GLL,N\n    f_gll_N = f(nodes_gll_N)\n    I_N_gll_f = barycentric_interpolate(nodes_gll_N, f_gll_N, weights_gll_N, x_eval)\n    E_GLL_N = np.max(np.abs(f_eval - I_N_gll_f))\n\n    # E_eq,N+2\n    nodes_eq_N_plus_2 = get_equidistant_nodes(N + 2, a, b)\n    weights_eq_N_plus_2 = barycentric_weights(nodes_eq_N_plus_2)\n    f_eq_N_plus_2 = f(nodes_eq_N_plus_2)\n    I_N_plus_2_eq_f = barycentric_interpolate(nodes_eq_N_plus_2, f_eq_N_plus_2, weights_eq_N_plus_2, x_eval)\n    E_eq_N_plus_2 = np.max(np.abs(f_eval - I_N_plus_2_eq_f))\n\n    # Ground truth classification\n    truth_needs_redistribution = (E_GLL_N = E_eq_N_plus_2 / ALPHA)\n    \n    # --- 3. Compare prediction and truth ---\n    return prediction_needs_redistribution == truth_needs_redistribution\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    \n    test_cases = [\n        {\n            \"name\": \"Runge\",\n            \"function\": lambda x: 1.0 / (1.0 + 25.0 * x**2),\n            \"elements\": [\n                # K_1: [a, b], N, node_type\n                [-1.0, 1.0, 12, 'equidistant'],\n            ],\n        },\n        {\n            \"name\": \"Endpoint layer\",\n            \"function\": lambda x: np.sqrt(x + 1.000001),\n            \"elements\": [\n                [-1.0, -0.2, 10, 'equidistant'],\n                [-0.2, 1.0, 10, 'equidistant'],\n            ],\n        },\n        {\n            \"name\": \"Already GLL\",\n            \"function\": lambda x: np.cos(20.0 * x),\n            \"elements\": [\n                [-1.0, 1.0, 10, 'GLL'],\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        case_match_success = True\n        for elem_params in case[\"elements\"]:\n            element_match = analyze_element(elem_params, case[\"function\"])\n            if not element_match:\n                case_match_success = False\n                break\n        results.append(case_match_success)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3392318"}]}