{"hands_on_practices": [{"introduction": "在非线性系统的离散熵分析中，确保数值积分的精确性是关键的第一步。本练习将探讨不连续伽辽金（DG）方法中的一个核心问题：为精确计算与熵相关的项，我们需要多高阶的求积法则？通过分析标量非线性守恒律（伯格斯方程），你将学习如何确定保证离散熵守恒或耗散性质所需的最小求积点数，这是构建稳定数值格式的基石。[@problem_id:3380666]", "problem": "考虑标量一维无粘 Burgers 方程\n$$\nu_{t} + \\partial_{x} f(u) = 0, \\qquad f(u) = \\tfrac{1}{2} u^{2},\n$$\n该方程建立在区域的一个不重叠单元剖分上，其中每个物理单元到参考单元都有一个仿射映射。在每个单元上，用一个次数至多为 $N$（其中 $N \\geq 1$）的多项式 $u_{h}$ 来近似解，该多项式属于空间 $\\mathbb{P}^{N}$。假设间断 Galerkin (DG) 方法在每个单元上以标准弱形式表示，并考虑基于凸熵 $U(u)$ 及其相关熵通量 $F(u)$ 的离散熵分析，它们由以下关系定义\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}u} F(u) \\;=\\; \\frac{\\mathrm{d}}{\\mathrm{d}u} U(u) \\; \\frac{\\mathrm{d}}{\\mathrm{d}u} f(u).\n$$\n对于无粘 Burgers 方程，取经典的二次熵 $U(u) = \\tfrac{1}{2} u^{2}$，因此熵变量为 $v(u) = \\tfrac{\\mathrm{d}}{\\mathrm{d}u}U(u) = u$，相关的熵通量满足 $\\tfrac{\\mathrm{d}}{\\mathrm{d}u}F(u) = u \\cdot \\tfrac{\\mathrm{d}}{\\mathrm{d}u}f(u) = u \\cdot u = u^{2}$。\n\n在单元离散熵平衡中，一个关键的体积项贡献是积分\n$$\nI \\;=\\; \\int_{K} v(u_{h}) \\, \\partial_{x} f(u_{h}) \\, \\mathrm{d}x \\;=\\; \\int_{K} \\frac{\\mathrm{d}}{\\mathrm{d}u}U(u_{h}) \\; \\frac{\\mathrm{d}}{\\mathrm{d}u}f(u_{h}) \\; \\partial_{x} u_{h} \\, \\mathrm{d}x,\n$$\n如果逐点链式法则成立，该积分等于 $\\int_{K} \\partial_{x} F(u_{h}) \\, \\mathrm{d}x$。假设此体积积分使用参考单元上具有 $Q$ 个点的 Gauss–Legendre 求积法则进行计算，该求积对于次数最高为 $2Q-1$ 的所有多项式都是精确的，并假设单元映射是仿射的，从而多项式次数得以保持。\n\n请确定，作为 $N$ 的函数，为使求积法则在每个单元上都能精确地积分熵通量贡献 $I$ 所需的 Gauss–Legendre 点的最小数量 $Q$。请用一个关于 $N$ 的封闭形式解析表达式来表示你的最终答案。", "solution": "该问题是适定的，并且在守恒律数值分析领域具有坚实的科学基础。它提供了一套完整且一致的定义和约束，足以确定一个唯一的解。因此，有必要进行全面的分析。\n\n目标是找到精确计算体积积分\n$$\nI = \\int_{K} v(u_{h}) \\, \\partial_{x} f(u_{h}) \\, \\mathrm{d}x\n$$\n在给定单元 $K$ 上所需的 Gauss-Legendre 求积点的最小数量 $Q$。解的数值近似 $u_h$ 是空间 $\\mathbb{P}^{N}$ 内一个次数至多为 $N$ 的多项式，其中 $N \\ge 1$。\n\n一个具有 $Q$ 个点的 Gauss-Legendre 求积法则对于次数最高为 $2Q-1$ 的任何多项式的积分都是精确的。为了确保 $I$ 的精确计算，被积函数的次数必须小于或等于这个值。将被积函数记为 $\\mathcal{I}(x) = v(u_{h}(x)) \\, \\partial_{x} f(u_{h}(x))$。我们的第一步是确定 $\\mathcal{I}(x)$ 的多项式次数。\n\n问题为无粘 Burgers 方程提供了以下定义：\n1.  通量函数为 $f(u) = \\frac{1}{2} u^{2}$。\n2.  熵函数为 $U(u) = \\frac{1}{2} u^{2}$。\n3.  熵变量为 $v(u) = \\frac{\\mathrm{d}}{\\mathrm{d}u}U(u)$。\n\n根据这些定义，我们可以推导出被积函数中各项的具体形式。\n熵变量为：\n$$\nv(u) = \\frac{\\mathrm{d}}{\\mathrm{d}u} \\left( \\frac{1}{2} u^{2} \\right) = u.\n$$\n当对近似解 $u_h$ 求值时，这变为 $v(u_h(x)) = u_h(x)$。由于 $u_h(x) \\in \\mathbb{P}^{N}$， $v(u_h(x))$ 的次数至多为 $N$。为了找到适用于 $\\mathbb{P}^N$ 中任何多项式的最小求积法则，我们必须考虑最坏情况，即次数恰好为 $N$。\n$$\n\\text{deg}(v(u_h)) = N.\n$$\n接下来，我们分析 $\\partial_{x} f(u_{h}(x))$ 这一项。首先，我们求复合函数 $f(u_h(x))$：\n$$\nf(u_h(x)) = \\frac{1}{2} (u_h(x))^{2}.\n$$\n由于 $u_h(x)$ 是一个次数为 $N$ 的多项式，其平方 $(u_h(x))^{2}$ 是一个次数为 $2N$ 的多项式。因此，$\\text{deg}(f(u_h)) = 2N$。\n\n现在我们应用空间导数 $\\partial_x$。由于 $u_h(x)$ 是一个多项式，链式法则直接适用：\n$$\n\\partial_{x} f(u_{h}(x)) = \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left( \\frac{1}{2} (u_h(x))^{2} \\right) = \\frac{1}{2} \\cdot 2 u_h(x) \\cdot \\frac{\\mathrm{d}u_h(x)}{\\mathrm{d}x} = u_h(x) \\, \\partial_{x} u_h(x).\n$$\n$u_h(x)$ 的次数是 $N$，其导数 $\\partial_{x} u_h(x)$ 的次数是 $N-1$（因为 $N \\ge 1$）。它们乘积的次数是它们次数的总和：\n$$\n\\text{deg}(\\partial_{x} f(u_h)) = \\text{deg}(u_h) + \\text{deg}(\\partial_{x} u_h) = N + (N-1) = 2N-1.\n$$\n现在我们可以确定完整被积函数 $\\mathcal{I}(x) = v(u_h(x)) \\, \\partial_{x} f(u_h(x))$ 的次数：\n$$\n\\text{deg}(\\mathcal{I}) = \\text{deg}(v(u_h)) + \\text{deg}(\\partial_{x} f(u_h)) = N + (2N-1) = 3N-1.\n$$\n或者，可以先构建被积函数关于 $u_h$ 的完整表达式，然后求其次数：\n$$\n\\mathcal{I}(x) = v(u_h(x)) \\left( u_h(x) \\, \\partial_x u_h(x) \\right) = u_h(x) \\left( u_h(x) \\, \\partial_x u_h(x) \\right) = (u_h(x))^{2} \\, \\partial_x u_h(x).\n$$\n$(u_h(x))^2$ 的次数是 $2N$，而 $\\partial_x u_h(x)$ 的次数是 $N-1$。它们乘积的次数是它们次数的总和：\n$$\n\\text{deg}(\\mathcal{I}) = \\text{deg}((u_h)^2) + \\text{deg}(\\partial_x u_h) = 2N + (N-1) = 3N-1.\n$$\n两种方法都得到相同的结果。被积函数是一个次数为 $3N-1$ 的多项式。\n\n为使 $Q$ 点 Gauss-Legendre 求积法则精确，其精度阶必须至少为被积函数的次数：\n$$\n2Q - 1 \\ge \\text{deg}(\\mathcal{I})\n$$\n代入我们求得的次数：\n$$\n2Q - 1 \\ge 3N - 1.\n$$\n这个不等式简化为：\n$$\n2Q \\ge 3N\n$$\n$$\nQ \\ge \\frac{3N}{2}.\n$$\n问题要求点数 $Q$ 的最小值，它必须是一个整数。因此，我们必须取大于或等于 $\\frac{3N}{2}$ 的最小整数。这由向上取整函数（ceiling function）给出：\n$$\nQ = \\left\\lceil \\frac{3N}{2} \\right\\rceil.\n$$\n这也可以分段表示。如果 $N$ 是偶数，比如说 $N=2k$（其中 $k \\ge 1$ 为整数），那么 $Q \\ge \\frac{3(2k)}{2} = 3k = \\frac{3N}{2}$。如果 $N$ 是奇数，比如说 $N=2k-1$（其中 $k \\ge 1$ 为整数），那么 $Q \\ge \\frac{3(2k-1)}{2} = 3k - \\frac{3}{2}$。此时最小整数 $Q$ 为 $3k-1 = \\frac{3(N+1)}{2}-1 = \\frac{3N+1}{2}$。向上取整函数为这两种情况提供了一个单一的紧凑表达式。", "answer": "$$\n\\boxed{\\left\\lceil \\frac{3N}{2} \\right\\rceil}\n$$", "id": "3380666"}, {"introduction": "拥有了精确的积分方法后，我们进而关注如何设计数值格式本身以保持熵稳定性，特别是对于包含源项的平衡律。一个看似合理的源项离散化方法，如逐点赋值，可能在不经意间破坏系统的离散熵属性，从而引发不稳定性。本练习通过对比简单的逐点离散和精巧的“熵平衡”离散，让你亲手计算并理解为何后者能默认满足离散熵不等式，从而揭示熵分析在设计稳定格式中的指导作用。[@problem_id:3380676]", "problem": "考虑一维非线性标量平衡律\n$$\nu_{t} + f(u)_{x} = s(u,x),\n$$\n该平衡律定义在具有周期性边界条件的参考单元 $x \\in [-1,1]$ 上，并假设平流项的贡献恒为零，$f(u)_{x} \\equiv 0$，因此只有源项对熵平衡有贡献。设熵/熵通量对为 $U(u) = \\frac{1}{2} u^{2}$ 和 $F(u) = \\frac{1}{3} u^{3}$，熵变量为 $v(u) = U'(u) = u$。\n\n在 $[-1,1]$ 上总多项式次数为 $N=2$ 的谱 Galerkin 半离散化中，离散内积使用 Gauss–Lobatto–Legendre (GLL) 求积方法计算，其节点为 $x_{1}=-1$, $x_{2}=0$, $x_{3}=1$，权重为 $w_{1}=\\frac{1}{3}$, $w_{2}=\\frac{4}{3}$, $w_{3}=\\frac{1}{3}$。假设在某一固定时刻的近似解是多项式\n$$\nu(x) = 1 + x + x^{2}.\n$$\n考虑非线性源项 $s(u,x) = u(x)^{3}$。\n\n对于一个源项离散化 $s^{d}$，定义离散熵残差为\n$$\nR[s^{d}] = v^{T} W \\,\\dot{u} - v^{T} W \\, s^{d},\n$$\n其中 $v$ 是在 GLL 节点上求值的熵变量向量，$W = \\mathrm{diag}(w_{1}, w_{2}, w_{3})$ 是对角求积权重矩阵，而 $\\dot{u}$ 是由谱 Galerkin 方法提供的半离散时间导数。在没有平流的情况下，谱 Galerkin 方法生成的 $\\dot{u}$ 是 $s(u,x)$ 在次数至多为2的多项式子空间上的 $L^{2}$ 投影。\n\n您将比较两种源项离散化：\n- 一种逐点（配置）源项离散化 $s^{\\mathrm{pw}}$，它使用节点求值，即 $s^{\\mathrm{pw}}(x_{i}) = s(u(x_{i}),x_{i})$。\n- 一种熵平衡源项离散化 $s^{\\mathrm{bal}}$，它使用熵变量 $v$ 并强制离散熵相容性，做法是令 $\\dot{u}$ 等于 $s(u,x)$ 在次数 $\\leq 2$ 上的 $L^2$ 投影，并使离散熵方程中的右端项等于应用于同一 $L^2$ 投影的 $v^T W$。\n\n计算这两个离散熵残差\n$$\nR[s^{\\mathrm{pw}}] \\quad \\text{和} \\quad R[s^{\\mathrm{bal}}],\n$$\n对于给定的 $u(x)$ 和求积方法，使用最高2次的 Legendre 多项式在 $[-1,1]$ 上构成 $L^{2}$ 投影。具体地，使用 $P_{0}(x)=1$, $P_{1}(x)=x$, 和 $P_{2}(x)=\\frac{1}{2}(3x^{2}-1)$, 其中 $\\int_{-1}^{1} P_{m}(x) P_{n}(x) \\,\\mathrm{d}x = \\frac{2}{2n+1} \\delta_{mn}$。请以精确形式表示您的最终答案。不需要四舍五入。最终输出必须是这两个残差，按 $\\big(R[s^{\\mathrm{pw}}] \\;\\; R[s^{\\mathrm{bal}}]\\big)$ 的顺序排列成一个单行矩阵。", "solution": "该问题要求计算一个特定的一维非线性标量平衡律的两个离散熵残差，$R[s^{\\mathrm{pw}}]$ 和 $R[s^{\\mathrm{bal}}]$。分析在谱 Galerkin 半离散化框架内进行。\n\n对于给定的源项离散化 $s^d$，离散熵残差定义为\n$$\nR[s^{d}] = v^{T} W \\dot{u} - v^{T} W s^{d}\n$$\n其中 $v$ 是在 Gauss–Lobatto–Legendre (GLL) 求积节点上求值的熵变量向量，$W$ 是 GLL 求积权重的对角矩阵，$\\dot{u}$ 是在 GLL 节点上求值的半离散时间导数向量。\n\n首先，我们确定计算所需的必要组成部分。\n\n**1. GLL 节点、权重和解的求值**\n\n对于多项式次数 $N=2$，GLL 节点为 $x_1 = -1$, $x_2 = 0$, 和 $x_3 = 1$。\n相应的 GLL 权重为 $w_1 = \\frac{1}{3}$, $w_2 = \\frac{4}{3}$, 和 $w_3 = \\frac{1}{3}$。权重矩阵为 $W = \\mathrm{diag}(\\frac{1}{3}, \\frac{4}{3}, \\frac{1}{3})$。\n\n近似解由多项式 $u(x) = 1 + x + x^2$ 给出。我们在 GLL 节点上计算该解的值：\n$u_1 = u(x_1) = u(-1) = 1 + (-1) + (-1)^2 = 1$。\n$u_2 = u(x_2) = u(0) = 1 + 0 + 0^2 = 1$。\n$u_3 = u(x_3) = u(1) = 1 + 1 + 1^2 = 3$。\n\n熵变量为 $v(u) = U'(u)$，其中 $U(u) = \\frac{1}{2}u^2$，因此 $v(u) = u$。因此，在节点上的熵变量向量（记为 $v$）与节点上的解值向量相同：\n$$\nv = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\end{pmatrix} = \\begin{pmatrix} u_1 \\\\ u_2 \\\\ u_3 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 3 \\end{pmatrix}.\n$$\n\n**2. 逐点源项离散化 ($s^{\\mathrm{pw}}$)**\n\n非线性源项为 $s(u,x) = u(x)^3$。\n逐点（配置）源项离散化 $s^{\\mathrm{pw}}$ 包括使用解的节点值来计算源函数：$s^{\\mathrm{pw}}_i = s(u(x_i), x_i) = (u_i)^3$。\n$s^{\\mathrm{pw}}_1 = (u_1)^3 = 1^3 = 1$。\n$s^{\\mathrm{pw}}_2 = (u_2)^3 = 1^3 = 1$。\n$s^{\\mathrm{pw}}_3 = (u_3)^3 = 3^3 = 27$。\n向量 $s^{\\mathrm{pw}}$ 为：\n$$\ns^{\\mathrm{pw}} = \\begin{pmatrix} 1 \\\\ 1 \\\\ 27 \\end{pmatrix}.\n$$\n\n**3. 半离散时间导数 ($\\dot{u}$)**\n\n由于平流项 $f(u)_x$ 为零，方程为 $u_t = s(u,x)$。在谱 Galerkin 方法中，多项式近似的半离散时间导数（我们可称之为 $\\dot{u}_{\\mathrm{poly}}(t,x)$）是通过将源项 $s(u,x)$ 在次数至多为 $N=2$ 的多项式空间上进行 $L^2$ 投影得到的。残差公式中的向量 $\\dot{u}$ 是此多项式在 GLL 节点上的求值结果。\n\n令 $\\dot{u}_{\\mathrm{proj}}(x)$ 为 $s(u(x),x)$ 在 $\\mathcal{P}_2 = \\mathrm{span}\\{P_0(x), P_1(x), P_2(x)\\}$ 上的 $L^2$ 投影，其中 $P_k(x)$ 是 Legendre 多项式。\n$$\n\\dot{u}_{\\mathrm{proj}}(x) = c_0 P_0(x) + c_1 P_1(x) + c_2 P_2(x).\n$$\n作为 $x$ 的函数，源项为 $s(x) = s(u(x),x) = (1+x+x^2)^3$。展开此多项式得到：\n$$\ns(x) = 1 + 3x + 6x^2 + 7x^3 + 6x^4 + 3x^5 + x^6.\n$$\n系数 $c_k$ 使用公式 $c_k = \\frac{\\langle s, P_k \\rangle}{\\langle P_k, P_k \\rangle} = \\frac{\\int_{-1}^{1} s(x) P_k(x) dx}{\\int_{-1}^{1} P_k(x)^2 dx}$ 计算。分母由 $\\frac{2}{2k+1}$ 给出。\n\n对于 $c_0$，使用 $P_0(x)=1$：\n$c_0 = \\frac{1}{2} \\int_{-1}^{1} (1 + 3x + 6x^2 + 7x^3 + 6x^4 + 3x^5 + x^6) dx$。只对偶次项进行积分：\n$\\int_{-1}^1 s(x) dx = 2\\int_0^1(1+6x^2+6x^4+x^6)dx = 2[x+2x^3+\\frac{6}{5}x^5+\\frac{1}{7}x^7]_0^1 = 2(1+2+\\frac{6}{5}+\\frac{1}{7}) = 2(3+\\frac{42+5}{35}) = 2(3+\\frac{47}{35})=2(\\frac{105+47}{35}) = \\frac{304}{35}$。\n$c_0 = \\frac{1}{2}\\frac{304}{35} = \\frac{152}{35}$。\n\n对于 $c_1$，使用 $P_1(x)=x$：\n$c_1 = \\frac{3}{2}\\int_{-1}^{1} s(x) x dx = \\frac{3}{2} \\int_{-1}^{1} (3x^2+7x^4+3x^6) dx = \\frac{3}{2} \\cdot 2 [x^3+\\frac{7}{5}x^5+\\frac{3}{7}x^7]_0^1 = 3(1+\\frac{7}{5}+\\frac{3}{7}) = 3(\\frac{35+49+15}{35}) = 3(\\frac{99}{35}) = \\frac{297}{35}$。\n\n对于 $c_2$，使用 $P_2(x)=\\frac{1}{2}(3x^2-1)$：\n$\\int_{-1}^1 s(x) P_2(x) dx = \\int_{-1}^1 (1+6x^2+6x^4+x^6)\\frac{1}{2}(3x^2-1) dx = \\int_{-1}^1 (\\frac{3}{2}x^2-\\frac{1}{2} + 9x^4-3x^2+9x^6-3x^4+\\frac{3}{2}x^8-\\frac{1}{2}x^6) dx = \\int_{-1}^1 (\\frac{3}{2}x^8 + \\frac{17}{2}x^6 + 6x^4 - \\frac{3}{2}x^2 - \\frac{1}{2}) dx = 2(\\frac{3}{18} + \\frac{17}{14} + \\frac{6}{5} - \\frac{3}{6} - \\frac{1}{2}) = 2(\\frac{1}{6} + \\frac{17}{14} + \\frac{6}{5} - 1) = \\frac{332}{105}$。\n$c_2 = \\frac{5}{2}\\frac{332}{105} = \\frac{166 \\cdot 5}{105} = \\frac{166}{21}$。\n\n因此投影为 $\\dot{u}_{\\mathrm{proj}}(x) = \\frac{152}{35}P_0(x) + \\frac{297}{35}P_1(x) + \\frac{166}{21}P_2(x)$。\n代入 Legendre 多项式：\n$\\dot{u}_{\\mathrm{proj}}(x) = \\frac{152}{35} + \\frac{297}{35}x + \\frac{166}{21}(\\frac{3}{2}x^2-\\frac{1}{2}) = (\\frac{152}{35} - \\frac{83}{21}) + \\frac{297}{35}x + \\frac{83}{7}x^2 = \\frac{456 - 415}{105} + \\frac{297}{35}x + \\frac{83}{7}x^2 = \\frac{41}{105} + \\frac{297}{35}x + \\frac{83}{7}x^2$。\n\n现在，我们在 GLL 节点上计算该多项式的值以求得向量 $\\dot{u}$：\n$\\dot{u}_1 = \\dot{u}_{\\mathrm{proj}}(-1) = \\frac{41}{105} - \\frac{297}{35} + \\frac{83}{7} = \\frac{41 - 891 + 1245}{105} = \\frac{395}{105} = \\frac{79}{21}$。\n$\\dot{u}_2 = \\dot{u}_{\\mathrm{proj}}(0) = \\frac{41}{105}$。\n$\\dot{u}_3 = \\dot{u}_{\\mathrm{proj}}(1) = \\frac{41}{105} + \\frac{297}{35} + \\frac{83}{7} = \\frac{41 + 891 + 1245}{105} = \\frac{2177}{105}$。\n向量 $\\dot{u}$ 为：\n$$\n\\dot{u} = \\begin{pmatrix} 79/21 \\\\ 41/105 \\\\ 2177/105 \\end{pmatrix}.\n$$\n\n**4. $R[s^{\\mathrm{pw}}]$ 的计算**\n\n我们现在计算逐点源项的残差：\n$$\nR[s^{\\mathrm{pw}}] = v^T W (\\dot{u} - s^{\\mathrm{pw}}).\n$$\n首先，计算差分向量 $\\dot{u} - s^{\\mathrm{pw}}$：\n$\\dot{u}_1 - s^{\\mathrm{pw}}_1 = \\frac{79}{21} - 1 = \\frac{58}{21}$。\n$\\dot{u}_2 - s^{\\mathrm{pw}}_2 = \\frac{41}{105} - 1 = -\\frac{64}{105}$。\n$\\dot{u}_3 - s^{\\mathrm{pw}}_3 = \\frac{2177}{105} - 27 = \\frac{2177 - 2835}{105} = -\\frac{658}{105}$。\n\n现在计算三重积：\n$R[s^{\\mathrm{pw}}] = \\sum_{i=1}^3 v_i w_i (\\dot{u}_i - s^{\\mathrm{pw}}_i) = v_1 w_1 (\\dot{u}_1 - s^{\\mathrm{pw}}_1) + v_2 w_2 (\\dot{u}_2 - s^{\\mathrm{pw}}_2) + v_3 w_3 (\\dot{u}_3 - s^{\\mathrm{pw}}_3)$。\n$R[s^{\\mathrm{pw}}] = (1)(\\frac{1}{3})(\\frac{58}{21}) + (1)(\\frac{4}{3})(-\\frac{64}{105}) + (3)(\\frac{1}{3})(-\\frac{658}{105})$。\n$R[s^{\\mathrm{pw}}] = \\frac{58}{63} - \\frac{256}{315} - \\frac{658}{105}$。\n$63$、$315$ 和 $105$ 的最小公分母是 $315$。\n$R[s^{\\mathrm{pw}}] = \\frac{58 \\cdot 5}{315} - \\frac{256}{315} - \\frac{658 \\cdot 3}{315} = \\frac{290 - 256 - 1974}{315} = \\frac{34 - 1974}{315} = \\frac{-1940}{315}$。\n将分子和分母除以它们的最大公约数 $5$ 来简化分数：\n$$\nR[s^{\\mathrm{pw}}] = -\\frac{388}{63}.\n$$\n\n**5. $R[s^{\\mathrm{bal}}]$ 的计算**\n\n对于熵平衡源项离散化 $s^{\\mathrm{bal}}$，问题指出它“通过……[使]离散熵方程的右端等于应用于相同 $L^2$ 投影的 $v^T W$，来强制执行离散熵一致性”。\n源项贡献的离散熵方程是 $\\frac{dU_{total}}{dt} = v^T W s^d$。右端项是 $v^T W s^d$。\n对于平衡离散化，该项 $v^T W s^{\\mathrm{bal}}$ 被设定为等于“应用于相同 $L^2$ 投影的 $v^T W$”，即 $v^T W \\dot{u}$。因此，根据此情景下熵平衡格式的定义：\n$$\nv^{T} W s^{\\mathrm{bal}} \\equiv v^{T} W \\dot{u}.\n$$\n将此代入残差 $R[s^{\\mathrm{bal}}]$ 的定义中：\n$$\nR[s^{\\mathrm{bal}}] = v^{T} W \\dot{u} - v^{T} W s^{\\mathrm{bal}} = v^{T} W \\dot{u} - v^{T} W \\dot{u} = 0.\n$$\n熵平衡源项的构造目的就是为了使该残差为零，从而满足一个离散熵律。\n\n**结论**\n\n两个离散熵残差为：\n$R[s^{\\mathrm{pw}}] = -\\frac{388}{63}$。\n$R[s^{\\mathrm{bal}}] = 0$。\n\n最终答案按要求以行矩阵形式呈现。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{388}{63} & 0\n\\end{pmatrix}\n}\n$$", "id": "3380676"}, {"introduction": "在前两个练习的基础上，我们将挑战更复杂的实际问题：可压缩欧拉方程。在这些系统中，除了熵稳定性，我们还必须强制保证物理量的“正性”（如密度和压力为正）。本练习将引导你探究一个深刻的矛盾：为保证正性而引入的限制器（limiter），是否会破坏底层熵稳定格式的耗散特性？通过模拟并分析这些相互作用，你将认识到在为复杂流动设计高保真数值方法时所面临的现实挑战与权衡。[@problem_id:3380723]", "problem": "考虑单组分理想气体的一维可压缩欧拉方程，其比热比为 $\\gamma \\in \\mathbb{R}$，$\\gamma > 1$。令守恒变量为 $u = [\\rho, m, E]^T$，其中 $\\rho$ 是质量密度，$m = \\rho u$ 是动量（$u$ 为速度），$E$ 是总能量。热力学压力由状态方程 $p = (\\gamma - 1)\\left(E - \\frac{1}{2}\\frac{m^2}{\\rho}\\right)$ 给出。物理可容许性约束要求 $\\rho > 0$ 和 $p > 0$。无粘通量为 $f(u) = [m,\\; \\frac{m^2}{\\rho} + p,\\; (E + p)\\frac{m}{\\rho}]^T$。\n\n对于离散熵分析，将欧拉系统的数学熵（一个凸熵函数）定义为 $\\eta(u) = -\\frac{\\rho s}{\\gamma - 1}$，其中 $s = \\ln(p) - \\gamma \\ln(\\rho)$ 是物理比熵。在半离散熵稳定格式中，由熵稳定通量驱动的更新下，总离散熵应为非增的。局部 Lax-Friedrichs (LLF) 数值通量（也称为 Rusanov 通量）由下式给出\n$$\nF_{\\mathrm{LLF}}(u_L, u_R) = \\frac{1}{2}\\left(f(u_L) + f(u_R)\\right) - \\frac{1}{2}\\alpha(u_L, u_R)\\left(u_R - u_L\\right),\n$$\n其中 $\\alpha(u_L, u_R)$ 是最大特征速度的一个界，例如 $\\alpha(u_L,u_R) = \\max\\left(|u_L| + c_L,\\; |u_R| + c_R\\right)$，其中 $c = \\sqrt{\\gamma p / \\rho}$ 是根据与 $u_L$ 和 $u_R$ 相关的原始变量计算出的声速。当 $\\alpha$ 如上选择时，该通量对于欧拉方程是熵稳定的。\n\n在一个代表性的双单元周期性离散中（这种离散产生于对称节点谱方法或在简化为单个界面耦合时的最低阶间断 Galerkin 方法），考虑两个相邻的单元，其状态分别为 $u_L$ 和 $u_R$。假设在均匀网格间距 $\\Delta x$ 上，使用大小为 $\\Delta t$ 的单个前向欧拉步进行更新，在共享界面上使用两个具有相反参数的数值通量计算：\n$$\nF_{LR} = F_{\\mathrm{LLF}}(u_L, u_R), \\quad F_{RL} = F_{\\mathrm{LLF}}(u_R, u_L).\n$$\n双单元的周期性更新为\n$$\nu_L^{\\mathrm{new}} = u_L - \\frac{\\Delta t}{\\Delta x}\\left(F_{LR} - F_{RL}\\right), \\quad\nu_R^{\\mathrm{new}} = u_R - \\frac{\\Delta t}{\\Delta x}\\left(F_{RL} - F_{LR}\\right).\n$$\n\n为了在更新后强制密度和压力的正性，应用一个保正限制器，通过将每个候选更新状态 $u^{\\mathrm{new}}$ 与其原始可容许状态 $u^{\\mathrm{safe}}$（更新前状态）进行凸性混合：\n$$\nu^{\\mathrm{lim}}(\\theta) = \\theta\\, u^{\\mathrm{new}} + (1 - \\theta)\\, u^{\\mathrm{safe}}, \\quad \\theta \\in [0,1],\n$$\n并选择满足 $\\rho^{\\mathrm{lim}}(\\theta) \\ge \\rho_{\\min}$ 和 $p^{\\mathrm{lim}}(\\theta) \\ge p_{\\min}$ 的最大 $\\theta$，其中给定下限值 $\\rho_{\\min} > 0$ 和 $p_{\\min} > 0$。两个单元中的受限状态是通过此过程获得的 $u_L^{\\mathrm{lim}}$ 和 $u_R^{\\mathrm{lim}}$。\n\n将“熵增违背”定义为应用保正限制器后，两个单元上的数学熵之和增加的事件，即\n$$\n\\eta(u_L^{\\mathrm{lim}}) + \\eta(u_R^{\\mathrm{lim}}) > \\eta(u_L) + \\eta(u_R).\n$$\n在此设置下，研究保正限制器与熵稳定 LLF 通量的兼容性，并识别限制器引起的过冲导致总数学熵增加的情景。\n\n您的任务是实现一个程序，对于下面提供的每个测试用例，执行以下步骤：\n- 将给定的原始变量 $(\\rho, u, p)$ 转换为守恒变量 $u$。\n- 在共享界面上计算两种参数顺序的 LLF 通量，并使用上述双单元周期性格式更新两个单元。\n- 应用具有给定下限值 $\\rho_{\\min}$ 和 $p_{\\min}$ 的保正限制器，通过选择在每个单元中强制约束的最大 $\\theta \\in [0,1]$。\n- 计算限制更新前后的数学熵之和。\n- 返回一个布尔值，指示由于限制更新导致总数学熵是否增加。\n\n所有量均为无量纲。使用以下测试套件；每个测试用例由 $(\\gamma,\\; \\Delta t,\\; \\Delta x,\\; \\rho_L,\\; u_L,\\; p_L,\\; \\rho_R,\\; u_R,\\; p_R,\\; \\rho_{\\min},\\; p_{\\min})$ 指定：\n- 情况1（基准平滑状态）：$(1.4,\\; 0.1,\\; 1.0,\\; 1.0,\\; 0.0,\\; 1.0,\\; 0.9,\\; 0.1,\\; 1.1,\\; 10^{-10},\\; 10^{-10})$。\n- 情况2（具有潜在过冲的强跳跃）：$(1.4,\\; 1.0,\\; 1.0,\\; 0.2,\\; 5.0,\\; 0.01,\\; 1.0,\\; -2.0,\\; 2.0,\\; 10^{-12},\\; 10^{-12})$。\n- 情况3（类激波对比）：$(1.4,\\; 0.5,\\; 1.0,\\; 1.0,\\; 3.0,\\; 0.5,\\; 4.0,\\; 0.0,\\; 2.0,\\; 10^{-12},\\; 10^{-12})$。\n- 情况4（一侧接近真空）：$(1.4,\\; 0.7,\\; 1.0,\\; 10^{-3},\\; 0.0,\\; 10^{-5},\\; 1.0,\\; 0.0,\\; 1.0,\\; 10^{-12},\\; 10^{-12})$。\n- 情况5（反向传播高马赫数）：$(1.4,\\; 0.3,\\; 1.0,\\; 0.5,\\; 10.0,\\; 0.1,\\; 0.5,\\; -10.0,\\; 0.1,\\; 10^{-12},\\; 10^{-12})$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如，\"[result1,result2,result3,result4,result5]\"），其中每个结果是一个布尔值（True 或 False），指示对于该测试用例，应用保正限制器后总数学熵是否增加。", "solution": "该问题已经过验证，被认为是有效的。它在科学上基于双曲守恒律的计算流体动力学原理，特别是可压缩欧拉方程。该问题是适定的，提供了所有必要的定义、方程和参数来构建一个唯一的、确定性的计算解。语言是客观的，设置是一致的。\n\n任务是确定当保正限制器应用于熵稳定数值格式时，是否会导致一个简单的双单元周期性系统的总数学熵增加。解决方案涉及对一系列测试用例所述过程的直接模拟。分析的核心在于局部的、逐状态的正性强制与全局的、系统范围的熵耗散属性之间潜在的不兼容性。熵函数是凸的，虽然通量是熵稳定的且限制器是凸组合，但限制器系数 $\\theta$ 在不同单元间可能不同（$\\theta_L \\ne \\theta_R$）这一事实，破坏了保证组合格式熵稳定性的简单论证。\n\n计算过程实现如下：\n\n1.  **状态转换**：初始状态以原始变量 $(\\rho, u, p)$ 给出，其中 $\\rho$ 是密度，$u$ 是速度，$p$ 是压力。这些被转换为守恒变量向量 $u = [\\rho, m, E]^T$，其中 $m = \\rho u$ 是动量，$E$ 是单位体积的总能量。总能量的转换基于理想气体状态方程：\n    $$E = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\rho u^2 = \\frac{p}{\\gamma - 1} + \\frac{1}{2}\\frac{m^2}{\\rho}$$\n\n2.  **半离散更新**：问题描述了一个双单元周期性系统，它作为分析单个单元界面相互作用的最小模型。状态 $u_L$ 和 $u_R$ 的前向欧拉时间更新由下式给出：\n    $$\n    u_L^{\\mathrm{new}} = u_L - \\frac{\\Delta t}{\\Delta x}\\left(F_{LR} - F_{RL}\\right) \\\\\n    u_R^{\\mathrm{new}} = u_R - \\frac{\\Delta t}{\\Delta x}\\left(F_{RL} - F_{LR}\\right)\n    $$\n    其中 $F_{LR} = F_{\\mathrm{LLF}}(u_L, u_R)$ 和 $F_{RL} = F_{\\mathrm{LLF}}(u_R, u_L)$ 是局部 Lax-Friedrichs (LLF) 数值通量。LLF 通量定义为：\n    $$\n    F_{\\mathrm{LLF}}(u_L, u_R) = \\frac{1}{2}\\left(f(u_L) + f(u_R)\\right) - \\frac{1}{2}\\alpha(u_L, u_R)\\left(u_R - u_L\\right)\n    $$\n    稳定化参数 $\\alpha(u_L, u_R)$ 是对称的，即 $\\alpha(u_L, u_R) = \\alpha(u_R, u_L)$。这导致更新项的显著简化：\n    $$\n    F_{LR} - F_{RL} = -\\alpha(u_L, u_R)(u_R - u_L)\n    $$\n    因此，候选状态 $u_L^{\\mathrm{new}}$ 和 $u_R^{\\mathrm{new}}$ 的更新变为：\n    $$\n    u_L^{\\mathrm{new}} = u_L + \\frac{\\Delta t}{\\Delta x}\\alpha(u_L, u_R)(u_R - u_L) \\\\\n    u_R^{\\mathrm{new}} = u_R - \\frac{\\Delta t}{\\Delta x}\\alpha(u_L, u_R)(u_R - u_L)\n    $$\n    波速 $\\alpha$ 计算为 $\\alpha(u_L, u_R) = \\max(|u_L| + c_L, |u_R| + c_R)$，其中 $u$ 是流体速度，$c = \\sqrt{\\gamma p / \\rho}$ 是声速，所有这些都源自对应于状态 $u_L$ 和 $u_R$ 的原始变量。\n\n3.  **保正限制器**：候选状态 $u^{\\mathrm{new}}$ 可能违反物理可容许性约束 $\\rho > 0$ 和 $p > 0$。为强制这些约束，应用了保正限制器。对于每个单元，我们找到最大的混合因子 $\\theta \\in [0, 1]$，使得受限状态 $u^{\\mathrm{lim}}(\\theta) = \\theta u^{\\mathrm{new}} + (1 - \\theta) u^{\\mathrm{safe}}$ 是可容许的。这里，$u^{\\mathrm{safe}}$ 是更新前的状态，假定其是可容许的。\n    约束条件是 $\\rho^{\\mathrm{lim}}(\\theta) \\ge \\rho_{\\min}$ 和 $p^{\\mathrm{lim}}(\\theta) \\ge p_{\\min}$，对于小的正下限值 $\\rho_{\\min}$ 和 $p_{\\min}$。\n\n    *   **密度约束**：$\\rho^{\\mathrm{lim}}(\\theta) = \\theta \\rho^{\\mathrm{new}} + (1 - \\theta) \\rho^{\\mathrm{safe}} \\ge \\rho_{\\min}$。这是一个关于 $\\theta$ 的线性不等式。如果 $\\rho^{\\mathrm{new}}  \\rho_{\\min}$，它产生一个上界 $\\theta \\le \\theta_{\\rho} = (\\rho_{\\min} - \\rho^{\\mathrm{safe}})/(\\rho^{\\mathrm{new}} - \\rho^{\\mathrm{safe}})$。否则，对于密度约束，任何 $\\theta \\in [0,1]$ 都是有效的。\n\n    *   **压力约束**：$p^{\\mathrm{lim}}(\\theta) = (\\gamma-1)(E^{\\mathrm{lim}}(\\theta) - \\frac{1}{2}\\frac{(m^{\\mathrm{lim}}(\\theta))^2}{\\rho^{\\mathrm{lim}}(\\theta)}) \\ge p_{\\min}$。代入 $\\rho^{\\mathrm{lim}}$、 $m^{\\mathrm{lim}}$ 和 $E^{\\mathrm{lim}}$ 的线性表达式，会得到一个关于 $\\theta$ 的形如 $A\\theta^2 + B\\theta + C \\ge 0$ 的二次不等式。系数 $A, B, C$ 是安全状态和新状态以及 $\\gamma$ 和 $p_{\\min}$ 的函数。如果新状态 $u^{\\mathrm{new}}$ 已经是压力正的，则此约束不需要混合。否则，我们解二次方程 $A\\theta^2 + B\\theta + C = 0$ 以求其根。由于安全状态是可容许的（$p^{\\mathrm{safe}} > p_{\\min}$）而新状态不是（$p^{\\mathrm{new}}  p_{\\min}$），在区间 $(0, 1)$ 内必然存在一个根，它提供了上界 $\\theta_p$。使用 `numpy.roots` 函数来稳健地找到这些根。\n\n    每个单元的最终混合因子为 $\\theta = \\min(1.0, \\theta_{\\rho}, \\theta_{p})$。此过程对单元 $L$ 和单元 $R$ 独立执行以找到 $\\theta_L$ 和 $\\theta_R$，然后得到相应的受限状态 $u_L^{\\mathrm{lim}}$ 和 $u_R^{\\mathrm{lim}}$。\n\n4.  **熵违背检查**：一个状态 $u$ 的数学熵为 $\\eta(u) = -\\frac{\\rho s}{\\gamma - 1}$，其中物理比熵为 $s = \\ln(p) - \\gamma \\ln(\\rho)$。总初始熵为 $\\Sigma \\eta_{\\mathrm{initial}} = \\eta(u_L) + \\eta(u_R)$。限制更新后的总最终熵为 $\\Sigma \\eta_{\\mathrm{final}} = \\eta(u_L^{\\mathrm{lim}}) + \\eta(u_R^{\\mathrm{lim}})$。如果 $\\Sigma \\eta_{\\mathrm{final}} > \\Sigma \\eta_{\\mathrm{initial}}$，则发生“熵增违背”。对于每个测试用例，返回一个布尔值，指示是否观察到此违背。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    test_cases = [\n        # (gamma, dt, dx, rho_L, u_L, p_L, rho_R, u_R, p_R, rho_min, p_min)\n        (1.4, 0.1, 1.0, 1.0, 0.0, 1.0, 0.9, 0.1, 1.1, 1e-10, 1e-10),\n        (1.4, 1.0, 1.0, 0.2, 5.0, 0.01, 1.0, -2.0, 2.0, 1e-12, 1e-12),\n        (1.4, 0.5, 1.0, 1.0, 3.0, 0.5, 4.0, 0.0, 2.0, 1e-12, 1e-12),\n        (1.4, 0.7, 1.0, 1e-3, 0.0, 1e-5, 1.0, 0.0, 1.0, 1e-12, 1e-12),\n        (1.4, 0.3, 1.0, 0.5, 10.0, 0.1, 0.5, -10.0, 0.1, 1e-12, 1e-12),\n    ]\n\n    results = []\n    for case in test_cases:\n        violation = run_simulation(*case)\n        results.append(violation)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(gamma, dt, dx, rho_L, v_L, p_L, rho_R, v_R, p_R, rho_min, p_min):\n    \"\"\"\n    Runs the simulation for a single test case.\n    \"\"\"\n    # 1. Convert primitive to conservative variables\n    uL_safe = prim_to_cons(rho_L, v_L, p_L, gamma)\n    uR_safe = prim_to_cons(rho_R, v_R, p_R, gamma)\n\n    # 2. Calculate initial total entropy\n    eta_initial = entropy_function(uL_safe, gamma) + entropy_function(uR_safe, gamma)\n\n    # 3. Compute LLF wave speed\n    cL = np.sqrt(gamma * p_L / rho_L)\n    cR = np.sqrt(gamma * p_R / rho_R)\n    alpha = max(abs(v_L) + cL, abs(v_R) + cR)\n    \n    # 4. Compute candidate updated states\n    diff_u = uR_safe - uL_safe\n    uL_new = uL_safe + (dt / dx) * alpha * diff_u\n    uR_new = uR_safe - (dt / dx) * alpha * diff_u\n\n    # 5. Apply positivity-preserving limiter\n    theta_L = find_limiter_theta(uL_new, uL_safe, gamma, rho_min, p_min)\n    uL_lim = theta_L * uL_new + (1 - theta_L) * uL_safe\n\n    theta_R = find_limiter_theta(uR_new, uR_safe, gamma, rho_min, p_min)\n    uR_lim = theta_R * uR_new + (1 - theta_R) * uR_safe\n    \n    # 6. Calculate final total entropy\n    eta_final = entropy_function(uL_lim, gamma) + entropy_function(uR_lim, gamma)\n    \n    # 7. Check for entropy violation\n    return eta_final > eta_initial\n\ndef prim_to_cons(rho, v, p, gamma):\n    \"\"\"Converts primitive variables (rho, v, p) to conservative vector u.\"\"\"\n    m = rho * v\n    E = p / (gamma - 1) + 0.5 * rho * v**2\n    return np.array([rho, m, E])\n\ndef get_pressure(u, gamma):\n    \"\"\"Computes pressure from the conservative state vector.\"\"\"\n    rho, m, E = u\n    if rho = 0:\n        return -1.0\n    p = (gamma - 1) * (E - 0.5 * m**2 / rho)\n    return p\n\ndef entropy_function(u, gamma):\n    \"\"\"Computes the mathematical entropy eta(u).\"\"\"\n    rho, m, E = u\n    p = get_pressure(u, gamma)\n    if rho = 0 or p = 0:\n        # Invalid state, return a large number to signify error\n        return np.inf\n    s = np.log(p) - gamma * np.log(rho)\n    eta = -rho * s / (gamma - 1)\n    return eta\n\ndef find_limiter_theta(u_new, u_safe, gamma, rho_min, p_min):\n    \"\"\"\n    Finds the largest theta in [0, 1] for the positivity-preserving limiter.\n    \"\"\"\n    rho_new, m_new, E_new = u_new\n    rho_safe, m_safe, E_safe = u_safe\n    \n    # --- Density constraint ---\n    theta_rho = 1.0\n    if rho_new  rho_min:\n        # Since rho_safe >= rho_min, rho_new - rho_safe is negative.\n        # This check avoids division by zero if rho_new is somehow equal to rho_safe.\n        if rho_new - rho_safe  -1e-14:\n            theta_rho = (rho_min - rho_safe) / (rho_new - rho_safe)\n        else: # Cannot satisfy constraint if rho_new  rho_min and rho_new >= rho_safe\n            return 0.0\n\n    # --- Pressure constraint ---\n    p_new = get_pressure(u_new, gamma)\n    theta_p = 1.0\n    if p_new  p_min:\n        d_rho = rho_new - rho_safe\n        d_m = m_new - m_safe\n        d_E = E_new - E_safe\n        \n        # Coefficients of the quadratic A*theta^2 + B*theta + C >= 0\n        A = 2 * d_rho * d_E - d_m**2\n        B = 2 * (rho_safe * d_E + E_safe * d_rho) - 2 * m_safe * d_m - (2 * p_min / (gamma - 1)) * d_rho\n        C = 2 * rho_safe * E_safe - m_safe**2 - (2 * p_min / (gamma - 1)) * rho_safe\n\n        # C is guaranteed to be >= 0 because p_safe >= p_min\n        if C  0: C = 0\n\n        # Find the smallest positive real root of the quadratic.\n        # This root is the upper bound on theta for pressure positivity.\n        if abs(A)  1e-14:  # Linear case\n            if abs(B) > 1e-14:\n                root = -C / B\n                # If root > 0, it's our candidate theta_p\n                # If root = 0, and we need to limit, no positive theta will solve it\n                theta_p = root if root > 1e-14 else 0.0\n            else: # B=0, C >= 0, constraint is always satified or never\n                theta_p = 1.0 if C >= 0 else 0.0\n        else:  # Quadratic case\n            roots = np.roots([A, B, C])\n            pos_real_roots = sorted([r.real for r in roots if abs(r.imag)  1e-14 and r.real > 1e-14])\n            if pos_real_roots:\n                # Theory guarantees a root in (0,1) when p_new  p_min\n                theta_p = pos_real_roots[0]\n            else:\n                # Failsafe: if no positive roots, means parabola is always positive (since C>=0),\n                # which contradicts p_new  p_min. Something is numerically unstable.\n                # Reverting fully is the safest option.\n                theta_p = 0.0\n\n    # The final theta is the minimum of the bounds, clipped to [0, 1]\n    return min(1.0, max(0.0, theta_rho), max(0.0, theta_p))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3380723"}]}