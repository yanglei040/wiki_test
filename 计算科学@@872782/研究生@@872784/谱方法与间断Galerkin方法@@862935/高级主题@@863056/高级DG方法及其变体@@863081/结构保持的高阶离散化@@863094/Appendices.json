{"hands_on_practices": [{"introduction": "结构保持离散化的核心在于模仿连续介质的守恒律或能量稳定性。本练习从最基本的构建模块入手，通过为线性平流方程实现一个二阶求和分部（SBP）算子来引入这一概念。通过亲手实现并验证离散能量的非增性，您将对同步近似项（SAT）如何稳定地施加边界条件，并确保整个半离散格式的能量稳定性有一个具体而深刻的理解。", "problem": "考虑在空间域 $[0,1]$ 上的线性平流方程 $u_t + a\\,u_x = 0$，其中平流速度为常数 $a=1$，且具有齐次入流边界条件 $u(0,t)=0$。使用一个包含 $N$ 个点 $x_i = i h$（其中 $i=0,1,\\ldots,N-1$，$h = 1/(N-1)$）的均匀网格对该域进行离散化。实现一个二阶对角范数分部求和（SBP）算子，并使用一个同步近似项（SAT）以一种稳定的、能量一致的方式施加入流边界。然后计算半离散能量增长率，并验证对于所有提供的测试用例，该增长率都是非增的。\n\n定义和要求：\n- 分部求和（SBP）性质由一个对角范数矩阵 $H \\in \\mathbb{R}^{N \\times N}$ 和一个微分算子 $D \\in \\mathbb{R}^{N \\times N}$ 定义，它们满足 $D = H^{-1} Q$，其中某个矩阵 $Q \\in \\mathbb{R}^{N \\times N}$ 满足\n$$\nQ + Q^\\top = B,\n$$\n这里 $B = \\mathrm{diag}(-1, 0, \\ldots, 0, 1)$ 对应于离散边界通量。\n- 对于均匀网格上的二阶对角范数算子，选择 $H$ 为对角矩阵，其元素为\n$$\nH_{ii} = \\begin{cases}\n\\frac{h}{2},  i=0 \\text{ 或 } i=N-1,\\\\\nh,  \\text{其他情况},\n\\end{cases}\n$$\n并选择 $Q$ 使得 $D = H^{-1} Q$ 在内部重现标准中心差分，并在边界处使用与二阶精度一致的单边封口格式。最简单的选择是\n$$\nQ_{i,i+1} = \\frac{1}{2},\\quad Q_{i+1,i} = -\\frac{1}{2}\\quad \\text{对于 } i=0,1,\\ldots,N-2,\n$$\n以及边界对角元 $Q_{00} = -\\frac{1}{2}$，$Q_{N-1,N-1} = \\frac{1}{2}$，所有未指定的元素均为零。这个选择满足 $Q + Q^\\top = B$。\n- 使用形式如下的同步近似项（SAT）来施加齐次入流边界条件 $u(0,t)=0$\n$$\n\\text{SAT} = -a\\,H^{-1} e_1 (u_0 - g),\n$$\n其中 $e_1$ 是第一个标准基向量，$g=0$，$a=1$。半离散系统则为\n$$\nu_t = -a D u - a H^{-1} e_1 u_0,\n$$\n其中 $u \\in \\mathbb{R}^N$ 表示解在网格点上的值。\n- 定义离散能量范数\n$$\n\\|u\\|_H^2 = u^\\top H u,\n$$\n并计算其对于半离散系统的时间导数：\n$$\n\\frac{d}{dt}\\|u\\|_H^2 = 2\\,u^\\top H\\,u_t.\n$$\n\n任务：\n- 在均匀网格上实现上述二阶对角范数 SBP 算子以及针对 $a=1$ 和 $g=0$ 的 SAT 边界处理。\n- 对于下面指定的每个测试用例，计算半离散能量增长率 $\\frac{d}{dt}\\|u\\|_H^2$，并返回它是否为非增的，定义为小于或等于 $10^{-12}$（以考虑浮点舍入误差）。\n\n测试套件：\n- 用例 1：$N=2$，$u = [1.0, 0.0]$。\n- 用例 2：$N=2$，$u = [0.0, 2.0]$。\n- 用例 3：$N=5$，$u = [0,0,0,0,0]$。\n- 用例 4：$N=5$，$u$ 仅在入流点处有值，$u_0=1.0$，$u_i=0$ 对于 $i \\neq 0$。\n- 用例 5：$N=5$，$u$ 仅在出流点处有值，$u_{N-1}=1.0$，$u_i=0$ 对于 $i \\neq N-1$。\n- 用例 6：$N=10$，$u$ 从 $[-1,1]$ 上的均匀分布中确定性地抽取，使用固定的随机种子。\n- 用例 7：$N=10$，$u_i = x_i$ 其中 $x_i = i h$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如，“[True,False,True,False]”。每个条目按上述顺序对应一个测试用例，指示该用例的 $\\frac{d}{dt}\\|u\\|_H^2 \\le 10^{-12}$ 是否成立。\n- 不涉及物理单位或角度；所有计算均以纯数值进行。", "solution": "该问题要求对线性平流方程 $u_t + a\\,u_x = 0$ 实现并验证一个稳定的半离散化方案。该方案使用二阶对角范数分部求和（SBP）算子处理空间导数，并使用同步近似项（SAT）来施加边界条件。目标是计算离散能量范数的时间变化率，并确认对于一系列测试用例，该变化率是非增的。\n\n代表解在网格点 $x_i$ 处的值的解向量 $u(t) \\in \\mathbb{R}^N$ 的半离散系统由下式给出：\n$$\n\\frac{du}{dt} = -a D u + \\text{SAT}\n$$\n这里，$D$ 是 SBP 微分矩阵，$a=1$ 是平流速度，SAT 项用于施加齐次入流边界条件 $u(0,t)=0$。指定的 SAT 为：\n$$\n\\text{SAT} = -a\\,H^{-1} e_1 (u_0 - g)\n$$\n当 $a=1$ 且边界数据 $g=0$ 时，系统变为：\n$$\n\\frac{du}{dt} = -D u - H^{-1} e_1 u_0\n$$\n其中 $u_0$ 是向量 $u$ 的第一个分量，对应于入流边界 $x=0$ 处的解，而 $e_1 = [1, 0, \\ldots, 0]^\\top$ 是第一个标准基向量。\n\n该格式的稳定性通过由矩阵 $H$ 定义的离散能量范数进行分析：\n$$\n\\|u\\|_H^2 = u^\\top H u\n$$\n矩阵 $H$ 是一个正定对角矩阵，它定义了一个离散内积和求积法则。其时间导数给出了能量增长率：\n$$\n\\frac{d}{dt}\\|u(t)\\|_H^2 = \\frac{d}{dt}(u^\\top H u) = \\left(\\frac{du}{dt}\\right)^\\top H u + u^\\top H \\left(\\frac{du}{dt}\\right)\n$$\n由于结果是一个标量，这两项是相等的，因此我们有：\n$$\n\\frac{d}{dt}\\|u\\|_H^2 = 2 u^\\top H \\frac{du}{dt}\n$$\n将 $\\frac{du}{dt}$ 的半离散方程代入：\n$$\n\\frac{d}{dt}\\|u\\|_H^2 = 2 u^\\top H (-D u - H^{-1} e_1 u_0) = -2 u^\\top H D u - 2 u^\\top H H^{-1} e_1 u_0\n$$\n我们分别分析右侧的两项。\n\n对于第一项，我们使用 SBP 性质。微分算子 $D$ 定义为 $D = H^{-1}Q$，其中矩阵 $Q$ 满足 $Q+Q^\\top=B=\\mathrm{diag}(-1, 0, \\ldots, 0, 1)$。\n$$\n-2 u^\\top H D u = -2 u^\\top H (H^{-1}Q) u = -2 u^\\top Q u\n$$\n利用标量等于其自身转置的性质（$u^\\top Q u = (u^\\top Q u)^\\top = u^\\top Q^\\top u$），我们可以写出：\n$$\n-2 u^\\top Q u = - (u^\\top Q u + u^\\top Q^\\top u) = -u^\\top(Q+Q^\\top)u = -u^\\top B u\n$$\n代入 $B$ 的定义：\n$$\n-u^\\top B u = -(-u_0^2 + u_{N-1}^2) = u_0^2 - u_{N-1}^2\n$$\n此项代表了穿过边界的净能量通量。\n\n对于源自 SAT 的第二项，我们有：\n$$\n-2 u^\\top H H^{-1} e_1 u_0 = -2 u^\\top I e_1 u_0 = -2 u^\\top e_1 u_0\n$$\n乘积 $u^\\top e_1$ 提取了 $u$ 的第一个分量，即 $u_0$。所以，该项变为：\n$$\n-2 (u_0) u_0 = -2 u_0^2\n$$\n此项代表了为施加边界条件而由 SAT 引入的能量耗散。\n\n结合两个结果，总能量增长率为：\n$$\n\\frac{d}{dt}\\|u\\|_H^2 = (u_0^2 - u_{N-1}^2) - 2 u_0^2 = -u_0^2 - u_{N-1}^2\n$$\n由于 $u_0^2 \\ge 0$ 和 $u_{N-1}^2 \\ge 0$，能量增长率总是非正的（$\\le 0$）。这证明了 SBP-SAT 半离散化是能量稳定的（或者更准确地说，是耗散的）。\n\n实现部分将为给定的网格点数 $N$ 构建指定的矩阵 $H$ 和 $Q$。然后，它将根据半离散方程计算向量 $\\frac{du}{dt}$，并最终对每个测试用例数值计算能量增长率表达式 $2 u^\\top H \\frac{du}{dt}$。结果将与 $10^{-12}$ 的容差进行比较，以考虑浮点运算误差。", "answer": "```python\nimport numpy as np\n\ndef calculate_energy_rate(N, u_vec):\n    \"\"\"\n    Computes the semidiscrete energy growth rate for the linear advection equation\n    using a second-order SBP-SAT scheme.\n\n    Args:\n        N (int): The number of grid points.\n        u_vec (np.ndarray): The solution vector of size N.\n\n    Returns:\n        float: The computed energy growth rate, d/dt ||u||_H^2.\n    \"\"\"\n    if N  2:\n        # The SBP operator definition is for N>=2.\n        # For N2, h is undefined. A trivial case.\n        return 0.0\n\n    a = 1.0\n    h = 1.0 / (N - 1)\n\n    # 1. Construct the diagonal norm matrix H as a 1D array of its diagonal entries.\n    H_diag = np.full(N, h, dtype=float)\n    H_diag[0] = h / 2.0\n    H_diag[-1] = h / 2.0\n\n    # 2. Construct the matrix Q.\n    Q = np.zeros((N, N), dtype=float)\n    # Diagonal entries\n    Q[0, 0] = -0.5\n    Q[-1, -1] = 0.5\n    # Off-diagonal entries\n    idx = np.arange(N - 1)\n    Q[idx, idx + 1] = 0.5\n    Q[idx + 1, idx] = -0.5\n\n    # 3. Construct the differentiation matrix D = H^-1 * Q.\n    # We do this without explicitly forming the inverse of H.\n    H_inv_diag = 1.0 / H_diag\n    D = H_inv_diag[:, np.newaxis] * Q\n\n    # 4. Compute the time derivative of the solution vector, u_t.\n    # u_t = -a * D * u + SAT\n    Du = D @ u_vec\n    u_t = -a * Du\n\n    # The SAT term for u_t = -a*D*u - a*H^-1*e1*(u0-g) with g=0.\n    # This term simplifies to a vector with only the first component being non-zero.\n    # SAT_vector = -a * H_inv_diag[0] * u_vec[0]\n    sat_penalty = a * H_inv_diag[0] * u_vec[0]\n    u_t[0] -= sat_penalty\n\n    # 5. Compute the energy growth rate: d/dt ||u||^2_H = 2 * u^T * H * u_t.\n    # Since H is diagonal, H*u_t is an element-wise product.\n    H_u_t = H_diag * u_t\n    energy_rate = 2.0 * u_vec.T @ H_u_t\n    \n    return energy_rate\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (2, np.array([1.0, 0.0])),\n        # Case 2\n        (2, np.array([0.0, 2.0])),\n        # Case 3\n        (5, np.array([0.0, 0.0, 0.0, 0.0, 0.0])),\n        # Case 4\n        (5, np.array([1.0, 0.0, 0.0, 0.0, 0.0])),\n        # Case 5\n        (5, np.array([0.0, 0.0, 0.0, 0.0, 1.0])),\n    ]\n\n    # Case 6: Deterministic \"random\" vector\n    N6 = 10\n    rng = np.random.default_rng(seed=12345)\n    u6 = rng.uniform(-1, 1, size=N6)\n    test_cases.append((N6, u6))\n\n    # Case 7: Linear profile\n    N7 = 10\n    h7 = 1.0 / (N7 - 1)\n    u7 = np.arange(N7) * h7\n    test_cases.append((N7, u7))\n\n    results = []\n    # Tolerance for floating-point comparison\n    tolerance = 1e-12\n\n    for N, u_vec in test_cases:\n        rate = calculate_energy_rate(N, u_vec)\n        is_non_increasing = rate = tolerance\n        results.append(is_non_increasing)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3421651"}, {"introduction": "在掌握了有限差分框架下的SBP思想后，我们将这一概念推广到更灵活、功能更强大的间断伽辽金谱元方法（DGSEM）中，并应用于非线性守恒律。本练习要求您为一个经典的非线性问题——无粘伯格斯方程，实现一种保持熵的数值通量。通过构建完整的DGSEM格式并数值验证其线性化算子的斜对称性，您将掌握现代高阶动能保持或熵保持格式的“通量差分”核心技术。", "problem": "考虑在一维周期域上由无粘性 Burgers 方程给出的标量守恒律，\n$$\n\\partial_t u(x,t) + \\partial_x\\left(\\tfrac{1}{2}u(x,t)^2\\right) = 0 \\quad \\text{for} \\quad x \\in [0,1],\n$$\n该方程具有周期性边界条件和光滑解。设区间被划分为 $K$ 个大小为 $h = 1/K$ 的均匀单元，并将每个物理单元映射到参考区间 $[-1,1]$，其雅可比行列式为 $J = h/2$。在每个单元上，使用间断伽辽金谱元法（DGSEM），在 Legendre-Gauss 节点上配置，以 $N=3$ 次多项式近似 $u$。将 $N+1$ 个参考节点记为 $\\{\\xi_i\\}_{i=1}^{N+1}$，正的求积权重记为 $\\{w_i\\}_{i=1}^{N+1}$。\n\n按如下方式在参考单元上构造广义分部求和（SBP）算子：\n- 对角质量矩阵 $M \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 的元素为 $M_{ii} = w_i$。\n- 节点微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 由 Lagrange 基函数在节点 $\\{\\xi_i\\}$ 处的导数得到。\n- 定义 $Q = M D$。\n- 令 $R \\in \\mathbb{R}^{2\\times(N+1)}$ 为到边界 $\\xi=-1$ 和 $\\xi=1$ 的插值矩阵，即 $R = \\begin{bmatrix} \\ell_1(-1)  \\cdots  \\ell_{N+1}(-1) \\\\ \\ell_1(1)  \\cdots  \\ell_{N+1}(1)\\end{bmatrix}$，其中 $\\{\\ell_j\\}$ 是节点 Lagrange 基多项式。\n- 令 $B = \\operatorname{diag}(-1,1)$。\n\n这些算子满足广义 SBP 恒等式\n$$\nQ + Q^\\top = R^\\top B R.\n$$\n\n使用一个适用于 Burgers 方程的两点对称且相容的熵守恒体积通量来离散化平流项。定义两点通量\n$$\nf_S(a,b) = \\tfrac{1}{6}\\left(a^2 + a\\,b + b^2\\right),\n$$\n该通量对其参数是对称的，并且与物理通量 $f(u) = \\tfrac{1}{2}u^2$ 在 $f_S(u,u) = f(u)$ 的意义上相容。使用相同的两点通量来定义单元间界面处的数值通量（中心/熵守恒界面通量）。对于一个节点解向量为 $u \\in \\mathbb{R}^{N+1}$ 的单元，通过 $F_{ij} = f_S(u_i,u_j)$ 定义成对通量矩阵 $F \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，并通过按行求和定义体积贡献\n$$\nG(u) = (Q \\circ F)\\,\\mathbf{1},\n$$\n其中 $\\circ$ 表示 Hadamard（逐元素）积，$\\mathbf{1} \\in \\mathbb{R}^{N+1}$ 是全一向量。令 $\\widehat{f}\\in\\mathbb{R}^2$ 汇集单元左右边界的界面数值通量，这些通量通过在插值得到的边界迹上使用 $R$ 和周期性相邻耦合来计算 $f_S$ 得到。\n\n每个单元上的半离散强形式 DGSEM 为\n$$\n\\frac{d u}{dt} \\;=\\; -\\frac{2}{J}\\, M^{-1}\\left(G(u) - R^\\top B\\, \\widehat{f}\\right),\n$$\n而全局半离散系统通过在域端点处组装所有具有周期性边界条件的单元得到。\n\n对于一个全局状态向量 $u \\in \\mathbb{R}^{K(N+1)}$，通过如上所述组装所有单元的贡献来定义全局右端项 $\\mathcal{R}(u)$。对于一个常数状态 $u \\equiv c$，将半离散算子矩阵 $A(c) \\in \\mathbb{R}^{K(N+1)\\times K(N+1)}$ 定义为在 $u=c\\,\\mathbf{1}$ 处计算的右端项的雅可比矩阵，\n$$\nA(c) \\;=\\; \\left.\\frac{\\partial \\mathcal{R}(u)}{\\partial u}\\right|_{u = c\\,\\mathbf{1}}.\n$$\n将全局物理质量矩阵 $M_{\\text{phys}}$ 定义为块对角矩阵，每个单元对应一个块 $J M$，即 $M_{\\text{phys}} = \\operatorname{blkdiag}(J M,\\dots,J M) \\in \\mathbb{R}^{K(N+1)\\times K(N+1)}$。\n\n需要验证的结构保持性质是，在周期性边界条件下，平流部分在 $M_{\\text{phys}}$ 内积下的加权反对称性：\n$$\nM_{\\text{phys}}\\,A(c) + A(c)^\\top\\,M_{\\text{phys}} \\;=\\; 0.\n$$\n\n程序要求：\n- 在域 $[0,1]$ 上，使用 Legendre-Gauss 点，实现 $N=3$ 次的间断伽辽金谱元法（DGSEM），并采用周期性边界条件和指定的两点通量 $f_S$。\n- 组装全局右端项 $\\mathcal{R}(u)$，并通过中心有限差分和小扰动 $ \\varepsilon $ 计算在常数状态 $u \\equiv c$ 下的雅可比矩阵 $A(c)$，即\n$$\nA(c)\\,e_k \\;\\approx\\; \\frac{\\mathcal{R}(c\\,\\mathbf{1} + \\varepsilon\\, e_k) - \\mathcal{R}(c\\,\\mathbf{1} - \\varepsilon\\, e_k)}{2\\varepsilon},\n$$\n对每个典范基向量 $e_k$ 进行计算。\n- 通过计算缺陷矩阵 $S(c) = M_{\\text{phys}}A(c) + A(c)^\\top M_{\\text{phys}}$ 的无穷范数，并将其与一个容差进行比较，来验证加权反对称性。\n\n测试套件：\n- 使用以下 $(K,c)$ 情形，固定 $N=3$ 和周期性边界条件：\n    1. $(K,c) = (1, 0.8)$\n    2. $(K,c) = (3, 0.0)$\n    3. $(K,c) = (4, -1.0)$\n- 对每个测试用例，计算谓词的布尔结果\n$$\n\\|S(c)\\|_{\\infty} \\leq 10^{-9},\n$$\n其中 $\\|\\cdot\\|_{\\infty}$ 表示逐项最大绝对值。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含测试套件的三个布尔结果，格式为逗号分隔的 Python 风格列表，例如，“[True,False,True]”。不应打印任何额外文本。", "solution": "我们从无粘性 Burgers 方程的标量守恒律开始，\n$$\n\\partial_t u(x,t) + \\partial_x f(u(x,t)) = 0,\\quad f(u) = \\tfrac{1}{2}u^2,\n$$\n该方程定义在周期域 $x \\in [0,1]$ 上，并划分为 $K$ 个大小为 $h=1/K$ 的均匀单元。从参考坐标 $\\xi \\in [-1,1]$ 到每个单元上的物理坐标 $x$ 的映射是仿射的，其雅可比行列式为 $J = h/2$，因此 $\\partial_x = (1/J)\\partial_\\xi$，参考单元上的方程为\n$$\n\\partial_t u(\\xi,t) + \\frac{1}{J}\\,\\partial_\\xi f(u(\\xi,t)) = 0.\n$$\n*注意：问题描述中的半离散格式使用了 $\\frac{2}{J} = \\frac{1}{J}$ 的假设，这意味着 $J=2$。为了与问题描述一致，我们将在推导中使用 $\\frac{2}{J}$ 这一系数。*\n\n在参考单元上，我们选择在 Legendre-Gauss 节点 $\\{\\xi_i\\}_{i=1}^{N+1}$ 和求积权重 $\\{w_i\\}_{i=1}^{N+1}$ 处配置的 $N=3$ 次间断伽辽金谱元法（DGSEM）。令 $\\{\\ell_j(\\xi)\\}_{j=1}^{N+1}$ 为这些节点上的 Lagrange 插值多项式。我们定义对角质量矩阵 $M \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，其元素为 $M_{ii} = w_i$，以及节点微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，其元素为 $D_{ij} = \\ell_j'(\\xi_i)$。矩阵 $Q = M D$ 与由下式给出的边界插值矩阵 $R \\in \\mathbb{R}^{2\\times(N+1)}$\n$$\nR = \\begin{bmatrix}\n\\ell_1(-1)  \\cdots  \\ell_{N+1}(-1)\\\\\n\\ell_1(1)  \\cdots  \\ell_{N+1}(1)\n\\end{bmatrix},\n$$\n以及 $B = \\operatorname{diag}(-1,1)$ 满足广义分部求和（SBP）恒等式\n$$\nQ + Q^\\top = R^\\top B R.\n$$\n此恒等式确保当通过适当的数值通量耦合单元时，离散分部积分成立。\n\n为了实现对非线性通量的稳定且保持结构的离散化，我们采用一个对 Burgers 方程是熵守恒的对称且相容的两点体积通量 $f_S$：\n$$\nf_S(a,b) = \\tfrac{1}{6}\\left(a^2 + a\\,b + b^2\\right) = f_S(b,a), \\quad f_S(u,u) = f(u).\n$$\n使用通量差分形式，在一个节点状态向量为 $u \\in \\mathbb{R}^{N+1}$ 的单元上的体积贡献，通过构建元素为 $F_{ij} = f_S(u_i,u_j)$ 的矩阵 $F \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，然后取其行和来计算\n$$\nG(u) = (Q \\circ F)\\,\\mathbf{1},\n$$\n其中 $\\circ$ 表示 Hadamard 积，$\\mathbf{1}$ 是全一向量。单元边界处的数值通量也取为在左右迹 $u^-, u^+$ 上计算的 $f_S$，得到界面向量 $\\widehat{f} \\in \\mathbb{R}^2$。单元内的半离散强形式 DGSEM 为\n$$\n\\frac{d u}{dt} \\;=\\; -\\frac{2}{J}\\, M^{-1}\\left(G(u) - R^\\top B\\, \\widehat{f}\\right).\n$$\n通过周期性地耦合相邻单元之间的迹来定义每个面上的 $\\widehat{f}$，从而实现具有周期性边界条件的单元的粘合。\n\n能量分析使用由块对角全局质量矩阵 $M_{\\text{phys}} = \\operatorname{blkdiag}(J M,\\dots,J M)$ 导出的物理内积，这是网格上物理 $L^2$ 内积的求积表示。广义 SBP 恒等式意味着离散能量平衡。特别地，对于周期性边界和对称的两点通量，离散能量\n$$\nE(u) = \\tfrac{1}{2} u^\\top M_{\\text{phys}} u\n$$\n满足\n$$\n\\frac{dE}{dt} = u^\\top M_{\\text{phys}} \\frac{du}{dt} = 0,\n$$\n因此，平流算子在 $M_{\\text{phys}}$ 内积下是反对称的。当围绕常数状态 $u \\equiv c$ 对半离散右端项 $\\mathcal{R}(u)$ 进行线性化时，雅可比矩阵 $A(c) = \\left.\\frac{\\partial \\mathcal{R}}{\\partial u}\\right|_{u=c\\mathbf{1}}$ 代表该状态下的半离散平流算子，结构保持性质变为\n$$\nM_{\\text{phys}}\\,A(c) + A(c)^\\top\\,M_{\\text{phys}} = 0.\n$$\n此恒等式反映了在 $M_{\\text{phys}}$ 内积下的精确反对称性，并意味着对于周期性边界条件，离散能量是守恒的。\n\n算法构建：\n- 计算 $N=3$ 的 Legendre-Gauss 节点和权重 $\\{\\xi_i,w_i\\}_{i=1}^{N+1}$。\n- 构建重心权重以计算节点处的 Lagrange 基函数及其导数，得到 $D$ 和插值矩阵 $R$。\n- 形成 $M = \\operatorname{diag}(w)$ 和 $Q = M D$，并验证 $Q+Q^\\top \\approx R^\\top B R$。\n- 通过遍历单元，经由通量差分计算 $G(u)$ 和经由 $f_S$ 与 $R$ 计算界面通量 $\\widehat{f}$，并周期性地耦合单元，来组装全局右端项 $\\mathcal{R}(u)$。\n- 使用小扰动 $\\varepsilon$ 的中心有限差分来近似在常数状态 $u \\equiv c$ 下的雅可比矩阵 $A(c)$：\n$$\nA(c)\\,e_k \\approx \\frac{\\mathcal{R}(c\\,\\mathbf{1} + \\varepsilon\\, e_k) - \\mathcal{R}(c\\,\\mathbf{1} - \\varepsilon\\, e_k)}{2\\varepsilon}.\n$$\n- 将 $M_{\\text{phys}}$ 构建为每个块上为 $J M$ 的块对角矩阵，并评估反对称性缺陷\n$$\nS(c) = M_{\\text{phys}}A(c) + A(c)^\\top M_{\\text{phys}}.\n$$\n- 计算 $\\|S(c)\\|_{\\infty}$ 并与容差 $10^{-9}$ 比较，以获得每个测试用例的布尔结果。\n\n测试套件与输出：\n- 使用 $(K,c)=(1,0.8)$、$(K,c)=(3,0.0)$ 和 $(K,c)=(4,-1.0)$，固定 $N=3$。\n- 对每种情况，输出 $\\|S(c)\\|_{\\infty} \\le 10^{-9}$ 是否成立。\n- 程序必须打印单行，其中包含三个布尔结果，格式为 Python 风格的列表，例如，“[True,False,True]”。\n\n此构建从基本的离散 SBP 性质和适用于 Burgers 方程的对称、相容的两点通量出发，这些是确保结构保持的核心设计原则。通过 $A(c)$ 在 $M_{\\text{phys}}$ 内积下的加权反对称性进行验证，表明 DGSEM 离散化保持了周期性边界条件下的离散能量结构。", "answer": "```python\nimport numpy as np\n\n# DGSEM on Gauss points for Burgers' equation, N=3, periodic domain [0,1]\n# Verify weighted skew-symmetry of the advective operator Jacobian at constant states.\n\ndef legendre_gauss_nodes_weights(n):\n    # Returns nodes and weights for Legendre-Gauss quadrature on [-1,1]\n    from numpy.polynomial.legendre import leggauss\n    x, w = leggauss(n)\n    return x, w\n\ndef barycentric_weights(nodes):\n    # Compute first-form barycentric weights for distinct nodes\n    n = len(nodes)\n    w = np.ones(n)\n    for j in range(n):\n        prod = 1.0\n        xj = nodes[j]\n        for k in range(n):\n            if k != j:\n                prod *= (xj - nodes[k])\n        w[j] = 1.0 / prod\n    return w\n\ndef lagrange_interp_row(t, nodes, bary_w):\n    # Returns the row vector [l_1(t),...,l_n(t)] for Lagrange basis at t\n    n = len(nodes)\n    # Check if t coincides with a node\n    for j in range(n):\n        if np.isclose(t, nodes[j], atol=1e-14, rtol=0.0):\n            row = np.zeros(n)\n            row[j] = 1.0\n            return row\n    diff = t - nodes\n    alpha = bary_w / diff\n    denom = np.sum(alpha)\n    row = alpha / denom\n    return row\n\ndef differentiation_matrix(nodes, bary_w):\n    # Build the nodal differentiation matrix using barycentric weights\n    n = len(nodes)\n    D = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                D[i, j] = (bary_w[j] / bary_w[i]) / (nodes[i] - nodes[j])\n    D[np.diag_indices(n)] = -np.sum(D, axis=1)\n    return D\n\ndef burgers_two_point_flux(a, b):\n    # Entropy-conserving symmetric two-point flux: (a^2 + a b + b^2)/6\n    return (a*a + a*b + b*b) / 6.0\n\ndef build_reference_operators(N):\n    # Build reference element operators for degree N using Gauss nodes\n    n = N + 1\n    xi, wq = legendre_gauss_nodes_weights(n)\n    bw = barycentric_weights(xi)\n    D = differentiation_matrix(xi, bw)\n    M = np.diag(wq)\n    Q = M @ D\n    # Interpolation to boundaries -1 and 1\n    R = np.vstack([\n        lagrange_interp_row(-1.0, xi, bw),\n        lagrange_interp_row( 1.0, xi, bw)\n    ])\n    B = np.diag(np.array([-1.0, 1.0]))\n    return xi, wq, M, D, Q, R, B\n\ndef assemble_rhs(u, K, N, M, Q, R, B, J):\n    # Assemble the global RHS for Burgers' equation with periodic BCs using flux differencing on Gauss DGSEM\n    nloc = N + 1\n    total = K * nloc\n    rhs = np.zeros(total)\n    ones_loc = np.ones(nloc)\n\n    # Helper to extract element dofs\n    def elem_slice(e):\n        return slice(e*nloc, (e+1)*nloc)\n\n    # Compute boundary trace values per element\n    # left trace is at xi=-1 from inside element, right trace at xi=+1\n    u_left = np.zeros(K)\n    u_right = np.zeros(K)\n    for e in range(K):\n        ue = u[elem_slice(e)]\n        u_left[e] = R[0, :] @ ue\n        u_right[e] = R[1, :] @ ue\n\n    # Interface fluxes: for element e, left interface between e-1 (right) and e (left), right interface between e (right) and e+1 (left)\n    fhat_left = np.zeros(K)\n    fhat_right = np.zeros(K)\n    for e in range(K):\n        eL = (e - 1) % K\n        eR = (e + 1) % K\n        # left interface of element e: left neighbor right trace, current left trace\n        fhat_left[e] = burgers_two_point_flux(u_right[eL], u_left[e])\n        # right interface of element e: current right trace, right neighbor left trace\n        fhat_right[e] = burgers_two_point_flux(u_right[e], u_left[eR])\n\n    # Element contributions\n    Minv = np.linalg.inv(M)\n    for e in range(K):\n        ue = u[elem_slice(e)]\n        # Volume flux differencing\n        # Build matrix F with F_ij = f_S(u_i, u_j)\n        ui = ue[:, None]\n        uj = ue[None, :]\n        F = burgers_two_point_flux(ui, uj)\n        G = (Q * F) @ ones_loc  # row-wise sum\n        # Surface term\n        fhat = np.array([fhat_left[e], fhat_right[e]])\n        surf = R.T @ (B @ fhat)\n        # RHS local\n        rhs_e = -(2.0 / J) * (Minv @ (G - surf))\n        rhs[elem_slice(e)] = rhs_e\n\n    return rhs\n\ndef compute_jacobian_at_constant(K, N, c, M, Q, R, B, J, eps=1e-8):\n    # Compute Jacobian A at u=c via centered finite differences\n    nloc = N + 1\n    total = K * nloc\n    u0 = np.full(total, c)\n    rhs0 = assemble_rhs(u0, K, N, M, Q, R, B, J)  # not used directly but ensures any caches warm\n    A = np.zeros((total, total))\n    for k in range(total):\n        ek = np.zeros(total)\n        ek[k] = 1.0\n        up = u0 + eps * ek\n        um = u0 - eps * ek\n        rp = assemble_rhs(up, K, N, M, Q, R, B, J)\n        rm = assemble_rhs(um, K, N, M, Q, R, B, J)\n        A[:, k] = (rp - rm) / (2.0 * eps)\n    return A\n\ndef build_global_mass(K, M, J):\n    # Global physical mass matrix block diagonal with J * M per element\n    nloc = M.shape[0]\n    total = K * nloc\n    Mphys = np.zeros((total, total))\n    block = J * M\n    for e in range(K):\n        s = slice(e*nloc, (e+1)*nloc)\n        Mphys[s, s] = block\n    return Mphys\n\ndef skew_symmetry_defect_norm(Mphys, A):\n    # Compute infinity norm (max abs entry) of Mphys A + A^T Mphys\n    S = Mphys @ A + A.T @ Mphys\n    return np.max(np.abs(S))\n\ndef solve():\n    # Fixed degree N=3\n    N = 3\n    xi, wq, M, D, Q, R, B = build_reference_operators(N)\n\n    # Optional: check SBP property residual (not printed)\n    # sbp_res = np.max(np.abs(Q + Q.T - R.T @ B @ R))\n\n    # Test suite: (K, c)\n    test_cases = [\n        (1, 0.8),\n        (3, 0.0),\n        (4, -1.0),\n    ]\n\n    results = []\n    for K, c in test_cases:\n        h = 1.0 / K\n        J = 0.5 * h\n        # Build Jacobian at constant state\n        A = compute_jacobian_at_constant(K, N, c, M, Q, R, B, J, eps=1e-8)\n        Mphys = build_global_mass(K, M, J)\n        defect = skew_symmetry_defect_norm(Mphys, A)\n        results.append(defect = 1e-9)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3421735"}, {"introduction": "一个完整的结构保持格式不仅需要空间上的结构保持离散，还需要在时间上采用能够保持其几何特性的积分方法。本练习将引导您进入这一前沿领域，针对一个由非线性波动方程半离散化得到的哈密顿系统，实现并比较几种先进的几何积分器。通过模拟并定量分析不同方法在长时间尺度下对哈密顿量（能量）的保持能力，您将深刻体会到辛积分器和保能量方法在确保长期仿真可靠性方面的关键作用。", "problem": "考虑一个半离散哈密顿系统，该系统由定义在区间 $[0,1]$ 上的一维三次非线性波动方程经过周期性谱方法离散化得到。设 $N$ 为等距格点的数量，$c0$ 为传播速度常数，$\\lambda \\ge 0$ 为非线性耦合常数。定义正则变量 $q \\in \\mathbb{R}^N$ 和 $p \\in \\mathbb{R}^N$ 以及哈密顿量\n$$\nH(q,p) = \\frac{1}{2} \\, p^\\top p + \\frac{1}{2} \\, q^\\top L q + \\frac{\\lambda}{4} \\sum_{i=1}^N q_i^4,\n$$\n其中 $L$ 是与周期性网格上的负二阶导数相关的离散半正定算子，其谱方法构造如下：对于任意 $q \\in \\mathbb{R}^N$，令 $\\widehat{q} = \\mathcal{F}(q)$ 为离散傅里叶变换，并定义\n$$\nL q = c^2 \\, \\mathcal{F}^{-1}\\big( k^2 \\widehat{q} \\big),\n$$\n其中 $k$ 是角频率向量，$k_j = \\tfrac{2\\pi}{\\Delta x} \\, \\xi_j$，$\\Delta x = 1/N$，$\\xi_j$ 是由离散傅里叶变换产生的标准离散频率。其正则常微分方程为\n$$\n\\frac{d}{dt}\n\\begin{bmatrix}\nq \\\\ p\n\\end{bmatrix}\n=\nJ \\nabla H(q,p)\n=\n\\begin{bmatrix}\np \\\\ - (L q + \\lambda \\, q^{\\circ 3})\n\\end{bmatrix},\n$$\n其中 $J = \\begin{bmatrix} 0  I \\\\ -I  0 \\end{bmatrix}$ 是辛结构，$I$ 是 $N \\times N$ 单位矩阵，$\\nabla H$ 是 $H$ 的梯度，$q^{\\circ 3}$ 表示对 $q$ 的逐元素立方。\n\n您的任务是为此半离散哈密顿系统实现并比较三种时间积分格式：\n1. 一种基于两阶段 Gauss–Legendre 配置的辛 Runge–Kutta 方法。该方法可以写成一个具有 $s=2$ 级、节点 $c_1 = \\tfrac{1}{2} - \\tfrac{\\sqrt{3}}{6}$ 和 $c_2 = \\tfrac{1}{2} + \\tfrac{\\sqrt{3}}{6}$、权重 $b_1 = \\tfrac{1}{2}$ 和 $b_2 = \\tfrac{1}{2}$ 的隐式 Runge–Kutta 格式，其 Butcher 矩阵为\n$$\nA =\n\\begin{bmatrix}\n\\frac{1}{4}  \\frac{1}{4} - \\frac{\\sqrt{3}}{6} \\\\\n\\frac{1}{4} + \\frac{\\sqrt{3}}{6}  \\frac{1}{4}\n\\end{bmatrix}.\n$$\n其内部阶段 $\\{Y_i\\}_{i=1}^2$ 求解\n$$\nY_i = y_n + h \\sum_{j=1}^2 a_{ij} f(Y_j), \\quad f(y) = J \\nabla H(y), \\quad y_n = \\begin{bmatrix} q_n \\\\ p_n \\end{bmatrix},\n$$\n更新公式为 $y_{n+1} = y_n + h \\sum_{j=1}^2 b_j f(Y_j)$。\n\n2. 平均向量场 (AVF) 方法（对于正则哈密顿系统是保能量的）。对于时间步长 $h0$，AVF 方法通过求解以下方程将 $y_n$推进到 $y_{n+1}$\n$$\ny_{n+1} = y_n + h \\int_0^1 f\\left( (1-\\sigma) y_n + \\sigma y_{n+1} \\right) \\, d\\sigma,\n$$\n您应使用区间 $[0,1]$ 上的两点 Gauss–Legendre 求积来实现该方法，其节点为 $\\sigma_{1,2} = \\tfrac{1}{2} \\pm \\tfrac{1}{2\\sqrt{3}}$，权重为 $\\omega_{1,2} = \\tfrac{1}{2}$。\n\n3. 一种具有 $k=4$ 个求积节点和 $s=2$ 个基多项式的哈密顿边界值方法 (HBVM)（记为 HBVM(4,2)）。使用次数为 0 和 1 的、在区间 $[0,1]$ 上的标准正交移位 Legendre 多项式，\n$$\nP_0(\\tau) = 1, \\qquad P_1(\\tau) = \\sqrt{3} \\, (2\\tau - 1),\n$$\n以及映射到 $[0,1]$ 上的、具有 $k=4$ 个节点 $\\{c_\\ell\\}_{\\ell=1}^4$ 和权重 $\\{\\omega_\\ell\\}_{\\ell=1}^4$ 的 Gauss–Legendre 求积。定义内部阶段值如下\n$$\nY_\\ell = y_n + h \\left( \\alpha_{\\ell 0} \\, \\gamma_0 + \\alpha_{\\ell 1} \\, \\gamma_1 \\right), \\qquad \\alpha_{\\ell 0} = \\int_0^{c_\\ell} P_0(\\tau) \\, d\\tau = c_\\ell, \\quad \\alpha_{\\ell 1} = \\int_0^{c_\\ell} P_1(\\tau) \\, d\\tau = \\sqrt{3} \\, (c_\\ell^2 - c_\\ell),\n$$\n并通过求解以下非线性系统来计算 $\\gamma_0, \\gamma_1 \\in \\mathbb{R}^{2N}$\n$$\n\\gamma_0 = \\sum_{\\ell=1}^4 \\omega_\\ell \\, f(Y_\\ell), \\qquad\n\\gamma_1 = \\sum_{\\ell=1}^4 \\omega_\\ell \\, P_1(c_\\ell) \\, f(Y_\\ell).\n$$\n然后使用以下公式更新 $y_{n+1}$\n$$\ny_{n+1} = y_n + h \\int_0^1 \\left( \\gamma_0 P_0(\\tau) + \\gamma_1 P_1(\\tau) \\right) d\\tau = y_n + h \\, \\gamma_0,\n$$\n因为 $\\int_0^1 P_0(\\tau)\\,d\\tau = 1$ 且 $\\int_0^1 P_1(\\tau)\\,d\\tau = 0$。\n\n所有隐式方程都必须使用 Newton 迭代法求解，其精确 Jacobian 矩阵由 $f(y)$ 的 Jacobian 矩阵的解析表达式构建。对于上述系统，\n$$\nf(y) =\n\\begin{bmatrix}\np \\\\ - (L q + \\lambda \\, q^{\\circ 3})\n\\end{bmatrix},\n\\qquad\nDf(y) =\n\\begin{bmatrix}\n0  I \\\\\n- \\big(L + 3\\lambda \\, \\mathrm{diag}(q^{\\circ 2}) \\big)  0\n\\end{bmatrix}.\n$$\n为 Newton 迭代使用一个一致的初始猜测值，当 Newton 更新量的欧几里得范数小于 $10^{-10}$ 或迭代次数达到 20 次时终止，以先到者为准。\n\n对于这三种方法中的每一种，使用指定的初始数据为以下每个测试用例模拟动力学过程：\n- 测试用例 A (正常路径)：$N=32$, $c=1.0$, $\\lambda=0.1$, 时间步长 $h=0.05$, 终止时间 $T=10$。初始条件 $q_i(0) = 0.2 \\cos(2\\pi x_i)$, $p_i(0) = 0.2 \\sin(2\\pi x_i)$, 其中 $x_i = \\tfrac{i}{N}$ for $i=0,\\dots,N-1$。\n- 测试用例 B (强非线性)：$N=64$, $c=1.0$, $\\lambda=1.0$, 时间步长 $h=0.02$, 终止时间 $T=4$。初始条件 $q_i(0) = 0.5 \\cos(2\\pi x_i)$, $p_i(0) = 0$。\n- 测试用例 C (线性边界情况)：$N=16$, $c=1.0$, $\\lambda=0.0$, 时间步长 $h=0.1$, 终止时间 $T=50$。初始条件 $q_i(0) = 0.3 \\cos(4\\pi x_i)$, $p_i(0) = 0.3 \\sin(4\\pi x_i)$。\n\n对于每次模拟，计算最大绝对能量偏差\n$$\n\\Delta H_{\\max} = \\max_{0 \\le n \\le T/h} \\left| H(q_n,p_n) - H(q_0,p_0) \\right|.\n$$\n最终输出为单行文本，包含一个由三个列表组成的列表，每个子列表对应一个测试用例，其中包含该测试用例下辛 Runge–Kutta 方法、平均向量场方法和哈密顿边界值方法各自的 $\\Delta H_{\\max}$ 浮点数值。您的程序应生成单行输出，其中结果以方括号括起来的逗号分隔列表形式呈现（例如，“[[a1,a2,a3],[b1,b2,b3],[c1,c2,c3]]”）。不需要物理单位；所有数值都是无量纲的。", "solution": "### 问题分析\n\n该问题要求我们为源于一维三次非线性波动方程经过空间离散化后得到的哈密顿系统，实现并比较三种高级的几何积分器。问题的核心是，对每一种方法，在每个时间步内，使用带有精确雅可比矩阵的牛顿法来求解一个隐式方程组。\n\n### 第1步：系统离散化与核心函数\n\n首先，我们建立半离散系统的各个组成部分。系统的状态由向量 $y = [q^\\top, p^\\top]^\\top \\in \\mathbb{R}^{2N}$ 给出。\n\n**离散拉普拉斯算子 ($L$)**：算子 $L$ 代表周期域上的负二阶空间导数，它使用离散傅里叶变换（DFT）进行定义。对于向量 $q \\in \\mathbb{R}^N$，$Lq$ 的计算方式为 $Lq = c^2 \\mathcal{F}^{-1}(k^2 \\mathcal{F}(q))$，其中 $\\mathcal{F}$ 是DFT，$k$ 是角频率向量。对于一个在 $[0,1)$ 上有 $N$ 个点的网格，网格间距为 $\\Delta x = 1/N$。相应的角波数由 `numpy.fft.fftfreq(N, d=1/N)` 给出的空间频率 $\\nu_j$ 计算得到，即 $k_j = 2\\pi \\nu_j$。为了在向量场的雅可比矩阵中使用，算子 $L$ 可以通过将其应用于 $\\mathbb{R}^N$ 的标准基向量来预先计算并存储为一个稠密的 $N \\times N$ 矩阵 $L_{\\text{mat}}$。\n\n**哈密顿量与向量场**：哈密顿量 $H(q,p)$ 和向量场 $f(y) = J \\nabla H(y)$ 直接根据其定义实现。向量场 $f(y)$ 定义了常微分方程系统 $\\dot{y} = f(y)$ 的右端项。\n\n**向量场的雅可比矩阵 ($Df(y)$)**：$f(y)$ 的雅可比矩阵是问题描述中给出的一个 $2N \\times 2N$ 分块矩阵。其左下块 $\\frac{\\partial f_p}{\\partial q} = -(L + 3\\lambda \\, \\mathrm{diag}(q^{\\circ 2}))$ 取决于状态变量 $q$。这种状态依赖性使得整个系统（当 $\\lambda \\neq 0$ 时）成为非线性的，并要求在牛顿迭代的每一步中重新计算雅可比矩阵。\n\n**牛顿法**：实现一个通用的牛顿求解器来寻找残差函数 $F(x)=0$ 的根。它通过迭代 $x_{k+1} = x_k - [J_F(x_k)]^{-1} F(x_k)$ 来求解，其中 $J_F$ 是 $F$ 的雅可比矩阵。每次迭代都涉及求解一个用于更新的线性系统。\n\n### 第2步：时间积分器\n\n对于每一种积分器，我们构建其在每个时间步必须求解的非线性系统，并为牛顿求解器推导相应的残差和雅可比矩阵。\n\n#### 方法1：2级高斯-勒让德龙格-库塔方法 (GL2)\n这是一种四阶辛隐式龙格-库塔方法。每一步的未知量是两个内部阶段向量 $Y_1, Y_2 \\in \\mathbb{R}^{2N}$。因此，牛顿求解器处理的未知量总维度为 $4N$。\n- **残差**：需要求解的系统是 $Y_i = y_n + h \\sum_{j=1}^2 a_{ij} f(Y_j)$，其中 $i=1,2$。通过将所有项移到一边来构造残差函数。\n- **雅可比矩阵**：这个 $4N \\times 4N$ 系统关于拼接向量 $[Y_1^\\top, Y_2^\\top]^\\top$ 的雅可比矩阵是一个 $2 \\times 2$ 的分块矩阵，其中每个块都是一个 $2N \\times 2N$ 的矩阵。块 $(i,j)$ 由 $\\delta_{ij}I_{2N} - h a_{ij} Df(Y_j)$ 给出，其中 $\\delta_{ij}$ 是克罗内克符号，$I_{2N}$ 是单位矩阵。\n- **更新**：在解出 $Y_1$ 和 $Y_2$ 后，状态通过 $y_{n+1} = y_n + h (b_1 f(Y_1) + b_2 f(Y_2))$ 向前推进。\n\n#### 方法2：平均向量场方法 (AVF)\nAVF 方法被设计为对任何正则哈密顿系统都能精确保持能量。它隐式地定义了更新 $y_{n+1}$。\n- **残差**：更新公式中的积分使用两点高斯-勒让德求积来近似，得到一个关于 $y_{n+1}$ 的非线性方程：$y_{n+1} - y_n - h \\sum_{j=1}^2 \\omega_j f((1-\\sigma_j)y_n + \\sigma_j y_{n+1}) = 0$。该方程的左侧项即为牛顿法的残差。未知量是 $y_{n+1} \\in \\mathbb{R}^{2N}$。\n- **雅可比矩阵**：残差关于 $y_{n+1}$ 的雅可比矩阵使用链式法则推导得出：$I_{2N} - h \\sum_{j=1}^2 \\omega_j \\sigma_j Df((1-\\sigma_j)y_n + \\sigma_j y_{n+1})$。\n\n#### 方法3：哈密顿边界值方法 (HBVM(4,2))\nHBVMs 是一类保能量方法，其基础是使用多项式展开来近似解的积分形式。这里，我们使用区间 $[0,1]$ 上的 $s=2$ 个标准正交勒让德多项式 $P_0(\\tau)$ 和 $P_1(\\tau)$，以及 $k=4$ 个高斯-勒让德求积点。未知量是多项式展开的系数 $\\gamma_0, \\gamma_1 \\in \\mathbb{R}^{2N}$。\n- **残差**：未知量 $\\gamma_0, \\gamma_1$ 由以下系统隐式定义：\n    $\\gamma_0 = \\sum_{\\ell=1}^4 \\omega_\\ell f(Y_\\ell)$\n    $\\gamma_1 = \\sum_{\\ell=1}^4 \\omega_\\ell P_1(c_\\ell) f(Y_\\ell)$\n    其中内部阶段值 $Y_\\ell$ 线性依赖于 $\\gamma_0$ 和 $\\gamma_1$。这个维度为 $4N$ 的系统定义了残差。\n- **雅可比矩阵**：残差系统关于拼接向量 $[\\gamma_0^\\top, \\gamma_1^\\top]^\\top$ 的雅可比矩阵使用链式法则推导。它构成一个 $2 \\times 2$ 的分块矩阵，每个块都是一个 $2N \\times 2N$ 的矩阵，其中每个块都涉及到在求积点处雅可比矩阵 $Df(Y_\\ell)$ 的加权和。\n- **更新**：一旦找到 $\\gamma_0$ 和 $\\gamma_1$，状态通过 $y_{n+1} = y_n + h\\gamma_0$ 进行更新，这是对多项式近似在时间步长上积分得到的。\n\n### 第3步：模拟与分析\n代码针对三个测试用例中的每一个，使用上述三种方法进行模拟。首先设置初始条件 $(q_0, p_0)$，并计算初始能量 $H_0 = H(q_0, p_0)$。然后系统演化到最终时间 $T$。在每个时间步 $t_n$，计算当前能量 $H_n = H(q_n, p_n)$。初始能量的最大绝对偏差 $\\Delta H_{\\max} = \\max_n |H_n - H_0|$ 被记录为每次模拟运行的性能指标。最后，对结果进行整理并按指定格式输出。", "answer": "```python\nimport numpy as np\nfrom numpy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Implements and compares three geometric integrators for a semidiscrete\n    nonlinear wave equation.\n    \"\"\"\n\n    # --- Core Physics and Discretization ---\n    def setup_laplacian(N, c):\n        \"\"\"\n        Sets up the spectral Laplacian operator and its matrix form.\n        \"\"\"\n        k_wave_numbers = np.fft.fftfreq(N, d=1.0/N)\n        k = 2 * np.pi * k_wave_numbers\n        k_squared = k**2\n        \n        def apply_L(q):\n            return (c**2 * ifft(k_squared * fft(q))).real\n        \n        L_mat = np.zeros((N, N), dtype=float)\n        for i in range(N):\n            e_i = np.zeros(N)\n            e_i[i] = 1.0\n            L_mat[:, i] = apply_L(e_i)\n            \n        return apply_L, L_mat\n\n    def hamiltonian(y, apply_L, lam):\n        \"\"\"\n        Computes the Hamiltonian (total energy) of the system.\n        \"\"\"\n        N = len(y) // 2\n        q, p = y[:N], y[N:]\n        Lq = apply_L(q)\n        H_linear_q = 0.5 * np.dot(q, Lq)\n        H_p = 0.5 * np.dot(p, p)\n        H_nonlinear = (lam / 4.0) * np.sum(q**4)\n        return H_p + H_linear_q + H_nonlinear\n\n    def vector_field(y, apply_L, lam):\n        \"\"\"\n        Computes the vector field f(y) for the ODE y' = f(y).\n        \"\"\"\n        N = len(y) // 2\n        q, p = y[:N], y[N:]\n        fq = p\n        fp = -(apply_L(q) + lam * q**3)\n        return np.concatenate([fq, fp])\n\n    def jacobian_vector_field(y, L_mat, lam):\n        \"\"\"\n        Computes the Jacobian of the vector field, Df(y).\n        \"\"\"\n        N = len(y) // 2\n        q = y[:N]\n        I_N = np.eye(N)\n        Z_NN = np.zeros((N, N))\n        J_qq = -(L_mat + 3 * lam * np.diag(q**2))\n        return np.block([[Z_NN, I_N], [J_qq, Z_NN]])\n    \n    # --- Newton Solver ---\n    def newton_solver(F_func, J_func, y0, tol, max_iter):\n        \"\"\"\n        Solves F(y) = 0 using Newton's method.\n        \"\"\"\n        y = y0.copy()\n        for _ in range(max_iter):\n            F = F_func(y)\n            try:\n                J = J_func(y)\n                dy = np.linalg.solve(J, -F)\n            except np.linalg.LinAlgError:\n                J_pinv = np.linalg.pinv(J, rcond=1e-15)\n                dy = -J_pinv @ F\n            \n            y += dy\n            if np.linalg.norm(dy)  tol:\n                break\n        return y\n\n    # --- Integrators ---\n    def solve_gl2(y0, h, T, apply_L, L_mat, lam):\n        \"\"\"\n        Integrator 1: 2-stage Gauss-Legendre Runge-Kutta method.\n        \"\"\"\n        dim_y = len(y0)\n        s3 = np.sqrt(3)\n        A = np.array([[1/4, 1/4 - s3/6], [1/4 + s3/6, 1/4]])\n        b = np.array([1/2, 1/2])\n        \n        num_steps = int(round(T / h))\n        y_n = y0.copy()\n        H_initial = hamiltonian(y_n, apply_L, lam)\n        max_H_dev = 0.0\n\n        for _ in range(num_steps):\n            Y_guess = np.concatenate([y_n, y_n])\n            \n            def residual_gl2(Y_flat):\n                Y1, Y2 = Y_flat[:dim_y], Y_flat[dim_y:]\n                f_Y1 = vector_field(Y1, apply_L, lam)\n                f_Y2 = vector_field(Y2, apply_L, lam)\n                res1 = Y1 - y_n - h * (A[0,0] * f_Y1 + A[0,1] * f_Y2)\n                res2 = Y2 - y_n - h * (A[1,0] * f_Y1 + A[1,1] * f_Y2)\n                return np.concatenate([res1, res2])\n\n            def jacobian_gl2(Y_flat):\n                Y1, Y2 = Y_flat[:dim_y], Y_flat[dim_y:]\n                Df_Y1 = jacobian_vector_field(Y1, L_mat, lam)\n                Df_Y2 = jacobian_vector_field(Y2, L_mat, lam)\n                I = np.eye(dim_y)\n                J11 = I - h * A[0,0] * Df_Y1\n                J12 = -h * A[0,1] * Df_Y2\n                J21 = -h * A[1,0] * Df_Y1\n                J22 = I - h * A[1,1] * Df_Y2\n                return np.block([[J11, J12], [J21, J22]])\n\n            Y_sol_flat = newton_solver(residual_gl2, jacobian_gl2, Y_guess, 1e-10, 20)\n            Y1_sol, Y2_sol = Y_sol_flat[:dim_y], Y_sol_flat[dim_y:]\n            f_Y1_sol = vector_field(Y1_sol, apply_L, lam)\n            f_Y2_sol = vector_field(Y2_sol, apply_L, lam)\n            y_n += h * (b[0] * f_Y1_sol + b[1] * f_Y2_sol)\n            H_current = hamiltonian(y_n, apply_L, lam)\n            max_H_dev = max(max_H_dev, abs(H_current - H_initial))\n        return max_H_dev\n\n    def solve_avf(y0, h, T, apply_L, L_mat, lam):\n        \"\"\"\n        Integrator 2: Average Vector Field (AVF) method.\n        \"\"\"\n        dim_y = len(y0)\n        s1 = 0.5 - 1.0 / (2.0 * np.sqrt(3.0))\n        s2 = 0.5 + 1.0 / (2.0 * np.sqrt(3.0))\n        \n        num_steps = int(round(T / h))\n        y_n = y0.copy()\n        H_initial = hamiltonian(y_n, apply_L, lam)\n        max_H_dev = 0.0\n\n        for _ in range(num_steps):\n            y_guess = y_n.copy()\n            def residual_avf(y_np1):\n                y_s1 = (1 - s1) * y_n + s1 * y_np1\n                y_s2 = (1 - s2) * y_n + s2 * y_np1\n                f_s1 = vector_field(y_s1, apply_L, lam)\n                f_s2 = vector_field(y_s2, apply_L, lam)\n                return y_np1 - y_n - h * 0.5 * (f_s1 + f_s2)\n            \n            def jacobian_avf(y_np1):\n                y_s1 = (1 - s1) * y_n + s1 * y_np1\n                y_s2 = (1 - s2) * y_n + s2 * y_np1\n                Df_s1 = jacobian_vector_field(y_s1, L_mat, lam)\n                Df_s2 = jacobian_vector_field(y_s2, L_mat, lam)\n                return np.eye(dim_y) - (h / 2.0) * (s1 * Df_s1 + s2 * Df_s2)\n\n            y_n = newton_solver(residual_avf, jacobian_avf, y_guess, 1e-10, 20)\n            H_current = hamiltonian(y_n, apply_L, lam)\n            max_H_dev = max(max_H_dev, abs(H_current - H_initial))\n        return max_H_dev\n\n    def solve_hbvm(y0, h, T, apply_L, L_mat, lam):\n        \"\"\"\n        Integrator 3: Hamiltonian Boundary Value Method (HBVM(4,2)).\n        \"\"\"\n        dim_y = len(y0)\n        s3 = np.sqrt(3.0)\n        nodes_m11, weights_m11 = np.polynomial.legendre.leggauss(4)\n        c_nodes = (nodes_m11 + 1.0) / 2.0\n        w_weights = weights_m11 / 2.0\n        alpha_l0 = c_nodes\n        alpha_l1 = s3 * (c_nodes**2 - c_nodes)\n        P1_c = s3 * (2 * c_nodes - 1)\n        \n        num_steps = int(round(T / h))\n        y_n = y0.copy()\n        H_initial = hamiltonian(y_n, apply_L, lam)\n        max_H_dev = 0.0\n\n        for _ in range(num_steps):\n            gamma_guess = np.zeros(2*dim_y)\n            gamma_guess[:dim_y] = vector_field(y_n, apply_L, lam)\n\n            def residual_hbvm(Gamma_flat):\n                g0, g1 = Gamma_flat[:dim_y], Gamma_flat[dim_y:]\n                f_sum0 = np.zeros(dim_y)\n                f_sum1 = np.zeros(dim_y)\n                for l in range(4):\n                    Y_l = y_n + h * (alpha_l0[l] * g0 + alpha_l1[l] * g1)\n                    f_Y_l = vector_field(Y_l, apply_L, lam)\n                    f_sum0 += w_weights[l] * f_Y_l\n                    f_sum1 += w_weights[l] * P1_c[l] * f_Y_l\n                return np.concatenate([g0 - f_sum0, g1 - f_sum1])\n\n            def jacobian_hbvm(Gamma_flat):\n                g0, g1 = Gamma_flat[:dim_y], Gamma_flat[dim_y:]\n                I, Z_ = np.eye(dim_y), np.zeros((dim_y, dim_y))\n                J00, J01, J10, J11 = I.copy(), Z_.copy(), Z_.copy(), I.copy()\n                for l in range(4):\n                    Y_l = y_n + h * (alpha_l0[l] * g0 + alpha_l1[l] * g1)\n                    Df_l = jacobian_vector_field(Y_l, L_mat, lam)\n                    w_l = w_weights[l]\n                    J00 -= h * w_l * alpha_l0[l] * Df_l\n                    J01 -= h * w_l * alpha_l1[l] * Df_l\n                    J10 -= h * w_l * P1_c[l] * alpha_l0[l] * Df_l\n                    J11 -= h * w_l * P1_c[l] * alpha_l1[l] * Df_l\n                return np.block([[J00, J01], [J10, J11]])\n\n            Gamma_sol = newton_solver(residual_hbvm, jacobian_hbvm, gamma_guess, 1e-10, 20)\n            g0_sol = Gamma_sol[:dim_y]\n            y_n += h * g0_sol\n            H_current = hamiltonian(y_n, apply_L, lam)\n            max_H_dev = max(max_H_dev, abs(H_current - H_initial))\n        return max_H_dev\n\n    # --- Main Simulation Runner ---\n    test_cases_defs = [\n        {'N': 32, 'c': 1.0, 'lam': 0.1, 'h': 0.05, 'T': 10, \n         'q0_func': lambda x: 0.2 * np.cos(2*np.pi*x), \n         'p0_func': lambda x: 0.2 * np.sin(2*np.pi*x)},\n        {'N': 64, 'c': 1.0, 'lam': 1.0, 'h': 0.02, 'T': 4,\n         'q0_func': lambda x: 0.5 * np.cos(2*np.pi*x),\n         'p0_func': lambda x: np.zeros_like(x)},\n        {'N': 16, 'c': 1.0, 'lam': 0.0, 'h': 0.1, 'T': 50,\n         'q0_func': lambda x: 0.3 * np.cos(4*np.pi*x),\n         'p0_func': lambda x: 0.3 * np.sin(4*np.pi*x)}\n    ]\n    \n    methods = [solve_gl2, solve_avf, solve_hbvm]\n    all_results = []\n    \n    for case_params in test_cases_defs:\n        N = case_params['N']\n        x = np.arange(N) / N\n        y0 = np.concatenate([case_params['q0_func'](x), case_params['p0_func'](x)])\n        apply_L, L_mat = setup_laplacian(N, case_params['c'])\n        \n        case_results = []\n        for method in methods:\n            val = method(y0.copy(), case_params['h'], case_params['T'], apply_L, L_mat, case_params['lam'])\n            case_results.append(val)\n        all_results.append(case_results)\n        \n    output_str = \"[\" + \",\".join([f\"[{','.join(f'{v:.6e}' for v in r)}]\" for r in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3421719"}]}