{"hands_on_practices": [{"introduction": "本节的第一个实践将引导您在最简单的形式下，体验可杂交间断伽辽金（HDG）方法的核心机制。通过在仅包含两个单元的网格上求解一个一维扩散问题，您将直接应用局部求解器和静态凝聚的概念。这个动手计算对于揭示连接各单元解并构成全局系统的杂交迹变量的作用至关重要 ([@problem_id:3390545])。", "problem": "考虑区间 $[0,1]$ 上的稳态一维扩散方程，其中扩散系数 $\\kappa0$ 为常数且体积源为零，写成混合一阶形式：求解 $u:(0,1)\\to\\mathbb{R}$ 和 $q:(0,1)\\to\\mathbb{R}$，使得\n$$\nq \\;=\\; -\\,\\kappa\\,\\frac{du}{dx}, \n\\qquad \n\\frac{dq}{dx} \\;=\\; 0 \\quad \\text{在 } (0,1) \\text{ 内},\n$$\n满足混合 Dirichlet–Neumann 边界条件\n$$\nu(0) \\;=\\; U_{D}, \n\\qquad \nq(1) \\;=\\; g_{N},\n$$\n其中 $U_{D}\\in\\mathbb{R}$ 和 $g_{N}\\in\\mathbb{R}$ 是给定的数据，且在 $x=1$ 处的外法线方向为 $+1$。\n\n将域划分为两个单元 $K_{1}=[0,h_{1}]$ 和 $K_{2}=[h_{1},1]$，其中 $0h_{1}1$。对于解 $u_{h}$ 和通量 $q_{h}$，使用在每个单元上分片常数的多项式逼近空间。杂交迹变量 $\\widehat{u}_{h}$ 也是在每个面上分片的常数。\n\n使用 HDG 方法，利用局部问题和通量连续性的全局耦合，推导出内部面 $x=h_{1}$ 上杂交迹 $\\widehat{u}_{h}$ 的显式闭合形式表达式。假设数值通量为 $\\widehat{q}_{h}\\,n \\;=\\; q_{h}\\,n + \\tau\\,(u_{h}-\\widehat{u}_{h})$，其中稳定化参数 $\\tau0$ 为常数。", "solution": "用户提供的问题经验证是自洽的、有科学依据的、适定的和客观的。这是将可杂交间断 Galerkin (HDG) 方法应用于一维边值问题的标准练习。我们开始求解。\n\n该问题要求推导内部面 $x=h_1$ 上混合迹未知量 $\\widehat{u}_{h}$ 的值。我们将此值记为 $\\widehat{u}_{h,1} \\equiv \\widehat{u}_{h}(h_{1})$。域 $\\Omega = [0,1]$ 被划分为两个单元，$K_1 = [0, h_1]$ 和 $K_2 = [h_1, 1]$。解 $u_h$ 和通量 $q_h$ 的逼近空间在每个单元上是分片常数，即，对于 $i=1,2$，有 $u_h|_{K_i} = u_i \\in \\mathbb{R}$ 和 $q_h|_{K_i} = q_i \\in \\mathbb{R}$。混合迹 $\\widehat{u}_h$ 在每个面上为常数，其值为 $\\widehat{u}_h(0)$、$\\widehat{u}_h(h_1)$ 和 $\\widehat{u}_h(1)$。\n\n局部 HDG 方程由每个单元 $K$ 上的控制方程的弱形式推导而来。对于测试函数 $v \\in \\mathbb{P}_0(K)$ 和测试通量 $w \\in \\mathbb{P}_0(K)$，方程为：\n$$\n\\int_K w q_h \\,dx = -\\kappa \\int_{\\partial K} w n \\widehat{u}_h \\,ds\n$$\n$$\n\\int_{\\partial K} v n \\widehat{q}_h \\,ds = 0\n$$\n由于测试函数是常数（$v=1, w=1$），这些方程简化为：\n$$\n|K|q_h = -\\kappa \\sum_{F \\in \\partial K} n_F \\widehat{u}_h|_F\n$$\n$$\n\\sum_{F \\in \\partial K} n_F \\widehat{q}_h|_F = 0\n$$\n其中 $|K|$ 是单元 $K$ 的长度，$n_F$ 是面 $F$ 上的外法线方向。\n\n关于数值通量的问题陈述可解释如下：定义 $\\widehat{q}_{h}\\,n \\;=\\; q_{h}\\,n + \\tau\\,(u_{h}-\\widehat{u}_{h})$ 在所有面上成立，且 Neumann 条件作为边界上的全局方程 $\\widehat{q}_h \\cdot n = g_N$ 被弱施加。这种解释对于适定系统是必要的。\n\n**步骤 1：局部方程和静态凝聚**\n\n在单元 $K_1=[0, h_1]$ 上：\n未知量是常数 $u_1, q_1$。长度为 $|K_1|=h_1$。面位于 $x=0$（法线 $n=-1$）和 $x=h_1$（法线 $n=+1$）。迹值为 $\\widehat{u}_h(0) = U_D$（给定的 Dirichlet 数据）和 $\\widehat{u}_h(h_1) = \\widehat{u}_{h,1}$。\n第一个局部方程给出：\n$h_1 q_1 = -\\kappa [ (+1)\\widehat{u}_{h,1} + (-1)U_D ] \\implies q_1 = -\\frac{\\kappa}{h_1}(\\widehat{u}_{h,1} - U_D) = \\frac{\\kappa}{h_1}(U_D - \\widehat{u}_{h,1})$。\n对于第二个局部方程，面上的数值通量为：\n在 $x=h_1$ 处：$n_1 \\widehat{q}_{h,1} = (+1)q_1 + \\tau(u_1 - \\widehat{u}_{h,1})$。\n在 $x=0$ 处：$n_1 \\widehat{q}_{h,1} = (-1)q_1 + \\tau(u_1 - U_D)$。\n将它们相加得到：$[q_1 + \\tau(u_1 - \\widehat{u}_{h,1})] + [-q_1 + \\tau(u_1 - U_D)] = 0 \\implies 2\\tau u_1 - \\tau(\\widehat{u}_{h,1} + U_D) = 0$。\n这得出 $u_1 = \\frac{1}{2}(U_D + \\widehat{u}_{h,1})$。\n\n在单元 $K_2=[h_1, 1]$ 上：\n未知量是常数 $u_2, q_2$。长度为 $|K_2|=1-h_1$。面位于 $x=h_1$（法线 $n=-1$）和 $x=1$（法线 $n=+1$）。我们将 $x=1$ 处的未知迹值记为 $\\widehat{u}_{h,2} \\equiv \\widehat{u}_h(1)$。\n第一个局部方程给出：\n$(1-h_1) q_2 = -\\kappa [ (+1)\\widehat{u}_{h,2} + (-1)\\widehat{u}_{h,1} ] \\implies q_2 = -\\frac{\\kappa}{1-h_1}(\\widehat{u}_{h,2} - \\widehat{u}_{h,1})$。\n对于第二个局部方程，面上的数值通量为：\n在 $x=1$ 处：$n_2 \\widehat{q}_{h,2} = (+1)q_2 + \\tau(u_2 - \\widehat{u}_{h,2})$。\n在 $x=h_1$ 处：$n_2 \\widehat{q}_{h,2} = (-1)q_2 + \\tau(u_2 - \\widehat{u}_{h,1})$。\n将它们相加得到：$[q_2 + \\tau(u_2 - \\widehat{u}_{h,2})] + [-q_2 + \\tau(u_2 - \\widehat{u}_{h,1})] = 0 \\implies 2\\tau u_2 - \\tau(\\widehat{u}_{h,1} + \\widehat{u}_{h,2}) = 0$。\n这得出 $u_2 = \\frac{1}{2}(\\widehat{u}_{h,1} + \\widehat{u}_{h,2})$。\n\n**步骤 2：混合迹的全局系统**\n\n全局系统由未知迹值 $\\widehat{u}_{h,1}$ 和 $\\widehat{u}_{h,2}$ 的方程组成。\n在内部面 $x=h_1$ 处，我们强制数值通量的连续性。$K_1$ 的外法线为 $n=+1$，$K_2$ 的外法线为 $n=-1$。\n$(\\widehat{q}_h \\cdot n)|_{K_1, x=h_1} + (\\widehat{q}_h \\cdot n)|_{K_2, x=h_1} = 0$。\n$[q_1 + \\tau(u_1 - \\widehat{u}_{h,1})] + [-q_2 + \\tau(u_2-\\widehat{u}_{h,1})] = 0 \\implies q_1 - q_2 + \\tau(u_1+u_2-2\\widehat{u}_{h,1}) = 0$。\n\n在 Neumann 边界面 $x=1$ 处，我们施加条件 $\\widehat{q}_h \\cdot n = g_N$。从 $K_2$ 出发的外法线为 $n=+1$。\n$(\\widehat{q}_h \\cdot n)|_{K_2, x=1} = g_N \\implies q_2 + \\tau(u_2 - \\widehat{u}_{h,2}) = g_N$。\n\n**步骤 3：简化为单个方程并求解**\n\n现在我们有一个关于 $\\widehat{u}_{h,1}$ 和 $\\widehat{u}_{h,2}$ 的 $2 \\times 2$ 系统。首先，我们使用 Neumann 方程来消去 $\\widehat{u}_{h,2}$。\n将 $q_2$ 和 $u_2$ 的凝聚形式代入 Neumann 方程：\n$-\\frac{\\kappa}{1-h_1}(\\widehat{u}_{h,2} - \\widehat{u}_{h,1}) + \\tau\\left(\\frac{1}{2}(\\widehat{u}_{h,1} + \\widehat{u}_{h,2}) - \\widehat{u}_{h,2}\\right) = g_N$\n$\\frac{\\kappa}{1-h_1}(\\widehat{u}_{h,1} - \\widehat{u}_{h,2}) + \\frac{\\tau}{2}(\\widehat{u}_{h,1} - \\widehat{u}_{h,2}) = g_N$\n$\\left(\\frac{\\kappa}{1-h_1} + \\frac{\\tau}{2}\\right) (\\widehat{u}_{h,1} - \\widehat{u}_{h,2}) = g_N$。\n这使得我们可以用 $\\widehat{u}_{h,1}$ 来表示 $(\\widehat{u}_{h,1} - \\widehat{u}_{h,2})$，并因此表示 $\\widehat{u}_{h,2}$：\n$\\widehat{u}_{h,2} = \\widehat{u}_{h,1} - g_N \\left(\\frac{\\kappa}{1-h_1} + \\frac{\\tau}{2}\\right)^{-1}$。\n\n接下来，将所有凝聚形式代入内部面方程：\n$q_1 - q_2 + \\tau(u_1+u_2-2\\widehat{u}_{h,1}) = 0$\n$\\frac{\\kappa}{h_1}(U_D - \\widehat{u}_{h,1}) - \\left[-\\frac{\\kappa}{1-h_1}(\\widehat{u}_{h,2} - \\widehat{u}_{h,1})\\right] + \\tau\\left(\\frac{1}{2}(U_D + \\widehat{u}_{h,1}) + \\frac{1}{2}(\\widehat{u}_{h,1} + \\widehat{u}_{h,2}) - 2\\widehat{u}_{h,1}\\right) = 0$\n$\\frac{\\kappa}{h_1}(U_D - \\widehat{u}_{h,1}) + \\frac{\\kappa}{1-h_1}(\\widehat{u}_{h,2} - \\widehat{u}_{h,1}) + \\frac{\\tau}{2}(U_D - 2\\widehat{u}_{h,1} + \\widehatu}_{h,2}) = 0$\n合并项：\n$(U_D - \\widehat{u}_{h,1})\\left(\\frac{\\kappa}{h_1} + \\frac{\\tau}{2}\\right) + (\\widehat{u}_{h,2} - \\widehat{u}_{h,1})\\left(\\frac{\\kappa}{1-h_1} + \\frac{\\tau}{2}\\right) = 0$\n设 $A = \\frac{\\kappa}{1-h_1} + \\frac{\\tau}{2}$。从 Neumann 方程，我们已知 $(\\widehat{u}_{h,1}-\\widehat{u}_{h,2})A = g_N$，因此 $(\\widehat{u}_{h,2}-\\widehat{u}_{h,1})A = -g_N$。\n将此代入方程中：\n$(U_D - \\widehat{u}_{h,1})\\left(\\frac{\\kappa}{h_1} + \\frac{\\tau}{2}\\right) - g_N = 0$\n$(U_D - \\widehat{u}_{h,1})\\left(\\frac{2\\kappa + \\tau h_1}{2h_1}\\right) = g_N$\n$U_D - \\widehat{u}_{h,1} = \\frac{2h_1 g_N}{2\\kappa + \\tau h_1}$\n$\\widehat{u}_{h,1} = U_D - \\frac{2h_1 g_N}{2\\kappa + \\tau h_1}$\n为了将其表示为单个分数：\n$\\widehat{u}_{h,1} = \\frac{U_D(2\\kappa + \\tau h_1) - 2h_1 g_N}{2\\kappa + \\tau h_1}$。\n这就是 $\\widehat{u}_h(h_1)$ 的显式闭合形式表达式。", "answer": "$$\\boxed{\\frac{U_{D}(2\\kappa + \\tau h_{1}) - 2h_{1}g_{N}}{2\\kappa + \\tau h_{1}}}$$", "id": "3390545"}, {"introduction": "从手动计算过渡到计算机验证，这个实践将挑战您实现有限元方法中一个基础的质量保证测试：分片检验 (patch test)。您将编写代码来确认您的HDG实现能够精确地再现一个简单的线性解，这是被称为多项式一致性的关键属性。这项练习将巩固您在更真实的二维背景下，如何组装和求解局部HDG系统的理解 ([@problem_id:3390607])。", "problem": "考虑在单个三角形单元上带有狄利克雷边界数据的二阶标量椭圆模型问题。设控制方程为混合形式的泊松问题：寻找标量场 $u$ 和通量（矢量场）$\\boldsymbol{q}$，使得\n$$\n\\boldsymbol{q} + \\nabla u = \\boldsymbol{0}, \\qquad \\nabla \\cdot \\boldsymbol{q} = f \\quad \\text{在单元内部}，\n$$\n并在单元边界上满足狄利克雷边界数据 $u = g$。可杂交间断伽辽金 (HDG) 方法在单元内部及其边上各自的多项式空间中求解 $(\\boldsymbol{q}_h, u_h, \\widehat{u}_h)$，使其满足 HDG 局部方程：对于所选多项式空间中的所有测试函数 $\\boldsymbol{r}$ 和 $v$，\n$$\n(\\boldsymbol{q}_h, \\boldsymbol{r})_T - (u_h, \\nabla \\cdot \\boldsymbol{r})_T + \\langle \\widehat{u}_h, \\boldsymbol{r} \\cdot \\boldsymbol{n} \\rangle_{\\partial T} = 0,\n$$\n$$\n-(\\boldsymbol{q}_h, \\nabla v)_T + \\langle \\boldsymbol{q}_h \\cdot \\boldsymbol{n} + \\tau (u_h - \\widehat{u}_h), v \\rangle_{\\partial T} = (f, v)_T,\n$$\n其中 $T$ 是三角形单元，$\\partial T$ 是其边界，$\\boldsymbol{n}$ 是 $\\partial T$ 上的单位外法向量，$\\tau$ 是一个正的稳定化参数。在狄利克雷边界上，杂交迹变量被设置为边界数据，即 $\\widehat{u}_h = g$。\n\n面片检验（patch test）检查对线性多项式的精确再现能力。假设一个精确的线性解 $u_{\\text{exact}}(x,y) = \\alpha x + \\beta y + \\gamma$，其梯度为常数，因此 $f = 0$。当所有逼近空间的多项式次数 $p = 1$ 时（即 $u_h \\in \\mathbb{P}_1(T)$，$\\boldsymbol{q}_h \\in [\\mathbb{P}_1(T)]^2$，以及在每条边 $e \\subset \\partial T$ 上 $\\widehat{u}_h \\in \\mathbb{P}_1(e)$），HDG 面片检验要求计算每条边上的杂交迹未知量，以使局部求解器产生的 $u_h$ 等于线性多项式 $u_{\\text{exact}}$。\n\n从基本定义出发：\n- 泊松方程的混合形式及其弱形式。\n- 带有数值通量 $\\widehat{\\boldsymbol{q}}_h \\cdot \\boldsymbol{n} = \\boldsymbol{q}_h \\cdot \\boldsymbol{n} + \\tau (u_h - \\widehat{u}_h)$ 的 HDG 局部方程。\n- 三角形单元及其边上的多项式逼近空间及其基函数。\n\n推导、实现并验证一个带有狄利克雷边界数据的单单元 HDG 面片检验，重点是计算能够保证在单元内部精确再现线性解的边迹未知数值。\n\n您的程序必须：\n- 在单个三角形单元上，使用次数 $p = 1$ 的空间和常数稳定化参数 $\\tau$ 来组装和求解局部 HDG 系统。\n- 在体积分中使用精确的质量和梯度积分，在边上使用精确的两点高斯求积来计算边界积分。\n- 将每条边上的杂交迹未知量 $\\widehat{u}_h$ 设置为限制在该边上的狄利克雷数据 $g$，由次数为 1 的边自由度（即每条边两个端点处的值）表示。\n- 计算得到的 $u_h$ 并通过在一小组内部点上评估最大绝对逐点误差，来验证其在数值容差范围内等于 $u_{\\text{exact}}$。\n\n测试套件：\n对于每个测试用例，三角形由其顶点坐标 $(x_i, y_i)$（其中 $i \\in \\{0,1,2\\}$，按 $(0,1,2)$ 顺序给出）、线性多项式系数 $(\\alpha, \\beta, \\gamma)$ 以及稳定化参数 $\\tau$ 给出。使用以下三个测试用例：\n- 用例 1：顶点 $(0,0)$, $(1,0)$, $(0,1)$；系数 $(2, -1, 1)$；稳定化参数 $\\tau = 1$。\n- 用例 2：顶点 $(0,0)$, $(10^{-3}, 1)$, $(0,1)$；系数 $(-0.5, 1.7, 0.3)$；稳定化参数 $\\tau = 3.3$。\n- 用例 3：顶点 $(0,0)$, $(2,0)$, $(0,1)$；系数 $(1, 3, -2)$；稳定化参数 $\\tau = 5$。\n\n边迹自由度与输出顺序：\n- 按 $[(0,1), (1,2), (2,0)]$ 的顺序枚举边。\n- 对于每条边 $(i,j)$，两个迹自由度分别是 $\\widehat{u}_h$ 在端点 $i$ 和 $j$ 处的值。\n- 迹值由端点处的狄利克雷数据 $g = u_{\\text{exact}}$ 计算得出。\n\n最终输出格式：\n- 对于每个测试用例，输出一个形式为 $[\\text{trace\\_values}, \\text{max\\_error}]$ 的列表，其中 $\\text{trace\\_values}$ 是一个包含 6 个浮点数的列表，顺序为 $[ \\widehat{u}_{(0,1),0}, \\widehat{u}_{(0,1),1}, \\widehat{u}_{(1,2),1}, \\widehat{u}_{(1,2),2}, \\widehat{u}_{(2,0),2}, \\widehat{u}_{(2,0),0} ]$，而 $\\text{max\\_error}$ 是在一组固定的内部点上评估的 $u_h$ 和 $u_{\\text{exact}}$ 之间的最大绝对逐点误差。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，结果为逗号分隔的列表，用方括号括起，无空格，并按给定顺序排列。例如，输出必须类似于 $[[\\ldots,\\ldots],[\\ldots,\\ldots],[\\ldots,\\ldots]]$。\n- 如果出现任何三角函数，所有角度均以弧度为单位；然而，此任务不涉及角度。\n- 不涉及物理单位。", "solution": "用户要求在单个三角形单元上实现并验证一个用于标量椭圆问题的可杂交间断伽辽金 (HDG) 面片检验。面片检验是有限元方法的一项基本验证程序，旨在确保该方法能够精确再现特定次数的多项式解。对于此问题，我们必须证明，对于一个已知的线性精确解，使用次数 $p=1$ 多项式空间的 HDG 方法能够产生一个与精确解在机器精度内相同的数值解。\n\n控制方程是混合形式的泊松问题：\n$$\n\\boldsymbol{q} + \\nabla u = \\boldsymbol{0}, \\qquad \\nabla \\cdot \\boldsymbol{q} = f\n$$\nHDG 列式在多项式空间中求解 $(\\boldsymbol{q}_h, u_h, \\widehat{u}_h)$，其中 $\\boldsymbol{q}_h \\in [\\mathbb{P}_1(T)]^2$，$u_h \\in \\mathbb{P}_1(T)$，以及对于三角形 $T$ 的每条边 $e$，$\\widehat{u}_h \\in \\mathbb{P}_1(e)$。局部弱形式为：\n$$\n(\\boldsymbol{q}_h, \\boldsymbol{r})_T - (u_h, \\nabla \\cdot \\boldsymbol{r})_T + \\langle \\widehat{u}_h, \\boldsymbol{r} \\cdot \\boldsymbol{n} \\rangle_{\\partial T} = 0\n$$\n$$\n-(\\boldsymbol{q}_h, \\nabla v)_T + \\langle \\boldsymbol{q}_h \\cdot \\boldsymbol{n} + \\tau (u_h - \\widehat{u}_h), v \\rangle_{\\partial T} = (f, v)_T\n$$\n其中 $(\\cdot, \\cdot)_T$ 表示单元 $T$ 上的 $L^2$ 内积，而 $\\langle \\cdot, \\cdot \\rangle_{\\partial T}$ 是其边界 $\\partial T$ 上的内积。测试函数 $\\boldsymbol{r}$ 和 $v$ 分别与 $\\boldsymbol{q}_h$ 和 $u_h$ 来自相同的多项式空间。\n\n对于面片检验，精确解是一个线性多项式 $u_{\\text{exact}}(x,y) = \\alpha x + \\beta y + \\gamma$。这意味着源项为 $f = \\nabla \\cdot (-\\nabla u_{\\text{exact}}) = 0$。狄利克雷边界条件为 $\\partial T$ 上的 $u = g = u_{\\text{exact}}$。在 HDG 框架中，这是通过将迹变量 $\\widehat{u}_h$ 设置为 $g$ 在迹空间上的投影来实现的。由于 $\\widehat{u}_h \\in \\mathbb{P}_1(e)$ 且 $g$ 是线性的，这个投影是精确的：$\\widehat{u}_h$ 就是 $g$ 在每条边上的限制。$\\widehat{u}_h$ 的自由度是其在三角形顶点处的值，计算方式为 $\\widehat{U}_i = g(\\boldsymbol{v}_i) = \\alpha x_i + \\beta y_i + \\gamma$。\n\n求解过程包括以下步骤：\n1.  **定义基函数**：我们在顶点为 $(0,0), (1,0), (0,1)$ 的参考三角形 $\\widehat{T}$ 上，对 $\\mathbb{P}_1$ 使用单项式基 $\\{1, \\widehat{x}, \\widehat{y}\\}$。一个仿射映射 $F(\\widehat{\\boldsymbol{x}}) = B\\widehat{\\boldsymbol{x}} + \\boldsymbol{v}_0$ 将参考单元连接到物理单元 $T$。向量空间 $[\\mathbb{P}_1(T)]^2$ 的基函数是分量式构造的，这导致 $u_h$ 共有 3 个自由度，$\\boldsymbol{q}_h$ 共有 6 个自由度。\n2.  **建立线性系统**：将 $u_h$ 和 $\\boldsymbol{q}_h$ 的基函数展开式代入弱形式，得到一个关于未知系数的 $9 \\times 9$ 线性方程组。设 $u_h$ 的系数向量为 $\\boldsymbol{U}$，$\\boldsymbol{q}_h$ 的系数向量为 $\\boldsymbol{Q}$。该系统的形式为：\n    $$\n    \\begin{pmatrix} \\mathbf{A}_{\\boldsymbol{qq}}  \\mathbf{A}_{\\boldsymbol{q}u} \\\\ \\mathbf{A}_{u\\boldsymbol{q}}  \\mathbf{A}_{uu} \\end{pmatrix} \\begin{pmatrix} \\boldsymbol{Q} \\\\ \\boldsymbol{U} \\end{pmatrix} = \\begin{pmatrix} \\boldsymbol{F}_{\\boldsymbol{q}} \\\\ \\boldsymbol{F}_{u} \\end{pmatrix}\n    $$\n3.  **组装矩阵和向量**：系统矩阵 $\\mathbf{A}$ 和右侧向量 $\\boldsymbol{F}$ 的项由弱形式计算得出。\n    -   $\\mathbf{A}_{\\boldsymbol{qq}}$ 是 $\\boldsymbol{q}_h$ 的质量矩阵。\n    -   $\\mathbf{A}_{\\boldsymbol{q}u}$ 和 $\\mathbf{A}_{u\\boldsymbol{q}}$ 是耦合变量的类刚度矩阵。\n    -   $\\mathbf{A}_{uu}$ 是一个由稳定化参数 $\\tau$ 缩放的边界质量矩阵。\n    -   $\\boldsymbol{F}_{\\boldsymbol{q}}$ 和 $\\boldsymbol{F}_{u}$ 是由迹变量 $\\widehat{u}_h$ 产生的载荷向量。\n    所有积分都在参考单元 $\\widehat{T}$ 上计算，然后变换到物理单元。多项式的体积分使用已知公式精确计算。边上的边界积分使用 2 点高斯求积法则计算，这对于遇到的多项式被积函数（最高 3 次）是精确的。\n4.  **求解与验证**：求解线性系统以获得系数 $\\boldsymbol{U}$ 和 $\\boldsymbol{Q}$。然后将得到的数值解 $u_h$ 与在一组内部点上的已知精确解 $u_{\\text{exact}}$ 进行比较。计算最大绝对逐点误差，以验证面片检验是否通过（即误差在机器精度范围内）。顶点处的迹值也作为输出的一部分报告。\n\n该实现对每个提供的测试用例遵循这些步骤，系统地组装和求解局部 HDG 系统，然后评估结果的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_output(results):\n    \"\"\"Formats the results into the required single-line string format.\"\"\"\n    case_strings = []\n    for res in results:\n        trace_vals, max_err = res\n        # Format trace values with high precision scientific notation\n        trace_str = f\"[{','.join(f'{v:.15e}' for v in trace_vals)}]\"\n        # Format max error with high precision scientific notation\n        error_str = f\"{max_err:.15e}\"\n        case_strings.append(f\"[{trace_str},{error_str}]\")\n    return f\"[{','.join(case_strings)}]\"\n\ndef run_patch_test(vertices, coeffs, tau):\n    \"\"\"\n    Performs the HDG patch test for a single triangular element.\n\n    Args:\n        vertices (list of tuples): Coordinates of the triangle vertices.\n        coeffs (tuple): Coefficients (alpha, beta, gamma) for the linear exact solution.\n        tau (float): The stabilization parameter.\n\n    Returns:\n        tuple: A tuple containing the list of trace values and the maximum pointwise error.\n    \"\"\"\n    v = np.array(vertices, dtype=np.float64)\n    alpha, beta, gamma = coeffs\n\n    # 1. Geometric setup for the affine map from reference to physical element\n    v0, v1, v2 = v[0], v[1], v[2]\n    # Affine map: x = B * x_hat + v0\n    B = np.array([v1 - v0, v2 - v0]).T\n    J_det = np.linalg.det(B)\n    B_inv = np.linalg.inv(B)\n    C = B_inv.T  # Transformation matrix for gradients\n\n    # 2. Exact solution and trace setup\n    u_exact_func = lambda x, y: alpha * x + beta * y + gamma\n    Uhat_vals = np.array([u_exact_func(p[0], p[1]) for p in v])\n    trace_values_output = [\n        Uhat_vals[0], Uhat_vals[1], Uhat_vals[1], Uhat_vals[2], Uhat_vals[2], Uhat_vals[0]\n    ]\n\n    # 3. Basis functions and quadrature\n    # Basis on reference triangle (0,0)-(1,0)-(0,1): {1, x_hat, y_hat}\n    # Pre-computed integrals of basis product pairs (phi_i * phi_j) over the reference triangle.\n    M_hat_phiphi = np.array([\n        [1/2, 1/6, 1/6],\n        [1/6, 1/12, 1/24],\n        [1/6, 1/24, 1/12]\n    ])\n    # Pre-computed integrals of basis functions (phi_i) over the reference triangle.\n    int_phi_hat = np.array([1/2, 1/6, 1/6])\n\n    # 2-point Gaussian quadrature for the interval [0, 1]\n    q_points = 0.5 * (1.0 + np.array([-1.0, 1.0]) / np.sqrt(3.0))\n    q_weights = np.array([0.5, 0.5])\n\n    # 4. Assemble local system A*X = F\n    # X = [Qx0, Qx1, Qx2, Qy0, Qy1, Qy2, U0, U1, U2]^T (9 unknowns)\n    A = np.zeros((9, 9))\n    F = np.zeros(9)\n\n    # Volume integral contributions\n    # Block A_qq (mass matrix for q_h)\n    M_phiphi = J_det * M_hat_phiphi\n    A[:3, :3] = M_phiphi\n    A[3:6, 3:6] = M_phiphi\n\n    # Block A_qu\n    div_psi_consts = [0, C[0,0], C[0,1], 0, C[1,0], C[1,1]]\n    for i in range(6):\n        if abs(div_psi_consts[i]) > 1e-15:\n            for l_idx in range(3):\n                int_phi_l = J_det * int_phi_hat[l_idx]\n                A[i, 6 + l_idx] = -int_phi_l * div_psi_consts[i]\n\n    # Block A_uq (volume part)\n    grad_phi_k_consts = [np.zeros(2), C[:,0], C[:,1]]\n    int_psi_j = np.zeros((6, 2))\n    for j_idx in range(3):\n        int_phi_j = J_det * int_phi_hat[j_idx]\n        int_psi_j[j_idx, 0] = int_phi_j\n        int_psi_j[3 + j_idx, 1] = int_phi_j\n    for k_idx in range(3):\n        grad_phi_k = grad_phi_k_consts[k_idx]\n        for j_idx in range(6):\n            A[6 + k_idx, j_idx] = -np.dot(int_psi_j[j_idx], grad_phi_k)\n\n    # Boundary integral contributions\n    edges = [(0, 1), (1, 2), (2, 0)]\n    for i_start, i_end in edges:\n        v_start, v_end = v[i_start], v[i_end]\n        edge_vec = v_end - v_start\n        edge_len = np.linalg.norm(edge_vec)\n        normal = np.array([edge_vec[1], -edge_vec[0]]) / edge_len\n\n        for t_q, w_q in zip(q_points, q_weights):\n            if (i_start, i_end) == (0, 1): x_hat_q = np.array([t_q, 0.0])\n            elif (i_start, i_end) == (1, 2): x_hat_q = np.array([1.0 - t_q, t_q])\n            else: x_hat_q = np.array([0.0, 1.0 - t_q])\n            \n            phi_vals = np.array([1.0, x_hat_q[0], x_hat_q[1]])\n            psi_vals = np.zeros((6,2)); psi_vals[:3, 0] = phi_vals; psi_vals[3:, 1] = phi_vals\n            \n            u_hat_q = Uhat_vals[i_start] * (1 - t_q) + Uhat_vals[i_end] * t_q\n            factor = edge_len * w_q\n\n            # Update matrices and vectors from boundary terms\n            for k in range(3):\n                for j in range(6): A[6 + k, j] += factor * np.dot(psi_vals[j], normal) * phi_vals[k]\n                for l in range(3): A[6 + k, 6 + l] += factor * tau * phi_vals[l] * phi_vals[k]\n                F[6 + k] += factor * tau * u_hat_q * phi_vals[k]\n            for i in range(6): F[i] -= factor * u_hat_q * np.dot(psi_vals[i], normal)\n\n    # 5. Solve the system and extract solution coefficients for u_h\n    X = np.linalg.solve(A, F)\n    U_coeffs = X[6:]\n\n    # 6. Verification: Compare numerical and exact solutions\n    test_points_ref = [(1/3, 1/3), (0.1, 0.1), (0.8, 0.1), (0.1, 0.8)]\n    max_error = 0.0\n    for p_ref in test_points_ref:\n        p_ref_np = np.array(p_ref)\n        p_phy = B @ p_ref_np + v0\n        \n        u_h_val = U_coeffs[0] + U_coeffs[1]*p_ref[0] + U_coeffs[2]*p_ref[1]\n        u_exact_val = u_exact_func(p_phy[0], p_phy[1])\n        \n        error = abs(u_h_val - u_exact_val)\n        if error > max_error: max_error = error\n    \n    return trace_values_output, max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for all cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"vertices\": [(0, 0), (1, 0), (0, 1)],\n            \"coeffs\": (2, -1, 1),\n            \"tau\": 1.0\n        },\n        {\n            \"vertices\": [(0, 0), (1e-3, 1), (0, 1)],\n            \"coeffs\": (-0.5, 1.7, 0.3),\n            \"tau\": 3.3\n        },\n        {\n            \"vertices\": [(0, 0), (2, 0), (0, 1)],\n            \"coeffs\": (1, 3, -2),\n            \"tau\": 5.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res = run_patch_test(case[\"vertices\"], case[\"coeffs\"], case[\"tau\"])\n        results.append(res)\n    \n    print(format_output(results))\n\nsolve()\n\n```", "id": "3390607"}, {"introduction": "在学习了如何构建和实现HDG方法之后，理解其主要优势——计算效率——是至关重要的。这项实践提供了一个框架，用于分析和量化静态凝聚带来的好处。通过比较HDG方法和标准间断伽辽金（DG）方法全局矩阵中的非零元素数量，您将计算出显著的内存和计算工作量节省，正是这些优势使HDG成为大规模模拟的一个有吸引力的选择 ([@problem_id:3390584])。", "problem": "考虑通过对称内罚不连续伽辽金(DG)方法和通过静态凝聚的可杂交不连续伽辽金(HDG)方法离散化的标量泊松方程。静态凝聚消除了单元内部的未知数，仅在全局上保留了面迹未知数。请使用以下数据和建模假设来比较算术复杂度和内存存储。\n\n您可以使用的基本定义和事实：\n- 对于三角形上次数为 $p$ 的多项式，标量单元内部基函数的数量为 $n_{\\mathrm{el}} = \\frac{(p+1)(p+2)}{2}$。\n- 对于边上次数为 $p$ 的多项式，标量迹基函数的数量为 $m_{\\mathrm{ed}} = p+1$。\n- 在块稀疏全局矩阵上，Krylov方法的每次迭代的主要成本与存储的非零标量项的数量成正比。在压缩稀疏行(CSR)存储中，内存也与存储的非零标量项的数量成正比。\n- 在单纯形网格上组装的DG矩阵中，每个单元贡献一个 $n_{\\mathrm{el}}\\times n_{\\mathrm{el}}$ 的自块，每条内部边贡献两个相邻单元之间的非对角耦合。计算两个对称的非对角块，总非零元数量由 $\\mathrm{nnz}_{\\mathrm{DG}} = E\\,n_{\\mathrm{el}}^{2} + 2\\,E_{\\mathrm{int}}\\,n_{\\mathrm{el}}^{2}$ 建模，其中 $E$ 是单元数量，$E_{\\mathrm{int}}$ 是内部边数量。\n- 在三角形上的HDG凝聚全局矩阵中，每个单元在其三条边的迹之间贡献一个稠密的 $(3\\,m_{\\mathrm{ed}})\\times(3\\,m_{\\mathrm{ed}})$ 块。当在边上进行全局组装时，对角边块由两个相邻单元共享，因此应只计算一次；非对角边-边耦合（同一单元的两条不同边之间）是该单元独有的。一个一致的存储非零元计数为 $\\mathrm{nnz}_{\\mathrm{HDG}} = E\\,(3\\,m_{\\mathrm{ed}})^{2} - E_{\\mathrm{int}}\\,m_{\\mathrm{ed}}^{2}$。\n\n几何与网格：\n- 区域是一个矩形，被划分为 $N_{x}\\times N_{y}$ 个小矩形，其中 $N_{x} = 20$，$N_{y} = 10$。每个小矩形都由同一条对角线分割成两个三角形。网格具有齐次狄利克雷边界条件，因此只有内部边承载全局HDG迹未知数。\n- 对于这种结构化三角剖分，网格实体的数量为：\n  - 单元：$E = 2\\,N_{x}\\,N_{y}$。\n  - 总边数：$E_{\\mathrm{tot}} = 3\\,N_{x}\\,N_{y} + N_{x} + N_{y}$。\n  - 边界边数：$E_{\\partial} = 2\\,N_{x} + 2\\,N_{y}$。\n  - 内部边数：$E_{\\mathrm{int}} = E_{\\mathrm{tot}} - E_{\\partial} = 3\\,N_{x}\\,N_{y} - N_{x} - N_{y}$。\n\n多项式次数：\n- 在单元和边上使用 $p = 3$。\n\n任务：\n1. 使用以上信息，计算静态凝聚后的HDG与全局DG系统相比，每次矩阵向量积的算术复杂度之比，\n$$\n\\mathcal{C} = \\frac{\\mathrm{nnz}_{\\mathrm{HDG}}}{\\mathrm{nnz}_{\\mathrm{DG}}}.\n$$\n2. 计算内存节省分数\n$$\n\\mathcal{S} = 1 - \\frac{\\mathrm{nnz}_{\\mathrm{HDG}}}{\\mathrm{nnz}_{\\mathrm{DG}}}.\n$$\n\n将你的最终答案以一个二元行向量 $\\begin{pmatrix}\\mathcal{C}  \\mathcal{S}\\end{pmatrix}$ 的形式报告，四舍五入到四位有效数字。不需要单位。", "solution": "我们首先确定网格的组合量。当 $N_{x} = 20$ 且 $N_{y} = 10$ 时，三角形单元的数量为\n$$\nE = 2\\,N_{x}\\,N_{y} = 2\\cdot 20 \\cdot 10 = 400.\n$$\n内部边的数量为\n$$\nE_{\\mathrm{int}} = 3\\,N_{x}\\,N_{y} - N_{x} - N_{y} = 3\\cdot 20 \\cdot 10 - 20 - 10 = 600 - 30 = 570.\n$$\n\n接下来，我们计算多项式次数为 $p=3$ 时的局部自由度数量。在三角形上，\n$$\nn_{\\mathrm{el}} = \\frac{(p+1)(p+2)}{2} = \\frac{(3+1)(3+2)}{2} = \\frac{4\\cdot 5}{2} = 10,\n$$\n在边上，\n$$\nm_{\\mathrm{ed}} = p+1 = 3+1 = 4.\n$$\n\n我们现在对全局矩阵中存储的非零元数量进行建模。\n\n对于不连续伽辽金(DG)矩阵，我们使用块模式计数，该计数包括单元自耦合和跨每条内部边的成对耦合，并计算两个对称的非对角块。这给出\n$$\n\\mathrm{nnz}_{\\mathrm{DG}} = E\\,n_{\\mathrm{el}}^{2} + 2\\,E_{\\mathrm{int}}\\,n_{\\mathrm{el}}^{2}.\n$$\n代入 $E=400$，$E_{\\mathrm{int}}=570$ 和 $n_{\\mathrm{el}}=10$ 得出\n$$\n\\mathrm{nnz}_{\\mathrm{DG}} = 400\\cdot 10^{2} + 2\\cdot 570 \\cdot 10^{2} = 400\\cdot 100 + 1140\\cdot 100 = 40{,}000 + 114{,}000 = 154{,}000.\n$$\n\n对于可杂交不连续伽辽金(HDG)凝聚矩阵，每个三角形在其三条边之间贡献一个稠密的 $(3\\,m_{\\mathrm{ed}})\\times(3\\,m_{\\mathrm{ed}})$ 局部舒尔块。全局组装时，对角边块由两个三角形共享，因此必须只计算一次，而两条不同边之间的非对角耦合对于包含这两条边的三角形是唯一的。一个一致的全局计数是\n$$\n\\mathrm{nnz}_{\\mathrm{HDG}} = E\\,(3\\,m_{\\mathrm{ed}})^{2} - E_{\\mathrm{int}}\\,m_{\\mathrm{ed}}^{2}.\n$$\n当 $E=400$，$E_{\\mathrm{int}}=570$ 且 $m_{\\mathrm{ed}}=4$ 时，\n$$\n(3\\,m_{\\mathrm{ed}})^{2} = (3\\cdot 4)^{2} = 12^{2} = 144, \\quad m_{\\mathrm{ed}}^{2}=4^{2}=16,\n$$\n所以\n$$\n\\mathrm{nnz}_{\\mathrm{HDG}} = 400\\cdot 144 - 570\\cdot 16 = 57{,}600 - 9{,}120 = 48{,}480.\n$$\n\n每次矩阵向量乘法的算术复杂度比率被建模为非零元的比率：\n$$\n\\mathcal{C} = \\frac{\\mathrm{nnz}_{\\mathrm{HDG}}}{\\mathrm{nnz}_{\\mathrm{DG}}} = \\frac{48{,}480}{154{,}000}.\n$$\n计算该分数：\n$$\n\\mathcal{C} = \\frac{48{,}480}{154{,}000} \\approx 0.3148051948\\ldots\n$$\n\n内存节省分数为\n$$\n\\mathcal{S} = 1 - \\mathcal{C} \\approx 1 - 0.3148051948\\ldots \\approx 0.6851948052\\ldots\n$$\n\n将两者四舍五入到四位有效数字，得到\n$$\n\\mathcal{C} \\approx 0.3148, \\qquad \\mathcal{S} \\approx 0.6852.\n$$\n\n我们将结果报告为包含这两个条目的行向量。", "answer": "$$\\boxed{\\begin{pmatrix}0.3148  0.6852\\end{pmatrix}}$$", "id": "3390584"}]}