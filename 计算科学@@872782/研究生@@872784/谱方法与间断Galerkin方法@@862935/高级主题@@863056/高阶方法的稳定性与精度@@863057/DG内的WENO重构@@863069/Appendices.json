{"hands_on_practices": [{"introduction": "理解任何数值格式的性能，第一步往往是分析其在线性问题上的表现。傅里叶分析（或冯·诺依曼稳定性分析）是揭示数值格式内在耗散（dissipation）与色散（dispersion）特性的经典工具。本练习将指导你对一个$p=3$阶的间断伽辽金（DG）格式进行符号分析，推导其在光滑解区域线性化后的半离散算子，并计算其修正波数与误差曲线。通过这项实践，你将深入理解高阶DG格式在不同尺度上的传播特性，为后续理解非线性限制器的作用奠定理论基础。[@problem_id:3429573]", "problem": "考虑具有周期性边界条件的一维线性平流方程 $u_t + a u_x = 0$，该方程在使用迎风数值通量的多项式次数为 $p=3$ 的间断伽辽金 (Discontinuous Galerkin, DG) 方法，在宽度为 $h$ 的均匀网格单元上进行离散化。假设任何非线性限制器，例如加权基本不振荡 (Weighted Essentially Non-Oscillatory, WENO) 限制器或总变差有界 (Total Variation Bounded, TVB) 限制器，在光滑区域是不活跃的，因此线性化的半离散算子与底层的 DG 算子一致。在参考单元 $r \\in [-1,1]$上使用由勒让德多项式 (Legendre polynomials) $\\{\\phi_n(r)\\}_{n=0}^3$ 构成的模态基，通过 $x = x_j + \\tfrac{h}{2} r$ 映射到每个单元，并使用精确求积法来近似所有内积。\n\n从迎风数值通量线性平流的 DG 弱形式出发，推导无量纲波数 $\\kappa = k h \\in [0,\\pi]$ 的傅里葉模态的半离散算子符号，即一个 $4 \\times 4$ 矩阵 $S(\\kappa)$，使得对于傅里葉模态 $c_j(t) = v(t) \\mathrm{e}^{i \\kappa j}$，单元上的模态系数向量 $c_j \\in \\mathbb{C}^4$ 满足 $c_j'(t) = S(\\kappa) c_j(t)$。根据 $S(\\kappa)$ 定义：\n- 修正波数 (modified wavenumber) $k^\\star(\\kappa)$ 定义为 $k^\\star(\\kappa) = -\\mathrm{Im}(\\lambda^\\text{phys}(\\kappa))/a$，其中 $\\lambda^\\text{phys}(\\kappa)$ 是 $S(\\kappa)$ 的特征值，其虚部在小 $\\kappa$ 时最接近 $-a k$（物理分支）。\n- 耗散率 (dissipation rate) $\\mathcal{D}(\\kappa)$ 定义为 $\\mathcal{D}(\\kappa) = \\mathrm{Re}(\\lambda^\\text{phys}(\\kappa))/a$。\n- 色散误差 (dispersion error) $\\mathcal{E}(\\kappa)$ 定义为 $\\mathcal{E}(\\kappa) = k^\\star(\\kappa) - k$，其中 $k = \\kappa/h$。\n\n对于使用3阶强稳定保持龙格－库塔 (Strong Stability Preserving Runge–Kutta, SSP-RK3) 方法的全离散格式，定义放大矩阵 $G(\\kappa,\\nu)$ 为 $G(\\kappa,\\nu) = R\\!\\left(\\Delta t\\, S(\\kappa)\\right)$，其中稳定性多项式为 $R(z) = 1 + z + \\tfrac{1}{2} z^2 + \\tfrac{1}{6} z^3$，库朗－弗里德里希斯－列维 (Courant–Friedrichs–Lewy, CFL) 数为 $\\nu = a \\Delta t/h$。在光滑区域，假设 WENO 限制的 DG 和 TVB 限制的 DG 都简化为相同的线性算子 $S(\\kappa)$；因此，它们的放大矩阵是相同的。\n\n你的任务是：\n1. 使用 $n$ 次勒让德多项式 $\\phi_n(r) = P_n(r)$，在参考单元上推导矩阵 $M$ 和 $K$，其元素为\n   $$M_{mn} = \\int_{-1}^1 \\phi_m(r)\\,\\phi_n(r)\\, \\mathrm{d}r,\\quad K_{mn} = \\int_{-1}^1 \\phi'_m(r)\\,\\phi_n(r)\\, \\mathrm{d}r.$$\n   令 $\\Phi(\\pm 1)$表示在边界面上基函数的取值向量，并定义\n   $$F_R = \\Phi(1)\\,\\Phi(1)^\\top,\\quad G = \\Phi(-1)\\,\\Phi(1)^\\top.$$\n   证明在线性平流、迎风通量情况下，半离散 DG 算子可以写为\n   $$c_j'(t) = \\frac{2a}{h} M^{-1}\\Big[ K\\,c_j - F_R\\,c_j + G\\, c_{j-1}\\Big],$$\n   这给出了符号\n   $$S(\\kappa) = \\frac{2a}{h} M^{-1}\\Big[ K - F_R + \\mathrm{e}^{-i\\kappa} G \\Big].$$\n2. 使用符号 $S(\\kappa)$，通过选择虚部最接近 $-a k$（其中 $k=\\kappa/h$）的特征值来计算 $\\lambda^\\text{phys}(\\kappa)$。\n3. 对选定的 $\\kappa$ 计算色散误差 $\\mathcal{E}(\\kappa)$ 和耗散率 $\\mathcal{D}(\\kappa)$。\n4. 对于 SSP-RK3 和 CFL 数 $\\nu$，在一个密集的 $\\kappa \\in [0,\\pi]$ 网格上计算 $G(\\kappa,\\nu)$ 的谱半径，并报告在 $\\kappa$ 上的最大谱半径。在光滑解线性化假设下，比较 WENO 限制的 DG 和 TVB 限制的 DG 的结果。\n\n使用 $a=1$ 和 $h=1$。$\\kappa$ 的角度是无量纲的，单位为弧度。没有需要报告的物理单位。\n\n测试套件：\n- 波数 $\\kappa \\in \\{0.0,\\ 0.5,\\ 2.5,\\ \\pi\\}$。\n- CFL 数 $\\nu \\in \\{0.05,\\ 0.10,\\ 0.20,\\ 0.30\\}$。\n- 对于全离散谱半径，在一个至少包含 $200$ 个点的均匀 $\\kappa \\in [0,\\pi]$ 网格上评估最大值。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  1. 对于上面顺序中的每个测试 $\\kappa$，先是色散误差 $\\mathcal{E}(\\kappa)$，然后是耗散率 $\\mathcal{D}(\\kappa)$（浮点数）。\n  2. 对于上面顺序中的每个 CFL 值 $\\nu$，$G(\\kappa,\\nu)$ 在 $\\kappa \\in [0,\\pi]$ 上的最大谱半径（浮点数）。\n  3. 对于每个 CFL 值 $\\nu$，一个布尔值，指示 WENO 限制的 DG 的最大谱半径是否在 $10^{-12}$ 的绝对容差内等于 TVB 限制的 DG 的最大谱半径（布尔值）。\n\n例如，输出应如下所示\n$$[\\mathcal{E}(0.0),\\ \\mathcal{D}(0.0),\\ \\mathcal{E}(0.5),\\ \\mathcal{D}(0.5),\\ \\ldots,\\ \\rho_{\\max}(\\nu=0.05),\\ \\rho_{\\max}(\\nu=0.10),\\ \\rho_{\\max}(\\nu=0.20),\\ \\rho_{\\max}(\\nu=0.30),\\ \\text{flag}_{0.05},\\ \\text{flag}_{0.10},\\ \\text{flag}_{0.20},\\ \\text{flag}_{0.30}].$$\n\n程序必须是完全自包含的，并且无需任何输入即可生成这些值。所有计算出的答案必须是数值（浮点数或布尔值），并完全按照指定的方式聚合成单行打印的列表。", "solution": "用户提供的问题被评估为科学上合理、适定、客观和完整。所有提供的定义、方程和任务在偏微分方程数值分析领域，特别是间断伽辽金 (DG) 方法的研究中，都是标准的。因此，该问题被认为是 **有效的**，下面提供了完整的解答。\n\n### 任务1：半离散算子和符号的推导\n\n我们从一维线性平流方程 $u_t + a u_x = 0$ 开始。间断伽辽金弱形式是通过将偏微分方程乘以基中的一个测试函数 $\\phi_m$ 并在单元 $I_j = [x_{j-1/2}, x_{j+1/2}]$ 上积分得到的。\n\n$$\n\\int_{I_j} \\frac{\\partial u_h}{\\partial t} \\phi_m \\,dx + \\int_{I_j} a \\frac{\\partial u_h}{\\partial x} \\phi_m \\,dx = 0\n$$\n\n在这里，$u_h(x,t)$ 是近似解，它在每个单元内是次数为 $p=3$ 的多项式。在单元 $I_j$ 上，解通过映射 $x(r) = x_j + \\frac{h}{2}r$ 在参考单元 $r \\in [-1,1]$ 上的勒让德多项式 (Legendre polynomials) $\\{\\phi_n(r)\\}_{n=0}^3$ 模态基中展开：\n\n$$\nu_h(x(r), t) = \\sum_{n=0}^{p} c_{jn}(t) \\phi_n(r)\n$$\n\n对弱形式中的空间项应用分部积分得到：\n\n$$\n\\int_{I_j} \\frac{\\partial u_h}{\\partial t} \\phi_m \\,dx - a \\int_{I_j} u_h \\frac{\\partial \\phi_m}{\\partial x} \\,dx + [a \\, u_h \\phi_m]_{x_{j-1/2}}^{x_{j+1/2}} = 0\n$$\n\n边界项 $[a \\, u_h \\phi_m]_{x_{j-1/2}}^{x_{j+1/2}}$ 被数值通量所取代。对于波速 $a>0$ 的迎风通量，界面处的通量由上游（左侧）单元的值确定。设 $\\hat{u}(x_{j+1/2})$ 为单元 $I_j$ 右边界上的数值通量值。\n$\\hat{u}(x_{j+1/2}) = u_h(x_{j+1/2}^-)$，即来自单元 $I_j$ 内部的值。\n$\\hat{u}(x_{j-1/2}) = u_h(x_{j-1/2}^-)$，即来自单元 $I_{j-1}$ 的值。\n通量项变为：\n\n$$\na \\, \\hat{u}(x_{j+1/2}) \\phi_m(x_{j+1/2}) - a \\, \\hat{u}(x_{j-1/2}) \\phi_m(x_{j-1/2}) = a \\, u_h(x_{j+1/2}^-) \\phi_m(x_{j+1/2}) - a \\, u_h(x_{j-1/2}^-) \\phi_m(x_{j-1/2})\n$$\n\n使用 $dx = \\frac{h}{2}dr$ 和 $\\frac{\\partial}{\\partial x} = \\frac{2}{h}\\frac{\\partial}{\\partial r}$ 变换到参考单元 $r \\in [-1,1]$：\n\n$$\n\\frac{h}{2} \\int_{-1}^1 \\left(\\sum_n \\frac{dc_{jn}}{dt} \\phi_n\\right) \\phi_m \\,dr - a \\int_{-1}^1 \\left(\\sum_n c_{jn} \\phi_n\\right) \\left(\\frac{2}{h}\\phi'_m\\right) \\frac{h}{2} \\,dr + a \\left(\\sum_n c_{jn} \\phi_n(1)\\right)\\phi_m(1) - a \\left(\\sum_n c_{j-1,n} \\phi_n(1)\\right)\\phi_m(-1) = 0\n$$\n\n该方程对每个基函数 $\\phi_m$（$m=0, \\dots, p$）都成立。写成矩阵形式，其中 $c_j = [c_{j0}, \\dots, c_{jp}]^T$：\n\n$$\n\\frac{h}{2} M c'_j(t) = a K c_j(t) - a \\left(\\Phi(1)\\Phi(1)^T\\right) c_j(t) + a \\left(\\Phi(-1)\\Phi(1)^T\\right) c_{j-1}(t)\n$$\n\n其中矩阵 $M$、$K$ 和向量 $\\Phi(r)$ 在参考单元上定义：\n$M_{mn} = \\int_{-1}^1 \\phi_m(r) \\phi_n(r) dr$, $K_{mn} = \\int_{-1}^1 \\phi'_m(r) \\phi_n(r) dr$ 和 $\\Phi(r) = [\\phi_0(r), \\dots, \\phi_p(r)]^T$。\n整理后得到问题中所述的半离散形式：\n\n$$\nc'_j(t) = \\frac{2a}{h} M^{-1} \\left[ K c_j(t) - (\\Phi(1)\\Phi(1)^T) c_j(t) + (\\Phi(-1)\\Phi(1)^T) c_{j-1}(t) \\right]\n$$\n\n对于单个傅里葉模态 $c_j(t) = v(t) e^{i\\kappa j}$，我们有 $c_{j-1}(t) = v(t) e^{i\\kappa(j-1)} = e^{-i\\kappa} c_j(t)$。将其代入半离散形式，并根据定义注意到 $c'_j(t) = S(\\kappa) c_j(t)$，我们得到符号 $S(\\kappa)$：\n\n$$\nS(\\kappa) = \\frac{2a}{h} M^{-1} \\left[ K - \\Phi(1)\\Phi(1)^T + e^{-i\\kappa} \\Phi(-1)\\Phi(1)^T \\right] = \\frac{2a}{h} M^{-1} \\left[ K - F_R + e^{-i\\kappa} G \\right]\n$$\n这证实了问题中给出的表达式。\n\n当 $p=3$ 时，基函数是勒让德多项式 $\\phi_n(r) = P_n(r)$：\n$\\phi_0(r) = 1$, $\\phi_1(r) = r$, $\\phi_2(r) = \\frac{1}{2}(3r^2 - 1)$, $\\phi_3(r) = \\frac{1}{2}(5r^3 - 3r)$。\n所需的矩阵计算如下：\n- 质量矩阵 $M$：利用正交性 $\\int_{-1}^1 P_m(r)P_n(r) dr = \\frac{2}{2n+1}\\delta_{mn}$，$M$ 是对角矩阵：\n  $$M = \\text{diag}\\left(2, \\frac{2}{3}, \\frac{2}{5}, \\frac{2}{7}\\right)$$\n- 刚度矩阵 $K$：其元素为 $K_{mn} = \\int_{-1}^1 \\phi'_m(r)\\phi_n(r) dr$。利用该积分在 $n < m$ 且 $m-n$ 为奇数时为 $2$，否则为 $0$ 的性质：\n  $$K = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 2 & 0 & 0 & 0 \\\\ 0 & 2 & 0 & 0 \\\\ 2 & 0 & 2 & 0 \\end{pmatrix}$$\n- 边界面求值向量 $\\Phi(\\pm 1)$：使用 $P_n(1)=1$ 和 $P_n(-1)=(-1)^n$：\n  $\\Phi(1) = [1, 1, 1, 1]^T$ 和 $\\Phi(-1) = [1, -1, 1, -1]^T$。\n- 边界面矩阵 $F_R$ 和 $G$：\n  $F_R = \\Phi(1)\\Phi(1)^T = \\begin{pmatrix} 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\\\ 1 & 1 & 1 & 1 \\end{pmatrix}$，以及 $G = \\Phi(-1)\\Phi(1)^T = \\begin{pmatrix} 1 & 1 & 1 & 1 \\\\ -1 & -1 & -1 & -1 \\\\ 1 & 1 & 1 & 1 \\\\ -1 & -1 & -1 & -1 \\end{pmatrix}$。\n\n### 任务2和3：物理特征值、色散和耗散\n\n在矩阵已定义且常数 $a=1, h=1$ 的情况下，对于每个无量纲波数 $\\kappa$，符号 $S(\\kappa)$ 是一个 $4\\times 4$ 的复矩阵。我们计算它的四个特征值 $\\{\\lambda_j(\\kappa)\\}_{j=0}^3$。偏微分方程的解析解具有以 $e^{-iak t} = e^{-i\\kappa t}$ 形式演化的模态。物理特征值分支 $\\lambda^{\\text{phys}}(\\kappa)$ 是其虚部最接近此行为的分支。我们选择使 $|\\text{Im}(\\lambda_j(\\kappa)) - (-a\\kappa/h)| = |\\text{Im}(\\lambda_j(\\kappa)) + \\kappa|$ 最小化的特征值。\n\n从 $\\lambda^{\\text{phys}}(\\kappa)$ 计算以下量：\n- **修正波数：** $k^\\star(\\kappa) = -\\mathrm{Im}(\\lambda^\\text{phys}(\\kappa))/a$。这是数值格式的有效波数。\n- **耗散率：** $\\mathcal{D}(\\kappa) = \\mathrm{Re}(\\lambda^\\text{phys}(\\kappa))/a$。负值表示数值耗散（振幅衰减），而正值表示振幅增长（不稳定）。\n- **色散误差：** $\\mathcal{E}(\\kappa) = k^\\star(\\kappa) - k = k^\\star(\\kappa) - \\kappa/h$。这衡量了格式的相位误差。\n\n对于 $\\kappa=0$，解在空间上是常数，应该被精确地传播。我们期望 $\\lambda^{\\text{phys}}(0)=0$，从而导致 $\\mathcal{D}(0)=0$ 和 $\\mathcal{E}(0)=0$。对于其他 $\\kappa$，预计会出现非零误差。\n\n### 任务4：全离散分析和限制器比较\n\n该格式使用三阶段强稳定保持龙格－库塔方法 (SSP-RK3) 进行时间推进。一个傅里葉模态在一个时间步长 $\\Delta t$ 内的演化由 $c_j(t+\\Delta t) = G(\\kappa, \\nu) c_j(t)$ 给出，其中 $G(\\kappa, \\nu)$ 是放大矩阵。它通过将 SSP-RK3 稳定性多项式 $R(z)=1+z+\\frac{1}{2}z^2+\\frac{1}{6}z^3$ 应用于矩阵 $Z = \\Delta t S(\\kappa)$ 来定义：\n\n$$ G(\\kappa, \\nu) = R(\\Delta t S(\\kappa)) = I + \\Delta t S(\\kappa) + \\frac{(\\Delta t S(\\kappa))^2}{2} + \\frac{(\\Delta t S(\\kappa))^3}{6} $$\n\n这里，$\\nu = a\\Delta t/h$ 是 CFL 数。为了保证稳定性，$G$ 的谱半径 $\\rho(G) = \\max_j|\\lambda_j(G)|$ 必须小于或等于 $1$。我们为每个给定的 CFL 数 $\\nu$ 在一个密集的波数网格 $\\kappa \\in [0, \\pi]$ 上计算最大谱半径。\n\n问题要求比较 WENO 限制的 DG 和 TVB 限制的 DG 的结果。关键在于，问题假设在解的光滑区域（其中限制器不活跃），两种格式都简化为相同的底层线性 DG 算子。因此，它们的半离散符号 $S(\\kappa)$ 相同，放大矩阵 $G(\\kappa, \\nu)$ 相同，最大谱半径也相同。因此，在问题的假设下，这个比较是平凡的，相等标志将为 `True`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DG-p=3 linear advection analysis problem.\n    \"\"\"\n    # Problem parameters\n    p = 3\n    a = 1.0\n    h = 1.0\n\n    # Test cases from the problem statement\n    kappas_test = [0.0, 0.5, 2.5, np.pi]\n    nus_test = [0.05, 0.10, 0.20, 0.30]\n    kappa_grid_points = 201\n\n    # --- Part 1: Construct matrices for p=3 DG ---\n    \n    # Inverse of the mass matrix M\n    # M_mn = integral(P_m * P_n) = 2/(2n+1) * delta_mn\n    # M_inv_nn = (2n+1)/2\n    M_inv = np.diag([(2 * n + 1) / 2.0 for n in range(p + 1)])\n\n    # Stiffness matrix K\n    # K_mn = integral(P'_m * P_n)\n    # This is 2 if n  m and m-n is odd, 0 otherwise.\n    K = np.zeros((p + 1, p + 1))\n    for m in range(p + 1):\n        for n in range(m):\n            if (m - n) % 2 != 0:\n                K[m, n] = 2.0\n\n    # Face evaluation vectors and matrices\n    # Phi(1) = [1, 1, 1, 1]^T\n    # Phi(-1) = [1, -1, 1, -1]^T\n    phi_1 = np.ones(p + 1)\n    phi_m1 = np.array([(-1)**n for n in range(p + 1)])\n    \n    FR = np.outer(phi_1, phi_1)\n    G_face = np.outer(phi_m1, phi_1)\n\n    results = []\n\n    # --- Part 2  3: Dispersion and Dissipation Analysis ---\n    for kappa in kappas_test:\n        # Construct the symbol matrix S(kappa)\n        # S(k) = (2a/h) * M^-1 * [K - FR + exp(-i*k) * G]\n        A_kappa = K - FR + np.exp(-1j * kappa) * G_face\n        S_kappa = (2 * a / h) * M_inv @ A_kappa\n\n        # Find the physical eigenvalue\n        eigvals = np.linalg.eigvals(S_kappa)\n        target_imag = -a * kappa / h\n        phys_eig_idx = np.argmin(np.abs(np.imag(eigvals) - target_imag))\n        lambda_phys = eigvals[phys_eig_idx]\n\n        # Calculate dispersion and dissipation\n        # Dissipation rate D(k) = Re(lambda_phys)/a\n        dissipation_rate = np.real(lambda_phys) / a\n        \n        # Modified wavenumber k*(k) = -Im(lambda_phys)/a\n        k_star = -np.imag(lambda_phys) / a\n\n        # Dispersion error E(k) = k* - k\n        k = kappa / h\n        dispersion_error = k_star - k\n\n        results.extend([dispersion_error, dissipation_rate])\n\n    # --- Part 4: Fully discrete spectral radius analysis (SSP-RK3) ---\n    rho_max_results = []\n    kappa_grid = np.linspace(0, np.pi, kappa_grid_points)\n    I = np.identity(p + 1)\n\n    for nu in nus_test:\n        max_rho = 0.0\n        delta_t = nu * h / a\n\n        for kappa in kappa_grid:\n            # Construct S(kappa)\n            A_kappa = K - FR + np.exp(-1j * kappa) * G_face\n            S_kappa = (2 * a / h) * M_inv @ A_kappa\n\n            # Construct amplification matrix G(kappa, nu)\n            # G = R(delta_t * S) with R(z) = 1 + z + z^2/2 + z^3/6\n            Z = delta_t * S_kappa\n            Z2 = Z @ Z\n            Z3 = Z2 @ Z\n            G_amp = I + Z + 0.5 * Z2 + (1/6.0) * Z3\n            \n            # Spectral radius\n            rho = np.max(np.abs(np.linalg.eigvals(G_amp)))\n            if rho > max_rho:\n                max_rho = rho\n        \n        rho_max_results.append(max_rho)\n\n    results.extend(rho_max_results)\n\n    # --- Part 5: WENO vs TVB comparison ---\n    flag_results = []\n    for _ in nus_test:\n        # Per problem statement, in smooth regions, the limited schemes\n        # reduce to the same linear operator. Thus, their spectral\n        # radii are identical. The difference is 0, which is  1e-12.\n        flag_results.append(True)\n    \n    results.extend(flag_results)\n    \n    # --- Final Output Formatting ---\n    print(f\"[{','.join(f'{x:.12f}' if isinstance(x, float) else str(x).lower() for x in results)}]\")\n\nsolve()\n```", "id": "3429573"}, {"introduction": "从理想化的线性分析转向实际应用，我们会遇到非线性限制器带来的新挑战。WENO限制器的一个核心环节是计算光滑度指示因子，这通常需要依赖数值积分。本练习将探讨一个微妙但重要的问题：计算光滑度指示因子时所引入的数值积分误差，如何被非线性的WENO权重放大，进而影响限制后解的精度。通过这项实践，你将学会量化这种由数值积分引起的混叠误差（aliasing error），并理解为何在实现WENO-DG格式时，必须精心选择积分规则以保证算法的数值稳定性和设计精度。[@problem_id:3429520]", "problem": "考虑在参考单元 $I=[-1,1]$ 上，多项式次数为 $p\\in\\mathbb{N}$ 的一维间断 Galerkin (DG) 表示。设 $\\{L_k(x)\\}_{k=0}^p$ 表示 $[-1,1]$ 上的 Legendre 多项式，其归一化满足 $\\int_{-1}^{1} L_m(x)L_n(x)\\,dx=\\frac{2}{2n+1}\\delta_{mn}$。对于一个给定的光滑函数 $u(x)$，将其在次数 $\\le p$ 的多项式空间上的 $L^2$ 投影定义为 $u_p(x)=\\sum_{k=0}^p a_k L_k(x)$，其中模态系数 $a_k$ 由 $a_k=\\frac{2k+1}{2}\\int_{-1}^1 u(x)L_k(x)\\,dx$ 确定。\n\n定义一个单参数 WENO 型模态限制器，该限制器保持平均模态不变，并通过一个非线性权重对所有更高阶的模态进行统一缩放。具体来说，设光滑度指示子为 $\\beta=\\int_{-1}^{1} \\left(u_p'(x)\\right)^2\\,dx$。该限制器通过 $\\tilde{a}_0=a_0$ 和 $\\tilde{a}_k=\\omega\\,a_k$ (对于所有 $k\\in\\{1,\\dots,p\\}$) 来构造一个受限的模态向量 $\\tilde{a}=(\\tilde{a}_0,\\tilde{a}_1,\\dots,\\tilde{a}_p)$，其中非线性权重 $\\omega\\in(0,1)$ 由双候选 Jiang–Shu 形式定义\n$$\n\\alpha_{\\text{keep}}=\\frac{d_{\\text{keep}}}{(\\epsilon+\\beta)^r},\\qquad\n\\alpha_{\\text{zero}}=d_{\\text{zero}},\\qquad\n\\omega=\\frac{\\alpha_{\\text{keep}}}{\\alpha_{\\text{keep}}+\\alpha_{\\text{zero}}}.\n$$\n此处，$d_{\\text{keep}}\\in(0,1)$ 和 $d_{\\text{zero}}\\in(0,1)$ 是固定的线性权重，满足 $d_{\\text{keep}}+d_{\\text{zero}}=1$，$\\epsilon0$ 是一个防止除以零的小参数，$r\\ge 1$ 是一个正整数。在实践中，光滑度指示子的积分通过使用 $q$ 个点的 Gauss–Legendre 求积来近似，\n$$\n\\beta_q=\\sum_{i=1}^{q} w_i\\left(u_p'(x_i)\\right)^2,\n$$\n其中 $\\{(x_i,w_i)\\}_{i=1}^q$ 是 $[-1,1]$ 上的 Gauss–Legendre 节点和权重。相应的权重记为 $\\omega_q$，相应的受限系数记为 $\\tilde{a}^{(q)}$。定义一个高精度基准 $\\beta_\\star$，它通过使用 $q_\\star$ 个点的 Gauss–Legendre 求积计算得出，其中 $q_\\star$ 足够大（取 $q_\\star=200$），相关的权重和受限系数为 $\\omega_\\star$ 和 $\\tilde{a}^{(\\star)}$。\n\n你的目标是：\n- 仅从 $L^2$ 投影、Legendre 正交性和 Gauss–Legendre 求积的定义出发，量化因使用 $\\beta_q$ 而非 $\\beta_\\star$ 导致非线性 WENO 权重应用于模态系数时引入的混叠误差。使用系数空间的欧几里得误差\n$$\n\\mathcal{E}(p,q,\\epsilon,r,u)=\\left\\|\\tilde{a}^{(q)}-\\tilde{a}^{(\\star)}\\right\\|_2.\n$$\n- 提出并实现一个使用 $q\\ge 2p$ 个 Gauss–Legendre 点的求积法则，以在存在非线性模态限制的情况下保持 DG 的设计精度，并与更小和更大的 $q$ 值进行数值比较。\n- 测试 $\\mathcal{E}$ 对非线性权重中参数 $\\epsilon$ 的敏感性。\n\n使用以下基本理论：\n- $L^2([-1,1])$ 中到多项式子空间上的正交投影。\n- $[-1,1]$ 上 Legendre 多项式的正交性和完备性。\n- 阶数为 $q$ 的 Gauss–Legendre 求积对于次数 $\\le 2q-1$ 的被积函数的精确性。\n\n算法要求：\n- 通过使用 $q_\\text{proj}$ 个点的 Gauss–Legendre 求积来数值计算 $\\int_{-1}^{1} u(x)L_k(x)\\,dx$，从而计算模态系数 $a_k$。其中 $q_\\text{proj}$ 足够大，以至于对于所选的光滑函数 $u(x)$ 而言，计算结果实际上是精确的（取 $q_\\text{proj}=200$）。\n- 通过基于 Legendre 基的操作，构造 $u_p(x)=\\sum_{k=0}^p a_k L_k(x)$ 及其导数 $u_p'(x)$。\n- 对于给定的 $q$ 计算 $\\beta_q$，对于 $q_\\star=200$ 计算 $\\beta_\\star$；然后计算 $\\omega_q$ 和 $\\omega_\\star$ 以及相应的受限向量 $\\tilde{a}^{(q)}$ 和 $\\tilde{a}^{(\\star)}$。\n- 对每个测试，将 $\\mathcal{E}(p,q,\\epsilon,r,u)$ 报告为一个浮点数。\n\n用于 $u(x)$ 的函数：\n- $u_1(x)=\\sin(\\pi x)$。\n- $u_2(x)=\\exp(x)$。\n\n在所有测试中，固定 $d_{\\text{keep}}=0.99$，$d_{\\text{zero}}=0.01$ 和 $r=2$。\n\n测试组：\n- 情况 1：$p=3$, $q=6$, $\\epsilon=10^{-6}$, $u=u_1$。\n- 情况 2：$p=3$, $q=3$, $\\epsilon=10^{-6}$, $u=u_1$。\n- 情况 3：$p=3$, $q=9$, $\\epsilon=10^{-6}$, $u=u_1$。\n- 情况 4：$p=4$, $q=8$, $\\epsilon=10^{-12}$, $u=u_2$。\n- 情况 5：$p=4$, $q=8$, $\\epsilon=10^{-3}$, $u=u_2$。\n- 情况 6：$p=1$, $q=2$, $\\epsilon=10^{-6}$, $u=u_1$。\n\n角度单位不适用。不涉及物理单位。每个测试必须返回一个等于 $\\mathcal{E}(p,q,\\epsilon,r,u)$ 的单个实数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与测试组相同，例如 $[\\mathcal{E}_1,\\mathcal{E}_2,\\dots,\\mathcal{E}_6]$。", "solution": "该问题要求分析一种用于间断 Galerkin (DG) 方法的加权基本无振荡 (WENO) 型模态限制器所引入的数值误差。所研究的误差来源是使用具有有限数量点 $q$ 的数值求积来计算光滑度指示子 $\\beta$，而 $\\beta$ 又决定了非线性限制权重 $\\omega$。误差通过使用 $q$ 个点计算的受限模态系数向量 $\\tilde{a}^{(q)}$ 与使用大量点 $q_\\star$ 计算的高精度基准向量 $\\tilde{a}^{(\\star)}$ 之差的欧几里得范数来衡量。\n\n解决方案分几步进行：\n1.  函数及其投影的表示。\n2.  光滑度指示子的公式及其数值计算。\n3.  精确求积条件的分析。\n4.  受限模态系数和误差度量的计算。\n\n**1. L2 投影和多项式表示**\n\n给定参考区间 $I = [-1, 1]$ 上的一个光滑函数 $u(x)$，其在次数至多为 $p$ 的多项式空间 $\\mathbb{P}_p$ 上的 $L^2$ 投影由下式给出：\n$$\nu_p(x) = \\sum_{k=0}^{p} a_k L_k(x)\n$$\n其中 $\\{L_k(x)\\}_{k=0}^p$ 是 Legendre 多项式。模态系数 $a_k$ 通过利用 Legendre 多项式的正交性 $\\int_{-1}^{1} L_m(x)L_n(x)\\,dx=\\frac{2}{2n+1}\\delta_{mn}$ 来确定：\n$$\n\\int_{-1}^{1} u(x) L_k(x) \\,dx = \\sum_{j=0}^{p} a_j \\int_{-1}^{1} L_j(x) L_k(x) \\,dx = a_k \\frac{2}{2k+1}\n$$\n这给出了精确模态系数的公式：\n$$\na_k = \\frac{2k+1}{2} \\int_{-1}^{1} u(x) L_k(x) \\,dx\n$$\n在本问题中，此积分使用具有足够多点数 $q_{\\text{proj}}=200$ 的 Gauss-Legendre 求积进行数值计算，以确保高精度。设求积节点和权重为 $\\{(x_j^{\\text{proj}}, w_j^{\\text{proj}})\\}_{j=1}^{q_{\\text{proj}}}$。计算出的系数为：\n$$\na_k \\approx \\hat{a}_k = \\frac{2k+1}{2} \\sum_{j=1}^{q_{\\text{proj}}} w_j^{\\text{proj}} u(x_j^{\\text{proj}}) L_k(x_j^{\\text{proj}})\n$$\n在接下来的分析中，我们将使用多项式 $\\hat{u}_p(x) = \\sum_{k=0}^p \\hat{a}_k L_k(x)$，该多项式由这些数值计算出的系数构建而成。\n\n**2. 光滑度指示子和数值求积**\n\nWENO 限制器的行为由光滑度指示子 $\\beta$ 控制，其定义为多项式近似导数的平方 $L^2$-范数：\n$$\n\\beta = \\int_{-1}^{1} (\\hat{u}_p'(x))^2 \\,dx\n$$\n导数 $\\hat{u}_p'(x)$ 通过对多项式逐项求导形成：\n$$\n\\hat{u}_p'(x) = \\sum_{k=0}^{p} \\hat{a}_k L_k'(x) = \\sum_{k=1}^{p} \\hat{a}_k L_k'(x) \\quad (\\text{因为 } L_0'(x)=0)\n$$\n由于 $L_k'(x)$ 是一个 $k-1$ 次多项式，$\\hat{u}_p'(x)$ 是一个次数至多为 $p-1$ 的多项式。因此，被积函数 $(\\hat{u}_p'(x))^2$ 是一个次数至多为 $2(p-1)$ 的多项式。\n\n具有 $q$ 个点的 Gauss-Legendre 求积对于任何次数最高为 $2q-1$ 的多项式被积函数都是精确的。要精确计算 $\\beta$（在浮点精度范围内），我们必须选择 $q$ 使得：\n$$\n2q - 1 \\ge 2(p-1) \\implies 2q \\ge 2p - 1 \\implies q \\ge p - \\frac{1}{2}\n$$\n由于 $q$ 必须是整数，任何 $q \\ge p$ 的选择都将导致对 $\\beta$ 的积分进行精确计算。\n\n问题要求将使用 $q$ 个点计算的 $\\beta_q$ 与使用 $q_\\star = 200$ 个点计算的基准 $\\beta_\\star$ 进行比较。鉴于在所有测试用例中 $p \\ll 200$，基准 $\\beta_\\star$ 可以被视为积分的精确值。对于任何 $q \\ge p$ 的测试用例，理论上 $\\beta_q$ 也应该是精确的，因此 $\\beta_q = \\beta_\\star$。\n\n**3. 非线性限制与误差分析**\n\n受限的模态系数 $\\tilde{a}_k$ 计算如下：\n$$\n\\tilde{a}_0 = \\hat{a}_0, \\qquad \\tilde{a}_k = \\omega \\cdot \\hat{a}_k \\quad \\text{对于 } k \\in \\{1, \\dots, p\\}\n$$\n非线性权重 $\\omega$ 是 $\\beta$ 的函数：\n$$\n\\omega(\\beta) = \\frac{\\alpha_{\\text{keep}}}{\\alpha_{\\text{keep}}+\\alpha_{\\text{zero}}} = \\frac{d_{\\text{keep}}/(\\epsilon+\\beta)^r}{d_{\\text{keep}}/(\\epsilon+\\beta)^r + d_{\\text{zero}}}\n$$\n误差度量是系数向量 $\\tilde{a}^{(q)}$ (使用 $\\omega_q = \\omega(\\beta_q)$) 与基准向量 $\\tilde{a}^{(\\star)}$ (使用 $\\omega_\\star = \\omega(\\beta_\\star)$) 之间的欧几里得距离：\n$$\n\\mathcal{E} = \\left\\|\\tilde{a}^{(q)}-\\tilde{a}^{(\\star)}\\right\\|_2 = \\sqrt{\\sum_{k=0}^p (\\tilde{a}_k^{(q)} - \\tilde{a}_k^{(\\star)})^2}\n$$\n由于 $\\tilde{a}_0^{(q)} = \\tilde{a}_0^{(\\star)} = \\hat{a}_0$，求和从 $k=1$ 开始：\n$$\n\\mathcal{E}^2 = \\sum_{k=1}^p (\\omega_q \\hat{a}_k - \\omega_\\star \\hat{a}_k)^2 = (\\omega_q - \\omega_\\star)^2 \\sum_{k=1}^p \\hat{a}_k^2\n$$\n$$\n\\mathcal{E} = |\\omega_q - \\omega_\\star| \\sqrt{\\sum_{k=1}^p \\hat{a}_k^2}\n$$\n仅当 $\\omega_q \\ne \\omega_\\star$ 时，误差 $\\mathcal{E}$ 才非零，这意味着 $\\beta_q \\ne \\beta_\\star$。如前所述，对于 $q \\ge p$，$\\beta_q$ 和 $\\beta_\\star$ 都应该是对同一积分的精确计算。然而，它们是使用不同的求积节点和权重集计算的，导致不同的浮点运算序列。计算出的值 $\\beta_q^{\\text{float}}$ 和 $\\beta_\\star^{\\text{float}}$ 可能因舍入误差而有微小差异。\n$$\n\\beta_q^{\\text{float}} - \\beta_\\star^{\\text{float}} \\approx O(\\epsilon_{\\text{machine}})\n$$\n这个微小的差异可能会被非线性函数 $\\omega(\\beta)$ 显著放大，特别是如果其导数 $\\frac{d\\omega}{d\\beta}$ 很大。该导数为：\n$$\n\\frac{d\\omega}{d\\beta} = \\frac{-r \\, d_{\\text{keep}} \\, d_{\\text{zero}}}{(\\epsilon+\\beta)^{r+1} \\left( d_{\\text{keep}}(\\epsilon+\\beta)^{-r} + d_{\\text{zero}} \\right)^2}\n$$\n当光滑度参数 $\\epsilon$ 非常小时，这个导数可能会变得非常大，特别是对于小的 $\\beta$。这解释了误差 $\\mathcal{E}$ 对 $\\epsilon$ 的敏感性。因此，该问题是对限制器公式数值稳定性的研究，在精确算术中本应为零的误差，在有限精度算术中表现为非零误差，其大小取决于具体的求积法则 ($q$) 和参数 ($\\epsilon$)。\n\n问题描述中建议 $q\\ge 2p$，虽然在这个特定的指示子公式中对于多项式精确性来说并非严格必要，但它代表了一种在 DG 方法中常用于非线性通量项的更保守的经验法则，以确保在更一般的情况下具有鲁棒性并能控制混叠误差。测试组允许进行数值探索，以确定这种保守选择在此处是否提供更好的数值稳定性。\n\n**4. 计算步骤**\n\n对于由 $(p, q, \\epsilon, u)$ 指定的每个测试用例：\n1.  设置固定参数：$r=2$, $d_\\text{keep}=0.99$, $d_\\text{zero}=0.01$, $q_\\text{proj}=200$, $q_\\star=200$。\n2.  通过使用 $q_\\text{proj}$ 个 Gauss-Legendre 点对 $u(x)$ 进行数值投影，计算 $k=0, \\dots, p$ 的模态系数 $\\hat{a}_k$。\n3.  构造导数的多项式表示，$\\hat{u}_p'(x) = \\sum_{k=1}^p \\hat{a}_k L_k'(x)$。\n4.  通过使用 $q$ 个 Gauss-Legendre 点对 $(\\hat{u}_p'(x))^2$ 进行积分，计算光滑度指示子 $\\beta_q$。\n5.  通过使用 $q_\\star=200$ 个 Gauss-Legendre 点对 $(\\hat{u}_p'(x))^2$ 进行积分，计算参考光滑度指示子 $\\beta_\\star$。\n6.  使用提供的公式计算相应的非线性权重 $\\omega_q = \\omega(\\beta_q)$ 和 $\\omega_\\star = \\omega(\\beta_\\star)$。\n7.  构造受限的系数向量 $\\tilde{a}^{(q)}$ 和 $\\tilde{a}^{(\\star)}$。\n8.  计算并报告误差 $\\mathcal{E} = \\|\\tilde{a}^{(q)} - \\tilde{a}^{(\\star)}\\|_2$。\n\n对每个测试用例执行此过程以生成最终结果。", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre\n\ndef compute_error(p, q, epsilon, r, u_func, d_keep, d_zero):\n    \"\"\"\n    Computes the aliasing error for the WENO modal limiter.\n\n    Args:\n        p (int): Polynomial degree.\n        q (int): Number of quadrature points for the test indicator.\n        epsilon (float): Regularization parameter for the WENO weight.\n        r (int): Exponent for the WENO weight.\n        u_func (callable): The smooth function u(x).\n        d_keep (float): Linear weight for the 'keep' stencil.\n        d_zero (float): Linear weight for the 'zero' stencil.\n\n    Returns:\n        float: The coefficient-space Euclidean error E.\n    \"\"\"\n    q_proj = 200\n    q_star = 200\n\n    # 1. Compute modal coefficients a_k by numerical projection\n    x_proj, w_proj = np.polynomial.legendre.leggauss(q_proj)\n    u_vals_proj = u_func(x_proj)\n    a = np.zeros(p + 1)\n    for k in range(p + 1):\n        L_k_poly = legendre(k)\n        L_k_vals_proj = L_k_poly(x_proj)\n        integral = np.sum(w_proj * u_vals_proj * L_k_vals_proj)\n        a[k] = (2 * k + 1) / 2.0 * integral\n\n    # 2. Form the derivative polynomial u_p'(x)\n    # This creates a callable polynomial object for u_p'(x)\n    up_prime_poly = np.poly1d([0.0])\n    if p > 0:\n        for k in range(1, p + 1):\n            if np.abs(a[k]) > 1e-40: # Avoid adding zero polynomials\n                L_k_poly = legendre(k)\n                L_k_prime_poly = L_k_poly.deriv(1)\n                up_prime_poly += a[k] * L_k_prime_poly\n\n    # 3. Compute beta_q and beta_star\n    # Function to compute beta for a given number of quadrature points\n    def calculate_beta(num_points):\n        if num_points == 0:\n            return 0.0\n        x_quad, w_quad = np.polynomial.legendre.leggauss(num_points)\n        up_prime_vals = up_prime_poly(x_quad)\n        beta_val = np.sum(w_quad * up_prime_vals**2)\n        return beta_val\n\n    beta_q = calculate_beta(q)\n    beta_star = calculate_beta(q_star)\n\n    # 4. Compute omega weights\n    def calculate_omega(beta):\n        alpha_keep = d_keep / (epsilon + beta)**r\n        alpha_zero = d_zero\n        # Handle potential division by zero if both are zero.\n        if alpha_keep + alpha_zero == 0:\n            return 0.0\n        return alpha_keep / (alpha_keep + alpha_zero)\n\n    omega_q = calculate_omega(beta_q)\n    omega_star = calculate_omega(beta_star)\n    \n    # 5. Construct limited coefficient vectors\n    a_tilde_q = np.copy(a)\n    a_tilde_star = np.copy(a)\n    \n    a_tilde_q[1:] *= omega_q\n    a_tilde_star[1:] *= omega_star\n\n    # 6. Compute the Euclidean error\n    error = np.linalg.norm(a_tilde_q - a_tilde_star)\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the results.\n    \"\"\"\n    # Define functions for u(x)\n    u1 = lambda x: np.sin(np.pi * x)\n    u2 = lambda x: np.exp(x)\n\n    # Fixed parameters for all tests\n    d_keep = 0.99\n    d_zero = 0.01\n    r = 2\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (p, q, epsilon, u_func)\n        (3, 6, 1e-6, u1),   # Case 1\n        (3, 3, 1e-6, u1),   # Case 2\n        (3, 9, 1e-6, u1),   # Case 3\n        (4, 8, 1e-12, u2),  # Case 4\n        (4, 8, 1e-3, u2),   # Case 5\n        (1, 2, 1e-6, u1),   # Case 6\n    ]\n\n    results = []\n    for p, q, eps, u_f in test_cases:\n        error_val = compute_error(p, q, eps, r, u_f, d_keep, d_zero)\n        results.append(error_val)\n    \n    # Format the output exactly as required\n    print(f\"[{','.join(f'{res:.10e}' for res in results)}]\")\n\nsolve()\n```", "id": "3429520"}, {"introduction": "为了使WENO-DG方法能够应用于真实的复杂物理问题，必须将其从一维均匀网格推广到非结构网格上。在复杂的几何构型中，为高阶重构选择一个合适的模板（stencil）是一个关键且非平凡的任务。本练习将引导你设计并实现一种基于图论距离的自适应模板选择策略，该策略能够根据局部解的光滑度动态调整模板，从而在计算中智能地“绕开”间断。此外，本练习还将数值算法与高性能计算相结合，要求你分析该算法在简化GPU并行模型下的计算复杂度和可扩展性，这对于开发高效的现代科学计算程序至关重要。[@problem_id:3429522]", "problem": "您的任务是为非结构化网格上的间断伽辽金 (DG) 方法中的加权基本无振荡 (WENO) 重构，设计并评估一种基于图距离的模板自适应策略。底层网格表示为一个无向图。对于每个网格单元，目标是通过在基于图距离的 $k$-环内选择邻居来构建一个 WENO 重构模板，并根据局部光滑度指示器调整该模板，以模拟光滑度感知的模板应避免跨越间断的理念。您的程序必须实现该选择策略，量化计算复杂度，并在简化的图形处理单元 (GPU) 执行模型下估算并行可扩展性。\n\n基本基础：\n- 使用无向图 $G = (V, E)$ 的定义，其中 $V$ 是顶点（单元）集合，$E$ 是无向边（邻接关系）集合，图距离 $d(i,j)$ 是 $i$ 和 $j$ 之间最短路径的长度（以边数计）。\n- 在采用 WENO 重构的 DG 方法中，为每个单元从其邻居中选择一个重构模板，以在间断附近实现无振荡行为。此选择由从标量场计算出的局部光滑度指示器指导。\n- $k$-环邻居的计算依赖于广度优先搜索 (BFS) 层。限制在 $k$ 层内的 BFS 会访问所有满足 $d(i,j) \\le k$ 的节点 $j$。\n\n定义和要求：\n- 对于每个单元 $i \\in V$，其图邻居为 $\\mathcal{N}(i)$，定义其 $k$-环邻域为 $\\{ j \\in V \\setminus \\{i\\} \\mid d(i,j) \\le k \\}$。\n- 给定一个标量场 $u: V \\to \\mathbb{R}$，定义 $i$ 和 $j$ 之间的边光滑度指示器为\n$$\nS(i,j) = \\frac{|u(j) - u(i)|}{|u(j)| + |u(i)| + \\varepsilon},\n$$\n其中 $\\varepsilon  0$ 是一个小的正则化常数。\n- 对于每个单元 $i$，通过将环半径 $r$ 从 $r=1$ 增加到 $r=k_i$（其中 $k_i$ 是单元 $i$ 的最大环）来构建自适应模板 $S_i$。在每个环 $r$ 处，考虑所有已发现的满足 $d(i,j) \\le r$ 的候选单元的并集，并接受那些满足 $S(i,j) \\le \\tau$ 的候选单元，其中 $\\tau  0$ 是一个阈值。一旦 $|S_i| \\ge s_{\\min}$ 或 $r = k_i$，就停止增加 $r$。如果结束时 $|S_i|  s_{\\min}$，则通过添加距离最近的剩余候选单元（按 $d(i,j)$ 递增排序；若距离相同，则按较小的 $S(i,j)$ 打破平局）来填充 $S_i$，这些候选单元来自 $d(i,j) \\le k_i$ 的范围内，忽略阈值，直到 $|S_i| = s_{\\min}$ 或没有更多候选单元为止。\n- BFS 必须按递增的 $r$ 逐个单元进行，以便如果模板在达到 $k_i$ 之前已达到大小 $s_{\\min}$，可以提前停止，从而使计算工作量适应局部光滑度。\n- 复杂度指标：\n  - 统计所有单元在 BFS 过程中访问的单位边检查总数。每当算法在 BFS 队列中检查一个弹出节点的邻居时，此计数加一。\n  - 统计所有单元的光滑度指示器评估总数。每次为单元 $i$ 首次发现候选邻居 $j$ 并计算 $S(i,j)$ 时，此计数加一。\n- GPU 上的并行可扩展性模型：\n  - 假设每个单元一个线程，这些线程被分组为大小为 $w=32$ 的线程束 (warp)。\n  - 设单元 $i$ 的成本为 $c_i = \\text{i 的边检查数} + \\text{i 的指示器评估数}$。\n  - 将单元划分为大小为 $w$ 的连续线程束，即索引 $0$ 到 $w-1$ 在线程束 $0$ 中， $w$ 到 $2w-1$ 在线程束 $1$ 中，依此类推。对于最后一个线程束，如果剩余的单元少于 $w$ 个，则它形成一个部分线程束。\n  - 一个线程束的时间是其包含的所有单元中最大的 $c_i$（模拟锁步执行和分歧）。\n  - 预测的并行时间是每个线程束时间的总和。基准串行时间是 $\\sum_i c_i$。\n  - 定义预测的并行效率为\n  $$\n  \\eta = \\frac{\\sum_i c_i}{\\sum_{\\text{线程束 } \\omega} \\max_{i \\in \\omega} c_i},\n  $$\n  预测的加速比为\n  $$\n  \\text{speedup} = \\frac{\\sum_i c_i}{\\sum_{\\text{线程束 } \\omega} \\max_{i \\in \\omega} c_i}。\n  $$\n  在此模型下，加速比等于效率，因为基准和并行时间由相同的成本度量归一化。\n\n您的程序必须：\n- 按规定实现自适应模板选择。\n- 对于下面的每个测试用例，输出：\n  - 按索引顺序排列的所有单元 $i$ 的最终模板大小 $|S_i|$ 的列表。\n  - 边检查总数（一个整数）。\n  - 指示器评估总数（一个整数）。\n  - 预测的并行效率（一个浮点数）。\n  - 预测的加速比（一个浮点数）。\n- 最终的程序输出必须是单行，其中包含所有给定测试用例的结果，形式为逗号分隔的列表，每个测试用例的结果按上述顺序格式化为一个列表。\n\n测试套件：\n- 测试用例 1（理想情况，度数近似均匀）：\n  - 包含 $N = 9$ 个顶点（索引 0 到 8）的图，表示一个具有 4-连通性的 $3 \\times 3$ 网格。邻接表（对于每个索引 $i$，列表包含 $i$ 的邻居）：\n    - $0 : [1, 3]$\n    - $1 : [0, 2, 4]$\n    - $2 : [1, 5]$\n    - $3 : [0, 4, 6]$\n    - $4 : [1, 3, 5, 7]$\n    - $5 : [2, 4, 8]$\n    - $6 : [3, 7]$\n    - $7 : [4, 6, 8]$\n    - $8 : [5, 7]$\n  - 场值 $u = [0, 1, 2, 1, 2, 3, 2, 3, 4]$。\n  - 所有 $i$ 的环限制 $k_i = 2$。\n  - 阈值 $\\tau = 0.2$，目标模板大小 $s_{\\min} = 3$，以及 $\\varepsilon = 10^{-12}$。\n\n- 测试用例 2（边界情况，辐射状结构和强光滑度剪枝）：\n  - 包含 $N = 11$ 个顶点的图：\n    - $0 : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]$\n    - $1 : [0]$\n    - $2 : [0]$\n    - $3 : [0]$\n    - $4 : [0]$\n    - $5 : [0]$\n    - $6 : [0]$\n    - $7 : [0]$\n    - $8 : [0]$\n    - $9 : [0]$\n    - $10 : [0]$\n  - 场值 $u = [0, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10]$。\n  - 所有 $i$ 的环限制 $k_i = 1$。\n  - 阈值 $\\tau = 0.05$，目标模板大小 $s_{\\min} = 4$，以及 $\\varepsilon = 10^{-12}$。\n\n- 测试用例 3（度数不规则且存在局部间断）：\n  - 包含 $N = 12$ 个顶点的图：\n    - $0 : [1, 2]$\n    - $1 : [0, 3, 4]$\n    - $2 : [0, 4, 5]$\n    - $3 : [1, 6]$\n    - $4 : [1, 2, 7]$\n    - $5 : [2, 8]$\n    - $6 : [3, 7, 9]$\n    - $7 : [4, 6, 10]$\n    - $8 : [5, 10, 11]$\n    - $9 : [6, 10]$\n    - $10 : [7, 8, 9, 11]$\n    - $11 : [8, 10]$\n  - 场值 $u = [0.0, 0.1, 0.2, 0.15, 0.25, 0.3, 2.0, 2.1, 0.35, 2.05, 2.2, 0.4]$。\n  - 环限制 $k_i = [2, 2, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2]$。\n  - 阈值 $\\tau = 0.2$，目标模板大小 $s_{\\min} = 3$，以及 $\\varepsilon = 10^{-12}$。\n\n角度单位不适用。物理单位不适用。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含所有结果，形式为逗号分隔的列表，每个测试用例的结果格式化为：\n  - $[\\text{stencil\\_sizes\\_list}, \\text{total\\_edge\\_examinations}, \\text{total\\_indicator\\_evaluations}, \\text{predicted\\_efficiency}, \\text{predicted\\_speedup}]$\n- 整个输出必须是以下形式的单行：\n  - $[[\\ldots], [\\ldots], [\\ldots]]$\n其中每个 $[\\ldots]$ 对应于按上述顺序指定的一个测试用例。", "solution": "该问题要求为在非结构化网格上的间断伽辽金 (DG) 框架内，设计并实现一种用于加权基本无振荡 (WENO) 重构的基于图距离的自适应模板选择策略。该解决方案涉及为每个网格单元开发一个构建模板的算法，量化其计算复杂度，并在一个简化的 GPU 模型上评估其并行性能。\n\n### **问题验证**\n\n**步骤 1：提取给定条件**\n\n1.  **图表示**：一个无向图 $G = (V, E)$，其中 $V$ 是网格单元（顶点）的集合，$E$ 表示邻接关系（边）。图距离 $d(i,j)$ 是单元 $i$ 和 $j$ 之间最短路径的边数。\n2.  **$k$-环邻域**：对于一个单元 $i$，其 $k$-环邻域是 $\\{ j \\in V \\setminus \\{i\\} \\mid d(i,j) \\le k \\}$。\n3.  **标量场**：在单元上定义了一个标量场 $u: V \\to \\mathbb{R}$。\n4.  **光滑度指示器**：单元 $i$ 和 $j$ 之间的边光滑度指示器由下式给出\n    $$\n    S(i,j) = \\frac{|u(j) - u(i)|}{|u(j)| + |u(i)| + \\varepsilon}\n    $$\n    其中 $\\varepsilon  0$ 是一个小的正则化常数。\n5.  **自适应模板构建**：对于每个单元 $i$，通过将环半径 $r$ 从 1 迭代到指定的最大值 $k_i$ 来构建模板 $S_i$。在每个半径 $r$ 处，考虑满足 $d(i,j) \\le r$ 的候选邻居 $j$。如果候选邻居 $j$ 的光滑度指示器 $S(i,j)$ 小于或等于阈值 $\\tau  0$，则将其添加到 $S_i$。一旦模板大小 $|S_i|$ 达到或超过目标最小大小 $s_{\\min}$，或者当 $r$ 达到 $k_i$ 时，停止增加 $r$ 的过程。\n6.  **回退机制**：如果在检查完所有达到 $k_i$ 的环后，模板大小 $|S_i|$ 仍小于 $s_{\\min}$，则通过添加最近的剩余候选单元（那些因光滑度检查而被拒绝的单元）来填充模板，直到 $|S_i| = s_{\\min}$ 或 $k_i$-环内的所有候选单元都已用尽。距离相同的情况下，通过较小的 $S(i,j)$ 值来打破平局。\n7.  **复杂度指标**：\n    *   **总边检查数**：在所有单元的广度优先搜索 (BFS) 遍历期间，邻居检查的总次数。\n    *   **总指示器评估数**：在所有单元中，为新发现的候选邻居计算 $S(i,j)$ 的总次数。\n8.  **并行性能模型**：\n    *   每个单元一个线程，线程被分组为大小为 $w=32$ 的线程束 (warp)。\n    *   单元 $i$ 的成本：$c_i = (\\text{单元 } i \\text{ 的边检查数}) + (\\text{单元 } i \\text{ 的指示器评估数})$。\n    *   线程束时间：对于一个线程束 $\\omega$，其时间为 $\\max_{i \\in \\omega} c_i$。\n    *   总并行时间：$\\sum_{\\text{线程束 } \\omega} \\max_{i \\in \\omega} c_i$。\n    *   总串行时间：$\\sum_{i \\in V} c_i$。\n    *   预测的并行效率和加速比：$\\eta = \\text{speedup} = \\frac{\\sum_i c_i}{\\sum_{\\omega} \\max_{i \\in \\omega} c_i}$。\n9.  **测试用例**：提供了三个具体的测试用例，每个用例都包含图结构（邻接表）、标量场 $u$、逐单元的环限制 $k_i$ 以及全局参数 $\\tau$、$s_{\\min}$ 和 $\\varepsilon$。\n\n**步骤 2：使用提取的给定条件进行验证**\n\n根据验证标准对问题进行评估。\n\n*   **科学性**：该问题植根于偏微分方程数值方法领域，特别是 WENO-DG 方法。模板、光滑度指示器和基于图的邻域选择等概念是标准的且科学上合理的。GPU 性能模型虽然简化，但抓住了线程束分歧这一并行性能关键因素的核心概念。\n*   **良构性**：模板构建算法被确定性地描述。环半径的迭代增加、接受候选单元的条件、停止准则以及回退机制都已明确规定，确保可以为每个单元构建唯一的模板。回退机制的平局打破规则进一步确保了唯一性。\n*   **客观性**：问题使用精确的数学定义和客观标准进行陈述。所有术语都经过了正式定义。\n\n该问题未表现出任何无效标志。它在科学上是合理的、可形式化的、完整的、可行的、良构的且并非微不足道的。\n\n**步骤 3：结论与行动**\n\n该问题被判定为**有效**。将制定并实现一个解决方案。\n\n### **算法设计与解决方案**\n\n任务的核心是为每个单元 $i \\in V$ 实现自适应模板选择算法。“一旦 $|S_i| \\ge s_{\\min}$ 就停止增加 $r$” 的要求表明，该算法应按层探索图，而不是执行一次完整的 BFS 来预计算所有距离。分层 BFS 方法是满足此条件的最有效方式。\n\n对于每个单元 $i \\in V$，执行以下过程：\n\n1.  **初始化**：\n    *   为模板初始化一个空集，$S_i = \\emptyset$。\n    *   初始化一个空列表 `rejected_candidates`，用于存储未通过光滑度测试的邻居 $j$ 的元组 $(d, S, j)$。\n    *   为此单元的成本初始化计数器：`edge_examinations_i = 0` 和 `indicator_evaluations_i = 0`。\n    *   从单元 $i$ 开始进行分层 BFS。设 `current_layer_nodes` 是一个仅包含 $i$ 的列表，`visited_bfs` 是一个仅包含 $i$ 的集合。设置初始距离 `dist = 0`。\n\n2.  **分层 BFS 与模板构建**：\n    *   进入一个循环，只要当前距离 `dist` 小于单元 $i$ 的最大环限制 $k_i$，循环就继续。如果模板大小 $|S_i|$ 达到或超过目标最小大小 $s_{\\min}$，则循环提前终止。\n    *   在循环内部，增加距离：`dist` $\\leftarrow$ `dist` $+ 1$。\n    *   为下一层识别所有新的邻居。遍历 `current_layer_nodes` 中的每个节点 $u$。对于图邻接表中 $u$ 的每个邻居 $v$：\n        *   增加 `edge_examinations_i`。\n        *   如果 $v$ 尚未被访问（即 $v \\notin \\text{visited\\_bfs}$），则将其标记为已访问，并添加到 `next_layer_nodes` 列表和一个 `candidates_at_this_dist` 集合中。\n    *   处理新发现的候选单元。对于 `candidates_at_this_dist` 中的每个唯一候选单元 $j$（为确保确定性，按节点索引排序）：\n        *   增加 `indicator_evaluations_i`。\n        *   使用给定的标量场 $u$ 和正则化 $\\varepsilon$ 计算光滑度指示器 $S(i, j)$。\n        *   如果 $S(i, j) \\le \\tau$，将 $j$ 添加到模板 $S_i$ 中。\n        *   否则，将元组 $(dist, S(i,j), j)$ 添加到 `rejected_candidates` 列表中。\n    *   将 `current_layer_nodes` 更新为 `next_layer_nodes` 以进行下一次迭代。如果 `next_layer_nodes` 为空，则无法到达更远的单元，因此可以终止循环。\n\n3.  **回退机制**：\n    *   循环终止后，检查是否 $|S_i|  s_{\\min}$。\n    *   如果模板太小，对 `rejected_candidates` 列表进行排序。主排序键是距离 `dist`，次排序键是光滑度值 $S$。\n    *   遍历排序后的 `rejected_candidates`，并将其对应的节点添加到 $S_i$ 中，直到 $|S_i| = s_{\\min}$ 或 `rejected_candidates` 列表被用尽。\n\n4.  **复杂度与性能指标聚合**：\n    *   处理完所有单元 $i \\in V$ 后，收集最终的模板大小 $|S_i|$。\n    *   通过对单个计数求和来计算总边检查数和总指示器评估数：$\\sum_i \\text{edge\\_examinations}_i$ 和 $\\sum_i \\text{indicator\\_evaluations}_i$。\n    *   为每个 $i$ 计算单位成本 $c_i = \\text{edge\\_examinations}_i + \\text{indicator\\_evaluations}_i$。\n    *   预测的串行时间为 $T_{serial} = \\sum_i c_i$。\n    *   将单元划分为大小为 $w=32$ 的线程束。每个线程束 $\\omega$ 的时间为 $T_{\\omega} = \\max_{i \\in \\omega} c_i$。\n    *   预测的并行时间为 $T_{parallel} = \\sum_{\\omega} T_{\\omega}$。\n    *   并行效率和加速比计算为 $\\eta = \\text{speedup} = T_{serial} / T_{parallel}$。\n\n这个详细的、基于原则的算法正确地实现了问题陈述的所有要求，包括模板搜索的自适应性质以及指定的复杂度和性能模型。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"N\": 9,\n            \"adj\": {\n                0: [1, 3], 1: [0, 2, 4], 2: [1, 5], 3: [0, 4, 6],\n                4: [1, 3, 5, 7], 5: [2, 4, 8], 6: [3, 7], 7: [4, 6, 8], 8: [5, 7]\n            },\n            \"u\": np.array([0, 1, 2, 1, 2, 3, 2, 3, 4], dtype=float),\n            \"k\": np.full(9, 2),\n            \"tau\": 0.2, \"s_min\": 3, \"eps\": 1e-12, \"w\": 32\n        },\n        {\n            \"N\": 11,\n            \"adj\": {\n                0: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1: [0], 2: [0], 3: [0],\n                4: [0], 5: [0], 6: [0], 7: [0], 8: [0], 9: [0], 10: [0]\n            },\n            \"u\": np.array([0, 10, -10, 10, -10, 10, -10, 10, -10, 10, -10], dtype=float),\n            \"k\": np.full(11, 1),\n            \"tau\": 0.05, \"s_min\": 4, \"eps\": 1e-12, \"w\": 32\n        },\n        {\n            \"N\": 12,\n            \"adj\": {\n                0: [1, 2], 1: [0, 3, 4], 2: [0, 4, 5], 3: [1, 6],\n                4: [1, 2, 7], 5: [2, 8], 6: [3, 7, 9], 7: [4, 6, 10],\n                8: [5, 10, 11], 9: [6, 10], 10: [7, 8, 9, 11], 11: [8, 10]\n            },\n            \"u\": np.array([0.0, 0.1, 0.2, 0.15, 0.25, 0.3, 2.0, 2.1, 0.35, 2.05, 2.2, 0.4], dtype=float),\n            \"k\": np.array([2, 2, 2, 1, 1, 2, 1, 2, 2, 1, 1, 2]),\n            \"tau\": 0.2, \"s_min\": 3, \"eps\": 1e-12, \"w\": 32\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, adj, u, k, tau, s_min, eps, w = case.values()\n        \n        stencil_sizes = []\n        total_edge_examinations = 0\n        total_indicator_evaluations = 0\n        element_costs = []\n\n        for i in range(N):\n            size, edge_exams, ind_evals = build_adaptive_stencil(i, N, adj, u, k, tau, s_min, eps)\n            stencil_sizes.append(size)\n            total_edge_examinations += edge_exams\n            total_indicator_evaluations += ind_evals\n            element_costs.append(edge_exams + ind_evals)\n\n        serial_time = float(sum(element_costs))\n        parallel_time = 0.0\n        \n        num_warps = (N + w - 1) // w\n        for warp_idx in range(num_warps):\n            start_idx = warp_idx * w\n            end_idx = min((warp_idx + 1) * w, N)\n            warp_costs = element_costs[start_idx:end_idx]\n            if warp_costs:\n                parallel_time += max(warp_costs)\n\n        if parallel_time > 0:\n            efficiency = serial_time / parallel_time\n            speedup = efficiency\n        else:\n            efficiency = 0.0 \n            speedup = 0.0\n\n        all_results.append(\n            f\"[[{','.join(map(str, stencil_sizes))}],{total_edge_examinations},{total_indicator_evaluations},{efficiency:.6f},{speedup:.6f}]\"\n        )\n        \n    print(f\"[{','.join(all_results)}]\")\n\ndef smoothness_indicator(ui, uj, eps):\n    \"\"\"Computes the smoothness indicator S(i,j).\"\"\"\n    numerator = abs(uj - ui)\n    denominator = abs(uj) + abs(ui) + eps\n    return numerator / denominator\n\ndef build_adaptive_stencil(i, N, adj, u, k, tau, s_min, eps):\n    \"\"\"\n    Implements the adaptive stencil selection for a single element i.\n    Uses a layered BFS approach.\n    \"\"\"\n    S_i = set()\n    rejected_candidates = []\n    \n    edge_examinations = 0\n    indicator_evaluations = 0\n    \n    visited_bfs = {i}\n    current_layer_nodes = [i]\n    dist = 0\n    max_k = k[i]\n\n    while dist  max_k:\n        if len(S_i) >= s_min:\n            break\n        \n        dist += 1\n        next_layer_nodes = []\n        candidates_at_this_dist = set()\n        \n        for node_u in current_layer_nodes:\n            for node_v in adj.get(node_u, []):\n                edge_examinations += 1\n                if node_v not in visited_bfs:\n                    visited_bfs.add(node_v)\n                    next_layer_nodes.append(node_v)\n                    candidates_at_this_dist.add(node_v)\n        \n        # Process newly discovered candidates for this layer\n        # Sort for deterministic behavior\n        for cand_node in sorted(list(candidates_at_this_dist)):\n            indicator_evaluations += 1\n            s_val = smoothness_indicator(u[i], u[cand_node], eps)\n            if s_val = tau:\n                S_i.add(cand_node)\n            else:\n                rejected_candidates.append((dist, s_val, cand_node))\n        \n        if not next_layer_nodes:\n            break\n        current_layer_nodes = next_layer_nodes\n\n    # Fallback mechanism\n    if len(S_i)  s_min:\n        rejected_candidates.sort() # Sorts by distance, then s_val, then node_id\n        needed = s_min - len(S_i)\n        \n        added_count = 0\n        for _, _, node in rejected_candidates:\n            if added_count >= needed:\n                break\n            if node not in S_i:\n              S_i.add(node)\n              added_count += 1\n    \n    return len(S_i), edge_examinations, indicator_evaluations\n\nsolve()\n```", "id": "3429522"}]}