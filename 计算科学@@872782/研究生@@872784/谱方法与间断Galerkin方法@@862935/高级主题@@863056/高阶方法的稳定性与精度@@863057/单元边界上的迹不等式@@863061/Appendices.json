{"hands_on_practices": [{"introduction": "掌握迹不等式等理论工具的第一步，是在具体场景中应用它。本练习将引导你对一个简单的线性多项式和四面体单元应用标准的迹不等式。通过这个过程，你将熟悉不等式中各个组成部分，并理解它们如何依赖于单元尺寸 $h_{K}$ 进行缩放。", "problem": "设 $K \\subset \\mathbb{R}^{3}$ 为缩放的单位单纯形（四面体）\n$$\nK = \\left\\{ x \\in \\mathbb{R}^{3} : x_{i} \\ge 0 \\text{ for } i=1,2,3,\\; x_{1}+x_{2}+x_{3} \\le h_{K} \\right\\},\n$$\n其单元尺寸参数为 $h_{K} > 0$，并设 $F$ 为其任意一个面（为确定起见，取 $F = \\{ x \\in K : x_{1} = 0 \\}$）。考虑多项式场 $v(x) = 1 + \\sum_{i=1}^{3} x_{i}$。使用形状正则四面体的标准逐面迹不等式，该不等式涉及一个仅依赖于 $K$ 的形状正则性而与 $h_{K}$ 无关的常数 $C_{\\mathrm{tr}}>0$，推导边界积分 $\\int_{F} v(x)^{2}\\,ds$ 的一个以 $h_{K}$、$C_{\\mathrm{tr}}$ 和 $K$ 上的体积积分表示的显式上界。您的最终界必须是关于 $h_{K}$ 和 $C_{\\mathrm{tr}}$ 的单个闭式解析表达式。此外，在您的推导过程中，请指出该界如何随 $h_{K}$ 缩放。除基本定义和经过充分检验的结果外，不要假设或引用任何快捷公式；从 $K$ 的几何形状直接推导任何所需的积分。最终报告的界必须是单个解析表达式；最终答案中不允许出现不等式。", "solution": "我们从形状正则单元（三维中的四面体）上经过充分检验的逐面迹不等式开始。对于任意 $v \\in H^{1}(K)$ 和任意面 $F \\subset \\partial K$，存在一个仅依赖于 $K$ 的形状正则性（而不依赖于 $h_{K}$ 或 $v$）的常数 $C_{\\mathrm{tr}}>0$，使得\n$$\n\\int_{F} v^{2}\\,ds \\le C_{\\mathrm{tr}} \\left( h_{K}^{-1} \\int_{K} v^{2}\\,dx + h_{K} \\int_{K} |\\nabla v|^{2}\\,dx \\right).\n$$\n我们的任务是针对给定的多项式 $v(x) = 1 + x_{1} + x_{2} + x_{3}$ 和四面体 $K$（由下式给出），计算右侧的体积积分\n$$\nK = \\left\\{ x \\in \\mathbb{R}^{3} : x_{i} \\ge 0,\\; x_{1}+x_{2}+x_{3} \\le h_{K} \\right\\}.\n$$\n\n为计算所需的积分，我们使用从参考单位单纯形 $\\widehat{K} = \\{ \\widehat{x} \\in \\mathbb{R}^{3} : \\widehat{x}_{i} \\ge 0,\\; \\widehat{x}_{1}+\\widehat{x}_{2}+\\widehat{x}_{3} \\le 1 \\}$ 通过 $x = h_{K} \\widehat{x}$ 进行的缩放。此仿射映射的雅可比行列式为 $h_{K}^{3}$，因此 $dx = h_{K}^{3}\\,d\\widehat{x}$。$\\widehat{K}$ 的体积是\n$$\n\\operatorname{vol}(\\widehat{K}) = \\frac{1}{6}.\n$$\n在此缩放变换下，$v(x)$ 变为\n$$\nv(x) = 1 + x_{1} + x_{2} + x_{3} = 1 + h_{K} \\left( \\widehat{x}_{1} + \\widehat{x}_{2} + \\widehat{x}_{3} \\right).\n$$\n\n我们首先计算 $\\int_{K} v^{2}\\,dx$：\n\\begin{align*}\n\\int_{K} v^{2}\\,dx\n&= \\int_{\\widehat{K}} \\left( 1 + h_{K} \\sum_{i=1}^{3} \\widehat{x}_{i} \\right)^{2} h_{K}^{3}\\,d\\widehat{x} \\\\\n&= h_{K}^{3} \\int_{\\widehat{K}} \\left( 1 + 2 h_{K} \\sum_{i=1}^{3} \\widehat{x}_{i} + h_{K}^{2} \\left( \\sum_{i=1}^{3} \\widehat{x}_{i} \\right)^{2} \\right) d\\widehat{x}.\n\\end{align*}\n我们现在使用三维单位单纯形 $\\widehat{K}$ 上的标准矩公式：\n- $\\displaystyle \\int_{\\widehat{K}} 1\\,d\\widehat{x} = \\frac{1}{6}$。\n- $\\displaystyle \\int_{\\widehat{K}} \\widehat{x}_{i}\\,d\\widehat{x} = \\frac{1}{24}$，因此 $\\displaystyle \\int_{\\widehat{K}} \\sum_{i=1}^{3} \\widehat{x}_{i}\\,d\\widehat{x} = \\frac{3}{24} = \\frac{1}{8}$。\n- $\\displaystyle \\int_{\\widehat{K}} \\widehat{x}_{i}^{2}\\,d\\widehat{x} = \\frac{1}{60}$ 且 $\\displaystyle \\int_{\\widehat{K}} \\widehat{x}_{i}\\widehat{x}_{j}\\,d\\widehat{x} = \\frac{1}{120}$ 对于 $i \\ne j$。因此\n\\begin{align*}\n\\int_{\\widehat{K}} \\left( \\sum_{i=1}^{3} \\widehat{x}_{i} \\right)^{2} d\\widehat{x}\n&= \\sum_{i=1}^{3} \\int_{\\widehat{K}} \\widehat{x}_{i}^{2}\\,d\\widehat{x} + 2 \\sum_{1 \\le i  j \\le 3} \\int_{\\widehat{K}} \\widehat{x}_{i}\\widehat{x}_{j}\\,d\\widehat{x} \\\\\n= 3 \\cdot \\frac{1}{60} + 2 \\cdot 3 \\cdot \\frac{1}{120} = \\frac{1}{20} + \\frac{1}{20} = \\frac{1}{10}.\n\\end{align*}\n因此，\n\\begin{align*}\n\\int_{K} v^{2}\\,dx\n= h_{K}^{3} \\left( \\frac{1}{6} + 2 h_{K} \\cdot \\frac{1}{8} + h_{K}^{2} \\cdot \\frac{1}{10} \\right) \\\\\n= h_{K}^{3} \\left( \\frac{1}{6} + \\frac{h_{K}}{4} + \\frac{h_{K}^{2}}{10} \\right).\n\\end{align*}\n\n接下来，我们计算 $\\int_{K} |\\nabla v|^{2}\\,dx$。由于 $v(x) = 1 + x_{1} + x_{2} + x_{3}$，\n$$\n\\nabla v(x) = (1, 1, 1), \\quad |\\nabla v|^{2} = 1^{2} + 1^{2} + 1^{2} = 3,\n$$\n它在 $K$ 上是常数。于是，\n\\begin{align*}\n\\int_{K} |\\nabla v|^{2}\\,dx = 3 \\int_{K} 1\\,dx = 3\\,\\operatorname{vol}(K) = 3 \\cdot h_{K}^{3} \\cdot \\operatorname{vol}(\\widehat{K}) = 3 \\cdot h_{K}^{3} \\cdot \\frac{1}{6} = \\frac{h_{K}^{3}}{2}.\n\\end{align*}\n\n将这些表达式代入迹不等式，得到\n\\begin{align*}\n\\int_{F} v^{2}\\,ds\n\\le C_{\\mathrm{tr}} \\left( h_{K}^{-1} \\int_{K} v^{2}\\,dx + h_{K} \\int_{K} |\\nabla v|^{2}\\,dx \\right) \\\\\n= C_{\\mathrm{tr}} \\left( h_{K}^{-1} \\cdot h_{K}^{3} \\left( \\frac{1}{6} + \\frac{h_{K}}{4} + \\frac{h_{K}^{2}}{10} \\right) + h_{K} \\cdot \\frac{h_{K}^{3}}{2} \\right) \\\\\n= C_{\\mathrm{tr}} \\left( h_{K}^{2} \\left( \\frac{1}{6} + \\frac{h_{K}}{4} + \\frac{h_{K}^{2}}{10} \\right) + \\frac{h_{K}^{4}}{2} \\right) \\\\\n= C_{\\mathrm{tr}} \\left( \\frac{h_{K}^{2}}{6} + \\frac{h_{K}^{3}}{4} + \\left( \\frac{1}{10} + \\frac{1}{2} \\right) h_{K}^{4} \\right) \\\\\n= C_{\\mathrm{tr}} \\left( \\frac{h_{K}^{2}}{6} + \\frac{h_{K}^{3}}{4} + \\frac{3}{5} h_{K}^{4} \\right).\n\\end{align*}\n\n该界展现了预期的随 $h_{K}$ 的缩放行为：主阶项与 $h_{K}^{2}$ 成正比，这与面的面积缩放相匹配。对于小的 $h_{K}$，主要贡献是 $\\displaystyle C_{\\mathrm{tr}} \\frac{h_{K}^{2}}{6}$，并带有 $h_{K}^{3}$ 和 $h_{K}^{4}$ 阶的高阶修正。\n\n因此，最终要求的单个解析表达式为\n$$\nC_{\\mathrm{tr}} \\left( \\frac{h_{K}^{2}}{6} + \\frac{h_{K}^{3}}{4} + \\frac{3}{5} h_{K}^{4} \\right).\n$$", "answer": "$$\\boxed{C_{\\mathrm{tr}}\\left(\\frac{h_{K}^{2}}{6}+\\frac{h_{K}^{3}}{4}+\\frac{3}{5}h_{K}^{4}\\right)}$$", "id": "3424658"}, {"introduction": "在应用不等式之后，一个自然的问题是：迹常数 $C_{\\mathrm{tr}}$ 从何而来，其最佳值是多少？这个练习将从第一性原理出发，通过求解一个一维模型来回答这个问题。它揭示了该不等式与一个特定微分方程的解之间的深刻联系，这是变分法中的一个经典结论。", "problem": "在谱方法和间断 Galerkin (DG) 方法的数值通量和罚参数分析中，单元边界上的精确迹不等式至关重要。考虑一维参考单元 $\\Omega = (0,1)$ 和 Sobolev 空间 $H^{1}(0,1)$，该空间配备有 Hilbert 范数\n$$\n\\|u\\|_{H^{1}(0,1)}^{2} = \\int_{0}^{1} \\left( |u(x)|^{2} + |u'(x)|^{2} \\right) \\, dx.\n$$\n边界 $\\partial \\Omega$ 由两个点 $\\{0,1\\}$ 组成。对于单点面 $\\{1\\}$，将迹的边界 $L^{2}$ 范数定义为\n$$\n\\|u\\|_{L^{2}(\\{x=1\\})} = |u(1)|,\n$$\n这对应于点集上的计数测度，并且在一维迹不等式中是标准做法。\n\n确定精确的最小常数 $C  0$，使得迹不等式\n$$\n\\|u\\|_{L^{2}(\\{x=1\\})} \\leq C \\, \\|u\\|_{H^{1}(0,1)}\n$$\n对所有 $u \\in H^{1}(0,1)$ 均成立。您的答案必须是单一的闭式解析表达式。无需四舍五入，也不涉及物理单位。此外，请确定使等式成立的极值函数，并用它来推导该常数，而不依赖任何预先制表的公式。", "solution": "问题在于找到最小的常数 $C  0$，使得对于所有函数 $u \\in H^{1}(0,1)$，以下迹不等式成立：\n$$\n|u(1)| \\leq C \\|u\\|_{H^{1}(0,1)}\n$$\n其中 $H^{1}(0,1)$ 上的范数由下式给出\n$$\n\\|u\\|_{H^{1}(0,1)}^{2} = \\int_{0}^{1} \\left( |u(x)|^{2} + |u'(x)|^{2} \\right) \\, dx.\n$$\n将不等式两边平方并重新整理，我们可以将最优常数 $C$ 的平方定义为瑞利商的上确界：\n$$\nC^2 = \\sup_{u \\in H^{1}(0,1) \\setminus \\{0\\}} \\frac{|u(1)|^2}{\\|u\\|_{H^{1}(0,1)}^2} = \\sup_{u \\in H^{1}(0,1) \\setminus \\{0\\}} \\frac{|u(1)|^2}{\\int_{0}^{1} \\left( |u(x)|^2 + |u'(x)|^2 \\right) \\, dx}\n$$\n不失一般性，我们可以考虑实值函数，因此 $|u(x)|$ 变为 $u(x)$。寻找此上确界的问题是变分法中的一个经典问题。使该商最大化的函数 $u(x)$，即所谓的极值函数，必须满足相关的欧拉-拉格朗日方程。\n\n令 $J(u)$ 为待最大化的泛函：\n$$\nJ(u) = \\frac{u(1)^2}{\\int_{0}^{1} \\left( u(x)^2 + u'(x)^2 \\right) \\, dx}\n$$\n对于极值函数 $u$，$J(u)$ 的一阶变分必须为零。对于任何容许变分 $v \\in H^1(0,1)$，我们必须有 $\\delta J(u;v) = 0$。\n其Gâteaux导数为：\n$$\n\\delta J(u;v) = \\left. \\frac{d}{d\\epsilon} J(u+\\epsilon v) \\right|_{\\epsilon=0} = \\frac{2u(1)v(1) \\left( \\int_{0}^{1} (u^2 + u'^2)dx \\right) - u(1)^2 \\left( 2\\int_{0}^{1} (uv+u'v')dx \\right)}{\\left(\\int_{0}^{1} (u^2 + u'^2)dx\\right)^2} = 0\n$$\n假设对于非平凡解有 $u(1) \\neq 0$，则上式简化为：\n$$\nu(1)v(1) \\int_{0}^{1} (u^2 + u'^2)dx - u(1)^2 \\int_{0}^{1} (uv+u'v')dx = 0\n$$\n$$\nv(1) \\frac{\\int_{0}^{1} (u^2 + u'^2)dx}{u(1)} - \\int_{0}^{1} (uv+u'v')dx = 0\n$$\n对于极值函数 $u$，该商的值为 $C^2$。因此，$C^2 = \\frac{u(1)^2}{\\int_{0}^{1} (u^2+u'^2)dx}$。这意味着 $\\frac{\\int_{0}^{1} (u^2+u'^2)dx}{u(1)} = \\frac{u(1)}{C^2}$。将此代入变分方程，得到问题的弱形式：\n$$\n\\int_{0}^{1} \\left( u(x)v(x) + u'(x)v'(x) \\right) \\, dx = \\frac{u(1)}{C^2} v(1) \\quad \\forall v \\in H^1(0,1)\n$$\n为了得到强形式（一个带边界条件的微分方程），我们对 $\\int_{0}^{1} u'(x)v'(x)dx$ 项应用分部积分：\n$$\n\\int_{0}^{1} u'(x)v'(x)dx = [u'(x)v(x)]_{0}^{1} - \\int_{0}^{1} u''(x)v(x)dx = u'(1)v(1) - u'(0)v(0) - \\int_{0}^{1} u''(x)v(x)dx\n$$\n将此代回弱形式，得到：\n$$\n\\int_{0}^{1} u(x)v(x)dx + u'(1)v(1) - u'(0)v(0) - \\int_{0}^{1} u''(x)v(x)dx = \\frac{u(1)}{C^2} v(1)\n$$\n合并项：\n$$\n\\int_{0}^{1} \\left( u(x) - u''(x) \\right) v(x) dx + \\left( u'(1) - \\frac{u(1)}{C^2} \\right) v(1) - u'(0)v(0) = 0\n$$\n此式必须对所有 $v \\in H^1(0,1)$ 成立。\n1.  通过选择在边界处为零的测试函数 $v$（即 $v \\in H_0^1(0,1)$，满足 $v(0)=v(1)=0$），边界项为零。根据变分法基本引理，被积函数必须为零，这给出了欧拉-拉格朗日微分方程：\n    $$\n    u''(x) - u(x) = 0 \\quad \\text{for } x \\in (0,1)\n    $$\n2.  在微分方程成立的情况下，对于任何 $v$，积分项都为零。方程简化为自然边界条件：\n    $$\n    \\left( u'(1) - \\frac{u(1)}{C^2} \\right) v(1) - u'(0)v(0) = 0\n    $$\n    通过选择 $v$ 使得 $v(0)=1$ 且 $v(1)=0$，我们得到在 $x=0$ 处的条件：\n    $$\n    u'(0) = 0\n    $$\n    通过选择 $v$ 使得 $v(0)=0$ 且 $v(1)=1$，我们得到在 $x=1$ 处的条件：\n    $$\n    u'(1) = \\frac{u(1)}{C^2}\n    $$\n现在问题简化为求解这个边值问题。$u'' - u = 0$ 的通解是 $u(x) = A e^x + B e^{-x}$。其导数为 $u'(x) = A e^x - B e^{-x}$。\n应用在 $x=0$ 处的条件：\n$u'(0) = A - B = 0$，这意味着 $A=B$。\n因此，极值函数的形式必为 $u(x) = A(e^x + e^{-x}) = K \\cosh(x)$，其中 $K=2A$ 是某个常数。对于非平凡解，$K \\neq 0$。\n\n现在，我们使用在 $x=1$ 处的边界条件来确定常数 $C^2$。\n对于 $u(x) = K \\cosh(x)$，我们有 $u(1) = K \\cosh(1)$ 和 $u'(1) = K \\sinh(1)$。\n将这些代入 $u'(1) = \\frac{u(1)}{C^2}$：\n$$\nK \\sinh(1) = \\frac{K \\cosh(1)}{C^2}\n$$\n由于 $K \\neq 0$，我们可以将其约去：\n$$\n\\sinh(1) = \\frac{\\cosh(1)}{C^2}\n$$\n解出 $C^2$，我们得到：\n$$\nC^2 = \\frac{\\cosh(1)}{\\sinh(1)} = \\coth(1)\n$$\n精确的最小常数 $C$ 是该值的正平方根：\n$$\nC = \\sqrt{\\coth(1)}\n$$\n达到这个界的极值函数是 $u(x) = \\cosh(x)$ 的任何非零倍数。我们可以用指数函数将 $\\coth(1)$ 表示为 $\\coth(1) = \\frac{e^1 + e^{-1}}{e^1 - e^{-1}} = \\frac{e^2+1}{e^2-1}$。", "answer": "$$\n\\boxed{\\sqrt{\\coth(1)}}\n$$", "id": "3424723"}, {"introduction": "本练习旨在连接连续理论与离散的实际计算。你将学习如何通过将问题表述为一个广义特征值问题，来为有限维多项式空间计算离散迹常数。这是不连续伽辽金方法（DG）设计与分析中的一项核心实用技术，用于确定罚参数以确保数值稳定性。", "problem": "设 $K$ 表示谱方法和间断Galerkin (DG) 方法中使用的二维单元。单元层面上的连续迹不等式指出，存在一个常数 $C_{\\mathrm{tr}}$，使得对于充分光滑的 $u$，\n$$\n\\lVert u \\rVert_{\\partial K} \\leq C_{\\mathrm{tr}} \\, \\lVert u \\rVert_{K},\n$$\n其中 $\\lVert \\cdot \\rVert_{\\partial K}$ 是边界 $\\partial K$ 上的 $L^2$ 范数，而 $\\lVert \\cdot \\rVert_{K}$ 是内部 $K$ 上的 $L^2$ 范数。在实际的高阶方法中，有限维多项式空间上边界范数与内部范数之比的极值决定了离散迹常数，这些常数控制着数值通量和罚项的稳定性。您的任务是设计并实现一个数值实验，以确定在给定单元尺寸和多项式次数下，以下最大比值：\n$$\n\\sup_{u \\in \\mathcal{V}_p \\setminus \\{0\\}} \\frac{\\lVert u \\rVert_{\\partial K}}{\\lVert u \\rVert_{K}},\n$$\n其中 $\\mathcal{V}_p$ 是 $K$ 上次数至多为 $p$ 的张量积多项式空间。\n\n请在以下具有科学依据且完全指定的设置下进行工作：\n\n- 几何与映射。使用参考正方形 $K_{\\mathrm{ref}} = [-1,1]^2$ 以及由 $x = \\frac{h}{2}\\,\\xi$ 和 $y = \\frac{h}{2}\\,\\eta$ 定义的仿射映射 $F_h : K_{\\mathrm{ref}} \\to K_h$，其中 $(\\xi,\\eta) \\in [-1,1]^2$ 且 $h  0$ 是物理正方形 $K_h$ 的边长。雅可比行列式满足 $\\lvert J \\rvert = \\left(\\frac{h}{2}\\right)^2$，边界线元的缩放因子为 $\\left(\\frac{h}{2}\\right)$。\n\n- 多项式空间。取 $\\mathcal{V}_p = Q_p(K_{\\mathrm{ref}})$，即由 Legendre 多项式 $\\{P_i(\\xi)\\}_{i=0}^{p}$ 和 $\\{P_j(\\eta)\\}_{j=0}^{p}$ 张成的张量积空间，其基函数为 $\\phi_{ij}(\\xi,\\eta) = P_i(\\xi) P_j(\\eta)$，其中 $0 \\le i,j \\le p$。Legendre 多项式由 $P_0(x)=1$、$P_1(x)=x$ 以及对于 $n \\ge 1$ 的递推关系 $(n+1)P_{n+1}(x) = (2n+1)x P_n(x) - n P_{n-1}(x)$ 定义。\n\n- 范数。对于一个函数 $u \\in \\mathcal{V}_p$，通过 $F_h^{-1}$ 从 $K_h$ 拉回到 $K_{\\mathrm{ref}}$（即在 $K_{\\mathrm{ref}}$ 上视为 $u(\\xi,\\eta)$），定义\n$$\n\\lVert u \\rVert_{K_h}^2 = \\int_{K_h} u^2 \\, \\mathrm{d}A = \\int_{K_{\\mathrm{ref}}} u^2 \\, \\left(\\frac{h}{2}\\right)^2 \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta,\n$$\n$$\n\\lVert u \\rVert_{\\partial K_h}^2 = \\int_{\\partial K_h} u^2 \\, \\mathrm{d}s = \\int_{\\partial K_{\\mathrm{ref}}} u^2 \\, \\left(\\frac{h}{2}\\right) \\, \\mathrm{d}\\sigma.\n$$\n\n- 优化目标。考虑瑞利商\n$$\nR(u) = \\frac{\\lVert u \\rVert_{\\partial K_h}^2}{\\lVert u \\rVert_{K_h}^2},\n$$\n在 $u \\in \\mathcal{V}_p \\setminus \\{0\\}$ 上。其最大值的平方根即为所求的最大比值 $\\sup \\lVert u \\rVert_{\\partial K_h} / \\lVert u \\rVert_{K_h}$。\n\n- 积分的离散化。在每个方向上使用点数为 $n_q = p + 3$ 的张量积 Gauss-Legendre 求积来组装：\n  1. 内部对称正定质量矩阵 $M \\in \\mathbb{R}^{N \\times N}$（其中 $N=(p+1)^2$），通过在 $K_{\\mathrm{ref}}$ 上进行求积并包含因子 $\\left(\\frac{h}{2}\\right)^2$ 来近似 $\\lVert u \\rVert_{K_h}^2$。\n  2. 边界对称质量矩阵 $B \\in \\mathbb{R}^{N \\times N}$，通过沿 $K_{\\mathrm{ref}}$ 的四条边分别进行一维 Gauss-Legendre 求积并包含因子 $\\left(\\frac{h}{2}\\right)$ 来近似 $\\lVert u \\rVert_{\\partial K_h}^2$。\n\n- 最大比值的计算。构建广义对称特征值问题 $B \\mathbf{v} = \\lambda M \\mathbf{v}$。最大特征值 $\\lambda_{\\max}$（非负）满足 $\\sup_{u \\in \\mathcal{V}_p \\setminus \\{0\\}} R(u) = \\lambda_{\\max}$，所求的最大比值为 $\\sqrt{\\lambda_{\\max}}$。\n\n推导的基本假设必须从 $L^2$ 范数的定义、Legendre 多项式的性质、Gauss-Legendre 求积对多项式的精确性以及对称定对的广义特征值的瑞利商刻画出发。\n\n您必须实现一个完整的程序，该程序：\n- 如上所述构建 $M$ 和 $B$，\n- 求解广义特征值问题以找到 $\\lambda_{\\max}$，\n- 对每个请求的测试用例输出最大比值 $\\sqrt{\\lambda_{\\max}}$。\n\n单位：由于比值 $\\lVert u \\rVert_{\\partial K_h} / \\lVert u \\rVert_{K_h}$ 的量纲是长度平方根的倒数（$1/\\sqrt{\\text{length}}$），因此将每个输出表示为一个纯浮点数，其隐式度量单位为 $1/\\sqrt{\\text{length}}$（假设 $h$ 以一致的长度单位表示）。不应打印任何单位字符串。\n\n测试套件和最终输出规范：\n- 使用以下有序的对偶 $(p,h)$ 测试套件：\n  1. $(0,\\,1.0)$,\n  2. $(1,\\,1.0)$,\n  3. $(3,\\,0.5)$,\n  4. $(6,\\,2.0)$,\n  5. $(10,\\,1.0)$.\n- 您的程序应生成单行输出，其中包含这些测试用例的最大比值，形式为一个逗号分隔的十进制数列表，并用方括号括起来，每个数值四舍五入到小数点后十位。例如，输出行应类似于\n$[r_1,r_2,r_3,r_4,r_5]$,\n其中每个 $r_i$ 是一个格式化为小数点后恰好十位的浮点数。\n\n您的实现不得读取任何输入，且必须仅使用指定的运行时环境。", "solution": "我们从基础数学定义开始。对于函数 $u \\in L^2(K)$，其在内部 $K$ 上的 $L^2$ 范数定义为\n$$\n\\lVert u \\rVert_{K}^2 = \\int_{K} u^2 \\, \\mathrm{d}A.\n$$\n类似地，其在边界 $\\partial K$ 上的 $L^2$ 范数定义为\n$$\n\\lVert u \\rVert_{\\partial K}^2 = \\int_{\\partial K} u^2 \\, \\mathrm{d}s.\n$$\n在从参考正方形 $K_{\\mathrm{ref}} = [-1,1]^2$ 到物理正方形 $K_h$ 的仿射映射 $F_h : (\\xi,\\eta) \\mapsto \\left(\\frac{h}{2}\\xi, \\frac{h}{2}\\eta \\right)$ 下，面积元变换为 $\\mathrm{d}A = \\left(\\frac{h}{2}\\right)^2 \\mathrm{d}\\xi \\mathrm{d}\\eta$，边界线元变换为 $\\mathrm{d}s = \\left(\\frac{h}{2}\\right) \\mathrm{d}\\sigma$，其中 $\\mathrm{d}\\sigma$ 是 $\\partial K_{\\mathrm{ref}}$ 上的线测度。因此，对于一个从 $K_h$ 拉回到 $K_{\\mathrm{ref}}$ 的函数 $u$，我们得到\n$$\n\\lVert u \\rVert_{K_h}^2 = \\int_{K_{\\mathrm{ref}}} u^2 \\, \\left(\\frac{h}{2}\\right)^2 \\mathrm{d}\\xi \\mathrm{d}\\eta,\n\\quad\n\\lVert u \\rVert_{\\partial K_h}^2 = \\int_{\\partial K_{\\mathrm{ref}}} u^2 \\, \\left(\\frac{h}{2}\\right) \\mathrm{d}\\sigma.\n$$\n空间 $\\mathcal{V}_p = Q_p(K_{\\mathrm{ref}})$ 是由张量积基函数\n$$\n\\phi_{ij}(\\xi,\\eta) = P_i(\\xi) P_j(\\eta), \\quad 0 \\le i,j \\le p,\n$$\n张成的空间，其中 $\\{P_n\\}_{n=0}^{p}$ 是在 $[-1,1]$ 上的 Legendre 多项式，由 $P_0(x) = 1$、$P_1(x) = x$ 和递推关系\n$$\n(n+1)P_{n+1}(x) = (2n+1) x \\, P_n(x) - n \\, P_{n-1}(x), \\quad n \\ge 1\n$$\n定义。Legendre 多项式关于 $[-1,1]$ 上的标准 $L^2$ 内积是正交的，并且 $n_q$ 点的 Gauss-Legendre 求积能够精确地积分次数最高为 $2n_q - 1$ 的多项式。\n\n为了确定最大比值\n$$\n\\sup_{u \\in \\mathcal{V}_p \\setminus \\{0\\}} \\frac{\\lVert u \\rVert_{\\partial K_h}}{\\lVert u \\rVert_{K_h}},\n$$\n我们考虑以瑞利商形式表示的比值的平方：\n$$\nR(u) = \\frac{\\lVert u \\rVert_{\\partial K_h}^2}{\\lVert u \\rVert_{K_h}^2}.\n$$\n如果我们将 $u$ 在基 $\\{\\phi_{ij}\\}$ 中展开，\n$$\nu(\\xi,\\eta) = \\sum_{i=0}^p \\sum_{j=0}^p c_{ij} \\, \\phi_{ij}(\\xi,\\eta),\n$$\n并将系数收集到一个向量 $\\mathbf{c} \\in \\mathbb{R}^{N}$ 中（其中 $N = (p+1)^2$），那么内部范数的平方和边界范数的平方可以通过求积近似为二次型\n$$\n\\lVert u \\rVert_{K_h}^2 \\approx \\mathbf{c}^\\top M \\, \\mathbf{c}, \\qquad \\lVert u \\rVert_{\\partial K_h}^2 \\approx \\mathbf{c}^\\top B \\, \\mathbf{c},\n$$\n其中 $M$ 是通过在 $K_{\\mathrm{ref}}$ 上进行二维 Gauss-Legendre 求积并包含因子 $\\left(\\frac{h}{2}\\right)^2$ 而组装的对称正定质量矩阵，而 $B$ 是通过沿 $K_{\\mathrm{ref}}$ 的四条边分别进行一维 Gauss-Legendre 求积并包含因子 $\\left(\\frac{h}{2}\\right)$ 而组装的对称边界质量矩阵。在每个一维求积中选择 $n_q = p+3$ 可确保精确积分矩阵项中出现的所有多项式乘积，因为被积函数在每个变量中的次数至多为 $2p$。\n\n系数向量的瑞利商变为\n$$\nR(\\mathbf{c}) = \\frac{\\mathbf{c}^\\top B \\, \\mathbf{c}}{\\mathbf{c}^\\top M \\, \\mathbf{c}}.\n$$\n根据对于 $M$ 为对称正定的对称矩阵对 $(B,M)$ 的瑞利商的基本性质，在 $\\mathbf{c} \\neq \\mathbf{0}$ 上 $R(\\mathbf{c})$ 的最大值等于满足以下方程的最大广义特征值 $\\lambda_{\\max}$\n$$\nB \\mathbf{v} = \\lambda M \\mathbf{v}.\n$$\n因此，\n$$\n\\sup_{u \\in \\mathcal{V}_p \\setminus \\{0\\}} R(u) = \\lambda_{\\max},\n\\quad \\text{以及} \\quad\n\\sup_{u \\in \\mathcal{V}_p \\setminus \\{0\\}} \\frac{\\lVert u \\rVert_{\\partial K_h}}{\\lVert u \\rVert_{K_h}} = \\sqrt{\\lambda_{\\max}}.\n$$\n\n算法设计：\n1. 选择多项式次数 $p$ 和边长 $h$。设置求积阶数 $n_q = p + 3$。\n2. 计算 $[-1,1]$ 上的一维 Gauss-Legendre 节点和权重 $\\{x_k, w_k\\}_{k=1}^{n_q}$。\n3. 在两个方向（$\\xi$ 和 $\\eta$）的节点上，对 $n=0,\\dots,p$ 计算 Legendre 多项式 $P_n(x_k)$，通过递推关系形成矩阵 $L_x \\in \\mathbb{R}^{(p+1) \\times n_q}$ 和 $L_y \\in \\mathbb{R}^{(p+1) \\times n_q}$。\n4. 组装内部质量矩阵 $M$：\n   - 通过 $L_x$ 和 $L_y$ 的外积，在二维求积网格上形成每个基函数的张量积求值。\n   - 将二维求积权重构造为一维权重的 Kronecker 积乘以 $\\left(\\frac{h}{2}\\right)^2$，并用它们来组装 $M = V_{\\mathrm{int}} \\, \\mathrm{diag}(W_{\\mathrm{int}}) \\, V_{\\mathrm{int}}^\\top$，其中 $V_{\\mathrm{int}}$ 是网格上的基函数求值矩阵。\n5. 组装边界质量矩阵 $B$：\n   - 对于 $K_{\\mathrm{ref}}$ 的四条边中的每一条，沿该边计算基函数的值。对于 $\\xi = \\pm 1$ 的边，固定坐标使用 $P_i(\\pm 1)$，变量方向使用 $L_y$；对于 $\\eta = \\pm 1$ 的边，变量方向使用 $L_x$，固定坐标使用 $P_j(\\pm 1)$。\n   - 将一维求积权重乘以 $\\left(\\frac{h}{2}\\right)$ 并组装贡献 $B_{\\mathrm{edge}} = V_{\\mathrm{edge}} \\, \\mathrm{diag}(W_{\\mathrm{edge}}) \\, V_{\\mathrm{edge}}^\\top$；将所有四条边的贡献相加得到 $B$。\n6. 使用对称求解器求解广义特征值问题 $B \\mathbf{v} = \\lambda M \\mathbf{v}$ 以获得特征值，并取最大值 $\\lambda_{\\max}$。\n7. 报告最大比值 $\\sqrt{\\lambda_{\\max}}$。\n\n合理性检查：\n- 对于 $p=0$（仅常数基），可以精确计算出 $\\lVert u \\rVert_{\\partial K_h} / \\lVert u \\rVert_{K_h} = \\sqrt{\\frac{\\text{perimeter}(K_h)}{\\text{area}(K_h)}} = \\sqrt{\\frac{4h}{h^2}} = \\frac{2}{\\sqrt{h}}$，数值方法能够重现此结果，因为求积对于常数是精确的。\n\n数值细节：\n- 在一维中使用 $n_q = p+3$ 以确保对次数高达 $2p+5$ 的多项式精确，这覆盖了所有遇到的多项式乘积。\n- 使用稳定的 Legendre 递推在求积节点上计算 $P_n$ 的值，包括通过递推（或直接通过已知的端点性质）得到的值 $P_n(\\pm 1) = (\\pm 1)^n$。\n- 对 $(B,M)$ 使用对称广义特征值求解器，以避免显式构造 $M^{-1}$；由于 $B$ 和 $M$ 的正性，最大特征值为非负。\n\n最后，将此过程应用于测试套件 $(p,h) \\in \\{(0,1.0), (1,1.0), (3,0.5), (6,2.0), (10,1.0)\\}$，并在一行中打印最大比值，形式为用方括号括起来的逗号分隔列表，每个值格式化为小数点后十位。", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss\nfrom scipy.linalg import eigh\n\ndef legendre_matrix(x, p):\n    \"\"\"\n    Compute Legendre polynomials P_n(x) for n=0..p at points x using recurrence.\n    Returns an array L of shape (p+1, len(x)), where L[n, :] = P_n(x).\n    \"\"\"\n    x = np.asarray(x)\n    npts = x.size\n    L = np.zeros((p + 1, npts), dtype=np.float64)\n    L[0, :] = 1.0\n    if p = 1:\n        L[1, :] = x\n        for n in range(1, p):\n            # (n+1) P_{n+1}(x) = (2n+1) x P_n(x) - n P_{n-1}(x)\n            L[n + 1, :] = ((2 * n + 1) * x * L[n, :] - n * L[n - 1, :]) / (n + 1)\n    return L\n\ndef assemble_matrices(p, h):\n    \"\"\"\n    Assemble interior mass matrix M and boundary mass matrix B for Q_p on the square K_h.\n    Uses Gauss-Legendre quadrature with n_q = p + 3 points in each direction.\n    \"\"\"\n    n_q = p + 3  # sufficient for exactness up to degree 2p+5\n    # 1D Gauss-Legendre nodes and weights on [-1,1]\n    x_nodes, x_weights = leggauss(n_q)\n    y_nodes, y_weights = x_nodes, x_weights  # same quadrature in both directions\n\n    # Evaluate Legendre polynomials at nodes\n    Lx = legendre_matrix(x_nodes, p)  # shape (p+1, n_q)\n    Ly = legendre_matrix(y_nodes, p)  # shape (p+1, n_q)\n\n    # Basis count\n    dim = (p + 1) ** 2\n\n    # Assemble interior evaluation matrix V_int: shape (dim, n_q * n_q)\n    # Each basis phi_{i,j} evaluated at all tensor-product nodes\n    # To build efficiently, we use outer products of 1D evaluations\n    V_int = np.zeros((dim, n_q * n_q), dtype=np.float64)\n    idx = 0\n    for i in range(p + 1):\n        for j in range(p + 1):\n            # Evaluate P_i(x) * P_j(y) over grid\n            # Outer product gives (n_q, n_q), then flatten in row-major or column-major consistently\n            vals = np.outer(Lx[i, :], Ly[j, :]).ravel()  # flatten\n            V_int[idx, :] = vals\n            idx += 1\n\n    # Interior weights (tensor product), scaled by (h/2)^2\n    alpha = h / 2.0\n    W_int = alpha ** 2 * np.kron(x_weights, y_weights)  # shape (n_q * n_q,)\n\n    # Assemble interior mass matrix: M = V_int * diag(W_int) * V_int^T\n    # Using weighted inner product: M[m,n] = sum_k W_int[k] * V_int[m,k] * V_int[n,k]\n    # Implement via matrix multiplication with weighting\n    # Compute V_int * diag(sqrt(W_int))\n    sqrt_W_int = np.sqrt(W_int)\n    Vw_int = V_int * sqrt_W_int[np.newaxis, :]\n    M = Vw_int @ Vw_int.T\n\n    # Assemble boundary mass matrix B: sum over four edges\n    B = np.zeros((dim, dim), dtype=np.float64)\n\n    # One-dimensional weights for edges, scaled by alpha\n    W_edge = alpha * x_weights  # shape (n_q,)\n\n    # Precompute endpoint values P_i(±1)\n    P_at_plus1 = np.ones(p + 1, dtype=np.float64)\n    P_at_minus1 = np.array([(-1) ** n for n in range(p + 1)], dtype=np.float64)\n\n    # Edge xi = +1: (xi, eta) = (1, t), t in [-1,1]\n    V_edge_plus_x = np.zeros((dim, n_q), dtype=np.float64)\n    idx = 0\n    for i in range(p + 1):\n        for j in range(p + 1):\n            V_edge_plus_x[idx, :] = P_at_plus1[i] * Ly[j, :]\n            idx += 1\n    Vw_edge_plus_x = V_edge_plus_x * np.sqrt(W_edge)[np.newaxis, :]\n    B += Vw_edge_plus_x @ Vw_edge_plus_x.T\n\n    # Edge xi = -1: (xi, eta) = (-1, t)\n    V_edge_minus_x = np.zeros((dim, n_q), dtype=np.float64)\n    idx = 0\n    for i in range(p + 1):\n        for j in range(p + 1):\n            V_edge_minus_x[idx, :] = P_at_minus1[i] * Ly[j, :]\n            idx += 1\n    Vw_edge_minus_x = V_edge_minus_x * np.sqrt(W_edge)[np.newaxis, :]\n    B += Vw_edge_minus_x @ Vw_edge_minus_x.T\n\n    # Edge eta = +1: (xi, eta) = (t, 1)\n    V_edge_plus_y = np.zeros((dim, n_q), dtype=np.float64)\n    idx = 0\n    for i in range(p + 1):\n        for j in range(p + 1):\n            V_edge_plus_y[idx, :] = Lx[i, :] * P_at_plus1[j]\n            idx += 1\n    Vw_edge_plus_y = V_edge_plus_y * np.sqrt(W_edge)[np.newaxis, :]\n    B += Vw_edge_plus_y @ Vw_edge_plus_y.T\n\n    # Edge eta = -1: (xi, eta) = (t, -1)\n    V_edge_minus_y = np.zeros((dim, n_q), dtype=np.float64)\n    idx = 0\n    for i in range(p + 1):\n        for j in range(p + 1):\n            V_edge_minus_y[idx, :] = Lx[i, :] * P_at_minus1[j]\n            idx += 1\n    Vw_edge_minus_y = V_edge_minus_y * np.sqrt(W_edge)[np.newaxis, :]\n    B += Vw_edge_minus_y @ Vw_edge_minus_y.T\n\n    return M, B\n\ndef maximal_ratio(p, h):\n    \"\"\"\n    Compute the maximal ratio ||u||_{∂K_h} / ||u||_{K_h} over u in Q_p(K_ref) mapped to K_h.\n    \"\"\"\n    M, B = assemble_matrices(p, h)\n    # Solve the generalized eigenproblem B v = lambda M v\n    # eigh returns eigenvalues in ascending order\n    evals = eigh(B, M, eigvals_only=True)\n    lambda_max = np.max(evals)\n    # Numerical guard: ensure non-negativity\n    if lambda_max  0 and lambda_max > -1e-12:\n        lambda_max = 0.0\n    ratio = np.sqrt(lambda_max)\n    return float(ratio)\n\ndef solve():\n    test_cases = [\n        (0, 1.0),\n        (1, 1.0),\n        (3, 0.5),\n        (6, 2.0),\n        (10, 1.0),\n    ]\n    results = []\n    for p, h in test_cases:\n        r = maximal_ratio(p, h)\n        results.append(r)\n    # Print with exactly ten digits after the decimal point\n    formatted = \",\".join(f\"{val:.10f}\" for val in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3424636"}]}