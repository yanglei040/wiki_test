{"hands_on_practices": [{"introduction": "要优化科学计算程序，第一步是理解其在特定硬件上的性能瓶颈。Roofline模型是一个关键的性能分析工具，它将计算核心的算术强度（每字节内存访问的浮点运算次数）与硬件的峰值性能和内存带宽联系起来。通过这个练习，你将亲手实践如何根据实测数据计算算术强度，并判断一个高阶DG方法的核心计算是受限于计算能力还是内存带宽，这是性能优化的基础。[@problem_id:3407889]", "problem": "一个多项式阶数为 $p=8$ 的高阶间断伽辽金（DG）方法被实现于三维六面体网格上，其采用了单元内并行化和融合的体-面积分核函数。在一台加速器上进行的性能研究报告了一次代表性调用中 DG 核函数的测量数据：浮点运算总数为 $F=6.72\\times 10^{12}$，设备全局内存与流式多处理器之间传输的总数据量为 $B=1.02\\times 10^{12}$ 字节。该设备制造商标称的峰值双精度浮点吞吐量为 $P_{\\mathrm{peak}}=9.7\\times 10^{12}$ flop/秒，峰值内存带宽为 $B_{\\mathrm{peak}}=1.6\\times 10^{12}$ 字节/秒。\n\n从 Roofline 模型的基本定义出发，利用这些测量值和硬件限制，确定此 DG 核函数的：\n- 算术强度，以 flop/字节 表示；\n- 该核函数在此硬件上是计算受限还是内存受限。\n\n将算术强度四舍五入到四位有效数字。以 flop/字节 为单位表示该强度。最终答案仅提供算术强度。", "solution": "题目要求计算给定间断伽辽金（DG）核函数的算术强度，并确定该核函数是计算受限还是内存受限。此分析基于 Roofline 性能模型的原理。\n\n首先，我们定义算术强度，记为 $I$。计算核函数的算术强度是其执行的总浮点运算次数（$F$）与主存（本例中为设备全局内存）和处理器（流式多处理器）之间传输的总数据量（$B$）之比。算术强度的计算公式为：\n$$I = \\frac{F}{B}$$\n算术强度的单位通常是 flop/字节。\n\n题目为该 DG 核函数提供了以下测量值：\n-   总浮点运算次数：$F = 6.72\\times 10^{12}$ flop\n-   总数据传输量：$B = 1.02\\times 10^{12}$ 字节\n\n使用这些值，我们可以计算该核函数的算术强度：\n$$I = \\frac{6.72\\times 10^{12} \\text{ flop}}{1.02\\times 10^{12} \\text{ byte}}$$\n$10^{12}$ 因子可以消去，从而简化计算：\n$$I = \\frac{6.72}{1.02} \\frac{\\text{flop}}{\\text{byte}} \\approx 6.588235... \\frac{\\text{flop}}{\\text{byte}}$$\n按照要求，将其四舍五入到四位有效数字，得到算术强度：\n$$I \\approx 6.588 \\frac{\\text{flop}}{\\text{byte}}$$\n\n接下来，我们必须确定该核函数是计算受限还是内存受限。根据 Roofline 模型，一个核函数的可达性能 $P_{\\text{attainable}}$ 受限于硬件的峰值浮点吞吐量 $P_{\\text{peak}}$ 和数据供给处理器的速率（即算术强度 $I$ 与峰值内存带宽 $B_{\\text{peak}}$ 的乘积）。用数学公式表示为：\n$$P_{\\text{attainable}} \\le \\min(P_{\\text{peak}}, I \\times B_{\\text{peak}})$$\n\n硬件规格如下：\n-   峰值双精度浮点吞吐量：$P_{\\mathrm{peak}} = 9.7\\times 10^{12}$ flop/s\n-   峰值内存带宽：$B_{\\mathrm{peak}} = 1.6\\times 10^{12}$ byte/s\n\n如果核函数的性能受内存带宽限制，即 $I \\times B_{\\text{peak}}  P_{\\text{peak}}$，则该核函数被视为**内存受限**。\n如果核函数的性能受处理器计算能力限制，即 $I \\times B_{\\text{peak}} > P_{\\text{peak}}$，则该核函数被视为**计算受限**。\n\n这两种状态之间的转换发生在 Roofline 图的“屋脊点”。该点的算术强度被称为机器平衡点 $I_{\\text{machine}}$，其计算方法为峰值性能与峰值带宽之比：\n$$I_{\\text{machine}} = \\frac{P_{\\text{peak}}}{B_{\\text{peak}}}$$\n我们可以通过比较核函数的算术强度 $I$ 和机器平衡点 $I_{\\text{machine}}$ 来确定其性能瓶颈。\n\n让我们计算给定硬件的机器平衡点：\n$$I_{\\text{machine}} = \\frac{9.7\\times 10^{12} \\text{ flop/s}}{1.6\\times 10^{12} \\text{ byte/s}} = \\frac{9.7}{1.6} \\frac{\\text{flop}}{\\text{byte}} = 6.0625 \\frac{\\text{flop}}{\\text{byte}}$$\n\n现在，我们将核函数的算术强度 $I$ 与机器平衡点 $I_{\\text{machine}}$ 进行比较：\n-   核函数强度：$I \\approx 6.588$ flop/字节\n-   机器平衡点：$I_{\\text{machine}} = 6.0625$ flop/字节\n\n由于 $I > I_{\\text{machine}}$（$6.588 > 6.0625$），该 DG 核函数的性能受限于处理器的浮点吞吐量，而非内存带宽。因此，该核函数是**计算受限**的。这是一个多项式阶数为 $p=8$ 的高阶 DG 方法并采用了融合核函数，这一信息与此结论相符，因为这些技术正是为了提高计算与访存的比率而设计的，从而增加算术强度，使核函数趋向于计算受限状态。\n\n题目要求给出算术强度并确定核函数是计算受限还是内存受限。我们已经得出了两个结论。最终答案应为算术强度的值。", "answer": "$$\\boxed{6.588}$$", "id": "3407889"}, {"introduction": "性能分析的结果促使我们思考算法层面的设计选择，以从根本上优化资源使用。本练习聚焦于一个核心决策：是预先构建并存储一个稀疏的全局矩阵，还是采用“无矩阵”方法在需要时才计算算子作用？通过对这两种策略的内存占用进行渐近分析，你将深刻理解为何无矩阵方法在高阶DG计算中占据主导地位，这直接关系到内存效率和计算性能。[@problem_id:3407879]", "problem": "考虑一个标量线性算子，它在空间维度 $d \\in \\{2,3\\}$ 中，于由张量积六面体构成的形状规则网格上，使用不连续伽辽金 (DG) 方法进行离散化。该方法采用节点式张量积基，每个坐标方向的次数为 $p$，节点为 Legendre–Gauss–Lobatto (LGL) 节点。如此，每个单元有 $n_{e}=(p+1)^{d}$ 个未知量，每个 $(d-1)$ 维的面有 $n_{f}=(p+1)^{d-1}$ 个迹未知量。假设内部单元有 $c_{n}=2d$ 个面相邻单元。您将比较单个标量场的两种算子表示方法：(i) 以压缩稀疏行 (CSR) 格式存储的组装全局稀疏矩阵，以及 (ii) 基于和因子分解的无矩阵表示，该表示仅存储每个单元的几何因子和一维算子。\n\n使用以下基本事实和定义：\n- DG 离散化产生来自单元内部（体）项和面（表面）通量项的贡献。体项耦合同一单元内的所有未知量。面项通过提升算子将一个面上的未知量与相邻单元的体未知量耦合起来。\n- 对于组装矩阵，由体项产生的单元自耦合块是大小为 $n_{e} \\times n_{e}$ 的稠密块。对于每个面相邻单元，非对角耦合仅在对应相邻单元面迹未知量的列上具有非零元（有 $n_{f}$ 个这样的列），并且由于提升作用，这些列在接收单元的 $n_{e}$ 行中是稠密的。\n- 在 CSR 中，存储一个非零元需要恒定数量的字节来存储其值和列索引；将此组合常数记为每个非零元 $\\gamma$ 字节。为了对 $p$ 进行渐近分析，您可以将 $\\gamma$ 视为一个与 $p$ 和 $d$ 无关的常数。\n- 在具有单元局部几何因子的无矩阵和因子分解实现中，每个单元的主导存储量与 $n_{e}$ 呈线性关系（例如，在张量积求积点上存储度量项和雅可比行列式）。将此每个单元的存储量建模为 $\\kappa\\, n_{e}$ 字节，其中 $\\kappa$ 对 $p$ 和 $d$ 是常数。\n- 考虑跨进程的区域分解。设 $S$ 为给定进程与其相邻进程之间的共享面数量。对于单次算子应用：\n  - 在组装稀疏矩阵向量乘法 (SpMV) 中，唯一需要的远程向量项是出现在非对角块的非零列中的项，即相邻单元的面迹项。将通信量建模为与 $S\\, n_{f}$ 个标量成正比。\n  - 在无矩阵的面通量评估中，所需的远程数据同样是每个共享面上相邻单元的面迹项，也与 $S\\, n_{f}$ 个标量成正比。\n\n任务：\n1. 推导组装矩阵的每个单元的主阶内存占用 $M_{\\mathrm{asm}}(p,d)$，用 $p$ 和 $d$ 表示，忽略常数和 $p$ 的低阶项。\n2. 推导无矩阵算子存储的每个单元的主阶内存占用 $M_{\\mathrm{mf}}(p,d)$，用 $p$ 和 $d$ 表示，忽略常数和 $p$ 的低阶项。\n3. 使用以上结果，构建渐近比率 $R_{\\mathrm{mem}}(p,d)=M_{\\mathrm{asm}}(p,d)/M_{\\mathrm{mf}}(p,d)$，并将其简化为关于 $p$ 和 $d$ 的主阶依赖关系。\n4. 推导每次算子应用的主阶通信量 $C_{\\mathrm{asm}}(p,d,S)$ 和 $C_{\\mathrm{mf}}(p,d,S)$，并构建比率 $R_{\\mathrm{comm}}(p,d)=C_{\\mathrm{asm}}(p,d,S)/C_{\\mathrm{mf}}(p,d,S)$，将其简化为关于 $p$ 和 $d$ 的主阶依赖关系。\n5. 以封闭形式提供行向量 $\\bigl(R_{\\mathrm{mem}}(p,d),\\,R_{\\mathrm{comm}}(p,d)\\bigr)$ 作为您的最终答案。\n\n您的推导必须从上述定义以及不连续伽辽金算子和张量积基的标准性质出发。忽略不依赖于 $p$ 或 $d$ 的乘法常数，并忽略与主阶项相比 $p$ 的低阶项。最终答案必须是任务5中描述的单一的行向量表达式（无单位）。", "solution": "用户提供了一个有效的问题陈述，其基础是偏微分方程的数值方法原理，特别是一种高阶不连续伽辽金 (DG) 方法。该问题提法恰当、客观，并包含足够的信息以获得唯一解。我将按要求进行推导。\n\n分析的关键在于，在 $d$ 维六面体网格上，确定两种不同 DG 算子表示的内存和通信成本随多项式次数 $p$ 变化的尺度关系。关键量是每个单元的未知量数量 $n_{e} = (p+1)^{d}$ 和每个面的未知量数量 $n_{f} = (p+1)^{d-1}$。\n\n### 任务1：组装矩阵的每单元内存占用 $M_{\\mathrm{asm}}(p,d)$\n\n以压缩稀疏行 (CSR) 格式存储的组装稀疏矩阵所需的内存与其非零元的数量成正比。我们计算全局矩阵中与单个单元的行相关联的非零元数量。根据问题陈述，这些非零元来自两个来源：单元内部（体）耦合和面（通量）耦合。\n\n1.  **体项贡献**：体项耦合一个单元内的所有基函数，形成一个大小为 $n_{e} \\times n_{e}$ 的稠密块。此块中的非零元数量为 $n_{e}^{2}$。\n\n2.  **面项贡献**：一个内部单元有 $c_{n} = 2d$ 个面相邻单元。对于每个相邻单元，耦合涉及共享面上相邻单元一侧的 $n_{f}$ 个迹未知量。问题陈述指出，这 $n_{f}$ 个未知量通过提升算子与本地单元的所有 $n_{e}$ 个未知量进行稠密耦合。因此，对于 $c_{n}$ 个相邻单元中的每一个，都有 $n_{e} \\times n_{f}$ 个非零元的贡献。来自面项的非零元总数为 $c_{n} n_{e} n_{f}$。\n\n每个单元的非零元总数（记为 $nnz_{e}$）是这些贡献的总和：\n$$nnz_{e} = n_{e}^{2} + c_{n} n_{e} n_{f}$$\n内存占用 $M_{\\mathrm{asm}}$ 与 $nnz_{e}$ 成正比。我们将给定的关于 $n_{e}$、$n_{f}$ 和 $c_{n}$ 的表达式代入（用 $p$ 和 $d$ 表示）：\n$$M_{\\mathrm{asm}}(p,d) \\propto \\left((p+1)^{d}\\right)^{2} + (2d) (p+1)^{d} (p+1)^{d-1}$$\n$$M_{\\mathrm{asm}}(p,d) \\propto (p+1)^{2d} + 2d (p+1)^{2d-1}$$\n对于 $p \\to \\infty$ 的渐近分析，我们找出 $p$ 的最高次幂项。项 $(p+1)^{2d}$ 的阶为 $\\mathcal{O}(p^{2d})$，而项 $2d (p+1)^{2d-1}$ 的阶为 $\\mathcal{O}(p^{2d-1})$。第一项是主导项。因此，组装矩阵内存占用的主阶行为是：\n$$M_{\\mathrm{asm}}(p,d) \\propto (p+1)^{2d}$$\n\n### 任务2：无矩阵表示的每单元内存占用 $M_{\\mathrm{mf}}(p,d)$\n\n问题陈述定义了无矩阵表示的存储模型。其主要开销在于为和因子分解存储预计算的几何因子，并且此存储量与每个单元的未知量（或求积点）数量 $n_{e}$ 呈线性关系。\n内存占用由下式给出：\n$$M_{\\mathrm{mf}}(p,d) \\propto n_{e}$$\n代入 $n_{e}$ 的定义：\n$$M_{\\mathrm{mf}}(p,d) \\propto (p+1)^{d}$$\n此表达式代表了无矩阵方案的主阶内存占用。\n\n### 任务3：渐近内存比率 $R_{\\mathrm{mem}}(p,d)$\n\n内存占用的渐近比率是通过将 $M_{\\mathrm{asm}}$ 的表达式除以 $M_{\\mathrm{mf}}$ 的表达式得到的。我们关心的是关于 $p$ 和 $d$ 的主阶依赖关系。让我们构建完整表达式的比率，然后确定其主阶行为。\n$$R_{\\mathrm{mem}}(p,d) = \\frac{M_{\\mathrm{asm}}(p,d)}{M_{\\mathrm{mf}}(p,d)} \\propto \\frac{(p+1)^{2d} + 2d (p+1)^{2d-1}}{(p+1)^{d}}$$\n简化表达式得到：\n$$R_{\\mathrm{mem}}(p,d) \\propto (p+1)^{d} + 2d (p+1)^{d-1}$$\n为了找到关于 $p$ 的主阶依赖关系，我们比较各项。第一项 $(p+1)^{d}$ 的阶为 $\\mathcal{O}(p^{d})$，第二项 $2d (p+1)^{d-1}$ 的阶为 $\\mathcal{O}(p^{d-1})$。对于大的 $p$，主导项是 $(p+1)^{d}$。因此，简化的渐近比率为：\n$$R_{\\mathrm{mem}}(p,d) = (p+1)^{d}$$\n\n### 任务4：渐近通信比率 $R_{\\mathrm{comm}}(p,d)$\n\n我们在具有 $S$ 个共享面的区域分解设置中，分析单次算子应用的通信量。\n\n1.  **组装矩阵通信 ($C_{\\mathrm{asm}}$)**：对于稀疏矩阵向量乘法 (SpMV)，一个进程需要向量中与其矩阵分区中的非零列相对应的分量。问题陈述指出，对于进程间耦合，所需数据包括相邻单元的面迹项。通信量与共享面数量 $S$ 乘以每个面的未知量数量 $n_{f}$ 成正比。\n    $$C_{\\mathrm{asm}}(p,d,S) \\propto S \\, n_{f} = S (p+1)^{d-1}$$\n\n2.  **无矩阵通信 ($C_{\\mathrm{mf}}$)**：对于无矩阵的面通量评估，从相邻进程所需的数据正是相邻面上的解的迹值。问题证实了这一点，指出通信“同样……与 $S \\, n_{f}$ 个标量成正比”。\n    $$C_{\\mathrm{mf}}(p,d,S) \\propto S \\, n_{f} = S (p+1)^{d-1}$$\n\n通信量的比率 $R_{\\mathrm{comm}}(p,d)$ 是通过将 $C_{\\mathrm{asm}}$ 除以 $C_{\\mathrm{mf}}$ 得到的。\n$$R_{\\mathrm{comm}}(p,d) = \\frac{C_{\\mathrm{asm}}(p,d,S)}{C_{\\mathrm{mf}}(p,d,S)} \\propto \\frac{S (p+1)^{d-1}}{S (p+1)^{d-1}} = 1$$\n由于对 $p$、$d$ 和 $S$ 的主阶函数依赖关系是相同的，并且我们被指示忽略乘法常数，所以比率为 $1$。\n\n### 任务5：最终答案向量\n\n最终答案是包含两个推导比率的行向量 $\\bigl(R_{\\mathrm{mem}}(p,d),\\,R_{\\mathrm{comm}}(p,d)\\bigr)$。基于以上分析：\n- $R_{\\mathrm{mem}}(p,d) = (p+1)^{d}$\n- $R_{\\mathrm{comm}}(p,d) = 1$\n\n最终向量为 $\\bigl((p+1)^{d},\\,1\\bigr)$。", "answer": "$$\\boxed{\\begin{pmatrix} (p+1)^{d}  1 \\end{pmatrix}}$$", "id": "3407879"}]}