{"hands_on_practices": [{"introduction": "本练习聚焦于离散 de Rham 复形的基本代数性质。在实现复杂的数值格式之前，理解离散空间与算子之间的关系至关重要。此问题要求您运用秩-零化度定理等核心线性代数概念，分析谱元子复形的结构并确定其核空间的维度，从而为后续学习奠定坚实的理论基础。[@problem_id:3380442]", "problem": "考虑参考正方形 $\\hat{K} = [-1,1]^{2}$ 以及作为二维谱元子复形基础的张量积多项式空间。对于固定的多项式次数 $p \\in \\mathbb{N}$ 且 $p \\geq 1$，定义标量多项式空间 $\\hat{V}^{0}_{p}$ 和向量多项式空间 $\\hat{V}^{1}_{p}$ 为\n$$\n\\hat{V}^{0}_{p} := \\mathcal{Q}_{p,p}, \\qquad \\hat{V}^{1}_{p} := \\mathcal{Q}_{p-1,p} \\times \\mathcal{Q}_{p,p-1},\n$$\n其中 $\\mathcal{Q}_{a,b}$ 表示在 $\\hat{K}$ 上所有 $x$ 变量次数最高为 $a$ 且 $y$ 变量次数最高为 $b$ 的多项式集合。设离散微分算子为\n$$\nd^{0} := \\nabla : \\hat{V}^{0}_{p} \\to \\hat{V}^{1}_{p}, \\qquad d^{1} : \\hat{V}^{1}_{p} \\to \\hat{V}^{2}_{p}, \\quad d^{1}\\boldsymbol{v} := \\partial_{x} v_{2} - \\partial_{y} v_{1},\n$$\n映射到标量空间 $\\hat{V}^{2}_{p} := \\mathcal{Q}_{p-1,p-1}$。假设 $\\hat{K}$ 是单连通的，并且标准的谱元投影导出一个具有交换图的离散 de Rham 复形，因此 $\\nabla \\hat{V}^{0}_{p} \\subset \\hat{V}^{1}_{p}$ 且 $d^{1} \\circ \\nabla = 0$。\n\n仅从张量积空间的定义、上述算子 $d^{0}$ 和 $d^{1}$，以及在单连通域上无旋场是梯度场这一事实出发，推导限制在 $\\hat{V}^{1}_{p}$ 上的 $d^{1}$ 的核空间的维数的封闭形式解析表达式，即\n$$\n\\dim\\left(\\ker\\left(d^{1}\\big|\\hat{V}^{1}_{p}\\right)\\right).\n$$\n请将最终答案表示为 $p$ 的函数，并以精确形式给出。无需四舍五入，不涉及物理单位。", "solution": "该问题是有效的。这是一个在数值分析和有限元方法领域中定义明确的数学问题，具体涉及张量积多项式空间上离散 de Rham 复形的性质。所有术语都定义清晰，前提条件在科学上和数学上都是合理的。\n\n目标是计算离散微分算子 $d^{1}$ 的核空间的维数，记为 $\\dim(\\ker(d^{1}))$。算子 $d^{1}$ 作用于向量多项式空间 $\\hat{V}^{1}_{p} = \\mathcal{Q}_{p-1,p} \\times \\mathcal{Q}_{p,p-1}$，对于向量场 $\\boldsymbol{v} = (v_1, v_2)$，其定义为 $d^{1}\\boldsymbol{v} := \\partial_{x} v_{2} - \\partial_{y} v_{1}$。\n\n问题提供了一系列空间和算子，它们构成了一个离散 de Rham 复形的一部分：\n$$ \\hat{V}^{0}_{p} \\xrightarrow{d^{0}} \\hat{V}^{1}_{p} \\xrightarrow{d^{1}} \\hat{V}^{2}_{p} $$\n其中 $d^{0} = \\nabla$。给定性质 $d^{1} \\circ d^{0} = 0$，这意味着 $d^{0}$ 的像空间是 $d^{1}$ 的核空间的子空间，即 $\\text{Im}(d^{0}) \\subseteq \\ker(d^{1})$。\n\n该问题利用了这样一个事实：在像参考正方形 $\\hat{K} = [-1,1]^{2}$ 这样的单连通域上，无旋向量场总是一个标量势的梯度。我们将证明，对于指定的多项式空间，该性质完全成立，这意味着该序列在 $\\hat{V}^{1}_{p}$ 处是正合的。这就建立了等式 $\\text{Im}(d^{0}) = \\ker(d^{1})$。\n\n我们来证明这个正合性。\n首先，我们确认 $\\text{Im}(d^{0}) \\subseteq \\ker(d^{1})$。令 $\\phi \\in \\hat{V}^{0}_{p}$。则 $d^{0}\\phi = \\nabla\\phi = (\\partial_{x}\\phi, \\partial_{y}\\phi)$。将 $d^{1}$ 应用于此向量场得到\n$$ d^{1}(d^{0}\\phi) = \\partial_{x}(\\partial_{y}\\phi) - \\partial_{y}(\\partial_{x}\\phi) = \\frac{\\partial^2 \\phi}{\\partial x \\partial y} - \\frac{\\partial^2 \\phi}{\\partial y \\partial x} $$\n由于 $\\phi$ 是一个多项式，它是无限可微的，根据关于混合偏导数相等的 Clairaut 定理，此表达式恒为零。因此，$d^{0}$ 的像空间中的任何元素都在 $d^{1}$ 的核空间中。\n\n接下来，我们证明反向包含关系，$\\ker(d^{1}) \\subseteq \\text{Im}(d^{0})$。设 $\\boldsymbol{v} = (v_{1}, v_{2})$ 是 $\\ker(d^{1})$ 中的任意元素。根据定义，$\\boldsymbol{v} \\in \\hat{V}^{1}_{p}$ 且 $d^{1}\\boldsymbol{v} = 0$。条件 $d^{1}\\boldsymbol{v} = \\partial_{x}v_{2} - \\partial_{y}v_{1} = 0$ 意味着 $\\boldsymbol{v}$ 是一个无旋向量场。由于域 $\\hat{K}$ 是单连通的，存在一个标量势 $\\phi$ 使得 $\\boldsymbol{v} = \\nabla\\phi$。我们必须证明，如果 $\\boldsymbol{v} \\in \\hat{V}^{1}_{p}$，那么这个势 $\\phi$ 可以被选择为属于 $\\hat{V}^{0}_{p}$。\n\n$\\boldsymbol{v}$ 的分量是 $v_1 \\in \\mathcal{Q}_{p-1,p}$ 和 $v_2 \\in \\mathcal{Q}_{p,p-1}$。我们可以显式地构造势 $\\phi$，例如，通过积分：\n$$ \\phi(x,y) = \\int_{-1}^{x} v_{1}(\\xi, y) \\,d\\xi + \\int_{-1}^{y} v_{2}(-1, \\eta) \\,d\\eta $$\n我们来验证 $\\nabla\\phi = \\boldsymbol{v}$。对 $x$ 求导：\n$$ \\partial_{x}\\phi(x,y) = v_{1}(x,y) $$\n对 $y$ 求导：\n$$ \\partial_{y}\\phi(x,y) = \\int_{-1}^{x} \\partial_{y}v_{1}(\\xi, y) \\,d\\xi + v_{2}(-1, y) $$\n由于 $\\boldsymbol{v}$ 是无旋的，我们有 $\\partial_{y}v_{1} = \\partial_{x}v_{2}$。将此代入 $\\partial_{y}\\phi$ 的表达式中：\n$$ \\partial_{y}\\phi(x,y) = \\int_{-1}^{x} \\partial_{\\xi}v_{2}(\\xi, y) \\,d\\xi + v_{2}(-1, y) = \\left[v_{2}(\\xi, y)\\right]_{\\xi=-1}^{x} + v_{2}(-1, y) $$\n$$ \\partial_{y}\\phi(x,y) = (v_{2}(x, y) - v_{2}(-1, y)) + v_{2}(-1, y) = v_{2}(x,y) $$\n因此，我们构造了一个势 $\\phi$ 使得 $\\nabla\\phi = \\boldsymbol{v}$。现在我们检查 $\\phi$ 是否属于 $\\hat{V}^{0}_{p} = \\mathcal{Q}_{p,p}$。\n1. 由于 $v_{1}(\\xi, y) \\in \\mathcal{Q}_{p-1,p}$，其关于 $\\xi$ 的积分得到一个 $x$ 的次数最高为 $p$、$y$ 的次数最高为 $p$ 的多项式。所以，$\\int_{-1}^{x} v_{1}(\\xi, y) \\,d\\xi \\in \\mathcal{Q}_{p,p}$。\n2. 由于 $v_{2}(-1, \\eta) \\in \\mathcal{Q}_{p,p-1}$，在 $x=-1$ 处求值得到一个 $\\eta$ 的次数最高为 $p-1$ 的多项式。其关于 $\\eta$ 的积分是一个 $y$ 的次数最高为 $p$ 的多项式，且与 $x$ 无关。该多项式属于 $\\mathcal{Q}_{0,p}$，它是 $\\mathcal{Q}_{p,p}$ 的一个子空间。\n$\\mathcal{Q}_{p,p}$ 中两个多项式之和也在 $\\mathcal{Q}_{p,p}$ 中。因此，$\\phi \\in \\mathcal{Q}_{p,p} = \\hat{V}^{0}_{p}$。这表明 $\\ker(d^{1})$ 中的任何元素 $\\boldsymbol{v}$ 都可以写成某个 $\\phi \\in \\hat{V}^{0}_{p}$ 的 $d^{0}\\phi$ 形式。这意味着 $\\ker(d^{1}) \\subseteq \\text{Im}(d^{0})$。\n\n建立了两个包含关系后，我们得出结论 $\\ker(d^{1}) = \\text{Im}(d^{0})$。因此，它们的维数相等：\n$$ \\dim(\\ker(d^{1})) = \\dim(\\text{Im}(d^{0})) $$\n为了求出 $\\dim(\\text{Im}(d^{0}))$，我们对线性映射 $d^{0} : \\hat{V}^{0}_{p} \\to \\hat{V}^{1}_{p}$ 应用秩-零度定理：\n$$ \\dim(\\hat{V}^{0}_{p}) = \\dim(\\ker(d^{0})) + \\dim(\\text{Im}(d^{0})) $$\n整理得：\n$$ \\dim(\\text{Im}(d^{0})) = \\dim(\\hat{V}^{0}_{p}) - \\dim(\\ker(d^{0})) $$\n我们需要计算空间 $\\hat{V}^{0}_{p}$ 和 $d^{0}$ 的核空间的维数。\n空间 $\\hat{V}^{0}_{p}$ 定义为 $\\mathcal{Q}_{p,p}$，即 $x$ 的次数最高为 $p$、$y$ 的次数最高为 $p$ 的多项式空间。一组基由单项式 $\\{x^i y^j\\}_{0 \\le i \\le p, 0 \\le j \\le p}$ 给出。基元素的数量是 $(p+1)(p+1) = (p+1)^{2}$。所以，$\\dim(\\hat{V}^{0}_{p}) = (p+1)^{2}$。\n\n$d^{0} = \\nabla$ 的核空间由所有满足 $\\nabla\\phi = (\\partial_{x}\\phi, \\partial_{y}\\phi) = (0,0)$ 的多项式 $\\phi \\in \\hat{V}^{0}_{p}$ 组成。一个多项式对其所有变量的偏导数都为零，当且仅当它是一个常数。常数多项式空间由单个多项式 $1$ 张成。由于 $p \\geq 1$，常数函数 $1$ 是 $\\mathcal{Q}_{p,p}$ 的一个元素。因此，$\\ker(d^{0})$ 是由常数函数组成的一维空间。\n$$ \\dim(\\ker(d^{0})) = 1 $$\n将这些维数代入我们的表达式中：\n$$ \\dim(\\ker(d^{1})) = \\dim(\\text{Im}(d^{0})) = (p+1)^{2} - 1 $$\n$$ \\dim(\\ker(d^{1})) = (p^{2} + 2p + 1) - 1 = p^{2} + 2p $$\n这就是 $d^{1}$ 的核空间维数的最终表达式。", "answer": "$$\n\\boxed{p^2+2p}\n$$", "id": "3380442"}, {"introduction": "交换图是结构保持离散化的基石。本实践提供了一个直接的动手操作机会，通过将抽象的离散外微分算子 $d$ 与经典的 Stokes 定理和 Gauss 定理联系起来，来验证这一关键性质。您将通过在简单的几何元素上实现余链投影和离散算子，从数值上确认图表的交换性，并观察其如何与基本物理定律相联系。[@problem_id:3380459]", "problem": "考虑通过在简单定向网格上构建的离散 de Rham 复形来表述的麦克斯韦方程组的间断伽辽金（DG）离散化。设外微分（$\\mathrm{d}$）在不同阶的离散上链之间进行映射，并设可交换投影（$\\Pi_k$）通过将连续场积分到 $k$-上链（当 $k=1$ 时为边，$k=2$ 时为面，$k=3$ 时为体）上来定义。当 $\\Pi_k$ 由精确的线/面积/体积积分定义，并且关联关系（$\\mathrm{d}$）通过定向边界和实现时，可交换图性质在足够光滑的场上表明 $\\mathrm{d}\\circ\\Pi_k = \\Pi_{k+1}\\circ \\mathrm{d}$。以斯托克斯定理和散度定理为基本依据，您将在一组构造的场上对这些性质进行数值验证，同时在上链层面检查法拉第定律和高斯定律的积分恒等式。\n\n几何与定向：\n- 设由顶点 $v_0=(0,0,0)$、$v_1=(1,0,0)$、$v_2=(0,1,0)$ 定义的定向三角形（一个 2-单纯形），其正定向法向量 $\\boldsymbol{n}$ 指向 $+z$ 方向。其定向边界为逆时针边循环 $(v_0\\rightarrow v_1)$、$(v_1\\rightarrow v_2)$、$(v_2\\rightarrow v_0)$。\n- 设由顶点 $v_0=(0,0,0)$、$v_1=(1,0,0)$、$v_2=(0,1,0)$、$v_3=(0,0,1)$ 定义的定向四面体（一个 3-单纯形），其定向由有序列表 $[v_0,v_1,v_2,v_3]$ 给出。其定向边界由以下顶点排序的面构成：$(v_1,v_2,v_3)$、$(v_0,v_3,v_2)$、$(v_0,v_1,v_3)$、$(v_0,v_2,v_1)$，根据右手定则计算时，这些面对应于外法线。对于具有有序顶点 $(a,b,c)$ 的三角形，设其定向面积矢量为 $\\boldsymbol{A} = \\tfrac{1}{2}(b-a)\\times(c-a)$，因此 $\\int_{\\text{face}} \\boldsymbol{n}\\, \\mathrm{d}S = \\boldsymbol{A}$。对于四面体，其体积为 $V=\\tfrac{1}{6}\\left|\\det\\left([v_1-v_0, v_2-v_0, v_3-v_0]\\right)\\right|$。\n\n上链投影和离散外微分：\n- 对于光滑矢量场 $\\boldsymbol{E}(\\boldsymbol{x},t)$，通过在定向边上的线积分定义 1-上链投影：$\\Pi_1 \\boldsymbol{E}(e) = \\int_e \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l}$。\n- 对于光滑矢量场 $\\boldsymbol{B}(\\boldsymbol{x},t)$，通过在定向面上的面积通量定义 2-上链投影：$\\Pi_2 \\boldsymbol{B}(f) = \\int_f \\boldsymbol{B}\\cdot \\boldsymbol{n}\\,\\mathrm{d}S$。\n- 对于光滑标量场 $q(\\boldsymbol{x},t)$，通过在定向单元上的体积分定义 3-上链投影：$\\Pi_3 q(c) = \\int_c q\\,\\mathrm{d}V$。\n- 离散外微分 $\\mathrm{d}$ 通过定向边界和作用：对于边界边为 $\\partial f$ 的面 $f$，$(\\mathrm{d}\\Pi_1 \\boldsymbol{E})(f) = \\sum_{e\\in \\partial f} \\Pi_1 \\boldsymbol{E}(e)$；对于边界面为 $\\partial c$ 的单元 $c$，$(\\mathrm{d}\\Pi_2 \\boldsymbol{B})(c) = \\sum_{f\\in \\partial c} \\Pi_2 \\boldsymbol{B}(f)$。\n\n需要验证的基本恒等式：\n- 斯托克斯定理：$\\int_f (\\nabla\\times \\boldsymbol{E})\\cdot \\boldsymbol{n}\\,\\mathrm{d}S = \\oint_{\\partial f} \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l}$，这意味着在面上具有可交换性质 $\\mathrm{d}\\circ\\Pi_1 \\boldsymbol{E} = \\Pi_2 (\\nabla\\times\\boldsymbol{E})$。\n- 散度定理：$\\int_c (\\nabla\\cdot \\boldsymbol{B})\\,\\mathrm{d}V = \\int_{\\partial c} \\boldsymbol{B}\\cdot \\boldsymbol{n}\\,\\mathrm{d}S$，这意味着在单元上具有可交换性质 $\\mathrm{d}\\circ\\Pi_2 \\boldsymbol{B} = \\Pi_3 (\\nabla\\cdot\\boldsymbol{B})$。\n- 积分形式的法拉第定律：$\\oint_{\\partial f} \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l} + \\dfrac{\\partial}{\\partial t}\\int_f \\boldsymbol{B}\\cdot \\boldsymbol{n}\\,\\mathrm{d}S = 0$。\n- 高斯磁定律：$\\int_c (\\nabla\\cdot \\boldsymbol{B})\\,\\mathrm{d}V = 0$。\n\n数值实现：\n- 对线段上的线积分使用中点法则，该法则对线性场是精确的：对于从 $a$ 到 $b$ 的定向边，$\\int_e \\boldsymbol{E}\\cdot \\mathrm{d}\\boldsymbol{l} = \\boldsymbol{E}\\!\\left(\\tfrac{a+b}{2},t\\right)\\cdot (b-a)$。\n- 对线性场在三角形上使用形心法则：对于面 $(a,b,c)$，若 $\\boldsymbol{F}$ 在空间上是线性的，则 $\\int_f \\boldsymbol{F}\\cdot \\boldsymbol{n}\\,\\mathrm{d}S = \\boldsymbol{F}\\!\\left(\\tfrac{a+b+c}{3},t\\right)\\cdot \\boldsymbol{A}$。\n- 对线性标量在四面体上使用形心法则：若 $q$ 在空间上是线性的，则 $\\int_c q\\,\\mathrm{d}V = q\\!\\left(\\tfrac{v_0+v_1+v_2+v_3}{4},t\\right)\\, V$。\n\n测试套件：\n对于每个测试案例，定义 $\\boldsymbol{E}$、其旋度 $\\nabla\\times\\boldsymbol{E}$、$\\boldsymbol{B}$、其散度 $\\nabla\\cdot\\boldsymbol{B}$、时间导数 $\\dfrac{\\partial \\boldsymbol{B}}{\\partial t}$ 和计算时间 $t$。所有场都是无量纲的（已作无量纲化处理），因此输出中无需物理单位。\n\n- 案例 A（非平凡的、与麦克斯韦方程一致的环量和零散度）：\n  - $\\boldsymbol{E}(\\boldsymbol{x},t) = \\left(-\\dfrac{y}{2}, \\dfrac{x}{2}, 0\\right)$。\n  - $\\nabla\\times\\boldsymbol{E} = (0,0,1)$。\n  - $\\boldsymbol{B}(\\boldsymbol{x},t) = (0,0,-t)$。\n  - $\\nabla\\cdot\\boldsymbol{B} = 0$。\n  - $\\dfrac{\\partial \\boldsymbol{B}}{\\partial t} = (0,0,-1)$。\n  - $t=0.3$。\n- 案例 B（可交换性质成立；麦克斯韦定律不成立）：\n  - $\\boldsymbol{E}(\\boldsymbol{x},t) = (x,0,0)$。\n  - $\\nabla\\times\\boldsymbol{E} = (0,0,0)$。\n  - $\\boldsymbol{B}(\\boldsymbol{x},t) = \\left(x, \\dfrac{y}{2}, -\\dfrac{z}{4} + \\sin t\\right)$。\n  - $\\nabla\\cdot\\boldsymbol{B} = \\dfrac{\\partial}{\\partial x}x + \\dfrac{\\partial}{\\partial y}\\left(\\dfrac{y}{2}\\right) + \\dfrac{\\partial}{\\partial z}\\left(-\\dfrac{z}{4} + \\sin t\\right) = 1 + \\dfrac{1}{2} - \\dfrac{1}{4} = \\dfrac{5}{4}$。\n  - $\\dfrac{\\partial \\boldsymbol{B}}{\\partial t} = (0,0,\\cos t)$。\n  - $t=0.7$。\n- 案例 C（零场）：\n  - $\\boldsymbol{E}(\\boldsymbol{x},t) = (0,0,0)$。\n  - $\\nabla\\times\\boldsymbol{E} = (0,0,0)$。\n  - $\\boldsymbol{B}(\\boldsymbol{x},t) = (0,0,0)$。\n  - $\\nabla\\cdot\\boldsymbol{B} = 0$。\n  - $\\dfrac{\\partial \\boldsymbol{B}}{\\partial t} = (0,0,0)$。\n  - $t=0$。\n\n程序要求：\n- 在给定的定向三角形和四面体上，使用上述规则实现上链投影和离散外微分。\n- 对于每个案例，使用容差 $\\varepsilon=10^{-12}$ 计算四个布尔检查：\n  1. 旋度的可交换性：$\\left|(\\mathrm{d}\\circ \\Pi_1 \\boldsymbol{E})(\\text{face}) - \\Pi_2 (\\nabla\\times\\boldsymbol{E})(\\text{face})\\right| \\le \\varepsilon$。\n  2. 法拉第积分恒等式：$\\left|(\\mathrm{d}\\circ \\Pi_1 \\boldsymbol{E})(\\text{face}) + \\dfrac{\\partial}{\\partial t}\\Pi_2 \\boldsymbol{B}(\\text{face})\\right| \\le \\varepsilon$。\n  3. 散度的可交换性：$\\left|(\\mathrm{d}\\circ \\Pi_2 \\boldsymbol{B})(\\text{cell}) - \\Pi_3 (\\nabla\\cdot\\boldsymbol{B})(\\text{cell})\\right| \\le \\varepsilon$。\n  4. 高斯定律：$\\left|\\Pi_3 (\\nabla\\cdot\\boldsymbol{B})(\\text{cell})\\right| \\le \\varepsilon$。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_{12}]$），列表条目是案例 A、B 和 C 的十二个布尔值，顺序按每个案例的四个检查指定。\n\n解决方案应仅依赖于基本定理（斯托克斯定理和散度定理）、作为定向边界和的离散外微分的定义，以及由线/面积/体积积分定义的精确投影算子。不允许外部输入。使用确定性算术和规定的容差进行比较。", "solution": "已对用户提供的问题陈述进行分析，并认定其**有效**。该问题具有科学依据、定义清晰，并且为获得唯一解提供了所有必要的数据和定义。该问题要求在单个三角形面和单个四面体单元上，对与离散 de Rham 复形相关的可交换图性质和物理定律进行数值验证。所提供的场在空间变量上是线性的，对于这些场，指定的求积法则（中点法则和形心法则）是精确的。这确保了数值投影不是近似值，而是对连续积分的精确计算，从而可以对代数结构进行精确测试。\n\n解决方案步骤如下：\n1.  **定义几何实体**：将参考三角形和四面体的顶点定义为 `numpy` 数组。根据这些顶点，并遵循问题陈述中指定的定向，构造三角形的定向边和四面体的定向面。\n2.  **实现辅助几何函数**：实现计算三角形定向面积矢量 $\\boldsymbol{A} = \\frac{1}{2}(b-a)\\times(c-a)$ 和四面体体积 $V=\\frac{1}{6}|\\det([v_1-v_0, v_2-v_0, v_3-v_0])|$ 的函数。这些对于投影算子至关重要。\n3.  **实现投影算子（$\\Pi_k$）**：根据提供的数值积分规则实现投影算子，这些算子将连续场映射到离散上链：\n    *   $\\Pi_1$：矢量场 $\\boldsymbol{E}$ 在边 $e=(a,b)$ 上的线积分使用中点法则计算：$\\Pi_1 \\boldsymbol{E}(e) = \\boldsymbol{E}(\\frac{a+b}{2}, t) \\cdot (b-a)$。\n    *   $\\Pi_2$：矢量场 $\\boldsymbol{F}$ 在三角形面 $f=(a,b,c)$ 上的面积积分（通量）使用形心法则计算：$\\Pi_2 \\boldsymbol{F}(f) = \\boldsymbol{F}(\\frac{a+b+c}{3}, t) \\cdot \\boldsymbol{A}_f$。\n    *   $\\Pi_3$：标量场 $q$ 在四面体单元 $c=(v_0,v_1,v_2,v_3)$ 上的体积分使用形心法则计算：$\\Pi_3 q(c) = q(\\frac{v_0+v_1+v_2+v_3}{4}, t) \\cdot V_c$。\n4.  **实现离散外微分（$\\mathrm{d}$）**：将离散外微分实现为边界元素上的定向和：\n    *   对于 1-上链（边上的值），其在面 $f$ 上的微分为 $(\\mathrm{d}\\Pi_1 \\boldsymbol{E})(f) = \\sum_{e \\in \\partial f} \\Pi_1 \\boldsymbol{E}(e)$。该和是对构成面边界的定向边求和。\n    *   对于 2-上链（面上的值），其在单元 $c$ 上的微分为 $(\\mathrm{d}\\Pi_2 \\boldsymbol{B})(c) = \\sum_{f \\in \\partial c} \\Pi_2 \\boldsymbol{B}(f)$。该和是对构成单元边界的定向面求和。\n5.  **定义场函数**：对于三个测试案例（A、B、C）中的每一个，将矢量场 $\\boldsymbol{E}(\\boldsymbol{x},t)$、$\\boldsymbol{B}(\\boldsymbol{x},t)$、它们的导数（$\\nabla\\times\\boldsymbol{E}$、$\\nabla\\cdot\\boldsymbol{B}$、$\\frac{\\partial\\boldsymbol{B}}{\\partial t}$）和计算时间 $t$ 定义为 Python 函数。\n6.  **执行数值验证**：对于每个测试案例，使用 $\\varepsilon = 10^{-12}$ 的容差执行四个指定的检查。\n    *   **检查 1（旋度的可交换性）**：在三角形上验证 $\\mathrm{d}\\circ\\Pi_1 \\boldsymbol{E} = \\Pi_2(\\nabla\\times\\boldsymbol{E})$。这是斯托克斯定理的离散形式。由于基本定理为真，且对于给定的线性场投影是精确的，因此该检查预计对所有案例都通过。\n    *   **检查 2（法拉第定律）**：验证 $(\\mathrm{d}\\circ \\Pi_1 \\boldsymbol{E})(f) + \\Pi_2 (\\frac{\\partial \\boldsymbol{B}}{\\partial t})(f) = 0$。这是法拉第电磁感应定律的离散积分形式。仅当提供的场 $\\boldsymbol{E}$ 和 $\\boldsymbol{B}$ 满足连续定律 $\\nabla\\times\\boldsymbol{E} = -\\frac{\\partial\\boldsymbol{B}}{\\partial t}$ 时，此检查才成立。\n    *   **检查 3（散度的可交换性）**：在四面体上验证 $\\mathrm{d}\\circ\\Pi_2 \\boldsymbol{B} = \\Pi_3(\\nabla\\cdot\\boldsymbol{B})$。这是散度定理的离散形式。与第一个检查一样，这是一个代数恒等式，在投影精确的情况下，应对所有案例都成立。\n    *   **检查 4（高斯磁定律）**：验证 $\\Pi_3(\\nabla\\cdot\\boldsymbol{B}) = 0$，这是连续定律 $\\nabla\\cdot\\boldsymbol{B}=0$ 的直接推论。此检查取决于给定的 $\\boldsymbol{B}$ 场是否无散。\n7.  **格式化输出**：收集十二个布尔检查的结果（三个案例各四个），并按要求格式化为单个字符串。\n\n计算按计划执行。对于案例 A，构造的场满足麦克斯韦方程组，因此所有四个检查都通过。对于案例 B，选择的场不满足法拉第定律和高斯磁定律，但可交换图性质（纯粹是几何/代数性质）仍然成立。对于案例 C，所有场均为零，因此平凡地满足所有条件。最终输出将反映这些理论预期。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the discrete de Rham complex verification problem.\n    \"\"\"\n    TOL = 1e-12\n\n    # --- 1. Define Geometric Entities ---\n    v0 = np.array([0.0, 0.0, 0.0])\n    v1 = np.array([1.0, 0.0, 0.0])\n    v2 = np.array([0.0, 1.0, 0.0])\n    v3 = np.array([0.0, 0.0, 1.0])\n\n    # Oriented triangle face and its boundary edges\n    triangle_face_geom = (v0, v1, v2)\n    triangle_edges_geom = [(v0, v1), (v1, v2), (v2, v0)]\n\n    # Oriented tetrahedron cell and its boundary faces\n    tetra_cell_geom = (v0, v1, v2, v3)\n    tetra_faces_geom = [(v1, v2, v3), (v0, v3, v2), (v0, v1, v3), (v0, v2, v1)]\n\n    # --- 2. Implement Auxiliary Geometric Functions ---\n    def area_vector(v_a, v_b, v_c):\n        return 0.5 * np.cross(v_b - v_a, v_c - v_a)\n\n    def volume(v0, v1, v2, v3):\n        mat = np.array([v1 - v0, v2 - v0, v3 - v0])\n        return np.abs(np.linalg.det(mat)) / 6.0\n\n    # --- 3. Implement Projection Operators ---\n    def pi_1(E_func, edge, t):\n        a, b = edge\n        midpoint = 0.5 * (a + b)\n        dl = b - a\n        E_val = E_func(midpoint, t)\n        return np.dot(E_val, dl)\n\n    def pi_2(F_func, face, t):\n        a, b, c = face\n        centroid = (a + b + c) / 3.0\n        A = area_vector(a, b, c)\n        F_val = F_func(centroid, t)\n        return np.dot(F_val, A)\n\n    def pi_3(q_func, cell, t):\n        v0, v1, v2, v3 = cell\n        centroid = (v0 + v1 + v2 + v3) / 4.0\n        V = volume(v0, v1, v2, v3)\n        q_val = q_func(centroid, t)\n        return q_val * V\n\n    # --- 4. Implement Discrete Exterior Derivative ---\n    def d_pi_1(E_func, edges, t):\n        total = 0.0\n        for edge in edges:\n            total += pi_1(E_func, edge, t)\n        return total\n\n    def d_pi_2(B_func, faces, t):\n        total = 0.0\n        for face in faces:\n            total += pi_2(B_func, face, t)\n        return total\n\n    # --- 5. Define Field Functions ---\n    test_cases = [\n        # Case A\n        {\n            \"E\": lambda x, t: np.array([-x[1]/2.0, x[0]/2.0, 0.0]),\n            \"curl_E\": lambda x, t: np.array([0.0, 0.0, 1.0]),\n            \"B\": lambda x, t: np.array([0.0, 0.0, -t]),\n            \"div_B\": lambda x, t: 0.0,\n            \"dB_dt\": lambda x, t: np.array([0.0, 0.0, -1.0]),\n            \"t\": 0.3\n        },\n        # Case B\n        {\n            \"E\": lambda x, t: np.array([x[0], 0.0, 0.0]),\n            \"curl_E\": lambda x, t: np.array([0.0, 0.0, 0.0]),\n            \"B\": lambda x, t: np.array([x[0], x[1]/2.0, -x[2]/4.0 + np.sin(t)]),\n            \"div_B\": lambda x, t: 1.25,\n            \"dB_dt\": lambda x, t: np.array([0.0, 0.0, np.cos(t)]),\n            \"t\": 0.7\n        },\n        # Case C\n        {\n            \"E\": lambda x, t: np.array([0.0, 0.0, 0.0]),\n            \"curl_E\": lambda x, t: np.array([0.0, 0.0, 0.0]),\n            \"B\": lambda x, t: np.array([0.0, 0.0, 0.0]),\n            \"div_B\": lambda x, t: 0.0,\n            \"dB_dt\": lambda x, t: np.array([0.0, 0.0, 0.0]),\n            \"t\": 0.0\n        }\n    ]\n\n    results = []\n    # --- 6. Perform Numerical Verification ---\n    for case in test_cases:\n        E_func = case[\"E\"]\n        curl_E_func = case[\"curl_E\"]\n        B_func = case[\"B\"]\n        div_B_func = case[\"div_B\"]\n        dB_dt_func = case[\"dB_dt\"]\n        t = case[\"t\"]\n\n        # Check 1: Commuting for curl on the triangle face\n        # | (d o Pi_1 E)(face) - Pi_2(curl E)(face) | = tol\n        d_pi_1_E_val = d_pi_1(E_func, triangle_edges_geom, t)\n        pi_2_curl_E_val = pi_2(curl_E_func, triangle_face_geom, t)\n        check1 = np.abs(d_pi_1_E_val - pi_2_curl_E_val) = TOL\n        results.append(check1)\n\n        # Check 2: Faraday integral identity on the triangle face\n        # | (d o Pi_1 E)(face) + d/dt(Pi_2 B)(face) | = tol\n        # d/dt(Pi_2 B) is implemented as Pi_2(dB/dt)\n        pi_2_dB_dt_val = pi_2(dB_dt_func, triangle_face_geom, t)\n        check2 = np.abs(d_pi_1_E_val + pi_2_dB_dt_val) = TOL\n        results.append(check2)\n\n        # Check 3: Commuting for divergence on the tetrahedron cell\n        # | (d o Pi_2 B)(cell) - Pi_3(div B)(cell) | = tol\n        d_pi_2_B_val = d_pi_2(B_func, tetra_faces_geom, t)\n        pi_3_div_B_val = pi_3(div_B_func, tetra_cell_geom, t)\n        check3 = np.abs(d_pi_2_B_val - pi_3_div_B_val) = TOL\n        results.append(check3)\n\n        # Check 4: Gauss's law for magnetism on the tetrahedron cell\n        # | Pi_3(div B)(cell) | = tol\n        check4 = np.abs(pi_3_div_B_val) = TOL\n        results.append(check4)\n\n    # --- 7. Format Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3380459"}, {"introduction": "为什么保持交换图的性质如此重要？本练习旨在探究当这一结构*未被*保持时所产生的后果。您将研究一个常见场景——谱模式截断，在此场景中交换性质失效，并量化由此产生的“交换亏格”与“Stokes 亏格”。这将帮助您具体地理解当底层结构被破坏时，会引入怎样的拓扑和分析误差。[@problem_id:3380480]", "problem": "考虑区间 $[-1,1]$ 上的一维离散 de Rham 复形，其中 0-形式是标量函数 $u(x)$，1-形式是形如 $v(x)\\,\\mathrm{d}x$ 的函数。外微分 $\\mathrm{d}$ 将一个 0-形式 $u$ 映射到一个 1-形式 $\\mathrm{d}u = u'(x)\\,\\mathrm{d}x$。在一个基于 Legendre 多项式的谱模态设置中，令 $\\{P_n(x)\\}_{n=0}^{\\infty}$ 表示在 $[-1,1]$ 上的 Legendre 多项式序列，该序列关于带单位权重的 $L^2([-1,1])$ 内积是正交的。对于一个截断阶数 $K \\in \\mathbb{N}$，定义到多项式空间 $V_K := \\mathrm{span}\\{P_0,\\dots,P_K\\}$ 上的模态截断（正交 $L^2$ 投影）算子 $\\Pi_K$ 为\n$$\n\\Pi_K u = \\sum_{n=0}^{K} a_n P_n(x), \\quad a_n = \\frac{2n+1}{2} \\int_{-1}^{1} u(x) P_n(x)\\,\\mathrm{d}x.\n$$\n类似地，为 1-形式定义到 $W_{K-1} := \\mathrm{span}\\{P_0,\\dots,P_{K-1}\\}$ 上的 $\\Pi_{K-1}$（在系数计算中忽略 $\\mathrm{d}x$ 因子）。谱模态稀疏化是通过截断到阶数 $K$ 来舍弃高频模态的操作，即将 $n  K$ 的系数 $a_n$ 置零。\n\n连续复形的交换图性质要求 $\\mathrm{d}\\,\\Pi_K u = \\Pi_{K-1}\\,\\mathrm{d}u$。当应用模态稀疏化时，对于非多项式函数 $u$，此性质通常不成立。我们希望量化由稀疏化引起的两个缺陷：\n\n1. 交换缺陷\n$$\n\\Delta_K(u) := \\left\\| \\mathrm{d}\\big(\\Pi_K u\\big) - \\Pi_{K-1}\\big(\\mathrm{d}u\\big) \\right\\|_{L^2([-1,1])},\n$$\n使用标准 $L^2$ 范数计算。\n\n2. 离散 Stokes 缺陷（一个拓扑误差的代理指标），\n$$\n\\Sigma_K(u) := \\left| \\int_{-1}^{1} \\Pi_{K-1}\\big(\\mathrm{d}u\\big)\\,\\mathrm{d}x - \\Big(\\big(\\Pi_K u\\big)(1) - \\big(\\Pi_K u\\big)(-1)\\Big) \\right|,\n$$\n它衡量了截断投影在保持微积分基本定理（Stokes 定理的一维实例）方面的失效程度。\n\n使用 Gauss–Legendre 求积法来近似计算投影和范数所需的积分。假设所有三角函数中的角度单位均为弧度。所有模态展开和投影都必须使用 Legendre 多项式基。\n\n你的程序必须实现上述定义，并为下面的每个测试用例计算浮点数值对 $(\\Delta_K(u), \\Sigma_K(u))$。使用足够高的求积阶数，以使数值积分误差相对于报告的值可以忽略不计。\n\n测试套件（每个用例指定 $u(x)$ 和 $K$）：\n\n- 用例 1：$u(x) = e^{x}$，$K=3$。\n- 用例 2：$u(x) = \\sin(7x)$，$K=5$。\n- 用例 3：$u(x) = x^{3} + e^{x}$，$K=7$。\n- 用例 4：$u(x) = 1$，$K=4$。\n- 用例 5：$u(x) = \\cos(50x)$，$K=8$。\n- 用例 6：$u(x) = x^{6} - 2x + 1$，$K=6$。\n\n对于每个用例，严格按照定义计算 $\\Delta_K(u)$ 和 $\\Sigma_K(u)$。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n[\\Delta_{K_1}(u_1), \\Sigma_{K_1}(u_1), \\Delta_{K_2}(u_2), \\Sigma_{K_2}(u_2), \\dots, \\Delta_{K_6}(u_6), \\Sigma_{K_6}(u_6)].\n$$\n没有物理单位。所有三角函数中的角度必须解释为弧度。最终输出必须是浮点数。", "solution": "用户提供了一个来自数值分析领域的问题，具体涉及谱方法和离散 de Rham 复形。任务是为一组给定的一维函数 $u(x)$ 和多项式截断阶数 $K$ 计算两个量：交换缺陷 $\\Delta_K(u)$ 和离散 Stokes 缺陷 $\\Sigma_K(u)$。\n\n### **问题验证**\n\n1.  **提取已知条件**：\n    -   **定义域**：$x \\in [-1, 1]$。\n    -   **空间**：0-形式 $u(x)$，1-形式 $v(x)\\mathrm{d}x$。\n    -   **外微分**：$\\mathrm{d}u = u'(x)\\mathrm{d}x$。\n    -   **基**：Legendre 多项式 $P_n(x)$。\n    -   **多项式空间**：$V_K = \\mathrm{span}\\{P_0, \\dots, P_K\\}$ 和 $W_{K-1} = \\mathrm{span}\\{P_0, \\dots, P_{K-1}\\}$。\n    -   **投影算子 $\\Pi_K u$**：$\\sum_{n=0}^{K} a_n P_n(x)$，其中 $a_n = \\frac{2n+1}{2} \\int_{-1}^{1} u(x) P_n(x)\\,\\mathrm{d}x$。\n    -   **交换缺陷**：$\\Delta_K(u) := \\left\\| \\mathrm{d}\\big(\\Pi_K u\\big) - \\Pi_{K-1}\\big(\\mathrm{d}u\\big) \\right\\|_{L^2([-1,1])}$。\n    -   **离散 Stokes 缺陷**：$\\Sigma_K(u) := \\left| \\int_{-1}^{1} \\Pi_{K-1}\\big(\\mathrm{d}u\\big)\\,\\mathrm{d}x - \\Big(\\big(\\Pi_K u\\big)(1) - \\big(\\Pi_K u\\big)(-1)\\Big) \\right|$。\n    -   **数值方法**：对所有积分使用 Gauss-Legendre 求积法。\n    -   **测试用例**：提供了六对 $(u(x), K)$。\n\n2.  **使用提取的已知条件进行验证**：\n    -   **科学上成立**：该问题在谱方法和间断 Galerkin 方法的理论中有充分的根据。离散 de Rham 复形的概念以及离散算子交换性质的分析是现代数值偏微分方程中的标准课题。所给定义在数学上是严谨的。\n    -   **良态问题**：对于每个测试用例，函数 $u(x)$ 都是光滑的，这确保了所有导数和积分都存在。缺陷的定义是无歧义的，对于给定的求积方案，会得到唯一的数值结果。\n    -   **客观性**：问题用精确的数学公式和定义陈述，不含任何主观性。\n    -   该问题不违反任何无效标准。使用“足够高的求积阶数”的指令是标准做法，表明实现应对数值积分误差具有鲁棒性。\n\n3.  **结论与行动**：\n    -   该问题是**有效的**。将提供一个完整的解决方案。\n\n### **解法推导**\n\n解决方案需要实现给定的定义。我们将首先根据 Legendre 展开系数推导两个缺陷的解析表达式，而这些系数本身是通过数值计算得到的。\n\n令 $u(x)$ 为给定函数，$K$ 为截断阶数。$u$ 到 $V_K$ 上的投影 $\\Pi_K u = \\sum_{n=0}^{K} a_n P_n(x)$ 的系数由下式给出\n$$a_n = \\frac{2n+1}{2} \\int_{-1}^{1} u(x) P_n(x)\\,\\mathrm{d}x, \\quad n = 0, \\dots, K.$$\n类似地，导数 $u'(x)$ 到 $W_{K-1}$ 上的投影 $\\Pi_{K-1}(u') = \\sum_{m=0}^{K-1} b_m P_m(x)$ 的系数为\n$$b_m = \\frac{2m+1}{2} \\int_{-1}^{1} u'(x) P_m(x)\\,\\mathrm{d}x, \\quad m = 0, \\dots, K-1.$$\n这些积分使用 Gauss-Legendre 求积法进行近似。令 $\\{x_i, w_i\\}_{i=1}^{N_q}$ 为足够高阶 $N_q$ 的求积点和权重。则系数计算如下：\n$$a_n \\approx \\frac{2n+1}{2} \\sum_{i=1}^{N_q} w_i u(x_i) P_n(x_i)$$\n$$b_m \\approx \\frac{2m+1}{2} \\sum_{i=1}^{N_q} w_i u'(x_i) P_m(x_i)$$\n\n**1. 交换缺陷 $\\Delta_K(u)$**\n\n交换缺陷为 $\\Delta_K(u) = \\| (\\Pi_K u)' - \\Pi_{K-1}(u') \\|_{L^2}$。令 $D(x) = (\\Pi_K u)'(x) - \\Pi_{K-1}(u')(x)$。我们需要计算 $\\|D\\|_{L^2}$。\n\n第一项是 $(\\Pi_K u)'(x) = \\left(\\sum_{n=0}^{K} a_n P_n(x)\\right)' = \\sum_{n=1}^{K} a_n P'_n(x)$。\n我们使用 Legendre 多项式恒等式：$P'_n(x) = \\sum_{k=0, n-k \\text{ odd}}^{n-1} (2k+1)P_k(x)$。\n代入此式可得：\n$$(\\Pi_K u)'(x) = \\sum_{n=1}^{K} a_n \\sum_{k=0, n-k \\text{ odd}}^{n-1} (2k+1)P_k(x) = \\sum_{l=0}^{K-1} \\left( (2l+1) \\sum_{n=l+1, n-l \\text{ odd}}^{K} a_n \\right) P_l(x).$$\n我们将 $(\\Pi_K u)'$ 的 Legendre 系数表示为 $c_l$，因此 $c_l = (2l+1) \\sum_{n=l+1, n-l \\text{ odd}}^{K} a_n$。\n\n缺陷多项式为 $D(x) = \\sum_{l=0}^{K-1} c_l P_l(x) - \\sum_{l=0}^{K-1} b_l P_l(x) = \\sum_{l=0}^{K-1} (c_l - b_l) P_l(x)$。\n$L^2$ 范数使用 Legendre 多项式的正交性 $\\int_{-1}^1 P_l(x)P_j(x)\\,\\mathrm{d}x = \\frac{2}{2l+1}\\delta_{lj}$ 计算：\n$$\\Delta_K(u)^2 = \\|D\\|_{L^2}^2 = \\int_{-1}^1 \\left(\\sum_{l=0}^{K-1} (c_l - b_l) P_l(x)\\right)^2 \\mathrm{d}x = \\sum_{l=0}^{K-1} (c_l - b_l)^2 \\frac{2}{2l+1}.$$\n因此，交换缺陷为：\n$$\\Delta_K(u) = \\sqrt{\\sum_{l=0}^{K-1} \\frac{2}{2l+1} \\left( \\left( (2l+1) \\sum_{n=l+1, n-l \\text{ odd}}^{K} a_n \\right) - b_l \\right)^2 }.$$\n\n**2. 离散 Stokes 缺陷 $\\Sigma_K(u)$**\n\nStokes 缺陷为 $\\Sigma_K(u) = \\left| \\int_{-1}^{1} \\Pi_{K-1}(u')\\,\\mathrm{d}x - \\Big((\\Pi_K u)(1) - (\\Pi_K u)(-1)\\Big) \\right|$。\n\n第一项是投影后导数的积分：\n$$\\int_{-1}^{1} \\Pi_{K-1}(u')\\,\\mathrm{d}x = \\int_{-1}^{1} \\sum_{m=0}^{K-1} b_m P_m(x)\\,\\mathrm{d}x = \\sum_{m=0}^{K-1} b_m \\int_{-1}^{1} P_m(x)\\,\\mathrm{d}x.$$\n由于性质 $\\int_{-1}^1 P_m(x)\\,\\mathrm{d}x = 2\\delta_{m0}$，该积分简化为 $2b_0$。\n\n第二项是投影后函数在边界上的取值：\n$$(\\Pi_K u)(1) - (\\Pi_K u)(-1) = \\sum_{n=0}^{K} a_n P_n(1) - \\sum_{n=0}^{K} a_n P_n(-1) = \\sum_{n=0}^{K} a_n (P_n(1) - P_n(-1)).$$\n使用性质 $P_n(1)=1$ 和 $P_n(-1)=(-1)^n$，项 $(P_n(1) - P_n(-1))$ 等于 $1 - (-1)^n$，当 $n$ 为奇数时等于 2，当 $n$ 为偶数时等于 0。\n因此，边界项简化为 $2 \\sum_{n=1, n \\text{ odd}}^{K} a_n$。\n\n综合这些结果，Stokes 缺陷由下式给出：\n$$\\Sigma_K(u) = \\left| 2b_0 - 2\\sum_{n=1, n \\text{ odd}}^{K} a_n \\right|.$$\n\n**数值策略**\n实现将遵循这些推导出的公式。将使用高阶 Gauss-Legendre 求积（例如，$N_q=200$ 个点）来计算系数 $a_n$ 和 $b_m$，以确保数值积分误差可以忽略不计。其余的计算是基于这些系数的解析计算。对于测试用例中 $u(x)$ 是一个阶数 $N \\le K$ 的多项式的情况，两个缺陷在理论上都为零。这可以作为实现正确性的验证，因为任何非零结果都将归因于浮点精度限制。", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import legval, legfit, Legendre, leggauss\nfrom typing import Callable, List, Tuple\n\ndef compute_defects(u_func: Callable[[np.ndarray], np.ndarray],\n                    u_prime_func: Callable[[np.ndarray], np.ndarray],\n                    K: int,\n                    N_q: int = 200) - Tuple[float, float]:\n    \"\"\"\n    Computes the commuting defect Delta_K and Stokes defect Sigma_K.\n\n    Args:\n        u_func: The function u(x).\n        u_prime_func: The derivative of the function, u'(x).\n        K: The truncation level for the polynomial space V_K.\n        N_q: The number of quadrature points for Gauss-Legendre integration.\n\n    Returns:\n        A tuple (Delta_K, Sigma_K).\n    \"\"\"\n\n    # 1. Setup Gauss-Legendre quadrature\n    x_q, w_q = leggauss(N_q)\n\n    # 2. Evaluate functions at quadrature points\n    u_vals = u_func(x_q)\n    u_prime_vals = u_prime_func(x_q)\n\n    # 3. Compute coefficients a_n for Pi_K(u)\n    a = np.zeros(K + 1)\n    for n in range(K + 1):\n        P_n_vals = legval(x_q, [0]*n + [1])\n        integral = np.sum(w_q * u_vals * P_n_vals)\n        a[n] = (2 * n + 1) / 2 * integral\n\n    # 4. Compute coefficients b_m for Pi_{K-1}(u')\n    b = np.zeros(K)\n    # The space is W_{K-1}, so projection is onto span{P_0, ..., P_{K-1}}\n    for m in range(K):\n        P_m_vals = legval(x_q, [0]*m + [1])\n        integral = np.sum(w_q * u_prime_vals * P_m_vals)\n        b[m] = (2 * m + 1) / 2 * integral\n\n    # 5. Compute the commuting defect Delta_K(u)\n    # Delta_K^2 = sum_{l=0}^{K-1} (2/(2l+1)) * (c_l - b_l)^2\n    # where c_l are the Legendre coeffs of (Pi_K u)'\n    \n    c = np.zeros(K)\n    for l in range(K):\n        sum_a = 0\n        # Sum over n from l+1 to K, where n-l is odd\n        for n in range(l + 1, K + 1):\n            if (n - l) % 2 == 1:\n                sum_a += a[n]\n        c[l] = (2 * l + 1) * sum_a\n\n    delta_sq = 0\n    for l in range(K):\n        delta_sq += (2 / (2 * l + 1)) * (c[l] - b[l])**2\n    delta = np.sqrt(delta_sq)\n\n    # 6. Compute the discrete Stokes defect Sigma_K(u)\n    # Sigma_K = | 2*b_0 - 2 * sum_{n odd, 1 to K} a_n |\n    \n    term1_sigma = 2 * b[0]\n\n    sum_a_odd = 0\n    for n in range(1, K + 1):\n        if n % 2 == 1:\n            sum_a_odd += a[n]\n    term2_sigma = 2 * sum_a_odd\n    \n    sigma = np.abs(term1_sigma - term2_sigma)\n\n    return delta, sigma\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        # Case 1: u(x) = e^x, K=3\n        {'u': lambda x: np.exp(x), 'u_prime': lambda x: np.exp(x), 'K': 3},\n        # Case 2: u(x) = sin(7x), K=5\n        {'u': lambda x: np.sin(7*x), 'u_prime': lambda x: 7*np.cos(7*x), 'K': 5},\n        # Case 3: u(x) = x^3 + e^x, K=7\n        {'u': lambda x: x**3 + np.exp(x), 'u_prime': lambda x: 3*x**2 + np.exp(x), 'K': 7},\n        # Case 4: u(x) = 1, K=4\n        {'u': lambda x: np.ones_like(x), 'u_prime': lambda x: np.zeros_like(x), 'K': 4},\n        # Case 5: u(x) = cos(50x), K=8\n        {'u': lambda x: np.cos(50*x), 'u_prime': lambda x: -50*np.sin(50*x), 'K': 8},\n        # Case 6: u(x) = x^6 - 2x + 1, K=6\n        {'u': lambda x: x**6 - 2*x + 1, 'u_prime': lambda x: 6*x**5 - 2, 'K': 6},\n    ]\n\n    results = []\n    # Use a high quadrature order to minimize integration error, especially for Case 5\n    quadrature_order = 400\n\n    for case in test_cases:\n        delta, sigma = compute_defects(case['u'], case['u_prime'], case['K'], N_q=quadrature_order)\n        results.extend([delta, sigma])\n\n    # Format the final output string\n    output_str = f\"[{','.join(f'{r:.10f}' for r in results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3380480"}]}