{"hands_on_practices": [{"introduction": "我们从一个基础但至关重要的练习开始：利用快速傅里叶变换（FFT）计算周期函数的导数。这个练习旨在将谱微分的核心思想——物理空间中的微分等价于傅里叶空间中的乘法——转化为具体的代码实现。通过将数值结果与精确的解析解进行比较，你可以亲手验证谱方法对于光滑周期函数的卓越精度，并为更复杂的应用打下坚实的基础 [@problem_id:3387455]。", "problem": "考虑区间 $[0,2\\pi)$ 上的一个周期性网格，其定义为 $x_j = \\frac{2\\pi j}{N}$，其中 $j \\in \\{0,1,\\dots,N-1\\}$，$N \\in \\mathbb{N}$，且角度以弧度为单位。设所有网格点上的值为 $u_j = \\sin(5 x_j)$。目标是使用快速傅里叶变换 (FFT) 计算离散导数 $\\mathbf{v} = D \\mathbf{u}$，其中 $D$ 表示作用于 $2\\pi$ 周期函数网格值上的傅里叶微分矩阵。推导和计算必须基于第一性原理：从等距网格上 $2\\pi$ 周期三角插值多项式的离散傅里叶变换的定义出发，并且只使用傅里叶级数和线性算子的基本性质。问题陈述中不允许使用任何预先推导出的微分公式。\n\n你的任务是编写一个完整的、可运行的程序，该程序：\n- 构建网格 $x_j = \\frac{2\\pi j}{N}$ 和数据 $u_j = \\sin(5 x_j)$。\n- 通过将 $\\mathbf{u}$ 变换到傅里叶空间，在该基底下应用与周期性设置一致的微分算子，然后变换回物理空间，来计算傅里叶微分矩阵 $D$ 对 $\\mathbf{u}$ 的作用。\n- 数值上验证计算出的离散导数 $v_j$ 与解析导数 $5 \\cos(5 x_j)$ 在机器精度内相等，并报告每个测试用例的最大绝对误差 $\\max_j |v_j - 5\\cos(5 x_j)|$。\n\n使用弧度制角度。不涉及物理单位。答案必须表示为实值浮点数。\n\n测试套件：\n- 使用网格尺寸集合 $N \\in \\{11, 12, 64, 128, 1001\\}$ 来测试不同情况，包括允许的最小网格 ($N=11$)、带有奈奎斯特模式的偶数网格 ($N=12$)，以及分辨率较高的大网格 ($N=64, N=128, N=1001$)。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含测试套件的最大绝对误差，格式为方括号括起来的逗号分隔列表。例如，输出必须为 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_5]$ 形式，其中每个 $\\text{result}_i$ 是对应于顺序 $[11,12,64,128,1001]$ 中 $N$ 的最大绝对误差。", "solution": "该问题被评估为有效。它在科学上基于傅里叶分析和谱方法的原理，是适定的，提供了所有必要信息，并且表述客观。解法如下。\n\n问题的核心是使用傅里叶谱方法计算周期性网格上函数 $u(x)$ 的导数。该方法依赖于用三角多项式表示函数，然后在频域中执行微分，在频域中微分简化为乘法运算。该过程涉及三个主要步骤：将函数从物理域变换到频域，在频域中应用微分算子，然后将结果变换回物理域。\n\n设定义域为区间 $[0, 2\\pi)$，由 $N$ 个等距点 $x_j = \\frac{2\\pi j}{N}$（其中 $j \\in \\{0, 1, \\dots, N-1\\}$）离散化。此网格上的函数值为 $u_j = u(x_j)$。对于本问题，$u(x) = \\sin(5x)$，所以 $u_j = \\sin(5x_j)$。\n\n**原理 1：三角插值**\n\n这 $N$ 个数据点 $(x_j, u_j)$ 唯一确定一个次数至多为 $\\lfloor N/2 \\rfloor$ 的三角插值多项式 $p(x)$，使得对所有 $j$ 都有 $p(x_j) = u_j$。该插值多项式可以表示为有限复傅里叶级数：\n$$\np(x) = \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k e^{ikx}\n$$\n其中 $\\mathbb{K}_N$ 是适用于尺寸为 $N$ 的网格的整数波数集合。\n当 $N$ 为奇数时，$\\mathbb{K}_N = \\{-(N-1)/2, \\dots, (N-1)/2\\}$。\n当 $N$ 为偶数时，$\\mathbb{K}_N = \\{-N/2+1, \\dots, N/2\\}$。在网格上，模式 $k=-N/2$ 与 $k=N/2$ 发生混叠，它们通常被合并成一个单一的余弦项。\n\n复傅里叶系数 $\\hat{u}_k$ 通过离散傅里叶变换 (DFT) 与网格值 $u_j$ 相关联。标准定义是：\n$$\n\\hat{u}_k = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-ikx_j} = \\frac{1}{N} \\sum_{j=0}^{N-1} u_j e^{-i k \\frac{2\\pi j}{N}}\n$$\n\n**原理 2：傅里叶域中的微分**\n\n傅里叶表示的主要优点是，物理空间中函数的微分对应于频域中其傅里叶系数乘以 $ik$ 的简单运算。对插值多项式 $p(x)$ 关于 $x$ 求导得出：\n$$\nv(x) = p'(x) = \\frac{d}{dx} \\left( \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k e^{ikx} \\right)\n$$\n根据线性性质，我们可以交换微分和求和的顺序：\n$$\nv(x) = \\sum_{k \\in \\mathbb{K}_N} \\hat{u}_k \\frac{d}{dx} (e^{ikx}) = \\sum_{k \\in \\mathbb{K}_N} (ik) \\hat{u}_k e^{ikx}\n$$\n这表明导数的傅里叶系数（记作 $\\hat{v}_k$）由下式给出：\n$$\n\\hat{v}_k = ik \\hat{u}_k\n$$\n然后，通过计算这个新的级数可以找到网格上的导数值 $v_j = v(x_j)$，这等价于对系数 $\\hat{v}_k$ 执行离散傅里叶逆变换 (IDFT)。\n\n**使用快速傅里叶变换 (FFT) 的算法实现**\n\nDFT 和 IDFT 可以使用 FFT 算法高效计算。步骤如下：\n\n1.  **正向变换**：给定函数值向量 $\\mathbf{u} = [u_0, u_1, \\dots, u_{N-1}]$，使用 FFT 算法计算其 DFT。设结果为 $\\hat{U} = \\text{fft}(\\mathbf{u})$。像 NumPy 这样的标准数值库计算 $\\hat{U}_m = \\sum_{j=0}^{N-1} u_j e^{-i 2\\pi mj / N}$，其中 $m \\in \\{0, \\dots, N-1\\}$。这与我们的物理系数的关系是 $\\hat{u}_k = \\frac{1}{N}\\hat{U}_k$，其中 FFT 索引 $m$ 映射到物理波数 $k$。\n\n2.  **波数向量**：需要构建与 FFT 输出排序相对应的物理波数向量 $k$。对于一个 $N$ 点 FFT，当 $N$ 为偶数时，波数为 $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$；当 $N$ 为奇数时，波数为 $k \\in \\{0, 1, \\dots, (N-1)/2, -(N-1)/2, \\dots, -1\\}$。这个向量可以使用库函数如 `numpy.fft.fftfreq(N) * N` 轻松生成。\n\n3.  **应用微分算子**：导数的傅里叶系数 $\\hat{v}_k$ 通过逐元素相乘计算得出：$\\hat{v}_k = ik \\hat{u}_k$。以 FFT 的未归一化系数表示，即为 $\\hat{V}_k = ik \\hat{U}_k$。当 $N$ 为偶数时，在奈奎斯特频率处会出现一个特殊情况，该频率对应于波数 $k=N/2$（或根据约定为 $k=-N/2$）。实值信号在网格上的插值多项式对于此模式仅包含 $\\cos((N/2)x)$ 分量。此余弦函数的导数 $-(N/2)\\sin((N/2)x)$ 在所有网格点 $x_j$ 处均为零。因此，对于一个稳健的微分算法，奈奎斯特频率系数的乘数必须设置为 $0$。\n\n4.  **逆变换**：通过对修改后的系数 $\\hat{V}$ 应用逆 FFT，可以获得网格上的导数值 $\\mathbf{v} = [v_0, v_1, \\dots, v_{N-1}]$：$\\mathbf{v} = \\text{ifft}(\\hat{V})$。由于实函数的导数是实数，结果中任何残留的虚部都是由浮点误差引起的，应予以舍弃。\n\n**验证**\n将计算出的离散导数 $v_j$ 与 $u(x) = \\sin(5x)$ 的解析导数 $u'(x) = 5\\cos(5x)$ 进行比较。计算最大绝对误差 $\\max_j |v_j - 5\\cos(5x_j)|$。由于函数 $\\sin(5x)$ 是带限的，其波数为 $k=5$，并且所有测试用例都使用 $N > 2k = 10$，因此三角插值多项式与函数本身完全相同。因此，傅里叶微分在机器精度内应该是精确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the derivative of u(x) = sin(5x) on a periodic grid\n    using the Fourier spectral method for a suite of grid sizes N,\n    and reports the maximum absolute error against the analytical derivative.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [11, 12, 64, 128, 1001]\n\n    results = []\n    \n    for N in test_cases:\n        # Step 1: Construct the grid and the function data.\n        # Grid points on [0, 2*pi).\n        x = 2 * np.pi * np.arange(N) / N\n        \n        # Function values on the grid for u(x) = sin(5x).\n        u = np.sin(5 * x)\n        \n        # Analytical derivative u'(x) = 5*cos(5x) on the grid for verification.\n        u_analytic_deriv = 5 * np.cos(5 * x)\n        \n        # Step 2: Transform to Fourier space using FFT.\n        # This gives the un-normalized Fourier coefficients.\n        u_hat = np.fft.fft(u)\n        \n        # Step 3: Apply the differentiation operator in Fourier space.\n        \n        # Generate the vector of physical wavenumbers corresponding to the FFT output array.\n        # np.fft.fftfreq(N) returns frequencies f_k = k/N.\n        # Multiplying by N gives the integer wavenumbers k.\n        wavenumbers = np.fft.fftfreq(N) * N\n        \n        # The differentiation operator in Fourier space is multiplication by ik.\n        d_hat = 1j * wavenumbers\n        \n        # For even N, the Nyquist frequency component requires special handling.\n        # The derivative of the cos(N/2 * x) basis function is zero on the grid points.\n        # Therefore, the corresponding multiplier must be set to 0.\n        # In numpy's fftfreq, the Nyquist frequency corresponds to index N//2.\n        if N % 2 == 0:\n            d_hat[N // 2] = 0.0\n            \n        # Apply the differentiation operator.\n        v_hat = d_hat * u_hat\n        \n        # Step 4: Transform back to physical space using inverse FFT.\n        v = np.fft.ifft(v_hat)\n        \n        # The result should be real. We take the real part to discard\n        # any small imaginary noise from floating-point inaccuracies.\n        v_real = v.real\n        \n        # Step 5: Verify the result by comparing with the analytical derivative.\n        # Calculate the maximum absolute error across all grid points.\n        max_error = np.max(np.abs(v_real - u_analytic_deriv))\n        \n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # The map function converts each float error into a string for joining.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3387455"}, {"introduction": "在掌握了基本的微分实现后，我们将深入探索傅里叶微分矩阵 $D$ 作为一个线性算子的内在属性。本练习引导你分析 $D$ 及其二阶形式 $D^2$ 的零空间与值域，这些是理解微分方程解的存在性与唯一性的关键 [@problem_id:3387459]。通过将这些理论性质应用于求解周期性泊松方程 $D^2 \\mathbf{u} = \\mathbf{f}$ 的具体问题，你将学会如何通过施加恰当的约束来获得唯一解，并理解这些约束对解空间的影响。", "problem": "考虑在区间 $[0,2\\pi)$ 上的一个具有 $N$ 个点的等距周期网格，其中 $N$ 为偶数，网格点为 $x_{j} = \\frac{2\\pi j}{N}$，$j=0,1,\\dots,N-1$。通过网格函数 $\\mathbf{u}$ 的系数 $\\,\\hat{u}_{k}$ 定义离散傅里叶变换 (DFT)，满足 $u(x_{j}) = \\sum_{k=-N/2+1}^{N/2} \\hat{u}_{k} \\exp(\\mathrm{i} k x_{j})$。按照惯例，对于偶数 $N$，奈奎斯特模式 $k=N/2$ 以标准方式处理，以确保表示的一致性，并且当 $\\hat{u}_{-k}=\\overline{\\hat{u}_{k}}$ 时，$u(x)$ 是实值函数。傅里叶微分矩阵 $D$ 的定义是：将 $D$ 应用于 $\\mathbf{u}$ 相当于在傅里叶空间中将每个模式乘以 $\\mathrm{i}k$。而二阶傅里叶微分矩阵 $D^{2}$ 相当于将每个模式乘以 $-k^{2}$。\n\n从这些定义和周期性设置出发：\n\n- 从第一性原理出发，推导作用于周期网格上截断傅里叶基表示的网格函数上的 $D$ 和 $D^{2}$ 的零空间和值域。\n- 提出并证明一组关于 $\\mathbf{u}$ 的线性约束条件，使得当 $\\mathbf{f}$ 位于 $D^{2}$ 的值域内时，泊松型问题 $D^{2} \\mathbf{u} = \\mathbf{f}$ 的反演是唯一的。具体来说，使用约束条件来固定 $\\mathbf{u}$ 的均值并抑制其一次谐波，即强制 $\\mathbf{u}$ 在 $k=0$ 和 $k=\\pm 1$ 处的傅里叶系数为零。\n- 解释这些约束如何影响反问题的可解性和可辨识性，描述在这些约束下，$D^{2} \\mathbf{u}$ 能够匹配和不能匹配 $\\mathbf{f}$ 的哪些分量。\n\n然后，对于具体情况 $N=8$，角度以弧度为单位，数据为\n$$\nf(x) = \\cos(x) + 2\\cos(2x) - 3,\n$$\n计算在 $k=0$ 和 $k=\\pm 1$ 处 $\\mathbf{u}$ 的傅里叶系数为零的约束条件下，通过求解 $D^{2}\\mathbf{u} = \\mathbf{f}$ 得到的约束解 $\\mathbf{u}$ 在网格点 $x_{2}=\\frac{2\\pi\\cdot 2}{8}$ 处的值。需要理解的是，该方程是在强制施加这些约束的子空间上一致求解的。将最终数值答案四舍五入到四位有效数字。", "solution": "该问题要求分析周期网格上的傅里叶微分矩阵、泊松型方程的可解性，并进行一个具体的数值计算。我们将依次处理每个部分，首先从微分算子的性质开始。\n\n一个定义在点 $x_j = \\frac{2\\pi j}{N}$（$j=0, 1, \\dots, N-1$）上的网格函数 $\\mathbf{u}$，可以通过其离散傅里叶变换 (DFT) 系数 $\\hat{u}_k$ 由以下合成公式表示：\n$$\nu(x_j) = \\sum_{k=-N/2+1}^{N/2} \\hat{u}_k \\exp(\\mathrm{i} k x_j)\n$$\n复指数集合 $\\{\\exp(\\mathrm{i} k x)\\}_{k=-N/2+1}^{N/2}$ 构成了该网格上函数的一个正交基。一阶傅里叶微分矩阵 $D$ 对网格函数 $\\mathbf{u}$ 的作用，在傅里叶域中定义为将每个系数 $\\hat{u}_k$ 乘以 $\\mathrm{i}k$。如果 $\\mathbf{v} = D\\mathbf{u}$，其傅里叶系数为 $\\hat{v}_k = \\mathrm{i}k \\hat{u}_k$。类似地，对于二阶微分矩阵 $D^2$，如果 $\\mathbf{w} = D^2 \\mathbf{u}$，其傅里叶系数为 $\\hat{w}_k = (\\mathrm{i}k)^2 \\hat{u}_k = -k^2 \\hat{u}_k$。\n\n**$D$ 和 $D^2$ 的零空间和值域**\n\n线性算子的零空间由所有被映射到零向量的向量组成。对于算子 $D$，我们寻找满足 $D\\mathbf{u}=0$ 的函数 $\\mathbf{u}$。在傅里叶空间中，这意味着结果函数的所有系数都为零：$\\hat{v}_k = \\mathrm{i}k \\hat{u}_k = 0$，对于指定范围内的所有 $k$。\n对于任何 $k \\neq 0$，方程 $\\mathrm{i}k \\hat{u}_k = 0$ 意味着 $\\hat{u}_k = 0$。\n对于 $k=0$，方程变为 $\\mathrm{i}(0) \\hat{u}_0 = 0$，这对任何 $\\hat{u}_0$ 的值都成立。\n因此，$D$ 的零空间包含所有只有 $k=0$ 的傅里叶系数可以非零的函数 $\\mathbf{u}$。$k=0$ 对应的基函数是 $\\exp(\\mathrm{i} \\cdot 0 \\cdot x_j) = 1$。所以，$D$ 的零空间是网格上的常数函数集合。这是一个由常数向量 $(1, 1, \\dots, 1)^T$ 张成的一维空间。\n\n$D$ 的值域是所有满足 $\\mathbf{v}=D\\mathbf{u}$（对于某个函数 $\\mathbf{u}$）的函数 $\\mathbf{v}$ 的集合。在傅里叶空间中，这对应于所有可能的系数向量 $\\{\\hat{v}_k\\}$ 的集合。由于 $\\hat{v}_k = \\mathrm{i}k \\hat{u}_k$，对于 $k=0$，我们有 $\\hat{v}_0 = \\mathrm{i}(0)\\hat{u}_0 = 0$。这意味着 $D$ 的值域中的任何函数都必须具有零均值（其 $k=0$ 的傅里叶系数必须为零）。对于任何 $k \\neq 0$，我们可以找到 $\\hat{u}_k = \\hat{v}_k / (\\mathrm{i}k)$。因此，任何满足 $\\hat{v}_0=0$ 的函数 $\\mathbf{v}$ 都在 $D$ 的值域中。$D$ 的值域是所有具有零均值的网格函数的空间，这是由基函数 $\\{\\exp(\\mathrm{i} k x_j)\\}$（其中 $k \\in \\{-N/2+1, \\dots, N/2\\}$ 且 $k \\neq 0$）张成的子空间。该空间的维度为 $N-1$。\n\n对于二阶算子 $D^2$，我们寻找满足 $D^2\\mathbf{u}=0$ 的函数 $\\mathbf{u}$。在傅里叶空间中，即为对所有 $k$ 有 $-k^2 \\hat{u}_k = 0$。\n与 $D$ 的情况类似，对于任何 $k \\neq 0$，有 $-k^2 \\neq 0$，所以必须有 $\\hat{u}_k = 0$。\n对于 $k=0$，方程为 $-(0)^2 \\hat{u}_0 = 0$，这对任何 $\\hat{u}_0$ 都成立。\n因此，$D^2$ 的零空间与 $D$ 的零空间相同：即网格上常数函数组成的一维空间。\n\n$D^2$ 的值域包含所有满足 $\\mathbf{w}=D^2\\mathbf{u}$ 的函数 $\\mathbf{w}$。在傅里叶空间中，$\\hat{w}_k = -k^2 \\hat{u}_k$。对于 $k=0$，这意味着 $\\hat{w}_0 = 0$。对于任何 $k \\neq 0$，我们可以找到 $\\hat{u}_k = -\\hat{w}_k/k^2$。因此，任何满足 $\\hat{w}_0=0$ 的函数 $\\mathbf{w}$ 都在 $D^2$ 的值域中。$D^2$ 的值域与 $D$ 的值域相同：即所有具有零均值的网格函数的空间。\n\n**泊松问题 $D^2 \\mathbf{u} = \\mathbf{f}$ 的约束条件**\n\n方程 $D^2 \\mathbf{u} = \\mathbf{f}$ 在傅里叶空间中转化为以下代数方程组：\n$$\n-k^2 \\hat{u}_k = \\hat{f}_k, \\quad \\text{对于 } k = -N/2+1, \\dots, N/2.\n$$\n对于 $k=0$，该方程变为 $0 \\cdot \\hat{u}_0 = \\hat{f}_0$。为了使解存在，我们必须满足相容性条件 $\\hat{f}_0 = 0$，这意味着强迫函数 $\\mathbf{f}$ 必须具有零均值。如果满足此条件，方程 $0 = 0$ 不提供关于 $\\hat{u}_0$ 的任何信息，$\\hat{u}_0$ 仍然是任意的。这种任意性对应于这样一个事实：如果 $\\mathbf{u}$ 是一个解，那么对于任何常数 $C$，$\\mathbf{u}+C$ 也是一个解，因为 $D^2(\\mathbf{u}+C) = D^2\\mathbf{u} + D^2C = D^2\\mathbf{u} + 0 = \\mathbf{f}$。\n为确保解的唯一性，我们必须施加一个约束来固定 $\\hat{u}_0$ 的值。问题建议了约束条件 $\\hat{u}_0 = 0$，这将解 $\\mathbf{u}$ 的均值设为零。在满足相容性条件 $\\hat{f}_0=0$ 的前提下，这是保证周期域上泊松方程唯一解的标准且充分的条件。\n\n问题进一步建议了对 $k = \\pm 1$ 施加约束 $\\hat{u}_{k}=0$。这些约束对于使算子 $D^2$ 在零均值函数空间上可逆并非必要。该算子在该空间上已经可逆。然而，在各种物理或工程问题（例如，流体力学、弹性力学）中，人们可能希望在更受限的子空间内找到解。强制一次谐波系数为零会抑制解中“最慢”的非恒定模式。如果所建物理模型具有排除此类模式的特性（例如，通过固定系统的总动量或质心），则可以证明这些约束是合理的。\n\n**约束下的可解性与可辨识性**\n\n当在约束条件 $\\hat{u}_0=0$ 和 $\\hat{u}_{\\pm 1}=0$ 下求解 $D^2 \\mathbf{u} = \\mathbf{f}$ 时，我们采用以下步骤。解 $\\mathbf{u}$ 由其傅里叶系数 $\\hat{u}_k$ 定义：\n1. 对于 $k \\in \\{0, 1, -1\\}$，我们强制执行约束：$\\hat{u}_0 = 0$ 和 $\\hat{u}_{\\pm 1} = 0$。\n2. 对于所有其他波数 $k \\notin \\{0, 1, -1\\}$，我们求解方程 $-k^2 \\hat{u}_k = \\hat{f}_k$，得到 $\\hat{u}_k = -\\frac{\\hat{f}_k}{k^2}$。\n\n此过程唯一地定义了一个解 $\\mathbf{u}$。我们来检验这个解满足的方程。$D^2 \\mathbf{u}$ 的傅里叶系数是 $\\widehat{(D^2 \\mathbf{u})}_k = -k^2 \\hat{u}_k$。\n- 对于 $k \\in \\{0, 1, -1\\}$，由于 $\\hat{u}_k=0$，我们有 $\\widehat{(D^2 \\mathbf{u})}_k = 0$。\n- 对于 $k \\notin \\{0, 1, -1\\}$，我们有 $\\widehat{(D^2 \\mathbf{u})}_k = -k^2 \\left(-\\frac{\\hat{f}_k}{k^2}\\right) = \\hat{f}_k$。\n\n这意味着所得函数 $D^2 \\mathbf{u}$ 不等于 $\\mathbf{f}$，而是 $\\mathbf{f}$ 的一个投影。具体来说，$D^2 \\mathbf{u}$ 在除 $k=0$ 和 $k=\\pm 1$ 之外的所有傅里叶模式上都与 $\\mathbf{f}$ 匹配。在这些约束下，$D^2 \\mathbf{u}$ 无法匹配 $\\mathbf{f}$ 中对应于常数项（均值）和一次谐波（$\\cos(x)$、$\\sin(x)$）的分量。在反问题的背景下，人们可能试图通过将模型输出 $D^2 \\mathbf{u}$ 与测量数据 $\\mathbf{f}$ 匹配来推断系统属性，这时，任何仅影响输出均值或一次谐波的系统方面都将是不可辨识的。这些约束有效地从可拟合的数据和解空间中滤除了这些分量。\n\n**对于 $N=8$ 的数值计算**\n\n给定 $N=8$ 和强迫函数 $f(x) = \\cos(x) + 2\\cos(2x) - 3$。网格点为 $x_j = \\frac{2\\pi j}{8} = \\frac{\\pi j}{4}$。波数的范围是 $k \\in \\{-3, -2, -1, 0, 1, 2, 3, 4\\}$。\n\n首先，我们求 $f(x)$ 的傅里叶系数 $\\hat{f}_k$。我们使用欧拉公式 $e^{\\mathrm{i}\\theta} = \\cos(\\theta) + \\mathrm{i}\\sin(\\theta)$，它给出 $\\cos(\\theta) = \\frac{1}{2}(e^{\\mathrm{i}\\theta} + e^{-\\mathrm{i}\\theta})$。\n$$\nf(x) = \\frac{1}{2}(e^{\\mathrm{i}x} + e^{-\\mathrm{i}x}) + 2 \\cdot \\frac{1}{2}(e^{\\mathrm{i}2x} + e^{-\\mathrm{i}2x}) - 3e^{\\mathrm{i}0x}\n$$\n$$\nf(x) = -3e^{\\mathrm{i}0x} + \\frac{1}{2}e^{\\mathrm{i}x} + \\frac{1}{2}e^{-\\mathrm{i}x} + 1e^{\\mathrm{i}2x} + 1e^{-\\mathrm{i}2x}\n$$\n在 $f$ 的这种连续表示中出现的最高波数是 $k=2$。由于这小于奈奎斯特波数 $N/2 = 4$，在网格上对 $f(x)$ 进行采样时不会发生混叠。离散傅里叶系数 $\\hat{f}_k$ 与连续傅里叶级数的系数相同。\n非零系数为：\n- $\\hat{f}_0 = -3$\n- $\\hat{f}_1 = \\frac{1}{2}$ 和 $\\hat{f}_{-1} = \\frac{1}{2}$\n- $\\hat{f}_2 = 1$ 和 $\\hat{f}_{-2} = 1$\n所有其他系数 $\\hat{f}_k$（对于 $k \\in \\{-3, 3, 4\\}$）均为零。\n\n现在，我们计算约束解 $\\mathbf{u}$ 的系数 $\\hat{u}_k$。\n- 约束条件直接规定了 $\\hat{u}_0 = 0$，$\\hat{u}_1 = 0$ 和 $\\hat{u}_{-1} = 0$。\n- 对于 $k=\\pm 2$，我们求解 $\\hat{u}_k = -\\frac{\\hat{f}_k}{k^2}$：\n  - $\\hat{u}_2 = -\\frac{\\hat{f}_2}{2^2} = -\\frac{1}{4}$\n  - $\\hat{u}_{-2} = -\\frac{\\hat{f}_{-2}}{(-2)^2} = -\\frac{1}{4}$\n- 对于 $k \\in \\{-3, 3, 4\\}$，由于 $\\hat{f}_k=0$，我们有 $\\hat{u}_k = -\\frac{0}{k^2} = 0$。\n\n解 $\\mathbf{u}$ 的唯一非零系数是 $\\hat{u}_2 = -1/4$ 和 $\\hat{u}_{-2} = -1/4$。\n我们在网格上重构解 $u(x)$：\n$$\nu(x_j) = \\sum_{k=-3}^{4} \\hat{u}_k e^{\\mathrm{i} k x_j} = \\hat{u}_{-2}e^{-\\mathrm{i}2x_j} + \\hat{u}_2 e^{\\mathrm{i}2x_j}\n$$\n$$\nu(x_j) = -\\frac{1}{4} e^{-\\mathrm{i}2x_j} - \\frac{1}{4} e^{\\mathrm{i}2x_j} = -\\frac{1}{4} (e^{\\mathrm{i}2x_j} + e^{-\\mathrm{i}2x_j}) = -\\frac{1}{2} \\cos(2x_j)\n$$\n我们需要计算 $\\mathbf{u}$ 在网格点 $x_2$ 处的值。\n$$\nx_2 = \\frac{2\\pi \\cdot 2}{8} = \\frac{4\\pi}{8} = \\frac{\\pi}{2}\n$$\n将这个值代入 $u(x)$ 的表达式中：\n$$\nu(x_2) = u(\\frac{\\pi}{2}) = -\\frac{1}{2} \\cos\\left(2 \\cdot \\frac{\\pi}{2}\\right) = -\\frac{1}{2} \\cos(\\pi)\n$$\n因为 $\\cos(\\pi) = -1$，所以值为：\n$$\nu(\\frac{\\pi}{2}) = -\\frac{1}{2}(-1) = \\frac{1}{2} = 0.5\n$$\n问题要求将答案四舍五入到四位有效数字。这得到 $0.5000$。", "answer": "$$\n\\boxed{0.5000}\n$$", "id": "3387459"}, {"introduction": "微分的“逆运算”是积分，但在数值上实现稳定的积分算子比微分更具挑战性，因为它涉及到如何处理微分算子的零空间（即常数模式）。本练习将指导你构建一个谱积分矩阵 $I$，它作为微分矩阵 $D$ 在零均值函数子空间上的伪逆 [@problem_id:3387474]。你将学习如何为一阶微分方程 $u_x = f$ 建立一个稳定的求解器，并理解周期性问题的相容性条件（即 $f$ 的均值必须为零）为何如此重要。", "problem": "考虑周期区间 $[0,2\\pi)$ 和一个等距配置网格 $x_j = \\frac{2\\pi j}{N}$，其中 $j = 0,1,\\ldots,N-1$。令 $\\mathbf{u} \\in \\mathbb{C}^N$ 是一个足够光滑的 $2\\pi$-周期函数 $u(x)$ 的节点值向量 $u_j = u(x_j)$。离散傅里叶变换 (DFT) 提供了用复傅里叶模态表示 $\\mathbf{u}$ 的一种方法。使用以下基本事实作为推导基础：\n\n- 复指数函数 $e^{\\mathrm{i} k x}$ 是微分算子的特征函数，其特征值为 $\\mathrm{i} k$，即对于任意整数 $k$，都有 $\\frac{d}{dx}\\left(e^{\\mathrm{i} k x}\\right) = \\mathrm{i} k e^{\\mathrm{i} k x}$。\n- 在使用离散傅里叶变换 (DFT) 对等距网格进行周期离散化时，微分在傅里叶空间中起对角作用，其对角线上的元素由相应的整数波数确定。\n- 快速傅里叶变换 (FFT) 为 $N$ 点序列的 DFT 及其逆变换提供了一种数值稳定且精确（在浮点精度范围内）的实现。\n\n基于以上事实，通过在傅里叶空间中对角化微分作用并变换回物理空间，推导出将节点值 $\\mathbf{u}$ 映射到节点导数 $u_x$ 的傅里叶微分矩阵 $D \\in \\mathbb{C}^{N \\times N}$。接下来，推导一个谱积分矩阵 $I \\in \\mathbb{C}^{N \\times N}$，它在零均值子空间上是 $D$ 的左逆，即 $ID$ 对所有与常数模态正交的分量起单位作用，并湮没常数模态。然后，为周期函数 $u$ 的线性方程 $u_x = f$ 构建一个稳定求解器，方法是通过投影掉零波数（$k=0$ 模态）来强制满足周期性的相容性条件，并一致地选择 $\\mathbf{u}$ 的均值。\n\n您必须实现一个完整的程序，该程序：\n- 对于给定的 $N$，使用 DFT 及其逆变换构建傅里叶微分矩阵 $D$ 和谱积分矩阵 $I$，除了上述基本事实外，不依赖任何快捷公式。\n- 通过在积分前于傅里叶空间中显式地投影掉 $k=0$ 模态，实现一个求解 $u_x = f$ 的稳定求解器，从而得到零均值周期解。\n- 验证性质 $ID\\mathbf{u} = \\mathbf{u} - \\overline{\\mathbf{u}}$，其中 $\\overline{\\mathbf{u}}$ 表示其所有元素均等于 $\\mathbf{u}$ 的节点值平均值的常数向量。\n- 当 $\\mathbf{f}$ 具有非零均值时，通过报告残差 $\\|D\\mathbf{u} - \\mathbf{f}\\|_\\infty$ 来测试求解器的敏感性。\n\n所有角度必须以弧度为单位。程序必须在区间 $[0,2\\pi)$ 上评估以下测试套件：\n\n- 测试 1（复合检验）：$N = 16$，$u(x) = 2 + \\cos(3x)$。计算 $ID\\mathbf{u}$ 和 $\\mathbf{u} - \\overline{\\mathbf{u}}$ 之间的最大绝对误差，以单个浮点数形式报告。\n- 测试 2（零均值右端项）：$N = 32$，$f(x) = -3 \\sin(3x)$。通过稳定求解器求解周期函数 $u$ 的方程 $u_x = f$。以单个浮点数形式报告 $\\|D\\mathbf{u} - \\mathbf{f}\\|_\\infty$。\n- 测试 3（非零均值右端项）：$N = 32$，$f(x) = 1 + \\sin(x)$。使用相同的稳定求解器求解。以单个浮点数形式报告 $\\|D\\mathbf{u} - \\mathbf{f}\\|_\\infty$，该值量化了对 $\\mathbf{f}$ 的非零均值的敏感性。\n- 测试 4（零右端项）：$N = 10$，$f(x) \\equiv 0$。使用稳定求解器求解，并以单个浮点数形式报告 $\\|D\\mathbf{u} - \\mathbf{f}\\|_\\infty$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[$\\text{result1}$,$\\text{result2}$,$\\text{result3}$,$\\text{result4}$]\"）。每个结果都必须是在指定网格上以弧度计算的浮点数。", "solution": "该问题要求推导并实现用于区间 $[0, 2\\pi)$ 上周期函数的傅里叶谱微分和积分方法。这将通过利用离散傅里叶变换 (DFT) 的性质来完成，DFT 可以对角化微分算子。\n\n### 理论基础\n\n设 $u(x)$ 是一个在等距网格 $x_j = \\frac{2\\pi j}{N}$（其中 $j = 0, 1, \\ldots, N-1$）上采样的 $2\\pi$-周期函数。其节点值向量为 $\\mathbf{u} = [u(x_0), \\ldots, u(x_{N-1})]^T \\in \\mathbb{C}^N$。\n\nDFT 及其逆变换 (IDFT) 提供了函数在物理空间（节点值 $\\mathbf{u}$）和频率空间（傅里叶系数 $\\hat{\\mathbf{u}}$）表示之间的转换。这些变换定义如下：\n$$\n\\hat{u}_k = \\sum_{j=0}^{N-1} u_j e^{-2\\pi\\mathrm{i}jk/N} \\quad (\\text{DFT})\n$$\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k e^{2\\pi\\mathrm{i}jk/N} \\quad (\\text{IDFT})\n$$\n我们使用 `numpy.fft` 库的记法，其中 IDFT 包含 $1/N$ 缩放因子。该关系可以用 DFT 矩阵算子 $\\mathcal{F}$ 及其逆 $\\mathcal{F}^{-1}$ 来表示，即 $\\hat{\\mathbf{u}} = \\mathcal{F}\\mathbf{u}$ 和 $\\mathbf{u} = \\mathcal{F}^{-1}\\hat{\\mathbf{u}}$。\n\n一个关键原理是，物理空间中的微分对应于频率空间中的乘法。单个傅里叶模态 $e^{\\mathrm{i}kx}$ 的导数是 $\\frac{d}{dx} e^{\\mathrm{i}kx} = \\mathrm{i}k e^{\\mathrm{i}kx}$。对于与网格对应的离散波数集合 $k_{eff}$，其导数的节点值 $u_x$ 可以通过以下步骤获得：\n1. 将 $\\mathbf{u}$ 变换到频率空间：$\\hat{\\mathbf{u}} = \\mathcal{F}\\mathbf{u}$。\n2. 将每个傅里叶系数 $\\hat{u}_k$ 乘以其对应的缩放波数 $\\mathrm{i}k_{eff, k}$。\n3. 变换回物理空间：$\\mathbf{u}_x = \\mathcal{F}^{-1}(\\mathrm{i}k_{eff} \\odot \\hat{\\mathbf{u}})$，其中 $\\odot$ 表示逐元素乘法。\n\n对于一个 $N$ 点的 DFT，其有效整数波数向量 $k_{eff}$ 在 $N$ 为偶数时由 $k_{eff} = [0, 1, \\ldots, N/2-1, -N/2, \\ldots, -1]$ 给出，在 $N$ 为奇数时也有类似的序列。这个序列可以方便地通过 `numpy.fft.fftfreq(N) * N` 获得。\n\n### 推导过程\n\n**1. 傅里叶微分矩阵 $D$**\n\n谱微分的过程可以封装在一个矩阵 $D \\in \\mathbb{C}^{N \\times N}$ 中，使得 $\\mathbf{u}_x = D\\mathbf{u}$。根据上述步骤，我们可以写出：\n$$\nD \\mathbf{u} = \\mathcal{F}^{-1}(\\Lambda_D (\\mathcal{F}\\mathbf{u})) = (\\mathcal{F}^{-1} \\Lambda_D \\mathcal{F}) \\mathbf{u}\n$$\n其中 $\\Lambda_D$ 是一个对角矩阵，其对角线上的元素是微分的特征值：$(\\Lambda_D)_{kk} = \\mathrm{i}k_{eff, k}$。因此，微分矩阵为 $D = \\mathcal{F}^{-1} \\Lambda_D \\mathcal{F}$。\n为了构造这个矩阵，我们可以将微分算子应用于每个标准基向量 $e_j \\in \\mathbb{R}^N$（一个在索引 $j$ 处为 1，其余处为 0 的向量）。$D$ 的第 $j$ 列就是 $D e_j$。\n\n**2. 谱积分矩阵 $I$**\n\n为了求解微分方程 $u_x = f$，我们可以在频率空间中执行逆运算。方程变为 $\\mathrm{i}k_{eff,k} \\hat{u}_k = \\hat{f}_k$，这意味着 $\\hat{u}_k = \\frac{\\hat{f}_k}{\\mathrm{i}k_{eff,k}}$。\n对于 $k=0$ 模态（均值），由于 $k_{eff,0}=0$，这个除法是奇异的。\n为了使周期解存在，必须满足相容性条件 $\\int_0^{2\\pi} f(x) dx = 0$。在离散情况下，这对应于 $\\sum_{j=0}^{N-1} f_j \\approx 0$，或者更精确地说，$\\hat{f}_0 = 0$。如果此条件成立，$\\hat{u}_0$ 是不确定的，代表积分常数。我们通过要求解具有零均值（即 $\\hat{u}_0 = 0$）来获得唯一解。\n\n如果 $\\hat{f}_0 \\neq 0$，则不存在周期解。一个“稳定求解器”会通过求解解的零均值部分来继续，实际上是求解 $u_x = f - \\bar{f}$，其中 $\\bar{f}$ 是 $f$ 的均值。这是通过将 $\\hat{u}_0=0$ 并对所有其他 $k$ 计算 $\\hat{u}_k = \\hat{f}_k / (\\mathrm{i}k_{eff,k})$ 来完成的。\n\n这个过程定义了一个谱积分矩阵 $I$。与 $D$ 类似，它可以表示为 $I = \\mathcal{F}^{-1} \\Lambda_I \\mathcal{F}$，其中 $\\Lambda_I$ 是一个对角矩阵，其元素为当 $k_{eff,k} \\neq 0$ 时 $(\\Lambda_I)_{kk} = 1/(\\mathrm{i}k_{eff,k})$，以及 $(\\Lambda_I)_{00} = 0$。\n\n**3. 复合性质 $ID\\mathbf{u} = \\mathbf{u} - \\overline{\\mathbf{u}}$**\n\n复合算子 $ID$ 是一个投影算子。\n$$\nID = (\\mathcal{F}^{-1} \\Lambda_I \\mathcal{F}) (\\mathcal{F}^{-1} \\Lambda_D \\mathcal{F}) = \\mathcal{F}^{-1} (\\Lambda_I \\Lambda_D) \\mathcal{F}\n$$\n对角矩阵 $\\Lambda_I$ 和 $\\Lambda_D$ 的乘积是一个对角矩阵 $\\Pi$，其元素为：\n$$\n\\Pi_{kk} = (\\Lambda_I)_{kk} (\\Lambda_D)_{kk} = \\begin{cases} \\frac{1}{\\mathrm{i}k_{eff,k}} \\cdot \\mathrm{i}k_{eff,k} = 1  \\text{if } k_{eff,k} \\neq 0 \\\\ 0 \\cdot 0 = 0  \\text{if } k_{eff,k} = 0 \\end{cases}\n$$\n所以，$\\Pi$ 是一个湮没 $k=0$ 傅里叶模态的投影矩阵。将 $ID$ 应用于向量 $\\mathbf{u}$ 会得到：\n$$\nID\\mathbf{u} = \\mathcal{F}^{-1} \\Pi (\\mathcal{F} \\mathbf{u}) = \\mathcal{F}^{-1}(\\Pi \\hat{\\mathbf{u}})\n$$\n此操作将 $\\mathbf{u}$ 的零频系数设为零，然后进行逆变换。这等同于从 $\\mathbf{u}$ 中减去其均值。$\\mathbf{u}$ 的均值是 $\\bar{u} = \\frac{1}{N}\\sum u_j = \\frac{1}{N}\\hat{u}_0$。所有元素都等于 $\\bar{u}$ 的向量 $\\overline{\\mathbf{u}}$ 的 DFT 只有一个等于 $\\hat{u}_0$ 的 $k=0$ 分量。因此，$\\mathcal{F}(\\mathbf{u} - \\overline{\\mathbf{u}}) = \\hat{\\mathbf{u}} - \\mathcal{F}(\\overline{\\mathbf{u}}) = \\Pi\\hat{\\mathbf{u}}$。应用 $\\mathcal{F}^{-1}$ 证实了 $ID\\mathbf{u} = \\mathbf{u} - \\overline{\\mathbf{u}}$。\n\n### 测试套件的实现\n\n程序实现了这些概念来构造 $D$ 和 $I$ 并求解 $u_x=f$。\n\n- **矩阵构造**：函数 `construct_matrices(N)` 通过将变换-乘法-逆变换序列应用于单位矩阵的各列来计算 $D$ 和 $I$。\n- **稳定求解器**：函数 `solve_pde(f, N)` 实现稳定求解器，它将 $f$ 变换到傅里叶空间，除以 $\\mathrm{i}k_{eff}$（通过将其系数设为零来处理 $k=0$ 模态），然后变换回来。\n- **测试 1**：对于 $u(x) = 2+\\cos(3x)$，计算 `IDu` 并与 $\\mathbf{u}-\\overline{\\mathbf{u}}$ 比较。在对称网格上 $\\cos(3x)$ 的均值为零，所以 $\\bar{u}=2$ 且 $\\mathbf{u}-\\overline{\\mathbf{u}}=\\cos(3x)$。复合运算 $ID\\mathbf{u}$ 应该能高精度地恢复 $\\cos(3x)$。\n- **测试 2**：对于 $f(x)=-3\\sin(3x)$，均值为零，因此问题是适定的。求解器找到唯一的零均值解 $u(x)=\\cos(3x)$。残差 $\\|D\\mathbf{u} - \\mathbf{f}\\|_\\infty$ 应该接近机器精度。\n- **测试 3**：对于 $f(x)=1+\\sin(x)$，均值为 $\\bar{f}=1$。问题是不相容的。稳定求解器实际上求解的是 $u_x = f-\\bar{f} = \\sin(x)$，得到 $u(x)=-\\cos(x)$。残差 $\\|D\\mathbf{u}-\\mathbf{f}\\|_\\infty$ 将是 $\\|(\\mathbf{f}-\\overline{\\mathbf{f}}) - \\mathbf{f}\\|_\\infty = \\|-\\overline{\\mathbf{f}}\\|_\\infty = 1$。\n- **测试 4**：对于 $f(x)=0$，求解器返回 $u=0$，残差 $\\|D \\cdot 0 - 0\\|_\\infty$ 精确为 $0$。", "answer": "```python\nimport numpy as np\n\ndef construct_matrices(N):\n    \"\"\"\n    Constructs the Fourier differentiation matrix D and spectral integration matrix I.\n    \n    Args:\n        N (int): The number of grid points.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the (D, I) matrices.\n    \"\"\"\n    if not isinstance(N, int) or N = 0:\n        raise ValueError(\"N must be a positive integer.\")\n    \n    # Effective integer wave numbers for an N-point DFT.\n    k_vec = np.fft.fftfreq(N) * N\n    \n    # Diagonal entries for the differentiation operator in Fourier space.\n    diag_D = 1j * k_vec\n    \n    # Diagonal entries for the integration operator in Fourier space.\n    # We use a pseudo-inverse, setting the 1/0 term to 0.\n    diag_I = np.zeros(N, dtype=complex)\n    non_zero_k = k_vec != 0\n    diag_I[non_zero_k] = 1.0 / diag_D[non_zero_k]\n\n    # Construct matrices by applying the operators to basis vectors.\n    D = np.zeros((N, N), dtype=complex)\n    I = np.zeros((N, N), dtype=complex)\n    \n    identity_matrix = np.identity(N)\n    for j in range(N):\n        e_j = identity_matrix[:, j]\n        e_j_hat = np.fft.fft(e_j)\n        \n        # Column j of D is the derivative of the j-th basis vector\n        D[:, j] = np.fft.ifft(diag_D * e_j_hat)\n        \n        # Column j of I is the integral of the j-th basis vector\n        I[:, j] = np.fft.ifft(diag_I * e_j_hat)\n        \n    return D, I\n\ndef solve_pde(f, N):\n    \"\"\"\n    Solves the equation u_x = f for periodic u using a stable spectral method.\n    The solver finds the unique solution with zero mean.\n    \n    Args:\n        f (np.ndarray): The vector of nodal values of the right-hand side function.\n        N (int): The number of grid points.\n        \n    Returns:\n        np.ndarray: The vector of nodal values of the solution u(x).\n    \"\"\"\n    # Effective integer wave numbers\n    k_vec = np.fft.fftfreq(N) * N\n    \n    # Transform f to Fourier space\n    f_hat = np.fft.fft(f)\n    \n    # Allocate space for solution in Fourier space\n    u_hat = np.zeros(N, dtype=complex)\n    \n    # Find indices of non-zero wave numbers\n    non_zero_k = k_vec != 0\n    \n    # Solve for u_hat components where k is not zero\n    u_hat[non_zero_k] = f_hat[non_zero_k] / (1j * k_vec[non_zero_k])\n    \n    # The k=0 component (mean) of u_hat remains zero.\n    \n    # Transform back to physical space\n    u = np.fft.ifft(u_hat)\n    \n    return u\n\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        {'id': 1, 'N': 16, 'u_func': lambda x: 2 + np.cos(3 * x)},\n        {'id': 2, 'N': 32, 'f_func': lambda x: -3 * np.sin(3 * x)},\n        {'id': 3, 'N': 32, 'f_func': lambda x: 1 + np.sin(x)},\n        {'id': 4, 'N': 10, 'f_func': lambda x: np.zeros_like(x)},\n    ]\n\n    results = []\n    \n    # Test 1: Composition check IDu = u - u_bar\n    N1 = test_cases[0]['N']\n    u_func1 = test_cases[0]['u_func']\n    \n    D1, I1 = construct_matrices(N1)\n    x1 = 2 * np.pi * np.arange(N1) / N1\n    u1 = u_func1(x1)\n    \n    # Compute IDu\n    computed1 = (I1 @ D1 @ u1).real\n    \n    # Compute u - u_bar\n    u_mean1 = np.mean(u1)\n    expected1 = u1 - u_mean1\n    \n    # Maximum absolute error\n    error1 = np.max(np.abs(computed1 - expected1))\n    results.append(error1)\n\n    # Tests 2, 3, 4: Solve u_x = f and check residual\n    for case in test_cases[1:]:\n        N = case['N']\n        f_func = case['f_func']\n\n        D, _ = construct_matrices(N)\n        x = 2 * np.pi * np.arange(N) / N\n        f = f_func(x)\n        \n        # Solve u_x = f to get the mean-zero solution u\n        u_sol = solve_pde(f, N)\n        \n        # Compute the numerical derivative Du\n        f_computed = (D @ u_sol).real\n        \n        # Calculate the residual ||Du - f||_inf\n        # Take real part of f for cases where it's specified as real\n        residual = np.max(np.abs(f_computed - f.real))\n        results.append(residual)\n\n    # Format and print the final results\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3387474"}]}