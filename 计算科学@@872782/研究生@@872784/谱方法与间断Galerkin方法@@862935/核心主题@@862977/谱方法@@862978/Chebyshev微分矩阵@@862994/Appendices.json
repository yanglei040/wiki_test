{"hands_on_practices": [{"introduction": "谱搭配法的基础在于微分矩阵，它将连续的微分算子转化为离散的矩阵运算。本练习将指导您从第一性原理出发，构建切比雪夫微分矩阵，重点在于采用数值稳定的向量化公式，这对于开发高效、准确的光谱求解器至关重要。通过这个实践，您将掌握确保计算过程中避免灾难性抵消和除零错误的关键技术。", "problem": "您需要推导并实现一个数值稳定、完全向量化的 Chebyshev-Gauss-Lobatto 微分矩阵，用于谱方法和间断 Galerkin 方法。请从基本原理开始：第一类 Chebyshev 多项式定义为 $T_n(x) = \\cos(n \\arccos(x))$，而 Chebyshev-Gauss-Lobatto 点由 $T_n(x)$ 在区间 $[-1,1]$ 上的极值点生成。利用一个基本事实：在不同节点上的插值可以通过带权重的重心 Lagrange 插值进行微分，并且插值函数在每个节点上的导数可以通过一个作用于节点值的微分矩阵得到。您的推导过程必须构建出微分矩阵的非对角线和对角线元素的向量化公式，并且必须强调当 $x_i \\approx x_j$ 时如何避免灾难性抵消。您必须对所有采用的数值保护措施进行说明。\n\n在单个程序中实现以下内容：\n- 使用 Chebyshev-Gauss-Lobatto 节点 $x_k = \\cos(\\theta_k)$，其中 $\\theta_k = \\pi k / N$，$k=0,1,\\dots,N$，角度以弧度为单位。\n- 推导并实现一个基于重心的微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，其作用 $y = D f$ 可近似函数 $f$ 的 $N$ 次插值多项式在节点 $x_k$ 处的导数。您的实现必须是完全向量化的，并且必须包含明确的保护措施，以避免对角线上的除零操作以及对角线元素因相减导致的有效位数损失。\n- 提供一个数值稳定的例程，用于在 Chebyshev-Gauss-Lobatto 节点上计算第一类 Chebyshev 多项式 $T_m(x)$ 和第二类 Chebyshev 多项式 $U_{m-1}(x)$，以便测试多项式微分的精确性。注意处理端点 $x=\\pm 1$ 时避免引入未定义的操作。角度必须以弧度处理。\n\n测试套件。对于下述每个测试用例，计算数值导数 $D f$ 与相应的解析导数（如果可用）之间的最大绝对误差（节点上的上确界范数）。\n- 测试 A（边界情况）：$N=1$，$f(x)=1$。以浮点数形式输出值 $\\max\\limits_{k} |(Df)_k|$。\n- 测试 B（多项式精确性，一般情况）：$N=8$，$m=3$，$f(x)=T_m(x)$。使用精确导数 $f'(x)=m\\,U_{m-1}(x)$。以浮点数形式输出 $\\max\\limits_{k} |(Df)_k - m\\,U_{m-1}(x_k)|$。\n- 测试 C（网格上的最高次数）：$N=32$，$m=32$，$f(x)=T_m(x)$。使用精确导数 $f'(x)=m\\,U_{m-1}(x)$。以浮点数形式输出 $\\max\\limits_{k} |(Df)_k - m\\,U_{m-1}(x_k)|$。\n- 测试 D（线性函数性质）：$N=16$，$f(x)=x$。精确导数为 $f'(x)=1$。以浮点数形式输出 $\\max\\limits_{k} |(Df)_k - 1|$。\n- 测试 E（解析非多项式）：$N=128$，$f(x)=e^x$。精确导数为 $f'(x)=e^x$。以浮点数形式输出 $\\max\\limits_{k} |(Df)_k - e^{x_k}|$。\n\n最终输出格式。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC,resultD,resultE]”）。每个结果都必须是标准小数或科学记数法表示的浮点数。所有角度必须以弧度处理。", "solution": "构建 Chebyshev 微分矩阵是求解微分方程的谱方法中的一个基石。该过程始于选择节点，然后进行多项式插值和微分。本文将从第一性原理出发，推导 Chebyshev-Gauss-Lobatto (CGL) 节点的微分矩阵元素，并强调数值稳定性。\n\n**1. Chebyshev 多项式和 CGL 节点**\n\n第一类 Chebyshev 多项式 $T_N(x)$ 在区间 $x \\in [-1, 1]$ 上由关系式 $T_N(x) = \\cos(N \\arccos(x))$ 定义。Chebyshev-Gauss-Lobatto (CGL) 节点是与 $T_N(x)$ 的极值点相对应的 $N+1$ 个点的集合。这些节点由以下公式给出：\n$$\nx_k = \\cos\\left(\\frac{\\pi k}{N}\\right) \\quad \\text{其中 } k = 0, 1, \\dots, N\n$$\n设函数 $f(x)$ 在这些节点上进行采样，得到值向量 $\\mathbf{f} = [f(x_0), f(x_1), \\dots, f(x_N)]^T$。我们寻求一个微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，使得向量 $\\mathbf{f}' = D\\mathbf{f}$ 能为 $f(x)$ 在节点上的导数提供一个高阶近似，即 $f'_k \\approx f'(x_k)$。这是通过对穿过点 $(x_k, f(x_k))$ 的 $N$ 次多项式插值 $p(x)$ 进行微分来实现的。\n\n**2. 重心 Lagrange 插值**\n\n次数最多为 $N$ 的唯一多项式插值 $p(x)$ 以 Lagrange 形式给出，即 $p(x) = \\sum_{j=0}^{N} f_j \\ell_j(x)$，其中 $f_j = f(x_j)$，$\\ell_j(x)$ 是 Lagrange 基多项式：\n$$\n\\ell_j(x) = \\prod_{\\substack{k=0 \\\\ k \\neq j}}^{N} \\frac{x-x_k}{x_j-x_k}\n$$\n直接对这种形式进行微分在数值上是不稳定的。一种更好的方法是重心公式法。第一重心公式使用重心权重 $w_j$ 重写 $\\ell_j(x)$：\n$$\n\\ell_j(x) = \\frac{w_j}{x-x_j} \\left/ \\sum_{k=0}^N \\frac{w_k}{x-x_k} \\right.\n$$\nCGL 节点的权重 $w_j$ 已知具有简单的形式：\n$$\nw_j = \\frac{(-1)^j}{c_j}, \\quad \\text{其中 } c_j = \\begin{cases} 2, & \\text{当 } j=0 \\text{ 或 } j=N \\\\ 1, & \\text{当 } 1 \\le j \\le N-1 \\end{cases}\n$$\n插值多项式在节点 $x_i$ 处的导数为 $p'(x_i) = \\sum_{j=0}^{N} f_j \\ell'_j(x_i)$。因此，微分矩阵 $D$ 的元素由 $D_{ij} = \\ell'_j(x_i)$ 给出。\n\n**3. 微分矩阵元素的推导**\n\n我们通过对 Lagrange 基多项式 $\\ell_j(x)$ 求导来推导 $D$ 的元素。\n\n**非对角线元素 ($i \\neq j$):**\n对于 $i \\neq j$，$\\ell'_j(x_i)$ 的计算是直接的。使用乘积法则会很繁琐；一种更优雅的方法依赖于 Lagrange 多项式和重心权重之间的关系。在节点上，两个基多项式之间的关系式为 $\\ell_j(x_i) = \\delta_{ij}$。使用另一种形式的 Lagrange 多项式 $\\ell_j(x)=L(x)/((x-x_j)L'(x_j))$，其中 $L(x) = \\prod_k (x-x_k)$，我们可以证明对于 $i \\neq j$：\n$$\nD_{ij} = \\ell'_j(x_i) = \\frac{L'(x_i)}{(x_i-x_j)L'(x_j)} = \\frac{w_j/w_i}{x_i - x_j}\n$$\n代入 CGL 节点的特定权重：\n$$\n\\frac{w_j}{w_i} = \\frac{(-1)^j/c_j}{(-1)^i/c_i} = \\frac{c_i}{c_j}(-1)^{j-i}\n$$\n由于 $(-1)^{j-i} = (-1)^{i-j} = (-1)^{i+j}$，我们可以将非对角线元素写为：\n$$\nD_{ij} = \\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j} \\quad \\text{对于 } i \\neq j\n$$\n这个公式是良态的。尽管分母 $x_i - x_j$ 可能很小，但它不是由近似相等的浮点数相减造成的灾难性抵消的结果，因为节点 $x_i$ 和 $x_j$ 是通过余弦函数精确定义的。\n\n**对角线元素 ($i = j$):**\n对角线元素 $D_{ii} = \\ell'_i(x_i)$ 不能使用上述公式计算，因为它会导致 $0/0$ 不定式。有两种稳定的方法可用。\n\n方法1：求和性质。Lagrange 基多项式之和为 $\\sum_{j=0}^N \\ell_j(x) = 1$。对 $x$ 求导得到 $\\sum_{j=0}^N \\ell'_j(x) = 0$。在节点 $x_i$ 处求值得到 $\\sum_{j=0}^N \\ell'_j(x_i) = 0$，这意味着：\n$$\nD_{ii} = \\ell'_i(x_i) = -\\sum_{\\substack{j=0 \\\\ j \\neq i}}^{N} \\ell'_j(x_i) = -\\sum_{\\substack{j=0 \\\\ j \\neq i}}^{N} D_{ij}\n$$\n这意味着每个对角线元素是其所在行其他元素的和的负数。这种方法在数值上是稳定的，因为它避免了对复杂表达式的微分，只涉及求和。\n\n方法2：显式公式。通过对 Chebyshev 多项式性质进行更详细的分析，可以推导出对角线元素的显式公式。这些公式计算效率高且数值稳健：\n$$\nD_{ii} = \\begin{cases} \\frac{2N^2+1}{6}, & \\text{当 } i=0 \\\\ -\\frac{x_i}{2(1-x_i^2)}, & \\text{当 } 1 \\le i \\le N-1 \\\\ -\\frac{2N^2+1}{6}, & \\text{当 } i=N \\end{cases}\n$$\n在实现上，这个显式公式因其直接性和效率而更可取，避免了对每行进行循环或求和。对于内部点（$1 \\le i \\le N-1$），分母 $1-x_i^2 = 1-\\cos^2(\\pi i/N) = \\sin^2(\\pi i/N)$ 是非零的。\n\n**4. 测试函数的数值稳定求值**\n\n测试套件要求在 CGL 节点 $x_k = \\cos(\\theta_k)$（其中 $\\theta_k = \\pi k/N$）处计算 $T_m(x)$ 及其导数 $T'_m(x) = m U_{m-1}(x)$。\n\n$T_m(x_k)$ 的求值：最稳定的方法是直接使用角度空间定义。对于 $\\theta_k \\in [0, \\pi]$，有 $\\arccos(\\cos(\\theta_k)) = \\theta_k$。\n$$\nT_m(x_k) = T_m(\\cos(\\theta_k)) = \\cos(m \\arccos(\\cos(\\theta_k))) = \\cos(m \\theta_k) = \\cos\\left(\\frac{m \\pi k}{N}\\right)\n$$\n\n$U_{m-1}(x_k)$ 的求值：第二类 Chebyshev 多项式定义为 $U_n(\\cos\\theta) = \\frac{\\sin((n+1)\\theta)}{\\sin\\theta}$。因此，\n$$\nU_{m-1}(x_k) = U_{m-1}(\\cos\\theta_k) = \\frac{\\sin(m\\theta_k)}{\\sin\\theta_k}\n$$\n此公式在端点 $k=0$（$\\theta_0=0$）和 $k=N$（$\\theta_N=\\pi$）处会变成不定式（$0/0$）。我们必须在这些点使用洛必达（L'Hôpital's）法则：\n- 对于 $k=0$（$\\theta_k \\to 0$）：\n$$ \\lim_{\\theta \\to 0} \\frac{\\sin(m\\theta)}{\\sin\\theta} = \\lim_{\\theta \\to 0} \\frac{m\\cos(m\\theta)}{\\cos\\theta} = m $$\n- 对于 $k=N$（$\\theta_k \\to \\pi$）：令 $\\phi = \\pi - \\theta \\to 0$。\n$$ \\lim_{\\theta \\to \\pi} \\frac{\\sin(m\\theta)}{\\sin\\theta} = \\lim_{\\phi \\to 0} \\frac{\\sin(m(\\pi-\\phi))}{\\sin(\\pi-\\phi)} = \\lim_{\\phi \\to 0} \\frac{-\\cos(m\\pi)\\sin(m\\phi)}{\\sin\\phi} = -(-1)^m \\cdot m = (-1)^{m+1}m = m(-1)^{m-1} $$\n因此，$U_{m-1}(x_k)$ 的稳定求值方法是：\n$$\nU_{m-1}(x_k) = \\begin{cases} m, & \\text{当 } k=0 \\\\ \\frac{\\sin(m \\pi k/N)}{\\sin(\\pi k/N)}, & \\text{当 } 1 \\le k \\le N-1 \\\\ m(-1)^{m-1}, & \\text{当 } k=N \\end{cases}\n$$\n这些稳定的求值例程，结合稳健的微分矩阵公式，为高精度地执行所需测试提供了必要的工具。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests a Chebyshev differentiation matrix.\n    \"\"\"\n\n    def chebyshev_diff_matrix(N):\n        \"\"\"\n        Constructs the (N+1)x(N+1) Chebyshev differentiation matrix.\n        Uses numerically stable, vectorized formulas.\n        \"\"\"\n        if not isinstance(N, int) or N  0:\n            raise ValueError(\"N must be a non-negative integer.\")\n        if N == 0:\n            return np.array([[0.0]])\n\n        # Generate Chebyshev-Gauss-Lobatto nodes\n        k = np.arange(N + 1)\n        theta = np.pi * k / N\n        x = np.cos(theta)\n\n        # Vectorized computation of off-diagonal entries\n        c = np.ones(N + 1)\n        c[0] = 2.0\n        c[N] = 2.0\n\n        # Create column and row vectors for broadcasting\n        x_i = x[:, np.newaxis]\n        x_j = x[np.newaxis, :]\n        c_i = c[:, np.newaxis]\n        c_j = c[np.newaxis, :]\n        \n        # Matrix of i and j indices for sign\n        i = np.arange(N + 1)[:, np.newaxis]\n        j = np.arange(N + 1)[np.newaxis, :]\n        sign_matrix = (-1.0)**(i + j)\n        \n        # Difference matrix\n        dX = x_i - x_j\n        \n        # Fill diagonal to avoid division by zero; these values are overwritten later.\n        np.fill_diagonal(dX, 1e-30)\n\n        # Compute off-diagonal entries D_ij = (c_i/c_j) * (-1)^(i+j) / (x_i - x_j)\n        D = (c_i / c_j) * sign_matrix / dX\n\n        # Compute diagonal entries using the explicit, stable formula\n        diag = np.zeros(N + 1)\n        # Interior points\n        diag[1:N] = -x[1:N] / (2.0 * (1.0 - x[1:N]**2))\n        # Endpoints\n        diag[0] = (2.0 * N**2 + 1.0) / 6.0\n        diag[N] = -(2.0 * N**2 + 1.0) / 6.0\n        \n        np.fill_diagonal(D, diag)\n        \n        return D\n\n    def eval_Tm(m, N):\n        \"\"\"\n        Evaluates Chebyshev polynomial T_m at (N+1) CGL nodes.\n        Uses the stable formula T_m(x_k) = cos(m*theta_k).\n        \"\"\"\n        if N == 0:\n            return np.array([1.0])\n        k = np.arange(N + 1)\n        theta = np.pi * k / N\n        return np.cos(m * theta)\n\n    def eval_Um_minus_1(m, N):\n        \"\"\"\n        Evaluates Chebyshev polynomial U_{m-1} at (N+1) CGL nodes.\n        Uses stable formulas for endpoints.\n        \"\"\"\n        if m == 0:\n            # T'_0(x) = 0. So 0 * U_{-1} is 0.\n            return np.zeros(N + 1)\n        \n        if N == 0: # U_{m-1}(x_0=1) = m.\n            return np.array([float(m)])\n            \n        k = np.arange(N + 1)\n        theta = np.pi * k / N\n        \n        u_vals = np.zeros(N + 1)\n        \n        # Interior points k = 1, ..., N-1 where sin(theta) is non-zero\n        interior_indices = (k > 0)  (k  N)\n        u_vals[interior_indices] = np.sin(m * theta[interior_indices]) / np.sin(theta[interior_indices])\n        \n        # Endpoint k=0 (theta=0, x=1) using L'Hopital's rule\n        u_vals[0] = m\n        \n        # Endpoint k=N (theta=pi, x=-1) using L'Hopital's rule\n        u_vals[N] = m * (-1.0)**(m - 1)\n        \n        return u_vals\n\n    test_cases = [\n        {'id': 'A', 'N': 1, 'm': 0, 'f_name': 'const'},\n        {'id': 'B', 'N': 8, 'm': 3, 'f_name': 'poly'},\n        {'id': 'C', 'N': 32, 'm': 32, 'f_name': 'poly'},\n        {'id': 'D', 'N': 16, 'm': 1, 'f_name': 'poly'},\n        {'id': 'E', 'N': 128, 'm': None, 'f_name': 'exp'}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        m = case['m']\n        \n        # Generate nodes and differentiation matrix\n        k = np.arange(N + 1)\n        theta = np.pi * k / N\n        x = np.cos(theta)\n        D = chebyshev_diff_matrix(N)\n        \n        f_vec = None\n        df_analytical = None\n\n        if case['f_name'] == 'const':\n            # f(x) = 1 = T_0(x)\n            f_vec = np.ones(N + 1)\n            df_analytical = np.zeros(N + 1)\n        elif case['f_name'] == 'poly':\n            # f(x) = T_m(x)\n            f_vec = eval_Tm(m, N)\n            # f'(x) = m * U_{m-1}(x)\n            df_analytical = m * eval_Um_minus_1(m, N)\n        elif case['f_name'] == 'exp':\n            # f(x) = exp(x)\n            f_vec = np.exp(x)\n            df_analytical = np.exp(x)\n        \n        # Compute numerical derivative\n        df_numerical = D @ f_vec\n\n        # For Test A, the problem asks for max|(Df)_k|\n        if case['id'] == 'A':\n            error = np.max(np.abs(df_numerical))\n        else:\n            error = np.max(np.abs(df_numerical - df_analytical))\n\n        results.append(error)\n\n    # Format output as a comma-separated list in brackets.\n    output_str = \",\".join(f\"{res:.15e}\" for res in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3369023"}, {"introduction": "一旦构建了微分矩阵，它就成为求解微分方程的强大工具。本练习展示了其在求解一个典型的斯特姆-刘维尔（Sturm-Liouville）特征值问题中的应用 [@problem_id:3368981]，揭示了连续算子的谱与离散矩阵的特征值之间的深刻联系。通过对比不同的边界条件处理方法——内部搭配法和罚函数法，您将深入理解它们对解的准确性和伪解（spurious modes）的影响。", "problem": "考虑区间 $[-1,1]$ 上的 Sturm-Liouville 特征值问题，\n$$(p(x)\\,u'(x))' + q(x)\\,u(x) = \\lambda\\,w(x)\\,u(x),$$\n其中 $p(x) = 1$，$q(x)=0$，$w(x)=1$，并服从齐次狄利克雷边界条件 $u(-1)=0$ 和 $u(1)=0$。您将使用基于切比雪夫-高斯-洛巴托点的切比雪夫配置法对算子进行离散化，并分析得到的离散谱。\n\n您的任务是：\n\n1. 从切比雪夫-高斯-洛巴托点的基本定义 $x_j = \\cos(\\pi j/N)$（其中 $j=0,1,\\dots,N$）出发，并要求微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 在这些节点上逼近一阶导数，推导出切比雪夫一阶微分矩阵 $D$。由此，推导出离散二阶导数矩阵 $D^{(2)} = D^2$。\n\n2. 使用内部配置法精确实施狄利克雷边界条件（即，消除在 $x_0=1$ 和 $x_N=-1$ 处的方程，并在 $N-1$ 个内部节点上求解特征问题），构建离散特征值问题\n$$\nD^{(2)}_{\\text{int}}\\,v = \\lambda\\,v,\n$$\n其中 $D^{(2)}_{\\text{int}}$ 是 $D^{(2)}$ 的内部子矩阵，通过限制索引为 $1,\\dots,N-1$ 得到。计算按实部降序排列的前 $K$ 个离散特征值。\n\n3. 独立地，为 $p(x)=1$，$q(x)=0$，$w(x)=1$ 且在 $[-1,1]$ 上具有齐次狄利克雷边界条件的连续问题，推导出闭式形式的精确特征对。根据此推导，得到连续特征值 $\\lambda_m$ 作为模态索引 $m \\in \\mathbb{N}$ 函数的大索引渐近行为。使用此解析结果与任务2中获得的离散特征值进行比较。\n\n4. 通过修改完整的 $(N+1)\\times(N+1)$ 矩阵 $D^{(2)}$，仅在边界节点 $j=0$ 和 $j=N$ 处施加一个大小为 $\\tau$ 的对角罚项，来分析罚函数法边界实施的效果。也就是说，考虑\n$$\nL_{\\tau} \\equiv D^{(2)} + \\tau\\,\\mathrm{diag}(1,0,\\dots,0,1).\n$$\n在所有 $N+1$ 个节点上求解离散特征问题\n$$\nL_{\\tau}\\,u = \\lambda\\,u\n$$\n如果一个离散模态 $u$ 的归一化端点质量比\n$$\n\\rho(u) \\equiv \\frac{|u_0|^2 + |u_N|^2}{\\sum_{j=0}^N |u_j|^2}\n$$\n超过一个阈值 $\\theta$（其中 $0  \\theta  1$），则定义该模态为边界局域化的。通过有原则地选择一个大的 $\\tau$ 和阈值 $\\theta$，识别并计数边界局域化的伪特征模态数量，即那些特征值由罚项主导且特征向量局域化在边界的特征对。\n\n5. 通过一个小型的测试套件来报告您的发现，该套件检验精度、稳定性和伪模态识别。对于每个测试，按照下述要求生成一个单一数字或一个布尔值。\n\n测试套件规范：\n\n- 测试A（精度，内部实施）：使用 $N=48$ 和 $K=6$。计算 $D^{(2)}_{\\text{int}}$ 的按实部降序排列的前 $K$ 个离散特征值。将它们与任务3中推导出的由 $m=1,2,\\dots,K$ 索引的精确连续特征值进行比较，并计算这 $K$ 个模态上的最大相对误差，\n$$\n\\varepsilon_{\\max} \\equiv \\max_{1\\le m\\le K} \\frac{|\\lambda^{\\text{disc}}_m - \\lambda^{\\text{cont}}_m|}{|\\lambda^{\\text{cont}}_m|}.\n$$\n将此结果报告为一个四舍五入到 $8$ 位小数的浮点数。\n\n- 测试B（伪模态计数，罚函数实施）：使用 $N=48$，罚项大小 $\\tau = 10^6$，以及边界局域化阈值 $\\theta=0.9$。求解 $L_{\\tau}$ 的完整 $(N+1)$ 维特征问题，并计算满足特征值 $\\mathrm{Re}(\\lambda)  0.1\\,\\tau$ 且特征向量满足 $\\rho(u) \\ge \\theta$ 的特征对数量。将此计数报告为一个整数。\n\n- 测试C（内部实施下谱的实数性）：使用 $N=16$。计算 $D^{(2)}_{\\text{int}}$ 的所有特征值，并检验其虚部的最大绝对值是否小于 $10^{-10}$。如果成立，则报告布尔值 $\\mathrm{True}$，否则报告 $\\mathrm{False}$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含测试A、B和C的结果，以逗号分隔的列表形式包含在方括号中，顺序为 [TestA,TestB,TestC]。例如，输出必须是以下形式\n$$\n[\\varepsilon_{\\max},\\; \\text{spurious\\_count},\\; \\text{all\\_real}],\n$$\n其中 $\\varepsilon_{\\max}$ 是一个四舍五入到 $8$ 位小数的浮点数，$\\text{spurious\\_count}$ 是一个整数，而 $\\text{all\\_real}$ 是一个布尔字面量。", "solution": "所提出的问题是在一个典型的 Sturm-Liouville 特征值问题上应用切比雪夫谱配置法的一个综合性练习。它要求推导和实现切比雪夫微分矩阵，比较两种不同的边界条件实施方法（内部配置法与罚函数法），并为验证而解析求解底层的连续问题。\n\n我们首先注意到问题陈述中的一个微小不一致之处。切比雪夫-高斯-洛巴托（CGL）点由公式 $x_j = \\cos(\\pi j/N)$ 定义，其中 $j=0,1,\\dots,N$。这明确设定了 $x_0 = \\cos(0) = 1$ 和 $x_N = \\cos(\\pi) = -1$。问题文本后来将边界节点称为“$x_0=-1$ 和 $x_N=1$”。这似乎是一个文本错误。我们将遵循CGL点的明确标准公式进行操作，使得齐次狄利克雷边界条件 $u(-1)=0$ 和 $u(1)=0$ 分别在节点 $x_N$ 和 $x_0$ 处实施。\n\n### 任务1：切比雪夫微分矩阵的推导\n\n对于一组节点 $\\{x_j\\}_{j=0}^N$，谱微分矩阵 $D$ 提供了一个从函数值向量 $\\mathbf{u} = (u_0, \\dots, u_N)^T$到这些节点上近似导数值向量 $\\mathbf{u}' = (u'_0, \\dots, u'_N)^T$的线性变换。即，$\\mathbf{u}' = D\\mathbf{u}$。该矩阵的元素 $D_{jk}$ 由 $D_{jk} = \\ell'_k(x_j)$ 给出，其中 $\\ell_k(x)$ 是与节点 $x_k$ 相关的拉格朗日基本多项式，具有性质 $\\ell_k(x_j) = \\delta_{jk}$。\n\n对于切比雪夫-高斯-洛巴托点 $x_j = \\cos(\\pi j/N)$ 的特定情况，存在用于 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 元素的公认显式公式。\n\n非对角线元素由下式给出：\n$$\nD_{jk} = \\frac{c_j}{c_k} \\frac{(-1)^{j+k}}{x_j - x_k}, \\quad j \\ne k\n$$\n其中系数 $c_j$ 定义为：\n$$\nc_j = \\begin{cases} 2,  \\text{当 } j=0 \\text{ 或 } j=N \\\\ 1,  \\text{当 } 1 \\le j \\le N-1 \\end{cases}\n$$\n\n对角线元素 $D_{jj}$ 可以用不同的方法推导。一个直接的公式是：\n$$\nD_{jj} = -\\frac{x_j}{2(1-x_j^2)}, \\quad 1 \\le j \\le N-1\n$$\n端点有特殊公式：\n$$\nD_{00} = \\frac{2N^2+1}{6}, \\quad D_{NN} = -\\frac{2N^2+1}{6}\n$$\n然而，一种更鲁棒且数值稳定的方法依赖于常数函数的导数必须为零这一事实。如果对所有 $x$ 都有 $u(x)=1$，那么其导数为 $0$。在矩阵形式中，这意味着 $D \\mathbf{1} = \\mathbf{0}$，其中 $\\mathbf{1}$ 是全为1的向量。这表明 $D$ 的每一行之和必须为零：\n$$\n\\sum_{k=0}^{N} D_{jk} = 0, \\quad \\text{对于每个 } j=0, \\dots, N\n$$\n这使得对角线元素可以从非对角线元素计算得出：\n$$\nD_{jj} = -\\sum_{k=0, k \\ne j}^{N} D_{jk}\n$$\n这种方法避免了在边界处计算不定式，并提高了数值稳定性。\n\n然后，二阶切比雪夫微分矩阵 $D^{(2)}$ 仅通过平方一阶矩阵得到：\n$$\nD^{(2)} = D^2 = D D\n$$\n\n### 任务3：连续问题的精确解\n\n在分析离散系统之前，我们推导连续问题的精确解。该问题是区间 $[-1,1]$ 上的亥姆霍兹方程：\n$$\nu''(x) = \\lambda u(x)\n$$\n服从齐次狄利克雷边界条件 $u(-1)=0$ 和 $u(1)=0$。\n为了得到非平凡解，我们必须有 $\\lambda  0$。设 $\\lambda = -k^2$，其中 $k > 0$。微分方程变为 $u''(x) + k^2 u(x) = 0$，其通解为：\n$$\nu(x) = A \\sin(kx) + B \\cos(kx)\n$$\n应用边界条件：\n1. $u(1) = A \\sin(k) + B \\cos(k) = 0$\n2. $u(-1) = -A \\sin(k) + B \\cos(k) = 0$\n\n将这两个方程相加得到 $2B\\cos(k) = 0$。从第一个方程中减去第二个方程得到 $2A\\sin(k) = 0$。对于非平凡解，我们不能同时有 $A=0$ 和 $B=0$。这导致两族解：\n- **奇解 ($B=0, A\\ne 0$)：** 我们要求 $\\sin(k) = 0$，这意味着 $k = n\\pi$ 对于 $n \\in \\mathbb{N}$（正整数）。特征函数为 $u_n(x) \\propto \\sin(n\\pi x)$。\n- **偶解 ($A=0, B\\ne 0$)：** 我们要求 $\\cos(k) = 0$，这意味着 $k = (n - 1/2)\\pi$ 对于 $n \\in \\mathbb{N}$。特征函数为 $u_n(x) \\propto \\cos((n - 1/2)\\pi x)$。\n\n为了获得单一、有序的特征值序列，我们将这些 $k$ 的可能性结合起来：\n$$\nk_m = \\frac{m\\pi}{2}, \\quad m=1, 2, 3, \\ldots\n$$\n相应的特征值为：\n$$\n\\lambda^{\\text{cont}}_m = -k_m^2 = -\\left(\\frac{m\\pi}{2}\\right)^2, \\quad m=1, 2, 3, \\ldots\n$$\n按实部降序排列的特征值（即从最小负值到最大负值）是 $\\lambda^{\\text{cont}}_1 = -(\\pi/2)^2$, $\\lambda^{\\text{cont}}_2 = -(\\pi)^2$, $\\lambda^{\\text{cont}}_3 = -(3\\pi/2)^2$，依此类推。这个精确公式也描述了大索引的渐近行为。\n\n### 任务2：通过内部配置法进行离散化\n\n内部配置法，也称为矩阵限制法或子矩阵法，可以精确地实施狄利克雷边界条件。完整的离散系统是 $D^{(2)}\\mathbf{u} = \\lambda\\mathbf{u}$。边界条件 $u(1)=0$ 和 $u(-1)=0$ 在CGL网格上转化为 $u_0=0$ 和 $u_N=0$。\n\n系统的第 $j$ 个方程是 $\\sum_{k=0}^{N} D^{(2)}_{jk} u_k = \\lambda u_j$。对于一个内部节点 $j \\in \\{1, \\dots, N-1\\}$，这变为：\n$$\nD^{(2)}_{j,0}u_0 + \\sum_{k=1}^{N-1} D^{(2)}_{jk} u_k + D^{(2)}_{j,N}u_N = \\lambda u_j\n$$\n代入 $u_0=0$ 和 $u_N=0$，系统简化为：\n$$\n\\sum_{k=1}^{N-1} D^{(2)}_{jk} u_k = \\lambda u_j, \\quad j=1, \\dots, N-1\n$$\n这是一个针对内部自由度 $\\mathbf{v} = (u_1, \\dots, u_{N-1})^T$ 的简化特征值问题：\n$$\nD^{(2)}_{\\text{int}}\\mathbf{v} = \\lambda\\mathbf{v}\n$$\n其中 $D^{(2)}_{\\text{int}}$ 是通过取索引从 $1$ 到 $N-1$ 的行和列从 $D^{(2)}$ 中获得的 $(N-1) \\times (N-1)$ 子矩阵。$D^{(2)}_{\\text{int}}$ 的特征值逼近精确的连续特征值 $\\lambda^{\\text{cont}}_m$。\n\n### 任务4：通过罚函数法进行离散化\n\n罚函数法是处理边界条件的另一种方法。它不是减小系统的大小，而是修改完整的 $(N+1) \\times (N+1)$ 算子。对于狄利克雷条件，在对应于边界节点的对角线元素上添加一个大的罚项。\n修改后的算子是：\n$$\nL_{\\tau} = D^{(2)} + \\tau \\cdot \\mathrm{diag}(1, 0, \\dots, 0, 1)\n$$\n其中 $\\tau > 0$ 是一个大的罚参数。\n要解决的特征问题是 $L_{\\tau}\\mathbf{u} = \\lambda\\mathbf{u}$。其原理是，如果一个特征模态 $\\mathbf{u}$ 恰好满足边界条件（即，$u_0 \\approx 0, u_N \\approx 0$），则罚项影响很小，其特征值 $\\lambda$ 应逼近原始算子的真实特征值。\n相反，如果一个模态违反了边界条件（例如，$u_0$ 或 $u_N$很大），那么项 $\\tau u_j$（对于 $j=0$ 或 $j=N$）将主导该方程，产生一个量级为 $\\tau$ 的大特征值。这些特征对不对应连续问题的解，被称为“伪模态”。它们通常的特征是具有大特征值和在边界处局域化的特征向量。\n为了识别它们，我们使用边界局域化质量比：\n$$\n\\rho(u) \\equiv \\frac{|u_0|^2 + |u_N|^2}{\\sum_{j=0}^N |u_j|^2}\n$$\n如果一个模态的特征值很大（例如，$\\mathrm{Re}(\\lambda) > c\\tau$，其中 $c$ 是某个常数）并且其特征向量是边界局域化的（例如，$\\rho(u) > \\theta$，其中 $\\theta$ 是某个接近 $1$ 的阈值），则该模态被标记为伪模态。\n\n### 任务5：测试套件的实现\n\n现在将上面建立的逻辑应用于指定的计算测试。\n- **测试A** 评估内部配置法的精度。它将对于 $N=48$ 的 $D^{(2)}_{\\text{int}}$ 的前 $K=6$ 个特征值与精确的解析特征值 $\\lambda^{\\text{cont}}_m = -(m\\pi/2)^2$ 进行比较，并计算最大相对误差。这展示了该方法对于良好解析的模态所具有的高精度（“谱精度”）。\n- **测试B** 量化了罚函数法对于 $N=48$ 所产生的伪模态数量。它使用指定的标准（$\\mathrm{Re}(\\lambda) > 0.1\\tau$ 其中 $\\tau=10^6$ 以及 $\\rho(u) \\ge 0.9$）来筛选和计数这些非物理的解。\n- **测试C** 验证离散算子的一个基本性质。对于这个自伴随的连续问题，$D^{(2)}_{\\text{int}}$ 的特征值应该是实数。此测试检查对于 $N=16$ 的情况，计算出的特征值的虚部是否可以忽略不计（小于 $10^{-10}$），从而证实矩阵构造的正确性和数值特征求解器的稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef cheb_diff_mat(N):\n    \"\"\"\n    Computes the Chebyshev differentiation matrix D on N+1 Gauss-Lobatto points.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.0]])\n    \n    x = np.cos(np.pi * np.arange(N + 1) / N)\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[N] = 2.0\n    \n    D = np.zeros((N + 1, N + 1))\n    \n    # Off-diagonal entries\n    for j in range(N + 1):\n        for k in range(N + 1):\n            if j != k:\n                D[j, k] = (c[j] / c[k]) * ((-1)**(j + k)) / (x[j] - x[k])\n\n    # Diagonal entries using the row-sum property for stability\n    for j in range(N + 1):\n        D[j, j] = -np.sum(D[j, :])\n        \n    return D\n\ndef solve():\n    \"\"\"\n    Executes the specified test suite for Chebyshev spectral methods.\n    \"\"\"\n    results = []\n\n    # === Test A: Accuracy, Interior Enforcement ===\n    N_A = 48\n    K_A = 6\n    \n    D_A = cheb_diff_mat(N_A)\n    D2_A = D_A @ D_A\n    D2_int_A = D2_A[1:N_A, 1:N_A]\n    \n    eigvals_disc_A = np.linalg.eigvals(D2_int_A)\n    # Sort by decreasing real part (e.g., from -2.5 to -9.8)\n    sorted_eigvals_disc_A = np.sort(np.real(eigvals_disc_A))[::-1]\n    \n    # Get top K discrete eigenvalues\n    lambda_disc = sorted_eigvals_disc_A[:K_A]\n    \n    # Get exact continuous eigenvalues\n    m_vals = np.arange(1, K_A + 1)\n    lambda_cont = -((m_vals * np.pi) / 2.0)**2\n    \n    # Compute maximum relative error\n    rel_errors = np.abs(lambda_disc - lambda_cont) / np.abs(lambda_cont)\n    eps_max = np.max(rel_errors)\n    \n    results.append(round(eps_max, 8))\n\n    # === Test B: Spurious-mode Count, Penalty Enforcement ===\n    N_B = 48\n    tau_B = 1.0e6\n    theta_B = 0.9\n    \n    D_B = cheb_diff_mat(N_B)\n    D2_B = D_B @ D_B\n    \n    L_tau = D2_B.copy()\n    L_tau[0, 0] += tau_B\n    L_tau[N_B, N_B] += tau_B\n    \n    eigvals_B, eigvecs_B = np.linalg.eig(L_tau)\n    \n    spurious_count = 0\n    for i in range(N_B + 1):\n        lam = eigvals_B[i]\n        u = eigvecs_B[:, i]\n        \n        # Condition 1: Eigenvalue dominated by penalty\n        if np.real(lam) > 0.1 * tau_B:\n            # Condition 2: Eigenvector localized at boundaries\n            # Eigenvectors from np.linalg.eig are L2-normalized to 1\n            rho_u_num = np.abs(u[0])**2 + np.abs(u[N_B])**2\n            rho_u_den = np.sum(np.abs(u)**2) # Should be 1.0, but compute for robustness\n            rho_u = rho_u_num / rho_u_den\n            \n            if rho_u >= theta_B:\n                spurious_count += 1\n                \n    results.append(spurious_count)\n\n    # === Test C: Reality of Spectrum, Interior Enforcement ===\n    N_C = 16\n    \n    D_C = cheb_diff_mat(N_C)\n    D2_C = D_C @ D_C\n    D2_int_C = D2_C[1:N_C, 1:N_C]\n    \n    eigvals_C = np.linalg.eigvals(D2_int_C)\n    \n    max_imag_part = np.max(np.abs(np.imag(eigvals_C)))\n    all_real = max_imag_part  1e-10\n    \n    results.append(all_real)\n\n    # Final print statement in the exact required format.\n    print(f\"[{results[0]},{results[1]},{results[2]}]\")\n\nsolve()\n\n```", "id": "3368981"}, {"introduction": "对于随时间演化的偏微分方程，数值格式的长期稳定性至关重要。本练习探讨了如何离散一个变系数扩散方程，并分析不同离散格式对系统离散能量的影响 [@problem_id:3368959]。您将对比“守恒形式”和“斜对称形式”的算子，从而理解一个深刻的原则：在离散层面模仿连续问题（如积分-微分）的内在结构，可以构建出更为稳健和物理上可靠的数值方案。", "problem": "考虑在区间 $[-1,1]$ 上的变系数扩散方程 $u_t = (\\nu(x) u_x)_x$，其边界条件为齐次狄利克雷边界条件 $u(-1)=0$ 和 $u(1)=0$。对于标准 $L^2$ 内积，连续能量法通过分部积分表明，能量 $E(t) = \\tfrac{1}{2} \\int_{-1}^1 u(x,t)^2 \\, dx$ 满足 $\\tfrac{d}{dt} E(t) = - \\int_{-1}^1 \\nu(x) u_x(x,t)^2 \\, dx \\le 0$，其中 $\\nu(x) \\ge 0$ 为任意非负函数。在谱配置法中，我们使用 Chebyshev-Gauss-Lobatto 节点 $x_j = \\cos\\left(\\frac{\\pi j}{n}\\right)$（其中 $j=0,1,\\dots,n$）来离散化 $x \\in [-1,1]$，并使用与这些节点关联的 Chebyshev 一阶微分矩阵 $D \\in \\mathbb{R}^{(n+1)\\times(n+1)}$。矩阵 $D$ 的元素由重心 Lagrange 插值微分公式确定：当 $i \\ne j$ 时，$D_{ij} = \\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i-x_j}$；当 $i=j$ 时，$D_{ii} = -\\sum_{j\\ne i} D_{ij}$。其中，$c_0 = c_n = 2$，$c_j = 1$（$1 \\le j \\le n-1$）。令 $I = \\{1,2,\\dots,n-1\\}$ 表示内部节点的索引集合，令 $v \\in \\mathbb{R}^{n-1}$ 为对应于内部自由度的未知量向量，并强制 $u_0 = u_n = 0$。记 $A = D(:,I) \\in \\mathbb{R}^{(n+1)\\times(n-1)}$ 为在 $u_0 = u_n = 0$ 的约定下，将内部值 $v$ 映射到节点导数 $D u$ 的矩阵；记 $B = D(I,:) \\in \\mathbb{R}^{(n-1)\\times(n+1)}$ 为将 $D$ 限制在内部行所得到的矩阵。\n\n考虑以下两个半离散算子：\n\n- 一个保守通量形式配置算子 $L_{\\mathrm{cons}} \\in \\mathbb{R}^{(n-1)\\times(n-1)}$，定义为 $L_{\\mathrm{cons}} = B \\, \\mathrm{diag}(\\nu(x)) \\, A$。它对应于 $v_t = L_{\\mathrm{cons}} v$，并将 $u_t = ( \\nu u_x )_x$ 的离散形式 $D(\\nu \\, D u)$ 限制在内部来实现。\n\n- 一个反对称（分裂）能量形式算子 $L_{\\mathrm{skew}} \\in \\mathbb{R}^{(n-1)\\times(n-1)}$，定义为 $L_{\\mathrm{skew}} = - A^\\top \\, \\mathrm{diag}(\\nu(x)) \\, A$。它对应于 $v_t = L_{\\mathrm{skew}} v$，并模拟了在齐次狄利克雷边界条件下通过分部积分获得的能量恒等式。\n\n对于基于内部自由度上欧几里得内积的固定离散能量 $E_h(v) = \\tfrac{1}{2} v^\\top v$，与算子 $L \\in \\mathbb{R}^{(n-1)\\times(n-1)}$ 相关联的瞬时离散能量变化由其对称部分 $S(L) = \\tfrac{1}{2}(L + L^\\top)$ 决定，即 $\\tfrac{d}{dt} E_h(v) = v^\\top S(L) v$。对于所有 $v$，离散能量单调不增的充要条件是 $S(L)$ 的最大特征值小于或等于 $0$。在连续极限下，且如果具有合适的分部求和（summation-by-parts）结构，反对称形式应产生非正的离散能量变化率。然而，当 $\\nu(x)$ 非均匀时，朴素的保守配置法 $D(\\nu D u)$ 在欧几里得内积下可能不具有能量耗散性。\n\n您的任务是实现一个程序，该程序针对一组指定的测试用例，为每个粘度剖面 $\\nu(x)$ 构造 $D$、$A$、$B$，组装 $L_{\\mathrm{cons}}$ 和 $L_{\\mathrm{skew}}$，构成对称部分 $S(L_{\\mathrm{cons}})$ 和 $S(L_{\\mathrm{skew}})$，并计算每个对称部分的最大特征值。所有三角函数的参数均以弧度为单位。最终输出必须是实值浮点数。\n\n仅从以上定义以及 Chebyshev-Gauss-Lobatto 网格和微分矩阵的性质出发，推导这些算子，并设计一个能稳健计算其对称部分最大特征值的算法。解释为什么当在欧几里得内积下度量时，反对称（能量形式）算子对于任何非负的 $\\nu(x)$ 都能保证离散能量变化的非正性，而保守通量形式却不一定。除了这些核心定义之外，不要使用或假设任何外部公式。\n\n测试套件。对每个用例，按如下方式设置 $n$ 和 $\\nu(x)$，其中 $\\cos$ 表示参数以弧度为单位的余弦函数：\n\n- 用例 1：$n = 16$，$\\nu(x) = 1 + 0.5\\,x$。\n- 用例 2：$n = 32$，$\\nu(x) = 1 + 0.9 \\cos(3 \\pi x)$。\n- 用例 3：$n = 24$，$\\nu(x) = \\exp(5 x)$。\n- 用例 4：$n = 28$，$\\nu(x) = 0.01 + \\tfrac{1}{2}(x+1)$。\n- 用例 5：$n = 30$，$\\nu(x) = \\begin{cases}1,  \\text{当 } x  0,\\\\ 3,  \\text{当 } x \\ge 0.\\end{cases}$\n\n对每个用例，计算两个浮点数：\n\n- $\\lambda_{\\max}^{\\mathrm{cons}}$，$S(L_{\\mathrm{cons}})$ 的最大特征值。\n- $\\lambda_{\\max}^{\\mathrm{skew}}$，$S(L_{\\mathrm{skew}})$ 的最大特征值。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\lambda_{\\max,1}^{\\mathrm{cons}}, \\lambda_{\\max,1}^{\\mathrm{skew}}, \\lambda_{\\max,2}^{\\mathrm{cons}}, \\lambda_{\\max,2}^{\\mathrm{skew}}, \\dots, \\lambda_{\\max,5}^{\\mathrm{cons}}, \\lambda_{\\max,5}^{\\mathrm{skew}}]$。打印前，将每个浮点数四舍五入到六位小数。\n\n本问题不涉及物理单位。三角函数中的角度以弧度度量。请确保对于给定的 $n$ 值，所有运算都是数值稳定的，并确保在每个测试用例中，所有节点 $x$ 处的 $\\nu(x) \\ge 0$。", "solution": "问题陈述已经过验证，被认为是可靠的。它具有适定性，在偏微分方程数值方法的理论中有科学依据，并包含了进行求解所需的所有必要信息。\n\n该问题要求对定义在区间 $x \\in [-1,1]$ 上、带有齐次狄利克雷边界条件 $u(-1,t)=u(1,t)=0$ 的变系数扩散方程 $u_t = (\\nu(x) u_x)_x$ 的两种不同谱配置离散化方法进行分析和计算。分析的核心是离散能量稳定性的概念。\n\n**1. 离散能量分析**\n\n在半离散系统中，解的演化由常微分方程（ODE）系统 $\\frac{d v}{dt} = L v$ 给出，其中 $v(t) \\in \\mathbb{R}^{n-1}$ 是在内部 Chebyshev 节点上解值的向量，$L \\in \\mathbb{R}^{(n-1)\\times(n-1)}$ 是离散空间算子。\n\n问题定义了基于内部自由度上欧几里得内积的离散能量：\n$$E_h(v) = \\frac{1}{2} v^\\top v$$\n该离散能量的时间变化率为：\n$$ \\frac{d}{dt} E_h(v) = \\frac{1}{2} \\frac{d}{dt} (v^\\top v) = \\frac{1}{2} \\left( \\frac{dv^\\top}{dt} v + v^\\top \\frac{dv}{dt} \\right) $$\n代入 $\\frac{dv}{dt} = L v$，我们得到：\n$$ \\frac{d}{dt} E_h(v) = \\frac{1}{2} \\left( (Lv)^\\top v + v^\\top (Lv) \\right) = \\frac{1}{2} \\left( v^\\top L^\\top v + v^\\top L v \\right) = v^\\top \\left( \\frac{L + L^\\top}{2} \\right) v $$\n令 $S(L) = \\frac{1}{2} (L + L^\\top)$ 为算子 $L$ 的对称部分。能量变化率则表示为二次型 $v^\\top S(L) v$。\n\n为使数值格式具有能量耗散性（或更准确地说，能量不增），对于任何状态向量 $v$，该变化率必须为非正。这意味着矩阵 $S(L)$ 必须是负半定的。一个对称矩阵是负半定的充要条件是其所有特征值均为非正。因此，保证该格式是能量耗散的充要条件是 $S(L)$ 的最大特征值满足 $\\lambda_{\\max}(S(L)) \\le 0$。\n\n**2. 反对称（能量形式）算子 $L_{\\mathrm{skew}}$ 的分析**\n\n能量形式算子定义为 $L_{\\mathrm{skew}} = -A^\\top N A$，其中 $N = \\mathrm{diag}(\\nu(x_j))$ 是节点上粘度值的对角矩阵，$A=D(:,I)$ 是 Chebyshev 微分矩阵 $D$ 中对应于内部节点列的子矩阵。向量 $w = Av$ 表示（边界值为零的）函数在所有网格点上求值的离散导数。\n\n让我们求 $L_{\\mathrm{skew}}$ 的对称部分：\n$$ S(L_{\\mathrm{skew}}) = \\frac{1}{2} (L_{\\mathrm{skew}} + L_{\\mathrm{skew}}^\\top) = \\frac{1}{2} \\left( -A^\\top N A + (-A^\\top N A)^\\top \\right) $$\n使用性质 $(XYZ)^\\top = Z^\\top Y^\\top X^\\top$ 并注意到 $N$ 是一个对角矩阵（因此是对称的，$N^\\top = N$），我们有：\n$$ S(L_{\\mathrm{skew}}) = \\frac{1}{2} \\left( -A^\\top N A - A^\\top N^\\top (A^\\top)^\\top \\right) = \\frac{1}{2} \\left( -A^\\top N A - A^\\top N A \\right) = -A^\\top N A = L_{\\mathrm{skew}} $$\n这表明 $L_{\\mathrm{skew}}$ 本身就是一个对称矩阵。\n\n能量变化由以下二次型给出：\n$$ v^\\top S(L_{\\mathrm{skew}}) v = v^\\top (-A^\\top N A) v = -(Av)^\\top N (Av) $$\n令 $w = Av \\in \\mathbb{R}^{n+1}$，表达式变为：\n$$ -w^\\top N w = - \\sum_{j=0}^{n} w_j^2 N_{jj} = - \\sum_{j=0}^{n} \\nu(x_j) w_j^2 $$\n鉴于问题规定 $\\nu(x) \\ge 0$，可推得对于所有节点 $x_j$ 都有 $\\nu(x_j) \\ge 0$。由于 $w_j^2 \\ge 0$，和中的每一项都是非负的。因此，总和是非负的，而该二次型是非正的：\n$$ \\frac{d}{dt} E_h(v) = - \\sum_{j=0}^{n} \\nu(x_j) w_j^2 \\le 0 $$\n这对任意向量 $v$ 都成立。因此，$S(L_{\\mathrm{skew}})$ 是负半定的，其最大特征值必须小于或等于零，即 $\\lambda_{\\max}(S(L_{\\mathrm{skew}})) \\le 0$。这种构造保证了对于任何非负粘度函数 $\\nu(x)$，离散能量都是稳定的。\n\n**3. 保守通量形式算子 $L_{\\mathrm{cons}}$ 的分析**\n\n保守形式算子定义为 $L_{\\mathrm{cons}} = B N A$，其中 $B=D(I,:)$ 是将 $D$ 限制到其内部行所得到的矩阵。这种形式通过依次应用微分算子来直接离散化通量形式的方程 $u_t = (\\nu u_x)_x$：首先获得 $u_x$，然后乘以 $\\nu$，最后对乘积 $\\nu u_x$ 进行微分。\n\n该算子的对称部分是：\n$$ S(L_{\\mathrm{cons}}) = \\frac{1}{2} (L_{\\mathrm{cons}} + L_{\\mathrm{cons}}^\\top) = \\frac{1}{2} (B N A + (B N A)^\\top) = \\frac{1}{2} (B N A + A^\\top N^\\top B^\\top) = \\frac{1}{2} (B N A + A^\\top N B^\\top) $$\n在连续情形下，稳定性是通过分部积分来证明的，它在适当的内积和边界条件下，有效地将算子 $(\\cdot)_x$ 与其负伴随算子 $-(\\cdot)_x$ 联系起来。在离散情形下，需要一个类似的性质，即分部求和（summation-by-parts, SBP）性质，来保证 $D$ 的稳定性。Chebyshev 微分矩阵 $D$ 对于标准欧几里得内积（其中求积矩阵是单位矩阵）不满足 SBP 性质。相反，它对于一个由 Clenshaw-Curtis 求积权重构成的非单位对角矩阵满足 SBP 性质。\n\n由于离散能量 $E_h(v) = \\frac{1}{2} v^\\top v$ 是用未加权的欧几里得内积定义的，因此存在不匹配。没有普适的代数性质能将 $B$ 和 $A^\\top$（它们是 $D$ 和 $D^\\top$ 的子块）联系起来，以确保对于任何非负对角矩阵 $N$，矩阵 $S(L_{\\mathrm{cons}})$ 都是负半定的。虽然对于常数 $\\nu(x)$，这种形式通常是稳定的，但对于一般的非常数 $\\nu(x)$，二次型 $v^\\top S(L_{\\mathrm{cons}}) v$ 的符号没有保证。$S(L_{\\mathrm{cons}})$ 有可能出现正特征值，从而导致离散能量的伪增长。\n\n**4. 算法实现**\n\n对每个测试用例 $(n, \\nu(x))$，计算所需特征值的算法流程如下：\n1.  **生成网格**：计算 $n+1$ 个 Chebyshev-Gauss-Lobatto 节点 $x_j = \\cos(\\frac{\\pi j}{n})$，其中 $j=0, \\dots, n$。\n2.  **构造微分矩阵 $D$**：使用问题中给出的标准公式构造 $(n+1) \\times (n+1)$ 的矩阵 $D$。\n3.  **形成边界条件矩阵**：从 $D$ 中提取用于处理齐次狄利克雷边界条件的矩阵：$A = D(:, I)$ 由 $D$ 的第 $1$ 列到第 $n-1$ 列组成。此矩阵将 $(n-1)$ 个内部值映射到所有 $n+1$ 个节点上的导数。$B = D(I, :)$ 由 $D$ 的第 $1$ 行到第 $n-1$ 行组成。这代表了限制在内部点上的微分算子。\n4.  **组装算子**：形成对角粘度矩阵 $N = \\mathrm{diag}(\\nu(x_j))$。通过矩阵乘法组装算子：$L_{\\mathrm{cons}} = B N A$ 和 $L_{\\mathrm{skew}} = -A^\\top N A$。\n5.  **计算特征值**：形成对称部分 $S(L_{\\mathrm{cons}}) = \\frac{1}{2}(L_{\\mathrm{cons}} + L_{\\mathrm{cons}}^\\top)$ 和 $S(L_{\\mathrm{skew}}) = \\frac{1}{2}(L_{\\mathrm{skew}} + L_{\\mathrm{skew}}^\\top)$。计算这些实对称矩阵的特征值。为每个矩阵找出其最大特征值 $\\lambda_{\\max}$。`numpy.linalg.eigvalsh` 是完成此任务的理想选择，因为它针对对称矩阵进行了优化并返回排序后的特征值。\n\n将此过程系统地应用于每个测试用例，以生成最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_chebyshev_diff_matrix(n):\n    \"\"\"\n    Constructs the Chebyshev differentiation matrix for n+1 Chebyshev-Gauss-Lobatto nodes.\n\n    Args:\n        n (int): The degree of the polynomial, corresponding to n+1 grid points.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing:\n            - D (np.ndarray): The (n+1)x(n+1) Chebyshev differentiation matrix.\n            - x (np.ndarray): The n+1 Chebyshev-Gauss-Lobatto nodes.\n    \"\"\"\n    N = n + 1\n    # Generate Chebyshev-Gauss-Lobatto nodes\n    x = np.cos(np.pi * np.arange(N) / n)\n\n    # Weights c_j from the problem description's formula\n    c = np.ones(N)\n    c[0] = 2.0\n    c[n] = 2.0\n    \n    # Vectorized computation of off-diagonal entries\n    x_col = x.reshape(-1, 1)\n    x_row = x.reshape(1, -1)\n    dX = x_col - x_row\n    \n    signs_i = (-1.0)**np.arange(N).reshape(-1, 1)\n    signs_j = (-1.0)**np.arange(N).reshape(1, -1)\n    \n    # Add identity to dX to avoid division by zero on the diagonal\n    D = (c.reshape(-1, 1) / c.reshape(1, -1)) * (signs_i * signs_j) / (dX + np.eye(N))\n    \n    # Set diagonal to zero before summing rows\n    np.fill_diagonal(D, 0.0)\n\n    # Compute diagonal entries: D_ii = -sum(D_ij for j!=i)\n    row_sums = np.sum(D, axis=1)\n    np.fill_diagonal(D, -row_sums)\n    \n    return D, x\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    For each case, it constructs the conservative and skew-symmetric operators,\n    forms their symmetric parts, and computes the largest eigenvalue of each.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (16, lambda x: 1 + 0.5 * x),\n        (32, lambda x: 1 + 0.9 * np.cos(3 * np.pi * x)),\n        (24, lambda x: np.exp(5 * x)),\n        (28, lambda x: 0.01 + 0.5 * (x + 1)),\n        (30, lambda x: np.where(x  0, 1.0, 3.0)),\n    ]\n\n    results = []\n    for n, nu_func in test_cases:\n        # Step 1  2: Build differentiation matrix and grid\n        D, x_nodes = build_chebyshev_diff_matrix(n)\n        \n        # Step 3: Build submatrices A and B for boundary conditions\n        # Interior indices are 1, ..., n-1. In Python slicing, this is 1:n.\n        A = D[:, 1:n]  # D maps interior values to derivatives at all nodes\n        B = D[1:n, :]  # D restricts to interior rows\n        \n        # Step 4: Assemble operators\n        # Evaluate viscosity function at the nodes\n        nu_vals = nu_func(x_nodes)\n        Nu = np.diag(nu_vals)\n        \n        # Conservative flux-form operator\n        L_cons = B @ Nu @ A\n        \n        # Skew-symmetric (energy-form) operator\n        L_skew = -A.T @ Nu @ A\n        \n        # Step 5: Form symmetric parts\n        S_cons = 0.5 * (L_cons + L_cons.T)\n        S_skew = 0.5 * (L_skew + L_skew.T)\n        \n        # Step 6: Compute largest eigenvalue of each symmetric part\n        # eigvalsh returns sorted eigenvalues, so the largest is the last one.\n        lambda_max_cons = np.linalg.eigvalsh(S_cons)[-1]\n        lambda_max_skew = np.linalg.eigvalsh(S_skew)[-1]\n        \n        results.append(lambda_max_cons)\n        results.append(lambda_max_skew)\n\n    # Final print statement in the exact required format.\n    formatted_results = ','.join([f\"{r:.6f}\" for r in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "3368959"}]}