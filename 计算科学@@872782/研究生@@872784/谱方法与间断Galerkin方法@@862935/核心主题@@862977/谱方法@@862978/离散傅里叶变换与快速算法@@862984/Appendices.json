{"hands_on_practices": [{"introduction": "理论的美妙之处往往在于其在实践中的高效应用。离散傅里叶变换 (DFT) 的一个核心性质是，当输入信号为实数时，其输出频谱具有埃尔米特对称性。本练习旨在将这一基本数学原理转化为具体的计算优势：设计一种紧凑的存储方案，以减半的存储空间表示完整的频谱信息。通过完成此练习 [@problem_id:3381085]，您将深入理解实数输入 FFT 算法的内部工作原理，这是许多高性能科学计算库中的标准优化技术。", "problem": "给定一个长度为 $N$ 的实值序列及其离散傅里叶变换 (DFT)，其正变换定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n\\,e^{-2\\pi i kn/N},\\quad k=0,1,\\dots,N-1,\n$$\n逆变换定义为\n$$\nx_n = \\frac{1}{N}\\sum_{k=0}^{N-1} X_k\\,e^{2\\pi i kn/N},\\quad n=0,1,\\dots,N-1.\n$$\n角度应以弧度为单位。对于实数输入 $x_n\\in\\mathbb{R}$，DFT 遵循厄米对称性：\n$$\nX_{N-k} = \\overline{X_k},\\quad k=1,2,\\dots,N-1,\n$$\n当 $N$ 为偶数时，奈奎斯特频率点满足 $X_{N/2}\\in\\mathbb{R}$，而对于所有 $N$，$X_0\\in\\mathbb{R}$。\n\n任务：设计一种存储布局，将实值序列 DFT 中的非冗余信息打包到一个长度为 $N$ 的实数数组中（即，恰好 $N$ 个实数）。该布局必须编码由厄米对称性产生的所有 DFT 自由度。推导逆向解包算法，该算法能从这个打包的实数数组中重构出完整的复数频谱 $\\{X_k\\}_{k=0}^{N-1}$，需要同时考虑 $N$ 为偶数和奇数两种情况，并基于上述定义和性质从第一性原理证明其正确性。\n\n您的程序必须实现以下功能：\n- 一个函数，接收一个实数输入序列的完整复数频谱 $\\{X_k\\}_{k=0}^{N-1}$，并根据您设计的布局返回长度为 $N$ 的打包实数数组。\n- 一个函数，接收这样一个打包数组和 $N$，并使用您的逆向解包算法重构完整的复数频谱 $\\{X_k\\}_{k=0}^{N-1}$，同时强制满足厄米对称性以及 $X_0$ 和（如果 $N$ 为偶数）$X_{N/2}$ 为实数的特殊情况。\n- 一个验证程序，对每个测试用例，计算给定实数序列的正向 DFT，将其打包，解包为完整频谱，应用逆向 DFT，并将重构的实数序列与原始序列进行比较。比较必须使用最大绝对重构误差，并且当且仅当此误差小于或等于 $10^{-10}$ 时，才声明测试通过。\n\n测试套件：\n使用以下四个测试用例，它们测试了问题的不同方面，包括边界情况。\n1. $N=1$，其中 $x_0=3.5$。\n2. $N=2$，其中 $x_0=1.0$，$x_1=-2.0$。\n3. $N=7$，其中 $x_n = 0.3 + \\cos\\!\\big(2\\pi\\cdot 1\\cdot n/7\\big) + 0.5\\,\\sin\\!\\big(2\\pi\\cdot 2\\cdot n/7\\big)$，对于 $n=0,1,\\dots,6$。\n4. $N=8$，其中 $x_n = 0.1 + 1.25\\,\\cos\\!\\big(2\\pi\\cdot 3\\cdot n/8\\big) + 2.0\\,\\cos\\!\\big(\\pi\\cdot n\\big) + 0.75\\,\\sin\\!\\big(2\\pi\\cdot 1\\cdot n/8\\big)$，对于 $n=0,1,\\dots,7$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目都是一个布尔值，指示相应的测试用例是否通过（例如，$[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]$）。所有角度都必须以弧度为单位，不涉及任何物理单位。最终输出仅为布尔值。", "solution": "该问题要求设计一种存储布局以及相应的打包/解包算法，以使用恰好 $N$ 个实数来表示长度为 $N$ 的实值序列的离散傅里叶变换 (DFT)。必须从第一性原理证明算法的正确性。\n\n一个实值序列 $\\{x_n\\}_{n=0}^{N-1}$（其中 $x_n \\in \\mathbb{R}$）的 DFT $\\{X_k\\}_{k=0}^{N-1}$ 具有厄米对称性。此性质是紧凑存储方案的基础。该对称性表示为：\n$$\nX_{N-k} = \\overline{X_k}, \\quad k=1, 2, \\dots, N-1\n$$\n其中 $\\overline{X_k}$ 表示 $X_k$ 的复共轭。此外，两个特定的频率分量具有特殊性质：\n1.  直流分量 $X_0 = \\sum_{n=0}^{N-1} x_n$ 始终为实数，因为所有 $x_n$ 都是实数。\n2.  对于偶数长度 $N$，奈奎斯特分量 $X_{N/2} = \\sum_{n=0}^{N-1} x_n e^{-i\\pi n} = \\sum_{n=0}^{N-1} x_n (-1)^n$ 也始终为实数。\n\n这些性质意味着 $N$ 个复数 $X_k$（代表 $2N$ 个实数值）并非全部独立。独立实数值（自由度）的总数恰好为 $N$，我们现在对此进行论证。\n\n**自由度分析**\n\n让我们计算定义频谱 $\\{X_k\\}$ 所需的独立实数值的数量。我们考虑长度 $N$ 的两种情况。\n\n情况1：$N$ 为偶数。设 $N=2M$，其中 $M \\ge 1$ 为某个整数。\n-   $X_0$ 是实数，贡献 $1$ 个自由度。\n-   $X_M = X_{N/2}$ 是实数，贡献 $1$ 个自由度。\n-   其余系数通过对称关系配对。这些对是 $(X_k, X_{N-k})$，其中 $k=1, 2, \\dots, M-1$。共有 $M-1$ 个这样的对。对于每一对，$X_{N-k}$ 完全由 $X_k$ 决定。因此，我们只需要存储 $X_k = \\mathrm{Re}(X_k) + i\\,\\mathrm{Im}(X_k)$，它有 $2$ 个自由度（其实部和虚部）。\n-   自由度总数为 $1 \\text{ (对于 } X_0) + 1 \\text{ (对于 } X_M) + 2(M-1) \\text{ (对于配对)} = 2 + 2M - 2 = 2M = N$。\n\n情况2：$N$ 为奇数。设 $N=2M+1$，其中 $M \\ge 0$ 为某个整数。\n-   $X_0$ 是实数，贡献 $1$ 个自由度。\n-   没有保证为实数的奈奎斯特分量。\n-   系数通过对称性配对为 $(X_k, X_{N-k})$，其中 $k=1, 2, \\dots, M$。共有 $M$ 个这样的对。对于每一对，我们只需要存储一个复系数，例如 $X_k$，贡献 $2$ 个自由度。\n-   自由度总数为 $1 \\text{ (对于 } X_0) + 2M \\text{ (对于配对)} = 1 + 2M = N$。\n\n在 $N$ 为偶数和奇数两种情况下，长度为 $N$ 的实数序列的 DFT 都由恰好 $N$ 个实数唯一确定。我们的任务是设计一个从这些自由度到长度为 $N$ 的实值数组的映射。\n\n**存储布局与打包算法**\n\n我们为长度为 $N$ 的实值打包数组 $P$ 提出以下布局。该布局是高效的，因为它对低频分量的实部和虚部使用了连续的内存块。\n\n设 $P$ 是一个长度为 $N$ 的实数数组。打包算法如下：\n1.  直流分量 $X_0$ 是实数。将其存储在 $P$ 的第一个元素中：\n    $P[0] = \\mathrm{Re}(X_0)$。\n2.  对于直至奈奎斯特频率（或刚好低于它）的正频率分量，存储其实部和虚部。此类复数分量的数量为 $\\lfloor (N-1)/2 \\rfloor$。对于 $k = 1, 2, \\dots, \\lfloor (N-1)/2 \\rfloor$：\n    -   存储实部：$P[k] = \\mathrm{Re}(X_k)$。\n    -   存储虚部：$P[N-k] = \\mathrm{Im}(X_k)$。\n3.  如果 $N$ 是偶数，则还有一个剩余的自由度 $\\mathrm{Re}(X_{N/2})$，以及数组中一个未使用的位置 $P[N/2]$。将实的奈奎斯特分量存储在此处：\n    $P[N/2] = \\mathrm{Re}(X_{N/2})$。\n\n该方案完全填充了长度为 $N$ 的数组 $P$，没有任何重叠。例如，对于奇数 $N=2M+1$，索引 $N-k$ 的范围从 $N-1$ 到 $N-M = M+1$，而 $k$ 的范围从 $1$ 到 $M$。使用的索引是 $0, \\{1,\\dots,M\\}, \\{M+1,\\dots,N-1\\}$，这覆盖了从 $0$ 到 $N-1$ 的所有索引。对于偶数 $N=2M$，配对的 $k$ 从 $1$ 到 $M-1$。配对使用的索引是 $\\{1,\\dots,M-1\\}$ 和 $\\{N-1, \\dots, N-(M-1)\\}=\\{M+1,\\dots,2M-1\\}$。包括索引 $0$ 和索引 $M=N/2$ 即可覆盖所有索引。\n\n**逆向解包算法**\n\n为了从打包数组 $P$ 中重构完整的复数频谱 $\\{X_k\\}_{k=0}^{N-1}$，我们反转打包过程。设重构后的频谱为 $X'$。\n\n1.  将 $X'$ 初始化为长度为 $N$ 的复值数组。\n2.  重构直流分量：\n    $X'[0] = P[0] + 0i$。\n3.  重构复共轭对。对于 $k=1, 2, \\dots, \\lfloor (N-1)/2 \\rfloor$：\n    -   组合存储的实部和虚部以形成 $X'_k$：\n        $X'[k] = P[k] + i P[N-k]$。\n    -   使用厄米对称性找到其共轭对 $X'_{N-k}$：\n        $X'[N-k] = \\overline{X'[k]} = P[k] - i P[N-k]$。\n4.  如果 $N$ 是偶数，重构实值的奈奎斯特分量：\n    $X'[N/2] = P[N/2] + 0i$。\n\n**正确性证明**\n\n该设计的正确性基于这样一个事实：它在实信号的有效 DFT 频谱集合与长度为 $N$ 的打包实数数组之间建立了一个无损的一一对应关系（一个双射）。\n-   **信息保持**：打包算法存储了定义频谱的所有 $N$ 个独立实数值。没有信息丢失。\n-   **对称性强制**：解包算法重构的频谱 $X'$，根据其构造，严格遵守其逆变换为实值的必要条件：\n    -   $X'[0]$ 是实数。\n    -   如果 $N$ 是偶数，$X'[N/2]$ 是实数。\n    -   对于所有 $k=1, \\dots, N-1$，强制满足属性 $X'[N-k] = \\overline{X'[k]}$。\n-   **可逆性**：应用打包算法后再应用解包算法是一个恒等操作。如果我们从一个有效的频谱 $X$ 开始，我们将得到 $X' = X$。因此，对重构的频谱 $X'$ 应用逆向 DFT 将产生原始的实值序列 $x_n$，其精度受限于浮点精度。整个过程是一个有效且可逆的变换。这证实了所提出的存储布局及其相关算法的正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef pack_dft(X: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Packs the DFT of a real sequence into a real array of length N.\n    \n    The layout is:\n    - P[0] = Re(X[0])\n    - P[k] = Re(X[k]) for k=1..floor((N-1)/2)\n    - P[N-k] = Im(X[k]) for k=1..floor((N-1)/2)\n    - P[N/2] = Re(X[N/2]) if N is even\n    \n    Args:\n        X (np.ndarray): The full complex DFT spectrum of length N.\n\n    Returns:\n        np.ndarray: The packed real array of length N.\n    \"\"\"\n    N = len(X)\n    P = np.zeros(N, dtype=np.float64)\n\n    # Store the DC component (always real)\n    P[0] = X[0].real\n\n    # Store real and imaginary parts for k=1...floor((N-1)/2)\n    # This range handles both even and odd N correctly for the paired components.\n    num_pairs = (N - 1) // 2\n    for k in range(1, num_pairs + 1):\n        P[k] = X[k].real\n        P[N - k] = X[k].imag\n\n    # If N is even, store the Nyquist component (always real)\n    if N % 2 == 0:\n        if N > 0: # Guard for N=0 case, though not in test suite\n            P[N // 2] = X[N // 2].real\n            \n    return P\n\ndef unpack_dft(P: np.ndarray, N: int) -> np.ndarray:\n    \"\"\"\n    Unpacks a real array into the full complex DFT spectrum, enforcing Hermitian symmetry.\n\n    Args:\n        P (np.ndarray): The packed real array of length N.\n        N (int): The length of the spectrum to reconstruct.\n\n    Returns:\n        np.ndarray: The reconstructed full complex spectrum of length N.\n    \"\"\"\n    X_re = np.zeros(N, dtype=np.complex128)\n\n    # Reconstruct the DC component\n    X_re[0] = P[0]\n\n    # Reconstruct complex conjugate pairs\n    num_pairs = (N - 1) // 2\n    for k in range(1, num_pairs + 1):\n        real_part = P[k]\n        imag_part = P[N - k]\n        X_re[k] = real_part + 1j * imag_part\n        # Enforce Hermitian symmetry\n        X_re[N - k] = real_part - 1j * imag_part\n\n    # If N is even, reconstruct the real Nyquist component\n    if N % 2 == 0:\n        if N > 0:\n            X_re[N // 2] = P[N // 2]\n            \n    return X_re\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases.\n    \"\"\"\n    test_cases = [\n        # (N, function to generate sequence x_n)\n        (1, lambda n: np.array([3.5])),\n        (2, lambda n: np.array([1.0, -2.0])),\n        (7, lambda n: 0.3 + np.cos(2 * np.pi * 1 * n / 7) + 0.5 * np.sin(2 * np.pi * 2 * n / 7)),\n        (8, lambda n: 0.1 + 1.25 * np.cos(2 * np.pi * 3 * n / 8) + 2.0 * np.cos(np.pi * n) + 0.75 * np.sin(2 * np.pi * 1 * n / 8))\n    ]\n\n    results = []\n    error_threshold = 1e-10\n\n    for N, x_func in test_cases:\n        # Step 1: Generate the original real sequence\n        if N > 1:\n            n_vals = np.arange(N)\n            x_original = x_func(n_vals)\n        else: # Handle N=1 case where arange is not needed\n            x_original = x_func(0)\n\n        # Step 2: Compute the forward DFT\n        X_full = np.fft.fft(x_original)\n\n        # Step 3: Pack the DFT spectrum\n        P_packed = pack_dft(X_full)\n\n        # Step 4: Unpack to reconstruct the spectrum\n        X_reconstructed = unpack_dft(P_packed, N)\n\n        # Step 5: Apply the inverse DFT\n        x_reconstructed = np.fft.ifft(X_reconstructed)\n        \n        # Result of IFFT on a Hermitian-symmetric spectrum is real.\n        # Take .real to discard negligible imaginary parts from floating-point errors.\n        x_reconstructed_real = x_reconstructed.real\n\n        # Step 6: Compare reconstructed sequence to original\n        max_abs_error = np.max(np.abs(x_original - x_reconstructed_real))\n\n        # Step 7: Check if the test passes and record result\n        passed = max_abs_error = error_threshold\n        results.append(passed)\n\n    # Final print statement in the exact required format.\n    # The map(str,...) converts boolean True/False to \"True\"/\"False\" strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3381085"}, {"introduction": "从一维到多维的跨越不仅是维度的增加，更带来了全新的计算挑战，尤其是在现代计算机体系结构下。本练习探讨了二维 DFT 的高效实现，其核心挑战在于如何处理非单位步长的内存访问模式，这种模式会严重降低缓存性能。通过实现一个基于转置的二维 FFT 算法 [@problem_id:3381024]，您将学习如何将可分离变换的数学思想与“硬件感知”的算法设计相结合，从而在解决实际问题时最大化计算效率。", "problem": "考虑在谱方法和间断伽辽金 (DG) 方法中出现的张量积网格上的二维离散傅里叶变换 (DFT)。设 $X \\in \\mathbb{C}^{n_y \\times n_x}$ 是一个以行主序存储的复数数组，这意味着对于 $0 \\le j  n_y$，$0 \\le i  n_x$ 的条目 $(j,i)$ 的线性内存索引为 $p = j\\,n_x + i$。$X$ 的二维 DFT 是数组 $Y \\in \\mathbb{C}^{n_y \\times n_x}$，定义为\n$$\nY_{k,\\ell} = \\sum_{j=0}^{n_y-1} \\sum_{i=0}^{n_x-1} X_{j,i} \\, e^{-2\\pi \\mathrm{i} \\frac{k j}{n_y}} \\, e^{-2\\pi \\mathrm{i} \\frac{\\ell i}{n_x}}, \\quad $0 \\le k  n_y, \\; 0 \\le \\ell  n_x$,\n$$\n其中 $\\mathrm{i}$ 是虚数单位。此变换是可分离的，可以使用一维 DFT 矩阵 $F_{n_y} \\in \\mathbb{C}^{n_y \\times n_y}$ 和 $F_{n_x} \\in \\mathbb{C}^{n_x \\times n_x}$ 以矩阵形式表示为\n$$\nY = F_{n_y} \\, X \\, F_{n_x}^{\\top}.\n$$\n等效地，使用克罗内克积，向量化映射满足\n$$\n\\operatorname{vec}(Y) = \\left(F_{n_x} \\otimes F_{n_y}\\right) \\operatorname{vec}(X),\n$$\n其中 $\\operatorname{vec}(\\cdot)$ 堆叠列，$\\otimes$ 表示克罗内克积。快速傅里叶变换 (FFT) 通过利用递归基数分解，在 $O(n \\log n)$ 次运算内计算一维 DFT。\n\n在行主序内存中，一个朴素的两遍调度方案首先沿行（单位步长访问）应用长度为 $n_x$ 的一维 FFT，然后沿列（步长为 $n_x$ 的访问）应用长度为 $n_y$ 的一维 FFT，由于列的连续元素在线性内存中相隔 $n_x$，该方案在列处理阶段存在缓存局部性差的问题。通过交错转置操作可以改善缓存局部性，从而使两个一维 FFT 过程都以单位步长遍历内存。您的任务是设计用于计算具有良好缓存局部性的原地二维 FFT 的过程和转置序列，并从二维 DFT 的可分离性和行主序内存映射等第一性原理出发，论证您的选择。设计应最小化 FFT 过程中的非单位步长内存访问，并应使用分块转置来最大化空间局部性。\n\n程序要求：\n- 实现以下序列以计算 $Y = F_{n_y} \\, X \\, F_{n_x}^{\\top}$：\n  $1$) 沿 $X$ 的行应用长度为 $n_x$ 的一维 FFT，生成 $X^{(1)}$。\n  $2$) 应用块大小为 $(b_y, b_x)$ 的分块转置，得到形状为 $n_x \\times n_y$ 的 $T = \\left(X^{(1)}\\right)^{\\top}$。\n  $3$) 沿 $T$ 的行应用长度为 $n_y$ 的一维 FFT，生成 $T^{(1)}$（这对应于对 $X$ 的列进行 FFT）。\n  $4$) 应用分块转置，将其转置回原始方向 $Y = \\left(T^{(1)}\\right)^{\\top}$。\n- 通过与沿 $X$ 的两个轴应用内置一维 FFT 计算的直接二维 FFT 进行比较，验证数值正确性。\n- 对于每个测试用例，报告：\n  $1$) 设计序列结果与直接二维 FFT 结果之间的最大绝对误差，以浮点数形式表示，以及\n  $2$) 一个缓存局部性改进度量，定义为在朴素的两遍调度（先行后列，无转置）中遇到的最大步长与在基于转置的调度中遇到的最大步长之比。在行主序布局中，朴素的最大步长为 $n_x$，改进后的最大步长为 $1$，因此该度量等于 $n_x$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且本身是一个双元素列表 $[\\,\\text{error},\\,\\text{improvement}\\,]$。\n\n测试套件：\n使用以下测试用例 $(n_x, n_y, b_x, b_y, s)$，其中 $s$ 是用于可复现性的随机种子：\n- 情况 1：$(64, 32, 8, 8, 0)$。\n- 情况 2：$(1, 128, 16, 16, 1)$。\n- 情况 3：$(30, 45, 10, 9, 2)$。\n- 情况 4：$(17, 31, 8, 8, 3)$。\n\n三角因子中的所有角度均以弧度为单位。不涉及物理单位。最终输出必须是浮点数。您的程序必须是自包含的，且不得从用户或外部文件读取输入。在您的解决方案的推导部分，应论证过程和转置的序列。", "solution": "该问题要求设计并实现一种缓存高效的算法，用于计算存储在行主序内存布局中的复值矩阵 $X \\in \\mathbb{C}^{n_y \\times n_x}$ 的二维离散傅里叶变换 (DFT)。设计的核心是论证并实现一个操作序列，将计算成本高昂的非单位步长内存访问模式转换为一系列单位步长操作。\n\n$X$ 的二维 DFT 定义为矩阵 $Y \\in \\mathbb{C}^{n_y \\times n_x}$，其条目为：\n$$\nY_{k,\\ell} = \\sum_{j=0}^{n_y-1} \\sum_{i=0}^{n_x-1} X_{j,i} \\, e^{-2\\pi \\mathrm{i} \\frac{k j}{n_y}} \\, e^{-2\\pi \\mathrm{i} \\frac{\\ell i}{n_x}}, \\quad \\text{for } $0 \\le k  n_y, \\; 0 \\le \\ell  n_x$\n$$\n其中 $\\mathrm{i}$ 是虚数单位。指数核是可分离的，这使得双重求和可以分解为两个连续的步骤。我们可以首先对每行 $j$ 的索引 $i$ 进行求和，然后对每列 $\\ell$ 的索引 $j$ 进行求和。\n\n让我们通过对 $X$ 的每一行执行长度为 $n_x$ 的一维 DFT 来定义一个中间矩阵 $X^{(1)} \\in \\mathbb{C}^{n_y \\times n_x}$：\n$$\nX^{(1)}_{j,\\ell} = \\sum_{i=0}^{n_x-1} X_{j,i} \\, e^{-2\\pi \\mathrm{i} \\frac{\\ell i}{n_x}}\n$$\n此操作对应于矩阵乘积 $X^{(1)} = X F_{n_x}^{\\top}$，其中 $F_{n_x}$ 是大小为 $n_x \\times n_x$ 的一维 DFT 矩阵，其 $(\\ell, i)$ 项为 $e^{-2\\pi \\mathrm{i} \\frac{\\ell i}{n_x}}$。\n\n然后通过对中间矩阵 $X^{(1)}$ 的每一列执行长度为 $n_y$ 的一维 DFT 来获得最终结果 $Y$：\n$$\nY_{k,\\ell} = \\sum_{j=0}^{n_y-1} X^{(1)}_{j,\\ell} \\, e^{-2\\pi \\mathrm{i} \\frac{k j}{n_y}}\n$$\n这对应于矩阵乘积 $Y = F_{n_y} X^{(1)}$。将这两个步骤结合起来，就证实了问题陈述中给出的表达式：$Y = F_{n_y} X F_{n_x}^{\\top}$。\n\n这种可分离性导出了一个朴素的两遍算法：\n1.  对 $X$ 的 $n_y$ 行中的每一行应用长度为 $n_x$ 的一维快速傅里叶变换 (FFT)。\n2.  对得到的矩阵 $X^{(1)}$ 的 $n_x$ 列中的每一列应用长度为 $n_y$ 的一维 FFT。\n\n现在，我们分析以行主序存储的矩阵的内存访问模式。在这种布局中，元素 $X_{j,i}$ 的线性内存索引是 $p = j \\cdot n_x + i$。\n- 在第一遍（行向 FFT）中，一行 $j$ 的元素 $(X_{j,0}, X_{j,1}, \\dots, X_{j,n_x-1})$ 位于连续的内存地址。访问这些元素涉及的内存步长为 $1$，这对于现代 CPU 缓存是理想的（表现出高度的空间局部性）。\n- 在第二遍（列向 FFT）中，一列 $\\ell$ 的元素 $(X^{(1)}_{0,\\ell}, X^{(1)}_{1,\\ell}, \\dots, X^{(1)}_{n_y-1,\\ell})$ 位于以 $n_x$ 为步长分隔的内存地址。$X^{(1)}_{j,\\ell}$ 的地址是 $j \\cdot n_x + \\ell$，列中下一个元素 $X^{(1)}_{j+1,\\ell}$ 的地址是 $(j+1) \\cdot n_x + \\ell$。如果 $n_x$ 很大，这种非单位步长访问模式会导致缓存性能不佳，因为每次内存访问都可能获取不同的缓存行，而其中只有一个元素被使用，从而导致高缓存未命中率。\n\n为了缓解这一性能瓶颈，我们可以交错进行矩阵转置操作，以确保两个 FFT 过程都以单位步长操作数据。提出的改进算法如下：\n1.  **行向 FFT**：通过沿 $X$ 的行应用长度为 $n_x$ 的 FFT 来计算 $X^{(1)} = X F_{n_x}^{\\top}$。此步骤具有单位步长内存访问，是缓存友好的。\n2.  **转置**：计算中间矩阵的转置，$T = (X^{(1)})^{\\top}$。现在，$X^{(1)}$ 的列已成为 $T$ 的行。矩阵 $T$ 的维度为 $n_x \\times n_y$。\n3.  **对转置矩阵进行行向 FFT**：沿 $T$ 的行应用长度为 $n_y$ 的 FFT，得到 $T^{(1)} = T F_{n_y}^{\\top}$。由于我们再次沿行（$T$ 的行）操作，此步骤也具有单位步长内存访问。此步骤在数学上等同于对 $X^{(1)}$ 的列执行 FFT。\n4.  **转置回来**：将结果转置回原始方向，$Y = (T^{(1)})^{\\top}$，以获得最终的 $n_y \\times n_x$ 结果矩阵。\n\n让我们验证这个序列的数学正确性。\n$$\nY = (T^{(1)})^{\\top} = (T F_{n_y}^{\\top})^{\\top}\n$$\n使用属性 $(AB)^{\\top} = B^{\\top}A^{\\top}$，我们有：\n$$\nY = (F_{n_y}^{\\top})^{\\top} T^{\\top} = F_{n_y} T^{\\top}\n$$\n代入 $T = (X^{(1)})^{\\top}$：\n$$\nY = F_{n_y} ((X^{(1)})^{\\top})^{\\top} = F_{n_y} X^{(1)}\n$$\n最后，代入 $X^{(1)} = X F_{n_x}^{\\top}$：\n$$\nY = F_{n_y} (X F_{n_x}^{\\top}) = F_{n_y} X F_{n_x}^{\\top}\n$$\n这证实了基于转置的序列正确地计算了二维 DFT。\n\n如果朴素地实现，转置操作本身也可能遭受缓存局部性差的问题。将矩阵 $A$ 朴素转置为 $B$ 涉及读取 $A_{j,i}$ 并写入 $B_{i,j}$。如果我们在内循环中遍历 $i$，那么从 $A$ 的读取是单位步长的，但对 $B$ 的写入是非单位步长的。为了优化这一点，使用了**分块转置**。矩阵被划分为大小为 $b_y \\times b_x$ 的更小的矩形块。理想情况下，每个块都足够小，可以装入 CPU 缓存。从源矩阵中加载一个块到缓存中，在本地进行转置（此时所有需要的数据都已准备好访问），然后写回其目标位置。与朴素的全矩阵转置相比，这种技术最大化了缓存内的数据重用，并显著减少了缓存未命中。\n\n缓存局部性改进度量定义为朴素调度中的最大步长与基于转置的调度中的最大步长之比。\n- 在朴素调度中，最大步长出现在列向 FFT 过程中，等于 $n_x$。\n- 在基于转置的调度中，两个 FFT 过程都沿行操作，因此 FFT 计算的步长始终为 $1$。问题陈述仅根据 FFT 过程来定义此调度的步长。\n- 因此，改进度量为 $\\frac{\\text{最大步长 (朴素)}}{\\text{最大步长 (改进)}} = \\frac{n_x}{1} = n_x$。该度量通过将 FFT 计算本身重构为完全缓存友好的方式来量化性能增益。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, fft2\n\ndef blocked_transpose(arr: np.ndarray, block_h: int, block_w: int) - np.ndarray:\n    \"\"\"\n    Performs a blocked (tiled) transpose of a 2D numpy array.\n\n    Args:\n        arr (np.ndarray): The input 2D array to transpose.\n        block_h (int): The height of the blocks.\n        block_w (int): The width of the blocks.\n\n    Returns:\n        np.ndarray: The transposed array.\n    \"\"\"\n    h, w = arr.shape\n    transposed_arr = np.empty((w, h), dtype=arr.dtype)\n\n    for j in range(0, h, block_h):\n        for i in range(0, w, block_w):\n            # Define the slice for the source block, handling boundary cases\n            j_end = min(j + block_h, h)\n            i_end = min(i + block_w, w)\n            block = arr[j:j_end, i:i_end]\n\n            # Transpose the block and place it in the destination array\n            transposed_arr[i:i_end, j:j_end] = block.T\n            \n    return transposed_arr\n\ndef solve():\n    \"\"\"\n    Solves the 2D FFT problem for the given test cases.\n    It implements a cache-efficient 2D FFT using transposes and compares it\n    to a direct 2D FFT to verify correctness and calculate a performance metric.\n    \"\"\"\n    # Test cases: (nx, ny, bx, by, seed)\n    test_cases = [\n        (64, 32, 8, 8, 0),\n        (1, 128, 16, 16, 1),\n        (30, 45, 10, 9, 2),\n        (17, 31, 8, 8, 3),\n    ]\n\n    results = []\n    for nx, ny, bx, by, seed in test_cases:\n        # Generate a reproducible random complex array\n        rng = np.random.default_rng(seed)\n        X = rng.random((ny, nx)) + 1j * rng.random((ny, nx))\n\n        # --- Reference solution: Direct 2D FFT ---\n        # scipy.fft.fft2 computes the DFT as defined in the problem\n        Y_direct = fft2(X)\n\n        # --- Transpose-based 2D FFT implementation ---\n        # 1. Apply length-nx 1D FFTs along rows of X\n        # axis=1 for row-wise operations in a (ny, nx) matrix\n        X1 = fft(X, axis=1)\n\n        # 2. Apply a blocked transpose with tile sizes (by, bx)\n        T = blocked_transpose(X1, by, bx)\n\n        # 3. Apply length-ny 1D FFTs along rows of T\n        # T has shape (nx, ny), so axis=1 is the correct dimension\n        T1 = fft(T, axis=1)\n\n        # 4. Apply a blocked transpose back. The matrix T1 has shape (nx, ny),\n        # so the blocks on it are of size (bx, by).\n        Y_computed = blocked_transpose(T1, bx, by)\n\n        # --- Calculate required metrics ---\n        # 1. Maximum absolute error between the two results\n        max_abs_error = np.max(np.abs(Y_computed - Y_direct))\n\n        # 2. Cache-locality improvement metric\n        # Naive max stride = nx (column FFTs on row-major data)\n        # Improved max stride = 1 (all FFTs are row-wise)\n        # Ratio = nx / 1 = nx\n        improvement_metric = float(nx)\n        \n        results.append([max_abs_error, improvement_metric])\n\n    # Final print statement in the exact required format.\n    # str() on a list produces the required \"[item1, item2]\" format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3381024"}, {"introduction": "离散傅里叶变换不仅是信号分析的工具，更是求解偏微分方程的强大引擎，尤其是在谱方法中。本练习将带您进入伪谱方法的核心，探索如何利用 FFT 精确计算函数的导数，并解决一个关键难题：非线性项的处理。通过亲手实现和比较混叠与去混叠技术（如“3/2规则”）[@problem_id:3381044]，您将掌握在谱域中正确处理非线性问题的关键技能，这对于任何使用谱方法进行数值模拟的研究人员来说都至关重要。", "problem": "考虑一个实值 $2\\pi$-周期函数 $u(x)$，在 $N$ 个等距配置点 $x_j = 2\\pi j/N$（其中 $j = 0,1,\\dots,N-1$）上进行采样。设离散傅里叶变换 (DFT) 对定义如下：\n$$\n\\widehat{u}_k = \\sum_{j=0}^{N-1} u(x_j)\\, e^{-2\\pi i\\, j k/N}, \\quad\nu(x_j) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\widehat{u}_k\\, e^{2\\pi i\\, j k/N}.\n$$\n与第 $k$ 个 DFT 箱相关的波数对应于在 $2\\pi$ 周期域上解释的整数 $k$。也就是说，角波数是离散傅里叶变换指数在上述约定下的标准映射所返回频率的 $2\\pi$ 倍。对于偶数 $N$，整数波数值为 $k \\in \\{0,1,\\dots,N/2-1,-N/2,\\dots,-1\\}$。\n\n谱方法微分定义为：变换到傅里叶空间，乘以 $i k$，然后逆变换回来：\n$$\n\\mathcal{D}_x[u](x) \\approx \\mathcal{F}^{-1}\\left\\{ i\\,k\\,\\widehat{u}_k \\right\\}(x).\n$$\n对于非线性乘积，伪谱法在物理空间中计算乘积，然后变换回傅里叶空间。当傅里叶模式的卷积超出网格的可分辨范围时，这会引入混叠效应。两种经典的去混叠策略是：\n- “3/2 法则”补零：将谱分辨率临时提高 $3/2$ 倍，在更高的分辨率下计算乘积，然后截断回 $N$ 个模式。\n- “2/3 法则”截断：在原始网格上计算二次乘积之前，将所有 $|k|  \\lfloor N/3 \\rfloor$ 的模式置零。\n\n从上述 DFT 对和 $2\\pi$ 周期傅里叶级数解释出发，实现以下内容：\n1. 通过 DFT 实现谱方法微分，并与解析导数进行比较以验证其准确性。\n2. 对 $u(x)^2$ 进行伪谱法评估，并在傅里叶系数层面上演示混叠与“3/2 法则”去混叠的对比。\n3. 当初始谱包含在 2/3 带宽内时，对于二次乘积，在已解析的低频模式上，“3/2 法则”和“2/3 法则”的等价性。\n4. 对非线性通量导数 $\\partial_x\\left(\\tfrac{1}{2}u(x)^2\\right) = u(x)\\,u_x(x)$ 进行伪谱法评估，将混叠计算与正确去混叠的计算进行比较，并使用精确结果的解析表达式。\n\n您的程序必须实现以下测试套件并生成所要求的输出。角度以弧度为单位，不涉及物理单位。\n\n测试套件：\n- 测试 A (谱方法微分准确性)：\n  - 定义域 $[0,2\\pi)$，$N \\in \\{16, 32, 64\\}$。\n  - 函数 $u(x) = \\sin(3x) + 0.5 \\cos(5x)$。\n  - 在配置点上计算谱方法导数 $\\mathcal{D}_x[u](x)$ 和解析导数 $u_x(x)$。\n  - 对每个 $N$，输出最大绝对误差 $\\max_j | \\mathcal{D}_x[u](x_j) - u_x(x_j) |$，作为三个独立的浮点数。\n\n- 测试 B (在傅里叶系数层面上 $u^2$ 中的混叠与“3/2 法则”去混叠)：\n  - 定义域 $[0,2\\pi)$，$N = 16$。\n  - 函数 $u(x) = \\cos(6x) + \\cos(7x)$。\n  - 通过以下方式计算 $u^2$ 的傅里叶系数：\n    - 混叠伪谱法：在 $N$ 点网格上计算 $u(x_j)^2$，然后应用 DFT 得到 $\\widehat{(u^2)}^{\\mathrm{alias}}_k$。\n    - 去混叠的“3/2 法则”：通过 $3/2$ 因子构建一个补零谱，在填充后的网格上计算 $u^2$，逆变换回来，并截断为 $N$ 个模式以获得 $\\widehat{(u^2)}^{3/2}_k$。补零和截断必须保持与给定 DFT 对一致的傅里叶级数归一化。\n  - 输出长度为 $N$ 的系数向量之差的欧几里得范数，即 $\\left\\| \\widehat{(u^2)}^{\\mathrm{alias}} - \\widehat{(u^2)}^{3/2} \\right\\|_2$，作为一个浮点数。\n\n- 测试 C (二次乘积在低频模式上“3/2 法则”与“2/3 法则”的等价性)：\n  - 定义域 $[0,2\\pi)$，$N = 24$。\n  - 函数 $u(x) = \\cos(7x) + 0.5 \\sin(6x)$。\n  - 令 $K_c = \\lfloor N/3 \\rfloor$。\n  - 使用以下方法计算 $u^2$ 的傅里叶系数：\n    - “3/2 法则”补零方法，截断回 $N$ 个模式。\n    - “2/3 法则”：在原始网格上，将 $\\widehat{u}_k$ 中 $|k|  K_c$ 的模式置零，逆变换到物理空间，求平方，然后变换回来；接着在结果中将 $|k|  K_c$ 的模式置零。\n  - 仅比较 $|k| \\le K_c$ 的低频模式。输出这些模式间的最大绝对差，作为一个浮点数。\n\n- 测试 D (混叠与去混叠的非线性通量导数)：\n  - 定义域 $[0,2\\pi)$，$N = 32$。\n  - 函数 $u(x) = \\sin(9x) + 0.4 \\cos(8x)$。\n  - 精确通量导数：$u(x)\\,u_x(x)$，其中 $u_x(x)$ 是解析导数。\n  - 混叠计算：在 $N$-网格上用谱方法计算 $u_x$，在物理空间中形成 $u\\,u_x$，并与配置点上的精确值进行比较。输出均方根误差 $\\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} \\left( u(x_j)u_x(x_j) - [u\\,u_x]^{\\mathrm{alias}}(x_j)\\right)^2}$，作为一个浮点数。\n  - 去混叠的“3/2 法则”计算：为 $u\\,u_x$ 执行一个“3/2 法则”去混叠乘积，方法是填充到 $3N/2$，在填充后的网格上用谱方法求导，在填充后的网格上形成乘积，逆变换回来，截断为 $N$ 个模式，然后逆变换到 $N$-网格。与精确值进行比较，并输出均方根误差，作为一个浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  - 测试 A 中 $N=16$ 的误差\n  - 测试 A 中 $N=32$ 的误差\n  - 测试 A 中 $N=64$ 的误差\n  - 测试 B 的系数向量差的范数\n  - 测试 C 的最大低频模式差\n  - 测试 D 的混叠均方根误差\n  - 测试 D 的去混叠均方根误差\n- 每个数字必须以科学记数法打印，保留十二位有效数字，列表前后不得有任何其他文本。", "solution": "该问题是有效的。它就偏微分方程谱方法这一主题，提出了一套清晰、适定且科学上合理的数值练习。所有必要的定义、参数和评估标准都已提供。这些任务涉及该领域标准、基础技术的实现和验证，例如谱方法微分、处理非线性的伪谱法，以及像“3/2 法则”和“2/3 法则”这样的常用去混叠策略。\n\n问题的核心在于，当使用离散傅里叶变换 (DFT) 来近似周期函数的导数和非线性乘积时，其所表现出的性质。在一个 $2\\pi$ 周期域上的 $N$ 个等距点 $x_j = 2\\pi j/N$ 组成的网格上，函数 $u(x)$ 由其值 $u(x_j)$ 表示。所提供的 DFT 对为：\n$$ \\widehat{u}_k = \\sum_{j=0}^{N-1} u(x_j)\\, e^{-2\\pi i\\, j k/N} $$\n$$ u(x_j) = \\frac{1}{N} \\sum_{k=0}^{N-1} \\widehat{u}_k\\, e^{2\\pi i\\, j k/N} $$\n这些定义分别直接对应于 `numpy.fft.fft` 和 `numpy.fft.ifft` 函数，从而简化了实现。\n\n整数波数 $k$ 是从 DFT 指数映射而来的。对于偶数个点 $N$，波数为 $k \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$。这个集合代表了网格可以解析的频率。最高幅值的波数是奈奎斯特频率， $|k| = N/2$。\n\n**1. 谱方法微分**\n傅里叶级数项 $e^{ikx}$ 的导数是 $ik e^{ikx}$。这个性质可以延伸到 DFT。谱方法导数 $\\mathcal{D}_x[u]$ 的计算方法是：将 $u$ 变换到傅里叶空间得到系数 $\\widehat{u}_k$，将每个系数乘以其对应的有效波数 $ik$，然后逆变换回物理空间：\n$$ (\\mathcal{D}_x[u])_j = \\mathcal{F}^{-1}\\left\\{ i k \\widehat{u}_k \\right\\}_j $$\n对于一个傅里叶级数只包含满足 $|k|  N/2$ 的波数 $k$ 的函数，谱方法导数在机器精度范围内是精确的。这是因为所有分量波都能被网格很好地解析。\n\n**2. 伪谱法与混叠**\n像 $u(x)^2$ 这样的非线性项在傅里叶空间中处理起来很有挑战性。两个函数的乘积对应于其傅里叶系数的卷积：\n$$ \\widehat{(uv)}_k = (\\widehat{u} * \\widehat{v})_k = \\sum_{m=-\\infty}^{\\infty} \\widehat{u}_m \\widehat{v}_{k-m} $$\n直接计算这个卷积的计算成本高昂 ($O(N^2)$)。伪谱法提供了一种高效的替代方案：\n1. 将 $\\widehat{u}_k$ 和 $\\widehat{v}_k$ 变换到物理空间得到 $u(x_j)$ 和 $v(x_j)$ ($O(N\\log N)$)。\n2. 在物理空间中逐点计算乘积：$w(x_j) = u(x_j) v(x_j)$ ($O(N)$)。\n3. 将 $w(x_j)$ 变换回傅里叶空间得到 $\\widehat{w}_k$ ($O(N\\log N)$)。\n\n然而，这种方法会引入混叠误差。如果 $u(x)$ 的模式最高达到波数 $K_{max}$，那么乘积 $u(x)^2$ 将拥有最高达到 $2K_{max}$ 的模式。如果 $2K_{max}$ 超过了网格的奈奎斯特极限 ($N/2$)，高频分量就会“折叠”回低频波数上，从而污染计算出的谱。具体来说，一个真实波数为 $k_{true}$ 的模式会被混叠为 $k_{alias} = k_{true} \\pmod N$。\n\n**3. 去混叠策略**\n为防止混叠，网格必须足够精细，以解析非线性乘积中的最高波数。\n- **“3/2 法则”（补零）：** 这是一种通用的去混叠方法。如果原始函数 $u$ 是带限的，其谱 $\\widehat{u}_k$ 在 $|k|  K$ 时为零，则乘积 $u^2$ 的谱仅在 $|k| \\le 2K$ 范围内非零。为了无混叠地计算这个乘积，我们需要一个奈奎斯特频率大于 $2K$ 的网格，即 $N_{padded}/2  2K$。“3/2 法则”涉及将网格大小临时增加到 $N' = \\lfloor 3N/2 \\rfloor$。原始谱 $\\widehat{u}_k$ 通过补零来创建一个高分辨率谱 $\\widehat{u}^{\\mathrm{pad}}_k$。然后在这个填充后的网格上计算乘积。最后，将得到的谱截断回原始的 $N$ 个模式。如果原始信号的能量包含在 $|k|  N/3$ 内，该方法是有效的，因为这样乘积的能量就在 $|k|2N/3$ 内，这在填充后的网格上是可解析的，因为 $N'/2 \\approx 3N/4  2N/3$。当将 $N$ 点变换的系数填充到 $N'$ 点变换时，必须将其乘以 $N'/N$ 来保持底层连续函数的振幅。当截断回来时，则乘以 $N/N'$。\n\n- **“2/3 法则”（截断）：** 此法则专门适用于二次或三次非线性。对于二次乘积 $u^2$，如果首先通过将所有 $|k|  N/3$ 的模式置零来截断输入谱 $\\widehat{u}_k$，那么在原始 $N$ 点网格上计算的伪谱乘积对于所有 $|k| \\le N/3$ 的模式将具有正确的、未混叠的系数。混叠误差被限制在谱的较高、被截断的部分。对于已经带限在 $|k| \\le N/3$ 的初始谱，该方法对于保留的低频模式而言，等价于“3/2 法则”。\n\n该问题要求在四个测试案例中实现这些概念。\n\n**测试 A：谱方法微分准确性**\n对于 $u(x) = \\sin(3x) + 0.5 \\cos(5x)$，最高波数为 $k=5$。对于网格大小 $N=16, 32, 64$，奈奎斯特频率分别为 $N/2=8, 16, 32$。在所有情况下，$5  N/2$。因此，该函数被很好地解析，谱方法导数 $\\mathcal{D}_x[u]$ 应与解析导数 $u_x(x) = 3\\cos(3x) - 2.5\\sin(5x)$ 在机器精度范围内匹配。最大绝对误差预计会非常小，在 $10^{-14}$ 或更低的数量级。\n\n**测试 B：$u^2$ 中的混叠**\n对于 $u(x) = \\cos(6x) + \\cos(7x)$ 且 $N=16$，输入波数为 $k=6,7$。奈奎斯特频率为 $N/2=8$。二次乘积 $u^2(x)$ 将通过三角恒等式（$\\cos(A)\\cos(B) = \\frac{1}{2}(\\cos(A-B)+\\cos(A+B))$）生成波数为 $k=0, 1, 12, 13, 14$ 的模式。模式 $k=12, 13, 14$ 都大于奈奎斯特频率 $8$。它们将分别混叠为 $k=12-16=-4$，$k=13-16=-3$ 和 $k=14-16=-2$。因此，混叠的伪谱计算将在这些负波数处具有非零系数，而在精确结果中这些系数应为零。在大小为 $N' = 3/2 \\cdot 16 = 24$ 的填充网格上执行的“3/2 法则”去混叠将计算出一个更准确的谱。乘积的最高波数 $k=14$ 超过了填充网格的奈奎斯特极限 $12$，因此仍会存在一些混叠（$k=14$ 混叠为 $14-24=-10$）。然而，混叠模式不同，其结果比在 $N=16$ 网格上的计算更准确。两种方法得到的系数向量之差的范数将非零，从而量化了混叠效应。\n\n**测试 C：“3/2 法则”与“2/3 法则”的等价性**\n对于 $N=24$，“2/3 法则”的截止波数是 $K_c = \\lfloor 24/3 \\rfloor = 8$。函数为 $u(x) = \\cos(7x) + 0.5 \\sin(6x)$。其所有波数（$k=6,7$）都在 $|k| \\le K_c$ 的范围内。根据理论，对于这样的带限输入，在 $|k| \\le K_c$ 的范围内，“3/2 法则”和“2/3 法则”都应该为乘积 $u^2$ 得出精确的傅里叶系数。因此，两种方法在该范围内计算出的系数之间的最大绝对差应接近机器精度。\n\n**测试 D：混叠与去混叠的非线性通量导数**\n非线性通量为 $\\frac{1}{2}u(x)^2$，其导数为 $u(x)u_x(x)$。对于 $u(x) = \\sin(9x) + 0.4 \\cos(8x)$ 且 $N=32$，奈奎斯特频率是 $16$。函数 $u$ 及其导数 $u_x$ 中的波数均为 $8, 9$。乘积 $u u_x$ 将包含最高达 $9+9=18$ 的波数。由于 $18  16$，混叠的伪谱计算（在 $N=32$ 网格上将 $u$ 与其谱方法导数相乘）会因 $k=18$ 模式混叠为 $k=18-32=-14$ 而不正确。与解析结果相比，其均方根误差将非常显著。相比之下，在大小为 $N' = 3/2 \\cdot 32 = 48$ 的网格上使用“3/2 法则”进行的去混叠计算将是准确的。填充后网格的奈奎斯特频率是 $24$，大于乘积的最大波数 $18$。因此，在填充网格上计算的乘积是精确的，最终在 $N=32$ 网格上的去混叠结果的均方根误差将接近机器精度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the specified test suite for spectral methods and dealiasing.\n    \"\"\"\n    \n    results = []\n\n    # --- Test A: Spectral differentiation accuracy ---\n    def run_test_A(N):\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.sin(3 * x) + 0.5 * np.cos(5 * x)\n        u_x_analytic = 3 * np.cos(3 * x) - 2.5 * np.sin(5 * x)\n        \n        # Spectral derivative\n        u_hat = np.fft.fft(u)\n        # Wavenumbers k = [0, 1, ..., N/2-1, -N/2, ..., -1]\n        k = np.fft.fftfreq(N, d=1.0/N)\n        du_dx_hat = 1j * k * u_hat\n        u_x_spectral = np.fft.ifft(du_dx_hat)\n        \n        # Error calculation\n        error = np.max(np.abs(np.real(u_x_spectral) - u_x_analytic))\n        return error\n\n    results.append(run_test_A(16))\n    results.append(run_test_A(32))\n    results.append(run_test_A(64))\n\n    # --- Test B: Aliasing in u^2 and 3/2-rule dealiasing ---\n    def run_test_B(N):\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.cos(6 * x) + np.cos(7 * x)\n\n        # Aliased computation\n        u_sq_alias_phys = u**2\n        u_sq_alias_hat = np.fft.fft(u_sq_alias_phys)\n\n        # Dealiased 3/2-rule computation\n        N_pad = int(N * 3 / 2)\n        u_hat = np.fft.fft(u)\n        \n        # Pad spectrum, scaling by N'/N\n        u_hat_padded = np.zeros(N_pad, dtype=complex)\n        scaling_factor_pad = N_pad / N\n        u_hat_padded[0 : N//2] = scaling_factor_pad * u_hat[0 : N//2]\n        u_hat_padded[N_pad - (N - N//2) :] = scaling_factor_pad * u_hat[N//2:]\n        \n        u_padded = np.fft.ifft(u_hat_padded)\n        u_sq_padded_phys = np.real(u_padded)**2\n        u_sq_padded_hat = np.fft.fft(u_sq_padded_phys)\n        \n        # Truncate spectrum, scaling by N/N'\n        u_sq_dealias_hat = np.zeros(N, dtype=complex)\n        scaling_factor_trunc = N / N_pad\n        u_sq_dealias_hat[0 : N//2] = scaling_factor_trunc * u_sq_padded_hat[0 : N//2]\n        u_sq_dealias_hat[N//2:] = scaling_factor_trunc * u_sq_padded_hat[N_pad - (N - N//2) :]\n        \n        diff_norm = np.linalg.norm(u_sq_alias_hat - u_sq_dealias_hat)\n        return diff_norm\n\n    results.append(run_test_B(16))\n\n    # --- Test C: 3/2-rule versus 2/3-rule equivalence ---\n    def run_test_C(N):\n        Kc = N // 3\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.cos(7 * x) + 0.5 * np.sin(6 * x)\n        k = np.fft.fftfreq(N, d=1.0/N)\n\n        # 3/2-rule\n        N_pad = int(N * 3 / 2)\n        u_hat = np.fft.fft(u)\n\n        u_hat_padded = np.zeros(N_pad, dtype=complex)\n        scaling_factor_pad = N_pad / N\n        u_hat_padded[0 : N//2] = scaling_factor_pad * u_hat[0 : N//2]\n        u_hat_padded[N_pad - (N - N//2) :] = scaling_factor_pad * u_hat[N//2:]\n\n        u_padded = np.fft.ifft(u_hat_padded)\n        u_sq_padded_phys = np.real(u_padded)**2\n        u_sq_padded_hat = np.fft.fft(u_sq_padded_phys)\n\n        u_sq_32_hat = np.zeros(N, dtype=complex)\n        scaling_factor_trunc = N / N_pad\n        u_sq_32_hat[0 : N//2] = scaling_factor_trunc * u_sq_padded_hat[0 : N//2]\n        u_sq_32_hat[N//2:] = scaling_factor_trunc * u_sq_padded_hat[N_pad - (N - N//2) :]\n\n        # 2/3-rule\n        u_hat_trunc = u_hat.copy()\n        u_hat_trunc[np.abs(k)  Kc] = 0\n        u_trunc = np.fft.ifft(u_hat_trunc)\n        u_sq_trunc_phys = np.real(u_trunc)**2\n        u_sq_23_hat = np.fft.fft(u_sq_trunc_phys)\n        u_sq_23_hat[np.abs(k)  Kc] = 0\n\n        # Comparison\n        low_modes_mask = np.abs(k) = Kc\n        max_diff = np.max(np.abs(u_sq_32_hat[low_modes_mask] - u_sq_23_hat[low_modes_mask]))\n        return max_diff\n        \n    results.append(run_test_C(24))\n\n    # --- Test D: Aliased vs. dealiased nonlinear flux derivative ---\n    def run_test_D(N):\n        x = 2 * np.pi * np.arange(N) / N\n        u = np.sin(9 * x) + 0.4 * np.cos(8 * x)\n        \n        # Exact flux derivative\n        ux_analytic = 9 * np.cos(9 * x) - 3.2 * np.sin(8 * x)\n        flux_deriv_exact = u * ux_analytic\n        \n        # Aliased computation\n        u_hat = np.fft.fft(u)\n        k = np.fft.fftfreq(N, d=1.0/N)\n        ux_hat = 1j * k * u_hat\n        ux_spectral = np.fft.ifft(ux_hat)\n        flux_deriv_alias = u * np.real(ux_spectral)\n        err_alias = np.sqrt(np.mean((flux_deriv_alias - flux_deriv_exact)**2))\n        \n        # Dealiased 3/2-rule computation\n        N_pad = int(N * 3 / 2)\n        k_pad = np.fft.fftfreq(N_pad, d=1.0/N_pad)\n\n        u_hat_padded = np.zeros(N_pad, dtype=complex)\n        scaling_factor_pad = N_pad / N\n        u_hat_padded[0 : N//2] = scaling_factor_pad * u_hat[0 : N//2]\n        u_hat_padded[N_pad - (N - N//2) :] = scaling_factor_pad * u_hat[N//2:]\n        \n        ux_hat_padded = 1j * k_pad * u_hat_padded\n        \n        u_padded = np.fft.ifft(u_hat_padded)\n        ux_padded = np.fft.ifft(ux_hat_padded)\n        \n        flux_deriv_padded_phys = np.real(u_padded) * np.real(ux_padded)\n        flux_deriv_padded_hat = np.fft.fft(flux_deriv_padded_phys)\n        \n        flux_deriv_dealias_hat = np.zeros(N, dtype=complex)\n        scaling_factor_trunc = N / N_pad\n        flux_deriv_dealias_hat[0 : N//2] = scaling_factor_trunc * flux_deriv_padded_hat[0 : N//2]\n        flux_deriv_dealias_hat[N//2:] = scaling_factor_trunc * flux_deriv_padded_hat[N_pad - (N - N//2) :]\n        \n        flux_deriv_dealias = np.fft.ifft(flux_deriv_dealias_hat)\n        err_dealias = np.sqrt(np.mean((np.real(flux_deriv_dealias) - flux_deriv_exact)**2))\n        \n        return err_alias, err_dealias\n\n    err_D_alias, err_D_dealias = run_test_D(32)\n    results.append(err_D_alias)\n    results.append(err_D_dealias)\n    \n    # Format and print the final output\n    formatted_results = [f\"{r:.12e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3381044"}]}