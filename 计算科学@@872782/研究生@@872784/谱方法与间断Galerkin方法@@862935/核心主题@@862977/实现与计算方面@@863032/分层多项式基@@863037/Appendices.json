{"hands_on_practices": [{"introduction": "在使用谱方法求解微分方程时，一个关键步骤是在所选基底中表示微分等算子。这个练习将推导在勒让德基底中一阶导数的矩阵表示，并揭示其出人意料的简单稀疏结构。理解这种结构对于创建高效的数值求解器至关重要。[@problem_id:3390228]", "problem": "考虑在谱方法和间断伽辽金（DG）方法中使用的一维参考单元 $[-1,1]$。令 $\\{\\phi_{n}\\}_{n=0}^{\\infty}$ 表示由勒让德多项式构成的分层多项式基，其中 $\\phi_{n}(x) = P_{n}(x)$ 是定义在 $[-1,1]$ 上的 $n$ 次勒让德多项式，并通过 $P_{n}(1) = 1$ 进行归一化。对于非负整数 $m,n$，定义微分矩阵的元素为\n$$\nD_{mn} = \\int_{-1}^{1} \\phi_{m}'(x)\\,\\phi_{n}(x)\\,dx,\n$$\n\n从勒让德多项式的基本性质出发——即在 $[-1,1]$ 上的正交性、奇偶性 $P_{n}(-x) = (-1)^{n} P_{n}(x)$，以及正交多项式理论中的标准三项递推关系和微分关系——推导出一个 $D_{mn}$ 的闭式表达式，该表达式能揭示其在勒让德分层基中的稀疏模式。使用此表达式，显式计算直到3次的矩阵 $\\big(D_{mn}\\big)_{m,n=0}^{3}$。\n\n你的最终答案必须是具有精确整数元素（无舍入）的显式 $4\\times 4$ 矩阵。不需要单位。", "solution": "用户希望在勒让德多项式基中推导微分矩阵元素的闭式表达式，然后计算一个特定的子矩阵。\n\n### 步骤1：提取已知条件\n- **定义域：** 一维参考单元为 $I = [-1, 1]$。\n- **基：** 分层多项式基 $\\{\\phi_n\\}_{n=0}^{\\infty}$，其中 $\\phi_n(x) = P_n(x)$ 为 $n$ 次勒让德多项式。\n- **归一化：** 勒让德多项式被归一化，使得对所有 $n \\geq 0$ 都有 $P_n(1) = 1$。\n- **矩阵定义：** 对于非负整数 $m$ 和 $n$，微分矩阵的元素由积分 $D_{mn} = \\int_{-1}^{1} \\phi_{m}'(x)\\,\\phi_{n}(x)\\,dx$ 给出。\n- **假定性质：** 勒让德多项式的标准性质，包括正交性、奇偶性和微分关系。\n- **任务1：** 推导 $D_{mn}$ 的闭式表达式。\n- **任务2：** 显式计算 $4\\times 4$ 矩阵 $(D_{mn})_{m,n=0}^{3}$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，提法恰当且客观。这是数值分析领域的一个标准问题，特别涉及谱方法和间断伽辽金方法。给定的信息是自洽和一致的。该问题要求基于在数学中已完善建立的勒让德多项式的基本性质进行推导。未检测到任何缺陷。\n\n### 步骤3：结论与行动\n问题是**有效的**。继续求解。\n\n### $D_{mn}$ 闭式表达式的推导\n\n微分矩阵的元素定义为：\n$$\nD_{mn} = \\int_{-1}^{1} P_{m}'(x)\\,P_{n}(x)\\,dx\n$$\n为了计算这个积分，我们将使用勒让德多项式 $P_k(x)$ 在区间 $[-1, 1]$ 上的两个基本性质。\n\n1.  **正交性：** 勒让德多项式在 $[-1, 1]$ 上关于 $L^2$ 内积构成一个正交集。标准的归一化（与本问题上下文中指定的归一化不同，但在正交关系中使用）得出：\n    $$\n    \\int_{-1}^{1} P_k(x)P_j(x)\\,dx = \\frac{2}{2k+1}\\delta_{kj}\n    $$\n    其中 $\\delta_{kj}$ 是克罗内克δ函数。\n\n2.  **导数展开：** 勒让德多项式的导数可以表示为一系列低阶勒让德多项式的级数。一个标准的恒等式是：\n    $$\n    P_{m}'(x) = \\sum_{k=0, \\, m-k \\text{ 为奇数}}^{m-1} (2k+1)P_k(x)\n    $$\n    这个公式将 $P_m(x)$ 的导数（一个 $m-1$ 次多项式）在勒让德基中表示出来。求和的指标 $k$ 从 $0$ 到 $m-1$，且阶数之差 $m-k$ 为奇数。这反映了导数的奇偶性：如果 $P_m(x)$ 的奇偶性为 $(-1)^m$，其导数 $P_m'(x)$ 的奇偶性为 $(-1)^{m-1}$。因此，其展开式只能包含奇偶性为 $(-1)^k = (-1)^{m-1}$ 的多项式 $P_k(x)$，这要求 $k$ 和 $m-1$ 具有相同的奇偶性，意味着 $m-k$ 是奇数。\n\n我们将导数展开式代入 $D_{mn}$ 的定义中：\n$$\nD_{mn} = \\int_{-1}^{1} \\left( \\sum_{k=0, \\, m-k \\text{ 为奇数}}^{m-1} (2k+1)P_k(x) \\right) P_n(x)\\,dx\n$$\n由于和是有限的，我们可以交换求和与积分的顺序：\n$$\nD_{mn} = \\sum_{k=0, \\, m-k \\text{ 为奇数}}^{m-1} (2k+1) \\int_{-1}^{1} P_k(x)P_n(x)\\,dx\n$$\n现在，我们应用正交性。积分 $\\int_{-1}^{1} P_k(x)P_n(x)\\,dx$ 仅在 $k=n$ 时非零，此时其值为 $\\frac{2}{2n+1}$。为了使和非零，指标 $n$ 必须是求和中出现的指标 $k$ 之一。这对 $n$ 施加了两个条件：\n\n1.  $n$ 必须在求和范围内，即 $0 \\le n \\le m-1$。这意味着 $n  m$。如果 $n \\ge m$，则和中的每一项都为零，因此 $D_{mn} = 0$。这表明矩阵 $\\mathbf{D} = (D_{mn})$ 是严格下三角矩阵。\n2.  如求和指标所要求的，差值 $m-n$ 必须是奇数。如果 $m-n$ 是偶数，则 $n$ 不会是和中的指标，因此 $D_{mn} = 0$。\n\n如果两个条件（$n  m$ 且 $m-n$ 为奇数）都满足，则和中恰好有一个非零项，出现在 $k=n$ 时。$D_{mn}$ 的表达式简化为：\n$$\nD_{mn} = (2n+1) \\cdot \\left( \\frac{2}{2n+1} \\right) = 2\n$$\n结合这些结果，我们得到矩阵元素的闭式表达式：\n$$\nD_{mn} =\n\\begin{cases}\n2   \\text{如果 } n  m \\text{ 且 } (m-n) \\text{ 为奇数} \\\\\n0   \\text{否则}\n\\end{cases}\n$$\n这个表达式揭示了微分矩阵在分层勒让德基中的稀疏模式。它是一个严格下三角矩阵，其非零元素等于 $2$ 的位置仅出现在行和列指标之差为奇数的地方。\n\n### 矩阵 $(D_{mn})_{m,n=0}^{3}$ 的计算\n\n我们需要为 $m, n \\in \\{0, 1, 2, 3\\}$ 计算这个 $4 \\times 4$ 矩阵。该矩阵为：\n$$\n\\mathbf{D} = \\begin{pmatrix}\nD_{00}  D_{01}  D_{02}  D_{03} \\\\\nD_{10}  D_{11}  D_{12}  D_{13} \\\\\nD_{20}  D_{21}  D_{22}  D_{23} \\\\\nD_{30}  D_{31}  D_{32}  D_{33}\n\\end{pmatrix}\n$$\n我们应用推导出的 $D_{mn}$ 规则：\n\n-   对于对角线和上三角部分（$n \\ge m$），所有元素都为 $0$：\n    $D_{00} = D_{11} = D_{22} = D_{33} = 0$。\n    $D_{01} = D_{02} = D_{03} = 0$。\n    $D_{12} = D_{13} = 0$。\n    $D_{23} = 0$。\n\n-   对于严格下三角部分（$n  m$）：\n    -   $D_{10}$：$m=1$, $n=0$。$m-n = 1$（奇数）。$D_{10} = 2$。\n    -   $D_{20}$：$m=2$, $n=0$。$m-n = 2$（偶数）。$D_{20} = 0$。\n    -   $D_{21}$：$m=2$, $n=1$。$m-n = 1$（奇数）。$D_{21} = 2$。\n    -   $D_{30}$：$m=3$, $n=0$。$m-n = 3$（奇数）。$D_{30} = 2$。\n    -   $D_{31}$：$m=3$, $n=1$。$m-n = 2$（偶数）。$D_{31} = 0$。\n    -   $D_{32}$：$m=3$, $n=2$。$m-n = 1$（奇数）。$D_{32} = 2$。\n\n将这些值组合成矩阵形式，得到：\n$$\n\\mathbf{D} = \\begin{pmatrix}\n0  0  0  0 \\\\\n2  0  0  0 \\\\\n0  2  0  0 \\\\\n2  0  2  0\n\\end{pmatrix}\n$$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0  0  0 \\\\\n2  0  0  0 \\\\\n0  2  0  0 \\\\\n2  0  2  0\n\\end{pmatrix}\n}\n$$", "id": "3390228"}, {"introduction": "解析投影仅对简单函数可行。本实践练习通过演示如何使用高斯-勒让德求积将一个通用函数（如 $e^x$）数值投影到多项式基底上，从而将理论与应用联系起来。此练习强调了投影的精度如何依赖于求积规则，这是任何实际应用中都必须考虑的关键因素。[@problem_id:3390285]", "problem": "考虑参考区间 $[-1,1]$ 以及最高为 $3$ 次的多项式空间，记作 $\\mathbb{P}_3$。使用勒让德多项式 $\\{P_0(x),P_1(x),P_2(x),P_3(x)\\}$ 作为分层基，其中 $P_n(x)$ 是第 $n$ 阶勒让德多项式。勒让德多项式在 $[-1,1]$ 上满足关于标准 $L^2$ 内积 $\\langle f,g\\rangle = \\int_{-1}^{1} f(x) g(x)\\,dx$ 的正交关系，即 $\\int_{-1}^{1} P_n(x) P_m(x)\\,dx = \\frac{2}{2n+1}\\,\\delta_{nm}$。将函数 $u(x)$ 在 $\\mathbb{P}_3$ 上的 $L^2$-投影定义为 $u_3(x) = \\sum_{n=0}^{3} c_n P_n(x)$，其系数由正交性确定。\n\n任务是使用高斯-勒让德求积法推导、实现和测试投影系数 $c_n$ 的计算。在 $[-1,1]$ 上具有 $N_q$ 个节点的高斯-勒让德求积法可以精确积分最高为 $2N_q-1$ 次的所有多项式。对于一般的非多项式函数 $u(x)$，内积 $\\int_{-1}^{1} u(x) P_n(x)\\,dx$ 必须进行数值近似，求积阶数 $N_q$ 会影响其精度。\n\n您必须：\n\n- 从第一性原理出发，使用正交性推导关于勒让德基的 $L^2$-投影系数 $c_n$ 的公式，推导过程从投影和内积的定义开始。\n- 使用具有 $N_q=3$ 个节点的高斯-勒让德求积法来近似计算 $n=0,1,2,3$ 时的 $\\int_{-1}^{1} u(x) P_n(x)\\,dx$，其中 $u(x)=e^x$。\n- 通过三项递推关系 $P_0(x)=1$, $P_1(x)=x$ 和 $(n+1)P_{n+1}(x)=(2n+1)xP_n(x)-nP_{n-1}(x)$（对于 $n\\ge 1$）来实现勒让德多项式。\n- 通过计算系数 $c_n$ 来构建投影 $u_3(x)$。\n- 通过将使用 $N_q=3$ 计算的系数与使用 $N_q^{\\text{ref}}=200$ 个高斯-勒让德节点计算的高精度参考值进行比较，来估计系数的求积误差。\n\n为了使实现可测试，请使用以下测试套件，每个套件指定被积函数 $u(x)$ 和求积阶数 $N_q$：\n\n- 测试用例 1（一般非多项式，“理想路径”）：$u(x)=e^x$, $N_q=3$。\n- 测试用例 2（与 $\\mathbb{P}_3$ 内积的精确性边界）：$u(x)=x^2$, $N_q=3$。\n- 测试用例 3（边缘情况，最小求积）：$u(x)=e^x$, $N_q=1$。\n\n对于每个测试用例，使用 $N_q$ 个节点计算四个勒让德系数 $c_n$（对于 $n=0,1,2,3$），并使用 $N_q^{\\text{ref}}=200$ 计算参考系数。对于每个测试用例，报告一个浮点数，该浮点数等于四个系数之间的最大绝对差，即 $\\max_{n=0,\\dots,3} |c_n^{(N_q)} - c_n^{\\text{ref}}|$。\n\n您的程序应生成单行输出，其中包含三个结果，格式为方括号内以逗号分隔的列表（例如，\"[result1,result2,result3]\"）。此问题不涉及物理单位或角度，所有报告的值必须是纯十进制浮点数。", "solution": "当前问题要求计算一个函数在由分层勒让德基张成的多项式空间上的 $L^2$-投影系数。这是发展谱方法和间断 Galerkin 方法中的一项基本任务。解决方案包括从第一性原理推导系数的解析公式，使用高斯-勒让德求积法对所得积分进行离散化，并实现整个过程以评估特定测试用例的数值误差。\n\n设最高次数为 $k$ 的多项式空间表示为 $\\mathbb{P}_k$。我们在参考区间 $I = [-1, 1]$ 上使用多项式空间 $\\mathbb{P}_3$。该空间的基由前四个勒让德多项式 $\\{P_0(x), P_1(x), P_2(x), P_3(x)\\}$ 给出。这些多项式关于标准 $L^2$ 内积 $\\langle f, g \\rangle = \\int_{-1}^{1} f(x)g(x) \\, dx$ 是正交的。其正交关系由下式给出：\n$$\n\\langle P_n, P_m \\rangle = \\int_{-1}^{1} P_n(x) P_m(x) \\, dx = \\frac{2}{2n+1} \\delta_{nm}\n$$\n其中 $\\delta_{nm}$ 是克罗内克 delta。\n\n函数 $u(x) \\in L^2(I)$ 在子空间 $\\mathbb{P}_3$ 上的 $L^2$-投影是一个多项式 $u_3(x) \\in \\mathbb{P}_3$，使得投影误差 $e(x) = u(x) - u_3(x)$ 与 $\\mathbb{P}_3$ 中的每个函数都正交。只需强制其与每个基函数正交即可：\n$$\n\\langle u(x) - u_3(x), P_m(x) \\rangle = 0 \\quad \\text{for } m = 0, 1, 2, 3\n$$\n投影 $u_3(x)$ 可以写成基函数的线性组合：\n$$\nu_3(x) = \\sum_{n=0}^{3} c_n P_n(x)\n$$\n将此展开式代入正交条件并利用内积的线性性质，我们得到：\n$$\n\\langle u(x), P_m(x) \\rangle - \\left\\langle \\sum_{n=0}^{3} c_n P_n(x), P_m(x) \\right\\rangle = 0\n$$\n$$\n\\langle u(x), P_m(x) \\rangle - \\sum_{n=0}^{3} c_n \\langle P_n(x), P_m(x) \\rangle = 0\n$$\n由于勒让德多项式的正交性，该和式简化为仅剩 $n=m$ 的一项：\n$$\n\\langle u(x), P_m(x) \\rangle - c_m \\langle P_m(x), P_m(x) \\rangle = 0\n$$\n解出系数 $c_m$ 可得：\n$$\nc_m = \\frac{\\langle u(x), P_m(x) \\rangle}{\\langle P_m(x), P_m(x) \\rangle} = \\frac{\\int_{-1}^{1} u(x) P_m(x) \\, dx}{\\frac{2}{2m+1}}\n$$\n因此，第 $m$ 个投影系数的精确公式为：\n$$\nc_m = \\frac{2m+1}{2} \\int_{-1}^{1} u(x) P_m(x) \\, dx\n$$\n\n对于一般函数 $u(x)$，$c_m$ 表达式中的积分可能无法解析求解。我们必须借助数值求积。高斯-勒让德求积是在 $[-1, 1]$ 上进行积分的最佳选择，因为具有 $N_q$ 个节点（点）的求积法则可以精确地积分最高为 $2N_q-1$ 次的多项式。积分的求积近似由下式给出：\n$$\n\\int_{-1}^{1} f(x) \\, dx \\approx \\sum_{j=1}^{N_q} w_j f(x_j)\n$$\n其中 $x_j$ 是求积节点，$w_j$ 是相应的权重。将此应用于 $c_m$ 的公式，我们得到数值近似系数 $c_m^{(N_q)}$：\n$$\nc_m^{(N_q)} = \\frac{2m+1}{2} \\sum_{j=1}^{N_q} w_j u(x_j) P_m(x_j)\n$$\n\n实现将按以下步骤进行：\n1.  一个函数，用于在给定点集 $x_j$ 上计算 $n=0, \\dots, 3$ 的勒让德多项式 $P_n(x)$。这可以通过使用三项递推关系高效实现：\n    $P_0(x) = 1$\n    $P_1(x) = x$\n    $(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)$ for $n \\ge 1$.\n2.  一个函数，用于为给定的函数 $u(x)$、多项式次数 $3$ 和求积阶数 $N_q$ 计算系数 $c_n^{(N_q)}$。该函数将：\n    a. 获取 $N_q$ 个高斯-勒让德节点 $x_j$ 和权重 $w_j$。\n    b. 在节点处计算 $u(x_j)$。\n    c. 在节点处计算 $n \\in \\{0, 1, 2, 3\\}$ 的 $P_n(x_j)$。\n    d. 对每个 $n$，计算和式 $\\sum_{j=1}^{N_q} w_j u(x_j) P_n(x_j)$ 并应用比例因子 $\\frac{2n+1}{2}$。\n3.  主程序将执行三个指定的测试用例。对于每个用例，它将使用指定的 $N_q$ 和一个具有 $N_q^{\\text{ref}} = 200$ 的高精度参考求积来计算系数。然后，误差计算为近似系数和参考系数之间的最大绝对差：$\\max_{n=0,\\dots,3} |c_n^{(N_q)} - c_n^{(N_q^{\\text{ref}})}|$。\n\n对于测试用例 2，其中 $u(x) = x^2$ 且 $N_q=3$，我们分析被积函数 $f_n(x) = u(x)P_n(x) = x^2P_n(x)$。$P_n(x)$ 的次数为 $n$。因此，对于 $n=0, 1, 2, 3$，被积函数的次数分别为 $2, 3, 4, 5$。具有 $N_q=3$ 个节点的高斯-勒让德求积对于最高次数为 $2N_q-1 = 5$ 的多项式是精确的。因此，所有四个系数的积分都将由 $N_q=3$ 法则和 $N_q^{\\text{ref}}=200$ 法则精确计算。因此，计算出的误差预计为零（在机器精度范围内）。\n\n对于涉及 $u(x)=e^x$ 的其他测试用例，被积函数不是多项式，预计会存在求积误差。对于阶数较低的求积法则 $N_q=1$，误差会更大。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef legendre_poly_values(n_max, x):\n    \"\"\"\n    Evaluates Legendre polynomials P_0, ..., P_{n_max} at points x.\n\n    Args:\n        n_max (int): The maximum degree of the polynomial.\n        x (np.ndarray): A 1D array of points to evaluate the polynomials at.\n\n    Returns:\n        np.ndarray: A (n_max + 1) x len(x) array where P[n, j] = P_n(x[j]).\n    \"\"\"\n    if not isinstance(x, np.ndarray):\n        x = np.array(x)\n    \n    num_points = x.shape[0]\n    P = np.zeros((n_max + 1, num_points))\n\n    if n_max >= 0:\n        P[0, :] = 1.0  # P_0(x) = 1\n    if n_max >= 1:\n        P[1, :] = x    # P_1(x) = x\n    \n    # Use the three-term recurrence relation for n >= 1\n    for n in range(1, n_max):\n        # (n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)\n        P[n + 1, :] = ((2 * n + 1) * x * P[n, :] - n * P[n - 1, :]) / (n + 1)\n        \n    return P\n\ndef compute_coefficients(u_func, n_poly, N_q):\n    \"\"\"\n    Computes the L2-projection coefficients using Gauss-Legendre quadrature.\n\n    Args:\n        u_func (callable): The function u(x) to project.\n        n_poly (int): The maximum polynomial degree for projection (e.g., 3 for P_3).\n        N_q (int): The number of quadrature nodes.\n\n    Returns:\n        np.ndarray: A 1D array of coefficients [c_0, c_1, ..., c_{n_poly}].\n    \"\"\"\n    # 1. Get Gauss-Legendre quadrature nodes and weights\n    nodes, weights = roots_legendre(N_q)\n\n    # 2. Evaluate the function u(x) at the quadrature nodes\n    u_vals = u_func(nodes)\n\n    # 3. Evaluate Legendre polynomials P_n(x) at the nodes\n    # P_vals is a (n_poly+1) x N_q matrix where P_vals[n, j] = P_n(nodes[j])\n    P_vals = legendre_poly_values(n_poly, nodes)\n\n    # 4. Compute the coefficients\n    coeffs = np.zeros(n_poly + 1)\n    for n in range(n_poly + 1):\n        # Numerically integrate\n        integral = np.sum(weights * u_vals * P_vals[n, :])\n        # Apply the normalization factor\n        coeffs[n] = (2 * n + 1) / 2.0 * integral\n        \n    return coeffs\n\ndef main():\n    \"\"\"\n    Runs the test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        {\"u_func\": lambda x: np.exp(x), \"N_q\": 3},   # Case 1\n        {\"u_func\": lambda x: x**2, \"N_q\": 3},        # Case 2\n        {\"u_func\": lambda x: np.exp(x), \"N_q\": 1}    # Case 3\n    ]\n    \n    n_poly = 3\n    N_q_ref = 200\n    \n    results = []\n    \n    for case in test_cases:\n        u_func = case[\"u_func\"]\n        N_q = case[\"N_q\"]\n        \n        # Compute coefficients with the specified quadrature order\n        coeffs_approx = compute_coefficients(u_func, n_poly, N_q)\n        \n        # Compute reference coefficients with high quadrature order\n        coeffs_ref = compute_coefficients(u_func, n_poly, N_q_ref)\n        \n        # Calculate the maximum absolute difference\n        max_error = np.max(np.abs(coeffs_approx - coeffs_ref))\n        results.append(max_error)\n        \n    # Print the results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    main()\n```", "id": "3390285"}, {"introduction": "分层基底的威力在于其适应性。这个高级练习从勒让德多项式扩展到雅可比多项式，后者更适用于处理带权范数或特定边界行为的问题。通过将其与间断伽辽金（DG）方法相结合，本练习展示了如何构建和使用为特定应用（近似数值通量）量身定制的基底，并定量评估不同模式的贡献。[@problem_id:3390295]", "problem": "你需要编写一个完整的、可运行的程序，该程序为区间 $[-1,1]$ 上的间断伽辽金 (DG) 对流构建和使用针对边界加权范数定制的分层 Jacobi 多项式基，并定量评估前两个边界模式 $n=0$ 和 $n=1$ 如何影响端点 $x=\\pm 1$ 处迎风数值通量的精度。\n\n基本数学基础如下：\n- 令 Jacobi 权重为 $w^{(\\alpha,\\beta)}(x) = (1-x)^{\\alpha}(1+x)^{\\beta}$，定义在 $[-1,1]$ 上，其中 $\\alpha  -1$ 且 $\\beta  -1$。加权内积为\n$$\n\\langle f,g \\rangle_{(\\alpha,\\beta)} = \\int_{-1}^{1} f(x)\\,g(x)\\,w^{(\\alpha,\\beta)}(x)\\,dx.\n$$\n- Jacobi 多项式 $P_n^{(\\alpha,\\beta)}(x)$ 在 $[-1,1]$ 上关于权重 $w^{(\\alpha,\\beta)}(x)$ 是正交的。通过对 $P_n^{(\\alpha,\\beta)}(x)$ 进行归一化，定义一个分层正交归一基 $\\{\\phi_n^{(\\alpha,\\beta)}\\}_{n=0}^{N}$，使得 $\\langle \\phi_n^{(\\alpha,\\beta)},\\phi_m^{(\\alpha,\\beta)} \\rangle_{(\\alpha,\\beta)} = \\delta_{nm}$ 且 $\\deg(\\phi_n^{(\\alpha,\\beta)})=n$。\n- 对于单个单元 $[-1,1]$ 上的常数对流速度为 $a \\in \\mathbb{R}$ 的线性对流方程 $u_t + a\\,u_x = 0$，其入流边界处的迎风数值通量为 $F_{\\text{up}} = a\\,u(b)$，其中若 $a0$ 则 $b=-1$，若 $a0$ 则 $b=+1$。\n- 对于给定的解析函数 $f$，定义其到由 $\\{\\phi_n^{(\\alpha,\\beta)}\\}_{n=0}^{N}$ 张成的空间上的截断加权 $L^2$ 投影为\n$$\nf_N(x) = \\sum_{n=0}^{N} c_n \\,\\phi_n^{(\\alpha,\\beta)}(x),\n\\quad\nc_n = \\langle f, \\phi_n^{(\\alpha,\\beta)} \\rangle_{(\\alpha,\\beta)}.\n$$\n- 为定量评估边界模式 $n=0,1$ 对迎风通量精度的影响，对 $k \\in \\{0,1\\}$ 定义部分边界重构\n$$\ns_k(b) = \\sum_{n=0}^{k} c_n \\,\\phi_n^{(\\alpha,\\beta)}(b),\n$$\n以及相应的迎风通量绝对误差\n$$\nE_k = \\big| a \\,\\big(f(b) - s_k(b)\\big) \\big|.\n$$\n\n你的程序必须：\n1. 根据第一性原理（正交性和归一化），从 $P_n^{(\\alpha,\\beta)}(x)$ 和权重 $w^{(\\alpha,\\beta)}(x)$ 构建分层正交归一 Jacobi 基 $\\{\\phi_n^{(\\alpha,\\beta)}\\}_{n=0}^{N}$。对于非多项式函数，必须使用数值积分来计算内积。使用与权重 $w^{(\\alpha,\\beta)}(x)$ 一致的 Gauss–Jacobi 求积法来精确近似内积。\n2. 对每个测试用例，通过数值积分计算模态系数 $\\{c_n\\}_{n=0}^{N}$，然后计算如上定义的 $E_0$ 和 $E_1$。如果出现角度，必须以弧度为单位进行解释。\n3. 若 $a0$，使用入流边界 $b=-1$；若 $a0$，使用入流边界 $b=1$。\n\n测试套件：\n- 用例 1：$\\alpha=0$, $\\beta=0$, $a=1$, $N=8$, $f(x)=\\exp(x)$，边界 $b=-1$。\n- 用例 2：$\\alpha=0$, $\\beta=3$, $a=1$, $N=8$, $f(x)=\\exp(5x)$，边界 $b=-1$。\n- 用例 3：$\\alpha=3$, $\\beta=0$, $a=-1$, $N=8$, $f(x)=\\cos(2\\pi x)$，边界 $b=+1$；余弦函数的参数使用弧度。\n- 用例 4：$\\alpha=\\frac{1}{2}$, $\\beta=\\frac{1}{2}$, $a=1$, $N=10$, $f(x)=\\frac{1}{1+25x^2}$，边界 $b=-1$。\n\n程序输出要求：\n- 对每个测试用例，计算并返回数对 $[E_0,E_1]$，结果为实数，采用定点小数表示法，四舍五入保留 $12$ 位小数。\n- 你的程序应生成单行输出，其中包含四个测试用例的结果，形式为由方括号括起来的、逗号分隔的数对列表。确切格式必须是：\n`\"[[E0_1,E1_1],[E0_2,E1_2],[E0_3,E1_3],[E0_4,E1_4]]\"`\n其中每个 $E$ 是一个小数点后有 $12$ 位数字的十进制数。\n\n所有计算都是无量纲的；不涉及任何物理单位。角度以弧度为单位。程序不得要求任何用户输入；程序必须能运行并打印出所要求的单行输出。", "solution": "该问题是有效的。这是一个数值分析中适定的问题，其基础是成熟的正交多项式理论及其在谱方法和间断伽辽金 (DG) 方法中的应用。所有术语都定义清晰，测试用例完整，目标是定量的且可验证的。\n\n该问题的解决方案涉及构建和利用一个分层正交归一多项式基来近似给定函数，然后在特定边界点评估此近似的精度。其背景是近似线性对流方程 $u_t + a\\,u_x = 0$ 的迎风数值通量。该方法的核心依赖于 Jacobi 多项式的性质。\n\n首先，我们建立数学框架。Jacobi 多项式，记为 $P_n^{(\\alpha,\\beta)}(x)$，是一系列在区间 $[-1,1]$ 上关于权重函数 $w^{(\\alpha,\\beta)}(x) = (1-x)^{\\alpha}(1+x)^{\\beta}$ 正交的多项式。正交性通过加权内积定义：\n$$\n\\langle f,g \\rangle_{(\\alpha,\\beta)} = \\int_{-1}^{1} f(x)\\,g(x)\\,w^{(\\alpha,\\beta)}(x)\\,dx\n$$\n使得当 $n \\neq m$ 时，$\\langle P_n^{(\\alpha,\\beta)}, P_m^{(\\alpha,\\beta)} \\rangle_{(\\alpha,\\beta)} = 0$。\n\n问题要求一个分层正交归一基 $\\{\\phi_n^{(\\alpha,\\beta)}\\}_{n=0}^{N}$。如果前 $k+1$ 个基函数 $\\{\\phi_n\\}_{n=0}^{k}$ 的张成空间构成了所有次数至多为 $k$ 的多项式空间，则该基是分层的。由于我们将 $\\phi_n^{(\\alpha,\\beta)}$ 定义为 $n$ 次多项式，此性质得以满足。为了使基是正交归一的，即 $\\langle \\phi_n^{(\\alpha,\\beta)}, \\phi_m^{(\\alpha,\\beta)} \\rangle_{(\\alpha,\\beta)} = \\delta_{nm}$，我们对每个 Jacobi 多项式 $P_n^{(\\alpha,\\beta)}(x)$ 进行归一化。归一化常数是多项式与其自身加权内积的平方根，即其范数的平方 $h_n^2$：\n$$\nh_n^2 = \\|P_n^{(\\alpha,\\beta)}\\|_{(\\alpha,\\beta)}^2 = \\int_{-1}^{1} \\left[P_n^{(\\alpha,\\beta)}(x)\\right]^2 w^{(\\alpha,\\beta)}(x)\\,dx = \\frac{2^{\\alpha+\\beta+1}}{2n+\\alpha+\\beta+1} \\frac{\\Gamma(n+\\alpha+1)\\Gamma(n+\\beta+1)}{n!\\Gamma(n+\\alpha+\\beta+1)}\n$$\n因此，正交归一基函数由 $\\phi_n^{(\\alpha,\\beta)}(x) = P_n^{(\\alpha,\\beta)}(x) / h_n$ 给出。\n\n接下来，我们将一个解析函数 $f(x)$ 投影到由前 $N+1$ 个基函数张成的空间上。这个投影 $f_N(x)$ 是一个有限级数展开：\n$$\nf_N(x) = \\sum_{n=0}^{N} c_n \\,\\phi_n^{(\\alpha,\\beta)}(x)\n$$\n模态系数 $c_n$ 是通过计算 $f(x)$ 与每个基函数的内积得到的：\n$$\nc_n = \\langle f, \\phi_n^{(\\alpha,\\beta)} \\rangle_{(\\alpha,\\beta)} = \\int_{-1}^{1} f(x)\\,\\phi_n^{(\\alpha,\\beta)}(x)\\,w^{(\\alpha,\\beta)}(x)\\,dx\n$$\n对于一个通用函数 $f(x)$，该积分必须进行数值计算。问题指定使用 Gauss-Jacobi 求积法，这是对此类积分的最佳选择。一个具有 $M$ 个点的求积规则将积分近似为：\n$$\n\\int_{-1}^{1} g(x)\\,w^{(\\alpha,\\beta)}(x)\\,dx \\approx \\sum_{i=1}^{M} w_i\\,g(x_i)\n$$\n其中 $x_i$ 和 $w_i$ 是求积节点和权重。应用此方法，系数计算为 $c_n \\approx \\sum_{i=1}^{M} w_i f(x_i) \\phi_n^{(\\alpha,\\beta)}(x_i)$。选择一个足够大的 $M$ 值以确保高精度。\n\n最后一步是评估迎风数值通量的精度。对于对流方程，入流边界 $b$ 是信息进入计算域的地方。如果对流速度 $a$ 为正，则 $b=-1$；如果 $a$ 为负，则 $b=+1$。迎风通量基于解在此边界上的值。我们使用级数展开的部分和 $s_k(b)$ 来近似真值 $f(b)$，它表示使用最高次数为 $k$ 的模式时，该投影在边界上的值：\n$$\ns_k(b) = \\sum_{n=0}^{k} c_n \\,\\phi_n^{(\\alpha,\\beta)}(b)\n$$\n为了精确计算 $\\phi_n^{(\\alpha,\\beta)}(b)$，我们使用 Jacobi 多项式在端点 $x=\\pm 1$ 处的解析公式：\n$$\nP_n^{(\\alpha,\\beta)}(1) = \\frac{\\Gamma(n+\\alpha+1)}{n! \\Gamma(\\alpha+1)}, \\quad \\quad P_n^{(\\alpha,\\beta)}(-1) = (-1)^n \\frac{\\Gamma(n+\\beta+1)}{n! \\Gamma(\\beta+1)}\n$$\n迎风通量近似的绝对误差则定义为 $E_k = \\big| a \\,\\big(f(b) - s_k(b)\\big) \\big|$。我们针对 $k=0$（常数近似）和 $k=1$（线性近似）计算这个值，以观察包含线性模式如何改善边界表示。\n\n该算法通过迭代每个测试用例来执行。对于每个用例，它确定参数 $\\alpha, \\beta, a, N$ 和函数 $f(x)$。它计算必要的组成部分：Gauss-Jacobi 求积节点和权重、归一化常数 $h_n$、模态系数 $c_n$ 以及基函数 $\\phi_n^{(\\alpha,\\beta)}$ 在入流边界 $b$ 处的值。最后，它组合部分和 $s_0(b)$ 和 $s_1(b)$ 以计算误差 $E_0$ 和 $E_1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jacobi, roots_jacobi, gamma, gammaln\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 0.0, 1.0, 8, lambda x: np.exp(x)),\n        (0.0, 3.0, 1.0, 8, lambda x: np.exp(5.0 * x)),\n        (3.0, 0.0, -1.0, 8, lambda x: np.cos(2.0 * np.pi * x)),\n        (0.5, 0.5, 1.0, 10, lambda x: 1.0 / (1.0 + 25.0 * x**2))\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, beta, a, N, f = case\n        \n        # Determine inflow boundary based on advection speed 'a'\n        b = -1.0 if a > 0 else 1.0\n\n        # Set up Gauss-Jacobi Quadrature. A high number of quadrature points\n        # is used for accuracy with the given analytic functions.\n        M = 100 \n        quad_x, quad_w = roots_jacobi(M, alpha, beta)\n\n        # Pre-compute values for efficiency\n        h_n = np.zeros(N + 1)      # Norms ||P_n||\n        c_n = np.zeros(N + 1)      # Modal coefficients\n        f_at_quad_x = f(quad_x)\n\n        for n in range(N + 1):\n            # Calculate the squared norm of P_n^(alpha, beta) using log-gamma for stability\n            log_h_n_sq = ((alpha + beta + 1.0) * np.log(2.0)\n                          - np.log(2.0 * n + alpha + beta + 1.0)\n                          + gammaln(n + alpha + 1.0)\n                          + gammaln(n + beta + 1.0)\n                          - gammaln(n + 1.0)\n                          - gammaln(n + alpha + beta + 1.0))\n            h_n[n] = np.exp(0.5 * log_h_n_sq)\n\n            # Get the standard Jacobi polynomial P_n\n            p_n_poly = jacobi(n, alpha, beta)\n            \n            # Evaluate the orthonormal basis function phi_n at quadrature points\n            phi_n_at_quad_x = p_n_poly(quad_x) / h_n[n]\n            \n            # Compute modal coefficient c_n using numerical quadrature\n            integrand = f_at_quad_x * phi_n_at_quad_x\n            c_n[n] = np.sum(quad_w * integrand)\n\n        # Evaluate orthonormal basis functions phi_n for n=0,1 at the boundary 'b'\n        phi_n_at_b = np.zeros(2)\n        for n in range(2):\n            # Use stable analytical formulas for P_n(b)\n            if b == 1.0:\n                log_p_n_at_b = gammaln(n + alpha + 1.0) - gammaln(n + 1.0) - gammaln(alpha + 1.0)\n                p_n_at_b = np.exp(log_p_n_at_b)\n            else:  # b == -1.0\n                log_p_n_at_b = gammaln(n + beta + 1.0) - gammaln(n + 1.0) - gammaln(beta + 1.0)\n                p_n_at_b = ((-1.0)**n) * np.exp(log_p_n_at_b)\n            \n            phi_n_at_b[n] = p_n_at_b / h_n[n]\n\n        # Compute partial boundary reconstructions s_k(b) for k=0, 1\n        s0_b = c_n[0] * phi_n_at_b[0]\n        s1_b = s0_b + c_n[1] * phi_n_at_b[1]\n\n        # Compute absolute upwind flux errors E_k\n        f_at_b = f(np.array([b]))[0]\n        E0 = np.abs(a * (f_at_b - s0_b))\n        E1 = np.abs(a * (f_at_b - s1_b))\n        \n        results.append((E0, E1))\n\n    # Format the results into the required string format\n    formatted_pairs = []\n    for E0, E1 in results:\n        formatted_pairs.append(f\"[{E0:.12f},{E1:.12f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_pairs)}]\")\n\nsolve()\n```", "id": "3390295"}]}