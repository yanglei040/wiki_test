{"hands_on_practices": [{"introduction": "任何谱方法的第一步都是选择基函数。勒让德多项式因其正交性而成为一个自然的选择，但出于理论和实践上的考虑，使用标准正交基通常更为有利。本练习 [@problem_id:3422988] 将引导你完成从正交的勒让德多项式构造标准正交基的基本过程。掌握这项基础技能是构建稳健的谱方法和间断 Galerkin 方法的第一步，因为它能简化质量矩阵的结构和理论分析。", "problem": "考虑用于四边形和六面体单元的高阶谱方法和间断 Galerkin (DG) 方法中的参考一维区间 $[-1,1]$。令 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 表示 Legendre 多项式序列，它们在 $[-1,1]$ 上关于标准 Lebesgue 测度是正交的。$L^{2}([-1,1])$ 内积定义为 $\\langle f, g \\rangle = \\int_{-1}^{1} f(x) g(x) \\, dx$。参考六面体 $[-1,1]^{3}$ 上的张量积 $L^{2}$ 内积定义为 $\\langle f, g \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} f(x,y,z) g(x,y,z) \\, dx \\, dy \\, dz$。Legendre 多项式满足 $\\int_{-1}^{1} P_{n}(x) P_{m}(x) \\, dx = \\frac{2}{2n+1} \\delta_{nm}$ 是一个经过充分验证的事实，其中 $\\delta_{nm}$ 是 Kronecker delta。\n\n从这些基本内积定义和 Legendre 多项式的正交性出发，推導出一个缩放变换，从 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 生成一个 $L^{2}([-1,1])$ 标准正交基 $\\{\\phi_{n}(x)\\}_{n=0}^{\\infty}$，然后将此缩放变换扩展到参考六面体 $[-1,1]^{3}$ 上的张量积标准正交基 $\\{\\Phi_{i j k}(x,y,z)\\}_{i,j,k \\ge 0}$，其形式为 $\\Phi_{i j k}(x,y,z)$ 与 $P_{i}(x) P_{j}(y) P_{k}(z)$ 成比例。分别计算由此产生的归一化常数 $c_{n}$ 和 $c_{i j k}$，它们将 $P_{n}(x)$ 和 $P_{i}(x) P_{j}(y) P_{k}(z)$ 缩放至单位 $L^{2}$ 范数。将你的最终答案表示为 $c_{n}$ 和 $c_{i j k}$ 的闭式解析表达式。无需四舍五入。", "solution": "该问题经验证具有科学依据、提法恰当、客观且内部一致。这是为谱方法构建标准正交基的一个标准练习，是数值分析和应用数学中的一个基本课题。因此，我们可以着手求解。\n\n目标是确定归一化常数 $c_{n}$ 和 $c_{i j k}$，它们分别将 Legendre 多项式 $P_{n}(x)$ 及其张量积 $P_{i}(x) P_{j}(y) P_{k}(z)$ 进行缩放，以在定义域 $[-1,1]$ 和 $[-1,1]^3$ 上形成标准正交基。标准正交基是指任意两个不同基函数的内积为零（正交性），且任意基函数与其自身的内积（即其范数的平方）为一（归一化）。\n\n首先，我们考虑区间 $[-1,1]$ 上的一维情况。$L^{2}([-1,1])$ 内积由 $\\langle f, g \\rangle = \\int_{-1}^{1} f(x) g(x) \\, dx$ 给出。我们寻求从 Legendre 多项式序列 $\\{P_{n}(x)\\}_{n=0}^{\\infty}$ 构建一个标准正交基 $\\{\\phi_{n}(x)\\}_{n=0}^{\\infty}$。令标准正交基函数定义为 $\\phi_{n}(x) = c_{n} P_{n}(x)$，其中 $c_{n}$ 是我们需要找到的实值归一化常数。\n\n标准正交性条件是 $\\langle \\phi_{n}, \\phi_{m} \\rangle = \\delta_{nm}$，其中 $\\delta_{nm}$ 是 Kronecker delta。我们来计算这个内积：\n$$\n\\langle \\phi_{n}, \\phi_{m} \\rangle = \\langle c_{n} P_{n}, c_{m} P_{m} \\rangle = \\int_{-1}^{1} (c_{n} P_{n}(x)) (c_{m} P_{m}(x)) \\, dx = c_{n} c_{m} \\int_{-1}^{1} P_{n}(x) P_{m}(x) \\, dx\n$$\n问题给出了 Legendre 多项式的正交关系：$\\int_{-1}^{1} P_{n}(x) P_{m}(x) \\, dx = \\frac{2}{2n+1} \\delta_{nm}$。将其代入我们的表达式可得：\n$$\n\\langle \\phi_{n}, \\phi_{m} \\rangle = c_{n} c_{m} \\frac{2}{2n+1} \\delta_{nm}\n$$\n为使该表达式等于 $\\delta_{nm}$，我们必须考虑 $n=m$ 的情况。当 $n \\neq m$ 时，$\\delta_{nm}=0$，正交条件 $\\langle \\phi_{n}, \\phi_{m} \\rangle = 0$ 已经满足。对于归一化，我们要求 $\\phi_{n}(x)$ 的 $L^{2}$-范数的平方为1。范数的平方是 $\\|\\phi_{n}\\|^2 = \\langle \\phi_{n}, \\phi_{n} \\rangle$。令 $m=n$，我们得到：\n$$\n\\langle \\phi_{n}, \\phi_{n} \\rangle = (c_{n})^2 \\frac{2}{2n+1} \\delta_{nn} = (c_{n})^2 \\frac{2}{2n+1}\n$$\n为了归一化，我们将其设为 $1$：\n$$\n(c_{n})^2 \\frac{2}{2n+1} = 1\n$$\n解出 $c_{n}$，我们得到 $(c_{n})^2 = \\frac{2n+1}{2}$。按照惯例，我们为归一化常数选择正根：\n$$\nc_{n} = \\sqrt{\\frac{2n+1}{2}}\n$$\n\n接下来，我们将其扩展到参考六面体 $[-1,1]^3$ 上的三维情况。张量积 $L^{2}$ 内积由 $\\langle f, g \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} f(x,y,z) g(x,y,z) \\, dx \\, dy \\, dz$ 给出。我们寻求一个张量积标准正交基 $\\{\\Phi_{i j k}(x,y,z)\\}_{i,j,k \\ge 0}$，其中 $\\Phi_{i j k}(x,y,z) = c_{i j k} P_{i}(x) P_{j}(y) P_{k}(z)$。常数 $c_{i j k}$ 是归一化常数。\n\n在这种多重索引的情况下，标准正交性条件是 $\\langle \\Phi_{i j k}, \\Phi_{l m n} \\rangle = \\delta_{il} \\delta_{jm} \\delta_{kn}$。和之前一样，我们通过计算基函数的范数平方来关注归一化条件，这对应于设置 $(l,m,n) = (i,j,k)$：\n$$\n\\| \\Phi_{i j k} \\|^2 = \\langle \\Phi_{i j k}, \\Phi_{i j k} \\rangle = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} [c_{i j k} P_{i}(x) P_{j}(y) P_{k}(z)]^2 \\, dx \\, dy \\, dz\n$$\n$$\n\\| \\Phi_{i j k} \\|^2 = (c_{i j k})^2 \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} P_{i}(x)^2 P_{j}(y)^2 P_{k}(z)^2 \\, dx \\, dy \\, dz\n$$\n由于函数和定义域的张量积性质，三重积分可以分离为三个一维积分的乘积：\n$$\n\\| \\Phi_{i j k} \\|^2 = (c_{i j k})^2 \\left( \\int_{-1}^{1} P_{i}(x)^2 \\, dx \\right) \\left( \\int_{-1}^{1} P_{j}(y)^2 \\, dy \\right) \\left( \\int_{-1}^{1} P_{k}(z)^2 \\, dz \\right)\n$$\n我们可以使用 Legendre 多项式范数平方的一维结果，即 $\\int_{-1}^{1} P_{n}(x)^2 \\, dx = \\frac{2}{2n+1}$。将此应用于每个积分：\n$$\n\\| \\Phi_{i j k} \\|^2 = (c_{i j k})^2 \\left( \\frac{2}{2i+1} \\right) \\left( \\frac{2}{2j+1} \\right) \\left( \\frac{2}{2k+1} \\right) = (c_{i j k})^2 \\frac{8}{(2i+1)(2j+1)(2k+1)}\n$$\n为了归一化，我们将此范数的平方设为 $1$：\n$$\n(c_{i j k})^2 \\frac{8}{(2i+1)(2j+1)(2k+1)} = 1\n$$\n解出 $c_{i j k}$，我们得到 $(c_{i j k})^2 = \\frac{(2i+1)(2j+1)(2k+1)}{8}$。再次取正根：\n$$\nc_{i j k} = \\sqrt{\\frac{(2i+1)(2j+1)(2k+1)}{8}}\n$$\n我们观察到 $c_{i j k} = \\sqrt{\\frac{2i+1}{2}} \\sqrt{\\frac{2j+1}{2}} \\sqrt{\\frac{2k+1}{2}} = c_i c_j c_k$。这证实了张量积标准正交基是由一维标准正交基函数的乘积形成的，即 $\\Phi_{i j k}(x,y,z) = \\phi_{i}(x) \\phi_{j}(y) \\phi_{k}(z)$。\n\n所需的归一化常数因此得以确定。", "answer": "$$\n\\boxed{c_n = \\sqrt{\\frac{2n+1}{2}}, \\quad c_{ijk} = \\sqrt{\\frac{(2i+1)(2j+1)(2k+1)}{8}}}\n$$", "id": "3422988"}, {"introduction": "在构建基函数之后，有限元方法中的一个关键设计抉择是选择多项式空间本身，这需要在精度和计算成本之间取得平衡。本问题 [@problem_id:3423029] 探讨了全张量积空间 $Q_p$ 与更经济的“意外”空间 (serendipity space) $S_p$ 之间的区别，这对于开发计算高效的高阶格式至关重要。你将精确地识别出在“意外”空间构造中省略了哪些“交叉项”。", "problem": "在高阶间断 Galerkin 方法中，为了在四边形单元上平衡精度和计算成本，通常会在全张量积多项式空间和降阶的 serendipity 空间之间进行选择。考虑坐标为 $(\\xi,\\eta)$ 的参考正方形 $[-1,1]^2$ 和张量积空间 $Q_p$。$Q_p$ 定义为所有单项式 $\\xi^i \\eta^j$（其中 $0 \\le i \\le p$ 且 $0 \\le j \\le p$）张成的空间。四边形上的 serendipity 空间 $S_p$ 的定义可以确保所有边迹保留最多为 $p$ 次的多项式，同时减少内部气泡分量以消除某些交叉项。对于 $p=3$ 的情况，请选择正确定义了 $S_p$ 并精确指出了存在于 $Q_3$ 但不存在于 $S_3$ 的单项式（即“缺失的交叉项”）的选项。\n\nA. $S_p$ 由所有双变量多项式组成，其超线性次数（指数至少为 $2$ 的变量的指数之和）最多为 $p$。对于 $p=3$，在 $Q_3$ 中但不在 $S_3$ 中的单项式恰好是 $\\xi^2 \\eta^2$、$\\xi^2 \\eta^3$、$\\xi^3 \\eta^2$ 和 $\\xi^3 \\eta^3$。\n\nB. $S_p$ 是所有总次数最多为 $p$ 的多项式的集合。对于 $p=3$，在 $Q_3$ 中但不在 $S_3$ 中的单项式是所有总次数超过 $3$ 的单项式，包括 $\\xi^3$、$\\eta^3$、$\\xi^3 \\eta$、$\\xi \\eta^3$、$\\xi^2 \\eta^2$、$\\xi^2 \\eta^3$、$\\xi^3 \\eta^2$ 和 $\\xi^3 \\eta^3$。\n\nC. $S_p$ 等于 $Q_p$ 移除唯一的成对二次交叉项。对于 $p=3$，在 $Q_3$ 中但不在 $S_3$ 中的单项式减少到只有 $\\xi^2 \\eta^2$。\n\nD. $S_p$ 的定义要求每个变量的次数最多为 $p$，并消除任何其中任一变量指数至少为 $2$ 的单项式。对于 $p=3$，在 $Q_3$ 中但不在 $S_3$ 中的单项式是 $\\xi^2$、$\\eta^2$、$\\xi^2 \\eta$、$\\xi \\eta^2$、$\\xi^3$ 和 $\\eta^3$。", "solution": "### 第 1 步：提取已知信息\n- **定义域：** 参考正方形 $[-1,1]^2$，坐标为 $(\\xi, \\eta)$。\n- **张量积空间 $Q_p$ 定义：** 所有单项式 $\\xi^i \\eta^j$（其中 $0 \\le i \\le p$ 且 $0 \\le j \\le p$）张成的空间。\n- **Serendipity 空间 $S_p$ 描述：** 四边形上的一个空间，其中所有边迹都是次数最多为 $p$ 的多项式，并且与 $Q_p$ 相比，内部气泡分量被减少。\n- **特定阶数：** 问题涉及 $p=3$ 的情况。\n- **目标：** 选择正确定义 $S_p$ 并指出在 $Q_3$ 中但不在 $S_3$ 中的单项式的选项。\n\n### 第 2 步：使用提取的已知信息进行验证\n问题陈述具有科学依据，提法得当且客观。$Q_p$ 和 $S_p$ 多项式空间的概念是有限元法及相关数值技术的基础。这些定义是标准的，问题是对这些空间的构成进行的精确数学探究。不存在会妨碍严谨分析的矛盾、歧义或信息缺失。\n\n### 第 3 步：结论与行动\n问题有效。将开始求解过程。\n\n### 多项式空间的推导\n\n首先，我们在参考单元 $[-1,1]^2$ 上定义张量积空间 $Q_3$。根据给定的定义，$Q_p = \\text{span} \\{ \\xi^i \\eta^j \\mid 0 \\le i \\le p, 0 \\le j \\le p \\}$。对于 $p=3$，这变为：\n$$ Q_3 = \\text{span} \\{ \\xi^i \\eta^j \\mid 0 \\le i \\le 3, 0 \\le j \\le 3 \\} $$\n该空间的维度是 $(p+1)^2 = (3+1)^2 = 16$。其基由以下 $16$ 个单项式组成：\n$$ \\{ 1, \\xi, \\eta, \\xi^2, \\xi\\eta, \\eta^2, \\xi^3, \\xi^2\\eta, \\xi\\eta^2, \\eta^3, \\xi^3\\eta, \\xi\\eta^3, \\xi^2\\eta^2, \\xi^3\\eta^2, \\xi^2\\eta^3, \\xi^3\\eta^3 \\} $$\n\n接下来，我们建立 serendipity 空间 $S_p$ 的标准构造。关键条件是边迹为次数最多为 $p$ 的多项式。令 $P_p(\\xi, \\eta)$ 表示总次数最多为 $p$ 的多项式空间，即 $P_p = \\text{span} \\{ \\xi^i \\eta^j \\mid i+j \\le p \\}$。对于 $p \\ge 2$，标准的 serendipity 空间 $S_p$ 是通过在 $P_p$ 的基础上增加最少的高次项集合来构造的，以确保每条边上的迹都是一个完整的 $p$ 次一维多项式。这通过以下方式实现：\n$$ S_p = P_p(\\xi, \\eta) \\oplus \\text{span} \\{ \\xi^p\\eta, \\xi\\eta^p \\} $$\n对于 $p=3$ 的情况，我们首先确定 $P_3$ 的基：\n$$ P_3 = \\text{span} \\{ 1, \\xi, \\eta, \\xi^2, \\xi\\eta, \\eta^2, \\xi^3, \\xi^2\\eta, \\xi\\eta^2, \\eta^3 \\} $$\n该空间的维度为 $\\frac{(3+1)(3+2)}{2} = 10$。\n现在，我们通过添加所需的交叉项来构成 $S_3$：\n$$ S_3 = P_3(\\xi, \\eta) \\oplus \\text{span} \\{ \\xi^3\\eta, \\xi\\eta^3 \\} $$\n$S_3$ 的基因此由来自 $P_3$ 的 $10$ 个单项式加上 $2$ 个额外的单项式 $\\xi^3\\eta$ 和 $\\xi\\eta^3$ 组成，总共有 $12$ 个基函数：\n$$ \\{ 1, \\xi, \\eta, \\xi^2, \\xi\\eta, \\eta^2, \\xi^3, \\xi^2\\eta, \\xi\\eta^2, \\eta^3, \\xi^3\\eta, \\xi\\eta^3 \\} $$\n请注意，两个添加的项 $\\xi^3\\eta$ 和 $\\xi\\eta^3$ 的总次数为 $4$，大于 $p=3$。\n\n通过取其基的集合差，可以找到存在于 $Q_3$ 但不存在于 $S_3$ 的单项式：\n$$ Q_3 \\setminus S_3 = \\{ \\xi^2\\eta^2, \\xi^2\\eta^3, \\xi^3\\eta^2, \\xi^3\\eta^3 \\} $$\n这四项就是“缺失的交叉项”。它们被认为是内部“气泡”模式，因为如果使用合适的 Lagrange 多项式组合来构造，它们在参考单元的所有四条边上都为零。例如，任何与 $(1-\\xi^2)(1-\\eta^2)$ 成比例的多项式在边界上都为零。项 $\\xi^2\\eta^2$ 可以是这种气泡的一部分，例如 $(1-\\xi^2)(1-\\eta^2)\\xi^0\\eta^0$。Serendipity 空间的目标是消除这些最高阶的内部模式，以降低计算成本。\n\n### 逐项分析\n\nA. $S_p$ 由所有双变量多项式组成，其超线性次数（指数至少为 $2$ 的变量的指数之和）最多为 $p$。对于 $p=3$，在 $Q_3$ 中但不在 $S_3$ 中的单项式恰好是 $\\xi^2 \\eta^2$、$\\xi^2 \\eta^3$、$\\xi^3 \\eta^2$ 和 $\\xi^3 \\eta^3$。\n\n我们来测试一下所提出的 $S_p$ 定义在 $p=3$ 的情况下。来自 $Q_3$ 的单项式 $\\xi^i\\eta^j$ 如果其“超线性次数”最多为 $3$，则属于该空间。\n- 对于 $\\xi^3\\eta$：$\\xi$ 的指数为 $3 \\ge 2$。超线性次数为 $3$。由于 $3 \\le 3$，它被包括在内。这与我们推导的 $S_3$ 基相符。\n- 对于 $\\xi\\eta^3$：$\\eta$ 的指数为 $3 \\ge 2$。超线性次数为 $3$。由于 $3 \\le 3$，它被包括在内。这也相符。\n- 对于 $\\xi^2\\eta^2$：$\\xi$ 的指数为 $2 \\ge 2$，$\\eta$ 的指数为 $2 \\ge 2$。超线性次数为 $2+2=4$。由于 $4 > 3$，它被排除。这与我们找到的缺失项集合相符。\n- 对于 $\\xi^2\\eta^3$：$\\xi$ 的指数为 $2 \\ge 2$，$\\eta$ 的指数为 $3 \\ge 2$。超线性次数为 $2+3=5$。由于 $5 > 3$，它被排除。这也相符。\n- 对于 $\\xi^3\\eta^2$：$\\xi$ 的指数为 $3 \\ge 2$，$\\eta$ 的指数为 $2 \\ge 2$。超线性次数为 $3+2=5$。由于 $5 > 3$，它被排除。这也相符。\n- 对于 $\\xi^3\\eta^3$：$\\xi$ 的指数为 $3 \\ge 2$，$\\eta$ 的指数为 $3 \\ge 2$。超线性次数为 $3+3=6$。由于 $6 > 3$，它被排除。这也相符。\n该定义虽然使用了非标准术语，但正确地识别了标准 serendipity 空间 $S_3$ 的单项式集合。其后给出的“缺失的交叉项”列表也正是我们推导出的集合 $Q_3 \\setminus S_3$。\n结论：**正确**。\n\nB. $S_p$ 是所有总次数最多为 $p$ 的多项式的集合。对于 $p=3$，在 $Q_3$ 中但不在 $S_3$ 中的单项式是所有总次数超过 $3$ 的单项式，包括 $\\xi^3$、$\\eta^3$、$\\xi^3 \\eta$、$\\xi \\eta^3$、$\\xi^2 \\eta^2$、$\\xi^2 \\eta^3$、$\\xi^3 \\eta^2$ 和 $\\xi^3 \\eta^3$。\n\n该选项将 $S_p$ 定义为 $P_p$。对于 $p=3$，这意味着 $S_3 = P_3$。如上所述，标准的 serendipity 空间 $S_3$ 包含像 $\\xi^3\\eta$ 和 $\\xi\\eta^3$ 这样的项，它们的总次数为 $4$。因此，$S_3 \\ne P_3$。该定义不正确。此外，缺失单项式的列表也有缺陷。如果 $S_3 = P_3$，那么缺失的单项式将是 $Q_3$ 中所有总次数大于 $3$ 的项。而给出的列表包括了 $\\xi^3$ 和 $\\eta^3$，它们的总次数为 $3$，是 $P_3$ 的成员。因此，排除项的列表与其自身定义不一致。\n结论：**不正确**。\n\nC. $S_p$ 等于 $Q_p$ 移除唯一的成对二次交叉项。对于 $p=3$，在 $Q_3$ 中但不在 $S_3$ 中的单项式减少到只有 $\\xi^2 \\eta^2$。\n\n这个规则正确地描述了从 $Q_2$ 到 $S_2$ 的转换，其中只移除了 $\\xi^2\\eta^2$ 项。然而，这个规则不能推广到更高阶。将其应用于 $p=3$ 意味着 $S_3$ 是一个 $15$ 维空间，而不是标准的 $12$ 维 serendipity 空间。我们的推导表明，必须从 $Q_3$ 中移除四个单项式才能得到 $S_3$，而不仅仅是一个。\n结论：**不正确**。\n\nD. $S_p$ 的定义要求每个变量的次数最多为 $p$，并消除任何其中任一变量指数至少为 $2$ 的单项式。对于 $p=3$，在 $Q_3$ 中但不在 $S_3$ 中的单项式是 $\\xi^2$、$\\eta^2$、$\\xi^2 \\eta$、$\\xi \\eta^2$、$\\xi^3$ 和 $\\eta^3$。\n\n定义的第一部分（“要求每个变量的次数最多为 $p$”）定义了 $Q_p$。第二部分（“消除任何其中任一变量指数至少为 $2$ 的单项式”）是一个过滤规则。对于 $p=3$，该规则将从 $Q_3$ 中消除像 $\\xi^2$、$\\xi^3$、$\\eta^2$、$\\eta^3$ 等基本项。生成的空间将是 $Q_1 = \\text{span}\\{1, \\xi, \\eta, \\xi\\eta\\}$，这对于 $S_3$ 来说是完全错误的。$Q_1$ 多项式的边迹仅为 $1$ 次，而不是 $3$ 次。因此，该定义不正确。列出的要移除的单项式（`$\\xi^2$、$\\eta^2$、$\\xi^2 \\eta$、$\\xi \\eta^2$、$\\xi^3$ 和 $\\eta^3$`）也是不正确的，因为这些项对于边迹属性至关重要，并且是标准 $S_3$ 空间的一部分。\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "3423029"}, {"introduction": "张量积基的真正威力在于其运算（如微分）的高效性，但这种高效性在很大程度上取决于单元的几何形状。通过这个编程练习 [@problem_id:3422992]，你将实现并比较拉普拉斯算子的完整形式和简化形式，以验证张量积结构何时可以被充分利用，以及几何复杂性何时会破坏这种简化。这种实践对于理解谱方法在真实世界网格上的性能至关重要。", "problem": "考虑在四边形和六面体单元上，张量积谱方法和间断伽辽金方法的强形式离散拉普拉斯残差。设参考单元为超立方体 $[-1,1]^d$，其维度 $d \\in \\{2,3\\}$。沿每个参考坐标使用多项式阶数为 $N$ 的 Legendre–Gauss–Lobatto (LGL) 节点，以及在这些节点上插值的张量积拉格朗日基。在物理坐标中定义一个可分离的构造解为 $u(x,y,z)=f(x)g(y)h(z)$，其中 $f(x)=\\sin(\\pi x)$、$g(y)=\\cos(2\\pi y)$ 和 $h(z)=\\exp(z)$，所有角度均以弧度为单位。\n\n给定一个从参考坐标 $(r,s,t)$ 到物理坐标 $(x,y,z)$ 的等参映射 $\\boldsymbol{x}(r,s,t)$。记雅可比矩阵为 $J=\\partial\\boldsymbol{x}/\\partial(r,s,t)$，其行列式为 $|J|$，逆变度量张量为 $G=J^{-1}J^{-T}$。节点上的变换后强形式拉普拉斯残差为\n$$\nR = \\frac{1}{|J|}\\sum_{a=1}^d \\frac{\\partial}{\\partial \\xi_a}\\left(|J|\\sum_{b=1}^d G^{ab}\\frac{\\partial u}{\\partial \\xi_b}\\right),\n$$\n其中 $(\\xi_1,\\xi_2,\\xi_3)=(r,s,t)$ 且 $(G^{ab})$ 是 $G$ 的分量。导数 $\\partial/\\partial \\xi_a$ 通过与 LGL 节点相关的一维微分矩阵 $D$ 进行离散化；在多维情况下，沿每个轴使用 $D$ 的张量积。沿一个轴的二阶导数通过在该轴上应用两次 $D$ 来实现。\n\n在仿射对角映射下（例如，$x=\\alpha_x r+\\beta_x$, $y=\\alpha_y s+\\beta_y$, $z=\\alpha_z t+\\beta_z$，其中 $\\alpha_x,\\alpha_y,\\alpha_z$ 为常数，且无交叉依赖），雅可比矩阵和度量张量是常数和对角的，并且离散残差可张量化：若 $F(r)=f(x(r))$, $G(s)=g(y(s))$, $H(t)=h(z(t))$，则\n$$\nR_{\\text{split}} = \\left(\\frac{\\partial^2 F}{\\partial r^2}\\frac{1}{\\alpha_x^2}\\right)G(s)H(t) + F(r)\\left(\\frac{\\partial^2 G}{\\partial s^2}\\frac{1}{\\alpha_y^2}\\right)H(t) + F(r)G(s)\\left(\\frac{\\partial^2 H}{\\partial t^2}\\frac{1}{\\alpha_z^2}\\right),\n$$\n其中二阶导数通过沿相应轴的 $D^2$ 进行离散化。这种构造仅涉及一维运算，并且在各轴之间是分离的。\n\n在弯曲映射（非仿射，带有交叉项，例如 $x=x(r,s,t)$ 依赖于多个参考坐标）上，$J$、$|J|$ 和 $G$ 随点变化，并可能具有非对角分量。在这种情况下，离散残差通常不等于上述由一维二阶导数（按局部对角链式法则因子，如 $1/x_r^2$、$1/y_s^2$、$1/z_t^2$ 缩放）构建的 $R_{\\text{split}}$，因为来自非对角度量项和映射导数的额外贡献会进入 $R$。\n\n您的任务是编写一个程序，该程序：\n- 为指定阶数构建 LGL 节点和一维微分矩阵 $D$。\n- 对每个映射，在张量积节点上计算构造解 $u(x,y,z)$。\n- 使用具有逐点 $|J|$ 和 $G$ 的变换后强形式计算完整离散残差 $R$。\n- 仅使用沿相应因子的每个轴的一维二阶导数，并按链式法则对角因子进行缩放，来计算分离残差 $R_{\\text{split}}$；对于二维情况，省略与 $z$ 相关的项。\n\n使用以下映射和参数的测试套件。在所有情况下，三角函数的角度必须以弧度为单位：\n1. 二维仿射对角映射：$x=1.1\\,r+0.3$，$y=0.9\\,s-0.2$，多项式阶数 $N=10$。检查 $\\|R-R_{\\text{split}}\\|_2/\\|R\\|_2 \\leq 10^{-9}$。\n2. 三维仿射对角映射：$x=0.7\\,r-0.1$，$y=1.2\\,s+0.05$，$z=0.8\\,t+0.02$，多项式阶数 $N=8$。检查 $\\|R-R_{\\text{split}}\\|_2/\\|R\\|_2 \\leq 10^{-8}$。\n3. 二维弯曲映射：$x=1.0\\,r+0.4+0.3\\,r\\,s$，$y=0.8\\,s-0.1+0.2\\,r^2$，多项式阶数 $N=10$。检查 $\\|R-R_{\\text{split}}\\|_2/\\|R\\|_2 \\geq 5\\times 10^{-4}$。\n4. 三维弯曲映射：$x=0.9\\,r+0.1+0.2\\,r\\,s$，$y=1.0\\,s-0.2+0.2\\,s\\,t$，$z=0.95\\,t+0.05+0.2\\,r\\,t$，多项式阶数 $N=7$。检查 $\\|R-R_{\\text{split}}\\|_2/\\|R\\|_2 \\geq 5\\times 10^{-4}$。\n\n对于每种情况，生成一个布尔结果来评估指定的不等式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[true,false,true,false]\"）。输出必须是小写字母，并且必须是布尔类型（而不是字符串）。\n\n除了三角函数的弧度规定外，不需要其他物理单位。所有计算都纯粹是在参考单元及其到物理空间的映射上进行的数值计算。\n\n最终输出格式必须是与测试套件案例顺序对应的四个布尔结果列表的单行。", "solution": "用户提供的问题经评估有效。它在科学上基于偏微分方程数值分析的原理，特别是谱方法和间断伽辽金方法。该问题定义明确、客观，并包含进行计算求解所需的所有信息。未检测到不一致、模糊之处或事实错误。\n\n本文提供了一个全面的解决方案，详细说明了解决该问题所需的理论背景和计算步骤。\n\n### 1. 理论框架\n\n该问题涉及在物理空间中的一般四边形或六面体单元上对拉普拉斯算子 $\\nabla^2 u$ 进行离散化。这是通过使用等参映射 $\\boldsymbol{x}(\\boldsymbol{\\xi})$ 将一个简单的参考单元，即超立方体 $\\mathcal{E}_{\\text{ref}} = [-1,1]^d$（其中 $d \\in \\{2,3\\}$），映射到物理单元来实现的，其中 $\\boldsymbol{x}=(x,y,z)$ 是物理坐标，$\\boldsymbol{\\xi}=(r,s,t)$ 是参考坐标。\n\n#### 1.1. 参考单元上的谱离散化\n\n我们使用基于一维 Legendre-Gauss-Lobatto (LGL) 点的张量积的节点谱方法。对于给定的多项式阶数 $N$，这 $N+1$ 个 LGL 节点 $\\{\\xi_j\\}_{j=0}^N$ 是 $(1-\\xi^2)P'_N(\\xi)$ 的零点，其中 $P_N$ 是 $N$ 次 Legendre 多项式。这些节点包括端点 $\\xi_0 = -1$ 和 $\\xi_N = 1$。\n\n$[-1,1]$ 上的函数 $f(\\xi)$ 由其在这些节点处的值 $f_j = f(\\xi_j)$ 表示。其导数可以使用微分矩阵 $D$ 进行代数计算。函数在节点处的导数由矩阵向量积给出：\n$$\n\\left. \\frac{df}{d\\xi} \\right|_{\\xi_j} \\approx \\sum_{k=0}^N D_{jk} f_k\n$$\n$(N+1) \\times (N+1)$ 微分矩阵 $D$ 的项由以下公式给出：\n$$\nD_{jk} = \n\\begin{cases}\n\\frac{P_N(\\xi_j)}{P_N(\\xi_k)(\\xi_j - \\xi_k)} & j \\neq k \\\\\n-\\frac{N(N+1)}{4} & j=k=0 \\\\\n\\frac{N(N+1)}{4} & j=k=N \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\n二阶导数通过应用该矩阵两次来近似，即使用 $D^2 = D \\cdot D$。在多维 ($d>1$) 情况下，节点形成一个张量积网格，导数通过沿相应轴应用一维微分矩阵来计算。对于二维网格上的函数 $F(r,s)$，偏导数计算为 $(D \\cdot F^T)^T$（对于 $\\partial/\\partial r$）和 $F \\cdot D^T$（对于 $\\partial/\\partial s$），或更普遍地使用张量缩并。\n\n#### 1.2. 变换后的拉普拉斯算子（完整残差 $R$）\n\n物理坐标 $(x,y,z)$ 中的拉普拉斯算子根据以下公式变换到参考坐标 $(r,s,t)$：\n$$\n\\nabla^2 u = \\frac{1}{|J|} \\sum_{a=1}^d \\frac{\\partial}{\\partial \\xi_a} \\left( |J| \\sum_{b=1}^d G^{ab} \\frac{\\partial u}{\\partial \\xi_b} \\right)\n$$\n这里，$\\boldsymbol{\\xi} = (\\xi_1, \\xi_2, \\xi_3) = (r,s,t)$，$J = \\frac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{\\xi}}$ 是映射的雅可比矩阵，$|J|$ 是其行列式，$G = J^{-1}J^{-T}$ 是逆变度量张量。右侧的表达式是待计算的量 $R$。\n\n在张量积 LGL 节点上计算 $R$ 的计算过程如下：\n1.  在参考网格 $\\boldsymbol{\\xi}_{ijk}$ 的所有节点上计算物理坐标 $\\boldsymbol{x}$。\n2.  通过使用谱微分矩阵 $D$ 对映射函数进行微分（例如，$x_r = \\partial x/\\partial r$，$x_s = \\partial x/\\partial s$ 等），在每个节点上计算雅可比矩阵 $J$ 的分量。由于映射可以是非线性的，$J$（以及 $|J|$ 和 $G$）将逐点变化。\n3.  在每个节点处，通过对 $J$ 求逆来计算行列式 $|J|$ 和度量张量 $G$。\n4.  在每个节点的物理坐标处计算构造解 $u(x,y,z)$。\n5.  使用矩阵 $D$ 计算解在参考坐标中的导数 $\\partial u/\\partial \\xi_b$。\n6.  在每个节点处形成通量分量 $F_a = |J| \\sum_{b=1}^d G^{ab} (\\partial u / \\partial \\xi_b)$。\n7.  再次使用矩阵 $D$ 计算通量的散度 $\\sum_{a=1}^d \\partial F_a/\\partial \\xi_a$。\n8.  最后，通过将步骤 7 的结果除以每个节点的 $|J|$ 来获得离散残差 $R$。\n\n#### 1.3. 分离近似（分离残差 $R_{\\text{split}}$）\n\n$R_{\\text{split}}$ 是拉普拉斯算子的一个简化近似，它忽略了由弯曲、非正交映射产生的几何复杂性。\n\n对于**仿射对角映射**，例如 $x=\\alpha_x r+\\beta_x$ 和 $y=\\alpha_y s+\\beta_y$，雅可比和度量张量是常数和对角的。具体来说，$J = \\text{diag}(\\alpha_x, \\alpha_y, \\alpha_z)$，$|J| = \\alpha_x\\alpha_y\\alpha_z$，$G = \\text{diag}(\\alpha_x^{-2}, \\alpha_y^{-2}, \\alpha_z^{-2})$。在这种特殊情况下，变换后的拉普拉斯算子简化为沿每个轴的缩放二阶导数之和：\n$$\n\\nabla^2 u = \\frac{1}{\\alpha_x^2} \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{\\alpha_y^2} \\frac{\\partial^2 u}{\\partial s^2} + \\frac{1}{\\alpha_z^2} \\frac{\\partial^2 u}{\\partial t^2}\n$$\n对于给定的可分离解 $u(x,y,z) = f(x)g(y)h(z)$，在此映射下变为 $u(x(r), y(s), z(t)) = F(r)G(s)H(t)$，残差可以完美地张量化。项 $\\partial^2 u / \\partial r^2$ 变为 $(\\partial^2 F/\\partial r^2) G(s) H(t)$。这导致了问题陈述中给出的 $R_{\\text{split}}$ 公式，该公式对于此类映射是精确的。\n\n对于**一般弯曲映射**，问题将 $R_{\\text{split}}$ 定义为扩展仿射情况逻辑的近似。它的构造方法是忽略所有非对角度量项（$a \\neq b$ 时的 $G^{ab}$）和所有几何因子（$|J|$ 和 $G^{ab}$）的导数。它只保留了链式法则中的对角缩放因子，如 $1/(\\partial x/\\partial r)^2$、$1/(\\partial y/\\partial s)^2$ 等，这些因子现在是位置相关的。“沿相应因子的每个轴的一维二阶导数”意味着对于 $u=f(x)g(y)h(z)$ 采用以下构造：\n$$\nR_{\\text{split}} = \\frac{g(y)h(z)}{(\\partial x/\\partial r)^2} \\frac{\\partial^2 f(x(r,s,t))}{\\partial r^2} + \\frac{f(x)h(z)}{(\\partial y/\\partial s)^2} \\frac{\\partial^2 g(y(r,s,t))}{\\partial s^2} + \\frac{f(x)g(y)}{(\\partial z/\\partial t)^2} \\frac{\\partial^2 h(z(r,s,t))}{\\partial t^2}\n$$\n其中所有导数都使用 $D$ 和 $D^2$ 进行谱计算。这种形式是一种近似，因为它省略了交叉导数项（例如 $\\partial^2 u / \\partial r \\partial s$）和由几何非均匀性产生的项（例如 $\\partial G^{ab}/\\partial \\xi_c$）。\n\n### 2. 计算方法\n\n该解决方案以 Python 脚本的形式实现，对每个测试用例执行以下步骤：\n\n1.  **设置**：定义一个函数 `lgl_diff_matrix(N)` 来计算给定阶数 $N$ 的 LGL 节点和一维微分矩阵 $D$。创建一个辅助函数 `spec_deriv(field, axis, D)` 来沿指定轴对多维数组应用微分矩阵。构建参考坐标网格 $\\boldsymbol{\\xi}$。\n2.  **映射和解**：根据当前测试用例的映射，在网格上计算物理坐标 $\\boldsymbol{x}(\\boldsymbol{\\xi})$。然后在这些物理坐标处计算构造解 $u(\\boldsymbol{x})$。\n3.  **计算 $R$**：按照第 1.2 节中的过程计算完整残差 $R$。这涉及尽可能使用向量化操作：\n    *   使用 `spec_deriv` 计算映射导数（例如 $x_r, x_s, ...$）。\n    *   在每个网格点上将雅可比矩阵 $J$ 组装成一个多维数组（例如，对于二维，形状为 `(N+1, N+1, 2, 2)`）。\n    *   使用 `numpy.linalg.det` 和 `numpy.linalg.inv` 在整个网格上计算 $|J|$ 和 $G$。\n    *   使用 `spec_deriv` 计算解的导数（$\\partial u/\\partial r$ 等）和通量导数。\n    *   根据 $R$ 的公式组合所有项。\n4.  **计算 $R_{\\text{split}}$**：计算分离残差 $R_{\\text{split}}$。\n    *   对于仿射情况，创建一维函数 `F(r)`、`G(s)`、`H(t)`，使用 $D^2$ 计算它们的二阶导数，进行缩放，并通过张量积（例如 `numpy.outer` 或广播）进行组合。\n    *   对于弯曲情况，使用第 1.3 节中的构造。在整个网格上定义因子 $f(x)$、$g(y)$、$h(z)$。使用 `spec_deriv` 计算它们各自的二阶导数（例如 $\\partial^2 f/\\partial r^2$）和所需的映射导数（例如 $\\partial x/\\partial r$），然后将它们组合起来。\n5.  **比较和验证**：计算差异的相对 L2 范数 $\\|R-R_{\\text{split}}\\|_2/\\|R\\|_2$。将结果与测试用例中指定的不等式进行比较，产生一个布尔值。\n6.  **输出**：收集所有四个测试用例的布尔结果，并以指定的列表格式打印。\n\n该过程正确地区分了算子的精确数学变换和常见的简化方法，验证了简化仅对几何简单（仿射对角）的映射有效。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\n\ndef lgl_diff_matrix(N):\n    \"\"\"\n    Computes the (N+1)x(N+1) LGL differentiation matrix and nodes.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0]), np.array([[0.0]])\n    \n    # Use roots of Jacobi polynomial P_{N-1}^{(1,1)} for internal nodes\n    jacobi_roots, _ = roots_jacobi(N - 1, 1, 1)\n    nodes = np.concatenate(([-1.0], jacobi_roots, [1.0]))\n\n    # Legendre polynomials at nodes\n    PN_vals = eval_legendre(N, nodes)\n\n    # Differentiation matrix\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = PN_vals[i] / (PN_vals[j] * (nodes[i] - nodes[j]))\n            elif i == 0:\n                D[i, i] = -N * (N + 1) / 4.0\n            elif i == N:\n                D[i, i] = N * (N + 1) / 4.0\n            else:\n                D[i, i] = 0.0\n    return nodes, D\n\ndef spec_deriv(F, axis, D):\n    \"\"\"\n    Computes the spectral derivative of a d-dimensional array F along a given axis.\n    \"\"\"\n    d = F.ndim\n    if axis  0 or axis >= d:\n        raise ValueError(\"Invalid axis\")\n    \n    # Permute the interested axis to the front\n    F_perm = np.moveaxis(F, axis, 0)\n    original_shape = F_perm.shape\n    \n    # Reshape for matrix multiplication\n    F_reshaped = F_perm.reshape(original_shape[0], -1)\n    \n    # Apply differentiation matrix\n    DF_reshaped = D @ F_reshaped\n    \n    # Reshape back to permuted shape\n    DF_perm = DF_reshaped.reshape(original_shape)\n    \n    # Permute axis back to original position\n    result = np.moveaxis(DF_perm, 0, axis)\n    \n    return result\n\ndef solve():\n    test_cases = [\n        {\n            'd': 2, 'N': 10,\n            'map': lambda r, s, t: (1.1 * r + 0.3, 0.9 * s - 0.2, None),\n            'map_params': {'ax': 1.1, 'ay': 0.9, 'az':None, 'beta_x': 0.3, 'beta_y': -0.2, 'beta_z':None},\n            'check': lambda err: err = 1e-9,\n            'is_affine_diag': True\n        },\n        {\n            'd': 3, 'N': 8,\n            'map': lambda r, s, t: (0.7 * r - 0.1, 1.2 * s + 0.05, 0.8 * t + 0.02),\n            'map_params': {'ax': 0.7, 'ay': 1.2, 'az': 0.8, 'beta_x': -0.1, 'beta_y': 0.05, 'beta_z': 0.02},\n            'check': lambda err: err = 1e-8,\n            'is_affine_diag': True\n        },\n        {\n            'd': 2, 'N': 10,\n            'map': lambda r, s, t: (1.0 * r + 0.4 + 0.3 * r * s, 0.8 * s - 0.1 + 0.2 * r**2, None),\n            'map_params': None,\n            'check': lambda err: err >= 5e-4,\n            'is_affine_diag': False\n        },\n        {\n            'd': 3, 'N': 7,\n            'map': lambda r, s, t: (0.9 * r + 0.1 + 0.2 * r * s, 1.0 * s - 0.2 + 0.2 * s * t, 0.95 * t + 0.05 + 0.2 * r * t),\n            'map_params': None,\n            'check': lambda err: err >= 5e-4,\n            'is_affine_diag': False\n        }\n    ]\n\n    results = []\n    \n    # Manufactured solution functions\n    f_sol = lambda x: np.sin(np.pi * x)\n    g_sol = lambda y: np.cos(2 * np.pi * y)\n    h_sol = lambda z: np.exp(z)\n\n    for case in test_cases:\n        N, d = case['N'], case['d']\n        nodes, D = lgl_diff_matrix(N)\n        D2 = D @ D\n        \n        # Create grid\n        if d == 2:\n            r, s = np.meshgrid(nodes, nodes, indexing='ij')\n            t = None\n            grid_coords = (r, s)\n        else: # d == 3\n            r, s, t = np.meshgrid(nodes, nodes, nodes, indexing='ij')\n            grid_coords = (r, s, t)\n\n        # Physical coordinates and solution\n        x, y, z = case['map'](r, s, t)\n        \n        if d == 2:\n            u = f_sol(x) * g_sol(y)\n        else:\n            u = f_sol(x) * g_sol(y) * h_sol(z)\n            \n        # --- Compute Full Residual R ---\n        # Mapping derivatives\n        coords = (x, y, z) if d == 3 else (x, y)\n        J = np.zeros(list(r.shape) + [d, d])\n        \n        for i in range(d): # physical coord index\n            for j in range(d): # reference coord index\n                J[..., i, j] = spec_deriv(coords[i], j, D)\n        \n        detJ = np.linalg.det(J)\n        invJ = np.linalg.inv(J)\n        G = np.einsum('...ij,...kj->...ik', invJ, invJ)\n        \n        # Solution derivatives in ref coords\n        u_derivs = [spec_deriv(u, i, D) for i in range(d)]\n        \n        # Flux vector F_a = |J| * sum_b(G_ab * du/dxi_b)\n        flux = np.zeros(list(r.shape) + [d])\n        for i in range(d):\n            for j in range(d):\n                flux[..., i] += G[..., i, j] * u_derivs[j]\n        flux *= detJ[..., np.newaxis]\n        \n        # Divergence of flux\n        div_flux = np.zeros_like(r)\n        for i in range(d):\n            div_flux += spec_deriv(flux[..., i], i, D)\n            \n        R = div_flux / detJ\n\n        # --- Compute Split Residual R_split ---\n        if case['is_affine_diag']:\n            ax = case['map_params']['ax']\n            ay = case['map_params']['ay']\n            beta_x = case['map_params']['beta_x']\n            beta_y = case['map_params']['beta_y']\n            \n            F_1d = f_sol(ax * nodes + beta_x)\n            G_1d = g_sol(ay * nodes + beta_y)\n            \n            F_rr_1d = D2 @ F_1d\n            G_ss_1d = D2 @ G_1d\n            \n            if d == 2:\n                term1 = np.outer(F_rr_1d / (ax**2), G_1d)\n                term2 = np.outer(F_1d, G_ss_1d / (ay**2))\n                R_split = term1 + term2\n            else: # d == 3\n                az = case['map_params']['az']\n                beta_z = case['map_params']['beta_z']\n                H_1d = h_sol(az * nodes + beta_z)\n                H_tt_1d = D2 @ H_1d\n                \n                term1 = (F_rr_1d/ax**2)[:,None,None] * G_1d[None,:,None] * H_1d[None,None,:]\n                term2 = F_1d[:,None,None] * (G_ss_1d/ay**2)[None,:,None] * H_1d[None,None,:]\n                term3 = F_1d[:,None,None] * G_1d[None,:,None] * (H_tt_1d/az**2)[None,None,:]\n                R_split = term1 + term2 + term3\n        else: # Curved map\n            f_factor = f_sol(x)\n            g_factor = g_sol(y)\n\n            derivatives = [spec_deriv(f, 0, D) for f in (x,y,z) if f is not None]\n            xr, ys = derivatives[0], derivatives[1]\n            if d==3: zt = derivatives[2]\n            \n            f_rr = spec_deriv(spec_deriv(f_factor, 0, D), 0, D)\n            g_ss = spec_deriv(spec_deriv(g_factor, 1, D), 1, D)\n\n            if d == 2:\n                term1 = f_rr * g_factor / (xr**2)\n                term2 = f_factor * g_ss / (ys**2)\n                R_split = term1 + term2\n            else: # d == 3\n                h_factor = h_sol(z)\n                h_tt = spec_deriv(spec_deriv(h_factor, 2, D), 2, D)\n                term1 = f_rr * g_factor * h_factor / (xr**2)\n                term2 = f_factor * g_ss * h_factor / (ys**2)\n                term3 = f_factor * g_factor * h_tt / (zt**2)\n                R_split = term1 + term2 + term3\n        \n        # --- Comparison ---\n        norm_R = np.linalg.norm(R)\n        if norm_R  1e-15: # R is effectively zero, handle division by zero\n            norm_diff = np.linalg.norm(R - R_split)\n            relative_error = norm_diff\n        else:\n            relative_error = np.linalg.norm(R - R_split) / norm_R\n        \n        results.append(case['check'](relative_error))\n\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3422992"}]}