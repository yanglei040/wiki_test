{"hands_on_practices": [{"introduction": "要深刻理解低存储龙格-库塔（LSRK）格式，第一步是掌握其稳定性分析的基本原理。这个练习将引导你从第一性原理出发，推导一个典型LSRK格式的绝对稳定函数，并将其应用于一个简单的间断伽辽金（DG）离散格式。通过这个分析过程，你将亲身体验时间积分格式的特性如何与空间离散算子的谱属性相结合，最终决定数值方法的稳定性边界，即库朗数（Courant number）的上限[@problem_id:3397065]。", "problem": "考虑一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中平流速度 $a  0$ 为常数，定义在周期性域 $x \\in [0,L]$ 上。在空间上，使用间断 Galerkin (DG) 方法进行离散化，该方法在包含 $K$ 个单元、单元大小为 $h = L/K$ 的均匀网格上使用分片常数（多项式次数 $p=0$）。数值通量等于迎风通量，并在每个单元内使用标准的 $L^{2}$ 集中质量。这将产生一个半离散的线方法 $\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = L\\,\\mathbf{u}(t)$，其中 $L$ 是一个块循环矩阵。\n\n时间推进通过以下二寄存器、低存储、三阶段、三阶格式执行（等价于三阶 Shu–Osher 强稳定保持 Runge–Kutta 方法），该格式适用于任何右端项 $F(\\mathbf{u})$：\n- 阶段 1：$\\mathbf{u}^{(1)} = \\mathbf{u}^{n} + \\Delta t\\,F(\\mathbf{u}^{n})$。\n- 阶段 2：$\\mathbf{u}^{(2)} = \\frac{3}{4}\\,\\mathbf{u}^{n} + \\frac{1}{4}\\left(\\mathbf{u}^{(1)} + \\Delta t\\,F(\\mathbf{u}^{(1)})\\right)$。\n- 阶段 3：$\\mathbf{u}^{n+1} = \\frac{1}{3}\\,\\mathbf{u}^{n} + \\frac{2}{3}\\left(\\mathbf{u}^{(2)} + \\Delta t\\,F(\\mathbf{u}^{(2)})\\right)$。\n\n您的任务是：\n1. 从应用于线性测试方程 $y'(t) = \\lambda\\,y(t)$ 的 Runge–Kutta 方法的绝对稳定函数的定义出发，推导上述低存储格式的稳定函数 $R(z)$，其中 $z = \\lambda\\,\\Delta t$。\n2. 对于均匀周期网格上采用 $p=0$ 和迎风通量的 DG 半离散化，通过应用傅里叶模态拟设来推导半离散算子 $L$ 的特征值集合 $\\Lambda(L)$。然后，使用 Courant 数 $C = a\\,\\Delta t/h$，将稳定性条件 $\\max_{\\lambda \\in \\Lambda(L)}\\left|R(\\Delta t\\,\\lambda)\\right| \\le 1$ 表示为一个关于 $C$ 的条件，该条件涉及一个相对于傅里叶相位 $\\theta \\in [0,2\\pi]$ 的显式单变量极值化问题。\n3. 确定最大允许 Courant 数 $C_{\\max}$，使得对于所有 $\\lambda \\in \\Lambda(L)$ 都满足绝对稳定性条件。您的最终答案必须是一个实数。将您的答案四舍五入到四位有效数字。\n\n除了上述定义和给定的格式外，不得使用任何进一步的简化或预先推导的公式。请清楚地说明您所做的任何中间变换，并根据线方法、采用迎风通量的 DG 半离散化以及 Runge–Kutta 绝对稳定函数的定义，从第一性原理证明每一步。最终答案必须是 $C_{\\max}$ 的单个值（无单位）。", "solution": "用户提供了一个三部分问题，涉及对线性平流方程的间断 Galerkin (DG) 有限元方法与低存储 Runge-Kutta (RK) 时间积分格式相结合的稳定性分析。首先，必须确定问题的有效性。\n\n### 步骤 1：提取已知条件\n- **方程**：一维线性平流方程 $u_{t} + a\\,u_{x} = 0$，其中平流速度 $a  0$ 为常数。\n- **域**：周期性域，$x \\in [0,L]$。\n- **空间离散化**：\n    - 方法：间断 Galerkin (DG)。\n    - 多项式次数：$p=0$（分片常数）。\n    - 网格：包含 $K$ 个单元、单元大小为 $h = L/K$ 的均匀网格。\n    - 数值通量：迎风通量。\n    - 质量矩阵：标准的 $L^2$ 集中质量。\n- **半离散形式**：$\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = L\\,\\mathbf{u}(t)$，其中 $L$ 是一个块循环矩阵。\n- **时间积分格式**：一个二寄存器、低存储、三阶段、三阶格式 (SSP-RK3)：\n    - 阶段 1：$\\mathbf{u}^{(1)} = \\mathbf{u}^{n} + \\Delta t\\,F(\\mathbf{u}^{n})$。\n    - 阶段 2：$\\mathbf{u}^{(2)} = \\frac{3}{4}\\,\\mathbf{u}^{n} + \\frac{1}{4}\\left(\\mathbf{u}^{(1)} + \\Delta t\\,F(\\mathbf{u}^{(1)})\\right)$。\n    - 阶段 3：$\\mathbf{u}^{n+1} = \\frac{1}{3}\\,\\mathbf{u}^{n} + \\frac{2}{3}\\left(\\mathbf{u}^{(2)} + \\Delta t\\,F(\\mathbf{u}^{(2)})\\right)$。\n- **定义**：Courant 数 $C = a\\,\\Delta t/h$。\n- **任务**：\n    1. 推导该格式对于 $z = \\lambda\\,\\Delta t$ 的稳定函数 $R(z)$。\n    2. 推导 DG 半离散化的特征值集合 $\\Lambda(L)$，并将稳定性条件 $\\max_{\\lambda \\in \\Lambda(L)}\\left|R(\\Delta t\\,\\lambda)\\right| \\le 1$ 表示为一个关于 $C$ 且对傅里叶相位 $\\theta$ 进行极值化的问题。\n    3. 确定最大允许 Courant 数 $C_{\\max}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学上合理**：该问题牢固地植根于偏微分方程数值分析领域。DG 方法、Runge-Kutta 格式和稳定性分析都是标准的、完善的课题。线性平流方程是一个典型的模型问题。所有元素在科学上都是合理的。\n2.  **适定**：问题被构造成一系列推导，最终导出一个数值。每个部分都定义清晰，并以前一部分为基础，从而得到一个唯一且有意义的解（$C_{\\max}$）。\n3.  **客观**：问题以精确、客观的数学语言陈述。没有主观或基于意见的论断。\n4.  **完整性**：问题提供了所有必要的信息：偏微分方程、离散化细节（DG、$p=0$、迎风通量、周期性边界条件）、时间步进格式以及 Courant 数的定义。虽然问题将矩阵 $L$ 标记为“块循环”，但对于 $p=0$ 的情况，它是一个简单的（非块）循环矩阵。这是一个微小的术语不精确之处，但不影响可解性或造成矛盾，因为其结构完全由其他规范确定。\n5.  **其他缺陷**：该问题不是隐喻性的、琐碎的、不适定的或无法验证的。这是一个标准的、尽管详细的数值分析问题。\n\n### 步骤 3：结论与行动\n此问题是**有效**的。现在将提供一个完整的、有理有据的解答。\n\n### 解答\n\n问题按要求分为三个连续部分来解决。\n\n**第 1 部分：稳定函数 $R(z)$ 的推导**\n\nRunge-Kutta 方法的稳定函数 $R(z)$ 由关系式 $y^{n+1} = R(z) y^n$ 定义，当该方法应用于线性测试方程 $y'(t) = \\lambda y(t)$ 时。这里，右端函数是 $F(y) = \\lambda y$，我们定义 $z = \\lambda \\Delta t$。我们将此应用于给定的三阶段格式。\n\n对于第一阶段：\n$$y^{(1)} = y^n + \\Delta t F(y^n) = y^n + \\Delta t (\\lambda y^n) = (1 + \\lambda \\Delta t) y^n = (1+z) y^n$$\n\n对于第二阶段，我们首先计算 $F$ 的参数，即 $y^{(1)}$，然后代入 $y^{(1)}$ 的表达式：\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} \\left( y^{(1)} + \\Delta t F(y^{(1)}) \\right) = \\frac{3}{4} y^n + \\frac{1}{4} \\left( y^{(1)} + \\Delta t (\\lambda y^{(1)}) \\right)$$\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} (1 + \\lambda \\Delta t) y^{(1)} = \\frac{3}{4} y^n + \\frac{1}{4} (1+z) y^{(1)}$$\n代入 $y^{(1)} = (1+z)y^n$：\n$$y^{(2)} = \\frac{3}{4} y^n + \\frac{1}{4} (1+z)(1+z) y^n = \\left[ \\frac{3}{4} + \\frac{1}{4}(1+z)^2 \\right] y^n$$\n展开关于 $z$ 的多项式：\n$$y^{(2)} = \\left[ \\frac{3}{4} + \\frac{1}{4}(1 + 2z + z^2) \\right] y^n = \\left[ \\frac{3}{4} + \\frac{1}{4} + \\frac{2}{4}z + \\frac{1}{4}z^2 \\right] y^n = \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 \\right) y^n$$\n\n对于第三个也是最后一个阶段：\n$$y^{n+1} = \\frac{1}{3} y^n + \\frac{2}{3} \\left( y^{(2)} + \\Delta t F(y^{(2)}) \\right) = \\frac{1}{3} y^n + \\frac{2}{3} (1 + \\lambda \\Delta t) y^{(2)}$$\n$$y^{n+1} = \\frac{1}{3} y^n + \\frac{2}{3} (1+z) y^{(2)}$$\n代入 $y^{(2)}$ 的表达式：\n$$y^{n+1} = \\left[ \\frac{1}{3} + \\frac{2}{3} (1+z) \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 \\right) \\right] y^n$$\n方括号中的表达式就是稳定函数 $R(z)$。我们展开它：\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 \\cdot (1 + \\frac{1}{2}z + \\frac{1}{4}z^2) + z \\cdot (1 + \\frac{1}{2}z + \\frac{1}{4}z^2) \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 + \\frac{1}{2}z + \\frac{1}{4}z^2 + z + \\frac{1}{2}z^2 + \\frac{1}{4}z^3 \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} \\left( 1 + \\frac{3}{2}z + \\frac{3}{4}z^2 + \\frac{1}{4}z^3 \\right)$$\n$$R(z) = \\frac{1}{3} + \\frac{2}{3} + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$$\n$$R(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$$\n这是 $\\exp(z)$ 的泰勒级数展开到三阶项，证实了该方法的三阶精度。\n\n**第 2 部分：特征值谱与稳定性条件**\n\n我们首先推导 $p=0$ 的 DG 方法的半离散系统。在单元 $I_j = [x_{j-1/2}, x_{j+1/2}]$ 上的 DG 弱形式是寻找 $u_h$，使得对于所有测试函数 $v_h$：\n$$\\int_{I_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx + \\int_{I_j} a \\frac{\\partial u_h}{\\partial x} v_h \\,dx = 0$$\n对第二项使用分部积分法：\n$$\\int_{I_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx - \\int_{I_j} a u_h \\frac{\\partial v_h}{\\partial x} \\,dx + [a u_h^* v_h]_{x_{j-1/2}}^{x_{j+1/2}} = 0$$\n对于 $p=0$，$u_h(x,t) = u_j(t)$ 和 $v_h(x) = v_j$ 在 $I_j$ 上是常数。令 $v_j=1$。积分内的导数消失。方程变为：\n$$h \\frac{du_j}{dt} + a u^*(x_{j+1/2}) - a u^*(x_{j-1/2}) = 0$$\n问题指定了迎风通量。由于 $a0$，风从左向右吹。界面处的数值通量 $u^*$ 是取自左侧（迎风）的值。\n在界面 $x_{j+1/2}$ 处，左侧状态为 $u_j$，右侧状态为 $u_{j+1}$。所以，$u^*(x_{j+1/2}) = u_j$。\n在界面 $x_{j-1/2}$ 处，左侧状态为 $u_{j-1}$，右侧状态为 $u_j$。所以，$u^*(x_{j-1/2}) = u_{j-1}$。\n将这些通量代入半离散方程：\n$$h \\frac{du_j}{dt} + a u_j - a u_{j-1} = 0 \\implies \\frac{du_j}{dt} = -\\frac{a}{h} (u_j - u_{j-1})$$\n这定义了算子 $L$ 的作用：$(L\\mathbf{u})_j = -\\frac{a}{h} (u_j - u_{j-1})$。\n为了找到 $L$ 的特征值 $\\lambda$，我们对网格函数 $\\mathbf{u}$ 使用傅里葉模态拟设，并考虑周期性。令 $u_j(t) = \\hat{u}(t) e^{i k x_j}$，其中 $x_j = j h$，$k$ 是波数。\n$$\\frac{d}{dt} (\\hat{u} e^{ikjh}) = -\\frac{a}{h} (\\hat{u} e^{ikjh} - \\hat{u} e^{ik(j-1)h})$$\n$$\\frac{d\\hat{u}}{dt} e^{ikjh} = -\\frac{a}{h} \\hat{u} e^{ikjh} (1 - e^{-ikh})$$\n$$\\frac{d\\hat{u}}{dt} = \\left[-\\frac{a}{h} (1 - e^{-ikh})\\right] \\hat{u}$$\n因此，算子 $L$ 的特征值为 $\\lambda(k) = -\\frac{a}{h} (1 - e^{-ikh})$。\n周期域 $[0, L]$ 和网格尺寸 $h=L/K$ 要求波数满足 $kL = 2\\pi m$，其中 $m$为整数。因此，$k = \\frac{2\\pi m}{L} = \\frac{2\\pi m}{Kh}$。\n令 $\\theta_m = kh = \\frac{2\\pi m}{K}$ 为离散傅里叶相位，其中 $m = 0, 1, \\dots, K-1$。当单元数量 $K \\to \\infty$ 时，$\\theta$ 可以视为在 $[0, 2\\pi]$ 内的连续变量。\n特征值为 $\\lambda(\\theta) = -\\frac{a}{h}(1 - e^{-i\\theta}) = \\frac{a}{h}(e^{-i\\theta} - 1)$。\n稳定函数 $R(z)$ 的参数是 $z = \\Delta t \\lambda$。\n$$z(\\theta) = \\Delta t \\lambda(\\theta) = \\frac{a \\Delta t}{h} (e^{-i\\theta} - 1) = C(e^{-i\\theta} - 1)$$\n其中 $C = a \\Delta t/h$ 是 Courant 数。\n稳定性条件是对于 $L$ 的所有特征值 $\\lambda$，放大因子 $|R(\\Delta t \\lambda)|$ 不得大于 1。在 $K \\to \\infty$ 的极限下，这成为一个关于连续相位 $\\theta$ 的极值问题：\n$$\\max_{\\theta \\in [0, 2\\pi]} |R(z(\\theta))| \\le 1$$\n代入 $R(z)$ 和 $z(\\theta)$ 的表达式，条件为：\n$$\\max_{\\theta \\in [0, 2\\pi]} \\left| 1 + C(e^{-i\\theta}-1) + \\frac{1}{2} C^2(e^{-i\\theta}-1)^2 + \\frac{1}{6} C^3(e^{-i\\theta}-1)^3 \\right| \\le 1$$\n\n**第 3 部分：最大允许 Courant 数 $C_{\\max}$**\n\n点集 $z(\\theta) = C(e^{-i\\theta} - 1)$（其中 $\\theta \\in [0, 2\\pi]$）在复平面上描绘出一个圆。记 $z = x+iy$，我们有 $x = C(\\cos\\theta - 1)$ 和 $y = -C\\sin\\theta$。由此可知 $(x+C)^2 + y^2 = C^2\\cos^2\\theta + C^2\\sin^2\\theta = C^2$。这是一个以 $-C$ 为中心、半径为 $C$ 的圆。\n\n稳定性条件要求整个圆都位于 RK 方法的绝对稳定区域内，该区域定义为 $\\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$。最大允许 Courant 数 $C_{\\max}$ 是使该圆从内部与稳定区域边界相切的 $C$ 值。\n\n对于许多耗散数值格式，最严格的稳定性约束来自网格上可表示的最高频率模式。对于迎风格式，这对应于 $\\theta=\\pi$，此时特征值具有最大的负实部。我们假设 $|R(z(\\theta))|$ 的最大值出现在 $\\theta=\\pi$处。\n当 $\\theta = \\pi$ 时，我们有 $e^{-i\\pi} = -1$。对应的 $z$ 值为：\n$$z(\\pi) = C(-1-1) = -2C$$\n该点位于负实轴上。该点的稳定性条件是 $|R(-2C)| \\leq 1$。\n对于一个实数负自变量 $-x$（其中 $x  0$），稳定函数是实数：\n$$R(-x) = 1 - x + \\frac{1}{2}x^2 - \\frac{1}{6}x^3$$\n所以，我们需要 $|R(-2C)| \\le 1$，这等价于 $-1 \\le R(-2C) \\le 1$。我们来检查这两个不等式。\n1. $R(-2C) \\le 1$:\n$$1 - 2C + \\frac{1}{2}(-2C)^2 - \\frac{1}{6}(-2C)^3 \\le 1$$\n$$ -2C + 2C^2 + \\frac{4}{3}C^3 \\le 0$$\n由于 $C0$，我们可以除以 $2C$：\n$$-1 + C + \\frac{2}{3}C^2 \\le 0 \\implies \\frac{2}{3}C^2 + C - 1 \\le 0$$\n$\\frac{2}{3}C^2 + C - 1 = 0$ 的根为 $C = \\frac{-1 \\pm \\sqrt{1 - 4(2/3)(-1)}}{2(2/3)} = \\frac{-1 \\pm \\sqrt{1+8/3}}{4/3} = \\frac{3}{4}(-1 \\pm \\sqrt{11/3})$。由于 $C0$，此不等式对于任何相关的 $C$ 都不成立。我重新计算一下我的符号。$R(-x) = 1 - x + x^2/2 - x^3/6$。所以 $R(-2C) = 1 - 2C + (4C^2)/2 - (8C^3)/6 = 1 - 2C + 2C^2 - \\frac{4}{3}C^3$。\n我为这个错误道歉。让我们用正确的多项式重新计算。\n$$R(-2C) = 1 - 2C + 2C^2 - \\frac{4}{3}C^3$$\n1. 不等式 $R(-2C) \\le 1$：\n$$1 - 2C + 2C^2 - \\frac{4}{3}C^3 \\le 1 \\implies -2C + 2C^2 - \\frac{4}{3}C^3 \\le 0$$\n两边除以 $-2C$（并因为 $-2C0$ 而翻转不等号）：\n$$1 - C + \\frac{2}{3}C^2 \\ge 0$$\n这个二次方程的判别式是 $D = (-1)^2 - 4(\\frac{2}{3})(1) = 1 - \\frac{8}{3}  0$。由于首项系数为正，该二次式总是正的。此不等式对所有 $C$ 都成立。\n\n2. 不等式 $R(-2C) \\ge -1$：\n$$1 - 2C + 2C^2 - \\frac{4}{3}C^3 \\ge -1$$\n$$2 - 2C + 2C^2 - \\frac{4}{3}C^3 \\ge 0$$\n令 $f(C) = 2 - 2C + 2C^2 - \\frac{4}{3}C^3$。我们需要找到满足 $f(C) \\ge 0$ 的最大 $C$。我们来考察其导数：\n$$f'(C) = -2 + 4C - 4C^2 = -2(1 - 2C + 2C^2)$$\n二次式 $1 - 2C + 2C^2$ 的判别式是 $D = (-2)^2 - 4(2)(1) = 4 - 8 = -4  0$。由于首项系数为正，该二次式总是正的。因此，$f'(C)$ 总是负的，$f(C)$ 对于所有 $C$ 都是一个严格递减的函数。\n$C$ 的最大允许值，记为 $C_{\\max}$，将是方程 $f(C) = 0$ 的根。\n$$2 - 2C_{\\max} + 2C_{\\max}^2 - \\frac{4}{3}C_{\\max}^3 = 0$$\n两边乘以 $-\\frac{3}{2}$ 以简化：\n$$2C_{\\max}^3 - 3C_{\\max}^2 + 3C_{\\max} - 3 = 0$$\n这是一个关于 $C_{\\max}$ 的三次方程。我们必须用数值方法求解。令 $g(C) = 2C^3 - 3C^2 + 3C - 3$。\n$g(1) = 2-3+3-3 = -1$。\n$g(1.5) = 2(3.375) - 3(2.25) + 3(1.5) - 3 = 6.75 - 6.75 + 4.5 - 3 = 1.5$。\n根位于 $1$ 和 $1.5$ 之间。使用数值求解器（例如，牛顿法）：\n我们从初始猜测 $C_0 = 1.2$ 开始。\n$g(1.2) = 2(1.728) - 3(1.44) + 3(1.2) - 3 = 3.456 - 4.32 + 3.6 - 3 = -0.264$。\n$g'(C) = 6C^2 - 6C + 3$。\n$g'(1.2) = 6(1.44) - 6(1.2) + 3 = 8.64 - 7.2 + 3 = 4.44$。\n$C_1 = C_0 - \\frac{g(C_0)}{g'(C_0)} = 1.2 - \\frac{-0.264}{4.44} \\approx 1.2 + 0.059459 = 1.259459$。\n进一步迭代得到根的更精确值：\n$C_{\\max} \\approx 1.2564115$。\n将答案四舍五入到四位有效数字，我们得到 $C_{\\max} = 1.256$。", "answer": "$$\\boxed{1.256}$$", "id": "3397065"}, {"introduction": "在掌握了理论分析的基础后，下一个挑战是在更真实的计算场景中应用这些知识。本练习要求你通过编程实践，对比传统四阶龙格-库塔（RK4）方法和一个高效的五阶四步低存储方案（LSRK54）的稳定性差异[@problem_id:3397159]。你将需要为高阶DG方法构建空间算子，计算其特征值谱，并数值化地确定两种时间积分格式所允许的最大稳定时间步长，从而量化低存储格式在内存优化与稳定性方面的权衡。", "problem": "考虑在周期性区域 $[0,1]$ 上、平流速度为 $a = 1$ 的一维线性平流初值问题，该问题由 $u_t + a u_x = 0$ 给出。使用高阶间断 Galerkin (DG) 方法对空间域进行离散化，该方法采用均匀剖分，将区域划分为 $N$ 个大小为 $h = 1/N$ 的单元。在每个单元上，使用位于 Legendre–Gauss–Lobatto 点的多项式次数为 $p$ 的节点基（因此每个单元有 $p+1$ 个节点）。使用与 $a = 1$ 一致的迎风数值通量。\n\n半离散 DG 算子可以使用分部求和性质写成强形式，其中参考单元上的微分矩阵 $D$ 和求积权重矩阵 $W$ 满足 $Q = W D$ 和 $Q + Q^\\top = B$，其中 $B$ 是一个对角矩阵，用于选择边界节点。在此公式中，半离散系统具有 $u_t = L u$ 的形式，其中 $L$ 是由单元体积项以及迎风通量和周期性边界条件引起的面耦合项组装而成的全局 DG 矩阵。对于显式时间步进，应用于半离散系统 $u_t = L u$ 的单步方法的稳定性由绝对稳定函数 $R(z)$ 在 $z = \\Delta t \\lambda$ 处的值决定，其中 $\\lambda$ 遍历 $L$ 的所有特征值。稳定性要求 $\\max_{\\lambda \\in \\Lambda(L)} |R(\\Delta t \\lambda)| \\le 1$。在高阶 DG 分析中，已经确定平流算子的谱半径因逆不等式和迹估计而按 $\\mathcal{O}(p^2/h)$ 缩放，这促使对于显式 Runge–Kutta 型方法，Courant–Friedrichs–Lewy (CFL) 条件的形式为 $\\Delta t \\frac{p^2}{h} \\le C$。\n\n您的任务是实现并比较从经典的四阶 Runge–Kutta 方法 (RK4) 切换到五级四阶双寄存器低存储 Runge–Kutta 方法（通常称为 Carpenter–Kennedy 2N-存储低存储格式）时，稳定性限制的时间步长系数 $C$。经典的四阶 Runge–Kutta 方法具有已知的稳定性函数，而低存储方法可以使用两个寄存器和常数系数的级递推更新来表示。在所有情况下，都必须根据给定的 $p$ 和 $N$ 下组装的 DG 算子的完整复数谱来验证时间稳定性。\n\n您的推导应基于以下基本事实：\n- 采用迎风通量和周期性边界条件的线性平流的半离散 DG 公式产生一个线性系统 $u_t = L u$，其特征值的模按 $\\mathcal{O}(p^2/h)$ 缩放。\n- 对于应用于 $u_t = L u$ 的显式 Runge–Kutta 方法，稳定性由稳定性函数 $R(z)$ 在集合 $z = \\Delta t \\lambda$ 上的模决定，其中 $\\lambda$ 是 $L$ 的特征值。\n\n在这些基础上，推导一个算法，用于在固定的 $p$ 和 $N$ 下，计算使方法保持稳定的最大 $\\Delta t$，并通过 $C = \\Delta t \\frac{p^2}{h}$ 报告相应的 $C$。通过组装以下内容来实现 $L$：\n- 参考单元上次数为 $p$ 的 Legendre–Gauss–Lobatto 节点和权重。\n- 通过重心权重构建的参考单元上的节点微分矩阵 $D$。\n- 在 $N$ 个单元上具有迎风通量和周期性边界条件的全局强形式 DG 平流算子 $L$。\n\n然后，对于每个 Runge–Kutta 格式：\n- 计算 $L$ 的特征值。\n- 通过在 $\\Delta t$ 上进行单调二分法搜索，并在每一步检查 $\\max_{\\lambda} |R(\\Delta t \\lambda)| \\le 1$，来确定最大稳定 $\\Delta t$。\n- 计算 $C = \\Delta t \\frac{p^2}{h}$。\n\n不需要角度测量，也不需要物理单位；所有量都是无量纲的。\n\n测试套件：\n- 使用 $N = 16$ 个单元，平流速度 $a = 1$，以及周期性边界条件。\n- 针对 $p \\in \\{2,4,8\\}$ 评估这些格式。\n- 格式：\n  1. 经典的四阶 Runge–Kutta（用代码字符串 \"RK4\" 表示）。\n  2. 双寄存器低存储五级四阶 Runge–Kutta（用代码字符串 \"LSRK54\" 表示）。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按 $[C_{\\mathrm{RK4}}(p{=}2), C_{\\mathrm{LSRK54}}(p{=}2), C_{\\mathrm{RK4}}(p{=}4), C_{\\mathrm{LSRK54}}(p{=}4), C_{\\mathrm{RK4}}(p{=}8), C_{\\mathrm{LSRK54}}(p{=}8)]$ 的顺序排列。", "solution": "用户提供了一个科学上有效且适定的问题。任务是为一维线性平流方程的高阶间断 Galerkin (DG) 离散，计算稳定性限制的 Courant–Friedrichs–Lewy (CFL) 系数，记为 $C$。此分析将针对两种不同的显式 Runge-Kutta 时间步进格式进行。\n\n该问题由以下初值问题控制：\n$$ u_t + a u_x = 0, \\quad x \\in [0,1], \\quad t  0 $$\n平流速度为 $a=1$，并采用周期性边界条件。\n\n求解过程分为几个步骤：\n1.  **构建半离散 DG 算子**：空间域被离散为 $N$ 个单元，并在每个单元内使用基于 Legendre-Gauss-Lobatto (LGL) 点的 $p$ 次多项式节点基。半离散系统是一个形如 $\\frac{d\\vec{U}}{dt} = L\\vec{U}$ 的常微分方程组，其中 $\\vec{U}$ 是节点值的全局向量，$L$ 是全局 DG 算子。矩阵 $L$ 是通过组装每个单元的局部算子构建的，这些算子包含了体积导数和单元间的通量贡献。对于此问题，使用迎风通量。\n\n2.  **推导 DG 算子矩阵 ($L$)**：全局算子 $L$ 是一个 $N(p+1) \\times N(p+1)$ 的矩阵。\n    -   **LGL 节点和权重**：对于多项式次数 $p$，我们需要参考单元 $[-1,1]$ 上的 $p+1$ 个 LGL 节点 $\\xi_j$ 和求积权重 $w_j$。节点是 $(1-x^2)P_p'(x)$ 的根，其中 $P_p(x)$ 是 $p$ 次 Legendre 多项式。\n    -   **微分矩阵 ($D$)**：在参考单元上构建一个微分矩阵 $D$，使得对于一个节点值向量 $\\vec{v}$，$D\\vec{v}$ 近似于这些节点处的导数。\n    -   **强形式算子**：应用于单元 $k$（大小为 $h=1/N$）上解向量 $\\vec{u}_k$ 的 DG 算子的强形式由一个体积项和一个表面通量修正项组成。单元 $k$ 上节点值 $\\vec{u}_k$ 的时间演化由下式给出：\n        $$ \\frac{d\\vec{u}_k}{dt} = -\\frac{2a}{h} D \\vec{u}_k + \\text{FluxCorrection}(\\vec{u}_k, \\vec{u}_{neighbors}) $$\n    -   **迎风通量**：对于 $a=10$，界面处的迎风通量是来自左侧单元的值。在单元 $k$ 的右边界（界面 $k+1/2$），数值通量等于内部迹 $u_{k,p}$，因此修正为零。在左边界（界面 $k-1/2$），数值通量是外部迹 $u_{k-1,p}$。通量修正项仅影响单元的第一个节点 $u_{k,0}$。对 $\\frac{du_{k,0}}{dt}$ 的此修正由下式给出：\n        $$ M_0^{-1} a ( u_{k,0} - u_{k-1,p} ) = \\frac{a}{w_0 h/2} ( u_{k,0} - u_{k-1,p} ) = \\frac{2a}{h w_0} ( u_{k,0} - u_{k-1,p} ) $$\n        此项被加到右侧。\n    -   **组装 L**：全局矩阵 $L$ 是通过分配这些局部贡献来组装的。对于每个单元 $k$，一个对应于 $-\\frac{2a}{h}D$ 的块被放置在对角线上。然后，通量修正项将值 $\\frac{2a}{h w_0}$ 添加到将 $u_{k,0}$ 映射到 $\\dot{u}_{k,0}$ 的矩阵项中，将值 $-\\frac{2a}{h w_0}$ 添加到将 $u_{k-1,p}$ 映射到 $\\dot{u}_{k,0}$ 的项中。周期性边界条件规定，对于 $k=0$，“前一个”单元是 $k=N-1$。\n\n3.  **分析时间稳定性**：应用于 $\\frac{d\\vec{U}}{dt} = L\\vec{U}$ 的显式 Runge-Kutta 方法的稳定性由其稳定性函数 $R(z)$ 决定。该方法是稳定的，当且仅当对于 $L$ 的所有特征值 $\\lambda$，都有 $|R(\\Delta t \\lambda)| \\le 1$。\n    -   **L 的特征值**：特征值 $\\lambda$ 通过数值计算得到。\n    -   **稳定性函数**：\n        -   对于经典的四阶 Runge-Kutta 方法 (RK4)，稳定性多项式是 $e^z$ 最高到四次的泰勒展开：\n            $$ R_{\\mathrm{RK4}}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} $$\n        -   对于指定的五级、四阶、双寄存器低存储 Runge-Kutta 格式 (LSRK54)，稳定性多项式由其递推关系构建。该格式可以写为：\n            $$ d_0 = 0, \\quad q_0 = U_n $$\n            $$ d_i = A_i d_{i-1} + \\Delta t f(q_{i-1}), \\quad q_i = q_{i-1} + B_i d_i \\quad \\text{for } i=1,\\dots,5 $$\n            $$ U_{n+1} = q_5 $$\n            将此应用于测试方程 $u'=\\lambda u$（因此 $f(u)=\\lambda u$），其中 $z = \\Delta t \\lambda$，可以递归地构建稳定性多项式 $R_{\\mathrm{LSRK54}}(z) = q_5/q_0$。\n\n4.  **计算最大稳定时间步长和 C**：对于每种格式，我们必须找到维持稳定性的最大 $\\Delta t$。这等价于找到最大的 $\\Delta t$，使得缩放谱 $\\Delta t \\Lambda(L)$ 保持在稳定区域 $\\{z \\in \\mathbb{C} : |R(z)| \\le 1\\}$ 内。\n    -   对 $\\Delta t$ 执行二分搜索。对于给定的 $\\Delta t$，通过对所有 $z \\in \\Delta t \\Lambda(L)$ 计算 $|R(z)|$ 并确保最大模不超过 1 来检查稳定性。\n    -   一旦找到最大稳定时间步长 $\\Delta t_{\\mathrm{max}}$，就使用问题中定义的缩放关系计算稳定性限制系数 $C$：\n        $$ C = \\Delta t_{\\mathrm{max}} \\cdot p^2 \\cdot h^{-1} = \\Delta t_{\\mathrm{max}} \\cdot p^2 \\cdot N $$\n\n实现将对指定的参数（$N=16$, $a=1$）和多项式次数（$p \\in \\{2,4,8\\}$）执行这些步骤，并报告每种情况下的系数 $C$。", "answer": "```python\nimport numpy as np\nimport scipy.special\n\ndef solve():\n    \"\"\"\n    Computes the stability-limited CFL coefficient C for a DG discretization of\n    the linear advection equation using RK4 and LSRK54 time-stepping schemes.\n    \"\"\"\n\n    def leg_gauss_lobatto(p):\n        \"\"\"\n        Computes the Legendre-Gauss-Lobatto nodes and weights on [-1, 1].\n\n        Args:\n            p (int): Polynomial degree.\n\n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: LGL nodes.\n                - np.ndarray: LGL weights.\n        \"\"\"\n        if p == 0:\n            return np.array([0.0]), np.array([2.0])\n        if p == 1:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n        \n        # Nodes are -1, 1, and the roots of P_p'(x).\n        # Roots of P_p'(x) are roots of the Jacobi polynomial P_{p-1}^{(1,1)}(x).\n        roots_jacobi, _ = scipy.special.roots_jacobi(p - 1, 1, 1)\n        nodes = np.concatenate(([-1.0], np.sort(roots_jacobi), [1.0]))\n        \n        # Weights are given by w_i = 2 / (p*(p+1) * [P_p(x_i)]^2).\n        P_p_at_nodes = scipy.special.eval_legendre(p, nodes)\n        weights = 2.0 / (p * (p + 1) * P_p_at_nodes**2)\n        \n        return nodes, weights\n\n    def diff_matrix(p, nodes):\n        \"\"\"\n        Computes the 1D nodal differentiation matrix on LGL nodes.\n\n        Args:\n            p (int): Polynomial degree.\n            nodes (np.ndarray): LGL nodes.\n\n        Returns:\n            np.ndarray: The (p+1)x(p+1) differentiation matrix.\n        \"\"\"\n        n_pts = p + 1\n        D = np.zeros((n_pts, n_pts))\n        P_p_at_nodes = scipy.special.eval_legendre(p, nodes)\n        \n        for i in range(n_pts):\n            for j in range(n_pts):\n                if i != j:\n                    D[i, j] = P_p_at_nodes[i] / (P_p_at_nodes[j] * (nodes[i] - nodes[j]))\n        \n        D[0, 0] = -p * (p + 1) / 4.0\n        D[p, p] = p * (p + 1) / 4.0\n        # For i=1..p-1, D[i,i] = 0, which is the default from np.zeros.\n        \n        return D\n\n    def build_L_matrix(p, N, a, D, weights):\n        \"\"\"\n        Builds the global strong-form DG operator matrix L.\n\n        Args:\n            p (int): Polynomial degree.\n            N (int): Number of elements.\n            a (float): Advection speed.\n            D (np.ndarray): Reference element differentiation matrix.\n            weights (np.ndarray): LGL quadrature weights.\n\n        Returns:\n            np.ndarray: The global DG operator matrix.\n        \"\"\"\n        n_pts = p + 1\n        total_dofs = N * n_pts\n        L = np.zeros((total_dofs, total_dofs), dtype=np.float64)\n        h = 1.0 / N\n        w0 = weights[0]\n        \n        flux_coeff = 2.0 * a / (h * w0)\n\n        for k in range(N):\n            start_idx = k * n_pts\n            end_idx = start_idx + n_pts\n            \n            # Volume term (block diagonal part)\n            L[start_idx:end_idx, start_idx:end_idx] = - (2.0 * a / h) * D\n            \n            # Surface flux correction term (upwind for a>0)\n            # This adds to the row for u_{k,0} from u_{k,0} and u_{k-1,p}.\n            row_idx = start_idx\n            \n            # Contribution from u_{k,0}\n            L[row_idx, row_idx] += flux_coeff\n            \n            # Contribution from u_{k-1, p} (periodic boundary)\n            prev_k = (k - 1 + N) % N\n            col_idx = prev_k * n_pts + p\n            L[row_idx, col_idx] -= flux_coeff\n            \n        return L\n\n    def get_stability_poly(scheme):\n        \"\"\"\n        Returns the stability polynomial for a given RK scheme.\n        \n        Args:\n            scheme (str): The scheme identifier (\"RK4\" or \"LSRK54\").\n\n        Returns:\n            np.poly1d: The stability polynomial.\n        \"\"\"\n        if scheme == \"RK4\":\n            # R(z) = 1 + z + z^2/2! + z^3/3! + z^4/4!\n            coeffs = [1/24.0, 1/6.0, 1/2.0, 1.0, 1.0]\n            return np.poly1d(coeffs)\n        elif scheme == \"LSRK54\":\n            # 2-register, 5-stage, 4th-order scheme (Carpenter-Kennedy)\n            # Recurrence: d_i = A_i*d_{i-1} + dt*f(q_{i-1}), q_i = q_{i-1} + B_i*d_i\n            B = np.array([0.118888066885314, 0.281111933114686, 0.5, 0.6, 1.0])\n            A = np.array([0.0, 0.0, -0.0911516952733231, -1.0911516952733231, -1.2])\n\n            z = np.poly1d([1, 0])\n            q_poly = np.poly1d([1.0])\n            d_poly = np.poly1d([0.0])\n\n            for i in range(5):\n                d_poly_new = A[i] * d_poly + q_poly\n                q_poly = q_poly + B[i] * z * d_poly_new\n                d_poly = d_poly_new\n            return q_poly\n        else:\n            raise ValueError(f\"Unknown scheme: {scheme}\")\n\n    def find_max_dt(eigs, stability_poly):\n        \"\"\"\n        Finds the maximum stable time step using bisection.\n\n        Args:\n            eigs (np.ndarray): Eigenvalues of the DG operator.\n            stability_poly (np.poly1d): The stability polynomial.\n\n        Returns:\n            float: The maximum stable time step.\n        \"\"\"\n        def is_stable(dt):\n            if dt  1e-12: return True\n            z = dt * eigs\n            R_z = stability_poly(z)\n            return np.max(np.abs(R_z)) = 1.000000001 # Numerical tolerance\n\n        max_eig_mag = np.max(np.abs(eigs))\n        if max_eig_mag  1e-9: return np.inf\n        \n        dt_low = 0.0\n        dt_high = 10.0 / max_eig_mag\n        \n        for _ in range(100):\n            dt_mid = (dt_low + dt_high) / 2.0\n            if is_stable(dt_mid):\n                dt_low = dt_mid\n            else:\n                dt_high = dt_mid\n        \n        return dt_low\n\n    # Problem parameters\n    N = 16\n    a = 1.0\n    p_values = [2, 4, 8]\n    schemes = [\"RK4\", \"LSRK54\"]\n    \n    results = []\n\n    for p in p_values:\n        nodes, weights = leg_gauss_lobatto(p)\n        D = diff_matrix(p, nodes)\n        L = build_L_matrix(p, N, a, D, weights)\n        \n        eigenvalues = np.linalg.eigvals(L)\n        \n        for scheme_name in schemes:\n            poly = get_stability_poly(scheme_name)\n            dt_max = find_max_dt(eigenvalues, poly)\n            h = 1.0 / N\n            C = dt_max * p**2 / h\n            results.append(f\"{C:.6f}\")\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3397159"}, {"introduction": "除了稳定性和精度，数值格式的守恒性是衡量其物理真实性的一个关键指标，尤其是在采用局部时间步长等高级加速技术时。这个高级练习揭示了一个在实现LSRK格式时容易被忽视的陷阱：朴素的实现方式在非均匀时间步长下会破坏离散质量守恒[@problem_id:3397152]。通过实现一个非守恒的“朴素”版本和一个经过精心设计的“修正”版本，你将学会如何通过内存感知的算法设计来确保数值解在任何情况下都严格保持守恒性。", "problem": "考虑一维标量平流方程 $u_t + a u_x = 0$，其速度 $a  0$ 为常数，定义在一个划分为 $N$ 个单元的周期性域上。使用分段常数基函数（多项式阶数 $p = 0$）的间断伽辽金（DG）方法。在此设置中，单元平均值 $u_e(t)$ 的半离散演化完全由界面通量驱动。设单元循环索引为 $e \\in \\{0,1,\\dots,N-1\\}$，界面 $i$ 位于单元 $e=i$ 和 $f=(i+1) \\bmod N$ 之间。对于 $a0$，采用迎风格式，界面 $i$ 处的数值通量为 $\\phi_i = a u_e$，每个单元 $e$ 的半离散残差为\n$$\nL_e(u) = \\phi_{e-1} - \\phi_e = a u_{e-1} - a u_e,\n$$\n其中索引算术采用模 $N$ 运算，并施加周期性边界条件。\n\n使用具有 $S$ 个阶段和系数 $\\{\\alpha_s\\}_{s=1}^S$ 与 $\\{\\beta_s\\}_{s=1}^S$ 的低存储龙格-库塔（LSRK）方法对解进行时间推进，该方法以双寄存器形式实现：\n$$\nr^{(s)} = \\alpha_s r^{(s-1)} + L\\!\\left(w^{(s-1)}\\right), \\quad\nw^{(s)} = w^{(s-1)} + \\beta_s \\, \\gamma_s \\, \\Delta t_e \\, r^{(s)} \\quad \\text{elementwise},\n$$\n其中 $w^{(0)} = u^n$ 是时间步开始时的初始场，$r^{(0)} = 0$ 是残差缓冲区，$\\Delta t_e$ 是单元 $e$ 上的局部时间步长，$\\gamma_s$ 是一个依赖于阶段的缩放因子。此实现重用单个残差缓冲区 $r$，并在更新时逐单元应用局部时间步长缩放。注意，$L(w)$ 通过界面通量依赖于 $w$。\n\n总离散质量定义为\n$$\nM(t) = \\sum_{e=0}^{N-1} u_e(t).\n$$\n在周期性边界条件和内部界面通量精确成对抵消的情况下，该半离散方法是守恒的，即 $dM/dt = 0$。然而，当 $\\Delta t_e$ 随 $e$ 变化且 $\\gamma_s$ 随 $s$ 变化时，上述 LSRK 更新会破坏离散守恒性，因为大小相等、方向相反的界面贡献在相邻单元上被不同的因子缩放。\n\n您的任务是：\n1. 实现所述的朴素 LSRK 更新，该更新重用单个残差缓冲区，并在每个阶段逐单元应用局部时间步长重缩放。\n2. 提出并实现一个考虑内存的修改方案，该方案在逐单元局部时间步长和逐阶段缩放的情况下，仍能保持跨界面的离散守恒性。该修改应使用一个额外的缓冲区来按界面累积界面贡献，并在每个界面应用一个公共的成对缩放，以使对两个相邻单元的贡献在每个阶段都大小相等、方向相反。具体来说，维护一个按界面更新的缓冲区 $s_i$：\n$$\ns_i^{(s)} = \\alpha_s s_i^{(s-1)} + \\phi_i\\!\\left(w^{(s-1)}\\right),\n$$\n并使用一个公共的成对缩放 $\\widehat{\\Delta t}_i$（例如，$\\widehat{\\Delta t}_i = \\min(\\Delta t_e,\\Delta t_f)$）来更新相邻单元 $e$ 和 $f$，以确保精确抵消：\n$$\nw_e^{(s)} \\gets w_e^{(s)} - \\beta_s \\, \\gamma_s \\, \\widehat{\\Delta t}_i \\, s_i^{(s)}, \\quad\nw_f^{(s)} \\gets w_f^{(s)} + \\beta_s \\, \\gamma_s \\, \\widehat{\\Delta t}_i \\, s_i^{(s)}.\n$$\n\n使用 Carpenter–Kennedy 低存储龙格-库塔（LSRK）五阶段四阶系数\n$$\n\\alpha = \\left[\n0,\\,\n-\\frac{567301805773}{1357537059087},\\,\n-\\frac{2404267990393}{2016746695238},\\,\n-\\frac{3550918686646}{2091501179385},\\,\n-\\frac{1275806237668}{842570457699}\n\\right],\n$$\n$$\n\\beta = \\left[\n\\frac{1432997174477}{9575080441755},\\,\n\\frac{5161836677717}{13612068292357},\\,\n\\frac{1720146321549}{2090206949498},\\,\n\\frac{3134564353537}{4481467310338},\\,\n\\frac{2277821191437}{14882151754819}\n\\right],\n$$\n和逐阶段缩放\n$$\n\\gamma = [1.0,\\, 0.9,\\, 1.1,\\, 0.95,\\, 1.05],\n$$\n编写一个程序，对于下面的每个测试用例，使用朴素方案和修改后方案各执行一个复合时间步（所有 $S$ 个阶段），然后计算每种方案的离散质量变化 $\\Delta M = M^{n+1} - M^n$。\n\n测试套件：\n- 案例 1（均匀局部时间步长）：$N=4$, $a=1.0$, $u^n = [1.0, 2.0, 3.0, 4.0]$, $\\Delta t = [0.1, 0.1, 0.1, 0.1]$。\n- 案例 2（非均匀局部时间步长）：$N=4$, $a=1.0$, $u^n = [1.0, 2.0, 3.0, 4.0]$, $\\Delta t = [0.10, 0.05, 0.20, 0.15]$。\n- 案例 3（单单元，周期性）：$N=1$, $a=1.0$, $u^n = [1.23]$, $\\Delta t = [0.1]$。\n- 案例 4（多单元，确定性可变性）：$N=20$，$a=1.0$，$u^n$ 由 $u_e^n = \\sin\\!\\left(2\\pi e/N\\right) + 0.5\\, e/N$ 给出（对于 $e=0,\\dots,19$），且 $\\Delta t_e = 0.05 + 0.01\\left( (e \\bmod 5) \\right)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一对，按顺序排列。每对是一个包含两个浮点数的列表 $[\\Delta M_{\\text{naive}}, \\Delta M_{\\text{modified}}]$。例如，输出应如下所示：\n$$\n[\\,[\\Delta M_{1,\\text{naive}},\\Delta M_{1,\\text{modified}}],\\,[\\Delta M_{2,\\text{naive}},\\Delta M_{2,\\text{modified}}],\\,[\\Delta M_{3,\\text{naive}},\\Delta M_{3,\\text{modified}}],\\,[\\Delta M_{4,\\text{naive}},\\Delta M_{4,\\text{modified}}]\\,].\n$$\n所有答案均为无量纲实数；无需物理单位。请确保单行输出与此规范完全匹配。", "solution": "该问题被评估为有效的，因为它代表了偏微分方程数值分析领域中一个适定的、有科学依据的问题。所有参数、方程和初始条件都得到了明确定义，从而能够得出一个唯一且可验证的解。\n\n问题的核心在于使用低存储龙格-库塔（LSRK）方法对半离散化的平流方程 $u_t + a u_x = 0$ 进行数值时间积分。空间离散化是通过在包含 $N$ 个单元的周期性域上使用分段常数基函数（$p=0$）的间断伽辽金（DG）方法来执行的。\n\n### 半离散格式\n对于 DG($p=0$) 格式，每个单元 $e$ 内的解由其平均值 $u_e$ 表示。控制这些平均值时间演化的平流方程的半离散形式由下式给出\n$$\n\\frac{du_e}{dt} = L_e(u)\n$$\n其中 $L_e(u)$ 是单元 $e$ 的残差。该残差汇集了跨单元边界通量的净效应。对于正的平流速度 $a0$，问题将界面 $i$（位于单元 $e=i$ 和 $f=(i+1) \\bmod N$ 之间）的迎风通量定义为 $\\phi_i = a u_i$。单元 $e$ 的残差则是从界面 $e-1$ 流入的通量与在界面 $e$ 流出的通量之差：\n$$\nL_e(u) = \\phi_{e-1} - \\phi_e = a u_{e-1} - a u_e\n$$\n此处，索引采用模 $N$ 运算以强制施加周期性边界条件。总离散质量定义为 $M(t) = \\sum_{e=0}^{N-1} u_e(t)$。该半离散系统是守恒的，因为所有残差之和是一个在周期性条件下抵消为零的伸缩和：\n$$\n\\frac{dM}{dt} = \\sum_{e=0}^{N-1} \\frac{du_e}{dt} = \\sum_{e=0}^{N-1} L_e(u) = \\sum_{e=0}^{N-1} (a u_{e-1} - a u_e) = a \\left( \\sum_{e=0}^{N-1} u_{e-1} - \\sum_{e=0}^{N-1} u_e \\right) = 0\n$$\n\n### 朴素 LSRK 实现（非守恒）\n指定的 LSRK 格式使用双寄存器形式将解从时间层 $n$ 推进到 $n+1$。这两个寄存器是解缓冲区 $w$ 和残差缓冲区 $r$。一个时间步的更新（包含 $S$ 个阶段）由下式给出：\n$$\nr^{(s)} = \\alpha_s r^{(s-1)} + L\\!\\left(w^{(s-1)}\\right) \\\\\nw^{(s)} = w^{(s-1)} + \\beta_s \\, \\gamma_s \\, \\Delta t_e \\, r^{(s)}\n$$\n初始条件为 $w^{(0)} = u^n$ 和 $r^{(0)} = 0$。关键部分是解 $w^{(s)}$ 的逐单元更新，其中单元 $e$ 的残差 $r^{(s)}$ 按其局部时间步长 $\\Delta t_e$ 进行缩放。\n\n当局部时间步长 $\\Delta t_e$ 不均匀时，此格式无法保持离散质量。在一个完整时间步长内，总质量变化为 $\\Delta M = \\sum_e (w^{(S)}_e - w^{(0)}_e) = \\sum_e \\sum_{s=1}^S \\beta_s \\gamma_s \\Delta t_e r_e^{(s)}$。在每个阶段，和 $\\sum_e r_e^{(s)}$ 为零，但加权和 $\\sum_e \\Delta t_e r_e^{(s)}$ 不为零，因为非均匀的 $\\Delta t_e$ 破坏了抵消。例如，对于阶段 $s=1$，$\\sum_e \\Delta t_e r_e^{(1)} = \\sum_e \\Delta t_e L_e(u^n) = a \\sum_e \\Delta t_e (u^n_{e-1} - u^n_e) \\neq 0$（如果 $\\Delta t_e$ 不为常数）。这在第一阶段引入了非零的质量变化，并会传播到其余阶段。\n\n### 修改后的 LSRK 实现（守恒）\n为了恢复守恒性，更新机制必须确保在每个阶段，来自任何给定界面的对其两个相邻单元的贡献都是大小相等、方向相反的。所提出的修改通过引入一个按界面的残差缓冲区 $s_i$ 来实现这一点。\n界面缓冲区的更新为：\n$$\ns_i^{(s)} = \\alpha_s s_i^{(s-1)} + \\phi_i\\!\\left(w^{(s-1)}\\right)\n$$\n其中 $\\phi_i(w^{(s-1)}) = a w_i^{(s-1)}$ 是界面 $i$ 处的通量。然后，单元 $e$ 的解更新由其相邻界面 $e-1$ 和 $e$ 的贡献构成。关键是在界面 $i$ 处对通量使用一个公共的、共享的时间步长缩放 $\\widehat{\\Delta t}_i$，定义为 $\\widehat{\\Delta t}_i = \\min(\\Delta t_i, \\Delta t_{(i+1)\\bmod N})$。\n\n单元 $e$ 在阶段 $s$ 的更新是来自界面 $e-1$ 的流入和流向界面 $e$ 的流出之和：\n$$\n\\Delta w_e^{(s)} = \\underbrace{+\\beta_s \\gamma_s \\widehat{\\Delta t}_{e-1} s_{e-1}^{(s)}}_{\\text{inflow from interface } e-1} \\quad \\underbrace{-\\beta_s \\gamma_s \\widehat{\\Delta t}_{e} s_{e}^{(s)}}_{\\text{outflow to interface } e}\n$$\n总更新为 $w_e^{(s)} = w_e^{(s-1)} + \\Delta w_e^{(s)}$。将这些更新在所有单元 $e$ 上求和，会得到一个计算结果为零的伸缩和：\n$$\n\\sum_{e=0}^{N-1} \\Delta w_e^{(s)} = \\sum_{e=0}^{N-1} \\beta_s \\gamma_s \\left( \\widehat{\\Delta t}_{e-1} s_{e-1}^{(s)} - \\widehat{\\Delta t}_e s_e^{(s)} \\right) = 0\n$$\n这保证了总离散质量在时间积分的每个阶段都是守恒的，无论 $\\Delta t_e$ 是否均匀或 $\\gamma_s$ 是否依赖于阶段。\n\n### 实现\n使用给定的 Carpenter-Kennedy 五阶段四阶 LSRK 系数 $\\{\\alpha_s\\}_{s=1}^5$、$\\{\\beta_s\\}_{s=1}^5$ 以及逐阶段缩放因子 $\\{\\gamma_s\\}_{s=1}^5$。对于每个测试用例，我们为朴素方案和修改后方案计算一个完整的时间步（所有5个阶段），并计算总离散质量的变化 $\\Delta M = M^{n+1} - M^n$。\n\n- **朴素方案算法**：对于每个阶段 $s=1,\\dots,5$：\n    1. 根据当前解 $w^{(s-1)}$ 计算单元残差向量 $L$。\n    2. 更新单元残差缓冲区：$r \\leftarrow \\alpha_s r + L$。\n    3. 更新解向量：$w \\leftarrow w + (\\beta_s \\gamma_s) \\cdot (\\Delta t \\odot r)$，其中 $\\odot$ 是逐元素乘积。\n- **修改后方案算法**：对于每个阶段 $s=1,\\dots,5$：\n    1. 根据当前解 $w^{(s-1)}$ 计算界面通量向量 $\\phi$。\n    2. 更新界面残差缓冲区：$s_{intf} \\leftarrow \\alpha_s s_{intf} + \\phi$。\n    3. 计算每个界面的更新项：$U_{intf} = (\\beta_s \\gamma_s) \\cdot (\\widehat{\\Delta t} \\odot s_{intf})$。\n    4. 通过通量差分更新解向量：$w \\leftarrow w + (\\text{roll}(U_{intf}, 1) - U_{intf})$。\n\n测试用例的结果将表明，对于均匀的 $\\Delta t$，两种方案都是守恒的（在机器精度范围内）。然而，对于非均匀的 $\\Delta t$，只有修改后的方案才能保持离散质量。", "answer": "```python\nimport numpy as np\n\ndef run_case(N, a, u_initial, dt_local):\n    \"\"\"\n    Runs a single test case for both the naive and modified LSRK schemes.\n\n    Args:\n        N (int): Number of elements.\n        a (float): Advection speed.\n        u_initial (np.ndarray): Initial solution vector.\n        dt_local (np.ndarray): Vector of local time steps for each element.\n\n    Returns:\n        list: A list containing two floats: [delta_mass_naive, delta_mass_modified].\n    \"\"\"\n\n    alpha_coeffs = np.array([\n        0.0,\n        -567301805773.0 / 1357537059087.0,\n        -2404267990393.0 / 2016746695238.0,\n        -3550918686646.0 / 2091501179385.0,\n        -1275806237668.0 / 842570457699.0\n    ])\n\n    beta_coeffs = np.array([\n        1432997174477.0 / 9575080441755.0,\n        5161836677717.0 / 13612068292357.0,\n        1720146321549.0 / 2090206949498.0,\n        3134564353537.0 / 4481467310338.0,\n        2277821191437.0 / 14882151754819.0\n    ])\n    \n    gamma_coeffs = np.array([1.0, 0.9, 1.1, 0.95, 1.05])\n    \n    num_stages = 5\n    m_initial = np.sum(u_initial)\n\n    # --- Naive Scheme Implementation ---\n    w_naive = np.copy(u_initial)\n    r_naive = np.zeros(N, dtype=float)\n\n    for s in range(num_stages):\n        # Calculate residual L(w) = a * (u_{e-1} - u_e)\n        L = a * (np.roll(w_naive, 1) - w_naive)\n        \n        # Update residual buffer r\n        r_naive = alpha_coeffs[s] * r_naive + L\n        \n        # Update solution w\n        w_naive += beta_coeffs[s] * gamma_coeffs[s] * dt_local * r_naive\n\n    m_final_naive = np.sum(w_naive)\n    delta_m_naive = m_final_naive - m_initial\n\n    # --- Modified Scheme Implementation ---\n    w_mod = np.copy(u_initial)\n    s_interface = np.zeros(N, dtype=float)\n    \n    # Pairwise time step scaling at interfaces\n    # Interface i is between element i and (i+1)%N\n    dt_hat = np.minimum(dt_local, np.roll(dt_local, -1))\n\n    for s in range(num_stages):\n        # Calculate flux vector phi_i = a * w_i\n        phi = a * w_mod\n        \n        # Update interface residual buffer s\n        s_interface = alpha_coeffs[s] * s_interface + phi\n        \n        # Calculate update term for each interface\n        update_term = beta_coeffs[s] * gamma_coeffs[s] * dt_hat * s_interface\n        \n        # Apply conservative updates to elements\n        # Element e gets inflow from interface e-1 and outflow to interface e\n        delta_w = np.roll(update_term, 1) - update_term\n        w_mod += delta_w\n\n    m_final_mod = np.sum(w_mod)\n    delta_m_mod = m_final_mod - m_initial\n\n    return [delta_m_naive, delta_m_mod]\n\n\ndef solve():\n    \"\"\"\n    Sets up test cases, runs simulations, and prints the formatted results.\n    \"\"\"\n    # Test Case 1\n    case1 = {\n        \"N\": 4, \"a\": 1.0, \n        \"u_initial\": np.array([1.0, 2.0, 3.0, 4.0]),\n        \"dt_local\": np.array([0.1, 0.1, 0.1, 0.1])\n    }\n\n    # Test Case 2\n    case2 = {\n        \"N\": 4, \"a\": 1.0,\n        \"u_initial\": np.array([1.0, 2.0, 3.0, 4.0]),\n        \"dt_local\": np.array([0.10, 0.05, 0.20, 0.15])\n    }\n\n    # Test Case 3\n    case3 = {\n        \"N\": 1, \"a\": 1.0,\n        \"u_initial\": np.array([1.23]),\n        \"dt_local\": np.array([0.1])\n    }\n\n    # Test Case 4\n    N4 = 20\n    e4 = np.arange(N4)\n    u_n4 = np.sin(2 * np.pi * e4 / N4) + 0.5 * e4 / N4\n    dt4 = 0.05 + 0.01 * (e4 % 5)\n    case4 = {\n        \"N\": N4, \"a\": 1.0,\n        \"u_initial\": u_n4,\n        \"dt_local\": dt4\n    }\n\n    test_cases = [case1, case2, case3, case4]\n    \n    results = []\n    for case in test_cases:\n        res = run_case(case[\"N\"], case[\"a\"], case[\"u_initial\"], case[\"dt_local\"])\n        results.append(res)\n    \n    # Format the final output string as specified\n    result_pairs = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(result_pairs)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3397152"}]}