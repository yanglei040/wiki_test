{"hands_on_practices": [{"introduction": "开发任何数值代码的第一步都是验证。对于无矩阵方法，一个基本的检验是确保算子的作用与传统的组装稀疏矩阵向量乘积产生完全相同的结果。本练习将指导您为线性平流方程实现一个无矩阵算子和一个基于矩阵的算子。通过比较两者在随机向量上的输出，您将对您实现的核心组件（如微分矩阵和数值通量）建立信心，并体会到两种方法在数学上的等价性。[@problem_id:3398909]", "problem": "考虑周期性域上具有恒定速度的一维线性平流方程。设物理域为区间 $[0,1]$，被划分为 $E$ 个等长度 $h = 1/E$ 的仿射单元。每个单元 $e$ 通过一个雅可比行列式为 $J_e = h/2$ 的仿射映射从参考区间 $[-1,1]$ 映射而来。在每个单元上，使用 Legendre–Gauss–Lobatto (LGL) 节点 $\\{\\xi_j\\}_{j=0}^N$ 上的节点表示，通过一个 $N$ 次多项式来近似解，这些节点具有相关的 LGL 求积权重 $\\{w_j\\}_{j=0}^N$。用 $\\{\\phi_j(\\xi)\\}_{j=0}^N$ 表示 Lagrange 插值基函数，使得 $\\phi_j(\\xi_k) = \\delta_{jk}$，并在参考区间上定义微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，通过恒等式 $d u/d \\xi \\big|_{\\xi = \\xi_j} = \\sum_{k=0}^N D_{jk} u(\\xi_k)$ 对任意次数至多为 $N$ 的多项式成立。\n\n对于一个恒定的平流速度 $a > 0$，在单元 $e$ 上使用迎风数值通量的半离散间断 Galerkin 弱形式表明，对于每个测试函数索引 $j \\in \\{0,\\dots,N\\}$，\n$$\n\\int_{x_{e-1/2}}^{x_{e+1/2}} \\phi_j(x) \\frac{\\partial u}{\\partial t}(x,t) \\, dx\n= -a \\int_{x_{e-1/2}}^{x_{e+1/2}} \\phi_j'(x) u(x,t) \\, dx\n+ a \\, \\phi_j(x_{e+1/2}) \\, \\hat{u}_{e+1/2} - a \\, \\phi_j(x_{e-1/2}) \\, \\hat{u}_{e-1/2},\n$$\n其中 $x_{e\\pm 1/2}$ 是物理单元边界，撇号表示关于 $x$ 的导数，$\\hat{u}_{e\\pm 1/2}$ 是 $u$ 在右/左单元界面处的迎风数值迹。在周期性网格上且对于 $a>0$，迎风数值迹在每个界面处取左侧状态，即 $\\hat{u}_{e+1/2} = u_{N}^e$ 和 $\\hat{u}_{e-1/2} = u_{N}^{e-1}$，其中 $u_j^e$ 表示单元 $e$ 上节点索引 $j$ 处的值，$e-1$ 是 $e$ 的左邻居（带周期性环绕）。\n\n使用以下经过充分检验的基本事实：\n- LGL 节点是端点 $\\xi_0 = -1$, $\\xi_N = 1$ 以及 $N$ 次 Legendre 多项式 $P_N(\\xi)$ 的导数在 $(-1,1)$ 内的 $N-1$ 个根。\n- LGL 求积权重满足 $w_j = \\dfrac{2}{N(N+1)} \\dfrac{1}{[P_N(\\xi_j)]^2}$，对于 $j = 0,\\dots,N$。\n- 在节点 LGL 基中，单元 $e$ 上的质量矩阵是对角矩阵，其对角项为 $M_{jj}^e = J_e w_j$，这是由于与 LGL 求积的配置所致。\n- 对于不同的节点 $\\xi_j \\neq \\xi_k$，Lagrange 基的微分矩阵项由重心微分恒等式给出 $D_{jk} = \\dfrac{\\omega_k}{\\omega_j}\\dfrac{1}{\\xi_j - \\xi_k}$，对角项为 $D_{jj} = -\\sum_{k\\ne j} D_{jk}$，其中 $\\omega_j$ 是重心权重 $\\omega_j = \\left(\\prod_{k\\ne j}(\\xi_j - \\xi_k)\\right)^{-1}$。\n\n任务：从这些基本定义和事实出发，设计并实现一个程序，用于在指定的 $(E,N,a)$ 条件下，比较无矩阵间断 Galerkin 算子的作用与全局组装的稀疏矩阵算子的作用。这两个算子都代表了从节点自由度到由弱形式导出的右端向量的相同半离散映射。你的比较应通过计算随机测试向量的差异范数来执行。\n\n你的程序必须：\n1. 为给定的多项式次数 $N$ 构建 LGL 节点和权重。\n2. 在 LGL 节点上使用重心权重构建微分矩阵 $D$。\n3. 定义一个无矩阵算子应用，它不组装全局矩阵，仅使用单元局部操作、质量矩阵对角线、微分矩阵和带周期性边界条件的迎风数值通量，来计算每个节点自由度上的半离散右端项。\n4. 组装全局稀疏矩阵，该矩阵代表在包含 $E$ 个单元的整个周期性网格上的相同半离散算子映射，其排序方式为连接每个单元的 $(N+1)$ 个节点。\n5. 对于预定数量的随机测试向量（使用固定种子以保证可复现性），对每个向量计算无矩阵结果与组装的稀疏矩阵向量乘积结果之间差异的相对 2-范数。对于每个测试用例，返回这些相对范数中的最大值。\n\n使用以下测试套件（每个元组列出 $(E,N,a,\\text{seed},R)$，其中 $R$ 是测试的随机向量数量）：\n- $(1,1,1.0,42,3)$：单个单元，最低阶情况，三个随机向量。\n- $(4,3,1.0,7,5)$：中等数量的单元和阶数，五个随机向量。\n- $(8,7,0.5,123,4)$：更高多项式阶数，四个随机向量。\n- $(10,2,0.0,9,2)$：零平流速度的边界情况，两个随机向量。\n- $(3,5,2.0,100,4)$：较少单元但速度更高，四个随机向量。\n\n由于未使用角度，角度单位不适用。由于输出纯属数学性质，无需报告物理单位。对于每个测试用例，计算一个浮点数，该数等于其 $R$ 个随机向量的差异的相对 2-范数中的最大值。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5]”），每个结果按上面列出的相同顺序对应于测试用例。", "solution": "该问题要求设计、实现和验证两种计算方法，以应用一维线性平流方程的间断 Galerkin (DG) 离散化的空间算子。这两种方法分别是无矩阵方法和基于组装的全局稀疏矩阵的方法。验证过程包括比较它们在随机向量上的输出，并计算最大相对差异。\n\n### 数学公式\n该问题考虑线性平流方程 $\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0$，定义在周期性域 $[0,1]$ 上，平流速度为 $a > 0$。该域被划分为 $E$ 个单元，在每个单元上，解由一个 $N$ 次多项式近似。对于测试函数 $\\phi_j$，单元 $e$ 上的半离散弱形式为：\n$$\n\\int_{x_e} \\phi_j \\frac{\\partial u}{\\partial t} \\, dx = -a \\int_{x_e} \\phi_j' u \\, dx + a \\, \\phi_j(x_{e+1/2}) \\, \\hat{u}_{e+1/2} - a \\, \\phi_j(x_{e-1/2}) \\, \\hat{u}_{e-1/2}\n$$\n左侧对应于质量矩阵作用于解系数的时间导数。任务是计算整个自由度 (DOF) 集合的右端 (RHS) 向量。设 $u^e = [u_0^e, \\dots, u_N^e]^T$ 是单元 $e$ 上的节点自由度向量。全局自由度向量 $U$ 是所有 $u^e$ 的串联。待实现的算子将 $U$ 映射到全局 RHS 向量 $F(U)$。让我们分析单个单元 $e$ 上对 RHS 的贡献。\n\n#### 体积积分项\n第一项是体积积分，我们记为 $F_{\\text{vol}, j}^e$:\n$$\nF_{\\text{vol}, j}^e = -a \\int_{x_e} \\phi_j'(x) u(x) \\, dx\n$$\n在单元 $e$ 上，解为 $u(x) = \\sum_{k=0}^N u_k^e \\phi_k(x)$。将其代入积分中得到：\n$$\nF_{\\text{vol}, j}^e = -a \\sum_{k=0}^N u_k^e \\int_{x_e} \\phi_j'(x) \\phi_k(x) \\, dx\n$$\n积分 $\\int_{x_e} \\phi_j'(x) \\phi_k(x) \\, dx$ 定义了单元刚度矩阵的项。使用雅可比行列式为 $J_e = h/2$（其中 $h=1/E$）的仿射映射 $x(\\xi)$ 变换到参考单元 $[-1,1]$：$\\phi_j'(x) = \\frac{d\\phi_j}{d\\xi}\\frac{d\\xi}{dx} = \\frac{1}{J_e}\\frac{d\\phi_j}{d\\xi}$ 且 $dx = J_e d\\xi$。积分变为：\n$$\nS^{\\text{ref}}_{jk} = \\int_{-1}^1 \\left(\\frac{1}{J_e}\\frac{d\\phi_j}{d\\xi}\\right) \\phi_k(\\xi) J_e d\\xi = \\int_{-1}^1 \\frac{d\\phi_j}{d\\xi}(\\xi) \\phi_k(\\xi) d\\xi\n$$\n这个参考刚度矩阵与单元无关。我们使用 $N+1$ 点 LGL 求积法则来近似这个积分，该法则对于次数最高为 $2N-1$ 的多项式是精确的。被积函数的多项式次数最高为 $2N-1$，因此求积通常不是精确的，但这是标准的 DG 方法。\n利用性质 $\\frac{d\\phi_j}{d\\xi}(\\xi) = \\sum_{l=0}^N \\frac{d\\phi_j}{d\\xi}(\\xi_l) \\phi_l(\\xi) = \\sum_{l=0}^N D_{lj} \\phi_l(\\xi)$:\n$$\nS^{\\text{ref}}_{jk} \\approx \\sum_{m=0}^N w_m \\left(\\sum_{l=0}^N D_{lj} \\phi_l(\\xi_m)\\right) \\phi_k(\\xi_m) = \\sum_{m=0}^N w_m \\left(\\sum_{l=0}^N D_{lj} \\delta_{lm}\\right) \\delta_{mk} = w_k D_{kj}\n$$\n在矩阵表示法中，$S^{\\text{ref}} = D^T \\text{diag}(w)$。单元 $e$ 上对 RHS 向量的体积贡献为 $F_{\\text{vol}}^e = -a S^{\\text{ref}} u^e$。\n\n#### 表面（通量）积分项\nRHS 的第二部分涉及单元边界 $x_{e \\pm 1/2}$ 处的数值通量：\n$$\nF_{\\text{flux}, j}^e = a \\, \\phi_j(x_{e+1/2}) \\, \\hat{u}_{e+1/2} - a \\, \\phi_j(x_{e-1/2}) \\, \\hat{u}_{e-1/2}\n$$\nLagrange 基函数 $\\phi_j$ 定义在 LGL 节点 $\\{\\xi_k\\}_{k=0}^N$ 上，其中 $\\xi_0=-1$ 和 $\\xi_N=1$。它们分别映射到单元边界 $x_{e-1/2}$ 和 $x_{e+1/2}$。由于性质 $\\phi_j(\\xi_k)=\\delta_{jk}$，我们有 $\\phi_j(x_{e-1/2})=\\delta_{j0}$ 和 $\\phi_j(x_{e+1/2})=\\delta_{jN}$。这意味着通量项仅在单元的第一个和最后一个节点（$j=0$ 和 $j=N$）处非零。\n对于 $a>0$，迎风通量在界面处取“左侧”状态的值。\n- 在右边界 $x_{e+1/2}$ 处：$\\hat{u}_{e+1/2} = u(x_{e+1/2}^-)$，这是当前单元 $e$ 上节点 $N$ 处的值，所以 $\\hat{u}_{e+1/2} = u_N^e$。\n- 在左边界 $x_{e-1/2}$ 处：$\\hat{u}_{e-1/2} = u(x_{e-1/2}^-)$，这是左邻单元 $e-1$ 上节点 $N$ 处的值。由于周期性，如果 $e=0$，$e-1$ 对应于单元 $E-1$。因此，$\\hat{u}_{e-1/2} = u_N^{e-1}$。\n通量贡献为：\n- 对于节点 $j=0$：$-a \\cdot 1 \\cdot \\hat{u}_{e-1/2} = -a u_N^{e-1}$。\n- 对于节点 $j=N$：$a \\cdot 1 \\cdot \\hat{u}_{e+1/2} = a u_N^e$。\n\n### 算法实现策略\n\n#### 基础组件\n实现从为给定的多项式次数 $N$ 构建必要的构建块开始：\n1.  **LGL 节点和权重**：节点 $\\{\\xi_j\\}$ 是 $\\{-1, 1\\}$ 与 Legendre 多项式 $P_N(\\xi)$ 的导数的根（等价于 Jacobi 多项式 $P_{N-1}^{(1,1)}(\\xi)$ 的根）的并集。权重 $\\{w_j\\}$ 通过提供的公式计算。\n2.  **微分矩阵**：参考微分矩阵 $D$ 使用给定的重心公式 $D_{jk} = \\frac{\\omega_k}{\\omega_j}\\frac{1}{\\xi_j - \\xi_k}$ 和 $D_{jj} = -\\sum_{k\\ne j} D_{jk}$ 构建。重心权重 $\\omega_j = (\\prod_{k\\ne j}(\\xi_j - \\xi_k))^{-1}$ 使用对数进行精细计算，以保持数值稳定性。\n\n#### 无矩阵算子\n此算子直接计算作用 $F(U)$ 而不形成全局矩阵。它遍历 $E$ 个单元中的每一个：\n1.  对于每个单元 $e$，从全局向量 $U$ 中提取局部 DOF 向量 $u^e$。\n2.  计算体积项：$F_{\\text{vol}}^e = -a (D^T \\text{diag}(w)) u^e$。\n3.  识别迎风邻居的 DOF，$u_N^{e-1}$。\n4.  添加通量贡献：从 $F_{\\text{vol}}^e$ 的第一个分量中减去 $a u_N^{e-1}$，并向最后一个分量中加上 $a u_N^e$。\n5.  结果向量是来自单元 $e$ 的 RHS 贡献，存储在全局 RHS 向量 $F(U)$ 的相应段中。\n\n#### 组装矩阵算子\n此方法显式构建全局 $E(N+1) \\times E(N+1)$ 稀疏矩阵 $L$，使得 $F(U) = L U$。\n1.  初始化一个稀疏矩阵（例如，使用 LIL 格式以实现高效构建）。\n2.  遍历每个单元 $e$：\n    a.  **体积部分**：局部算子 $-a S^{\\text{ref}} = -a D^T \\text{diag}(w)$ 是一个稠密的 $(N+1) \\times (N+1)$ 块。此块被添加到与单元 $e$ 对应的 $L$ 的对角块上。\n    b.  **通量部分**：通量项在相邻单元之间创建耦合。对于每个单元 $e$：\n        i.  项 $a u_N^e$ 增加到 $L$ 中对应于单元 $e$ 上节点 $N$ 的全局索引的行和列的元素上。\n        ii. 项 $-a u_N^{e-1}$ 增加到 $L$ 中对应于单元 $e$ 上节点 $0$ 的行和单元 $e-1$ 上节点 $N$ 的列的元素上。\n3.  将矩阵转换为适用于矩阵向量乘积的高效格式（例如 CSR）。\n\n#### 验证\n对于每个测试用例，生成 $R$ 个随机向量 $U_i$。使用两种方法计算算子作用，得到 $y_{\\text{free},i}$ 和 $y_{\\text{mat},i} = L U_i$。计算差异的相对 2-范数 $\\frac{\\|y_{\\text{free},i} - y_{\\text{mat},i}\\|_2}{\\|y_{\\text{mat},i}\\|_2}$。报告这 $R$ 个向量中这些范数的最大值。对于特殊情况 $a=0$，两种方法都产生零向量，因此差异为零，相对误差取为 $0$。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, eval_legendre\nfrom scipy.sparse import lil_matrix\n\ndef get_lgl_nodes_weights(N):\n    \"\"\"\n    Computes the Legendre-Gauss-Lobatto (LGL) nodes and weights for a given\n    polynomial degree N.\n    \"\"\"\n    if N == 0:\n        return np.array([-1.0]), np.array([2.0])\n    if N == 1:\n        nodes = np.array([-1.0, 1.0])\n        weights = np.array([1.0, 1.0])\n        return nodes, weights\n\n    # Interior nodes are roots of P_N'(x), which are roots of Jacobi P_{N-1}^{(1,1)}(x)\n    interior_nodes, _ = roots_jacobi(N - 1, 1, 1)\n    nodes = np.concatenate(([-1.0], interior_nodes, [1.0]))\n\n    # Weights from the formula w_j = 2 / (N(N+1) [P_N(xi_j)]^2)\n    poly_vals = eval_legendre(N, nodes)\n    weights = 2.0 / (N * (N + 1) * poly_vals**2)\n    \n    return nodes, weights\n\ndef get_derivative_matrix(N, nodes):\n    \"\"\"\n    Computes the nodal derivative matrix D on the reference element using\n    the provided barycentric weight formula.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.0]])\n    \n    D = np.zeros((N + 1, N + 1))\n    omega = np.zeros(N + 1)\n\n    # Compute barycentric weights omega_j = (product_{k!=j} (xi_j - xi_k))^{-1}\n    # This is done using logarithms to avoid numerical overflow/underflow.\n    for j in range(N + 1):\n        log_abs_prod = np.sum(np.log(np.abs(nodes[j] - np.delete(nodes, j))))\n        # The sign of the product is (-1)^(N-j) for ordered nodes.\n        # The sign of omega_j is the same.\n        sign = (-1.0)**(N - j)\n        omega[j] = sign / np.exp(log_abs_prod)\n\n    # Off-diagonal entries: D_jk = (omega_k/omega_j) / (xi_j - xi_k)\n    for j in range(N + 1):\n        for k in range(N + 1):\n            if j != k:\n                D[j, k] = (omega[k] / omega[j]) / (nodes[j] - nodes[k])\n\n    # Diagonal entries: D_jj = -sum_{k!=j} D_jk\n    for j in range(N + 1):\n        D[j, j] = -np.sum(D[j, :])\n        \n    return D\n\ndef matrix_free_operator(U, E, N, a, D, w):\n    \"\"\"\n    Computes the action of the DG operator in a matrix-free fashion.\n    \"\"\"\n    dofs = E * (N + 1)\n    rhs = np.zeros(dofs)\n    \n    if np.isclose(a, 0.0):\n        return rhs\n\n    U_mat = U.reshape((E, N + 1))\n    \n    # Reference stiffness matrix S_ref = D^T @ diag(w)\n    # This is efficiently computed by scaling columns of D^T by w.\n    S_ref = D.T * w\n\n    for e in range(E):\n        u_e = U_mat[e, :]\n        \n        # Volume term contribution\n        vol_term = -a * (S_ref @ u_e)\n        \n        # Flux term contribution (upwind for a > 0)\n        e_prev = (e - 1 + E) % E\n        u_left_neighbor_val = U_mat[e_prev, N]  # u_N from element e-1\n        u_self_right_val = u_e[N]               # u_N from element e\n        \n        flux_term_at_0 = -a * u_left_neighbor_val\n        flux_term_at_N = a * u_self_right_val\n        \n        # Combine local contributions\n        rhs_e = vol_term\n        rhs_e[0] += flux_term_at_0\n        rhs_e[N] += flux_term_at_N\n        \n        # Place into global RHS vector\n        rhs[e * (N + 1):(e + 1) * (N + 1)] = rhs_e\n        \n    return rhs\n\ndef assemble_global_matrix(E, N, a, D, w):\n    \"\"\"\n    Assembles the global sparse matrix for the DG operator.\n    \"\"\"\n    dofs = E * (N + 1)\n    L_global = lil_matrix((dofs, dofs))\n\n    if np.isclose(a, 0.0):\n        return L_global.tocsr()\n\n    S_ref = D.T * w\n    local_op_block = -a * S_ref\n\n    for e in range(E):\n        start_idx = e * (N + 1)\n        end_idx = (e + 1) * (N + 1)\n        \n        # Add volume term (block diagonal part)\n        L_global[start_idx:end_idx, start_idx:end_idx] = local_op_block\n        \n        # Add flux terms (off-diagonal and diagonal-modifying part)\n        e_prev = (e - 1 + E) % E\n        \n        # Contribution from left neighbor to node j=0\n        row_idx_0 = start_idx\n        col_idx_neighbor = e_prev * (N + 1) + N\n        L_global[row_idx_0, col_idx_neighbor] += -a\n        \n        # Contribution from self to node j=N\n        row_idx_N = start_idx + N\n        col_idx_self = start_idx + N\n        L_global[row_idx_N, col_idx_self] += a\n        \n    return L_global.tocsr()\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compare operator implementations.\n    \"\"\"\n    test_cases = [\n        (1, 1, 1.0, 42, 3),\n        (4, 3, 1.0, 7, 5),\n        (8, 7, 0.5, 123, 4),\n        (10, 2, 0.0, 9, 2),\n        (3, 5, 2.0, 100, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        E, N, a, seed, R = case\n        \n        rel_diffs = []\n        \n        # Pre-compute DG basis components for the given degree N\n        nodes, weights = get_lgl_nodes_weights(N)\n        D = get_derivative_matrix(N, nodes)\n        \n        # Assemble the global sparse matrix for this test case\n        L_global = assemble_global_matrix(E, N, a, D, weights)\n        \n        # Use a reproducible random number generator for this case\n        rng = np.random.default_rng(seed)\n        \n        for _ in range(R):\n            U_rand = rng.random(E * (N + 1))\n            \n            y_free = matrix_free_operator(U_rand, E, N, a, D, weights)\n            y_mat = L_global @ U_rand\n            \n            diff_norm = np.linalg.norm(y_free - y_mat)\n            y_mat_norm = np.linalg.norm(y_mat)\n            \n            if y_mat_norm > 1e-15:\n                rel_diff = diff_norm / y_mat_norm\n            else:\n                # If true result is zero vector, relative error is 0 if difference is also zero.\n                rel_diff = 0.0 if diff_norm < 1e-15 else np.inf\n\n            rel_diffs.append(rel_diff)\n\n        results.append(max(rel_diffs))\n        \n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```", "id": "3398909"}, {"introduction": "除了基本的正确性，鲁棒的数值格式还必须保持基本的物理原理。对于在移动或变形网格上的求解器，一个关键特性是“均匀流保持”——即能够精确维持一个恒定的流动状态。本实践在任意拉格朗日-欧拉（ALE）框架下探讨了这一特性，这要求离散地满足几何守恒律（GCL）。通过验证您的无矩阵算子能够正确平衡物理通量项和几何源项，您将理解如何为流固耦合或自适应网格等复杂应用构建可靠的格式。[@problem_id:3398913]", "problem": "考虑在任意拉格朗日-欧拉 (ALE) 框架下，一个具有网格运动的周期性域上的一维线性平流方程。物理守恒律由 $\\,\\partial_t u + a\\,\\partial_x u = 0\\,$ 给出，其中平流速度 $\\,a \\in \\mathbb{R}\\,$ 为常数。在一个从参考坐标 $\\,\\xi \\in [-1,1]\\,$ 到物理坐标 $\\,x(\\xi,t)\\,$ 的随时间变化的映射下，其雅可比为 $\\,J(\\xi,t) = \\partial x / \\partial \\xi\\,$，网格速度为 $\\,w(\\xi,t) = \\partial_t x(\\xi,t)\\,$，参考空间中的 ALE 形式为如下守恒型方程\n$$\n\\partial_t \\big(J(\\xi,t)\\,u(\\xi,t)\\big) + \\partial_\\xi \\big( F(u,w) \\big) = 0,\n$$\n其中 ALE 通量为 $\\,F(u,w) = u\\,(a - w)\\,$。自由流保持要求，如果离散化和几何处理是一致的，那么一个精确常数解 $\\,u(\\xi,t) \\equiv c\\,$ 在所有时间里都保持为常数。特别地，几何守恒律 (GCL) 指出\n$$\n\\partial_t J(\\xi,t) - \\partial_\\xi w(\\xi,t) = 0,\n$$\n为了保持自由流，该定律必须在离散意义下成立。\n\n你的任务是通过算子管线追踪一个精确常数解，以验证一种无矩阵高阶间断 Galerkin 谱元法 (DGSEM) 中的自由流保持特性。使用具有分部求和 (SBP) 性质的 Gauss-Lobatto-Legendre (GLL) 节点进行插值和求积，并在每个单元上使用强形式 DGSEM 离散化。不要组装任何全局矩阵；实现必须直接应用单元算子（在全局意义上是无矩阵的）。所有三角函数中的角度必须以弧度为单位。\n\n从守恒形式、参考映射和 GCL 的基本基础出发：\n- 守恒律：$\\,\\partial_t u + \\partial_x f(u) = 0\\,$，其中 $\\,f(u) = a u\\,$。\n- ALE 守恒形式：$\\,\\partial_t(J u) + \\partial_\\xi \\big( u (a - w) \\big) = 0\\,$。\n- 几何守恒律：$\\,\\partial_t J - \\partial_\\xi w = 0\\,$。\n- GLL 节点上的离散 SBP 性质和配置法。\n\n将参考域离散为 $\\,E \\in \\mathbb{N}\\,$ 个单元，每个单元都通过 $\\,s = e + (\\xi+1)/2\\,$（其中单元索引 $\\,e \\in \\{0,1,\\dots,E-1\\}\\,$）从 $\\,\\xi \\in [-1,1]\\,$ 等参映射到一个全局周期性参数坐标 $\\,s \\in [0,E]\\,$。通过全局映射 $\\,x(s,t) = s + \\gamma \\sin\\!\\big(2\\pi s / E\\big)\\,\\sin(\\Omega t)\\,$ 定义一个光滑的周期性网格运动，其中振幅为 $\\,\\gamma \\in \\mathbb{R}\\,$，频率为 $\\,\\Omega \\in \\mathbb{R}\\,$。网格速度为 $\\,w(s,t) = \\partial_t x(s,t) = \\gamma\\,\\Omega \\cos(\\Omega t)\\,\\sin\\!\\big(2\\pi s / E\\big)\\,$。关于 $\\,\\xi\\,$ 的雅可比为 $\\,J(\\xi,t) = \\big(\\partial x / \\partial s\\big) \\big(\\partial s / \\partial \\xi\\big) = \\frac{1}{2}\\Big(1 + \\frac{2\\pi \\gamma}{E}\\cos\\!\\big(2\\pi s / E\\big)\\,\\sin(\\Omega t)\\Big)\\,$；通过为每个测试用例选择足够小的 $\\,\\gamma\\,$ 来确保 $\\,J(\\xi,t) > 0\\,$。\n\n实现以下内容：\n- 每个单元使用 $\\,N+1\\,$ 个 GLL 节点，多项式阶数为 $\\,N \\in \\mathbb{N}\\,$。设 GLL 节点为 $\\,\\{\\xi_j\\}_{j=0}^N\\,$，求积权重为 $\\,\\{w_j\\}_{j=0}^N\\,$，微分矩阵为 $\\,D \\in \\mathbb{R}^{(N+1)\\times(N+1)}\\,$，该矩阵满足 GLL 求积的 SBP 性质。\n- 在每个单元上，为任意节点通量向量 $\\,\\boldsymbol{F} \\in \\mathbb{R}^{N+1}\\,$ 定义强形式 DGSEM 算子\n$$\n\\mathcal{L}(\\boldsymbol{F})_j = -\\sum_{k=0}^{N} D_{jk}\\,F_k \\;+\\; \\frac{1}{w_j}\\,\\Big( \\delta_{j,N}\\,\\big(F^\\ast_{R} - F_{N}^- \\big)\\;-\\;\\delta_{j,0}\\,\\big(F^\\ast_{L} - F_{0}^- \\big) \\Big),\n$$\n其中 $\\,F^\\ast_{L}\\,$ 和 $\\,F^\\ast_{R}\\,$ 分别是左、右面上的数值通量，而 $\\,F_0^-\\,$ 和 $\\,F_N^-\\,$ 分别是左、右节点处的内部面值。对于此验证，对任意界面量 $\\,q\\,$ 使用一致的中心数值通量 $\\,q^\\ast = \\tfrac{1}{2}(q^- + q^+)\\,$，并在相邻单元之间进行周期性耦合。对于 ALE 通量，使用 $\\,F = u\\,(a - w)\\,$；对于 GCL 通量，使用 $\\,G = -w\\,$，使得 $\\,\\partial_t J = \\mathcal{L}(\\boldsymbol{G})\\,$。\n- 对于一个常数状态 $\\,u \\equiv c\\,$，计算离散自由流残差向量\n$$\n\\boldsymbol{R} = c\\,\\partial_t \\boldsymbol{J} \\;-\\; \\mathcal{L}\\big(\\boldsymbol{F}(c,a,w)\\big),\n$$\n其中 $\\,\\partial_t \\boldsymbol{J}\\,$ 通过将相同的 DGSEM 算子应用于 $\\,\\boldsymbol{G} = -\\boldsymbol{w}\\,$ 来近似，而 $\\,\\boldsymbol{F}(c,a,w)\\,$ 使用 $\\,w\\,$ 的节点值。如果 $\\,\\|\\boldsymbol{R}\\|_\\infty\\,$ 小到舍入误差级别，则自由流被离散地保持。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n- 为给定的 $\\,N\\,$ 构建 GLL 节点、权重和微分矩阵。\n- 在每个单元上实现带有周期性耦合的无矩阵 DGSEM 强形式算子。\n- 在所有节点和单元面上计算全局网格速度 $\\,w(s,t)\\,$，角度以弧度为单位。\n- 对于下面测试套件中列出的每个参数集，计算在所有单元和节点上 $\\,\\boldsymbol{R}\\,$ 的最大绝对值。\n\n测试套件与答案规格：\n- 在所有测试用例中使用频率 $\\,\\Omega = 1\\,$。\n- 参数元组为 $\\,\\big(E,N,a,\\gamma,t,c\\big)\\,$。使用以下五个用例：\n    - 用例 $\\,1$: $\\,E=3\\,$, $\\,N=5\\,$, $\\,a=1.0\\,$, $\\,γ=0.15\\,$, $\\,t=0.37\\,$, $\\,c=2.0\\,$。\n    - 用例 $\\,2$: $\\,E=4\\,$, $\\,N=10\\,$, $\\,a=0.7\\,$, $\\,γ=0.05\\,$, $\\,t=2.1\\,$, $\\,c=-1.0\\,$。\n    - 用例 $\\,3$: $\\,E=2\\,$, $\\,N=7\\,$, $\\,a=-0.5\\,$, $\\,γ=0.0\\,$, $\\,t=1.23\\,$, $\\,c=1.0\\,$。\n    - 用例 $\\,4$: $\\,E=5\\,$, $\\,N=3\\,$, $\\,a=0.0\\,$, $\\,γ=0.1\\,$, $\\,t=1.7\\,$, $\\,c=3.3\\,$。\n    - 用例 $\\,5$: $\\,E=1\\,$, $\\,N=1\\,$, $\\,a=1.0\\,$, $\\,γ=0.02\\,$, $\\,t=3.14\\,$, $\\,c=1.0\\,$。\n- 对于每个用例，计算标量 $\\,r = \\|\\boldsymbol{R}\\|_\\infty\\,$，结果为浮点数。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4,r_5]$）。\n\n通过保持 $\\,\\gamma\\,$ 足够小以确保在所有情况下 $\\,J(\\xi,t) > 0\\,$，来保证科学真实性。输出中不需要物理单位。所有三角函数角度必须以弧度为单位。输出必须是确定性的，不依赖任何用户输入。", "solution": "该问题要求在一个任意拉格朗日-欧拉 (ALE) 框架下，对使用无矩阵高阶间断 Galerkin 谱元法 (DGSEM) 离散化的一维线性平流方程进行自由流保持特性的验证。自由流保持是数值格式的一项基本性质，它确保即使在运动或变形的网格上，常数初始状态也能随时间保持不变。未能保持自由流会引入虚假的源或汇，从而违反均匀流动的基本物理原理。\n\n验证是通过为常数解 $u(\\xi,t) = c$ 计算离散残差来执行的。如果格式是一致的，该残差应在浮点精度范围内为零。此性质的核心在于由物理守恒律和几何守恒律 (GCL) 产生的项之间的精确离散抵消。\n\n我们从平流的物理守恒律 $\\partial_t u + a\\,\\partial_x u = 0$ 开始。在随时间变化的映射 $x(\\xi,t)$ 下，将其转换到参考坐标系 $\\xi$ 中，得到守恒的 ALE 形式：\n$$\n\\partial_t \\big(J u\\big) + \\partial_\\xi \\big( u (a - w) \\big) = 0\n$$\n其中 $J = \\partial x / \\partial \\xi$ 是雅可比，$w = \\partial_t x$ 是网格速度。使用乘法法则可以将此方程展开：\n$$\nu\\,\\partial_t J + J\\,\\partial_t u + \\partial_\\xi \\big( u (a - w) \\big) = 0\n$$\n对于常数解 $u \\equiv c$，项 $J\\,\\partial_t u$ 消失。方程简化为：\n$$\nc\\,\\partial_t J + \\partial_\\xi \\big( c (a - w) \\big) = 0\n$$\n自由流保持取决于几何守恒律 (GCL)，该定律源于偏导数的交换性，即 $\\partial_t (\\partial_\\xi x) = \\partial_\\xi (\\partial_t x)$，从而导致：\n$$\n\\partial_t J - \\partial_\\xi w = 0 \\quad \\text{或} \\quad \\partial_t J = \\partial_\\xi w\n$$\n将 $\\partial_t J = \\partial_\\xi w$ 代入常数状态下的简化 ALE 方程，得到：\n$$\nc\\,(\\partial_\\xi w) + \\partial_\\xi \\big( c (a - w) \\big) = c\\,\\partial_\\xi w + c\\,\\partial_\\xi a - c\\,\\partial_\\xi w = 0\n$$\n这表明连续方程是一致的。问题的关键是验证所选的 DGSEM 离散化方法是否保持了这种抵消。\n\nDGSEM 离散化在 $E$ 个单元上执行，每个单元都从参考域 $\\xi \\in [-1,1]$ 映射而来。在每个单元内部，解和几何形状由 $N+1$ 个 Gauss-Lobatto-Legendre (GLL) 节点上的 $N$ 阶多项式表示。空间导数算子由强形式 DGSEM 算子 $\\mathcal{L}$ 近似，该算子将内部导数（使用分部求和导数矩阵 $\\boldsymbol{D}$）与单元界面上的数值通量相结合。对于节点通量向量 $\\boldsymbol{F}$，该算子为：\n$$\n\\mathcal{L}(\\boldsymbol{F})_j = -\\sum_{k=0}^{N} D_{jk}\\,F_k \\;+\\; \\frac{1}{w_j}\\,\\Big( \\delta_{j,N}\\,\\big(F^\\ast_{R} - F_{N}^- \\big)\\;-\\;\\delta_{j,0}\\,\\big(F^\\ast_{L} - F_{0}^- \\big) \\Big)\n$$\n该算子近似于 $-\\partial_\\xi \\boldsymbol{F}$。基于 GLL 的导数矩阵 $\\boldsymbol{D}$ 的一个关键性质是它能零化常数向量，即 $\\boldsymbol{D}\\boldsymbol{1} = \\boldsymbol{0}$。此外，对于全局常数通量，数值通量 $F^\\ast$ 等于内部通量 $F^-$，导致边界项消失。因此，$\\mathcal{L}(\\text{constant}) = \\boldsymbol{0}$。\n\n问题定义了一致的离散 GCL。连续 GCL $\\partial_t J = \\partial_\\xi w$ 被离散为：\n$$\n\\partial_t \\boldsymbol{J} = \\mathcal{L}(\\boldsymbol{G}) \\quad \\text{其中 GCL 通量为 } \\boldsymbol{G} = -\\boldsymbol{w}\n$$\n这是一致的，因为 $\\mathcal{L}(\\boldsymbol{G}) = \\mathcal{L}(-\\boldsymbol{w})$ 近似于 $-\\partial_\\xi(-\\boldsymbol{w}) = \\partial_\\xi \\boldsymbol{w}$。\n\n离散自由流残差向量 $\\boldsymbol{R}$ 被定义为 $c\\,\\partial_t J + \\partial_\\xi (c(a-w)) = 0$ 的离散版本。由于 $\\mathcal{L}$ 近似于 $-\\partial_\\xi$，相应的离散表达式为：\n$$\n\\boldsymbol{R} = c\\,\\partial_t \\boldsymbol{J} - \\mathcal{L}\\big(\\boldsymbol{F}(c,a,w)\\big)\n$$\n其中 $\\boldsymbol{F}(c,a,w)$ 是 ALE 通量 $u(a-w)$ 在 $u=c$ 时的节点向量。现在，我们将离散 GCL 和 ALE 通量代入残差表达式：\n$$\n\\boldsymbol{R} = c\\,\\mathcal{L}(-\\boldsymbol{w}) - \\mathcal{L}\\big(c(a - \\boldsymbol{w})\\big)\n$$\n算子 $\\mathcal{L}$ 在其通量参数上是线性的。因此：\n$$\n\\mathcal{L}\\big(c(a - \\boldsymbol{w})\\big) = \\mathcal{L}(ca - c\\boldsymbol{w}) = \\mathcal{L}(ca) - \\mathcal{L}(c\\boldsymbol{w})\n$$\n由于 $ca$ 是一个常数，$\\mathcal{L}(ca) = \\boldsymbol{0}$。因此，$\\mathcal{L}\\big(c(a - \\boldsymbol{w})\\big) = -\\mathcal{L}(c\\boldsymbol{w})$。残差变为：\n$$\n\\boldsymbol{R} = c\\,\\mathcal{L}(-\\boldsymbol{w}) - \\big( -\\mathcal{L}(c\\boldsymbol{w}) \\big) = -c\\,\\mathcal{L}(\\boldsymbol{w}) + c\\,\\mathcal{L}(\\boldsymbol{w}) = \\boldsymbol{0}\n$$\n对于离散算子，代数抵消是精确成立的。因此，数值实现应产生一个在机器浮点精度量级上的残差范数 $\\|\\boldsymbol{R}\\|_\\infty$。\n\n实现计划如下：\n1.  对于给定的多项式阶数 $N$，生成 $N+1$ 个 GLL 节点 $\\xi_j$、求积权重 $w_j$ 和 $(N+1) \\times (N+1)$ 的 SBP 微分矩阵 $\\boldsymbol{D}$。节点是勒让德多项式 $P_N(x)$ 在 $[-1,1]$ 上的极值点，权重和微分矩阵由标准公式计算得出。\n2.  对于每个测试用例，定义由 $E$ 个单元组成的网格。为每个单元 $e$ 上的每个节点 $j$ 计算全局参数坐标 $s_{ej} = e + (\\xi_j+1)/2$。\n3.  使用给定的公式 $w(s,t) = \\gamma\\,\\Omega \\cos(\\Omega t)\\,\\sin(2\\pi s / E)$，在所有单元上计算节点网格速度向量 $\\boldsymbol{w}$。\n4.  实现无矩阵算子 $\\mathcal{L}$。该函数接受一个全局通量向量（一个 $E \\times (N+1)$ 数组）并返回算子应用的结果。它通过在每个单元上进行矩阵-向量乘积来计算体积项，并使用中心通量和周期性边界条件添加面积修正项。\n5.  计算雅可比的离散时间导数，$\\partial_t \\boldsymbol{J} = \\mathcal{L}(-\\boldsymbol{w})$。\n6.  计算 ALE 通量的离散散度，$\\mathcal{L}(\\boldsymbol{F}) = \\mathcal{L}(c(a - \\boldsymbol{w}))$。\n7.  将这些结果组合起来，形成残差向量 $\\boldsymbol{R} = c\\,\\partial_t \\boldsymbol{J} - \\mathcal{L}(\\boldsymbol{F})$。\n8.  最后，为每个测试用例计算全局残差向量的无穷范数 $\\|\\boldsymbol{R}\\|_\\infty$。", "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre, roots_jacobi\n\ndef get_gll_data(N):\n    \"\"\"\n    Computes Gauss-Lobatto-Legendre (GLL) nodes, weights, and derivative matrix.\n\n    Args:\n        N (int): Polynomial degree.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, np.ndarray]:\n            - xi: GLL nodes of size (N+1).\n            - w: GLL quadrature weights of size (N+1).\n            - D: GLL derivative matrix of size (N+1, N+1).\n    \"\"\"\n    if not isinstance(N, int) or N < 1:\n        raise ValueError(\"Polynomial degree N must be an integer >= 1.\")\n\n    if N == 1:\n        xi = np.array([-1.0, 1.0])\n        w = np.array([1.0, 1.0])\n        D = np.array([[-0.5, 0.5], [-0.5, 0.5]])\n        return xi, w, D\n\n    # GLL nodes are roots of (1-x^2) * P_N'(x).\n    # The inner nodes are roots of P_N'(x), which are roots of the\n    # Jacobi polynomial P_{N-1}^{(1,1)}(x).\n    inner_nodes, _ = roots_jacobi(N - 1, 1, 1)\n    xi = np.concatenate(([-1.0], inner_nodes, [1.0]))\n\n    # Quadrature weights: w_j = 2 / (N(N+1) * P_N(xi_j)^2)\n    p_N_at_xi = eval_legendre(N, xi)\n    w = 2.0 / (N * (N + 1) * p_N_at_xi**2)\n\n    # Derivative matrix D\n    D = np.zeros((N + 1, N + 1))\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = (p_N_at_xi[i] / p_N_at_xi[j]) / (xi[i] - xi[j])\n            elif i == 0:\n                D[i, i] = -N * (N + 1) / 4.0\n            elif i == N:\n                D[i, i] = N * (N + 1) / 4.0\n            else:  # diagonal, 0 < i < N\n                D[i, i] = 0.0\n    return xi, w, D\n\ndef apply_L_operator(flux_global, E, N, D, w_gll):\n    \"\"\"\n    Applies the strong-form DGSEM operator L to a global flux vector.\n\n    Args:\n        flux_global (np.ndarray): Nodal flux values, shape (E, N+1).\n        E (int): Number of elements.\n        N (int): Polynomial degree.\n        D (np.ndarray): Derivative matrix, shape (N+1, N+1).\n        w_gll (np.ndarray): GLL weights, shape (N+1).\n\n    Returns:\n        np.ndarray: Result of operator application, shape (E, N+1).\n    \"\"\"\n    result_global = np.zeros_like(flux_global)\n\n    # Volume integral term: -D * F_e for each element e\n    # This is equivalent to `result_global = -flux_global @ D.T`\n    result_global = -np.einsum('ij,kj->ki', D, flux_global)\n\n    # Surface integral term (boundary corrections)\n    if N > 0:\n        inv_w0 = 1.0 / w_gll[0]\n        inv_wN = 1.0 / w_gll[N]\n\n        for e in range(E):\n            # Left face (at node 0)\n            e_left = (e - 1 + E) % E\n            F_minus_L = flux_global[e, 0]\n            F_plus_L = flux_global[e_left, N]  # from right face of left neighbor\n            F_star_L = 0.5 * (F_minus_L + F_plus_L)\n            result_global[e, 0] += -inv_w0 * (F_star_L - F_minus_L)\n\n            # Right face (at node N)\n            e_right = (e + 1) % E\n            F_minus_R = flux_global[e, N]\n            F_plus_R = flux_global[e_right, 0] # from left face of right neighbor\n            F_star_R = 0.5 * (F_minus_R + F_plus_R)\n            result_global[e, N] += inv_wN * (F_star_R - F_minus_R)\n\n    return result_global\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute free-stream residuals.\n    \"\"\"\n    # Test cases: (E, N, a, gamma, t, c)\n    test_cases = [\n        (3, 5, 1.0, 0.15, 0.37, 2.0),\n        (4, 10, 0.7, 0.05, 2.1, -1.0),\n        (2, 7, -0.5, 0.0, 1.23, 1.0),\n        (5, 3, 0.0, 0.1, 1.7, 3.3),\n        (1, 1, 1.0, 0.02, 3.14, 1.0),\n    ]\n\n    results = []\n    Omega = 1.0\n\n    for case in test_cases:\n        E, N, a, gamma, t, c = case\n\n        # 1. Get GLL data (nodes, weights, derivative matrix)\n        xi_nodes, w_gll, D = get_gll_data(N)\n\n        # 2. Set up geometry and compute mesh velocity\n        s_global = np.zeros((E, N + 1))\n        for e in range(E):\n            s_global[e, :] = e + (xi_nodes + 1.0) / 2.0\n        \n        # Check Jacobian positivity\n        # J_min = 0.5 * (1 - 2*pi*|gamma|/E). Must be > 0.\n        # This is equivalent to |gamma|  E / (2*pi).\n        if np.abs(gamma) * 2.0 * np.pi >= E:\n            # This check is for robustness; problem statement confirms validity.\n            raise ValueError(f\"Jacobian may not be positive for case {case}\")\n\n        w_mesh_global = gamma * Omega * np.cos(Omega * t) * np.sin(2.0 * np.pi * s_global / E)\n\n        # 3. Compute discrete GCL term: dt_J = L(-w)\n        G_global = -w_mesh_global\n        dt_J_global = apply_L_operator(G_global, E, N, D, w_gll)\n\n        # 4. Compute discrete ALE flux term: L(F) = L(c*(a-w))\n        F_global = c * (a - w_mesh_global)\n        L_F_global = apply_L_operator(F_global, E, N, D, w_gll)\n        \n        # 5. Compute the residual vector: R = c*dt_J - L(F)\n        # As derived, this should be close to zero.\n        R_global = c * dt_J_global - L_F_global\n        \n        # 6. Compute the infinity norm of the residual\n        r = np.max(np.abs(R_global))\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.16e}' for res in results)}]\")\n\nsolve()\n```", "id": "3398913"}]}