{"hands_on_practices": [{"introduction": "在理论学习了数值通量的基本性质后，我们通过一个思想实验来开启动手实践。这个练习 [@problem_id:3405177] 将引导我们思考数值通量设计中的一个核心权衡：色散与耗散。我们将对比中心通量和Lax-Friedrichs通量，分析它们在处理不同尺度波时的行为，从而理解为什么耗散（虽然会损失能量）在抑制非物理振荡方面至关重要。", "problem": "考虑一维线性平流方程 $u_t + a\\,u_x = 0$，其中速度 $a \\in \\mathbb{R}$ 为常数，定义在一个周期性域上。该域被划分为大小为 $h$ 的均匀单元网格。采用多项式次数为 $p$ 且节点为 Legendre-Gauss-Lobatto 节点的节点间断 Galerkin (DG) 方法（Discontinuous Galerkin (DG)）来构建半离散空间算子。在单元交界面处，考虑两种数值通量：中心通量和 Lax-Friedrichs 通量（Lax-Friedrichs (LF)）。中心通量的定义为 $f^* = \\tfrac{1}{2}\\big(a\\,u^- + a\\,u^+\\big)$，而 Lax-Friedrichs 通量的定义为 $f^* = \\tfrac{1}{2}\\big(a\\,u^- + a\\,u^+\\big) - \\tfrac{\\alpha}{2}\\big(u^+ - u^-\\big)$，其中惩罚参数 $\\alpha \\ge |a|$。假设对半离散算子进行时间精确分析（即，排除时间积分误差），并为傅里叶模 $u(x,t) = \\hat{u}(t)e^{\\mathrm{i}k x}$ 定义无量纲波数 $\\theta = k h$ 和阶数缩放波数 $\\kappa = \\theta/(p+1)$。\n\n仅使用 DG 空间离散化的基本性质，包括界面通量、周期性和傅里叶模分析，推断两种通量在不同波数下的色散和耗散特性。具体而言：\n\n- 对于中心通量，确定半离散算子是耗散的还是能量守恒的，并解释这如何影响作为 $\\kappa$ 函数的色散-耗散曲线。\n- 对于 Lax-Friedrichs 通量（$\\alpha = |a|$），确定界面惩罚项如何改变能量平衡，并论证耗散如何依赖于 $\\kappa$，特别是当 $\\kappa$ 增大并接近单元尺度分辨率极限时。\n- 基于这些性质，当目标是保持良好解析波的振幅和相位，同时抑制虚假的欠解析内容时，确定每种通量对于波传播更优的 $\\kappa$ 范围。\n\n哪个陈述最能准确地描述在不同波数范围内的正确比较和优选？\n\nA. 对于 $\\kappa \\ll 1$ 的良好解析模，中心通量因其半离散耗散为零且相位误差较小而更优；对于 $\\kappa = \\mathcal{O}(1)$ 且接近单元奈奎斯特频率（即 $\\kappa \\to \\pi$）的欠解析模，Lax-Friedrichs 通量更优，因为其耗散随波数增加而增强，能抑制虚假的高频内容。\n\nB. Lax-Friedrichs 通量在所有波数上都一致更优，因为其附加的耗散对于任何 $\\kappa$ 值都能减少色散误差并比中心通量更好地保持振幅。\n\nC. 中心通量对于高波数 $\\kappa \\approx \\pi$ 更优，因为其非耗散特性保留了奈奎斯特频率附近的振荡，而 Lax-Friedrichs 通量在该范围内过度阻尼了已解析的内容。\n\nD. 当 $\\alpha = |a|$ 时，中心通量和 Lax-Friedrichs 通量对所有波数都是等效的，因此在节点 DG 格式中没有依赖于波数的优选。\n\n提供唯一的最佳选项，并使用半离散 DG 框架、界面通量定义以及色散和耗散的傅里叶模分析，从第一性原理出发进行论证。陈述您需要的任何额外假设，并使其在科学上具有现实性且与情景一致。清晰地解释推理过程，不要依赖于快捷公式或预先给定的目标结果。", "solution": "该问题陈述被评估为有效。它提出了一个偏微分方程数值分析中的标准、适定的问题，使用了来自间断 Galerkin 方法领域的明确定义的术语和概念。所有参数和方法都是标准的，问题要求基于基本原理进行概念性比较。\n\n求解过程通过分析两种指定数值通量下，半离散 DG 算子的能量守恒性质来进行。设 $u_h$ 为近似解，它在每个单元 $K_j = [x_{j-1/2}, x_{j+1/2}]$ 内是一个次数为 $p$ 的多项式。平流方程 $u_t + a u_x = 0$ 的半离散弱形式通过乘以一个测试函数 $v_h$ 并在单元 $K_j$ 上积分得到：\n$$ \\int_{K_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx - \\int_{K_j} a u_h \\frac{\\partial v_h}{\\partial x} \\,dx + \\left[ a u_h v_h \\right]_{x_{j-1/2}}^{x_{j+1/2}} = 0 $$\n边界求值项 $[ \\cdot ]$ 被一个基于每个界面左侧 ($^-$) 和右侧 ($^+$) 值的数值通量项所取代。\n$$ \\int_{K_j} \\frac{\\partial u_h}{\\partial t} v_h \\,dx - \\int_{K_j} a u_h \\frac{\\partial v_h}{\\partial x} \\,dx + f^*(u_h(x_{j+1/2}^-), u_h(x_{j+1/2}^+)) v_h(x_{j+1/2}^-) - f^*(u_h(x_{j-1/2}^-), u_h(x_{j-1/2}^+)) v_h(x_{j-1/2}^-) = 0 $$\n为了分析格式的耗散性，我们设测试函数 $v_h = u_h$ 并对所有单元 $j$ 求和。这将得到一个描述总半离散能量（即 $L^2$ 范数的平方，$\\|u_h\\|^2 = \\sum_j \\int_{K_j} u_h^2 \\,dx$）随时间演化的方程。能量变化率由每个界面的贡献之和给出。对于一个具有左状态 $u_L$ 和右状态 $u_R$ 的通用界面，其对 $\\frac{1}{2} \\frac{d}{dt} \\|u_h\\|^2$ 的贡献为：\n$$ \\mathcal{J} = \\frac{a}{2}(u_L^2 - u_R^2) - (u_L - u_R)f^*(u_L, u_R) $$\n对于所有的 $u_L, u_R$，$\\mathcal{J}$ 的非正值表示这是一个耗散（能量稳定）的格式，而 $\\mathcal{J}=0$ 表示这是一个能量守恒的格式。\n\n**1. 中心通量分析**\n\n中心通量定义为 $f^*_{\\text{central}} = \\frac{1}{2}(a u^- + a u^+)$。将其代入能量贡献表达式，其中 $u_L=u^-$ 且 $u_R=u^+$：\n$$ \\mathcal{J}_{\\text{central}} = \\frac{a}{2}(u_L^2 - u_R^2) - (u_L - u_R) \\left( \\frac{1}{2}(a u_L + a u_R) \\right) $$\n$$ \\mathcal{J}_{\\text{central}} = \\frac{a}{2}(u_L^2 - u_R^2) - \\frac{a}{2}(u_L - u_R)(u_L + u_R) $$\n$$ \\mathcal{J}_{\\text{central}} = \\frac{a}{2}(u_L^2 - u_R^2) - \\frac{a}{2}(u_L^2 - u_R^2) = 0 $$\n因此，无论 $u_L$ 和 $u_R$ 的值如何，每个界面的贡献都恰好为零。这证明了使用中心通量的 DG 半离散化是**能量守恒**的。在傅里叶分析的背景下，这意味着半离散算子的特征值是纯虚数。该格式对所有波数 $\\kappa$ 的数值耗散均为零。虽然这能完美地保持波的振幅，但任何色散误差都会导致不同频率的波以不正确的速度传播，从而导致相位误差随时间累积。对于高波数，这些色散误差会变得很大，导致非物理振荡（虚假模）持续存在并在域中传播。\n\n**2. Lax-Friedrichs (LF) 通量分析**\n\nLax-Friedrichs 通量定义为 $f^*_{\\text{LF}} = \\frac{1}{2}(a u^- + a u^+) - \\frac{\\alpha}{2}(u^+ - u^-)$，其中 $\\alpha = |a|$。\n$$ \\mathcal{J}_{\\text{LF}} = \\frac{a}{2}(u_L^2 - u_R^2) - (u_L - u_R) \\left( \\frac{1}{2}(a u_L + a u_R) - \\frac{\\alpha}{2}(u_R - u_L) \\right) $$\n$$ \\mathcal{J}_{\\text{LF}} = \\left( \\frac{a}{2}(u_L^2 - u_R^2) - \\frac{a}{2}(u_L^2 - u_R^2) \\right) - (u_L - u_R)\\left(-\\frac{\\alpha}{2}(u_R-u_L)\\right) $$\n$$ \\mathcal{J}_{\\text{LF}} = - (u_L - u_R)\\left(\\frac{\\alpha}{2}(u_L-u_R)\\right) = -\\frac{\\alpha}{2}(u_L - u_R)^2 $$\n由于给定 $\\alpha = |a| \\ge 0$，能量贡献为 $\\mathcal{J}_{\\text{LF}} = -\\frac{|a|}{2}(u_L - u_R)^2 \\le 0$。只要界面上存在跳跃（$u_L \\neq u_R$），该格式就会耗散能量。耗散量与跳跃的平方成正比。\n- 对于**良好解析**的波模（低波数，$\\kappa \\ll 1$），多项式表示 $u_h$ 非常精确。多项式在单元边界上的值与相邻单元的值非常接近，因此跳跃 $(u_L - u_R)$ 非常小。因此，耗散是极小的。\n- 对于**欠解析**的波模（高波数，$\\kappa = \\mathcal{O}(1)$），次数为 $p$ 的多项式无法精确捕捉快速振荡。这导致在单元交界面上出现显著的跳跃，因为一个单元的多项式无法与下一个单元平滑连接。项 $(u_L - u_R)^2$ 变得很大，导致大量的耗散。这是一个理想的特性，因为它阻尼了网格和多项式阶数无法精确解析的虚假、高频数值噪声。\n\n**3. 比较与结论**\n\n- **对于良好解析的波 ($\\kappa \\ll 1$)：** 主要目标是振幅和相位的双重准确性。中心通量更优越，因为它非耗散（完美保持振幅），并且已知高阶 DG 方法在此范围内具有非常低的相位（色散）误差。而 LF 通量，虽然在此处仅为弱耗散，但仍会引入一些不希望的阻尼，并且可能具有稍大的相位误差。\n- **对于欠解析的波 ($\\kappa = \\mathcal{O}(1)$):** 主要目标从准确性（这是无法实现的）转向稳定性和抑制非物理伪影。中心通量缺乏耗散在这里是一个主要缺点，因为它允许具有大相位误差的虚假模持续存在并污染解。Lax-Friedrichs 通量在此范围内是高度优选的，因为其耗散与跳跃成比例，跳跃是未解析内容的一个代表，从而有效地阻尼这些虚假模并稳定格式。\n\n**选项评估：**\n\n- **A：** 该选项正确地指出，对于良好解析的模 ($\\kappa \\ll 1$)，中心通量因其无耗散和低相位误差而更受青睐。它还正确地指出，对于欠解析的模 ($\\kappa = \\mathcal{O}(1)$)，Lax-Friedrichs 通量更受青睐，因为其耗散随波数增加而增强，从而抑制了虚假内容。这与分析完全一致。**正确**。\n\n- **B：** 该选项声称 LF 通量一致更优，这是错误的。对于良好解析的波，与中心通量相比，其耗散是一种不希望出现的副作用。它还错误地声称 LF 能更好地保持振幅；中心通量完美地保持 $L^2$ 范数，而 LF 会耗散它。**不正确**。\n\n- **C：** 该选项错误地声称中心通量对于高波数更优。保留这些高色散、虚假的振荡对数值解的质量是有害的。LF 通量在此范围内提供的阻尼是有益的，而非过度的。**不正确**。\n\n- **D：** 该选项声稱兩種通量是等效的。定義和能量分析清楚地表明它們並不等效。一個是能量守恆的，另一個是耗散的。它們僅在連續解（所有界面上 $u^-=u^+$）的平凡情況下等效，但這否定了 DG 中的“間斷”特性。**不正確**。", "answer": "$$\\boxed{A}$$", "id": "3405177"}, {"introduction": "在定性理解了耗散的重要性之后，我们现在将通过编程实践来定量地、可视化地探索它。一个半离散格式的稳定性和耗散特性完全体现在其空间算子的特征值谱中。这个练习 [@problem_id:3405180] 要求我们构建间断Galerkin方法（DG）的半离散算子矩阵，并计算其特征值，从而直观地看到不同数值通量（通过参数 $\\alpha$ 调节）如何影响特征值在复平面上的分布，并直接与显式时间积分的稳定性联系起来。", "problem": "考虑一维线性平流方程 $u_t + a u_x = 0$，定义在长度为 $L = 1$ 的周期性域上，具有恒定的平流速度 $a = 1$。使用节点间断 Galerkin 谱元法 (DGSEM)，每个单元采用 Legendre-Gauss-Lobatto (LGL) 点，并强制执行分部求和 (SBP) 性质。半离散 DGSEM 算子构建在包含 $K$ 个单元的均匀网格上，每个单元的大小为 $h = L/K$，使用参考单元映射和强形式配置微分。界面处的数值通量采用单参数族的形式：\n$$\n\\widehat{f}(u^-, u^+) = a \\left( \\tfrac{1}{2} (u^- + u^+) - \\tfrac{\\alpha}{2} (u^+ - u^-) \\right),\n$$\n其中 $u^-$ 和 $u^+$ 是左右界面迹，$\\alpha \\in [0,1]$ 是界面跳跃惩罚强度。特殊情况包括 $\\alpha = 0$（中心通量）、$\\alpha = 1$（迎风通量），以及对应于带有局部 Lax-Friedrichs 惩罚的斜对称分裂形式通量的中间值 $\\alpha$。\n\n您的任务是：\n1. 从 DG 弱形式和 SBP 性质出发，推导一个半离散矩阵算子 $\\mathbf{L}(\\alpha, p, K)$，使得全局自由度向量 $\\mathbf{u}$ 满足 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}(\\alpha, p, K) \\mathbf{u}$。这里 $p$ 是每个单元的多项式阶数，节点基由每个单元上的 $p+1$ 个 LGL 节点组成。\n2. 对每个 $\\alpha$，计算 $\\mathbf{L}(\\alpha, p, K)$ 的特征值，并分析谱的实部和虚部如何依赖于 $p$ 和 $\\alpha$。特别地，识别出那些实部远低于谱主体的“离群”特征模态，并量化其大小如何随界面惩罚强度 $\\alpha$ 变化。\n\n在您的推导和构建中，请使用以下基础：\n- 每个单元上的 DG 弱形式，其中界面数值通量取代了单元边界处的物理通量。\n- 从物理坐标 $x$ 到参考坐标 $\\xi \\in [-1,1]$ 的映射，其中 $x = x_e + \\frac{h}{2}\\xi$ 且 $u_x = \\frac{2}{h} u_\\xi$。\n- 在 LGL 点进行节点配置，采用基于 LGL 求积权重的对角质量矩阵，以及从 LGL 节点处的 Lagrange 基导数获得的微分矩阵。\n- LGL 微分和求积对的分部求和 (SBP) 性质，该性质确保了中心通量的能量稳定性，并控制了惩罚通量的耗散。\n\n数值和算法要求：\n- 使用 $K = 8$ 个单元和周期性边界条件。\n- 对于每个 $p \\in \\{1,2,4\\}$ 和每个 $\\alpha \\in \\{0.0, 0.5, 1.0\\}$，组装 $\\mathbf{L}(\\alpha, p, K)$ 并计算所有特征值。\n- 使用阈值定义离群值\n$$\n\\theta = \\min\\left( \\mu_{\\Re} - 2 \\sigma_{\\Re}, -10^{-8} \\right),\n$$\n其中 $\\mu_{\\Re}$ 和 $\\sigma_{\\Re}$ 分别是特征值实部的均值和标准差。将实部严格小于 $\\theta$ 的特征值计为离群值。\n- 对于每个 $p$，计算 $\\alpha$ 值列表 $[0.0, 0.5, 1.0]$ 与对应的特征值最小实部列表 $\\left[\\min \\Re(\\lambda(\\alpha))\\right]$ 之间的 Pearson 相关系数。该系数用于量化加强界面惩罚如何将最具耗散性的模态在复平面上进一步向左推移。\n- 对于每个 $p$，还需计算 $\\Delta_{\\min} = \\min \\Re(\\lambda(\\alpha{=}1.0)) - \\min \\Re(\\lambda(\\alpha{=}0.0))$，以及在 $\\alpha = 1.0$ 时的离群值数量。\n\n测试套件：\n- 单元数 $K = 8$，域长度 $L = 1$，平流速度 $a = 1$。\n- 多项式阶数 $p \\in \\{1, 2, 4\\}$。\n- 惩罚强度 $\\alpha \\in \\{0.0, 0.5, 1.0\\}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个按升序排列的 $p$，附加一个三元组\n  - $\\alpha$ 与 $\\min \\Re(\\lambda)$ 之间的相关系数（浮点数），\n  - $\\Delta_{\\min}$ 的值（浮点数），\n  - $\\alpha = 1.0$ 时的离群值数量（整数）。\n- 因此，最终输出必须按 $p = 1$、$p = 2$、$p = 4$ 的顺序包含 3 个三元组，总共得到一个包含 9 个条目的列表，例如：\n\"[corr_p1,delta_p1,count_p1,corr_p2,delta_p2,count_p2,corr_p4,delta_p4,count_p4]\"。", "solution": "所提出的问题是偏微分方程数值分析中的一个明确定义的标准任务，具体涉及线性平流方程的间断 Galerkin 谱元法 (DGSEM) 的谱特性。所有参数和方法，如方程、域、DGSEM 公式、Legendre-Gauss-Lobatto (LGL) 节点、分部求和 (SBP) 性质以及数值通量的定义，都是标准的且已正确指定。该问题具有科学依据，是自洽的，并且在算法上是可行的。因此，我们可以着手进行推导和求解。\n\n我们的目标是为一维线性平流方程 $u_t + a u_x = 0$ 构建半离散矩阵算子 $\\mathbf{L}(\\alpha, p, K)$ 并分析其特征值。域是长度为 $L=1$ 的周期性域，离散为 $K$ 个大小为 $h=L/K$ 的均匀单元。平流速度为 $a=1$。每个单元内的解由一个次数为 $p$ 的多项式在由 $p+1$ 个 LGL 点定义的节点基上进行近似。\n\n我们从强形式 DGSEM 公式开始。在每个单元 $k$ 上，我们在 $p+1$ 个 LGL 节点处配置偏微分方程。设 $\\mathbf{u}_k$ 为单元 $k$ 内 LGL 节点上的解值向量。这些节点上解的时间导数由作用于解的空间算子，加上界面通量的修正项给出。空间导数 $u_x$ 通过 $u_x = \\frac{2}{h} u_\\xi$ 映射到参考单元 $\\xi \\in [-1, 1]$。节点上的导数 $u_\\xi$ 通过与 LGL 微分矩阵 $\\mathbf{D}$ 的矩阵向量乘法来近似。\n\n单元 $k$ 中自由度 $\\mathbf{u}_k$ 的半离散方程为\n$$\n\\frac{d\\mathbf{u}_k}{dt} = -a \\frac{2}{h} \\mathbf{D} \\mathbf{u}_k + \\mathbf{C}_k\n$$\n其中 $\\mathbf{C}_k$ 是一个修正向量，用于在单元界面处强制执行用户定义的数值通量。此修正仅影响单元的边界节点，对于 LGL 点，即第一个节点 ($\\xi_0 = -1$) 和最后一个节点 ($\\xi_p = 1$)。节点 $i$ 的修正项由数值通量与物理通量之差导出，并按相应质量矩阵项的倒数进行缩放。对于对角质量矩阵 $\\mathbf{M} = \\text{diag}(w_0, \\dots, w_p)$（由雅可比行列式 $h/2$ 缩放），节点 $i$ 的更新公式为：\n$$\n\\frac{du_{i,k}}{dt} = -a \\frac{2}{h} (\\mathbf{D} \\mathbf{u}_k)_i - \\frac{2}{h} \\frac{1}{w_i} \\left[ \\delta_{ip} (\\widehat{f}(u_p^k, u_0^{k+1}) - f(u_p^k)) - \\delta_{i0} (\\widehat{f}(u_p^{k-1}, u_0^k) - f(u_0^k)) \\right]\n$$\n其中 $f(u) = au$ 是物理通量，$u_j^k$ 表示单元 $k$ 的节点 $j$ 上的解。Kronecker 符号 $\\delta_{ip}$ 和 $\\delta_{i0}$ 确保修正仅分别应用于节点 $p$（右边界, $\\xi=1$）和节点 $0$（左边界, $\\xi=-1$）。相邻单元 $k-1$ 和 $k+1$ 的索引按周期性处理。\n\n数值通量由 $\\widehat{f}(u^-, u^+) = a \\left( \\frac{1}{2} (u^- + u^+) - \\frac{\\alpha}{2} (u^+ - u^-) \\right)$ 给出，可重写为 $\\widehat{f}(u^-, u^+) = a \\left( \\frac{1+\\alpha}{2} u^- + \\frac{1-\\alpha}{2} u^+ \\right)$。\n\n在单元 $k$ 的左边界（节点 $0$），我们有 $u^- = u_p^{k-1}$ 和 $u^+ = u_0^k$。通量失配为：\n$$\n\\widehat{f}(u_p^{k-1}, u_0^k) - f(u_0^k) = a \\left( \\frac{1+\\alpha}{2} u_p^{k-1} + \\frac{1-\\alpha}{2} u_0^k \\right) - a u_0^k = a \\frac{1+\\alpha}{2} u_p^{k-1} - a \\frac{1+\\alpha}{2} u_0^k = -a \\frac{1+\\alpha}{2} (u_0^k - u_p^{k-1})\n$$\n在单元 $k$ 的右边界（节点 $p$），我们有 $u^- = u_p^k$ 和 $u^+ = u_0^{k+1}$。通量失配为：\n$$\n\\widehat{f}(u_p^k, u_0^{k+1}) - f(u_p^k) = a \\left( \\frac{1+\\alpha}{2} u_p^k + \\frac{1-\\alpha}{2} u_0^{k+1} \\right) - a u_p^k = a \\frac{1-\\alpha}{2} u_0^{k+1} - a \\frac{1-\\alpha}{2} u_p^k = a \\frac{1-\\alpha}{2} (u_0^{k+1} - u_p^k)\n$$\n将这些代入节点更新方程：\n对于节点 $i=0$：\n$$\n\\frac{du_{0,k}}{dt} = -a \\frac{2}{h} (\\mathbf{D} \\mathbf{u}_k)_0 - \\frac{2}{h} \\frac{1}{w_0} \\left[ - \\left( -a \\frac{1+\\alpha}{2} (u_0^k - u_p^{k-1}) \\right) \\right] = -a \\frac{2}{h} (\\mathbf{D} \\mathbf{u}_k)_0 - \\frac{a(1+\\alpha)}{h w_0} (u_0^k - u_p^{k-1})\n$$\n对于节点 $i=p$：\n$$\n\\frac{du_{p,k}}{dt} = -a \\frac{2}{h} (\\mathbf{D} \\mathbf{u}_k)_p - \\frac{2}{h} \\frac{1}{w_p} \\left[ a \\frac{1-\\alpha}{2} (u_0^{k+1} - u_p^k) \\right] = -a \\frac{2}{h} (\\mathbf{D} \\mathbf{u}_k)_p - \\frac{a(1-\\alpha)}{h w_p} (u_0^{k+1} - u_p^k)\n$$\n现在我们可以组装大小为 $N \\times N$ 的全局矩阵算子 $\\mathbf{L}$，其中 $N=K(p+1)$。全局自由度向量为 $\\mathbf{U} = [\\mathbf{u}_0^T, \\dots, \\mathbf{u}_{K-1}^T]^T$。该系统为 $\\frac{d\\mathbf{U}}{dt} = \\mathbf{L} \\mathbf{U}$。矩阵 $\\mathbf{L}$ 具有块循环结构。对角块 $\\mathbf{L}_{k,k}$ 代表单元内贡献，而非对角块 $\\mathbf{L}_{k,k-1}$ 和 $\\mathbf{L}_{k,k+1}$ 代表单元间耦合。\n\n1.  **体项**：微分项 $-a \\frac{2}{h} \\mathbf{D}$ 贡献于对角块 $\\mathbf{L}_{k,k}$。\n2.  **面积项（对角块）**：\n    - 项 $-\\frac{a(1+\\alpha)}{h w_0} u_0^k$ 加到 $\\mathbf{L}_{k,k}$ 的 $(0,0)$ 项上。\n    - 项 $+\\frac{a(1-\\alpha)}{h w_p} u_p^k$ 加到 $\\mathbf{L}_{k,k}$ 的 $(p,p)$ 项上。\n3.  **面积项（非对角块）**：\n    - 项 $+\\frac{a(1+\\alpha)}{h w_0} u_p^{k-1}$ 贡献于块 $\\mathbf{L}_{k,k-1}$ 的 $(0,p)$ 项。\n    - 项 $-\\frac{a(1-\\alpha)}{h w_p} u_0^{k+1}$ 贡献于块 $\\mathbf{L}_{k,k+1}$ 的 $(p,0)$ 项。\n\n基于 LGL 点的微分算子 $\\mathbf{D}$ 和质量矩阵 $\\mathbf{M}$ 的 SBP 性质为 $\\mathbf{M}\\mathbf{D} + (\\mathbf{M}\\mathbf{D})^T = \\text{diag}(-1, 0, \\dots, 0, 1)$。此性质保证了对于中心通量 ($\\alpha=0$)，半离散算子是能量稳定的，意味着特征值的实部为零或非正（对于平流方程理想情况下为零）。对于 $\\alpha > 0$，会引入耗散，将特征值的实部推向严格为负。\n\n数值实现将为每组给定的参数 $(p, \\alpha)$ 构建此矩阵，计算其特征值，并执行指定的分析：计算 $\\alpha$ 与特征值最小实部之间的 Pearson 相关性，迎风通量与中心通量之间最小实部的差异，以及计算迎风情况下离群模态的数量。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_jacobi, legendre\n\ndef get_lgl_basis(p):\n    \"\"\"\n    Computes LGL nodes, weights, and the differentiation matrix for a given\n    polynomial degree p.\n    \"\"\"\n    if p == 0:\n      return np.array([-1.0]), np.array([2.0]), np.array([[0.0]])\n      \n    if p == 1:\n        xi = np.array([-1.0, 1.0])\n        w = np.array([1.0, 1.0])\n        D = np.array([[-0.5, 0.5], [-0.5, 0.5]])\n        return xi, w, D\n\n    # Interior nodes are roots of the derivative of the p-th Legendre polynomial,\n    # which are roots of the Jacobi polynomial P_{p-1}^{(1,1)}.\n    xi_interior, _ = roots_jacobi(p - 1, 1, 1)\n    xi = np.concatenate(([-1.0], np.sort(xi_interior), [1.0]))\n\n    # Legendre polynomial object\n    P_p_poly = legendre(p)\n    P_p_vals = P_p_poly(xi)\n\n    # Weights\n    w = 2.0 / (p * (p + 1) * P_p_vals**2)\n\n    # Differentiation matrix\n    D = np.zeros((p + 1, p + 1))\n    for i in range(p + 1):\n        for j in range(p + 1):\n            if i != j:\n                D[i, j] = P_p_vals[i] / (P_p_vals[j] * (xi[i] - xi[j]))\n            else:\n                if i == 0:\n                    D[i, i] = -p * (p + 1) / 4.0\n                elif i == p:\n                    D[i, i] = p * (p + 1) / 4.0\n                else:\n                    D[i, i] = 0.0\n    return xi, w, D\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem.\n    \"\"\"\n    L_domain = 1.0\n    a = 1.0\n    K = 8\n    h = L_domain / K\n\n    p_list = [1, 2, 4]\n    alpha_list = [0.0, 0.5, 1.0]\n\n    all_results = []\n\n    for p in p_list:\n        xi, w, D = get_lgl_basis(p)\n        N_p = p + 1\n        N_global = K * N_p\n\n        min_real_parts = []\n        outlier_count_alpha1 = 0\n\n        for alpha in alpha_list:\n            L_matrix = np.zeros((N_global, N_global), dtype=np.complex128)\n\n            # Volume contribution (same for all elements)\n            D_block = -a * 2.0 / h * D\n\n            # Surface contributions\n            # Self-coupling terms\n            C_self_00 = -a * (1.0 + alpha) / (h * w[0])\n            C_self_pp = a * (1.0 - alpha) / (h * w[p])\n            \n            # Neighbor-coupling terms\n            C_left_0p = a * (1.0 + alpha) / (h * w[0])\n            C_right_p0 = -a * (1.0 - alpha) / (h * w[p])\n\n            for k in range(K):\n                offset = k * N_p\n\n                # Diagonal block (volume + self-coupling surface terms)\n                L_matrix[offset : offset + N_p, offset : offset + N_p] = D_block\n                L_matrix[offset, offset] += C_self_00\n                L_matrix[offset + p, offset + p] += C_self_pp\n\n                # Off-diagonal blocks (neighbor-coupling surface terms)\n                # Periodic boundary conditions\n                km1 = (k - 1 + K) % K\n                kp1 = (k + 1) % K\n                \n                L_matrix[offset, km1 * N_p + p] += C_left_0p\n                L_matrix[offset + p, kp1 * N_p] += C_right_p0\n\n            # Compute eigenvalues\n            eigenvalues = np.linalg.eigvals(L_matrix)\n            real_parts = eigenvalues.real\n            min_real_parts.append(np.min(real_parts))\n\n            # Outlier analysis for alpha = 1.0\n            if alpha == 1.0:\n                mu_re = np.mean(real_parts)\n                sigma_re = np.std(real_parts)\n                threshold = min(mu_re - 2 * sigma_re, -1e-8)\n                outlier_count_alpha1 = int(np.sum(real_parts  threshold))\n\n        # Compute Pearson correlation\n        corr_matrix = np.corrcoef(alpha_list, min_real_parts)\n        # Handle case of zero variance if min_real_parts are constant\n        if np.isnan(corr_matrix[0, 1]):\n            correlation = 0.0\n        else:\n            correlation = corr_matrix[0, 1]\n\n        # Compute Delta_min\n        delta_min = min_real_parts[2] - min_real_parts[0]\n\n        all_results.extend([correlation, delta_min, outlier_count_alpha1])\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{x:.6f}' if isinstance(x, float) else str(x) for x in all_results)}]\")\n\nsolve()\n```", "id": "3405180"}, {"introduction": "我们的实践从简单平流方程进入到更真实的物理系统。在许多地球物理流动问题中，数值格式不仅要能传播波，还必须精确地维持重要的物理稳态平衡，例如地转平衡。这催生了“保平衡”（well-balanced）格式的设计，其中数值通量的选择必须与源项的离散化方法相匹配。这个练习 [@problem_id:3405150] 将带领我们为浅水方程实现一个保平衡格式，并研究当通量和源项的离散不一致时（由于求积不匹配）所产生的数值误差，从而深刻理解现代数值通量设计在复杂应用中的精妙之处。", "problem": "考虑在平坦底面上的二维浅水方程组，带有 Coriolis 加速度，该方程组是为流体深度 $h(x,y,t)$ 和深度平均速度 $(u(x,y,t),v(x,y,t))$ 编写的：\n$$\n\\partial_t h + \\partial_x (h u) + \\partial_y (h v) = 0,\n$$\n$$\n\\partial_t (h u) + \\partial_x\\left(h u^2 + \\tfrac{1}{2} g h^2\\right) + \\partial_y (h u v) = f_c h v,\n$$\n$$\n\\partial_t (h v) + \\partial_x (h u v) + \\partial_y\\left(h v^2 + \\tfrac{1}{2} g h^2\\right) = - f_c h u,\n$$\n其中 $g$ 是重力加速度，$f_c$ 是 Coriolis 参数。假设场仅依赖于坐标 $y$ 和时间 $t$（无 $x$ 方向变化），并考虑地转平衡稳态，其中 $(\\partial_t h,\\partial_t u,\\partial_t v)=(0,0,0)$，$v(y)=0$，且 $u(y)$ 满足 $y$ 方向动量方程中静水压力梯度与 Coriolis 力相平衡。\n\n您将为 $y$ 方向的一维域上的 $y$ 动量方程构建并分析一个间断 Galerkin (DG) 离散化：\n$$\n\\partial_t (h v) + \\partial_y\\left(\\tfrac{1}{2} g h^2\\right) = - f_c h u,\n$$\n在地转假设 $v(y)=0$ 下。计算域为区间 $[0,1]$，被划分为两个相等的单元 $[0,\\tfrac{1}{2}]$ 和 $[\\tfrac{1}{2},1]$。在每个单元上，使用 $p$ 次多项式逼近，节点为 Legendre-Gauss-Lobatto 节点，并令 $\\{\\ell_j(y)\\}_{j=0}^{p}$ 表示局部 Lagrange 基函数。分别用 $F(y) := \\tfrac{1}{2} g h(y)^2$ 表示静水压力通量，用 $S(y) := - f_c h(y) u(y)$ 表示 Coriolis 源。在稳定地转平衡中，$y$ 动量方程的 DG 弱形式简化为对每个基函数 $\\ell_j$ 进行检验，并强制离散残差\n$$\n\\mathcal{R}_j = - \\int_{K} \\partial_y \\ell_j(y)\\, F(y)\\, dy + \\left.\\ell_j(y)\\,F^*(y)\\,n(y)\\right|_{\\partial K} - \\int_K \\ell_j(y)\\, S(y)\\, dy,\n$$\n在每个单元 $K$ 上为零，其中 $n(y)$ 是单元边界处的外单位法向量（在一维情况下，左侧面上 $n=-1$，右侧面上 $n=+1$），$F^*(y)$ 是单元边界处的数值通量函数。任务是：\n1. 从连续地转平衡关系（静水压力梯度等于 Coriolis 力）出发，证明一种通量-源配对的合理性。在该配对中，选择界面通量函数 $F^*$ 和一个离散源项，使得对于在 Legendre-Gauss-Lobatto 节点上表示的地转平衡状态，离散残差 $\\mathcal{R}_j$ 精确为零，前提是在共享界面上对 $h$ 的单元边界值进行一致性求值。\n2. 量化当使用与通量配对不匹配的替代求积法则替换体积源积分时，对离散残差的影响，并解释不平衡的机制。\n\n您必须实现一个程序，对于给定的 $p$、重力加速度 $g$、Coriolis 参数 $f_c$ 以及一个深度剖面 $h(y)$ 及其对应的地转速度 $u(y)$ 的选择，该程序会评估两个单元上所有自由度的离散残差向量，并返回残差的欧几里得范数。在所有计算中，使用无量纲单位，令 $g=1$ 和 $f_c=1$（无需物理单位转换；以浮点数报告无量纲的残差大小）。\n\n对于通量-源配对，请遵循以下设计选择：\n- 使用界面数值通量 $F^*$，其值等于在 $h$ 的共享边界值处计算的静水压力势（边界坐标对相邻单元是共有的，因此在 $h$ 的逐点求值下单值）。\n- 为实现精确的地转平衡保持，通过静水压力势的离散导数来离散化 Coriolis 源，该离散导数使用与通量体积项相同的 Legendre-Gauss-Lobatto 微分算子计算。\n- 对于求积不匹配分析，通过在每个单元上使用 $q$ 个点的 Legendre-Gauss 求积来逼近 Coriolis 源体积积分，在这些求积点上计算连续表达式 $S(y)=g h(y)\\,\\partial_y h(y)$ 以及在相同点上的基函数。通量体积项和界面通量保持与精确配对中相同。\n\n您的程序必须实现以下测试套件，并按照本问题末尾指定的精确格式，在单行中输出四个残差范数：\n\n- 测试用例 1（匹配配对，多项式深度）：$p=4$，$h(y)=1+0.2\\,y+0.1\\,y^2$，$g=1$，$f_c=1$。使用精确配对（离散源作为静水压力势的离散导数，使用相同的 Legendre-Gauss-Lobatto 算子）。返回组装后的残差向量的欧几里得范数。\n\n- 测试用例 2（求积不匹配，相同多项式深度）：$p=4$，$h(y)=1+0.2\\,y+0.1\\,y^2$，$g=1$，$f_c=1$，但使用每个单元 $q=5$ 个点的 Legendre-Gauss 求积计算源体积积分，并在这些点上计算连续公式 $S(y)=g h(y)\\,\\partial_y h(y)$。返回组装后的残差向量的欧几里得范数。\n\n- 测试用例 3（边界度数边缘情况，线性深度，不匹配）：$p=1$，$h(y)=1+0.3\\,y$，$g=1$，$f_c=1$，源积分采用每个单元 $q=2$ 个点的 Legendre-Gauss 求积。返回组装后的残差向量的欧几里得范数。\n\n- 测试用例 4（非多项式深度，不匹配）：$p=6$，$h(y)=1+0.1\\sin(2\\pi y)$，$g=1$，$f_c=1$，源积分采用每个单元 $q=6$ 个点的 Legendre-Gauss 求积。返回组装后的残差向量的欧几里得范数。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含四个残差范数，以逗号分隔，并用方括号括起来。例如，它应打印如下形式的一行：\n$$\n[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]\n$$\n其中每个条目都是一个浮点数。", "solution": "该问题要求为浅水方程的一维 $y$ 动量方程构建并分析一个间断 Galerkin (DG) 离散化，该离散化专门针对稳定地转平衡状态。分析的重点是良好平衡（well-balancing）的概念，即数值格式被设计为能精确保持这种平衡状态。\n\n首先，我们建立连续地转平衡关系。给定浅水方程组，在稳态（$\\partial_t = 0$）、$x$ 方向无变化（$\\partial_x = 0$）以及 $y$ 方向速度为零（$v=0$）的假设下，$y$ 动量方程得到显著简化。\n完整的方程为：\n$$\n\\partial_t (h v) + \\partial_x (h u v) + \\partial_y\\left(h v^2 + \\tfrac{1}{2} g h^2\\right) = - f_c h u\n$$\n应用这些假设后，所有包含 $v$ 或 $\\partial_t$ 的项都消失了，并且 $\\partial_x$ 项也因假设为零，剩下：\n$$\n\\partial_y\\left(\\tfrac{1}{2} g h^2\\right) = - f_c h u\n$$\n这个方程代表了地转平衡，其中 $y$ 方向的静水压力梯度力与 Coriolis 力相平衡。我们将静水压力通量定义为 $F(y) = \\tfrac{1}{2} g h(y)^2$，Coriolis 源项定义为 $S(y) = -f_c h(y) u(y)$。因此，连续平衡可以简写为 $\\partial_y F(y) = S(y)$。对于指定的无量纲单位 $g=1$ 和 $f_c=1$，地转速度为 $u(y) = - g/f_c \\partial_y h(y) = - \\partial_y h(y)$。源项变为 $S(y) = - (1) h(y) (-\\partial_y h(y)) = h(y) \\partial_y h(y)$。这与通量导数一致，因为 $\\partial_y F(y) = \\partial_y(\\frac{1}{2}h(y)^2) = h(y) \\partial_y h(y)$。\n\n接下来，我们建立 DG 弱形式。将方程 $\\partial_y F = S$ 乘以一个测试函数 $\\ell_j(y)$（一个 $p$ 次 Lagrange 基多项式）并在一个计算单元 $K$ 上积分，得到：\n$$\n\\int_K \\ell_j(y) (\\partial_y F(y)) dy = \\int_K \\ell_j(y) S(y) dy\n$$\n对通量项进行分部积分，得到：\n$$\n\\left[ \\ell_j(y) F(y) \\right]_{\\partial K} - \\int_K (\\partial_y \\ell_j(y)) F(y) dy = \\int_K \\ell_j(y) S(y) dy\n$$\n在 DG 的背景下，单元边界处的单值通量 $F$ 被数值通量 $F^*$ 替代。边界项写为 $\\left. \\ell_j(y) F^*(y) n(y) \\right|_{\\partial K}$，其中 $n(y)$ 是外单位法向量。于是，单元 $K$ 上第 $j$ 个自由度的离散残差定义为：\n$$\n\\mathcal{R}_j = - \\int_{K} \\partial_y \\ell_j(y)\\, F(y)\\, dy + \\left.\\ell_j(y)\\,F^*(y)\\,n(y)\\right|_{\\partial K} - \\int_K \\ell_j(y)\\, S(y)\\, dy\n$$\n该问题要求对一个离散逼近计算此残差，其中解由其在每个单元内 $p+1$ 个 Legendre-Gauss-Lobatto (LGL) 节点上的值表示。令 $F_p(y)$ 为通过这些节点的通量函数 $F(y)$ 的多项式插值。\n\n**第1部分：通量-源配对的合理性证明**\n\n一个良好平衡的格式是指当使用精确的连续平衡解作为输入时，离散残差 $\\mathcal{R}_j$ 恒等于零。这通过以一种能够精确抵消离散通量导数的方式定义离散源项来实现。\n\nDG 离散化在 LGL 节点上执行。这些节点集的一个关键性质是，相关的微分矩阵 $\\mathbf{D}$ 和对角质量矩阵（求积权重）$\\mathbf{W}$ 满足分部求和 (SBP) 性质：$\\mathbf{D}^T\\mathbf{W} + \\mathbf{W}\\mathbf{D} = \\mathbf{B}$，其中 $\\mathbf{B}=\\text{diag}([-1, 0, \\dots, 0, 1])$。\n\n残差中的体积积分使用基于节点值的 LGL 求积来近似。\n通量积分项（向量形式）为 $\\mathbf{I}_1 = -(\\mathbf{D}^T \\mathbf{W}) \\mathbf{F}$，其中 $\\mathbf{F}$ 是节点处通量值的向量。\n按照规定，良好平衡的源项使用相同的 LGL 微分算子。在节点框架中，这意味着离散源向量 $\\mathbf{S}_{\\text{node}}$ 被定义为通量向量的离散导数：$\\mathbf{S}_{\\text{node}} = \\mathbf{D} \\mathbf{F}$。相应的源积分项是 $\\mathbf{I}_3 = -\\mathbf{W} \\mathbf{S}_{\\text{node}} = -\\mathbf{W}\\mathbf{D}\\mathbf{F}$。\n\n因此，残差中体积项的和为：\n$$\n\\mathbf{I}_1 + \\mathbf{I}_3 = -(\\mathbf{D}^T\\mathbf{W})\\mathbf{F} - (\\mathbf{W}\\mathbf{D})\\mathbf{F} = -(\\mathbf{D}^T\\mathbf{W} + \\mathbf{W}\\mathbf{D})\\mathbf{F} = -\\mathbf{B}\\mathbf{F}\n$$\n这导致一个向量，其中只有对应于单元边界的项非零：第一个节点（$j=0$）为 $-(-1)F_0$，最后一个节点（$j=p$）为 $-(+1)F_p$。所以，组合的体积项残差为 $(F_0, 0, \\dots, 0, -F_p)^T$，其中 $F_0$ 和 $F_p$ 是单元左右边界的通量值。\n\n残差中的边界通量项是 $\\mathbf{I}_2$。对于基函数 $\\ell_j$，它只在端点非零。对于 $j=0$，贡献为 $\\ell_0(y_{\\text{left}}) F^*(y_{\\text{left}}) n_{\\text{left}} = (1) F^*(y_{\\text{left}}) (-1) = -F^*(y_{\\text{left}})$。对于 $j=p$，贡献为 $\\ell_p(y_{\\text{right}}) F^*(y_{\\text{right}}) n_{\\text{right}} = (1) F^*(y_{\\text{right}}) (+1) = F^*(y_{\\text{right}})$。向量 $\\mathbf{I}_2$ 是 $(-F^*(y_{\\text{left}}), 0, \\dots, 0, F^*(y_{\\text{right}}))^T$。\n\n总残差向量为 $\\mathcal{R} = (\\mathbf{I}_1 + \\mathbf{I}_3) + \\mathbf{I}_2$。\n$$\n\\mathcal{R} = \\begin{pmatrix} F_0 \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ -F_p \\end{pmatrix} + \\begin{pmatrix} -F^*(y_{\\text{left}}) \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ F^*(y_{\\text{right}}) \\end{pmatrix} = \\begin{pmatrix} F_0 - F^*(y_{\\text{left}}) \\\\ 0 \\\\ \\vdots \\\\ 0 \\\\ -F_p + F^*(y_{\\text{right}}) \\end{pmatrix}\n$$\n问题指出，数值通量 $F^*$ 在 $h$ 的共享边界值处计算。这是一种中心通量，意味着在边界处 $F^* = F$。因此，$F_0 - F^*(y_{\\text{left}}) = 0$ 且 $-F_p + F^*(y_{\\text{right}}) = 0$。整个离散残差向量 $\\mathcal{R}$ 为零。这证明了所提出的通量-源配对的合理性：它确保了离散地转平衡能维持到机器精度。\n\n**第2部分：求积不匹配与不平衡**\n\n当源体积积分使用替代方法计算时，上述证明的精确抵消被破坏。问题指定使用一个 $q$ 点 Legendre-Gauss (LG) 求积法则来近似 $\\int_K \\ell_j(y) S(y) dy$，其中 $S(y)$ 是*连续*源函数 $S(y) = g h(y) \\partial_y h(y)$。\n\n现在的残差计算为 $\\mathcal{R} = \\mathbf{I}_1 + \\mathbf{I}_2 + \\mathbf{I}_{3, \\text{mismatch}}$。通量项 $\\mathbf{I}_1$ 和 $\\mathbf{I}_2$ 不变。新的源项 $\\mathbf{I}_{3, \\text{mismatch}}$ 不再满足与通量梯度项 $\\mathbf{I}_1$ 抵消所需的代数恒等式。\n\n不平衡的机制在于通量梯度和源项的离散算子之间失去了一致性。虽然连续地转状态满足 $S = \\partial_y F$，但良好平衡的数值格式要求离散表示也满足这一点，即 $\\text{Discrete}(S) = \\text{Discrete}(\\partial_y F)$。通过对源项使用不同于通量梯度的数值程序（即对解析源函数使用 LG 求积，而通量梯度是由基于 LGL 的弱形式隐式定义的），这种一致性被违反。由此产生的非零残差 $\\mathcal{R}$ 代表了一种伪力，在瞬态模拟中会使流体偏离稳态。此残差的大小量化了不平衡的程度。\n\n下面的程序实现了对四个测试用例中良好平衡（匹配）和非良好平衡（不匹配）格式的组装残差向量的欧几里得范数的计算。", "answer": "```python\nimport numpy as np\nfrom scipy.special import legendre, roots_jacobi\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the Discontinuous Galerkin residual problem for the shallow water equations.\n    \"\"\"\n\n    # Helper functions for spectral/DG methods, nested to be self-contained.\n    def get_lgl_nodes_weights(p):\n        \"\"\"Computes Legendre-Gauss-Lobatto nodes and weights for degree p on [-1, 1].\"\"\"\n        if p == 0:\n            return np.array([0.0]), np.array([2.0])\n        if p == 1:\n            return np.array([-1.0, 1.0]), np.array([1.0, 1.0])\n        \n        # Interior nodes are roots of P_p'(x) == roots of Jacobi polynomial P_{p-1}^{(1,1)}(x)\n        interior_nodes = roots_jacobi(p - 1, 1, 1)[0]\n        nodes = np.concatenate([[-1.0], interior_nodes, [1.0]])\n        \n        # Weights\n        leg_p_at_nodes = legendre(p)(nodes)\n        weights = 2.0 / (p * (p + 1) * leg_p_at_nodes**2)\n        \n        return nodes, weights\n\n    def get_lgl_diff_matrix(p, nodes):\n        \"\"\"Computes the LGL differentiation matrix for degree p on [-1, 1].\"\"\"\n        if p == 0:\n            return np.array([[0.0]])\n        \n        N = p + 1\n        D = np.zeros((N, N))\n        leg_p_at_nodes = legendre(p)(nodes)\n        \n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    D[i, j] = (leg_p_at_nodes[i] / leg_p_at_nodes[j]) / (nodes[i] - nodes[j])\n                else:\n                    if i == 0:\n                        D[i, j] = -p * (p + 1) / 4.0\n                    elif i == p:\n                        D[i, j] = p * (p + 1) / 4.0\n                    else:\n                        D[i, j] = 0.0\n        return D\n\n    def get_lagrange_basis_eval_matrix(eval_pts, nodes):\n        \"\"\"Computes matrix L where L_ij = l_j(eval_pts_i).\"\"\"\n        n_nodes = len(nodes)\n        n_eval = len(eval_pts)\n        L = np.zeros((n_eval, n_nodes))\n        \n        ident = np.eye(n_nodes)\n        for j in range(n_nodes):\n            # The j-th basis function has value 1 at node j and 0 at others.\n            interp = BarycentricInterpolator(nodes, ident[j, :])\n            if n_eval > 0:\n                L[:, j] = interp(eval_pts)\n        return L\n\n\n    def calculate_residual_norm(p, h_func, h_prime_func, g, f_c, mode, q=None):\n        \"\"\"\n        Calculates the Euclidean norm of the DG residual vector.\n        \"\"\"\n        domain = [0.0, 1.0]\n        elements = [[0.0, 0.5], [0.5, 1.0]]\n        total_dofs = 2 * (p + 1)\n        global_residual = np.zeros(total_dofs)\n\n        lgl_nodes_ref, lgl_weights_ref = get_lgl_nodes_weights(p)\n        diff_matrix_ref = get_lgl_diff_matrix(p, lgl_nodes_ref)\n\n        for e_idx, elem_bounds in enumerate(elements):\n            y_a, y_b = elem_bounds\n            jacobian = (y_b - y_a) / 2.0\n            \n            # Map reference nodes to physical element\n            y_nodes = y_a + jacobian * (lgl_nodes_ref + 1.0)\n            \n            # Evaluate functions at nodes\n            h_vals = h_func(y_nodes)\n            F_vals = 0.5 * g * h_vals**2\n\n            # 1. Flux volume term: I1 = - (D_ref^T @ W_ref) @ F_vals\n            # (D_ref.T @ diag(W_ref)) is the weak derivative matrix\n            I1_vec = - (diff_matrix_ref.T @ np.diag(lgl_weights_ref)) @ F_vals\n\n            # 2. Boundary flux term: I2\n            F_left = 0.5 * g * h_func(y_a)**2\n            F_right = 0.5 * g * h_func(y_b)**2\n            I2_vec = np.zeros(p + 1)\n            I2_vec[0] = -F_left  # n=-1 at left boundary\n            I2_vec[-1] = F_right # n=+1 at right boundary\n\n            # 3. Source term: I3\n            if mode == 'matched':\n                # S_node = D_phys @ F_vals = (1/J) * D_ref @ F_vals\n                S_node_vals = (1.0 / jacobian) * (diff_matrix_ref @ F_vals)\n                # I3 = - M @ S_node = - J * W_ref * S_node\n                I3_vec = - (jacobian * lgl_weights_ref) * S_node_vals\n            \n            elif mode == 'mismatched':\n                lg_nodes_ref, lg_weights_ref = np.polynomial.legendre.leggauss(q)\n                y_lg = y_a + jacobian * (lg_nodes_ref + 1.0)\n                \n                # Evaluate analytical source S(y) = g*h(y)*h'(y) at LG quadrature points\n                S_vals_at_lg = g * h_func(y_lg) * h_prime_func(y_lg)\n                \n                # Evaluate Lagrange basis functions at LG points\n                lagrange_eval_matrix = get_lagrange_basis_eval_matrix(lg_nodes_ref, lgl_nodes_ref)\n                \n                # I3_i = - integral(l_i * S)_K = - J * sum(w_k * l_i(y_k) * S(y_k))\n                I3_vec = -jacobian * (lagrange_eval_matrix.T @ (lg_weights_ref * S_vals_at_lg))\n            \n            else:\n                raise ValueError(\"Invalid mode specified.\")\n\n            elem_residual = I1_vec + I2_vec + I3_vec\n            start_idx = e_idx * (p + 1)\n            end_idx = start_idx + (p + 1)\n            global_residual[start_idx:end_idx] = elem_residual\n\n        return np.linalg.norm(global_residual)\n\n    # Test Case Definitions\n    g_val, fc_val = 1.0, 1.0\n    \n    # Case 1\n    p1 = 4\n    h1 = lambda y: 1.0 + 0.2*y + 0.1*y**2\n    h1_p = lambda y: 0.2 + 0.2*y\n    res1 = calculate_residual_norm(p1, h1, h1_p, g_val, fc_val, 'matched')\n    \n    # Case 2\n    p2, q2 = 4, 5\n    h2 = h1\n    h2_p = h1_p\n    res2 = calculate_residual_norm(p2, h2, h2_p, g_val, fc_val, 'mismatched', q=q2)\n\n    # Case 3\n    p3, q3 = 1, 2\n    h3 = lambda y: 1.0 + 0.3*y\n    h3_p = lambda y: 0.3\n    res3 = calculate_residual_norm(p3, h3, h3_p, g_val, fc_val, 'mismatched', q=q3)\n\n    # Case 4\n    p4, q4 = 6, 6\n    h4 = lambda y: 1.0 + 0.1 * np.sin(2 * np.pi * y)\n    h4_p = lambda y: 0.1 * 2 * np.pi * np.cos(2 * np.pi * y)\n    res4 = calculate_residual_norm(p4, h4, h4_p, g_val, fc_val, 'mismatched', q=q4)\n\n    results = [res1, res2, res3, res4]\n    \n    # Format output as specified\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3405150"}]}