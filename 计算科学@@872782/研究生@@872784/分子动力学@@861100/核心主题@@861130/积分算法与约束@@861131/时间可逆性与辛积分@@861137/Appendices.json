{"hands_on_practices": [{"introduction": "时间可逆性是许多辛积分器（如速度Verlet算法）的一个基本对称性。本练习旨在通过一个严格的数值实验来验证这一特性 [@problem_id:3456282]。通过在一个前向-反向积分周期后检查状态是否能逐位精确地恢复，我们超越了理论上的论证，直接检验了对称算法在有限精度计算中的鲁棒性，并将其与非对称算法的行为进行了对比。", "problem": "考虑一个分子动力学系统，其位形坐标为 $q \\in \\mathbb{R}^{n}$，共轭动量为 $p \\in \\mathbb{R}^{n}$，质量参数为 $m \\in \\mathbb{R}^{n}$ (各分量严格为正)，势能为 $V(q)$。其运动方程源于牛顿第二定律和哈密顿力学，其哈密顿量为 $H(q,p) = \\sum_{i=1}^{n} \\frac{p_i^2}{2m_i} + V(q)$，演化由 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = - \\partial H / \\partial q$ 决定。定义时间反演算符 $\\mathcal{R}$，其作用为 $\\mathcal{R}(q,p) = (q,-p)$。一个步进映射为 $\\Phi_{\\Delta t}$ 的积分器是时间可逆的，如果满足 $\\mathcal{R} \\circ \\Phi_{\\Delta t} \\circ \\mathcal{R} = \\Phi_{-\\Delta t}$。一个辛积分器会保持从哈密顿流继承的辛二形式。\n\n您的任务是实现一个完整、可运行的程序，该程序使用以下流程对多个子系统和代码路径执行精确时间可逆性的严格测试：\n1. 从初始状态 $(q_0,p_0)$ 开始，使用数值上是辛的和时间可逆的方案进行正向积分，总时间为 $T$，采用固定的时间步长 $\\Delta t$ 和严格为正的整数步数 $N$，使得 $T = N \\Delta t$。将得到的状态记为 $(q_T, p_T)$。\n2. 对动量应用时间反演算符：$(q_T, p_T) \\mapsto (q_T, -p_T)$。\n3. 使用相同的方案和时间步长 $\\Delta t$ 再次正向积分相同的步数 $N$，得到 $(q_{\\mathrm{back}}, p_{\\mathrm{back}})$。\n4. 再次对动量应用时间反演算符：$(q_{\\mathrm{fin}}, p_{\\mathrm{fin}}) = (q_{\\mathrm{back}}, -p_{\\mathrm{back}})$。\n5. 测量 $(q_{\\mathrm{fin}}, p_{\\mathrm{fin}})$ 和 $(q_0, p_0)$ 之间的按位相等性，即当 $q$ 和 $p$ 的所有64位浮点数分量被视为无符号整数时，其二进制表示完全相等。报告此测试的布尔结果。\n\n此外，实现一个基于前向欧拉法的非时间可逆基线积分器，以对比其行为。\n\n使用无量纲单位（即，所有量都是与数值模型一致的无单位标量）。\n\n为辛积分器实现两种结构上不同的代码路径：\n- 一个“标量循环”路径，按顺序执行原地更新。\n- 一个“向量化”路径，使用具有不同算术分组的向量化数组操作执行更新。\n\n您的程序必须对以下测试套件执行上述流程。对于每个测试用例，输出一个布尔值，指示最终的 $(q_{\\mathrm{fin}}, p_{\\mathrm{fin}})$ 是否与初始的 $(q_0, p_0)$ 按位相等：\n\n- 测试用例 1 (理想情况，二进分数步长)：一维谐振子，$V(q) = \\frac{1}{2} k q^2$，$k=1$，质量 $m=1$，初始 $q_0 = 1/2$，$p_0 = 1/4$，时间步长 $\\Delta t = 1/8$，总时间 $T = 8$，使用辛时间可逆方案的标量循环路径。\n\n- 测试用例 2 (备用代码路径)：与测试用例1使用相同的系统和参数，但使用向量化路径。\n\n- 测试用例 3 (非二进分数步长)：一维谐振子，$k=1$，$m=1$，初始 $q_0 = 1/2$，$p_0 = 1/4$，时间步长 $\\Delta t = 0.1$，总时间 $T = 1.0$，使用辛时间可逆方案的标量循环路径。\n\n- 测试用例 4 (边界情况，零力)：二维自由粒子 ($V(q) \\equiv 0$)，每个自由度的质量 $m=1$，初始 $q_0 = [1/4, -1/8]$，$p_0 = [1/16, 1/32]$，时间步长 $\\Delta t = 1/16$，总时间 $T = 1$，使用辛时间可逆方案的向量化路径。\n\n- 测试用例 5 (非线性相互作用)：两个在二维空间中通过 Lennard-Jones 势 $V(r) = 4 \\varepsilon \\left[ (\\sigma/r)^{12} - (\\sigma/r)^6 \\right]$ 相互作用的粒子，其中 $\\varepsilon = 1$，$\\sigma = 1$，两个粒子的质量均为 $m=1$，初始位置 $q_{0,1} = [1.5, 0.0]$，$q_{0,2} = [-1.5, 0.0]$，初始动量 $p_{0,1} = [0.0, 0.05]$，$p_{0,2} = [0.0, -0.05]$，时间步长 $\\Delta t = 0.001$，总时间 $T = 0.01$，使用辛时间可逆方案的向量化路径。\n\n- 测试用例 6 (非时间可逆基线)：一维谐振子，$k=1$，$m=1$，初始 $q_0 = 1/2$，$p_0 = 1/4$，时间步长 $\\Delta t = 1/8$，总时间 $T = 8$，使用基于前向欧拉法的基线积分器的标量循环路径。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[result1,result2,result3,result4,result5,result6]`），其中每个条目是“True”或“False”，对应于上述各测试用例的按位相等性测试结果。不涉及角度；除了所述的无量纲化之外，不需要进行单位转换。", "solution": "用户提供的问题是有效的。它在科学上基于哈密顿力学和数值积分的原理，问题陈述清晰，具有完整且明确的规范，并且其表述是客观的。任务是测试数值积分器的精确、按位时间可逆性，这是计算物理学中一个标准而严谨的流程。\n\n问题的核心在于算法的数学属性与其有限精度数值实现之间的区别。一个积分器 $\\Phi_{\\Delta t}$ 被定义为时间可逆的，如果它满足关系式 $\\mathcal{R} \\circ \\Phi_{\\Delta t} \\circ \\mathcal{R} = \\Phi_{-\\Delta t}$，其中 $\\mathcal{R}$ 是反转动量的时间反演算符，$\\mathcal{R}(q,p) = (q,-p)$。所描述的测试流程利用了这一属性。对于一个完全时间可逆的方案，一个 $N$ 步的正向积分，接着一次动量反转，再进行另一个 $N$ 步的正向积分，最后再进行一次动量反转，应该使系统返回到其精确的初始状态：$(\\mathcal{R} \\circ \\Phi_T \\circ \\mathcal{R}) \\circ \\Phi_T (q_0, p_0) = \\Phi_T^{-1} \\circ \\Phi_T (q_0, p_0) = (q_0, p_0)$。\n\n挑战在于验证这是否能达到*按位*精度。浮点运算会引入舍入误差。然而，像速度 Verlet 方法这样的对称、时间可逆算法的一个关键特征是，其后向积分路径的算术运算序列与前向路径的运算序列完全相反地镜像对应。这种对称性使得浮点误差可以相互抵消，理论上可以逐位地恢复初始状态，前提是没有信息因下溢或上溢而丢失。\n\n该问题要求实现两种积分器：\n\n1.  **速度 Verlet 积分器**：这是一个标准的辛和时间可逆方案选择。它可以从对应于哈密顿量 $H(q,p) = T(p) + V(q)$ 的刘维尔算符的 Trotter 分裂中导出。步进映射 $\\Phi_{\\Delta t}$ 是通过对动能 $T(p)$ 和势能 $V(q)$ 下的精确流进行对称组合而构建的：$\\Phi_{\\Delta t} = \\Phi_V(\\Delta t/2) \\circ \\Phi_T(\\Delta t) \\circ \\Phi_V(\\Delta t/2)$。这三个操作对应于：\n    a. 对动量进行半步“踢动”（kick）：$p(t+\\frac{\\Delta t}{2}) = p(t) + F(q(t))\\frac{\\Delta t}{2}$，其中力 $F = -\\nabla_q V$。\n    b. 对位置进行全步“漂移”（drift）：$q(t+\\Delta t) = q(t) + \\frac{p(t+\\frac{\\Delta t}{2})}{m}\\Delta t$。\n    c. 对动量进行最后一次半步踢动：$p(t+\\Delta t) = p(t+\\frac{\\Delta t}{2}) + F(q(t+\\Delta t))\\frac{\\Delta t}{2}$。\n    这种对称结构是其时间可逆性的来源。我们将按照要求，以两种不同的方式实现它：一个带有显式维度循环的‘标量循环’路径和一个使用 `numpy` 数组操作的‘向量化’路径，后者可能具有不同的算术分组。\n\n2.  **前向欧拉积分器**：这作为一个非时间可逆的基线。其更新方式为：\n    $q(t+\\Delta t) = q(t) + \\frac{p(t)}{m}\\Delta t$\n    $p(t+\\Delta t) = p(t) + F(q(t))\\Delta t$\n    这种异步更新（力仅基于时间 $t$ 的状态）破坏了对称性，因此它既不是时间可逆的，也不是辛的。我们预计它将无法通过按位可逆性测试。\n\n该流程将针对六个测试用例执行，涵盖不同的势（谐振子、自由粒子、Lennard-Jones）、不同的数值参数（二进分数步长与非二进分数步长），以及不同的积分器代码路径。每个用例都会报告一个布尔结果，指示最终状态是否与初始状态按位相同。按位比较是通过将状态向量的64位浮点数重新解释为64位无符号整数并检查其相等性来执行的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef are_bitwise_equal(q1, p1, q2, p2):\n    \"\"\"\n    Performs a bitwise comparison of two states (q, p).\n    Each state is composed of numpy arrays q and p of dtype float64.\n    \"\"\"\n    s1 = np.concatenate((np.ravel(q1), np.ravel(p1)))\n    s2 = np.concatenate((np.ravel(q2), np.ravel(p2)))\n\n    if s1.dtype != np.float64 or s2.dtype != np.float64:\n        raise TypeError(\"Inputs must be float64 numpy arrays for bitwise comparison.\")\n\n    if s1.shape != s2.shape:\n        return False\n\n    # View arrays as 64-bit unsigned integers and check for equality.\n    return np.all(s1.view(np.uint64) == s2.view(np.uint64))\n\n# --- Force Functions ---\n\ndef force_harmonic_oscillator(q, k=1.0):\n    \"\"\"Force for a 1D harmonic oscillator: F = -kq.\"\"\"\n    return -k * q\n\ndef force_free_particle(q):\n    \"\"\"Force for a free particle: F = 0.\"\"\"\n    return np.zeros_like(q)\n\ndef force_lennard_jones(q, epsilon=1.0, sigma=1.0):\n    \"\"\"Force for two particles interacting via Lennard-Jones potential.\"\"\"\n    q1 = q[0:2]\n    q2 = q[2:4]\n    r_vec = q1 - q2\n    r_sq = np.dot(r_vec, r_vec)\n    \n    r_minus2 = 1.0 / r_sq\n    sigma_sq = sigma * sigma\n    \n    sig2_r_minus2 = sigma_sq * r_minus2\n    sig6_r_minus6 = sig2_r_minus2 * sig2_r_minus2 * sig2_r_minus2\n    sig12_r_minus12 = sig6_r_minus6 * sig6_r_minus6\n\n    # F = (24*epsilon/r^2) * [2*(sigma/r)^12 - (sigma/r)^6] * r_vec\n    force_scalar_part = (24.0 * epsilon * r_minus2) * (2.0 * sig12_r_minus12 - sig6_r_minus6)\n    \n    force_on_1 = force_scalar_part * r_vec\n    force_on_2 = -force_on_1\n    \n    return np.concatenate((force_on_1, force_on_2))\n\n# --- Integrator Implementations ---\n\nclass VelocityVerletScalar:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"In-place update using sequential scalar loops.\"\"\"\n        force = self.force_func(q)\n        for i in range(len(q)):\n            p[i] += force[i] * 0.5 * dt\n        \n        for i in range(len(q)):\n            q[i] += (p[i] / self.m[i]) * dt\n        \n        force = self.force_func(q)\n        for i in range(len(q)):\n            p[i] += force[i] * 0.5 * dt\n        \n        return q, p\n\nclass VelocityVerletVectorized:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"In-place update using vectorized numpy operations.\"\"\"\n        p += self.force_func(q) * 0.5 * dt\n        q += (p / self.m) * dt\n        p += self.force_func(q) * 0.5 * dt\n        return q, p\n\nclass ForwardEulerScalar:\n    def __init__(self, force_func, m):\n        self.force_func = force_func\n        self.m = m\n\n    def step(self, q, p, dt):\n        \"\"\"Out-of-place update using scalar loops.\"\"\"\n        force = self.force_func(q)\n        q_next = np.empty_like(q)\n        p_next = np.empty_like(p)\n        for i in range(len(q)):\n            q_next[i] = q[i] + (p[i] / self.m[i]) * dt\n            p_next[i] = p[i] + force[i] * dt\n        return q_next, p_next\n\n# --- Simulation and Test Logic ---\n\ndef test_reversibility(integrator_class, force_func, q0_list, p0_list, m_val, T, dt, force_params):\n    \"\"\"\n    Executes the time-reversibility test for a given configuration.\n    \"\"\"\n    # Bind parameters to the force function\n    bound_force_func = lambda q: force_func(q, **force_params)\n\n    # Prepare initial state as float64 numpy arrays\n    q0 = np.array(q0_list, dtype=np.float64)\n    p0 = np.array(p0_list, dtype=np.float64)\n    m = np.full_like(q0, m_val, dtype=np.float64)\n\n    # Calculate number of steps\n    num_steps = int(round(T / dt))\n\n    integrator = integrator_class(bound_force_func, m)\n\n    # --- Step 1: Forward integration ---\n    q_fwd, p_fwd = q0.copy(), p0.copy()\n    for _ in range(num_steps):\n        q_fwd, p_fwd = integrator.step(q_fwd, p_fwd, dt)\n    \n    # --- Step 2: Apply time-reversal to momenta ---\n    p_fwd = -p_fwd\n\n    # --- Step 3: Integrate forward again (\"backward\" evolution) ---\n    q_back, p_back = q_fwd.copy(), p_fwd.copy()\n    for _ in range(num_steps):\n        q_back, p_back = integrator.step(q_back, p_back, dt)\n    \n    # --- Step 4: Apply time-reversal again ---\n    q_fin, p_fin = q_back.copy(), -p_back\n\n    # --- Step 5: Measure bitwise equality ---\n    return are_bitwise_equal(q0, p0, q_fin, p_fin)\n\ndef solve():\n    test_cases = [\n        # Test Case 1 (happy path, dyadic step)\n        {\"integrator_class\": VelocityVerletScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n        # Test Case 2 (alternate code path)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n        # Test Case 3 (non-dyadic step)\n        {\"integrator_class\": VelocityVerletScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 1.0, \"dt\": 0.1},\n        # Test Case 4 (boundary, zero force)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_free_particle, \"force_params\": {},\n         \"q0_list\": [1/4, -1/8], \"p0_list\": [1/16, 1/32], \"m_val\": 1.0, \"T\": 1.0, \"dt\": 1/16},\n        # Test Case 5 (nonlinear interaction)\n        {\"integrator_class\": VelocityVerletVectorized, \"force_func\": force_lennard_jones, \"force_params\": {\"epsilon\": 1.0, \"sigma\": 1.0},\n         \"q0_list\": [1.5, 0.0, -1.5, 0.0], \"p0_list\": [0.0, 0.05, 0.0, -0.05], \"m_val\": 1.0, \"T\": 0.01, \"dt\": 0.001},\n        # Test Case 6 (non-time-reversible baseline)\n        {\"integrator_class\": ForwardEulerScalar, \"force_func\": force_harmonic_oscillator, \"force_params\": {\"k\": 1.0},\n         \"q0_list\": [1/2], \"p0_list\": [1/4], \"m_val\": 1.0, \"T\": 8.0, \"dt\": 1/8},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = test_reversibility(\n            integrator_class=case[\"integrator_class\"],\n            force_func=case[\"force_func\"],\n            q0_list=case[\"q0_list\"],\n            p0_list=case[\"p0_list\"],\n            m_val=case[\"m_val\"],\n            T=case[\"T\"],\n            dt=case[\"dt\"],\n            force_params=case[\"force_params\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3456282"}, {"introduction": "在验证了时间可逆性这一基本属性之后，一个自然的问题是：它在实际的长时程模拟中究竟有何优势？本练习将一个辛积分器和一个经典的非辛积分器（四阶龙格-库塔法）应用于著名的费米-帕斯塔-乌拉姆-秦戈（FPUT）问题 [@problem_id:3456295]。通过这项实践，你将亲眼见证这些几何性质如何转化为卓越的长期能量守恒性以及对亚稳态等精细物理现象的忠实再现。", "problem": "考虑一个由 $N$ 个相同粒子组成的一维 Fermi–Pasta–Ulam–Tsingou 链，具有周期性边界条件和单位粒子质量。设位置和动量为 $(q_i,p_i)$，$i=0,1,\\dots,N-1$，粒子排列在一个环上。该系统根据哈密顿动力学演化，其 $\\beta$-Fermi–Pasta–Ulam–Tsingou 哈密顿量为\n$$\nH(q,p) \\equiv \\sum_{i=0}^{N-1} \\frac{1}{2} p_i^2 + \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} \\left(q_{i+1} - q_i\\right)^2 + \\frac{\\beta}{4} \\left(q_{i+1} - q_i\\right)^4 \\right),\n$$\n其中，索引在模 $N$ 意义下理解（周期性），且 $\\beta > 0$ 控制非线性强度。运动方程由哈密顿形式的牛顿第二定律给出，\n$$\n\\dot{q}_i = p_i, \\quad \\dot{p}_i = F_i(q),\n$$\n其中力 $F_i(q)$ 由 $-\\partial H / \\partial q_i$ 得到。\n\n您必须为此哈密顿系统实现并比较两种在长时间范围内的数值积分器：\n- 一种时间可逆的辛积分器：velocity–Verlet，\n- 一种非辛的显式积分器：经典的四阶 Runge–Kutta。\n\n对于每种积分器和每个测试用例，您必须在时间区间 $[0,T]$ 内，使用固定时间步长 $dt$ 和总步数 $n=\\lfloor T/dt \\rfloor$，计算以下诊断指标：\n\n1. 最大绝对相对能量漂移：\n$$\nD_{\\mathrm{energy}} \\equiv \\max_{0 \\le k \\le n} \\left| \\frac{H\\left(q^{(k)},p^{(k)}\\right) - H\\left(q^{(0)},p^{(0)}\\right)}{H\\left(q^{(0)},p^{(0)}\\right)} \\right|,\n$$\n其中 $(q^{(k)},p^{(k)})$ 表示 $k$ 步之后的状态。\n\n2. 时间可逆性误差：使用时间步长 $dt$ 从 $t=0$ 到 $t=T$ 进行正向积分，得到 $(q^{(n)},p^{(n)})$，然后将动量反转为 $(q^{(n)},-p^{(n)})$，并使用相同步数和负时间步长 $-dt$ 进行反向积分，得到 $(\\tilde{q}^{(0)},\\tilde{p}^{(0)})$。定义\n$$\nD_{\\mathrm{rev}} \\equiv \\sqrt{ \\frac{1}{N} \\sum_{i=0}^{N-1} \\left( \\left[\\tilde{q}^{(0)}_i - q^{(0)}_i\\right]^2 + \\left[\\tilde{p}^{(0)}_i - p^{(0)}_i\\right]^2 \\right) }.\n$$\n\n3. 基于线性简正模的亚稳态泄漏：定义 $q$ 和 $p$ 的离散傅里叶变换 (DFT)，采用酉归一化 $Q_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} q_j e^{-2\\pi i k j / N}$ 和 $P_k = \\frac{1}{\\sqrt{N}} \\sum_{j=0}^{N-1} p_j e^{-2\\pi i k j / N}$，其中 $k=0,1,\\dots,N-1$。对于线性化链，模频率为\n$$\n\\omega_k = \\sqrt{2\\left(1 - \\cos\\left(\\frac{2\\pi k}{N}\\right)\\right)}, \\quad k=0,1,\\dots,N-1.\n$$\n定义在时间步 $k_{\\mathrm{step}}$、波数为 $m$ 的线性化模态能量为\n$$\n\\mathcal{E}_m(k_{\\mathrm{step}}) \\equiv \\frac{1}{2} \\left|P_m\\right|^2 + \\frac{1}{2} \\omega_m^2 \\left|Q_m\\right|^2,\n$$\n以及初始激发的低频共轭模集合 $\\mathcal{S} \\equiv \\{1, N-1\\}$。在第 $k_{\\mathrm{step}}$ 步的瞬时泄漏为\n$$\nL(k_{\\mathrm{step}}) \\equiv 1 - \\frac{\\sum_{m \\in \\mathcal{S}} \\mathcal{E}_m(k_{\\mathrm{step}})}{\\sum_{m=1}^{N-1} \\mathcal{E}_m(k_{\\mathrm{step}})}.\n$$\n亚稳态泄漏指标是时间平均值\n$$\nD_{\\mathrm{leak}} \\equiv \\frac{1}{n} \\sum_{k_{\\mathrm{step}}=1}^{n} L(k_{\\mathrm{step}}).\n$$\n\n初始化：使用低振幅单模位移\n$$\nq_i(0) = A \\cos\\left(\\frac{2\\pi i}{N}\\right), \\quad p_i(0) = 0,\n$$\n振幅 $A > 0$。\n\n对于每个测试用例，计算两种积分器诊断指标之间的差值三元组，\n$$\n\\left[\\, D_{\\mathrm{energy}}^{\\mathrm{RK4}} - D_{\\mathrm{energy}}^{\\mathrm{VV}}, \\quad D_{\\mathrm{rev}}^{\\mathrm{RK4}} - D_{\\mathrm{rev}}^{\\mathrm{VV}}, \\quad D_{\\mathrm{leak}}^{\\mathrm{RK4}} - D_{\\mathrm{leak}}^{\\mathrm{VV}} \\,\\right],\n$$\n其中上标表示积分器方法（四阶 Runge–Kutta 与 velocity–Verlet）。所有量均为无量纲；以浮点数形式报告数值。\n\n您的程序必须生成一行输出，其中包含一个用方括号括起来的列表的列表，格式为逗号分隔，例如 $\\left[ [x_1,y_1,z_1], [x_2,y_2,z_2], [x_3,y_3,z_3] \\right]$，其中每个内部列表按下面列出的顺序对应一个测试用例。\n\n使用以下测试套件，它涵盖了一个典型场景、一个小时间步长场景和一个具有更大时间步长的更强非线性场景：\n- 用例 1（典型）：$N=8$，$\\beta=0.25$，$A=0.1$，$T=100$，$dt=0.02$。\n- 用例 2（小步长）：$N=8$，$\\beta=0.25$，$A=0.1$，$T=100$，$dt=0.005$。\n- 用例 3（更强非线性）：$N=8$，$\\beta=1.0$，$A=0.2$，$T=100$，$dt=0.05$。\n\n您的最终输出必须是包含三个计算出的三元组的单行，格式必须为 $\\left[\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot]\\,\\right]$。", "solution": "该问题是有效的。它提出了一个在计算物理学领域定义明确、有科学依据的任务，并提供了所有必要的参数和定义。其目标是比较两种数值积分方案——velocity–Verlet 和四阶 Runge–Kutta——在模拟一维 Fermi–Pasta–Ulam–Tsingou (FPUT) 链时的表现。这种比较是哈密顿系统数值分析中的一个经典练习，没有任何科学或逻辑上的缺陷。\n\n问题的核心在于理解辛积分器和非辛积分器在哈密顿系统长时间模拟中的定性差异。FPUT 系统为此提供了一个绝佳的测试平台。其动力学由哈密顿量决定：\n$$\nH(q,p) = K(p) + V(q) = \\sum_{i=0}^{N-1} \\frac{1}{2} p_i^2 + \\sum_{i=0}^{N-1} \\left( \\frac{1}{2} \\left(q_{i+1} - q_i\\right)^2 + \\frac{\\beta}{4} \\left(q_{i+1} - q_i\\right)^4 \\right)\n$$\n其中 $q_i$ 和 $p_i$ 是第 $i$ 个粒子的位置和动量，$m=1$ 是质量，$\\beta$ 控制四次非线性的强度。运动方程为 $\\dot{q}_i = \\partial H / \\partial p_i = p_i$ 和 $\\dot{p}_i = -\\partial H / \\partial q_i = F_i(q)$。粒子 $i$ 上的力由势能 $V(q)$ 导出：\n$$\nF_i(q) = -\\frac{\\partial V}{\\partial q_i} = (q_{i+1} - q_i) + \\beta(q_{i+1} - q_i)^3 - (q_i - q_{i-1}) - \\beta(q_i - q_{i-1})^3\n$$\n其中由于周期性边界条件，索引按模 $N$ 计算。\n\n比较了两种积分器：\n\n1.  **Velocity–Verlet (VV)**：这是一种二阶显式积分器，属于几何积分器或辛积分器类。单步执行如下：\n    $$\n    \\begin{align*}\n    p\\left(t + \\frac{dt}{2}\\right) = p(t) + F(q(t)) \\frac{dt}{2} \\\\\n    q(t + dt) = q(t) + p\\left(t + \\frac{dt}{2}\\right) dt \\\\\n    p(t + dt) = p\\left(t + \\frac{dt}{2}\\right) + F(q(t+dt)) \\frac{dt}{2}\n    \\end{align*}\n    $$\n    其关键特性是时间可逆性和辛性。辛性意味着积分器能精确地保持一个“影子”哈密顿量，该哈密顿量与真实的哈密顿量非常接近。这带来了出色的长期能量稳定性，数值能量误差保持有界并振荡，而不是随时间发生长期漂移。\n\n2.  **经典四阶 Runge–Kutta (RK4)**：这是一种通用的高阶显式积分器。对于系统 $\\dot{y} = f(t,y)$，一步计算如下：\n    $$\n    \\begin{align*}\n    k_1 = f(t_n, y_n) \\\\\n    k_2 = f\\left(t_n + \\frac{dt}{2}, y_n + \\frac{dt}{2}k_1\\right) \\\\\n    k_3 = f\\left(t_n + \\frac{dt}{2}, y_n + \\frac{dt}{2}k_2\\right) \\\\\n    k_4 = f(t_n + dt, y_n + dt k_3) \\\\\n    y_{n+1} = y_n + \\frac{dt}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n    \\end{align*}\n    $$\n    虽然 RK4 对于单步计算非常精确（局部误差为 $O(dt^5)$），但它不是辛积分器。当应用于哈密顿系统时，它不保持能量或相空间流的其他几何特性。数值能量通常会表现出长期漂移，这使其不适用于那些物理守恒定律至关重要的长期模拟。\n\n使用三种旨在突显这些差异的诊断指标来评估解：\n\n1.  **能量漂移 ($D_{\\mathrm{energy}}$)**：该指标直接测量能量守恒的违背程度，而能量守恒是精确动力学的一个基本属性。我们预期 VV 的值会显著小于 RK4，尤其是在长时间积分后。\n\n2.  **时间可逆性误差 ($D_{\\mathrm{rev}}$)**：精确的哈密顿动力学是时间可逆的。VV 积分器的构造使其能精确地共享此属性。相比之下，RK4 不是时间可逆的。该指标量化了从时间 $0$ 积分到 $T$ 再反向积分回时间 $0$ 后的误差。对于 VV，该误差应接近机器精度（由于浮点舍入误差），而对于 RK4，该误差将是巨大的。\n\n3.  **亚稳态泄漏 ($D_{\\mathrm{leak}}$)**：FPUT 问题因其“亚稳态”而闻名，即最初置于低频模式中的能量泄漏到其他模式的速度比统计力学预期的要慢得多。保持这种微妙的长期动力学行为是优秀几何积分器的标志。该指标基于线性化简正模中的能量，量化了这种泄漏。我们预计，非辛的 RK4 会引入数值伪影，加速这种泄漏，导致与结构保持的 VV 积分器相比，$D_{\\mathrm{leak}}$ 值更高。\n\n实现过程将首先为力、哈密顿量和每个积分步骤定义函数。一个主模拟循环将根据指定的初始条件，对每个测试用例和积分器演化系统，收集数据以计算三种诊断指标。最终结果是两种方法在这些诊断值上的差异集合。为了高效计算，采用了使用 NumPy 的矢量化操作，特别是使用 `numpy.roll` 来处理周期性边界条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_force(q, beta):\n    \"\"\"Calculates the force on each particle in the FPUT chain.\"\"\"\n    dq_plus = np.roll(q, -1) - q\n    dq_minus = q - np.roll(q, 1)\n    # The term (dq + beta * dq^3) represents the force from a spring.\n    # The net force is the difference between the pull from the right and the pull from the left.\n    force = (dq_plus + beta * dq_plus**3) - (dq_minus + beta * dq_minus**3)\n    return force\n\ndef calculate_hamiltonian(q, p, beta):\n    \"\"\"Calculates the total energy (Hamiltonian) of the FPUT chain.\"\"\"\n    kinetic_energy = 0.5 * np.sum(p**2)\n    dq = np.roll(q, -1) - q\n    potential_energy = np.sum(0.5 * dq**2 + (beta / 4.0) * dq**4)\n    return kinetic_energy + potential_energy\n\ndef velocity_verlet_step(q, p, dt, beta):\n    \"\"\"Performs a single step of the velocity-Verlet integrator.\"\"\"\n    force_t = calculate_force(q, beta)\n    p_half = p + 0.5 * dt * force_t\n    q_new = q + dt * p_half\n    force_t_plus_dt = calculate_force(q_new, beta)\n    p_new = p_half + 0.5 * dt * force_t_plus_dt\n    return q_new, p_new\n\ndef rk4_step(q, p, dt, beta):\n    \"\"\"Performs a single step of the classical fourth-order Runge-Kutta integrator.\"\"\"\n    # State vector y = (q, p), ODE is y_dot = f(y) = (p, F(q))\n    # k1\n    k1_q = p\n    k1_p = calculate_force(q, beta)\n    # k2\n    q2 = q + 0.5 * dt * k1_q\n    p2 = p + 0.5 * dt * k1_p\n    k2_q = p2\n    k2_p = calculate_force(q2, beta)\n    # k3\n    q3 = q + 0.5 * dt * k2_q\n    p3 = p + 0.5 * dt * k2_p\n    k3_q = p3\n    k3_p = calculate_force(q3, beta)\n    # k4\n    q4 = q + dt * k3_q\n    p4 = p + dt * k3_p\n    k4_q = p4\n    k4_p = calculate_force(q4, beta)\n    \n    q_new = q + (dt / 6.0) * (k1_q + 2.0 * k2_q + 2.0 * k3_q + k4_q)\n    p_new = p + (dt / 6.0) * (k1_p + 2.0 * k2_p + 2.0 * k3_p + k4_p)\n    return q_new, p_new\n\ndef compute_diagnostics(integrator_name, q0, p0, N, beta, T, dt):\n    \"\"\"Computes the three diagnostic metrics for a given integrator.\"\"\"\n    if integrator_name == 'vv':\n        step_func = velocity_verlet_step\n    elif integrator_name == 'rk4':\n        step_func = rk4_step\n    else:\n        raise ValueError(\"Unknown integrator\")\n\n    n_steps = int(np.floor(T / dt))\n\n    # --- Forward integration for D_energy and D_leak ---\n    q_curr, p_curr = q0.copy(), p0.copy()\n    \n    # Store final state for reversibility test\n    q_final, p_final = None, None\n    \n    # D_energy calculation\n    H0 = calculate_hamiltonian(q0, p0, beta)\n    if H0 == 0: H0 = 1.0 # Avoid division by zero, though unlikely\n    max_energy_drift = 0.0\n\n    # D_leak calculation\n    k_modes = np.arange(N)\n    omega_sq = 2.0 * (1.0 - np.cos(2.0 * np.pi * k_modes / N))\n    total_leakage = 0.0\n\n    for k in range(n_steps):\n        q_curr, p_curr = step_func(q_curr, p_curr, dt, beta)\n        \n        # Energy drift\n        Hk = calculate_hamiltonian(q_curr, p_curr, beta)\n        drift = np.abs((Hk - H0) / H0)\n        if drift > max_energy_drift:\n            max_energy_drift = drift\n\n        # Leakage\n        Q_k = np.fft.fft(q_curr, norm='ortho')\n        P_k = np.fft.fft(p_curr, norm='ortho')\n        modal_energies = 0.5 * (np.abs(P_k)**2 + omega_sq * np.abs(Q_k)**2)\n        total_linear_energy = np.sum(modal_energies[1:])\n        energy_in_S = modal_energies[1] + modal_energies[N-1]\n        \n        if total_linear_energy > 1e-15:\n            instantaneous_leakage = 1.0 - (energy_in_S / total_linear_energy)\n        else:\n            instantaneous_leakage = 0.0\n        total_leakage += instantaneous_leakage\n    \n    q_final, p_final = q_curr, p_curr\n    D_energy = max_energy_drift\n    D_leak = total_leakage / n_steps if n_steps > 0 else 0.0\n\n    # --- Backward integration for D_rev ---\n    q_rev, p_rev = q_final.copy(), -p_final.copy() # Reverse momenta\n    \n    for _ in range(n_steps):\n        q_rev, p_rev = step_func(q_rev, p_rev, -dt, beta)\n\n    # Reversibility error\n    q_diff_sq = np.sum((q_rev - q0)**2)\n    p_diff_sq = np.sum((p_rev - p0)**2)\n    D_rev = np.sqrt((q_diff_sq + p_diff_sq) / N)\n\n    return D_energy, D_rev, D_leak\n\ndef solve():\n    test_cases = [\n        # Case 1 (typical)\n        {'N': 8, 'beta': 0.25, 'A': 0.1, 'T': 100, 'dt': 0.02},\n        # Case 2 (small step)\n        {'N': 8, 'beta': 0.25, 'A': 0.1, 'T': 100, 'dt': 0.005},\n        # Case 3 (stronger nonlinearity)\n        {'N': 8, 'beta': 1.0, 'A': 0.2, 'T': 100, 'dt': 0.05}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, beta, A, T, dt = case['N'], case['beta'], case['A'], case['T'], case['dt']\n        \n        # Initial conditions\n        i = np.arange(N)\n        q0 = A * np.cos(2.0 * np.pi * i / N)\n        p0 = np.zeros(N)\n\n        # Compute diagnostics for both integrators\n        d_energy_vv, d_rev_vv, d_leak_vv = compute_diagnostics(\n            'vv', q0, p0, N, beta, T, dt)\n        \n        d_energy_rk4, d_rev_rk4, d_leak_rk4 = compute_diagnostics(\n            'rk4', q0, p0, N, beta, T, dt)\n\n        # Calculate differences RK4 - VV\n        diffs = [\n            d_energy_rk4 - d_energy_vv,\n            d_rev_rk4 - d_rev_vv,\n            d_leak_rk4 - d_leak_vv\n        ]\n        all_results.append(diffs)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list of lists matches the required format.\n    print(str(all_results))\n\nsolve()\n```", "id": "3456295"}, {"introduction": "基础的二阶辛积分器功能强大，但我们能否在保持其几何结构的同时获得更高的精度？本练习将指导你使用吉田组合法（Yoshida composition）构建一个四阶辛积分器。通过比较二阶与四阶方案 [@problem_id:3456317]，你将探索高阶方法不仅提升了精度，还显著改善了微正则系综采样的质量，这对于分子动力学的统计力学应用至关重要。", "problem": "实现、分析和比较一类通过组合构造的辛分子动力学积分器的时间可逆性和微正则采样性质。考虑一个由 $N$ 个独立谐振子组成的一维系统，其哈密顿量为\n$$H(q,p) \\equiv K(p) + V(q) = \\sum_{i=1}^{N} \\frac{p_i^2}{2} + \\frac{k}{2}\\sum_{i=1}^{N} q_i^2,$$\n其中 $q \\in \\mathbb{R}^N$ 是位置，$p \\in \\mathbb{R}^N$ 是动量，$k > 0$ 是一个刚度常数。在约化单位制下进行计算，其中质量、长度和能量均为无量纲且设为1，因此所有报告的量都是无量纲数。\n\n从哈密顿方程和算符分裂的概念出发，定义一个对称的二阶辛映射 $S(h)$，该映射通过对由 $H$ 生成的精确流进行 Strang 分裂得到，即对 $K$ 和 $V$ 的精确子流在时间步长 $h$ 上进行组合。然后，通过 Yoshida 组合构造一个四阶辛积分器：\n$$S_4(h) = S(a h)\\, S(b h)\\, S(a h),$$\n其中 $a$ 和 $b$ 是待选的实常数，以使 $S_4(h)$ 在保持对称性和辛性的同时达到四阶精度。\n\n你的程序必须：\n- 将 $S(h)$ 实现为标准的 velocity-Verlet (蛙跳) 更新，这对应于此可分哈密顿量的 Strang 分裂。\n- 推导并使用 Yoshida 系数 $a$ 和 $b$ 来实现 $S_4(h)$，作为 $S(h)$ 以子步长 $a h$、$b h$ 和 $a h$ 进行的三重组合。\n- 对于下述每个测试用例，在固定的总能量 $E$ 下，使用以下初始条件初始化系统\n  $$q_i(0) = 0 \\quad \\text{for all } i, \\qquad p_i(0) = \\sqrt{\\frac{2E}{N}} \\quad \\text{for all } i,$$\n  这确保了 $K(0) = E$ 和 $V(0) = 0$。\n- 对于每个积分器（$S$ 和 $S_4$）和测试用例：\n  1. 按如下方式计算可逆性误差。使用时间步长 $h$ 向前演化 $M_{\\mathrm{rev}}$ 步，然后将动量取反，再用相同方法和 $h$ 向前演化 $M_{\\mathrm{rev}}$ 步。用 $(q^{\\ast},p^{\\ast})$ 表示最终状态，用 $(q^{(0)},p^{(0)})$ 表示初始状态。报告可逆性误差\n     $$\\varepsilon \\equiv \\max\\big(\\lVert q^{\\ast} - q^{(0)}\\rVert_{\\infty},\\, \\lVert p^{\\ast} + p^{(0)}\\rVert_{\\infty}\\big).$$\n  2. 通过运行一个长为 $M_{\\mathrm{samp}}$ 步的轨迹并计算势能的时间平均值 $\\langle V \\rangle$，来估计势能分数的微正则采样偏差。对于此二次哈密顿量的精确动力学，微正则分数满足 $\\langle V \\rangle / E = 1/2$。定义偏差为\n     $$B \\equiv \\left|\\frac{\\langle V \\rangle}{E} - \\frac{1}{2}\\right|.$$\n  在指定的 $(q(0),p(0))$ 处初始化后，沿着轨迹每一步进行均匀采样。\n\n使用以下测试套件。在所有情况下，对 $S$ 和 $S_4$ 使用相同的时间步长 $h$。\n- 测试用例 1：$N = 1$, $k = 1.0$, $E = 1.0$, $h = 0.3$, $M_{\\mathrm{samp}} = 20000$, $M_{\\mathrm{rev}} = 400$。\n- 测试用例 2：$N = 3$, $k = 0.5$, $E = 2.0$, $h = 1.0$, $M_{\\mathrm{samp}} = 20000$, $M_{\\mathrm{rev}} = 400$。\n- 测试用例 3：$N = 5$, $k = 1.0$, $E = 5.0$, $h = 1.1$, $M_{\\mathrm{samp}} = 20000$, $M_{\\mathrm{rev}} = 400$。\n\n注意事项和要求：\n- 应用于频率为 $\\omega$ 的谐振模式的 velocity-Verlet 映射的稳定性条件是 $h \\,\\omega  2$。对于具有系数 $a$ 和 $b$ 的 Yoshida 组合 $S_4(h)$，确保对于所有测试的 $\\omega = \\sqrt{k}$，都有 $\\max(|a|,|b|)\\, h\\, \\omega  2$，上述测试套件满足此条件。\n- 将所有输出表示为无量纲浮点数。\n- 最终输出格式：你的程序应生成单行输出，包含一个列表的列表形式的结果，每个测试用例一个子列表，其中每个子列表按顺序包含四个浮点数 $[\\varepsilon_S,\\varepsilon_{S_4},B_S,B_{S_4}]$。例如，打印的行必须看起来像\n  $$\\big[\\,[\\varepsilon_S^{(1)},\\varepsilon_{S_4}^{(1)},B_S^{(1)},B_{S_4}^{(1)}],\\,[\\varepsilon_S^{(2)},\\varepsilon_{S_4}^{(2)},B_S^{(2)},B_{S_4}^{(2)}],\\,[\\varepsilon_S^{(3)},\\varepsilon_{S_4}^{(3)},B_S^{(3)},B_{S_4}^{(3)}]\\,\\big].$$\n打印的单行必须是这种带有数字条目的括号列表结构。", "solution": "该问题要求针对一个由 $N$ 个独立的一维谐振子组成的系统，实现并分析两种辛积分器，一个为二阶，一个为四阶。分析重点关注哈密顿系统数值积分器的两个关键性质：时间可逆性和微正则采样的准确性。\n\n### 基于原理的设计\n\n#### 1. 哈密顿系统与算符分裂\n\n系统由可分的哈密顿量 $H(q,p) = K(p) + V(q)$ 描述，其中 $K(p) = \\sum_{i=1}^{N} \\frac{p_i^2}{2}$ 是动能，$V(q) = \\frac{k}{2}\\sum_{i=1}^{N} q_i^2$ 是势能。在约化单位制中，质量 $m$ 为 $1$。任何相空间函数 $f(q,p)$ 的动力学都由哈密顿方程决定，可以写成算符形式 $\\frac{df}{dt} = \\{f, H\\} \\equiv L f$，其中 $L$ 是刘维尔算符。\n\n在时间步长 $h$ 后，状态 $(q(t), p(t))$ 的形式解由流算符 $\\exp(hL)$ 作用于初始状态 $(q(0), p(0))$ 给出。由于哈密顿量是可分的，刘维尔算符可以分裂为 $L = L_K + L_V$，其中 $L_K = \\{\\cdot, K\\}$ 控制演化的动能部分，$L_V = \\{\\cdot, V\\}$ 控制势能部分。这些子问题的精确解是已知的：\n-   在 $K$ 下演化时间 $t$：$q \\to q+pt$, $p \\to p$。这是一个自由漂移。算符为 $\\exp(t L_K)$。\n-   在 $V$ 下演化时间 $t$：$q \\to q$, $p \\to p - kqt$。这是一个动量“踢”。算符为 $\\exp(t L_V)$。\n\n由于 $L_K$ 和 $L_V$ 不对易，$\\exp(h(L_K+L_V)) \\neq \\exp(hL_K)\\exp(hL_V)$。辛积分器是通过组合子系统的精确流来构造的，其方式旨在保持相空间映射的辛性质并达到所需的精度阶数。\n\n#### 2. 二阶积分器 $S(h)$\n\n可以使用 Strang 分裂构造一个对称的二阶精度积分器。一步长为 $h$ 的算符由以下组合给出：\n$$ S(h) = \\exp\\left(\\frac{h}{2}L_V\\right) \\exp(h L_K) \\exp\\left(\\frac{h}{2}L_V\\right) $$\n根据构造，此组合是对称且辛的。其实现对应于广泛使用的 velocity-Verlet 算法。对于在时间 $t_n$ 的状态 $(q_n, p_n)$，在 $t_{n+1} = t_n + h$ 的状态计算如下：\n1.  **半步“踢”：** 用半个时间步长的力更新动量。\n    $$ p_{n+1/2} = p_n + F(q_n) \\frac{h}{2} = p_n - k q_n \\frac{h}{2} $$\n2.  **整步漂移：** 用新的动量更新整个时间步长的位置。\n    $$ q_{n+1} = q_n + p_{n+1/2} h $$\n3.  **半步“踢”：** 再次用新位置的力更新半个时间步长的动量。\n    $$ p_{n+1} = p_{n+1/2} + F(q_{n+1}) \\frac{h}{2} = p_{n+1/2} - k q_{n+1} \\frac{h}{2} $$\n这个记为 $S(h)$ 的算法是全局二阶精度的，意味着在固定时间 $T$ 后的误差为 $O(h^2)$。\n\n#### 3. 四阶积分器 $S_4(h)$\n\n更高阶的对称积分器可以通过组合一个低阶对称积分器来构造。这是由 H. Yoshida 发展的一种技术。为了从我们的二阶方法 $S(h)$ 构建一个四阶积分器，我们使用以下三重组合：\n$$ S_4(h) = S(a h) S(b h) S(a h) $$\n为了使此组合达到四阶，系数 $a$ 和 $b$ 必须满足两个条件。第一个条件确保总时间步长是正确的，第二个条件消除了组合映射的 Baker-Campbell-Hausdorff 展开中的主要三阶误差项。\n1.  时间步长分数之和：$2a+b=1$。\n2.  主要误差项的抵消：$2a^3+b^3=0$。\n\n将 $b = 1-2a$ 代入第二个方程得到 $2a^3 + (1-2a)^3 = 0$。对于实数解，这简化为 $\\sqrt[3]{2}a + (1-2a) = 0$，解出：\n$$ a = \\frac{1}{2 - 2^{1/3}}, \\quad b = 1 - 2a = \\frac{-2^{1/3}}{2 - 2^{1/3}} $$\n积分器 $S_4(h)$ 的实现方式是简单地连续调用 $S(h)$ 程序三次，使用缩放后的时间步长 $ah$, $bh$ 和 $ah$。根据构造，$S_4(h)$ 也是对称和辛的，其全局误差为 $O(h^4)$。\n\n#### 4. 分析与实现\n\n程序将实现这两种积分器，并根据两个指标对其进行评估。\n\n-   **时间可逆性误差 $\\varepsilon$**：一个对称积分器 $\\Psi_h$ 必须满足性质 $\\Psi_h^{-1} = R \\circ \\Psi_h \\circ R$，其中 $R(q,p)=(q,-p)$ 是动量反转算符。这意味着“演化 $M$ 步，反转动量，再演化 $M$ 步”的操作序列应使系统返回其初始状态，但动量相反：$\\Psi_h^M \\circ R \\circ \\Psi_h^M \\equiv R$。可逆性误差 $\\varepsilon$ 衡量了与此理想行为的数值偏差，对于对称方法，该偏差应在机器浮点精度的量级。该指标计算为 $\\varepsilon = \\max\\big(\\lVert q^{\\ast} - q^{(0)}\\rVert_{\\infty},\\, \\lVert p^{\\ast} + p^{(0)}\\rVert_{\\infty}\\big)$。\n\n-   **微正则采样偏差 $B$**：辛积分器并不精确守恒哈密顿量 $H$，而是守恒一个邻近的“影子”哈密顿量 $H_{eff} = H + O(h^p)$，其中 $p$ 是方法的阶数。因此，由积分器生成的轨迹采样的是 $H_{eff}$ 的微正则系综。对于长轨迹，可观测量的时间平均值将不同于 $H$ 的精确微正则平均值。对于谐振子，维里定理规定势能的精确微正则平均值为 $\\langle V \\rangle = E/2$。偏差 $B = \\left|\\frac{\\langle V \\rangle_{num}}{E} - \\frac{1}{2}\\right|$ 量化了数值采样的系统误差。我们预期该偏差会随积分器的阶数缩放，因此 $B_{S_4}$ 应显著小于 $B_S$。\n\n实现包括用于 $S(h)$ 和 $S_4(h)$ 步的独立函数，以及计算 $\\varepsilon$ 和 $B$ 的函数。一个主循环将遍历指定的测试用例，初始化系统，并为每个积分器调用分析函数以生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants for Yoshida coefficients\nYOSHIDA_A = 1.0 / (2.0 - 2.0**(1.0/3.0))\nYOSHIDA_B = 1.0 - 2.0 * YOSHIDA_A\n\ndef step_S(q, p, h, k):\n    \"\"\"\n    Performs a single step of the second-order velocity-Verlet integrator (S(h)).\n    \n    Args:\n        q (np.ndarray): Current positions.\n        p (np.ndarray): Current momenta.\n        h (float): Time step.\n        k (float): Stiffness constant.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: Updated positions and momenta.\n    \"\"\"\n    p_half = p - 0.5 * h * k * q\n    q_new = q + h * p_half\n    p_new = p_half - 0.5 * h * k * q_new\n    return q_new, p_new\n\ndef step_S4(q, p, h, k):\n    \"\"\"\n    Performs a single step of the fourth-order Yoshida integrator (S4(h)).\n    \n    Args:\n        q (np.ndarray): Current positions.\n        p (np.ndarray): Current momenta.\n        h (float): Time step.\n        k (float): Stiffness constant.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: Updated positions and momenta.\n    \"\"\"\n    q1, p1 = step_S(q, p, YOSHIDA_A * h, k)\n    q2, p2 = step_S(q1, p1, YOSHIDA_B * h, k)\n    q3, p3 = step_S(q2, p2, YOSHIDA_A * h, k)\n    return q3, p3\n\ndef compute_reversibility_error(integrator_type, q0, p0, h, k, M_rev):\n    \"\"\"\n    Computes the time-reversibility error for a given integrator.\n    \"\"\"\n    q, p = q0.copy(), p0.copy()\n    \n    step_func = step_S if integrator_type == 'S' else step_S4\n\n    # Evolve forward for M_rev steps\n    for _ in range(M_rev):\n        q, p = step_func(q, p, h, k)\n\n    # Negate momenta\n    p = -p\n\n    # Evolve forward again for M_rev steps\n    for _ in range(M_rev):\n        q, p = step_func(q, p, h, k)\n        \n    # Final state is (q*, p*) in the problem statement\n    err_q = np.linalg.norm(q - q0, ord=np.inf)\n    err_p = np.linalg.norm(p + p0, ord=np.inf)\n    \n    return max(err_q, err_p)\n\ndef compute_sampling_bias(integrator_type, q0, p0, h, k, E, M_samp):\n    \"\"\"\n    Computes the microcanonical sampling bias in potential energy.\n    \"\"\"\n    q, p = q0.copy(), p0.copy()\n    total_V = 0.0\n    \n    step_func = step_S if integrator_type == 'S' else step_S4\n\n    for _ in range(M_samp):\n        q, p = step_func(q, p, h, k)\n        potential_energy = 0.5 * k * np.sum(q**2)\n        total_V += potential_energy\n        \n    avg_V = total_V / M_samp\n    bias = abs(avg_V / E - 0.5)\n    \n    return bias\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (N, k, E, h, M_samp, M_rev)\n        (1, 1.0, 1.0, 0.3, 20000, 400),\n        (3, 0.5, 2.0, 1.0, 20000, 400),\n        (5, 1.0, 5.0, 1.1, 20000, 400),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, k, E, h, M_samp, M_rev = case\n        \n        # Initial conditions\n        q0 = np.zeros(N, dtype=np.float64)\n        p0 = np.full(N, np.sqrt(2.0 * E / N), dtype=np.float64)\n\n        # Compute metrics for S integrator\n        eps_S = compute_reversibility_error('S', q0, p0, h, k, M_rev)\n        bias_S = compute_sampling_bias('S', q0, p0, h, k, E, M_samp)\n        \n        # Compute metrics for S4 integrator\n        eps_S4 = compute_reversibility_error('S4', q0, p0, h, k, M_rev)\n        bias_S4 = compute_sampling_bias('S4', q0, p0, h, k, E, M_samp)\n        \n        all_results.append([eps_S, eps_S4, bias_S, bias_S4])\n\n    # Format and print output exactly as specified\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, row))}]\" for row in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3456317"}]}