{"hands_on_practices": [{"introduction": "在构建任何原子间势函数时，首要任务是确保其形式遵循基本的物理原理。其中一项核心原则是全同粒子的不可区分性，即交换任意两个相同类型原子的标签，系统的能量不应改变。本练习 ([@problem_id:3413133]) 将引导你从第一性原理出发，为一个依赖于原子间距离的三体相互作用构建一个满足置换对称性的势函数，并推导这一对称性约束如何减少模型的独立参数数量。掌握这一概念对于理解和开发从传统多体势到现代机器学习势的核心架构至关重要。", "problem": "一个单原子分子系统使用参数化的三体势进行建模，该势的形式受量子力学训练数据和实验可观测量启发。该势写为三重态描述符的线性泛函，这些描述符是根据每个三重态内的三个原子间距离计算得出的。设 $\\{g_{\\alpha}(r)\\}_{\\alpha=1}^{P}$ 是 $[0,\\infty)$ 上关于对距离的固定径向基，并为原子 $i$、$j$、$k$ 定义有序三重态描述符为\n$$\n\\mathbf{x}_{ijk} \\in \\mathbb{R}^{P^{3}}, \\quad \\left[\\mathbf{x}_{ijk}\\right]_{\\alpha\\beta\\gamma} \\equiv g_{\\alpha}(r_{ij})\\,g_{\\beta}(r_{jk})\\,g_{\\gamma}(r_{ki}),\n$$\n对所有索引 $\\alpha,\\beta,\\gamma \\in \\{1,\\dots,P\\}$，其中 $r_{ab}$ 是原子 $a$ 和 $b$ 之间的标量距离。三重态 $(i,j,k)$ 的模型能量贡献为 $E_{ijk} = \\mathbf{c}^{\\top}\\mathbf{x}_{ijk}$，其中 $\\mathbf{c} \\in \\mathbb{R}^{P^{3}}$，总的三体能量是所有有序三重态的总和。\n\n相同原子的基本不可区分性要求总能量在任何原子标签的置换下保持不变。这要求三体贡献在三个元素上的对称群作用下保持不变。仅使用物理可观测量在相同粒子置换下的对称性这一基本要求以及上述描述符的定义，并且不假设任何特定的预对称化公式，完成以下任务：\n\n1. 通过将与相同无序基函数三元组对应的 $(\\alpha,\\beta,\\gamma)$ 置换的参数 $\\mathbf{c}$ 联系起来，或者通过对有序边 $(ij)$、$(jk)$、$(ki)$ 作用的对称群上的平均算子来对称化描述符，从而正式构建一种强制对称性的方法。论证为什么对于线性模型这两种方法是等价的。\n\n2. 从群作用于索引三元组的第一性原理以及不可区分选择的组合学出发，推导在对每个三重态内的三个相同原子施加完全置换对称性后，参数空间的确切维度。将答案表示为关于 $P$ 的封闭形式解析表达式。\n\n你的最终答案必须是经过对称性约简后独立参数数量的单一封闭形式表达式。不需要数值代入。如果引入角度，则必须以弧度为单位，但此问题中仅出现径向距离，且未要求单位。最终答案必须是单一的封闭形式解析表达式，而不是不等式或方程。", "solution": "用户提供了一个关于构建对称三体原子间势并确定其参数空间维度的问题陈述。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n-   一个单原子分子系统。\n-   三体势被建模为三重态描述符的线性泛函。\n-   对距离的径向基为 $\\{g_{\\alpha}(r)\\}_{\\alpha=1}^{P}$，其中 $r \\in [0,\\infty)$。\n-   原子 $i, j, k$ 的有序三重态描述符是一个向量 $\\mathbf{x}_{ijk} \\in \\mathbb{R}^{P^{3}}$，其分量为 $[\\mathbf{x}_{ijk}]_{\\alpha\\beta\\gamma} = g_{\\alpha}(r_{ij})\\,g_{\\beta}(r_{jk})\\,g_{\\gamma}(r_{ki})$，其中 $\\alpha,\\beta,\\gamma \\in \\{1,\\dots,P\\}$，$r_{ab}$ 是原子 $a$ 和 $b$ 之间的距离。\n-   有序三重态 $(i,j,k)$ 的能量贡献为 $E_{ijk} = \\mathbf{c}^{\\top}\\mathbf{x}_{ijk}$，其中 $\\mathbf{c} \\in \\mathbb{R}^{P^{3}}$ 是一个参数向量。$\\mathbf{c}$ 的分量表示为 $c_{\\alpha\\beta\\gamma}$。\n-   总的三体能量是所有有序三重态的总和。\n-   对称性要求：总能量必须在任何原子标签的置换下保持不变，这要求三体贡献在三个元素上的对称群作用下保持不变。\n\n**步骤2：使用提取的给定信息进行验证**\n-   **科学依据**：该问题在计算材料科学和化学领域有充分的依据，特别是在机器学习原子间势的开发方面。基于径向基函数张量积的描述符的使用以及置换对称性的施加，在像ACE（原子团簇展开）、MTP（矩张量势）等模型中是标准且关键的概念。\n-   **适定性**：该问题是适定的。它要求对两种等价的强制对称方法进行形式化论证，并推导所得参数空间的维度。这些都是明确的数学目标。\n-   **客观性**：该问题以精确、客观和数学化的语言陈述。\n\n该问题没有科学缺陷，是自洽的，并描述了物理学和应用数学中一个现实且非平凡的任务。不存在使其无效的缺陷。\n\n**步骤3：结论与行动**\n该问题是**有效的**。将提供完整解答。\n\n---\n\n### 解答\n\n一个有序原子三重态 $(i,j,k)$ 的能量贡献由下式给出\n$$\nE_{ijk} = \\mathbf{c}^{\\top}\\mathbf{x}_{ijk} = \\sum_{\\alpha=1}^{P} \\sum_{\\beta=1}^{P} \\sum_{\\gamma=1}^{P} c_{\\alpha\\beta\\gamma} g_{\\alpha}(r_{ij}) g_{\\beta}(r_{jk}) g_{\\gamma}(r_{ki})\n$$\n相同粒子不可区分性的基本要求规定了物理系统的能量必须在这些粒子的标签置换下保持不变。对于三体势，这意味着来自三个原子集合 $\\{i,j,k\\}$ 的能量贡献必须与我们如何标记它们无关。这个依赖于原子几何构型的能量函数，必须在对称群 $S_3$ 对原子索引的作用下保持不变。\n\n设由原子 $i,j,k$ 定义的几何构型的三体能量表示为 $U_{ijk}$。问题要求我们对任何置换 $\\pi \\in S_3$ 强制执行对称性 $U_{\\pi(i)\\pi(j)\\pi(k)} = U_{ijk}$。我们假设该能量的函数形式是给定的形式，因此 $U_{ijk} = E_{ijk}$。让我们分析置换对基函数自变量的影响。令 $d_1 = r_{ij}$，$d_2 = r_{jk}$，以及 $d_3 = r_{ki}$。那么能量是一个函数 $U(d_1, d_2, d_3)$。\n\n考虑置换 $\\pi = (j,k)$，它交换原子 $j$ 和 $k$。新的有序三重态是 $(i,k,j)$。相应的距离是 $d'_1 = r_{ik} = d_3$，$d'_2 = r_{kj} = d_2$，以及 $d'_3 = r_{ji} = d_1$。这并不是自变量的简单置换。\n\n让我们更精确一点。问题陈述了“三个元素上的对称群”对“三体贡献”的作用。来自原子 $i,j,k$ 的贡献必须是不变的。我们来分析函数 $E_{ijk}$ 的自变量在原子标签的置换下如何变换。\n令 $\\pi=(j,k)$。原子三重态变为 $(i,k,j)$。提供给函数的距离是 $(r_{ik}, r_{kj}, r_{ji}) = (r_{ki}, r_{jk}, r_{ij})$。这个新三重态的能量表达式是：\n$$\nE_{ikj} = \\sum_{\\alpha\\beta\\gamma} c_{\\alpha\\beta\\gamma} g_{\\alpha}(r_{ik}) g_{\\beta}(r_{kj}) g_{\\gamma}(r_{ji}) = \\sum_{\\alpha\\beta\\gamma} c_{\\alpha\\beta\\gamma} g_{\\alpha}(r_{ki}) g_{\\beta}(r_{jk}) g_{\\gamma}(r_{ij})\n$$\n不变性要求 $E_{ijk} = E_{ikj}$ 表明：\n$$\n\\sum_{\\alpha\\beta\\gamma} c_{\\alpha\\beta\\gamma} g_{\\alpha}(r_{ij}) g_{\\beta}(r_{jk}) g_{\\gamma}(r_{ki}) = \\sum_{\\alpha\\beta\\gamma} c_{\\alpha\\beta\\gamma} g_{\\alpha}(r_{ki}) g_{\\beta}(r_{jk}) g_{\\gamma}(r_{ij})\n$$\n我们可以重新标记右侧的求和索引。令 $\\alpha'=\\gamma, \\beta'=\\beta, \\gamma'=\\alpha$。\n$$\n\\sum_{\\alpha'\\beta'\\gamma'} c_{\\gamma'\\beta'\\alpha'} g_{\\gamma'}(r_{ij}) g_{\\beta'}(r_{jk}) g_{\\alpha'}(r_{ki})\n$$\n由于基函数 $\\{g_{\\lambda}(r)\\}$ 是线性无关的，张量积函数 $\\{g_\\alpha(r_1)g_\\beta(r_2)g_\\gamma(r_3)\\}$ 构成了三变量函数的一个基。因此我们可以逐项对比系数：$c_{\\alpha\\beta\\gamma} = c_{\\gamma\\beta\\alpha}$。这对应于交换第一个和第三个索引。\n\n现在考虑一个循环置换 $\\pi = (i,j,k)$。新的三重态是 $(j,k,i)$。距离是 $(r_{jk}, r_{ki}, r_{ij})$。不变性 $E_{ijk} = E_{jki}$ 意味着：\n$$\n\\sum_{\\alpha\\beta\\gamma} c_{\\alpha\\beta\\gamma} g_{\\alpha}(r_{ij}) g_{\\beta}(r_{jk}) g_{\\gamma}(r_{ki}) = \\sum_{\\alpha\\beta\\gamma} c_{\\alpha\\beta\\gamma} g_{\\alpha}(r_{jk}) g_{\\beta}(r_{ki}) g_{\\gamma}(r_{ij})\n$$\n用 $\\alpha'=\\gamma, \\beta'=\\alpha, \\gamma'=\\beta$ 重新标记右侧，得到：\n$$\n\\sum_{\\alpha'\\beta'\\gamma'} c_{\\beta'\\gamma'\\alpha'} g_{\\beta'}(r_{ij}) g_{\\gamma'}(r_{jk}) g_{\\alpha'}(r_{ki})\n$$\n对比系数可得 $c_{\\alpha\\beta\\gamma} = c_{\\beta\\gamma\\alpha}$。这是索引的一个循环置换。\n\n索引 $(\\alpha,\\beta,\\gamma)$ 上的这两个置换，即 $(\\gamma,\\beta,\\alpha)$ 和 $(\\beta,\\gamma,\\alpha)$，生成了整个对称群 $S_3$。因此，能量在所有原子置换下保持不变的条件是，系数张量 $\\mathbf{c}$ 必须在其索引的任何置换下完全对称：\n$$\nc_{\\alpha\\beta\\gamma} = c_{\\pi(\\alpha\\beta\\gamma)} \\quad \\forall \\pi \\in S_3 \\text{ (acting on index positions)}\n$$\n\n**1. 对称强制方法的构建及其等价性**\n\n**方法1：参数绑定**\n这种方法直接实现了上面推导出的对称性条件。我们约束参数张量 $\\mathbf{c}$ 为一个对称张量。这意味着对于任何索引的多重集 $\\{\\alpha, \\beta, \\gamma\\}$，所有系数 $c_{\\alpha'\\beta'\\gamma'}$（其中 $(\\alpha',\\beta',\\gamma')$ 是 $(\\alpha, \\beta, \\gamma)$ 的一个置换）都被设置为相等。例如，$c_{123} = c_{132} = c_{213} = c_{231} = c_{312} = c_{321}$，以及 $c_{112} = c_{121} = c_{211}$。独立参数与从 $\\{1, \\dots, P\\}$ 中抽取的三个索引的无序多重集一一对应。\n\n**方法2：描述符对称化**\n在这种方法中，我们从一个通用的、非对称的参数张量 $\\mathbf{c}'$ 开始，转而对描述符向量 $\\mathbf{x}_{ijk}$ 强制施加对称性。问题建议使用一个“作用于有序边 $(ij), (jk), (ki)$ 的对称群上的平均算子”。有序边与张量积 $g_{\\alpha}(r_{ij})\\,g_{\\beta}(r_{jk})\\,g_{\\gamma}(r_{ki})$ 中的三个位置相关联。因此，对这些边的作用就是对索引 $(\\alpha, \\beta, \\gamma)$ 的作用。\n\n让我们定义一个对称化描述符 $\\mathbf{x}^{\\text{sym}}$，其分量为：\n$$\n[\\mathbf{x}^{\\text{sym}}_{ijk}]_{\\alpha\\beta\\gamma} = \\frac{1}{|S_3|} \\sum_{\\sigma \\in S_3} g_{\\sigma(\\alpha)}(r_{ij}) g_{\\sigma(\\beta)}(r_{jk}) g_{\\sigma(\\gamma)}(r_{ki})\n$$\n能量随后计算为 $E_{ijk} = (\\mathbf{c}')^{\\top} \\mathbf{x}^{\\text{sym}}_{ijk}$：\n$$\nE_{ijk} = \\sum_{\\alpha\\beta\\gamma} c'_{\\alpha\\beta\\gamma} \\left( \\frac{1}{6} \\sum_{\\sigma \\in S_3} g_{\\sigma(\\alpha)}(r_{ij}) g_{\\sigma(\\beta)}(r_{jk}) g_{\\sigma(\\gamma)}(r_{ki}) \\right)\n$$\n我们可以重新排列求和顺序：\n$$\nE_{ijk} = \\frac{1}{6} \\sum_{\\sigma \\in S_3} \\sum_{\\alpha\\beta\\gamma} c'_{\\alpha\\beta\\gamma} g_{\\sigma(\\alpha)}(r_{ij}) g_{\\sigma(\\beta)}(r_{jk}) g_{\\sigma(\\gamma)}(r_{ki})\n$$\n让我们重新标记内部求和索引：令 $(\\alpha', \\beta', \\gamma') = \\sigma(\\alpha, \\beta, \\gamma)$，则 $(\\alpha, \\beta, \\gamma) = \\sigma^{-1}(\\alpha', \\beta', \\gamma')$。\n$$\nE_{ijk} = \\frac{1}{6} \\sum_{\\sigma \\in S_3} \\sum_{\\alpha'\\beta'\\gamma'} c'_{\\sigma^{-1}(\\alpha', \\beta', \\gamma')} g_{\\alpha'}(r_{ij}) g_{\\beta'}(r_{jk}) g_{\\gamma'}(r_{ki})\n$$\n将关于 $\\sigma$ 的和移到内部，并将 $(\\alpha', \\beta', \\gamma')$ 重命名回 $(\\alpha, \\beta, \\gamma)$：\n$$\nE_{ijk} = \\sum_{\\alpha\\beta\\gamma} \\left( \\frac{1}{6} \\sum_{\\sigma \\in S_3} c'_{\\sigma^{-1}(\\alpha, \\beta, \\gamma)} \\right) g_{\\alpha}(r_{ij}) g_{\\beta}(r_{jk}) g_{\\gamma}(r_{ki})\n$$\n这个表达式的形式为 $E_{ijk} = \\sum_{\\alpha\\beta\\gamma} c_{\\alpha\\beta\\gamma} g_{\\alpha}(r_{ij}) g_{\\beta}(r_{jk}) g_{\\gamma}(r_{ki})$，其中有效系数为：\n$$\nc_{\\alpha\\beta\\gamma} = \\frac{1}{6} \\sum_{\\sigma \\in S_3} c'_{\\sigma^{-1}(\\alpha, \\beta, \\gamma)}\n$$\n这些有效系数 $c_{\\alpha\\beta\\gamma}$ 根据构造是完全对称的。对于任何置换 $\\pi \\in S_3$，$c_{\\pi(\\alpha)\\pi(\\beta)\\pi(\\gamma)} = \\frac{1}{6} \\sum_{\\sigma \\in S_3} c'_{\\sigma^{-1}(\\pi(\\alpha), \\pi(\\beta), \\pi(\\gamma))}$。令 $\\tau = \\sigma^{-1}\\pi$，求和遍及所有 $\\tau \\in S_3$，因此 $c_{\\pi(\\alpha)\\pi(\\beta)\\pi(\\gamma)} = c_{\\alpha\\beta\\gamma}$。\n\n**等价性：**\n这两种方法是等价的，因为它们都导出了相同的能量函数形式。能量是基乘积 $g_{\\alpha}(r_{ij}) g_{\\beta}(r_{jk}) g_{\\gamma}(r_{ki})$ 的线性泛函。两种方法都将此泛函限制在对称系数张量的子空间内。\n设 $S$ 是 $\\mathbb{R}^{P^3}$ 中对称张量的子空间。方法1将参数向量 $\\mathbf{c}$ 限制在 $S$ 中。方法2取一个任意的参数向量 $\\mathbf{c}'$，并通过平均化将其有效地投影到对称子空间 $S$ 上，得到一个位于 $S$ 中的有效参数向量 $\\mathbf{c} = \\mathcal{P}(\\mathbf{c}')$。在两种情况下，所有可以表示的可能势函数的集合，都恰好是由对称张量 $\\mathbf{c} \\in S$ 参数化的势的集合。参数空间是同构的，对于用一种方法描述的任何势，在另一种方法中都有一个等价的表示。\n\n**2. 对称参数空间的维度**\n\n对系数张量 $\\mathbf{c}$ 施加完全置换对称性，要求 $c_{\\alpha\\beta\\gamma}$ 在其三个索引的任何置换下保持不变。因此，独立参数的数量是从集合 $\\{1, 2, \\dots, P\\}$ 中有放回地选择三个索引的方法数，其中选择的顺序无关紧要。这是一个计算特定大小多重集的经典组合问题。\n\n从 $n$ 个元素的集合中选择大小为 $k$ 的多重集的方法数由多重集系数给出，通常称为“隔板法”公式：\n$$\n\\left(\\!\\!{n \\choose k}\\!\\!\\right) = \\binom{n+k-1}{k}\n$$\n在我们的例子中，我们是从 $n=P$ 个可能值的集合中选择 $k=3$ 个索引（对于 $\\alpha, \\beta, \\gamma$）。所以，独立参数的数量是：\n$$\nN = \\left(\\!\\!{P \\choose 3}\\!\\!\\right) = \\binom{P+3-1}{3} = \\binom{P+2}{3}\n$$\n这可以写成展开形式：\n$$\n\\binom{P+2}{3} = \\frac{(P+2)!}{3!(P+2-3)!} = \\frac{(P+2)(P+1)P}{3 \\cdot 2 \\cdot 1} = \\frac{P(P+1)(P+2)}{6}\n$$\n\n我们也可以通过考虑索引 $\\{\\alpha, \\beta, \\gamma\\}$ 的三种情况来推导这个结果：\n1.  所有三个索引都相同 $(\\alpha=\\beta=\\gamma)$。有 $\\binom{P}{1}=P$ 种方法选择这一个索引。\n2.  恰好有两个索引相同 $(\\text{例如, } \\alpha=\\beta \\neq \\gamma)$。我们首先从 $P$ 中选择两个不同的索引，有 $\\binom{P}{2}$ 种方法。对于每对索引，比如 $\\{i, j\\}$，我们可以形成两个不同的大小为3的多重集：$\\{i,i,j\\}$ 和 $\\{i,j,j\\}$。所以，有 $2\\binom{P}{2} = P(P-1)$ 种这样的组合。\n3.  所有三个索引都不同 $(\\alpha \\neq \\beta \\neq \\gamma)$。有 $\\binom{P}{3}$ 种方法选择三个不同的索引。\n\n独立参数的总数是这些情况的总和：\n$$\nN = \\binom{P}{1} + P(P-1) + \\binom{P}{3} = P + P(P-1) + \\frac{P(P-1)(P-2)}{6}\n$$\n这可以简化为：\n$$\nN = P^2 + \\frac{P^3 - 3P^2 + 2P}{6} = \\frac{6P^2 + P^3 - 3P^2 + 2P}{6} = \\frac{P^3 + 3P^2 + 2P}{6} = \\frac{P(P+1)(P+2)}{6}\n$$\n这证实了从多重集系数公式得到的结果。施加完全置换对称性后，参数空间的维度是 $\\binom{P+2}{3}$。", "answer": "$$\\boxed{\\binom{P+2}{3}}$$", "id": "3413133"}, {"introduction": "一个势函数的优劣取决于其复现多种物理性质的能力，但这些性质的参考数据（如能量和结构）往往相互冲突，难以用单一目标函数完美拟合。本练习 ([@problem_id:3413157]) 将带你进入一个更真实的势函数拟合场景：多目标优化。你将通过编写代码，学习如何同时拟合一个Lennard-Jones类型的对势函数以匹配量子化学计算的能量曲线和模拟液体的径向分布函数，并利用帕累托前沿（Pareto front）这一强大工具来量化和分析不同目标之间的内在权衡关系。", "problem": "给定一个形式为 $U(r) = \\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]$ 的双参数 Lennard-Jones 型对势，您需要将其同时拟合到两种类型的数据：量子二聚体能量和一个由径向分布函数近似的结构可观测量。科学背景是分子动力学参数化，旨在协调第一性原理二聚体能量学与结构可观测量。您的任务是构建一个独立的程序，该程序能从已知的基准实况参数生成合成数据，并执行多目标拟合，通过帕累托前沿分析其权衡关系。\n\n需要使用的基本依据和定义：\n- 使用上述 $U(r)$ 直接给出的、间距为 $r$ 的二聚体对势能的定义。\n- 令 $E_{\\mathrm{DFT}}(r)$ 表示在 $r$ 处计算的量子参考二聚体能量。假设这是带有微小观测噪声的“基准实况”，并对应于与 $U(r)$ 相同的解析形式，但具有已知的基准实况参数 $(\\epsilon^\\star, \\sigma^\\star)$。\n- 使用径向分布函数 $g(r)$ 的定义，即在间距 $r$ 处观测到的对密度与理想气体对密度的比值。在低密度或高温近似下，假设 $g(r) \\approx \\exp(-\\beta U(r))$，其中 $\\beta = \\frac{1}{k_{\\mathrm{B}} T}$ 且 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。这是在所述近似下，将平均力势等同于 $U(r)$ 得出的结论。\n- 使用均方根误差 (RMSE) 来量化二聚体能量和 $g(r)$ 的失配。对于一组样本 $\\{x_i\\}_{i=1}^N$，其模型预测为 $m_i$，参考值为 $y_i$，RMSE 为 $\\sqrt{\\frac{1}{N}\\sum_{i=1}^N (m_i - y_i)^2}$。\n- 在以最小化为目标的多目标优化中，如果参数对 $(\\epsilon_1,\\sigma_1)$ 在两个目标上的值均小于或等于 $(\\epsilon_2,\\sigma_2)$ 处的值，并且至少有一个目标严格更小，则称 $(\\epsilon_1,\\sigma_1)$ 支配 $(\\epsilon_2,\\sigma_2)$。帕累托前沿是非支配点的集合。\n- 使用二维超体积指标，其参考点等于候选网格上目标值的坐标最大值。对于待最小化的目标 $f_1$ 和 $f_2$ 以及参考点 $(R_1,R_2)$，被支配超体积是由每个帕累托最优点所张成的矩形 $[f_1,R_1]\\times[f_2,R_2]$ 的并集面积。在二维情况下，可通过按 $f_1$ 升序对帕累托前沿排序，并累加由 $f_2$ 的连续减小所定义的矩形面积来精确计算。\n\n数据生成协议：\n- 使用基准实况参数 $(\\epsilon^\\star, \\sigma^\\star) = (\\epsilon^\\star, \\sigma^\\star) = ($0.5$, $3.4$)$，单位如下文规定。\n- 通过在指定范围内对 $r$ 进行采样，并计算 $E_{\\mathrm{DFT}}(r) = U(r; \\epsilon^\\star,\\sigma^\\star) + \\eta_E$ 来生成合成二聚体能量，其中 $\\eta_E$ 是具有指定标准差的零均值高斯噪声。\n- 通过在指定范围内对 $r$ 进行采样，并计算 $g_{\\mathrm{exp}}(r) = \\max\\{0, \\exp(-\\beta U(r; \\epsilon^\\star,\\sigma^\\star)) + \\eta_g\\}$ 来生成合成结构数据，其中 $\\eta_g$ 是具有指定标准差的零均值高斯噪声，$\\max$ 操作强制非负性。\n\n目标：\n- 对于任何候选 $(\\epsilon,\\sigma)$，将能量失配定义为 $f_1(\\epsilon,\\sigma) = \\mathrm{RMSE}(U(r; \\epsilon,\\sigma), E_{\\mathrm{DFT}}(r))$，在二聚体能量采样点上计算。\n- 将结构失配定义为 $f_2(\\epsilon,\\sigma) = \\mathrm{RMSE}(\\exp(-\\beta U(r; \\epsilon,\\sigma)), g_{\\mathrm{exp}}(r))$，在结构采样点上计算。\n\n候选搜索域与离散化：\n- 在 $(\\epsilon,\\sigma)$ 值的矩形网格上进行搜索：\n  - $\\epsilon \\in [\\, $0.3$,\\, $0.8$\\,]$，包含 $31$ 个等间距网格点。\n  - $\\sigma \\in [\\, $3.0$,\\, $3.8$\\,]$，包含 $31$ 个等间距网格点。\n- 对于能量数据，使用 $r \\in [\\, $2.6$,\\, $7.0$\\,]$，在 $50$ 个等间距点上采样。\n- 对于结构数据，使用 $r \\in [\\, $2.6$,\\, $9.0$\\,]$，在 $150$ 个等间距点上采样。\n\n单位：\n- 能量单位必须是千焦/摩尔 ($\\mathrm{kJ/mol}$)。\n- 长度单位必须是埃 ($\\mathrm{\\AA}$)。\n- 温度单位必须是开尔文 ($\\mathrm{K}$)。\n- 使用 $k_{\\mathrm{B}} = $0.008314462618$\\, \\mathrm{kJ/(mol\\,K)}$。\n- 所有输出必须是数值；任何类能量的量应被理解为单位是 $\\mathrm{kJ/mol}$，而 $g(r)$ 是无量纲的。\n\n测试套件：\n每个测试用例指定 $(T, \\sigma_E, \\sigma_g, \\text{seed})$，其中 $T$ 是温度，$\\sigma_E$ 是能量噪声的标准差，$\\sigma_g$ 是 $g(r)$ 噪声的标准差，$\\text{seed}$ 是用于可复现性的随机种子。使用以下三种情况：\n- 情况 1：$(T, \\sigma_E, \\sigma_g, \\text{seed}) = ($120$, $0.01$, $0.02$, $1$)$.\n- 情况 2：$(T, \\sigma_E, \\sigma_g, \\text{seed}) = ($300$, $0.02$, $0.01$, $2$)$.\n- 情况 3：$(T, \\sigma_E, \\sigma_g, \\text{seed}) = ($60$, $0.005$, $0.05$, $3$)$.\n\n对于每个测试用例，您的程序必须：\n- 从 $(\\epsilon^\\star, \\sigma^\\star)$ 和指定的 $(T, \\sigma_E, \\sigma_g)$ 及种子生成合成的 $E_{\\mathrm{DFT}}(r)$ 和 $g_{\\mathrm{exp}}(r)$。\n- 在指定的 $(\\epsilon,\\sigma)$ 网格上评估 $f_1$ 和 $f_2$。\n- 计算非支配点的帕累托前沿。\n- 使用由 $R_1 = \\max f_1$ 和 $R_2 = \\max f_2$（在该测试用例的整个网格上取最大值）定义的参考点 $(R_1,R_2)$ 计算二维超体积指标。\n- 分别确定每个单独目标的最小化器：\n  - $(\\epsilon_{\\min f_1}, \\sigma_{\\min f_1}) = \\arg\\min f_1(\\epsilon,\\sigma)$。\n  - $(\\epsilon_{\\min f_2}, \\sigma_{\\min f_2}) = \\arg\\min f_2(\\epsilon,\\sigma)$。\n\n最终输出格式：\n- 对于每个测试用例，输出一个包含以下六个条目的列表：\n  - 帕累托最优点数量，为整数。\n  - 被支配超体积，为浮点数，四舍五入到 $6$ 位小数（单位应理解为 $\\mathrm{kJ/mol}$）。\n  - $\\epsilon_{\\min f_1}$，四舍五入到 $6$ 位小数（单位为 $\\mathrm{kJ/mol}$）。\n  - $\\sigma_{\\min f_1}$，四舍五入到 $6$ 位小数（单位为 $\\mathrm{\\AA}$）。\n  - $\\epsilon_{\\min f_2}$，四舍五入到 $6$ 位小数（单位为 $\\mathrm{kJ/mol}$）。\n  - $\\sigma_{\\min f_2}$，四舍五入到 $6$ 位小数（单位为 $\\mathrm{\\AA}$）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个元素对应一个测试用例，并且本身也是一个按上述顺序排列的列表。例如，一个有效的输出形状是 $[\\,[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]\\,]$。", "solution": "用户提供的问题是有效的。它在科学上基于统计力学和分子建模的原理，问题陈述清晰，提供了所有必要信息，并提出了一个明确、客观且可验证的计算任务。该问题要求通过对两种合成数据源（二聚体相互作用能和径向分布函数）进行多目标优化来参数化 Lennard-Jones 对势。解决方案涉及在参数空间上进行网格搜索，识别帕累托最优参数集，并使用超体积指标对此集合进行分析。\n\n在此，将给出一个详细的、分步的解决方案，概述其数学公式和算法流程。\n\n### 1. 数学和物理公式\n\n问题的核心在于将模型势拟合到参考数据。关键组成部分定义如下：\n\n**Lennard-Jones 势：** 一对相距为 $r$ 的粒子之间的相互作用由双参数 Lennard-Jones (LJ) 12-6 势 $U(r)$ 描述。该函数由势阱深度 $\\epsilon$ 和粒子间势为零时的有限距离 $\\sigma$ 参数化。\n\n$$\nU(r; \\epsilon, \\sigma) = 4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\n$$\n\n然而，问题陈述提供了一个略有不同但等价的形式：\n\n$$\nU(r; \\epsilon, \\sigma) = \\epsilon\\left[\\left(\\frac{\\sigma_{min}}{r}\\right)^{12} - 2\\left(\\frac{\\sigma_{min}}{r}\\right)^6\\right]\n$$\n\n其中 $\\sigma_{min} = 2^{1/6}\\sigma$ 是势能最小值的位置。问题中提供的形式是 $U(r) = \\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]$。这不是 LJ 势的标准形式，因为其最小能量不是 $-\\epsilon$，零点也不在 $\\sigma$。对于这种非标准形式，最小值出现在 $r_{min} = (2)^{1/6}\\sigma$ 处，势阱深度为 $U(r_{min}) = -\\frac{\\epsilon}{4}$。零点在 $r=\\sigma$ 处。我们将严格遵守指定的形式：\n\n$$\nU(r; \\epsilon, \\sigma) = \\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\n$$\n\n**合成数据生成：**\n我们基于基准实况参数 $(\\epsilon^\\star, \\sigma^\\star) = (0.5 \\, \\mathrm{kJ/mol}, 3.4 \\, \\mathrm{\\AA})$ 生成两组合成“实验”数据。\n\n1.  **二聚体能量：** 量子参考二聚体能量 $E_{\\mathrm{DFT}}(r)$ 是通过在基准实况参数下评估势能并添加高斯噪声来合成的。对于一组距离 $\\{r_i\\}$，数据点为：\n    $$\n    E_{\\mathrm{DFT}}(r_i) = U(r_i; \\epsilon^\\star, \\sigma^\\star) + \\eta_E\n    $$\n    其中 $\\eta_E$ 是从均值为 $0$、标准差为 $\\sigma_E$ 的正态分布中抽取的随机变量。\n\n2.  **结构数据：** 径向分布函数 $g(r)$ 在低密度极限下近似为 $g(r) \\approx \\exp(-\\beta U(r))$，其中 $\\beta = (k_{\\mathrm{B}} T)^{-1}$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是温度。合成实验数据 $g_{\\mathrm{exp}}(r)$ 生成如下：\n    $$\n    g_{\\mathrm{exp}}(r_i) = \\max\\{0, \\exp(-\\beta U(r_i; \\epsilon^\\star, \\sigma^\\star)) + \\eta_g\\}\n    $$\n    其中 $\\eta_g$ 是从均值为 $0$、标准差为 $\\sigma_g$ 的正态分布中抽取的随机变量。$\\max\\{0, \\dots\\}$ 操作确保了 $g(r)$ 的物理非负性。\n\n**目标函数：**\n目标是找到能够同时最好地再现这两组数据的参数 $(\\epsilon, \\sigma)$。失配通过每个目标的均方根误差 (RMSE) 来量化。对于一组具有模型预测值 $m_i$ 和参考值 $y_i$ 的 $N$ 个数据点，RMSE 为：\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N (m_i - y_i)^2}\n$$\n\n需要最小化的两个目标函数是：\n1.  **能量失配 ($f_1$)：** 模型势 $U(r; \\epsilon, \\sigma)$ 与合成二聚体能量 $E_{\\mathrm{DFT}}(r)$ 之间的 RMSE。\n    $$\n    f_1(\\epsilon, \\sigma) = \\mathrm{RMSE}(U(r; \\epsilon, \\sigma), E_{\\mathrm{DFT}}(r))\n    $$\n2.  **结构失配 ($f_2$)：** 模型预测的 $g(r)$ 与合成结构数据 $g_{\\mathrm{exp}}(r)$ 之间的 RMSE。\n    $$\n    f_2(\\epsilon, \\sigma) = \\mathrm{RMSE}(\\exp(-\\beta U(r; \\epsilon, \\sigma)), g_{\\mathrm{exp}}(r))\n    $$\n\n### 2. 算法流程\n\n通过对每个测试用例执行系统的流程来找到解决方案。\n\n**网格搜索：**\n定义一个离散的候选参数网格：$\\epsilon \\in [0.3, 0.8]$ 和 $\\sigma \\in [3.0, 3.8]$，每个维度都有 $31$ 个等间距点。这就创建了一个包含 $961$ 个候选对 $(\\epsilon_i, \\sigma_j)$ 的 $31 \\times 31$ 网格。对于每一对参数，计算目标函数 $f_1(\\epsilon_i, \\sigma_j)$ 和 $f_2(\\epsilon_i, \\sigma_j)$。\n\n**帕累托前沿识别：**\n在多目标优化中，通常没有单一解能同时最小化所有目标。因此，我们寻求帕累托最优解的集合。如果参数集 $p_1 = (\\epsilon_1, \\sigma_1)$ 在所有目标上的值都优于或等于另一参数集 $p_2 = (\\epsilon_2, \\sigma_2)$，并且在至少一个目标上严格更优，则称 $p_1$ **支配** $p_2$。对于我们的最小化问题，这意味着：\n$$\n(f_1(p_1) \\le f_1(p_2) \\land f_2(p_1) \\le f_2(p_2)) \\land (f_1(p_1)  f_1(p_2) \\lor f_2(p_1)  f_2(p_2))\n$$\n**帕累托前沿**是所有非支配参数集的集合。我们通过对网格上所有 $961$ 个点进行两两比较来识别该集合。对于每个点，我们检查它是否被任何其他点支配。如果不是，它就属于帕累托前沿。\n\n**单目标最小化器：**\n作为分析的一部分，我们独立地确定最小化每个目标函数的参数：\n- $(\\epsilon_{\\min f_1}, \\sigma_{\\min f_1}) = \\arg\\min_{(\\epsilon, \\sigma)} f_1(\\epsilon, \\sigma)$\n- $(\\epsilon_{\\min f_2}, \\sigma_{\\min f_2}) = \\arg\\min_{(\\epsilon, \\sigma)} f_2(\\epsilon, \\sigma)$\n这些是通过在计算出的 $f_1$ 和 $f_2$ 目标数组中定位最小值来找到的。\n\n**超体积指标计算：**\n超体积指标衡量由帕累托前沿支配的目标空间的大小。它提供一个单一的标量值来量化前沿的质量。参考点定义为 $(R_1, R_2)$，其中 $R_1 = \\max f_1$ 和 $R_2 = \\max f_2$ 是在整个网格上的最大值。\n对于一个二维问题，超体积可以通过对帕累托最优点进行排序并求和不相交矩形的面积来计算。假设 $k$ 个帕累托最优目标对按其第一个分量 $f_1$ 升序排列：$(f_{1,1}, f_{2,1}), (f_{1,2}, f_{2,2}), \\dots, (f_{1,k}, f_{2,k})$。由于帕累托前沿的性质，这意味着 $f_{2,1} > f_{2,2} > \\dots > f_{2,k}$。总的被支配超体积 $H$ 计算为一系列垂直条带的面积之和：\n$$\nH = \\sum_{i=1}^{k-1} (f_{1,i+1} - f_{1,i})(R_2 - f_{2,i}) + (R_1 - f_{1,k})(R_2 - f_{2,k})\n$$\n该公式将被支配区域划分为一系列矩形并求和它们的面积。\n\n通过对每个测试用例遵循这一全面的流程，我们可以生成所需的输出，从而为该参数化问题中的权衡提供完整的分析。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-objective optimization problem for fitting a Lennard-Jones potential.\n    \"\"\"\n    # Fixed parameters from problem statement\n    EPS_STAR, SIG_STAR = 0.5, 3.4  # Ground-truth parameters (kJ/mol, A)\n    KB = 0.008314462618  # Boltzmann constant in kJ/(mol K)\n\n    # Search domain and discretization\n    eps_grid = np.linspace(0.3, 0.8, 31)\n    sig_grid = np.linspace(3.0, 3.8, 31)\n    \n    # Sampling points for r\n    r_energy = np.linspace(2.6, 7.0, 50)\n    r_struct = np.linspace(2.6, 9.0, 150)\n\n    # Test suite\n    test_cases = [\n        {'T': 120, 'sigma_E': 0.01, 'sigma_g': 0.02, 'seed': 1},\n        {'T': 300, 'sigma_E': 0.02, 'sigma_g': 0.01, 'seed': 2},\n        {'T': 60, 'sigma_E': 0.005, 'sigma_g': 0.05, 'seed': 3},\n    ]\n\n    all_results = []\n\n    def lj_potential(r, eps, sig):\n        \"\"\"Lennard-Jones potential as specified in the problem.\"\"\"\n        ratio = sig / r\n        return eps * (ratio**12 - ratio**6)\n\n    def rmse(model, data):\n        \"\"\"Calculates the Root-Mean-Square Error.\"\"\"\n        return np.sqrt(np.mean((model - data)**2))\n\n    for case in test_cases:\n        T, sigma_E, sigma_g, seed = case['T'], case['sigma_E'], case['sigma_g'], case['seed']\n        beta = 1.0 / (KB * T)\n        rng = np.random.default_rng(seed)\n\n        # --- 1. Generate synthetic data ---\n        # Dimer energies\n        true_energy = lj_potential(r_energy, EPS_STAR, SIG_STAR)\n        noise_E = rng.normal(0, sigma_E, size=len(r_energy))\n        exp_energy = true_energy + noise_E\n\n        # Structural data (g(r))\n        true_g_r = np.exp(-beta * lj_potential(r_struct, EPS_STAR, SIG_STAR))\n        noise_g = rng.normal(0, sigma_g, size=len(r_struct))\n        exp_g_r = np.maximum(0, true_g_r + noise_g)\n        \n        # --- 2. Grid search and objective evaluation ---\n        obj_f1 = np.zeros((len(eps_grid), len(sig_grid)))\n        obj_f2 = np.zeros((len(eps_grid), len(sig_grid)))\n        \n        grid_points = []\n\n        for i, eps in enumerate(eps_grid):\n            for j, sig in enumerate(sig_grid):\n                # Calculate f1 (energetic misfit)\n                model_energy = lj_potential(r_energy, eps, sig)\n                f1_val = rmse(model_energy, exp_energy)\n                obj_f1[i, j] = f1_val\n\n                # Calculate f2 (structural misfit)\n                model_g_r = np.exp(-beta * lj_potential(r_struct, eps, sig))\n                f2_val = rmse(model_g_r, exp_g_r)\n                obj_f2[i, j] = f2_val\n                \n                grid_points.append({'eps': eps, 'sig': sig, 'f1': f1_val, 'f2': f2_val})\n\n        # --- 3. Analyze results ---\n        # Find individual minimizers\n        min_f1_idx = np.unravel_index(np.argmin(obj_f1), obj_f1.shape)\n        eps_min_f1 = eps_grid[min_f1_idx[0]]\n        sig_min_f1 = sig_grid[min_f1_idx[1]]\n        \n        min_f2_idx = np.unravel_index(np.argmin(obj_f2), obj_f2.shape)\n        eps_min_f2 = eps_grid[min_f2_idx[0]]\n        sig_min_f2 = sig_grid[min_f2_idx[1]]\n\n        # Find Pareto front\n        pareto_front = []\n        for p1 in grid_points:\n            is_dominated = False\n            for p2 in grid_points:\n                if p1 is p2:\n                    continue\n                # Check if p2 dominates p1\n                if p2['f1'] = p1['f1'] and p2['f2'] = p1['f2']:\n                    if p2['f1']  p1['f1'] or p2['f2']  p1['f2']:\n                        is_dominated = True\n                        break\n            if not is_dominated:\n                pareto_front.append(p1)\n\n        # Calculate hypervolume indicator\n        R1 = np.max(obj_f1)\n        R2 = np.max(obj_f2)\n        \n        # Sort Pareto front by f1 ascending\n        pareto_front.sort(key=lambda p: p['f1'])\n        \n        hypervolume = 0.0\n        if pareto_front:\n            # Using the formula H = sum_{i=1 to k-1} (f1_{i+1} - f1_i)(R2 - f2_i) + (R1 - f1_k)(R2 - f2_k)\n            pf_f1 = [p['f1'] for p in pareto_front]\n            pf_f2 = [p['f2'] for p in pareto_front]\n            k = len(pareto_front)\n            \n            # Sum areas of rectangles between adjacent points\n            for i in range(k - 1):\n                hypervolume += (pf_f1[i+1] - pf_f1[i]) * (R2 - pf_f2[i])\n\n            # Area of the rectangle for the last (rightmost) point\n            hypervolume += (R1 - pf_f1[k-1]) * (R2 - pf_f2[k-1])\n\n        # --- 4. Store results for this case ---\n        case_results = [\n            len(pareto_front),\n            round(hypervolume, 6),\n            round(eps_min_f1, 6),\n            round(sig_min_f1, 6),\n            round(eps_min_f2, 6),\n            round(sig_min_f2, 6)\n        ]\n        all_results.append(case_results)\n\n    # --- 5. Format and print final output ---\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3413157"}, {"introduction": "获得一组“最佳”拟合参数只是参数化过程的开始，而非结束。一个关键的后续问题是：这些参数的确定性有多高？数据是否能够唯一地约束模型中的每一个参数？本练习 ([@problem_id:3413114]) 将介绍一种源自统计推断的强大诊断技术——费雪信息矩阵（Fisher Information Matrix, FIM），用于分析模型的“草率性”（sloppiness）和参数的可辨识性。通过这个编程实践，你将学会如何利用FIM的特征值谱和克拉默-拉奥下界（Cramér–Rao lower bound）来评估参数拟合的可靠性，从而深刻理解模型、数据和参数不确定性之间的复杂关系。", "problem": "考虑一个用于分子动力学的双位点二聚体模型，该模型用于根据量子和实验的能量与响应数据拟合参数。每个构型由一对A型和B型位点组成，它们之间的距离为 $r_k$，并受到大小为 $E_k$ 的均匀外电场的作用。构型 $k$ 的模型总能量是 van der Waals (vdW) Lennard–Jones 相互作用与在线性响应下带有 Thole-like 屏蔽的各向同性极化贡献之和，\n$$\n\\mathcal{E}_k(\\boldsymbol{\\theta}) \\equiv \\mathcal{E}_{\\mathrm{LJ}}(r_k;\\epsilon,\\sigma) + \\mathcal{E}_{\\mathrm{pol}}(r_k,E_k;\\alpha_A,\\alpha_B,a),\n$$\n其中参数矢量为 $\\boldsymbol{\\theta} = (\\epsilon,\\sigma,\\alpha_A,\\alpha_B,a)$。Lennard–Jones 相互作用为\n$$\n\\mathcal{E}_{\\mathrm{LJ}}(r;\\epsilon,\\sigma) = 4\\,\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right],\n$$\n而外电场下的极化能通过带有屏蔽有效极化率的线性响应来建模，\n$$\n\\mathcal{E}_{\\mathrm{pol}}(r,E;\\alpha_A,\\alpha_B,a) = -\\frac{1}{2}\\,E^2\\;\\frac{\\alpha_A+\\alpha_B}{1 + a\\,r^{-3}}.\n$$\n这种 $\\mathcal{E}_{\\mathrm{pol}}$ 形式是一种简化的各向同性平均场近似，它通过一个与距离相关的、与 $r^{-3}$ 成正比的屏蔽效应，捕捉了相互极化的主导阶衰减，这与偶极-偶极耦合是一致的。\n\n假设测量噪声为独立同分布的高斯噪声，其方差为 $\\sigma_n^2$，并采用高斯似然下的最大似然估计 (MLE) 作为目标。对于给定的参数矢量 $\\boldsymbol{\\theta}$，高斯噪声下的 Fisher 信息矩阵 (FIM) $\\mathbf{I}(\\boldsymbol{\\theta})$ 定义为\n$$\nI_{ij}(\\boldsymbol{\\theta}) \\equiv \\mathbb{E}\\left[\\partial_{\\theta_i} \\log L(\\boldsymbol{\\theta})\\;\\partial_{\\theta_j} \\log L(\\boldsymbol{\\theta})\\right],\n$$\n其中 $L(\\boldsymbol{\\theta})$ 是似然函数。在所述的高斯模型下，这可以简化为梯度外積的数据求和形式，\n$$\n\\mathbf{I}(\\boldsymbol{\\theta}) = \\frac{1}{\\sigma_n^2}\\sum_{k} \\left(\\nabla_{\\boldsymbol{\\theta}} \\mathcal{E}_k(\\boldsymbol{\\theta})\\right)\\left(\\nabla_{\\boldsymbol{\\theta}} \\mathcal{E}_k(\\boldsymbol{\\theta})\\right)^{\\top}.\n$$\n\n您的程序必须为下面的每个测试用例计算 Fisher 信息矩阵 $\\mathbf{I}(\\boldsymbol{\\theta})$，通过条件数诊断模型的粗疏性 (sloppiness)\n$$\n\\kappa(\\mathbf{I}) \\equiv \\frac{\\lambda_{\\max}}{\\lambda_{\\min}},\n$$\n其中 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 分别是 $\\mathbf{I}$ 的最大和最小特征值，并使用近似的 Cramér–Rao 下界协方差矩阵 $\\mathbf{C} \\approx \\mathbf{I}^{-1}$ 来评估参数的可识别性。当 $\\mathbf{I}$ 是奇异或近奇异矩阵时，使用一个小的 Tikhonov 正则化参数 $\\lambda_{\\mathrm{reg}}$ 来定义\n$$\n\\mathbf{C} \\approx \\left(\\mathbf{I} + \\lambda_{\\mathrm{reg}}\\mathbf{I}_5\\right)^{-1},\n$$\n其中 $\\mathbf{I}_5$ 是 $5\\times 5$ 的单位矩阵。定义参数 $\\theta_i$ 的相对不确定度为\n$$\n\\rho_i \\equiv \\frac{\\sqrt{C_{ii}}}{|\\theta_i|}.\n$$\n如果参数满足 $\\rho_i \\le \\tau$（其中 $\\tau$ 为阈值），则该参数被认为是可识别的。\n\n将正则化参数设置为 $\\lambda_{\\mathrm{reg}} = 10^{-12}$，可识别性阈值设置为 $\\tau = 0.5$。对于条件数，如果最小特征值满足 $\\lambda_{\\min} \\le 10^{-12}$，则将矩阵视为奇异矩阵并设置 $\\kappa(\\mathbf{I}) = +\\infty$；否则，使用比率 $\\lambda_{\\max}/\\lambda_{\\min}$。\n\n基于上述定义，为 $\\boldsymbol{\\theta}$ 中的每个参数从第一性原理计算梯度 $\\nabla_{\\boldsymbol{\\theta}}\\mathcal{E}_k$，然后构建 $\\mathbf{I}(\\boldsymbol{\\theta})$。\n\n测试套件：\n- 情况 1 (通用情况，信息丰富的电场和变化的距离):\n    - 参数: $\\boldsymbol{\\theta} = (\\epsilon,\\sigma,\\alpha_A,\\alpha_B,a) = (0.20, 3.50, 1.20, 0.80, 0.30)$。\n    - 距离: $[3.00, 3.50, 4.00, 4.50, 5.00]$。\n    - 电场: $[0.30, 0.50, 0.70, 0.90, 1.10]$。\n    - 噪声方差: $\\sigma_n^2 = 0.01$。\n- 情况 2 (边界情况，无电场；极化参数不可观测):\n    - 参数: $\\boldsymbol{\\theta} = (0.20, 3.50, 1.20, 0.80, 0.30)$。\n    - 距离: $[3.00, 3.50, 4.00, 4.50, 5.00]$。\n    - 电场: $[0.00, 0.00, 0.00, 0.00, 0.00]$。\n    - 噪声方差: $\\sigma_n^2 = 0.01$。\n- 情况 3 (边缘情况，重复的距离；解析 van der Waals 参数的能力降低):\n    - 参数: $\\boldsymbol{\\theta} = (0.20, 3.50, 1.20, 0.80, 0.30)$。\n    - 距离: $[4.00, 4.00, 4.00, 4.00, 4.00]$。\n    - 电场: $[0.30, 0.50, 0.70, 0.90, 1.10]$。\n    - 噪声方差: $\\sigma_n^2 = 0.02$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表：$[\\kappa_1,\\kappa_2,\\kappa_3,N_1,N_2,N_3]$，其中 $\\kappa_j$ 是情况 $j$ 的条件数（按规定，奇异时使用 $+\\infty$），$N_j$ 是在阈值 $\\tau$ 下情况 $j$ 中可识别参数的整数计数。\n\n所有数学推导必须从上面提供的基本定义开始。输出值为无量纲；无需报告物理单位。代码必须是一个完整、可运行的程序，并且不得读取任何输入或文件。", "solution": "目标是为给定的物理模型计算 Fisher 信息矩阵 (FIM)，使用条件数诊断参数的粗疏性 (sloppiness)，并使用 Cramér–Rao 下界评估参数的可识别性。该分析将针对三个不同的测试用例进行。\n\n对于位点间距为 $r_k$ 和外场为 $E_k$ 的构型 $k$，其模型能量由下式给出：\n$$\n\\mathcal{E}_k(\\boldsymbol{\\theta}) = \\mathcal{E}_{\\mathrm{LJ}}(r_k;\\epsilon,\\sigma) + \\mathcal{E}_{\\mathrm{pol}}(r_k,E_k;\\alpha_A,\\alpha_B,a)\n$$\n其中参数矢量为 $\\boldsymbol{\\theta} = (\\epsilon,\\sigma,\\alpha_A,\\alpha_B,a)$。两个能量分量是：\n$$\n\\mathcal{E}_{\\mathrm{LJ}}(r;\\epsilon,\\sigma) = 4\\,\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n$$\n$$\n\\mathcal{E}_{\\mathrm{pol}}(r,E;\\alpha_A,\\alpha_B,a) = -\\frac{1}{2}\\,E^2\\;\\frac{\\alpha_A+\\alpha_B}{1 + a\\,r^{-3}}\n$$\n\n第一步是通过对 $\\boldsymbol{\\theta}$ 中的五个参数分别求偏导数来计算能量函数 $\\nabla_{\\boldsymbol{\\theta}}\\mathcal{E}_k(\\boldsymbol{\\theta})$ 的梯度。对于单个构型，为清晰起見省略下标 $k$：\n\n1.  **关于 $\\epsilon$ 的导数**：只有 Lennard-Jones 项依赖于 $\\epsilon$。\n    $$\n    \\frac{\\partial\\mathcal{E}}{\\partial\\epsilon} = \\frac{\\partial}{\\partial\\epsilon} \\left(4\\,\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\\right) = 4\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n    $$\n\n2.  **关于 $\\sigma$ 的导数**：只有 Lennard-Jones 项依赖于 $\\sigma$。\n    $$\n    \\frac{\\partial\\mathcal{E}}{\\partial\\sigma} = \\frac{\\partial}{\\partial\\sigma} \\left(4\\,\\epsilon\\left[\\sigma^{12}r^{-12} - \\sigma^{6}r^{-6}\\right]\\right) = 4\\,\\epsilon\\left[12\\sigma^{11}r^{-12} - 6\\sigma^{5}r^{-6}\\right] = \\frac{24\\epsilon}{\\sigma}\\left[2\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6}\\right]\n    $$\n\n3.  **关于 $\\alpha_A$ 的导数**：只有极化项依赖于 $\\alpha_A$。\n    $$\n    \\frac{\\partial\\mathcal{E}}{\\partial\\alpha_A} = \\frac{\\partial}{\\partial\\alpha_A}\\left(-\\frac{1}{2}\\,E^2\\;\\frac{\\alpha_A+\\alpha_B}{1 + a\\,r^{-3}}\\right) = -\\frac{1}{2}\\,E^2\\;\\frac{1}{1 + a\\,r^{-3}}\n    $$\n\n4.  **关于 $\\alpha_B$ 的导数**：只有极化项依赖于 $\\alpha_B$。\n    $$\n    \\frac{\\partial\\mathcal{E}}{\\partial\\alpha_B} = \\frac{\\partial}{\\partial\\alpha_B}\\left(-\\frac{1}{2}\\,E^2\\;\\frac{\\alpha_A+\\alpha_B}{1 + a\\,r^{-3}}\\right) = -\\frac{1}{2}\\,E^2\\;\\frac{1}{1 + a\\,r^{-3}}\n    $$\n    关键要注意的是 $\\frac{\\partial\\mathcal{E}}{\\partial\\alpha_A} = \\frac{\\partial\\mathcal{E}}{\\partial\\alpha_B}$。这意味着存在结构性不可识别性；模型只能解析总和 $\\alpha_A + \\alpha_B$，而不能解析它们各自的值。\n\n5.  **关于 $a$ 的导数**：只有极化项依赖于 $a$。\n    $$\n    \\frac{\\partial\\mathcal{E}}{\\partial a} = -\\frac{1}{2}\\,E^2(\\alpha_A+\\alpha_B)\\frac{\\partial}{\\partial a}\\left( (1 + a\\,r^{-3})^{-1} \\right) = \\frac{1}{2}\\,E^2(\\alpha_A+\\alpha_B)\\frac{r^{-3}}{(1 + a\\,r^{-3})^2}\n    $$\n\n有了这些解析导数，我们可以为每个数据构型 $k$ 构建梯度矢量 $\\mathbf{g}_k = \\nabla_{\\boldsymbol{\\theta}}\\mathcal{E}_k(\\boldsymbol{\\theta})$。然后，通过对所有 $k$ 个数据点的这些梯度矢量的外积求和，并按噪声方差 $\\sigma_n^2$ 的倒数进行缩放，来构建 Fisher 信息矩阵 (FIM)：\n$$\n\\mathbf{I}(\\boldsymbol{\\theta}) = \\frac{1}{\\sigma_n^2}\\sum_{k} \\mathbf{g}_k \\mathbf{g}_k^{\\top}\n$$\n\n计算出 $5 \\times 5$ 的 FIM $\\mathbf{I}(\\boldsymbol{\\theta})$ 后，我们进行分析：\n\n**粗疏性 (Sloppiness) 诊断**：我们计算对称矩阵 $\\mathbf{I}$ 的特征值。设最大和最小特征值分别为 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$。条件数为 $\\kappa(\\mathbf{I}) = \\lambda_{\\max}/\\lambda_{\\min}$。如果 $\\lambda_{\\min}$ 低于数值阈值（$\\lambda_{\\min} \\le 10^{-12}$），则该矩阵被认为是奇异的，条件数取为无穷大，即 $\\kappa(\\mathbf{I}) = +\\infty$。非常大或无穷大的条件数表示一个“sloppy”（粗疏）模型，其中至少有一个参数组合受数据的约束很弱。$\\alpha_A$ 和 $\\alpha_B$ 之间的结构性不可识别性保证了只要电场不为零，FIM 就将是奇异的，从而导致无穷大的条件数。\n\n**参数可识别性**：FIM 的逆矩阵近似了参数估计协方差矩阵的 Cramér–Rao 下界，即 $\\mathbf{C} \\approx \\mathbf{I}^{-1}$。为了处理奇异或近奇异的 FIM，我们使用 Tikhonov 正則化：\n$$\n\\mathbf{C} \\approx \\left(\\mathbf{I} + \\lambda_{\\mathrm{reg}}\\mathbf{I}_5\\right)^{-1}\n$$\n其中 $\\lambda_{\\mathrm{reg}} = 10^{-12}$。该矩阵的对角元素 $C_{ii}$ 代表参数 $\\theta_i$ 估计的方差。每个参数的相对不确定度定义为：\n$$\n\\rho_i = \\frac{\\sqrt{C_{ii}}}{|\\theta_i|}\n$$\n如果参数 $\\theta_i$ 的相对不确定度低于指定阈值，即 $\\rho_i \\le \\tau=0.5$，则该参数被认为是可识别的。\n\n程序为所提供的三个测试用例实现了这整个流程——计算梯度、构建 FIM 以及执行后续分析。然后，将包含每个情况 $j$ 的条件数 $\\kappa_j$ 和可识别参数计数 $N_j$ 的结果格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the Fisher Information Matrix (FIM), condition number,\n    and parameter identifiability for three different scenarios of a\n    two-site dimer model.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case 1 (general)\",\n            \"params\": (0.20, 3.50, 1.20, 0.80, 0.30),\n            \"distances\": [3.00, 3.50, 4.00, 4.50, 5.00],\n            \"fields\": [0.30, 0.50, 0.70, 0.90, 1.10],\n            \"noise_var\": 0.01\n        },\n        {\n            \"name\": \"Case 2 (no field)\",\n            \"params\": (0.20, 3.50, 1.20, 0.80, 0.30),\n            \"distances\": [3.00, 3.50, 4.00, 4.50, 5.00],\n            \"fields\": [0.00, 0.00, 0.00, 0.00, 0.00],\n            \"noise_var\": 0.01\n        },\n        {\n            \"name\": \"Case 3 (repeated distance)\",\n            \"params\": (0.20, 3.50, 1.20, 0.80, 0.30),\n            \"distances\": [4.00, 4.00, 4.00, 4.00, 4.00],\n            \"fields\": [0.30, 0.50, 0.70, 0.90, 1.10],\n            \"noise_var\": 0.02\n        }\n    ]\n\n    lambda_reg = 1e-12\n    identifiability_threshold = 0.5\n    singularity_threshold = 1e-12\n\n    def calculate_gradient(theta, r, E):\n        \"\"\"\n        Calculates the gradient of the energy function w.r.t. parameters.\n        theta = (epsilon, sigma, alpha_A, alpha_B, a)\n        \"\"\"\n        epsilon, sigma, alpha_A, alpha_B, a = theta\n        grad = np.zeros(5, dtype=float)\n\n        # Lennard-Jones term derivatives\n        if r > 0:\n            s_over_r = sigma / r\n            s_over_r_6 = s_over_r**6\n            s_over_r_12 = s_over_r_6**2\n            \n            # dE/d(epsilon)\n            grad[0] = 4.0 * (s_over_r_12 - s_over_r_6)\n            \n            # dE/d(sigma)\n            if sigma > 0:\n                grad[1] = (24.0 * epsilon / sigma) * (2.0 * s_over_r_12 - s_over_r_6)\n\n        # Polarization term derivatives\n        if E != 0:\n            r_inv3 = r**(-3)\n            denom_pol = 1.0 + a * r_inv3\n            \n            if abs(denom_pol) > 1e-15: # Avoid division by zero\n                # dE/d(alpha_A) and dE/d(alpha_B)\n                common_pol_deriv = -0.5 * E**2 / denom_pol\n                grad[2] = common_pol_deriv\n                grad[3] = common_pol_deriv\n                \n                # dE/d(a)\n                alpha_sum = alpha_A + alpha_B\n                grad[4] = 0.5 * E**2 * alpha_sum * r_inv3 / (denom_pol**2)\n                \n        return grad\n\n    def analyze_case(case_data):\n        \"\"\"\n        Performs the full FIM analysis for a single case.\n        \"\"\"\n        theta = np.array(case_data[\"params\"])\n        distances = case_data[\"distances\"]\n        fields = case_data[\"fields\"]\n        noise_var = case_data[\"noise_var\"]\n        \n        num_params = len(theta)\n        fim = np.zeros((num_params, num_params), dtype=float)\n        \n        for r, E in zip(distances, fields):\n            grad = calculate_gradient(theta, r, E)\n            fim += np.outer(grad, grad)\n            \n        fim /= noise_var\n        \n        # Eigenvalue analysis for condition number\n        eigvals = np.linalg.eigvalsh(fim)\n        lambda_min, lambda_max = eigvals[0], eigvals[-1]\n        \n        if lambda_min = singularity_threshold:\n            kappa = np.inf\n        else:\n            kappa = lambda_max / lambda_min\n            \n        # Identifiability analysis\n        fim_reg = fim + lambda_reg * np.identity(num_params)\n        try:\n            cov_matrix = np.linalg.inv(fim_reg)\n        except np.linalg.LinAlgError:\n            # Should not happen due to regularization, but as a safeguard\n            return kappa, 0\n\n        identifiable_count = 0\n        for i in range(num_params):\n            # A parameter value of zero cannot be assessed by relative uncertainty.\n            if abs(theta[i])  1e-15:\n                continue\n            \n            # Variance must be non-negative.\n            C_ii = cov_matrix[i, i]\n            if C_ii  0:\n                continue\n\n            rho_i = np.sqrt(C_ii) / np.abs(theta[i])\n            \n            if rho_i = identifiability_threshold:\n                identifiable_count += 1\n                \n        return kappa, identifiable_count\n\n    # Process all cases and collect results\n    kappas = []\n    identifiable_counts = []\n    for case in test_cases:\n        kappa, N = analyze_case(case)\n        kappas.append(kappa)\n        identifiable_counts.append(N)\n    \n    final_results = kappas + identifiable_counts\n    \n    # Format and print the final output as a single line\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3413114"}]}