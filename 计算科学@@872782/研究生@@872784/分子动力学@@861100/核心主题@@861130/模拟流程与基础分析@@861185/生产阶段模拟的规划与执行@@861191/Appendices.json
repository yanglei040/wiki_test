{"hands_on_practices": [{"introduction": "在分子动力学模拟中，静电相互作用的计算通常是性能瓶颈。粒子网格Ewald（PME）方法是计算长程静电力的标准技术，但其精度和计算成本高度依赖于一系列参数。本练习 [@problem_id:3438102] 将指导你通过一个系统的优化过程，在给定的精度要求下，寻找能够最小化计算成本的PME参数组合，这是规划高效生产阶段模拟的关键第一步。", "problem": "您正在为将使用粒子网格埃瓦尔德 (PME) 方法的经典分子动力学模拟规划生产阶段的静电学设置。您必须构建一个程序，该程序针对给定测试套件中的每个系统，选择 PME 参数以在固定的精度约束下最小化成本模型。您的选择变量是埃瓦尔德分裂参数 $\\,\\alpha\\,$、实空间截断半径 $\\,r_c\\,$ 以及一个各向同性的三维网格尺寸 $\\,\\mathbf{n}_{\\mathrm{grid}} = (n,n,n)\\,$，该尺寸被约束为对快速傅里叶变换 (FFT) 友好。任务是生成一个单行输出，汇总所有测试用例的最优选择。\n\n基本原理和定义：\n- 埃瓦尔德求和法将库仑相互作用分解为实空间和倒易空间两部分，由埃瓦尔德分裂参数 $\\,\\alpha\\,$ 控制，其中互补误差函数对短程部分进行加权，高斯屏蔽对长程部分进行加权。\n- 均方根 (RMS) 力误差被建模为实空间截断误差和倒易空间离散化误差的正交和。我们使用一对被广泛采用且保守的误差模型，这些模型随密度和特征谱隙而缩放：\n  1. 实空间 RMS 力误差模型：\n     $$\\mathcal{E}_{\\mathrm{real}}(\\alpha, r_c; \\rho, q_{\\mathrm{rms}}) \\;=\\; k_{\\mathrm{real}}\\; q_{\\mathrm{rms}}^2 \\, \\sqrt{\\rho}\\, \\exp\\!\\left(-(\\alpha r_c)^2\\right).$$\n  2. 对于使用基数B样条分配阶数 $\\,p\\,$ 的平滑粒子网格埃瓦尔德方法，其倒易空间 RMS 力误差模型为：\n     $$\\mathcal{E}_{\\mathrm{recip}}(\\alpha, n; L, \\rho, q_{\\mathrm{rms}}, p) \\;=\\; k_{\\mathrm{recip}}\\; q_{\\mathrm{rms}}^2 \\, \\sqrt{\\rho}\\; n^{-p}\\, \\exp\\!\\left(-\\left(\\frac{\\pi n}{\\alpha L}\\right)^2\\right).$$\n  总 RMS 力误差为：\n     $$\\mathcal{E}_{\\mathrm{tot}}(\\alpha, r_c, n) \\;=\\; \\sqrt{\\mathcal{E}_{\\mathrm{real}}(\\alpha, r_c)^2 + \\mathcal{E}_{\\mathrm{recip}}(\\alpha, n)^2}.$$\n- 网格尺寸向量被约束为 $\\,\\mathbf{n}_{\\mathrm{grid}} = (n,n,n)\\,$，其中 $\\,n\\,$ 被限制为 $\\,5$-平滑数（其质因数仅为 $\\,2,3,5\\,$），选自一个有界区间 $[n_{\\min}, n_{\\max}]$。\n- 模拟盒子是边长为 $\\,L\\,$ 的立方体，包含 $\\,N\\,$ 个粒子，数密度为 $\\,\\rho = N/L^3\\,$。对于此规划问题，所有量均被视为无量纲。误差容限 $\\,\\varepsilon\\,$ 是特征力尺度的无量纲分数。成本以每步任意时间单位计算。\n- 每个时间步的计算成本被建模为三个组成部分的总和：\n  - 在截断半径 $\\,r_c\\,$ 内使用Verlet列表的实空间对计算：\n    $$C_{\\mathrm{real}}(N, \\rho, r_c) \\;=\\; c_{\\mathrm{pair}}\\; N\\, \\rho\\, r_c^3.$$\n  - 使用阶数为 $\\,p\\,$ 的B样条在网格上进行电荷分布和力收集：\n    $$C_{\\mathrm{spread}}(n, p) \\;=\\; c_{\\mathrm{spread}}\\, p^3\\, n^3.$$\n  - 三维快速傅里叶变换 (FFT)：\n    $$C_{\\mathrm{FFT}}(n) \\;=\\; c_{\\mathrm{FFT}}\\, n^3 \\log_2(n^3).$$\n  总成本为：\n    $$C_{\\mathrm{tot}} \\;=\\; C_{\\mathrm{real}} + C_{\\mathrm{spread}} + C_{\\mathrm{FFT}}.$$\n\n优化问题：\n- 给定 $\\,N, L, q_{\\mathrm{rms}}, p, \\varepsilon\\,$、常数 $\\,k_{\\mathrm{real}}, k_{\\mathrm{recip}}, c_{\\mathrm{pair}}, c_{\\mathrm{spread}}, c_{\\mathrm{FFT}}\\,$ 以及 $\\,r_c, \\alpha, n\\,$ 的界限，选择 $\\,(\\alpha, r_c, n)\\,$ 以最小化 $\\,C_{\\mathrm{tot}}\\,$，约束条件为：\n  $$\\mathcal{E}_{\\mathrm{tot}}(\\alpha, r_c, n) \\;\\le\\; \\varepsilon.$$\n- 为满足实际生产运行的要求，搜索域受到以下约束：\n  - 截断半径范围：$\\,r_c \\in [r_{c,\\min}, r_{c,\\max}]$，其中 $\\,r_{c,\\min} = 0.5\\,$ 且 $\\,r_{c,\\max} = 0.49 L\\,$。\n  - 与 $\\,r_c\\,$ 相关的埃瓦尔德分裂参数范围：$\\,\\alpha \\in [\\alpha_{\\min}(r_c), \\alpha_{\\max}(r_c)]\\,$，其中 $\\,\\alpha_{\\min}(r_c) = 0.5/r_c\\,$ 且 $\\,\\alpha_{\\max}(r_c) = 3.5/r_c\\,$。\n  - 网格尺寸：$\\,n \\in \\mathcal{N}\\,$，即在 $[n_{\\min}, n_{\\max}]$ 范围内的 $\\,5$-平滑数集合，其中 $\\,n_{\\min} = 32\\,$ 且 $\\,n_{\\max} = 128\\,$。\n- 如果没有可行的三元组 $\\,(\\alpha, r_c, n)\\,$ 满足误差约束，则报告结果为不可行。\n\n使用的常数：\n- 误差模型常数：$\\,k_{\\mathrm{real}} = 1.0\\,$ 和 $\\,k_{\\mathrm{recip}} = 1.0\\,$。\n- 成本模型常数：$\\,c_{\\mathrm{pair}} = 10^{-6}\\,$, $\\,c_{\\mathrm{spread}} = 2\\times 10^{-7}\\,$ 和 $\\,c_{\\mathrm{FFT}} = 5\\times 10^{-6}\\,$。\n\n要求的输出：\n- 对于每个测试用例，您的程序必须将所选参数和指标以下列列表形式输出：\n  $$[\\alpha^\\star, r_c^\\star, n^\\star, C_{\\mathrm{tot}}^\\star, \\mathcal{E}_{\\mathrm{tot}}^\\star, \\text{feasible}],$$\n  其中 $\\,\\text{feasible}\\,$ 是一个布尔值，当存在可行解时为真，否则为假。所有浮点输出必须四舍五入到 $\\,6\\,$ 位小数。如果不可行，则为该测试用例返回 $\\,[-1,-1,-1,-1,-1,\\text{False}]\\,$。\n- 您的程序应生成单行输出，其中包含一个由逗号分隔的各测试用例列表组成的列表，并用一对单独的方括号括起来。例如：$\\,\\texttt{[[...],[...],[...]]}\\,$。\n\n测试套件：\n使用以下四个测试用例，每个用例由元组 $\\, (N, L, q_{\\mathrm{rms}}, p, \\varepsilon)\\,$ 描述：\n1. $\\, (100000,\\, 10.0,\\, 0.30,\\, 4,\\, 10^{-3})\\,$.\n2. $\\, (100000,\\, 10.0,\\, 0.30,\\, 4,\\, 3\\times 10^{-5})\\,$.\n3. $\\, (5000,\\, 6.0,\\, 0.50,\\, 6,\\, 5\\times 10^{-4})\\,$.\n4. $\\, (200000,\\, 8.0,\\, 0.25,\\, 6,\\, 10^{-5})\\,$.\n\n算法要求：\n- 您的程序必须在离散集合 $\\,\\mathcal{N}\\,$ 中搜索 $\\,n\\,$，并在指定范围内的均匀网格上对 $\\,r_c\\,$ 和 $\\,\\alpha\\,$ 进行采样。在 $[r_{c,\\min}, r_{c,\\max}]$ 范围内为 $\\,r_c\\,$ 使用至少 $\\,40\\,$ 个线性间隔的样本，并为每个 $\\,r_c\\,$ 在 $[\\alpha_{\\min}(r_c), \\alpha_{\\max}(r_c)]$ 范围内为 $\\,\\alpha\\,$ 使用至少 $\\,40\\,$ 个线性间隔的样本。\n- 对于每个可行的组合，计算总成本并选择成本最小的那个。通过优先选择较小的 $\\,n\\,$，然后是较小的 $\\,r_c\\,$，再然后是较小的 $\\,\\alpha\\,$ 来打破平局。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个列表，该列表有四个子列表，对应四个测试用例，每个子列表都具有上面指定的格式和舍入要求，不得包含其他文本。例如：\n  $$\\texttt{[[a1,rc1,n1,c1,e1,True],[a2,rc2,n2,c2,e2,True],[...],[...]]}.$$", "solution": "所呈现的问题是一个约束优化任务，是规划采用粒子网格埃瓦尔德 (PME) 方法处理长程静电相互作用的分子动力学模拟的核心。其目标是选择一组 PME 参数——埃瓦尔德分裂参数 $\\alpha$、实空间截断距离 $r_c$ 和 FFT 网格维度 $n$——以在满足用户定义的均方根 (RMS) 力误差 $\\mathcal{E}_{\\mathrm{tot}}$ 容限 $\\varepsilon$ 的同时，最小化每个时间步的计算成本 $C_{\\mathrm{tot}}$。\n\n首先，我们重申所提供的控制性数学模型。总 RMS 力误差 $\\mathcal{E}_{\\mathrm{tot}}$ 是实空间求和与倒易空间求和贡献的正交和：\n$$\n\\mathcal{E}_{\\mathrm{tot}}(\\alpha, r_c, n) = \\sqrt{\\mathcal{E}_{\\mathrm{real}}(\\alpha, r_c)^2 + \\mathcal{E}_{\\mathrm{recip}}(\\alpha, n)^2}\n$$\n实空间误差 $\\mathcal{E}_{\\mathrm{real}}$ 源于在截断半径 $r_c$ 处截断短程相互作用：\n$$\n\\mathcal{E}_{\\mathrm{real}}(\\alpha, r_c; \\rho, q_{\\mathrm{rms}}) = k_{\\mathrm{real}} q_{\\mathrm{rms}}^2 \\sqrt{\\rho} \\exp(-(\\alpha r_c)^2)\n$$\n倒易空间误差 $\\mathcal{E}_{\\mathrm{recip}}$ 源于将倒易空间离散化到尺寸为 $\\mathbf{n}_{\\mathrm{grid}} = (n,n,n)$ 的网格上：\n$$\n\\mathcal{E}_{\\mathrm{recip}}(\\alpha, n; L, \\rho, q_{\\mathrm{rms}}, p) = k_{\\mathrm{recip}} q_{\\mathrm{rms}}^2 \\sqrt{\\rho} n^{-p} \\exp\\left(-\\left(\\frac{\\pi n}{\\alpha L}\\right)^2\\right)\n$$\n此处，$\\rho = N/L^3$ 是粒子数密度，$q_{\\mathrm{rms}}$ 是均方根粒子电荷，$L$ 是立方体盒子的边长，$p$ 是 B 样条插值阶数。常数 $k_{\\mathrm{real}}$ 和 $k_{\\mathrm{recip}}$ 均给定为 $1.0$。\n\n总计算成本 $C_{\\mathrm{tot}}$ 被建模为三个主要组成部分的总和：\n$$\nC_{\\mathrm{tot}}(r_c, n; N, \\rho, p) = C_{\\mathrm{real}}(r_c) + C_{\\mathrm{spread}}(n) + C_{\\mathrm{FFT}}(n)\n$$\n其中：\n- $C_{\\mathrm{real}}(N, \\rho, r_c) = c_{\\mathrm{pair}} N \\rho r_c^3$ 是实空间对计算的成本。\n- $C_{\\mathrm{spread}}(n, p) = c_{\\mathrm{spread}} p^3 n^3$ 是将电荷分布到网格和收集力的成本。\n- $C_{\\mathrm{FFT}}(n) = c_{\\mathrm{FFT}} n^3 \\log_2(n^3)$ 是三维快速傅里叶变换的成本。\n成本常数指定为 $c_{\\mathrm{pair}} = 10^{-6}$，$c_{\\mathrm{spread}} = 2\\times 10^{-7}$，以及 $c_{\\mathrm{FFT}} = 5\\times 10^{-6}$。\n\n优化问题是找到 $(\\alpha^\\star, r_c^\\star, n^\\star)$，在约束条件 $\\mathcal{E}_{\\mathrm{tot}} \\le \\varepsilon$ 下最小化 $C_{\\mathrm{tot}}$。搜索空间由以下参数定义：\n- $n \\in \\mathcal{N}$，即区间 $[32, 128]$ 内的 $5$-平滑数（质因数 $\\in \\{2,3,5\\}$）集合。\n- $r_c \\in [r_{c,\\min}, r_{c,\\max}] = [0.5, 0.49 L]$。\n- $\\alpha \\in [\\alpha_{\\min}(r_c), \\alpha_{\\max}(r_c)] = [0.5/r_c, 3.5/r_c]$。\n\n鉴于误差函数和成本函数的非线性及耦合性质，解析解是难以处理的。规定的求解方法是对离散化参数空间进行系统的网格搜索。$n$ 的离散性构成了搜索的基础。对于每个有效的整数 $n$，对 $r_c$ 和 $\\alpha$ 的连续域进行均匀采样。具体来说，我们在 $r_c$ 的范围内使用 $40$ 个采样点，并对每个 $r_c$，在其对应的 $\\alpha$ 范围内使用 $40$ 个采样点。\n\n对于每个测试用例，算法按以下步骤进行：\n1.  在 $[32, 128]$ 内生成排序后的 $5$-平滑数列表 $\\mathcal{N}$。\n2.  为最优参数初始化一个跟踪元组 $(C_{\\mathrm{best}}, n_{\\mathrm{best}}, r_{c, \\mathrm{best}}, \\alpha_{\\mathrm{best}})$，并将 $C_{\\mathrm{best}}$ 设置为无穷大。选择此结构是为了方便进行字典序比较，这自然地实现了指定的平局打破规则：优先选择更低的成本，然后是更小的 $n$，接着是更小的 $r_c$，最后是更小的 $\\alpha$。\n3.  遍历 $\\mathcal{N}$ 中的每个 $n$。对于每个 $n$，遍历 $r_c$ 的 $40$ 个样本。对于每个 $(n, r_c)$ 对，遍历 $\\alpha$ 的 $40$ 个样本。\n4.  在搜索网格中的每个点 $(\\alpha, r_c, n)$，计算总误差 $\\mathcal{E}_{\\mathrm{tot}}$。\n5.  通过将计算出的误差与容限进行比较来检查可行性：$\\mathcal{E}_{\\mathrm{tot}} \\le \\varepsilon$。\n6.  如果参数集是可行的，计算总成本 $C_{\\mathrm{tot}}$。\n7.  将当前可行解的字典序元组 $(C_{\\mathrm{tot}}, n, r_c, \\alpha)$ 与迄今为止的最优元组进行比较。如果当前元组更小，则它成为新的最优解，并存储其参数和误差。\n8.  在搜索完整个网格后，如果找到了可行解，则记录最优参数 $(\\alpha^\\star, r_c^\\star, n^\\star)$、最小成本 $C_{\\mathrm{tot}}^\\star$ 及其对应的误差 $\\mathcal{E}_{\\mathrm{tot}}^\\star$。否则，将该用例标记为不可行。\n9.  将每个测试用例的最终结果按要求格式化并聚合成一个单一的列表结构。浮点值格式化为 $6$ 位小数。\n\n这种暴力搜索保证在离散化空间内找到最优参数。输出是为所提供的测试系统套件找到的这些最优设置的集合。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Finds optimal PME parameters by performing a grid search for a series of test cases.\n    \"\"\"\n\n    # Define constants from the problem statement.\n    K_REAL = 1.0\n    K_RECIP = 1.0\n    C_PAIR = 1.0e-6\n    C_SPREAD = 2.0e-7\n    C_FFT = 5.0e-6\n    N_MIN = 32\n    N_MAX = 128\n    RC_MIN_VAL = 0.5\n    NUM_SAMPLES = 40\n\n    test_cases = [\n        (100000, 10.0, 0.30, 4, 1e-3),\n        (100000, 10.0, 0.30, 4, 3e-5),\n        (5000, 6.0, 0.50, 6, 5e-4),\n        (200000, 8.0, 0.25, 6, 1e-5),\n    ]\n\n    def generate_smooth_numbers(n_min, n_max):\n        \"\"\"Generates 5-smooth integers within a given range.\"\"\"\n        nums = {1}\n        q = [1]\n        head = 0\n        # Generate all 5-smooth numbers up to n_max\n        while head  len(q):\n            curr = q[head]\n            head += 1\n            for factor in [2, 3, 5]:\n                next_val = curr * factor\n                if next_val = n_max and next_val not in nums:\n                    nums.add(next_val)\n                    q.append(next_val)\n        # Filter by n_min and sort\n        return sorted([x for x in nums if x >= n_min])\n\n    n_smooth_list = generate_smooth_numbers(N_MIN, N_MAX)\n    \n    all_results = []\n    \n    for case in test_cases:\n        N, L, q_rms, p, epsilon = case\n        rho = N / (L**3)\n\n        best_params_tuple = (float('inf'), -1, -1.0, -1.0)  # (cost, n, rc, alpha)\n        best_error = -1.0\n        found_feasible = False\n\n        # Pre-calculate reciprocal space cost components which only depend on n and p\n        cost_recip_map = {}\n        for n_val in n_smooth_list:\n            c_spread = C_SPREAD * (p**3) * (n_val**3)\n            c_fft = C_FFT * (n_val**3) * np.log2(n_val**3)\n            cost_recip_map[n_val] = c_spread + c_fft\n\n        for n in n_smooth_list:\n            rc_max = 0.49 * L\n            rc_samples = np.linspace(RC_MIN_VAL, rc_max, NUM_SAMPLES)\n            \n            cost_recip = cost_recip_map[n]\n\n            for r_c in rc_samples:\n                alpha_min = 0.5 / r_c\n                alpha_max = 3.5 / r_c\n                alpha_samples = np.linspace(alpha_min, alpha_max, NUM_SAMPLES)\n\n                cost_real = C_PAIR * N * rho * r_c**3\n\n                common_err_factor = (q_rms**2) * np.sqrt(rho)\n                e_real_base = K_REAL * common_err_factor\n                e_recip_base = K_RECIP * common_err_factor * (n**(-p))\n                \n                for alpha in alpha_samples:\n                    # Error Calculation\n                    e_real_sq_arg = -((alpha * r_c)**2)\n                    e_real = e_real_base * np.exp(e_real_sq_arg)\n\n                    e_recip_sq_arg = -((np.pi * n) / (alpha * L))**2\n                    e_recip = e_recip_base * np.exp(e_recip_sq_arg)\n\n                    e_tot = np.sqrt(e_real**2 + e_recip**2)\n\n                    if e_tot = epsilon:\n                        found_feasible = True\n                        \n                        # Cost Calculation\n                        cost_tot = cost_real + cost_recip\n                        \n                        current_params_tuple = (cost_tot, n, r_c, alpha)\n                        if current_params_tuple  best_params_tuple:\n                            best_params_tuple = current_params_tuple\n                            best_error = e_tot\n        \n        if found_feasible:\n            opt_cost, opt_n, opt_rc, opt_alpha = best_params_tuple\n            result = [opt_alpha, opt_rc, opt_n, opt_cost, best_error, True]\n        else:\n            result = [-1, -1, -1, -1, -1, False]\n        \n        all_results.append(result)\n\n    # Format the final output string exactly as specified.\n    output_parts = []\n    for res in all_results:\n        if res[-1] is False:\n            output_parts.append(\"[-1,-1,-1,-1,-1,False]\")\n        else:\n            alpha, rc, n, cost, error, _ = res\n            part = (f\"[{alpha:.6f},{rc:.6f},{n},\"\n                    f\"{cost:.6f},{error:.6f},True]\")\n            output_parts.append(part)\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n\n```", "id": "3438102"}, {"introduction": "在理想的NVE系综（微正则系综）模拟中，总能量应严格守恒。然而，由于数值积分、力计算和约束算法中不可避免的系统误差，实际模拟中经常观察到能量漂移。本练习 [@problem_id:3438091] 提供了一个实际的诊断情景，要求你根据观察到的能量不守恒现象，从多个潜在的误差来源中进行推理，并确定最合理的修正策略。", "problem": "一个溶剂化的肽在微正则系综（NVE）中进行模拟，使用的参数包括：辛速度-Verlet积分器，时间步长为 $2\\,\\mathrm{fs}$；对含氢键的键长采用线性约束求解器（LINCS）施加全息约束；通过粒子网格埃瓦尔德方法（PME）处理静电相互作用；并在图形处理器（GPU）上使用Verlet邻居列表。观察到总能量 $E(t) = K(t) + U(t)$ 在 $100\\,\\mathrm{ps}$ 的时间内以 $+0.002\\,\\mathrm{kJ\\,mol^{-1}\\,ps^{-1}}$ 的速率近似线性增长。模拟中没有激活恒温器或恒压器。请从牛顿第二定律 $m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$ 和保守力定义 $\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U(\\mathbf{r})$ 出发，并回顾在精确执行全息约束 $g_j(\\mathbf{r})=0$ 时，相关的约束力不做功的原理，论证在计算所得的力和约束中存在的系统误差如何导致NVE系综下 $E(t)$ 的单调漂移。然后，从以下选项中，选择一个最恰当的方案，该方案对约束、PME容差、精度模式和邻居列表设置的诊断检查进行了优先级排序，并提出了与最小化能量漂移、同时保持物理保真度和计算稳定性相一致的修正性参数更改。\n\n选项：\n\nA. 首先优先考虑邻居列表的安全性：验证GPU上的对称配对列表，将邻居列表缓冲区 $\\Delta r$ 从 $0.1\\,\\mathrm{nm}$ 增加到 $0.3\\,\\mathrm{nm}$，并将邻居列表更新周期从每 $10$ 步减少到每 $1$ 步，以避免错过截断半径附近的相互作用。接下来，通过将相对力误差容差从 $10^{-3}$ 降低到 $10^{-5}$ 并增大快速傅里叶变换（FFT）网格以维持目标容差，来收紧PME精度。然后，通过将LINCS容差从 $10^{-4}$ 降低到 $10^{-6}$ 并增加最大迭代次数（例如，从 $50$ 次增加到 $100$ 次）来加强约束执行；如果约束迭代达到饱和，则考虑将时间步长减少到 $1\\,\\mathrm{fs}$。最后，通过切换到混合精度模式（使用双精度进行累加）或使用完全双精度进行力和能量求和，来提高算术精度。\n\nB. 应用一个弱恒温器来消除漂移，同时保留NVE标签，将PME容差从 $10^{-3}$ 放宽到 $10^{-2}$ 以提高性能，将所有计算切换到单精度以最大化GPU吞吐量，并保持邻居列表缓冲区和更新周期不变，即 $\\Delta r=0.1\\,\\mathrm{nm}$ 和 $20$ 步。\n\nC. 激进地将时间步长减少到 $0.5\\,\\mathrm{fs}$，禁用所有约束以避免LINCS迭代，粗化PME网格以降低计算成本，并保持邻居列表参数不变。依赖更小的时间步长来抑制观察到的能量漂移。\n\nD. 从约束执行开始：将LINCS容差从 $10^{-4}$ 降低到 $10^{-6}$，增加最大迭代次数，并考虑从LINCS算法切换到SHAKE算法。接下来，将PME容差从 $10^{-3}$ 调整到 $10^{-5}$。然后增加邻居列表缓冲区 $\\Delta r$ 和更新频率以避免配对遗漏。最后，通过使用双精度进行力累加来提高数值精度，同时保持时间步长为 $2\\,\\mathrm{fs}$。", "solution": "该问题要求对微正则（NVE）分子动力学模拟中观察到的能量漂移进行论证，并选择最合适的策略来诊断和纠正它。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n- 系综：微正则（NVE），无恒温器或恒压器。\n- 系统：溶剂化的肽。\n- 积分器：辛速度-Verlet。\n- 时间步长（$\\Delta t$）：$2\\,\\mathrm{fs}$。\n- 约束：对涉及氢原子的键施加全息约束，使用线性约束求解器（LINCS）解决。\n- 静电学：粒子网格埃瓦尔德（PME）。\n- 邻居搜索：Verlet邻居列表。\n- 硬件：图形处理器（GPU）。\n- 观察：总能量 $E(t) = K(t) + U(t)$ 呈现近似线性增加。\n- 能量漂移速率：$+0.002\\,\\mathrm{kJ\\,mol^{-1}\\,ps^{-1}}$。\n- 观察时长：$100\\,\\mathrm{ps}$。\n- 基本方程：$m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$，$\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U(\\mathbf{r})$，以及精确全息约束 $g_j(\\mathbf{r})=0$ 的约束力不做功原理。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题陈述在科学上是合理的、适定的且客观的。它描述了一个标准的分子动力学模拟设置和一个常见的数值伪影（能量漂移）。提到的组件（NVE、velocity-Verlet、LINCS、PME）都是标准方法。在给定的速率下观察到的正能量漂移，或称“数值加热”，对于一个使用 $2\\,\\mathrm{fs}$ 这种中等大小时间步长的模拟来说，是一个现实情景。问题要求基于第一性原理对这一现象进行论证，并评估修正策略，这是计算科学中的一个标准任务。该问题是自洽的，并提供了足够的信息，可以根据该领域已建立的最佳实践来评估所提出的选项。不存在科学、逻辑或事实上的缺陷。\n\n**步骤3：结论与行动**\n该问题有效。将提供完整解答。\n\n**能量漂移的理由**\n\n在理想的微正则系综模拟中，总能量 $E(t)$ 必须守恒。这种守恒性源于对牛顿运动方程 $m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$ 的积分，其中力 $\\mathbf{F}_i$ 是保守的，即它们是势能函数 $U(\\mathbf{r})$ 的负梯度，$\\mathbf{F}_i = -\\nabla_{\\mathbf{r}_i} U$。总能量的时间导数为\n$$ \\frac{dE}{dt} = \\frac{d}{dt} \\left( \\sum_i \\frac{1}{2} m_i \\dot{\\mathbf{r}}_i^2 + U(\\mathbf{r}) \\right) = \\sum_i (m_i \\dot{\\mathbf{r}}_i \\cdot \\ddot{\\mathbf{r}}_i + \\nabla_{\\mathbf{r}_i} U \\cdot \\dot{\\mathbf{r}}_i) $$\n代入 $m_i \\ddot{\\mathbf{r}}_i = \\mathbf{F}_i$ 和 $\\nabla_{\\mathbf{r}_i} U = -\\mathbf{F}_i$，我们得到：\n$$ \\frac{dE}{dt} = \\sum_i (\\dot{\\mathbf{r}}_i \\cdot \\mathbf{F}_i - \\mathbf{F}_i \\cdot \\dot{\\mathbf{r}}_i) = 0 $$\n然而，数值模拟引入了几个破坏这种精确守恒的近似，从而导致能量漂移。\n\n$1$. **离散化误差**：velocity-Verlet积分器以有限的时间步长 $\\Delta t$ 对时间进行离散化。虽然它是辛算法，意味着它能保守一个与真实哈密顿量接近的“影子”哈密顿量，但这一特性会被其他误差源破坏，这些误差源可能将有界的能量振荡转变为系统性漂移。\n\n$2$. **力计算中的误差**：计算出的力并非完全保守。\n    - **邻居列表**：短程力通常是为截断半径内的粒子对计算的。为避免 $\\mathcal{O}(N^2)$ 的复杂度，会构建一个邻居列表并定期更新。如果缓冲区（$\\Delta r$）太小或更新频率太低，粒子可能会在下次更新前移动到超出截断半径加缓冲区的位置。这会导致现有相互作用的突然消失或新相互作用的突然出现。这种力的不连续变化是非保守的，会向系统中注入能量。GPU实现有时可能存在微妙的错误，例如构建非对称的配对列表（其中粒子 $i$ 对 $j$ 的相互作用被计算，但 $j$ 对 $i$ 的没有），这违反了牛顿第三定律，直接破坏了能量和动量守恒。\n    - **PME静电学**：PME方法将计算分为实空间部分（受截断半径影响，如邻居列表）和倒易空间部分（通过在网格上进行FFT计算）。其精度由一个容差参数控制，该参数平衡了两部分之间的误差。将电荷离散化到网格上以及在倒易空间中使用的有限傅里叶级数会引入误差，这意味着得到的静电力不是埃瓦尔德势的精确梯度。宽松的容差会导致更大的非保守力分量，从而导致能量漂移。\n\n$3$. **约束执行中的误差**：诸如使用LINCS固定键长之类的全息约束是通过迭代求解的，其容差为有限值 $\\epsilon_{LINCS}$。因此，约束条件 $g_j(\\mathbf{r})=0$ 并未被精确满足。施加的约束力是为近似满足约束所需的力。虽然理想的约束力不做功，但这些近似的力在许多时间步长上可能会做少量净功，导致总能量发生系统性变化。对于 $2\\,\\mathrm{fs}$ 这样相对较大的时间步长，约束算法承受着巨大的压力，未能在最大迭代次数内收敛或容差过于宽松是能量漂移的常见来源。\n\n$4$. **有限精度算术**：所有计算都使用有限精度的浮点数（例如，单精度或双精度）进行。舍入误差会累积，尤其是在力和能量计算等大规模求和中。这会逐渐降低积分的时间可逆性和辛性，导致长期能量漂移。\n\n观察到的能量线性增加是这些系统误差共同作用，充当“数值加热”源的典型特征。\n\n**逐项分析选项**\n\n目标是找到最合适的诊断检查和修复措施的优先级顺序。一个有效的策略应从最可能和影响最大的误差源开始，再到较不常见的误差源，并且倾向于选择计算成本较低的修复方法，而不是成本较高的。\n\n**A. 首先优先考虑邻居列表的安全性：验证GPU上的对称配对列表，将邻居列表缓冲区 $\\Delta r$ 从 $0.1\\,\\mathrm{nm}$ 增加到 $0.3\\,\\mathrm{nm}$，并将邻居列表更新周期从每 $10$ 步减少到每 $1$ 步，以避免错过截断半径附近的相互作用。接下来，通过将相对力误差容差从 $10^{-3}$ 降低到 $10^{-5}$ 并增大快速傅里叶变换（FFT）网格以维持目标容差，来收紧PME精度。然后，通过将LINCS容差从 $10^{-4}$ 降低到 $10^{-6}$ 并增加最大迭代次数（例如，从 $50$ 次增加到 $100$ 次）来加强约束执行；如果约束迭代达到饱和，则考虑将时间步长减少到 $1\\,\\mathrm{fs}$。最后，通过切换到混合精度模式（使用双精度进行累加）或使用完全双精度进行力和能量求和，来提高算术精度。**\n\n此选项提出了一个高度逻辑化和系统化的诊断层级。\n$1$. **邻居列表**：它正确地优先确保力计算本身没有因错过相互作用而存在根本性缺陷。这是导致不稳定性和能量漂移的主要原因。检查GPU特定的实现细节（如对称配对列表）是专家级的诊断步骤。所提议的参数更改虽然激进，但保证了邻居搜索的安全性，从而将此作为一个潜在问题隔离开来。\n$2$. **PME**：下一步是提高长程力计算的准确性，这是非保守力的另一个主要来源。\n$3$. **约束**：然后它解决了约束算法的准确性问题，这对于使用 $2\\,\\mathrm{fs}$ 时间步长的稳定性至关重要。它正确地提供了一个应急措施（减少 $\\Delta t$），以防约束算法无法收敛。\n$4$. **精度**：最后，它处理了数值精度这个更微妙的问题，这通常是最后的手段。\n这个优先级顺序（力计算的正确性 - 力的准确性 - 积分的准确性 - 数值精度）在科学上是合理的，并反映了最佳实践。所提出的更改适合于减少能量漂移。\n\n**结论：正确**\n\n**B. 应用一个弱恒温器来消除漂移，同时保留NVE标签，将PME容差从 $10^{-3}$ 放宽到 $10^{-2}$ 以提高性能，将所有计算切换到单精度以最大化GPU吞吐量，并保持邻居列表缓冲区和更新周期不变，即 $\\Delta r=0.1\\,\\mathrm{nm}$ 和 $20$ 步。**\n\n此选项存在根本性缺陷。\n$1$. 应用恒温器是掩盖数值不稳定性，而不是修复它。在NVE模拟中使用恒温器并贴上NVE标签是具有欺骗性的；目标是修复导致NVE模拟非保守的根本问题。\n$2$. 将PME容差从 $10^{-3}$ 放宽到 $10^{-2}$ 会*增加*力的误差，从而加剧能量漂移。\n$3$. 如果尚未使用单精度，切换到单精度计算更有可能增加舍入误差并加剧漂移，而不是减少它。\n$4$. 忽略邻居列表这个主要嫌疑对象是不良做法。\n\n**结论：不正确**\n\n**C. 激进地将时间步长减少到 $0.5\\,\\mathrm{fs}$，禁用所有约束以避免LINCS迭代，粗化PME网格以降低计算成本，并保持邻居列表参数不变。依赖更小的时间步长来抑制观察到的能量漂移。**\n\n此选项也存在严重缺陷。\n$1$. 将时间步长减小到 $0.5\\,\\mathrm{fs}$ 是一种暴力方法，由于其高计算成本（增加$4$倍），应作为最后手段。虽然这可能会减少漂移，但它并未诊断出实际问题。\n$2$. 禁用约束从根本上改变了所模拟的物理模型。虽然这确实需要更小的时间步长，但这不是“修复”，而是改变了研究问题。\n$3$. 粗化PME网格会降低精度并*增加*能量漂移，与目标直接矛盾。\n$4$. 保持邻居列表参数不变忽略了一个关键的潜在误差源。\n\n**结论：不正确**\n\n**D. 从约束执行开始：将LINCS容差从 $10^{-4}$ 降低到 $10^{-6}$，增加最大迭代次数，并考虑从LINCS算法切换到SHAKE算法。接下来，将PME容差从 $10^{-3}$ 调整到 $10^{-5}$。然后增加邻居列表缓冲区 $\\Delta r$ 和更新频率以避免配对遗漏。最后，通过使用双精度进行力累加来提高数值精度，同时保持时间步长为 $2\\,\\mathrm{fs}$。**\n\n此选项提出了一套科学上合理的行动，与选项A相似。然而，其优先级设置不够理想。它将约束置于邻居列表之前。虽然在使用 $2\\,\\mathrm{fs}$ 时间步长时，约束误差很可能是罪魁祸首，但一个有缺陷的邻居列表意味着提供给积分器和约束算法的力从一开始就是不正确的。更合乎逻辑的做法是首先确保所有相互作用都被正确捕捉（邻居列表安全性），然后再微调力分量（PME）和使用这些力的算法（积分器/约束）的准确性。因此，选项A中的层级结构，即从邻居列表安全性开始，更为优越。\n\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3438091"}, {"introduction": "生产阶段模拟的主要目标是精确地计算物理量的系综平均值。然而，模拟时间过短会导致统计误差过大，而模拟时间过长则会浪费计算资源。本练习 [@problem_id:3438067] 引导你利用预模拟（pilot simulation）获得的统计信息，如方差和积分自相关时间，来估算达到目标精度所需的模拟时长，从而科学地规划生产阶段的规模。", "problem": "计划进行一次生产性的分子动力学（MD）模拟，以预设的精度估算一个可观测量 $A(t)$（例如，瞬时摩尔势能）的时间平均值。已经进行了一次数值实验性质的短时模拟，在舍弃平衡阶段后，时间序列 $A(t)$ 表现出平稳性和遍历性。从该模拟数据中，获得了以下估计值：积分自相关时间 $\\tau_{\\mathrm{int}}$ 和方差 $\\sigma_{A}^{2} \\equiv \\langle (A - \\langle A \\rangle)^{2} \\rangle$。生产性模拟的轨迹将足够长，使得总模拟时间 $T$ 满足 $T \\gg \\tau_{\\mathrm{int}}$，且采样在时间上是均匀的。\n\n从时间平均的定义 $\\bar{A}_{T} \\equiv \\frac{1}{T} \\int_{0}^{T} A(t) \\, dt$ 和平稳过程的自协方差函数 $C_{A}(t) \\equiv \\langle (A(0) - \\langle A \\rangle)(A(t) - \\langle A \\rangle) \\rangle$ 出发，推导 $\\bar{A}_{T}$ 的渐近方差的表达式，用 $\\sigma_{A}^{2}$、$\\tau_{\\mathrm{int}}$ 和 $T$ 表示。然后使用此表达式确定所需的生产性模拟时间 $T$，以使估计量 $\\bar{A}_{T}$ 达到目标标准误差 $\\sigma_{\\bar{A}}$。\n\n为规划模拟，请使用实验性模拟的估计值 $\\tau_{\\mathrm{int}} = 25\\,\\mathrm{ps}$ 和 $\\sigma_{A}^{2} = 400\\,(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}$，并要求目标标准误差为 $\\sigma_{\\bar{A}} = 1\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。以纳秒为单位表示最终所需的生产性模拟时间 $T$，并将您的答案四舍五入到三位有效数字。", "solution": "该问题要求从分子动力学（MD）模拟中推导时间平均可观测量的方差，并随后计算达到目标精度所需的模拟时长。该问题具有科学依据，提法明确，并包含所有必要信息。我们可以开始求解。\n\n首先，我们推导时间平均值 $\\bar{A}_{T}$ 的方差表达式。一个可观测量 $A(t)$ 在总时间 $T$ 上的时间平均值定义为：\n$$\n\\bar{A}_{T} \\equiv \\frac{1}{T} \\int_{0}^{T} A(t) \\, dt\n$$\n此估计量的方差，记为 $\\sigma_{\\bar{A}_{T}}^{2}$，由 $\\sigma_{\\bar{A}_{T}}^{2} = \\langle (\\bar{A}_{T} - \\langle \\bar{A}_{T} \\rangle)^{2} \\rangle$ 给出，其中 $\\langle \\cdot \\rangle$ 表示系综平均。对于一个平稳过程，系综平均 $\\langle A(t) \\rangle$ 与时间无关，等于我们记为 $\\langle A \\rangle$ 的真实平均值。估计量 $\\bar{A}_{T}$ 的系综平均为：\n$$\n\\langle \\bar{A}_{T} \\rangle = \\left\\langle \\frac{1}{T} \\int_{0}^{T} A(t) \\, dt \\right\\rangle = \\frac{1}{T} \\int_{0}^{T} \\langle A(t) \\rangle \\, dt = \\frac{1}{T} \\int_{0}^{T} \\langle A \\rangle \\, dt = \\frac{1}{T} \\langle A \\rangle [t]_{0}^{T} = \\langle A \\rangle\n$$\n这表明 $\\bar{A}_{T}$ 是 $\\langle A \\rangle$ 的一个无偏估计量。因此，方差可以写为：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\langle (\\bar{A}_{T} - \\langle A \\rangle)^{2} \\rangle\n$$\n代入 $\\bar{A}_{T}$ 的定义并引入涨落项 $\\delta A(t) = A(t) - \\langle A \\rangle$：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\left\\langle \\left( \\frac{1}{T} \\int_{0}^{T} A(t) \\, dt - \\langle A \\rangle \\right)^{2} \\right\\rangle = \\left\\langle \\left( \\frac{1}{T} \\int_{0}^{T} (A(t) - \\langle A \\rangle) \\, dt \\right)^{2} \\right\\rangle = \\frac{1}{T^{2}} \\left\\langle \\left( \\int_{0}^{T} \\delta A(t) \\, dt \\right)^{2} \\right\\rangle\n$$\n我们可以将积分的平方写成一个二重积分：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\frac{1}{T^{2}} \\left\\langle \\int_{0}^{T} \\delta A(t) \\, dt \\int_{0}^{T} \\delta A(t') \\, dt' \\right\\rangle\n$$\n根据期望算符的线性性质，我们可以将其移到积分内部：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\frac{1}{T^{2}} \\int_{0}^{T} dt \\int_{0}^{T} dt' \\, \\langle \\delta A(t) \\delta A(t') \\rangle\n$$\n对于平稳过程，相关性 $\\langle \\delta A(t) \\delta A(t') \\rangle$ 仅依赖于时间差 $|t' - t|$。这正是自协方差函数 $C_{A}(\\tau) = \\langle \\delta A(0) \\delta A(\\tau) \\rangle$ 的定义。因此，$\\langle \\delta A(t) \\delta A(t') \\rangle = C_{A}(t' - t)$。\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\frac{1}{T^{2}} \\int_{0}^{T} dt \\int_{0}^{T} dt' \\, C_{A}(t' - t)\n$$\n这个在方形域上的二重积分可以简化。使用恒等式 $\\int_{0}^{L} \\int_{0}^{L} f(|x-y|) \\, dy \\, dx = 2 \\int_{0}^{L} (L-z) f(z) \\, dz$ 并注意到自协方差函数是偶函数，即 $C_{A}(\\tau) = C_{A}(-\\tau)$, 我们得到：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} = \\frac{2}{T^{2}} \\int_{0}^{T} (T - \\tau) C_{A}(\\tau) \\, d\\tau = \\frac{2}{T} \\int_{0}^{T} \\left(1 - \\frac{\\tau}{T}\\right) C_{A}(\\tau) \\, d\\tau\n$$\n问题陈述中提到，总生产性模拟时间 $T$ 远大于积分自相关时间，即 $T \\gg \\tau_{\\mathrm{int}}$。自协方差 $C_{A}(\\tau)$ 在以 $\\tau_{\\mathrm{int}}$ 为特征的时间尺度上衰减至零。因此，在积分范围内 $C_{A}(\\tau)$ 不为零的主要部分，我们有 $\\tau \\ll T$。这允许我们做两个近似：\n1.  项 $(1 - \\frac{\\tau}{T}) \\approx 1$。\n2.  积分上限可以从 $T$ 扩展到 $\\infty$，其引入的误差可忽略不计。\n应用这些近似，我们得到渐近方差：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} \\approx \\frac{2}{T} \\int_{0}^{\\infty} C_{A}(\\tau) \\, d\\tau\n$$\n问题给出了方差 $\\sigma_{A}^{2}$ 和积分自相关时间 $\\tau_{\\mathrm{int}}$ 的定义。可观测量 $A$ 的方差是 $\\sigma_{A}^{2} = C_{A}(0)$。积分自相关时间的标准定义是*归一化*自相关函数的积分：\n$$\n\\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\frac{C_{A}(\\tau)}{C_{A}(0)} \\, d\\tau = \\frac{1}{\\sigma_{A}^{2}} \\int_{0}^{\\infty} C_{A}(\\tau) \\, d\\tau\n$$\n由此，我们得到 $\\int_{0}^{\\infty} C_{A}(\\tau) \\, d\\tau = \\sigma_{A}^{2} \\tau_{\\mathrm{int}}$。将此式代入我们关于平均值方差的表达式，得到所需的关系：\n$$\n\\sigma_{\\bar{A}_{T}}^{2} \\approx \\frac{2 \\sigma_{A}^{2} \\tau_{\\mathrm{int}}}{T}\n$$\n接下来，我们使用这个表达式来确定所需的生产性模拟时间 $T$。估计量的目标标准误差是 $\\sigma_{\\bar{A}}$，即方差的平方根，$\\sigma_{\\bar{A}} = \\sqrt{\\sigma_{\\bar{A}_{T}}^{2}}$。两边平方得到 $\\sigma_{\\bar{A}}^{2} = \\sigma_{\\bar{A}_{T}}^{2}$。我们现在可以解出 $T$：\n$$\nT \\approx \\frac{2 \\sigma_{A}^{2} \\tau_{\\mathrm{int}}}{\\sigma_{\\bar{A}}^{2}}\n$$\n我们已知以下实验性模拟估计值和目标精度：\n- $\\tau_{\\mathrm{int}} = 25\\,\\mathrm{ps}$\n- $\\sigma_{A}^{2} = 400\\,(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}$\n- $\\sigma_{\\bar{A}} = 1\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，这意味着 $\\sigma_{\\bar{A}}^{2} = (1\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2} = 1\\,(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}$。\n\n将这些值代入 $T$ 的表达式中：\n$$\nT \\approx \\frac{2 \\times 400\\,(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2} \\times 25\\,\\mathrm{ps}}{1\\,(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}}\n$$\n$(\\mathrm{kJ}\\,\\mathrm{mol}^{-1})^{2}$ 的单位相消，剩下时间的单位为皮秒：\n$$\nT \\approx (2 \\times 400 \\times 25)\\,\\mathrm{ps} = (800 \\times 25)\\,\\mathrm{ps} = 20000\\,\\mathrm{ps}\n$$\n问题要求答案以纳秒（ns）为单位。由于 $1\\,\\mathrm{ns} = 1000\\,\\mathrm{ps}$：\n$$\nT \\approx 20000\\,\\mathrm{ps} \\times \\frac{1\\,\\mathrm{ns}}{1000\\,\\mathrm{ps}} = 20\\,\\mathrm{ns}\n$$\n最后，我们必须将答案四舍五入到三位有效数字。\n$$\nT = 20.0\\,\\mathrm{ns}\n$$\n作为一致性检验，我们的结果 $T = 20000\\,\\mathrm{ps}$ 确实远大于 $\\tau_{\\mathrm{int}} = 25\\,\\mathrm{ps}$（大了800倍），这验证了推导中使用的渐近近似的有效性。", "answer": "$$\\boxed{20.0}$$", "id": "3438067"}]}