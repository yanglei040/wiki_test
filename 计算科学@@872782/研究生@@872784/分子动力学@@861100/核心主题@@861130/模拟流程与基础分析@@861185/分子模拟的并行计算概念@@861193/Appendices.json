{"hands_on_practices": [{"introduction": "高效并行化分子动力学模拟的第一步是对模拟体系进行空间分解。此练习将指导您完成一个基本但至关重要的任务：基于相互作用截断半径和表皮距离，为元胞列表（cell list）方法设置合适的网格。通过计算最优的元胞数量和每个元胞内的平均原子数，您将亲身体验到在确保模拟准确性的同时，如何为高效的邻居搜索奠定基础，这是并行计算性能的关键。[@problem_id:3431951]", "problem": "在一个边长为 $L$、具有周期性边界条件的立方体盒子中，对一个数密度均匀的简单流体进行三维分子动力学模拟。为了能够使用单元列表进行高效的并行邻近原子搜索，该区域被划分为一个由立方体单元组成的均匀网格。单元边长 $a$ 的选择必须满足邻近列表安全条件 $a \\geq l_c$，其中列表单元尺寸 $l_c$ 等于用于对相互作用的保守截断半径 $r_c$ 与用于分摊邻近列表重建成本的非键合蒙皮距离 $\\Delta$ 之和。该实现为每个边选择整数个单元 $n$，使得 $a = L/n \\geq l_c$ 且在此约束下 $n$ 最大化，单元总数为 $N_{\\text{cell}} = n^3$。每个单元的平均原子数等于原子总数除以单元总数。\n\n给定 $r_c = 1.0$ nm，$\\Delta = 0.2$ nm，$\\rho = 33$ nm$^{-3}$，以及边长为 $L = 20$ nm 的立方体盒子，计算：\n- 网格中的单元总数 $N_{\\text{cell}}$，以及\n- 每个单元的平均原子数。\n\n使用列表单元尺寸 $l_c = r_c + \\Delta$，将数密度 $\\rho$ 视为均匀的，并假设原子总数为 $N = \\rho L^3$。将单元数报告为无量纲整数，并将每个单元的平均原子数报告为四舍五入到四位有效数字的无量纲量。", "solution": "该问题经验证是自洽、一致且科学上合理的。它代表了在设置带有区域分解的分子动力学模拟时的标准流程。我们开始进行解答。\n\n目标是计算 $2$ 个量：单元总数 $N_{\\text{cell}}$ 和每个单元的平均原子数。\n\n首先，我们确定每个边的最佳单元数 $n$。该实现要求单元边长 $a$ 必须满足安全条件 $a \\geq l_c$，其中 $l_c$ 是列表单元尺寸。列表单元尺寸是截断半径 $r_c$ 和非键合蒙皮距离 $\\Delta$ 的和。给定 $r_c = 1.0$ nm 和 $\\Delta = 0.2$ nm，我们计算 $l_c$：\n$$l_c = r_c + \\Delta = 1.0 \\text{ nm} + 0.2 \\text{ nm} = 1.2 \\text{ nm}$$\n单元边长 $a$ 由总盒子长度 $L$ 和每个边的单元数 $n$ 定义为 $a = L/n$。将此代入安全条件：\n$$\\frac{L}{n} \\geq l_c$$\n问题规定 $n$ 必须是整数，并且在此约束下最大化。我们可以重排不等式来求解 $n$：\n$$n \\leq \\frac{L}{l_c}$$\n使用给定的盒子边长 $L = 20$ nm 和计算出的 $l_c = 1.2$ nm 值：\n$$n \\leq \\frac{20 \\text{ nm}}{1.2 \\text{ nm}} = \\frac{200}{12} = \\frac{50}{3} \\approx 16.667$$\n由于 $n$ 必须是整数，满足此条件的最大 $n$ 值为 $16.667$ 的向下取整：\n$$n = \\lfloor 16.667 \\rfloor = 16$$\n既然我们已经确定了每个边的单元数，我们就可以计算三维网格中的单元总数 $N_{\\text{cell}}$。\n$$N_{\\text{cell}} = n^3 = 16^3 = 4096$$\n这是第一个所求的量。\n\n其次，我们计算每个单元的平均原子数。它等于原子总数 $N$ 除以单元总数 $N_{\\text{cell}}$。原子总数由均匀数密度 $\\rho$ 和模拟盒子的体积 $V = L^3$ 确定。给定 $\\rho = 33 \\text{ nm}^{-3}$ 和 $L = 20$ nm：\n$$N = \\rho V = \\rho L^3 = (33 \\text{ nm}^{-3}) \\times (20 \\text{ nm})^3 = 33 \\times 8000 = 264000$$\n因此，每个单元的平均原子数，我们记为 $\\langle N_{\\text{atoms/cell}} \\rangle$，为：\n$$\\langle N_{\\text{atoms/cell}} \\rangle = \\frac{N}{N_{\\text{cell}}} = \\frac{264000}{4096}$$\n进行除法运算得到精确值：\n$$\\langle N_{\\text{atoms/cell}} \\rangle = 64.453125$$\n问题要求将此值报告为四舍五入到 $4$ 位有效数字。前 $4$ 位有效数字是 $6$、$4$、$4$ 和 $5$。第五位有效数字是 $3$，小于 $5$，所以我们向下舍入。\n$$\\langle N_{\\text{atoms/cell}} \\rangle \\approx 64.45$$\n因此，计算出的 $2$ 个量是 $N_{\\text{cell}} = 4096$ 和每个单元的平均原子数约为 $64.45$。", "answer": "$$\\boxed{\\begin{pmatrix} 4096  64.45 \\end{pmatrix}}$$", "id": "3431951"}, {"introduction": "在将计算任务分配给各个处理器后，下一个挑战是如何在每个处理器上高效地执行这些任务。这个练习要求您构建一个性能模型，来分析两种关键内存布局——结构数组（AoS）和数组结构（SoA）——对计算核心性能的影响。通过推导吞吐量的解析表达式，您将深入理解数据布局如何与现代CPU架构（如SIMD指令集和缓存层次结构）相互作用，这是编写高性能科学计算代码的核心技能。[@problem_id:3431984]", "problem": "考虑一个经典的短程对偶分子动力学内核，该内核对每个中心粒子 $i$，使用单指令多数据（SIMD）宽度 $w$ 来评估其与 $w$ 个邻居粒子 $\\{j_{1},\\dots,j_{w}\\}$ 的对偶相互作用。假设以下经过充分测试的性能建模基础：\n\n1. 每次 SIMD 向量迭代的时间是算术项和内存流量项之和，其中后者与移动的缓存行数量成正比。这与屋顶线式分解一致，即当算术和数据移动没有完全重叠时，它们对执行时间的贡献是线性相加的。\n2. 对于内存，从主导的内存层级传输一个缓存行的成本是一个常数 $c_{L}$（单位：周期/行），非单位步长向量加载（gather）和非单位步长向量存储（scatter）分别增加每行 $c_{g}$ 和 $c_{s}$ 的开销。单位步长加载和存储不产生 gather/scatter 开销。\n3. 缓存行大小为 $B$ 字节。标量值（例如，一个坐标分量）的大小为 $a$ 字节。对于结构体数组（AoS）布局，每个粒子占用一个大小为 $s$ 字节的结构体，其中至少包含三个位置分量和三个力分量。对于数组结构体（SoA）布局，位置和力存储在独立的数组中，每个分量一个数组（例如，位置的 $x$、$y$、$z$ 和力的 $f_{x}$、$f_{y}$、$f_{z}$），每个元素占用 $a$ 字节。\n\n假设一个短程邻居列表，使得在一次 SIMD 向量迭代中，$w$ 个邻居索引 $\\{j_{k}\\}$ 在内存中实际上是不相关的（向量内部没有复用），因此：\n- 在 SoA 布局下，加载 $w$ 个邻居位置所访问的缓存行数为 $L_{\\mathrm{SoA},j}^{\\mathrm{load}} = 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil$，存储 $w$ 个邻居力更新所访问的缓存行数为 $L_{\\mathrm{SoA},j}^{\\mathrm{store}} = 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil$。\n- 在 AoS 布局下，加载 $w$ 个邻居位置（作为结构体）所访问的缓存行数为 $L_{\\mathrm{AoS},j}^{\\mathrm{load}} = \\left\\lceil \\frac{w s}{B} \\right\\rceil$，存储 $w$ 个邻居力更新所访问的缓存行数为 $L_{\\mathrm{AoS},j}^{\\mathrm{store}} = \\left\\lceil \\frac{w s}{B} \\right\\rceil$。\n\n对于中心粒子 $i$，假设其数据以单位步长访问，因此：\n- 在 SoA 布局下，$i$ 的位置访问 $L_{\\mathrm{SoA},i} = \\left\\lceil \\frac{3 a}{B} \\right\\rceil$ 个缓存行。\n- 在 AoS 布局下，$i$ 的结构体访问 $L_{\\mathrm{AoS},i} = \\left\\lceil \\frac{s}{B} \\right\\rceil$ 个缓存行。\n\n设每次对偶相互作用的算术成本为 $c_{c}$ 个周期（这包括浮点力计算，但不包括内存成本）。假设没有其他内存流量占主导地位（例如，就本问题而言，与位置和力相比，邻居索引的流量可以忽略不计），并且算术和内存成本之间没有重叠。\n\n将吞吐量定义为每个处理器周期完成的对偶相互作用次数。仅使用上述建模假设和定义，推导在 AoS 和 SoA 布局下 SIMD 向量迭代的吞吐量的闭式表达式，分别表示为 $T_{\\mathrm{AoS}}(w,B,a,s,c_{c},c_{L},c_{g},c_{s})$ 和 $T_{\\mathrm{SoA}}(w,B,a,s,c_{c},c_{L},c_{g},c_{s})$，单位均为“相互作用次数/周期”。用 $w$、$B$、$a$、$s$、$c_{c}$、$c_{L}$、$c_{g}$ 和 $c_{s}$ 来表示你的最终解析表达式。最终表达式中不要包含任何单位。无需进行数值计算。", "solution": "我们从屋顶线式原理开始，即每次 SIMD 向量迭代的时间是算术贡献和数据移动贡献之和。设一次 SIMD 向量迭代处理 $w$ 次对偶相互作用，即中心粒子 $i$ 与 $w$ 个邻居 $\\{j_{1},\\dots,j_{w}\\}$ 的相互作用。吞吐量（单位：相互作用次数/周期）是完成的相互作用次数除以该次迭代所花费的总周期数。因此，如果每次迭代的总周期数为 $C_{\\mathrm{iter}}$，则吞吐量为 $T = \\frac{w}{C_{\\mathrm{iter}}}$。\n\n我们现在从第一性原理出发，构建每种内存布局下的 $C_{\\mathrm{iter}}$。\n\n算术成本。根据假设，每次对偶相互作用的算术成本为 $c_c$ 个周期，并且与布局无关。对于每次迭代的 $w$ 对相互作用，算术成本为\n$$\nC_{\\mathrm{comp}} = c_{c} \\, w.\n$$\n\n内存成本模型。在主导内存层级计算时，每次缓存行传输的成本为 $c_{L}$ 个周期，无论是加载还是存储。此外，非单位步长向量加载（gather）会为 gather 访问的每个缓存行带来 $c_{g}$ 的开销，非单位步长向量存储（scatter）会为 scatter 访问的每个缓存行带来 $c_{s}$ 的开销。单位步长访问不产生这些 gather/scatter 开销。\n\n短程邻居列表的访问模式特征。在一次 SIMD 向量迭代中，邻居索引 $\\{j_{k}\\}$ 被假定在内存中是不相关的。这意味着，在向量粒度上，从数组（SoA）或结构体（AoS）中提取的 $w$ 个元素跨越了足够的地址，以至于访问的不同缓存行的数量可以很好地用寻址的总字节数除以缓存行大小 $B$ 再向上取整来近似。\n\n在数组结构体（SoA）布局下，每个坐标分量都存储在一个元素大小为 $a$ 字节的专用数组中。为了加载 $w$ 个邻居的位置，我们必须从 $x$、$y$ 和 $z$ 数组中 gather 数据，每个数组 $w$ 个元素。加载这些数据所访问的缓存行数为\n$$\nL_{\\mathrm{SoA},j}^{\\mathrm{load}} = 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil.\n$$\n类似地，为了将 $w$ 个邻居的力更新 scatter 到 $f_{x}$、$f_{y}$ 和 $f_{z}$ 数组中，所访问的缓存行数为\n$$\nL_{\\mathrm{SoA},j}^{\\mathrm{store}} = 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil.\n$$\n对于中心粒子 $i$，其数据以单位步长访问，加载其位置分量所访问的缓存行数为\n$$\nL_{\\mathrm{SoA},i} = \\left\\lceil \\frac{3 a}{B} \\right\\rceil.\n$$\n因为这些是单位步长访问，所以对粒子 $i$ 没有 gather 开销。\n\n在结构体数组（AoS）布局下，每个粒子占用一个大小为 $s$ 字节的结构体，其中至少包括三个位置分量和三个力分量。通过读取 $w$ 个结构体来 gather $w$ 个邻居的位置。加载所访问的缓存行数为\n$$\nL_{\\mathrm{AoS},j}^{\\mathrm{load}} = \\left\\lceil \\frac{w s}{B} \\right\\rceil,\n$$\n存储 $w$ 个邻居力更新所访问的缓存行数为\n$$\nL_{\\mathrm{AoS},j}^{\\mathrm{store}} = \\left\\lceil \\frac{w s}{B} \\right\\rceil.\n$$\n对于以单位步长访问的中心粒子 $i$，加载其结构体所访问的缓存行数为\n$$\nL_{\\mathrm{AoS},i} = \\left\\lceil \\frac{s}{B} \\right\\rceil.\n$$\n\nSoA 布局下的周期核算。每次迭代移动的缓存行总数（加载加存储）为\n$$\nL_{\\mathrm{SoA}}^{\\mathrm{tot}} = L_{\\mathrm{SoA},j}^{\\mathrm{load}} + L_{\\mathrm{SoA},j}^{\\mathrm{store}} + L_{\\mathrm{SoA},i} = 2 \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil + \\left\\lceil \\frac{3 a}{B} \\right\\rceil.\n$$\ngather 开销仅适用于邻居加载，为 $L_{\\mathrm{SoA},j}^{\\mathrm{load}}$ 中访问的每个缓存行增加 $c_{g}$。scatter 开销仅适用于邻居存储，为 $L_{\\mathrm{SoA},j}^{\\mathrm{store}}$ 中访问的每个缓存行增加 $c_{s}$。对于单位步长的中心粒子 $i$ 的加载，没有 gather/scatter 开销。因此，SoA 布局下每次迭代的总周期数为\n$$\nC_{\\mathrm{iter}}^{\\mathrm{SoA}} = c_{c} \\, w \\;+\\; c_{L} \\left( 2 \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil + \\left\\lceil \\frac{3 a}{B} \\right\\rceil \\right) \\;+\\; c_{g} \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil \\;+\\; c_{s} \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil.\n$$\n为方便起见，我们将邻居的 gather 和 scatter 开销合并：\n$$\nC_{\\mathrm{iter}}^{\\mathrm{SoA}} = c_{c} \\, w \\;+\\; c_{L} \\left( 6 \\left\\lceil \\frac{w a}{B} \\right\\rceil + \\left\\lceil \\frac{3 a}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil.\n$$\n因此，SoA 吞吐量（单位：相互作用次数/周期）为\n$$\nT_{\\mathrm{SoA}}(w,B,a,s,c_{c},c_{L},c_{g},c_{s}) \\;=\\; \\frac{w}{\\,c_{c} \\, w \\;+\\; c_{L} \\left( 6 \\left\\lceil \\frac{w a}{B} \\right\\rceil + \\left\\lceil \\frac{3 a}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\cdot 3 \\left\\lceil \\frac{w a}{B} \\right\\rceil\\,}.\n$$\n\nAoS 布局下的周期核算。每次迭代移动的缓存行总数（加载加存储）为\n$$\nL_{\\mathrm{AoS}}^{\\mathrm{tot}} = L_{\\mathrm{AoS},j}^{\\mathrm{load}} + L_{\\mathrm{AoS},j}^{\\mathrm{store}} + L_{\\mathrm{AoS},i} = 2 \\left\\lceil \\frac{w s}{B} \\right\\rceil + \\left\\lceil \\frac{s}{B} \\right\\rceil.\n$$\n如上所述，邻居加载产生 gather 开销，邻居存储产生 scatter 开销，均为每个缓存行。对于单位步长的中心粒子 $i$，没有 gather/scatter 开销。因此，AoS 布局下每次迭代的总周期数为\n$$\nC_{\\mathrm{iter}}^{\\mathrm{AoS}} = c_{c} \\, w \\;+\\; c_{L} \\left( 2 \\left\\lceil \\frac{w s}{B} \\right\\rceil + \\left\\lceil \\frac{s}{B} \\right\\rceil \\right) \\;+\\; c_{g} \\left\\lceil \\frac{w s}{B} \\right\\rceil \\;+\\; c_{s} \\left\\lceil \\frac{w s}{B} \\right\\rceil,\n$$\n或等价地，\n$$\nC_{\\mathrm{iter}}^{\\mathrm{AoS}} = c_{c} \\, w \\;+\\; c_{L} \\left( 2 \\left\\lceil \\frac{w s}{B} \\right\\rceil + \\left\\lceil \\frac{s}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\left\\lceil \\frac{w s}{B} \\right\\rceil.\n$$\n因此，AoS 吞吐量（单位：相互作用次数/周期）为\n$$\nT_{\\mathrm{AoS}}(w,B,a,s,c_{c},c_{L},c_{g},c_{s}) \\;=\\; \\frac{w}{\\,c_{c} \\, w \\;+\\; c_{L} \\left( 2 \\left\\lceil \\frac{w s}{B} \\right\\rceil + \\left\\lceil \\frac{s}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\left\\lceil \\frac{w s}{B} \\right\\rceil\\,}.\n$$\n\n这些表达式在所述的短程、不相关邻居的假设下，明确地展示了吞吐量对 SIMD 宽度 $w$、缓存行大小 $B$、标量大小 $a$、结构体大小 $s$、算术成本 $c_{c}$、缓存行传输成本 $c_{L}$ 以及 gather/scatter 开销 $c_{g}$ 和 $c_{s}$ 的依赖关系。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\dfrac{w}{\\,c_{c} \\, w \\;+\\; c_{L} \\left( 2 \\left\\lceil \\dfrac{w s}{B} \\right\\rceil + \\left\\lceil \\dfrac{s}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\left\\lceil \\dfrac{w s}{B} \\right\\rceil\\,} \n\\dfrac{w}{\\,c_{c} \\, w \\;+\\; c_{L} \\left( 6 \\left\\lceil \\dfrac{w a}{B} \\right\\rceil + \\left\\lceil \\dfrac{3 a}{B} \\right\\rceil \\right) \\;+\\; (c_{g} + c_{s}) \\cdot 3 \\left\\lceil \\dfrac{w a}{B} \\right\\rceil\\,}\n\\end{pmatrix}\n}\n$$", "id": "3431984"}, {"introduction": "静态的区域分解策略在均匀体系中表现良好，但当体系密度不均（例如存在空洞）时，就会出现严重的负载不平衡。本练习模拟了一种强大的动态负载均衡策略——工作窃取（work stealing）。您将通过编程实现一个调度器，来量化分析其在非均匀负载下的性能增益、调度开销，乃至对模拟可复现性的影响，从而深刻理解并行效率与算法复杂性之间的权衡。[@problem_id:3431949]", "problem": "考虑一个经典的分子动力学（MD）短程力计算，其空间域被分解为 $P$ 个子域，每个工作单元一个。每个子域 $i \\in \\{0,1,\\dots,P-1\\}$ 持有 $W_i$ 个等成本的交互区块。处理单个区块的确定性成本为 $t_u$ 微秒（每个区块的时间）。工作单元并发执行，并遵循一种跨子域的本地优先工作窃取（WS）策略，以缓解空洞（空的或稀疏的子域）问题。该 WS 策略每次窃取使用固定的块大小 $c$ 个区块，并且每次成功窃取会产生 $\\ell_s$ 微秒的窃取延迟。\n\n调度器定义如下。\n- 所有工作单元在时间 $0$ 开始，并在连续时间内执行。每个工作单元 $i$ 都有一个包含 $W_i$ 个区块的初始本地队列。\n- 一个尚有本地区块剩余的工作单元总是优先处理一个本地块。一个大小为 $q$ 个区块的块，其中 $q = \\min(c, \\text{剩余本地区块数})$，需要 $q \\cdot t_u$ 微秒完成，没有额外开销。\n- 当一个工作单元的本地队列为空时，它会尝试从一个受害者子域窃取。受害者被选为所有子域中剩余区块数量最多的那个（平局时由最小的子域索引打破）。如果受害者有 $r$ 个剩余区块，窃取者会窃取一个大小为 $q = \\min(c,r)$ 的块。在处理该块之前，窃取者需要付出 $\\ell_s$ 微秒的延迟。该被窃取块的处理时间在延迟之后为 $q \\cdot t_u$ 微秒。一旦窃取决定作出，受害者剩余的区块数量立即减少 $q$。如果整个系统中已无剩余区块，该工作单元将永久变为空闲。\n- 所有块的执行（本地和窃取的）都是非抢占式的。全局执行将持续到所有区块都被处理完毕。\n\n定义性能指标为 WS 下的并行完成时间（makespan），记为 $T_{\\text{steal}}$，即最后一个块完成的时间。定义无窃取时的静态基线完成时间为 $T_{\\text{base}} = \\max_{i} \\left(W_i \\cdot t_u\\right)$，其中每个工作单元只处理自己子域的区块，没有窃取也没有额外开销。定义加速比为 $S = T_{\\text{base}} / T_{\\text{steal}}$（无量纲）。定义可复现性暴露度指标为 $R$，即由窃取者（而非其所属子域的原始工作单元）处理的区块比例，即 $R = (\\text{总被窃取区块数})/\\left(\\sum_{i=0}^{P-1} W_i\\right)$，表示为小数（无百分号）。\n\n你的任务是精确地实现上述调度器，并为每个测试用例计算元组 $(T_{\\text{steal}}, S, R)$。时间 $T_{\\text{steal}}$ 必须以微秒为单位表示，为一个整数微秒值。加速比 $S$ 和可复现性暴露度 $R$ 必须作为十进制浮点值返回。\n\n你可以假设的基本前提：\n- 完成时间（makespan）的定义是并发工作单元中的最大完成时间。\n- 成本模型中，顺序块处理时间是可加的：一个 $q$ 区块的块需要 $q \\cdot t_u$ 微秒，而窃取会在块的计算时间开始前增加一个固定的延迟 $\\ell_s$。\n- 通过最小索引进行确定性平局打破，以确保调度是明确定义的。\n\n测试套件。对于每个用例，使用 $P=4$ 个工作单元（每个子域一个），参数如下，所有时间单位均为微秒：\n- 用例 1: $W=[800,50,0,50]$, $c=20$, $\\ell_s=40$, $t_u=1$.\n- 用例 2: $W=[200,200,200,200]$, $c=50$, $\\ell_s=5$, $t_u=1$.\n- 用例 3: $W=[0,0,0,1000]$, $c=10$, $\\ell_s=100$, $t_u=1$.\n- 用例 4: $W=[300,10,10,10]$, $c=64$, $\\ell_s=30$, $t_u=1$.\n- 用例 5: $W=[101,0,101,0]$, $c=1$, $\\ell_s=1$, $t_u=1$.\n\n要求的最终输出格式。你的程序应生成单行输出，其中包含所有结果，这些结果被扁平化为一个列表，形式为方括号括起来的逗号分隔列表。每个用例的结果必须按三元组 $\\left[T_{\\text{steal}}, S, R\\right]$ 的顺序附加，从而产生一个扁平化的列表，顺序为\n$[T_{\\text{steal}}^{(1)}, S^{(1)}, R^{(1)}, T_{\\text{steal}}^{(2)}, S^{(2)}, R^{(2)}, \\dots, T_{\\text{steal}}^{(5)}, S^{(5)}, R^{(5)}]$,\n其中 $T_{\\text{steal}}^{(k)}$ 是一个整数（微秒），$S^{(k)}$ 和 $R^{(k)}$ 是十进制浮点值。将 $T_{\\text{steal}}$ 以微秒表示，$S$ 和 $R$ 表示为小数（无百分号），且不包含任何额外文本。", "solution": "该问题要求模拟一个并行工作窃取调度器，以确定其性能特征。该系统由 $P$ 个工作单元组成，每个工作单元都有一个包含 $W_i$ 个工作区块的初始队列。调度策略是确定性的，因此适合进行精确模拟。此问题是一个定义明確的离散事件模拟任务。\n\n该解决方案被构建为一个离散事件模拟，这是一种用于建模在异步、离散时间点上演进的系统的标准方法。此模拟的核心组件是系统状态、事件以及一个事件驱动的控制循环。\n\n1.  **系统状态**：模拟的全局状态主要由每个子域队列中剩余的未处理区块数量定义。这通过一个大小为 $P$、用工作负载分布 $W$ 初始化的数组 `rem_tiles` 来表示。额外的状态变量跟踪被窃取的区块总数（`total_stolen_tiles`）和模拟的完成时间。\n\n2.  **事件**：一个“事件”被定义为一个工作单元完成其当前工作块并可用于新任务。每个事件由一个元组 $(t, i)$ 来表征，表示工作单元 $i$ 在时间 $t$ 变为空闲。\n\n3.  **事件队列与模拟循环**：一个按事件时间 $t$ 排序的优先队列管理事件序列。模拟开始时，将所有 $P$ 个工作单元在时间 $t=0$ 的初始事件填充到队列中。主循环重复地从队列中提取时间最小的事件，将模拟的 `current_time` 推进到此事件的时间，并处理该事件。\n\n4.  **事件处理逻辑**：当工作单元 $i$ 在 `current_time` 变为空闲时，根据指定策略分配一个新任务：\n    a. **本地工作**：工作单元首先检查自己的区块队列 `rem_tiles[i]`。如果 `rem_tiles[i]  0`，它会处理一个大小为 $q = \\min(c, \\text{rem\\_tiles}[i])$ 的本地块。该任务耗时 $q \\cdot t_u$ 微秒。一个对应于完成时间 `current_time` + $q \\cdot t_u$ 的新事件被添加到该工作单元的优先队列中。\n    \n    b. **工作窃取**：如果本地队列为空（`rem_tiles[i] == 0`），工作单元会尝试窃取。它将剩余区块数量最多的子域识别为受害者 $v$。平局通过选择索引最小的子域来打破，以确保确定性。如果找到了一个拥有非零区块的受害者，工作单元会窃取一个大小为 $q = \\min(c, \\text{rem\\_tiles}[v])$ 的块。受害者队列的状态 `rem_tiles[v]` 会立即减少。窃取者支付一个延迟成本 $\\ell_s$。这个被窃取任务的完成时间是 `current_time` + $\\ell_s$ + $q \\cdot t_u$。一个相应的完成事件被加入队列。\n    \n    c. **空闲**：如果一个工作单元的本地队列为空，并且系统中任何地方都没有剩余区块，该工作单元将永久变为空闲，并且不会被重新插入到事件队列中。\n\n5.  **终止与指标计算**：当事件队列变空时，模拟终止，这发生在所有区块被处理完毕且所有工作单元都变为空闲之后。工作窃取下的完成时间 $T_{\\text{steal}}$ 是所有任务中记录的最大完成时间。基线完成时间 $T_{\\text{base}}$ 计算为 $\\max_i(W_i \\cdot t_u)$。加速比 $S$ 是比率 $T_{\\text{base}} / T_{\\text{steal}}$，而可复现性暴露度 $R$ 是被窃取的区块总数与初始区块总数的比率。所有时间计算都按规定使用整数算術。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef run_simulation(P, W, c, l_s, t_u):\n    \"\"\"\n    Runs the discrete-event simulation for one test case to compute\n    makespan, speedup, and reproducibility exposure.\n    \n    Args:\n        P (int): Number of workers/subdomains.\n        W (list): Initial workload (number of tiles) for each subdomain.\n        c (int): Chunk size for processing and stealing.\n        l_s (int): Latency for a successful steal in microseconds.\n        t_u (int): Time to process a single tile in microseconds.\n        \n    Returns:\n        tuple: A tuple containing (T_steal, S, R).\n    \"\"\"\n    # Initialize state variables\n    rem_tiles = list(W)\n    total_initial_tiles = sum(W)\n    \n    # Handle the edge case of no work.\n    if total_initial_tiles == 0:\n        return (0, 1.0, 0.0)\n\n    total_stolen_tiles = 0\n    \n    # The event queue stores (finish_time, worker_id) tuples.\n    # heapq implements a min-priority queue perfectly suited for this.\n    # Python's tuple comparison breaks ties on finish_time by worker_id,\n    # ensuring deterministic processing of simultaneous events.\n    event_queue = []\n    for i in range(P):\n        heapq.heappush(event_queue, (0, i))\n\n    makespan = 0\n\n    # The simulation loop continues as long as there are workers with\n    # pending tasks in the event queue.\n    while event_queue:\n        # Dequeue the event with the earliest finish time.\n        current_time, worker_id = heapq.heappop(event_queue)\n\n        # Assign a new task to the now-available worker.\n\n        # PRIORITY 1: Process local work if available.\n        if rem_tiles[worker_id] > 0:\n            # Determine local chunk size.\n            q = min(c, rem_tiles[worker_id])\n            rem_tiles[worker_id] -= q\n            \n            # Calculate task duration and the worker's next finish time.\n            duration = q * t_u\n            finish_time = current_time + duration\n            makespan = max(makespan, finish_time)\n            \n            # Add the worker's next availability event to the queue.\n            heapq.heappush(event_queue, (finish_time, worker_id))\n\n        # PRIORITY 2: Attempt to steal work if local queue is empty.\n        else:\n            # Find a victim based on the specified policy: the subdomain with\n            # the largest number of tiles, with ties broken by smallest index.\n            max_tiles = -1\n            victim_idx = -1\n            for j in range(P):\n                if rem_tiles[j] > max_tiles:\n                    max_tiles = rem_tiles[j]\n                    victim_idx = j\n            \n            # If a victim with work is found, perform the steal.\n            if victim_idx != -1 and max_tiles > 0:\n                # Determine stolen chunk size.\n                q = min(c, rem_tiles[victim_idx])\n                \n                # Atomically update victim's tile count and total stolen count.\n                rem_tiles[victim_idx] -= q\n                total_stolen_tiles += q\n                \n                # Calculate task duration (including latency) and finish time.\n                duration = l_s + q * t_u\n                finish_time = current_time + duration\n                makespan = max(makespan, finish_time)\n                \n                # Add the thief's next availability event to the queue.\n                heapq.heappush(event_queue, (finish_time, worker_id))\n            # If no work is left anywhere, the worker becomes idle and is not\n            # pushed back onto the event queue, naturally ending its work life.\n\n    # Post-simulation metric calculations.\n    T_steal = int(makespan)\n    \n    T_base = max(W) * t_u if W else 0\n    \n    # S = T_base / T_steal\n    S = T_base / T_steal if T_steal > 0 else 1.0\n    \n    # R = (total stolen tiles) / (total initial tiles)\n    R = total_stolen_tiles / total_initial_tiles\n\n    return (T_steal, S, R)\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (W, c, l_s, t_u)\n        ([800, 50, 0, 50], 20, 40, 1),\n        ([200, 200, 200, 200], 50, 5, 1),\n        ([0, 0, 0, 1000], 10, 100, 1),\n        ([300, 10, 10, 10], 64, 30, 1),\n        ([101, 0, 101, 0], 1, 1, 1),\n    ]\n\n    P = 4 # Number of workers is fixed for all test cases.\n    \n    all_results = []\n    for case_params in test_cases:\n        W, c, l_s, t_u = case_params\n        # Run the simulation for the current case.\n        result_tuple = run_simulation(P, W, c, l_s, t_u)\n        # Append the flattened results to the final list.\n        all_results.extend(result_tuple)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3431949"}]}