{"hands_on_practices": [{"introduction": "在将分子动力学模拟扩展到大规模并行计算机上时，评估其性能至关重要。强标度效率（strong scaling efficiency）是衡量额外计算资源利用效果的关键指标。本练习将通过一个实际场景，帮助您理解和计算这一指标，并揭示随着处理器数量增加，通信开销如何成为性能瓶颈的关键因素。[@problem_id:3448088]", "problem": "使用空间域分解和消息传递接口 (MPI) 晕环交换，对一个具有周期性边界的稠密Lennard-Jones流体执行了三维分子动力学模拟。力计算采用截断半径 $r_c$ 和Verlet邻居列表。在一个分布式内存系统上，针对两个处理器数量 $P=64$ 和 $P=512$ 测量了每个时间步的墙上时钟时间。每个时间步的时间被分解为计算部分 $T_c(P)$（子域内的力和积分计算工作）和通信部分 $T_m(P)$（晕环交换和集体规约）。假设每个时间步的总时间满足 $T(P)=T_c(P)+T_m(P)$，并忽略输入/输出。\n\n测量到的时间如下：\n- 当 $P=64$ 时：$T_c(64)=2.40\\,\\mathrm{ms}$，$T_m(64)=0.35\\,\\mathrm{ms}$。\n- 当 $P=512$ 时：$T_c(512)=0.34\\,\\mathrm{ms}$，$T_m(512)=0.62\\,\\mathrm{ms}$。\n\n从强扩展加速比和效率的基本定义出发，且不引入任何额外的经验模型，推导在 $P=512$ 时相对于基准 $P_0=64$ 的强扩展效率表达式，该表达式应使用 $T(64)$、$T(512)$、$P$ 和 $P_0$ 表示。使用上述测量值对该效率进行数值计算。作为推理的一部分，根据判据 $T_m(P)>T_c(P)$，确定在 $P=512$ 时通信是否占主导地位，但仅报告效率值。\n\n将您的最终答案表示为一个无量纲小数，并四舍五入到四位有效数字。", "solution": "该问题被验证为具有科学依据、问题明确、客观且完整。求解所需的所有数据和条件均已提供，不存在矛盾或不成立的前提。该问题是并行计算性能分析中的一个标准练习。\n\n主要任务是推导并计算当分子动力学模拟从基准处理器数量 $P_0$ 扩展到更大的数量 $P$ 时的强扩展效率。\n\n强扩展分析假设总问题规模（在本例中为原子数量和模拟体积）保持不变，而处理器数量增加。\n\n加速比 $S(P)$ 定义为串行执行时间 $T_{serial}$（在单个处理器上）与在 $P$ 个处理器上的并行执行时间 $T(P)$ 之比。\n$$ S(P) = \\frac{T_{serial}}{T(P)} $$\n在许多实际场景中，真正的单处理器串行运行要么不可用，要么不切实际。取而代之的是，性能是相对于在 $P_0$ 个处理器上的基准运行来测量的。当处理器数量从 $P_0$ 增加到 $P$ 时，相对加速比 $S_{P_0 \\to P}$ 是它们执行时间之比：\n$$ S_{P_0 \\to P} = \\frac{T(P_0)}{T(P)} $$\n对于理想或线性扩展，将处理器数量从 $P_0$ 增加到 $P$ 所获得的加速比将等于处理器数量之比 $\\frac{P}{P_0}$。\n\n强扩展效率 $E_{P_0 \\to P}$ 是观测到的相对加速比与理想线性加速比之比。这提供了一个衡量额外计算资源被有效利用程度的指标。\n$$ E_{P_0 \\to P} = \\frac{\\text{观测到的加速比}}{\\text{理想加速比}} = \\frac{S_{P_0 \\to P}}{P/P_0} $$\n代入相对加速比的表达式，我们得到相对强扩展效率的公式：\n$$ E_{P_0 \\to P} = \\frac{T(P_0)/T(P)}{P/P_0} = \\frac{T(P_0) P_0}{T(P) P} $$\n这个效率表达式是根据要求从基本定义推导出来的，并用指定的变量表示。\n\n现在，我们将此公式应用于给定数据。基准和最终处理器数量分别为 $P_0 = 64$ 和 $P = 512$。\n每个时间步的总执行时间 $T(P)$ 是计算时间 $T_c(P)$ 和通信时间 $T_m(P)$ 的总和：\n$$ T(P) = T_c(P) + T_m(P) $$\n使用提供的数据：\n对于 $P_0=64$ 的基准运行：\n$$ T(64) = T_c(64) + T_m(64) = 2.40\\,\\mathrm{ms} + 0.35\\,\\mathrm{ms} = 2.75\\,\\mathrm{ms} $$\n对于扩展到 $P=512$ 的运行：\n$$ T(512) = T_c(512) + T_m(512) = 0.34\\,\\mathrm{ms} + 0.62\\,\\mathrm{ms} = 0.96\\,\\mathrm{ms} $$\n在计算效率之前，我们先解决第二个问题，即在 $P=512$ 时通信是否占主导地位。判据是 $T_m(P) > T_c(P)$。\n在 $P=512$ 时，我们有 $T_m(512) = 0.62\\,\\mathrm{ms}$ 和 $T_c(512) = 0.34\\,\\mathrm{ms}$。由于 $0.62\\,\\mathrm{ms} > 0.34\\,\\mathrm{ms}$，该条件得到满足，在此规模下通信时间确实超过了计算时间，占主导地位。这是强扩展中收益递减的常见原因。\n\n现在我们将总时间和处理器数量代入推导出的效率公式中：\n$$ E_{64 \\to 512} = \\frac{T(64) \\times 64}{T(512) \\times 512} = \\frac{2.75 \\times 64}{0.96 \\times 512} $$\n时间单位（ms）相消，得到一个无量纲的效率值。\n$$ E_{64 \\to 512} = \\frac{176}{491.52} $$\n进行除法运算：\n$$ E_{64 \\to 512} \\approx 0.3580729166... $$\n题目要求结果四舍五入到四位有效数字。\n$$ E_{64 \\to 512} \\approx 0.3581 $$\n该值表示，当处理器数量从 $64$ 扩展到 $512$ 时，该并行作业达到了理想线性加速比的约 $35.81\\%$。", "answer": "$$\\boxed{0.3581}$$", "id": "3448088"}, {"introduction": "空间分解策略的几何形状对通信成本有直接而深远的影响，进而影响整体并行效率。通过比较“板状”（slab）分解和“笔状”（pencil）分解这两种常见的策略，本练习将量化展示子区域的表面积-体积比如何成为优化通信的关键。掌握这一原理对于在大型分布式系统上设计高效的并行模拟至关重要。[@problem_id:3448083]", "problem": "考虑一个粒子数密度均匀的三维周期性分子动力学系统，其中短程对力通过球形截断进行计算。设在一个边长为 $L$ 的立方体区域中，总粒子数为 $N=10^6$。力截断半径为 $r_c$，通过带有晕环交换的空间区域分解方法实现。用于粒子-网格操作的网格是均匀的，有 $M_x \\times M_y \\times M_z = 256^3$ 个点。截断半径设为 $r_c = 3h$，其中 $h=L/256$ 是网格间距。\n\n假设在 $P=512$ 个处理器上采用以下两种分解方式：\n1. 板状分解：$P_x=1$, $P_y=1$, $P_z=512$，因此每个子区域的尺寸为 $l_x=L$, $l_y=L$, $l_z=L/512$。\n2. 笔状分解：$P_x=16$, $P_y=32$, $P_z=1$，因此每个子区域的尺寸为 $l_x=L/16$, $l_y=L/32$, $l_z=L$。\n\n假设采用一个标准的三阶段晕环交换协议，该协议保证每个进程能接收到其子区域周围厚度为 $r_c$ 的并集晕环内的所有粒子。因此，每个进程的预期通信粒子数等于粒子数密度 $\\rho=N/L^3$ 乘以并集暈環的體積\n$$\nV_{\\mathrm{halo}}=(l_x+2r_c)(l_y+2r_c)(l_z+2r_c)-l_x l_y l_z.\n$$\n将总预期通信量定义为在一个力交换步骤中通过网络发送的预期粒子总数，等于对所有进程求和后的 $P \\rho V_{\\mathrm{halo}}$。\n\n仅使用上述假设和定义，计算板状分解的总预期通信量与笔状分解的总预期通信量之比 $\\mathcal{R}$。将最终答案表示为一个四舍五入到四位有效数字的实数。", "solution": "用户提供的问题通过了所有验证标准。该问题在计算分子动力学领域具有科学依据，提法恰当，包含了所有必要信息，并且陈述客观。数据一致且物理上合理。因此，我将提供完整解答。\n\n目标是计算板状分解与笔状分解的总预期通信量之比 $\\mathcal{R}$。总预期通信量 $C$ 定义为 $P \\rho V_{\\mathrm{halo}}$，其中 $P$ 是处理器数量，$\\rho$ 是粒子数密度，$V_{\\mathrm{halo}}$ 是单个处理器子区域的晕环区域体积。\n\n设 $C_S$ 和 $V_{\\mathrm{halo}, S}$ 分别为板状分解的总通信量和单子区域晕环体积。\n设 $C_P$ 和 $V_{\\mathrm{halo}, P}$ 分别为笔状分解的总通信量和单子区域晕环体积。\n\n比率 $\\mathcal{R}$ 由下式给出：\n$$\n\\mathcal{R} = \\frac{C_S}{C_P} = \\frac{P \\rho V_{\\mathrm{halo}, S}}{P \\rho V_{\\mathrm{halo}, P}}\n$$\n由于两种情况下处理器数量 $P$ 和密度 $\\rho$ 相同，它们可以被消去，比率简化为：\n$$\n\\mathcal{R} = \\frac{V_{\\mathrm{halo}, S}}{V_{\\mathrm{halo}, P}}\n$$\n问题给出了晕环体积的公式：\n$$\nV_{\\mathrm{halo}} = (l_x+2r_c)(l_y+2r_c)(l_z+2r_c) - l_x l_y l_z\n$$\n其中 $l_x$、$l_y$ 和 $l_z$ 是子区域的尺寸，$r_c$ 是力截断半径。请注意，此计算不需要总粒子数 $N=10^6$。\n\n为便于计算，我们用网格间距 $h$ 来表示所有长度。问题陈述如下：\n- 立方体区域的边长为 $L$。\n- 网格有 $256^3$ 个点，因此网格间距为 $h = L/256$。这意味着 $L = 256h$。\n- 力截断半径为 $r_c = 3h$。\n\n首先，我们分析板状分解。\n处理器排列为 $P_x=1$, $P_y=1$, $P_z=512$。板状分解情况（$S$）的子区域尺寸为：\n$l_{x,S} = \\frac{L}{P_x} = \\frac{L}{1} = L = 256h$\n$l_{y,S} = \\frac{L}{P_y} = \\frac{L}{1} = L = 256h$\n$l_{z,S} = \\frac{L}{P_z} = \\frac{L}{512} = \\frac{256h}{512} = 0.5h$\n\n现在我们计算晕环体积 $V_{\\mathrm{halo}, S}$：\n$$\nV_{\\mathrm{halo}, S} = (l_{x,S}+2r_c)(l_{y,S}+2r_c)(l_{z,S}+2r_c) - l_{x,S}l_{y,S}l_{z,S}\n$$\n将尺寸用 $h$ 代入：\n$$\nV_{\\mathrm{halo}, S} = (256h + 2(3h))(256h + 2(3h))(0.5h + 2(3h)) - (256h)(256h)(0.5h)\n$$\n$$\nV_{\\mathrm{halo}, S} = (256h + 6h)(256h + 6h)(0.5h + 6h) - (256 \\times 256 \\times 0.5)h^3\n$$\n$$\nV_{\\mathrm{halo}, S} = (262h)(262h)(6.5h) - (32768)h^3\n$$\n$$\nV_{\\mathrm{halo}, S} = (262^2 \\times 6.5)h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, S} = (68644 \\times 6.5)h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, S} = 446186h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, S} = 413418h^3\n$$\n\n接下来，我们分析笔状分解。\n处理器排列为 $P_x=16$, $P_y=32$, $P_z=1$。笔状分解情况（$P$）的子区域尺寸为：\n$l_{x,P} = \\frac{L}{P_x} = \\frac{L}{16} = \\frac{256h}{16} = 16h$\n$l_{y,P} = \\frac{L}{P_y} = \\frac{L}{32} = \\frac{256h}{32} = 8h$\n$l_{z,P} = \\frac{L}{P_z} = \\frac{L}{1} = L = 256h$\n\n现在我们计算晕环体积 $V_{\\mathrm{halo}, P}$：\n$$\nV_{\\mathrm{halo}, P} = (l_{x,P}+2r_c)(l_{y,P}+2r_c)(l_{z,P}+2r_c) - l_{x,P}l_{y,P}l_{z,P}\n$$\n将尺寸用 $h$ 代入：\n$$\nV_{\\mathrm{halo}, P} = (16h + 2(3h))(8h + 2(3h))(256h + 2(3h)) - (16h)(8h)(256h)\n$$\n$$\nV_{\\mathrm{halo}, P} = (16h + 6h)(8h + 6h)(256h + 6h) - (16 \\times 8 \\times 256)h^3\n$$\n$$\nV_{\\mathrm{halo}, P} = (22h)(14h)(262h) - (32768)h^3\n$$\n$$\nV_{\\mathrm{halo}, P} = (22 \\times 14 \\times 262)h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, P} = (308 \\times 262)h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, P} = 80696h^3 - 32768h^3\n$$\n$$\nV_{\\mathrm{halo}, P} = 47928h^3\n$$\n\n最后，我们计算比率 $\\mathcal{R}$：\n$$\n\\mathcal{R} = \\frac{V_{\\mathrm{halo}, S}}{V_{\\mathrm{halo}, P}} = \\frac{413418h^3}{47928h^3} = \\frac{413418}{47928}\n$$\n$$\n\\mathcal{R} \\approx 8.625801201552328\n$$\n问题要求答案四舍五入到四位有效数字。\n$$\n\\mathcal{R} \\approx 8.626\n$$\n这个结果证实了一个计算原理：产生更接近“立方体”形状子区域的区域分解方法（如此处的笔状分解，其尺寸为 $16h \\times 8h \\times 256h$），在通信量方面比产生高度各向异性子区域的分解方法（如板状分解，其尺寸为 $256h \\times 256h \\times 0.5h$）更高效，因为它们最小化了子区域的表面积与体积之比。", "answer": "$$\n\\boxed{8.626}\n$$", "id": "3448083"}, {"introduction": "真实的物理系统很少是均匀的，例如液滴在蒸汽中的存在会导致计算负载在空间上极不均衡。为了在这种情况下实现高效的并行化，必须采用负载均衡策略，即为工作量大的区域分配较小的空间域。本练习将指导您实现加权递归二分法（Weighted Recursive Bisection），这是一种强大的算法，用于根据非均匀的工作密度对系统进行分区，确保每个处理器承担相近的计算任务。[@problem_id:3448085]", "problem": "一个边长为 $L$（单位为 $\\mathrm{nm}$）的立方模拟盒子中，包含一个半径为 $R$（单位为 $\\mathrm{nm}$）的致密球形液滴，该液滴以 $x$ 轴上的位置 $x_0$ 为中心，盒子其余部分为稀疏的蒸汽。考虑一个短程对相互作用势，根据牛顿定律和在固定截断半径下力的局域性，分子动力学（MD）一个步骤的计算功主要由对评估主导。在连续介质近似中，设局域数密度为 $n(\\mathbf{r})$（单位为 $\\mathrm{nm}^{-3}$），单位体积的局域功密度与 $n(\\mathbf{r})^2$ 成正比，因为在一个小邻域内相互作用的粒子对数量与该邻域内粒子数的平方成比例。假设采用两相近似，液滴内部的 $n(\\mathbf{r}) = n_d$，蒸汽中的 $n(\\mathbf{r}) = n_v$，且 $n_d \\gg n_v$。\n\n为了给 $P$ 个处理器构建沿 $x$ 轴的一维分解，通过对与 $x$ 轴对齐的平板上的功密度进行积分来估算每个处理器的功。假设盒子是周期性的，并且液滴被完全包含（$R \\le L/2$），因此横截面是明确的。在给定的 $x$ 处，位于液滴内部的横截面积是一个半径为 $\\sqrt{R^2 - (x - x_0)^2}$ 的圆的面积（当 $\\lvert x - x_0 \\rvert \\le R$ 时），否则为零，而 $y$–$z$ 平面中直到面积 $L^2$ 的剩余部分是蒸汽。因此，每无穷小宽度 $\\mathrm{d}x$ 的平板功与 $n_d^2$ 乘以内部面积加上 $n_v^2$ 乘以外部面积成正比。您的目标是将区间 $[0,L]$ 划分为 $P$ 个连续的子域，使得每个子域中的估算总功相等，使用简单的加权递归二分法（WRB）：递归地将一个区间按分配给两侧的处理器数量的比例分割成两个子区间，并将分割点置于累计估算功达到所需比例的 $x$ 处。\n\n从第一性原理出发，实现以下步骤：\n- 将 $[0,L]$ 离散化为 $N_x$ 个均匀单元格，其边界为 $x_i$，宽度为 $\\Delta x = L/N_x$。通过在单元格中心评估横截面积并乘以 $\\Delta x$ 来近似单元格 $i$ 中的平板功，从而获得一个非负权重 $w_i$。\n- 在离散权重 $w_i$ 和边界 $x_i$ 上实现加权递归二分法以产生域边界。对于一个分配了 $P$ 个处理器的区间，将其分割为 $P_\\ell = \\lfloor P/2 \\rfloor$ 和 $P_r = P - P_\\ell$ 的两个部分，放置分割位置，使得累计权重等于该区间总权重的 $(P_\\ell/P)$。然后分别用 $P_\\ell$ 和 $P_r$ 在每一侧进行递归。当分割点位于一个单元格内部时，在该单元格内进行线性插值以放置分割点，并相应地分配该单元格的权重，以便后续的递归操作在与分割一致的精确子区间权重上进行。\n- 返回包括 $0$ 和 $L$ 在内的完整域边界列表。\n\n物理单位：所有长度输入和输出必须以 $\\mathrm{nm}$ 为单位。数密度以 $\\mathrm{nm}^{-3}$ 为单位。最终的域边界坐标必须以 $\\mathrm{nm}$ 为单位报告，四舍五入到 $6$ 位小数。\n\n测试套件：\n- 案例 $1$ (非对称液滴，2的幂次方数量的处理器)：$L = 10.0$, $R = 2.0$, $x_0 = 6.0$, $n_d = 30.0$, $n_v = 1.0$, $N_x = 2000$, $P = 4$。\n- 案例 $2$ (非对称液滴，非2的幂次方数量的处理器)：$L = 10.0$, $R = 2.0$, $x_0 = 6.0$, $n_d = 30.0, n_v = 1.0, N_x = 2000, P = 3$。\n- 案例 $3$ (无液滴，均匀蒸汽)：$L = 10.0$, $R = 0.0$, $x_0 = 6.0$, $n_d = 30.0, n_v = 1.0, N_x = 2000, P = 4$。\n- 案例 $4$ (居中液滴，两个处理器)：$L = 10.0$, $R = 2.0$, $x_0 = 5.0$, $n_d = 30.0, n_v = 1.0, N_x = 2000, P = 2$。\n\n您的程序应计算每种情况的边界，并生成单行输出，其中包含四个结果，格式为一个用方括号括起来的逗号分隔列表，每个结果本身是从 $0$ 到 $L$ 按升序排列的边界坐标列表，每个坐标四舍五入到 $6$ 位小数。例如，包含两个案例的输出应如下所示：$[[0.000000,2.500000,5.000000],[0.000000,5.000000,10.000000]]$；您必须按此格式准确生成一行输出，其中包含按顺序列出的四个案例。", "solution": "用户想要解决一个分子动力学模拟的域分解问题。\n\n### 步骤1：提取给定信息\n- **模拟盒子**：立方体，边长 $L$ (nm)。\n- **系统**：一个半径为 $R$ (nm) 的球形液滴，以x轴上的 $x_0$ 为中心，周围是稀疏的蒸汽。\n- **数密度**：$n(\\mathbf{r}) = n_d$ (液滴, $\\mathrm{nm}^{-3}$)，$n(\\mathbf{r}) = n_v$ (蒸汽, $\\mathrm{nm}^{-3}$)，且 $n_d \\gg n_v$。\n- **功模型**：局域功密度与 $n(\\mathbf{r})^2$ 成正比。\n- **分解**：沿x轴为 $P$ 个处理器进行一维分解。\n- **假设**：盒子是周期性的，并且液滴被完全包含（$R \\le L/2$）。\n- **功剖面**：在位置 $x$ 处，宽度为 $\\mathrm{d}x$ 的无穷小平板中的功与 $W(x) \\mathrm{d}x$ 成正比，其中 $W(x) = (n_d^2 - n_v^2)A_{droplet}(x) + n_v^2 L^2$。\n- **液滴横截面**：当 $|x - x_0| \\le R$ 时，$A_{droplet}(x) = \\pi(R^2 - (x - x_0)^2)$，否则为 $0$。\n- **离散化**：区间 $[0, L]$ 被离散化为 $N_x$ 个宽度为 $\\Delta x = L/N_x$ 的均匀单元格。\n- **单元格权重**：单元格 $i$ 中的功 $w_i$ 通过在单元格中心评估功密度并乘以 $\\Delta x$ 来近似。\n- **算法**：加权递归二分法（WRB）。\n  - 一个用于 $P$ 个处理器的区间被分割为两个，分别用于 $P_\\ell = \\lfloor P/2 \\rfloor$ 和 $P_r = P - P_\\ell$ 个处理器。\n  - 分割点放置在累积功占该区间总功比例为 $P_\\ell/P$ 的位置。\n  - 此过程递归应用。\n  - 如果分割点落在一个单元格内，则使用线性插值来找到坐标。\n- **输出**：对于每个测试案例，从 $0$到 $L$ 的所有域边界列表，坐标四舍五入到6位小数。\n- **测试案例**：\n  1. $L=10.0, R=2.0, x_0=6.0, n_d=30.0, n_v=1.0, N_x=2000, P=4$。\n  2. $L=10.0, R=2.0, x_0=6.0, n_d=30.0, n_v=1.0, N_x=2000, P=3$。\n  3. $L=10.0, R=0.0, x_0=6.0, n_d=30.0, n_v=1.0, N_x=2000, P=4$。\n  4. $L=10.0, R=2.0, x_0=5.0, n_d=30.0, n_v=1.0, N_x=2000, P=2$。\n\n### 步骤2：使用提取的给定信息进行验证\n问题陈述经过严格评估如下：\n- **基于科学依据**：该问题基于计算物理学中一个健全且广泛使用的近似方法。短程MD模拟的计算成本与局域粒子密度的平方（$n^2$）成比例的假设是估算负载的标准模型，因为它反映了对相互作用的尺度变化关系。几何和物理学与既定原理一致。\n- **适定的**：问题定义明确。输入已指定，物理模型明确，算法（加权递归二分法）的描述足够详细，包括离散化和插值方法。这种结构确保了可以通过算法确定一个唯一且稳定的解。\n- **客观的**：语言精确、量化，没有主观或模糊的术语。\n\n该问题没有表现出任何无效性缺陷：\n1.  **科学/事实不健全**：没有违反科学原理。\n2.  **非形式化/不相关**：该问题是分子动力学中分解策略的直接且相关的应用。\n3.  **不完整/矛盾的设置**：提供了所有必需的参数。所有测试案例都满足条件 $R \\le L/2$，确保模型自洽。\n4.  **不切实际/不可行**：物理参数在纳米级模拟的现实范围内。\n5.  **不适定/结构不良**：规定的算法导致一组唯一的边界。\n6.  **伪深刻/琐碎**：该问题要求在一个离散近似的连续域上实现一个非平凡的递归划分算法，代表了一项真正的计算任务。测试案例经过精心选择，以测试算法的不同方面。\n7.  **超出科学可验证性**：结果是可通过计算验证的。\n\n### 步骤3：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n---\n\n问题的核心是在空间域 $[0, L]$ 上定义的功剖面上实现加权递归二分算法。一个稳健的实现方法是使用从细粒度离散化中近似出的累积功的连续表示。\n\n**1. 离散化功剖面**\n首先，我们将域 $[0,L]$ 离散化为 $N_x$ 个宽度为 $\\Delta x = L/N_x$ 的单元格。对于每个单元格 $i \\in \\{0, 1, ..., N_x-1\\}$，我们计算其计算权重 $w_i$。该权重与相应体积为 $L^2 \\Delta x$ 的平板中所做的功成正比。我们通过在单元格中心 $x_{c,i} = (i+0.5)\\Delta x$ 处评估功密度来近似它。\n\n单位体积的功与 $n(\\mathbf{r})^2$ 成正比。通过对其横截面积分，可以找到厚度为 $\\mathrm{d}x$ 的平板中的功：\n$$ \\mathrm{d}W \\propto [n_d^2 A_{droplet}(x) + n_v^2 (L^2 - A_{droplet}(x))] \\mathrm{d}x $$\n设功剖面函数为 $W'(x) = (n_d^2 - n_v^2)A_{droplet}(x) + n_v^2 L^2$，其中当 $|x-x_0| \\le R$ 时 $A_{droplet}(x) = \\pi(R^2 - (x - x_0)^2)$，否则为 $0$。单元格 $i$ 的权重则为 $w_i = W'(x_{c,i}) \\Delta x$。\n\n**2. 连续累积功及其逆函数**\n从离散权重 $w_i$，我们可以构建一个近似的连续累积功函数 $C(x)$，表示区间 $[0,x]$ 内的总功。这通过将所有完全位于 $x$ 左侧的单元格的权重相加，并加上 $x$ 所在的单元格的按比例权重来完成。\n$$ C(x) \\approx \\sum_{j=0}^{i-1} w_j + w_i \\frac{x - x_i}{\\Delta x}, \\quad \\text{其中 } x \\in [x_i, x_{i+1}] $$\n这里，$x_i = i \\Delta x$ 是单元格 $i$ 的左边界。使用预先计算的累积权重数组 $S_i = \\sum_{j=0}^{i} w_j$ 可以高效地计算此函数。\n\n反过来，我们需要逆函数 $C^{-1}(W)$，它给出对应于给定累积功 $W$ 的坐标 $x$。这可以通过首先确定达到累积功 $W$ 的单元格 $i$（即 $S_{i-1} \\le W  S_i$），然后在该单元格内使用线性插值来找到精确坐标。\n\n**3. 加权递归二分法（WRB）算法**\nWRB算法通过管理一个任务队列来实现。每个任务是一个元组 `(x_start, x_end, P_current)`，表示一个待在 $P_{current}$ 个处理器之间划分的区间 $[x_{start}, x_{end}]$。\n\n该过程从单个任务开始：$(0, L, P)$。对于每个任务：\n- 如果 $P_{current} \\le 1$，则该区间无需进一步分割。\n- 如果 $P_{current} > 1$，我们计算左右子问题的处理器数量：$P_\\ell = \\lfloor P_{current}/2 \\rfloor$ 和 $P_r = P_{current} - P_\\ell$。\n- 区间 $[x_{start}, x_{end}]$ 必须在一个坐标 $x_{split}$ 处分割，使得功按 $P_\\ell : P_r$ 的比例划分。左区间的功分数为 $f = P_\\ell / P_{current}$。\n- 我们找到当前区间的总功，$W_{interval} = C(x_{end}) - C(x_{start})$。\n- 分割点的目标累积功（从原点测量）为 $W_{target} = C(x_{start}) + f \\cdot W_{interval}$。\n- 然后使用逆累积功函数找到分割坐标：$x_{split} = C^{-1}(W_{target})$。\n- 记录这个新的边界 $x_{split}$，并将两个新任务 $(x_{start}, x_{split}, P_\\ell)$ 和 $(x_{split}, x_{end}, P_r)$ 添加到队列中。\n\n此过程持续进行，直到所有区间都分配给单个处理器。最终结果是唯一的边界坐标的排序列表，并增补 $0$ 和 $L$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\nclass DomainDecomposer:\n    \"\"\"\n    Handles the calculation of domain decomposition boundaries for a given\n    MD system profile using weighted recursive bisection.\n    \"\"\"\n    def __init__(self, L, R, x0, nd, nv, Nx):\n        \"\"\"\n        Initializes the decomposer with system parameters and pre-computes\n        the work profile.\n\n        Args:\n            L (float): Side length of the cubic simulation box.\n            R (float): Radius of the spherical droplet.\n            x0 (float): x-coordinate of the droplet center.\n            nd (float): Number density inside the droplet.\n            nv (float): Number density in the vapor.\n            Nx (int): Number of discretization cells along the x-axis.\n        \"\"\"\n        self.L = float(L)\n        self.R = float(R)\n        self.x0 = float(x0)\n        self.nd = float(nd)\n        self.nv = float(nv)\n        self.Nx = int(Nx)\n        \n        self.dx = self.L / self.Nx if self.Nx > 0 else self.L\n        \n        self._calculate_weights()\n\n    def _calculate_weights(self):\n        \"\"\"\n        Calculates the discrete work weights for each cell and their\n        cumulative sum based on the continuum model.\n        \"\"\"\n        if self.Nx == 0:\n            self.weights = np.array([])\n            self.cumulative_weights = np.array([])\n            self.total_work = 0.0\n            return\n\n        cell_centers = np.linspace(self.dx / 2.0, self.L - self.dx / 2.0, self.Nx)\n        \n        # Calculate work density profile W'(x)\n        nd2_minus_nv2 = self.nd**2 - self.nv**2\n        nv2_L2 = self.nv**2 * self.L**2\n        \n        # Vectorized calculation for droplet cross-sectional area\n        dist_sq = (cell_centers - self.x0)**2\n        A_droplet = np.zeros_like(cell_centers)\n        mask = dist_sq = self.R**2\n        A_droplet[mask] = np.pi * (self.R**2 - dist_sq[mask])\n        \n        work_density_prime = nd2_minus_nv2 * A_droplet + nv2_L2\n        \n        self.weights = work_density_prime * self.dx\n        self.cumulative_weights = np.cumsum(self.weights)\n        self.total_work = self.cumulative_weights[-1] if len(self.cumulative_weights) > 0 else 0.0\n\n    def get_work_from_coord(self, x):\n        \"\"\"Calculates the cumulative work from 0 to coordinate x.\"\"\"\n        if x = 0.0:\n            return 0.0\n        if x >= self.L:\n            return self.total_work\n            \n        # Determine cell index and fraction within the cell\n        idx = int(x / self.dx)\n        if idx >= self.Nx:\n            idx = self.Nx - 1\n            \n        cell_start_coord = idx * self.dx\n        fraction = (x - cell_start_coord) / self.dx\n        \n        work_in_cell_part = self.weights[idx] * fraction\n        \n        prev_cumulative_work = self.cumulative_weights[idx - 1] if idx > 0 else 0.0\n        \n        return prev_cumulative_work + work_in_cell_part\n\n    def get_coord_from_work(self, work):\n        \"\"\"Calculates the coordinate x for a given cumulative work.\"\"\"\n        if work = 0.0:\n            return 0.0\n        if work >= self.total_work:\n            return self.L\n            \n        # Find cell index where cumulative work W is reached\n        idx = np.searchsorted(self.cumulative_weights, work, side='left')\n        \n        prev_cumulative_work = self.cumulative_weights[idx - 1] if idx > 0 else 0.0\n        work_into_cell = work - prev_cumulative_work\n        cell_weight = self.weights[idx]\n        cell_start_coord = idx * self.dx\n        \n        if cell_weight == 0.0:\n            # If target work falls on a boundary before a zero-weight cell region,\n            # place the split at the start of that region.\n            return cell_start_coord\n\n        fraction = work_into_cell / cell_weight\n        \n        return cell_start_coord + fraction * self.dx\n\n    def calculate_boundaries(self, P):\n        \"\"\"\n        Performs weighted recursive bisection to find domain boundaries.\n\n        Args:\n            P (int): The number of processors.\n\n        Returns:\n            list: A sorted list of domain boundaries from 0 to L.\n        \"\"\"\n        if P = 1:\n            return [0.0, self.L]\n\n        boundaries = set()\n        tasks = [(0.0, self.L, P)]  # (x_start, x_end, num_procs)\n\n        while tasks:\n            x_start, x_end, p_curr = tasks.pop(0)\n\n            if p_curr = 1:\n                continue\n\n            p_left = p_curr // 2\n            p_right = p_curr - p_left\n            work_frac = p_left / p_curr\n\n            work_start = self.get_work_from_coord(x_start)\n            work_end = self.get_work_from_coord(x_end)\n            \n            interval_work = work_end - work_start\n\n            if interval_work == 0.0:\n                # Fallback for zero-work intervals: geometric split\n                x_split = x_start + (x_end - x_start) * work_frac\n            else:\n                target_cumulative_work = work_start + interval_work * work_frac\n                x_split = self.get_coord_from_work(target_cumulative_work)\n\n            boundaries.add(x_split)\n\n            tasks.append((x_start, x_split, p_left))\n            tasks.append((x_split, x_end, p_right))\n        \n        final_boundaries = [0.0] + sorted(list(boundaries)) + [self.L]\n        return final_boundaries\n\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases and prints the results\n    in the specified format.\n    \"\"\"\n    test_cases = [\n        # L, R, x0, nd, nv, Nx, P\n        (10.0, 2.0, 6.0, 30.0, 1.0, 2000, 4),\n        (10.0, 2.0, 6.0, 30.0, 1.0, 2000, 3),\n        (10.0, 0.0, 6.0, 30.0, 1.0, 2000, 4),\n        (10.0, 2.0, 5.0, 30.0, 1.0, 2000, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, R, x0, nd, nv, Nx, P = case\n        decomposer = DomainDecomposer(L, R, x0, nd, nv, Nx)\n        boundaries = decomposer.calculate_boundaries(P)\n        \n        formatted_boundaries = [f\"{b:.6f}\" for b in boundaries]\n        results.append(f\"[{','.join(formatted_boundaries)}]\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3448085"}]}