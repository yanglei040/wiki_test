{"hands_on_practices": [{"introduction": "线性相关系数不足以捕捉生物分子运动中复杂的非线性关系，而高阶统计量（如三阶累积量）是量化这种非谐性的有力工具。本练习 [@problem_id:3406423] 提供了一个简化的确定性模型，旨在帮助你建立关于如何计算和解释非谐耦合系数的基础直觉。这些系数衡量了不同运动模式之间的非线性相互作用，是深入理解变构效应和信号传导机制的关键。", "problem": "给定一个确定性的分子动力学式设置，通过将轨迹投影到低频模态上，并从三阶累积量计算非谐模态耦合系数，来量化一个简化生物分子模型中的关联运动。请基于简正模投影和联合累积量的基本定义进行计算。目标是实现一个程序，针对三个指定的测试用例，基于三个投影模态坐标的归一化三阶累积量，计算一个无量纲耦合系数。\n\n假设与定义：\n- 系统由一个代表生物分子局部区域的粗粒化珠子组成。设该珠子的质量为 $m$，以统一原子质量单位 (u) 计量，其中 $m = 12\\,\\mathrm{u}$。\n- 该珠子具有三个笛卡尔自由度。设珠子的位置为 $\\mathbf{r}(t) = (x(t), y(t), z(t))$，单位为纳米 (nm)，时间 $t$ 的单位为皮秒 (ps)。\n- 低频模态基由一个质量正交归一的特征向量矩阵 $\\mathbf{V} \\in \\mathbb{R}^{3 \\times 3}$ 提供，对于质量矩阵 $\\mathbf{M} = m\\,\\mathbf{I}$，该矩阵满足 $\\mathbf{V}^\\top \\mathbf{M} \\mathbf{V} = \\mathbf{I}$。使用 $\\mathbf{V} = \\mathbf{I}/\\sqrt{m}$，其中 $\\mathbf{I}$ 是 $3 \\times 3$ 单位矩阵。设三个低频角频率（单位为弧度/皮秒，$\\mathrm{rad/ps}$）为 $\\boldsymbol{\\omega} = (\\omega_1, \\omega_2, \\omega_3) = (0.10, 0.08, 0.06)$；这些频率不用于任何数值计算，仅用于将这些模态识别为“低频”。\n- 对于长度为 $T$ 帧的轨迹段，将笛卡尔轨迹的时间平均值表示为 $\\overline{\\mathbf{r}} = \\frac{1}{T} \\sum_{t=1}^{T} \\mathbf{r}(t)$，并将涨落定义为 $\\delta \\mathbf{r}(t) = \\mathbf{r}(t) - \\overline{\\mathbf{r}}$。\n- 将涨落到模态 $\\alpha$ 上的质量加权投影定义为 $q_\\alpha(t) = \\sum_{i=1}^{3} \\sum_{j=1}^{3} V_{i\\alpha} \\left(M^{1/2}\\right)_{ij} \\delta r_j(t)$，其中 $\\mathbf{M}^{1/2}$ 是质量矩阵的对称平方根，因此 $\\mathbf{M}^{1/2} = \\sqrt{m}\\,\\mathbf{I}$。当 $\\mathbf{V} = \\mathbf{I}/\\sqrt{m}$ 时，该式简化为 $q_\\alpha(t) = \\delta r_\\alpha(t)$。\n- 对于三个模态坐标 $q_\\alpha(t)$、$q_\\beta(t)$、$q_\\gamma(t)$，根据联合累积量的定义来定义三阶联合累积量 $\\kappa_{3}(\\alpha,\\beta,\\gamma)$。归一化非谐耦合系数定义为 $g_{\\alpha\\beta\\gamma} = \\kappa_{3}(\\alpha,\\beta,\\gamma)/\\left(\\sigma_\\alpha \\sigma_\\beta \\sigma_\\gamma\\right)$，其中 $\\sigma_\\alpha$ 是 $q_\\alpha(t)$ 的标准差。系数 $g_{\\alpha\\beta\\gamma}$ 是无量纲的；请将其报告为浮点数。\n\n程序要求：\n- 使用上文定义的质量正交归一基 $\\mathbf{V}$ 和时间平均参考结构 $\\overline{\\mathbf{r}}$ 来实现投影。然后，对每个测试用例，计算 $(\\alpha,\\beta,\\gamma) = (1,2,3)$ 的 $g_{\\alpha\\beta\\gamma}$，这在从1开始的索引中对应于笛卡尔坐标中的有序三元组 $(x,y,z)$。\n- 三阶联合累积量必须根据累积量和矩的第一性原理进行计算，并且不得假定任何依赖于均值为零的简化；当按规定应用投影时，它在非零均值下应正确地保持不变。\n- 最终输出必须为单行，包含一个 Python 风格的列表，内含三个浮点数 $[g_1,g_2,g_3]$，其中 $g_k$ 对应下方测试套件中列出的第 $k$ 个测试用例，并按此顺序排列。数值应报告为原始十进制数（无单位）。\n\n测试套件：\n使用以下三个确定性测试用例。对于每个用例，定义一个长度为 $T$ 帧的轨迹 $\\mathbf{r}(t) = (x(t),y(t),z(t))$，由整数 $t \\in \\{0,1,2,\\dots,T-1\\}$ 索引，时间步长为 $\\Delta t = 1\\,\\mathrm{ps}$。所有坐标的单位均为纳米，但最终结果无单位。对于每个用例，使用 $\\mathbf{V} = \\mathbf{I}/\\sqrt{m}$ 和 $m = 12$。\n\n- 测试用例 1（标称非耦合正弦运动）：设 $T = 2400$。定义\n  - $x(t) = \\cos\\left(2\\pi t / 50\\right)$，\n  - $y(t) = \\sin\\left(2\\pi t / 80\\right)$，\n  - $z(t) = \\cos\\left(2\\pi t / 30\\right)$。\n  计算 $g_{123}$。\n- 测试用例 2（具有正系数的确定性三次耦合）：设 $T = 4000$。定义\n  - $x(t) = \\cos\\left(2\\pi t / 50\\right)$，\n  - $y(t) = \\sin\\left(2\\pi t / 80\\right)$，\n  - $z(t) = a\\, x(t)\\, y(t)$，其中 $a = 0.5$。\n  计算 $g_{123}$。\n- 测试用例 3（具有负系数的确定性三次耦合）：设 $T = 4000$。定义\n  - $x(t) = \\cos\\left(2\\pi t / 50\\right)$，\n  - $y(t) = \\sin\\left(2\\pi t / 80\\right)$，\n  - $z(t) = a\\, x(t)\\, y(t)$，其中 $a = -0.3$。\n  计算 $g_{123}$。\n\n所有三角函数参数均为无量纲，以弧度表示。由于输入轨迹跨越整数个周期，因此在此窗口内平均值是良定义的。您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，按三个测试用例的顺序排列，例如 $[g_1,g_2,g_3]$。", "solution": "用户提供的问题已经过验证，被认为是合理的。这是一个适定 (well-posed) 的计算问题，其基础是分子动力学和统计力学原理。所有必要的定义、参数和数据均已提供。该问题在其所述的简化模型背景下是科学一致的。\n\n目标是为单个粒子的三个不同确定性轨迹计算一个无量纲非谐耦合系数，记为 $g_{\\alpha\\beta\\gamma}$。该系数通过测量投影模态坐标的归一化三阶累积量，来量化不同空间分量之间的关联运动。要求进行的具体计算是针对 $g_{123}$，它对应于笛卡尔坐标 $(x,y,z)$。\n\n该解决方案是通过将所提供的定义形式化为一个具体的计算算法来制定的。\n\n**1. 理论框架与定义**\n\n粒子的轨迹由其位置向量 $\\mathbf{r}(t) = (x(t), y(t), z(t))$ 的时间序列给出，该序列包含 $T$ 个离散时间步，索引为 $t \\in \\{0, 1, \\ldots, T-1\\}$。\n\n首先，我们通过计算轨迹的时间平均值来建立一个参考结构：\n$$\n\\overline{\\mathbf{r}} = \\langle \\mathbf{r}(t) \\rangle = \\frac{1}{T} \\sum_{t=0}^{T-1} \\mathbf{r}(t)\n$$\n涨落，即相对于此平均位置的位移，定义为：\n$$\n\\delta \\mathbf{r}(t) = \\mathbf{r}(t) - \\overline{\\mathbf{r}}\n$$\n这些涨落代表了粒子相对于其平均位置的内部运动。\n\n问题定义了将这些涨落投影到一组模态上的方法。模态 $\\alpha$ 的投影模态坐标 $q_\\alpha(t)$ 由下式给出：\n$$\nq_\\alpha(t) = \\sum_{i=1}^{3} \\sum_{j=1}^{3} V_{i\\alpha} \\left(M^{1/2}\\right)_{ij} \\delta r_j(t)\n$$\n其中 $V_{i\\alpha}$ 是特征向量矩阵 $\\mathbf{V}$ 的分量，$\\mathbf{M}$ 是质量矩阵。问题指定 $\\mathbf{M} = m\\,\\mathbf{I}$ 和 $\\mathbf{V} = \\mathbf{I}/\\sqrt{m}$，其中 $m=12\\,\\mathrm{u}$ 是粒子质量，$\\mathbf{I}$ 是 $3 \\times 3$ 单位矩阵。质量矩阵的平方根是 $\\mathbf{M}^{1/2} = \\sqrt{m}\\,\\mathbf{I}$。\n\n将这些代入投影公式：\n$$\nq_\\alpha(t) = \\sum_{i=1}^{3} \\left(\\frac{1}{\\sqrt{m}}\\,\\delta_{i\\alpha}\\right) \\sum_{j=1}^{3} \\left(\\sqrt{m}\\,\\delta_{ij}\\right) \\delta r_j(t)\n$$\n第二个求和简化为 $\\sqrt{m}\\,\\delta r_i(t)$。将其代回：\n$$\nq_\\alpha(t) = \\sum_{i=1}^{3} \\left(\\frac{1}{\\sqrt{m}}\\,\\delta_{i\\alpha}\\right) (\\sqrt{m}\\,\\delta r_i(t)) = \\sum_{i=1}^{3} \\delta_{i\\alpha}\\,\\delta r_i(t) = \\delta r_\\alpha(t)\n$$\n因此，对于给定的基，模态坐标 $q_1(t), q_2(t), q_3(t)$ 分别就是笛卡尔坐标的涨落 $\\delta x(t), \\delta y(t), \\delta z(t)$。\n\n分析的核心是三阶联合累积量 $\\kappa_3(\\alpha, \\beta, \\gamma)$。对于三个随机变量 $X_1, X_2, X_3$，三阶联合累积量用原始矩 $E[\\cdot]$ 定义为：\n$$\n\\kappa_3(X_1, X_2, X_3) = E[X_1 X_2 X_3] - E[X_1]E[X_2 X_3] - E[X_2]E[X_1 X_3] - E[X_3]E[X_1 X_2] + 2 E[X_1]E[X_2]E[X_3]\n$$\n该表达式等价于三阶联合中心矩：\n$$\n\\kappa_3(X_1,X_2,X_3) = E[(X_1 - E[X_1])(X_2 - E[X_2])(X_3 - E[X_3])]\n$$\n问题要求计算模态坐标 $q_\\alpha, q_\\beta, q_\\gamma$ 的累积量。根据涨落 $\\delta\\mathbf{r}$ 的定义，每个模态坐标 $q_\\alpha$ 的时间平均值为零：\n$$\n\\langle q_\\alpha(t) \\rangle = \\langle \\delta r_\\alpha(t) \\rangle = \\langle r_\\alpha(t) - \\overline{r}_\\alpha \\rangle = \\langle r_\\alpha(t) \\rangle - \\overline{r}_\\alpha = \\overline{r}_\\alpha - \\overline{r}_\\alpha = 0\n$$\n由于均值为零，累积量公式显著简化为：\n$$\n\\kappa_3(q_\\alpha, q_\\beta, q_\\gamma) = \\langle q_\\alpha(t) q_\\beta(t) q_\\gamma(t) \\rangle = \\frac{1}{T} \\sum_{t=0}^{T-1} q_\\alpha(t) q_\\beta(t) q_\\gamma(t)\n$$\n这一简化是有效的，因为我们处理的是均值中心化的坐标 $q_\\alpha$，这满足了问题提出的使用正确、通用定义的要求。\n\n最后，通过将累积量除以各模态坐标标准差的乘积，得到无量纲非谐耦合系数 $g_{\\alpha\\beta\\gamma}$：\n$$\ng_{\\alpha\\beta\\gamma} = \\frac{\\kappa_3(q_\\alpha, q_\\beta, q_\\gamma)}{\\sigma_\\alpha \\sigma_\\beta \\sigma_\\gamma}\n$$\n时间序列 $q_\\alpha(t)$ 的标准差 $\\sigma_\\alpha$ 是方差的平方根。由于 $\\langle q_\\alpha \\rangle = 0$，方差就是均方值：\n$$\n\\sigma_\\alpha = \\sqrt{\\langle (q_\\alpha(t) - \\langle q_\\alpha \\rangle)^2 \\rangle} = \\sqrt{\\langle q_\\alpha(t)^2 \\rangle} = \\sqrt{\\frac{1}{T} \\sum_{t=0}^{T-1} q_\\alpha(t)^2}\n$$\n\n**2. 计算算法**\n\n每个测试用例的计算过程如下：\n1.  **生成轨迹**：对于给定长度为 $T$ 的测试用例，生成三个笛卡尔坐标时间序列 $x(t)$、$y(t)$ 和 $z(t)$，其中 $t = 0, 1, \\ldots, T-1$。将它们存储在一个 $T \\times 3$ 的矩阵 $\\mathbf{R}$ 中。\n2.  **计算涨落**：计算 $\\mathbf{R}$ 的每一列的平均值，得到平均位置向量 $\\overline{\\mathbf{r}}$。从 $\\mathbf{R}$ 的每一行中减去 $\\overline{\\mathbf{r}}$，得到涨落矩阵 $\\delta\\mathbf{R}$。该矩阵的列即为模态坐标时间序列 $q_1(t), q_2(t), q_3(t)$。\n3.  **计算累积量**：通过对 $\\delta\\mathbf{R}$ 的三列进行逐元素相乘，然后计算所得向量的平均值，来计算三阶累积量 $\\kappa_3(1,2,3)$。\n4.  **计算标准差**：为 $\\delta\\mathbf{R}$ 的每一列计算总体标准差，得到 $\\sigma_1, \\sigma_2$ 和 $\\sigma_3$。\n5.  **计算耦合系数**：计算最终系数 $g_{123} = \\kappa_3(1,2,3) / (\\sigma_1 \\sigma_2 \\sigma_3)$。为当前测试用例存储该值。\n\n对所有三个指定的测试用例重复此过程。\n\n**3. 在测试用例上的应用**\n\n-   **测试用例 1** 涉及三个非耦合的正弦运动。由于不同频率的正弦和余弦函数在整数个周期上的正交性，三阶累积量 $\\langle q_1 q_2 q_3 \\rangle$ 预计在数值上接近于零。因此，$g_{123} \\approx 0$。\n-   **测试用例 2** 引入了一个确定性的“三次”耦合，其中 $z(t)$ 与 $x(t)$ 和 $y(t)$ 的乘积成正比，比例系数为正值 $a=0.5$。该系统的构造使得 $q_1 \\approx x$，$q_2 \\approx y$，$q_3 \\approx z$。计算 $g_{123}$ 预计将得到恰好为 $1.0$ 的值，这表示这种特定类型的完美相关。\n-   **测试用例 3** 与用例 2 相同，但耦合系数为负值 $a = -0.3$。这一变化在累积量 $\\kappa_3$ 中引入了一个负号，但不影响标准差。预期结果为 $g_{123} = -1.0$，表示完美的反相关。\n\n实现将使用 `numpy` 库来进行高效的、基于数组的平均值、标准差和逐元素运算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the dimensionless anharmonic coupling coefficient g_123 for three test cases.\n    \"\"\"\n\n    # The mass m=12 is specified but not required for the final calculation because\n    # the modal projection q_alpha simplifies to the Cartesian fluctuation delta_r_alpha.\n\n    test_cases = [\n        {\n            \"T\": 2400,\n            \"x_period\": 50,\n            \"y_period\": 80,\n            \"z_type\": \"cos\",\n            \"z_param\": 30, # period\n        },\n        {\n            \"T\": 4000,\n            \"x_period\": 50,\n            \"y_period\": 80,\n            \"z_type\": \"prod\",\n            \"z_param\": 0.5, # coefficient 'a'\n        },\n        {\n            \"T\": 4000,\n            \"x_period\": 50,\n            \"y_period\": 80,\n            \"z_type\": \"prod\",\n            \"z_param\": -0.3, # coefficient 'a'\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Step 1: Generate the discrete trajectory r(t)\n        T = case[\"T\"]\n        t = np.arange(T, dtype=np.float64)\n\n        x_t = np.cos(2.0 * np.pi * t / case[\"x_period\"])\n        y_t = np.sin(2.0 * np.pi * t / case[\"y_period\"])\n\n        if case[\"z_type\"] == \"cos\":\n            z_t = np.cos(2.0 * np.pi * t / case[\"z_param\"])\n        elif case[\"z_type\"] == \"prod\":\n            z_t = case[\"z_param\"] * x_t * y_t\n        \n        # Combine into a single trajectory matrix r of shape (T, 3)\n        r = np.vstack((x_t, y_t, z_t)).T\n\n        # Step 2: Compute mean and fluctuations (delta_r)\n        # The mean r_bar is a vector of shape (3,)\n        r_mean = np.mean(r, axis=0)\n        \n        # The fluctuations delta_r have shape (T, 3)\n        delta_r = r - r_mean\n\n        # As derived, the modal coordinates q_alpha are the Cartesian fluctuations delta_r_alpha.\n        # Let's extract them for clarity.\n        q1 = delta_r[:, 0]\n        q2 = delta_r[:, 1]\n        q3 = delta_r[:, 2]\n\n        # Step 3: Calculate the third-order joint cumulant kappa_3(1,2,3)\n        # Since the mean of each q_alpha is zero, the cumulant is the mean of the product.\n        kappa_123 = np.mean(q1 * q2 * q3)\n\n        # Step 4: Calculate the standard deviations sigma_alpha\n        # numpy.std calculates the population standard deviation by default, which is correct here.\n        sigma_1 = np.std(q1)\n        sigma_2 = np.std(q2)\n        sigma_3 = np.std(q3)\n        \n        # Step 5: Compute the normalized coupling coefficient g_123\n        denominator = sigma_1 * sigma_2 * sigma_3\n        \n        # Avoid division by zero, although not expected for these dynamic test cases.\n        if np.isclose(denominator, 0.0):\n            g_123 = 0.0\n        else:\n            g_123 = kappa_123 / denominator\n        \n        results.append(g_123)\n\n    # Final print statement in the exact required format.\n    # The map to str ensures standard float formatting.\n    formatted_results = [f\"{res:.15f}\".rstrip('0').rstrip('.') if '.' in f\"{res:.15f}\" else f\"{res:.1f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3406423"}, {"introduction": "要分析协同运动，首先必须生成真实的动态轨迹。本练习 [@problem_id:3406448] 将指导你从第一性原理出发，构建一个朗之万动力学模拟器，以探索惯性耦合和热涨落之间的相互作用。通过计算和比较位置与速度的相关性，你将学会如何揭示不同时间尺度下的动力学特征，这是理解信号如何在生物分子中传播的基础。", "problem": "一个一维粗粒化生物分子片段可以被理想化为一条由 $N$ 个质点组成的链，质点间存在最近邻谐波耦合。在分子动力学 (MD) 中，通过基于位置的相关性来研究相关运动，并在快速时间尺度上通过基于速度的相关性来评估惯性耦合。考虑以下由牛顿第二定律、线形阻尼和热驱动力（朗之万动力学）所描述的物理上一致的模型。该链的状态由位置 $x_i(t)$ 和速度 $v_i(t)$ 描述，其中 $i \\in \\{1,\\dots,N\\}$。总势能是谐波形式，包含最近邻耦合和一个用于消除全局漂移的弱在位锚定。确定性力是线性的，$F(x) = -K x$，其中 $K$ 是一个对称正定刚度矩阵，由链的拉普拉斯矩阵加上一个在位项构成。连续时间运动方程为\n$$\nm \\,\\frac{d^2 x}{dt^2} \\;=\\; F(x) \\;-\\; \\gamma \\, \\frac{dx}{dt} \\;+\\; \\sqrt{2 \\gamma \\, k_{\\mathrm{B}} T} \\,\\eta(t),\n$$\n其中 $m$ 是质量（假设所有位点相同），$\\gamma$ 是每个自由度的摩擦系数，$k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，而 $\\eta(t)$ 是一个由独立标准高斯白噪声分量组成的向量。使用约化单位，其中 $k_{\\mathrm{B}} T$ 以与势能相同的能量单位表示，并取 $k_{\\mathrm{B}}=1$，因此 $T$ 在数值上等于热能。假设质量矩阵为 $m I$，且摩擦是各向同性的（标量 $\\gamma$）。您必须从第一性原理出发，在离散时间内模拟该系统，而不依赖任何黑箱 MD 库。\n\n您的任务是：\n- 仅从牛顿第二定律、谐波势产生的线性力以及涨落-耗散关系出发，为朗之万动力学推导出一个稳定、时间可逆的分裂积分方法，该方法能精确处理 Ornstein–Uhlenbeck 速度子步骤，并对漂移和力的施加使用对称半步。\n- 实现该模拟器，并生成在均匀时间网格 $t_n = n \\,\\Delta t$（整数 $n \\ge 0$，时间步长为 $\\Delta t$）上采样的轨迹 $x_i(t_n)$ 和 $v_i(t_n)$。\n- 根据采样得到的轨迹，使用时间样本作为观测值，分别计算位置和速度的跨位点皮尔逊相关矩阵。将基于位置的相关矩阵记为 $C$（其元素为 $C_{ij}$），将基于速度的相关矩阵记为 $C^{v}$（其元素为 $C^{v}_{ij}$）。\n- 将惯性耦合指数定义为平均最近邻绝对速度相关性与平均最近邻绝对位置相关性之差：\n$$\n\\mathcal{I} \\;=\\; \\frac{1}{N-1} \\sum_{i=1}^{N-1} \\left( \\left| C^{v}_{i,i+1} \\right| \\;-\\; \\left| C_{i,i+1} \\right| \\right).\n$$\n该指数是无量纲的。正值 $\\mathcal{I}$ 表示平均而言，最近邻的速度相关性超过位置相关性，这与在快速时间尺度上惯性耦合占主导地位的情况一致；负值 $\\mathcal{I}$ 则表示相反情况。\n\n对于具有最近邻耦合常数 $k$ 和在位锚定 $k_{\\mathrm{a}}$ 的线性链，其刚度矩阵 $K$ 构建如下：\n$$\nK \\;=\\; k \\, L \\;+\\; k_{\\mathrm{a}} \\, I,\n$$\n其中 $L$ 是路径图的 $N \\times N$ 拉普拉斯矩阵：对于 $i \\in \\{2,\\dots,N-1\\}$，$(L)_{ii} = 2$；$(L)_{11}=(L)_{NN}=1$；对于所有最近邻，$(L)_{i,i+1}=(L)_{i+1,i}=-1$。使用初始条件 $x(0)=0$ 和 $v(0)=0$，除非指定了脉冲；如果给定了脉冲振幅 $v_0$，则设置 $v_{\\lfloor N/2 \\rfloor}(0) \\leftarrow v_{\\lfloor N/2 \\rfloor}(0) + v_0$。为确保可复现性，必须使用种子 $s=12345$ 初始化随机数生成器。\n\n测试套件。请精确运行以下三个测试用例，每个用例指定为一个元组 $(N, m, k, k_{\\mathrm{a}}, \\gamma, T, \\Delta t, \\text{steps}, \\text{warmup}, v_0)$，其中 $\\text{steps}$ 是总积分步数，$\\text{warmup}$ 是在为计算相关性收集数据之前要丢弃的初始步数，而 $v_0$ 是脉冲振幅：\n- 用例 1（无热噪声的欠阻尼瞬态过程）：$(N, m, k, k_{\\mathrm{a}}, \\gamma, T, \\Delta t, \\text{steps}, \\text{warmup}, v_0) = (6, 1, 100, 1, 0.1, 0, 0.001, 20000, 0, 8)$。\n- 用例 2（强阻尼热平衡）：$(N, m, k, k_{\\mathrm{a}}, \\gamma, T, \\Delta t, \\text{steps}, \\text{warmup}, v_0) = (6, 1, 100, 1, 5, 1, 0.001, 80000, 20000, 0)$。\n- 用例 3（中等阻尼热平衡）：$(N, m, k, k_{\\mathrm{a}}, \\gamma, T, \\Delta t, \\text{steps}, \\text{warmup}, v_0) = (6, 1, 100, 1, 1, 1, 0.001, 80000, 20000, 0)$。\n\n所有输出均为无量纲。您的程序应生成单行输出，其中包含上述三个用例的 $\\mathcal{I}$ 值，按顺序排列，格式为用方括号括起来的逗号分隔列表（例如，$[\\mathcal{I}_1,\\mathcal{I}_2,\\mathcal{I}_3]$）。不应打印任何其他文本。", "solution": "该问题是有效的，因为它提出了一个计算统计物理领域中适定且有科学依据的任务。它是自洽的，提供了所有必要的参数、初始条件和定义，以获得唯一且可验证的数值解。该模型，即谐振子链的朗之万动力学，是分子动力学中的一个标准且基础的系统。验证清单未显示任何缺陷。\n\n问题的核心是模拟一维质点链的朗之万动力学。位置 $x(t) \\in \\mathbb{R}^N$ 的运动方程是一个二阶随机微分方程：\n$$\nm \\frac{d^2 x}{dt^2} = F(x) - \\gamma \\frac{dx}{dt} + \\sqrt{2 \\gamma T} \\eta(t)\n$$\n此处，我们使用了指定的约化单位，其中玻尔兹曼常数 $k_{\\mathrm{B}}=1$。变量包括质量 $m$（一个标量，因为质量矩阵是 $mI$）、摩擦系数 $\\gamma$、温度 $T$ 以及一个由独立标准高斯白噪声组成的向量 $\\eta(t)$。确定性力是线性的，$F(x) = -Kx$，源于谐波势，其中 $K$ 是刚度矩阵。\n\n为了数值求解此问题，我们需要一个稳定、时间可逆的积分器。问题要求采用一种分裂法，该方法能精确处理速度动力学中的 Ornstein-Uhlenbeck (OU) 部分，并对位置和力的更新使用对称半步。BAOAB 积分器完美符合这些要求。\n\n该动力学可以形式上由一个刘维尔算符 $\\mathcal{L}$ 描述，该算符可以分裂为三个部分：\n1.  **漂移 (A)：** 由速度引起的位置演化，$\\dot{x} = v$。关联的算符是 $\\mathcal{L}_A = v \\cdot \\nabla_x$。\n2.  **踢 (B)：** 由确定性力引起的速度演化，$\\dot{v} = F(x)/m$。关联的算符是 $\\mathcal{L}_B = (F(x)/m) \\cdot \\nabla_v$。\n3.  **OU 过程 (O)：** 由摩擦和热噪声引起的速度演化，$\\dot{v} = -(\\gamma/m)v + \\sqrt{2 \\gamma T}/m \\, \\eta(t)$。关联的算符是 $\\mathcal{L}_O$。\n\nBAOAB 方法是一种对称 Strang 分裂，其形式为 $e^{\\mathcal{L} \\Delta t} \\approx e^{\\frac{\\Delta t}{2}\\mathcal{L}_B} e^{\\frac{\\Delta t}{2}\\mathcal{L}_A} e^{\\Delta t\\mathcal{L}_O} e^{\\frac{\\Delta t}{2}\\mathcal{L}_A} e^{\\frac{\\Delta t}{2}\\mathcal{L}_B}$。这个操作序列定义了单个时间步 $\\Delta t$ 的算法。\n\n让我们推导每个子步骤的精确传播子：\n- **传播子 $e^{\\tau \\mathcal{L}_A}$ (漂移)：** 对于时间间隔 $\\tau$，此步骤在假设速度恒定的情况下更新位置：$x \\rightarrow x + v\\tau$。\n- **传播子 $e^{\\tau \\mathcal{L}_B}$ (踢)：** 对于时间间隔 $\\tau$，此步骤在假设力恒定的情况下更新速度：$v \\rightarrow v + (F(x)/m)\\tau$。\n- **传播子 $e^{\\tau \\mathcal{L}_O}$ (OU 过程)：** 此步骤涉及求解速度 $v$ 的线性随机微分方程，同时保持位置 $x$ 固定：\n$$\nd v = - \\frac{\\gamma}{m} v dt + \\frac{\\sqrt{2 \\gamma T}}{m} dW_t\n$$\n其中 $dW_t = \\eta(t)dt$ 是一个维纳过程向量。在时间间隔 $\\tau$ 内，速度向量的每个分量的精确解是：\n$$\nv_i(\\tau) = v_i(0) e^{-(\\gamma/m)\\tau} + R_i\n$$\n其中 $R_i$ 是一个高斯随机数，其均值为 $\\mathbb{E}[R_i] = 0$，方差为：\n$$\n\\text{Var}(R_i) = \\frac{2\\gamma T}{m^2} \\int_0^\\tau e^{-2(\\gamma/m)(\\tau-s)} ds = \\frac{T}{m} \\left( 1 - e^{-2(\\gamma/m)\\tau} \\right)\n$$\n因此，O-步骤在一个完整时间步 $\\Delta t$ 内的速度更新可以写为：\n$$\nv \\rightarrow c_1 v + c_2 \\mathcal{N}(0, I)\n$$\n其中 $\\mathcal{N}(0, I)$ 是一个由独立标准正态随机变量组成的向量，常数为：\n$$\nc_1 = e^{-(\\gamma/m)\\Delta t} \\quad \\text{and} \\quad c_2 = \\sqrt{\\frac{T}{m}(1 - c_1^2)}\n$$\n\n根据 BAOAB 分裂方案组合这些传播子，可得到从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的一个积分步的算法，起始状态为 $(x_n, v_n)$：\n1.  **B-步骤 (半步踢)：** 计算力 $F_n = -Kx_n$。更新速度：\n    $$v_{n+1/2}^{(1)} = v_n + \\frac{\\Delta t}{2m} F_n$$\n2.  **A-步骤 (半步漂移)：** 使用新速度更新位置：\n    $$x_{n+1/2} = x_n + \\frac{\\Delta t}{2} v_{n+1/2}^{(1)}$$\n3.  **O-步骤 (完整 OU)：** 用摩擦和噪声更新速度：\n    $$v_{n+1/2}^{(2)} = c_1 v_{n+1/2}^{(1)} + c_2 \\mathcal{N}_n$$\n    其中 $\\mathcal{N}_n$ 是一个新的标准正态随机向量。\n4.  **A-步骤 (半步漂移)：** 再次使用 OU 步骤之后的速度更新位置：\n    $$x_{n+1} = x_{n+1/2} + \\frac{\\Delta t}{2} v_{n+1/2}^{(2)}$$\n5.  **B-步骤 (半步踢)：** 计算新位置处的力 $F_{n+1} = -Kx_{n+1}$，并完成速度更新：\n    $$v_{n+1} = v_{n+1/2}^{(2)} + \\frac{\\Delta t}{2m} F_{n+1}$$\n\n该算法被实现用于生成位置 $x(t_n)$ 和速度 $v(t_n)$ 的轨迹。在丢弃初始的 `warmup` 阶段后，收集到的轨迹被用来计算所需的相关矩阵。\n\n刚度矩阵 $K$ 的构建方式为 $K = k L + k_{\\mathrm{a}} I$，其中 $I$ 是单位矩阵，$L$ 是一维链（路径图）的拉普拉斯矩阵：\n$$\n(L)_{ij} = \\begin{cases} 1 & \\text{if } i=j \\text{ and } i \\in \\{1,N\\} \\\\ 2 & \\text{if } i=j \\text{ and } i \\in \\{2,\\dots,N-1\\} \\\\ -1 & \\text{if } |i-j|=1 \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\n从存储为数据矩阵 $X$ 和 $V$ 的位置轨迹 $\\{x_i(t_n)\\}$ 和速度轨迹 $\\{v_i(t_n)\\}$（其中列代表位点，行代表时间样本）出发，计算位置的皮尔逊相关矩阵 ($C$) 和速度的皮尔逊相关矩阵 ($C^v$)。元素 $C_{ij}$ 是位点 $i$ 和位点 $j$ 的时间序列之间的相关性。\n\n最后，惯性耦合指数 $\\mathcal{I}$ 计算为速度和位置的绝对最近邻相关性之间的平均差值：\n$$\n\\mathcal{I} = \\frac{1}{N-1} \\sum_{i=1}^{N-1} \\left( | C^v_{i,i+1} | - | C_{i,i+1} | \\right)\n$$\n此方案被应用于指定的三个测试用例中的每一个。为确保可复现性，随机数生成器已设定种子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_inertial_index(N, m, k, k_a, gamma, T, dt, steps, warmup, v0, rng):\n    \"\"\"\n    Simulates a 1D harmonic chain with Langevin dynamics and computes the inertial coupling index.\n    \"\"\"\n    \n    # 1. Build the stiffness matrix K\n    L = np.zeros((N, N))\n    if N > 1:\n        np.fill_diagonal(L, 2)\n        L[0, 0] = 1\n        L[N-1, N-1] = 1\n        np.fill_diagonal(L[1:], -1)\n        np.fill_diagonal(L[:, 1:], -1)\n    elif N == 1:\n        L[0,0] = 0 # No neighbors\n        \n    K = k * L + k_a * np.identity(N)\n    \n    # 2. Initialization\n    x = np.zeros(N)\n    v = np.zeros(N)\n    \n    if v0 != 0 and N > 0:\n        center_idx = N // 2\n        v[center_idx] += v0\n        \n    # 3. Integrator constants for BAOAB\n    c1 = np.exp(-gamma * dt / m)\n    if T > 0:\n        # k_B is 1\n        c2 = np.sqrt(T * (1 - c1**2) / m)\n    else:\n        c2 = 0.0\n\n    # 4. Simulation Loop\n    x_traj = []\n    v_traj = []\n    \n    for step in range(steps):\n        # B-step (half kick)\n        F = -K @ x\n        v_half = v + (dt / (2.0 * m)) * F\n        \n        # A-step (half drift)\n        x_half = x + (dt / 2.0) * v_half\n        \n        # O-step (full)\n        if c2 > 0:\n            R = rng.standard_normal(N)\n            v_prime_half = c1 * v_half + c2 * R\n        else:\n            v_prime_half = c1 * v_half\n\n        # A-step (half drift)\n        x_new = x_half + (dt / 2.0) * v_prime_half\n        \n        # B-step (half kick)\n        F_new = -K @ x_new\n        v_new = v_prime_half + (dt / (2.0 * m)) * F_new\n        \n        # Update state\n        x, v = x_new, v_new\n        \n        # Store trajectories after warmup\n        if step >= warmup:\n            x_traj.append(x)\n            v_traj.append(v)\n            \n    # 5. Post-processing and Analysis\n    if not x_traj or N == 1:\n        return 0.0\n\n    X_data = np.array(x_traj)\n    V_data = np.array(v_traj)\n    \n    # Handle potential constant trajectories by checking std dev\n    # This avoids RuntimeWarning from np.corrcoef\n    if np.any(np.std(X_data, axis=0) < 1e-12) or np.any(np.std(V_data, axis=0) < 1e-12):\n        # Center data manually\n        X_data_centered = X_data - np.mean(X_data, axis=0)\n        V_data_centered = V_data - np.mean(V_data, axis=0)\n        # Compute covariance matrices\n        cov_pos = X_data_centered.T @ X_data_centered / X_data_centered.shape[0]\n        cov_vel = V_data_centered.T @ V_data_centered / V_data_centered.shape[0]\n        # Compute standard deviations, adding epsilon to avoid division by zero\n        std_pos = np.sqrt(np.diag(cov_pos)) + 1e-12\n        std_vel = np.sqrt(np.diag(cov_vel)) + 1e-12\n        # Compute correlation matrices\n        C_pos = cov_pos / np.outer(std_pos, std_pos)\n        C_vel = cov_vel / np.outer(std_vel, std_vel)\n    else:\n        C_pos = np.corrcoef(X_data, rowvar=False)\n        C_vel = np.corrcoef(V_data, rowvar=False)\n\n    abs_nn_corr_pos = np.abs(np.diag(C_pos, k=1))\n    abs_nn_corr_vel = np.abs(np.diag(C_vel, k=1))\n    \n    inertial_index = np.mean(abs_nn_corr_vel - abs_nn_corr_pos)\n    \n    return inertial_index\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, m, k, k_a, gamma, T, dt, steps, warmup, v0)\n        (6, 1, 100, 1, 0.1, 0, 0.001, 20000, 0, 8),\n        (6, 1, 100, 1, 5, 1, 0.001, 80000, 20000, 0),\n        (6, 1, 100, 1, 1, 1, 0.001, 80000, 20000, 0),\n    ]\n\n    results = []\n    # Initialize a single random number generator for reproducibility\n    rng = np.random.default_rng(seed=12345)\n\n    for case in test_cases:\n        N, m, k, k_a, gamma, T, dt, steps, warmup, v0 = case\n        result = calculate_inertial_index(N, m, k, k_a, gamma, T, dt, steps, warmup, v0, rng)\n        # Format result to a reasonable number of decimal places for consistency\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3406448"}, {"introduction": "增强采样方法对于研究缓慢的生物分子过程至关重要，但它们可能会引入人为的假象。这个高级练习 [@problem_id:3406465] 探讨了一个关键的方法论问题：偏置势如何影响我们旨在研究的协同运动？通过分析和数值量化不同偏置方案下天然协方差矩阵的扭曲，你将对增强采样模拟的应用和结果解释形成更为深刻和批判性的理解。", "problem": "考虑一个过阻尼分子动力学 (MD) 系统，该系统具有三个构型自由度，一个指定的集体变量 (CV) $x$ 和两个正交坐标 $y$ 和 $z$。假设位置的稳态分布由玻尔兹曼形式给出，无量纲单位下的逆热能为 $\\beta = 1$，且原始势能是具有双线性耦合的谐波势，\n$$\nU(x,y,z) = \\frac{1}{2} k_x x^2 + \\frac{1}{2} k_y y^2 + \\frac{1}{2} k_z z^2 + k_{yz} y z + k_{xy} x y + k_{xz} x z,\n$$\n其黑塞矩阵是正定的。定义正交子空间中的原始协方差矩阵为\n$$\n\\Sigma^{\\text{native}} = \\begin{pmatrix}\n\\mathrm{Cov}(y,y) & \\mathrm{Cov}(y,z) \\\\\n\\mathrm{Cov}(z,y) & \\mathrm{Cov}(z,z)\n\\end{pmatrix}.\n$$\n沿集体变量 $x$ 应用两种偏置方案：\n1. 伞形采样，使用谐波偏置，\n$$\nV_{\\mathrm{umb}}(x) = \\frac{1}{2} k_{\\mathrm{umb}} (x - x_0)^2,\n$$\n2. 元动力学，其静态极限偏置表示为高斯山丘之和，\n$$\nV_{\\mathrm{meta}}(x) = \\sum_{n=1}^{N} h_n \\exp\\left(-\\frac{(x - s_n)^2}{2 w^2}\\right).\n$$\n从基本定义出发，包括玻尔兹曼分布 $p(\\mathbf{q}) \\propto \\exp(-U(\\mathbf{q}))$（其中 $\\mathbf{q} = (x,y,z)$）和协方差定义 $C_{ij} = \\langle q_i q_j \\rangle - \\langle q_i \\rangle \\langle q_j \\rangle$，推导增加一个偏置 $V(x)$ 如何改变 $x$ 的有效分布，并如何根据谐波参数传播到正交协方差矩阵 $\\Sigma^{V}$ 中。使用相对弗罗贝尼乌斯范数来量化偏置在正交子空间中引起的原始协方差畸变，\n$$\n\\Delta(V) = \\frac{\\left\\| \\Sigma^{V} - \\Sigma^{\\text{native}} \\right\\|_F}{\\left\\| \\Sigma^{\\text{native}} \\right\\|_F},\n$$\n其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。所有能量和变量均为无量纲，且 $\\beta = 1$。\n\n您的任务是实现一个程序，对每个提供的测试用例计算两个浮点数：\n- 伞形偏置的 $\\Delta(V_{\\mathrm{umb}})$，\n- 元动力学偏置的 $\\Delta(V_{\\mathrm{meta}})$，\n并输出所有测试用例的汇总结果。\n\n推导必须基于：\n- 玻尔兹曼分布和高斯积分的性质，\n- 协方差的定义以及谐波势中的线性耦合如何影响条件分布和边际分布。\n\n对于伞形偏置，由于其二次形式，$x$ 的方差可以解析表示。对于元动力学偏置，通过一维数值积分计算 $x$ 的方差，\n$$\n\\mathrm{Var}_{V_{\\mathrm{meta}}}(x) = \\frac{\\int_{-\\infty}^{\\infty} x^2 \\exp\\left(-U_{\\mathrm{eff}}(x) - V_{\\mathrm{meta}}(x)\\right) \\, dx}{\\int_{-\\infty}^{\\infty} \\exp\\left(-U_{\\mathrm{eff}}(x) - V_{\\mathrm{meta}}(x)\\right) \\, dx},\n$$\n其中 $U_{\\mathrm{eff}}(x)$ 是在积分掉 $y$ 和 $z$ 后，$x$ 的有效二次项。利用所得方差，通过其对 $x$ 与 $(y,z)$ 之间耦合的依赖关系来计算正交协方差 $\\Sigma^{V}$。\n\n测试套件：\n为以下参数集提供结果，每个参数集指定为元组 $(k_x,k_y,k_z,k_{yz},k_{xy},k_{xz},k_{\\mathrm{umb}},x_0,N,\\{h_n\\},\\{s_n\\},w)$：\n\n- 案例 1 (常规“顺利”路径)：\n  $(3.0, 2.0, 1.5, 0.2, 0.3, -0.25, 4.0, 0.5, 3, \\{0.8, 0.6, 0.4\\}, \\{-0.5, 0.0, 0.5\\}, 0.4)$\n- 案例 2 (边界，正交自由度中与 $x$ 的耦合为零)：\n  $(2.2, 1.8, 1.3, 0.3, 0.0, 0.0, 3.0, -0.1, 2, \\{1.0, 0.5\\}, \\{-0.2, 0.7\\}, 0.5)$\n- 案例 3 (边缘案例，强正交耦合和中等 $x$ 耦合)：\n  $(5.0, 1.5, 1.1, 0.9, 0.7, 0.6, 0.5, -0.2, 4, \\{2.0, 1.7, 1.3, 0.9\\}, \\{-1.0, -0.3, 0.3, 1.1\\}, 0.3)$\n\n算法要求：\n- 计算原始正交协方差 $\\Sigma^{\\text{native}}$。\n- 使用组合有效二次系数下 $x$ 的解析方差，计算伞形偏置下的正交协方差 $\\Sigma^{V_{\\mathrm{umb}}}$。\n- 使用数值积分计算 $\\mathrm{Var}_{V_{\\mathrm{meta}}}(x)$，以计算元动力学偏置下的正交协方差 $\\Sigma^{V_{\\mathrm{meta}}}$。\n- 为每个案例计算 $\\Delta(V_{\\mathrm{umb}})$ 和 $\\Delta(V_{\\mathrm{meta}})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个内部列表包含一个测试用例的两个浮点数，形式如下\n\"[ [delta_case1_umb, delta_case1_meta], [delta_case2_umb, delta_case2_meta], [delta_case3_umb, delta_case3_meta] ]\"。\n无需单位，因为所有量都是无量纲的。不涉及角度。", "solution": "我们考虑一个三维谐波系统，其坐标为 $(x,y,z)$，能量为\n$$\nU(x,y,z) = \\frac{1}{2} k_x x^2 + \\frac{1}{2} k_y y^2 + \\frac{1}{2} k_z z^2 + k_{yz} y z + k_{xy} x y + k_{xz} x z,\n$$\n且 $\\beta = 1$，因此稳态分布为 $p(x,y,z) \\propto \\exp(-U(x,y,z))$。我们将正交坐标定义为向量 $\\mathbf{o} = (y,z)^\\top$。令\n$$\nA = \\begin{pmatrix} k_y & k_{yz} \\\\ k_{yz} & k_z \\end{pmatrix}, \\quad b = \\begin{pmatrix} k_{xy} \\\\ k_{xz} \\end{pmatrix}.\n$$\n则能量可以写成块符号的二次型形式，\n$$\nU(x,\\mathbf{o}) = \\frac{1}{2} k_x x^2 + \\frac{1}{2} \\mathbf{o}^\\top A \\mathbf{o} + x b^\\top \\mathbf{o}.\n$$\n我们要求完整的黑塞矩阵是正定的，以便积分收敛。\n\n原理 1：玻尔兹曼分布和高斯条件化。对于一个与 $\\exp\\left(-\\frac{1}{2} [x,\\mathbf{o}]^\\top H [x,\\mathbf{o}] \\right)$ 成正比的联合高斯分布，给定 $x$ 时 $\\mathbf{o}$ 的条件分布是高斯分布，其协方差为 $A^{-1}$，均值随 $x$ 线性偏移。对 $\\mathbf{o}$ 配方，我们得到\n$$\nU(x,\\mathbf{o}) = \\frac{1}{2} \\left( \\mathbf{o} + A^{-1} b x \\right)^\\top A \\left( \\mathbf{o} + A^{-1} b x \\right) + \\frac{1}{2} \\left( k_x - b^\\top A^{-1} b \\right) x^2.\n$$\n对 $\\mathbf{o}$ 积分得到 $x$ 的有效能量，\n$$\nU_{\\mathrm{eff}}(x) = \\frac{1}{2} \\left( k_x - b^\\top A^{-1} b \\right) x^2 + \\text{const},\n$$\n因此，在原始系统中 $x$ 的边际分布是高斯分布，其方差为\n$$\n\\mathrm{Var}_{\\text{native}}(x) = \\frac{1}{k_x - b^\\top A^{-1} b}.\n$$\n这确定了沿 $x$ 方向的有效刚度，\n$$\nk_x^{\\mathrm{eff}} = k_x - b^\\top A^{-1} b,\n$$\n为了保证可归一化，该值必须为正。\n\n原理 2：通过全协方差定律计算正交协方差。给定 $x$ 时 $\\mathbf{o}$ 的条件协方差是常数，等于 $A^{-1}$，因为 $\\mathbf{o}$ 中的条件二次型矩阵为 $A$。条件均值为 $\\mathbb{E}[\\mathbf{o}\\mid x] = -A^{-1} b x$。使用全协方差定律，\n$$\n\\mathrm{Cov}(\\mathbf{o}) = \\mathbb{E}[\\mathrm{Cov}(\\mathbf{o}\\mid x)] + \\mathrm{Cov}(\\mathbb{E}[\\mathbf{o}\\mid x]).\n$$\n第一项就是 $A^{-1}$。第二项涉及 $x$ 的方差：\n$$\n\\mathrm{Cov}(\\mathbb{E}[\\mathbf{o}\\mid x]) = \\mathrm{Cov}(-A^{-1} b x) = A^{-1} b \\, \\mathrm{Var}(x) \\, b^\\top A^{-1}.\n$$\n因此，对于任何只修改 $x$ 分布的偏置 $V(x)$，正交协方差变为\n$$\n\\Sigma^{V} = A^{-1} + A^{-1} b \\, \\mathrm{Var}_{V}(x) \\, b^\\top A^{-1}.\n$$\n当 $\\mathrm{Var}_{V}(x)$ 等于 $\\mathrm{Var}_{\\text{native}}(x)$ 时，恢复为原始正交协方差。\n\n伞形采样。对于伞形偏置 $V_{\\mathrm{umb}}(x) = \\frac{1}{2} k_{\\mathrm{umb}} (x - x_0)^2$，沿 $x$ 方向的有效能量为\n$$\nU_{\\mathrm{eff}}^{\\mathrm{umb}}(x) = \\frac{1}{2} k_x^{\\mathrm{eff}} x^2 + \\frac{1}{2} k_{\\mathrm{umb}} (x - x_0)^2,\n$$\n这是一个二次型。$x$ 的方差仅取决于总的二次项系数，而不取决于位移 $x_0$：\n$$\n\\mathrm{Var}_{\\mathrm{umb}}(x) = \\frac{1}{k_x^{\\mathrm{eff}} + k_{\\mathrm{umb}}}.\n$$\n因此，\n$$\n\\Sigma^{V_{\\mathrm{umb}}} = A^{-1} + A^{-1} b \\, \\frac{1}{k_x^{\\mathrm{eff}} + k_{\\mathrm{umb}}} \\, b^\\top A^{-1}.\n$$\n\n元动力学。对于作为高斯山丘之和的元动力学偏置 $V_{\\mathrm{meta}}(x)$，$x$ 的有效一维分布是非高斯的：\n$$\np_{V_{\\mathrm{meta}}}(x) \\propto \\exp\\left(-U_{\\mathrm{eff}}(x) - V_{\\mathrm{meta}}(x)\\right) = \\exp\\left(-\\frac{1}{2} k_x^{\\mathrm{eff}} x^2 - \\sum_{n=1}^N h_n \\exp\\left(-\\frac{(x - s_n)^2}{2 w^2}\\right)\\right).\n$$\n方差通过一维数值积分计算，\n$$\n\\mathrm{Var}_{\\mathrm{meta}}(x) = \\frac{\\int_{-\\infty}^{\\infty} x^2 \\exp\\left(-\\frac{1}{2} k_x^{\\mathrm{eff}} x^2 - \\sum_{n=1}^N h_n \\exp\\left(-\\frac{(x - s_n)^2}{2 w^2}\\right)\\right) \\, dx}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{1}{2} k_x^{\\mathrm{eff}} x^2 - \\sum_{n=1}^N h_n \\exp\\left(-\\frac{(x - s_n)^2}{2 w^2}\\right)\\right) \\, dx}.\n$$\n然后\n$$\n\\Sigma^{V_{\\mathrm{meta}}} = A^{-1} + A^{-1} b \\, \\mathrm{Var}_{\\mathrm{meta}}(x) \\, b^\\top A^{-1}.\n$$\n\n畸变度量。原始正交协方差为\n$$\n\\Sigma^{\\text{native}} = A^{-1} + A^{-1} b \\, \\frac{1}{k_x^{\\mathrm{eff}}} \\, b^\\top A^{-1}.\n$$\n对于每个偏置 $V$，计算\n$$\n\\Delta(V) = \\frac{\\left\\| \\Sigma^{V} - \\Sigma^{\\text{native}} \\right\\|_F}{\\left\\| \\Sigma^{\\text{native}} \\right\\|_F}.\n$$\n\n程序中实现的算法步骤：\n1. 构建 $A$ 并计算 $A^{-1}$。\n2. 计算 $b$ 和 $k_x^{\\mathrm{eff}} = k_x - b^\\top A^{-1} b$；检查其正性。\n3. 使用 $\\mathrm{Var}_{\\text{native}}(x) = 1/k_x^{\\mathrm{eff}}$ 计算 $\\Sigma^{\\text{native}}$。\n4. 伞形采样：计算 $\\mathrm{Var}_{\\mathrm{umb}}(x) = 1/(k_x^{\\mathrm{eff}} + k_{\\mathrm{umb}})$ 和 $\\Sigma^{V_{\\mathrm{umb}}}$。\n5. 元动力学：使用数值积分为 $\\mathrm{Var}_{\\mathrm{meta}}(x)$ 计算分子和分母的积分，然后计算 $\\Sigma^{V_{\\mathrm{meta}}}$。\n6. 通过弗罗贝尼乌斯范数计算 $\\Delta(V_{\\mathrm{umb}})$ 和 $\\Delta(V_{\\mathrm{meta}})$。\n7. 按指定方式汇总结果。\n\n边缘案例分析：\n- 当 $b = \\mathbf{0}$（$x$ 和 $(y,z)$ 之间没有耦合）时，无论 $x$ 的方差如何，$\\Sigma^{V}$ 都简化为 $A^{-1}$。因此，对于任何偏置，$\\Delta(V) = 0$，这反映了原始正交协方差的完美保持。\n- 强正交耦合（$|k_{yz}|$ 较大但 $A$ 是正定的）通过 $A^{-1}$ 增加了 $\\Sigma^{\\text{native}}$ 对 $b$ 的敏感性，使得当 $\\mathrm{Var}(x)$ 变化时，畸变更加明显。\n\n数值考量：\n- 元动力学积分是一维的，并且由于 $k_x^{\\mathrm{eff}} > 0$ 设定的高斯包络而快速收敛；我们使用高精度的数值积分容差。\n- 所有计算均在无量纲单位下进行，$\\beta = 1$，不涉及角度。\n\n最终程序对所提供的测试用例执行这些步骤，并为每个案例打印一行包含一对 $[\\Delta(V_{\\mathrm{umb}}), \\Delta(V_{\\mathrm{meta}})]$ 的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef frobenius_norm(mat):\n    return np.linalg.norm(mat, 'fro')\n\ndef compute_A_inverse(k_y, k_z, k_yz):\n    A = np.array([[k_y, k_yz],\n                  [k_yz, k_z]], dtype=float)\n    # Ensure positive definiteness for numerical stability\n    # Inverse via numpy\n    A_inv = np.linalg.inv(A)\n    return A, A_inv\n\ndef effective_kx(k_x, b_vec, A_inv):\n    # kx_eff = k_x - b^T A^{-1} b\n    return k_x - float(b_vec.T @ A_inv @ b_vec)\n\ndef sigma_orth(A_inv, b_vec, var_x):\n    # Sigma^V = A^{-1} + A^{-1} b var_x b^T A^{-1}\n    term = A_inv @ np.outer(b_vec, b_vec) @ A_inv\n    return A_inv + var_x * term\n\ndef umbrella_var_x(kx_eff, k_umb):\n    # Analytical variance for quadratic umbrella bias\n    return 1.0 / (kx_eff + k_umb)\n\ndef meta_var_x(kx_eff, hills, centers, width):\n    # Compute Var(x) under metadynamics bias via 1D quadrature\n    # V_meta(x) = sum h_n exp(-(x - s_n)^2 / (2 w^2))\n    def V_meta(x):\n        # Use vectorized-like sum\n        total = 0.0\n        for h, s in zip(hills, centers):\n            dx = x - s\n            total += h * np.exp(-0.5 * (dx * dx) / (width * width))\n        return total\n\n    def weight(x):\n        return np.exp(-0.5 * kx_eff * x * x - V_meta(x))\n\n    # Compute Z = ∫ w(x) dx and M2 = ∫ x^2 w(x) dx\n    # Use high accuracy; integrand decays rapidly due to quadratic term\n    Z, _ = integrate.quad(lambda x: weight(x), -np.inf, np.inf, epsabs=1e-10, epsrel=1e-10, limit=200)\n    M2, _ = integrate.quad(lambda x: x * x * weight(x), -np.inf, np.inf, epsabs=1e-10, epsrel=1e-10, limit=200)\n    return M2 / Z\n\ndef compute_distortions(case):\n    # Unpack parameters\n    (k_x, k_y, k_z, k_yz, k_xy, k_xz,\n     k_umb, x0, N, hills, centers, w) = case\n\n    # Build matrices and vectors\n    A, A_inv = compute_A_inverse(k_y, k_z, k_yz)\n    b = np.array([k_xy, k_xz], dtype=float)\n\n    # Effective stiffness along x\n    kx_eff = effective_kx(k_x, b, A_inv)\n    if kx_eff <= 0:\n        # For robustness, raise an error if parameters are not physically consistent\n        raise ValueError(\"Effective stiffness kx_eff must be positive for normalizable distribution.\")\n\n    # Native variance of x and native orthogonal covariance\n    var_x_native = 1.0 / kx_eff\n    Sigma_native = sigma_orth(A_inv, b, var_x_native)\n\n    # Umbrella variance (independent of x0) and covariance\n    var_x_umb = umbrella_var_x(kx_eff, k_umb)\n    Sigma_umb = sigma_orth(A_inv, b, var_x_umb)\n\n    # Metadynamics variance and covariance\n    # Ensure hills and centers lengths == N\n    hills = list(hills)[:N]\n    centers = list(centers)[:N]\n    var_x_meta = meta_var_x(kx_eff, hills, centers, w)\n    Sigma_meta = sigma_orth(A_inv, b, var_x_meta)\n\n    # Distortions relative to native\n    denom = frobenius_norm(Sigma_native)\n    # Handle case where denom is zero (e.g., if b=0 and A_inv=0, though unlikely)\n    if np.isclose(denom, 0.0):\n        return [0.0, 0.0]\n\n    delta_umb = frobenius_norm(Sigma_umb - Sigma_native) / denom\n    delta_meta = frobenius_norm(Sigma_meta - Sigma_native) / denom\n\n    return [delta_umb, delta_meta]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: happy path\n        (3.0, 2.0, 1.5, 0.2, 0.3, -0.25, 4.0, 0.5, 3, [0.8, 0.6, 0.4], [-0.5, 0.0, 0.5], 0.4),\n        # Case 2: boundary, zero coupling to x\n        (2.2, 1.8, 1.3, 0.3, 0.0, 0.0, 3.0, -0.1, 2, [1.0, 0.5], [-0.2, 0.7], 0.5),\n        # Case 3: edge case, strong orthogonal coupling and moderate x coupling\n        (5.0, 1.5, 1.1, 0.9, 0.7, 0.6, 0.5, -0.2, 4, [2.0, 1.7, 1.3, 0.9], [-1.0, -0.3, 0.3, 1.1], 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        deltas = compute_distortions(case)\n        results.append(deltas)\n\n    # Final print statement in the exact required format.\n    # Produce a single line of output containing the list of lists.\n    # Ensure no extra text is printed.\n    def format_inner_list(lst):\n        return \"[\" + \",\".join(f\"{x:.10f}\" for x in lst) + \"]\"\n    print(\"[\" + \",\".join(format_inner_list(r) for r in results) + \"]\")\n\nsolve()\n```", "id": "3406465"}]}