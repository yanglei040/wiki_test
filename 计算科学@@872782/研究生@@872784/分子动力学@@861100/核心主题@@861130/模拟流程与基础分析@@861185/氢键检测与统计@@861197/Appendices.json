{"hands_on_practices": [{"introduction": "在分子动力学模拟中，为了模拟体相系统，我们通常采用周期性边界条件（PBC）。正确处理这些边界是进行任何结构或动态分析的绝对前提。本练习将引导你掌握最小镜像约定（Minimum Image Convention, MIC），这是在周期性系统中准确计算原子间距离和矢量所必需的基本工具。通过解决一个具体问题，你将巩固对这一关键概念的理解，为后续更复杂的分析奠定坚实的基础 [@problem_id:3416831]。", "problem": "考虑在具有周期性边界条件 (PBC) 的立方模拟盒子中，水分子的分子动力学 (MD) 轨迹。氢键检测通常需要计算供体-受体 (D–A) 重原子距离和氢-受体 (H–A) 距离，并且这些距离必须在 PBC 下计算，以避免因原子跨越边界而产生的假象。该问题的基本原理如下。在 PBC 下，物理空间是原始模拟单元通过平移对 $\\mathbb{R}^3$ 的一种密铺。任何位置矢量 $\\mathbf{r}$ 都等效于 $\\mathbf{r} + \\mathbf{n} L$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$，$L$ 是立方盒子的边长。氢键判据的相关几何度量是欧几里得范数，即在无限周期性密铺中，位于位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的两个粒子之间的距离由 $d = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$ 给出。在 PBC 下，物理上有意义的粒子间分离距离是所有周期性镜像中的最小欧几里得距离，即对于某个 $\\mathbf{n} \\in \\mathbb{Z}^3$，选择唯一的粒子 $j$ 的镜像来最小化 $\\lVert \\mathbf{r}_j + \\mathbf{n}L - \\mathbf{r}_i \\rVert$。这种构造方法被称为最小镜像约定 (MIC)。\n\n给定一个边长为 $L = 3.0\\,\\mathrm{nm}$ 的立方盒子。一个供体重原子 $D$ 位于 $\\mathbf{r}_{D} = (2.90, 0.10, 1.50)\\,\\mathrm{nm}$，其成键氢原子 $H$ 位于 $\\mathbf{r}_{H} = (2.95, 0.10, 1.50)\\,\\mathrm{nm}$，一个受体重原子 $A$ 位于 $\\mathbf{r}_{A} = (0.05, 0.10, 1.50)\\,\\mathrm{nm}$。如果不使用 MIC，朴素的差值 $\\mathbf{r}_{A} - \\mathbf{r}_{D}$ 会沿 $x$ 轴产生一个很大的分离距离，因为 $D$ 和 $A$ 位于盒子的相对两侧附近。\n\n请选择一个选项，该选项正确定义了立方盒子中的最小镜像约定，并使用该定义解释了为什么 MIC 能够避免在氢键检测中出现虚假的过长 D–A 和 H–A 距离。在相关的情况下，请陈述给定坐标下得到的 D–A 和 H–A 距离。\n\nA. 立方盒子中的 MIC 位移是按分量计算的，公式为 $\\Delta \\mathbf{r} = \\mathbf{r}_{j} - \\mathbf{r}_{i} - L \\,\\mathrm{round}\\!\\left(\\dfrac{\\mathbf{r}_{j} - \\mathbf{r}_{i}}{L}\\right)$，其中 $\\mathrm{round}$ 函数作用于每个笛卡尔分量，产生在 $(-L/2, L/2]$ 范围内的分量。这会得到所有周期性镜像中的最短距离。对于给定的 $D$、$H$ 和 $A$，应用 MIC 得到 $\\Delta \\mathbf{r}_{DA} = (0.15, 0.00, 0.00)\\,\\mathrm{nm}$ 和 $\\Delta \\mathbf{r}_{HA} = (0.10, 0.00, 0.00)\\,\\mathrm{nm}$，因此 $d_{\\mathrm{DA}} = 0.15\\,\\mathrm{nm}$ 和 $d_{\\mathrm{HA}} = 0.10\\,\\mathrm{nm}$，从而避免了由边界穿越引起的虚假的过长距离。\n\nB. 立方盒子中的 MIC 位移应使用 $\\Delta \\mathbf{r} = \\mathbf{r}_{j} - \\mathbf{r}_{i} - L \\,\\mathrm{floor}\\!\\left(\\dfrac{\\mathbf{r}_{j} - \\mathbf{r}_{i}}{L}\\right)$ 按分量计算，以便分量落在 $[0, L)$ 区间内。这保证了最小距离，因为所有分量都是非负且小于 $L$ 的。对于给定的坐标，这给出了 $d_{\\mathrm{DA}} = 2.85\\,\\mathrm{nm}$ 和 $d_{\\mathrm{HA}} = 2.90\\,\\mathrm{nm}$，表明朴素的大分离距离是真正的最小值。\n\nC. MIC 位移可以通过将朴素位移均匀地向零收缩来计算：$\\Delta \\mathbf{r} = \\mathbf{r}_{j} - \\mathbf{r}_{i} - L\\, \\mathrm{round}\\!\\left(\\dfrac{\\lVert \\mathbf{r}_{j} - \\mathbf{r}_{i} \\rVert}{L}\\right) \\dfrac{\\mathbf{r}_{j} - \\mathbf{r}_{i}}{\\lVert \\mathbf{r}_{j} - \\mathbf{r}_{i} \\rVert}$，这通过减小位移的大小来保证得到最短镜像。对于给定的 $D$、$H$ 和 $A$，这会产生与朴素距离相同的距离。\n\nD. MIC 位移是通过最小化所有 $27$ 个镜像的平方距离得到的，但有一个平局打破规则，该规则将每个分量映射到 $[-L, 0)$，这确保了分量的大小从不超过 $L$。这仅能防止沿一个轴的虚假过长距离；对于给定的坐标，它使 $d_{\\mathrm{DA}}$ 与朴素值相比保持不变。\n\nE. 在 PBC 下进行氢键检测时，仅对 D–A 距离应用 MIC 就足够了；H–A 距离可以朴素地计算，因为氢原子 $H$ 与供体 $D$ 共价键合，所以 $d_{\\mathrm{HA}}$ 可以从 $d_{\\mathrm{DA}}$ 推导出来，无需独立的周期性包裹。因此，对于给定的坐标，即使没有 MIC，$d_{\\mathrm{HA}} = d_{\\mathrm{DA}} - 0.05\\,\\mathrm{nm}$。", "solution": "用户希望我扮演一名 STEM 教授，批判性地验证并解决一个关于分子动力学模拟中最小镜像约定 (MIC) 的问题。\n\n### 第 1 步：提取已知条件\n- **系统**：在具有周期性边界条件 (PBC) 的立方模拟盒子中，水分子的分子动力学 (MD) 轨迹。\n- **盒子尺寸**：边长 $L = 3.0\\,\\mathrm{nm}$ 的立方盒子。\n- **PBC 定义**：任何位置矢量 $\\mathbf{r}$ 等效于 $\\mathbf{r} + \\mathbf{n} L$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。\n- **MIC 定义**：物理上有意义的粒子间分离距离是所有周期性镜像中的最小欧几里得距离，这对应于寻找一个整数矢量 $\\mathbf{n}$ 来最小化 $\\lVert (\\mathbf{r}_j + \\mathbf{n}L) - \\mathbf{r}_i \\rVert$。\n- **粒子坐标**：\n    - 供体重原子 $D$：$\\mathbf{r}_{D} = (2.90, 0.10, 1.50)\\,\\mathrm{nm}$。\n    - 氢原子 $H$：$\\mathbf{r}_{H} = (2.95, 0.10, 1.50)\\,\\mathrm{nm}$。\n    - 受体重原子 $A$：$\\mathbf{r}_{A} = (0.05, 0.10, 1.50)\\,\\mathrm{nm}$。\n- **任务**：选择一个选项，该选项正确定义了立方盒子中的 MIC，并解释了它在防止氢键检测中出现虚假过长距离方面的作用，包括为给定坐标计算出的距离。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题牢固地植根于计算化学和物理的标准实践中，特别是在分子动力学模拟的背景下。周期性边界条件和最小镜像约定是模拟体相系统的基本、普遍接受的技术。该问题在科学上是合理的。\n2.  **适定性**：该问题提供了所有必要的数据（$L$、粒子坐标）和定义（PBC、MIC 概念），足以得出一个唯一的解。问题是具体且可回答的。\n3.  **客观性**：语言精确且技术性强。定义和数据都是定量的。没有主观或基于观点的陈述。\n4.  **完整性**：问题是自洽的，并提供了足够的信息。\n5.  **一致性**：所提供的信息中没有矛盾。上下文（氢键检测）和方法（MIC）被恰当地联系在一起。\n\n### 第 3 步：结论和行动\n问题陈述是有效的。这是一个来自计算分子科学领域的、适定的、有科学依据的问题。我将继续进行完整的推导和选项评估。\n\n### 解题推导\n\n最小镜像约定 (MIC) 旨在找到连接粒子 $i$ 和粒子 $j$ 的任意周期性镜像的最短矢量。对于边长为 $L$ 的立方模拟盒子，位移矢量 $\\mathbf{r}_j - \\mathbf{r}_i$ 的分量是独立考虑的。设朴素位移矢量为 $\\boldsymbol{\\delta} = \\mathbf{r}_j - \\mathbf{r}_i$。对于每个分量 $\\delta_k$ (其中 $k \\in \\{x, y, z\\}$)，MIC 找到校正后的位移 $\\Delta r_k$，该位移位于区间 $[-L/2, L/2]$ 内（或等效的区间，如 $(-L/2, L/2]$）。\n\n这是通过加上或减去盒子长度 $L$ 的整数倍来实现的。将其形式化的最直接方法是：\n$$ \\Delta r_k = \\delta_k - L \\cdot \\mathrm{nint}(\\delta_k / L) $$\n其中 $\\mathrm{nint}$ 是最近整数函数（例如，在许多编程语言中的 `round` 函数）。此操作有效地检查 $\\delta_k > L/2$，如果是，则减去 $L$；或者检查 $\\delta_k  -L/2$，如果是，则加上 $L$，从而将位移“包裹”到最近的镜像。最终的 MIC 距离是校正后位移矢量 $\\Delta\\mathbf{r} = (\\Delta r_x, \\Delta r_y, \\Delta r_z)$ 的欧几里得范数，即 $d = \\lVert \\Delta\\mathbf{r} \\rVert$。\n\n让我们将此方法应用于给定的坐标，其中 $L=3.0\\,\\mathrm{nm}$。\n\n**1. 供体-受体 (D-A) 距离：**\n粒子位置为 $\\mathbf{r}_{D} = (2.90, 0.10, 1.50)\\,\\mathrm{nm}$ 和 $\\mathbf{r}_{A} = (0.05, 0.10, 1.50)\\,\\mathrm{nm}$。\n\n朴素位移矢量为：\n$$ \\boldsymbol{\\delta}_{DA} = \\mathbf{r}_{A} - \\mathbf{r}_{D} = (0.05 - 2.90, 0.10 - 0.10, 1.50 - 1.50)\\,\\mathrm{nm} = (-2.85, 0.00, 0.00)\\,\\mathrm{nm} $$\n朴素距离为 $\\lVert \\boldsymbol{\\delta}_{DA} \\rVert = 2.85\\,\\mathrm{nm}$，正如问题中所指出的，这是一个虚假的过长距离。\n\n现在，我们对每个分量应用 MIC 校正：\n-   **x 分量**：$\\delta_x = -2.85\\,\\mathrm{nm}$。比率为 $\\delta_x/L = -2.85/3.0 = -0.95$。最近的整数是 $\\mathrm{nint}(-0.95) = -1$。\n    校正后的位移是 $\\Delta r_x = -2.85 - (3.0 \\cdot (-1)) = -2.85 + 3.0 = 0.15\\,\\mathrm{nm}$。\n-   **y 分量**：$\\delta_y = 0.00\\,\\mathrm{nm}$。比率为 $\\delta_y/L = 0.0$。最近的整数是 $\\mathrm{nint}(0.0) = 0$。\n    校正后的位移是 $\\Delta r_y = 0.00 - (3.0 \\cdot 0) = 0.00\\,\\mathrm{nm}$。\n-   **z 分量**：$\\delta_z = 0.00\\,\\mathrm{nm}$。比率为 $\\delta_z/L = 0.0$。最近的整数是 $\\mathrm{nint}(0.0) = 0$。\n    校正后的位移是 $\\Delta r_z = 0.00 - (3.0 \\cdot 0) = 0.00\\,\\mathrm{nm}$。\n\nD-A 对的 MIC 位移矢量为 $\\Delta\\mathbf{r}_{DA} = (0.15, 0.00, 0.00)\\,\\mathrm{nm}$。\nMIC 距离为 $d_{\\mathrm{DA}} = \\lVert \\Delta\\mathbf{r}_{DA} \\rVert = \\sqrt{(0.15)^2 + (0.00)^2 + (0.00)^2} = 0.15\\,\\mathrm{nm}$。\n\n**2. 氢-受体 (H-A) 距离：**\n粒子位置为 $\\mathbf{r}_{H} = (2.95, 0.10, 1.50)\\,\\mathrm{nm}$ 和 $\\mathbf{r}_{A} = (0.05, 0.10, 1.50)\\,\\mathrm{nm}$。\n\n朴素位移矢量为：\n$$ \\boldsymbol{\\delta}_{HA} = \\mathbf{r}_{A} - \\mathbf{r}_{H} = (0.05 - 2.95, 0.10 - 0.10, 1.50 - 1.50)\\,\\mathrm{nm} = (-2.90, 0.00, 0.00)\\,\\mathrm{nm} $$\n朴素距离为 $\\lVert \\boldsymbol{\\delta}_{HA} \\rVert = 2.90\\,\\mathrm{nm}$。\n\n应用 MIC 校正：\n-   **x 分量**：$\\delta_x = -2.90\\,\\mathrm{nm}$。比率为 $\\delta_x/L = -2.90/3.0 \\approx -0.967$。最近的整数是 $\\mathrm{nint}(-0.967) = -1$。\n    校正后的位移是 $\\Delta r_x = -2.90 - (3.0 \\cdot (-1)) = -2.90 + 3.0 = 0.10\\,\\mathrm{nm}$。\n-   **y 分量**：$\\delta_y = 0.00\\,\\mathrm{nm}$，校正后为 $0.00\\,\\mathrm{nm}$。\n-   **z 分量**：$\\delta_z = 0.00\\,\\mathrm{nm}$，校正后为 $0.00\\,\\mathrm{nm}$。\n\nH-A 对的 MIC 位移矢量为 $\\Delta\\mathbf{r}_{HA} = (0.10, 0.00, 0.00)\\,\\mathrm{nm}$。\nMIC 距离为 $d_{\\mathrm{HA}} = \\lVert \\Delta\\mathbf{r}_{HA} \\rVert = \\sqrt{(0.10)^2 + (0.00)^2 + (0.00)^2} = 0.10\\,\\mathrm{nm}$。\n\n这些距离（$0.15\\,\\mathrm{nm}$ 和 $0.10\\,\\mathrm{nm}$）对于氢键体系是物理上合理的，表明 MIC 正确地识别了跨越周期性边界的“最短路径”距离。\n\n### 逐项分析\n\n**A. 立方盒子中的 MIC 位移是按分量计算的，公式为 $\\Delta \\mathbf{r} = \\mathbf{r}_{j} - \\mathbf{r}_{i} - L \\,\\mathrm{round}\\!\\left(\\dfrac{\\mathbf{r}_{j} - \\mathbf{r}_{i}}{L}\\right)$，其中 $\\mathrm{round}$ 函数作用于每个笛卡尔分量，产生在 $(-L/2, L/2]$ 范围内的分量。这会得到所有周期性镜像中的最短距离。对于给定的 $D$、$H$ 和 $A$，应用 MIC 得到 $\\Delta \\mathbf{r}_{DA} = (0.15, 0.00, 0.00)\\,\\mathrm{nm}$ 和 $\\Delta \\mathbf{r}_{HA} = (0.10, 0.00, 0.00)\\,\\mathrm{nm}$，因此 $d_{\\mathrm{DA}} = 0.15\\,\\mathrm{nm}$ 和 $d_{\\mathrm{HA}} = 0.10\\,\\mathrm{nm}$，从而避免了由边界穿越引起的虚假的过长距离。**\n-   **公式和原理**：所提供的公式是立方盒子 MIC 的标准、正确的数学实现。`round` 函数等同于我在推导中使用的最近整数函数。对其目的的解释是准确的。指定的范围 $(-L/2, L/2]$ 是输出分量的一种常见且有效的约定。\n-   **计算**：所述的位移矢量 $\\Delta\\mathbf{r}_{DA}$ 和 $\\Delta\\mathbf{r}_{HA}$ 以及得到的距离 $d_{\\mathrm{DA}}$ 和 $d_{\\mathrm{HA}}$ 与我的推导完全匹配。\n-   **结论**：正确。\n\n**B. 立方盒子中的 MIC 位移应使用 $\\Delta \\mathbf{r} = \\mathbf{r}_{j} - \\mathbf{r}_{i} - L \\,\\mathrm{floor}\\!\\left(\\dfrac{\\mathbf{r}_{j} - \\mathbf{r}_{i}}{L}\\right)$ 按分量计算，以便分量落在 $[0, L)$ 区间内。这保证了最小距离，因为所有分量都是非负且小于 $L$ 的。对于给定的坐标，这给出了 $d_{\\mathrm{DA}} = 2.85\\,\\mathrm{nm}$ 和 $d_{\\mathrm{HA}} = 2.90\\,\\mathrm{nm}$，表明朴素的大分离距离是真正的最小值。**\n-   **公式和原理**：使用 `floor` 函数的公式通常不会产生最小镜像位移矢量。它通常用于将粒子坐标包裹回主模拟盒子 $[0, L)^3$，而不是用于计算位移。例如，一个位移分量可以是 $0.9L$，如果替代方案是 $-0.1L$，那么 $0.9L$ 就不是最小镜像。\n-   **计算**：该选项声称此公式得出 $d_{\\mathrm{DA}} = 2.85\\,\\mathrm{nm}$ 和 $d_{\\mathrm{HA}} = 2.90\\,\\mathrm{nm}$。这在内部是矛盾的。让我们将他们的公式应用于 $\\delta_{DA,x} = -2.85$：$\\Delta r_x = -2.85 - 3.0 \\cdot \\mathrm{floor}(-2.85/3.0) = -2.85 - 3.0 \\cdot (-1) = 0.15$。距离应为 $0.15\\,\\mathrm{nm}$，而不是 $2.85\\,\\mathrm{nm}$。该选项陈述的计算值对应于朴素距离，而不是其自身公式的结果。\n-   **结论**：声称朴素分离距离是真正的最小值是根本错误的，并且违背了 MIC 的目的。\n-   **结论**：不正确。\n\n**C. MIC 位移可以通过将朴素位移均匀地向零收缩来计算：$\\Delta \\mathbf{r} = \\mathbf{r}_{j} - \\mathbf{r}_{i} - L\\, \\mathrm{round}\\!\\left(\\dfrac{\\lVert \\mathbf{r}_{j} - \\mathbf{r}_{i} \\rVert}{L}\\right) \\dfrac{\\mathbf{r}_{j} - \\mathbf{r}_{i}}{\\lVert \\mathbf{r}_{j} - \\mathbf{r}_{i} \\rVert}$，这通过减小位移的大小来保证得到最短镜像。对于给定的 $D$、$H$ 和 $A$，这会产生与朴素距离相同的距离。**\n-   **公式和原理**：这个公式在概念上是有缺陷的。它试图校正位移矢量的大小，而不是其各个笛卡尔分量。对于沿笛卡尔轴应用 PBC 的立方盒子来说，这是不正确的。周期性不是各向同性的。对于预期目的，该表达式在数学上是畸形的。对于我们的 D-A 情况，其中 $\\boldsymbol{\\delta}_{DA} = (-2.85, 0, 0)$，它会得出 $\\Delta \\mathbf{r} = (-2.85, 0, 0) - 3.0 \\cdot \\mathrm{round}(2.85/3.0) \\cdot \\frac{(-2.85, 0, 0)}{2.85} = (-2.85, 0, 0) - 3.0 \\cdot 1 \\cdot (-1, 0, 0) = (-2.85, 0, 0) + (3.0, 0, 0) = (0.15, 0, 0)$。对于这个一维情况，它偶然给出了正确答案，但该公式不具有普适性。对于像 $(2.8, 2.8, 0)$ 这样的矢量，它将完全失败。声称它“产生与朴素距离相同的距离”也是错误的。\n-   **结论**：不正确。\n\n**D. MIC 位移是通过最小化所有 $27$ 个镜像的平方距离得到的，但有一个平局打破规则，该规则将每个分量映射到 $[-L, 0)$，这确保了分量的大小从不超过 $L$。这仅能防止沿一个轴的虚假过长距离；对于给定的坐标，它使 $d_{\\mathrm{DA}}$ 与朴素值相比保持不变。**\n-   **原理**：MIC 位移分量必须落在 $[-L/2, L/2]$ 范围内。区间 $[-L, 0)$ 是不正确和不对称的，并且不保证最小距离。此外，MIC 同等地应用于所有轴，而不是“仅沿一个轴”。\n-   **结论**：这些说法在事实上是错误的。应用他们的规则，分量 $\\delta_{DA,x} = -2.85$ 在 $[-3.0, 0)$ 内，所以它将保持不变，导致错误的距离。整个前提是有缺陷的。\n-   **结论**：不正确。\n\n**E. 在 PBC 下进行氢键检测时，仅对 D–A 距离应用 MIC 就足够了；H–A 距离可以朴素地计算，因为氢原子 $H$ 与供体 $D$ 共价键合，所以 $d_{\\mathrm{HA}}$ 可以从 $d_{\\mathrm{DA}}$ 推导出来，无需独立的周期性包裹。因此，对于给定的坐标，即使没有 MIC，$d_{\\mathrm{HA}} = d_{\\mathrm{DA}} - 0.05\\,\\mathrm{nm}$。**\n-   **原理**：这是一个谬误的捷径。虽然 $H$ 与 $D$ 共价键合，但从 $A$ 到 $H$ 的矢量是独立的，也必须使用 MIC 计算。矢量之间的关系是 $\\Delta\\mathbf{r}_{HA} = \\Delta\\mathbf{r}_{DA} - \\Delta\\mathbf{r}_{DH}$。不能简单地减去大小，即 $d_{HA} \\neq d_{DA} - d_{DH}$，除非所有三个矢量共线，这在一般情况下是不成立的。\n-   **计算**：对于这个具体问题，原子沿 x 轴共线排列，所以 $\\Delta\\mathbf{r}_{DA}$、$\\Delta\\mathbf{r}_{DH}$ 和 $\\Delta\\mathbf{r}_{HA}$ 都是平行的。因此，标量减法 $d_{HA} = d_{DA} - d_{DH}$ 恰好成立：$0.10\\,\\mathrm{nm} = 0.15\\,\\mathrm{nm} - 0.05\\,\\mathrm{nm}$。然而，将此作为一般原则提出是根本错误的，并且对于非共线几何形状会失败。声称 H-A 距离可以“朴素地”计算也是错误的；必须正确应用 MIC。\n-   **结论**：不正确。其推理不健全且不具有普适性，尽管在这个人为设计的例子中得出了正确的数值结果。", "answer": "$$\\boxed{A}$$", "id": "3416831"}, {"introduction": "理解了最小镜像约定（MIC）的原理之后，下一步是将其付诸实践并体会其重要性。本练习要求你编写代码，直接对比忽略周期性边界条件（naive algorithm）和正确应用最小镜像约定（MIC-consistent algorithm）对氢键几何分析的影响。通过这个实践，你将亲眼看到忽略PBC会如何引入严重的计算伪影，并学会如何通过计算二维分布函数 $g_{\\mathrm{HB}}(r,\\theta)$ 并量化其偏差，来评估算法的正确性 [@problem_id:3416826]。", "problem": "在分子动力学中，您有一项任务，需要严格评估周期性边界条件 (PBC) 和映象选择对立方模拟盒子边缘附近氢键检测的影响。您的目标是从基本原理出发，推导一种用于评估氢键几何结构的最小映象一致性算法，并量化在氢键径向-角向分布函数（记为 $g_{\\mathrm{HB}}(r,\\theta)$，其中 $r$ 是受体-氢距离，$\\theta$ 是供体-氢-受体角）中由此产生的偏差。在一个边长为 $L$、具有周期性边界条件的立方盒子中进行计算，并将所有分子视为刚性类水实体，以构建供体和受体集合。\n\n从以下基本原理开始：\n- 在周期性边界条件下，物理系统被建模为主模拟盒子的无限平铺，并且必须使用“最近映象”几何来计算原子间向量。最小映象约定指出，两个位置之间物理相关的位移向量是在所有周期性映象中具有最小欧几里得范数的那个。\n- 氢键几何结构由数对 $(r,\\theta)$ 定义，其中 $r$ 等于从氢到受体重原子的向量范数，$\\theta$ 等于在氢原子处，从氢到其供体重原子的向量与从氢到受体重原子的向量之间的夹角。距离必须以埃（ångström）为单位表示，角度必须以度为单位表示。\n\n您的程序必须实现两种算法，用于评估测试套件中所有帧中所有供体-受体候选对的 $(r,\\theta)$：\n1. 一种朴素的、非映象的算法，该算法计算原始笛卡尔坐标差，而不调用周期性最小映象映射。\n2. 一种最小映象一致性算法，该算法对供体-氢向量和氢-受体向量使用相同的周期性映射，从而确保与周期性边界条件的兼容性。\n\n使用这两种算法，计算在固定区间上近似 $g_{\\mathrm{HB}}(r,\\theta)$ 的二维直方图，并将其归一化为概率密度，使得在直方图域上的积分等于 $1$。通过计算归一化直方图之间的均方根差，量化朴素算法相对于最小映象一致性算法所引起的偏差。对于每个测试案例，将此单一标量偏差报告为无量纲浮点数。\n\n测试套件和几何规格：\n- 使用类水分子，每个分子包含一个位于位置 $\\mathbf{O}$ 的供体重原子和两个位于位置 $\\mathbf{H}_1$ 和 $\\mathbf{H}_2$ 的氢原子。氢原子相对于 $\\mathbf{O}$ 的位置使用固定的偏移量 $\\Delta \\mathbf{r}_1 = (0.95,0,0)$ 和 $\\Delta \\mathbf{r}_2 = (-0.24,0.93,0)$（单位为埃）来确定，然后对每个笛卡尔分量使用模运算将每个氢的坐标包裹到主盒子 $[0,L)$ 内。每个分子的氧原子 $\\mathbf{O}$ 是供体重原子。每个氧原子 $\\mathbf{O}$ 也充当其他分子所有氢原子的受体（仅限跨分子对）。\n- 对于每个测试案例，程序必须跨越两个帧进行评估。距离必须以埃为单位计算，角度以度为单位。径向直方图必须使用区间边界 $[1.5,1.9,2.3,2.7,3.1,3.5]$（单位为埃），角向直方图必须使用区间边界 $[120,130,140,150,160,170,180]$（单位为度）。二维直方图必须归一化为概率密度 $g_{\\mathrm{HB}}(r,\\theta)$，使得所有区间的 $g_{\\mathrm{HB}}(r,\\theta)\\,\\Delta r\\,\\Delta \\theta$ 之和等于 $1$，其中 $\\Delta r$ 和 $\\Delta \\theta$ 分别是 $r$ 和 $\\theta$ 的区间宽度。如果一个测试案例在直方图域内没有产生任何数对，则将其直方图定义为恒等于零，偏差定义为 $0$。\n- 测试套件包含四个案例，参数如下：\n    - 案例 1：$L = 10$ 埃，第 1 帧分子：\n        - 分子 $\\mathrm{A}$：$\\mathbf{O} = (9.8,5.0,5.0)$，$\\mathbf{H}_1 = (0.75,5.0,5.0)$，$\\mathbf{H}_2 = (9.56,5.93,5.0)$。\n        - 分子 $\\mathrm{B}$：$\\mathbf{O} = (2.4,5.2,5.0)$，$\\mathbf{H}_1 = (3.35,5.2,5.0)$，$\\mathbf{H}_2 = (2.16,6.13,5.0)$。\n      第 2 帧分子：\n        - 分子 $\\mathrm{A}$：$\\mathbf{O} = (9.9,5.1,5.0)$，$\\mathbf{H}_1 = (0.85,5.1,5.0)$，$\\mathbf{H}_2 = (9.66,6.03,5.0)$。\n        - 分子 $\\mathrm{B}$：$\\mathbf{O} = (2.5,5.1,5.0)$，$\\mathbf{H}_1 = (3.45,5.1,5.0)$，$\\mathbf{H}_2 = (2.26,6.03,5.0)$。\n    - 案例 2：$L = 20$ 埃，第 1 帧分子：\n        - 分子 $\\mathrm{C}$：$\\mathbf{O} = (10.0,10.0,10.0)$，$\\mathbf{H}_1 = (10.95,10.0,10.0)$，$\\mathbf{H}_2 = (9.76,10.93,10.0)$。\n        - 分子 $\\mathrm{D}$：$\\mathbf{O} = (14.0,14.0,14.0)$，$\\mathbf{H}_1 = (14.95,14.0,14.0)$，$\\mathbf{H}_2 = (13.76,14.93,14.0)$。\n      第 2 帧分子：\n        - 分子 $\\mathrm{C}$：$\\mathbf{O} = (10.1,10.1,10.0)$，$\\mathbf{H}_1 = (11.05,10.1,10.0)$，$\\mathbf{H}_2 = (9.86,11.03,10.0)$。\n        - 分子 $\\mathrm{D}$：$\\mathbf{O} = (13.9,14.1,14.0)$，$\\mathbf{H}_1 = (14.85,14.1,14.0)$，$\\mathbf{H}_2 = (13.66,15.03,14.0)$。\n    - 案例 3：$L = 8$ 埃，第 1 帧分子：\n        - 分子 $\\mathrm{E}$：$\\mathbf{O} = (7.9,3.0,3.0)$，$\\mathbf{H}_1 = (0.85,3.0,3.0)$，$\\mathbf{H}_2 = (7.66,3.93,3.0)$。\n        - 分子 $\\mathrm{F}$：$\\mathbf{O} = (2.4,3.1,3.0)$，$\\mathbf{H}_1 = (3.35,3.1,3.0)$，$\\mathbf{H}_2 = (2.16,4.03,3.0)$。\n      第 2 帧分子：\n        - 分子 $\\mathrm{E}$：$\\mathbf{O} = (7.85,3.1,3.0)$，$\\mathbf{H}_1 = (0.80,3.1,3.0)$，$\\mathbf{H}_2 = (7.61,4.03,3.0)$。\n        - 分子 $\\mathrm{F}$：$\\mathbf{O} = (2.5,3.2,3.0)$，$\\mathbf{H}_1 = (3.45,3.2,3.0)$，$\\mathbf{H}_2 = (2.26,4.13,3.0)$。\n    - 案例 4：$L = 12$ 埃，第 1 帧分子：\n        - 分子 $\\mathrm{G}$：$\\mathbf{O} = (1.0,1.0,1.0)$，$\\mathbf{H}_1 = (1.95,1.0,1.0)$，$\\mathbf{H}_2 = (0.76,1.93,1.0)$。\n        - 分子 $\\mathrm{H}$：$\\mathbf{O} = (9.5,9.5,9.5)$，$\\mathbf{H}_1 = (10.45,9.5,9.5)$，$\\mathbf{H}_2 = (9.26,10.43,9.5)$。\n      第 2 帧分子：\n        - 分子 $\\mathrm{G}$：$\\mathbf{O} = (1.5,1.5,1.0)$，$\\mathbf{H}_1 = (2.45,1.5,1.0)$，$\\mathbf{H}_2 = (1.26,2.43,1.0)$。\n        - 分子 $\\mathrm{H}$：$\\mathbf{O} = (9.0,9.0,10.0)$，$\\mathbf{H}_1 = (9.95,9.0,10.0)$，$\\mathbf{H}_2 = (8.76,9.93,10.0)$。\n\n程序要求：\n- 实现朴素算法和最小映象一致性算法，以计算每个测试案例中所有帧和分子中的所有供体-受体候选对的 $(r,\\theta)$，其中供体是 $(\\mathbf{O},\\mathbf{H}_k)$ 对，受体是其他分子的 $\\mathbf{O}$。\n- 根据指定的区间边界为 $r$（单位为埃）和 $\\theta$（单位为度）构建二维直方图，并按前述方法归一化为概率密度 $g_{\\mathrm{HB}}(r,\\theta)$。\n- 为每个测试案例计算偏差，该偏差定义为两个归一化直方图之间的均方根差。\n\n最终输出：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是对应于上述顺序的测试案例的偏差值（无量纲浮点数）。", "solution": "该问题要求在分子动力学背景下，对两种用于确定周期性边界条件 (PBC) 下氢键几何结构的计算算法进行严格比较。其目标是量化一种忽略 PBC 的朴素算法相对于一种物理上正确的最小映象一致性 (MIC) 算法所引入的偏差。该偏差通过每种方法产生的归一化二维径向-角向分布函数 $g_{\\mathrm{HB}}(r,\\theta)$ 之间的均方根差来衡量。\n\n基本原理和算法设计详述如下。所有数学实体均按要求使用 LaTeX 渲染。\n\n### 1. 周期性边界条件与最小映象约定\n\n在块体物质的计算机模拟中，采用周期性边界条件来减轻有限尺寸效应。模拟盒子被视作无限晶格的原胞，从而有效地创建了一个无限的周期性系统。当计算位于位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的两个粒子 $i$ 和 $j$ 之间的相互作用或几何关系时，必须考虑粒子 $i$ 与粒子 $j$ 的所有周期性映象之间的相互作用。\n\n最小映象约定 (MIC) 是实现此目的的标准程序。它规定，物理相关的位移是粒子 $i$ 和粒子 $j$ 的任何映象之间可能的最短向量。对于边长为 $L$ 的立方模拟盒子，原始位移向量为 $\\mathbf{d} = \\mathbf{r}_j - \\mathbf{r}_i$。最小映象向量 $\\mathbf{d}_{\\text{mic}}$ 的每个笛卡尔分量被计算到区间 $[-L/2, L/2]$ 内。这可以通过逐分量操作实现：\n$$\nd_{k, \\text{mic}} = d_k - L \\cdot \\left\\lfloor \\frac{d_k}{L} + \\frac{1}{2} \\right\\rfloor \\quad \\text{for } k \\in \\{x, y, z\\}\n$$\n其中 $\\lfloor \\cdot \\rfloor$ 是向下取整函数。此操作有效地找到粒子 $j$ 相对于粒子 $i$ 的最近映象。我们定义一个向量函数 $\\text{MIC}(\\mathbf{d}, L)$，它将此操作应用于 $\\mathbf{d}$ 的所有分量。\n\n### 2. 氢键几何结构定义\n\n氢键由供体-氢-受体三原子组来表征。设其位置分别为 $\\mathbf{r}_D$（供体重原子）、$\\mathbf{r}_H$（氢）和 $\\mathbf{r}_A$（受体重原子）。其几何结构由两个参数定义：\n1.  氢-受体距离 $r$，即从 $\\mathbf{H}$ 到 $\\mathbf{A}$ 的向量范数。\n2.  供体-氢-受体角 $\\theta$，即在氢原子处形成的夹角。\n\n两种算法的关键区别在于定义 $r$ 和 $\\theta$ 的向量是如何计算的。我们定义从氢原子出发的基本向量：\n-   从氢到供体的向量：$\\mathbf{v}_{HD} = \\mathbf{r}_D - \\mathbf{r}_H$\n-   从氢到受体的向量：$\\mathbf{v}_{HA} = \\mathbf{r}_A - \\mathbf{r}_H$\n\n### 3. 算法实现\n\n#### a. 朴素（非映象）算法\n该算法使用原始笛卡尔位移向量计算几何参数，而不考虑 PBC。这种方法存在根本性缺陷，因为它忽略了系统的周期性，导致对被盒子边界分隔的原子对计算出不正确的距离和角度。\n\n-   距离：$r_{\\text{naive}} = \\|\\mathbf{r}_A - \\mathbf{r}_H\\|_2$\n-   角度：该角度由原始向量的点积计算得出。\n    $$\n    \\theta_{\\text{naive}} = \\arccos\\left(\\frac{(\\mathbf{r}_D - \\mathbf{r}_H) \\cdot (\\mathbf{r}_A - \\mathbf{r}_H)}{\\|\\mathbf{r}_D - \\mathbf{r}_H\\|_2 \\cdot \\|\\mathbf{r}_A - \\mathbf{r}_H\\|_2}\\right)\n    $$\n    结果从弧度转换为度。\n\n#### b. 最小映象一致性 (MIC) 算法\n该算法将 MIC 正确地应用于几何计算中使用的所有位移向量。这确保了几何结构能反映在周期性复制空间中的真实邻近度。\n\n1.  计算从 $\\mathbf{H}$ 到 $\\mathbf{D}$ 的最小映象向量：$\\mathbf{v}_{HD}^{\\text{mic}} = \\text{MIC}(\\mathbf{r}_D - \\mathbf{r}_H, L)$。\n2.  计算从 $\\mathbf{H}$ 到 $\\mathbf{A}$ 的最小映象向量：$\\mathbf{v}_{HA}^{\\text{mic}} = \\text{MIC}(\\mathbf{r}_A - \\mathbf{r}_H, L)$。\n3.  使用这些经过 MIC 校正的向量计算距离和角度：\n    -   距离：$r_{\\text{mic}} = \\|\\mathbf{v}_{HA}^{\\text{mic}}\\|_2$\n    -   角度：\n        $$\n        \\theta_{\\text{mic}} = \\arccos\\left(\\frac{\\mathbf{v}_{HD}^{\\text{mic}} \\cdot \\mathbf{v}_{HA}^{\\text{mic}}}{\\|\\mathbf{v}_{HD}^{\\text{mic}}\\|_2 \\cdot \\|\\mathbf{v}_{HA}^{\\text{mic}}\\|_2}\\right)\n        $$\n        结果从弧度转换为度。\n\n### 4. 统计分析与偏差量化\n\n对于每种算法，收集所有有效供体-受体候选对和所有帧中计算出的所有 $(r, \\theta)$ 对的集合。\n\n#### a. 直方图构建\n使用提供的区间边界构建二维直方图：\n-   径向区间 ($r$)：边界为 $[1.5, 1.9, 2.3, 2.7, 3.1, 3.5]$ 埃。这产生 $5$ 个区间，每个区间的宽度为 $\\Delta r = 0.4$ Å。\n-   角向区间 ($\\theta$)：边界为 $[120, 130, 140, 150, 160, 170, 180]$ 度。这产生 $6$ 个区间，每个区间的宽度为 $\\Delta \\theta = 10$ 度。\n原始直方图 $N_{ij}$ 包含落入区间 $(i, j)$ 的 $(r, \\theta)$ 对的数量。\n\n#### b. 归一化\n原始计数 $N_{ij}$ 被归一化为概率密度函数 $g_{ij}$，使得在定义域上的积分为 1。设 $N_{\\text{total}} = \\sum_{i,j} N_{ij}$ 为落入直方图范围内的总对数。区间 $(i, j)$ 中的归一化密度为：\n$$\ng_{ij} = \\frac{N_{ij}}{N_{\\text{total}} \\cdot \\Delta r \\cdot \\Delta \\theta}\n$$\n此式在 $N_{\\text{total}} > 0$ 时有效。如果 $N_{\\text{total}} = 0$，则所有 $g_{ij}$ 都定义为 $0$。这种归一化确保了 $\\sum_{i,j} g_{ij} \\Delta r \\Delta \\theta = 1$。\n\n#### c. 偏差计算\n朴素算法引入的偏差通过两个归一化直方图 $g^{\\text{naive}}$ 和 $g^{\\text{mic}}$ 之间的均方根差 (RMSD) 来量化。求和遍及直方图的所有 $N_{\\text{bins}} = 5 \\times 6 = 30$ 个区间。\n$$\n\\text{Bias} = \\sqrt{\\frac{1}{N_{\\text{bins}}} \\sum_{i,j} (g_{ij}^{\\text{naive}} - g_{ij}^{\\text{mic}})^2}\n$$\n如果两个直方图都为空（即，对于两种算法，在指定范围内都未找到任何数对），则偏差为 $0$。\n\n### 5. 计算流程\n\n解决方案通过对每个测试案例执行以下步骤来进行：\n1.  初始化空列表以存储两种算法的 $(r, \\theta)$ 对。\n2.  遍历测试案例提供的两个帧。\n3.  对于每个帧，遍历所有可能的跨分子供体-受体配对。根据问题陈述，对于两个分子（例如 A 和 B），配对为（供体 A，受体 B）和（供体 B，受体 A）。\n4.  对于每个配对，遍历供体分子的两个氢原子。\n5.  对于每个产生的 D-H-A 三元组，使用朴素算法和 MIC 算法计算 $(r, \\theta)$。存储结果。\n6.  处理完所有数对后，根据收集到的数对和指定的区间边界生成二维直方图 $N_{ij}^{\\text{naive}}$ 和 $N_{ij}^{\\text{mic}}$。\n7.  将两个直方图都归一化以获得概率密度 $g_{ij}^{\\text{naive}}$ 和 $g_{ij}^{\\text{mic}}$。\n8.  使用 RMSD 公式计算最终的标量偏差。\n收集并报告所有四个案例的最终偏差值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hydrogen bond geometry problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 10.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (9.8, 5.0, 5.0), \"H1\": (0.75, 5.0, 5.0), \"H2\": (9.56, 5.93, 5.0)},\n                    {\"O\": (2.4, 5.2, 5.0), \"H1\": (3.35, 5.2, 5.0), \"H2\": (2.16, 6.13, 5.0)}\n                ],\n                [ # Frame 2\n                    {\"O\": (9.9, 5.1, 5.0), \"H1\": (0.85, 5.1, 5.0), \"H2\": (9.66, 6.03, 5.0)},\n                    {\"O\": (2.5, 5.1, 5.0), \"H1\": (3.45, 5.1, 5.0), \"H2\": (2.26, 6.03, 5.0)}\n                ]\n            ]\n        },\n        # Case 2\n        {\n            \"L\": 20.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (10.0, 10.0, 10.0), \"H1\": (10.95, 10.0, 10.0), \"H2\": (9.76, 10.93, 10.0)},\n                    {\"O\": (14.0, 14.0, 14.0), \"H1\": (14.95, 14.0, 14.0), \"H2\": (13.76, 14.93, 14.0)}\n                ],\n                [ # Frame 2\n                    {\"O\": (10.1, 10.1, 10.0), \"H1\": (11.05, 10.1, 10.0), \"H2\": (9.86, 11.03, 10.0)},\n                    {\"O\": (13.9, 14.1, 14.0), \"H1\": (14.85, 14.1, 14.0), \"H2\": (13.66, 15.03, 14.0)}\n                ]\n            ]\n        },\n        # Case 3\n        {\n            \"L\": 8.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (7.9, 3.0, 3.0), \"H1\": (0.85, 3.0, 3.0), \"H2\": (7.66, 3.93, 3.0)},\n                    {\"O\": (2.4, 3.1, 3.0), \"H1\": (3.35, 3.1, 3.0), \"H2\": (2.16, 4.03, 3.0)}\n                ],\n                [ # Frame 2\n                    {\"O\": (7.85, 3.1, 3.0), \"H1\": (0.80, 3.1, 3.0), \"H2\": (7.61, 4.03, 3.0)},\n                    {\"O\": (2.5, 3.2, 3.0), \"H1\": (3.45, 3.2, 3.0), \"H2\": (2.26, 4.13, 3.0)}\n                ]\n            ]\n        },\n        # Case 4\n        {\n            \"L\": 12.0,\n            \"frames\": [\n                [ # Frame 1\n                    {\"O\": (1.0, 1.0, 1.0), \"H1\": (1.95, 1.0, 1.0), \"H2\": (0.76, 1.93, 1.0)},\n                    {\"O\": (9.5, 9.5, 9.5), \"H1\": (10.45, 9.5, 9.5), \"H2\": (9.26, 10.43, 9.5)}\n                ],\n                [ # Frame 2\n                    {\"O\": (1.5, 1.5, 1.0), \"H1\": (2.45, 1.5, 1.0), \"H2\": (1.26, 2.43, 1.0)},\n                    {\"O\": (9.0, 9.0, 10.0), \"H1\": (9.95, 9.0, 10.0), \"H2\": (8.76, 9.93, 10.0)}\n                ]\n            ]\n        }\n    ]\n\n    r_bins = np.array([1.5, 1.9, 2.3, 2.7, 3.1, 3.5])\n    theta_bins = np.array([120, 130, 140, 150, 160, 170, 180])\n    delta_r = 0.4\n    delta_theta = 10.0\n    bin_area = delta_r * delta_theta\n    num_bins = (len(r_bins) - 1) * (len(theta_bins) - 1)\n\n\n    def calculate_bias_for_case(case_data):\n        L = case_data[\"L\"]\n        frames = case_data[\"frames\"]\n\n        pairs_naive = []\n        pairs_mic = []\n\n        def apply_mic(v, box_L):\n            return v - box_L * np.floor(v / box_L + 0.5)\n\n        for molecules_in_frame in frames:\n            mol_indices = range(len(molecules_in_frame))\n            for i in mol_indices:\n                for j in mol_indices:\n                    if i == j:\n                        continue\n                    \n                    donor_mol = molecules_in_frame[i]\n                    acceptor_mol = molecules_in_frame[j]\n\n                    r_D = np.array(donor_mol['O'])\n                    r_A = np.array(acceptor_mol['O'])\n                    \n                    hydrogens = [np.array(donor_mol['H1']), np.array(donor_mol['H2'])]\n\n                    for r_H in hydrogens:\n                        # Naive calculation\n                        v_HD_naive = r_D - r_H\n                        v_HA_naive = r_A - r_H\n                        norm_v_HD_naive = np.linalg.norm(v_HD_naive)\n                        norm_v_HA_naive = np.linalg.norm(v_HA_naive)\n\n                        if norm_v_HD_naive > 1e-9 and norm_v_HA_naive > 1e-9:\n                            r_naive = norm_v_HA_naive\n                            cos_theta_naive = np.dot(v_HD_naive, v_HA_naive) / (norm_v_HD_naive * norm_v_HA_naive)\n                            theta_naive = np.degrees(np.arccos(np.clip(cos_theta_naive, -1.0, 1.0)))\n                            pairs_naive.append((r_naive, theta_naive))\n\n                        # MIC calculation\n                        v_HD_mic = apply_mic(r_D - r_H, L)\n                        v_HA_mic = apply_mic(r_A - r_H, L)\n                        norm_v_HD_mic = np.linalg.norm(v_HD_mic)\n                        norm_v_HA_mic = np.linalg.norm(v_HA_mic)\n                        \n                        if norm_v_HD_mic > 1e-9 and norm_v_HA_mic > 1e-9:\n                            r_mic = norm_v_HA_mic\n                            cos_theta_mic = np.dot(v_HD_mic, v_HA_mic) / (norm_v_HD_mic * norm_v_HA_mic)\n                            theta_mic = np.degrees(np.arccos(np.clip(cos_theta_mic, -1.0, 1.0)))\n                            pairs_mic.append((r_mic, theta_mic))\n\n        # Histogramming and Normalization\n        if not pairs_naive and not pairs_mic:\n             return 0.0\n\n        if pairs_naive:\n            r_vals_naive = [p[0] for p in pairs_naive]\n            theta_vals_naive = [p[1] for p in pairs_naive]\n            H_naive, _, _ = np.histogram2d(r_vals_naive, theta_vals_naive, bins=[r_bins, theta_bins])\n        else:\n            H_naive = np.zeros((len(r_bins) - 1, len(theta_bins) - 1))\n        \n        if pairs_mic:\n            r_vals_mic = [p[0] for p in pairs_mic]\n            theta_vals_mic = [p[1] for p in pairs_mic]\n            H_mic, _, _ = np.histogram2d(r_vals_mic, theta_vals_mic, bins=[r_bins, theta_bins])\n        else:\n            H_mic = np.zeros((len(r_bins) - 1, len(theta_bins) - 1))\n\n        N_total_naive = np.sum(H_naive)\n        N_total_mic = np.sum(H_mic)\n\n        g_naive = np.zeros_like(H_naive)\n        if N_total_naive > 0:\n            g_naive = H_naive / (N_total_naive * bin_area)\n        \n        g_mic = np.zeros_like(H_mic)\n        if N_total_mic > 0:\n            g_mic = H_mic / (N_total_mic * bin_area)\n        \n        # Bias calculation\n        if N_total_naive == 0 and N_total_mic == 0:\n            return 0.0\n            \n        rms_diff = np.sqrt(np.mean((g_naive - g_mic)**2))\n        return rms_diff\n\n    results = [calculate_bias_for_case(case) for case in test_cases]\n    \n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3416826"}, {"introduction": "当我们掌握了如何在单个模拟帧中准确识别氢键后，一个更深入的问题便是研究它们的动力学行为，例如氢键能持续存在多久。为了回答这个问题，我们需要计算氢键自相关函数 $C(k)$。本练习不仅将引导你理解并计算这一关键的动力学量，还将挑战你设计一种内存有界的“流式” (streaming) 算法，这对于分析现代分子动力学产生的大规模轨迹数据至关重要 [@problem_id:3416818]。", "problem": "您的任务是为分子动力学（MD）轨迹设计并实现一个流式（在线）氢键检测器，该检测器使用有界内存计算运行估计值，并与完整的离线分析进行验证。该检测器必须处理一系列水分子的笛卡尔坐标，并产生两种统计数据：(i) 每帧氢键数量的时间平均值，表示为 $\\langle n_{\\mathrm{HB}}\\rangle$，以及 (ii) 在离散帧延迟 $k \\in \\{0,1,\\dots,L\\}$ 下的间歇性氢键自相关函数 $C(k)$，其中 $L$ 是一个小的非负整数。\n\n氢键需根据以下几何规则确定，该规则源自简单的向量几何和公认的分子标准：\n\n- 供体是一个水分子的氧原子连同其两个氢原子中的一个。\n- 受体是一个水分子的氧原子。\n- 禁止分子内氢键（供体和受体必须属于不同的水分子）。\n- 当且仅当以下两个条件同时满足时，供体氧原子 $D$ 及其连接的氢原子 $H$ 与受体氧原子 $A$ 之间存在氢键：\n  1. 供体-受体距离至多为一个截断值，即 $| \\mathbf{r}_{A} - \\mathbf{r}_{D} | \\le r_c$。\n  2. 供体-氢-受体角度满足 $\\theta = \\angle D\\text{–}H\\cdots A \\ge \\theta_{\\min}$，其中 $\\theta$ 是向量 $\\mathbf{r}_{D}-\\mathbf{r}_{H}$ 和 $\\mathbf{r}_{A}-\\mathbf{r}_{H}$ 之间的夹角，使用点积定义计算。角度必须以度为单位计算。\n\n在每一帧 $t$，定义一个供体-受体对 $(D,A)$ 的集合 $S(t)$，对于该集合中的每一对，至少有一个与 $D$ 相连的氢原子满足氢键的几何标准。无论有多少个氢原子满足角度标准，每对 $(D,A)$ 在每帧中只计数一次。第 $t$ 帧的氢键总数为 $n_{\\mathrm{HB}}(t) = |S(t)|$。\n\n设 $T$ 为帧数。时间平均值 $\\langle n_{\\mathrm{HB}}\\rangle$ 为样本平均值\n$$\n\\langle n_{\\mathrm{HB}}\\rangle = \\frac{1}{T}\\sum_{t=0}^{T-1} n_{\\mathrm{HB}}(t).\n$$\n定义整数延迟 $k \\in \\{0,\\dots,L\\}$ 的间歇性氢键自相关函数为\n$$\nC(k) = \\frac{\\sum\\limits_{t=0}^{T-1-k} \\sum\\limits_{(D,A)} \\mathbb{1}\\!\\left[(D,A) \\in S(t)\\right] \\, \\mathbb{1}\\!\\left[(D,A) \\in S(t+k)\\right]}{\\sum\\limits_{t=0}^{T-1-k} \\sum\\limits_{(D,A)} \\mathbb{1}\\!\\left[(D,A) \\in S(t)\\right]} \\,,\n$$\n这等价于\n$$\nC(k) = \\frac{\\sum\\limits_{t=0}^{T-1-k} | S(t) \\cap S(t+k) |}{\\sum\\limits_{t=0}^{T-1-k} | S(t) |}.\n$$\n根据定义，当分母非零时，$C(0) = 1$。\n\n您的程序必须同时实现以下两者：\n- 一个流式估计器，它逐帧处理数据，维持不随 $T$ 增长的有界内存（内存大小可能随 $L$ 和最近 $L$ 帧内瞬时氢键对的数量增长），并增量更新 $\\langle n_{\\mathrm{HB}}\\rangle$ 和 $C(k)$（对于 $k \\in \\{0,\\dots,L\\}$），而无需存储整个轨迹。\n- 一个完整的离线分析，它根据所有帧的 $S(t)$ 精确计算 $\\langle n_{\\mathrm{HB}}\\rangle$ 和 $C(k)$。\n\n核心算法要求必须源自以下基本原则：\n- 三维欧几里得距离：对于向量 $\\mathbf{a}$ 和 $\\mathbf{b}$，距离为 $|\\mathbf{a}-\\mathbf{b}| = \\sqrt{(a_x-b_x)^2 + (a_y-b_y)^2 + (a_z-b_z)^2}$。\n- 非零向量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 之间的夹角满足 $\\cos \\theta = \\dfrac{\\mathbf{u}\\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\, \\|\\mathbf{v}\\|}$；使用反余弦函数计算 $\\theta$（以弧度为单位），然后转换为度。\n- 时间平均和自相关应如上所述，使用样本和进行计算。\n\n单位和约定：\n- 所有距离必须以埃（ångström）为单位处理，记为 $\\mathrm{\\AA}$。\n- 所有角度必须以度为单位。\n- 供体和受体是为水分子定义的，每个分子内的原子排序为 $(\\mathrm{O}, \\mathrm{H}, \\mathrm{H})$。每个水分子提供一个带两个氢原子的供体氧和一个受体氧（是同一个氧原子）。\n\n实现三个测试用例。对于每个用例，提供氢键截断值 $r_c$ 和 $\\theta_{\\min}$、延迟上限 $L$ 以及轨迹坐标。您的代码必须使用这些精确值。\n\n所有测试用例的全局参数：\n- 截断距离 $r_c = 3.5\\,\\mathrm{\\AA}$。\n- 角度阈值 $\\theta_{\\min} = 150.0$ 度。\n- 最大延迟 $L = 2$ 帧。\n- 每个原子的坐标均以埃为单位。不应用周期性边界条件。\n\n测试用例 A（正常路径；氢键形成后断裂）：\n- 两个水分子，共 $6$ 帧。\n- 分子 $1$ 的原子：所有帧中 $\\mathrm{O}_1=(0,0,0)$; $\\mathrm{H}_{1a}=(1,0,0)$; $\\mathrm{H}_{1b}=(0,1,0)$。\n- 分子 $2$ 的原子在帧 $t \\in \\{0,1,2\\}$ 中：$\\mathrm{O}_2=(2.8,0,0)$; $\\mathrm{H}_{2a}=(2.8,1,0)$; $\\mathrm{H}_{2b}=(2.8,0,1)$。\n- 分子 $2$ 的原子在帧 $t \\in \\{3,4,5\\}$ 中：$\\mathrm{O}_2=(6.0,0,0)$; $\\mathrm{H}_{2a}=(6.0,1,0)$; $\\mathrm{H}_{2b}=(6.0,0,1)$。\n\n测试用例 B（边界包容性；在两个阈值处均相等）：\n- 两个水分子，共 $4$ 个相同的帧。\n- 分子 $1$ 的原子固定：$\\mathrm{O}_1=(0,0,0)$; $\\mathrm{H}_{1a}=(1,0,0)$; $\\mathrm{H}_{1b}=(0,1,0)$。\n- 分子 $2$ 的氧原子位于 $\\mathrm{O}_2 = \\left(3.25,\\; \\tfrac{1}{4}\\sqrt{27},\\; 0\\right)$，这意味着在 $\\mathrm{H}_{1a}$ 处 $|\\mathrm{O}_2 - \\mathrm{O}_1| = 3.5\\,\\mathrm{\\AA}$ 且 $\\angle \\mathrm{D}\\text{–}\\mathrm{H}\\cdots \\mathrm{A} = 150.0$ 度；氢原子 $\\mathrm{H}_{2a} = \\mathrm{O}_2 + (0,1,0)$ 和 $\\mathrm{H}_{2b} = \\mathrm{O}_2 + (0,0,1)$。\n\n测试用例 C（多对与切换；测试对级相关性）：\n- 三个水分子，共 $4$ 帧。\n- 分子 $1$ 固定：所有帧中 $\\mathrm{O}_1=(0,0,0)$; $\\mathrm{H}_{1a}=(1,0,0)$; $\\mathrm{H}_{1b}=(-1,0,0)$。\n- 分子 $2$ 的氢原子正交设置：所有帧中 $\\mathrm{H}_{2a}=\\mathrm{O}_2 + (0,1,0)$; $\\mathrm{H}_{2b}=\\mathrm{O}_2 + (0,0,1)$。\n- 分子 $3$ 的氢原子正交设置：所有帧中 $\\mathrm{H}_{3a}=\\mathrm{O}_3 + (0,1,0)$; $\\mathrm{H}_{3b}=\\mathrm{O}_3 + (0,0,1)$。\n- 按帧划分的氧原子位置：\n  - 第 $0$ 帧：$\\mathrm{O}_2=(2.9,0,0)$; $\\mathrm{O}_3=(-2.9,0,0)$。\n  - 第 $1$ 帧：$\\mathrm{O}_2=(2.9,0,0)$; $\\mathrm{O}_3=(-6.0,0,0)$。\n  - 第 $2$ 帧：$\\mathrm{O}_2=(6.0,0,0)$; $\\mathrm{O}_3=(-2.9,0,0)$。\n  - 第 $3$ 帧：$\\mathrm{O}_2=(2.9,0,0)$; $\\mathrm{O}_3=(-2.9,0,0)$。\n\n您的实现要求：\n- 每帧的氢键检测必须仅使用指定的几何标准。对于每个供体-受体对 $(D,A)$，如果供体的任何一个氢原子在满足距离标准的同时也满足角度标准，则该对在该帧的 $S(t)$ 中计数一次。\n- 流式算法必须维护：\n  - 收到每一帧后通过增量更新来维持 $\\langle n_{\\mathrm{HB}}\\rangle$ 的运行估计值。\n  - 对于每个延迟 $k \\in \\{0,\\dots,L\\}$，维护运行的分子和分母，以便在接收帧 $t$ 时，仅使用存储的最后 $L$ 个集合 $S(t')$ 来更新时间原点为 $t-k$ 的对的贡献。\n  - 有界内存，最多存储最后 $L$ 个集合 $S(t)$ 和聚合计数器。\n- 离线算法必须计算所有帧的精确 $S(t)$，然后直接使用上述定义计算 $\\langle n_{\\mathrm{HB}}\\rangle$ 和 $C(k)$。\n\n验证目标和输出：\n- 对于每个测试用例，计算流式和离线估计的 $\\langle n_{\\mathrm{HB}}\\rangle$ 之间的绝对差，以及 $C(k)$ 在 $k \\in \\{0,1,2\\}$ 上的最大绝对差。对于每个测试用例，将这两个绝对差中的最大值报告为一个浮点数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_A,x_B,x_C]$），其中 $x_A$、$x_B$ 和 $x_C$ 分别是测试用例 A、B 和 C 的结果。在整个过程中，距离必须以 $\\mathrm{\\AA}$ 解释，角度以度解释。输出的数字应为标准十进制浮点数。\n\n覆盖性设计：\n- 测试用例 A 检验了一般操作，即一个键持续几帧然后消失。\n- 测试用例 B 检验了恰好在 $r_c$ 和 $\\theta_{\\min}$ 处的边界包容性，由于不等式是包含性的，这种情况必须计为成键。\n- 测试用例 C 检验了多个同时存在的键以及不同供体-受体对之间的切换，以此来强调对级相关逻辑的正确性。\n\n您的任务是实现一个完整的、可运行的程序，该程序构建上述轨迹，执行两种分析，并打印所需的单行输出。", "solution": "用户提供的问题是分子动力学（MD）模拟分析领域中一个明确定义的计算任务。它要求实现两种算法——一种离线（批处理）算法和一种在线（流式）算法——以从原子坐标轨迹中计算氢键统计数据。其目标是根据精确的离线计算来验证流式算法。问题陈述在科学上是合理的，在数学上是精确的，在算法上是完整的。因此，提供一个解决方案是必要的。\n\n### 氢键检测原理\n\n氢键是一种非共价相互作用，对许多化学体系（尤其是水）的结构至关重要。该问题指定了一种常见的几何定义，该定义基于供体氧（$D$）、其共价连接的氢（$H$）和受体氧（$A$）的相对位置。当且仅当满足两个条件时，氢键存在：\n1.  供体和受体氧原子之间的距离小于或等于一个截断值，$|\\mathbf{r}_{A} - \\mathbf{r}_{D}| \\le r_c$。\n2.  由供体氧、氢和受体氧形成的夹角大于或等于一个最小阈值，$\\theta = \\angle D\\text{–}H\\cdots A \\ge \\theta_{\\min}$。\n\n这些几何标准是使用三维欧几里得空间中向量代数的基本原理计算的。给定原子的笛卡尔坐标，距离的平方计算为 $(\\mathbf{r}_A - \\mathbf{r}_D) \\cdot (\\mathbf{r}_A - \\mathbf{r}_D)$。角度 $\\theta$ 通过定义夹角两臂的向量 $\\mathbf{u} = \\mathbf{r}_D - \\mathbf{r}_H$ 和 $\\mathbf{v} = \\mathbf{r}_A - \\mathbf{r}_H$ 的点积导出，关系如下：\n$$\n\\cos \\theta = \\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\|\\mathbf{v}\\|}\n$$\n然后通过取反余弦并将弧度转换为度来找到角度 $\\theta$。对于每一帧 $t$，我们识别出形成至少一个氢键的所有唯一供体-受体分子对 $(D, A)$ 的集合 $S(t)$。该帧中的氢键数量即为 $n_{\\mathrm{HB}}(t) = |S(t)|$。\n\n### 统计分析：离线与在线算法\n\n该问题要求计算两个关键的统计量：氢键数量的时间平均值 $\\langle n_{\\mathrm{HB}}\\rangle$ 和间歇性氢键自相关函数 $C(k)$。\n\n**1. 离线（批处理）算法**\n\n离线算法代表了一种标准的双遍分析法。\n-   **第一遍**：遍历从 $0$ 到 $T-1$ 的所有帧 $t$。对于每一帧，将几何标准应用于所有可能的供体-受体对，以计算成键对的集合 $S(t)$。将所有这些集合存储在内存中，例如，存储在一个列表 `[S(0), S(1), ..., S(T-1)]` 中。\n-   **第二遍**：在所有 $S(t)$ 都可用的情况下，直接根据其定义计算最终的统计数据：\n    -   氢键的平均数量为 $\\langle n_{\\mathrm{HB}}\\rangle = \\frac{1}{T}\\sum_{t=0}^{T-1} |S(t)|$。\n    -   对于每个延迟 $k \\in \\{0, \\dots, L\\}$ 的自相关函数为 $C(k) = \\frac{\\sum_{t=0}^{T-1-k} | S(t) \\cap S(t+k) |}{\\sum_{t=0}^{T-1-k} | S(t) |}$。这涉及遍历每个延迟 $k$ 的适当时间窗口，并使用预先计算的集合 $S(t)$。\n\n这种方法简单直接，但内存消耗大，因为它需要存储整个轨迹的信息。\n\n**2. 在线（流式）算法**\n\n在线算法逐帧处理轨迹，并使用不随总帧数 $T$ 扩展的有界内存来增量更新统计数据。\n\n-   **内存**：该算法为统计数据维护运行总和，并使用一个小型缓冲区来存储最近 $L+1$ 帧的氢键集合。循环缓冲区是完成此任务的高效数据结构。\n-   **处理帧 $t$**：在接收到第 $t$ 帧的坐标后：\n    1.  计算当前氢键集合 $S(t)$ 及其大小 $n_{\\mathrm{HB}}(t)$。\n    2.  更新平均值的运行总和：一个运行总计 $\\Sigma_n$ 增加 $n_{\\mathrm{HB}}(t)$。在第 $t$ 帧时的平均值为 $\\frac{\\Sigma_n}{t+1}$。\n    3.  将 $S(t)$ 存储在循环缓冲区中，覆盖掉来自第 $t-(L+1)$ 帧的数据。\n    4.  更新 $C(k)$ 的运行总和。对于每个延迟 $k \\in \\{0, \\dots, L\\}$，如果 $t \\ge k$，则帧对 $(t-k, t)$ 对相关性有贡献。我们从缓冲区中检索历史集合 $S(t-k)$，并计算它与 $S(t)$ 的交集。\n        -   $C(k)$ 的分子总和增加 $|S(t-k) \\cap S(t)|$。\n        -   $C(k)$ 的分母总和增加 $|S(t-k)|$。\n\n处理完所有帧后，通过将累积的总和相除来计算最终的统计数据。这种在线方法在数学上与离线方法等效，并且除非存在浮点精度问题，否则将产生相同的结果。问题要求计算两者之间的差异，这为验证流式实现方案的正确性提供了一种可靠的方法。\n\n### 实现与验证\n\n提供的解决方案将实现这两种算法。一个核心函数执行每帧的氢键检测。离线和流式函数将调用此核心函数，但如上所述，会以不同方式管理数据和计算。测试用例旨在检验各种场景：简单的键形成/解离事件（A）、几何标准的边界条件（B）以及多个竞争性成键伙伴（C）。最终输出报告了两种方法结果之间的最大绝对差，预期结果将是一个零数组，从而证实了在线算法设计和实现的正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\n# Global parameters from the problem statement\nR_C = 3.5  # Angstrom\nTHETA_MIN = 150.0  # degrees\nL_MAX = 2\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run analyses, and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A\n        {\n            \"num_molecules\": 2,\n            \"num_frames\": 6,\n            \"get_coords\": lambda t: np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],\n                [[2.8, 0.0, 0.0], [2.8, 1.0, 0.0], [2.8, 0.0, 1.0]]\n            ]) if t  3 else np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],\n                [[6.0, 0.0, 0.0], [6.0, 1.0, 0.0], [6.0, 0.0, 1.0]]\n            ])\n        },\n        # Test Case B\n        {\n            \"num_molecules\": 2,\n            \"num_frames\": 4,\n            \"get_coords\": lambda t: np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]],\n                [\n                    [3.25, np.sqrt(27)/4.0, 0.0],\n                    [3.25, np.sqrt(27)/4.0 + 1.0, 0.0],\n                    [3.25, np.sqrt(27)/4.0, 1.0]\n                ]\n            ])\n        },\n        # Test Case C\n        {\n            \"num_molecules\": 3,\n            \"num_frames\": 4,\n            \"get_coords\": lambda t: np.array([\n                [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [-1.0, 0.0, 0.0]],\n                *({\n                    0: [[[2.9,0,0],[2.9,1,0],[2.9,0,1]],[[-2.9,0,0],[-2.9,1,0],[-2.9,0,1]]],\n                    1: [[[2.9,0,0],[2.9,1,0],[2.9,0,1]],[[-6.0,0,0],[-6.0,1,0],[-6.0,0,1]]],\n                    2: [[[6.0,0,0],[6.0,1,0],[6.0,0,1]],[[-2.9,0,0],[-2.9,1,0],[-2.9,0,1]]],\n                    3: [[[2.9,0,0],[2.9,1,0],[2.9,0,1]],[[-2.9,0,0],[-2.9,1,0],[-2.9,0,1]]]\n                }[t])\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        trajectory = [case[\"get_coords\"](t) for t in range(case[\"num_frames\"])]\n        \n        n_hb_offline, c_k_offline = offline_analyzer(trajectory, case[\"num_molecules\"])\n        n_hb_streaming, c_k_streaming = streaming_analyzer(trajectory, case[\"num_molecules\"])\n        \n        diff_n_hb = abs(n_hb_offline - n_hb_streaming)\n        diff_c_k = np.max(np.abs(np.array(c_k_offline) - np.array(c_k_streaming)))\n        \n        results.append(max(diff_n_hb, diff_c_k))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef detect_hbonds_frame(coords, num_molecules):\n    \"\"\"\n    Detects hydrogen bonds in a single frame based on geometric criteria.\n    - coords: (num_molecules, 3 atoms, 3 coords) numpy array\n    Returns a set of (donor_idx, acceptor_idx) tuples.\n    \"\"\"\n    hbond_pairs = set()\n    for d_idx in range(num_molecules):\n        for a_idx in range(num_molecules):\n            if d_idx == a_idx:\n                continue\n\n            r_d = coords[d_idx, 0]\n            r_a = coords[a_idx, 0]\n\n            dist_vec = r_a - r_d\n            dist_sq = np.dot(dist_vec, dist_vec)\n            if dist_sq > R_C**2:\n                continue\n            \n            # Distance criterion met, check angles\n            is_h_bonded = False\n            for h_idx in [1, 2]: # H1 and H2\n                r_h = coords[d_idx, h_idx]\n                \n                vec_dh = r_d - r_h\n                vec_ah = r_a - r_h\n\n                norm_dh = np.linalg.norm(vec_dh)\n                norm_ah = np.linalg.norm(vec_ah)\n\n                if norm_dh == 0 or norm_ah == 0:\n                    continue\n\n                cos_theta = np.dot(vec_dh, vec_ah) / (norm_dh * norm_ah)\n                # Clamp cos_theta to handle potential floating point inaccuracies\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                \n                theta_rad = np.arccos(cos_theta)\n                theta_deg = np.rad2deg(theta_rad)\n\n                if theta_deg >= THETA_MIN:\n                    is_h_bonded = True\n                    break # Pair is counted once\n\n            if is_h_bonded:\n                hbond_pairs.add((d_idx, a_idx))\n    \n    return hbond_pairs\n\ndef offline_analyzer(trajectory, num_molecules):\n    \"\"\"\n    Computes H-bond statistics by processing the entire trajectory in batch.\n    \"\"\"\n    num_frames = len(trajectory)\n    if num_frames == 0:\n        return 0.0, [1.0] + [0.0] * L_MAX\n\n    all_s_t = [detect_hbonds_frame(coords, num_molecules) for coords in trajectory]\n    n_hb_list = [len(s) for s in all_s_t]\n\n    # Calculate avg(n_HB)\n    avg_n_hb = np.mean(n_hb_list) if n_hb_list else 0.0\n\n    # Calculate C(k)\n    c_k = []\n    for k in range(L_MAX + 1):\n        if num_frames = k:\n            c_k.append(0.0) # Not enough frames for this lag\n            continue\n        \n        numerator = 0.0\n        denominator = 0.0\n        for t in range(num_frames - k):\n            numerator += len(all_s_t[t].intersection(all_s_t[t+k]))\n            denominator += len(all_s_t[t])\n        \n        c_k.append(numerator / denominator if denominator > 0 else (1.0 if k == 0 else 0.0))\n\n    return avg_n_hb, c_k\n\ndef streaming_analyzer(trajectory, num_molecules):\n    \"\"\"\n    Computes H-bond statistics by processing the trajectory frame by frame.\n    \"\"\"\n    num_frames = len(trajectory)\n    if num_frames == 0:\n        return 0.0, [1.0] + [0.0] * L_MAX\n\n    sum_n_hb = 0.0\n    \n    c_k_numerators = np.zeros(L_MAX + 1)\n    c_k_denominators = np.zeros(L_MAX + 1)\n    \n    s_buffer = collections.deque(maxlen=L_MAX + 1)\n\n    for t in range(num_frames):\n        coords = trajectory[t]\n        current_s = detect_hbonds_frame(coords, num_molecules)\n        current_n_hb = len(current_s)\n        \n        # Update mean n_HB\n        sum_n_hb += current_n_hb\n        \n        s_buffer.append(current_s)\n        \n        # Update C(k)\n        for k in range(L_MAX + 1):\n            if t >= k:\n                # The pair of frames is (t-k, t)\n                # s_buffer[len-1] is current_s, s_buffer[len-1-k] is S(t-k)\n                past_s = s_buffer[len(s_buffer) - 1 - k]\n                c_k_numerators[k] += len(past_s.intersection(current_s))\n                c_k_denominators[k] += len(past_s)\n\n    avg_n_hb = sum_n_hb / num_frames if num_frames > 0 else 0.0\n    \n    c_k = []\n    for k in range(L_MAX + 1):\n        if c_k_denominators[k] > 0:\n            c_k.append(c_k_numerators[k] / c_k_denominators[k])\n        else:\n            # Handle cases with no bonds, C(0) should be 1 if any frame with bonds exists,\n            # but if no bonds ever, denominator will be 0.\n            c_k.append(1.0 if k == 0 and sum_n_hb > 0 else 0.0)\n            if k == 0 and sum_n_hb == 0: c_k[-1] = 1.0 # C(0) is 1 by convention if frames exist.\n            if num_frames = k: c_k[-1] = 0.0 # Match offline behavior if trajectory is too short\n    \n    # Special case, C(0) is 1 if there's at least one frame.\n    if num_frames > 0:\n        sum_of_hb_counts = c_k_denominators[0]\n        c_k[0] = 1.0 if sum_of_hb_counts > 0 else (1.0 if num_frames > 0 else 0.0)\n\n    # If num_frames is small, some lags may not be computable\n    for k in range(L_MAX + 1):\n        if num_frames = k:\n            c_k[k] = 0.0\n\n    return avg_n_hb, c_k\n\n\n# Execute the solution\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3416818"}]}