{"hands_on_practices": [{"introduction": "在分子动力学模拟中，Verlet列表的更新频率是一个关键的性能参数。本练习将理论与实践相结合，要求您从统计力学的基本原理出发，推导非均匀温度场中邻居列表寿命的概率分布。通过将粒子速度的麦克斯韦分布与弹道运动模型联系起来，您将学会如何定量预测和识别那些因局部高温而需要更频繁更新的区域，从而为开发自适应更新策略奠定坚实的基础。[@problem_id:3460172]", "problem": "您的任务是推导、实现和应用一种有原则的估计量，以确定分子动力学中非均匀温度场下的 Verlet 邻居列表寿命。您需要基于基本的力学和统计学原理，且不得做出任何超出所述范围的假设。\n\n考虑一个由质量为 $m$ 的相同粒子组成的系统，其在牛顿动力学下演化。在系统于温度 $T(\\mathbf{r})$ 下局部平衡的区域，假设瞬时速度分量是独立的，服从均值为 0、方差为 $\\sigma^{2} = k_{\\mathrm{B}} T(\\mathbf{r}) / m$ 的正态分布，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。因此，粒子速率 $v$ 服从三维经典麦克斯韦速率分布。Verlet 邻居列表的构建使用了一个径向截断半径 $r_{\\mathrm{c}}$ 和一个额外的缓冲层（皮层）厚度 $s  0$。一种广泛使用的保守更新策略是，当任何粒子自上次构建以来的位移超过阈值 $\\Delta$ 时，就重建邻居列表，其中一个常见的选择是 $\\Delta = s/2$。假设在两次列表构建之间，与短时间窗口内的位移相关的运动是弹道式的，因此在时间 $t$ 内的位移大小可近似为 $d(t) = v t$。\n\n您的任务如下：\n\n1. 在温度为 $T(\\mathbf{r})$ 的区域中，推导邻居列表寿命 $t$ 的概率密度函数，其定义为位移首次超过阈值 $\\Delta  0$ 的随机时间，此过程在弹道近似 $t = \\Delta / v$ 下进行，其中 $v$ 根据局部麦克斯韦速率分布进行分布。从该分布中，推导均值 $\\mathbb{E}[t]$ 和方差 $\\mathrm{Var}(t)$ 的表达式，用 $m$、$k_{\\mathrm{B}}$、$T(\\mathbf{r})$ 和 $\\Delta$ 表示。\n\n2. 设 $t_{\\mathrm{thr}}  0$ 为一个提前重建的阈值时间。在相同的局部平衡和弹道假设下，推导在时间 $t_{\\mathrm{thr}}$ 之前，一个区域需要提前重建的局部概率 $P_{\\mathrm{early}}(\\mathbf{r})$。您的表达式必须用麦克斯韦速率累积分布函数和给定参数来表示。\n\n3. 实现一个程序，对于每个提供的温度场实例，计算：\n   - 空间区域索引的列表（从 0 开始，按行主序展开），其中 $P_{\\mathrm{early}}(\\mathbf{r})$ 严格超过给定的概率截断值 $p_{\\mathrm{cut}}$。\n   - 整个场上邻居列表寿命的全局均值，定义为场中所有区域的局部 $\\mathbb{E}[t]$ 值的算术平均值。\n   - 整个场上邻居列表寿命的全局方差，定义为场中所有区域的局部 $\\mathrm{Var}(t)$ 值的算术平均值。\n\n假设每个场被指定为具有给定温度的有限网格。麦克斯韦速率分布必须使用相应区域的温度在局部应用。使用 $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}$ 焦耳/开尔文。所有时间以秒为单位，概率以小数形式表示。不涉及角度。\n\n测试套件：\n\n提供一个程序来评估以下三种情况。在所有情况下，均使用 $\\Delta = s/2$。\n\n- 情况 A（正常路径，二维非均匀场）：\n  - 质量 $m = 6.63 \\times 10^{-26}$ 千克。\n  - 皮层厚度 $s = 0.6 \\times 10^{-9}$ 米，因此 $\\Delta = 0.3 \\times 10^{-9}$ 米。\n  - 提前重建阈值 $t_{\\mathrm{thr}} = 1.0 \\times 10^{-12}$ 秒。\n  - 概率截断值 $p_{\\mathrm{cut}} = 0.6$。\n  - 场形状为 $3 \\times 3$，温度（单位：开尔文）由矩阵给出\n    $$\n    \\begin{bmatrix}\n    200  300  200 \\\\\n    300  600  300 \\\\\n    200  300  200\n    \\end{bmatrix}.\n    $$\n  - 展开顺序为行主序：索引从 0 到 8。\n\n- 情况 B（边界覆盖：一维梯度，较大质量）：\n  - 质量 $m = 1.0 \\times 10^{-25}$ 千克。\n  - 皮层厚度 $s = 0.4 \\times 10^{-9}$ 米，因此 $\\Delta = 0.2 \\times 10^{-9}$ 米。\n  - 提前重建阈值 $t_{\\mathrm{thr}} = 0.8 \\times 10^{-12}$ 秒。\n  - 概率截断值 $p_{\\mathrm{cut}} = 0.5$。\n  - 场形状为 $1 \\times 5$，温度（单位：开尔文）由以下给出\n    $$\n    [150, 200, 250, 300, 350].\n    $$\n  - 展开顺序产生的索引为 0 到 4。\n\n- 情况 C（边缘情况：极小皮层，强非均匀场）：\n  - 质量 $m = 6.63 \\times 10^{-26}$ 千克。\n  - 皮层厚度 $s = 0.1 \\times 10^{-9}$ 米，因此 $\\Delta = 0.05 \\times 10^{-9}$ 米。\n  - 提前重建阈值 $t_{\\mathrm{thr}} = 0.5 \\times 10^{-12}$ 秒。\n  - 概率截断值 $p_{\\mathrm{cut}} = 0.3$。\n  - 场形状为 $2 \\times 2$，温度（单位：开尔文）由矩阵给出\n    $$\n    \\begin{bmatrix}\n    400  400 \\\\\n    700  100\n    \\end{bmatrix}.\n    $$\n  - 展开顺序产生的索引为 0 到 3。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果必须是 $[\\text{高风险区域索引}, \\text{全局平均寿命（秒）}, \\text{全局方差（秒}^2）]$ 形式的列表，其中 $\\text{高风险区域索引}$ 本身是一个整数列表。例如，总输出应如下所示：\n$[[[i\\_1,i\\_2,\\dots],m\\_A,v\\_A],[[j\\_1,j\\_2,\\dots],m\\_B,v\\_B],[[k\\_1,k\\_2,\\dots],m\\_C,v\\_C]]$\n其中所有时间以秒为单位，方差以 $\\text{秒}^2$ 为单位。", "solution": "该问题是有效的，因为它具有科学依据、自成体系、提法明确且客观。它提出了一个基于统计力学和分子动力学基本原理的可解物理问题。我们着手进行推导和实现。\n\n按照要求，分析分为三个部分：寿命分布及其矩的推导，提前重建概率的推导，以及针对给定测试用例的计算实现。\n\n### 1. 寿命分布及其矩的推导\n\n我们从三维粒子速率 $v$ 的概率密度函数（PDF），即麦克斯韦速率分布开始，该分布对于在温度 $T(\\mathbf{r})$ 下处于局部热平衡的系统是有效的：\n$$ f_V(v) = \\sqrt{\\frac{2}{\\pi}} \\left(\\frac{m}{k_{\\mathrm{B}}T}\\right)^{3/2} v^2 \\exp\\left(-\\frac{mv^2}{2k_{\\mathrm{B}}T}\\right) \\quad \\text{for } v \\ge 0 $$\n其中 $m$ 是粒子质量，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。为方便起见，我们定义一个参数 $a = \\sqrt{k_{\\mathrm{B}}T/m}$，它代表最概然速率（相差一个常数因子）。于是，PDF可以写成：\n$$ f_V(v) = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} v^2 \\exp\\left(-\\frac{v^2}{2a^2}\\right) $$\n问题将邻居列表寿命 $t$ 定义为在弹道近似 $d(t) = vt$ 下，速率为 $v$ 的粒子行进距离 $\\Delta = s/2$ 所需的时间。因此，寿命 $t$ 是一个与速率 $v$ 通过以下变换相关的随机变量：\n$$ t = \\frac{\\Delta}{v} \\implies v = \\frac{\\Delta}{t} $$\n由于 $v \\ge 0$ 且 $\\Delta  0$，因此 $t$ 的定义域为 $t  0$。我们可以使用概率分布的变量替换公式来求出 $t$ 的 PDF，记为 $g_T(t)$：\n$$ g_T(t) = f_V(v(t)) \\left| \\frac{dv}{dt} \\right| $$\n变换的雅可比行列式为 $\\left| \\frac{d}{dt}\\left(\\frac{\\Delta}{t}\\right) \\right| = \\left| -\\frac{\\Delta}{t^2} \\right| = \\frac{\\Delta}{t^2}$。\n将 $v = \\Delta/t$ 和雅可比行列式代入 $g_T(t)$ 的公式中：\n$$ g_T(t) = \\left( \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} \\left(\\frac{\\Delta}{t}\\right)^2 \\exp\\left(-\\frac{(\\Delta/t)^2}{2a^2}\\right) \\right) \\cdot \\frac{\\Delta}{t^2} $$\n$$ g_T(t) = \\sqrt{\\frac{2}{\\pi}} \\frac{\\Delta^3}{a^3} \\frac{1}{t^4} \\exp\\left(-\\frac{\\Delta^2}{2a^2t^2}\\right) \\quad \\text{for } t  0 $$\n这就是邻居列表寿命 $t$ 的 PDF。\n\n**平均寿命 $\\mathbb{E}[t]$**\n\n平均寿命 $\\mathbb{E}[t]$ 可以通过随机变量 $V$ 的变换来计算：\n$$ \\mathbb{E}[t] = \\mathbb{E}\\left[\\frac{\\Delta}{v}\\right] = \\Delta \\, \\mathbb{E}\\left[\\frac{1}{v}\\right] $$\n我们计算 $1/v$ 的期望值：\n$$ \\mathbb{E}\\left[\\frac{1}{v}\\right] = \\int_0^\\infty \\frac{1}{v} f_V(v) dv = \\int_0^\\infty \\frac{1}{v} \\left( \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} v^2 \\exp\\left(-\\frac{v^2}{2a^2}\\right) \\right) dv $$\n$$ = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} \\int_0^\\infty v \\exp\\left(-\\frac{v^2}{2a^2}\\right) dv $$\n令 $u = v^2/(2a^2)$，则 $du = (v/a^2) dv$。积分变为：\n$$ \\int_0^\\infty v \\exp\\left(-\\frac{v^2}{2a^2}\\right) dv = a^2 \\int_0^\\infty e^{-u} du = a^2 [-e^{-u}]_0^\\infty = a^2(0 - (-1)) = a^2 $$\n将此结果代回：\n$$ \\mathbb{E}\\left[\\frac{1}{v}\\right] = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} (a^2) = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a} $$\n因此，平均寿命为：\n$$ \\mathbb{E}[t] = \\Delta \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a} = \\Delta \\sqrt{\\frac{2m}{\\pi k_{\\mathrm{B}}T}} $$\n\n**寿命方差 $\\mathrm{Var}(t)$**\n\n方差由 $\\mathrm{Var}(t) = \\mathbb{E}[t^2] - (\\mathbb{E}[t])^2$ 给出。首先，我们求 $\\mathbb{E}[t^2]$：\n$$ \\mathbb{E}[t^2] = \\mathbb{E}\\left[\\left(\\frac{\\Delta}{v}\\right)^2\\right] = \\Delta^2 \\, \\mathbb{E}\\left[\\frac{1}{v^2}\\right] $$\n我们计算 $1/v^2$ 的期望值：\n$$ \\mathbb{E}\\left[\\frac{1}{v^2}\\right] = \\int_0^\\infty \\frac{1}{v^2} f_V(v) dv = \\int_0^\\infty \\frac{1}{v^2} \\left( \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} v^2 \\exp\\left(-\\frac{v^2}{2a^2}\\right) \\right) dv $$\n$$ = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} \\int_0^\\infty \\exp\\left(-\\frac{v^2}{2a^2}\\right) dv $$\n这是一个标准高斯积分的一半，$\\int_0^\\infty \\exp(-x^2/(2\\sigma^2))dx = \\frac{1}{2}\\sqrt{2\\pi\\sigma^2}$。此处 $\\sigma=a$。\n$$ \\int_0^\\infty \\exp\\left(-\\frac{v^2}{2a^2}\\right) dv = \\frac{1}{2} \\sqrt{2\\pi a^2} = a\\sqrt{\\frac{\\pi}{2}} $$\n代入这个结果：\n$$ \\mathbb{E}\\left[\\frac{1}{v^2}\\right] = \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a^3} \\left( a\\sqrt{\\frac{\\pi}{2}} \\right) = \\frac{1}{a^2} $$\n所以，$t$ 的二阶矩是：\n$$ \\mathbb{E}[t^2] = \\Delta^2 \\frac{1}{a^2} = \\frac{\\Delta^2 m}{k_{\\mathrm{B}}T} $$\n最后，我们可以求出方差：\n$$ \\mathrm{Var}(t) = \\mathbb{E}[t^2] - (\\mathbb{E}[t])^2 = \\frac{\\Delta^2}{a^2} - \\left(\\Delta \\sqrt{\\frac{2}{\\pi}} \\frac{1}{a}\\right)^2 = \\frac{\\Delta^2}{a^2} - \\frac{2\\Delta^2}{\\pi a^2} $$\n$$ \\mathrm{Var}(t) = \\frac{\\Delta^2}{a^2} \\left(1 - \\frac{2}{\\pi}\\right) = \\frac{\\Delta^2 m}{k_{\\mathrm{B}}T} \\left(1 - \\frac{2}{\\pi}\\right) $$\n\n### 2. 提前重建概率的推导\n\n提前重建的局部概率 $P_{\\mathrm{early}}(\\mathbf{r})$ 是寿命 $t$ 小于阈值时间 $t_{\\mathrm{thr}}$ 的概率：\n$$ P_{\\mathrm{early}}(\\mathbf{r}) = P(t  t_{\\mathrm{thr}}) $$\n使用关系式 $t = \\Delta/v$，此条件变为：\n$$ \\frac{\\Delta}{v}  t_{\\mathrm{thr}} \\iff v  \\frac{\\Delta}{t_{\\mathrm{thr}}} $$\n我们定义一个阈值速率 $v_{\\mathrm{thr}} = \\Delta / t_{\\mathrm{thr}}$。那么概率就是 $P(v  v_{\\mathrm{thr}})$。这可以通过将麦克斯韦速率 PDF 从 $v_{\\mathrm{thr}}$ 积分到无穷大来计算，或者更简单地，用 1 减去在 $v_{\\mathrm{thr}}$ 处计算的累积分布函数（CDF）：\n$$ P(v  v_{\\mathrm{thr}}) = 1 - F_V(v_{\\mathrm{thr}}) = 1 - \\int_0^{v_{\\mathrm{thr}}} f_V(v) dv $$\n麦克斯韦速率分布的 CDF，$F_V(v)$，可以用误差函数 $\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}}\\int_0^x e^{-z^2}dz$ 来表示：\n$$ F_V(v) = \\mathrm{erf}\\left(\\frac{v}{\\sqrt{2}a}\\right) - \\sqrt{\\frac{2}{\\pi}}\\frac{v}{a}\\exp\\left(-\\frac{v^2}{2a^2}\\right) $$\n因此，提前重建的概率是：\n$$ P_{\\mathrm{early}}(\\mathbf{r}) = 1 - \\left[ \\mathrm{erf}\\left(\\frac{v_{\\mathrm{thr}}}{\\sqrt{2}a}\\right) - \\sqrt{\\frac{2}{\\pi}}\\frac{v_{\\mathrm{thr}}}{a}\\exp\\left(-\\frac{v_{\\mathrm{thr}}^2}{2a^2}\\right) \\right] $$\n其中 $a=\\sqrt{k_{\\mathrm{B}}T(\\mathbf{r})/m}$ 且 $v_{\\mathrm{thr}} = \\Delta/t_{\\mathrm{thr}}$。该表达式用给定的参数提供了所需的概率。\n\n### 3. 实现与结果\n\n推导出的公式在一个 Python 程序中实现，以评估指定的测试用例。对于温度场中的每个区域，计算 $\\mathbb{E}[t]$、$\\mathrm{Var}(t)$ 和 $P_{\\mathrm{early}}$ 的局部值。然后，程序找出 $P_{\\mathrm{early}}$ 超过 $p_{\\mathrm{cut}}$ 的区域，并按照问题中的定义，将它们各自在场中所有区域的局部值的算术平均值计算为全局平均寿命和全局寿命方差。最终输出的格式为一个列表的列表，其中包含每个案例的高风险区域索引、全局平均寿命和全局寿命方差。", "answer": "```python\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves the Verlet list lifetime problem for the specified test cases.\n    \"\"\"\n    \n    # Define constants\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    test_cases = [\n        # Case A\n        {\n            \"m\": 6.63e-26,  # kg\n            \"s\": 0.6e-9,    # m\n            \"t_thr\": 1.0e-12, # s\n            \"p_cut\": 0.6,\n            \"T_field\": np.array([\n                [200, 300, 200],\n                [300, 600, 300],\n                [200, 300, 200]\n            ])\n        },\n        # Case B\n        {\n            \"m\": 1.0e-25,\n            \"s\": 0.4e-9,\n            \"t_thr\": 0.8e-12,\n            \"p_cut\": 0.5,\n            \"T_field\": np.array([150, 200, 250, 300, 350])\n        },\n        # Case C\n        {\n            \"m\": 6.63e-26,\n            \"s\": 0.1e-9,\n            \"t_thr\": 0.5e-12,\n            \"p_cut\": 0.3,\n            \"T_field\": np.array([\n                [400, 400],\n                [700, 100]\n            ])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        m = case[\"m\"]\n        s = case[\"s\"]\n        t_thr = case[\"t_thr\"]\n        p_cut = case[\"p_cut\"]\n        T_field = case[\"T_field\"]\n        \n        delta = s / 2.0\n        v_thr = delta / t_thr\n        \n        T_flat = T_field.flatten()\n        \n        local_means = []\n        local_vars = []\n        high_risk_indices = []\n        \n        for i, T in enumerate(T_flat):\n            # Parameter 'a' from the Maxwell distribution\n            # a^2 = k_B * T / m\n            a_sq = K_B * T / m\n            a = np.sqrt(a_sq)\n            \n            # --- 1. Local Mean and Variance of Lifetime ---\n            # E[t] = delta * sqrt(2/pi) * (1/a)\n            mean_t = delta * np.sqrt(2.0 / np.pi) / a\n            local_means.append(mean_t)\n            \n            # Var(t) = (delta^2 / a^2) * (1 - 2/pi)\n            var_t = (delta**2 / a_sq) * (1.0 - 2.0 / np.pi)\n            local_vars.append(var_t)\n            \n            # --- 2. Early Rebuild Probability ---\n            # P_early = 1 - CDF(v_thr)\n            # CDF(v) = erf(v / (sqrt(2)*a)) - sqrt(2/pi) * (v/a) * exp(-(v^2)/(2*a^2))\n            arg_erf = v_thr / (np.sqrt(2.0) * a)\n            term_exp = np.sqrt(2.0 / np.pi) * (v_thr / a) * np.exp(-arg_erf**2)\n            \n            cdf_v_thr = erf(arg_erf) - term_exp\n            p_early = 1.0 - cdf_v_thr\n            \n            if p_early  p_cut:\n                high_risk_indices.append(i)\n\n        # --- 3. Global Aggregation ---\n        global_mean_lifetime = np.mean(local_means)\n        global_variance_lifetime = np.mean(local_vars)\n        \n        result_tuple = (high_risk_indices, global_mean_lifetime, global_variance_lifetime)\n        all_results.append(result_tuple)\n\n    # --- Final Output Formatting ---\n    results_str_parts = []\n    for res in all_results:\n        indices_str = f'[{\",\".join(map(str, res[0]))}]'\n        mean_str = f'{res[1]:.7e}' # Use scientific notation for consistency\n        var_str = f'{res[2]:.7e}'\n        results_str_parts.append(f'[{indices_str},{mean_str},{var_str}]')\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n\n```", "id": "3460172"}, {"introduction": "许多先进的分子动力学模拟（如晶体或剪切流研究）采用非正交（三斜）或随时间变形的模拟盒子。本练习旨在解决在这种复杂几何条件下构建Verlet列表的挑战，要求您为三斜晶胞和Lees–Edwards剪切边界条件实现正确的最小镜像约定。您将推导并应用一个严谨的更新条件，该条件同时考虑了粒子的位移和模拟盒子的形变 $\\Delta \\mathbf{H}$，以确保在动态变化的元胞中也能避免“拓扑邻居错误”，这是保证此类模拟准确性的核心要求。[@problem_id:3460089]", "problem": "实现一个程序，该程序在可能是三斜的或正在经历Lees–Edwards剪切的三维周期性模拟盒子中构建Verlet邻居列表，并评估一个保守的邻居列表更新条件以避免拓扑邻居错误。该程序必须在三斜和剪切几何构型中为最小镜像距离应用一致的成像规则，并测试该保守更新条件是否能保证在构建邻居列表时遗漏的任何粒子对，在声明的更新时间之前不会成为相互作用的粒子对。\n\n从以下基本基础和定义开始：\n\n- 牛顿力学通过 $\\mathrm{d}\\mathbf{x}_i/\\mathrm{d}t=\\mathbf{v}_i$ 定义了粒子位置 $\\mathbf{x}_i(t) \\in \\mathbb{R}^3$ 和速度 $\\mathbf{v}_i(t) \\in \\mathbb{R}^3$。在一个力没有被显式积分的短时间间隔内，假设遵循线性运动学 $\\mathbf{x}_i(t)=\\mathbf{x}_i(0)+\\mathbf{v}_i\\,t$。\n\n- 三斜晶胞中的周期性边界条件由一个随时间变化的晶格形变（晶胞）矩阵 $\\mathbf{H}(t) \\in \\mathbb{R}^{3\\times 3}$ 表示，该矩阵通过以下公式将简约（分数）坐标 $\\mathbf{s}_i(t)\\in [0,1)^3$ 映射到笛卡尔坐标：\n$$\n\\mathbf{x}_i(t) = \\mathbf{H}(t)\\,\\mathbf{s}_i(t).\n$$\n在时间 $t$ 时粒子 $i$ 和 $j$ 之间的最小镜像位移为\n$$\n\\mathbf{r}_{ij}(t) = \\mathbf{H}(t)\\,\\big(\\Delta \\mathbf{s}_{ij}(t) - \\mathbf{n}\\big),\n$$\n其中 $\\Delta \\mathbf{s}_{ij}(t)=\\mathbf{s}_j(t)-\\mathbf{s}_i(t)$，$\\mathbf{n}\\in \\mathbb{Z}^3$ 是使欧几里得范数 $\\|\\mathbf{r}_{ij}(t)\\|_2$ 最小化的晶格镜像整数向量。\n\n- Lees–Edwards剪切使用一个随时间变化的剪切应变 $\\gamma(t)$，其中剪切沿 $x$ 方向施加，其大小与 $y$ 坐标成正比。一种一致的晶胞矩阵选择是：\n$$\n\\mathbf{H}(t)=\\begin{bmatrix}\nL_x  \\gamma(t)\\,L_y  0\\\\\n0  L_y  0\\\\\n0  0  L_z\n\\end{bmatrix},\n$$\n其中 $\\gamma(t)=\\gamma_0+\\dot{\\gamma}\\,t$，并且 $L_x$、$L_y$、$L_z$ 是常数。\n\n- 在构建时间 $t_0$ 的Verlet邻居列表包含所有无序对 $(i,j)$，其在 $t_0$ 时的最小镜像距离满足 $\\|\\mathbf{r}_{ij}(t_0)\\|_2 \\le r_c+\\delta$，其中 $r_c$ 是相互作用截断半径，$\\delta0$ 是缓冲层距离。\n\n- 如果在某个 $t_1t_0$ 的时刻，存在一个粒子对 $(i,j)$ 满足 $\\|\\mathbf{r}_{ij}(t_1)\\|_2 \\le r_c$，但该对 $(i,j)$ 未被包含在 $t_0$ 时构建的邻居列表中，则发生拓扑邻居错误。\n\n任务要求：\n\n1) 成像规则。您的程序必须为三斜和剪切晶胞实现一个与上述定义一致的最小镜像规则。为避免在倾斜晶胞中出现歧义，您必须通过检查简约坐标中最近整数中心镜像周围的所有 $\\mathbf{n}\\in\\{-1,0,1\\}^3$，在一个固定的、有限的模板上实现最小化，并选择能够产生最小 $\\|\\mathbf{H}(t)\\,(\\Delta \\mathbf{s}_{ij}(t)-\\mathbf{n})\\|_2$ 的 $\\mathbf{n}$。\n\n2) 保守更新条件。推导并实现一个充分条件，保证在时间 $t_1$ 之前不重建邻居列表就不会发生拓扑邻居错误。仅使用运动学和矩阵范数：\n   - 设 $d_{\\max}(t_1)=\\max_i \\|\\mathbf{x}_i(t_1)-\\mathbf{x}_i(t_0)\\|_2$。\n   - 设 $\\Delta \\mathbf{H}=\\mathbf{H}(t_1)-\\mathbf{H}(t_0)$，并且 $\\|\\cdot\\|_2$ 表示谱范数。\n   - 使用形式为\n$$\n2\\,d_{\\max}(t_1) + C_H(t_0,t_1)  \\delta,\n$$\n   的保守充分条件，其中 $C_H(t_0,t_1)$ 是一个从 $\\|\\Delta \\mathbf{H}\\|_2$ 推导出的界，它安全地考虑了晶胞形变和可能的重新成像。您必须从基本原理出发推导一个有效的 $C_H(t_0,t_1)$ 表达式并加以实现。\n\n3) 验证逻辑。对于给定的 $t_1$，如果保守条件指示不需要更新，您的程序必须通过直接计算来验证没有发生拓扑邻居错误，方法是将 $t_1$ 时 $r_c$ 范围内的邻居集合与在 $t_0$ 构建的邻居列表进行比较。如果条件指示需要更新，那么根据定义不会发生错误，因为您会重建列表；为了布尔结果的目的，将该情况视为成功。\n\n4) 单位。所有量都是无量纲的；报告所有数值输出时，应为不带单位的纯数字。\n\n5) 测试套件。完全按照规定实现以下四个测试用例。在每个用例中，设置 $t_0=0$ 并在列出的 $t_1$ 时进行评估。对于每个用例，在 $t_0$ 时使用截断半径 $r_c+\\delta$ 构建邻居列表，应用保守更新条件来决定在 $t_1$ 之前是否需要更新，如果指示不需要更新，则直接验证在 $t_1$ 时没有发生拓扑邻居错误。\n\n- 测试 A (三斜，静态盒子，近边界分数坐标)：\n  - 晶胞矩阵 $\\mathbf{H}(t)\\equiv \\mathbf{H}_0=\\begin{bmatrix}3.00.80.2\\\\0.02.50.5\\\\0.00.02.0\\end{bmatrix}$。\n  - 粒子数 $N=3$，在 $t_0$ 时的简约坐标为 $\\mathbf{s}_1=(0.49,0.49,0.49)$，$\\mathbf{s}_2=(0.51,0.52,0.48)$，$\\mathbf{s}_3=(0.10,0.10,0.10)$。在 $t_0$ 时的笛卡尔坐标为 $\\mathbf{x}_i(0)=\\mathbf{H}_0\\,\\mathbf{s}_i$。\n  - 所有 $i$ 的速度 $\\mathbf{v}_i=\\mathbf{0}$。\n  - 截断半径 $r_c=1.2$，缓冲层 $\\delta=0.3$，评估时间 $t_1=5.0$。\n\n- 测试 B (Lees–Edwards剪切，小形变，零速度)：\n  - $L_x=5.0$, $L_y=5.0$, $L_z=5.0$, $\\gamma_0=0.0$, $\\dot{\\gamma}=0.02$ 使得 $\\gamma(t)=0.02\\,t$。\n  - 粒子数 $N=3$，在 $t_0$ 时的简约坐标为 $\\mathbf{s}_1=(0.20,0.10,0.10)$，$\\mathbf{s}_2=(0.25,0.12,0.10)$，$\\mathbf{s}_3=(0.80,0.90,0.10)$。在 $t_0$ 时的笛卡尔坐标使用 $\\mathbf{H}(0)$。\n  - 所有 $i$ 的速度 $\\mathbf{v}_i=\\mathbf{0}$。\n  - 截断半径 $r_c=1.0$，缓冲层 $\\delta=0.5$，评估时间 $t_1=2.0$。\n\n- 测试 C (正交，粒子移动以穿过截断半径)：\n  - 晶胞矩阵 $\\mathbf{H}(t)\\equiv \\mathrm{diag}(10.0,10.0,10.0)$。\n  - 粒子数 $N=3$，在 $t_0$ 时的笛卡尔坐标为：$\\mathbf{x}_1(0)=(0.0,0.0,0.0)$，$\\mathbf{x}_2(0)=(1.6,0.0,0.0)$，$\\mathbf{x}_3(0)=(5.0,5.0,5.0)$。\n  - 速度：$\\mathbf{v}_1=(1.0,0.0,0.0)$，$\\mathbf{v}_2=(-1.0,0.0,0.0)$，$\\mathbf{v}_3=(0.0,0.0,0.0)$。\n  - 截断半径 $r_c=1.0$，缓冲层 $\\delta=0.3$，评估时间 $t_1=0.4$。\n\n- 测试 D (Lees–Edwards剪切，较大形变触发更新)：\n  - $L_x=8.0$, $L_y=8.0$, $L_z=8.0$, $\\gamma_0=0.0$, $\\dot{\\gamma}=0.1$ 使得 $\\gamma(t)=0.1\\,t$。\n  - 粒子数 $N=3$，在 $t_0$ 时的简约坐标为：$\\mathbf{s}_1=(0.15,0.15,0.15)$，$\\mathbf{s}_2=(0.35,0.35,0.35)$，$\\mathbf{s}_3=(0.75,0.75,0.25)$。在 $t_0$ 时的笛卡尔坐标使用 $\\mathbf{H}(0)$。\n  - 所有 $i$ 的速度 $\\mathbf{v}_i=\\mathbf{0}$。\n  - 截断半径 $r_c=1.0$，缓冲层 $\\delta=0.4$，评估时间 $t_1=2.0$。\n\n要求输出：\n\n- 对于每个测试用例，输出一个布尔值，指示保守更新策略在指定条件下是否能避免在 $t_1$ 之前发生拓扑邻居错误。解释如下：如果保守条件指示需要更新，则输出布尔值 $\\mathrm{True}$（因为通过构造，更新可以避免错误）；如果指示不需要更新，则仅当在 $t_1$ 时的直接验证确认没有发生拓扑邻居错误时才输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含测试 A、B、C、D 的四个布尔结果，按顺序以逗号分隔的列表形式包含在方括号内，例如 $\\mathrm{[True,False,True,True]}$。", "solution": "该问题要求为在三斜和剪切周期性晶胞中的分子动力学模拟，实现并验证一种保守的邻居列表更新策略。我将首先推导保守更新条件，然后详细说明其实现和针对所提供测试用例进行验证的逐步过程。\n\n### 保守更新条件的推导\n\n在时间 $t_0$ 构建的Verlet邻居列表包含所有满足最小镜像距离 $\\|\\mathbf{r}_{ij}(t_0)\\|_2 \\le r_c + \\delta$ 的粒子对 $(i,j)$，其中 $r_c$ 是相互作用截断半径，$\\delta$ 是缓冲层距离。如果在之后的某个时间 $t_1$，一个不在列表中的粒子对 $(i,j)$（即 $\\|\\mathbf{r}_{ij}(t_0)\\|_2  r_c + \\delta$）被发现其距离满足 $\\|\\mathbf{r}_{ij}(t_1)\\|_2 \\le r_c$，则发生拓扑邻居错误。\n\n为防止这种情况，邻居列表必须在此类事件发生前重建。避免拓扑错误的一个充分条件是，对于任何不在列表中的粒子对 $(i,j)$，其在 $t_1$ 时的距离保持大于 $r_c$。最坏的情况是在 $t_0$ 时，一个粒子对恰好在缓冲区域之外，其距离为 $\\|\\mathbf{r}_{ij}(t_0)\\|_2 = r_c + \\delta$。对于这对粒子，我们必须保证它们之间距离的减少量小于 $\\delta$。\n$$\n\\|\\mathbf{r}_{ij}(t_0)\\|_2 - \\|\\mathbf{r}_{ij}(t_1)\\|_2  \\delta\n$$\n这可以通过限制在 $t_0$ 和 $t_1$ 之间任何粒子对距离的最大可能变化来保证。一个保守的界可以通过将粒子运动和晶胞形变的最坏情况贡献相加来形成。\n\n1. **粒子运动的贡献**：问题假设在笛卡尔空间中为线性运动学，$\\mathbf{x}_i(t) = \\mathbf{x}_i(0) + \\mathbf{v}_i t$。粒子 $i$ 在时间间隔 $[t_0, t_1]$ 内的位移是 $\\Delta \\mathbf{x}_i = \\mathbf{x}_i(t_1) - \\mathbf{x}_i(t_0)$。最大位移是 $d_{\\max}(t_1) = \\max_i \\|\\Delta \\mathbf{x}_i\\|_2$。在固定度量下，由于粒子 $i$ 和 $j$ 的运动导致的距离变化，其上界是它们沿着连接线位移的总和。在最坏情况下，它们直接朝向对方移动，因此它们之间分离距离的最大减少量受 $\\|\\Delta \\mathbf{x}_i\\|_2 + \\|\\Delta \\mathbf{x}_j\\|_2 \\le 2d_{\\max}(t_1)$ 限制。\n\n2. **晶胞形变的贡献**：由晶胞矩阵从 $\\mathbf{H}(t_0)$ 变为 $\\mathbf{H}(t_1)$ 所代表的晶胞形变，改变了空间的度量。最小镜像位移由 $\\mathbf{r}_{ij}(t) = \\mathbf{H}(t) \\mathbf{w}_{ij}(t)$ 给出，其中 $\\mathbf{w}_{ij}(t) = \\mathbf{s}_j(t) - \\mathbf{s}_i(t) - \\mathbf{n}_{ij}(t)$ 是分数坐标中的最小镜像位移。如果我们考虑分数坐标固定的粒子，它们笛卡尔分离向量的变化是 $\\Delta \\mathbf{r}_{ij} = (\\mathbf{H}(t_1) - \\mathbf{H}(t_0))\\mathbf{w}_{ij}(t_0) = \\Delta \\mathbf{H} \\mathbf{w}_{ij}(t_0)$。距离的变化受 $\\|\\Delta\\mathbf{H} \\mathbf{w}_{ij}(t_0)\\|_2 \\le \\|\\Delta\\mathbf{H}\\|_2 \\|\\mathbf{w}_{ij}(t_0)\\|_2$ 限制。\n\n我们必须找到 $\\|\\mathbf{w}_{ij}(t_0)\\|_2$ 的一个界。问题指定了一个成像规则：通过检查最近整数镜像周围 $3 \\times 3 \\times 3$ 模板中的整数向量 $\\mathbf{n}$ 来找到最小镜像。设 $\\Delta \\mathbf{s} = \\mathbf{s}_j - \\mathbf{s}_i$。最近的整数向量是 $\\mathbf{n}_c = \\text{round}(\\Delta\\mathbf{s})$。模板检查向量 $\\mathbf{n} = \\mathbf{n}_c + \\mathbf{d}$，其中 $\\mathbf{d} \\in \\{-1,0,1\\}^3$。分数位移向量为 $\\mathbf{w} = \\Delta\\mathbf{s} - \\mathbf{n} = (\\Delta\\mathbf{s} - \\mathbf{n}_c) - \\mathbf{d}$。根据定义，$\\Delta\\mathbf{s} - \\mathbf{n}_c$ 的每个分量都在 $[-0.5, 0.5]$ 区间内。$\\mathbf{d}$ 的每个分量都在 $\\{-1,0,1\\}$ 中。因此，$\\mathbf{w}$ 的每个分量都受 $[-0.5-1, 0.5+1] = [-1.5, 1.5]$ 限制。因此，范数的平方有界：$\\|\\mathbf{w}\\|_2^2 \\le 1.5^2 + 1.5^2 + 1.5^2 = 3 \\times 2.25 = 6.75$。这给出了最大分数向量的大小为 $S_{\\max} = \\sqrt{6.75} = 1.5\\sqrt{3}$。\n\n因此，由晶胞形变引起的距离变化受 $C_H(t_0, t_1) = \\|\\Delta\\mathbf{H}\\|_2 S_{\\max}$ 限制。该项保守地考虑了空间拉伸和由于晶格形变可能导致的重新成像。\n\n**充分条件**：结合这些效应，距离可能的最大减少量受粒子运动引起的最大变化和晶胞形变引起的最大变化之和的限制。确保不发生拓扑错误的充分条件是：\n$$\n2 d_{\\max}(t_1) + C_H(t_0, t_1)  \\delta\n$$\n其中 $C_H(t_0, t_1) = \\|\\mathbf{H}(t_1) - \\mathbf{H}(t_0)\\|_2 \\times 1.5\\sqrt{3}$。\n\n### 算法实现\n\n每个测试用例的验证过程如下：\n\n1.  **初始化**：定义晶胞矩阵 $\\mathbf{H}(t)$、粒子位置 $\\mathbf{x}_i(0)$、速度 $\\mathbf{v}_i$ 以及参数 $r_c, \\delta, t_1$。对于初始位置以分数坐标 $\\mathbf{s}_i(0)$ 给出的测试用例，计算 $\\mathbf{x}_i(0) = \\mathbf{H}(0)\\mathbf{s}_i(0)$。设置 $t_0=0$。\n\n2.  **最小镜像距离计算**：实现一个函数 `min_img_dist(p1, p2, H)`。给定两个笛卡尔位置向量和一个晶胞矩阵 $\\mathbf{H}$，它通过以下步骤计算最小镜像距离： a. 计算逆晶胞矩阵 $\\mathbf{H}^{-1}$。 b. 找到分数位移 $\\Delta \\mathbf{s} = \\mathbf{H}^{-1}(\\mathbf{p}_2 - \\mathbf{p}_1)$。 c. 找到最近整数中心镜像向量 $\\mathbf{n}_c = \\text{round}(\\Delta\\mathbf{s})$。 d. 遍历 27 个镜像向量 $\\mathbf{n} = \\mathbf{n}_c + \\mathbf{d}$，其中 $\\mathbf{d} \\in \\{-1,0,1\\}^3$。对于每个 $\\mathbf{n}$，计算试验位移向量 $\\mathbf{r} = \\mathbf{H}(\\Delta\\mathbf{s} - \\mathbf{n})$ 的范数平方。 e. 函数返回找到的最小范数平方的平方根。\n\n3.  **在 $t_0$ 构建邻居列表**：构建一个邻居列表 `nlist_t0`。它存储所有满足 `min_img_dist`$(\\mathbf{x}_i(0), \\mathbf{x}_j(0), \\mathbf{H}(0)) \\le r_c + \\delta$ 的无序对 $(i,j)$。\n\n4.  **评估更新条件**： a. 计算最终位置 $\\mathbf{x}_i(t_1) = \\mathbf{x}_i(0) + \\mathbf{v}_i t_1$。 b. 计算 $d_{\\max}(t_1) = t_1 \\max_i \\|\\mathbf{v}_i\\|_2$。 c. 计算最终晶胞矩阵 $\\mathbf{H}(t_1)$ 和变化量 $\\Delta\\mathbf{H} = \\mathbf{H}(t_1) - \\mathbf{H}(0)$。 d. 计算谱范数 $\\|\\Delta\\mathbf{H}\\|_2$。 e. 评估条件 $2 d_{\\max}(t_1) + \\|\\Delta\\mathbf{H}\\|_2 \\times 1.5\\sqrt{3}  \\delta$。如果不等式为假，则认为需要更新（`needs_update = True`）。\n\n5.  **最终验证和输出**： a. 如果 `needs_update` 为 `True`，根据定义，该策略是成功的（更新会防止错误）。该测试用例的结果为 `True`。 b. 如果 `needs_update` 为 `False`，则执行直接检查。遍历所有*不*在 `nlist_t0` 中的粒子对 $(i,j)$。对于每个这样的对，计算它们在 $t_1$ 时的距离 $d_{ij}(t_1) = \\text{min_img_dist}(\\mathbf{x}_i(t_1), \\mathbf{x}_j(t_1), \\mathbf{H}(t_1))$。如果任何这样的对满足 $d_{ij}(t_1) \\le r_c$，则发生了拓扑错误。如果没有发现此类错误，则结果为 `True`，否则为 `False`。\n\n将此完整过程应用于问题中指定的四个测试用例中的每一个。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Verlet list update strategy.\n    \n    The program implements and validates a conservative neighbor-list update condition\n    for molecular dynamics simulations in triclinic and shearing periodic cells.\n    \"\"\"\n\n    def get_h_matrix(case, t):\n        \"\"\"Computes the cell matrix H at a given time t for a test case.\"\"\"\n        if case['type'] == 'triclinic':\n            return case['H0']\n        elif case['type'] == 'orthorhombic':\n            return case['H0']\n        elif case['type'] == 'lees_edwards':\n            L_x, L_y, L_z = case['L']\n            gamma = case['gamma0'] + case['gamma_dot'] * t\n            return np.array([\n                [L_x, gamma * L_y, 0.0],\n                [0.0, L_y, 0.0],\n                [0.0, 0.0, L_z]\n            ])\n        return None\n\n    def min_img_dist(p1, p2, H):\n        \"\"\"\n        Calculates the minimal-image distance between two particles in a triclinic cell.\n        Uses the specified 27-image stencil check method.\n        \n        Args:\n            p1 (np.ndarray): Cartesian position of particle 1.\n            p2 (np.ndarray): Cartesian position of particle 2.\n            H (np.ndarray): 3x3 cell matrix.\n            \n        Returns:\n            float: The minimal-image distance.\n        \"\"\"\n        try:\n            H_inv = np.linalg.inv(H)\n        except np.linalg.LinAlgError:\n            return np.inf\n\n        # Fractional displacement vector\n        ds = H_inv @ (p2 - p1)\n        \n        # Central image integer vector\n        n_c = np.round(ds)\n        \n        min_dist_sq = np.inf\n        \n        # Iterate over the 3x3x3=27 images in the stencil around the central image\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                for k in range(-1, 2):\n                    d = np.array([i, j, k])\n                    n = n_c + d\n                    # Cartesian displacement vector for this image\n                    r_vec = H @ (ds - n)\n                    dist_sq = r_vec.dot(r_vec)\n                    if dist_sq  min_dist_sq:\n                        min_dist_sq = dist_sq\n                        \n        return np.sqrt(min_dist_sq)\n\n    def run_test(case):\n        \"\"\"Runs a single test case and returns the boolean result.\"\"\"\n        t0 = 0.0\n        t1 = case['t1']\n        rc = case['rc']\n        delta = case['delta']\n        \n        # 1. Initialization\n        H0 = get_h_matrix(case, t0)\n        \n        if 's0' in case:\n            x0 = np.array([H0 @ s for s in case['s0']])\n        else:\n            x0 = case['x0']\n        \n        v = case['v']\n        num_particles = len(x0)\n        \n        # 2. Build neighbor list at t0\n        nlist_t0 = set()\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                dist_t0 = min_img_dist(x0[i], x0[j], H0)\n                if dist_t0 = rc + delta:\n                    nlist_t0.add(tuple(sorted((i, j))))\n\n        # 3. Check conservative update condition\n        # Kinematics\n        x1 = x0 + v * t1\n        H1 = get_h_matrix(case, t1)\n        \n        # Max particle displacement\n        if v.shape[0]  0:\n            d_max = t1 * np.max(np.linalg.norm(v, axis=1))\n        else:\n            d_max = 0.0\n            \n        # Box deformation term\n        delta_H = H1 - H0\n        norm_delta_H = np.linalg.norm(delta_H, 2)\n        S_max = 1.5 * np.sqrt(3.0)\n        C_H = norm_delta_H * S_max\n        \n        # Evaluate condition\n        needs_update = (2 * d_max + C_H = delta)\n        \n        if needs_update:\n            return True\n            \n        # 4. If no update needed, perform direct verification\n        topological_error_found = False\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                if tuple(sorted((i, j))) not in nlist_t0:\n                    dist_t1 = min_img_dist(x1[i], x1[j], H1)\n                    if dist_t1 = rc:\n                        topological_error_found = True\n                        break\n            if topological_error_found:\n                break\n                \n        return not topological_error_found\n\n    test_cases = [\n        # Test A: Triclinic, static, near-boundary\n        {\n            'type': 'triclinic',\n            'H0': np.array([[3.0, 0.8, 0.2], [0.0, 2.5, 0.5], [0.0, 0.0, 2.0]]),\n            's0': np.array([[0.49, 0.49, 0.49], [0.51, 0.52, 0.48], [0.10, 0.10, 0.10]]),\n            'v': np.zeros((3, 3)),\n            'rc': 1.2, 'delta': 0.3, 't1': 5.0\n        },\n        # Test B: Lees-Edwards, small deformation\n        {\n            'type': 'lees_edwards',\n            'L': (5.0, 5.0, 5.0), 'gamma0': 0.0, 'gamma_dot': 0.02,\n            's0': np.array([[0.20, 0.10, 0.10], [0.25, 0.12, 0.10], [0.80, 0.90, 0.10]]),\n            'v': np.zeros((3, 3)),\n            'rc': 1.0, 'delta': 0.5, 't1': 2.0\n        },\n        # Test C: Orthorhombic, particles move\n        {\n            'type': 'orthorhombic',\n            'H0': np.diag([10.0, 10.0, 10.0]),\n            'x0': np.array([[0.0, 0.0, 0.0], [1.6, 0.0, 0.0], [5.0, 5.0, 5.0]]),\n            'v': np.array([[1.0, 0.0, 0.0], [-1.0, 0.0, 0.0], [0.0, 0.0, 0.0]]),\n            'rc': 1.0, 'delta': 0.3, 't1': 0.4\n        },\n        # Test D: Lees-Edwards, larger deformation\n        {\n            'type': 'lees_edwards',\n            'L': (8.0, 8.0, 8.0), 'gamma0': 0.0, 'gamma_dot': 0.1,\n            's0': np.array([[0.15, 0.15, 0.15], [0.35, 0.35, 0.35], [0.75, 0.75, 0.25]]),\n            'v': np.zeros((3, 3)),\n            'rc': 1.0, 'delta': 0.4, 't1': 2.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3460089"}, {"introduction": "传统的Verlet列表更新策略是全局性的，即使只有少数粒子快速运动，也需要对整个系统进行重建，这可能导致巨大的计算浪费。本高级练习将引导您实现一种更高效的事件驱动方法，即为每对粒子设置基于其相对运动学的“闹钟”，以预测它们穿越邻居列表边界的精确时间。当“闹钟”响起时，您将执行一次局部的“微重建”，仅更新相关粒子的邻居关系，从而在保证全局一致性的前提下，显著提升算法效率，体验分子动力学算法设计的前沿思想。[@problem_id:3460119]", "problem": "考虑一个在二维空间中，于有限时间范围内，遵循牛顿运动学定律并以恒定加速度运动的 $N$ 个质点组成的系统。每个粒子 $i$ 由其初始位置 $\\mathbf{x}_i(0)\\in\\mathbb{R}^2$、初始速度 $\\mathbf{v}_i(0)\\in\\mathbb{R}^2$ 和恒定加速度 $\\mathbf{a}_i\\in\\mathbb{R}^2$ 描述。粒子 $i$ 和 $j$ 之间的成对相对运动由相对位置 $\\mathbf{r}_{ij}(t)=\\mathbf{x}_j(t)-\\mathbf{x}_i(t)$、相对速度 $\\mathbf{v}_{ij}=\\mathbf{v}_j(0)-\\mathbf{v}_i(0)$ 和相对加速度 $\\mathbf{a}_{ij}=\\mathbf{a}_j-\\mathbf{a}_i$ 给出。在时间 $t$ 时，$i$ 和 $j$ 之间的欧几里得距离为 $d_{ij}(t)=\\|\\mathbf{r}_{ij}(t)\\|$。\n\n在分子动力学 (MD) 中，相互作用在超出截断半径 $r_c0$ 后被截断。为避免频繁地全局重建邻居列表，会增加一个缓冲距离 $r_s0$，定义一个邻居壳层半径 $r_n=r_c+r_s$。在时间 $t$ 的邻居列表包含所有满足 $d_{ij}(t)\\leq r_n$ 的粒子对 $(i,j)$。全局一致性要求在模拟过程中的任何时间 $t$，任何相互作用的粒子对（即 $d_{ij}(t)\\leq r_c$）都不能从邻居列表中丢失。\n\n您的任务是实现一个事件驱动的逐对“闹钟”策略，该策略触发局部微重建（仅针对直接涉及警报的粒子）以维持全局一致性，而无需执行完全重建。警报是使用从相对运动学的基本原理推导出的保守预测来调度的，确保一对 $(i,j)$ 的警报激活时间不晚于该对可能穿越邻居壳层边界 $r_n$ 的最早时间（无论是从外部进入还是从内部退出）。当一对 $(i,j)$ 的警报在时间 $t_e$ 触发时，执行一次局部微重建，该重建会根据时间 $t_e$ 的状态更新所有涉及粒子 $i$ 或 $j$ 的粒子对的邻居列表成员关系，并为涉及 $i$ 或 $j$ 的粒子对重新调度警报。不涉及 $i$ 或 $j$ 的粒子对的事件保持不变。\n\n推导起点：牛顿第二定律和匀加速运动学。具体来说，对于每个粒子 $i$，其位置满足 $\\mathbf{x}_i(t)=\\mathbf{x}_i(0)+\\mathbf{v}_i(0)t+\\tfrac{1}{2}\\mathbf{a}_i t^2$。对于一对 $(i,j)$，其相对运动为 $\\mathbf{r}_{ij}(t)=\\mathbf{r}_{ij}(0)+\\mathbf{v}_{ij} t+\\tfrac{1}{2}\\mathbf{a}_{ij} t^2$。使用从这些关系推导出的范数不等式和保守边界来预测进入或退出邻居壳层时与 $r_n$ 相交的最早可能时间。\n\n实现一个程序，该程序：\n- 在 $t=0$ 时使用 $r_n$ 初始化邻居列表。\n- 使用保守边界，根据相对运动学计算每对粒子的警报时间，区分 $d_{ij}(0)r_n$（未来可能进入）和 $d_{ij}(0)\\leq r_n$（未来可能退出）的情况。\n- 按时间顺序处理警报，直至最大时间 $T0$，在每次警报时执行局部微重建，并为涉及警报端点的粒子对重新调度警报。\n- 在一系列时间点上验证全局一致性，检查每个满足 $d_{ij}(t)\\leq r_c$ 的粒子对是否存在于当前的邻居列表中（在处理完该时间点之前的所有警报后）。\n\n物理单位：位置必须以米为单位，速度以米/秒为单位，加速度以米/秒²为单位，时间以秒为单位，距离以米为单位。所有答案必须用这些单位表示。\n\n角度单位：不适用（没有角度作为输出要求）。\n\n您的程序应生成单行输出，其中包含以下测试套件的全局一致性布尔结果，格式为方括号括起来的逗号分隔列表（例如，“$[true,false,true]$”，使用 Python 布尔格式）：\n\n测试套件：\n- 案例 1 (一般情况): $N=5$, $r_c=1.0\\times 10^{-9}\\ \\text{m}$, $r_s=0.2\\times 10^{-9}\\ \\text{m}$, $T=2.0\\times 10^{-9}\\ \\text{s}$，均匀验证网格步长 $\\Delta t=2.0\\times 10^{-11}\\ \\text{s}$，其中\n  - $\\mathbf{x}(0)=\\{[0.0,0.0],[1.3\\times 10^{-9},0.0],[2.6\\times 10^{-9},0.3\\times 10^{-9}],[0.5\\times 10^{-9},1.5\\times 10^{-9}],[3.5\\times 10^{-9},3.0\\times 10^{-9}]\\}$,\n  - $\\mathbf{v}(0)=\\{[120.0,50.0],[-150.0,80.0],[0.0,-120.0],[60.0,-40.0],[-80.0,110.0]\\}$,\n  - $\\mathbf{a}=\\{[5.0\\times 10^{8},-3.0\\times 10^{8}],[-3.0\\times 10^{8},2.0\\times 10^{8}],[0.0,1.0\\times 10^{8}],[1.0\\times 10^{8},1.0\\times 10^{8}],[-2.0\\times 10^{8},-1.0\\times 10^{8}]\\}$.\n- 案例 2 (初始时刻在边界上): $N=4$, $r_c=1.0\\times 10^{-9}\\ \\text{m}$, $r_s=0.2\\times 10^{-9}\\ \\text{m}$, $T=1.0\\times 10^{-9}\\ \\text{s}$, $\\Delta t=1.0\\times 10^{-11}\\ \\text{s}$，其中\n  - $\\mathbf{x}(0)=\\{[0.0,0.0],[1.2\\times 10^{-9},0.0],[3.0\\times 10^{-9},0.0],[0.0,3.0\\times 10^{-9}]\\}$,\n  - $\\mathbf{v}(0)=\\{[0.0,0.0],[-10.0,0.0],[0.0,-20.0],[5.0,5.0]\\}$,\n  - $\\mathbf{a}=\\{[0.0,0.0],[0.0,0.0],[0.0,0.0],[0.0,0.0]\\}$.\n- 案例 3 (静态边界情况): $N=3$, $r_c=1.0\\times 10^{-9}\\ \\text{m}$, $r_s=0.1\\times 10^{-9}\\ \\text{m}$, $T=1.0\\times 10^{-9}\\ \\text{s}$, $\\Delta t=1.0\\times 10^{-11}\\ \\text{s}$，其中\n  - $\\mathbf{x}(0)=\\{[0.0,0.0],[1.5\\times 10^{-9},0.0],[0.0,2.0\\times 10^{-9}]\\}$,\n  - $\\mathbf{v}(0)=\\{[0.0,0.0],[0.0,0.0],[0.0,0.0]\\}$,\n  - $\\mathbf{a}=\\{[0.0,0.0],[0.0,0.0],[0.0,0.0]\\}$.\n- 案例 4 (切向运动压力测试): $N=4$, $r_c=1.0\\times 10^{-9}\\ \\text{m}$, $r_s=0.2\\times 10^{-9}\\ \\text{m}$, $T=5.0\\times 10^{-10}\\ \\text{s}$, $\\Delta t=5.0\\times 10^{-11}\\ \\text{s}$，其中\n  - $\\mathbf{x}(0)=\\{[0.0,0.0],[1.3\\times 10^{-9},0.0],[0.7\\times 10^{-9},1.0\\times 10^{-9}],[2.5\\times 10^{-9},-0.5\\times 10^{-9}]\\}$,\n  - $\\mathbf{v}(0)=\\{[0.0,0.0],[0.0,1.0],[0.0,0.0],[0.0,0.0]\\}$,\n  - $\\mathbf{a}=\\{[0.0,0.0],[0.0,0.0],[0.0,0.0],[0.0,0.0]\\}$.\n\n您的程序必须输出单行，其中包含按案例顺序汇总在单个列表中的四个布尔结果：“[result1,result2,result3,result4]”。", "solution": "用户希望验证一个关于分子动力学中事件驱动邻居列表更新策略的问题陈述，并在其有效的情况下提供一个完整的解决方案。\n\n### 步骤 1：提取已知条件\n- **系统：** 二维空间中的一组 $N$ 个质点。\n- **运动学：** 每个粒子 $i$ 具有恒定加速度，其初始位置为 $\\mathbf{x}_i(0)$，初始速度为 $\\mathbf{v}_i(0)$，恒定加速度为 $\\mathbf{a}_i$。在时间 $t$ 的位置为 $\\mathbf{x}_i(t) = \\mathbf{x}_i(0) + \\mathbf{v}_i(0)t + \\frac{1}{2}\\mathbf{a}_i t^2$。\n- **相对运动：** 对于一对 $(i,j)$，其相对量为 $\\mathbf{r}_{ij}(t) = \\mathbf{x}_j(t) - \\mathbf{x}_i(t)$，$\\mathbf{v}_{ij} = \\mathbf{v}_j(0) - \\mathbf{v}_i(0)$，以及 $\\mathbf{a}_{ij} = \\mathbf{a}_j - \\mathbf{a}_i$。\n- **相互作用半径：** 相互作用截断半径 $r_c  0$ 和缓冲距离 $r_s  0$。\n- **邻居列表：** 由邻居壳层半径 $r_n = r_c + r_s$ 定义。在时间 $t$，该列表包含所有欧几里得距离 $d_{ij}(t) = \\|\\mathbf{r}_{ij}(t)\\| \\le r_n$ 的粒子对 $(i,j)$。\n- **一致性要求：** 在所有验证时间 $t$，任何满足 $d_{ij}(t) \\le r_c$ 的粒子对 $(i,j)$ 都必须存在于邻居列表中。\n- **任务：** 实现一个事件驱动的“闹钟”策略。\n    1. 在 $t=0$ 时初始化邻居列表。\n    2. 基于它们将穿越 $r_n$ 边界的保守预测，为每对粒子安排警报。\n    3. 按时间顺序处理事件（警报和验证），直至最终时间 $T$。\n    4. 当一对 $(i,j)$ 的警报在时间 $t_e$ 触发时：\n        - 执行一次“微重建”：根据 $t_e$ 时的距离，更新所有涉及粒子 $i$ 或 $j$ 的粒子对的邻居列表状态。\n        - 基于它们在 $t_e$ 时的运动学状态，为这些受影响的粒子对重新安排警报。\n    5. 在指定的 $\\Delta t$ 时间间隔验证全局一致性。\n- **测试套件：** 提供了四个测试用例，包含所有参数和初始条件的具体数值。\n- **输出：** 一个布尔值列表 `[true, false, ...]`，指示每个测试用例的总体一致性。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据充分：** 该问题植根于经典力学（匀加速运动学）和标准的计算模拟技术（分子动力学中的邻居列表）。核心概念是公认且科学合理的。\n- **问题定义明确：** 提供了所有必要的数据、初始条件、参数和一个清晰的算法目标。问题是自包含的，并且结构化以便为每个测试用例产生确定性、可验证的结果。\n- **目标明确：** 问题以精确的数学和算法语言陈述，没有主观性或歧义。\n\n问题陈述在科学性、可形式化性、完整性、矛盾性、可行性或适定性方面均未表现出任何缺陷。该任务是计算科学领域一个具有挑战性的算法问题。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供完整的解决方案。\n\n### 解法推导\n\n问题的核心是确定每对粒子的“警报时间”。一对 $(i,j)$ 的警报必须被安排在未来最早的时刻 $\\Delta t  0$，此时它们的间距 $d_{ij}$ 可能等于邻居壳层半径 $r_n$。问题指定了恒定加速度运动学，对此可以精确计算出这个穿越时间，从而提供最紧密的“保守”边界。\n\n设在一对 $(i,j)$ 在更新时间 $t_0$ 的相对状态由相对位置 $\\mathbf{r}_0$、相对速度 $\\mathbf{v}_0$ 和恒定相对加速度 $\\mathbf{a}$ 给出。在 $\\Delta t$ 时间后的相对位置为：\n$$ \\mathbf{r}(\\Delta t) = \\mathbf{r}_0 + \\mathbf{v}_0 \\Delta t + \\frac{1}{2} \\mathbf{a} (\\Delta t)^2 $$\n粒子间的距离平方为 $d^2(\\Delta t) = \\mathbf{r}(\\Delta t) \\cdot \\mathbf{r}(\\Delta t)$。展开这个点积会得到一个关于 $\\Delta t$ 的四次多项式：\n$$ d^2(\\Delta t) = \\left(\\frac{1}{4}\\|\\mathbf{a}\\|^2\\right)(\\Delta t)^4 + (\\mathbf{v}_0 \\cdot \\mathbf{a})(\\Delta t)^3 + (\\|\\mathbf{v}_0\\|^2 + \\mathbf{r}_0 \\cdot \\mathbf{a})(\\Delta t)^2 + (2\\mathbf{r}_0 \\cdot \\mathbf{v}_0)\\Delta t + \\|\\mathbf{r}_0\\|^2 $$\n警报应在距离等于 $r_n$ 时触发，因此我们必须解 $d^2(\\Delta t) = r_n^2$。这等价于找到以下四次多项式 $P(\\Delta t)$ 的根：\n$$ P(\\Delta t) = c_4 (\\Delta t)^4 + c_3 (\\Delta t)^3 + c_2 (\\Delta t)^2 + c_1 \\Delta t + c_0 = 0 $$\n其中系数为：\n- $c_4 = \\frac{1}{4}\\|\\mathbf{a}\\|^2$\n- $c_3 = \\mathbf{v}_0 \\cdot \\mathbf{a}$\n- $c_2 = \\|\\mathbf{v}_0\\|^2 + \\mathbf{r}_0 \\cdot \\mathbf{a}$\n- $c_1 = 2(\\mathbf{r}_0 \\cdot \\mathbf{v}_0)$\n- $c_0 = \\|\\mathbf{r}_0\\|^2 - r_n^2$\n\n警报时间 $\\Delta t_{alarm}$ 是该多项式的最小正实根。如果不存在这样的根，则该对粒子未来不会穿越 $r_n$ 边界，警报时间为无穷大。这个计算可以使用标准的多项式求根算法进行数值求解。\n\n模拟使用事件驱动模型进行，并使用一个优先队列按时间顺序管理事件（警报和验证）。\n\n1.  **初始化：** 在 $t=0$ 时，通过检查所有粒子对与 $r_n$ 的关系来构建邻居列表。然后，对于每一对粒子，通过求解相应的四次方程计算初始警报时间，并将其作为绝对时间推入事件队列。验证检查也以 $\\Delta t$ 的间隔被安排。\n\n2.  **事件处理：** 模拟循环从队列中弹出时间最早的事件。\n    - 如果是在时间 $t_v$ 的**验证事件**，我们遍历所有粒子对。对于每个满足 $d_{ij}(t_v) \\le r_c$ 的粒子对 $(i,j)$，我们检查它是否在当前的邻居列表中。如果有任何这样的粒子对缺失，则模拟未通过一致性检查。\n    - 如果是在时间 $t_e$ 的一对 $(i,j)$ 的**警报事件**，则执行一次“微重建”。这包括：\n        a. 识别所有包含粒子 $i$ 或 $j$ 的粒子对。\n        b. 对于每个受影响的粒子对，根据其在 $t_e$ 时的距离更新其在邻居列表中的成员资格。\n        c. 根据它们在 $t_e$ 时的运动学状态，为每个受影响的粒子对计算新的警报时间，并将这些新警报推入事件队列。\n\n3.  **过时事件处理：** 当处理一对 $(i,j)$ 的警报时，会为所有涉及 $i$ 或 $j$ 的粒子对安排新的警报。这些粒子对仍在队列中的旧警报变成了“过时”事件。为了处理这个问题，我们维护一个注册表（`valid_alarms`），将每对粒子映射到其最近安排的警报时间。当从队列中弹出一个警报时，只有当其时间与注册表中的时间匹配时才处理；否则，它被视为过时事件而被丢弃。\n\n这个过程确保邻居列表始终足够保守，以在任何时候都满足全局一致性要求。每个测试用例的最终输出是一个布尔值，指示在所有验证点上是否保持了一致性。", "answer": "```python\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and print results for all test cases.\n    \"\"\"\n    \n    # Tolerance for floating point comparisons, especially for positive time roots.\n    TOL = 1e-14\n    \n    test_cases = [\n        # Case 1 (general case)\n        {\n            \"N\": 5, \"rc\": 1.0e-9, \"rs\": 0.2e-9, \"T\": 2.0e-9, \"dt_verify\": 2.0e-11,\n            \"x0\": np.array([[0.0, 0.0], [1.3e-9, 0.0], [2.6e-9, 0.3e-9], [0.5e-9, 1.5e-9], [3.5e-9, 3.0e-9]]),\n            \"v0\": np.array([[120.0, 50.0], [-150.0, 80.0], [0.0, -120.0], [60.0, -40.0], [-80.0, 110.0]]),\n            \"a\": np.array([[5.0e8, -3.0e8], [-3.0e8, 2.0e8], [0.0, 1.0e8], [1.0e8, 1.0e8], [-2.0e8, -1.0e8]])\n        },\n        # Case 2 (boundary-at-start)\n        {\n            \"N\": 4, \"rc\": 1.0e-9, \"rs\": 0.2e-9, \"T\": 1.0e-9, \"dt_verify\": 1.0e-11,\n            \"x0\": np.array([[0.0, 0.0], [1.2e-9, 0.0], [3.0e-9, 0.0], [0.0, 3.0e-9]]),\n            \"v0\": np.array([[0.0, 0.0], [-10.0, 0.0], [0.0, -20.0], [5.0, 5.0]]),\n            \"a\": np.array([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]])\n        },\n        # Case 3 (static edge case)\n        {\n            \"N\": 3, \"rc\": 1.0e-9, \"rs\": 0.1e-9, \"T\": 1.0e-9, \"dt_verify\": 1.0e-11,\n            \"x0\": np.array([[0.0, 0.0], [1.5e-9, 0.0], [0.0, 2.0e-9]]),\n            \"v0\": np.array([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0]]),\n            \"a\": np.array([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0]])\n        },\n        # Case 4 (tangential motion stress test)\n        {\n            \"N\": 4, \"rc\": 1.0e-9, \"rs\": 0.2e-9, \"T\": 5.0e-10, \"dt_verify\": 5.0e-11,\n            \"x0\": np.array([[0.0, 0.0], [1.3e-9, 0.0], [0.7e-9, 1.0e-9], [2.5e-9, -0.5e-9]]),\n            \"v0\": np.array([[0.0, 0.0], [0.0, 1.0], [0.0, 0.0], [0.0, 0.0]]),\n            \"a\": np.array([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]])\n        }\n    ]\n\n    def run_simulation(case_data):\n        \"\"\"\n        Executes the event-driven simulation for a single test case.\n        \"\"\"\n        N = case_data[\"N\"]\n        rc, rs = case_data[\"rc\"], case_data[\"rs\"]\n        T, dt_verify = case_data[\"T\"], case_data[\"dt_verify\"]\n        x0, v0, a = case_data[\"x0\"], case_data[\"v0\"], case_data[\"a\"]\n        \n        rn = rc + rs\n        rn_sq = rn**2\n        rc_sq = rc**2\n\n        def get_pair_kinematics(i, j, t):\n            r_ij_0 = x0[j] - x0[i]\n            v_ij_0 = v0[j] - v0[i]\n            a_ij = a[j] - a[i]\n            \n            r_ij_t = r_ij_0 + v_ij_0 * t + 0.5 * a_ij * t**2\n            v_ij_t = v_ij_0 + a_ij * t\n            \n            return r_ij_t, v_ij_t, a_ij\n            \n        def get_dist_sq(i, j, t):\n            r_ij_0 = x0[j] - x0[i]\n            r_ij_t = r_ij_0 + (v0[j] - v0[i]) * t + 0.5 * (a[j] - a[i]) * t**2\n            return np.dot(r_ij_t, r_ij_t)\n\n        def compute_alarm_dt(r, v, acc, rn_sq_val):\n            c4 = 0.25 * np.dot(acc, acc)\n            c3 = np.dot(v, acc)\n            c2 = np.dot(v, v) + np.dot(r, acc)\n            c1 = 2 * np.dot(r, v)\n            c0 = np.dot(r, r) - rn_sq_val\n            \n            coeffs = [c4, c3, c2, c1, c0]\n            first_nonzero = next((i for i, coef in enumerate(coeffs) if abs(coef)  TOL), None)\n            \n            if first_nonzero is None:\n                return float('inf')\n                \n            roots = np.roots(coeffs[first_nonzero:])\n            \n            positive_real_roots = [rt.real for rt in roots if np.isreal(rt) and rt.real  TOL]\n\n            return min(positive_real_roots) if positive_real_roots else float('inf')\n\n        # Initialization\n        current_time = 0.0\n        neighbor_list = set()\n        event_queue = []\n        valid_alarms = {}\n        all_pairs = [(i, j) for i in range(N) for j in range(i + 1, N)]\n        \n        for i, j in all_pairs:\n            r_ij_t0, v_ij_t0, a_ij = get_pair_kinematics(i, j, 0)\n            \n            if np.dot(r_ij_t0, r_ij_t0) = rn_sq:\n                neighbor_list.add((i, j))\n                \n            dt_alarm = compute_alarm_dt(r_ij_t0, v_ij_t0, a_ij, rn_sq)\n            if dt_alarm != float('inf'):\n                alarm_time = dt_alarm\n                heapq.heappush(event_queue, (alarm_time, \"alarm\", (i, j)))\n                valid_alarms[(i, j)] = alarm_time\n\n        for t_v in np.arange(0, T, dt_verify):\n            if t_v = T + TOL:\n                heapq.heappush(event_queue, (t_v, \"verify\", None))\n        # Ensure T is included if not covered by arange\n        if T not in (ev[0] for ev in event_queue if ev[1] == 'verify'):\n             heapq.heappush(event_queue, (T, \"verify\", None))\n\n        overall_consistency = True\n        \n        while event_queue:\n            event_time, event_type, data = heapq.heappop(event_queue)\n            \n            if event_time  T + TOL:\n                break\n            \n            current_time = event_time\n            \n            if event_type == \"alarm\":\n                i_alarm, j_alarm = data\n                if (i_alarm, j_alarm) not in valid_alarms or abs(event_time - valid_alarms.get((i_alarm, j_alarm), -1))  TOL:\n                    continue\n\n                pairs_to_update = set()\n                for p in {i_alarm, j_alarm}:\n                    for k in range(N):\n                        if p != k:\n                            pairs_to_update.add(tuple(sorted((p, k))))\n                \n                for i, j in pairs_to_update:\n                    if get_dist_sq(i, j, current_time) = rn_sq:\n                        neighbor_list.add((i, j))\n                    else:\n                        neighbor_list.discard((i, j))\n                    \n                    r_t, v_t, a_t = get_pair_kinematics(i, j, current_time)\n                    dt_alarm = compute_alarm_dt(r_t, v_t, a_t, rn_sq)\n                    if dt_alarm != float('inf'):\n                        new_alarm_time = current_time + dt_alarm\n                        heapq.heappush(event_queue, (new_alarm_time, \"alarm\", (i, j)))\n                        valid_alarms[(i, j)] = new_alarm_time\n\n            elif event_type == \"verify\":\n                for i_check, j_check in all_pairs:\n                    if get_dist_sq(i_check, j_check, current_time) = rc_sq:\n                        if (i_check, j_check) not in neighbor_list:\n                            overall_consistency = False\n                            # Once inconsistent, the case has failed, but we continue processing \n                            # events up to T in case of complex scenarios.\n                            # For this problem, it's safe to assume one failure means failure.\n                if not overall_consistency:\n                    # To optimize, we can break from the main loop once a failure is detected\n                    # because the final result for the test case is already determined.\n                    pass # Let's keep processing to be fully compliant with the continuous check idea.\n\n\n        return overall_consistency\n\n    results = [run_simulation(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3460119"}]}