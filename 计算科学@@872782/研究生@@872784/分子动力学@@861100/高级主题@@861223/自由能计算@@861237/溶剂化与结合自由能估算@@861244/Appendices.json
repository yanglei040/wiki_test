{"hands_on_practices": [{"introduction": "热力学积分是计算自由能差异的基石。本练习将带你完成关键的最后一步：将模拟中得到的系综平均能量导数 $\\langle \\partial U / \\partial \\lambda \\rangle$ 转换成最终的自由能数值，并至关重要地，估算其不确定性。掌握这一数值处理流程对于将原始模拟数据转化为有意义的热力学量至关重要 [@problem_id:3447320]。", "problem": "您正在通过分子动力学中的热力学积分方法研究溶剂化或结合自由能的差异。考虑一个系统，其势能函数 $U(\\mathbf{x};\\lambda)$ 受可微耦合参数 $\\lambda \\in [0,1]$ 的调节，该函数定义在构型 $\\mathbf{x}$ 上。亥姆霍兹自由能 $A(\\lambda)$ 由配分函数定义，其中逆温度 $\\beta = 1/(k_{\\mathrm{B}} T)$，表达式为 $A(\\lambda) = -\\beta^{-1} \\ln Z(\\lambda)$，而 $Z(\\lambda) = \\int \\exp\\{-\\beta U(\\mathbf{x};\\lambda)\\} \\, d\\mathbf{x}$。您将获得在离散 $\\lambda$ 值处采样的系综平均值 $\\langle \\partial U/\\partial \\lambda \\rangle_{\\lambda_i}$ 及其相关的不确定度，以及在一种情况下，一个非对角协方差矩阵，该矩阵捕捉了不同 $\\lambda$ 值处估计值之间的互相关性。\n\n任务 1 (推导)：从亥姆霍兹自由能 $A(\\lambda)$ 的基本定义和统计力学中公认的热力学恒等式出发，推导一个表达式，将 $\\lambda$ 区间上的自由能差 $\\Delta G$ 与势能对 $\\lambda$ 的导数的系综平均值的积分联系起来。推导如何在一个任意的、严格递增的网格 $\\{\\lambda_i\\}_{i=0}^{N-1}$ 上，使用一个复合求积法则来近似该积分，该法则满足：\n- 尽可能在不重叠的三元组 $(\\lambda_i,\\lambda_{i+1},\\lambda_{i+2})$ 上使用局域二次插值法则，通过对唯一的二次拉格朗日插值多项式在 $[\\lambda_i,\\lambda_{i+2}]$ 上积分。\n- 当三元组不可用时（例如，当末尾剩下一个点对，或总区间数为奇数时），则在单个区间 $[\\lambda_i,\\lambda_{i+1}]$ 上回退使用梯形法则。\n您的推导应表明，总的估计量可以写成数据值的单个线性泛函，即加权和 $\\widehat{\\Delta G} = \\sum_{i=0}^{N-1} w_i \\, y_i$，其中 $y_i \\equiv \\langle \\partial U/\\partial \\lambda \\rangle_{\\lambda_i}$，权重 $w_i$ 仅取决于 $\\lambda$ 网格和所选的复合求积方法。\n\n任务 2 (不确定度传播)：推导在以下两种情况下 $\\widehat{\\Delta G}$ 的方差表达式：\n- 如果每个 $\\lambda_i$ 处只有独立的标准误差 $s_i$ 可用，请展示如何使用求积权重和 $s_i$ 计算 $\\mathrm{Var}(\\widehat{\\Delta G})$。\n- 如果一个完整的协方差矩阵 $\\mathbf{C}$（其元素为 $C_{ij}$）可用，请展示如何使用 $\\mathbf{C}$ 和求积权重计算 $\\mathrm{Var}(\\widehat{\\Delta G})$。\n\n任务 3 (算法)：设计一个算法，给定任意严格递增的 $\\{\\lambda_i\\}$、对应的 $y_i$ 以及标准误差 $s_i$ 或完整的协方差矩阵 $\\mathbf{C}$，通过以下方式构建复合求积权重 $\\{w_i\\}$：\n- 从最小到最大的 $\\lambda$ 将网格划分为尽可能多的不重叠三元组，在每个三元组上应用二次拉格朗日法则，为涉及的三个索引贡献权重，然后\n- 如果需要，对任何剩余的最终区间应用梯形法则。\n然后根据这些权重和不确定度计算 $\\widehat{\\Delta G}$ 及其标准误差。如果输入的 $\\lambda$ 值未按升序排列，您的算法必须对其进行排序，并且必须将相同的置换一致地应用于 $y_i$ 以及 $s_i$ 或 $\\mathbf{C}$。假设所有 $\\lambda$ 都是唯一的。\n\n实现和测试要求：\n- 单位：每个 $y_i$ 的单位是 $\\mathrm{kJ/mol}$，$\\lambda$ 是无量纲的，因此您的 $\\widehat{\\Delta G}$ 必须以 $\\mathrm{kJ/mol}$ 为单位报告。所有不确定度和标准误差也必须以 $\\mathrm{kJ/mol}$ 为单位报告。将最终结果以 $\\mathrm{kJ/mol}$ 表示，并将每个报告的浮点数四舍五入到 $6$ 位小数。\n- 角度单位不适用于本问题。\n- 您的程序必须实现上述算法，并评估以下四个测试用例。对于每个测试用例，计算并报告一对浮点数：首先是 $\\widehat{\\Delta G}$（单位为 $\\mathrm{kJ/mol}$），然后是其标准误差（单位为 $\\mathrm{kJ/mol}$），两者都四舍五入到 $6$ 位小数。\n\n测试套件：\n- 测试用例 1 (均匀网格，二次信号):\n  - $\\lambda = [\\,0.0,\\,0.25,\\,0.5,\\,0.75,\\,1.0\\,]$\n  - $y_i = 2 + 3\\lambda_i - \\lambda_i^2$ (对每个 $\\lambda_i$)\n  - $s_i = 0.05$ (对所有 $i$)\n  - 未提供交叉协方差；将测量误差视为独立的。\n- 测试用例 2 (非均匀网格，含相关误差):\n  - $\\lambda = [\\,0.0,\\,0.1,\\,0.4,\\,0.9,\\,1.0\\,]$\n  - $y_i = 1.5 + 0.5\\lambda_i + 2\\lambda_i^2$ (对每个 $\\lambda_i$)\n  - 标准误差: $s = [\\,0.08,\\,0.10,\\,0.07,\\,0.09,\\,0.08\\,]$\n  - 使用一个完整的协方差矩阵 $\\mathbf{C}$，其对角线元素为 $C_{ii} = s_i^2$，相邻点之间的非对角线元素由 $C_{i,i+1} = C_{i+1,i} = \\rho_1 s_i s_{i+1}$ 给出（其中 $\\rho_1 = 0.3$），次近邻点之间的非对角线元素由 $C_{i,i+2} = C_{i+2,i} = \\rho_2 s_i s_{i+2}$ 给出（其中 $\\rho_2 = 0.1$），所有其他非对角线元素均为 $0$。\n- 测试用例 3 (两点边界情况):\n  - $\\lambda = [\\,0.0,\\,1.0\\,]$\n  - $y = [\\,1.0,\\,3.0\\,]$\n  - $s = [\\,0.2,\\,0.2\\,]$\n  - 未提供交叉协方差；将测量误差视为独立的。\n- 测试用例 4 (奇数个区间，非均匀网格，平滑非多项式信号):\n  - $\\lambda = [\\,0.0,\\,0.05,\\,0.2,\\,0.6,\\,0.85,\\,1.0\\,]$\n  - $y_i = 2 + \\sin(\\pi \\lambda_i)$ (对每个 $\\lambda_i$)，其中 $\\pi$ 是圆周率。\n  - $s = [\\,0.05,\\,0.06,\\,0.04,\\,0.05,\\,0.07,\\,0.05\\,]$\n  - 未提供交叉协方差；将测量误差视为独立的。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含测试用例 1 到 4 的每个用例的估计自由能差及其标准误差。例如，输出必须如下所示：\n  - $[g_1,e_1,g_2,e_2,g_3,e_3,g_4,e_4]$，\n其中每个 $g_i$ 和 $e_i$ 都是一个四舍五入到 $6$ 位小数的浮点数，单位为 $\\mathrm{kJ/mol}$。", "solution": "该问题是有效的，因为它在科学上基于统计力学，在数学上是适定的，并且为获得唯一解提供了所有必要的数据和定义。\n\n### 任务 1：自由能估计量的推导\n\n热力学积分的基本关系源自亥姆霍兹自由能 $A(\\lambda)$ 作为耦合参数 $\\lambda$ 的函数的定义。自由能与正则配分函数 $Z(\\lambda)$ 在逆温度 $\\beta = 1/(k_{\\mathrm{B}} T)$ 下相关：\n$$A(\\lambda) = -\\frac{1}{\\beta} \\ln Z(\\lambda)$$\n其中 $Z(\\lambda) = \\int \\exp\\{-\\beta U(\\mathbf{x};\\lambda)\\} \\, d\\mathbf{x}$ 是对势能为 $U(\\mathbf{x};\\lambda)$ 的系统的所有构型态 $\\mathbf{x}$ 进行的积分。\n\n为了求得自由能差，我们首先对 $A(\\lambda)$ 关于 $\\lambda$求导：\n$$ \\frac{dA(\\lambda)}{d\\lambda} = -\\frac{1}{\\beta Z(\\lambda)} \\frac{dZ(\\lambda)}{d\\lambda} $$\n配分函数的导数为：\n$$ \\frac{dZ(\\lambda)}{d\\lambda} = \\int \\frac{\\partial}{\\partial\\lambda} e^{-\\beta U(\\mathbf{x};\\lambda)} \\, d\\mathbf{x} = \\int \\left(-\\beta \\frac{\\partial U(\\mathbf{x};\\lambda)}{\\partial\\lambda}\\right) e^{-\\beta U(\\mathbf{x};\\lambda)} \\, d\\mathbf{x} $$\n将此代回 $dA/d\\lambda$ 的表达式中：\n$$ \\frac{dA(\\lambda)}{d\\lambda} = -\\frac{1}{\\beta Z(\\lambda)} \\int \\left(-\\beta \\frac{\\partial U}{\\partial\\lambda}\\right) e^{-\\beta U(\\mathbf{x};\\lambda)} \\, d\\mathbf{x} = \\frac{\\int \\frac{\\partial U}{\\partial\\lambda} e^{-\\beta U(\\mathbf{x};\\lambda)} \\, d\\mathbf{x}}{\\int e^{-\\beta U(\\mathbf{x};\\lambda)} \\, d\\mathbf{x}} $$\n等式右边是在给定 $\\lambda$ 值下，物理量 $\\partial U/\\partial \\lambda$ 的正则系综平均的定义。因此，我们得到了核心恒等式：\n$$ \\frac{dA(\\lambda)}{d\\lambda} = \\left\\langle \\frac{\\partial U}{\\partial \\lambda} \\right\\rangle_{\\lambda} $$\n$\\lambda=0$ 和 $\\lambda=1$ 之间的总自由能差 $\\Delta G$ 是通过对该导数积分得到的。（我们按照问题中的规定使用 $\\Delta G$，并注意它在 NVT 系综中等同于 $\\Delta A$）。令 $y(\\lambda) = \\langle \\partial U/\\partial \\lambda \\rangle_{\\lambda}$。\n$$ \\Delta G = A(1) - A(0) = \\int_0^1 \\frac{dA(\\lambda)}{d\\lambda} \\, d\\lambda = \\int_0^1 \\left\\langle \\frac{\\partial U}{\\partial \\lambda} \\right\\rangle_{\\lambda} \\, d\\lambda = \\int_0^1 y(\\lambda) d\\lambda $$\n我们得到该函数在一组离散点 $\\{\\lambda_i\\}_{i=0}^{N-1}$ 上的样本值 $y_i = y(\\lambda_i)$。任务是使用一个特定的复合求积法则来数值近似这个积分。总积分是网格上不重叠区段上积分的总和。该规则是通过将相邻区间成对分组来处理网格，这对应于使用三元点组 $(\\lambda_i, \\lambda_{i+1}, \\lambda_{i+2})$，并应用二次插值法则。如果区间总数为奇数，导致最后剩下一个单独的区间 $[\\lambda_{N-2}, \\lambda_{N-1}]$，则使用梯形法则。\n\n**在三元组 $(\\lambda_i, \\lambda_{i+1}, \\lambda_{i+2})$ 上的二次法则**\n对于三个不共线的点 $(\\lambda_i, y_i)$、$(\\lambda_{i+1}, y_{i+1})$ 和 $(\\lambda_{i+2}, y_{i+2})$，存在一个唯一的二次多项式 $P_2(\\lambda)$ 穿过它们。$y(\\lambda)$ 在 $[\\lambda_i, \\lambda_{i+2}]$ 上的积分可以通过对该多项式积分来近似。结果是函数值 $y_i$、$y_{i+1}$ 和 $y_{i+2}$ 的加权和。对于非均匀间隔的横坐标，令 $h_1 = \\lambda_{i+1} - \\lambda_i$ 和 $h_2 = \\lambda_{i+2} - \\lambda_{i+1}$。拉格朗日插值多项式的积分为：\n$$ \\int_{\\lambda_i}^{\\lambda_{i+2}} P_2(\\lambda) \\, d\\lambda = w'_{i} y_i + w'_{i+1} y_{i+1} + w'_{i+2} y_{i+2} $$\n其中权重为：\n$$ w'_{i} = \\frac{h_1+h_2}{6h_1 h_2} h_2(2h_1-h_2) $$\n$$ w'_{i+1} = \\frac{h_1+h_2}{6h_1 h_2} (h_1+h_2)^2 $$\n$$ w'_{i+2} = \\frac{h_1+h_2}{6h_1 h_2} h_1(2h_2-h_1) $$\n这些权重的和为 $w'_i+w'_{i+1}+w'_{i+2} = h_1+h_2 = \\lambda_{i+2}-\\lambda_i$，即积分子区间的长度。\n\n**在点对 $(\\lambda_i, \\lambda_{i+1})$ 上的梯形法则**\n如果剩余单个区间 $[\\lambda_i, \\lambda_{i+1}]$，我们使用梯形法则，该法则通过梯形面积来近似积分：\n$$ \\int_{\\lambda_i}^{\\lambda_{i+1}} y(\\lambda) \\, d\\lambda \\approx \\frac{\\lambda_{i+1}-\\lambda_i}{2}(y_i + y_{i+1}) = w'_{i} y_i + w'_{i+1} y_{i+1} $$\n其中权重贡献为 $w'_{i} = w'_{i+1} = (\\lambda_{i+1}-\\lambda_i)/2$。\n\n**复合规则与线性泛函形式**\n总积分近似值 $\\widehat{\\Delta G}$ 是将这些规则应用于划分后的网格所得结果的总和。例如，在一个有 $N$ 个点和 $M=N-1$ 个区间的网格上，我们从 $i=0$ 开始以步长 $2$ 进行迭代。对于每个满足 $i+2  N$ 的 $i$，我们将二次法则应用于三元组 $(\\lambda_i, \\lambda_{i+1}, \\lambda_{i+2})$，并将计算出的贡献值加到一个全局权重向量中。如果 $M$ 是奇数，则会留下一个最后的区间 $[\\lambda_{N-2}, \\lambda_{N-1}]$，我们对其应用梯形法则。\n估计的总自由能为：\n$$ \\widehat{\\Delta G} = \\sum_{\\text{sub-integrals}} (\\text{local weighted sum of } y_k) $$\n由于每个 $y_k$ 可能对一个或两个相邻的子积分（例如，$y_2$ 在 $\\int_{\\lambda_0}^{\\lambda_2}$ 和 $\\int_{\\lambda_2}^{\\lambda_4}$ 中）有贡献，因此该过程可以表述为计算一组唯一的权重 $\\{w_i\\}$，使得：\n$$ \\widehat{\\Delta G} = \\sum_{i=0}^{N-1} w_i y_i $$\n每个 $w_i$ 是所有涉及点 $(\\lambda_i, y_i)$ 的局域法则所贡献权重的总和。这表明该估计量是数据值 $\\{y_i\\}$ 的一个线性泛函。\n\n### 任务 2：不确定度传播\n\n估计量 $\\widehat{\\Delta G}$ 是测量量 $y_i$ 的线性组合，而这些 $y_i$ 是随机变量。设 $\\mathbf{w} = [w_0, \\dots, w_{N-1}]^T$ 为权重向量，$\\mathbf{y} = [y_0, \\dots, y_{N-1}]^T$ 为测量值向量。则估计量为 $\\widehat{\\Delta G} = \\mathbf{w}^T \\mathbf{y}$。\n\n**一般情况：完整协方差矩阵**\n相关随机变量的线性组合的方差由通用公式给出：\n$$ \\mathrm{Var}(\\widehat{\\Delta G}) = \\mathrm{Var}(\\mathbf{w}^T \\mathbf{y}) = \\mathbf{w}^T \\mathbf{C} \\mathbf{w} $$\n其中 $\\mathbf{C}$ 是 $\\mathbf{y}$ 的协方差矩阵，其元素为 $C_{ij} = \\mathrm{Cov}(y_i, y_j)$。展开形式为：\n$$ \\mathrm{Var}(\\widehat{\\Delta G}) = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} w_i C_{ij} w_j $$\n\n**特殊情况：独立误差**\n如果每个 $\\lambda_i$ 处的测量误差是独立的，则协方差矩阵 $\\mathbf{C}$ 是对角矩阵。非对角元素为零，$C_{ij} = 0$ for $i \\neq j$。对角元素是每次测量的方差，$C_{ii} = \\mathrm{Var}(y_i) = s_i^2$，其中 $s_i$ 是 $y_i$ 的标准误差。\n在这种情况下，方差的双重求和大大简化：\n$$ \\mathrm{Var}(\\widehat{\\Delta G}) = \\sum_{i=0}^{N-1} w_i^2 s_i^2 $$\n在这两种情况下，估计值 $\\widehat{\\Delta G}$ 的标准误差都是方差的平方根，即 $\\sigma_{\\widehat{\\Delta G}} = \\sqrt{\\mathrm{Var}(\\widehat{\\Delta G})}$。\n\n### 任务 3：算法设计\n\n该算法根据给定的一组点 $\\{\\lambda_i\\}$、相应的数值 $\\{y_i\\}$ 和不确定度（标准误差 $\\{s_i\\}$ 或协方差矩阵 $\\mathbf{C}$）来计算 $\\widehat{\\Delta G}$ 及其标准误差。\n\n1.  **输入排序**：给定输入 $\\lambda = \\{\\lambda_i\\}$、$y = \\{y_i\\}$ 和不确定度，首先确保数据按 $\\lambda$ 排序。计算将 $\\lambda$ 按升序排序的置换 `p`。将此置换应用于 $\\lambda$、$y$ 和不确定度（向量 $s$ 或矩阵 $\\mathbf{C}$ 的行和列）。将排序后的数据表示为 $\\lambda^{\\text{s}}, y^{\\text{s}}, s^{\\text{s}}, \\mathbf{C}^{\\text{s}}$。设 $N$ 为数据点数。\n\n2.  **权重计算**：初始化一个大小为 $N$ 的权重向量 $w$，所有元素均为零。从网格的起点开始迭代，成对处理区间。\n    - 设计数器 `i` 从 $0$ 开始。\n    - 当 `i + 2  N` 时，我们可以形成一个三元组 $(\\lambda^{\\text{s}}_i, \\lambda^{\\text{s}}_{i+1}, \\lambda^{\\text{s}}_{i+2})$。\n        - 计算步长 $h_1 = \\lambda^{\\text{s}}_{i+1} - \\lambda^{\\text{s}}_i$ 和 $h_2 = \\lambda^{\\text{s}}_{i+2} - \\lambda^{\\text{s}}_{i+1}$。\n        - 使用任务1中的二次法则公式计算权重贡献 $w'_i, w'_{i+1}, w'_{i+2}$。\n        - 将这些贡献加到全局权重上：$w_i \\leftarrow w_i + w'_i$，$w_{i+1} \\leftarrow w_{i+1} + w'_{i+1}$，$w_{i+2} \\leftarrow w_{i+2} + w'_{i+2}$。\n        - 增加计数器：`i \\leftarrow i + 2`。\n    - 循环结束后，如果总区间数（$N-1$）为奇数，将剩余一个区间 $[\\lambda^{\\text{s}}_{N-2}, \\lambda^{\\text{s}}_{N-1}]$。这对应于 `i == N-2` 的情况。\n        - 计算步长 $\\Delta\\lambda = \\lambda^{\\text{s}}_{N-1} - \\lambda^{\\text{s}}_{N-2}$。\n        - 应用梯形法则：将 $\\Delta\\lambda/2$ 加到 $w_{N-2}$ 和 $w_{N-1}$ 上。\n\n3.  **自由能估计**：通过计算最终权重向量和排序后的值向量的点积来计算估计的自由能差：\n    $$ \\widehat{\\Delta G} = \\sum_{i=0}^{N-1} w_i y^{\\text{s}}_i $$\n\n4.  **不确定度估计**：计算估计值的方差。\n    - 如果提供的是独立标准误差 $s^{\\text{s}}$：\n      $$ \\mathrm{Var}(\\widehat{\\Delta G}) = \\sum_{i=0}^{N-1} w_i^2 (s^{\\text{s}}_i)^2 $$\n    - 如果提供的是协方差矩阵 $\\mathbf{C}^{\\text{s}}$：\n      $$ \\mathrm{Var}(\\widehat{\\Delta G}) = \\mathbf{w}^T \\mathbf{C}^{\\text{s}} \\mathbf{w} $$\n    - 标准误差为 $\\sigma_{\\widehat{\\Delta G}} = \\sqrt{\\mathrm{Var}(\\widehat{\\Delta G})}$。\n\n5.  **输出**：按要求格式返回计算出的 $\\widehat{\\Delta G}$ 及其标准误差 $\\sigma_{\\widehat{\\Delta G}}$。", "answer": "```python\nimport numpy as np\n\ndef calculate_free_energy_and_error(lambdas, y_values, uncertainties):\n    \"\"\"\n    Calculates the free energy difference and its uncertainty using a custom\n    composite quadrature rule, as described in the problem.\n    \"\"\"\n    # 1. Sort inputs based on lambda values\n    sort_indices = np.argsort(lambdas)\n    l_sorted = np.array(lambdas)[sort_indices]\n    y_sorted = np.array(y_values)[sort_indices]\n    \n    N = len(l_sorted)\n    weights = np.zeros(N)\n\n    # 2. Compute quadrature weights\n    i = 0\n    # Process non-overlapping triplets with quadratic rule (Simpson's variant)\n    while i + 2  N:\n        l1, l2, l3 = l_sorted[i], l_sorted[i+1], l_sorted[i+2]\n        \n        h1 = l2 - l1\n        h2 = l3 - l2\n        \n        # Weights for integrating a quadratic interpolant over [l1, l3]\n        # This is a non-uniform Simpson's rule.\n        # w_i = integral of Lagrange polynomial L_i(x)\n        # Using the formulas from the solution section\n        common_factor = (h1 + h2) / (6 * h1 * h2)\n        w_i_contrib = common_factor * h2 * (2*h1 - h2)\n        w_i1_contrib = common_factor * (h1 + h2)**2\n        w_i2_contrib = common_factor * h1 * (2*h2 - h1)\n        \n        weights[i] += w_i_contrib\n        weights[i+1] += w_i1_contrib\n        weights[i+2] += w_i2_contrib\n        \n        i += 2\n\n    # If an interval remains at the end, use the trapezoidal rule\n    if i  N - 1:\n        l1, l2 = l_sorted[i], l_sorted[i+1]\n        delta_l = l2 - l1\n        weights[i] += delta_l / 2.0\n        weights[i+1] += delta_l / 2.0\n\n    # 3. Calculate free energy estimate\n    delta_g = np.sum(weights * y_sorted)\n\n    # 4. Calculate uncertainty\n    if isinstance(uncertainties, list) or (isinstance(uncertainties, np.ndarray) and uncertainties.ndim == 1):\n        # Independent errors\n        s_sorted = np.array(uncertainties)[sort_indices]\n        var_delta_g = np.sum(weights**2 * s_sorted**2)\n    else:\n        # Full covariance matrix\n        C = np.array(uncertainties)\n        # Permute covariance matrix according to sort order\n        C_sorted = C[sort_indices, :][:, sort_indices]\n        var_delta_g = weights.T @ C_sorted @ weights\n            \n    std_err = np.sqrt(var_delta_g)\n\n    return delta_g, std_err\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            'lambda': [0.0, 0.25, 0.5, 0.75, 1.0],\n            'y_func': lambda l: 2 + 3*l - l**2,\n            'uncertainties': [0.05, 0.05, 0.05, 0.05, 0.05]\n        },\n        # Test Case 2\n        {\n            'lambda': [0.0, 0.1, 0.4, 0.9, 1.0],\n            'y_func': lambda l: 1.5 + 0.5*l + 2*l**2,\n            's': np.array([0.08, 0.10, 0.07, 0.09, 0.08]),\n            'rho1': 0.3, 'rho2': 0.1\n        },\n        # Test Case 3\n        {\n            'lambda': [0.0, 1.0],\n            'y_values': [1.0, 3.0],\n            'uncertainties': [0.2, 0.2]\n        },\n        # Test Case 4\n        {\n            'lambda': [0.0, 0.05, 0.2, 0.6, 0.85, 1.0],\n            'y_func': lambda l: 2 + np.sin(np.pi * l),\n            'uncertainties': [0.05, 0.06, 0.04, 0.05, 0.07, 0.05]\n        }\n    ]\n\n    results = []\n    \n    # Case 1\n    case1 = test_cases[0]\n    y1 = [case1['y_func'](l) for l in case1['lambda']]\n    g1, e1 = calculate_free_energy_and_error(case1['lambda'], y1, case1['uncertainties'])\n    results.extend([g1, e1])\n\n    # Case 2\n    case2 = test_cases[1]\n    y2 = [case2['y_func'](l) for l in case2['lambda']]\n    N2 = len(case2['lambda'])\n    C2 = np.zeros((N2, N2))\n    s2 = case2['s']\n    for i in range(N2):\n        C2[i, i] = s2[i]**2\n        if i + 1  N2:\n            C2[i, i+1] = C2[i+1, i] = case2['rho1'] * s2[i] * s2[i+1]\n        if i + 2  N2:\n            C2[i, i+2] = C2[i+2, i] = case2['rho2'] * s2[i] * s2[i+2]\n    g2, e2 = calculate_free_energy_and_error(case2['lambda'], y2, C2)\n    results.extend([g2, e2])\n\n    # Case 3\n    case3 = test_cases[2]\n    g3, e3 = calculate_free_energy_and_error(case3['lambda'], case3['y_values'], case3['uncertainties'])\n    results.extend([g3, e3])\n\n    # Case 4\n    case4 = test_cases[3]\n    y4 = [case4['y_func'](l) for l in case4['lambda']]\n    g4, e4 = calculate_free_energy_and_error(case4['lambda'], y4, case4['uncertainties'])\n    results.extend([g4, e4])\n\n    print(f\"[{','.join([f'{x:.6f}' for x in results])}]\")\n\nsolve()\n```", "id": "3447320"}, {"introduction": "单一的自由能数值告诉你一个过程*是否*有利，而随温度变化的分析则揭示了*为何*有利。通过拟合在不同温度下收集的自由能数据，我们可以将 $\\Delta G$ 分解为其焓 ($\\Delta H$) 和熵 ($\\Delta S$) 贡献。本练习将指导你如何将热力学模型拟合到 $\\Delta G(T)$ 数据，从而揭示分子识别或溶剂化背后的基本驱动力 [@problem_id:3447345]。", "problem": "给定一系列与温度相关的溶剂化或结合自由能测量值，记为 $\\Delta G(T)$，包含测量不确定度，温度范围为 $290 \\,\\mathrm{K}$ 至 $320 \\,\\mathrm{K}$。假设一个适用于分子动力学分析的热力学模型，其中热容变化 $\\Delta C_p$ 在所考虑的温度范围内为常数。您必须从基本热力学定义出发，将温度依赖关系表示为相对于参考温度 $T_0 = 300 \\,\\mathrm{K}$ 的形式，使用加权最小二乘法 (WLS) 从 $\\Delta G(T)$ 数据中拟合模型中的隐含参数，然后计算在 $T = 298 \\,\\mathrm{K}$ 时的焓变 $\\Delta H$ 和熵变 $\\Delta S$，以及通过参数协方差矩阵传播得到的标准不确定度。\n\n您的推导必须从以下基本关系开始：\n- 吉布斯自由能的定义：$\\Delta G(T) = \\Delta H(T) - T \\, \\Delta S(T)$。\n- 热容变化的定义：$\\Delta C_p = \\frac{d \\Delta H}{dT}$ 以及通过 $T \\frac{d \\Delta S}{dT} = \\Delta C_p$ 与熵保持的一致性。\n\n您必须对由这些关系所隐含的模型进行 WLS 拟合。WLS 定义为最小化 $\\sum_i w_i \\left[\\Delta G(T_i) - \\text{model}(T_i)\\right]^2$，其中 $w_i = 1/\\sigma_i^2$，$\\sigma_i$ 是 $\\Delta G(T_i)$ 测量值的报告标准差。根据拟合结果，通过拟合参数协方差矩阵进行线性传播，估算 $\\Delta H(298 \\,\\mathrm{K})$ 和 $\\Delta S(298 \\,\\mathrm{K})$ 及其标准不确定度。\n\n所有能量必须以 $\\mathrm{kJ/mol}$ 为单位报告，所有熵以 $\\mathrm{kJ/(mol\\,K)}$ 为单位，所有温度以 $\\mathrm{K}$ 为单位。最终数值输出应四舍五入至六位小数。\n\n测试组：\n- 情况 A（$\\Delta C_p$ 非零的一般情况）：\n  - $T_0 = 300 \\,\\mathrm{K}$\n  - 温度点 $T = [290, 295, 300, 305, 310, 315, 320] \\,\\mathrm{K}$\n  - 测量的 $\\Delta G(T)$（单位 $\\mathrm{kJ/mol}$）：$[-7.620200, -7.305000, -7.000000, -6.705000, -6.419700, -6.144268, -5.878458]$\n  - 不确定度 $\\sigma$（单位 $\\mathrm{kJ/mol}$）：$[0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10]$\n- 情况 B（$\\Delta C_p \\approx 0$ 的边界情况）：\n  - $T_0 = 300 \\,\\mathrm{K}$\n  - 温度点 $T = [290, 295, 300, 305, 310, 315, 320] \\,\\mathrm{K}$\n  - 测量的 $\\Delta G(T)$（单位 $\\mathrm{kJ/mol}$）：$[-9.200000, -9.100000, -9.000000, -8.900000, -8.800000, -8.700000, -8.600000]$\n  - 不确定度 $\\sigma$（单位 $\\mathrm{kJ/mol}$）：$[0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]$\n- 情况 C（数据点更少且不确定度更大的边缘情况）：\n  - $T_0 = 300 \\,\\mathrm{K}$\n  - 温度点 $T = [290, 295, 300, 305] \\,\\mathrm{K}$\n  - 测量的 $\\Delta G(T)$（单位 $\\mathrm{kJ/mol}$）：$[-7.933725, -7.958440, -8.000000, -8.058293]$\n  - 不确定度 $\\sigma$（单位 $\\mathrm{kJ/mol}$）：$[0.50, 0.40, 0.50, 0.60]$\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是一个包含四个浮点数的列表，顺序为 $[\\Delta H(298\\,\\mathrm{K}), \\sigma_{\\Delta H(298\\,\\mathrm{K})}, \\Delta S(298\\,\\mathrm{K}), \\sigma_{\\Delta S(298\\,\\mathrm{K})}]$，所有数值均四舍五入至六位小数。例如，输出格式必须类似于：“[[hA,sig_hA,sA,sig_sA],[hB,sig_hB,sB,sig_sB],[hC,sig_hC,sC,sig_sC]]”，并用所需的数值替换。", "solution": "目标是根据一组与温度相关的吉布斯自由能测量值 $\\Delta G(T_i)$，确定在特定目标温度 $T_{target} = 298\\,\\mathrm{K}$ 下的焓变 $\\Delta H$ 和熵变 $\\Delta S$。该分析假设在实验温度范围内，热容变化 $\\Delta C_p$ 是一个常数。解决该问题的方法是：首先推导 $\\Delta G(T)$ 的函数形式，然后使用加权最小二乘法 (WLS) 拟合其参数，最后将拟合产生的不确定度传播到目标量 $\\Delta H(T_{target})$ 和 $\\Delta S(T_{target})$ 上。\n\n**1. $\\Delta G(T)$ 的热力学模型推导**\n\n推导从给定的基本热力学关系开始：\n焓变 $\\Delta H$ 和熵变 $\\Delta S$ 随温度的变化由热容变化 $\\Delta C_p$ 决定：\n$$\n\\frac{d \\Delta H}{dT} = \\Delta C_p\n$$\n$$\n\\frac{d \\Delta S}{dT} = \\frac{\\Delta C_p}{T}\n$$\n假设在感兴趣的温度范围内 $\\Delta C_p$ 是常数，我们可以将这些方程从参考温度 $T_0$ 积分到任意温度 $T$：\n$$\n\\int_{\\Delta H(T_0)}^{\\Delta H(T)} d(\\Delta H') = \\int_{T_0}^{T} \\Delta C_p \\, dT' \\implies \\Delta H(T) = \\Delta H(T_0) + \\Delta C_p (T - T_0)\n$$\n$$\n\\int_{\\Delta S(T_0)}^{\\Delta S(T)} d(\\Delta S') = \\int_{T_0}^{T} \\frac{\\Delta C_p}{T'} \\, dT' \\implies \\Delta S(T) = \\Delta S(T_0) + \\Delta C_p \\ln\\left(\\frac{T}{T_0}\\right)\n$$\n为方便起见，我们记 $\\Delta H_0 \\equiv \\Delta H(T_0)$ 和 $\\Delta S_0 \\equiv \\Delta S(T_0)$。吉布斯自由能的定义为 $\\Delta G(T) = \\Delta H(T) - T \\Delta S(T)$。代入 $\\Delta H(T)$ 和 $\\Delta S(T)$ 的表达式，得到：\n$$\n\\Delta G(T) = [\\Delta H_0 + \\Delta C_p (T - T_0)] - T [\\Delta S_0 + \\Delta C_p \\ln(T/T_0)]\n$$\n为了构建一个适合拟合的线性模型，我们用参考温度下的自由能 $\\Delta G_0 \\equiv \\Delta G(T_0) = \\Delta H_0 - T_0 \\Delta S_0$ 来表示 $\\Delta H_0$。这得到 $\\Delta H_0 = \\Delta G_0 + T_0 \\Delta S_0$。将此代入 $\\Delta G(T)$ 方程：\n$$\n\\Delta G(T) = (\\Delta G_0 + T_0 \\Delta S_0) - T \\Delta S_0 + \\Delta C_p (T - T_0) - T \\Delta C_p \\ln(T/T_0)\n$$\n重新整理各项，将被拟合的参数（$\\Delta G_0$、$\\Delta S_0$、$\\Delta C_p$）分组：\n$$\n\\Delta G(T) = \\Delta G_0 - (T - T_0)\\Delta S_0 + \\Delta C_p \\left[ (T - T_0) - T \\ln\\left(\\frac{T}{T_0}\\right) \\right]\n$$\n这就是最终的模型方程，它对于三个参数 $\\Delta G_0$、$\\Delta S_0$ 和 $\\Delta C_p$ 是线性的。\n\n**2. 加权最小二乘法 (WLS) 公式**\n\n该模型可以表示为矩阵形式 $\\mathbf{y} = \\mathbf{Xp}$，其中 $\\mathbf{y}$ 是观测到的 $\\Delta G(T_i)$ 值的向量，$\\mathbf{p}$ 是参数向量，$\\mathbf{X}$ 是设计矩阵。\n对于 $N$ 个数据点，它们是：\n$$\n\\mathbf{y} = \\begin{bmatrix} \\Delta G(T_1) \\\\ \\vdots \\\\ \\Delta G(T_N) \\end{bmatrix}, \\quad\n\\mathbf{p} = \\begin{bmatrix} \\Delta G_0 \\\\ \\Delta S_0 \\\\ \\Delta C_p \\end{bmatrix}\n$$\n设计矩阵 $\\mathbf{X}$ 的第 $i$ 行对应于在温度 $T_i$ 下第 $i$ 次测量的参数系数：\n$$\n\\mathbf{X}_i = \\begin{bmatrix} 1  -(T_i - T_0)  (T_i - T_0) - T_i \\ln(T_i/T_0) \\end{bmatrix}\n$$\nWLS 方法最小化加权残差平方和 $\\chi^2 = (\\mathbf{y} - \\mathbf{Xp})^T \\mathbf{W} (\\mathbf{y} - \\mathbf{Xp})$，其中 $\\mathbf{W}$ 是对角权重矩阵，其元素为 $W_{ii} = 1/\\sigma_i^2$，$\\sigma_i$ 是 $\\Delta G(T_i)$ 的测量不确定度。\n参数向量 $\\mathbf{p}$ 的解由正规方程组给出：\n$$\n\\mathbf{p} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$\n拟合参数的协方差矩阵 $\\mathbf{C_p}$ 是 $\\chi^2$ 的 Hessian 矩阵的逆矩阵：\n$$\n\\mathbf{C_p} = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1}\n$$\n\n**3. 目标量计算与不确定度传播**\n\n目标是计算在 $T_{target} = 298\\,\\mathrm{K}$ 时的 $\\Delta H(T_{target})$ 和 $\\Delta S(T_{target})$ 及其标准不确定度。我们首先将这些量表示为拟合参数 $\\mathbf{p} = [\\Delta G_0, \\Delta S_0, \\Delta C_p]^T$ 的线性函数。\n\n对于在 $T_{target}$ 的焓：\n$$\n\\Delta H(T_{target}) = \\Delta H_0 + \\Delta C_p (T_{target} - T_0) = (\\Delta G_0 + T_0 \\Delta S_0) + \\Delta C_p (T_{target} - T_0)\n$$\n这是拟合参数的一个线性组合：\n$$\n\\Delta H(T_{target}) = \\begin{bmatrix} 1  T_0  T_{target} - T_0 \\end{bmatrix} \\begin{bmatrix} \\Delta G_0 \\\\ \\Delta S_0 \\\\ \\Delta C_p \\end{bmatrix} = \\mathbf{j}_H^T \\mathbf{p}\n$$\n其中 $\\mathbf{j}_H = [1, T_0, T_{target} - T_0]^T$ 是 $\\Delta H(T_{target})$ 相对于参数的雅可比向量。\n\n对于在 $T_{target}$ 的熵：\n$$\n\\Delta S(T_{target}) = \\Delta S_0 + \\Delta C_p \\ln(T_{target}/T_0)\n$$\n这也是拟合参数的一个线性组合：\n$$\n\\Delta S(T_{target}) = \\begin{bmatrix} 0  1  \\ln(T_{target}/T_0) \\end{bmatrix} \\begin{bmatrix} \\Delta G_0 \\\\ \\Delta S_0 \\\\ \\Delta C_p \\end{bmatrix} = \\mathbf{j}_S^T \\mathbf{p}\n$$\n其中 $\\mathbf{j}_S = [0, 1, \\ln(T_{target}/T_0)]^T$ 是对应的雅可比向量。\n\n对于一个量 $F = \\mathbf{j}^T \\mathbf{p}$，其方差由误差传播公式 $\\sigma_F^2 = \\mathbf{j}^T \\mathbf{C_p} \\mathbf{j}$ 给出。将此应用于我们的目标量：\n$\\Delta H(T_{target})$ 的方差为：\n$$\n\\sigma_{\\Delta H}^2 = \\mathbf{j}_H^T \\mathbf{C_p} \\mathbf{j}_H\n$$\n$\\Delta S(T_{target})$ 的方差为：\n$$\n\\sigma_{\\Delta S}^2 = \\mathbf{j}_S^T \\mathbf{C_p} \\mathbf{j}_S\n$$\n标准不确定度 $\\sigma_{\\Delta H}$ 和 $\\sigma_{\\Delta S}$ 是这些方差的平方根。\n\n计算步骤如下：\n1. 对每个测试用例，根据给定的 $\\Delta G_i$ 和 $\\sigma_i$ 构建测量向量 $\\mathbf{y}$ 和权重矩阵 $\\mathbf{W}$。\n2. 使用温度点 $T_i$ 和参考温度 $T_0 = 300\\,\\mathrm{K}$ 构建设计矩阵 $\\mathbf{X}$。\n3. 求解参数向量 $\\mathbf{p}$ 和协方差矩阵 $\\mathbf{C_p}$。\n4. 使用拟合的参数计算 $\\Delta H(298\\,\\mathrm{K})$ 和 $\\Delta S(298\\,\\mathrm{K})$ 的值。\n5. 为 $T_{target} = 298\\,\\mathrm{K}$ 构建雅可比向量 $\\mathbf{j}_H$ 和 $\\mathbf{j}_S$。\n6. 计算方差 $\\sigma_{\\Delta H}^2$ 和 $\\sigma_{\\Delta S}^2$ 并取其平方根以得到标准不确定度。\n所有能量的单位均为 $\\mathrm{kJ/mol}$，熵的单位均为 $\\mathrm{kJ/(mol \\cdot K)}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T\": [290, 295, 300, 305, 310, 315, 320],\n            \"dG\": [-7.620200, -7.305000, -7.000000, -6.705000, -6.419700, -6.144268, -5.878458],\n            \"sigma\": [0.10, 0.10, 0.10, 0.10, 0.10, 0.10, 0.10]\n        },\n        {\n            \"T\": [290, 295, 300, 305, 310, 315, 320],\n            \"dG\": [-9.200000, -9.100000, -9.000000, -8.900000, -8.800000, -8.700000, -8.600000],\n            \"sigma\": [0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]\n        },\n        {\n            \"T\": [290, 295, 300, 305],\n            \"dG\": [-7.933725, -7.958440, -8.000000, -8.058293],\n            \"sigma\": [0.50, 0.40, 0.50, 0.60]\n        }\n    ]\n\n    T0 = 300.0  # Reference temperature in K\n    T_target = 298.0  # Target temperature in K\n\n    results = []\n    for case in test_cases:\n        T_arr = np.array(case[\"T\"])\n        dG_arr = np.array(case[\"dG\"])\n        sigma_arr = np.array(case[\"sigma\"])\n\n        result = fit_thermo_model(T_arr, dG_arr, sigma_arr, T0, T_target)\n        results.append(result)\n\n    # Format the output string as per problem specification.\n    case_results_str = []\n    for res in results:\n        case_results_str.append(\n            f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f},{res[3]:.6f}]\"\n        )\n    \n    print(f\"[{','.join(case_results_str)}]\")\n\ndef fit_thermo_model(T, dG, sigma, T0, T_target):\n    \"\"\"\n    Performs a Weighted Least Squares fit to the thermodynamic model and propagates uncertainties.\n\n    Args:\n        T (np.ndarray): Array of temperatures in K.\n        dG (np.ndarray): Array of measured Gibbs free energies in kJ/mol.\n        sigma (np.ndarray): Array of uncertainties for dG in kJ/mol.\n        T0 (float): Reference temperature in K.\n        T_target (float): Target temperature for calculation in K.\n\n    Returns:\n        tuple: A tuple containing (dH_target, sigma_dH, dS_target, sigma_dS) at T_target.\n    \"\"\"\n    # 1. Construct the design matrix X\n    # The model is dG(T) = dG0 - (T-T0)*dS0 + dCp*[(T-T0) - T*ln(T/T0)]\n    # Parameters p = [dG0, dS0, dCp]\n    num_points = len(T)\n    X = np.zeros((num_points, 3))\n    \n    # Using np.errstate to handle the case T=T0 for the log term, where the result is 0.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        col0 = np.ones(num_points)\n        col1 = -(T - T0)\n        # The third column's expression is zero when T = T0\n        col2 = (T - T0) - T * np.log(T / T0)\n        col2[T == T0] = 0.0\n\n    X[:, 0] = col0\n    X[:, 1] = col1\n    X[:, 2] = col2\n\n    # 2. Construct the weight matrix W (as a vector for efficiency)\n    w = 1.0 / (sigma**2)\n\n    # 3. Solve the normal equations for parameters and covariance matrix\n    # p = (X^T W X)^-1 X^T W y\n    # Cov(p) = (X^T W X)^-1\n    XT_W = X.T * w  # Broadcasting w to rows of X.T\n    XT_W_X = XT_W @ X\n    \n    # Parameter covariance matrix\n    Cp = np.linalg.inv(XT_W_X)\n    \n    XT_W_y = XT_W @ dG\n    \n    # Best-fit parameters\n    p = Cp @ XT_W_y\n    dG0, dS0, dCp = p\n\n    # 4. Calculate target quantities (dH and dS at T_target)\n    # dH(T) = dG0 + T0*dS0 + (T-T0)*dCp\n    dH_target = dG0 + T0 * dS0 + (T_target - T0) * dCp\n    \n    # dS(T) = dS0 + dCp*ln(T/T0)\n    # Handle the case where T_target might be T0, for which ln(1)=0\n    log_term_S = np.log(T_target / T0) if T_target != T0 else 0.0\n    dS_target = dS0 + dCp * log_term_S\n\n    # 5. Propagate uncertainties\n    # Variance(F) = j^T * Cov(p) * j\n    \n    # Jacobian for dH(T_target) w.r.t p=[dG0, dS0, dCp]\n    jH = np.array([1.0, T0, T_target - T0])\n    \n    # Jacobian for dS(T_target) w.r.t p=[dG0, dS0, dCp]\n    jS = np.array([0.0, 1.0, log_term_S])\n\n    # Calculate variances\n    var_dH = jH.T @ Cp @ jH\n    var_dS = jS.T @ Cp @ jS\n\n    # Standard uncertainties are the square roots of the variances\n    sigma_dH = np.sqrt(var_dH)\n    sigma_dS = np.sqrt(var_dS)\n    \n    return dH_target, sigma_dH, dS_target, sigma_dS\n\n# Execute the main function when the script is run\nsolve()\n```", "id": "3447345"}, {"introduction": "自由能计算的准确性在很大程度上取决于相邻热力学态之间充分的采样和重叠。本练习探讨了炼金术路径的设计，特别是用于避免奇异点的“软核”势函数，如何影响计算的稳定性和可靠性。你将学习使用巴氏系数和有效样本大小等关键指标来诊断自由能模拟的质量 [@problem_id:3447341]。", "problem": "考虑一个在正则系综中建模的配体-受体接触。设在耦合参数 $\\lambda \\in [0,1]$ 下，总势能是单个径向坐标 $r$（代表性配体重原子与受体位点之间的距离）的函数，其表达式为\n$$\nU_\\lambda(r) = U_\\mathrm{conf}(r) + U_\\mathrm{softcore}(\\lambda, r),\n$$\n其中包含一个限制项\n$$\nU_\\mathrm{conf}(r) = \\tfrac{1}{2} k (r - r_0)^2,\n$$\n和一个软核排斥项\n$$\nU_\\mathrm{softcore}(\\lambda, r) = \\lambda \\, \\varepsilon \\, \\frac{1}{\\alpha + r^n}.\n$$\n此处 $\\varepsilon$ 是一个正能量标度，$\\alpha0$ 是一个软核半径，其幂为软核指数 $n$，而 $k0$ 和 $r_00$ 表征了一个谐波限制，代表了大体积配体在腔内的空间位阻。在三维空间中，对于固定的 $\\lambda$，$r$ 的正则概率密度为\n$$\np_\\lambda(r) = \\frac{4\\pi r^2 \\exp\\left(-\\beta U_\\lambda(r)\\right)}{Z_\\lambda}, \\quad \\beta = \\frac{1}{k_\\mathrm{B} T}, \\quad Z_\\lambda = \\int_0^{r_\\mathrm{max}} 4\\pi r^2 \\exp\\left(-\\beta U_\\lambda(r)\\right)\\, \\mathrm{d}r,\n$$\n其中 $k_\\mathrm{B}$ 是玻尔兹曼常数，$T$ 是绝对温度，上限 $r_\\mathrm{max}$ 是径向坐标的一个物理上合理的截断值。\n\n在用于溶剂化和结合自由能估算的自由能微扰（FEP）方法中，一个关键挑战是估计量在一系列 $\\lambda$ 值上的稳定性。稳定性与避免在小 $r$ 处的奇异力以及在相邻 $\\lambda$ 态之间保持足够的构象系综重叠有关。在正则重要性采样框架中，从 $\\lambda_i$ 到 $\\lambda_{i+1}$ 的指数功重加权的一个稳定性指标使用权重\n$$\nw(r) = \\exp\\left(-\\beta \\left[ U_{\\lambda_{i+1}}(r) - U_{\\lambda_i}(r) \\right]\\right),\n$$\n其期望值在 $p_{\\lambda_i}(r)$ 分布下计算。此重加权的相对有效样本量（ESS）分数定义为\n$$\n\\rho_{i} = \\frac{\\left\\langle w(r) \\right\\rangle_{p_{\\lambda_i}}^2}{\\left\\langle w(r)^2 \\right\\rangle_{p_{\\lambda_i}}},\n$$\n其值位于区间 $(0,1]$ 内，并随构象重叠的增加而增加。一个独立于重加权的重叠度量是相邻系综之间的 Bhattacharyya 系数，\n$$\n\\mathrm{BC}_{i} = \\int_0^{r_\\mathrm{max}} \\sqrt{p_{\\lambda_i}(r)\\, p_{\\lambda_{i+1}}(r)} \\, \\mathrm{d}r,\n$$\n其值也位于 $(0,1]$ 内，并随重叠的增加而增加。可以通过在整个 $\\lambda$ 方案中，在小的接触区域 $[0, r_c]$ 内，$U_\\mathrm{softcore}$ 产生的最大力的大小来监测接触附近的奇异性避免情况，其中力为\n$$\nF_\\mathrm{softcore}(\\lambda, r) = \\left| \\frac{\\partial U_\\mathrm{softcore}(\\lambda, r)}{\\partial r} \\right| = \\lambda \\varepsilon \\left| \\frac{-n r^{n-1}}{(\\alpha + r^n)^2} \\right|.\n$$\n\n从正则系综定义和重要性采样出发，推导上述重叠和稳定性指标，并设计一个算法在离散化的径向网格上计算它们。实现该算法，通过改变 $U_\\mathrm{softcore} \\propto 1/(\\alpha + r^n)$ 中的 $n$ 值，并监测整个 $\\lambda$ 范围内的奇异性避免和重叠度量，来比较不同软核指数 $n$ 对大体积配体的 FEP 稳定性的影响。\n\n使用以下科学上合理的参数和单位：\n- 温度 $T = 300\\,\\mathrm{K}$，玻尔兹曼常数 $k_\\mathrm{B} = 0.008314462618\\,\\mathrm{kJ}\\, \\mathrm{mol}^{-1}\\, \\mathrm{K}^{-1}$，因此 $\\beta = 1/(k_\\mathrm{B} T)$ 的单位是 $\\mathrm{mol}\\, \\mathrm{kJ}^{-1}$。\n- 能量标度 $\\varepsilon = 5\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n- 限制参数 $k = 100\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-2}$ 和 $r_0 = 0.3\\,\\mathrm{nm}$。\n- 软核长度标度 $a = 0.1\\,\\mathrm{nm}$，因此 $\\alpha = a^n$ 以确保 $\\alpha$ 的单位是 $\\mathrm{nm}^n$。\n- 径向域 $r \\in [0, r_\\mathrm{max}]$，其中 $r_\\mathrm{max} = 1.2\\,\\mathrm{nm}$。\n- 接触区域上界 $r_c = 0.05\\,\\mathrm{nm}$。\n- $\\lambda$ 方案为 $[0,1]$ 上的 $M = 11$ 个等距点。\n\n用足够精细的均匀网格离散化径向坐标 $r$，以确保求积的数值稳定性。对于每个相邻对 $\\lambda_i, \\lambda_{i+1}$，计算：\n- Bhattacharyya 系数 $\\mathrm{BC}_i$。\n- 上文定义的相对有效样本量分数 $\\rho_i$。\n- 最大软核力的大小 $\\max_{\\lambda \\in \\{\\lambda_i,\\lambda_{i+1}\\},\\, r \\in [0, r_c]} F_\\mathrm{softcore}(\\lambda, r)$，单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$。\n\n对于下面测试套件中的每个软核指数 $n$，汇总所有相邻 $\\lambda$ 对 $\\{(\\lambda_i,\\lambda_{i+1})\\}_{i=0}^{M-2}$ 的以下摘要统计量：\n- 整个方案中的最小 Bhattacharyya 系数，$\\min_i \\mathrm{BC}_i$（无量纲）。\n- 整个方案中的最小 ESS 分数，$\\min_i \\rho_i$（无量纲）。\n- 整个方案中的最大接触区域力，$\\max_{i} \\max_{\\lambda \\in \\{\\lambda_i,\\lambda_{i+1}\\},\\, r \\in [0, r_c]} F_\\mathrm{softcore}(\\lambda, r)$，以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$ 为单位报告。\n\n测试套件：\n- 情况 1：$n = 1$。\n- 情况 2：$n = 2$。\n- 情况 3：$n = 4$。\n- 情况 4：$n = 8$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个情况生成一个包含三个浮点数的列表 $[\\min \\mathrm{BC}, \\min \\rho, \\max F]$，顺序如上。例如，总体输出应如下所示\n$$\n\\left[ [x_1,y_1,z_1], [x_2,y_2,z_2], [x_3,y_3,z_3], [x_4,y_4,z_4] \\right],\n$$\n其中每个 $x_j$，$y_j$ 和 $z_j$ 都是十进制浮点数。最终的力值 $z_j$ 严格以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-1}$ 为单位表示。所有重叠量都是无量纲的。确保程序没有输入并能确定性地运行。", "solution": "该问题要求推导并数值计算若干用于评估分子动力学中自由能微扰（FEP）计算稳定性的度量指标。该模型系统涉及一个在由耦合参数 $\\lambda$ 参数化的势能 $U_\\lambda(r)$ 下的单一径向坐标 $r$。我们将首先推导指定的指标，然后概述其数值计算的算法。\n\n总势能由 $U_\\lambda(r) = U_\\mathrm{conf}(r) + U_\\mathrm{softcore}(\\lambda, r)$ 给出，包含谐波限制项 $U_\\mathrm{conf}(r) = \\frac{1}{2} k (r - r_0)^2$ 和软核排斥项 $U_\\mathrm{softcore}(\\lambda, r) = \\lambda \\varepsilon / (\\alpha + r^n)$。系统处于温度为 $T$ 的正则系综中，从而得到径向概率密度 $p_\\lambda(r) = (4\\pi r^2 / Z_\\lambda) \\exp(-\\beta U_\\lambda(r))$，其中 $\\beta = 1/(k_\\mathrm{B}T)$，$Z_\\lambda$ 是配分函数。\n\n### 稳定性和重叠度量的推导\n\n**1. 相对有效样本量 ($\\rho_i$)**\n\n相对有效样本量 $\\rho_i$ 是一个源于重要性采样理论的度量。当使用从参考态 $\\lambda_i$ 采样的构象来估计目标态 $\\lambda_{i+1}$ 的可观测量时，每个构象都被赋予一个权重。这些权重的方差决定了重加权过程的统计效率。低方差对应于良好的相空间重叠和高的有效样本量。\n\n在状态 $\\lambda$ 下观察到构象 $r$ 的未归一化概率与 $\\exp(-\\beta U_\\lambda(r))$ 成正比。从状态 $p_{\\lambda_i}$ 重加权到 $p_{\\lambda_{i+1}}$ 的精确重要性权重是 $p_{\\lambda_{i+1}}(r) / p_{\\lambda_i}(r)$。然而，在使用 Bennett Acceptance Ratio 或 Zwanzig 方程的自由能计算中，关键量是指数功，定义为 $w(r) = \\exp(-\\beta \\Delta U(r)) = \\exp(-\\beta [U_{\\lambda_{i+1}}(r) - U_{\\lambda_i}(r)])$。\n\n该权重在分布 $p_{\\lambda_i}(r)$下的期望值与自由能差有关：\n$$\n\\left\\langle w(r) \\right\\rangle_{p_{\\lambda_i}} = \\int_0^{r_\\mathrm{max}} p_{\\lambda_i}(r) \\exp\\left(-\\beta [U_{\\lambda_{i+1}}(r) - U_{\\lambda_i}(r)]\\right) \\mathrm{d}r\n$$\n$$\n\\left\\langle w(r) \\right\\rangle_{p_{\\lambda_i}} = \\int_0^{r_\\mathrm{max}} \\frac{4\\pi r^2 \\exp(-\\beta U_{\\lambda_i}(r))}{Z_{\\lambda_i}} \\exp\\left(-\\beta [U_{\\lambda_{i+1}}(r) - U_{\\lambda_i}(r)]\\right) \\mathrm{d}r = \\frac{1}{Z_{\\lambda_i}} \\int_0^{r_\\mathrm{max}} 4\\pi r^2 \\exp(-\\beta U_{\\lambda_{i+1}}(r)) \\mathrm{d}r = \\frac{Z_{\\lambda_{i+1}}}{Z_{\\lambda_i}}\n$$\n量 $\\rho_i$ 定义为权重的均值的平方除以权重的平方的均值：\n$$\n\\rho_{i} = \\frac{\\left\\langle w(r) \\right\\rangle_{p_{\\lambda_i}}^2}{\\left\\langle w(r)^2 \\right\\rangle_{p_{\\lambda_i}}}\n$$\n这个量与两个分布的重叠有关。如果分布相同，则 $w(r)=1$，且 $\\rho_i=1$。如果分布重叠性差，$w(r)$ 的方差会很大，导致分母 $\\langle w(r)^2 \\rangle_{p_{\\lambda_i}}$ 远大于分子 $\\langle w(r) \\rangle_{p_{\\lambda_i}}^2$，从而得到一个小的 $\\rho_i  1$。这种表述是相对有效样本量的标准代理，因此被用作稳定性指标。\n\n**2. Bhattacharyya 系数 ($\\mathrm{BC}_i$)**\n\nBhattacharyya 系数是衡量两个概率分布相似性的直接方法。对于两个连续的概率密度函数 $p(x)$ 和 $q(x)$，它定义为：\n$$\n\\mathrm{BC}(p, q) = \\int \\sqrt{p(x)q(x)} \\, \\mathrm{d}x\n$$\n$\\mathrm{BC}$ 的值范围从 $0$（对于不重叠的分布）到 $1$（对于相同的分布）。问题将此定义直接应用于 $r$ 的定义域上的相邻概率密度 $p_{\\lambda_i}(r)$ 和 $p_{\\lambda_{i+1}}(r)$：\n$$\n\\mathrm{BC}_{i} = \\int_0^{r_\\mathrm{max}} \\sqrt{p_{\\lambda_i}(r)\\, p_{\\lambda_{i+1}}(r)} \\, \\mathrm{d}r\n$$\n这提供了一个稳健的、独立于重加权的、衡量相邻 $\\lambda$ 态之间构象重叠的方法。\n\n**3. 软核力 ($F_\\mathrm{softcore}$)**\n\n由势能产生的力是其梯度的负值。对于一维径向势能 $U_\\mathrm{softcore}(\\lambda, r)$，力的大小由其对 $r$ 的导数的绝对值给出：\n$$\nF_\\mathrm{softcore}(\\lambda, r) = \\left| \\frac{\\partial U_\\mathrm{softcore}(\\lambda, r)}{\\partial r} \\right|\n$$\n给定 $U_\\mathrm{softcore}(\\lambda, r) = \\lambda \\varepsilon (\\alpha + r^n)^{-1}$，我们对 $r$ 求导：\n$$\n\\frac{\\partial U_\\mathrm{softcore}}{\\partial r} = \\lambda \\varepsilon \\cdot (-1) (\\alpha + r^n)^{-2} \\cdot \\frac{\\partial}{\\partial r}(\\alpha + r^n) = - \\lambda \\varepsilon (\\alpha + r^n)^{-2} (n r^{n-1}) = - \\frac{\\lambda \\varepsilon n r^{n-1}}{(\\alpha + r^n)^2}\n$$\n取绝对值，并注意到所有参数（$\\lambda, \\varepsilon, n, \\alpha$）和坐标 $r$ 都是非负的，我们得到问题中给出的表达式：\n$$\nF_\\mathrm{softcore}(\\lambda, r) = \\frac{\\lambda \\varepsilon n r^{n-1}}{(\\alpha + r^n)^2}\n$$\n这个度量对于监测由小分子间距（奇异点）处的大作用力引起的潜在数值不稳定性非常重要，这是炼金术变换中的一个常见问题。\n\n### 数值计算的算法设计\n\n对于每个软核指数 $n \\in \\{1, 2, 4, 8\\}$，通过在指定的 $\\lambda$ 方案中迭代相邻对 $(\\lambda_i, \\lambda_{i+1})$ 来计算这些度量。\n\n**1. 离散化和网格设置**\n将径向坐标 $r$ 在从 $0$ 到 $r_\\mathrm{max}$ 的范围内离散化为一个精细的均匀网格。这使得所有积分都可以使用梯形法则进行数值近似，该方法适用于平滑或采样良好的函数。选择足够多的网格点以确保收敛。\n\n**2. 概率密度的计算**\n对于方案中的每个 $\\lambda$ 值，相应的归一化概率密度 $p_\\lambda(r)$ 计算如下：\n- 在径向网格上计算总势能 $U_\\lambda(r) = \\frac{1}{2} k (r - r_0)^2 + \\lambda \\varepsilon (\\alpha + r^n)^{-1}$。\n- 为防止计算玻尔兹曼因子时出现数值下溢或上溢，使用了一种标准的稳定化技术。在求指数之前，减去网格上势能的最小值 $U_{\\lambda, \\mathrm{min}} = \\min_r U_\\lambda(r)$。未归一化的密度则为 $\\tilde{p}_\\lambda(r) = 4\\pi r^2 \\exp(-\\beta [U_\\lambda(r) - U_{\\lambda, \\mathrm{min}}])$。\n- 配分函数 $Z_\\lambda$ 通过对这个未归一化密度进行数值积分来计算：$Z_\\lambda \\propto \\int_0^{r_\\mathrm{max}} \\tilde{p}_\\lambda(r) \\mathrm{d}r$。此步骤使用梯形法则（`numpy.trapz`）。\n- 归一化概率密度通过除法得到：$p_\\lambda(r) = \\tilde{p}_\\lambda(r) / \\int_0^{r_\\mathrm{max}} \\tilde{p}_\\lambda(r) \\mathrm{d}r$。常数因子 $\\exp(-\\beta U_{\\lambda, \\mathrm{min}})$ 在此归一化过程中被抵消。\n\n**3. 计算每个 $(\\lambda_i, \\lambda_{i+1})$ 对的度量**\n在网格上获得密度 $p_{\\lambda_i}(r)$ 和 $p_{\\lambda_{i+1}}(r)$ 后，计算度量如下：\n- **$\\mathrm{BC}_i$**：被积函数 $\\sqrt{p_{\\lambda_i}(r) p_{\\lambda_{i+1}}(r)}$ 在网格上逐点计算，然后使用梯形法则进行数值积分。\n- **$\\rho_i$**：权重函数 $w(r) = \\exp(-\\beta [U_{\\lambda_{i+1}}(r) - U_{\\lambda_i}(r)])$ 在网格上求值。期望值 $\\langle w \\rangle_{p_{\\lambda_i}} = \\int w(r) p_{\\lambda_i}(r) \\mathrm{d}r$ 和 $\\langle w^2 \\rangle_{p_{\\lambda_i}} = \\int w(r)^2 p_{\\lambda_i}(r) \\mathrm{d}r$ 通过数值积分计算。然后根据它们的比率计算 $\\rho_i$。\n- **最大接触力**：我们通过解析方法而非数值搜索来找到最大力。力与 $\\lambda$ 成正比，因此在 $\\lambda \\in \\{\\lambda_i, \\lambda_{i+1}\\}$ 上的最大值出现在 $\\lambda_{i+1}$ 处。然后我们必须找到 $F_\\mathrm{softcore}(\\lambda_{i+1}, r)$ 在 $r \\in [0, r_c]$ 上的最大值。\n    - 对于 $n=1$，力 $F \\propto (\\alpha+r)^{-2}$ 是 $r$ 的单调递减函数。其在 $[0, r_c]$ 上的最大值在 $r=0$ 处。\n    - 对于 $n1$，力在 $r=0$ 时为 $0$，并在 $r_\\mathrm{peak} = a ((n-1)/(n+1))^{1/n}$ 处有一个单峰。对于给定的参数（$a=0.1\\,\\mathrm{nm}$, $r_c=0.05\\,\\mathrm{nm}$），分析表明对于所有测试的 $n  1$，$r_\\mathrm{peak}  r_c$。因此，力在 $[0, r_c]$ 上是单调递增的，其最大值出现在 $r=r_c$ 处。\n    - 因此，对于对 $(\\lambda_i, \\lambda_{i+1})$，最大力在 $n=1$ 时为 $F_\\mathrm{softcore}(\\lambda_{i+1}, 0)$，在 $n1$ 时为 $F_\\mathrm{softcore}(\\lambda_{i+1}, r_c)$。\n\n**4. 结果汇总**\n对于每个软核指数 $n$，为所有 $M-1$ 个相邻的 $\\lambda$ 对计算这三个度量。然后，通过取所有计算的 $\\mathrm{BC}_i$ 值的最小值、所有 $\\rho_i$ 值的最小值以及整个方案中所有计算的最大接触力的最大值来获得最终的摘要统计量。对测试套件中的每个 $n$ 值重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes FEP stability metrics for a model ligand-receptor interaction\n    with a softcore potential, varying the softcore exponent 'n'.\n    \"\"\"\n    # --- Define Constants and Parameters ---\n    # Physical constants\n    T = 300.0  # Temperature in K\n    kB = 0.008314462618  # Boltzmann constant in kJ mol^-1 K^-1\n    BETA = 1.0 / (T * kB)  # Inverse temperature in mol kJ^-1\n\n    # Potential parameters\n    EPSILON = 5.0  # Energy scale in kJ mol^-1\n    K = 100.0  # Confinement spring constant in kJ mol^-1 nm^-2\n    R0 = 0.3  # Confinement equilibrium distance in nm\n    A = 0.1  # Softcore length scale in nm\n\n    # Domain and grid parameters\n    R_MAX = 1.2  # Maximum radial coordinate in nm\n    R_C = 0.05  # Contact region upper bound in nm\n    N_POINTS = 20000  # Number of points for the radial grid\n    \n    # Lambda schedule\n    M = 11  # Number of lambda points\n    lambda_schedule = np.linspace(0.0, 1.0, M)\n\n    # Test suite for softcore exponent n\n    test_suite = [1, 2, 4, 8]\n    \n    # --- Setup Numerical Grid ---\n    r_grid = np.linspace(0.0, R_MAX, N_POINTS)\n\n    # --- Main Calculation Loop ---\n    final_results = []\n    \n    # Define potential and force functions\n    def u_conf(r):\n        return 0.5 * K * (r - R0)**2\n\n    def u_softcore(r, lam, n_val, alpha_val):\n        return lam * EPSILON / (alpha_val + np.power(r, n_val))\n\n    def u_total(r, lam, n_val, alpha_val):\n        return u_conf(r) + u_softcore(r, lam, n_val, alpha_val)\n\n    def f_softcore_mag(r, lam, n_val, alpha_val):\n        # Using np.power for r**(n-1) handles r=0 correctly for n>1\n        with np.errstate(divide='ignore', invalid='ignore'):\n            numerator = n_val * np.power(r, n_val - 1)\n            denominator = (alpha_val + np.power(r, n_val))**2\n            force = lam * EPSILON * numerator / denominator\n        # Handle the 0/0 case at r=0 for n=1 (derivative is discontinuous)\n        if n_val == 1 and r == 0:\n             return lam * EPSILON / (alpha_val**2)\n        return np.nan_to_num(force)\n\n\n    for n in test_suite:\n        alpha = A**n\n        \n        bc_values = []\n        rho_values = []\n        max_force_values = []\n\n        # Loop over adjacent lambda pairs\n        for i in range(M - 1):\n            lambda_i = lambda_schedule[i]\n            lambda_i1 = lambda_schedule[i+1]\n            \n            # --- Calculate Probability Densities ---\n            # For lambda_i\n            u_i_grid = u_total(r_grid, lambda_i, n, alpha)\n            u_i_min = np.min(u_i_grid)\n            with np.errstate(divide='ignore'):\n                log_tilde_p_i = np.log(4 * np.pi) + 2 * np.log(r_grid) - BETA * (u_i_grid - u_i_min)\n            # Handle r=0 where log(r) is -inf\n            log_tilde_p_i[0] = -np.inf \n            tilde_p_i = np.exp(log_tilde_p_i)\n            z_i = np.trapz(tilde_p_i, r_grid)\n            p_i = tilde_p_i / z_i if z_i > 0 else np.zeros_like(tilde_p_i)\n\n            # For lambda_i1\n            u_i1_grid = u_total(r_grid, lambda_i1, n, alpha)\n            u_i1_min = np.min(u_i1_grid)\n            with np.errstate(divide='ignore'):\n                log_tilde_p_i1 = np.log(4 * np.pi) + 2 * np.log(r_grid) - BETA * (u_i1_grid - u_i1_min)\n            log_tilde_p_i1[0] = -np.inf\n            tilde_p_i1 = np.exp(log_tilde_p_i1)\n            z_i1 = np.trapz(tilde_p_i1, r_grid)\n            p_i1 = tilde_p_i1 / z_i1 if z_i1 > 0 else np.zeros_like(tilde_p_i1)\n            \n            # --- Calculate Metrics ---\n            \n            # 1. Bhattacharyya Coefficient (BC)\n            integrand_bc = np.sqrt(p_i * p_i1)\n            bc_i = np.trapz(integrand_bc, r_grid)\n            bc_values.append(bc_i)\n        \n            # 2. Relative Effective Sample Size (ESS) fraction (rho)\n            delta_u = u_i1_grid - u_i_grid\n            w = np.exp(-BETA * delta_u)\n            \n            avg_w = np.trapz(w * p_i, r_grid)\n            avg_w2 = np.trapz(w**2 * p_i, r_grid)\n            \n            rho_i = avg_w**2 / avg_w2 if avg_w2 > 0 else 0.0\n            rho_values.append(rho_i)\n            \n            # 3. Maximum Softcore Force in contact region [0, r_c]\n            # Analytical maximum location is used instead of numerical search.\n            # Max over lambda is at lambda_i1. Max over r depends on n.\n            if n == 1:\n                # For n=1, force decreases with r, so max is at r=0.\n                f_max = f_softcore_mag(0.0, lambda_i1, n, alpha)\n                max_force_values.append(f_max)\n            else:\n                # For n>1, force is increasing on [0, r_c] for the given parameters,\n                # so max is at r=r_c.\n                f_max = f_softcore_mag(R_C, lambda_i1, n, alpha)\n                max_force_values.append(f_max)\n\n        # --- Aggregate metrics for this n ---\n        min_bc = np.min(bc_values)\n        min_rho = np.min(rho_values)\n        max_f = np.max(max_force_values)\n        \n        final_results.append([min_bc, min_rho, max_f])\n        \n    # --- Format and Print Final Output ---\n    # Construct the output string exactly as specified.\n    result_strs = []\n    for res in final_results:\n        result_strs.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(result_strs)}]\")\n\nsolve()\n```", "id": "3447341"}]}