{"hands_on_practices": [{"introduction": "在深入研究含时密度泛函理论 (TDDFT) 的复杂数值模拟之前，我们首先需要从第一性原理出发，掌握电子动力学的基本图像。这个练习 [@problem_id:2461440] 将带我们回到量子力学的核心：一个处于定态叠加态的系统如何随时间演化。通过分析一个简单的双能级模型，我们将亲手推导并计算偶极矩的含时振荡行为，从而直观地理解量子相干性是如何驱动超快电子动力学的。这个基础练习是理解 TDDFT 模拟中所有含时可观测量（如吸收光谱）起源的关键。", "problem": "给定一个在含时密度泛函理论（TD-DFT，Time-Dependent Density Functional Theory）中遇到的、无外场的实时动力学的最小双能级表象。考虑一个封闭系统，其仅限于两个 Kohn-Sham (KS) 本征态，即能量为 $E_0$ 的基态 $\\lvert 0 \\rangle$ 和能量为 $E_1$ 的第一激发态 $\\lvert 1 \\rangle$。系统在时间 $t=0$ 时被初始化为一个归一化的叠加态\n$$\\lvert \\psi(0) \\rangle = c_0 \\lvert 0 \\rangle + c_1 e^{i \\phi} \\lvert 1 \\rangle,$$\n其中 $c_0 \\ge 0$，$c_1 \\ge 0$，$c_0^2 + c_1^2 = 1$，相对相位为 $\\phi$。在任何时候都没有外场。假设沿 $x$ 轴的电偶极算符 $\\hat{\\mu}_x$ 在此基组下具有实数矩阵元：$\\mu_{00} = \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 0 \\rangle$，$\\mu_{11} = \\langle 1 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle$ 和 $\\mu_{01} = \\mu_{10} = \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle \\in \\mathbb{R}$。单位：全过程使用原子单位，其中能量单位为哈特里（$E_h$），时间单位为原子单位时间（$\\hbar / E_h$），偶极矩单位为 $e a_0$。角度以弧度表示。\n\n任务：从第一性原理出发，确定在无外场情况下状态 $\\lvert \\psi(t) \\rangle$ 的演化，并计算偶极矩 $x$ 分量的含时期望值，\n$$\\mu_x(t) = \\langle \\psi(t) \\lvert \\hat{\\mu}_x \\rvert \\psi(t) \\rangle,$$\n在以下测试组中每个参数集的指定采样时间点上进行计算。以 $e a_0$ 为单位报告 $\\mu_x(t)$ 的数值，并四舍五入到六位小数。\n\n测试组（所有量均以原子单位给出）：\n- 情况 A（具有非零跃迁偶极矩的一般叠加态）：$E_0 = -0.5$, $E_1 = -0.125$, $c_0 = \\sqrt{0.8}$, $c_1 = \\sqrt{0.2}$, $\\phi = 0.3$, $\\mu_{00} = 0.0$, $\\mu_{11} = 1.0$, $\\mu_{01} = 0.5$, 采样时间 $[0.0,\\,5.0,\\,10.0,\\,15.0]$。\n- 情况 B（边界情况：纯基态，无相干性）：$E_0 = -0.5$, $E_1 = -0.125$, $c_0 = 1.0$, $c_1 = 0.0$, $\\phi = 0.0$, $\\mu_{00} = 0.2$, $\\mu_{11} = 0.8$, $\\mu_{01} = 1.0$, 采样时间 $[0.0,\\,1.0,\\,2.0]$。\n- 情况 C（边界情况：跃迁偶极矩为零，无振荡）：$E_0 = -1.0$, $E_1 = -0.9$, $c_0 = 1/\\sqrt{2}$, $c_1 = 1/\\sqrt{2}$, $\\phi = 0.7$, $\\mu_{00} = -0.3$, $\\mu_{11} = 0.4$, $\\mu_{01} = 0.0$, 采样时间 $[0.0,\\,20.0]$。\n- 情况 D（边缘情况：简并能级，静态相位差）：$E_0 = -0.2$, $E_1 = -0.2$, $c_0 = \\sqrt{0.3}$, $c_1 = \\sqrt{0.7}$, $\\phi = 1.0$, $\\mu_{00} = 0.0$, $\\mu_{11} = 0.0$, $\\mu_{01} = 1.2$, 采样时间 $[0.0,\\,3.0]$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个情况必须按顺序贡献一个包含采样 $\\mu_x(t)$ 值的列表，因此总输出是按 A、B、C、D 顺序排列的包含4个列表的列表。例如，打印的行必须如下所示\n$[ [a_1, a_2, \\dots], [b_1, b_2, \\dots], [c_1, c_2, \\dots], [d_1, d_2, \\dots] ]$\n且行中任何地方都不能有空格。每个数值条目必须按规定四舍五入到六位小数。", "solution": "提交分析的问题陈述具有科学依据，提法明确且客观。它提供了一套完整的参数和条件，足以根据量子力学的基本原理得到唯一解。这是一个关于双能级量子系统时间演化的标准练习。因此，我们着手求解。\n\n问题的核心是确定一个量子态的时间演化，然后计算一个可观测量（observable）的期望值。系统不受任何外场微扰，因此其动力学由不含时薛定谔方程（在原子单位制中，$\\hbar=1$）决定。\n\n首先，我们定义系统的状态。基组由两个 Kohn-Sham 本征态组成，即基态 $\\lvert 0 \\rangle$ 和第一激发态 $\\lvert 1 \\rangle$。根据定义，它们是无场哈密顿算符 $\\hat{H}$ 的本征态：\n$$\n\\hat{H} \\lvert 0 \\rangle = E_0 \\lvert 0 \\rangle\n$$\n$$\n\\hat{H} \\lvert 1 \\rangle = E_1 \\lvert 1 \\rangle\n$$\n其中 $E_0$ 和 $E_1$ 是相应的本征能量。在此基组中，哈密顿算符表示为一个对角矩阵：\n$$\n\\mathbf{H} = \\begin{pmatrix} E_0  0 \\\\ 0  E_1 \\end{pmatrix}\n$$\n系统在时间 $t=0$ 时被初始化为一个叠加态：\n$$\n\\lvert \\psi(0) \\rangle = c_0 \\lvert 0 \\rangle + c_1 e^{i \\phi} \\lvert 1 \\rangle\n$$\n该状态的时间演化可通过应用时间演化算符 $U(t) = e^{-i\\hat{H}t}$ 来求得。由于 $\\lvert 0 \\rangle$ 和 $\\lvert 1 \\rangle$ 是 $\\hat{H}$ 的本征态，所以 $U(t)$ 的作用是直接的：\n$$\n\\lvert \\psi(t) \\rangle = e^{-i\\hat{H}t} \\lvert \\psi(0) \\rangle = e^{-i\\hat{H}t} (c_0 \\lvert 0 \\rangle + c_1 e^{i \\phi} \\lvert 1 \\rangle)\n$$\n$$\n\\lvert \\psi(t) \\rangle = c_0 (e^{-i\\hat{H}t} \\lvert 0 \\rangle) + c_1 e^{i \\phi} (e^{-i\\hat{H}t} \\lvert 1 \\rangle)\n$$\n$$\n\\lvert \\psi(t) \\rangle = c_0 e^{-iE_0t} \\lvert 0 \\rangle + c_1 e^{i \\phi} e^{-iE_1t} \\lvert 1 \\rangle\n$$\n这给出了在任意时间 $t0$ 的状态矢量：\n$$\n\\lvert \\psi(t) \\rangle = c_0 e^{-iE_0t} \\lvert 0 \\rangle + c_1 e^{-i(E_1t - \\phi)} \\lvert 1 \\rangle\n$$\n接下来，我们必须计算偶极算符的含时期望值 $\\mu_x(t) = \\langle \\psi(t) \\lvert \\hat{\\mu}_x \\rvert \\psi(t) \\rangle$。相应的左矢（bra vector）是：\n$$\n\\langle \\psi(t) \\rvert = c_0 e^{iE_0t} \\langle 0 \\rvert + c_1 e^{i(E_1t - \\phi)} \\langle 1 \\rvert\n$$\n我们将 $\\lvert \\psi(t) \\rangle$ 和 $\\langle \\psi(t) \\rvert$ 代入期望值表达式中：\n$$\n\\mu_x(t) = \\left( c_0 e^{iE_0t} \\langle 0 \\rvert + c_1 e^{i(E_1t - \\phi)} \\langle 1 \\rvert \\right) \\hat{\\mu}_x \\left( c_0 e^{-iE_0t} \\lvert 0 \\rangle + c_1 e^{-i(E_1t - \\phi)} \\lvert 1 \\rangle \\right)\n$$\n展开此表达式可得四项。我们使用记号 $\\mu_{ij} = \\langle i \\lvert \\hat{\\mu}_x \\rvert j \\rangle$ 表示偶极算符的矩阵元。\n$$\n\\mu_x(t) = c_0^2 e^{iE_0t} e^{-iE_0t} \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 0 \\rangle + c_0 c_1 e^{iE_0t} e^{-i(E_1t - \\phi)} \\langle 0 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle + c_1 c_0 e^{i(E_1t - \\phi)} e^{-iE_0t} \\langle 1 \\lvert \\hat{\\mu}_x \\rvert 0 \\rangle + c_1^2 e^{i(E_1t - \\phi)} e^{-i(E_1t - \\phi)} \\langle 1 \\lvert \\hat{\\mu}_x \\rvert 1 \\rangle\n$$\n简化指数项并使用偶极矩阵元记号：\n$$\n\\mu_x(t) = c_0^2 \\mu_{00} + c_1^2 \\mu_{11} + c_0 c_1 e^{i(E_0 - E_1)t + i\\phi} \\mu_{01} + c_1 c_0 e^{i(E_1 - E_0)t - i\\phi} \\mu_{10}\n$$\n偶极算符 $\\hat{\\mu}_x$ 是一个可观测量，因此是厄米（Hermitian）的，所以 $\\mu_{10} = \\mu_{01}^*$。题目说明 $\\mu_{01}$ 是实数，因此 $\\mu_{10} = \\mu_{01}$。我们定义跃迁频率 $\\omega_{10} = E_1 - E_0$。表达式变为：\n$$\n\\mu_x(t) = c_0^2 \\mu_{00} + c_1^2 \\mu_{11} + c_0 c_1 \\mu_{01} \\left( e^{-i( \\omega_{10} t - \\phi )} + e^{i( \\omega_{10} t - \\phi )} \\right)\n$$\n使用欧拉恒等式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，我们得到含时偶极矩的最终解析表达式：\n$$\n\\mu_x(t) = c_0^2 \\mu_{00} + c_1^2 \\mu_{11} + 2 c_0 c_1 \\mu_{01} \\cos(\\omega_{10} t - \\phi)\n$$\n该方程表明，偶极矩由一个静态分量和一个动态分量组成。静态分量是基态永久偶极矩的加权平均值，动态分量以对应于两个态之间能量差的频率振荡。此振荡的振幅与系数 $c_0, c_1$ 和跃迁偶极矩 $\\mu_{01}$ 的乘积成正比。如果这三个量（$c_0, c_1, \\mu_{01}$）中的任何一个为零，或者如果态是简并的（$\\omega_{10}=0$），振荡将消失或变为一个静态偏移。\n\n此推导出的公式将应用于每个测试案例，以计算所需的数值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the time-dependent expectation value of the dipole moment\n    for a two-level quantum system based on a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: general superposition with nonzero transition dipole\n        {\n            \"E0\": -0.5, \"E1\": -0.125, \"c0\": np.sqrt(0.8), \"c1\": np.sqrt(0.2), \"phi\": 0.3,\n            \"mu00\": 0.0, \"mu11\": 1.0, \"mu01\": 0.5, \"times\": [0.0, 5.0, 10.0, 15.0]\n        },\n        # Case B: boundary: pure ground state, no coherence\n        {\n            \"E0\": -0.5, \"E1\": -0.125, \"c0\": 1.0, \"c1\": 0.0, \"phi\": 0.0,\n            \"mu00\": 0.2, \"mu11\": 0.8, \"mu01\": 1.0, \"times\": [0.0, 1.0, 2.0]\n        },\n        # Case C: boundary: zero transition dipole, no oscillation\n        {\n            \"E0\": -1.0, \"E1\": -0.9, \"c0\": 1/np.sqrt(2), \"c1\": 1/np.sqrt(2), \"phi\": 0.7,\n            \"mu00\": -0.3, \"mu11\": 0.4, \"mu01\": 0.0, \"times\": [0.0, 20.0]\n        },\n        # Case D: edge: degenerate levels, stationary phase difference\n        {\n            \"E0\": -0.2, \"E1\": -0.2, \"c0\": np.sqrt(0.3), \"c1\": np.sqrt(0.7), \"phi\": 1.0,\n            \"mu00\": 0.0, \"mu11\": 0.0, \"mu01\": 1.2, \"times\": [0.0, 3.0]\n        }\n    ]\n\n    all_results = []\n    \n    # The analytical formula for the time-dependent dipole moment is:\n    # mu_x(t) = c0^2*mu00 + c1^2*mu11 + 2*c0*c1*mu01*cos(omega10*t - phi)\n    # where omega10 = E1 - E0.\n\n    for case in test_cases:\n        E0 = case[\"E0\"]\n        E1 = case[\"E1\"]\n        c0 = case[\"c0\"]\n        c1 = case[\"c1\"]\n        phi = case[\"phi\"]\n        mu00 = case[\"mu00\"]\n        mu11 = case[\"mu11\"]\n        mu01 = case[\"mu01\"]\n        times = case[\"times\"]\n\n        omega10 = E1 - E0\n        \n        # Static part of the dipole moment\n        static_part = c0**2 * mu00 + c1**2 * mu11\n        \n        # Amplitude of the oscillating part\n        osc_amplitude = 2 * c0 * c1 * mu01\n        \n        case_results = []\n        for t in times:\n            # Dynamic part calculation\n            dynamic_part = osc_amplitude * np.cos(omega10 * t - phi)\n            \n            # Total dipole moment at time t\n            mu_t = static_part + dynamic_part\n            \n            # Append rounded result\n            case_results.append(mu_t)\n\n        all_results.append(case_results)\n\n    # Format the final output string as per the requirements:\n    # A list of lists, with no spaces, and numbers rounded to six decimal places.\n    case_strings = []\n    for case_result in all_results:\n        # Format each number to 6 decimal places and join with commas\n        num_strings = [f\"{val:.6f}\" for val in case_result]\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    # Join the case strings into the final output format\n    final_output_str = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2461440"}, {"introduction": "真实的分子过程，如光致电离，涉及电子逃逸到连续谱中，这对在有限空间网格上进行的模拟提出了重大挑战。本次动手实践 [@problem_id:3455965] 将引导你解决这一核心数值问题：如何防止逃逸的电子波包在模拟区域边界发生非物理性反射。我们将学习并实现一种强大的技术，即复吸收势 (Complex Absorbing Potential, CAP)，它通过在边界区域引入一个非厄米势来“吸收”出射的波函数。通过对不同形状和强度的 CAP 进行系统性测试并量化其反射伪影，你将掌握设置和验证开放量子系统 TDDFT 模拟的关键技能。", "problem": "考虑一个在一维实时含时密度泛函理论 (TDDFT) 中，在吸收边界条件下自由传播的单个 Kohn-Sham 轨道的模拟。从原子单位（哈特里原子单位，其中 $\\hbar = 1$，$m = 1$，$e = 1$）下的含时 Kohn-Sham 方程开始：$$ i \\frac{\\partial}{\\partial t} \\psi(x,t) = \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + V(x) + V_{\\text{ext}}(x,t) + V_{\\text{abs}}(x)\\right]\\psi(x,t), $$ 其中 $\\psi(x,t)$ 是 Kohn-Sham 轨道，$V(x)$ 是一个静态势（本问题中设 $V(x) = 0$），$V_{\\text{ext}}(x,t)$ 是一个外部驱动势（本问题中设 $V_{\\text{ext}}(x,t) = 0$），$V_{\\text{abs}}(x)$ 是一个实现吸收边界条件的非厄米吸收势。复吸收势 (CAP) 定义为 $$ V_{\\text{abs}}(x) = -i\\,\\eta\\,f(x), $$ 其中 CAP 强度 $\\eta \\ge 0$，无量纲形状函数 $f(x) \\ge 0$ 仅在区域两端宽度为 $w$ 的边界层内非零。区域为 $x \\in [-L/2, L/2]$，具有固定的狄利克雷边界。电子密度为 $n(x,t) = |\\psi(x,t)|^2$。根据连续性方程，流密度由下式给出：$$ j(x,t) = \\operatorname{Im}\\!\\left(\\psi^*(x,t)\\frac{\\partial \\psi(x,t)}{\\partial x}\\right). $$\n\n你将使用均匀的空间网格和时间步长，为上述方程实现一个时间上二阶稳定的传播格式，并在区域两端 $x = -L/2$ 和 $x = L/2$ 处使用狄利克雷边界条件。吸收边界 $V_{\\text{abs}}(x)$ 必须实现为一个对角算符，其形状 $f(x)$ 和强度 $\\eta$ 可调，并在边界层 $|x|  x_{\\text{cap}}$ 内生效，其中 $x_{\\text{cap}} = L/2 - w$。\n\n将初始 Kohn-Sham 轨道定义为一个具有向右的非零平均动量的高斯波包：$$ \\psi(x,0) = \\left( \\frac{1}{\\pi \\sigma^2} \\right)^{1/4} \\exp\\!\\left( -\\frac{(x - x_0)^2}{2\\sigma^2} \\right)\\exp\\!\\left(i k_0 x\\right), $$ 参数如下文所述。该波包向右传播并与吸收边界相互作用。由于不完全吸收和数值边界条件导致的反射伪影，可以通过比较位于吸收区域内部的一个固定探測点 $x_{\\text{probe}}$ 处的出射流和入射流来量化。\n\n将探測位置处的探測点流函数定义为 $$ j_{\\text{probe}}(t) = j(x_{\\text{probe}},t), $$ 并定义非负的出射和入射时间积分流 $$ J^{+} = \\int_{0}^{T} \\max\\big(j_{\\text{probe}}(t), 0\\big)\\,dt,\\quad J^{-} = \\int_{0}^{T} \\max\\big(-j_{\\text{probe}}(t), 0\\big)\\,dt. $$ 反射伪影度量是一个无量纲比率 $$ R = \\begin{cases} \\dfrac{J^{-}}{J^{+}},  \\text{if } J^{+}  0, \\\\ 0,  \\text{if } J^{+} = 0. \\end{cases} $$ R 值越小，表示吸收效果越好，反射越少。\n\n使用以下固定的数值参数（均为原子单位；无需转换）实现模拟：\n- 空间区域长度：$L = 40.0$。\n- 空间网格点数：$N = 1024$。\n- 空间网格间距：$dx = L/(N-1)$。\n- 时间步长：$dt = 0.005$。\n- 时间步数：$N_t = 2000$（总持续时间 $T = N_t \\cdot dt$）。\n- 初始波包中心：$x_0 = -10.0$。\n- 初始波包宽度：$\\sigma = 2.0$。\n- 初始波包波数：$k_0 = 4.0$。\n- 吸收层宽度：$w = 6.0$，因此 $x_{\\text{cap}} = L/2 - w$。\n- 探測位置：$x_{\\text{probe}} = x_{\\text{cap}} - 2.0$。\n\n对空间离散化的哈密顿量使用二阶精度的隐式 Crank-Nicolson 时间传播格式。在每个时间步，使用中心有限差分近似计算 $\\partial \\psi/\\partial x$ 来计算流密度 $j(x,t)$，并根据上述定义累加 $J^{+}$ 和 $J^{-}$。\n\n在吸收区域 $|x|  x_{\\text{cap}}$ 中，为 CAP 定义形状函数 $f(x)$ 如下：\n- 对于 $|x| \\le x_{\\text{cap}}$，设 $f(x) = 0$。\n- 对于 $|x|  x_{\\text{cap}}$，令 $s(x) = \\dfrac{|x| - x_{\\text{cap}}}{w}$（因此在吸收层中 $s \\in [0,1]$）。需要实现的形状选项如下：\n  1. \"none\"：对所有 $x$，有 $f(x) = 0$。\n  2. \"linear\"：$f(x) = s(x)$。\n  3. \"quadratic\"：$f(x) = s(x)^2$。\n  4. \"step\"：$f(x) = 1$。\n\n对于每个测试用例，传播该系统并计算反射度量 $R$。将最终结果表示为无量纲浮点数。\n\n测试套件：\n对以下五个参数集 $(\\text{shape}, \\eta)$ 运行模拟：\n1. $\\text{shape} = \\text{\"none\"}$, $\\eta = 0.0$。\n2. $\\text{shape} = \\text{\"linear\"}$, $\\eta = 0.2$。\n3. $\\text{shape} = \\text{\"quadratic\"}$, $\\eta = 1.0$。\n4. $\\text{shape} = \\text{\"quadratic\"}$, $\\eta = 3.0$。\n5. $\\text{shape} = \\text{\"step\"}$, $\\eta = 1.0$。\n\n你的程序应产生单行输出，包含一个逗号分隔的列表，用方括号括起来，例如 $\\text{[}R_1,R_2,R_3,R_4,R_5\\text{]}$。值 $R_k$ 是为上述相应测试用例计算的反射度量，顺序完全一致。输出是无量纲的，应打印为浮点数。不涉及角度。因为所有参数都以原子单位指定，所以不需要进行物理单位转换。", "solution": "用户希望解决一个一维含时量子力学问题，以评估不同复吸收势 (CAP) 的有效性。\n\n### **1. 问题验证**\n\n问题陈述已根据指定标准进行了评估。\n\n**步骤 1：提取给定条件**\n\n- **控制方程**：$i \\frac{\\partial}{\\partial t} \\psi(x,t) = \\left[-\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + V(x) + V_{\\text{ext}}(x,t) + V_{\\text{abs}}(x)\\right]\\psi(x,t)$。\n- **势**：$V(x) = 0$, $V_{\\text{ext}}(x,t) = 0$。\n- **复吸收势 (CAP)**：$V_{\\text{abs}}(x) = -i\\,\\eta\\,f(x)$，强度为 $\\eta \\ge 0$。\n- **区域**：$x \\in [-L/2, L/2]$，具有固定狄利克雷边界 ($\\psi(-L/2, t) = \\psi(L/2, t) = 0$)。\n- **CAP 形状函数 $f(x)$**：\n    - 对于 $|x| \\le x_{\\text{cap}}$，$f(x) = 0$。\n    - 对于 $|x|  x_{\\text{cap}}$，其中 $s(x) = \\frac{|x| - x_{\\text{cap}}}{w}$，形状有 \"none\" ($f(x)=0$)、\"linear\" ($f(x)=s(x)$)、\"quadratic\" ($f(x)=s(x)^2$)、\"step\" ($f(x)=1$)。\n- **初始条件**：$\\psi(x,0) = \\left( \\frac{1}{\\pi \\sigma^2} \\right)^{1/4} \\exp\\!\\left( -\\frac{(x - x_0)^2}{2\\sigma^2} \\right)\\exp\\!\\left(i k_0 x\\right)$。\n- **流密度**：$j(x,t) = \\operatorname{Im}\\!\\left(\\psi^*(x,t)\\frac{\\partial \\psi(x,t)}{\\partial x}\\right)$。\n- **反射度量 $R$**：对于 $J^{+}0$，$R = J^{-}/J^{+}$，否则 $R=0$。其中 $J^{+} = \\int_{0}^{T} \\max\\big(j_{\\text{probe}}(t), 0\\big)\\,dt$ 且 $J^{-} = \\int_{0}^{T} \\max\\big(-j_{\\text{probe}}(t), 0\\big)\\,dt$，其中 $j_{\\text{probe}}(t) = j(x_{\\text{probe}},t)$。\n- **数值参数**：\n    - $L = 40.0$\n    - $N = 1024$\n    - $dx = L/(N-1)$\n    - $dt = 0.005$\n    - $N_t = 2000$\n    - $x_0 = -10.0$\n    - $\\sigma = 2.0$\n    - $k_0 = 4.0$\n    - $w = 6.0$\n    - $x_{\\text{cap}} = L/2 - w = 14.0$\n    - $x_{\\text{probe}} = x_{\\text{cap}} - 2.0 = 12.0$\n- **数值方法**：时间传播采用二阶隐式 Crank-Nicolson 方法；空间导数采用中心有限差分法。\n- **测试套件**：\n    1. $(\\text{shape} = \\text{\"none\"}$, $\\eta = 0.0)$\n    2. $(\\text{shape} = \\text{\"linear\"}$, $\\eta = 0.2)$\n    3. $(\\text{shape} = \\text{\"quadratic\"}$, $\\eta = 1.0)$\n    4. $(\\text{shape} = \\text{\"quadratic\"}$, $\\eta = 3.0)$\n    5. $(\\text{shape} = \\text{\"step\"}$, $\\eta = 1.0)$\n\n**步骤 2：使用提取的给定条件进行验证**\n\n- **科学基础**：该问题描述了使用含时薛定谔方程（对于单个无相互作用的电子，Kohn-Sham 方程简化为此方程）模拟量子力学波包。使用复吸收势是计算物理学中模拟开放边界条件的标准且物理上合理的技巧。Crank-Nicolson 方法是解决此类问题的经典、稳定算法。该问题在科学上和数学上都是合理的。\n- **适定性**：提供了所有必要的参数、初始条件、边界条件和定义。问题结构为每个测试用例导向一个唯一、稳定且有意义的数值解。\n- **客观性**：问题以精确、客观的数学和计算术语陈述。没有主观或模棱两可的陈述。\n\n**步骤 3：结论与行动**\n\n问题是有效的。将开发一个解决方案。\n\n### **2. 解决方案推导与算法设计**\n\n该问题需要数值求解带非厄米哈密顿量的一维含时薛定谔方程（TDSE），以模拟吸收过程。\n\n**2.1. 控制方程与离散化**\n在原子单位（$\\hbar=1$, $m_e=1$）下的控制方程为：\n$$ i \\frac{\\partial \\psi(x,t)}{\\partial t} = \\hat{H}\\psi(x,t) $$\n本问题的哈密顿算符 $\\hat{H}$ 为：\n$$ \\hat{H} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} + V_{\\text{abs}}(x) = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2} - i \\eta f(x) $$\n将区域 $x \\in [-L/2, L/2]$ 离散化为包含 $N$ 个点的均匀网格 $x_j = -L/2 + j \\cdot dx$，$j=0, 1, \\dots, N-1$，网格间距为 $dx = L/(N-1)$。波函数 $\\psi(x,t)$ 由其在网格点上的值构成的向量 $\\Psi(t)$ 表示，即 $\\Psi_j(t) = \\psi(x_j, t)$。\n\n空间二阶导数（动能算符）使用二阶中心有限差分公式近似：\n$$ \\left(\\frac{\\partial^2 \\psi}{\\partial x^2}\\right)_{j} \\approx \\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{dx^2} $$\n因此，哈密顿算符 $\\hat{H}$ 由一个 $N \\times N$ 的矩阵 $\\mathbf{H}$ 表示。由于狄利克雷边界条件，对所有 $t$，$\\psi_0(t) = \\psi_{N-1}(t) = 0$。这允许我们求解 $N-2$ 个内部点，从而得到一个有效的 $(N-2) \\times (N-2)$ 三对角哈密顿矩阵 $\\mathbf{H}_{\\text{inner}}$。其元素为：\n- **对角元**：$(\\mathbf{H}_{\\text{inner}})_{j,j} = \\frac{1}{dx^2} - i \\eta f(x_{j+1})$\n- **非对角元**：$(\\mathbf{H}_{\\text{inner}})_{j, j\\pm 1} = -\\frac{1}{2dx^2}$\n\n**2.2. Crank-Nicolson 时间传播**\nTDSE 是状态向量 $\\Psi(t)$ 的一阶常微分方程组：$i \\frac{d\\Psi}{dt} = \\mathbf{H}\\Psi$。我们使用 Crank-Nicolson 方法，它在时间上是二阶精确且无条件稳定的。它通过对时间步长 $[t_n, t_{n+1}]$ 上的哈密顿量进行平均得到：\n$$ i \\frac{\\Psi(t_{n+1}) - \\Psi(t_n)}{dt} = \\frac{1}{2}\\left(\\mathbf{H}\\Psi(t_{n+1}) + \\mathbf{H}\\Psi(t_n)\\right) $$\n整理以求解下一个时间步的状态 $\\Psi(t_{n+1})$，我们得到：\n$$ \\left(\\mathbf{I} + \\frac{i dt}{2} \\mathbf{H}\\right) \\Psi(t_{n+1}) = \\left(\\mathbf{I} - \\frac{i dt}{2} \\mathbf{H}\\right) \\Psi(t_n) $$\n其中 $\\mathbf{I}$ 是单位矩阵。令 $\\mathbf{A} = \\mathbf{I} + \\frac{i dt}{2} \\mathbf{H}$ 和 $\\mathbf{B} = \\mathbf{I} - \\frac{i dt}{2} \\mathbf{H}$。传播步骤为 $\\Psi(t_{n+1}) = \\mathbf{A}^{-1} (\\mathbf{B} \\Psi(t_n))$。由于 $\\mathbf{H}_{\\text{inner}}$ 是三对角的，对应的矩阵 $\\mathbf{A}_{\\text{inner}}$ 和 $\\mathbf{B}_{\\text{inner}}$ 也是三对角的。$\\mathbf{A}_{\\text{inner}}$ 的逆通过求解一个三对角线性方程组来完成，这在计算上是高效的。\n\n**2.3. 初始状态与势的构建**\n初始状态 $\\psi(x,0)$ 是一个高斯波包，在空间网格 $x_j$ 上离散化：\n$$ \\psi(x_j, 0) = \\left( \\frac{1}{\\pi \\sigma^2} \\right)^{1/4} \\exp\\!\\left( -\\frac{(x_j - x_0)^2}{2\\sigma^2} \\right)\\exp\\!\\left(i k_0 x_j\\right) $$\n通过设置 $\\psi_0(0) = \\psi_{N-1}(0) = 0$ 来施加狄利克雷边界条件。\n\nCAP 形状函数 $f(x)$ 基于给定的测试用例在网格上构建。对于吸收层中的网格点 $x_j$（$|x_j|  x_{\\text{cap}}$），计算归一化距离 $s_j = (|x_j| - x_{\\text{cap}})/w$，并用它根据指定的形状（\"linear\"、\"quadratic\" 等）来定义 $f(x_j)$。然后，完整的吸收势为 $V_{\\text{abs}}(x_j) = -i \\eta f(x_j)$。\n\n**2.4. 电流与反射计算**\n在每个时间步 $t_n$，传播波函数得到 $\\psi(x, t_n)$ 后，计算流密度 $j(x,t)$。在探測位置 $x_{\\text{probe}}$ 处的空间导数 $\\partial\\psi/\\partial x$ 通过网格上的中心有限差分来近似。设 $k$ 是使得 $x_k \\approx x_{\\text{probe}}$ 的索引。\n$$ j_{\\text{probe}}(t_n) = \\operatorname{Im}\\!\\left(\\psi_k^*(t_n) \\frac{\\psi_{k+1}(t_n) - \\psi_{k-1}(t_n)}{2dx}\\right) $$\n在总模拟时间 $T=N_t \\cdot dt$ 内，使用黎曼和累加时间积分的出射流 ($J^+$) 和入射流 ($J^-$)：\n$$ J^{+} = \\sum_{n=0}^{N_t-1} \\max(j_{\\text{probe}}(t_n), 0) \\cdot dt $$\n$$ J^{-} = \\sum_{n=0}^{N_t-1} \\max(-j_{\\text{probe}}(t_n), 0) \\cdot dt $$\n最后，反射伪影度量 $R$ 计算为比率 $R = J^{-}/J^{+}$。\n\n**2.5. 算法总结**\n对于每个测试用例 $(\\text{shape}, \\eta)$：\n1.  **设置**：定义数值参数（$L, N, dx, dt, N_t$ 等）。创建空间网格 `x`。\n2.  **初始状态**：在网格上构建初始波函数向量 $\\Psi(0)$ 并施加边界条件。\n3.  **哈密顿量**：基于 $\\eta$ 和 `shape` 构建 CAP 向量 $V_{\\text{abs}}$。\n4.  **Crank-Nicolson 矩阵**：构建 $(N-2) \\times (N-2)$ 三对角矩阵 $\\mathbf{A}_{\\text{inner}}$ 和 $\\mathbf{B}_{\\text{inner}}$ 的对角线。为提高效率，为线性求解器准备 $\\mathbf{A}_{\\text{inner}}$ 的带状表示。\n5.  **时间演化**：\n    a. 初始化 $J^{+} = 0$，$J^{-} = 0$，以及 $\\Psi_{\\text{inner}} = \\Psi(0)[1:-1]$。\n    b. 对 $n$ 从 $0$ 到 $N_t-1$ 进行循环：\n        i.  计算右端向量 $\\mathbf{v} = \\mathbf{B}_{\\text{inner}} \\Psi_{\\text{inner}}(t_n)$。\n        ii. 求解线性系统 $\\mathbf{A}_{\\text{inner}} \\Psi_{\\text{inner}}(t_{n+1}) = \\mathbf{v}$ 以得到 $\\Psi_{\\text{inner}}(t_{n+1})$。\n        iii. 通过用零填充 $\\Psi_{\\text{inner}}(t_{n+1})$ 来重构完整波函数 $\\Psi(t_{n+1})$。\n        iv. 在探測索引处计算 $j_{\\text{probe}}(t_{n+1})$。\n        v.  更新积分流 $J^{+}$ 和 $J^{-}$。\n6.  **结果**：计算反射度量 $R = J^{-}/J^{+}$。\n最终输出是所有测试用例计算出的 $R$ 值的列表。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-dependent Schrödinger equation with complex absorbing potentials\n    and computes the reflection metric for different potential shapes and strengths.\n    \"\"\"\n\n    # Fixed numerical parameters (all in atomic units)\n    L = 40.0\n    N = 1024\n    dt = 0.005\n    Nt = 2000\n    x0 = -10.0\n    sigma = 2.0\n    k0 = 4.0\n    w = 6.0\n    x_cap = L / 2.0 - w\n    x_probe = x_cap - 2.0\n\n    # Spatial grid\n    x = np.linspace(-L / 2.0, L / 2.0, N)\n    dx = x[1] - x[0]\n    \n    # Memoize matrix construction\n    memoized_matrices = {}\n\n    def get_crank_nicolson_matrices(eta, shape):\n        \"\"\"\n        Constructs and returns the Crank-Nicolson propagation matrices A and B.\n        Uses memoization to avoid redundant calculations.\n        \"\"\"\n        if (eta, shape) in memoized_matrices:\n            return memoized_matrices[(eta, shape)]\n\n        # --- Construct Complex Absorbing Potential (CAP) ---\n        f_x = np.zeros(N)\n        abs_x = np.abs(x)\n        in_cap_region = abs_x > x_cap\n        \n        s = (abs_x[in_cap_region] - x_cap) / w\n        \n        if shape == \"linear\":\n            f_x[in_cap_region] = s\n        elif shape == \"quadratic\":\n            f_x[in_cap_region] = s**2\n        elif shape == \"step\":\n            f_x[in_cap_region] = 1.0\n        # \"none\" shape corresponds to f_x = 0, which is the default\n        \n        V_abs = -1j * eta * f_x\n        \n        # --- Construct Hamiltonian for interior points (N-2 x N-2) ---\n        M = N - 2\n        \n        # Kinetic part\n        H_kin_diag = 1.0 / dx**2\n        H_kin_offdiag = -1.0 / (2.0 * dx**2)\n        \n        # Full Hamiltonian diagonals\n        H_diag = H_kin_diag + V_abs[1:-1]\n        \n        # --- Construct Crank-Nicolson matrices A and B for interior points ---\n        c = 0.5j * dt\n        \n        # Matrix A = I + c*H\n        A_diag = 1.0 + c * H_diag\n        A_offdiag_val = c * H_kin_offdiag\n        \n        # Matrix B = I - c*H\n        B_diag = 1.0 - c * H_diag\n        B_offdiag_val = -c * H_kin_offdiag\n\n        # Create banded representation of A for scipy's solver\n        # ab is a (3, M) array for a tridiagonal matrix\n        ab_A = np.zeros((3, M), dtype=np.complex128)\n        ab_A[0, 1:] = A_offdiag_val\n        ab_A[1, :] = A_diag\n        ab_A[2, :-1] = A_offdiag_val\n        \n        # Store B's diagonals for efficient matrix-vector product\n        B_matrix_diags = (B_diag, B_offdiag_val)\n        \n        result = (ab_A, B_matrix_diags)\n        memoized_matrices[(eta, shape)] = result\n        return result\n\n\n    # Test Suite\n    test_cases = [\n        {\"shape\": \"none\", \"eta\": 0.0},\n        {\"shape\": \"linear\", \"eta\": 0.2},\n        {\"shape\": \"quadratic\", \"eta\": 1.0},\n        {\"shape\": \"quadratic\", \"eta\": 3.0},\n        {\"shape\": \"step\", \"eta\": 1.0},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        shape = case[\"shape\"]\n        eta = case[\"eta\"]\n\n        # --- Initial Wave Packet ---\n        norm_factor = (1.0 / (np.pi * sigma**2))**0.25\n        psi_t0 = norm_factor * np.exp(-(x - x0)**2 / (2.0 * sigma**2)) * np.exp(1j * k0 * x)\n        psi_t0 = psi_t0.astype(np.complex128)\n        \n        # Enforce Dirichlet boundary conditions\n        psi_t0[0] = 0.0\n        psi_t0[-1] = 0.0\n        \n        # We only propagate the interior points\n        psi_inner = psi_t0[1:-1]\n        M = N - 2\n\n        # --- Get CN matrices ---\n        ab_A, (B_diag, B_offdiag_val) = get_crank_nicolson_matrices(eta, shape)\n        \n        # --- Find Probe Index ---\n        probe_idx = np.argmin(np.abs(x - x_probe))\n\n        # --- Time Propagation Loop ---\n        J_plus = 0.0\n        J_minus = 0.0\n\n        for _ in range(Nt):\n            # Calculate RHS: rhs = B @ psi_inner\n            rhs = B_diag * psi_inner\n            rhs[:-1] += B_offdiag_val * psi_inner[1:]\n            rhs[1:] += B_offdiag_val * psi_inner[:-1]\n            \n            # Solve for next time step: A @ psi_new = rhs\n            psi_inner = scipy.linalg.solve_banded((1, 1), ab_A, rhs)\n\n            # --- Calculate Current Density at Probe ---\n            # Reconstruct full psi vector to handle boundaries in derivative\n            psi_full = np.zeros(N, dtype=np.complex128)\n            psi_full[1:-1] = psi_inner\n            \n            # Central finite difference for a_psi/a_x\n            dpsi_dx = (psi_full[probe_idx + 1] - psi_full[probe_idx - 1]) / (2.0 * dx)\n            \n            # j = Im(psi* * dpsi/dx)\n            j_probe = np.imag(np.conj(psi_full[probe_idx]) * dpsi_dx)\n\n            # Accumulate integrated currents\n            J_plus += max(j_probe, 0.0) * dt\n            J_minus += max(-j_probe, 0.0) * dt\n\n        # --- Calculate Reflection Metric R ---\n        if J_plus > 0:\n            R = J_minus / J_plus\n        else:\n            R = 0.0\n        \n        results.append(R)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3455965"}, {"introduction": "实时 TDDFT 模拟的原始输出是体系随时间演化的偶极矩，但我们通常更关心的是频域中的吸收光谱。这最后一步的转换——从时域到频域——并非没有陷阱。本次实践 [@problem_id:3497345] 聚焦于这一关键的数据后处理步骤，探讨由有限的模拟时长导致的数值伪影，即“谱泄漏”。你将通过实现一个合成信号模型，系统地比较不同窗函数和零填充技术在抑制谱泄漏和提高光谱分辨率方面的效果。掌握这些信号处理技术对于从 TDDFT 模拟中准确提取激子能量和振子强度至关重要。", "problem": "要求您设计并实现一个程序，用以量化在实时含时密度泛函理论 (TDDFT) 中产生的瞬时偶极矩信号的傅里叶变换中的频谱泄漏。在实时 TDDFT 中，一个弱脉冲微扰 (delta-kick) 会产生一个偶极响应，其线性范围可以建模为一个指数衰减的正弦波。有限的观测时间、离散化以及窗函数的选择，会将一个狭窄的激子谱线的能量泄漏到邻近的频率中。您的任务是量化这种泄漏，并比较窗函数 $w(t)$ 与补零的效果。\n\n从以下基本依据出发：\n- 密度泛函理论 (DFT) 的 Kohn-Sham 方程描述了电子动力学，在含时密度泛函理论 (TDDFT) 的线性响应机制下，当信号主要由单个激子共振主导时，感生偶极矩信号可以建模为一个指数衰减的正弦波。\n- 偶极矩 $d(t)$ 在有限时间 $T$ 内以均匀的时间步长进行采样。\n- 在时域中将 $d(t)$ 乘以一个窗函数 $w(t)$ 对应于在频域中的一次卷积，这可以减少旁瓣，但代价是主瓣会变宽。\n- 对时域信号进行补零会增加离散频率网格的密度，但不会改变潜在的频谱泄漏；它能改善谱的插值效果。\n\n将合成偶极信号定义为\n$d(t) = A \\exp(-\\gamma t) \\sin(\\omega_0 t)$\n对于 $t \\ge 0$ 直至总观测时间 $T$，其中 $A$ 是振幅，$\\gamma$ 是衰减率，$\\omega_0$ 是单个窄激子共振的角频率。该信号代表了偶极子对一个非常弱的 delta-kick 的线性响应。您将比较不同的窗函数 $w(t)$ 和不同的补零因子。\n\n频谱泄漏分数 $L$ 必须按如下方式定义。计算加窗和补零后偶极矩的离散傅里叶变换，并获得单边正角频率谱。在 $\\omega_0$ 周围定义一个对称的主带宽度 $B$，为 $B = \\alpha \\gamma$，其中 $\\alpha = 3$。令 $S(\\omega)$ 为与傅里叶变换的幅度平方成正比的非负功率谱。泄漏分数 $L$ 是位于区间 $[\\omega_0 - B, \\omega_0 + B]$ 之外的总功率与所有正角频率的总功率之比。这个 $L$ 是一个在 $[0,1]$ 区间内的无量纲小数。\n\n您必须：\n- 使用固定的 $A = 1$ 以及指定的 $N$ 和 $\\Delta t$（见下面的测试套件）来构建 $d(t)$，因此 $T = N \\Delta t$。\n- 应用每个指定的窗函数 $w(t)$，然后在计算离散傅里叶变换之前，用一个整数因子 $p$ 对加窗后的信号进行补零。\n- 使用正角频率（单位为弧度/飞秒）上的单边谱，按定义计算 $L$，并返回所有测试用例的泄漏分数。\n\n所有角度必须以弧度处理，角频率必须以弧度/飞秒为单位。时间步长必须以飞秒为单位。最终输出必须是单行文本，包含一个用方括号括起来的逗号分隔列表形式的结果。\n\n实现以下测试套件。使用 $N = 32768$ 个样本和 $\\Delta t = 10^{-3}$ 飞秒的时间步长，因此 $T = 32.768$ 飞秒。定义基础角频率网格间距 $\\Delta \\omega = 2\\pi / T$。对于给定的整数索引 $k$ 和偏移量 $\\delta \\in [0,1)$，设置 $\\omega_0 = (k + \\delta)\\Delta \\omega$。\n\n将五个测试用例指定为元组 $(\\text{window}, p, k, \\delta, \\gamma)$:\n\n1. $(\\text{\"hann\"}, 4, 1000, 0.37, 0.01)$\n2. $(\\text{\"rect\"}, 1, 1000, 0.00, 0.01)$\n3. $(\\text{\"blackman\"}, 16, 1000, 0.37, 0.001)$\n4. $(\\text{\"rect\"}, 16, 1000, 0.37, 0.01)$\n5. $(\\text{\"hann\"}, 1, 1000, 0.00, 0.001)$\n\n在每种情况下：\n- 使用指定的 $\\omega_0$ 和 $\\gamma$，以及上面定义的 $A=1$、$N$ 和 $\\Delta t$ 来构建 $d(t)$。\n- 选择 $w(t)$ 为指定的窗口类型：矩形窗 (\"rect\")、汉宁窗 (\"hann\") 或布莱克曼窗 (\"blackman\")，使用它们在信号处理中的标准定义。\n- 在计算离散傅里叶变换之前，按因子 $p$ 进行补零。\n- 如上定义计算泄漏分数 $L$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[0.12345,0.23456,0.34567]”），顺序与上述测试用例相同。每个元素必须是浮点数。不应打印其他任何文本。", "solution": "该问题是有效的。它在科学上基于含时密度泛函理论 (TDDFT) 和数字信号处理的既定原理。该问题是适定的，所有必要的参数、方程和定义都已提供，可以为每个测试用例计算出唯一且可验证的数值结果。\n\n目标是量化一个合成的实时 TDDFT 偶极信号中的频谱泄漏。该信号代表了对单个电子激发附近的 delta-kick 微扰的响应，被建模为一个指数衰减的正弦波。我们的任务是在各种信号处理条件下计算泄漏分数 $L$：不同的窗函数、补零因子，以及信号频率相对于离散傅里叶变换 (DFT) 频点的在格或离格情况。\n\n算法流程如下：\n\n1.  **信号生成**：\n    在离散时间点 $t_n = n \\Delta t$（其中 $n = 0, 1, \\dots, N-1$）上合成离散时域偶极信号 $d[n]$。控制方程为：\n    $$d[n] = A \\exp(-\\gamma t_n) \\sin(\\omega_0 t_n)$$\n    参数指定为：振幅 $A=1$，样本数 $N=32768$，时间步长 $\\Delta t = 10^{-3} \\, \\text{fs}$。这定义了总观测时间为 $T = N \\Delta t = 32.768 \\, \\text{fs}$。共振的角频率 $\\omega_0$ 和衰减率 $\\gamma$ 对每个测试用例都已给出。频率 $\\omega_0$ 是相对于时间序列的基本频率分辨率 $\\Delta \\omega = \\frac{2\\pi}{T}$ 定义的：\n    $$\\omega_0 = (k + \\delta) \\Delta \\omega$$\n    其中 $k$ 和 $\\delta$ 分别是特定于用例的整数和小数部分。\n\n2.  **加窗**：\n    为了减轻因信号在时间 $T$ 处突然截断而引起的频谱泄漏，将信号 $d[n]$ 乘以一个长度为 $N$ 的窗函数 $w[n]$。加窗后的信号为 $d_w[n] = d[n] \\cdot w[n]$。我们将实现三种标准的窗函数：\n    -   **矩形窗 (`rect`)**: $w[n] = 1$，对于 $n = 0, \\dots, N-1$。这等同于不加窗。\n    -   **汉宁窗 (`hann`)**: $w[n] = 0.5 \\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$，对于 $n = 0, \\dots, N-1$。\n    -   **布莱克曼窗 (`blackman`)**: $w[n] = 0.42 - 0.5 \\cos\\left(\\frac{2\\pi n}{N-1}\\right) + 0.08 \\cos\\left(\\frac{4\\pi n}{N-1}\\right)$，对于 $n = 0, \\dots, N-1$。\n\n3.  **补零与离散傅里叶变换 (DFT)**：\n    加窗后的信号 $d_w[n]$ 按因子 $p$ 进行补零。这意味着追加零直到总信号长度达到 $N_{\\text{pad}} = p \\times N$。然后计算这个补零后信号的 DFT，通常使用快速傅里叶变换 (FFT) 算法。令得到的复数 DFT 系数为 $D[m]$，其中 $m = 0, \\dots, N_{\\text{pad}}-1$。补零不会向信号中添加新信息，但会增加频谱的采样密度，从而提供一个对连续傅里叶变换更好的插值视图。变换的离散角频率由下式给出：\n    $$\\omega'_m = m \\frac{2\\pi}{N_{\\text{pad}} \\Delta t} = m \\frac{2\\pi}{p T} = m \\frac{\\Delta \\omega}{p}$$\n\n4.  **功率谱计算**：\n    功率谱 $S[m]$ 与 DFT 系数的幅度平方成正比，$S[m] = |D[m]|^2$。由于输入信号是实数，我们可以使用 `rfft` 算法，该算法能高效地仅计算非负频率的变换。我们将此“单边”功率谱表示为 $S_{\\text{one-sided}}$。\n\n5.  **泄漏分数计算**：\n    频谱泄漏分数 $L$ 计算为指定主带之外的功率与仅考虑正频率的总功率之比。\n    -   主带定义为区间 $[\\omega_0 - B, \\omega_0 + B]$，其中带宽参数 $B$ 由 $B = \\alpha \\gamma$ 给出，且 $\\alpha = 3$。\n    -   正频率的总功率 $P_{\\text{total}}$ 是所有频谱分量之和，不包括 $\\omega=0$ 处的直流分量：\n    $$P_{\\text{total}} = \\sum_{m \\text{ s.t. } \\omega'_m  0} S[m]$$\n    -   主带内的功率 $P_{\\text{band}}$ 是其频率落在区间 $[\\omega_0 - B, \\omega_0 + B]$ 内的频谱分量之和。我们还必须确保如果频带恰好包含 $\\omega=0$，则不计入直流分量：\n    $$P_{\\text{band}} = \\sum_{m \\text{ s.t. } \\omega_0 - B \\le \\omega'_m \\le \\omega_0 + B \\text{ and } \\omega'_m0} S[m]$$\n    -   泄漏分数 $L$ 于是为：\n    $$L = \\frac{P_{\\text{total}} - P_{\\text{band}}}{P_{\\text{total}}} = 1 - \\frac{P_{\\text{band}}}{P_{\\text{total}}}$$\n    对所提供的五个测试用例中的每一个都执行此计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spectral leakage problem for the given test cases.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    N = 32768\n    dt = 1e-3\n    A = 1.0\n    alpha = 3.0\n\n    # Define the five test cases as tuples: (window, p, k, delta, gamma)\n    test_cases = [\n        (\"hann\", 4, 1000, 0.37, 0.01),\n        (\"rect\", 1, 1000, 0.00, 0.01),\n        (\"blackman\", 16, 1000, 0.37, 0.001),\n        (\"rect\", 16, 1000, 0.37, 0.01),\n        (\"hann\", 1, 1000, 0.00, 0.001),\n    ]\n\n    results = []\n\n    # Process each test case\n    for window_type, p, k, delta, gamma in test_cases:\n        # 1. Calculate derived parameters\n        T = N * dt\n        d_omega = 2 * np.pi / T\n        omega0 = (k + delta) * d_omega\n\n        # 2. Generate the synthetic dipole signal\n        t = np.arange(N) * dt\n        signal = A * np.exp(-gamma * t) * np.sin(omega0 * t)\n\n        # 3. Apply the specified window function\n        if window_type == \"hann\":\n            window = np.hanning(N)\n        elif window_type == \"blackman\":\n            window = np.blackman(N)\n        elif window_type == \"rect\":\n            window = np.ones(N)\n        else:\n            # This case should not be reached with the given test suite\n            raise ValueError(f\"Unknown window type: {window_type}\")\n            \n        windowed_signal = signal * window\n\n        # 4. Zero-pad and compute the DFT and power spectrum\n        N_pad = p * N\n        \n        # Use rfft for real-valued input signals for efficiency\n        dft_coeffs = np.fft.rfft(windowed_signal, n=N_pad)\n        power_spectrum = np.abs(dft_coeffs)**2\n\n        # 5. Get the corresponding angular frequency grid\n        # rfftfreq returns frequency in cycles/unit_time; convert to angular freq.\n        freq_grid_hz = np.fft.rfftfreq(N_pad, d=dt)\n        omega_grid = 2 * np.pi * freq_grid_hz\n\n        # 6. Compute the leakage fraction L\n        # Define the main band\n        B = alpha * gamma\n        omega_min = omega0 - B\n        omega_max = omega0 + B\n\n        # Total power for positive frequencies (excluding DC component at index 0)\n        P_total = np.sum(power_spectrum[1:])\n\n        # Find power within the main band\n        # Create a boolean mask for frequencies inside the band\n        band_mask = (omega_grid >= omega_min)  (omega_grid = omega_max)\n        \n        # Explicitly exclude the DC component from the band sum,\n        # as per definition of studying leakage for positive frequencies.\n        band_mask[0] = False\n        \n        P_band = np.sum(power_spectrum[band_mask])\n        \n        # Calculate the leakage fraction\n        if P_total > 0:\n            leakage_fraction = (P_total - P_band) / P_total\n        else:\n            leakage_fraction = 0.0\n            \n        results.append(leakage_fraction)\n\n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3497345"}]}