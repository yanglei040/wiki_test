{"hands_on_practices": [{"introduction": "平均力势 (Potential of Mean Force, PMF) 是粗粒化坐标感受到的有效能量景观，是连接微观细节和宏观行为的桥梁。本练习 [@problem_id:3399951] 通过一个最简单的理想系统——一维谐振子二聚体——来解析地推导其质心的平均力势。理解这种在没有外场时平坦的PMF基线情况，对于我们构建更复杂系统中非平凡有效势的直觉至关重要。", "problem": "考虑一个一维双原子分子，由两个原子组成，其在实轴上的位置分别为 $x_1$ 和 $x_2$。分子内势能是谐振的，由 $U(x_1,x_2)=\\tfrac{k}{2}\\left(x_2-x_1-\\ell\\right)^2$ 给出，其中 $k>0$ 是弹簧常数，$\\ell>0$ 是平衡键长。将粗粒化坐标定义为算术平均值 $R=\\left(x_1+x_2\\right)/2$。假设系统处于温度为 $T$ 的正则系综中，逆温度为 $\\beta=1/\\left(k_B T\\right)$，其中 $k_B$ 是玻尔兹曼常数，并假设除了 $R$ 的定义外，没有其他外场或约束。通过使用构型分布来忽略动量。\n\n从正则系综的第一性原理和平均力势 (PMF) 的定义出发，即使用与 $\\exp\\left(-\\beta U\\right)$ 成正比的构型概率密度和获得 $R$ 分布所需的边缘化过程，解析地对内坐标进行积分，以获得平均力势 $U_{\\text{PMF}}(R)$（可相差一个加性常数）。将你的最终答案表示为 $R$ 的显式函数，并且你可以将该加性常数设置为零。你的最终答案必须是单一的解析表达式。不要四舍五入。最终表达式不需要单位。", "solution": "在尝试解答之前，对问题进行验证。\n\n### 第1步：提取已知条件\n-   系统：一个一维双原子分子，两个原子的位置分别为 $x_1$ 和 $x_2$。\n-   分子内势能：$U(x_1,x_2)=\\frac{k}{2}\\left(x_2-x_1-\\ell\\right)^2$。\n-   常数：弹簧常数 $k>0$，平衡键长 $\\ell>0$。\n-   粗粒化坐标：$R=\\frac{x_1+x_2}{2}$。\n-   热力学系综：温度为 $T$ 的正则系综。\n-   逆温度：$\\beta=\\frac{1}{k_B T}$，其中 $k_B$ 是玻尔兹曼常数。\n-   假设：除了 $R$ 的定义外，没有其他外场或约束。忽略动量（构型分布）。\n-   任务：通过解析地对内坐标进行积分，推导出平均力势 $U_{\\text{PMF}}(R)$。最终结果应表示为一个可相差一个加性常数的形式，该常数可设置为零。\n\n### 第2步：使用提取的已知条件进行验证\n-   **科学依据**：该问题是统计力学中的一个标准练习，涉及正则系综、玻尔兹曼分布、粗粒化和平均力势等基本概念。谐振双原子分子模型是分子物理学的基石。所有涉及的原理都是公认的。\n-   **问题明确**：问题定义清晰，包含所有必要组成部分：系统、其势能、粗粒化变量和统计系综。通过边缘化求平均力势的要求是一个标准的、可解的过程。存在唯一的解（可相差一个加性常数）。\n-   **客观性**：问题使用精确、无歧义的数学和物理术语进行陈述。\n\n### 第3步：结论与行动\n-   **结论**：问题有效。它在科学上是合理的、问题是明确的且客观的。\n-   **行动**：继续解答。\n\n对于粗粒化坐标 $R$ 的平均力势 $U_{\\text{PMF}}(R)$，是通过该坐标的边缘概率密度 $P(R)$ 定义的：\n$$P(R) = C \\exp(-\\beta U_{\\text{PMF}}(R))$$\n其中 $C$ 是一个归一化常数，$\\beta = \\frac{1}{k_B T}$ 是逆温度。\n\n边缘概率密度 $P(R)$ 是通过对完整的构型概率密度 $P(x_1, x_2)$ 在所有与给定粗粒化坐标 $R$ 值一致的微观自由度（$x_1$ 和 $x_2$）上积分得到的。完整的概率密度与玻尔兹曼因子成正比，$P(x_1, x_2) \\propto \\exp(-\\beta U(x_1, x_2))$。\n\n我们可以将 $P(R)$ 写成：\n$$P(R) \\propto \\int_{-\\infty}^{\\infty} dx_1 \\int_{-\\infty}^{\\infty} dx_2 \\, \\delta\\left(R - \\frac{x_1 + x_2}{2}\\right) \\exp\\left(-\\beta U(x_1, x_2)\\right)$$\n其中 $\\delta(\\cdot)$ 是施加约束的狄拉克δ函数。势能由 $U(x_1,x_2)=\\frac{k}{2}\\left(x_2-x_1-\\ell\\right)^2$ 给出。\n\n为了计算该积分，方便的做法是从微观坐标 $(x_1, x_2)$ 进行变量替换，换成一个包含粗粒化变量 $R$ 的新坐标系。第二个坐标的自然选择是内部分离距离 $r = x_2 - x_1$。\n变换如下：\n$$R = \\frac{x_1 + x_2}{2}$$\n$$r = x_2 - x_1$$\n逆变换将 $x_1$ 和 $x_2$ 表示为 $R$ 和 $r$ 的函数：\n$$x_1 = R - \\frac{r}{2}$$\n$$x_2 = R + \\frac{r}{2}$$\n该变换的雅可比行列式是：\n$$J = \\det \\begin{pmatrix} \\frac{\\partial x_1}{\\partial R} & \\frac{\\partial x_1}{\\partial r} \\\\ \\frac{\\partial x_2}{\\partial R} & \\frac{\\partial x_2}{\\partial r} \\end{pmatrix} = \\det \\begin{pmatrix} 1 & -\\frac{1}{2} \\\\ 1 & \\frac{1}{2} \\end{pmatrix} = (1)\\left(\\frac{1}{2}\\right) - \\left(-\\frac{1}{2}\\right)(1) = \\frac{1}{2} + \\frac{1}{2} = 1$$\n微分体积元变换为 $dx_1 dx_2 = |J| dR dr = dR dr$。\n\n新坐标系下的联合概率密度 $P(R, r)$ 与用这些坐标表示的玻尔兹曼因子成正比。势能变为：\n$$U(x_1, x_2) = \\frac{k}{2}\\left((x_2-x_1) - \\ell\\right)^2 = \\frac{k}{2}(r - \\ell)^2$$\n至关重要的是，势能 $U$ 仅依赖于内坐标 $r$，而与粗粒化坐标 $R$ 无关。这是势能具有平移不变性的直接结果。\n\n边缘概率密度 $P(R)$ 是通过对联合密度 $P(R, r)$ 在内坐标 $r$ 上积分得到的。坐标 $r = x_2 - x_1$ 的取值范围是从 $-\\infty$ 到 $\\infty$。\n$$P(R) = \\int_{-\\infty}^{\\infty} P(R, r) dr \\propto \\int_{-\\infty}^{\\infty} \\exp(-\\beta U(r)) dr$$\n代入势能的表达式：\n$$P(R) \\propto \\int_{-\\infty}^{\\infty} \\exp\\left(-\\beta \\frac{k}{2}(r - \\ell)^2\\right) dr$$\n右侧的积分是一个标准的高斯积分。积分变量是 $r$，被积函数不依赖于 $R$。积分限是常数。因此，这个定积分的值是一个常数，与 $R$ 无关。\n\n为了完整起见，我们来计算这个积分。令 $u = r - \\ell$，则 $du = dr$。$u$ 的积分限也是从 $-\\infty$ 到 $\\infty$。\n$$\\int_{-\\infty}^{\\infty} \\exp\\left(-\\beta \\frac{k}{2}(r - \\ell)^2\\right) dr = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\beta \\frac{k}{2} u^2\\right) du$$\n使用高斯积分公式 $\\int_{-\\infty}^{\\infty} \\exp(-ax^2) dx = \\sqrt{\\frac{\\pi}{a}}$，其中 $a = \\frac{\\beta k}{2}$：\n$$\\int_{-\\infty}^{\\infty} \\exp\\left(-\\beta \\frac{k}{2} u^2\\right) du = \\sqrt{\\frac{\\pi}{\\frac{\\beta k}{2}}} = \\sqrt{\\frac{2\\pi}{\\beta k}}$$\n如上所示，该积分的计算结果是一个常数。因此，边缘概率密度 $P(R)$ 是一个常数：\n$$P(R) = \\text{常数}$$\n这表明质心 $R$ 在任何位置被发现的概率都是相等的，这对于一个没有外势的系统是符合预期的。\n\n现在，我们将其与平均力势联系起来：\n$$\\exp(-\\beta U_{\\text{PMF}}(R)) \\propto P(R) = \\text{常数}$$\n对两边取自然对数：\n$$-\\beta U_{\\text{PMF}}(R) = \\ln(\\text{常数}) = \\text{另一个常数}$$\n因此，平均力势本身也是一个常数：\n$$U_{\\text{PMF}}(R) = -\\frac{1}{\\beta} (\\text{另一个常数}) = \\text{又一个常数}$$\n问题说明我们可以定义 PMF 时相差一个任意的加性常数，并且我们可以将此常数设置为零。\n因此，我们得出结论：\n$$U_{\\text{PMF}}(R) = 0$$", "answer": "$$\\boxed{0}$$", "id": "3399951"}, {"introduction": "从理论转向实践，力匹配方法将势能参数化问题转化为一个数据驱动的回归任务。该方法的核心在于将复杂的微观力信息映射到粗粒化模型的参数上。本练习 [@problem_id:3399938] 将引导你亲手构建此回归问题的关键组成部分——设计矩阵 $A$ 和目标力向量 $b$，让你深入理解如何将一个物理模型（势能是基函数的线性组合）转化为一个可解的线性代数系统。", "problem": "您将处理一个自底向上的粗粒化任务，该任务被构建为分子动力学（MD）中的一个线性力匹配问题。其基本原理是，对于守恒的粗粒化力，粗粒化坐标 $R \\in \\mathbb{R}^D$ 上的力是势能 $U_{\\theta}(R)$ 的负梯度，该势能被建模为一组基函数 $\\{B_k(R)\\}_{k=1}^K$ 的线性展开，即 $U_{\\theta}(R) = \\sum_{k=1}^K \\theta_k B_k(R)$。因此，力为 $F_{\\theta}(R) = -\\nabla_R U_{\\theta}(R) = -\\sum_{k=1}^K \\theta_k \\nabla_R B_k(R)$。在力匹配中，我们使用细粒度坐标 $r_n$ 处的细粒度力 $f(r_n) \\in \\mathbb{R}^{d_{\\mathrm{fg}}}$，以及一个线性映射 $\\Xi \\in \\mathbb{R}^{D \\times d_{\\mathrm{fg}}}$ 来获得粗粒化目标力 $b_n = \\Xi f(r_n) \\in \\mathbb{R}^D$。最小二乘问题是找到 $\\theta \\in \\mathbb{R}^K$ 以最小化 $\\sum_{n=1}^N \\|F_{\\theta}(R_n) - b_n\\|_2^2$。这可以简化为一个线性系统 $A \\theta \\approx b$，其设计矩阵 $A \\in \\mathbb{R}^{(N D) \\times K}$ 是通过堆叠在样本 $\\{R_n\\}_{n=1}^N$ 处求值的基函数的负梯度而构建的。\n\n您的任务是实现一个程序，为每个提供的测试用例，构建设计矩阵的元素 $A_{(n,d),k} = \\left(-\\nabla_R B_k(R_n)\\right)_d$（对于每个样本索引 $n \\in \\{1,\\dots,N\\}$ 和分量 $d \\in \\{1,\\dots,D\\}$），构建目标 $b_{(n,d)} = \\left(\\Xi f(r_n)\\right)_d$，求解线性最小二乘问题以得到 $\\theta$，并报告这些系数。角度必须以弧度解释。所有量纲均为无量纲。程序必须在二维空间 $D = 2$ 中使用以下基函数，其中 $R = (x,y)$:\n- $B_1(R) = \\tfrac{1}{2} \\left(x^2 + y^2\\right)$,\n- $B_2(R) = x y$,\n- $B_3(R) = \\sin(x)$,\n- $B_4(R) = \\cos(y)$.\n对于这些基函数，用于设计矩阵的负梯度为：\n- $-\\nabla_R B_1(R) = \\left(-x, -y\\right)$,\n- $-\\nabla_R B_2(R) = \\left(-y, -x\\right)$,\n- $-\\nabla_R B_3(R) = \\left(-\\cos(x), 0\\right)$,\n- $-\\nabla_R B_4(R) = \\left(0, \\sin(y)\\right)$.\n在 $A$ 中堆叠行，在 $b$ 中堆叠元素时，应遵循样本主序、分量次序，即对于 $n = 1, \\dots, N$，首先堆叠 $x$ 分量行，然后堆叠 $y$ 分量行。\n\n使用欧几里得范数下的线性最小二乘法求解 $\\theta$。如果 $A$ 是秩亏的，则返回最小范数最小二乘解。对于每个测试用例，返回向量 $\\theta \\in \\mathbb{R}^4$，四舍五入到六位小数。\n\n测试套件：\n- 测试用例 1（理想情况，单位映射）：\n  - $N = 3$, $D = 2$, $K = 4$, $d_{\\mathrm{fg}} = 2$.\n  - $R_1 = (0.0, 0.0)$, $R_2 = (1.0, 0.5)$, $R_3 = (-0.5, 1.0)$.\n  - $r_1 = (0.0, 0.0)$, $r_2 = (1.0, 0.5)$, $r_3 = (-0.5, 1.0)$.\n  - $\\Xi = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 1.0 \\end{bmatrix}$.\n  - $f(r_1) = (-0.5, 0.0)$; $f(r_2) = (-1.770151153, -0.119856385)$; $f(r_3) = (1.561208719, -2.710367746)$.\n- 测试用例 2（边界情况，近奇异设计，单位映射）：\n  - $N = 2$, $D = 2$, $K = 4$, $d_{\\mathrm{fg}} = 2$.\n  - $R_1 = (1.0, 0.0)$, $R_2 = (2.0, 0.0)$.\n  - $r_1 = (1.0, 0.0)$, $r_2 = (2.0, 0.0)$.\n  - $\\Xi = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 1.0 \\end{bmatrix}$.\n  - $f(r_1) = (-0.729848847, -2.0)$; $f(r_2) = (-2.208073419, -4.0)$.\n- 测试用例 3（从细粒度力到粗粒度力的非平凡映射）：\n  - $N = 2$, $D = 2$, $K = 4$, $d_{\\mathrm{fg}} = 4$.\n  - $R_1 = (0.3, -0.7)$, $R_2 = (-1.2, 0.8)$.\n  - $r_1 = (0.3, 0.4, -0.7, -0.9)$, $r_2 = (-1.2, -1.1, 0.8, 0.6)$.\n  - $\\Xi = \\begin{bmatrix} 0.5 & 0.5 & 0.0 & 0.0 \\\\ 0.0 & 0.0 & 0.5 & 0.5 \\end{bmatrix}$.\n  - $f(r_1) = (2.0, 4.0, -1.0, 1.0)$; $f(r_2) = (-0.5, 1.5, 2.0, 2.0)$.\n- 测试用例 4（零力边缘情况）：\n  - $N = 3$, $D = 2$, $K = 4$, $d_{\\mathrm{fg}} = 2$.\n  - $R_1 = (0.2, 0.2)$, $R_2 = (1.1, -1.1)$, $R_3 = (-2.0, 2.0)$.\n  - $r_1 = (0.2, 0.2)$, $r_2 = (1.1, -1.1)$, $r_3 = (-2.0, 2.0)$.\n  - $\\Xi = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 1.0 \\end{bmatrix}$.\n  - $f(r_1) = (0.0, 0.0)$; $f(r_2) = (0.0, 0.0)$; $f(r_3) = (0.0, 0.0)$.\n\n所需算法，针对每个测试用例：\n1. 构建 $A \\in \\mathbb{R}^{(N D) \\times K}$，其行由 $(n,d)$ 索引，其中 $n \\in \\{1,\\dots,N\\}$，$d \\in \\{1,2\\}$，且 $A_{(n,d),k} = \\left(-\\nabla_R B_k(R_n)\\right)_d$。\n2. 构建 $b \\in \\mathbb{R}^{N D}$，通过为每个 $n$ 依次堆叠 $b_{(n,1)}$ 和 $b_{(n,2)}$，其中 $b_n = \\Xi f(r_n)$。\n3. 通过最小化 $\\|A \\theta - b\\|_2^2$ 来求解 $\\theta$；如果 $A$ 是秩亏的，则返回最小范数解。\n4. 将 $\\theta$ 的每个分量四舍五入到六位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例的结果本身是一个由四个四舍五入的系数组成的、用方括号括起来的、无空格的逗号分隔列表。例如：“[[a1,a2,a3,a4],[b1,b2,b3,b4],[c1,c2,c3,c4],[d1,d2,d3,d4]]”，其中每个占位符是一个四舍五入到六位小数的浮点数。", "solution": "该问题经评估为**有效**。它在科学上基于分子动力学和统计力学的原理，特别是用于粗粒化的力匹配方法。该问题是适定的，提供了构建可解的线性最小二乘问题所需的所有数据和定义。指令是客观、精确的，且没有矛盾或歧义。\n\n任务是确定粗粒化势能模型的最优系数 $\\theta \\in \\mathbb{R}^K$，通过最小化模型力与从高分辨率模拟中派生的目标力之间的差异。这是一个经典的自底向上粗粒化过程，被构建为一个线性回归问题。\n\n粗粒化势能 $U_{\\theta}(R)$ 定义为 $K$ 个基函数 $\\{B_k(R)\\}_{k=1}^K$ 的线性组合：\n$$\nU_{\\theta}(R) = \\sum_{k=1}^{K} \\theta_k B_k(R)\n$$\n其中 $R \\in \\mathbb{R}^D$ 是粗粒化坐标，$\\theta = (\\theta_1, \\dots, \\theta_K)^T$ 是待确定的系数向量。在这个问题中，空间维度是 $D=2$，基函数的数量是 $K=4$。\n\n粗粒化系统上的力是该势能相对于坐标 $R$ 的负梯度：\n$$\nF_{\\theta}(R) = -\\nabla_R U_{\\theta}(R) = -\\nabla_R \\left(\\sum_{k=1}^{K} \\theta_k B_k(R)\\right) = \\sum_{k=1}^{K} \\theta_k (-\\nabla_R B_k(R))\n$$\n该方程表明，模型力 $F_{\\theta}(R)$ 在系数 $\\theta_k$ 上是线性的。项 $-\\nabla_R B_k(R)$ 是作为力场基底的向量值函数。\n\n力匹配的目标是找到参数向量 $\\theta$，使得对于一系列 $N$ 个构型（样本，索引为 $n=1, \\dots, N$），模型力 $F_{\\theta}(R_n)$ 能最好地匹配一组目标力 $b_n$。目标力 $b_n \\in \\mathbb{R}^D$ 是通过将线性映射 $\\Xi \\in \\mathbb{R}^{D \\times d_{\\mathrm{fg}}}$ 应用于细粒度（例如，全原子）模拟的细粒度力 $f(r_n) \\in \\mathbb{R}^{d_{\\mathrm{fg}}}$ 得到的：\n$$\nb_n = \\Xi f(r_n)\n$$\n优化问题是最小化所有 $N$ 个样本和所有 $D$ 个维度上的平方差之和（最小二乘残差）：\n$$\nL(\\theta) = \\sum_{n=1}^{N} \\|F_{\\theta}(R_n) - b_n\\|_2^2\n$$\n这可以被表述为一个标准的线性最小二乘问题，$A\\theta \\approx b$。设计矩阵 $A \\in \\mathbb{R}^{(ND) \\times K}$ 和目标向量 $b \\in \\mathbb{R}^{ND}$ 是通过堆叠每个样本的贡献来构建的。遵循问题指定的样本主序、分量次序，对应于第 $n$ 个样本的第 $d$ 个分量的 $A$ 的行由基函数的负梯度的第 $d$ 个分量组成：\n$$\nA_{(n,d), k} = \\left(-\\nabla_R B_k(R_n)\\right)_d\n$$\n类似地，向量 $b$ 是通过堆叠目标力 $b_n$ 的分量形成的：\n$$\nb_{(n,d)} = (b_n)_d\n$$\n对于这个问题，当 $D=2$（$R=(x,y)$）和 $K=4$ 时，基函数及其指定的负梯度为：\n- $B_1(R) = \\tfrac{1}{2} (x^2 + y^2) \\implies -\\nabla_R B_1(R) = (-x, -y)$\n- $B_2(R) = xy \\implies -\\nabla_R B_2(R) = (-y, -x)$\n- $B_3(R) = \\sin(x) \\implies -\\nabla_R B_3(R) = (-\\cos(x), 0)$\n- $B_4(R) = \\cos(y) \\implies -\\nabla_R B_4(R) = (0, \\sin(y))$\n\n对于每个坐标为 $R_n=(x_n, y_n)$ 的样本 $n=1, \\dots, N$，我们在设计矩阵 $A$（大小为 $(2N) \\times 4$）中构建两行。为了实现清晰，使用基于0的索引，行为：\n- 行 $2(n-1)$（对于 $x$ 分量, $d=1$）: $\\begin{bmatrix} -x_n & -y_n & -\\cos(x_n) & 0 \\end{bmatrix}$\n- 行 $2(n-1)+1$（对于 $y$ 分量, $d=2$）: $\\begin{bmatrix} -y_n & -x_n & 0 & \\sin(y_n) \\end{bmatrix}$\n\n目标向量 $b$（大小为 $2N$）是通过为每个样本计算 $b_n = \\Xi f(r_n)$ 并堆叠其分量来构建的：$b = [ (b_1)_1, (b_1)_2, (b_2)_1, (b_2)_2, \\dots, (b_N)_1, (b_N)_2 ]^T$。\n\n最小化 $\\|A\\theta - b\\|_2^2$ 的解 $\\theta$ 可以使用数值线性代数例程找到。问题规定，如果矩阵 $A$ 是秩亏的（即其列不是线性无关的），则应返回唯一的最小范数解 $\\theta$。这个解是 $\\theta^*$，它最小化 $\\|A\\theta - b\\|_2$，并且在所有达到该最小值的向量中，具有最小的欧几里得范数 $\\|\\theta^*\\|_2$。Python 中的 `numpy.linalg.lstsq` 函数，使用其默认设置，恰好提供了这种最小范数最小二乘解。这对于测试用例2（其设计矩阵被构造成秩亏）和测试用例4（求解齐次系统 $A\\theta \\approx 0$，其最小范数解为 $\\theta=0$）尤其重要。\n\n对于每个测试用例，流程如下：\n1.  初始化一个形状为 $(2N, 4)$ 的零矩阵 $A$ 和一个形状为 $(2N,)$ 的零向量 $b$。\n2.  遍历每个样本 $n$（从 $1$到 $N$）。\n3.  对于每个样本，提取粗粒化坐标 $R_n=(x_n, y_n)$ 和细粒度力向量 $f(r_n)$。\n4.  使用梯度公式计算对应于样本 $n$ 的 $A$ 的两行。\n5.  计算目标粗粒化力 $b_n = \\Xi f(r_n)$。\n6.  将值放入 $A$ 的相应行和 $b$ 的元素中。\n7.  填充完 $A$ 和 $b$ 后，使用 `numpy.linalg.lstsq(A, b, rcond=None)` 求解 $\\theta$。\n8.  将 $\\theta$ 的结果分量四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of linear force-matching problems.\n    For each test case, it constructs the design matrix A and target vector b,\n    solves the least-squares problem A*theta = b for the coefficients theta,\n    and formats the results as specified.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 3, \"D\": 2, \"K\": 4, \"d_fg\": 2,\n            \"R\": np.array([[0.0, 0.0], [1.0, 0.5], [-0.5, 1.0]]),\n            \"f\": np.array([[-0.5, 0.0], [-1.770151153, -0.119856385], [1.561208719, -2.710367746]]),\n            \"Xi\": np.array([[1.0, 0.0], [0.0, 1.0]])\n        },\n        {\n            \"N\": 2, \"D\": 2, \"K\": 4, \"d_fg\": 2,\n            \"R\": np.array([[1.0, 0.0], [2.0, 0.0]]),\n            \"f\": np.array([[-0.729848847, -2.0], [-2.208073419, -4.0]]),\n            \"Xi\": np.array([[1.0, 0.0], [0.0, 1.0]])\n        },\n        {\n            \"N\": 2, \"D\": 2, \"K\": 4, \"d_fg\": 4,\n            \"R\": np.array([[0.3, -0.7], [-1.2, 0.8]]),\n            \"f\": np.array([[2.0, 4.0, -1.0, 1.0], [-0.5, 1.5, 2.0, 2.0]]),\n            \"Xi\": np.array([[0.5, 0.5, 0.0, 0.0], [0.0, 0.0, 0.5, 0.5]])\n        },\n        {\n            \"N\": 3, \"D\": 2, \"K\": 4, \"d_fg\": 2,\n            \"R\": np.array([[0.2, 0.2], [1.1, -1.1], [-2.0, 2.0]]),\n            \"f\": np.array([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0]]),\n            \"Xi\": np.array([[1.0, 0.0], [0.0, 1.0]])\n        }\n    ]\n\n    results_str_list = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        D = case[\"D\"]\n        K = case[\"K\"]\n        \n        R_samples = case[\"R\"]\n        f_samples = case[\"f\"]\n        Xi = case[\"Xi\"]\n        \n        # Initialize the design matrix A and target vector b\n        A = np.zeros((N * D, K))\n        b = np.zeros(N * D)\n        \n        # Populate the matrix A and vector b\n        for n in range(N):\n            Rn = R_samples[n]\n            xn, yn = Rn[0], Rn[1]\n            \n            # Row index for x-component: 2*n\n            # Row index for y-component: 2*n + 1\n            row_idx_x = 2 * n\n            row_idx_y = 2 * n + 1\n            \n            # Basis function gradients for A\n            # B1: 0.5*(x^2+y^2) => -grad B1 = (-x, -y)\n            A[row_idx_x, 0] = -xn\n            A[row_idx_y, 0] = -yn\n            \n            # B2: x*y => -grad B2 = (-y, -x)\n            A[row_idx_x, 1] = -yn\n            A[row_idx_y, 1] = -xn\n            \n            # B3: sin(x) => -grad B3 = (-cos(x), 0)\n            A[row_idx_x, 2] = -np.cos(xn)\n            A[row_idx_y, 2] = 0.0\n            \n            # B4: cos(y) => -grad B4 = (0, sin(y))\n            A[row_idx_x, 3] = 0.0\n            A[row_idx_y, 3] = np.sin(yn)\n            \n            # Target force vector b\n            fn = f_samples[n]\n            bn = Xi @ fn # Matrix-vector product\n            \n            b[row_idx_x] = bn[0]\n            b[row_idx_y] = bn[1]\n\n        # Solve for theta using linear least squares.\n        # np.linalg.lstsq returns the minimum-norm solution for rank-deficient matrices.\n        theta, residuals, rank, singular_values = np.linalg.lstsq(A, b, rcond=None)\n        \n        # Round the solution to six decimal places\n        theta_rounded = np.round(theta, 6)\n\n        # Format the result string for this case\n        case_result_str = f\"[{','.join([f'{c:.6f}' for c in theta_rounded])}]\"\n        results_str_list.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```", "id": "3399938"}, {"introduction": "虽然解析基函数在力匹配中很有用，但在实践中，我们常常使用更灵活的表格化势能，通过样条插值来表示。本练习 [@problem_id:3399949] 介绍了这种强大的技术，并引入了一个关键的实际考量：如何施加物理约束，例如保证势能和力在截断距离处平滑地变为零。你将学习如何将这些约束条件表达为线性方程，并将标准的最小二乘问题转化为一个约束最小二乘问题来求解。", "problem": "考虑一个分子动力学 (MD) 中的自下而上粗粒化问题，其目标是通过力匹配方法，从细粒度力数据中估计中心对势 $u(r)$。假设相互作用是纯径向且对加性的，因此，对于相距为 $r$ 的两个粒子，径向力的大小为 $f(r) = -u'(r)$。您的任务是将 $u(r)$ 表示为一个三次样条，该样条定义在一组严格递增的节点 $\\{r_a\\}_{a=0}^{A}$上，其中 $A \\in \\mathbb{N}$ 且 $r_0 < r_1 < \\cdots < r_A$，且 $A \\geq 1$。在每对连续节点 $[r_{i}, r_{i+1}]$（其中 $i \\in \\{0,\\dots,A-1\\}$）之间，定义一个局部坐标 $x = r - r_i$，并令\n$$\nu_i(x) = a_i + b_i x + c_i x^2 + d_i x^3,\n$$\n其中每个区间都有未知的系数 $\\{a_i,b_i,c_i,d_i\\}$。将所有未知数收集到一个向量 $\\mathbf{w} \\in \\mathbb{R}^{4(A)}$ 中，其顺序为 $(a_0,b_0,c_0,d_0,a_1,b_1,c_1,d_1,\\dots,a_{A-1},b_{A-1},c_{A-1},d_{A-1})$。\n\n对 $\\mathbf{w}$ 施加以下线性等式约束：\n\n- 在每个内部节点 $r_i$（其中 $i \\in \\{1,\\dots,A-1\\}$）处的 $u(r)$ 连续性：\n$$\nu_{i-1}(\\Delta_{i-1}) = u_{i}(0),\n$$\n其中 $\\Delta_{i-1} = r_i - r_{i-1}$。\n\n- 在每个内部节点 $r_i$（其中 $i \\in \\{1,\\dots,A-1\\}$）处的 $u'(r)$ 连续性：\n$$\nu_{i-1}'(\\Delta_{i-1}) = u_{i}'(0).\n$$\n\n- 在最后一个节点 $r_A$ 处的平滑截断：\n$$\nu_{A-1}(\\Delta_{A-1}) = 0, \\quad u_{A-1}'(\\Delta_{A-1}) = 0,\n$$\n其中 $\\Delta_{A-1} = r_A - r_{A-1}$。\n\n- 在第一个节点 $r_0$ 处的规范固定：\n$$\nu_0(0) = 0.\n$$\n\n任务：\n\n$1.$ 推导约束关于系数 $\\{a_i,b_i,c_i,d_i\\}$ 的显式线性方程，并将其表示为矩阵方程 $\\mathbf{C} \\mathbf{w} = \\mathbf{0}$，其中 $\\mathbf{C} \\in \\mathbb{R}^{M \\times 4A}$，对于某个 $M \\in \\mathbb{N}$。您的推导必须从上述定义出发，并且只使用微积分和线性代数的基本原理。\n\n$2.$ 对于给定的样本距离集 $\\{r_k\\}_{k=1}^{K}$ 和相应的力大小集 $\\{f_k\\}_{k=1}^{K}$，构建一个设计矩阵 $\\mathbf{X} \\in \\mathbb{R}^{K \\times 4A}$，使得力匹配模型为\n$$\n\\mathbf{f} \\approx \\mathbf{X} \\mathbf{w},\n$$\n其中第 $k$ 行将 $f(r_k) = -u'(r_k)$ 编码为局部区间系数的线性函数。提供第 $k$ 行非零项的显式公式，该公式以包含 $r_k$ 的区间 $[r_i, r_{i+1}]$ 的局部坐标 $x_k = r_k - r_i$ 表示。\n\n$3.$ 从线性代数的第一性原理出发，解释如何使用正交分解求解等式约束最小二乘问题\n$$\n\\min_{\\mathbf{w} \\in \\mathbb{R}^{4A}} \\|\\mathbf{X}\\mathbf{w} - \\mathbf{f}\\|_2^2 \\quad \\text{subject to} \\quad \\mathbf{C}\\mathbf{w} = \\mathbf{0},\n$$\n您的解释必须明确如何计算 $\\mathbf{C}$ 的零空间基，以及如何将问题简化为降维坐标下的无约束最小二乘问题。\n\n$4.$ 实现一个程序，该程序构建 $\\mathbf{C}$ 和 $\\mathbf{X}$，求解 $\\mathbf{w}$，并通过与用于生成合成数据的已知真实系数进行比较，返回一个定量准确性度量。所有量都是无量纲的。\n\n使用以下样条定义的测试套件，其中列出的系数是真实值，合成数据 $\\{f_k\\}$ 是从这些精确的样条生成的，不含噪声。在每种情况下，使用在 $[r_0, r_A]$ 上等间距分布的 $K = 401$ 个样本点。对于每种情况，输出最大绝对系数误差\n$$\n\\varepsilon_{\\max} = \\|\\widehat{\\mathbf{w}} - \\mathbf{w}^{\\star}\\|_{\\infty},\n$$\n其中 $\\widehat{\\mathbf{w}}$ 是估计的系数向量，$\\mathbf{w}^{\\star}$ 是真实值。三个测试用例如下：\n\n- 情况 1：节点 $\\{r_a\\} = [0.0, 1.0, 2.0]$。\n  - 区间 $[0.0, 1.0]$: $(a_0,b_0,c_0,d_0) = (0.0, 0.0, 1.0, 0.0)$。\n  - 区间 $[1.0, 2.0]$: $(a_1,b_1,c_1,d_1) = (1.0, 2.0, -7.0, 4.0)$。\n\n- 情况 2：节点 $\\{r_a\\} = [0.0, 0.5, 1.0, 1.5]$。\n  - 区间 $[0.0, 0.5]$: $(a_0,b_0,c_0,d_0) = (0.0, 0.0, 1.0, 0.0)$。\n  - 区间 $[0.5, 1.0]$: $(a_1,b_1,c_1,d_1) = (0.25, 1.0, -1.0, 0.0)$。\n  - 区间 $[1.0, 1.5]$: $(a_2,b_2,c_2,d_2) = (0.5, 0.0, -6.0, 8.0)$。\n\n- 情况 3：节点 $\\{r_a\\} = [0.0, 1.0]$。\n  - 区间 $[0.0, 1.0]$: $(a_0,b_0,c_0,d_0) = (0.0, 1.0, -2.0, 1.0)$。\n\n您的程序必须：\n\n- 根据上述约束为每个节点序列构建 $\\mathbf{C}$。\n- 根据样本点和模型 $f(r) = -u'(r)$ 构建 $\\mathbf{X}$。\n- 使用一种基于酉矩阵的正交分解方法求解约束最小二乘问题，该酉矩阵能揭示 $\\mathbf{C}$ 零空间的基。\n- 为每种情况计算 $\\varepsilon_{\\max}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如，“[e1,e2,e3]”），其中每个 $e_i$ 是相应测试用例的 $\\varepsilon_{\\max}$，表示为浮点数。所有量都是无量纲的，并且必须以原始十进制数的形式报告（无百分比，无物理单位）。", "solution": "该问题要求通过拟合力数据来确定三次样条势 $u(r)$ 的系数。这是分子动力学自下而上粗粒化中的一项常见任务。该问题被构建为一个等式约束的最小二乘优化问题。解决方案涉及三个主要步骤：定义代表物理约束的线性系统，定义将系数与观测力相关联的线性模型，以及求解由此产生的优化问题。\n\n首先，我们构建样条系数的线性等式约束。完整的系数向量 $\\mathbf{w} \\in \\mathbb{R}^{4A}$ 连接了 $A$ 个样条区间中每一个的系数 $\\{a_i, b_i, c_i, d_i\\}$。单个系数 $a_i, b_i, c_i, d_i$ 分别位于 $\\mathbf{w}$ 的索引 $4i, 4i+1, 4i+2, 4i+3$ 处。这些约束表示为一个齐次线性系统 $\\mathbf{C}\\mathbf{w} = \\mathbf{0}$。每个约束对应于矩阵 $\\mathbf{C}$ 中的一行。\n\n在区间 $i \\in \\{0, \\dots, A-1\\}$ 中，对于局部坐标 $x = r-r_i$，局部势为 $u_i(x) = a_i + b_i x + c_i x^2 + d_i x^3$。其导数为 $u'_i(x) = b_i + 2c_i x + 3d_i x^2$。令 $\\Delta_j = r_{j+1} - r_j$ 为区间 $j$ 的长度。\n\n1.  **$u(r)$ 的连续性**：对于每个内部节点 $r_i$（其中 $i \\in \\{1,\\dots,A-1\\}$），势必须是连续的。这意味着 $u_{i-1}(\\Delta_{i-1}) = u_i(0)$。代入多项式形式可得：\n    $$a_{i-1} + b_{i-1}\\Delta_{i-1} + c_{i-1}\\Delta_{i-1}^2 + d_{i-1}\\Delta_{i-1}^3 = a_i$$\n    这产生了 $A-1$ 个形如下式的线性方程：\n    $$a_{i-1} + b_{i-1}\\Delta_{i-1} + c_{i-1}\\Delta_{i-1}^2 + d_{i-1}\\Delta_{i-1}^3 - a_i = 0$$\n    每个这样的方程在 $\\mathbf{C}$ 的一行中填充非零项 $1, \\Delta_{i-1}, \\Delta_{i-1}^2, \\Delta_{i-1}^3$（对应于 $(a_{i-1}, b_{i-1}, c_{i-1}, d_{i-1})$ 的列），并在对应 $a_i$ 的列中填充 $-1$。\n\n2.  **$u'(r)$ 的连续性**：势的一阶导数（与力相关）在内部节点也必须是连续的：$u'_{i-1}(\\Delta_{i-1}) = u'_{i}(0)$（对于 $i \\in \\{1,\\dots,A-1\\}$）。\n    $$b_{i-1} + 2c_{i-1}\\Delta_{i-1} + 3d_{i-1}\\Delta_{i-1}^2 = b_i$$\n    这提供了另外 $A-1$ 个方程：\n    $$b_{i-1} + 2c_{i-1}\\Delta_{i-1} + 3d_{i-1}\\Delta_{i-1}^2 - b_i = 0$$\n    $\\mathbf{C}$ 中相应的行具有对应于 $(b_{i-1}, c_{i-1}, d_{i-1})$ 的项 $1, 2\\Delta_{i-1}, 3\\Delta_{i-1}^2$，以及对应于 $b_i$ 的项 $-1$。\n\n3.  **平滑截断**：在最终节点 $r_A$ 处，势及其导数必须均为零：$u(r_A) = 0$ 和 $u'(r_A) = 0$。这对应于 $u_{A-1}(\\Delta_{A-1}) = 0$ 和 $u'_{A-1}(\\Delta_{A-1}) = 0$。\n    $$a_{A-1} + b_{A-1}\\Delta_{A-1} + c_{A-1}\\Delta_{A-1}^2 + d_{A-1}\\Delta_{A-1}^3 = 0$$\n    $$b_{A-1} + 2c_{A-1}\\Delta_{A-1} + 3d_{A-1}\\Delta_{A-1}^2 = 0$$\n    这两个方程只影响最后一个区间的系数 $\\{a_{A-1}, b_{A-1}, c_{A-1}, d_{A-1}\\}$。\n\n4.  **规范固定**：势的定义允许相差一个加性常数。我们通过将原点处的势设为零来固定这一点：$u(r_0) = 0$，即 $u_0(0) = 0$。\n    $$a_0 = 0$$\n    这是一个单一的方程，它在 $\\mathbf{C}$ 某一行的第一列放置一个 1。\n\n总共，对于 $A$ 个区间，有 $(A-1) + (A-1) + 2 + 1 = 2A+1$ 个线性约束。因此，矩阵 $\\mathbf{C}$ 的维度为 $(2A+1) \\times 4A$。\n\n其次，我们为力匹配模型 $\\mathbf{f} \\approx \\mathbf{X}\\mathbf{w}$ 构建设计矩阵 $\\mathbf{X}$。力的大小为 $f(r) = -u'(r)$。对于位于区间 $i$（即 $r_k \\in [r_i, r_{i+1}]$）的样本点 $r_k$，局部坐标为 $x_k = r_k - r_i$。力为：\n$$f(r_k) = -u'_i(x_k) = -(b_i + 2c_i x_k + 3d_i x_k^2)$$\n这个方程对于系数 $b_i, c_i, d_i$ 是线性的。方程 $\\mathbf{f} = \\mathbf{X}\\mathbf{w}$ 的第 $k$ 行表示 $f(r_k)$。因此，$\\mathbf{X}$ 的第 $k$ 行将仅在对应于区间 $i$ 系数的列中具有非零元素。具体的项是：\n-   在第 $4i+1$ 列（对应 $b_i$）：$-1$\n-   在第 $4i+2$ 列（对应 $c_i$）：$-2x_k = -2(r_k - r_i)$\n-   在第 $4i+3$ 列（对应 $d_i$）：$-3x_k^2 = -3(r_k - r_i)^2$\n$\\mathbf{X}$ 的第 $k$ 行中的所有其他项均为零。\n\n第三，我们求解等式约束最小二乘问题：\n$$ \\min_{\\mathbf{w} \\in \\mathbb{R}^{4A}} \\|\\mathbf{X}\\mathbf{w} - \\mathbf{f}\\|_2^2 \\quad \\text{subject to} \\quad \\mathbf{C}\\mathbf{w} = \\mathbf{0} $$\n约束 $\\mathbf{C}\\mathbf{w} = \\mathbf{0}$ 将解向量 $\\mathbf{w}$ 限制在 $\\mathbf{C}$ 的零空间中，记为 $\\text{Null}(\\mathbf{C})$。线性代数的一个基本原理是，该子空间中的任何向量都可以表示为该子空间基向量的线性组合。设 $\\mathbf{Z}$ 是一个矩阵，其列构成了 $\\text{Null}(\\mathbf{C})$ 的一个标准正交基。那么，任何有效的 $\\mathbf{w}$ 都可以写成 $\\mathbf{w} = \\mathbf{Z}\\boldsymbol{\\alpha}$，其中 $\\boldsymbol{\\alpha}$ 是某个降维坐标向量。\n\n$\\text{Null}(\\mathbf{C})$ 的维度是 $d = 4A - \\text{rank}(\\mathbf{C})$。假设这 $2A+1$ 个约束是线性无关的，则秩为 $2A+1$，自由参数的数量为 $d = 4A - (2A+1) = 2A-1$。\n$\\text{Null}(\\mathbf{C})$ 的一个标准正交基 $\\mathbf{Z}$ 可以使用奇异值分解 (SVD) 等数值方法稳健地计算出来。如果 $\\mathbf{C} = \\mathbf{U}\\boldsymbol{\\Sigma}\\mathbf{V}^T$，那么 $\\mathbf{V}$ 中对应于零奇异值的列构成了零空间的一个标准正交基。\n\n通过将 $\\mathbf{w} = \\mathbf{Z}\\boldsymbol{\\alpha}$ 代入目标函数，我们将约束问题转化为关于 $\\boldsymbol{\\alpha}$ 的无约束问题：\n$$ \\min_{\\boldsymbol{\\alpha} \\in \\mathbb{R}^d} \\|\\mathbf{X}(\\mathbf{Z}\\boldsymbol{\\alpha}) - \\mathbf{f}\\|_2^2 = \\min_{\\boldsymbol{\\alpha} \\in \\mathbb{R}^d} \\|\\mathbf{X'}\\boldsymbol{\\alpha} - \\mathbf{f}\\|_2^2 $$\n其中 $\\mathbf{X'} = \\mathbf{X}\\mathbf{Z}$。这是一个标准的线性最小二乘问题，可以通过例如对 $\\mathbf{X'}$ 进行 QR 分解来求解 $\\hat{\\boldsymbol{\\alpha}}$。一旦找到 $\\hat{\\boldsymbol{\\alpha}}$，最终的系数向量就重构为 $\\widehat{\\mathbf{w}} = \\mathbf{Z}\\hat{\\boldsymbol{\\alpha}}$。由于提供的测试数据是合成的且无噪声，计算出的 $\\widehat{\\mathbf{w}}$ 预计将在机器精度范围内与真实值 $\\mathbf{w}^{\\star}$ 相匹配。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        (\n            [0.0, 1.0, 2.0],\n            [0.0, 0.0, 1.0, 0.0, 1.0, 2.0, -7.0, 4.0]\n        ),\n        # Case 2\n        (\n            [0.0, 0.5, 1.0, 1.5],\n            [0.0, 0.0, 1.0, 0.0, 0.25, 1.0, -1.0, 0.0, 0.5, 0.0, -6.0, 8.0]\n        ),\n        # Case 3\n        (\n            [0.0, 1.0],\n            [0.0, 1.0, -2.0, 1.0]\n        )\n    ]\n\n    results = []\n    for knots, w_star in test_cases:\n        error = solve_case(knots, w_star)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef solve_case(knots, w_star):\n    \"\"\"\n    Solves one test case of the spline fitting problem by building the constraint\n    and design matrices, and solving the constrained least squares problem.\n    \n    Args:\n        knots (list): A list of strictly increasing knot positions.\n        w_star (list): The ground-truth coefficient vector w*.\n\n    Returns:\n        float: The maximum absolute error ||w_hat - w*||_inf.\n    \"\"\"\n    knots = np.array(knots, dtype=np.float64)\n    w_star = np.array(w_star, dtype=np.float64)\n    \n    A = len(knots) - 1 # Number of intervals\n    num_coeffs = 4 * A # Total number of coefficients\n    \n    # 1. Construct the constraint matrix C\n    num_constraints = 2 * A + 1\n    C = np.zeros((num_constraints, num_coeffs), dtype=np.float64)\n    deltas = np.diff(knots)\n    \n    row_idx = 0\n    # Continuity constraints (A-1 for u, A-1 for u')\n    if A > 1:\n        for i in range(1, A):\n            delta_prev = deltas[i-1]\n            \n            # u_{i-1}(delta) = u_i(0)\n            C[row_idx, 4 * (i - 1) + 0] = 1.0\n            C[row_idx, 4 * (i - 1) + 1] = delta_prev\n            C[row_idx, 4 * (i - 1) + 2] = delta_prev**2\n            C[row_idx, 4 * (i - 1) + 3] = delta_prev**3\n            C[row_idx, 4 * i + 0] = -1.0\n            row_idx += 1\n            \n            # u'_{i-1}(delta) = u'_i(0)\n            C[row_idx, 4 * (i - 1) + 1] = 1.0\n            C[row_idx, 4 * (i - 1) + 2] = 2.0 * delta_prev\n            C[row_idx, 4 * (i - 1) + 3] = 3.0 * delta_prev**2\n            C[row_idx, 4 * i + 1] = -1.0\n            row_idx += 1\n\n    # Smooth cutoff constraints at r_A (2 constraints)\n    delta_last = deltas[A-1]\n    # u_{A-1}(delta_last) = 0\n    C[row_idx, 4 * (A - 1) + 0] = 1.0\n    C[row_idx, 4 * (A - 1) + 1] = delta_last\n    C[row_idx, 4 * (A - 1) + 2] = delta_last**2\n    C[row_idx, 4 * (A - 1) + 3] = delta_last**3\n    row_idx += 1\n    # u'_{A-1}(delta_last) = 0\n    C[row_idx, 4 * (A - 1) + 1] = 1.0\n    C[row_idx, 4 * (A - 1) + 2] = 2.0 * delta_last\n    C[row_idx, 4 * (A - 1) + 3] = 3.0 * delta_last**2\n    row_idx += 1\n    \n    # Gauge fixing constraint at r_0 (1 constraint)\n    # u_0(0) = 0 => a_0 = 0\n    C[row_idx, 0] = 1.0\n    \n    # 2. Find an orthonormal basis Z for the null space of C\n    Z = null_space(C)\n\n    # 3. Generate synthetic force data from w_star\n    K = 401\n    r_samples = np.linspace(knots[0], knots[-1], K, dtype=np.float64)\n    f_samples = np.zeros(K, dtype=np.float64)\n    \n    # Find interval indices for all sample points efficiently\n    indices = np.searchsorted(knots, r_samples, side='right') - 1\n    # Clip to handle the rightmost boundary point r_A\n    indices = np.clip(indices, 0, A - 1)\n\n    for k in range(K):\n        i = indices[k]\n        x_k = r_samples[k] - knots[i]\n        b_i, c_i, d_i = w_star[4*i+1], w_star[4*i+2], w_star[4*i+3]\n        f_samples[k] = -(b_i + 2.0*c_i*x_k + 3.0*d_i*x_k**2)\n\n    # 4. Construct the design matrix X\n    X = np.zeros((K, num_coeffs), dtype=np.float64)\n    for k in range(K):\n        i = indices[k]\n        x_k = r_samples[k] - knots[i]\n        # f(r_k) = - (b_i + 2*c_i*x_k + 3*d_i*x_k^2)\n        X[k, 4*i + 1] = -1.0\n        X[k, 4*i + 2] = -2.0 * x_k\n        X[k, 4*i + 3] = -3.0 * x_k**2\n        \n    # 5. Solve the constrained least squares problem\n    # Project into the null space of C\n    X_prime = X @ Z\n    \n    # Solve the unconstrained least squares problem for alpha\n    alpha_hat, _, _, _ = np.linalg.lstsq(X_prime, f_samples, rcond=None)\n    \n    # Reconstruct the full coefficient vector\n    w_hat = Z @ alpha_hat\n    \n    # 6. Compute the maximum absolute coefficient error\n    error = np.max(np.abs(w_hat - w_star))\n    \n    return error\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3399949"}]}