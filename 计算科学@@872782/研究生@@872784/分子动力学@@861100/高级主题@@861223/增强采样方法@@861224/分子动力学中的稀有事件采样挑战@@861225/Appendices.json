{"hands_on_practices": [{"introduction": "在深入研究复杂的采样方法之前，掌握简单系统中反应速率的解析理论至关重要。这项练习将引导您推导著名的克莱默斯(Kramers)速率公式，该公式描述了在一维双势阱中，一个遵循过阻尼朗之万(Langevin)动力学的粒子如何克服势垒。此推导通过福克-普朗克(Fokker-Planck)方程将微观动力学与宏观速率联系起来，为理解所有势垒穿越问题奠定了理论基石。[@problem_id:3440646]", "problem": "考虑一个在双势阱 $U(x) = a x^{4} - b x^{2}$（其中 $a>0$ 且 $b>0$）中演化的一维空间中的单个粒子，其动力学行为由过阻尼朗之万动力学描述。其运动方程为\n$$\n\\gamma \\,\\dot{x}(t) \\;=\\; -\\,U'(x) \\;+\\; \\sqrt{2\\,\\gamma\\,k_{B}T}\\,\\eta(t),\n$$\n其中 $\\gamma$ 是摩擦系数，$k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度，$\\eta(t)$ 是单位方差白噪声，满足 $\\langle \\eta(t)\\eta(t')\\rangle=\\delta(t-t')$。将平均首达时间（MFPT）定义为从左侧极小值点 $x_{L}=-\\sqrt{b/(2a)}$ 出发，首次到达右势阱盆地的期望时间。在右侧极小值点 $x_{R}=+\\sqrt{b/(2a)}$ 处施加吸收边界，并在 $x\\to -\\infty$ 处施加反射边界（由于当 $x\\to -\\infty$ 时 $U(x)\\to +\\infty$，这实际上是限制性的）。在活化能 $\\Delta U=U(0)-U(x_{L})$ 满足 $\\beta \\,\\Delta U \\gg 1$ 的高势垒极限下进行计算，其中 $\\beta = 1/(k_{B}T)$。\n\n仅从 Smoluchowski（过阻尼 Fokker–Planck）描述和 MFPT 的后向方程出发，推导从左势阱到右势阱的 MFPT 的领导阶渐近表达式，该表达式需包含阿伦尼乌斯因子以及用 $U(x)$ 在左侧极小值点和势垒顶部的局部曲率表示的完整指前因子。然后将您的结果具体化到势 $U(x)=a x^{4}-b x^{2}$，并将其简化为关于 $a$、$b$、$\\gamma$、$k_{B}$ 和 $T$ 的闭合形式解析表达式。\n\n请用一个单位为秒的 MFPT 解析表达式来表示您的最终答案。在最终答案的方框中不要包含任何单位。无需进行数值四舍五入。", "solution": "该问题陈述已经过验证，被认为是具有科学依据、良定且客观的。它提出了一个统计物理学中的标准问题，即计算在双势阱中、受过阻尼朗之万动力学支配的粒子的平均首达时间（MFPT）。Kramers 速率公式的推导是该领域的经典练习。\n\n分析始于 MFPT $\\tau(x)$ 的后向 Fokker-Planck 方程，$\\tau(x)$ 是从位置 $x$ 出发的粒子首次到达吸收边界的期望时间。过阻尼朗之万方程为\n$$ \\gamma \\dot{x}(t) = -U'(x) + \\sqrt{2\\gamma k_B T} \\eta(t) $$\n其中 $U'(x)$ 是势 $U(x)$ 的导数，$\\gamma$ 是摩擦系数，$k_B$ 是玻尔兹曼常数，$T$ 是温度，$\\eta(t)$ 是高斯白噪声。这对应于一个随机微分方程，其漂移项为 $\\mu(x) = -U'(x)/\\gamma$，扩散系数为 $D = k_B T / \\gamma$。MFPT $\\tau(x)$ 的后向方程是一个二阶常微分方程，形式如下：\n$$ \\mu(x) \\frac{d\\tau}{dx} + D \\frac{d^2\\tau}{dx^2} = -1 $$\n代入 $\\mu(x)$ 和 $D$ 的表达式，我们得到：\n$$ -\\frac{U'(x)}{\\gamma} \\frac{d\\tau}{dx} + \\frac{k_B T}{\\gamma} \\frac{d^2\\tau}{dx^2} = -1 $$\n令 $\\beta = 1/(k_B T)$。该方程可重写为：\n$$ D \\frac{d^2\\tau}{dx^2} - D \\beta U'(x) \\frac{d\\tau}{dx} = -1 $$\n此问题定义了起始位置在左侧极小值点 $x_L = -\\sqrt{b/(2a)}$，吸收边界在右侧极小值点 $x_R = +\\sqrt{b/(2a)}$，以及当 $x \\to -\\infty$ 时的反射边界。因此，$\\tau(x)$ 的边界条件为：\n1. 在 $x_R$ 处的吸收边界：$\\tau(x_R) = 0$。\n2. 在 $x \\to -\\infty$ 处的反射边界。此条件意味着概率流为零，对于后向方程，这转化为 $\\lim_{x \\to -\\infty} \\frac{d\\tau}{dx} = 0$。\n\n令 $y(x) = d\\tau/dx$。方程变为关于 $y(x)$ 的一阶线性常微分方程：\n$$ \\frac{dy}{dx} - \\beta U'(x) y = -\\frac{1}{D} $$\n积分因子为 $\\exp\\left(-\\int \\beta U'(x) dx\\right) = \\exp(-\\beta U(x))$。乘以积分因子得到：\n$$ \\frac{d}{dx} \\left( y(x) e^{-\\beta U(x)} \\right) = -\\frac{1}{D} e^{-\\beta U(x)} $$\n从任意点 $c$ 到 $x$ 积分：\n$$ y(x) e^{-\\beta U(x)} - y(c) e^{-\\beta U(c)} = -\\frac{1}{D} \\int_c^x e^{-\\beta U(s)} ds $$\n为了满足反射边界条件 $\\lim_{x \\to -\\infty} y(x) = 0$，我们取极限 $c \\to -\\infty$。注意到当 $x \\to -\\infty$ 时 $U(x) \\to \\infty$，只要 $y(c)$ 的增长速度不超过 $e^{\\beta U(c)}$（这在物理上是必须的），则 $y(c) e^{-\\beta U(c)}$ 项会消失。因此，我们有：\n$$ y(x) e^{-\\beta U(x)} = -\\frac{1}{D} \\int_{-\\infty}^x e^{-\\beta U(s)} ds $$\n$$ y(x) = \\frac{d\\tau}{dx} = -\\frac{1}{D} e^{\\beta U(x)} \\int_{-\\infty}^x e^{-\\beta U(s)} ds $$\n为了求出 $\\tau(x)$，我们将 $y(x)$ 从 $x_R$ 积分到 $x$，并使用吸收边界条件 $\\tau(x_R)=0$：\n$$ \\tau(x) = \\int_{x_R}^x y(s) ds = -\\frac{1}{D} \\int_{x_R}^x e^{\\beta U(s)} \\left( \\int_{-\\infty}^s e^{-\\beta U(q)} dq \\right) ds $$\n我们寻求从左势阱极小值点出发的 MFPT，即 $\\tau(x_L)$：\n$$ \\tau(x_L) = -\\frac{1}{D} \\int_{x_R}^{x_L} e^{\\beta U(s)} \\left( \\int_{-\\infty}^s e^{-\\beta U(q)} dq \\right) ds = \\frac{1}{D} \\int_{x_L}^{x_R} e^{\\beta U(s)} \\left( \\int_{-\\infty}^s e^{-\\beta U(q)} dq \\right) ds $$\n这是精确表达式。我们现在在高势垒极限 $\\beta \\Delta U \\gg 1$ 下对其进行评估。这意味着被积函数呈尖峰状，从而可以使用拉普拉斯方法（鞍点近似）。\n\n外部积分 $\\int_{x_L}^{x_R} \\dots ds$ 主要由其被积函数最大的区域贡献。项 $e^{\\beta U(s)}$ 在势垒顶部 $s=x_B=0$ 处有一个尖锐的最大值。在此区域，内部积分项是一个缓变函数。\n内部积分 $I_{in}(s) = \\int_{-\\infty}^s e^{-\\beta U(q)} dq$，对于势垒顶部 $x_B$ 附近的 $s$，主要由 $e^{-\\beta U(q)}$ 最大的区域贡献。这发生在左势阱的底部，$q=x_L$。我们用谐波展开来近似 $x_L$ 附近的 $U(q)$：$U(q) \\approx U(x_L) + \\frac{1}{2}U''(x_L)(q-x_L)^2$。\n于是，内部积分变为：\n$$ I_{in}(s) \\approx \\int_{-\\infty}^{\\infty} e^{-\\beta \\left( U(x_L) + \\frac{1}{2}U''(x_L)(q-x_L)^2 \\right)} dq = e^{-\\beta U(x_L)} \\sqrt{\\frac{2\\pi}{\\beta U''(x_L)}} $$\n积分上限 $s$（接近 0）距离 $x_L$ 足够远，使得将积分上限扩展到 $\\infty$ 是合理的。\n\n现在，将此代入 $\\tau(x_L)$ 的表达式中：\n$$ \\tau(x_L) \\approx \\frac{1}{D} \\left( e^{-\\beta U(x_L)} \\sqrt{\\frac{2\\pi}{\\beta U''(x_L)}} \\right) \\int_{x_L}^{x_R} e^{\\beta U(s)} ds $$\n剩余的积分通过在势垒顶部 $s=x_B=0$ 附近近似 $U(s)$ 来计算：$U(s) \\approx U(x_B) + \\frac{1}{2}U''(x_B)s^2 = U(x_B) - \\frac{1}{2}|U''(x_B)|s^2$。\n$$ \\int_{x_L}^{x_R} e^{\\beta U(s)} ds \\approx \\int_{-\\infty}^{\\infty} e^{\\beta \\left( U(x_B) - \\frac{1}{2}|U''(x_B)|s^2 \\right)} ds = e^{\\beta U(x_B)} \\sqrt{\\frac{2\\pi}{\\beta |U''(x_B)|}} $$\n合并所有部分：\n$$ \\tau(x_L) \\approx \\frac{1}{D} \\left( e^{-\\beta U(x_L)} \\sqrt{\\frac{2\\pi}{\\beta U''(x_L)}} \\right) \\left( e^{\\beta U(x_B)} \\sqrt{\\frac{2\\pi}{\\beta |U''(x_B)|}} \\right) $$\n$$ \\tau(x_L) \\approx \\frac{2\\pi}{D\\beta\\sqrt{U''(x_L)|U''(x_B)|}} e^{\\beta (U(x_B)-U(x_L))} $$\n代入 $D = 1/(\\beta\\gamma)$ 并定义活化能 $\\Delta U = U(x_B) - U(x_L)$，我们得到了在过阻尼极限下 MFPT 的一般 Kramers 公式：\n$$ \\tau_{Kramers} = \\frac{2\\pi\\gamma}{\\sqrt{U''(x_L)|U''(x_B)|}} e^{\\beta \\Delta U} $$\n接下来，我们将此结果具体化到势 $U(x) = ax^4 - bx^2$（其中 $a>0, b>0$）。\n首先，我们通过令 $U'(x) = 4ax^3 - 2bx = 2x(2ax^2-b) = 0$ 来找到驻点。解为 $x=0$ 和 $x=\\pm\\sqrt{b/(2a)}$。\n二阶导数是 $U''(x) = 12ax^2 - 2b$。\n在 $x=0$ 处，$U''(0) = -2b  0$，所以这是一个局部极大值（势垒顶部，$x_B=0$）。\n在 $x=\\pm\\sqrt{b/(2a)}$ 处，$U''(\\pm\\sqrt{b/(2a)}) = 12a(b/(2a)) - 2b = 6b - 2b = 4b > 0$，所以这些是局部极小值。左侧极小值点是 $x_L = -\\sqrt{b/(2a)}$。\n\n我们计算公式所需的量：\n- 左侧极小值点的曲率：$U''(x_L) = 4b$。\n- 势垒顶部的曲率大小：$|U''(x_B)| = |-2b| = 2b$。\n- 势能值为 $U(x_L) = a(-\\sqrt{b/(2a)})^4 - b(-\\sqrt{b/(2a)})^2 = a\\frac{b^2}{4a^2} - b\\frac{b}{2a} = \\frac{b^2}{4a} - \\frac{b^2}{2a} = -\\frac{b^2}{4a}$。\n- 且 $U(x_B) = U(0) = 0$。\n- 活化能为 $\\Delta U = U(x_B) - U(x_L) = 0 - (-\\frac{b^2}{4a}) = \\frac{b^2}{4a}$。\n\n最后，我们将这些值代入 Kramers 公式：\n$$ \\tau(x_L) \\approx \\frac{2\\pi\\gamma}{\\sqrt{(4b)(2b)}} \\exp\\left( \\beta \\frac{b^2}{4a} \\right) $$\n$$ \\tau(x_L) \\approx \\frac{2\\pi\\gamma}{\\sqrt{8b^2}} \\exp\\left( \\frac{b^2}{4a k_B T} \\right) $$\n$$ \\tau(x_L) \\approx \\frac{2\\pi\\gamma}{2\\sqrt{2}b} \\exp\\left( \\frac{b^2}{4a k_B T} \\right) $$\n$$ \\tau(x_L) \\approx \\frac{\\pi\\gamma}{\\sqrt{2}b} \\exp\\left( \\frac{b^2}{4a k_B T} \\right) $$\n该表达式是在高势垒极限下，给定势中粒子从左势阱到右势阱的平均首达时间的领导阶渐近结果。", "answer": "$$\n\\boxed{\\frac{\\pi \\gamma}{\\sqrt{2} b} \\exp\\left(\\frac{b^2}{4 a k_B T}\\right)}\n$$", "id": "3440646"}, {"introduction": "现实世界中的稀有事件并不仅仅由能量势垒的高度决定。本练习将向您介绍“熵瓶颈”这一重要概念，在这种情况下，即使能量势垒很低，狭窄的过渡路径也会显著降低反应速率。您将通过编程构建一个具有此特征的二维势能面，并应用过渡态理论(Transition State Theory, TST)来计算反应速率，从而获得处理复杂反应坐标和理解自由能表面的第一手经验。[@problem_id:3440663]", "problem": "你需要构建一个数学上定义的二维势能面，该势能面表现出熵瓶颈，即势能垒较低而自由能垒较高，并计算稀有事件的转变速率如何依赖于温度。你的推导和算法必须仅从以下基础出发：牛顿运动定律、使用玻尔兹曼分布的正则系综，以及稀有事件速率作为跨越分割面的平衡通量的定义。此物理情景以纯数学术语提出，以确保其普适性和计算的无歧义性。\n\n将二维势能定义为\n$$\nU(x,y) \\equiv V(x) + \\tfrac{1}{2}\\,k(x)\\,y^2,\n$$\n其中一维双阱分量为\n$$\nV(x) \\equiv a\\,(x^2 - b^2)^2\n$$\n以及随位置变化的横向刚度为\n$$\nk(x) \\equiv k_0 + k_1 \\exp\\!\\big(-(x/\\sigma)^2\\big).\n$$\n选择反应物盆地为区域 $x0$，产物盆地为区域 $x>0$。分割面位于 $x=0$。势能垒高度为 $V(0)=a\\,b^4$，可以通过选择较小的 $a$ 来降低。熵瓶颈通过使 $k(x)$ 在 $x=0$ 附近较大而在盆地区域较小来实现，这样可及的横向构型在鞍点附近收缩，从而增加自由能垒。\n\n在约化单位下工作，将玻尔兹曼常数设为 $k_B=1$，质量设为 $m=1$，单位长度设为 $L_0=1$。所有速率均以约化时间单位的倒数报告。任务中不出现角度，因此不需要角度单位。本任务不涉及百分比。\n\n仅从正则系综和跨越分割面的平衡通量定义出发，使用过渡态理论（TST）推导该模型中与温度相关的转变速率 $k(T)$。使用跨越 $x=0$ 的通量的精确平衡表达式，除以处于反应物盆地中的平衡概率，并对横向坐标 $y$ 进行解析积分。你的最终算法应将 $k(T)$ 作为对 $x$ 的一维数值积分，为上述定义的模型精确计算 $k(T)$。\n\n实现一个完整、可运行的程序，对于每个指定的测试用例，通过以下方式计算\n$$\nk(T) = \\left\\langle \\delta(x)\\,\\dot{x}\\,\\Theta(\\dot{x}) \\right\\rangle \\big/ \\Pr(x0)\n$$\n- 在正则玻尔兹曼分布下解析地完成对 $y$ 的积分，\n- 通过在 $x\\in(-\\infty,0)$ 上的数值积分计算剩余的对 $x$ 的积分，\n- 使用麦克斯韦-玻尔兹曼速度分布来获得正法向速度因子。\n\n程序必须仅使用指定的运行时环境和库。最终输出必须是单行，包含所有测试用例的结果，格式为方括号内以逗号分隔的列表，例如 $\\texttt{[r_1,r_2,r_3]}$，其中每个 $r_i$ 是一个浮点数，表示以约化时间单位的倒数为单位的速率。\n\n测试组参数集，每个为元组 $(a,b,k_0,k_1,\\sigma,m,T)$：\n- 案例 $1$ （理想路径，低势垒，强熵瓶颈）：$(0.02,\\,1.0,\\,1.0,\\,100.0,\\,0.3,\\,1.0,\\,0.5)$。\n- 案例 $2$ （低温，相同瓶颈）：$(0.02,\\,1.0,\\,1.0,\\,100.0,\\,0.3,\\,1.0,\\,0.1)$。\n- 案例 $3$ （较高温度，相同瓶颈）：$(0.02,\\,1.0,\\,1.0,\\,100.0,\\,0.3,\\,1.0,\\,1.0)$。\n- 案例 $4$ （无熵瓶颈，均匀横向刚度）：$(0.02,\\,1.0,\\,1.0,\\,0.0,\\,0.3,\\,1.0,\\,0.5)$。\n- 案例 $5$ （极窄瓶颈）：$(0.02,\\,1.0,\\,1.0,\\,100.0,\\,0.1,\\,1.0,\\,0.5)$。\n\n你的程序应产生单行输出，包含结果，格式为方括号内以逗号分隔的列表（例如 $\\texttt{[r_1,r_2,r_3,r_4,r_5]}$），其中每个 $r_i$ 是相应案例计算出的速率，单位为约化时间单位的倒数。", "solution": "问题陈述经过严格验证，被认为是**有效的**。它在科学上基于统计力学，具有所有必要的定义和参数，是一个适定问题，并以客观的数学语言表达。该任务是化学速率理论中一个标准的、非平凡的问题，可以从所提供的第一性原理出发进行严格求解。\n\n从反应物盆地（$x0$）到产物盆地（$x>0$）的转变速率 $k(T)$ 被定义为轨迹在正 $x$ 方向上穿过 $x=0$ 处分割面的平衡通量，并通过处于反应物盆地中的平衡概率进行归一化。\n$$\nk(T) = \\frac{\\left\\langle \\delta(x)\\,\\dot{x}\\,\\Theta(\\dot{x}) \\right\\rangle}{\\Pr(x0)}\n$$\n其中 $\\langle \\cdot \\rangle$ 表示正则系综平均，$\\dot{x}$ 是沿 $x$ 方向的速度，$\\delta(x)$ 是选择分割面的狄拉克δ函数，而 $\\Theta(\\dot{x})$ 是亥维赛德阶跃函数，确保只计算正向（产物方向）的通量。\n\n在相空间 $(\\mathbf{q}, \\mathbf{p})$ 中，一个可观测量 $A(\\mathbf{q}, \\mathbf{p})$ 的正则平均由 $\\langle A \\rangle = Z^{-1} \\int A(\\mathbf{q}, \\mathbf{p}) e^{-\\beta H(\\mathbf{q}, \\mathbf{p})} d\\mathbf{q} d\\mathbf{p}$ 给出，其中 $H$ 是哈密顿量，$\\beta = (k_B T)^{-1}$，$Z$ 是总配分函数。当 $k_B=1$ 时，$\\beta = 1/T$。该二维系统的哈密顿量为\n$$\nH(x, y, p_x, p_y) = \\frac{p_x^2}{2m} + \\frac{p_y^2}{2m} + U(x, y)\n$$\n其中 $U(x,y) = V(x) + \\frac{1}{2}k(x)y^2$。粒子质量为 $m$。\n\n分子是通量 $J = \\left\\langle \\delta(x)\\,\\dot{x}\\,\\Theta(\\dot{x}) \\right\\rangle$。将其写成相空间积分形式：\n$$\nJ = \\frac{1}{Z} \\int_{-\\infty}^{\\infty} dx \\int_{-\\infty}^{\\infty} dy \\int_{-\\infty}^{\\infty} dp_x \\int_{-\\infty}^{\\infty} dp_y \\, \\delta(x) \\frac{p_x}{m} \\Theta(p_x) e^{-\\beta H}\n$$\n对 $x$ 的积分被δ函数消去，它将积分被积函数的其余部分中的 $x$ 设为0。该表达式分离为对其余变量的积分之积：\n$$\nJ = \\frac{1}{Z} \\left(\\int_0^{\\infty} \\frac{p_x}{m} e^{-\\beta p_x^2/(2m)} dp_x\\right) \\left(\\int_{-\\infty}^{\\infty} e^{-\\beta p_y^2/(2m)} dp_y\\right) \\left(\\int_{-\\infty}^{\\infty} e^{-\\beta U(0,y)} dy\\right)\n$$\n计算动量积分：\n1. $\\int_0^{\\infty} \\frac{p_x}{m} e^{-\\beta p_x^2/(2m)} dp_x = \\left[-\\frac{1}{\\beta} e^{-\\beta p_x^2/(2m)}\\right]_0^{\\infty} = \\frac{1}{\\beta} = T$。\n2. $\\int_{-\\infty}^{\\infty} e^{-\\beta p_y^2/(2m)} dp_y = \\sqrt{2\\pi m/\\beta} = \\sqrt{2\\pi m T}$。\n\n在过渡态 $x=0$ 处的构型积分将记为 $Z_q^\\ddagger$：\n$Z_q^\\ddagger = \\int_{-\\infty}^{\\infty} e^{-\\beta U(0,y)} dy$。\n因此，通量为 $J = \\frac{1}{Z} (T) (\\sqrt{2\\pi m T}) Z_q^\\ddagger$。\n\n分母是处于反应物盆地中的概率，$\\Pr(x0) = Z_R/Z$，其中 $Z_R$ 是反应物配分函数：\n$$\nZ_R = \\int_{x0} dx \\int_{-\\infty}^{\\infty} dy \\int_{-\\infty}^{\\infty} dp_x \\int_{-\\infty}^{\\infty} dp_y \\, e^{-\\beta H}\n$$\n这也分离为动量和构型部分：\n$$\nZ_R = \\left(\\int_{-\\infty}^{\\infty} e^{-\\beta p_x^2/(2m)} dp_x\\right) \\left(\\int_{-\\infty}^{\\infty} e^{-\\beta p_y^2/(2m)} dp_y\\right) \\left(\\int_{x0} dx \\int_{-\\infty}^{\\infty} dy \\, e^{-\\beta U(x,y)}\\right)\n$$\n动量积分的计算结果为 $(\\sqrt{2\\pi m T})^2 = 2\\pi m T$。构型部分是构型空间中的反应物配分函数，$Z_{R,q} = \\int_{x0} dx \\int_{-\\infty}^{\\infty} dy \\, e^{-\\beta U(x,y)}$。\n所以，$Z_R = (2\\pi m T) Z_{R,q}$。\n\n将这些结果合并得到速率常数 $k(T)$：\n$$\nk(T) = \\frac{J}{\\Pr(x0)} = \\frac{J Z}{Z_R} = \\frac{ \\frac{1}{Z} (T \\sqrt{2\\pi m T}) Z_q^\\ddagger \\cdot Z}{(2\\pi m T) Z_{R,q}} = \\frac{T \\sqrt{2\\pi m T}}{2\\pi m T} \\frac{Z_q^\\ddagger}{Z_{R,q}} = \\sqrt{\\frac{T}{2\\pi m}} \\frac{Z_q^\\ddagger}{Z_{R,q}}\n$$\n这是过渡态理论在构型空间中的标准表述。\n\n现在，我们对横向坐标 $y$ 进行解析积分。\n对于任意 $x$，对 $y$ 的积分为：\n$$\n\\int_{-\\infty}^{\\infty} e^{-\\beta U(x,y)} dy = \\int_{-\\infty}^{\\infty} e^{-\\beta(V(x) + \\frac{1}{2}k(x)y^2)} dy = e^{-\\beta V(x)} \\int_{-\\infty}^{\\infty} e^{-\\beta \\frac{k(x)}{2} y^2} dy\n$$\n这是一个标准高斯积分，其计算结果为 $\\sqrt{2\\pi/(\\beta k(x))} = \\sqrt{2\\pi T/k(x)}$。\n所以，$\\int_{-\\infty}^{\\infty} e^{-\\beta U(x,y)} dy = e^{-V(x)/T} \\sqrt{2\\pi T/k(x)}$。\n\n将此结果应用于 $Z_q^\\ddagger$（在 $x=0$ 处）和 $Z_{R,q}$（在 $x0$ 上积分）：\n$$\nZ_q^\\ddagger = \\int_{-\\infty}^{\\infty} e^{-\\beta U(0,y)} dy = e^{-V(0)/T} \\sqrt{2\\pi T/k(0)}\n$$\n$$\nZ_{R,q} = \\int_{-\\infty}^{0} dx \\left( \\int_{-\\infty}^{\\infty} e^{-\\beta U(x,y)} dy \\right) = \\int_{-\\infty}^{0} dx \\, e^{-V(x)/T} \\sqrt{2\\pi T/k(x)}\n$$\n将这些代入 $k(T)$ 的表达式中：\n$$\nk(T) = \\sqrt{\\frac{T}{2\\pi m}} \\frac{e^{-V(0)/T} \\sqrt{2\\pi T/k(0)}}{\\int_{-\\infty}^{0} e^{-V(x)/T} \\sqrt{2\\pi T/k(x)} dx} = \\sqrt{\\frac{T}{2\\pi m}} \\frac{e^{-V(0)/T}/\\sqrt{k(0)}}{\\int_{-\\infty}^{0} e^{-V(x)/T}/\\sqrt{k(x)} dx}\n$$\n使用所提供的具体函数形式：\n$V(x) = a(x^2 - b^2)^2 \\implies V(0) = ab^4$。\n$k(x) = k_0 + k_1 \\exp(-(x/\\sigma)^2) \\implies k(0) = k_0+k_1$。\n需要计算的最终表达式是：\n$$\nk(T) = \\sqrt{\\frac{T}{2\\pi m}} \\frac{\\exp(-ab^4/T) / \\sqrt{k_0+k_1}}{\\int_{-\\infty}^{0} \\frac{\\exp(-a(x^2-b^2)^2/T)}{\\sqrt{k_0 + k_1 \\exp(-(x/\\sigma)^2)}} dx}\n$$\n分母中的积分无法解析求解，必须通过数值积分计算。所提供的算法将对每个测试用例实现此公式。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes the transition rate k(T) for a 2D potential energy surface \n    exhibiting an entropic bottleneck, based on Transition State Theory (TST).\n    \n    The rate is calculated using an analytical expression derived from first principles,\n    with the final step involving a 1D numerical quadrature.\n    \"\"\"\n    \n    # Test suite parameter sets, each a tuple (a, b, k0, k1, sigma, m, T)\n    test_cases = [\n        (0.02, 1.0, 1.0, 100.0, 0.3, 1.0, 0.5), # Case 1: Happy path\n        (0.02, 1.0, 1.0, 100.0, 0.3, 1.0, 0.1), # Case 2: Low temperature\n        (0.02, 1.0, 1.0, 100.0, 0.3, 1.0, 1.0), # Case 3: High temperature\n        (0.02, 1.0, 1.0, 0.0, 0.3, 1.0, 0.5),  # Case 4: No entropic bottleneck\n        (0.02, 1.0, 1.0, 100.0, 0.1, 1.0, 0.5), # Case 5: Narrow bottleneck\n    ]\n\n    results = []\n    for case in test_cases:\n        a, b, k0, k1, sigma, m, T = case\n\n        # Define the potential component V(x) and transverse stiffness k(x)\n        def V_func(x_val):\n            return a * (x_val**2 - b**2)**2\n\n        def k_func(x_val):\n            return k0 + k1 * np.exp(-(x_val / sigma)**2)\n\n        # Define the integrand for the denominator of the rate expression.\n        # This corresponds to exp(-V(x)/T) / sqrt(k(x)).\n        def integrand(x_val):\n            return np.exp(-V_func(x_val) / T) / np.sqrt(k_func(x_val))\n\n        # --- Calculate the components of the TST rate formula ---\n\n        # 1. Prefactor derived from kinetic terms\n        prefactor = np.sqrt(T / (2 * np.pi * m))\n\n        # 2. Numerator term, related to the transition state configuration\n        V_at_0 = a * b**4\n        k_at_0 = k0 + k1\n        \n        # This term is exp(-V(0)/T) / sqrt(k(0))\n        numerator_term = np.exp(-V_at_0 / T) / np.sqrt(k_at_0)\n\n        # 3. Denominator term, related to the reactant basin configuration\n        # This is the integral over x from -infinity to 0 of the integrand.\n        denominator_integral, _ = integrate.quad(integrand, -np.inf, 0, limit=100)\n        \n        # Combine all parts to get the final TST rate\n        rate = prefactor * numerator_term / denominator_integral\n        results.append(rate)\n\n    # Format the final output as a single comma-separated list in brackets,\n    # with each rate expressed in scientific notation for clarity.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3440663"}, {"introduction": "元动力学等增强采样方法可以加速稀有事件的发生，但我们如何确保其统计结果的正确性呢？这项高级练习旨在解决这一关键问题，它教您如何检验一系列事件的等待时间是否遵循泊松(Poisson)过程所预期的指数分布。您将基于时间重整化定理和柯尔莫戈洛夫-斯米尔诺夫(Kolmogorov–Smirnov)检验，实现一个强大的算法来检测模拟数据中的非物理伪影，这是确保稀有事件模拟可靠性的核心技能。[@problem_id:3440725]", "problem": "您的任务是在分子动力学稀有事件采样的背景下，设计并实现一个基于统计原理的检测器，用于检测非泊松等待时间，并重点关注经元动力学校正的事件时间。您的算法必须从第一性原理出发，仅使用公认的定义，并根据固定的测试套件产生可量化的输出。\n\n定义与基本原理：\n- 具有恒定事件率 $k$ 的均匀泊松过程是一个连续时间上的点过程，其事件间等待时间是独立同分布的随机变量，每个变量都服从率为 $k$ 的指数分布。\n- 对于率为 $k$ 的指数分布，其概率密度函数为 $f(t) = k \\, e^{-k t}$（$t \\ge 0$），累积分布函数为 $F(t) = 1 - e^{-k t}$，生存函数为 $S(t) = e^{-k t}$。\n- 时间重标度定理指出，对于一个条件强度被正确指定的点过程，存在一个对事件间时间的单调变换，该变换可以产生服从一个已知的、简单的参考分布的独立同分布变量。对于均匀泊松过程，请推导将每个等待时间映射到 [0,1] 上标准均匀分布变量的具体变换。您的推导必须从上述定义开始，并且不得假定超出这些定义的任何结果。\n- 对于一个独立指数等待时间序列，推导恒定率 $k$ 的最大似然估计量。\n\n元动力학교正的事件：\n- 在诸如元动力学等偏置加速模拟中，在时间加速因子 $a$ 下观察到的事件具有一个有偏等待时间 $t_{\\mathrm{b}}$，其分布与无偏等待时间不同。在每个事件的加速因子为分段恒定的简化模型下，无偏等待时间可以通过校正 $t_{\\mathrm{corr}} = a \\, t_{\\mathrm{b}}$ 精确恢复。在实践中，$a$ 的估计可能带有噪声，从而产生错误校正的时间 $t_{\\mathrm{corr}}^{\\mathrm{wrong}}$。\n- 您的算法必须将提供的每个等待时间序列视为假设的无偏时间，从数据中估计恒定率参数，通过为均匀泊松过程的时间重标度定理所隐含的变换来转换等待时间，然后使用 Kolmogorov–Smirnov (KS) 统计量来量化其与 [0,1] 上均匀分布的偏差。\n\n算法要求：\n- 给定一个等待时间序列 $\\{t_i\\}_{i=1}^n$，使用最大似然原理从数据中估计恒定率 $\\hat{k}$。\n- 使用您推导出的均匀泊松变换，计算变换后的变量 $\\{u_i\\}_{i=1}^n$，并使用 Kolmogorov–Smirnov 统计量检验它们与 [0,1] 上标准均匀分布的一致性。报告 KS 统计量值及其对应的 p 值。\n- 所有输出均为无量纲实数。不需要物理单位。\n\n测试套件与数据生成：\n实现以下五个独立的测试用例。在每个用例中，使用一个以指定种子初始化的新的伪随机数生成器流。除非由构造明确耦合，否则所有随机变量在用例内必须是独立的。将所有时间变量视为无单位。\n\n- 用例 A（基准均匀泊松过程）：\n  - 样本量 $n = 500$。\n  - 真实率 $k = 0.5$。\n  - 种子 $12345$。\n  - 生成 $n$ 个率为 $k$ 的独立指数等待时间。\n\n- 用例 B（元动力学校正，精确校正）：\n  - 样本量 $n = 500$。\n  - 真实率 $k = 0.2$。\n  - 种子 $12346$。\n  - 对于每个事件 $i$，从一个对数正态分布中抽取一个独立的加速因子 $a_i$，其对应的正态分布参数为 $\\mu = \\ln(10)$ 和 $\\sigma = 0.5$。\n  - 在给定 $a_i$ 的条件下，从一个率为 $a_i \\, k$ 的指数分布中抽取一个有偏等待时间 $t_{{\\mathrm{b}}, i}$。\n  - 构成精确校正的时间 $t_i = a_i \\, t_{{\\mathrm{b}}, i}$。\n  - 使用 $\\{t_i\\}$ 作为您的检测算法的输入。\n\n- 用例 C（元动力学校正，错误校正）：\n  - 样本量 $n = 500$。\n  - 真实率 $k = 0.2$。\n  - 种子 $12347$。\n  - 对于每个事件 $i$，如用例 B 中一样抽取 $a_i$。\n  - 在给定 $a_i$ 的条件下，从一个率为 $a_i \\, k$ 的指数分布中抽取 $t_{{\\mathrm{b}}, i}$。\n  - 从一个均值为 $0$、标准差为 $0.6$ 的正态分布中抽取一个独立的估计噪声 $\\epsilon_i$，并定义 $a_i^{\\mathrm{est}} = a_i \\, e^{\\epsilon_i}$。\n  - 构成错误校正的时间 $t_i = a_i^{\\mathrm{est}} \\, t_{{\\mathrm{b}}, i}$。\n  - 使用 $\\{t_i\\}$ 作为您的检测算法的输入。\n\n- 用例 D（非指数更新，伽马形状）：\n  - 样本量 $n = 500$。\n  - 基准率参数 $k_0 = 0.5$。\n  - 种子 $12348$。\n  - 抽取 $n$ 个独立的伽马分布等待时间，其形状参数为 $r = 2$，率参数为 $\\lambda = r \\, k_0$（等效于尺度参数 $\\theta = 1/\\lambda$）。这将产生一个更新过程，其平均等待时间与 $1/k_0$ 相匹配，但具有非指数的变异性。\n  - 使用这些时间作为您的检测算法的输入。\n\n- 用例 E（小样本均匀泊松过程边缘用例）：\n  - 样本量 $n = 10$。\n  - 真实率 $k = 0.5$。\n  - 种子 $12349$。\n  - 生成 $n$ 个率为 $k$ 的独立指数等待时间。\n\n所需输出：\n- 对于 A, B, C, D, E 顺序中的每个用例，计算并返回两个值：Kolmogorov–Smirnov 统计量 $D$ 及其在原假设（即变换后的变量是独立同分布的标准均匀随机变量）下的 p 值。\n- 您的程序应生成单行输出，包含一个用方括号括起来的、逗号分隔的扁平实数列表，顺序为 $[D_{\\mathrm{A}}, p_{\\mathrm{A}}, D_{\\mathrm{B}}, p_{\\mathrm{B}}, D_{\\mathrm{C}}, p_{\\mathrm{C}}, D_{\\mathrm{D}}, p_{\\mathrm{D}}, D_{\\mathrm{E}}, p_{\\mathrm{E}}]$。\n- 在打印前，将每个报告的实数四舍五入到 $6$ 位小数。\n\n约束条件：\n- 您的推导必须从上面陈述的定义和事实出发。在没有推导的情况下，不要假定或引用目标变换或估计量。\n- 您的实现不得假定对真实参数有先验知识。测试套件所需的所有参数仅用于合成数据生成；您的检测算法必须在每个用例中分别从提供的等待时间中估计率。", "solution": "该任务旨在设计一个基于统计原理的检测器，用于检测非泊松等待时间。这是分析分子动力学模拟中稀有事件时的一个常见挑战。该检测器的基础是原假设，即观察到的事件间时间 $\\{t_i\\}_{i=1}^n$ 是从一个具有恒定率 $k$ 的指数分布中抽取的独立同分布 (i.i.d.) 样本，这是均匀泊松过程 (HPP) 的定义特征。先验未知的率 $k$ 必须从数据中估计。该方法的核心在于将观察到的时间变换为一组变量，在原假设下，这些变量应服从标准均匀分布。然后使用 Kolmogorov-Smirnov (KS) 检验来量化与均匀性的偏差。\n\n解决方案分三个阶段进行：首先，我们按要求从第一性原理推导必要的理论组件；其次，我们概述完整的算法流程；第三，我们分析每个指定测试用例的预期结果。\n\n### 理论推导\n\n必须推导两个关键结果：将指数变量映射到均匀变量的变换，以及指数率参数的最大似然估计量。\n\n**1. 均匀泊松过程的时间重标度变换**\n\n问题要求推导一个变换，将指数分布的等待时间 $T$ 映射到一个在区间 $[0, 1]$ 上均匀分布的随机变量 $U$。这是概率积分变换定理的一个具体应用。\n\n令 $T$ 为表示事件间等待时间的随机变量。在 HPP 假设下，$T$ 服从率参数为 $k > 0$ 的指数分布。其概率密度函数 (PDF) 和累积分布函数 (CDF) 如下所示：\n$$\nf(t; k) = k e^{-kt} \\quad \\text{for } t \\ge 0\n$$\n$$\nF_T(t; k) = P(T \\le t) = \\int_0^t k e^{-k\\tau} d\\tau = \\left[ -e^{-k\\tau} \\right]_0^t = 1 - e^{-kt}\n$$\n\n概率积分变换定理指出，如果 $X$ 是一个具有 CDF $F_X(x)$ 的连续随机变量，那么随机变量 $Y = F_X(X)$ 在 $[0, 1]$ 上均匀分布。将此定理应用于我们的等待时间变量 $T$：\n令 $U = F_T(T; k)$。因此，变换为：\n$$\nU = 1 - e^{-kT}\n$$\n\n为了证明 $U \\sim U[0, 1]$，我们求其 CDF，记为 $F_U(u)$。\n$T$ 的支撑集是 $[0, \\infty)$。这意味着 $e^{-kT}$ 在 $(0, 1]$ 内，因此 $U = 1 - e^{-kT}$ 在 $[0, 1)$ 内。\n对于任意 $u \\in [0, 1)$，$U$ 的 CDF 为：\n$$\nF_U(u) = P(U \\le u) = P(1 - e^{-kT} \\le u)\n$$\n重新整理不等式以求解 $T$：\n$$\nP(-e^{-kT} \\le u - 1) \\implies P(e^{-kT} \\ge 1 - u)\n$$\n取两边的自然对数（这是一个单调函数）：\n$$\nP(-kT \\ge \\ln(1 - u))\n$$\n由于 $k > 0$，乘以 $-1/k$ 会反转不等号：\n$$\nP\\left(T \\le -\\frac{1}{k}\\ln(1 - u)\\right)\n$$\n根据定义，$P(T \\le t) = F_T(t; k)$。因此：\n$$\nF_U(u) = F_T\\left(-\\frac{1}{k}\\ln(1 - u); k\\right) = 1 - \\exp\\left[-k \\left(-\\frac{1}{k}\\ln(1 - u)\\right)\\right]\n$$\n$$\nF_U(u) = 1 - \\exp[\\ln(1 - u)] = 1 - (1 - u) = u\n$$\n$U$ 的 CDF 是 $F_U(u) = u$ (对于 $u \\in [0, 1)$)，$F_U(u) = 0$ (对于 $u  0$)，以及 $F_U(u) = 1$ (对于 $u \\ge 1$)。这是标准均匀分布 $U[0, 1]$ 的 CDF。\n在实践中，真实的率 $k$ 是未知的，并被其估计值 $\\hat{k}$ 所取代。因此，应用于每个观测时间 $t_i$ 的变换是 $u_i = 1 - e^{-\\hat{k}t_i}$。\n\n**2. 率参数的最大似然估计量 (MLE)**\n\n给定从一个具有未知率 $k$ 的指数分布中抽取的 $n$ 个 i.i.d. 等待时间 $\\{t_i\\}_{i=1}^n$，我们推导 $k$ 的 MLE。\n\n似然函数 $\\mathcal{L}(k)$ 是观测数据的联合概率密度，被视为参数 $k$ 的函数：\n$$\n\\mathcal{L}(k; \\{t_i\\}_{i=1}^n) = \\prod_{i=1}^n f(t_i; k) = \\prod_{i=1}^n \\left(k e^{-kt_i}\\right) = k^n \\exp\\left(-k \\sum_{i=1}^n t_i\\right)\n$$\n为了简化最大化过程，我们处理对数似然函数 $\\ell(k) = \\ln \\mathcal{L}(k)$：\n$$\n\\ell(k) = \\ln\\left(k^n\\right) + \\ln\\left(\\exp\\left(-k \\sum_{i=1}^n t_i\\right)\\right) = n \\ln(k) - k \\sum_{i=1}^n t_i\n$$\n为了找到使 $\\ell(k)$ 最大化的 $k$ 值，我们计算其关于 $k$ 的导数并将其设为零：\n$$\n\\frac{d\\ell(k)}{dk} = \\frac{n}{k} - \\sum_{i=1}^n t_i\n$$\n将导数设为零，得到 MLE $\\hat{k}$：\n$$\n\\frac{n}{\\hat{k}} - \\sum_{i=1}^n t_i = 0 \\implies \\frac{n}{\\hat{k}} = \\sum_{i=1}^n t_i\n$$\n$$\n\\hat{k} = \\frac{n}{\\sum_{i=1}^n t_i}\n$$\n估计量 $\\hat{k}$ 是等待时间样本均值 $\\bar{t} = \\frac{1}{n}\\sum_{i=1}^n t_i$ 的倒数。\n为确认这是一个最大值，我们检查二阶导数：\n$$\n\\frac{d^2\\ell(k)}{dk^2} = -\\frac{n}{k^2}\n$$\n由于对于任何非平凡情况 $n > 0$ 且 $k^2 > 0$，二阶导数总是负的，这证实了 $\\hat{k}$ 对应于似然函数的最大值。\n\n### 算法流程\n\n对每个测试用例，应用以下算法：\n1.  **数据生成**：根据测试用例的具体规则，使用以指定种子初始化的伪随机数生成器生成一个包含 $n$ 个等待时间的序列 $\\{t_i\\}_{i=1}^n$，以确保可复现性。\n2.  **率估计**：使用推导的公式计算率的最大似然估计值 $\\hat{k}$：\n    $$\n    \\hat{k} = \\frac{n}{\\sum_{i=1}^n t_i}\n    $$\n3.  **时间重标度**：使用推导的时间重标度变换和估计的率 $\\hat{k}$，将序列中的每个等待时间 $t_i$ 变换为一个新变量 $u_i$：\n    $$\n    u_i = 1 - e^{-\\hat{k}t_i}\n    $$\n    这将产生一个新的重标度时间序列 $\\{u_i\\}_{i=1}^n$。\n4.  **假设检验**：使用 Kolmogorov-Smirnov (KS) 检验来量化 $\\{u_i\\}$ 的经验分布与理论标准均匀分布 $U[0, 1]$ 之间的差异。KS 统计量 $D$ 是 $\\{u_i\\}$ 的经验 CDF 与 $U[0, 1]$ 的 CDF 之间的最大绝对差。该检验还会产生一个 p 值，即在 $\\{u_i\\}$ 确实是从 $U[0, 1]$ 中 i.i.d. 抽样的原假设下，观察到至少与测量值一样大的 $D$ 统计量的概率。一个小的 p 值（例如  0.05）表示与原 HPP 模型存在统计上显著的偏差。\n\n### 测试用例分析\n\n该测试套件旨在在不同明确定义的场景下验证算法：\n- **用例 A（基准 HPP）**：数据是从一个真实的均匀泊松过程生成的。我们期望算法会确认原假设。估计的率 $\\hat{k}$ 应接近真实率 $k=0.5$。变换后的变量 $\\{u_i\\}$ 应接近均匀分布，从而产生一个小的 KS 统计量 $D$ 和一个大的 p 值。\n- **用例 B（精确校正的元动力学）**：构造确保了校正后的时间 $\\{t_i = a_i t_{\\mathrm{b},i}\\}$ 是从率 $k=0.2$ 的指数分布中抽取的 i.i.d. 样本。这个用例在理论上等同于用例 A。因此，我们期望得到类似的结果：一个小的 $D$ 值和一个大的 p 值，这表明该算法即使在从有偏模拟中恢复统计数据时也能正确识别有效的 HPP。\n- **用例 C（错误校正的元动力学）**：加速因子估计中的噪声在校正后的时间中引入了乘法误差。由此产生的 $\\{t_i\\}$ 将不再是指数分布的。期望算法能够检测到这种偏差。这应表现为一个大的 KS 统计量 $D$ 和一个相应的小 p 值，从而导致拒绝 HPP 假设。\n- **用例 D（伽马更新过程）**：等待时间是从伽马分布（$r=2$）中抽取的，其形状与指数分布（$r=1$ 的伽马分布）不同，尽管平均等待时间与可比较的 HPP 相匹配。检测器应该对分布形状的这种差异敏感。我们期望得到一个大的 $D$ 统计量和一个非常小的 p 值。\n- **用例 E（小样本 HPP）**：这是一个边缘用例，用于测试在数据有限（$n=10$）时的行为。虽然数据生成过程是一个真实的 HPP，但对于这样小的样本量，KS 检验的统计功效较低。因此，我们预计未能拒绝原假设（即获得一个大的 p 值），但与大样本情况（用例 A）相比，估计的 $\\hat{k}$ 和 KS 统计量 $D$ 可能会显示出更高的方差。\n\n现在将着手为所有五个用例执行此程序，并按规定报告结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import kstest\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting non-Poissonian waiting times\n    by implementing and applying a statistical test based on the\n    time-rescaling theorem and Kolmogorov-Smirnov statistic.\n    \"\"\"\n\n    test_cases = [\n        {'name': 'A', 'n': 500, 'k': 0.5, 'seed': 12345},\n        {'name': 'B', 'n': 500, 'k': 0.2, 'seed': 12346},\n        {'name': 'C', 'n': 500, 'k': 0.2, 'seed': 12347},\n        {'name': 'D', 'n': 500, 'k0': 0.5, 'seed': 12348},\n        {'name': 'E', 'n': 10, 'k': 0.5, 'seed': 12349},\n    ]\n\n    results = []\n    for case in test_cases:\n        rng = np.random.default_rng(case['seed'])\n        n = case['n']\n        \n        # --- Data Generation ---\n        if case['name'] == 'A':\n            # Case A: baseline homogeneous Poisson\n            k = case['k']\n            # numpy's exponential uses scale = 1/rate\n            times = rng.exponential(scale=1.0/k, size=n)\n        \n        elif case['name'] == 'B':\n            # Case B: metadynamics-corrected, exact correction\n            k = case['k']\n            # Lognormal parameters are for the underlying Normal distribution\n            log_a_mu = np.log(10)\n            log_a_sigma = 0.5\n            a_i = rng.lognormal(mean=log_a_mu, sigma=log_a_sigma, size=n)\n            \n            # Biased waiting time t_b has rate a_i * k\n            # Scale for exponential is 1 / (a_i * k)\n            t_b_i = rng.exponential(scale=1.0/(a_i * k))\n            \n            # Exactly corrected time\n            times = a_i * t_b_i\n            \n        elif case['name'] == 'C':\n            # Case C: metadynamics-corrected, mis-correction\n            k = case['k']\n            log_a_mu = np.log(10)\n            log_a_sigma = 0.5\n            a_i = rng.lognormal(mean=log_a_mu, sigma=log_a_sigma, size=n)\n            \n            t_b_i = rng.exponential(scale=1.0/(a_i * k))\n            \n            # Estimation noise for acceleration factor\n            epsilon_i = rng.normal(loc=0, scale=0.6, size=n)\n            a_est_i = a_i * np.exp(epsilon_i)\n            \n            # Mis-corrected time\n            times = a_est_i * t_b_i\n\n        elif case['name'] == 'D':\n            # Case D: non-exponential renewal, gamma shape\n            k0 = case['k0']\n            shape_r = 2.0\n            rate_lambda = shape_r * k0\n            # numpy's gamma uses scale = 1/rate\n            scale_theta = 1.0 / rate_lambda\n            times = rng.gamma(shape=shape_r, scale=scale_theta, size=n)\n\n        elif case['name'] == 'E':\n            # Case E: small-sample homogeneous Poisson\n            k = case['k']\n            times = rng.exponential(scale=1.0/k, size=n)\n        \n        # --- Algorithmic Analysis ---\n        \n        # 1. Estimate rate k using MLE\n        # handle case where sum of times is zero to avoid division by zero\n        sum_times = np.sum(times)\n        if sum_times == 0:\n            # This is highly unlikely for exponential waiting times but is good practice\n            k_hat = np.inf\n        else:\n            k_hat = n / sum_times\n\n        # 2. Compute transformed variables (rescaled times)\n        # Using the transformation u = 1 - exp(-k*t)\n        u_values = 1.0 - np.exp(-k_hat * times)\n\n        # 3. Perform Kolmogorov-Smirnov test against standard uniform distribution\n        # kstest returns a result object with statistic and pvalue\n        ks_result = kstest(u_values, 'uniform')\n        D_statistic = ks_result.statistic\n        p_value = ks_result.pvalue\n        \n        # 4. Store rounded results\n        results.append(round(D_statistic, 6))\n        results.append(round(p_value, 6))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3440725"}]}