{"hands_on_practices": [{"introduction": "分子动力学模拟的核心在于精确地求解牛顿运动方程，从而预测粒子随时间的演化轨迹。本练习将指导您为描述双原子分子振动的莫尔斯势，实现一个基本且功能强大的速度Verlet积分器。通过这个实践[@problem_id:3401300]，您不仅将掌握一种核心的数值积分算法，还将学会如何通过分析能量守恒性来评估模拟的准确性，这是选择合适时间步长的关键技能。", "problem": "考虑一个质量为 $m$ 的单个粒子在一维空间中运动，其受到 Morse potential 的作用，这是一个用于模拟双原子分子振动的标准模型。Morse potential $V(r)$ 定义为\n$$\nV(r) = D_e \\left(1 - e^{-a (r - r_e)}\\right)^2,\n$$\n其中 $D_e$ 是势阱深度（单位为焦耳），$a$ 是一个范围参数（单位为米$^{-1}$），$r_e$ 是平衡键长（单位为米）。该运动遵循 Newton's second law，即 $m \\,\\ddot{r} = F(r)$，其中 $F(r) = -\\frac{dV}{dr}$，且对于精确动力学，能量 $E(r, \\dot{r}) = \\frac{1}{2} m \\dot{r}^2 + V(r)$ 是守恒的。\n\n您的任务是编写一个完整的程序，该程序能够：\n- 实现速度 Verlet 积分器（在允许的范围之外不使用外部库），以在时间上推进上述系统的动力学。\n- 通过使用 Morse potential 最小值处的曲率，计算该势阱附近的最高小振幅振动角频率 $\\omega_{\\max}$，\n$$\n\\omega_{\\max} = \\sqrt{\\frac{k}{m}}, \\quad k = \\left.\\frac{d^2 V}{dr^2}\\right|_{r = r_e}.\n$$\n- 使用一组时间步长 $\\Delta t$，该步长由基频周期 $T = \\frac{2\\pi}{\\omega_{\\max}}$ 的分数 $s$ 构成，即 $\\Delta t = s\\,T$。\n- 对于每个时间步长，从初始位置 $r(0) = r_e + x_0$ 和初始速度 $\\dot{r}(0) = 0$ 开始，对动力学进行积分，总时长等于 $N_{\\text{periods}}$ 个完整周期，其中 $x_0$ 是一个小的位移，以保持系统处于近谐振状态。\n- 对于每个时间步长，报告积分过程中达到的最大相对能量误差，其定义为\n$$\n\\varepsilon_{\\max} = \\max_{0 \\le t \\le N_{\\text{periods}} T} \\frac{\\left|E(t) - E(0)\\right|}{E(0)}.\n$$\n\n使用以下参数值（国际单位制）：\n- $D_e = 3.0 \\,\\text{eV}$，使用 $1\\,\\text{eV} = 1.602176634 \\times 10^{-19}\\,\\text{J}$ 转换为焦耳，因此 $D_e = 3.0 \\times 1.602176634 \\times 10^{-19}\\,\\text{J}$，\n- $a = 2.0 \\times 10^{10}\\,\\text{m}^{-1}$，\n- $r_e = 1.0 \\times 10^{-10}\\,\\text{m}$，\n- $m = 1.0 \\times 10^{-26}\\,\\text{kg}$，\n- $x_0 = 2.0 \\times 10^{-12}\\,\\text{m}$，\n- $N_{\\text{periods}} = 50$。\n\n测试套件规范（每个测试用例是一个 $s$ 值，该值定义了 $\\Delta t = s\\,T$）：\n- $s = 0.01$ (小时间步长)，\n- $s = 0.05$ (中等时间步长)，\n- $s = 0.10$ (较大时间步长)，\n- $s = 0.20$ (接近实际精度的极限)，\n- $s = \\frac{1.9}{2\\pi}$ (一个接近谐振稳定阈值 $\\Delta t \\,\\omega \\approx 2$ 的边界情况)。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来、以逗号分隔的浮点数列表形式的结果，其顺序与上述测试套件一致。例如，输出格式应为 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_i$ 是对应 $s$ 值的最大相对能量误差 $\\varepsilon_{\\max}$。\n- 报告的值是无量纲的浮点数；输出中不需要包含物理单位。", "solution": "该问题在经典力学和计算物理学方面具有坚实的科学基础，问题设定良好，拥有一套完整的参数和明确的目标，并且表述客观，因此是有效的。我们可以着手提供一个解决方案。\n\n一个质量为 $m$ 的粒子在一维空间中的运动由 Morse potential $V(r)$ 决定，其表达式为：\n$$\nV(r) = D_e \\left(1 - e^{-a (r - r_e)}\\right)^2\n$$\n此处，$D_e$ 是势阱深度，$a$ 是控制势阱宽度的参数，$r_e$ 是对应于势能最小值的平衡位置。\n\n作用在粒子上的力 $F(r)$ 是势能的负梯度：\n$$\nF(r) = -\\frac{dV}{dr}\n$$\n使用链式法则，令 $u(r) = 1 - e^{-a(r-r_e)}$，我们有 $\\frac{dV}{dr} = \\frac{d(D_e u^2)}{du} \\frac{du}{dr}$。\n求导可得 $\\frac{d(D_e u^2)}{du} = 2D_e u = 2D_e(1 - e^{-a(r-r_e)})$ 和 $\\frac{du}{dr} = -e^{-a(r-r_e)}(-a) = a e^{-a(r-r_e)}$。\n将它们结合起来得到：\n$$\n\\frac{dV}{dr} = 2a D_e \\left(1 - e^{-a(r-r_e)}\\right) e^{-a(r-r_e)}\n$$\n因此，力为：\n$$\nF(r) = -2a D_e \\left(1 - e^{-a(r-r_e)}\\right) e^{-a(r-r_e)} = -2a D_e \\left(e^{-a(r-r_e)} - e^{-2a(r-r_e)}\\right)\n$$\n\n对于平衡位置 $r_e$ 附近的微小位移，该势可以近似为一个谐振势 $V(r) \\approx \\frac{1}{2} k (r-r_e)^2$，其中 $k$ 是劲度系数。劲度系数由势在最小值处的曲率确定：\n$$\nk = \\left.\\frac{d^2 V}{dr^2}\\right|_{r = r_e}\n$$\n对 $\\frac{dV}{dr}$ 的表达式求导：\n$$\n\\frac{d^2 V}{dr^2} = \\frac{d}{dr} \\left[ 2a D_e \\left(e^{-a(r-r_e)} - e^{-2a(r-r_e)}\\right) \\right] = 2a D_e \\left( -a e^{-a(r-r_e)} - (-2a) e^{-2a(r-r_e)} \\right)\n$$\n$$\n\\frac{d^2 V}{dr^2} = 2a^2 D_e \\left( 2e^{-2a(r-r_e)} - e^{-a(r-r_e)} \\right)\n$$\n在 $r=r_e$ 处计算该式：\n$$\nk = 2a^2 D_e \\left( 2e^0 - e^0 \\right) = 2a^2 D_e (2 - 1) = 2a^2 D_e\n$$\n那么，小振幅振荡的角频率为：\n$$\n\\omega_{\\max} = \\sqrt{\\frac{k}{m}} = \\sqrt{\\frac{2a^2 D_e}{m}} = a\\sqrt{\\frac{2D_e}{m}}\n$$\n相应的振荡周期为 $T = \\frac{2\\pi}{\\omega_{\\max}}$。\n\n为模拟该动力学过程，我们采用速度 Verlet 积分算法。这是一种时间可逆的辛积分器，它能在长时间的模拟中很好地保持总能量守恒。对于给定的时间步长 $\\Delta t$，位置 $r$、速度 $v$ 和加速度 $acc = F/m$ 按如下方式更新：\n1. 更新位置：$r(t + \\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2} acc(t) (\\Delta t)^2$\n2. 计算新的力和加速度：$F(t+\\Delta t)=F(r(t+\\Delta t))$ 和 $acc(t+\\Delta t) = F(t+\\Delta t)/m$。\n3. 更新速度：$v(t + \\Delta t) = v(t) + \\frac{1}{2} \\left[ acc(t) + acc(t+\\Delta t) \\right] \\Delta t$\n\n模拟从初始条件 $r(0) = r_e + x_0$ 和 $\\dot{r}(0) = v(0) = 0$ 开始。初始总能量 $E(0)$ 完全是势能：\n$$\nE(0) = \\frac{1}{2} m v(0)^2 + V(r(0)) = V(r_e + x_0) = D_e \\left(1 - e^{-a x_0}\\right)^2\n$$\n模拟运行总时长为 $N_{\\text{periods}}T$，使用的时间步长为 $\\Delta t = sT$。因此，积分步数为 $N_{\\text{steps}} = \\frac{N_{\\text{periods}} T}{sT} = \\frac{N_{\\text{periods}}}{s}$。在每一步 $i$，我们计算总能量 $E(t_i) = \\frac{1}{2} m v(t_i)^2 + V(r(t_i))$ 和相对能量误差 $\\varepsilon_i = \\frac{|E(t_i) - E(0)|}{E(0)}$。最终报告的量是整个模拟过程中观察到的最大相对误差：\n$$\n\\varepsilon_{\\max} = \\max_{i} \\varepsilon_i\n$$\n\n对于每个给定的 $s$ 值，其流程如下：\n1. 计算常数 $k$、$\\omega_{\\max}$ 和 $T$。\n2. 确定时间步长 $\\Delta t = sT$ 和总步数 $N_{\\text{steps}} = \\text{round}(N_{\\text{periods}}/s)$。\n3. 根据初始条件初始化位置 $r$、速度 $v$ 和加速度 $acc$。计算初始能量 $E(0)$。\n4. 循环 $N_{\\text{steps}}$ 次迭代，在每一步中应用速度 Verlet 更新规则。\n5. 在每次迭代中，计算当前能量 $E(t)$ 并更新观察到的最大相对误差 $\\varepsilon_{\\max}$。\n6. 循环结束后，$\\varepsilon_{\\max}$ 的最终值即为给定 $s$ 的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the molecular dynamics problem for a particle in a Morse potential\n    using the velocity Verlet integrator and calculates the maximum relative\n    energy error for different timesteps.\n    \"\"\"\n\n    # --- Problem Parameters (SI units) ---\n    EV_TO_JOULE = 1.602176634e-19\n    D_e = 3.0 * EV_TO_JOULE  # Well depth (J)\n    a = 2.0e10               # Range parameter (m^-1)\n    r_e = 1.0e-10            # Equilibrium distance (m)\n    m = 1.0e-26              # Mass (kg)\n    x_0 = 2.0e-12            # Initial displacement (m)\n    N_periods = 50.0         # Number of periods to simulate\n\n    # --- Test Suite ---\n    # Each value 's' defines a timestep dt = s * T\n    s_values = [0.01, 0.05, 0.10, 0.20, 1.9 / (2 * np.pi)]\n\n    # --- Helper Functions for Physics ---\n    def potential(r, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the Morse potential energy.\"\"\"\n        return D_e_val * (1.0 - np.exp(-a_val * (r - r_e_val)))**2\n\n    def force(r, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the force derived from the Morse potential.\"\"\"\n        # This form is slightly more efficient as it computes exp once.\n        # F(r) = -2*a*D_e * (exp(-a(r-re)) - exp(-2a(r-re)))\n        exp_term = np.exp(-a_val * (r - r_e_val))\n        return -2.0 * a_val * D_e_val * (exp_term - exp_term**2)\n\n    def total_energy(r, v, m_val, D_e_val, a_val, r_e_val):\n        \"\"\"Calculates the total energy (kinetic + potential).\"\"\"\n        kinetic = 0.5 * m_val * v**2\n        potential_e = potential(r, D_e_val, a_val, r_e_val)\n        return kinetic + potential_e\n\n    # --- Derived Harmonic Quantities ---\n    # Stiffness k = d^2V/dr^2 at r=r_e\n    k = 2.0 * a**2 * D_e\n    # Harmonic angular frequency omega_max = sqrt(k/m)\n    omega_max = np.sqrt(k / m)\n    # Harmonic period T = 2*pi / omega_max\n    T = 2.0 * np.pi / omega_max\n\n    results = []\n\n    # --- Main Loop over Test Cases ---\n    for s in s_values:\n        # --- Simulation Setup ---\n        dt = s * T\n        num_steps = int(round(N_periods / s))\n\n        # --- Initial Conditions ---\n        r = r_e + x_0\n        v = 0.0\n        acc = force(r, D_e, a, r_e) / m\n\n        # --- Initial Energy Calculation ---\n        E0 = total_energy(r, v, m, D_e, a, r_e)\n        if E0 == 0:\n            # This case should not be reached with the given parameters\n            # but is a safeguard against division by zero.\n            max_rel_error = 0.0\n        else:\n            max_rel_error = 0.0\n\n            # --- Velocity Verlet Integration Loop ---\n            for _ in range(num_steps):\n                # 1. Update position\n                r = r + v * dt + 0.5 * acc * dt**2\n                \n                # 2. Calculate new force and acceleration\n                acc_new = force(r, D_e, a, r_e) / m\n                \n                # 3. Update velocity\n                v = v + 0.5 * (acc + acc_new) * dt\n                \n                # Update acceleration for the next step\n                acc = acc_new\n\n                # 4. Calculate energy drift\n                E_t = total_energy(r, v, m, D_e, a, r_e)\n                rel_error = np.abs((E_t - E0) / E0)\n                \n                # 5. Update maximum relative error\n                if rel_error > max_rel_error:\n                    max_rel_error = rel_error\n\n        results.append(max_rel_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.15e}' for err in results)}]\")\n\nsolve()\n\n```", "id": "3401300"}, {"introduction": "许多化学和生物过程是在恒定温度下发生的，因此在分子动力学模拟中准确地控制温度至关重要。本练习将引导您从能量守恒的NVE系综过渡到更实用的恒温NVT系综，通过实现先进的BAOAB分裂积分器来求解朗之万动力学方程[@problem_id:3401323]。这个练习不仅能让您掌握一种精确的随机积分方案，还将通过弱收敛阶和构象采样准确性的分析，加深您对随机模拟正确性的理解。", "problem": "实现一个基于经典力学的分子动力学数值积分器，该积分器使用 BAOAB 分裂方法来推进粒子在谐波势中的一维朗之万动力学。然后，通过分析不变构型方差，量化其在有限时间步长下对位置均值的弱精度阶以及构型采样精度。使用无量纲简化单位，其中玻尔兹曼常数等于 1，即设置 $k_{\\mathrm{B}}=1$ 并将所有量视为无量纲。无需进行物理单位转换。\n\n该动力学由朗之万方程描述，用于描述质量为 $m$ 的粒子在谐波势 $U(x)=\\tfrac{1}{2} k x^2$ 中的位置 $x(t)$ 和速度 $v(t)$，其中摩擦系数为 $\\gamma$，温度为 $T$：\n$$\nm \\,\\mathrm{d} v(t)= -\\nabla U\\bigl(x(t)\\bigr)\\,\\mathrm{d} t - \\gamma m\\, v(t)\\,\\mathrm{d} t + \\sqrt{2 \\gamma m k_{\\mathrm{B}} T}\\,\\mathrm{d} W_t,\\qquad \\mathrm{d} x(t)= v(t)\\,\\mathrm{d} t,\n$$\n此处 $W_t$ 是一个标准维纳过程。在简化单位中，取 $k_{\\mathrm{B}}=1$ 并将 $m$、$k$、$\\gamma$、$T$ 以及时间步长 $h$ 视为无量纲。\n\n单个时间步长 $h$ 上的 BAOAB 分裂由以下子步骤序列组成：保守力引起的半步动量更新（表示为 B），半步位置漂移（表示为 A），一个整步的速度随机 Ornstein–Uhlenbeck (OU) 恒温器（表示为 O），然后是另一个半步 A 和最后一个半步 B。具体来说，对于谐波力 $F(x)=-\\partial_x U(x)=-k x$，在一个时间步长 $h$ 内，子步骤按 $B\\to A\\to O\\to A\\to B$ 的顺序应用。您必须实现这个 BAOAB 传播算子。\n\n您的任务：\n\n$1.$ 均值位置的弱精度阶评估。对于固定的 $m$、$k$、$\\gamma$、$T$ 和初始条件 $(x_0,v_0)$，考虑在最终时间 $t_f$ 时，通过 BAOAB 方法得到的均值位置 $\\mathbb{E}[x(t_f)]$。随机 OU 噪声的期望为零，因此 BAOAB 下均值的演化可以通过将其随机 OU 子步骤替换为其无噪声的平均映射来获得。将时间步长为 $h$ 的数值弱误差定义为\n$$\ne(h) = \\bigl|\\mathbb{E}[x_{h}(t_f)] - x_{\\mathrm{exact}}(t_f)\\bigr|,\n$$\n其中 $\\mathbb{E}[x_{h}(t_f)]$ 是通过 BAOAB 平均映射以步长 $h$ 传播 $t_f$ 时间得到的均值，而 $x_{\\mathrm{exact}}(t_f)$ 是从连续朗之万动力学得到的精确均值位置。由于 $\\mathbb{E}[W_t]=0$，精确均值满足确定性的阻尼谐振子方程\n$$\nm \\ddot{x}(t) + \\gamma m \\dot{x}(t) + k x(t) = 0,\n$$\n并使用给定的初始条件 $(x_0,v_0)$。计算误差比\n$$\nR = \\frac{e(h)}{e(h/2)}\n$$\n对于测试套件中指定的两对时间步长。一个二阶弱方法应产生 $R\\approx 4$。\n\n$2.$ 有限时间步长下的构型采样精度。BAOAB 积分器为 $(x_n,v_n)$ 定义了一个线性马尔可夫链，其中仿射高斯噪声注入源于 OU 子步骤。对于谐波势，连续动力学的不变分布具有构型方差 $\\mathrm{Var}(x)=T/k$。BAOAB 链有一个不变协方差矩阵 $\\Sigma$，它满足离散李雅普诺夫方程\n$$\n\\Sigma = M \\Sigma M^\\top + Q,\n$$\n其中 $M$ 是一个完整 BAOAB 步骤对 $(x,v)$ 的 $2\\times 2$ 确定性平均映射，而 $Q$ 是来自一个步骤的 OU 噪声经过周围 A 和 B 子步骤传播后的 $2\\times 2$ 协方差贡献。通过线性代数（此部分不要使用蒙特卡洛采样）精确求解此离散李雅普诺夫方程以计算双精度的 $\\Sigma$，并报告绝对构型方差误差\n$$\n\\varepsilon_{\\mathrm{conf}} = \\bigl|\\Sigma_{11} - T/k\\bigr|,\n$$\n对于指定的参数集。\n\n实现说明和约束：\n\n- 仅使用朗之万动力学的基本陈述和 BAOAB 分裂描述。不要在问题陈述中使用任何预先推导的简化公式。任何必要的公式都应在您的解决方案中从第一性原理推导。\n- 对于弱误差，请确保 $t_f$ 是 $h$ 的整数倍，以便采取整数步数。使用 BAOAB 平均映射传播均值，无需采样噪声。\n- 对于不变协方差，构建单步仿射高斯映射，并使用克罗内克积方法通过向量化求解离散李雅普诺夫方程以得到 $\\Sigma$，即求解\n$$\n\\mathrm{vec}(\\Sigma) = \\bigl(I - M \\otimes M \\bigr)^{-1} \\mathrm{vec}(Q).\n$$\n\n测试套件和要求的输出：\n\n您的程序必须为以下四个测试用例计算以下八个量，并将它们作为包含在方括号内的逗号分隔列表的单行打印出来，顺序如下。列表元素为：\n\n$1.$ 对于测试 A（欠阻尼弱阶检验）：弱误差比 $R_A$（浮点数），后跟一个布尔值，指示 $R_A \\in [3.5, 4.5]$ 是否成立。\n\n$2.$ 对于测试 B（有限时间步长下的构型方差，中等阻尼）：绝对方差误差 $\\varepsilon_{\\mathrm{conf},B}$（浮点数），后跟一个布尔值，指示 $\\varepsilon_{\\mathrm{conf},B} \\le 10^{-12}$ 是否成立。\n\n$3.$ 对于测试 C（临界阻尼弱阶检验）：弱误差比 $R_C$（浮点数），后跟一个布尔值，指示 $R_C \\in [3.5, 4.5]$ 是否成立。\n\n$4.$ 对于测试 D（有限时间步长下的构型方差，过阻尼）：绝对方差误差 $\\varepsilon_{\\mathrm{conf},D}$（浮点数），后跟一个布尔值，指示 $\\varepsilon_{\\mathrm{conf},D} \\le 10^{-12}$ 是否成立。\n\n使用以下测试参数：\n\n- 测试 A（欠阻尼弱阶检验）：$m=1$, $k=1$, $\\gamma=0.5$, $T=1$, $(x_0,v_0)=(1,0)$, $t_f=10$, $h=0.08$ 和 $h/2=0.04$。\n\n- 测试 B（有限时间步长下的构型方差）：$m=1$, $k=3$, $\\gamma=0.5$, $T=2$, $h=0.4$。\n\n- 测试 C（临界阻尼弱阶检验）：$m=1$, $k=1$, $\\gamma=2$, $T=1$, $(x_0,v_0)=(1,1)$, $t_f=3$, $h=0.05$ 和 $h/2=0.025$。\n\n- 测试 D（过阻尼构型方差）：$m=1$, $k=1$, $\\gamma=5$, $T=1$, $h=0.1$。\n\n最终输出格式：\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序完全如下：\n$$\n\\bigl[ R_A,\\ \\text{bool}(R_A\\in[3.5,4.5]),\\ \\varepsilon_{\\mathrm{conf},B},\\ \\text{bool}(\\varepsilon_{\\mathrm{conf},B}\\le 10^{-12}),\\ R_C,\\ \\text{bool}(R_C\\in[3.5,4.5]),\\ \\varepsilon_{\\mathrm{conf},D},\\ \\text{bool}(\\varepsilon_{\\mathrm{conf},D}\\le 10^{-12}) \\bigr].\n$$", "solution": "该问题是有效的，因为它在科学上基于经典力学和统计力学，定义清晰，包含所有必要的参数和明确的目标，并且其表述是客观的。我们将提供一个完整的解决方案。\n\n该问题要求实现和分析用于一维谐波势中朗之万动力学的 BAOAB 分裂积分器。我们被赋予两项不同的分析任务：评估均值位置的弱精度阶，以及量化不变构型方差在有限时间步长下的误差。所有计算均在无量纲简化单位下进行，其中玻尔兹曼常数 $k_{\\mathrm{B}}=1$。\n\n让粒子的状态由向量 $z(t) = (x(t), v(t))^\\top$ 表示。该动力学由一个质量为 $m$ 的粒子在谐波势 $U(x) = \\frac{1}{2} k x^2$ 中的朗之万方程控制：\n$$\n\\begin{cases}\n\\mathrm{d}x(t) = v(t)\\,\\mathrm{d}t \\\\\nm\\,\\mathrm{d}v(t) = -k x(t)\\,\\mathrm{d}t - \\gamma m\\, v(t)\\,\\mathrm{d}t + \\sqrt{2 \\gamma m T}\\,\\mathrm{d}W_t\n\\end{cases}\n$$\n力为 $F(x) = -\\nabla U(x) = -k x$。BAOAB 积分器将动力学分解为三个部分，在一个时间步长 $h$ 内依次求解：\n- **B**：在保守力作用下更新速度：$m\\,\\mathrm{d}v = F(x)\\,\\mathrm{d}t$。\n- **A**：更新位置：$\\mathrm{d}x = v\\,\\mathrm{d}t$。\n- **O**：在 Ornstein-Uhlenbeck (OU) 过程中更新速度：$m\\,\\mathrm{d}v = -\\gamma m v\\,\\mathrm{d}t + \\sqrt{2 \\gamma m T}\\,\\mathrm{d}W_t$。\n\nBAOAB 方案按对称序列 B(h/2)、A(h/2)、O(h)、A(h/2)、B(h/2) 应用这些步骤。由于力是线性的，并且 OU 过程是线性的，每个子步骤都可以由一个矩阵算子表示。设 $z_n = (x_n, v_n)^\\top$ 为时间 $t_n$ 时的状态。\n\n**1. 子步骤传播算子的推导**\n\n**子步骤 B (力)：** 对 $\\dot{v} = F(x)/m = - (k/m) x$ 在持续时间 $\\delta t = h/2$ 内进行积分，将 $x$ 视为常数（Verlet 格式）：\n$v_{n+1} = v_n - (k/m) x_n \\delta t$。位置 $x_n$ 保持不变。\n算子 $M_B$ 为：\n$$\nz \\mapsto M_B z, \\quad M_B = \\begin{pmatrix} 1  0 \\\\ - \\frac{k h}{2m}  1 \\end{pmatrix}\n$$\n\n**子步骤 A (漂移)：** 对 $\\dot{x} = v$ 在持续时间 $\\delta t = h/2$ 内进行积分，将 $v$ 视为常数：\n$x_{n+1} = x_n + v_n \\delta t$。速度 $v_n$ 保持不变。\n算子 $M_A$ 为：\n$$\nz \\mapsto M_A z, \\quad M_A = \\begin{pmatrix} 1  \\frac{h}{2} \\\\ 0  1 \\end{pmatrix}\n$$\n\n**子步骤 O (恒温器)：** OU 过程 $\\mathrm{d}v = -\\gamma v\\,\\mathrm{d}t + \\sqrt{2 \\gamma T/m}\\,\\mathrm{d}W_t$ 在持续时间 $h$ 内精确求解。位置 $x$ 保持不变。\n$v_{n+1} = v_n e^{-\\gamma h} + \\sqrt{\\frac{T}{m}(1 - e^{-2\\gamma h})} R_n$，其中 $R_n \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量。\n这是一个仿射变换：\n$$\nz \\mapsto M_O z + \\xi_O, \\quad M_O = \\begin{pmatrix} 1  0 \\\\ 0  e^{-\\gamma h} \\end{pmatrix}, \\quad \\xi_O = \\begin{pmatrix} 0 \\\\ \\sigma_v R_n \\end{pmatrix}\n$$\n其中 $\\sigma_v = \\sqrt{\\frac{T}{m}(1 - e^{-2\\gamma h})}$。\n\n**完整 BAOAB 步骤：** 状态 $z_{n+1}$ 是通过组合这些操作获得的：\n$z_{n+1} = M_B(M_A(M_O(M_A(M_B z_n)) + \\xi_O))$。\n展开后得到一个完整步骤的仿射映射：\n$$\nz_{n+1} = (M_B M_A M_O M_A M_B) z_n + (M_B M_A) \\xi_O = M z_n + \\xi\n$$\n其中 $M = M_B M_A M_O M_A M_B$ 是确定性平均映射，$\\xi = M_B M_A \\xi_O$ 是完整步骤的有效噪声向量。\n\n**任务 1：弱精度阶评估**\n\n状态的均值 $\\bar{z}_n = \\mathbb{E}[z_n]$ 根据 $\\bar{z}_{n+1} = M \\bar{z}_n$ 演化，因为 $\\mathbb{E}[\\xi_O]=0$。从 $z_0 = (x_0, v_0)^\\top$ 开始，经过 $N = t_f/h$ 步后的均值状态是 $\\bar{z}_N = M^N z_0$。数值均值位置是 $\\mathbb{E}[x_h(t_f)] = (\\bar{z}_N)_1$。\n\n精确的均值动力学遵循确定性方程 $m \\ddot{x} + \\gamma m \\dot{x} + k x = 0$，或 $\\ddot{x} + \\gamma \\dot{x} + \\omega_0^2 x = 0$，其中 $\\omega_0^2 = k/m$。特征方程是 $r^2 + \\gamma r + \\omega_0^2 = 0$。解取决于判别式 $\\Delta = \\gamma^2 - 4\\omega_0^2$。\n- **欠阻尼 ($\\Delta  0$)：** 测试 A ($m=1, k=1, \\gamma=0.5 \\implies \\Delta = -3.75$)。\n  解为 $x(t) = e^{-\\gamma t/2} (C_1 \\cos(\\omega_d t) + C_2 \\sin(\\omega_d t))$，其中 $\\omega_d = \\sqrt{\\omega_0^2 - (\\gamma/2)^2}$。\n  给定 $(x_0, v_0)$，我们得到 $C_1 = x_0$ 和 $C_2 = (v_0 + \\gamma x_0/2)/\\omega_d$。\n- **临界阻尼 ($\\Delta = 0$)：** 测试 C ($m=1, k=1, \\gamma=2 \\implies \\Delta = 0$)。\n  解为 $x(t) = (C_1 + C_2 t) e^{-\\gamma t/2}$。\n  给定 $(x_0, v_0)$，我们得到 $C_1 = x_0$ 和 $C_2 = v_0 + \\gamma x_0/2$。\n\n弱误差是 $e(h) = |\\mathbb{E}[x_h(t_f)] - x_{\\mathrm{exact}}(t_f)|$。一个弱精度阶为 $p$ 的方法满足 $e(h) \\propto h^p$。因此，比率 $R = e(h)/e(h/2)$ 应该约等于 $2^p$。对于 BAOAB，它是二阶弱方法，我们期望 $R \\approx 4$。\n\n**任务 2：构型采样精度**\n\nBAOAB 积分器生成一个线性马尔可夫链，其不变分布是高斯分布，具有某个协方差矩阵 $\\Sigma = \\mathbb{E}[(z-\\bar{z})(z-\\bar{z})^\\top]$。该矩阵是离散李雅普诺夫方程的稳态解：\n$$\n\\Sigma = M \\Sigma M^\\top + Q\n$$\n这里，$Q = \\mathbb{E}[\\xi \\xi^\\top]$ 是有效噪声向量 $\\xi = M_B M_A \\xi_O$ 的协方差矩阵。\n令 $C = M_B M_A$。噪声为 $\\xi = C \\xi_O$。\nOU 噪声的协方差为 $Q_O = \\mathbb{E}[\\xi_O \\xi_O^\\top] = \\mathrm{diag}(0, \\sigma_v^2)$。\n因此，$Q = C Q_O C^\\top$。\n这个李雅普诺夫方程可以通过向量化来求解 $\\Sigma$。令 $\\sigma = \\mathrm{vec}(\\Sigma)$ 和 $q = \\mathrm{vec}(Q)$，其中 $\\mathrm{vec}(\\cdot)$ 将矩阵按列展平为向量。方程变为：\n$$\n\\sigma = (M \\otimes M)\\sigma + q\n$$\n其中 $\\otimes$ 是克罗内克积。这是一个关于 $\\sigma$ 的标准线性系统：\n$$\n(I - M \\otimes M)\\sigma = q \\implies \\sigma = (I - M \\otimes M)^{-1}q\n$$\n解出向量 $\\sigma$ 后，将其重塑为 $2 \\times 2$ 矩阵 $\\Sigma$。模拟得到的构型方差为 $\\Sigma_{11}$。\n\n对于连续动力学，不变分布是 Gibbs-Boltzmann 分布，其构型部分是一个方差为 $\\mathrm{Var}(x) = k_B T/k = T/k$ 的高斯分布。已知 BAOAB 方案对于线性力能精确地保持此构型边缘分布。因此，绝对构型方差误差 $\\varepsilon_{\\mathrm{conf}} = |\\Sigma_{11} - T/k|$ 应接近机器精度，仅反映浮点运算误差。\n\n以下 Python 代码实现了对指定测试用例的这些计算。它首先定义了用于计算 BAOAB 传播算子矩阵、阻尼谐振子的精确均值位置、通过传播算子计算的数值均值位置以及通过求解李雅普诺夫方程计算不变协方差矩阵的函数。然后将这些函数应用于四个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_baoab_matrices(m, k, gamma, h):\n    \"\"\"\n    Constructs the matrix operators for the BAOAB substeps.\n    \n    Returns:\n        M_A (np.ndarray): Matrix for the A (position drift) substep.\n        M_B (np.ndarray): Matrix for the B (force) substep.\n        M_O (np.ndarray): Matrix for the O (thermostat) substep's mean map.\n    \"\"\"\n    # B step matrix for a timestep of h/2\n    M_B = np.array([[1, 0], [-k * h / (2 * m), 1]])\n    \n    # A step matrix for a timestep of h/2\n    M_A = np.array([[1, h / 2], [0, 1]])\n    \n    # O step matrix (mean map) for a timestep of h\n    M_O = np.array([[1, 0], [0, np.exp(-gamma * h)]])\n    \n    return M_A, M_B, M_O\n\ndef get_exact_mean_pos(m, k, gamma, x0, v0, tf):\n    \"\"\"\n    Computes the exact mean position for the damped harmonic oscillator.\n    \"\"\"\n    omega0_sq = k / m\n    delta = gamma**2 - 4 * omega0_sq\n\n    if np.abs(delta)  1e-15:  # Critically damped case\n        alpha = gamma / 2\n        c1 = x0\n        c2 = v0 + alpha * x0\n        x_exact = (c1 + c2 * tf) * np.exp(-alpha * tf)\n    elif delta  0:  # Underdamped case\n        alpha = gamma / 2\n        omega_d = np.sqrt(omega0_sq - alpha**2)\n        c1 = x0\n        c2 = (v0 + alpha * x0) / omega_d\n        x_exact = np.exp(-alpha * tf) * (c1 * np.cos(omega_d * tf) + c2 * np.sin(omega_d * tf))\n    else:  # Overdamped case\n        # Not needed for the specific test cases in this problem, but included for completeness.\n        sqrt_delta = np.sqrt(delta)\n        r1 = (-gamma + sqrt_delta) / 2\n        r2 = (-gamma - sqrt_delta) / 2\n        c2 = (v0 - r1 * x0) / (r2 - r1)\n        c1 = x0 - c2\n        x_exact = c1 * np.exp(r1 * tf) + c2 * np.exp(r2 * tf)\n        \n    return x_exact\n\ndef get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h):\n    \"\"\"\n    Computes the numerical mean position by propagating the mean map.\n    \"\"\"\n    if not np.isclose(tf % h, 0, atol=1e-9) and not np.isclose(tf % h, h, atol=1e-9):\n        raise ValueError(\"tf must be an integer multiple of h.\")\n    num_steps = int(round(tf / h))\n    \n    M_A, M_B, M_O = get_baoab_matrices(m, k, gamma, h)\n    \n    # Full BAOAB deterministic mean map M\n    M = M_B @ M_A @ M_O @ M_A @ M_B\n    \n    # Propagate for N steps\n    M_N = np.linalg.matrix_power(M, num_steps)\n    z0 = np.array([x0, v0])\n    zf = M_N @ z0\n    \n    return zf[0]\n\ndef calculate_weak_error_ratio(params):\n    \"\"\"\n    Calculates the weak error ratio R = e(h)/e(h/2).\n    \"\"\"\n    m, k, gamma, _, x0, v0, tf, h = params.values()\n    \n    x_exact = get_exact_mean_pos(m, k, gamma, x0, v0, tf)\n    \n    # Error for timestep h\n    x_num_h = get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h)\n    e_h = np.abs(x_num_h - x_exact)\n    \n    # Error for timestep h/2\n    x_num_h2 = get_numerical_mean_pos(m, k, gamma, x0, v0, tf, h / 2)\n    e_h2 = np.abs(x_num_h2 - x_exact)\n    \n    if e_h2 == 0:\n        return np.inf if e_h != 0 else 1.0\n\n    return e_h / e_h2\n\ndef calculate_configurational_variance_error(params):\n    \"\"\"\n    Calculates the configurational variance error at finite timestep.\n    \"\"\"\n    m, k, gamma, T, h = params.values()\n    \n    # 1. Get the BAOAB mean map M\n    M_A, M_B, M_O = get_baoab_matrices(m, k, gamma, h)\n    M = M_B @ M_A @ M_O @ M_A @ M_B\n    \n    # 2. Get the noise covariance matrix Q\n    sigma_v_sq = (T / m) * (1 - np.exp(-2 * gamma * h))\n    Q_O = np.array([[0, 0], [0, sigma_v_sq]])\n    C = M_B @ M_A\n    Q = C @ Q_O @ C.T\n    \n    # 3. Solve the discrete Lyapunov equation using Kronecker product\n    dim = M.shape[0]\n    Id_kronsq = np.eye(dim**2)\n    M_kron_M = np.kron(M, M)\n    A_lyap = Id_kronsq - M_kron_M\n    \n    q_vec = Q.flatten('F') # Use Fortran order for vec operator\n    \n    sigma_vec = np.linalg.solve(A_lyap, q_vec)\n    \n    Sigma = sigma_vec.reshape((dim, dim), order='F')\n\n    # 4. Compute the error\n    Sigma_11 = Sigma[0, 0]\n    var_exact = T / k\n    error = np.abs(Sigma_11 - var_exact)\n    \n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = {\n        'A': {'m': 1, 'k': 1, 'gamma': 0.5, 'T': 1, 'x0': 1, 'v0': 0, 'tf': 10, 'h': 0.08},\n        'B': {'m': 1, 'k': 3, 'gamma': 0.5, 'T': 2, 'h': 0.4},\n        'C': {'m': 1, 'k': 1, 'gamma': 2, 'T': 1, 'x0': 1, 'v0': 1, 'tf': 3, 'h': 0.05},\n        'D': {'m': 1, 'k': 1, 'gamma': 5, 'T': 1, 'h': 0.1},\n    }\n\n    results = []\n\n    # Test A: Weak order (underdamped)\n    params_A = test_cases['A']\n    R_A = calculate_weak_error_ratio(params_A)\n    results.append(R_A)\n    results.append(3.5 = R_A = 4.5)\n\n    # Test B: Configurational variance (moderate damping)\n    params_B = test_cases['B']\n    eps_conf_B = calculate_configurational_variance_error(params_B)\n    results.append(eps_conf_B)\n    results.append(eps_conf_B = 1e-12)\n\n    # Test C: Weak order (critical damping)\n    params_C = test_cases['C']\n    R_C = calculate_weak_error_ratio(params_C)\n    results.append(R_C)\n    results.append(3.5 = R_C = 4.5)\n\n    # Test D: Configurational variance (overdamped)\n    params_D = test_cases['D']\n    eps_conf_D = calculate_configurational_variance_error(params_D)\n    results.append(eps_conf_D)\n    results.append(eps_conf_D = 1e-12)\n    \n    # Format a boolean as a lowercase string \"true\" or \"false\" for printing\n    def format_bool(b):\n        return 'true' if b else 'false'\n\n    # Prepare string representations for each result item\n    str_results = []\n    for i, item in enumerate(results):\n        if isinstance(item, bool):\n            str_results.append(format_bool(item))\n        else:\n            str_results.append(str(item))\n\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "3401323"}, {"introduction": "为了提高计算效率并消除高频振动，分子模型中常常引入刚性键等完整约束。本练习探讨了如何处理这些约束，将约束哈密顿动力学的严谨理论框架（Dirac bracket）与分子动力学代码中广泛使用的实用算法（如SHAKE和RATTLE）进行对比[@problem_id:3401341]。通过分析这些方法的几何与计算特性，您将理解为什么像RATTLE这样的几何积分器对于保证长时间模拟的稳定性至关重要，并洞悉理论与实践之间的权衡。", "problem": "考虑一个经典的三维空间双粒子系统，其位置为 $r_1 \\in \\mathbb{R}^3$, $r_2 \\in \\mathbb{R}^3$，正则动量为 $p_1 \\in \\mathbb{R}^3$, $p_2 \\in \\mathbb{R}^3$，质量为 $m_10$, $m_20$。设哈密顿量为 $H(r_1,r_2,p_1,p_2)=\\frac{\\lVert p_1\\rVert^2}{2 m_1}+\\frac{\\lVert p_2\\rVert^2}{2 m_2}+U(r_1,r_2)$，其中 $U$ 是一个不依赖于时间的光滑势。施加一个完整约束，将原子间距离固定为一个常数 $a0$，即 $\\phi(r_1,r_2)=\\lVert r_1-r_2\\rVert^2-a^2=0$。令 $R=r_1-r_2$ 并定义二级（速度级）约束 $\\psi(r_1,r_2,p_1,p_2)=R\\cdot\\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right)=0$，这是确保约束流形在动力学下保持不变所必需的。\n\n在 Dirac 约束哈密顿框架中，定义第二类约束集 $\\chi_1=\\phi$, $\\chi_2=\\psi$，标准的正则泊松括号 $\\{f,g\\}=\\sum_{i=1}^{2}\\left(\\frac{\\partial f}{\\partial r_i}\\cdot\\frac{\\partial g}{\\partial p_i}-\\frac{\\partial f}{\\partial p_i}\\cdot\\frac{\\partial g}{\\partial r_i}\\right)$，$2\\times 2$ 的约束矩阵 $C_{ij}=\\{\\chi_i,\\chi_j\\}$，以及 Dirac 括号 $\\{f,g\\}_D=\\{f,g\\}-\\{f,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,g\\}$，其中重复的指标表示求和。精确的约束连续时间演化由 $H$ 通过 $\\{\\cdot,\\cdot\\}_D$ 生成，并在所有时间内保持 $\\phi=0$ 和 $\\psi=0$。\n\n在计算分子动力学中，SHAKE 算法是一种位置校正方法，它在无约束更新后，通过迭代调整位置来在离散时间步长上强制执行完整约束以满足 $\\phi=0$。RATTLE 算法通过额外校正速度来增强 SHAKE，从而在每个步骤结束时，当与例如速度 Verlet 积分法结合使用时，位置和速度级约束都能得到满足。\n\n使用哈密顿力学、约束动力学的第一性原理以及上述定义，分析所描述的双原子约束下 Dirac 括号演化与 SHAKE 和 RATTLE 的几何和计算特性。下列陈述中哪些是正确的？\n\nA. 在固定键长约束下，Dirac 括号演化将相对动量投影到约束流形的切空间上，从而精确地移除了径向分量，并保持了约束辛形式；因此，对于不依赖于时间的 $H$，连续时间能量是精确守恒的。\n\nB. 在使用速度 Verlet 积分法时，标准的仅位置 SHAKE 校正使得完整约束 $\\phi=0$ 在离散时间点上得到满足，但二级约束 $\\psi=0$ 通常不被强制执行；因此，径向动量分量可能保持非零，并且仅通过随后的位置校正间接减少。\n\nC. RATTLE 算法，当约束在每一步都被求解到机器精度时，会为完整约束生成一个辛的、时间可逆的离散映射；因此，它表现出有界的长期能量误差，但并不精确守恒能量。\n\nD. 计算此双原子约束的 Dirac 括号需要在每一步求一个 $6\\times 6$ 矩阵的逆，这使其即使在只有一个键长约束的情况下，渐近地比 SHAKE 和 RATTLE 更昂贵。\n\nE. 对于双原子约束，Dirac 矩阵简化为一个标量，因此 Dirac 括号演化和 RATTLE 计算出相同的拉格朗日乘子，这意味着这些方法在代数上是等价的，并且对于任何时间步长都能产生相同的离散轨迹。\n\n选择所有适用项。", "solution": "问题陈述已经过验证，被认为是科学上合理的、问题定义良好的和客观的。它提出了高等经典力学和计算分子动力学中的一个标准场景，所有术语和形式体系都得到了正确定义。我们可以进行分析。\n\n系统由哈密顿量 $H=\\frac{\\lVert p_1\\rVert^2}{2 m_1}+\\frac{\\lVert p_2\\rVert^2}{2 m_2}+U(r_1,r_2)$ 描述，受一组第二类约束 $\\chi_1 = \\phi(r_1,r_2)=\\lVert r_1-r_2\\rVert^2-a^2=0$ 和 $\\chi_2 = \\psi(r_1,r_2,p_1,p_2)=R\\cdot\\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right)=0$ 的限制，其中 $R=r_1-r_2$。约束 $\\chi_2 = 0$ 源于要求 $\\chi_1$ 在时间演化中守恒，即 $\\dot{\\chi}_1 = \\{\\chi_1, H\\} = 0$。直接计算可得：\n$$\n\\{\\chi_1, H\\} = \\left\\{ \\lVert R \\rVert^2, \\frac{\\lVert p_1\\rVert^2}{2 m_1} + \\frac{\\lVert p_2\\rVert^2}{2 m_2} \\right\\} = \\sum_{k=1}^2 \\frac{\\partial \\lVert R \\rVert^2}{\\partial r_k} \\cdot \\frac{\\partial T}{\\partial p_k} = (2R) \\cdot \\frac{p_1}{m_1} + (-2R) \\cdot \\frac{p_2}{m_2} = 2 R \\cdot \\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right) = 2\\chi_2\n$$\n为了使 $\\dot{\\chi}_1=0$，我们必须强制 $\\chi_2=0$。约束 $(\\chi_1, \\chi_2)$ 是第二类的，因为它们的泊松括号矩阵 $C_{ij} = \\{\\chi_i, \\chi_j\\}$ 是可逆的。矩阵元素为 $C_{11}=\\{\\chi_1, \\chi_1\\}=0$, $C_{22}=\\{\\chi_2, \\chi_2\\}=0$，以及\n$$\nC_{12} = \\{\\chi_1, \\chi_2\\} = \\left\\{ \\lVert R \\rVert^2, R \\cdot \\left(\\frac{p_1}{m_1}-\\frac{p_2}{m_2}\\right) \\right\\} = \\sum_{k=1}^2 \\frac{\\partial \\chi_1}{\\partial r_k} \\cdot \\frac{\\partial \\chi_2}{\\partial p_k} = (2R) \\cdot \\frac{R}{m_1} + (-2R) \\cdot \\left(-\\frac{R}{m_2}\\right) = 2 \\lVert R \\rVert^2 \\left(\\frac{1}{m_1}+\\frac{1}{m_2}\\right)\n$$\n在约束流形 $\\lVert R \\rVert^2 = a^2$ 上，所以 $C_{12} = 2 a^2 (\\frac{1}{m_1}+\\frac{1}{m_2})$。由于 $m_1, m_2, a  0$，因此 $C_{12} \\neq 0$。$C = \\begin{pmatrix} 0  C_{12} \\\\ -C_{12}  0 \\end{pmatrix}$ 的行列式为 $C_{12}^2 \\neq 0$，所以 $C$ 是可逆的。\n\n现在我们分析每个选项。\n\n**A. 在固定键长约束下，Dirac 括号演化将相对动量投影到约束流形的切空间上，从而精确地移除了径向分量，并保持了约束辛形式；因此，对于不依赖于时间的 $H$，连续时间能量是精确守恒的。**\n约束 $\\chi_1 = \\lVert R \\rVert^2 - a^2 = 0$ 在相对坐标空间中定义了一个半径为 $a$ 的球面。该流形在点 $R$ 处的切空间是与 $R$ 正交的向量集合。约束 $\\chi_2=R\\cdot(\\dot{r}_1-\\dot{r}_2)=R\\cdot\\dot{R}=0$ 明确指出相对速度向量 $\\dot{R}$ 与相对位置向量 $R$ 正交。这意味着 $\\dot{R}$ 位于切空间内。由于相对动量与相对速度成正比（$p_{rel} = \\mu \\dot{R}$，其中 $\\mu$ 是约化质量），该约束强制相对动量的径向分量为零。根据其构造，Dirac 括号形式体系生成的动力学在所有时间内都遵守所有第二类约束。所以陈述的第一部分是正确的。\nDirac 括号在约束子流形上定义了一个泊松结构。相关的非退化2-形式是一个辛形式，根据 $\\dot{F}=\\{F,H\\}_D$ 的时间演化是一个保持此约束辛形式的哈密顿流。这是 Dirac 形式体系的一个基本结果。所以第二部分是正确的。\n对于不依赖于时间的哈密顿量 $H$，能量的变化由 $\\frac{dH}{dt} = \\{H, H\\}_D$ 给出。使用 Dirac 括号的定义，$\\{f,g\\}_D = \\{f,g\\} - \\{f,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,g\\}$：\n$$\n\\{H, H\\}_D = \\{H,H\\} - \\{H,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,H\\}\n$$\n第一项 $\\{H,H\\}=0$。因此表达式为：\n$$\n\\{H, H\\}_D = - \\begin{pmatrix} \\{H, \\chi_1\\}  \\{H, \\chi_2\\} \\end{pmatrix} \\frac{1}{C_{12}} \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} \\{\\chi_1, H\\} \\\\ \\{\\chi_2, H\\} \\end{pmatrix}\n$$\n使用 $\\{H, \\chi_j\\} = -\\{\\chi_j, H\\}$，这变成：\n$$\n\\{H, H\\}_D = -\\frac{1}{C_{12}} \\begin{pmatrix} -\\{\\chi_1, H\\}  -\\{\\chi_2, H\\} \\end{pmatrix} \\begin{pmatrix} -\\{\\chi_2, H\\} \\\\ \\{\\chi_1, H\\} \\end{pmatrix} = -\\frac{1}{C_{12}} ( \\{\\chi_1, H\\}\\{\\chi_2, H\\} - \\{\\chi_2, H\\}\\{\\chi_1, H\\} ) = 0\n$$\n因此，$\\frac{dH}{dt}=0$，能量是精确守恒的。陈述的所有部分都与哈密顿力学的原理一致。\n**结论：正确。**\n\n**B. 在使用速度 Verlet 积分法时，标准的仅位置 SHAKE 校正使得完整约束 $\\phi=0$ 在离散时间点上得到满足，但二级约束 $\\psi=0$ 通常不被强制执行；因此，径向动量分量可能保持非零，并且仅通过随后的位置校正间接减少。**\n速度 Verlet 算法包括以下步骤：\n1. 更新位置：$r(t+\\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2}a(t)(\\Delta t)^2$。\n2. 应用 SHAKE：修改 $r(t+\\Delta t)$ 为 $r'(t+\\Delta t)$ 以满足 $\\phi(r'(t+\\Delta t))=0$。\n3. 计算新力/加速度：$a'(t+\\Delta t) = F(r'(t+\\Delta t))/m$。\n4. 更新速度：$v'(t+\\Delta t) = v(t) + \\frac{1}{2}(a(t)+a'(t+\\Delta t))\\Delta t$。\n关键点在于 SHAKE 仅校正位置。然后，速度根据时间 $t$ 和 $t+\\Delta t$ 处的加速度，使用标准的 Verlet 公式计算。在此过程中没有步骤明确地将速度 $v'(t+\\Delta t)$ 投影以满足速度级约束 $\\psi(t+\\Delta t) = R'(t+\\Delta t) \\cdot (\\frac{p'_1(t+\\Delta t)}{m_1} - \\frac{p'_2(t+\\Delta t)}{m_2}) = 0$。由于此条件未被强制执行，相对速度（和动量）的径向分量在一步结束时通常不为零。虽然强制执行 $\\phi(t)=0$ 和 $\\phi(t+\\Delta t)=0$ 意味着该时间间隔内的平均径向速度必须非常小，但这并不能保证在 $t+\\Delta t$ 时的瞬时径向速度为零。在 $t+2\\Delta t$ 时的后续 SHAKE 校正将防止粒子飞散，从而“间接减少”任何径向速度的影响，但它并未在每一步都消除它。这个缺陷正是 RATTLE 算法旨在修复的。\n**结论：正确。**\n\n**C. RATTLE 算法，当约束在每一步都被求解到机器精度时，会为完整约束生成一个辛的、时间可逆的离散映射；因此，它表现出有界的长期能量误差，但并不精确守恒能量。**\nRATTLE 算法通过增加第二个校正步骤来扩展 SHAKE。在 SHAKE 位置校正和速度更新的第一个半步之后，RATTLE 执行速度校正以强制执行速度级约束 $\\psi=0$。带 RATTLE 的完整速度 Verlet 算法是：\n1. 速度半步：$v(t+\\Delta t/2) = v(t) + \\frac{1}{2}a(t)\\Delta t$。\n2. 位置全步：$r(t+\\Delta t) = r(t) + v(t+\\Delta t/2)\\Delta t$。\n3. 位置校正（SHAKE 部分）：求解拉格朗日乘子以调整 $r(t+\\Delta t)$ 来满足 $\\phi(t+\\Delta t)=0$。\n4. 速度校正（RATTLE 部分）：半步速度 $v(t+\\Delta t/2)$ 与校正后的位置不一致。首先计算没有约束力贡献的最终速度，然后求解另一组拉格朗日乘子来投影最终速度以满足 $\\psi(t+\\Delta t)=0$。\n该算法是一种几何积分器。从微分方程数值分析的文献中可知，RATTLE 是一种辛积分器。这意味着它精确地保持了约束相空间上辛2-形式的一个离散模拟。它在时间上也是对称构造的，这使其具有时间可逆性。当应用于哈密顿系统时，辛积分器的一个基本性质是它们不精确守恒原始哈密顿量 $H$。相反，它们精确守恒一个与 $H$ 相近的修正的或“影子”哈密顿量 $H'$。这确保了原始能量的误差 $H(t)-H(0)$ 在非常长的模拟时间内保持有界，而不是表现出长期漂移。因此，RATTLE 以不精确守恒能量为代价，提供了出色的长期稳定性。\n**结论：正确。**\n\n**D. 计算此双原子约束的 Dirac 括号需要在每一步求一个 $6\\times 6$ 矩阵的逆，这使其即使在只有一个键长约束的情况下，渐近地比 SHAKE 和 RATTLE 更昂贵。**\nDirac 括号 $\\{f,g\\}_D = \\{f,g\\} - \\{f,\\chi_i\\}(C^{-1})_{ij}\\{\\chi_j,g\\}$ 的计算需要对约束矩阵 $C_{ij} = \\{\\chi_i, \\chi_j\\}$ 求逆。该矩阵的大小由第二类约束的数量决定。对于给定的问题，我们有两个第二类约束，$\\chi_1 = \\phi$ 和 $\\chi_2 = \\psi$。因此，指标 $i,j$ 的取值范围是从1到2，所以 $C$ 是一个 $2 \\times 2$ 矩阵。关于必须对一个 $6 \\times 6$ 矩阵求逆的前提是错误的。数字 6 很可能源于与位置坐标数量（2个粒子 $\\times$ 3个维度）的混淆。由于前提是错误的，关于相对计算成本的结论是没有根据的。对一个 $2 \\times 2$ 矩阵求逆在计算上是微不足道的。\n**结论：不正确。**\n\n**E. 对于双原子约束，Dirac 矩阵简化为一个标量，因此 Dirac 括号演化和 RATTLE 计算出相同的拉格朗日乘子，这意味着这些方法在代数上是等价的，并且对于任何时间步长都能产生相同的离散轨迹。**\n这个陈述包含几个错误。首先，正如在选项 D 的分析中确立的，约束矩阵 $C$（“Dirac 矩阵”）是一个 $2 \\times 2$ 矩阵，而不是一个标量。其次，Dirac 括号演化是精确的、*连续时间*动力学的形式体系。RATTLE 是一个生成近似*离散时间*轨迹的算法。对于任何有限的时间步长 $\\Delta t > 0$，离散时间近似在代数上不可能等同于精确的连续解。RATTLE 的轨迹仅在极限 $\\Delta t \\to 0$ 时才收敛到精确轨迹。第三，虽然两种方法在概念上都使用拉格朗日乘子，但在连续形式体系中，乘子是连续相空间变量的函数，而在 RATTLE 中，乘子是在每个离散步骤计算出的数值，以满足依赖于 $\\Delta t$ 的代数方程。它们不是相同的量，也不会有相同的值。\n**结论：不正确。**", "answer": "$$\\boxed{ABC}$$", "id": "3401341"}]}