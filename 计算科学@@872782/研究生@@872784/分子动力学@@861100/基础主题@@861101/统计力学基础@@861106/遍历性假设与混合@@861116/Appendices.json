{"hands_on_practices": [{"introduction": "在实际模拟中，我们经常使用恒温器来强制实现正则采样，但并非所有恒温器都能保证所有系统的遍历性。这项练习提供了一个关键的理论对照，要求你解析地比较几种常用恒温器对于简谐振子的性能。通过计算积分自相关时间，你将揭示为何某些确定性方法可能会失效，以及为何随机性是确保稳健混合的有力工具。", "problem": "考虑一个一维谐振子，其质量为 $m$、弹簧常数为 $k$、角频率为 $\\omega$，其中 $\\omega = \\sqrt{k/m}$。该振子与温度为 $T$ 的热库耦合，通过分子动力学中三种标准方式进行建模：确定性的 Nosé–Hoover 恒温器、Nosé–Hoover 链和随机的 Langevin 恒温器。目标是通过一个从第一性原理推导出的可计算度量，比较这些恒温器对谐振子的遍历性和混合性。\n\n定义归一化坐标自相关函数 $C_{q}(t)$ 为\n$$\nC_{q}(t) = \\frac{\\langle q(0)\\, q(t)\\rangle_{\\text{stat}}}{\\langle q^{2}\\rangle_{\\text{stat}}},\n$$\n其中 $\\langle \\cdot \\rangle_{\\text{stat}}$ 表示稳态系综平均。定义坐标的积分自相关时间为\n$$\n\\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} C_{q}(t)\\, dt.\n$$\n你将为下面的三种恒温器模型计算 $\\tau_{\\mathrm{int}}$，并将你的最终答案表示为一个单行矩阵，其中按顺序包含三个值：Nosé–Hoover、Nosé–Hoover 链、Langevin。\n\n1. Nosé–Hoover 恒温器。其扩展的确定性动力学为\n$$\n\\dot{q} = \\frac{p}{m}, \\quad \\dot{p} = -k\\, q - \\xi\\, p, \\quad \\dot{\\xi} = \\frac{1}{Q}\\left(\\frac{p^{2}}{m} - k_{B}T\\right),\n$$\n其中 $p$ 是动量，$\\xi$ 是恒温器变量，$Q$ 是恒温器质量参数，$k_{B}$ 是玻尔兹曼常数。仅使用这些方程和基本定义，证明存在与恒温器一致的轨迹，这些轨迹对于单个谐振子能产生不衰减的 $C_{q}(t)$，并计算 Nosé–Hoover 情形下 $\\tau_{\\mathrm{int}}$ 的隐含值。\n\n2. Markovian 白噪声极限下的 Nosé–Hoover 链。考虑一个与谐振子耦合的无限 Nosé–Hoover 链。在链对物理动量起到有效的 Markovian 热库作用的极限下（这是由 Mori–Zwanzig 投影形式论证明的标准粗粒化方法），振子的动量 $p$ 被建模为服从一个有效的 Ornstein–Uhlenbeck (OU) 方程，其阻尼系数为 $\\nu$，并带有与涨落-耗散定理 (FDT) 一致的高斯白噪声。在此 Markovian 白噪声极限下，有效动力学简化为\n$$\nm\\, \\ddot{q} + \\nu\\, m\\, \\dot{q} + k\\, q = \\sqrt{2\\, \\nu\\, m\\, k_{B}T}\\, \\eta(t),\n$$\n其中 $\\eta(t)$ 是单位方差的高斯白噪声。用 $\\nu$ 和 $\\omega$ 计算 $\\tau_{\\mathrm{int}}$。\n\n3. Langevin 恒温器。谐振子的标准 Langevin 动力学为\n$$\nm\\, \\ddot{q} + \\gamma\\, m\\, \\dot{q} + k\\, q = \\sqrt{2\\, \\gamma\\, m\\, k_{B}T}\\, \\eta(t),\n$$\n其中摩擦系数为 $\\gamma > 0$，$\\eta(t)$ 为单位方差高斯白噪声。假设处于欠阻尼状态 $\\gamma  2\\, \\omega$。从这些方程和用于谐振子的平衡统计力学出发，推导 $C_{q}(t)$ 并用 $\\gamma$ 和 $\\omega$ 计算 $\\tau_{\\mathrm{int}}$。\n\n你的最终答案必须是包含三个 $\\tau_{\\mathrm{int}}$ 值的单一解析表达式，按（Nosé–Hoover, Nosé–Hoover 链, Langevin）的顺序排列，并使用 $\\mathrm{pmatrix}$ 环境表示为一个行矩阵。不需要数值近似。最终答案中不要包含单位。", "solution": "问题要求计算在三种不同恒温方案下一个一维谐振子位置的积分自相关时间 $\\tau_{\\mathrm{int}}$。积分自相关时间定义为\n$$\n\\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} C_{q}(t)\\, dt,\n$$\n其中 $C_{q}(t)$ 是归一化位置自相关函数，\n$$\nC_{q}(t) = \\frac{\\langle q(0)\\, q(t)\\rangle_{\\text{stat}}}{\\langle q^{2}\\rangle_{\\text{stat}}}.\n$$\n平均 $\\langle \\cdot \\rangle_{\\text{stat}}$ 是对由动力学产生的稳态系综进行的。对于温度为 $T$ 的遍历系统，这对应于正则系综平均。对于势能为 $V(q) = \\frac{1}{2}kq^2$ 的谐振子，正则系综的一个关键性质是能量均分定理，该定理指出 $\\frac{1}{2}k\\langle q^2 \\rangle_{\\text{stat}} = \\frac{1}{2}k_B T$。这给出了归一化因子：\n$$\n\\langle q^{2}\\rangle_{\\text{stat}} = \\frac{k_B T}{k}.\n$$\n我们现在将分析这三种情况中的每一种。\n\n1. Nosé–Hoover 恒温器\n振子坐标 $q$、其动量 $p$ 和恒温器变量 $\\xi$ 的运动方程由以下确定性方程组给出：\n$$\n\\dot{q} = \\frac{p}{m}, \\quad \\dot{p} = -k\\, q - \\xi\\, p, \\quad \\dot{\\xi} = \\frac{1}{Q}\\left(\\frac{p^{2}}{m} - k_{B}T\\right).\n$$\n这些方程可以组合成一个关于 $q$ 的二阶方程：\n$$\nm\\ddot{q} = \\dot{p} = -kq - \\xi p = -kq - \\xi (m\\dot{q}) \\implies m\\ddot{q} + m\\xi\\dot{q} + kq = 0.\n$$\n这是一个具有时变阻尼系数 $\\xi(t)$ 的振子方程。已知对于单个谐振子，由 $(q, p, \\xi)$ 组成的这个三元常微分方程组是非遍历的。动力学不是混沌的；相反，对于几乎所有的初始条件，三维相空间中的轨迹都局限于一个二维不变环面上。\n这样一个环面上的轨迹对应于准周期运动。一个准周期函数 $q(t)$ 可以表示为一个具有多个不可通约频率的类傅里叶级数。当 $t \\to \\infty$ 时，这样的函数不会衰减到零。\n因此，由这个准周期函数 $q(t)$ 构建的位置自相关函数 $C_q(t)$ 也将是一个准周期函数，并且当 $t \\to \\infty$ 时不会衰减到零。例如，一个纯周期运动 $q(t) = A\\cos(\\omega' t)$ 将导致一个行为类似于 $\\cos(\\omega' t)$ 的时间平均自相关函数。\n由于 $C_q(t)$ 不衰减到零，其从 $t=0$ 到 $t=\\infty$ 的积分不会收敛到一个有限值。\n$$\n\\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} C_{q}(t)\\, dt \\to \\infty.\n$$\n这种发散表明 Nosé–Hoover 恒温器无法为单个谐振子提供有效的统计采样，这是一个经典的结论，证明了混沌动力学对遍历性的重要性。因此，在这种情况下，积分自相关时间是无穷大的。\n\n2. Nosé–Hoover 链 (Markovian 白噪声极限)\n在这个模型中，振子的动力学由以下随机微分方程描述：\n$$\nm\\, \\ddot{q} + \\nu\\, m\\, \\dot{q} + k\\, q = F(t),\n$$\n其中 $F(t) = \\sqrt{2\\, \\nu\\, m\\, k_{B}T}\\, \\eta(t)$ 且 $\\eta(t)$ 是高斯白噪声，满足 $\\langle \\eta(t)\\eta(t') \\rangle = \\delta(t-t')$。这是 Langevin 方程的一种形式，已知它是遍历的，并在温度 $T$ 下产生正则分布。\n设 $R(t) = \\langle q(0)q(t) \\rangle_{\\text{stat}}$。由于稳态的时间平移不变性，我们可以写出：\n$$\n\\ddot{R}(t) = \\langle q(0)\\ddot{q}(t) \\rangle, \\quad \\dot{R}(t) = \\langle q(0)\\dot{q}(t) \\rangle.\n$$\n将 $t$ 时刻的运动方程乘以 $q(0)$ 并取系综平均，得到：\n$$\nm \\langle q(0)\\ddot{q}(t) \\rangle + \\nu m \\langle q(0)\\dot{q}(t) \\rangle + k \\langle q(0)q(t) \\rangle = \\langle q(0)F(t) \\rangle.\n$$\n对于 $t > 0$，随机力 $F(t)$ 与位置 $q(0)$ 不相关，因为 $q(0)$ 仅依赖于 $0$ 时刻之前的噪声历史。因此，$\\langle q(0)F(t) \\rangle = 0$。这就得到了关于 $R(t)$ 的一个齐次常微分方程：\n$$\nm\\ddot{R}(t) + \\nu m\\dot{R}(t) + k R(t) = 0 \\quad (\\text{对于 } t > 0).\n$$\n为了计算 $\\tau_{\\mathrm{int}}$，我们可以将这个方程从 $t=0$ 积分到 $\\infty$：\n$$\n\\int_{0}^{\\infty} \\left( m\\ddot{R}(t) + \\nu m\\dot{R}(t) + k R(t) \\right) dt = 0.\n$$\n$$\nm[\\dot{R}(t)]_{0}^{\\infty} + \\nu m[R(t)]_{0}^{\\infty} + k\\int_{0}^{\\infty} R(t) dt = 0.\n$$\n系统会热化，所以当 $t \\to \\infty$ 时，$R(t) \\to 0$ 且 $\\dot{R}(t) \\to 0$。这给出：\n$$\nm(0 - \\dot{R}(0)) + \\nu m(0 - R(0)) + k\\int_{0}^{\\infty} R(t) dt = 0.\n$$\n初始条件是 $R(0) = \\langle q^2 \\rangle$ 和 $\\dot{R}(0) = \\langle q(0)\\dot{q}(0) \\rangle$。在热平衡状态下，位置和速度是不相关的，即 $\\langle q\\dot{q} \\rangle = (1/m)\\langle qp \\rangle = 0$，因为相空间分布函数在 $q$ 和 $p$ 上是可分的。所以，$\\dot{R}(0) = 0$。\n方程简化为：\n$$\n- \\nu m R(0) + k\\int_{0}^{\\infty} R(t) dt = 0.\n$$\n$$\n\\int_{0}^{\\infty} R(t) dt = \\frac{\\nu m}{k} R(0).\n$$\n那么积分自相关时间为\n$$\n\\tau_{\\mathrm{int}} = \\int_{0}^{\\infty} \\frac{R(t)}{R(0)} dt = \\frac{1}{R(0)} \\int_{0}^{\\infty} R(t) dt = \\frac{1}{R(0)} \\left( \\frac{\\nu m}{k} R(0) \\right) = \\frac{\\nu m}{k}.\n$$\n使用定义 $\\omega = \\sqrt{k/m}$，我们有 $m/k = 1/\\omega^2$。因此，\n$$\n\\tau_{\\mathrm{int}} = \\frac{\\nu}{\\omega^2}.\n$$\n\n3. Langevin 恒温器\n运动方程给出如下：\n$$\nm\\, \\ddot{q} + \\gamma\\, m\\, \\dot{q} + k\\, q = \\sqrt{2\\, \\gamma\\, m\\, k_{B}T}\\, \\eta(t).\n$$\n这个方程的数学形式与第 2 部分中的完全相同，只是用摩擦系数 $\\gamma$ 替换了阻尼系数 $\\nu$。求 $\\tau_{\\mathrm{int}}$ 的过程是相同的。\n遵循上述相同的步骤，我们得到未归一化自相关函数 $R(t) = \\langle q(0)q(t) \\rangle$ 的方程：\n$$\nm\\ddot{R}(t) + \\gamma m\\dot{R}(t) + k R(t) = 0 \\quad (\\text{对于 } t > 0).\n$$\n将此方程从 $t=0$ 积分到 $\\infty$ 得到：\n$$\n- \\gamma m R(0) + k\\int_{0}^{\\infty} R(t) dt = 0.\n$$\n这给出 $\\int_{0}^{\\infty} R(t) dt = \\frac{\\gamma m}{k} R(0)$。\n因此，积分自相关时间为：\n$$\n\\tau_{\\mathrm{int}} = \\frac{\\gamma m}{k} = \\frac{\\gamma}{\\omega^2}.\n$$\n为了完整起见，我们按照要求，在指定的欠阻尼条件 $\\gamma  2\\omega$ 下推导此情况的 $C_q(t)$。$R(t)$ 的常微分方程的特征方程是 $\\lambda^2 + \\gamma\\lambda + \\omega^2 = 0$，其根为 $\\lambda = -\\frac{\\gamma}{2} \\pm i\\omega'_d$，其中 $\\omega'_d = \\sqrt{\\omega^2 - (\\gamma/2)^2}$。\n$R(t)$ 的通解是 $R(t) = e^{-\\gamma t/2} (A \\cos(\\omega'_d t) + B \\sin(\\omega'_d t))$。\n初始条件是 $R(0) = \\langle q^2 \\rangle = k_B T/k$ 和 $\\dot{R}(0) = \\langle q\\dot{q} \\rangle = 0$。\n$R(0) = A = k_B T/k$。\n$\\dot{R}(0) = -\\frac{\\gamma}{2}A + B\\omega'_d = 0$，这意味着 $B = \\frac{\\gamma A}{2\\omega'_d}$。\n因此，$R(t) = \\frac{k_B T}{k} e^{-\\gamma t/2} \\left( \\cos(\\omega'_d t) + \\frac{\\gamma}{2\\omega'_d}\\sin(\\omega'_d t) \\right)$。\n归一化的自相关函数是：\n$$\nC_q(t) = \\frac{R(t)}{R(0)} = e^{-\\gamma t/2} \\left( \\cos(\\omega'_d t) + \\frac{\\gamma}{2\\omega'_d}\\sin(\\omega'_d t) \\right).\n$$\n将此表达式从 $0$ 积分到 $\\infty$ 证实了先前关于 $\\tau_{\\mathrm{int}}$ 的结果。\n\n最终答案整合\n按指定顺序（Nosé–Hoover, Nosé–Hoover 链, Langevin）计算出的三个 $\\tau_{\\mathrm{int}}$ 值为：\n1. $\\tau_{\\mathrm{int,NH}} = \\infty$\n2. $\\tau_{\\mathrm{int,NHC}} = \\frac{\\nu}{\\omega^2}$\n3. $\\tau_{\\mathrm{int,Lang}} = \\frac{\\gamma}{\\omega^2}$\n将它们组合成一个单行矩阵。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\infty  \\frac{\\nu}{\\omega^{2}}  \\frac{\\gamma}{\\omega^{2}} \\end{pmatrix}}\n$$", "id": "3452506"}, {"introduction": "在模拟了一个系统并应用了恒温器之后，你如何确信你的轨迹正在正确地对正则系综进行采样？这最后一项实践从理论转向验证，指导你构建一个全面的诊断套件，以严格测试遍历性和收敛性。通过实现一系列统计检验，你将学会区分根本性的遍历性破缺与有限时间采样偏差，这是从分子动力学模拟中获得可靠科学结果的一项关键技能。", "problem": "您的任务是设计一个全自动诊断程序，用于测试恒温分子动力学轨迹是否对正则系综进行采样，并从算法上区分遍历性缺乏与有限时间偏差。该诊断必须基于第一性原理，且不应依赖任何未指定的外部启发式方法。\n\n您必须实现一个单一程序，为给定的一维系统测试套件中的每个成员执行以下任务：\n\n1.  通过在一个维度上对Langevin动力学进行积分，生成两条独立的轨迹副本。积分在约化单位下进行，其中玻尔兹曼常数设为 $k_{\\mathrm{B}} = 1$，质量设为 $m = 1$。运动方程为\n    $$\n    \\frac{dx}{dt} = v, \\qquad \\frac{dv}{dt} = -\\frac{dU(x)}{dx} - \\gamma v + \\sqrt{2 \\gamma T}\\, \\eta(t),\n    $$\n    其中 $x$ 是位置，$v$ 是速度，$U(x)$ 是给定的势能函数，$\\gamma$ 是摩擦系数，$T$ 是温度，$\\eta(t)$ 是单位方差的高斯白噪声。使用一种时间离散化方案，该方案应遵循此动力学规律，并在给定参数和小 $dt$ 的情况下保持稳定。\n\n2.  在丢弃初始的老化（burn-in）阶段后，从模拟数据中计算用于测试正则采样和混合性的诊断指标：\n    -   正则速度边际测试：在正则系综中，速度分量是独立的、均值为 $0$、方差为 $T$ 的高斯随机变量。使用诸如Kolmogorov–Smirnov (KS)检验之类的假设检验，对照均值为 $0$、标准差为 $\\sqrt{T}$ 的正态分布，评估来自两个副本的汇合速度样本是否与此分布一致。同时计算速度的样本方差，并将其与 $T$ 在一个相对容差范围内进行比较。\n    -   副本一致性测试：令 $A(t)$ 为可观测量 $x(t)$。对于副本 $i \\in \\{1, 2\\}$，计算其在老化阶段后的轨迹上的时间平均值 $\\bar{A}_i$、其样本方差 $s_i^2$ 以及其积分自相关时间 $\\tau_{\\mathrm{int}, i}$，公式如下\n        $$\n        \\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{t=1}^{t^\\star} \\rho(t), \\quad \\rho(t) = \\frac{C(t)}{C(0)},\n        $$\n        其中 $C(t)$ 是自协方差函数，当 $\\rho(t)$ 首次为非正值或达到最大可用延迟时，截断求和。通过以下公式估算 $\\bar{A}_i$ 的标准误差\n        $$\n        \\sigma_i \\approx \\sqrt{\\frac{s_i^2 \\, 2 \\tau_{\\mathrm{int}, i}}{N_i}},\n        $$\n        其中 $N_i$ 是副本 $i$ 中老化阶段后的样本数。使用这两个副本，计算 $z$-score\n        $$\n        z_{\\mathrm{rep}} = \\frac{|\\bar{A}_1 - \\bar{A}_2|}{\\sqrt{\\sigma_1^2 + \\sigma_2^2}},\n        $$\n        以评估两个独立的时间平均值是否在估计的不确定性范围内一致。\n    -   与正则期望值的一致性：对于每个系统，通过对权重 $e^{-U(x)/T}$ 在 $x \\in (-\\infty, \\infty)$ 上进行数值积分，计算精确的正则期望值 $\\langle x \\rangle$。\n        $$\n        \\langle x \\rangle = \\frac{\\int_{-\\infty}^{\\infty} x \\, e^{-U(x)/T} \\, dx}{\\int_{-\\infty}^{\\infty} e^{-U(x)/T} \\, dx}.\n        $$\n        使用根据汇合标准误差（该误差使用积分自相关时间计算）计算出的 $z$-score，将来自两个副本的汇合时间平均值 $\\bar{A}$ 与此理论值进行比較。\n    -   有限时间趋势测试：计算汇合轨迹后半部分的累积移动平均值 $\\bar{A}(t)$，并使用最小二乘法对 $\\bar{A}(t)$ 与时间 $t$ 的关系进行直线拟合。使用线性回归得到的斜率标准误差，计算斜率的 $t$-统计量。一个统计上显著的非零斜率表明时间平均值仍在漂移，这与有限时间偏差一致，而非遍历性破缺。\n\n对于每个测试用例，您的程序必须根据以下规则返回一个单一的整数分类代码：\n-   如果正则速度边际测试失败（KS检验在显著性水平 $\\alpha = 10^{-3}$ 下拒绝原假设，或速度的样本方差与 $T$ 的差异超过 $10\\%$），则输出 $0$。\n-   否则，如果副本之间相互不一致（即 $z_{\\mathrm{rep}}  3$），表明在采样时间尺度上缺乏遍历性或混合性破缺，则输出 $3$。\n-   否则，如果汇合的时间平均值与理论正则期望值显著不同（即相应的 $z$-score 超过 $3$），并且有限时间趋势测试表明斜率在统计上显著（绝对 $t$-统计量大于 $3$），表明存在有限时间偏差，则输出 $2$。\n-   否则，输出 $1$，表明轨迹与正则采样一致，且未检测到混合性破缺的证据。\n\n数值和物理单位：使用约化单位，其中 $k_{\\mathrm{B}} = 1$ 且 $m = 1$。时间以与离散化参数 $dt$ 一致的任意单位进行测量。任何输出都不得包含明确的单位。\n\n测试套件：将您的程序应用于以下三种情况。对于每种情况，使用指定的参数模拟两个独立的副本。丢弃指定数量的初始步骤作为老化阶段。为副本使用独立的随机数种子。\n\n-   情况 A（充分混合的谐振子）：\n    -   势能：$U(x) = \\tfrac{1}{2} k x^2$，其中 $k = 1$。\n    -   温度：$T = 1$。\n    -   摩擦系数：$\\gamma = 1$。\n    -   时间步长：$dt = 0.005$。\n    -   每个副本的总步数：$30000$。\n    -   每个副本的老化步数：$5000$。\n    -   初始条件：两个副本均为 $x(0) = 0$, $v(0) = 0$。\n    -   使用两个不同的随机种子。\n\n-   情况 B（非遍历性双阱，在时间尺度上被困）：\n    -   势能：$U(x) = a(x^2 - b^2)^2 + c x$，其中 $a = 5$, $b = 1.5$, $c = 0.3$。\n    -   温度：$T = 0.2$。\n    -   摩擦系数：$\\gamma = 1$。\n    -   时间步长：$dt = 0.002$。\n    -   每个副本的总步数：$20000$。\n    -   每个副本的老化步数：$2000$。\n    -   初始条件：副本1从 $x(0) = -b$, $v(0) = 0$ 开始；副本2从 $x(0) = +b$, $v(0) = 0$ 开始。\n    -   使用两个不同的随机种子。\n\n-   情况 C（遍历性但存在可用时间尺度上的有限时间偏差）：\n    -   势能：$U(x) = a(x^2 - b^2)^2 + c x$，其中 $a = 1$, $b = 1$, $c = 0.2$。\n    -   温度：$T = 0.5$。\n    -   摩擦系数：$\\gamma = 1$。\n    -   时间步长：$dt = 0.002$。\n    -   每个副本的总步数：$6000$。\n    -   每个副本的老化步数：$1000$。\n    -   初始条件：两个副本均从 $x(0) = -b$, $v(0) = 0$ 开始。\n    -   使用两个不同的随机种子。\n\n实现约束：\n-   积分方案、统计估计量和假设检验必须以数值稳定的方式实现。对于 $\\langle x \\rangle$ 的数值积分，使用一种稳定的方法，通过一个恒定的参考能量来平移势能以避免溢出；该平移在分子和分母之间会相互抵消。\n-   所有阈值必须严格按照规定实现：Kolmogorov–Smirnov速度检验的 $\\alpha = 10^{-3}$，速度方差检查的 $10\\%$ 相对容差，以及 $z$-scores 和斜率 $t$-统计量的临界值均为 $3$。\n\n最终输出格式：\n-   您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_A, r_B, r_C]$），$r_A$、$r_B$ 和 $r_C$ 分别是情况A、B和C的整数分类代码。\n\n您的程序必须是自包含的，并且不得接受任何输入。它必须仅使用执行环境中指定的库。所有数值答案必须在最终打印的列表中表示为整数。", "solution": "所提供的问题陈述是有效的。它在科学上基于统计力学和分子动力学的原理，问题阐述清晰，具有明确的目标和约束，且没有矛盾或含糊之处。任务是设计并实现一个数值诊断套件，用以评估分子动力学轨迹的收敛性和遍历性。我们将继续提供完整的解决方案。\n\n该解决方案围绕一系列应用于通过Langevin动力学生成的轨迹的统计检验构建。每个检验都针对正则采样的特定方面，这些方面由遍历性假说所规定。遍历性假说假定，对于足够长的轨迹，可观测量的长时间平均值会收敛到其在相应统计系综中的系综平均值——在本例中，即正则(NVT)系综。我们的诊断框架旨在检测对此原则的违反，并区分两种主要失败模式：遍历性破缺（或混合不良）和有限时间偏差（收敛缓慢）。\n\n首先，我们必须生成动力学数据。系统根据一维Langevin动力学演化，其运动方程由下式给出：\n$$\nm \\frac{d^2x}{dt^2} = -\\frac{dU(x)}{dx} - \\gamma m v + \\sqrt{2 \\gamma m k_{\\mathrm{B}} T} \\, \\eta(t)\n$$\n在指定的约化单位（$m=1$, $k_{\\mathrm{B}}=1$）下，该方程简化为：\n$$\n\\frac{dv}{dt} = -\\frac{dU(x)}{dx} - \\gamma v + \\sqrt{2 \\gamma T} \\, \\eta(t)\n$$\n为了对这些方程进行数值积分，我们采用了BAOAB分裂方案，这是一种流行且稳健的Langevin动力学算法。该方法时间可逆，并能保持正确的正则分布。该方案将一个时间步长 $dt$ 离散化为一系列更新步骤：\n1.  **B-步：** 将位置推进半个时间步长：$x \\leftarrow x + v \\frac{dt}{2}$。\n2.  **A-步：** 因保守力作用推进速度：$v \\leftarrow v - \\frac{dU(x)}{dx} \\frac{dt}{2}$。\n3.  **O-步：** 因恒温器（摩擦力和随机力）作用推进速度。这对应于速度的Ornstein-Uhlenbeck过程的精确解：$v \\leftarrow v e^{-\\gamma dt} + \\sqrt{T(1 - e^{-2\\gamma dt})} \\mathcal{N}(0,1)$，其中 $\\mathcal{N}(0,1)$ 是一个标准正态随机数。\n4.  **A-步：** 再次因保守力作用推进速度：$v \\leftarrow v - \\frac{dU(x)}{dx} \\frac{dt}{2}$。\n5.  **B-步：** 将位置推进最后半个时间步长：$x \\leftarrow x + v \\frac{dt}{2}$。\n\n对于每个测试案例，我们从指定的初始条件开始，但使用不同的随机数种子为随机力项生成两条独立的轨迹（副本）。每条轨迹的初始部分作为老化（burn-in）阶段被丢弃，以使系统达到平衡。\n\n分析遵循一个严格的层级流程：\n\n**1. 正则速度边际测试（代码 $0$）：**\n基础检查是恒温器是否正确地维持了系统的温度。在正则系综中，速度分布是Maxwell-Boltzmann分布，对于一维系统，这是一个均值为 $0$、方差为 $T$ 的高斯分布（因为 $m=1, k_{\\mathrm{B}}=1$）。我们使用来自两个老化后副本的汇合速度样本，通过两种方式对此进行测试：\n-   **分布形状：** 执行Kolmogorov-Smirnov (KS)检验，以比较采样速度的经验累积分布函数(CDF)与 $\\mathcal{N}(0, T)$ 的理论CDF。如果p值低于显著性水平 $\\alpha = 10^{-3}$，我们拒绝速度是从目标分布中抽取的原假设。\n-   **分布方差：** 我们计算速度的样本方差。均分定理规定，平均动能 $\\frac{1}{2}m \\langle v^2 \\rangle$ 应等于 $\\frac{1}{2}k_{\\mathrm{B}}T$。对于 $m=1, k_{\\mathrm{B}}=1$，这意味着 $\\langle v^2 \\rangle = T$。我们检查样本方差与 $T$ 的偏差是否超过 $10\\%$ 的相对容差。\n其中任何一项测试失败都表明模拟在对正则系综采样方面存在根本性失败，从而归类为代码 $0$。\n\n**2. 副本一致性测试（代码 $3$）：**\n如果速度分布正确，我们接下来测试遍历性。我们运行两个独立的副本，看它们是否采样到相同的统计特性。如果系统是遍历的，那么来自两个副本的可觀测量的时间平均值应收敛到相同的系综平均值，因此在统计上是无法区分的。我们使用位置 $A(t) = x(t)$作为我们的可觀测量。\n对于每个副本 $i \\in \\{1, 2\\}$，我们计算均值 $\\bar{A}_i$ 及其标准误差 $\\sigma_i$。由于轨迹中的连续样本是相关的，均值的标准误差不仅仅是样本标准差除以 $\\sqrt{N_i}$。相反，它需要通过积分自相关时间 $\\tau_{\\mathrm{int}, i}$ 进行校正：\n$$\n\\sigma_i^2 \\approx \\frac{s_i^2 \\, 2 \\tau_{\\mathrm{int}, i}}{N_i}\n$$\n其中 $s_i^2$ 是副本 $i$ 中 $A$ 的样本方差，$N_i$ 是样本数量。积分自相关时间由归一化自协方差函数 $\\rho(t)$ 计算得出：\n$$\n\\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{t=1}^{t^\\star} \\rho(t)\n$$\n求和在 $\\rho(t)$ 变为非正值的第一个延迟 $t$ 处截断，这是一种减少ACF尾部噪声的标准启发式方法。\n然后我们计算一个 $z$-score 来量化两个副本均值之间的差异：\n$$\nz_{\\mathrm{rep}} = \\frac{|\\bar{A}_1 - \\bar{A}_2|}{\\sqrt{\\sigma_1^2 + \\sigma_2^2}}\n$$\n一个大的 $z$-score（具体来说是 $z_{\\mathrm{rep}}  3$）意味着两个副本产生了统计上显著不同的平均值，这是一个强烈的迹象，表明它们被困在了相空间的不同区域，系统在模拟时间尺度上没有混合。这表示遍历性破缺，并归类为代码 $3$。\n\n**3. 有限时间偏差测试（代码 $2$）：**\n如果副本是一致的，这表明它们正在对相空间的同一区域进行采样。然而，模拟可能仍然太短，未能完全收敛到真正的正则平均值。这被称为有限时间偏差。我们通过检查两个同时存在的条件来测试这一点：\n-   **与已知理论值不一致：** 将两个副本的汇合平均值 $\\bar{A}$ 与精确的正则期望值 $\\langle A \\rangle = \\langle x \\rangle$ 进行比较。理论平均值通过数值积分计算：\n    $$\n    \\langle x \\rangle = \\frac{\\int_{-\\infty}^{\\infty} x \\, e^{-U(x)/T} \\, dx}{\\int_{-\\infty}^{\\infty} e^{-U(x)/T} \\, dx}\n    $$\n    计算一个 $z$-score, $z_{\\text{canon}} = \\frac{|\\bar{A} - \\langle x \\rangle|}{\\sigma_{\\text{pool}}}$，其中 $\\sigma_{\\text{pool}}$ 是汇合均值的标准误差。显著的偏差 ($z_{\\text{canon}}  3$) 表明时间平均值尚未收敛到系综平均值。\n-   **持续漂移：** 我们检查数据中是否存在残留趋势。在汇合轨迹的后半部分计算可观测量的累积移动平均值 $\\bar{A}(t)$。对 $\\bar{A}(t)$ 与时间 $t$ 进行线性回归。一个统计上显著的非零斜率表明平均值仍在系统性地漂移。我们使用斜率的 $t$-统计量（斜率除以其标准误差）进行此测试。$|t_{\\text{slope}}|  3$ 的值被认为是显著的。\n\n如果两个条件都满足——汇合平均值与理论值不同，并且存在显著的漂移——我们则将该运行归类为表现出有限时间偏差，代码为 $2$。这个特征将缓慢收敛与遍历性破缺区分开来，在遍历性破缺的情况下，副本会不一致。\n\n**4. 一致的正则采样（代码 $1$）：**\n如果一条轨迹通过了所有前面的测试，我们得出结论，没有证据表明恒温器设置不正确、遍历性破缺或存在显著的有限时间偏差。该模拟被认为与正确的正则采样一致，并被賦予分类代码 $1$。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import kstest, linregress\nfrom scipy.integrate import quad\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Main function to run the diagnostic suite on all test cases and print results.\n    \"\"\"\n\n    # Test cases parameter definitions\n    test_cases = [\n        {\n            \"name\": \"Case A (Harmonic)\",\n            \"potential\": lambda x, k=1: 0.5 * k * x**2,\n            \"force\": lambda x, k=1: -k * x,\n            \"potential_params\": {\"k\": 1},\n            \"T\": 1.0,\n            \"gamma\": 1.0,\n            \"dt\": 0.005,\n            \"total_steps\": 30000,\n            \"burn_in_steps\": 5000,\n            \"initial_conditions\": [(0.0, 0.0), (0.0, 0.0)],\n            \"seed\": 101,\n            \"theory_mean_x\": 0.0,\n        },\n        {\n            \"name\": \"Case B (Non-ergodic)\",\n            \"potential\": lambda x, a=5, b=1.5, c=0.3: a * (x**2 - b**2)**2 + c * x,\n            \"force\": lambda x, a=5, b=1.5, c=0.3: -4 * a * x * (x**2 - b**2) - c,\n            \"potential_params\": {\"a\": 5, \"b\": 1.5, \"c\": 0.3},\n            \"T\": 0.2,\n            \"gamma\": 1.0,\n            \"dt\": 0.002,\n            \"total_steps\": 20000,\n            \"burn_in_steps\": 2000,\n            \"initial_conditions\": [(-1.5, 0.0), (1.5, 0.0)],\n            \"seed\": 202,\n            \"theory_mean_x\": \"compute\",\n        },\n        {\n            \"name\": \"Case C (Finite-time bias)\",\n            \"potential\": lambda x, a=1, b=1, c=0.2: a * (x**2 - b**2)**2 + c * x,\n            \"force\": lambda x, a=1, b=1, c=0.2: -4 * a * x * (x**2 - b**2) - c,\n            \"potential_params\": {\"a\": 1, \"b\": 1, \"c\": 0.2},\n            \"T\": 0.5,\n            \"gamma\": 1.0,\n            \"dt\": 0.002,\n            \"total_steps\": 6000,\n            \"burn_in_steps\": 1000,\n            \"initial_conditions\": [(-1.0, 0.0), (-1.0, 0.0)],\n            \"seed\": 303,\n            \"theory_mean_x\": \"compute\",\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result_code = run_diagnostic_case(case)\n        results.append(result_code)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_diagnostic_case(case_params):\n    \"\"\"\n    Runs the full diagnostic suite for a single test case.\n    \"\"\"\n    # --- 1. Generate Trajectories ---\n    trajectories = []\n    for i in range(2):  # Two replicas\n        seed = case_params[\"seed\"] + i\n        rng = np.random.default_rng(seed)\n        x0, v0 = case_params[\"initial_conditions\"][i]\n        \n        traj_x, traj_v = langevin_integrator(\n            x0, v0, case_params[\"force\"], case_params[\"potential_params\"],\n            case_params[\"T\"], case_params[\"gamma\"], case_params[\"dt\"],\n            case_params[\"total_steps\"], rng\n        )\n        # Discard burn-in\n        burn_in = case_params[\"burn_in_steps\"]\n        trajectories.append((traj_x[burn_in:], traj_v[burn_in:]))\n    \n    x1, v1 = trajectories[0]\n    x2, v2 = trajectories[1]\n\n    # --- 2. Perform Diagnostics ---\n    \n    # Code 0: Canonical Velocity Marginal Test\n    v_pooled = np.concatenate((v1, v2))\n    ks_stat, ks_pvalue = kstest(v_pooled, 'norm', args=(0, np.sqrt(case_params[\"T\"])))\n    \n    v_var = np.var(v_pooled)\n    v_var_rel_diff = np.abs(v_var - case_params[\"T\"]) / case_params[\"T\"]\n\n    if ks_pvalue  1e-3 or v_var_rel_diff  0.1:\n        return 0\n\n    # Code 3: Replica Consistency Test\n    stats1 = compute_observable_stats(x1)\n    stats2 = compute_observable_stats(x2)\n    \n    mean_diff = np.abs(stats1['mean'] - stats2['mean'])\n    pooled_se = np.sqrt(stats1['se']**2 + stats2['se']**2)\n    \n    z_rep = mean_diff / pooled_se if pooled_se  0 else np.inf\n    \n    if z_rep  3.0:\n        return 3\n\n    # Code 2: Finite-Time Bias Test\n    # Condition 1: Inconsistency with canonical expectation\n    if case_params[\"theory_mean_x\"] == \"compute\":\n        theory_mean_x = compute_canonical_average(\n            case_params[\"potential\"], case_params[\"potential_params\"], case_params[\"T\"]\n        )\n    else:\n        theory_mean_x = case_params[\"theory_mean_x\"]\n\n    x_pooled = np.concatenate((x1, x2))\n    pooled_stats = compute_observable_stats(x_pooled)\n    \n    z_canon = np.abs(pooled_stats['mean'] - theory_mean_x) / pooled_stats['se'] if pooled_stats['se']  0 else np.inf\n    \n    inconsistent_with_theory = z_canon  3.0\n\n    # Condition 2: Finite-time trend\n    second_half_start = len(x_pooled) // 2\n    x_trend_data = x_pooled[second_half_start:]\n    \n    if len(x_trend_data)  2:\n        running_avg = np.cumsum(x_trend_data) / (np.arange(len(x_trend_data)) + 1)\n        time_points = np.arange(len(x_trend_data))\n        \n        # Linear regression can fail with constant data\n        if np.ptp(running_avg)  1e-9:\n            lin_reg = linregress(time_points, running_avg)\n            t_stat_slope = np.abs(lin_reg.slope / lin_reg.stderr) if lin_reg.stderr  0 else 0.0\n        else:\n            t_stat_slope = 0.0\n        \n        has_significant_trend = t_stat_slope  3.0\n    else:\n        has_significant_trend = False\n\n    if inconsistent_with_theory and has_significant_trend:\n        return 2\n\n    # Code 1: Consistent Canonical Sampling\n    return 1\n\n\ndef langevin_integrator(x0, v0, force_func, force_params, T, gamma, dt, n_steps, rng):\n    \"\"\"\n    BAOAB Langevin integrator.\n    \"\"\"\n    x_traj, v_traj = np.zeros(n_steps), np.zeros(n_steps)\n    x, v = x0, v0\n    \n    c1 = np.exp(-gamma * dt)\n    c2 = np.sqrt(T * (1 - c1**2))\n\n    for i in range(n_steps):\n        # B\n        x = x + v * dt / 2.0\n        # A\n        f = force_func(x, **force_params)\n        v = v + f * dt / 2.0\n        # O\n        v = c1 * v + c2 * rng.normal()\n        # A\n        f = force_func(x, **force_params)\n        v = v + f * dt / 2.0\n        # B\n        x = x + v * dt / 2.0\n        \n        x_traj[i], v_traj[i] = x, v\n    \n    return x_traj, v_traj\n\n\ndef compute_acf(series):\n    \"\"\"\n    Computes the autocorrelation function using FFT.\n    \"\"\"\n    n = len(series)\n    x = series - np.mean(series)\n    \n    # Pad to next power of 2 for performance\n    fft_len = 2**int(np.ceil(np.log2(2 * n - 1)))\n    \n    f = np.fft.fft(x, n=fft_len)\n    acf_full = np.fft.ifft(f * np.conj(f)).real\n    \n    # Normalize\n    acf_normalized = acf_full[:n] / acf_full[0]\n    return acf_normalized\n\n\ndef compute_observable_stats(series):\n    \"\"\"\n    Computes mean, variance, integrated autocorrelation time, and standard error.\n    \"\"\"\n    n = len(series)\n    if n  2:\n        return {'mean': np.mean(series), 'var': 0, 'tau': 0, 'se': np.inf}\n\n    mean = np.mean(series)\n    var = np.var(series, ddof=1)\n    \n    if var  1e-12: # Constant series\n        return {'mean': mean, 'var': var, 'tau': 0, 'se': 0}\n\n    acf = compute_acf(series)\n    \n    # Truncate sum for tau_int at first non-positive value\n    positive_acf = np.where(acf  0)[0]\n    # Find first non-consecutive index, indicating end of initial positive part\n    if len(positive_acf)  1:\n        first_zero_crossing_idx = np.where(np.diff(positive_acf)  1.5)[0]\n        if len(first_zero_crossing_idx)  0:\n            t_star = positive_acf[first_zero_crossing_idx[0]]\n        else:\n            t_star = len(acf) -1\n    else:\n        t_star = 0\n            \n    # Per problem spec: tau_int = 1/2 + sum_{t=1}^{t*} rho(t)\n    tau_int = 0.5 + np.sum(acf[1:t_star + 1])\n    \n    # Guard against negative tau due to noise\n    if tau_int  0.5:\n        tau_int = 0.5\n\n    # Standard error of the mean for correlated data\n    se = np.sqrt(2 * tau_int * var / n) if n  0 else np.inf\n    \n    return {'mean': mean, 'var': var, 'tau': tau_int, 'se': se}\n\n\ndef compute_canonical_average(potential_func, potential_params, T):\n    \"\"\"\n    Computes the exact canonical average x by numerical integration.\n    \"\"\"\n    # Find minimum of potential to use as reference for numerical stability\n    res = minimize_scalar(lambda x: potential_func(x, **potential_params))\n    u_min = res.fun\n\n    def integrand_num(x):\n        u = potential_func(x, **potential_params)\n        return x * np.exp(-(u - u_min) / T)\n\n    def integrand_den(x):\n        u = potential_func(x, **potential_params)\n        return np.exp(-(u - u_min) / T)\n\n    # Use a reasonable integration range\n    # For the given potentials, [-10, 10] is more than sufficient\n    num, _ = quad(integrand_num, -10, 10)\n    den, _ = quad(integrand_den, -10, 10)\n    \n    return num / den if den != 0 else 0.0\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3452525"}]}