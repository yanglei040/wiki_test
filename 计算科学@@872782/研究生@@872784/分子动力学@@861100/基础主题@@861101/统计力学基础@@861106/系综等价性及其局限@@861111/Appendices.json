{"hands_on_practices": [{"introduction": "理论模型是理解系综不等价现象的基石。居里-魏斯（Curie-Weiss）平均场伊辛（Ising）模型便是一个经典的范例，它通过一个简化的多体系统，清晰地揭示了在相变点附近系综等价性为何会失效。这项练习 [@problem_id:3410966] 将引导您推导微正则熵和正则自由能，并从熵函数非凹性的角度，精确定位不等价性的热力学根源。这是掌握系综不等价背后物理机制的一项基础性训练。", "problem": "考虑居里-外斯平均场伊辛模型，该模型包含$N$个自旋$\\sigma_{i}\\in\\{-1,+1\\}$，相互作用强度为$J0$，外磁场为$h\\in\\mathbb{R}$。其哈密顿量为\n$$\nH_{N}(\\sigma) \\;=\\; -\\,\\frac{J}{2N}\\,\\Big(\\sum_{i=1}^{N}\\sigma_{i}\\Big)^{2}\\;-\\;h\\sum_{i=1}^{N}\\sigma_{i}.\n$$\n令单位自旋磁化强度为$m=\\frac{1}{N}\\sum_{i=1}^{N}\\sigma_{i}$，单位自旋能量为$e=\\frac{1}{N}H_{N}(\\sigma)$。在热力学极限$N\\to\\infty$下进行计算，并根据需要使用标准的组合计数和大偏差（拉普拉斯）原理。\n\n(a) 仅从微正则熵和哈密顿量的定义出发，推导微正则熵密度$s(e,m)$，其定义为具有能量密度$e$和磁化强度$m$的构型数的主要指数增长率。明确指出$s(e,m)$为有限值的$(e,m)$定义域，并给出在该定义域上的显式表达式。\n\n(b) 使用正则系综，在逆温$\\beta0$下，将热力学极限中的正则自由能密度$f(\\beta,h)$表示为一个关于$m$的变分问题。你的推导必须从正则配分函数开始，通过将对微观态的求和简化为对磁化强度的求和（由其简并度和玻尔兹曼因子加权）来进行。给出$f(\\beta,h)$的最终闭合形式变分表达式。\n\n(c) 专用于零场$h=0$的情况。分析$f(\\beta,0)$变分表达式中目标函数在$m=0$处关于$m$的曲率，并确定它在何时不再是凹的，这标志着全局凹性的丧失以及由熵贡献的非凹性驱动的$m$约束系综不等价的开始。作为最终答案，提供临界逆温$\\beta_{c}$关于$J$的解析表达式，该表达式区分了凹区间和非凹区间。无需四舍五入；以单一闭合形式表达式报告$\\beta_c$，不带单位。", "solution": "该问题被验证为具有科学依据、问题明确且客观。这是一个关于居里-外斯模型的统计力学标准问题，所有术语和要求的推导都是该领域的常规内容。我们开始解答。\n\n(a) 微正则熵密度$s(e,m)$的推导。\n\n系统的状态由$N$个自旋的构型$\\sigma = \\{\\sigma_1, \\dots, \\sigma_N\\}$定义，其中$\\sigma_i \\in \\{-1, +1\\}$。单位自旋磁化强度由$m = \\frac{1}{N}\\sum_{i=1}^{N}\\sigma_{i}$给出。设$N_+$是值为$+1$的自旋数，而$N_-$是值为$-1$的自旋数。我们有以下关系：\n$N = N_+ + N_-$\n$Nm = N_+ - N_-$\n用$N$和$m$求解$N_+$和$N_-$得到：\n$$N_+ = N\\frac{1+m}{2} \\quad \\text{和} \\quad N_- = N\\frac{1-m}{2}$$\n为使$N_+$和$N_-$为0到$N$之间的整数，$m$的允许值是离散的，范围从$-1$到$1$，步长为$2/N$。\n\n系统的哈密顿量为$H_{N}(\\sigma) = -\\frac{J}{2N}\\left(\\sum_{i=1}^{N}\\sigma_{i}\\right)^{2} - h\\sum_{i=1}^{N}\\sigma_{i}$。它仅取决于总磁化强度$\\sum_{i=1}^{N}\\sigma_{i}=Nm$。因此，对于给定的磁化强度$m$，所有具有该磁化强度的微观态都具有相同的能量：\n$$H_N(m) = -\\frac{J}{2N}(Nm)^2 - h(Nm) = -N\\left(\\frac{J}{2}m^2 + hm\\right)$$\n因此，单位自旋能量$e = H_N/N$是磁化强度$m$的确定性函数：\n$$e(m) = -\\frac{J}{2}m^2 - hm$$\n这一关系意味着对于该模型，宏观变量$e$和$m$不是独立的。一个具有磁化强度$m$的构型必然具有能量密度$e(m)$。\n\n微正则熵密度$s(e,m)$被定义为具有给定能量密度$e$和磁化强度$m$的构型数$\\Omega(N,e,m)$的主要指数增长率。\n$$s(e,m) = \\lim_{N\\to\\infty} \\frac{1}{N}\\ln \\Omega(N, e, m)$$\n由于约束$e=e(m)$，构型数仅在该关系定义的曲线上非零。如果$e \\neq -\\frac{J}{2}m^2 - hm$，则$\\Omega(N,e,m) = 0$，因此$s(e,m) = -\\infty$。\n如果$e = -\\frac{J}{2}m^2 - hm$，那么构型集就是所有具有磁化强度$m$的构型的集合。此类构型的数量由在$N$个位置上排列$N_+$个上自旋的二项式系数给出：\n$$\\Omega(N, e(m), m) = \\binom{N}{N_+} = \\binom{N}{N\\frac{1+m}{2}}$$\n我们现在使用斯特林近似计算二项式系数的对数来计算熵密度，$\\ln \\binom{N}{k} \\approx -N [p\\ln p + (1-p)\\ln(1-p)]$，其中$p=k/N$且$N$很大。设$p = \\frac{1+m}{2}$，我们得到：\n$$s(m) = \\lim_{N\\to\\infty} \\frac{1}{N}\\ln\\binom{N}{N\\frac{1+m}{2}} = -\\left(\\frac{1+m}{2}\\right)\\ln\\left(\\frac{1+m}{2}\\right) - \\left(\\frac{1-m}{2}\\right)\\ln\\left(\\frac{1-m}{2}\\right)$$\n$s(e,m)$为有限值的定义域要求$m \\in [-1, 1]$，以使对数的参数非负且自旋计数有效。熵在$m=\\pm 1$时为零，在$m\\in(-1,1)$时为正。\n因此，微正则熵密度$s(e,m)$由下式给出：\n$$s(e,m) = \\begin{cases} -\\left(\\frac{1+m}{2}\\right)\\ln\\left(\\frac{1+m}{2}\\right) - \\left(\\frac{1-m}{2}\\right)\\ln\\left(\\frac{1-m}{2}\\right)  \\text{如果 } e = -\\frac{J}{2}m^2 - hm \\\\ -\\infty  \\text{其他情况} \\end{cases}$$\n$s(e,m)$为有限值的定义域是$(e,m)$平面上的一维曲线，由$e = -\\frac{J}{2}m^2 - hm$定义，其中$m \\in [-1, 1]$。\n\n(b) 正则自由能密度$f(\\beta,h)$的变分表达式。\n\n逆温$\\beta$下的正则配分函数为$Z_N(\\beta, h) = \\sum_{\\sigma} \\exp(-\\beta H_N(\\sigma))$。由于哈密顿量$H_N$仅取决于磁化强度$m$，我们可以将对所有$2^N$个自旋构型的求和重写为对所有可能磁化强度值的求和，并按每个$m$的构型数$\\Omega(N,m)$加权：\n$$Z_N(\\beta, h) = \\sum_{m} \\Omega(N,m) \\exp(-\\beta H_N(m))$$\n代入$\\Omega(N,m)$（在大$N$极限下）和$H_N(m)$的表达式：\n$$Z_N(\\beta, h) \\approx \\sum_{m} \\exp(N s(m)) \\exp\\left(-\\beta N\\left(-\\frac{J}{2}m^2 - hm\\right)\\right) = \\sum_{m} \\exp\\left(N\\left[s(m) + \\beta\\frac{J}{2}m^2 + \\beta hm\\right]\\right)$$\n在热力学极限$N\\to\\infty$下，和由指数最大的项主导。这是拉普拉斯方法的应用。该和可以由其最大项（或通过被积函数指数的最大值计算的积分）来近似。\n$$\\lim_{N\\to\\infty} \\frac{1}{N}\\ln Z_N(\\beta, h) = \\max_{m \\in [-1,1]} \\left\\{ s(m) + \\beta\\frac{J}{2}m^2 + \\beta hm \\right\\}$$\n正则自由能密度定义为$f(\\beta, h) = \\lim_{N\\to\\infty} -\\frac{1}{N\\beta}\\ln Z_N(\\beta,h)$。因此：\n$$f(\\beta, h) = -\\frac{1}{\\beta} \\max_{m \\in [-1,1]} \\left\\{ s(m) + \\beta\\frac{J}{2}m^2 + \\beta hm \\right\\}$$\n这可以重写为一个最小化问题：\n$$f(\\beta, h) = \\min_{m \\in [-1,1]} \\left\\{ -\\frac{1}{\\beta}s(m) - \\frac{J}{2}m^2 - hm \\right\\}$$\n代入(a)部分中$s(m)$的显式公式，我们得到自由能密度的最终变分表达式：\n$$f(\\beta, h) = \\min_{m \\in [-1,1]} \\left\\{ \\frac{1}{\\beta}\\left[\\left(\\frac{1+m}{2}\\right)\\ln\\left(\\frac{1+m}{2}\\right) + \\left(\\frac{1-m}{2}\\right)\\ln\\left(\\frac{1-m}{2}\\right)\\right] - \\frac{J}{2}m^2 - hm \\right\\}$$\n这将$f(\\beta,h)$表示为单个变分参数$m$的函数的最小值。\n\n(c) 曲率分析与临界逆温$\\beta_c$的确定。\n\n我们专用于零外场的情况，$h=0$。$f(\\beta, 0)$变分问题中的目标函数是类金兹堡-朗道自由能泛函：\n$$\\phi(m; \\beta) = \\frac{1}{\\beta}\\left[\\left(\\frac{1+m}{2}\\right)\\ln\\left(\\frac{1+m}{2}\\right) + \\left(\\frac{1-m}{2}\\right)\\ln\\left(\\frac{1-m}{2}\\right)\\right] - \\frac{J}{2}m^2$$\n问题要求分析此目标函数在$m=0$处的曲率。曲率由二阶导数$\\frac{d^2\\phi}{dm^2}$给出。我们首先计算熵部分的导数。令$g(m) = \\left(\\frac{1+m}{2}\\right)\\ln\\left(\\frac{1+m}{2}\\right) + \\left(\\frac{1-m}{2}\\right)\\ln\\left(\\frac{1-m}{2}\\right)$。\n关于$m$的一阶导数是：\n$$\\frac{dg}{dm} = \\frac{1}{2}\\left[\\ln\\left(\\frac{1+m}{2}\\right)+1\\right] - \\frac{1}{2}\\left[\\ln\\left(\\frac{1-m}{2}\\right)+1\\right] = \\frac{1}{2}\\ln\\left(\\frac{1+m}{1-m}\\right) = \\text{arctanh}(m)$$\n二阶导数是：\n$$\\frac{d^2g}{dm^2} = \\frac{d}{dm} \\text{arctanh}(m) = \\frac{1}{1-m^2}$$\n现在，我们计算完整目标函数$\\phi(m; \\beta)$的二阶导数：\n$$\\frac{d^2\\phi}{dm^2} = \\frac{1}{\\beta}\\frac{d^2g}{dm^2} - J = \\frac{1}{\\beta(1-m^2)} - J$$\n我们在$m=0$点计算该曲率：\n$$\\frac{d^2\\phi}{dm^2}\\bigg|_{m=0} = \\frac{1}{\\beta} - J$$\n问题要求确定目标函数$\\phi(m;\\beta)$在$m=0$处何时“不再是凹的”。如果一个函数在某点的二阶导数小于或等于零，则该函数在该点是局部凹的。因此，$\\phi(m;\\beta)$在$m=0$处是凹的，如果：\n$$\\frac{1}{\\beta} - J \\leq 0 \\quad \\implies \\quad 1 \\leq \\beta J \\quad \\implies \\quad \\beta \\geq \\frac{1}{J}$$\n这对应于低温相，此时$m=0$是一个不稳定点（局部极大值），并出现铁磁有序。当此条件被违反时，即曲率变为正时，函数在$m=0$处“不再是凹的”。转变发生在曲率恰好为零的临界点。\n$$\\frac{1}{\\beta_c} - J = 0$$\n求解临界逆温$\\beta_c$得到：\n$$\\beta_c = \\frac{1}{J}$$\n对于$\\beta  \\beta_c$（高温），$m=0$处的曲率为正，使得目标函数局部凸，从而在$m=0$处产生一个稳定的顺磁态。对于$\\beta > \\beta_c$（低温），曲率为负，目标函数局部凹，$m=0$的状态变得不稳定，导致向$m \\neq 0$的铁磁态发生相变。", "answer": "$$\\boxed{\\frac{1}{J}}$$", "id": "3410966"}, {"introduction": "在理解了不等价的理论基础后，我们将注意力转向连接不同系综的数学桥梁——拉普拉斯变换。这项动手编程练习 [@problem_id:3410951] 将带您实践如何从给定的微正则态密度出发，通过数值积分计算正则配分函数，并特别关注计算过程中的数值稳定性问题。更重要的是，通过比较精确的数值结果与鞍点近似（即系综等价性的数学体现），您可以直观地检验等价性成立的条件及其失效的场景，从而深化对两个系综关系的理解。", "problem": "给定在离散能量网格上定义的微正则态密度函数 $\\Omega(E)$，这些函数可以通过王-兰道 (WL) 采样获得。你的任务是通过拉普拉斯变换重构正则热力学，并评估计算的数值稳定性以及鞍点近似的准确性，该近似在热力学极限下代表了系综等价性。所有量均采用无量纲单位，玻尔兹曼常数 $k_{\\mathrm B}=1$，因此能量 $E$、逆温度 $\\beta$ 和熵 $S(E)=\\ln \\Omega(E)$ 均为无量纲。不使用也不需要其他物理单位。\n\n使用的基本定义：\n- 正则配分函数由拉普拉斯变换定义：$Z(\\beta)=\\int_{0}^{\\infty}\\Omega(E)\\,\\mathrm{e}^{-\\beta E}\\,\\mathrm{d}E$。\n- 正则平均能量为 $U(\\beta)=\\int_{0}^{\\infty} E \\, \\pi_{\\beta}(E) \\,\\mathrm{d}E$，其中 $\\pi_{\\beta}(E)=\\Omega(E)\\,\\mathrm{e}^{-\\beta E}/Z(\\beta)$ 是归一化的正则能量分布。\n- 微正则熵为 $S(E)=\\ln \\Omega(E)$，主导能量的鞍点近似通过求解勒让德变换的平稳性条件得到，在离散网格上，你应该通过寻找 $F_{\\beta}(E)=S(E)-\\beta E$ 的最大值点来计算它。\n\n离散化要求：\n- 每个输入 $\\Omega(E)$ 均以参数化形式隐式提供，定义在均匀网格 $E_i=E_{\\min}+i\\,\\Delta E$（$i=0,1,\\dots,N-1$）上，网格间距为常数 $\\Delta E=(E_{\\max}-E_{\\min})/(N-1)$。\n- 你必须使用梯形法则来近似拉普拉斯积分。为确保数值稳定性，你必须使用 log-sum-exp 变换来实现 $\\ln Z(\\beta)$ 的计算。具体来说，如果 $w_i$ 是梯形权重（$w_0=w_{N-1}=\\tfrac{1}{2}$，其他情况下 $w_i=1$），则定义 $f_i=\\ln \\Omega(E_i)-\\beta E_i+\\ln w_i+\\ln \\Delta E$，并使用最大值减法计算 $\\ln Z(\\beta)=\\ln \\sum_i \\exp(f_i)$，即 $\\ln Z(\\beta)=m+\\ln \\sum_i \\exp(f_i-m)$，其中 $m=\\max_i f_i$。\n- 正则平均能量必须使用相同的稳定化权重进行计算：$U(\\beta)=\\sum_i E_i \\, \\exp(f_i-\\ln Z(\\beta))$。\n- 鞍点能量 $E_{\\ast}(\\beta)$ 必须通过在网格上最大化 $F_{\\beta}(E_i)=S(E_i)-\\beta E_i$ 来获得。\n\n数值稳定性评估：\n- 除了稳定化计算外，还需使用直接指数 $g_i=\\exp(\\ln \\Omega(E_i)-\\beta E_i)$ 进行朴素的梯形求值（不使用最大值减法）。如果任何 $g_i$ 不是有限值，或者朴素配分和为非有限值或非正值，则将朴素求值声明为“不稳定”。如果它是有限且为正，则计算朴素正则平均能量 $U_{\\mathrm{naive}}(\\beta)$，并与稳定化计算得到的 $U(\\beta)$ 进行比较。如果相对差异超过容差 $\\tau=10^{-6}$，则声明其不稳定；否则声明其稳定。\n- 对每个测试用例，报告两个结果：(i) 平均能量的鞍点近似的相对绝对误差 $\\varepsilon=\\lvert E_{\\ast}(\\beta)-U(\\beta)\\rvert/\\max(U(\\beta),\\epsilon)$，其中 $\\epsilon=10^{-300}$ 用以避免除以零；(ii) 一个稳定性指标 $s$，如果朴素求值根据上述标准是不稳定的，则 $s$ 等于 $1.0$，否则等于 $0.0$。\n\n测试套件：\n实现以下三个用例，每个用例都由参数化的 $\\ln \\Omega(E)$ 和 $(E_{\\min},E_{\\max},N,\\beta)$ 完全指定：\n\n- 用例 1（单峰，理想路径）：\n  - $\\ln \\Omega(E)=(a-1)\\ln E$，其中 $a=50$。这对应于一个理想化的多自由度动能态密度。\n  - 定义域：$E_{\\min}=10^{-9}$，$E_{\\max}=500$，$N=20001$。\n  - 逆温度：$\\beta=0.5$。\n\n- 用例 2（双峰，系综不等价区域）：\n  - $\\ln \\Omega(E)=\\ln\\left(\\exp\\left(A_1+s_1 E-\\dfrac{(E-m_1)^2}{2 w_1^2}\\right)+\\exp\\left(A_2+s_2 E-\\dfrac{(E-m_2)^2}{2 w_2^2}\\right)\\right)$，参数为 $A_1=0$, $s_1=0.06$, $m_1=40$, $w_1=8$, $A_2=2.0$, $s_2=0.015$, $m_2=140$, $w_2=8$。\n  - 定义域：$E_{\\min}=0$，$E_{\\max}=220$，$N=40001$。\n  - 逆温度：$\\beta=0.03$。\n\n- 用例 3（极端尺度，数值稳定性压力测试）：\n  - $\\ln \\Omega(E)=(a-1)\\ln E$，其中 $a=200$。\n  - 定义域：$E_{\\min}=10^{-9}$，$E_{\\max}=50000$，$N=80001$。\n  - 逆温度：$\\beta=0.01$。\n\n计算与报告要求：\n- 全程使用自然对数。\n- 不使用角度；不需要角度单位。\n- 对每个用例，按上述规定计算并返回浮点数对 $(\\varepsilon,s)$。\n- 你的程序应生成单行输出，其中包含结果，格式为方括号内用逗号分隔的列表，顺序为 $[\\varepsilon_1,s_1,\\varepsilon_2,s_2,\\varepsilon_3,s_3]$。", "solution": "该问题要求从一个给定的、定义在离散能量网格上的微正则态密度 $\\Omega(E)$ 出发，计算正则热力学性质。这涉及到数值计算拉普拉斯变换。任务的一个关键部分是评估此过程的数值稳定性，并量化鞍点近似的准确性，后者是系综等价性在热力学极限下的一种表现。\n\n在逆温度 $\\beta$ 下，微正则熵 $S(E) = \\ln \\Omega(E)$ 与正则配分函数 $Z(\\beta)$ 之间的基本关系由拉普拉斯变换给出：\n$$\nZ(\\beta) = \\int_{0}^{\\infty} \\Omega(E) e^{-\\beta E} \\,\\mathrm{d}E = \\int_{0}^{\\infty} e^{S(E) - \\beta E} \\,\\mathrm{d}E\n$$\n正则平均能量 $U(\\beta)$ 是能量分布 $\\pi_{\\beta}(E) = e^{S(E)-\\beta E}/Z(\\beta)$ 的一阶矩：\n$$\nU(\\beta) = \\langle E \\rangle_{\\beta} = \\frac{\\int_{0}^{\\infty} E e^{S(E) - \\beta E} \\,\\mathrm{d}E}{\\int_{0}^{\\infty} e^{S(E) - \\beta E} \\,\\mathrm{d}E}\n$$\n在热力学极限下（对于大系统），被积函数 $e^{S(E)-\\beta E}$ 在其最大值附近形成尖峰。使指数 $S(E)-\\beta E$ 最大化的能量 $E_{\\ast}(\\beta)$ 被称为鞍点能量。这个条件等价于找到一个能量 $E$，在该能量下，定义为 $T(E) = (\\partial S/\\partial E)^{-1}$ 的微正则温度等于正则温度 $T = 1/\\beta$。对于大系统，系综等价性意味着正则平均能量 $U(\\beta)$ 应收敛于此鞍点能量 $E_{\\ast}(\\beta)$。\n\n所定义的任务是为三个特定的测试用例数值地实现这些计算，并报告 (i) 鞍点近似的相对误差 $\\varepsilon = \\lvert E_{\\ast}(\\beta)-U(\\beta)\\rvert/\\max(U(\\beta),\\epsilon)$ 和 (ii) 一个标志 $s$，该标志指示朴素计算方法相对于稳定化方法的数值稳定性。\n\n算法流程如下：\n\n1.  网格离散化：对于每个用例，定义一个均匀能量网格 $E_i = E_{\\min} + i \\Delta E$（$i=0, \\dots, N-1$），其间距为 $\\Delta E = (E_{\\max}-E_{\\min})/(N-1)$。在此网格上计算微正则熵 $S(E_i) = \\ln \\Omega(E_i)$。\n\n2.  鞍点能量计算：通过找出使函数 $F_{\\beta}(E_i) = S(E_i) - \\beta E_i$ 最大化的网格点 $E_i$ 来找到鞍点能量 $E_{\\ast}(\\beta)$。\n    $$\n    E_{\\ast}(\\beta) = \\underset{E_i}{\\mathrm{argmax}} \\left( S(E_i) - \\beta E_i \\right)\n    $$\n\n3.  稳定化的正则计算：$Z(\\beta)$ 和 $U(\\beta)$ 的积分使用梯形法则进行近似。为处理指数项中可能导致数值上溢或下溢的大范围数值，强制要求使用 log-sum-exp 稳定化技术。\n    配分函数积分近似为 $Z(\\beta) \\approx \\sum_{i=0}^{N-1} w_i \\Delta E \\, e^{S(E_i) - \\beta E_i}$，其中 $w_i$ 是梯形权重（$w_0=w_{N-1}=\\frac{1}{2}$，其他情况下 $w_i=1$）。\n    为计算其对数，我们定义项 $f_i = S(E_i) - \\beta E_i + \\ln(w_i) + \\ln(\\Delta E)$，使得 $Z(\\beta) \\approx \\sum_i e^{f_i}$。\n    $\\ln Z(\\beta)$ 的稳定化计算随后为：\n    $$\n    m = \\max_i(f_i) \\\\\n    \\ln Z(\\beta) = m + \\ln\\left(\\sum_{i=0}^{N-1} e^{f_i - m}\\right)\n    $$\n    正则平均能量 $U(\\beta)$ 使用从此稳定化计算中派生出的权重进行计算：\n    $$\n    U(\\beta) = \\frac{\\sum_i E_i w_i \\Delta E e^{S(E_i) - \\beta E_i}}{\\sum_i w_i \\Delta E e^{S(E_i) - \\beta E_i}} = \\frac{\\sum_i E_i e^{f_i}}{\\sum_i e^{f_i}} = \\sum_{i=0}^{N-1} E_i e^{f_i - \\ln Z(\\beta)}\n    $$\n\n4.  数值稳定性评估：同时进行一次朴素计算。令 $g_i = e^{S(E_i) - \\beta E_i}$。\n    朴素配分函数为 $Z_{\\mathrm{naive}} = \\sum_i w_i g_i \\Delta E$。\n    如果任何 $g_i$ 不是有限值，如果 $Z_{\\mathrm{naive}}$ 不是有限值或非正值，或者如果朴素平均能量 $U_{\\mathrm{naive}} = (\\sum_i E_i w_i g_i \\Delta E)/Z_{\\mathrm{naive}}$ 与稳定化计算的 $U(\\beta)$ 的相对差异超过 $\\tau=10^{-6}$，则该计算被视为不稳定（且稳定性标志 $s$ 设置为 $1.0$）。否则，计算是稳定的（$s=0.0$）。\n\n5.  报告：对每个测试用例，计算并报告数对 $(\\varepsilon, s)$。这三个用例旨在测试不同的物理和数值状况：一个标准的单峰系统（用例 1），一个表现出系综不等价性的双峰系统（用例 2），以及一个旨在导致朴素实现中数值溢出的大尺度系统（用例 3）。对于双峰情况，函数 $\\ln \\Omega(E)$ 本身就是一个指数和的对数形式，需要进行嵌套的稳定求值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for microcanonical to canonical ensemble calculations.\n    \"\"\"\n\n    def log_omega_power_law(E, a):\n        \"\"\"Computes ln(Omega(E)) for a power-law density of states.\"\"\"\n        # This handles vector input E, taking care of log(0) if E_min=0, although here E_min > 0.\n        return (a - 1) * np.log(E)\n\n    def log_omega_bimodal(E, **params):\n        \"\"\"Computes ln(Omega(E)) for a bimodal density of states using log-sum-exp.\"\"\"\n        p = params\n        term1 = p['A1'] + p['s1'] * E - ((E - p['m1'])**2) / (2 * p['w1']**2)\n        term2 = p['A2'] + p['s2'] * E - ((E - p['m2'])**2) / (2 * p['w2']**2)\n        \n        # Use log-sum-exp for numerical stability\n        max_term = np.maximum(term1, term2)\n        return max_term + np.log(np.exp(term1 - max_term) + np.exp(term2 - max_term))\n\n    def process_case(log_omega_func, E_min, E_max, N, beta, func_params):\n        \"\"\"\n        Processes a single test case to compute the saddle-point error and stability indicator.\n        \n        Returns:\n            A tuple (epsilon, s) containing the relative error and stability flag.\n        \"\"\"\n        # --- 1. Grid and Function Setup ---\n        E = np.linspace(E_min, E_max, N)\n        delta_E = (E_max - E_min) / (N - 1)\n        \n        # Handle E=0 in log for power law case (though not strictly necessary for problems as given)\n        if E_min == 0 and log_omega_func == log_omega_power_law:\n            log_omega_E = np.full_like(E, -np.inf)\n            log_omega_E[1:] = log_omega_func(E[1:], **func_params)\n        else:\n            log_omega_E = log_omega_func(E, **func_params)\n\n        # --- 2. Saddle-Point Energy Calculation ---\n        F_beta = log_omega_E - beta * E\n        E_star = E[np.argmax(F_beta)]\n\n        # --- 3. Stabilized Canonical Calculation ---\n        trapezoidal_weights = np.ones(N)\n        trapezoidal_weights[0] = 0.5\n        trapezoidal_weights[-1] = 0.5\n        \n        f = log_omega_E - beta * E + np.log(trapezoidal_weights) + np.log(delta_E)\n\n        # Log-sum-exp for ln(Z)\n        m = np.max(f[np.isfinite(f)]) # Avoid -inf from log(0) if any\n        log_Z = m + np.log(np.sum(np.exp(f - m)))\n        \n        # Stabilized mean energy U\n        U = np.sum(E * np.exp(f - log_Z))\n\n        # --- 4. Numerical Stability Assessment ---\n        s = 0.0\n        \n        # Naive calculation\n        # Use np.seterr to temporarily ignore overflow/underflow warnings for the naive part\n        with np.errstate(over='ignore', under='ignore'):\n            g = np.exp(log_omega_E - beta * E)\n        \n        if not np.all(np.isfinite(g)):\n            s = 1.0\n        else:\n            Z_naive = np.sum(trapezoidal_weights * g * delta_E)\n            if not np.isfinite(Z_naive) or Z_naive = 0:\n                s = 1.0\n            else:\n                U_naive = np.sum(trapezoidal_weights * E * g * delta_E) / Z_naive\n                \n                # Check relative difference\n                tau = 1e-6\n                # Use a small absolute tolerance for comparison when U is near zero\n                if not np.isclose(U_naive, U, rtol=tau, atol=1e-12):\n                    s = 1.0\n\n        # --- 5. Error Calculation ---\n        epsilon_small = 1e-300\n        epsilon_rel_error = np.abs(E_star - U) / np.max([np.abs(U), epsilon_small])\n        \n        return epsilon_rel_error, s\n\n    # Define test cases\n    test_cases = [\n        {\n            \"log_omega_func\": log_omega_power_law,\n            \"E_min\": 1e-9, \"E_max\": 500, \"N\": 20001, \"beta\": 0.5,\n            \"func_params\": {\"a\": 50}\n        },\n        {\n            \"log_omega_func\": log_omega_bimodal,\n            \"E_min\": 0, \"E_max\": 220, \"N\": 40001, \"beta\": 0.03,\n            \"func_params\": {\n                'A1': 0, 's1': 0.06, 'm1': 40, 'w1': 8,\n                'A2': 2.0, 's2': 0.015, 'm2': 140, 'w2': 8\n            }\n        },\n        {\n            \"log_omega_func\": log_omega_power_law,\n            \"E_min\": 1e-9, \"E_max\": 50000, \"N\": 80001, \"beta\": 0.01,\n            \"func_params\": {\"a\": 200}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        eps, s = process_case(**case)\n        results.extend([eps, s])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.7e}' for r in results)}]\")\n\nsolve()\n```", "id": "3410951"}, {"introduction": "理论和数值分析最终要服务于实际的模拟工作。当您运行一个分子动力学模拟时，如何确定它确实在正确地抽样所设想的系综？这项编程练习 [@problem_id:3410952] 提供了一个强大的统计诊断工具。通过检验模拟输出的动能分布是否符合其理论预测的卡方分布（$\\chi^2$ distribution），我们可以有效地识别出模拟设置或算法实现中可能存在的微妙错误，确保模拟结果的可靠性。", "problem": "您需要编写一个完整、可运行的程序，用于交叉验证来自三个假设的分子动力学（MD）软件包的动能分布。这些软件包在恒定粒子数、体积和温度（NVT）系综下进行采样。该验证基于基本的统计力学原理：对于一个在正则系综（NVT）中，包含 $N$ 个相同粒子、温度为 $T$ 的系统，其瞬时动能 $K$ 的分布由动量的麦克斯韦-玻尔兹曼分布所决定。具体来说，当移除质心（COM）动量后，平动自由度（DOF）的数量为 $f = 3N - 3$，并且缩放后的动能 $Y = 2K/(k_B T)$ 服从自由度为 $f$ 的卡方分布。您的任务是实现一个交叉验证程序，测试每个软件包生成的合成动能样本是否与正确自由度计算下的预期卡方分布一致，并检测出指示非正则采样或自由度处理不当的偏差。\n\n从基本原理出发：正则相空间分布的概率密度与 $\\exp(-\\beta H)$ 成正比，其中 $\\beta = 1/(k_B T)$，哈密顿量 $H = K + U$；并且在该系综中，对于无约束的自由度，动量分量是独立的高斯分布。基于此，推导 $K$ 和缩放变量 $Y$ 的分布，并相应地设计一个检验。\n\n您必须为一组测试用例生成三个假设的MD软件包的合成动能样本。使用约化单位，其中玻尔兹曼常数 $k_B = 1$，因此能量和温度是无量纲的。不需要进行物理单位转换。对于每个测试用例，定义 $N$、$T$ 和样本数 $n_s$，并生成以下三个数据集：\n- 软件包 A（正则，正确自由度）：从 $Y \\sim \\chi^2_f$（其中 $f = 3N - 3$）中抽样，并设置 $K = (k_B T/2) Y$。\n- 软件包 B（自由度计算错误）：从 $Y \\sim \\chi^2_{3N}$（即未移除质心运动）中抽样，并设置 $K = (k_B T/2) Y$；此样本将与预期的 $f = 3N - 3$ 进行检验。\n- 软件包 C（具有抑制方差的非正则采样）：如软件包 A 一样从 $Y \\sim \\chi^2_f$ 中抽样，然后构造 $Y' = f + \\alpha_v (Y - f)$，其中方差收缩因子 $\\alpha_v = 0.6$，并设置 $K = (k_B T/2) Y'$。\n\n为了可复现性，请使用固定的随机种子。对于测试用例索引 $i$（从 $i = 1$ 开始），软件包 A 使用种子 $s_A = 12345 + i$，软件包 B 使用种子 $s_B = 22345 + i$，软件包 C 使用种子 $s_C = 32345 + i$。\n\n对于每个数据集，执行以下验证步骤：\n1. 计算 $f = 3N - 3$。如果 $f \\le 0$，则该测试用例中所有三个软件包的结果都返回失败（布尔值 $False$），因为 $Y$ 的正则分布是简并的，检验是不适定的。\n2. 对于 $i = 1, \\ldots, n_s$，计算缩放后的动能 $Y_i = 2K_i/(k_B T)$。\n3. 对 $Y$ 与自由度为 $f$ 的卡方分布进行柯尔莫可洛夫-斯米洛夫（KS）拟合优度检验，得到一个 $p$ 值。使用显著性水平 $\\alpha = 0.01$。如果 $p \\ge \\alpha$，则 KS 检验通过。\n4. 独立地检查样本均值与卡方分布期望均值的一致性。$Y$ 的期望均值是 $f$，其方差是 $2f$。在 $n_s$ 个样本上，$Y$ 的样本均值的方差是 $2f/n_s$。计算一个 $z$ 分数 $z = | \\overline{Y} - f | / \\sqrt{2f/n_s}$，并从标准正态分布中定义临界值 $z_{\\mathrm{crit}}$，即 $z_{\\mathrm{crit}} = \\Phi^{-1}(1 - \\alpha/2)$，其中 $\\Phi^{-1}$ 是逆累积分布函数。如果 $z \\le z_{\\mathrm{crit}}$，则均值一致性检验通过。\n5. 一个数据集只有在 KS 检验和均值一致性检验都通过时才被视为一致（布尔值 $True$）。\n\n为以下测试套件实现上述过程：\n- 测试用例 1: $N = 64$，$T = 2.0$，$n_s = 20000$。\n- 测试用例 2: $N = 8$，$T = 1.5$，$n_s = 20000$。\n- 测试用例 3: $N = 1$，$T = 1.0$，$n_s = 10000$。\n- 测试用例 4: $N = 256$，$T = 0.7$，$n_s = 30000$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，布尔值按 $[A_1,B_1,C_1,A_2,B_2,C_2,A_3,B_3,C_3,A_4,B_4,C_4]$ 的顺序排列，其中 $A_i$ 对应于测试用例 $i$ 的软件包 A，$B_i$ 对应于软件包 B，$C_i$ 对应于软件包 C。\n\n请在实现中保持精确和严谨。不涉及角度。能量和温度均在约化无量纲单位下，且 $k_B = 1$。不允许外部输入或文件；所有数据必须根据上述规则在内部生成。", "solution": "目标是开发一个计算流程，以验证模拟的分子动力学轨迹产生的动能分布是否符合正则系综理论的预测。这包括推导动能的理论分布，并实施统计检验以检查一致性。\n\n该问题建立在正则系综的统计力学原理之上，该系综描述了一个具有固定粒子数 $N$、体积 $V$ 和温度 $T$ 的系统。系统处于具有相空间坐标 $(\\mathbf{q}, \\mathbf{p})$ 和哈密顿量 $H(\\mathbf{q}, \\mathbf{p})$ 的特定微观状态的概率由概率密度函数 $p(\\mathbf{q}, \\mathbf{p}) \\propto \\exp(-\\beta H(\\mathbf{q}, \\mathbf{p}))$ 给出，其中 $\\beta = 1/(k_B T)$，$k_B$ 是玻尔兹曼常数。哈密顿量是动能 $K(\\mathbf{p})$ 和势能 $U(\\mathbf{q})$ 的总和，因此 $H = K + U$。\n\n通过对整个相空间概率密度在所有位置坐标 $\\mathbf{q}$ 上积分，可以找到动能的分布。由于 $K$ 仅依赖于动量 $\\mathbf{p}$，因此得到的动量分布为 $p(\\mathbf{p}) \\propto \\exp(-\\beta K(\\mathbf{p}))$。对于一个由 $N$ 个质量为 $m$ 的相同粒子组成的系统，动能是所有 $3N$ 个笛卡尔动量分量 $p_j$ 贡献的总和：\n$$K = \\sum_{j=1}^{3N} \\frac{p_j^2}{2m}$$\n这意味着每个动量分量 $p_j$ 是一个从均值为 $0$、方差为 $m/\\beta = m k_B T$ 的高斯分布中抽取的独立随机变量。因此，缩放后的动量分量 $p_j / \\sqrt{m k_B T}$ 是一个标准正态变量，$p_j / \\sqrt{m k_B T} \\sim \\mathcal{N}(0, 1)$。\n\n缩放后的瞬时动能，记作 $Y$，定义为：\n$$Y = \\frac{2K}{k_B T} = \\frac{2}{k_B T} \\sum_{j=1}^{3N} \\frac{p_j^2}{2m} = \\sum_{j=1}^{3N} \\left(\\frac{p_j}{\\sqrt{m k_B T}}\\right)^2$$\n根据定义，自由度为 $f$ 的卡方（$\\chi^2$）分布是 $f$ 个独立标准正态随机变量平方和的分布。如果所有 $3N$ 个动量分量都是独立的，那么 $Y$ 将服从自由度为 $3N$ 的卡方分布，即 $Y \\sim \\chi^2_{3N}$。\n\n然而，在 NVT 系综下对孤立系统进行的典型分子动力学模拟中，系统的总线性动量是守恒的，并且通常固定为零以保持质心静止。这给动量分量带来了3个约束条件：\n$$\\sum_{i=1}^{N} \\mathbf{p}_i = \\mathbf{0} \\quad \\implies \\quad \\sum_{i=1}^{N} p_{ix} = 0, \\quad \\sum_{i=1}^{N} p_{iy} = 0, \\quad \\sum_{i=1}^{N} p_{iz} = 0$$\n这些约束使动能和中的独立二次项数量减少了 $3$ 个。因此，正确的平动自由度数为 $f = 3N - 3$。对于这样的系统，缩放后的动能 $Y$ 由自由度为 $f = 3N-3$ 的卡方分布正确描述，即 $Y \\sim \\chi^2_{f}$。该分布的期望均值为 $\\mathbb{E}[Y] = f$，方差为 $\\mathrm{Var}[Y] = 2f$。\n\n验证程序旨在检验来自给定模拟的动能样本 $\\{K_i\\}$ 是否符合这一理论预期。对于每个由 $N$、$T$ 和样本大小 $n_s$ 定义的测试用例，以及对于三个假设的软件包中的每一个，执行以下步骤：\n\n1.  **自由度计算与合理性检查**：计算自由度数 $f = 3N - 3$。如果 $N \\le 1$，则 $f \\le 0$。$\\chi^2_0$ 分布是在 $0$ 处的简并点质量，标准的统计检验对其是无效的。根据问题规范，这种情况会自动被视为无效，并且对所有三个软件包的验证都返回失败（布尔值 $False$）。\n\n2.  **数据生成与缩放**：为每个软件包生成合成动能样本。\n    - **软件包 A**：通过从 $f = 3N-3$ 的 $\\chi^2_f$ 分布中抽取缩放能量 $Y$ 来模拟正确的正则采样。\n    - **软件包 B**：通过从 $\\chi^2_{3N}$ 分布中抽取 $Y$ 来模拟错误的自由度计算。\n    - **软件包 C**：模拟具有抑制能量波动的非正则采样。它从 $\\chi^2_f$ 分布中生成一个样本 $Y$，然后通过 $Y' = f + \\alpha_v (Y - f)$ 进行变换，其中方差收缩因子 $\\alpha_v = 0.6$。\n    对于每个软件包，根据问题的约化单位用法，使用玻尔兹曼常数 $k_B=1$，将动能样本计算为 $K = (k_B T/2) Y$（或 $Y'$）。为了后续检验，这些 $K$ 样本被缩放回 $Y_i = 2K_i/T$。\n\n3.  **柯尔莫可洛夫-斯米洛夫（KS）检验**：这是一种非参数拟合优度检验，它将样本数据 $\\{Y_i\\}$ 的累积分布函数（CDF）与目标分布（即 $\\chi^2_f$）的理论CDF进行比较。检验产生一个 $p$ 值，该值是在原假设（即数据是从目标分布中抽取的）成立的情况下，观测到至少与测量到的样本一样极端的样本的概率。如果 $p$ 值大于或等于所选的显著性水平 $\\alpha = 0.01$，则认为检验通过。低的 $p$ 值（$p  \\alpha$）表示分布形状存在显著偏差。\n\n4.  **均值一致性检验**：该检验检查缩放后动能的样本均值是否与其理论期望值一致。计算样本均值 $\\overline{Y} = \\frac{1}{n_s}\\sum_{i=1}^{n_s} Y_i$。根据中心极限定理，对于大量样本 $n_s$，$\\overline{Y}$ 近似服从均值为 $\\mathbb{E}[\\overline{Y}] = f$、方差为 $\\mathrm{Var}[\\overline{Y}] = \\mathrm{Var}[Y]/n_s = 2f/n_s$ 的正态分布。计算一个 $z$ 分数，以标准误差为单位来衡量样本均值与期望均值的偏差：\n    $$z = \\frac{|\\overline{Y} - f|}{\\sqrt{2f/n_s}}$$\n    将此 $z$ 分数与在显著性水平 $\\alpha$ 下进行双尾检验的标准正态分布的临界值 $z_{\\mathrm{crit}}$ 进行比较。临界值为 $z_{\\mathrm{crit}} = \\Phi^{-1}(1 - \\alpha/2)$，其中 $\\Phi^{-1}$ 是标准正态分布的逆CDF。对于 $\\alpha = 0.01$，$z_{\\mathrm{crit}} \\approx 2.576$。如果 $z \\le z_{\\mathrm{crit}}$，则检验通过。\n\n5.  **最终判定**：一个数据集只有在同时通过KS检验和均值一致性检验时，才被认为与正则系综理论一致。\n\n这种严谨的两部分验证是稳健的。均值检验对平均能量的系统性误差（例如，错误的自由度）很敏感，而KS检验对分布的整体形状（包括其方差和更高阶矩）敏感，使其能够检测到更微妙的偏离正则采样的情况，例如软件包C中被抑制的波动。软件包A应通过，而软件包B（均值错误）和软件包C（方差错误）预计会失败。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import kstest, chi2, norm\n\ndef solve():\n    \"\"\"\n    Main function to run the cross-validation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, T, n_s)\n        (64, 2.0, 20000),\n        (8, 1.5, 20000),\n        (1, 1.0, 10000),\n        (256, 0.7, 30000),\n    ]\n    \n    # Constants from the problem statement\n    k_B = 1.0\n    alpha_v = 0.6\n    alpha_sig = 0.01\n\n    results = []\n    \n    for i, (N, T, n_s) in enumerate(test_cases, 1):\n        # Step 1: Compute DOF and handle the degenerate case\n        f = 3 * N - 3\n        if f = 0:\n            results.extend([False, False, False])\n            continue\n            \n        # Define random seeds for reproducibility\n        seed_A = 12345 + i\n        seed_B = 22345 + i\n        seed_C = 32345 + i\n        \n        # --- Data Generation ---\n\n        # Package A: Correct canonical sampling\n        rng_A = np.random.default_rng(seed_A)\n        Y_samples_A = rng_A.chisquare(f, n_s)\n        K_samples_A = (k_B * T / 2.0) * Y_samples_A\n        \n        # Package B: Incorrect DOF accounting\n        rng_B = np.random.default_rng(seed_B)\n        Y_samples_B = rng_B.chisquare(3 * N, n_s)\n        K_samples_B = (k_B * T / 2.0) * Y_samples_B\n        \n        # Package C: Non-canonical sampling with suppressed variance\n        rng_C = np.random.default_rng(seed_C)\n        Y_base_samples_C = rng_C.chisquare(f, n_s)\n        Y_samples_C = f + alpha_v * (Y_base_samples_C - f)\n        K_samples_C = (k_B * T / 2.0) * Y_samples_C\n        \n        # --- Validation ---\n        \n        result_A = validate_dataset(K_samples_A, N, T, n_s, alpha_sig)\n        result_B = validate_dataset(K_samples_B, N, T, n_s, alpha_sig)\n        result_C = validate_dataset(K_samples_C, N, T, n_s, alpha_sig)\n        \n        results.extend([result_A, result_B, result_C])\n\n    # Final print statement in the exact required format\n    # The problem asks for boolean values, which Python's str() converts to \"True\" and \"False\"\n    # The example output uses lowercase, so we convert them explicitly.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\ndef validate_dataset(K_samples: np.ndarray, N: int, T: float, n_s: int, alpha: float) -> bool:\n    \"\"\"\n    Performs the validation procedure for a single dataset.\n    \n    Args:\n        K_samples: Array of kinetic energy samples.\n        N: Number of particles.\n        T: Temperature.\n        n_s: Number of samples.\n        alpha: Significance level.\n\n    Returns:\n        True if the dataset passes both validation tests, False otherwise.\n    \"\"\"\n    f = 3 * N - 3\n    k_B = 1.0\n\n    # Step 2: Compute scaled kinetic energies\n    Y_samples = 2 * K_samples / (k_B * T)\n    \n    # Step 3: Kolmogorov-Smirnov goodness-of-fit test\n    # The 'args' parameter provides the degrees of freedom for the chi2 distribution.\n    ks_statistic, p_value = kstest(Y_samples, 'chi2', args=(f,))\n    ks_pass = p_value >= alpha\n\n    # Step 4: Mean consistency test\n    sample_mean_Y = np.mean(Y_samples)\n    expected_mean_Y = f\n    \n    # Variance of the theoretical chi-square distribution with f DOFs.\n    expected_var_Y = 2 * f\n    \n    # The standard error is the standard deviation of the sample mean's distribution.\n    # The denominator can't be zero due to the f > 0 check in the main loop.\n    std_error_of_mean = np.sqrt(expected_var_Y / n_s)\n    \n    z_score = np.abs(sample_mean_Y - expected_mean_Y) / std_error_of_mean\n    \n    # Critical value for a two-tailed test.\n    z_crit = norm.ppf(1 - alpha / 2.0)\n    \n    mean_pass = z_score = z_crit\n    \n    # Step 5: A dataset is consistent only if both tests pass.\n    return ks_pass and mean_pass\n\n# Execute the main function\nsolve()\n```", "id": "3410952"}]}