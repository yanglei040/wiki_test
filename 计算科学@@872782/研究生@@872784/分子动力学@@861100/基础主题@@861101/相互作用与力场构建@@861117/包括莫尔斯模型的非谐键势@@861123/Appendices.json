{"hands_on_practices": [{"introduction": "Morse势的有效性取决于其参数$D_e$、$a$和$r_e$的准确确定。本练习模拟了力场开发中的一项常见任务：根据高精度量子化学计算得到的数据来拟合势能函数。通过掌握这种实践，你将能够连接第一性原理理论与实际的模拟模型，确保你的模型具有坚实的物理基础。[@problem_id:3395888]", "problem": "分子动力学 (MD) 力场中的一个双原子键将由摩尔斯 (Morse) 非谐势来表示，该势采用在最小值处能量为零、解离能为渐近极限的约定，因此势能函数为 $$V(r)=D_e\\left(1-e^{-a(r-r_e)}\\right)^2,$$ 其中 $$V(r_e)=0$$ 且 $$V(\\infty)=D_e.$$ 您从电子结构计算中获得了三个高质量的量：(i) 最小值处的曲率，定义为 $$k_e=V''(r_e),$$ 通过围绕平衡结构的简正模式分析获得；(ii) 一个标记为大拉伸的能量点，即对于一个具有显著伸长的构型 $$r_s>r_e$$，其能量为 $$E_s=V(r_s)$$；以及 (iii) 解离能 $$D_e,$$ 定义为最小值与解离极限之间的能量差。假设电子结构能量处于相同的绝对参考系上，使得最小值在 $$r=r_e$$ 处始终为零。以下哪种方案正确地使用了这三个输入来唯一确定 $$\\left(D_e,a,r_e\\right)$$，并为其数值稳健性提供了合理的论证？\n\nA. 使用曲率通过 $$a=\\sqrt{\\dfrac{k_e}{2D_e}}$$ 来确定范围参数；然后通过强制满足拉伸点的能量 $$E_s=D_e\\left(1-e^{-a(r_s-r_e)}\\right)^2$$ 来恢复平衡距离，求解为 $$r_e=r_s+\\dfrac{1}{a}\\ln\\!\\left(1-\\sqrt{\\dfrac{E_s}{D_e}}\\right),$$ 选择满足 $$0<\\sqrt{E_s/D_e}<1$$ 的单调吸引分支。保持 $$D_e$$ 等于所提供的解离能。稳健性论证：最小值附近的曲率独立于 $$r_e$$ 约束了 $$a$$，远离平衡点的拉伸点打破了困扰纯近平衡拟合的 $$a$$ 和 $$r_e$$ 之间的强相关性，用 $$D_e$$ 固定渐近线强制了物理行为；选择的 $$E_s$$ 不太接近 $$0$$ 或 $$D_e$$ 可以避免对数病态问题。\n\nB. 使用线性关系 $$a=\\dfrac{k_e}{D_e}$$ 从曲率确定范围参数；然后通过 $$E_s=D_e\\left(1-e^{-a(r_s-r_e)}\\right)$$ 使用拉伸点的能量，并求解平衡距离为 $$r_e=r_s-\\dfrac{1}{a}\\ln\\!\\left(1-\\dfrac{E_s}{D_e}\\right)$$。保持 $$D_e$$ 等于所提供的解离能。稳健性论证：对 $$a$$ 使用线性映射避免了平方误差，而单个对数使灵敏度保持在较低水平。\n\nC. 在将 $$r_e$$ 固定在计算能量最小化的构型下，通过非线性最小二乘法将 $$a$$ 和 $$D_e$$ 拟合到两个拉伸点 $$\\left(r_{s1},E_{s1}\\right)$$ 和 $$\\left(r_{s2},E_{s2}\\right)$$。仅将曲率 $$k_e$$ 用作后验一致性检查，并在必要时进行调整。稳健性论证：两个远点锚定了渐近线和尾部形状，而最小构型可直接从电子结构扫描中获得。\n\nD. 设定 $$D_e=E_s$$ 并假设 $$r_e=r_s$$，因为最小值在计算的构型处定义了能量零点。然后通过在 $$r_s$$ 附近的有限差分曲率估计 $$a$$，使用 $$k_e\\approx V''(r_s)$$ 并强制 $$a=\\sqrt{k_e/(2D_e)}$$。稳健性论证：将最小值和拉伸点置于同一位置减少了参数相关性，并且根据构造，解离能等于观测到的远距离拉伸能量。", "solution": "用户要求对一个关于摩尔斯势参数化的问题陈述进行严格验证，然后给出完整的解决方案并评估所提供的选项。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n\n问题陈述提供了以下明确信息：\n1.  **势能函数**：摩尔斯势，$$V(r)=D_e\\left(1-e^{-a(r-r_e)}\\right)^2$$。\n2.  **能量约定**：势在最小值处为零，$$V(r_e)=0$$，解离能是渐近极限，$$V(\\infty)=D_e$$。\n3.  **来自电子结构计算的输入数据**：\n    (i) 最小值处的曲率，$$k_e=V''(r_e)$$。\n    (ii) 一个大拉伸处的能量点，$$E_s=V(r_s)$$，其构型为 $$r_s>r_e$$。\n    (iii) 解离能，$$D_e$$。\n4.  **能量参考**：能量最小值始终为零，$$V(r_e)=0$$。\n5.  **目标**：找到一个能正确使用这三个输入来唯一确定参数 $$\\left(D_e,a,r_e\\right)$$ 并为数值稳健性提供合理论证的方案。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据所需标准对问题进行评估：\n-   **科学基础**：摩尔斯势是描述双原子分子势能的一个标准且具有物理意义的模型，广泛应用于光谱学和分子动力学中。量 $$D_e$$（解离能）、$$r_e$$（平衡键长）和 $$k_e$$（最小值处的谐振力常数）是化学键的基本属性。该问题牢固地建立在物理化学和计算物理的既定原则之上。\n-   **适定性**：该问题要求一个确定三个参数（$$D_e$$、$$a$$ 和 $$r_e$$）的方案。它提供了三个不同的信息：一个 $$D_e$$ 值，一个 $$k_e$$ 值，以及一个能量-距离对 $$(r_s, E_s)$$。问题暗示输入的 $$D_e$$ 值将直接用作参数 $$D_e$$，留下两个未知数 $$a$$ 和 $$r_e$$，由剩下的两个约束条件 $$k_e=V''(r_e)$$ 和 $$E_s=V(r_s)$$ 来确定。对于两个方程和两个未知数，该系统原则上是可解的。唯一性和数值稳健性的问题是参数拟合中的标准考虑因素，这使得该问题结构良好。\n-   **客观性**：该问题使用精确、无歧义的科学语言陈述。所有术语，如“最小值处的曲率”和“解离能”，在该领域内都有清晰、普遍接受的定义。\n\n该问题没有科学或事实上的不健全之处，不是比喻性的，不不完整或矛盾，没有设定不切实际的条件，不是不适定的，也不是微不足道的。\n\n**步骤3：结论与行动**\n\n问题陈述是**有效的**。该任务是化学物理学中一个标准的参数化练习，既需要正确的数学推导，也需要对数值稳定性的理解。我现在将继续进行求解。\n\n**正确方案的推导**\n\n目标是确定摩尔斯势 $$V(r)=D_e\\left(1-e^{-a(r-r_e)}\\right)^2$$ 的参数 $$a$$ 和 $$r_e$$，给定 $$D_e$$、$$k_e=V''(r_e)$$ 的值以及一个点 $$(r_s, E_s)$$，其中 $$r_s > r_e$$。\n\n首先，我们建立曲率 $$k_e$$ 和势参数之间的关系。这需要计算 $$V(r)$$ 关于 $$r$$ 的二阶导数。\n\n一阶导数是：\n$$ V'(r) = \\frac{d}{dr} \\left[ D_e\\left(1-e^{-a(r-r_e)}\\right)^2 \\right] $$\n$$ V'(r) = D_e \\cdot 2\\left(1-e^{-a(r-r_e)}\\right) \\cdot \\frac{d}{dr}\\left(1-e^{-a(r-r_e)}\\right) $$\n$$ V'(r) = 2D_e\\left(1-e^{-a(r-r_e)}\\right) \\left(-e^{-a(r-r_e)} \\cdot (-a)\\right) $$\n$$ V'(r) = 2aD_e \\left(1-e^{-a(r-r_e)}\\right)e^{-a(r-r_e)} = 2aD_e \\left(e^{-a(r-r_e)} - e^{-2a(r-r_e)}\\right) $$\n在最小值 $$r=r_e$$ 处，我们有 $$V'(r_e)=2aD_e(e^0 - e^0) = 0$$，这与平衡点是一致的。\n\n二阶导数是：\n$$ V''(r) = \\frac{d}{dr} \\left[ 2aD_e \\left(e^{-a(r-r_e)} - e^{-2a(r-r_e)}\\right) \\right] $$\n$$ V''(r) = 2aD_e \\left(-a e^{-a(r-r_e)} - (-2a) e^{-2a(r-r_e)}\\right) $$\n$$ V''(r) = 2a^2D_e \\left(2e^{-2a(r-r_e)} - e^{-a(r-r_e)}\\right) $$\n\n最小值处的曲率 $$k_e$$ 是 $$V''(r_e)$$：\n$$ k_e = V''(r_e) = 2a^2D_e \\left(2e^0 - e^0\\right) = 2a^2D_e(2-1) = 2a^2D_e $$\n从这个精确的关系式中，我们可以解出参数 $$a$$：\n$$ a^2 = \\frac{k_e}{2D_e} $$\n由于 $$a$$ 是一个表示势阱宽度的物理参数，它必须是正的。因此，我们取主根：\n$$ a = \\sqrt{\\frac{k_e}{2D_e}} $$\n这个方程使用提供的两个高质量输入 $$k_e$$ 和 $$D_e$$ 来确定参数 $$a$$。\n\n接下来，我们使用第三个输入，即能量点 $$(r_s, E_s)$$，来确定剩下的参数 $$r_e$$。定义方程是：\n$$ E_s = V(r_s) = D_e\\left(1-e^{-a(r_s-r_e)}\\right)^2 $$\n我们求解 $$r_e$$。参数 $$a$$ 现在被认为是已从上一步中得知的。\n$$ \\frac{E_s}{D_e} = \\left(1-e^{-a(r_s-r_e)}\\right)^2 $$\n两边取平方根得到：\n$$ \\pm\\sqrt{\\frac{E_s}{D_e}} = 1-e^{-a(r_s-r_e)} $$\n我们必须选择正确的符号。问题陈述 $$r_s>r_e$$，这意味着键被拉伸。对于一个正参数 $$a$$，指数 $$-a(r_s-r_e)$$ 是负的。因此，$$0 < e^{-a(r_s-r_e)} < 1$$。这意味着项 $$1-e^{-a(r_s-r_e)}$$ 是正的。因此，我们必须取正根：\n$$ \\sqrt{\\frac{E_s}{D_e}} = 1-e^{-a(r_s-r_e)} $$\n此外，由于 $$r_s$$ 是束缚势上的一个点，$$0 < E_s < D_e$$，这确保了 $$0 < \\sqrt{E_s/D_e} < 1$$，并且随后的对数将是对一个正数进行运算。\n\n重新整理以求解指数项：\n$$ e^{-a(r_s-r_e)} = 1 - \\sqrt{\\frac{E_s}{D_e}} $$\n两边取自然对数：\n$$ -a(r_s-r_e) = \\ln\\left(1 - \\sqrt{\\frac{E_s}{D_e}}\\right) $$\n最后，求解 $$r_e$$：\n$$ r_s - r_e = -\\frac{1}{a} \\ln\\left(1 - \\sqrt{\\frac{E_s}{D_e}}\\right) $$\n$$ r_e = r_s + \\frac{1}{a} \\ln\\left(1 - \\sqrt{\\frac{E_s}{D_e}}\\right) $$\n这个结果根据输入提供了一个唯一的 $$r_e$$ 公式。因此，该方案是解析确定的。\n\n**选项评估**\n\n**选项A：**\n所描述的方案是：\n1.  $$a=\\sqrt{\\dfrac{k_e}{2D_e}}$$\n2.  $$r_e=r_s+\\dfrac{1}{a}\\ln\\!\\left(1-\\sqrt{\\dfrac{E_s}{D_e}}\\right)$$，条件为 $$0<\\sqrt{E_s/D_e}<1$$。\n3.  $$D_e$$ 取自输入。\n\n该方案与上面的推导完全匹配。选项中提供的论证也是合理的。关系式 $$k_e=2a^2D_e$$ 确实在不参考 $$r_e$$ 的情况下约束了 $$a$$。使用一个远离最小值（$$r_e$$）的数据点 $$(r_s, E_s)$$ 是避免仅拟合近平衡数据时出现的参数相关性的标准技术。最后，关于数值稳健性的分析是正确的：如果对数函数的参数趋近于零（当 $$E_s \\to D_e$$ 时发生），则函数是病态的。如果 $$E_s \\to 0$$，数据点提供的信息与从 $$k_e$$ 获得的信息是冗余的，这是一个不那么严重但仍然相关的问题。\n- **结论**：正确。\n\n**选项B：**\n所描述的方案是：\n1.  $$a=\\dfrac{k_e}{D_e}$$\n2.  $$E_s=D_e\\left(1-e^{-a(r_s-r_e)}\\right)$$\n3.  $$r_e=r_s-\\dfrac{1}{a}\\ln\\!\\left(1-\\dfrac{E_s}{D_e}\\right)$$\n\n这个选项有根本性的缺陷。$$a$$、$$k_e$$ 和 $$D_e$$ 之间的关系是 $$k_e = 2a^2D_e$$，而不是 $$k_e = aD_e$$。所提出的 $$a$$ 的公式在数学上是错误的。此外，势能被表述为 $$E_s=D_e\\left(1-e^{-a(r_s-r_e)}\\right)$$，它缺少了括号项的平方，这与问题陈述中提供的摩尔斯势的定义相矛盾。$$r_e$$ 的表达式是从这个错误的势形式推导出来的。整个方案都基于错误的数学关系。\n- **结论**：错误。\n\n**选项C：**\n所描述的方案是：\n1.  使用非线性最小二乘法将 $$a$$ 和 $$D_e$$ 拟合到**两个**拉伸点。\n2.  将 $$r_e$$ 固定在计算确定的最小值处。\n3.  仅将 $$k_e$$ 用作后验检查。\n\n这个方案与问题陈述不一致。问题提供了一个拉伸点 $$(r_s, E_s)$$，而不是两个。它还提供了 $$D_e$$ 和 $$k_e$$ 作为用于参数化的高质量输入，而不是作为检查或待拟合的值。这个选项描述了一个完全不同的参数化过程，忽略了指定的输入。\n- **结论**：错误。\n\n**选项D：**\n所描述的方案是：\n1.  设置 $$D_e=E_s$$ 和 $$r_e=r_s$$。\n2.  估计 $$k_e \\approx V''(r_s)$$。\n3.  使用 $$a=\\sqrt{k_e/(2D_e)}$$。\n\n这个方案基于物理上和数学上荒谬的前提。\n-   $$D_e=E_s$$：解离能 $$D_e$$ 是无限分离时的能量，是束缚态可能的最大势能。$$E_s$$ 是在有限分离距离 $$r_s$$ 时的能量。对于任何有限的拉伸，$$E_s < D_e$$。将它们相等是一个根本性的错误。\n-   $$r_e=r_s$$：$$r_e$$ 是能量最小（$$V(r_e)=0$$）时的平衡键长。$$r_s$$ 是一个“显著伸长”的点，其能量 $$E_s > 0$$。将这两者等同起来直接与问题的设置和物理现实相矛盾。\n-   $$k_e\\approx V''(r_s)$$: $$k_e$$ 被定义为*在最小值*（$$r_e$$）处的曲率，而不是在拉伸位置 $$r_s$$ 处的曲率。摩尔斯势的曲率不是恒定的。\n\n所提供的论证是荒谬的，因为它建立在这些谬误之上。\n- **结论**：错误。", "answer": "$$\\boxed{A}$$", "id": "3395888"}, {"introduction": "非谐性的最重要物理效应之一是热膨胀——材料随温度升高而膨胀的趋势。本练习将指导你应用统计力学的基本原理，计算在给定温度的正则系综中键的平均长度$\\langle r \\rangle$。通过将$\\langle r \\rangle$与平衡键长$r_e$进行比较，你将能够量化这种依赖于温度的偏移，并更深刻地理解Morse势的不对称形状是如何产生这一基本材料属性的。[@problem_id:3395887]", "problem": "考虑一个在分子动力学 (MD) 中使用的、由非谐莫尔斯势控制的经典双原子键坐标。势能作为键长的函数由 $U_{M}(r)$ 给出，其中 $r$ 是核间距。温度为 $T$ 的正则系综为每个构型分配一个与 $\\exp(-\\beta U_{M}(r))$ 成正比的概率密度，其中 $\\beta = 1/(k_{B} T)$，$k_{B}$ 是玻尔兹曼常数。正则平均键长定义为两个在键长域上的积分之比。你的任务是为几个指定的参数集数值计算这个正则平均值，然后量化偏离平衡键长的非谐位移。\n\n从基础的统计力学原理出发：正则概率密度与 $\\exp(-\\beta U(r))$ 成正比，以及系综平均的定义是构型空间上的归一化积分。在你的推导和算法设计中，仅使用这些原理和给定的势函数作为基础。\n\n莫尔斯势为\n$$\nU_{M}(r) = D_{e} \\left(1 - e^{-a\\,(r - r_{e})}\\right)^{2},\n$$\n其中 $D_{e}$ 是势阱深度，$a$ 设定了势阱的逆长度标度，$r_{e}$ 是平衡键长。正则平均键长是\n$$\n\\langle r \\rangle = \\frac{\\int r \\, e^{-\\beta U_{M}(r)} \\, dr}{\\int e^{-\\beta U_{M}(r)} \\, dr}.\n$$\n\n重要的物理和数值考虑：\n- 在没有额外约束的情况下，对于莫尔斯势，对 $r$ 积分到 $+\\infty$ 是不可归一化的，因为当 $r \\to \\infty$ 时，$U_{M}(r) \\to D_{e}$，这导致一个不消失的玻尔兹曼因子。在实际的分子动力学中，解离或有限的分子环境限制了可及的 $r$。为了在远低于解离尺度的温度 $T$ 下获得一个定义明确、有物理意义的束缚态平均值，需要将积分限制在一个有限区间 $[r_{\\min}, r_{\\max}]$ 内，该区间通过一个玻尔兹曼权重容差和一个上限自适应地选择：\n  - 定义容差 $\\tau = 10^{-12}$ 和一个右侧上限 $L_{\\text{cap}} = 10\\,\\text{\\AA}$。\n  - 计算能量阈值 $U_{\\text{th}} = -k_{B} T \\ln \\tau$。\n  - 找到 $r_{\\text{L}} \\in (0, r_{e})$ 使得 $U_{M}(r_{\\text{L}}) = U_{\\text{th}}$，并设置 $r_{\\min} = \\max(0, r_{\\text{L}})$。\n  - 尝试找到 $r_{\\text{R}} \\in (r_{e}, r_{e} + L_{\\text{cap}})$ 使得 $U_{M}(r_{\\text{R}}) = U_{\\text{th}}$。如果这样的 $r_{\\text{R}}$ 存在，则设置 $r_{\\max} = r_{\\text{R}}$；否则，设置 $r_{\\max} = r_{e} + L_{\\text{cap}}$。\n  - 这构建了一个适用于束缚态占主导地位的温度 $T$ 的受限正则平均。你的数值方法应该能稳健地处理 $U_{\\text{th}} < D_{e}$ 和 $U_{\\text{th}} \\ge D_{e}$ 两种情况。\n\n程序要求：\n- 使用 $k_{B} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$。\n- 单位：\n  - 能量 $D_{e}$ 必须以焦耳 (Joules) 为单位。\n  - 温度 $T$ 必须以开尔文 (Kelvin) 为单位。\n  - 长度 $r$ 和 $r_{e}$ 必须以埃 ($\\text{\\AA}$) 为单位。\n  - 逆长度参数 $a$ 必须以 $\\text{\\AA}^{-1}$ 为单位。\n- 在 $[r_{\\min}, r_{\\max}]$ 上计算受限正则平均 $\\langle r \\rangle$ 和非谐位移 $\\Delta = \\langle r \\rangle - r_{e}$。将 $\\langle r \\rangle$ 和 $\\Delta$ 都以埃为单位表示。\n- 数值积分必须足够精确，以满足高级研究生水平的分析要求；使用具有严格容差的自适应求积法。\n\n测试套件：\n对于以下每个参数集 $(D_{e}, a, r_{e}, T)$，计算 $\\langle r \\rangle$ 和 $\\Delta$：\n1. $D_{e} = 8.000 \\times 10^{-19}\\,\\mathrm{J}$, $a = 2.0\\,\\text{\\AA}^{-1}$, $r_{e} = 1.0\\,\\text{\\AA}$, $T = 300\\,\\mathrm{K}$。\n2. $D_{e} = 8.000 \\times 10^{-20}\\,\\mathrm{J}$, $a = 1.5\\,\\text{\\AA}^{-1}$, $r_{e} = 1.5\\,\\text{\\AA}$, $T = 600\\,\\mathrm{K}$。\n3. $D_{e} = 1.1215 \\times 10^{-18}\\,\\mathrm{J}$, $a = 4.0\\,\\text{\\AA}^{-1}$, $r_{e} = 1.0\\,\\text{\\AA}$, $T = 50\\,\\mathrm{K}$。\n4. $D_{e} = 4.8065 \\times 10^{-20}\\,\\mathrm{J}$, $a = 2.0\\,\\text{\\AA}^{-1}$, $r_{e} = 1.2\\,\\text{\\AA}$, $T = 1000\\,\\mathrm{K}$。\n\n算法输出：\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 对于每个测试用例，列表应按顺序包含以埃为单位的正则平均 $\\langle r \\rangle$ 和以埃为单位的位移 $\\Delta$。对于这四个测试用例，输出必须包含八个浮点数：\n$$\n[\\langle r \\rangle_{1}, \\Delta_{1}, \\langle r \\rangle_{2}, \\Delta_{2}, \\langle r \\rangle_{3}, \\Delta_{3}, \\langle r \\rangle_{4}, \\Delta_{4}]\n$$\n所有长度均以埃为单位。", "solution": "该问题陈述已经过严格验证，并被认为是一个有效的科学问题。它在科学上基于经典统计力学的原理，在数学上是适定的，具有清晰而完整的给定条件，并以客观、正式的语言表述。其中没有矛盾、歧义或事实上的不健全之处。该任务是计算物理学中一个标准的、尽管非平凡的练习。因此，我们可以着手解决。\n\n该问题要求计算一个双原子分子的正则平均键长 $\\langle r \\rangle$，其势能 $U_{M}(r)$ 由莫尔斯势描述。该势的非谐性，即其与简单二次（谐振）形式的偏离，导致平均键长随温度变化而偏离势能最小值点 $r_{e}$。我们的目标是计算这个平均长度以及相应的位移 $\\Delta = \\langle r \\rangle - r_{e}$。\n\n基本原理是，在温度为 $T$ 的正则系综中，找到系统处于键长为 $r$ 的概率密度 $p(r)$ 与玻尔兹曼因子 $e^{-\\beta U(r)}$ 成正比，其中 $\\beta = 1/(k_{B}T)$，$k_{B}$ 是玻尔兹曼常数。\n$$\np(r) = \\frac{e^{-\\beta U_{M}(r)}}{Z}\n$$\n归一化常数 $Z$，即这个一维构型空间的配分函数，由玻尔兹曼因子在所有可能键长上的积分给出：\n$$\nZ = \\int e^{-\\beta U_{M}(r)} \\, dr\n$$\n任何可观测量 $A(r)$ 的正则平均值则通过其概率加权积分计算得出：\n$$\n\\langle A \\rangle = \\int A(r) p(r) \\, dr = \\frac{\\int A(r) e^{-\\beta U_{M}(r)} \\, dr}{\\int e^{-\\beta U_{M}(r)} \\, dr}\n$$\n对于这个问题，可观测量是键长本身，即 $A(r) = r$。因此，我们必须计算：\n$$\n\\langle r \\rangle = \\frac{\\int r \\, e^{-\\beta U_{M}(r)} \\, dr}{\\int e^{-\\beta U_{M}(r)} \\, dr}\n$$\n莫尔斯势由下式给出：\n$$\nU_{M}(r) = D_{e} \\left(1 - e^{-a(r - r_{e})}\\right)^{2}\n$$\n其中 $D_{e}$ 是解离能（势阱深度），$a$ 是一个控制势阱宽度的参数，$r_{e}$ 是对应于最小能量 $U_{M}(r_e) = 0$ 的平衡键长。\n\n一个关键问题来自于积分的域。当 $r \\to \\infty$ 时，项 $e^{-a(r-r_e)} \\to 0$，因此 $U_{M}(r) \\to D_{e}$。被积函数 $e^{-\\beta U_{M}(r)}$ 趋近于一个非零常数 $e^{-\\beta D_{e}}$。一个函数在无限域上趋近于一个正常数，其积分是发散的。这反映了物理现实，即在没有其他约束的情况下，存在有限的解离概率。该问题通过定义束缚态的受限正则平均来规避此问题。这在温度 $T$ 满足 $k_{B}T \\ll D_{e}$ 的情况下是物理上合理的，因为能量接近或高于 $D_{e}$ 的态是极不可能出现的。积分域被截断为一个区间 $[r_{\\min}, r_{\\max}]$，在该区间的边界上，玻尔兹曼因子根据给定的容差 $\\tau = 10^{-12}$ 而变得极小。\n\n确定积分边界 $[r_{\\min}, r_{\\max}]$ 的算法如下：\n1.  计算能量阈值 $U_{\\text{th}} = -k_{B} T \\ln \\tau$。这是玻尔兹曼权重 $e^{-\\beta U}$ 下降到容差 $\\tau$ 时的能量。注意 $U_{\\text{th}} = -\\frac{1}{\\beta} \\ln \\tau$。\n2.  为了找到积分极限，我们求解方程 $U_{M}(r) = U_{\\text{th}}$ 以得到 $r$：\n    $$\n    D_{e} \\left(1 - e^{-a(r - r_{e})}\\right)^{2} = U_{\\text{th}}\n    $$\n    $$\n    1 - e^{-a(r - r_{e})} = \\pm \\sqrt{\\frac{U_{\\text{th}}}{D_{e}}}\n    $$\n    $$\n    e^{-a(r - r_{e})} = 1 \\mp \\sqrt{\\frac{U_{\\text{th}}}{D_{e}}}\n    $$\n    $$\n    r = r_{e} - \\frac{1}{a} \\ln \\left(1 \\mp \\sqrt{\\frac{U_{\\text{th}}}{D_{e}}}\\right)\n    $$\n3.  这产生了两个可能的解。'+' 号对应于势的内壁 ($r < r_{e}$)，'-' 号对应于势的外壁 ($r > r_{e}$)。\n    -   左边界 $r_{\\text{L}}$ 使用 '+' 号找到：$r_{\\text{L}} = r_{e} - \\frac{1}{a} \\ln \\left(1 + \\sqrt{U_{\\text{th}}/D_{e}}\\right)$。这个解总是实数且小于 $r_e$。我们设置 $r_{\\min} = \\max(0, r_{\\text{L}})$，因为键长不能为负。\n    -   右边界 $r_{\\text{R}}$ 与 '-' 号相关联：$r_{\\text{R}} = r_{e} - \\frac{1}{a} \\ln \\left(1 - \\sqrt{U_{\\text{th}}/D_{e}}\\right)$。\n4.  $r_{\\max}$ 的确定取决于 $U_{\\text{th}}$ 是否小于 $D_{e}$：\n    -   **情况 1: $U_{\\text{th}} < D_{e}$**。项 $\\sqrt{U_{\\text{th}}/D_{e}} < 1$，所以对数的参数为正，存在一个实数解 $r_{\\text{R}} > r_{e}$。根据问题的约束，我们必须将此值限制在 $r_{e} + L_{\\text{cap}}$，其中 $L_{\\text{cap}} = 10\\,\\text{\\AA}$。因此，$r_{\\max} = \\min(r_{\\text{R}}, r_{e} + L_{\\text{cap}})$。\n    -   **情况 2: $U_{\\text{th}} \\ge D_{e}$**。项 $\\sqrt{U_{\\text{th}}/D_{e}} \\ge 1$，使得对数的参数为非正数。不存在 $r_{\\text{R}}$ 的实数解。在这种情况下（高温或浅势阱），玻尔兹曼权重在外壁上永远不会降到容差 $\\tau$ 以下。遵循问题的明确指示，我们使用硬上限：$r_{\\max} = r_{e} + L_{\\text{cap}}$。\n\n建立了积分极限 $[r_{\\min}, r_{\\max}]$ 后，我们可以定义需要数值计算的两个定积分：\n$$\nN = \\int_{r_{\\min}}^{r_{\\max}} r \\, e^{-\\beta U_{M}(r)} \\, dr\n$$\n$$\nZ = \\int_{r_{\\min}}^{r_{\\max}} e^{-\\beta U_{M}(r)} \\, dr\n$$\n平均键长即为 $\\langle r \\rangle = N/Z$，非谐位移为 $\\Delta = \\langle r \\rangle - r_{e}$。由于莫尔斯势的不对称形状（对于 $r > r_{e}$ 比 $r < r_{e}$ 更平缓），我们预计对于任何 $T > 0$，$\\langle r \\rangle$ 都将大于 $r_{e}$，从而导致正的位移 $\\Delta$。\n\n计算将使用自适应求积法实现，如 `scipy.integrate.quad` 函数所提供的，以确保对这些行为良好但可能急剧峰化的函数的数值积分具有高精度。上述定义的逻辑将应用于测试套件中的每个参数集。所有单位必须一致；我们将按规定使用焦耳表示能量，开尔文表示温度，埃表示长度。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Computes the canonical average bond length and anharmonic shift for a diatomic\n    molecule described by a Morse potential for several test cases.\n    \"\"\"\n\n    # Physical constant and numerical parameters\n    K_B = 1.380649e-23  # Boltzmann constant in J/K\n    TAU = 1.0e-12       # Boltzmann weight tolerance\n    L_CAP = 10.0        # Right-hand integration cap in Angstroms\n\n    # Test suite: (D_e [J], a [A^-1], r_e [A], T [K])\n    test_cases = [\n        (8.000e-19, 2.0, 1.0, 300.0),\n        (8.000e-20, 1.5, 1.5, 600.0),\n        (1.1215e-18, 4.0, 1.0, 50.0),\n        (4.8065e-20, 2.0, 1.2, 1000.0),\n    ]\n\n    results = []\n\n    def compute_metrics(De, a, re, T):\n        \"\"\"\n        Calculates the canonical average bond length and anharmonic shift for a given \n        set of Morse potential parameters and temperature.\n        \"\"\"\n        if T == 0:\n            return re, 0.0\n\n        beta = 1.0 / (K_B * T)\n        U_th = -K_B * T * np.log(TAU)\n\n        def morse_potential(r):\n            return De * (1.0 - np.exp(-a * (r - re)))**2\n\n        # Determine integration bounds\n        # Left bound\n        r_L = re - (1.0/a) * np.log(1.0 + np.sqrt(U_th / De))\n        r_min = max(0.0, r_L)\n\n        # Right bound\n        if U_th  De:\n            sqrt_term = np.sqrt(U_th / De)\n            if (1.0 - sqrt_term) > 1e-15: # Safety for numerical precision\n                r_R = re - (1.0/a) * np.log(1.0 - sqrt_term)\n                r_max = min(r_R, re + L_CAP)\n            else:\n                r_max = re + L_CAP\n        else:\n            r_max = re + L_CAP\n        \n        def integrand_Z(r):\n            return np.exp(-beta * morse_potential(r))\n        \n        def integrand_N(r):\n            return r * integrand_Z(r)\n\n        # Perform numerical integration with high precision\n        Z_val, _ = quad(integrand_Z, r_min, r_max, epsabs=1e-13, epsrel=1e-13)\n        N_val, _ = quad(integrand_N, r_min, r_max, epsabs=1e-13, epsrel=1e-13)\n\n        if Z_val == 0:\n            r_avg = re\n        else:\n            r_avg = N_val / Z_val\n        \n        delta = r_avg - re\n        return r_avg, delta\n\n    for case in test_cases:\n        De, a, re, T = case\n        r_avg, delta = compute_metrics(De, a, re, T)\n        results.extend([r_avg, delta])\n\n    # Format the output string as required\n    output_str = \"[\" + \", \".join(f\"{val}\" for val in results) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3395887"}, {"introduction": "模拟非谐振子的动力学过程带来了一个数值上的挑战：势能的曲率（以及振动的特征频率）会随着键的压缩和拉伸而急剧变化。本练习要求你实现并比较一个简单的固定时间步长积分器和一个更复杂的自适应时间步长方案。通过这个实践，你将亲身体验现代分子动力学模拟的一个关键方面，并学会如何在处理真实化学键的“刚性”力时保持数值稳定性和能量守恒。[@problem_id:3395874]", "problem": "考虑一个双原子键的单自由度模型，其运动由标量键坐标 $r(t)$ 描述，遵循牛顿第二定律 $m \\, d^{2}r/dt^{2} = - \\, dU(r)/dr$。其中，$m$ 是折合质量，$U(r)$ 是莫尔斯势 $U(r) = D_{e} \\left(1 - e^{-a \\, (r - r_{e})}\\right)^{2}$。在约化（无量纲）单位下进行计算，使得 $r$、$t$、$m$、$D_{e}$、$a$ 和 $r_{e}$ 均为无量纲标量，且总能量 $E(t) = \\tfrac{1}{2} m \\, v^{2}(t) + U(r(t))$ 也是无量纲的。设计一个用于显式时间积分的自适应步长方案。该方案利用瞬时曲率，通过局域频率代理 $\\omega(t) = \\sqrt{\\max\\{U''(r(t)), \\, 0\\}/m}$ 来限制步长，并结合明确的步长下限和上限。目的是比较这种基于曲率的自适应步长方案与固定步长方案在能量守恒方面的影响。\n\n你的程序必须仅从上述定义和标准定律出发，完成以下所有任务：\n- 从给定的 $U(r)$ 解析地推导出 $dU(r)/dr$ 和 $d^{2}U(r)/dr^{2}$。\n- 实现一个速度 Verlet 積分器来演化 $r(t)$ 和 $v(t)$：\n  - 对于固定步长方案，使用恒定步长 $\\Delta t_{\\mathrm{fix}}$。\n  - 对于自适应步長方案，在每一步根据 $U''(r(t))$ 和 $m$ 计算 $\\omega(t)$，并选择满足约束条件 $\\omega(t) \\, \\Delta t(t) \\le \\eta$ 的最大步长 $\\Delta t(t)$，同时强制步长满足 $\\Delta t_{\\min} \\le \\Delta t(t) \\le \\Delta t_{\\max}$。如果 $U''(r(t)) \\le 0$，则在施加约束时将 $\\omega(t)$ 视为 $0$。通过必要时缩短最后一步，确保最后一步恰好落在指定的最终时间 $T$ 上。\n- 对每条轨迹，计算在模拟时间区间 $[0, T]$ 内的最大相对能量偏差，其定义为\n$$\\varepsilon_{\\max} \\equiv \\max_{i} \\frac{\\left|E(t_{i}) - E(0)\\right|}{\\max\\left\\{\\left|E(0)\\right|, \\, 10^{-12}\\right\\}},$$\n其中 $t_{i}$ 是计算能量的离散积分器时间点。\n- 对每个测试用例，报告两个值：固定步长的 $\\varepsilon_{\\max}$ 和自适应步长的 $\\varepsilon_{\\max}$。\n\n测试套件。使用以下参数集，所有参数均采用约化单位：\n- 用例 1：$D_{e} = 20.0$，$a = 1.5$，$r_{e} = 1.0$，$m = 1.0$，$r(0) = 1.1$，$v(0) = 0.0$，$T = 150.0$，$\\Delta t_{\\mathrm{fix}} = 0.02$，$\\eta = 0.2$，$\\Delta t_{\\min} = 0.002$，$\\Delta t_{\\max} = 0.02$。\n- 用例 2：$D_{e} = 20.0$，$a = 1.5$，$r_{e} = 1.0$，$m = 1.0$，$r(0) = 1.8$，$v(0) = 0.0$，$T = 150.0$，$\\Delta t_{\\mathrm{fix}} = 0.02$，$\\eta = 0.2$，$\\Delta t_{\\min} = 0.002$，$\\Delta t_{\\max} = 0.02$。\n- 用例 3：$D_{e} = 5.0$，$a = 3.0$，$r_{e} = 1.0$，$m = 0.5$，$r(0) = 0.95$，$v(0) = 0.0$，$T = 100.0$，$\\Delta t_{\\mathrm{fix}} = 0.005$，$\\eta = 0.15$，$\\Delta t_{\\min} = 0.0005$，$\\Delta t_{\\max} = 0.005$。\n\n要求的输出格式。你的程序应生成单行输出，其中包含一个列表的列表（嵌套列表），每个测试用例对应一个子列表，顺序与上文一致。每个子列表包含两个浮点数值 $[\\varepsilon_{\\max}^{\\mathrm{fix}}, \\varepsilon_{\\max}^{\\mathrm{adapt}}]$。将每个浮点值四舍五入到恰好 8 位小数，并以类似 Python 字面量的形式（例如 `[[0.12345678,0.23456789],[\\dots],\\dots]`）打印该嵌套列表。", "solution": "该问题要求对一个由莫尔斯势控制的一维系统，比较固定步长和自适应步长两种数值积分方法。任务的核心是为这两种场景实现速度 Verlet 算法，并基于能量守恒来评估它们的性能。所有计算都在无量纲单位系统中执行。\n\n首先，我们必须推导力和势能二阶导数的解析表达式，它们分别对积分器和自适应步长方案至關重要。莫尔斯势由以下公式给出：\n$$U(r) = D_{e} \\left(1 - e^{-a \\, (r - r_{e})}\\right)^{2}$$\n其中 $D_{e}$ 是解离能，$r_{e}$ 是平衡键长，$a$ 控制势阱的宽度。\n\n力 $F(r)$ 是势能的负梯度：$F(r) = - \\frac{dU(r)}{dr}$。我们使用链式法则计算一阶导数：\n$$ \\frac{dU}{dr} = D_{e} \\cdot 2 \\left(1 - e^{-a \\, (r - r_{e})}\\right) \\cdot \\frac{d}{dr}\\left(- e^{-a \\, (r - r_{e})}\\right) $$\n$$ \\frac{dU}{dr} = 2 D_{e} \\left(1 - e^{-a \\, (r - r_{e})}\\right) \\cdot \\left(-e^{-a \\, (r - r_{e})} \\cdot (-a)\\right) $$\n$$ \\frac{dU}{dr} = 2 a D_{e} \\left(1 - e^{-a \\, (r - r_{e})}\\right) e^{-a \\, (r - r_{e})} $$\n$$ \\frac{dU}{dr} = 2 a D_{e} \\left(e^{-a \\, (r - r_{e})} - e^{-2a \\, (r - r_{e})}\\right) $$\n因此，力为：\n$$ F(r) = -2 a D_{e} \\left(e^{-a \\, (r - r_{e})} - e^{-2a \\, (r - r_{e})}\\right) $$\n\n接下来，我们计算势能的二阶导数 $U''(r) = \\frac{d^{2}U(r)}{dr^{2}}$，它是势能面局部曲率的度量。这是自适应步长计算所必需的。\n$$ \\frac{d^{2}U}{dr^{2}} = \\frac{d}{dr} \\left[ 2 a D_{e} \\left(e^{-a \\, (r - r_{e})} - e^{-2a \\, (r - r_{e})}\\right) \\right] $$\n$$ \\frac{d^{2U}}{dr^{2}} = 2 a D_{e} \\left[ -a e^{-a \\, (r - r_{e})} - (-2a) e^{-2a \\, (r - r_{e})} \\right] $$\n$$ \\frac{d^{2}U}{dr^{2}} = 2 a^{2} D_{e} \\left[ 2e^{-2a \\, (r - r_{e})} - e^{-a \\, (r - r_{e})} \\right] $$\n\n系统的动力学使用速度 Verlet 算法进行模拟，这是一种在分子动力学中广泛使用的时间可逆和辛积分器。对于给定的步长 $\\Delta t$，位置 $r(t)$、速度 $v(t)$ 和加速度 $a(t) = F(r(t))/m$ 按如下方式更新：\n1. 更新位置：$r(t + \\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2} a(t) (\\Delta t)^{2}$\n2. 计算新的力 $F(r(t+\\Delta t))$ 和加速度 $a(t + \\Delta t) = F(r(t+\\Delta t))/m$。\n3. 更新速度：$v(t + \\Delta t) = v(t) + \\frac{1}{2} [a(t) + a(t + \\Delta t)] \\Delta t$\n\n实现了两种步长方案：\n1.  **固定步长**：在整个模拟过程中使用恒定的步长 $\\Delta t = \\Delta t_{\\mathrm{fix}}$。\n2.  **自适应步长**：步长 $\\Delta t(t)$ 在每一步都根据局域动力学进行调整。局域频率代理 $\\omega(t) = \\sqrt{\\max\\{U''(r(t)), 0\\}/m}$ 表征了运动的最快时间尺度。选择步长 $\\Delta t(t)$ 以满足稳定性条件 $\\omega(t) \\Delta t(t) \\le \\eta$，其中 $\\eta$ 是一个控制每个振荡周期步数的无量纲参数。如果 $U''(r(t)) \\le 0$，势能是凸的或线性的，表明没有局域振荡行为，因此 $\\omega(t)$ 设为 $0$。在这种情况下，该约束不提供上限。最终步长通过寻找满足稳定性约束且被限制在 $[\\Delta t_{\\min}, \\Delta t_{\\max}]$ 范围内的最大值来确定。具体来说，来自稳定性约束的步长 $\\Delta t_{s}$ 在 $\\omega(t)  0$ 时为 $\\Delta t_{s} = \\eta/\\omega(t)$，否则实际上是无限大。然后，所选步长为 $\\Delta t(t) = \\max\\{\\Delta t_{\\min}, \\min\\{\\Delta t_{s}, \\Delta t_{\\max}\\}\\}$。对于这兩種方案，如有必要，都会缩短最后的积分步长，以确保模拟在时间 $T$ 精确终止。\n\n为了量化每种方案的性能，我们计算整个轨迹上的最大相对能量偏差 $\\varepsilon_{\\max}$。总能量为 $E(t) = \\frac{1}{2} m v^{2}(t) + U(r(t))$。偏差定义为：\n$$ \\varepsilon_{\\max} = \\max_{i} \\frac{\\left|E(t_{i}) - E(0)\\right|}{\\max\\left\\{\\left|E(0)\\right|, \\, 10^{-12}\\right\\}} $$\n其中 $t_i$ 是模拟的离散时间点。分母中包含一个小的下限值 $10^{-12}$，以防止初始能量恰好为零时发生除零错误。较小的 $\\varepsilon_{\\max}$ 表示更好的能量守恒性，从而意味着更精确的数值积分。\n\n该程序通过为势能 $U(r)$、力 $F(r)$ 和二阶导数 $U''(r)$ 定义函数来实现这些原理。一个通用的模拟函数封装了速度 Verlet 循环，该循环可以在固定或自适应模式下运行。对每个测试用例调用此函数以计算 $\\varepsilon_{\\max}^{\\mathrm{fix}}$ 和 $\\varepsilon_{\\max}^{\\mathrm{adapt}}$，然后按要求将其格式化并打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation test suite and print results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"De\": 20.0, \"a\": 1.5, \"re\": 1.0, \"m\": 1.0,\n            \"r0\": 1.1, \"v0\": 0.0, \"T\": 150.0,\n            \"dt_fix\": 0.02, \"eta\": 0.2, \"dt_min\": 0.002, \"dt_max\": 0.02\n        },\n        # Case 2\n        {\n            \"De\": 20.0, \"a\": 1.5, \"re\": 1.0, \"m\": 1.0,\n            \"r0\": 1.8, \"v0\": 0.0, \"T\": 150.0,\n            \"dt_fix\": 0.02, \"eta\": 0.2, \"dt_min\": 0.002, \"dt_max\": 0.02\n        },\n        # Case 3\n        {\n            \"De\": 5.0, \"a\": 3.0, \"re\": 1.0, \"m\": 0.5,\n            \"r0\": 0.95, \"v0\": 0.0, \"T\": 100.0,\n            \"dt_fix\": 0.005, \"eta\": 0.15, \"dt_min\": 0.0005, \"dt_max\": 0.005\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        \n        # --- Potential, Force, and Second Derivative Functions ---\n        De, a, re = params[\"De\"], params[\"a\"], params[\"re\"]\n\n        def potential(r):\n            term = 1.0 - np.exp(-a * (r - re))\n            return De * term**2\n\n        def force(r):\n            exp1 = np.exp(-a * (r - re))\n            exp2 = np.exp(-2 * a * (r - re))\n            return -2 * a * De * (exp1 - exp2)\n\n        def potential_pp(r): # Second derivative\n            exp1 = np.exp(-a * (r - re))\n            exp2 = np.exp(-2 * a * (r - re))\n            return 2 * a**2 * De * (2 * exp2 - exp1)\n        \n        funcs = {\n            \"U\": potential,\n            \"F\": force,\n            \"U_pp\": potential_pp\n        }\n\n        # --- Run fixed and adaptive simulations ---\n        eps_fix = run_simulation(params, funcs, adaptive=False)\n        eps_adapt = run_simulation(params, funcs, adaptive=True)\n        all_results.append([eps_fix, eps_adapt])\n\n    # --- Format and print final output ---\n    sublists_str = [f\"[{res[0]:.8f},{res[1]:.8f}]\" for res in all_results]\n    final_output = \"[\" + \",\".join(sublists_str) + \"]\"\n    print(final_output)\n\ndef run_simulation(params, funcs, adaptive):\n    \"\"\"\n    Runs a single simulation using the velocity Verlet integrator.\n\n    Args:\n        params (dict): Dictionary of simulation parameters.\n        funcs (dict): Dictionary of physics functions (U, F, U_pp).\n        adaptive (bool): If True, use adaptive timestepping. Otherwise, use fixed.\n\n    Returns:\n        float: The maximum relative energy deviation (epsilon_max).\n    \"\"\"\n    # Unpack parameters\n    m, r0, v0, T = params[\"m\"], params[\"r0\"], params[\"v0\"], params[\"T\"]\n    dt_fix, eta, dt_min, dt_max = (\n        params.get(\"dt_fix\"), params.get(\"eta\"),\n        params.get(\"dt_min\"), params.get(\"dt_max\")\n    )\n    \n    # Physics functions\n    U, F, U_pp = funcs[\"U\"], funcs[\"F\"], funcs[\"U_pp\"]\n\n    # Initial conditions\n    t = 0.0\n    r = r0\n    v = v0\n    acc = F(r) / m\n\n    # Energy calculation setup\n    E0 = 0.5 * m * v**2 + U(r)\n    E_denom = max(abs(E0), 1e-12)\n    max_rel_error = 0.0\n\n    while t  T:\n        # Determine timestep dt\n        if adaptive:\n            U_double_prime = U_pp(r)\n            if U_double_prime > 0:\n                omega = np.sqrt(U_double_prime / m)\n                dt_stable = eta / omega if omega > 1e-12 else float('inf')\n            else:\n                dt_stable = float('inf')\n            \n            dt = min(dt_stable, dt_max)\n            dt = max(dt, dt_min)\n        else: # Fixed timestep\n            dt = dt_fix\n\n        # Ensure final step lands exactly at T\n        if t + dt > T:\n            dt = T - t\n\n        # Exit condition if dt becomes too small (prevents infinite loops)\n        if dt  1e-15:\n            break\n            \n        # Velocity Verlet integrator step\n        r = r + v * dt + 0.5 * acc * dt**2\n        acc_new = F(r) / m\n        v = v + 0.5 * (acc + acc_new) * dt\n        \n        # Update state for next iteration\n        acc = acc_new\n        t += dt\n\n        # Calculate and track energy deviation\n        E_current = 0.5 * m * v**2 + U(r)\n        rel_error = abs(E_current - E0) / E_denom\n        if rel_error > max_rel_error:\n            max_rel_error = rel_error\n            \n    return max_rel_error\n\nsolve()\n```", "id": "3395874"}]}