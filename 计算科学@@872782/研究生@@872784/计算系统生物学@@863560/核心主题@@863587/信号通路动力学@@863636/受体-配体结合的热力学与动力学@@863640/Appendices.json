{"hands_on_practices": [{"introduction": "分子间的相互作用并非发生在真空中。在生物体内，受体与配体的结合受到周围溶液环境的深刻影响，尤其是离子强度。此练习将引导你运用经典的德拜-休克尔理论，将以活度定义的热力学平衡常数与实验中更易测量的、基于浓度的动力学参数（如解离速率常数 $k_{\\mathrm{off}}$）联系起来。通过这个计算，你将亲身体会到静电筛选效应对生物分子相互作用的调节机制，这是理解生理条件下反应动力学的基础。[@problem_id:3344616]", "problem": "一个在温度为 $298\\ \\mathrm{K}$ 的水溶液中的受体-配体系统，由可逆结合反应 $R + L \\rightleftharpoons RL$ 描述。在 $298\\ \\mathrm{K}$ 时，无限稀释（以活度定义）下的热力学标准结合常数为 $K_{a}^{0} = 1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}$。溶液中含有一种支持性的 $1{:}1$ 电解质，离子强度为 $I = 0.010\\ \\mathrm{M}$，该强度足够低，可以适用 Debye–Hückel 极限法。在所关注的 pH 范围内，受体、配体和复合物的净电荷分别为 $z_{R} = -3$、$z_{L} = +2$ 和 $z_{RL} = -1$。假设长程静电屏蔽是影响非理想性的唯一离子强度效应，并且短程特定离子效应可以忽略不计。\n\n使用以下基本事实：\n- 溶质组分 $i$ 的化学势为 $\\mu_{i} = \\mu_{i}^{\\circ} + RT \\ln a_{i}$，其中 $a_{i} = \\gamma_{i} c_{i}$ 是活度，$\\gamma_{i}$ 是活度系数，$c_{i}$ 是摩尔浓度。\n- 在平衡状态下，活度满足无限稀释时热力学结合常数 $K_{a}^{0}$ 的定义。\n- 对于低离子强度下的 $z{:}z$ 电解质，Debye–Hückel 极限法给出 $\\log_{10} \\gamma_{i} = -A z_{i}^{2} \\sqrt{I}$，其中对于 $298\\ \\mathrm{K}$ 的水，$A = 0.509$，$I$ 是离子强度。\n\n正向速率（结合速率常数）是扩散限制的，并假定其与离子强度无关，为 $k_{\\mathrm{on}} = 1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}$。\n\n从化学势的定义和基于活度的平衡条件出发，推导离子强度如何以活度系数的形式改变在 $I \\neq 0$ 时基于浓度的结合常数，然后计算在 $I = 0.010\\ \\mathrm{M}$ 时的解离速率常数 $k_{\\mathrm{off}}$。以 $\\mathrm{s}^{-1}$ 为单位表示最终答案，并四舍五入至三位有效数字。", "solution": "该问题是有效的，因为它科学地基于物理化学原理（溶液的热力学和动力学），问题陈述清晰，提供了所有必要信息，并且其表述是客观的。\n\n可逆结合反应由 $R + L \\rightleftharpoons RL$ 给出。\n在化学平衡时，反应的吉布斯自由能变为零。这转化为产物的化学势等于反应物化学势之和的条件：\n$$ \\mu_{RL} = \\mu_{R} + \\mu_{L} $$\n组分 $i$ 的化学势由 $\\mu_{i} = \\mu_{i}^{\\circ} + RT \\ln a_{i}$ 给出，其中 $\\mu_{i}^{\\circ}$ 是标准化学势，$R$ 是气体常数，$T$ 是绝对温度，$a_{i}$ 是该组分的活度。将此代入平衡条件：\n$$ \\mu_{RL}^{\\circ} + RT \\ln a_{RL} = (\\mu_{R}^{\\circ} + RT \\ln a_{R}) + (\\mu_{L}^{\\circ} + RT \\ln a_{L}) $$\n重新整理各项可得：\n$$ \\mu_{RL}^{\\circ} - \\mu_{R}^{\\circ} - \\mu_{L}^{\\circ} = RT (\\ln a_{R} + \\ln a_{L} - \\ln a_{RL}) $$\n左边是结合反应的标准吉布斯自由能变 $\\Delta G_{a}^{\\circ}$。该方程可以重写为：\n$$ \\Delta G_{a}^{\\circ} = -RT \\ln \\left( \\frac{a_{RL}}{a_{R} a_{L}} \\right) $$\n热力学标准结合常数 $K_{a}^{0}$ 由关系式 $\\Delta G_{a}^{\\circ} = -RT \\ln K_{a}^{0}$ 定义。因此，在平衡时，活度由以下关系式关联：\n$$ K_{a}^{0} = \\frac{a_{RL}}{a_{R} a_{L}} $$\n活度 $a_i$ 通过活度系数 $\\gamma_i$ 与摩尔浓度 $c_i$ 相关，即 $a_i = \\gamma_i c_i$。将此代入 $K_{a}^{0}$ 的表达式中：\n$$ K_{a}^{0} = \\frac{\\gamma_{RL} c_{RL}}{(\\gamma_{R} c_{R}) (\\gamma_{L} c_{L})} = \\left( \\frac{\\gamma_{RL}}{\\gamma_{R} \\gamma_{L}} \\right) \\left( \\frac{c_{RL}}{c_{R} c_{L}} \\right) $$\n在给定离子强度 $I$ 下，基于浓度的结合常数，记为 $K_{a}(I)$，定义为：\n$$ K_{a}(I) = \\frac{c_{RL}}{c_{R} c_{L}} $$\n因此，我们得到了热力学常数 $K_{a}^{0}$（在无限稀释下，所有 $\\gamma_i=1$）与在离子强度 $I$ 下基于浓度的常数 $K_{a}(I)$ 之间的关系：\n$$ K_{a}^{0} = K_{a}(I) \\left( \\frac{\\gamma_{RL}}{\\gamma_{R} \\gamma_{L}} \\right) $$\n这个表达式可以重新整理，以显示基于浓度的结合常数如何被离子强度所修正，这是任务的第一部分：\n$$ K_{a}(I) = K_{a}^{0} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right) $$\n活度系数 $\\gamma_i$ 使用 $T=298\\ \\mathrm{K}$ 水溶液的 Debye–Hückel 极限法计算：\n$$ \\log_{10} \\gamma_{i} = -A z_{i}^{2} \\sqrt{I} $$\n其中 $A = 0.509$，$z_i$ 是组分 $i$ 的电荷，$I$ 是离子强度。\n为了找到 $K_{a}(I)$ 的校正因子，我们可以处理活度系数比值的对数：\n$$ \\log_{10} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right) = \\log_{10} \\gamma_{R} + \\log_{10} \\gamma_{L} - \\log_{10} \\gamma_{RL} $$\n代入 Debye–Hückel 定律：\n$$ \\log_{10} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right) = (-A z_{R}^{2} \\sqrt{I}) + (-A z_{L}^{2} \\sqrt{I}) - (-A z_{RL}^{2} \\sqrt{I}) $$\n$$ \\log_{10} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right) = -A \\sqrt{I} (z_{R}^{2} + z_{L}^{2} - z_{RL}^{2}) $$\n问题提供的值为：$z_{R} = -3$、$z_{L} = +2$、$z_{RL} = -1$、$I = 0.010\\ \\mathrm{M}$ 和 $A = 0.509$。\n首先，我们计算涉及电荷的项：\n$$ z_{R}^{2} + z_{L}^{2} - z_{RL}^{2} = (-3)^{2} + (+2)^{2} - (-1)^{2} = 9 + 4 - 1 = 12 $$\n现在我们计算比值的对数：\n$$ \\log_{10} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right) = -0.509 \\times \\sqrt{0.010} \\times 12 = -0.509 \\times 0.1 \\times 12 = -0.6108 $$\n所以，校正因子是 $10^{-0.6108}$。\n基于浓度的结合常数也是正向速率常数 $k_{\\mathrm{on}}$ 和逆向速率常数 $k_{\\mathrm{off}}$ 的比值：\n$$ K_{a}(I) = \\frac{k_{\\mathrm{on}}(I)}{k_{\\mathrm{off}}(I)} $$\n问题指出 $k_{\\mathrm{on}}$ 与离子强度无关，所以 $k_{\\mathrm{on}}(I) = k_{\\mathrm{on}} = 1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}$。\n我们需要求出在 $I=0.010\\ \\mathrm{M}$ 时的 $k_{\\mathrm{off}}$，我们将其记为 $k_{\\mathrm{off}}(I)$。\n$$ k_{\\mathrm{off}}(I) = \\frac{k_{\\mathrm{on}}}{K_{a}(I)} $$\n代入 $K_{a}(I)$ 的表达式：\n$$ k_{\\mathrm{off}}(I) = \\frac{k_{\\mathrm{on}}}{K_{a}^{0} \\left( \\frac{\\gamma_{R} \\gamma_{L}}{\\gamma_{RL}} \\right)} $$\n给定 $K_{a}^{0} = 1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}$。\n$$ k_{\\mathrm{off}}(I) = \\frac{1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}\\ \\mathrm{s}^{-1}}{(1.00 \\times 10^{8}\\ \\mathrm{M}^{-1}) \\times 10^{-0.6108}} $$\n$$ k_{\\mathrm{off}}(I) = \\frac{1}{10^{-0.6108}} \\ \\mathrm{s}^{-1} = 10^{0.6108}\\ \\mathrm{s}^{-1} $$\n现在，我们计算数值：\n$$ k_{\\mathrm{off}}(I) \\approx 4.08133 \\ \\mathrm{s}^{-1} $$\n四舍五入到三位有效数字，在 $I = 0.010\\ \\mathrm{M}$ 时的解离速率常数为 $4.08\\ \\mathrm{s}^{-1}$。\n电解质的存在屏蔽了带相反电荷的受体（$z_R = -3$）和配体（$z_L = +2$）之间有利的静电吸引力。与无限稀释的情况相比，这种屏蔽作用使复合物不稳定，导致结合减弱（$K_a(I)$ 更低）和解离加快（$k_{\\mathrm{off}}(I)$ 更高）。我们的结果与这一物理图像一致。", "answer": "$$\\boxed{4.08}$$", "id": "3344616"}, {"introduction": "许多关键的生物学过程，如氧气与血红蛋白的结合，都表现出“全或无”的开关特性，这源于变构效应和协同性。本练习将深入探讨用于描述这类现象的经典理论——Monod-Wyman-Changeux (MWC) 模型。你将从第一性原理出发，推导MWC模型的结合曲线方程，并编写程序来计算和分析描述协同性的关键参数，如希尔系数 $n_H$。这项实践将为你提供一个分析和量化复杂协同结合系统的实用工具。[@problem_id:3344587]", "problem": "一个受体-配体系统采用 Monod–Wyman–Changeux (MWC) 变构框架进行建模。该受体是一个寡聚体，具有 $N$ 个相同的配体结合位点，并可以存在于两种全局构象状态中：紧张态 $R_T$ 和松弛态 $R_R$，这两种状态可相互转换 $R_T \\rightleftharpoons R_R$。变构常数 $L$ 定义为在配体浓度 $C = 0$ 时，未结合配体状态的布居比例 $L = [R_T]/[R_R]$。在每种构象内部，$N$ 个结合位点是独立且等效的，对于 $R_T$ 和 $R_R$ 的微观解离常数分别为 $K_{d,T}$ 和 $K_{d,R}$。令 $\\theta(C)$ 表示在配体浓度为 $C$ 时的饱和分数（即已占据位点的期望分数）。\n\n从质量作用定律和每种构象中独立结合的基本统计力学计数出发，推导 MWC 假设所蕴含的函数依赖关系 $\\theta(C)$，过程中不使用任何预先推导的简化公式。使用推导出的 $\\theta(C)$ 计算以下量：\n\n1.  半饱和浓度 $C_{0.5}$，由方程 $\\theta(C_{0.5}) = 0.5$ 定义。将 $C_{0.5}$ 以摩尔（M）为单位表示。\n\n2.  半饱和时的 Hill 系数 $n_H$，操作上定义为 Hill 图在 $\\theta = 0.5$ 处的斜率，\n    $$\n    n_H = \\left.\\frac{d \\log\\left(\\frac{\\theta}{1 - \\theta}\\right)}{d \\log C}\\right|_{C = C_{0.5}},\n    $$\n    其中 $\\log$ 表示自然对数。$n_H$ 是无量纲的。\n\n3.  结合曲线在配体浓度趋于零时的初始斜率 $S_0$，\n    $$\n    S_0 = \\lim_{C \\to 0^+} \\frac{d \\theta}{d C},\n    $$\n    以 $\\mathrm{M}^{-1}$ 为单位表示。\n\n你的程序必须实现一个算法，对于每个测试参数集，仅使用上述基本原理（质量作用定律和 MWC 模型下的组合/统计计数）来计算 $C_{0.5}$、在 $C_{0.5}$ 处计算的 $n_H$ 以及 $S_0$。对于 $C_{0.5}$，你必须使用一个无需外部输入的稳健区间法来数值求解 $\\theta(C) = 0.5$。对于 $n_H$ ，你必须使用你推导的解析表达式来计算导数，而非有限差分。对于 $S_0$，你必须从你推导的 $\\theta(C)$ 解析地计算极限。\n\n使用以下测试参数组，每个参数组指定为 $(N, K_{d,T}, K_{d,R}, L)$，其中 $K_{d,T}$ 和 $K_{d,R}$ 的单位为摩尔（M），$L$ 为无量纲：\n\n-   测试用例 1（协同机制，初始偏好紧张态）：$(4, 2\\times 10^{-4}, 1\\times 10^{-6}, 1000)$。\n-   测试用例 2（具有相同微观解离常数的非协同基线）：$(4, 1\\times 10^{-5}, 1\\times 10^{-5}, 100)$。\n-   测试用例 3（单价受体边界情况）：$(1, 5\\times 10^{-6}, 5\\times 10^{-7}, 50)$。\n-   测试用例 4（初始偏好松弛态，弱变构效应）：$(4, 5\\times 10^{-6}, 1\\times 10^{-6}, 1\\times 10^{-3})$。\n-   测试用例 5（极端变构效应与微观亲和力差异）：$(4, 1\\times 10^{-3}, 1\\times 10^{-9}, 1\\times 10^{6})$。\n\n要求的最终输出格式：你的程序应生成单行输出，包含所有五个测试用例的结果，形式为由方括号括起来的逗号分隔列表，其中每个测试用例贡献一个包含三个浮点数 $[n_H, C_{0.5}, S_0]$ 的子列表（按此顺序）。所有数字必须四舍五入到六位有效数字。例如，整体输出必须具有以下形式：\n$$\n[[n_{H,1}, C_{0.5,1}, S_{0,1}],[n_{H,2}, C_{0.5,2}, S_{0,2}],[n_{H,3}, C_{0.5,3}, S_{0,3}],[n_{H,4}, C_{0.5,4}, S_{0,4}],[n_{H,5}, C_{0.5,5}, S_{0,5}]]\n$$\n打印行中不含空格。每个 $C_{0.5}$ 必须以 $\\mathrm{M}$ 为单位，每个 $S_0$ 必须以 $\\mathrm{M}^{-1}$ 为单位。", "solution": "用户要求解决一个基于 Monod-Wyman-Changeux (MWC) 变构模型的受体-配体结合问题。任务要求从第一性原理推导饱和分数 $\\theta(C)$ 的函数形式，然后用它来计算半饱和浓度 $C_{0.5}$、半饱和时的 Hill 系数 $n_H$ 和结合曲线的初始斜率 $S_0$。\n\n**1. 饱和分数函数 $\\theta(C)$ 的推导**\n\nMWC 模型假定一个具有 $N$ 个相同且独立结合位点的受体存在于两种构象状态：紧张态 ($R_T$) 和松弛态 ($R_R$) 。这两种状态处于平衡中，$R_T \\rightleftharpoons R_R$，在没有配体的情况下（$C=0$），由变构常数 $L = [R_T]/[R_R]$ 控制。配体以不同的微观解离常数与每种状态结合，T 态为 $K_{d,T}$，R 态为 $K_{d,R}$。\n\n让我们考虑每种状态下受体物种的布居。对于处于状态 $S \\in \\{T, R\\}$ 的受体，具有 $N$ 个独立位点和微观解离常数 $K_{d,S}$，结合了 $k$ 个配体的受体浓度 $[R_{S,k}]$ 与未结合配体的受体浓度 $[R_{S,0}]$ 通过质量作用定律相关联。将 $k$ 个配体结合到 $N$ 个位点的方式数由二项式系数 $\\binom{N}{k}$ 给出。\n$$[R_{S,k}] = \\binom{N}{k} \\left(\\frac{C}{K_{d,S}}\\right)^k [R_{S,0}]$$\n状态 $S$ 下受体的总浓度 $[R_S^{\\text{total}}]$ 是所有配体结合状态（$k=0, \\dots, N$）的总和：\n$$[R_S^{\\text{total}}] = \\sum_{k=0}^{N} [R_{S,k}] = [R_{S,0}] \\sum_{k=0}^{N} \\binom{N}{k} \\left(\\frac{C}{K_{d,S}}\\right)^k = [R_{S,0}] \\left(1 + \\frac{C}{K_{d,S}}\\right)^N$$\n变构常数 $L = [R_{T,0}]/[R_{R,0}]$ 关联了未结合配体状态的浓度。我们可以用 $[R_{R,0}]$ 来表示 T 态和 R 态受体的总浓度：\n$$[R_T^{\\text{total}}] = L [R_{R,0}] \\left(1 + \\frac{C}{K_{d,T}}\\right)^N$$\n$$[R_R^{\\text{total}}] = [R_{R,0}] \\left(1 + \\frac{C}{K_{d,R}}\\right)^N$$\n饱和分数 $\\theta(C)$ 是已结合的配体位点总数除以可用的总位点数。\n$$\\theta(C) = \\frac{\\sum_{k=0}^{N} k [R_{T,k}] + \\sum_{k=0}^{N} k [R_{R,k}]}{N \\left( [R_T^{\\text{total}}] + [R_R^{\\text{total}}] \\right)}$$\n总和 $\\sum_{k=0}^{N} k [R_{S,k}]$ 表示状态 $S$ 下已结合配体位点的总浓度。使用恒等式 $\\sum_{k=0}^{N} k \\binom{N}{k} x^k = Nx(1+x)^{N-1}$，我们发现：\n$$\\sum_{k=0}^{N} k [R_{S,k}] = [R_{S,0}] N \\frac{C}{K_{d,S}} \\left(1 + \\frac{C}{K_{d,S}}\\right)^{N-1}$$\n将这些表达式代入 $\\theta(C)$ 的公式中，并使用 $[R_{T,0}] = L [R_{R,0}]$，分子和分母中的 $[R_{R,0}]N$ 项相互抵消：\n$$ \\theta(C) = \\frac{L \\frac{C}{K_{d,T}} \\left(1+\\frac{C}{K_{d,T}}\\right)^{N-1} + \\frac{C}{K_{d,R}} \\left(1+\\frac{C}{K_{d,R}}\\right)^{N-1}}{L \\left(1+\\frac{C}{K_{d,T}}\\right)^N + \\left(1+\\frac{C}{K_{d,R}}\\right)^N} $$\n这就是饱和分数所需的函数形式。\n\n**2. $C_{0.5}$、$n_H$ 和 $S_0$ 的计算**\n\n**a. 半饱和浓度 ($C_{0.5}$)**\n$C_{0.5}$ 是使得 $\\theta(C_{0.5}) = 0.5$ 时的配体浓度。这导致方程：\n$$ 2 \\left( L \\frac{C_{0.5}}{K_{d,T}} \\left(1+\\frac{C_{0.5}}{K_{d,T}}\\right)^{N-1} + \\frac{C_{0.5}}{K_{d,R}} \\left(1+\\frac{C_{0.5}}{K_{d,R}}\\right)^{N-1} \\right) = L \\left(1+\\frac{C_{0.5}}{K_{d,T}}\\right)^N + \\left(1+\\frac{C_{0.5}}{K_{d,R}}\\right)^N $$\n该方程是关于 $C_{0.5}$ 的高次多项式，通常没有闭合形式的解析解。必须进行数值求解。我们定义函数 $f(C) = \\theta(C) - 0.5$，并使用像 Brent 方法这样的稳健区间法来寻找其根。必须找到一个合适的搜索区间 $[a, b]$，使得 $f(a)f(b)  0$。由于 $\\theta(0)=0$，我们可以将 $a$ 设置为一个小的正数。可以通过从一个较小的值开始并增加它直到 $\\theta(b) > 0.5$ 来找到一个上界 $b$。\n\n**b. Hill 系数 ($n_H$)**\n半饱和时的 Hill 系数定义为：\n$$ n_H = \\left.\\frac{d \\log\\left(\\frac{\\theta}{1 - \\theta}\\right)}{d \\log C}\\right|_{C = C_{0.5}} = \\frac{C}{\\theta(1-\\theta)} \\frac{d\\theta}{dC} \\bigg|_{C = C_{0.5}} $$\n在 $C=C_{0.5}$ 时，$\\theta=0.5$，所以 $\\theta(1-\\theta) = 0.25$。表达式简化为：\n$$ n_H = 4 C_{0.5} \\left.\\frac{d\\theta}{dC}\\right|_{C = C_{0.5}} $$\n为了计算 $n_H$，我们需要 $\\theta(C)$ 的解析导数。令 $\\theta(C) = \\frac{Num(C)}{Den(C)}$。使用商法则，$\\frac{d\\theta}{dC} = \\frac{Num'(C)Den(C) - Num(C)Den'(C)}{Den(C)^2}$。\n在 $C=C_{0.5}$ 时，$Num(C_{0.5}) = 0.5 Den(C_{0.5})$，这简化了导数为：\n$$ \\left.\\frac{d\\theta}{dC}\\right|_{C=C_{0.5}} = \\frac{Num'(C_{0.5}) - 0.5 Den'(C_{0.5})}{Den(C_{0.5})} $$\n令 $A_S(C) = 1 + C/K_{d,S}$，其中 $S \\in \\{T,R\\}$。分子和分母组成函数的导数是：\n$$ Den'(C) = \\frac{d}{dC} \\left[ L A_T^N + A_R^N \\right] = \\frac{LN}{K_{d,T}} A_T^{N-1} + \\frac{N}{K_{d,R}} A_R^{N-1} $$\n$$ Num'(C) = \\frac{d}{dC} \\left[ L \\frac{C}{K_{d,T}} A_T^{N-1} + \\frac{C}{K_{d,R}} A_R^{N-1} \\right] = \\frac{L}{K_{d,T}} A_T^{N-2} \\left(1 + \\frac{NC}{K_{d,T}}\\right) + \\frac{1}{K_{d,R}} A_R^{N-2} \\left(1 + \\frac{NC}{K_{d,R}}\\right) $$\n这些表达式可以在 $C=C_{0.5}$ 处求值以找到 $n_H$。这些通用形式对于 $N \\ge 1$ 均有效。\n\n**c. 初始斜率 ($S_0$)**\n初始斜率 $S_0$ 是导数在 $C \\to 0^+$ 时的极限：\n$$ S_0 = \\lim_{C \\to 0^+} \\frac{d\\theta}{dC} $$\n我们在 $C=0$ 处计算 $\\frac{d\\theta}{dC}$。当 $C \\to 0$ 时，我们有 $A_T \\to 1$，$A_R \\to 1$，$Num(C) \\to 0$，以及 $Den(C) \\to L+1$。导数计算为：\n$$ \\lim_{C\\to 0} Num'(C) = \\frac{L}{K_{d,T}} + \\frac{1}{K_{d,R}} $$\n$$ \\lim_{C\\to 0} Den'(C) = \\frac{LN}{K_{d,T}} + \\frac{N}{K_{d,R}} $$\n代入商法则公式计算 $\\frac{d\\theta}{dC}$：\n$$ S_0 = \\frac{(\\frac{L}{K_{d,T}} + \\frac{1}{K_{d,R}})(L+1) - (0) \\cdot Den'(0)}{(L+1)^2} = \\frac{\\frac{L}{K_{d,T}} + \\frac{1}{K_{d,R}}}{L+1} $$\n该表达式可以直接从输入参数计算。\n\n**算法实现**\n程序将实现函数来计算 $\\theta(C)$，使用数值求根器找到 $C_{0.5}$，并计算 $n_H$ 和 $S_0$ 的解析表达式。对每个指定的测试用例重复此过程。最终的数值结果将被格式化为六位有效数字。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the MWC model problem for a suite of test cases.\n    It computes C_0.5, n_H, and S_0 for each case based on first-principle derivations.\n    \"\"\"\n    \n    test_cases = [\n        # (N, K_d,T, K_d,R, L)\n        (4, 2e-4, 1e-6, 1000),\n        (4, 1e-5, 1e-5, 100),\n        (1, 5e-6, 5e-7, 50),\n        (4, 5e-6, 1e-6, 1e-3),\n        (4, 1e-3, 1e-9, 1e6)\n    ]\n\n    def _calculate_quantities(N, K_d_T, K_d_R, L):\n        \"\"\"\n        Computes the three requested quantities for a single parameter set.\n        \"\"\"\n        \n        # 1. Define the fractional occupancy function theta(C)\n        def theta(C):\n            if C == 0: return 0.0\n            \n            alpha_T = C / K_d_T\n            alpha_R = C / K_d_R\n            \n            # Using np.power for robust exponentiation\n            # Numerator terms\n            term_T_num = L * alpha_T * np.power(1.0 + alpha_T, N - 1)\n            term_R_num = alpha_R * np.power(1.0 + alpha_R, N - 1)\n            \n            # Denominator terms\n            term_T_den = L * np.power(1.0 + alpha_T, N)\n            term_R_den = np.power(1.0 + alpha_R, N)\n            \n            numerator = term_T_num + term_R_num\n            denominator = term_T_den + term_R_den\n            \n            # Avoid division by zero, though unlikely for C > 0\n            if denominator == 0:\n                return 0.0\n            return numerator / denominator\n\n        # 2. Find C_0.5 by solving theta(C) - 0.5 = 0\n        def f_for_root(C):\n            return theta(C) - 0.5\n\n        # Establish a robust search bracket [a, b] for the root finder\n        a, b = 1e-20, 1e-18\n        # Check if the root is smaller than the initial guess for b\n        if f_for_root(b)  0:\n            while f_for_root(b)  0:\n                b *= 10.0\n                if b > 1e12: # Safety break to prevent infinite loops\n                    raise ValueError(\"Failed to find an upper bracket for C_0.5\")\n        \n        # Use Brent's method to find the root C_0.5\n        C_0_5 = brentq(f_for_root, a, b, xtol=1e-24, rtol=1e-15)\n\n        # 3. Calculate the Hill coefficient n_H at C_0.5\n        def calculate_n_H(C):\n            # n_H = 4 * C * (d(theta)/dC) at C_0.5\n            # d(theta)/dC = (Num' - 0.5 * Den') / Den at C_0.5\n            \n            A_T = 1.0 + C / K_d_T\n            A_R = 1.0 + C / K_d_R\n            \n            Den = L * np.power(A_T, N) + np.power(A_R, N)\n            \n            # Derivative of Numerator (Num')\n            Num_prime_T = (L / K_d_T) * np.power(A_T, N - 2) * (1.0 + N * C / K_d_T)\n            Num_prime_R = (1.0 / K_d_R) * np.power(A_R, N - 2) * (1.0 + N * C / K_d_R)\n            Num_prime = Num_prime_T + Num_prime_R\n            \n            # Derivative of Denominator (Den')\n            Den_prime_T = N * L / K_d_T * np.power(A_T, N - 1)\n            Den_prime_R = N / K_d_R * np.power(A_R, N - 1)\n            Den_prime = Den_prime_T + Den_prime_R\n            \n            dtheta_dc_at_C05 = (Num_prime - 0.5 * Den_prime) / Den\n            \n            n_H = 4.0 * C * dtheta_dc_at_C05\n            return n_H\n\n        n_H = calculate_n_H(C_0_5)\n\n        # 4. Calculate the initial slope S_0\n        S_0 = (L / K_d_T + 1.0 / K_d_R) / (L + 1.0)\n        \n        return n_H, C_0_5, S_0\n\n    all_results = []\n    for case in test_cases:\n        N, K_d_T, K_d_R, L = case\n        result_tuple = _calculate_quantities(N, K_d_T, K_d_R, L)\n        all_results.append(result_tuple)\n\n    # Format the final output string according to the spec\n    # Use {:.6g} for floating-point formatting to 6 significant figures.\n    formatted_sublists = [\n        f\"[{res[0]:.6g},{res[1]:.6g},{res[2]:.6g}]\" \n        for res in all_results\n    ]\n    final_output_string = f\"[{','.join(formatted_sublists)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3344587"}, {"introduction": "确定性常微分方程（ODE）模型成功地描述了大量分子群体的平均行为，但在细胞内，许多关键分子的数量可能非常低，导致其动态行为表现出显著的随机性。本练习将引导你从确定性描述跨越到随机性描述，使用化学主方程（CME）来模拟结合事件的概率演化。通过这项实践，你将学会如何计算系统的稳态分布、涨落（方差）以及首次通过时间等重要随机量，这些对于理解细胞信号传导中的噪声和时序控制至关重要。[@problem_id:3344581]", "problem": "考虑一个受体-配体系统，其中有有限数量的受体和配体进行可逆结合。设$n$表示已结合的受体-配体复合物的数量。状态空间为$n \\in \\{0,1,2,\\dots,\\min(N_R,N_L)\\}$，其中$N_R$是受体总数，$N_L$是配体总数。假设在充分混合条件下，遵循质量作用配对，从状态$n$到$n+1$的瞬时结合倾向为$a_+(n) = k_+ \\,(N_R - n)\\,(N_L - n)$，从状态$n$到$n-1$的解离倾向为$a_-(n) = k_- \\, n$，其中$k_+$是单位为$\\mathrm{s}^{-1}$的每对结合速率常数，$k_-$是单位为$\\mathrm{s}^{-1}$的每复合物解离速率常数。设$p_n(t)$表示在时间$t$处于状态$n$的概率。化学主方程（CME）定义了连续时间马尔可夫链生成元$\\mathbf{Q}$，使得正向方程为$\\frac{d}{dt}\\mathbf{p}(t) = \\mathbf{p}(t)\\,\\mathbf{Q}$，其中$\\mathbf{p}(t)$是一个行向量，其元素为$p_n(t)$，$\\mathbf{Q}$具有与生灭过程转移一致的三对角结构。\n\n仅从上述定义以及随机过程平衡与动力学的基本原理出发：\n- 基于生灭链的可逆性和细致平衡，推导$n$上的稳态分布$\\boldsymbol{\\pi}$，确保在离散状态空间上归一化。用此计算已结合复合物的稳态平均数$\\mu = \\sum_n n\\,\\pi_n$和稳态方差$\\sigma^2 = \\sum_n (n - \\mu)^2 \\,\\pi_n$。将$\\mu$和$\\sigma^2$报告为实数。\n- 对于给定的阈值$n^\\*$（$1 \\le n^\\* \\le \\min(N_R,N_L)$），推导并计算从初始状态$n_0$（$0 \\le n_0  n^\\*$）首次到达状态$n^\\*$的平均首达时间$\\tau$（以秒为单位）。通过将$n^\\*$设为吸收态，并求解生成元在暂态上的相应线性系统来模拟首达事件。\n- 对于给定的评估时间$t$（以秒为单位），计算当系统在时间$0$从$n_0$初始化时，在时间$t$处于状态$n=0$（所有受体均未结合）的瞬时概率$p_0(t)$。使用$\\mathbf{Q}$的矩阵指数来随时间演化分布。\n\n物理单位：\n- 所有速率常数$k_+$和$k_-$必须以$\\mathrm{s}^{-1}$为单位。\n- 所有时间（$t$和$\\tau$）必须以秒为单位表示，为实数。\n\n您的程序必须精确实现这些计算，并为以下测试套件生成数值结果。每个测试用例指定$(N_R,N_L,k_+,k_-,n^\\*,n_0,t)$：\n\n- 测试用例A（一般情景）：$N_R=20$, $N_L=15$, $k_+=10^{-3}\\ \\mathrm{s}^{-1}$, $k_-=10^{-2}\\ \\mathrm{s}^{-1}$, $n^\\*=10$, $n_0=0$, $t=500\\ \\mathrm{s}$。\n- 测试用例B（小数目边界）：$N_R=1$, $N_L=1$, $k_+=5\\times 10^{-1}\\ \\mathrm{s}^{-1}$, $k_-=10^{-1}\\ \\mathrm{s}^{-1}$, $n^\\*=1$, $n_0=0$, $t=5\\ \\mathrm{s}$。\n- 测试用例C（高亲和力体系）：$N_R=30$, $N_L=30$, $k_+=5\\times 10^{-2}\\ \\mathrm{s}^{-1}$, $k_-=10^{-3}\\ \\mathrm{s}^{-1}$, $n^\\*=25$, $n_0=0$, $t=20\\ \\mathrms$。\n- 测试用例D（配体限制边界）：$N_R=50$, $N_L=5$, $k_+=2\\times 10^{-3}\\ \\mathrm{s}^{-1}$, $k_-=5\\times 10^{-3}\\ \\mathrm{s}^{-1}$, $n^\\*=5$, $n_0=0$, $t=50\\ \\mathrm{s}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例一个子列表，顺序为A、B、C、D。每个子列表必须包含四个实数，顺序为$[\\mu,\\sigma^2,\\tau,p_0(t)]$，其中$\\mu$是稳态平均占据数，$\\sigma^2$是稳态方差，$\\tau$是到达$n^\\*$的平均首达时间（秒），$p_0(t)$是在时间$t$未结合的概率。要求的确切格式是\n\"[[\\mu_A,\\sigma^2_A,\\tau_A,p_{0,A}(t)],[\\mu_B,\\sigma^2_B,\\tau_B,p_{0,B}(t)],[\\mu_C,\\sigma^2_C,\\tau_C,p_{0,C}(t)],[\\mu_D,\\sigma^2_D,\\tau_D,p_{0,D}(t)]]\"\n方括号内不含任何空白字符。", "solution": "用户提供了一个关于受体-配体结合随机动力学的计算系统生物学问题。我将首先验证问题陈述，然后提供完整的推导和计算解决方案。\n\n### 问题验证\n\n**第1步：提取已知信息**\n- **系统**：$N_R$个受体与$N_L$个配体之间的可逆结合。\n- **状态空间**：结合复合物的数量$n$，范围从$0$到$N_{max} = \\min(N_R, N_L)$。\n- **结合倾向**：从状态$n$到$n+1$的转移速率为$a_+(n) = k_+ (N_R - n)(N_L - n)$。\n- **解离倾向**：从状态$n$到$n-1$的转移速率为$a_-(n) = k_- n$。\n- **速率常数**：$k_+$（单位$\\mathrm{s}^{-1}$）和$k_-$（单位$\\mathrm{s}^{-1}$）。\n- **演化方程**：$\\frac{d}{dt}\\mathbf{p}(t) = \\mathbf{p}(t)\\mathbf{Q}$，其中$\\mathbf{p}(t)$是状态概率的行向量。\n- **任务1**：计算$n$的稳态均值$\\mu$和方差$\\sigma^2$。\n- **任务2**：计算从$n_0$开始，首次到达状态$n^\\*$的平均首达时间（MFPT）$\\tau$，其中$1 \\le n^\\* \\le N_{max}$且$0 \\le n_0  n^\\*$。\n- **任务3**：计算从$t=0$时状态为$n_0$开始，在时间$t$系统处于状态$n=0$的瞬时概率$p_0(t)$。\n- **测试用例**：\n    - A: $(N_R=20, N_L=15, k_+=10^{-3}, k_-=10^{-2}, n^\\*=10, n_0=0, t=500)$\n    - B: $(N_R=1, N_L=1, k_+=0.5, k_-=0.1, n^\\*=1, n_0=0, t=5)$\n    - C: $(N_R=30, N_L=30, k_+=0.05, k_-=0.001, n^\\*=25, n_0=0, t=20)$\n    - D: $(N_R=50, N_L=5, k_+=0.002, k_-=0.005, n^\\*=5, n_0=0, t=50)$\n\n**第2步：使用提取的已知信息进行验证**\n- **科学基础**：该问题描述了一个经典的生灭过程模型，用于随机化学动力学，这是系统生物学的基石。对于一个充分混合且分子数量有限的系统，质量作用倾向是标准且物理上合理的。\n- **适定性**：每个任务都是有限状态空间连续时间马尔可夫链理论中的标准、明确定义的问题。存在唯一的稳态分布。到达吸收态的平均首达时间是唯一确定的。概率分布的瞬时演化由一个明确定义的线性常微分方程控制。\n- **客观性**：问题使用精确的数学和科学语言陈述，没有任何主观性。\n- **一致性和完整性**：为每个测试用例提供了所有必需的参数。参数的约束条件（例如，$0 \\le n_0  n^\\*$）是一致的。状态空间的边界由倾向函数的定义正确处理（例如，$a_+(N_{max}) = 0$, $a_-(0) = 0$）。\n\n**第3步：结论与行动**\n此问题是**有效的**。它是一个适定的、有科学依据且计算上可解的问题。我将继续进行详细的解决方案。\n\n### 推导与方法论\n\n该系统是一个在状态空间$S = \\{0, 1, \\dots, N_{max}\\}$上的一维生灭过程，其中$N_{max} = \\min(N_R, N_L)$。生（从$n \\to n+1$）速率为$\\lambda_n = a_+(n) = k_+(N_R - n)(N_L - n)$，适用于$n \\in \\{0, \\dots, N_{max}-1\\}$；灭（从$n \\to n-1$）速率为$\\mu_n = a_-(n) = k_- n$，适用于$n \\in \\{1, \\dots, N_{max}\\}$。\n\n**1. 稳态分布、均值和方差**\n在平衡状态下，系统满足细致平衡条件：\n$$ \\pi_n \\lambda_n = \\pi_{n+1} \\mu_{n+1} $$\n其中$\\pi_n$是处于状态$n$的稳态概率。这为概率提供了一个递推关系：\n$$ \\pi_{n+1} = \\pi_n \\frac{\\lambda_n}{\\mu_{n+1}} = \\pi_n \\frac{k_+(N_R - n)(N_L - n)}{k_-(n+1)} $$\n我们可以用$\\pi_0$表示每个$\\pi_n$：\n$$ \\pi_n = \\pi_0 \\prod_{i=0}^{n-1} \\frac{\\lambda_i}{\\mu_{i+1}} $$\n为避免计算中出现上溢或下溢，我们首先计算未归一化的对数概率：$\\log \\tilde{\\pi}_0 = 0$，以及$\\log \\tilde{\\pi}_{n+1} = \\log \\tilde{\\pi}_n + \\log(\\lambda_n) - \\log(\\mu_{n+1})$。然后，为保持稳定性，使用log-sum-exp技巧将其转换回线性尺度，最后通过总和$\\sum_n \\pi_n = 1$进行归一化，以找到正确缩放的$\\pi_n$值。\n稳态均值$\\mu$和方差$\\sigma^2$随后根据其定义计算得出：\n$$ \\mu = \\sum_{n=0}^{N_{max}} n \\pi_n \\quad , \\quad \\sigma^2 = \\sum_{n=0}^{N_{max}} (n-\\mu)^2 \\pi_n = \\left(\\sum_{n=0}^{N_{max}} n^2 \\pi_n\\right) - \\mu^2 $$\n\n**2. 平均首达时间（MFPT）**\n要计算从$n_0  n^\\*$开始到达吸收态$n^\\*$的MFPT $\\tau$，我们考虑暂态集合$S_T = \\{0, 1, \\dots, n^\\*-1\\}$。设$\\tau_i$为从状态$i \\in S_T$到达$n^\\*$的MFPT。$\\tau_i$值满足一个线性方程组。通过考虑离开状态$i$的第一步，我们将$\\tau_i$与相邻状态的MFPT联系起来：\n$$ \\tau_i = \\frac{1}{\\lambda_i + \\mu_i} + \\frac{\\lambda_i}{\\lambda_i + \\mu_i}\\tau_{i+1} + \\frac{\\mu_i}{\\lambda_i + \\mu_i}\\tau_{i-1} $$\n整理后得到：\n$$ \\mu_i \\tau_{i-1} - (\\lambda_i + \\mu_i) \\tau_i + \\lambda_i \\tau_{i+1} = -1 $$\n此式对$i \\in S_T$成立，边界条件为$\\tau_{n^\\*} = 0$（从目标到达目标的时间为零）和$\\mu_0 = 0$。这个包含$n^\\*$个线性方程的系统可以写成矩阵形式$\\mathbf{A}\\boldsymbol{\\tau} = \\mathbf{b}$，其中$\\boldsymbol{\\tau} = [\\tau_0, \\dots, \\tau_{n^\\*-1}]^T$，$\\mathbf{b} = [-1, \\dots, -1]^T$，而$\\mathbf{A}$是暂态的$n^\\* \\times n^\\*$生成元子矩阵。我们求解这个系统得到$\\boldsymbol{\\tau}$，并提取$\\tau_{n_0}$。\n\n**3. 瞬时概率**\n概率向量$\\mathbf{p}(t)$的演化由$\\frac{d}{dt}\\mathbf{p}(t) = \\mathbf{p}(t)\\mathbf{Q}$给出，其中$\\mathbf{p}(t)$是一个行向量。解为$\\mathbf{p}(t) = \\mathbf{p}(0) e^{\\mathbf{Q}t}$，其中$\\mathbf{p}(0)$是初始概率分布，$e^{\\mathbf{Q}t}$是$\\mathbf{Q}t$的矩阵指数。对于全状态空间$S = \\{0, \\dots, N_{max}\\}$，生成元矩阵$\\mathbf{Q}$是一个$(N_{max}+1) \\times (N_{max}+1)$的三对角矩阵，其元素由转移速率定义：\n$$ Q_{i,j} = \\begin{cases} \\lambda_i  \\text{若 } j = i+1 \\\\ \\mu_i  \\text{若 } j = i-1 \\\\ -(\\lambda_i + \\mu_i)  \\text{若 } j = i \\\\ 0  \\text{其他情况} \\end{cases} $$\n其中$\\lambda_{N_{max}} = 0$且$\\mu_0 = 0$。\n初始状态为$n_0$，所以$\\mathbf{p}(0)$是一个在索引$n_0$处为1，其他位置为0的向量。在时间$t$处于状态$j$的概率为$p_j(t) = (\\mathbf{p}(0)e^{\\mathbf{Q}t})_j = (e^{\\mathbf{Q}t})_{n_0, j}$。我们需要计算$p_0(t)$，它对应于矩阵指数$(e^{\\mathbf{Q}t})$的第$(n_0, 0)$个元素。对于给定的测试用例，$n_0=0$，所以我们需要$\\mathbf{Q}t$的矩阵指数的$(0,0)$元素。这将使用`scipy.linalg.expm`进行数值计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, solve\n\ndef solve_problem():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Test cases as specified in the problem statement.\n    # Each tuple: (NR, NL, k+, k-, n*, n0, t)\n    test_cases = [\n        (20, 15, 1e-3, 1e-2, 10, 0, 500),  # Test Case A\n        (1, 1, 0.5, 0.1, 1, 0, 5),          # Test Case B\n        (30, 30, 5e-2, 1e-3, 25, 0, 20),    # Test Case C\n        (50, 5, 2e-3, 5e-3, 5, 0, 50),      # Test Case D\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = compute_metrics(*case)\n        all_results.append(result)\n\n    # Format the final output string exactly as required.\n    result_strings = []\n    for res in all_results:\n        result_strings.append(f\"[{','.join(map(str, res))}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\ndef compute_metrics(NR, NL, k_plus, k_minus, n_star, n0, t):\n    \"\"\"\n    Computes the four required metrics (stationary mean, stationary variance,\n    mean first-passage time, and a transient probability) for a single test case.\n    \"\"\"\n    N_max = min(NR, NL)\n\n    # --- Part 1: Stationary Mean and Variance ---\n    # We use logarithms to prevent numerical over/underflow when calculating\n    # the unnormalized stationary probabilities.\n    log_unnormalized_pi = np.zeros(N_max + 1, dtype=np.float64)\n    for n in range(N_max):\n        lambda_n = k_plus * (NR - n) * (NL - n)\n        mu_n_plus_1 = k_minus * (n + 1)\n        if lambda_n == 0:\n            log_unnormalized_pi[n+1:] = -np.inf\n            break\n        log_unnormalized_pi[n+1] = log_unnormalized_pi[n] + np.log(lambda_n) - np.log(mu_n_plus_1)\n\n    # Normalize using the log-sum-exp trick for stability\n    log_max = np.max(log_unnormalized_pi)\n    unnormalized_pi = np.exp(log_unnormalized_pi - log_max)\n    pi = unnormalized_pi / np.sum(unnormalized_pi)\n\n    n_values = np.arange(N_max + 1, dtype=np.float64)\n    mu_stationary = np.sum(n_values * pi)\n    sigma2_stationary = np.sum((n_values - mu_stationary)**2 * pi)\n\n    # --- Part 2: Mean First-Passage Time (MFPT) ---\n    # Solve the system A * tau = -1, where A is the generator submatrix\n    # for the transient states {0, 1, ..., n_star-1}.\n    size_mfpt = n_star\n    \n    lambda_vals = k_plus * (NR - np.arange(size_mfpt, dtype=np.float64)) * (NL - np.arange(size_mfpt, dtype=np.float64))\n    mu_vals = k_minus * np.arange(size_mfpt, dtype=np.float64)\n\n    diag0 = -(lambda_vals + mu_vals)\n    diagp1 = lambda_vals[:-1] if size_mfpt > 1 else np.array([])\n    diagm1 = mu_vals[1:] if size_mfpt > 1 else np.array([])\n\n    A_mfpt = np.diag(diag0) + np.diag(diagp1, k=1) + np.diag(diagm1, k=-1)\n    \n    b_mfpt = -np.ones(size_mfpt, dtype=np.float64)\n    tau_vec = solve(A_mfpt, b_mfpt)\n    tau_mfpt = tau_vec[n0]\n\n    # --- Part 3: Transient Probability ---\n    # Compute p(t) = p(0) * expm(Q*t), where Q is the full generator matrix.\n    size_q = N_max + 1\n    \n    lambda_vals_q = k_plus * (NR - np.arange(size_q, dtype=np.float64)) * (NL - np.arange(size_q, dtype=np.float64))\n    lambda_vals_q[N_max] = 0.0 # Explicitly set rate out of max state to 0\n    mu_vals_q = k_minus * np.arange(size_q, dtype=np.float64)\n\n    diag0_q = -(lambda_vals_q + mu_vals_q)\n    diagp1_q = lambda_vals_q[:-1] if size_q > 1 else np.array([])\n    diagm1_q = mu_vals_q[1:] if size_q > 1 else np.array([])\n\n    Q = np.diag(diag0_q) + np.diag(diagp1_q, k=1) + np.diag(diagm1_q, k=-1)\n    \n    # Propagator matrix P(t) = expm(Q*t)\n    P_t = expm(Q * t)\n    \n    # We need p_0(t) given initial state n0, which is P_t[n0, 0].\n    p0_t = P_t[n0, 0]\n\n    return [mu_stationary, sigma2_stationary, tau_mfpt, p0_t]\n\nif __name__ == '__main__':\n    solve_problem()\n```", "id": "3344581"}]}