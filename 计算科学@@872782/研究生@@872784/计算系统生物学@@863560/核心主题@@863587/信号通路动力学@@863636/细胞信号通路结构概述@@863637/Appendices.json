{"hands_on_practices": [{"introduction": "细胞信号通路中的前馈环 (Feedforward Loops, FFLs) 是用于塑造动态响应的基本结构单元。特别是，非相干前馈环 (Incoherent FFL) 是产生瞬时脉冲信号的关键基序，这对于细胞适应和精确的时间控制至关重要。本练习将通过求解线性化模型的常微分方程，让您亲手验证电路的“布线图”如何直接决定其功能输出，并量化适应 (adaptation) 和脉冲式 (pulse-like) 响应的行为 [@problem_id:3336287]。", "problem": "考虑在细胞中常见的两种经典三节点信号通路结构：一致性1型前馈环 (C1-FFL) 和非一致性1型前馈环 (I1-FFL)。设上游输入为一个阶跃函数 $u(t)$，在时间 $t=0$ 时从 $0$ 切换到一个正常数 $U$。假设系统在某个工作点附近处于线性化的小信号状态，其中产物的生成速率与调控因子的浓度呈线性关系，且所有物质均以一级动力学方式降解。具体来说，设 $x(t)$ 和 $z(t)$ 是由 $u(t)$ 直接驱动的中间调控因子，而 $y(t)$ 是输出。其动力学由一阶常微分方程 (ODE) 描述，其生物学和数学基础如下：\n\n- 一阶分子周转：$x(t)$、$y(t)$ 和 $z(t)$ 的降解速率与其各自浓度成正比，速率常数分别为正常数 $a_x$、$a_y$ 和 $a_z$。\n- 工作点附近的线性化生成：对于小偏差，生成项与上游调控因子的浓度呈线性关系，其中 $u(t)$ 对 $x(t)$ 和 $z(t)$ 影响的增益为 $b_x$ 和 $b_z$，$x(t)$ 和 $z(t)$ 对 $y(t)$ 影响的增益为 $k_x$ 和 $k_z$。\n- C1-FFL 的两条路径都激活 $y(t)$，而 I1-FFL 的一条路径激活 $y(t)$，另一条则抑制它。令 $s \\in \\{+1,-1\\}$ 来编码一致性：C1-FFL 为 $s=+1$，I1-FFL 为 $s=-1$。\n\n在这些假设下，常微分方程组为\n$$\n\\frac{dx}{dt} = -a_x x + b_x u(t), \\quad \\frac{dz}{dt} = -a_z z + b_z u(t), \\quad \\frac{dy}{dt} = -a_y y + k_x x + s\\,k_z z,\n$$\n初始条件为 $x(0)=0$、$z(0)=0$、$y(0)=0$，并且对于所有 $t\\ge 0$ 有阶跃输入 $u(t)=U$，对于所有 $t<0$ 有 $u(t)=0$。所有参数 $a_x$、$a_y$、$a_z$、$b_x$、$b_z$、$k_x$、$k_z$、$U$ 均为严格正实数。\n\n你的任务：\n\n1. 从上述 ODE 出发，仅使用线性系统原理（叠加原理、积分因子法和一阶系统的阶跃响应），推导出在 $t\\ge 0$ 时 $y(t)$ 关于参数 $a_x$、$a_y$、$a_z$、$b_x$、$b_z$、$k_x$、$k_z$、$U$ 和 $s$ 的闭式表达式。你的推导必须从一阶系统的阶跃响应定义和一阶线性 ODE 的积分因子法开始。\n2. 使用你得到的 $y(t)$ 表达式，为阶跃输入后的适应性和脉冲状行为定义一个定量检验方法：\n   - 定义稳态值 $y_\\infty = \\lim_{t\\to\\infty} y(t)$，并定义一个绝对容差 $\\varepsilon$ 来判断适应性。如果 $|y_\\infty - y(0)| \\le \\varepsilon$，则称系统表现出适应性，注意 $y(0)=0$。使用 $\\varepsilon = 10^{-8}$。\n   - 定义峰值 $y_{\\max} = \\max_{t\\ge 0} y(t)$。如下定义脉冲状响应。如果系统具有适应性，当 $y_{\\max} \\ge A_{\\min}$ (其中 $A_{\\min} = 10^{-4}$) 时，判定为脉冲状。如果系统不具有适应性，当 $y_{\\max} / \\max\\{ |y_\\infty|, \\delta \\} \\ge R$ (其中 $R = 1.2$，$ \\delta = 10^{-12}$ 用于避免除以零) 时，判定为脉冲状。该定义捕捉了两种情况：一种是返回基线的瞬态响应（具有脉冲的适应性），另一种是相对于非零稳态的显著超调。\n3. 实现一个程序，对于下面的每一组参数，在时间范围 $t \\in [0,T]$（其中 $T=50$）上计算 $y(t)$，并使用上述定义确定两个布尔值：响应是否具有适应性以及是否呈脉冲状。使用足够精细的时间离散化来精确捕捉瞬态过程。\n4. 你的程序必须处理以下参数集的测试套件。对于每种情况，所有量都是无量纲的。对于每个参数元组，按顺序报告两个布尔值：首先是适应性布尔值，然后是脉冲状布尔值。\n   - 情况 1 (具有完美适应性的 I1-FFL): $s=-1$, $a_x=1.0$, $a_y=0.5$, $a_z=0.2$, $b_x=1.0$, $b_z=1.0$, $k_x=1.0$, $k_z=0.2$, $U=1.0$。\n   - 情况 2 (C1-FFL, 无适应性): $s=+1$, $a_x=1.0$, $a_y=0.5$, $a_z=0.2$, $b_x=1.0$, $b_z=1.0$, $k_x=1.0$, $k_z=0.2$, $U=1.0$。\n   - 情况 3 (具有部分适应性和超调的 I1-FFL): $s=-1$, $a_x=1.0$, $a_y=0.5$, $a_z=0.2$, $b_x=1.0$, $b_z=1.0$, $k_x=1.0$, $k_z=0.1$, $U=1.0$。\n   - 情况 4 (具有不同时间尺度的 C1-FFL): $s=+1$, $a_x=0.1$, $a_y=0.5$, $a_z=2.0$, $b_x=1.0$, $b_z=1.0$, $k_x=1.0$, $k_z=1.0$, $U=1.0$。\n   - 情况 5 (I1-FFL，时间尺度接近，增益略有失配): $s=-1$, $a_x=0.5$, $a_y=0.3$, $a_z=0.51$, $b_x=1.0$, $b_z=1.0$, $k_x=1.0$, $k_z=0.95$, $U=1.0$。\n5. 最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须是按顺序将每种情况的两个布尔值串联起来的结果，形成一个长度为 $10$ 的扁平列表。例如，输出形式为 $[b_1,b_2,\\dots,b_{10}]$，其中每个 $b_i$ 为 $True$ 或 $False$。\n\n你的程序必须是自包含的，不得读取任何输入，并且只能使用标准库以及（如果需要）指定的数值库。输出必须严格遵守指定格式且只有一行。不涉及任何物理单位；所有量都是无量纲的。不出现角度。任何地方都不得使用百分比；如果需要，只能考虑使用十进制形式的实数分数。", "solution": "该问题已经过验证，并被确定为有效。它在科学上基于应用于生化网络基序的线性系统理论原理，在数学上是适定的，提供了所有必要信息，并且陈述客观。我们开始进行解答。\n\n任务是推导两种类型的前馈环 (FFL) 对阶跃输入的瞬态响应 $y(t)$，然后根据适应性和脉冲状行为的标准对响应进行分类。\n\n**1. $y(t)$ 闭式解的推导**\n\n该系统由一组具有常系数的线性常微分方程 (ODE) 描述。对于 $t \\ge 0$，输入为常数 $u(t)=U$。\n\n**步骤 1.1：求解中间调控因子 $x(t)$ 和 $z(t)$**\n\n$x(t)$ 和 $z(t)$ 的动力学与系统其余部分以及彼此之间是解耦的。它们遵循相同的一般一阶线性 ODE 形式：\n$$\n\\frac{dw}{dt} = -a w + b U, \\quad w(0) = 0\n$$\n其中 $(w, a, b)$ 对应于 $(x, a_x, b_x)$ 或 $(z, a_z, b_z)$。我们使用积分因子法来求解。积分因子为 $e^{\\int a dt} = e^{at}$。将整理后的 ODE $\\frac{dw}{dt} + aw = bU$ 乘以积分因子得到：\n$$\ne^{at} \\frac{dw}{dt} + a e^{at} w = b U e^{at}\n$$\n左边是一个乘积的导数：\n$$\n\\frac{d}{dt}(w(t) e^{at}) = b U e^{at}\n$$\n对两边从 $\\tau=0$ 到 $\\tau=t$ 进行积分，并应用初始条件 $w(0)=0$：\n$$\n\\int_0^t \\frac{d}{d\\tau}(w(\\tau) e^{a\\tau}) d\\tau = \\int_0^t b U e^{a\\tau} d\\tau\n$$\n$$\n[w(\\tau) e^{a\\tau}]_0^t = b U \\left[ \\frac{1}{a} e^{a\\tau} \\right]_0^t\n$$\n$$\nw(t)e^{at} - w(0)e^0 = \\frac{bU}{a} (e^{at} - e^0)\n$$\n$$\nw(t)e^{at} = \\frac{bU}{a} (e^{at} - 1)\n$$\n求解 $w(t)$ 得到一阶系统的阶跃响应：\n$$\nw(t) = \\frac{bU}{a}(1 - e^{-at})\n$$\n将此通解应用于 $x(t)$ 和 $z(t)$：\n$$\nx(t) = \\frac{b_x U}{a_x}(1 - e^{-a_x t})\n$$\n$$\nz(t) = \\frac{b_z U}{a_z}(1 - e^{-a_z t})\n$$\n\n**步骤 1.2：求解输出 $y(t)$**\n\n$y(t)$ 的 ODE 为：\n$$\n\\frac{dy}{dt} = -a_y y + k_x x(t) + s k_z z(t), \\quad y(0)=0\n$$\n代入 $x(t)$ 和 $z(t)$ 的表达式：\n$$\n\\frac{dy}{dt} + a_y y = k_x \\left[\\frac{b_x U}{a_x}(1 - e^{-a_x t})\\right] + s k_z \\left[\\frac{b_z U}{a_z}(1 - e^{-a_z t})\\right]\n$$\n设强迫函数为 $f(t)$。我们可以对各项进行分组：\n$$\nf(t) = \\underbrace{U \\left(\\frac{k_x b_x}{a_x} + s\\frac{k_z b_z}{a_z}\\right)}_{K_0} \\underbrace{- U\\frac{k_x b_x}{a_x}}_{K_x} e^{-a_x t} \\underbrace{- s U\\frac{k_z b_z}{a_z}}_{K_z} e^{-a_z t}\n$$\n方程为 $\\frac{dy}{dt} + a_y y = K_0 + K_x e^{-a_x t} + K_z e^{-a_z t}$。通解是齐次解 $y_h(t) = A e^{-a_y t}$ 和一个特解 $y_p(t)$ 的和。根据叠加原理，我们可以为 $f(t)$ 中的每一项找到特解。假设衰减率 $a_x, a_y, a_z$ 是互不相同的（在所有给定的测试用例中都是如此），我们使用待定系数法：\n- 对于常数项 $K_0$，特解为 $y_{p,0} = K_0/a_y$。\n- 对于项 $K_x e^{-a_x t}$，特解为 $y_{p,x} = \\frac{K_x}{a_y - a_x} e^{-a_x t}$。\n- 对于项 $K_z e^{-a_z t}$，特解为 $y_{p,z} = \\frac{K_z}{a_y - a_z} e^{-a_z t}$。\n\n完整的特解为 $y_p(t) = \\frac{K_0}{a_y} + \\frac{K_x}{a_y - a_x} e^{-a_x t} + \\frac{K_z}{a_y - a_z} e^{-a_z t}$。\n通解为：\n$$\ny(t) = A e^{-a_y t} + \\frac{K_0}{a_y} + \\frac{K_x}{a_y - a_x} e^{-a_x t} + \\frac{K_z}{a_y - a_z} e^{-a_z t}\n$$\n使用初始条件 $y(0)=0$：\n$$\n0 = A + \\frac{K_0}{a_y} + \\frac{K_x}{a_y - a_x} + \\frac{K_z}{a_y - a_z} \\implies A = -\\left(\\frac{K_0}{a_y} + \\frac{K_x}{a_y - a_x} + \\frac{K_z}{a_y - a_z}\\right)\n$$\n将 $A$ 代回并重新整理各项：\n$$\ny(t) = \\frac{K_0}{a_y}(1 - e^{-a_y t}) + \\frac{K_x}{a_y - a_x}(e^{-a_x t} - e^{-a_y t}) + \\frac{K_z}{a_y - a_z}(e^{-a_z t} - e^{-a_y t})\n$$\n最后，代回 $K_0$、$K_x$ 和 $K_z$ 的表达式：\n$$\ny(t) = \\frac{U}{a_y}\\left(\\frac{k_x b_x}{a_x} + s\\frac{k_z b_z}{a_z}\\right)(1-e^{-a_y t}) - \\frac{U k_x b_x}{a_x(a_y-a_x)}(e^{-a_x t} - e^{-a_y t}) - \\frac{s U k_z b_z}{a_z(a_y-a_z)}(e^{-a_z t} - e^{-a_y t})\n$$\n这就是在衰减率互不相同的假设下，$y(t)$ 的闭式表达式。\n\n**2. 系统行为的定量检验**\n\n**步骤 2.1：稳态和适应性**\n稳态值 $y_\\infty$ 是通过取 $y(t)$ 在 $t \\to \\infty$ 时的极限得到的。由于所有速率常数 $a_i$ 均为正数，所有指数项 $e^{-a_i t}$ 都趋近于 $0$。\n$$\ny_\\infty = \\lim_{t\\to\\infty} y(t) = \\frac{U}{a_y}\\left(\\frac{k_x b_x}{a_x} + s\\frac{k_z b_z}{a_z}\\right) = U\\left(\\frac{k_x b_x}{a_x a_y} + s\\frac{k_z b_z}{a_z a_y}\\right)\n$$\n如果 $|y_\\infty - y(0)| \\le \\varepsilon$，系统就表现出适应性。由于 $y(0)=0$，这简化为 $|y_\\infty| \\le \\varepsilon$，其中 $\\varepsilon = 10^{-8}$。对于 I1-FFL ($s=-1$)，如果 $\\frac{k_x b_x}{a_x} = \\frac{k_z b_z}{a_z}$，则发生完美适应 ($y_\\infty=0$)。\n\n**步骤 2.2：峰值和脉冲状响应**\n峰值为 $y_{\\max} = \\max_{t\\ge 0} y(t)$。求峰值时间 $t_{\\text{peak}}$ 需要求解 $\\frac{dy}{dt}=0$，这会得到一个通常无法解析求解的超越方程。因此，必须通过在足够密集的时间网格上计算 $y(t)$ 来数值确定 $y_{\\max}$。\n\n根据以下条件，响应被定义为脉冲状：\n- 如果系统具有适应性（$|y_\\infty| \\le \\varepsilon$），当 $y_{\\max} \\ge A_{\\min}$ (其中 $A_{\\min} = 10^{-4}$) 时，它被视为脉冲状。\n- 如果系统不具有适应性，当它表现出显著超调时，即 $y_{\\max} / \\max\\{|y_\\infty|, \\delta\\} \\ge R$ (其中 $R=1.2$，$ \\delta=10^{-12}$ 用于防止除以零) 时，它被视为脉冲状。\n\n**3. 实现策略**\n\n程序将实现推导出的 $y(t)$ 解析解。对于每组参数：\n1.  使用其解析公式计算 $y_\\infty$ 以检验适应性。\n2.  生成一个从 $t=0$ 到 $t=T=50$ 的离散时间向量，步长要小，以精确捕捉瞬态。\n3.  使用推导的闭式解计算向量 $y(t)$。\n4.  通过取计算出的 $y(t)$ 向量的最大值来找到 $y_{\\max}$。\n5.  应用由两部分组成的逻辑测试来确定响应是否为脉冲状。\n6.  存储每种情况得到的两个布尔值（适应性、脉冲状），并按规定格式化最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the response of FFL circuits and classifies their behavior.\n    \"\"\"\n    # Define constants from the problem statement\n    EPSILON = 1e-8\n    A_MIN = 1e-4\n    R = 1.2\n    DELTA = 1e-12\n    T_FINAL = 50.0\n    N_POINTS = 10001  # Use a fine grid to accurately find the peak\n\n    # Define the test cases as a list of tuples.\n    # Each tuple: (s, ax, ay, az, bx, bz, kx, kz, U)\n    test_cases = [\n        # Case 1 (I1-FFL with perfect adaptation)\n        (-1, 1.0, 0.5, 0.2, 1.0, 1.0, 1.0, 0.2, 1.0),\n        # Case 2 (C1-FFL, no adaptation)\n        (1, 1.0, 0.5, 0.2, 1.0, 1.0, 1.0, 0.2, 1.0),\n        # Case 3 (I1-FFL with partial adaptation and overshoot)\n        (-1, 1.0, 0.5, 0.2, 1.0, 1.0, 1.0, 0.1, 1.0),\n        # Case 4 (C1-FFL with disparate timescales)\n        (1, 0.1, 0.5, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0),\n        # Case 5 (I1-FFL near-timescale match, slight mismatch in gains)\n        (-1, 0.5, 0.3, 0.51, 1.0, 1.0, 1.0, 0.95, 1.0),\n    ]\n\n    results = []\n\n    # Time vector for evaluating the transient response\n    t = np.linspace(0, T_FINAL, N_POINTS)\n\n    for case in test_cases:\n        s, ax, ay, az, bx, bz, kx, kz, U = case\n        \n        # --- Task 2: Quantitative Tests ---\n        \n        # Calculate steady-state value y_inf\n        x_inf = bx * U / ax\n        z_inf = bz * U / az\n        y_inf = (kx * x_inf + s * kz * z_inf) / ay\n\n        # Perform adaptation test\n        adapts = abs(y_inf) = EPSILON\n\n        # --- Task 1: Closed-form solution for y(t) ---\n        # The analytical solution for y(t) assuming distinct decay rates.\n        # This holds for all given test cases.\n\n        # Term related to the constant part of the forcing function\n        term1_const = (U / ay) * ((kx * bx / ax) + s * (kz * bz / az))\n        term1 = term1_const * (1 - np.exp(-ay * t))\n        \n        # Term related to the exponential from x(t)'s dynamics\n        term2_const = U * kx * bx / (ax * (ay - ax))\n        term2 = term2_const * (np.exp(-ax * t) - np.exp(-ay * t))\n        \n        # Term related to the exponential from z(t)'s dynamics\n        term3_const = s * U * kz * bz / (az * (ay - az))\n        term3 = term3_const * (np.exp(-az * t) - np.exp(-ay * t))\n        \n        y_t = term1 - term2 - term3\n        \n        # Find the peak value y_max\n        # Per problem, y_max is the algebraic maximum of y(t) for t>=0.\n        y_max = np.max(y_t)\n        \n        # Perform pulse-like test\n        is_pulse_like = False\n        if adapts:\n            if y_max >= A_MIN:\n                is_pulse_like = True\n        else:  # Does not adapt\n            denominator = max(abs(y_inf), DELTA)\n            if y_max / denominator >= R:\n                is_pulse_like = True\n                \n        results.append(adapts)\n        results.append(is_pulse_like)\n\n    # Final print statement in the exact required format\n    # The map(str,...) converts Python's True/False to \"True\"/\"False\" string literals.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3336287"}, {"introduction": "许多细胞决策，如分化或凋亡，都表现为“全或无”的开关特性，这需要一个能够存储状态的分子开关。本练习将探讨一种经典的开关构建模块：结合了正反馈和饱和动力学的系统，它能够产生双稳态 (bistability)，即这种开关行为的数学基础。通过进行分岔分析 (bifurcation analysis) [@problem_id:3336283]，您将学习如何精确地识别出系统出现这种关键开关行为所需的参数区间。", "problem": "您的任务是为一个具有饱和去磷酸化作用的自激活激酶建立一个最小化的、有原理依据的模型，然后执行分岔分析以定位参数空间中的鞍结分岔点。该场景必须纯粹用基于已建立的生物物理动力学原理的数学术语来描述。您将从基本的生物化学动力学原理出发，推导出一个描述活性激酶浓度的一维常微分方程（ODE），并利用它通过求解定义的数学条件来检测鞍结分岔。最终交付成果是一个完整的、可运行的程序。\n\n使用的基本原理：\n- 质量作用动力学：当活性激酶催化非活性激酶转化为其活性形式时，速率与反应物浓度的乘积成正比。如果总激酶池是守恒的，则可以使用可用的非活性部分来模拟激活过程。\n- 酶催化去磷酸化的米氏动力学：一个依赖于活性激酶浓度的饱和去磷酸化速率。\n\n建模设置：\n- 令 $x$ 表示活性激酶的浓度，令 $T$ 表示守恒的总激酶浓度，因此非活性激酶池为 $T - x$。\n- 激活过程包括基础激活和自激活两个部分。基础激活速率与非活性激酶池成正比，比例常数为 $k_b$；自激活速率与活性和非活性激酶池的乘积成正比，比例常数为 $k_a$。\n- 去磷酸化过程由磷酸酶催化，遵循米氏动力学，其最大速率为 $V_{\\max}$，米氏常数为 $K_M$。\n\n任务：\n1. 根据第一性原理，推导出一个形式为 $\\dfrac{dx}{dt} = f(x; k_b, k_a, V_{\\max}, K_M, T)$ 的常微分方程（ODE），该方程能在上述假设下描述基础激活、自激活和饱和去磷酸化过程。\n2. 针对一维系统 $ \\dfrac{dx}{dt} = f(x;\\theta)$，其中标量控制参数嵌入在参数矢量 $\\theta$ 中，构建鞍结分岔的数学条件。这些条件是稳态和相切条件的同步解：\n   - 稳态条件：$f(x;\\theta) = 0$。\n   - 相切（折叠）条件：$\\dfrac{\\partial f}{\\partial x}(x;\\theta) = 0$。\n   - 非简并条件：$\\dfrac{\\partial^2 f}{\\partial x^2}(x;\\theta) \\neq 0$。\n   您需要将基础激活常数 $k_b$ 作为控制参数，并为每个测试用例固定其余参数。\n3. 实现一个数值程序，对于每个参数集，通过联立求解 $f(x; k_b, k_a, V_{\\max}, K_M, T) = 0$ 和 $\\dfrac{\\partial f}{\\partial x}(x; k_b, k_a, V_{\\max}, K_M, T) = 0$ 来同时求解 $x$ 和 $k_b$，从而定位所有鞍结分岔点。求解需满足约束条件 $0  x  T$ 和 $k_b  0$，并验证非简并条件 $\\dfrac{\\partial^2 f}{\\partial x^2} \\neq 0$。报告发生鞍结分岔时对应的 $k_b$ 值。\n4. 您的程序必须稳健地实现该数值算法，无需任何用户输入，并精确地按照规定格式生成最终输出。对于每个参数集，请将检测到的 $k_b$ 值按升序排序。\n\n物理和数值细节：\n- 在此问题中，所有量均为无量纲量；您必须将 $x$、$T$、$k_b$、$k_a$、$V_{\\max}$ 和 $K_M$ 视为无量纲数。\n- 问题不涉及角度；您不得引入任何角度单位。\n- 将每个鞍结分岔点的 $k_b$ 值列表报告为浮点数。\n\n测试套件：\n使用以下参数集来测试不同的机制。每个测试用例是一个元组 $(k_a, V_{\\max}, K_M, T)$；将 $k_b$ 视为待由鞍结条件确定的控制参数。\n- 测试 $1$：$(k_a = 5.0, V_{\\max} = 1.0, K_M = 0.1, T = 1.0)$。\n- 测试 $2$：$(k_a = 1.0, V_{\\max} = 1.0, K_M = 0.1, T = 1.0)$。\n- 测试 $3$：$(k_a = 5.0, V_{\\max} = 5.0, K_M = 0.1, T = 1.0)$。\n- 测试 $4$：$(k_a = 5.0, V_{\\max} = 1.0, K_M = 1.0, T = 1.0)$。\n- 测试 $5$：$(k_a = 3.0, V_{\\max} = 1.0, K_M = 0.2, T = 2.0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个元素对应一个测试用例，其本身也是一个由方括号括起来的逗号分隔列表，包含发生鞍结分岔时的浮点 $k_b$ 值，并按升序排列。例如，如果前两个测试分别产生两个和零个鞍结分岔点，其余测试各产生一个点，则一个有效的输出应类似于 $[[k_{b,1},k_{b,2}],[],[k_{b,3}],[k_{b,4}],[k_{b,5}]]$，其中不含任何空格。", "solution": "用户要求对一个自激活激酶模型进行分岔分析。这需要推导其控制常微分方程（ODE），然后构建并求解鞍结分岔的条件。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n-   **模型：** 一个具有饱和去磷酸化作用的自激活激酶。\n-   **变量：**\n    -   $x$：活性激酶的浓度。\n    -   $T$：守恒的总激酶浓度。\n-   **动力学和速率：**\n    -   基础激活：速率为 $k_b (T - x)$，其中 $k_b$ 是速率常数。\n    -   自激活：速率为 $k_a x (T - x)$，其中 $k_a$ 是速率常数。\n    -   去磷酸化：遵循米氏动力学，速率为 $V_{\\max} \\frac{x}{K_M + x}$，其中 $V_{\\max}$ 是最大速率，$K_M$ 是米氏常数。\n-   **ODE 形式：** $\\dfrac{dx}{dt} = f(x; k_b, k_a, V_{\\max}, K_M, T)$。\n-   **分岔条件（鞍结）：**\n    1.  稳态条件：$f(x; \\theta) = 0$。\n    2.  相切条件：$\\dfrac{\\partial f}{\\partial x}(x; \\theta) = 0$。\n    3.  非简并条件：$\\dfrac{\\partial^2 f}{\\partial x^2}(x; \\theta) \\neq 0$。\n-   **控制参数：** $k_b$。\n-   **约束条件：** $0  x  T$ 和 $k_b  0$。\n-   **测试套件：** 提供了五组关于 $(k_a, V_{\\max}, K_M, T)$ 的参数集。\n-   **输出：** 一个列表的列表，其中每个内部列表包含对应测试用例中发生分岔时的 $k_b$ 值（浮点数，已排序）。\n\n**第 2 步：使用提取的已知信息进行验证**\n-   **科学依据：** 该问题坚实地基于已建立的生物化学动力学。用于激活的质量作用动力学和用于酶促去磷酸化的米氏动力学是系统生物学中的标准模型。正反馈（自激活）与饱和清除过程的结合是一个经典的模体（motif），已知可以产生双稳态和滞后现象，而鞍结分岔正是这些现象的边界。该模型在科学上是合理的。\n-   **适定性：** 该问题是适定的。它要求解一个由两个变量（$x$ 和 $k_b$）组成的、具体且明确定义的代数方程组，该方程组源于标准的动力系统理论（分岔分析）。约束条件具有物理意义，有助于定义一组唯一的解。\n-   **客观性：** 问题陈述精确、量化，没有任何主观或模糊的语言。\n\n**第 3 步：结论与行动**\n该问题有效。它在科学上合理，数学上适定，且表述客观。我将继续推导并实现解决方案。\n\n### 分步解决方案\n\n**1. 控制 ODE 的推导**\n\n活性激酶浓度的时间变化率 $\\dfrac{dx}{dt}$ 是激活和去磷酸化过程的净结果。\n\n-   **激活速率：** 总激活速率是基础激活和自激活速率之和：\n    $$ \\text{Rate}_{\\text{activation}} = k_b (T - x) + k_a x (T - x) = (k_b + k_a x)(T - x) $$\n-   **去磷酸化速率：** 失活速率遵循米氏动力学：\n    $$ \\text{Rate}_{\\text{dephos}} = V_{\\max} \\dfrac{x}{K_M + x} $$\n-   **完整 ODE：** 结合这些项，得到函数 $f(x)$：\n    $$ \\dfrac{dx}{dt} = f(x; k_b, k_a, V_{\\max}, K_M, T) = (k_b + k_a x)(T - x) - V_{\\max} \\dfrac{x}{K_M + x} $$\n\n**2. 鞍结分岔条件**\n\n当一对不动点（一个稳定，一个不稳定）随着参数的变化而出现或消失时，就会发生鞍结分岔。这对应于函数 $f(x)$ 与 x 轴相切。其数学条件是：\n\n-   **稳态条件：** $f(x) = 0$\n    $$ (k_b + k_a x)(T - x) - V_{\\max} \\dfrac{x}{K_M + x} = 0 \\quad (1) $$\n-   **相切条件：** $\\dfrac{\\partial f}{\\partial x} = 0$。首先，我们计算导数：\n    $$ \\dfrac{\\partial f}{\\partial x} = \\dfrac{\\partial}{\\partial x} \\left[ (k_b + k_a x)(T - x) - V_{\\max} \\dfrac{x}{K_M + x} \\right] $$\n    $$ \\dfrac{\\partial f}{\\partial x} = [k_a(T-x) + (k_b+k_a x)(-1)] - V_{\\max} \\dfrac{(1)(K_M + x) - x(1)}{(K_M + x)^2} $$\n    $$ \\dfrac{\\partial f}{\\partial x} = k_a T - k_a x - k_b - k_a x - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} $$\n    $$ \\dfrac{\\partial f}{\\partial x} = k_a(T - 2x) - k_b - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} $$\n    令其为零得到第二个条件：\n    $$ k_a(T - 2x) - k_b - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} = 0 \\quad (2) $$\n-   **非简并条件：** $\\dfrac{\\partial^2 f}{\\partial x^2} \\neq 0$。我们计算二阶导数：\n    $$ \\dfrac{\\partial^2 f}{\\partial x^2} = \\dfrac{\\partial}{\\partial x} \\left[ k_a(T - 2x) - k_b - V_{\\max} K_M (K_M + x)^{-2} \\right] $$\n    $$ \\dfrac{\\partial^2 f}{\\partial x^2} = -2k_a - V_{\\max} K_M (-2)(K_M + x)^{-3} = -2k_a + \\dfrac{2 V_{\\max} K_M}{(K_M + x)^3} $$\n    在解点 $(x, k_b)$ 处，此表达式必须非零。\n\n**3. 解析简化与数值策略**\n\n我们有一个包含两个未知数 $x$ 和 $k_b$ 的方程组，由方程 $(1)$ 和 $(2)$ 组成。为求解该方程组，我们可以先从方程 $(2)$ 中用 $x$ 表示 $k_b$：\n$$ k_b = k_a(T - 2x) - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} \\quad (*) $$\n接下来，我们将这个 $k_b$ 的表达式代入方程 $(1)$。项 $(k_b + k_a x)$ 变为：\n$$ k_b + k_a x = \\left( k_a(T - 2x) - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} \\right) + k_a x = k_a(T - x) - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} $$\n将此代回方程 $(1)$：\n$$ \\left( k_a(T - x) - \\dfrac{V_{\\max} K_M}{(K_M + x)^2} \\right)(T - x) - V_{\\max} \\dfrac{x}{K_M + x} = 0 $$\n为消去分母，我们将整个方程乘以 $(K_M+x)^2$：\n$$ (k_a(T - x)(K_M+x)^2 - V_{\\max}K_M)(T-x) - V_{\\max} x(K_M+x) = 0 $$\n展开并整理各项，我们得到一个关于 $x$ 的多项式方程，记为 $h(x) = 0$：\n$$ h(x) = k_a(T - x)^2 (K_M + x)^2 - V_{\\max} K_M (T - x) - V_{\\max} x (K_M + x) = 0 $$\n简化乘以 $V_{\\max}$ 的项：\n$$ -V_{\\max} [K_M (T - x) + x (K_M + x)] = -V_{\\max} [K_M T - K_M x + K_M x + x^2] = -V_{\\max}(x^2 + K_M T) $$\n因此，需求解的关于 $x$ 的方程是：\n$$ h(x) = k_a(T - x)^2 (K_M + x)^2 - V_{\\max}(x^2 + K_M T) = 0 $$\n这是一个关于 $x$ 的四次多项式。数值求解其根是一种稳健的方法。一种可靠的方法是，首先通过找到 $h(x)$ 的临界点（即 $h'(x)=0$ 的根）来定位包含根的区间，然后使用像 Brent 方法这样的区间求根法在这些区间内求解。\n\n**4. 数值算法**\n\n对于每个参数集 $(k_a, V_{\\max}, K_M, T)$：\n1.  定义四次多项式函数 $h(x)$。\n2.  定义其导数 $h'(x)$，它是一个三次多项式。\n3.  求解 $h'(x)=0$ 在有效范围 $(0, T)$ 内的实根。这些是 $h(x)$ 的临界点。\n4.  使用这些临界点以及 $0$ 和 $T$ 来定义一组搜索区间。对于每个区间 $(a, b)$，检查 $h(a)$ 和 $h(b)$ 的符号是否相反。如果是，则该区间内存在一个根。\n5.  对于每个保证包含根的区间，使用数值求解器（例如，`scipy.optimize.root_scalar` 的 `brentq` 方法）来找到根 $x^*$。\n6.  对于找到的每个根 $x^*$：\n    a. 使用方程 $(*)$ 计算相应的 $k_b^*$。\n    b. 验证 $k_b^*  0$。\n    c. 验证非简并条件：$\\dfrac{\\partial^2 f}{\\partial x^2}(x^*) \\neq 0$。\n    d. 如果所有条件都满足，则该 $k_b^*$ 值对应一个鞍结分岔。\n7.  收集该参数集的所有有效 $k_b^*$ 值，去除重复项，并按升序排序。\n8.  对所有测试用例重复此过程，并按指定格式化最终输出。\n\n此过程将在提供的 Python 环境中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Analyzes a model of a self-activating kinase to find saddle-node bifurcations.\n\n    The model is described by the ODE:\n    dx/dt = (k_b + k_a*x)*(T - x) - V_max*x / (K_M + x)\n\n    Saddle-node bifurcations occur where f(x) = 0 and df/dx = 0 simultaneously.\n    This leads to a quartic polynomial equation h(x) = 0 for the state variable x at the bifurcation point.\n    h(x) = k_a*(T - x)^2*(K_M + x)^2 - V_max*(x^2 + K_M*T)\n\n    The algorithm finds roots of h(x) in (0, T), then calculates the corresponding\n    bifurcation parameter k_b and validates the solution.\n    \"\"\"\n    test_cases = [\n        # (k_a, V_max, K_M, T)\n        (5.0, 1.0, 0.1, 1.0),\n        (1.0, 1.0, 0.1, 1.0),\n        (5.0, 5.0, 0.1, 1.0),\n        (5.0, 1.0, 1.0, 1.0),\n        (3.0, 1.0, 0.2, 2.0),\n    ]\n\n    final_results = []\n    tol = 1e-9  # Tolerance for floating point comparisons\n\n    for params in test_cases:\n        ka, vmax, km, T = params\n\n        # Define the quartic polynomial h(x) whose roots give the x-coordinate of the saddle-node.\n        def h(x, ka_p, vmax_p, km_p, T_p):\n            term1 = ka_p * ((T_p - x)**2) * ((km_p + x)**2)\n            term2 = vmax_p * (x**2 + km_p * T_p)\n            return term1 - term2\n\n        # To robustly find roots of h(x), we first find its critical points by solving h'(x)=0.\n        # h(x) = A*x^4 + B*x^3 + C*x^2 + D*x + E\n        # Coefficients of the polynomial h(x):\n        A = ka\n        B = 2 * ka * (km - T)\n        C = ka * (T**2 - 4 * T * km + km**2) - vmax\n        D = 2 * ka * T * km * (T - km)\n        E = ka * (T * km)**2 - vmax * km * T\n\n        # h'(x) is a cubic: 4*A*x^3 + 3*B*x^2 + 2*C*x + D = 0\n        h_prime_coeffs = [4 * A, 3 * B, 2 * C, D]\n        critical_points_all = np.roots(h_prime_coeffs)\n\n        # Filter for real critical points within the physical interval (0, T)\n        real_crit_pts = [cp.real for cp in critical_points_all if np.isclose(cp.imag, 0)]\n        crit_pts_in_interval = sorted([p for p in real_crit_pts if tol  p  T - tol])\n\n        # Define search intervals for roots of h(x) based on its critical points.\n        boundaries = [0] + crit_pts_in_interval + [T]\n        \n        potential_x_saddles = []\n        for i in range(len(boundaries) - 1):\n            a, b = boundaries[i], boundaries[i + 1]\n            # Use a slightly smaller bracket to avoid issues at the boundaries.\n            a_eff, b_eff = a + tol, b - tol\n            if a_eff >= b_eff:\n                continue\n\n            try:\n                # Check for a sign change, which indicates a root is present.\n                if np.sign(h(a_eff, ka, vmax, km, T)) != np.sign(h(b_eff, ka, vmax, km, T)):\n                    sol = root_scalar(h, args=(ka, vmax, km, T), bracket=[a_eff, b_eff], method='brentq')\n                    potential_x_saddles.append(sol.root)\n            except ValueError:\n                # This can occur if signs are the same; just ignore.\n                pass\n        \n        saddle_node_kbs = set()\n        for x_star in potential_x_saddles:\n            # For each potential x, calculate the corresponding k_b.\n            # k_b = k_a*(T - 2x) - V_max*K_M / (K_M + x)^2\n            kb_star = ka * (T - 2 * x_star) - (vmax * km) / ((km + x_star)**2)\n\n            # Validate the solution: k_b must be positive.\n            if kb_star = tol:\n                continue\n            \n            # Validate the non-degeneracy condition: d2f/dx2 != 0.\n            # d2f/dx2 = -2*k_a + 2*V_max*K_M / (K_M + x)^3\n            d2f_dx2 = -2 * ka + (2 * vmax * km) / ((km + x_star)**3)\n            if abs(d2f_dx2) = tol:\n                continue\n                \n            saddle_node_kbs.add(kb_star)\n\n        final_results.append(sorted(list(saddle_node_kbs)))\n\n    # Format the final output string precisely as specified.\n    formatted_sublists = []\n    for sublist in final_results:\n        s = ','.join(map(str, sublist))\n        formatted_sublists.append(f'[{s}]')\n    \n    print(f\"[{','.join(formatted_sublists)}]\")\n\nsolve()\n```", "id": "3336283"}, {"introduction": "从细胞周期到昼夜节律，生物节律在生命活动中无处不在。本练习旨在探究产生振荡的一个经典机制：带有时间延迟的负反馈回路。通过运用控制理论中的稳定性分析工具 [@problem_id:3336299]，您将学习如何推导系统的传递函数 (transfer function)，并预测系统从稳定状态转变为持续振荡 (sustained oscillations) 的临界条件，从而深入理解生物钟背后的动态原理。", "problem": "考虑一个线性时不变一阶信号模块，该模块在标准准稳态线性化下捕获受体到效应器级联反应的小信号动态。前向过程被建模为一个常微分方程 (ODE)，其增益 $g  0$，时间常数 $\\theta  0$，即 $\\theta \\,\\dot{x}(t) + x(t) = g\\,v(t)$，输出为 $y(t) = x(t)$。测量输出经过一个纯测量延迟 $\\tau  0$ 后，以反馈强度 $k_f  0$进行负反馈，因此受控对象输入为 $v(t) = r(t) - k_f\\,y(t-\\tau)$，其中 $r(t)$ 是一个外源输入。角度和频率的单位应分别理解为弧度和弧度每单位时间。\n\n仅使用线性时不变系统的基本定义、拉普拉斯变换以及负反馈的标准框图代数，完成以下任务：\n\n1. 推导闭环传递函数 $T(s) = \\frac{Y(s)}{R(s)}$，用 $g$、$ \\theta$、$ k_f$ 和 $\\tau$ 表示。\n\n2. 推导极点的闭环特征方程，并通过代入 $s = \\mathrm{i}\\omega$（其中 $\\omega \\in \\mathbb{R}$）并分离实部和虚部，来构建临界振荡条件。\n\n3. 根据这些条件，得到一对共轭复极点位于虚轴上的首次穿越频率 $\\omega^{\\ast}  0$ 的隐式方程，以及相应临界反馈增益 $k_f^{\\ast}$ 关于 $g$、$ \\theta$、$ \\tau$ 和 $\\omega^{\\ast}$ 的闭式表达式。清楚说明相对于 $k_f^{\\ast}$，何时会出现持续振荡。\n\n4. 对于具体参数值 $g = 2.0$ (无量綱)，$\\theta = 1.5$ 分钟，以及 $\\tau = 2.4$ 分钟，计算首次出现持续振荡时的最小临界反馈增益 $k_f^{\\ast}$。将您的答案四舍五入至四位有效数字，并以无量纲数的形式表示。\n\n您最终报告的结果必须是第 4 项中指定的 $k_f^{\\ast}$ 的单个数值。", "solution": "首先验证问题，以确保其有科学依据、适定且客观。\n\n### 第 1 步：提取已知条件\n- 前向过程 ODE：$\\theta \\,\\dot{x}(t) + x(t) = g\\,v(t)$\n- 输出方程：$y(t) = x(t)$\n- 反馈定律：$v(t) = r(t) - k_f\\,y(t-\\tau)$\n- 参数约束：增益 $g  0$，时间常数 $\\theta  0$，反馈强度 $k_f  0$，时间延迟 $\\tau  0$。\n- 外源输入：$r(t)$。\n- 任务分为四个部分：\n  1. 推导闭环传递函数 $T(s) = \\frac{Y(s)}{R(s)}$。\n  2. 推导特征方程和临界振荡条件。\n  3. 推导临界频率 $\\omega^{\\ast}$ 的隐式方程和临界反馈增益 $k_f^{\\ast}$ 的表达式。\n  4. 计算特定参数下的 $k_f^{\\ast}$：$g = 2.0$，$\\theta = 1.5$ 分钟，$\\tau = 2.4$ 分钟。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题描述了一个带比例反馈的一阶加时延 (FOPTD) 系统，这是控制工程和系统生物学中用于分析稳定性和振荡的典型模型。该模型基于线性时不变 (LTI) 系统和拉普拉斯变换的既定原理。它在科学上是合理的。\n- **适定性**：问题给出了所有必要的方程和参数。目标明确，可以得到最小临界增益的唯一解。问题是自洽且一致的。\n- **客观性**：问题用精确的数学语言表述，没有任何主观或模糊的陈述。\n\n### 第 3 步：结论与行动\n问题有效。下面提供了完整的、附有推理的解答。\n\n### 解答推导\n\n**第 1 部分：闭环传递函数**\n\n我们从由常微分方程描述的前向过程动态开始：\n$$\n\\theta \\,\\frac{dx(t)}{dt} + x(t) = g\\,v(t)\n$$\n假设初始条件为零，应用拉普拉斯变换，我们得到：\n$$\n\\theta s X(s) + X(s) = g V(s)\n$$\n其中 $X(s)$ 和 $V(s)$ 分别是 $x(t)$ 和 $v(t)$ 的拉普拉斯变换。\n输出为 $y(t) = x(t)$，所以它们的拉普拉斯变换也相等，$Y(s) = X(s)$。\n因此，前向受控对象 $P(s)$ 的传递函数为：\n$$\nP(s) = \\frac{Y(s)}{V(s)} = \\frac{X(s)}{V(s)} = \\frac{g}{\\theta s + 1}\n$$\n接下来，我们考虑负反馈回路。受控对象输入 $v(t)$ 由下式给出：\n$$\nv(t) = r(t) - k_f y(t-\\tau)\n$$\n其中 $r(t)$ 是参考输入。对该方程进行拉普拉斯变换，并使用时移性质 $\\mathcal{L}\\{f(t-\\tau)\\} = e^{-s\\tau} F(s)$，我们得到：\n$$\nV(s) = R(s) - k_f Y(s) e^{-s\\tau}\n$$\n该系统可以用一个框图表示，其中输出 $Y(s)$ 通过一个传递函数为 $H(s) = k_f e^{-s\\tau}$ 的模块反馈回来。开环传递函数是 $L(s) = P(s)H(s) = \\frac{g k_f e^{-s\\tau}}{\\theta s + 1}$。\n\n使用负反馈系统的标准公式，闭环传递函数 $T(s) = \\frac{Y(s)}{R(s)}$ 为：\n$$\nT(s) = \\frac{P(s)}{1 + P(s)H(s)} = \\frac{\\frac{g}{\\theta s + 1}}{1 + \\frac{g k_f e^{-s\\tau}}{\\theta s + 1}}\n$$\n将分子和分母同乘以 $(\\theta s + 1)$，简化后得到：\n$$\nT(s) = \\frac{g}{\\theta s + 1 + g k_f e^{-s\\tau}}\n$$\n\n**第 2 部分：特征方程和临界振荡条件**\n\n闭环系统的稳定性由极点的位置决定，极点是令 $T(s)$ 的分母为零所得到的特征方程的根。\n特征方程为：\n$$\n\\theta s + 1 + g k_f e^{-s\\tau} = 0\n$$\n临界稳定性对应于持续振荡的开始，发生在s-复平面上有一对共轭复极点位于虚轴上时。我们通过代入 $s = \\mathrm{i}\\omega$ 来找到这个条件，其中 $\\omega  0$ 是振荡的角频率。\n$$\n\\theta (\\mathrm{i}\\omega) + 1 + g k_f e^{-\\mathrm{i}\\omega\\tau} = 0\n$$\n使用欧拉公式 $e^{-\\mathrm{i}\\omega\\tau} = \\cos(\\omega\\tau) - \\mathrm{i}\\sin(\\omega\\tau)$，我们展开方程：\n$$\n\\mathrm{i}\\theta\\omega + 1 + g k_f (\\cos(\\omega\\tau) - \\mathrm{i}\\sin(\\omega\\tau)) = 0\n$$\n为求解这个复数方程，我们将其分为实部和虚部，并令它们都为零：\n$$\n(1 + g k_f \\cos(\\omega\\tau)) + \\mathrm{i}(\\theta\\omega - g k_f \\sin(\\omega\\tau)) = 0\n$$\n这得到一个由两个方程组成的方程组：\n$$\n\\text{实部: } \\quad 1 + g k_f \\cos(\\omega\\tau) = 0\n$$\n$$\n\\text{虚部: } \\quad \\theta\\omega - g k_f \\sin(\\omega\\tau) = 0\n$$\n\n**第 3 部分：$\\omega^{\\ast}$ 和 $k_f^{\\ast}$ 的推导**\n\n令 $\\omega^{\\ast}$ 为极点首次穿越虚轴时的第一个正频率，令 $k_f^{\\ast}$ 为相应的临界反馈增益。第 2 部分中的两个方程变为：\n$$\n(1)\\quad g k_f^{\\ast} \\cos(\\omega^{\\ast}\\tau) = -1\n$$\n$$\n(2)\\quad g k_f^{\\ast} \\sin(\\omega^{\\ast}\\tau) = \\theta\\omega^{\\ast}\n$$\n为了找到 $\\omega^{\\ast}$ 的隐式方程，我们可以用方程 $(2)$ 除以方程 $(1)$：\n$$\n\\frac{g k_f^{\\ast} \\sin(\\omega^{\\ast}\\tau)}{g k_f^{\\ast} \\cos(\\omega^{\\ast}\\tau)} = \\frac{\\theta\\omega^{\\ast}}{-1}\n$$\n这给出了关于 $\\omega^{\\ast}$ 的超越方程：\n$$\n\\tan(\\omega^{\\ast}\\tau) = -\\theta\\omega^{\\ast}\n$$\n为了找到 $k_f^{\\ast}$ 的表达式，我们将方程 $(1)$ 和 $(2)$ 两边平方后相加：\n$$\n(g k_f^{\\ast})^2 \\cos^2(\\omega^{\\ast}\\tau) + (g k_f^{\\ast})^2 \\sin^2(\\omega^{\\ast}\\tau) = (-1)^2 + (\\theta\\omega^{\\ast})^2\n$$\n使用恒等式 $\\cos^2(\\phi) + \\sin^2(\\phi) = 1$：\n$$\n(g k_f^{\\ast})^2 = 1 + (\\theta\\omega^{\\ast})^2\n$$\n因为 $g  0$ 且 $k_f^{\\ast}  0$，我们可以解出 $k_f^{\\ast}$：\n$$\nk_f^{\\ast} = \\frac{\\sqrt{1 + (\\theta\\omega^{\\ast})^2}}{g}\n$$\n这就得到了用其他参数和临界频率 $\\omega^{\\ast}$ 表示的临界增益。\n\n根据方程(1)，$\\cos(\\omega^\\ast\\tau) = -1/(g k_f^\\ast)  0$。根据方程(2)，$\\sin(\\omega^\\ast\\tau) = \\theta\\omega^\\ast/(g k_f^\\ast)  0$。一个余弦为负、正弦为正的角度必定位于第二象限。最小正频率 $\\omega^{\\ast}$ 对应于角度的主值，即 $\\omega^{\\ast}\\tau \\in (\\frac{\\pi}{2}, \\pi)$。对于典型的根轨迹，当 $k_f  k_f^{\\ast}$ 时系统是稳定的。当 $k_f = k_f^{\\ast}$ 时出现持续振荡，而当 $k_f  k_f^{\\ast}$ 时系统变得不稳定。\n\n**第 4 部分：数值计算**\n\n给定的参数值为 $g = 2.0$, $\\theta = 1.5$ 分钟, 以及 $\\tau = 2.4$ 分钟。\n首先，我们求解 $\\omega^{\\ast}$ 的隐式方程：\n$$\n\\tan(2.4\\,\\omega^{\\ast}) = -1.5\\,\\omega^{\\ast}\n$$\n令 $x = 2.4\\,\\omega^{\\ast}$。则 $\\omega^{\\ast} = x/2.4$。将此代入方程得到：\n$$\n\\tan(x) = -1.5 \\left(\\frac{x}{2.4}\\right) = -0.625x\n$$\n我们需要找到方程 $f(x) = \\tan(x) + 0.625x = 0$ 在区间 $x \\in (\\frac{\\pi}{2}, \\pi) \\approx (1.571, 3.142)$ 内的根。\n这个超越方程的数值解（例如，使用牛顿法或计算求解器）得出：\n$$\nx \\approx 2.199723\n$$\n现在，我们求临界频率 $\\omega^{\\ast}$：\n$$\n\\omega^{\\ast} = \\frac{x}{\\tau} = \\frac{2.199723}{2.4} \\approx 0.916551 \\text{ rad/min}\n$$\n最后，我们使用推导出的公式计算临界反馈增益 $k_f^{\\ast}$：\n$$\nk_f^{\\ast} = \\frac{\\sqrt{1 + (\\theta\\omega^{\\ast})^2}}{g} = \\frac{\\sqrt{1 + (1.5 \\times 0.916551)^2}}{2.0}\n$$\n$$\nk_f^{\\ast} = \\frac{\\sqrt{1 + (1.374827)^2}}{2.0} = \\frac{\\sqrt{1 + 1.890149}}{2.0}\n$$\n$$\nk_f^{\\ast} = \\frac{\\sqrt{2.890149}}{2.0} = \\frac{1.700044}{2.0} \\approx 0.850022\n$$\n四舍五入到四位有效数字，临界反馈增益为 $0.8500$。", "answer": "$$\n\\boxed{0.8500}\n$$", "id": "3336299"}]}