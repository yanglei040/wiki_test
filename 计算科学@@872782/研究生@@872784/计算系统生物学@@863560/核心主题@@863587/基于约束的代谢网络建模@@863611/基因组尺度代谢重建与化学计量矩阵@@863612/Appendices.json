{"hands_on_practices": [{"introduction": "通量平衡分析（FBA）的预测能力在很大程度上依赖于对网络中每个反应所施加的约束，特别是反应方向性（可逆或不可逆）的设定。这个实践将揭示这些约束背后的基本原理，展示它们如何从基本的热力学定律中推导得出。通过这个练习，你将学习如何根据代谢物的生理浓度计算反应的实际吉布斯自由能变化（$\\Delta_r G^\\prime$），并利用其判断反应的不可逆性，从而将物理化学原理与模型参数紧密联系起来 [@problem_id:3316719]。", "problem": "考虑一个嵌入在基因组尺度代谢化学计量表示中的单一细胞内反应。该反应根据化学计量式 $2A + B \\rightarrow C + D$ 消耗代谢物 $A$ 和 $B$ 以生成代谢物 $C$ 和 $D$。该反应在化学计量矩阵中对应的列，写成化学计量系数向量为 $\\boldsymbol{\\nu}^{(r)} = \\begin{pmatrix} \\nu_A \\\\ \\nu_B \\\\ \\nu_C \\\\ \\nu_D \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ -1 \\\\ 1 \\\\ 1 \\end{pmatrix}$。假设在生化标准状态（pH $7$, $I \\approx 0.1$ M）下，标准生成吉布斯自由能为 $\\Delta_f G_A^\\circ = -120$ kJ/mol, $\\Delta_f G_B^\\circ = -80$ kJ/mol, $\\Delta_f G_C^\\circ = -220$ kJ/mol, 以及 $\\Delta_f G_D^\\circ = -90$ kJ/mol。胞质活度为 $a_A = 0.2$, $a_B = 0.1$, $a_C = 1.0 \\times 10^{-6}$, 以及 $a_D = 1.0 \\times 10^{-4}$。设绝对温度为 $T = 310$ K，普适气体常数为 $R = 8.314462618 \\times 10^{-3}$ kJ mol$^{-1}$ K$^{-1}$。反应自由能的符号约定由上述化学计量式设定，当反应按书写方向进行，即消耗 $A$ 和 $B$ 并生成 $C$ 和 $D$ 时，正向通量 $v_r$ 定义为正。\n\n从化学势的定义和反应的化学计量表示出发，推导以标准生成吉布斯自由能 $\\Delta_f G_i^\\circ$ 和化学计量系数 $\\nu_i$ 表示的标准反应吉布斯能 $\\Delta_r G^\\circ$，然后利用代谢物活度求出在温度 $T$ 下的转换反应吉布斯能 $\\Delta_r G^\\prime$。在稳态通量平衡分析（FBA）的背景下（其中通量 $\\boldsymbol{v}$ 满足 $\\mathbf{S}\\boldsymbol{v} = \\boldsymbol{0}$），当给定活度下 $\\Delta_r G^\\prime \\ll 0$ 时，构建关于标量通量 $v_r$ 的不等式，以强制该反应的不可逆性。最后，使用所提供的数据计算 $\\Delta_r G^\\prime$ 的数值，并将您的最终数值答案以 kJ/mol 为单位表示，保留四位有效数字。", "solution": "**反应吉布斯能的推导**\n\n标准反应吉布斯能 $\\Delta_r G^\\circ$ 指在标准状态下，所有反应物和产物都维持其标准浓度（通常为1M）、温度（通常为298.15K）和压力（1 bar）时，一摩尔反应发生所引起的吉布斯自由能变化。根据盖斯定律，它可以通过将产物的标准生成吉布斯自由能 $\\Delta_f G_i^\\circ$ 的总和减去反应物的标准生成吉布斯自由能的总和计算得出，每一项都由其化学计量系数 $\\nu_i$ 加权。采用产物系数为正、反应物系数为负的约定，该关系可紧凑地表示为：\n$$\n\\Delta_r G^\\circ = \\sum_i \\nu_i \\Delta_f G_i^\\circ\n$$\n\n在实际细胞条件下，反应物和产物的活度（或近似浓度）不处于标准状态。物质 $i$ 的化学势 $\\mu_i$ 与其标准化学势 $\\mu_i^\\circ$（等于其标准生成吉布斯自由能 $\\Delta_f G_i^\\circ$）通过以下方程相关联：\n$$\n\\mu_i = \\mu_i^\\circ + RT \\ln a_i\n$$\n其中 $R$ 是普适气体常数，$T$ 是绝对温度，$a_i$ 是物质 $i$ 的活度。实际的反应吉布斯能，即转换反应吉布斯能 $\\Delta_r G^\\prime$，是产物和反应物化学势的总和，并由其化学计量系数 $\\nu_i$ 加权：\n$$\n\\Delta_r G^\\prime = \\sum_i \\nu_i \\mu_i = \\sum_i \\nu_i (\\mu_i^\\circ + RT \\ln a_i) = \\sum_i \\nu_i \\mu_i^\\circ + RT \\sum_i \\nu_i \\ln a_i\n$$\n第一项是 $\\Delta_r G^\\circ$ 的定义。第二项可以简化为：\n$$\n\\Delta_r G^\\prime = \\Delta_r G^\\circ + RT \\ln \\left( \\prod_i a_i^{\\nu_i} \\right)\n$$\n乘积项 $\\prod_i a_i^{\\nu_i}$ 是反应商 $Q$。对于反应 $2A + B \\rightarrow C + D$，它是：\n$$\nQ = \\frac{a_C a_D}{a_A^2 a_B}\n$$\n因此，转换反应吉布斯能的最终表达式为：\n$$\n\\Delta_r G^\\prime = \\Delta_r G^\\circ + RT \\ln Q\n$$\n\n**FBA中的通量不可逆性约束**\n\n热力学第二定律规定，只有当吉布斯自由能变为负（$\\Delta_r G^\\prime  0$）时，反应才能自发进行。在FBA的背景下，通量 $v_r$ 代表反应的净速率。通量的方向与 $\\Delta_r G^\\prime$ 的符号紧密相关。\n- 如果 $\\Delta_r G^\\prime  0$，正向反应是自发的，意味着净通量必须是非负的，$v_r \\ge 0$。\n- 如果 $\\Delta_r G^\\prime > 0$，逆向反应是自发的，意味着净通量必须是非正的，$v_r \\le 0$。\n- 如果 $\\Delta_r G^\\prime = 0$，反应处于平衡状态，净通量为零，$v_r = 0$。\n\n问题指定了一个 $\\Delta_r G^\\prime \\ll 0$ 的情景。这表明吉布斯自由能有很大的负变化，意味着正向反应在热力学上非常有利，实际上是不可逆的。在这种条件下，逆向反应不可能发生。因此，通量 $v_r$ 必须为非负。在FBA的基于约束的建模框架中，这被表述为一个不等式，为该通量设定了一个下界：\n$$\nv_r \\ge 0\n$$\n这是在FBA中强制反应不可逆的标准方法。一个典型的完整约束将是 $0 \\le v_r \\le v_{max}$，其中 $v_{max}$ 是由酶动力学等因素决定的通量上限。\n\n**数值计算**\n\n首先，计算标准反应吉布斯能 $\\Delta_r G^\\circ$：\n$$\n\\Delta_r G^\\circ = \\nu_A \\Delta_f G_A^\\circ + \\nu_B \\Delta_f G_B^\\circ + \\nu_C \\Delta_f G_C^\\circ + \\nu_D \\Delta_f G_D^\\circ\n$$\n$$\n\\Delta_r G^\\circ = (-2)(-120 \\text{ kJ/mol}) + (-1)(-80 \\text{ kJ/mol}) + (1)(-220 \\text{ kJ/mol}) + (1)(-90 \\text{ kJ/mol})\n$$\n$$\n\\Delta_r G^\\circ = (240 + 80 - 220 - 90) \\text{ kJ/mol} = (320 - 310) \\text{ kJ/mol} = 10 \\text{ kJ/mol}\n$$\n接下来，使用给定的活度计算反应商 $Q$：\n$$\nQ = \\frac{a_C a_D}{a_A^2 a_B} = \\frac{(1.0 \\times 10^{-6})(1.0 \\times 10^{-4})}{(0.2)^2 (0.1)} = \\frac{1.0 \\times 10^{-10}}{(0.04)(0.1)} = \\frac{1.0 \\times 10^{-10}}{0.004} = 2.5 \\times 10^{-8}\n$$\n现在，计算 $RT \\ln Q$ 项：\n$$\nRT = (8.314462618 \\times 10^{-3} \\text{ kJ mol}^{-1} \\text{ K}^{-1})(310 \\text{ K}) \\approx 2.57748 \\text{ kJ/mol}\n$$\n$$\n\\ln Q = \\ln(2.5 \\times 10^{-8}) \\approx -17.504397\n$$\n$$\nRT \\ln Q \\approx (2.57748 \\text{ kJ/mol})( -17.504397) \\approx -45.12028 \\text{ kJ/mol}\n$$\n最后，计算转换反应吉布斯能 $\\Delta_r G^\\prime$：\n$$\n\\Delta_r G^\\prime = \\Delta_r G^\\circ + RT \\ln Q \\approx 10 \\text{ kJ/mol} - 45.12028 \\text{ kJ/mol} = -35.12028 \\text{ kJ/mol}\n$$\n将最终答案四舍五入到四位有效数字：\n$$\n\\Delta_r G^\\prime = -35.12 \\text{ kJ/mol}\n$$\n这个很大的负值证实了在指定的胞质条件下，该反应在正向方向上非常有利，并且实际上是不可逆的，这为约束条件 $v_r \\ge 0$ 提供了坚实的理论依据。", "answer": "$$\n\\boxed{-35.12}\n$$", "id": "3316719"}, {"introduction": "在理解了物理约束之后，下一步是将遗传信息整合到模型中。本实践将探讨基因-蛋白质-反应（GPR）规则，这是连接生物体基因型与其代谢表型的逻辑基础。你将练习如何将布尔逻辑形式的GPR规则（例如，同工酶的“或”逻辑与酶复合物的“与”逻辑）转化为混合整数线性规划的数学语言，这是构建和分析基因组尺度模型的关键技能 [@problem_id:3316802]。", "problem": "您正在重建一个最小代谢模块，以说明基因-蛋白质-反应 (GPR) 规则如何在通量平衡分析 (FBA) 中约束反应通量。考虑一个细胞内代谢网络，该网络包含两种内源性代谢物 $A$ 和 $B$，以及三个不可逆反应：一个从外部库将 $A$ 输入细胞的摄取反应 $v_{u}$，一个将 $A$ 转化为 $B$ 的转化反应 $v_{R}$，以及一个将 $B$ 排出到外部汇的排泄反应 $v_{d}$。细胞内代谢物的稳态假设由化学计量矩阵 $S$ 和约束条件 $S \\, v = 0$ 表示，根据网络拓扑，这在此处意味着在稳态下 $v_{u} = v_{R} = v_{d}$。每个反应 $v_{i}$ 都遵循边界条件 $0 \\le v_{i} \\le u_{i}$。\n\n转化反应 $v_{R}$ 由一个遵循基因-蛋白质-反应 (GPR) 规则 $((g_{1} \\land g_{2}) \\lor g_{3})$ 的酶催化，其中基因 $g_{1}$ 和 $g_{2}$ 编码一个蛋白质复合物的亚基（逻辑与），而基因 $g_{3}$ 编码一个同工酶（逻辑或）。令 $x_{1}, x_{2}, x_{3} \\in \\{0,1\\}$ 表示二元基因存在指示符，其中 $x_{i} = 1$ 表示基因 $g_{i}$ 存在（未被敲除），$x_{i} = 0$ 表示它被敲除。为 $v_{R}$ 引入一个二元反应活性指示符 $y \\in \\{0,1\\}$。假设边界条件如下：相对于 $v_{R}$ 的催化能力，摄取反应是非限制性的，即 $0 \\le v_{u} \\le U$ 且 $U \\ge V$；排泄反应也是非限制性的，即 $0 \\le v_{d} \\le \\bar{U}$，其中 $\\bar{U}$ 足够大。当该酶催化反应激活时，其催化上限为 $0 \\le v_{R} \\le V$。您可以假设所有三个反应都是不可逆的。\n\n任务：\n- 仅使用化学计量稳态 ($S \\, v = 0$) 的核心定义、反应边界和 GPR 规则的布尔逻辑（同工酶为逻辑或，蛋白质复合物为逻辑与），将布尔规则 $((g_{1} \\land g_{2}) \\lor g_{3})$ 转化为一组混合整数线性约束。这些约束将基因指示符 $x_{1}, x_{2}, x_{3}$、反应活性指示符 $y$ 以及 $v_{R}$ 的催化边界联系起来，使得当规则不满足时 $v_{R} = 0$，当规则满足时 $v_{R} \\le V$。不要先验地假设任何特定的线性化方法；请从布尔语义中推导出它。\n\n- 现在假设基因存在事件在各基因间是随机且独立的，其中 $\\mathbb{P}(x_{i} = 1) = p_{i}$ (对于 $i \\in \\{1,2,3\\}$)，且 $\\mathbb{P}(x_{i} = 0) = 1 - p_{i}$。在 FBA 目标为最大化 $v_{R}$，并受限于 $S \\, v = 0$ 和上述推导出的边界条件的情况下，计算最优目标值的期望值 $\\mathbb{E}[\\max v_{R}]$，并将其表示为关于 $p_{1}$、$p_{2}$、$p_{3}$ 和 $V$ 的封闭形式解析表达式。\n\n将您的最终答案表示为单个封闭形式表达式。如果包含物理单位，请将预期通量表示为 $\\text{mmol}\\ \\text{gDW}^{-1}\\ \\text{h}^{-1}$。无需四舍五入。", "solution": "此问题包含两个部分。首先，我们需要将给定的基因-蛋白质-反应（GPR）布尔规则转化为一组混合整数线性约束。其次，在基因存在概率模型下，计算由GPR规则调控的反应的最大通量的期望值。\n\n**第一部分：GPR规则的线性化**\n\nGPR规则为 $((g_1 \\land g_2) \\lor g_3)$。我们引入二元变量 $x_1, x_2, x_3 \\in \\{0, 1\\}$ 表示基因 $g_1, g_2, g_3$ 是否存在，并引入二元变量 $y \\in \\{0, 1\\}$ 表示反应 $v_R$ 是否被激活。当GPR规则为真时，$y=1$；否则 $y=0$。\n\n逻辑表达式 $y = (x_1 \\land x_2) \\lor x_3$ 意味着，如果 $x_3=1$，则 $y=1$；或者，如果 $x_1=1$ 且 $x_2=1$，则 $y=1$。我们可以通过引入一个代表“与”逻辑的中间变量 $z = x_1 \\land x_2$ 来构建约束。\n1.  将 $z = x_1 \\land x_2$ 线性化：\n    - $z \\le x_1$\n    - $z \\le x_2$\n    - $z \\ge x_1 + x_2 - 1$\n    这些不等式确保了只有当 $x_1$ 和 $x_2$ 都为1时，$z$ 才能为1。\n\n2.  将 $y = z \\lor x_3$ 线性化：\n    - $y \\ge z$\n    - $y \\ge x_3$\n    - $y \\le z + x_3$\n    这些不等式确保了只要 $z$ 或 $x_3$ 中至少有一个为1，$y$ 就必须为1。\n\n3.  将反应活性与通量 $v_R$ 关联起来：\n    反应 $v_R$ 的通量上限为 $V$。当反应被激活时（$y=1$），通量 $v_R$ 可以达到其上限 $V$。当反应未被激活时（$y=0$），通量必须为零。这可以通过以下“大M”类型的约束来实现：\n    $$ v_R \\le V \\cdot y $$\n    结合反应的不可逆性约束 $v_R \\ge 0$：\n    - 如果 $y=0$，则 $0 \\le v_R \\le 0$，即 $v_R=0$。\n    - 如果 $y=1$，则 $0 \\le v_R \\le V$，符合题意。\n\n因此，完整的混合整数线性约束集是：\n$$ z \\le x_1 $$\n$$ z \\le x_2 $$\n$$ z \\ge x_1 + x_2 - 1 $$\n$$ y \\ge z $$\n$$ y \\ge x_3 $$\n$$ y \\le z + x_3 $$\n$$ v_R \\le V \\cdot y $$\n$$ v_R \\ge 0 $$\n其中 $x_i, y, z$ 为二元变量。\n\n**第二部分：计算期望通量**\n\nFBA问题是在网络约束下最大化 $v_R$。稳态条件 $S v = 0$ 意味着 $v_u = v_R = v_d$。反应的边界条件为 $0 \\le v_u \\le U$，$0 \\le v_d \\le \\bar{U}$，以及由GPR规则决定的 $0 \\le v_R \\le V \\cdot y$。由于 $U \\ge V$ 且 $\\bar{U}$ 足够大（即 $\\ge V$），$v_R$ 的有效上限由GPR约束决定。\n\n对于给定的基因状态 $\\{x_1, x_2, x_3\\}$，优化问题 $\\max v_R$ 的解为：\n$$ \\max v_R = V \\cdot y $$\n由于基因状态是随机的，最优通量也是一个随机变量。我们需要计算它的期望值：\n$$ \\mathbb{E}[\\max v_R] = \\mathbb{E}[V \\cdot y] = V \\cdot \\mathbb{E}[y] $$\n对于二元变量 $y$，其期望值等于它取值为1的概率，即 $\\mathbb{E}[y] = \\mathbb{P}(y=1)$。因此，我们需要计算GPR规则被满足的概率。\n$$ \\mathbb{P}(y=1) = \\mathbb{P}((x_1=1 \\land x_2=1) \\lor x_3=1) $$\n使用概率的加法法则：\n$$ \\mathbb{P}(A \\lor B) = \\mathbb{P}(A) + \\mathbb{P}(B) - \\mathbb{P}(A \\land B) $$\n令事件 $A$ 为 $x_1=1 \\land x_2=1$，事件 $B$ 为 $x_3=1$。\n由于基因存在的独立性：\n$$ \\mathbb{P}(A) = \\mathbb{P}(x_1=1 \\land x_2=1) = \\mathbb{P}(x_1=1) \\cdot \\mathbb{P}(x_2=1) = p_1 p_2 $$\n$$ \\mathbb{P}(B) = \\mathbb{P}(x_3=1) = p_3 $$\n事件 $A \\land B$ 是 $x_1=1 \\land x_2=1 \\land x_3=1$。同样由于独立性：\n$$ \\mathbb{P}(A \\land B) = \\mathbb{P}(x_1=1) \\cdot \\mathbb{P}(x_2=1) \\cdot \\mathbb{P}(x_3=1) = p_1 p_2 p_3 $$\n将这些代入加法法则：\n$$ \\mathbb{P}(y=1) = p_1 p_2 + p_3 - p_1 p_2 p_3 $$\n最后，最大通量的期望值为：\n$$ \\mathbb{E}[\\max v_R] = V \\cdot \\mathbb{P}(y=1) = V (p_1 p_2 + p_3 - p_1 p_2 p_3) $$\n这个表达式给出了以催化能力 $V$ 和各基因的存在概率 $p_1, p_2, p_3$ 表示的预期最优通量。", "answer": "$$ \\boxed{V (p_1 p_2 + p_3 - p_1 p_2 p_3)} $$", "id": "3316802"}, {"introduction": "直接从基因组数据重建的代谢网络模型通常是不完整的，存在“空缺”（gaps），导致其无法模拟细胞生长等关键生理功能。这项高级实践将通过一个原则性的“空缺填充”（gap-filling）算法来解决这一核心重建挑战。你将实现一个方法，用于从候选反应库中识别出恢复网络功能所需的最小反应集合，同时学习如何检测并避免模型中可能出现的、不符合物理规律的“能量循环”等问题 [@problem_id:3316760]。", "problem": "请使用化学计量矩阵形式，为小型代谢网络构建一个有原则的空隙填充算法。其目标是通过从一个给定的候选集合中添加最少数量的反应来恢复生物质合成的可行性，同时严格排除产物能循环。你的程序必须实现以下数学框架，并将其应用于指定的测试套件。\n\n定义和基本基础：\n- 一个代谢网络由一个化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$（涵盖 $m$ 种代谢物和 $n$ 个反应）和一个通量向量 $v \\in \\mathbb{R}^{n}$ 来表示。稳态要求 $S v = 0$。\n- 每个反应 $j$ 都有一个下界和上界 $l_j \\le v_j \\le u_j$。边界可以编码不可逆性（例如 $l_j = 0$）或摄取限制（例如 $l_j = -10, u_j = 1000$）。\n- 通量平衡分析 (Flux Balance Analysis, FBA) 是一个线性规划 (Linear Programming, LP) 问题，它在满足 $S v = 0$ 和边界 $l \\le v \\le u$ 的约束下，最大化一个目标（这里是生物质反应通量）。\n- 一组交换反应 $E \\subset \\{0,\\dots,n-1\\}$ 代表与环境的交换。为了排除产物能循环，我们将通过关闭环境来测试它们的存在，这会强制所有 $j \\in E$ 的 $v_j = 0$。\n- 产物能循环的操作性检测方法是：在所有交换都关闭的情况下，测试最大化一个腺苷三磷酸 (Adenosine Triphosphate, ATP) 水解消耗反应的 LP 是否允许一个严格为正的最优通量。形式上，让 $a$ 作为 ATP 消耗反应的索引。求解\n  $$\\max_{v \\in \\mathbb{R}^n} \\ v_a \\quad \\text{subject to} \\quad S v = 0, \\quad l' \\le v \\le u',$$\n  其中，对于所有 $j \\in E$（关闭的交换），$l'_j = u'_j = 0$，否则 $l'_j = l_j, u'_j = u_j$。如果最优值严格大于 $0$（在数值上，大于一个小的容差），则该网络存在产物能循环，是无效的。\n- 空隙填充问题是：给定一个基础网络 $(S_{\\text{base}}, l_{\\text{base}}, u_{\\text{base}})$，其拥有一个指定的生物质反应索引 $b$ 和一个 ATP 消耗索引 $a$，以及一组候选反应 $\\{(s^{(k)}, \\ell^{(k)}, u^{(k)})\\}_{k=0}^{K-1}$，选择一个基数最小的候选子集，使得：\n  1. 当求解\n     $$\\max_{v} \\ v_b \\quad \\text{subject to} \\quad S_{\\text{aug}} v = 0, \\quad l_{\\text{aug}} \\le v \\le u_{\\text{aug}},$$\n     时，增广网络允许一个具有严格为正的生物质通量的可行稳态，其中 $S_{\\text{aug}}$ 和边界包含了附加到基础网络上的所选候选反应。\n  2. 根据上述关闭所有交换的 LP，增广网络不存在产物能循环。\n  如果有多个基数最小的子集满足这些标准，选择候选索引字典序最小的那个集合。\n\n测试套件：\n对于所有测试，代谢物顺序为 $(A, B, ATP, ADP, Pi)$，所有未另外指定的通量边界都采用一致的任意单位。以下所有数字均为精确常数。索引是从零开始的。\n\n- 测试 1：\n  - 基础反应（列索引从 $0$ 到 $2$）：\n    - 索引 $0$（$A$ 的交换反应）：化学计量向量 $( -1, 0, 0, 0, 0 )$，边界 $l_0 = -10, u_0 = 1000$。\n    - 索引 $1$（生物质）：化学计量向量 $( 0, -1, -1, +1, +1 )$，边界 $l_1 = 0, u_1 = 1000$。\n    - 索引 $2$（ATP 消耗）：化学计量向量 $( 0, 0, -1, +1, +1 )$，边界 $l_2 = 0, u_2 = 1000$。\n  - 候选反应（索引从 $c0$ 到 $c2$）：\n    - $c0$：$( -1, +1, 0, 0, 0 )$，边界 $0 \\le v \\le 1000$。\n    - $c1$：$( 0, 0, +1, -1, -1 )$，边界 $0 \\le v \\le 1000$。\n    - $c2$：$( -1, +1, +1, -1, -1 )$，边界 $0 \\le v \\le 1000$。\n  - 交换反应索引：$E = \\{ 0 \\}$。\n  - 生物质索引：$b = 1$。\n  - ATP 消耗索引：$a = 2$。\n\n- 测试 2：\n  - 基础反应（列索引从 $0$ 到 $3$）：\n    - 索引 $0$（$A$ 的交换反应）：$( -1, 0, 0, 0, 0 )$，边界 $l_0 = -10, u_0 = 1000$。\n    - 索引 $1$（已存在的 $A \\to B$）：$( -1, +1, 0, 0, 0 )$，边界 $l_1 = 0, u_1 = 1000$。\n    - 索引 $2$（生物质）：$( 0, -1, -1, +1, +1 )$，边界 $l_2 = 0, u_2 = 1000$。\n    - 索引 $3$（ATP 消耗）：$( 0, 0, -1, +1, +1 )$，边界 $l_3 = 0, u_3 = 1000$。\n  - 候选反应（索引从 $c0$ 到 $c2$）：\n    - $c0$：$( 0, 0, +1, -1, -1 )$，边界 $0 \\le v \\le 1000$。\n    - $c1$：$( -1, 0, +1, -1, -1 )$，边界 $0 \\le v \\le 1000$。\n    - $c2$：$( -1, +1, +1, -1, -1 )$，边界 $0 \\le v \\le 1000$。\n  - 交换反应索引：$E = \\{ 0 \\}$。\n  - 生物质索引：$b = 2$。\n  - ATP 消耗索引：$a = 3$。\n\n- 测试 3：\n  - 基础反应（列索引从 $0$ 到 $3$）：\n    - 索引 $0$（$A$ 的交换反应）：$( -1, 0, 0, 0, 0 )$，边界 $l_0 = -2, u_0 = 1000$。\n    - 索引 $1$（ATP 耦合到 $A$）：$( -1, 0, +1, -1, -1 )$，边界 $l_1 = 0, u_1 = 1000$。\n    - 索引 $2$（生物质）：$( 0, -1, -1, +1, +1 )$，边界 $l_2 = 0, u_2 = 1000$。\n    - 索引 $3$（ATP 消耗）：$( 0, 0, -1, +1, +1 )$，边界 $l_3 = 0, u_3 = 1000$。\n  - 候选反应（索引从 $c0$ 到 $c2$）：\n    - $c0$：$( -1, +1, 0, 0, 0 )$，边界 $0 \\le v \\le 1000$。\n    - $c1$：$( -2, +1, 0, 0, 0 )$，边界 $0 \\le v \\le 1000$。\n    - $c2$：$( 0, 0, +1, -1, -1 )$，边界 $0 \\le v \\le 1000$。\n  - 交换反应索引：$E = \\{ 0 \\}$。\n  - 生物质索引：$b = 2$。\n  - ATP 消耗索引：$a = 3$。\n\n对你的程序的要求：\n- 对于每个测试，按基数递增的顺序枚举候选子集，在相同基数内，按候选索引的字典序枚举。\n- 对给定的子集，构建增广网络并：\n  1. 如上定义，通过求解在关闭交换的情况下最大化 $v_a$ 的 LP 来验证不存在产物能循环。如果最优 $v_a$ 严格大于 0，则拒绝该子集。\n  2. 如果通过，求解 FBA 以最大化生物质通量 $v_b$（使用原始交换边界）。如果最优 $v_b$ 严格大于 0，则接受该子集。\n- 选择第一个同时满足这两个标准的子集。如果没有子集同时满足这两个标准，则为该测试返回空列表。\n- 数值容差：将任何 $\\le 10^{-9}$ 的通量视为零。\n- 最终输出格式：你的程序应生成单行，包含一个整数列表的列表，其中第 $i$ 个内部列表包含为测试 $i$ 选择的候选反应的从零开始的索引，并按升序排列。例如，像 `[[2],[1],[0]]` 这样的输出表示为测试 1 选择候选反应 2，为测试 2 选择候选反应 1，为测试 3 选择候选反应 0。\n\n你的程序必须是一个完整的、可运行的实现，它硬编码了上述测试套件，并仅以指定格式打印最终结果行。输出中不需要单位。", "solution": "该问题要求实现一个算法，从一个候选池中识别出一个最小的反应集合，以修复一个存在空缺的代谢网络。网络的功能性由两个标准定义：能够以非零速率产生生物质，以及不存在热力学上不可行的能量生成循环。\n\n解决方案的核心是系统地搜索候选反应的所有可能子集。为确保找到的是最小且唯一的解（根据字典序），搜索按子集的大小（基数）递增进行，从0到候选反应总数 $K$。对于相同大小的子集，则按照候选反应索引的字典序进行迭代。第一个满足所有必要标准的子集即为最终解。\n\n对于每个候选子集，我们通过将选定的反应添加到基础网络来构建一个增广代谢网络。该增广网络由其化学计量矩阵 $S_{\\text{aug}}$ 和反应通量边界 $l_{\\text{aug}} \\le v \\le u_{\\text{aug}}$ 描述。然后，此增广网络将经受两个验证测试，这两个测试都以线性规划（LP）问题的形式表述。\n\n**1. 能量生成循环测试：**\n能量生成循环在模型中代表一种“免费午餐”，即能量（通常以ATP形式）可以无中生有地产生。这在生物学上是不现实的，并表明网络定义存在错误。问题为此类循环提供了一个特定的、基于LP的操作性测试。我们通过将所有交换反应的通量边界设置为零（对所有 $j \\in E$，$v_j=0$）来关闭网络与环境的任何物质交换。然后，我们尝试最大化一个模拟ATP消耗的合成反应的通量 $v_a$。\n\nLP公式为：\n$$ \\max_{v} v_a \\quad \\text{subject to} \\quad \\begin{cases} S_{\\text{aug}} v = 0 \\\\ l'_{\\text{aug}} \\le v \\le u'_{\\text{aug}} \\end{cases} $$\n其中边界 $l'_{\\text{aug}}$ 和 $u'_{\\text{aug}}$ 与 $l_{\\text{aug}}$ 和 $u_{\\text{aug}}$ 相同，只是对于每个交换反应索引 $j \\in E$，$l'_{j} = u'_{j} = 0$。如果得到的最优 $v_a$ 值严格大于一个小的数值容差（给定为 $10^{-9}$），则意味着网络可以在没有外部输入的情况下自发产生能量。这样的网络是无效的，相应的候选子集被拒绝。\n\n**2. 生物质生产测试：**\n如果网络通过了循环测试，我们接着检查它是否已被“修复”，即是否能够产生生物质。这是一个标准的通量平衡分析（FBA）问题。我们使用原始的通量边界，包括交换反应的非零摄取速率，并最大化生物质反应的通量 $v_b$。\n\nLP公式为：\n$$ \\max_{v} v_b \\quad \\text{subject to} \\quad \\begin{cases} S_{\\text{aug}} v = 0 \\\\ l_{\\text{aug}} \\le v \\le u_{\\text{aug}} \\end{cases} $$\n如果最优 $v_b$ 值严格大于容差 $10^{-9}$，则网络是功能性的。因此，当前的候选子集是一个有效的解决方案。由于我们是按最小性和字典序的顺序进行迭代的，这个第一个有效的子集就是所期望的答案。\n\n整个算法通过迭代由 `itertools.combinations` 生成的候选子集来实现。对于每个子集，使用 `scipy.optimize.linprog` 构建并求解两个LP问题。如果为某个测试用例找到了解，则对该测试用例的搜索终止，算法继续处理下一个。如果在对某个测试用例的搜索完成时没有找到任何有效的子集，则其解为空集。此过程独立应用于所提供套件中的每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the metabolic gap-filling problem for a suite of test cases.\n    \"\"\"\n    TOL = 1e-9\n\n    # Metabolite order for all tests: (A, B, ATP, ADP, Pi)\n    # m = 5\n    m = 5\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        {\n            \"s_base\": np.array([\n                [-1, 0, 0],   # A\n                [0, -1, 0],   # B\n                [0, -1, -1],  # ATP\n                [0, 1, 1],    # ADP\n                [0, 1, 1]     # Pi\n            ]),\n            \"l_base\": np.array([-10, 0, 0]),\n            \"u_base\": np.array([1000, 1000, 1000]),\n            \"candidates\": [\n                {\"s\": np.array([-1, 1, 0, 0, 0]), \"l\": 0, \"u\": 1000},  # c0\n                {\"s\": np.array([0, 0, 1, -1, -1]), \"l\": 0, \"u\": 1000},  # c1\n                {\"s\": np.array([-1, 1, 1, -1, -1]), \"l\": 0, \"u\": 1000}    # c2\n            ],\n            \"exchange_indices\": {0},\n            \"biomass_idx\": 1,\n            \"atp_drain_idx\": 2\n        },\n        # Test 2\n        {\n            \"s_base\": np.array([\n                [-1, -1, 0, 0],  # A\n                [0, 1, -1, 0],   # B\n                [0, 0, -1, -1],  # ATP\n                [0, 0, 1, 1],    # ADP\n                [0, 0, 1, 1]     # Pi\n            ]),\n            \"l_base\": np.array([-10, 0, 0, 0]),\n            \"u_base\": np.array([1000, 1000, 1000, 1000]),\n            \"candidates\": [\n                {\"s\": np.array([0, 0, 1, -1, -1]), \"l\": 0, \"u\": 1000},  # c0\n                {\"s\": np.array([-1, 0, 1, -1, -1]), \"l\": 0, \"u\": 1000},  # c1\n                {\"s\": np.array([-1, 1, 1, -1, -1]), \"l\": 0, \"u\": 1000}    # c2\n            ],\n            \"exchange_indices\": {0},\n            \"biomass_idx\": 2,\n            \"atp_drain_idx\": 3\n        },\n        # Test 3\n        {\n            \"s_base\": np.array([\n                [-1, -1, 0, 0],  # A\n                [0, 0, -1, 0],   # B\n                [0, 1, -1, -1],  # ATP\n                [0, -1, 1, 1],   # ADP\n                [0, -1, 1, 1]    # Pi\n            ]),\n            \"l_base\": np.array([-2, 0, 0, 0]),\n            \"u_base\": np.array([1000, 1000, 1000, 1000]),\n            \"candidates\": [\n                {\"s\": np.array([-1, 1, 0, 0, 0]), \"l\": 0, \"u\": 1000},  # c0\n                {\"s\": np.array([-2, 1, 0, 0, 0]), \"l\": 0, \"u\": 1000},  # c1\n                {\"s\": np.array([0, 0, 1, -1, -1]), \"l\": 0, \"u\": 1000}    # c2\n            ],\n            \"exchange_indices\": {0},\n            \"biomass_idx\": 2,\n            \"atp_drain_idx\": 3\n        }\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        s_base = case[\"s_base\"]\n        l_base = case[\"l_base\"]\n        u_base = case[\"u_base\"]\n        candidates = case[\"candidates\"]\n        exchange_indices = case[\"exchange_indices\"]\n        biomass_idx = case[\"biomass_idx\"]\n        atp_drain_idx = case[\"atp_drain_idx\"]\n\n        n_base = s_base.shape[1]\n        n_candidates = len(candidates)\n        b_eq = np.zeros(m)\n        solution_found = False\n        \n        for k in range(n_candidates + 1):\n            if solution_found:\n                break\n            # Iterate through subsets of size k in lexicographical order\n            for subset_indices in itertools.combinations(range(n_candidates), k):\n                # 1. Construct the augmented network\n                s_aug = s_base\n                l_aug = list(l_base)\n                u_aug = list(u_base)\n\n                if subset_indices:\n                    s_to_add = np.array([candidates[i][\"s\"] for i in subset_indices]).T\n                    s_aug = np.hstack((s_base, s_to_add))\n                    l_to_add = [candidates[i][\"l\"] for i in subset_indices]\n                    u_to_add = [candidates[i][\"u\"] for i in subset_indices]\n                    l_aug.extend(l_to_add)\n                    u_aug.extend(u_to_add)\n                \n                n_aug = s_aug.shape[1]\n                \n                # 2. Test for energy-generating cycles\n                c_atp = np.zeros(n_aug)\n                c_atp[atp_drain_idx] = -1  # Maximize ATP drain flux\n                \n                # Close exchanges for cycle test\n                bounds_cycle_test = list(zip(l_aug, u_aug))\n                for ex_idx in exchange_indices:\n                    bounds_cycle_test[ex_idx] = (0, 0)\n                \n                res_cycle = linprog(c=c_atp, A_eq=s_aug, b_eq=b_eq, bounds=bounds_cycle_test, method='highs')\n                \n                max_atp_flux = -res_cycle.fun if res_cycle.success else 0\n                \n                if max_atp_flux  TOL:\n                    continue  # Cycle detected, this subset is invalid\n\n                # 3. Test for biomass production\n                c_biomass = np.zeros(n_aug)\n                c_biomass[biomass_idx] = -1 # Maximize biomass flux\n\n                bounds_biomass_test = list(zip(l_aug, u_aug))\n\n                res_biomass = linprog(c=c_biomass, A_eq=s_aug, b_eq=b_eq, bounds=bounds_biomass_test, method='highs')\n\n                max_biomass_flux = -res_biomass.fun if res_biomass.success else 0\n\n                if max_biomass_flux  TOL:\n                    final_results.append(list(subset_indices))\n                    solution_found = True\n                    break\n\n        if not solution_found:\n            final_results.append([])\n\n    # Final print statement in the exact required format.\n    # The str(final_results).replace(\" \", \"\") format ensures compliance with the\n    # example structure specified in the problem `[[2],[1],[0]]`.\n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3316760"}]}