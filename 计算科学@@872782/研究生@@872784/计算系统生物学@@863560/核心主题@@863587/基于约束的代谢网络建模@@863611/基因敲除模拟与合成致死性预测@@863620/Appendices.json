{"hands_on_practices": [{"introduction": "掌握任何计算方法的第一步是实现其核心算法。本练习将指导您通过通量平衡分析（FBA）从头开始构建一个单基因必要性预测流程。通过将布尔基因-蛋白质-反应（GPR）规则与线性规划相结合，您将学习如何模拟基因敲除对代谢网络的影响，并根据对细胞生长目标的预测影响来确定哪些基因是必不可少的。[@problem_id:3313310]", "problem": "考虑使用通量平衡分析（Flux Balance Analysis, FBA）计算单基因必需性的问题。通量平衡分析（FBA）定义在一个代谢网络上，该网络具有化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$、通量向量 $v \\in \\mathbb{R}^{n}$、稳态质量平衡约束 $S v = 0$ 以及反应界限 $l \\le v \\le u$，其中 $l \\in \\mathbb{R}^{n}$ 且 $u \\in \\mathbb{R}^{n}$。通过最大化一个线性目标 $c^{\\top} v$ 来表示生长，其中 $c \\in \\mathbb{R}^{n}$。基因与反应的关联由基因-蛋白质-反应规则表示，使用析取范式（即“与”的“或”）的布尔逻辑。每个反应 $i$ 都有一个相关规则 $\\mathcal{R}_i = \\bigvee_{k} \\bigwedge_{g \\in C_{i,k}} g$，其中 $C_{i,k}$ 是基因索引的子句；一个反应是活跃的，当且仅当至少有一个子句被存在的基因完全满足。单基因敲除会移除一个基因，那些规则因此变得不满足的反应必须通过设置 $l_i = u_i = 0$ 来强制其界限为 $v_i = 0$。一个基因被定义为必需的，当且仅当在 $S v = 0$ 和 $l \\le v \\le u$ 条件下的野生型最优目标 $z_{\\mathrm{WT}} = \\max_{v} c^{\\top} v$ 至少为一个给定的阈值 $\\epsilon$，并且在相同约束下但对已删除基因实施规则后计算出的敲除型最优目标 $z_{\\mathrm{KO}}^{(g)}$ 严格小于 $\\epsilon$。所有数值比较必须使用实数，并且必须严格按照所述方式实现。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n- 对于每个给定的测试用例，通过求解线性规划 $\\max_{v} c^{\\top} v$（约束条件为 $S v = 0$ 和 $l \\le v \\le u$）来计算 $z_{\\mathrm{WT}}$。\n- 对于每个基因索引 $g \\in \\{0, 1, \\dots, G-1\\}$，通过对反应规则实施基因敲除（对于那些在基因 $g$ 敲除后规则不满意的反应 $i$，设置 $v_i = 0$），并重新求解线性规划，来计算 $z_{\\mathrm{KO}}^{(g)}$。\n- 确定测试用例的必需基因集合，即那些满足 $z_{\\mathrm{WT}} \\ge \\epsilon$ 和 $z_{\\mathrm{KO}}^{(g)}  \\epsilon$ 的基因索引 $g$。\n- 生成单行输出，包含所有测试用例的结果，格式为一个方括号括起来的逗号分隔列表，其中每个元素是代表相应测试用例的必需基因索引（按升序排列）的整数列表（例如，$[\\,[0,2],\\,[1]\\,]$）。\n\n使用以下纯数学术语表示的测试套件。在每种情况下，均使用指定的目标向量 $c$ 和界限 $(l, u)$。除非另有说明，所有反应都是正向不可逆的。通量单位是任意的，不影响逻辑判定；无需报告任何物理单位。\n\n测试用例 1（包含同工酶的顺利路径）：\n- 代谢物：$m = 2$，标记为 $A$ 和 $B$；反应：$n = 3$，标记为 $0, 1, 2$。\n- 化学计量矩阵：\n$$\nS = \n\\begin{bmatrix}\n1  -1  0 \\\\\n0  1  -1\n\\end{bmatrix}.\n$$\n- 界限：\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nu = \\begin{bmatrix} 10 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n$$\n- 目标：\n$$\nc = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}.\n$$\n- 基因数量：$G = 3$，索引为 $0, 1, 2$。\n- 反应规则：\n  - 反应 0：无基因规则（始终活跃）。\n  - 反应 1：$(0) \\lor (1)$。\n  - 反应 2：$(2)$。\n- 阈值：$\\epsilon = 10^{-6}$。\n\n测试用例 2（具有复杂需求的边界情况）：\n- 与测试用例 1 相同的 $S$、$c$ 和 $l, u$。\n- 基因数量：$G = 3$，索引为 $0, 1, 2$。\n- 反应规则：\n  - 反应 0：无基因规则（始终活跃）。\n  - 反应 1：$(0 \\land 1)$。\n  - 反应 2：$(2)$。\n- 阈值：$\\epsilon = 10^{-6}$。\n\n测试用例 3（野生型零生长和未映射基因的边缘情况）：\n- 化学计量矩阵：\n$$\nS = \n\\begin{bmatrix}\n1  -1  0 \\\\\n0  1  -1\n\\end{bmatrix}.\n$$\n- 界限：\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nu = \\begin{bmatrix} 0 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n$$\n- 目标：\n$$\nc = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}.\n$$\n- 基因数量：$G = 4$，索引为 $0, 1, 2, 3$。\n- 反应规则：\n  - 反应 0：无基因规则（始终活跃）。\n  - 反应 1：$(0) \\lor (1)$。\n  - 反应 2：$(2)$。\n- 阈值：$\\epsilon = 10^{-6}$。\n\n测试用例 4（数值阈值边界）：\n- 化学计量矩阵：\n$$\nS = \n\\begin{bmatrix}\n1  -1  0 \\\\\n0  1  -1\n\\end{bmatrix}.\n$$\n- 界限：\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\quad\nu = \\begin{bmatrix} 10^{-6} \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n$$\n- 目标：\n$$\nc = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}.\n$$\n- 基因数量：$G = 3$，索引为 $0, 1, 2$。\n- 反应规则：\n  - 反应 0：无基因规则（始终活跃）。\n  - 反应 1：$(0) \\lor (1)$。\n  - 反应 2：$(2)$。\n- 阈值：$\\epsilon = 10^{-6}$。\n\n你的程序必须构建并求解每个线性规划，通过将那些基因规则变得不满足的反应的界限归零来实施基因敲除，使用所述标准确定必需基因，并以 $[\\text{case}_1,\\text{case}_2,\\text{case}_3,\\text{case}_4]$ 的确切格式输出单行结果，其中每个 $\\text{case}_k$ 是一个 Python 风格的整数列表，表示测试用例 $k$ 的必需基因索引（按升序排列）。", "solution": "问题陈述经过仔细审查，被确定为有效。它在科学上根植于计算系统生物学的既定原则，特别是通量平衡分析（FBA）和代谢网络建模。该问题是良构的，为每个测试用例提供了所有必要的数学定义和数据（$S$、$l$、$u$、$c$、基因-蛋白质-反应规则以及必需性阈值 $\\epsilon$）。语言客观精确，没有模糊不清之处。任务是实现一个标准的计算机模拟基因必需性分析，这是一个可形式化和可验证的计算问题。\n\n该解决方案从第一性原理出发，始于通量平衡分析的数学公式。FBA 模拟代谢网络在稳态下的行为。FBA 的核心是一个线性规划（LP），旨在找到通过网络中所有反应的特定通量分布 $v$，以优化给定的细胞目标，例如生物质的产生。\n\nFBA 问题的一般形式是：\n$$\n\\begin{align*}\n\\text{maximize} \\quad  z = c^{\\top} v \\\\\n\\text{subject to} \\quad  S v = \\mathbf{0} \\\\\n l \\le v \\le u\n\\end{align*}\n$$\n其中：\n- $v \\in \\mathbb{R}^{n}$ 是网络中 $n$ 个反应的反应通量向量。\n- $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，表示 $m$ 种代谢物的质量平衡。\n- $c \\in \\mathbb{R}^{n}$ 是目标向量，定义了要最大化的通量的线性组合（例如，一个“生物质反应”）。\n- $l, u \\in \\mathbb{R}^{n}$ 分别是单个反应通量的下界和上界，由于热力学和酶容量限制而约束反应速率。\n- 约束 $S v = \\mathbf{0}$ 强制执行稳态假设，即对于每种代谢物，其总生产速率等于总消耗速率。\n\n基因与反应的关联由基因-蛋白质-反应（GPR）规则编码。问题将这些规则指定为析取范式（DNF），即“与”的“或”。一个反应 $i$ 被催化，从而可以承载通量，当且仅当其 GPR 规则 $\\mathcal{R}_i$ 的值为真。规则 $\\mathcal{R}_i = \\bigvee_{k} \\bigwedge_{g \\in C_{i,k}} g$ 为真，如果其至少一个“与”子句 $C_{i,k}$ 为真。一个子句为真，如果其中所有的基因 $g$ 都存在且功能正常。\n\n单基因敲除模拟涉及将特定基因 $g$ 指定为缺失。这可能导致某些 GPR 规则的计算结果为假。如果反应 $i$ 的规则 $\\mathcal{R}_i$ 变为假，则该反应被视为“被敲除”。这在模型中通过将该反应通量的界限设置为零来强制执行，即 $l_i = u_i = 0$，从而强制 $v_i = 0$。\n\n基因必需性的确定遵循一个精确的标准。一个基因 $g$ 是必需的，当且仅当满足两个条件：\n1. 野生型（WT）生物体的最优目标值 $z_{\\mathrm{WT}}$ 大于或等于一个生存能力阈值 $\\epsilon$，即 $z_{\\mathrm{WT}} \\ge \\epsilon$。\n2. 基因 $g$ 被删除的敲除型（KO）生物体的最优目标值 $z_{\\mathrm{KO}}^{(g)}$ 严格小于此阈值，即 $z_{\\mathrm{KO}}^{(g)}  \\epsilon$。\n\n为每个测试用例解决问题的算法如下：\n\n1.  **解析 GPR 规则**：将提供的布尔规则解析为适合计算的数据结构。一个列表的列表的列表是合适的，其中外层列表对应于反应，中间列表对应于“或”子句，内层列表对应于“与”连接的基因。对于没有规则的反应，使用一个特殊值（例如，`None`）。\n2.  **求解野生型生长**：使用原始界限（$l, u$）构建并求解一个线性规划，以计算野生型最优目标 $z_{\\mathrm{WT}}$。这是通过数值 LP 求解器实现的。请注意，标准求解器如 `scipy.optimize.linprog` 执行最小化。为了最大化 $c^{\\top}v$，我们最小化 $-c^{\\top}v$，然后将得到的最优值取反。\n3.  **评估野生型生存能力**：将计算出的 $z_{\\mathrm{WT}}$ 与阈值 $\\epsilon$进行比较。如果 $z_{\\mathrm{WT}}  \\epsilon$，则认为该生物体从一开始就不具生存能力，根据定义，没有基因可以是必需的。此情况的结果是一个空集。\n4.  **执行单基因敲除分析**：如果 $z_{\\mathrm{WT}} \\ge \\epsilon$，我们继续测试每个基因。对于每个基因索引 $g \\in \\{0, 1, ..., G-1\\}$：\n    a. 从野生型界限 $(l, u)$ 初始化一组新的通量界限 $(l_{\\mathrm{KO}}, u_{\\mathrm{KO}})$。\n    b. 对于每个反应 $i$，在基因 $g$ 缺失的条件下评估其 GPR 规则 $\\mathcal{R}_i$。\n    c. 如果 $\\mathcal{R}_i$ 的计算结果为假，则通过将其界限设置为零来敲除该反应：$l_{\\mathrm{KO}, i} = 0$ 和 $u_{\\mathrm{KO}, i} = 0$。\n    d. 使用这些修改后的界限求解一个新的线性规划，以计算敲除型目标值 $z_{\\mathrm{KO}}^{(g)}$。\n    e. 应用必需性标准：如果 $z_{\\mathrm{KO}}^{(g)}  \\epsilon$，则将基因 $g$ 添加到当前测试用例的必需基因列表中。\n5.  **汇总和格式化结果**：遍历所有基因后，将必需基因索引列表按升序排序。对所有测试用例重复此过程。最终输出是一个格式化的字符串，包含每个用例的必需基因列表。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves for essential genes in a series of metabolic models\n    using Flux Balance Analysis (FBA).\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: happy path with isoenzymes\n        {\n            \"S\": np.array([[1, -1, 0], [0, 1, -1]], dtype=np.float64),\n            \"l\": np.array([0, 0, 0], dtype=np.float64),\n            \"u\": np.array([10, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 1], dtype=np.float64),\n            \"G\": 3,\n            \"gpr_rules\": [None, [[0], [1]], [[2]]],\n            \"epsilon\": 1e-6,\n        },\n        # Test Case 2: boundary with complex requirement\n        {\n            \"S\": np.array([[1, -1, 0], [0, 1, -1]], dtype=np.float64),\n            \"l\": np.array([0, 0, 0], dtype=np.float64),\n            \"u\": np.array([10, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 1], dtype=np.float64),\n            \"G\": 3,\n            \"gpr_rules\": [None, [[0, 1]], [[2]]],\n            \"epsilon\": 1e-6,\n        },\n        # Test Case 3: edge case with zero wild-type growth and an unmapped gene\n        {\n            \"S\": np.array([[1, -1, 0], [0, 1, -1]], dtype=np.float64),\n            \"l\": np.array([0, 0, 0], dtype=np.float64),\n            \"u\": np.array([0, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 1], dtype=np.float64),\n            \"G\": 4,\n            \"gpr_rules\": [None, [[0], [1]], [[2]]],\n            \"epsilon\": 1e-6,\n        },\n        # Test Case 4: numerical threshold boundary\n        {\n            \"S\": np.array([[1, -1, 0], [0, 1, -1]], dtype=np.float64),\n            \"l\": np.array([0, 0, 0], dtype=np.float64),\n            \"u\": np.array([1e-6, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 1], dtype=np.float64),\n            \"G\": 3,\n            \"gpr_rules\": [None, [[0], [1]], [[2]]],\n            \"epsilon\": 1e-6,\n        },\n    ]\n\n    all_results = []\n\n    def run_fba(c_obj, S, l_bounds, u_bounds):\n        \"\"\"Helper to run a single FBA linear program.\"\"\"\n        m, n = S.shape\n        bounds = list(zip(l_bounds, u_bounds))\n        # scipy.optimize.linprog minimizes, so we minimize -c to maximize c\n        res = linprog(-c_obj, A_eq=S, b_eq=np.zeros(m), bounds=bounds, method='highs')\n        \n        # If solver is successful, return the maximized objective. Otherwise, 0.\n        # The zero vector is always feasible in these problems, so infeasibility implies 0 growth.\n        # Unboundedness is not possible with finite upper bounds.\n        if res.success:\n            return -res.fun\n        return 0.0\n\n    def is_reaction_active(rule, deleted_gene_idx):\n        \"\"\"Evaluates a GPR rule given a deleted gene.\"\"\"\n        if rule is None:\n            return True  # Reaction always active if no rule\n        \n        # OR logic over clauses\n        for clause in rule:\n            is_clause_satisfied = True\n            # AND logic over genes in a clause\n            for gene in clause:\n                if gene == deleted_gene_idx:\n                    is_clause_satisfied = False\n                    break\n            if is_clause_satisfied:\n                return True # One satisfied clause is enough\n        \n        return False # No clause was satisfied\n\n    for case in test_cases:\n        S, l, u, c = case[\"S\"], case[\"l\"], case[\"u\"], case[\"c\"]\n        G, gpr_rules, epsilon = case[\"G\"], case[\"gpr_rules\"], case[\"epsilon\"]\n        \n        # 1. Compute wild-type growth\n        z_wt = run_fba(c, S, l, u)\n\n        # 2. Check for viability. If not viable, no genes are essential.\n        if z_wt  epsilon:\n            all_results.append([])\n            continue\n\n        # 3. Perform single gene deletion analysis\n        essential_genes = []\n        for g_idx in range(G):\n            # Create copies of bounds for the knockout simulation\n            l_ko, u_ko = l.copy(), u.copy()\n\n            # Apply GPR logic for the deleted gene\n            for i, rule in enumerate(gpr_rules):\n                if not is_reaction_active(rule, g_idx):\n                    # Knock out the reaction by setting bounds to 0\n                    l_ko[i] = 0.0\n                    u_ko[i] = 0.0\n            \n            # Compute knockout growth\n            z_ko = run_fba(c, S, l_ko, u_ko)\n\n            # 4. Check essentiality criterion\n            if z_ko  epsilon:\n                essential_genes.append(g_idx)\n        \n        essential_genes.sort()\n        all_results.append(essential_genes)\n\n    # 5. Format output\n    formatted_results = []\n    for res_list in all_results:\n        # Convert list to string like '[1,2,3]' and remove spaces\n        s = str(res_list).replace(\" \", \"\")\n        formatted_results.append(s)\n\n    # Join the strings with commas and enclose in brackets\n    output_str = f\"[{','.join(formatted_results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3313310"}, {"introduction": "在掌握了单基因敲除的基础上，我们可以进一步探索基因间的相互作用，这对于理解系统的鲁棒性和发现新的治疗靶点至关重要。本练习要求您将单基因删除框架扩展到双基因删除，以预测合成致死（Synthetic Lethality）相互作用。通过在一个简化的代谢网络中模拟成对基因的删除，您将亲身体验如何识别那些单独缺失不影响生存、但同时缺失则导致细胞死亡的关键基因对。[@problem_id:3313293]", "problem": "给定一个最小稳态代谢网络，要求您使用通量平衡分析 (FBA) 实现双基因敲除模拟，以确定合成致死。从第一性原理出发，FBA 假设胞内浓度处于准稳态，从而施加线性约束 $$S \\, v = 0,$$ 其中 $S$ 是化学计量矩阵，$v$ 是反应通量向量。反应通量受以下界限约束：$$\\ell \\le v \\le u,$$ 其中 $\\ell$ 和 $u$ 分别是下界和上界。细胞生长替代指标通过最大化一个线性目标函数来表示：$$\\max_{v} \\; c^\\top v.$$ 基因敲除通过基因-蛋白质-反应 (GPR) 映射传播至反应敲除：如果一个反应所需的基因被敲除，相应反应的通量界限将被设为零。存活性定义为最优目标值是否至少达到一个阈值；一对基因的合成致死意味着每个单基因敲除是存活的，而双基因敲除则不存活。\n\n网络定义：\n- 代谢物：胞内葡萄糖 $G$、中间代谢物 $X$ 和中间代谢物 $Y$。\n- 反应：\n    - $r_1$：葡萄糖摄取，表示为外部来源到内部 $G$。\n    - $r_2$：$G \\rightarrow X$。\n    - $r_3$：$G \\rightarrow Y$。\n    - $r_4$：$X + Y \\rightarrow$ 生物质流出。\n    - $r_5$：$G \\rightarrow$ 生物质流出。\n- 化学计量矩阵 $S \\in \\mathbb{R}^{3 \\times 5}$，代谢物行按 $(G, X, Y)$ 顺序排列，反应列按 $(r_1, r_2, r_3, r_4, r_5)$ 顺序排列：\n$$\nS =\n\\begin{bmatrix}\n+1  -1  -1  0  -1 \\\\\n0  +1  0  -1  0 \\\\\n0  0  +1  -1  0 \\\\\n\\end{bmatrix}.\n$$\n- 目标函数是产生物质量的通量之和，即 $c = [0, 0, 0, 1, 1]^\\top$，因此目标值为 $v_4 + v_5$。\n- 界限：\n    - 所有反应都是不可逆的，其下界 $\\ell_i = 0$ (对于 $i \\in \\{1,2,3,4,5\\}$)。\n    - 葡萄糖摄取反应 $r_1$ 的上界为 $u_1 = U$，其中 $U$ 是一个非负常数（单位为毫摩尔/克干重/小时，缩写为 mmol/(gDW·h)）。\n    - 所有其他反应的上界为 $u_i = L$ (对于 $i \\in \\{2,3,4,5\\}$)，其中 $L$ 是一个大的有限常数（使用 $L = 10^6$）。\n- 基因-蛋白质-反应 (GPR) 映射：\n    - $r_2$ 需要基因 $gA$。\n    - $r_3$ 需要基因 $gB$。\n    - $r_4$ 需要基因 $gC$。\n    - $r_5$ 需要基因 $gD$。\n    - 在此设置中，$r_1$（摄取）被视为受环境限制，而非受基因限制。\n- 基因敲除规则：敲除基因 $g$ 会使其 GPR 所需的每个反应 $r_j$ 的界限 $u_j = \\ell_j = 0$，而其他界限保持不变。\n- 存活性判据：给定阈值 $\\tau \\ge 0$ (单位为 mmol/(gDW·h))，如果最优目标值满足 $v_4^\\star + v_5^\\star \\ge \\tau$，则菌株是存活的。\n- 一对基因 $(g_p, g_q)$ 的合成致死判据：在相同的 $(U, \\tau)$ 条件下进行评估，野生型是存活的，两个单基因敲除都是存活的，而双基因敲除是不存活的。\n\n任务：\n- 实现一个程序，对每个测试用例执行以下操作：\n    - 进行野生型 FBA 计算最优目标值。\n    - 分别对 $g_p$ 和 $g_q$ 进行单基因敲除，并对每个敲除进行 FBA。\n    - 对 $(g_p, g_q)$ 进行双基因敲除并进行 FBA。\n    - 返回一个布尔值，指示是否如上文所定义的那样存在合成致死。\n\n所有通量和阈值的单位均为 mmol/(gDW·h)；不涉及其他单位。不使用角度。最终输出为布尔值。\n\n测试套件：\n- 案例 1：$(gA, gD)$，其中 $U = 10$ 且 $\\tau = 1.0$。\n- 案例 2：$(gA, gB)$，其中 $U = 10$ 且 $\\tau = 0.5$。\n- 案例 3：$(gB, gD)$，其中 $U = 8$ 且 $\\tau = 4.0$。\n- 案例 4：$(gA, gD)$，其中 $U = 0$ 且 $\\tau = 0.0$。\n- 案例 5：$(gC, gD)$，其中 $U = 6$ 且 $\\tau = 2.5$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，$[{\\text{True}},{\\text{False}},\\dots]$），不含空格。", "solution": "我们从稳态质量平衡假设开始，即在所关注的时间尺度上，胞内代谢物浓度近似恒定，这产生了线性约束 $$S \\, v = 0,$$ 其中 $S$ 是化学计量矩阵，$v$ 是反应通量向量。通量平衡分析 (FBA) 提出了一个线性规划问题：$$\\max_{v} \\; c^\\top v \\quad \\text{subject to} \\quad S v = 0, \\quad \\ell \\le v \\le u.$$ 这依赖于一个被广泛使用且经过充分检验的观察：在稳态下，代谢通量会重新分配以在物理化学约束下最大化细胞目标。\n\n在我们的网络中，代谢物是 $G$、$X$ 和 $Y$，反应按 $(r_1, r_2, r_3, r_4, r_5)$ 顺序排列，其化学计量为\n$$\nS =\n\\begin{bmatrix}\n+1  -1  -1  0  -1 \\\\\n0  +1  0  -1  0 \\\\\n0  0  +1  -1  0 \\\\\n\\end{bmatrix}.\n$$\n约束展开为：\n- 对于代谢物 $G$：$$+1 \\cdot v_1 - 1 \\cdot v_2 - 1 \\cdot v_3 - 1 \\cdot v_5 = 0.$$\n- 对于代谢物 $X$：$$+1 \\cdot v_2 - 1 \\cdot v_4 = 0 \\;\\Rightarrow\\; v_4 = v_2.$$\n- 对于代谢物 $Y$：$$+1 \\cdot v_3 - 1 \\cdot v_4 = 0 \\;\\Rightarrow\\; v_4 = v_3.$$\n\n因此，在稳态下，通过 $r_4$ 通向生物质的 $X$ 和 $Y$ 通路需要相等的通量 $v_2 = v_3 = v_4$，而 $G$ 则由 $v_1 = v_2 + v_3 + v_5 = 2 v_4 + v_5$ 来平衡。所有反应都是不可逆的，下界 $\\ell_i = 0$。摄取反应的上界为 $u_1 = U$ (mmol/(gDW·h))，内部反应有较大的上界 $u_i = L$ (对于 $i \\in \\{2,3,4,5\\}$)，其中 $L = 10^6$。目标是最大化 $$c^\\top v = v_4 + v_5.$$\n\n基因通过基因-蛋白质-反应 (GPR) 映射调控反应：$gA \\rightarrow r_2$，$gB \\rightarrow r_3$，$gC \\rightarrow r_4$，$gD \\rightarrow r_5$。敲除一个基因会将相应反应的界限设为零（$\\ell_j = u_j = 0$），从而有效地将该反应从可行集中移除。存活性定义为最优目标值是否满足 $v_4^\\star + v_5^\\star \\ge \\tau,$ 其中 $\\tau$ 是一个给定的阈值 (mmol/(gDW·h))。$(g_p, g_q)$ 的合成致死成立，条件是在相同的 $(U, \\tau)$ 下评估时，野生型是存活的，两个单基因敲除都是存活的，而双基因敲除是不存活的。\n\n算法设计：\n- 对每种情况（野生型、单基因敲除、双基因敲除）建立线性规划模型，使用相同的化学计量约束和界限，基因敲除会对需要被敲除基因的反应应用零界限。\n- 使用线性规划求解器最大化 $c^\\top v$。由于常见的求解器是最小化，我们等价地最小化 $-c^\\top v$。等式约束 $S v = 0$ 和界限 $\\ell \\le v \\le u$ 被强制执行。\n- 计算每种情况下的最优目标值 $z^\\star = v_4^\\star + v_5^\\star$，并与阈值 $\\tau$ 进行比较，以确定存活性和合成致死。\n\n对网络结构的推理可以提供直觉理解：\n- 当所有反应都存在时，通过 $r_5$ 的 $G \\rightarrow$ 生物质路径每单位目标消耗 $1$ 单位 $G$，而通过 $r_4$ 的 $X + Y \\rightarrow$ 生物质路径每单位目标需要 $2$ 单位 $G$（因为 $v_2 = v_3 = v_4$ 且每个都消耗 $1$ 单位 $G$）。因此，对于固定的摄取上限 $U$，最优解倾向于 $r_5$（直接路径），并产生 $z^\\star_{\\text{WT}} = U$。\n- 如果 $r_5$ 被删除（通过敲除 $gD$），唯一的生长路径是通过 $r_4$，这需要每单位生长消耗 $2$ 单位 $G$，从而得到 $2 v_4 \\le U \\;\\Rightarrow\\; z^\\star_{\\text{single }gD} = v_4^\\star \\le \\frac{U}{2}$。 在内部界限很大的情况下，最优选择是 $v_4^\\star = \\frac{U}{2}$，所以 $z^\\star_{\\text{single }gD} = \\frac{U}{2}$。\n- 如果 $r_2$ 或 $r_3$ 被删除（通过敲除 $gA$ 或 $gB$），那么根据化学计量 $v_4 = 0$，如果 $r_5$ 存在，唯一的生长路径是通过它，得到 $z^\\star_{\\text{single }gA} = U$ 和 $z^\\star_{\\text{single }gB} = U$。\n- 对于双基因敲除：\n    - $(gA, gD)$ 敲除 $r_2$ 和 $r_5$，剩下 $r_3$ 和 $r_4$，但由于 $v_2 = 0$，等式 $v_4 = v_2$ 意味着 $v_4 = 0$。又因为 $r_5$ 被删除，没有其他选择，所以 $z^\\star_{\\text{double }(gA,gD)} = 0$。\n    - $(gB, gD)$ 与 $(gA, gD)$ 对称，同样得到 $z^\\star_{\\text{double }(gB,gD)} = 0$。\n    - $(gA, gB)$ 敲除 $r_2$ 和 $r_3$，所以 $v_4 = 0$，但 $r_5$ 仍然存在，得到 $z^\\star_{\\text{double }(gA,gB)} = U$。\n    - $(gC, gD)$ 敲除两个生物质反应 $r_4$ 和 $r_5$，得到 $z^\\star_{\\text{double }(gC,gD)} = 0$。\n\n应用阈值：\n- 案例 1：$(gA, gD)$，$U = 10$，$\\tau = 1.0$。\n    - 野生型：$10 \\ge 1.0$ 存活。\n    - 单基因 $gA$ 敲除：$10 \\ge 1.0$ 存活；单基因 $gD$ 敲除：$5 \\ge 1.0$ 存活。\n    - 双基因敲除：$0  1.0$ 不存活。\n    - 合成致死：True。\n- 案例 2：$(gA, gB)$，$U = 10$，$\\tau = 0.5$。\n    - 野生型：$10 \\ge 0.5$ 存活。\n    - 单基因 $gA$ 敲除：$10 \\ge 0.5$ 存活；单基因 $gB$ 敲除：$10 \\ge 0.5$ 存活。\n    - 双基因敲除：$10 \\ge 0.5$ 存活。\n    - 合成致死：False。\n- 案例 3：$(gB, gD)$，$U = 8$，$\\tau = 4.0$。\n    - 野生型：$8 \\ge 4.0$ 存活。\n    - 单基因 $gB$ 敲除：$8 \\ge 4.0$ 存活；单基因 $gD$ 敲除：$\\frac{8}{2} = 4.0 \\ge 4.0$ 在等于的情况下存活。\n    - 双基因敲除：$0  4.0$ 不存活。\n    - 合成致死：True。\n- 案例 4：$(gA, gD)$，$U = 0$，$\\tau = 0.0$。\n    - 野生型：$0 \\ge 0.0$ 在等于的情况下存活。\n    - 单基因 $gA$ 敲除：$0 \\ge 0.0$ 存活；单基因 $gD$ 敲除：$0 \\ge 0.0$ 存活。\n    - 双基因敲除：$0 \\ge 0.0$ 存活。\n    - 合成致死：False。\n- 案例 5：$(gC, gD)$，$U = 6$，$\\tau = 2.5$。\n    - 野生型：$6 \\ge 2.5$ 存活。\n    - 单基因 $gC$ 敲除：$6 \\ge 2.5$ 存活；单基因 $gD$ 敲除：$3 \\ge 2.5$ 存活。\n    - 双基因敲除：$0  2.5$ 不存活。\n    - 合成致死：True。\n\n因此，预期的布尔值结果按顺序为 $[{\\text{True}},{\\text{False}},{\\text{True}},{\\text{False}},{\\text{True}}]$。该程序为了一般性而实现了线性规划，并通过对每个案例求解优化问题并应用合成致死判据来重现这些结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef fba_growth(U, deleted_genes):\n    \"\"\"\n    Compute the maximal growth (objective value v4 + v5) for the given uptake bound U\n    and a set of deleted genes under steady-state FBA with linear constraints.\n    \"\"\"\n    # Stoichiometric matrix S for metabolites (G, X, Y) and reactions (r1..r5)\n    S = np.array([\n        [ 1.0, -1.0, -1.0,  0.0, -1.0],  # G balance\n        [ 0.0,  1.0,  0.0, -1.0,  0.0],  # X balance\n        [ 0.0,  0.0,  1.0, -1.0,  0.0],  # Y balance\n    ])\n\n    # Objective c: maximize v4 + v5 - in linprog, minimize -c^T v\n    c = np.array([0.0, 0.0, 0.0, 1.0, 1.0])\n    c_min = -c  # since linprog minimizes\n\n    # Large upper bound for internal reactions\n    L = 1e6\n\n    # Base bounds: all irreversible, r1 upper bound = U\n    lower_bounds = np.zeros(5, dtype=float)\n    upper_bounds = np.array([U, L, L, L, L], dtype=float)\n\n    # Gene-to-reaction mapping\n    gene_to_reactions = {\n        'gA': [1],  # r2\n        'gB': [2],  # r3\n        'gC': [3],  # r4\n        'gD': [4],  # r5\n        # r1 uptake is environmentally constrained (no gene mapping)\n    }\n\n    # Apply gene deletions: set bounds of mapped reactions to zero\n    for g in deleted_genes:\n        for rxn_idx in gene_to_reactions.get(g, []):\n            lower_bounds[rxn_idx] = 0.0\n            upper_bounds[rxn_idx] = 0.0\n\n    bounds = list(zip(lower_bounds.tolist(), upper_bounds.tolist()))\n\n    # Equality constraints Sv = 0\n    A_eq = S\n    b_eq = np.zeros(S.shape[0], dtype=float)\n\n    # Solve LP\n    res = linprog(c=c_min, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    if not res.success:\n        # If infeasible or solver failed, return 0.0 growth (conservative)\n        return 0.0\n\n    v = res.x\n    growth = float(v[3] + v[4])  # v4 + v5\n    # Numerical safety: tiny negative due to tolerance - clip to 0\n    if growth  0 and growth > -1e-9:\n        growth = 0.0\n    return growth\n\ndef is_synthetic_lethal(g1, g2, U, tau):\n    \"\"\"\n    Determine synthetic lethality for a gene pair (g1, g2) under (U, tau):\n    WT viable, both singles viable, double non-viable.\n    \"\"\"\n    wt_growth = fba_growth(U, deleted_genes=[])\n    g1_growth = fba_growth(U, deleted_genes=[g1])\n    g2_growth = fba_growth(U, deleted_genes=[g2])\n    double_growth = fba_growth(U, deleted_genes=[g1, g2])\n\n    wt_ok = wt_growth >= tau\n    singles_ok = (g1_growth >= tau) and (g2_growth >= tau)\n    double_fail = double_growth  tau\n\n    return wt_ok and singles_ok and double_fail\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (gene1, gene2, U, tau)\n    test_cases = [\n        ('gA', 'gD', 10.0, 1.0),   # Case 1\n        ('gA', 'gB', 10.0, 0.5),   # Case 2\n        ('gB', 'gD', 8.0, 4.0),    # Case 3\n        ('gA', 'gD', 0.0, 0.0),    # Case 4\n        ('gC', 'gD', 6.0, 2.5),    # Case 5\n    ]\n\n    results = []\n    for g1, g2, U, tau in test_cases:\n        result = is_synthetic_lethal(g1, g2, U, tau)\n        results.append(result)\n\n    # Final print statement in the exact required format: no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3313293"}, {"introduction": "一个严谨的计算生物学家不仅要会使用模型，更要能洞察其内在的局限性。本练习旨在揭示一个在基于约束的建模中常见的陷阱：替代最优解（alternative optima）。您将通过实现并比较两种合成致死预测方法——一种是严谨的FBA再优化方法，另一种是基于单一野生型解的朴素投影方法——来深入理解为何在每次基因扰动后重新优化是必不可少的。[@problem_id:3313299]", "problem": "要求您实现一个完整的、可运行的程序，该程序使用基于约束的模拟，通过生化网络的稳态线性优化来预测合成致死基因对。其基本原理是通量平衡分析（FBA）中使用的稳态质量平衡和边界约束线性规划。具体而言，考虑化学计量矩阵 $S \\in \\mathbb{R}^{m \\times n}$、通量向量 $v \\in \\mathbb{R}^n$、下界和上界向量 $l \\in \\mathbb{R}^n$ 和 $u \\in \\mathbb{R}^n$、目标系数向量 $c \\in \\mathbb{R}^n$ 以及基因到反应的映射。在准稳态假设（无细胞内积累）下，所有内部代谢物均满足质量平衡约束 $S v = 0$。可行通量空间由 $l \\le v \\le u$ 定义。生物量生产速率由线性目标 $c^\\top v$ 表示，对于给定的基因型和培养基，必须最大化该目标。基因删除被建模为一组反应通量约束 $v_j = 0$，其中 $j$ 是所有由被删除基因控制的反应。一对基因 $\\{g_i,g_j\\}$ 是合成致死当且仅当在指定培养基下同时满足以下三个条件：（i）野生型通量平衡分析得出 $\\max c^\\top v > \\varepsilon$，（ii）$\\{g_i\\}$ 和 $\\{g_j\\}$ 的单基因删除均得出 $\\max c^\\top v > \\varepsilon$，以及（iii）$\\{g_i,g_j\\}$ 的双基因删除得出 $\\max c^\\top v \\le \\varepsilon$。其中 $\\varepsilon = 10^{-9}$ 是一个小的生存能力阈值。您还必须实现一个朴素分类器，该分类器在删除后不进行重新优化：它首先计算一个最大化 $c^\\top v$ 的单一野生型最优通量向量 $v^\\star$，然后预测一对基因为致死，如果仅将 $v^\\star$ 中相应的反应通量置零得到的向量要么违反 $S v = 0$（超出小容差范围），要么其 $c^\\top v \\le \\varepsilon$。这种朴素方法旨在说明，依赖单一最优参考通量而非每次删除后重新优化，会导致备选最优解如何增加假阳性。\n\n您的程序必须实现正确的基于 FBA 的合成致死测试和基于朴素投影的测试，并将它们应用于以下测试套件。所有线性规划问题必须按规定精确求解；不得使用任何启发式捷径。角度不会出现。输出中不需要物理单位。所有结果必须是数值：布尔值、整数、浮点数或它们的列表，如下所述。\n\n测试套件：\n\n测试案例 1（具有备选最优解的平行途径）：\n\n- 内部代謝物：$G$、$P$。\n\n- 反应（$S$ 的列），索引为 $0,1,2,3,4$：\n  - 交换摄取 $r_0$：$\\varnothing \\rightarrow G$。\n  - 途径 1 $r_1$：$G \\rightarrow P$。\n  - 途径 2 $r_2$：$G \\rightarrow P$。\n  - 生物量流失 $r_3$：$P \\rightarrow \\varnothing$。\n  - 废物排泄 $r_4$：$G \\rightarrow \\varnothing$。\n\n- 化学计量矩阵 $S \\in \\mathbb{R}^{2 \\times 5}$，代谢物顺序为 $(G,P)$，反应顺序为 $(r_0,r_1,r_2,r_3,r_4)$：\n  $$\n  S = \\begin{bmatrix}\n  1  -1  -1  0  -1 \\\\\n  0  1  1  -1  0\n  \\end{bmatrix}.\n  $$\n\n- 边界 $l \\le v \\le u$：\n  $$\n  l = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n  u = \\begin{bmatrix} 10 \\\\ 10 \\\\ 4 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n  $$\n\n- 生物量的目标系数：\n  $$\n  c = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix}.\n  $$\n\n- 基因及其与反应的映射：\n  - $g_1 \\mapsto \\{r_1\\}$，\n  - $g_2 \\mapsto \\{r_2\\}$，\n  - $g_3 \\mapsto \\{r_3\\}$，\n  - $g_4 \\mapsto \\{r_4\\}$。\n\n- 待评估的基因对（为报告而索引）：索引 $0$：$(g_1,g_2)$，索引 $1$：$(g_1,g_4)$，索引 $2$：$(g_2,g_4)$。\n\n测试案例 2（无底物边界情况）：\n\n- 与测试案例 1 相同的 $S$、$c$、基因和基因对，但通过收紧 $r_0$ 的边界来禁用摄取：\n  $$\n  l = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n  u = \\begin{bmatrix} 0 \\\\ 10 \\\\ 4 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n  $$\n\n测试案例 3（孤儿基因和非合成致死）：\n\n- 内部代謝物：$A$、$P$。\n\n- 反应（$S$ 的列），索引为 $0,1,2,3$：\n  - 交换摄取 $r_0$：$\\varnothing \\rightarrow A$。\n  - 合成 $r_1$：$A \\rightarrow P$。\n  - 生物量流失 $r_2$：$P \\rightarrow \\varnothing$。\n  - 旁路流失 $r_3$：$A \\rightarrow \\varnothing$。\n\n- 化学计量矩阵 $S \\in \\mathbb{R}^{2 \\times 4}$，代谢物顺序为 $(A,P)$，反应顺序为 $(r_0,r_1,r_2,r_3)$：\n  $$\n  S = \\begin{bmatrix}\n  1  -1  0  -1 \\\\\n  0  1  -1  0\n  \\end{bmatrix}.\n  $$\n\n- 边界 $l \\le v \\le u$：\n  $$\n  l = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\n  u = \\begin{bmatrix} 5 \\\\ 5 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n  $$\n\n- 生物量的目标系数：\n  $$\n  c = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix}.\n  $$\n\n- 基因及其与反应的映射：\n  - $g_a \\mapsto \\{r_1\\}$，\n  - $g_b \\mapsto \\{r_2\\}$，\n  - $g_c \\mapsto \\{r_3\\}$，\n  - $g_{\\text{orph}}$ 不映射到任何反应（一个孤儿基因）。\n\n- 待评估的基因对（为报告而索引）：索引 $0$：$(g_a,g_{\\text{orph}})$，索引 $1$：$(g_c,g_{\\text{orph}})$，索引 $2$：$(g_a,g_c)$。\n\n算法要求：\n\n- 正确的 FBA 生存能力测试：对于任何基因型，求解线性规划问题\n  $$\n  \\max_{v \\in \\mathbb{R}^n}\\; c^\\top v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l \\le v \\le u,\\;\\; v_j = 0 \\;\\; \\forall j \\in \\mathcal{R}_{\\text{deleted}},\n  $$\n  其中 $\\mathcal{R}_{\\text{deleted}}$ 是由被删除基因控制的反应索引集合。一个基因型是可生存的当且仅当获得的最优值严格大于 $\\varepsilon = 10^{-9}$。\n\n- 合成致死性：一对基因 $\\{g_i,g_j\\}$ 是合成致死的当且仅当野生型是可生存的，两个单基因删除基因型都是可生存的，而双基因删除基因型根据上述标准是不可生存的。\n\n- 基于朴素投影的致死性测试：通过一次最大化 $c^\\top v$ 来计算一个单一的野生型最优通量 $v^\\star$。对于每一对 $\\{g_i,g_j\\}$，通过取 $v^\\star$ 并将所有 $k \\in \\mathcal{R}_{g_i} \\cup \\mathcal{R}_{g_j}$ 的分量 $v^\\star_k$ 置零，形成一个投影向量 $\\tilde v$。如果在朴素测试下，$\\|S \\tilde v\\|_\\infty > \\tau$ (其中 $\\tau = 10^{-9}$) 或 $c^\\top \\tilde v \\le \\varepsilon$，则将该对分类为致死。此测试 deliberately 忽略了重新优化，以揭示备选最优通量的作用。\n\n您的程序应为每个测试案例计算三个输出，按顺序排列：\n\n- 正确预测的合成致死基因对的整数计数（根据正确的基于 FBA 的定义）。\n\n- 朴素投影测试预测为致死的基因对的整数计数。\n\n- 假阳性对的索引列表（按升序排列），即被朴素测试预测为致死但根据正确测试并非合成致死的基因对。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个长度为 $3$ 的列表（每个测试案例一个条目）。每个条目本身必须是 $[\\text{count\\_true\\_SL}, \\text{count\\_naive\\_lethal}, \\text{sorted\\_false\\_positive\\_indices}]$ 形式的列表。整个输出必须打印为单个 Python 风格的列表字面量，例如：$[[\\cdot,\\cdot,[\\cdot]], [\\cdot,\\cdot,[\\cdot]], [\\cdot,\\cdot,[\\cdot]]]$。", "solution": "该问题要求实现两种不同的方法来预测代谢网络中的合成致死基因对，并随后在给定的测试套件上进行比较分析。第一种方法是基于通量平衡分析（FBA）的经典方法，该方法涉及为每个基因扰动重新优化网络的目标函数。第二种是基于朴素投影的方法，它依赖于单一的野生型最优通量分布，旨在揭示基于约束的建模中的常见陷阱。\n\n其基本原理是细胞内代谢物的准稳态假设，这在数学上表示为一个质量平衡约束。对于一个有 $m$ 个代谢物和 $n$ 个反应的代谢网络，该约束由线性系统给出：\n$$\nS v = 0\n$$\n其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$v \\in \\mathbb{R}^n$ 是反应通量向量。每个通量 $v_j$进一步受下界和上界 $l_j \\le v_j \\le u_j$ 的约束，这些边界由热力学和底物可用性决定。在此可行通量空间内，FBA 旨在找到一个通量向量 $v$，以最大化细胞目标函数，通常表示为通量的线性组合，$Z = c^\\top v$。因此，标准的 FBA 问题是一个线性规划（LP）问题：\n$$\n\\max_{v} \\quad c^\\top v \\\\\n\\text{subject to} \\quad S v = 0 \\\\\nl \\le v \\le u\n$$\n\n基因删除的模拟方法是，将与该基因相关的所有酶催化反应的通量约束为零。如果基因 $g$ 控制反应集合 $\\mathcal{R}_g$，则其删除会施加约束 $v_j = 0$ 对所有 $j \\in \\mathcal{R}_g$。这是通过将相应的下界和上界设置为零来实现的：$l_j = u_j = 0$。\n\n问题将一对基因 $\\{g_i, g_j\\}$ 定义为合成致死，当且仅当满足四个条件：\n1. 野生型（WT）生物体是可生存的：其最大目标值 $Z_{WT} > \\varepsilon$。\n2. $g_i$ 的单基因删除导致可生存的表型：$Z_{\\Delta g_i} > \\varepsilon$。\n3. $g_j$ 的单基因删除也导致可生存的表型：$Z_{\\Delta g_j} > \\varepsilon$。\n4. $g_i$ 和 $g_j$ 的双基因删除导致不可生存的表型：$Z_{\\Delta g_i \\Delta g_j} \\le \\varepsilon$。\n生存能力阈值为 $\\varepsilon = 10^{-9}$。这个“正确”的方法要求为每对基因求解四个独立的LP问题。\n\n相比之下，“朴素”的基于投影的方法设计上计算成本更低，但概念上有缺陷。其操作如下：\n1. 为野生型求解一次 FBA 问题，以获得*一个*最优通量向量 $v^\\star$。\n2. 对于给定的基因对 $\\{g_i, g_j\\}$，通过取 $v^\\star$ 并将由 $g_i$ 或 $g_j$ 控制的反应通量置零来构造一个投影通量向量 $\\tilde{v}$。因此，如果 $k \\in \\mathcal{R}_{g_i} \\cup \\mathcal{R}_{g_j}$，则 $\\tilde{v}_k = 0$，否则 $\\tilde{v}_k = v^\\star_k$。\n3. 如果这个投影 $\\tilde{v}$ 是无效的，则该基因对被分类为致死。无效的定义是，要么违反稳态质量平衡条件，$\\|S \\tilde{v}\\|_\\infty > \\tau$（容差为 $\\tau = 10^{-9}$），要么导致生物量生产速率低于生存能力阈值，$c^\\top \\tilde{v} \\le \\varepsilon$。\n\n朴素方法的缺陷源于野生型 FBA 问题中可能存在备选最优解。当多个通量分布产生相同的最大目标值时，求解器只返回其中一个 $v^\\star$。如果这个特定的 $v^\\star$ 恰好没有使用可以补偿基因删除的途径，那么朴素方法将因质量平衡违规而错误地预测致死性。正确的方法通过重新优化来避免这个问题，从而允许网络在扰动系统的可行空间中找到任何可能存在的补偿路径。\n\n算法的流程是首先定义一个函数 `solve_fba`，它接受模型参数（$c$, $S$, $l$, $u$）并使用 `scipy.optimize.linprog` 求解相应的 LP。由于 `linprog` 是最小化函数，我们向其提供负的目标向量 $-c$，然后将得到的最优值取反以获得最大值。\n\n对于每个测试案例：\n1. 计算野生型目标值 $Z_{WT}$ 和一个最优通量向量 $v^\\star$。如果 $Z_{WT} \\le \\varepsilon$，根据定义，没有基因对可以是合成致死的。\n2. 我们遍历要测试的每个基因对 $\\{g_i, g_j\\}$。\n3. 对于正确的 FBA 方法，我们通过调整通量边界并为每次删除调用 `solve_fba` 来模拟 $g_i$ 和 $g_j$ 的单基因删除以及 $\\{g_i, g_j\\}$ 的双基因删除。然后我们应用合成致死的四条件定义。\n4. 对于朴素方法，我们使用预先计算的 $v^\\star$。对于每对基因，我们创建投影向量 $\\tilde{v}$ 并检查质量平衡违规（$S\\tilde{v} \\neq 0$）或低目标值（$c^\\top\\tilde{v} \\le \\varepsilon$）。\n5. 如果一个基因对被朴素方法预测为致死，但根据正确的基于 FBA 的方法实际上不是合成致死的，则该对被识别为假阳性。\n6. 为每个测试案例收集真实合成致死的计数、朴素致死的计数以及假阳性的索引。\n\n**测试案例1分析**：该案例模拟了两个可以产生代谢物 $P$ 的平行途径（$r_1$ 和 $r_2$）。野生型最优生物量为10，可以通过任何满足 $v_1+v_2 = 10$（并遵守各自边界）的 $v_1$ 和 $v_2$ 组合实现。基因对 $(g_1, g_2)$ 是合成致死的，因为单独删除任一基因都是非致死的（另一条途径会补偿），但同时删除两者是致死的。其他基因对不是合成致死的。朴素方法的预测将取决于 LP 求解器找到的具体 $v^\\star$。如果求解器选择一个只使用一条途径的 $v^\\star$（例如，$v_1=10, v_2=0$），那么对此解决方案进行涉及另一途径基因（$g_2$）的删除投影可能不会导致违规，而涉及活性途径基因（$g_1$）的删除则很可能导致质量平衡错误，从而产生假阳性。\n\n**测试案例2分析**：摄取反应 $r_0$ 被禁用（$u_0=0$），因此没有底物可以进入系统。野生型唯一的可行解是零通量向量（$v=0$），使得生物量为0。由于野生型不可生存，没有基因对可以是合成致死的。然而，朴素方法从 $v^\\star=\\mathbf{0}$ 开始。任何投影 $\\tilde{v}$ 也将是 $\\mathbf{0}$，这满足质量平衡但目标值为0，即 $\\le \\varepsilon$。因此，朴素方法将错误地预测所有基因对都为致死。\n\n**测试案例3分析**：此案例包含一个线性途径和一个孤兒基因。野生型是可生存的。$g_a$（阻断通往生物量的主要途径）的单基因删除是致死的，因此任何涉及 $g_a$ 的基因对都不可能是合成致死的。删除 $g_{\\text{orph}}$ 没有效果。因此，在这种情况下没有合成致死对。朴素方法从唯一的最优解 $v^\\star = [5, 5, 5, 0]^\\top$ 开始，将对此向量进行投影以进行删除。通过设置 $\\tilde{v}_1=0$ 来删除 $g_a$ 将破坏质量平衡，导致对 $(g_a, g_{\\text{orph}})$ 和 $(g_a, g_c)$ 的假阳性预测。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the synthetic lethality analysis.\n    \"\"\"\n    \n    epsilon = 1e-9\n    tau = 1e-9\n\n    test_cases = [\n        # Test Case 1: parallel pathways with alternative optima\n        {\n            \"S\": np.array([\n                [1, -1, -1, 0, -1],\n                [0, 1, 1, -1, 0]\n            ], dtype=np.float64),\n            \"l\": np.array([0, 0, 0, 0, 0], dtype=np.float64),\n            \"u\": np.array([10, 10, 4, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 0, 1, 0], dtype=np.float64),\n            \"gene_map\": {\n                'g1': [1], 'g2': [2], 'g3': [3], 'g4': [4]\n            },\n            \"pairs\": [('g1', 'g2'), ('g1', 'g4'), ('g2', 'g4')]\n        },\n        # Test Case 2: no substrate boundary case\n        {\n            \"S\": np.array([\n                [1, -1, -1, 0, -1],\n                [0, 1, 1, -1, 0]\n            ], dtype=np.float64),\n            \"l\": np.array([0, 0, 0, 0, 0], dtype=np.float64),\n            \"u\": np.array([0, 10, 4, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 0, 1, 0], dtype=np.float64),\n            \"gene_map\": {\n                'g1': [1], 'g2': [2], 'g3': [3], 'g4': [4]\n            },\n            \"pairs\": [('g1', 'g2'), ('g1', 'g4'), ('g2', 'g4')]\n        },\n        # Test Case 3: orphan gene and non-synthetic lethals\n        {\n            \"S\": np.array([\n                [1, -1, 0, -1],\n                [0, 1, -1, 0]\n            ], dtype=np.float64),\n            \"l\": np.array([0, 0, 0, 0], dtype=np.float64),\n            \"u\": np.array([5, 5, 1000, 1000], dtype=np.float64),\n            \"c\": np.array([0, 0, 1, 0], dtype=np.float64),\n            \"gene_map\": {\n                'ga': [1], 'gb': [2], 'gc': [3], 'g_orph': []\n            },\n            \"pairs\": [('ga', 'g_orph'), ('gc', 'g_orph'), ('ga', 'gc')]\n        }\n    ]\n\n    all_results = []\n    for case_data in test_cases:\n        result = process_case(case_data, epsilon, tau)\n        all_results.append(result)\n        \n    # Format the output as a compact Python-style list literal string.\n    print(str(all_results).replace(\" \", \"\"))\n\ndef solve_fba(c, S, l, u):\n    \"\"\"\n    Solves the FBA linear program: max c^T v s.t. Sv=0, l = v = u.\n    Returns the maximal objective value and the optimal flux vector.\n    \"\"\"\n    num_reactions = S.shape[1]\n    bounds = list(zip(l, u))\n    \n    # scipy.optimize.linprog minimizes, so we minimize -c^T v\n    res = linprog(c=-c, A_eq=S, b_eq=np.zeros(S.shape[0]), bounds=bounds, method='highs')\n    \n    if res.success:\n        return -res.fun, res.x\n    else:\n        # Infeasible or unbounded, so objective value is treated as 0 (non-viable)\n        return 0.0, np.zeros(num_reactions)\n\ndef process_case(case_data, epsilon, tau):\n    \"\"\"\n    Processes a single test case to find synthetic lethal pairs.\n    \"\"\"\n    S = case_data[\"S\"]\n    l_base = case_data[\"l\"]\n    u_base = case_data[\"u\"]\n    c = case_data[\"c\"]\n    gene_map = case_data[\"gene_map\"]\n    pairs_to_test = case_data[\"pairs\"]\n\n    true_sl_count = 0\n    naive_lethal_count = 0\n    false_positive_indices = []\n\n    # Get wild-type solution\n    wt_obj, v_star = solve_fba(c, S, l_base, u_base)\n    wt_is_viable = wt_obj > epsilon\n\n    for idx, (g1, g2) in enumerate(pairs_to_test):\n        is_true_sl = False\n        is_naive_lethal = False\n\n        # --- Correct FBA-based Synthetic Lethality Test ---\n        if wt_is_viable:\n            # Single deletion of g1\n            l_g1, u_g1 = l_base.copy(), u_base.copy()\n            for rxn_idx in gene_map.get(g1, []):\n                l_g1[rxn_idx], u_g1[rxn_idx] = 0, 0\n            g1_obj, _ = solve_fba(c, S, l_g1, u_g1)\n            g1_is_viable = g1_obj > epsilon\n\n            # Single deletion of g2\n            l_g2, u_g2 = l_base.copy(), u_base.copy()\n            for rxn_idx in gene_map.get(g2, []):\n                l_g2[rxn_idx], u_g2[rxn_idx] = 0, 0\n            g2_obj, _ = solve_fba(c, S, l_g2, u_g2)\n            g2_is_viable = g2_obj > epsilon\n\n            # Double deletion of g1 and g2\n            l_g1g2, u_g1g2 = l_base.copy(), u_base.copy()\n            reactions_to_delete = set(gene_map.get(g1, [])) | set(gene_map.get(g2, []))\n            for rxn_idx in reactions_to_delete:\n                l_g1g2[rxn_idx], u_g1g2[rxn_idx] = 0, 0\n            g1g2_obj, _ = solve_fba(c, S, l_g1g2, u_g1g2)\n            double_is_non_viable = g1g2_obj = epsilon\n\n            if g1_is_viable and g2_is_viable and double_is_non_viable:\n                is_true_sl = True\n                true_sl_count += 1\n        \n        # --- Naive Projection-based Lethality Test ---\n        v_tilde = v_star.copy()\n        reactions_to_delete_naive = set(gene_map.get(g1, [])) | set(gene_map.get(g2, []))\n        for rxn_idx in reactions_to_delete_naive:\n            v_tilde[rxn_idx] = 0.0\n\n        mass_balance_error = np.max(np.abs(S @ v_tilde))\n        projected_biomass = c @ v_tilde\n\n        if mass_balance_error > tau or projected_biomass = epsilon:\n            is_naive_lethal = True\n            naive_lethal_count += 1\n\n        # Check for false positives\n        if is_naive_lethal and not is_true_sl:\n            false_positive_indices.append(idx)\n            \n    return [true_sl_count, naive_lethal_count, sorted(false_positive_indices)]\n\nsolve()\n```", "id": "3313299"}]}