{"hands_on_practices": [{"introduction": "将网络划分为最大化模块度的社区是一个计算上的难题。谱方法通过将离散的分配问题松弛为连续的特征向量问题，为这一挑战提供了一个优雅且强大的近似解法。本练习将指导您实现基于模块度矩阵的谱对分算法，这是网络科学中的一个经典方法 [@problem_id:3328768]。通过这个实践，您将深入理解如何利用线性代数工具揭示网络中的宏观结构。", "problem": "您的任务是为小型的无向无权蛋白质-蛋白质相互作用（PPI）网络实现一种基于模块度框架的谱二分方法。目标是通过对模块度矩阵的主特征向量的条目进行阈值处理来计算双向社区分配。请仅使用网络科学和线性代数中的基本定义来构建您的方法。\n\n定义和要求：\n- 令 $A \\in \\{0,1\\}^{n \\times n}$ 表示一个具有 $n$ 个节点、零对角线的无向无权网络的对称邻接矩阵，其条目 $A_{ij} = 1$ 当且仅当节点 $i$ 和 $j$ 之间存在一条边。令 $k_i = \\sum_{j=1}^{n} A_{ij}$ 表示节点 $i$ 的度，令 $2m = \\sum_{i=1}^{n} k_i = \\sum_{i=1}^{n} \\sum_{j=1}^{n} A_{ij}$ 表示边数的两倍。\n- 在配置模型零模型下，节点 $i$ 和 $j$ 之间的期望边数为 $k_i k_j / (2m)$。模块度矩阵是 $B \\in \\mathbb{R}^{n \\times n}$，其条目为 $B_{ij} = A_{ij} - \\frac{k_i k_j}{2m}$。\n- 计算 $B$ 的主特征对，其中主特征值 $\\lambda_{\\max}$ 是最大的实特征值（按数值大小，非绝对值大小），对应的特征向量 $v_{\\max}$ 是任意相关的单位范数特征向量。\n- 使用阈值规则 $s_i = +1$（如果 $v_{\\max,i} \\ge 0$）和 $s_i = -1$（如果 $v_{\\max,i}  0$）将节点分配到两个社区。这将产生一个双向分配向量 $s \\in \\{-1,+1\\}^n$；恰好等于 $0$ 的条目必须分配给 $+1$。\n- 对于由 $s$ 编码的二分，计算模块度值\n$$\nQ = \\frac{1}{4m} \\sum_{i=1}^{n}\\sum_{j=1}^{n} B_{ij} s_i s_j,\n$$\n这等同于专门针对两个组的标准模块度定义。如果 $2m = 0$，按照惯例定义 $Q = 0$。\n- 将有信息量的划分定义为满足 $\\lambda_{\\max}  0$ 且两个社区都非空（即，至少存在一个 $i$ 使得 $s_i = +1$ 并且至少存在一个 $j$ 使得 $s_j = -1$）的二分。\n\n实现一个程序，对以下每个测试用例：\n- 使用配置模型从 $A$ 构建 $B$。\n- 通过对称特征值分解计算 $B$ 的主特征对 $(\\lambda_{\\max}, v_{\\max})$。\n- 按照规定，通过对 $v_{\\max}$ 在 $0$ 处进行阈值处理来形成 $s$。\n- 为该 $s$ 计算 $Q$。\n- 报告一个形式为 $[\\lambda_{\\max}, s\\_list, Q, informative]$ 的结果，其中 $\\lambda_{\\max}$ 和 $Q$ 四舍五入到六位小数，$s\\_list$ 是一个由 $\\{-1, +1\\}$ 中的整数组成的列表，而 $informative$ 是一个布尔值。\n\n测试套件（三个无向无权类PPI网络），每个都用纯组合术语完全指定：\n- 测试用例1（具有单个桥接的双模块结构）：$n = 8$，节点 $\\{0,1,2,3\\}$ 形成一个4-团，节点 $\\{4,5,6,7\\}$ 形成另一个4-团，并且在节点 $3$ 和节点 $4$ 之间恰好有一条模块间边。这两个团之间的所有其他节点对都是非邻接的，并且不存在自环。\n- 测试用例2（星形交互中心）：$n = 6$，节点 $0$ 连接到 $\\{1,2,3,4,5\\}$ 中的每个节点，没有其他边；不存在自环。\n- 测试用例3（没有信息量划分的密集背景）：$n = 5$，网络是完全图 $K_5$（每对不同的节点都相连），没有自环。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个结果列表，每个测试用例一个结果，顺序与上述测试套件一致。每个结果必须是 $[\\lambda_{\\max}, s\\_list, Q, informative]$ 形式的列表，其中 $\\lambda_{\\max}$ 和 $Q$ 四舍五入到六位小数，$s\\_list$ 是一个长度为 $n$ 的由 $-1$ 和 $+1$ 组成的列表，而 $informative$ 是一个布尔值。整个输出必须是一个包含三个用例结果的单一列表。例如：`[[\\dots],[\\dots],[\\dots]]`。", "solution": "该问题要求为无向无权网络实现一种基于模块度矩阵的谱二分算法。解决方案将遵循指定的网络科学和线性代数原理进行设计。\n\n该方法的核心原理是最大化模块度，模块度是社区发现的一种质量函数。对于网络到社区的划分，模块度（表示为 $Q$）衡量的是在给定社区内的边所占的比例，减去如果边是根据配置模型随机分布时期望的该比例。配置模型是一种零模型，其中网络的度序列被保留。\n\n模块度的一般公式是：\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(c_i, c_j)\n$$\n其中 $A$ 是邻接矩阵，$k_i$ 是节点 $i$ 的度，$2m$ 是总边数的两倍（即所有度的总和），$\\delta(c_i, c_j)$ 是克罗内克δ函数，如果节点 $i$ 和 $j$ 在同一个社区（$c_i = c_j$）则为 $1$，否则为 $0$。\n\n括号中的项是模块度矩阵 $B$ 的条目 $B_{ij}$，因此 $B = A - \\frac{1}{2m} k k^T$，其中 $k$ 是节点度的列向量。\n\n对于划分为两个社区的二分，我们可以用一个向量 $s \\in \\{-1, +1\\}^n$ 来表示社区分配。如果节点 $i$ 和 $j$ 在同一个社区，则 $s_i s_j = 1$；如果它们在不同的社区，则 $s_i s_j = -1$。项 $\\delta(c_i, c_j)$ 可以通过 $\\delta(c_i, c_j) = \\frac{1}{2}(1 + s_i s_j)$ 与 $s_i s_j$ 关联。将此代入模块度公式，并利用 $\\sum_{i,j} B_{ij} = 0$ 的事实，我们得到问题陈述中给出的模块度表达式：\n$$\nQ = \\frac{1}{4m} \\sum_{i,j} B_{ij} s_i s_j = \\frac{1}{4m} s^T B s\n$$\n最大化 $Q$ 等价于最大化二次型 $s^T B s$。这是一个 NP 难的整数优化问题。谱方法通过放宽 $s_i$ 必须为 $-1$ 或 $+1$ 的约束来提供一个近似解。我们转而允许向量的条目为任意实数，并在归一化约束 $\\|v\\|=1$ 下最大化 $v^T B v$。根据 Rayleigh-Ritz 定理，最大化该量的向量 $v$ 是对应于矩阵 $B$ 最大特征值的特征向量。这就是主特征向量 $v_{\\max}$。\n\n然后，通过一个简单的阈值方案将得到的实值向量 $v_{\\max}$ 转换回离散的划分向量 $s$。每个分量 $v_{\\max, i}$ 的符号决定了节点 $i$ 的社区分配。\n\n对于每个提供的测试用例，实现将按以下步骤进行：\n\n1.  **构建邻接矩阵 $A$**：根据每个测试网络的组合描述，将构建一个表示邻接矩阵 $A$ 的 $n \\times n$ NumPy 数组。\n\n2.  **计算网络属性**：从 $A$ 中，通过对 $A$ 的行求和来计算度向量 $k$。总度数和 $2m$ 通过对 $k$ 的元素求和来计算。对于 $2m=0$（空图）的特殊情况，按规定处理，设置 $Q=0$。\n\n3.  **构建模块度矩阵 $B$**：使用公式 $B_{ij} = A_{ij} - \\frac{k_i k_j}{2m}$ 构建模块度矩阵 $B$。在矩阵表示法中，即为 $B = A - \\frac{1}{2m} k k^T$，其中 $k k^T$ 是度向量与自身的外积。\n\n4.  **计算主特征对**：对模块度矩阵 $B$ 进行对称特征值分解。由于 $B$ 是一个实对称矩阵，其特征值是实数，其特征向量构成一个标准正交基。我们使用 `numpy.linalg.eigh`，它专为对称矩阵设计，并按升序返回特征值。主特征值 $\\lambda_{\\max}$ 是返回的特征值数组的最后一个元素，主特征向量 $v_{\\max}$ 是返回的特征向量矩阵的最后一列。\n\n5.  **确定二分**：根据阈值规则从 $v_{\\max}$ 创建划分向量 $s$：如果第 $i$ 个分量 $v_{\\max,i} \\ge 0$，则 $s_i = +1$；如果 $v_{\\max,i}  0$，则 $s_i = -1$。\n\n6.  **计算模块度 $Q$**：对于所获得的划分 $s$，使用给定公式的矩阵形式计算模块度 $Q$：$Q = \\frac{s^T B s}{4m}$。这是通过矩阵向量积实现的。\n\n7.  **评估划分**：如果满足两个条件，则该划分被分类为“有信息量”：主特征值 $\\lambda_{\\max}$ 严格为正，并且得到的划分 $s$ 同时包含 $+1$ 和 $-1$ 值（即两个社区都非空）。\n\n8.  **格式化输出**：将每个测试用例的最终结果组合成一个列表，其中包含四舍五入到六位小数的 $\\lambda_{\\max}$ 和 $Q$、划分向量 $s$ 的列表表示形式，以及指示该划分是否有信息量的布尔值。所有测试用例的结果被收集到一个单一列表中作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the spectral bipartitioning problem for the given test cases.\n    \"\"\"\n\n    def analyze_network(A: np.ndarray):\n        \"\"\"\n        Performs spectral bipartitioning on a network given its adjacency matrix.\n        \n        Args:\n            A (np.ndarray): The symmetric adjacency matrix of the network.\n\n        Returns:\n            list: A list containing the rounded leading eigenvalue, the partition vector,\n                  the rounded modularity, and a boolean indicating if the split is informative.\n        \"\"\"\n        n = A.shape[0]\n        if n == 0:\n            return [0.0, [], 0.0, False]\n\n        k = A.sum(axis=1)\n        two_m = k.sum()\n\n        if two_m == 0:\n            s_list = [1] * n if n  0 else []\n            return [0.0, s_list, 0.0, False]\n\n        # Construct the modularity matrix B\n        B = A - np.outer(k, k) / two_m\n\n        # Eigenvalue decomposition for the symmetric matrix B\n        # numpy.linalg.eigh returns eigenvalues in ascending order\n        eigenvalues, eigenvectors = np.linalg.eigh(B)\n\n        # The leading eigenpair corresponds to the largest eigenvalue\n        lambda_max = eigenvalues[-1]\n        v_max = eigenvectors[:, -1]\n\n        # Create partition vector s from the leading eigenvector v_max\n        # s_i = +1 if v_max_i = 0, s_i = -1 if v_max_i  0\n        s = np.ones(n, dtype=int)\n        s[v_max  0] = -1\n\n        # Calculate modularity Q for the partition s\n        # Q = (1/(4m)) * s^T * B * s. Here, two_m is 2m, so 4m = 2 * two_m.\n        Q = (s.T @ B @ s) / (2 * two_m)\n\n        # Determine if the split is informative\n        is_lambda_positive = lambda_max  1e-12 # Use a small tolerance for float comparison\n        has_both_communities = len(np.unique(s)) == 2\n        informative = bool(is_lambda_positive and has_both_communities)\n\n        # Format results\n        lambda_max_rounded = round(float(lambda_max), 6)\n        Q_rounded = round(float(Q), 6)\n        s_list = s.tolist()\n\n        return [lambda_max_rounded, s_list, Q_rounded, informative]\n\n    # --- Test Case 1: Two modules with a bridge ---\n    n1 = 8\n    A1 = np.zeros((n1, n1), dtype=int)\n    # First 4-clique (nodes 0, 1, 2, 3)\n    for i in range(4):\n        for j in range(i + 1, 4):\n            A1[i, j] = A1[j, i] = 1\n    # Second 4-clique (nodes 4, 5, 6, 7)\n    for i in range(4, 8):\n        for j in range(i + 1, 8):\n            A1[i, j] = A1[j, i] = 1\n    # Bridge between node 3 and node 4\n    A1[3, 4] = A1[4, 3] = 1\n\n    # --- Test Case 2: Star graph ---\n    n2 = 6\n    A2 = np.zeros((n2, n2), dtype=int)\n    # Node 0 is connected to all other nodes\n    for i in range(1, n2):\n        A2[0, i] = A2[i, 0] = 1\n\n    # --- Test Case 3: Complete graph K5 ---\n    n3 = 5\n    A3 = np.ones((n3, n3), dtype=int) - np.eye(n3, dtype=int)\n\n    test_cases = [A1, A2, A3]\n\n    results = []\n    for A in test_cases:\n        result = analyze_network(A)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python includes spaces after commas.\n    # The boilerplate format string ensures the output conforms to the problem's example.\n    # Example item: `[2.413793, [1, 1, 1, 1, -1, -1, -1, -1], 0.357322, True]`\n    # `str()` of this list produces `'[2.413793, [1, 1, 1, 1, -1, -1, -1, -1], 0.357322, True]'`\n    # `','.join(map(str, results))` joins these strings with commas.\n    # The outer `f\"[{...}]\"` wraps the whole thing in brackets.\n    # This combination correctly produces the format `[[...],[...],[...]]`.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3328768"}, {"introduction": "模块度的核心思想是比较社区内部的连接密度与“随机期望”的连接密度。然而，“随机期望”的定义至关重要，一个不恰当的零模型可能会将网络固有的特征（如度异质性）错误地解读为社区结构。本练习通过一个思想实验，揭示了零模型选择不当如何导致在没有真实社区的网络中产生虚假的模块 [@problem_id:3328725]。通过这个分析，您将理解为什么保留度的配置模型是模块度分析的标准选择，并学会审慎评估社区检测方法背后的假设。", "problem": "在一种真核细胞类型的蛋白质-蛋白质相互作用网络中，假设有 $N=1000$ 个蛋白质，表示为一个简单无向图（无自环）中的节点。度序列表现出显著的异质性：$h=10$ 个中心蛋白质（hub）的度均为 $20$，其余 $N-h=990$ 个蛋白质的度均为 $2$。该网络是通过在保持度序列的条件下（度保持的随机连接）对末端（stub）进行均匀随机连接生成的，并且在生成过程中，除了度异质性本身之外，没有真正的中尺度社群结构。考虑一个划分 $\\mathcal{P}_1$，它将所有中心蛋白质放入一个模块，所有非中心蛋白质放入第二个模块。\n\n为了基于模块度进行社群评分，考虑了两种关于期望边数的零模型：\n- 一个同质伯努利零模型，其中每对不同节点以概率 $p$ 独立连接，$p$ 的选择与整个图的观测边密度相匹配。\n- 一个度保持的零模型，其中节点 $i$ 和 $j$ 之间的期望边数与 $k_i k_j$ 成正比，并与配置模型（configuration model）相匹配。\n\n令 $m$ 表示总边数，$K_H$ 表示中心蛋白质集合的度之和，$K_L$ 表示非中心蛋白质集合的度之和，$n_H$ 表示中心蛋白质的数量，$n_L$ 表示非中心蛋白质的数量。利用第一性原理计算每种零模型下的期望边数，并根据模块度的核心定义（即观测到的模块内边密度与零模型期望的模块内边密度之差，经过适当归一化），分析在两种零模型下，$\\mathcal{P}_1$ 中中心蛋白质模块对模块度的贡献。然后，论证同质伯努利零模型是否会在存在极端度异质性的情况下产生虚假模块，并提出一个修正的零模型，以避免在计算系统生物学网络（如蛋白质-蛋白质相互作用（PPI）图）中出现这种陷阱。\n\n选择所有正确的陈述：\n\nA. 在同质伯努利零模型下，$\\mathcal{P}_1$ 中中心蛋白质模块对模块度的贡献是正的，数量级约为 $7.5\\times 10^{-3}$，这在一个实际上除了度异质性外没有真正社群的网络中，围绕中心蛋白质创建了一个表观上的模块。\n\nB. 在度保持的零模型下，对于通过度保持随机连接生成的图，任何划分的期望模块度均为 $0$。对于 $\\mathcal{P}_1$，中心蛋白质模块的贡献约为 $-8.4\\times 10^{-4}$，这表明 A 中的表观信号源于零模型的错误设定。\n\nC. 一个针对虚假模块度的合适修正是保留同质伯努利零模型，但将 $p$ 替换为仅从中心蛋白质节点估计的值。\n\nD. 对于具有重尾度分布的网络，一个修正的零模型是度校正模型（例如，配置模型或度校正随机块模型），其中节点 $i$ 和 $j$ 之间的期望边数与 $k_i k_j$ 成比例，从而防止由中心蛋白质驱动的虚假模块的产生。\n\nE. 将非中心蛋白质模块分割成许多小社群会减少在同质伯努利零模型下中心蛋白质模块的正贡献。", "solution": "问题陈述已经过验证，被认为是合理的。它具有科学依据，问题提出得当，客观，并包含进行严谨分析所需的所有信息。\n\n我们首先计算所描述网络的基本属性。\n节点总数为 $N=1000$。\n中心蛋白质的数量为 $n_H = 10$，每个的度为 $k_{hub} = 20$。\n非中心蛋白质的数量为 $n_L = 990$，每个的度为 $k_{non-hub} = 2$。\n网络中所有度的总和为 $2m = \\sum_{i} k_i$。\n$$ 2m = n_H \\cdot k_{hub} + n_L \\cdot k_{non-hub} = (10)(20) + (990)(2) = 200 + 1980 = 2180 $$\n因此，网络中的总边数为 $m = 1090$。\n\n划分 $\\mathcal{P}_1$ 包含两个模块：中心蛋白质模块 $C_H$（包含 $n_H=10$ 个中心蛋白质）和非中心蛋白质模块 $C_L$（包含 $n_L=990$ 个非中心蛋白质）。\n中心蛋白质模块的度之和为 $K_H = n_H \\cdot k_{hub} = 10 \\cdot 20 = 200$。\n非中心蛋白质模块的度之和为 $K_L = n_L \\cdot k_{non-hub} = 990 \\cdot 2 = 1980$。\n作为检验，$K_H + K_L = 200 + 1980 = 2180 = 2m$。\n\n一个划分的模块度 $Q$ 的一般定义是：\n$$ Q = \\sum_{C} \\left( \\frac{L_C}{m} - \\frac{E_C}{m} \\right) $$\n其中，总和是对划分中所有模块 $C$进行的，$L_C$ 是两个端点都在模块 $C$ 内部的边数，$E_C$ 是在指定零模型下模块 $C$ 内部的期望边数。单个模块 $C$ 对总模块度的贡献为 $Q_C = (L_C - E_C)/m$。\n\n问题陈述指出，该网络是通过度保持的随机连接生成的，这对应于配置模型。在此类网络中，任何模块内的边数 $L_C$ 是一个随机变量。在需要 $L_C$ 的地方，我们将使用其期望值 $E[L_C]$，因为它代表了由此过程生成的典型图的属性。对于中心蛋白质模块 $C_H$，该图是简单的（无自环），因此内部边的期望数（我们将用其作为 $L_H$）为：\n$$ L_H \\approx E[L_H] = \\sum_{i", "answer": "$$\\boxed{ABD}$$", "id": "3328725"}, {"introduction": "在应用社区检测算法后，我们如何客观地评估其结果的优劣，特别是当存在一个已知的“基准真相”（如已知的蛋白质复合物）时？简单的重叠计数可能会产生误导，我们需要能够校正偶然一致性的度量标准。本练习将介绍归一化互信息 (NMI) 和调整兰德指数 (ARI) 的定义与解释，它们是比较网络划分的两种关键的、统计上稳健的指标 [@problem_id:3328780]。掌握这些工具，对于严谨地验证和比较社区检测算法的性能至关重要。", "problem": "在一项计算系统生物学研究中，您希望评估蛋白质-蛋白质相互作用网络上检测到的社群分配在多大程度上恢复了经整理的蛋白质复合物参考集。设 $U=\\{U_{1},\\dots,U_{r}\\}$ 表示真实划分，而 $V=\\{V_{1},\\dots,V_{s}\\}$ 表示对同一组 $n$ 个蛋白质的检测划分。定义列联表计数 $n_{ij}=\\lvert U_{i}\\cap V_{j}\\rvert$，其边际量为 $a_{i}=\\sum_{j} n_{ij}$ 和 $b_{j}=\\sum_{i} n_{ij}$。设 $p_{ij}=n_{ij}/n$，$p_{i}=a_{i}/n$ 和 $q_{j}=b_{j}/n$。使用香农熵 $H(U)=-\\sum_{i} p_{i}\\log p_{i}$ 和互信息 $I(U;V)=\\sum_{i,j} p_{ij}\\log\\!\\big(p_{ij}/(p_{i}q_{j})\\big)$ 的标准信息论定义，其中对数的底是任意但固定的。对于配对计数，请注意无序对的总数为 ${n \\choose 2}$，并且 $U$ 中的簇内配对数量为 $\\sum_{i} {a_{i}\\choose 2}$，对于 $V$ 也类似。\n\n假设我们所关注的标准化互信息 (NMI) 版本使用熵的算术平均值进行对称标准化，并且调整兰德指数 (ARI) 指的是在保留簇大小序列 $\\{a_{i}\\}$ 和 $\\{b_{j}\\}$ 的广义超几何模型下的机会校正版本。\n\n选择所有能够用明确公式正确定义这些指数，并准确解释它们如何在此生物学背景下评估 $U$ 和 $V$ 之间一致性的选项。\n\nA. 定义 $ \\mathrm{NMI}(U,V)=\\dfrac{2\\,I(U;V)}{H(U)+H(V)} $，其中 $H(U)$、$H(V)$ 和 $I(U;V)$ 根据指定的 $p_{i}$、$q_{j}$ 和 $p_{ij}$ 计算。该量满足 $0\\le \\mathrm{NMI}(U,V)\\le 1$，当且仅当 $U$ 和 $V$ 在重新标记后相同时等于 $1$，当给定 $p_{i}$ 和 $q_{j}$ 时 $U$ 和 $V$ 统计独立时等于 $0$，并且对标签的排列不变。在评估检测到的蛋白质复合物与真实蛋白质复合物时，较大的值表示对经整理的模块的恢复效果更好，并且该值与对数底的选择无关。\n\nB. 定义 $ \\mathrm{NMI}(U,V)=\\dfrac{I(U;V)}{H(U)} $。对于相同的划分，此比率等于 $1$，对于独立的划分，此比率等于 $0$，它在 $U$ 和 $V$ 之间是对称的，因此适合用于比较检测到的蛋白质复合物与真实情况，而不会偏向任何一个划分。\n\nC. 定义 $ \\mathrm{ARI}(U,V)=\\dfrac{\\displaystyle \\sum_{i,j} {n_{ij}\\choose 2}\\;-\\;\\dfrac{\\left(\\sum_{i} {a_{i}\\choose 2}\\right)\\left(\\sum_{j} {b_{j}\\choose 2}\\right)}{{n\\choose 2}}}{\\displaystyle \\tfrac{1}{2}\\Big(\\sum_{i} {a_{i}\\choose 2}+\\sum_{j} {b_{j}\\choose 2}\\Big)\\;-\\;\\dfrac{\\left(\\sum_{i} {a_{i}\\choose 2}\\right)\\left(\\sum_{j} {b_{j}\\choose 2}\\right)}{{n\\choose 2}}} $。当且仅当 $U$ 和 $V$ 在重新标记后相同时，此指数等于 $1$；在固定 $\\{a_{i}\\}$ 和 $\\{b_{j}\\}$ 的广义超几何零假设下，其期望值为 $0$；当一致性低于机会预期的水平时，可能为负；并且对标签排列不变。在比较检测到的社群与参考蛋白质复合物时，较大的值表示在校正了由簇大小分布驱动的随机一致性后，成对一致性更高。\n\nD. 定义 $ \\mathrm{ARI}(U,V)=\\dfrac{\\text{一致配对的数量}}{ {n\\choose 2} }=\\dfrac{\\sum_{i,j} {n_{ij}\\choose 2}+\\Big[{n\\choose 2}-\\sum_{i} {a_{i}\\choose 2}-\\sum_{j} {b_{j}\\choose 2}+\\sum_{i,j} {n_{ij}\\choose 2}\\Big]}{{n\\choose 2}} $，该值始终在 $[0,1]$ 范围内，对于随机划分，其期望值为 $0$。这种未经调整的度量足以在不受边际簇大小序列偏见影响的情况下，比较检测到的复合物与真实情况。\n\nE. $ \\mathrm{NMI} $ 和 $ \\mathrm{ARI} $ 对分裂和合并的惩罚相同，无论社群大小如何，因此它们在细化或粗化下是严格单调的：通过合并任何社群来粗化 $U$ 永远不会增加任一指数，通过分裂任何社群来细化 $U$ 永远不会减少任一指数。", "solution": "用户提供了一个关于评估网络中社群检测的问题陈述，特别要求给出标准化互信息 (NMI) 和调整兰德指数 (ARI) 的正确定义和解释。\n\n### 问题验证\n\n首先，评估问题陈述的有效性。\n\n**第 1 步：提取已知信息**\n\n*   $U=\\{U_{1},\\dots,U_{r}\\}$：将 $n$ 个蛋白质划分为 $r$ 个不相交复合物的真实划分。\n*   $V=\\{V_{1},\\dots,V_{s}\\}$：对同一 $n$ 个蛋白质检测到的划分为 $s$ 个社群。\n*   $n_{ij}=\\lvert U_{i}\\cap V_{j}\\rvert$：真实复合物 $U_i$ 和检测社群 $V_j$ 共有的蛋白质数量。\n*   $a_{i}=\\sum_{j=1}^{s} n_{ij} = \\lvert U_i \\rvert$：第 $i$ 个真实复合物的大小。\n*   $b_{j}=\\sum_{i=1}^{r} n_{ij} = \\lvert V_j \\rvert$：第 $j$ 个检测社群的大小。\n*   $n=\\sum_{i=1}^{r} a_i = \\sum_{j=1}^{s} b_j$：蛋白质总数。\n*   $p_{ij}=n_{ij}/n$, $p_{i}=a_{i}/n$, $q_{j}=b_{j}/n$：联合概率和边际概率。\n*   $H(U)=-\\sum_{i=1}^{r} p_{i}\\log p_{i}$：划分 $U$ 的香农熵。\n*   $I(U;V)=\\sum_{i=1}^{r}\\sum_{j=1}^{s} p_{ij}\\log\\!\\big(p_{ij}/(p_{i}q_{j})\\big)$：划分 $U$ 和 $V$ 之间的互信息。\n*   指定的 NMI 版本：通过熵的算术平均值进行对称标准化。\n*   指定的 ARI 版本：在广义超几何模型（固定边际量 $\\{a_{i}\\}$ 和 $\\{b_{j}\\}$）下进行机会校正。\n*   配对计数定义：总配对数为 ${n \\choose 2}$；$U$ 中簇内的配对数为 $\\sum_{i} {a_{i}\\choose 2}$。\n\n**第 2 步：使用提取的已知信息进行验证**\n\n对问题的科学合理性、适定性和客观性进行评估。\n\n1.  **科学或事实不健全**：问题在事实上是健全的。它使用了信息论（$H(U)$, $I(U;V)$）和统计学（列联表、配对计数、超几何模型）中标准的、正确的定义，并将其应用于网络社群检测评估这一成熟领域。\n2.  **非形式化或不相关**：问题与计算系统生物学中模块化和社群结构这一特定主题高度相关。它完全可以形式化。\n3.  **不完整或矛盾的设定**：问题是自洽的。它提供了所有必要的定义，并且关键地指定了要考虑的 NMI（算术平均值标准化）和 ARI（广义超几何零模型）的确切变体，避免了歧义。\n4.  **不切实际或不可行**：所描述的情景是生物信息学研究中的一个标准且现实的任务。\n5.  **不适定或结构不良**：问题是适定的，要求给出定义明确的度量的正确公式和解释。\n6.  **伪深刻、琐碎或同义反复**：问题并非琐碎。它需要关于聚类评估指标的数学定义和统计特性的特定知识。\n7.  **超出科学可验证范围**：选项中的所有主张在数学上都是可验证的。\n\n**第 3 步：结论与行动**\n\n问题陈述是**有效的**。现在将推导解决方案。\n\n### 推导与选项评估\n\n任务是识别那些正确定义了指定版本的 NMI 和 ARI，并准确描述其属性和解释的选项。\n\n**A. 定义 $ \\mathrm{NMI}(U,V)=\\dfrac{2\\,I(U;V)}{H(U)+H(V)} $，其中 $H(U)$、$H(V)$ 和 $I(U;V)$ 根据指定的 $p_{i}$、$q_{j}$ 和 $p_{ij}$ 计算。该量满足 $0\\le \\mathrm{NMI}(U,V)\\le 1$，当且仅当 $U$ 和 $V$ 在重新标记后相同时等于 $1$，当给定 $p_{i}$ 和 $q_{j}$ 时 $U$ 和 $V$ 统计独立时等于 $0$，并且对标签的排列不变。在评估检测到的蛋白质复合物与真实蛋白质复合物时，较大的值表示对经整理的模块的恢复效果更好，并且该值与对数底的选择无关。**\n\n问题指定了使用熵的算术平均值进行对称标准化的 NMI 变体。$H(U)$ 和 $H(V)$ 的算术平均值是 $\\frac{H(U)+H(V)}{2}$。用这个量来标准化互信息 $I(U;V)$ 得到：\n$$ \\mathrm{NMI}(U,V) = \\frac{I(U;V)}{\\left(\\frac{H(U)+H(V)}{2}\\right)} = \\frac{2\\,I(U;V)}{H(U)+H(V)} $$\n这个公式是正确的。\n\n让我们评估其陈述的属性：\n1.  **范围 $0\\le \\mathrm{NMI}(U,V)\\le 1$**：我们知道 $I(U;V) \\ge 0$，且熵为非负，所以 $\\mathrm{NMI} \\ge 0$。根据信息论，我们有不等式 $I(U;V) \\le \\min(H(U), H(V))$。由于算术平均值总是大于或等于最小值，即 $\\frac{H(U)+H(V)}{2} \\ge \\min(H(U), H(V))$，因此可得 $\\mathrm{NMI}(U,V) \\le \\frac{\\min(H(U), H(V))}{\\min(H(U), H(V))} = 1$（假设熵不为零）。该属性正确。\n2.  **值为 $1$**：$\\mathrm{NMI}(U,V)=1$ 要求 $I(U;V) = \\frac{H(U)+H(V)}{2}$。这意味着 $I(U;V) \\ge H(U)$ 和 $I(U;V) \\ge H(V)$。由于 $I(U;V) = H(U) - H(U|V) \\le H(U)$ 和 $I(U;V) = H(V) - H(V|U) \\le H(V)$，这个等式只有在 $H(U|V)=0$、$H(V|U)=0$ 和 $H(U)=H(V)$ 时才能成立。这当且仅当两个划分 $U$ 和 $V$ 相同（在不考虑簇标签排列的情况下）时发生。该属性正确。\n3.  **值为 $0$**：$\\mathrm{NMI}(U,V)=0$ 当且仅当 $I(U;V)=0$。这对应于划分在统计上独立的情况，即对所有 $i,j$ 都有 $p_{ij}=p_i q_j$。该陈述正确。\n4.  **标签不变性**：$H(U)$、$H(V)$ 和 $I(U;V)$ 的定义涉及对所有簇的求和。对簇的标签进行排列只会重新排序求和中的项，而总值保持不变。该属性正确。\n5.  **解释**：NMI 衡量共享信息。更高的值表示更高的一致性。因此，较大的 NMI 值表示检测到的社群更好地恢复了真实的复合物。这是正确的。\n6.  **对数底不变性**：如果将对数底从 $b_1$ 更改为 $b_2$，所有的熵和互信息值都会乘以一个常数因子 $\\log_{b_2}(b_1)$。这个因子同时出现在 NMI 公式的分子和分母中，因此会消掉。该属性正确。\n\n此选项的所有部分都是正确的。\n结论：**正确**。\n\n**B. 定义 $ \\mathrm{NMI}(U,V)=\\dfrac{I(U;V)}{H(U)} $。对于相同的划分，此比率等于 $1$，对于独立的划分，此比率等于 $0$，它在 $U$ 和 $V$ 之间是对称的，因此适合用于比较检测到的蛋白质复合物与真实情况，而不会偏向任何一个划分。**\n\n公式 $\\mathrm{NMI}(U,V)=\\dfrac{I(U;V)}{H(U)}$ 是一个有效的，但不同的互信息标准化方法。它不是问题陈述中指定的版本（通过*算术平均值*进行标准化）。此外，该陈述声称这个版本“在 $U$ 和 $V$ 之间是对称的”。这是错误的。虽然互信息是对称的（$I(U;V) = I(V;U)$），但划分的熵通常不是（$H(U) \\neq H(V)$）。因此，$\\frac{I(U;V)}{H(U)} \\ne \\frac{I(V;U)}{H(V)}$，该度量不是对称的。这种不对称性使其不适合进行对称比较。\n结论：**错误**。\n\n**C. 定义 $ \\mathrm{ARI}(U,V)=\\dfrac{\\displaystyle \\sum_{i,j} {n_{ij}\\choose 2}\\;-\\;\\dfrac{\\left(\\sum_{i} {a_{i}\\choose 2}\\right)\\left(\\sum_{j} {b_{j}\\choose 2}\\right)}{{n\\choose 2}}}{\\displaystyle \\tfrac{1}{2}\\Big(\\sum_{i} {a_{i}\\choose 2}+\\sum_{j} {b_{j}\\choose 2}\\Big)\\;-\\;\\dfrac{\\left(\\sum_{i} {a_{i}\\choose 2}\\right)\\left(\\sum_{j} {b_{j}\\choose 2}\\right)}{{n\\choose 2}}} $。当且仅当 $U$ 和 $V$ 在重新标记后相同时，此指数等于 $1$；在固定 $\\{a_{i}\\}$ 和 $\\{b_{j}\\}$ 的广义超几何零假设下，其期望值为 $0$；当一致性低于机会预期的水平时，可能为负；并且对标签排列不变。在比较检测到的社群与参考蛋白质复合物时，较大的值表示在校正了由簇大小分布驱动的随机一致性后，成对一致性更高。**\n\nARI 的通用形式定义为 $\\frac{\\text{指数} - E[\\text{指数}]}{\\text{指数最大值} - E[\\text{指数}]}$。在这里，`指数`是在两个划分中都属于同一簇的元素对的数量，即 $\\sum_{i,j} {n_{ij} \\choose 2}$。在具有固定边际量 $\\{a_i\\}$ 和 $\\{b_j\\}$ 的超几何模型下，该指数的期望值为 $E[\\text{指数}] = \\frac{(\\sum_{i} {a_{i}\\choose 2})(\\sum_{j} {b_{j}\\choose 2})}{{n\\choose 2}}$。`指数最大值`被取为两个划分中簇内配对数的平均值，即 $\\frac{1}{2}(\\sum_{i} {a_{i}\\choose 2}+\\sum_{j} {b_{j}\\choose 2})$。\n将这些代入通用形式，即可得到选项中给出的确切公式。\n\n让我们评估其陈述的属性：\n1.  **值为 $1$**：当 $U$ 和 $V$ 是相同的划分时，达到此最大值。在这种情况下，$\\sum_{i,j} {n_{ij}\\choose 2}$ 等于 $\\sum_{i} {a_{i}\\choose 2}$ 和 $\\sum_{j} {b_{j}\\choose 2}$。分子和分母变得相等（前提是分母不为零），得到值为 $1$。这是正确的。\n2.  **期望值为 $0$**：根据构造，分子是 $\\text{指数} - E[\\text{指数}]$，所以分子的期望值为 $0$。因此，在零模型下，ARI 的期望值为 $0$。这是正确的。\n3.  **可能为负**：如果观察到的一致性 $\\sum {n_{ij}\\choose 2}$ 小于预期的一致性 $E[\\text{指数}]$，则分子将为负，使 ARI 为负。这是正确的。\n4.  **标签不变性**：求和是针对所有簇 $i$ 和 $j$ 的，因此对任一划分的标签进行排列不会改变结果。这是正确的。\n5.  **解释**：ARI 的核心目的是为兰德指数校正随机一致性。高值意味着一致配对的数量显著高于在给定簇大小分布下随机预期的数量。这个解释是正确的。\n\n此选项的所有部分都是正确的。\n结论：**正确**。\n\n**D. 定义 $ \\mathrm{ARI}(U,V)=\\dfrac{\\text{一致配对的数量}}{ {n\\choose 2} }=\\dfrac{\\sum_{i,j} {n_{ij}\\choose 2}+\\Big[{n\\choose 2}-\\sum_{i} {a_{i}\\choose 2}-\\sum_{j} {b_{j}\\choose 2}+\\sum_{i,j} {n_{ij}\\choose 2}\\Big]}{{n\\choose 2}} $，该值始终在 $[0,1]$ 范围内，对于随机划分，其期望值为 $0$。这种未经调整的度量足以在不受边际簇大小序列偏见影响的情况下，比较检测到的复合物与真实情况。**\n\n提供的公式是未经调整的兰德指数 (RI)，而不是调整兰德指数 (ARI)。分子是一致配对的数量：（在 $U, V$ 中均属同一簇的配对数）+（在 $U, V$ 中均属不同簇的配对数）。这是 $TP+TN$。项 $\\sum_{i,j} {n_{ij}\\choose 2}$ 是 $TP$。括号中的项是 $TN$ 的公式。所以显示的公式确实是兰德指数。\n关于其属性的说法是错误的：\n1.  它不是 ARI。\n2.  对于随机划分，其期望值不为 $0$；它为正，而这正是需要进行调整的原因。ARI 才是期望值为 $0$ 的指数。\n3.  最后的说法，即这种“未经调整的度量足以...不受偏见影响”，与事实完全相反。RI 已知会受到簇的数量和大小的偏见影响，而 ARI 正是为了校正这一点而设计的。\n结论：**错误**。\n\n**E. $ \\mathrm{NMI} $ 和 $ \\mathrm{ARI} $ 对分裂和合并的惩罚相同，无论社群大小如何，因此它们在细化或粗化下是严格单调的：通过合并任何社群来粗化 $U$ 永远不会增加任一指数，通过分裂任何社群来细化 $U$ 永远不会减少任一指数。**\n\n这个选项提出了两个强烈的断言。第一个是关于惩罚如何施加，第二个是关于严格单调性。\n1.  “对分裂和合并的惩罚相同，无论社群大小如何”：这是错误的。NMI 和 ARI 在分裂或合并后的变化直接取决于受影响簇的大小（$n_{ij}$、$a_i$、$b_j$）。例如，在 ARI 中，分裂一个大簇对配对计数的影响远大于分裂一个小簇。在 NMI 中，熵和互信息的变化取决于概率 $p_i$，而这些概率是簇大小的函数。\n2.  “在细化或粗化下是严格单调的”：这也是错误的。让我们考虑将 $U$ 粗化为 $U'$（通过合并其某些簇），并比较 $\\text{Index}(U,V)$ 与 $\\text{Index}(U',V)$。该断言声称 $\\text{Index}(U',V) \\le \\text{Index}(U,V)$。考虑 $V = \\{\\{1,2\\}, \\{3,4\\}\\}$ 和 $U = \\{\\{1\\}, \\{2\\}, \\{3,4\\}\\}$。如果我们通过合并 $\\{1\\}$ 和 $\\{2\\}$ 将 $U$ 粗化为 $U' = \\{\\{1,2\\}, \\{3,4\\}\\}$，那么新的划分 $U'$ 将与 $V$ 相同。一致性指数（NMI 和 ARI）将从一个小于 $1$ 的值增加到恰好为 $1$。这违反了粗化“永远不会增加”该指数的说法。这些指数相对于分裂和合并等局部变化的行为是复杂的，而不是单调的。\n结论：**错误**。", "answer": "$$\\boxed{AC}$$", "id": "3328780"}]}