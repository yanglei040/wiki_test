{"hands_on_practices": [{"introduction": "我们从一项最基础的任务开始：为一个简单、明确定义的系统实现格兰杰因果关系（$GC$）和传递熵（$TE$）的核心定义。这个练习将巩固这两种度量在线性高斯情况下的理论联系，即证明$TE$与$GC$成正比[@problem_id:3293117]。它为理解如何从系统的协方差结构计算这些度量提供了一个计算基础。", "problem": "考虑一个二维状态 $Z_t = [X_t, Y_t]^\\top$ 上的平稳线性高斯一阶向量自回归过程（VAR(1)），其动态方程为 $Z_t = A Z_{t-1} + \\varepsilon_t$，其中 $A \\in \\mathbb{R}^{2 \\times 2}$ 是自回归参数矩阵，$\\varepsilon_t \\sim \\mathcal{N}(0, \\Sigma_\\varepsilon)$ 是协方差为 $\\Sigma_\\varepsilon \\in \\mathbb{R}^{2 \\times 2}$ 的独立同分布高斯新息。假设 $A$ 是稳定的，因此存在唯一的平稳协方差。使用以下基本依据：(i) 平稳性意味着协方差 $\\Sigma$ 满足离散时间李雅普诺夫方程，(ii) 高斯条件方差和条件互信息由协方差确定，以及 (iii) 格兰杰因果关系通过预测误差方差定义。\n\n仅使用这些依据和下文给出的标准定义，设计一个程序，为每个指定的参数集 $(A, \\Sigma_\\varepsilon)$ 计算从 $X$ 到 $Y$ 和从 $Y$ 到 $X$ 的一步Geweke格兰杰因果关系，以及相应的传递熵，并数值上验证它们对于线性高斯系统的理论恒等式。\n\n待使用的定义：\n- 平稳协方差 $\\,\\Sigma = \\operatorname{Var}(Z_t)\\,$ 是在 $\\,A\\,$ 稳定的条件下，离散李雅普诺夫方程 $\\,\\Sigma = A \\Sigma A^\\top + \\Sigma_\\varepsilon\\,$ 的唯一正定解。\n- 标量目标 $\\,U_t \\in \\{X_t, Y_t\\}\\,$ 在以由 $\\,Z_{t-1}\\,$ 元素构成的预测变量集 $\\,S\\,$ 为条件时的一步预测误差方差，是由 $\\,\\{U_t, S\\}\\,$ 的联合协方差确定的高斯条件方差 $\\,\\operatorname{Var}(U_t \\mid S)\\,$。\n- 从 $\\,X\\,$ 到 $\\,Y\\,$ 的格兰杰因果关系（Geweke度量）定义为 $\\,F_{X \\to Y} = \\log\\left(\\operatorname{Var}(Y_t \\mid Y_{t-1}) / \\operatorname{Var}(Y_t \\mid X_{t-1}, Y_{t-1})\\right)\\,$，单位为自然单位（奈特），通过交换角色可得到类似的 $\\,F_{Y \\to X}\\,$ 定义。\n- 从 $\\,X\\,$ 到 $\\,Y\\,$ 的传递熵（Schreiber）定义为条件互信息 $\\,T_{X \\to Y} = I(X_{t-1}; Y_t \\mid Y_{t-1})\\,$，单位为自然单位（奈特），通过交换角色可得到类似的 $\\,T_{Y \\to X}\\,$ 定义。\n\n对于高斯变量，条件互信息可简化为条件方差的对数比，这意味着当所有量都以自然单位（奈特）表示时，理论恒等式 $\\,F_{X \\to Y} = 2\\,T_{X \\to Y}\\,$ 和 $\\,F_{Y \\to X} = 2\\,T_{Y \\to X}\\,$ 成立。\n\n您的程序必须：\n- 对于下面的每个参数集，通过确定所需的平稳协方差和根据VAR(1)模型所蕴含的高斯协方差恒等式计算所有必要的条件方差，来计算 $\\,F_{X \\to Y}, F_{Y \\to X}, T_{X \\to Y}, T_{Y \\to X}\\,$。\n- 对每个参数集，报告一个等于与恒等式最大绝对偏差的实数，即\n$$d = \\max\\left(\\left|F_{X \\to Y} - 2 T_{X \\to Y}\\right|, \\left|F_{Y \\to X} - 2 T_{Y \\to X}\\right|\\right).$$\n所有值都应被视为无量纲的自然单位（奈特）。不涉及物理单位。不涉及角度。\n\n测试套件（每组为一对 $\\,A\\,$ 和 $\\,\\Sigma_\\varepsilon\\,$）：\n1. 通用耦合、稳定情况（理想路径）：\n$$\nA = \\begin{bmatrix} 0.3  0.1 \\\\ 0.4  0.2 \\end{bmatrix}, \\quad\n\\Sigma_\\varepsilon = \\begin{bmatrix} 0.7  0.2 \\\\ 0.2  0.5 \\end{bmatrix}.\n$$\n2. 从 $\\,X\\,$ 到 $\\,Y\\,$ 的单向耦合：\n$$\nA = \\begin{bmatrix} 0.4  0.0 \\\\ 0.5  0.3 \\end{bmatrix}, \\quad\n\\Sigma_\\varepsilon = \\begin{bmatrix} 0.7  0.0 \\\\ 0.0  0.3 \\end{bmatrix}.\n$$\n3. 无交叉耦合（期望度量为零的边缘情况）：\n$$\nA = \\begin{bmatrix} 0.6  0.0 \\\\ 0.0  0.6 \\end{bmatrix}, \\quad\n\\Sigma_\\varepsilon = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix}.\n$$\n4. 接近稳定边界的中度耦合：\n$$\nA = \\begin{bmatrix} 0.95  -0.1 \\\\ 0.2  0.85 \\end{bmatrix}, \\quad\n\\Sigma_\\varepsilon = \\begin{bmatrix} 0.2  0.05 \\\\ 0.05  0.2 \\end{bmatrix}.\n$$\n5. 强相关新息：\n$$\nA = \\begin{bmatrix} 0.5  0.5 \\\\ 0.0  0.4 \\end{bmatrix}, \\quad\n\\Sigma_\\varepsilon = \\begin{bmatrix} 0.3  0.27 \\\\ 0.27  0.5 \\end{bmatrix}.\n$$\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，即 $[d_1,d_2,d_3,d_4,d_5]$，其中 $d_i$ 是为测试用例 $i$ 定义的上述偏差。这些值必须以自然单位（奈特）计算。不应打印任何额外文本。", "solution": "该问题是有效的，因为它在科学上基于向量自回归过程、格兰杰因果关系和传递熵的理论，并且问题定义清晰，提供了所有必要的定义和数据。所提供的自回归矩阵是稳定的，保证了唯一平稳协方差的存在。任务是通过从第一性原理实现其定义，来数值验证线性高斯系统中已建立的关联格兰杰因果关系和传递熵的理论恒等式。\n\n解决方案的核心在于从过程的平稳协方差矩阵中推导出必要的条件方差。设二维状态为 $Z_t = [X_t, Y_t]^\\top$。VAR(1)模型为 $Z_t = A Z_{t-1} + \\varepsilon_t$，其中 $A$ 是自回归矩阵，$\\varepsilon_t \\sim \\mathcal{N}(0, \\Sigma_\\varepsilon)$ 是新息过程。\n\n首先，我们确定平稳协方差矩阵 $\\Sigma = \\operatorname{Var}(Z_t)$。由于过程是平稳的，其协方差不随时间变化，$\\operatorname{Var}(Z_t) = \\operatorname{Var}(Z_{t-1}) = \\Sigma$。对模型方程取方差可得 $\\operatorname{Var}(Z_t) = \\operatorname{Var}(A Z_{t-1} + \\varepsilon_t)$。由于 $\\varepsilon_t$ 独立于 $Z_{t-1}$ 等过去的状态，这可以展开为 $\\operatorname{Var}(A Z_{t-1}) + \\operatorname{Var}(\\varepsilon_t) = A \\operatorname{Var}(Z_{t-1}) A^\\top + \\Sigma_\\varepsilon$。这就得到了离散时间李雅普诺夫方程 $\\Sigma = A \\Sigma A^\\top + \\Sigma_\\varepsilon$。对于一个稳定的矩阵 $A$，该方程有一个唯一的正定解 $\\Sigma$，可以通过数值方法找到。我们将 $\\Sigma$ 的分量表示为：\n$$\n\\Sigma = \\begin{bmatrix} \\operatorname{Var}(X_t)  \\operatorname{Cov}(X_t, Y_t) \\\\ \\operatorname{Cov}(Y_t, X_t)  \\operatorname{Var}(Y_t) \\end{bmatrix} = \\begin{bmatrix} \\Sigma_{11}  \\Sigma_{12} \\\\ \\Sigma_{21}  \\Sigma_{22} \\end{bmatrix}\n$$\n类似地，新息协方差矩阵的分量表示为 $\\Sigma_{\\varepsilon,ij}$。\n\n接下来，我们推导格兰杰因果关系和传递熵所需的条件方差表达式。对于具有联合协方差矩阵的高斯变量 $(U, V)$，给定 $V$ 时 $U$ 的条件方差由舒尔补公式给出：$\\operatorname{Var}(U \\mid V) = \\operatorname{Var}(U) - \\operatorname{Cov}(U,V) \\operatorname{Var}(V)^{-1} \\operatorname{Cov}(V,U)$。\n\n让我们计算因果方向 $X \\to Y$ 的度量。\n格兰杰因果关系为 $F_{X \\to Y} = \\log\\left(\\frac{\\operatorname{Var}(Y_t \\mid Y_{t-1})}{\\operatorname{Var}(Y_t \\mid X_{t-1}, Y_{t-1})}\\right)$。\n传递熵为 $T_{X \\to Y} = I(X_{t-1}; Y_t \\mid Y_{t-1})$。对于高斯系统，这等价于 $T_{X \\to Y} = \\frac{1}{2} \\log\\left(\\frac{\\operatorname{Var}(Y_t \\mid Y_{t-1})}{\\operatorname{Var}(Y_t \\mid X_{t-1}, Y_{t-1})}\\right)$。\n\n我们需要两个条件方差：\n1. $\\operatorname{Var}(Y_t \\mid X_{t-1}, Y_{t-1})$：这是 $Y_t$ 在给定完整过去状态 $Z_{t-1}$ 条件下的方差。根据模型方程，$Y_t = (A Z_{t-1})_2 + (\\varepsilon_t)_2$。由于在给定 $Z_{t-1}$ 的条件下 $A Z_{t-1}$ 是固定的，并且 $\\varepsilon_t$ 独立于 $Z_{t-1}$，因此条件方差就是 $Y_t$ 的新息项的方差。\n$$\n\\operatorname{Var}(Y_t \\mid X_{t-1}, Y_{t-1}) = \\operatorname{Var}((\\varepsilon_t)_2) = (\\Sigma_\\varepsilon)_{22}\n$$\n2. $\\operatorname{Var}(Y_t \\mid Y_{t-1})$：这需要 $(Y_t, Y_{t-1})$ 的联合协方差。我们有 $\\operatorname{Var}(Y_t) = \\operatorname{Var}(Y_{t-1}) = \\Sigma_{22}$。互协方差是 $\\operatorname{Cov}(Y_t, Y_{t-1}) = E[Y_t Y_{t-1}] = E[( (A Z_{t-1})_2 + (\\varepsilon_t)_2 ) Y_{t-1}] = E[(A Z_{t-1})_2 Y_{t-1}]$。这是滞后1阶互协方差矩阵 $\\operatorname{Cov}(Z_t, Z_{t-1}) = E[Z_t Z_{t-1}^\\top] = A E[Z_{t-1} Z_{t-1}^\\top] = A \\Sigma$ 的 $(2,2)$ 元素。因此，$\\operatorname{Cov}(Y_t, Y_{t-1}) = (A\\Sigma)_{22}$。对标量变量应用舒尔补公式：\n$$\n\\operatorname{Var}(Y_t \\mid Y_{t-1}) = \\operatorname{Var}(Y_t) - \\frac{\\operatorname{Cov}(Y_t, Y_{t-1})^2}{\\operatorname{Var}(Y_{t-1})} = \\Sigma_{22} - \\frac{((A\\Sigma)_{22})^2}{\\Sigma_{22}}\n$$\n通过对称性，对于因果方向 $Y \\to X$，我们交换索引 $1$ 和 $2$：\n$$\n\\operatorname{Var}(X_t \\mid X_{t-1}, Y_{t-1}) = (\\Sigma_\\varepsilon)_{11}\n$$\n$$\n\\operatorname{Var}(X_t \\mid X_{t-1}) = \\Sigma_{11} - \\frac{((A\\Sigma)_{11})^2}{\\Sigma_{11}}\n$$\n程序将为每个测试用例计算这些量。为了数值检验恒等式 $F = 2T$，我们将使用数学上等价但在计算上不同的公式来计算 $F$ 和 $T$，以暴露潜在的浮点差异。具体来说，我们使用 $F = \\log(V_1/V_2)$ 和 $T = \\frac{1}{2}(\\log(V_1)-\\log(V_2))$。最终偏差 $d$ 是两个因果方向上 $|F - 2T|$ 的最大绝对差。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_discrete_lyapunov\n\ndef solve():\n    \"\"\"\n    Computes causal measures for a 2D VAR(1) process and verifies a theoretical identity.\n\n    For each parameter set (A, Sigma_eps) of a VAR(1) process Z_t = A*Z_{t-1} + eps_t,\n    this function calculates Granger causality (F) and Transfer Entropy (T) in both\n    directions (X->Y and Y->X). It then computes the maximum absolute deviation 'd'\n    from the theoretical identity F = 2T for linear Gaussian systems.\n    \"\"\"\n\n    test_cases = [\n        (  # Case 1: General coupled, stable case\n            np.array([[0.3, 0.1], [0.4, 0.2]]),\n            np.array([[0.7, 0.2], [0.2, 0.5]]),\n        ),\n        (  # Case 2: Unidirectional coupling from X to Y\n            np.array([[0.4, 0.0], [0.5, 0.3]]),\n            np.array([[0.7, 0.0], [0.0, 0.3]]),\n        ),\n        (  # Case 3: No cross-coupling\n            np.array([[0.6, 0.0], [0.0, 0.6]]),\n            np.array([[1.0, 0.0], [0.0, 1.0]]),\n        ),\n        (  # Case 4: Near-boundary stability\n            np.array([[0.95, -0.1], [0.2, 0.85]]),\n            np.array([[0.2, 0.05], [0.05, 0.2]]),\n        ),\n        (  # Case 5: Strongly correlated innovations\n            np.array([[0.5, 0.5], [0.0, 0.4]]),\n            np.array([[0.3, 0.27], [0.27, 0.5]]),\n        ),\n    ]\n\n    results = []\n    for A, Sigma_eps in test_cases:\n        # Numerically compute the deviation for the current parameter set.\n        d = compute_deviation(A, Sigma_eps)\n        results.append(d)\n\n    # Print the final result in the specified format.\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\ndef compute_deviation(A, Sigma_eps):\n    \"\"\"\n    Calculates the maximum deviation from the F=2T identity for a given VAR(1) model.\n\n    Args:\n        A (np.ndarray): The 2x2 autoregressive parameter matrix.\n        Sigma_eps (np.ndarray): The 2x2 covariance matrix of the Gaussian innovations.\n\n    Returns:\n        float: The maximum absolute deviation d = max(|F_XY - 2T_XY|, |F_YX - 2T_YX|).\n    \"\"\"\n    # Step 1: Solve the discrete Lyapunov equation for the stationary covariance Sigma.\n    # Sigma = A * Sigma * A.T + Sigma_eps\n    Sigma = solve_discrete_lyapunov(A, Sigma_eps)\n\n    # Step 2: Compute the lag-1 cross-covariance matrix needed for conditional variances.\n    A_Sigma = A @ Sigma\n\n    # --- Calculation for X -> Y direction ---\n\n    # Step 3: Compute the required conditional variances.\n    # Var(Y_t | Y_{t-1})\n    var_Y_given_Y_lag1 = Sigma[1, 1] - (A_Sigma[1, 1] ** 2) / Sigma[1, 1]\n    # Var(Y_t | X_{t-1}, Y_{t-1})\n    var_Y_given_XY_lag1 = Sigma_eps[1, 1]\n\n    # Step 4: Compute Granger causality and Transfer Entropy using numerically\n    # distinct but mathematically equivalent formulas to test the identity.\n    # F = log(V1/V2)\n    F_X_to_Y = np.log(var_Y_given_Y_lag1 / var_Y_given_XY_lag1)\n    # T = 0.5 * (log(V1) - log(V2))\n    T_X_to_Y = 0.5 * (np.log(var_Y_given_Y_lag1) - np.log(var_Y_given_XY_lag1))\n    \n    dev_X_to_Y = np.abs(F_X_to_Y - 2 * T_X_to_Y)\n\n    # --- Calculation for Y -> X direction ---\n    \n    # Step 5: Compute the required conditional variances.\n    # Var(X_t | X_{t-1})\n    var_X_given_X_lag1 = Sigma[0, 0] - (A_Sigma[0, 0] ** 2) / Sigma[0, 0]\n    # Var(X_t | X_{t-1}, Y_{t-1})\n    var_X_given_XY_lag1 = Sigma_eps[0, 0]\n\n    # Step 6: Compute Granger causality and Transfer Entropy.\n    F_Y_to_X = np.log(var_X_given_X_lag1 / var_X_given_XY_lag1)\n    T_Y_to_X = 0.5 * (np.log(var_X_given_X_lag1) - np.log(var_X_given_XY_lag1))\n\n    dev_Y_to_X = np.abs(F_Y_to_X - 2 * T_Y_to_X)\n\n    # Step 7: The result is the maximum of the two deviations.\n    return max(dev_X_to_Y, dev_Y_to_X)\n\nsolve()\n```", "id": "3293117"}, {"introduction": "在基础模型之上，本练习引入了一个常见的现实世界复杂性：同期的相关噪声。这种情况迫使我们区分滞后（时间延迟）因果关系和“瞬时”统计依赖关系[@problem_id:3293174]。这项练习对于培养对因果分析的细致解读至关重要，尤其是在像快速生物信号通路这样的系统中，其采样率可能不足以解析事件的真实时间顺序。", "problem": "考虑形成快速信号通路的两种分子，其活动以 $1$ 秒的分辨率记录，并联合建模为一个平稳的、零均值的二元一阶向量自回归（VAR(1)）过程。设状态向量为 $\\mathbf{Z}_{t} = \\begin{pmatrix} X_{t} \\\\ Y_{t} \\end{pmatrix}$，其演化方程为 $\\mathbf{Z}_{t} = \\mathbf{A} \\mathbf{Z}_{t-1} + \\mathbf{E}_{t}$，其中系数矩阵为 $\\mathbf{A} = \\begin{pmatrix} 0.6  0.0 \\\\ 0.4  0.5 \\end{pmatrix}$，且新息（残差）是联合高斯的、时间上是白噪声，并且同期相关，其协方差矩阵为 $\\boldsymbol{\\Sigma}_{e} = \\begin{pmatrix} 1.0  0.4 \\\\ 0.4  0.8 \\end{pmatrix}$。假设该过程是稳定且严平稳的。\n\n仅使用在线性高斯设定下将格兰杰因果（GC）定义为单步预测误差方差减少（即比较完整线性预测器与受限线性预测器）的基本原理，以及用于平稳协方差的离散时间李雅普诺夫方程，执行以下操作：\n\n1. 通过求解 $\\boldsymbol{\\Gamma} = \\mathbf{A} \\boldsymbol{\\Gamma} \\mathbf{A}^{\\top} + \\boldsymbol{\\Sigma}_{e}$ 来计算平稳协方差矩阵 $\\boldsymbol{\\Gamma} = \\mathbb{E}[\\mathbf{Z}_{t} \\mathbf{Z}_{t}^{\\top}]$。从 $\\boldsymbol{\\Gamma}$ 中，求出条件方差 $\\operatorname{Var}(X_{t-1} \\mid Y_{t-1})$。\n\n2. 使用方差减少的定义，计算从 $X$ 到 $Y$ 的滞后格兰杰因果。其计算方式为：在一个排除了 $X$ 历史信息的模型下，$Y_{t}$ 的单步预测误差方差与在完整 VAR(1) 模型下的该方差之比的自然对数。\n\n3. 独立地，计算 $X$ 和 $Y$ 之间的瞬时格兰杰因果（在线性高斯假设下的同期对称耦合度量），该因果仅由新息的同期相关性引起。\n\n报告这两个标量——首先是从 $X$ 到 $Y$ 的滞后格兰杰因果，其次是瞬时格兰杰因果——以自然对数单位（nats）表示。将每个值四舍五入到四位有效数字。\n\n最后，基于这些计算出的量，简要解释滞后项和瞬时项的分离如何为快速信号通路中的因果解释提供信息，在这些通路中，采样可能接近分子相互作用的特征时间尺度。", "solution": "该问题在科学上和数学上都是适定的。所有需要的数据和定义都已提供，参数与一个稳定的向量自回归过程一致，任务也明确指定。其基本概念——向量自回归（VAR）、离散时间李雅普诺夫方程以及通过预测误差方差定义的格兰杰因果——是时间序列分析及其在计算系统生物学等领域应用的常规方法。因此，我们可以进行完整求解。\n\nVAR($1$)过程的状态向量为 $\\mathbf{Z}_{t} = \\begin{pmatrix} X_{t} \\\\ Y_{t} \\end{pmatrix}$，其演化方程为 $\\mathbf{Z}_{t} = \\mathbf{A} \\mathbf{Z}_{t-1} + \\mathbf{E}_{t}$。给定的矩阵是：\n$$\n\\mathbf{A} = \\begin{pmatrix} 0.6  0.0 \\\\ 0.4  0.5 \\end{pmatrix}, \\quad \\boldsymbol{\\Sigma}_{e} = \\mathbb{E}[\\mathbf{E}_{t} \\mathbf{E}_{t}^{\\top}] = \\begin{pmatrix} 1.0  0.4 \\\\ 0.4  0.8 \\end{pmatrix}\n$$\n\n通过检查 $\\mathbf{A}$ 的特征值可以确认过程的稳定性。由于 $\\mathbf{A}$ 是一个下三角矩阵，其特征值是其对角线元素，即 $\\lambda_1 = 0.6$ 和 $\\lambda_2 = 0.5$。因为 $|\\lambda_1|  1$ 和 $|\\lambda_2|  1$ 都成立，所以该过程是稳定的，并具有唯一的平稳分布。\n\n**1. 计算平稳协方差矩阵 $\\boldsymbol{\\Gamma}$**\n\n平稳协方差矩阵 $\\boldsymbol{\\Gamma} = \\mathbb{E}[\\mathbf{Z}_{t} \\mathbf{Z}_{t}^{\\top}]$ 是离散时间李雅普诺夫方程的解：\n$$\n\\boldsymbol{\\Gamma} = \\mathbf{A} \\boldsymbol{\\Gamma} \\mathbf{A}^{\\top} + \\boldsymbol{\\Sigma}_{e}\n$$\n设 $\\boldsymbol{\\Gamma} = \\begin{pmatrix} \\gamma_{11}  \\gamma_{12} \\\\ \\gamma_{21}  \\gamma_{22} \\end{pmatrix}$。由于 $\\boldsymbol{\\Gamma}$ 是一个协方差矩阵，它是对称的，所以 $\\gamma_{12} = \\gamma_{21}$。将矩阵代入方程中：\n$$\n\\begin{pmatrix} \\gamma_{11}  \\gamma_{12} \\\\ \\gamma_{12}  \\gamma_{22} \\end{pmatrix} = \\begin{pmatrix} 0.6  0.0 \\\\ 0.4  0.5 \\end{pmatrix} \\begin{pmatrix} \\gamma_{11}  \\gamma_{12} \\\\ \\gamma_{12}  \\gamma_{22} \\end{pmatrix} \\begin{pmatrix} 0.6  0.4 \\\\ 0.0  0.5 \\end{pmatrix} + \\begin{pmatrix} 1.0  0.4 \\\\ 0.4  0.8 \\end{pmatrix}\n$$\n$$\n\\begin{pmatrix} \\gamma_{11}  \\gamma_{12} \\\\ \\gamma_{12}  \\gamma_{22} \\end{pmatrix} = \\begin{pmatrix} 0.36\\gamma_{11}  0.24\\gamma_{11} + 0.3\\gamma_{12} \\\\ 0.24\\gamma_{11} + 0.3\\gamma_{12}  0.16\\gamma_{11} + 0.4\\gamma_{12} + 0.25\\gamma_{22} \\end{pmatrix} + \\begin{pmatrix} 1.0  0.4 \\\\ 0.4  0.8 \\end{pmatrix}\n$$\n这产生了一个关于 $\\boldsymbol{\\Gamma}$ 元素的线性方程组：\n1. $\\gamma_{11} = 0.36\\gamma_{11} + 1.0 \\implies 0.64\\gamma_{11} = 1.0 \\implies \\gamma_{11} = \\frac{1.0}{0.64} = 1.5625 = \\frac{25}{16}$。\n2. $\\gamma_{12} = 0.24\\gamma_{11} + 0.3\\gamma_{12} + 0.4 \\implies 0.7\\gamma_{12} = 0.24(1.5625) + 0.4 = 0.375 + 0.4 = 0.775 \\implies \\gamma_{12} = \\frac{0.775}{0.7} = \\frac{31}{28}$。\n3. $\\gamma_{22} = 0.16\\gamma_{11} + 0.4\\gamma_{12} + 0.25\\gamma_{22} + 0.8 \\implies 0.75\\gamma_{22} = 0.16\\gamma_{11} + 0.4\\gamma_{12} + 0.8$。\n代入 $\\gamma_{11}$ 和 $\\gamma_{12}$ 的值：\n$0.75\\gamma_{22} = 0.16(\\frac{25}{16}) + 0.4(\\frac{31}{28}) + 0.8 = 0.25 + \\frac{31}{70} + 0.8 = 1.05 + \\frac{31}{70} = \\frac{21}{20} + \\frac{31}{70} = \\frac{147+62}{140} = \\frac{209}{140}$。\n$\\gamma_{22} = \\frac{209}{140} \\cdot \\frac{1}{0.75} = \\frac{209}{140} \\cdot \\frac{4}{3} = \\frac{209}{105}$。\n\n所以，平稳协方差矩阵是 $\\boldsymbol{\\Gamma} = \\begin{pmatrix} \\frac{25}{16}  \\frac{31}{28} \\\\ \\frac{31}{28}  \\frac{209}{105} \\end{pmatrix}$。\n\n接下来，我们计算条件方差 $\\operatorname{Var}(X_{t-1} \\mid Y_{t-1})$。由于该过程是平稳且高斯的，我们使用二元正态分布中条件方差的标准公式：\n$$\n\\operatorname{Var}(X_{t-1} \\mid Y_{t-1}) = \\operatorname{Var}(X_{t-1}) - \\frac{\\operatorname{Cov}(X_{t-1}, Y_{t-1})^2}{\\operatorname{Var}(Y_{t-1})} = \\gamma_{11} - \\frac{\\gamma_{12}^2}{\\gamma_{22}}\n$$\n$$\n\\operatorname{Var}(X_{t-1} \\mid Y_{t-1}) = \\frac{25}{16} - \\frac{(31/28)^2}{209/105} = \\frac{25}{16} - \\frac{961/784}{209/105} = \\frac{25}{16} - \\frac{961}{784} \\frac{105}{209}\n$$\n化简分数：$\\frac{961 \\cdot 105}{784 \\cdot 209} = \\frac{14415}{23408}$。\n$$\n\\operatorname{Var}(X_{t-1} \\mid Y_{t-1}) = \\frac{25}{16} - \\frac{14415}{23408} = \\frac{25 \\cdot 1463 - 14415}{23408} = \\frac{36575 - 14415}{23408} = \\frac{22160}{23408} = \\frac{1385}{1463}\n$$\n\n**2. 计算滞后格兰杰因果 ($GC_{X \\to Y}$)**\n\n从 $X$到 $Y$ 的滞后格兰杰因果定义为预测误差方差之比的自然对数：\n$$\nGC_{X \\to Y} = \\ln \\left( \\frac{\\sigma^2_{\\text{restr}}}{\\sigma^2_{\\text{full}}} \\right)\n$$\n预测 $Y_t$ 的完整模型使用了 $X$ 和 $Y$ 的历史信息：\n$Y_t = A_{21}X_{t-1} + A_{22}Y_{t-1} + E_{2,t} = 0.4 X_{t-1} + 0.5 Y_{t-1} + E_{2,t}$。\n完整模型的单步预测误差方差是新息项 $E_{2,t}$ 的方差，即 $\\boldsymbol{\\Sigma}_e$ 的 $(2,2)$ 元素。\n$$\n\\sigma^2_{\\text{full}} = \\operatorname{Var}(E_{2,t}) = (\\boldsymbol{\\Sigma}_{e})_{22} = 0.8\n$$\n受限模型仅使用 $Y_t$ 自身历史信息来预测它。预测误差的方差 $\\sigma^2_{\\text{restr}} = \\operatorname{Var}(Y_t \\mid Y_{t-1}, Y_{t-2}, \\dots)$，对于一个 VAR($1$) 过程，简化为从 $Y_{t-1}$ 预测 $Y_t$ 时的误差方差。这个误差方差可以优雅地表示为：\n$$\n\\sigma^2_{\\text{restr}} = A_{21}^2 \\operatorname{Var}(X_{t-1} \\mid Y_{t-1}) + (\\boldsymbol{\\Sigma}_{e})_{22}\n$$\n使用第1部分计算的条件方差：\n$$\n\\sigma^2_{\\text{restr}} = (0.4)^2 \\left(\\frac{1385}{1463}\\right) + 0.8 = 0.16 \\left(\\frac{1385}{1463}\\right) + 0.8 = \\frac{4}{25}\\frac{1385}{1463} + \\frac{4}{5} = \\frac{221.6}{1463} + \\frac{1170.4}{1463} = \\frac{1392}{1463}\n$$\n现在我们可以计算格兰杰因果：\n$$\nGC_{X \\to Y} = \\ln \\left( \\frac{1392/1463}{0.8} \\right) = \\ln \\left( \\frac{1392}{1463 \\cdot 0.8} \\right) = \\ln \\left( \\frac{1392}{1170.4} \\right) \\approx \\ln(1.189337) \\approx 0.17340\n$$\n保留四位有效数字，$GC_{X \\to Y} = 0.1734$ nats。\n\n**3. 计算瞬时格兰杰因果 ($GC_{X \\leftrightarrow Y}$)**\n\n瞬时因果量化了在知道另一个变量的同期新息的情况下，一个变量的预测误差可以减少的程度。它是一个对称的度量，源于新息协方差矩阵 $\\boldsymbol{\\Sigma}_e$ 的非对角线项。它的计算方法是新息方差与条件新息方差之比的对数。\n对于 $X$ 和 $Y$ 之间的效应，我们比较来自完整滞后模型的 $Y_t$ 的预测误差方差 $\\operatorname{Var}(E_{2,t})$，与同时给定同期新息 $E_{1,t}$ 时的误差方差 $\\operatorname{Var}(E_{2,t} \\mid E_{1,t})$。\n$$\nGC_{X \\leftrightarrow Y} = \\ln \\left( \\frac{\\operatorname{Var}(E_{2,t})}{\\operatorname{Var}(E_{2,t} \\mid E_{1,t})} \\right)\n$$\n条件方差由 $\\boldsymbol{\\Sigma}_e$ 的元素计算得出：\n$$\n\\operatorname{Var}(E_{2,t} \\mid E_{1,t}) = (\\boldsymbol{\\Sigma}_{e})_{22} - \\frac{(\\boldsymbol{\\Sigma}_{e})_{21}^2}{(\\boldsymbol{\\Sigma}_{e})_{11}} = 0.8 - \\frac{(0.4)^2}{1.0} = 0.8 - 0.16 = 0.64\n$$\n因此，瞬时因果为：\n$$\nGC_{X \\leftrightarrow Y} = \\ln \\left( \\frac{0.8}{0.64} \\right) = \\ln(1.25) \\approx 0.22314\n$$\n保留四位有效数字，$GC_{X \\leftrightarrow Y} = 0.2231$ nats。\n\n**4. 因果解释**\n\n滞后格兰杰因果 $GC_{X \\to Y} \\approx 0.1734$ 度量了在 $1$ 秒的采样时间尺度上，从 $X$ 的过去到 $Y$ 的现在的有向影响。这个非零值是预料之中的，因为系数 $A_{21}=0.4$ 是非零的。\n\n瞬时格兰杰因果 $GC_{X \\leftrightarrow Y} \\approx 0.2231$ 量化了 $X_t$ 和 $Y_t$ 之间无法用其历史值解释的统计依赖性。这种同期相关性源于相关的新息（$\\Sigma_{e,12} = 0.4 \\neq 0$）。\n\n在快速信号通路的背景下，一个非零的、特别是数值较大的瞬时因果项具有关键意义。真实的分子相互作用不是瞬时的，而是在有限的时间尺度上发生的。如果采样间隔（此处为 $1$ 秒）相对于实际相互作用速度来说是粗糙的，那么一个快速的因果影响（例如，在毫秒内发生的 $X \\to Y$）将被捕获在单个采样区间内。VAR 模型受限于离散时间滞后，无法解析这种子采样动态，并将快速的滞后效应错误地归因于新息中的同期相关性。因此，一个较大的瞬时因果项可能表明：(1) 存在一个真实的因果联系，其发生时间尺度快于采样率，或者 (2) 存在一个未测量的共同驱动因素，在采样间隔内同时影响 $X$ 和 $Y$。\n\n在这个问题中，瞬时因果（$0.2231$ nats）大于滞后因果（$0.1734$ nats）。这强烈表明 $1$ 秒的采样分辨率不足以完全解析系统的因果动态。$X$ 和 $Y$ 之间相互作用的很大一部分发生在子采样时间尺度上，导致对滞后因果影响的低估，并将其错误地归因于对称的、非因果的瞬时项。为了区分快速因果联系和共同驱动因素，需要分析以更高频率采样的数据。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.1734  0.2231\n\\end{pmatrix}\n}\n$$", "id": "3293174"}, {"introduction": "最后的这个练习将解决因果推断中最关键的挑战之一：隐藏混杂因素。通过模拟，你将亲眼看到简单的双变量分析如何错误地推断出两个变量之间的因果联系，而实际上这两个变量是由第三个未观察到的因素驱动的[@problem_id:3293189]。这项练习展示了条件分析（部分格兰杰因果关系和条件传递熵）在避免此类虚假结论和识别真实直接关系方面的强大作用和必要性。", "problem": "考虑一个用于三个共同演化的生物信号的一阶线性高斯向量自回归模型（VAR(1)），这三个信号分别代表一个隐藏的调控因子 $Z$ 和两个观测到的基因表达时间序列 $X$ 和 $Y$。该系统演化如下：在每个离散时间 $t$，状态 $(Z_t, X_t, Y_t)$ 线性依赖于滞后-1 的状态 $(Z_{t-1}, X_{t-1}, Y_{t-1})$，并加上具有指定标准差的零均值独立高斯新息。对于下方的每个参数集，均假设模型是稳定的（谱半径严格小于 $1$）。\n\n您的任务是编写一个完整的程序，对于每个指定的参数集，从具有如下给定系数的 VAR(1) 过程中模拟 $T$ 个点（在丢弃 $T_0$ 个点的“预烧”期之后），然后计算 $X$ 和 $Y$ 之间的以下方向性度量：\n- 从 $X$到 $Y$ 的双变量格兰杰因果关系（GC），记为 $GC_{X \\to Y}^{(biv)}$，以及从 $Y$ 到 $X$ 的双变量格兰杰因果关系，记为 $GC_{Y \\to X}^{(biv)}$。每个度量仅使用被测试对的滞后-1 历史进行计算，并排除 $Z$。\n- 以 $Z$ 为条件的从 $X$ 到 $Y$ 的偏格兰杰因果关系（GC），记为 $GC_{X \\to Y \\mid Z}^{(par)}$，以及以 $Z$ 为条件的从 $Y$ 到 $X$ 的偏格兰杰因果关系，记为 $GC_{Y \\to X \\mid Z}^{(par)}$。每个度量均使用滞后-1 历史进行计算，同时以 $Z$ 的滞后-1 为条件。\n- 给定 $Z$ 时，从 $X$到 $Y$ 的条件转移熵（TE），记为 $TE_{X \\to Y \\mid Z}$，以及给定 $Z$ 时，从 $Y$ 到 $X$ 的条件转移熵，记为 $TE_{Y \\to X \\mid Z}$。每个度量均针对滞后-1 历史计算，并使用自然对数。\n\n所有量均以自然单位（nats）计算。您应将每个度量视为一个非负的信息论得分。对于每个测试用例和每个方向，通过如下阈值化方法将六个得分中的每一个转换为二元检测决策：\n- 对于任何 GC 度量 $GC$，如果 $GC  \\tau_{\\mathrm{GC}}$，则声明检测到，否则未检测到。\n- 对于任何 TE 度量 $TE$，如果 $TE  \\tau_{\\mathrm{TE}}$，则声明检测到，否则未检测到。\n\n使用 $T = 15000$ 和 $T_0 = 1000$。使用 $\\tau_{\\mathrm{GC}} = 0.02$ 和 $\\tau_{\\mathrm{TE}} = 0.01$。为了可复现性，请使用固定的伪随机种子。\n\n模型设定。对于每种情况，根据具有以下方程的线性高斯 VAR(1) 系统进行模拟：\n$$\n\\begin{aligned}\nZ_t = a \\, Z_{t-1} + \\varepsilon_{Z,t}, \\\\\nX_t = b_X \\, X_{t-1} + d \\, Y_{t-1} + g_{ZX} \\, Z_{t-1} + \\varepsilon_{X,t}, \\\\\nY_t = b_Y \\, Y_{t-1} + c \\, X_{t-1} + g_{ZY} \\, Z_{t-1} + \\varepsilon_{Y,t},\n\\end{aligned}\n$$\n其中 $\\varepsilon_{Z,t} \\sim \\mathcal{N}(0, \\sigma_Z^2)$、$\\varepsilon_{X,t} \\sim \\mathcal{N}(0, \\sigma_X^2)$ 和 $\\varepsilon_{Y,t} \\sim \\mathcal{N}(0, \\sigma_Y^2)$ 在时间和分量上都是独立的。\n\n测试套件。模拟以下三种情况，每种情况都具有指定的系数和新息标准差：\n- 情况 1（纯粹的隐藏混杂，无直接因果关系）：$a = 0.6$，$b_X = 0.2$，$b_Y = 0.2$，$g_{ZX} = 0.8$，$g_{ZY} = 0.8$，$c = 0.0$，$d = 0.0$，$\\sigma_Z = 1.0$，$\\sigma_X = 0.8$，$\\sigma_Y = 0.8$。\n- 情况 2（隐藏混杂加上真实的 $X \\to Y$）：$a = 0.5$，$b_X = 0.2$，$b_Y = 0.2$，$g_{ZX} = 0.5$，$g_{ZY} = 0.5$，$c = 0.3$，$d = 0.0$，$\\sigma_Z = 1.0$，$\\sigma_X = 0.8$，$\\sigma_Y = 0.8$。\n- 情况 3（隐藏混杂加上真实的 $Y \\to X$）：$a = 0.5$，$b_X = 0.2$，$b_Y = 0.2$，$g_{ZX} = 0.5$，$g_{ZY} = 0.5$，$c = 0.0$，$d = 0.35$，$\\sigma_Z = 1.0$，$\\sigma_X = 0.8$，$\\sigma_Y = 0.8$。\n\n估计协议。对于每种情况：\n1. 模拟 $T_0 + T$ 个点，并丢弃前 $T_0$ 个点。\n2. 通过为 $Y_t$ 拟合两个线性预测器来计算 $GC_{X \\to Y}^{(biv)}$：一个仅使用 $Y_{t-1}$ 的受限模型和一个同时使用 $Y_{t-1}$ 和 $X_{t-1}$ 的完整模型；通过交换 $X$ 和 $Y$ 的角色，类似地计算 $GC_{Y \\to X}^{(biv)}$。\n3. 通过为 $Y_t$ 拟合两个线性预测器来计算 $GC_{X \\to Y \\mid Z}^{(par)}$：一个使用 $Y_{t-1}$ 和 $Z_{t-1}$ 的受限模型和一个使用 $Y_{t-1}$、$Z_{t-1}$ 和 $X_{t-1}$ 的完整模型；通过以 $Z_{t-1}$ 为条件并测试 $Y_{t-1}$ 作为 $X_t$ 的新增预测变量，类似地计算 $GC_{Y \\to X \\mid Z}^{(par)}$。\n4. 使用与步骤 3 中相同的受限和完整预测变量集以及自然对数来计算 $TE_{X \\to Y \\mid Z}$ 和 $TE_{Y \\to X \\mid Z}$。\n\n在所有线性拟合中，对滞后-1 预测变量使用不含截距的普通最小二乘法。通过将负的估计值截断为 $0$ 来将所得得分视为非负。\n\n最终输出格式。对于每种情况，按以下固定顺序生成六个二进制整数：\n$[ \\mathbf{1}\\{GC_{X \\to Y}^{(biv)}  \\tau_{\\mathrm{GC}}\\}, \\mathbf{1}\\{GC_{X \\to Y \\mid Z}^{(par)}  \\tau_{\\mathrm{GC}}\\}, \\mathbf{1}\\{TE_{X \\to Y \\mid Z}  \\tau_{\\mathrm{TE}}\\}, \\mathbf{1}\\{GC_{Y \\to X}^{(biv)}  \\tau_{\\mathrm{GC}}\\}, \\mathbf{1}\\{GC_{Y \\to X \\mid Z}^{(par)}  \\tau_{\\mathrm{GC}}\\}, \\mathbf{1}\\{TE_{Y \\to X \\mid Z}  \\tau_{\\mathrm{TE}}\\} ]$。\n将三种情况的结果按用例顺序聚合到一个包含 $18$ 个整数的单个扁平列表中。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,\\dots,r_{18}]$）。", "solution": "该问题被认为是有效的，因为它具有科学依据、是适定的且客观的。它提出了系统生物学中的一个标准计算任务，涉及向量自回归（VAR）模型的模拟以及随后应用明确定义的因果推断技术，即格兰杰因果关系和转移熵。所有参数、模型和程序都得到了精确指定，从而可以得到唯一且有意义的解。\n\n解法将通过以下步骤来构建：\n1.  对于每个测试用例，从指定的一阶线性高斯向量自回归模型（VAR(1)）中模拟一个三变量时间序列 $(Z_t, X_t, Y_t)$。\n2.  根据模拟数据，估计六个指定的有向连接性度量：双变量格兰杰因果关系（$GC^{(biv)}$）、偏格兰杰因果关系（$GC^{(par)}$）和条件转移熵（$TE$）。\n3.  通过应用给定的阈值，将每个估计得分转换为二元检测结果。\n\n### 基于原理的设计\n\n#### 1. VAR(1) 模型与模拟\n系统的动力学由一个 VAR(1) 过程描述。一组随时间变化的变量 $\\mathbf{v}_t = [Z_t, X_t, Y_t]^T$ 根据以下线性随机差分方程演化：\n$$\n\\mathbf{v}_t = \\mathbf{A} \\mathbf{v}_{t-1} + \\boldsymbol{\\varepsilon}_t\n$$\n其中 $\\mathbf{v}_{t-1}$ 是系统在前一个时间步的状态，$\\mathbf{A}$ 是定义线性依赖关系的系数矩阵，而 $\\boldsymbol{\\varepsilon}_t$ 是一个白噪声项（新息）向量。根据问题的方程，系数矩阵 $\\mathbf{A}$ 为：\n$$\n\\mathbf{A} = \\begin{pmatrix}\na  0  0 \\\\\ng_{ZX}  b_X  d \\\\\ng_{ZY}  c  b_Y\n\\end{pmatrix}\n$$\n新息向量 $\\boldsymbol{\\varepsilon}_t = [\\varepsilon_{Z,t}, \\varepsilon_{X,t}, \\varepsilon_{Y,t}]^T$ 从均值为零、对角协方差矩阵为 $\\boldsymbol{\\Sigma}_{\\varepsilon} = \\text{diag}(\\sigma_Z^2, \\sigma_X^2, \\sigma_Y^2)$ 的多元正态分布中抽取。问题指出模型是稳定的，这意味着 $\\mathbf{A}$ 的谱半径（其特征值的最大模）小于 $1$。\n\n模拟从初始状态 $\\mathbf{v}_0 = [0, 0, 0]^T$ 开始，并进行 $T_0 + T$ 个时间步。在每个时间步 $t$，生成一个噪声向量 $\\boldsymbol{\\varepsilon}_t$，并计算下一个状态 $\\mathbf{v}_t$。前 $T_0$ 个点构成一个“预烧”期，它们被丢弃以确保模拟序列是该过程稳态分布的一个实现，且不受任意初始状态的影响。余下的 $T$ 个点用于分析。\n\n#### 2. 因果推断度量\n问题要求计算格兰杰因果关系（GC）和转移熵（TE）。\n\n**格兰杰因果关系（GC）：** 格兰杰因果关系的原理是，如果时间序列 $X$ 的过去值包含有助于比仅使用 $Y$ 的过去值更好地预测 $Y$ 未来的信息，那么 $X$ 就“格兰杰导致”另一个时间序列 $Y$。对于线性 VAR 模型，这通过比较来自两个线性模型的预测误差方差来量化：\n1.  一个**受限模型**，仅使用 $Y$ 自身的过去来预测其当前值。\n2.  一个**完整模型**，使用 $Y$ 和 $X$ 两者的过去来预测 $Y$ 的当前值。\n\nGC 得分定义为这两个模型的残差方差之比的自然对数：\n$$\nGC_{X \\to Y} = \\ln \\left( \\frac{\\text{Var}(\\text{error}_{\\text{restricted}})}{\\text{Var}(\\text{error}_{\\text{full}})} \\right) = \\ln \\left( \\frac{\\hat{\\sigma}_r^2}{\\hat{\\sigma}_f^2} \\right)\n$$\n一个正的 $GC$ 值表示 $X$ 改善了对 $Y$ 的预测。\n\n-   **双变量 GC（$GC_{X \\to Y}^{(biv)}$）：** 这仅使用对 $(X, Y)$ 进行计算。受限模型为 $Y_t \\sim Y_{t-1}$，完整模型为 $Y_t \\sim Y_{t-1} + X_{t-1}$。\n-   **偏 GC（$GC_{X \\to Y \\mid Z}^{(par)}$）：** 这是一个条件度量。它在考虑了第三个变量 $Z$ 的影响后，测试从 $X$ 到 $Y$ 的直接影响。在这里，$Z$ 的过去被包含在两个模型中。受限模型为 $Y_t \\sim Y_{t-1} + Z_{t-1}$，完整模型为 $Y_t \\sim Y_{t-1} + Z_{t-1} + X_{t-1}$。这个度量对于区分直接因果关系和由共同驱动因素（混杂因素）引起的伪相关至关重要。\n\n**条件转移熵（TE）：** 在给定 $Z$ 的条件下，从 $X$ 到 $Y$ 的转移熵量化了在已知 $Y$ 和 $Z$ 的历史情况下，通过知晓 $X_{t-1}$ 对 $Y_t$ 不确定性的减少量。对于线性高斯 VAR(1) 过程，它与偏格兰杰因果关系直接相关：\n$$\nTE_{X \\to Y \\mid Z} = \\frac{1}{2} GC_{X \\to Y \\mid Z}^{(par)}\n$$\n问题要求使用与偏 GC 相同的模型来计算这个量，但对所得分数的阈值处理方式不同。\n\n#### 3. 估计与决策\n如指定的那样，残差方差 $\\hat{\\sigma}_r^2$ 和 $\\hat{\\sigma}_f^2$ 使用不含截距的普通最小二乘（OLS）回归从模拟数据中估计。对于一个通用线性模型 $\\mathbf{y} = \\mathbf{M}\\boldsymbol{\\beta} + \\boldsymbol{\\epsilon}$，OLS 找到最小化残差平方和 $\\|\\boldsymbol{\\epsilon}\\|^2 = \\|\\mathbf{y} - \\mathbf{M}\\boldsymbol{\\beta}\\|^2$ 的系数向量 $\\boldsymbol{\\beta}$。这个和，我们称之为 $SSR$，用于计算这些度量。由于受限模型和完整模型的样本数量相同，GC/TE 得分简化为 $\\ln(SSR_r / SSR_f)$。由于 OLS 在嵌套模型上的性质，$SSR_f \\le SSR_r$，所以得分是非负的。按照指示，我们将任何由浮点误差引起的微小负值截断为 $0$。\n\n对于六个计算出的得分中的每一个，都会做出一个二元决策：\n-   如果 $GC  \\tau_{\\mathrm{GC}} = 0.02$，则检测到因果联系（输出 $1$）。否则，未检测到联系（输出 $0$）。\n-   如果 $TE  \\tau_{\\mathrm{TE}} = 0.01$，则检测到因果联系（输出 $1$）。否则，未检测到联系（输出 $0$）。\n\n最终输出是这 $18$ 个二元决策（$3$ 个案例，每个案例 $6$ 个）聚合到一个单一列表中的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and analysis for all test cases.\n    \"\"\"\n    # Define problem parameters\n    T = 15000\n    T0 = 1000\n    TAU_GC = 0.02\n    TAU_TE = 0.01\n    SEED = 42\n\n    # Define test cases as a list of dictionaries\n    test_cases = [\n        {\n            'name': 'Case 1: Hidden Confounding',\n            'a': 0.6, 'bX': 0.2, 'bY': 0.2, 'gZX': 0.8, 'gZY': 0.8, \n            'c': 0.0, 'd': 0.0, 'sigmaZ': 1.0, 'sigmaX': 0.8, 'sigmaY': 0.8\n        },\n        {\n            'name': 'Case 2: Confounding + X-Y',\n            'a': 0.5, 'bX': 0.2, 'bY': 0.2, 'gZX': 0.5, 'gZY': 0.5, \n            'c': 0.3, 'd': 0.0, 'sigmaZ': 1.0, 'sigmaX': 0.8, 'sigmaY': 0.8\n        },\n        {\n            'name': 'Case 3: Confounding + Y-X',\n            'a': 0.5, 'bX': 0.2, 'bY': 0.2, 'gZX': 0.5, 'gZY': 0.5, \n            'c': 0.0, 'd': 0.35, 'sigmaZ': 1.0, 'sigmaX': 0.8, 'sigmaY': 0.8\n        }\n    ]\n\n    rng = np.random.default_rng(SEED)\n    all_results = []\n\n    for params in test_cases:\n        # Step 1: Simulate the VAR(1) process\n        v_total = simulate_var1(params, T + T0, rng)\n        data = v_total[T0:] # Discard burn-in\n\n        # Extract time series for Z, X, Y\n        Z, X, Y = data[:, 0], data[:, 1], data[:, 2]\n\n        # Prepare lagged data for regression\n        # Target variables (t)\n        Y_t = Y[1:]\n        X_t = X[1:]\n        # Predictor variables (t-1)\n        Z_lag1 = Z[:-1].reshape(-1, 1)\n        X_lag1 = X[:-1].reshape(-1, 1)\n        Y_lag1 = Y[:-1].reshape(-1, 1)\n\n        # Step 2  3: Compute measures and apply thresholds\n\n        # Direction X - Y\n        # GC_biv(X - Y)\n        gc_xy_biv = compute_gc(target_vec=Y_t, past_target=Y_lag1, driver=X_lag1)\n        \n        # GC_par(X - Y | Z)\n        gc_xy_par = compute_gc(target_vec=Y_t, past_target=Y_lag1, driver=X_lag1, condition=Z_lag1)\n        # TE(X -> Y | Z) for linear Gaussian systems is 0.5 * GC\n        te_xy_cond = 0.5 * gc_xy_par\n\n        # Direction Y - X\n        # GC_biv(Y - X)\n        gc_yx_biv = compute_gc(target_vec=X_t, past_target=X_lag1, driver=Y_lag1)\n        \n        # GC_par(Y - X | Z)\n        gc_yx_par = compute_gc(target_vec=X_t, past_target=X_lag1, driver=Y_lag1, condition=Z_lag1)\n        # TE(Y -> X | Z) for linear Gaussian systems is 0.5 * GC\n        te_yx_cond = 0.5 * gc_yx_par\n\n        # Apply thresholds to get binary decisions\n        case_results = [\n            1 if gc_xy_biv > TAU_GC else 0,\n            1 if gc_xy_par > TAU_GC else 0,\n            1 if te_xy_cond > TAU_TE else 0,\n            1 if gc_yx_biv > TAU_GC else 0,\n            1 if gc_yx_par > TAU_GC else 0,\n            1 if te_yx_cond > TAU_TE else 0\n        ]\n        all_results.extend(case_results)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef simulate_var1(params, num_points, rng):\n    \"\"\"\n    Simulates a 3-variable VAR(1) process.\n    Returns a numpy array of shape (num_points, 3).\n    \"\"\"\n    # Coefficient matrix A\n    A = np.array([\n        [params['a'], 0.0, 0.0],\n        [params['gZX'], params['bX'], params['d']],\n        [params['gZY'], params['c'], params['bY']]\n    ])\n    \n    # Standard deviations of innovations\n    noise_std = np.array([params['sigmaZ'], params['sigmaX'], params['sigmaY']])\n    \n    # Initialize the time series data array\n    v = np.zeros((num_points, 3))\n    \n    # Iterate through time to generate the series\n    for t in range(1, num_points):\n        epsilon = rng.normal(loc=0.0, scale=noise_std)\n        v[t, :] = A @ v[t-1, :] + epsilon\n        \n    return v\n\ndef compute_gc(target_vec, past_target, driver, condition=None):\n    \"\"\"\n    Computes a Granger Causality score.\n    \n    Args:\n        target_vec (np.array): The vector of the target variable at time t.\n        past_target (np.array): The vector of the target variable at time t-1.\n        driver (np.array): The vector of the driver variable at time t-1.\n        condition (np.array, optional): Conditioning variable(s) at t-1.\n    \n    Returns:\n        float: The computed GC score.\n    \"\"\"\n    # Restricted model regression\n    if condition is None:\n        X_restr = past_target\n    else:\n        X_restr = np.hstack([past_target, condition])\n    \n    _, res_r, _, _ = np.linalg.lstsq(X_restr, target_vec, rcond=None)\n    \n    # Full model regression\n    if condition is None:\n        X_full = np.hstack([past_target, driver])\n    else:\n        X_full = np.hstack([past_target, condition, driver])\n        \n    _, res_f, _, _ = np.linalg.lstsq(X_full, target_vec, rcond=None)\n    \n    # The lstsq function returns the sum of squared residuals in an array\n    ssr_r = res_r[0]\n    ssr_f = res_f[0]\n\n    # Handle cases where full model performs no better due to precision\n    if ssr_f >= ssr_r:\n        return 0.0\n    \n    # Calculate GC score in nats and truncate to be non-negative\n    score = np.log(ssr_r / ssr_f)\n    return np.maximum(0.0, score)\n\n# Execute the solution\nsolve()\n```", "id": "3293189"}]}