{"hands_on_practices": [{"introduction": "理论是指导，但实践才能出真知。本节的第一个练习旨在将双层优化的核心概念转化为可执行的代码。通过为一个简化的代谢网络枚举所有可能的基因敲除策略，并利用通量平衡分析（FBA）模拟细胞的响应，你将亲手构建并解决一个菌株设计问题[@problem_id:3290717]。这个练习将帮助你巩固对双层优化框架中“上层设计”与“下层优化”相互作用的直观理解。", "problem": "您将处理一个用于菌株设计的双层优化玩具案例研究，该案例研究建立在通量平衡分析（FBA）的框架之上。该生物体由一个最小代谢网络表示，该网络具有稳态质量平衡和不可逆反应边界。该双层设计问题模拟了上层工程师选择反应敲除，以在下层生物体达到最佳生长时最大化最坏情况下的产物生成。您必须实现一个完整的、可运行的程序，该程序评估所有允许的敲除组合下的最坏情况产物生成，并返回最佳选择。\n\n基本依据与假设：\n- 通量平衡分析（FBA）对细胞内代谢物使用稳态近似，从而得出形如 $$S\\,\\mathbf{v}=\\mathbf{0}$$ 的线性等式，其中 $$S$$ 是化学计量矩阵，$$\\mathbf{v}$$ 是反应通量向量。\n- 每个反应 $$i$$ 的反应通量受不可逆约束 $$\\ell_i \\le v_i \\le u_i$$ 的限制。\n- 生物体的生长由生物质反应通量 $$v_2$$ 建模，生物体在稳态下会最大化该通量。\n- 我们假设下层生物体可能会在多个生长最优的通量分布中进行选择；在此，我们评估悲观情况，即在所有达到最大生长的通量向量中，生物体选择使产物分泌通量 $$v_3$$ 最小化的那一个。这对应于一个字典序双层问题：首先最大化 $$v_2$$，然后在相同约束条件下，并附加一个强制 $$v_2=v_2^\\star$$ 的等式，最小化 $$v_3$$，其中 $$v_2^\\star$$ 是从第一步获得的最优生长速率。\n\n网络定义：\n- 反应索引为 $$R_0, R_1, R_2, R_3, R_4$$，其通量分别为 $$v_0, v_1, v_2, v_3, v_4$$：\n  - $$R_0$$：葡萄糖摄取 $$G_{\\mathrm{ext}} \\rightarrow G$$。\n  - $$R_1$$：氧气摄取 $$O_{\\mathrm{ext}} \\rightarrow O$$。\n  - $$R_2$$：生物质生长 $$G + 2\\,O \\rightarrow \\mathrm{Biomass}$$。\n  - $$R_3$$：产物生成 $$G \\rightarrow P_{\\mathrm{ext}}$$。\n  - $$R_4$$：废物生成 $$G \\rightarrow W_{\\mathrm{ext}}$$。\n- 关于细胞内葡萄糖 $$G$$ 和氧气 $$O$$ 的内部稳态质量平衡等式：\n  - $$v_0 - v_2 - v_3 - v_4 = 0$$，\n  - $$v_1 - 2\\,v_2 = 0$$。\n- 边界条件：\n  - 固定葡萄糖摄取：$$v_0 \\in [G_{\\mathrm{fixed}},\\,G_{\\mathrm{fixed}}]$$，其中 $$G_{\\mathrm{fixed}}$$ 是一个指定的非负数。\n  - 氧气摄取：$$v_1 \\in [0,\\,O_{\\max}]$$，其中 $$O_{\\max}$$ 是一个指定的非负数。\n  - 生物质生长最小存活率：$$v_2 \\in [\\gamma,\\,U_2]$$，其中 $$\\gamma \\ge 0$$ 且 $$U_2$$ 是一个较大的上界（您可以选择 $$U_2=100$$）。\n  - 产物和废物通量：$$v_3 \\in [0,\\,U_3]$$, $$v_4 \\in [0,\\,U_4]$$，具有较大的上界（您可以选择 $$U_3=U_4=100$$）。\n- 候选敲除仅限于集合 $$\\{R_3, R_4\\}$$。敲除反应 $$R_i$$ 是通过边界条件 $$[0,0]$$ 来实现 $$v_i=0$$。\n\n双层优化定义：\n- 上层选择一个敲除集 $$\\mathcal{K} \\subseteq \\{3,4\\}$$，其中 $$|\\mathcal{K}| \\le K$$，以在下层达到最优生长时最大化最坏情况下的产物通量：\n  1. 下层步骤 $$1$$：在应用了 $$\\mathcal{K}$$ 中敲除的质量平衡和边界条件下，最大化 $$v_2$$。\n  2. 下层步骤 $$2$$：在达到最优生长速率 $$v_2^\\star$$ 的解中，在相同约束条件以及附加等式 $$v_2=v_2^\\star$$ 的情况下，最小化 $$v_3$$。\n- 上层的目标是步骤 $$2$$ 返回的最小产物通量 $$v_3^{\\min}(\\mathcal{K})$$；工程师选择使该值最大化的 $$\\mathcal{K}$$。\n\n敲除集的位掩码编码：\n- 反应索引为 $$0,1,2,3,4$$，分别对应于 $$R_0,R_1,R_2,R_3,R_4$$。\n- 一个敲除集 $$\\mathcal{K}$$ 被编码为一个整数位掩码 $$M$$，其中如果反应 $$R_i$$ 被敲除，则位 $$i$$ 为 $$1$$，否则为 $$0$$。例如，仅敲除 $$R_4$$ 对应于 $$M=2^4=16$$，仅敲除 $$R_3$$ 对应于 $$M=2^3=8$$，没有敲除则对应于 $$M=0$$。\n\n您的任务：\n- 在指定环境中实现一个程序，该程序：\n  - 枚举所有满足 $$|\\mathcal{K}| \\le K$$ 的敲除集 $$\\mathcal{K} \\subseteq \\{3,4\\}$$。\n  - 对于每个 $$\\mathcal{K}$$，求解下层步骤 $$1$$（最大化 $$v_2$$）。如果无解，则丢弃 $$\\mathcal{K}$$。\n  - 对于可行的 $$\\mathcal{K}$$，求解下层步骤 $$2$$（在 $$v_2=v_2^\\star$$ 的条件下最小化 $$v_3$$）。如果无解，则丢弃 $$\\mathcal{K}$$。\n  - 选择使最坏情况产物通量 $$v_3^{\\min}(\\mathcal{K})$$ 最大化的 $$\\mathcal{K}$$。如果出现平局，选择最小的位掩码 $$M$$。\n- 对于任何在步骤 $$1$$ 中没有敲除集能产生可行解的测试用例，返回哨兵对 $$[-1,-1.0]$$。\n\n测试套件：\n- 您必须将以下测试用例实现为一个列表，每个用例由 $$[G_{\\mathrm{fixed}},\\,O_{\\max},\\,\\gamma,\\,K]$$ 定义：\n  1. $$[10,\\,6,\\,2.5,\\,1]$$：理想情况，氧气限制生长，并允许一次敲除。\n  2. $$[10,\\,6,\\,2.5,\\,0]$$：边界情况，不允许敲除。\n  3. $$[5,\\,6,\\,2.0,\\,1]$$：减少葡萄糖，迫使剩余碳减少。\n  4. $$[10,\\,6,\\,2.5,\\,2]$$：最多允许两次敲除；同时敲除产物和废物的组合可能变得不可行。\n  5. $$[10,\\,4,\\,2.5,\\,1]$$：氧气过低，无法满足最低生长需求，导致所有组合都不可行。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含测试套件的结果。结果是一个用方括号括起来的逗号分隔列表，其中每个元素是针对所选敲除位掩码 $$M$$ 和相应最坏情况产物通量 $$v_3$$ 的双元素列表 $$[M, v_3]$$，并按测试用例的顺序排列。例如：$$[[M_1,v_{3,1}], [M_2,v_{3,2}], \\dots]$$。\n- 将每个 $$v_3$$ 表示为浮点数。此玩具模型不需要物理单位。", "solution": "该问题提出了一个有效且适定的（well-posed）代谢菌株设计双层优化任务。其目标是确定一个最佳的反应敲除集，以最大化目标产物的最坏情况生成量。该问题是在通量平衡分析（FBA）的框架内提出的，FBA是计算系统生物学中一种标准的基于约束的建模方法。解决方案需要迭代求解一系列线性规划（LP）问题。\n\n问题的核心由一个双层优化结构组成：\n1.  一个代表工程师的**上层**，从一组允许的修改中选择一个敲除策略 $$\\mathcal{K}$$。\n2.  一个代表细胞新陈代谢的**下层**，在给定上层施加的基因修饰的情况下，优化其自身的目标（生长）。\n\n我们为下层假设一个悲观或最坏情况的场景：在所有能达到最大生长的可能代谢状态（通量分布）中，细胞将选择使所需化合物产量最小化的那一种。\n\n总体算法通过枚举所有允许的敲除策略，评估每种策略的结果，并根据工程师的目标选择最佳策略来进行。\n\n**数学公式**\n\n代谢网络由一个线性方程和不等式系统描述。设反应通量向量为 $$\\mathbf{v} = [v_0, v_1, v_2, v_3, v_4]^T$$。\n\n稳态质量平衡约束由 $$S\\mathbf{v}=\\mathbf{0}$$ 给出。对于这个特定网络，其显式方程为：\n$$v_0 - v_2 - v_3 - v_4 = 0$$\n$$v_1 - 2v_2 = 0$$\n\n这两个方程可以写成矩阵形式 $$A_{eq}\\mathbf{v}=\\mathbf{b}_{eq}$$，其中：\n$$\nA_{eq} = \\begin{pmatrix}\n1  0  -1  -1  -1 \\\\\n0  1  -2  0  0\n\\end{pmatrix}\n, \\quad \\mathbf{b}_{eq} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n\n每个反应 $$i$$ 的通量也受到下界和上界的约束，即 $$\\ell_i \\le v_i \\le u_i$$。对于给定的参数为 $G_{\\mathrm{fixed}}$、$O_{\\max}$ 和 $\\gamma$ 的测试用例，基本边界条件为：\n- $$v_0 \\in [G_{\\mathrm{fixed}}, G_{\\mathrm{fixed}}]$$\n- $$v_1 \\in [0, O_{\\max}]$$\n- $$v_2 \\in [\\gamma, 100]$$\n- $$v_3 \\in [0, 100]$$\n- $$v_4 \\in [0, 100]$$\n\n对反应 $$R_i$$ 的敲除通过将其边界设置为 $$[0, 0]$$ 来实现。候选敲除反应为 $$R_3$$ 和 $$R_4$$。\n\n**双层优化算法**\n\n对于每个测试用例，我们必须考虑所有有效的敲除集 $$\\mathcal{K} \\subseteq \\{3, 4\\}$$，其中敲除数量 $$|\\mathcal{K}|$$ 不超过给定限制 $$K$$。每个集合 $$\\mathcal{K}$$ 由一个整数位掩码 $$M$$ 编码。我们评估每个有效的掩码 $$M$$。\n\n对于给定的掩码 $$M$$：\n1.  **下层步骤1：最大化生长速率**\n    我们首先求解最大可能的生物质通量 $$v_2$$。这是一个线性规划（LP）问题：\n    $$\n    \\begin{align*}\n    v_2^\\star = \\max_{\\mathbf{v}} \\quad  v_2 \\\\\n    \\text{subject to} \\quad  A_{eq}\\mathbf{v} = \\mathbf{b}_{eq} \\\\\n     \\ell_i(M) \\le v_i \\le u_i(M) \\quad \\text{for } i=0, \\dots, 4\n    \\end{align*}\n    $$\n    边界 $$\\ell_i(M)$$ 和 $$u_i(M)$$ 是根据 $$M$$ 中的敲除修改后的基本边界。如果此 LP 不可行（即没有通量向量可以满足所有约束，例如最小生长需求 $$\\gamma$$），则丢弃敲除策略 $$M$$。\n\n2.  **下层步骤2：最小化产物通量（最坏情况）**\n    如果步骤1可行，我们通过最小化 $$v_3$$ 来找到最坏情况下的产物通量，同时将生长速率约束为其可达到的最大值 $$v_2^\\star$$。这是第二个 LP 问题：\n    $$\n    \\begin{align*}\n    v_3^{\\min}(M) = \\min_{\\mathbf{v}} \\quad  v_3 \\\\\n    \\text{subject to} \\quad  A_{eq}\\mathbf{v} = \\mathbf{b}_{eq} \\\\\n     \\ell_i(M) \\le v_i \\le u_i(M) \\quad \\text{for } i=0, \\dots, 4 \\\\\n     v_2 = v_2^\\star\n    \\end{align*}\n    $$\n    值 $$v_3^{\\min}(M)$$ 是敲除策略 $$M$$ 的保证最低产物产量。\n\n**上层决策**\n\n在为所有可行和允许的掩码 $$M$$ 评估 $$v_3^{\\min}(M)$$ 之后，上层问题是选择使该值最大化的掩码 $$M^\\star$$：\n$$ M^\\star = \\arg\\max_{M} \\{v_3^{\\min}(M)\\} $$\n如果 $$v_3^{\\min}$$ 值出现平局，则选择整数值最小的掩码 $$M$$。如果没有敲除策略能产生可行的模型，则为该测试用例返回哨兵值 $$[-1, -1.0]$$。\n\n**实现细节**\n\n所描述的算法使用 Python 的 `scipy.optimize.linprog` 函数实现，该函数用于求解标准形式的 LP 问题。\n- $$v_2$$ 的最大化通过最小化 $$-v_2$$ 来实现，即使用目标向量 $$c = [0, 0, -1, 0, 0]^T$$。\n- 第二个 LP 中的约束 $$v_2 = v_2^\\star$$ 是通过将变量 $$v_2$$ 的边界设置为 `[v_2_star, v_2_star]` 来实现的。\n- 程序遍历所提供的测试用例，对每个用例应用双层算法，并报告最优掩码和相应的最坏情况产物通量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_case(G_fixed, O_max, gamma, K):\n    \"\"\"\n    Solves the bilevel optimization problem for a single test case.\n    \n    Args:\n        G_fixed (float): The fixed glucose uptake rate.\n        O_max (float): The maximum oxygen uptake rate.\n        gamma (float): The minimum required biomass flux for viability.\n        K (int): The maximum number of allowed knockouts.\n\n    Returns:\n        list: A list containing the best knockout mask and the corresponding\n              worst-case product flux, e.g., [mask, v3_min].\n              Returns [-1, -1.0] if no feasible strategy is found.\n    \"\"\"\n    # Stoichiometric matrix for equality constraints v0-v2-v3-v4=0, v1-2v2=0\n    A_eq = np.array([\n        [1, 0, -1, -1, -1],  # Glucose balance\n        [0, 1, -2, 0, 0]     # Oxygen balance\n    ])\n    b_eq = np.array([0, 0])\n    \n    # Large upper bound for unconstrained fluxes\n    U_large = 100.0\n    \n    # Base bounds for the fluxes [v0, v1, v2, v3, v4]\n    base_bounds = [\n        (G_fixed, G_fixed),   # v0: Glucose uptake\n        (0, O_max),           # v1: Oxygen uptake\n        (gamma, U_large),     # v2: Biomass growth\n        (0, U_large),         # v3: Product formation\n        (0, U_large)          # v4: Waste formation\n    ]\n\n    # Define all possible knockout strategies (mask, number of knockouts)\n    # R3 knockout corresponds to bit 3 (2^3=8)\n    # R4 knockout corresponds to bit 4 (2^4=16)\n    knockout_options = [\n        (0, 0),    # No knockouts\n        (8, 1),    # Knockout R3\n        (16, 1),   # Knockout R4\n        (24, 2)    # Knockout R3 and R4\n    ]\n    \n    # Filter for strategies that are permissible under the K limit\n    masks_to_test = [m for m, k_count in knockout_options if k_count = K]\n    \n    best_mask = -1\n    best_v3_min = -1.0\n\n    for M in masks_to_test:\n        bounds = base_bounds.copy()\n        \n        # Apply knockouts by setting the bounds of the flux to [0, 0]\n        if M  8:  # Test bit 3 for R3 knockout\n            bounds[3] = (0, 0)\n        if M  16: # Test bit 4 for R4 knockout\n            bounds[4] = (0, 0)\n        \n        # --- Lower-Level Step 1: Maximize v2 ---\n        # Objective: max(v2) is equivalent to min(-v2)\n        c1 = np.array([0, 0, -1, 0, 0])\n        res1 = linprog(c=c1, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n        \n        if not res1.success:\n            continue  # This knockout strategy is infeasible.\n        \n        v2_star = -res1.fun\n\n        # --- Lower-Level Step 2: Minimize v3 at optimal growth ---\n        bounds_step2 = bounds.copy()\n        # Enforce v2 = v2_star by setting the bounds for v2\n        bounds_step2[2] = (v2_star, v2_star)\n        \n        # Objective: min(v3)\n        c2 = np.array([0, 0, 0, 1, 0])\n        res2 = linprog(c=c2, A_eq=A_eq, b_eq=b_eq, bounds=bounds_step2, method='highs')\n        \n        if not res2.success:\n            # This would be an unexpected failure, but we handle it defensively.\n            continue\n            \n        v3_min = res2.fun\n\n        # --- Upper-Level: Update best result ---\n        if best_mask == -1:\n            best_mask = M\n            best_v3_min = v3_min\n        else:\n            # Update if current v3_min is better, or if it's a tie and the mask is smaller\n            # Using a tolerance for robust float comparison\n            if v3_min > best_v3_min + 1e-9:\n                best_v3_min = v3_min\n                best_mask = M\n            elif abs(v3_min - best_v3_min)  1e-9 and M  best_mask:\n                best_mask = M\n    \n    return [best_mask, float(best_v3_min)]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # [G_fixed, O_max, gamma, K]\n        [10, 6, 2.5, 1],\n        [10, 6, 2.5, 0],\n        [5, 6, 2.0, 1],\n        [10, 6, 2.5, 2],\n        [10, 4, 2.5, 1],\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list includes a space, e.g., '[16, 7.0]',\n    # which is consistent with the problem's example format of `[M, v_3]`.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3290717"}, {"introduction": "尽管枚举法对于小型问题直观有效，但它在面对真实规模的基因组尺度网络时会变得不切实际。为了解决这一可扩展性问题，我们需要更高级的数学工具。本练习将引导你完成一个关键的理论推导：如何利用线性规划的对偶理论，将一个双层线性规划问题（如OptKnock）严格地转化为一个等价的单层混合整数线性规划（MILP）问题[@problem_id:3339859]。掌握这一转变是理解和应用现代菌株设计算法的基石。", "problem": "考虑一个使用基于约束的建模和流平衡分析 (FBA) 建模的、处于稳态的小型代谢网络。设内部代谢物为底物 $S$ 和前体 $D$，外部底物 $S_{\\mathrm{ex}}$、产物 $P$ 和生物质为交换汇。反应集合由四个不可逆反应组成，其通量 $v_1, v_2, v_3, v_4$ 定义如下（所有化学计量系数均为整数，所有通量均为非负）：\n- $v_1$：输入，$S_{\\mathrm{ex}} \\rightarrow S$，边界为 $0 \\le v_1 \\le 10$；\n- $v_2$：前体合成途径 A，$S \\rightarrow D$，边界为 $0 \\le v_2 \\le 10$；\n- $v_3$：前体和产物合成途径 B，$2 S \\rightarrow D + P$，边界为 $0 \\le v_3 \\le 10$；\n- $v_4$：生物质合成，$D \\rightarrow \\text{Biomass}$，边界为 $0 \\le v_4$，无显式上界。\n\n在稳态下，$S$ 和 $D$ 的内部质量平衡意味着以下等式\n$$\nv_1 - v_2 - 2 v_3 = 0, \\quad v_2 + v_3 - v_4 = 0.\n$$\n内部（细胞）问题是标准的 FBA，其目标是最大化生长，即最大化生物质通量 $v_4$，并受限于稳态等式和给定的反应通量边界。外部（菌株设计）问题选择反应敲除，以在内部问题的最优生长状态下最大化产物生成 $v_3$，允许从集合 $\\{v_2, v_3\\}$ 中最多选择一个敲除。\n\n要求您将 OptKnock 表述为一个双层优化问题，然后利用内部 FBA 问题的线性规划对偶性，推导出一个单层混合整数线性规划 (MILP) 的重构形式。请执行以下操作：\n\n1. 用数学方式写出双层优化问题。为反应 $v_2$ 和 $v_3$ 的活性引入二进制变量 $y_2, y_3 \\in \\{0,1\\}$（其中 $y_j = 1$ 表示反应存在，$y_j = 0$ 表示反应被敲除），并通过 $(1 - y_2) + (1 - y_3) \\le 1$ 强制执行敲除限制。通过 $v_2 \\le 10\\, y_2$ 和 $v_3 \\le 10\\, y_3$ 将反应活性与通量上界联系起来。反应 $v_1$ 不可敲除，隐含有 $y_1 = 1$，反应 $v_4$ 不可敲除且没有显式上界。\n\n2. 通过将内部 LP 替换为其原始可行性、对偶可行性和强对偶性条件，推导出 MILP 的重构形式。设内部代谢物的化学计量矩阵为 $S \\in \\mathbb{R}^{2 \\times 4}$，其列对应于 $(v_1,v_2,v_3,v_4)$，生长目标为 $c^\\top v$，其中 $c = (0,0,0,1)^\\top$。为稳态等式引入对偶变量 $\\pi \\in \\mathbb{R}^2$（符号无限制），为适用的 $v_j$ 的上界约束引入 $\\alpha_j \\ge 0$，为 $j \\in \\{1,2,3,4\\}$ 的非负约束 $v_j \\ge 0$ 引入 $\\beta_j \\ge 0$。明确写出对偶可行性条件，以及将 $v_4$ 与对偶变量、反应上界和活性联系起来的强对偶性等式。\n\n3. 求解得到的 MILP 以获得外部目标的最优值，即在内部问题最优生长状态下，且在最多敲除 $\\{v_2,v_3\\}$ 中一个反应的限制下，可行的最大 $v_3$。提供这个最优 $v_3$ 的单一数值。无需四舍五入。\n\n您的最终答案必须是第 3 部分要求的单一实数值。", "solution": "用户提供的问题是计算系统生物学领域中一个适定 (well-posed) 的优化任务。它在科学上基于流平衡分析 (FBA) 和 OptKnock（一种用于代谢菌株设计的双层优化框架）的原理。问题陈述是自洽的，所有必要的反应、约束和目标都已明确定义。数值和化学计量系数是一致的。因此，该问题是有效的，我将继续提供完整解答。\n\n按照问题陈述的要求，解答分为三个部分呈现。\n\n### 第 1 部分：双层优化公式\n\n该问题描述了一个双层优化情景。外部（菌株设计）问题通过选择最优的反应敲除策略，寻求最大化 $P$ 的产量（由通量 $v_3$ 衡量）。内部（细胞目标）问题描述了细胞的行为，假定在给定的敲除策略下，细胞会最大化其自身的生长速率（由生物质通量 $v_4$ 表示）。\n\n设 $y_2, y_3 \\in \\{0, 1\\}$ 为二进制变量，表示反应 $v_2$ 和 $v_3$ 的状态，其中 $y_j = 1$ 表示反应是活跃的，$y_j = 0$ 表示它被敲除。最多只允许一个敲除的约束可以表示为 $(1 - y_2) + (1 - y_3) \\le 1$，简化后为 $y_2 + y_3 \\ge 1$。\n\n反应通量的边界取决于这些二进制变量。不可逆反应 $v_2$ 和 $v_3$ 的上界由它们各自的 $y_j$ 变量控制开关：\n- $v_2 \\le 10 y_2$\n- $v_3 \\le 10 y_3$\n由于所有通量都必须是非负的（$v_j \\ge 0$），如果 $y_j=0$，通量 $v_j$ 被强制为 $0$。如果 $y_j=1$，则原始边界 $v_j \\le 10$ 生效。反应 $v_1$ 有一个固定的边界 $0 \\le v_1 \\le 10$，而 $v_4$ 没有上界，$v_4 \\ge 0$。\n\n双层优化公式如下：\n\n**外部问题：** 在敲除选择上最大化产物通量 $v_3$。\n$$\n\\max_{y_2, y_3, v} \\quad v_3\n$$\n约束条件：\n$$\ny_2 + y_3 \\ge 1\n$$\n$$\ny_2, y_3 \\in \\{0, 1\\}\n$$\n其中通量向量 $v = (v_1, v_2, v_3, v_4)^\\top$ 是以下由 $y_2$ 和 $y_3$ 参数化的内部 FBA 问题的最优解：\n\n**内部问题：** 最大化生物质通量 $v_4$。\n$$\n\\max_{\\bar{v}} \\quad \\bar{v}_4\n$$\n约束条件：\n$$\n\\bar{v}_1 - \\bar{v}_2 - 2 \\bar{v}_3 = 0 \\quad (\\text{代謝物 } S)\n$$\n$$\n\\bar{v}_2 + \\bar{v}_3 - \\bar{v}_4 = 0 \\quad (\\text{代謝物 } D)\n$$\n$$\n0 \\le \\bar{v}_1 \\le 10\n$$\n$$\n0 \\le \\bar{v}_2 \\le 10 y_2\n$$\n$$\n0 \\le \\bar{v}_3 \\le 10 y_3\n$$\n$$\n\\bar{v}_4 \\ge 0\n$$\n内部问题中使用 $\\bar{v}$ 的表示法是为了将其变量与外部问题的变量区分开。双层问题的解 $v$ 必须是内部问题的最优解之一 $\\bar{v}$。\n\n### 第 2 部分：使用对偶性的 MILP 重构\n\n为了将双层规划问题转换为单层混合整数线性规划 (MILP)，内部的线性规划被其 Karush-Kuhn-Tucker (KKT) 条件所取代。对于一个 LP，这些条件包括原始可行性、对偶可行性和强对偶性。\n\n**原始可行性：** 内部问题的约束必须被满足。这些约束已在上面列出，并成为最终 MILP 中的约束条件。\n\n**矩阵形式的内部原始问题：**\n对于一个固定的 $y$，内部问题是：\n$$\n\\max_{v} \\quad c^\\top v \\quad \\text{s.t.} \\quad Sv = 0, \\quad v_{lb} \\le v \\le v_{ub}\n$$\n其中\n- 通量向量: $v = (v_1, v_2, v_3, v_4)^\\top$\n- 化学计量矩阵: $S = \\begin{pmatrix} 1  -1  -2  0 \\\\ 0  1  1  -1 \\end{pmatrix}$\n- 目标向量: $c = (0, 0, 0, 1)^\\top$\n- 下界: $v_{lb} = (0, 0, 0, 0)^\\top$\n- 上界: $v_{ub} = (10, 10y_2, 10y_3, \\infty)^\\top$\n\n**对偶可行性：** 内部 LP 的对偶问题提供了下一组约束。设 $\\pi = (\\pi_S, \\pi_D)^\\top \\in \\mathbb{R}^2$ 为两个等式约束 ($Sv=0$) 的对偶变量。设 $\\alpha_j \\ge 0$ 为上界约束 $v_j \\le v_{j,ub}$ 的对偶变量，$\\beta_j \\ge 0$ 为非负约束 $v_j \\ge 0$ (或 $-v_j \\le 0$) 的对偶变量。对偶约束由 $S^\\top \\pi + \\alpha - \\beta = c$ 给出。\n由于 $v_4$ 没有有限上界，其对应的对偶变量 $\\alpha_4$ 必须为 $0$。\n\n具体的对偶可行性约束是：\n1. 对于 $v_1$:  $1 \\cdot \\pi_S + 0 \\cdot \\pi_D + \\alpha_1 - \\beta_1 = 0 \\implies \\pi_S + \\alpha_1 - \\beta_1 = 0$\n2. 对于 $v_2$: $-1 \\cdot \\pi_S + 1 \\cdot \\pi_D + \\alpha_2 - \\beta_2 = 0 \\implies -\\pi_S + \\pi_D + \\alpha_2 - \\beta_2 = 0$\n3. 对于 $v_3$: $-2 \\cdot \\pi_S + 1 \\cdot \\pi_D + \\alpha_3 - \\beta_3 = 0 \\implies -2\\pi_S + \\pi_D + \\alpha_3 - \\beta_3 = 0$\n4. 对于 $v_4$:  $0 \\cdot \\pi_S - 1 \\cdot \\pi_D + \\alpha_4 - \\beta_4 = 1 \\implies -\\pi_D - \\beta_4 = 1$ (因为 $\\alpha_4=0$)\n其中 $\\pi_S, \\pi_D$ 符号无限制，且 $\\alpha_1, \\alpha_2, \\alpha_3 \\ge 0$ 以及 $\\beta_1, \\beta_2, \\beta_3, \\beta_4 \\ge 0$。\n\n**强对偶性：** 对于 LP，强对偶性表明在最优状态下，原始目标值等于对偶目标值。\n$$\nc^\\top v = v_{ub}^\\top \\alpha - v_{lb}^\\top \\beta\n$$\n由于 $v_{lb}=0$，项 $v_{lb}^\\top \\beta$ 为零。上界是 $(10, 10y_2, 10y_3, \\infty)$。强对偶性等式为：\n$$\nv_4 = 10 \\alpha_1 + (10 y_2) \\alpha_2 + (10 y_3) \\alpha_3\n$$\n项 $y_2 \\alpha_2$ 和 $y_3 \\alpha_3$ 是非线性的。在一个完整的 MILP 公式中，它们需要被线性化，例如通过引入新变量 $w_j = y_j \\alpha_j$ 并添加诸如 $w_j \\le M y_j$、$w_j \\le \\alpha_j$、$w_j \\ge \\alpha_j - M(1-y_j)$ 和 $w_j \\ge 0$ 的约束，其中 $M$ 是一个足够大的常数。\n\n结合这些部分，可以得到一个与原始双层问题等价的单层 MILP。\n\n### 第 3 部分：求解最优产物通量\n\n外部问题涉及从一个小的敲除策略集合中进行选择。我们可以通过枚举所有有效的策略来解决这个问题，为每个策略求解其产生的优化问题，然后选择产生最大 $v_3$ 的策略。有效的策略是：\n- 情况 1：无敲除 ($y_2=1, y_3=1$)\n- 情况 2：敲除 $v_2$ ($y_2=0, y_3=1$)\n- 情况 3：敲除 $v_3$ ($y_2=1, y_3=0$)\n\n对于每种情况，我们首先找到最大生物质通量 ($v_4^{max}$)，然后在保持此最大生长的同时，找到可实现的最大产物通量 ($v_3$)。\n\n**情况 1：无敲除 ($y_2=1, y_3=1$)**\nFBA 问题是最大化 $v_4$，约束条件为：\n$v_1 - v_2 - 2 v_3 = 0$\n$v_2 + v_3 - v_4 = 0 \\implies v_4 = v_2 + v_3$\n$0 \\le v_1 \\le 10$\n$0 \\le v_2 \\le 10$\n$0 \\le v_3 \\le 10$\n将 $v_1$ 从第一个方程代入其边界条件：$0 \\le v_2 + 2v_3 \\le 10$。\n我们在由 $v_2 \\ge 0$, $v_3 \\ge 0$, $v_2 \\le 10$, $v_3 \\le 10$, and $v_2 + 2v_3 \\le 10$ 定义的 $(v_2, v_3)$ 空间可行域上最大化 $v_4 = v_2 + v_3$。\n可行域的顶点是 $(0,0)$, $(10,0)$, and $(0,5)$。\n- 在 $(v_2, v_3)=(0,0)$， $v_4 = 0$。\n- 在 $(v_2, v_3)=(10,0)$， $v_4 = 10$。\n- 在 $(v_2, v_3)=(0,5)$， $v_4 = 5$。\n最大生长速率为 $v_4^{max} = 10$，在通量分布为 $v_2=10$ 和 $v_3=0$ 时唯一实现。\n由于最大生长状态是唯一的，产物通量被唯一确定为 $v_3=0$。\n\n**情况 2：敲除 $v_2$ ($y_2=0, y_3=1$)**\n当 $v_2=0$ 时，约束变为：\n$v_1 - 2 v_3 = 0 \\implies v_1 = 2 v_3$\n$v_3 - v_4 = 0 \\implies v_4 = v_3$\n$0 \\le v_1 \\le 10$\n$0 \\le v_3 \\le 10$\n为了最大化生长速率 $v_4$，我们最大化 $v_3$。对 $v_1$ 的约束给出 $0 \\le 2v_3 \\le 10$，这意味着 $0 \\le v_3 \\le 5$。这比 $v_3 \\le 10$ 更严格。\n$v_3$ 的最大可能值为 $5$，因此最大生长速率为 $v_4^{max} = 5$。\n这个最大生长速率在 $v_3=5$ 时实现。因此，在最优生长状态下，产物通量为 $v_3=5$。\n\n**情况 3：敲除 $v_3$ ($y_2=1, y_3=0$)**\n当 $v_3=0$ 时，约束变为：\n$v_1 - v_2 = 0 \\implies v_1 = v_2$\n$v_2 - v_4 = 0 \\implies v_4 = v_2$\n$0 \\le v_1 \\le 10$\n$0 \\le v_2 \\le 10$\n为了最大化生长速率 $v_4$，我们最大化 $v_2$。约束条件意味着 $0 \\le v_2 \\le 10$。\n最大生长速率为 $v_4^{max} = 10$，在 $v_2=10$ 时实现。\n通量 $v_3$ 被敲除约束为 $0$。因此，在最优生长状态下，产物通量为 $v_3=0$。\n\n**结论**\n我们比较每种有效敲除策略下可实现的最大 $v_3$ 值：\n- 野生型（无敲除）：$v_3 = 0$\n- 敲除 $v_2$：$v_3 = 5$\n- 敲除 $v_3$：$v_3 = 0$\n外部目标（最大化 $v_3$）的最大值为 $5$。这是通过敲除反应 $v_2$ 实现的。", "answer": "$$\\boxed{5}$$", "id": "3339859"}, {"introduction": "在现实世界中，工程菌株需要在多种不同甚至不确定的环境条件下稳定地发挥作用。因此，设计的“鲁棒性”与在单一理想条件下的最优性能同等重要。本练习将双层优化的应用从单一场景扩展到多场景决策问题，要求你从一系列设计方案中，找出一个在所有给定场景中表现最差的情况仍然最优的“鲁棒”设计[@problem_id:3290694]。这个练习将让你体验如何将鲁棒性这一工程目标量化，并整合到菌株设计的优化框架中。", "problem": "考虑一个基于稳态流通平衡分析 (FBA) 的多场景双层菌株设计问题。对于每个场景索引 $k$，细胞内稳态条件由线性约束 $S v^{(k)} = 0$ 表示，其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$v^{(k)} \\in \\mathbb{R}^n$ 是场景 $k$ 的反应流向量，并且边界 $l^{(k)} \\le v^{(k)} \\le u^{(k)}$ 是按分量施加的。每个场景 $k$ 中的内层问题选择一个流向量 $v^{(k)}$，以最大化生长目标 $c_{\\mu}^\\top v^{(k)}$，其中 $c_{\\mu} \\in \\mathbb{R}^n$。为了使产物流在最优生长条件下唯一确定，使用字典序准则：首先求解生长最大化问题以获得最优生长值 $\\mu^{*(k)}$，然后在所有能达到至少 $\\mu^{*(k)}$ 生长水平的流向量中，选择使产物目标 $c_{p}^\\top v^{(k)}$ 最大化的那一个。外层问题从一个有限目录 $\\mathcal{X}$ 中选择一个单一设计 $x$，该设计以依赖于设计的方式修改边界 $(l^{(k)}, u^{(k)})$，其目标是最大化所有场景中的最差情况产物流，同时确保最优生长值满足各场景的存活阈值。形式上，对于给定的 $x \\in \\mathcal{X}$ 和场景 $k$，将经设计修改的边界定义为 $l^{(k)}(x), u^{(k)}(x)$，并将内层生长最优值定义为\n$$\n\\mu^{*(k)}(x) \\;=\\; \\max_{v \\in \\mathbb{R}^n} \\;\\; c_{\\mu}^\\top v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l^{(k)}(x) \\le v \\le u^{(k)}(x).\n$$\n对每个场景 $k$ 施加存活要求 $\\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)}$，其中给定了 $\\underline{\\mu}^{(k)} \\in \\mathbb{R}_{\\ge 0}$。然后将每个 $k$ 的产生产物的字典序步骤定义为\n$$\nv_{p}^{(k)}(x) \\;=\\; \\max_{v \\in \\mathbb{R}^n} \\;\\; c_{p}^\\top v \\quad \\text{subject to} \\quad S v = 0,\\;\\; l^{(k)}(x) \\le v \\le u^{(k)}(x),\\;\\; c_{\\mu}^\\top v \\ge \\mu^{*(k)}(x) - \\tau,\n$$\n其中 $\\tau \\in \\mathbb{R}_{0}$ 是一个为避免数值问题而设的小容差。外层问题选择 $x \\in \\mathcal{X}$ 来最大化最差情况下的产物，\n$$\n\\max_{x \\in \\mathcal{X}} \\;\\; \\min_{k} \\; v_{p}^{(k)}(x) \\qquad \\text{subject to} \\qquad \\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)} \\;\\; \\text{for all}\\; k.\n$$\n您必须实现一个程序，针对以下包含三个案例的测试套件，计算每个案例的最优外层目标值（实数），并将结果作为单行输出。\n\n所有三个案例使用相同的化学计量矩阵 $S \\in \\mathbb{R}^{2 \\times 5}$，其中有 $n = 5$ 个反应和 $m = 2$ 个细胞内代谢物。反应顺序如下：$v_1$ 是葡萄糖摄取，$v_2$ 是生物质形成（生长），$v_3$ 是前体形成，$v_4$ 是产物形成，$v_5$ 是一条竞争性废物途径。代谢物按细胞内葡萄糖和细胞内前体的顺序排列。化学计量矩阵 $S$ 为\n$$\nS \\;=\\; \\begin{bmatrix}\n1  -1  -1  0  -1\\\\\n0  0  1  -1  0\n\\end{bmatrix}.\n$$\n生长目标向量为 $c_{\\mu} = \\begin{bmatrix}0  1  0  0  0\\end{bmatrix}^\\top$，产物目标向量为 $c_{p} = \\begin{bmatrix}0  0  0  1  0\\end{bmatrix}^\\top$。除非通过设计进行修改，否则所有下界均为 $0$。在设计修改前，每个场景 $k$ 都有其自己的上界 $u^{(k)}$，如下文所述，且具有共同的下界 $l^{(k)} = \\begin{bmatrix}0  0  0  0  0\\end{bmatrix}^\\top$。\n\n必须从离散集合 $\\mathcal{X} = \\{x^{(0)}, x^{(1)}, x^{(2)}, x^{(3)}\\}$ 中选择一个单一设计 $x$。依赖于设计的边界修改定义如下。对于任何场景 $k$，令 $u^{(k)}_{\\text{base}}$ 表示设计前的基础上限；则：\n1. 基线设计 $x^{(0)}$ 不施加任何更改，即 $u^{(k)}(x^{(0)}) = u^{(k)}_{\\text{base}}$ 且 $l^{(k)}(x^{(0)}) = l^{(k)}$。\n2. 废物敲除设计 $x^{(1)}$ 通过在每个场景中将 $v_5$ 的上界设置为 $0$ 来消除竞争途径，即 $u^{(k)}(x^{(1)})_5 = 0$，所有其他分量等于 $u^{(k)}_{\\text{base}}$。\n3. 生长上限设计 $x^{(2)}$ 在每个场景中对 $v_2$ 施加 $4$ 的上界限制，即 $u^{(k)}(x^{(2)})_2 = \\min\\{u^{(k)}_{\\text{base},2}, 4\\}$，所有其他分量等于 $u^{(k)}_{\\text{base}}$。\n4. 产物过表达设计 $x^{(3)}$ 在每个场景中将产物能力提高 $3$ 倍，即 $u^{(k)}(x^{(3)})_4 = 3 \\, u^{(k)}_{\\text{base},4}$，所有其他分量等于 $u^{(k)}_{\\text{base}}$。\n\n在所有案例中，使用字典序容差 $\\tau = 10^{-9}$。每个案例包含三个场景，其指定的基础上限 $u^{(k)}_{\\text{base}}$ 和存活阈值 $\\underline{\\mu}^{(k)}$ 如下。\n\n案例 A：\n三个场景的基础上限为\n$$\nu^{(1)}_{\\text{base}} = \\begin{bmatrix}10  100  100  3  8\\end{bmatrix}^\\top,\\quad\nu^{(2)}_{\\text{base}} = \\begin{bmatrix}5  100  100  1.5  4\\end{bmatrix}^\\top,\\quad\nu^{(3)}_{\\text{base}} = \\begin{bmatrix}8  100  100  2  7\\end{bmatrix}^\\top.\n$$\n存活阈值为\n$$\n\\underline{\\mu}^{(1)} = 0.5,\\quad \\underline{\\mu}^{(2)} = 0.2,\\quad \\underline{\\mu}^{(3)} = 0.2.\n$$\n\n案例 B：\n基础上限与案例 A 相同。存活阈值更严格，\n$$\n\\underline{\\mu}^{(1)} = 6,\\quad \\underline{\\mu}^{(2)} = 4.5,\\quad \\underline{\\mu}^{(3)} = 4.\n$$\n\n案例 C：\n基础上限与案例 A 相同，除了第三个场景具有更紧的产物能力，\n$$\nu^{(3)}_{\\text{base}} = \\begin{bmatrix}8  100  100  0.5  7\\endbmatrix}^\\top.\n$$\n存活阈值与案例 A 相同，\n$$\n\\underline{\\mu}^{(1)} = 0.5,\\quad \\underline{\\mu}^{(2)} = 0.2,\\quad \\underline{\\mu}^{(3)} = 0.2.\n$$\n\n对于每个案例，任务是计算最优外层目标值，即在满足所有场景 $k$ 的存活约束 $\\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)}$ 的前提下，$\\max_{x \\in \\mathcal{X}} \\min_{k} v_{p}^{(k)}(x)$ 的值。您的程序必须如所述求解内层问题，并枚举有限设计集以确定每个案例的最佳 $x$。\n\n不使用角度单位。数值输出中没有物理单位。要求的最终输出格式是包含三个浮点数的单行 Python 风格列表，每个案例一个，按 A、B、C 的顺序排列。每个数字必须四舍五入到恰好六位小数。例如，格式必须像 $[a,b,c]$，其中 $a$、$b$ 和 $c$ 是小数点后有六位数字的浮点数，且逗号后没有空格，例如 $[1.234000,0.000100,5.600000]$。", "solution": "问题陈述描述了一个用于代谢菌株设计的多场景双层优化问题。任务是从一个有限目录中识别出一种最优设计策略，该策略在满足细胞生长存活约束的前提下，最大化多种环境场景中的最差情况产物产量。该问题是良定的，其科学基础是流通平衡分析 (FBA) 的原理，并为获得唯一解提供了所有必要数据。因此，我们可以进行完整求解。\n\n整个问题可以表述为：\n$$\n\\max_{x \\in \\mathcal{X}} \\left( \\min_{k} v_{p}^{(k)}(x) \\right)\n$$\n受制于存活约束，即对于每个场景 $k$，最大生长速率 $\\mu^{*(k)}(x)$ 必须满足 $\\mu^{*(k)}(x) \\ge \\underline{\\mu}^{(k)}$。对于任何场景 $k$，未能满足此条件的设计 $x$ 被认为是不可存活的，并从外层最大化问题的候选解集合中排除。\n\n问题的核心在于为每个设计 $x \\in \\mathcal{X}$ 和场景 $k$ 求解内层字典序优化。这涉及两个序贯的线性规划 (LP) 问题。\n\n**步骤1：代谢模型的解析简化**\n\n首先，我们分析稳态质量平衡约束 $S v = 0$，其中 $v = [v_1, v_2, v_3, v_4, v_5]^\\top$。给定的化学计量矩阵为：\n$$\nS = \\begin{bmatrix}\n1  -1  -1  0  -1 \\\\\n0  0  1  -1  0\n\\end{bmatrix}\n$$\n该矩阵方程对应两个线性方程：\n1. $v_1 - v_2 - v_3 - v_5 = 0$\n2. $v_3 - v_4 = 0$\n\n从第二个方程，我们直接得到 $v_3 = v_4$。将此代入第一个方程，得到 $v_1 = v_2 + v_4 + v_5$。\n这两个关系表明，5 维流向量 $v$ 由三个独立的流确定。我们可以选择生长流 $v_2$、产物流 $v_4$ 和废物路径流 $v_5$ 作为我们的自变量。其余的流，即前体形成流 $v_3$ 和葡萄糖摄取流 $v_1$，是因变量。\n\nLP 的全套约束可以用这些独立流重新表述。对于任何给定的设计 $x$ 和场景 $k$，设边界为 $l^{(k)}(x) \\le v \\le u^{(k)}(x)$。鉴于所有基础下界均为 $l_i = 0$，我们有 $v_i \\ge 0$ 对于所有反应 $i \\in \\{1, \\dots, 5\\}$。对因变量流的上限 $u_i$ 施加了对自变量的约束：\n- $v_1 \\le u_1 \\implies v_2 + v_4 + v_5 \\le u_1$\n- $v_3 \\le u_3 \\implies v_4 \\le u_3$\n\n将这些与对自变量的直接边界相结合，$(v_2, v_4, v_5)$ 的可行空间由以下条件定义：\n- $v_2 + v_4 + v_5 \\le u_1$\n- $0 \\le v_2 \\le u_2$\n- $0 \\le v_4 \\le \\min(u_3, u_4)$\n- $0 \\le v_5 \\le u_5$\n\n**步骤2：求解内层优化问题**\n\n利用简化的约束，我们可以找到两个内层 LP 的解析解。对于给定的设计 $x$ 和场景 $k$，边界 $(u_1, u_2, u_3, u_4, u_5)$ 是固定的。\n\n**LP 1：生长最大化**\n第一个目标是最大化生长流，$c_\\mu^\\top v = v_2$。\n$$\n\\mu^{*(k)}(x) = \\max_{v_2, v_4, v_5} v_2\n$$\n受限于简化的约束。为了最大化 $v_2$，我们必须在约束 $v_2 + v_4 + v_5 \\le u_1$ 中为 $v_4$ 和 $v_5$ 选择尽可能小的非负值。最小值为 $v_4=0$ 和 $v_5=0$。这将对 $v_2$ 的约束简化为 $v_2 \\le u_1$ 和 $v_2 \\le u_2$。因此，最优生长速率为：\n$$\n\\mu^{*(k)}(x) = \\min(u_1, u_2)\n$$\n\n**LP 2：产物最大化（字典序步骤）**\n第二个目标是最大化产物流，$c_p^\\top v = v_4$，条件是达到至少 $\\mu^{*(k)}(x) - \\tau$ 的生长速率。\n$$\nv_p^{(k)}(x) \\text{ 值} = \\max_{v_2, v_4, v_5} v_4\n$$\n受限于简化的约束以及附加的字典序约束：\n$$\nv_2 \\ge \\mu^{*(k)}(x) - \\tau\n$$\n为了最大化 $v_4$，我们必须在约束 $v_2 + v_4 + v_5 \\le u_1$ 中为 $v_2$ 和 $v_5$ 选择尽可能小的值。$v_2$ 的允许最小值为 $\\mu^{*(k)}(x) - \\tau$。$v_5$ 的最小值为 $0$。将这些值代入不等式，得到：\n$$\n(\\mu^{*(k)}(x) - \\tau) + v_4 + 0 \\le u_1 \\implies v_4 \\le u_1 - \\mu^{*(k)}(x) + \\tau\n$$\n最终的最大产物流也受其自身能力的限制，$v_4 \\le \\min(u_3, u_4)$。因此，解为：\n$$\nv_p^{(k)}(x) \\text{ 值} = \\min(\\min(u_3, u_4), u_1 - \\mu^{*(k)}(x) + \\tau)\n$$\n代入 $\\mu^{*(k)}(x) = \\min(u_1, u_2)$ 的表达式：\n$$\nv_p^{(k)}(x) \\text{ 值} = \\min(\\min(u_3, u_4), u_1 - \\min(u_1, u_2) + \\tau)\n$$\n\n**步骤3：设计的算法评估**\n\n有了这些解析解，我们可以通过对每个案例的设计有限集进行迭代来实现完整的程序。对于每个案例（A, B, C）：\n1. 初始化最大最差情况产物 $P_{\\text{opt}}$ 为一个非常小的数（例如，$-\\infty$）。\n2. 对于每个设计 $x \\in \\{x^{(0)}, x^{(1)}, x^{(2)}, x^{(3)}\\}$：\n   a. 初始化一个标志 `is_viable` 为 `true` 和一个列表 `product_fluxes` 用于存储各场景的结果。\n   b. 对于每个场景 $k \\in \\{1, 2, 3\\}$：\n      i. 通过将设计 $x$ 的修改规则应用于基础上限 $u^{(k)}_{\\text{base}}$ 来确定上限 $u^{(k)}(x)$。\n      ii. 计算最大生长速率 $\\mu^{*(k)}(x) = \\min(u_1, u_2)$。\n      iii. 检查存活性：如果 $\\mu^{*(k)}(x)  \\underline{\\mu}^{(k)}$，则将 `is_viable` 设置为 `false` 并跳出场景循环，因为此设计无效。\n      iv. 如果存活，则使用推导出的公式计算最大产物流 $v_p^{(k)}(x)$。将此值附加到 `product_fluxes`。\n   c. 如果在检查完所有场景后 `is_viable` 仍为 `true`：\n      i. 找到此设计的最差情况（最小）产物流：$P_{\\text{worst}}(x) = \\min(\\text{product\\_fluxes})$。\n      ii. 更新全局最优值：$P_{\\text{opt}} = \\max(P_{\\text{opt}}, P_{\\text{worst}}(x))$。\n3. 最终值 $P_{\\text{opt}}$ 即为该案例的答案。如果没有可行的设计，则最大值取自一个空集，通常为 $-\\infty$。在本问题中，每个案例至少有一个设计被证明是可行的。\n\n通过将此算法应用于为案例 A、B 和 C 提供的数据，我们可以计算出所需的最优目标值。例如，在案例 A 中，对于设计 $x^{(2)}$，生长上限为 $u_2=4$。对于场景 1，新的边界为 $[10, 4, 100, 3, 8]^\\top$。生长速率为 $\\mu^* = \\min(10, 4) = 4$，超过了阈值 $\\underline{\\mu}^{(1)}=0.5$。产物流为 $\\min(\\min(100, 3), 10 - 4 + \\tau) = \\min(3, 6+\\tau) = 3$。对所有设计和场景重复此过程以找到最终的最优值。对于案例 B，更严格的存活阈值 $\\underline{\\mu}^{(k)}$ 使得设计 $x^{(2)}$ 不可行，因为其上限为 $4$ 的生长速率小于 $\\underline{\\mu}^{(1)}=6$ 和 $\\underline{\\mu}^{(2)}=4.5$。最终的最优值是从每个案例中表现最佳的可行设计中得出的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-scenario bilevel strain design problem for three given cases.\n    \"\"\"\n    \n    # Global parameters from the problem statement\n    tau = 1e-9\n    designs = ['baseline', 'waste_ko', 'growth_cap', 'product_over']\n\n    def solve_case(base_upper_bounds, viability_thresholds):\n        \"\"\"\n        Calculates the optimal outer objective value for a single case.\n\n        This involves iterating through all possible designs, checking their viability\n        across all scenarios, and finding the design that maximizes the worst-case\n        product flux.\n        \"\"\"\n        max_worst_case_product = -np.inf\n\n        for design in designs:\n            scenario_product_fluxes = []\n            design_is_viable = True\n\n            for k in range(3):  # Iterate through the three scenarios\n                u_base = base_upper_bounds[k]\n                u_mod = u_base.copy()\n\n                # Apply design modifications to the base upper bounds\n                if design == 'waste_ko':\n                    # Design x^(1): Waste knockout\n                    u_mod[4] = 0.0\n                elif design == 'growth_cap':\n                    # Design x^(2): Growth cap\n                    u_mod[1] = min(u_base[1], 4.0)\n                elif design == 'product_over':\n                    # Design x^(3): Product overexpression\n                    u_mod[3] = 3.0 * u_base[3]\n\n                u1, u2, u3, u4, u5 = u_mod\n\n                # Analytically solve the inner optimization problems\n                \n                # LP1: Maximize growth (v_2)\n                # mu_star = min(u_1, u_2)\n                mu_star = min(u1, u2)\n\n                # Check viability constraint for the current scenario\n                if mu_star  viability_thresholds[k]:\n                    design_is_viable = False\n                    break  # This design is not viable, no need to check other scenarios\n\n                # LP2: Maximize product (v_4) subject to near-optimal growth\n                # vp = min(min(u_3, u_4), u_1 - min(u_1, u_2) + tau)\n                u4_prime = min(u3, u4)\n                if u1 = u2:\n                    # In this case, u_1 - min(u_1, u_2) = u_1 - u_1 = 0\n                    vp = min(u4_prime, tau)\n                else: # u1 > u2\n                    # In this case, u_1 - min(u_1, u_2) = u_1 - u_2\n                    vp = min(u4_prime, u1 - u2 + tau)\n                \n                scenario_product_fluxes.append(vp)\n            \n            # If the design was viable across all scenarios, evaluate its performance\n            if design_is_viable:\n                worst_case_product = min(scenario_product_fluxes)\n                if worst_case_product > max_worst_case_product:\n                    max_worst_case_product = worst_case_product\n\n        # If no design was viable, the result is -inf.\n        # The problem setup ensures at least one design is viable.\n        if max_worst_case_product == -np.inf:\n            return 0.0\n        \n        return max_worst_case_product\n\n    # Define the test cases from the problem statement.\n    case_A_ubs = [\n        np.array([10., 100., 100., 3., 8.]),\n        np.array([5., 100., 100., 1.5, 4.]),\n        np.array([8., 100., 100., 2., 7.])\n    ]\n    case_A_mus = [0.5, 0.2, 0.2]\n\n    # Case B uses the same bounds as Case A but with stricter viability thresholds.\n    case_B_ubs = case_A_ubs\n    case_B_mus = [6.0, 4.5, 4.0]\n\n    # Case C modifies the bounds of the third scenario from Case A.\n    case_C_ubs = [\n        np.array([10., 100., 100., 3., 8.]),\n        np.array([5., 100., 100., 1.5, 4.]),\n        np.array([8., 100., 100., 0.5, 7.])\n    ]\n    case_C_mus = case_A_mus\n\n    test_cases = [\n        (case_A_ubs, case_A_mus),\n        (case_B_ubs, case_B_mus),\n        (case_C_ubs, case_C_mus),\n    ]\n\n    results = []\n    for ubs, mus in test_cases:\n        result = solve_case(ubs, mus)\n        results.append(result)\n\n    # Format the final output string as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3290694"}]}