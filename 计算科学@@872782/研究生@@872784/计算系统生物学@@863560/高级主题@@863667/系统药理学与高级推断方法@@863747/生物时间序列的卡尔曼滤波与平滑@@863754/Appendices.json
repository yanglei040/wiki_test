{"hands_on_practices": [{"introduction": "在我们尝试使用卡尔曼滤波器从时间序列数据中推断潜在状态之前，必须首先回答一个基本问题：我们能否从可用的测量值中唯一地确定系统的状态？这个基本属性被称为“可观测性”。这项练习将引导你通过一个具体的基因表达模型，动手计算可观测性矩阵并评估其秩，从而掌握判断系统是否可观测的核心技能 [@problem_id:3322163]。", "problem": "一个双物种基因表达系统在一个固定的采样间隔内被建模为一个离散时间线性时不变(LTI)状态空间模型，该模型旨在用于荧光时间序列的卡尔曼滤波和平滑。潜状态 $x_{t} \\in \\mathbb{R}^{2}$ 包含了两个对数变换后的浓度，观测值 $y_{t} \\in \\mathbb{R}$ 是一个单通道的荧光读数。动态方程和观测方程由下式给出\n$$\nx_{t+1} = A x_{t}, \\quad y_{t} = C x_{t} + v_{t},\n$$\n其中 $v_{t}$ 是零均值高斯测量噪声，矩阵为\n$$\nA = \\begin{bmatrix} 1  0 \\\\ 0  0.5 \\end{bmatrix}, \\quad C = \\begin{bmatrix} 1  1 \\end{bmatrix}.\n$$\n在可观测性分析所依赖的无噪声思想实验中，不同的初始状态 $x_{0}$ 应产生不同的半无限输出序列 $\\{y_{t}\\}_{t=0}^{\\infty}$。\n\n严格从“一个离散时间线性系统是可观测的，当且仅当从初始状态 $x_{0}$ 到有限时间输出堆叠的映射具有平凡零空间”这一定义出发，按以下步骤进行：\n- 将前两个输出 $y_{0}$ 和 $y_{1}$ 表示为初始状态 $x_{0}$ 的线性函数。\n- 构建从 $x_{0}$ 到堆叠输出 $\\begin{bmatrix} y_{0} \\\\ y_{1} \\end{bmatrix}$ 的相应线性映射，并确定其像的维度。\n- 基于此分析，计算相关的可观测性映射的秩，并说明状态对 $(A,C)$ 是否使状态 $x_{t}$ 完全可观测（即，不同的 $x_{0}$ 是否产生不同的输出序列）。\n\n将可观测性映射的秩作为你的最终数值答案。请用一个不带单位的整数表示你的最终答案。", "solution": "问题陈述经核实具有科学依据、提法明确且客观。它提出了一个线性系统理论中的标准问题，涉及离散时间状态空间模型的可观测性，并为进行严格分析提供了所有必要的矩阵和定义。\n\n对状态空间系统的可观测性分析，其前提是确定初始状态 $x_{0}$ 是否能从观测序列 $\\{y_{t}\\}$ 中唯一确定。按照标准做法，此性质在无噪声的背景下进行评估。因此，为进行分析，我们将测量噪声项 $v_{t}$ 设置为 $0$。控制系统方程为：\n$$\nx_{t+1} = A x_{t}\n$$\n$$\ny_{t} = C x_{t}\n$$\n通过递归应用状态动态方程，任何时刻 $t$ 的状态可以表示为初始状态 $x_{0}$ 的函数：\n$$\nx_{t} = A^{t} x_{0}\n$$\n将此代入观测方程，得到时刻 $t$ 的输出作为初始状态的线性函数：\n$$\ny_{t} = C A^{t} x_{0}\n$$\n\n问题的第一部分要求将前两个输出 $y_{0}$ 和 $y_{1}$ 表示为初始状态 $x_{0} \\in \\mathbb{R}^{2}$ 的线性函数。\n对于时间 $t=0$，输出 $y_{0}$ 与 $x_{0}$ 的关系为：\n$$\ny_{0} = C A^{0} x_{0} = C I x_{0} = C x_{0}\n$$\n其中 $I$ 是 $2 \\times 2$ 的单位矩阵。使用给定的观测矩阵 $C = \\begin{bmatrix} 1  1 \\end{bmatrix}$ 并将初始状态向量定义为 $x_{0} = \\begin{bmatrix} x_{0,1} \\\\ x_{0,2} \\end{bmatrix}$，$y_{0}$ 的表达式变为：\n$$\ny_{0} = \\begin{bmatrix} 1  1 \\end{bmatrix} \\begin{bmatrix} x_{0,1} \\\\ x_{0,2} \\end{bmatrix} = x_{0,1} + x_{0,2}\n$$\n对于时间 $t=1$，输出 $y_{1}$ 与 $x_{0}$ 的关系为：\n$$\ny_{1} = C A^{1} x_{0} = C A x_{0}\n$$\n为继续进行，我们必须计算矩阵乘积 $CA$：\n$$\nCA = \\begin{bmatrix} 1  1 \\end{bmatrix} \\begin{bmatrix} 1  0 \\\\ 0  0.5 \\end{bmatrix} = \\begin{bmatrix} (1)(1) + (1)(0)  (1)(0) + (1)(0.5) \\end{bmatrix} = \\begin{bmatrix} 1  0.5 \\end{bmatrix}\n$$\n利用这个结果，我们可以将 $y_{1}$ 表示为 $x_{0}$ 的函数：\n$$\ny_{1} = \\begin{bmatrix} 1  0.5 \\end{bmatrix} \\begin{bmatrix} x_{0,1} \\\\ x_{0,2} \\end{bmatrix} = x_{0,1} + 0.5 x_{0,2}\n$$\n\n问题的第二部分涉及构建从 $x_{0}$ 到堆叠输出 $\\begin{bmatrix} y_{0} \\\\ y_{1} \\end{bmatrix}$ 的线性映射，并确定其像的维度。我们可以将这个堆叠的方程组写成矩阵形式：\n$$\n\\begin{bmatrix} y_{0} \\\\ y_{1} \\end{bmatrix} = \\begin{bmatrix} C x_{0} \\\\ C A x_{0} \\end{bmatrix} = \\begin{bmatrix} C \\\\ CA \\end{bmatrix} x_{0}\n$$\n从初始状态 $x_{0}$ 到输出向量 $\\begin{bmatrix} y_{0} \\\\ y_{1} \\end{bmatrix}$ 的线性映射由矩阵 $\\mathcal{O}_{2} = \\begin{bmatrix} C \\\\ CA \\end{bmatrix}$ 表示。这个矩阵是在 $2$ 个时间步长（从 $t=0$ 到 $t=1$）的有限观测范围内的可观测性矩阵。代入先前计算的矩阵 $C$ 和 $CA$：\n$$\n\\mathcal{O}_{2} = \\begin{bmatrix} 1  1 \\\\ 1  0.5 \\end{bmatrix}\n$$\n该线性映射的像是矩阵 $\\mathcal{O}_{2}$ 的列空间。根据定义，像的维度就是矩阵的秩。对于方阵，可以通过计算其行列式来评估秩。\n$$\n\\det(\\mathcal{O}_{2}) = (1)(0.5) - (1)(1) = 0.5 - 1 = -0.5\n$$\n由于行列式非零（$\\det(\\mathcal{O}_{2}) \\neq 0$），该矩阵是可逆的，因此具有满秩。秩等于列数（或行数），即 $2$。因此，该映射的像的维度是 $2$。\n\n问题的最后一部分要求计算相关的可观测性映射的秩，并对系统的可观测性得出结论。对于状态维度为 $n$ 的离散时间LTI系统，可观测性映射（或可观测性矩阵）$\\mathcal{O}$ 由卡尔曼可观测性判据定义为：\n$$\n\\mathcal{O} = \\begin{bmatrix} C \\\\ CA \\\\ CA^{2} \\\\ \\vdots \\\\ CA^{n-1} \\end{bmatrix}\n$$\n在这个问题中，状态维度为 $n=2$。因此，可观测性映射为：\n$$\n\\mathcal{O} = \\begin{bmatrix} C \\\\ CA^{2-1} \\end{bmatrix} = \\begin{bmatrix} C \\\\ CA \\end{bmatrix}\n$$\n这正是前一步中构建和分析的矩阵 $\\mathcal{O}_{2}$。因此，可观测性映射的秩为：\n$$\n\\text{rank}(\\mathcal{O}) = \\text{rank}(\\mathcal{O}_{2}) = 2\n$$\n一个系统被定义为完全可观测的，当且仅当其可观测性映射 $\\mathcal{O}$ 具有满列秩，即 $\\text{rank}(\\mathcal{O}) = n$。在本例中，状态维度 $n=2$，我们已经求得 $\\text{rank}(\\mathcal{O}) = 2$。条件 $\\text{rank}(\\mathcal{O}) = n$ 得到满足。因此，对 $(A, C)$ 使状态 $x_{t}$ 完全可观测。这意味着 $\\mathcal{O}$ 的零空间是平凡的，仅包含零向量。因此，如果对于两个初始状态有 $\\mathcal{O} x_{0,a} = \\mathcal{O} x_{0,b}$，那么必然有 $x_{0,a} = x_{0,b}$。不同的初始状态必然产生不同的输出序列，并且初始状态 $x_{0}$ 可以从前 $n=2$ 个测量值中唯一确定。\n\n问题明确要求可观测性映射的秩。根据形式计算，该秩为 $2$。", "answer": "$$\\boxed{2}$$", "id": "3322163"}, {"introduction": "卡尔曼滤波器为我们提供了给定截至当前时间所有测量的状态估计。然而，在许多生物学应用中，我们希望利用整个数据集（包括未来的测量）来获得对过去状态的最精确估计。Rauch-Tung-Striebel (RTS) 平滑器正是为此目的而设计的，它通过一个反向传递过程来修正滤波后的估计。本练习将要求你对一个模拟信使核糖核酸 (mRNA) 和蛋白质动力学的系统，应用 RTS 平滑递归，从而具体体验如何从滤波结果中计算出更精确的平滑状态轨迹 [@problem_id:3322157]。", "problem": "一个二维潜状态表示单个细胞中信使核糖核酸 (mRNA) 和蛋白质的对数丰度，记为向量 $x_t \\in \\mathbb{R}^2$，其分量为 $x_{t,1}$ (mRNA) 和 $x_{t,2}$ (蛋白质)。其动态被建模为一个线性高斯状态空间模型，状态演化为随机游走，并伴有直接带噪观测：\n$$\nx_{t+1} = A x_t + w_t, \\quad w_t \\sim \\mathcal{N}(0,Q), \\\\\ny_t = C x_t + v_t, \\quad v_t \\sim \\mathcal{N}(0,R),\n$$\n其中 $A \\in \\mathbb{R}^{2 \\times 2}$、$Q \\in \\mathbb{R}^{2 \\times 2}$、$C \\in \\mathbb{R}^{2 \\times 2}$ 和 $R \\in \\mathbb{R}^{2 \\times 2}$ 不随时间变化。考虑在时间 $t \\in \\{1,2,3\\}$ 上的一个三步序列，其中\n$$\nA = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}, \\quad\nQ = \\begin{pmatrix} 0.09  0 \\\\ 0  0.04 \\end{pmatrix}, \\quad\nC = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}, \\quad\nR = \\begin{pmatrix} 0.50  0 \\\\ 0  0.50 \\end{pmatrix}.\n$$\n通过卡尔曼滤波器的完整前向传递，滤波后的后验均值和协方差给出如下：\n$$\nx_{1|1} = \\begin{pmatrix} 1.0 \\\\ 2.0 \\end{pmatrix}, \\quad\nP_{1|1} = \\begin{pmatrix} 0.25  0 \\\\ 0  0.16 \\end{pmatrix},\n$$\n$$\nx_{2|2} = \\begin{pmatrix} 1.2 \\\\ 1.8 \\end{pmatrix}, \\quad\nP_{2|2} = \\begin{pmatrix} 0.20  0 \\\\ 0  0.12 \\end{pmatrix},\n$$\n$$\nx_{3|3} = \\begin{pmatrix} 0.9 \\\\ 2.1 \\end{pmatrix}, \\quad\nP_{3|3} = \\begin{pmatrix} 0.15  0 \\\\ 0  0.10 \\end{pmatrix}.\n$$\n仅使用线性高斯状态空间模型的基本定义和联合高斯变量的性质，推导适用于此设置的Rauch–Tung–Striebel (RTS) 平滑递归，并用它们计算在 $t \\in \\{1,2,3\\}$ 时平滑后的后验均值 $x_{t|3}$ 和协方差 $P_{t|3}$。作为您最终报告的量，提供在时间 $t=1$ 处的平滑协方差的第一个对角线元素，即标量 $(P_{1|3})_{11}$。将最终答案表示为精确值（不进行四舍五入）。对数丰度变量是无量纲的；报告该标量时无需单位。", "solution": "经评估，该问题是有效的，因为它具有科学依据，提法明确，客观，并且包含一套完整且一致的给定条件。它提出了一个计算系统生物学领域中涉及卡尔曼平滑的标准的、可解的问题。\n\n该问题要求推导Rauch–Tung–Striebel (RTS) 平滑递归，并将其应用于一个特定的线性高斯状态空间模型。该模型描述了在时间序列 $t \\in \\{1, 2, 3\\}$ 上mRNA和蛋白质的对数丰度 $x_t = \\begin{pmatrix} x_{t,1} \\\\ x_{t,2} \\end{pmatrix}$ 的动态。总时间步数为 $T=3$。平滑后的后验矩 $x_{t|T}$ 和 $P_{t|T}$ 是在给定所有测量值 $y_{1:T}$（即 $p(x_t | y_1, \\dots, y_T)$）的条件下，状态 $x_t$ 的均值和协方差。\n\n**RTS平滑递归的推导**\n\n推导过程通过考虑在所有可用数据 $y_{1:T}$ 条件下，状态 $x_t$ 和 $x_{t+1}$ 的联合分布来进行。根据条件概率法则，我们可以写出：\n$$p(x_t, x_{t+1} | y_{1:T}) = p(x_t | x_{t+1}, y_{1:T}) p(x_{t+1} | y_{1:T})$$\n由于状态空间模型的马尔可夫结构，在给定状态 $x_{t+1}$ 的条件下，状态 $x_t$ 与未来的测量值 $y_{t+1:T}$ 条件独立。因此，$p(x_t | x_{t+1}, y_{1:T}) = p(x_t | x_{t+1}, y_{1:t})$。\n\n我们的第一步是刻画联合分布 $p(x_t, x_{t+1} | y_{1:t})$。卡尔曼滤波器提供了滤波后的后验分布 $p(x_t | y_{1:t}) = \\mathcal{N}(x_t; x_{t|t}, P_{t|t})$。状态演化为 $x_{t+1} = A x_t + w_t$。由于 $x_t$（在 $y_{1:t}$ 条件下）和 $w_t$ 是独立的高斯变量，它们的线性组合 $x_{t+1}$ 也是高斯分布的。因此，在 $y_{1:t}$ 条件下，$(x_t, x_{t+1})$ 的联合分布是高斯分布。其矩为：\n$$E\\begin{pmatrix} x_t \\\\ x_{t+1} \\end{pmatrix} | y_{1:t} = \\begin{pmatrix} E[x_t | y_{1:t}] \\\\ E[A x_t + w_t | y_{1:t}] \\end{pmatrix} = \\begin{pmatrix} x_{t|t} \\\\ A x_{t|t} \\end{pmatrix} = \\begin{pmatrix} x_{t|t} \\\\ x_{t+1|t} \\end{pmatrix}$$\n$$Cov\\begin{pmatrix} x_t \\\\ x_{t+1} \\end{pmatrix} | y_{1:t} = \\begin{pmatrix} Cov(x_t)  Cov(x_t, x_{t+1}) \\\\ Cov(x_{t+1}, x_t)  Cov(x_{t+1}) \\end{pmatrix}_{|y_{1:t}}$$\n对角块是滤波和预测协方差：$Cov(x_t|y_{1:t}) = P_{t|t}$ 和 $Cov(x_{t+1}|y_{1:t}) = P_{t+1|t} = A P_{t|t} A^T + Q$。非对角块是 $Cov(x_t, x_{t+1} | y_{1:t}) = Cov(x_t, A x_t + w_t | y_{1:t}) = Cov(x_t, A x_t | y_{1:t}) = P_{t|t} A^T$。\n因此，我们有联合分布：\n$$p(x_t, x_{t+1} | y_{1:t}) = \\mathcal{N}\\left( \\begin{pmatrix} x_{t|t} \\\\ x_{t+1|t} \\end{pmatrix}, \\begin{pmatrix} P_{t|t}  P_{t|t}A^T \\\\ A P_{t|t}  P_{t+1|t} \\end{pmatrix} \\right)$$\n使用条件高斯分布的公式，我们发现 $p(x_t | x_{t+1}, y_{1:t})$ 是一个高斯分布，其均值和协方差为：\n$$ E[x_t | x_{t+1}, y_{1:t}] = x_{t|t} + P_{t|t} A^T P_{t+1|t}^{-1} (x_{t+1} - x_{t+1|t}) $$\n$$ Cov(x_t | x_{t+1}, y_{1:t}) = P_{t|t} - P_{t|t} A^T P_{t+1|t}^{-1} A P_{t|t} $$\n我们定义平滑增益矩阵 $G_t = P_{t|t} A^T P_{t+1|t}^{-1}$。\n\n平滑均值 $x_{t|T}$ 使用全期望定律求得：\n$$x_{t|T} = E[x_t | y_{1:T}] = E_{x_{t+1}|y_{1:T}} \\left[ E[x_t | x_{t+1}, y_{1:T}] \\right]$$\n$$x_{t|T} = E_{x_{t+1}|y_{1:T}} \\left[ x_{t|t} + G_t (x_{t+1} - x_{t+1|t}) \\right]$$\n$$x_{t|T} = x_{t|t} + G_t (E[x_{t+1} | y_{1:T}] - x_{t+1|t}) = x_{t|t} + G_t (x_{t+1|T} - x_{t+1|t})$$\n这是平滑均值的后向递归。\n\n平滑协方差 $P_{t|T}$ 使用全协方差定律求得：\n$$P_{t|T} = Cov(x_t | y_{1:T}) = E_{x_{t+1}|y_{1:T}} \\left[ Cov(x_t | x_{t+1}, y_{1:T}) \\right] + Cov_{x_{t+1}|y_{1:T}} \\left( E[x_t | x_{t+1}, y_{1:T}] \\right)$$\n第一项不依赖于 $x_{t+1}$，所以期望是平凡的：\n$$E[\\dots] = P_{t|t} - G_t A P_{t|t} = P_{t|t} - G_t (P_{t|t} A^T)^T = P_{t|t} - G_t (G_t P_{t+1|t})^T = P_{t|t} - G_t P_{t+1|t} G_t^T$$\n第二项是：\n$$Cov(\\dots) = Cov(x_{t|t} + G_t (x_{t+1} - x_{t+1|t}) | y_{1:T}) = G_t Cov(x_{t+1} | y_{1:T}) G_t^T = G_t P_{t+1|T} G_t^T$$\n结合这些项，得到平滑协方差的后向递归：\n$$P_{t|T} = (P_{t|t} - G_t P_{t+1|t} G_t^T) + G_t P_{t+1|T} G_t^T = P_{t|t} + G_t (P_{t+1|T} - P_{t+1|t}) G_t^T$$\n\n**应用于本问题**\n\n在本问题中，$A$ 是单位矩阵，并且所有协方差矩阵 $Q, R, P_{t|t}$ 都是对角矩阵。这意味着两个状态变量 $x_{t,1}$ 和 $x_{t,2}$ 的动态是解耦的。卡尔曼滤波和平滑可以对每个标量分量独立进行。我们被要求计算 $(P_{1|3})_{11}$，即第一个分量的方差。我们记第一个分量的标量方差为 $p_{t|s} = (P_{t|s})_{11}$，过程噪声方差为 $q = Q_{11} = 0.09$。对于这个标量分量，当 $A=1$ 时，递归式为：\n$p_{t+1|t} = p_{t|t} + q$\n$g_t = p_{t|t} / p_{t+1|t}$\n$p_{t|T} = p_{t|t} + g_t^2 (p_{t+1|T} - p_{t+1|t})$\n平滑从 $t=T-1=2$ 到 $t=1$ 后向进行。初始化为 $p_{3|3} = (P_{3|3})_{11} = 0.15$。\n\n**$t=2$ 时的平滑方差**：\n首先，我们使用前向传递得到的滤波方差 $p_{2|2} = (P_{2|2})_{11} = 0.20$ 来计算预测方差 $p_{3|2}$。\n$p_{3|2} = p_{2|2} + q = 0.20 + 0.09 = 0.29$\n接下来，我们计算平滑增益 $g_2$：\n$g_2 = \\frac{p_{2|2}}{p_{3|2}} = \\frac{0.20}{0.29} = \\frac{20}{29}$\n现在我们计算平滑方差 $p_{2|3}$：\n$p_{2|3} = p_{2|2} + g_2^2 (p_{3|3} - p_{3|2}) = 0.20 + \\left(\\frac{20}{29}\\right)^2 (0.15 - 0.29)$\n$p_{2|3} = \\frac{1}{5} + \\frac{400}{841}(-0.14) = \\frac{1}{5} - \\frac{400}{841} \\frac{14}{100} = \\frac{1}{5} - \\frac{56}{841}$\n$p_{2|3} = \\frac{841 - 5 \\times 56}{5 \\times 841} = \\frac{841-280}{4205} = \\frac{561}{4205}$\n\n**$t=1$ 时的平滑方差**：\n我们对 $t=1$ 重复此过程。首先，我们使用滤波方差 $p_{1|1} = (P_{1|1})_{11} = 0.25$ 计算预测方差 $p_{2|1}$。\n$p_{2|1} = p_{1|1} + q = 0.25 + 0.09 = 0.34$\n接下来，我们计算平滑增益 $g_1$：\n$g_1 = \\frac{p_{1|1}}{p_{2|1}} = \\frac{0.25}{0.34} = \\frac{25}{34}$\n现在我们计算最终的平滑方差 $p_{1|3}$：\n$p_{1|3} = p_{1|1} + g_1^2 (p_{2|3} - p_{2|1})$\n$p_{1|3} = 0.25 + \\left(\\frac{25}{34}\\right)^2 \\left(\\frac{561}{4205} - 0.34\\right)$\n$p_{1|3} = \\frac{1}{4} + \\frac{625}{1156} \\left(\\frac{561}{4205} - \\frac{34}{100}\\right) = \\frac{1}{4} + \\frac{625}{1156} \\left(\\frac{561}{4205} - \\frac{17}{50}\\right)$\n括号中的项是：\n$\\frac{561 \\times 50 - 17 \\times 4205}{4205 \\times 50} = \\frac{28050 - 71485}{210250} = \\frac{-43435}{210250} = -\\frac{8687}{42050}$\n将其代回：\n$p_{1|3} = \\frac{1}{4} + \\frac{625}{1156} \\left(-\\frac{8687}{42050}\\right)$\n我们通过对常数进行因式分解来简化乘积项：\n$$ \\frac{625}{1156} \\frac{8687}{42050} = \\frac{5^4}{2^2 \\cdot 17^2} \\frac{7 \\cdot 17 \\cdot 73}{2 \\cdot 5^2 \\cdot 29^2} = \\frac{5^2 \\cdot 7 \\cdot 73}{2^3 \\cdot 17 \\cdot 29^2} = \\frac{25 \\cdot 511}{8 \\cdot 17 \\cdot 841} = \\frac{12775}{114376} $$\n最后，我们计算 $p_{1|3}$：\n$p_{1|3} = \\frac{1}{4} - \\frac{12775}{114376} = \\frac{28594}{114376} - \\frac{12775}{114376} = \\frac{15819}{114376}$\n分子可因式分解为 $3 \\times 5273$，而分母的因子是 $2$、$17$ 和 $29$。该分式不可约。", "answer": "$$\\boxed{\\frac{15819}{114376}}$$", "id": "3322157"}, {"introduction": "现实世界中的生物系统，如基因调控网络，本质上是高度非线性的，这超出了标准卡尔曼滤波器的适用范围。无迹卡尔曼滤波器 (Unscented Kalman Filter, UKF) 是一种强大的高级方法，它通过一种确定的采样策略（无迹变换）来处理非线性，而无需计算复杂的雅可比矩阵。这项实践是一个综合性的编程练习，你将为一个典型的非线性基因表达模型实现 UKF 的预测和更新步骤，从而将理论知识转化为解决复杂生物系统问题的实用技能 [@problem_id:3322180]。", "problem": "考虑以下非线性二维生物化学基因表达模型，该模型带有加性高斯过程噪声和测量噪声，适用于无迹卡尔曼滤波器（UKF）的单步预测和更新。潜在状态为 $x_t = [m_t, p_t]^\\top$，其中 $m_t$ 是信使RNA（mRNA）浓度，单位为纳摩尔（nM），$p_t$ 是蛋白质浓度，单位为纳摩尔（nM）。其连续时间动态由以下耦合非线性常微分方程给出\n$$\n\\frac{dm}{dt} = \\frac{k_{\\mathrm{txn}}}{1 + \\left(\\frac{p}{K_{\\mathrm{rep}}}\\right)^{n_{\\mathrm{H}}}} - d_m m, \\quad\n\\frac{dp}{dt} = k_{\\mathrm{tl}} m - d_p p.\n$$\n这些动态通过步长为 $\\Delta t$ 的前向欧拉法进行离散化，得到一个非线性离散时间状态转移函数 $f(\\cdot)$：\n$$\nx_{t+1} = f(x_t) + w_t, \\quad f([m,p]^\\top) = \n\\begin{bmatrix}\nm + \\Delta t\\left(\\dfrac{k_{\\mathrm{txn}}}{1 + \\left(\\dfrac{p}{K_{\\mathrm{rep}}}\\right)^{n_{\\mathrm{H}}}} - d_m m\\right) \\\\\np + \\Delta t\\left(k_{\\mathrm{tl}} m - d_p p\\right)\n\\end{bmatrix},\n$$\n其中过程噪声 $w_t \\sim \\mathcal{N}(0, Q)$。测量是蛋白质的饱和荧光读数，\n$$\ny_t = h(x_t) + v_t, \\quad h([m,p]^\\top) = c \\cdot \\frac{p}{K_f + p},\n$$\n其中测量噪声 $v_t \\sim \\mathcal{N}(0, R)$。\n\n假设在时间 $t$ 有一个高斯先验，其均值为 $x_t \\sim \\mathcal{N}(\\mu_t, P_t)$。您必须实现一个无迹卡尔曼滤波器（UKF）的预测步骤，使用带有参数 $(\\alpha, \\beta, \\kappa)$ 的无迹变换来生成sigma点，将它们通过 $f(\\cdot)$ 和 $h(\\cdot)$ 进行传播，然后在给定观测值 $y_{t+1}$ 的情况下，在时间 $t+1$ 执行一次测量更新。使用无迹变换的sigma点和权重的标准定义，并假设在需要时所有协方差均为对称正定。使用Cholesky分解来生成sigma点；如果出现数值问题，可以添加最小的对角线抖动以在分解过程中保持正定性。\n\n所有状态的物理量必须以纳摩尔（nM）表示，状态协方差以 $(\\mathrm{nM})^2$ 表示。测量值 $y_t$ 的单位是任意荧光单位。您的程序应只产生数值输出（无单位字符串），但在解释这些值时必须遵守这些单位。\n\n模型参数值固定如下：\n- $\\Delta t = 0.1$,\n- $k_{\\mathrm{txn}} = 60.0$,\n- $K_{\\mathrm{rep}} = 250.0$,\n- $n_{\\mathrm{H}} = 2.0$,\n- $d_m = 1.2$,\n- $k_{\\mathrm{tl}} = 4.5$,\n- $d_p = 0.15$,\n- $c = 1000.0$,\n- $K_f = 150.0$,\n- $Q = \\mathrm{diag}(2.0, 10.0)$ in $(\\mathrm{nM})^2$,\n- $R = [25.0]$ (标量).\n\n测试套件。对于以下三种情况，计算：\n1. UKF预测均值 $\\hat{\\mu}_{t+1|t}$ 和协方差 $\\hat{P}_{t+1|t}$。\n2. 给定相应的观测值 $y_{t+1}$，UKF更新后的均值 $\\mu_{t+1|t+1}$ 和协方差 $P_{t+1|t+1}$。\n\n然后，对于每种情况，记录列表 $[\\hat{\\mu}_{t+1|t}^{(1)}, \\hat{\\mu}_{t+1|t}^{(2)}, \\mu_{t+1|t+1}^{(1)}, \\mu_{t+1|t+1}^{(2)}, \\mathrm{tr}(\\hat{P}_{t+1|t}), \\mathrm{tr}(P_{t+1|t+1})]$，其中上标 $(i)$ 表示第 $i$ 个分量。所有状态值以 $\\mathrm{nM}$ 表示，迹以 $(\\mathrm{nM})^2$ 表示。将这些列表中的每个浮点数条目四舍五入到恰好六位小数。\n\n- 情况 1:\n  - 先验均值 $\\mu_t = [40.0, 200.0]^\\top$,\n  - 先验协方差 $P_t = \\begin{bmatrix} 25.0  0.0 \\\\ 0.0  400.0 \\end{bmatrix}$,\n  - 无迹变换参数 $(\\alpha, \\beta, \\kappa) = (0.7, 2.0, 0.0)$,\n  - 观测值 $y_{t+1} = 600.0$。\n- 情况 2:\n  - 先验均值 $\\mu_t = [5.0, 30.0]^\\top$,\n  - 先验协方差 $P_t = \\begin{bmatrix} 9.0  0.0 \\\\ 0.0  100.0 \\end{bmatrix}$,\n  - 无迹变换参数 $(\\alpha, \\beta, \\kappa) = (0.5, 2.0, 1.0)$,\n  - 观测值 $y_{t+1} = 120.0$。\n- 情况 3:\n  - 先验均值 $\\mu_t = [80.0, 400.0]^\\top$,\n  - 先验协方差 $P_t = \\begin{bmatrix} 16.0  0.0 \\\\ 0.0  256.0 \\end{bmatrix}$,\n  - 无迹变换参数 $(\\alpha, \\beta, \\kappa) = (1.1, 2.0, 0.0)$,\n  - 观测值 $y_{t+1} = 800.0$。\n\n最终输出格式。您的程序应该生成单行输出，其中包含一个Python风格的列表，该列表包含三个子列表（每个测试用例一个），每个子列表包含六个如上所述四舍五入到六位小数的浮点值。例如，它应该看起来像\n$$\n[[a_1, a_2, a_3, a_4, a_5, a_6],[b_1, b_2, b_3, b_4, b_5, b_6],[c_1, c_2, c_3, c_4, c_5, c_6]]\n$$\n并且不打印任何额外的文本。", "solution": "该问题要求为一个非线性二维生物化学基因表达模型实现无迹卡尔曼滤波器（UKF）的单次预测和更新步骤。该问题定义明确，有科学依据，并包含了进行求解所需的所有必要信息。\n\n无迹卡尔曼滤波器是一种用于非线性动力系统中状态估计的先进算法。它通过避免对系统动态和测量函数进行解析推导和线性化，从而优于扩展卡尔曼滤波器（EKF）。相反，UKF采用无迹变换（UT），这是一种确定性采样技术，它将一组最小化的采样点（称为sigma点）通过真实的非线性函数进行传播。然后从传播后的sigma点中恢复状态分布的均值和协方差，得到的近似值对于任何非线性至少精确到二阶，对于高斯分布的先验则精确到更高阶。\n\n系统状态是一个二维向量 $x_t = [m_t, p_t]^\\top$，其中 $m_t$ 是mRNA浓度，$p_t$ 是蛋白质浓度。状态维度为 $L=2$。我们给定时间 $t$ 的状态先验分布，假设为高斯分布：$x_t \\sim \\mathcal{N}(\\mu_t, P_t)$。目标是在给定测量值 $y_{t+1}$ 的情况下，计算时间 $t+1$ 的后验分布 $x_{t+1} \\sim \\mathcal{N}(\\mu_{t+1|t+1}, P_{t+1|t+1})$。\n\nUKF算法主要分两个阶段进行：预测和更新。\n\n### 1. Sigma点生成和权重计算\n\n无迹变换首先从先验分布 $\\mathcal{N}(\\mu_t, P_t)$ 中生成一组 $2L+1$ 个sigma点及相应的权重。这些点的散布由参数 $\\alpha$、$\\beta$ 和 $\\kappa$ 控制。\n\n首先，计算一个复合缩放参数 $\\lambda$：\n$$\n\\lambda = \\alpha^2(L + \\kappa) - L\n$$\n接下来，为 $2L+1$ 个sigma点中的每一个确定用于均值（$W^{(m)}$）和协方差（$W^{(c)}$）的权重。\n$$\n\\begin{align*}\nW_0^{(m)} = \\frac{\\lambda}{L+\\lambda} \\\\\nW_0^{(c)} = \\frac{\\lambda}{L+\\lambda} + (1 - \\alpha^2 + \\beta) \\\\\nW_i^{(m)} = W_i^{(c)} = \\frac{1}{2(L+\\lambda)}, \\quad \\text{for } i = 1, \\dots, 2L\n\\end{align*}\n$$\n然后生成sigma点 $\\mathcal{X}_t$。这需要计算缩放后协方差矩阵的矩阵平方根，该计算使用Cholesky分解完成：$S = \\text{chol}((L+\\lambda)P_t)$。\n$$\n\\begin{align*}\n\\mathcal{X}_{t,0} = \\mu_t \\\\\n\\mathcal{X}_{t,i} = \\mu_t + S_i, \\quad \\text{for } i = 1, \\dots, L \\\\\n\\mathcal{X}_{t,i} = \\mu_t - S_{i-L}, \\quad \\text{for } i = L+1, \\dots, 2L\n\\end{align*}\n$$\n其中 $S_i$ 是矩阵 $S$ 的第 $i$ 列。\n\n### 2. 预测步骤\n\n预测步骤使用非线性状态转移函数 $f(\\cdot)$ 将状态分布从时间 $t$ 传播到 $t+1$。\n\n生成的sigma点 $\\mathcal{X}_{t,i}$ 被逐一通过 $f(\\cdot)$：\n$$\n\\mathcal{Y}_i = f(\\mathcal{X}_{t,i}), \\quad \\text{for } i = 0, \\dots, 2L\n$$\n其中 $f([m,p]^\\top) = \\begin{bmatrix} m + \\Delta t\\left(\\dfrac{k_{\\mathrm{txn}}}{1 + \\left(\\frac{p}{K_{\\mathrm{rep}}}\\right)^{n_{\\mathrm{H}}}} - d_m m\\right) \\\\ p + \\Delta t\\left(k_{\\mathrm{tl}} m - d_p p\\right) \\end{bmatrix}$。\n\n预测的状态均值 $\\hat{\\mu}_{t+1|t}$ 是这些传播后点的加权平均值：\n$$\n\\hat{\\mu}_{t+1|t} = \\sum_{i=0}^{2L} W_i^{(m)} \\mathcal{Y}_i\n$$\n预测的状态协方差 $\\hat{P}_{t+1|t}$ 是传播后的点与预测均值之间偏差的加权外积，再加上过程噪声协方差 $Q$：\n$$\n\\hat{P}_{t+1|t} = \\sum_{i=0}^{2L} W_i^{(c)} (\\mathcal{Y}_i - \\hat{\\mu}_{t+1|t})(\\mathcal{Y}_i - \\hat{\\mu}_{t+1|t})^\\top + Q\n$$\n\n### 3. 更新步骤\n\n更新步骤结合测量值 $y_{t+1}$ 来修正预测的状态分布。\n\n传播后的状态sigma点 $\\mathcal{Y}_i$ 使用非线性测量函数 $h(\\cdot)$ 转换到测量空间：\n$$\n\\mathcal{Z}_i = h(\\mathcal{Y}_i), \\quad \\text{for } i = 0, \\dots, 2L\n$$\n其中 $h([m,p]^\\top) = c \\cdot \\frac{p}{K_f + p}$。\n\n预测的测量均值 $\\hat{y}_{t+1}$ 是转换后点的加权平均值：\n$$\n\\hat{y}_{t+1} = \\sum_{i=0}^{2L} W_i^{(m)} \\mathcal{Z}_i\n$$\n计算新息协方差 $P_{yy}$（预测的测量协方差），其中包括测量噪声协方差 $R$：\n$$\nP_{yy} = \\sum_{i=0}^{2L} W_i^{(c)} (\\mathcal{Z}_i - \\hat{y}_{t+1})(\\mathcal{Z}_i - \\hat{y}_{t+1})^\\top + R\n$$\n状态和测量之间的互协方差 $P_{xy}$ 计算如下：\n$$\nP_{xy} = \\sum_{i=0}^{2L} W_i^{(c)} (\\mathcal{Y}_i - \\hat{\\mu}_{t+1|t})(\\mathcal{Z}_i - \\hat{y}_{t+1})^\\top\n$$\n然后计算卡尔曼增益 $K_{t+1}$：\n$$\nK_{t+1} = P_{xy} P_{yy}^{-1}\n$$\n最后，使用测量新息 $(y_{t+1} - \\hat{y}_{t+1})$ 和卡尔曼增益来更新预测的均值和协方差：\n$$\n\\begin{align*}\n\\mu_{t+1|t+1} = \\hat{\\mu}_{t+1|t} + K_{t+1} (y_{t+1} - \\hat{y}_{t+1}) \\\\\nP_{t+1|t+1} = \\hat{P}_{t+1|t} - K_{t+1} P_{yy} K_{t+1}^\\top\n\\end{align*}\n$$\n此过程提供了更新后的状态均值 $\\mu_{t+1|t+1}$ 和协方差 $P_{t+1|t+1}$。以下程序实现了该算法，以计算三个指定测试用例所需的值。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import cholesky\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the UKF calculations for all test cases.\n    \"\"\"\n    \n    # Fixed model parameter values\n    params = {\n        'dt': 0.1,\n        'k_txn': 60.0,\n        'K_rep': 250.0,\n        'n_H': 2.0,\n        'd_m': 1.2,\n        'k_tl': 4.5,\n        'd_p': 0.15,\n        'c': 1000.0,\n        'K_f': 150.0,\n    }\n    \n    Q = np.diag([2.0, 10.0])\n    R = np.array([[25.0]])\n\n    # Define the nonlinear state transition function f(x)\n    def f(x, p):\n        m, pt = x[0], x[1]\n        m_dot = p['k_txn'] / (1.0 + (pt / p['K_rep'])**p['n_H']) - p['d_m'] * m\n        p_dot = p['k_tl'] * m - p['d_p'] * pt\n        \n        m_next = m + p['dt'] * m_dot\n        p_next = pt + p['dt'] * p_dot\n        \n        return np.array([m_next, p_next])\n\n    # Define the nonlinear measurement function h(x)\n    def h(x, p):\n        pt = x[1]\n        return np.array([p['c'] * pt / (p['K_f'] + pt)])\n\n    test_cases = [\n        {\n            'mu_t': np.array([40.0, 200.0]),\n            'P_t': np.array([[25.0, 0.0], [0.0, 400.0]]),\n            'ukf_params': (0.7, 2.0, 0.0), # alpha, beta, kappa\n            'y_tp1': 600.0,\n        },\n        {\n            'mu_t': np.array([5.0, 30.0]),\n            'P_t': np.array([[9.0, 0.0], [0.0, 100.0]]),\n            'ukf_params': (0.5, 2.0, 1.0),\n            'y_tp1': 120.0,\n        },\n        {\n            'mu_t': np.array([80.0, 400.0]),\n            'P_t': np.array([[16.0, 0.0], [0.0, 256.0]]),\n            'ukf_params': (1.1, 2.0, 0.0),\n            'y_tp1': 800.0,\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = ukf_one_step(case['mu_t'], case['P_t'], Q, R, f, h, \n                              params, case['y_tp1'], case['ukf_params'])\n        all_results.append(result)\n        \n    # Format output string\n    formatted_cases = []\n    for res in all_results:\n        formatted_res = [f\"{val:.6f}\" for val in res]\n        formatted_cases.append(f\"[{','.join(formatted_res)}]\")\n    \n    final_output = f\"[{','.join(formatted_cases)}]\"\n    print(final_output)\n\ndef ukf_one_step(mu, P, Q, R, f_func, h_func, model_params, y_obs, ukf_params):\n    \"\"\"\n    Performs one prediction and update step of the Unscented Kalman Filter.\n    \"\"\"\n    L = len(mu)\n    alpha, beta, kappa = ukf_params\n\n    # 1. Calculate weights and sigma points\n    lam = alpha**2 * (L + kappa) - L\n    \n    wm = np.full(2 * L + 1, 1. / (2. * (L + lam)))\n    wc = np.full(2 * L + 1, 1. / (2. * (L + lam)))\n    wm[0] = lam / (L + lam)\n    wc[0] = lam / (L + lam) + (1. - alpha**2 + beta)\n\n    # Use cholesky decomposition to get matrix square root\n    # Add a small jitter for numerical stability if necessary, though not expected here.\n    try:\n        S = cholesky((L + lam) * P)\n    except np.linalg.LinAlgError:\n        S = cholesky((L + lam) * P + np.eye(L) * 1e-6)\n\n    # Generate sigma points\n    sigma_points = np.zeros((2 * L + 1, L))\n    sigma_points[0] = mu\n    for i in range(L):\n        sigma_points[i + 1]   = mu + S[:, i]\n        sigma_points[i + L + 1] = mu - S[:, i]\n        \n    # 2. Prediction step\n    # Propagate sigma points through process model f\n    propagated_sigmas = np.array([f_func(s, model_params) for s in sigma_points])\n    \n    # Predicted state mean\n    mu_pred = np.dot(wm, propagated_sigmas)\n\n    # Predicted state covariance\n    P_pred = np.zeros((L, L))\n    for i in range(2 * L + 1):\n        diff = propagated_sigmas[i] - mu_pred\n        P_pred += wc[i] * np.outer(diff, diff)\n    P_pred += Q\n\n    # 3. Update step\n    # Propagate predicted sigma points through measurement model h\n    measurement_sigmas = np.array([h_func(s, model_params) for s in propagated_sigmas])\n    \n    # Predicted measurement mean\n    y_pred = np.dot(wm, measurement_sigmas)\n    \n    # Calculate innovation covariance Pyy and cross-covariance Pxy\n    Pyy = np.zeros((measurement_sigmas.shape[1], measurement_sigmas.shape[1]))\n    Pxy = np.zeros((L, measurement_sigmas.shape[1]))\n    for i in range(2 * L + 1):\n        diff_y = measurement_sigmas[i] - y_pred\n        Pyy += wc[i] * np.outer(diff_y, diff_y)\n        \n        diff_x = propagated_sigmas[i] - mu_pred\n        Pxy += wc[i] * np.outer(diff_x, diff_y)\n    Pyy += R\n\n    # Kalman gain\n    K = Pxy @ np.linalg.inv(Pyy)\n    \n    # Update state mean and covariance\n    innovation = y_obs - y_pred\n    mu_updated = mu_pred + K @ innovation\n    P_updated = P_pred - K @ Pyy @ K.T\n    \n    # Extract results\n    result_list = [\n        mu_pred[0], mu_pred[1],\n        mu_updated[0], mu_updated[1],\n        np.trace(P_pred),\n        np.trace(P_updated)\n    ]\n    \n    return result_list\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3322180"}]}