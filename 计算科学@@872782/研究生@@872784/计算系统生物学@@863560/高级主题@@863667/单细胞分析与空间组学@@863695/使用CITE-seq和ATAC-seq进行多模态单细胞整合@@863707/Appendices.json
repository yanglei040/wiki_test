{"hands_on_practices": [{"introduction": "在进行多模态整合之前，确保每个模态数据的质量是至关重要的一步。本练习将指导您从头开始实现单细胞ATAC-seq数据质量控制中的两个核心指标：转录起始位点（$TSS$）富集分数和峰内读数比例（$FRiP$）。通过这个实践，您将深入理解这些指标的计算原理，并学会如何基于明确的阈值筛选出高质量的细胞，为后续的整合分析奠定坚实的基础。", "problem": "您的任务是形式化并计算两个标准的单细胞转座酶可及性染色质测序 (ATAC-seq) 质量控制指标，然后针对多个阈值体系决定质量控制是通过还是失败。这些指标是在与通过测序进行转录组和表位的细胞索引 (CITE-seq) 和 ATAC-seq 进行多模态整合之前使用的转录起始位点 (TSS) 富集度和 Reads 在峰值区域的比例 (FRiP)。该问题故意在一个具有离散整数坐标的玩具基因组上定义，以强调第一性原理。\n\n以下所有区间均为整数线上的闭区间。一个闭区间 $[a,b]$ 是集合 $\\{x \\in \\mathbb{Z} \\mid a \\le x \\le b\\}$。两个闭区间 $[a,b]$ 和 $[c,d]$ 重叠当且仅当 $\\max(a,c) \\le \\min(b,d)$。\n\n需要实现的定义：\n\n- 碱基覆盖度。给定一个细胞，其片段多重集为 $\\mathcal{F} = \\{[s_i,e_i]\\}$，以及一个位置 $p \\in \\mathbb{Z}$，定义单碱基覆盖度函数\n$$\n\\operatorname{cov}(p;\\mathcal{F}) = \\sum_{[s_i,e_i]\\in \\mathcal{F}} \\mathbf{1}\\{s_i \\le p \\le e_i\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是条件的指示函数。\n\n- 聚合 TSS 图谱和 TSS 富集度。设单条染色体上的 TSS 位置集合为 $G = \\{g_1,\\dots,g_{|G|}\\}$。固定一个对称窗口半径 $W \\in \\mathbb{N}$。对于每个偏移量 $o \\in \\{-W, -W+1, \\dots, -1, 0, 1, \\dots, W\\}$，定义聚合偏移覆盖度\n$$\nC(o) = \\sum_{g \\in G} \\operatorname{cov}(g+o;\\mathcal{F}).\n$$\n定义中心集 $S_{\\text{center}} = \\{-1,0,1\\}$ 和背景集 $S_{\\text{bg}} = \\{-W,\\dots,-2,2,\\dots,W\\}$。定义平均覆盖度\n$$\n\\overline{C}(S) = \\frac{1}{|S|} \\sum_{o\\in S} C(o).\n$$\n定义 TSS 富集度\n$$\nE = \\begin{cases}\n\\frac{\\overline{C}(S_{\\text{center}})}{\\overline{C}(S_{\\text{bg}})}  & \\text{若 } \\overline{C}(S_{\\text{bg}}) > 0, \\\\\n+\\infty  & \\text{若 } \\overline{C}(S_{\\text{bg}}) = 0 \\text{ 且 } \\overline{C}(S_{\\text{center}}) > 0, \\\\\n0  & \\text{若 } \\overline{C}(S_{\\text{bg}}) = 0 \\text{ 且 } \\overline{C}(S_{\\text{center}}) = 0.\n\\end{cases}\n$$\n\n- Reads 在峰值区域的比例 (FRiP)。设峰值区间集合为 $\\mathcal{P} = \\{[u_j,v_j]\\}$。设 $N_{\\text{frag}} = |\\mathcal{F}|$ 为细胞中的片段数量。设 $N_{\\text{in\\_peaks}}$ 为 $\\mathcal{F}$ 中与 $\\mathcal{P}$ 中至少一个峰值区间重叠的片段数量。定义\n$$\nF = \\begin{cases}\n\\frac{N_{\\text{in\\_peaks}}}{N_{\\text{frag}}}  & \\text{若 } N_{\\text{frag}} > 0, \\\\\n0  & \\text{若 } N_{\\text{frag}} = 0.\n\\end{cases}\n$$\n将 $F$ 表示为小数。\n\n- 质量控制通过规则。对于阈值 $\\tau_F \\in \\mathbb{R}_{\\ge 0}$，$\\tau_E \\in \\mathbb{R}_{\\ge 0}$ 和 $\\tau_n \\in \\mathbb{N}_0$，一个细胞通过当且仅当所有三个条件都成立：\n$$\nN_{\\text{frag}} \\ge \\tau_n,\\quad F \\ge \\tau_F,\\quad E \\ge \\tau_E.\n$$\n\n所有测试用例使用以下固定的玩具数据集：\n\n- TSS 集合 $G = \\{1000, 2000\\}$。\n\n- 窗口半径 $W = 5$。\n\n- 峰值集合 $\\mathcal{P} = \\{[990,1010], [1990,2005], [3000,3010]\\}$。\n\n- 三个细胞及其片段集合：\n\n    - 细胞 1：$\\mathcal{F}_1 = \\{[995,1005], [999,1002], [1998,2002], [2999,3001], [4000,4003]\\}$。\n\n    - 细胞 2：$\\mathcal{F}_2 = \\{[985,988], [1008,1012], [1993,1994], [2006,2008], [3005,3005]\\}$。\n\n    - 细胞 3：$\\mathcal{F}_3 = \\{\\}$ (无片段)。\n\n阈值三元组 $(\\tau_F,\\tau_E,\\tau_n)$ 的测试套件：\n\n- 测试 1：$(0.5, 2.0, 1)$。\n\n- 测试 2：$(0.8, \\frac{24}{11}, 5)$。\n\n- 测试 3：$(0.0, 0.0, 0)$。\n\n- 测试 4：$(0.9, 3.0, 6)$。\n\n您的程序必须对上述顺序中的每个测试用例，计算在给定阈值下通过质量控制的细胞数量。您的程序应生成一行输出，其中包含这四个整数，以逗号分隔的列表形式并用方括号括起来，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是测试 $i$ 中通过的细胞计数。", "solution": "该问题是有效的，因为它科学地基于单细胞基因组学质量控制的原理，在数学上是良定的，并提供了一套完整、自洽的定义和数据。使用玩具整数基因组是一种标准的教学简化方法，旨在专注于质量控制指标的第一性原理实现。\n\n任务是为三个不同的单细胞 ATAC-seq 图谱计算三个质量控制 (QC) 指标，然后针对四组不同的阈值，确定有多少细胞通过 QC。这些指标是唯一片段数 ($N_{\\text{frag}}$)、Reads 在峰值区域的比例 ($F$，或 FRiP) 和转录起始位点 (TSS) 富集度分数 ($E$)。\n\n总体步骤是首先为三个细胞中的每一个计算 QC 指标三元组 $(N_{\\text{frag}}, F, E)$。随后，对于四个测试用例中的每一个，我们将每个细胞的指标与给定的阈值 $(\\tau_n, \\tau_F, \\tau_E)$ 进行比较，以确定通过的细胞数量。\n\n所有计算的固定参数如下：\n- TSS 集合 $G = \\{1000, 2000\\}$。\n- 窗口半径 $W = 5$。\n- 峰值集合 $\\mathcal{P} = \\{[990,1010], [1990,2005], [3000,3010]\\}$。\n\n**步骤 1：为每个细胞计算 QC 指标**\n\n我们将为细胞 1、细胞 2 和细胞 3 计算 $(N_{\\text{frag}}, F, E)$。\n\n**细胞 1: $\\mathcal{F}_1 = \\{[995,1005], [999,1002], [1998,2002], [2999,3001], [4000,4003]\\}$**\n\n1.  **片段数 ($N_{\\text{frag},1}$):**\n    片段数是多重集 $\\mathcal{F}_1$ 的大小。\n    $$N_{\\text{frag},1} = |\\mathcal{F}_1| = 5$$\n\n2.  **Reads 在峰值区域的比例 ($F_1$):**\n    我们计算 $\\mathcal{F}_1$ 中与 $\\mathcal{P}$ 中至少一个峰值区间重叠的片段数。\n    - $[995,1005]$ 与 $[990,1010]$ 重叠。\n    - $[999,1002]$ 与 $[990,1010]$ 重叠。\n    - $[1998,2002]$ 与 $[1990,2005]$ 重叠。\n    - $[2999,3001]$ 与 $[3000,3010]$ 重叠。\n    - $[4000,4003]$ 不与 $\\mathcal{P}$ 中的任何峰值区间重叠。\n    在峰值区域内的片段数是 $N_{\\text{in\\_peaks},1} = 4$。\n    $$F_1 = \\frac{N_{\\text{in\\_peaks},1}}{N_{\\text{frag},1}} = \\frac{4}{5} = 0.8$$\n\n3.  **TSS 富集度 ($E_1$):**\n    我们需要为偏移量 $o \\in \\{-5, \\dots, 5\\}$ 计算聚合偏移覆盖度 $C(o) = \\sum_{g \\in G} \\operatorname{cov}(g+o;\\mathcal{F}_1)$。\n    TSS 位于位置 $g_1 = 1000$ 和 $g_2 = 2000$。\n    对于给定的偏移量 $o$，$C(o) = \\operatorname{cov}(1000+o;\\mathcal{F}_1) + \\operatorname{cov}(2000+o;\\mathcal{F}_1)$。\n\n    TSS 附近位置的覆盖度是：\n    - 对于 $o = -5$: $C(-5) = \\operatorname{cov}(995) + \\operatorname{cov}(1995) = 1 + 0 = 1$。\n    - 对于 $o = -4$: $C(-4) = \\operatorname{cov}(996) + \\operatorname{cov}(1996) = 1 + 0 = 1$。\n    - 对于 $o = -3$: $C(-3) = \\operatorname{cov}(997) + \\operatorname{cov}(1997) = 1 + 0 = 1$。\n    - 对于 $o = -2$: $C(-2) = \\operatorname{cov}(998) + \\operatorname{cov}(1998) = 1 + 1 = 2$。\n    - 对于 $o = -1$: $C(-1) = \\operatorname{cov}(999) + \\operatorname{cov}(1999) = 2 + 1 = 3$。\n    - 对于 $o = 0$: $C(0) = \\operatorname{cov}(1000) + \\operatorname{cov}(2000) = 2 + 1 = 3$。\n    - 对于 $o = 1$: $C(1) = \\operatorname{cov}(1001) + \\operatorname{cov}(2001) = 2 + 1 = 3$。\n    - 对于 $o = 2$: $C(2) = \\operatorname{cov}(1002) + \\operatorname{cov}(2002) = 2 + 1 = 3$。\n    - 对于 $o = 3$: $C(3) = \\operatorname{cov}(1003) + \\operatorname{cov}(2003) = 1 + 0 = 1$。\n    - 对于 $o = 4$: $C(4) = \\operatorname{cov}(1004) + \\operatorname{cov}(2004) = 1 + 0 = 1$。\n    - 对于 $o = 5$: $C(5) = \\operatorname{cov}(1005) + \\operatorname{cov}(2005) = 1 + 0 = 1$。\n\n    中心集 $S_{\\text{center}}=\\{-1,0,1\\}$ 上的平均覆盖度为：\n    $$\\overline{C}(S_{\\text{center}}) = \\frac{C(-1) + C(0) + C(1)}{3} = \\frac{3+3+3}{3} = 3$$\n    背景集 $S_{\\text{bg}}=\\{-5,-4,-3,-2,2,3,4,5\\}$ 上的平均覆盖度为：\n    $$\\overline{C}(S_{\\text{bg}}) = \\frac{C(-5)+C(-4)+C(-3)+C(-2)+C(2)+C(3)+C(4)+C(5)}{8} = \\frac{1+1+1+2+3+1+1+1}{8} = \\frac{11}{8}$$\n    由于 $\\overline{C}(S_{\\text{bg}}) > 0$，富集度为：\n    $$E_1 = \\frac{\\overline{C}(S_{\\text{center}})}{\\overline{C}(S_{\\text{bg}})} = \\frac{3}{11/8} = \\frac{24}{11}$$\n    細胞 1 的指标是 $(N_{\\text{frag},1}, F_1, E_1) = (5, 0.8, \\frac{24}{11})$。\n\n**細胞 2: $\\mathcal{F}_2 = \\{[985,988], [1008,1012], [1993,1994], [2006,2008], [3005,3005]\\}$**\n\n1.  **片段数 ($N_{\\text{frag},2}$):**\n    $$N_{\\text{frag},2} = |\\mathcal{F}_2| = 5$$\n\n2.  **Reads 在峰值区域的比例 ($F_2$):**\n    - $[985,988]$: 无重叠。\n    - $[1008,1012]$ 与 $[990,1010]$ 重叠。\n    - $[1993,1994]$ 与 $[1990,2005]$ 重叠。\n    - $[2006,2008]$: 无重叠。\n    - $[3005,3005]$ 与 $[3000,3010]$ 重叠。\n    在峰值区域内的片段数是 $N_{\\text{in\\_peaks},2} = 3$。\n    $$F_2 = \\frac{N_{\\text{in\\_peaks},2}}{N_{\\text{frag},2}} = \\frac{3}{5} = 0.6$$\n\n3.  **TSS 富集度 ($E_2$):**\n    对于细胞 2，$\\mathcal{F}_2$ 中的片段均未覆盖范围 $[995, 1005]$ 或 $[1995, 2005]$ 中的任何位置 $p$。这些位置是 $g+o$，其中 $g \\in G$ 且 $o \\in \\{-5, \\dots, 5\\}$。因此，对于所有相关的 $g$ 和 $o$，$\\operatorname{cov}(g+o;\\mathcal{F}_2) = 0$。\n    这导致对于所有 $o \\in \\{-5, \\dots, 5\\}$，$C(o) = 0$。\n    因此，$\\overline{C}(S_{\\text{center}}) = 0$ 且 $\\overline{C}(S_{\\text{bg}}) = 0$。\n    根据此情况的定义：\n    $$E_2 = 0$$\n    细胞 2 的指标是 $(N_{\\text{frag},2}, F_2, E_2) = (5, 0.6, 0)$。\n\n**细胞 3: $\\mathcal{F}_3 = \\{\\}$**\n\n1.  **片段数 ($N_{\\text{frag},3}$):**\n    $$N_{\\text{frag},3} = |\\mathcal{F}_3| = 0$$\n\n2.  **Reads 在峰值区域的比例 ($F_3$):**\n    根据定义，如果 $N_{\\text{frag}}=0$，则 $F=0$。\n    $$F_3 = 0$$\n\n3.  **TSS 富集度 ($E_3$):**\n    没有片段，所有位置的覆盖度都是 $0$。因此，与细胞 2 一样，$\\overline{C}(S_{\\text{center}}) = 0$ 且 $\\overline{C}(S_{\\text{bg}}) = 0$。\n    $$E_3 = 0$$\n    细胞 3 的指标是 $(N_{\\text{frag},3}, F_3, E_3) = (0, 0, 0)$。\n\n**步骤 2：评估测试用例**\n\n我们使用 QC 规则：一个细胞通过当且仅当 $N_{\\text{frag}} \\ge \\tau_n$，$F \\ge \\tau_F$ 和 $E \\ge \\tau_E$。\n\n**细胞指标摘要：**\n- 细胞 1: $(5, 0.8, \\frac{24}{11} \\approx 2.18)$\n- 细胞 2: $(5, 0.6, 0)$\n- 细胞 3: $(0, 0, 0)$\n\n**测试 1: $(\\tau_F, \\tau_E, \\tau_n) = (0.5, 2.0, 1)$**\n- 细胞 1: $5 \\ge 1$ (通过), $0.8 \\ge 0.5$ (通过), $24/11 \\ge 2.0$ (通过)。$\\implies$ **通过**\n- 细胞 2: $5 \\ge 1$ (通过), $0.6 \\ge 0.5$ (通过), $0 \\ge 2.0$ (失败)。$\\implies$ **失败**\n- 细胞 3: $0 \\ge 1$ (失败)。$\\implies$ **失败**\n通过的细胞数 = $1$。\n\n**测试 2: $(\\tau_F, \\tau_E, \\tau_n) = (0.8, \\frac{24}{11}, 5)$**\n- 细胞 1: $5 \\ge 5$ (通过), $0.8 \\ge 0.8$ (通过), $24/11 \\ge 24/11$ (通过)。$\\implies$ **通过**\n- 细胞 2: $5 \\ge 5$ (通过), $0.6 \\ge 0.8$ (失败)。$\\implies$ **失败**\n- 细胞 3: $0 \\ge 5$ (失败)。$\\implies$ **失败**\n通过的细胞数 = $1$。\n\n**测试 3: $(\\tau_F, \\tau_E, \\tau_n) = (0.0, 0.0, 0)$**\n- 细胞 1: $5 \\ge 0$ (通过), $0.8 \\ge 0.0$ (通过), $24/11 \\ge 0.0$ (通过)。$\\implies$ **通过**\n- 细胞 2: $5 \\ge 0$ (通过), $0.6 \\ge 0.0$ (通过), $0 \\ge 0.0$ (通过)。$\\implies$ **通过**\n- 细胞 3: $0 \\ge 0$ (通过), $0.0 \\ge 0.0$ (通过), $0.0 \\ge 0.0$ (通过)。$\\implies$ **通过**\n通过的细胞数 = $3$。\n\n**测试 4: $(\\tau_F, \\tau_E, \\tau_n) = (0.9, 3.0, 6)$**\n- 细胞 1: $5 \\ge 6$ (失败)。$\\implies$ **失败**\n- 细胞 2: $5 \\ge 6$ (失败)。$\\implies$ **失败**\n- 细胞 3: $0 \\ge 6$ (失败)。$\\implies$ **失败**\n通过的细胞数 = $0$。\n\n最终结果是四个测试中每个测试通过的细胞计数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes ATAC-seq QC metrics for a toy dataset and determines the number of passing cells\n    for several QC thresholds.\n    \"\"\"\n\n    # --- Fixed Dataset ---\n    G = [1000, 2000]  # TSS set\n    W = 5             # Window radius\n    P = [[990, 1010], [1990, 2005], [3000, 3010]]  # Peak set\n\n    cells_fragments = [\n        # Cell 1\n        [[995, 1005], [999, 1002], [1998, 2002], [2999, 3001], [4000, 4003]],\n        # Cell 2\n        [[985, 988], [1008, 1012], [1993, 1994], [2006, 2008], [3005, 3005]],\n        # Cell 3\n        []\n    ]\n\n    test_cases = [\n        (0.5, 2.0, 1),\n        (0.8, 24/11, 5),\n        (0.0, 0.0, 0),\n        (0.9, 3.0, 6),\n    ]\n    \n    def compute_metrics(fragments, tss_set, peak_set, window_radius):\n        \"\"\"\n        Computes N_frag, FRiP (F), and TSS Enrichment (E) for a single cell.\n        \"\"\"\n        N_frag = len(fragments)\n\n        # Handle the case of an empty cell\n        if N_frag == 0:\n            return (0, 0.0, 0.0)\n\n        # --- Compute Fraction of Reads in Peaks (FRiP) ---\n        N_in_peaks = 0\n        for s_frag, e_frag in fragments:\n            in_any_peak = False\n            for s_peak, e_peak in peak_set:\n                if max(s_frag, s_peak) <= min(e_frag, e_peak):\n                    in_any_peak = True\n                    break\n            if in_any_peak:\n                N_in_peaks += 1\n        F = N_in_peaks / N_frag\n\n        # --- Compute TSS Enrichment (E) ---\n        C = {o: 0 for o in range(-window_radius, window_radius + 1)}\n        \n        # Calculate aggregated offset coverage C(o)\n        for g in tss_set:\n            for s_frag, e_frag in fragments:\n                # The offsets o relative to g covered by the fragment are in [s_frag - g, e_frag - g]\n                o_start = s_frag - g\n                o_end = e_frag - g\n                \n                # Iterate through offsets in the intersection of the covered range and the window [-W, W]\n                # to increment the aggregated coverage counts.\n                start_offset = max(-window_radius, o_start)\n                end_offset = min(window_radius, o_end)\n                for o in range(start_offset, end_offset + 1):\n                    C[o] += 1\n        \n        # Calculate mean coverages for center and background\n        s_center_offsets = [-1, 0, 1]\n        s_bg_offsets = list(range(-window_radius, -1)) + list(range(2, window_radius + 1))\n        \n        C_center_values = [C[o] for o in s_center_offsets]\n        C_bg_values = [C[o] for o in s_bg_offsets]\n        \n        mean_C_center = np.mean(C_center_values) if C_center_values else 0.0\n        mean_C_bg = np.mean(C_bg_values) if C_bg_values else 0.0\n        \n        # Apply definition of TSS enrichment E\n        if mean_C_bg > 0:\n            E = mean_C_center / mean_C_bg\n        elif mean_C_center > 0:\n            E = np.inf\n        else:  # mean_C_bg == 0 and mean_C_center == 0\n            E = 0.0\n            \n        return (N_frag, F, E)\n\n    # Calculate metrics for all cells once\n    cell_metrics = []\n    for frags in cells_fragments:\n        metrics = compute_metrics(frags, G, P, W)\n        cell_metrics.append(metrics)\n\n    # Evaluate each test case\n    final_results = []\n    for tau_F, tau_E, tau_n in test_cases:\n        passed_count = 0\n        for n_frag, f, e in cell_metrics:\n            if n_frag >= tau_n and f >= tau_F and e >= tau_E:\n                passed_count += 1\n        final_results.append(passed_count)\n\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3330229"}, {"introduction": "整合scATAC-seq和scRNA-seq数据的核心挑战在于如何关联染色质开放性与基因表达。一个关键的解决方案是计算“基因活性分数”，将基于峰（peak）的ATAC信号转化为与基因对应的特征。本练习将引导您实现一个经典的基因活性分数计算方法，该方法通过聚合基因转录起始位点（$TSS$）附近的ATAC-seq信号，并根据与$TSS$的距离进行指数衰减加权，从而量化基因的潜在调控活性。", "problem": "考虑一个整合 Assay for Transposase-Accessible Chromatin using sequencing (ATAC-seq) 染色质可及性与 Cellular Indexing of Transcriptomes and Epitopes by Sequencing (CITE-seq) 信使核糖核酸 (mRNA) 表达的任务，以在单细胞水平上评估其一致性。给定一个小型的峰-细胞可及性矩阵、峰的基因组坐标、两个基因的转录起始位点 (TSS) 位置，以及一个以碱基对为单位的基因组窗口大小。假设以下基本原理：基因 TSS 附近的染色质可及性有助于其转录活动，并且调控影响随着与 TSS 的基因组距离增加而衰减，该衰减遵循指数核函数。您必须通过聚合 TSS 周围对称窗口内的峰的可及性信号来计算每个细胞的基因活性得分，使用指数核函数对这些信号进行加权，然后计算每个基因在所有细胞中的活性得分与 mRNA 表达之间的 Pearson 相关系数，以评估其一致性。\n\n数据和参数：\n1. 峰位于单个染色体上，并由以碱基对 (bp) 为单位的闭区间表示。峰的区间如下：\n$$\nP_1 = [1000,1100],\\quad\nP_2 = [1500,1600],\\quad\nP_3 = [2000,2100],\\quad\nP_4 = [2600,2700],\\quad\nP_5 = [3000,3100].\n$$\n定义峰中心 $c_p$ 为其区间的中点。\n\n2. 峰-细胞可及性矩阵 $X \\in \\mathbb{R}^{5 \\times 4}$ (行是峰 $P_1, \\dots, P_5$；列是细胞 $C_1,\\dots,C_4$) 如下：\n$$\nX = \\begin{bmatrix}\n2 & 0 & 1 & 0 \\\\\n3 & 1 & 0 & 0 \\\\\n0 & 2 & 2 & 0 \\\\\n0 & 1 & 0 & 3 \\\\\n1 & 0 & 3 & 2\n\\end{bmatrix}.\n$$\n\n3. 两个基因，其 TSS 位置（以 bp 为单位）位于同一染色体上，如下：\n$$\ng_A: t_A = 1550,\\quad g_B: t_B = 3050.\n$$\n\n4. 这两个基因在同样 $4$ 个细胞中的信使核糖核酸 (mRNA) 表达量如下：\n$$\ny_A = [5,2,3,0], \\quad y_B = [0,1,0,2].\n$$\n\n5. 指数衰减核参数（长度尺度）指定为：\n$$\n\\tau = 500\\ \\text{bp}.\n$$\n\n基因活性计算：\n- 对于一个 TSS 为 $t_g$ 的基因 $g$，和一个对称窗口大小 $w$（以碱基对为单位），选择其中心满足 $|c_p - t_g| \\le w$ 的峰。如果没有选中任何峰，则基因 $g$ 的活性得分向量为零向量。\n- 定义一个选定的峰 $p$ 在距离 $d_p = |c_p - t_g|$ 处的权重为：\n$$\nK(d_p) = \\exp\\left(-\\frac{d_p}{\\tau}\\right).\n$$\n- 基因 $g$ 在细胞 $i$ 中的基因活性得分为：\n$$\nA_{g,i}(w) = \\sum_{p:\\ |c_p - t_g| \\le w} X_{p,i}\\, K(|c_p - t_g|).\n$$\n\n一致性计算：\n- 令 $A_g(w) \\in \\mathbb{R}^4$ 为 $4$ 个细胞的活性得分，令 $y_g \\in \\mathbb{R}^4$ 为同样 $4$ 个细胞的 mRNA 表达量。Pearson 相关系数定义为：\n$$\nr_g(w) = \n\\begin{cases}\n0, & \\text{if}\\ \\sum_{i=1}^{4} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)^2 = 0\\ \\text{or}\\ \\sum_{i=1}^{4} \\left(y_{g,i} - \\bar{y}_g\\right)^2 = 0, \\\\\n\\displaystyle \\frac{\\sum_{i=1}^{4} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)\\left(y_{g,i} - \\bar{y}_g\\right)}{\\sqrt{\\sum_{i=1}^{4} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)^2}\\ \\sqrt{\\sum_{i=1}^{4} \\left(y_{g,i} - \\bar{y}_g\\right)^2}}, & \\text{otherwise},\n\\end{cases}\n$$\n其中 $\\bar{A}_g(w)$ 和 $\\bar{y}_g$ 分别表示 $A_g(w)$ 和 $y_g$ 的均值。\n\n测试套件：\n- 使用以下窗口大小（以碱基对为单位）：\n$$\nw_1 = 600,\\quad w_2 = 0,\\quad w_3 = 400.\n$$\n对于每个 $w_j$，计算 $r_{g_A}(w_j)$ 和 $r_{g_B}(w_j)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含测试套件的 $6$ 个相关性结果，顺序如下：\n$$\n\\left[r_{g_A}(w_1), r_{g_B}(w_1), r_{g_A}(w_2), r_{g_B}(w_2), r_{g_A}(w_3), r_{g_B}(w_3)\\right],\n$$\n以逗号分隔的列表形式打印，并用方括号括起来，数值为无单位（无量纲）的浮点数。", "solution": "我们从一个原理出发：在真核生物基因调控中，基因转录起始位点 (TSS) 附近的开放染色质区域（通过 Assay for Transposase-Accessible Chromatin using sequencing (ATAC-seq) 测量的可及性 DNA）有助于转录起始，并且它们的调控影响随着与 TSS 的基因组距离增加而减弱。为了对这种距离依赖性影响进行建模，我们采用一种广泛使用的指数核函数，它反映了远端调控元件贡献的衰减特性。对于单细胞一致性评估，我们将源自染色质的基因活性得分与通过 Cellular Indexing of Transcriptomes and Epitopes by Sequencing (CITE-seq) 测量的信使核糖核酸 (mRNA) 表达进行比较。\n\n定义与推导：\n1. 峰的表示与中心：每个染色质可及性峰 $p$ 是染色体上一个以碱基对 (bp) 为单位的区间 $[s_p, e_p]$。其中心为：\n$$\nc_p = \\frac{s_p + e_p}{2}.\n$$\n该中心为相对于基因 TSS 的距离计算提供了一个一致的标量表示。\n\n2. 基于窗口的选择：对于一个 TSS 位置为 $t_g$ 的基因 $g$ 和一个对称窗口大小 $w$（以 bp 为单位），我们包含其中心满足以下条件的峰：\n$$\n|c_p - t_g| \\le w.\n$$\n这个条件在 TSS 周围施加了一个具有物理意义的局部性约束。包含关系被定义为包含边界，以确保在 $|c_p - t_g| = w$ 处的行为是明确定义的。\n\n3. 指数衰减核函数：调控影响随距离 $d_p = |c_p - t_g|$ 衰减，遵循：\n$$\nK(d_p) = \\exp\\left(-\\frac{d_p}{\\tau}\\right),\n$$\n其中 $\\tau > 0$ 是一个长度尺度参数（以 bp 为单位）。该核函数与生物物理学的直觉一致，即可及区域的相互作用概率和功能效应随基因组距离近似呈指数下降。\n\n4. 基因活性聚合：给定峰-细胞矩阵 $X \\in \\mathbb{R}^{m \\times n}$（此处 $m = 5, n = 4$），对于窗口大小 $w$，基因 $g$ 在细胞 $i$ 中的基因活性得分为：\n$$\nA_{g,i}(w) = \\sum_{p:\\ |c_p - t_g| \\le w} X_{p,i}\\, \\exp\\left(-\\frac{|c_p - t_g|}{\\tau}\\right).\n$$\n如果选择集为空，我们定义 $A_g(w)$ 为 $\\mathbb{R}^n$ 中的零向量，反映了窗口内没有可及的调控证据。\n\n5. 通过 Pearson 相关性评估一致性：为了量化源自染色质的活性 $A_g(w)$ 与 mRNA 表达 $y_g$ 之间的线性一致性，Pearson 相关系数为：\n$$\nr_g(w) = \n\\begin{cases}\n0, & \\text{if}\\ \\sum_{i=1}^{n} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)^2 = 0\\ \\text{or}\\ \\sum_{i=1}^{n} \\left(y_{g,i} - \\bar{y}_g\\right)^2 = 0, \\\\\n\\displaystyle \\frac{\\sum_{i=1}^{n} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)\\left(y_{g,i} - \\bar{y}_g\\right)}{\\sqrt{\\sum_{i=1}^{n} \\left(A_{g,i}(w) - \\bar{A}_g(w)\\right)^2}\\ \\sqrt{\\sum_{i=1}^{n} \\left(y_{g,i} - \\bar{y}_g\\right)^2}}, & \\text{otherwise},\n\\end{cases}\n$$\n在此设置中 $n = 4$，且 $\\bar{A}_g(w)$ 和 $\\bar{y}_g$ 表示跨细胞的均值。零值情况的保护机制处理任一向量为常数的退化场景。\n\n与上述原理一致的算法步骤：\n- 使用 $c_p = (s_p + e_p)/2$ 从给定的区间 $[s_p,e_p]$ 计算峰中心 $c_p$。\n- 对于每个基因 $g \\in \\{g_A,g_B\\}$ 和每个窗口大小 $w \\in \\{w_1, w_2, w_3\\}$，为中心满足 $|c_p - t_g| \\le w$ 的峰构建选择掩码。\n- 对于选定的峰，计算权重 $K(d_p) = \\exp(-d_p/\\tau)$，其中 $d_p = |c_p - t_g|$ 且 $\\tau = 500$。\n- 使用选定峰的加权和来聚合每个细胞的活性：\n$$\nA_{g,i}(w) = \\sum_{p} \\left(\\mathbf{1}\\{|c_p - t_g| \\le w\\}\\, X_{p,i}\\, K(|c_p - t_g|)\\right).\n$$\n- 根据上面的 Pearson 相关公式计算 $r_g(w)$，包括当标准差为零时的零值情况处理。\n- 按以下顺序生成单个列表形式的最终结果：\n$$\n\\left[r_{g_A}(w_1), r_{g_B}(w_1), r_{g_A}(w_2), r_{g_B}(w_2), r_{g_A}(w_3), r_{g_B}(w_3)\\right].\n$$\n\n此过程将 ATAC-seq 可及性与 CITE-seq mRNA 表达的整合操作化，通过推导一个可解释的基因活性得分，该得分反映了受距离调控的局部染色质环境，然后通过标准相关性度量来量化一致性。该测试套件涵盖了一个一般情况 ($w_1$)、一个捕获精确匹配 TSS 的峰的边界情况 ($w_2$)，以及一个测试包含性窗口边界的边缘情况 ($w_3$)。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_peak_centers(starts, ends):\n    return (np.array(starts, dtype=float) + np.array(ends, dtype=float)) / 2.0\n\ndef exponential_kernel(distances, tau):\n    return np.exp(-np.abs(distances) / float(tau))\n\ndef compute_activity(X, centers, tss, window, tau):\n    distances = np.abs(centers - float(tss))\n    mask = distances <= float(window)\n    if not np.any(mask):\n        # No peaks in window: return zero activity vector\n        return np.zeros(X.shape[1], dtype=float)\n    weights = exponential_kernel(distances[mask], tau)  # shape (k,)\n    X_sel = X[mask, :]  # shape (k, n_cells)\n    # Weighted sum across peaks -> activity per cell\n    activity = (weights[:, None] * X_sel).sum(axis=0)\n    return activity\n\ndef pearson_correlation(x, y):\n    x = np.asarray(x, dtype=float)\n    y = np.asarray(y, dtype=float)\n    # Center\n    x_dev = x - x.mean()\n    y_dev = y - y.mean()\n    ssx = np.dot(x_dev, x_dev)\n    ssy = np.dot(y_dev, y_dev)\n    if ssx == 0.0 or ssy == 0.0:\n        return 0.0\n    num = np.dot(x_dev, y_dev)\n    den = np.sqrt(ssx * ssy)\n    return float(num / den)\n\ndef solve():\n    # Define data from the problem statement.\n    # Peak intervals (bp)\n    starts = [1000, 1500, 2000, 2600, 3000]\n    ends   = [1100, 1600, 2100, 2700, 3100]\n    centers = compute_peak_centers(starts, ends)  # shape (5,)\n\n    # Peak-by-cell ATAC accessibility matrix X (5 peaks x 4 cells)\n    X = np.array([\n        [2, 0, 1, 0],\n        [3, 1, 0, 0],\n        [0, 2, 2, 0],\n        [0, 1, 0, 3],\n        [1, 0, 3, 2]\n    ], dtype=float)\n\n    # Gene TSS positions (bp)\n    tss_A = 1550\n    tss_B = 3050\n\n    # CITE-seq mRNA expression across 4 cells\n    y_A = np.array([5, 2, 3, 0], dtype=float)\n    y_B = np.array([0, 1, 0, 2], dtype=float)\n\n    # Exponential kernel length scale (bp)\n    tau = 500\n\n    # Test suite: window sizes (bp)\n    test_windows = [600, 0, 400]\n\n    results = []\n    for w in test_windows:\n        # Gene A\n        A_A = compute_activity(X, centers, tss_A, w, tau)\n        r_A = pearson_correlation(A_A, y_A)\n        results.append(r_A)\n        # Gene B\n        A_B = compute_activity(X, centers, tss_B, w, tau)\n        r_B = pearson_correlation(A_B, y_B)\n        results.append(r_B)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3330201"}, {"introduction": "当我们为每个模态准备好数据后，下一步就是将它们真正地整合起来。加权最近邻（$WNN$）算法是当前最先进的多模态整合方法之一，它能为每个细胞学习不同模态的相对重要性，并构建一个统一的细胞邻近图。通过本练习，您将亲手实现$WNN$算法的核心逻辑——从计算跨模态预测误差，到确定模态权重，再到构建最终的加权相似性得分和邻居列表，从而深刻理解如何平衡并融合多种数据来源，以获得对细胞状态更全面的定义。", "problem": "给定三种合成的低维嵌入，它们对应于通过三种模态测量的一组共享单细胞：信使核糖核酸 (messenger Ribonucleic Acid, RNA)，来自CITE-seq（通过测序对转录组和表位进行细胞索引）的抗体衍生标签 (Antibody-Derived Tags, ADT)，以及来自ATAC-seq（利用测序技术进行转座酶可及性染色质分析）的染色质可及性。设模态集合为 $\\mathcal{M} = \\{\\mathrm{RNA}, \\mathrm{ADT}, \\mathrm{ATAC}\\}$，细胞数量为 $N$，在所有模态中共享。对于每个模态 $m \\in \\mathcal{M}$，给定一个嵌入矩阵 $X^{(m)} \\in \\mathbb{R}^{N \\times d_m}$，其中第 $i$ 行存储细胞 $i$ 的嵌入。\n\n从基本定义出发，您将为一个焦点细胞 $c$ 和一个邻域大小 $k$ 实现以下流程：\n- 在每个模态中，使用嵌入空间中的欧几里得距离计算特定于该模态的 $k$ 最近邻，不包括焦点细胞本身。\n- 对于每个模态，通过源模态中选择的 $k$ 最近邻的均值来预测焦点细胞在所有模态中的嵌入，从而计算焦点细胞的跨模态预测误差。\n- 通过逆误差归一化将预测误差转换为归一化权重，以获得总和为1的模態权重。\n- 使用模態权重组合特定于模態的相似性核函数，形成加权最近邻分数，该分数仅限于来自所有模態特定邻居集合的候选并集。返回最终的加权最近邻索引列表。\n\n使用以下核心定义作为基础：\n- 向量 $u, v \\in \\mathbb{R}^{d}$ 之间的欧几里得距离为 $d(u,v) = \\lVert u - v \\rVert_2 = \\sqrt{\\sum_{j=1}^{d} (u_j - v_j)^2}$。\n- 对于一个焦点细胞 $c$ 和模态 $m \\in \\mathcal{M}$，令 $d_{c,i}^{(m)} = \\lVert X_c^{(m)} - X_i^{(m)} \\rVert_2$ 表示细胞 $c$ 和另一个细胞 $i$ 在模态 $m$ 中的距离。\n- $k$-最近邻集合 $N_c^{(m)}$ 由 $k$ 个索引 $i \\neq c$ 组成，这些索引具有最小的 $d_{c,i}^{(m)}$。距离相等的情况必须通过优先选择较小的细胞索引来解决。集合 $N_c^{(m)}$ 按距离升序排列（平局时按索引升序排列）。\n- 对于每个源模态 $m \\in \\mathcal{M}$ 和每个目标模态 $t \\in \\mathcal{M}$，将焦点细胞在模态 $t$ 中的嵌入的邻居均值预测器定义为\n$$\n\\widehat{X}_{c}^{(t \\mid m)} \\;=\\; \\frac{1}{k} \\sum_{i \\in N_c^{(m)}} X_i^{(t)}.\n$$\n- 将特定于模态的预测误差定义为所有模态上欧几里得误差平方的总和：\n$$\nE_c^{(m)} \\;=\\; \\sum_{t \\in \\mathcal{M}} \\left\\lVert X_c^{(t)} \\;-\\; \\widehat{X}_{c}^{(t \\mid m)} \\right\\rVert_2^2.\n$$\n- 通过带有小数値稳定性常数 $\\varepsilon$ 的逆误差归一化将预测误差转换为正权重：\n$$\nw_c^{(m)} \\;=\\; \\frac{1}{E_c^{(m)} + \\varepsilon}, \\quad\n\\alpha_c^{(m)} \\;=\\; \\frac{w_c^{(m)}}{\\sum_{r \\in \\mathcal{M}} w_c^{(r)}}.\n$$\n- 对于每个模态 $m$，将焦点细胞 $c$ 与任何候选邻居 $i$ 之间的相似性核函数定义为\n$$\ns_{c,i}^{(m)} \\;=\\; \\exp\\!\\left( - \\frac{d_{c,i}^{(m)}}{\\sigma_c^{(m)}} \\right),\n$$\n其中 $\\sigma_c^{(m)}$ 是焦点细胞 $c$ 在模态 $m$ 中到第 $k$ 个最近邻的距离（即 $N_c^{(m)}$ 中 $k$ 个邻居中的最大距离）。如果 $\\sigma_c^{(m)} \\le \\varepsilon$，则使用 $\\sigma_c^{(m)} = \\varepsilon$ 以避免除以零。\n- 令候选集合为特定于模态的邻居的并集：\n$$\nU_c \\;=\\; N_c^{(\\mathrm{RNA})} \\;\\cup\\; N_c^{(\\mathrm{ADT})} \\;\\cup\\; N_c^{(\\mathrm{ATAC})}.\n$$\n- 将候选 $i \\in U_c$ 的聚合加权相似性分数定义为\n$$\nS_{c,i} \\;=\\; \\sum_{m \\in \\mathcal{M}} \\alpha_c^{(m)} \\, s_{c,i}^{(m)}.\n$$\n- 最终的加权最近邻列表是来自 $U_c$ 的前 $k$ 个索引的列表，按 $S_{c,i}$ 降序排序；$S_{c,i}$ 的平局通过优先选择较小的索引来解决。\n\n您必须使用 $\\varepsilon = 10^{-8}$。所有浮点输出必须四舍五入到六位小数并以十进制表示。\n\n数据集。在所有模态中共享 $N = 6$ 个细胞，其嵌入如下：\n- RNA 嵌入 $X^{(\\mathrm{RNA})} \\in \\mathbb{R}^{6 \\times 3}$:\n  - 细胞 $0$: $(0.0, 0.0, 0.0)$\n  - 细胞 $1$: $(0.1, 0.0, 0.0)$\n  - 细胞 $2$: $(5.0, 0.0, 0.0)$\n  - 细胞 $3$: $(5.1, 0.1, 0.0)$\n  - 细胞 $4$: $(10.0, 0.0, 0.0)$\n  - 细胞 $5$: $(10.1, 0.1, 0.0)$\n- ADT 嵌入 $X^{(\\mathrm{ADT})} \\in \\mathbb{R}^{6 \\times 2}$:\n  - 细胞 $0$: $(1.0, 1.0)$\n  - 细胞 $1$: $(1.1, 0.9)$\n  - 细胞 $2$: $(2.0, 2.0)$\n  - 细胞 $3$: $(2.1, 2.1)$\n  - 细胞 $4$: $(1.0, 1.0)$\n  - 细胞 $5$: $(5.0, 5.0)$\n- ATAC 嵌入 $X^{(\\mathrm{ATAC})} \\in \\mathbb{R}^{6 \\times 4}$:\n  - 细胞 $0$: $(0.0, 0.0, 1.0, 0.0)$\n  - 细胞 $1$: $(0.0, 0.0, 0.9, 0.1)$\n  - 细胞 $2$: $(0.0, 1.0, 0.0, 0.0)$\n  - 细胞 $3$: $(0.0, 1.1, 0.0, 0.0)$\n  - 细胞 $4$: $(1.0, 0.0, 0.0, 0.0)$\n  - 细胞 $5$: $(1.1, 0.0, 0.0, 0.0)$\n\n测试套件。对于以下集合中的每个参数对 $(c,k)$，计算：\n- 特定于模态的邻居列表 $N_c^{(\\mathrm{RNA})}$, $N_c^{(\\mathrm{ADT})}$, $N_c^{(\\mathrm{ATAC})}$；\n- 预测误差 $E_c^{(\\mathrm{RNA})}$, $E_c^{(\\mathrm{ADT})}$, $E_c^{(\\mathrm{ATAC})}$；\n- 归一化权重 $\\alpha_c^{(\\mathrm{RNA})}$, $\\alpha_c^{(\\mathrm{ADT})}$, $\\alpha_c^{(\\mathrm{ATAC})}$；以及\n- 最终的加权最近邻列表（来自 $U_c$ 的前 $k$ 个索引，按 $S_{c,i}$ 降序排序，平局时按索引升序排列）。\n\n使用以下测试用例：\n- $(c,k) = (2,2)$\n- $(c,k) = (2,3)$\n- $(c,k) = (3,3)$\n\n计算规则和约束：\n- 所有距离必须使用定义的欧几里得距离。\n- 从所有邻居列表中排除焦点细胞 $c$。\n- 在 $k$-最近邻选择中，距离的平局必须通过增加细胞索引来解决。\n- 对于聚合加权相似性评分， $S_{c,i}$ 的平局必须通过增加细胞索引来解决。\n- 在指定处使用 $\\varepsilon = 10^{-8}$。\n- 所有浮点输出必须四舍五入到六位小数，并以小数表示（非百分比）。\n\n最终输出格式：\n- 对于每个测试用例 $(c,k)$，生成一个以下形式的列表\n$$\n[\\;N_c^{(\\mathrm{RNA})},\\; N_c^{(\\mathrm{ADT})},\\; N_c^{(\\mathrm{ATAC})},\\; [E_c^{(\\mathrm{RNA})}, E_c^{(\\mathrm{ADT})}, E_c^{(\\mathrm{ATAC})}],\\; [\\alpha_c^{(\\mathrm{RNA})}, \\alpha_c^{(\\mathrm{ADT})}, \\alpha_c^{(\\mathrm{ATAC})}],\\; \\mathrm{WNN}_c\\;],\n$$\n其中每个 $N_c^{(\\cdot)}$ 和 $\\mathrm{WNN}_c$ 是细胞索引的列表，误差和权重向量是四舍五入后的小数列表。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3}]$）。", "solution": "该问题提出了一个详细且自成一体的流程，用于使用加权最近邻 (Weighted Nearest Neighbor, WNN) 方法进行多模态单细胞数据整合。提供的输入包括一组 $N=6$ 个细胞的三种合成低维嵌入，分别对应RNA、ADT（蛋白质）和ATAC（染色质可及性）模态。任务是为指定的焦点细胞和邻域大小计算特定于模态的邻居、跨模态预测误差、归一化的模态权重以及最终的整合最近邻列表。\n\n该问题的陈述经验证如下：\n- **科学基础**：该方法论是WNN算法的一个简化但概念正确的表示，WNN算法是计算系统生物学中一种广泛接受的用于整合多模态单细胞数据集的技术。欧几里得距离、k-最近邻、跨模态预测和加权核函数求和的使用都是标准组成部分。\n- **适定性**：该问题在计算上是适定的。所有步骤都用数学精确定义。关键是，为k-最近邻选择（优先选择较小的细胞索引）和最终加权相似性得分排序（优先选择较小的细胞索引）都提供了明确的平局打破规则，确保了唯一解的存在。引入数值稳定性常数 $\\varepsilon$ 可防止除以零。\n- **客观性和完整性**：问题以客观、正式的语言陈述。所有必要的数据，包括嵌入矩阵 $X^{(m)}$、参数（$c, k, \\varepsilon$）和一套完整的程序定义，都已提供。问题是自成一体且无歧义的。\n\n该问题被认为是有效的，因为它科学合理、数学严谨且规范完整。解决方案将为三个测试用例中的每一个逐步实现定义的流程。\n\n让我们将模态集合表示为 $\\mathcal{M} = \\{\\mathrm{RNA}, \\mathrm{ADT}, \\mathrm{ATAC}\\}$。我们 được 给定了嵌入矩阵 $X^{(\\mathrm{RNA})}$、$X^{(\\mathrm{ADT})}$ 和 $X^{(\\mathrm{ATAC})}$。对于每个测试用例 $(c, k)$，执行以下步骤：\n\n**1. 特定于模态的 $k$-最近邻 ($N_c^{(m)}$)**\n对于每个模态 $m \\in \\mathcal{M}$，我们计算从焦点细胞 $c$ 到每个其他细胞 $i \\neq c$ 的欧几里得距离 $d_{c,i}^{(m)} = \\lVert X_c^{(m)} - X_i^{(m)} \\rVert_2$。然后按此距离升序对细胞进行排序。平局通过优先选择索引较小的细胞来解决。集合 $N_c^{(m)}$ 包含此排序列表中前 $k$ 个细胞的索引。我们还记录 $\\sigma_c^{(m)}$，即此列表中第 $k$ 个邻居的距离，它将用作带宽参数。\n\n**2. 跨模态预测误差 ($E_c^{(m)}$)**\n对于每个源模態 $m$，我们使用其最近邻集合 $N_c^{(m)}$ 来预测焦点细胞在每个目标模態 $t \\in \\mathcal{M}$ 中的嵌入。预测值 $\\widehat{X}_{c}^{(t \\mid m)}$ 是 $N_c^{(m)}$ 中细胞在目标模态 $t$ 中嵌入的算术平均值：\n$$\n\\widehat{X}_{c}^{(t \\mid m)} \\;=\\; \\frac{1}{k} \\sum_{i \\in N_c^{(m)}} X_i^{(t)}\n$$\n源模态 $m$ 的总预测误差，记为 $E_c^{(m)}$，是真实嵌入 $X_c^{(t)}$ 与预测嵌入 $\\widehat{X}_{c}^{(t \\mid m)}$ 之间在所有目标模态上的平方欧几里得误差之和：\n$$\nE_c^{(m)} \\;=\\; \\sum_{t \\in \\mathcal{M}} \\left\\lVert X_c^{(t)} \\;-\\; \\widehat{X}_{c}^{(t \\mid m)} \\right\\rVert_2^2\n$$\n\n**3. 模态权重计算 ($\\alpha_c^{(m)}$)**\n预测误差 $\\{E_c^{(m)}\\}_{m \\in \\mathcal{M}}$ 被转换为与误差成反比的权重。给定源模态的误差越小，意味着其局部邻域结构对于预测所有测量类型中细胞的状态信息越丰富。首先使用一个小常数 $\\varepsilon = 10^{-8}$ 来计算中间权重 $w_c^{(m)}$ 以确保数值稳定性：\n$$\nw_c^{(m)} \\;=\\; \\frac{1}{E_c^{(m)} + \\varepsilon}\n$$\n然后将这些权重归一化，使其总和为1，从而得到最终的模态权重 $\\alpha_c^{(m)}$：\n$$\n\\alpha_c^{(m)} \\;=\\; \\frac{w_c^{(m)}}{\\sum_{r \\in \\mathcal{M}} w_c^{(r)}}\n$$\n\n**4. 加权最近邻 (WNN) 整合**\n首先，通过取所有特定于模态的邻居集合的并集来形成候选邻居集合 $U_c$：$U_c = \\bigcup_{m \\in \\mathcal{M}} N_c^{(m)}$。\n\n对于每个模态 $m$，使用高斯核函数计算焦点细胞 $c$ 与每个候选邻居 $i \\in U_c$ 之间的相似性核 $s_{c,i}^{(m)}$。距离由 $\\sigma_c^{(m)}$（该模态中到第 $k$ 个最近邻的距离）进行缩放，该值充当局部带宽：\n$$\ns_{c,i}^{(m)} \\;=\\; \\exp\\!\\left( - \\frac{d_{c,i}^{(m)}}{\\sigma_c^{(m)}} \\right)\n$$\n如果 $\\sigma_c^{(m)}$ 小于 $\\varepsilon$，则将其设置为 $\\varepsilon$。\n\n每个候选邻居 $i$ 的最终整合相似性分数 $S_{c,i}$ 是这些特定于模态的相似性核的加权和，使用权重 $\\alpha_c^{(m)}$：\n$$\nS_{c,i} \\;=\\; \\sum_{m \\in \\mathcal{M}} \\alpha_c^{(m)} \\, s_{c,i}^{(m)}\n$$\n$U_c$ 中的候选者根据其分数 $S_{c,i}$ 按降序排序。平局通过选择索引较小的细胞来解决。最终的WNN列表由该排序列表中的前 $k$ 个索引组成。\n\n针对每个给定的测试用例实施这些步骤，所有浮点结果按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the WNN pipeline for multimodal single-cell data integration based on the problem description.\n    \"\"\"\n    # Define the datasets as per the problem statement\n    X_rna = np.array([\n        [0.0, 0.0, 0.0],\n        [0.1, 0.0, 0.0],\n        [5.0, 0.0, 0.0],\n        [5.1, 0.1, 0.0],\n        [10.0, 0.0, 0.0],\n        [10.1, 0.1, 0.0],\n    ])\n\n    X_adt = np.array([\n        [1.0, 1.0],\n        [1.1, 0.9],\n        [2.0, 2.0],\n        [2.1, 2.1],\n        [1.0, 1.0],\n        [5.0, 5.0],\n    ])\n\n    X_atac = np.array([\n        [0.0, 0.0, 1.0, 0.0],\n        [0.0, 0.0, 0.9, 0.1],\n        [0.0, 1.0, 0.0, 0.0],\n        [0.0, 1.1, 0.0, 0.0],\n        [1.0, 0.0, 0.0, 0.0],\n        [1.1, 0.0, 0.0, 0.0],\n    ])\n\n    modalities = {\n        'RNA': X_rna,\n        'ADT': X_adt,\n        'ATAC': X_atac,\n    }\n    \n    num_cells = X_rna.shape[0]\n    modality_keys = ['RNA', 'ADT', 'ATAC']\n    epsilon = 1e-8\n\n    test_cases = [\n        (2, 2),\n        (2, 3),\n        (3, 3),\n    ]\n\n    all_results = []\n\n    for c, k in test_cases:\n        focal_cell_idx = c\n        \n        # Step 1: Compute modality-specific k-nearest neighbors\n        nn_sets = {}\n        sigmas = {}\n        all_distances = {}\n\n        for m_key in modality_keys:\n            X_m = modalities[m_key]\n            focal_vec = X_m[focal_cell_idx]\n            \n            distances = []\n            for i in range(num_cells):\n                if i == focal_cell_idx:\n                    continue\n                dist = np.linalg.norm(focal_vec - X_m[i])\n                distances.append((dist, i))\n            \n            # Sort by distance, then by index for tie-breaking\n            distances.sort()\n            \n            nn_sets[m_key] = [i for dist, i in distances[:k]]\n            sigmas[m_key] = distances[k-1][0] if k > 0 else epsilon\n            \n            # Store all distances for later use\n            all_distances[m_key] = {i: dist for dist, i in distances}\n\n        # Step 2: Compute cross-modal prediction errors\n        errors = {}\n        for m_source_key in modality_keys:\n            total_error = 0.0\n            neighbor_indices = nn_sets[m_source_key]\n\n            for m_target_key in modality_keys:\n                X_target = modalities[m_target_key]\n                \n                # Calculate the mean embedding of neighbors\n                if k > 0:\n                    neighbor_embeddings = X_target[neighbor_indices]\n                    predicted_embedding = np.mean(neighbor_embeddings, axis=0)\n                else: \n                    predicted_embedding = np.zeros(X_target.shape[1])\n                \n                # Get the true embedding of the focal cell\n                true_embedding = X_target[focal_cell_idx]\n                \n                # Calculate squared Euclidean error\n                squared_error = np.sum((true_embedding - predicted_embedding)**2)\n                total_error += squared_error\n            \n            errors[m_source_key] = total_error\n\n        # Step 3: Convert prediction errors to normalized weights\n        raw_weights = {m_key: 1.0 / (errors[m_key] + epsilon) for m_key in modality_keys}\n        sum_raw_weights = sum(raw_weights.values())\n        \n        if sum_raw_weights > 0:\n            norm_weights = {m_key: w / sum_raw_weights for m_key, w in raw_weights.items()}\n        else: # Handle case of all zero weights (unlikely)\n            norm_weights = {m_key: 1.0/len(modality_keys) for m_key in modality_keys}\n\n        # Step 4: Form a weighted nearest neighbor score\n        candidate_set = set()\n        for m_key in modality_keys:\n            candidate_set.update(nn_sets[m_key])\n        \n        candidate_list = sorted(list(candidate_set))\n\n        weighted_scores = []\n        if k > 0:\n            for i in candidate_list:\n                total_score = 0.0\n                for m_key in modality_keys:\n                    # Retrieve the distance to candidate i\n                    dist_ci_m = np.linalg.norm(modalities[m_key][c] - modalities[m_key][i])\n                    \n                    sigma_m = max(sigmas[m_key], epsilon)\n                    \n                    # Similarity kernel\n                    s_cim = np.exp(-dist_ci_m / sigma_m)\n                    \n                    total_score += norm_weights[m_key] * s_cim\n                \n                # Store with negative score for descending sort\n                weighted_scores.append((-total_score, i))\n        \n        # Sort by score (desc), then index (asc)\n        weighted_scores.sort()\n        \n        wnn_list = [i for score, i in weighted_scores[:k]]\n\n        # Format results for output\n        result_Nc = [nn_sets[key] for key in modality_keys]\n        result_E = [round(errors[key], 6) for key in modality_keys]\n        result_alpha = [round(norm_weights[key], 6) for key in modality_keys]\n\n        # Use repr to get the exact list format like [1, 2]\n        formatted_result = (\n            f\"[{repr(result_Nc[0])}, {repr(result_Nc[1])}, {repr(result_Nc[2])}, \"\n            f\"[{result_E[0]:.6f}, {result_E[1]:.6f}, {result_E[2]:.6f}], \"\n            f\"[{result_alpha[0]:.6f}, {result_alpha[1]:.6f}, {result_alpha[2]:.6f}], \"\n            f\"{repr(wnn_list)}]\"\n        )\n        all_results.append(formatted_result)\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3330226"}]}