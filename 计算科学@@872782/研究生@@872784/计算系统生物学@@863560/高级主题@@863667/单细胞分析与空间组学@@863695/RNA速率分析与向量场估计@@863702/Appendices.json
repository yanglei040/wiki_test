{"hands_on_practices": [{"introduction": "将RNA速度的理论概念转化为可执行的计算流程是理解其应用的第一步。这个实践旨在通过从头开始构建一个完整的RNA速度分析流程，来巩固您对核心概念的理解。您将亲手实现从原始计数矩阵到最终矢量场的每一个关键步骤，包括数据标准化、统计建模和低维投影，从而将抽象的理论与具体的数据处理实践联系起来 [@problem_id:3346376]。", "problem": "给定一个包含单细胞剪接和未剪接的信使核糖核酸（mRNA）计数矩阵的小型数据集，要求您实现一个完整、可复现的预处理和归一化流程，该流程适用于下游的核糖核酸（RNA）速度分析和向量场估计。该流程必须从基本原理构建，并且必须包括以下步骤：（i）使用目标文库大小进行细胞级文库大小归一化，（ii）添加伪计数以稳定比率和对数，（iii）对数变换，（iv）基因级标准化，（v）对每个基因的未剪接计数和剪接计数进行线性回归，以获得基于残差的速度估计，（vi）将基因级速度投影到源自对剪接数据进行主成分分析（PCA）得到的二维嵌入空间中，以及（vii）将投影后的速度通过基于核的平滑方法处理成一个在指定查询点上评估的连续向量场。\n\n基本原理和定义：\n- 分子生物学的中心法则指出，脱氧核糖核酸（DNA）转录成RNA，RNA经过剪接和加工产生为成熟（已剪接）的转录本；观测到的每个基因的单细胞剪接和未剪接RNA计数源于此过程，并受到技术性抽样变异的影响。\n- 我们假设每个细胞 $i$ 对于每个基因 $g$ 都有观测到的非负整数剪接计数 $S_{i g}$ 和未剪接计数 $U_{i g}$。细胞级文库大小定义为 $L_i = \\sum_{g} \\left(S_{i g} + U_{i g}\\right)$。\n- 文库大小归一化的目的是重新缩放每个细胞，使所有细胞的总分子含量处于可比较的尺度上，这在对整个群体的转录动力学进行模型拟合之前至关重要。对数变换可以稳定方差，而基因级标准化确保了在线性建模中剪接和未剪接信号的可比性。\n- 基于残差的 RNA 速度分析对每个基因使用一个线性模型来关联未剪接和剪接信号，并将速度估计为与拟合的稳态关系的偏差。\n\n需要实现的计算步骤：\n1. 细胞级文库大小归一化与伪计数添加：\n   - 对于每个细胞 $i$，计算 $L_i = \\sum_{g} \\left(S_{i g} + U_{i g}\\right)$。\n   - 给定目标文库大小 $L_0$ 和一个用于避免除以零的小正数下限 $\\varepsilon_L$，定义大小因子 $s_i = \\max(L_i,\\varepsilon_L)/L_0$。\n   - 给定一个伪计数 $p > 0$，定义经过伪计数调整和归一化后的计数\n     $$\n     \\tilde{S}_{i g} = \\frac{S_{i g} + p}{s_i}, \\quad \\tilde{U}_{i g} = \\frac{U_{i g} + p}{s_i}.\n     $$\n2. 对数变换：\n   - 定义对数变换后的量\n     $$\n     \\hat{S}_{i g} = \\log\\!\\left(1 + \\tilde{S}_{i g}\\right), \\quad \\hat{U}_{i g} = \\log\\!\\left(1 + \\tilde{U}_{i g}\\right).\n     $$\n3. 跨细胞的基因级标准化：\n   - 对于每个基因 $g$，计算所有细胞的均值 $m^S_g = \\frac{1}{n}\\sum_i \\hat{S}_{i g}$ 和 $m^U_g = \\frac{1}{n}\\sum_i \\hat{U}_{i g}$，以及总体标准差\n     $$\n     \\sigma^S_g = \\sqrt{\\frac{1}{n}\\sum_i \\left(\\hat{S}_{i g} - m^S_g\\right)^2}, \\quad \\sigma^U_g = \\sqrt{\\frac{1}{n}\\sum_i \\left(\\hat{U}_{i g} - m^U_g\\right)^2}.\n     $$\n   - 使用一个小的数值稳定因子 $\\delta > 0$，定义标准化后的量\n     $$\n     \\bar{S}_{i g} = \\frac{\\hat{S}_{i g} - m^S_g}{\\max(\\sigma^S_g,\\delta)}, \\quad \\bar{U}_{i g} = \\frac{\\hat{U}_{i g} - m^U_g}{\\max(\\sigma^U_g,\\delta)}.\n     $$\n4. 逐基因线性回归和基于残差的速度：\n   - 对每个基因 $g$，拟合一个将 $\\bar{U}_{i g}$ 与 $\\bar{S}_{i g}$ 关联起来的单变量带截距线性模型：\n     $$\n     \\bar{U}_{i g} = \\alpha_g \\bar{S}_{i g} + \\beta_g + \\varepsilon_{i g}.\n     $$\n   - 令 $x_i = \\bar{S}_{i g}$，$y_i = \\bar{U}_{i g}$，$\\mu_x = \\frac{1}{n}\\sum_i x_i$，$\\mu_y = \\frac{1}{n}\\sum_i y_i$，$\\mathrm{var}(x)=\\frac{1}{n}\\sum_i (x_i-\\mu_x)^2$，$\\mathrm{cov}(x,y)=\\frac{1}{n}\\sum_i (x_i-\\mu_x)(y_i-\\mu_y)$。如果 $\\mathrm{var}(x) \\ge \\delta$，则设置 $\\alpha_g = \\mathrm{cov}(x,y)/\\mathrm{var}(x)$ 和 $\\beta_g = \\mu_y - \\alpha_g \\mu_x$；否则设置 $\\alpha_g = 0$ 和 $\\beta_g = \\mu_y$。将每个细胞和基因的基于残差的速度定义为\n     $$\n     v_{i g} = y_i - \\left(\\alpha_g x_i + \\beta_g\\right).\n     $$\n5. 通过主成分分析进行二维嵌入：\n   - 令 $Z$ 为矩阵，其元素为 $Z_{i g} = \\bar{S}_{i g}$。计算奇异值分解 $Z = U \\Sigma V^\\top$。取 $V$ 的前 2 列以获得基因载荷矩阵 $W \\in \\mathbb{R}^{G \\times 2}$。\n   - 将细胞的二维嵌入定义为\n     $$\n     X_i = \\sum_{g} Z_{i g} W_{g, :} \\in \\mathbb{R}^2,\n     $$\n     以及投影后的速度向量定义为\n     $$\n     \\mathbf{v}^{\\mathrm{emb}}_i = \\sum_{g} v_{i g} W_{g, :} \\in \\mathbb{R}^2.\n     $$\n6. 在查询点处对向量场进行核平滑：\n   - 给定一个查询点 $\\mathbf{q} \\in \\mathbb{R}^2$、一个带宽 $h > 0$ 以及权重为\n     $$\n     w_i = \\exp\\!\\left(-\\frac{\\lVert X_i - \\mathbf{q}\\rVert^2}{2 h^2}\\right)\n     $$\n     的高斯核，将在 $\\mathbf{q}$ 处的平滑向量场定义为\n     $$\n     \\hat{\\mathbf{V}}(\\mathbf{q}) = \\frac{\\sum_i w_i \\, \\mathbf{v}^{\\mathrm{emb}}_i}{\\sum_i w_i}.\n     $$\n\n需要处理的边缘情况：\n- 如果某个细胞的 $L_i = 0$，则使用下限 $\\varepsilon_L$。\n- 如果 $\\sigma^S_g$ 或 $\\sigma^U_g$ 为零，在标准化时于分母中使用稳定因子 $\\delta$。\n- 如果回归中 $\\mathrm{var}(x)  \\delta$，则设置 $\\alpha_g = 0$ 和 $\\beta_g = \\mu_y$ 以避免除以接近零的数。\n\n测试套件：\n对于每个测试用例，给定剪接计数 $S$、未剪接计数 $U$ 以及参数 $(L_0, p, \\varepsilon_L, \\delta, h, \\mathbf{q})$。实现上述所有步骤 $1$–$6$，并返回平滑后的向量场 $\\hat{\\mathbf{V}}(\\mathbf{q})$，结果为包含两个浮点数的列表，四舍五入到六位小数。\n\n- 测试用例 1（正常路径，计数适中）：\n  - $S^{(1)} = \\begin{bmatrix} 10  5  0 \\\\ 3  8  1 \\\\ 0  2  9 \\\\ 6  4  3 \\end{bmatrix}$，$U^{(1)} = \\begin{bmatrix} 4  2  0 \\\\ 1  3  0 \\\\ 0  1  5 \\\\ 2  1  1 \\end{bmatrix}$。\n  - 参数：$L_0 = 1000.0$, $p = 1.0$, $\\varepsilon_L = 1.0$, $\\delta = 10^{-8}$, $h = 1.0$, $\\mathbf{q} = (0.0, 0.0)$。\n- 测试用例 2（边界条件，包含零计数细胞和稀疏基因）：\n  - $S^{(2)} = \\begin{bmatrix} 0  0  0 \\\\ 2  0  0 \\\\ 0  1  0 \\\\ 0  0  3 \\end{bmatrix}$，$U^{(2)} = \\begin{bmatrix} 0  0  0 \\\\ 0  1  0 \\\\ 0  0  2 \\\\ 1  0  0 \\end{bmatrix}$。\n  - 参数：$L_0 = 1000.0$, $p = 0.5$, $\\varepsilon_L = 1.0$, $\\delta = 10^{-8}$, $h = 0.5$, $\\mathbf{q} = (0.0, 0.0)$。\n- 测试用例 3（边缘情况，文库大小极不均匀且包含零方差基因）：\n  - $S^{(3)} = \\begin{bmatrix} 1000  50  7 \\\\ 50  50  7 \\\\ 3000  50  7 \\\\ 10  50  7 \\end{bmatrix}$，$U^{(3)} = \\begin{bmatrix} 200  10  3 \\\\ 10  10  3 \\\\ 600  10  3 \\\\ 2  10  3 \\end{bmatrix}$。\n  - 参数：$L_0 = 10000.0$, $p = 1.0$, $\\varepsilon_L = 1.0$, $\\delta = 10^{-8}$, $h = 2.0$, $\\mathbf{q} = (0.0, 0.0)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个包含两个元素的列表，即四舍五入到六位小数的 $\\hat{\\mathbf{V}}(\\mathbf{q})$。例如：$[\\,[v^{(1)}_x, v^{(1)}_y], [v^{(2)}_x, v^{(2)}_y], [v^{(3)}_x, v^{(3)}_y]\\,]$。", "solution": "该问题提出了一个来自计算系统生物学领域的、定义明确且有科学依据的任务：实现一个简化的 RNA 速度分析流程。该问题是有效的，因为它提供了一套完整、自洽且逻辑一致的指令、定义和测试数据。它没有科学不准确、模糊或矛盾之处。所描述的步骤是单细胞数据分析中的标准（尽管是简化的）程序，包括归一化、变换、统计建模、降维和向量场估计。所有必需的数学公式、参数和边缘情况处理规则都已明确说明，使得该问题是适定的（well-posed），并且能够计算出唯一、可验证的解。\n\n解决方案通过系统地实现指定的六个计算步骤来展开。该实现旨在将所提供的数学形式直接转化为可执行代码。\n\n1.  **细胞级文库大小归一化**：对于每个细胞，计算其总 RNA 计数（剪接加未剪接）以确定其文库大小 $L_i$。然后，通过将此文库大小相对于目标文库大小 $L_0$ 进行缩放来计算大小因子 $s_i$，同时强制使用一个最小下限 $\\varepsilon_L$ 以防止对零计数细胞进行除零操作。每个细胞 $i$ 中每个基因 $g$ 的原始剪接（$S_{ig}$）和未剪接（$U_{ig}$）计数首先通过一个伪计数 $p$ 进行增强，然后除以该细胞的大小因子 $s_i$。这将产生归一化后的计数 $\\tilde{S}_{ig}$ 和 $\\tilde{U}_{ig}$，这些计数已经针对测序深度和细胞大小的差异进行了调整。\n\n2.  **对数变换**：归一化的计数 $\\tilde{S}_{ig}$ 和 $\\tilde{U}_{ig}$ 使用函数 $\\log(1+x)$ 进行对数变换。这种常用技术（为保证数值稳定性，实现为 `np.log1p`）用于稳定表达值范围内的方差，并使数据分布更对称，这对于下游的线性建模是有益的。得到的量表示为 $\\hat{S}_{ig}$ 和 $\\hat{U}_{ig}$。\n\n3.  **基因级标准化**：为了使不同基因之间的表达值具有可比性（这些基因可能具有截然不同的动态范围），每个基因的对数变换后的计数都被标准化。对于每个基因 $g$，计算其在所有细胞中的均值（$m^S_g, m^U_g$）和总体标准差（$\\sigma^S_g, \\sigma^U_g$）。通过减去均值并除以标准差来获得标准化值 $\\bar{S}_{ig}$ 和 $\\bar{U}_{ig}$。在分母中使用一个小的稳定因子 $\\delta$ 以防止对在细胞群体中表达没有变化的基因进行除零操作。\n\n4.  **线性回归和基于残差的速度**：此模型中 RNA 速度估计的核心在于关联未剪接和剪接的 mRNA 丰度。对于每个基因 $g$，拟合一个简单的线性回归模型 $\\bar{U}_{ig} = \\alpha_g \\bar{S}_{ig} + \\beta_g$，以从标准化的剪接丰度预测标准化的未剪接丰度。斜率 $\\alpha_g$ 和截距 $\\beta_g$ 使用普通最小二乘法公式计算。对于剪接计数方差接近于零的基因，处理了一个边缘情况，即将其斜率设置为零。每个细胞 $i$ 和基因 $g$ 的 RNA 速度 $v_{ig}$ 定义为此回归的残差——观测到的标准化未剪接丰度 $\\bar{U}_{ig}$ 与其模型预测值之间的差。此残差代表了与预期的剪接和降解稳态关系的偏离，指示了基因的表达是增加还是减少。\n\n5.  **PCA 嵌入和速度投影**：为了可视化发育轨迹，细胞通常被嵌入到一个低维空间中。在这里，对标准化的剪接数据矩阵 $Z_{ig} = \\bar{S}_{ig}$ 执行主成分分析（PCA）。从 $Z$ 的奇异值分解（SVD）中提取对应于前两个主成分的基因载荷矩阵，表示为 $W$。通过将标准化的剪接数据投影到这些载荷上（$X = Z W$）来计算二维细胞嵌入 $X_i$。类似地，高维的基因级速度向量 $v_{ig}$ 被投影到相同的二维空间中，以产生嵌入的速度向量 $\\mathbf{v}^{\\mathrm{emb}}_i$。\n\n6.  **核平滑**：最后一步是从单个细胞的离散速度向量中估计一个连续的向量场。给定二维嵌入中的一个查询点 $\\mathbf{q}$，使用高斯核计算嵌入速度 $\\mathbf{v}^{\\mathrm{emb}}_i$ 的加权平均值。在嵌入空间中离查询点更近的细胞会获得更高的权重。这个平滑过程提供了一个对局部速度向量的稳健估计 $\\hat{\\mathbf{V}}(\\mathbf{q})$，代表了在该发育景观位置上细胞状态变化的可能方向和大小。\n\n这些步骤中的每一步都使用 `numpy` 库进行高效的基于数组的计算，并仔细遵循提供的公式，处理所有指定的边缘条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _calculate_rna_velocity_pipeline(S, U, params):\n    \"\"\"\n    Implements the complete RNA velocity pipeline for a single dataset.\n    \n    Args:\n        S (np.ndarray): Spliced counts matrix (cells x genes).\n        U (np.ndarray): Unspliced counts matrix (cells x genes).\n        params (tuple): A tuple of parameters (L0, p, eps_L, delta, h, q).\n\n    Returns:\n        list: The smoothed 2D vector [vx, vy], rounded to 6 decimal places.\n    \"\"\"\n    L0, p, eps_L, delta, h, q_tuple = params\n    S = np.array(S, dtype=float)\n    U = np.array(U, dtype=float)\n    q = np.array(q_tuple, dtype=float)\n    \n    n_cells, n_genes = S.shape\n\n    # Step 1: Cell-wise library-size normalization\n    L = S.sum(axis=1) + U.sum(axis=1)\n    s = np.maximum(L, eps_L) / L0\n    S_tilde = (S + p) / s[:, np.newaxis]\n    U_tilde = (U + p) / s[:, np.newaxis]\n\n    # Step 2: Logarithmic transformation\n    S_hat = np.log1p(S_tilde)\n    U_hat = np.log1p(U_tilde)\n    \n    # Step 3: Gene-wise standardization\n    m_S = S_hat.mean(axis=0)\n    m_U = U_hat.mean(axis=0)\n    # np.std computes population standard deviation (ddof=0) by default\n    sigma_S = S_hat.std(axis=0)\n    sigma_U = U_hat.std(axis=0)\n    \n    denom_S = np.maximum(sigma_S, delta)\n    denom_U = np.maximum(sigma_U, delta)\n    \n    S_bar = (S_hat - m_S) / denom_S\n    U_bar = (U_hat - m_U) / denom_U\n\n    # Step 4: Linear regression per gene and residual-based velocities\n    v = np.zeros_like(S_bar)\n    for g in range(n_genes):\n        x = S_bar[:, g]\n        y = U_bar[:, g]\n        \n        mu_x = x.mean()\n        mu_y = y.mean()\n        \n        # np.var computes population variance (ddof=0) by default\n        var_x = np.var(x)\n        \n        if var_x >= delta:\n            cov_xy = np.mean((x - mu_x) * (y - mu_y))\n            alpha_g = cov_xy / var_x\n            beta_g = mu_y - alpha_g * mu_x\n        else:\n            alpha_g = 0.0\n            beta_g = mu_y\n            \n        v[:, g] = y - (alpha_g * x + beta_g)\n\n    # Step 5: Two-dimensional embedding by PCA\n    Z = S_bar\n    # Using full_matrices=False is efficient and gives Vh of shape (min(n,G), G)\n    try:\n        _, _, Vh = np.linalg.svd(Z, full_matrices=False)\n    except np.linalg.LinAlgError:\n         return [0.0, 0.0] # Failsafe for non-finite data\n\n    # V is the transpose of Vh\n    V = Vh.T\n    \n    # Handle cases with fewer than 2 genes/principal components\n    if V.shape[1]  2:\n        W = np.zeros((n_genes, 2))\n        W[:, :V.shape[1]] = V[:, :V.shape[1]]\n    else:\n        # W are the first 2 columns of V (gene loadings)\n        W = V[:, :2]\n\n    # Project data and velocities onto the 2D embedding space\n    X_emb = Z @ W\n    v_emb = v @ W\n    \n    # Step 6: Kernel smoothing of the vector field at a query point\n    diff = X_emb - q\n    sq_dists = np.sum(diff**2, axis=1)\n    weights = np.exp(-sq_dists / (2 * h**2))\n    \n    sum_weights = np.sum(weights)\n    \n    if sum_weights  delta: # Check for effective zero\n        V_q_hat = np.array([0.0, 0.0])\n    else:\n        weighted_v_emb = weights[:, np.newaxis] * v_emb\n        V_q_hat = np.sum(weighted_v_emb, axis=0) / sum_weights\n        \n    return [round(c, 6) for c in V_q_hat]\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the pipeline for each, and prints the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"S\": np.array([[10, 5, 0], [3, 8, 1], [0, 2, 9], [6, 4, 3]]),\n            \"U\": np.array([[4, 2, 0], [1, 3, 0], [0, 1, 5], [2, 1, 1]]),\n            \"params\": (1000.0, 1.0, 1.0, 1e-8, 1.0, (0.0, 0.0))\n        },\n        {\n            \"S\": np.array([[0, 0, 0], [2, 0, 0], [0, 1, 0], [0, 0, 3]]),\n            \"U\": np.array([[0, 0, 0], [0, 1, 0], [0, 0, 2], [1, 0, 0]]),\n            \"params\": (1000.0, 0.5, 1.0, 1e-8, 0.5, (0.0, 0.0))\n        },\n        {\n            \"S\": np.array([[1000, 50, 7], [50, 50, 7], [3000, 50, 7], [10, 50, 7]]),\n            \"U\": np.array([[200, 10, 3], [10, 10, 3], [600, 10, 3], [2, 10, 3]]),\n            \"params\": (10000.0, 1.0, 1.0, 1e-8, 2.0, (0.0, 0.0))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_rna_velocity_pipeline(case[\"S\"], case[\"U\"], case[\"params\"])\n        results.append(result)\n\n    # The str() representation of a list of lists matches the required format structure.\n    # Ex: [[-0.0, 0.0], [1.0, 2.0]] -> str -> '[[-0.0, 0.0], [1.0, 2.0]]'\n    # The problem asks for a comma-separated list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3346376"}, {"introduction": "在估计RNA速度场时，为了揭示潜在的动态趋势，通常需要对单个细胞的速度估计进行平滑处理。然而，这种基于邻近细胞平均的平滑方法，在某些情况下可能会引入系统性偏差，特别是在嵌入空间中不同细胞谱系紧密相邻时。这项实践将通过构建一个可控的“对抗性”数学模型，引导您定量地分析和理解这种由邻居图选择不当所导致的偏差，从而培养对计算方法局限性的批判性思维 [@problem_id:3346448]。", "problem": "您的任务是量化在估计RNA速度矢量场时，因选择邻近图而引入的偏差。这种情况发生在两个发育上不同的谱系被嵌入到一个$k$-最近邻（kNN）算法会将它们混合的空间中。该分析必须基于第一性原理：RNA速度是基因表达沿潜流形对时间的导数，而基于单细胞数据的矢量场估计通常使用邻近图来平滑局部速度估计。您必须数学上构建一个对抗性嵌入，并计算一个作为邻近点数 $k$ 和流形曲率 $\\kappa$ 函数的定量偏差度量。\n\n构建以下纯数学模型：\n\n- 有两个谱系（曲线）嵌入在二维欧几里得空间中。设共享的曲线形状为一条在原点附近曲率可控的抛物线。将第一个谱系定义为参数曲线 $\\alpha(t) = (x(t), y(t))$，其中\n  $$\n  x(t) = t, \\quad y(t) = \\tfrac{1}{2}\\,\\kappa\\,t^2,\n  $$\n  并将第二个谱系定义为 $\\beta(t) = (x(t), y(t) + \\delta)$，其 $x(t)$ 相同，但增加了一个垂直偏移量 $\\delta$，以使两个谱系保持分离但相互靠近。参数 $t$ 是均匀采样的。\n\n- 真实速度是嵌入沿每条曲线对时间的导数。对于第一个谱系，定义\n  $$\n  \\mathbf{v}_A(t) = \\frac{d\\alpha}{dt} = \\left(1,\\, \\kappa\\, t\\right).\n  $$\n  对于第二个谱系，定义相反的演进方向以创建对抗性配置：\n  $$\n  \\mathbf{v}_B(t) = -\\mathbf{v}_A(t).\n  $$\n  为了计算误差，将真实速度归一化为单位向量：\n  $$\n  \\widehat{\\mathbf{v}}_A(t) = \\frac{\\mathbf{v}_A(t)}{\\|\\mathbf{v}_A(t)\\|_2}, \\quad \\widehat{\\mathbf{v}}_B(t) = \\frac{\\mathbf{v}_B(t)}{\\|\\mathbf{v}_B(t)\\|_2}.\n  $$\n\n- 某个细胞的估计速度是通过对其在嵌入空间中的 $k$ 个欧几里得最近邻（包括来自两个谱系的邻近点）的真实速度进行平均，然后将该方向与该细胞的真实（ground truth）方向进行比较得到的。令 $\\mathcal{N}_k(i)$ 表示细胞 $i$ 的 $k$ 个最近邻的索引集（不包括其自身），并令 $\\mathbf{v}_j^{\\text{true}}$ 表示邻近点 $j$ 的单位真实速度。将细胞 $i$ 的估计速度定义为未加权平均值：\n  $$\n  \\mathbf{v}_i^{\\text{est}} = \\frac{1}{k}\\sum_{j \\in \\mathcal{N}_k(i)} \\mathbf{v}_j^{\\text{true}}.\n  $$\n  每个细胞的方向误差使用余弦相异性来定义：\n  $$\n  e_i = 1 - \\frac{\\mathbf{v}_i^{\\text{est}} \\cdot \\mathbf{v}_i^{\\text{true}}}{\\|\\mathbf{v}_i^{\\text{est}}\\|_2 \\, \\|\\mathbf{v}_i^{\\text{true}}\\|_2}.\n  $$\n  如果 $\\|\\mathbf{v}_i^{\\text{est}}\\|_2 = 0$，则定义 $e_i = 1$。\n\n- 在两个谱系最接近的局部窗口内（此处混合最具对抗性），量化平均偏差 $E(k,\\kappa)$。具体来说，在区间 $[-T, T]$ 上，为每个谱系在均匀间隔的参数值 $t$ 处采样 $N$ 个细胞。定义 $h = \\tfrac{2T}{N-1}$ 并将垂直偏移量设置为 $\\delta = \\eta h$，其中常数 $\\eta \\in (0,1)$，以确保在相同参数 $t$ 下的跨谱系点比同谱系邻近点更近。计算两个谱系在窗口 $|t| \\le \\tau$ 内的平均误差：\n  $$\n  E(k,\\kappa) = \\frac{1}{M}\\sum_{i: |t_i| \\le \\tau} e_i,\n  $$\n  其中 $M$ 是两个谱系中参数值满足 $|t_i| \\le \\tau$ 的细胞总数。\n\n实现以下算法：\n\n- 将常量 $N$、$T$、$\\eta$ 和 $\\tau$ 固定为值 $N = 401$、$T = 1$、$\\eta = 0.2$ 和 $\\tau = 0.2$。\n- 对于每个测试用例 $(k,\\kappa)$，使用指定的 $\\kappa$ 构建两个谱系，并计算如上定义的 $E(k,\\kappa)$。在 $\\mathbb{R}^2$ 中使用欧几里得距离来寻找 $k$-最近邻。在构建邻近点集之前，将两个谱系连接成一个单一的数据集，以便邻近点选择可以混合谱系。\n- 在进行邻近点平均之前，将所有真实速度归一化为单位长度。未归一化的平均值 $\\mathbf{v}_i^{\\text{est}}$ 可能不是单位向量；直接在余弦相异性公式中使用它。\n\n测试套件：\n\n- 使用以下测试用例来探究不同的机制，包括边界和对抗性条件：\n  - $(k,\\kappa) = (1, 0)$\n  - $(k,\\kappa) = (1, 1)$\n  - $(k,\\kappa) = (5, 0.5)$\n  - $(k,\\kappa) = (15, 0)$\n  - $(k,\\kappa) = (51, 2)$\n  - $(k,\\kappa) = (151, 1.5)$\n\n要求的输出格式：\n\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与测试用例相同，例如 $[r_1,r_2,\\dots,r_6]$，其中每个 $r_i$ 是对应测试用例计算出的 $E(k,\\kappa)$ 值。每个 $r_i$ 必须是浮点数。", "solution": "我们通过一个受控的对抗性构造，将RNA速度矢量场估计中由邻近点引起的偏差问题形式化。其基本原理如下：RNA速度是基因表达沿潜在细胞轨迹的时间导数；在一个嵌入中，此轨迹是一条曲线，局部速度矢量与切线对齐。一种常见的估计器通过在嵌入的欧几里得距离上构建的$k$-最近邻（kNN）图来平滑逐细胞的速度。如果嵌入的几何结构导致不同谱系的细胞比同一谱系内的邻近细胞更近，那么邻近点平均会因混合不同方向而引入系统性偏差。\n\n我们按步骤进行。\n\n$1.$ 在 $\\mathbb{R}^2$ 中构建两个谱系，作为曲率 $\\kappa$ 可调的曲线：\n- 第一个谱系是 $\\alpha(t) = (t, \\tfrac{1}{2}\\kappa t^2)$，其中 $t \\in [-T,T]$。\n- 第二个谱系是 $\\beta(t) = (t, \\delta + \\tfrac{1}{2}\\kappa t^2)$，是第一个谱系在垂直方向上平移 $\\delta$ 的副本。\n这种选择允许直接控制 $t=0$ 附近的曲率。对于抛物线 $y = a t^2$ 且 $a = \\tfrac{\\kappa}{2}$，根据平面曲线 $y(x)$ 的标准曲率公式，在原点的曲率等于 $\\kappa$，因为当 $x=0$ 时，该公式简化为 $|y''(0)|$（因为 $y'(0)=0$）。\n\n$2.$ 将真实速度定义为嵌入的时间导数，这与RNA速度的解释一致：\n- 对于谱系 $A$，$\\mathbf{v}_A(t) = \\frac{d\\alpha}{dt} = (1,\\kappa t)$。\n- 对于谱系 $B$，强制设定一个对抗性的相反发育方向 $\\mathbf{v}_B(t) = -\\mathbf{v}_A(t)$。\n归一化为单位向量：\n$$\n\\widehat{\\mathbf{v}}_A(t) = \\frac{(1,\\kappa t)}{\\sqrt{1+(\\kappa t)^2}}, \\quad \\widehat{\\mathbf{v}}_B(t) = -\\widehat{\\mathbf{v}}_A(t).\n$$\n这保证了对于来自不同谱系、具有相同参数 $t$ 的细胞，其真实速度是反平行的，从而在混合时最大化了潜在的偏差。\n\n$3.$ 采样与对抗性邻近。在 $[-T,T]$ 区间上，为每个谱系在均匀间隔的参数 $t_i$ 处采样 $N$ 个细胞。参数间距为 $h = \\tfrac{2T}{N-1}$。将垂直偏移量设置为 $\\delta = \\eta h$，其中常数 $\\eta \\in (0,1)$。对于较小的 $|t|$，在相同 $t$ 值下跨谱系点之间的欧几里得距离为 $\\delta$，而到 $t \\pm h$ 处的同谱系邻近点的距离约为 $h\\sqrt{1+(\\kappa t)^2}$。通过选择 $\\delta = \\eta h$ 且 $\\eta  1$，我们确保在 $t=0$ 附近，相同 $t$ 值的跨谱系邻近点比同谱系邻近点更近，因此kNN图在该区域会优先混合谱系。\n\n$4.$ 基于kNN的估计器。将两个谱系连接成一个包含 $2N$ 个细胞的单一数据集，这些细胞位于点 $\\{\\mathbf{x}_i\\}_{i=1}^{2N}$ 处。对于每个细胞 $i$，计算其 $k$ 个欧几里得距离最近的邻近点集合 $\\mathcal{N}_k(i)$（不包括其自身）。通过未加权的邻近点平均来估计局部速度：\n$$\n\\mathbf{v}_i^{\\text{est}} = \\frac{1}{k} \\sum_{j \\in \\mathcal{N}_k(i)} \\mathbf{v}_j^{\\text{true}}.\n$$\n我们令 $\\mathbf{v}_j^{\\text{true}}$ 为邻近点 $j$ 对应其谱系的单位真实速度。\n\n$5.$ 误差度量。为量化方向性偏差，计算每个细胞的余弦相异性：\n$$\ne_i = 1 - \\frac{\\mathbf{v}_i^{\\text{est}} \\cdot \\mathbf{v}_i^{\\text{true}}}{\\|\\mathbf{v}_i^{\\text{est}}\\|_2 \\, \\|\\mathbf{v}_i^{\\text{true}}\\|_2}.\n$$\n由于根据构造 $\\|\\mathbf{v}_i^{\\text{true}}\\|_2 = 1$，上式可简化为 $1 - \\frac{\\mathbf{v}_i^{\\text{est}} \\cdot \\mathbf{v}_i^{\\text{true}}}{\\|\\mathbf{v}_i^{\\text{est}}\\|_2}$。如果 $\\|\\mathbf{v}_i^{\\text{est}}\\|_2 = 0$，则定义 $e_i = 1$（平均而言，与随机方向的最大相异性）。在窗口 $|t|\\le \\tau$ 内两个谱系的平均误差为\n$$\nE(k,\\kappa) = \\frac{1}{M} \\sum_{i: |t_i| \\le \\tau} e_i.\n$$\n我们关注一个局部化的窗口，以测量混合最强区域的偏差，并限制曲率引起的全局效应。\n\n$6.$ 参数选择与测试套件。固定 $N = 401$，$T = 1$，并选择 $\\eta = 0.2$，使得 $\\delta = 0.2\\,h$，其中 $h = \\tfrac{2}{400} = 0.005$。因此 $\\delta = 0.001$。选择窗口半宽 $\\tau = 0.2$。对指定的配对 $(k,\\kappa)$ 评估 $E(k,\\kappa)$：\n- $(1,0)$：边界情况，谱系为直线、平行，且方向呈最大对抗性。当 $k=1$ 时，在 $t=0$ 附近的细胞的最近邻位于距离 $\\delta$ 的相对谱系上，导致局部 $\\mathbf{v}_i^{\\text{est}} \\approx -\\mathbf{v}_i^{\\text{true}}$ 且 $e_i \\approx 2$。\n- $(1,1)$：$k=1$ 的曲线情况，仍然具有对抗性；曲率轻微改变了邻近点的几何结构。\n- $(5,0.5)$：低曲率下的小范围邻近点平滑。\n- $(15,0)$：在直线谱系上进行更强的平滑。\n- $(51,2)$：高平滑度和高曲率，增加了同谱系内邻近点的距离，从而在 $t=0$ 附近增加了跨谱系的混合。\n- $(151,1.5)$：非常强的平滑，对许多邻近点进行平均，可能稀释方向性并增加抵消的机会。\n\n$7.$ 计算方法。对于每个 $(k,\\kappa)$：\n- 使用给定的 $\\kappa$ 和 $\\delta$ 为两个谱系构建坐标。\n- 计算两两之间的欧几里得距离，并通过排序距离获得 $\\mathcal{N}_k(i)$。\n- 为所有 $i$ 计算 $\\mathbf{v}_i^{\\text{est}}$ 和 $e_i$。\n- 限制在 $|t| \\le \\tau$ 的细胞范围内，并计算平均值以获得 $E(k,\\kappa)$。\n\n最终程序确定性地实现此算法，并以单行逗号分隔的浮点数列表形式输出 $[E(1,0), E(1,1), E(5,0.5), E(15,0), E(51,2), E(151,1.5)]$，并用方括号括起来。\n\n定性预期：\n- 对于 $k=1$，对抗性设计在 $t=0$ 附近产生较大误差，当最近邻位于方向相反的谱系上时，误差接近 $2$。\n- 随着 $k$ 的增加，估计器对混合的邻近点进行平均；根据相对谱系邻近点的比例，$\\mathbf{v}_i^{\\text{est}}$ 可能会被衰减甚至几乎抵消。如果估计值的模长变小或方向错误，余弦相异性会趋向于 $1$。\n- 增加 $\\kappa$ 会在窗口边缘附近以固定的参数间距增加同谱系内邻近点的距离（因为点在 $y$ 方向上分离得更远），从而增强了对抗区域内的跨谱系混合，并倾向于在固定 $k$ 的情况下增加 $E(k,\\kappa)$。\n\n这些行为源于几何嵌入与kNN图之间的相互作用，其基础是将RNA速度定义为流形切线，并将估计器定义为嵌入空间中的邻近点平均。", "answer": "```python\nimport numpy as np\n\ndef build_lineages_and_velocities(kappa, N=401, T=1.0, eta=0.2):\n    # Parameter grid\n    t = np.linspace(-T, T, N)\n    h = (2*T) / (N-1)\n    delta = eta * h\n\n    # Lineage A coordinates: (t, 0.5 * kappa * t^2)\n    xA = t.copy()\n    yA = 0.5 * kappa * t**2\n\n    # Lineage B coordinates: shifted vertically by delta\n    xB = t.copy()\n    yB = delta + 0.5 * kappa * t**2\n\n    # True velocities (unit vectors)\n    # v_A = (1, kappa * t) normalized\n    denom = np.sqrt(1.0 + (kappa * t)**2)\n    vAx = 1.0 / denom\n    vAy = (kappa * t) / denom\n\n    # v_B = -v_A\n    vBx = -vAx\n    vBy = -vAy\n\n    # Stack coordinates and velocities\n    X = np.vstack([np.column_stack([xA, yA]), np.column_stack([xB, yB])])  # shape (2N, 2)\n    V_true = np.vstack([np.column_stack([vAx, vAy]), np.column_stack([vBx, vBy])])  # shape (2N, 2)\n    # Parameter t replicated for both lineages\n    t_all = np.concatenate([t, t])\n\n    return X, V_true, t_all\n\ndef knn_indices(X, k):\n    # Compute pairwise distances\n    # X shape: (M, 2)\n    M = X.shape[0]\n    # Use (x^2 + y^2) - 2 X X^T + (x^2 + y^2)^T trick\n    sq = np.sum(X**2, axis=1, keepdims=True)  # (M,1)\n    d2 = sq + sq.T - 2.0 * (X @ X.T)\n    # Ensure self-distance is inf to exclude self\n    np.fill_diagonal(d2, np.inf)\n    # Get k nearest indices for each point\n    # argsort along axis 1, take first k\n    idx = np.argpartition(d2, kth=k-1, axis=1)[:, :k]\n    # For stable ordering by actual distance within the k subset\n    # Gather distances for these idx and sort within rows\n    row_indices = np.arange(M)[:, None]\n    d2_k = d2[row_indices, idx]\n    order_within = np.argsort(d2_k, axis=1)\n    idx_sorted = idx[row_indices, order_within]\n    return idx_sorted\n\ndef compute_mean_error(X, V_true, t_all, k, tau=0.2):\n    # Build kNN graph\n    k = int(k)\n    k = max(1, min(k, X.shape[0]-1))\n    nn_idx = knn_indices(X, k)\n    # Estimate velocities by averaging neighbors' true velocities\n    V_est = np.zeros_like(V_true)\n    for i in range(X.shape[0]):\n        nbrs = nn_idx[i]\n        v_mean = V_true[nbrs].mean(axis=0)\n        V_est[i] = v_mean\n\n    # Compute per-cell cosine dissimilarity\n    # Handle zero norm estimates\n    est_norm = np.linalg.norm(V_est, axis=1)\n    # True norm is 1 by construction, but compute robustly\n    true_norm = np.linalg.norm(V_true, axis=1)\n    # Avoid division by zero\n    eps = 1e-12\n    cos_sim = np.sum(V_est * V_true, axis=1) / (np.maximum(est_norm, eps) * np.maximum(true_norm, eps))\n    # Clip for numerical safety\n    cos_sim = np.clip(cos_sim, -1.0, 1.0)\n    e = 1.0 - cos_sim\n\n    # Restrict to window |t| = tau\n    mask = np.abs(t_all) = tau\n    if not np.any(mask):\n        return float(np.nan)\n    E = float(e[mask].mean())\n    return E\n\ndef solve():\n    # Constants per the problem statement\n    N = 401\n    T = 1.0\n    eta = 0.2\n    tau = 0.2\n\n    # Test cases: (k, kappa)\n    test_cases = [\n        (1, 0.0),\n        (1, 1.0),\n        (5, 0.5),\n        (15, 0.0),\n        (51, 2.0),\n        (151, 1.5),\n    ]\n\n    results = []\n    for k, kappa in test_cases:\n        X, V_true, t_all = build_lineages_and_velocities(kappa, N=N, T=T, eta=eta)\n        E = compute_mean_error(X, V_true, t_all, k=k, tau=tau)\n        # Round to 6 decimal places for stable output\n        results.append(f\"{E:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3346448"}, {"introduction": "标准的RNA速度模型一个核心局限性在于其动力学参数（如剪接速率）的不可辨识性，这导致了速度估计的绝对尺度不确定。为了克服这一挑战，我们可以整合额外的数据类型，如代谢标记（例如4sU标记）实验，以校准模型参数。这项高级实践将指导您使用分层贝叶斯模型，以一种有原则的方式融合剪接/非剪接RNA计数和代谢标记数据，以联合推断动力学速率并量化最终速度估计的不确定性 [@problem_id:3346357]。", "problem": "考虑一个简化的核糖核酸（RNA）转录和加工动力学模型，其中基因 $g$ 的未剪接和已剪接计数分别表示为 $u_g$ 和 $s_g$。核心动力学系统由以下常微分方程（ODE）捕获：\n$$\n\\frac{du_g}{dt} = \\alpha_g - \\beta_g u_g, \\quad \\frac{ds_g}{dt} = \\beta_g u_g - \\gamma_g s_g,\n$$\n其中 $\\alpha_g$ 是转录起始率，$\\beta_g$ 是剪接率，$\\gamma_g$ 是降解率。已剪接 RNA 的速率定义为：\n$$\nv_g = \\frac{ds_g}{dt} = \\beta_g u_g - \\gamma_g s_g,\n$$\n当 $\\gamma_g$ 的单位为 $\\text{min}^{-1}$ 且 $u_g, s_g$ 的单位为分子时，其单位为分子/分钟。\n\n为了校准转录率的尺度，我们引入了来自 $4$-硫尿苷（$4$sU）的代谢标记数据，该数据为 $\\alpha_g$ 提供了一个含噪声的线性代理。具体来说，我们假设一个观测模型\n$$\nz_g = c \\, \\alpha_g + \\epsilon^{(z)}_g, \\quad \\epsilon^{(z)}_g \\sim \\mathcal{N}(0, \\sigma_z^2),\n$$\n其中 $z_g$ 是从 $4$sU 标记中导出的测量值，$c$ 是一个已知的校准尺度，$\\sigma_z^2$ 是测量噪声方差。我们还通过未剪接计数 $u_g$ 在 $\\alpha_g$ 和 $\\beta_g$ 之间引入一个准稳态耦合，将其视为一个含噪声的约束：\n$$\nr_g = \\alpha_g - u_g \\beta_g + \\epsilon^{(r)}_g, \\quad \\epsilon^{(r)}_g \\sim \\mathcal{N}(0, \\sigma_r^2),\n$$\n其中伪观测值 $r_g = 0$ 代表未剪接池与稳态的微小偏离。\n\n我们对每个基因的参数设置一个具有共享超参数的分层贝叶斯先验：\n$$\n\\alpha_g \\mid \\mu_\\alpha \\sim \\mathcal{N}(\\mu_\\alpha, \\tau_\\alpha^2), \\quad \\beta_g \\mid \\mu_\\beta \\sim \\mathcal{N}(\\mu_\\beta, \\tau_\\beta^2),\n$$\n$$\n\\mu_\\alpha \\sim \\mathcal{N}(m_{0,\\alpha}, s_{0,\\alpha}^2), \\quad \\mu_\\beta \\sim \\mathcal{N}(m_{0,\\beta}, s_{0,\\beta}^2),\n$$\n其中 $\\tau_\\alpha^2$ 和 $\\tau_\\beta^2$ 被视为固定且已知。\n\n在这个线性高斯分层模型下，变量\n$$\n\\mathbf{x} = \\left[\\alpha_1, \\ldots, \\alpha_n, \\beta_1, \\ldots, \\beta_n, \\mu_\\alpha, \\mu_\\beta\\right]^\\top\n$$\n的联合后验分布是高斯的。设后验精度矩阵为 $\\mathbf{K}$，后验信息向量为 $\\mathbf{h}$，因此后验均值 $\\boldsymbol{m}$ 满足\n$$\n\\mathbf{K} \\, \\boldsymbol{m} = \\mathbf{h},\n$$\n且后验协方差为 $\\mathbf{\\Sigma} = \\mathbf{K}^{-1}$。$v_g$ 的后验分布是高斯的，因为 $v_g$ 是 $\\beta_g$ 的一个仿射函数。其均值和方差为\n$$\n\\mathbb{E}[v_g] = u_g \\, \\mathbb{E}[\\beta_g] - \\gamma_g s_g, \\quad \\mathrm{Var}(v_g) = u_g^2 \\, \\mathrm{Var}(\\beta_g).\n$$\n\n为速率定义一个可识别性信噪比（SNR）准则：\n$$\n\\mathrm{SNR}_g = \\frac{|\\mathbb{E}[v_g]|}{\\sqrt{\\mathrm{Var}(v_g)}},\n$$\n如果 $\\mathrm{SNR}_g \\geq T$，则声明 $v_g$ 是可识别的，其中 $T$ 是一个指定的阈值。\n\n你的任务是实现一个程序，该程序：\n- 使用与上述先验和似然相对应的线性高斯因子，为分层模型构建后验。\n- 对每个测试用例中的每个基因，计算 $v_g$ 的后验均值（单位：分子/分钟）、$v_g$ 的后验标准差（单位：分子/分钟）以及根据 SNR 阈值 $T$ 确定的可识别性布尔值。\n\n使用以下测试套件参数集：\n\n- 测试用例 $1$（具有信息性 $4$sU 的一般情况）：\n  - $n = 3$，基因索引为 $g = 1, 2, 3$。\n  - $u = [5.0, 2.0, 8.0]$ 分子，$s = [20.0, 10.0, 30.0]$ 分子。\n  - $z = [5.2, 1.8, 9.0]$ 任意单位。\n  - $c = 1.0$, $\\sigma_z = 0.5$, $\\sigma_r = 0.3$。\n  - 对所有 $g$，$\\gamma_g = 0.1$ $\\text{min}^{-1}$。\n  - $m_{0,\\alpha} = 2.0$, $s_{0,\\alpha} = 2.0$, $\\tau_\\alpha = 1.0$。\n  - $m_{0,\\beta} = 0.5$, $s_{0,\\beta} = 2.0$, $\\tau_\\beta = 1.0$。\n  - $T = 2.0$。\n\n- 测试用例 $2$（弱 $4$sU 校准，高噪声）：\n  - $n = 3$, $u = [5.0, 2.0, 8.0]$, $s = [20.0, 10.0, 30.0]$。\n  - $z = [5.2, 1.8, 9.0]$。\n  - $c = 1.0$, $\\sigma_z = 10.0$, $\\sigma_r = 0.3$。\n  - 对所有 $g$，$\\gamma_g = 0.1$ $\\text{min}^{-1}$。\n  - $m_{0,\\alpha} = 2.0$, $s_{0,\\alpha} = 2.0$, $\\tau_\\alpha = 1.0$。\n  - $m_{0,\\beta} = 0.5$, $s_{0,\\beta} = 2.0$, $\\tau_\\beta = 1.0$。\n  - $T = 2.0$。\n\n- 测试用例 $3$（边界情况，一个基因的 $u=0$ 且无 $4$sU 校准）：\n  - $n = 2$, $u = [0.0, 3.0]$, $s = [15.0, 12.0]$。\n  - $z = [0.0, 0.0]$（由于零校准而无信息）。\n  - $c = 0.0$, $\\sigma_z = 1.0$, $\\sigma_r = 0.2$。\n  - 对所有 $g$，$\\gamma_g = 0.2$ $\\text{min}^{-1}$。\n  - $m_{0,\\alpha} = 2.0$, $s_{0,\\alpha} = 2.0$, $\\tau_\\alpha = 1.0$。\n  - $m_{0,\\beta} = 0.5$, $s_{0,\\beta} = 2.0$, $\\tau_\\beta = 1.0$。\n  - $T = 1.0$。\n\n你的程序应生成单行输出，其中包含每个测试用例的一个包含三个元素的列表：\n- 后验均值速率列表 $[\\mathbb{E}[v_1], \\ldots, \\mathbb{E}[v_n]]$，单位为分子/分钟（浮点数），\n- 后验标准差列表 $[\\sqrt{\\mathrm{Var}(v_1)}, \\ldots, \\sqrt{\\mathrm{Var}(v_n)}]$，单位为分子/分钟（浮点数），\n- 可识别性布尔值列表 $[\\mathrm{SNR}_1 \\ge T, \\ldots, \\mathrm{SNR}_n \\ge T]$。\n\n最终输出格式必须是单行，包含所有测试用例结果的逗号分隔列表，并用方括号括起来，例如：\n$$\n[\\text{case1\\_result}, \\text{case2\\_result}, \\text{case3\\_result}],\n$$\n其中每个 $\\text{caseX\\_result}$ 本身就是具有上述结构的列表。所有速率和标准差都必须以分子/分钟为单位表示，每个浮点数显示到小数点后四位。不涉及角度。不使用百分比；任何比率都必须表示为小数。程序必须是完全确定性的和自包含的。", "solution": "该问题要求在指定的分层贝叶斯模型中计算 RNA 速率的后验统计量。该模型是一个线性高斯系统，这意味着所有未知参数的联合后验分布也是高斯的。这使得可以通过构建和求解一个线性系统来获得解析解，从而避免了像马尔可夫链蒙特卡洛（MCMC）这样计算密集型的采样方法。解决方案主要分三个阶段进行：构建后验分布的正则形式，求解后验参数，以及计算所需的速率统计量。\n\n### 1. 贝叶斯模型与后验公式\n\n未知参数的向量是 $\\mathbf{x} = [\\alpha_1, \\ldots, \\alpha_n, \\beta_1, \\ldots, \\beta_n, \\mu_\\alpha, \\mu_\\beta]^\\top$，维度为 $2n+2$。后验分布 $p(\\mathbf{x} | \\text{data})$ 与所有先验和似然项的乘积成正比：\n$$\np(\\mathbf{x} | \\text{data}) \\propto p(\\mu_\\alpha) p(\\mu_\\beta) \\left( \\prod_{g=1}^n p(\\alpha_g | \\mu_\\alpha) p(\\beta_g | \\mu_\\beta) p(z_g | \\alpha_g) p(r_g=0 | \\alpha_g, \\beta_g) \\right).\n$$\n由于所有因子都是高斯的，它们的乘积也是高斯的。后验密度的对数是 $\\mathbf{x}$ 的一个二次函数：\n$$\n\\log p(\\mathbf{x} | \\text{data}) = -\\frac{1}{2}\\mathbf{x}^\\top \\mathbf{K} \\mathbf{x} + \\mathbf{h}^\\top \\mathbf{x} + \\text{const.},\n$$\n其中 $\\mathbf{K}$ 是后验精度矩阵，$\\mathbf{h}$ 是后验信息向量。这种正则形式的一个关键特性是，总精度矩阵 $\\mathbf{K}$ 是每个因子精度矩阵的总和，总信息向量 $\\mathbf{h}$ 是每个因子信息向量的总和。我们将通过对模型中每一项的贡献求和来构建 $\\mathbf{K}$ 和 $\\mathbf{h}$。\n\n设状态向量 $\\mathbf{x}$ 的索引如下：$\\alpha_g$ 在索引 $g-1$ 处，$\\beta_g$ 在索引 $n+g-1$ 处（对于 $g \\in \\{1, \\ldots, n\\}$），$\\mu_\\alpha$ 在索引 $2n$ 处，$\\mu_\\beta$ 在索引 $2n+1$ 处。\n\n### 2. 精度矩阵（$\\mathbf{K}$）和信息向量（$\\mathbf{h}$）的构建\n\n我们分析每个因子对 $\\mathbf{K}$ 和 $\\mathbf{h}$ 的贡献。\n\n- **超先验**：$p(\\mu_\\alpha) = \\mathcal{N}(\\mu_\\alpha | m_{0,\\alpha}, s_{0,\\alpha}^2)$ 和 $p(\\mu_\\beta) = \\mathcal{N}(\\mu_\\beta | m_{0,\\beta}, s_{0,\\beta}^2)$。\n  对数先验是 $-\\frac{1}{2s_{0,\\alpha}^2}(\\mu_\\alpha - m_{0,\\alpha})^2$ 和 $-\\frac{1}{2s_{0,\\beta}^2}(\\mu_\\beta - m_{0,\\beta})^2$。展开这些二次型可得：\n  - 对 $\\mathbf{K}[2n, 2n]$ 的贡献：$1/s_{0,\\alpha}^2$。对 $\\mathbf{h}[2n]$ 的贡献：$m_{0,\\alpha}/s_{0,\\alpha}^2$。\n  - 对 $\\mathbf{K}[2n+1, 2n+1]$ 的贡献：$1/s_{0,\\beta}^2$。对 $\\mathbf{h}[2n+1]$ 的贡献：$m_{0,\\beta}/s_{0,\\beta}^2$。\n\n- **分层先验**：对于每个基因 $g$，$p(\\alpha_g | \\mu_\\alpha) = \\mathcal{N}(\\alpha_g | \\mu_\\alpha, \\tau_\\alpha^2)$ 和 $p(\\beta_g | \\mu_\\beta) = \\mathcal{N}(\\beta_g | \\mu_\\beta, \\tau_\\beta^2)$。\n  对数先验涉及成对的变量，例如，$-\\frac{1}{2\\tau_\\alpha^2}(\\alpha_g - \\mu_\\alpha)^2 = -\\frac{1}{2\\tau_\\alpha^2}(\\alpha_g^2 - 2\\alpha_g\\mu_\\alpha + \\mu_\\alpha^2)$。\n  - 对于 $p(\\alpha_g|\\mu_\\alpha)$，对变量 $(\\alpha_g, \\mu_\\alpha)$ 的精度矩阵贡献是 $\\frac{1}{\\tau_\\alpha^2}\\begin{psmallmatrix} 1  -1 \\\\ -1  1 \\end{psmallmatrix}$。这会影响 $\\mathbf{K}[g-1, g-1]$、$\\mathbf{K}[2n, 2n]$ 以及非对角项 $\\mathbf{K}[g-1, 2n]$ 和 $\\mathbf{K}[2n, g-1]$。\n  - 类似地，对于 $p(\\beta_g|\\mu_\\beta)$，对 $(\\beta_g, \\mu_\\beta)$ 的精度矩阵贡献是 $\\frac{1}{\\tau_\\beta^2}\\begin{psmallmatrix} 1  -1 \\\\ -1  1 \\end{psmallmatrix}$。\n\n- **似然**：对于每个基因 $g$，我们有两个观测项。\n  - $p(z_g | \\alpha_g) = \\mathcal{N}(z_g | c\\alpha_g, \\sigma_z^2)$：对数似然是 $-\\frac{1}{2\\sigma_z^2}(z_g - c\\alpha_g)^2 = -\\frac{c^2}{2\\sigma_z^2}\\alpha_g^2 + \\frac{cz_g}{\\sigma_z^2}\\alpha_g + \\text{const}$。\n    - 对 $\\mathbf{K}[g-1, g-1]$ 的贡献：$c^2/\\sigma_z^2$。对 $\\mathbf{h}[g-1]$ 的贡献：$cz_g/\\sigma_z^2$。\n  - $p(r_g=0 | \\alpha_g, \\beta_g) = \\mathcal{N}(0 | \\alpha_g - u_g\\beta_g, \\sigma_r^2)$：对数似然是 $-\\frac{1}{2\\sigma_r^2}(\\alpha_g - u_g\\beta_g)^2 = -\\frac{1}{2\\sigma_r^2}(\\alpha_g^2 - 2u_g\\alpha_g\\beta_g + u_g^2\\beta_g^2)$。\n    - 对变量 $(\\alpha_g, \\beta_g)$ 的精度矩阵贡献是 $\\frac{1}{\\sigma_r^2}\\begin{psmallmatrix} 1  -u_g \\\\ -u_g  u_g^2 \\end{psmallmatrix}$。\n\n通过将 $\\mathbf{K}$ 和 $\\mathbf{h}$ 初始化为零，并对所有基因和所有模型因子累加这些贡献，我们得到了完整的后验精度矩阵和信息向量。\n\n### 3. 求解后验矩和速率统计量\n\n后验均值向量 $\\boldsymbol{m}$ 和协方差矩阵 $\\mathbf{\\Sigma}$ 通过以下方式找到：\n$$\n\\boldsymbol{m} = \\mathbf{K}^{-1}\\mathbf{h} \\quad \\text{和} \\quad \\mathbf{\\Sigma} = \\mathbf{K}^{-1}.\n$$\n在计算上，求解线性系统 $\\mathbf{K}\\boldsymbol{m} = \\mathbf{h}$ 来得到 $\\boldsymbol{m}$，然后通过对 $\\mathbf{K}$ 求逆来计算 $\\mathbf{\\Sigma}$ 会更稳定。\n\n每个基因 $\\beta_g$ 的后验矩直接从 $\\boldsymbol{m}$ 和 $\\mathbf{\\Sigma}$ 中提取：\n- 后验均值：$\\mathbb{E}[\\beta_g] = \\boldsymbol{m}_{n+g-1}$\n- 后验方差：$\\mathrm{Var}(\\beta_g) = \\mathbf{\\Sigma}_{n+g-1, n+g-1}$\n\n速率 $v_g = \\beta_g u_g - \\gamma_g s_g$ 是高斯随机变量 $\\beta_g$ 的仿射函数。因此，其后验分布也是高斯的。其均值和方差为：\n$$\n\\mathbb{E}[v_g] = u_g \\, \\mathbb{E}[\\beta_g] - \\gamma_g s_g\n$$\n$$\n\\mathrm{Var}(v_g) = \\mathrm{Var}(u_g \\beta_g - \\gamma_g s_g) = u_g^2 \\, \\mathrm{Var}(\\beta_g)\n$$\n后验标准差是 $\\sqrt{\\mathrm{Var}(v_g)}$。\n\n最后，计算信噪比：\n$$\n\\mathrm{SNR}_g = \\frac{|\\mathbb{E}[v_g]|}{\\sqrt{\\mathrm{Var}(v_g)}}.\n$$\n当 $u_g = 0$ 时会出现一个特殊情况，导致 $\\mathrm{Var}(v_g) = 0$。如果 $\\mathbb{E}[v_g] \\neq 0$，则 SNR 为无穷大。如果两者都为零，则 SNR 为零。如果 $\\mathrm{SNR}_g \\geq T$，则速率 $v_g$ 被认为是可识别的。\n\n实现将对每个测试用例遵循这些步骤，构建和求解系统，然后为每个基因计算所需的统计数据。", "answer": "```python\nimport numpy as np\n\ndef format_result(mean_v, std_v, iden):\n    \"\"\"\n    Formats the results for a single test case into the required string representation.\n    \"\"\"\n    mean_v_str = [f\"{v:.4f}\" for v in mean_v]\n    std_v_str = [f\"{v:.4f}\" for v in std_v]\n    # Use join to create a comma-separated list without spaces, e.g., \"[True,False]\"\n    iden_str = ','.join(map(str, iden))\n    \n    return f\"[[{','.join(mean_v_str)}],[{','.join(std_v_str)}],[{iden_str}]]\"\n\ndef compute_posterior_stats(params):\n    \"\"\"\n    Constructs the posterior and computes velocity statistics for a single test case.\n    \"\"\"\n    n, u, s, z, c, sigma_z, sigma_r, gamma_val, m0_alpha, s0_alpha, tau_alpha, m0_beta, s0_beta, tau_beta, T = params\n\n    gamma = [gamma_val] * n\n    dim = 2 * n + 2\n    K = np.zeros((dim, dim))\n    h = np.zeros(dim)\n\n    # Indices map\n    mu_alpha_idx = 2 * n\n    mu_beta_idx = 2 * n + 1\n\n    # Add hyperprior contributions\n    if s0_alpha > 0:\n        prec_m0_alpha = 1 / s0_alpha**2\n        K[mu_alpha_idx, mu_alpha_idx] += prec_m0_alpha\n        h[mu_alpha_idx] += m0_alpha * prec_m0_alpha\n    if s0_beta > 0:\n        prec_m0_beta = 1 / s0_beta**2\n        K[mu_beta_idx, mu_beta_idx] += prec_m0_beta\n        h[mu_beta_idx] += m0_beta * prec_m0_beta\n\n    # Pre-calculate factor precisions\n    prec_tau_alpha = 1 / tau_alpha**2 if tau_alpha > 0 else 0\n    prec_tau_beta = 1 / tau_beta**2 if tau_beta > 0 else 0\n    prec_z = 1 / sigma_z**2 if sigma_z > 0 else 0\n    prec_r = 1 / sigma_r**2 if sigma_r > 0 else 0\n\n    # Loop over genes to add prior and likelihood contributions\n    for g in range(n):\n        alpha_idx = g\n        beta_idx = n + g\n\n        # Hierarchical prior on alpha_g\n        K[alpha_idx, alpha_idx] += prec_tau_alpha\n        K[mu_alpha_idx, mu_alpha_idx] += prec_tau_alpha\n        K[alpha_idx, mu_alpha_idx] -= prec_tau_alpha\n        K[mu_alpha_idx, alpha_idx] -= prec_tau_alpha\n\n        # Hierarchical prior on beta_g\n        K[beta_idx, beta_idx] += prec_tau_beta\n        K[mu_beta_idx, mu_beta_idx] += prec_tau_beta\n        K[beta_idx, mu_beta_idx] -= prec_tau_beta\n        K[mu_beta_idx, beta_idx] -= prec_tau_beta\n\n        # Likelihood from z_g\n        K[alpha_idx, alpha_idx] += c**2 * prec_z\n        h[alpha_idx] += c * z[g] * prec_z\n        \n        # Likelihood from r_g\n        ug = u[g]\n        K[alpha_idx, alpha_idx] += prec_r\n        K[beta_idx, beta_idx] += ug**2 * prec_r\n        K[alpha_idx, beta_idx] -= ug * prec_r\n        K[beta_idx, alpha_idx] -= ug * prec_r\n\n    # Solve for posterior mean and calculate covariance\n    m = np.linalg.solve(K, h)\n    Sigma = np.linalg.inv(K)\n\n    # Calculate and collect velocity statistics for each gene\n    mean_velocities = []\n    std_dev_velocities = []\n    identifiability = []\n\n    for g in range(n):\n        beta_idx = n + g\n        mean_beta_g = m[beta_idx]\n        var_beta_g = Sigma[beta_idx, beta_idx]\n        \n        # Ensure variance is non-negative due to potential floating point errors\n        var_beta_g = max(0, var_beta_g)\n\n        mean_vg = u[g] * mean_beta_g - gamma[g] * s[g]\n        var_vg = u[g]**2 * var_beta_g\n        std_dev_vg = np.sqrt(var_vg)\n        \n        # SNR calculation, handling division by zero\n        if std_dev_vg == 0.0:\n            snr_g = np.inf if np.abs(mean_vg) > 0 else 0.0\n        else:\n            snr_g = np.abs(mean_vg) / std_dev_vg\n\n        is_identifiable = snr_g >= T\n        \n        mean_velocities.append(mean_vg)\n        std_dev_velocities.append(std_dev_vg)\n        identifiability.append(is_identifiable)\n\n    return format_result(mean_velocities, std_dev_velocities, identifiability)\n\ndef solve():\n    # Test cases defined in the problem statement\n    test_cases = [\n        # Test Case 1\n        (3, [5.0, 2.0, 8.0], [20.0, 10.0, 30.0], [5.2, 1.8, 9.0], 1.0, 0.5, 0.3, 0.1, 2.0, 2.0, 1.0, 0.5, 2.0, 1.0, 2.0),\n        # Test Case 2\n        (3, [5.0, 2.0, 8.0], [20.0, 10.0, 30.0], [5.2, 1.8, 9.0], 1.0, 10.0, 0.3, 0.1, 2.0, 2.0, 1.0, 0.5, 2.0, 1.0, 2.0),\n        # Test Case 3\n        (2, [0.0, 3.0], [15.0, 12.0], [0.0, 0.0], 0.0, 1.0, 0.2, 0.2, 2.0, 2.0, 1.0, 0.5, 2.0, 1.0, 1.0)\n    ]\n    \n    results = []\n    for case in test_cases:\n        result_str = compute_posterior_stats(case)\n        results.append(result_str)\n\n    # Print the final output as a single-line string\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3346357"}]}