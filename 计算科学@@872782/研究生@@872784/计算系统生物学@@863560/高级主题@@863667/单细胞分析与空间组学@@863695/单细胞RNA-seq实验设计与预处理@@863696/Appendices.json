{"hands_on_practices": [{"introduction": "唯一分子标识（Unique Molecular Identifiers, UMIs）对于去除PCR扩增重复并实现精确的分子计数至关重要。然而，由于UMI序列的数量有限，可能会发生“碰撞”——即不同的分子被偶然分配了相同的UMI，这会导致高表达基因的表达量被低估。本练习 [@problem_id:3348560] 将指导您从第一性原理出发，推导出一个数学模型来预测观测到的唯一UMI的期望数量，为您评估自身实验设计中潜在的UMI饱和问题提供一个关键工具。", "problem": "您正在设计一种数学方法，用于估算单细胞核糖核酸测序 (single-cell RNA-seq) 中的去重独特分子标识符 (UMI)。假设对于单个细胞中的单个基因，其生成模型如下：捕获的互补脱氧核糖核酸 (cDNA) 分子数量是一个随机变量 $N$，服从均值为 $\\lambda$ 的泊松分布，记为 $N \\sim \\mathrm{Poisson}(\\lambda)$。每个分子都被一个从脱氧核糖核酸字母表 $\\{A, C, G, T\\}$ 中独立均匀采样的长度为 $L$ 的 UMI 标记，因此 UMI 标签空间的大小为 $M = 4^L$。被分配相同 UMI 标签的多个分子在扩增和测序后将无法区分，因此观测到的独特 UMI 数量等于 $N$ 个分子所占据的不同标签的数量。假设 UMI 在各分子间的分配是均匀且独立的，并且 $N$ 与标记过程无关。\n\n仅从泊松分布的基本定义和已充分验证的结论出发（您可以使用以下结论：如果 $N \\sim \\mathrm{Poisson}(\\lambda)$，并且这 $N$ 个项目中的每一项都以相等的概率 $1/M$ 被独立地分配到 $M$ 个类别中的一个，那么每个类别中的项目数量是独立的，且服从 $\\mathrm{Poisson}(\\lambda/M)$ 分布），推导观测到的独特 UMI 期望数量关于 $\\lambda$ 和 $L$ 的函数 $\\mathbb{E}[U \\mid \\lambda, L]$ 的精确闭式表达式。您的推导必须纯粹基于第一性原理，使用泊松分布的有效性质和期望的线性性，不得引用任何简化的占有公式。\n\n然后，实现一个程序，该程序：\n- 计算 $M = 4^L$。\n- 根据您推导的表达式计算精确期望值 $\\mathbb{E}[U \\mid \\lambda, L]$。\n- 使用一种数值稳定的评估策略，该策略适用于 $\\lambda/M$ 值极大和极小的情况。\n- 按顺序处理以下 $(L,\\lambda)$ 对的测试套件，并输出每个测试对的结果：\n  1. $(L,\\lambda) = (0, 3.5)$\n  2. $(L,\\lambda) = (2, 1.0)$\n  3. $(L,\\lambda) = (6, 5000.0)$\n  4. $(L,\\lambda) = (8, 1000000.0)$\n  5. $(L,\\lambda) = (12, 100000.0)$\n  6. $(L,\\lambda) = (4, 0.0)$\n\n所有输出均为实数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个值都四舍五入到小数点后六位（例如，$[0.123456,2.000000,15.500000]$）。不应打印任何其他文本。不涉及任何物理单位或角度单位，任何分数值都必须按规定以小数形式表示。程序必须是完全确定性的，并且不需要任何输入。", "solution": "该问题要求在特定生成模型下，推导独特分子标识符 (UMI) 期望数量 $\\mathbb{E}[U \\mid \\lambda, L]$ 的精确闭式表达式。该模型假设捕获的 cDNA 分子数量 $N$ 服从均值为 $\\lambda$ 的泊松分布，记为 $N \\sim \\mathrm{Poisson}(\\lambda)$。这 $N$ 个分子中的每一个都被一个从字母表 $\\{A, C, G, T\\}$ 中独立采样的长度为 $L$ 的 UMI 标记。因此，可能的 UMI 总数为 $M = 4^L$。分配是均匀且独立的。\n\n令 $U$ 为观测到的独特 UMI 数量的随机变量。这是 $N$ 个分子集合中存在的不同 UMI 标签的数量。为了推导 $U$ 的期望 $\\mathbb{E}[U]$，我们可以使用期望的线性性原理。\n\n我们为 $M$ 个可能的 UMI 标签中的每一个定义一个指示随机变量集合 $\\{I_i\\}_{i=1}^{M}$。指示变量 $I_i$ 定义如下：\n$$\nI_i =\n\\begin{cases}\n1  \\text{如果 UMI 标签 } i \\text{ 被分配给至少一个分子} \\\\\n0  \\text{如果 UMI 标签 } i \\text{ 未被分配给任何分子}\n\\end{cases}\n$$\n独特 UMI 的总数 $U$ 是这些指示变量在所有可能的 UMI 标签上的总和：\n$$U = \\sum_{i=1}^{M} I_i$$\n根据期望的线性性， $U$ 的期望值是各个指示变量期望值的总和：\n$$\\mathbb{E}[U] = \\mathbb{E}\\left[\\sum_{i=1}^{M} I_i\\right] = \\sum_{i=1}^{M} \\mathbb{E}[I_i]$$\n指示变量的期望等于它所指示事件的概率。因此，$\\mathbb{E}[I_i] = P(I_i = 1)$。\n$$\\mathbb{E}[U] = \\sum_{i=1}^{M} P(I_i = 1)$$\n由于每个分子的 UMI 是从 $M$ 种可能性中均匀且独立地选择的，因此任何特定 UMI 标签 $i$ 被使用的概率对于所有 $i$ 都是相同的。因此，我们可以简化这个和：\n$$\\mathbb{E}[U] = M \\cdot P(I_1 = 1)$$\n其中 $P(I_1 = 1)$ 是第一个 UMI 标签至少被使用一次的概率。计算其互补事件的概率 $P(I_1 = 0)$ 通常更容易，即 UMI 标签 1 从未被使用的概率。\n$$P(I_1 = 1) = 1 - P(I_1 = 0)$$\n将此代入我们关于 $\\mathbb{E}[U]$ 的表达式中，得到：\n$$\\mathbb{E}[U] = M \\cdot (1 - P(I_1 = 0))$$\n为了求得 $P(I_1 = 0)$，我们必须确定没有分子被分配到 UMI 标签 1 的概率。令 $N_i$ 为分配给 UMI 标签 $i$ 的分子数量的随机变量。事件 $I_1 = 0$ 等价于事件 $N_1 = 0$。\n\n问题陈述了泊松分布的一个关键性质：如果项目总数 $N$ 是一个均值为 $\\lambda$ 的泊松随机变量，即 $N \\sim \\mathrm{Poisson}(\\lambda)$，并且这 $N$ 个项目中的每一项都以相等的概率 $1/M$ 被独立地分配到 $M$ 个类别中的一个，那么任何给定类别 $i$ 中的项目数量 $N_i$ 是一个独立的、均值为 $\\lambda/M$ 的泊松随机变量。这被称为泊松分裂或稀疏性质。\n\n将此性质应用于我们的问题，分配给 UMI 标签 1 的分子数量 $N_1$ 服从均值为 $\\lambda/M$ 的泊松分布：\n$$N_1 \\sim \\mathrm{Poisson}(\\lambda/M)$$\n均值为 $\\mu$ 的泊松分布的概率质量函数由 $P(k; \\mu) = \\frac{e^{-\\mu}\\mu^k}{k!}$ 给出。我们需要求出 $N_1 = 0$ 的概率。使用均值为 $\\mu = \\lambda/M$ 且 $k=0$ 的概率质量函数：\n$$P(N_1 = 0) = \\frac{e^{-\\lambda/M}(\\lambda/M)^0}{0!} = e^{-\\lambda/M}$$\n这给出了特定 UMI 未被使用的概率。将此代回 $\\mathbb{E}[U]$ 的表达式中：\n$$\\mathbb{E}[U] = M \\cdot (1 - e^{-\\lambda/M})$$\n考虑到 $M = 4^L$，独特 UMI 期望数量作为 $\\lambda$ 和 $L$ 的函数的最终精确闭式表达式为：\n$$\\mathbb{E}[U \\mid \\lambda, L] = 4^L \\left(1 - e^{-\\lambda/4^L}\\right)$$\n至此，基于第一性原理的推导完成。\n\n对于数值实现，当 $x = \\lambda/M$ 非常小时，计算表达式 $1 - e^{-x}$ 可能会因灾难性抵消而出错。在这种情况下，$e^{-x}$ 非常接近 1，减法会损失大量有效精度。一种数值稳定的方法是使用 `expm1` 函数，该函数可以为较小的 $y$ 精确计算 $e^y - 1$。该项可以重写为 $1 - e^{-x} = -(e^{-x} - 1) = -\\mathrm{expm1}(-x)$。这确保了对于所有 $\\lambda/M$ 值都能进行精确计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected number of unique UMIs for a given set of parameters.\n    The derivation shows the expected number of unique UMIs E[U] is M * (1 - exp(-lambda/M)),\n    where M = 4^L.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, lambda)\n        (0, 3.5),\n        (2, 1.0),\n        (6, 5000.0),\n        (8, 1000000.0),\n        (12, 100000.0),\n        (4, 0.0),\n    ]\n\n    results = []\n    for L, lambd in test_cases:\n        # Calculate M = 4^L, the size of the UMI label space.\n        # L must be an integer, so we ensure it is treated as such for the power.\n        M = 4.0**float(L)\n\n        # The case lambda = 0 is trivial: if there are no molecules, there are no UMIs.\n        if lambd == 0.0:\n            expected_U = 0.0\n        else:\n            # The argument for the exponential function.\n            x = lambd / M\n\n            # We use the numerically stable np.expm1 function to calculate 1 - exp(-x).\n            # 1 - exp(-x) = - (exp(-x) - 1) = -expm1(-x).\n            # This avoids catastrophic cancellation when x is close to 0.\n            one_minus_exp_term = -np.expm1(-x)\n            \n            expected_U = M * one_minus_exp_term\n        \n        results.append(expected_U)\n\n    # Format the final results into a single string as specified.\n    # Each value is rounded to exactly six digits after the decimal point.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3348560"}, {"introduction": "在基于液滴的scRNA-seq技术中，一个主要挑战是来自细胞悬液中“环境RNA”（ambient RNA）的污染，这会在所有细胞中产生背景噪声。本实践 [@problem_id:3348555] 介绍了一个针对此类污染的标准模型，并要求您实现一种去污染算法。通过从观测计数中减去预期的环境RNA贡献，您将学会如何清洗数据，并直接评估一个关键生物学指标——标记基因特异性（marker gene specificity）——是否因此得到改善。", "problem": "给定一个单细胞RNA测序 (scRNA-seq) 的场景，其中每个细胞中每个基因观测到的唯一分子标识符 (UMI) 计数受到环境RNA污染的影响。一个普遍接受的生成模型观点是，观测到的计数来自于对细胞内源表达谱和环境表达谱混合物的采样。假设有 $n$ 个细胞和 $G$ 个基因。对于每个细胞 $i \\in \\{1,\\dots,n\\}$ 和每个基因 $g \\in \\{1,\\dots,G\\}$，将观测计数定义为 $N_{ig} \\in \\mathbb{N}_0$。设 $\\mathbf{a} \\in \\mathbb{R}_{\\ge 0}^{G}$ 是一个关于基因的非负环境表达谱，代表了环境分子的分布；并设 $c_i \\in [0,1]$ 表示细胞 $i$ 的污染分数，代表了可归因于环境污染的计数的期望比例。环境表达谱必须满足 $\\sum_{g=1}^{G} a_g = 1$；如果不满足，则应进行归一化。\n\n基本原理。在采用唯一分子标识符 (UMI) 计数的scRNA-seq中，一个经过充分检验的模型将计数视为采样产生，其中细胞 $i$ 的期望观测计数向量是其内源表达谱和环境表达谱的凸混合。具体来说，如果 $T_i = \\sum_{g=1}^{G} N_{ig}$ 表示细胞 $i$ 中的总观测计数，那么细胞 $i$ 中每个基因的期望环境归因计数与 $c_i T_i$ 成正比，并根据 $\\mathbf{a}$ 分布在各个基因上，这反映了环境污染会按照环境分布增加计数这一事实。真实的、去污染后的计数应该移除环境归因部分，同时要保证计数的非负性。\n\n标记基因特异性。假设每个细胞 $i$ 被赋予一个来自有限细胞类型集合 $\\mathcal{Y}$ 的标签 $y_i$，并且对于每种类型 $y \\in \\mathcal{Y}$，存在一个标记基因集 $\\mathcal{S}(y) \\subseteq \\{1,\\dots,G\\}$。在计数矩阵 $\\mathbf{X} \\in \\mathbb{R}_{\\ge 0}^{n \\times G}$ 下，细胞 $i$ 的标记基因特异性定义为其总计数中落在 $\\mathcal{S}(y_i)$ 内的比例：\n$$\ns_i(\\mathbf{X}) \\;=\\; \n\\begin{cases}\n\\dfrac{\\sum_{g \\in \\mathcal{S}(y_i)} X_{ig}}{\\sum_{g=1}^{G} X_{ig}}  \\text{if } \\sum_{g=1}^{G} X_{ig} > 0, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n为了评估去污染对标记基因特异性的影响，需要比较去污染前后所有细胞的平均特异性，即计算\n$$\n\\Delta \\;=\\; \\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{D}) \\;-\\; \\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{N}),\n$$\n其中 $\\mathbf{N}$ 是观测计数，$\\mathbf{D}$ 是去污染后的计数。\n\n任务。从上述基本混合模型观点出发，设计并实现一个程序，该程序：\n- 基于 $\\mathbf{a}$、$c_i$ 和 $T_i$ 推导出一个非负的去污染算子，该算子移除每个细胞中每个基因的期望环境归因计数，从而得到一个去污染后的计数矩阵 $\\mathbf{D}$。\n- 针对每个测试用例，计算 $\\mathbf{N}$ 和 $\\mathbf{D}$ 之间的平均标记基因特异性改善值 $\\Delta$。\n\n您的算法必须满足以下约束条件：\n- 如果环境表达谱 $\\mathbf{a}$ 的总和不为 $1$，则必须将其归一化。\n- 每个基因去污染后的计数必须为非负；如果减法操作导致负值，则必须将其截断为 $0$。\n- 如果一个细胞去污染后的总计数为 $0$，其特异性必须定义为 $0$。\n- 如果一个细胞类型的标记基因集为空，则该细胞对特异性的贡献为 $0$。\n\n测试套件。为以下参数集实现您的解决方案。每个测试用例都指定了观测计数矩阵 $\\mathbf{N}^{(k)}$、环境表达谱 $\\mathbf{a}^{(k)}$、各细胞的污染分数 $\\mathbf{c}^{(k)}$、细胞标签 $\\mathbf{y}^{(k)}$ 和标记基因集 $\\mathcal{S}^{(k)}$。标记基因集中的所有基因索引都是从0开始的。\n\n测试用例 1 (理想路径，中度污染):\n- $n = 3$, $G = 5$,\n- $\\mathbf{N}^{(1)} = \\begin{bmatrix}\n12  8  1  3  0 \\\\\n2  4  15  0  1 \\\\\n0  1  0  20  5\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(1)} = \\begin{bmatrix} 0.25  0.25  0.2  0.2  0.1 \\end{bmatrix}$,\n- $\\mathbf{c}^{(1)} = \\begin{bmatrix} 0.2  0.3  0.15 \\end{bmatrix}$,\n- $\\mathbf{y}^{(1)} = \\begin{bmatrix} \\text{A}  \\text{B}  \\text{C} \\end{bmatrix}$,\n- $\\mathcal{S}^{(1)}(\\text{A}) = \\{0,1\\}$, $\\mathcal{S}^{(1)}(\\text{B}) = \\{2\\}$, $\\mathcal{S}^{(1)}(\\text{C}) = \\{3\\}$.\n\n测试用例 2 (边界条件，零污染):\n- $n = 2$, $G = 4$,\n- $\\mathbf{N}^{(2)} = \\begin{bmatrix}\n5  0  0  5 \\\\\n0  10  0  0\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(2)} = \\begin{bmatrix} 0.4  0.1  0.4  0.1 \\end{bmatrix}$,\n- $\\mathbf{c}^{(2)} = \\begin{bmatrix} 0  0 \\end{bmatrix}$,\n- $\\mathbf{y}^{(2)} = \\begin{bmatrix} \\text{C}  \\text{A} \\end{bmatrix}$,\n- $\\mathcal{S}^{(2)}(\\text{A}) = \\{1\\}$, $\\mathcal{S}^{(2)}(\\text{C}) = \\{3\\}$.\n\n测试用例 3 (边缘情况，高污染和截断):\n- $n = 2$, $G = 4$,\n- $\\mathbf{N}^{(3)} = \\begin{bmatrix}\n3  1  0  0 \\\\\n1  0  2  0\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(3)} = \\begin{bmatrix} 0.7  0.2  0.1  0.0 \\end{bmatrix}$,\n- $\\mathbf{c}^{(3)} = \\begin{bmatrix} 0.95  0.8 \\end{bmatrix}$,\n- $\\mathbf{y}^{(3)} = \\begin{bmatrix} \\text{A}  \\text{B} \\end{bmatrix}$,\n- $\\mathcal{S}^{(3)}(\\text{A}) = \\{0\\}$, $\\mathcal{S}^{(3)}(\\text{B}) = \\{2\\}$.\n\n测试用例 4 (边缘情况，去污染后总计数消失):\n- $n = 1$, $G = 3$,\n- $\\mathbf{N}^{(4)} = \\begin{bmatrix}\n1  0  0\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(4)} = \\begin{bmatrix} 0.6  0.3  0.1 \\end{bmatrix}$,\n- $\\mathbf{c}^{(4)} = \\begin{bmatrix} 1.0 \\end{bmatrix}$,\n- $\\mathbf{y}^{(4)} = \\begin{bmatrix} \\text{A} \\end{bmatrix}$,\n- $\\mathcal{S}^{(4)}(\\text{A}) = \\{0\\}$.\n\n测试用例 5 (边缘情况，一个标签的标记基因集为空):\n- $n = 2$, $G = 3$,\n- $\\mathbf{N}^{(5)} = \\begin{bmatrix}\n10  5  0 \\\\\n0  0  8\n\\end{bmatrix}$,\n- $\\mathbf{a}^{(5)} = \\begin{bmatrix} 0.2  0.2  0.6 \\end{bmatrix}$,\n- $\\mathbf{c}^{(5)} = \\begin{bmatrix} 0.2  0.4 \\end{bmatrix}$,\n- $\\mathbf{y}^{(5)} = \\begin{bmatrix} \\text{D}  \\text{B} \\end{bmatrix}$,\n- $\\mathcal{S}^{(5)}(\\text{D}) = \\varnothing$, $\\mathcal{S}^{(5)}(\\text{B}) = \\{2\\}$.\n\n最终输出格式。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是浮点数 $\\Delta$，四舍五入到六位小数。例如，输出应类似于 $[\\delta_1,\\delta_2,\\dots,\\delta_5]$，其中每个 $\\delta_k$ 是一个有六位小数的十进制数。不应打印任何其他文本。", "solution": "该问题是有效的。它在科学上基于单细胞RNA测序中环境RNA污染的既定模型，问题陈述清晰，定义和约束明确，并且表达客观。所有必要的参数和条件都已提供，足以推导出唯一且有意义的解决方案。\n\n解决方案分三个阶段展开：首先，从给定的生成模型推导出去污染算子；其次，形式化标记基因特异性指标；第三，阐明计算平均标记基因特异性变化 $\\Delta$ 的完整算法。\n\n**1. 去污染算子的推导**\n\n问题假设了一个生成模型，其中 $n$ 个细胞和 $G$ 个基因的观测UMI计数 $\\mathbf{N} \\in \\mathbb{N}_0^{n \\times G}$ 是真实细胞计数和环境RNA计数的混合物。环境RNA的贡献由一个环境表达谱 $\\mathbf{a} \\in \\mathbb{R}_{\\ge 0}^{G}$（一个在基因上的概率分布，$\\sum_{g=1}^{G} a_g = 1$）和每个细胞的污染分数 $c_i \\in [0,1]$ 定义。\n\n对于每个细胞 $i$，总观测UMI计数为 $T_i = \\sum_{g=1}^{G} N_{ig}$。污染分数 $c_i$ 代表了这些总计数中源自环境池的期望比例。因此，细胞 $i$ 中期望的环境计数总数为 $c_i T_i$。\n\n这些环境计数根据环境表达谱 $\\mathbf{a}$ 分布在 $G$ 个基因上。细胞 $i$ 中特定基因 $g$ 的期望环境计数（表示为 $A_{ig}$）是该细胞的总期望环境计数乘以基因 $g$ 在环境表达谱中的相对频率 $a_g$。\n$$\nE[A_{ig}] = (c_i T_i) a_g\n$$\n去污染的目标是通过从观测计数 $N_{ig}$ 中移除这个期望的环境部分来估计真实的、细胞内源的计数。设 $\\mathbf{D} \\in \\mathbb{R}_{\\ge 0}^{n \\times G}$ 为去污染后的计数矩阵。元素 $D_{ig}$ 通过从观测计数中减去期望的环境计数得到：\n$$\nD_{ig} = N_{ig} - c_i T_i a_g\n$$\n一个关键约束是计数必须为非负。如果减法操作得到一个负值（当观测计数 $N_{ig}$ 由于采样噪声而低于期望的环境贡献时，可能会发生这种情况），该值必须在 $0$ 处截断。这导出了去污染算子的最终形式：\n$$\nD_{ig} = \\max(0, N_{ig} - c_i T_i a_g)\n$$\n此操作应用于每个细胞中的每个基因，以生成完整的去污染矩阵 $\\mathbf{D}$。\n\n**2. 标记基因特异性**\n\n细胞 $i$ 的标记基因特异性被定义为其总UMI计数中归属于其指定细胞类型 $y_i$ 的标记基因集 $\\mathcal{S}(y_i)$ 的部分。对于一个通用的计数矩阵 $\\mathbf{X} \\in \\mathbb{R}_{\\ge 0}^{n \\times G}$，其特异性 $s_i(\\mathbf{X})$ 为：\n$$\ns_i(\\mathbf{X}) \\;=\\; \n\\begin{cases}\n\\dfrac{\\sum_{g \\in \\mathcal{S}(y_i)} X_{ig}}{\\sum_{g=1}^{G} X_{ig}}  \\text{if } \\sum_{g=1}^{G} X_{ig} > 0 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n此公式同时适用于观测计数矩阵 $\\mathbf{N}$ 和去污染后的计数矩阵 $\\mathbf{D}$。问题还规定，如果标记基因集 $\\mathcal{S}(y_i)$ 为空，则分子为 $0$，因此 $s_i(\\mathbf{X}) = 0$。总体的质量指标是去污染后所有 $n$ 个细胞的平均特异性变化：\n$$\n\\Delta \\;=\\; \\bar{s}(\\mathbf{D}) - \\bar{s}(\\mathbf{N}) \\;=\\; \\left(\\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{D})\\right) \\;-\\; \\left(\\dfrac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{N})\\right)\n$$\n\n**3. 计算特异性改善值 $\\Delta$ 的算法**\n\n对于一个给定的测试用例（$\\mathbf{N}, \\mathbf{a}, \\mathbf{c}, \\mathbf{y}, \\mathcal{S}$），完整的算法如下：\n\n1.  **归一化环境表达谱**：检查是否 $\\sum_{g=1}^{G} a_g = 1$。若否，则将 $\\mathbf{a}$ 除以其总和进行归一化。令归一化后的表达谱为 $\\mathbf{a}'$。\n    $$\n    \\mathbf{a}' = \\dfrac{\\mathbf{a}}{\\sum_{g=1}^{G} a_g}\n    $$\n2.  **计算观测计数的平均特异性**：\n    a. 对每个细胞 $i=1, \\dots, n$，计算总观测计数 $T_i = \\sum_{g=1}^{G} N_{ig}$。\n    b. 对每个细胞 $i$，使用公式、其标签 $y_i$ 和相应的标记基因集 $\\mathcal{S}(y_i)$ 计算其特异性 $s_i(\\mathbf{N})$。处理 $T_i=0$ 或 $\\mathcal{S}(y_i)$ 为空的情况。\n    c. 计算平均观测特异性 $\\bar{s}(\\mathbf{N}) = \\frac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{N})$。\n\n3.  **执行去污染**：\n    a. 对每个细胞 $i=1, \\dots, n$，使用上面推导的算子计算去污染后的计数向量 $\\mathbf{D}_{i,:}$：\n       $$\n       D_{ig} = \\max(0, N_{ig} - c_i T_i a'_g) \\quad \\text{for } g=1, \\dots, G\n       $$\n    b. 这些向量构成了去污染后的矩阵 $\\mathbf{D}$。\n\n4.  **计算去污染后计数的平均特异性**：\n    a. 对每个细胞 $i=1, \\dots, n$，计算去污染后的总计数 $T'_i = \\sum_{g=1}^{G} D_{ig}$。\n    b. 对每个细胞 $i$，使用公式计算其去污染后的特异性 $s_i(\\mathbf{D})$，其中 $T'_i=0$ 会导致 $s_i(\\mathbf{D})=0$。\n    c. 计算平均去污染后特异性 $\\bar{s}(\\mathbf{D}) = \\frac{1}{n} \\sum_{i=1}^{n} s_i(\\mathbf{D})$。\n\n5.  **计算最终指标**：计算差值 $\\Delta = \\bar{s}(\\mathbf{D}) - \\bar{s}(\\mathbf{N})$。结果按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": np.array([[12, 8, 1, 3, 0], [2, 4, 15, 0, 1], [0, 1, 0, 20, 5]]),\n            \"a\": np.array([0.25, 0.25, 0.2, 0.2, 0.1]),\n            \"c\": np.array([0.2, 0.3, 0.15]),\n            \"y\": ['A', 'B', 'C'],\n            \"S\": {'A': {0, 1}, 'B': {2}, 'C': {3}}\n        },\n        {\n            \"N\": np.array([[5, 0, 0, 5], [0, 10, 0, 0]]),\n            \"a\": np.array([0.4, 0.1, 0.4, 0.1]),\n            \"c\": np.array([0.0, 0.0]),\n            \"y\": ['C', 'A'],\n            \"S\": {'A': {1}, 'C': {3}}\n        },\n        {\n            \"N\": np.array([[3, 1, 0, 0], [1, 0, 2, 0]]),\n            \"a\": np.array([0.7, 0.2, 0.1, 0.0]),\n            \"c\": np.array([0.95, 0.8]),\n            \"y\": ['A', 'B'],\n            \"S\": {'A': {0}, 'B': {2}}\n        },\n        {\n            \"N\": np.array([[1, 0, 0]]),\n            \"a\": np.array([0.6, 0.3, 0.1]),\n            \"c\": np.array([1.0]),\n            \"y\": ['A'],\n            \"S\": {'A': {0}}\n        },\n        {\n            \"N\": np.array([[10, 5, 0], [0, 0, 8]]),\n            \"a\": np.array([0.2, 0.2, 0.6]),\n            \"c\": np.array([0.2, 0.4]),\n            \"y\": ['D', 'B'],\n            \"S\": {'D': set(), 'B': {2}}\n        }\n    ]\n\n    results = []\n\n    def calculate_mean_specificity(X, y_labels, marker_sets):\n        \"\"\"\n        Helper function to calculate the mean marker specificity for a count matrix.\n        \"\"\"\n        n, _ = X.shape\n        total_specificity = 0.0\n        for i in range(n):\n            total_counts_i = np.sum(X[i, :])\n            if total_counts_i == 0:\n                specificity_i = 0.0\n            else:\n                cell_type = y_labels[i]\n                marker_genes = marker_sets.get(cell_type, set())\n                if not marker_genes:\n                    specificity_i = 0.0\n                else:\n                    marker_indices = list(marker_genes)\n                    marker_counts = np.sum(X[i, marker_indices])\n                    specificity_i = marker_counts / total_counts_i\n            total_specificity += specificity_i\n        return total_specificity / n\n\n    for case in test_cases:\n        N, a, c, y, S = case[\"N\"], case[\"a\"], case[\"c\"], case[\"y\"], case[\"S\"]\n        \n        # Step 1: Normalize ambient profile 'a' if necessary\n        a_sum = np.sum(a)\n        if not np.isclose(a_sum, 1.0):\n            a = a / a_sum\n\n        # Step 2: Calculate mean specificity for observed counts N\n        mean_specificity_N = calculate_mean_specificity(N, y, S)\n\n        # Step 3: Perform decontamination\n        # Calculate total observed counts per cell\n        T = np.sum(N, axis=1)\n        \n        # Calculate the expected ambient counts to subtract for each cell and gene.\n        # This requires broadcasting:\n        # c (n,1) * T (n,1) * a (1,G) -> (n,G)\n        ambient_subtraction_matrix = c.reshape(-1, 1) * T.reshape(-1, 1) * a.reshape(1, -1)\n\n        # Decontaminate by subtracting and clipping at 0\n        D = np.maximum(0, N - ambient_subtraction_matrix)\n\n        # Step 4: Calculate mean specificity for decontaminated counts D\n        mean_specificity_D = calculate_mean_specificity(D, y, S)\n        \n        # Step 5: Compute the final metric delta\n        delta = mean_specificity_D - mean_specificity_N\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3348555"}, {"introduction": "scRNA-seq分析的一个主要目标是揭示细胞异质性，而这主要是由具有高度生物学变异的基因所驱动的。本练习 [@problem_id:3348549] 聚焦于一项核心任务：通过建模基因平均表达量与其方差之间的关系来识别这些高变基因（Highly Variable Genes, HVGs）。您将实现一种标准方法，用于区分真实的生物学变异和技术噪声，并比较不同的基因表达统计模型如何影响最终的筛选结果。", "problem": "给定每个数据集的标准化计数矩阵和一个拟合的均值-方差曲线。您的任务是，在泊松模型和负二项模型这两种噪声模型下，通过编程计算高变异基因（HVG），并比较所选出的基因。您的程序必须严格遵循下述定义和步骤，并生成一个单行输出，该输出汇总了所有给定测试用例的结果。\n\n定义和所需计算：\n- 令 $X \\in \\mathbb{R}^{n \\times p}$ 表示一个标准化计数矩阵，其中有 $n$ 个细胞（行）和 $p$ 个基因（列）。\n- 对于每个基因 $g \\in \\{0,1,\\dots,p-1\\}$，计算其在所有细胞中的样本均值\n  $$\\bar{x}_g \\equiv \\frac{1}{n} \\sum_{i=1}^{n} x_{ig},$$\n  和无偏样本方差\n  $$s_g^2 \\equiv \\frac{1}{n-1} \\sum_{i=1}^{n} \\left(x_{ig} - \\bar{x}_g\\right)^2.$$\n- 一个拟合的均值-方差曲线以二次函数的形式给出\n  $$\\hat{v}_{\\text{trend}}(m) = a + b\\,m + c\\,m^2,$$\n  每个数据集都有给定的系数 $a$、 $b$ 和 $c$。\n- 在泊松噪声模型下，方差-均值关系为 $v_{\\text{P}}(m) = m$。定义模型约束的期望方差为\n  $$E_{\\text{P}}(m) \\equiv \\max\\left( \\hat{v}_{\\text{trend}}(m), \\, v_{\\text{P}}(m) \\right) = \\max\\left( a + b\\,m + c\\,m^2,\\, m \\right).$$\n- 在离散参数为 $\\alpha  0$ 的负二项噪声模型下，方差-均值关系为 $v_{\\text{NB}}(m) = m + \\alpha\\,m^2$。定义模型约束的期望方差为\n  $$E_{\\text{NB}}(m) \\equiv \\max\\left( \\hat{v}_{\\text{trend}}(m), \\, v_{\\text{NB}}(m) \\right) = \\max\\left( a + b\\,m + c\\,m^2,\\, m + \\alpha\\,m^2 \\right).$$\n- 为了数值稳定性，当除以一个期望方差时，使用一个小的常数 $\\varepsilon = 10^{-8}$ 来避免除以零，方法是将任何分母 $d$ 替换为 $\\max(d, \\varepsilon)$。\n- 定义每个基因 $g$ 在某个模型下的标准化残差离散度为\n  $$r_g^{(\\cdot)} \\equiv \\frac{s_g^2 - E_{(\\cdot)}(\\bar{x}_g)}{\\max\\left( E_{(\\cdot)}(\\bar{x}_g), \\, \\varepsilon \\right)},$$\n  其中 $(\\cdot) \\in \\{\\text{P}, \\text{NB}\\}$ 表示所使用的模型。\n- 给定模型的HVG选择规则：在残差严格为正 ($r_g^{(\\cdot)}  0$) 的基因中，按 $r_g^{(\\cdot)}$ 的降序选择前 $K$ 个基因的索引。如果残差严格为正的基因少于 $K$ 个，则返回所有这些基因。处理平局情况的规则如下：\n  $1)$ 按较大的 $\\bar{x}_g$ （降序）排序，\n  $2)$ 按较小的基因索引 $g$ （升序）排序。\n- 所有基因索引均为从0开始的整数。\n\n测试套件：\n对于每个测试用例 $t \\in \\{1,2,3,4\\}$，您会得到一个矩阵 $X^{(t)}$、系数 $(a^{(t)}, b^{(t)}, c^{(t)})$、一个负二项离散参数 $\\alpha^{(t)}$ 和一个目标数量 $K^{(t)}$。您的程序必须为每个测试 $t$ 计算并返回一个包含两个列表的对：第一个列表是泊松模型下的HVG索引，第二个列表是负二项模型下的HVG索引。\n\n- 测试用例 $1$：\n  - $X^{(1)}$ 有 $n=5$ 行和 $p=6$ 列，各行为\n    $[2, 0, 3, 1, 10, 5]$,\n    $[3, 0, 4, 1, 11, 6]$,\n    $[2, 0, 8, 1, 9, 5]$,\n    $[3, 0, 2, 1, 12, 4]$,\n    $[2, 0, 5, 1, 8, 5]$。\n  - $(a^{(1)}, b^{(1)}, c^{(1)}) = (0.2, 0.7, 0.02)$。\n  - $\\alpha^{(1)} = 0.1$。\n  - $K^{(1)} = 3$。\n\n- 测试用例 $2$：\n  - $X^{(2)}$ 有 $n=4$ 行和 $p=4$ 列，各行为\n    $[0, 0, 0, 10]$,\n    $[0, 0, 0, 10]$,\n    $[0, 0, 0, 10]$,\n    $[0, 0, 0, 11]$。\n  - $(a^{(2)}, b^{(2)}, c^{(2)}) = (0.1, 0.1, 0.01)$。\n  - $\\alpha^{(2)} = 0.05$。\n  - $K^{(2)} = 2$。\n\n- 测试用例 $3$：\n  - $X^{(3)}$ 有 $n=5$ 行和 $p=4$ 列，各行为\n    $[0, 5, 0, 1]$,\n    $[0, 5, 0, 1]$,\n    $[0, 5, 50, 1]$,\n    $[0, 5, 0, 1]$,\n    $[0, 5, 0, 1]$。\n  - $(a^{(3)}, b^{(3)}, c^{(3)}) = (0.1, 0.2, 0.0)$。\n  - $\\alpha^{(3)} = 0.1$。\n  - $K^{(3)} = 1$。\n\n- 测试用例 $4$：\n  - $X^{(4)}$ 有 $n=4$ 行和 $p=3$ 列，各行为\n    $[5, 10, 0]$,\n    $[7, 10, 5]$,\n    $[6, 10, 0]$,\n    $[8, 10, 5]$。\n  - $(a^{(4)}, b^{(4)}, c^{(4)}) = (0.1, 0.5, 0.0)$。\n  - $\\alpha^{(4)} = 1.0$。\n  - $K^{(4)} = 2$。\n\n最终输出格式：\n- 您的程序应生成一个单行输出，其中包含一个列表，列表中的每个条目对应一个测试用例，按 $t=1,2,3,4$ 的顺序排列。\n- 每个条目必须是一个包含两个元素的列表：第一个元素是泊松模型下的HVG索引列表，第二个元素是负二项模型下的HVG索引列表。\n- 整个输出必须打印在单一行上，使用逗号分隔且无空格，例如：\n  $$\\texttt{[[[i\\_P\\_1,i\\_P\\_2],[i\\_NB\\_1]],[[\\dots],[\\dots]],[[\\dots],[\\dots]],[[\\dots],[\\dots]]]}$$\n其中 $i\\_P\\_\\cdot$ 和 $i\\_{NB}\\_\\cdot$ 是整数。如果列表为空，则必须打印为 $\\texttt{[]}$。您的程序不得打印任何其他文本。", "solution": "该问题要求使用两种不同的统计噪声模型——泊松模型和负二项模型，从标准化的单细胞RNA测序（scRNA-seq）计数数据中识别高变异基因（HVG）。该过程是生物信息学中一个明确定义的标准计算工作流程，旨在区分具有显著生物学变异的基因与那些观测到的方差与测序过程中固有的统计噪声相一致的基因。\n\n其基本原理是分析基因表达计数的均值-方差关系。对于计数数据，一个基因在细胞间表达的方差与其平均表达水平内在地相关联。我们将系统地计算每个基因的统计数据，基于均值对期望方差进行建模，然后识别出那些观测方差显著超过此期望的基因。\n\n算法步骤如下：\n\n1.  **逐基因统计数据计算**：对于每个数据集（以一个大小为 $n \\times p$ 的标准化计数矩阵 $X$ 表示，其中 $n$ 是细胞数，$p$ 是基因数），我们首先为每个基因 $g$ 计算两个基本统计量：\n    -   样本均值表达量, $\\bar{x}_g = \\frac{1}{n} \\sum_{i=1}^{n} x_{ig}$。\n    -   无偏样本方差表达量, $s_g^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_{ig} - \\bar{x}_g)^2$。\n    这些计算是针对 $p$ 个基因中的每一个，在 $n$ 个细胞上进行的。\n\n2.  **期望方差建模**：HVG检测的核心在于将观测方差 $s_g^2$ 与一个从模型中派生出的期望方差进行比较。问题指定了两种这样的模型，并将它们与预先拟合的趋势相结合。\n\n    -   方差对均值的总体趋势由一个拟合的二次函数 $\\hat{v}_{\\text{trend}}(m) = a + b m + c m^2$ 捕获。这个趋势解释了数据中的系统性偏差和全局模式。\n\n    -   **泊松模型**：此模型假设平均表达量为 $m$ 的基因的计数遵循泊松分布，其方差等于均值。理论方差为 $v_{\\text{P}}(m) = m$。此模型下的期望方差 $E_{\\text{P}}(m)$ 定义为拟合趋势和理论泊松方差中的最大值：$E_{\\text{P}}(m) \\equiv \\max(\\hat{v}_{\\text{trend}}(m), v_{\\text{P}}(m))$。这种形式确保了期望方差至少与总体趋势和基本噪声模型的预测一样大。\n\n    -   **负二项（NB）模型**：NB分布是用于过度离散计数数据（scRNA-seq的典型特征）的更灵活模型。其方差是均值的二次函数：$v_{\\text{NB}}(m) = m + \\alpha m^2$，其中 $\\alpha  0$ 是离散参数。较大的 $\\alpha$ 表示更大的过度离散（方差远大于均值）。NB模型的期望方差定义类似：$E_{\\text{NB}}(m) \\equiv \\max(\\hat{v}_{\\text{trend}}(m), v_{\\text{NB}}(m))$。\n\n3.  **量化过度变异**：为了识别方差异常高的基因，我们为每个基因计算标准化残差离散度 $r_g$。该指标量化了观测方差 $s_g^2$ 与期望方差 $E_{(\\cdot)}(\\bar{x}_g)$ 的偏离程度，并由期望方差本身进行归一化。对于给定的模型 $(\\cdot) \\in \\{\\text{P}, \\text{NB}\\}$，其计算公式为：\n    $$r_g^{(\\cdot)} = \\frac{s_g^2 - E_{(\\cdot)}(\\bar{x}_g)}{\\max(E_{(\\cdot)}(\\bar{x}_g), \\varepsilon)}$$\n    在分母中使用一个小的常数 $\\varepsilon = 10^{-8}$ 以防止除以零，这对于期望方差为零或接近零的基因是必要的预防措施。正残差 $r_g^{(\\cdot)}  0$ 表明该基因的观测方差高于模型预期，暗示它可能是HVG的候选者。\n\n4.  **HVG选择与排序**：最后一步是根据基因的残差离散度值选择顶部的HVG。\n    -   首先，我们筛选基因，只保留那些具有严格正残差（$r_g^{(\\cdot)}  0$）的基因。\n    -   接下来，对这些候选基因进行排序。主要排序键是残差离散度 $r_g^{(\\cdot)}$（降序）。为确保唯一且确定性的排序，使用两个后续标准来处理平局情况：首先是按更高的平均表达量 $\\bar{x}_g$（降序），然后是按更小的基因索引 $g$（升序）。\n    -   最后，我们从此排序列表中选择前 $K$ 个基因的索引。如果具有正残差的基因数量少于 $K$，则选择所有这些基因。\n\n对于提供的每个测试用例，此过程会分别应用于泊松模型和负二项模型。实现将利用向量化操作来提高效率，从而同时计算所有基因的均值、方差和残差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final aggregated result.\n    \"\"\"\n    test_cases = [\n        {\n            \"X\": np.array([\n                [2, 0, 3, 1, 10, 5],\n                [3, 0, 4, 1, 11, 6],\n                [2, 0, 8, 1, 9, 5],\n                [3, 0, 2, 1, 12, 4],\n                [2, 0, 5, 1, 8, 5]\n            ], dtype=float),\n            \"coeffs\": (0.2, 0.7, 0.02),\n            \"alpha\": 0.1,\n            \"K\": 3\n        },\n        {\n            \"X\": np.array([\n                [0, 0, 0, 10],\n                [0, 0, 0, 10],\n                [0, 0, 0, 10],\n                [0, 0, 0, 11]\n            ], dtype=float),\n            \"coeffs\": (0.1, 0.1, 0.01),\n            \"alpha\": 0.05,\n            \"K\": 2\n        },\n        {\n            \"X\": np.array([\n                [0, 5, 0, 1],\n                [0, 5, 0, 1],\n                [0, 5, 50, 1],\n                [0, 5, 0, 1],\n                [0, 5, 0, 1]\n            ], dtype=float),\n            \"coeffs\": (0.1, 0.2, 0.0),\n            \"alpha\": 0.1,\n            \"K\": 1\n        },\n        {\n            \"X\": np.array([\n                [5, 10, 0],\n                [7, 10, 5],\n                [6, 10, 0],\n                [8, 10, 5]\n            ], dtype=float),\n            \"coeffs\": (0.1, 0.5, 0.0),\n            \"alpha\": 1.0,\n            \"K\": 2\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        hvg_p = compute_hvgs(case[\"X\"], case[\"coeffs\"], case[\"K\"], model='poisson')\n        hvg_nb = compute_hvgs(case[\"X\"], case[\"coeffs\"], case[\"K\"], model='neg_binomial', alpha=case[\"alpha\"])\n        results.append([hvg_p, hvg_nb])\n\n    # Format the final output string exactly as specified.\n    case_strings = []\n    for res_pair in results:\n        p_str = ','.join(map(str, res_pair[0]))\n        nb_str = ','.join(map(str, res_pair[1]))\n        case_strings.append(f'[[{p_str}],[{nb_str}]]')\n    \n    print(f\"[{','.join(case_strings)}]\")\n\ndef compute_hvgs(X, coeffs, K, model, alpha=None):\n    \"\"\"\n    Computes Highly Variable Genes (HVGs) for a given counts matrix and parameters.\n\n    Args:\n        X (np.ndarray): n x p normalized counts matrix.\n        coeffs (tuple): (a, b, c) coefficients for the mean-variance trend.\n        K (int): The number of top HVGs to select.\n        model (str): 'poisson' or 'neg_binomial'.\n        alpha (float, optional): Dispersion parameter for the NB model. Required if model is 'neg_binomial'.\n\n    Returns:\n        list: A list of 0-based integer indices of the selected HVGs.\n    \"\"\"\n    n, p = X.shape\n    if n  2:\n        return []\n\n    a, b, c = coeffs\n    epsilon = 1e-8\n\n    # Step 1: Compute per-gene sample mean and variance\n    means = np.mean(X, axis=0)\n    # ddof=1 for unbiased sample variance (1/(n-1))\n    variances = np.var(X, axis=0, ddof=1)\n\n    # Step 2: Compute expected variance based on the model\n    v_trend = a + b * means + c * means**2\n\n    if model == 'poisson':\n        v_model = means\n    elif model == 'neg_binomial':\n        if alpha is None:\n            raise ValueError(\"alpha must be provided for the Negative Binomial model.\")\n        v_model = means + alpha * means**2\n    else:\n        raise ValueError(\"Unknown model specified.\")\n\n    expected_variances = np.maximum(v_trend, v_model)\n\n    # Step 3: Compute standardized residual dispersion\n    denominators = np.maximum(expected_variances, epsilon)\n    residuals = (variances - expected_variances) / denominators\n\n    # Step 4: Filter, rank, and select HVGs\n    candidates = []\n    for g in range(p):\n        if residuals[g] > 0:\n            # Store (residual, mean, gene_index) for sorting\n            candidates.append((residuals[g], means[g], g))\n\n    # Sort based on the specified tie-breaking rules:\n    # 1. residual descending (reverse=True on item[0])\n    # 2. mean descending (reverse=True on item[1])\n    # 3. gene index ascending (reverse=False on item[2], so we use -item[2] with reverse=True)\n    candidates.sort(key=lambda item: (item[0], item[1], -item[2]), reverse=True)\n\n    # Select the top K gene indices\n    hvg_indices = [item[2] for item in candidates[:K]]\n    \n    return hvg_indices\n\nsolve()\n```", "id": "3348549"}]}