{"hands_on_practices": [{"introduction": "这项练习为在贝叶斯框架中对单细胞计数数据进行建模奠定了理论基础。通过推导 Gamma-Poisson 模型下基因表达率的后验分布，您将亲身体验共轭先验的作用，并了解我们最初的信念（先验）是如何通过观测数据（似然）更新，从而形成新的认识（后验）。这项基础练习 [@problem_id:3349825] 对于理解基因组学中更高级的概率模型至关重要。", "problem": "在单细胞RNA测序 (scRNA-seq) 中，每个基因的稀疏观测计数通常使用共轭伽马-泊松框架进行建模，该框架没有显式的零膨胀来反映技术性脱扣，从而将零归因于低的潜在表达率。考虑在索引为 $c$ 的单个细胞中，索引为 $g$ 的单个基因，其观测到的唯一分子标识符 (UMI) 计数为 $X_{gc} \\in \\{0,1,2,\\ldots\\}$。假设一个已知的、严格为正的暴露或大小因子 $s_{c} > 0$，它捕捉了测序深度和效率的差异。设基因 $g$ 在细胞 $c$ 中的潜表达率参数为 $\\theta_{gc} > 0$。\n\n假设以下模型组件：\n- 似然：$X_{gc} \\mid \\theta_{gc} \\sim \\mathrm{Poisson}(s_{c}\\,\\theta_{gc})$。\n- 先验：$\\theta_{gc} \\sim \\mathrm{Gamma}(a_{g}, b_{g})$，其中形状参数 $a_{g} > 0$ 且率参数 $b_{g} > 0$，其密度为 $p(\\theta_{gc}) = \\dfrac{b_{g}^{a_{g}}}{\\Gamma(a_{g})}\\,\\theta_{gc}^{a_{g}-1}\\exp(-b_{g}\\theta_{gc})$。\n\n从贝叶斯法则出发，并使用泊松概率质量函数和伽马概率密度函数的标准形式，推导在此共轭模型下的闭式后验分布 $p(\\theta_{gc}\\mid X_{gc})$。然后，计算并简化后验均值 $E[\\theta_{gc}\\mid X_{gc}]$ 和后验方差 $\\mathrm{Var}[\\theta_{gc}\\mid X_{gc}]$ 的闭式表达式，用 $a_{g}$、$b_{g}$、$s_{c}$ 和 $X_{gc}$ 表示。\n\n以解析表达式的形式提供最终答案。无需四舍五入。使用 $\\mathrm{pmatrix}$ 约定将多个量表示为单行矩阵。由于所有量都是无量纲的率和计数，因此不涉及物理单位。", "solution": "该问题要求在单细胞RNA测序背景下，给定观测计数 $X_{gc}$，推导潜表达率参数 $\\theta_{gc}$ 的后验分布，并随后求出后验均值和方差。该模型是一个共轭伽马-泊松模型。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件：**\n- 观测到的UMI计数：$X_{gc} \\in \\{0, 1, 2, \\ldots\\}$\n- 基因索引：$g$\n- 细胞索引：$c$\n- 暴露/大小因子：$s_{c} > 0$\n- 潜表达率：$\\theta_{gc} > 0$\n- 似然模型：$X_{gc} \\mid \\theta_{gc} \\sim \\mathrm{Poisson}(s_{c}\\,\\theta_{gc})$\n- 先验模型：$\\theta_{gc} \\sim \\mathrm{Gamma}(a_{g}, b_{g})$，其中 $a_{g} > 0$ 是形状参数，$b_{g} > 0$ 是率参数。\n- 先验概率密度函数 (PDF)：$p(\\theta_{gc}) = \\dfrac{b_{g}^{a_{g}}}{\\Gamma(a_{g})}\\,\\theta_{gc}^{a_{g}-1}\\exp(-b_{g}\\theta_{gc})$\n\n**1.2. 验证：**\n- **科学依据：**伽马-泊松混合模型是用于建模计数数据的标准且成熟的统计框架，特别是在基因组学和计算生物学中用于分析scRNA-seq数据。对计数使用泊松似然，对率使用伽马先验是共轭先验对的典型例子，它构成了负二项分布的基础。该模型在科学上是合理的。\n- **适定性：**该问题要求从一个完全指定的、具有共轭先验-似然对的贝叶斯模型中推导后验分布及其矩。这种结构保证了唯一、稳定且有意义的解析解的存在。\n- **客观性：**该问题以精确的数学和统计术语陈述，没有歧义或主观论断。\n\n**1.3. 结论：**\n该问题是有效的。它具有科学依据，适定、客观，并包含获得唯一解所需的所有信息。\n\n### 步骤2：推导后验分布\n\n我们从贝叶斯法则开始，该法则指出后验分布与似然和先验分布的乘积成正比：\n$$p(\\theta_{gc} \\mid X_{gc}) \\propto p(X_{gc} \\mid \\theta_{gc}) \\, p(\\theta_{gc})$$\n\n似然函数由泊松概率质量函数 (PMF) 给出，其中率为 $\\lambda = s_{c}\\theta_{gc}$：\n$$p(X_{gc} \\mid \\theta_{gc}) = \\frac{(s_{c}\\theta_{gc})^{X_{gc}} \\exp(-s_{c}\\theta_{gc})}{X_{gc}!}$$\n\n$\\theta_{gc}$ 的先验分布是伽马PDF：\n$$p(\\theta_{gc}) = \\frac{b_{g}^{a_{g}}}{\\Gamma(a_{g})} \\theta_{gc}^{a_{g}-1} \\exp(-b_{g}\\theta_{gc})$$\n\n我们将这两个表达式代入贝叶斯法则：\n$$p(\\theta_{gc} \\mid X_{gc}) \\propto \\left( \\frac{(s_{c}\\theta_{gc})^{X_{gc}} \\exp(-s_{c}\\theta_{gc})}{X_{gc}!} \\right) \\left( \\frac{b_{g}^{a_{g}}}{\\Gamma(a_{g})} \\theta_{gc}^{a_{g}-1} \\exp(-b_{g}\\theta_{gc}) \\right)$$\n\n为了找到后验分布的形式，我们可以省略所有不依赖于参数 $\\theta_{gc}$ 的项，因为它们被吸收到归一化常数中。来自似然的项 $\\frac{s_{c}^{X_{gc}}}{X_{gc}!}$ 和来自先验的项 $\\frac{b_{g}^{a_{g}}}{\\Gamma(a_{g})}$ 相对于 $\\theta_{gc}$ 是常数。\n$$p(\\theta_{gc} \\mid X_{gc}) \\propto (\\theta_{gc}^{X_{gc}} \\exp(-s_{c}\\theta_{gc})) (\\theta_{gc}^{a_{g}-1} \\exp(-b_{g}\\theta_{gc}))$$\n\n现在，我们通过相加指数来合并包含 $\\theta_{gc}$ 的项：\n$$p(\\theta_{gc} \\mid X_{gc}) \\propto \\theta_{gc}^{X_{gc} + a_{g} - 1} \\exp(-s_{c}\\theta_{gc} - b_{g}\\theta_{gc})$$\n$$p(\\theta_{gc} \\mid X_{gc}) \\propto \\theta_{gc}^{(a_{g} + X_{gc}) - 1} \\exp(-(b_{g} + s_{c})\\theta_{gc})$$\n\n这个表达式是伽马分布的核（PDF中依赖于变量的部分）。我们可以识别出这个新伽马分布的形状和率参数。\n形状参数为 $\\alpha$、率参数为 $\\beta$ 的伽马分布的PDF正比于 $y^{\\alpha-1} \\exp(-\\beta y)$。\n通过将此形式与我们推导出的后验核进行比较，我们可以确定后验参数：\n- 后验形状参数：$\\alpha' = a_{g} + X_{gc}$\n- 后验率参数：$\\beta' = b_{g} + s_{c}$\n\n因此，给定数据 $X_{gc}$，$\\theta_{gc}$ 的后验分布是一个伽马分布：\n$$\\theta_{gc} \\mid X_{gc} \\sim \\mathrm{Gamma}(a_{g} + X_{gc}, b_{g} + s_{c})$$\n完整的后验PDF为：\n$$p(\\theta_{gc} \\mid X_{gc}) = \\frac{(b_{g} + s_{c})^{a_{g} + X_{gc}}}{\\Gamma(a_{g} + X_{gc})} \\theta_{gc}^{(a_{g} + X_{gc}) - 1} \\exp(-(b_{g} + s_{c})\\theta_{gc})$$\n\n### 步骤3：计算后验均值和方差\n\n一个随机变量 $Y \\sim \\mathrm{Gamma}(\\alpha, \\beta)$ 的均值和方差由以下公式给出：\n- 均值：$E[Y] = \\frac{\\alpha}{\\beta}$\n- 方差：$\\mathrm{Var}[Y] = \\frac{\\alpha}{\\beta^2}$\n\n我们将这些公式应用于我们的后验分布，代入后验形状参数 $\\alpha' = a_{g} + X_{gc}$ 和后验率参数 $\\beta' = b_{g} + s_{c}$。\n\n$\\theta_{gc}$ 的后验均值为：\n$$E[\\theta_{gc} \\mid X_{gc}] = \\frac{\\alpha'}{\\beta'} = \\frac{a_{g} + X_{gc}}{b_{g} + s_{c}}$$\n\n$\\theta_{gc}$ 的后验方差为：\n$$\\mathrm{Var}[\\theta_{gc} \\mid X_{gc}] = \\frac{\\alpha'}{(\\beta')^2} = \\frac{a_{g} + X_{gc}}{(b_{g} + s_{c})^2}$$\n\n这些表达式表示在观测到计数数据 $X_{gc}$ 后，对潜表达率的均值和方差的更新估计。后验均值是先验均值 $\\frac{a_g}{b_g}$ 和由数据推导的最大似然估计 $\\frac{X_{gc}}{s_c}$ 的加权平均。\n\n最终答案由这两个后验均值和后验方差的表达式组成。", "answer": "$$\\boxed{\\begin{pmatrix} \\dfrac{a_{g} + X_{gc}}{b_{g} + s_{c}} & \\dfrac{a_{g} + X_{gc}}{(b_{g} + s_{c})^{2}} \\end{pmatrix}}$$", "id": "3349825"}, {"introduction": "虽然基本的泊松模型是一个好的起点，但它往往无法捕捉单细胞RNA测序数据中零值的高频出现，这一现象被称为“零膨胀”（zero-inflation）。本练习将介绍零膨胀负二项（ZINB）模型，这是一种更现实的方法，它明确地考虑了技术性脱落。通过推导用于拟合 ZINB 模型的期望最大化（EM）算法，您将揭示这些高级模型如何区分结构性零（脱落）和真正的生物性零的内部机制 [@problem_id:3349849]。", "problem": "考虑在单细胞核糖核酸测序 (scRNA-seq) 中，对 $n$ 个细胞测量到的单个基因。细胞 $i$ 的观测计数为 $y_i \\in \\{0,1,2,\\dots\\}$，其中 $i=1,\\dots,n$。由于技术性脱落，数据表现出超出负二项 (NB) 分布所能产生的过量零值。一个标准的建模方法是零膨胀负二项 (ZINB) 混合模型。令 $d_i \\in \\{0,1\\}$ 为细胞 $i$ 中脱落的潜伏二元指示变量，其中 $d_i=1$ 表示由脱落引起的结构性零值，而 $d_i=0$ 表示该计数来自 NB 过程。假设\n$$\nd_i \\sim \\mathrm{Bernoulli}(\\pi),\n\\quad\ny_i \\mid d_i\n\\sim\n\\begin{cases}\n0  \\text{如果 } d_i = 1, \\\\\n\\mathrm{NB}(\\mu,\\alpha)  \\text{如果 } d_i = 0,\n\\end{cases}\n$$\n其中 $\\pi \\in (0,1)$ 是脱落概率，$\\mu>0$ 是 NB 均值，$\\alpha>0$ 是 NB 离散度 (形状) 参数。使用以下经过充分检验的形式和事实：\n- 由均值 $\\mu$ 和离散度 $\\alpha$ 参数化的负二项 (NB) 概率质量函数为\n$$\np_{\\mathrm{NB}}(y \\mid \\mu,\\alpha)\n=\n\\frac{\\Gamma(y+\\alpha)}{\\Gamma(\\alpha)\\,y!}\n\\left(\\frac{\\alpha}{\\alpha+\\mu}\\right)^{\\alpha}\n\\left(\\frac{\\mu}{\\alpha+\\mu}\\right)^{y}.\n$$\n- 双伽玛函数 $\\psi(x)$ 是 $\\ln\\Gamma(x)$ 的导数，而三伽玛函数 $\\psi'(x)$ 是其导数。\n\n从完全数据似然和期望最大化 (EM) 算法的定义（期望最大化 (EM)：通过交替计算潜变量的条件期望和最大化期望完全数据对数似然，来迭代地最大化观测数据对数似然的一个下界）出发，为带有潜伏脱落指示变量的 ZINB 模型推导一个 EM 算法。在平均场近似下，其中变分后验在细胞间分解为 $q(d_1,\\dots,d_n) = \\prod_{i=1}^n q_i(d_i)$ 且 $q_i(d_i=1) \\in [0,1]$，执行以下操作：\n\n- 推导 E 步更新，给出每个细胞 $i$ 的 $q_i(d_i=1)$，用 $\\pi$、$\\mu$、$\\alpha$ 和观测到的 $y_i$ 显式表示。\n- 在平均场近似下，推导 $\\pi$、$\\mu$ 和 $\\alpha$ 的 M 步更新，以最大化期望完全数据对数似然。为 $\\pi$ 和 $\\mu$ 提供闭式更新，并为 $\\alpha$ 提供一个用 $\\psi(\\cdot)$ 和 $\\psi'(\\cdot)$ 表示的显式牛顿步。\n- 清楚地指出更新中出现的充分统计量或权重。\n\n仅报告 NB 均值参数 $\\mu$ 的闭式 M 步更新作为你的最终答案。不需要进行数值计算，也无需四舍五入。将最终答案表示为单个解析表达式。", "solution": "用户希望为零膨胀负二项 (ZINB) 模型推导期望最大化 (EM) 算法。\n\n以下是分步推导过程。\n\n### 步骤1：提取已知条件\n-   **数据**：对于 $i=1, \\dots, n$ 个细胞的观测计数 $y_i \\in \\{0, 1, 2, \\dots\\}$。\n-   **潜变量**：$d_i \\in \\{0, 1\\}$ 是脱落的二元指示变量。$d_i=1$ 表示脱落（结构性零值），$d_i=0$ 表示计数来自负二项 (NB) 过程。\n-   **模型参数**：$\\theta = (\\pi, \\mu, \\alpha)$，其中 $\\pi \\in (0,1)$ 是脱落概率，$\\mu > 0$ 是 NB 均值，$\\alpha > 0$ 是 NB 离散度。\n-   **模型设定**：\n    -   $d_i \\sim \\mathrm{Bernoulli}(\\pi)$，所以 $p(d_i|\\pi) = \\pi^{d_i}(1-\\pi)^{1-d_i}$。\n    -   给定潜变量 $d_i$，计数 $y_i$ 的条件分布是：\n        $$\n        y_i \\mid d_i \\sim\n        \\begin{cases}\n        \\delta_0  \\text{如果 } d_i = 1 \\text{ (在0处的点质量)}, \\\\\n        \\mathrm{NB}(\\mu,\\alpha)  \\text{如果 } d_i = 0.\n        \\end{cases}\n        $$\n-   **NB 概率质量函数 (PMF)**：\n    $$\n    p_{\\mathrm{NB}}(y \\mid \\mu,\\alpha) = \\frac{\\Gamma(y+\\alpha)}{\\Gamma(\\alpha)\\,y!} \\left(\\frac{\\alpha}{\\alpha+\\mu}\\right)^{\\alpha} \\left(\\frac{\\mu}{\\alpha+\\mu}\\right)^{y}\n    $$\n-   **任务**：为估计 $\\theta$ 的 EM 算法推导 E 步和 M 步更新。最终答案应为 $\\mu$ 的 M 步更新。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上和数学上是合理的。ZINB 模型是计算系统生物学中用于建模单细胞测序实验稀疏计数数据的标准且广泛使用的统计工具。EM 算法是为此类潜变量模型进行参数估计的典型方法。所提供的定义和分布都是标准的。该问题是适定的、客观的且自洽的。因此，该问题是**有效的**。\n\n### 步骤3：EM 算法的推导\n\nEM 算法是在具有潜变量的统计模型中寻找参数的最大似然估计的一种迭代过程。它在期望 (E) 步和最大化 (M) 步之间交替进行。\n\n**完全数据对数似然**\n\n模型的完全数据为 $(Y, D) = \\{(y_i, d_i)\\}_{i=1}^n$。给定参数 $\\theta = (\\pi, \\mu, \\alpha)$，单个观测 $(y_i, d_i)$ 的联合概率是：\n$$\np(y_i, d_i \\mid \\theta) = p(y_i \\mid d_i, \\theta) p(d_i \\mid \\theta) = \\left[p(y_i \\mid d_i=1, \\theta) p(d_i=1 \\mid \\theta)\\right]^{d_i} \\left[p(y_i \\mid d_i=0, \\theta) p(d_i=0 \\mid \\theta)\\right]^{1-d_i}\n$$\n根据模型设定，我们有：\n-   如果 $d_i=1$，$y_i$ 必须为 $0$。概率为 $p(d_i=1 \\mid \\pi) = \\pi$。\n-   如果 $d_i=0$，$y_i$ 从 $\\mathrm{NB}(\\mu, \\alpha)$ 中抽样。联合概率为 $p_{\\mathrm{NB}}(y_i \\mid \\mu, \\alpha) \\cdot p(d_i=0 \\mid \\pi) = p_{\\mathrm{NB}}(y_i \\mid \\mu, \\alpha)(1-\\pi)$。\n\n联合概率可以简明地写为：\n$$\np(y_i, d_i \\mid \\theta) = [\\pi \\cdot \\mathbf{1}_{y_i=0}]^{d_i} [(1-\\pi) \\cdot p_{\\mathrm{NB}}(y_i \\mid \\mu, \\alpha)]^{1-d_i}\n$$\n其中 $\\mathbf{1}_{y_i=0}$ 是一个指示函数，如果 $y_i=0$ 则为 $1$，否则为 $0$。这个公式正确地蕴含了如果 $y_i > 0$，那么 $d_i$ 必须为 $0$。\n\n完全数据对数似然 $\\mathcal{L}_c(\\theta; Y, D) = \\sum_{i=1}^n \\log p(y_i, d_i \\mid \\theta)$ 为：\n$$\n\\mathcal{L}_c(\\theta) = \\sum_{i=1}^n \\left\\{ d_i (\\log\\pi + \\log\\mathbf{1}_{y_i=0}) + (1-d_i) [\\log(1-\\pi) + \\log p_{\\mathrm{NB}}(y_i \\mid \\mu, \\alpha)] \\right\\}\n$$\n如果我们通过注意带有 $d_i$ 的项仅在 $y_i=0$ 时有贡献来处理 $\\log\\mathbf{1}_{y_i=0}$ 项，那么这个表达式是有效的。\n\n**E步：计算后验概率**\n\n在 E 步中，我们计算完全数据对数似然关于给定观测数据 $Y$ 和当前参数估计 $\\theta^{(t)} = (\\pi^{(t)}, \\mu^{(t)}, \\alpha^{(t)})$ 的潜变量 $D$ 的后验分布的期望。这需要计算每个细胞 $i$ 的 $d_i=1$ 的后验概率。我们用 $\\gamma_i$ 表示这个概率：\n$$\n\\gamma_i \\equiv p(d_i=1 \\mid y_i, \\theta^{(t)})\n$$\n问题陈述中将其称为 $q_i(d_i=1)$。\n\n-   如果 $y_i > 0$：非零计数不可能是脱落。因此，$d_i$ 必须为 $0$。\n    $$\n    \\gamma_i = p(d_i=1 \\mid y_i > 0, \\theta^{(t)}) = 0\n    $$\n-   如果 $y_i = 0$：零计数可能是脱落 ($d_i=1$) 或来自 NB 部分的生物学零值 ($d_i=0$)。我们使用贝叶斯定理：\n    $$\n    \\gamma_i = p(d_i=1 \\mid y_i=0, \\theta^{(t)}) = \\frac{p(y_i=0 \\mid d_i=1, \\theta^{(t)}) p(d_i=1 \\mid \\theta^{(t)})}{p(y_i=0 \\mid \\theta^{(t)})}\n    $$\n    各组成部分为：\n    -   分子：$p(y_i=0 \\mid d_i=1, \\theta^{(t)}) = 1$ 且 $p(d_i=1 \\mid \\theta^{(t)}) = \\pi^{(t)}$。所以分子是 $\\pi^{(t)}$。\n    -   分母（观测到零的边际概率）：\n        $p(y_i=0 \\mid \\theta^{(t)}) = p(y_i=0, d_i=1 \\mid \\theta^{(t)}) + p(y_i=0, d_i=0 \\mid \\theta^{(t)})$\n        $p(y_i=0 \\mid \\theta^{(t)}) = \\pi^{(t)} + (1-\\pi^{(t)}) p_{\\mathrm{NB}}(0 \\mid \\mu^{(t)}, \\alpha^{(t)})$。\n        $0$ 的 NB 概率为 $p_{\\mathrm{NB}}(0 \\mid \\mu, \\alpha) = \\left(\\frac{\\alpha}{\\alpha+\\mu}\\right)^{\\alpha}$。\n    所以，对于 $y_i=0$：\n    $$\n    \\gamma_i = \\frac{\\pi^{(t)}}{\\pi^{(t)} + (1-\\pi^{(t)}) \\left(\\frac{\\alpha^{(t)}}{\\alpha^{(t)}+\\mu^{(t)}}\\right)^{\\alpha^{(t)}}}\n    $$\n这些概率 $\\gamma_i$ 是在 E 步中计算的关键量。它们有时被称为“责任 (responsibilities)”。\n\n**M步：最大化期望对数似然**\n\n在 M 步中，我们关于参数 $\\theta = (\\pi, \\mu, \\alpha)$ 最大化期望完全数据对数似然 $Q(\\theta \\mid \\theta^{(t)})$。\n$$\nQ(\\theta \\mid \\theta^{(t)}) = E_{D \\mid Y, \\theta^{(t)}}[\\mathcal{L}_c(\\theta)] = \\sum_{i=1}^n E[d_i \\mid y_i, \\theta^{(t)}] \\log\\pi + E[1-d_i \\mid y_i, \\theta^{(t)}] (\\log(1-\\pi) + \\log p_{\\mathrm{NB}}(y_i \\mid \\mu, \\alpha))\n$$\n代入 $E[d_i \\mid y_i, \\theta^{(t)}] = \\gamma_i$：\n$$\nQ(\\theta \\mid \\theta^{(t)}) = \\sum_{i=1}^n \\left\\{ \\gamma_i \\log\\pi + (1-\\gamma_i) \\log(1-\\pi) + (1-\\gamma_i) \\log p_{\\mathrm{NB}}(y_i \\mid \\mu, \\alpha) \\right\\}\n$$\n注意，对于涉及 $p_{\\mathrm{NB}}$ 的项，由于 $\\gamma_i=1$ 意味着 $y_i=0$，项 $(1-\\gamma_i)\\log p_{\\mathrm{NB}}(y_i=0\\dots)$ 可能不为零。但如果 $\\gamma_i=1$，这不重要，因为权重是 $0$。等等，如果 $\\gamma_i=1$，权重是 $(1-1)=0$。这是不正确的。如果 $y_i > 0, \\gamma_i=0$，那么项是 $\\log(1-\\pi) + \\log p_{NB}$。如果 $y_i=0$，项是 $\\gamma_i\\log\\pi + (1-\\gamma_i)[\\log(1-\\pi)+\\dots]$。让我们重写 $Q$。\n$$\nQ(\\theta|\\theta^{(t)}) = \\sum_{i: y_i=0} \\left[ \\gamma_i \\log \\pi + (1-\\gamma_i) \\left( \\log(1-\\pi) + \\log p_{\\mathrm{NB}}(0|\\mu,\\alpha) \\right) \\right] + \\sum_{i: y_i>0} \\left[ \\log(1-\\pi) + \\log p_{\\mathrm{NB}}(y_i|\\mu,\\alpha) \\right]\n$$\n因为对于 $y_i>0$, $\\gamma_i=0$，这可以简化为：\n$$\nQ(\\theta|\\theta^{(t)}) = \\sum_{i=1}^n \\left[ \\gamma_i \\log \\pi + (1-\\gamma_i) \\log(1-\\pi) \\right] + \\sum_{i=1}^n (1-\\gamma_i) \\log p_{\\mathrm{NB}}(y_i|\\mu,\\alpha)\n$$\n我们分别就 $\\pi, \\mu, \\alpha$ 对此进行最大化。\n\n**$\\pi$ 的 M 步更新**：\n我们最大化 $Q_{\\pi}(\\pi) = \\sum_{i=1}^n [\\gamma_i \\log\\pi + (1-\\gamma_i)\\log(1-\\pi)]$。\n$$\n\\frac{\\partial Q_{\\pi}}{\\partial \\pi} = \\sum_{i=1}^n \\left( \\frac{\\gamma_i}{\\pi} - \\frac{1-\\gamma_i}{1-\\pi} \\right) = 0 \\implies \\frac{1}{\\pi}\\sum \\gamma_i = \\frac{1}{1-\\pi}\\sum(1-\\gamma_i)\n$$\n解出 $\\pi$ 得到更新式：\n$$\n\\pi^{(t+1)} = \\frac{\\sum_{i=1}^n \\gamma_i}{n}\n$$\n充分统计量是脱落的期望总数，$\\sum_i \\gamma_i$。\n\n**$\\mu$ 的 M 步更新**：\n我们最大化 $Q_{\\mu,\\alpha}(\\mu,\\alpha) = \\sum_{i=1}^n (1-\\gamma_i)\\log p_{\\mathrm{NB}}(y_i \\mid \\mu, \\alpha)$。这是一个加权的 NB 对数似然。为了找到 $\\mu$ 的更新式，我们对 $\\mu$ 求偏导数并令其为零。\n$$\n\\log p_{\\mathrm{NB}}(y \\mid \\mu, \\alpha) = \\log\\Gamma(y+\\alpha) - \\log\\Gamma(\\alpha) - \\log y! + \\alpha\\log\\alpha + y\\log\\mu - (y+\\alpha)\\log(\\alpha+\\mu)\n$$\n$$\n\\frac{\\partial}{\\partial \\mu} \\log p_{\\mathrm{NB}}(y \\mid \\mu, \\alpha) = \\frac{y}{\\mu} - \\frac{y+\\alpha}{\\alpha+\\mu}\n$$\n目标函数的导数为：\n$$\n\\frac{\\partial Q_{\\mu,\\alpha}}{\\partial \\mu} = \\sum_{i=1}^n (1-\\gamma_i) \\left( \\frac{y_i}{\\mu} - \\frac{y_i+\\alpha}{\\alpha+\\mu} \\right) = 0\n$$\n为了找到 $\\mu^{(t+1)}$，我们设 $\\alpha = \\alpha^{(t)}$ 并解出 $\\mu$：\n$$\n\\frac{1}{\\mu} \\sum_{i=1}^n (1-\\gamma_i)y_i = \\frac{1}{\\alpha^{(t)}+\\mu} \\sum_{i=1}^n (1-\\gamma_i)(y_i+\\alpha^{(t)})\n$$\n$$\n\\frac{1}{\\mu} \\sum_{i=1}^n (1-\\gamma_i)y_i = \\frac{1}{\\alpha^{(t)}+\\mu} \\left( \\sum_{i=1}^n (1-\\gamma_i)y_i + \\alpha^{(t)}\\sum_{i=1}^n(1-\\gamma_i) \\right)\n$$\n令 $S_y = \\sum_{i=1}^n (1-\\gamma_i)y_i$ 且 $S_w = \\sum_{i=1}^n (1-\\gamma_i)$。\n$$\n\\frac{S_y}{\\mu} = \\frac{S_y + \\alpha^{(t)} S_w}{\\alpha^{(t)}+\\mu} \\implies S_y(\\alpha^{(t)}+\\mu) = \\mu(S_y + \\alpha^{(t)}S_w)\n$$\n$$\nS_y \\alpha^{(t)} + S_y \\mu = \\mu S_y + \\mu \\alpha^{(t)} S_w \\implies S_y \\alpha^{(t)} = \\mu \\alpha^{(t)} S_w\n$$\n对于 $\\alpha^{(t)} > 0$，我们可以除以它，得到 $S_y = \\mu S_w$。解出 $\\mu$：\n$$\n\\mu^{(t+1)} = \\frac{S_y}{S_w} = \\frac{\\sum_{i=1}^n (1-\\gamma_i)y_i}{\\sum_{i=1}^n (1-\\gamma_i)}\n$$\n这就是 $\\mu$ 的闭式更新。它是计数的加权平均值，其中权重是不属于脱落的后验概率。这里的充分统计量是来自 NB 部分的期望总计数 $\\sum(1-\\gamma_i)y_i$ 和来自 NB 部分的期望细胞数 $\\sum(1-\\gamma_i)$。\n\n**$\\alpha$ 的 M 步更新**：\n$\\alpha$ 的更新没有闭式解。我们在将 $\\mu$ 固定为 $\\mu^{(t+1)}$ 的情况下最大化 $Q_{\\mu,\\alpha}$。这需要像牛顿-拉夫逊法这样的数值优化方法。将 $\\alpha$ 从当前值 $\\alpha_{old}$ 更新到 $\\alpha_{new}$ 的一个牛顿步是：\n$$\n\\alpha_{new} = \\alpha_{old} - \\frac{g(\\alpha_{old})}{h(\\alpha_{old})}\n$$\n其中 $g(\\alpha) = \\frac{\\partial Q_{\\mu,\\alpha}}{\\partial\\alpha}$ 和 $h(\\alpha) = \\frac{\\partial^2 Q_{\\mu,\\alpha}}{\\partial\\alpha^2}$。\n$$\ng(\\alpha) = \\sum_{i=1}^n (1-\\gamma_i) \\left[ \\psi(y_i+\\alpha) - \\psi(\\alpha) + \\log\\alpha + 1 - \\log(\\alpha+\\mu^{(t+1)}) - \\frac{y_i+\\alpha}{\\alpha+\\mu^{(t+1)}} \\right]\n$$\n$$\nh(\\alpha) = \\sum_{i=1}^n (1-\\gamma_i) \\left[ \\psi'(y_i+\\alpha) - \\psi'(\\alpha) + \\frac{1}{\\alpha} - \\frac{1}{\\alpha+\\mu^{(t+1)}} + \\frac{y_i-\\mu^{(t+1)}}{(\\alpha+\\mu^{(t+1)})^2} \\right]\n$$\n该更新包括在 $\\alpha_{old}=\\alpha^{(t)}$ (以及 $\\mu=\\mu^{(t+1)}$) 处评估 $g$ 和 $h$，并执行一步或多步迭代。\n\n具体问题只要求 $\\mu$ 的最终闭式更新。", "answer": "$$\\boxed{\\frac{\\sum_{i=1}^{n} (1-\\gamma_i) y_i}{\\sum_{i=1}^{n} (1-\\gamma_i)}}$$", "id": "3349849"}, {"introduction": "理论模型固然强大，但对任何计算生物学家来说，一项关键技能是知道何时应用它们。这个动手编码练习解决了一个关键问题：我们如何定量地判断我们的数据是否表现出显著的零膨胀，从而需要使用像 ZINB 这样的复杂模型？您将实现一个拟合优度检验 [@problem_id:3349885]，将观测到的零值数量与标准负二项模型的期望值进行比较，从而将一个理论问题转化为一个实用的诊断工具。", "problem": "您的任务是为单细胞基因表达计数数据中的零膨胀设计并实现一个离散拟合优度检验。背景是在有限数量的细胞中测量单个基因。单细胞计数表现出稀疏性，必须将生物学上有意义的低表达与技术性脱落区分开。建模基础是负二项 (NB) 分布，这是一种在单细胞基因组学中广泛使用的计数模型，用以捕捉细胞间的过度离散。您的程序必须为提供的测试套件中的每个案例执行以下步骤。\n\n从以下基础且广为接受的定义出发：\n- 负二项 (NB) 分布用于对非负整数值计数进行建模。在使用大小 $r$ 和成功概率 $p$ 的 NB 参数化下，对于 $X \\in \\{0,1,2,\\dots\\}$ 的概率质量函数为 $P(X=x) = \\binom{x+r-1}{x} p^{r} (1-p)^{x}$。其均值为 $E[X] = r \\frac{1-p}{p}$，方差为 $\\mathrm{Var}[X] = r \\frac{1-p}{p^{2}}$。在计算生物学背景下，通常通过其均值 $\\mu$ 和大小 $r$ 对 NB 进行重新参数化，其中 $p = \\frac{r}{r+\\mu}$，得到 $E[X]=\\mu$ 和 $\\mathrm{Var}[X]=\\mu + \\frac{\\mu^{2}}{r}$。\n- 对于一个在 $N$ 个细胞中测量的基因，索引 $i \\in \\{1,\\dots,N\\}$，假设计数 $X_{i}$ 是跨细胞从一个 NB 模型中独立抽取的样本，构成一个基线生成模型。在此基线 NB 模型下，任何单个细胞中出现精确零的概率是 $P(X_{i}=0) = p^{r}$，而在 $N$ 个细胞中零的期望数量是 $N \\cdot p^{r}$。\n- 在原假设下，即不存在超出 NB 模型预测的额外零膨胀，零的个数 $Z = \\sum_{i=1}^{N} \\mathbf{1}\\{X_{i}=0\\}$ 服从参数为 $(N, q)$ 的二项分布，其中 $q = p^{r}$。\n- 为检验超出 NB 模型的零膨胀（过多的零），适合采用单侧检验，将观测到的零计数 $z$ 与 NB 期望计数 $N q$ 进行比较。两种标准的离散检验策略都是可接受的：针对 $Z$ 的精确二项上尾检验，以及带连续性校正的校准 Pearson 卡方检验（仅在上尾进行评估，因为科学上感兴趣的备择假设是零过多）。当 $q$ 接近 $0$ 或 $1$ 时，为保证科学真实性，需要进行连续性校正和谨慎的边界处理。\n- 为了在单基因数据上进行实际应用，必须使用矩估计法，通过广泛接受的 NB 方差分解，从观测计数中估计参数 $(\\mu, r)$。给定样本均值 $\\hat{\\mu}$ 和样本方差 $\\hat{v}$，当 $\\hat{v} > \\hat{\\mu}$ 时，一个有效的 NB 大小估计是 $\\hat{r} = \\frac{\\hat{\\mu}^{2}}{\\hat{v} - \\hat{\\mu}}$。当 $\\hat{v} \\le \\hat{\\mu}$ 时，数据最多是泊松离散的；在这种边界情况下，您必须使用一个大的代理值 $\\hat{r}$ 来近似泊松极限，从而得到 NB 零概率 $q \\approx \\exp(-\\hat{\\mu})$，这是当 $p = \\frac{\\hat{r}}{\\hat{r} + \\hat{\\mu}}$ 且 $\\hat{r} \\to \\infty$ 时 $p^{r}$ 的极限行为。\n\n您的程序必须为每个测试案例执行以下操作：\n1. 使用零膨胀负二项 (ZINB) 数据生成器，为 $N$ 个细胞生成合成的单基因计数，以实现真实性：以概率 $\\pi$ 发出一个额外的零，否则从均值为 $\\mu$、大小为 $r$ 的 NB 分布中抽取，如上定义。为确保所有案例的可复现性，使用固定的伪随机数生成器种子 $12345$。此生成器严格用于产生测试数据；推断过程必须使用 NB 模型，且无法访问 $\\pi$。\n2. 根据生成的计数，计算样本均值 $\\hat{\\mu}$ 和样本方差 $\\hat{v}$，然后通过矩估计法估计 NB 大小参数 $\\hat{r}$，在 $\\hat{v} \\le \\hat{\\mu}$ 时使用一个大的代理值 $\\hat{r}$ 来近似泊松极限。根据 $(\\hat{\\mu}, \\hat{r})$，计算 $p = \\frac{\\hat{r}}{\\hat{r} + \\hat{\\mu}}$ 以及 NB 零概率估计 $q = p^{\\hat{r}}$。通过对数取幂的方式对 $q$ 进行数值稳定的评估。最后，计算观测到的零计数 $z$ 和 NB 期望的零计数 $\\hat{z}^{\\mathrm{NB}} = N q$。\n3. 执行零膨胀的单侧检验：\n   - 精确二项上尾检验：计算在 $Z \\sim \\mathrm{Binomial}(N, q)$ 下的 $p$ 值 $P(Z \\ge z)$。为减少离散性带来的保守性，可接受中位 $p$ 值调整 $P(Z > z) + \\tfrac{1}{2} P(Z = z)$。\n   - 校准 Pearson 卡方检验：带连续性校正，仅在 $z \\ge N q$ 时定义统计量为 $$X^{2} = \\frac{\\left(|z - N q| - 0.5\\right)^{2}}{N q (1-q)}.$$ 当 $z  N q$ 时，将单侧上尾 $p$ 值设为 $1$。为确保数值安全，当 $q$ 极度接近 $0$ 或 $1$ 时，回退到精确二项上尾 $p$ 值，以避免除以极小的分母。\n4. 将得到的 $p$ 值与给定的显著性水平 $\\alpha$ 进行比较，如果检验检测到显著的零膨胀（即 $p  \\alpha$），则返回布尔决策 $True$，否则返回 $False$。\n\n不涉及物理单位。所有角度（如有）均不相关。将任何比率阈值或水平表示为小数（例如，需要时将 $\\alpha$ 写为 $0.05$）。您的实现必须纯粹基于数学和逻辑术语，可通过指定的伪随机种子复现。\n\n测试套件：\n对于每个元组，参数为 $(N, \\mu, r, \\pi, \\alpha, \\text{test})$，其中 $N$ 是细胞数量，$\\mu$ 是 NB 均值， $r$ 是 NB 大小，$\\pi$ 是零膨胀概率，$\\alpha$ 是显著性水平，$\\text{test}$ 是精确二项检验或校准卡方检验。使用以下案例：\n- 案例 1：$(200, 1.5, 4.0, 0.0, 0.05, \\text{Binomial})$。\n- 案例 2：$(200, 1.5, 4.0, 0.20, 0.05, \\text{Binomial})$。\n- 案例 3：$(50, 0.2, 2.0, 0.0, 0.05, \\text{Binomial})$。\n- 案例 4：$(50, 0.2, 2.0, 0.70, 0.05, \\text{Binomial})$。\n- 案例 5：$(100, 5.0, 10.0, 0.0, 0.01, \\text{ChiSquare})$。\n- 案例 6：$(150, 2.0, 10^{6}, 0.30, 0.01, \\text{ChiSquare})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试案例对应一个布尔值，指示是否在其指定的水平上检测到显著的零膨胀，例如 $[True,False,\\dots]$。程序必须且只能打印这一行内容。", "solution": "用户提供的问题经评估为有效问题。它在科学上基于统计基因组学的既定原则，定义明确，对所需程序有清晰完整的说明，且表述客观。任务是为单细胞计数数据中的零膨胀实现一个拟合优度检验，这是计算系统生物学中的一个标准问题。解决方案将首先实现数据生成和参数估计，然后执行指定的统计检验。\n\n每个测试案例的总体流程如下：生成一个合成数据集，根据此数据估计一个零模型（负二项分布）的参数，执行统计检验以评估零模型对观测到的零数量的解释程度，并就统计显著性做出决策。\n\n**步骤 1：合成数据生成**\n对于每个测试案例，我们从零膨胀负二项 (ZINB) 分布中为 $N$ 个细胞生成合成的单基因表达计数。ZINB 模型由零膨胀概率 $\\pi$、负二项 (NB) 均值 $\\mu$ 和 NB 大小参数 $r$ 定义。对于每个细胞 $i=1, \\dots, N$：\n1. 从参数为 $\\pi$ 的伯努利分布中抽取一个值。\n2. 如果结果为成功（概率为 $\\pi$），则计数 $X_i$ 是一个“额外”的零，所以 $X_i=0$。\n3. 如果结果为失败（概率为 $1-\\pi$），则计数 $X_i$ 从负二项分布 $\\mathrm{NB}(\\mu, r)$ 中抽取。\n\nNB 分布通过其均值 $\\mu$ 和大小 $r$ 进行参数化。NB 过程的底层伯努利试验的成功概率由 $p = \\frac{r}{r+\\mu}$ 给出。其概率质量函数为 $P(X=x) = \\binom{x+r-1}{x} p^{r} (1-p)^{x}$。使用一个以 $12345$ 为种子的伪随机数生成器进行所有随机抽样，以确保所有测试案例的可复现性。\n\n**步骤 2：从数据中进行参数估计**\n根据生成的 $N$ 个计数的向量，我们使用矩估计法来估计纯 NB 模型（零模型）的参数。此过程故意忽略用于生成数据的零膨胀成分（如果存在），因为检验的目的就是检测其是否存在。\n\n1.  从 $N$ 个计数中计算样本均值 $\\hat{\\mu}$ 和样本方差 $\\hat{v}$（带 Bessel 校正，即分母为 $N-1$）。\n2.  理论上 NB 方差为 $\\mathrm{Var}[X] = \\mu + \\frac{\\mu^2}{r}$。通过代入样本估计值，我们可以解出 $r$：\n    $$ \\hat{r} = \\frac{\\hat{\\mu}^2}{\\hat{v} - \\hat{\\mu}} $$\n    该估计仅对过度离散数据（其中 $\\hat{v}  \\hat{\\mu}$）有效。\n3.  在离散不足或类泊松离散 ($\\hat{v} \\le \\hat{\\mu}$) 的情况下，数据不支持具有有限正值 $r$ 的 NB 模型。这对应于 $r \\to \\infty$ 的极限情况，此时 NB 分布收敛于泊松分布。在这种情况下，我们为 $\\hat{r}$ 分配一个非常大的代理值，例如 $10^{12}$，以近似此极限。\n4.  利用估计值 $\\hat{\\mu}$ 和 $\\hat{r}$，我们计算在拟合的 NB 模型下观测到零的概率。成功概率为 $p = \\frac{\\hat{r}}{\\hat{r} + \\hat{\\mu}}$。零计数的概率为 $q = p^{\\hat{r}}$。为保持数值稳定性，尤其是在 $\\hat{r}$ 很大时，$q$ 通过其对数计算：\n    $$ q = \\exp\\left(\\hat{r} \\log p\\right) = \\exp\\left(\\hat{r} \\log\\left(\\frac{\\hat{r}}{\\hat{r} + \\hat{\\mu}}\\right)\\right) = \\exp\\left(-\\hat{r} \\log\\left(1 + \\frac{\\hat{\\mu}}{\\hat{r}}\\right)\\right) $$\n    这种形式在数值上是稳健的，并且对于大的 $\\hat{r}$ 能正确地评估为 $q \\approx e^{-\\hat{\\mu}}$。\n5.  最后，我们计算数据中观测到的零的数量 $z$，并计算在拟合的 NB 模型下期望的零的数量 $\\hat{z}^{\\mathrm{NB}} = N \\cdot q$。\n\n**步骤 3：单侧拟合优度检验**\n我们检验原假设 $H_0$：观测到的零计数 $z$ 与从二项分布 $Z \\sim \\mathrm{Binomial}(N, q)$ 中抽样的结果一致。备择假设 $H_1$ 是存在零膨胀，即零过多，因此我们执行单侧上尾检验。\n\n按规定实现了两种检验策略：\n\n1.  **精确二项检验**：$p$ 值是在原假设下观测到至少 $z$ 个零的概率。\n    $$ p\\text{-值} = P(Z \\ge z) = \\sum_{k=z}^{N} \\binom{N}{k} q^k (1-q)^{N-k} $$\n    这通过计算二项分布在 $z-1$ 处的生存函数得到。\n\n2.  **校准 Pearson 卡方检验**：此检验是基于二项分布的正态近似。仅当观测到的零计数 $z$ 超过期望计数 $Nq$ 时，才计算包含 Yates 连续性校正的检验统计量。\n    $$ X^2 = \\frac{\\left(|z - N q| - 0.5\\right)^2}{N q (1-q)} $$\n    如果 $z  Nq$，则没有零过多的证据，因此单侧 $p$ 值设为 $1$。如果 $z \\ge Nq$，$p$ 值是概率 $P(\\chi^2_1 \\ge X^2)$，其中 $\\chi^2_1$ 是一个自由度为 $1$ 的卡方随机变量。\n\n    卡方近似仅在两个类别（‘零’和‘非零’）的期望计数足够大时才有效。一个标准的启发式法则是期望计数应至少为 $5$。因此，如果 $N q  5$ 或 $N (1-q)  5$，我们会回退到更精确的精确二项检验，以确保数值稳定性和统计有效性。\n\n**步骤 4：决策**\n对于每个测试案例，将计算出的 $p$ 值与给定的显著性水平 $\\alpha$ 进行比较。如果 $p$ 值小于 $\\alpha$，则拒绝无零膨胀的原假设，结果为 `True`。否则，不拒绝原假设，结果为 `False`。所有测试案例的布尔结果被编译成一个列表，并格式化为最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import binom, chi2\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem of detecting zero inflation in single-gene count data.\n    \"\"\"\n    \n    # Test cases: (N, mu, r, pi, alpha, test_type)\n    test_cases = [\n        (200, 1.5, 4.0, 0.0, 0.05, 'Binomial'),\n        (200, 1.5, 4.0, 0.20, 0.05, 'Binomial'),\n        (50, 0.2, 2.0, 0.0, 0.05, 'Binomial'),\n        (50, 0.2, 2.0, 0.70, 0.05, 'Binomial'),\n        (100, 5.0, 10.0, 0.0, 0.01, 'ChiSquare'),\n        (150, 2.0, 10**6, 0.30, 0.01, 'ChiSquare'),\n    ]\n\n    # Initialize a single random number generator for reproducibility across all cases.\n    rng = np.random.default_rng(12345)\n    \n    results = []\n\n    for N, mu, r, pi, alpha, test_type in test_cases:\n        \n        # Step 1: Generate synthetic ZINB data\n        counts = np.zeros(N, dtype=int)\n        is_dropout = rng.uniform(0, 1, size=N)  pi\n        counts[is_dropout] = 0\n        \n        n_non_dropout = N - np.sum(is_dropout)\n        if n_non_dropout > 0:\n            # For NB(mu, r), success probability p = r / (r + mu)\n            nb_p = r / (r + mu)\n            # numpy's `negative_binomial` has mean n*(1-p)/p.\n            # With our p, mean = r*(1 - r/(r+mu)) / (r/(r+mu)) = r*(mu/(r+mu)) / (r/(r+mu)) = mu. This is correct.\n            nb_draws = rng.negative_binomial(n=r, p=nb_p, size=n_non_dropout)\n            counts[~is_dropout] = nb_draws\n\n        # Step 2: Parameter estimation\n        if N > 1:\n            mu_hat = np.mean(counts)\n            v_hat = np.var(counts, ddof=1)\n        else: # Handle edge case of N=1\n            mu_hat = counts[0] if N == 1 else 0.0\n            v_hat = 0.0\n\n        if mu_hat == 0: # All counts are 0\n            r_hat = 1e12\n        elif v_hat > mu_hat:\n            r_hat = mu_hat**2 / (v_hat - mu_hat)\n        else: # Underdispersed or Poisson-like case\n            r_hat = 1e12 # Surrogate for r -> infinity\n\n        # Numerically stable calculation of q = p^r\n        if mu_hat >= 0 and r_hat > 0:\n            # q = (r/(r+mu))^r = exp(r * log(r/(r+mu))) = exp(-r * log(1 + mu/r))\n            # np.log1p(x) computes log(1+x) accurately for small x.\n            log_q = -r_hat * np.log1p(mu_hat / r_hat)\n            q = np.exp(log_q)\n        else: # Should not happen with mu_hat >= 0\n            q = 1.0 if mu_hat == 0 else 0.0\n\n        # Clip q to be within a valid probability range\n        q = np.clip(q, 0.0, 1.0)\n            \n        z_obs = np.sum(counts == 0)\n        z_exp = N * q\n\n        # Step 3: Perform one-sided test\n        p_value = -1.0 # Initialize\n\n        def compute_binomial_p_value(z, n_trials, prob):\n            # P(Z >= z) = 1 - P(Z = z-1) = sf(z-1)\n            # Handle z=0 edge case where z-1 is negative.\n            if z == 0:\n                return 1.0\n            return binom.sf(z - 1, n_trials, prob)\n\n        if test_type == 'Binomial':\n            p_value = compute_binomial_p_value(z_obs, N, q)\n\n        elif test_type == 'ChiSquare':\n            # Fallback condition for chi-square approximation validity\n            chi2_fallback = (N * q  5) or (N * (1 - q)  5)\n            \n            if chi2_fallback:\n                p_value = compute_binomial_p_value(z_obs, N, q)\n            else:\n                if z_obs = z_exp:\n                    # One-sided test: no evidence for *excess* zeros\n                    p_value = 1.0\n                else:\n                    numerator = (abs(z_obs - z_exp) - 0.5)**2\n                    denominator = N * q * (1 - q)\n                    chi2_stat = numerator / denominator\n                    p_value = chi2.sf(chi2_stat, df=1)\n        \n        # Step 4: Compare p-value with alpha\n        is_significant = p_value  alpha\n        results.append(is_significant)\n    \n    # Final output formatting\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3349885"}]}