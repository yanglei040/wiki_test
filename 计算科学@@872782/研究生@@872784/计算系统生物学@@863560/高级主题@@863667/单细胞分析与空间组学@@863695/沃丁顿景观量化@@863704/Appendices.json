{"hands_on_practices": [{"introduction": "细胞表型的稳定性和变异性被编码在沃丁顿景观上相应吸引子的局部几何形状中。本练习旨在通过动手实践，将景观的数学曲率（由Hessian矩阵表示）与具体的生物学可观测量联系起来。通过计算表型方差和弛豫时间，您将对势阱的形状如何决定系统在稳定态附近的行为建立起定量的直觉[@problem_id:3358338]。", "problem": "考虑一个粗粒化基因调控系统，该系统被建模为在 Waddington 表观遗传景观上的一个过阻尼随机微分方程 (SDE)，其状态向量 $x \\in \\mathbb{R}^{n}$ 的演化遵循\n$$\ndx \\,=\\, -\\nabla U(x)\\,dt \\,+\\, \\sqrt{2D}\\,dW_t,\n$$\n其中 $U(x)$ 是一个塑造景观的标量势， $D$ 是一个标量扩散系数，而 $W_t$ 是一个标准维纳过程。一个吸引子 $x^{\\ast}$ 位于 $U(x)$ 的一个局部最小值处，因此其黑塞矩阵 (Hessian) $H \\equiv \\nabla^{2} U(x^{\\ast})$ 是对称且正定的。在 $x^{\\ast}$ 附近的线性响应区域内，小偏差 $\\xi \\equiv x - x^{\\ast}$ 为动力学和稳态变异性提供了一个局部有效的近似，而曲率 $H$ 同时调节弛豫和涨落。\n\n关注一个二维状态 ($n = 2$)，其吸引子处的曲率经实验推断如下：\n$$\nH \\,=\\, \\begin{pmatrix} 5  1 \\\\ 1  3 \\end{pmatrix},\n$$\n以及一个标量扩散系数\n$$\nD \\,=\\, 0.2.\n$$\n假设噪声是加性和各向同性的，并且没有外部驱动。定义一个线性表型 $y$ 作为状态涨落的投影，\n$$\ny \\,=\\, c^{\\top}\\xi,\\quad c \\,=\\, \\begin{pmatrix} 1 \\\\ -2 \\end{pmatrix}.\n$$\n\n从该 SDE 和关于稳定不动点线性化的基本性质（Ornstein-Uhlenbeck 行为）出发，并使用与 Fokker-Planck 描述一致的线性响应理论和涨落-耗散推理，推导表型 $y$ 的稳态方差以及 $x^{\\ast}$ 附近的最慢弛豫时间常数，用给定的 $H$、$D$ 和 $c$ 表示。将稳态方差以状态变量的平方单位表示，将时间常数以 SDE 的时间单位表示。将最终答案以一个单行矩阵的形式给出，该矩阵首先包含 $y$ 的稳态方差，其次是最慢弛豫时间常数。无需四舍五入；报告精确值。", "solution": "用户希望我解决这个问题陈述。\n\n### 步骤 1：提取给定条件\n\n-   状态向量 $x \\in \\mathbb{R}^{n}$ 根据随机微分方程 (SDE) 演化：$dx = -\\nabla U(x) dt + \\sqrt{2D} dW_t$。\n-   系统是二维的，所以 $n = 2$。\n-   势能 $U(x)$ 在吸引子 $x^{\\ast}$ 处的黑塞矩阵是 $H \\equiv \\nabla^{2} U(x^{\\ast}) = \\begin{pmatrix} 5  1 \\\\ 1  3 \\end{pmatrix}$。\n-   标量扩散系数是 $D = 0.2$。\n-   与吸引子的偏差是 $\\xi \\equiv x - x^{\\ast}$。\n-   线性表型 $y$ 定义为 $y = c^{\\top}\\xi$。\n-   投影向量是 $c = \\begin{pmatrix} 1 \\\\ -2 \\end{pmatrix}$。\n\n### 步骤 2：使用提取的给定条件进行验证\n\n-   **科学依据：**该问题牢固地植根于统计物理学和计算系统生物学。使用过阻尼朗之万方程（给定形式的 SDE）来模拟势能景观上的动力学是一个标准框架。在稳定不动点附近进行线性化以推导 Ornstein-Uhlenbeck 过程，以及应用涨落-耗散概念，都是该领域的经典方法。\n-   **适定性：**该问题提供了求解所要求量所需的所有信息。黑塞矩阵 $H$ 是对称的。其行列式为 $\\det(H) = (5)(3) - (1)(1) = 14 > 0$，其迹为 $\\text{tr}(H) = 5+3=8 > 0$。由于两者均为正， $H$ 的特征值也为正，这证实了 $H$ 是正定的，且 $x^{\\ast}$ 是一个稳定最小值。这确保了存在唯一的稳态分布，并且弛豫时间是明确定义且为正的。因此，该问题是适定的。\n-   **客观性：**该问题使用精确的数学和物理术语陈述，没有主观或含糊的语言。\n-   **完整性和一致性：**该问题是自洽的，所有给定的参数都是一致的。\n\n### 步骤 3：结论和行动\n\n问题是有效的。我将开始推导解答。\n\n问题要求两个量：表型 $y$ 的稳态方差和吸引子 $x^{\\ast}$ 附近的最慢弛豫时间常数。\n\n首先，我们在稳定不动点 $x^{\\ast}$ 附近对动力学进行线性化。势能 $U(x)$ 在 $x^{\\ast}$ 附近的二阶泰勒展开式为：\n$$\nU(x) \\approx U(x^{\\ast}) + (\\nabla U(x^{\\ast}))^{\\top}(x - x^{\\ast}) + \\frac{1}{2}(x - x^{\\ast})^{\\top} H (x - x^{\\ast})\n$$\n由于 $x^{\\ast}$ 是一个局部最小值，梯度 $\\nabla U(x^{\\ast})$ 为零。因此，SDE 中的力项 $-\\nabla U(x)$ 可以近似为：\n$$\n-\\nabla U(x) \\approx -H(x - x^{\\ast}) = -H\\xi\n$$\n偏差 $\\xi = x - x^{\\ast}$ 的 SDE 可以通过注意到 $d\\xi = dx$（因为 $x^{\\ast}$ 是一个常数向量）来获得。代入线性化的力可得：\n$$\nd\\xi = -H\\xi \\,dt + \\sqrt{2D}\\,dW_t\n$$\n这是一个多维 Ornstein-Uhlenbeck 过程，它描述了系统在稳定吸引子周围的涨落。\n\n**1. 表型 $y$ 的稳态方差**\n\n该系统的稳态概率分布是一个以 $\\xi = 0$ 为中心的多变量高斯分布。该分布可以从相应的 Fokker-Planck 方程推导得出，并且等价于玻尔兹曼分布 $P_{ss}(\\xi) \\propto \\exp(-U(\\xi)/D)$。使用势能的二次近似 $U(\\xi) \\approx \\frac{1}{2}\\xi^{\\top}H\\xi$，我们得到：\n$$\nP_{ss}(\\xi) \\propto \\exp\\left(-\\frac{\\xi^{\\top}H\\xi}{2D}\\right)\n$$\n这是一个均值为 $E[\\xi] = 0$、协方差矩阵为 $\\Sigma = E[\\xi\\xi^{\\top}]$ 的多变量正态分布。这种分布的标准形式是 $P(\\xi) \\propto \\exp(-\\frac{1}{2}\\xi^{\\top}\\Sigma^{-1}\\xi)$。通过比较，我们发现 $\\Sigma^{-1} = \\frac{H}{D}$，这意味着稳态协方差矩阵是：\n$$\n\\Sigma = D H^{-1}\n$$\n这个结果是该系统涨落-耗散定理的一种体现。\n\n表型定义为 $y = c^{\\top}\\xi$。其稳态方差 $\\text{Var}(y)$ 为：\n$$\n\\text{Var}(y) = E[(y - E[y])^2]\n$$\n由于 $E[y] = E[c^{\\top}\\xi] = c^{\\top}E[\\xi] = 0$，方差简化为：\n$$\n\\text{Var}(y) = E[y^2] = E[(c^{\\top}\\xi)(c^{\\top}\\xi)^{\\top}] = E[c^{\\top}\\xi\\xi^{\\top}c]\n$$\n根据期望的线性性质，这变为：\n$$\n\\text{Var}(y) = c^{\\top} E[\\xi\\xi^{\\top}] c = c^{\\top}\\Sigma c = c^{\\top}(D H^{-1})c = D c^{\\top}H^{-1}c\n$$\n为了计算这个值，我们首先需要求出黑塞矩阵 $H$ 的逆矩阵：\n$$\nH = \\begin{pmatrix} 5  1 \\\\ 1  3 \\end{pmatrix}\n$$\n行列式为 $\\det(H) = (5)(3) - (1)(1) = 14$。逆矩阵是：\n$$\nH^{-1} = \\frac{1}{\\det(H)} \\begin{pmatrix} 3  -1 \\\\ -1  5 \\end{pmatrix} = \\frac{1}{14} \\begin{pmatrix} 3  -1 \\\\ -1  5 \\end{pmatrix}\n$$\n现在我们用 $c = \\begin{pmatrix} 1 \\\\ -2 \\end{pmatrix}$ 计算二次型 $c^{\\top}H^{-1}c$：\n$$\nc^{\\top}H^{-1}c = \\begin{pmatrix} 1  -2 \\end{pmatrix} \\left( \\frac{1}{14} \\begin{pmatrix} 3  -1 \\\\ -1  5 \\end{pmatrix} \\right) \\begin{pmatrix} 1 \\\\ -2 \\end{pmatrix}\n$$\n$$\nc^{\\top}H^{-1}c = \\frac{1}{14} \\begin{pmatrix} 1  -2 \\end{pmatrix} \\begin{pmatrix} 3(1) + (-1)(-2) \\\\ -1(1) + 5(-2) \\end{pmatrix} = \\frac{1}{14} \\begin{pmatrix} 1  -2 \\end{pmatrix} \\begin{pmatrix} 5 \\\\ -11 \\end{pmatrix}\n$$\n$$\nc^{\\top}H^{-1}c = \\frac{1}{14} ( (1)(5) + (-2)(-11) ) = \\frac{1}{14} (5 + 22) = \\frac{27}{14}\n$$\n最后，我们乘以扩散系数 $D = 0.2 = \\frac{1}{5}$：\n$$\n\\text{Var}(y) = D (c^{\\top}H^{-1}c) = \\frac{1}{5} \\times \\frac{27}{14} = \\frac{27}{70}\n$$\n\n**2. 最慢弛豫时间常数**\n\n弛豫动力学由线性化 SDE 的确定性部分 $\\frac{d\\xi}{dt} = -H\\xi$ 控制。这个线性常微分方程组的解可以表示为本征模式的叠加。每个本征模式的时间演化由一个项 $\\exp(-\\lambda_i t)$ 来表征，其中 $\\lambda_i$ 是矩阵 $H$ 的特征值。弛豫时间常数是这些特征值的倒数，$\\tau_i = 1/\\lambda_i$。\n\n最慢弛豫时间 $\\tau_{\\text{slowest}}$ 对应于 $H$ 的最小特征值 $\\lambda_{\\min}$。我们通过求解特征方程 $\\det(H - \\lambda I) = 0$ 来找到特征值：\n$$\n\\det\\begin{pmatrix} 5-\\lambda  1 \\\\ 1  3-\\lambda \\end{pmatrix} = 0\n$$\n$$\n(5-\\lambda)(3-\\lambda) - (1)(1) = 0\n$$\n$$\n\\lambda^2 - 8\\lambda + 15 - 1 = 0\n$$\n$$\n\\lambda^2 - 8\\lambda + 14 = 0\n$$\n使用二次公式 $\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$：\n$$\n\\lambda = \\frac{8 \\pm \\sqrt{(-8)^2 - 4(1)(14)}}{2(1)} = \\frac{8 \\pm \\sqrt{64 - 56}}{2} = \\frac{8 \\pm \\sqrt{8}}{2} = \\frac{8 \\pm 2\\sqrt{2}}{2} = 4 \\pm \\sqrt{2}\n$$\n特征值是 $\\lambda_1 = 4 + \\sqrt{2}$ 和 $\\lambda_2 = 4 - \\sqrt{2}$。最小的特征值是：\n$$\n\\lambda_{\\min} = 4 - \\sqrt{2}\n$$\n最慢弛豫时间是 $\\lambda_{\\min}$ 的倒数：\n$$\n\\tau_{\\text{slowest}} = \\frac{1}{\\lambda_{\\min}} = \\frac{1}{4 - \\sqrt{2}}\n$$\n为了使分母有理化，我们将分子和分母同乘以共轭项 $4 + \\sqrt{2}$：\n$$\n\\tau_{\\text{slowest}} = \\frac{1}{4 - \\sqrt{2}} \\times \\frac{4 + \\sqrt{2}}{4 + \\sqrt{2}} = \\frac{4 + \\sqrt{2}}{4^2 - (\\sqrt{2})^2} = \\frac{4 + \\sqrt{2}}{16 - 2} = \\frac{4 + \\sqrt{2}}{14}\n$$\n问题要求以单行矩阵的形式给出 $y$ 的稳态方差和最慢弛豫时间常数。这两个值是 $\\frac{27}{70}$ 和 $\\frac{4 + \\sqrt{2}}{14}$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{27}{70}  \\frac{4+\\sqrt{2}}{14} \\end{pmatrix}}\n$$", "id": "3358338"}, {"introduction": "景观理论中的一个基本问题是，一个基因网络的复杂动态是否可以被一个标量势严格描述。本练习深入探讨了保证沃丁顿景观存在的数学条件——系统漂移场的无旋特性。您将实现一个计算方法来检验此条件，并且更重要的是，学习一种强大的最小二乘法，为在生物学中常见存在的非平衡系统构建一个近似景观[@problem_id:3358340]。", "problem": "在Waddington景观量化的背景下，考虑一个二维基因调控漂移场。设状态为$\\boldsymbol{x} = (x,y) \\in \\Omega \\subset \\mathbb{R}^2$，其确定性漂移场为$\\boldsymbol{f}(\\boldsymbol{x}) = (f_1(x,y), f_2(x,y))$。梯度Waddington景观由一个标量势$U(\\boldsymbol{x})$表示，当此势存在时，$\\boldsymbol{f}(\\boldsymbol{x}) = -\\nabla U(\\boldsymbol{x})$。从以下基本依据出发：(i) 向量微积分中的Poincaré引理，该引理指出，在一个单连通域上的连续可微向量场是保守的，当且仅当它是无旋的；(ii) 保守场的路径积分存在且与路径无关；以及(iii) 在Schwarz定理的假设下，混合二阶偏导数相等。根据这些，推导出$U(\\boldsymbol{x})$存在的关于$\\boldsymbol{f}$和$\\Omega$的充要条件。当此条件不满足时，定义一个最小二乘法程序来近似一个梯度场$\\widehat{\\boldsymbol{g}}(\\boldsymbol{x}) = \\nabla \\widehat{U}(\\boldsymbol{x})$，该梯度场在最小化采样点网格上的经验平方误差的意义下，能最好地匹配$\\boldsymbol{f}(\\boldsymbol{x})$。\n\n您的程序必须实现以下任务：\n\n- 给定$\\Omega = [-L,L] \\times [-L,L]$上的一个具有$N \\times N$个点的均匀方形网格，使用二阶有限差分近似标量旋度\n$$\\omega(x,y) = \\frac{\\partial f_2}{\\partial x}(x,y) - \\frac{\\partial f_1}{\\partial y}(x,y)$$ \n。当且仅当$\\max_{(x,y)\\in\\Omega} |\\omega(x,y)| \\le \\tau$时，声明势存在，其中$\\tau$是指定的数值容差。\n\n- 通过将$\\widehat{U}$参数化为最高3次的多项式基函数的线性组合，构造一个势$\\widehat{U}(x,y)$的最小二乘近似：\n$$\n\\widehat{U}(x,y) = \\sum_{k=1}^{K} \\theta_k \\, \\phi_k(x,y),\n$$\n其中基为\n$$\n\\{\\phi_k\\}_{k=1}^{K} = \\{1, x, y, x^2, xy, y^2, x^3, x^2 y, x y^2, y^3\\},\n$$\n因此\n$$\n\\nabla \\widehat{U}(x,y) = \\left(\\sum_{k=1}^{K} \\theta_k \\, \\frac{\\partial \\phi_k}{\\partial x}(x,y), \\ \\sum_{k=1}^{K} \\theta_k \\, \\frac{\\partial \\phi_k}{\\partial y}(x,y)\\right).\n$$\n通过在所有采样网格点$\\{(x_i,y_i)\\}_{i=1}^{M}$（其中$M = N^2$）上最小化正则化最小二乘目标函数来估计$\\boldsymbol{\\theta} \\in \\mathbb{R}^{K}$：\n$$\n\\min_{\\boldsymbol{\\theta} \\in \\mathbb{R}^{K}} \\ \\sum_{i=1}^{M} \\left\\| \\nabla \\widehat{U}(x_i,y_i) - \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2 \\ + \\ \\lambda \\, \\|\\boldsymbol{\\theta}\\|_2^2,\n$$\n其中$\\lambda \\ge 0$是给定的正则化参数。通过正规方程求解这个凸问题。\n\n- 通过归一化均方根误差来量化梯度近似的质量\n$$\n\\mathrm{NRMSE} \\ = \\ \\frac{\\sqrt{\\frac{1}{M} \\sum_{i=1}^{M} \\left\\| \\nabla \\widehat{U}(x_i,y_i) - \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2}}{\\sqrt{\\frac{1}{M} \\sum_{i=1}^{M} \\left\\| \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2}}.\n$$\n\n在单连通域$\\Omega$上，使用以下具有科学合理且自洽的向量场的测试套件：\n\n- 测试用例1（保守线性漂移）：$L = 1$，$N = 25$，$\\tau = 10^{-6}$，$\\lambda = 10^{-8}$，以及\n$$\nU(x,y) = \\frac{a}{2}(x^2 + y^2), \\quad a = 1, \\quad \\boldsymbol{f}(x,y) = -\\nabla U(x,y) = -a(x,y).\n$$\n\n- 测试用例2（纯旋转非保守漂移）：$L = 1$，$N = 25$，$\\tau = 10^{-6}$，$\\lambda = 10^{-8}$，以及\n$$\n\\boldsymbol{f}(x,y) = \\big(-y, \\ x\\big).\n$$\n\n- 测试用例3（混合保守与旋转漂移）：$L = 1$，$N = 25$，$\\tau = 10^{-6}$，$\\lambda = 10^{-8}$，以及\n$$\n\\boldsymbol{f}(x,y) = -a(x,y) + c\\big(-y,\\ x\\big), \\quad a = 1, \\ c = \\tfrac{1}{2}.\n$$\n\n对于每个测试用例，您的程序必须：\n\n- 根据旋度阈值$\\tau$计算指示势是否存在的布尔值。\n- 计算最小二乘梯度近似$\\nabla \\widehat{U}$相对于$\\boldsymbol{f}$的$\\mathrm{NRMSE}$。\n\n最终输出格式要求：\n\n- 将输出表示为单行，其中包含一个扁平列表，条目按以下顺序排列\n$$\n[\\text{exists}_1, \\ \\mathrm{NRMSE}_1, \\ \\text{exists}_2, \\ \\mathrm{NRMSE}_2, \\ \\text{exists}_3, \\ \\mathrm{NRMSE}_3],\n$$\n其中$\\text{exists}_j$是一个布尔值，$\\mathrm{NRMSE}_j$是一个四舍五入到$6$位小数的浮点数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，例如$[{\\tt True},0.000001,{\\tt False},0.707107,{\\tt False},0.408248]$。\n- 此问题不涉及物理单位；所有量均为无量纲量。", "solution": "我们从向量微积分的基本事实开始，这些事实是量化Waddington景观的基础。如果漂移场$\\boldsymbol{f}(\\boldsymbol{x})$可以表示为$\\boldsymbol{f}(\\boldsymbol{x}) = -\\nabla U(\\boldsymbol{x})$（对于某个标量势$U$），则存在一个梯度Waddington景观。Poincaré引理指出，在单连通域$\\Omega \\subset \\mathbb{R}^2$上，一个连续可微的向量场$\\boldsymbol{f}$是保守的，当且仅当其旋度处处为零：$\\nabla \\times \\boldsymbol{f} = \\boldsymbol{0}$。在二维情况下，这简化为标量条件\n$$\n\\omega(x,y) \\equiv \\frac{\\partial f_2}{\\partial x}(x,y) - \\frac{\\partial f_1}{\\partial y}(x,y) = 0 \\quad \\text{for all } (x,y) \\in \\Omega.\n$$\n这等价于势$U$的混合偏导数相等，因为如果$\\boldsymbol{f} = -\\nabla U$，那么$\\frac{\\partial f_2}{\\partial x} = -\\frac{\\partial^2 U}{\\partial x \\partial y}$且$\\frac{\\partial f_1}{\\partial y} = -\\frac{\\partial^2 U}{\\partial y \\partial x}$，而Schwarz定理在标准光滑性条件下保证$\\frac{\\partial^2 U}{\\partial x \\partial y} = \\frac{\\partial^2 U}{\\partial y \\partial x}$。反之，如果$\\omega \\equiv 0$且$\\Omega$是单连通的，那么线积分$\\int_{\\gamma} \\boldsymbol{f} \\cdot d\\boldsymbol{\\ell}$对于任意连接两点的曲线$\\gamma$都与路径无关，并且可以通过$U(\\boldsymbol{x}) = -\\int_{\\gamma_{\\boldsymbol{x}_0 \\to \\boldsymbol{x}}} \\boldsymbol{f} \\cdot d\\boldsymbol{\\ell}$来定义$U$（相差一个加性常数）。\n\n在实践中，我们拥有的是网格上的采样数据，因此我们通过有限差分来近似旋度。在一个两个方向上间距均为$h$的均匀网格上，我们使用内部的二阶中心差分来近似$\\frac{\\partial f_2}{\\partial x}$和$\\frac{\\partial f_1}{\\partial y}$。将数值旋度记为$\\widehat{\\omega}(x_i,y_j)$。如果$\\max_{i,j} |\\widehat{\\omega}(x_i,y_j)| \\le \\tau$，我们声明势存在，其中$\\tau$是一个考虑了离散化和舍入误差的指定容差。\n\n当旋度条件不满足时，能够精确匹配$\\boldsymbol{f}$的标量势无法全局存在。尽管如此，在Waddington景观量化中，获得对采样域上$\\boldsymbol{f}$的最佳梯度近似是很有用的。这是将$\\boldsymbol{f}$投影到梯度场子空间上的一个实例，也是Helmholtz–Hodge分解的一个特例。我们通过在由基函数$\\{\\phi_k\\}_{k=1}^{K}$张成的有限维函数空间中寻找$\\widehat{U}$，并使用Tikhonov正则化最小化$\\nabla \\widehat{U}$和$\\boldsymbol{f}$之间的经验平方差异来实现：\n$$\n\\min_{\\boldsymbol{\\theta}\\in\\mathbb{R}^{K}} \\sum_{i=1}^{M} \\left\\| \\nabla \\widehat{U}(x_i,y_i) - \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2 + \\lambda \\|\\boldsymbol{\\theta}\\|_2^2,\n$$\n其中$\\widehat{U}(x,y) = \\sum_{k=1}^{K} \\theta_k \\phi_k(x,y)$。将$\\nabla \\widehat{U}(x_i,y_i)$写成$\\boldsymbol{\\theta}$的线性函数，得到一个线性最小二乘问题。定义设计矩阵$A_x \\in \\mathbb{R}^{M \\times K}$和$A_y \\in \\mathbb{R}^{M \\times K}$，其元素为\n$$\n(A_x)_{i,k} = \\frac{\\partial \\phi_k}{\\partial x}(x_i,y_i), \\qquad (A_y)_{i,k} = \\frac{\\partial \\phi_k}{\\partial y}(x_i,y_i).\n$$\n令$A \\in \\mathbb{R}^{2M \\times K}$为$A_x$和$A_y$的垂直堆叠，令$\\boldsymbol{b} \\in \\mathbb{R}^{2M}$为堆叠观测到的漂移分量的向量：$\\boldsymbol{b} = (f_1(x_1,y_1),\\ldots,f_1(x_M,y_M), f_2(x_1,y_1),\\ldots,f_2(x_M,y_M))^\\top$。问题变为\n$$\n\\min_{\\boldsymbol{\\theta}} \\ \\|A \\boldsymbol{\\theta} - \\boldsymbol{b}\\|_2^2 + \\lambda \\|\\boldsymbol{\\theta}\\|_2^2,\n$$\n其最优性条件得出正规方程\n$$\n(A^\\top A + \\lambda I)\\boldsymbol{\\theta} = A^\\top \\boldsymbol{b}.\n$$\n我们使用数值稳定的线性求解器求解这些方程以得到$\\boldsymbol{\\theta}$。得到$\\boldsymbol{\\theta}$后，我们在每个网格点上计算$\\nabla \\widehat{U}$并计算归一化均方根误差\n$$\n\\mathrm{NRMSE} = \\frac{\\sqrt{\\frac{1}{M} \\sum_{i=1}^{M} \\left\\| \\nabla \\widehat{U}(x_i,y_i) - \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2}}{\\sqrt{\\frac{1}{M} \\sum_{i=1}^{M} \\left\\| \\boldsymbol{f}(x_i,y_i) \\right\\|_2^2}}.\n$$\n\n我们将此程序应用于指定的测试套件：\n\n- 测试用例1使用从二次势$U(x,y) = \\frac{a}{2}(x^2+y^2)$（其中$a=1$）导出的保守线性漂移，因此$\\boldsymbol{f}(x,y) = -(x,y)$。域$\\Omega$是单连通的，且$\\omega \\equiv 0$，所以势存在。多项式基包括$x^2$和$y^2$，因此最小二乘近似可以精确地恢复梯度场（在数值精度范围内）。因此，我们预期布尔值为${\\tt True}$，$\\mathrm{NRMSE}$接近$0$。\n\n- 测试用例2使用纯旋转场$\\boldsymbol{f}(x,y) = (-y, x)$，其$\\omega(x,y) \\equiv 2$，所以势不存在。最小二乘梯度近似将此场投影到所选基张成的梯度上。由于在对称域上，此场在连续$L^2$意义下与无旋场正交，我们预期会有显著的残差。因此，我们预期布尔值为${\\tt False}$，$\\mathrm{NRMSE}$明显不为$0$。\n\n- 测试用例3混合了测试用例1的保守场和一个大小为$c = \\tfrac{1}{2}$的旋转分量。旋度是常数且非零，所以不存在精确的势，但最小二乘法程序将有效捕捉保守分量，导致一个中等的$\\mathrm{NRMSE}$。因此，我们预期布尔值为${\\tt False}$，$\\mathrm{NRMSE}$介于测试用例1和2之间。\n\n实现细节包括：\n\n- 在$\\Omega = [-L,L]^2$上构建网格，其中$L=1$，$N=25$，得到间距$h = \\frac{2L}{N-1}$。\n- 使用二阶中心差分计算数值旋度，即$\\frac{\\partial f_2}{\\partial x} \\approx \\frac{f_2(x+h,y) - f_2(x-h,y)}{2h}$和$\\frac{\\partial f_1}{\\partial y} \\approx \\frac{f_1(x,y+h) - f_1(x,y-h)}{2h}$，并对边界进行一致处理。\n- 通过正规方程进行最小二乘估计，其中$\\lambda = 10^{-8}$。\n- 每个测试用例的最终输出是布尔存在性决策和四舍五入到6位小数的$\\mathrm{NRMSE}$，汇总成一个打印在单行上的扁平列表。\n\n这些步骤整合了Waddington势存在的理论条件和一种在无旋条件不满足时近似漂移场梯度分量的有原则的数值方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef make_grid(L, N):\n    xs = np.linspace(-L, L, N)\n    ys = np.linspace(-L, L, N)\n    X, Y = np.meshgrid(xs, ys, indexing='xy')\n    return X, Y\n\ndef field_conservative_linear(X, Y, a=1.0):\n    # f = -a * (x, y)\n    f1 = -a * X\n    f2 = -a * Y\n    return f1, f2\n\ndef field_rotational(X, Y):\n    # f = (-y, x)\n    f1 = -Y\n    f2 = X\n    return f1, f2\n\ndef field_mixed(X, Y, a=1.0, c=0.5):\n    f1c, f2c = field_conservative_linear(X, Y, a=a)\n    f1r, f2r = field_rotational(X, Y)\n    return f1c + c * f1r, f2c + c * f2r\n\ndef numerical_curl(f1, f2, L, N):\n    # Compute curl omega = d f2 / dx - d f1 / dy using central differences\n    # Grid spacing\n    h = 2 * L / (N - 1)\n    # Use numpy.gradient with spacing h (second-order in interior)\n    df2_dx = np.gradient(f2, h, axis=1)\n    df1_dy = np.gradient(f1, h, axis=0)\n    omega = df2_dx - df1_dy\n    return omega\n\ndef build_basis_and_grads(X, Y):\n    # Returns gradients of basis functions evaluated at all points\n    # Basis: [1, x, y, x^2, x y, y^2, x^3, x^2 y, x y^2, y^3]\n    x = X.ravel()\n    y = Y.ravel()\n    ones = np.ones_like(x)\n\n    # Partial derivatives of basis functions\n    # d/dx\n    dphidx = np.stack([\n        np.zeros_like(x),       # d(1)/dx\n        ones,                   # d(x)/dx\n        np.zeros_like(x),       # d(y)/dx\n        2.0 * x,                # d(x^2)/dx\n        y,                      # d(x*y)/dx\n        np.zeros_like(x),       # d(y^2)/dx\n        3.0 * x**2,             # d(x^3)/dx\n        2.0 * x * y,            # d(x^2 y)/dx\n        y**2,                   # d(x y^2)/dx\n        np.zeros_like(x),       # d(y^3)/dx\n    ], axis=1)  # shape (M, K)\n\n    # d/dy\n    dphidy = np.stack([\n        np.zeros_like(y),       # d(1)/dy\n        np.zeros_like(y),       # d(x)/dy\n        ones,                   # d(y)/dy\n        np.zeros_like(y),       # d(x^2)/dy\n        x,                      # d(x*y)/dy\n        2.0 * y,                # d(y^2)/dy\n        np.zeros_like(y),       # d(x^3)/dy\n        x**2,                   # d(x^2 y)/dy\n        2.0 * x * y,            # d(x y^2)/dy\n        3.0 * y**2,             # d(y^3)/dy\n    ], axis=1)\n\n    return dphidx, dphidy  # each is (M, K)\n\ndef fit_potential_least_squares(X, Y, f1, f2, lam=1e-8):\n    # Build design matrix A and target b for ridge regression\n    dphidx, dphidy = build_basis_and_grads(X, Y)  # (M, K)\n    M, K = dphidx.shape\n\n    A = np.vstack([dphidx, dphidy])  # (2M, K)\n    b = np.concatenate([f1.ravel(), f2.ravel()])  # (2M,)\n\n    # Solve (A^T A + lam I) theta = A^T b\n    AtA = A.T @ A\n    Atb = A.T @ b\n    if lam > 0:\n        AtA = AtA + lam * np.eye(K)\n    theta = np.linalg.solve(AtA, Atb)\n    return theta\n\ndef eval_gradient_from_theta(X, Y, theta):\n    dphidx, dphidy = build_basis_and_grads(X, Y)  # (M, K)\n    gx = (dphidx @ theta).reshape(X.shape)\n    gy = (dphidy @ theta).reshape(Y.shape)\n    return gx, gy\n\ndef nrmse(g1, g2, f1, f2):\n    # Compute normalized RMSE between gradient g and field f\n    diff_sq = (g1 - f1)**2 + (g2 - f2)**2\n    f_sq = f1**2 + f2**2\n    mse = np.mean(diff_sq)\n    denom = np.mean(f_sq)\n    # Handle degenerate case where field is zero everywhere\n    if denom == 0:\n        return 0.0 if mse == 0 else np.inf\n    return float(np.sqrt(mse / denom))\n\ndef evaluate_case(field_func, params, L=1.0, N=25, tau=1e-6, lam=1e-8):\n    X, Y = make_grid(L, N)\n    f1, f2 = field_func(X, Y, **params)\n    omega = numerical_curl(f1, f2, L=L, N=N)\n    exists = bool(np.max(np.abs(omega)) = tau)\n    theta = fit_potential_least_squares(X, Y, f1, f2, lam=lam)\n    g1, g2 = eval_gradient_from_theta(X, Y, theta)\n    err = nrmse(g1, g2, f1, f2)\n    return exists, err\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each test case is a tuple: (field_func, params_dict)\n        (field_conservative_linear, {\"a\": 1.0}),\n        (lambda X, Y, **kw: field_rotational(X, Y), {}),\n        (field_mixed, {\"a\": 1.0, \"c\": 0.5}),\n    ]\n    L = 1.0\n    N = 25\n    tau = 1e-6\n    lam = 1e-8\n\n    results = []\n    for field_func, params in test_cases:\n        exists, err = evaluate_case(field_func, params, L=L, N=N, tau=tau, lam=lam)\n        # Append boolean and rounded error\n        results.append(exists)\n        results.append(round(err, 6))\n\n    # Convert booleans and floats to string as required\n    def to_str(x):\n        if isinstance(x, bool):\n            return \"True\" if x else \"False\"\n        if isinstance(x, float):\n            # Ensure fixed formatting with up to 6 decimals, no scientific notation if possible\n            return f\"{x:.6f}\"\n        return str(x)\n\n    print(f\"[{','.join(to_str(r) for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3358340"}, {"introduction": "识别细胞命运决定中的“不归点”至关重要。虽然势垒的顶点提供了一个静态的地标，但真正的动态分界线则更为微妙。本练习引入了“到达函数”（committor function）这一统计物理学中的强大概念，它定义了系统向目标态转变的概率，并指导您计算当此概率恰好为二分之一时的真实过渡态[@problem_id:3358344]。", "problem": "你的任务是推导、实现和测试一种计算方法，该方法使用提交函数（committor functions）来量化 Waddington 景观，并在一个一维随机细胞命运模型中识别过渡态。该模型是过阻尼朗之万随机微分方程（SDE），在计算系统生物学中被广泛用于表示势能景观上的噪声动力学。该景观由一个多项式自由能类势给出，其两个局部极小值代表了两个细胞命运盆地。\n\n从基本定义和定律开始：\n- 单坐标 $x(t)$ 的过阻尼朗之万随机微分方程（SDE）为 $dx(t) = b(x) \\, dt + \\sqrt{2 D} \\, dW(t)$，其中 $b(x)$ 是确定性漂移，$D$ 是扩散系数（噪声强度），$W(t)$ 是一个标准维纳过程。\n- 对于 Waddington 类势 $U(x)$ 上的梯度动力学，漂移为 $b(x) = - \\frac{dU}{dx}$。\n- 作用于光滑检验函数 $f(x)$ 的相关后向 Kolmogorov 算子（无穷小生成元）是 $L f(x) = b(x) \\, \\frac{df}{dx}(x) + D \\, \\frac{d^2 f}{dx^2}(x)$。\n- 提交函数 $q(x)$ 定义为从 $x$ 开始的轨迹在到达盆 $A$ 之前先到达盆 $B$ 的概率，它在盆之间的区域内满足后向方程 $L q(x) = 0$，并具有吸收边界条件 $q(x_A) = 0$ 和 $q(x_B) = 1$，其中 $x_A$ 和 $x_B$ 分别是左右两个盆的极小值位置。\n- 在这种一维设定中，过渡态被定义为满足 $q(x_{\\mathrm{TS}}) = \\tfrac{1}{2}$ 的构型 $x_{\\mathrm{TS}}$，它在操作上代表了反应轨迹上盆之间的分割面。\n\n你的任务：\n1. 从上述原理出发，为一维梯度漂移 $b(x) = - \\frac{dU}{dx}$ 和常数 $D$ 的情况，在边界条件 $q(x_A) = 0$ 和 $q(x_B) = 1$ 下，推导提交函数 $q(x)$ 的一个可实现的表达式或数值程序。\n2. 对于每个指定的势和参数集，数值计算：\n   - 在初始条件 $x_0$ 处的提交函数值 $q(x_0)$。\n   - 由 $q(x_{\\mathrm{TS}}) = \\tfrac{1}{2}$ 定义的过渡态位置 $x_{\\mathrm{TS}}$。\n   - 定义为 $U(x)$ 在 $x_A$ 和 $x_B$ 之间唯一的局部极大值的势垒顶点位置 $x_{\\mathrm{bar}}$（通过 $U'(x_{\\mathrm{bar}}) = 0$ 和 $U''(x_{\\mathrm{bar}})  0$ 确定）。\n   - 绝对偏差 $\\Delta = \\left| x_{\\mathrm{TS}} - x_{\\mathrm{bar}} \\right|$。\n3. 实现一个单一程序，为所有测试用例计算这些量，并以要求的最终格式输出结果。\n\n景观和测试套件：\n- 考虑由 $U(x) = \\alpha \\, \\frac{x^4}{4} - \\beta \\, \\frac{x^2}{2} + \\gamma \\, x$ 参数化的 Waddington 类势，其漂移为 $b(x) = - U'(x) = - \\left( \\alpha \\, x^3 - \\beta \\, x + \\gamma \\right)$，扩散系数 $D$ 为常数。\n- 盆地位置 $x_A$ 和 $x_B$ 分别是 $U(x)$ 的最左和最右的局部极小值。它们之间的势垒顶点 $x_{\\mathrm{bar}}$ 是局部极大值。\n- 对于每种情况，程序应通过求解 $U'(x) = 0$ 来确定临界点，通过 $U''(x)$ 对每个点进行分类，然后从第一性原理计算 $q(x)$，而不调用任何未从上述基础推导出的快捷公式。\n\n测试用例：\n- 用例 $1$（对称双阱，低噪声）：$\\alpha = 1$，$\\beta = 1$，$\\gamma = 0$，$D = 0.05$，$x_0 = 0.2$。\n- 用例 $2$（对称双阱，高噪声）：$\\alpha = 1$，$\\beta = 1$，$\\gamma = 0$，$D = 1.0$，$x_0 = 0.2$。\n- 用例 $3$（非对称双阱，中等倾斜）：$\\alpha = 1$，$\\beta = 1$，$\\gamma = 0.3$, $D = 0.05$, $x_0 = 0.0$。\n- 用例 $4$（非对称双阱，中等倾斜反向）：$\\alpha = 1$，$\\beta = 1$，$\\gamma = -0.3$, $D = 0.05$, $x_0 = 0.0$。\n\n输出规格：\n- 对于每个用例，返回一个包含四个浮点数的列表 $[ q(x_0), x_{\\mathrm{TS}}, x_{\\mathrm{bar}}, \\Delta ]$。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，形式为这些列表的逗号分隔列表，并用方括号括起来，例如：$[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$。\n- 不涉及物理单位；所有量均为无量纲实数。", "solution": "用户提供了一个来自计算系统生物学领域的、定义明确的问题陈述。任务是推导并实现一个方法，使用提交函数（committor function）的概念来量化一个一维 Waddington 类景观。\n\n### 问题验证\n\n**步骤 1：提取给定条件**\n- **SDE**：过阻尼朗之万随机微分方程（SDE）由 $dx(t) = b(x) \\, dt + \\sqrt{2 D} \\, dW(t)$ 给出，其中 $b(x)$ 是漂移，$D$ 是扩散系数，$W(t)$ 是标准维纳过程。\n- **漂移**：对于梯度动力学，漂移为 $b(x) = - \\frac{dU}{dx}$，其中 $U(x)$ 是势。\n- **后向 Kolmogorov 算子**：作用于函数 $f(x)$ 的算子为 $L f(x) = b(x) \\, \\frac{df}{dx}(x) + D \\, \\frac{d^2 f}{dx^2}(x)$。\n- **提交函数 $q(x)$**：定义为从 $x$ 开始的轨迹在到达盆 $A$ 之前先到达盆 $B$ 的概率。它满足后向方程 $L q(x) = 0$，边界条件为 $q(x_A) = 0$ 和 $q(x_B) = 1$，其中 $x_A$ 和 $x_B$ 是两个盆的极小值。\n- **过渡态 $x_{\\mathrm{TS}}$**：由条件 $q(x_{\\mathrm{TS}}) = \\tfrac{1}{2}$ 定义。\n- **势函数**：$U(x) = \\alpha \\, \\frac{x^4}{4} - \\beta \\, \\frac{x^2}{2} + \\gamma \\, x$。漂移为 $b(x) = - \\left( \\alpha \\, x^3 - \\beta \\, x + \\gamma \\right)$。\n- **势垒顶点 $x_{\\mathrm{bar}}$**：$U(x)$ 在 $x_A$ 和 $x_B$ 之间的局部极大值，通过求解 $U'(x_{\\mathrm{bar}}) = 0$ 且 $U''(x_{\\mathrm{bar}})  0$ 找到。\n- **待计算量**：$q(x_0)$, $x_{\\mathrm{TS}}$, $x_{\\mathrm{bar}}$, 以及 $\\Delta = \\left| x_{\\mathrm{TS}} - x_{\\mathrm{bar}} \\right|$。\n- **测试用例**：\n    - 用例 1：$\\alpha = 1$, $\\beta = 1$, $\\gamma = 0$, $D = 0.05$, $x_0 = 0.2$。\n    - 用例 2：$\\alpha = 1$, $\\beta = 1$, $\\gamma = 0$, $D = 1.0$, $x_0 = 0.2$。\n    - 用例 3：$\\alpha = 1$, $\\beta = 1$, $\\gamma = 0.3$, $D = 0.05$, $x_0 = 0.0$。\n    - 用例 4：$\\alpha = 1$, $\\beta = 1$, $\\gamma = -0.3$, $D = 0.05$, $x_0 = 0.0$。\n\n**步骤 2：使用提取的给定条件进行验证**\n该问题具有科学依据、定义明确且客观。它基于随机微积分和统计力学的基本原理在计算生物学中的应用。定义是标准的，数学任务——求解一个带边界条件的二阶常微分方程（ODE）——是一个定义明确的边值问题。势函数是双稳态的典型模型。每个测试用例都提供了所有必要的参数，不存在矛盾或模糊之处。该问题是该领域的标准练习，并非微不足道，需要解析推导和数值实现。\n\n**步骤 3：结论与行动**\n问题有效。详细解答如下。\n\n### 提交函数的推导\n\n提交函数 $q(x)$ 满足后向 Kolmogorov 方程 $Lq(x) = 0$。代入算子 $L$ 和梯度漂移 $b(x) = -U'(x) = -\\frac{dU}{dx}$ 的表达式，我们得到控制微分方程：\n$$\nD \\frac{d^2q}{dx^2}(x) - \\frac{dU}{dx}(x) \\frac{dq}{dx}(x) = 0\n$$\n这是一个关于 $q(x)$ 的二阶线性齐次常微分方程。为了求解它，我们可以引入一个中间变量 $p(x) = \\frac{dq}{dx}$。方程变成一个关于 $p(x)$ 的一阶可分离常微分方程：\n$$\nD \\frac{dp}{dx} = \\frac{dU}{dx} p(x)\n$$\n分离变量，假设 $p(x) \\neq 0$：\n$$\n\\frac{dp}{p} = \\frac{1}{D} \\frac{dU}{dx} dx\n$$\n对两边积分得到：\n$$\n\\ln|p(x)| = \\frac{1}{D} U(x) + C_0\n$$\n其中 $C_0$ 是一个积分常数。对两边取指数给出：\n$$\np(x) = C_1 e^{U(x)/D}\n$$\n其中 $C_1 = \\pm e^{C_0}$ 是一个新的常数。现在，我们代回 $p(x) = \\frac{dq}{dx}$：\n$$\n\\frac{dq}{dx} = C_1 e^{U(x)/D}\n$$\n为了找到 $q(x)$，我们将此表达式关于 $x$ 从左盆极小值 $x_A$ 积分到一个点 $x$：\n$$\nq(x) - q(x_A) = \\int_{x_A}^{x} C_1 e^{U(s)/D} ds\n$$\n现在我们应用边界条件，$q(x_A) = 0$ 和 $q(x_B) = 1$。\n应用第一个条件，$q(x_A) = 0$：\n$$\nq(x) - 0 = C_1 \\int_{x_A}^{x} e^{U(s)/D} ds \\implies q(x) = C_1 \\int_{x_A}^{x} e^{U(s)/D} ds\n$$\n应用第二个条件，$q(x_B) = 1$：\n$$\n1 = C_1 \\int_{x_A}^{x_B} e^{U(s)/D} ds\n$$\n解出常数 $C_1$：\n$$\nC_1 = \\frac{1}{\\int_{x_A}^{x_B} e^{U(s)/D} ds}\n$$\n将 $C_1$ 的表达式代回 $q(x)$ 的方程，我们得到提交函数的最终解析表达式：\n$$\nq(x) = \\frac{\\int_{x_A}^{x} e^{U(s)/D} ds}{\\int_{x_A}^{x_B} e^{U(s)/D} ds}\n$$\n这个表达式是精确的，并且可以使用数值积分方法来评估积分，从而进行数值实现。\n\n### 计算流程\n\n对于每个测试用例，执行以下步骤：\n\n1.  **识别临界点**：势 $U(x) = \\alpha \\frac{x^4}{4} - \\beta \\frac{x^2}{2} + \\gamma x$ 的临界点是其导数 $U'(x) = \\alpha x^3 - \\beta x + \\gamma = 0$ 的根。解这个三次方程以找到临界点。二阶导数 $U''(x) = 3\\alpha x^2 - \\beta$ 用于对它们进行分类：如果 $U''(x_c)  0$，则点 $x_c$ 是一个局部极小值；如果 $U''(x_c)  0$，则是一个局部极大值。对于给定的参数，有三个不同的实根。最左边和最右边的根分别是盆地极小值，记为 $x_A$ 和 $x_B$，中间的根是势垒顶点 $x_{\\mathrm{bar}}$。\n\n2.  **计算提交函数值 $q(x_0)$**：使用推导出的公式，计算在给定点 $x_0$ 处的提交函数值。积分是数值计算的。令被积函数为 $I(s) = e^{U(s)/D}$。那么：\n    $$\n    q(x_0) = \\frac{\\int_{x_A}^{x_0} I(s) ds}{\\int_{x_A}^{x_B} I(s) ds}\n    $$\n\n3.  **找到过渡态 $x_{\\mathrm{TS}}$**：过渡态位置 $x_{\\mathrm{TS}}$ 由 $q(x_{\\mathrm{TS}}) = \\frac{1}{2}$ 定义。这转化为求解以下关于 $x_{\\mathrm{TS}}$ 的方程：\n    $$\n    \\frac{\\int_{x_A}^{x_{\\mathrm{TS}}} e^{U(s)/D} ds}{\\int_{x_A}^{x_B} e^{U(s)/D} ds} = \\frac{1}{2}\n    $$\n    这等价于找到函数 $F(x) = \\left( \\int_{x_A}^{x} e^{U(s)/D} ds \\right) - \\frac{1}{2} \\left( \\int_{x_A}^{x_B} e^{U(s)/D} ds \\right) = 0$ 的根。由于被积函数 $e^{U(s)/D}$ 是严格正的，积分是其上限的单调递增函数。因此，在区间 $(x_A, x_B)$ 中存在唯一的根 $x_{\\mathrm{TS}}$，并且可以使用像 Brent-Dekker 方法这样的数值求根算法高效地找到它。\n\n4.  **计算偏差 $\\Delta$**：过渡态位置与势垒顶点之间的绝对差值计算为 $\\Delta = |x_{\\mathrm{TS}} - x_{\\mathrm{bar}}|$。这个值量化了由于势的不对称性或显著噪声的存在而导致的动力学分割面 ($x_{\\mathrm{TS}}$) 相对于静态分割面 ($x_{\\mathrm{bar}}$) 的偏移。在对称、低噪声极限下，$\\Delta$ 趋近于 $0$。\n\n这个流程在提供的 Python 代码中实现，该代码系统地处理每个测试用例并计算所需的量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, optimize\n\ndef solve():\n    \"\"\"\n    Derives, implements, and tests a computational method for quantifying\n    the Waddington landscape using committor functions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, beta, gamma, D, x0)\n        (1.0, 1.0, 0.0, 0.05, 0.2),\n        (1.0, 1.0, 0.0, 1.0, 0.2),\n        (1.0, 1.0, 0.3, 0.05, 0.0),\n        (1.0, 1.0, -0.3, 0.05, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Format each inner list of floats to a string representation.\n    formatted_results = [\n        f\"[{','.join(f'{val:.8f}' for val in res)}]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef process_case(alpha, beta, gamma, D, x0):\n    \"\"\"\n    Processes a single test case to compute the required quantities.\n    \"\"\"\n    \n    # 1. Define potential landscape U(x) and its derivatives\n    U = lambda x: alpha * x**4 / 4 - beta * x**2 / 2 + gamma * x\n    U_prime_coeffs = [alpha, 0, -beta, gamma] # for alpha*x^3 - beta*x + gamma\n    U_double_prime = lambda x: 3 * alpha * x**2 - beta\n\n    # 2. Find critical points (x_A, x_bar, x_B)\n    # Roots of U'(x) = 0\n    crit_points = np.roots(U_prime_coeffs)\n    \n    # Filter for real roots and sort them\n    real_crit_points = sorted([p.real for p in crit_points if np.isclose(p.imag, 0)])\n\n    # Classify critical points using the second derivative test\n    minima = []\n    maxima = []\n    for cp in real_crit_points:\n        if U_double_prime(cp) > 0:\n            minima.append(cp)\n        elif U_double_prime(cp)  0:\n            maxima.append(cp)\n\n    # For a double-well potential, we expect two minima and one maximum\n    if len(minima) != 2 or len(maxima) != 1:\n        raise ValueError(f\"Unexpected number of critical points for case with params {alpha, beta, gamma}.\")\n\n    x_A = min(minima)\n    x_B = max(minima)\n    x_bar = maxima[0]\n\n    # 3. Define the integrand and the committor function q(x)\n    integrand = lambda s: np.exp(U(s) / D)\n\n    # The denominator of the committor function formula\n    total_integral, _ = integrate.quad(integrand, x_A, x_B)\n\n    def q(x):\n        # The numerator of the committor function formula\n        numerator_integral, _ = integrate.quad(integrand, x_A, x)\n        return numerator_integral / total_integral\n\n    # 4. Compute q(x0)\n    q_x0 = q(x0)\n    \n    # 5. Find the transition state x_TS where q(x) = 1/2\n    # This involves finding the root of q(x) - 0.5 = 0\n    # The function is guaranteed to be monotonic, so a robust solver can be used.\n    try:\n        x_TS = optimize.brentq(lambda x: q(x) - 0.5, x_A, x_B)\n    except ValueError:\n        # Handle edge cases where x_TS might be at the boundary\n        if np.isclose(q(x_A) - 0.5, 0):\n            x_TS = x_A\n        elif np.isclose(q(x_B) - 0.5, 0):\n            x_TS = x_B\n        else:\n            raise\n\n    # 6. Compute the discrepancy Delta\n    delta = np.abs(x_TS - x_bar)\n    \n    return [q_x0, x_TS, x_bar, delta]\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3358344"}]}