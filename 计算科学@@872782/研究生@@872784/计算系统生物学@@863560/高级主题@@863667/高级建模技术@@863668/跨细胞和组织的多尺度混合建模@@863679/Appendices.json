{"hands_on_practices": [{"introduction": "在多尺度系统中，不同过程通常在截然不同的时间尺度上发生，例如缓慢的细胞状态更新与快速的分子扩散。理解这些时间尺度之间的分离是设计高效混合模型的关键。本练习 ([@problem_id:3330605]) 将指导您计算反应扩散系统和细胞过程的相关时间尺度，并基于此判断是否可以使用计算成本更低的“准静态”耦合策略，这是多尺度建模决策中的一个核心问题。", "problem": "考虑一个混合多尺度模型，该模型将细胞外形态发生素的连续反应扩散场与在离散时间更新其内部状态的基于智能体的细胞耦合起来。在一个长度为 $L$ 的局部一维组织薄片中，形态发生素浓度 $c(x,t)$ 根据线性反应扩散方程演化\n$$\n\\frac{\\partial c}{\\partial t} \\;=\\; D\\,\\frac{\\partial^{2} c}{\\partial x^{2}} \\;-\\; k\\,c \\;+\\; s(x,t),\n$$\n在 $x=0$ 和 $x=L$ 处具有零通量（Neumann）边界条件。源项 $s(x,t)$ 有界且足够平滑，因此围绕准稳态分布的线性稳定性由齐次算子决定。每个智能体（细胞）在特征时间尺度 $T_{\\mathrm{cell}}$ 上更新其细胞内状态，细胞的空间离散性由嵌入在特征范围为 $L_{\\mathrm{tissue}}$ 的组织中的典型细胞直径 $d_{\\mathrm{cell}}$ 来表征。假设在有界扰动后，形态发生素场回到准稳态的有效弛豫过程由齐次算子的最慢衰减模式主导。\n\n使用基本的反应扩散动力学和一级反应动力学，从控制方程和边界条件中推导出主导的连续场弛豫时间 $\\tau_{\\mathrm{PDE}}$。将时间尺度分离参数定义为 $\\epsilon_{t} \\equiv \\tau_{\\mathrm{PDE}} / T_{\\mathrm{cell}}$，长度尺度分离参数定义为 $\\epsilon_{x} \\equiv d_{\\mathrm{cell}} / L_{\\mathrm{tissue}}$。令总分离参数为 $\\epsilon \\equiv \\max\\{\\epsilon_{t}, \\epsilon_{x}\\}$。计算以下参数集下 $\\epsilon$ 的数值：\n- $D \\;=\\; 2.0 \\times 10^{-9}\\ \\mathrm{m^{2}\\,s^{-1}}$，\n- $k \\;=\\; 1.0 \\times 10^{-1}\\ \\mathrm{s^{-1}}$，\n- $L \\;=\\; 2.0 \\times 10^{-4}\\ \\mathrm{m}$，\n- $T_{\\mathrm{cell}} \\;=\\; 3.600 \\times 10^{3}\\ \\mathrm{s}$，\n- $d_{\\mathrm{cell}} \\;=\\; 2.0 \\times 10^{-5}\\ \\mathrm{m}$，\n- $L_{\\mathrm{tissue}} \\;=\\; 2.0 \\times 10^{-3}\\ \\mathrm{m}$。\n\n然后，根据准则：如果 $\\epsilon \\leq 1.0 \\times 10^{-1}$，则场与智能体的准静态耦合是合理的；否则需要全动态耦合。使用您计算的 $\\epsilon$ 来决定适用哪种耦合机制。将您报告的 $\\epsilon$ 值四舍五入到三位有效数字。将最终的 $\\epsilon$ 表示为无单位的纯数。最终答案必须仅为 $\\epsilon$ 的单个值。", "solution": "问题陈述经核实具有科学依据、问题适定且客观。它提供了一套完整且一致的定义、方程和参数，以便在计算系统生物学领域内推导出有意义的结果。未发现任何缺陷。\n\n主要任务是计算总的时间和长度尺度分离参数 $\\epsilon$，并用它来确定多尺度模型的适当耦合机制。这首先需要推导出连续形态发生素场的主导弛豫时间 $\\tau_{\\mathrm{PDE}}$。\n\n形态发生素浓度 $c(x,t)$ 的弛豫动力学由给定反应扩散方程的齐次部分决定：\n$$\n\\frac{\\partial c}{\\partial t} = D\\,\\frac{\\partial^{2} c}{\\partial x^{2}} - k\\,c\n$$\n在域 $x \\in [0, L]$ 上服从零通量 Neumann 边界条件：\n$$\n\\frac{\\partial c}{\\partial x}(0,t) = 0 \\quad \\text{and} \\quad \\frac{\\partial c}{\\partial x}(L,t) = 0\n$$\n我们使用分离变量法求解此线性偏微分方程，假设解的形式为 $c(x,t) = X(x)T(t)$。将此代入偏微分方程得到：\n$$\nX(x) \\frac{dT(t)}{dt} = D\\, T(t) \\frac{d^2X(x)}{dx^2} - k\\, X(x)T(t)\n$$\n两边同除以 $X(x)T(t)$，可分离时间和空间变量：\n$$\n\\frac{1}{T(t)}\\frac{dT(t)}{dt} = \\frac{D}{X(x)}\\frac{d^2X(x)}{dx^2} - k\n$$\n重新整理各项，我们将等式两边设为一个分离常数 $-\\lambda_{eig}$：\n$$\n\\frac{1}{T(t)}\\frac{dT(t)}{dt} + k = \\frac{D}{X(x)}\\frac{d^2X(x)}{dx^2} = -\\lambda_{eig}\n$$\n这得到两个常微分方程。时间部分的常微分方程是：\n$$\n\\frac{dT(t)}{dt} = -(k + \\lambda_{eig}) T(t)\n$$\n其解为 $T(t) \\propto \\exp(-(k+\\lambda_{eig})t)$。每个模式的衰减率为 $r = k+\\lambda_{eig}$。\n\n空间部分的常微分方程是一个 Sturm-Liouville 问题：\n$$\nD\\frac{d^2X(x)}{dx^2} + \\lambda_{eig} X(x) = 0 \\quad \\implies \\quad \\frac{d^2X(x)}{dx^2} + \\frac{\\lambda_{eig}}{D} X(x) = 0\n$$\n边界条件变为 $\\frac{dX}{dx}(0) = 0$ 和 $\\frac{dX}{dx}(L) = 0$。该空间常微分方程的通解为 $X(x) = A \\cos(\\sqrt{\\frac{\\lambda_{eig}}{D}}x) + B \\sin(\\sqrt{\\frac{\\lambda_{eig}}{D}}x)$。\n应用第一个边界条件 $\\frac{dX}{dx}(0) = 0$：\n$$\n\\frac{dX}{dx} = -A\\sqrt{\\frac{\\lambda_{eig}}{D}}\\sin\\left(\\sqrt{\\frac{\\lambda_{eig}}{D}}x\\right) + B\\sqrt{\\frac{\\lambda_{eig}}{D}}\\cos\\left(\\sqrt{\\frac{\\lambda_{eig}}{D}}x\\right) \\implies \\frac{dX}{dx}(0) = B\\sqrt{\\frac{\\lambda_{eig}}{D}} = 0\n$$\n对于非平凡解，这意味着 $B=0$。空间解简化为 $X(x) = A \\cos(\\sqrt{\\frac{\\lambda_{eig}}{D}}x)$。\n应用第二个边界条件 $\\frac{dX}{dx}(L) = 0$：\n$$\n-A\\sqrt{\\frac{\\lambda_{eig}}{D}}\\sin\\left(\\sqrt{\\frac{\\lambda_{eig}}{D}}L\\right) = 0\n$$\n对于非平凡解 ($A \\neq 0$)，必须有 $\\sin(\\sqrt{\\frac{\\lambda_{eig}}{D}}L) = 0$。此条件在以下情况下满足：\n$$\n\\sqrt{\\frac{\\lambda_{eig}}{D}}L = n\\pi, \\quad \\text{for } n = 0, 1, 2, \\dots\n$$\n这给出了离散的本征值 $\\lambda_{eig, n}$：\n$$\n\\lambda_{eig, n} = D\\left(\\frac{n\\pi}{L}\\right)^2, \\quad \\text{for } n = 0, 1, 2, \\dots\n$$\n由 $n$ 索引的每个模式的总衰减率为：\n$$\nr_n = k + \\lambda_{eig, n} = k + D\\left(\\frac{n\\pi}{L}\\right)^2\n$$\n每个模式的弛豫时间是其衰减率的倒数，$\\tau_n = 1/r_n$。问题陈述指出，弛豫过程由最慢的衰减模式主导，这对应于最长的弛豫时间。我们寻求 $\\tau_{\\mathrm{PDE}} = \\max_n(\\tau_n)$。这等价于找到最小的衰减率 $\\min_n(r_n)$。\n衰减率 $r_n$ 构成一个随 $n$ 单调递增的序列：$r_0  r_1  r_2  \\dots$。最小速率出现在 $n=0$ 时：\n$$\nr_0 = k + D\\left(\\frac{0 \\cdot \\pi}{L}\\right)^2 = k\n$$\n因此，主导的（最长的）连续场弛豫时间为：\n$$\n\\tau_{\\mathrm{PDE}} = \\frac{1}{r_0} = \\frac{1}{k}\n$$\n现在我们代入给定的数值。\n反应速率常数为 $k = 1.0 \\times 10^{-1}\\ \\mathrm{s^{-1}}$。\n$$\n\\tau_{\\mathrm{PDE}} = \\frac{1}{1.0 \\times 10^{-1}\\ \\mathrm{s^{-1}}} = 10\\ \\mathrm{s}\n$$\n接下来，我们计算时间尺度分离参数 $\\epsilon_t$：\n$$\n\\epsilon_{t} = \\frac{\\tau_{\\mathrm{PDE}}}{T_{\\mathrm{cell}}} = \\frac{10\\ \\mathrm{s}}{3.600 \\times 10^{3}\\ \\mathrm{s}} = \\frac{1}{360} \\approx 2.777... \\times 10^{-3}\n$$\n然后，我们计算长度尺度分离参数 $\\epsilon_x$：\n$$\n\\epsilon_{x} = \\frac{d_{\\mathrm{cell}}}{L_{\\mathrm{tissue}}} = \\frac{2.0 \\times 10^{-5}\\ \\mathrm{m}}{2.0 \\times 10^{-3}\\ \\mathrm{m}} = 1.0 \\times 10^{-2}\n$$\n总分离参数 $\\epsilon$ 是这两个值的最大值：\n$$\n\\epsilon = \\max\\{\\epsilon_{t}, \\epsilon_{x}\\} = \\max\\{2.777... \\times 10^{-3}, 1.0 \\times 10^{-2}\\} = 1.0 \\times 10^{-2}\n$$\n问题为耦合机制指定了一个准则：如果 $\\epsilon \\leq 1.0 \\times 10^{-1}$，则准静态耦合是合理的。\n我们计算出的值为 $\\epsilon = 1.0 \\times 10^{-2}$，满足条件 $1.0 \\times 10^{-2} \\leq 1.0 \\times 10^{-1}$。因此，准静态耦合机制适用于该系统。\n\n问题要求将 $\\epsilon$ 的数值四舍五入到三位有效数字。\n$$\n\\epsilon = 1.00 \\times 10^{-2}\n$$", "answer": "$$\\boxed{1.00 \\times 10^{-2}}$$", "id": "3330605"}, {"introduction": "在确定了合适的耦合策略后，下一步便是具体实现它。一个核心挑战是确保物质在不同模型域（例如，随机模型和连续模型）之间能够被正确地交换，以维持系统的基本守恒律。本练习 ([@problem_id:3330619]) 提供了一个动手编程任务，要求您实现随机反应室和确定性扩散场之间的接口，并重点关注如何通过精确的通量计算来维持严格的质量平衡。", "problem": "考虑一个一维组织段，它由一个使用 Gillespie 随机模拟算法 (SSA) 的中心室和由扩散-衰减偏微分方程建模的外部区域组成。长度为 $L_s$ 的中心随机室包含离散数量的分子 $N_s$，其两侧各有一个等宽 $h$ 的外部有限体积单元，其浓度分别为 $c_L$ (左侧单元) 和 $c_R$ (右侧单元)。分子交换仅通过中心室与紧邻的外部单元之间的扩散发生；外部区域通过扩散和线性衰减演化，而中心室则通过 SSA 反应演化。\n\n外部动力学由扩散-衰减方程控制\n$$\n\\partial_t c = D \\,\\partial_{xx} c - k\\, c,\n$$\n其中 $D$ 是扩散系数，$k$ 是一阶衰减率。SSA 室通过 $c_s = N_s/L_s$ 将其离散分子数 $N_s$ 映射为浓度。令 $A$ 表示横截面积，为简化问题，本题中取 $A = 1$。每个界面上的交换遵循菲克定律。通过单元中心之间的中心差分来近似界面上的梯度，穿过左侧界面（左侧单元与中心室之间）的向右通量 $F$ 为\n$$\nF_{\\text{left}} = - D \\,\\frac{c_s - c_L}{d},\n$$\n穿过右侧界面（中心室与右侧单元之间）的通量为\n$$\nF_{\\text{right}} = - D \\,\\frac{c_R - c_s}{d},\n$$\n其中 $d = \\tfrac{1}{2}(h + L_s)$ 是相应单元中心之间的距离。按照惯例，正的 $F$ 表示向右的通量。在单个时间步长 $\\Delta t$ 内，对于具有零通量外边界的外部单元，其有限体积更新公式为\n$$\nc_L^{n+1} = c_L^n - \\frac{\\Delta t}{h}\\,F_{\\text{left}} - k\\,c_L^n\\,\\Delta t,\n\\quad\nc_R^{n+1} = c_R^n + \\frac{\\Delta t}{h}\\,F_{\\text{right}} - k\\,c_R^n\\,\\Delta t.\n$$\n令 $\\Delta N_{\\text{rxn}}$ 为在时间步长 $\\Delta t$ 内，中心室中由 SSA 反应净生成（正值）或消耗（负值）的分子数。必须计算在 $\\Delta t$ 时间内进入 SSA 室的总扩散交换量，以维持详细的质量平衡。您必须使用上述基本定律和定义，推导并实现 SSA 室 $N_s$ 的质量守恒交换更新，使得在 $\\Delta t$ 时间内所有三个室的质量变化总和等于 SSA 反应产生量与外部衰减损失量之和。\n\n所有量均带有以下单位且必须一致处理：$D$ 的单位是 $\\mathrm{\\mu m^2/s}$，$k$ 的单位是 $\\mathrm{s^{-1}}$，$h$ 和 $L_s$ 的单位是 $\\mathrm{\\mu m}$，$c$ 的单位是 分子数/$\\mathrm{\\mu m}$，$N_s$ 的单位是 分子数，$\\Delta t$ 的单位是 $\\mathrm{s}$。任何分子数都应表示为实值浮点数（不进行四舍五入），任何浓度单位都应为 分子数/$\\mathrm{\\mu m}$。\n\n对于下方的每个测试用例，您的程序必须在单个时间步长 $\\Delta t$ 内计算：\n- 进入 SSA 室的净扩散交换量 $\\Delta N_{\\text{ex}}$（单位：分子数），\n- 更新后的 SSA 分子数 $N_s^{n+1}$（单位：分子数），\n- 更新后的外部浓度 $c_L^{n+1}$ 和 $c_R^{n+1}$（单位：分子数/$\\mathrm{\\mu m}$），\n- 质量平衡残差，定义为\n$$\n\\text{residual} = (N_s^{n+1} + h c_L^{n+1} + h c_R^{n+1}) - (N_s^n + h c_L^n + h c_R^n) - (\\Delta N_{\\text{rxn}} - k \\Delta t h (c_L^n + c_R^n)),\n$$\n如果交换实现正确，该值在数值上应接近于 $0$。\n\n使用以下测试套件，它涵盖了理想路径、对称性、无扩散和非对称几何等条件：\n- 测试 1：$D = 10$, $k = 0.05$, $h = 5$, $L_s = 5$, $\\Delta t = 0.1$, $N_s = 500$, $c_L = 140$, $c_R = 80$, $\\Delta N_{\\text{rxn}} = 0$。\n- 测试 2：$D = 10$, $k = 0.1$, $h = 5$, $L_s = 5$, $\\Delta t = 0.1$, $N_s = 500$, $c_L = 100$, $c_R = 100$, $\\Delta N_{\\text{rxn}} = 10$。\n- 测试 3：$D = 0$, $k = 0$, $h = 5$, $L_s = 5$, $\\Delta t = 0.1$, $N_s = 500$, $c_L = 120$, $c_R = 80$, $\\Delta N_{\\text{rxn}} = -5$。\n- 测试 4：$D = 20$, $k = 0$, $h = 10$, $L_s = 2$, $\\Delta t = 0.05$, $N_s = 200$, $c_L = 50$, $c_R = 200$, $\\Delta N_{\\text{rxn}} = 0$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序连接每个测试用例的五个浮点数 $[\\Delta N_{\\text{ex}}, N_s^{n+1}, c_L^{n+1}, c_R^{n+1}, \\text{residual}]$。对于所有数值输出，请使用原始浮点数（无百分号），并确保单位如上所述。", "solution": "核心要求是设计一个随机室与周围确定性扩散-衰减外部区域之间的数学上一致的耦合，以保证在时间步长 $\\Delta t$ 内的详细质量平衡。我们将推导基于以下原则：\n- 菲克扩散定律：通量 $J$ 为 $J = -D\\,\\partial_x c$。\n- 有限体积守恒：单元内平均浓度的变化等于通过其边界的净通量除以其体积（此处为一维，横截面积设为 $1$，体积简化为长度 $h$），再减去任何反应项。\n- SSA 室内离散分子数与浓度之间的映射关系：$c_s = N_s/L_s$。\n\n我们通过与中心 SSA 室相邻的两个有限体积单元来离散化外部区域：一个平均浓度为 $c_L$ 的左侧单元和一个平均浓度为 $c_R$ 的右侧单元。左侧单元中心与 SSA 中心之间，以及 SSA 中心与右侧单元中心之间的距离由 $d = \\tfrac{1}{2}(h + L_s)$ 建模，假设每个界面区域具有均匀的属性和线性的浓度分布。\n\n使用中心差分计算左侧界面（左侧单元中心到 SSA 中心）的梯度，向右的通量为\n$$\nF_{\\text{left}} = -D\\,\\frac{c_s - c_L}{d}.\n$$\n正的 $F_{\\text{left}}$ 表示从左侧单元流入 SSA 室的净流量（穿过左侧界面向右）。穿过右侧界面（SSA 中心到右侧单元中心），向右的通量为\n$$\nF_{\\text{right}} = -D\\,\\frac{c_R - c_s}{d}.\n$$\n正的 $F_{\\text{right}}$ 表示从 SSA 室流入右侧外部单元的净流量（穿过右侧界面向右）。\n\n对于每个外部单元，在一维情况下，具有零通量外边界的有限体积守恒在单个时间步长 $\\Delta t$ 内给出：\n$$\nc_L^{n+1} = c_L^n - \\frac{\\Delta t}{h}\\,F_{\\text{left}} - k\\,c_L^n\\,\\Delta t,\n$$\n$$\nc_R^{n+1} = c_R^n + \\frac{\\Delta t}{h}\\,F_{\\text{right}} - k\\,c_R^n\\,\\Delta t.\n$$\n符号遵循标准更新公式 $c_i^{n+1} = c_i^n - (\\Delta t/h)\\,(F_{i+1/2} - F_{i-1/2}) - k\\,c_i^n\\,\\Delta t$，其中 $F_{L-1/2} = 0$ 且 $F_{R+1/2} = 0$。\n\nSSA 室接收的净扩散交换量必须等于来自左界面和右界面的流入量之和（取适当的符号以表示流入 SSA）。从左界面流入 SSA 的量等于 $+\\Delta t\\,F_{\\text{left}}$（穿过左侧界面向右的正通量将分子从左侧单元移动到 SSA 中）。从右界面流入 SSA 的量等于 $-\\Delta t\\,F_{\\text{right}}$（穿过右侧界面向右的正通量将分子从 SSA 移动到右侧单元，这是从 SSA 的流出；因此流入量是其负值）。因此，进入 SSA 的净扩散交换量为\n$$\n\\Delta N_{\\text{ex}} = \\Delta t\\,\\Big(F_{\\text{left}} - F_{\\text{right}}\\Big).\n$$\n令 $\\Delta N_{\\text{rxn}}$ 表示在时间步长 $\\Delta t$ 内由 SSA 反应净产生（正值）或消耗（负值）的分子数。那么 SSA 室的更新公式为\n$$\nN_s^{n+1} = N_s^n + \\Delta N_{\\text{rxn}} + \\Delta N_{\\text{ex}}.\n$$\n根据构造，界面间的详细质量平衡得以保持，因为由界面通量引起的外部区域净质量变化等于 $-\\Delta N_{\\text{ex}}$：\n$$\n\\Delta M_{\\text{ext, interface}} = h\\,(c_L^{n+1} - c_L^n)_{\\text{interface}} + h\\,(c_R^{n+1} - c_R^n)_{\\text{interface}} = -\\Delta t\\,F_{\\text{left}} + \\Delta t\\,F_{\\text{right}} = -\\Delta N_{\\text{ex}}.\n$$\n因此，对所有室求和，唯一的净质量产生或损失来自于中心室内的 SSA 反应和外部单元中的外部衰减：\n$$\n\\Big(N_s^{n+1} + h\\,c_L^{n+1} + h\\,c_R^{n+1}\\Big) - \\Big(N_s^n + h\\,c_L^n + h\\,c_R^n\\Big) = \\Delta N_{\\text{rxn}} - k\\,\\Delta t\\,h\\,(c_L^n + c_R^n).\n$$\n为了数值上验证质量守恒，我们计算残差\n$$\n\\text{residual} = \\Big( N_s^{n+1} + h\\,c_L^{n+1} + h\\,c_R^{n+1} \\Big) - \\Big( N_s^n + h\\,c_L^n + h\\,c_R^n \\Big) - \\Big( \\Delta N_{\\text{rxn}} - k\\,\\Delta t\\,h\\,(c_L^n + c_R^n) \\Big),\n$$\n其结果应在浮点舍入误差范围内为 $0$。\n\n每个测试用例的算法步骤：\n- 计算 $c_s = N_s/L_s$ 和 $d = \\tfrac{1}{2}(h + L_s)$。\n- 使用上述公式计算 $F_{\\text{left}}$ 和 $F_{\\text{right}}$。\n- 计算 $\\Delta N_{\\text{ex}} = \\Delta t\\,(F_{\\text{left}} - F_{\\text{right}})$。\n- 使用 $N_s^{n+1} = N_s^n + \\Delta N_{\\text{rxn}} + \\Delta N_{\\text{ex}}$ 更新 $N_s^{n+1}$。\n- 更新外部浓度：\n  $c_L^{n+1} = c_L^n - (\\Delta t/h)\\,F_{\\text{left}} - k\\,c_L^n\\,\\Delta t$ 和\n  $c_R^{n+1} = c_R^n + (\\Delta t/h)\\,F_{\\text{right}} - k\\,c_R^n\\,\\Delta t$。\n- 计算残差以验证质量平衡。\n\n对于给定的时间步长和参数（例如，选择的 $D$ 和 $h$ 使得 $\\Delta t/h^2$ 保持较小），该显式格式是科学上现实且稳定的，并且仅使用基本定律，没有使用快捷公式。根据要求，对于每个测试用例，程序按 $[\\Delta N_{\\text{ex}}, N_s^{n+1}, c_L^{n+1}, c_R^{n+1}, \\text{residual}]$ 的顺序输出五个浮点数，并将所有测试用例的结果连接成一个单行的方括号列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hybrid_step(D, k, h, Ls, dt, Ns, cL, cR, dN_rxn):\n    \"\"\"\n    Perform one hybrid step coupling a central SSA compartment and two exterior PDE cells.\n    Units:\n      D: um^2/s\n      k: 1/s\n      h, Ls: um\n      dt: s\n      Ns: molecules\n      cL, cR: molecules/um\n      dN_rxn: molecules\n    Returns:\n      (dN_ex, Ns_new, cL_new, cR_new, residual)\n    \"\"\"\n    # Map SSA molecules to concentration in the compartment\n    cs = Ns / Ls\n    # Distance between centers across each interface\n    d = 0.5 * (h + Ls)\n\n    # Face-to-the-right fluxes by Fick's law (central differences)\n    F_left = -D * (cs - cL) / d      # left interface: left cell (cL) to SSA (cs)\n    F_right = -D * (cR - cs) / d     # right interface: SSA (cs) to right cell (cR)\n\n    # Net diffusive exchange into SSA (in molecules) over dt\n    dN_ex = dt * (F_left - F_right)\n\n    # Update SSA molecule count with reactions and exchange\n    Ns_new = Ns + dN_rxn + dN_ex\n\n    # Exterior updates via finite volume with zero outer fluxes\n    cL_new = cL - (dt / h) * F_left - k * cL * dt\n    cR_new = cR + (dt / h) * F_right - k * cR * dt\n\n    # Mass-balance residual check (should be ~0)\n    M_before = Ns + h * (cL + cR)\n    M_after = Ns_new + h * (cL_new + cR_new)\n    predicted_change = dN_rxn - k * dt * h * (cL + cR)\n    residual = M_after - M_before - predicted_change\n\n    return dN_ex, Ns_new, cL_new, cR_new, residual\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (D, k, h, Ls, dt, Ns, cL, cR, dN_rxn)\n    test_cases = [\n        (10.0, 0.05, 5.0, 5.0, 0.1, 500.0, 140.0, 80.0, 0.0),    # Test 1\n        (10.0, 0.1, 5.0, 5.0, 0.1, 500.0, 100.0, 100.0, 10.0),   # Test 2\n        (0.0, 0.0, 5.0, 5.0, 0.1, 500.0, 120.0, 80.0, -5.0),     # Test 3\n        (20.0, 0.0, 10.0, 2.0, 0.05, 200.0, 50.0, 200.0, 0.0),   # Test 4\n    ]\n\n    results = []\n    for case in test_cases:\n        D, k, h, Ls, dt, Ns, cL, cR, dN_rxn = case\n        dN_ex, Ns_new, cL_new, cR_new, residual = hybrid_step(D, k, h, Ls, dt, Ns, cL, cR, dN_rxn)\n        # Append results in required flat order for each test case\n        results.extend([dN_ex, Ns_new, cL_new, cR_new, residual])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3330619"}, {"introduction": "多尺度模型常常表现出局部化的活动，例如细胞在一个小区域内释放信号分子，导致解在空间上呈现出剧烈变化。在整个模拟域中使用统一的高分辨率网格会造成巨大的计算浪费。这个练习 ([@problem_id:3330692]) 介绍了自适应网格加密（AMR）技术，它能将计算资源智能地集中在最需要的地方。您将实现一个由“智能体活动”指标引导的AMR方案，从而掌握一项用于实现高效、精确模拟的关键优化技术。", "problem": "考虑一个占据域 $[0,1]$ 的一维无量纲组织段。一个扩散和降解的分子场 $u(x)$ 由位于 $\\{x_j\\}$ 位置的离散主体产生，这些主体作为局部源。从质量守恒和菲克定律出发，具有一阶降解和源的扩散过程的稳态满足\n$$-D \\frac{d^2 u}{dx^2} + \\lambda u = s(x), \\quad x \\in (0,1),$$\n其齐次狄利克雷边界条件为\n$$u(0)=0, \\quad u(1)=0,$$\n其中 $D0$ 是扩散系数，$\\lambda0$ 是降解率，$s(x)$ 是由主体引起的源密度。将位于位置 $x_j$ 的每个主体建模为产生一个由高斯核近似的光滑局部源。设每个主体的产生强度为 $q0$，核宽度为 $\\sigma0$，定义\n$$s(x) = \\sum_{j} q \\cdot \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(x-x_j)^2}{2\\sigma^2}\\right)。$$\n定义一个主体活动指示剂为\n$$\\eta(x) = \\sum_{j} \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(x-x_j)^2}{2\\sigma^2}\\right),$$\n该指示剂与 $s(x)$ 成正比，并度量与产生强度 $q$ 无关的局部主体活动。\n\n您需要实现由主体活动指示剂 $\\eta(x)$ 引导的自适应网格加密（AMR），并用它来求解该稳态偏微分方程（PDE）。在一个包含边界 $x_0=0$ 和 $x_{N-1}=1$ 以及由 $i=1,\\dots,N-2$ 索引的内部节点的非均匀节点集 $\\{x_i\\}_{i=0}^{N-1}$ 上对该偏微分方程进行保守离散化。利用每个内部节点周围控制体积上的有限体积平衡和菲克定律，将节点 $i$ 处的二阶导数近似为\n$$\\left.\\frac{d^2 u}{dx^2}\\right|_{x_i} \\approx \\frac{\\displaystyle \\frac{u_{i+1}-u_i}{x_{i+1}-x_i} - \\frac{u_i - u_{i-1}}{x_i - x_{i-1}}}{\\displaystyle \\frac{(x_{i+1}-x_i) + (x_i - x_{i-1})}{2}},$$\n由此得到内部节点的线性系统\n$$\\left(\\frac{D}{\\delta_i}\\left(\\frac{1}{x_{i+1}-x_i} + \\frac{1}{x_i - x_{i-1}}\\right) + \\lambda\\right) u_i - \\frac{D}{\\delta_i}\\frac{u_{i-1}}{x_i - x_{i-1}} - \\frac{D}{\\delta_i}\\frac{u_{i+1}}{x_{i+1}-x_i} = s(x_i),$$\n其中 $\\delta_i = \\tfrac{1}{2}\\big((x_{i+1}-x_i)+(x_i-x_{i-1})\\big)$，并且边界条件强制 $u_0=u_{N-1}=0$。\n\n通过从将 $[0,1]$ 剖分为 $M_0$ 个相等单元的粗糙剖分开始，实现AMR。迭代地二分任何中点活动指示剂超过阈值 $\\tau0$ 的单元，即，如果一个中点为 $c=\\tfrac{a+b}{2}$ 的单元 $[a,b]$ 满足 $\\eta(c)\\tau$，则将其标记。持续此过程，直到没有单元被标记或达到最大加密级别 $L_{\\max}$。将节点集 $\\{x_i\\}$ 构建为加密后所有单元端点的排序唯一集合。\n\n将协同仿真误差定义为 AMR 解与在 $[0,1]$ 上具有 $N_{\\text{ref}}$ 个节点的精细均匀参考网格上计算的参考解之差的 $L^2$ 范数。将 AMR 解线性插值到参考网格上，并计算\n$$\\|u_{\\text{AMR}} - u_{\\text{ref}}\\|_{L^2(0,1)} = \\left(\\int_0^1 \\left(u_{\\text{AMR}}(x) - u_{\\text{ref}}(x)\\right)^2 dx\\right)^{1/2},$$\n在参考网格上使用梯形法则进行数值近似。所有量均为无量纲。您的程序在 AMR 和参考计算中必须使用相同的 $D, \\lambda, q, \\sigma$ 值。\n\n对所有测试使用以下固定参数值：\n- $D = 1.0$,\n- $\\lambda = 1.0$,\n- $q = 0.02$,\n- $\\sigma = 0.02$,\n- $M_0 = 32$,\n- $L_{\\max} = 6$,\n- $\\tau = 0.35$,\n- $N_{\\text{ref}} = 2049$。\n\n测试套件。对于以下每个主体位置集，计算如上定义的协同仿真误差：\n- 测试 $1$（主体分离）：$\\{x_j\\} = [0.2, 0.5, 0.8]$。\n- 测试 $2$（主体在内部聚集）：$\\{x_j\\} = [0.48, 0.5, 0.52]$。\n- 测试 $3$（主体在边界附近聚集）：$\\{x_j\\} = [0.02, 0.04, 0.06]$。\n\n最终输出格式。您的程序应生成单行输出，其中包含按上述测试顺序排列的三个协同仿真误差，格式为方括号内以逗号分隔的列表，每个数字格式化为四舍五入到六位小数的浮点值，例如 $[0.123456,0.234567,0.345678]$。", "solution": "我们从具有源的扩散和降解分子场的质量守恒开始。令 $u(x)$ 表示稳态浓度。在一维空间中，结合菲克扩散定律和一阶降解的质量平衡得出稳态偏微分方程（PDE）\n$$-D \\frac{d^2 u}{dx^2} + \\lambda u = s(x), \\quad x \\in (0,1),$$\n其齐次狄利克雷边界条件为 $u(0)=0$ 和 $u(1)=0$。这里 $D>0$ 是扩散系数，$\\lambda>0$ 是降解率。源项 $s(x)$ 来自产生场的主体。为便于数值计算，需要对狄拉克分布进行正则化，将位置 $x_j$ 处的每个主体表示为宽度为 $\\sigma>0$ 且强度为 $q>0$ 的高斯函数，因此总源为\n$$s(x) = \\sum_{j} q \\cdot \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(x-x_j)^2}{2\\sigma^2}\\right)。$$\n为了引导自适应网格加密（AMR），将主体活动指示剂定义为高斯函数的归一化和，\n$$\\eta(x) = \\sum_{j} \\frac{1}{\\sigma \\sqrt{2\\pi}} \\exp\\!\\left(-\\frac{(x-x_j)^2}{2\\sigma^2}\\right),$$\n它与 $s(x)$ 成正比且与 $q$ 无关。\n\n非均匀网格上的离散化是根据第一性原理，通过对每个内部节点 $x_i$（$i=1,\\dots,N-2$）周围的控制体积应用有限体积平衡来构建的。设节点集为 $0=x_0  x_1  \\dots  x_{N-2}  x_{N-1}=1$，并定义间距 $\\Delta x_{i-1/2} = x_i - x_{i-1}$、$\\Delta x_{i+1/2} = x_{i+1} - x_i$ 和平均半宽 $\\delta_i = \\tfrac{1}{2}(\\Delta x_{i-1/2} + \\Delta x_{i+1/2})$。菲克定律给出通量 $J = -D \\tfrac{du}{dx}$。将扩散项在控制体积上积分，并用单边差分近似界面梯度，得到保守的离散拉普拉斯算子\n$$\\left.\\frac{d^2 u}{dx^2}\\right|_{x_i} \\approx \\frac{\\displaystyle \\frac{u_{i+1}-u_i}{\\Delta x_{i+1/2}} - \\frac{u_i - u_{i-1}}{\\Delta x_{i-1/2}}}{\\displaystyle \\delta_i}。$$\n将此代入偏微分方程，对每个内部节点可得\n$$-D \\cdot \\frac{\\displaystyle \\frac{u_{i+1}-u_i}{\\Delta x_{i+1/2}} - \\frac{u_i - u_{i-1}}{\\Delta x_{i-1/2}}}{\\displaystyle \\delta_i} + \\lambda u_i = s(x_i)。$$\n重新整理可得一个对称三对角线性系统\n$$a_{i-1} u_{i-1} + a_i u_i + a_{i+1} u_{i+1} = s(x_i),$$\n其系数为\n$$a_{i-1} = -\\frac{D}{\\delta_i} \\cdot \\frac{1}{\\Delta x_{i-1/2}}, \\quad a_{i+1} = -\\frac{D}{\\delta_i} \\cdot \\frac{1}{\\Delta x_{i+1/2}}, \\quad a_i = \\frac{D}{\\delta_i}\\left(\\frac{1}{\\Delta x_{i-1/2}} + \\frac{1}{\\Delta x_{i+1/2}}\\right) + \\lambda。$$\n边界条件 $u_0=0$ 和 $u_{N-1}=0$ 被直接强制执行，并消除了 $i=0$ 和 $i=N-1$ 处的未知数，因此该三对角系统求解的是内部未知数 $u_1,\\dots,u_{N-2}$。\n\n自适应网格加密由活动指示剂 $\\eta(x)$ 驱动。从加密级别为 0 的、将 $[0,1]$ 均匀剖分为 $M_0$ 个单元开始。对于级别为 $\\ell$、中点为 $c=\\tfrac{a+b}{2}$ 的单元 $[a,b]$，如果 $\\eta(c)>\\tau$ 且 $\\ell  L_{\\max}$，则标记其进行加密。每个被标记的单元被二分为两个级别为 $\\ell+1$ 的子单元。迭代执行标记和二分过程，直到没有单元被标记或达到最大加密级别 $L_{\\max}$。用于离散化偏微分方程的节点集 $\\{x_i\\}$ 是加密后所有单元端点的排序集合。这将加密与主体高活动区域对齐，在这些区域，$s(x)$ 呈现尖峰，而 $u(x)$ 倾向于表现出陡峭的梯度。\n\n协同仿真误差是通过将 AMR 解与在 $[0,1]$ 上具有 $N_{\\text{ref}}$ 个节点的精细均匀网格上的参考解进行比较来计算的。通过在均匀网格上应用相同的离散算子来计算参考解。将 AMR 解线性插值到参考网格上，得到均匀节点 $x_k$ 处的 $u_{\\text{AMR}}(x_k)$。使用梯形法则近似 $L^2$ 误差范数，\n$$\\|u_{\\text{AMR}} - u_{\\text{ref}}\\|_{L^2(0,1)} \\approx \\left( \\int_0^1 \\left(u_{\\text{AMR}}(x) - u_{\\text{ref}}(x)\\right)^2 dx \\right)^{1/2} \\approx \\left( \\sum_{k=0}^{N_{\\text{ref}}-1} w_k \\left(u_{\\text{AMR}}(x_k) - u_{\\text{ref}}(x_k)\\right)^2 \\right)^{1/2},$$\n其中 $w_k$ 是梯形求积权重，其中 $w_0 = w_{N_{\\text{ref}}-1} = \\tfrac{\\Delta x}{2}$，$w_k = \\Delta x$（对于 $1 \\le k \\le N_{\\text{ref}}-2$），且 $\\Delta x = \\tfrac{1}{N_{\\text{ref}}-1}$。\n\n算法步骤：\n- 定义参数 $D, \\lambda, q, \\sigma, M_0, L_{\\max}, \\tau$ 和 $N_{\\text{ref}}$。\n- 对于每个测试用例的主体集 $\\{x_j\\}$：\n  - 通过使用阈值 $\\tau$ 进行迭代中点指示剂标记来构建 AMR 网格，直到没有标记或达到最大级别 $L_{\\max}$。\n  - 从加密后的单元端点形成非均匀节点向量。\n  - 使用上述系数和在节点上求值的右侧项 $s(x_i)$，为 AMR 网格组装并求解三对角系统。\n  - 在具有 $N_{\\text{ref}}$ 个节点的均匀网格上，使用相同的 $D, \\lambda, q, \\sigma$ 组装并求解参考系统。\n  - 将 AMR 解插值到均匀参考网格上，并通过梯形法则计算 $L^2$ 误差。\n- 以指定的列表格式输出三个误差。\n\n正确性论证：\n- 控制方程源于质量守恒和菲克定律，具有线性降解和光滑源，这确保了对于 $D>0$ 和 $\\lambda>0$ 的情况，这是一个具有唯一解的适定、线性、自伴的椭圆边值问题。\n- 非均匀网格上的有限体积离散化是保守的，并且由于 $D>0$, $\\lambda>0$ 以及严格递增的节点，它产生一个对称正定三对角系统，从而确保了离散解的数值稳定性和唯一性。\n- AMR 策略针对 $\\eta(x)$ 较大的区域，这些区域与局部源和 $u(x)$ 中的陡峭梯度相吻合，从而将分辨率集中在最有效益的地方。\n- 在精细均匀参考网格上计算的 $L^2$ 误差为 AMR 解和参考解之间的协同仿真差异提供了一致的定量度量。\n\n所有量均为无量纲，要求的三个测试是：\n- 测试 1：$\\{x_j\\} = [0.2, 0.5, 0.8]$，\n- 测试 2：$\\{x_j\\} = [0.48, 0.5, 0.52]$，\n- 测试 3：$\\{x_j\\} = [0.02, 0.04, 0.06]$。\n\n程序必须打印一行，其中包含三个误差值，格式为 $[e_1,e_2,e_3]$，每个值四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gaussian_mixture(x, agents, q, sigma):\n    # Compute sum_j q * Gaussian(x - x_j; sigma)\n    # Gaussian normalization 1/(sigma*sqrt(2*pi))\n    x = np.asarray(x)\n    val = np.zeros_like(x, dtype=float)\n    norm = 1.0 / (sigma * np.sqrt(2.0 * np.pi))\n    for aj in agents:\n        val += q * norm * np.exp(-0.5 * ((x - aj) / sigma) ** 2)\n    return val\n\ndef activity_indicator(x, agents, sigma):\n    # Same as gaussian mixture but with q=1\n    x = np.asarray(x)\n    val = np.zeros_like(x, dtype=float)\n    norm = 1.0 / (sigma * np.sqrt(2.0 * np.pi))\n    for aj in agents:\n        val += norm * np.exp(-0.5 * ((x - aj) / sigma) ** 2)\n    return val\n\ndef build_amr_nodes(agents, sigma, tau, M0, Lmax, max_cells=8192):\n    # Cells represented as tuples (a, b, level)\n    cells = []\n    # initial uniform partition\n    edges = np.linspace(0.0, 1.0, M0 + 1)\n    for i in range(M0):\n        cells.append([edges[i], edges[i+1], 0])\n    # Refinement loop\n    changed = True\n    while changed:\n        changed = False\n        new_cells = []\n        for a, b, lev in cells:\n            c = 0.5 * (a + b)\n            eta_c = activity_indicator(np.array([c]), agents, sigma)[0]\n            if (eta_c > tau) and (lev  Lmax):\n                # bisect\n                mid = 0.5 * (a + b)\n                new_cells.append([a, mid, lev + 1])\n                new_cells.append([mid, b, lev + 1])\n                changed = True\n            else:\n                new_cells.append([a, b, lev])\n        cells = new_cells\n        if len(cells) > max_cells:\n            break\n        if not changed:\n            break\n    # Build nodes from cell endpoints\n    nodes = np.unique(np.array([c[0] for c in cells] + [cells[-1][1]]))\n    return nodes\n\ndef assemble_tridiagonal_nonuniform(nodes, D, lam, source_fn):\n    # nodes: array of length N, with boundaries at nodes[0]=0, nodes[-1]=1\n    N = len(nodes)\n    # interior indices: 1..N-2\n    n_int = N - 2\n    if n_int = 0:\n        # trivial case, no interior unknowns\n        return np.zeros((0,)), np.zeros((0,)), np.zeros((0,)), np.zeros((0,))\n    xi = nodes\n    # compute spacings\n    dxm = xi[1:-1] - xi[0:-2]     # length n_int\n    dxp = xi[2:] - xi[1:-1]       # length n_int\n    denom = 0.5 * (dxm + dxp)     # length n_int\n\n    # Coefficients for interior points\n    aW = -D / denom / dxm\n    aE = -D / denom / dxp\n    aP = (D / denom) * (1.0/dxm + 1.0/dxp) + lam\n\n    # RHS s(x_i)\n    x_interior = xi[1:-1]\n    b = source_fn(x_interior).copy()\n\n    # Tridiagonal arrays\n    lower = aW[1:]          # sub-diagonal of length n_int-1\n    diag = aP.copy()        # main diagonal of length n_int\n    upper = aE[:-1]         # super-diagonal of length n_int-1\n\n    # Dirichlet boundaries are zero, so no modifications to b needed\n    return lower, diag, upper, b\n\ndef thomas_solve(lower, diag, upper, rhs):\n    # Solve tridiagonal system with Thomas algorithm\n    n = len(diag)\n    if n == 0:\n        return np.zeros((0,))\n    c = np.zeros(n-1, dtype=float)\n    d = np.zeros(n, dtype=float)\n    # forward elimination\n    c[0:1] = upper[0:1] / diag[0]\n    d[0] = rhs[0] / diag[0]\n    for i in range(1, n):\n        denom = diag[i] - lower[i-1] * c[i-1]\n        if i  n-1:\n            c[i] = upper[i] / denom\n        d[i] = (rhs[i] - lower[i-1] * d[i-1]) / denom\n    # back substitution\n    x = np.zeros(n, dtype=float)\n    x[-1] = d[-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d[i] - c[i] * x[i+1]\n    return x\n\ndef solve_nonuniform(nodes, D, lam, agents, q, sigma):\n    # Build source function\n    def sfun(x):\n        return gaussian_mixture(x, agents, q, sigma)\n    lower, diag, upper, b = assemble_tridiagonal_nonuniform(nodes, D, lam, sfun)\n    u_int = thomas_solve(lower, diag, upper, b)\n    # assemble full solution with Dirichlet boundaries zero\n    u_full = np.zeros_like(nodes)\n    if len(u_int) > 0:\n        u_full[1:-1] = u_int\n    return u_full\n\ndef l2_error_on_uniform_ref(u_ref, x_ref, x_amr, u_amr):\n    # Interpolate AMR solution to reference grid and compute L2 norm via trapezoidal rule\n    u_amr_interp = np.interp(x_ref, x_amr, u_amr)\n    diff2 = (u_amr_interp - u_ref) ** 2\n    err_sq = np.trapz(diff2, x_ref)\n    return np.sqrt(err_sq)\n\ndef solve_case(agents, params):\n    D = params[\"D\"]\n    lam = params[\"lam\"]\n    q = params[\"q\"]\n    sigma = params[\"sigma\"]\n    M0 = params[\"M0\"]\n    Lmax = params[\"Lmax\"]\n    tau = params[\"tau\"]\n    Nref = params[\"Nref\"]\n\n    # Reference grid and solution\n    x_ref = np.linspace(0.0, 1.0, Nref)\n    u_ref = solve_nonuniform(x_ref, D, lam, agents, q, sigma)\n\n    # AMR grid and solution\n    x_amr = build_amr_nodes(agents, sigma, tau, M0, Lmax, max_cells=8192)\n    u_amr = solve_nonuniform(x_amr, D, lam, agents, q, sigma)\n\n    # L2 error\n    err = l2_error_on_uniform_ref(u_ref, x_ref, x_amr, u_amr)\n    return err\n\ndef solve():\n    # Define parameters\n    params = {\n        \"D\": 1.0,\n        \"lam\": 1.0,\n        \"q\": 0.02,\n        \"sigma\": 0.02,\n        \"M0\": 32,\n        \"Lmax\": 6,\n        \"tau\": 0.35,\n        \"Nref\": 2049,\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [0.2, 0.5, 0.8],        # Test 1: separated agents\n        [0.48, 0.5, 0.52],      # Test 2: clustered interior\n        [0.02, 0.04, 0.06],     # Test 3: clustered near boundary\n    ]\n\n    results = []\n    for agents in test_cases:\n        err = solve_case(agents, params)\n        # Round to six decimal places for output formatting\n        results.append(f\"{err:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3330692"}]}