{"hands_on_practices": [{"introduction": "在我们使用强大的软件分析复杂的生物数据之前，理解拓扑特征计算的基本原理至关重要。本练习通过指导您为一个小的、具体的单纯复形构建边界矩阵并计算其贝蒂数（Betti number），将抽象的代数概念与具体的线性代数联系起来，从而揭开单纯同调的神秘面纱。[@problem_id:3355925]", "problem": "在计算系统生物学中，当在固定尺度上对细胞间的相似性进行建模时，会出现一个小型拓扑数据分析 (TDA) 任务。考虑一个 Vietoris–Rips (VR) 复形 $K$，它是从嵌入潜空间中的 $5$ 个单细胞图谱，使用一个生物学上合理的相似性阈值构建的，定义在具有两个元素的有限域 ($\\mathbb{F}_{2}$) 上，并产生了以下单纯形。$0$-单纯形 (顶点) 是 $v_{1}, v_{2}, v_{3}, v_{4}, v_{5}$。$1$-单纯形 (边) 是 $e_{12}, e_{23}, e_{34}, e_{45}, e_{15}, e_{25}, e_{35}$。$2$-单纯形 (三角形) 是 $\\tau_{125}, \\tau_{345}$。假设不存在更高维的单纯形。整个过程都在 $\\mathbb{F}_{2}$ 上进行。\n\n仅从单纯同调的核心定义出发，构建边界算子 $\\partial_{1} : C_{1}(K;\\mathbb{F}_{2}) \\to C_{0}(K;\\mathbb{F}_{2})$ 和 $\\partial_{2} : C_{2}(K;\\mathbb{F}_{2}) \\to C_{1}(K;\\mathbb{F}_{2})$ 关于有序基 $\\{v_{1}, v_{2}, v_{3}, v_{4}, v_{5}\\}$ (对于 $C_{0}(K;\\mathbb{F}_{2})$)，$\\{e_{12}, e_{23}, e_{34}, e_{45}, e_{15}, e_{25}, e_{35}\\}$ (对于 $C_{1}(K;\\mathbb{F}_{2})$)，以及 $\\{\\tau_{125}, \\tau_{345}\\}$ (对于 $C_{2}(K;\\mathbb{F}_{2})$) 的边界矩阵。仅使用这些矩阵和在 $\\mathbb{F}_{2}$ 上的同调的标准定义，验证确定第一同调群 $H_{1}(K;\\mathbb{F}_{2})$ 所需的秩。\n\n将 Betti 数 $\\beta_{1} = \\dim H_{1}(K;\\mathbb{F}_{2})$ 作为单个整数报告。无需四舍五入。", "solution": "此问题要求计算给定单纯复形 $K$ 在有限域 $\\mathbb{F}_{2}$ 上的第一个 Betti 数 $\\beta_{1}$。第一同调群 $H_{1}(K; \\mathbb{F}_{2})$ 定义为 1-圈链的向量空间 $Z_{1}(K; \\mathbb{F}_{2})$ 与 1-边界链的向量空间 $B_{1}(K; \\mathbb{F}_{2})$ 的商空间。\n$$H_{1}(K; \\mathbb{F}_{2}) = Z_{1}(K; \\mathbb{F}_{2}) / B_{1}(K; \\mathbb{F}_{2})$$\nBetti 数 $\\beta_{1}$ 是这个商空间的维数：\n$$\\beta_{1} = \\dim(H_{1}(K; \\mathbb{F}_{2})) = \\dim(Z_{1}(K; \\mathbb{F}_{2})) - \\dim(B_{1}(K; \\mathbb{F}_{2}))$$\n\n1-圈链空间 $Z_{1}$ 是边界算子 $\\partial_{1}: C_{1}(K; \\mathbb{F}_{2}) \\to C_{0}(K; \\mathbb{F}_{2})$ 的核 (kernel)，而 1-边界链空间 $B_{1}$ 是边界算子 $\\partial_{2}: C_{2}(K; \\mathbb{F}_{2}) \\to C_{1}(K; \\mathbb{F}_{2})$ 的像 (image)。\n因此，我们有：\n$\\dim(Z_{1}(K; \\mathbb{F}_{2})) = \\dim(\\ker \\partial_{1})$\n$\\dim(B_{1}(K; \\mathbb{F}_{2})) = \\dim(\\operatorname{im} \\partial_{2})$\n\n对线性映射 $\\partial_{1}$ 使用秩-零度定理，我们有 $\\dim(C_{1}) = \\dim(\\ker \\partial_{1}) + \\dim(\\operatorname{im} \\partial_{1})$。因此，$\\dim(\\ker \\partial_{1}) = \\dim(C_{1}) - \\operatorname{rank}(\\partial_{1})$。算子的秩是其像的维数。\n将这些代入 $\\beta_{1}$ 的表达式中：\n$$\\beta_{1} = (\\dim(C_{1}) - \\operatorname{rank}(\\partial_{1})) - \\operatorname{rank}(\\partial_{2})$$\n问题指定了链群的基，所以它们的维数是已知的。$\\dim(C_{2}) = 2$, $\\dim(C_{1}) = 7$, 以及 $\\dim(C_{0}) = 5$。我们的任务简化为构建 $\\partial_{2}$ 和 $\\partial_{1}$ 的矩阵表示并求出它们的秩。\n\n首先，我们构建 $\\partial_{2} : C_{2}(K;\\mathbb{F}_{2}) \\to C_{1}(K;\\mathbb{F}_{2})$ 的矩阵。$C_{2}$ 的基是 $\\{\\tau_{125}, \\tau_{345}\\}$，$C_{1}$ 的基是 $\\{e_{12}, e_{23}, e_{34}, e_{45}, e_{15}, e_{25}, e_{35}\\}$。一个 p-单纯形 $[v_{i_{0}}, \\dots, v_{i_{p}}]$ 的边界是 $\\sum_{j=0}^{p} (-1)^{j} [v_{i_{0}}, \\dots, \\widehat{v_{i_{j}}}, \\dots, v_{i_{p}}]$。在 $\\mathbb{F}_{2}$ 中计算时，因为 $-1 \\equiv 1 \\pmod 2$，这简化为所有 $(p-1)$-面的和。\n\n$C_{2}$ 的第一个基元的边界是：\n$\\partial_{2}(\\tau_{125}) = \\partial_{2}([v_{1}, v_{2}, v_{5}]) = [v_{2}, v_{5}] + [v_{1}, v_{5}] + [v_{1}, v_{2}] = e_{25} + e_{15} + e_{12}$。\n$C_{2}$ 的第二个基元的边界是：\n$\\partial_{2}(\\tau_{345}) = \\partial_{2}([v_{3}, v_{4}, v_{5}]) = [v_{4}, v_{5}] + [v_{3}, v_{5}] + [v_{3}, v_{4}] = e_{45} + e_{35} + e_{34}$。\n\n$\\partial_2$ 的矩阵表示（记为 $D_2$）的列对应于 $C_2$ 基向量的像。其维度为 $\\dim(C_1) \\times \\dim(C_2) = 7 \\times 2$。\n$$D_{2} =\n\\begin{pmatrix}\n1  0 \\\\\n0  0 \\\\\n0  1 \\\\\n0  1 \\\\\n1  0 \\\\\n1  0 \\\\\n0  1\n\\end{pmatrix}\n\\begin{matrix} \\\n\\leftarrow e_{12} \\\\ \\leftarrow e_{23} \\\\ \\leftarrow e_{34} \\\\ \\leftarrow e_{45} \\\\ \\leftarrow e_{15} \\\\ \\leftarrow e_{25} \\\\ \\leftarrow e_{35} \\end{matrix}\n$$\n这两个列向量在 $\\mathbb{F}_{2}$ 上是线性无关的，因为对于行 $1, 5, 6$ 与行 $3, 4, 7$ 来说，它们在不相交的行集合中有非零项。因此，该矩阵的秩为 $2$。\n$\\operatorname{rank}(\\partial_{2}) = \\operatorname{rank}(D_{2}) = 2$。\n\n接下来，我们构建 $\\partial_{1} : C_{1}(K;\\mathbb{F}_{2}) \\to C_{0}(K;\\mathbb{F}_{2})$ 的矩阵。$C_{1}$ 的基是 $\\{e_{12}, e_{23}, e_{34}, e_{45}, e_{15}, e_{25}, e_{35}\\}$，$C_{0}$ 的基是 $\\{v_{1}, v_{2}, v_{3}, v_{4}, v_{5}\\}$。\n一条边 $[v_{i}, v_{j}]$ 的边界是 $v_{j} + v_{i}$ (在 $\\mathbb{F}_{2}$ 中)。\n$\\partial_{1}(e_{12}) = v_{1} + v_{2}$\n$\\partial_{1}(e_{23}) = v_{2} + v_{3}$\n$\\partial_{1}(e_{34}) = v_{3} + v_{4}$\n$\\partial_{1}(e_{45}) = v_{4} + v_{5}$\n$\\partial_{1}(e_{15}) = v_{1} + v_{5}$\n$\\partial_{1}(e_{25}) = v_{2} + v_{5}$\n$\\partial_{1}(e_{35}) = v_{3} + v_{5}$\n\n$\\partial_1$ 的矩阵表示（记为 $D_1$）的维度为 $\\dim(C_0) \\times \\dim(C_1) = 5 \\times 7$。\n$$D_{1} =\n\\begin{pmatrix}\n1  0  0  0  1  0  0 \\\\\n1  1  0  0  0  1  0 \\\\\n0  1  1  0  0  0  1 \\\\\n0  0  1  1  0  0  0 \\\\\n0  0  0  1  1  1  1\n\\end{pmatrix}$$\n为了求 $D_{1}$ 的秩，我们对其进行高斯消元法（在 $\\mathbb{F}_{2}$ 上）以将其化为行阶梯形。令 $R_{i}$ 表示第 $i$ 行。\n$$\n\\begin{pmatrix}\n1  0  0  0  1  0  0 \\\\\n1  1  0  0  0  1  0 \\\\\n0  1  1  0  0  0  1 \\\\\n0  0  1  1  0  0  0 \\\\\n0  0  0  1  1  1  1\n\\end{pmatrix}\n\\xrightarrow{R_{2} \\leftarrow R_{2} + R_{1}}\n\\begin{pmatrix}\n1  0  0  0  1  0  0 \\\\\n0  1  0  0  1  1  0 \\\\\n0  1  1  0  0  0  1 \\\\\n0  0  1  1  0  0  0 \\\\\n0  0  0  1  1  1  1\n\\end{pmatrix}\n$$\n$$\n\\xrightarrow{R_{3} \\leftarrow R_{3} + R_{2}}\n\\begin{pmatrix}\n1  0  0  0  1  0  0 \\\\\n0  1  0  0  1  1  0 \\\\\n0  0  1  0  1  1  1 \\\\\n0  0  1  1  0  0  0 \\\\\n0  0  0  1  1  1  1\n\\end{pmatrix}\n\\xrightarrow{R_{4} \\leftarrow R_{4} + R_{3}}\n\\begin{pmatrix}\n1  0  0  0  1  0  0 \\\\\n0  1  0  0  1  1  0 \\\\\n0  0  1  0  1  1  1 \\\\\n0  0  0  1  1  1  1 \\\\\n0  0  0  1  1  1  1\n\\end{pmatrix}\n$$\n$$\n\\xrightarrow{R_{5} \\leftarrow R_{5} + R_{4}}\n\\begin{pmatrix}\n1  0  0  0  1  0  0 \\\\\n0  1  0  0  1  1  0 \\\\\n0  0  1  0  1  1  1 \\\\\n0  0  0  1  1  1  1 \\\\\n0  0  0  0  0  0  0\n\\end{pmatrix}\n$$\n得到的行阶梯形矩阵有 $4$ 个非零行，所以它的秩是 $4$。\n$\\operatorname{rank}(\\partial_{1}) = \\operatorname{rank}(D_{1}) = 4$。\n\n现在我们有了计算 $\\beta_{1}$ 所需的所有要素。\n$\\dim(C_{1}) = 7$\n$\\operatorname{rank}(\\partial_{1}) = 4$\n$\\operatorname{rank}(\\partial_{2}) = 2$\n\n将这些值代入 Betti 数的公式：\n$$\\beta_{1} = \\dim(C_{1}) - \\operatorname{rank}(\\partial_{1}) - \\operatorname{rank}(\\partial_{2}) = 7 - 4 - 2 = 1$$\n\n第一个 Betti 数是 $1$。这表示在单纯复形 $K$ 中存在一个独立的一维“洞”。", "answer": "$$\n\\boxed{1}\n$$", "id": "3355925"}, {"introduction": "持久同调的输出是持久性图，它可视化了数据在不同尺度下的拓扑特征。为了比较不同实验条件或样本，我们需要一种严谨的方法来量化这些图之间的差异。本练习将介绍两种关键的度量——瓶颈距离 ($d_B$) 和1-瓦瑟斯坦距离 ($W_1$)，并让您通过一个具体的匹配问题亲手计算它们，从而深入理解它们在区分信号与噪声时的不同特性。[@problem_id:3355848]", "problem": "空间转录组学中的两个实验条件，通过对细胞间距离进行 Vietoris–Rips 过滤，并使用拓扑数据分析（TDA）进行分析，产生了两个一维同调特征集。由此产生的持续性图记录了环状结构的生死对，这些结构反映了稳定的组织域（长寿特征）和瞬时的测量波动（短寿特征）。考虑两个持续性图\n$$D_A = \\{(0.05,\\,0.70),\\,(0.30,\\,0.35)\\} \\quad \\text{和} \\quad D_B = \\{(0.06,\\,0.71),\\,(0.48,\\,0.50)\\}.$$\n使用 $L^{\\infty}$ 基度量进行匹配：匹配两个非对角点 $(b,\\,d)$ 和 $(b',\\,d')$ 的成本是 $\\max\\!\\big(|b-b'|,\\,|d-d'|\\big)$，而将一个非对角点 $(b,\\,d)$ 匹配到对角线的成本是 $(d-b)/2$。瓶颈距离 $d_B$ 定义为，在两个图（都增加了无限多个对角线点）之间的所有双射中，最大匹配成本的下确界；$1$-Wasserstein 距离 $W_1$ 是此类双射中匹配成本总和的下确界。\n\n通过解决匹配问题，精确计算 $d_B(D_A,D_B)$ 和 $W_1(D_A,D_B)$。然后，根据长寿特征对应于稳定组织域而短寿特征类似噪声的生物学解释，论证在此示例中哪种度量更能反映有意义的生物学变异。\n\n将最终数值结果表示为行矩阵 $\\big[d_B,\\,W_1\\big]$，无需四舍五入。", "solution": "该问题要求计算两个持久同调图 $D_A$ 和 $D_B$ 之间的瓶颈距离 $d_B$ 和 1-瓦瑟斯坦距离 $W_1$。这需要找到两个图的点集之间的最优双射（匹配），允许点匹配到对角线 $\\Delta$。\n\n首先，我们列出两个图中的点，并计算它们的持久性（生命周期长度 $d-b$）和匹配到对角线的成本（持久性的一半）。\n\n对于图 $D_A = \\{p_1, p_2\\} = \\{(0.05, 0.70), (0.30, 0.35)\\}$：\n-   点 $p_1 = (0.05, 0.70)$：持久性 = $0.70 - 0.05 = 0.65$ (长寿特征/信号)。匹配到 $\\Delta$ 的成本 $C(p_1, \\Delta) = 0.65 / 2 = 0.325$。\n-   点 $p_2 = (0.30, 0.35)$：持久性 = $0.35 - 0.30 = 0.05$ (短寿特征/噪声)。匹配到 $\\Delta$ 的成本 $C(p_2, \\Delta) = 0.05 / 2 = 0.025$。\n\n对于图 $D_B = \\{q_1, q_2\\} = \\{(0.06, 0.71), (0.48, 0.50)\\}$：\n-   点 $q_1 = (0.06, 0.71)$：持久性 = $0.71 - 0.06 = 0.65$ (长寿特征/信号)。匹配到 $\\Delta$ 的成本 $C(q_1, \\Delta) = 0.65 / 2 = 0.325$。\n-   点 $q_2 = (0.48, 0.50)$：持久性 = $0.50 - 0.48 = 0.02$ (短寿特征/噪声)。匹配到 $\\Delta$ 的成本 $C(q_2, \\Delta) = 0.02 / 2 = 0.01$。\n\n接下来，我们计算点与点之间的匹配成本，使用 $L^{\\infty}$ 距离：\n-   $C(p_1, q_1) = \\max(|0.05 - 0.06|, |0.70 - 0.71|) = \\max(0.01, 0.01) = 0.01$。\n-   $C(p_1, q_2) = \\max(|0.05 - 0.48|, |0.70 - 0.50|) = \\max(0.43, 0.20) = 0.43$。\n-   $C(p_2, q_1) = \\max(|0.30 - 0.06|, |0.35 - 0.71|) = \\max(0.24, 0.36) = 0.36$。\n-   $C(p_2, q_2) = \\max(|0.30 - 0.48|, |0.35 - 0.50|) = \\max(0.18, 0.15) = 0.18$。\n\n现在我们考虑最优匹配方案。直观上，两个长寿特征 $p_1$ 和 $q_1$ 应该互相匹配，而两个短寿特征 $p_2$ 和 $q_2$ 则被视为噪声并匹配到对角线。这个匹配为 $\\gamma_{\\text{opt}} = \\{(p_1, q_1), (p_2, \\Delta), (\\Delta, q_2)\\}$。\n-   匹配成本集：$\\{C(p_1, q_1), C(p_2, \\Delta), C(q_2, \\Delta)\\} = \\{0.01, 0.025, 0.01\\}$。\n-   $d_B(\\gamma_{\\text{opt}}) = \\max(0.01, 0.025, 0.01) = 0.025$。\n-   $W_1(\\gamma_{\\text{opt}}) = 0.01 + 0.025 + 0.01 = 0.045$。\n\n通过比较此方案与其他可能的匹配（例如，直接匹配 $\\{(p_1, q_1), (p_2, q_2)\\}$，其 $d_B = 0.18$，$W_1=0.19$），我们确认 $\\gamma_{\\text{opt}}$ 是最优的，因为它在两种度量下都给出了最小的成本。\n\n最终距离为：\n-   $d_B(D_A, D_B) = 0.025$。\n-   $W_1(D_A, D_B) = 0.045$。\n\n**论证：**\n在本例中，$W_1$ 距离更能反映有意义的生物学变异。\n瓶颈距离 $d_B$ 是一个“最坏情况”的度量，其值 $0.025$ 完全由将噪声点 $p_2$ 匹配到对角线的成本决定。它对两个实验条件中稳定组织域（信号点 $p_1, q_1$）之间的微小差异（成本为 $0.01$）不敏感。\n相比之下，1-瓦瑟斯坦距离 $W_1$ 是一个累积度量。其值 $0.045$ 是所有匹配成本的总和，它既包含了信号点之间差异的贡献（$0.01$），也包含了滤除两个噪声点的成本（$0.025 + 0.01$）。因此，$W_1$ 提供了一个更全面的视图，能同时反映信号的变化和噪声的程度，使其成为评估整体生物学变异的更细致的指标。", "answer": "$$ \\boxed{ \\begin{pmatrix} 0.025  0.045 \\end{pmatrix} } $$", "id": "3355848"}, {"introduction": "在拓扑数据分析中，如何从原始数据（如点云）构建一个过滤（filtration）是至关重要的第一步，这个选择直接影响最终的拓扑特征。本计算练习将带您实现并比较两种常用的过滤函数——k近邻（kNN）距离和到测度的距离（DTM），并通过计算零维持久同调来评估它们在存在离群点时的鲁棒性。[@problem_id:3355953]", "problem": "给定一个嵌入在二维欧几里得平面（具有标准欧几里得度量）中的有限点云。您必须严格比较从该点云定义的两种标量滤除：到测度的距离和k-最近邻距离。具体方法为，在离散化的立方复形上计算子水平集的零维持续同调，并利用规定的摘要统计量来量化其对离群点的鲁棒性。\n\n基本基础和定义：\n\n- 设环境空间为 $\\mathbb{R}^2$，其欧几里得距离为 $d(\\mathbf{x},\\mathbf{y})=\\|\\mathbf{x}-\\mathbf{y}\\|_2$。\n- 设点云为 $P=\\{\\mathbf{p}_1,\\ldots,\\mathbf{p}_n\\}\\subset\\mathbb{R}^2$。\n- 对于任意 $\\mathbf{x}\\in\\mathbb{R}^2$，令 $d_i(\\mathbf{x})$ 表示 $\\mathbf{x}$ 到 $P$ 中第 $i$ 个最近点的距离（基于距离 $d$）。\n- 定义k-最近邻（kNN）距离函数 $g_k:\\mathbb{R}^2\\to\\mathbb{R}$ 为 $g_k(\\mathbf{x})=d_k(\\mathbf{x})$。\n- 对于固定的整数 $k\\geq 1$ 和指数 $q0$，定义到测度的距离（DTM）函数 $f_{k,q}:\\mathbb{R}^2\\to\\mathbb{R}$ 为\n$$\nf_{k,q}(\\mathbf{x})=\\left(\\frac{1}{k}\\sum_{i=1}^k d_i(\\mathbf{x})^q\\right)^{1/q}.\n$$\n- 对于任意标量场 $h:\\mathbb{R}^2\\to\\mathbb{R}$，考虑其子水平集滤除 $\\{h^{-1}(-\\infty,t]\\}_{t\\in\\mathbb{R}}$。该滤除的零维持续同调记录了随着 $t$ 增大，连通分量的生成（birth）和湮灭（death）水平。一个分量的生存期（lifetime）是其湮灭水平减去其生成水平。\n\n离散化与计算模型：\n\n- 在边界框 $[-1,1]\\times[-1,1]$ 上使用一个分辨率为 $N\\times N$（其中 $N=60$）顶点的规则正方形网格。将网格顶点视为二维立方复形的单元，其邻接关系为 $4$-邻域。在网格顶点上评估每个标量场 $h$，并通过按 $h$ 值递增的顺序激活顶点来构建子水平滤除（平局情况可以任意但一致地处理）。当一个顶点被激活时，如果它的邻居中没有已激活的，它就生成一个新的连通分量；否则，它会附着到具有最小生成值的最老邻居分量上，并将所有其他邻居分量合并到该最老分量中，导致它们在当前的激活值处湮灭。处理完所有顶点后，任何剩余的分量将在场的最大值处湮灭。这就是在立方子水平滤除上计算零维持续同调的过程。\n\n鲁棒性摘要统计量：\n\n- 对于网格上的给定标量场 $h$，令 $L(h)$ 为通过上述算法产生的零维生存期的多重集。令 $h_{\\min}$ 和 $h_{\\max}$ 分别为 $h$ 在网格上的最小值和最大值。定义动态范围 $\\Delta(h)=h_{\\max}-h_{\\min}$。对于固定的分数 $\\alpha=0.2$，定义计数\n$$\nC_\\alpha(h)=\\#\\{\\ell\\in L(h): \\ell\\geq \\alpha\\,\\Delta(h)\\}.\n$$\n解释：$C_\\alpha(h)$ 计算了相对于 $h$ 的动态范围而言，长生存期连通分量的数量。一个对离群点更鲁棒的滤除函数会产生较少的伪长生存期分量，因此当存在离群点时，较低的 $C_\\alpha(h)$ 值更优。\n\n您的任务：\n\n1. 实现两个标量场：用于到测度的距离的 $f_{k,2}$（指数 $q=2$）和用于k-最近邻距离的 $g_k$，两者都在 $N\\times N$ 网格上进行评估。\n2. 使用并查集方法，并遵循最老分量在合并中存活的规则，为网格上的子水平滤除实现零维持续同调计算。\n3. 对每个测试用例，计算 $C_\\alpha(f_{k,2})$ 和 $C_\\alpha(g_k)$，并返回差值 $C_\\alpha(f_{k,2})-C_\\alpha(g_k)$ 作为一个整数。正值表示k-最近邻距离产生的长生存期分量比到测度的距离少；负值表示相反；零表示数量相等。您必须根据该算法精确计算此值，不允许使用启发式捷径。\n\n测试套件：\n\n为确保可复现性，所有采样均使用固定的伪随机生成器种子 $s=42$。对于每个案例，点云是通过从指定的高斯簇中独立抽取样本生成的，并在说明时包含一个确定的离群点。所有标准差都是各向同性的，并在两个坐标轴上指定为相同的值。\n\n- 案例 $1$（两个簇，一个离群点，中等 $k$ 值）：\n  - 簇 A：均值 $\\boldsymbol{\\mu}_A=(-0.3,0.0)$，标准差 $\\sigma_A=0.06$，大小 $n_A=40$。\n  - 簇 B：均值 $\\boldsymbol{\\mu}_B=(0.35,0.15)$，标准差 $\\sigma_B=0.06$，大小 $n_B=40$。\n  - 离群点 $\\mathbf{o}_1=(0.0,0.9)$。\n  - 参数 $k=5$。\n- 案例 $2$（相同簇，无离群点）：\n  - 簇 A：均值 $\\boldsymbol{\\mu}_A=(-0.3,0.0)$，标准差 $\\sigma_A=0.06$，大小 $n_A=40$。\n  - 簇 B：均值 $\\boldsymbol{\\mu}_B=(0.35,0.15)$，标准差 $\\sigma_B=0.06$，大小 $n_B=40$。\n  - 无离群点。\n  - 参数 $k=5$。\n- 案例 $3$（小簇，极端离群点，边界 $k$ 值）：\n  - 簇 C：均值 $\\boldsymbol{\\mu}_C=(-0.2,-0.2)$，标准差 $\\sigma_C=0.03$，大小 $n_C=12$。\n  - 离群点 $\\mathbf{o}_3=(0.9,-0.9)$。\n  - 参数 $k=1$。\n- 案例 $4$（两个簇，一个离群点，较大 $k$ 值）：\n  - 与案例1相同的簇和离群点。\n  - 参数 $k=12$。\n\n所有点云都是簇样本（作为独立高斯向量抽取）和离群点（若存在）的并集。所有案例使用相同的网格。距离为欧几里得距离。角度不出现。物理单位不适用。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含四个案例的结果，格式为逗号分隔的列表，并用方括号括起来，顺序为案例1、案例2、案例3、案例4，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是对应案例的整数 $C_\\alpha(f_{k,2})-C_\\alpha(g_k)$。不应打印任何其他文本。", "solution": "该问题要求对源自点云 $P \\subset \\mathbb{R}^2$ 的两个标量场进行严格的鲁棒性比较：$k$-最近邻（kNN）距离函数 $g_k$ 和到测度的距离（DTM）函数 $f_{k,q}$。比较方式为，在一个离散化域上计算它们子水平集滤除的零维持续同调，并使用一个特定的统计量 $C_\\alpha(h)$ 来总结结果。该问题定义明确，并在拓扑数据分析领域具有坚实的科学基础。\n\n首先，我们建立计算域。环境空间 $\\mathbb{R}^2$ 被离散化为一个在正方形 $[-1, 1] \\times [-1, 1]$ 上，分辨率为 $N \\times N$（$N=60$）的规则网格。这些顶点构成立方复形的 $0$-胞腔。网格点记为 $\\mathbf{x}_{ij}$，其中 $i, j \\in \\{0, \\ldots, N-1\\}$。\n\n对于四个测试用例中的每一个，都会生成一个点云 $P$。这涉及使用带有固定种子 $s=42$ 的 `numpy.random.Generator` 从指定的高斯分布中采样点，以确保可复现性，并添加指定的离群点。\n\n接下来，对于每个网格顶点 $\\mathbf{x}$，我们评估两个标量函数，$g_k(\\mathbf{x})$ 和 $f_{k,2}(\\mathbf{x})$（因为问题设定指数 $q=2$）。这需要计算从 $\\mathbf{x}$ 到每个点 $\\mathbf{p} \\in P$ 的欧几里得距离。然后对这些距离进行排序，以找到 $k$ 个最小的值，记为 $d_1(\\mathbf{x}), d_2(\\mathbf{x}), \\ldots, d_k(\\mathbf{x})$。\nkNN距离函数由第 $k$ 小的距离给出：\n$$g_k(\\mathbf{x}) = d_k(\\mathbf{x}).$$\nDTM函数计算为前 $k$ 个距离的二次平均值：\n$$f_{k,2}(\\mathbf{x}) = \\left(\\frac{1}{k}\\sum_{i=1}^k d_i(\\mathbf{x})^2\\right)^{1/2}.$$\n这些计算对 $N \\times N$ 网格上的每个顶点执行，从而产生两个 $N \\times N$ 的标量值数组，我们将其表示为 $H_g$ 和 $H_f$。\n\n任务的核心是为每个标量场 $h$（其中 $h$ 为 $g_k$ 或 $f_{k,2}$）计算子水平集滤除的零维持续同调（$H_0$）。滤除是通过按相关标量值 $h(\\mathbf{x})$ 的递增顺序处理网格顶点来构建的。此过程跟踪连通分量的生成和湮灭。执行此任务的一个高效算法是并查集（Union-Find 或 Disjoint Set Union, DSU）数据结构。\n\n算法流程如下：\n1.  收集所有 $N^2$ 个网格顶点及其标量值。按标量值对这些顶点进行升序排序。使用稳定排序以确保一致的平局处理。设排序后的顶点为 $v_1, v_2, \\ldots, v_{N^2}$，对应的标量值（激活时间）为 $t_1 \\le t_2 \\le \\ldots \\le t_{N^2}$。\n2.  初始化一个包含 $N^2$ 个元素的DSU数据结构，每个顶点一个，将每个顶点放入其自己的集合中。我们还维护一个记录每个分量生成时间的记录，按其集合的代表元素索引。\n3.  我们从 $m=1$ 到 $N^2$ 遍历排序后的顶点 $v_m$。在处理激活时间为 $t_m$ 的顶点 $v_m$ 时：\n    a. 我们识别其在 $4$-连通网格中已经处理过的邻居（即顶点 $v_j$ 且 $j  m$）。\n    b. 如果 $v_m$ 没有已激活的邻居，它会生成一个新的连通分量。其生成时间记录为 $t_m$，并且它在DSU中保留在自己的集合里。\n    c. 如果 $v_m$ 有一个或多个已激活的邻居，它将连接到它们的分量。根据指定的规则，我们识别其邻居中“最老”的分量——即生成时间最小的那个。所有其他邻居分量都被合并到这个最老的分量中。对于每次这样的合并，一个分量在当前时间 $t_m$“湮灭”。记录一个持续同调对（生成时间，湮灭时间）。然后，顶点 $v_m$ 也被合并到这个最老的分量中。DSU的 `union` 操作被定向执行，以确保最老分量的代表成为合并后集合的新代表。\n4.  处理完所有顶点后，通常会剩下一个分量，它是在全局最小标量值 $h_{\\min}$ 时生成的。根据问题规范，这最后一个分量在最大标量值 $h_{\\max}$ 时“湮灭”。这产生了最后一个持续同调对 $(h_{\\min}, h_{\\max})$。\n\n从完整的持续同调对（生成, 湮灭）列表中，我们计算生存期 $L(h)$ 的多重集，其中每个生存期 $\\ell$ 由 $\\ell = \\text{湮灭} - \\text{生成}$ 给出。\n\n最后，我们计算鲁棒性摘要统计量 $C_\\alpha(h)$。这包括：\n1.  计算标量场在网格上的动态范围：$\\Delta(h) = h_{\\max} - h_{\\min}$。\n2.  计算“长生存期”分量的数量，定义为生存期 $\\ell$ 满足 $\\ell \\ge \\alpha \\Delta(h)$ 的分量。问题指定 $\\alpha=0.2$。这个计数就是 $C_\\alpha(h)$。较小的 $C_\\alpha(h)$ 值表明对离群点有更强的鲁棒性，因为它意味着伪影般的、长生存期的拓扑特征较少。\n\n对于每个测试用例，都对DTM场 $h=f_{k,2}$ 和kNN场 $h=g_k$ 执行这整个过程。该用例的最终结果是整数差值 $C_\\alpha(f_{k,2}) - C_\\alpha(g_k)$。这个值量化了在测试用例条件下这两个函数的相对鲁棒性。案例3是实现的一个合理性检查，其中 $k=1$。在这种情况下，$f_{1,2}(\\mathbf{x}) = g_1(\\mathbf{x})$，意味着这两个场是完全相同的。因此，它们的持续同调图和摘要统计量必须相同，从而导致差值为 $0$。", "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\nclass DSU:\n    \"\"\"A Disjoint Set Union (DSU) data structure with path compression.\"\"\"\n    def __init__(self, n):\n        self.parent = np.arange(n)\n    \n    def find(self, i):\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"Merges set containing i into set containing j.\"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            self.parent[root_i] = root_j\n            return True\n        return False\n\ndef _compute_persistence_lifetimes(h, N):\n    \"\"\"\n    Computes 0D persistence lifetimes for a scalar field h on an N x N grid.\n    \"\"\"\n    h_flat = h.flatten()\n    sorted_indices = np.argsort(h_flat, kind='stable')\n    \n    dsu = DSU(N * N)\n    birth_times = {}\n    persistence_pairs = []\n    \n    # A reverse mapping to quickly check if a neighbor is already processed.\n    # rank[i] gives the processing order of vertex i.\n    rank = np.empty_like(sorted_indices)\n    rank[sorted_indices] = np.arange(N * N)\n\n    for i in range(N * N):\n        vertex_idx = sorted_indices[i]\n        activation_time = h_flat[vertex_idx]\n        \n        r, c = vertex_idx // N, vertex_idx % N\n        \n        # Find processed neighbors\n        active_neighbors = []\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            if 0 = nr  N and 0 = nc  N:\n                neighbor_idx = nr * N + nc\n                if rank[neighbor_idx]  i: # Check if neighbor was processed\n                    active_neighbors.append(neighbor_idx)\n        \n        neighbor_roots = {dsu.find(n_idx) for n_idx in active_neighbors}\n        \n        if not neighbor_roots:\n            # Birth of a new component\n            birth_times[vertex_idx] = activation_time\n        else:\n            # Find oldest component among neighbors\n            oldest_root = min(neighbor_roots, key=lambda root: birth_times[root])\n            \n            # Merge other components into the oldest one\n            for root in neighbor_roots:\n                if root != oldest_root:\n                    if root in birth_times:\n                        persistence_pairs.append((birth_times[root], activation_time))\n                        dsu.union(root, oldest_root)\n                        del birth_times[root]\n            \n            # Merge current vertex into the oldest component\n            dsu.union(vertex_idx, oldest_root)\n\n    # The last remaining component dies at h_max\n    h_min = h_flat[sorted_indices[0]]\n    h_max = h_flat[sorted_indices[-1]]\n    if h_min != h_max:\n        persistence_pairs.append((h_min, h_max))\n\n    lifetimes = np.array([death - birth for birth, death in persistence_pairs])\n    return lifetimes, h_min, h_max\n\ndef solve():\n    test_cases = [\n        {\n            \"clusters\": [\n                {\"mean\": (-0.3, 0.0), \"std\": 0.06, \"size\": 40},\n                {\"mean\": (0.35, 0.15), \"std\": 0.06, \"size\": 40},\n            ],\n            \"outliers\": [(0.0, 0.9)],\n            \"k\": 5,\n        },\n        {\n            \"clusters\": [\n                {\"mean\": (-0.3, 0.0), \"std\": 0.06, \"size\": 40},\n                {\"mean\": (0.35, 0.15), \"std\": 0.06, \"size\": 40},\n            ],\n            \"outliers\": [],\n            \"k\": 5,\n        },\n        {\n            \"clusters\": [\n                {\"mean\": (-0.2, -0.2), \"std\": 0.03, \"size\": 12},\n            ],\n            \"outliers\": [(0.9, -0.9)],\n            \"k\": 1,\n        },\n        {\n            \"clusters\": [\n                {\"mean\": (-0.3, 0.0), \"std\": 0.06, \"size\": 40},\n                {\"mean\": (0.35, 0.15), \"std\": 0.06, \"size\": 40},\n            ],\n            \"outliers\": [(0.0, 0.9)],\n            \"k\": 12,\n        },\n    ]\n\n    N = 60\n    ALPHA = 0.2\n    Q = 2.0\n    SEED = 42\n\n    rng = np.random.default_rng(SEED)\n\n    grid_coords = np.linspace(-1, 1, N)\n    grid_x, grid_y = np.meshgrid(grid_coords, grid_coords)\n    grid_points = np.vstack([grid_x.ravel(), grid_y.ravel()]).T\n\n    results = []\n\n    for case in test_cases:\n        # 1. Generate point cloud\n        points = []\n        for cluster in case[\"clusters\"]:\n            cov = np.eye(2) * (cluster[\"std\"] ** 2)\n            points.append(rng.multivariate_normal(cluster[\"mean\"], cov, cluster[\"size\"]))\n        \n        if case[\"outliers\"]:\n            points.append(np.array(case[\"outliers\"]))\n\n        point_cloud = np.vstack(points)\n        k = case[\"k\"]\n\n        # 2. Evaluate scalar fields\n        # Shape: (num_grid_points, num_cloud_points)\n        distances = cdist(grid_points, point_cloud)\n        distances.sort(axis=1)\n        \n        # Take the first k distances\n        k_distances = distances[:, :k]\n        \n        # g_k function (kNN)\n        h_knn = k_distances[:, -1].reshape(N, N)\n        \n        # f_{k,2} function (DTM)\n        if k == 1:\n            h_dtm = h_knn # For k=1, d_1(x) = (\\frac{1}{1}d_1(x)^2)^0.5\n        else:\n            h_dtm = np.power(np.mean(np.power(k_distances, Q), axis=1), 1/Q).reshape(N, N)\n\n        # 3. Compute statistics for each field\n        counts = []\n        for h_field in [h_dtm, h_knn]:\n            lifetimes, h_min, h_max = _compute_persistence_lifetimes(h_field, N)\n            dynamic_range = h_max - h_min\n            \n            if dynamic_range > 0:\n                threshold = ALPHA * dynamic_range\n                count = np.sum(lifetimes >= threshold)\n            else:\n                count = 0\n            counts.append(count)\n        \n        # 4. Store difference\n        # C_alpha(f_{k,2}) - C_alpha(g_k)\n        results.append(counts[0] - counts[1])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3355953"}]}