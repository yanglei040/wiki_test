{"hands_on_practices": [{"introduction": "翻译起始是基因表达调控中的一个关键瓶颈，其效率决定了蛋白质的合成速率。这个练习将引导你将一个经典的生物学机制——核糖体扫描模型——转化为一个定量的数学框架。通过运用泊松过程和风险率等随机过程理论的基本概念，你将从第一性原理出发，推导出在不同调控元件（如uORF和Kozak序列）影响下的翻译起始率[@problem_id:3325094]。这项实践旨在锻炼你将复杂的生物学假设抽象为可检验的动力学模型的核心能力。", "problem": "一条信使核糖核酸 (mRNA) 被真核生物的 $43\\mathrm{S}$ 预起始复合物 (PIC) 翻译。该复合物结合在 $5^{\\prime}$ 端帽上，并沿 $5^{\\prime}\\to 3^{\\prime}$ 方向扫描，以定位 AUG 起始密码子。假设以下经过充分检验的机理基础：(i) 扫描以恒定速度 $v$（核苷酸/秒）进行，(ii) 在局部 Kozak 上下文中对 AUG 的识别是一个无记忆（泊松）捕获过程，其速率与一个无量纲的 Kozak 强度 $s\\in[0,1]$ 成正比，以及 (iii) 在扫描过程中，PIC 会以恒定的风险率 $k_{\\text{off}}$（每秒）解离。这些假设意味着，在一个有限的识别窗口内未被捕获（渗漏扫描）的概率等于泊松过程的存活概率，并且沿 $5^{\\prime}$ 非翻译区上各位点之间的存活概率等于恒定风险率过程在相应扫描时间内的存活概率。\n\n考虑一个 mRNA，其上有一个上游开放阅读框 (uORF)，随后是主开放阅读框 (main ORF)。uAUG 位于 $5'$ 端帽下游 $D$ 个核苷酸处，而主 AUG 位于 uAUG 下游另外 $L$ 个核苷酸处。任何 AUG 周围的识别窗口宽度为 $w$ 个核苷酸。对于 Kozak 强度为 $s$ 的 AUG，其捕获率为 $k_{0}s$（每秒），其中 $k_{0}$ 是一个常数。PIC 以速率 $J_{0}$（每秒）加载到端帽上。假设 PIC 之间无相互作用（无排队），在 uORF 翻译终止后无再起始，并且在 AUG 处的起始在捕获后是瞬时发生的。\n\n1. 从第一性原理出发，构建渗漏扫描概率 $p_{\\text{leak}}(s)$，将其表示为 Kozak 强度 $s$、识别窗口宽度 $w$、扫描速度 $v$ 和基础捕获率 $k_{0}$ 的函数。\n2. 使用你得到的 $p_{\\text{leak}}(s)$ 表达式以及扫描过程中的恒定风险率存活概率，推导出 uORF ($J_{\\mathrm{u}}$) 和主 ORF ($J_{\\mathrm{m}}$) 处的稳态起始率，将其表示为 $J_{0}$、$D$、$L$、$v$、$k_{\\text{off}}$、$k_{0}$、$w$ 以及各自的 Kozak 强度 $s_{\\mathrm{u}}$ 和 $s_{\\mathrm{m}}$ 的函数。\n3. 对以下参数集，数值计算 $J_{\\mathrm{u}}$ 和 $J_{\\mathrm{m}}$：$J_{0}=\\,$ $0.50$ $\\mathrm{s}^{-1}$，$v=\\,$ $10$ $\\mathrm{nt}\\cdot\\mathrm{s}^{-1}$，$w=\\,$ $12$ $\\mathrm{nt}$，$k_{0}=\\,$ $2.0$ $\\mathrm{s}^{-1}$，$k_{\\text{off}}=\\,$ $0.010$ $\\mathrm{s}^{-1}$，$D=\\,$ $60$ $\\mathrm{nt}$，$L=\\,$ $120$ $\\mathrm{nt}$，$s_{\\mathrm{u}}=\\,$ $0.60$ 和 $s_{\\mathrm{m}}=\\,$ $0.90$。\n\n将这两个起始率以一个二元行向量 $\\big(J_{\\mathrm{u}},\\,J_{\\mathrm{m}}\\big)$ 的形式报告，单位为 $\\mathrm{s}^{-1}$，并四舍五入到三位有效数字。", "solution": "问题陈述已经过验证，被认为是具有科学依据、提法恰当、客观且自洽的。所提出的模型是真核生物翻译起始的一个标准简化表示，在计算系统生物学中经常使用。所有必要的参数和假设都已明确定义。\n\n### 第1部分：渗漏扫描概率 $p_{\\text{leak}}(s)$ 的推导\n\n问题将 AUG 密码子的识别定义为一个无记忆的泊松捕获过程。渗漏扫描的概率 $p_{\\text{leak}}(s)$ 是指预起始复合物 (PIC) 扫描通过 AUG 周围的识别窗口而未被捕获的概率。这等同于 PIC 在该窗口内停留的时间段里，泊松过程的存活概率。\n\n首先，我们确定 PIC 以恒定速度 $v$ 扫描过宽度为 $w$ 的识别窗口所需的时间 $\\Delta t$：\n$$ \\Delta t = \\frac{w}{v} $$\n捕获过程的速率 $\\lambda$ 由 $k_{0}s$ 给出，其中 $k_{0}$ 是基础捕获率常数，$s$ 是无量纲的 Kozak 强度。\n$$ \\lambda = k_{0}s $$\n对于一个速率恒为 $\\lambda$ 的泊松过程，在时间间隔 $\\Delta t$ 内观察到零个事件（在本例中，即零次捕获事件）的概率由下式给出：\n$$ P(N(\\Delta t)=0) = \\exp(-\\lambda \\Delta t) $$\n根据定义，这个概率就是渗漏扫描概率 $p_{\\text{leak}}(s)$。代入 $\\lambda$ 和 $\\Delta t$ 的表达式，我们得到：\n$$ p_{\\text{leak}}(s) = \\exp\\left(-k_{0}s \\frac{w}{v}\\right) $$\n该表达式给出了 PIC 未能在 AUG 密码子处起始的概率，它是 Kozak 强度 $s$ 以及系统参数 $k_{0}$、$w$ 和 $v$ 的函数。\n\n### 第2部分：稳态起始率 $J_{\\mathrm{u}}$ 和 $J_{\\mathrm{m}}$ 的推导\n\n我们将 PIC 沿 mRNA 的流动建模为一系列级联的随机事件。PIC 加载到 $5^{\\prime}$ 端帽上的速率为 $J_{0}$。\n\n**uORF 处的起始率 ($J_{\\mathrm{u}}$):**\n一个 PIC 要在上游 AUG (uAUG) 处起始，它必须首先成功地从 $5^{\\prime}$ 端帽扫描到 uAUG（距离为 $D$ 个核苷酸）而不发生解离。此过程所需时间为 $t_{D} = D/v$。解离是一个恒定风险率过程，速率为 $k_{\\text{off}}$。一个 PIC 在此扫描区段存活下来的概率是：\n$$ P_{\\text{surv}}(t_{D}) = \\exp(-k_{\\text{off}} t_{D}) = \\exp\\left(-\\frac{k_{\\text{off}} D}{v}\\right) $$\nPIC 到达 uAUG 识别窗口的速率是初始加载速率 $J_{0}$ 乘以该存活概率：\n$$ J_{\\text{arrive, u}} = J_{0} \\exp\\left(-\\frac{k_{\\text{off}} D}{v}\\right) $$\n到达后，PIC 被捕获（起始）的概率为 $1 - p_{\\text{leak}}(s_{\\mathrm{u}})$，其中 $s_{\\mathrm{u}}$ 是 uAUG 的 Kozak 强度。uORF 处的稳态起始率 $J_{\\mathrm{u}}$ 是到达速率乘以捕获概率：\n$$ J_{\\mathrm{u}} = J_{\\text{arrive, u}} \\left(1 - p_{\\text{leak}}(s_{\\mathrm{u}})\\right) $$\n代入 $J_{\\text{arrive, u}}$ 和 $p_{\\text{leak}}(s_{\\mathrm{u}})$ 的表达式：\n$$ J_{\\mathrm{u}} = J_{0} \\exp\\left(-\\frac{k_{\\text{off}} D}{v}\\right) \\left[1 - \\exp\\left(-\\frac{k_{0} s_{\\mathrm{u}} w}{v}\\right)\\right] $$\n\n**主 ORF 处的起始率 ($J_{\\mathrm{m}}$):**\n一个 PIC 要在主 AUG (mAUG) 处起始，它必须首先经过 uAUG。这需要它先到达 uAUG，然后发生渗漏扫描。渗漏过 uAUG 的 PIC 速率是：\n$$ J_{\\text{leak, u}} = J_{\\text{arrive, u}} \\cdot p_{\\text{leak}}(s_{\\mathrm{u}}) = J_{0} \\exp\\left(-\\frac{k_{\\text{off}} D}{v}\\right) \\exp\\left(-\\frac{k_{0} s_{\\mathrm{u}} w}{v}\\right) $$\n这些 PIC 必须接着扫描额外的距离 $L$ 以到达主 AUG。所需时间为 $t_{L} = L/v$，并且在这一区段存活而不解离的概率是：\n$$ P_{\\text{surv}}(t_{L}) = \\exp(-k_{\\text{off}} t_{L}) = \\exp\\left(-\\frac{k_{\\text{off}} L}{v}\\right) $$\n到达主 AUG 的 PIC 速率是从 uAUG 渗漏的速率乘以在距离 $L$ 上的存活概率：\n$$ J_{\\text{arrive, m}} = J_{\\text{leak, u}} \\cdot P_{\\text{surv}}(t_{L}) = J_{0} \\exp\\left(-\\frac{k_{\\text{off}} D}{v}\\right) \\exp\\left(-\\frac{k_{0} s_{\\mathrm{u}} w}{v}\\right) \\exp\\left(-\\frac{k_{\\text{off}} L}{v}\\right) $$\n合并指数项，到达主 AUG 的速率是：\n$$ J_{\\text{arrive, m}} = J_{0} \\exp\\left(-\\frac{k_{\\text{off}}(D+L) + k_{0} s_{\\mathrm{u}} w}{v}\\right) $$\n主 ORF 处的起始率 $J_{\\mathrm{m}}$ 是这个到达速率乘以在主 AUG 处的捕获概率，该 AUG 的 Kozak 强度为 $s_{\\mathrm{m}}$：\n$$ J_{\\mathrm{m}} = J_{\\text{arrive, m}} \\left(1 - p_{\\text{leak}}(s_{\\mathrm{m}})\\right) $$\n代入 $J_{\\text{arrive, m}}$ 和 $p_{\\text{leak}}(s_{\\mathrm{m}})$ 的表达式，得到 $J_{\\mathrm{m}}$ 的最终表达式：\n$$ J_{\\mathrm{m}} = J_{0} \\exp\\left(-\\frac{k_{\\text{off}}(D+L) + k_{0} s_{\\mathrm{u}} w}{v}\\right) \\left[1 - \\exp\\left(-\\frac{k_{0} s_{\\mathrm{m}} w}{v}\\right)\\right] $$\n\n### 第3部分：数值计算\n\n我们已知以下参数值：\n$J_{0}=\\,$ $0.50$ $\\mathrm{s}^{-1}$\n$v=\\,$ $10$ $\\mathrm{nt}\\cdot\\mathrm{s}^{-1}$\n$w=\\,$ $12$ $\\mathrm{nt}$\n$k_{0}=\\,$ $2.0$ $\\mathrm{s}^{-1}$\n$k_{\\text{off}}=\\,$ $0.010$ $\\mathrm{s}^{-1}$\n$D=\\,$ $60$ $\\mathrm{nt}$\n$L=\\,$ $120$ $\\mathrm{nt}$\n$s_{\\mathrm{u}}=\\,$ $0.60$\n$s_{\\mathrm{m}}=\\,$ $0.90$\n\n首先，我们计算推导出的表达式中各指数的值。\n对于 $J_{\\mathrm{u}}$：\n解离指数为 $-\\frac{k_{\\text{off}} D}{v} = -\\frac{0.010 \\times 60}{10} = -0.06$。\nuAUG 捕获指数为 $-\\frac{k_{0} s_{\\mathrm{u}} w}{v} = -\\frac{2.0 \\times 0.60 \\times 12}{10} = -1.44$。\n将这些值代入 $J_{\\mathrm{u}}$ 的表达式中：\n$$ J_{\\mathrm{u}} = 0.50 \\times \\exp(-0.06) \\times [1 - \\exp(-1.44)] $$\n$$ J_{\\mathrm{u}} \\approx 0.50 \\times 0.94176 \\times (1 - 0.23693) $$\n$$ J_{\\mathrm{u}} \\approx 0.50 \\times 0.94176 \\times 0.76307 \\approx 0.35932 \\, \\mathrm{s}^{-1} $$\n\n对于 $J_{\\mathrm{m}}$：\n解离和渗漏扫描的组合指数为：\n$$ -\\frac{k_{\\text{off}}(D+L) + k_{0} s_{\\mathrm{u}} w}{v} = -\\frac{k_{\\text{off}}(60+120)}{10} - \\frac{k_{0} s_{\\mathrm{u}} w}{10} = -\\frac{0.010 \\times 180}{10} - 1.44 = -0.18 - 1.44 = -1.62 $$\n主 AUG 捕获指数为 $-\\frac{k_{0} s_{\\mathrm{m}} w}{v} = -\\frac{2.0 \\times 0.90 \\times 12}{10} = -2.16$。\n将这些值代入 $J_{\\mathrm{m}}$ 的表达式中：\n$$ J_{\\mathrm{m}} = 0.50 \\times \\exp(-1.62) \\times [1 - \\exp(-2.16)] $$\n$$ J_{\\mathrm{m}} \\approx 0.50 \\times 0.19791 \\times (1 - 0.11533) $$\n$$ J_{\\mathrm{m}} \\approx 0.50 \\times 0.19791 \\times 0.88467 \\approx 0.08754 \\, \\mathrm{s}^{-1} $$\n\n将两个结果四舍五入到三位有效数字，我们得到：\n$J_{\\mathrm{u}} \\approx 0.359$ $\\mathrm{s}^{-1}$\n$J_{\\mathrm{m}} \\approx 0.0875$ $\\mathrm{s}^{-1}$", "answer": "$$ \\boxed{ \\begin{pmatrix} 0.359 & 0.0875 \\end{pmatrix} } $$", "id": "3325094"}, {"introduction": "在掌握了单个过程的建模后，我们将视野提升到系统层面，探讨细胞如何在基本约束下进行资源分配。此练习聚焦于翻译过程中一个经典的权衡：速度与准确性。我们将密码子和tRNA的使用形式化为一个资源分配问题，并利用拉格朗日乘子法等优化技术来求解，以理解细胞可能如何在这种根本性的权衡中找到最优策略[@problem_id:3325056]。通过这个练习，你将学会如何运用优化理论来揭示驱动基因序列演化和翻译效率的系统级设计原则。", "problem": "您的任务是，在转运核糖核酸（tRNA）供应受限的翻译过程中，为密码子重编码建立资源分配模型并求解。从以下基于分子生物学中心法则和基本酶动力学的基础出发：在延伸阶段，核糖体在某个密码子上的停留时间随着同源tRNA可用性的增加而减少，并且随着同源tRNA与近同源tRNA竞争胜出，氨基酸的错掺概率降低。考虑一个单一的蛋白质编码转录本，其由索引为 $i \\in \\{1,\\dots,N\\}$ 的同义密码子类别组成，其中对于一个给定的实例，$N$ 是固定的。设 $p_i$ 是该转录本上密码子类别 $i$ 的使用分数，满足 $\\sum_{i=1}^N p_i = 1$ 且 $p_i \\ge 0$。设 $u_i \\ge 0$ 表示决策变量，代表从有限池中分配给密码子类别 $i$ 的同源tRNA的供应量（丰度）。\n\n使用停留时间近似法对平均延伸速度 $v$ （单位：密码子/秒）进行建模，在该近似中，每个密码子类别 $i$ 贡献的平均停留时间 $\\tau_i$ 与一个有效动力学因子 $k_i$ 和分配的同源tRNA $u_i$ 的乘积成反比，即 $\\tau_i = 1/(k_i u_i)$。有效动力学因子 $k_i$ 捕捉了核糖体-tRNA的相遇和化学反应过程，并被视为正常数。因此，总平均速度为\n$$\nv = \\left(\\sum_{i=1}^N p_i \\tau_i \\right)^{-1} = \\left(\\sum_{i=1}^N \\frac{p_i}{k_i u_i}\\right)^{-1}.\n$$\n将每个密码子的全局氨基酸错掺错误率建模为各密码子类别错误率的使用加权和，这些错误率随着同源tRNA分配的增加而降低，采用比例形式 $\\epsilon_i = b_i / u_i$，其中正常数 $b_i$ 捕捉了近同源竞争压力和校对效能。全局错误率为\n$$\n\\epsilon = \\sum_{i=1}^N p_i \\epsilon_i = \\sum_{i=1}^N \\frac{p_i b_i}{u_i}.\n$$\ntRNA池的约束是一个线性预算\n$$\n\\sum_{i=1}^N u_i \\le T_{\\text{tot}}, \\quad u_i \\ge 0,\n$$\n其中 $T_{\\text{tot}}$ 是所有密码子类别可分配的同源tRNA总供应量。\n\n为了近似速度与误差的帕累托前沿，考虑使用加权和标量化方法并求解\n$$\n\\min_{u_1,\\dots,u_N} J(u) = \\frac{w_1}{v} + w_2 \\epsilon\n$$\n同时满足上述tRNA预算约束，其中 $w_1 \\ge 0$ 和 $w_2 \\ge 0$ 是给定的权重，且 $w_1$ 或 $w_2$ 中至少有一个严格为正。请注意，根据 $v$ 的定义，$1/v = \\sum_{i=1}^N p_i/(k_i u_i)$。在所有情况下，假设所有参数都严格为正，除了某些可能为零的 $p_i$。\n\n您的任务是编写一个程序，对于下面指定的每个测试用例，计算在约束条件下最小化 $J(u)$ 的最优tRNA分配向量 $u^\\star = (u_1^\\star,\\dots,u_N^\\star)$，然后报告得到的目标值 $J^\\star$、速度 $v^\\star$（单位：密码子/秒）和错误率 $\\epsilon^\\star$（无单位小数）。所有标量输出必须四舍五入到六位小数。最优分配向量的条目也必须四舍五入到六位小数。最终单位为：$v$ 的单位是密码子/秒，$\\epsilon$ 是无单位小数，$J$ 的单位根据定义与加权和相同；不要打印单位，只打印数字。\n\n测试套件。对于每个测试用例，您将获得 $N$、数组 $\\{p_i\\}_{i=1}^N$、$\\{k_i\\}_{i=1}^N$、$\\{b_i\\}_{i=1}^N$、tRNA总预算 $T_{\\text{tot}}$ 和权重 $(w_1,w_2)$：\n\n- 测试用例 1（混合权衡）：\n  - $N = 3$,\n  - $p = [\\,0.5,\\,0.3,\\,0.2\\,]$,\n  - $k = [\\,8.0,\\,6.0,\\,4.0\\,]$,\n  - $b = [\\,0.02,\\,0.03,\\,0.015\\,]$,\n  - $T_{\\text{tot}} = 3.0$,\n  - $(w_1,w_2) = (1.0,\\,1.0)$.\n- 测试用例 2（速度优先边界）：\n  - $N = 3$,\n  - $p = [\\,0.5,\\,0.3,\\,0.2\\,]$,\n  - $k = [\\,8.0,\\,6.0,\\,4.0\\,]$,\n  - $b = [\\,0.02,\\,0.03,\\,0.015\\,]$,\n  - $T_{\\text{tot}} = 3.0$,\n  - $(w_1,w_2) = (1.0,\\,0.0)$.\n- 测试用例 3（错误率优先边界）：\n  - $N = 3$,\n  - $p = [\\,0.5,\\,0.3,\\,0.2\\,]$,\n  - $k = [\\,8.0,\\,6.0,\\,4.0\\,]$,\n  - $b = [\\,0.02,\\,0.03,\\,0.015\\,]$,\n  - $T_{\\text{tot}} = 3.0$,\n  - $(w_1,w_2) = (0.0,\\,1.0)$.\n- 测试用例 4（对称性检查）：\n  - $N = 3$,\n  - $p = [\\,1/3,\\,1/3,\\,1/3\\,]$,\n  - $k = [\\,7.0,\\,7.0,\\,7.0\\,]$,\n  - $b = [\\,0.02,\\,0.02,\\,0.02\\,]$,\n  - $T_{\\text{tot}} = 1.5$,\n  - $(w_1,w_2) = (2.0,\\,1.0)$.\n- 测试用例 5（倾斜的使用率和动力学）：\n  - $N = 3$,\n  - $p = [\\,0.9,\\,0.08,\\,0.02\\,]$,\n  - $k = [\\,10.0,\\,5.0,\\,2.0\\,]$,\n  - $b = [\\,0.01,\\,0.05,\\,0.1\\,]$,\n  - $T_{\\text{tot}} = 2.0$,\n  - $(w_1,w_2) = (1.0,\\,3.0)$.\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出一个列表\n$$\n[\\,J^\\star,\\, v^\\star,\\, \\epsilon^\\star,\\, [\\,u_1^\\star,\\,u_2^\\star,\\,\\dots,\\,u_N^\\star\\,]\\,],\n$$\n所有标量和向量条目都四舍五入到六位小数，并按给定顺序列出测试用例。例如，总输出应如下所示\n$$\n[[\\,\\cdot,\\,\\cdot,\\,\\cdot,\\,[\\,\\cdot,\\,\\cdot,\\,\\cdot\\,]\\,], \\dots]\n$$\n在单行上，无附加文本。", "solution": "用户提出了一个源于蛋白质翻译中资源分配模型的约束优化问题。任务是找到转运核糖核酸（tRNA）资源的最优分配，以在总tRNA预算的约束下，最小化翻译速度倒数和错误率的加权和。\n\n首先，对问题进行验证。该模型虽然是一个简化，但其基础是分子生物学和酶动力学的既定原理。目标函数和约束构成了一个适定的凸优化问题，保证了唯一的全局最小值。所有参数都已提供，并且在数学和物理上是一致的。该问题是形式化的、客观的、可验证的。因此，该问题被认为是有效的，有必要给出完整解答。\n\n问题的核心是最小化目标函数 $J(u)$：\n$$\nJ(u) = \\frac{w_1}{v} + w_2 \\epsilon\n$$\n通过代入所提供的平均延伸速度 $v$ 和全局错误率 $\\epsilon$ 的表达式，我们可以将 $J(u)$ 完全用tRNA分配 $u = (u_1, \\dots, u_N)$ 来表示：\n$$\nJ(u) = w_1 \\left(\\sum_{i=1}^N \\frac{p_i}{k_i u_i}\\right) + w_2 \\left(\\sum_{i=1}^N \\frac{p_i b_i}{u_i}\\right)\n$$\n这可以重排成一个更紧凑的形式：\n$$\nJ(u) = \\sum_{i=1}^N \\frac{p_i}{u_i} \\left(\\frac{w_1}{k_i} + w_2 b_i\\right)\n$$\n让我们为每个密码子类别 $i$ 定义一个复合系数 $C_i$：\n$$\nC_i = p_i \\left(\\frac{w_1}{k_i} + w_2 b_i\\right)\n$$\n那么目标函数就简化为：\n$$\nJ(u) = \\sum_{i=1}^N \\frac{C_i}{u_i}\n$$\n该优化问题是在以下约束条件下最小化 $J(u)$：\n$$\n\\sum_{i=1}^N u_i \\le T_{\\text{tot}} \\quad \\text{且} \\quad u_i \\ge 0 \\text{ for } i=1, \\dots, N\n$$\n目标函数 $J(u)$ 是各项 $C_i/u_i$ 的和。由于所有参数 $p_i, k_i, b_i, w_1, w_2$ 都是非负的，且 $k_i > 0, b_i > 0$，所以系数 $C_i$ 是非负的（$C_i \\ge 0$）。对于任何使用率不为零（$p_i > 0$）且至少有一个权重不为零（$w_1+w_2 > 0$）的密码子类别，我们有 $C_i > 0$。函数 $C_i/u_i$ 是 $u_i$ 的递减函数。为了最小化总和，分配量 $u_i$ 应尽可能大。这意味着在最优点，预算约束必须是激活的，即总分配量将等于总预算：\n$$\n\\sum_{i=1}^N u_i = T_{\\text{tot}}\n$$\n这是一个经典的资源分配问题，可以使用拉格朗日乘数法求解。拉格朗日函数 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}(u_1, \\dots, u_N, \\lambda) = \\sum_{i=1}^N \\frac{C_i}{u_i} + \\lambda \\left(\\sum_{i=1}^N u_i - T_{\\text{tot}}\\right)\n$$\n其中 $\\lambda$ 是拉格朗日乘数。为求最小值，我们将关于每个 $u_j$ 的偏导数设为零：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial u_j} = -\\frac{C_j}{u_j^2} + \\lambda = 0\n$$\n这得出 $u_j^2 = C_j / \\lambda$，并且由于 $u_j$ 必须为正（对于任何 $C_j > 0$ 的 $j$），我们有：\n$$\nu_j = \\sqrt{\\frac{C_j}{\\lambda}} = \\frac{\\sqrt{C_j}}{\\sqrt{\\lambda}}\n$$\n这表明最优分配 $u_j^\\star$ 与其对应的成本系数 $C_j$ 的平方根成正比。我们通过将 $u_j$ 的这个表达式代回激活的预算约束中来确定乘数 $\\lambda$ 的值：\n$$\n\\sum_{j=1}^N u_j = \\sum_{j=1}^N \\frac{\\sqrt{C_j}}{\\sqrt{\\lambda}} = \\frac{1}{\\sqrt{\\lambda}} \\sum_{j=1}^N \\sqrt{C_j} = T_{\\text{tot}}\n$$\n求解 $1/\\sqrt{\\lambda}$：\n$$\n\\frac{1}{\\sqrt{\\lambda}} = \\frac{T_{\\text{tot}}}{\\sum_{i=1}^N \\sqrt{C_i}}\n$$\n最后，我们将此结果代回到 $u_j$ 的表达式中，以找到最优分配 $u_j^\\star$：\n$$\nu_j^\\star = \\sqrt{C_j} \\left( \\frac{T_{\\text{tot}}}{\\sum_{i=1}^N \\sqrt{C_i}} \\right)\n$$\n我们定义 $S = \\sum_{i=1}^N \\sqrt{C_i}$。那么最优分配为 $u_j^\\star = T_{\\text{tot}} \\frac{\\sqrt{C_j}}{S}$。\n请注意，如果 $p_j = 0$，则 $C_j = 0$，因此 $u_j^\\star = 0$，这在生物学上是合理的：不为从不使用的密码子分配资源。\n\n利用最优分配向量 $u^\\star = (u_1^\\star, \\dots, u_N^\\star)$，我们可以计算最优目标值 $J^\\star$、速度 $v^\\star$ 和错误率 $\\epsilon^\\star$。最优目标值 $J^\\star$ 可以高效地计算如下：\n$$\nJ^\\star = \\sum_{i=1}^N \\frac{C_i}{u_i^\\star} = \\sum_{i=1}^N \\frac{C_i}{T_{\\text{tot}} \\frac{\\sqrt{C_i}}{S}} = \\frac{S}{T_{\\text{tot}}} \\sum_{i=1}^N \\sqrt{C_i} = \\frac{S^2}{T_{\\text{tot}}}\n$$\n最优速度 $v^\\star$ 和错误率 $\\epsilon^\\star$ 可以通过将 $u^\\star$ 代入其定义中得到：\n$$\nv^\\star = \\left(\\sum_{i=1}^N \\frac{p_i}{k_i u_i^\\star}\\right)^{-1} \\quad \\text{和} \\quad \\epsilon^\\star = \\sum_{i=1}^N \\frac{p_i b_i}{u_i^\\star}\n$$\n当 $p_i=0$ 时，相应的 $u_i^\\star=0$，导致不定式 $0/0$。在这种情况下，对总和的正确贡献为 $0$。\n\n对于每个测试用例，将实施以下算法：\n1.  给定参数 $\\{p_i\\}$、$\\{k_i\\}$、$\\{b_i\\}$、$T_{\\text{tot}}$、$w_1$ 和 $w_2$，计算系数 $C_i = p_i (w_1/k_i + w_2 b_i)$ for all $i=1,\\dots,N$。\n2.  计算 $S = \\sum_{i=1}^N \\sqrt{C_i}$。\n3.  计算最优分配向量 $u^\\star$，其元素为 $u_i^\\star = T_{\\text{tot}} (\\sqrt{C_i} / S)$。\n4.  计算最优目标值 $J^\\star = S^2 / T_{\\text{tot}}$。\n5.  使用它们的定义求和来计算最优速度 $v^\\star$ 和错误率 $\\epsilon^\\star$，确保 $p_i=0$ 的项贡献为 $0$。\n6.  按规定将所有结果格式化为六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the tRNA allocation optimization problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (mixed trade-off)\n        {'N': 3, 'p': [0.5, 0.3, 0.2], 'k': [8.0, 6.0, 4.0], 'b': [0.02, 0.03, 0.015], 'T_tot': 3.0, 'w': (1.0, 1.0)},\n        # Test case 2 (speed-prioritizing boundary)\n        {'N': 3, 'p': [0.5, 0.3, 0.2], 'k': [8.0, 6.0, 4.0], 'b': [0.02, 0.03, 0.015], 'T_tot': 3.0, 'w': (1.0, 0.0)},\n        # Test case 3 (error-prioritizing boundary)\n        {'N': 3, 'p': [0.5, 0.3, 0.2], 'k': [8.0, 6.0, 4.0], 'b': [0.02, 0.03, 0.015], 'T_tot': 3.0, 'w': (0.0, 1.0)},\n        # Test case 4 (symmetry check)\n        {'N': 3, 'p': [1/3, 1/3, 1/3], 'k': [7.0, 7.0, 7.0], 'b': [0.02, 0.02, 0.02], 'T_tot': 1.5, 'w': (2.0, 1.0)},\n        # Test case 5 (skewed usage and kinetics)\n        {'N': 3, 'p': [0.9, 0.08, 0.02], 'k': [10.0, 5.0, 2.0], 'b': [0.01, 0.05, 0.1], 'T_tot': 2.0, 'w': (1.0, 3.0)},\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        # Unpack parameters and convert to NumPy arrays for vectorized operations\n        p = np.array(case['p'])\n        k = np.array(case['k'])\n        b = np.array(case['b'])\n        T_tot = case['T_tot']\n        w1, w2 = case['w']\n\n        # Step 1: Calculate cost coefficients C_i = p_i * (w1/k_i + w2*b_i)\n        C = p * (w1 / k + w2 * b)\n        \n        # Step 2: Calculate S = sum(sqrt(C_i))\n        sqrt_C = np.sqrt(C)\n        S = np.sum(sqrt_C)\n\n        # Step 3: Calculate optimal tRNA allocation u_star\n        # The problem constraints ensure S > 0, so no division by zero here.\n        u_star = (sqrt_C / S) * T_tot\n            \n        # Step 4: Calculate performance metrics J_star, v_star, eps_star\n        # J_star is calculated directly from S for better numerical stability.\n        J_star = (S**2) / T_tot\n\n        # For v_star and eps_star, we must handle potential 0/0 divisions\n        # which occur when p_i=0 (and thus u_star_i=0). The contribution is 0.\n        # np.divide with 'where' and 'out' arguments handles this robustly.\n        inv_v_terms = np.divide(p, k * u_star, out=np.zeros_like(p, dtype=float), where=u_star>0)\n        inv_v_star = np.sum(inv_v_terms)\n        v_star = 1.0 / inv_v_star\n\n        eps_terms = np.divide(p * b, u_star, out=np.zeros_like(p, dtype=float), where=u_star>0)\n        eps_star = np.sum(eps_terms)\n        \n        # Step 5: Format the results into the specified string format.\n        # All scalar values and vector elements are rounded to six decimal places.\n        # The output string must not contain spaces.\n        u_list_str = f\"[{','.join(f'{x:.6f}' for x in u_star)}]\"\n        case_str = f\"[{J_star:.6f},{v_star:.6f},{eps_star:.6f},{u_list_str}]\"\n        results_as_strings.append(case_str)\n\n    # Final print statement in the exact required single-line format.\n    print(f\"[[{','.join(results_as_strings)}]]\")\n\nsolve()\n```", "id": "3325056"}, {"introduction": "理论模型的力量最终取决于其参数的准确性，而这些参数必须通过实验来确定。这个练习将我们带到理论与实践的交汇点，探讨如何为参数估计设计最优的实验方案。我们将聚焦于核糖体分析测序（Ribo-seq）技术，并引入费雪信息矩阵（Fisher Information Matrix, FIM）这一强大的统计工具来量化和最小化参数的不确定性[@problem_id:3325109]。这项实践旨在弥合理论建模与真实世界实验之间的鸿沟，让你掌握评估和规划定量生物学实验的关键技能。", "problem": "您需要设计并实现一个完整的、可运行的程序。对于一组在核糖体分析测序（Ribo-seq）中计划的实验设计，该程序会计算翻译起始和延伸速率估计值的预期置信区间，并选择能最小化参数不确定性的设计。此任务必须以纯数学术语进行表述，基于中心法则和核糖体动力学的第一性原理，并且必须以精确格式单行输出结果。\n\n基本依据包括以下被广泛接受的原则和建模假设：\n\n- 中心法则指出，遗传信息从脱氧核糖核酸（DNA）流向核糖核酸（RNA），再到蛋白质。核糖体的翻译过程通过在起始密码子处起始，并沿着密码子延伸直至终止。\n- 在核糖体碰撞可忽略不计的低密度状态下，沿开放阅读框的稳态核糖体足迹密度与起始通量和在每个位置的停留时间的乘积成正比。设起始速率为 $\\alpha$（单位 $\\mathrm{s}^{-1}$），均一延伸速度为 $e$（单位 codons/s）。定义 $\\varphi = 1/e$（单位 $\\mathrm{s}$/codon）为每密码子停留时间缩放参数。\n- 设 $m$ 表示用于分析的编码序列上的足迹位置数量，设 $s$ 表示由起始特异性分析测定法（例如，定量翻译起始测序）使用的起始区域位置数量。设 $\\mathbf{w} \\in \\mathbb{R}^m$ 为一个已知的 Ribo-seq 位置的密码子特异性停留权重向量，$\\mathbf{h} \\in \\mathbb{R}^s$ 为一个已知的起始特异性足迹的起始区域权重向量。\n\n测量模型：\n\n- 位置 $i \\in \\{1,\\dots,m\\}$ 的预期 Ribo-seq 足迹密度建模为 $f_i(\\alpha,\\varphi) = \\alpha\\,\\varphi\\,w_i$。\n- 起始区域位置 $j \\in \\{1,\\dots,s\\}$ 的预期起始特异性足迹密度为 $g_j(\\alpha,\\varphi) = \\alpha\\,h_j$，与 $\\varphi$ 无关。\n\n噪声与重复实验：\n\n- 每个观测值都受到独立的、零均值的高斯噪声的影响。Ribo-seq 测量的每个位置方差为 $\\sigma_R^2$，起始特异性测量的每个位置方差为 $\\sigma_Q^2$。\n- 对于 $n_R$ 次独立的 Ribo-seq 重复实验和 $n_Q$ 次独立的起始特异性重复实验，每个位置的有效方差分别变为 $\\sigma_R^2/n_R$ 和 $\\sigma_Q^2/n_Q$。\n\n参数推断与不确定性：\n\n- 考虑参数向量 $\\boldsymbol{\\theta} = [\\alpha,\\varphi]^\\top$。在高斯噪声模型以及 $\\mathbf{f}$ 和 $\\mathbf{g}$ 的平滑性假设下，加权最小二乘估计量 $\\hat{\\boldsymbol{\\theta}}$ 是渐近正态的，其协方差可通过基于均值模型的雅可比矩阵和噪声协方差逆矩阵的费雪信息矩阵（FIM）的逆矩阵来近似。使用关于 $\\boldsymbol{\\theta}$ 的堆叠均值向量的雅可比矩阵 $\\mathbf{J}(\\alpha,\\varphi)$ 和包含有效方差倒数的对角权重矩阵 $\\mathbf{W}$。\n- 设 $\\mathrm{Cov}(\\hat{\\boldsymbol{\\theta}})$ 表示 $\\hat{\\boldsymbol{\\theta}}$ 的渐近协方差。$\\alpha$ 和 $e$ 的 $0.95$ 置信区间是使用正态近似和临界值 $z_{0.975}$ 构建的，其中 $z_{0.975} \\approx 1.959964$。由于 $e = 1/\\varphi$，应用 delta 方法将不确定性从 $\\varphi$ 转换到 $e$。\n\n设计选择目标：\n\n- 在由 $(n_R, n_Q)$ 对指定的有限候选设计集中，选择能最小化最差情况边际不确定性的设计。该不确定性定义为在标称真实参数下计算的 $\\alpha$（单位 $\\mathrm{s}^{-1}$）和 $e$（单位 codons/s）的两个置信区间半宽的最大值。若出现平局，必须通过选择候选设计在所提供列表中的最小索引来决定。\n\n实现要求：\n\n- 对每个测试案例，按如下方式从 $m$ 和 $s$ 确定性地构建 $\\mathbf{w}$ 和 $\\mathbf{h}$：\n  - 对于 $i \\in \\{1,\\dots,m\\}$，定义 $w_i = 1 + 0.4\\,\\sin\\!\\left(\\frac{2\\pi i}{30}\\right) + 0.3\\,\\frac{i}{m}$。这会生成一个科学上合理、平滑变化且具有中等异质性的密码子停留景观。\n  - 对于 $j \\in \\{1,\\dots,s\\}$，定义 $h_j = \\exp\\!\\left(-\\frac{j-1}{3}\\right)$。这模拟了一个在起始区域上衰减的、与起始相关的信号。\n- 对每个候选设计 $(n_R, n_Q)$，使用上述框架计算 $\\alpha$ 和 $e$ 的预期 $0.95$ 置信区间半宽，并选择最小化最大半宽的设计。以 $\\mathrm{s}^{-1}$ 为单位表示 $\\alpha$ 的半宽，以 codons/s 为单位表示 $e$ 的半宽。对于数值报告，将每个半宽四舍五入到 $6$ 位小数。\n\n测试套件：\n\n- 案例 $1$：$m=50$，$s=8$，$\\alpha=0.05$ $\\mathrm{s}^{-1}$，$e=5.0$ codons/s，$\\sigma_R^2=0.02$，$\\sigma_Q^2=0.05$。候选设计：$(n_R,n_Q) \\in \\{(2,2),(3,2),(2,3)\\}$ 按此顺序列出。\n- 案例 $2$：$m=50$，$s=8$，$\\alpha=0.07$ $\\mathrm{s}^{-1}$，$e=4.5$ codons/s，$\\sigma_R^2=0.08$，$\\sigma_Q^2=0.12$。候选设计：$(n_R,n_Q) \\in \\{(2,1),(4,2),(3,3)\\}$ 按此顺序列出。\n- 案例 $3$：$m=100$，$s=10$，$\\alpha=0.03$ $\\mathrm{s}^{-1}$，$e=7.0$ codons/s，$\\sigma_R^2=0.005$，$\\sigma_Q^2=0.01$。候选设计：$(n_R,n_Q) \\in \\{(3,3),(5,1),(2,4)\\}$ 按此顺序列出。\n- 案例 $4$：$m=300$，$s=12$，$\\alpha=0.02$ $\\mathrm{s}^{-1}$，$e=6.5$ codons/s，$\\sigma_R^2=0.02$，$\\sigma_Q^2=0.04$。候选设计：$(n_R,n_Q) \\in \\{(4,4),(6,2),(3,5)\\}$ 按此顺序列出。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。对每个测试案例，输出一个形式为 $[\\text{design_index}, \\text{ci_alpha}, \\text{ci_e}]$ 的子列表，其中 $\\text{design_index}$ 是候选设计列表中的索引（从1开始），$\\text{ci_alpha}$ 是 $\\alpha$ 的 $0.95$ 置信区间半宽（单位 $\\mathrm{s}^{-1}$，四舍五入到 $6$ 位小数），$\\text{ci_e}$ 是 $e$ 的 $0.95$ 置信区间半宽（单位 codons/s，四舍五入到 $6$ 位小数）。因此，最终行必须如下所示：$[[d_1,c_{\\alpha,1},c_{e,1}],[d_2,c_{\\alpha,2},c_{e,2}],\\dots]$。", "solution": "该问题已经过仔细验证，并被确定为**有效**。它在科学上基于分子生物学和统计推断的既定原则，提法恰当、目标明确，并为得到唯一解提供了所有必要信息。\n\n我们现在开始进行形式化解法。目标是选择一个由重复实验次数对 $(n_R, n_Q)$ 定义的实验设计，以最小化翻译起始速率 $\\alpha$ 和延伸速度 $e$ 估计值的最大预期不确定性。不确定性由 $0.95$ 置信区间的半宽来量化。此分析依赖于费雪信息矩阵 (FIM) 来近似参数估计量的协方差。\n\n**1. 模型规范**\n\n待估计的参数向量是 $\\boldsymbol{\\theta} = [\\alpha, \\varphi]^\\top$，其中 $\\alpha$ 是起始速率，单位为 $\\mathrm{s}^{-1}$，$\\varphi = 1/e$ 是每密码子停留时间缩放参数，单位为 $\\mathrm{s}/\\mathrm{codon}$。延伸速度 $e$ 的单位是 $\\mathrm{codons}/\\mathrm{s}$。\n\n实验包含两种类型的测量：\n- Ribo-seq，有 $m$ 个足迹位置。位置 $i$ 的预期足迹密度为 $f_i(\\alpha, \\varphi) = \\alpha \\varphi w_i$。\n- 起始特异性分析，有 $s$ 个起始区域位置。位置 $j$ 的预期密度为 $g_j(\\alpha, \\varphi) = \\alpha h_j$。\n\n权重向量 $\\mathbf{w} \\in \\mathbb{R}^m$ 和 $\\mathbf{h} \\in \\mathbb{R}^s$ 由提供的公式确定：\n- $w_i = 1 + 0.4\\sin(\\frac{2\\pi i}{30}) + 0.3\\frac{i}{m}$ 对于 $i \\in \\{1, \\dots, m\\}$。\n- $h_j = \\exp(-\\frac{j-1}{3})$ 对于 $j \\in \\{1, \\dots, s\\}$。\n\n测量值受到独立高斯噪声的影响。对于 $n_R$ 次 Ribo-seq 重复实验和 $n_Q$ 次起始特异性重复实验，有效方差分别为 $\\sigma_{R,eff}^2 = \\sigma_R^2/n_R$ 和 $\\sigma_{Q,eff}^2 = \\sigma_Q^2/n_Q$。\n\n**2. 费雪信息矩阵 (FIM)**\n\nFIM，记作 $\\mathbf{F}$，量化了数据为参数提供的信息量。对于一个带有高斯噪声模型的加权最小二乘问题，FIM 由 $\\mathbf{F} = \\mathbf{J}^\\top \\mathbf{W} \\mathbf{J}$ 给出，其中 $\\mathbf{J}$ 是均值模型的雅可比矩阵，$\\mathbf{W}$ 是测量方差倒数矩阵。\n\n均值模型是所有预期测量的向量，$\\boldsymbol{\\mu}(\\boldsymbol{\\theta}) = [f_1, \\dots, f_m, g_1, \\dots, g_s]^\\top$。雅可比矩阵 $\\mathbf{J}$ 是 $\\boldsymbol{\\mu}$ 关于 $\\boldsymbol{\\theta} = [\\alpha, \\varphi]^\\top$ 的偏导数的 $(m+s) \\times 2$ 矩阵：\n$$\n\\mathbf{J} = \\frac{\\partial \\boldsymbol{\\mu}}{\\partial \\boldsymbol{\\theta}^\\top} =\n\\begin{pmatrix}\n\\frac{\\partial f_1}{\\partial \\alpha} & \\frac{\\partial f_1}{\\partial \\varphi} \\\\\n\\vdots & \\vdots \\\\\n\\frac{\\partial f_m}{\\partial \\alpha} & \\frac{\\partial f_m}{\\partial \\varphi} \\\\\n\\frac{\\partial g_1}{\\partial \\alpha} & \\frac{\\partial g_1}{\\partial \\varphi} \\\\\n\\vdots & \\vdots \\\\\n\\frac{\\partial g_s}{\\partial \\alpha} & \\frac{\\partial g_s}{\\partial \\varphi}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\varphi w_1 & \\alpha w_1 \\\\\n\\vdots & \\vdots \\\\\n\\varphi w_m & \\alpha w_m \\\\\nh_1 & 0 \\\\\n\\vdots & \\vdots \\\\\nh_s & 0\n\\end{pmatrix}\n$$\n权重矩阵 $\\mathbf{W}$ 是一个 $(m+s) \\times (m+s)$ 的对角矩阵，其对角线元素为有效方差的倒数：\n$$\n\\mathbf{W} = \\mathrm{diag}\\left(\\underbrace{\\frac{n_R}{\\sigma_R^2}, \\dots, \\frac{n_R}{\\sigma_R^2}}_{m \\text{ 次}}, \\underbrace{\\frac{n_Q}{\\sigma_Q^2}, \\dots, \\frac{n_Q}{\\sigma_Q^2}}_{s \\text{ 次}}\\right)\n$$\n$2 \\times 2$ FIM $\\mathbf{F} = \\mathbf{J}^\\top \\mathbf{W} \\mathbf{J}$ 的分量计算如下：\n$$F_{11} = \\sum_{i=1}^m \\frac{n_R}{\\sigma_R^2} (\\varphi w_i)^2 + \\sum_{j=1}^s \\frac{n_Q}{\\sigma_Q^2} (h_j)^2 = \\frac{n_R \\varphi^2}{\\sigma_R^2} S_{w2} + \\frac{n_Q}{\\sigma_Q^2} S_{h2}$$\n$$F_{12} = F_{21} = \\sum_{i=1}^m \\frac{n_R}{\\sigma_R^2} (\\varphi w_i)(\\alpha w_i) = \\frac{n_R \\alpha \\varphi}{\\sigma_R^2} S_{w2}$$\n$$F_{22} = \\sum_{i=1}^m \\frac{n_R}{\\sigma_R^2} (\\alpha w_i)^2 = \\frac{n_R \\alpha^2}{\\sigma_R^2} S_{w2}$$\n其中 $S_{w2} = \\sum_{i=1}^m w_i^2$ 且 $S_{h2} = \\sum_{j=1}^s h_j^2$。求和 $S_{h2} = \\sum_{j=1}^s (\\exp(-\\frac{j-1}{3}))^2 = \\sum_{k=0}^{s-1} (\\exp(-2/3))^k$ 是一个等比级数，其闭式解为 $S_{h2} = \\frac{1 - \\exp(-2s/3)}{1 - \\exp(-2/3)}$。\n\n**3. 参数协方差与置信区间**\n\n估计量 $\\hat{\\boldsymbol{\\theta}}$ 的渐近协方差矩阵可通过 FIM 的逆矩阵来近似：$\\mathrm{Cov}(\\hat{\\boldsymbol{\\theta}}) \\approx \\mathbf{F}^{-1}$。\n$\\mathbf{F}$ 的行列式为：\n$$\\det(\\mathbf{F}) = F_{11}F_{22} - F_{12}^2 = \\frac{n_R n_Q \\alpha^2 S_{w2} S_{h2}}{\\sigma_R^2 \\sigma_Q^2}$$\n\n估计量 $\\hat{\\alpha}$ 和 $\\hat{\\varphi}$ 的方差是 $\\mathbf{F}^{-1}$ 的对角元素：\n$$\\mathrm{Var}(\\hat{\\alpha}) = (\\mathbf{F}^{-1})_{11} = \\frac{F_{22}}{\\det(\\mathbf{F})} = \\frac{\\sigma_Q^2}{n_Q S_{h2}}$$\n$$\\mathrm{Var}(\\hat{\\varphi}) = (\\mathbf{F}^{-1})_{22} = \\frac{F_{11}}{\\det(\\mathbf{F})} = \\frac{\\varphi^2 \\sigma_Q^2}{n_Q \\alpha^2 S_{h2}} + \\frac{\\sigma_R^2}{n_R \\alpha^2 S_{w2}}$$\n\n$\\alpha$ 的 $0.95$ 置信区间半宽由下式给出：\n$$\\mathrm{CI}_{\\alpha} = z_{0.975} \\sqrt{\\mathrm{Var}(\\hat{\\alpha})} = z_{0.975} \\frac{\\sigma_Q}{\\sqrt{n_Q S_{h2}}}$$\n其中 $z_{0.975} \\approx 1.959964$ 是标准正态分布的临界值。\n\n为求出延伸速度 $e = 1/\\varphi$ 的置信区间，我们应用 Delta 方法。$\\hat{e}$ 的方差近似为：\n$$\\mathrm{Var}(\\hat{e}) \\approx \\left(\\frac{de}{d\\varphi}\\right)^2 \\mathrm{Var}(\\hat{\\varphi}) = \\left(-\\frac{1}{\\varphi^2}\\right)^2 \\mathrm{Var}(\\hat{\\varphi}) = \\frac{1}{\\varphi^4} \\mathrm{Var}(\\hat{\\varphi})$$\n代入 $\\varphi = 1/e$ 和 $\\mathrm{Var}(\\hat{\\varphi})$ 的表达式：\n$\\mathrm{Var}(\\hat{e}) \\approx e^4 \\left( \\frac{(1/e)^2 \\sigma_Q^2}{n_Q \\alpha^2 S_{h2}} + \\frac{\\sigma_R^2}{n_R \\alpha^2 S_{w2}} \\right) = \\frac{e^2 \\sigma_Q^2}{n_Q \\alpha^2 S_{h2}} + \\frac{e^4 \\sigma_R^2}{n_R \\alpha^2 S_{w2}}$。\n$e$ 的置信区间半宽为：\n$$\\mathrm{CI}_{e} = z_{0.975} \\sqrt{\\mathrm{Var}(\\hat{e})} = z_{0.975} \\sqrt{\\frac{e^2 \\sigma_Q^2}{n_Q \\alpha^2 S_{h2}} + \\frac{e^4 \\sigma_R^2}{n_R \\alpha^2 S_{w2}}}$$\n\n**4. 设计选择**\n\n对于每个测试案例和每个候选设计 $(n_R, n_Q)$，我们计算半宽 $\\mathrm{CI}_{\\alpha}$ 和 $\\mathrm{CI}_{e}$。最优设计是最小化目标函数 $\\max(\\mathrm{CI}_{\\alpha}, \\mathrm{CI}_{e})$ 的设计。如果出现平局，则选择在所提供列表中索引最小的设计。最终报告的值是设计索引（从1开始）以及对应的 $\\alpha$ 和 $e$ 的置信区间半宽，四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the experimental design problem for all test cases.\n    \"\"\"\n    \n    # Critical value for 95% confidence interval\n    z_crit = 1.959964\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"params\": {\"m\": 50, \"s\": 8, \"alpha\": 0.05, \"e\": 5.0, \"sigma_R_sq\": 0.02, \"sigma_Q_sq\": 0.05},\n            \"designs\": [(2, 2), (3, 2), (2, 3)]\n        },\n        # Case 2\n        {\n            \"params\": {\"m\": 50, \"s\": 8, \"alpha\": 0.07, \"e\": 4.5, \"sigma_R_sq\": 0.08, \"sigma_Q_sq\": 0.12},\n            \"designs\": [(2, 1), (4, 2), (3, 3)]\n        },\n        # Case 3\n        {\n            \"params\": {\"m\": 100, \"s\": 10, \"alpha\": 0.03, \"e\": 7.0, \"sigma_R_sq\": 0.005, \"sigma_Q_sq\": 0.01},\n            \"designs\": [(3, 3), (5, 1), (2, 4)]\n        },\n        # Case 4\n        {\n            \"params\": {\"m\": 300, \"s\": 12, \"alpha\": 0.02, \"e\": 6.5, \"sigma_R_sq\": 0.02, \"sigma_Q_sq\": 0.04},\n            \"designs\": [(4, 4), (6, 2), (3, 5)]\n        }\n    ]\n\n    final_results = []\n    \n    for case_data in test_cases:\n        params = case_data[\"params\"]\n        designs = case_data[\"designs\"]\n        \n        m = params[\"m\"]\n        s = params[\"s\"]\n        alpha = params[\"alpha\"]\n        e = params[\"e\"]\n        sigma_R_sq = params[\"sigma_R_sq\"]\n        sigma_Q_sq = params[\"sigma_Q_sq\"]\n\n        # Calculate weight summary statistics S_w2 and S_h2\n        i_vals = np.arange(1, m + 1)\n        w = 1.0 + 0.4 * np.sin(2.0 * np.pi * i_vals / 30.0) + 0.3 * i_vals / m\n        S_w2 = np.sum(w**2)\n        \n        # Using the closed-form sum of a geometric series for S_h2\n        # S_h2 = sum_{k=0}^{s-1} (exp(-2/3))^k\n        r = np.exp(-2.0 / 3.0)\n        if r == 1:\n            S_h2 = s\n        else:\n            S_h2 = (1.0 - r**s) / (1.0 - r)\n\n        min_max_ci = float('inf')\n        best_design_info = None\n\n        for idx, (n_R, n_Q) in enumerate(designs):\n            # Calculate CI for alpha\n            var_alpha = sigma_Q_sq / (n_Q * S_h2)\n            ci_alpha = z_crit * np.sqrt(var_alpha)\n\n            # Calculate CI for e\n            term1 = (e**2 * sigma_Q_sq) / (n_Q * alpha**2 * S_h2)\n            term2 = (e**4 * sigma_R_sq) / (n_R * alpha**2 * S_w2)\n            var_e = term1 + term2\n            ci_e = z_crit * np.sqrt(var_e)\n            \n            # Objective: minimize the maximum of the two CIs\n            max_ci = max(ci_alpha, ci_e)\n            \n            if max_ci  min_max_ci:\n                min_max_ci = max_ci\n                best_design_info = {\n                    \"index\": idx + 1,\n                    \"ci_alpha\": ci_alpha,\n                    \"ci_e\": ci_e\n                }\n\n        # Format the result for the current test case\n        result_tuple = [\n            best_design_info[\"index\"],\n            round(best_design_info[\"ci_alpha\"], 6),\n            round(best_design_info[\"ci_e\"], 6)\n        ]\n        final_results.append(str(result_tuple).replace(\" \", \"\"))\n\n    # Final print statement in the exact required format.\n    print(f\"[[{','.join(final_results)}]]\")\n\nsolve()\n```", "id": "3325109"}]}