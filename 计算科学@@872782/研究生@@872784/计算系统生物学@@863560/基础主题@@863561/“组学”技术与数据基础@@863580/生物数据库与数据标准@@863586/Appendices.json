{"hands_on_practices": [{"introduction": "描述基因和外显子等特征位置和结构的基因组注释，通常以通用特征格式第 3 版 (GFF3) 存储。理解如何解析这种格式并重建特征之间的层级关系，对于转录组学和基因组分析至关重要。在此实践中，您将实现一个算法，根据 GFF3 记录构建转录本模型，并根据规范验证它们的父子关系 [@problem_id:3291684]。", "problem": "您将得到一份基于通用特征格式第3版（GFF3）数据标准的描述和约束，该标准在计算系统生物学中被广泛用于表示基因组特征及其关系。您的目标是从符合GFF3标准的特征记录中重建转录本的外显子链，并根据规范检测无效的Parent关系。\n\n基本依据：使用GFF3规范的权威规则。通用特征格式第3版（GFF3）是一种以制表符分隔的格式，每行特征有九个字段：序列标识符、来源、类型、起始、终止、得分、链、阶段和属性。属性字段包含键值对，例如标识符和关系。以下事实被用作基本规则：\n- 坐标是基于 $1$ 的且包含端点。一个特征具有起始坐标 $s$ 和终止坐标 $e$，其中 $s \\le e$。\n- 父子关系通过键为 $ID$ 和 $Parent$ 的属性来表示。子级通过 $Parent$ 标签列出其父级；多个父级由逗号分隔。\n- 类型为基因（gene）、信使RNA（mRNA）和外显子（exon）的特征必须符合以下亲子关系约束：一个mRNA的 $Parent$ 必须引用一个基因，一个外显子的 $Parent$ 必须引用一个mRNA。一个基因不应该有 $Parent$ 标签。\n- 转录本外显子链的顺序取决于链（strand）：在正链 $+$ 上，按基因组坐标升序排列；在负链 $-$ 上，按基因组坐标降序排列。起始位置相同时，应通过终止位置来决定顺序。\n\n任务：对于每个提供的GFF3片段，为每个mRNA重建外显子链，并检测是否存在任何无效的 $Parent$ 引用，其中“无效”指以下任一情况：\n- 一个 $Parent$ 标识符在已定义的特征 $ID$ 中不存在，或\n- 一个 $Parent$ 存在但类型错误（例如，一个外显子引用一个基因），或\n- 一个基因行根本就带有 $Parent$ 属性。\n\n算法要求：\n- 解析特征，并为mRNA构建一个从 $ID$ 到类型和链的映射。\n- 对于每个外显子，如果其父级存在且类型为mRNA，则将其与每个 $Parent$ mRNA关联起来。\n- 对于每个mRNA，对其关联的外显子进行排序以形成其外显子链。对于 $+$ 链，按 $(s,e)$ 升序排序；对于 $-$ 链，按 $(s,e)$ 降序排序，其中平局由 $e$ 决定。\n- 使用上述规则检测无效的 $Parent$ 引用。\n- 计算复杂度应从原理上进行论证，依赖于字典查找和排序。\n\n输入模型：您的程序必须将测试套件作为字符串内嵌；不允许外部输入。每个GFF3片段包含有效的、以制表符分隔的记录，使用九个字段以及包含 $ID$ 和 $Parent$ 标签的属性。\n\n测试套件：\n- 案例1（正链，单个转录本，有序外显子）：基因 $g1$，mRNA $t1$ ($Parent=g1$)，外显子位于坐标 $[100,200]$ 和 $[300,400]$，两者都有 $Parent=t1$ 和链 $+$。\n- 案例2（负链，单个转录本，乱序外显子）：基因 $g2$，mRNA $t2$ ($Parent=g2$)，外显子位于 $[450,480]$ 和 $[500,600]$，两者都有 $Parent=t2$ 和链 $-$；输出的外显子链必须按起始位置降序排列，产生外显子起始位置 $500$ 在 $450$ 之前。\n- 案例3（无效的父级引用）：基因 $g3$，mRNA $t3$ ($Parent=g3$)；外显子位于 $[200,250]$ 处，其 $Parent=t3$；另一外显子位于 $[260,300]$ 处，其 $Parent=mr\\_unknown$（不存在）。无效 $Parent$ 的检测必须为真；$t3$ 的外显子链必须只包含其有效的外显子。\n- 案例4（多个父级中有一个无效）：基因 $g4$，mRNA $t4$ ($Parent=g4$)；一个外显子位于 $[150,180]$，其 $Parent=t4,t4b$（其中 $t4b$ 缺失），另一个外显子位于 $[800,900]$，其 $Parent=t4$。无效 $Parent$ 的检测必须为真；$t4$ 的链必须在 $+$ 链上按升序包含两个外显子。\n- 案例5（边界条件：排序中的平局处理和多个转录本）：基因 $g5$；mRNAs $t5$ 和 $t5b$（均为 $Parent=g5$），全部在 $+$ 链上。对于 $t5$，外显子位于 $[100,150]$, $[100,120]$ 和 $[160,170]$。对于 $t5b$，外显子位于 $[210,220]$ 和 $[300,320]$。$t5$ 链必须因终止位置的平局处理而将 $[100,120]$ 排在 $[100,150]$ 之前，然后是 $[160,170]$。$t5b$ 链必须是 $[210,220]$ 后跟 $[300,320]$。\n\n输出格式：\n- 对于每个测试用例，输出一个形式为 $[B,N,C]$ 的列表，其中 $B$ 是一个布尔值，表示是否检测到任何无效的 $Parent$ 引用，$N$ 是一个整数，等于重建的mRNA数量，而 $C$ 是一个外显子链的列表（每个mRNA一条，按mRNA $ID$ 的字典序排序）。每个外显子链必须是一个整数列表，由按转录本顺序连接的起始和终止坐标组成，形式为 $[s_1,e_1,s_2,e_2,\\dots]$。\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，形式为逗号分隔的列表并用方括号括起来，例如：$[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n答案类型：所有输出必须是布尔值、整数、浮点数或这些类型的列表。除了标准列表格式产生的括号外，输出中不能有任何字符串。\n\n您的程序必须是一个完整的、可运行的Python程序，该程序在内部嵌入测试套件并遵守指定的输出格式。不允许使用外部输入或文件。", "solution": "该问题要求根据通用特征格式第3版（GFF3）规范，重建转录本外显子链并验证父子关系。该解决方案实现为一个系统性的多遍算法，它首先解析和索引所有基因组特征，然后验证它们的关系并重建转录本模型，最后组装并格式化输出。\n\n该算法的核心依赖于高效的数据结构，主要是字典（哈希映射），来存储和检索特征信息。这确保了诸如通过标识符（$ID$）查找特征之类的操作在平均情况下以常数时间完成，这对于性能至关重要。\n\n对于每个GFF3片段的处理过程如下：\n\n**步骤1：解析与索引**\n\n首先，我们处理原始的GFF3数据。每一行代表一个单独的基因组特征，被解析为其九个组成字段。其中，我们感兴趣的是特征 `type`（字段3）、`start` 和 `end` 坐标（字段4和5）、`strand`（字段7）以及 `attributes`（字段9）。\n\n`attributes` 字段是一个由分号分隔的 `key=value` 对列表，我们解析它以提取唯一的特征 `ID` 和任何 `Parent` 标识符。由于 `Parent` 属性可以指定一个逗号分隔的多个父级列表，这些父级被解析为一个字符串列表。\n\n所有解析出的特征都存储在一个主字典中，我们称之为 `feature_map`。该字典将每个特征的 `ID` 映射到一个包含其基本属性的对象：`type`、`strand` 和一个 `Parent` ID列表。坐标被临时与外显子特征一起存储以供后续使用。这种索引至关重要，因为它允许在验证父子链接时进行快速查找（平均时间 $O(1)$）。同时，还维护一个包含所有 `mRNA` 特征 `ID` 的单独列表。\n\n**步骤2：验证与外显子关联**\n\n第二遍遍历所有已解析的特征，以验证问题中指定的亲子关系规则，并将外显子与其父mRNA关联起来。一个布尔标志 `invalid_parent_detected` 被初始化为 `false`，如果发现任何规则违规，它将被设置为 `true`。\n\n验证规则应用如下：\n1.  **带有Parent的基因**：如果发现一个 `type` 为“gene”的特征具有 `Parent` 属性，则将 `invalid_parent_detected` 设置为 `true`。\n2.  **mRNA的亲子关系**：对于每个 `type` 为“mRNA”的特征，我们遍历其 `Parent` ID。对于每个父ID `p_id`：\n    - 如果 `p_id` 不是 `feature_map` 中的一个键，则父级不存在。`invalid_parent_detected` 被设置为 `true`。\n    - 如果 `p_id` 存在，我们检查 `feature_map[p_id].type` 是否为“gene”。如果不是，则父级类型错误，`invalid_parent_detected` 被设置为 `true`。\n3.  **外显子的亲子关系**：对于每个 `type` 为“exon”的特征，我们遍历其 `Parent` ID。对于每个父ID `p_id`：\n    - 如果 `p_id` 不在 `feature_map` 中，`invalid_parent_detected` 被设置为 `true`。\n    - 如果 `p_id` 存在，我们检查 `feature_map[p_id].type` 是否为“mRNA”。如果不是，`invalid_parent_detected` 被设置为 `true`。如果它是一个有效的“mRNA”父级，则该外显子的坐标 $(s, e)$ 被添加到一个与 `p_id` 关联的列表中，该列表位于一个名为 `mrna_to_exons` 的独立字典中。该字典将每个mRNA `ID` 映射到其组成外显子的列表。\n\n**步骤3：外显子链的组装与排序**\n\n验证之后，`mrna_to_exons` 字典包含了所有有效的mRNA到外显子的关联。最后一步是为每个mRNA构建有序的外显子链。\n\n首先，mRNA `ID` 按字典序排序，以确保最终链列表的输出顺序是确定的。然后，对于每个mRNA：\n- 检索其关联的外显子列表。\n- 从 `feature_map` 中查找该mRNA的 `strand`。\n- 外显子的排序顺序由 `strand` 决定：\n    - 对于正链（`+`），外显子按其 `start` 坐标升序排序。`start` 的平局由 `end` 坐标（同样升序）打破。这对应于对坐标对 $(s, e)$ 进行字典序排序。\n    - 对于负链（`-`），外显子按其 `start` 坐标降序排序。平局由 `end` 坐标（同样降序）打破。这等同于对坐标对 $(s, e)$ 进行反向字典序排序。\n- 排序后的外显子坐标对列表随后被“扁平化”成一个单一的整数列表，形式为 $[s_1, e_1, s_2, e_2, \\dots]$。\n\n**最终输出生成**\n\n对于每个测试用例，最终结果是一个3元素列表 $[B, N, C]$，其中：\n- $B$ 是 `invalid_parent_detected` 布尔标志。\n- $N$ 是在输入片段中找到的 `mRNA` 特征的总数。\n- $C$ 是扁平化、排序后的外显子链列表，其顺序根据按字典序排序的mRNA `ID` 决定。\n\n**计算复杂度**\n\n设 $N$ 为GFF3片段中的特征数量（行数）。\n- 解析和索引阶段（步骤1）需要对 $N$ 行进行单遍扫描，字典插入的平均时间为 $O(1)$。此阶段为 $O(N)$。\n- 验证和关联阶段（步骤2）涉及对 $N$ 个特征的另一次遍历。对于每个特征，我们可能检查少量父级。每次检查都是一次字典查找（$O(1)$）。此阶段也近似为 $O(N)$。\n- 组装和排序阶段（步骤3）主要由为每个mRNA排序外显子所主导。如果有 $K$ 个mRNA，且第 $k$ 个mRNA有 $E_k$ 个外显子，则总时间为 $\\sum_{k=1}^{K} O(E_k \\log E_k)$。在最坏的情况下，即所有 $N$ 个特征都是单个转录本的外显子，这将变为 $O(N \\log N)$。对 $K$ 个mRNA ID进行排序需要 $O(K \\log K)$。\n因此，总体复杂度主要由排序决定，从而得到一个高效的 $O(N \\log N)$ 算法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the GFF3 transcript reconstruction and validation problem.\n    This function embeds the test suite and processes each case according to GFF3 rules.\n    \"\"\"\n    test_cases_gff3 = [\n        # Case 1: positive strand, single transcript, ordered exons\n        \"\"\"\nchr1\\t.\\tgene\\t100\\t400\\t.\\t+\\t.\\tID=g1\nchr1\\t.\\tmRNA\\t100\\t400\\t.\\t+\\t.\\tID=t1;Parent=g1\nchr1\\t.\\texon\\t100\\t200\\t.\\t+\\t.\\tID=e1;Parent=t1\nchr1\\t.\\texon\\t300\\t400\\t.\\t+\\t.\\tID=e2;Parent=t1\n        \"\"\",\n        # Case 2: negative strand, single transcript, out-of-order exons\n        \"\"\"\nchr2\\t.\\tgene\\t450\\t600\\t.\\t-\\t.\\tID=g2\nchr2\\t.\\tmRNA\\t450\\t600\\t.\\t-\\t.\\tID=t2;Parent=g2\nchr2\\t.\\texon\\t500\\t600\\t.\\t-\\t.\\tID=e3;Parent=t2\nchr2\\t.\\texon\\t450\\t480\\t.\\t-\\t.\\tID=e4;Parent=t2\n        \"\"\",\n        # Case 3: invalid parent reference (nonexistent)\n        \"\"\"\nchr3\\t.\\tgene\\t200\\t300\\t.\\t+\\t.\\tID=g3\nchr3\\t.\\tmRNA\\t200\\t300\\t.\\t+\\t.\\tID=t3;Parent=g3\nchr3\\t.\\texon\\t200\\t250\\t.\\t+\\t.\\tID=e5;Parent=t3\nchr3\\t.\\texon\\t260\\t300\\t.\\t+\\t.\\tID=e6;Parent=mr_unknown\n        \"\"\",\n        # Case 4: multiple parents with one invalid\n        \"\"\"\nchr4\\t.\\tgene\\t150\\t900\\t.\\t+\\t.\\tID=g4\nchr4\\t.\\tmRNA\\t150\\t900\\t.\\t+\\t.\\tID=t4;Parent=g4\nchr4\\t.\\texon\\t150\\t180\\t.\\t+\\t.\\tID=e7;Parent=t4,t4b\nchr4\\t.\\texon\\t800\\t900\\t.\\t+\\t.\\tID=e8;Parent=t4\n        \"\"\",\n        # Case 5: boundary conditions: tie-breaking and multiple transcripts\n        \"\"\"\nchr5\\t.\\tgene\\t100\\t320\\t.\\t+\\t.\\tID=g5\nchr5\\t.\\tmRNA\\t100\\t170\\t.\\t+\\t.\\tID=t5;Parent=g5\nchr5\\t.\\tmRNA\\t210\\t320\\t.\\t+\\t.\\tID=t5b;Parent=g5\nchr5\\t.\\texon\\t100\\t150\\t.\\t+\\t.\\tID=e9;Parent=t5\nchr5\\t.\\texon\\t100\\t120\\t.\\t+\\t.\\tID=e10;Parent=t5\nchr5\\t.\\texon\\t160\\t170\\t.\\t+\\t.\\tID=e11;Parent=t5\nchr5\\t.\\texon\\t210\\t220\\t.\\t+\\t.\\tID=e12;Parent=t5b\nchr5\\t.\\texon\\t300\\t320\\t.\\t+\\t.\\tID=e13;Parent=t5b\n        \"\"\"\n    ]\n\n    results = []\n    \n    for gff3_data in test_cases_gff3:\n        lines = [line for line in gff3_data.strip().split('\\n') if line.strip()]\n        \n        feature_map = {}\n        all_features = [] # To iterate over in the second pass\n\n        # Pass 1: Parse and index all features\n        for line in lines:\n            fields = line.strip().split('\\t')\n            seqid, source, ftype, start, end, score, strand, phase, attributes_str = fields\n            start, end = int(start), int(end)\n\n            # Parse attributes\n            attrs = {}\n            for part in attributes_str.split(';'):\n                if '=' in part:\n                    key, value = part.split('=', 1)\n                    attrs[key] = value\n\n            feature_id = attrs.get('ID')\n            parents = attrs.get('Parent', '').split(',') if attrs.get('Parent') else []\n\n            feature_info = {\n                'id': feature_id,\n                'type': ftype,\n                'start': start,\n                'end': end,\n                'strand': strand,\n                'parents': parents\n            }\n            \n            if feature_id:\n                feature_map[feature_id] = feature_info\n            \n            all_features.append(feature_info)\n\n        invalid_parent_found = False\n        mrna_ids = sorted([fid for fid, finfo in feature_map.items() if finfo['type'] == 'mRNA'])\n        mrna_to_exons = {mid: [] for mid in mrna_ids}\n        \n        # Pass 2: Validate relationships and associate exons\n        for feature in all_features:\n            ftype = feature['type']\n            parents = feature['parents']\n\n            if ftype == 'gene' and parents:\n                invalid_parent_found = True\n\n            elif ftype == 'mRNA':\n                if not parents: # An mRNA must have a parent\n                  invalid_parent_found = True\n                for parent_id in parents:\n                    if parent_id not in feature_map:\n                        invalid_parent_found = True\n                    elif feature_map.get(parent_id, {}).get('type') != 'gene':\n                        invalid_parent_found = True\n            \n            elif ftype == 'exon':\n                if not parents: # An exon must have a parent\n                  invalid_parent_found = True\n                for parent_id in parents:\n                    if parent_id not in feature_map:\n                        invalid_parent_found = True\n                    else:\n                        parent_feature = feature_map.get(parent_id)\n                        if parent_feature and parent_feature.get('type') == 'mRNA':\n                            # This check handles cases where an exon parent is a valid mRNA\n                            # but that mRNA is not in the list of mRNAs to be processed (e.g. from another gene).\n                            if parent_id in mrna_to_exons:\n                                mrna_to_exons[parent_id].append((feature['start'], feature['end']))\n                        else:\n                            invalid_parent_found = True\n        \n        # Pass 3: Sort exons and format output\n        exon_chains = []\n        for mrna_id in mrna_ids:\n            exons = mrna_to_exons[mrna_id]\n            strand = feature_map[mrna_id]['strand']\n            \n            if strand == '+':\n                exons.sort(key=lambda x: (x[0], x[1]))\n            elif strand == '-':\n                exons.sort(key=lambda x: (x[0], x[1]), reverse=True)\n            \n            chain = [coord for exon_coords in exons for coord in exon_coords]\n            exon_chains.append(chain)\n\n        results.append([invalid_parent_found, len(mrna_ids), exon_chains])\n\n    # Format the final output string exactly as specified.\n    # The default string representation of lists, booleans, and integers is used.\n    output_str = '[' + ','.join(map(str, results)) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "3291684"}, {"introduction": "为了使生物数据真正有价值并可重用，它必须附有丰富且标准化的元数据。本实践从基因组数据转向实验背景，演示如何使用形式化的模式来强制执行数据完整性。您将设计并应用一个 JSON 模式来验证单细胞 RNA 测序研究的元数据，确保其遵守 FAIR 原则并为整合分析做好准备 [@problem_id:3291672]。", "problem": "您的任务是为一个单细胞核糖核酸测序（scRNA-seq; single-cell RNA sequencing）研究中的样本元数据设计并以编程方式强制执行一个数据标准。目标是将数据完整性和互操作性的基本原则，如“可发现、可访问、可互操作、可重用”（FAIR）原则，转化为一个针对以JavaScript对象表示法（JSON; JavaScript Object Notation）表示的表格记录的具体验证方案。从数理逻辑和集合论的角度来看，一个模式（schema）通过在指定定义域上建立类型约束、集合成员资格（枚举）和数值顺序关系来规定可接受的值。\n\n从以下基本依据出发：\n- 类型即集合：字符串字段从所有有限字符序列的集合中取值，整数字段从整数集合 $\\mathbb{Z}$ 中取值，数字字段从实数集合 $\\mathbb{R}$ 中取值。\n- 集合成员资格约束：枚举约束要求 $x \\in S$，其中 $S$ 是一个明确列出的有限集合。\n- 顺序约束：数值范围表示为 $a \\le x \\le b$，其中 $a$ 和 $b$ 分别是 $\\mathbb{R}$ 或 $\\mathbb{Z}$ 内的下界和上界。\n\n请提出了一个JSON Schema，该Schema对每条记录 $r$ 强制执行以下属性：\n- 必填字段及其类型：\n  - $sample\\_id$：字符串。\n  - $species$：字符串，枚举为 $S\\_{\\text{species}} = \\{\\text{\"Homo sapiens\"}, \\text{\"Mus musculus\"}\\}$。\n  - $tissue$：字符串，枚举为 $S\\_{\\text{tissue}} = \\{\\text{\"lung\"}, \\text{\"liver\"}, \\text{\"kidney\"}\\}$。\n  - $platform$：字符串，枚举为 $S\\_{\\text{platform}} = \\{\\text{\"10x Genomics\"}, \\text{\"Smart-seq2\"}, \\text{\"Drop-seq\"}\\}$。\n  - $umi\\_count$：整数，范围约束为 $1 \\le umi\\_count \\le 10^6$。\n  - $mito\\_fraction$：数字，范围约束为 $0 \\le mito\\_fraction \\le 1$，以小数表示（不使用百分号）。\n  - $doublet\\_probability$：数字，范围约束为 $0 \\le doublet\\_probability \\le 1$，以小数表示（不使用百分号）。\n  - $age\\_years$：整数，范围约束为 $0 \\le age\\_years \\le 120$，以年表示。\n  - $sex$：字符串，枚举为 $S\\_{\\text{sex}} = \\{\\text{\"male\"}, \\text{\"female\"}, \\text{\"unknown\"}\\}$。\n- 可选字段可以存在，但不是必需的。任何存在的可选字段都必须符合其声明的类型和任何适用的约束。\n- 上面未列出的附加属性可以存在；只要所有必填字段满足约束，它们不影响验证结果。\n\n您的程序必须：\n1. 将上述模式构建为一个内部数据对象。\n2. 使用一个包含五个记录的测试套件对该模式进行验证，为每个记录生成一个布尔有效性结果，其中 $\\text{True}$ 表示记录符合模式，$\\text{False}$ 表示存在违规。\n3. 演示检测到三个特定的格式错误记录：\n   - 缺少必填字段。\n   - 枚举违规（值不在要求的集合中）。\n   - 数值范围违规（值超出要求的边界）。\n4. 使用以下具有明确值的测试套件：\n   - 记录 A（正常路径）：$sample\\_id$ = \"SC0001\", $species$ = \"Homo sapiens\", $tissue$ = \"lung\", $platform$ = \"10x Genomics\", $umi\\_count$ = $50000$, $mito\\_fraction$ = $0.08$, $doublet\\_probability$ = $0.05$, $age\\_years$ = $34$, $sex$ = \"female\"。\n   - 记录 B（边界条件）：$sample\\_id$ = \"SC0002\", $species$ = \"Mus musculus\", $tissue$ = \"liver\", $platform$ = \"Smart-seq2\", $umi\\_count$ = $1$, $mito\\_fraction$ = $0.0$, $doublet\\_probability$ = $1.0$, $age\\_years$ = $0$, $sex$ = \"male\"。\n   - 记录 C（缺少必填字段）：$sample\\_id$ = \"SC0003\", $tissue$ = \"kidney\", $platform$ = \"Drop-seq\", $umi\\_count$ = $20000$, $mito\\_fraction$ = $0.12$, $doublet\\_probability$ = $0.1$, $age\\_years$ = $12$, $sex$ = \"unknown\"。$species$ 字段被故意省略。\n   - 记录 D（枚举违规）：$sample\\_id$ = \"SC0004\", $species$ = \"Drosophila melanogaster\", $tissue$ = \"lung\", $platform$ = \"10x Genomics\", $umi\\_count$ = $30000$, $mito\\_fraction$ = $0.07$, $doublet\\_probability$ = $0.02$, $age\\_years$ = $5$, $sex$ = \"female\"。\n   - 记录 E（数值范围违规）：$sample\\_id$ = \"SC0005\", $species$ = \"Homo sapiens\", $tissue$ = \"liver\", $platform$ = \"Smart-seq2\", $umi\\_count$ = $500000$, $mito\\_fraction$ = $1.2$, $doublet\\_probability$ = $0.03$, $age\\_years$ = $27$, $sex$ = \"male\"。\n5. 最终的输出格式必须是单行文本，包含一个用方括号括起来的逗号分隔列表。例如，如果记录 A 到 E 的结果为 $[v\\_A, v\\_B, v\\_C, v\\_D, v\\_E]$ 且 $v\\_i \\in \\{\\text{True}, \\text{False}\\}$，则精确打印 \"[True,False,True,False,True]\"。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3,result4,result5]\"）。所有测试用例的答案必须是布尔值。", "solution": "该解决方案基于数据完整性的既定原则和模式（schema）的形式语义。我们从以下观点出发：一个模式定义了字段定义域笛卡尔积的一个子集，通过与由类型、枚举和区间边界定义的集合求交集来强制执行约束。\n\n1. 将类型定义为集合。对每个字段 $f$，分配一个类型 $T\\_f$：\n   - 对于字符串，$T\\_f$ 是有限字符序列的集合。\n   - 对于整数，$T\\_f = \\mathbb{Z}$。\n   - 对于数字，$T\\_f = \\mathbb{R}$。\n\n2. 定义必填字段。设 $R$ 为必填字段名称的集合。一条记录 $r$ 仅在 $\\forall f \\in R$, $f \\in \\text{dom}(r)$ 时才可接受，其中 $\\text{dom}(r)$ 是 $r$ 中存在的键的集合。这强制了字段的存在性。\n\n3. 强制执行类型约束。对每个存在的字段 $f$，检查 $r[f] \\in T\\_f$。在代码中，这是一个运行时类型测试。对于整数字段，我们必须确保 $r[f] \\in \\mathbb{Z}$ 并排除布尔值，因为在许多编程语言中，布尔值是整数的子类型；因此我们明确要求 $r[f]$ 是整数而非布尔值。\n\n4. 强制执行枚举约束。对于带有枚举的字段，设 $S\\_f$ 为允许的有限集合。要求 $r[f] \\in S\\_f$。这实现了集合成员资格谓词 $x \\in S$。\n\n5. 强制执行数值范围。对于具有包含性边界的数字字段，如果 $a \\le x \\le b$，则值 $x$ 有效，其中 $a$ 和 $b$ 分别是最小值和最大值。此处：\n   - $1 \\le umi\\_count \\le 10^6$ 表示唯一分子标识符计数。\n   - $0 \\le mito\\_fraction \\le 1$ 和 $0 \\le doublet\\_probability \\le 1$ 的值以小数表示。\n   - $0 \\le age\\_years \\le 120$。\n\n6. 构建验证器。验证器函数遍历必填字段以检查其存在性，然后遍历属性以：\n   - 断言类型，\n   - 在定义时应用枚举检查，\n   - 在定义时应用最小值和最大值检查。\n   任何违规都会产生布尔值 $\\text{False}$；否则返回 $\\text{True}$。\n\n7. 应用于测试套件：\n   - 记录 A 满足所有约束：类型匹配，所有必填字段都存在，枚举有效，数值在范围内；因此结果为 $\\text{True}$。\n   - 记录 B 检查边界的包含性：$umi\\_count = 1$, $mito\\_fraction = 0.0$, $doublet\\_probability = 1.0$, $age\\_years = 0$ 均在包含性边界内，且枚举有效；因此结果为 $\\text{True}$。\n   - 记录 C 缺少必填字段 $species$。根据步骤 $2$，存在 $f \\in R$ 使得 $f \\notin \\text{dom}(r)$，因此结果为 $\\text{False}$。\n   - 记录 D 将 $species$ 设置为 \"Drosophila melanogaster\"，这违反了 $S\\_{\\text{species}}$。由于 $r[\\text{species}] \\notin S\\_{\\text{species}}$，结果为 $\\text{False}$。\n   - 记录 E 将 $mito\\_fraction$ 设置为 $1.2$，这违反了 $0 \\le mito\\_fraction \\le 1$。因为 $1.2 \\notin [0,1]$，结果为 $\\text{False}$。\n\n8. 输出聚合。收集五个布尔值 $[v\\_A, v\\_B, v\\_C, v\\_D, v\\_E]$ 并以要求的格式单行打印。这满足了可测试性要求，并演示了基于模式的验证检测到三个格式错误的记录。\n\n这种方法直接实现了来自类型、枚举和数值区间的约束的交集，通过严格遵守共享模式使数据具有互操作性，从而与FAIR原则保持一致。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# We use only the Python standard library.\nfrom typing import Any, Dict, List\n\ndef is_integer(value: Any) -> bool:\n    # Exclude booleans (which are subclasses of int in Python)\n    return isinstance(value, int) and not isinstance(value, bool)\n\ndef is_number(value: Any) -> bool:\n    # Accept ints and floats, but exclude booleans\n    return (isinstance(value, int) and not isinstance(value, bool)) or isinstance(value, float)\n\ndef validate_record(record: Dict[str, Any], schema: Dict[str, Any]) -> bool:\n    # Check required fields presence\n    for req in schema.get(\"required\", []):\n        if req not in record:\n            return False\n\n    properties = schema.get(\"properties\", {})\n\n    # Validate each property that appears in the record and is defined in the schema\n    for key, prop in properties.items():\n        if key not in record:\n            # If not present, skip unless it's required (handled above)\n            continue\n        value = record[key]\n        # Type checks\n        expected_type = prop.get(\"type\")\n        if expected_type == \"string\":\n            if not isinstance(value, str):\n                return False\n        elif expected_type == \"integer\":\n            if not is_integer(value):\n                return False\n        elif expected_type == \"number\":\n            if not is_number(value):\n                return False\n        else:\n            # Unknown type in schema; for robustness, consider invalid\n            return False\n\n        # Enumeration check\n        enum_values = prop.get(\"enum\")\n        if enum_values is not None:\n            if value not in enum_values:\n                return False\n\n        # Range checks (minimum and maximum, inclusive)\n        if expected_type in (\"integer\", \"number\"):\n            if \"minimum\" in prop:\n                if value  prop[\"minimum\"]:\n                    return False\n            if \"maximum\" in prop:\n                if value > prop[\"maximum\"]:\n                    return False\n\n    # All checks passed\n    return True\n\ndef solve():\n    # Define the JSON Schema as a Python dictionary\n    schema = {\n        \"type\": \"object\",\n        \"required\": [\n            \"sample_id\",\n            \"species\",\n            \"tissue\",\n            \"platform\",\n            \"umi_count\",\n            \"mito_fraction\",\n            \"doublet_probability\",\n            \"age_years\",\n            \"sex\"\n        ],\n        \"properties\": {\n            \"sample_id\": {\"type\": \"string\"},\n            \"species\": {\n                \"type\": \"string\",\n                \"enum\": [\"Homo sapiens\", \"Mus musculus\"]\n            },\n            \"tissue\": {\n                \"type\": \"string\",\n                \"enum\": [\"lung\", \"liver\", \"kidney\"]\n            },\n            \"platform\": {\n                \"type\": \"string\",\n                \"enum\": [\"10x Genomics\", \"Smart-seq2\", \"Drop-seq\"]\n            },\n            \"umi_count\": {\n                \"type\": \"integer\",\n                \"minimum\": 1,\n                \"maximum\": 10**6\n            },\n            \"mito_fraction\": {\n                \"type\": \"number\",\n                \"minimum\": 0.0,\n                \"maximum\": 1.0\n            },\n            \"doublet_probability\": {\n                \"type\": \"number\",\n                \"minimum\": 0.0,\n                \"maximum\": 1.0\n            },\n            \"age_years\": {\n                \"type\": \"integer\",\n                \"minimum\": 0,\n                \"maximum\": 120\n            },\n            \"sex\": {\n                \"type\": \"string\",\n                \"enum\": [\"male\", \"female\", \"unknown\"]\n            },\n            # Optional fields example (not required)\n            \"library_prep\": {\n                \"type\": \"string\",\n                \"enum\": [\"polyA\", \"totalRNA\"]\n            },\n            \"batch_id\": {\"type\": \"string\"}\n        },\n        # Allow additional properties without affecting validation\n        \"additionalProperties\": True\n    }\n\n    # Define the test cases (records A-E)\n    test_cases: List[Dict[str, Any]] = [\n        # Record A (happy path)\n        {\n            \"sample_id\": \"SC0001\",\n            \"species\": \"Homo sapiens\",\n            \"tissue\": \"lung\",\n            \"platform\": \"10x Genomics\",\n            \"umi_count\": 50000,\n            \"mito_fraction\": 0.08,\n            \"doublet_probability\": 0.05,\n            \"age_years\": 34,\n            \"sex\": \"female\"\n        },\n        # Record B (boundary conditions)\n        {\n            \"sample_id\": \"SC0002\",\n            \"species\": \"Mus musculus\",\n            \"tissue\": \"liver\",\n            \"platform\": \"Smart-seq2\",\n            \"umi_count\": 1,\n            \"mito_fraction\": 0.0,\n            \"doublet_probability\": 1.0,\n            \"age_years\": 0,\n            \"sex\": \"male\"\n        },\n        # Record C (missing required field: species)\n        {\n            \"sample_id\": \"SC0003\",\n            \"tissue\": \"kidney\",\n            \"platform\": \"Drop-seq\",\n            \"umi_count\": 20000,\n            \"mito_fraction\": 0.12,\n            \"doublet_probability\": 0.1,\n            \"age_years\": 12,\n            \"sex\": \"unknown\"\n        },\n        # Record D (enumeration violation: species not allowed)\n        {\n            \"sample_id\": \"SC0004\",\n            \"species\": \"Drosophila melanogaster\",\n            \"tissue\": \"lung\",\n            \"platform\": \"10x Genomics\",\n            \"umi_count\": 30000,\n            \"mito_fraction\": 0.07,\n            \"doublet_probability\": 0.02,\n            \"age_years\": 5,\n            \"sex\": \"female\"\n        },\n        # Record E (numeric range violation: mito_fraction > 1)\n        {\n            \"sample_id\": \"SC0005\",\n            \"species\": \"Homo sapiens\",\n            \"tissue\": \"liver\",\n            \"platform\": \"Smart-seq2\",\n            \"umi_count\": 500000,\n            \"mito_fraction\": 1.2,\n            \"doublet_probability\": 0.03,\n            \"age_years\": 27,\n            \"sex\": \"male\"\n        },\n    ]\n\n    results = []\n    for rec in test_cases:\n        result = validate_record(rec, schema)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3291672"}]}