{"hands_on_practices": [{"introduction": "在开发或使用数值计算代码时，验证是至关重要的第一步，它能确保代码正确地求解方程并达到预期的精度阶数。本练习将引导您实践“制造解方法”（Method of Manufactured Solutions, MMS）——一种强大的代码验证技术。您将实现三种经典的有限体积格式——中心差分、一阶迎风和Scharfetter–Gummel格式，并对一个稳态对流扩散问题进行数值模拟，以验证它们的收敛速度[@problem_id:3311647]。", "problem": "考虑定义在有限区间上的具有常系数的稳态一维线性对流扩散方程，通过引入总通量以守恒形式写出。设未知场为 $u(x)$，定义域为 $x \\in [0,1]$（单位：米），具有恒定的平流速度 $c$（单位：米/秒）和恒定的扩散系数 $D$（单位：平方米/秒）。其控制方程为\n$$\\frac{d}{dx}\\left(-D \\frac{du}{dx} + c\\,u\\right) = s(x), \\quad x \\in (0,1),$$\n这等价于非守恒形式\n$$c\\,\\frac{du}{dx} - D\\,\\frac{d^2 u}{dx^2} = s(x)。$$\n使用制造解方法（Method of Manufactured Solutions）来验证三种空间算子通量离散化方法的空间精度阶，具体如下：\n- 对流通量采用二阶中心插值，扩散通量采用中心差分，\n- 对流通量采用一阶迎风插值，扩散通量采用中心差分，\n- 总通量采用 Scharfetter–Gummel (SG) 指数拟合格式，其中 Scharfetter–Gummel (SG) 指的是通过求解跨越一个面且源项为零的局部稳态对流扩散方程所推导出的经典两点通量近似。\n\n你必须：\n- 选择制造解\n$$u(x) = e^{x}\\,\\sin(2\\pi x) + x(1-x),$$\n推导由控制方程所蕴含的相应源项 $s(x)$，并推断在 $x=0$ 和 $x=1$ 处的相容边界条件。\n- 使用空间算子 $c\\,u'(x) - D\\,u''(x)$ 的定义，通过对 $u(x)$ 进行必要的求导，从第一性原理推导 $s(x)$。边界条件必须直接由 $u(x)$ 得到，以确保精确解在构造上满足边界条件。\n- 设计一个基于节点的均匀网格，该网格包含 $N$ 个等大的子区间，尺寸为 $h=1/N$，节点为 $x_i = i h$（$i \\in \\{0,1,\\dots,N\\}$），并在每个内部节点 $x_i$（$i \\in \\{1,2,\\dots,N-1\\}$）周围的控制体积上应用有限体积平衡。对每个控制体积上的源项使用中点积分。施加由制造解在 $x=0$ 和 $x=1$ 处确定的狄利克雷边界条件。\n\n你的程序必须为每种格式组装并求解得到的线性系统，并计算与网格节点处精确解 $u(x)$ 的误差。使用离散的类 $L^2$ 范数\n$$E(h) = \\sqrt{h \\sum_{i=0}^{N} \\left(u_i^{\\text{num}} - u(x_i)\\right)^2}。$$\n通过在网格序列上的双对数关系 $\\log E(h) \\approx \\alpha + p \\log h$ 中的最佳拟合斜率来估计观测到的精度阶 $p$。\n\n科学和数值规格：\n- 物理单位：长度单位为米，时间单位为秒，速度单位为米/秒，扩散系数单位为平方米/秒。最终输出报告为无量纲实数。\n- 角度单位：弧度。\n- 对所有测试使用以下网格尺寸：$N \\in \\{40, 80, 160, 320\\}$。\n- 使用以下参数测试套件（每一项为一个测试用例）：\n  1. 正常路径，中等对流扩散：$(c, D) = (1.0, 0.1)$。\n  2. 边界值边缘情况，纯扩散：$(c, D) = (0.0, 0.1)$。\n  3. 在所选网格上接近对流主导但仍稳定：$(c, D) = (1.0, 0.025)$。\n- 对于每个测试用例，计算三种格式（中心、迎风和 Scharfetter–Gummel）中每种格式的观测阶 $p$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，包含 $9$ 个结果，形式为方括号内的逗号分隔列表，按测试用例和格式排序，即：\n$$[p_{\\text{central},1},p_{\\text{upwind},1},p_{\\text{SG},1},p_{\\text{central},2},p_{\\text{upwind},2},p_{\\text{SG},2},p_{\\text{central},3},p_{\\text{upwind},3},p_{\\text{SG},3}],$$\n其中下标表示（格式，测试用例索引），测试用例索引按上述顺序排列。将每个 $p$ 表示为小数点后保留三位的小数。", "solution": "该问题被评估为**有效**。它具有科学依据，问题设定良好，客观且完整，为获得唯一解提供了所有必要信息。\n\n### 1. 制造解与源项\n我们采用制造解方法（MMS）来验证实现。我们选择一个光滑函数，即制造解 $u(x)$，并将其代入控制微分方程中，以找到相应的源项 $s(x)$。此过程保证我们有一个精确解，可以用来衡量我们数值格式的误差。\n\n指定的制造解为：\n$$ u(x) = e^{x}\\,\\sin(2\\pi x) + x(1-x) $$\n问题定义在域 $x \\in [0, 1]$上。通过在边界处计算 $u(x)$ 的值来获得狄利克雷边界条件：\n$$ u(0) = e^{0}\\,\\sin(0) + 0(1-0) = 0 $$\n$$ u(1) = e^{1}\\,\\sin(2\\pi) + 1(1-1) = 0 $$\n因此，在离散问题中，我们施加 $u_0 = 0$ 和 $u_N = 0$。\n\n源项 $s(x)$ 是从控制方程的非守恒形式 $s(x) = c\\,u'(x) - D\\,u''(x)$ 推导出来的。我们首先计算 $u(x)$ 的一阶和二阶导数：\n$$ u'(x) = \\frac{d}{dx} \\left( e^{x}\\,\\sin(2\\pi x) + x - x^2 \\right) = e^x \\sin(2\\pi x) + 2\\pi e^x \\cos(2\\pi x) + 1 - 2x $$\n$$ u''(x) = \\frac{d}{dx} u'(x) = \\left( e^x \\sin(2\\pi x) + 2\\pi e^x \\cos(2\\pi x) \\right) + \\left( 2\\pi e^x \\cos(2\\pi x) - 4\\pi^2 e^x \\sin(2\\pi x) \\right) - 2 $$\n$$ u''(x) = (1 - 4\\pi^2) e^x \\sin(2\\pi x) + 4\\pi e^x \\cos(2\\pi x) - 2 $$\n综合这些，源项为：\n$$ s(x) = c \\left( e^x \\sin(2\\pi x) + 2\\pi e^x \\cos(2\\pi x) + 1 - 2x \\right) - D \\left( (1 - 4\\pi^2) e^x \\sin(2\\pi x) + 4\\pi e^x \\cos(2\\pi x) - 2 \\right) $$\n\n### 2. 有限体积离散化\n我们将域 $[0, 1]$ 离散化为 $N$ 个宽度为 $h=1/N$ 的均匀子区间。节点位于 $x_i = i h$，其中 $i=0, 1, \\dots, N$。通过在每个内部节点 $x_i$ 为中心的控制体积（CV）上对守恒形式的方程 $\\frac{dF}{dx} = s(x)$（其中 $F(x) = -D \\frac{du}{dx} + c\\,u$ 是总通量）进行积分来应用有限体积法。节点 $i$ 的控制体积是 $[x_{i-1/2}, x_{i+1/2}]$，其中 $x_{i \\pm 1/2} = x_i \\pm h/2$。\n\n在第 $i$ 个长度为 $h$ 的控制体积上积分方程得到：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{dF}{dx} \\,dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} s(x) \\,dx $$\n对左侧应用微积分基本定理，对右侧的积分应用中点法则，得到每个内部节点 $i \\in \\{1, \\dots, N-1\\}$ 的半离散方程：\n$$ F_{i+1/2} - F_{i-1/2} \\approx h \\cdot s(x_i) $$\n这里，$F_{i \\pm 1/2}$ 表示在控制体面 $x_{i \\pm 1/2}$ 处计算的总通量。\n\n### 3. 通量离散格式\n该问题要求比较三种不同的格式来近似节点 $j$ 和 $j+1$ 之间的面通量 $F_{j+1/2}$。通量的扩散部分 $-D \\frac{du}{dx}$ 一致地使用二阶中心差分近似：$-D \\frac{u_{j+1} - u_j}{h}$。各种格式在对流通量项 $c u$ 的近似上有所不同。\n\n设通量写为一般形式 $F_{j+1/2} = \\mathcal{A}_{j+1/2} u_j + \\mathcal{B}_{j+1/2} u_{j+1}$。\n\n**a) 中心差分格式（CD）:**\n对流项使用二阶中心插值，$u_{j+1/2} \\approx (u_j + u_{j+1})/2$。\n$$ F_{j+1/2}^{\\text{CD}} = -D \\frac{u_{j+1} - u_j}{h} + c \\frac{u_j + u_{j+1}}{2} = \\left(\\frac{D}{h} + \\frac{c}{2}\\right) u_j + \\left(-\\frac{D}{h} + \\frac{c}{2}\\right) u_{j+1} $$\n该格式名义上是二阶精度（$p=2$），但当单元佩克莱特数 $Pe_h = |c|h/D > 2$ 时，已知会变得不稳定并产生非物理振荡。\n\n**b) 迎风格式（UDS）:**\n对流项使用一阶迎风插值，即面的 $u$ 值取自上风向节点。\n$$ u_{j+1/2} \\approx \\begin{cases} u_j  \\text{if } c \\ge 0 \\\\ u_{j+1}  \\text{if } c  0 \\end{cases} $$\n这可以紧凑地写为 $u_{j+1/2} \\approx \\frac{1+\\text{sgn}(c)}{2} u_j + \\frac{1-\\text{sgn}(c)}{2} u_{j+1}$。总通量为：\n$$ F_{j+1/2}^{\\text{UDS}} = -D \\frac{u_{j+1} - u_j}{h} + \\max(c, 0) u_j + \\min(c, 0) u_{j+1} = \\left(\\frac{D}{h} + \\max(c, 0)\\right) u_j + \\left(-\\frac{D}{h} + \\min(c, 0)\\right) u_{j+1} $$\n该格式是一阶精度（$p=1$），但无论佩克莱特数如何，它都具有鲁棒的稳定性。在 $c=0$ 的特殊情况下，它正确地退化为纯扩散的二阶中心差分格式。\n\n**c) Scharfetter–Gummel 格式（SG）:**\n该格式通过求解两个节点之间的局部齐次方程（无源）$-D u'' + c u' = 0$ 的精确解，然后计算得到的恒定通量来推导。通量使用伯努利函数 $B(z) = z/(e^z - 1)$ 表示：\n$$ F_{j+1/2}^{\\text{SG}} = \\frac{D}{h} \\left( B(-Pe_h) u_j - B(Pe_h) u_{j+1} \\right) $$\n其中 $Pe_h = ch/D$ 是单元佩克莱特数。SG 格式在 $Pe_h \\to 0$ 时（此时 $B(z) \\to 1 - z/2$）平滑地过渡到中心差分格式，在 $|Pe_h| \\to \\infty$ 时过渡到迎风格式。由于它对控制方程的齐次部分是精确的，其精度由源项的近似决定，而通过中点法则，源项的近似是二阶的。因此，SG 格式预计具有二阶精度（$p=2$）。\n\n### 4. 线性系统组装与求解\n对于均匀网格，所有面上的通量系数 $\\mathcal{A}$ 和 $\\mathcal{B}$ 都是常数。我们将其表示为 $\\mathcal{A}_f$ 和 $\\mathcal{B}_f$。将通量表达式代入有限体积平衡方程得到：\n$$ (\\mathcal{A}_f u_i + \\mathcal{B}_f u_{i+1}) - (\\mathcal{A}_f u_{i-1} + \\mathcal{B}_f u_i) = h s(x_i) $$\n对未知数 $u_{i-1}, u_i, u_{i+1}$ 进行整理：\n$$ (-\\mathcal{A}_f) u_{i-1} + (\\mathcal{A}_f - \\mathcal{B}_f) u_i + (\\mathcal{B}_f) u_{i+1} = h s(x_i) $$\n该方程对每个内部节点 $i=1, \\dots, N-1$ 均成立。在边界处，对于 $i=1$，项 $(-\\mathcal{A}_f)u_0$ 移到右侧。对于 $i=N-1$，项 $(\\mathcal{B}_f)u_N$ 移到右侧。由于 $u_0=u_N=0$，这些项为零。这就为未知的内部节点值向量 $\\mathbf{U} = [u_1, \\dots, u_{N-1}]^T$ 形成了一个三对角线性系统 $\\mathbf{A} \\mathbf{U} = \\mathbf{b}$。求解该系统即可获得数值解。\n\n### 5. 误差分析与精度阶\n数值解的误差是相对于精确的制造解，使用离散的类 $L^2$ 范数来衡量的：\n$$ E(h) = \\sqrt{h \\sum_{i=0}^{N} \\left(u_i^{\\text{num}} - u(x_i)\\right)^2} $$\n求和包括边界节点，在这些节点上误差按构造为零。为了估计精度阶 $p$，我们在一系列递减的网格尺寸 $h$（对应于 $N \\in \\{40, 80, 160, 320\\}$）上计算误差 $E(h)$。假设误差行为满足 $E(h) \\approx C h^p$（其中 $C$ 为某个常数），我们可以取对数：\n$$ \\log E(h) \\approx \\log C + p \\log h $$\n精度阶 $p$ 是误差与网格尺寸的双对数图中的直线斜率。我们使用线性最小二乘法拟合计算出的 $(\\log h, \\log E)$ 数据点来确定此斜率。对三种格式和三个测试用例中的每一种都重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the verification study for the 1D convection-diffusion equation.\n    It computes the order of accuracy for three different spatial discretization schemes\n    across three different physical parameter sets.\n    \"\"\"\n    \n    # Define problem parameters from the statement.\n    test_cases = [\n        (1.0, 0.1),    # Case 1: Moderate advection-diffusion\n        (0.0, 0.1),    # Case 2: Pure diffusion\n        (1.0, 0.025),  # Case 3: Near convection-dominated\n    ]\n    schemes = ['central', 'upwind', 'sg']\n    N_values = [40, 80, 160, 320]\n    \n    # --- Helper Functions ---\n\n    def u_exact(x):\n        \"\"\" The manufactured solution u(x). \"\"\"\n        return np.exp(x) * np.sin(2 * np.pi * x) + x * (1 - x)\n\n    def s_source(x, c, D):\n        \"\"\" The source term s(x) derived from the manufactured solution. \"\"\"\n        u_prime = (np.exp(x) * (np.sin(2 * np.pi * x) + 2 * np.pi * np.cos(2 * np.pi * x)) \n                   + 1 - 2 * x)\n        u_double_prime = (np.exp(x) * ((1 - 4 * np.pi**2) * np.sin(2 * np.pi * x) \n                                     + 4 * np.pi * np.cos(2 * np.pi * x)) \n                          - 2)\n        return c * u_prime - D * u_double_prime\n\n    def bernoulli(z):\n        \"\"\" \n        Robust implementation of the Bernoulli function B(z) = z / (exp(z) - 1).\n        Handles limits for small and large |z| to avoid numerical issues.\n        \"\"\"\n        if abs(z)  1e-9:\n            # Taylor expansion for small z to avoid 0/0\n            return 1.0 - 0.5 * z + (z**2) / 12.0\n        elif z > 700:\n            # Asymptotic value for large positive z to avoid overflow\n            return 0.0\n        elif z  -700:\n            # Asymptotic value for large negative z\n            return -z\n        else:\n            return z / np.expm1(z)\n            \n    def get_flux_coeffs(scheme, c, D, h):\n        \"\"\" \n        Computes the coefficients for the flux F_{j+1/2} = A_f*u_j + B_f*u_{j+1}.\n        \"\"\"\n        if scheme == 'central':\n            A_f = D / h + c / 2.0\n            B_f = -D / h + c / 2.0\n        elif scheme == 'upwind':\n            A_f = D / h + max(c, 0.0)\n            B_f = -D / h + min(c, 0.0)\n        elif scheme == 'sg':\n            if c == 0.0:\n                 # Pure diffusion limit\n                A_f = D / h\n                B_f = -D / h\n            else:\n                Pe_h = c * h / D\n                B_Pe_h = bernoulli(Pe_h)\n                B_minus_Pe_h = bernoulli(-Pe_h)\n                A_f = (D / h) * B_minus_Pe_h\n                B_f = -(D / h) * B_Pe_h\n        return A_f, B_f\n        \n    def run_single_sim(N, c, D, scheme):\n        \"\"\" \n        Assembles and solves the linear system for a given mesh size and scheme.\n        Returns the discrete L2-like error.\n        \"\"\"\n        h = 1.0 / N\n        x = np.linspace(0.0, 1.0, N + 1)\n        \n        # Dirichlet boundary conditions from manufactured solution\n        u_bc0 = u_exact(x[0])\n        u_bc1 = u_exact(x[-1])\n\n        # Get flux coefficients which are constant on a uniform grid\n        A_f, B_f = get_flux_coeffs(scheme, c, D, h)\n        \n        # Assemble the tridiagonal system Ax=b for interior nodes\n        num_unknowns = N - 1\n        \n        # The banded matrix 'ab' for scipy.linalg.solve_banded\n        # Shape is (l+u+1, M) -> (3, N-1)\n        ab = np.zeros((3, num_unknowns))\n        ab[0, 1:] = B_f          # Upper diagonal\n        ab[1, :] = A_f - B_f     # Main diagonal\n        ab[2, :-1] = -A_f        # Lower diagonal\n        \n        # Assemble the right-hand side vector\n        b = h * s_source(x[1:-1], c, D)\n        \n        # Apply boundary conditions\n        b[0] -= (-A_f) * u_bc0\n        b[-1] -= B_f * u_bc1\n\n        # Solve the linear system\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Combine with boundary values to get full solution\n        u_num = np.concatenate(([u_bc0], u_interior, [u_bc1]))\n        \n        # Compute error norm\n        u_ex = u_exact(x)\n        error = np.sqrt(h * np.sum((u_num - u_ex)**2))\n        \n        return error\n\n    def calculate_order(c, D, scheme):\n        \"\"\"\n        Computes the order of accuracy p for a given scheme and parameters\n        by running simulations on a sequence of refined meshes.\n        \"\"\"\n        errors = []\n        h_values = []\n        \n        for N in N_values:\n            h = 1.0 / N\n            h_values.append(h)\n            error = run_single_sim(N, c, D, scheme)\n            errors.append(error)\n\n        # Use polyfit on log-log data to find the slope (order of accuracy)\n        log_h = np.log(h_values)\n        log_e = np.log(errors)\n        p, _ = np.polyfit(log_h, log_e, 1)\n        \n        return abs(p)\n\n    # --- Main Execution Logic ---\n    \n    all_results = []\n    for c_val, D_val in test_cases:\n        for scheme_name in schemes:\n            p_val = calculate_order(c_val, D_val, scheme_name)\n            all_results.append(p_val)\n    \n    # Format and print the final output as specified.\n    print(f\"[{','.join(f'{p:.3f}' for p in all_results)}]\")\n\nsolve()\n```", "id": "3311647"}, {"introduction": "除了简单的精度阶数，数值格式的误差还可以分解为幅值误差（耗散误差）和相位误差（色散误差）。这项高级练习将带您进入格式优化的实用领域，您将为一个瞬态问题实现一个可调的混合离散格式 $\\beta$。通过分析高斯波形的演化，您将学会量化这些不同类型的误差，并校准该格式以找到一个最佳平衡点，从而最小化数值阻尼和相位延迟[@problem_id:3311680]。", "problem": "考虑一个长度为 $L$ 的周期性域上的一维线性对流扩散方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in [0,L), \\ t \\ge 0,\n$$\n其中对流速度 $a0$ 为严格为正的常数，运动扩散系数 $\\nu \\ge 0$ 为常数。初始条件是一个高斯函数，\n$$\nu(x,0) = \\exp\\left(-\\frac{(x-x_0)^2}{4\\sigma^2}\\right),\n$$\n其中 $x_0 \\in [0,L)$ 是中心，$\\sigma0$ 表征初始宽度。使用具有 $N$ 个点、间距为 $\\Delta x = L/N$ 的均匀网格，并采用周期性边界条件。\n\n空间导数按如下方式离散化：\n- 对于一阶导数，使用一个混合了中心差分和迎风差分的单参数族，\n$$\n\\left(D^{(1)}_\\beta u\\right)_i = \\frac{1-\\beta}{2\\Delta x}\\left(u_{i+1}-u_{i-1}\\right) + \\frac{\\beta}{\\Delta x}\\left(u_i - u_{i-1}\\right),\n$$\n其中下标 $i$ 对 $N$ 取模，$\\beta \\in [0,1]$ 是迎风偏置参数。此定义假设 $a0$。\n- 对于二阶导数，使用标准中心差分，\n$$\n\\left(D^{(2)} u\\right)_i = \\frac{u_{i+1}-2u_i+u_{i-1}}{\\Delta x^2}.\n$$\n\n令 $T = L/a$ 表示一个对流翻转时间。在一个翻转时间内，连续问题的精确解会将高斯函数沿域平流一周并使其扩散。在时间 $T$ 时的精确解是一个中心位于 $x_0$ 的高斯函数，其振幅为\n$$\nA_{\\text{exact}} = \\frac{\\sigma}{\\sqrt{\\sigma^2 + \\nu T}},\n$$\n且位置与 $x_0$ 相同（对 $L$ 取模）。\n\n对半离散系统进行时间离散化\n$$\n\\frac{d \\boldsymbol{u}}{dt} = -a D^{(1)}_\\beta \\boldsymbol{u} + \\nu D^{(2)} \\boldsymbol{u}\n$$\n使用三阶强稳定性保持龙格-库塔方法 (SSP-RK3)。选择时间步长 $\\Delta t$ 以同时满足对流和扩散的显式稳定性限制，\n$$\n\\Delta t \\le \\text{CFL}\\,\\frac{\\Delta x}{a}, \\qquad \\Delta t \\le C_\\nu\\,\\frac{\\Delta x^2}{\\nu} \\ \\ (\\text{if } \\nu0),\n$$\n其中系数 $\\text{CFL} \\in (0,1)$ 和 $C_\\nu \\in (0,1)$ 为预设值，并取整数个时间步数 $n$ 使得 $n\\Delta t = T$。\n\n在时间 $T$ 定义两个定量诊断指标：\n- 数值振幅 $A_{\\text{num}} = \\max_i u_i(T)$。\n- 通过循环质心计算的数值相位位置，\n$$\nx_{\\text{num}} = \\frac{L}{2\\pi} \\operatorname{Arg}\\left(\\sum_{i=0}^{N-1} u_i(T)\\, e^{\\mathrm{i}\\, 2\\pi x_i/L}\\right) \\bmod L,\n$$\n以及最小周期相位误差\n$$\n\\Delta x = \\operatorname{mod}\\left(x_{\\text{num}} - x_0 + \\frac{L}{2},\\, L\\right) - \\frac{L}{2}.\n$$\n\n使用精确解来诊断一个翻转时间后的两个误差：\n- 振幅衰减误差 $E_A = \\left|A_{\\text{num}} - A_{\\text{exact}}\\right|/A_{\\text{exact}}$。\n- 相位误差 $E_\\phi = \\left|\\Delta x\\right|/\\sigma$。\n\n通过最小化组合目标函数来校准迎风偏置参数 $\\beta$\n$$\nJ(\\beta) = \\frac{1}{2} \\left(E_A + E_\\phi\\right),\n$$\n在一个候选值 $\\beta \\in [0, \\beta_{\\max}]$ 的均匀网格上进行，其中 $\\beta_{\\max}0$ 且步长 $\\Delta\\beta0$ 固定。时间积分器为 SSP-RK3，空间算子如上定义。为保证可复现性，通过在半离散算子的傅里叶符号上评估 SSP-RK3 稳定性多项式 $P(z) = 1 + z + \\tfrac{1}{2}z^2 + \\tfrac{1}{6}z^3$，使用离散傅里叶表示来应用大小为 $\\Delta t = T/n$ 的 $n$ 个相等时间步长的线性更新。该算法必须是自包含的，且不得依赖外部数据。\n\n所有量均为无量纲；无需物理单位。\n\n测试套件。对于下述每个测试用例，在搜索集 $\\{\\beta_k = k\\,\\Delta\\beta \\mid k=0,1,\\dots, K\\}$（其中 $\\beta_{\\max} = K\\,\\Delta\\beta$）上最小化 $J(\\beta)$：\n- 测试 1：$L=10$, $N=256$, $a=1$, $\\nu=10^{-2}$, $\\sigma=0.5$, $x_0 = L/5$, $\\text{CFL}=0.45$, $C_\\nu=0.25$, $\\Delta\\beta=0.01$, $\\beta_{\\max}=0.50$。\n- 测试 2：$L=10$, $N=256$, $a=1$, $\\nu=0$, $\\sigma=0.5$, $x_0 = L/5$, $\\text{CFL}=0.45$, $C_\\nu=0.25$, $\\Delta\\beta=0.01$, $\\beta_{\\max}=0.50$。\n- 测试 3：$L=10$, $N=64$, $a=1$, $\\nu=5\\times 10^{-3}$, $\\sigma=0.7$, $x_0 = L/5$, $\\text{CFL}=0.45$, $C_\\nu=0.25$, $\\Delta\\beta=0.01$, $\\beta_{\\max}=0.50$。\n- 测试 4：$L=10$, $N=256$, $a=2$, $\\nu=5\\times 10^{-3}$, $\\sigma=0.5$, $x_0 = L/5$, $\\text{CFL}=0.45$, $C_\\nu=0.25$, $\\Delta\\beta=0.01$, $\\beta_{\\max}=0.50$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含四个使目标函数最小化的 $\\beta$ 值，每个值四舍五入到三位小数，以逗号分隔的列表形式包含在方括号内（例如，$[\\beta_1,\\beta_2,\\beta_3,\\beta_4]$）。不应打印任何额外文本。", "solution": "用户提供了一个计算流体力学领域的适定问题。任务是为求解一维线性对流扩散方程的有限差分格式找到一个最优的迎风偏置参数 $\\beta$。该优化基于最小化一个对流翻转时间后的振幅和相位的组合误差度量。\n\n控制方程为长度为 $L$ 的周期性域上的线性对流扩散方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\n初始条件由一个高斯函数给出：\n$$\nu(x,0) = \\exp\\left(-\\frac{(x-x_0)^2}{4\\sigma^2}\\right)\n$$\n所有参数 $L, a, \\nu, \\sigma, x_0$ 均为给定常数。该域使用 $N$ 个均匀分布的网格点 $x_i = i \\Delta x$（$i=0, \\dots, N-1$）进行离散化，网格间距为 $\\Delta x = L/N$。\n\n空间导数使用有限差分进行离散化。由此产生的半离散系统可以写成一个关于网格点值向量 $\\boldsymbol{u}(t)$ 的常微分方程组 (ODE)：\n$$\n\\frac{d \\boldsymbol{u}}{dt} = \\boldsymbol{L}_\\beta \\boldsymbol{u}\n$$\n其中 $\\boldsymbol{L}_\\beta$ 是代表空间离散化的线性算子：\n$$\n\\boldsymbol{L}_\\beta = -a D^{(1)}_\\beta + \\nu D^{(2)}\n$$\n离散算子 $D^{(1)}_\\beta$ 和 $D^{(2)}$ 定义如下：\n$$\n\\left(D^{(1)}_\\beta u\\right)_i = \\frac{1-\\beta}{2\\Delta x}\\left(u_{i+1}-u_{i-1}\\right) + \\frac{\\beta}{\\Delta x}\\left(u_i - u_{i-1}\\right)\n$$\n$$\n\\left(D^{(2)} u\\right)_i = \\frac{u_{i+1}-2u_i+u_{i-1}}{\\Delta x^2}\n$$\n\n在周期性域上求解此常系数线性系统的一种高效方法是使用离散傅里叶变换 (DFT)。DFT 可以对角化任何循环矩阵，而我们在周期性网格上的离散算子正是由这类矩阵表示。令 $\\hat{\\boldsymbol{u}}(t)$ 为 $\\boldsymbol{u}(t)$ 的 DFT。该常微分方程组变换为一组解耦的标量常微分方程，每个傅里叶模式 $k$ 对应一个方程：\n$$\n\\frac{d\\hat{u}_k}{dt} = \\hat{L}_\\beta(k)\\hat{u}_k\n$$\n此处，$\\hat{L}_\\beta(k)$ 是算子 $\\boldsymbol{L}_\\beta$ 的傅里叶符号（特征值），对应于离散波数 $k_p = 2\\pi p / L$（$p = 0, \\dots, N-1$）。各个差分算子的符号是通过将它们应用于傅里叶模式 $e^{\\mathrm{i}k x_j} = e^{\\mathrm{i} (k \\Delta x)j}$ 推导得出的。令 $\\theta_k = k \\Delta x$。\n一阶导数算子的符号为：\n$$\n\\hat{d}^{(1)}_\\beta(k) = \\frac{\\mathrm{i}\\sin(\\theta_k)}{\\Delta x} + \\frac{\\beta(1-\\cos(\\theta_k))}{\\Delta x}\n$$\n二阶导数算子的符号为：\n$$\n\\hat{d}^{(2)}(k) = \\frac{2(\\cos(\\theta_k)-1)}{\\Delta x^2}\n$$\n将它们结合起来，得到完整算子 $\\boldsymbol{L}_\\beta$ 的符号：\n$$\n\\hat{L}_\\beta(k) = -a \\hat{d}^{(1)}_\\beta(k) + \\nu \\hat{d}^{(2)}(k)\n$$\n\n问题指定使用 SSP-RK3 方法进行时间积分，总时间为 $T = L/a$。时间区间被划分为 $n$ 个大小为 $\\Delta t = T/n$ 的步长。步数 $n$ 被选为满足对流和扩散显式稳定性条件的最小整数。经过 $n$ 步后，傅里叶空间中的解由下式给出：\n$$\n\\hat{u}_k(T) = \\left[ P\\left(\\hat{L}_\\beta(k) \\Delta t\\right) \\right]^n \\hat{u}_k(0)\n$$\n其中 $P(z) = 1 + z + \\frac{1}{2}z^2 + \\frac{1}{6}z^3$ 是 SSP-RK3 方法的稳定性多项式，$\\hat{u}_k(0)$ 是初始条件的 DFT。最终的数值解 $\\boldsymbol{u}(T)$ 通过对 $\\hat{\\boldsymbol{u}}(T)$ 应用逆 DFT 得到。\n\n为了找到最优的 $\\beta$，我们评估两个误差度量：\n1.  **振幅衰减误差 ($E_A$)**: 时间 $T$ 时的精确解是一个高斯函数，振幅为 $A_{\\text{exact}} = \\sigma / \\sqrt{\\sigma^2 + \\nu T}$。数值振幅为 $A_{\\text{num}} = \\max_i u_i(T)$。误差为 $E_A = |A_{\\text{num}} - A_{\\text{exact}}|/A_{\\text{exact}}$。\n2.  **相位误差 ($E_\\phi$)**: 数值相位位置 $x_{\\text{num}}$ 使用质心公式计算，该公式对应于第一傅里叶模式的相位：\n    $$\n    x_{\\text{num}} = \\frac{L}{2\\pi} \\operatorname{Arg}\\left(\\sum_{i=0}^{N-1} u_i(T)\\, e^{\\mathrm{i}\\, 2\\pi x_i/L}\\right) \\bmod L\n    $$\n    该求和等效于 $\\boldsymbol{u}(T)$ 的 DFT 的 $k=-1$ 分量，这可以从 $\\hat{\\boldsymbol{u}}(T)$ 中直接获得。最小周期相位误差为 $\\Delta x = \\operatorname{mod}(x_{\\text{num}} - x_0 + L/2, L) - L/2$。无量纲相位误差为 $E_\\phi = |\\Delta x|/\\sigma$。\n\n要最小化的目标函数是 $J(\\beta) = \\frac{1}{2} (E_A + E_\\phi)$。最小化通过在指定的 $\\beta$ 候选值的离散集合上进行网格搜索来执行。对于每个测试用例，选择产生最小 $J(\\beta)$ 值的 $\\beta$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_optimal_beta(L, N, a, nu, sigma, x0, CFL, C_nu, delta_beta, beta_max):\n    \"\"\"\n    Solves the 1D linear convection-diffusion equation and finds the optimal\n    upwind-bias parameter beta by minimizing a combined error metric.\n    \"\"\"\n    # Grid and initial condition\n    dx = L / N\n    x = np.arange(N) * dx\n    # The initial condition is a non-periodic Gaussian. This is a common simplification\n    # when sigma  L, as the periodic wrap-around effects are negligible.\n    u0 = np.exp(-(x - x0)**2 / (4 * sigma**2))\n    u0_hat = np.fft.fft(u0)\n\n    # Time step calculation\n    T = L / a\n    # Number of steps n must be large enough to satisfy CFL conditions.\n    # n >= (T * a) / (CFL * dx) = (L/a * a) / (CFL * L/N) = N/CFL\n    n_conv = N / CFL\n    # n >= (T * nu) / (C_nu * dx^2) = (L/a * nu) / (C_nu * (L/N)^2) = nu*N^2 / (a*C_nu*L)\n    n_diff = (nu * N**2) / (a * C_nu * L) if nu > 0 else 0\n    n_steps = int(np.ceil(max(n_conv, n_diff)))\n    dt = T / n_steps\n\n    # Wavenumbers for Fourier analysis\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    theta = k * dx\n\n    # Exact amplitude at time T\n    A_exact = sigma / np.sqrt(sigma**2 + nu * T)\n\n    # Grid search for optimal beta\n    beta_candidates = np.arange(0.0, beta_max + delta_beta / 2, delta_beta)\n    min_J = float('inf')\n    optimal_beta = -1.0\n\n    for beta in beta_candidates:\n        # Fourier symbol of the semi-discrete operator L_beta\n        # Symbol for first derivative operator D^(1)_beta\n        d1_hat = (1j * np.sin(theta) / dx) + (beta * (1 - np.cos(theta)) / dx)\n        # Symbol for second derivative operator D^(2)\n        d2_hat = (2 * (np.cos(theta) - 1)) / dx**2\n        \n        L_hat = -a * d1_hat + nu * d2_hat\n        \n        # Evolve in Fourier space using SSP-RK3 stability polynomial\n        z = L_hat * dt\n        P_z = 1 + z + 0.5 * z**2 + (1/6.0) * z**3\n        uT_hat = u0_hat * (P_z**n_steps)\n\n        # Transform back to physical space\n        uT = np.fft.ifft(uT_hat).real\n\n        # Calculate amplitude error\n        A_num = np.max(uT)\n        E_A = np.abs(A_num - A_exact) / A_exact\n\n        # Calculate phase error\n        # The sum is the k=-1 component of the DFT of uT, which is uT_hat[-1]\n        Z = uT_hat[-1]\n        x_num = (L / (2 * np.pi) * np.angle(Z)) % L\n        \n        # Minimal periodic phase error\n        dx_error = (x_num - x0 + L / 2) % L - L / 2\n        E_phi = np.abs(dx_error) / sigma\n\n        # Objective function\n        J = 0.5 * (E_A + E_phi)\n\n        if J  min_J:\n            min_J = J\n            optimal_beta = beta\n\n    return optimal_beta\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: L=10, N=256, a=1, nu=10^-2, sigma=0.5, x0=L/5, CFL=0.45, C_nu=0.25, dB=0.01, b_max=0.50\n        (10.0, 256, 1.0, 1e-2, 0.5, 10.0/5.0, 0.45, 0.25, 0.01, 0.50),\n        # Test 2: L=10, N=256, a=1, nu=0, sigma=0.5, x0=L/5, CFL=0.45, C_nu=0.25, dB=0.01, b_max=0.50\n        (10.0, 256, 1.0, 0.0, 0.5, 10.0/5.0, 0.45, 0.25, 0.01, 0.50),\n        # Test 3: L=10, N=64, a=1, nu=5x10^-3, sigma=0.7, x0=L/5, CFL=0.45, C_nu=0.25, dB=0.01, b_max=0.50\n        (10.0, 64, 1.0, 5e-3, 0.7, 10.0/5.0, 0.45, 0.25, 0.01, 0.50),\n        # Test 4: L=10, N=256, a=2, nu=5x10^-3, sigma=0.5, x0=L/5, CFL=0.45, C_nu=0.25, dB=0.01, b_max=0.50\n        (10.0, 256, 2.0, 5e-3, 0.5, 10.0/5.0, 0.45, 0.25, 0.01, 0.50),\n    ]\n\n    results = []\n    for params in test_cases:\n        optimal_beta = find_optimal_beta(*params)\n        results.append(optimal_beta)\n\n    # Format the results as specified\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3311680"}]}