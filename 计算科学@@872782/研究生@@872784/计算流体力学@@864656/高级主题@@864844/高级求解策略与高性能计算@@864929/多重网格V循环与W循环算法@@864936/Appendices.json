{"hands_on_practices": [{"introduction": "多重网格方法的核心在于在细网格和粗网格之间传递信息。本练习将这些基本操作——限制（restriction）和延长（prolongation）——分离出来，以分析它们的综合效应。通过将它们应用于一个简单的二次函数，您将直接计算出此过程引入的误差，从而对粗网格校正的内在属性获得具体的理解[@problem_id:3347230]。", "problem": "考虑在计算流体动力学(CFD)中，多重网格V循环和W循环迭代所使用的一个典型网格传输步骤，该步骤作用于一个代表偏微分方程(PDE)解的光滑标量场。设计算域为 $\\Omega = [0,1] \\times [0,1]$，细网格为均匀网格，有 $9 \\times 9$ 个节点（即每个方向有 $8$ 个区间），因此细网格间距为 $h = \\frac{1}{8}$。粗网格通过选取每隔一个细网格节点来定义，从而得到具有间距 $2h$ 的 $5 \\times 5$ 个粗网格节点。\n\n设连续场为 $u(x,y) = x^2 + y^2$，并假设在细网格节点上给出了 $u$ 的精确采样值。将在粗网格节点 $(x_{0},y_{0})$ 处从细网格到粗网格的全加权限制算子通过九点格式定义如下：\n$$\n\\mathcal{R}_{\\text{FW}}[u] (x_{0},y_{0}) \\;=\\; \\frac{1}{16}\\Big(u(x_{0}-h,y_{0}-h) + 2\\,u(x_{0},y_{0}-h) + u(x_{0}+h,y_{0}-h) \\\\\n+ 2\\,u(x_{0}-h,y_{0}) + 4\\,u(x_{0},y_{0}) + 2\\,u(x_{0}+h,y_{0}) \\\\\n+ u(x_{0}-h,y_{0}+h) + 2\\,u(x_{0},y_{0}+h) + u(x_{0}+h,y_{0}+h)\\Big).\n$$\n然后，通过逐单元双线性插值定义从粗网格到细网格的延拓：在一个顶点为 $(X_{0},Y_{0})$、$(X_{0}+2h,Y_{0})$、$(X_{0},Y_{0}+2h)$、$(X_{0}+2h,Y_{0}+2h)$ 的粗网格单元上，对于该单元内局部坐标为 $s,t \\in [0,1]$ 的任意点 $(x,y)$（满足 $x = X_{0} + 2hs$ 和 $y = Y_{0} + 2ht$），其插值等于\n$$\n\\mathcal{P}_{\\text{bilinear}}[U_{c}](x,y) \\;=\\; (1-s)(1-t)\\,U_{c}(X_{0},Y_{0}) \\;+\\; s(1-t)\\,U_{c}(X_{0}+2h,Y_{0}) \\\\\n+\\; (1-s)t\\,U_{c}(X_{0},Y_{0}+2h) \\;+\\; s t\\,U_{c}(X_{0}+2h,Y_{0}+2h),\n$$\n其中 $U_{c}$ 表示通过限制算子得到的粗网格值。使用这些定义，对给定的 $u$ 的细网格采样值应用全加权以获得粗网格值，然后应用双线性插值在细网格节点上重构近似的细网格值。计算在所有细网格节点上的最大逐点插值误差大小，\n$$\nE_{\\max} \\;=\\; \\max_{\\text{fine nodes }(x,y)} \\left|\\mathcal{P}_{\\text{bilinear}}\\big[\\mathcal{R}_{\\text{FW}}[u]\\big](x,y) \\;-\\; u(x,y)\\right|,\n$$\n并以单个实数的精确形式给出答案。答案无需四舍五入，也不包含任何单位。", "solution": "用户希望我解决一个问题。\n\n我的计划如下：\n1.  **验证问题陈述。**\n    *   **提取已知条件**：\n        *   计算域：$\\Omega = [0,1] \\times [0,1]$。\n        *   细网格：$9 \\times 9$ 个节点，间距 $h = \\frac{1}{8}$。\n        *   粗网格：$5 \\times 5$ 个节点，间距 $2h = \\frac{1}{4}$。\n        *   连续场：$u(x,y) = x^2 + y^2$。\n        *   细网格值为 $u(x,y)$ 的精确采样。\n        *   限制算子：$\\mathcal{R}_{\\text{FW}}$ 是全加权9点格式。\n        *   延拓算子：$\\mathcal{P}_{\\text{bilinear}}$ 是双线性插值。\n        *   目标：计算 $E_{\\max} = \\max_{\\text{fine nodes }(x,y)} |\\mathcal{P}_{\\text{bilinear}}[\\mathcal{R}_{\\text{FW}}[u]](x,y) - u(x,y)|$。\n    *   **验证**：\n        *   **科学依据**：该问题基于多重网格方法（限制、延拓）的标准基本概念，这些是求解偏微分方程的数值分析的基石。特定的算子（全加权、双线性插值）和测试函数（$u(x,y)=x^2+y^2$）是分析此类方法性质的经典选择。\n        *   **适定性**：问题陈述清晰，包含了所有必要的定义和数值。目标是一个特定的计算，会得出一个唯一的数值答案。\n        *   **客观性**：问题使用精确的数学语言陈述，没有歧义或主观内容。\n        *   **结论**：该问题是有效的。提及连续场 $u(x,y)$ 解决了在区域边界应用限制格式时可能出现的歧义，因为它暗示了函数的定义可以扩展到网格之外，这是截断误差分析中的标准做法。\n\n2.  **解决问题。**\n    求解过程包括三个主要步骤：\n    1.  将限制算子 $\\mathcal{R}_{\\text{FW}}$ 应用于 $u(x,y)$ 的细网格表示，以获得粗网格值 $U_c$。\n    2.  将延拓算子 $\\mathcal{P}_{\\text{bilinear}}$ 应用于粗网格值 $U_c$，以获得插值后的细网格值 $u_I$。\n    3.  计算误差 $E(x,y) = u_I(x,y) - u(x,y)$，并找出其在所有细网格节点上的最大绝对值。\n\n    **步骤1：限制**\n    设 $(x_0, y_0)$ 为一个粗网格节点。全加权限制算子 $\\mathcal{R}_{\\text{FW}}$ 通过对以 $(x_0, y_0)$ 为中心的九个细网格值进行加权平均，来计算粗网格值 $U_c(x_0, y_0)$。细网格值由连续函数 $u(x,y) = x^2 + y^2$ 给出。\n    该算子定义为：\n    $$\n    U_c(x_0, y_0) = \\frac{1}{16} \\sum_{i=-1}^{1} \\sum_{j=-1}^{1} w_{ij} u(x_0+ih, y_0+jh)\n    $$\n    其中权重为 $w_{00}=4$，$w_{\\pm 1, 0}=w_{0, \\pm 1}=2$，以及 $w_{\\pm 1, \\pm 1}=1$。\n\n    我们可以通过将 $u(x_0+ih, y_0+jh)$ 在 $(x_0, y_0)$ 周围进行泰勒级数展开来分析该算子对 $u(x,y)$ 的作用。由于 $u(x,y)$ 是一个二次多项式，其泰勒展开是精确且有限的：\n    $$\n    u(x_0+ih, y_0+jh) = u(x_0, y_0) + (ih) \\frac{\\partial u}{\\partial x} + (jh) \\frac{\\partial u}{\\partial y} + \\frac{1}{2} \\left( (ih)^2 \\frac{\\partial^2 u}{\\partial x^2} + (jh)^2 \\frac{\\partial^2 u}{\\partial y^2} + 2(ih)(jh) \\frac{\\partial^2 u}{\\partial x \\partial y} \\right)\n    $$\n    对于 $u(x,y) = x^2 + y^2$，在 $(x_0, y_0)$ 处的偏导数为：$\\frac{\\partial u}{\\partial x} = 2x_0$，$\\frac{\\partial u}{\\partial y} = 2y_0$，$\\frac{\\partial^2 u}{\\partial x^2} = 2$，$\\frac{\\partial^2 u}{\\partial y^2} = 2$，以及 $\\frac{\\partial^2 u}{\\partial x \\partial y} = 0$。\n    将这些代入展开式可得：\n    $$\n    u(x_0+ih, y_0+jh) = (x_0^2+y_0^2) + 2x_0 i h + 2y_0 j h + i^2 h^2 + j^2 h^2\n    $$\n    现在，我们计算加权和：\n    $$\n    U_c(x_0, y_0) = \\frac{1}{16} \\sum_{i,j} w_{ij} \\left( u(x_0, y_0) + 2x_0 i h + 2y_0 j h + i^2 h^2 + j^2 h^2 \\right)\n    $$\n    根据求和的线性性质：\n    $$\n    U_c(x_0, y_0) = \\frac{1}{16} \\left( u(x_0, y_0)\\sum_{i,j} w_{ij} + 2x_0 h \\sum_{i,j} w_{ij}i + 2y_0 h \\sum_{i,j} w_{ij}j + h^2 \\sum_{i,j} w_{ij}i^2 + h^2 \\sum_{i,j} w_{ij}j^2 \\right)\n    $$\n    我们计算加权指数的和：\n    $\\sum_{i,j} w_{ij} = 1+2+1+2+4+2+1+2+1 = 16$。\n    由于权重的对称性（$w_{ij} = w_{-i,j}$ 和 $w_{ij}=w_{i,-j}$）：\n    $\\sum_{i,j} w_{ij} i = 0$ 和 $\\sum_{i,j} w_{ij} j = 0$。\n    $i^2$ 项的和为：\n    $\\sum_{i,j} w_{ij} i^2 = \\sum_{j} (w_{-1,j}(-1)^2 + w_{0,j}(0)^2 + w_{1,j}(1)^2) = \\sum_{j} (w_{-1,j} + w_{1,j})$。\n    对于 $j \\in \\{-1, 1\\}$，$w_{-1,j}+w_{1,j} = 1+1=2$。对于 $j=0$，$w_{-1,0}+w_{1,0} = 2+2=4$。\n    所以，$\\sum_{i,j} w_{ij} i^2 = 2 + 4 + 2 = 8$。根据对称性，$\\sum_{i,j} w_{ij} j^2 = 8$。\n\n    将这些和代回到 $U_c$ 的表达式中：\n    $$\n    U_c(x_0, y_0) = \\frac{1}{16} \\left( 16 u(x_0, y_0) + 0 + 0 + 8h^2 + 8h^2 \\right) = u(x_0, y_0) + \\frac{16h^2}{16} = u(x_0, y_0) + h^2\n    $$\n    因此，在每个粗网格节点 $(x,y)$ 处，粗网格值为 $U_c(x,y) = x^2+y^2+h^2$。\n\n    **步骤2：延拓**\n    接下来，我们将双线性插值 $\\mathcal{P}_{\\text{bilinear}}$ 应用于粗网格数据 $U_c$，以获得细网格上的值 $u_I$。该算子是线性的，所以我们可以写出：\n    $$\n    u_I(x,y) = \\mathcal{P}_{\\text{bilinear}}[U_c](x,y) = \\mathcal{P}_{\\text{bilinear}}[u+h^2](x,y) = \\mathcal{P}_{\\text{bilinear}}[u](x,y) + \\mathcal{P}_{\\text{bilinear}}[h^2](x,y)\n    $$\n    对一个常数值（$h^2$）进行双线性插值，结果在任何地方都是该常数值。因此，$\\mathcal{P}_{\\text{bilinear}}[h^2](x,y) = h^2$。\n    方程简化为：\n    $$\n    u_I(x,y) = \\mathcal{P}_{\\text{bilinear}}[u](x,y) + h^2\n    $$\n\n    **步骤3：误差计算**\n    在细网格点 $(x,y)$ 处的误差为：\n    $$\n    E(x,y) = u_I(x,y) - u(x,y) = \\left( \\mathcal{P}_{\\text{bilinear}}[u](x,y) - u(x,y) \\right) + h^2\n    $$\n    括号中的项是函数 $u(x,y)=x^2+y^2$ 的标准双线性插值误差。我们来计算这个误差。\n    考虑一个顶点为 $(X_0, Y_0), (X_0+2h, Y_0), (X_0, Y_0+2h), (X_0+2h, Y_0+2h)$ 的粗网格单元。该单元中的一个点 $(x,y)$ 由 $x = X_0 + s(2h)$ 和 $y = Y_0 + t(2h)$ 参数化，其中 $s,t \\in [0,1]$。\n    双线性插值算子对于被插值的函数也是线性的，所以 $\\mathcal{P}_{\\text{bilinear}}[x^2+y^2] = \\mathcal{P}_{\\text{bilinear}}[x^2] + \\mathcal{P}_{\\text{bilinear}}[y^2]$。\n    让我们使用在 $[Z_0, Z_0+L]$ 上的一维线性插值来求 $f(z)=z^2$ 的插值误差。插值为 $f_I(z) = (1-\\sigma)Z_0^2 + \\sigma(Z_0+L)^2$，其中 $z=Z_0+\\sigma L$。\n    误差为 $f_I(z) - z^2 = ((1-\\sigma)Z_0^2 + \\sigma(Z_0+L)^2) - (Z_0+\\sigma L)^2 = L^2\\sigma(1-\\sigma)$。\n    对于 $u(x,y)=x^2+y^2$ 的双线性插值，我们有：\n    $\\mathcal{P}_{\\text{bilinear}}[x^2](x,y) = x^2 + (2h)^2s(1-s) = x^2+4h^2s(1-s)$。\n    $\\mathcal{P}_{\\text{bilinear}}[y^2](x,y) = y^2 + (2h)^2t(1-t) = y^2+4h^2t(1-t)$。\n    $u$ 的插值误差为：\n    $$\n    \\mathcal{P}_{\\text{bilinear}}[u](x,y) - u(x,y) = (x^2+4h^2s(1-s) + y^2+4h^2t(1-t)) - (x^2+y^2) = 4h^2s(1-s) + 4h^2t(1-t)\n    $$\n    因此，总误差为：\n    $$\n    E(x,y) = \\left( 4h^2s(1-s) + 4h^2t(1-t) \\right) + h^2 = h^2(1 + 4s(1-s) + 4t(1-t))\n    $$\n\n    **步骤4：最大化**\n    我们需要找到在所有细网格节点上 $|E(x,y)|$ 的最大值。由于 $h0$ 且 $s,t\\in[0,1]$，项 $s(1-s)$ 和 $t(1-t)$ 是非负的，所以 $E(x,y)$ 总是正的。因此， $|E(x,y)|=E(x,y)$。\n    细网格节点位于坐标 $(ih, jh)$ 处，其中 $i,j \\in \\{0, 1, \\dots, 8\\}$。一个细网格节点 $(ih, jh)$ 在一个粗网格单元内的局部坐标 $(s,t)$ 由 $s = (i \\pmod 2)/2$ 和 $t = (j \\pmod 2)/2$ 给出。\n    在细网格节点上，$s$ 和 $t$ 的可能值为 $0$ 和 $1/2$。\n    我们必须在 $(s,t) \\in \\{0, 1/2\\} \\times \\{0, 1/2\\}$ 的范围内最大化 $E(x,y)$。\n    函数 $f(\\sigma) = \\sigma(1-\\sigma)$ 在 $\\sigma=0$ 时为 $0$，在 $\\sigma=1/2$ 时为 $1/4$。\n    当 $s(1-s)$ 和 $t(1-t)$ 最大化时，误差函数 $E$ 也最大化，这发生在 $s=1/2$ 和 $t=1/2$ 时。\n    这对应于奇数索引 $(i,j)$ 的细网格节点，这些节点是粗网格单元的中心。\n    最大误差为：\n    $$\n    E_{\\max} = h^2\\left(1 + 4\\left(\\frac{1}{2}\\right)\\left(1-\\frac{1}{2}\\right) + 4\\left(\\frac{1}{2}\\right)\\left(1-\\frac{1}{2}\\right)\\right) = h^2\\left(1 + 4\\left(\\frac{1}{4}\\right) + 4\\left(\\frac{1}{4}\\right)\\right)\n    $$\n    $$\n    E_{\\max} = h^2(1 + 1 + 1) = 3h^2\n    $$\n    问题给出 $h = \\frac{1}{8}$。代入这个值：\n    $$\n    E_{\\max} = 3 \\left(\\frac{1}{8}\\right)^2 = 3 \\left(\\frac{1}{64}\\right) = \\frac{3}{64}\n    $$", "answer": "$$\\boxed{\\frac{3}{64}}$$", "id": "3347230"}, {"introduction": "多重网格循环的第一步是“光顺”，其目的是衰减在粗网格上无法很好表示的高频误差分量。本练习要求您实现一个红黑高斯-赛德尔（Red-Black Gauss-Seidel）光顺子，并通过测量其对特定傅里叶误差模式的衰减效果来量化其有效性[@problem_id:3347195]。这是局部傅里叶分析（Local Fourier Analysis, LFA）中的一项核心技术，也是预测多重网格性能的主要工具。", "problem": "考虑单位正方形 $\\Omega = (0,1)\\times(0,1)$ 上的泊松方程 $-\\Delta u = f$，边界条件为齐次狄利克雷边界条件 $u=0$ on $\\partial \\Omega$。使用一个包含 $N \\times N$ 个内部点的均匀网格，其中 $N=32$，网格间距 $h = 1/(N+1)$，并对负拉普拉斯算子使用标准的5点有限差分格式进行离散化。得到的线性系统为 $A u = f_h$，其中 $A$ 是对应于5点格式的稀疏矩阵，$f_h$ 是在网格点上采样的右端项。多重网格方法中的前平滑器应用一次红黑高斯-赛德尔（RBGS）扫描，该方法根据网格点整数索引之和 $(i+j)$ 的奇偶性将内部网格点分为两种颜色：“红色”（若 $(i+j)$ 为偶数）和“黑色”（若 $(i+j)$ 为奇数），并先更新红色点，再更新黑色点。每次更新将 $u_{i,j}$ 替换为其四个最近邻点的平均值加上一个强迫项，这与 $-\\Delta$ 的5点离散化格式一致。\n\n您的任务是：\n- 对离散系统 $A u = f_h$ 实现一次RBGS前平滑扫描，使用 $-\\Delta$ 的5点格式。在外部虚拟层上使用齐次狄利克雷边界条件，这意味着内部网格之外的值固定为零且不被更新。右端项是在内部网格点 $(x_i,y_j) = (i h, j h)$（其中 $i,j \\in \\{1,\\ldots,N\\}$）上采样的 $f(x,y) = \\sin(\\pi x)\\sin(\\pi y)$。\n- 通过RBGS前平滑器量化一个误差傅里叶模式的平滑（阻尼）效果。为此，考虑由RBGS诱导的线性定常迭代。对于这样的迭代，误差 $e^k = u^k - u^\\star$ 的演化遵循 $e^{k+1} = S e^k$，其中 $S$ 是一个不依赖于右端项的误差传播算子。因此，可以通过设置 $f_h \\equiv 0$，将内部未知量初始化为指定的误差模式 $e^0$，应用一次RBGS扫描，并测量范数之比 $\\|e^1\\|_2 / \\|e^0\\|_2$ 来评估特定误差模式的阻尼。将误差模式定义为\n$$\ne^0_{i,j} = \\cos(\\theta_x i)\\cos(\\theta_y j), \\quad \\text{for } i,j \\in \\{1,\\ldots,N\\},\n$$\n角度单位为弧度。在 $f_h \\equiv 0$ 的情况下进行一次RBGS扫描后，令 $e^1$ 表示更新后的内部场，并计算阻尼因子\n$$\n\\mu(\\theta_x,\\theta_y) = \\frac{\\|e^1\\|_2}{\\|e^0\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 是在 $N \\times N$ 内部网格上的欧几里得范数。\n\n需使用的假设和定义：\n- 在均匀网格上对 $-\\Delta$ 进行5点离散化，对每个内部节点 $(i,j)$ 可得：\n$$\n\\frac{4 u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} = f_{i,j}.\n$$\n- 在内部节点 $(i,j)$ 的RBGS更新将 $u_{i,j}$ 替换为\n$$\nu_{i,j} \\leftarrow \\frac{1}{4}\\left(u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} + h^2 f_{i,j}\\right),\n$$\n首先应用于所有红色节点（使用当前黑色邻点的值），然后应用于所有黑色节点（使用已更新的红色邻点的值）。由于齐次狄利克雷边界条件，在访问邻点时，内部网格之外的值被视为零。\n\n测试套件和要求输出：\n- 使用 $N=32$ 和 $h = 1/(N+1)$。为前平滑算子构建 $f_{i,j} = \\sin(\\pi x_i)\\sin(\\pi y_j)$，其中 $(x_i,y_j) = (i h, j h)$。为量化阻尼效果，设置 $f_{i,j} \\equiv 0$ 并使用上述的误差模式初始化。\n- 对以下三种情况（角度单位为弧度）评估阻尼因子 $\\mu(\\theta_x,\\theta_y)$：\n    - 情况1：$(\\theta_x,\\theta_y) = (\\pi/2,\\pi/2)$。\n    - 情况2：$(\\theta_x,\\theta_y) = (\\pi,\\pi)$。\n    - 情况3：$(\\theta_x,\\theta_y) = (\\pi/16,\\pi/16)$。\n- 您的程序必须按以上顺序计算三个阻尼因子，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$）。列表中的条目必须是浮点数。角度单位为弧度，无需报告物理单位。\n\n约束和期望：\n- 从基本定义开始：泊松方程 $-\\Delta u = f$、标准的5点离散化和迭代式RBGS平滑器。除这些定义外，不要调用任何专门的多重网格公式。\n- 通过使用指定的网格、边界条件和强迫函数来确保科学真实性。阻尼因子必须按规定进行数值计算，而不是通过外部公式得出。", "solution": "用户提供的问题经评估为**有效**。该问题在科学上是合理的、适定的和客观的，提出了一个偏微分方程数值分析领域的标准问题。所有必要的参数和定义都已提供，任务是为一个定义明确的算法进行直接的数值实现。\n\n该问题要求分析单次红黑高斯-赛德尔（RBGS）扫描的平滑特性，这是多重网格求解器中的一个常见组件。分析将通过量化单位正方形上二维泊松方程的特定误差模式的阻尼来进行。\n\n设连续问题为带齐次狄利克雷边界条件的泊松方程：\n$$\n-\\Delta u = f \\quad \\text{in } \\Omega = (0,1) \\times (0,1)\n$$\n$$\nu = 0 \\quad \\text{on } \\partial\\Omega\n$$\n我们在具有 $N \\times N$ 个内部点的均匀网格上离散化此问题，其中 $N=32$。网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, N+1\\}$，网格间距 $h = 1/(N+1)$。内部点对应于索引 $i,j \\in \\{1, \\dots, N\\}$。在边界上（即 $i$ 或 $j$ 为 $0$ 或 $N+1$），值固定为 $u_{i,j}=0$。\n\n在内部网格点 $(i,j)$ 处，对负拉普拉斯算子 $-\\Delta$ 使用标准的5点有限差分格式，我们得到离散方程：\n$$\n\\frac{4 u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} = f_{i,j}\n$$\n其中 $f_{i,j} = f(x_i, y_j)$。这构成了一个大型稀疏线性方程组，$A \\mathbf{u} = \\mathbf{f}_h$。\n\n红黑高斯-赛德尔（RBGS）方法是求解该系统的一种迭代技术。它将网格点重新排序为两个集合：“红色”点（索引和 $(i+j)$ 为偶数）和“黑色”点（索引和 $(i+j)$ 为奇数）。单次RBGS扫描包括两个阶段：\n1.  首先，同时更新所有红色点的 $u_{i,j}$ 值。更新规则通过求解 $u_{i,j}$ 的格式方程得到：\n    $$\n    u_{i,j} \\leftarrow \\frac{1}{4} \\left( u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} + h^2 f_{i,j} \\right)\n    $$\n    关键在于，对于一个红色点，其所有四个邻点 $(i\\pm 1, j)$ 和 $(i, j\\pm 1)$ 都是黑色的。因此，所有红色点都可以使用其黑色邻点的当前值并行更新。\n2.  其次，同时更新所有黑色点的 $u_{i,j}$ 值。此更新使用相同的公式，但现在依赖于第一阶段中计算出的相邻红色点的新值。\n\n在多重网格的背景下，平滑器的目的是阻尼误差的高频分量。误差 $\\mathbf{e}^k = \\mathbf{u}^k - \\mathbf{u}^*$（其中 $\\mathbf{u}^*$ 是精确离散解）根据误差传播算子 $S$ 进行演化，即 $\\mathbf{e}^{k+1} = S \\mathbf{e}^k$。该算子独立于右端项向量 $\\mathbf{f}_h$。因此，我们可以通过设置 $\\mathbf{f}_h = \\mathbf{0}$ 并观察平滑器对初始误差场 $\\mathbf{e}^0$ 的作用来分析其性质。\n\n我们的任务是计算以下形式的特定初始误差模式的阻尼因子：\n$$\ne^0_{i,j} = \\cos(\\theta_x i) \\cos(\\theta_y j), \\quad \\text{for } i,j \\in \\{1, \\dots, N\\}\n$$\n参数 $(\\theta_x, \\theta_y)$ 决定了误差模式的频率。较小的值对应于低频（光滑）误差，而接近 $\\pi$ 的值对应于高频（振荡）误差。\n\n对初始误差场 $\\mathbf{e}^0$ 应用一次RBGS扫描（在 $\\mathbf{f}_h = \\mathbf{0}$ 的情况下）后，我们得到一个新的误差场 $\\mathbf{e}^1$。阻尼因子 $\\mu$ 定义为内部网格上结果误差场与初始误差场的欧几里得范数之比：\n$$\n\\mu(\\theta_x, \\theta_y) = \\frac{\\|\\mathbf{e}^1\\|_2}{\\|\\mathbf{e}^0\\|_2} = \\frac{\\sqrt{\\sum_{i=1}^N \\sum_{j=1}^N (e^1_{i,j})^2}}{\\sqrt{\\sum_{i=1}^N \\sum_{j=1}^N (e^0_{i,j})^2}}\n$$\n$\\mu  1$ 的值表示该误差分量被阻尼，值越小表示平滑效果越好。$\\mu \\approx 1$ 的值表示该模式的阻尼效果很差。\n\n为了进行数值实现，我们将使用一个 $(N+2) \\times (N+2)$ 的网格来自然地引入齐次狄利克雷边界条件。对于每个测试用例 $(\\theta_x, \\theta_y)$，其步骤如下：\n1.  初始化一个大小为 $(N+2) \\times (N+2)$ 的误差网格 $\\mathbf{e}^0$，所有元素为零。\n2.  对于 $i,j \\in \\{1,\\dots,N\\}$，使用指定的余弦公式填充内部点 $e^0_{i,j}$。\n3.  计算内部网格上初始范数 $\\|\\mathbf{e}^0\\|_2$。\n4.  对 $\\mathbf{e}^0$ 执行一次RBGS扫描以计算 $\\mathbf{e}^1$。这包括一次红色遍及，然后一次黑色遍及，并如上所述正确处理数据依赖关系。在此误差分析中，$h^2 f_{i,j}$ 项为零。\n5.  计算内部网格上最终范数 $\\|\\mathbf{e}^1\\|_2$。\n6.  计算比率 $\\mu = \\|\\mathbf{e}^1\\|_2 / \\|\\mathbf{e}^0\\|_2$。\n\n对三对指定的 $(\\theta_x, \\theta_y)$ 重复此过程，并报告所得的阻尼因子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_damping_factor(N, theta_x, theta_y):\n    \"\"\"\n    Calculates the damping factor of a single Red-Black Gauss-Seidel sweep\n    for a given error mode.\n\n    Args:\n        N (int): The number of interior grid points in one dimension.\n        theta_x (float): The frequency parameter for the x-direction of the error mode.\n        theta_y (float): The frequency parameter for the y-direction of the error mode.\n\n    Returns:\n        float: The damping factor mu = ||e^1||_2 / ||e^0||_2.\n    \"\"\"\n    # Grid setup including boundary layers\n    # Grid is (N+2)x(N+2). Interior is [1:N+1, 1:N+1].\n    e0 = np.zeros((N + 2, N + 2))\n\n    # Create grid indices for the interior\n    i_indices, j_indices = np.mgrid[1:N + 1, 1:N + 1]\n\n    # Initialize the interior of the grid with the specified error mode\n    e0[1:N + 1, 1:N + 1] = np.cos(theta_x * i_indices) * np.cos(theta_y * j_indices)\n\n    # Calculate the L2 norm of the initial error field over the interior\n    norm_e0 = np.linalg.norm(e0[1:N + 1, 1:N + 1])\n    \n    # If the initial norm is zero, the concept of a damping ratio is ill-defined.\n    # For the given test cases this will not happen.\n    if norm_e0 == 0:\n        return 1.0\n\n    # The grid that will be updated by the RBGS sweep\n    e1 = e0.copy()\n\n    # Create masks for red and black points in the interior\n    # Red points: (i+j) is even\n    # Black points: (i+j) is odd\n    red_mask = ((i_indices + j_indices) % 2) == 0\n    black_mask = ((i_indices + j_indices) % 2) == 1\n\n    # Get a view of the interior of the grid to be updated\n    e1_interior = e1[1:N + 1, 1:N + 1]\n\n    # --- RBGS Sweep (with f_h = 0) ---\n\n    # 1. Red Pass: Update all red points.\n    # The update for each red point depends only on its black neighbors.\n    # These updates can be computed simultaneously using the state before the sweep.\n    # We use slicing to get neighbor values.\n    # e1[i-1, j] - e1[0:N, 1:N+1]\n    # e1[i+1, j] - e1[2:N+2, 1:N+1]\n    # e1[i, j-1] - e1[1:N+1, 0:N]\n    # e1[i, j+1] - e1[1:N+1, 2:N+2]\n    neighbors_sum = (e1[0:N, 1:N+1] + e1[2:N+2, 1:N+1] +\n                     e1[1:N+1, 0:N] + e1[1:N+1, 2:N+2])\n    \n    # The update uses the average of the neighbors. Since f_h=0, there is no source term.\n    # Masked assignment updates only the red points.\n    e1_interior[red_mask] = 0.25 * neighbors_sum[red_mask]\n\n    # 2. Black Pass: Update all black points.\n    # The update for each black point depends on its red neighbors.\n    # We must use the *updated* values of the red neighbors from the previous pass.\n    # By re-calculating the sum of neighbors now, we are implicitly using the\n    # updated values for red points stored in e1.\n    neighbors_sum = (e1[0:N, 1:N+1] + e1[2:N+2, 1:N+1] +\n                     e1[1:N+1, 0:N] + e1[1:N+1, 2:N+2])\n                     \n    # Masked assignment updates only the black points.\n    e1_interior[black_mask] = 0.25 * neighbors_sum[black_mask]\n\n    # --- End of RBGS Sweep ---\n\n    # Calculate the L2 norm of the final error field over the interior\n    norm_e1 = np.linalg.norm(e1_interior)\n\n    # Return the damping factor\n    return norm_e1 / norm_e0\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the problem parameters and test cases.\n    N = 32\n    test_cases = [\n        # Case 1: High-frequency mode\n        (np.pi / 2, np.pi / 2),\n        # Case 2: Highest frequency (checkerboard) mode\n        (np.pi, np.pi),\n        # Case 3: Low-frequency mode\n        (np.pi / 16, np.pi / 16),\n    ]\n\n    results = []\n    for theta_x, theta_y in test_cases:\n        damping_factor = calculate_damping_factor(N, theta_x, theta_y)\n        results.append(damping_factor)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3347195"}, {"introduction": "计算流体力学中的许多问题，例如带有纯诺伊曼（Neumann）边界条件的压力泊松方程，会导致奇异线性系统。本练习要求您为此类问题构建一个完整的V-cycle，并揭示在粗网格上正确处理算子零空间（nullspace）的至关重要性[@problem_id:3347220]。通过比较一个“尊重”零空间的求解器和一个不尊重零空间的求解器，您将亲眼看到为何这个细节对收敛性至关重要。", "problem": "考虑一维压力泊松子问题，该问题带有齐次诺伊曼边界条件，是计算流体动力学中的一个典型子问题。其连续模型是定义在闭区间 $[0,1]$ 上的拉普拉斯方程，其中 $u(x)$ 满足\n$$\n\\frac{d^2 u}{dx^2} = f(x), \\quad \\frac{du}{dx}(0) = 0, \\quad \\frac{du}{dx}(1) = 0,\n$$\n其中源项 $f(x)$ 在 $[0,1]$ 上的积分为零。该积分约束是问题可解的充分必要条件，并表明诺伊曼拉普拉斯算子存在一个常数零空间。\n\n使用 $n$ 个等距网格点 $\\{x_i\\}_{i=0}^{n-1}$（其中 $x_i = i/(n-1)$）对区间 $[0,1]$ 进行离散化，并采用标准二阶有限差分格式，在端点处通过单边差分来施加齐次诺伊曼边界条件。由此得到的离散算子 $\\mathbf{A} \\in \\mathbb{R}^{n \\times n}$ 是对称半正定的一维诺伊曼拉普拉斯算子，其分量定义如下\n$$\n\\mathbf{A}_{0,0} = 1, \\quad \\mathbf{A}_{0,1} = -1,\n$$\n$$\n\\mathbf{A}_{i,i-1} = -1, \\quad \\mathbf{A}_{i,i} = 2, \\quad \\mathbf{A}_{i,i+1} = -1 \\quad \\text{for} \\quad i = 1,2,\\dots,n-2,\n$$\n$$\n\\mathbf{A}_{n-1,n-2} = -1, \\quad \\mathbf{A}_{n-1,n-1} = 1,\n$$\n所有其他元素均为零。常数向量 $\\mathbf{1} = [1,1,\\dots,1]^\\top$ 满足 $\\mathbf{A}\\mathbf{1} = \\mathbf{0}$，并张成其零空间。一个相容的右端向量 $\\mathbf{b} \\in \\mathbb{R}^n$ 必须满足 $\\sum_{i=0}^{n-1} b_i = 0$，否则该线性系统是不相容的。\n\n定义一个标准的几何两层多重网格 V 循环，从初始猜测 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 开始近似求解 $\\mathbf{A}\\mathbf{u} = \\mathbf{b}$，该循环使用以下组件：\n- 权重为 $\\omega \\in (0,1)$ 的加权 Jacobi 光滑子，进行 $\\nu_{\\mathrm{pre}}$ 次预光滑扫描和 $\\nu_{\\mathrm{post}}$ 次后光滑扫描：\n$$\n\\mathbf{u} \\leftarrow \\mathbf{u} + \\omega \\mathbf{D}^{-1}(\\mathbf{b}-\\mathbf{A}\\mathbf{u}),\n$$\n其中 $\\mathbf{D} = \\mathrm{diag}(\\mathbf{A})$。\n- 从尺寸为 $n_c$ 的粗网格到尺寸为 $n_f$ 的细网格的线性插值延长算子 $\\mathbf{P} \\in \\mathbb{R}^{n_f \\times n_c}$，其中 $n_f = 2 n_c - 1$，定义如下：\n  - 对于粗网格索引 $j=0,1,\\dots,n_c-1$，令其对应的细网格偶数索引为 $i=2j$。则设置\n  $$\n  P_{i,j} = 1.\n  $$\n  - 对于细网格奇数索引 $i=1,3,\\dots,n_f-2$，定义\n  $$\n  P_{i,\\lfloor i/2 \\rfloor} = \\tfrac{1}{2}, \\quad P_{i,\\lfloor i/2 \\rfloor + 1} = \\tfrac{1}{2}.\n  $$\n- 从细网格到粗网格的全加权限制算子 $\\mathbf{R} \\in \\mathbb{R}^{n_c \\times n_f}$，对于 $j=0,1,\\dots,n_c-1$ 及其对应的细网格偶数索引 $i=2j$，定义如下：\n  - 在左边界 $j=0$ 处：\n  $$\n  R_{0,0} = \\tfrac{1}{2}, \\quad R_{0,1} = \\tfrac{1}{2}.\n  $$\n  - 在内部粗网格索引 $j=1,2,\\dots,n_c-2$ 处：\n  $$\n  R_{j,i-1} = \\tfrac{1}{4}, \\quad R_{j,i} = \\tfrac{1}{2}, \\quad R_{j,i+1} = \\tfrac{1}{4}.\n  $$\n  - 在右边界 $j=n_c-1$ 处：\n  $$\n  R_{n_c-1,n_f-2} = \\tfrac{1}{2}, \\quad R_{n_c-1,n_f-1} = \\tfrac{1}{2}.\n  $$\n- Galerkin 粗网格算子：\n$$\n\\mathbf{A}_c = \\mathbf{R}\\mathbf{A}_f\\mathbf{P},\n$$\n其中 $\\mathbf{A}_f$ 是细网格算子。注意 $\\mathbf{A}_c$ 是奇异的，且具有相同的常数零空间。\n\n为残差方程 $\\mathbf{A}_c \\mathbf{e}_c = \\mathbf{r}_c$ 定义两种粗网格求解器：\n- 一种尊重零空间的粗网格求解器，它首先将粗网格残差投影到 $\\mathbf{A}_c$ 的值域中，然后返回一个与零空间正交的粗网格校正量，从而强制施加零均值约束：\n$$\n\\mathbf{r}_c \\leftarrow \\mathbf{r}_c - \\left(\\frac{1}{n_c}\\sum_{j=0}^{n_c-1} (\\mathbf{r}_c)_j \\right)\\mathbf{1}, \\quad \\mathbf{e}_c = \\mathbf{A}_c^{\\dagger}\\mathbf{r}_c, \\quad \\mathbf{e}_c \\leftarrow \\mathbf{e}_c - \\left(\\frac{1}{n_c}\\sum_{j=0}^{n_c-1} (\\mathbf{e}_c)_j \\right)\\mathbf{1},\n$$\n其中 $\\mathbf{A}_c^{\\dagger}$ 表示 Moore–Penrose 伪逆。\n- 一种失效的粗网格求解器，它使用 Moore–Penrose 伪逆但不对零空间进行补偿，即\n$$\n\\mathbf{e}_c = \\mathbf{A}_c^{\\dagger}\\mathbf{r}_c,\n$$\n不对 $\\mathbf{r}_c$ 或 $\\mathbf{e}_c$ 进行到零均值子空间的投影。\n\n考虑在尺寸为 $n_f$ 的细网格上进行单次 V 循环更新，从初始迭代向量 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 开始，依次执行预光滑、残差限制和粗网格求解、延长和校正量相加，以及后光滑。令 $\\mathbf{u}^{\\star}$ 表示 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$ 的精确离散零均值解，该解被选择以满足 $\\sum_i u_i^{\\star} = 0$。定义一次 V 循环后的误差缩减因子为\n$$\n\\rho = \\frac{\\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(1)}\\|_2}{\\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(0)}\\|_2} = \\frac{\\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(1)}\\|_2}{\\|\\mathbf{u}^{\\star}\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 表示欧几里得范数。\n\n实现一个程序，构建上述算子，并对两种粗网格求解器（尊重零空间的和失效的）分别执行一次 V 循环，计算相应的误差缩减因子 $\\rho_{\\mathrm{respect}}$ 和 $\\rho_{\\mathrm{fail}}$。\n\n使用以下参数值和右端项的测试套件：\n- 测试用例 1（理想情况）：$n_f=9$，$\\omega=2/3$，$\\nu_{\\mathrm{pre}}=2$，$\\nu_{\\mathrm{post}}=2$，以及 $b_i = \\sin(2\\pi x_i)$，对于 $i=0,1,\\dots,n_f-1$。\n- 测试用例 2（极小粗网格）：$n_f=5$，$\\omega=2/3$，$\\nu_{\\mathrm{pre}}=1$，$\\nu_{\\mathrm{post}}=1$，以及 $b_i = \\sin(2\\pi x_i)$，对于 $i=0,1,\\dots,n_f-1$。\n- 测试用例 3（低频源项）：$n_f=7$，$\\omega=0.7$，$\\nu_{\\mathrm{pre}}=3$，$\\nu_{\\mathrm{post}}=3$，以及 $b_i = \\cos(\\pi x_i) - \\frac{1}{n_f}\\sum_{k=0}^{n_f-1}\\cos(\\pi x_k)$，对于 $i=0,1,\\dots,n_f-1$。\n\n对于每个测试用例，从 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 开始，经过一次 V 循环后，计算浮点数对 $[\\rho_{\\mathrm{respect}}, \\rho_{\\mathrm{fail}}]$。你的程序应生成单行输出，其中包含结果。结果应为逗号分隔的列表，用方括号括起来，并为三个测试用例包含嵌套列表，格式完全如下\n$$\n[[\\rho_{\\mathrm{respect}}^{(1)},\\rho_{\\mathrm{fail}}^{(1)}],[\\rho_{\\mathrm{respect}}^{(2)},\\rho_{\\mathrm{fail}}^{(2)}],[\\rho_{\\mathrm{respect}}^{(3)},\\rho_{\\mathrm{fail}}^{(3)}]],\n$$\n其中上标表示测试用例的索引。不涉及物理单位、角度或百分比；所有输出均为无量纲浮点数。", "solution": "我们从具有齐次诺伊曼边界条件的拉普拉斯算子的基本性质开始，该算子自然地出现在计算流体动力学的压力修正步骤中。由于边界通量为零且区域没有狄利克雷锚定，该连续算子具有一个常数零空间；从物理上讲，给压力增加一个常数并不会改变速度场。使用在端点处实现齐次诺伊曼条件的二阶有限差分进行离散化，会得到一个对称半正定矩阵 $\\mathbf{A}$，其行和为零，且常数向量 $\\mathbf{1}$ 位于其零空间中。因此，为了使 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$ 可解，离散源项必须满足相容性条件 $\\sum_i b_i = 0$。\n\n多重网格方法处理跨尺度的误差光滑和粗网格校正问题。V 循环包括在细网格上的光滑步骤、将剩余误差（残差）限制到粗网格、求解或近似求解粗网格问题、将校正量延长到细网格层面，以及后光滑步骤。对于使用对角矩阵 $\\mathbf{D}$ 的加权 Jacobi 法，一次扫描通过 $\\mathbf{u} \\leftarrow \\mathbf{u} + \\omega \\mathbf{D}^{-1}(\\mathbf{b}-\\mathbf{A}\\mathbf{u})$ 更新迭代向量。加权 Jacobi 法能有效衰减高频误差分量。\n\n网格间传递算子的选择必须尊重几何形状和边界条件。线性插值延长算子 $\\mathbf{P}$ 将粗网格上的项映射到细网格，方法是在偶数索引处进行精确注入，并通过平均来推断奇数索引处的值。全加权限制算子 $\\mathbf{R}$ 通过与模板一致的局部平均将细网格向量映射到粗网格向量；在边界处，权重会进行调整以考虑缺失的邻点。Galerkin 粗网格算子为 $\\mathbf{A}_c = \\mathbf{R}\\mathbf{A}_f\\mathbf{P}$，它继承了对称性和零空间。具体来说，粗网格上的常数向量位于其零空间中，因此 $\\mathbf{A}_c$ 是奇异的。\n\n对于诺伊曼问题，一个微妙但关键的点是在粗网格层面上对零空间的处理。残差方程 $\\mathbf{A}_c \\mathbf{e}_c = \\mathbf{r}_c$ 有解的充分必要条件是 $\\sum_j (\\mathbf{r}_c)_j = 0$（因为 $\\mathbf{A}_c$ 的值域由和为零的向量组成）。即使细网格残差 $\\mathbf{r}_f$ 的和为零——对于任何细网格迭代向量都是如此，因为根据行和为零的性质，$\\sum_i (\\mathbf{A}_f \\mathbf{u})_i = \\sum_i \\sum_k A_{ik} u_k = \\sum_k \\left(\\sum_i A_{ik}\\right) u_k = 0$，因此 $\\sum_i r_i = \\sum_i b_i = 0$——限制算子的选择也可能产生一个不能保持精确零和的粗网格残差 $\\mathbf{r}_c$。全加权在局部是守恒的，但在全局上，权重总和是变化的，除非限制算子经过特殊设计以保持均值，否则 $\\sum_j (\\mathbf{r}_c)_j$ 不必为零。\n\n如果粗网格求解忽略了零空间约束，并试图直接使用伪逆求解，它将计算出一个包含沿零空间的任意分量的最小二乘校正量。在粗网格上，解是不唯一的：因为 $\\mathbf{A}_c \\mathbf{1} = \\mathbf{0}$，将常数向量的任何倍数加到 $\\mathbf{e}_c$ 上都会得到另一个解。延长这样的校正量会在细网格上引入一个虚假的常数模态。加权 Jacobi 法和细网格算子无法移除常数模态误差，因为它位于 $\\mathbf{A}_f$ 的零空间中；因此，V 循环将无法减小该分量，从而增大了误差缩减因子。\n\n为了量化这种效应，我们计算从 $\\mathbf{u}^{(0)}=\\mathbf{0}$ 开始，经过一次 V 循环后的误差缩减因子 $\\rho = \\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(1)}\\|_2 / \\|\\mathbf{u}^{\\star}\\|_2$。此处 $\\mathbf{u}^{\\star}$ 是通过固定规范 $\\sum_i u_i^{\\star}=0$ 选择的精确离散零均值解，可以通过数值方法，即使用 Moore–Penrose 伪逆求解后减去均值来构造：\n$$\n\\mathbf{u}^{\\star} = \\mathbf{A}^{\\dagger}\\mathbf{b} - \\left(\\frac{1}{n}\\sum_{i=0}^{n-1} (\\mathbf{A}^{\\dagger}\\mathbf{b})_i\\right)\\mathbf{1}.\n$$\n这会产生一个代表解，该解属于因相差一个常数而构成的解的等价类中。\n\nV 循环算法如下：\n1. 预光滑：对 $\\mathbf{u}$ 应用 $\\nu_{\\mathrm{pre}}$ 次加权 Jacobi 扫描。\n2. 计算细网格残差 $\\mathbf{r}_f = \\mathbf{b} - \\mathbf{A}_f \\mathbf{u}$。\n3. 将残差限制到粗网格 $\\mathbf{r}_c = \\mathbf{R}\\mathbf{r}_f$。\n4. 粗网格求解：二选一\n   - 尊重零空间：通过 $\\mathbf{r}_c \\leftarrow \\mathbf{r}_c - \\left(\\frac{1}{n_c}\\sum_j (\\mathbf{r}_c)_j\\right)\\mathbf{1}$ 强制残差为零均值，求解 $\\mathbf{e}_c = \\mathbf{A}_c^{\\dagger}\\mathbf{r}_c$，并通过 $\\mathbf{e}_c \\leftarrow \\mathbf{e}_c - \\left(\\frac{1}{n_c}\\sum_j (\\mathbf{e}_c)_j\\right)\\mathbf{1}$ 强制校正量为零均值。\n   - 失效的：计算 $\\mathbf{e}_c = \\mathbf{A}_c^{\\dagger}\\mathbf{r}_c$，不进行任何投影。\n5. 延长校正量：$\\mathbf{e}_f = \\mathbf{P}\\mathbf{e}_c$。\n6. 更新细网格解：$\\mathbf{u} \\leftarrow \\mathbf{u} + \\mathbf{e}_f$。\n7. 后光滑：对 $\\mathbf{u}$ 应用 $\\nu_{\\mathrm{post}}$ 次加权 Jacobi 扫描。\n\n在这两种情况下，粗网格算子都是奇异的，但尊重零空间的求解器明确地从粗网格残差和校正量中移除了有问题的常数分量，确保校正量位于 $\\mathbf{A}_c$ 可逆的那个适当子空间中。失效的求解器保留了常数分量，而延长操作引入了一个无法通过后续光滑步骤减小的误差分量。因此，对于相容的源项和给定的传递算子，我们预期 $\\rho_{\\mathrm{respect}}  \\rho_{\\mathrm{fail}}$。\n\n我们测试三种场景：\n- 测试用例 1：$n_f=9$ 且 $b_i=\\sin(2\\pi x_i)$。这是一个典型的光滑零均值源项，用于检验内部行为。\n- 测试用例 2：$n_f=5$，用以强调在粗网格非常小的情况下的效应。\n- 测试用例 3：$n_f=7$ 且源项为低频的 $b_i = \\cos(\\pi x_i) - \\text{mean}$，这会产生一个强烈投影到最低频误差分量上的源项；在这种情况下，失效的求解器特别有害。\n\n对于每种情况，我们通过伪逆和均值减法计算精确的零均值解，对两种粗网格求解器变体执行一次 V 循环，并计算\n$$\n\\rho_{\\mathrm{respect}} = \\frac{\\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(1)}_{\\mathrm{respect}}\\|_2}{\\|\\mathbf{u}^{\\star}\\|_2}, \\quad \\rho_{\\mathrm{fail}} = \\frac{\\|\\mathbf{u}^{\\star}-\\mathbf{u}^{(1)}_{\\mathrm{fail}}\\|_2}{\\|\\mathbf{u}^{\\star}\\|_2}.\n$$\n然后我们将输出汇总为\n$$\n[[\\rho_{\\mathrm{respect}}^{(1)},\\rho_{\\mathrm{fail}}^{(1)}],[\\rho_{\\mathrm{respect}}^{(2)},\\rho_{\\mathrm{fail}}^{(2)}],[\\rho_{\\mathrm{respect}}^{(3)},\\rho_{\\mathrm{fail}}^{(3)}]].\n$$\n这直接展示了在计算流体动力学的离散诺伊曼问题中，不当处理粗网格零空间对多重网格 V 循环收敛性的影响。该程序显式地构建所有算子，并仅使用所述操作，从而确保可复现性并遵守指定的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef neumann_laplacian_1d(n: int) - np.ndarray:\n    \"\"\"\n    Construct the 1D Neumann Laplacian (positive semidefinite) with n grid points.\n    A[0,0]=1, A[0,1]=-1; interior i: A[i,i]=2, A[i,i-1]=-1, A[i,i+1]=-1; A[n-1,n-2]=-1, A[n-1,n-1]=1\n    \"\"\"\n    A = np.zeros((n, n), dtype=float)\n    if n == 1:\n        # Degenerate single-point case: purely nullspace; not used in tests.\n        A[0, 0] = 0.0\n        return A\n    # Left boundary\n    A[0, 0] = 1.0\n    A[0, 1] = -1.0\n    # Interior\n    for i in range(1, n - 1):\n        A[i, i] = 2.0\n        A[i, i - 1] = -1.0\n        A[i, i + 1] = -1.0\n    # Right boundary\n    A[n - 1, n - 1] = 1.0\n    A[n - 1, n - 2] = -1.0\n    return A\n\ndef prolongation_linear(n_coarse: int, n_fine: int) - np.ndarray:\n    \"\"\"\n    Linear interpolation prolongation from coarse to fine for 1D grids with n_fine = 2*n_coarse - 1.\n    \"\"\"\n    assert n_fine == 2 * n_coarse - 1, \"Fine size must be 2*n_coarse - 1\"\n    P = np.zeros((n_fine, n_coarse), dtype=float)\n    # Injection at even indices\n    for j in range(n_coarse):\n        i_even = 2 * j\n        P[i_even, j] = 1.0\n    # Averaging for odd indices\n    for i in range(1, n_fine, 2):\n        j_left = (i - 1) // 2\n        j_right = j_left + 1\n        P[i, j_left] = 0.5\n        if j_right  n_coarse:\n            P[i, j_right] = 0.5\n    return P\n\ndef restriction_full_weighting(n_fine: int, n_coarse: int) - np.ndarray:\n    \"\"\"\n    Full-weighting restriction from fine to coarse for 1D grids with n_fine = 2*n_coarse - 1.\n    Boundary rows use 0.5 weights, interior rows use [0.25, 0.5, 0.25] centered on even fine indices.\n    \"\"\"\n    assert n_fine == 2 * n_coarse - 1, \"Fine size must be 2*n_coarse - 1\"\n    R = np.zeros((n_coarse, n_fine), dtype=float)\n    for j in range(n_coarse):\n        i_even = 2 * j\n        if i_even == 0:\n            R[j, 0] = 0.5\n            if n_fine > 1:\n                R[j, 1] = 0.5\n        elif i_even == n_fine - 1:\n            R[j, n_fine - 2] = 0.5\n            R[j, n_fine - 1] = 0.5\n        else:\n            R[j, i_even - 1] = 0.25\n            R[j, i_even] = 0.5\n            R[j, i_even + 1] = 0.25\n    return R\n\ndef weighted_jacobi(A: np.ndarray, b: np.ndarray, u: np.ndarray, omega: float, sweeps: int) - np.ndarray:\n    \"\"\"\n    Perform 'sweeps' iterations of weighted Jacobi on Au = b with weight omega.\n    \"\"\"\n    D = np.diag(A)\n    # Avoid division by zero: for Neumann Laplacian, diagonals are positive (1 at boundaries, 2 interior)\n    invD = 1.0 / D\n    for _ in range(sweeps):\n        r = b - A @ u\n        u = u + omega * (invD * r)\n    return u\n\ndef zero_mean(vec: np.ndarray) - np.ndarray:\n    \"\"\"\n    Project a vector onto the zero-mean subspace.\n    \"\"\"\n    return vec - np.mean(vec)\n\ndef exact_zero_mean_solution(A: np.ndarray, b: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute a representative exact solution with zero mean using pseudoinverse and mean subtraction.\n    Assumes b is compatible with A (sum(b) ~ 0).\n    \"\"\"\n    u = np.linalg.pinv(A) @ b\n    u = zero_mean(u)\n    return u\n\ndef v_cycle_one(A_f: np.ndarray, R: np.ndarray, P: np.ndarray,\n                b_f: np.ndarray, omega: float, nu_pre: int, nu_post: int,\n                respect_nullspace: bool) - np.ndarray:\n    \"\"\"\n    Perform a single two-level V-cycle on fine grid.\n    \"\"\"\n    n_f = A_f.shape[0]\n    # Pre-smoothing\n    u = np.zeros(n_f, dtype=float)\n    u = weighted_jacobi(A_f, b_f, u, omega, nu_pre)\n    # Fine residual\n    r_f = b_f - A_f @ u\n    # Restrict to coarse\n    r_c = R @ r_f\n    # Build coarse operator\n    A_c = R @ A_f @ P\n    # Coarse solve\n    if respect_nullspace:\n        # Enforce zero-mean on coarse residual\n        r_c = zero_mean(r_c)\n        e_c = np.linalg.pinv(A_c) @ r_c\n        # Remove coarse nullspace component from correction\n        e_c = zero_mean(e_c)\n    else:\n        e_c = np.linalg.pinv(A_c) @ r_c\n        # No nullspace handling: potentially inject constant modes\n    # Prolongate and correct\n    e_f = P @ e_c\n    u = u + e_f\n    # Post-smoothing\n    u = weighted_jacobi(A_f, b_f, u, omega, nu_post)\n    return u\n\ndef build_rhs_sine(n: int) - np.ndarray:\n    \"\"\"\n    Build b_i = sin(2*pi*x_i) with x_i = i/(n-1). This RHS has mean zero.\n    \"\"\"\n    x = np.linspace(0.0, 1.0, n)\n    b = np.sin(2.0 * np.pi * x)\n    # Numerical rounding might cause tiny residual mean; enforce exact zero mean.\n    b = zero_mean(b)\n    return b\n\ndef build_rhs_cos_pi_minus_mean(n: int) - np.ndarray:\n    \"\"\"\n    Build b_i = cos(pi*x_i) - mean(cos(pi*x_i)), enforcing zero mean.\n    \"\"\"\n    x = np.linspace(0.0, 1.0, n)\n    c = np.cos(np.pi * x)\n    b = c - np.mean(c)\n    return b\n\ndef error_reduction_factors(n_f: int, omega: float, nu_pre: int, nu_post: int, b: np.ndarray) - list:\n    \"\"\"\n    Compute [rho_respect, rho_fail] for one V-cycle with the given parameters and RHS.\n    \"\"\"\n    # Fine operator\n    A_f = neumann_laplacian_1d(n_f)\n    # Coarse grid size: n_c = (n_f + 1)//2\n    n_c = (n_f + 1) // 2\n    # Transfers\n    P = prolongation_linear(n_c, n_f)\n    R = restriction_full_weighting(n_f, n_c)\n    # Exact zero-mean solution\n    u_star = exact_zero_mean_solution(A_f, b)\n    norm0 = np.linalg.norm(u_star)\n    # Respecting nullspace\n    u1_respect = v_cycle_one(A_f, R, P, b, omega, nu_pre, nu_post, respect_nullspace=True)\n    rho_respect = np.linalg.norm(u_star - u1_respect) / (norm0 if norm0 != 0.0 else 1.0)\n    # Failing nullspace handling\n    u1_fail = v_cycle_one(A_f, R, P, b, omega, nu_pre, nu_post, respect_nullspace=False)\n    rho_fail = np.linalg.norm(u_star - u1_fail) / (norm0 if norm0 != 0.0 else 1.0)\n    return [rho_respect, rho_fail]\n\ndef format_nested_list(lst):\n    \"\"\"\n    Format nested list of floats without spaces, with reasonable precision.\n    \"\"\"\n    if isinstance(lst, list):\n        return '[' + ','.join(format_nested_list(x) for x in lst) + ']'\n    elif isinstance(lst, float):\n        # Use 12 significant digits to be concise yet precise\n        return f\"{lst:.12g}\"\n    else:\n        return str(lst)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (n_f, omega, nu_pre, nu_post, rhs_builder)\n    test_cases = [\n        (9, 2.0/3.0, 2, 2, build_rhs_sine),          # Test case 1 (happy path)\n        (5, 2.0/3.0, 1, 1, build_rhs_sine),          # Test case 2 (small coarse grid)\n        (7, 0.7,      3, 3, build_rhs_cos_pi_minus_mean),  # Test case 3 (low-frequency source)\n    ]\n\n    results = []\n    for n_f, omega, nu_pre, nu_post, rhs_builder in test_cases:\n        b = rhs_builder(n_f)\n        pair = error_reduction_factors(n_f, omega, nu_pre, nu_post, b)\n        results.append(pair)\n\n    # Final print statement in the exact required format.\n    print(format_nested_list(results))\n\nsolve()\n```", "id": "3347220"}]}