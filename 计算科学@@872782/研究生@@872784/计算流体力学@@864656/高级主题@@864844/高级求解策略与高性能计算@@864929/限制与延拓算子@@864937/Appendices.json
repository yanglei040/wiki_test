{"hands_on_practices": [{"introduction": "要理解多重网格方法，首先需要掌握在网格之间传递信息的算子。第一个练习将聚焦于 prolongation（延拓）算子，通过回归多项式插值的基本原理来揭示其本质 [@problem_id:3357474]。通过推导一维和二维情况下的算子并分析其误差，你将对其局部精度有一个具体的认识，而局部精度是决定整个多重网格循环效率的关键属性。", "problem": "考虑一维空间中的一个均匀粗网格，其节点间距为 $H$，节点横坐标为 $x_i = i H$，其中 $i \\in \\mathbb{Z}$。令 $u^H_i$ 表示对一个足够光滑的标量场 $u(x)$ 的粗网格近似，该标量场是计算流体动力学 (CFD) 中出现的一个场变量。定义一个间距为 $h = H/2$ 的细网格，其节点包括 $x_i$、$x_i + H/2$ 和 $x_{i+1} = x_i + H$。\n\n(a) 仅使用插值的基本定义，即插值是选定多项式空间中与插值点数据相匹配的唯一元素，推导一维延拓算子。该算子在每个粗网格单元 $[x_i, x_{i+1}]$ 上插值是线性的要求下，将粗网格节点值 $\\{u^H_i, u^H_{i+1}\\}$ 映射到细网格点 $\\{x_i, x_i + H/2, x_{i+1}\\}$ 上的值。写出这三个细网格点的点映射结果，并用 $\\{u^H_i, u^H_{i+1}\\}$ 表示。\n\n(b) 现在考虑一个二维空间中的均匀粗网格，其粗网格节点位于 $(x,y) \\in \\{0,H\\} \\times \\{0,H\\}$，标量场仍为 $u(x,y)$。通过取 (a) 部分中推导的一维线性插值的张量积，构建粗网格单元 $[0,H] \\times [0,H]$ 上的双线性延拓算子。计算在单元中心 $(H/2,H/2)$ 处的双线性延拓值，并用角点值 $\\{u^H(0,0), u^H(H,0), u^H(0,H), u^H(H,H)\\}$ 表示。\n\n(c) 为了通过多项式精确性检验来评估精度阶，设 $f(x,y) = a x^2 + b y^2 + c x y + d x + e y + g$ 是一个二次多项式，其中 $a$, $b$, $c$, $d$, $e$ 和 $g$ 是常数。使用 (b) 部分得到的双线性延拓，计算单元中心的插值误差，定义为\n$$\nE_{\\mathrm{center}} = f\\!\\left(\\frac{H}{2},\\frac{H}{2}\\right) - I\\!\\left(\\frac{H}{2},\\frac{H}{2}\\right),\n$$\n其中 $I(x,y)$ 是由粗网格角点值 $\\{f(0,0), f(H,0), f(0,H), f(H,H)\\}$ 构建的双线性插值函数。以 $a$、$b$ 和 $H$ 的单一闭式解析表达式给出最终答案。不要使用大$\\mathcal{O}$符号，也不需要四舍五入。", "solution": "我们从给定单元上插值的基本定义开始：插值函数是在指定的多项式空间中与插值点上的已知数据相匹配的唯一成员。在一维空间中，该空间是每个粗网格单元上次数最多为1的多项式集合；在二维空间中，该空间是这些一维空间的张量积，即双线性多项式集合。\n\n(a) 部分。粗网格单元 $[x_i,x_{i+1}]$ 上的一维线性延拓。\n\n在 $[x_i,x_{i+1}]$（其中 $x_{i+1} = x_i + H$）上，一维线性插值函数由拉格朗日基函数\n$$\nN_0(x) = \\frac{x_{i+1} - x}{H}, \\qquad N_1(x) = \\frac{x - x_i}{H},\n$$\n表征，这些基函数满足 $N_0(x_i) = 1$、$N_0(x_{i+1}) = 0$、$N_1(x_i) = 0$ 和 $N_1(x_{i+1}) = 1$。给定粗网格节点值 $u^H_i \\approx u(x_i)$ 和 $u^H_{i+1} \\approx u(x_{i+1})$，线性插值函数为\n$$\nI(x) = u^H_i \\, N_0(x) + u^H_{i+1} \\, N_1(x).\n$$\n在单元中的三个细网格点处求值：\n- 在 $x = x_i$ 处，\n$$\nI(x_i) = u^H_i \\, N_0(x_i) + u^H_{i+1} \\, N_1(x_i) = u^H_i.\n$$\n- 在 $x = x_i + H/2$ 处，\n$$\nN_0\\!\\left(x_i + \\frac{H}{2}\\right) = \\frac{x_{i+1} - (x_i + H/2)}{H} = \\frac{H/2}{H} = \\frac{1}{2}, \\quad\nN_1\\!\\left(x_i + \\frac{H}{2}\\right) = \\frac{(x_i + H/2) - x_i}{H} = \\frac{1}{2},\n$$\n所以\n$$\nI\\!\\left(x_i + \\frac{H}{2}\\right) = \\frac{1}{2} u^H_i + \\frac{1}{2} u^H_{i+1}.\n$$\n- 在 $x = x_{i+1}$ 处，\n$$\nI(x_{i+1}) = u^H_{i+1}.\n$$\n因此，从单元中粗网格节点到细网格节点的一维延拓映射为\n$$\n\\bigl(u^H_i, u^H_{i+1}\\bigr) \\mapsto \\left( u^H_i,\\ \\frac{u^H_i + u^H_{i+1}}{2},\\ u^H_{i+1} \\right).\n$$\n\n(b) 部分。作为张量积的二维双线性延拓及在单元中心的求值。\n\n在粗网格单元 $[0,H] \\times [0,H]$ 上，取 $x$ 和 $y$ 方向上的一维基：\n$$\nN_0(x) = \\frac{H - x}{H}, \\quad N_1(x) = \\frac{x}{H}, \\qquad\nM_0(y) = \\frac{H - y}{H}, \\quad M_1(y) = \\frac{y}{H}.\n$$\n单元角点上的双线性基为 $\\{ \\phi_{pq}(x,y) = N_p(x) M_q(y) \\}_{p,q \\in \\{0,1\\}}$，因此给定角点值\n$$\nu^H_{00} = u^H(0,0), \\quad u^H_{10} = u^H(H,0), \\quad u^H_{01} = u^H(0,H), \\quad u^H_{11} = u^H(H,H),\n$$\n双线性插值函数为\n$$\nI(x,y) = u^H_{00} \\, N_0(x) M_0(y) + u^H_{10} \\, N_1(x) M_0(y) + u^H_{01} \\, N_0(x) M_1(y) + u^H_{11} \\, N_1(x) M_1(y).\n$$\n在中心点 $(H/2,H/2)$ 处，有\n$$\nN_0\\!\\left(\\frac{H}{2}\\right) = N_1\\!\\left(\\frac{H}{2}\\right) = \\frac{1}{2}, \\qquad\nM_0\\!\\left(\\frac{H}{2}\\right) = M_1\\!\\left(\\frac{H}{2}\\right) = \\frac{1}{2}.\n$$\n因此，\n$$\nI\\!\\left(\\frac{H}{2},\\frac{H}{2}\\right) = \\sum_{p=0}^{1} \\sum_{q=0}^{1} u^H_{pq} \\, \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{1}{4} \\left( u^H_{00} + u^H_{10} + u^H_{01} + u^H_{11} \\right).\n$$\n\n(c) 部分。二次多项式在中心的插值误差及精度阶评估。\n\n令 $f(x,y) = a x^2 + b y^2 + c x y + d x + e y + g$。在四个角点处计算 $f$ 的值：\n- 在 $(0,0)$ 处：\n$$\nf(0,0) = g.\n$$\n- 在 $(H,0)$ 处：\n$$\nf(H,0) = a H^2 + d H + g.\n$$\n- 在 $(0,H)$ 处：\n$$\nf(0,H) = b H^2 + e H + g.\n$$\n- 在 $(H,H)$ 处：\n$$\nf(H,H) = a H^2 + b H^2 + c H^2 + d H + e H + g = (a + b + c) H^2 + d H + e H + g.\n$$\n因此，使用 (b) 部分的结果，中心点处的双线性延拓值为\n$$\nI\\!\\left(\\frac{H}{2},\\frac{H}{2}\\right) = \\frac{1}{4} \\left[ g + (a H^2 + d H + g) + (b H^2 + e H + g) + \\bigl( (a+b+c) H^2 + d H + e H + g \\bigr) \\right].\n$$\n合并同类项：\n- 常数项：$g + g + g + g = 4 g$ 给出 $\\frac{1}{4} \\cdot 4 g = g$。\n- 与 $H$ 成正比的项：$d H + d H = 2 d H$ 和 $e H + e H = 2 e H$ 给出 $\\frac{1}{4} (2 d H + 2 e H) = \\frac{d+e}{2} H$。\n- 与 $H^2$ 成正比的项：$a H^2 + b H^2 + (a+b+c) H^2 = (2 a + 2 b + c) H^2$ 给出 $\\frac{1}{4} (2 a + 2 b + c) H^2$。\n\n因此，\n$$\nI\\!\\left(\\frac{H}{2},\\frac{H}{2}\\right) = g + \\frac{d+e}{2} H + \\frac{2 a + 2 b + c}{4} H^2.\n$$\n计算 $f$ 在中心点的精确值：\n$$\nf\\!\\left(\\frac{H}{2},\\frac{H}{2}\\right) = a \\left(\\frac{H}{2}\\right)^{2} + b \\left(\\frac{H}{2}\\right)^{2} + c \\left(\\frac{H}{2}\\right)\\left(\\frac{H}{2}\\right) + d \\left(\\frac{H}{2}\\right) + e \\left(\\frac{H}{2}\\right) + g.\n$$\n化简：\n$$\nf\\!\\left(\\frac{H}{2},\\frac{H}{2}\\right) = \\frac{a + b + c}{4} H^2 + \\frac{d+e}{2} H + g.\n$$\n中心的插值误差，定义为\n$$\nE_{\\mathrm{center}} = f\\!\\left(\\frac{H}{2},\\frac{H}{2}\\right) - I\\!\\left(\\frac{H}{2},\\frac{H}{2}\\right),\n$$\n则为\n$$\nE_{\\mathrm{center}} = \\left( \\frac{a + b + c}{4} H^2 + \\frac{d+e}{2} H + g \\right) - \\left( g + \\frac{d+e}{2} H + \\frac{2 a + 2 b + c}{4} H^2 \\right).\n$$\n消去公因子 $\\frac{d+e}{2} H$ 和 $g$，我们得到\n$$\nE_{\\mathrm{center}} = \\left( \\frac{a + b + c}{4} - \\frac{2 a + 2 b + c}{4} \\right) H^2 = - \\frac{a + b}{4} \\, H^2.\n$$\n这个精确表达式表明，双线性延拓能精确地再现混合项 $c x y$ 以及所有线性和常数项，并且主导误差与 $H^2$ 同阶，这证明了对于局部二次模型能够代表其截断行为的足够光滑场，该延拓在单元中心具有二阶精度。", "answer": "$$\\boxed{-\\frac{a+b}{4}\\,H^{2}}$$", "id": "3357474"}, {"introduction": "虽然局部精度很重要，但 restriction（限制）和 prolongation（延拓）算子的全局属性才能确保多重网格求解器的鲁棒性和守恒性。本练习要求你在有限体积框架下，开发一个数值验证方案，以测试质量守恒和离散伴随性等关键属性 [@problem_id:3357431]。完成此练习将连接抽象理论与具体实现，让你能确信所构造的算子符合理论预期。", "problem": "考虑单位超立方体 $[0,1]^d$（其中 $d \\in \\{1,2\\}$）上均匀、单元中心的有限体积网格层次结构。设粗网格的形状为 $\\boldsymbol{n}_c = (n_{c,1},\\dots,n_{c,d})$，细网格的形状为 $\\boldsymbol{n}_f = 2 \\boldsymbol{n}_c = (2 n_{c,1},\\dots,2 n_{c,d})$，即每个空间方向上的加密比为 $2$。令 $R$ 表示一个将细网格数据映射到粗网格数据的限制算子，令 $P$ 表示一个将粗网格数据映射到细网格数据的延长算子。假设在一个有限体积框架中，给定分辨率下两个网格函数 $a$ 和 $b$ 之间的离散内积由单元体积加权和定义为 $\\langle a, b \\rangle = \\sum_{\\text{cells}} V \\, a \\, b$，其中 $V$ 是该分辨率下的空间单元体积。场 $a$ 的离散积分（质量）定义为 $\\mathcal{M}[a] = \\sum_{\\text{cells}} V \\, a$。\n\n从有限体积法的原理和体积加权离散内积的定义出发，设计并实现一个验证协议，以在一组网格上数值测试 $R$ 和 $P$ 的以下性质：\n- 常数保持性：$R$ 和 $P$ 算子都将常数场映射为值相同的常数场。\n- 质量守恒性：跨层级映射时离散积分是守恒的，即从细到粗为 $\\mathcal{M}[a_f] = \\mathcal{M}[R a_f]$，从粗到细为 $\\mathcal{M}[a_c] = \\mathcal{M}[P a_c]$。\n- 离散伴随性（在舍入误差范围内）：对于体积加权内積，$R$ 和 $P$ 对通用场 $u_f$ 和 $v_c$ 满足 $\\langle R u_f, v_c \\rangle_c = \\langle u_f, P v_c \\rangle_f$（在浮点舍入误差范围内），其中下标指示了用于内积的网格分辨率。\n\n您的程序必须：\n1. 基于上述原理，推导 $R$ 和 $P$ 在 $d=1$ 和 $d=2$ 情况下，对于加密比为 $2$ 的均匀单元中心离散化网格的具体实现。\n2. 构建一个确定性的参数集测试套件，涵盖一维和二维情况，包括小尺寸和中等尺寸的网格，以及一个极端的最小尺寸边缘情况。为保证可复现性，随机场必须使用固定的种子。使用以下六个参数集：\n   - 情况 1: $d=1$, $\\boldsymbol{n}_c=(3)$, 种子 $42$。\n   - 情况 2: $d=1$, $\\boldsymbol{n}_c=(5)$, 种子 $123$。\n   - 情况 3: $d=2$, $\\boldsymbol{n}_c=(4,3)$, 种子 $2021$。\n   - 情况 4: $d=2$, $\\boldsymbol{n}_c=(16,10)$, 种子 $99$。\n   - 情况 5: $d=2$, $\\boldsymbol{n}_c=(7,9)$, 种子 $555$。\n   - 情况 6: $d=1$, $\\boldsymbol{n}_c=(1)$, 种子 $777$。\n3. 对每种情况，执行以下检查：\n   - 常数保持性检查：在两个层级上取一个振幅为 $c = 1.23456789$ 的常数场，并计算 $R$ 和 $P$ 的最大归一化绝对常数保持误差，定义为 $\\max\\left(\\frac{\\|R(c \\mathbf{1}_f) - c \\mathbf{1}_c\\|_{\\infty}}{|c|}, \\frac{\\|P(c \\mathbf{1}_c) - c \\mathbf{1}_f\\|_{\\infty}}{|c|}\\right)$，其中 $\\mathbf{1}$ 表示大小合适的元素全为1的向量。\n   - 质量守恒性检查：对于一个随机的细网格场 $u_f$，计算相对质量差异 $\\frac{|\\mathcal{M}[u_f] - \\mathcal{M}[R u_f]|}{\\max(10^{-15}, |\\mathcal{M}[u_f]|)}$；对于一个随机的粗网格场 $v_c$，计算相对质量差异 $\\frac{|\\mathcal{M}[v_c] - \\mathcal{M}[P v_c]|}{\\max(10^{-15}, |\\mathcal{M}[v_c]|)}$。报告这两个值中的最大值。\n   - 离散伴随性检查：对于独立的随机场 $u_f$ 和 $v_c$，计算相对差异 $\\frac{|\\langle R u_f, v_c \\rangle_c - \\langle u_f, P v_c \\rangle_f|}{\\max\\left(10^{-15}, \\sqrt{\\langle u_f, u_f \\rangle_f} \\sqrt{\\langle v_c, v_c \\rangle_c}\\right)}$。\n4. 对每种情况，通过返回三个差异中的最大值（即该情况下的最坏情况归一化误差）来汇总这三个检查，结果为一个浮点数。\n\n实现细节和约束：\n- 区域为一维和二维空间中的 $[0,1]^d$，网格为均匀的单元中心网格，层级间的加密比为 $2$。单元体积 $V_f$ 和 $V_c$ 根据网格间距一致地计算。\n- 随机场在不同检查和情况之间是独立的，并且必须使用给定的种子从标准正态分布中抽取，以确保可复现性。\n- 程序必须完全自包含，不需要任何输入，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,\\dots,r_6]$），其中每个 $r_i$ 是情况 $i$ 的汇总浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$）。", "solution": "问题陈述是有效的。它在科学上基于有限体积法和多重网格理论的原理，问题提法清晰，目标明确，数据充分，并以客观、正式的语言表达。我们开始进行求解。\n\n任务是为单元中心的有限体积离散化推导并数值验证限制（$R$）和延长（$P$）算子的性质。这些算子必须满足三个关键性质：常数保持性、质量守恒性以及关于体积加权内积的离散伴随性。\n\n### 1. 离散化与定义\n\n令区域为单位超立方体 $\\Omega = [0,1]^d$，其中 $d \\in \\{1, 2\\}$。我们考虑一个包含 $\\boldsymbol{n}_c = (n_{c,1}, \\dots, n_{c,d})$ 个单元的粗网格和一个包含 $\\boldsymbol{n}_f = 2\\boldsymbol{n}_c$ 个单元的细网格。\n\n对于一个包含 $\\boldsymbol{n} = (n_1, \\dots, n_d)$ 个单元的均匀网格，单元尺寸为 $\\Delta x_k = 1/n_k$。单个单元的体积为 $V = \\prod_{k=1}^d \\Delta x_k = 1/\\prod_{k=1}^d n_k$。\n粗单元体积为 $V_c = 1/\\prod_{k=1}^d n_{c,k}$。\n细单元体积为 $V_f = 1/\\prod_{k=1}^d n_{f,k} = 1/\\prod_{k=1}^d (2n_{c,k}) = 1/(2^d \\prod_{k=1}^d n_{c,k})$。\n因此，单元体积之间的关系为 $V_c = 2^d V_f$。\n\n在单元体积为 $V$ 的网格上，网格函数 $a$ 和 $b$ 的离散内积为 $\\langle a, b \\rangle = \\sum_{\\text{cells}} Vab$。\n网格函数 $a$ 的离散积分（质量）为 $\\mathcal{M}[a] = \\sum_{\\text{cells}} Va = \\langle a, \\mathbf{1} \\rangle$，其中 $\\mathbf{1}$ 是元素全为1的网格函数。\n\n### 2. 限制算子（$R$）的推导\n\n限制算子 $R$ 将细网格函数 $u_f$ 映射到粗网格函数 $u_c = R u_f$。我们从质量守恒原理推导其形式：$\\mathcal{M}[R u_f] = \\mathcal{M}[u_f]$。\n\n使用离散积分的定义：\n$$\n\\mathcal{M}[R u_f] = \\sum_{j \\in \\text{cells}_c} V_c (R u_f)_j\n\\quad \\text{和} \\quad\n\\mathcal{M}[u_f] = \\sum_{i \\in \\text{cells}_f} V_f (u_f)_i\n$$\n在这里，$j$ 索引粗单元，$i$ 索引细单元。由于每个粗单元是 $2^d$ 个细单元的并集，我们可以将对细单元的求和按其粗父单元进行分组：\n$$\n\\sum_{i \\in \\text{cells}_f} V_f (u_f)_i = \\sum_{j \\in \\text{cells}_c} \\left( \\sum_{i \\in \\text{children}(j)} V_f (u_f)_i \\right)\n$$\n对于全局质量守恒，$\\sum_{j} V_c (R u_f)_j = \\sum_{j} \\sum_{i \\in \\text{children}(j)} V_f (u_f)_i$。一个标准的有限体积方法是对每个粗单元 $j$ 局部地强制执行此守恒定律：\n$$\nV_c (R u_f)_j = \\sum_{i \\in \\text{children}(j)} V_f (u_f)_i\n$$\n解出 $(R u_f)_j$：\n$$\n(R u_f)_j = \\frac{V_f}{V_c} \\sum_{i \\in \\text{children}(j)} (u_f)_i = \\frac{1}{2^d} \\sum_{i \\in \\text{children}(j)} (u_f)_i\n$$\n这就是**体积平均限制算子**。对于 $d=1$，一个粗单元 $j$ 包含细单元 $2j$ 和 $2j+1$，因此 $(R u_f)_j = \\frac{1}{2}((u_f)_{2j} + (u_f)_{2j+1})$。对于 $d=2$，一个粗单元 $(j,k)$ 包含细单元 $(2j, 2k), (2j+1, 2k), (2j, 2k+1), (2j+1, 2k+1)$，因此 $(R u_f)_{j,k} = \\frac{1}{4} \\sum_{l=0}^1 \\sum_{m=0}^1 (u_f)_{2j+l, 2k+m}$。\n\n### 3. 延长算子（$P$）的推导\n\n延长算子 $P$ 将粗网格函数 $v_c$ 映射到细网格函数 $v_f = P v_c$。我们从关于体积加权内积的离散伴随性原理推导其形式：对于任意的 $u_f$ 和 $v_c$，\n$$\n\\langle R u_f, v_c \\rangle_c = \\langle u_f, P v_c \\rangle_f\n$$\n代入内积的定义：\n$$\n\\sum_{j \\in \\text{cells}_c} V_c (R u_f)_j (v_c)_j = \\sum_{i \\in \\text{cells}_f} V_f (u_f)_i (P v_c)_i\n$$\n现在，代入推导出的 $(R u_f)_j$ 的局部表达式：\n$$\n\\sum_{j \\in \\text{cells}_c} V_c \\left( \\frac{V_f}{V_c} \\sum_{k \\in \\text{children}(j)} (u_f)_k \\right) (v_c)_j = \\sum_{i \\in \\text{cells}_f} V_f (u_f)_i (P v_c)_i\n$$\n$V_c$ 项相互抵消，剩下：\n$$\n\\sum_{j \\in \\text{cells}_c} V_f \\left( \\sum_{k \\in \\text{children}(j)} (u_f)_k \\right) (v_c)_j = \\sum_{i \\in \\text{cells}_f} V_f (u_f)_i (P v_c)_i\n$$\n分配 $(v_c)_j$ 并按细单元索引对项进行分组，我们认识到对于任何细单元 $k$，其父单元是粗单元 $j = \\text{parent}(k)$。左侧变为：\n$$\n\\sum_{j \\in \\text{cells}_c} \\sum_{k \\in \\text{children}(j)} V_f (u_f)_k (v_c)_j = \\sum_{k \\in \\text{cells}_f} V_f (u_f)_k (v_c)_{\\text{parent}(k)}\n$$\n将其与右侧 $\\sum_{i \\in \\text{cells}_f} V_f (u_f)_i (P v_c)_i$ 进行比较，并注意到此等式必须对任意细网格函数 $u_f$ 成立，因此 $(u_f)_i$ 的系数对于每个 $i$都必须相等。这意味着：\n$$\nV_f (v_c)_{\\text{parent}(i)} = V_f (P v_c)_i \\quad \\implies \\quad (P v_c)_i = (v_c)_{\\text{parent}(i)}\n$$\n这就是**分段常数注入**算子。每个细单元从包含它的唯一粗父单元接收其值。\n\n### 4. 性质验证\n\n我们简要确认这对算子 $(R, P)$ 满足所有必需的性质。\n- **常数保持性**：\n  - 如果对所有 $i$ 都有 $(u_f)_i = C$，那么 $(R u_f)_j = \\frac{1}{2^d} \\sum_{i \\in \\text{children}(j)} C = \\frac{1}{2^d} (2^d C) = C$。$R$ 算子是常数保持的。\n  - 如果对所有 $j$ 都有 $(v_c)_j = C$，那么 $(P v_c)_i = (v_c)_{\\text{parent}(i)} = C$。$P$ 算子是常数保持的。\n- **质量守恒性**：\n  - 对于 $R$：该算子是直接从局部（并因此是全局）质量守恒的条件推导出来的。\n  - 对于 $P$：$\\mathcal{M}[P v_c] = \\sum_i V_f (P v_c)_i = \\sum_j \\sum_{i \\in \\text{children}(j)} V_f (v_c)_{\\text{parent}(i)}$。由于对于所有 $i \\in \\text{children}(j)$，都有 parent$(i)=j$，因此这等于 $\\sum_j \\sum_{i \\in \\text{children}(j)} V_f (v_c)_j = \\sum_j (v_c)_j (2^d V_f) = \\sum_j (v_c)_j V_c = \\mathcal{M}[v_c]$。\n- **离散伴随性**：在给定 $R$ 形式的情况下，$P$ 算子是直接从此条件推导出来的。\n\n### 5. 数值实现策略\n\n所推导的算子使用高效的 `numpy` 数组操作来实现。\n- **限制（$R$）**：对于一个 $d$ 维细网格数组 `u_f`，限制操作通过将其重塑为一个 $2d$ 维数组，对粗单元内细单元对应的新轴进行求和，并按 $1/2^d$进行缩放来实现。对于 $d=2$ 和形状为 $(n_{f,1}, n_{f,2})$ 的细网格，我们将其重塑为 $(n_{c,1}, 2, n_{c,2}, 2)$，对轴 1 和 3 求和，然后乘以 $0.25$。\n- **延长（$P$）**：对于一个 $d$ 维粗网格数组 `u_c`，分段常数注入可以通过使用 `numpy.kron` 和形状为 $(2, \\dots, 2)$ 的全1块，或沿每个轴使用 `numpy.repeat` 来实现。对于 $d=2$，`numpy.kron(u_c, numpy.ones((2, 2)))` 可实现所需的映射。\n\n验证协议通过为每个测试用例计算三个指定的误差度量来执行。为保证每个测试用例的可复现性，随机场使用固定的种子从标准正态分布生成。报告每种情况下三个误差中的最大值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and verifies restriction and prolongation operators for\n    a finite volume multigrid context.\n    \"\"\"\n\n    test_cases = [\n        # (d, n_c, seed)\n        (1, (3,), 42),\n        (1, (5,), 123),\n        (2, (4, 3), 2021),\n        (2, (16, 10), 99),\n        (2, (7, 9), 555),\n        (1, (1,), 777), # Extreme minimal-size edge case\n    ]\n\n    results = []\n\n    def restrict(u_f, n_c, d):\n        \"\"\"\n        Applies volume-averaging restriction operator.\n        (R u_f)_j = 1/2^d * sum_{i in children(j)} (u_f)_i\n        \"\"\"\n        if d == 1:\n            u_c = u_f.reshape(n_c[0], 2).mean(axis=1)\n        elif d == 2:\n            u_c = u_f.reshape(n_c[0], 2, n_c[1], 2).mean(axis=(1, 3))\n        else:\n            raise ValueError(f\"Unsupported dimension d={d}\")\n        return u_c\n\n    def prolong(v_c, d):\n        \"\"\"\n        Applies piecewise constant injection prolongation operator.\n        (P v_c)_i = v_c_{parent(i)}\n        \"\"\"\n        if d == 1:\n            v_f = np.repeat(v_c, 2)\n        elif d == 2:\n            v_f = np.kron(v_c, np.ones((2, 2)))\n        else:\n            raise ValueError(f\"Unsupported dimension d={d}\")\n        return v_f\n\n    for d, n_c, seed in test_cases:\n        # 1. Setup grids and volumes\n        n_c = np.array(n_c, dtype=int)\n        n_f = 2 * n_c\n\n        V_c = 1.0 / np.prod(n_c)\n        V_f = 1.0 / np.prod(n_f)\n        \n        # Initialize RNG for this case\n        rng = np.random.default_rng(seed)\n\n        # 2. Perform checks\n        \n        # --- Check 1: Constant Preservation ---\n        c = 1.23456789\n        const_f = np.full(tuple(n_f), c)\n        const_c = np.full(tuple(n_c), c)\n\n        R_const_f = restrict(const_f, tuple(n_c), d)\n        err_R = np.linalg.norm(R_const_f - const_c, ord=np.inf) / np.abs(c)\n\n        P_const_c = prolong(const_c, d)\n        err_P = np.linalg.norm(P_const_c - const_f, ord=np.inf) / np.abs(c)\n        \n        const_pres_error = max(err_R, err_P)\n\n        # --- Check 2: Mass Conservation ---\n        # Draw independent random fields for this check\n        u_f_mass = rng.standard_normal(size=tuple(n_f))\n        v_c_mass = rng.standard_normal(size=tuple(n_c))\n\n        mass_uf = np.sum(u_f_mass) * V_f\n        R_uf = restrict(u_f_mass, tuple(n_c), d)\n        mass_R_uf = np.sum(R_uf) * V_c\n        err_mass_R = np.abs(mass_uf - mass_R_uf) / max(1e-15, np.abs(mass_uf))\n\n        mass_vc = np.sum(v_c_mass) * V_c\n        P_vc = prolong(v_c_mass, d)\n        mass_P_vc = np.sum(P_vc) * V_f\n        err_mass_P = np.abs(mass_vc - mass_P_vc) / max(1e-15, np.abs(mass_vc))\n        \n        mass_cons_error = max(err_mass_R, err_mass_P)\n\n        # --- Check 3: Discrete Adjointness ---\n        # Draw independent random fields for this check\n        u_f_adj = rng.standard_normal(size=tuple(n_f))\n        v_c_adj = rng.standard_normal(size=tuple(n_c))\n        \n        R_uf_adj = restrict(u_f_adj, tuple(n_c), d)\n        P_vc_adj = prolong(v_c_adj, d)\n\n        inner_prod_c = np.sum(R_uf_adj * v_c_adj) * V_c\n        inner_prod_f = np.sum(u_f_adj * P_vc_adj) * V_f\n\n        norm_uf = np.sqrt(np.sum(u_f_adj**2) * V_f)\n        norm_vc = np.sqrt(np.sum(v_c_adj**2) * V_c)\n\n        adj_error = np.abs(inner_prod_c - inner_prod_f) / max(1e-15, norm_uf * norm_vc)\n        \n        # --- Summarize ---\n        max_error = max(const_pres_error, mass_cons_error, adj_error)\n        results.append(max_error)\n\n    # 3. Format output\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3357431"}, {"introduction": "在牢固掌握算子的构建和验证之后，我们现在将它们应用到一个完整的算法环境中。最后一个练习将带你逐步完成一个全近似格式（Full Approximation Scheme, FAS）的V-循环，FAS 是计算流体力学中广泛使用的非線性多重网格方法的基石 [@problem_id:3357488]。通过手动执行从计算细网格缺陷到应用粗网格校正的每一步，你将获得宝贵的实践经验，深刻理解这些算子如何协同工作以解决复杂的非线性问题。", "problem": "考虑一个代表计算流体动力学的一维稳态非线性扩散模型问题：$x \\in [0,1]$ 上的标量场 $u(x)$ 满足\n$$\n- \\frac{d}{dx} \\left( \\left( 1 + u(x)^{2} \\right) \\frac{du}{dx} \\right) = 1,\n$$\n边界条件为 Dirichlet 边界条件 $u(0) = 0$ 和 $u(1) = 0$。使用均匀网格上的守恒中心有限体积/有限差分格式对算子进行离散化，其中对于网格间距 $h$ 和内部节点索引 $i$，离散非线性算子 $N^{h}(u)$ 为\n$$\n\\left(N^{h}(u)\\right)_{i} \\equiv - \\frac{1}{h} \\left( \\frac{1}{h} a_{i+\\frac{1}{2}} \\left( u_{i+1} - u_{i} \\right) - \\frac{1}{h} a_{i-\\frac{1}{2}} \\left( u_{i} - u_{i-1} \\right) \\right),\n$$\n其中非线性面扩散系数定义为\n$$\na_{i+\\frac{1}{2}} \\equiv 1 + \\left( \\frac{u_{i} + u_{i+1}}{2} \\right)^{2}.\n$$\n\n使用以下设置完成一个完全逼近格式 (FAS) V循环：\n\n- 细网格：$h = \\frac{1}{4}$，节点位于 $x = 0, \\frac{1}{4}, \\frac{1}{2}, \\frac{3}{4}, 1$，有三个内点未知数 $\\tilde{u}^{h} = \\left( \\tilde{u}_{1}, \\tilde{u}_{2}, \\tilde{u}_{3} \\right)^{\\top}$，分别对应于 $x = \\frac{1}{4}, \\frac{1}{2}, \\frac{3}{4}$。\n- 粗网格：$H = 2h = \\frac{1}{2}$，节点位于 $x = 0, \\frac{1}{2}, 1$，有一个内点未知数 $u^{H}$ 位于 $x = \\frac{1}{2}$。\n- 两个网格上的右端项都是常数源项 $1$ 的离散化，即对于 $i = 1,2,3$，$f^{h}_{i} = 1$，并且在粗网格内点上 $f^{H} = 1$。\n- 初始细网格迭代值为零：$\\tilde{u}^{h} = (0,0,0)^{\\top}$。\n- 状态（网格函数）的限制算子为注射 $R_{u}: \\mathbb{R}^{3} \\to \\mathbb{R}$，定义为 $R_{u}(\\tilde{u}^{h}) = \\tilde{u}_{2}$。\n- 残差/亏量的限制算子为一维全加权 $R_{r}: \\mathbb{R}^{3} \\to \\mathbb{R}$，\n$$\nR_{r}(r^{h}) = \\frac{1}{4} r^{h}_{1} + \\frac{1}{2} r^{h}_{2} + \\frac{1}{4} r^{h}_{3}.\n$$\n- 修正量的延长算子 $P: \\mathbb{R} \\to \\mathbb{R}^{3}$ 是从粗网格内点修正量 $e^{H}$ 到细网格节点的线性插值，\n$$\nP(e^{H}) = \\left( \\frac{1}{2} e^{H}, \\; e^{H}, \\; \\frac{1}{2} e^{H} \\right)^{\\top}.\n$$\n- 在粗网格上，从注射的粗网格状态开始，执行一步 Newton 法来近似求解 FAS 粗网格方程。即，对于 $F^{H}(u^{H}) \\equiv N^{H}(u^{H}) - \\left( f^{H}_{\\text{FAS}} \\right)$，取\n$$\nu^{H} \\leftarrow u^{H} - \\frac{F^{H}(u^{H})}{\\left( F^{H} \\right)'(u^{H})},\n$$\n从 $u^{H} = R_{u}(\\tilde{u}^{h})$ 开始。\n\n按照如下步骤进行 FAS 操作：\n\n1. 计算细网格亏量 $d^{h} \\equiv f^{h} - N^{h}(\\tilde{u}^{h})$。\n2. 限制状态：$\\tilde{u}^{H} \\equiv R_{u}(\\tilde{u}^{h})$，并在间距为 $H$ 的相同离散化原则下写出粗网格非线性算子 $N^{H}(u^{H})$。\n3. 使用亏量和状态限制，以及在 $\\tilde{u}^{H}$ 处求值的粗网格算子，构造 FAS 粗网格右端项 $f^{H}_{\\text{FAS}}$。\n4. 对粗网格方程应用一步 Newton 法以获得 $u^{H}$。\n5. 计算粗网格修正量 $e^{H} \\equiv u^{H} - \\tilde{u}^{H}$。\n6. 延长修正量 $e^{h} \\equiv P(e^{H})$ 并更新细网格迭代值 $u^{h,\\text{new}} \\equiv \\tilde{u}^{h} + e^{h}$。\n\n在这些步骤中，明确写出 $R_{u}$、$R_{r}$ 和 $P$ 对状态和亏量的每一次应用，并解释粗网格修正量如何修正细网格迭代值。最后，报告中心节点 $x = \\frac{1}{2}$ 处更新后的细网格迭代值。以单个实数形式提供最终答案。无需四舍五入，且该量是无量纲的。", "solution": "用户希望针对一个特定的一维非线性扩散问题，执行一次完全逼近格式 (FAS) V循环。该过程如问题陈述中所指定的，被分解为六个不同的步骤。\n\n首先，我们建立数学背景。该非线性边值问题为：\n$$\n- \\frac{d}{dx} \\left( \\left( 1 + u(x)^{2} \\right) \\frac{du}{dx} \\right) = 1, \\quad x \\in [0,1]\n$$\n边界条件为 $u(0) = 0$ 和 $u(1) = 0$。\n\n细网格的间距为 $h = \\frac{1}{4}$，产生三个内点未知数 $\\tilde{u}_{1}, \\tilde{u}_{2}, \\tilde{u}_{3}$，分别位于 $x_1 = \\frac{1}{4}$、$x_2 = \\frac{1}{2}$ 和 $x_3 = \\frac{3}{4}$。边界节点为 $u_0 = u(0) = 0$ 和 $u_4 = u(1) = 0$。细网格解的初始猜测为 $\\tilde{u}^{h} = (\\tilde{u}_1, \\tilde{u}_2, \\tilde{u}_3)^{\\top} = (0, 0, 0)^{\\top}$。源项离散化为 $f^{h} = (1, 1, 1)^{\\top}$。\n\n粗网格的间距为 $H = 2h = \\frac{1}{2}$，在 $x = \\frac{1}{2}$ 处有一个内点未知数 $u^{H}$。边界节点为 $u^{H}_{0} = 0$ 和 $u^{H}_{2} = 0$。\n\n在内点 $i$ 处的细网格离散算子为：\n$$\n\\left(N^{h}(u)\\right)_{i} = - \\frac{1}{h^2} \\left( a_{i+\\frac{1}{2}} (u_{i+1} - u_{i}) - a_{i-\\frac{1}{2}} (u_{i} - u_{i-1}) \\right)\n$$\n其中 $a_{i+\\frac{1}{2}} = 1 + \\left( \\frac{u_i + u_{i+1}}{2} \\right)^{2}$ 且 $\\frac{1}{h^2} = \\frac{1}{(1/4)^2} = 16$。\n\n单个内点未知数 $u^H$ 的粗网格离散算子可类似推导。设 $u^H$ 为中心节点的值。\n$$\nN^{H}(u^{H}) = - \\frac{1}{H^2} \\left( a_{1+\\frac{1}{2}}(u^{H}_{2} - u^{H}) - a_{1-\\frac{1}{2}}(u^{H} - u^{H}_{0}) \\right)\n$$\n当 $H=\\frac{1}{2}$、$u^{H}_{0}=0$、$u^{H}_{2}=0$ 时，扩散系数变为 $a_{1+\\frac{1}{2}} = 1 + (\\frac{u^H+0}{2})^2$ 和 $a_{1-\\frac{1}{2}} = 1 + (\\frac{0+u^H}{2})^2$。两者都等于 $1 + \\frac{(u^H)^2}{4}$。\n$$\nN^{H}(u^{H}) = -4 \\left( \\left(1 + \\frac{(u^H)^2}{4}\\right)(0 - u^H) - \\left(1 + \\frac{(u^H)^2}{4}\\right)(u^H - 0) \\right) = -4 \\left( -2u^H \\left(1 + \\frac{(u^H)^2}{4}\\right) \\right) = 8u^H + 2(u^H)^3\n$$\n现在我们执行 FAS V循环的步骤。\n\n**步骤 1：计算细网格亏量 $d^{h} \\equiv f^{h} - N^{h}(\\tilde{u}^{h})$**\n初始迭代值为 $\\tilde{u}^{h} = (0,0,0)^{\\top}$。边界值为 $\\tilde{u}_0 = 0$ 和 $\\tilde{u}_4 = 0$。\n首先计算面扩散系数：\n$$\na_{i+\\frac{1}{2}} = 1 + \\left( \\frac{\\tilde{u}_i + \\tilde{u}_{i+1}}{2} \\right)^2 = 1 + \\left( \\frac{0 + 0}{2} \\right)^2 = 1\n$$\n这对所有面都成立。\n然后对每个内点 $i=1,2,3$ 计算离散算子 $N^{h}(\\tilde{u}^{h})$：\n$$\n\\left(N^{h}(\\tilde{u}^{h})\\right)_{i} = -16 \\left( 1(\\tilde{u}_{i+1} - \\tilde{u}_i) - 1(\\tilde{u}_i - \\tilde{u}_{i-1}) \\right) = -16 \\left( 1(0 - 0) - 1(0 - 0) \\right) = 0\n$$\n因此，$N^{h}(\\tilde{u}^{h}) = (0,0,0)^{\\top}$。\n亏量（或残差）为：\n$$\nd^{h} = f^{h} - N^{h}(\\tilde{u}^{h}) = (1,1,1)^{\\top} - (0,0,0)^{\\top} = (1,1,1)^{\\top}\n$$\n\n**步骤 2：限制状态：$\\tilde{u}^{H} \\equiv R_{u}(\\tilde{u}^{h})$**\n状态限制算子 $R_u$ 定义为注射：$R_{u}(\\tilde{u}^{h}) = \\tilde{u}_{2}$。\n将此应用于当前的细网格迭代值：\n$$\n\\tilde{u}^{H} = R_{u}\\left((0,0,0)^{\\top}\\right) = 0\n$$\n\n**步骤 3：构造 FAS 粗网格右端项 $f^{H}_{\\text{FAS}}$**\n粗网格方程为 $N^H(u^H) = f^H_{\\text{FAS}}$，其中 FAS 右端项定义为：\n$$\nf^{H}_{\\text{FAS}} = N^{H}(\\tilde{u}^{H}) + R_{r}(f^{h} - N^{h}(\\tilde{u}^{h})) = N^{H}(\\tilde{u}^{H}) + R_{r}(d^{h})\n$$\n我们计算右侧的每一项：\n- 根据步骤 2，$\\tilde{u}^{H} = 0$。因此，$N^{H}(\\tilde{u}^{H}) = N^{H}(0) = 8(0) + 2(0)^3 = 0$。\n- 残差限制算子是一维全加权 $R_{r}(r^{h}) = \\frac{1}{4} r^{h}_{1} + \\frac{1}{2} r^{h}_{2} + \\frac{1}{4} r^{h}_{3}$。根据步骤 1，$d^h=(1,1,1)^{\\top}$。\n$$\nR_{r}(d^{h}) = \\frac{1}{4}(1) + \\frac{1}{2}(1) + \\frac{1}{4}(1) = 1\n$$\n结合这些结果得到 FAS 右端项：\n$$\nf^{H}_{\\text{FAS}} = 0 + 1 = 1\n$$\n需要近似求解的粗网格方程是 $N^{H}(u^{H}) = 1$，即 $8u^{H} + 2(u^{H})^3 = 1$。\n\n**步骤 4：对粗网格方程应用一步 Newton 法以获得 $u^{H}$**\n我们从 $u^{H}_{\\text{start}} = \\tilde{u}^H = 0$ 开始，使用一步 Newton 法求解 $F^{H}(u^{H}) \\equiv 8u^{H} + 2(u^{H})^3 - 1 = 0$。\nNewton 更新法则是 $u^{H}_{\\text{new}} = u^{H}_{\\text{old}} - \\frac{F^{H}(u^{H}_{\\text{old}})}{(F^{H})'(u^{H}_{\\text{old}})}$。\n$F^{H}$ 的导数是 $(F^{H})'(u^{H}) = \\frac{d}{du^H}(8u^{H} + 2(u^{H})^3 - 1) = 8 + 6(u^{H})^2$。\n我们在起始点 $u^{H}_{\\text{old}} = 0$ 处计算 $F^H$ 及其导数：\n$$\nF^{H}(0) = 8(0) + 2(0)^3 - 1 = -1\n$$\n$$\n(F^{H})'(0) = 8 + 6(0)^2 = 8\n$$\n更新后的粗网格解 $u^H$ 为：\n$$\nu^{H} = 0 - \\frac{-1}{8} = \\frac{1}{8}\n$$\n\n**步骤 5：计算粗网格修正量 $e^{H} \\equiv u^{H} - \\tilde{u}^{H}$**\n粗网格修正量是新的粗网格解与限制后的细网格解之间的差值：\n$$\ne^{H} = u^{H} - \\tilde{u}^{H} = \\frac{1}{8} - 0 = \\frac{1}{8}\n$$\n\n**步骤 6：延长修正量 $e^{h} \\equiv P(e^{H})$ 并更新细网格迭代值**\n粗网格修正量 $e^H$ 使用延长算子 $P$ 插值到细网格。将 $P$ 应用于粗网格修正量 $e^H$ 得到细网格修正向量 $e^h$：\n$$\ne^{h} = P(e^H) = P\\left(\\frac{1}{8}\\right) = \\left( \\frac{1}{2} e^{H}, \\; e^{H}, \\; \\frac{1}{2} e^{H} \\right)^{\\top} = \\left( \\frac{1}{2} \\cdot \\frac{1}{8}, \\; \\frac{1}{8}, \\; \\frac{1}{2} \\cdot \\frac{1}{8} \\right)^{\\top} = \\left( \\frac{1}{16}, \\frac{1}{8}, \\frac{1}{16} \\right)^{\\top}\n$$\n然后通过加上这个修正量来更新细网格迭代值。这个步骤将在粗网格上捕获的低频误差信息注入回细网格解中：\n$$\nu^{h,\\text{new}} \\equiv \\tilde{u}^{h} + e^{h}\n$$\n$$\nu^{h,\\text{new}} = (0, 0, 0)^{\\top} + \\left( \\frac{1}{16}, \\frac{1}{8}, \\frac{1}{16} \\right)^{\\top} = \\left( \\frac{1}{16}, \\frac{1}{8}, \\frac{1}{16} \\right)^{\\top}\n$$\n问题要求的是中心节点 $x = \\frac{1}{2}$ 处的更新值，它对应于向量 $u^{h,\\text{new}}$ 的第二个分量。这个值是 $\\frac{1}{8}$。", "answer": "$$\n\\boxed{\\frac{1}{8}}\n$$", "id": "3357488"}]}