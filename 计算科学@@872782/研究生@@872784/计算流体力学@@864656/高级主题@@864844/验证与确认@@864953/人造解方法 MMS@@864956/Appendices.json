{"hands_on_practices": [{"introduction": "验证数值积分器的时间精度是代码验证的关键步骤。通过构造一个同时具有时间和空间变化的解析解，制造解方法（MMS）使我们能够精确评估时间推进格式的离散误差。这项实践将引导你推导一个源项，并用它来检验不同龙格-库塔（Runge-Kutta）方法经验收敛阶的计算，从而加深对时间积分误差来源的理解。[@problem_id:3376840]", "problem": "考虑周期性域 $x \\in [0, 2\\pi]$ 上的一维线性平流扩散方程，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t),\n$$\n其中 $a$ 和 $\\nu$ 是常系数，$s(x,t)$ 是一个待定的源项。使用制造解方法（MMS），通过指定精确解来推导出一个一致的源项\n$$\nu(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x),\n$$\n其中 $\\alpha$ 和 $\\beta$ 是实常数，$k$ 是一个正整数。三角函数中的所有角度必须以弧度为单位进行解释。您可以假设函数具有足够的光滑性以执行所有操作。\n\n任务1. 从偏导数的基本定义和给定的精确解出发，推导源项 $s(x,t)$，使得 $u(x,t)$ 是该平流扩散方程的精确解。推导过程必须首先计算时间导数 $\\partial u/\\partial t$、一阶空间导数 $\\partial u/\\partial x$ 和二阶空间导数 $\\partial^2 u/\\partial x^2$，然后将它们代入控制方程以分离出 $s(x,t)$。\n\n任务2. 通过将精确的制造解沿其内部级横坐标代入，定义龙格-库塔时间积分器的单步离散时间残差（也称为局部误差）。对于从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个时间步，沿精确轨迹应用的龙格-库塔更新为\n$$\nu^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F\\!\\left(x,t_n + c_i \\Delta t\\right),\n$$\n其中 $m$ 是级数，$b_i$ 和 $c_i$ 是方法的权重和横坐标，$F(x,t)$ 表示在精确制造解上计算的偏微分方程的右端项。由于源项是通过MMS选择以强制执行该解的，因此对于制造解成立 $F(x,t) = \\partial u/\\partial t(x,t)$。定义单步残差范数\n$$\n\\mathcal{R}(\\Delta t) = \\left\\| u^{\\text{RK}}(x) - u\\!\\left(x,t_n + \\Delta t\\right) \\right\\|_{L^2([0,2\\pi])},\n$$\n其中 $L^2$ 范数计算为周期性域上逐点差平方的空间平均值的平方根。\n\n任务3. 使用上述残差定义，通过其权重 $b_i$ 和横坐标 $c_i$ 实现以下显式龙格-库塔方法，并评估从 $t_n = 0$ 开始的单个时间步的残差：\n- 前向欧拉法（一级）：$m=1$, $b_1 = 1$, $c_1 = 0$。\n- 显式中点法（二级，二阶）：$m=1$, $b_1 = 1$, $c_1 = \\tfrac{1}{2}$，解释为时间步上 $\\partial u/\\partial t$ 的单点中点求积。\n- 经典四阶龙格-库塔法（四级）：$m=4$, $(c_1,c_2,c_3,c_4) = (0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1)$ 且 $(b_1,b_2,b_3,b_4) = \\left(\\tfrac{1}{6}, \\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{6}\\right)$。\n\n任务4. 对于每种方法和一系列时间步 $\\Delta t_1 > \\Delta t_2 > \\Delta t_3$，根据残差计算经验精度阶\n$$\np_{\\text{est}} = \\frac{\\log\\left(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)}.\n$$\n对 $\\left(\\Delta t_2, \\Delta t_3\\right)$ 对重复此过程。\n\n任务5. 通过设置 $\\alpha = 0$ 并选择 $\\beta$ 和 $\\Delta t$ 以满足 $\\beta \\Delta t = \\pi$，研究振荡制造解动力学中的类超收敛抵消现象。在这种情况下，对于时间因子，$u$ 在一个步长内的精确变化为零，某些求积法可能会表现出增强的抵消效果。对于经典四阶龙格-库塔方法，计算在 $\\Delta t_2$ 满足 $\\beta \\Delta t_2 = \\pi$ 的情况下，时间步对 $\\left(\\Delta t_1,\\Delta t_2\\right)$ 和 $\\left(\\Delta t_2,\\Delta t_3\\right)$ 的经验阶 $p_{\\text{est}}$，并返回一个布尔标志，指示每个经验阶是否超过方法的标称阶加 $0.5$。\n\n实现细节和单位：\n- 使用在 $[0,2\\pi]$ 上均匀分布的 $N$ 个点的周期性空间网格，通过网格点上均方差的平方根来数值近似 $L^2$ 范数。\n- 三角函数中的所有角度必须以弧度为单位进行解释。\n- 除了为三角函数求值指定角度单位外，不需要其他物理量纲单位。\n\n测试套件。您的程序必须为以下三组参数集实现计算，每组参数集如所述产生两个经验阶或布尔标志：\n\n1. 一般动力学，四阶方法（理想情况）：\n   - 参数：$a = 1.0$, $\\nu = 0.05$, $\\alpha = 0.1$, $\\beta = 2.0$, $k = 2$, $N = 256$。\n   - 方法：经典四阶龙格-库塔法。\n   - 时间步：$\\Delta t_1 = 0.2$, $\\Delta t_2 = 0.1$, $\\Delta t_3 = 0.05$。\n   - 输出：两个浮点数，即为 $\\left(\\Delta t_1,\\Delta t_2\\right)$ 和 $\\left(\\Delta t_2,\\Delta t_3\\right)$ 计算的经验阶。\n\n2. 时间主导的制造解动力学，二阶方法（强调纯时间变化的边界情况）：\n   - 参数：$a = 0.0$, $\\nu = 0.0$, $\\alpha = 0.2$, $\\beta = 1.5$, $k = 3$, $N = 256$。\n   - 方法：显式中点法。\n   - 时间步：$\\Delta t_1 = 0.3$, $\\Delta t_2 = 0.15$, $\\Delta t_3 = 0.075$。\n   - 输出：两个浮点数，即为 $\\left(\\Delta t_1,\\Delta t_2\\right)$ 和 $\\left(\\Delta t_2,\\Delta t_3\\right)$ 计算的经验阶。\n\n3. 振荡类超收敛抵消，四阶方法：\n   - 参数：$a = 0.5$, $\\nu = 0.01$, $\\alpha = 0.0$, $\\beta = 4\\pi$, $k = 4$, $N = 256$。\n   - 方法：经典四阶龙格-库塔法。\n   - 时间步：$\\Delta t_1 = 0.5$, $\\Delta t_2 = 0.25$, $\\Delta t_3 = 0.125$，使得 $\\beta \\Delta t_2 = \\pi$。\n   - 输出：两个布尔值，指示 $\\left(\\Delta t_1,\\Delta t_2\\right)$ 和 $\\left(\\Delta t_2,\\Delta t_3\\right)$ 的经验阶是否超过 $4.5$。\n\n最终输出格式。您的程序应生成单行输出，其中包含按以下顺序排列、用方括号括起并以逗号分隔的结果列表\n$$\n\\left[ p^{(1)}_{12},\\, p^{(1)}_{23},\\, p^{(2)}_{12},\\, p^{(2)}_{23},\\, \\text{flag}^{(3)}_{12},\\, \\text{flag}^{(3)}_{23} \\right],\n$$\n其中上标表示测试用例编号，下标表示使用的时间步对。每个 $p$ 必须是浮点数，每个标志必须是布尔值。", "solution": "该问题根据指定标准进行验证。\n\n### 第一步：提取已知条件\n- **控制方程**：周期性域 $x \\in [0, 2\\pi]$ 上的一维线性平流扩散方程为\n$$ \\frac{\\partial u}{\\partial t}(x,t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t) $$\n其中 $a$ 和 $\\nu$ 是常系数，$s(x,t)$ 是一个源项。\n- **制造解**：指定的精确解是\n$$ u(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x) $$\n其中 $\\alpha$、$\\beta$ 是实常数，$k$ 是一个正整数。\n- **任务1**：通过将制造解代入控制方程来推导源项 $s(x,t)$。\n- **任务2**：定义龙格-库塔（RK）积分器的单步离散时间残差。RK更新为：\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F\\!\\left(x,t_n + c_i \\Delta t\\right) $$\n其中 $F(x,t) = \\partial u/\\partial t(x,t)$ 沿精确解轨迹。残差范数定义为：\n$$ \\mathcal{R}(\\Delta t) = \\left\\| u^{\\text{RK}}(x) - u\\!\\left(x,t_n + \\Delta t\\right) \\right\\|_{L^2([0,2\\pi])} $$\n$L^2$ 范数将近似为空间上逐点差平方的平均值的平方根。\n- **任务3**：为三种显式RK方法实现并评估从 $t_n = 0$ 开始的残差：\n    - 前向欧拉法：$m=1$, $b_1 = 1$, $c_1 = 0$。\n    - 显式中点法：$m=1$, $b_1 = 1$, $c_1 = \\tfrac{1}{2}$（解释为单点求积）。\n    - 经典龙格-库塔法（RK4）：$m=4$, $(c_1,c_2,c_3,c_4) = (0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1)$, $(b_1,b_2,b_3,b_4) = \\left(\\tfrac{1}{6}, \\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{6}\\right)$。\n- **任务4**：计算经验精度阶：\n$$ p_{\\text{est}} = \\frac{\\log\\left(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2)\\right)}{\\log\\left(\\Delta t_1 / \\Delta t_2\\right)} $$\n- **任务5**：研究RK4方法在 $\\alpha = 0$ 和 $\\beta \\Delta t = \\pi$ 时的超收敛现象。\n- **实现细节**：在 $[0, 2\\pi]$ 上使用包含 $N$ 个点的周期性空间网格。角度以弧度为单位。\n- **测试套件**：提供了三个具体的测试用例，包含所有必要的参数（$\\alpha, \\beta, k, a, \\nu, N$）、时间步（$\\Delta t_1, \\Delta t_2, \\Delta t_3$）和目标输出（经验阶或布尔标志）。\n\n### 第二步：使用提取的已知条件进行验证\n对问题陈述进行严格审查：\n- **科学依据**：该问题植根于计算流体动力学和数值分析领域。控制方程是一个基本的偏微分方程，制造解方法（MMS）是代码验证的标准技术。龙格-库塔方法和精度阶的概念是常微分/偏微分方程数值分析的支柱。超收敛的研究是数值分析中一个有效且具体的主题。所有组成部分在科学上都是合理的。\n- **适定性**：问题是适定的。任务定义清晰，所有必要的数据、参数和公式都已提供。显式中点法的定义虽然陈述紧凑，但通过其作为单点求积规则的解释得以明确，消除了歧义。问题结构为每个测试用例导出了唯一且有意义的数值结果。\n- **客观性**：问题以精确、客观的数学语言陈述。没有主观或基于观点的论断。\n- **完整性与一致性**：问题是自洽的。提供了求解所需的所有常数、方程和条件。没有内部矛盾。例如，在MMS的背景下，明确陈述并证明了关键的简化 $F(x,t) = \\partial u/\\partial t(x,t)$，从而确保了计算时间积分误差的一致框架。\n- **无其他缺陷**：该问题并非无关紧要、不切实际或无法形式化。它代表了验证数值方案时间精度的标准、严谨的练习。\n\n### 第三步：结论与操作\n问题有效。将提供一个完整的、有理有据的解答。\n\n### 求解推导\n\n解答需要实现问题陈述中描述的逻辑。任务的核心是计算龙格-库塔方法应用于已知解轨迹时的时间误差。\n\n**任务1：源项的推导**\n\n源项 $s(x,t)$ 是通过强制要求 $u(x,t) = \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x)$ 成为控制平流扩散方程的解来推导的。这需要重排方程以求解 $s(x,t)$：\n$$ s(x,t) = \\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} - \\nu \\frac{\\partial^2 u}{\\partial x^2} $$\n我们计算 $u(x,t)$ 的必要偏导数。\n\n首先，对时间部分 $T(t) = \\exp(\\alpha t)\\sin(\\beta t)$ 使用乘法法则，计算时间导数 $\\partial u / \\partial t$：\n$$ \\frac{d T}{d t} = \\frac{d}{dt} \\left( \\exp(\\alpha t)\\sin(\\beta t) \\right) = \\alpha \\exp(\\alpha t)\\sin(\\beta t) + \\beta \\exp(\\alpha t)\\cos(\\beta t) = \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) $$\n因此，\n$$ \\frac{\\partial u}{\\partial t} = \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) $$\n接下来，是空间导数：\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\exp(\\alpha t)\\,\\sin(\\beta t)\\,\\sin(k x) \\right) = \\exp(\\alpha t)\\,\\sin(\\beta t) \\left( k \\cos(k x) \\right) $$\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( k \\exp(\\alpha t)\\,\\sin(\\beta t) \\cos(k x) \\right) = k \\exp(\\alpha t)\\,\\sin(\\beta t) \\left( -k \\sin(k x) \\right) = -k^2 u(x,t) $$\n将这些表达式代回 $s(x,t)$ 的方程中：\n$$ s(x,t) = \\left[ \\exp(\\alpha t) \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) \\right] + a \\left[ k \\exp(\\alpha t)\\sin(\\beta t) \\cos(k x) \\right] - \\nu \\left[ -k^2 \\exp(\\alpha t)\\sin(\\beta t)\\sin(k x) \\right] $$\n提取公因式，我们得到源项的最终表达式：\n$$ s(x,t) = \\exp(\\alpha t) \\left[ \\left( \\alpha\\sin(\\beta t) + \\beta\\cos(\\beta t) \\right) \\sin(k x) + a k \\sin(\\beta t) \\cos(k x) + \\nu k^2 \\sin(\\beta t) \\sin(k x) \\right] $$\n根据构造，此源项确保了给定的 $u(x,t)$ 是偏微分方程的精确解。请注意，对于问题的其余部分，并不直接使用 $s(x,t)$ 的这个表达式。相反，我们利用这样一个性质：当在精确解上求值时，完整的右端项会简化为其时间导数。\n\n**任务2和3：龙格-库塔方法的残差计算**\n\n问题的核心是计算单步残差，它衡量了时间积分器的局部截断误差。沿精确解的更新的一般形式是：\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i\\,F(x,t_n + c_i \\Delta t) $$\n根据MMS验证时间积分器的问题陈述，右端项函数 $F(x,t)$ 在精确解路径上求值，这简化为精确的时间导数：\n$$ F(x, t) = -a \\frac{\\partial u}{\\partial x}(x,t) + \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t) + s(x,t) = \\frac{\\partial u}{\\partial t}(x,t) $$\n因此，RK更新被计算为已知函数 $\\partial u / \\partial t$ 在时间步 $[t_n, t_{n+1}]$ 上的积分：\n$$ u^{\\text{RK}}(x) = u(x,t_n) + \\Delta t \\sum_{i=1}^m b_i \\frac{\\partial u}{\\partial t}(x,t_n + c_i \\Delta t) $$\n残差范数是该数值近似值与步末精确解 $u(x, t_{n+1})$ 之间差值的离散 $L^2$ 范数：\n$$ \\mathcal{R}(\\Delta t) = \\sqrt{ \\frac{1}{N} \\sum_{j=1}^{N} \\left( u^{\\text{RK}}(x_j) - u(x_j, t_n + \\Delta t) \\right)^2 } $$\n其中空间网格为 $x_j = (j-1) \\frac{2\\pi}{N}$，$j=1, \\dots, N$。计算从 $t_n = 0$ 开始。\n\n对于 $t_n=0$，所需方法的具体更新如下：\n- **前向欧拉法**：$m=1, b_1=1, c_1=0$。\n$$ u^{\\text{FE}}(x) = u(x,0) + \\Delta t \\, \\frac{\\partial u}{\\partial t}(x,0) $$\n- **显式中点法**：$m=1, b_1=1, c_1=1/2$。\n$$ u^{\\text{Midpoint}}(x) = u(x,0) + \\Delta t \\, \\frac{\\partial u}{\\partial t}(x, \\Delta t/2) $$\n这对应于使用单点中点求积规则来近似 $\\int_{0}^{\\Delta t} (\\partial u / \\partial t) dt$。\n- **经典RK4**：$m=4, b=(\\frac{1}{6}, \\frac{1}{3}, \\frac{1}{3}, \\frac{1}{6}), c=(0, \\frac{1}{2}, \\frac{1}{2}, 1)$。\n$$ u^{\\text{RK4}}(x) = u(x,0) + \\Delta t \\left[ \\frac{1}{6}\\frac{\\partial u}{\\partial t}(x,0) + \\frac{1}{3}\\frac{\\partial u}{\\partial t}(x,\\Delta t/2) + \\frac{1}{3}\\frac{\\partial u}{\\partial t}(x,\\Delta t/2) + \\frac{1}{6}\\frac{\\partial u}{\\partial t}(x,\\Delta t) \\right] $$\n这对应于使用辛普森法则进行积分。\n\n**任务4和5：经验阶与超收敛**\n\n经验精度阶 $p_{\\text{est}}$ 使用来自两个不同时间步 $\\Delta t_1$ 和 $\\Delta t_2$ 的残差计算：\n$$ p_{\\text{est}} = \\frac{\\log(\\mathcal{R}(\\Delta t_1) / \\mathcal{R}(\\Delta t_2))}{\\log(\\Delta t_1 / \\Delta t_2)} $$\n对于最后一个测试用例，我们研究一个特殊情况。当 $\\alpha=0$ 时，解在时间上变为纯振荡：$u(x,t) = \\sin(\\beta t)\\sin(k x)$。如果我们选择 $\\Delta t$ 使得 $\\beta \\Delta t = \\pi$，会发生有趣的抵消现象。对于 $t_n=0$ 和 $\\Delta t_{special} = \\pi/\\beta$：\n- 在 $t_n=0$ 处的精确解为 $u(x,0) = \\sin(0)\\sin(kx) = 0$。\n- 在 $t_n+\\Delta t_{special}$ 处的精确解为 $u(x,\\pi/\\beta) = \\sin(\\beta \\cdot \\pi/\\beta)\\sin(kx) = \\sin(\\pi)\\sin(kx) = 0$。\n时间导数为 $\\partial u/\\partial t = \\beta\\cos(\\beta t)\\sin(kx)$。RK4更新涉及在 $t=0, \\Delta t/2, \\Delta t$ 处的样本。\n- 在 $t=0$ 处, $\\partial u/\\partial t = \\beta\\cos(0)\\sin(kx)=\\beta\\sin(kx)$。\n- 在 $t=\\Delta t_{special}/2=\\pi/(2\\beta)$ 处, $\\partial u/\\partial t = \\beta\\cos(\\pi/2)\\sin(kx)=0$。\n- 在 $t=\\Delta t_{special}=\\pi/\\beta$ 处, $\\partial u/\\partial t = \\beta\\cos(\\pi)\\sin(kx)=-\\beta\\sin(kx)$。\nRK4的增量项与 $\\frac{1}{6}(\\beta\\sin(kx)) + \\frac{2}{3}(0) + \\frac{1}{6}(-\\beta\\sin(kx)) = 0$ 成正比。\n因此，对于这个特定的时间步，从零开始，精确解和RK4近似值在步末都为零。残差 $\\mathcal{R}(\\Delta t_{special})$ 精确为零（在机器精度范围内）。这导致包含 $\\Delta t_{special}$ 的步长对计算出的阶数为“无穷大”，表明出现了超收敛。实现必须处理残差为零的情况，以避免出现如 $\\log(0)$ 的数值错误。\n\n以下程序为三个指定的测试用例实现了这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    # Dictionary defining the Butcher tableau coefficients for the RK methods.\n    # The structure is method_name: {'b': weights, 'c': abscissae}.\n    RK_METHODS = {\n        \"fe\": {\"b\": np.array([1.0]), \"c\": np.array([0.0])},\n        \"midpoint\": {\"b\": np.array([1.0]), \"c\": np.array([0.5])},\n        \"rk4\": {\n            \"b\": np.array([1/6, 1/3, 1/3, 1/6]),\n            \"c\": np.array([0.0, 0.5, 0.5, 1.0]),\n        },\n    }\n\n    # Test suite parameters. Each tuple contains:\n    # (a, nu, alpha, beta, k, N, method_key, [dt1, dt2, dt3], task_type)\n    test_cases = [\n        (1.0, 0.05, 0.1, 2.0, 2, 256, \"rk4\", [0.2, 0.1, 0.05], \"order\"),\n        (0.0, 0.0, 0.2, 1.5, 3, 256, \"midpoint\", [0.3, 0.15, 0.075], \"order\"),\n        (0.5, 0.01, 0.0, 4 * np.pi, 4, 256, \"rk4\", [0.5, 0.25, 0.125], \"super\"),\n    ]\n\n    final_results = []\n\n    for params in test_cases:\n        a_p, nu_p, alpha, beta, k, N, method_key, dts, task_type = params\n        \n        # Spatial grid (uniform on periodic domain [0, 2*pi])\n        x = np.linspace(0, 2 * np.pi, N, endpoint=False)\n\n        # Define the manufactured solution u(x,t) and its time derivative du/dt\n        # Note: These are vectorized to operate on the grid 'x'.\n        u_func = lambda t_val: np.exp(alpha * t_val) * np.sin(beta * t_val) * np.sin(k * x)\n        dudt_func = lambda t_val: np.exp(alpha * t_val) * (\n            alpha * np.sin(beta * t_val) + beta * np.cos(beta * t_val)\n        ) * np.sin(k * x)\n\n        residuals = []\n        for dt in dts:\n            # Get RK method coefficients\n            b = RK_METHODS[method_key][\"b\"]\n            c = RK_METHODS[method_key][\"c\"]\n\n            # Exact solution at t_n=0 and t_{n+1}=dt\n            u_exact_tn = u_func(0)\n            u_exact_tn1 = u_func(dt)\n            \n            # Calculate the Runge-Kutta update\n            # u^RK = u(t_n) + dt * sum(b_i * F(t_n + c_i*dt))\n            # where F = du/dt on the exact trajectory\n            rk_sum_term = np.zeros_like(x)\n            for i in range(len(b)):\n                t_stage = 0 + c[i] * dt  # t_n = 0\n                rk_sum_term += b[i] * dudt_func(t_stage)\n            \n            u_rk = u_exact_tn + dt * rk_sum_term\n            \n            # Calculate the L2 norm of the residual\n            # R = ||u^RK - u(t_{n+1})||_L2\n            error_sq = (u_rk - u_exact_tn1)**2\n            l2_norm = np.sqrt(np.mean(error_sq))\n            residuals.append(l2_norm)\n\n        # Unpack time steps and residuals\n        dt1, dt2, dt3 = dts\n        res1, res2, res3 = residuals\n\n        # Calculate empirical order p_est = log(R1/R2) / log(dt1/dt2)\n        # Handle cases where residual is zero (perfect cancellation)\n        if res2 == 0:\n            p_12 = np.inf\n        else:\n            p_12 = np.log(res1 / res2) / np.log(dt1 / dt2)\n\n        if res3 == 0:\n            p_23 = np.inf  # This case is not expected here\n        elif res2 == 0:\n            p_23 = -np.inf\n        else:\n            p_23 = np.log(res2 / res3) / np.log(dt2 / dt3)\n\n        if task_type == \"order\":\n            final_results.extend([p_12, p_23])\n        elif task_type == \"super\":\n            # Nominal order for RK4 is 4. Superconvergence threshold is 4.5\n            nominal_order = 4.0\n            super_threshold = 0.5\n            is_super_12 = p_12 > (nominal_order + super_threshold)\n            is_super_23 = p_23 > (nominal_order + super_threshold)\n            final_results.extend([is_super_12, is_super_23])\n            \n    # Format and print the final output string exactly as required\n    # Booleans are converted to lowercase strings 'true'/'false'\n    formatted_results = []\n    for item in final_results:\n        if isinstance(item, bool) or isinstance(item, np.bool_):\n            formatted_results.append(str(item).lower())\n        else:\n            formatted_results.append(str(item))\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3376840"}, {"introduction": "在计算流体力学中，正确实现涉及应力张量的复杂边界条件（如诺伊曼或罗宾条件）是一项常见的挑战。制造解方法为此提供了一个强有力的测试框架，因为它能为边界上的物理量（例如，曳力矢量）提供一个精确的解析表达式。本练习将以斯托克斯（Stokes）流为背景，通过构造一个精确解来推导边界上的曳力，并验证混合型罗宾（Robin）边界条件的实现。[@problem_id:3376865]", "problem": "考虑由斯托克斯方程（作为纳维-斯托克斯方程的低雷诺数极限）控制的牛顿流体的稳定、不可压缩粘性流动。其基本原理是线动量守恒和质量守恒。对于动力粘度为 $\\mu$ 的牛顿流体，线动量守恒表明压力梯度、粘性应力和体积力 $\\mathbf{f}$ 之间的平衡由以下偏微分方程给出：\n$$\n-\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} = \\mathbf{0},\n$$\n而不可压缩流体的质量守恒给出：\n$$\n\\nabla \\cdot \\mathbf{u} = 0.\n$$\n牛顿流体的柯西应力张量为：\n$$\n\\boldsymbol{\\sigma} = -p \\mathbf{I} + \\mu\\left(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top\\right),\n$$\n作用在具有单位外法向量 $\\mathbf{n}$ 的边界上的牵引力矢量定义为：\n$$\n\\mathbf{t} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}.\n$$\n在制造解方法（Method of Manufactured Solutions, MMS）中，我们预先指定一个光滑、无散的速度场 $\\mathbf{u}$ 和压力场 $p$，计算出使这些场精确满足控制方程的相应体积力 $\\mathbf{f}$，然后推导解析边界数据（例如牵引力）以验证诺伊曼或罗宾边界条件的实现。罗宾边界条件以混合形式给出：\n$$\n\\alpha \\,\\mathbf{u} + \\beta \\,\\mathbf{t} = \\mathbf{g},\n$$\n其中 $\\alpha$ 和 $\\beta$ 是给定的系数，$\\mathbf{g}$ 是应施加的目标边界函数；当 $\\beta = 0$ 或 $\\alpha = 0$ 时，该条件分别推广为狄利克雷和诺伊曼类型。\n\n设域为单位正方形 $\\Omega = [0,1]\\times[0,1]$。构造以下光滑的无散速度场和压力场：\n$$\n\\mathbf{u}(x,y) = \\begin{bmatrix}\n\\sin(\\pi x)\\,\\sin(\\pi y) \\\\\n\\cos(\\pi x)\\,\\cos(\\pi y)\n\\end{bmatrix}, \\qquad\np(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y).\n$$\n仅使用上述控制方程和定义作为基本依据，推导所需体积力 $\\mathbf{f}(x,y)$ 的表达式，以及边界 $\\partial\\Omega$ 各部分上的牵引力矢量 $\\mathbf{t}(x,y)$ 的表达式，其中在 $x=0$ 处单位外法向量为 $\\mathbf{n} = (-1,0)$，在 $x=1$ 处为 $\\mathbf{n} = (1,0)$，在 $y=0$ 处为 $\\mathbf{n} = (0,-1)$，在 $y=1$ 处为 $\\mathbf{n} = (0,1)$。然后，对于给定的系数 $\\alpha$ 和 $\\beta$，使用 $\\mathbf{g} = \\alpha \\mathbf{u} + \\beta \\mathbf{t}$ 推导制造的罗宾目标 $\\mathbf{g}(x,y)$。\n\n您的程序必须精确实现这些推导出的表达式，并为以下测试套件评估它们。所有答案必须以要求的单位表示，并且程序报告的数值必须符合指定格式。单位：速度分量 $\\mathbf{u}$ 单位为米/秒（m/s），压力 $p$ 单位为帕斯卡（Pa），粘度 $\\mu$ 单位为帕斯卡-秒（Pa·s），牵引力分量 $\\mathbf{t}$ 单位为帕斯卡（Pa），体积力分量 $\\mathbf{f}$ 单位为牛顿/立方米（N/m$^3$）。不使用角度，因此不需要角度单位。\n\n测试套件规范：\n- 边界测试 1（左边界）：粘度 $\\mu = 0.7$ Pa·s，系数 $\\alpha = 3.0$ Pa·s/m，$\\beta = 0.5$（无量纲），位置 $(x,y) = (0,0.6)$，单位外法向量 $\\mathbf{n} = (-1,0)$。计算牵引力分量 $\\mathbf{t}(x,y)$ 和罗宾目标 $\\mathbf{g}(x,y)$。\n- 边界测试 2（上边界）：粘度 $\\mu = 1.0$ Pa·s，系数 $\\alpha = 2.0$ Pa·s/m，$\\beta = 1.0$（无量纲），位置 $(x,y) = (0.3,1)$，单位外法向量 $\\mathbf{n} = (0,1)$。计算牵引力分量 $\\mathbf{t}(x,y)$ 和罗宾目标 $\\mathbf{g}(x,y)$。\n- 边界测试 3（右边界）：粘度 $\\mu = 2.5$ Pa·s，系数 $\\alpha = 0.0$ Pa·s/m，$\\beta = 1.0$（无量纲），位置 $(x,y) = (1,0.25)$，单位外法向量 $\\mathbf{n} = (1,0)$。计算牵引力分量 $\\mathbf{t}(x,y)$ 和罗宾目标 $\\mathbf{g}(x,y)$。\n- 内部测试 4：粘度 $\\mu = 0.7$ Pa·s，位置 $(x,y) = (0.1,0.9)$。计算体积力分量 $\\mathbf{f}(x,y)$ 和残差向量 $\\mathbf{r}(x,y) = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f}$ 的欧几里得范数，对于正确的制造解，该值应为 $0$。\n- 内部测试 5：粘度 $\\mu = 1.8$ Pa·s，位置 $(x,y) = (0.75,0.35)$。计算体积力分量 $\\mathbf{f}(x,y)$ 和 $\\mathbf{r}(x,y)$ 的欧几里得范数。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表，该列表用方括号括起来，每个测试的结果本身也是一个列表：\n- 对于每个边界测试，输出列表 $[\\;t_x,\\;t_y,\\;g_x,\\;g_y\\;]$，其中 $t_x,t_y$ 的所有分量为浮点数，单位为帕斯卡，$g_x,g_y$ 的单位也为帕斯卡。\n- 对于每个内部测试，输出列表 $[\\;f_x,\\;f_y,\\;\\|\\mathbf{r}\\|\\;]$，其中 $f_x,f_y$ 的单位为牛顿/立方米，$\\|\\mathbf{r}\\|$ 为一个浮点数。\n\n例如，最终输出格式必须是\n$$\n[\\,[\\text{case1\\_values}],\\,[\\text{case2\\_values}],\\,[\\text{case3\\_values}],\\,[\\text{case4\\_values}],\\,[\\text{case5\\_values}]\\,],\n$$\n不含任何附加文本。", "solution": "该问题被评估为有效。它在斯托克斯方程的制造解方法（MMS）标准框架内，提出了一个适定且具有科学依据的任务。所有必要的定义、方程和数据均已提供，并且它们内部一致。经确认，所制造的速度场是无散的，这是一个关键的自洽性检验。\n\n求解过程首先推导体积力 $\\mathbf{f}$、牵引力矢量 $\\mathbf{t}$ 和罗宾边界目标 $\\mathbf{g}$ 的解析表达式。然后实现这些表达式，以计算指定测试用例所需的值。\n\n### 第一步：不可压缩性验证\n制造的速度场由下式给出：\n$$\n\\mathbf{u}(x,y) = \\begin{bmatrix} u(x,y) \\\\ v(x,y) \\end{bmatrix} = \\begin{bmatrix} \\sin(\\pi x)\\,\\sin(\\pi y) \\\\ \\cos(\\pi x)\\,\\cos(\\pi y) \\end{bmatrix}.\n$$\n对于不可压缩流体，$\\mathbf{u}$ 的散度必须为零：$\\nabla \\cdot \\mathbf{u} = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y} = 0$。\n偏导数是：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} (\\sin(\\pi x)\\,\\sin(\\pi y)) = \\pi \\cos(\\pi x)\\,\\sin(\\pi y)\n$$\n$$\n\\frac{\\partial v}{\\partial y} = \\frac{\\partial}{\\partial y} (\\cos(\\pi x)\\,\\cos(\\pi y)) = -\\pi \\cos(\\pi x)\\,\\sin(\\pi y)\n$$\n因此，散度为：\n$$\n\\nabla \\cdot \\mathbf{u} = \\pi \\cos(\\pi x)\\,\\sin(\\pi y) - \\pi \\cos(\\pi x)\\,\\sin(\\pi y) = 0.\n$$\n该速度场确实是无散的，从而验证了问题的一个关键前提。\n\n### 第二步：制造体积力 $\\mathbf{f}$ 的推导\n体积力 $\\mathbf{f}$ 通过重新排列斯托克斯动量方程来确定：$\\mathbf{f} = \\nabla p - \\mu \\nabla^2 \\mathbf{u}$。\n\n首先，我们计算压力 $p(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y)$ 的梯度 $\\nabla p$：\n$$\n\\nabla p = \\begin{bmatrix} \\frac{\\partial p}{\\partial x} \\\\ \\frac{\\partial p}{\\partial y} \\end{bmatrix} = \\begin{bmatrix} \\pi \\cos(\\pi x)\\,\\cos(\\pi y) \\\\ -\\pi \\sin(\\pi x)\\,\\sin(\\pi y) \\end{bmatrix}.\n$$\n\n接下来，我们计算速度场的拉普拉斯算子，$\\nabla^2 \\mathbf{u} = \\begin{bmatrix} \\nabla^2 u \\\\ \\nabla^2 v \\end{bmatrix}$。\n对于 x 分量 $u(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$:\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y), \\qquad \\frac{\\partial^2 u}{\\partial y^2} = -\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n$$\n\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = -2\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y) = -2\\pi^2 u.\n$$\n对于 y 分量 $v(x,y) = \\cos(\\pi x)\\,\\cos(\\pi y)$:\n$$\n\\frac{\\partial^2 v}{\\partial x^2} = -\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y), \\qquad \\frac{\\partial^2 v}{\\partial y^2} = -\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y)\n$$\n$$\n\\nabla^2 v = \\frac{\\partial^2 v}{\\partial x^2} + \\frac{\\partial^2 v}{\\partial y^2} = -2\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y) = -2\\pi^2 v.\n$$\n所以，矢量拉普拉斯算子是 $\\nabla^2 \\mathbf{u} = -2\\pi^2 \\mathbf{u}$。\n\n结合这些项，体积力 $\\mathbf{f} = [f_x, f_y]^\\top$ 为：\n$$\n\\mathbf{f} = \\nabla p - \\mu(-2\\pi^2 \\mathbf{u}) = \\nabla p + 2\\mu\\pi^2 \\mathbf{u}\n$$\n$$\nf_x(x,y) = \\pi \\cos(\\pi x)\\,\\cos(\\pi y) + 2\\mu\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y)\n$$\n$$\nf_y(x,y) = -\\pi \\sin(\\pi x)\\,\\sin(\\pi y) + 2\\mu\\pi^2 \\cos(\\pi x)\\,\\cos(\\pi y)\n$$\n根据此构造，残差 $\\mathbf{r} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f}$ 恒为零，因此其范数 $\\|\\mathbf{r}\\|$ 为 $0$。\n\n### 第三步：牵引力矢量 $\\mathbf{t}$ 的推导\n牵引力矢量为 $\\mathbf{t} = \\boldsymbol{\\sigma} \\cdot \\mathbf{n}$，其中 $\\boldsymbol{\\sigma} = -p \\mathbf{I} + \\mu(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top)$。\n\n首先，我们求速度梯度张量 $\\nabla \\mathbf{u}$：\n$$\n\\nabla \\mathbf{u} = \\begin{bmatrix} \\frac{\\partial u}{\\partial x} & \\frac{\\partial u}{\\partial y} \\\\ \\frac{\\partial v}{\\partial x} & \\frac{\\partial v}{\\partial y} \\end{bmatrix} = \\pi \\begin{bmatrix} \\cos(\\pi x)\\sin(\\pi y) & \\sin(\\pi x)\\cos(\\pi y) \\\\ -\\sin(\\pi x)\\cos(\\pi y) & -\\cos(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\n应变率张量的对称部分是 $\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top$：\n$$\n\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^\\top = \\pi \\begin{bmatrix} 2\\cos(\\pi x)\\sin(\\pi y) & 0 \\\\ 0 & -2\\cos(\\pi x)\\sin(\\pi y) \\end{bmatrix}.\n$$\n柯西应力张量 $\\boldsymbol{\\sigma}$ 的分量为：\n$$\n\\sigma_{xx} = -p + 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y) = -\\sin(\\pi x)\\cos(\\pi y) + 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y)\n$$\n$$\n\\sigma_{yy} = -p - 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y) = -\\sin(\\pi x)\\cos(\\pi y) - 2\\mu\\pi\\cos(\\pi x)\\sin(\\pi y)\n$$\n$$\n\\sigma_{xy} = \\sigma_{yx} = 0.\n$$\n牵引力矢量 $\\mathbf{t} = [t_x, t_y]^\\top$ 计算如下 $\\mathbf{t} = \\boldsymbol{\\sigma}\\mathbf{n} = [\\sigma_{xx}n_x + \\sigma_{xy}n_y, \\sigma_{yx}n_x + \\sigma_{yy}n_y]^\\top$。由于非对角线应力为零，这简化为 $t_x = \\sigma_{xx} n_x$ 和 $t_y = \\sigma_{yy} n_y$。\n\n每个边界上牵引力的具体表达式为：\n-   **左边界 ($x=0, \\mathbf{n}=(-1,0)$):**\n    $\\sigma_{xx}(0,y) = 2\\mu\\pi\\sin(\\pi y)$。\n    $t_x(0,y) = \\sigma_{xx}(0,y) \\cdot (-1) = -2\\mu\\pi\\sin(\\pi y)$。\n    $t_y(0,y) = 0$。\n-   **右边界 ($x=1, \\mathbf{n}=(1,0)$):**\n    $\\sigma_{xx}(1,y) = -2\\mu\\pi\\sin(\\pi y)$。\n    $t_x(1,y) = \\sigma_{xx}(1,y) \\cdot (1) = -2\\mu\\pi\\sin(\\pi y)$。\n    $t_y(1,y) = 0$。\n-   **下边界 ($y=0, \\mathbf{n}=(0,-1)$):**\n    $\\sigma_{yy}(x,0) = -\\sin(\\pi x)$。\n    $t_x(x,0) = 0$。\n    $t_y(x,0) = \\sigma_{yy}(x,0) \\cdot (-1) = \\sin(\\pi x)$。\n-   **上边界 ($y=1, \\mathbf{n}=(0,1)$):**\n    $\\sigma_{yy}(x,1) = \\sin(\\pi x)$。\n    $t_x(x,1) = 0$。\n    $t_y(x,1) = \\sigma_{yy}(x,1) \\cdot (1) = \\sin(\\pi x)$。\n\n### 第四步：罗宾目标函数 $\\mathbf{g}$ 的推导\n罗宾目标函数 $\\mathbf{g}$ 定义为 $\\mathbf{g} = \\alpha \\mathbf{u} + \\beta \\mathbf{t}$。其分量为：\n$$\ng_x = \\alpha u + \\beta t_x\n$$\n$$\ng_y = \\alpha v + \\beta t_y\n$$\n这些是在边界上使用在指定位置 $(x,y)$ 处求值的 $\\mathbf{u}$ 和 $\\mathbf{t}$ 的表达式计算得出的。\n\n### 第五步：算法实现\n推导出的解析表达式使用 `numpy` 库在 Python 中直接实现，用于数学常数和函数。\n1.  函数 `vel(x, y)` 计算速度分量 $u$ 和 $v$。\n2.  函数 `body_force(x, y, mu)` 计算体积力分量 $f_x$ 和 $f_y$。\n3.  函数 `traction(x, y, mu, n)` 使用应力张量表达式和给定的法向量 $\\mathbf{n}$ 计算牵引力分量 $t_x$ 和 $t_y$。\n4.  主脚本遍历指定的测试用例。\n    -   对于边界测试，它调用 `vel` 和 `traction` 函数。然后使用给定的 $\\alpha$ 和 $\\beta$ 系数组合它们的结果，以计算罗宾目标 $\\mathbf{g}$。结果 $[t_x, t_y, g_x, g_y]$ 被存储。\n    -   对于内部测试，它调用 `body_force` 函数。通过构造已知残差范数 $\\|\\mathbf{r}\\|$ 为 $0$，因此直接附加此值。结果 $[f_x, f_y, \\|\\mathbf{r}\\|]$ 被存储。\n5.  最后，收集的结果被格式化为单个字符串，表示一个列表的列表，如问题所指定，并打印到标准输出。", "answer": "```python\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the Method of Manufactured Solutions problem for Stokes flow.\n    \"\"\"\n    pi = np.pi\n\n    def get_vel(x, y):\n        \"\"\"Computes the manufactured velocity field components.\"\"\"\n        px, py = pi * x, pi * y\n        u = np.sin(px) * np.sin(py)\n        v = np.cos(px) * np.cos(py)\n        return u, v\n\n    def get_body_force(x, y, mu):\n        \"\"\"Computes the manufactured body force components.\"\"\"\n        px, py = pi * x, pi * y\n        spx, cpx = np.sin(px), np.cos(px)\n        spy, cpy = np.sin(py), np.cos(py)\n        \n        fx = pi * cpx * cpy + 2 * mu * pi**2 * spx * spy\n        fy = -pi * spx * spy + 2 * mu * pi**2 * cpx * cpy\n        return fx, fy\n\n    def get_traction(x, y, mu, n):\n        \"\"\"Computes the traction vector components on a boundary.\"\"\"\n        nx, ny = n\n        px, py = pi * x, pi * y\n        spx, cpx = np.sin(px), np.cos(px)\n        spy, cpy = np.sin(py), np.cos(py)\n\n        sigma_xx = -spx * cpy + 2 * mu * pi * cpx * spy\n        sigma_yy = -spx * cpy - 2 * mu * pi * cpx * spy\n        \n        # sigma_xy is 0, so traction components are simplified\n        tx = sigma_xx * nx\n        ty = sigma_yy * ny\n        return tx, ty\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Boundary test 1 (left)\n        {'type': 'boundary', 'params': {'mu': 0.7, 'alpha': 3.0, 'beta': 0.5, 'x': 0.0, 'y': 0.6, 'n': (-1.0, 0.0)}},\n        # Boundary test 2 (top)\n        {'type': 'boundary', 'params': {'mu': 1.0, 'alpha': 2.0, 'beta': 1.0, 'x': 0.3, 'y': 1.0, 'n': (0.0, 1.0)}},\n        # Boundary test 3 (right)\n        {'type': 'boundary', 'params': {'mu': 2.5, 'alpha': 0.0, 'beta': 1.0, 'x': 1.0, 'y': 0.25, 'n': (1.0, 0.0)}},\n        # Interior test 4\n        {'type': 'interior', 'params': {'mu': 0.7, 'x': 0.1, 'y': 0.9}},\n        # Interior test 5\n        {'type': 'interior', 'params': {'mu': 1.8, 'x': 0.75, 'y': 0.35}},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'boundary':\n            params = case['params']\n            mu, alpha, beta, x, y, n = params['mu'], params['alpha'], params['beta'], params['x'], params['y'], params['n']\n            \n            u_val, v_val = get_vel(x, y)\n            tx_val, ty_val = get_traction(x, y, mu, n)\n            \n            gx_val = alpha * u_val + beta * tx_val\n            gy_val = alpha * v_val + beta * ty_val\n            \n            results.append([tx_val, ty_val, gx_val, gy_val])\n\n        elif case['type'] == 'interior':\n            params = case['params']\n            mu, x, y = params['mu'], params['x'], params['y']\n            \n            fx_val, fy_val = get_body_force(x, y, mu)\n            # The residual is zero by construction in the Method of Manufactured Solutions.\n            residual_norm = 0.0\n            \n            results.append([fx_val, fy_val, residual_norm])\n\n    # Final print statement in the exact required format.\n    # The default str() representation for a list provides the required spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3376865"}, {"introduction": "除了验证基本离散格式，制造解方法还能用于探究更深层次的数值问题，例如在弯曲网格上对几何守恒律（Geometric Conservation Law, GCL）的满足情况。理论上，均匀流场应作为无源欧拉方程的精确解被完美保持，但在离散层面，网格度量项的计算误差可能会破坏这一特性。这项实践旨在通过在一个扭曲的网格上检验均匀流的保持能力，来量化由于坐标变换引起的自由流保持误差。[@problem_id:3376848]", "problem": "考虑二维可压缩欧拉方程，其以物理坐标 $(x,y)$ 写成守恒形式，守恒变量向量为 $Q = [\\rho,\\rho u,\\rho v,\\rho E]^\\top$，在 $x$ 和 $y$ 方向上的笛卡尔通量分别为 $F(Q)$ 和 $G(Q)$。本问题的基础是由 $\\partial_t Q + \\partial_x F + \\partial_y G = 0$ 体现的质量、动量和能量守恒，以及一个从均匀计算域 $(\\xi,\\eta)\\in[0,1]\\times[0,1]$ 到物理域的光滑映射 $\\mathbf{x}(\\xi,\\eta) = (x(\\xi,\\eta),y(\\xi,\\eta))$ 的定义。您需要构造一个在空间和时间上恒定且源项为零的均匀自由来流状态 $(\\rho,u,v,p)$，并通过计算网格上计算的逆变质量通量的散度，来评估在扭曲网格上的离散自由来流保持性。\n\n从物理坐标系下的基本守恒律和通过 $\\mathbf{x}(\\xi,\\eta)$ 定义的光滑变量变换出发，推导计算坐标系下的强守恒律形式及相关的逆变质量通量。在连续形式下，对于恒定的 $(\\rho,u,v,p)$，自由来流保持性关键取决于映射导数和雅可比行列式所满足的度量恒等式。在离散形式下，所选的有限差分近似若违反了这些恒等式，即使对于均匀状态也会产生非零残差。\n\n在单个、自包含的程序中实现以下内容：\n- 使用一个均匀计算网格，在 $\\xi$ 方向有 $N_\\xi$ 个点，在 $\\eta$ 方向有 $N_\\eta$ 个点，并采用周期性边界条件。设网格间距为 $\\Delta \\xi = 1/N_\\xi$ 和 $\\Delta \\eta = 1/N_\\eta$。\n- 通过以下公式定义一个扭曲映射 $\\mathbf{x}(\\xi,\\eta)$：\n$$\nx(\\xi,\\eta) = \\xi + \\alpha \\sin(2\\pi \\xi)\\sin(2\\pi \\eta), \\qquad\ny(\\xi,\\eta) = \\eta + \\beta \\cos(2\\pi \\xi)\\sin(2\\pi \\eta),\n$$\n其中 $\\alpha$ 和 $\\beta$ 是实值扭曲振幅。所有量均为无量纲。\n- 使用二阶中心差分和周期性边界条件，在计算网格上计算离散度量导数 $x_\\xi, x_\\eta, y_\\xi, y_\\eta$ 和离散雅可比行列式 $J = x_\\xi y_\\eta - x_\\eta y_\\xi$。对所有偏导数使用相同的离散算子。\n- 构造一个均匀自由来流状态，其常数 $(\\rho,u,v,p)$ 不随 $(\\xi,\\eta)$ 变化，并设置源项为零。具体使用常数值 $\\rho = 1$，$u = 0.7$，$v = -0.2$ 和 $p = 1$。\n- 对于质量守恒方程，构建离散逆变质量通量：\n$$\n\\widehat{F}_\\rho = y_\\eta \\,\\rho u - x_\\eta \\,\\rho v, \\qquad\n\\widehat{G}_\\rho = -y_\\xi \\,\\rho u + x_\\xi \\,\\rho v,\n$$\n然后计算离散散度：\n$$\nR_\\rho = \\partial_\\xi\\!\\left(\\frac{\\widehat{F}_\\rho}{J}\\right) + \\partial_\\eta\\!\\left(\\frac{\\widehat{G}_\\rho}{J}\\right),\n$$\n使用相同的二阶中心差分和周期性边界条件。这个 $R_\\rho$ 是为自由来流质量方程构造的残差；精确的自由来流保持性对应于 $R_\\rho \\equiv 0$。\n- 将自由来流保持性误差量化为 $R_\\rho$ 在网格上的离散 $\\ell_2$ 范数：\n$$\n\\|R_\\rho\\|_2 = \\sqrt{\\frac{1}{N_\\xi N_\\eta}\\sum_{i=0}^{N_\\xi-1}\\sum_{j=0}^{N_\\eta-1} \\left(R_{\\rho,ij}\\right)^2 }.\n$$\n将每个测试案例的此误差报告为浮点数。\n\n使用以下测试套件来探究映射强度和分辨率的影响：\n- 测试 1：$N_\\xi = 32$，$N_\\eta = 32$，$\\alpha = 0$，$\\beta = 0$（均匀网格上的恒等映射；预期可以精确离散保持的边界情况）。\n- 测试 2：$N_\\xi = 32$，$N_\\eta = 32$，$\\alpha = 0.10$，$\\beta = 0.10$（轻度扭曲网格）。\n- 测试 3：$N_\\xi = 64$，$N_\\eta = 64$，$\\alpha = 0.30$，$\\beta = 0.25$（较高分辨率的强扭曲网格）。\n- 测试 4：$N_\\xi = 16$，$N_\\eta = 16$，$\\alpha = 0.30$，$\\beta = 0.25$（粗糙分辨率的强扭曲网格；离散化误差的边缘情况）。\n- 测试 5：$N_\\xi = 64$，$N_\\eta = 16$，$\\alpha = 0.30$，$\\beta = 0.05$（具有中等扭曲的各向异性分辨率）。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中 $r_k$ 是为测试案例 $k$ 计算出的 $\\ell_2$ 误差。所有值都是无量纲的，应报告为标准浮点数。无需用户输入。", "solution": "该问题要求量化在扭曲网格上二维可压缩欧拉方程的自由来流保持性误差。这是计算流体动力学 (CFD) 中一种标准的验证程序，用于评估数值格式在非笛卡尔网格上的质量。问题的核心在于，虽然均匀流场应该是连续控制方程的精确解，但其离散近似通常会产生非零残差，这是因为离散几何算子未能完美地复制连续微积分的恒等式。\n\n分析始于物理域 $\\Omega$ 及其边界 $\\partial\\Omega$ 上一个通用守恒律的积分形式：\n$$\n\\frac{d}{dt} \\int_{\\Omega} Q \\, dV + \\oint_{\\partial\\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, dS = \\int_{\\Omega} S \\, dV\n$$\n其中 $Q$ 是守恒变量的向量，$\\mathbf{F}$ 是通量张量，$\\mathbf{n}$ 是向外的单位法向量，$S$ 是源项。对于二维欧拉方程，$Q = [\\rho, \\rho u, \\rho v, \\rho E]^\\top$，并且问题指出源项为零，$S=0$。\n\n引入一个从物理坐标 $(x,y)$到计算坐标 $(\\xi,\\eta)$ 的坐标变换，由映射 $\\mathbf{x}(\\xi,\\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$ 定义。物理坐标系下守恒律的微分形式为 $\\partial_t Q + \\partial_x F + \\partial_y G = 0$。应用链式法则将此方程变换到计算域。结果是强守恒律形式：\n$$\n\\partial_t (J Q) + \\partial_\\xi \\widehat{F} + \\partial_\\eta \\widehat{G} = 0\n$$\n这里，$J = x_\\xi y_\\eta - x_\\eta y_\\xi$ 是变换的雅可比行列式，表示微分面积之比 $dx\\,dy = J\\,d\\xi\\,d\\eta$。量 $\\widehat{F}$ 和 $\\widehat{G}$ 是逆变通量向量，定义为：\n$$\n\\widehat{F} = J(\\xi_x F + \\xi_y G)\n\\qquad\n\\widehat{G} = J(\\eta_x F + \\eta_y G)\n$$\n项 $\\xi_x, \\xi_y, \\eta_x, \\eta_y$ 是变换的度量项。它们可以用映射 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$ 的导数通过以下度量恒等式表示：\n$$\n\\xi_x = \\frac{y_\\eta}{J}, \\quad \\xi_y = -\\frac{x_\\eta}{J}, \\quad \\eta_x = -\\frac{y_\\xi}{J}, \\quad \\eta_y = \\frac{x_\\xi}{J}\n$$\n问题关注的是质量守恒方程，即该系统的第一个分量。对于质量守恒，守恒变量是密度 $\\rho$，笛卡尔通量是 $F_\\rho = \\rho u$ 和 $G_\\rho = \\rho v$。将度量恒等式代入质量方程的逆变通量定义中，得到：\n$$\n\\widehat{F}_\\rho = J(\\xi_x (\\rho u) + \\xi_y (\\rho v)) = J\\left(\\frac{y_\\eta}{J} \\rho u - \\frac{x_\\eta}{J} \\rho v\\right) = y_\\eta \\rho u - x_\\eta \\rho v\n$$\n$$\n\\widehat{G}_\\rho = J(\\eta_x (\\rho u) + \\eta_y (\\rho v)) = J\\left(-\\frac{y_\\xi}{J} \\rho u + \\frac{x_\\xi}{J} \\rho v\\right) = -y_\\xi \\rho u + x_\\xi \\rho v\n$$\n这些表达式与问题陈述中提供的定义相匹配。\n\n对于一个稳定 ($\\partial_t = 0$)、均匀的自由来流，状态变量 $(\\rho, u, v, p)$ 在整个域中是常数。稳态下的变换后质量守恒方程为 $\\partial_\\xi \\widehat{F}_\\rho + \\partial_\\eta \\widehat{G}_\\rho = 0$。代入通量的表达式，并注意到 $\\rho, u, v$ 是常数，我们得到：\n$$\n\\partial_\\xi(y_\\eta \\rho u - x_\\eta \\rho v) + \\partial_\\eta(-y_\\xi \\rho u + x_\\xi \\rho v) = 0\n$$\n$$\n\\rho u (\\partial_\\xi y_\\eta - \\partial_\\eta y_\\xi) + \\rho v (-\\partial_\\xi x_\\eta + \\partial_\\eta x_\\xi) = 0\n$$\n在连续微积分中，对于光滑映射，求导次序是可交换的（克莱罗定理, Clairaut's theorem），这意味着 $\\partial_\\xi y_\\eta = \\partial_{\\xi\\eta} y = \\partial_{\\eta\\xi} y = \\partial_\\eta y_\\xi$。因此，括号中的项，即几何守恒律 (GCL) 恒等式，恒等于零：\n$$\n\\partial_\\xi y_\\eta - \\partial_\\eta y_\\xi = 0 \\quad \\text{和} \\quad \\partial_\\eta x_\\xi - \\partial_\\xi x_\\eta = 0\n$$\n这证实了均匀自由来流是连续变换方程的精确解。\n\n然而，当离散化时，这些恒等式可能不成立。问题指定使用二阶中心差分算子（此处表示为 $\\delta_\\xi$ 和 $\\delta_\\eta$）来近似偏导数。对于网格上的通用函数 $f_{ij}$，它们是：\n$$\n(\\delta_\\xi f)_{ij} = \\frac{f_{i+1,j} - f_{i-1,j}}{2 \\Delta\\xi}, \\qquad (\\delta_\\eta f)_{ij} = \\frac{f_{i,j+1} - f_{i,j-1}}{2 \\Delta\\eta}\n$$\n通常，离散算子是不可交换的，即 $\\delta_\\xi(\\delta_\\eta f) \\neq \\delta_\\eta(\\delta_\\xi f)$。在离散层面未能满足 GCL 会引入一个类源项误差，导致数值格式对均匀流产生非零残差。\n\n问题将质量方程的残差定义为：\n$$\nR_\\rho = \\partial_\\xi\\left(\\frac{\\widehat{F}_\\rho}{J}\\right) + \\partial_\\eta\\left(\\frac{\\widehat{G}_\\rho}{J}\\right)\n$$\n这种形式是在离散化之前将变换后的方程重排为 $\\partial_t Q + \\frac{1}{J}(\\partial_\\xi \\widehat{F} + \\partial_\\eta \\widehat{G})=0$ 而得到的。对于稳态，残差 $R_\\rho$ 应为零。\n\n计算自由来流保持性误差的算法如下：\n1.  定义具有 $N_\\xi \\times N_\\eta$ 个点和网格间距 $\\Delta\\xi = 1/N_\\xi$, $\\Delta\\eta = 1/N_\\eta$ 的计算网格 $(\\xi_{ij}, \\eta_{ij})$。网格点为 $\\xi_i = i\\Delta\\xi$ for $i \\in \\{0, \\dots, N_\\xi-1\\}$ 和 $\\eta_j = j\\Delta\\eta$ for $j \\in \\{0, \\dots, N_\\eta-1\\}$。\n2.  使用提供的映射函数在每个网格点上计算物理坐标 $(x_{ij}, y_{ij})$：\n    $$\n    x(\\xi,\\eta) = \\xi + \\alpha \\sin(2\\pi \\xi)\\sin(2\\pi \\eta), \\qquad y(\\xi,\\eta) = \\eta + \\beta \\cos(2\\pi \\xi)\\sin(2\\pi \\eta)\n    $$\n3.  使用带周期性边界条件的二阶中心差分算子计算离散度量导数 $(x_\\xi)_{ij}, (x_\\eta)_{ij}, (y_\\xi)_{ij}, (y_\\eta)_{ij}$。\n4.  在每个网格点上计算离散雅可比行列式：$J_{ij} = (x_\\xi)_{ij} (y_\\eta)_{ij} - (x_\\eta)_{ij} (y_\\xi)_{ij}$。\n5.  设置自由来流状态常数：$\\rho = 1$, $u = 0.7$, $v = -0.2$。\n6.  在每个点上构建离散逆变质量通量：\n    $$\n    (\\widehat{F}_\\rho)_{ij} = (y_\\eta)_{ij} \\,\\rho u - (x_\\eta)_{ij} \\,\\rho v, \\qquad (\\widehat{G}_\\rho)_{ij} = -(y_\\xi)_{ij} \\,\\rho u + (x_\\xi)_{ij} \\,\\rho v\n    $$\n7.  计算通量密度 $\\Phi_{ij} = (\\widehat{F}_\\rho)_{ij} / J_{ij}$ 和 $\\Psi_{ij} = (\\widehat{G}_\\rho)_{ij} / J_{ij}$。\n8.  通过对通量密度应用中心差分算子来计算离散残差场 $R_{\\rho,ij}$：\n    $$\n    R_{\\rho,ij} = (\\delta_\\xi \\Phi)_{ij} + (\\delta_\\eta \\Psi)_{ij}\n    $$\n9.  通过计算残差场的离散 $\\ell_2$ 范数来量化总误差：\n    $$\n    \\|R_\\rho\\|_2 = \\sqrt{\\frac{1}{N_\\xi N_\\eta}\\sum_{i=0}^{N_\\xi-1}\\sum_{j=0}^{N_\\eta-1} \\left(R_{\\rho,ij}\\right)^2 }\n    $$\n对于恒等映射（$\\alpha=0, \\beta=0$），网格是笛卡尔网格（$x=\\xi, y=\\eta$），度量导数是常数（$x_\\xi=1, y_\\eta=1, x_\\eta=0, y_\\xi=0$），雅可比行列式是 $J=1$ ，逆变通量 $\\widehat{F}_\\rho, \\widehat{G}_\\rho$ 是常数。常数场的离散导数精确为零，因此残差 $R_\\rho$ 及其范数必须为零（在机器精度内），这提供了一个关键的验证检查。对于非零的 $\\alpha$ 和 $\\beta$，预计会产生非零误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_error(N_xi, N_eta, alpha, beta):\n    \"\"\"\n    Computes the l2-norm of the free-stream preservation residual for the mass equation.\n\n    Args:\n        N_xi (int): Number of grid points in the xi-direction.\n        N_eta (int): Number of grid points in the eta-direction.\n        alpha (float): Warp amplitude for the x-coordinate.\n        beta (float): Warp amplitude for the y-coordinate.\n\n    Returns:\n        float: The discrete l2-norm of the residual field.\n    \"\"\"\n    # Define free-stream state constants\n    rho = 1.0\n    u = 0.7\n    v = -0.2\n    # p = 1.0 (not needed for mass conservation)\n\n    # 1. Define the computational grid\n    delta_xi = 1.0 / N_xi\n    delta_eta = 1.0 / N_eta\n\n    xi_1d = np.linspace(0, 1.0, N_xi, endpoint=False)\n    eta_1d = np.linspace(0, 1.0, N_eta, endpoint=False)\n    xi, eta = np.meshgrid(xi_1d, eta_1d, indexing='ij')\n\n    # 2. Compute physical coordinates from the mapping\n    x = xi + alpha * np.sin(2 * np.pi * xi) * np.sin(2 * np.pi * eta)\n    y = eta + beta * np.cos(2 * np.pi * xi) * np.sin(2 * np.pi * eta)\n\n    # Helper function for centered differences with periodic boundary conditions\n    def centered_diff(field, delta, axis):\n        \"\"\"Computes 2nd order centered differences on a periodic grid.\"\"\"\n        # axis=0 corresponds to xi-derivative (row-wise in 'ij' indexing)\n        # axis=1 corresponds to eta-derivative (column-wise in 'ij' indexing)\n        np_axis = axis \n        \n        f_plus_1 = np.roll(field, -1, axis=np_axis)\n        f_minus_1 = np.roll(field, 1, axis=np_axis)\n        return (f_plus_1 - f_minus_1) / (2.0 * delta)\n\n    # 3. Calculate discrete metric derivatives\n    x_xi = centered_diff(x, delta_xi, axis=0)\n    x_eta = centered_diff(x, delta_eta, axis=1)\n    y_xi = centered_diff(y, delta_xi, axis=0)\n    y_eta = centered_diff(y, delta_eta, axis=1)\n\n    # 4. Compute the discrete Jacobian\n    J = x_xi * y_eta - x_eta * y_xi\n\n    # Check for non-positive Jacobian, which indicates grid folding\n    if np.any(J = 0):\n        # This should not happen for the given parameters but is good practice\n        # to check. For this specific problem, we proceed as specified.\n        pass\n\n    # 5. Form the discrete contravariant mass fluxes\n    F_hat_rho = y_eta * rho * u - x_eta * rho * v\n    G_hat_rho = -y_xi * rho * u + x_xi * rho * v\n    \n    # 6. Compute flux densities\n    Phi = F_hat_rho / J\n    Psi = G_hat_rho / J\n\n    # 7. Compute the discrete residual field\n    R_rho = centered_diff(Phi, delta_xi, axis=0) + centered_diff(Psi, delta_eta, axis=1)\n\n    # 8. Quantify the error using the l2-norm\n    # Note: np.mean(R_rho**2) is equivalent to (1/(N_xi*N_eta)) * sum(R_rho**2)\n    l2_error = np.sqrt(np.mean(R_rho**2))\n    \n    return l2_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N_xi, N_eta, alpha, beta)\n        (32, 32, 0.0, 0.0),      # Test 1\n        (32, 32, 0.10, 0.10),    # Test 2\n        (64, 64, 0.30, 0.25),    # Test 3\n        (16, 16, 0.30, 0.25),    # Test 4\n        (64, 16, 0.30, 0.05),    # Test 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N_xi, N_eta, alpha, beta = case\n        error = compute_error(N_xi, N_eta, alpha, beta)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3376848"}]}