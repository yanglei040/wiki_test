{"hands_on_practices": [{"introduction": "在任何计算流体动力学（CFD）模拟中，离散误差是不可避免的。为了量化由网格分辨率不足引起的解的不确定性，学术界和工业界广泛采用网格收敛指数（Grid Convergence Index, GCI）作为一种标准化的方法。本练习将引导您从第一性原理出发，推导并计算GCI，让您掌握仅利用两个不同网格上的模拟结果来评估离散不确定性的基础技能 [@problem_id:3326350]。", "problem": "在一次计算流体动力学 (CFD) 模拟中，一个标量 $S$ 在两个系统加密的网格上被计算。设 $S_1$ 表示在细网格上的值，$S_2$ 表示在中等网格上的值，中等网格和细网格的特征网格间距 $h_2$ 和 $h_1$ 之间存在一个均匀加密比 $r = h_2 / h_1 > 1$。假设该数值方法具有理论精度阶 $p$，并且在渐近区域内，离散误差满足 $|S(h) - S_{\\text{exact}}| \\approx C h^{p}$，其中 $C$ 为某个常数。网格收敛指数 (GCI) 的引入是为了量化一对网格由离散化引起的不确定性，它包含一个安全因子 $F_s$，并基于渐近范围内连续网格误差之间的关系。\n\n给定 $p = 2$，$r = 1.3$，$S_1 = 1.00$，$S_2 = 0.98$ 和 $F_s = 1.25$，请从第一性原理推导双网格网格收敛指数的表达式，并计算与细网格相关的 $\\mathrm{GCI}_{21}$。简要评论仅凭计算出的值是否足以证明这对解处于渐近范围内，并根据渐近区域的基本定义来证明你的推理。\n\n将 $\\mathrm{GCI}_{21}$ 的最终数值表示为一个无量纲小数，并四舍五入到四位有效数字。", "solution": "该问题被认为是有效的。它在科学上基于数值分析和计算流体动力学 (CFD) 的原理，特别是通过网格收敛性研究来量化离散误差的方法。该问题是适定的，提供了推导和计算网格收敛指数 (GCI) 所需的所有数据和定义（$S_1$、$S_2$、$p$、$r$、$F_s$）。语言客观明确。它与网格收敛和解的验证主题直接相关，并且不包含任何科学缺陷或不一致之处。\n\n网格收敛指数 ($\\mathrm{GCI}$) 的推导始于一个基本假设：对于足够小的特征网格间距 $h$，数值解 $S(h)$ 趋近于精确解 $S_{\\text{exact}}$，其离散误差与精度阶 $p$ 成比例。这种关系可以写成：\n$$ S(h) = S_{\\text{exact}} + C h^{p} + \\mathcal{O}(h^{p+1}) $$\n其中 $C$ 是一个常数，它取决于流动问题和数值格式，但在渐近范围内独立于 $h$。在本分析中，我们忽略高阶项。\n\n我们已知两个网格上的解：特征间距为 $h_1$ 的细网格得到解 $S_1$，间距为 $h_2$ 的中等网格得到解 $S_2$。网格加密比为 $r = h_2 / h_1$。将误差模型应用于每个网格，得到：\n$$ S_1 \\approx S_{\\text{exact}} + C h_1^p \\quad (1) $$\n$$ S_2 \\approx S_{\\text{exact}} + C h_2^p \\quad (2) $$\n将 $h_2 = r h_1$ 代入方程 (2) 中：\n$$ S_2 \\approx S_{\\text{exact}} + C (r h_1)^p = S_{\\text{exact}} + C r^p h_1^p \\quad (3) $$\n我们的目标是在不知道 $S_{\\text{exact}}$ 或 $C$ 的情况下，估计细网格解的误差 $E_1 = S_1 - S_{\\text{exact}} \\approx C h_1^p$。我们可以通过从方程 (3) 中减去方程 (1) 来消去 $S_{\\text{exact}}$：\n$$ S_2 - S_1 \\approx (S_{\\text{exact}} + C r^p h_1^p) - (S_{\\text{exact}} + C h_1^p) $$\n$$ S_2 - S_1 \\approx C h_1^p (r^p - 1) $$\n认识到 $C h_1^p$ 是细网格上误差 $E_1$ 的近似值，我们有：\n$$ S_2 - S_1 \\approx E_1 (r^p - 1) $$\n求解细网格上的估计绝对误差 $E_{a,1}$：\n$$ E_{a,1} \\approx \\frac{S_2 - S_1}{r^p - 1} $$\n这个结果也可以通过使用理查森外推法来获得一个更精确的解的估计值 $S_{\\text{ext}}$ 来得到。通过在方程 (1) 和 (3) 之间消去 $C h^p$ 项，我们得到：\n$$ S_{\\text{ext}} = \\frac{r^p S_1 - S_2}{r^p - 1} $$\n那么 $S_1$ 中的估计误差就是 $S_1$ 与这个更高阶估计值之间的差：\n$$ E_{a,1} = S_1 - S_{\\text{ext}} = S_1 - \\frac{r^p S_1 - S_2}{r^p - 1} = \\frac{S_1(r^p - 1) - (r^p S_1 - S_2)}{r^p - 1} = \\frac{S_2 - S_1}{r^p-1} $$\n细网格的网格收敛指数，记为 $\\mathrm{GCI}_{21}$，被定义为一个考虑了安全因子的相对误差度量。安全因子 $F_s$ 考虑到了分析是基于近似这一事实。$\\mathrm{GCI}_{21}$ 的表达式为：\n$$ \\mathrm{GCI}_{21} = F_s \\frac{|E_{a,1}|}{|S_1|} = F_s \\left| \\frac{(S_2 - S_1)/S_1}{r^p - 1} \\right| $$\n这就是从第一性原理推导出的所要求的表达式。\n\n现在，我们使用给定的数据计算 $\\mathrm{GCI}_{21}$ 的值：\n理论精度阶: $p = 2$\n网格加密比: $r = 1.3$\n细网格解: $S_1 = 1.00$\n中等网格解: $S_2 = 0.98$\n安全因子: $F_s = 1.25$\n\n首先，计算 $r^p - 1$ 项：\n$$ r^p - 1 = (1.3)^2 - 1 = 1.69 - 1 = 0.69 $$\n接下来，计算解之间的相对差异：\n$$ \\frac{S_2 - S_1}{S_1} = \\frac{0.98 - 1.00}{1.00} = -0.02 $$\n将这些值代入 $\\mathrm{GCI}_{21}$ 公式：\n$$ \\mathrm{GCI}_{21} = 1.25 \\times \\left| \\frac{-0.02}{0.69} \\right| = 1.25 \\times \\frac{0.02}{0.69} \\approx 1.25 \\times 0.0289855... $$\n$$ \\mathrm{GCI}_{21} \\approx 0.03623188... $$\n将结果四舍五入到四位有效数字得到 $0.03623$。这对应于大约 $3.623\\%$ 的估计不确定度。\n\n关于计算出的 $\\mathrm{GCI}_{21}$ 值本身是否足以证明解处于渐近范围内：答案是否定的。整个推导和计算都建立在模拟处于渐近范围的*假设*之上，在该范围内误差表现为 $C h^p$。双网格研究无法*验证*这一假设。要确信解处于渐近范围内，需要进行至少包含三个系统加密网格的研究。使用三个网格（例如，细网格 $S_1$、中等网格 $S_2$、粗网格 $S_3$），可以计算出*观测*或*表观*精度阶 $p_{\\text{obs}}$：\n$$ p_{\\text{obs}} = \\frac{\\ln\\left( \\frac{S_3 - S_2}{S_2 - S_1} \\right)}{\\ln(r)} $$\n如果 $p_{\\text{obs}}$ 的值接近理论精度阶 $p$，则提供了强有力的证据，表明模拟确实处于收敛的渐近范围内。如果没有这项检查，一个小的 GCI 值可能是误导性的，它可能源于解对网格加密不敏感，而原因并非是收敛到正确的连续介质解（例如，如果迭代收敛容差设置得过松）。因此，单个 $\\mathrm{GCI}_{21}$ 值是不确定性的一个估计，而不是渐近收敛的证明。", "answer": "$$ \\boxed{0.03623} $$", "id": "3326350"}, {"introduction": "上一个练习中的GCI计算依赖于一个关键的输入参数：方法的理论精度阶数 $p$。然而，在实际开发和应用中，我们必须验证代码的实现是否确实达到了其理论精度。本练习将通过精确解方法（Method of Manufactured Solutions, MMS）来解决这个问题，您将学习如何利用在三个系统加密网格上获得的误差数据来计算“观察到的”精度阶数，这是代码验证流程中的一个核心环节 [@problem_id:3326375]。", "problem": "使用制造解法 (Method of Manufactured Solutions, MMS) 验证一个稳态二维标量对流-扩散方程。该代码在均匀的笛卡尔网格上采用单元中心的有限体积 (Finite Volume, FV) 离散化方法。面法向对流通量通过在面中心评估通量得到，该评估使用基于单元中心值和最小二乘梯度的分段线性重构；而扩散通量则使用基于单元中心值的格林-高斯梯度计算，并通过算术平均将材料系数插值到面上。对于制造的光滑解，没有激活斜率限制器。空间网格是嵌套的，并以恒定的加密比进行均匀细化，且在整个计算域内，精确的 MMS 场是已知的。对于三种尺寸为 $N \\times N$（其中 $N \\in \\{32, 64, 128\\}$）的网格，标量场的离散误差以离散 $L_{1}$ 范数的形式报告。记 $h$ 为均匀的单元宽度，因此 $h_{1} = 1/32$，$h_{2} = 1/64$，$h_{3} = 1/128$，其恒定的加密比为 $r = h_{1}/h_{2} = h_{2}/h_{3} = 2$。测得的误差为\n\n$$\nE(h_{1}) = E_{1} = 3.200 \\times 10^{-3}, \\quad E(h_{2}) = E_{2} = 8.500 \\times 10^{-4}, \\quad E(h_{3}) = E_{3} = 2.200 \\times 10^{-4}.\n$$\n\n从离散误差的核心定义和一致性方法的标准渐近误差模型出发，推导一个关系式，该关系式允许从多个网格间距的数据中推断出观测到的精度阶 $p$。然后，使用上述三个误差测量值，确定该单元中心 FV 格式的观测精度阶 $p$。将你的答案四舍五入到四位有效数字，并以无量纲数的形式报告。\n\n最后，将观测到的精度阶与在均匀笛卡尔网格上采用分段线性重构和单点面通量积分的标称二阶期望值进行比较，并从重构和通量积分误差的角度，物理解释和数值解释为什么会发生与标称阶数的偏差。你的解释应基于截断误差、多项式重构和求积法的基本原理，不应引用任何黑箱公式。", "solution": "根据要求，问题的分析将分三部分进行：首先，推导观测精度阶的关系式；其次，使用所提供的数据计算该阶数；第三，解释观测阶数与标称理论阶数之间的偏差。\n\n### 第一部分：观测精度阶关系式的推导\n\n本分析的基础是一致性数值方法的渐近误差模型。对于足够小的网格间距 $h$，离散误差 $E$ 预计遵循以下关系：\n$$\nE(h) = C h^p + O(h^{p+q})\n$$\n其中 $C$ 是一个与 $h$ 无关的常数，$p$ 是该方法的形式精度阶，而 $O(h^{p+q})$ 项（$q \\ge 1$）表示误差展开中的高阶项。\n\n在渐近极限下，当 $h \\to 0$ 时，主导项占主导地位，我们可以写出近似式：\n$$\nE(h) \\approx C h^p\n$$\n为了确定观测到的精度阶 $p$，我们可以使用在至少两个不同网格上模拟得到的误差测量值。让我们考虑两个具有特征单元尺寸 $h_i$ 和 $h_j$ 的网格及其对应的误差 $E_i$ 和 $E_j$。应用渐近模型，我们有：\n$$\nE_i \\approx C h_i^p\n$$\n$$\nE_j \\approx C h_j^p\n$$\n假设在该网格间距范围内 $C$ 和 $p$ 是常数，我们可以通过对两个误差方程取比值来消去常数 $C$：\n$$\n\\frac{E_i}{E_j} \\approx \\frac{C h_i^p}{C h_j^p} = \\left(\\frac{h_i}{h_j}\\right)^p\n$$\n为了求解 $p$，我们对两边取自然对数：\n$$\n\\ln\\left(\\frac{E_i}{E_j}\\right) \\approx \\ln\\left(\\left(\\frac{h_i}{h_j}\\right)^p\\right) = p \\ln\\left(\\frac{h_i}{h_j}\\right)\n$$\n这就得到了我们所需要的观测精度阶关系式：\n$$\np \\approx \\frac{\\ln(E_i/E_j)}{\\ln(h_i/h_j)}\n$$\n该关系式可用于任意一对网格。当有三个或更多网格且具有恒定的加密比 $r = h_k/h_{k+1}$ 时（如此处所示），可以为每对连续的网格计算 $p$。然而，一个更稳健的方法是利用所有数据点，对误差模型的对数形式 $\\ln(E) = p \\ln(h) + \\ln(C)$ 进行线性最小二乘拟合。\n\n对于均匀加密的三个网格，使得点 $(\\ln(h_1), \\ln(h_2), \\ln(h_3))$ 等距分布，最小二乘法最佳拟合斜率 $p$ 与使用最外侧的两个数据点 $(h_1, E_1)$ 和 $(h_3, E_3)$ 计算出的斜率相同。因此，从这种方法推导出的关系式是：\n$$\np = \\frac{\\ln(E_1/E_3)}{\\ln(h_1/h_3)}\n$$\n这就是我们将在计算中使用的关系式。\n\n### 第二部分：观测精度阶的计算\n\n问题提供了以下数据：\n- 网格间距：$h_1 = 1/32$，$h_2 = 1/64$，$h_3 = 1/128$。\n- 恒定的网格加密比为 $r = h_1/h_2 = h_2/h_3 = 2$。\n- 测得的误差：$E_1 = 3.200 \\times 10^{-3}$，$E_2 = 8.500 \\times 10^{-4}$，以及 $E_3 = 2.200 \\times 10^{-4}$。\n\n我们使用推导出的关系式，并代入最粗网格 ($h_1, E_1$) 和最细网格 ($h_3, E_3$) 的数据，以获得在研究范围内最具代表性的精度阶。网格间距的比值为：\n$$\n\\frac{h_1}{h_3} = \\frac{1/32}{1/128} = \\frac{128}{32} = 4\n$$\n或者，由于 $h_1=rh_2=r(rh_3)=r^2 h_3$，该比值为 $r^2=2^2=4$。\n\n相应误差的比值为：\n$$\n\\frac{E_1}{E_3} = \\frac{3.200 \\times 10^{-3}}{2.200 \\times 10^{-4}} = \\frac{32}{2.2} \\approx 14.5454...\n$$\n现在，我们将这些值代入 $p$ 的公式中：\n$$\np = \\frac{\\ln(E_1/E_3)}{\\ln(h_1/h_3)} = \\frac{\\ln(14.5454...)}{\\ln(4)}\n$$\n计算数值：\n$$\np = \\frac{2.677234...}{1.386294...} \\approx 1.931240...\n$$\n根据要求将结果四舍五入到四位有效数字，我们得到：\n$$\np \\approx 1.931\n$$\n\n### 第三部分：与标称阶数偏差的解释\n\n观测到的精度阶 $p \\approx 1.931$ 略低于在均匀笛卡尔网格上使用分段线性重构格式所期望的标称二阶精度 ($p=2$)。这种偏差可以通过考虑截断误差的细节和渐近误差模型的实际局限性来解释。\n\n1.  **渐近收敛性**：误差模型 $E \\approx C h^p$ 仅在 $h \\to 0$ 的渐近极限下才严格有效。对于有限的网格间距，误差展开式 $E(h) = C_p h^p + C_{p+1} h^{p+1} + \\dots$ 中的高阶项不可忽略。这些项的存在“污染”了主导阶的行为，导致*观测*阶数与形式阶数 $p$ 不同。事实上，在网格1和2之间计算出的阶数 ($p_{12} \\approx 1.912$) 低于在网格2和3之间计算出的阶数 ($p_{23} \\approx 1.950$)，这表明随着网格的细化，该方法确实正在接近其 $p=2$ 的渐近阶。报告的 $p \\approx 1.931$ 值是该范围内的平均值，反映了模拟尚未完全进入渐近区域。\n\n2.  **截断误差相消与对称性破缺**：有限体积法在均匀网格上的标称二阶精度源于控制体相对面上主导阶截断误差的相消。这种相消在很大程度上依赖于离散格式模板的对称性，这是中心差分格式的一个特征。\n    问题描述了一个用于对流-扩散方程的格式。扩散通量的离散化使用了格林-高斯梯度（在均匀笛卡尔网格上等同于中心差分）和算术平均，它是对称的，并且天然具有二阶精度。\n    然而，对流通量的计算涉及到“从单元中心进行分段线性重构”以确定面上的通量。这意味着一种迎风偏置的方法，即使用迎风单元中流体的状态来确定面上的值 $\\phi_f$。尽管用于此重构的梯度是二阶精度的（最小二乘法），但迎风的单边性质从根本上破坏了格式模板的对称性。\n    这种不对称性破坏了主导误差项的完美相消。由此产生的对流部分的截断误差，虽然形式上是 $O(h^2)$ 阶，但包含了类似于数值扩散的项（通常与解的三阶导数有关，例如 $\\propto h^2 \\frac{\\partial^3\\phi}{\\partial x^3}$），这些项在纯对称格式中是不存在的。这个主导误差项的系数可能很大，并且在不够精细的网格上会降低有效或观测到的精度阶，从而导致一个略小于2的值。\n\n总而言之，观测阶数为 $1.931$ 而非恰好为 $2$ 的主要原因是，模拟尚未达到足够精细的网格分辨率，以真正进入 $O(h^2)$ 误差项完全占主导地位的渐近区域。迎风偏置对流格式的内在性质加剧了这种效应，其主导误差项虽然形式上是二阶的，但不如完全对称格式的误差项有利，导致向理论阶收敛的速度变慢。", "answer": "$$\n\\boxed{1.931}\n$$", "id": "3326375"}, {"introduction": "前面的练习都建立在一个理想化的假设之上：数值解是足够光滑的。然而，真实的CFD问题常常包含激波、接触间断或尖锐界面，这些特征破坏了解的光滑性。本练习将通过一个包含“扭折”（kink）的精确解来挑战这一假设，这是一个涉及编程的综合实践，旨在揭示解的正则性（或光滑性）如何显著影响收敛速度，以及为什么不同的误差范数（如 $L_1$, $L_2$, 和 $L_\\infty$）会描绘出关于模拟精度的不同图景 [@problem_id:3326338]。", "problem": "考虑单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上的二维稳态线性对流-反应偏微分方程，\n$$\na_x \\,\\frac{\\partial u}{\\partial x} + a_y \\,\\frac{\\partial u}{\\partial y} + \\sigma \\, u = s(x,y),\n$$\n服从狄利克雷边界条件 $u(x,y) = u_{\\text{MMS}}(x,y)$，其中 $(x,y) \\in \\partial \\Omega$。使用人造解法（MMS），其中精确解被指定为\n$$\nu_{\\text{MMS}}(x,y) = \\sin(2\\pi x)\\,\\exp(y) + \\left|y - 0.5\\right|,\n$$\n角度单位默认为弧度。通过代入 $u_{\\text{MMS}}$ 并在其经典意义下有定义的任何地方计算所需导数，从控制方程构造源项 $s(x,y)$。您必须以一种原则性的方式明确处理绝对值项的不可微性，即使用其一阶导数的分段定义，即对于 $y \\neq 0.5$ 有 $\\frac{d}{dy}\\left|y-0.5\\right| = \\operatorname{sign}(y-0.5)$，并在 $y=0.5$ 处使用 $\\operatorname{sign}(0)=0$ 以便在恰好位于拐点上的网格节点上进行逐点源项求值。此问题中不需要 $\\left|y-0.5\\right|$ 的二阶导数。\n\n使用 $x$ 方向上的 $N_x$ 个点和 $y$ 方向上的 $N_y$ 个点，在均匀笛卡尔网格上离散化 $\\Omega$ 的内部，间距分别为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。使用二阶中心有限差分格式计算一阶导数，并使用逐点求值计算反应项，以此构建离散算子，其中狄利克雷边界值由 $\\partial \\Omega$ 上的 $u_{\\text{MMS}}$ 设定。不要使用任何迎风格式、限制器、滤波或人工扩散。\n\n对于每个离散解，在内部网格点 $(x_i,y_j)$ 计算误差 $e_{i,j} = u_{i,j}^{\\text{num}} - u_{\\text{MMS}}(x_i,y_j)$，然后计算以下三种误差范数：\n- 离散 $L_1$ 范数，\n$$\n\\|e\\|_{L_1} = h_x\\,h_y \\sum_{i=1}^{N_x-2} \\sum_{j=1}^{N_y-2} \\left|e_{i,j}\\right|.\n$$\n- 离散 $L_2$ 范数，\n$$\n\\|e\\|_{L_2} = \\sqrt{h_x\\,h_y \\sum_{i=1}^{N_x-2} \\sum_{j=1}^{N_y-2} e_{i,j}^2 }.\n$$\n- 离散 $L_\\infty$ 范数，\n$$\n\\|e\\|_{L_\\infty} = \\max_{1 \\le i \\le N_x-2, \\, 1 \\le j \\le N_y-2} \\left|e_{i,j}\\right|.\n$$\n\n使用三套连续加密的网格，通过对最密的两套网格进行理查森外推，估计每个范数的观测精度阶 $p$。具体来说，如果中等密度网格上的误差为 $E(h_2)$，最密网格上的误差为 $E(h_3)$，其有效网格间距分别为 $h_2$ 和 $h_3$，则计算满足 $E(h) \\approx C h^p$ 的观测阶 $p$；具体地，对此估计在每个网格上使用有效网格间距 $h = \\max(h_x, h_y)$，并从最密的两个层级计算阶数 $p$，无需任何外部提示。在您的解题方案中，解释为什么 $y=0.5$ 处的不可微性会导致依赖于范数的精度阶下降。\n\n您的程序必须实现上述过程，并在每个网格上精确求解离散线性系统（在求解器容差范围内）。最终输出是为以下每个测试用例计算的 $L_1$、$L_2$ 和 $L_\\infty$ 范数的 $p$ 值（每个用例包括参数值和一个由三套网格组成的测试套件）：\n\n- 用例 $\\mathrm{A}$（所有网格上拐点对齐，各向同性加密）：\n  - $a_x = 1$, $a_y = 1$, $\\sigma = 2$.\n  - 网格：$(N_x,N_y) \\in \\{(17,17),(33,33),(65,65)\\}$。\n\n- 用例 $\\mathrm{B}$（所有网格上拐点错位，各向同性加密）：\n  - $a_x = 1$, $a_y = 0.5$, $\\sigma = 1$.\n  - 网格：$(N_x,N_y) \\in \\{(16,16),(32,32),(64,64)\\}$。\n\n- 用例 $\\mathrm{C}$（弱对流，强反应，各向同性加密）：\n  - $a_x = 0.1$, $a_y = 0.1$, $\\sigma = 10$.\n  - 网格：$(N_x,N_y) \\in \\{(17,17),(33,33),(65,65)\\}$。\n\n- 用例 $\\mathrm{D}$（各向异性加密，$y$ 方向拐点对齐）：\n  - $a_x = 1$, $a_y = 1$, $\\sigma = 2$.\n  - 网格：$(N_x,N_y) \\in \\{(33,17),(65,33),(97,49)\\}$。\n\n您的程序应生成单行输出，其中包含结果，格式为一个用方括号括起来的逗号分隔列表。每个用例贡献一个包含三个浮点数 $[p_{L_1},p_{L_2},p_{L_\\infty}]$ 的列表，四舍五入到六位小数，总输出必须是这些列表的列表，并按用例顺序排列，例如 $[[p_{A,L_1},p_{A,L_2},p_{A,L_\\infty}],[p_{B,L_1},p_{B,L_2},p_{B,L_\\infty}],[p_{C,L_1},p_{C,L_2},p_{C,L_\\infty}],[p_{D,L_1},p_{D,L_2},p_{D,L_\\infty}]]$。不得打印任何额外文本。\n\n此问题中的所有量都是无量纲的，并且必须以一致的数学单位处理。三角函数中的角度单位为弧度。您的代码必须是自包含的，并且无需任何用户输入即可生成指定的输出。", "solution": "该问题是有效的，因为它提出了一个在计算流体力学和数值分析领域中适定的、有科学依据的任务，并提供了所有必要的数据和定义。我们着手进行求解。\n\n问题的核心是使用人造解法（MMS）来验证求解偏微分方程（PDE）的数值方法的精度阶。这包括指定一个精确解，推导相应的源项，在一系列加密的网格上对PDE进行数值求解，然后根据计算出的误差计算观测收敛阶。\n\n**1. 控制方程与人造解**\n\n控制方程是在域 $\\Omega = [0,1]\\times[0,1]$ 上的二维稳态线性对流-反应方程：\n$$\na_x \\,\\frac{\\partial u}{\\partial x} + a_y \\,\\frac{\\partial u}{\\partial y} + \\sigma \\, u = s(x,y)\n$$\n人造解指定如下：\n$$\nu_{\\text{MMS}}(x,y) = \\sin(2\\pi x)\\,\\exp(y) + \\left|y - 0.5\\right|\n$$\n该解由一个光滑（$C^\\infty$）部分 $u_{smooth}(x,y) = \\sin(2\\pi x)\\exp(y)$ 和一个非光滑部分 $u_{kink}(y) = |y-0.5|$ 组成，后者是连续的但在 $y=0.5$ 处不可微。\n\n**2. 源项推导**\n\n为了找到使 $u_{\\text{MMS}}(x,y)$ 成为精确解的源项 $s(x,y)$，我们将其代入PDE。首先，我们计算 $u_{\\text{MMS}}$ 的偏导数。关于 $x$ 的导数为：\n$$\n\\frac{\\partial u_{\\text{MMS}}}{\\partial x} = 2\\pi\\cos(2\\pi x)\\,\\exp(y)\n$$\n关于 $y$ 的导数需要处理绝对值项。对于 $y \\neq 0.5$， $|y-0.5|$ 的导数是 $\\operatorname{sign}(y-0.5)$，其中如果 $z>0$ 则 $\\operatorname{sign}(z)$ 为 $1$，如果 $z<0$ 则为 $-1$。按照规定，对于在 $y=0.5$ 处的逐点求值，我们使用 $\\operatorname{sign}(0)=0$。因此：\n$$\n\\frac{\\partial u_{\\text{MMS}}}{\\partial y} = \\sin(2\\pi x)\\,\\exp(y) + \\operatorname{sign}(y-0.5)\n$$\n将这些代入PDE，得到人造源项：\n$$\ns(x,y) = a_x \\left(2\\pi\\cos(2\\pi x)\\exp(y)\\right) + a_y \\left(\\sin(2\\pi x)\\exp(y) + \\operatorname{sign}(y-0.5)\\right) + \\sigma \\left(\\sin(2\\pi x)\\exp(y) + \\left|y - 0.5\\right|\\right)\n$$\n\n**3. 数值离散化与线性系统**\n\n使用包含 $N_x$ 和 $N_y$ 个点的均匀笛卡尔网格对区域进行离散化，网格间距为 $h_x = 1/(N_x-1)$ 和 $h_y = 1/(N_y-1)$。网格点为 $(x_i, y_j) = (i h_x, j h_y)$。\n\n对于任何内部点 $(x_i, y_j)$（其中 $1 \\le i \\le N_x-2$ 且 $1 \\le j \\le N_y-2$），空间导数使用二阶中心有限差分进行近似：\n$$\n\\frac{\\partial u}{\\partial x}\\bigg|_{(x_i,y_j)} \\approx \\frac{u_{i+1,j} - u_{i-1,j}}{2h_x}, \\quad \\frac{\\partial u}{\\partial y}\\bigg|_{(x_i,y_j)} \\approx \\frac{u_{i,j+1} - u_{i,j-1}}{2h_y}\n$$\n将这些代入PDE，得到每个内部节点 $(i,j)$ 的离散方程：\n$$\na_x \\left(\\frac{u_{i+1,j} - u_{i-1,j}}{2h_x}\\right) + a_y \\left(\\frac{u_{i,j+1} - u_{i,j-1}}{2h_y}\\right) + \\sigma u_{i,j} = s(x_i,y_j)\n$$\n整理各项以组合 $u$ 的未知值的系数，得到：\n$$\n\\left(-\\frac{a_x}{2h_x}\\right)u_{i-1,j} + \\left(\\frac{a_x}{2h_x}\\right)u_{i+1,j} + \\left(-\\frac{a_y}{2h_y}\\right)u_{i,j-1} + \\left(\\frac{a_y}{2h_y}\\right)u_{i,j+1} + \\sigma u_{i,j} = s(x_i,y_j)\n$$\n这组 $(N_x-2)(N_y-2)$ 个线性代数方程构成一个大型稀疏系统 $A \\mathbf{u} = \\mathbf{b}$。向量 $\\mathbf{u}$ 包含内部网格点上的未知值 $u_{i,j}$。矩阵 $A$ 是稀疏的，每行有五个非零项（一个五点模板）。对于邻近边界的点，已知的狄利克雷值 $u_{\\text{MMS}}(x_i, y_j)$ 被移到右端向量 $\\mathbf{b}$。例如，在邻近 $x=0$ 边界的内部点 $(1,j)$，涉及 $u_{0,j}$ 的项是已知的，方程变为：\n$$\na_x \\left(\\frac{u_{2,j} - u_{\\text{MMS}}(x_0,y_j)}{2h_x}\\right) + \\dots = s(x_1,y_j) \\implies \\dots = s(x_1,y_j) + a_x\\frac{u_{\\text{MMS}}(x_0,y_j)}{2h_x}\n$$\n所得系统 $A \\mathbf{u} = \\mathbf{b}$ 使用标准的稀疏线性代数求解器求解。\n\n**4. 误差分析与预期精度阶**\n\n一个数值格式的形式精度阶由其截断误差决定，截断误差是将精确解代入离散方程后得到的残差。对于足够光滑的解（至少 $C^3$），中心差分格式是形式二阶精确的（$O(h^2)$）。\n\n由于存在 $|y-0.5|$ 项，人造解 $u_{\\text{MMS}}$ 不够光滑。该函数是 $C^0$ 的，其一阶导数在 $y=0.5$ 处有一个跳跃间断点。标准数值分析理论预测，这种缺乏正则性的特性会降低格式的收敛率。对于一个应用于其 $k$ 阶导数有跳跃间断点的函数的 $p$ 阶方法，其在 $L_q$ 范数下的观测收敛阶预计为 $\\min(p, k + 1/q)$。\n\n在此问题中，格式是二阶的（$p=2$），解的一阶导数有跳跃（$k=1$）。因此，预期的收敛阶为：\n- **$L_\\infty$ 范数 ($q=\\infty$)：** 阶数为 $\\min(2, 1 + 1/\\infty) = \\min(2, 1) = 1$。最大误差由最接近奇异点的点主导，并预计随网格间距线性减小。\n- **$L_2$ 范数 ($q=2$)：** 阶数为 $\\min(2, 1 + 1/2) = \\min(2, 1.5) = 1.5$。\n- **$L_1$ 范数 ($q=1$)：** 阶数为 $\\min(2, 1 + 1/1) = \\min(2, 2) = 2$。\n\n这种理论上的精度下降发生在 $y=0.5$ 处的奇异点位于网格线之间时。然而，如果奇异点总是与网格线对齐，可能会发生一种称为“超收敛”的现象。在 $N_y-1$ 是 $2$ 的倍数的网格中，$y=0.5$ 这条线将与一条网格线 $y_j = j h_y$ 重合，其中 $j=(N_y-1)/2$。在这条线上，用于计算 $\\partial u/\\partial y$ 的中心差分模板关于拐点是对称的。离散算子有效地计算了左右导数的平均值，即 $\\frac{1}{2}(1 + (-1)) = 0$。在 $y=0.5$ 处的源项也使用 $\\operatorname{sign}(y-0.5)|_{y=0.5}=0$ 进行求值。离散算子和源项求值之间的这种匹配可能导致主误差项的抵消，从而可能恢复形式二阶精度。\n\n- **用例 A, C, D：** 网格的选择使得 $N_y-1$ 总是偶数（A/C 为 $16, 32, 64$；D 为 $16, 32, 48$）。因此，拐点总是与网格对齐。我们期望观察到所有范数都接近二阶收敛（$p \\approx 2$）。\n- **用例 B：** 网格的选择使得 $N_y-1$ 总是奇数（$15, 31, 63$）。$y=0.5$ 处的拐点总是错位的，落在网格线之间。在这里，我们期望观察到理论预测的依赖于范数的精度阶下降：$p_{L_1} \\approx 2$，$p_{L_2} \\approx 1.5$ 和 $p_{L_\\infty} \\approx 1$。\n\n**5. 观测阶计算**\n\n给定在一系列网格上计算出的误差范数 $E$，观测精度阶 $p$ 是使用最密的两套网格的结果来估计的。如果有效间距分别为 $h_2$ 和 $h_3$ 的网格上的误差是 $E_2$ 和 $E_3$，那么假设 $E \\approx C h^p$，我们有：\n$$\n\\frac{E_2}{E_3} \\approx \\left(\\frac{h_2}{h_3}\\right)^p \\implies p = \\frac{\\log(E_2 / E_3)}{\\log(h_2 / h_3)}\n$$\n有效网格间距定义为 $h = \\max(h_x, h_y)$。此过程应用于 $L_1$、$L_2$ 和 $L_\\infty$ 每种误差范数，以确定它们各自的收敛阶。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef u_mms(x, y):\n    \"\"\"Computes the manufactured solution u_MMS(x, y).\"\"\"\n    return np.sin(2 * np.pi * x) * np.exp(y) + np.abs(y - 0.5)\n\ndef source_term(x, y, ax, ay, sigma):\n    \"\"\"Computes the source term s(x, y) for the manufactured solution.\"\"\"\n    dudx = 2 * np.pi * np.cos(2 * np.pi * x) * np.exp(y)\n    dudy = np.sin(2 * np.pi * x) * np.exp(y) + np.sign(y - 0.5)\n    u = u_mms(x, y)\n    return ax * dudx + ay * dudy + sigma * u\n\ndef solve_pde(Nx, Ny, ax, ay, sigma):\n    \"\"\"\n    Solves the 2D advection-reaction PDE on a grid of size (Nx, Ny)\n    and returns the L1, L2, and L_infinity error norms.\n    \"\"\"\n    hx = 1.0 / (Nx - 1)\n    hy = 1.0 / (Ny - 1)\n    \n    x = np.linspace(0, 1, Nx)\n    y = np.linspace(0, 1, Ny)\n    \n    # Number of interior points\n    Ni = Nx - 2\n    Nj = Ny - 2\n    N_unknowns = Ni * Nj\n\n    if N_unknowns == 0:\n        return 0.0, 0.0, 0.0\n\n    # Assemble the sparse matrix A and vector b\n    A = lil_matrix((N_unknowns, N_unknowns))\n    b = np.zeros(N_unknowns)\n\n    C_W = -ax / (2 * hx)\n    C_E = ax / (2 * hx)\n    C_S = -ay / (2 * hy)\n    C_N = ay / (2 * hy)\n    C_P = sigma\n\n    for j in range(1, Ny - 1):      # Corresponds to rows of interior grid\n        for i in range(1, Nx - 1):  # Corresponds to columns of interior grid\n            k = (j - 1) * Ni + (i - 1)  # Row-major mapping to 1D index\n            \n            # Diagonal entry\n            A[k, k] = C_P\n\n            # Off-diagonal entries for neighbors\n            # West neighbor\n            if i > 1:\n                A[k, k - 1] = C_W\n            # East neighbor\n            if i  Nx - 2:\n                A[k, k + 1] = C_E\n            # South neighbor\n            if j > 1:\n                A[k, k - Ni] = C_S\n            # North neighbor\n            if j  Ny - 2:\n                A[k, k + Ni] = C_N\n\n            # Construct RHS vector b\n            b[k] = source_term(x[i], y[j], ax, ay, sigma)\n            \n            # Incorporate boundary conditions into RHS\n            if i == 1:       # Left boundary\n                b[k] -= C_W * u_mms(x[0], y[j])\n            if i == Nx - 2:  # Right boundary\n                b[k] -= C_E * u_mms(x[Nx - 1], y[j])\n            if j == 1:       # Bottom boundary\n                b[k] -= C_S * u_mms(x[i], y[0])\n            if j == Ny - 2:  # Top boundary\n                b[k] -= C_N * u_mms(x[i], y[Ny - 1])\n                \n    # Solve the linear system\n    A_csc = csc_matrix(A)\n    u_sol_vec = spsolve(A_csc, b)\n    \n    # Reshape solution to 2D grid of interior points\n    u_num = u_sol_vec.reshape((Nj, Ni))\n    \n    # Get exact solution on interior points\n    X_int, Y_int = np.meshgrid(x[1:-1], y[1:-1])\n    u_exact_int = u_mms(X_int, Y_int)\n\n    # Compute error\n    error = u_num - u_exact_int\n    \n    # Compute error norms\n    l1_norm = hx * hy * np.sum(np.abs(error))\n    l2_norm = np.sqrt(hx * hy * np.sum(error**2))\n    if error.size > 0:\n        linf_norm = np.max(np.abs(error))\n    else:\n        linf_norm = 0.0\n\n    return l1_norm, l2_norm, linf_norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: kink aligned, isotropic refinement\n        {'ax': 1.0, 'ay': 1.0, 'sigma': 2.0, 'grids': [(17, 17), (33, 33), (65, 65)]},\n        # Case B: kink misaligned, isotropic refinement\n        {'ax': 1.0, 'ay': 0.5, 'sigma': 1.0, 'grids': [(16, 16), (32, 32), (64, 64)]},\n        # Case C: weak advection, strong reaction, aligned kink\n        {'ax': 0.1, 'ay': 0.1, 'sigma': 10.0, 'grids': [(17, 17), (33, 33), (65, 65)]},\n        # Case D: anisotropic refinement, aligned kink\n        {'ax': 1.0, 'ay': 1.0, 'sigma': 2.0, 'grids': [(33, 17), (65, 33), (97, 49)]},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        errors = []\n        h_effs = []\n        for Nx, Ny in case['grids']:\n            hx = 1.0 / (Nx - 1)\n            hy = 1.0 / (Ny - 1)\n            h_effs.append(max(hx, hy))\n            \n            l1, l2, linf = solve_pde(Nx, Ny, case['ax'], case['ay'], case['sigma'])\n            errors.append((l1, l2, linf))\n\n        # Errors from middle and fine grids\n        E2 = errors[1]\n        E3 = errors[2]\n        \n        # Effective grid spacings for middle and fine grids\n        h2 = h_effs[1]\n        h3 = h_effs[2]\n\n        # Calculate observed order of accuracy p\n        case_p_values = []\n        log_h_ratio = np.log(h2 / h3)\n        \n        for i in range(3): # For L1, L2, Linf norms\n            if E2[i] > 0 and E3[i] > 0:\n                p = np.log(E2[i] / E3[i]) / log_h_ratio\n            else:\n                p = 0.0 # Error is zero, no convergence to measure\n            case_p_values.append(p)\n        \n        all_results.append(case_p_values)\n\n    # Format the final output string\n    case_strings = []\n    for p_list in all_results:\n        num_strings = [f\"{val:.6f}\" for val in p_list]\n        case_strings.append(f\"[{','.join(num_strings)}]\")\n    \n    print(f\"[[{','.join(case_strings)}]]\")\n\nsolve()\n```", "id": "3326338"}]}