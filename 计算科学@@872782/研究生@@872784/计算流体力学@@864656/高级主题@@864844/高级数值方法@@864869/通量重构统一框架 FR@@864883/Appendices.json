{"hands_on_practices": [{"introduction": "通量重构（FR）方法的核心在于其从不连续的解表示中创建高阶连续通量函数的过程。本练习提供了一个基础的、动手的机会，让您从头开始构建离散微分算子。通过遵循一维简单情况下的插值和微分步骤，您将具体理解解点数据如何被转换为通量导数，而这构成了半离散格式的基础。[@problem_id:3320594]", "problem": "考虑标量守恒律 $\\partial_{t} u + \\partial_{\\xi} f(u) = 0$ 的一维参考单元 $\\xi \\in [-1,1]$，其中通量函数为 $f(u) = u$。在通量重构（Flux Reconstruction, FR）统一框架中，使用 $p+2$ 个通量点，根据在 $p+1$ 个解点上表示的解来重构一个多项式通量。设 $p=2$，解点位于 $\\xi = -1, 0, 1$，通量点位于 $\\xi = -1, -\\frac{1}{2}, \\frac{1}{2}, 1$。假设周期性或匹配的公共界面通量，使得在这个单个参考单元上的边界修正项为零；等效地，在边界处使用插值的局部通量。\n\n通过在解点处的 Lagrange 多项式定义 $p$ 次解插值多项式 $u(\\xi)$，在通量点处计算通量 $f(u)$，通过在通量点上的 Lagrange 插值重构 $p+1$ 次通量多项式，然后计算其在解点处的导数。从第一性原理推导微分矩阵 $\\mathbf{D} \\in \\mathbb{R}^{3 \\times 3}$，使得在解点处的重构通量导数向量 $\\left[\\partial_{\\xi} F(-1), \\partial_{\\xi} F(0), \\partial_{\\xi} F(1)\\right]^{\\mathsf{T}}$ 等于 $\\mathbf{D} \\left[u(-1), u(0), u(1)\\right]^{\\mathsf{T}}$。\n\n将微分矩阵的所有元素表示为精确的有理数。最终表达式中无需四舍五入，也不涉及物理单位。", "solution": "目标是推导微分矩阵 $\\mathbf{D} \\in \\mathbb{R}^{3 \\times 3}$，该矩阵根据关系式 $\\mathbf{F}'_S = \\mathbf{D} \\mathbf{u}_S$ 将解点处的解值向量 $\\mathbf{u}_S = \\left[u(-1), u(0), u(1)\\right]^{\\mathsf{T}}$ 映射到同一点处的重构通量导数向量 $\\mathbf{F}'_S = \\left[\\partial_{\\xi} F(-1), \\partial_{\\xi} F(0), \\partial_{\\xi} F(1)\\right]^{\\mathsf{T}}$。推导过程将遵循题目描述中的步骤。\n\n多项式次数为 $p=2$。解点为 $\\xi_S = \\{-1, 0, 1\\}$，通量点为 $\\xi_F = \\{-1, -\\frac{1}{2}, \\frac{1}{2}, 1\\}$。通量函数为 $f(u) = u$。\n\n步骤1：定义 $p$ 次解插值多项式 $u(\\xi)$。\n解由一个 $p=2$ 次多项式 $u(\\xi)$ 表示，它在解点 $\\xi_{S,0}=-1$、$\\xi_{S,1}=0$、$\\xi_{S,2}=1$ 处插值解值 $u_0 = u(-1)$、$u_1 = u(0)$ 和 $u_2 = u(1)$。使用 Lagrange 插值：\n$$u(\\xi) = \\sum_{i=0}^{2} u_i L_{S,i}(\\xi)$$\n其中 $L_{S,i}(\\xi)$ 是解点的 Lagrange 基多项式：\n$L_{S,0}(\\xi) = \\frac{(\\xi - 0)(\\xi - 1)}{(-1 - 0)(-1 - 1)} = \\frac{1}{2}(\\xi^2 - \\xi)$\n$L_{S,1}(\\xi) = \\frac{(\\xi - (-1))(\\xi - 1)}{(0 - (-1))(0 - 1)} = 1 - \\xi^2$\n$L_{S,2}(\\xi) = \\frac{(\\xi - (-1))(\\xi - 0)}{(1 - (-1))(1 - 0)} = \\frac{1}{2}(\\xi^2 + \\xi)$\n因此，解插值多项式为：\n$$u(\\xi) = u_0 \\left(\\frac{1}{2}(\\xi^2 - \\xi)\\right) + u_1 \\left(1 - \\xi^2\\right) + u_2 \\left(\\frac{1}{2}(\\xi^2 + \\xi)\\right)$$\n\n步骤2：在通量点处计算通量 $f(u)$。\n通量函数为 $f(u) = u$，因此在任意位置 $\\xi$ 的通量值就是 $f(u(\\xi)) = u(\\xi)$。我们在四个通量点 $\\xi_{F,0}=-1$, $\\xi_{F,1}=-1/2$, $\\xi_{F,2}=1/2$, $\\xi_{F,3}=1$ 处计算这些值。设通量值向量为 $\\mathbf{f}_F = [f_0, f_1, f_2, f_3]^{\\mathsf{T}}$。\n$f_0 = u(-1) = u_0$\n$f_1 = u(-1/2) = u_0 \\frac{1}{2}(\\frac{1}{4}+\\frac{1}{2}) + u_1(1-\\frac{1}{4}) + u_2 \\frac{1}{2}(\\frac{1}{4}-\\frac{1}{2}) = \\frac{3}{8}u_0 + \\frac{3}{4}u_1 - \\frac{1}{8}u_2$\n$f_2 = u(1/2) = u_0 \\frac{1}{2}(\\frac{1}{4}-\\frac{1}{2}) + u_1(1-\\frac{1}{4}) + u_2 \\frac{1}{2}(\\frac{1}{4}+\\frac{1}{2}) = -\\frac{1}{8}u_0 + \\frac{3}{4}u_1 + \\frac{3}{8}u_2$\n$f_3 = u(1) = u_2$\n这个关系可以表示为矩阵形式 $\\mathbf{f}_F = \\mathbf{M} \\mathbf{u}_S$：\n$$\\begin{pmatrix} f_0 \\\\ f_1 \\\\ f_2 \\\\ f_3 \\end{pmatrix} = \\begin{pmatrix} 1  0  0 \\\\ \\frac{3}{8}  \\frac{3}{4}  -\\frac{1}{8} \\\\ -\\frac{1}{8}  \\frac{3}{4}  \\frac{3}{8} \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} u_0 \\\\ u_1 \\\\ u_2 \\end{pmatrix}$$\n\n步骤3：重构 $p+1$ 次通量多项式 $F(\\xi)$。\n通量多项式 $F(\\xi)$ 的次数为 $p+1=3$，并在通量点 $\\xi_F$ 处插值通量值 $\\mathbf{f}_F$。使用 Lagrange 插值：\n$$F(\\xi) = \\sum_{j=0}^{3} f_j L_{F,j}(\\xi)$$\n其中 $L_{F,j}(\\xi)$ 是通量点的 Lagrange 基多项式。\n\n步骤4：计算重构通量在解点处的导数。\n通量多项式的导数为：\n$$\\partial_{\\xi} F(\\xi) = \\sum_{j=0}^{3} f_j \\frac{d L_{F,j}}{d\\xi}(\\xi)$$\n我们需要该导数在解点 $\\xi_S=\\{-1, 0, 1\\}$ 处的值。这可以写成矩阵-向量积的形式 $\\mathbf{F}'_S = \\mathbf{L}' \\mathbf{f}_F$，其中 $\\mathbf{L}'$ 是一个 $3 \\times 4$ 矩阵，其元素为 $\\mathbf{L}'_{ij} = \\frac{d L_{F,j}}{d\\xi}(\\xi_{S,i})$。让我们计算通量基多项式 $L_{F,j}(\\xi)$ 在解点处的导数。\n基多项式的导数为：\n$\\frac{d L_{F,0}}{d\\xi} = \\frac{d}{d\\xi} \\left( -\\frac{2}{3}(\\xi^3 - \\xi^2 - \\frac{1}{4}\\xi + \\frac{1}{4}) \\right) = -\\frac{2}{3}(3\\xi^2 - 2\\xi - \\frac{1}{4})$\n$\\frac{d L_{F,1}}{d\\xi} = \\frac{d}{d\\xi} \\left( \\frac{4}{3}(\\xi^3 - \\frac{1}{2}\\xi^2 - \\xi + \\frac{1}{2}) \\right) = \\frac{4}{3}(3\\xi^2 - \\xi - 1)$\n$\\frac{d L_{F,2}}{d\\xi} = \\frac{d}{d\\xi} \\left( -\\frac{4}{3}(\\xi^3 + \\frac{1}{2}\\xi^2 - \\xi - \\frac{1}{2}) \\right) = -\\frac{4}{3}(3\\xi^2 + \\xi - 1)$\n$\\frac{d L_{F,3}}{d\\xi} = \\frac{d}{d\\xi} \\left( \\frac{2}{3}(\\xi^3 + \\xi^2 - \\frac{1}{4}\\xi - \\frac{1}{4}) \\right) = \\frac{2}{3}(3\\xi^2 + 2\\xi - \\frac{1}{4})$\n\n在 $\\xi_S = \\{-1, 0, 1\\}$ 处计算这些值：\n对于 $\\xi = -1$：\n$\\frac{d L_{F,0}}{d\\xi}(-1) = -\\frac{2}{3}(3+2-\\frac{1}{4}) = -\\frac{19}{6}$，$\\frac{d L_{F,1}}{d\\xi}(-1) = \\frac{4}{3}(3+1-1) = 4$，$\\frac{d L_{F,2}}{d\\xi}(-1) = -\\frac{4}{3}(3-1-1) = -\\frac{4}{3}$，$\\frac{d L_{F,3}}{d\\xi}(-1) = \\frac{2}{3}(3-2-\\frac{1}{4}) = \\frac{1}{2}$。\n对于 $\\xi = 0$：\n$\\frac{d L_{F,0}}{d\\xi}(0) = -\\frac{2}{3}(-\\frac{1}{4}) = \\frac{1}{6}$，$\\frac{d L_{F,1}}{d\\xi}(0) = \\frac{4}{3}(-1) = -\\frac{4}{3}$，$\\frac{d L_{F,2}}{d\\xi}(0) = -\\frac{4}{3}(-1) = \\frac{4}{3}$，$\\frac{d L_{F,3}}{d\\xi}(0) = \\frac{2}{3}(-\\frac{1}{4}) = -\\frac{1}{6}$。\n对于 $\\xi = 1$：\n$\\frac{d L_{F,0}}{d\\xi}(1) = -\\frac{2}{3}(3-2-\\frac{1}{4}) = -\\frac{1}{2}$，$\\frac{d L_{F,1}}{d\\xi}(1) = \\frac{4}{3}(3-1-1) = \\frac{4}{3}$，$\\frac{d L_{F,2}}{d\\xi}(1) = -\\frac{4}{3}(3+1-1) = -4$，$\\frac{d L_{F,3}}{d\\xi}(1) = \\frac{2}{3}(3+2-\\frac{1}{4}) = \\frac{19}{6}$。\n\n这给出了矩阵 $\\mathbf{L}'$：\n$$\\mathbf{L}' = \\begin{pmatrix} -\\frac{19}{6}  4  -\\frac{4}{3}  \\frac{1}{2} \\\\ \\frac{1}{6}  -\\frac{4}{3}  \\frac{4}{3}  -\\frac{1}{6} \\\\ -\\frac{1}{2}  \\frac{4}{3}  -4  \\frac{19}{6} \\end{pmatrix}$$\n\n最后，推导微分矩阵 $\\mathbf{D}$。\n我们有 $\\mathbf{F}'_S = \\mathbf{L}' \\mathbf{f}_F$ 和 $\\mathbf{f}_F = \\mathbf{M} \\mathbf{u}_S$。将它们结合起来得到 $\\mathbf{F}'_S = (\\mathbf{L}' \\mathbf{M}) \\mathbf{u}_S$。因此，微分矩阵为 $\\mathbf{D} = \\mathbf{L}' \\mathbf{M}$。\n$$\\mathbf{D} = \\begin{pmatrix} -\\frac{19}{6}  4  -\\frac{4}{3}  \\frac{1}{2} \\\\ \\frac{1}{6}  -\\frac{4}{3}  \\frac{4}{3}  -\\frac{1}{6} \\\\ -\\frac{1}{2}  \\frac{4}{3}  -4  \\frac{19}{6} \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\\\ \\frac{3}{8}  \\frac{3}{4}  -\\frac{1}{8} \\\\ -\\frac{1}{8}  \\frac{3}{4}  \\frac{3}{8} \\\\ 0  0  1 \\end{pmatrix}$$\n执行矩阵乘法：\n$D_{11} = (-\\frac{19}{6})(1) + (4)(\\frac{3}{8}) + (-\\frac{4}{3})(-\\frac{1}{8}) = -\\frac{19}{6} + \\frac{3}{2} + \\frac{1}{6} = -\\frac{18}{6} + \\frac{3}{2} = -3 + \\frac{3}{2} = -\\frac{3}{2}$\n$D_{12} = (4)(\\frac{3}{4}) + (-\\frac{4}{3})(\\frac{3}{4}) = 3 - 1 = 2$\n$D_{13} = (4)(-\\frac{1}{8}) + (-\\frac{4}{3})(\\frac{3}{8}) + (\\frac{1}{2})(1) = -\\frac{1}{2} - \\frac{1}{2} + \\frac{1}{2} = -\\frac{1}{2}$\n\n$D_{21} = (\\frac{1}{6})(1) + (-\\frac{4}{3})(\\frac{3}{8}) + (\\frac{4}{3})(-\\frac{1}{8}) = \\frac{1}{6} - \\frac{1}{2} - \\frac{1}{6} = -\\frac{1}{2}$\n$D_{22} = (-\\frac{4}{3})(\\frac{3}{4}) + (\\frac{4}{3})(\\frac{3}{4}) = -1 + 1 = 0$\n$D_{23} = (-\\frac{4}{3})(-\\frac{1}{8}) + (\\frac{4}{3})(\\frac{3}{8}) + (-\\frac{1}{6})(1) = \\frac{1}{6} + \\frac{1}{2} - \\frac{1}{6} = \\frac{1}{2}$\n\n$D_{31} = (-\\frac{1}{2})(1) + (\\frac{4}{3})(\\frac{3}{8}) + (-4)(-\\frac{1}{8}) = -\\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2} = \\frac{1}{2}$\n$D_{32} = (\\frac{4}{3})(\\frac{3}{4}) + (-4)(\\frac{3}{4}) = 1 - 3 = -2$\n$D_{33} = (\\frac{4}{3})(-\\frac{1}{8}) + (-4)(\\frac{3}{8}) + (\\frac{19}{6})(1) = -\\frac{1}{6} - \\frac{3}{2} + \\frac{19}{6} = \\frac{18}{6} - \\frac{3}{2} = 3 - \\frac{3}{2} = \\frac{3}{2}$\n\n最终得到的微分矩阵 $\\mathbf{D}$ 是：\n$$\\mathbf{D} = \\begin{pmatrix} -\\frac{3}{2}  2  -\\frac{1}{2} \\\\ -\\frac{1}{2}  0  \\frac{1}{2} \\\\ \\frac{1}{2}  -2  \\frac{3}{2} \\end{pmatrix}$$", "answer": "$$ \\boxed{ \\begin{pmatrix} -\\frac{3}{2}  2  -\\frac{1}{2} \\\\ -\\frac{1}{2}  0  \\frac{1}{2} \\\\ \\frac{1}{2}  -2  \\frac{3}{2} \\end{pmatrix} } $$", "id": "3320594"}, {"introduction": "高阶格式的性能不仅取决于其名义上的精度阶数；一些微妙的设计选择可以带来显著的性能提升。本练习将深入探讨超收敛现象，即在特定点上数值误差的减小速度远快于预期。您将研究解点位置的选择（FR方法中的一个关键设计参数）如何直接影响收敛行为，从而揭示求积规则与格式精度之间的深刻联系。[@problem_id:3320647]", "problem": "考虑单位区间上具有恒定正速度的一维周期性线性平流方程，\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\n其中 $a > 0$，定义在 $x \\in [0,1]$ 上，并具有光滑的初始条件 $u(x,0) = \\sin\\left(2\\pi x\\right)$。在通量重构（FR）统一框架中，使用阶数为 $p$ 的单元多项式逼近，并选择能够恢复间断 Galerkin 方法的修正函数。每个单元被映射到参考坐标 $\\xi \\in [-1,1]$ 上，数值解在一组 $p+1$ 个解点上表示。界面位置 $\\xi=-1$ 和 $\\xi=1$ 被称为通量点。\n\n对于这 $p+1$ 个解点，考虑两种不同的节点集选择：\n- Gauss–Legendre 节点（仅内部节点），记为 $\\mathrm{LG}$。\n- Gauss–Lobatto–Legendre 节点（包括端点），记为 $\\mathrm{LGL}$。\n\n对于采用迎风数值通量的 FR 格式，在下游通量点（右界面 $\\xi=1$）处计算的某些解或通量值表现出超收敛性，这意味着该通量点处的渐近点误差以 $h^q$ 的形式缩放，其指数 $q$ 严格大于标称阶 $p+1$，其中 $h$ 是单元尺寸。这种超收敛性的存在与否通过离散正交性和求积精度性质与节点集的选择相关联。\n\n从以下基本基础出发：\n- 偏微分方程的守恒形式及其弱形式。\n- 每个单元上的多项式逼近，以及在界面处对 $a>0$ 使用迎风格式的数值通量。\n- Gauss–Legendre 和 Gauss–Lobatto–Legendre 求积精度的性质，具体来说，$p+1$ 点 Gauss–Legendre 求积对最高 $2p+1$ 次的多项式是精确的，而 $p+1$ 点 Gauss–Lobatto–Legendre 求积对最高 $2p-1$ 次的多项式是精确的。\n- 使用 Legendre 和 Radau 多项式构造修正函数，以在通量重构统一框架内恢复间断 Galerkin 方法。\n\n任务是根据多项式阶数 $p$ 和节点集，以逻辑和数学方式推导 FR 格式在下游通量点 $\\xi=1$ 处的点误差的渐近收敛指数 $q$，而不使用简化公式。使用上述基本性质来论证由求积精度引起的离散矩抵消如何决定主边界误差项是被消除（产生超收敛）还是持续存在（产生标称阶）。然后实现一个程序，给定一组 $(\\text{nodal\\_set}, p)$ 测试用例，输出每个用例预测的指数 $q$（作为整数）。\n\n您的实现必须是一个完整、可运行的程序。不需要用户输入。使用以下参数测试套件：\n- 用例 1：$(\\mathrm{LG}, p=1)$。\n- 用例 2：$(\\mathrm{LGL}, p=1)$。\n- 用例 3：$(\\mathrm{LG}, p=2)$。\n- 用例 4：$(\\mathrm{LGL}, p=2)$。\n- 用例 5：$(\\mathrm{LG}, p=0)$。\n- 用例 6：$(\\mathrm{LGL}, p=0)$。\n- 用例 7：$(\\mathrm{LG}, p=3)$。\n- 用例 8：$(\\mathrm{LGL}, p=3)$。\n\n对于每个用例，程序必须计算并报告下游通量点处渐近点误差的整数指数 $q$。要编码的原理是：当节点集为 $\\mathrm{LG}$ 时，由最高 $2p+1$ 次的精度所引出的离散矩结构消除了 FR 格式中由基于 Radau 的修正所构造的主边界误差项，从而得到 $q=2p+1$；当节点集为 $\\mathrm{LGL}$ 时，这种离散精度达不到 $2p+1$ 次，主项持续存在，得到 $q=p+1$。对于退化情况 $p=0$，两者都得到 $q=1$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result}_1,\\text{result}_2,\\dots]$）。输出必须是不带单位的整数。此问题不涉及角度。由于收敛指数是无量纲的，因此不需要物理单位。", "solution": "问题陈述的有效性已确立。该问题在科学上植根于偏微分方程数值方法的理论，是适定的，并且陈述客观。所有从基本先验原理推导解决方案所需的信息均已提供。\n\n任务是推导应用于一维线性平流方程 $\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0$（其中 $a > 0$）的通量重构（FR）格式在下游通量点处的点误差的渐近收敛指数 $q$。指数 $q$ 取决于逼近的多项式阶数 $p$ 和节点集（Gauss-Legendre，$\\mathrm{LG}$，或 Gauss-Lobatto-Legendre，$\\mathrm{LGL}$）的选择。\n\n推导过程从所提供的基本原理出发。\n\n1.  **框架设置**：我们考虑守恒形式的方程 $\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$，其中通量为 $f(u) = au$。区域 $[0,1]$ 被离散化为尺寸为 $h$ 的单元，每个单元映射到参考单元 $\\xi \\in [-1,1]$。在每个单元内部，解 $u$ 由一个阶数为 $p$ 的多项式 $u_h$ 逼近，该多项式由其在 $p+1$ 个解点上的值定义。FR 方法通过添加一个修正多项式，从一个间断通量 $F_D(\\xi) = a u_h(\\xi)$ 构造单元内的连续通量逼近 $F(\\xi)$。单元内的半离散方程为 $\\frac{d u_h}{dt} = -\\frac{1}{J} \\frac{dF}{d\\xi}$，其中 $J=h/2$ 是映射的 Jacobian 行列式。\n\n2.  **与间断 Galerkin (DG) 的联系**：问题指定使用能够恢复节点 DG 方法的修正函数。对于恒定的正速度 $a>0$，流动方向从左到右，使得 $\\xi=-1$ 成为迎风界面，$\\xi=1$ 成为下游界面。通量修正由界面处的数值通量 $F^*$ 与内部通量迹之间的跳跃确定。对于迎风通量，右界面 $\\xi=1$ 处的跳跃为 $\\Delta F_R = F^*(1) - F_D(1) = a u_h(1) - a u_h(1) = 0$，因为数值通量取自单元自身内部。左界面处的跳跃为 $\\Delta F_L = F^*(-1) - F_D(-1) = a u_{h,L}^* - a u_h(-1)$，其中 $u_{h,L}^*$ 是来自上游相邻单元的解值。修正后的通量为 $F(\\xi) = F_D(\\xi) + \\Delta F_L \\cdot g_L(\\xi)$，其中 $g_L(\\xi)$ 是左修正函数。等效于 DG 的修正函数使用 Radau 多项式构造，使得 $\\frac{dg_L}{d\\xi}$ 与右 Radau 多项式 $R_p(\\xi) = L_p(\\xi) - L_{p+1}(\\xi)$ 的导数成比例。\n\n3.  **误差传播机制**：超收敛性分析关注误差 $\\epsilon = u_h - u_I$ 的演化，其中 $u_I$ 是在 $p+1$ 个解点上插值精确解 $u_{ex}$ 的 $p$ 次多项式。下游通量点处的误差 $\\epsilon(1,t)$ 主要由上游通量边界引入的误差驱动。对于具有精确初始条件的单个单元，一个时间步后误差的主要来源是通量散度的连续和离散表示之间的不匹配。下游点 $\\xi=1$ 处的误差与来自上游通量边界条件的截断误差的积分成正比。对于节点 DG/FR 格式而言，至关重要的是，此误差由上游单元中初始插值误差的特定矩所控制。流出边界 $\\xi=1$ 处的点误差由以下形式的项主导：\n$$\n\\epsilon(1) \\propto \\int_{-1}^{1} (u_{ex}(\\xi, 0) - u_I(\\xi, 0)) \\cdot \\Psi(\\xi) d\\xi\n$$\n其中 $u_{ex}(\\xi, 0) - u_I(\\xi, 0)$ 是初始插值误差，$\\Psi(\\xi)$ 是一个与格式右端项公式相关的特定检验函数。对于从 FR 中恢复的 DG 格式，$\\Psi(\\xi)$ 与修正函数的导数相关，并且是一个 $p$ 次多项式。\n\n4.  **求积的作用**：在节点格式中，积分被替换为在解点 $\\{\\xi_k\\}_{k=0}^p$ 上的求积和：\n$$\n\\int_{-1}^{1} \\phi(\\xi) d\\xi \\approx \\sum_{k=0}^{p} w_k \\phi(\\xi_k)\n$$\n半离散误差方程的右侧包含项 $\\sum_{k=0}^{p} w_k (u_{ex}(\\xi_k, 0) - u_I(\\xi_k, 0)) \\cdot \\Psi(\\xi_k)$。根据插值多项式 $u_I$ 的定义，在所有解点 $\\xi_k$ 处，我们有 $u_{ex}(\\xi_k, 0) - u_I(\\xi_k, 0) = 0$。因此，离散和恒为零。这意味着由格式传播的误差与积分项的求积误差成正比：\n$$\nE_{quad} = \\int_{-1}^{1} (u_{ex} - u_I) \\Psi(\\xi) d\\xi - \\sum_{k=0}^{p} w_k (u_{ex} - u_I)(\\xi_k) \\Psi(\\xi_k) = \\int_{-1}^{1} (u_{ex} - u_I) \\Psi(\\xi) d\\xi\n$$\n因此，收敛阶 $q$ 由该积分的大小决定，而该积分的大小取决于由节点集定义的求积法则如何处理具有特定多项式结构的被积函数。插值误差的行为类似于 $u_{ex} - u_I \\sim O(h^{p+1})$，并与一个 $p+1$ 次多项式成正比。检验函数 $\\Psi(\\xi)$ 是一个 $p$ 次多项式。因此，被积函数 $(u_{ex} - u_I) \\Psi(\\xi)$ 是一个 $(p+1)+p = 2p+1$ 次多项式。\n\n5.  **Gauss-Legendre ($\\mathrm{LG}$) 节点的推导**：\n对于 $\\mathrm{LG}$ 节点集，$p+1$ 个解点是 Legendre 多项式 $L_{p+1}(\\xi)$ 的根。相应的 $p+1$ 点 Gauss-Legendre 求积法则对所有最高次数为 $2(p+1) - 1 = 2p+1$ 的多项式都是精确的。\n控制主误差项的被积函数是一个 $2p+1$ 次多项式。由于 $\\mathrm{LG}$ 求积法则对此次数的多项式是精确的，因此求积误差为零。\n$$\n\\int_{-1}^{1} (u_{ex} - u_I) \\Psi(\\xi) d\\xi = \\sum_{k=0}^{p} w_k (u_{ex} - u_I)(\\xi_k) \\Psi(\\xi_k) = 0\n$$\n这意味着量级为 $h^{p+1}$ 的主误差项由于离散矩抵消而完全消失。下游边界处的误差现在由误差展开式中的高阶项决定。更详细的分析表明，插值误差的下一个非零矩导致点误差以 $h$ 的更高次幂缩放。得到的收敛阶为 $q = 2p+1$。这是超收敛，因为对于 $p>0$，$2p+1 > p+1$。\n\n6.  **Gauss-Lobatto-Legendre ($\\mathrm{LGL}$) 节点的推导**：\n对于 $\\mathrm{LGL}$ 节点集，$p+1$ 个解点包括端点 $\\xi = \\pm 1$。相应的 $p+1$ 点 Gauss-Lobatto-Legendre 求积法则对所有最高次数为 $2(p+1) - 3 = 2p-1$ 的多项式都是精确的。\n被积函数 $(u_{ex} - u_I) \\Psi(\\xi)$ 和之前一样，是一个 $2p+1$ 次多项式。\n对于 $p \\geq 1$，我们有 $2p+1 > 2p-1$。$\\mathrm{LGL}$ 求积法则对此被积函数不精确。因此，求积误差不为零：\n$$\n\\int_{-1}^{1} (u_{ex} - u_I) \\Psi(\\xi) d\\xi \\neq \\sum_{k=0}^{p} w_k (u_{ex} - u_I)(\\xi_k) \\Psi(\\xi_k) = 0\n$$\n由于积分不为零，且插值误差项 $(u_{ex} - u_I)$ 的量级为 $h^{p+1}$，所以求积误差的量级也为 $h^{p+1}$。这个主误差项不会消失。因此，下游边界处的点误差以格式的标称精度阶收敛。收敛指数为 $q = p+1$。\n\n7.  **退化情况 $p=0$**：\n当 $p=0$ 时，逼近 $u_h$ 是分段常数。对于 $\\mathrm{LG}$ 和 $\\mathrm{LGL}$ 两种约定，都只有一个解点（$p+1=1$），通常位于单元中心 $\\xi=0$。分段常数逼近收敛到光滑解的速度不会快于一阶，因此不可能出现超收敛。收敛阶被限制为 $q=1$。这与两个公式都一致：对于 $\\mathrm{LG}$，$q=2(0)+1=1$，对于 $\\mathrm{LGL}$，$q=0+1=1$。\n\n**结论**：\n下游通量点处是否存在超收斂，直接取决于与节点集相关的求积法则的精度阶。\n- 对于 $\\mathrm{LG}$ 节点，求积法则足够精确（对最高 $2p+1$ 次多项式精确），可以消除主误差项，从而导致 $q=2p+1$ 阶的超收敛。\n- 对于 $\\mathrm{LGL}$ 节点，求积法则不够精确（仅对最高 $2p-1$ 次多项式精确），因此主误差项持续存在，格式达到其标称阶 $q=p+1$。\n- 对于基本情况 $p=0$，两种方法都得到标称阶 $q=1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the asymptotic convergence exponent q for the Flux Reconstruction method\n    at the downwind flux point for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (nodal_set_str, polynomial_degree_p).\n    test_cases = [\n        ('LG', 1),   # Case 1\n        ('LGL', 1),  # Case 2\n        ('LG', 2),   # Case 3\n        ('LGL', 2),  # Case 4\n        ('LG', 0),   # Case 5\n        ('LGL', 0),  # Case 6\n        ('LG', 3),   # Case 7\n        ('LGL', 3),  # Case 8\n    ]\n\n    results = []\n    for nodal_set, p in test_cases:\n        # The derivation shows that the convergence exponent 'q' depends on\n        # whether discrete moment cancellations occur, which is tied to the\n        # exactness of the quadrature rule associated with the nodal set.\n        \n        # For the degenerate case p=0, the approximation is piecewise constant.\n        # The order is limited to 1, regardless of methodology.\n        if p == 0:\n            q = 1\n        \n        # For Gauss-Legendre (LG) nodes, the quadrature is exact for polynomials\n        # up to degree 2p+1. This annihilates the leading error term (which is\n        # a polynomial of degree 2p+1), leading to superconvergence.\n        elif nodal_set == 'LG':\n            q = 2 * p + 1\n        \n        # For Gauss-Lobatto-Legendre (LGL) nodes, the quadrature is only exact\n        # for polynomials up to degree 2p-1. The leading error term persists,\n        # yielding the nominal order of convergence.\n        elif nodal_set == 'LGL':\n            q = p + 1\n        \n        else:\n            # This case should not be reached with the given valid test cases.\n            # Assign an invalid value to indicate an error.\n            q = -1 \n\n        results.append(q)\n\n    # Final print statement in the exact required format.\n    # e.g., \"[result_1,result_2,...]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3320647"}, {"introduction": "在将空间导数离散化以获得一个常微分方程（ODE）组后，最后一步是对该系统进行时间积分。对于显式时间格式，稳定性是首要考虑的问题，它受到Courant-Friedrichs-Lewy（CFL）条件的制约。本练习将演示如何通过将空间算子（其谱半径）的属性与所选时间积分器（其稳定域）的属性联系起来，来确定最大稳定时间步长，并探讨该时间步长随多项式阶数和网格尺寸变化的关键标度关系。[@problem_id:3320625]", "problem": "要求您编写一个完整、可运行的程序，用于计算通过通量重构 (FR) 空间离散化得到的半离散线性系统的显式龙格－库塔 (RK) 时间积分的最大稳定时间步长。其基本基础是常微分方程的方法线法和线性稳定性理论。\n\n考虑方法线半离散系统\n$$\n\\frac{d \\boldsymbol{u}}{dt} = \\boldsymbol{L}\\,\\boldsymbol{u},\n$$\n其中 $\\boldsymbol{L}$ 是由具有恒定平流速度 $a$ 的一维线性平流方程的通量重构 (FR) 空间离散化所产生的线性算子。设 $\\lambda_i$ 表示 $\\boldsymbol{L}$ 的特征值，谱半径为\n$$\n\\rho(\\boldsymbol{L}) = \\max_i |\\lambda_i|.\n$$\n对于应用于半离散系统的显式龙格－库塔 (RK) 方法，稳定性要求对于所有特征值 $\\lambda_i$，乘积 $z_i = \\Delta t \\,\\lambda_i$ 都位于 RK 方法的绝对稳定区域内。沿着负实轴，定义一维稳定性边界\n$$\nr_{\\mathrm{RK}} = \\sup\\{ x \\ge 0 \\,:\\, |R(-x)| \\le 1 \\},\n$$\n其中 $R(z)$ 是 RK 方法的稳定性函数（放大因子多项式）。对于显式欧拉法，$R(z) = 1 + z$；对于经典三阶龙格－库塔法，$R(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6}$；对于经典四阶龙格－库塔法，$R(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}$。半离散系统的最大稳定时间步长为\n$$\n\\Delta t_{\\max} = \\frac{r_{\\mathrm{RK}}}{\\rho(\\boldsymbol{L})}.\n$$\n\n您的程序必须：\n- 对于给定的 RK 方法，通过求解 $|R(-x)| = 1$ 以获得最大的 $x \\ge 0$，来数值计算 $r_{\\mathrm{RK}}$。\n- 给定谱半径 $\\rho(\\boldsymbol{L})$，计算 $\\Delta t_{\\max} = r_{\\mathrm{RK}} / \\rho(\\boldsymbol{L})$。\n\n通量重构 (FR) 框架为在元素大小为 $h$ 的均匀网格上的线性平流问题带来了谱半径的特征缩放：\n$$\n\\rho(\\boldsymbol{L}) = \\frac{|a|}{h} \\,\\alpha_p,\n$$\n其中 $\\alpha_p$ 是一个无量纲常数，由多项式阶数 $p$ 和所选的 FR 修正函数确定。根据多项式逼近理论，对于典范的基函数和修正函数的选择，$\\alpha_p$通常以 $\\mathcal{O}(p^2)$ 的速度增长，这意味着时间步长的缩放关系为\n$$\n\\Delta t_{\\max} \\sim \\frac{h}{|a|}\\,\\frac{r_{\\mathrm{RK}}}{\\alpha_p} \\propto \\frac{h}{p^2}.\n$$\n您不应硬编码任何关于 $r_{\\mathrm{RK}}$ 的简化公式；而应通过求解 $|R(-x)| = 1$ 来数值地确定它。\n\n测试套件：\n对于下面的每个测试用例，都给出了 RK 方法和以 $\\mathrm{s}^{-1}$ 为单位的谱半径 $\\rho(\\boldsymbol{L})$。这些谱半径是通过使用具有代表性的 $(a,h,p)$ 选择和 $\\alpha_p = (p+1)^2$ 的 $\\rho(\\boldsymbol{L}) = \\frac{|a|}{h}\\,\\alpha_p$ 构建的，以反映典型的 $\\mathcal{O}(p^2)$ 缩放关系，但您的程序必须仅使用给定的 $\\rho(\\boldsymbol{L})$ 值。\n\n- 测试用例 1：RK 方法为经典四阶龙格－库塔法，$\\rho(\\boldsymbol{L}) = 160.0\\,\\mathrm{s}^{-1}$（由 $a = 1\\,\\mathrm{m/s}$，$h = 0.1\\,\\mathrm{m}$，$p = 3$，$\\alpha_p = 16$ 构建）。\n- 测试用例 2：RK 方法为经典四阶龙格－库塔法，$\\rho(\\boldsymbol{L}) = 640.0\\,\\mathrm{s}^{-1}$（由 $a = 1\\,\\mathrm{m/s}$，$h = 0.1\\,\\mathrm{m}$，$p = 7$，$\\alpha_p = 64$ 构建）。\n- 测试用例 3：RK 方法为经典三阶龙格－库塔法，$\\rho(\\boldsymbol{L}) = 640.0\\,\\mathrm{s}^{-1}$（由 $a = 1\\,\\mathrm{m/s}$，$h = 0.025\\,\\mathrm{m}$，$p = 3$，$\\alpha_p = 16$ 构建）。\n- 测试用例 4：RK 方法为显式欧拉法，$\\rho(\\boldsymbol{L}) = 80.0\\,\\mathrm{s}^{-1}$（由 $a = 2\\,\\mathrm{m/s}$，$h = 0.1\\,\\mathrm{m}$，$p = 1$，$\\alpha_p = 4$ 构建）。\n- 测试用例 5：RK 方法为经典四阶龙格－库塔法，$\\rho(\\boldsymbol{L}) = 36300.0\\,\\mathrm{s}^{-1}$（由 $a = 3\\,\\mathrm{m/s}$，$h = 0.01\\,\\mathrm{m}$，$p = 10$，$\\alpha_p = 121$ 构建）。\n\n角度单位不适用。以秒为单位表示最终的时间步长值。您的程序应将每个 $\\Delta t_{\\max}$ 四舍五入到恰好 $9$ 位小数（即纳秒分辨率），并按照与上述五个测试用例相对应的顺序，以浮点数列表的形式输出。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来并以逗号分隔的列表，例如，\n$$\n[\\Delta t_1,\\Delta t_2,\\Delta t_3,\\Delta t_4,\\Delta t_5]\n$$\n其中每个 $\\Delta t_i$ 都四舍五入到 $9$ 位小数，并以秒（单位 $\\mathrm{s}$）表示。", "solution": "问题陈述被评估为有效。其科学基础在于偏微分方程的方法线离散化的数值稳定性理论原理，这是计算科学与工程领域的核心课题。该问题是适定、客观且自洽的，提供了计算出唯一且有意义的解所需的所有必要定义、数据和公式。所提供的上下文，涉及计算流体动力学中的通量重构 (FR) 方法，是恰当的，并准确反映了实践中遇到的典型稳定性约束。\n\n求解过程首先确定每个指定的龙格－库塔 (RK) 方法的稳定性边界 $r_{\\mathrm{RK}}$，然后应用给定的最大稳定时间步长公式 $\\Delta t_{\\max}$。\n\n主导的稳定性关系由下式给出：\n$$\n\\Delta t_{\\max} = \\frac{r_{\\mathrm{RK}}}{\\rho(\\boldsymbol{L})}\n$$\n其中 $\\rho(\\boldsymbol{L})$ 是空间离散算子 $\\boldsymbol{L}$ 的谱半径，而 $r_{\\mathrm{RK}}$ 是 RK 时间积分格式沿负实轴的稳定性边界。边界 $r_{\\mathrm{RK}}$ 定义为：\n$$\nr_{\\mathrm{RK}} = \\sup\\{ x \\ge 0 \\,:\\, |R(-x)| \\le 1 \\}\n$$\n其中 $R(z)$ 是 RK 方法的稳定性函数。我们通过求解 $|R(-x)| = 1$ 的最大正实根 $x$ 来找到 $r_{\\mathrm{RK}}$。\n\n我们现在将确定三种指定方法各自的 $r_{\\mathrm{RK}}$。\n\n1.  **显式欧拉法**\n    稳定性函数为 $R(z) = 1 + z$。我们需要求解 $|R(-x)| = 1$ (对于 $x \\ge 0$)。\n    $$\n    |1 - x| = 1\n    $$\n    该方程有两个解：\n    $$\n    1 - x = 1 \\implies x = 0\n    $$\n    $$\n    1 - x = -1 \\implies x = 2\n    $$\n    在负实轴上的稳定区间是 $[-2, 0]$。使此式成立的最大 $x$ 值为 $x=2$。\n    因此，对于显式欧拉法，$r_{\\mathrm{Euler}} = 2$。\n\n2.  **经典三阶龙格－库塔 (RK3) 法**\n    稳定性函数为 $R(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6}$。我们求解 $|R(-x)| = 1$ (对于 $x \\ge 0$)。\n    $$\n    \\left|1 - x + \\frac{x^2}{2} - \\frac{x^3}{6}\\right| = 1\n    $$\n    这意味着以下两个多项式方程之一必须成立：\n    a) $1 - x + \\frac{x^2}{2} - \\frac{x^3}{6} = 1 \\implies -x + \\frac{x^2}{2} - \\frac{x^3}{6} = 0$。这给出 $x( -1 + \\frac{x}{2} - \\frac{x^2}{6} ) = 0$。一个解是 $x=0$。二次因子 $-x^2 + 3x - 6 = 0$ 的判别式为 $3^2 - 4(-1)(-6) = 9 - 24 = -15  0$，因此没有实根。\n    b) $1 - x + \\frac{x^2}{2} - \\frac{x^3}{6} = -1 \\implies 2 - x + \\frac{x^2}{2} - \\frac{x^3}{6} = 0$。乘以 $-6$ 得到三次方程 $x^3 - 3x^2 + 6x - 12 = 0$。\n    该方程有一个正实根，我们通过数值方法找到它。这个根就是稳定性边界 $r_{\\mathrm{RK3}}$。\n    数值求解该方程的根，得到一个实根约在 $x \\approx 2.51274533$。\n    因此，$r_{\\mathrm{RK3}} \\approx 2.51274533$。\n\n3.  **经典四阶龙格－库塔 (RK4) 法**\n    稳定性函数为 $R(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}$。我们求解 $|R(-x)| = 1$ (对于 $x \\ge 0$)。\n    $$\n    \\left|1 - x + \\frac{x^2}{2} - \\frac{x^3}{6} + \\frac{x^4}{24}\\right| = 1\n    $$\n    这同样导致两种情况：\n    a) $1 - x + \\frac{x^2}{2} - \\frac{x^3}{6} + \\frac{x^4}{24} = 1 \\implies x(-1 + \\frac{x}{2} - \\frac{x^2}{6} + \\frac{x^3}{24}) = 0$。一个解是 $x=0$。其他实根必须满足 $x^3 - 4x^2 + 12x - 24 = 0$。这个三次方程有一个唯一的实根。\n    b) $1 - x + \\frac{x^2}{2} - \\frac{x^3}{6} + \\frac{x^4}{24} = -1 \\implies x^4 - 4x^3 + 12x^2 - 24x + 48 = 0$。可以证明这个四次多项式对于实数 $x$ 总是正的（例如，可以将其写为 $x^2(x-2)^2 + 8(x^2-3x+6)$，其中两项都是非负/正的），因此没有实根。\n    因此，稳定性边界 $r_{\\mathrm{RK4}}$ 是 $x^3 - 4x^2 + 12x - 24 = 0$ 的唯一正实根。\n    数值求解得到根 $x \\approx 2.78529434$。\n    因此，$r_{\\mathrm{RK4}} \\approx 2.78529434$。\n\n在确定了稳定性边界后，我们现在为每个测试用例计算 $\\Delta t_{\\max}$。\n\n**测试用例 1：**\n- RK 方法：经典四阶龙格－库塔法，$r_{\\mathrm{RK4}} \\approx 2.78529434$。\n- 谱半径：$\\rho(\\boldsymbol{L}) = 160.0\\,\\mathrm{s}^{-1}$。\n- $\\Delta t_{\\max} = \\frac{r_{\\mathrm{RK4}}}{\\rho(\\boldsymbol{L})} \\approx \\frac{2.78529434}{160.0} \\approx 0.017408090\\,\\mathrm{s}$。\n\n**测试用例 2：**\n- RK 方法：经典四阶龙格－库塔法，$r_{\\mathrm{RK4}} \\approx 2.78529434$。\n- 谱半径：$\\rho(\\boldsymbol{L}) = 640.0\\,\\mathrm{s}^{-1}$。\n- $\\Delta t_{\\max} = \\frac{r_{\\mathrm{RK4}}}{\\rho(\\boldsymbol{L})} \\approx \\frac{2.78529434}{640.0} \\approx 0.004352022\\,\\mathrm{s}$。\n\n**测试用例 3：**\n- RK 方法：经典三阶龙格－库塔法，$r_{\\mathrm{RK3}} \\approx 2.51274533$。\n- 谱半径：$\\rho(\\boldsymbol{L}) = 640.0\\,\\mathrm{s}^{-1}$。\n- $\\Delta t_{\\max} = \\frac{r_{\\mathrm{RK3}}}{\\rho(\\boldsymbol{L})} \\approx \\frac{2.51274533}{640.0} \\approx 0.003926165\\,\\mathrm{s}$。\n\n**测试用例 4：**\n- RK 方法：显式欧拉法，$r_{\\mathrm{Euler}} = 2.0$。\n- 谱半径：$\\rho(\\boldsymbol{L}) = 80.0\\,\\mathrm{s}^{-1}$。\n- $\\Delta t_{\\max} = \\frac{r_{\\mathrm{Euler}}}{\\rho(\\boldsymbol{L})} = \\frac{2.0}{80.0} = 0.025\\,\\mathrm{s}$。\n\n**测试用例 5：**\n- RK 方法：经典四阶龙格－库塔法，$r_{\\mathrm{RK4}} \\approx 2.78529434$。\n- 谱半径：$\\rho(\\boldsymbol{L}) = 36300.0\\,\\mathrm{s}^{-1}$。\n- $\\Delta t_{\\max} = \\frac{r_{\\mathrm{RK4}}}{\\rho(\\boldsymbol{L})} \\approx \\frac{2.78529434}{36300.0} \\approx 0.000076730\\,\\mathrm{s}$。\n\n这些结果是通过编程计算并按要求四舍五入到 $9$ 位小数得到的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum stable time step for explicit RK methods applied to\n    a semi-discrete system from a Flux Reconstruction spatial discretization.\n    \"\"\"\n\n    def compute_r_rk(method):\n        \"\"\"\n        Numerically computes the stability bound r_RK for a given RK method.\n\n        The bound r_RK is the largest positive real root x of |R(-x)| = 1, where\n        R(z) is the stability polynomial of the method.\n\n        Args:\n            method (str): The name of the RK method ('Euler', 'RK3', 'RK4').\n\n        Returns:\n            float: The stability bound r_RK.\n        \"\"\"\n        if method == 'Euler':\n            # R(z) = 1 + z. |1 - x| = 1 gives x=0 or x=2. The supremum is 2.\n            return 2.0\n        \n        elif method == 'RK3':\n            # R(z) = 1 + z + z^2/2 + z^3/6.\n            # We need to solve |R(-x)| = 1. This leads to two equations:\n            # 1) R(-x) = 1 => x^2 - 3x + 6 = 0 (after factoring x=0), which has no real roots.\n            # 2) R(-x) = -1 => x^3 - 3x^2 + 6x - 12 = 0.\n            # The coefficients for the cubic equation are [1, -3, 6, -12].\n            coeffs = [1, -3, 6, -12]\n            roots = np.roots(coeffs)\n            \n            # Filter for positive real roots\n            real_roots = roots[np.isreal(roots)].real\n            positive_real_roots = real_roots[real_roots > 0]\n            \n            # The problem definition ensures a unique largest positive root exists.\n            return np.max(positive_real_roots)\n\n        elif method == 'RK4':\n            # R(z) = 1 + z + z^2/2 + z^3/6 + z^4/24.\n            # We need to solve |R(-x)| = 1. This leads to two equations:\n            # 1) R(-x) = 1 => x^3 - 4x^2 + 12x - 24 = 0 (after factoring x=0).\n            # 2) R(-x) = -1 => x^4 - 4x^3 + 12x^2 - 24x + 48 = 0, which has no real roots.\n            # The coefficients for the cubic equation are [1, -4, 12, -24].\n            coeffs = [1, -4, 12, -24]\n            roots = np.roots(coeffs)\n            \n            # Filter for positive real roots\n            real_roots = roots[np.isreal(roots)].real\n            positive_real_roots = real_roots[real_roots > 0]\n            \n            # The problem definition ensures a unique largest positive root exists.\n            return np.max(positive_real_roots)\n        \n        else:\n            raise ValueError(f\"Unknown RK method: {method}\")\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (RK_method_name, spectral_radius_rho)\n    test_cases = [\n        ('RK4', 160.0),\n        ('RK4', 640.0),\n        ('RK3', 640.0),\n        ('Euler', 80.0),\n        ('RK4', 36300.0)\n    ]\n\n    # Pre-calculate r_RK values to avoid re-computation for the same method.\n    r_rk_cache = {}\n\n    results = []\n    for case in test_cases:\n        method_name, rho = case\n        \n        if method_name not in r_rk_cache:\n            r_rk_cache[method_name] = compute_r_rk(method_name)\n        \n        r_rk = r_rk_cache[method_name]\n        \n        # Calculate the maximum stable time step\n        delta_t_max = r_rk / rho\n        results.append(delta_t_max)\n\n    # Format the results to exactly 9 decimal places and join into a string.\n    formatted_results = [f\"{res:.9f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3320625"}]}