{"hands_on_practices": [{"introduction": "经典的 Smagorinsky 模型虽然是亚格子应力模型的基础，但它存在一个显著缺陷：无法区分层流中的平均剪切和由湍流产生的剪切。本练习 [@problem_id:3373067] 提供了一个亲手分析和论证这一缺陷的机会。通过将该模型应用于简单的层流剪切流，你将看到它如何错误地预测了亚格子尺度耗散，并精确理解为何能够“自动关闭”的动态程序是必要且强大的进步。", "problem": "考虑一个不可压缩层流简单剪切流的大涡模拟 (LES)，其滤波后的速度场由 $\\bar{\\mathbf{u}}(x,y,z) = (G y,\\, 0,\\, 0)$ 给出，其中 $G$ 是一个恒定的剪切率。该 LES 应用了宽度为 $\\Delta$ 的空间滤波器，并通过涡粘性封闭来模拟偏亚格子尺度 (SGS) 应力。\n\n从下述定义和定律出发，完成以下任务：\n1. 使用不可压缩流动的滤波应变率张量 $S_{ij}$ 的运动学定义，仅用 $G$ 计算其标量大小 $|\\bar{S}|$，其中大小定义为 $|\\bar{S}| = \\left(2\\,\\bar{S}_{ij}\\,\\bar{S}_{ij}\\right)^{1/2}$。\n2. 使用涡粘性封闭 $\\tau^{\\mathrm{SGS}}_{ij} - \\frac{1}{3}\\,\\tau^{\\mathrm{SGS}}_{kk}\\,\\delta_{ij} = -2\\,\\nu_{t}\\,\\bar{S}_{ij}$ 和 Smagorinsky 假设 $\\nu_{t} = \\left(C_{S}\\,\\Delta\\right)^{2}\\,|\\bar{S}|$，其中模型系数 $C_{S}$ 为常数，从基本原理出发，论证为何即使在网格细化时（即 $\\Delta \\to 0$），尽管流动是完全解析的层流，这种常数 $C_S$ 封闭仍然预测出非零的 SGS 耗散。然后，从动态 Smagorinsky 程序核心的 Germano 恒等式出发，解释为什么对于该流动，动态计算出的 $C_{S}^{2}$ 会消失。\n\n仅使用以下基本要素作为出发点：\n- 不可压缩滤波连续性方程 $\\partial \\bar{u}_{i}/\\partial x_{i} = 0$。\n- 滤波应变率定义 $\\bar{S}_{ij} = \\frac{1}{2}\\left(\\frac{\\partial \\bar{u}_{i}}{\\partial x_{j}} + \\frac{\\partial \\bar{u}_{j}}{\\partial x_{i}}\\right)$。\n- 偏 SGS 封闭 $\\tau^{\\mathrm{SGS}}_{ij} - \\frac{1}{3}\\,\\tau^{\\mathrm{SGS}}_{kk}\\,\\delta_{ij} = -2\\,\\nu_{t}\\,\\bar{S}_{ij}$ 及 $\\nu_{t} = \\left(C_{S}\\,\\Delta\\right)^{2}\\,|\\bar{S}|$。\n- 用于 LES 和测试滤波的 Germano 恒等式：$L_{ij} = \\widetilde{\\overline{u_{i}\\,u_{j}}} - \\tilde{\\bar{u}}_{i}\\,\\tilde{\\bar{u}}_{j}$，其中波浪号表示测试滤波，上划线表示网格滤波，$L_{ij}$ 是 Leonard 应力。\n\n将 $|\\bar{S}|$ 的值报告为仅含 $G$ 的单个代数表达式。无需进行数值计算。如果在推理中引入任何物理单位，请用国际单位制 (SI) 明确说明，但最终报告的表达式必须是仅用 $G$ 写出的无量纲形式。", "solution": "该问题要求对给定的不可压缩层流简单剪切流的 Smagorinsky 亚格子尺度 (SGS) 模型进行两部分分析。首先，我们计算滤波应变率张量的大小。其次，我们分析常系数和动态 Smagorinsky 模型对于此流动的行为。\n\n**第 1 部分：滤波应变率大小 $|\\bar{S}|$ 的计算**\n\n问题给出了滤波速度场 $\\bar{\\mathbf{u}}$，在笛卡尔坐标系 $(x_1, x_2, x_3) = (x, y, z)$ 中的分量为：\n$$\n\\bar{u}_1 = G y = G x_2 \\\\\n\\bar{u}_2 = 0 \\\\\n\\bar{u}_3 = 0\n$$\n其中 $G$ 是恒定的剪切率。\n\n滤波应变率张量 $\\bar{S}_{ij}$ 定义为：\n$$\n\\bar{S}_{ij} = \\frac{1}{2}\\left(\\frac{\\partial \\bar{u}_{i}}{\\partial x_{j}} + \\frac{\\partial \\bar{u}_{j}}{\\partial x_{i}}\\right)\n$$\n我们计算该张量的分量。唯一非零的速度分量偏导数是 $\\frac{\\partial \\bar{u}_1}{\\partial x_2} = G$。所有其他导数，如 $\\frac{\\partial \\bar{u}_1}{\\partial x_1}$、$\\frac{\\partial \\bar{u}_1}{\\partial x_3}$、$\\frac{\\partial \\bar{u}_2}{\\partial x_j}$ 和 $\\frac{\\partial \\bar{u}_3}{\\partial x_j}$，均为零。\n\n$\\bar{S}_{ij}$ 的对角分量为：\n$$\n\\bar{S}_{11} = \\frac{\\partial \\bar{u}_1}{\\partial x_1} = 0 \\\\\n\\bar{S}_{22} = \\frac{\\partial \\bar{u}_2}{\\partial x_2} = 0 \\\\\n\\bar{S}_{33} = \\frac{\\partial \\bar{u}_3}{\\partial x_3} = 0\n$$\n非对角分量为：\n$$\n\\bar{S}_{12} = \\bar{S}_{21} = \\frac{1}{2}\\left(\\frac{\\partial \\bar{u}_1}{\\partial x_2} + \\frac{\\partial \\bar{u}_2}{\\partial x_1}\\right) = \\frac{1}{2}(G + 0) = \\frac{G}{2} \\\\\n\\bar{S}_{13} = \\bar{S}_{31} = \\frac{1}{2}\\left(\\frac{\\partial \\bar{u}_1}{\\partial x_3} + \\frac{\\partial \\bar{u}_3}{\\partial x_1}\\right) = \\frac{1}{2}(0 + 0) = 0 \\\\\n\\bar{S}_{23} = \\bar{S}_{32} = \\frac{1}{2}\\left(\\frac{\\partial \\bar{u}_2}{\\partial x_3} + \\frac{\\partial \\bar{u}_3}{\\partial x_2}\\right) = \\frac{1}{2}(0 + 0) = 0\n$$\n因此，滤波应变率张量的矩阵形式为：\n$$\n\\bar{S}_{ij} =\n\\begin{pmatrix}\n0  & \\frac{G}{2} & 0 \\\\\n\\frac{G}{2} & 0 & 0 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n$$\n滤波应变率张量的大小定义为 $|\\bar{S}| = (2\\,\\bar{S}_{ij}\\,\\bar{S}_{ij})^{1/2}$，其中隐含了对重复指标的求和。\n首先，我们计算乘积 $\\bar{S}_{ij}\\,\\bar{S}_{ij}$：\n$$\n\\bar{S}_{ij}\\,\\bar{S}_{ij} = \\sum_{i=1}^3 \\sum_{j=1}^3 (\\bar{S}_{ij})^2 = (\\bar{S}_{12})^2 + (\\bar{S}_{21})^2 = \\left(\\frac{G}{2}\\right)^2 + \\left(\\frac{G}{2}\\right)^2 = \\frac{G^2}{4} + \\frac{G^2}{4} = \\frac{G^2}{2}\n$$\n现在，我们将此结果代入 $|\\bar{S}|$ 的定义中：\n$$\n|\\bar{S}| = \\left(2 \\cdot \\frac{G^2}{2}\\right)^{1/2} = \\left(G^2\\right)^{1/2} = |G|\n$$\n由于问题要求表达式仅含 $G$，并且剪切率是可以为正或为负的标量，因此最准确的形式是 $|G|$。\n\n**第 2 部分：Smagorinsky 封闭的分析**\n\n**常系数 Smagorinsky 模型的失效：**\n标准的 Smagorinsky 模型提出了一个由下式给出的涡粘性系数 $\\nu_t$：\n$$\n\\nu_t = (C_S \\Delta)^2 |\\bar{S}|\n$$\n其中 $C_S$ 是一个常数，$\\Delta$ 是滤波器宽度。偏 SGS 应力随后被建模为：\n$$\n\\tau^{\\mathrm{SGS}}_{ij} - \\frac{1}{3}\\tau^{\\mathrm{SGS}}_{kk}\\delta_{ij} = -2 \\nu_t \\bar{S}_{ij}\n$$\nSGS 动能耗散率是 $\\epsilon_{\\mathrm{SGS}} = -(\\tau^{\\mathrm{SGS}}_{ij} - \\frac{1}{3}\\tau^{\\mathrm{SGS}}_{kk}\\delta_{ij})\\bar{S}_{ij} = 2 \\nu_t \\bar{S}_{ij}\\bar{S}_{ij}$。\n对于给定的流动，我们得到 $|\\bar{S}| = |G|$。将其代入 $\\nu_t$ 的模型中：\n$$\n\\nu_t = (C_S \\Delta)^2 |G|\n$$\n由于在此公式中 $C_S$ 是一个非零常数，$\\Delta > 0$，且我们假设一个非平凡的剪切流（$G \\neq 0$），该模型预测涡粘性系数非零 $\\nu_t \\neq 0$。这反过来导致了非零的偏 SGS 应力和非零的 SGS 耗散率：\n$$\n\\epsilon_{\\mathrm{SGS}} = 2 \\left((C_S \\Delta)^2 |G|\\right) \\left(\\frac{G^2}{2}\\right) = (C_S \\Delta)^2 |G| G^2 = C_S^2 \\Delta^2 |G|^3\n$$\n根本的缺陷在于，原始流动被指定为*层流*。在层流中，没有湍流脉动，因此 SGS 应力张量必须为零。常系数 Smagorinsky 模型仅依赖于*已解析*应变率的大小 $|\\bar{S}|$。由于简单剪切流具有非零的平均应变率，该模型错误地预测了亚格子尺度湍流的存在，并从已解析的流场中虚假地移除了能量。该模型无法区分具有平均剪切的湍流和简单的层流剪切流。即使在网格细化时（$\\Delta \\to 0$），对于任何有限的 $\\Delta$，该模型都会预测虚假的耗散，尽管这种耗散在极限情况下确实会趋于零。\n\n**动态 Smagorinsky 程序的成功：**\n动态程序通过基于两个不同滤波尺度上的流动信息来计算 $C_S$，从而纠正了这一缺陷：网格滤波器（宽度为 $\\Delta$，用 $\\bar{\\cdot}$ 表示）和测试滤波器（宽度为 $\\hat{\\Delta} > \\Delta$，用 $\\tilde{\\cdot}$ 表示）。该程序源自 Germano 恒等式，它关联了这两个尺度上的应力：\n$$\nL_{ij} = T_{ij} - \\widetilde{\\tau_{ij}}\n$$\n其中 $L_{ij} = \\widetilde{\\bar{u}_i \\bar{u}_j} - \\tilde{\\bar{u}}_i \\tilde{\\bar{u}}_j$ 是 Leonard 应力（可从已解析场 $\\bar{u}_i$ 计算），$T_{ij} = \\widetilde{\\overline{u_i u_j}} - \\tilde{\\bar{u}}_i \\tilde{\\bar{u}}_j$ 是亚测试尺度应力，而 $\\tau_{ij} = \\overline{u_i u_j} - \\bar{u}_i \\bar{u}_j$ 是亚格子尺度应力。\n\n通过使用 Smagorinsky 封闭对 $\\tau_{ij}$ 和 $T_{ij}$ 的偏量部分进行建模，并假设 $C_S$ 在两个滤波层级之间是常数，可以得到关系式 $L_{ij}^{\\text{dev}} \\approx C_S^2 M_{ij}$，其中 $L_{ij}^{\\text{dev}}$ 是 Leonard 应力张量的偏量部分，而 $M_{ij}$ 是一个同样可以从滤波速度场计算出的张量。\n$C_S^2$ 随后通过最小化此关系中的误差来求得，通常通过最小二乘法：$C_S^2 \\propto \\frac{L_{ij}^{\\text{dev}} M_{ij}}{M_{kl} M_{kl}}$。\n\n我们来分析给定流动 $\\bar{u}_1 = Gx_2$ 的 $L_{ij}$ 和 $M_{ij}$。我们假设标准滤波器不会改变坐标的线性函数，因此 $\\tilde{\\bar{u}}_1 = \\widetilde{Gx_2} = Gx_2 = \\bar{u}_1$。然而，滤波确实会影响非线性项。\n乘积 $\\bar{u}_i \\bar{u}_j$ 中唯一的非零项是 $\\bar{u}_1\\bar{u}_1 = (Gx_2)^2$。对这个二次项应用测试滤波器得到 $\\widetilde{(Gx_2)^2} = (Gx_2)^2 + C$，其中 $C$ 为某个常数，取决于滤波器的形状和宽度 $\\hat{\\Delta}$（例如，对于一维箱式滤波器，$C = G^2\\hat{\\Delta}^2/12$）。\nLeonard 应力分量为：\n$$\nL_{11} = \\widetilde{\\bar{u}_1 \\bar{u}_1} - \\tilde{\\bar{u}}_1 \\tilde{\\bar{u}}_1 = ((Gx_2)^2 + C) - (Gx_2)^2 = C\n$$\n所有其他分量 $L_{ij}$ 均为零，因为它们涉及像 $\\bar{u}_1\\bar{u}_2=0$ 这样的乘积。因此，$L_{ij}$ 是一个对角张量。所以，它的偏量部分 $L_{ij}^{\\text{dev}} = L_{ij} - \\frac{1}{3}L_{kk}\\delta_{ij}$ 也是一个对角张量。\n\n现在，我们来分析模型张量 $M_{ij}$。在动态程序中， $M_{ij}$ 是由模型本身的形式决定的。根据 Smagorinsky 模型，$M_{ij}$ 与应变率张量成比例。由于 $\\tilde{\\bar{u}}_i = \\bar{u}_i$，应变率张量也相同：$\\tilde{\\bar{S}}_{ij} = \\bar{S}_{ij}$。因此，$M_{ij}$ 与 $\\bar{S}_{ij}$ 成正比。正如我们在第 1 部分中发现的，$\\bar{S}_{ij}$ 是一个纯非对角张量。\n\n最后，我们从分子 $L_{ij}^{\\text{dev}} M_{ij}$ 计算 $C_S^2$。这是一个对角张量 ($L_{ij}^{\\text{dev}}$) 和一个纯非对角张量 ($M_{ij}$) 的缩并积（内积）。这样的乘积恒等于零：\n$$\nL_{ij}^{\\text{dev}} M_{ij} = \\sum_{i,j} L_{ij}^{\\text{dev}} M_{ij} = 0\n$$\n分母 $M_{kl}M_{kl}$ 与 $\\bar{S}_{kl}\\bar{S}_{kl} = G^2/2$ 成正比，是非零的。\n因此，动态计算出的系数为：\n$$\nC_S^2 = \\frac{0}{\\text{非零}} = 0\n$$\n动态程序正确地确定了对于这种层流，模型系数必须为零，这反过来意味着 $\\nu_t = 0$，并且虚假的 SGS 耗散被消除。该模型正确地“自行关闭”。", "answer": "$$\n\\boxed{|G|}\n$$", "id": "3373067"}, {"introduction": "在确立了动态系数的必要性之后，我们现在转向其计算的核心数学方法。本练习 [@problem_id:3373015] 将引导你使用最小二乘法，从 Germano 恒等式中推导出局部的 Smagorinsky 系数。你还将实施约束条件来处理非物理的能量“反传”现象，并探索这些选择如何直接影响已解析动能的收支，从而在数值建模与流体物理之间建立起关键的联系。", "problem": "考虑一个二维、不可压缩的大涡模拟（Large-Eddy Simulation (LES)）设定，其中亚网格尺度（Subgrid-Scale (SGS)）应力采用空间局地的动态涡黏性模型。设某点处的已解析速度梯度定义了已解析应变率张量 $S_{ij} = \\tfrac{1}{2} \\left( \\partial \\bar{u}_i/\\partial x_j + \\partial \\bar{u}_j/\\partial x_i \\right)$，对于不可压缩流，该张量满足 $S_{11} + S_{22} = 0$。Smagorinsky 假设将 SGS 应力的偏量部分建模为 $\\tau_{ij}^{\\mathrm{sgs}} - \\tfrac{1}{3}\\tau_{kk}^{\\mathrm{sgs}}\\delta_{ij} = -2 \\nu_t S_{ij}$，其中涡黏性为 $\\nu_t = C \\Delta^2 \\lvert S \\rvert$。此处 $C$ 是一个待动态估计的无量纲系数，$\\Delta$ 是已解析尺度上的滤波宽度，$\\lvert S \\rvert$ 是由 $\\lvert S \\rvert = \\sqrt{2 S_{ij} S_{ij}}$ 定义的已解析应变大小，其中隐含的求和是所有指标上的完全双点积。\n\n动态 Smagorinsky 过程使用一个测试滤波器（由帽子符号表示）和 Germano 恒等式，将一个测量得到的 Leonard 应力张量与一个线性依赖于 $C$ 的模型项关联起来。在二维情况下，Germano 恒等式可以象征性地写为 $L_{ij} \\approx 2 C M_{ij}$，其中 $L_{ij}$ 是通过测试滤波和网格滤波得到的 Leonard 张量，$M_{ij}$ 是一个由已滤波场和模型形式构成的已知对称张量。局地动态系数 $C$ 由 $L_{ij}$ 和 $2 C M_{ij}$ 之间残差的最小二乘解确定，该解基于由双点积 $A:B \\equiv \\sum_{i,j} A_{ij} B_{ij}$ 导出的欧几里得（Frobenius）范数。\n\n您的任务是：\n- 仅从以上定义出发，使用标准双点积 $A:B = \\sum_{i=1}^{2}\\sum_{j=1}^{2} A_{ij} B_{ij}$，推导出给出 $C$ 的局地最小二乘估计（作为 $L_{ij}$ 和 $M_{ij}$ 的函数）的正规方程。\n- 实现两个 $C$ 的局地估计器：\n  1. 无约束最小二乘估计器 $C_{\\mathrm{LS}}$。\n  2. 有约束最小二乘估计器 $C_{\\mathrm{CLS}}$，它强制执行逐点不等式约束 $C \\ge C_{\\min}$，其中 $C_{\\min}$ 是一个给定的非负下界。如果某点处因分母恒为零而导致最小二乘正规方程是病态的，则通过在分母中添加一个小的 Tikhonov 正则化项 $\\varepsilon$（其中 $\\varepsilon = 10^{-12}$）来处理，然后再应用约束。\n- 对于每个点，使用模型形式和您的局地 $C$ 估计值，计算出现在已解析动能收支中的已解析尺度到亚网格尺度的能量传递密度 $\\Pi = -\\tau_{ij}^{\\mathrm{sgs}} S_{ij}$。将 $\\Pi$ 完全用 $C$、$\\Delta$ 和已解析应变率张量表示。假设不可压缩性，因此各向同性应力对 $\\Pi$ 没有贡献。\n- 对于下面的每个测试用例，计算所有点上 $C_{\\mathrm{LS}}$ 的空间平均值、$C_{\\mathrm{CLS}}$ 的空间平均值，以及相应 $\\Pi$ 场的空间平均值，记为 $\\overline{C_{\\mathrm{LS}}}$、$\\overline{C_{\\mathrm{CLS}}}$、$\\overline{\\Pi}_{\\mathrm{LS}}$ 和 $\\overline{\\Pi}_{\\mathrm{CLS}}$。\n\n使用以下测试套件。每个测试用例都是二维的，所有量均为无量纲。在一个测试用例中，所有点处的已解析滤波宽度是常数 $\\Delta = 1.0$。在每个点，对称张量的唯一分量按 $(\\cdot)_{11}$、$(\\cdot)_{12}$、$(\\cdot)_{22}$ 的顺序列出。对于每个测试，计算所有列出点的平均值。\n\n测试用例 A（理想情况，无约束与有约束结果一致）：\n- $C_{\\min} = 0.0$。\n- 各点处的已解析应变 $S_{ij}$：\n  - 各点间的 $\\left( S_{11}, S_{12}, S_{22} \\right)$：$\\left( (0.5, 0.3, -0.5), (0.4, 0.2, -0.4), (0.6, 0.1, -0.6), (0.1, 0.05, -0.1), (0.3, 0.25, -0.3) \\right)$。\n- 各点处的 Leonard 张量 $L_{ij}$：\n  - $\\left( (0.0048, 0.0024, 0.0072), (0.006, 0.003, 0.005), (0.007, 0.00224, 0.0056), (0.0032, 0.0008, 0.0024), (0.00396, 0.00198, 0.00484) \\right)$。\n- 各点处的模型张量 $M_{ij}$：\n  - $\\left( (0.02, 0.01, 0.03), (0.03, 0.015, 0.025), (0.025, 0.008, 0.02), (0.02, 0.005, 0.015), (0.018, 0.009, 0.022) \\right)$。\n\n测试用例 B（能量反传，无约束的负 $C$ 值被约束截断）：\n- $C_{\\min} = 0.0$。\n- 各点处的 $S_{ij}$：\n  - $\\left( (0.5, 0.4, -0.5), (0.7, 0.2, -0.7), (0.2, 0.3, -0.2), (0.4, 0.1, -0.4), (0.6, 0.25, -0.6) \\right)$。\n- 各点处的 $L_{ij}$：\n  - $\\left( (-0.0024, -0.0012, -0.0036), (-0.0048, -0.0024, -0.0032), (-0.0015, -0.0006, -0.0017), (-0.00308, -0.0014, -0.00266), (-0.00216, -0.00108, -0.00252) \\right)$。\n- 各点处的 $M_{ij}$：\n  - $\\left( (0.02, 0.01, 0.03), (0.03, 0.015, 0.02), (0.015, 0.006, 0.017), (0.022, 0.01, 0.019), (0.018, 0.009, 0.021) \\right)$。\n\n测试用例 C（近奇异正规方程，正则化加严格正值约束）：\n- $C_{\\min} = 0.02$。\n- 各点处的 $S_{ij}$：\n  - $\\left( (0.5, 0.2, -0.5), (0.3, 0.4, -0.3), (0.7, 0.1, -0.7) \\right)$。\n- 各点处的 $L_{ij}$：\n  - $\\left( (0.0001, 0.00005, 0.00012), (0.00005, 0.00002, 0.00006), (0.00008, 0.00003, 0.00007) \\right)$。\n- 各点处的 $M_{ij}$：\n  - $\\left( (0.0, 0.0, 0.0), (0.0, 0.0, 0.0), (0.0, 0.0, 0.0) \\right)$。\n\n测试用例 D（阈值提升了小的正系数）：\n- $C_{\\min} = 0.09$。\n- 各点处的 $S_{ij}$：\n  - $\\left( (0.35, 0.25, -0.35), (0.45, 0.15, -0.45), (0.55, 0.2, -0.55), (0.4, 0.1, -0.4) \\right)$。\n- 各点处的 $L_{ij}$：\n  - $\\left( (0.0024, 0.0012, 0.00216), (0.0035, 0.00168, 0.00308), (0.0048, 0.0024, 0.00384), (0.0018, 0.0009, 0.002) \\right)$。\n- 各点处的 $M_{ij}$：\n  - $\\left( (0.02, 0.01, 0.018), (0.025, 0.012, 0.022), (0.03, 0.015, 0.024), (0.018, 0.009, 0.02) \\right)$。\n\n算法和数值要求：\n- 对于对称二维张量，使用完全双点积的定义，因此对于任何由其唯一分量 $(A_{11}, A_{12}, A_{22})$ 和 $(B_{11}, B_{12}, B_{22})$ 表示的对称张量 $A_{ij}$ 和 $B_{ij}$，其双点积为 $A:B = A_{11}B_{11} + A_{22}B_{22} + 2 A_{12} B_{12}$，Frobenius 范数的平方为 $A:A$。\n- 在得到每个点的 $C$ 的最小二乘估计后，计算该点进入已解析动能收支的已解析尺度到亚网格尺度的能量传递密度 $\\Pi$，然后在每个测试用例中对所有列出的点进行平均。\n- 所有量均为无量纲，因此不需要物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，按 A、B、C、D 的顺序包含一个列表的列表。每个内部列表必须是 $[\\overline{C_{\\mathrm{LS}}}, \\overline{C_{\\mathrm{CLS}}}, \\overline{\\Pi}_{\\mathrm{LS}}, \\overline{\\Pi}_{\\mathrm{CLS}}]$ 的形式，其中每个条目四舍五入到六位小数。例如，一个有效的整体格式是 $[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_3],[a_4,b_4,c_4,d_4]]$，其中每个 $a_k,b_k,c_k,d_k$ 是小数点后有六位数的小数。", "solution": "此问题是有效的，因为它在科学上基于计算流体动力学，特别是大涡模拟（LES）的原理，并提出了一个适定、自洽且客观的计算任务。所有必要的数据和定义都已提供，不存在内部矛盾或违反数学或物理原理的情况。\n\n解答过程分为三部分：首先，推导局地动态系数 $C$；其次，推导 SGS 能量传递密度 $\\Pi$；第三，将这些公式应用于提供的测试用例。\n\n### 动态系数 $C$ 的推导\n\n动态过程通过最小化 Leonard 张量 $L_{ij}$ 与其模型 $2 C M_{ij}$ 之间的残差来估计 Smagorinsky 系数 $C$。目标是找到使残差张量 $R_{ij} = L_{ij} - 2 C M_{ij}$ 的 Frobenius 范数平方最小化的 $C$ 值。代价函数 $J(C)$ 为：\n$$ J(C) = R_{ij} : R_{ij} = (L_{ij} - 2 C M_{ij}) : (L_{ij} - 2 C M_{ij}) $$\n其中双点积 $A:B$ 定义为 $\\sum_{i,j} A_{ij} B_{ij}$。利用双点积的性质展开代价函数可得：\n$$ J(C) = (L:L) - 2C(L:M) - 2C(M:L) + 4C^2(M:M) $$\n由于双点积是可交换的（$L:M = M:L$），上式可简化为：\n$$ J(C) = (L:L) - 4C(L:M) + 4C^2(M:M) $$\n为求最小值，我们计算 $J(C)$ 对 $C$ 的导数并令其为零。这给出了正规方程：\n$$ \\frac{dJ}{dC} = -4(L:M) + 8C(M:M) = 0 $$\n求解 $C$ 可得到无约束最小二乘估计值 $C_{\\mathrm{LS}}$：\n$$ C_{\\mathrm{LS}} = \\frac{4(L:M)}{8(M:M)} = \\frac{L:M}{2(M:M)} $$\n对于由其唯一分量 $(A_{11}, A_{12}, A_{22})$ 和 $(B_{11}, B_{12}, B_{22})$ 给出的对称二维张量，所需的双点积计算如下：\n$$ L:M = L_{11}M_{11} + L_{22}M_{22} + 2L_{12}M_{12} $$\n$$ M:M = M_{11}^2 + M_{22}^2 + 2M_{12}^2 $$\n\n问题指定了两种 $C$ 的估计器：\n\n1.  **无约束估计器 $C_{\\mathrm{LS}}$**：这由推导出的公式直接给出。当分母 $2(M:M)$ 恒为零时（即 $M_{ij}$ 为零张量），方程是病态的。问题规定通过在分母中添加一个小参数 $\\varepsilon = 10^{-12}$ 来进行 Tikhonov 正则化。因此，公式变为：\n    $$ C_{\\mathrm{LS}} = \\frac{L:M}{2(M:M) + \\varepsilon'} $$\n    其中，如果 $M:M=0$，则 $\\varepsilon' = \\varepsilon$，否则 $\\varepsilon'=0$。根据在“分母中”添加 $\\varepsilon$ 的指令，这是最直接的解释。请注意，如果 $M_{ij}=0$，那么 $L:M=0$，导致 $C_{\\mathrm{LS}} = 0$。\n\n2.  **有约束估计器 $C_{\\mathrm{CLS}}$**：该估计器强制实现物理可实现性，通常确保 SGS 模型是耗散的。它是通过在指定的非负下界 $C_{\\min}$ 处截断无约束估计值 $C_{\\mathrm{LS}}$ 得到的：\n    $$ C_{\\mathrm{CLS}} = \\max(C_{\\mathrm{LS}}, C_{\\min}) $$\n\n### SGS 能量传递密度 $\\Pi$ 的推导\n\nSGS 能量传递密度 $\\Pi$ 代表从已解析尺度到亚网格尺度的能量传递速率。其定义为：\n$$ \\Pi = -\\tau_{ij}^{\\mathrm{sgs}} S_{ij} $$\nSGS 应力张量 $\\tau_{ij}^{\\mathrm{sgs}}$ 可以分解为其偏量（无迹）部分 $\\tau_{ij}^{\\mathrm{sgs, dev}}$ 和其各向同性部分：$\\tau_{ij}^{\\mathrm{sgs}} = \\tau_{ij}^{\\mathrm{sgs, dev}} + \\frac{1}{3}\\tau_{kk}^{\\mathrm{sgs}}\\delta_{ij}$。将此代入 $\\Pi$ 的表达式中：\n$$ \\Pi = -\\left(\\tau_{ij}^{\\mathrm{sgs, dev}} + \\frac{1}{3}\\tau_{kk}^{\\mathrm{sgs}}\\delta_{ij}\\right) S_{ij} = -\\tau_{ij}^{\\mathrm{sgs, dev}} S_{ij} - \\frac{1}{3}\\tau_{kk}^{\\mathrm{sgs}} S_{ii} $$\n对于不可压缩流，连续性方程意味着已解析应变率张量是无迹的，即 $S_{ii} = S_{11} + S_{22} = 0$。因此，SGS 应力的各向同性部分对能量传递没有贡献，表达式简化为：\n$$ \\Pi = -\\tau_{ij}^{\\mathrm{sgs, dev}} S_{ij} $$\nSmagorinsky 模型为偏 SGS 应力提供了一个本构关系：\n$$ \\tau_{ij}^{\\mathrm{sgs, dev}} = -2 \\nu_t S_{ij} $$\n其中涡黏性为 $\\nu_t = C \\Delta^2 |S|$。将此代入 $\\Pi$ 的表达式中：\n$$ \\Pi = -(-2 \\nu_t S_{ij}) S_{ij} = 2 \\nu_t (S_{ij} S_{ij}) = 2(C \\Delta^2 |S|) (S_{ij} S_{ij}) $$\n应变率张量的大小定义为 $|S| = \\sqrt{2 S_{ij} S_{ij}}$。由此可得 $|S|^2 = 2 S_{ij} S_{ij}$，这意味着 $S_{ij} S_{ij} = \\frac{1}{2}|S|^2$。将这最后一个关系代入 $\\Pi$ 的表达式中：\n$$ \\Pi = 2(C \\Delta^2 |S|) \\left(\\frac{1}{2}|S|^2\\right) = C \\Delta^2 |S|^3 $$\n这就是所求的能量传递密度表达式。对于指定的问题，滤波宽度 $\\Delta = 1.0$。$|S|$ 的大小由给定的 $S_{ij}$ 分量计算。对于二维不可压缩流，$S_{22}=-S_{11}$，所以双点积 $S:S$ 为：\n$$ S:S = S_{11}^2 + S_{22}^2 + 2S_{12}^2 = S_{11}^2 + (-S_{11})^2 + 2S_{12}^2 = 2S_{11}^2 + 2S_{12}^2 $$\n因此，$|S|$ 的大小为：\n$$ |S| = \\sqrt{2(S:S)} = \\sqrt{2(2S_{11}^2 + 2S_{12}^2)} = 2\\sqrt{S_{11}^2 + S_{12}^2} $$\n\n### 计算步骤\n\n对于每个测试用例，我们对每个数据点执行以下计算：\n1.  计算双点积 $L:M$ 和 $M:M$。\n2.  使用推导的公式计算 $C_{\\mathrm{LS}}$，如果 $M:M=0$ 则应用正则化。\n3.  通过应用下界 $C_{\\min}$ 来计算 $C_{\\mathrm{CLS}}$。\n4.  计算应变率大小 $|S|$。\n5.  计算能量传递密度 $\\Pi_{\\mathrm{LS}} = C_{\\mathrm{LS}} \\Delta^2 |S|^3$ 和 $\\Pi_{\\mathrm{CLS}} = C_{\\mathrm{CLS}} \\Delta^2 |S|^3$（其中 $\\Delta=1.0$）。\n最后，在每个测试用例中计算所有点上的 $C_{\\mathrm{LS}}$、$C_{\\mathrm{CLS}}$、$\\Pi_{\\mathrm{LS}}$ 和 $\\Pi_{\\mathrm{CLS}}$ 的空间平均值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the dynamic Smagorinsky procedure problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"C_min\": 0.0,\n            \"S\": [(0.5, 0.3, -0.5), (0.4, 0.2, -0.4), (0.6, 0.1, -0.6), (0.1, 0.05, -0.1), (0.3, 0.25, -0.3)],\n            \"L\": [(0.0048, 0.0024, 0.0072), (0.006, 0.003, 0.005), (0.007, 0.00224, 0.0056), (0.0032, 0.0008, 0.0024), (0.00396, 0.00198, 0.00484)],\n            \"M\": [(0.02, 0.01, 0.03), (0.03, 0.015, 0.025), (0.025, 0.008, 0.02), (0.02, 0.005, 0.015), (0.018, 0.009, 0.022)],\n        },\n        {\n            \"name\": \"B\",\n            \"C_min\": 0.0,\n            \"S\": [(0.5, 0.4, -0.5), (0.7, 0.2, -0.7), (0.2, 0.3, -0.2), (0.4, 0.1, -0.4), (0.6, 0.25, -0.6)],\n            \"L\": [(-0.0024, -0.0012, -0.0036), (-0.0048, -0.0024, -0.0032), (-0.0015, -0.0006, -0.0017), (-0.00308, -0.0014, -0.00266), (-0.00216, -0.00108, -0.00252)],\n            \"M\": [(0.02, 0.01, 0.03), (0.03, 0.015, 0.02), (0.015, 0.006, 0.017), (0.022, 0.01, 0.019), (0.018, 0.009, 0.021)],\n        },\n        {\n            \"name\": \"C\",\n            \"C_min\": 0.02,\n            \"S\": [(0.5, 0.2, -0.5), (0.3, 0.4, -0.3), (0.7, 0.1, -0.7)],\n            \"L\": [(0.0001, 0.00005, 0.00012), (0.00005, 0.00002, 0.00006), (0.00008, 0.00003, 0.00007)],\n            \"M\": [(0.0, 0.0, 0.0), (0.0, 0.0, 0.0), (0.0, 0.0, 0.0)],\n        },\n        {\n            \"name\": \"D\",\n            \"C_min\": 0.09,\n            \"S\": [(0.35, 0.25, -0.35), (0.45, 0.15, -0.45), (0.55, 0.2, -0.55), (0.4, 0.1, -0.4)],\n            \"L\": [(0.0024, 0.0012, 0.00216), (0.0035, 0.00168, 0.00308), (0.0048, 0.0024, 0.00384), (0.0018, 0.0009, 0.002)],\n            \"M\": [(0.02, 0.01, 0.018), (0.025, 0.012, 0.022), (0.03, 0.015, 0.024), (0.018, 0.009, 0.02)],\n        },\n    ]\n\n    delta = 1.0\n    epsilon = 1e-12\n    all_results = []\n\n    for case in test_cases:\n        C_min = case[\"C_min\"]\n        points_S = case[\"S\"]\n        points_L = case[\"L\"]\n        points_M = case[\"M\"]\n        \n        c_ls_list = []\n        c_cls_list = []\n        pi_ls_list = []\n        pi_cls_list = []\n\n        num_points = len(points_S)\n        for i in range(num_points):\n            S11, S12, S22 = points_S[i]\n            L11, L12, L22 = points_L[i]\n            M11, M12, M22 = points_M[i]\n            \n            # Double contraction L:M and M:M\n            L_dot_M = L11 * M11 + L22 * M22 + 2 * L12 * M12\n            M_dot_M = M11**2 + M22**2 + 2 * M12**2\n            \n            # Calculate unconstrained C_LS with regularization\n            denom = 2 * M_dot_M\n            if np.isclose(denom, 0.0):\n                denom += epsilon\n            \n            c_ls = L_dot_M / denom\n            \n            # Calculate constrained C_CLS\n            c_cls = max(c_ls, C_min)\n            \n            # Calculate strain magnitude |S|\n            s_mag = 2 * np.sqrt(S11**2 + S12**2)\n            \n            # Calculate energy transfer Pi\n            pi_ls = c_ls * (delta**2) * (s_mag**3)\n            pi_cls = c_cls * (delta**2) * (s_mag**3)\n            \n            c_ls_list.append(c_ls)\n            c_cls_list.append(c_cls)\n            pi_ls_list.append(pi_ls)\n            pi_cls_list.append(pi_cls)\n            \n        # Calculate spatial averages\n        avg_c_ls = np.mean(c_ls_list)\n        avg_c_cls = np.mean(c_cls_list)\n        avg_pi_ls = np.mean(pi_ls_list)\n        avg_pi_cls = np.mean(pi_cls_list)\n        \n        all_results.append([avg_c_ls, avg_c_cls, avg_pi_ls, avg_pi_cls])\n\n    # Format output as specified\n    formatted_cases = []\n    for case_res in all_results:\n        formatted_case = '[' + ','.join([f'{x:.6f}' for x in case_res]) + ']'\n        formatted_cases.append(formatted_case)\n        \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```", "id": "3373015"}, {"introduction": "一个稳健的动态模型不仅需要一个局部的代数公式，还需要稳定的平均和正确的物理行为，尤其是在固体边界附近。这个实践练习 [@problem_id:3373054] 解决了使用半拉格朗日方法以节省内存的方式实现拉格朗日动态平均方案的挑战。你将设计一个离散算法，该算法结合了平流、松弛和壁面阻尼，以在关键的近壁区域计算出物理上一致的动态系数。", "problem": "考虑一个一维壁面法向的网格点线，其索引为 $j \\in \\{0,1,\\dots,N_y-1\\}$，具有均匀间距 $\\Delta y > 0$，其中 $j=0$ 表示壁面。在动态 Smagorinsky 程序中，系数 $C$ 是通过建模和测试滤波的应力，从滤波后的 Navier–Stokes 方程和 Germano 恒等式中获得的；分子和分母贡献的运行估计值是使用指数松弛沿拉格朗日路径线维持的。在壁面附近，物理和数学的真实性要求系数在壁面处必须精确为零，以反映由于无滑移边界条件而消失的涡粘性。您的任务是设计一个离散实现，该实现能在 $j=0$ 处精确强制 $C=0$，同时通过半拉格朗日平流和指数松弛，在第一个离壁单元 $j=1$ 中与拉格朗日动态平均保持一致。最终输出必须是无量纲浮点数。\n\n基本设置基础：从不可压缩流的滤波后动量方程和沿路径线的物质导数定义开始。令 $A$ 和 $B$ 表示沿拉格朗日轨迹的瞬时分子和分母贡献（从 Germano 恒等式缩并获得）的运行估计值。连续拉格朗日松弛动力学由以下常微分方程控制：\n$$\n\\frac{\\mathrm{D}A}{\\mathrm{D}t} = \\frac{N - A}{T}, \\quad \\frac{\\mathrm{D}B}{\\mathrm{D}t} = \\frac{D - B}{T},\n$$\n其中 $N$ 和 $D$ 是瞬时分子和分母场，$T>0$ 是一个松弛时间尺度，$\\mathrm{D}/\\mathrm{D}t$ 是物质导数。松弛后的动态系数构造为 $C = A/(B+\\varepsilon)$，其中 $\\varepsilon > 0$ 是一个小的正则化参数，以避免除以零。近壁阻尼必须在壁面处强制 $C=0$，并在远离壁面时平滑地趋近于一。\n\n离散实现要求：\n- 在一维网格上使用半拉格朗日平流加松弛格式。对于以 $n \\in \\{0,1,\\dots,N_t-1\\}$ 为索引、时间增量为 $\\Delta t>0$ 的时间步，给定壁面法向速度场 $v^{(n)}_j$，从网格索引 $j$ 回溯到一个连续位置\n$$\ns^{(n)}_j = j - \\frac{v^{(n)}_j \\Delta t}{\\Delta y}.\n$$\n- 令 $A^{(n)}_j$ 和 $B^{(n)}_j$ 为时间步 $n$ 处的离散值。通过在位置 $s^{(n)}_j$ 对 $A^{(n)}$ 和 $B^{(n)}$ 进行线性插值，并强制边界条件，来定义平流中间值 $A^{*,(n+1)}_j$ 和 $B^{*,(n+1)}_j$：\n    - 如果 $s^{(n)}_j \\le 0$，则设置 $A^{*,(n+1)}_j = 0$ 和 $B^{*,(n+1)}_j = 0$ 以与壁面值保持一致。\n    - 如果 $s^{(n)}_j \\ge N_y - 1$，则通过 $A^{*,(n+1)}_j = A^{(n)}_{N_y-1}$ 和 $B^{*,(n+1)}_j = B^{(n)}_{N_y-1}$ 钳制到最后一个内部值。\n- 应用指数松弛更新：\n$$\nA^{(n+1)}_j = A^{*,(n+1)}_j + \\frac{\\Delta t}{T}\\left(N^{(n)}_j - A^{*,(n+1)}_j\\right), \\quad\nB^{(n+1)}_j = B^{*,(n+1)}_j + \\frac{\\Delta t}{T}\\left(D^{(n)}_j - B^{*,(n+1)}_j\\right).\n$$\n- 在每一步强制壁面边界：精确设置 $A^{(n+1)}_0 = 0$ 和 $B^{(n+1)}_0 = 0$。\n- 在最后一个时间步之后，计算无阻尼系数\n$$\nq_j = \\frac{A^{(N_t)}_j}{B^{(N_t)}_j + \\varepsilon}.\n$$\n- 应用一个近壁阻尼函数，该函数满足 $f_d(0)=0$ 且当 $y^+\\to\\infty$ 时 $f_d(y^+)\\to 1$，其中 $y^+$ 是以壁面单位表示的无量纲壁面距离。使用函数\n$$\nf_d(y^+) = 1 - \\exp\\left(-\\frac{y^+}{A^+}\\right),\n$$\n其中 $A^+>0$ 为预设值。最终系数为\n$$\nC_j = f_d(y^+_j)\\, q_j,\n$$\n具有精确的边界条件 $C_0=0$。\n\n输入和测试套件：\n- 所有输出量均为无量纲；不要附加物理单位。\n- 使用 $N_y=5$、$N_t=4$、$\\Delta y = 0.005$、$\\Delta t = 0.002$、$T = 0.02$、$\\varepsilon = 10^{-9}$、$A^+ = 26$ 以及壁面单位距离 $y^+ = [\\,0,\\;10,\\;25,\\;50,\\;100\\,]$。\n- 提供三个测试用例，每个用例指定数组 $N^{(n)}_j$、$D^{(n)}_j$ 和 $v^{(n)}_j$，其中 $n=0,1,2,3$ 且 $j=0,1,2,3,4$：\n\n测试用例 1 (一般一致性):\n- $v^{(0)} = [\\,0.0,\\;0.02,\\;0.03,\\;0.04,\\;0.05\\,]$, $v^{(1)} = [\\,0.0,\\;0.02,\\;0.03,\\;0.04,\\;0.05\\,]$, $v^{(2)} = [\\,0.0,\\;0.02,\\;0.03,\\;0.04,\\;0.05\\,]$, $v^{(3)} = [\\,0.0,\\;0.02,\\;0.03,\\;0.04,\\;0.05\\,]$.\n- $N^{(0)} = [\\,0.0,\\;0.02,\\;0.05,\\;0.08,\\;0.10\\,]$, $N^{(1)} = [\\,0.0,\\;0.025,\\;0.055,\\;0.085,\\;0.105\\,]$, $N^{(2)} = [\\,0.0,\\;0.03,\\;0.06,\\;0.09,\\;0.11\\,]$, $N^{(3)} = [\\,0.0,\\;0.035,\\;0.065,\\;0.095,\\;0.115\\,]$.\n- $D^{(0)} = [\\,0.0,\\;0.50,\\;0.60,\\;0.70,\\;0.80\\,]$, $D^{(1)} = [\\,0.0,\\;0.52,\\;0.62,\\;0.72,\\;0.82\\,]$, $D^{(2)} = [\\,0.0,\\;0.54,\\;0.64,\\;0.74,\\;0.84\\,]$, $D^{(3)} = [\\,0.0,\\;0.56,\\;0.66,\\;0.76,\\;0.86\\,]$.\n\n测试用例 2 (边界相互作用和近壁负分子):\n- $v^{(0)} = [\\,0.0,\\;3.0,\\;0.0,\\;0.0,\\;0.0\\,]$, $v^{(1)} = [\\,0.0,\\;3.0,\\;0.0,\\;0.0,\\;0.0\\,]$, $v^{(2)} = [\\,0.0,\\;3.0,\\;0.0,\\;0.0,\\;0.0\\,]$, $v^{(3)} = [\\,0.0,\\;3.0,\\;0.0,\\;0.0,\\;0.0\\,]$.\n- $N^{(0)} = [\\,0.0,\\;-0.02,\\;0.02,\\;0.05,\\;0.07\\,]$, $N^{(1)} = [\\,0.0,\\;-0.025,\\;0.025,\\;0.055,\\;0.075\\,]$, $N^{(2)} = [\\,0.0,\\;-0.03,\\;0.03,\\;0.06,\\;0.08\\,]$, $N^{(3)} = [\\,0.0,\\;-0.035,\\;0.035,\\;0.065,\\;0.085\\,]$.\n- $D^{(0)} = [\\,0.0,\\;0.50,\\;0.60,\\;0.70,\\;0.80\\,]$, $D^{(1)} = [\\,0.0,\\;0.52,\\;0.62,\\;0.72,\\;0.82\\,]$, $D^{(2)} = [\\,0.0,\\;0.54,\\;0.64,\\;0.74,\\;0.84\\,]$, $D^{(3)} = [\\,0.0,\\;0.56,\\;0.66,\\;0.76,\\;0.86\\,]$.\n\n测试用例 3 (零分母和静止场):\n- $v^{(0)} = [\\,0.0,\\;0.0,\\;0.0,\\;0.0,\\;0.0\\,]$, $v^{(1)} = [\\,0.0,\\;0.0,\\;0.0,\\;0.0,\\;0.0\\,]$, $v^{(2)} = [\\,0.0,\\;0.0,\\;0.0,\\;0.0,\\;0.0\\,]$, $v^{(3)} = [\\,0.0,\\;0.0,\\;0.0,\\;0.0,\\;0.0\\,]$.\n- $N^{(0)} = [\\,0.0,\\;0.01,\\;0.02,\\;0.03,\\;0.04\\,]$, $N^{(1)} = [\\,0.0,\\;0.01,\\;0.02,\\;0.03,\\;0.04\\,]$, $N^{(2)} = [\\,0.0,\\;0.01,\\;0.02,\\;0.03,\\;0.04\\,]$, $N^{(3)} = [\\,0.0,\\;0.01,\\;0.02,\\;0.03,\\;0.04\\,]$.\n- $D^{(0)} = [\\,0.0,\\;0.0,\\;0.0,\\;0.10,\\;0.20\\,]$, $D^{(1)} = [\\,0.0,\\;0.0,\\;0.0,\\;0.10,\\;0.20\\,]$, $D^{(2)} = [\\,0.0,\\;0.0,\\;0.0,\\;0.10,\\;0.20\\,]$, $D^{(3)} = [\\,0.0,\\;0.0,\\;0.0,\\;0.10,\\;0.20\\,]$.\n\n算法约束：\n- 对所有 $j$ 初始化 $A^{(0)}_j = 0$ 和 $B^{(0)}_j = 0$。\n- 在 $j$ 空间中使用线性插值来计算 $A^{*,(n+1)}_j$ 和 $B^{*,(n+1)}_j$。当 $s^{(n)}_j \\le 0$ 时，强制 $A^{*,(n+1)}_j = 0$ 和 $B^{*,(n+1)}_j = 0$，从而保证精确的壁面一致性以及与第一个离壁单元的耦合。\n- 经过 $N_t$ 步后，使用阻尼函数 $f_d$ 计算 $C_j$ 并精确设置 $C_0=0$。\n\n您的程序必须对三个测试用例执行上述步骤，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个条目是对应于一个测试用例的 $N_y$ 个无量纲浮点数列表 $[\\,C_0,\\;C_1,\\;C_2,\\;C_3,\\;C_4\\,]$ (例如, $[[c_{0,0},\\dots,c_{0,4}],[c_{1,0},\\dots,c_{1,4}],[c_{2,0},\\dots,c_{2,4}]]$))。", "solution": "该问题陈述提出了一个在计算流体力学领域中明确定义的计算任务，具体涉及为大涡模拟 (LES) 实现动态 Smagorinsky 亚格子尺度模型。目标是设计并实现一个离散算法，用于在一维壁面法向网格上计算 Smagorinsky 系数 $C$。该算法必须包含半拉格朗日平流、用于时间平均的指数松弛以及适当的近壁处理，以确保物理一致性，即在壁面处 $C=0$。该问题具有科学依据，内容自洽，且算法明确，因此可以进行完整求解。\n\n通过对用于构建动态系数的分子 $A$ 和分母 $B$ 的运行估计值的连续控制方程进行离散化，来开发求解方案。该过程在 $N_y$ 个点的网格上执行指定的 $N_t$ 个时间步。\n\n**1. 状态变量与初始化**\n\n动态程序的核心是沿流体路径线追踪量 $A$ 和 $B$。在此离散设置中，我们定义数组 $A^{(n)}_j$ 和 $B^{(n)}_j$ 来表示在时间步 $n$ 和网格点 $j$ 处的这些值。根据规定，模拟从没有初始历史的静止状态开始，因此在时间 $n=0$ 时将数组初始化为零：\n$$\nA^{(0)}_j = 0, \\quad B^{(0)}_j = 0 \\quad \\text{for } j \\in \\{0, 1, \\dots, N_y-1\\}\n$$\n\n**2. 时间步进程序**\n\n该算法将状态变量 $A$ 和 $B$ 从时间步 $n$ 推进到 $n+1$，其中 $n \\in \\{0, 1, \\dots, N_t-1\\}$。每个时间步包括两个主要阶段：半拉格朗日平流和指数松弛。\n\n**2.1. 半拉格朗日平流**\n\n物质导数 $\\mathrm{D}/\\mathrm{D}t$ 使用半拉格朗日方法处理。对于新时间 $n+1$ 的每个网格点 $j$，我们在时间间隔 $\\Delta t$ 内向后追溯其位置，以找到其在时间 $n$ 的出发点 $s^{(n)}_j$。给定壁面法向速度场 $v^{(n)}_j$，以网格索引度量的出发点为：\n$$\ns^{(n)}_j = j - \\frac{v^{(n)}_j \\Delta t}{\\Delta y}\n$$\n$A$ 和 $B$ 在到达点 $j$ 的值由其在出发点 $s^{(n)}_j$ 的值确定。由于 $s^{(n)}_j$ 通常不是整数，我们必须对时间 $n$ 的网格数据进行插值。我们将平流后的中间值表示为 $A^{*,(n+1)}_j$ 和 $B^{*,(n+1)}_j$。\n\n对于落在网格点之间的任何 $s^{(n)}_j$，使用线性插值。令 $j' = \\lfloor s^{(n)}_j \\rfloor$ 为向下取整的整数索引，$w = s^{(n)}_j - j'$ 为小数部分。场 $F^{(n)}$ 的插值 $F(s^{(n)}_j)$ 为：\n$$\nF(s^{(n)}_j) = (1-w) F^{(n)}_{j'} + w F^{(n)}_{j'+1}\n$$\n此格式应用于 $A^{(n)}$ 和 $B^{(n)}$。\n\n至关重要的是，边界条件在平流步骤本身上被强制执行，以模拟区域边缘的物理行为：\n-   **壁面边界 ($j=0$):** 如果粒子的轨迹源于壁面或壁面之后 ($s^{(n)}_j \\le 0$)，其对湍流统计的贡献为零。这反映了在无滑移边界处湍流涡的阻尼。因此，我们强制执行：\n    $$\n    A^{*,(n+1)}_j = 0, \\quad B^{*,(n+1)}_j = 0 \\quad \\text{if } s^{(n)}_j \\le 0\n    $$\n-   **远场边界 ($j=N_y-1$):** 如果粒子源于最后一个网格点之外 ($s^{(n)}_j \\ge N_y - 1$)，我们通过将值钳制到最后一个可用点的值来使用零梯度类型的条件：\n    $$\n    A^{*,(n+1)}_j = A^{(n)}_{N_y-1}, \\quad B^{*,(n+1)}_j = B^{(n)}_{N_y-1} \\quad \\text{if } s^{(n)}_j \\ge N_y - 1\n    $$\n\n**2.2. 指数松弛**\n\n平流之后，使用瞬时分子场 $N^{(n)}_j$ 和分母场 $D^{(n)}_j$ 更新中间值 $A^{*,(n+1)}_j$ 和 $B^{*,(n+1)}_j$。这是一个指数松弛（或移动平均）步骤，是对控制常微分方程的一阶精确离散化：\n$$\n\\frac{\\mathrm{d}A}{\\mathrm{d}t} \\approx \\frac{A^{(n+1)}_j - A^{*,(n+1)}_j}{\\Delta t} = \\frac{N^{(n)}_j - A^{*,(n+1)}_j}{T}\n$$\n重新整理得到更新公式：\n$$\nA^{(n+1)}_j = A^{*,(n+1)}_j + \\frac{\\Delta t}{T}\\left(N^{(n)}_j - A^{*,(n+1)}_j\\right) = \\left(1 - \\frac{\\Delta t}{T}\\right)A^{*,(n+1)}_j + \\frac{\\Delta t}{T} N^{(n)}_j\n$$\n对于 $B$ 也是类似的：\n$$\nB^{(n+1)}_j = B^{*,(n+1)}_j + \\frac{\\Delta t}{T}\\left(D^{(n)}_j - B^{*,(n+1)}_j\\right) = \\left(1 - \\frac{\\Delta t}{T}\\right)B^{*,(n+1)}_j + \\frac{\\Delta t}{T} D^{(n)}_j\n$$\n使用给定的参数，松弛因子为 $\\alpha = \\Delta t/T = 0.002/0.02 = 0.1$。\n\n**2.3. 壁面边界条件强制**\n\n为确保严格维持壁面的属性，在每个时间步结束时，将壁面点 $j=0$ 处的 $A$ 和 $B$ 的值重置为零：\n$$\nA^{(n+1)}_0 = 0, \\quad B^{(n+1)}_0 = 0\n$$\n此操作保证了无论松弛和平流步骤如何，无阻尼系数在壁面处都将为零。\n\n**3. 最终系数计算**\n\n完成 $N_t=4$ 个时间步后，可得到最终的平均场 $A^{(N_t)}_j$ 和 $B^{(N_t)}_j$。\n\n首先，计算无阻尼系数，我们将其表示为 $q_j$。一个小的正则化参数 $\\varepsilon > 0$ 被加到分母上，以防止除以零，这种情况在流场是层流或解析度差时可能会局部发生。\n$$\nq_j = \\frac{A^{(N_t)}_j}{B^{(N_t)}_j + \\varepsilon}\n$$\n其次，应用近壁阻尼函数 $f_d$ 来模拟粘性子层中涡粘性的抑制。指定的函数是 Van Driest 型阻尼模型，它取决于无量纲壁面距离 $y^+$：\n$$\nf_d(y^+_j) = 1 - \\exp\\left(-\\frac{y^+_j}{A^+}\\right)\n$$\n这里，$A^+=26$ 是一个常数。该函数正确地满足 $f_d(0)=0$ 且对于大的 $y^+$，$f_d(y^+) \\to 1$。\n\n最终的动态 Smagorinsky 系数 $C_j$ 是无阻尼系数和阻尼函数的乘积：\n$$\nC_j = f_d(y^+_j) \\, q_j\n$$\n条件 $C_0=0$ 得到保证，因为 $f_d(y^+_0) = f_d(0) = 0$ 且 $q_0 = A^{(N_t)}_0 / (B^{(N_t)}_0 + \\varepsilon) = 0 / (0 + \\varepsilon) = 0$。\n\n这样就完成了用于计算一组输入数据系数的算法规范。然后对所提供的所有三个测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the discrete semi-Lagrangian dynamic Smagorinsky procedure for three test cases.\n    \"\"\"\n    \n    # --- Givens and Constants ---\n    Ny = 5\n    Nt = 4\n    dy = 0.005\n    dt = 0.002\n    T = 0.02\n    eps = 1e-9\n    A_plus = 26.0\n    y_plus = np.array([0.0, 10.0, 25.0, 50.0, 100.0])\n\n    # --- Test Cases Data ---\n    test_cases = [\n        # Test Case 1\n        {\n            \"v\": np.array([\n                [0.0, 0.02, 0.03, 0.04, 0.05],\n                [0.0, 0.02, 0.03, 0.04, 0.05],\n                [0.0, 0.02, 0.03, 0.04, 0.05],\n                [0.0, 0.02, 0.03, 0.04, 0.05],\n            ]),\n            \"N\": np.array([\n                [0.0, 0.02, 0.05, 0.08, 0.10],\n                [0.0, 0.025, 0.055, 0.085, 0.105],\n                [0.0, 0.03, 0.06, 0.09, 0.11],\n                [0.0, 0.035, 0.065, 0.095, 0.115],\n            ]),\n            \"D\": np.array([\n                [0.0, 0.50, 0.60, 0.70, 0.80],\n                [0.0, 0.52, 0.62, 0.72, 0.82],\n                [0.0, 0.54, 0.64, 0.74, 0.84],\n                [0.0, 0.56, 0.66, 0.76, 0.86],\n            ]),\n        },\n        # Test Case 2\n        {\n            \"v\": np.array([\n                [0.0, 3.0, 0.0, 0.0, 0.0],\n                [0.0, 3.0, 0.0, 0.0, 0.0],\n                [0.0, 3.0, 0.0, 0.0, 0.0],\n                [0.0, 3.0, 0.0, 0.0, 0.0],\n            ]),\n            \"N\": np.array([\n                [0.0, -0.02, 0.02, 0.05, 0.07],\n                [0.0, -0.025, 0.025, 0.055, 0.075],\n                [0.0, -0.03, 0.03, 0.06, 0.08],\n                [0.0, -0.035, 0.035, 0.065, 0.085],\n            ]),\n            \"D\": np.array([\n                [0.0, 0.50, 0.60, 0.70, 0.80],\n                [0.0, 0.52, 0.62, 0.72, 0.82],\n                [0.0, 0.54, 0.64, 0.74, 0.84],\n                [0.0, 0.56, 0.66, 0.76, 0.86],\n            ]),\n        },\n        # Test Case 3\n        {\n            \"v\": np.array([\n                [0.0, 0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0, 0.0, 0.0],\n            ]),\n            \"N\": np.array([\n                [0.0, 0.01, 0.02, 0.03, 0.04],\n                [0.0, 0.01, 0.02, 0.03, 0.04],\n                [0.0, 0.01, 0.02, 0.03, 0.04],\n                [0.0, 0.01, 0.02, 0.03, 0.04],\n            ]),\n            \"D\": np.array([\n                [0.0, 0.0, 0.0, 0.10, 0.20],\n                [0.0, 0.0, 0.0, 0.10, 0.20],\n                [0.0, 0.0, 0.0, 0.10, 0.20],\n                [0.0, 0.0, 0.0, 0.10, 0.20],\n            ]),\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        v_all_n = case[\"v\"]\n        N_all_n = case[\"N\"]\n        D_all_n = case[\"D\"]\n\n        # 1. Initialization\n        A = np.zeros(Ny, dtype=float)\n        B = np.zeros(Ny, dtype=float)\n\n        # 2. Time-Stepping Loop\n        for n in range(Nt):\n            # Current time-step data\n            v_n = v_all_n[n]\n            N_n = N_all_n[n]\n            D_n = D_all_n[n]\n\n            # 2.1. Semi-Lagrangian Advection\n            A_star = np.zeros(Ny, dtype=float)\n            B_star = np.zeros(Ny, dtype=float)\n            \n            s = np.arange(Ny, dtype=float) - v_n * dt / dy\n            \n            for j in range(Ny):\n                s_j = s[j]\n                \n                # Advection boundary conditions\n                if s_j <= 0:\n                    A_star[j] = 0.0\n                    B_star[j] = 0.0\n                elif s_j >= Ny - 1:\n                    A_star[j] = A[Ny - 1]\n                    B_star[j] = B[Ny - 1]\n                else:\n                    # Linear interpolation\n                    j_floor = int(s_j)\n                    weight = s_j - j_floor\n                    A_star[j] = (1.0 - weight) * A[j_floor] + weight * A[j_floor + 1]\n                    B_star[j] = (1.0 - weight) * B[j_floor] + weight * B[j_floor + 1]\n\n            # 2.2. Exponential Relaxation\n            relax_factor = dt / T\n            A_next = A_star + relax_factor * (N_n - A_star)\n            B_next = B_star + relax_factor * (D_n - B_star)\n\n            # 2.3. Wall Boundary Condition Enforcement\n            A_next[0] = 0.0\n            B_next[0] = 0.0\n\n            # Update state for next iteration\n            A = A_next\n            B = B_next\n\n        # 3. Final Coefficient Calculation\n        q = A / (B + eps)\n        f_d = 1.0 - np.exp(-y_plus / A_plus)\n        C = f_d * q\n        C[0] = 0.0  # Enforce exact zero at wall\n\n        all_results.append(C.tolist())\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3373054"}]}