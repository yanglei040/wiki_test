{"hands_on_practices": [{"introduction": "在将数值方法应用于复杂的流体动力学模拟之前，验证其能否准确再现基本的几何属性至关重要。本练习 [@problem_id:3305511] 采用一个简单的圆形界面——即“斑块测试”(patch test)——来评估界面法向量和曲率计算的准确性。通过这项实践，您将不仅能够量化数值误差，还将深刻理解为何保持水平集函数的符号距离属性（即Eikonal条件 $|\\nabla \\phi| = 1$）对于获得精确的几何信息至关重要。", "problem": "为耦合水平集与流体体积 (Coupled Level-Set and Volume-of-Fluid, CLSVOF) 方法设计并实现一个数值界面法向补丁测试。从第一性原理和核心定义出发，避免使用任何预打包的界面重构捷径。您将为一个已知几何形状指定精确场，然后计算数值界面法向和曲率。您将验证网格加密下的收敛阶，并识别当平流后违反 Eikonal 条件时引入的偏差。所有计算均在二维空间中进行且无量纲。\n\n基本原理：\n- 水平集 (Level-Set, LS) 函数是一个标量场 $\\phi(\\mathbf{x})$，其零等值线表示界面。对于有符号距离水平集，$|\\nabla \\phi| = 1$。\n- 流体体积 (Volume-of-Fluid, VOF) 颜色函数是一个标量场 $C(\\mathbf{x}) \\in [0,1]$，表示相指示函数。我们使用从 $\\phi$ 到 $C$ 的正则化 Heaviside 映射，以获得离散体积分数的光滑代理：对于平滑半宽 $\\varepsilon > 0$，\n$$\nH_\\varepsilon(\\phi) =\n\\begin{cases}\n0,  \\phi \\le -\\varepsilon, \\\\\n\\frac{1}{2} + \\frac{\\phi}{2\\varepsilon} + \\frac{1}{2\\pi}\\sin\\!\\left(\\pi \\frac{\\phi}{\\varepsilon}\\right),  |\\phi|  \\varepsilon, \\\\\n1,  \\phi \\ge \\varepsilon.\n\\end{cases}\n$$\n然后定义 $C = H_\\varepsilon(\\phi)$。\n- 从标量场 $f$ 计算的单位法向为 $\\mathbf{n}_f = \\nabla f / \\|\\nabla f\\|$，其中 $\\|\\cdot\\|$ 表示欧几里得范数。\n- 曲率定义为 $\\kappa = \\nabla \\cdot \\left( \\nabla \\phi / \\|\\nabla \\phi\\| \\right)$。对于半径为 $R$、法向朝外的圆，其精确曲率为 $\\kappa_{\\text{exact}} = 1/R$。\n\n几何与精确场：\n- 考虑在均匀笛卡尔网格上离散化的单位正方形域 $[0,1] \\times [0,1]$，其 $N \\times N$ 个单元中心的坐标为 $x_i = (i + \\tfrac{1}{2}) \\Delta x$，$y_j = (j + \\tfrac{1}{2}) \\Delta x$，其中 $\\Delta x = 1/N$ 且 $i,j \\in \\{0,1,\\dots,N-1\\}$。\n- 设精确几何形状为一个以 $(x_0,y_0) = (0.5,0.5)$ 为中心、半径为 $R = 0.3$ 的圆。精确有符号距离水平集为\n$$\n\\phi_{\\text{sd}}(x,y) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R.\n$$\n- 通过保持零等值线不变的光滑重新参数化来定义一个平流后的（非 Eikonal）水平集：\n$$\n\\phi_{\\text{adv}}(x,y) = \\phi_{\\text{sd}}(x,y)\\bigl(1 + \\beta x\\bigr) + \\gamma \\, \\phi_{\\text{sd}}(x,y)^2,\n$$\n其中 $\\beta = 0.5$ 且 $\\gamma = 0.25 \\beta$。这在同一个圆上满足 $\\phi_{\\text{adv}} = 0$，但通常 $|\\nabla \\phi_{\\text{adv}}| \\ne 1$。\n- 定义正则化半宽为 $\\varepsilon = \\alpha \\Delta x$，其中 $\\alpha = 1.5$，并对于选定的 $\\phi$，设置 $C = H_\\varepsilon(\\phi)$。\n\n离散化：\n- 使用二阶中心有限差分在均匀网格上近似空间梯度和散度。对于在单元中心采样的任何足够光滑的标量场 $f$，用各方向上的中心差分来近似 $\\nabla f$。类似地，对于一个矢量场 $\\mathbf{g}$，通过分量上应用中心差分来近似 $\\nabla \\cdot \\mathbf{g}$。\n- 分别从 $\\phi$ 计算基于 LS 的单位法向 $\\mathbf{n}_\\phi$ 和从平滑后的 $C$ 计算基于 VOF 的单位法向 $\\mathbf{n}_C$，两种情况都通过归一化数值计算的梯度来得到。\n- 计算基于 LS 的曲率 $\\kappa_\\phi = \\nabla \\cdot \\mathbf{n}_\\phi$。\n\n误差度量与界面带：\n- 定义圆的精确单位法向为\n$$\n\\mathbf{n}_{\\text{exact}}(x,y) = \\frac{1}{\\sqrt{(x-x_0)^2 + (y-y_0)^2}}\\begin{bmatrix} x-x_0 \\\\ y-y_0 \\end{bmatrix},\n$$\n在网格点上进行评估，精确曲率为 $\\kappa_{\\text{exact}} = 1/R$。\n- 使用精确有符号距离场定义一个界面带（窄带）：包含满足 $|\\phi_{\\text{sd}}(x,y)| \\le 2\\varepsilon$ 的网格点。所有误差范数仅在此带上计算。\n- 对于向量误差 $\\mathbf{e} = \\mathbf{a} - \\mathbf{b}$，使用逐点大小 $\\|\\mathbf{e}\\|$。对于标量误差 $e = a - b$，使用绝对值 $|e|$。定义带上的离散 $L^2$ 误差为带上逐点误差平方的算术平均值的平方根。\n\n任务：\n- 对于每个分辨率 $N \\in \\{32, 64, 128\\}$，针对 $\\phi_{\\text{sd}}$ 和 $\\phi_{\\text{adv}}$ 两种场，计算带上的以下三个 $L^2$ 误差：\n  1. LS 法向误差 $E_{n,\\phi}(N)$，即 $\\mathbf{n}_\\phi$ 与 $\\mathbf{n}_{\\text{exact}}$ 之间的误差。\n  2. VOF 法向误差 $E_{n,C}(N)$，即 $\\mathbf{n}_C$ 与 $\\mathbf{n}_{\\text{exact}}$ 之间的误差。\n  3. LS 曲率误差 $E_{\\kappa,\\phi}(N)$，即 $\\kappa_\\phi$ 与 $\\kappa_{\\text{exact}}$ 之间的误差。\n- 对每个量，使用标准定义计算连续加密过程之间的观测收敛阶：\n$$\np = \\frac{\\log\\!\\bigl(E(N_1)/E(N_2)\\bigr)}{\\log\\!\\bigl(\\Delta x_{N_1}/\\Delta x_{N_2}\\bigr)} = \\frac{\\log\\!\\bigl(E(N_1)/E(N_2)\\bigr)}{\\log\\!\\bigl(N_2/N_1\\bigr)}.\n$$\n具体计算对 $(N_1,N_2) \\in \\{(32,64), (64,128)\\}$ 的收敛阶。\n- 在最精细的网格 $N = 128$ 上，通过计算梯度模长与 1 的带内平均偏差来量化 Eikonal 偏差，即\n$$\nB(\\phi) = \\text{在带上求平均}\\bigl(|\\,\\|\\nabla \\phi\\| - 1\\,|\\bigr),\n$$\n对 $\\phi_{\\text{sd}}$ 和 $\\phi_{\\text{adv}}$ 都进行计算。\n\n测试套件：\n- 几何参数：$(x_0,y_0) = (0.5,0.5)$，$R = 0.3$。\n- 正则化：$\\alpha = 1.5$，因此 $\\varepsilon = \\alpha \\Delta x$。\n- 平流参数：$\\beta = 0.5$，$\\gamma = 0.25 \\beta$。\n- 分辨率：$N \\in \\{32, 64, 128\\}$。\n\n所需输出：\n- 按以下顺序列出，计算并报告以下 $14$ 个浮点数值：\n  1. 对于 $\\phi_{\\text{sd}}$：LS 法向误差的两个观测收敛阶 $(p_{n,\\phi}^{32\\to64}, p_{n,\\phi}^{64\\to128})$。\n  2. 对于 $\\phi_{\\text{sd}}$：VOF 法向误差的两个观测收敛阶 $(p_{n,C}^{32\\to64}, p_{n,C}^{64\\to128})$。\n  3. 对于 $\\phi_{\\text{sd}}$：LS 曲率误差的两个观测收敛阶 $(p_{\\kappa,\\phi}^{32\\to64}, p_{\\kappa,\\phi}^{64\\to128})$。\n  4. 对于 $\\phi_{\\text{adv}}$：LS 法向误差的两个观测收敛阶 $(\\tilde{p}_{n,\\phi}^{32\\to64}, \\tilde{p}_{n,\\phi}^{64\\to128})$。\n  5. 对于 $\\phi_{\\text{adv}}$：VOF 法向误差的两个观测收敛阶 $(\\tilde{p}_{n,C}^{32\\to64}, \\tilde{p}_{n,C}^{64\\to128})$。\n  6. 对于 $\\phi_{\\text{adv}}$：LS 曲率误差的两个观测收敛阶 $(\\tilde{p}_{\\kappa,\\phi}^{32\\to64}, \\tilde{p}_{\\kappa,\\phi}^{64\\to128})$。\n  7. 在 $N = 128$ 时的两个偏差度量：$B(\\phi_{\\text{sd}})$ 和 $B(\\phi_{\\text{adv}})$。\n- 最终输出格式：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔结果列表（例如，“[r1,r2,r3,...]”）。不要包含空格。所有报告的值都是无量纲实数。\n\n约束与现实性：\n- 将所有有限差分操作限制在均匀网格上，并且只使用中心差分所隐含的数值微分；在计算法向或曲率时，不要调用 $\\phi$ 或 $C$ 的任何解析导数。\n- 实现必须是自包含的，不需要用户输入，并且只使用指定的计算库。", "solution": "用户提供了一个用于计算流体力学中数值补丁测试的适定 (well-posed) 问题陈述。该问题具有科学依据、自包含，并要求进行一系列与耦合水平集与流体体积 (CLSVOF) 方法相关的特定计算和误差分析。所有定义、参数和所需输出都已明确指定。因此，该问题被认为是有效的，下面提供了完整的解决方案。\n\n该问题要求实现并分析一个数值补丁测试，以评估从水平集 (LS) 和流体体积 (VOF) 标量场派生的界面法向和曲率计算的准确性。分析是在一个静态的圆形界面上进行的，该界面的精确解析解是已知的。这使得可以精确量化数值误差，并研究在网格加密下的收敛率。研究的一个关键方面是比较从满足 Eikonal 条件 $|\\nabla \\phi| = 1$ 的有符号距离水平集函数获得的结果与从非 Eikonal 场获得的结果，后者代表了被数值平流扭曲的水平集函数。\n\n解决方案的基本步骤如下：\n1.  对每个网格分辨率，离散化计算域并在单元中心评估解析的 LS 和 VOF 场。\n2.  使用二阶中心有限差分数值计算 LS 和 VOF 场的梯度。\n3.  通过归一化计算出的梯度来计算界面法向矢量。\n4.  通过对基于 LS 的法向矢量场求散度来计算界面曲率。\n5.  通过在界面周围指定的窄带内将数值法向和曲率与精确解析值进行比较，计算它们的 $L^2$ 误差。\n6.  根据三个连续网格分辨率下的误差，确定每个计算量的观测收敛阶。\n7.  对于有符号距离和扭曲的 LS 场，量化 Eikonal 偏差，即 LS 梯度模长与 1 的偏差。\n\n让我们将数值过程形式化。计算域是单位正方形 $[0,1] \\times [0,1]$，它被离散化为一个 $N \\times N$ 的网格。单元中心位于 $(x_i, y_j) = ((i + 0.5)\\Delta x, (j + 0.5)\\Delta x)$，其中 $i,j \\in \\{0, \\dots, N-1\\}$，网格间距为 $\\Delta x = 1/N$。\n\n对于定义在网格上的标量场 $f$，其梯度 $\\nabla f = (\\partial_x f, \\partial_y f)$ 使用二阶中心差分进行近似。如果 $f_{i,j}$ 表示在网格节点 $(i,j)$ 上的 $f$ 值，则梯度的分量近似为：\n$$\n(\\partial_x f)_{i,j} \\approx \\frac{f_{i+1,j} - f_{i-1,j}}{2\\Delta x}, \\quad\n(\\partial_y f)_{i,j} \\approx \\frac{f_{i,j+1} - f_{i,j-1}}{2\\Delta x}\n$$\n对于一个矢量场 $\\mathbf{g} = (g_x, g_y)$，其散度 $\\nabla \\cdot \\mathbf{g}$ 也类似地近似：\n$$\n(\\nabla \\cdot \\mathbf{g})_{i,j} \\approx \\frac{(g_x)_{i+1,j} - (g_x)_{i-1,j}}{2\\Delta x} + \\frac{(g_y)_{i,j+1} - (g_y)_{i,j-1}}{2\\Delta y}\n$$\n这些中心差分格式用于内部网格点，而边界上通常使用一阶格式。\n\n从场 $f$（无论是 $\\phi$ 还是 $C$）得到的数值单位法向矢量 $\\mathbf{n}_f$ 的计算方法是：首先近似 $\\nabla f$，然后在每个网格点上对结果进行归一化：\n$$\n\\mathbf{n}_f = \\frac{\\nabla_{\\text{num}} f}{\\lVert \\nabla_{\\text{num}} f \\rVert_2}\n$$\n其中 $\\nabla_{\\text{num}}$ 表示有限差分梯度算子，$\\lVert \\cdot \\rVert_2$ 是欧几里得范数。\n\n基于 LS 的曲率 $\\kappa_\\phi$ 被计算为数值 LS 单位法向场 $\\mathbf{n}_\\phi$ 的数值散度：\n$$\n\\kappa_\\phi = \\nabla_{\\text{num}} \\cdot \\mathbf{n}_\\phi\n$$\n\nVOF 场 $C$ 是通过正则化的 Heaviside 函数 $H_\\varepsilon(\\phi)$ 从给定的水平集场 $\\phi$ 派生出来的，其中平滑宽度 $\\varepsilon = \\alpha \\Delta x = 1.5 \\Delta x$ 与网格间距成正比。这种构造提供了 $C$ 在界面上从 $0$ 到 $1$ 的光滑过渡，这对于计算一个有意义的梯度 $\\nabla C$ 是必要的。\n\n分析区分了两个水平集场：\n1.  精确的有符号距离函数 $\\phi_{\\text{sd}}(x,y) = \\sqrt{(x-x_0)^2 + (y-y_0)^2} - R$，它处处满足 $|\\nabla \\phi_{\\text{sd}}| = 1$。\n2.  “平流后的”非 Eikonal 函数 $\\phi_{\\text{adv}}(x,y) = \\phi_{\\text{sd}}(x,y)(1 + \\beta x) + \\gamma \\phi_{\\text{sd}}(x,y)^2$。该函数与 $\\phi_{\\text{sd}}$ 共享相同的零等值线，但违反了 Eikonal 条件，即通常情况下 $|\\nabla \\phi_{\\text{adv}}| \\neq 1$。这模拟了有符号距离场在流场中平流后未经重新初始化步骤而发生的扭曲。\n\n误差在离散 $L^2$ 范数中计算，定义为位于界面带 $\\{ (x,y) \\mid |\\phi_{\\text{sd}}(x,y)| \\le 2\\varepsilon \\}$ 内的网格点上逐点误差平方的均值的平方根。例如，LS 法向误差为：\n$$\nE_{n,\\phi}(N) = \\sqrt{ \\frac{1}{N_{\\text{band}}} \\sum_{(i,j) \\in \\text{band}} \\lVert \\mathbf{n}_\\phi(x_i, y_j) - \\mathbf{n}_{\\text{exact}}(x_i, y_j) \\rVert_2^2 }\n$$\n其中 $N_{\\text{band}}$ 是带内的网格点数。\n\n两个分辨率 $N_1$ 和 $N_2$ 之间的观测收敛阶 $p$ 计算如下：\n$$\np = \\frac{\\log(E(N_1)/E(N_2))}{\\log(N_2/N_1)}\n$$\n对于使用二阶精度格式计算的量，期望得到 $p \\approx 2$ 的值。然而，对于像从 $\\phi_{\\text{adv}}$ 计算的曲率这样的量，理论定义 $\\kappa = \\nabla \\cdot (\\nabla \\phi/|\\nabla \\phi|)$ 仅对有符号距离场有效。当 $|\\nabla \\phi| \\neq 1$ 时，此公式引入了一个不随网格加密而减小的模型误差，导致零阶收敛 ($p \\approx 0$)。\n\n最后，Eikonal 偏差 $B(\\phi)$ 是数值梯度模长与 1 的带内平均偏差。这个度量直接量化了未能满足有符号距离属性的程度，这是曲率计算不准确性的主要原因。\n\n我们继续进行实现，该实现将系统地为分辨率 $N \\in \\{32, 64, 128\\}$ 计算这些量，并按要求报告收敛阶和偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef H_eps(phi, eps):\n    \"\"\"\n    Computes the regularized Heaviside function H_epsilon(phi).\n    \"\"\"\n    C = np.zeros_like(phi)\n    \n    # Case 1: phi = -eps\n    # C is already 0.\n    \n    # Case 2: phi = eps\n    C[phi = eps] = 1.0\n    \n    # Case 3: |phi|  eps\n    mid_mask = np.abs(phi)  eps\n    phi_mid = phi[mid_mask]\n    \n    C[mid_mask] = 0.5 + phi_mid / (2 * eps) + (1.0 / (2.0 * np.pi)) * np.sin(np.pi * phi_mid / eps)\n    \n    return C\n\ndef get_order(err1, err2, N1, N2):\n    \"\"\"\n    Computes the convergence order p.\n    Handles potential division by zero if errors are extremely small.\n    \"\"\"\n    if err1 = 0.0 or err2 = 0.0:\n        return 0.0\n    return np.log(err1 / err2) / np.log(N2 / N1)\n\ndef analyze_field(phi, phi_sd_for_band, N, dx, grid_x, grid_y, x0, y0, alpha, kappa_exact):\n    \"\"\"\n    Performs the analysis for a given level-set field: calculates normals,\n    curvature, and errors.\n    \"\"\"\n    eps = alpha * dx\n    band_mask = np.abs(phi_sd_for_band) = 2 * eps\n    \n    # Avoid division by zero if the band is empty, though unlikely.\n    if not np.any(band_mask):\n        return 0.0, 0.0, 0.0, 0.0\n\n    # Exact normals on the grid for error calculation\n    r_dist = np.sqrt((grid_x - x0)**2 + (grid_y - y0)**2)\n    # Avoid division by zero at the circle center\n    safe_r = np.where(r_dist == 0, 1.0, r_dist)\n    n_exact_x = (grid_x - x0) / safe_r\n    n_exact_y = (grid_y - y0) / safe_r\n    \n    safety_factor = 1e-15\n\n    # VOF field from the given LS field\n    C = H_eps(phi, eps)\n    \n    # --- LS-based calculations ---\n    # Gradient of phi. np.gradient returns (dy, dx) for a (y, x) indexed grid.\n    grad_phi_y, grad_phi_x = np.gradient(phi, dx)\n    \n    # Normals from phi\n    norm_grad_phi = np.sqrt(grad_phi_x**2 + grad_phi_y**2)\n    n_phi_x = grad_phi_x / (norm_grad_phi + safety_factor)\n    n_phi_y = grad_phi_y / (norm_grad_phi + safety_factor)\n    \n    # Curvature from phi\n    # div(n) = d(nx)/dx + d(ny)/dy\n    grad_nx_y, grad_nx_x = np.gradient(n_phi_x, dx)\n    grad_ny_y, grad_ny_x = np.gradient(n_phi_y, dx)\n    kappa_phi = grad_nx_x + grad_ny_y\n    \n    # --- VOF-based calculations ---\n    # Gradient and normals from C\n    grad_C_y, grad_C_x = np.gradient(C, dx)\n    norm_grad_C = np.sqrt(grad_C_x**2 + grad_C_y**2)\n    n_C_x = grad_C_x / (norm_grad_C + safety_factor)\n    n_C_y = grad_C_y / (norm_grad_C + safety_factor)\n    \n    # --- Error Calculations ---\n    # L2 error of LS-normal\n    err_n_phi = np.sqrt(np.mean(((n_phi_x - n_exact_x)**2 + (n_phi_y - n_exact_y)**2)[band_mask]))\n    \n    # L2 error of VOF-normal\n    err_n_C = np.sqrt(np.mean(((n_C_x - n_exact_x)**2 + (n_C_y - n_exact_y)**2)[band_mask]))\n    \n    # L2 error of LS-curvature\n    err_k_phi = np.sqrt(np.mean(((kappa_phi - kappa_exact)**2)[band_mask]))\n    \n    # --- Eikonal Bias Calculation ---\n    # Bias is mean(| |grad(phi)| - 1 |) over the band\n    bias = np.mean(np.abs(norm_grad_phi - 1.0)[band_mask])\n    \n    return err_n_phi, err_n_C, err_k_phi, bias\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = {\n        'params': {\n            'x0': 0.5, 'y0': 0.5, 'R': 0.3,\n            'alpha': 1.5, 'beta': 0.5,\n        },\n        'resolutions': [32, 64, 128]\n    }\n    \n    params = test_cases['params']\n    resolutions = test_cases['resolutions']\n    \n    # Derived parameters\n    params['gamma'] = 0.25 * params['beta']\n    params['kappa_exact'] = 1.0 / params['R']\n\n    errors_sd = {'n_phi': [], 'n_C': [], 'k_phi': []}\n    errors_adv = {'n_phi': [], 'n_C': [], 'k_phi': []}\n    \n    bias_sd_128, bias_adv_128 = 0.0, 0.0\n\n    for N in resolutions:\n        dx = 1.0 / N\n        grid_pts = np.linspace(0.5 * dx, 1.0 - 0.5 * dx, N)\n        # grid_x varies along axis 1, grid_y along axis 0\n        grid_x, grid_y = np.meshgrid(grid_pts, grid_pts)\n\n        # Define analytical fields on the grid\n        phi_sd = np.sqrt((grid_x - params['x0'])**2 + (grid_y - params['y0'])**2) - params['R']\n        phi_adv = phi_sd * (1 + params['beta'] * grid_x) + params['gamma'] * phi_sd**2\n\n        # --- Analyze phi_sd ---\n        err_n_phi_sd, err_n_C_sd, err_k_phi_sd, bias_sd = analyze_field(\n            phi_sd, phi_sd, N, dx, grid_x, grid_y, \n            params['x0'], params['y0'], params['alpha'], params['kappa_exact']\n        )\n        errors_sd['n_phi'].append(err_n_phi_sd)\n        errors_sd['n_C'].append(err_n_C_sd)\n        errors_sd['k_phi'].append(err_k_phi_sd)\n\n        # --- Analyze phi_adv ---\n        err_n_phi_adv, err_n_C_adv, err_k_phi_adv, bias_adv = analyze_field(\n            phi_adv, phi_sd, N, dx, grid_x, grid_y, \n            params['x0'], params['y0'], params['alpha'], params['kappa_exact']\n        )\n        errors_adv['n_phi'].append(err_n_phi_adv)\n        errors_adv['n_C'].append(err_n_C_adv)\n        errors_adv['k_phi'].append(err_k_phi_adv)\n\n        # Store bias values for the finest grid\n        if N == 128:\n            bias_sd_128 = bias_sd\n            bias_adv_128 = bias_adv\n\n    # Post-process to calculate convergence orders\n    results = []\n    \n    # 1. phi_sd: LS-normal orders\n    results.append(get_order(errors_sd['n_phi'][0], errors_sd['n_phi'][1], 32, 64))\n    results.append(get_order(errors_sd['n_phi'][1], errors_sd['n_phi'][2], 64, 128))\n\n    # 2. phi_sd: VOF-normal orders\n    results.append(get_order(errors_sd['n_C'][0], errors_sd['n_C'][1], 32, 64))\n    results.append(get_order(errors_sd['n_C'][1], errors_sd['n_C'][2], 64, 128))\n    \n    # 3. phi_sd: LS-curvature orders\n    results.append(get_order(errors_sd['k_phi'][0], errors_sd['k_phi'][1], 32, 64))\n    results.append(get_order(errors_sd['k_phi'][1], errors_sd['k_phi'][2], 64, 128))\n\n    # 4. phi_adv: LS-normal orders\n    results.append(get_order(errors_adv['n_phi'][0], errors_adv['n_phi'][1], 32, 64))\n    results.append(get_order(errors_adv['n_phi'][1], errors_adv['n_phi'][2], 64, 128))\n\n    # 5. phi_adv: VOF-normal orders\n    results.append(get_order(errors_adv['n_C'][0], errors_adv['n_C'][1], 32, 64))\n    results.append(get_order(errors_adv['n_C'][1], errors_adv['n_C'][2], 64, 128))\n\n    # 6. phi_adv: LS-curvature orders\n    results.append(get_order(errors_adv['k_phi'][0], errors_adv['k_phi'][1], 32, 64))\n    results.append(get_order(errors_adv['k_phi'][1], errors_adv['k_phi'][2], 64, 128))\n\n    # 7. Bias metrics at N = 128\n    results.append(bias_sd_128)\n    results.append(bias_adv_128)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3305511"}, {"introduction": "精确的曲率计算对于模拟表面张力至关重要，而表面张力在许多多相流问题中是主导作用力。本实践 [@problem_id:3305550] 将探讨并比较两种截然不同的曲率估算方法：一种直接从水平集场（level-set field）推导，另一种则通过由流体体积分数场（volume-of-fluid field）重构的高度函数（height function）计算。通过实现这两种方法并进行收敛性研究，您将能够亲手评估它们的准确性与数值特性，这对于在实际应用中做出明智的方法选择至关重要。", "problem": "您需要实现并比较两种用于在笛卡尔网格上表示的光滑二维界面的数值曲率估计器：一种是基于流体体积分数（volume-of-fluid）逐列积分的高度函数曲率，另一种是基于标量场归一化梯度散度的水平集曲率。该界面在一个周期性域上被规定为一个受扰动的正弦函数图形，所有角度都以弧度处理。不涉及物理单位；所有量均为无量纲。\n\n初始定义与定律：\n- 界面是由 $y=\\eta(x)$ 给出的图形，定义在区间 $x\\in[0,L]$ 上，且 $y\\in[0,H]$。假设 $L>0$ 和 $H>0$ 且在 $x$ 方向具有周期性。\n- 流体体积分数（Volume-of-Fluid, VOF）$F(x,y)$ 定义为在一个控制体积上平均的相占据指示函数：具体来说，如果单元体积完全在界面下方，则 $F=1$；如果完全在上方，则 $F=0$；中间值则与界面下方单元的面积成比例。\n- 与 $F$ 的逐列积分相关的高度函数 $h(x)$ 是界面下方流体高度的列平均值，通过对每列中所有行的离散求和来定义，$h_i=\\sum_j F_{i,j}\\,\\Delta y$，其中 $\\Delta y$ 是 $y$方向的均匀网格间距，$F_{i,j}$ 是单元 $(i,j)$ 中的 VOF 分数。\n- 图形 $y=\\eta(x)$ 的几何曲率由公式 $\\kappa(x)=-\\eta''(x)\\,\\big(1+(\\eta'(x))^2\\big)^{-3/2}$ 给出，该公式源自平面曲线的 Frenet–Serret 标架。\n- 水平集场 $\\phi(x,y)$ 可以定义为 $\\phi(x,y)=y-\\eta(x)$，由此可得到单位法向量 $\\mathbf{n}=\\nabla\\phi/|\\nabla\\phi|$ 和曲率 $\\kappa_\\phi=\\nabla\\cdot\\mathbf{n}$。\n\n您的程序必须：\n1. 在 $[0,L]\\times[0,H]$ 上构建一个包含 $N_x$ 列和 $N_y$ 行的二维均匀笛卡尔网格，并对所有使用的离散导数在 $x$ 方向上施加周期性边界条件。\n2. 定义一个受扰动的正弦界面高度\n   $$\\eta(x)=y_0+A\\sin(kx)+\\varepsilon\\sin(3kx),$$\n   其中 $k=2\\pi m/L$，$m\\in\\mathbb{Z}^+$，$A>0$，$\\varepsilon\\ge 0$，$y_0\\in(0,H)$ 是一个常数偏移量。正弦函数的参数以弧度为单位。\n3. 通过在每个单元的水平范围内对界面下方的指示函数进行积分，使用 $x$ 方向的 $4$ 点 Gauss–Legendre 求积法计算 VOF 分数 $F_{i,j}$。对于一个水平边界为 $[x_i-\\Delta x/2,x_i+\\Delta x/2]$、垂直边界为 $[y_j-\\Delta y/2,y_j+\\Delta y/2]$ 的单元，为每个求积点 $x_q$ 定义垂直占据分数 $L(x_q)$ 如下\n   - 如果 $\\eta(x_q)\\le y_j-\\Delta y/2$，则 $L(x_q)=0$，\n   - 如果 $\\eta(x_q)\\ge y_j+\\Delta y/2$，则 $L(x_q)=1$，\n   - 否则 $L(x_q)=\\big(\\eta(x_q)-(y_j-\\Delta y/2)\\big)/\\Delta y$。\n   然后使用求积法则，通过在单元宽度上平均 $L(x)$ 来近似 $F_{i,j}$，得到一个在 $[0,1]$ 区间内的值。\n4. 对每列 $i$ 组装高度函数 $h_i=\\sum_j F_{i,j}\\,\\Delta y$，并计算高度函数曲率\n   $$\\kappa_{HF,i}=-\\frac{h''_i}{\\big(1+(h'_i)^2\\big)^{3/2}},$$\n   其中，$h'_i$ 和 $h''_i$ 在 $x$ 方向上使用带周期性边界条件的离散中心差分。\n5. 定义水平集场 $\\phi_{i,j}=y_j-\\eta(x_i)$，其中 $x_i$ 和 $y_j$ 是单元中心坐标。通过以下步骤在网格上计算 $\\kappa_{\\phi}$：\n   - 计算离散中心差分 $\\phi_x$ 和 $\\phi_y$，\n   - 逐点构建 $\\mathbf{n}=\\nabla\\phi/|\\nabla\\phi|$，\n   - 并使用中心差分和 $x$ 方向的周期性边界条件计算离散散度 $\\kappa_\\phi=\\partial n_x/\\partial x+\\partial n_y/\\partial y$。\n   然后，对每列 $i$，通过在 $y$ 方向上对最接近 $y=\\eta(x_i)$ 的两行之间进行线性插值，来在界面高度处采样 $\\kappa_\\phi$，以获得界面值 $\\kappa_{\\phi,i}$。\n6. 使用以下公式计算每个列中心 $x_i$ 处的解析曲率 $\\kappa_{true,i}$\n   $$\\eta'(x)=Ak\\cos(kx)+3\\varepsilon k\\cos(3kx),\\quad \\eta''(x)=-Ak^2\\sin(kx)-9\\varepsilon k^2\\sin(3kx),$$\n   和\n   $$\\kappa_{true}(x)=-\\frac{\\eta''(x)}{\\big(1+(\\eta'(x))^2\\big)^{3/2}}.$$\n7. 对每种方法，计算所有列的均方根误差，\n   $$E_{HF}=\\sqrt{\\frac{1}{N_x}\\sum_{i=1}^{N_x}\\big(\\kappa_{HF,i}-\\kappa_{true,i}\\big)^2},\\quad E_{\\phi}=\\sqrt{\\frac{1}{N_x}\\sum_{i=1}^{N_x}\\big(\\kappa_{\\phi,i}-\\kappa_{true,i}\\big)^2}.$$\n8. 通过在两个网格上计算误差来进行收敛性研究：一个基础分辨率 $(N_x^{(0)},N_y^{(0)})$ 和一个加密分辨率 $(2N_x^{(0)},2N_y^{(0)})$。通过以下公式估计每种方法的观测精度阶数 $p$\n   $$p_{HF}=\\frac{\\log\\big(E_{HF}(N_x^{(0)})/E_{HF}(2N_x^{(0)})\\big)}{\\log(2)},\\quad p_{\\phi}=\\frac{\\log\\big(E_{\\phi}(N_x^{(0)})/E_{\\phi}(2N_x^{(0)})\\big)}{\\log(2)}.$$\n\n测试套件：\n使用以下三组参数集：\n- 测试 $1$：$(L,H,y_0,A,\\varepsilon,m,N_x^{(0)},N_y^{(0)})=(1,1,0.5,0.1,0.01,1,32,64)$。\n- 测试 $2$：$(L,H,y_0,A,\\varepsilon,m,N_x^{(0)},N_y^{(0)})=(1,1,0.5,0.02,0.0,1,24,48)$。\n- 测试 $3$：$(L,H,y_0,A,\\varepsilon,m,N_x^{(0)},N_y^{(0)})=(1,1,0.5,0.3,0.05,1,40,80)$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果。对于每个测试，按以下顺序输出六个浮点数：\n$[E_{HF}(N_x^{(0)}),E_{HF}(2N_x^{(0)}),p_{HF},E_{\\phi}(N_x^{(0)}),E_{\\phi}(2N_x^{(0)}),p_{\\phi}]$，\n并按顺序连接三个测试的结果。因此，最终输出行必须在单对方括号内包含 $18$ 个逗号分隔的浮点数。", "solution": "该问题提出了计算流体动力学领域中一个适定且科学上合理的任务，要求实现并比较两种不同的数值方法来估计二维界面的曲率。问题提供了进行严谨数值求解所需的所有必要定义、方程和参数。因此，该问题被认为是有效的。解决方案通过遵循问题描述中列举的步骤来执行。\n\n问题的核心是使用三种方法计算指定界面 $y = \\eta(x)$ 的曲率：解析公式法、基于流体体积分数（VOF）场的高度函数（HF）法，以及水平集（$\\phi$）法。\n\n界面由函数 $\\eta(x)=y_0+A\\sin(kx)+\\varepsilon\\sin(3kx)$ 在周期性域 $x\\in[0,L]$ 上给出，其中 $k=2\\pi m/L$。作为基准真相的解析曲率，由平面曲线 $y=\\eta(x)$ 的标准公式导出：\n$$ \\kappa_{true}(x) = -\\frac{\\eta''(x)}{\\left(1 + (\\eta'(x))^2\\right)^{3/2}} $$\n$\\eta(x)$ 的一阶和二阶导数是：\n$$ \\eta'(x) = Ak\\cos(kx)+3\\varepsilon k\\cos(3kx) $$\n$$ \\eta''(x) = -Ak^2\\sin(kx)-9\\varepsilon k^2\\sin(3kx) $$\n\n数值域是在 $[0,L]\\times[0,H]$ 上定义的均匀笛卡尔网格，包含 $N_x \\times N_y$ 个单元。单元尺寸为 $\\Delta x = L/N_x$ 和 $\\Delta y = H/N_y$。单元中心位于坐标 $(x_i, y_j) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$，其中 $i=0, \\dots, N_x-1$ 且 $j=0, \\dots, N_y-1$。\n\n**1. 高度函数（HF）曲率估计**\n\n该方法首先从二维 VOF 场 $F(x,y)$ 重建一维高度函数 $h(x)$，然后计算其曲率。\n\n**1a. VOF 场计算**\n单元 $(i,j)$ 中的 VOF 分数 $F_{i,j}$ 表示流体（定义为区域 $y  \\eta(x)$）占据该单元体积的比例。由于界面是光滑的，可以通过在单元宽度上平均垂直流体分数来获得更准确的 $F_{i,j}$。对于给定的水平位置 $x$，以 $y_j$ 为中心的单元内的垂直占据分数 $L(x)$ 定义为：\n$$\nL(x) = \\begin{cases} \n0,  \\text{if } \\eta(x) \\le y_j - \\Delta y/2 \\\\\n1,  \\text{if } \\eta(x) \\ge y_j + \\Delta y/2 \\\\\n(\\eta(x) - (y_j - \\Delta y/2))/\\Delta y,  \\text{otherwise}\n\\end{cases}\n$$\nVOF 分数 $F_{i,j}$ 是 $L(x)$ 在单元宽度 $[x_i-\\Delta x/2, x_i+\\Delta x/2]$ 上的平均值：\n$$ F_{i,j} = \\frac{1}{\\Delta x} \\int_{x_i-\\Delta x/2}^{x_i+\\Delta x/2} L(x) \\,dx $$\n该积分使用 $4$ 点 Gauss-Legendre 求积法进行近似。该求积法则近似了 $[-1,1]$ 上的积分。在进行变量替换 $x = x_i + u \\cdot (\\Delta x/2)$ 后，积分变为：\n$$ F_{i,j} \\approx \\frac{1}{\\Delta x} \\left( \\frac{\\Delta x}{2} \\sum_{q=1}^{4} w_q L(x_q) \\right) = \\frac{1}{2}\\sum_{q=1}^{4} w_q L(x_q) $$\n其中 $u_q$ 和 $w_q$ 是 $[-1,1]$ 上的求积节点和权重，$x_q = x_i + u_q \\cdot (\\Delta x/2)$ 是单元中对应的点。\n\n**1b. 高度函数与曲率**\n每列 $i$ 处的一维高度函数 $h_i$ 通过垂直求和 VOF 的贡献来计算：\n$$ h_i = \\sum_{j=0}^{N_y-1} F_{i,j} \\Delta y $$\n这个离散高度函数的曲率 $\\kappa_{HF,i}$ 随后使用与解析曲率相同的公式计算，但使用数值导数。一阶和二阶导数 $h'_i$ 和 $h''_i$ 使用二阶周期性中心差分计算：\n$$ h'_i = \\frac{h_{i+1} - h_{i-1}}{2\\Delta x} $$\n$$ h''_i = \\frac{h_{i+1} - 2h_i + h_{i-1}}{(\\Delta x)^2} $$\n其中索引对 $N_x$ 取模以强制周期性。最终曲率为：\n$$ \\kappa_{HF,i} = -\\frac{h''_i}{\\left(1 + (h'_i)^2\\right)^{3/2}} $$\n\n**2. 水平集（$\\phi$）曲率估计**\n\n该方法使用一个标量场 $\\phi$，其零等值线代表界面。曲率由该场的导数计算得出。\n\n**2a. 水平集场及其导数**\n水平集场在单元中心定义为有向距离函数，$\\phi_{i,j} = y_j - \\eta(x_i)$。需要计算該场的梯度 $\\nabla\\phi = (\\phi_x, \\phi_y)$。这些分量通过数值方法计算。由于域在 $x$ 方向是周期性的，因此 $\\phi_x$ 使用周期性中心差分。对于 $\\phi_y$，内部使用标准中心差分，在 $y$ 边界使用单侧差分。\n$$ \\phi_{x,i,j} = \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2\\Delta x} \\quad (\\text{periodic in } i) $$\n$$ \\phi_{y,i,j} = \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2\\Delta y} \\quad (\\text{central for interior } j) $$\n\n**2b. 法向量与曲率**\n界面的单位法向量由 $\\mathbf{n} = \\nabla\\phi / |\\nabla\\phi|$ 给出。这在网格上逐点计算：\n$$ \\mathbf{n}_{i,j} = \\frac{(\\phi_{x,i,j}, \\phi_{y,i,j})}{\\sqrt{\\phi_{x,i,j}^2 + \\phi_{y,i,j}^2}} $$\n曲率是法向量场的散度，$\\kappa_\\phi = \\nabla \\cdot \\mathbf{n} = \\partial n_x/\\partial x + \\partial n_y/\\partial y$。散度也使用数值差分计算，并考虑 $x$ 方向的周期性：\n$$ \\kappa_{\\phi,i,j} = \\frac{n_{x,i+1,j} - n_{x,i-1,j}}{2\\Delta x} + \\frac{n_{y,i,j+1} - n_{y,i,j-1}}{2\\Delta y} $$\n\n**2c. 界面曲率采样**\n曲率 $\\kappa_{\\phi,i,j}$ 定义在整个网格上。为了获得每列 $i$ 在界面处的曲率，我们在界面高度 $y = \\eta(x_i)$ 处对 $\\kappa_{\\phi,i,j}$ 进行采样。这通过在 $y$ 方向进行线性插值来完成。对于每列 $i$，我们找到网格行索引 $j$，使得 $y_j \\le \\eta(x_i)  y_{j+1}$。然后插值得到的曲率 $\\kappa_{\\phi,i}$ 为：\n$$ \\kappa_{\\phi,i} = (1-\\alpha)\\kappa_{\\phi,i,j} + \\alpha\\kappa_{\\phi,i,j+1}, \\quad \\text{where} \\quad \\alpha = \\frac{\\eta(x_i) - y_j}{\\Delta y} $$\n\n**3. 误差分析与收敛性**\n\n对于每种方法，均方根（RMS）误差是相对于在列中心 $x_i$ 计算的解析曲率 $\\kappa_{true,i}$ 来计算的：\n$$ E_{HF} = \\sqrt{\\frac{1}{N_x}\\sum_{i=0}^{N_x-1}(\\kappa_{HF,i} - \\kappa_{true,i})^2}, \\quad E_{\\phi} = \\sqrt{\\frac{1}{N_x}\\sum_{i=0}^{N_x-1}(\\kappa_{\\phi,i} - \\kappa_{true,i})^2} $$\n通过在基础分辨率为 $(N_x^{(0)}, N_y^{(0)})$ 的网格和加密分辨率为 $(2N_x^{(0)}, 2N_y^{(0)})$ 的网格上计算这些误差，来进行收敛性研究。观测到的精度阶数 $p$ 使用以下公式估计：\n$$ p = \\frac{\\log(E(N^{(0)}) / E(2N^{(0)}))}{\\log(2)} $$\n这提供了 $p_{HF}$ 和 $p_{\\phi}$，它们表明数值误差随网格加密而减小的速度。由于所采用的数值格式主要是二阶精度的，因此 $p$ 的期望值约为 $2$。\n\n实现过程遵循问题陈述中为每个测试用例提供的这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n# No scipy needed.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # (L, H, y0, A, eps, m, Nx0, Ny0)\n    test_cases = [\n        (1.0, 1.0, 0.5, 0.1, 0.01, 1, 32, 64),\n        (1.0, 1.0, 0.5, 0.02, 0.0, 1, 24, 48),\n        (1.0, 1.0, 0.5, 0.3, 0.05, 1, 40, 80),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = solve_for_case(case)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.8f}' for x in all_results)}]\")\n\ndef solve_for_case(case_params):\n    \"\"\"\n    Solves for a single test case, performing the convergence study.\n    \"\"\"\n    L, H, y0, A, eps, m, Nx0, Ny0 = case_params\n\n    # Coarse grid computation\n    e_hf_0, e_phi_0 = run_simulation(L, H, y0, A, eps, m, Nx0, Ny0)\n\n    # Refined grid computation\n    Nx1, Ny1 = 2 * Nx0, 2 * Ny0\n    e_hf_1, e_phi_1 = run_simulation(L, H, y0, A, eps, m, Nx1, Ny1)\n\n    # Order of accuracy calculation\n    # A small epsilon is added to the denominator to avoid division by zero\n    # if an error happens to be exactly zero.\n    p_hf = np.log((e_hf_0 + 1e-30) / (e_hf_1 + 1e-30)) / np.log(2)\n    p_phi = np.log((e_phi_0 + 1e-30) / (e_phi_1 + 1e-30)) / np.log(2)\n\n    return [e_hf_0, e_hf_1, p_hf, e_phi_0, e_phi_1, p_phi]\n\ndef run_simulation(L, H, y0, A, eps, m, Nx, Ny):\n    \"\"\"\n    Performs the full numerical simulation for a given set of parameters and grid resolution.\n    \"\"\"\n    # 1. Grid and Analytical Interface Setup\n    dx, dy = L / Nx, H / Ny\n    x = np.linspace(dx / 2.0, L - dx / 2.0, Nx)\n    y = np.linspace(dy / 2.0, H - dy / 2.0, Ny)\n    xg, yg = np.meshgrid(x, y)\n\n    k = 2.0 * np.pi * m / L\n    eta = lambda t: y0 + A * np.sin(k * t) + eps * np.sin(3.0 * k * t)\n    eta_p = lambda t: A * k * np.cos(k * t) + 3.0 * eps * k * np.cos(3.0 * k * t)\n    eta_pp = lambda t: -A * k**2 * np.sin(k * t) - 9.0 * eps * k**2 * np.sin(3.0 * k * t)\n\n    eta_vals_at_x = eta(x)\n    kappa_true = -eta_pp(x) / (1.0 + eta_p(x)**2)**1.5\n\n    # 2. VOF Method\n    # 2a. VOF field F_ij calculation using 4-point Gauss-Legendre quadrature\n    gauss_nodes, gauss_weights = np.polynomial.legendre.leggauss(4)\n    x_quad_offsets = gauss_nodes * dx / 2.0\n    F = np.zeros((Ny, Nx))\n\n    for i in range(Nx):\n        y_lower_bounds = y - dy / 2.0\n        x_quad_points = x[i] + x_quad_offsets\n        eta_at_quad = eta(x_quad_points)\n        \n        for j in range(Ny):\n            L_vals = (eta_at_quad - y_lower_bounds[j]) / dy\n            L_vals = np.clip(L_vals, 0.0, 1.0)\n            F[j, i] = np.sum(gauss_weights * L_vals) / 2.0\n\n    # 2b. Height-function curvature\n    h = np.sum(F, axis=0) * dy\n    h_p = (np.roll(h, -1) - np.roll(h, 1)) / (2.0 * dx)\n    h_pp = (np.roll(h, -1) - 2.0 * h + np.roll(h, 1)) / (dx**2)\n    kappa_hf = -h_pp / (1.0 + h_p**2)**1.5\n\n    # 3. Level-Set Method\n    # 3a. Level-set field and its gradient\n    phi = yg - eta(xg)\n    \n    # Gradient in y (non-periodic) using numpy.gradient's standard handling\n    phi_y = np.gradient(phi, dy, axis=0, edge_order=2)\n    # Gradient in x (periodic) using central differences via numpy.roll\n    phi_x = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n\n    # 3b. Normal vector and its divergence (curvature)\n    grad_phi_norm = np.sqrt(phi_x**2 + phi_y**2)\n    grad_phi_norm = np.maximum(grad_phi_norm, 1e-12) # Avoid division by zero\n    nx = phi_x / grad_phi_norm\n    ny = phi_y / grad_phi_norm\n\n    # Divergence of n: d(nx)/dx (periodic) + d(ny)/dy (non-periodic)\n    dnx_dx = (np.roll(nx, -1, axis=1) - np.roll(nx, 1, axis=1)) / (2.0 * dx)\n    dny_dy = np.gradient(ny, dy, axis=0, edge_order=2)\n    kappa_phi_grid = dnx_dx + dny_dy\n    \n    # 3c. Interpolate grid-based curvature to the interface\n    kappa_phi = np.zeros(Nx)\n    for i in range(Nx):\n        eta_val = eta_vals_at_x[i]\n        # Find index of cell center just below the interface\n        # y_j = (j + 0.5) * dy  = j = eta_val/dy - 0.5\n        j_below_float = (eta_val / dy) - 0.5\n        j_below = int(np.floor(j_below_float))\n        \n        # Clamp index to be in a valid range for interpolation [0, Ny-2]\n        j_below = np.clip(j_below, 0, Ny - 2)\n        j_above = j_below + 1\n\n        # Linear interpolation weight alpha\n        alpha = (eta_val - y[j_below]) / dy\n        \n        # Interpolate curvature value\n        kappa_phi[i] = (1.0 - alpha) * kappa_phi_grid[j_below, i] + alpha * kappa_phi_grid[j_above, i]\n\n    # 4. Compute RMS errors\n    e_hf = np.sqrt(np.mean((kappa_hf - kappa_true)**2))\n    e_phi = np.sqrt(np.mean((kappa_phi - kappa_true)**2))\n\n    return e_hf, e_phi\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3305550"}, {"introduction": "在均匀的高分辨率网格上模拟界面通常计算成本过高，尤其是在三维空间中。自适应网格加密（AMR）技术通过将计算资源集中在最需要的区域（即界面附近），为此提供了高效的解决方案。这项高级练习 [@problem_id:3305549] 聚焦于AMR的核心挑战：设计和实现跨网格层级的数据传输算子。您将学习如何为流体体积分数（VOF）场构建守恒的传输格式，并为水平集（level-set）场构建保持几何一致性的插值方法，这是开发高效、精确的多尺度界面追踪模拟器的关键一步。", "problem": "给定一个在方形域 $[0,1]\\times[0,1]$ 上的二维、均匀、以单元为中心的有限体积网格，该网格包含 $N\\times N$ 个宽度为 $h=1/N$ 的单元。定义了两种相指示器：一个是水平集函数 $\\phi(\\mathbf{x})$，表示到界面的有符号距离（因此理想情况下满足程函性质 $\\lvert \\nabla \\phi \\rvert = 1$）；另一个是体积分数函数 $F(\\mathbf{x})$，表示其中一相的单元平均指示函数。考虑一个以 $(0.5,0.5)$ 为中心、半径为 $R$ 的圆形界面，其精确的有符号距离场为 $\\phi(x,y) = \\sqrt{(x-0.5)^2 + (y-0.5)^2} - R$。通过以下公式定义一个正则化的 Heaviside 函数 $H_\\varepsilon(\\zeta)$，其平滑半厚度为 $\\varepsilon > 0$：\n$$\nH_\\varepsilon(\\zeta) = \n\\begin{cases}\n0,  \\zeta \\le -\\varepsilon,\\\\\n\\frac{1}{2} \\left[ 1 + \\frac{\\zeta}{\\varepsilon} + \\frac{1}{\\pi} \\sin\\left( \\frac{\\pi \\zeta}{\\varepsilon} \\right) \\right],  \\lvert \\zeta \\rvert  \\varepsilon,\\\\\n1,  \\zeta \\ge \\varepsilon.\n\\end{cases}\n$$\n设流体为 $\\phi \\le 0$ 的区域。然后，将每个单元中心的粗网格体积分数定义为 $F = H_\\varepsilon(-\\phi)$。\n\n将应用自适应网格加密（AMR），以便在界面附近以及体积分数跃变剧烈的区域触发加密。具体来说，如果满足 $\\lvert \\phi_{i,j} \\rvert \\le \\epsilon_\\phi$ 或 $\\lVert \\nabla F \\rVert_{i,j} \\ge \\tau_F$，则标记索引为 $(i,j)$ 的粗单元以进行加密。其中 $\\epsilon_\\phi > 0$ 和 $\\tau_F > 0$ 是阈值，$\\nabla F$ 在粗网格上使用中心有限差分进行近似，并在边界处使用合适的单边差分。一个加密比率 $r \\in \\mathbb{N}$ 将一个被标记的粗单元细分为 $r\\times r$ 个细子单元。\n\n您必须：\n- 设计并实现一个标记准则，当且仅当 $\\lvert \\phi \\rvert \\le \\epsilon_\\phi$ 或 $\\lVert \\nabla F \\rVert \\ge \\tau_F$ 时，标记每个粗单元以进行加密。\n- 为 $F$ 指定并实现保守的限制（restriction）和延拓（prolongation）算子：\n  - 限制算子必须在有限体积意义上是保守的：粗单元平均值 $F^{c}$ 必须等于其细子单元 $F^{f}$ 的面积加权平均值，从而保证在不同层级间传递时总“流体体积” $\\sum F\\,h^2$ 守恒。\n  - 延拓算子必须是保守且有界的：在每个粗单元内使用斜率限制将 $F$ 重构为分段线性函数以强制单调性，计算临时的细单元平均值，然后应用一个重分布步骤，该步骤在确保所有子单元中 $0 \\le F \\le 1$ 的同时，强制精确守恒父单元的平均值。\n- 为 $\\phi$ 延拓到细网格指定并实现一个一致的插值方法：使用分段线性重构，其梯度通过中心差分估计并进行缩放，以使重构的 $\\phi$ 近似为有符号距离，即在加密区域内 $\\lvert \\nabla \\phi \\rvert \\approx 1$。将 $\\phi$ 限制回粗网格时，使用算术平均。\n\n从以下基本原则出发：\n- 水平集函数 $\\phi$ 作为有符号距离的定义意味着，在远离扭结（kink）处几乎处处满足程函性质 $\\lvert \\nabla \\phi \\rvert = 1$。\n- 体积分数 $F$ 作为指示函数的单元平均值的定义意味着，在离散化和层级间传递时必须保持有限体积守恒。\n- 斜率限制（如 minmod 限制器）是一种经过充分检验的机制，用于确保分段线性重构的单调性并防止产生新的极值。\n\n您的程序必须：\n- 为给定的圆形界面和正则化的 Heaviside 函数 $H_\\varepsilon$ 构建粗网格场 $\\phi$ 和 $F$，其中平滑半厚度为 $\\varepsilon = \\eta_{\\mathrm{fac}}\\,h$，$\\eta_{\\mathrm{fac}}$ 是给定的无量纲因子。\n- 使用阈值 $\\epsilon_\\phi = \\epsilon_{\\phi,\\mathrm{fac}}\\,h$ 和 $\\tau_F = \\tau_{F,\\mathrm{fac}}/\\varepsilon$ 标记粗单元以进行加密，其中 $\\epsilon_{\\phi,\\mathrm{fac}}$ 和 $\\tau_{F,\\mathrm{fac}}$ 是给定的无量纲因子。\n- 对于每个被标记的单元，使用指定的算子将 $F$ 和 $\\phi$ 延拓到一个 $r\\times r$ 的片区（patch）。然后将 $F$ 限制回粗网格，并计算此加密-限制循环前后的总流体体积，以评估守恒性。\n- 通过在每个加密片区上计算细网格上的离散梯度 $\\nabla \\phi$（使用有限差分），并测量在满足 $\\lvert \\phi \\rvert \\le \\kappa$ 的细单元上 $\\lvert \\nabla \\phi \\rvert$ 与 $1$ 的最大偏差，来诊断 $\\phi$ 插值的一致性。其中 $\\kappa = 2\\,\\epsilon_\\phi$。\n\n测试套件：\n使用以下三个测试用例，每个用例以元组 $(N, R, \\eta_{\\mathrm{fac}}, \\epsilon_{\\phi,\\mathrm{fac}}, \\tau_{F,\\mathrm{fac}}, r)$ 的形式给出：\n- 用例 1： $(32, 0.3, 2.0, 1.0, 0.6, 2)$。\n- 用例 2： $(16, 0.25, 1.0, 0.5, 0.8, 2)$。\n- 用例 3： $(24, 0.2, 3.0, 0.2, 0.2, 2)$。\n\n对于每个用例，您的程序必须输出三个量：\n- 被加密的粗单元的整数数量 $n_{\\mathrm{ref}}$。\n- 对所有加密单元上的 $F$ 进行一次保守的延拓-限制循环后，总流体体积的相对误差 $e_V = \\lvert V_{\\mathrm{after}} - V_{\\mathrm{before}} \\rvert / \\max(V_{\\mathrm{before}}, 10^{-16})$。\n- 在所有加密片区内的细子单元中，程函方程的最大偏差 $e_\\phi = \\max_{\\lvert \\phi \\rvert \\le \\kappa} \\lvert \\lVert \\nabla \\phi \\rVert - 1 \\rvert$，其中 $\\kappa = 2\\,\\epsilon_\\phi$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。按顺序连接每个测试用例的三个量，得到一个长度为 $9$ 的扁平列表：\n$[n_{\\mathrm{ref},1}, e_{V,1}, e_{\\phi,1}, n_{\\mathrm{ref},2}, e_{V,2}, e_{\\phi,2}, n_{\\mathrm{ref},3}, e_{V,3}, e_{\\phi,3}]$。\n所有三个 $e_V$ 和 $e_\\phi$ 值都必须以浮点数形式打印。此问题不涉及物理单位。", "solution": "用户提供的问题是计算流体力学中一个明确定义的练习，具体涉及在耦合水平集/流体体积（level-set/volume-of-fluid）方法中，为自适应网格加密（AMR）实现和验证数据传输算子。该问题具有科学依据、内容自洽且算法明确。我将着手提供一个解决方案。\n\n该解决方案需要为以下方面设计和实现算法：\n1.  初始化粗网格上的水平集函数 $\\phi$ 和体积分数函数 $F$。\n2.  根据指定标准标记粗单元以进行加密。\n3.  将 $\\phi$ 和 $F$ 从一个粗单元延拓到一个细单元片区。\n4.  将 $F$ 从一个细单元片区限制回单个粗单元值。\n5.  诊断 $F$ 算子的守恒性和 $\\phi$ 算子的一致性。\n\n我将详细说明每个主要组件的实现。\n\n### 1. 网格和场初始化\n计算域为 $[0,1] \\times [0,1]$。使用一个 $N \\times N$ 单元的均匀、以单元为中心的网格。单元宽度为 $h=1/N$。单元中心 $(x_i, y_j)$ 的坐标由下式给出：\n$$ x_i = (i + 1/2)h, \\quad y_j = (j + 1/2)h \\quad \\text{for } i,j = 0, \\dots, N-1 $$\n水平集场 $\\phi$ 表示到以 $(0.5, 0.5)$ 为中心、半径为 $R$ 的圆的有符号距离，在每个单元中心计算：\n$$ \\phi_{i,j} = \\sqrt{(x_i - 0.5)^2 + (y_j - 0.5)^2} - R $$\n体积分数场 $F$ 由 $\\phi$ 通过给定的正则化 Heaviside 函数 $H_\\varepsilon(\\zeta)$ 导出，平滑半厚度为 $\\varepsilon = \\eta_{\\mathrm{fac}}h$。关系为 $F = H_\\varepsilon(-\\phi)$：\n$$\nF_{i,j} = H_\\varepsilon(-\\phi_{i,j}) = \n\\begin{cases}\n0,  -\\phi_{i,j} \\le -\\varepsilon,\\\\\n\\frac{1}{2} \\left[ 1 - \\frac{\\phi_{i,j}}{\\varepsilon} - \\frac{1}{\\pi} \\sin\\left( \\frac{\\pi \\phi_{i,j}}{\\varepsilon} \\right) \\right],  \\lvert \\phi_{i,j} \\rvert  \\varepsilon,\\\\\n1,  -\\phi_{i,j} \\ge \\varepsilon.\n\\end{cases}\n$$\n\n### 2. 单元加密标记\n如果索引为 $(i,j)$ 的粗单元满足以下两个条件之一，则将其标记为待加密：\n1.  **界面邻近度**：单元中心靠近界面，$\\lvert \\phi_{i,j} \\rvert \\le \\epsilon_\\phi$，其中阈值为 $\\epsilon_\\phi = \\epsilon_{\\phi,\\mathrm{fac}}h$。\n2.  **陡峭的体积分数**：体积分数梯度较大，$\\lVert \\nabla F \\rVert_{i,j} \\ge \\tau_F$，其中阈值为 $\\tau_F = \\tau_{F,\\mathrm{fac}}/\\varepsilon$。\n\n体积分数的梯度 $\\nabla F = (\\partial_x F, \\partial_y F)$ 使用二阶中心有限差分对内部单元进行近似，并在域边界处使用一阶单边差分。范数 $\\lVert \\nabla F \\rVert_{i,j}$ 是标准的欧几里得范数 $\\sqrt{(\\partial_x F)_{i,j}^2 + (\\partial_y F)_{i,j}^2}$。\n\n### 3. 延拓与限制算子\n\n#### 3.1. 体积分数 $F$\n$F$ 的数据传输算子必须是保守的，以保持总流体体积。\n\n**延拓（从粗到细）**：\n目标是从单个粗单元值 $F^c$ 生成 $r \\times r$ 个细单元值 $F^f_k$，以实现守恒性（$\\sum_k F^f_k = r^2 F^c$）和有界性（$0 \\le F^f_k \\le 1$）。这是通过带有斜率限制的分段线性重构，后跟一个重分布步骤来完成的。\n\n1.  **斜率限制**：对于每个粗单元 $(i,j)$，我们计算限制后的斜率 $(\\partial_x F)_{lim}$、$(\\partial_y F)_{lim}$。我们使用 minmod 限制器，这是强制单调性的标准选择。对于 x 方向：\n    $$ (\\partial_x F)_{lim} = \\text{minmod}\\left( \\frac{F_{i+1,j} - F_{i,j}}{h}, \\frac{F_{i,j} - F_{i-1,j}}{h} \\right) $$\n    其中 $\\text{minmod}(a,b) = \\frac{1}{2}(\\text{sgn}(a)+\\text{sgn}(b))\\min(\\lvert a \\rvert, \\lvert b \\rvert)$。y 方向有类似的表达式。在边界处，斜率设为零。\n\n2.  **重构**：通过在细单元中心评估线性重构来计算临时的细单元值 $\\tilde{F}^f_k$：\n    $$ \\tilde{F}^f_k = F^c + (\\nabla F)_{lim} \\cdot (\\mathbf{x}^f_k - \\mathbf{x}^c) $$\n\n3.  **重分布**：调整临时值 $\\tilde{F}^f_k$ 以满足守恒性和边界条件。采用迭代过程：\n    a. 首先，强制守恒：$\\tilde{F}^f_k \\leftarrow \\tilde{F}^f_k + (F^c - \\text{mean}(\\tilde{F}^f))$。\n    b. 迭代地修正越界值。在每次迭代中，将值裁剪到 $[0,1]$ 区间。计算由裁剪产生的总质量变化，并将其均匀地重新分配给非饱和单元（值严格在 $0$ 和 $1$ 之间的单元）。此过程重复固定次数或直到收敛。这确保最终的细单元值 $F^f_k$ 是有界的，同时它们的均值非常接近 $F^c$。\n\n**限制（从细到粗）**：\n此操作是简单平均，这与有限体积的守恒定义是一致的：\n$$ F^c = \\frac{1}{r^2} \\sum_{k=1}^{r^2} F^f_k $$\n\n#### 3.2. 水平集 $\\phi$\n$\\phi$ 的算子必须是一致的，旨在保持有符号距离属性 $|\\nabla\\phi|=1$。\n\n**延拓（从粗到细）**：\n与 $F$ 类似，我们使用分段线性重构。\n1.  **梯度估计**：使用中心差分计算粗网格梯度 $\\nabla \\phi^c$。\n2.  **归一化**：为强制执行程函性质，对梯度进行归一化：$\\mathbf{g} = \\nabla \\phi^c / \\lvert \\nabla \\phi^c \\rvert$。如果 $\\lvert \\nabla \\phi^c \\rvert = 0$，则将 $\\mathbf{g}$ 设为零。\n3.  **重构**：细单元值计算如下：\n    $$ \\phi^f_k = \\phi^c + \\mathbf{g} \\cdot (\\mathbf{x}^f_k - \\mathbf{x}^c) $$\n$\\phi$ 不需要重分布。\n\n**限制（从细到粗）**：\n如指定的那样，这是简单的算术平均：$\\phi^c = \\frac{1}{r^2} \\sum_k \\phi^f_k$。\n\n### 4. 诊断计算\n\n**体积守恒误差 $e_V$**：\n总流体体积为 $V = \\sum_{i,j} F_{i,j} h^2$。我们使用初始粗网格 $F$ 计算体积 $V_{\\mathrm{before}}$。然后，创建一个新网格 $F_{\\mathrm{after}}$，其中每个被标记单元的值被替换为延拓-限制循环的结果：$F_{\\mathrm{after}, i,j} = \\text{restrict}(\\text{prolongate}(F_{i,j}))$。从这个新网格计算体积 $V_{\\mathrm{after}}$。相对误差为：\n$$ e_V = \\frac{\\lvert V_{\\mathrm{after}} - V_{\\mathrm{before}} \\rvert}{\\max(V_{\\mathrm{before}}, 10^{-16})} $$\n由于保守算子的精心实现，该误差预计将接近机器精度。\n\n**程函方程偏差 $e_\\phi$**：\n对于从被标记单元生成的每个细片区，我们使用细网格上的中心差分计算延拓场的梯度 $\\nabla \\phi^f$。然后，我们找到其大小与 $1$ 的最大偏差，该偏差是在所有靠近界面（$\\lvert \\phi^f_k \\rvert \\le \\kappa = 2\\epsilon_\\phi$）的细单元上计算的：\n$$ e_\\phi = \\max_{\\text{所有细片区}} \\left( \\max_{k \\text{ s.t. } \\lvert\\phi^f_k\\rvert \\le \\kappa} \\lvert \\lvert \\nabla \\phi^f_k \\rvert - 1 \\rvert \\right) $$\n\n这些过程构成了解决问题并为每个测试用例生成所需输出的完整计划。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # Scipy is available but not used in this solution.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n\n    def H_eps(zeta, eps):\n        \"\"\"Regularized Heaviside function.\"\"\"\n        val = np.zeros_like(zeta, dtype=float)\n        # To avoid division by zero if eps is zero, though problem constraints prevent this.\n        if eps == 0:\n            val[zeta  0] = 1.0\n            return val\n            \n        mask_mid = np.abs(zeta)  eps\n        zeta_mid = zeta[mask_mid]\n        val[mask_mid] = 0.5 * (1.0 + zeta_mid / eps + (1.0 / np.pi) * np.sin(np.pi * zeta_mid / eps))\n        val[zeta = eps] = 1.0\n        return val\n\n    def minmod(a, b):\n        \"\"\"Minmod limiter function.\"\"\"\n        return 0.5 * (np.sign(a) + np.sign(b)) * np.minimum(np.abs(a), np.abs(b))\n\n    def compute_limited_slopes(F, h):\n        \"\"\"Computes minmod-limited slopes for a 2D field F.\"\"\"\n        # X-direction slopes\n        dF_fwd_x = (np.roll(F, -1, axis=1) - F) / h\n        dF_bwd_x = (F - np.roll(F, 1, axis=1)) / h\n        sx = minmod(dF_fwd_x, dF_bwd_x)\n        sx[:, 0] = 0.0\n        sx[:, -1] = 0.0\n\n        # Y-direction slopes\n        dF_fwd_y = (np.roll(F, -1, axis=0) - F) / h\n        dF_bwd_y = (F - np.roll(F, 1, axis=0)) / h\n        sy = minmod(dF_fwd_y, dF_bwd_y)\n        sy[0, :] = 0.0\n        sy[-1, :] = 0.0\n        \n        return sx, sy\n\n    def prolongate_F(F_c, sx, sy, h, r):\n        \"\"\"Prolongates F to a fine patch with conservation and bounds.\"\"\"\n        h_f = h / r\n        rel_coords_1d = np.linspace(-(h - h_f) / 2.0, (h - h_f) / 2.0, r)\n        rel_x, rel_y = np.meshgrid(rel_coords_1d, rel_coords_1d)\n        \n        F_prov = F_c + sx * rel_x + sy * rel_y\n        \n        F_f = F_prov\n        # Enforce conservation initially\n        F_f += F_c - np.mean(F_f)\n        \n        for _ in range(20): # Iterative redistribution\n            if np.all((F_f = 0)  (F_f = 1)):\n                break\n            \n            F_clipped = np.clip(F_f, 0, 1)\n            error_sum = F_c * (r**2) - np.sum(F_clipped)\n            \n            receivers_mask = (F_clipped  1e-12)  (F_clipped  1 - 1e-12)\n            num_receivers = np.sum(receivers_mask)\n\n            if num_receivers == 0:\n                F_f = F_clipped\n                break\n            \n            delta = error_sum / num_receivers\n            F_f = F_clipped\n            F_f[receivers_mask] += delta\n        \n        # Final clip to strictly enforce bounds after iterations\n        return np.clip(F_f, 0, 1)\n\n\n    def prolongate_phi(phi_c, gx, gy, h, r):\n        \"\"\"Prolongates phi with normalized gradients.\"\"\"\n        h_f = h / r\n        norm = np.sqrt(gx**2 + gy**2)\n        if norm  1e-15:\n            gx_norm, gy_norm = gx / norm, gy / norm\n        else:\n            gx_norm, gy_norm = 0.0, 0.0\n            \n        rel_coords_1d = np.linspace(-(h - h_f) / 2.0, (h - h_f) / 2.0, r)\n        rel_x, rel_y = np.meshgrid(rel_coords_1d, rel_coords_1d)\n\n        return phi_c + gx_norm * rel_x + gy_norm * rel_y\n\n    test_cases = [\n        (32, 0.3, 2.0, 1.0, 0.6, 2),\n        (16, 0.25, 1.0, 0.5, 0.8, 2),\n        (24, 0.2, 3.0, 0.2, 0.2, 2)\n    ]\n\n    results = []\n    for case in test_cases:\n        N, R, eta_fac, eps_phi_fac, tau_F_fac, r = case\n\n        # 1. Setup coarse grid and fields\n        h = 1.0 / N\n        eps = eta_fac * h\n        grid_coords = np.linspace(h / 2.0, 1.0 - h / 2.0, N)\n        xx, yy = np.meshgrid(grid_coords, grid_coords)\n        \n        phi_coarse = np.sqrt((xx - 0.5)**2 + (yy - 0.5)**2) - R\n        F_coarse = H_eps(-phi_coarse, eps)\n        \n        # 2. Tag cells for refinement\n        eps_phi = eps_phi_fac * h\n        tau_F = tau_F_fac / eps if eps  0 else float('inf')\n        \n        grad_F_y, grad_F_x = np.gradient(F_coarse, h)\n        grad_F_norm = np.sqrt(grad_F_x**2 + grad_F_y**2)\n        \n        tags = (np.abs(phi_coarse) = eps_phi) | (grad_F_norm = tau_F)\n        n_ref = np.sum(tags)\n        \n        # 3. Prepare for prolongation/restriction cycle\n        V_before = np.sum(F_coarse) * h**2\n        F_after = F_coarse.copy()\n        all_eikonal_errors = []\n        \n        # Pre-compute gradients for all cells\n        sx_F, sy_F = compute_limited_slopes(F_coarse, h)\n        grad_phi_y, grad_phi_x = np.gradient(phi_coarse, h)\n        \n        tagged_indices = np.argwhere(tags)\n        for i, j in tagged_indices:\n            # 4. Prolongation-Restriction for F\n            F_cell = F_coarse[i, j]\n            sx, sy = sx_F[i, j], sy_F[i, j]\n            F_fine_patch = prolongate_F(F_cell, sx, sy, h, r)\n            \n            # Conservative restriction is simple averaging\n            F_restricted = np.mean(F_fine_patch)\n            F_after[i, j] = F_restricted\n\n            # 5. Prolongation and Diagnosis for phi\n            phi_cell = phi_coarse[i, j]\n            gx, gy = grad_phi_x[i, j], grad_phi_y[i, j]\n            phi_fine_patch = prolongate_phi(phi_cell, gx, gy, h, r)\n\n            h_fine = h / r\n            grad_phi_fine_y, grad_phi_fine_x = np.gradient(phi_fine_patch, h_fine)\n            grad_norm_fine = np.sqrt(grad_phi_fine_x**2 + grad_phi_fine_y**2)\n            \n            kappa = 2.0 * eps_phi\n            mask = np.abs(phi_fine_patch) = kappa\n            if np.any(mask):\n                errors = np.abs(grad_norm_fine[mask] - 1.0)\n                all_eikonal_errors.append(np.max(errors))\n\n        # 6. Finalize diagnostics\n        V_after = np.sum(F_after) * h**2\n        e_V = np.abs(V_after - V_before) / max(V_before, 1e-16)\n\n        if not all_eikonal_errors:\n            e_phi = 0.0\n        else:\n            e_phi = np.max(all_eikonal_errors)\n\n        results.extend([n_ref, e_V, e_phi])\n    \n    # Format and print the final flat list of results\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3305549"}]}