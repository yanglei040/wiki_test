{"hands_on_practices": [{"introduction": "要真正掌握水平集方法，必须将理论付诸实践。重新初始化过程的核心在于求解一个特定的 Hamilton-Jacobi 方程。这个过程中的关键数值挑战是为信息流选择正确的“迎风”方向，以确保解的稳定性和准确性。此练习 [@problem_id:3339817] 将让你通过手动计算来实践这一核心步骤，使用 Godunov 格式在单个网格点上对重新初始化方程进行离散化，从而从最底层理解该方程的执行机制。", "problem": "考虑一个一维均匀网格，其间距为 $\\Delta x = 0.2$，节点位置为 $x_{i-1}$、$x_i$ 和 $x_{i+1}$，以及一个用于表示有符号距离函数的水平集函数 $\\phi$。重初始化步骤由以下哈密顿-雅可比型偏微分方程（PDE）建模\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0)\\left(|\\partial_x \\phi| - 1\\right) = 0,\n$$\n其中 $S(\\phi_0)$ 是初始水平集 $\\phi_0$ 的平滑符号函数，$\\tau$ 是仅用于重初始化的伪时间变量。在节点 $x_i$ 处的单边有限差分为\n$$\nD_x^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}, \\qquad D_x^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}.\n$$\n从哈密顿-雅可比方程中数值哈密顿量的单调性要求以及由特征速度导出的迎风原理出发，推导在 $x_i$ 处 $|\\partial_x \\phi|$ 的一个Godunov型相容离散格式。该格式使用单边差分 $D_x^- \\phi_i$ 和 $D_x^+ \\phi_i$，并依赖于 $S(\\phi_0)$ 在 $x_i$ 处的符号。然后，对于给定的具体数据\n$$\n\\phi_{i-1} = 0.3, \\qquad \\phi_i = -0.1, \\qquad \\phi_{i+1} = -0.6, \\qquad \\Delta x = 0.2, \\qquad \\phi_{0,i} = 0.15,\n$$\n计算在 $x_i$ 处 $|\\partial_x \\phi|$ 的Godunov离散值，并确定由重初始化PDE所隐含的在 $x_i$ 处的伪时间更新方向。在方向指示符中，使用 $+1$ 表示 $\\phi_i$ 相对于 $\\tau$ 增加，$-1$ 表示减少， $0$ 表示稳定不变。\n\n将您的最终答案表示为一个单行矩阵，其第一个元素是在 $x_i$ 处计算出的 $|\\partial_x \\phi|$ 的Godunov值，第二个元素是更新方向指示符。无需四舍五入。", "solution": "重初始化PDE\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0)\\left(|\\partial_x \\phi| - 1\\right) = 0\n$$\n是一个哈密顿-雅可比型方程，其哈密顿量为\n$$\nH(p) = S(\\phi_0)\\left(|p| - 1\\right), \\qquad p = \\partial_x \\phi.\n$$\n对于粘性解，一个相容且单调的数值哈密顿量必须遵循由特征速度决定的迎风方向。特征速度由哈密顿量对 $p$ 的导数给出：\n$$\na(p) = \\frac{\\partial H}{\\partial p} = S(\\phi_0)\\frac{\\partial}{\\partial p}|p| = S(\\phi_0)\\,\\operatorname{sign}(p), \\quad \\text{for } p \\neq 0,\n$$\n其中 $\\operatorname{sign}(p)$ 表示符号函数。由于 $a(p)$ 依赖于（未知的）局部梯度 $p$，Godunov数值哈密顿量根据单调性原理在容许的单边近似 $D_x^- \\phi_i$ 和 $D_x^+ \\phi_i$ 中进行选择：当 $H$ 在 $|p|$ 上非递减时，离散化在其每个参数上必须是非递减的，并且必须根据特征方向选择迎风差分。\n\n在一维情况下，可以通过考虑由单边斜率张成的 $p$ 的容许区间来推导 $|\\partial_x \\phi|$ 的Godunov选择。数值哈密顿量在该区间内寻找与单调性和迎风性相符的 $|p|$ 的极值。由此得到在 $x_i$ 处大小 $|\\partial_x \\phi|$ 的Godunov离散格式为\n$$\n|\\partial_x \\phi|_{\\text{G}} =\n\\begin{cases}\n\\sqrt{\\max\\!\\left(\\bigl(\\max(D_x^- \\phi_i,0)\\bigr)^2, \\bigl(\\min(D_x^+ \\phi_i,0)\\bigr)^2\\right)},  \\text{if } S(\\phi_{0,i})  0, \\\\\n\\sqrt{\\max\\!\\left(\\bigl(\\max(D_x^+ \\phi_i,0)\\bigr)^2, \\bigl(\\min(D_x^- \\phi_i,0)\\bigr)^2\\right)},  \\text{if } S(\\phi_{0,i})  0, \\\\\n0,  \\text{if } S(\\phi_{0,i}) = 0,\n\\end{cases}\n$$\n在一维情况下，这简化为根据 $D_x^- \\phi_i$ 和 $D_x^+ \\phi_i$ 的符号选择迎风的单边大小。具体来说，对于 $S(\\phi_{0,i})0$，\n- 如果 $D_x^- \\phi_i \\ge 0$ 且 $D_x^+ \\phi_i \\le 0$，那么 $|\\partial_x \\phi|_{\\text{G}} = \\max\\!\\left(|D_x^- \\phi_i|, |D_x^+ \\phi_i|\\right)$，\n- 如果 $D_x^- \\phi_i \\ge 0$ 且 $D_x^+ \\phi_i \\ge 0$，那么 $|\\partial_x \\phi|_{\\text{G}} = |D_x^- \\phi_i|$，\n- 如果 $D_x^- \\phi_i \\le 0$ 且 $D_x^+ \\phi_i \\le 0$，那么 $|\\partial_x \\phi|_{\\text{G}} = |D_x^+ \\phi_i|$，\n而对于 $S(\\phi_{0,i})0$， $D_x^- \\phi_i$ 和 $D_x^+ \\phi_i$ 的作用相反。\n\n现在为给定数据计算单边差分：\n$$\nD_x^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{\\Delta x} = \\frac{-0.1 - 0.3}{0.2} = \\frac{-0.4}{0.2} = -2.0,\n$$\n$$\nD_x^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{\\Delta x} = \\frac{-0.6 - (-0.1)}{0.2} = \\frac{-0.5}{0.2} = -2.5.\n$$\n平滑符号函数 $S(\\phi_{0,i})$ 为正，因为 $\\phi_{0,i} = 0.15  0$；任何标准的平滑符号函数近似（例如，对于小的 $\\varepsilon0$，$S(\\phi_{0,i}) = \\phi_{0,i}/\\sqrt{\\phi_{0,i}^2 + \\varepsilon^2}$）都会得出 $S(\\phi_{0,i})  0$。\n\n当 $S(\\phi_{0,i})  0$ 且两个单边差分都为负时，Godunov选择简化为\n$$\n|\\partial_x \\phi|_{\\text{G}} = |D_x^+ \\phi_i| = 2.5.\n$$\n接下来，根据PDE确定伪时间更新方向：\n$$\n\\frac{\\partial \\phi_i}{\\partial \\tau} = -\\,S(\\phi_{0,i})\\left(|\\partial_x \\phi|_{\\text{G}} - 1\\right).\n$$\n代入 $S(\\phi_{0,i})0$ 和 $|\\partial_x \\phi|_{\\text{G}} = 2.5$ 得\n$$\n\\frac{\\partial \\phi_i}{\\partial \\tau} = -\\,(\\text{positive number}) \\times (2.5 - 1) = -(\\text{positive number}) \\times 1.5,\n$$\n其值为负。因此，更新方向指示符为 $-1$（减少）。\n\n因此，所要求的输出是Godunov数值 $2.5$ 和方向指示符 $-1$。", "answer": "$$\\boxed{\\begin{pmatrix} 2.5  -1 \\end{pmatrix}}$$", "id": "3339817"}, {"introduction": "在理解了重新初始化的基本数值机制之后，我们可以将其应用于一个完整的仿真场景中。这个实践练习 [@problem_id:3339798] 要求你编写一个一维代码，对一个代表薄膜的水平集函数进行重新初始化。这个场景突显了一个在实践中非常常见的失效模式：当结构厚度与网格尺寸相当时，标准的重新初始化方法可能导致薄膜被数值侵蚀。通过实现一种“剪切”策略来减轻这种数值伪影，你将学会如何处理这类问题，并了解开发稳健数值方法的重要性。", "problem": "考虑一种一维水平集方法 (Level Set Method, LSM)，该方法通过标量场 $\\phi(x,t)$ 的零水平来表示界面。符号距离函数的定义是其属性 $\\lvert \\nabla \\phi \\rvert = 1$ 几乎处处成立，并且在一个区域内部 $\\phi  0$，外部 $\\phi  0$。重新初始化是将任意的 $\\phi(x,0)$ 演化到一个满足程函方程 $\\lvert \\nabla \\phi \\rvert = 1$ 的稳态的过程，同时保留原始零水平集的拓扑结构。一种标准的重新初始化方法使用 Hamilton–Jacobi 演化方程\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S_{\\epsilon}(\\phi_0)\\, \\left(\\lvert \\nabla \\phi \\rvert - 1\\right) = 0,\n$$\n其中 $\\tau$ 是一个虚拟时间，$\\phi_0$ 是初始场，$S_{\\epsilon}$ 是从 $\\phi_0$ 构建的平滑符号函数（例如 $S_{\\epsilon}(u) = \\frac{u}{\\sqrt{u^2+\\epsilon^2}}$）。在一维空间网格中，间距为 $h$，可以对 $\\lvert \\nabla \\phi \\rvert$ 使用 Godunov 迎风离散化，并结合受 Courant–Friedrichs–Lewy (CFL) 条件约束的显式时间步进。\n\n当两个界面间距 $g$ 与网格间距 $h$ 的量级相近时，重新初始化可能会错误地合并界面或侵蚀它们之间的薄膜，因为 $S_{\\epsilon}(\\phi_0)$ 在一个与 $h$ 相当的宽度上被正则化，导致平滑邻域重叠和数值扩散。有两种缓解思路：在网格点与两个不同界面距离相当的模糊区域附近，局部削减重新初始化的速度；或者采用多值符号距离，该方法保留到每个界面的独立距离。\n\n您的任务是编写一个完整的程序，该程序：\n- 构建一个一维域 $x \\in [-L,L]$，该域具有 $N$ 个点的均匀网格和间距 $h$。\n- 建立一个初始符号距离场 $\\phi_0(x)$，它表示一个由两个对称放置在 $x=-g/2$ 和 $x=+g/2$ 的界面所界定的薄膜，其中薄膜内部 $\\phi_0(x)  0$，外部 $\\phi_0(x)  0$，并且 $\\phi_0$ 等于到最近界面的符号距离。\n- 使用显式欧拉时间步进法，在虚拟时间 $\\tau$ 中演化 $\\phi$，采用上述重新初始化方程，并在一维空间上使用 Godunov 迎风格式：\n  - 对于每个网格索引 $i$，定义单边差分 $D^+ \\phi_i = \\frac{\\phi_{i+1}-\\phi_i}{h}$ 和 $D^- \\phi_i = \\frac{\\phi_i-\\phi_{i-1}}{h}$。对于边界，通过在需要时复制边界值来强制执行齐次 Neumann 条件。\n  - 对于每个 $i$，计算\n    $$\n    G_i = \n    \\begin{cases}\n    \\sqrt{\\max\\left(\\max(D^- \\phi_i, 0)^2, \\min(D^+ \\phi_i, 0)^2\\right)}  \\text{如果 } S_{\\epsilon}(\\phi_{0,i})  0,\\\\\n    \\sqrt{\\max\\left(\\max(D^+ \\phi_i, 0)^2, \\min(D^- \\phi_i, 0)^2\\right)}  \\text{如果 } S_{\\epsilon}(\\phi_{0,i})  0,\\\\\n    0  \\text{如果 } S_{\\epsilon}(\\phi_{0,i}) = 0,\n    \\end{cases}\n    $$\n    并更新\n    $$\n    \\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, S_{\\epsilon}(\\phi_{0,i})\\, \\left(G_i - 1\\right).\n    $$\n- 实现一种局部削减策略，该策略在网格点与两个界面几乎等距时抑制重新初始化：设 $x_L$ 和 $x_R$ 表示从 $\\phi_0$ 初始化的两个界面位置（通过子单元过零点检测找到）。为每个网格点 $x_i$ 定义距离 $d_L = \\lvert x_i - x_L \\rvert$ 和 $d_R = \\lvert x_i - x_R \\rvert$，以及接近度度量 $c_i = \\lvert d_L - d_R \\rvert$。引入一个权重 $w_i \\in \\{0,1\\}$，定义为\n  $$\n  w_i = \\begin{cases}\n  0  \\text{如果 } c_i  \\beta\\, h,\\\\\n  1  \\text{否则},\n  \\end{cases}\n  $$\n  并在更新中用 $w_i\\, S_{\\epsilon}(\\phi_{0,i})$ 替换 $S_{\\epsilon}(\\phi_{0,i})$。这会在两个界面因距离太近而无法在网格尺度上区分的区域局部冻结重新初始化。将 $\\beta$ 视为一个固定常数。\n- 在指定步数的重新初始化之后，测量两个诊断指标：\n  - 通过相邻网格点之间的符号变化检测到的过零点数量，通过线性插值到子单元位置计算。这可以量化两个界面是否仍然存在。\n  - 薄膜厚度，定义为包围 $x=0$ 的两个过零点位置之间的距离。如果找到的过零点少于两个，则报告薄膜厚度为 $0$。\n\n对所有测试使用以下固定的数值参数：\n- 域半长 $L = 1$（无量纲）。\n- 网格点数 $N = 801$（因此域包含 $x=0$）。\n- 网格间距 $h = \\frac{2L}{N-1}$（无量纲）。\n- 重新初始化平滑参数 $\\epsilon = \\alpha h$，其中 $\\alpha = 1.5$（无量纲）。\n- 时间步长 $\\Delta \\tau = 0.3 h$（无量纲），以满足 Courant–Friedrichs–Lewy 数。\n- 重新初始化步数 $N_{\\tau} = 300$。\n- 削减阈值因子 $\\beta = 1$。\n\n测试套件：\n- 情况 A（理想情况）：$g/h = 3.0$。\n- 情况 B（边界情况）：$g/h = 1.0$。\n- 情况 C（边缘情况）：$g/h = 0.5$。\n\n对于每种情况，从相同的 $\\phi_0$ 开始运行两次重新初始化：一次使用基准方案，另一次启用削减策略。对于每次运行，报告：\n- $g/h$，浮点数，\n- 基准方案的过零点数量，整数，\n- 基准方案的薄膜厚度除以 $h$，浮点数，\n- 削减方案的过零点数量，整数，\n- 削减方案的薄膜厚度除以 $h$，浮点数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个含三个元素的列表，每个元素对应一种情况。每个元素必须是包含上述五个值的列表，按指定顺序排列，例如\n  $$\n  \\left[ [g/h, z_{\\text{base}}, t_{\\text{base}}/h, z_{\\text{clip}}, t_{\\text{clip}}/h], \\ \\ldots \\right].\n  $$\n- 所有量均为定义的无量纲量，因此不需要物理单位。", "solution": "用户提供了一个有效的问题陈述。\n\n### 水平集重新初始化简介\n\n水平集方法 (LSM) 是一种强大的数值技术，用于跟踪演化中的界面和形状，广泛应用于计算流体力学、计算机图形学和材料科学等领域。其核心思想是将界面 $\\Gamma$ 表示为高维标量函数 $\\phi(\\mathbf{x}, t)$ 的零水平集，即 $\\Gamma(t) = \\{ \\mathbf{x} \\mid \\phi(\\mathbf{x}, t) = 0 \\}$。按照惯例，界面包围的区域内部 $\\phi  0$，外部 $\\phi  0$。\n\n为了数值稳定性和准确性，非常希望 $\\phi$ 是一个符号距离函数 (SDF)，它满足程函方程 $|\\nabla \\phi| = 1$。然而，在界面演化过程中，$\\phi$ 场可能会失真，失去 SDF 的特性。重新初始化是一个关键过程，它将 $\\phi$ 重塑为 SDF，同时保持零水平集 ($\\phi=0$) 不变。这通常通过求解一个 Hamilton-Jacobi 方程直到达到稳态来实现：\n$$\n\\frac{\\partial \\phi}{\\partial \\tau} + S(\\phi_0) \\left( |\\nabla \\phi| - 1 \\right) = 0\n$$\n这里，$\\tau$ 是重新初始化过程的虚拟时间变量。$S(\\phi_0)$ 是从重新初始化之前的初始失真场 $\\phi_0$ 导出的符号函数。它确保演化朝着正确的方向进行（即，使 $|\\nabla \\phi|$ 更接近 1），而不会移动零水平集。为避免奇异性，使用平滑符号函数，例如 $S_{\\epsilon}(\\phi_0) = \\frac{\\phi_0}{\\sqrt{\\phi_0^2 + \\epsilon^2}}$，其中 $\\epsilon$ 是一个通常与网格间距 $h$ 同量级的小参数。\n\n### 数值离散化\n\n重新初始化方程在离散网格上求解。我们考虑一个一维域 $x \\in [-L, L]$，具有 $N$ 个均匀分布的网格点 $x_i$ 和间距 $h = \\frac{2L}{N-1}$。\n\n- **时间离散化**：使用显式前向欧拉法在虚拟时间 $\\tau$ 上推进：\n  $$\n  \\frac{\\phi_i^{n+1} - \\phi_i^n}{\\Delta \\tau} = -S_{\\epsilon}(\\phi_{0,i}) \\left( |\\nabla \\phi|_i - 1 \\right)\n  $$\n  其中 $\\Delta \\tau$ 是时间步长，其选择要足够小以满足 Courant–Friedrichs–Lewy (CFL) 稳定性条件。\n\n- **空间离散化**：非线性项 $|\\nabla \\phi|$ 需要适用于 Hamilton-Jacobi 方程的精细迎风离散格式。Godunov 格式是一个标准选择。在一维中，它由下式给出：\n  $$\n  |\\nabla \\phi|_i \\approx G_i =\n  \\begin{cases}\n  \\sqrt{\\max\\left(\\left(\\max(D^- \\phi_i, 0)\\right)^2, \\left(\\min(D^+ \\phi_i, 0)\\right)^2\\right)}  \\text{如果 } S_{\\epsilon}(\\phi_{0,i})  0 \\\\\n  \\sqrt{\\max\\left(\\left(\\max(D^+ \\phi_i, 0)\\right)^2, \\left(\\min(D^- \\phi_i, 0)\\right)^2\\right)}  \\text{如果 } S_{\\epsilon}(\\phi_{0,i})  0 \\\\\n  0  \\text{如果 } S_{\\epsilon}(\\phi_{0,i}) = 0\n  \\end{cases}\n  $$\n  其中 $D^+ \\phi_i = \\frac{\\phi_{i+1} - \\phi_i}{h}$ 和 $D^- \\phi_i = \\frac{\\phi_i - \\phi_{i-1}}{h}$ 分别是前向和后向有限差分。在域边界处强制执行齐次 Neumann 边界条件 ($\\frac{\\partial\\phi}{\\partial x}=0$)。\n\n因此，网格点 $\\phi_i$ 从时间步 $n$ 到 $n+1$ 的完整更新为：\n$$\n\\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, S_{\\epsilon}(\\phi_{0,i})\\, \\left(G_i - 1\\right)\n$$\n\n### 薄膜问题与数值侵蚀\n\nLSM 中的一个已知挑战是表示厚度与网格间距相当的薄结构。在这个问题中，我们模拟一个厚度为 $g$、对称放置在 $x=0$ 周围的薄膜。初始场 $\\phi_0(x)$ 被构建为到 $x = -g/2$ 和 $x = +g/2$ 处界面的真实符号距离函数。\n\n当 $g$ 与 $h$ 的量级相同时，标准的重新初始化可能导致数值误差。平滑符号函数 $S_{\\epsilon}(\\phi_0)$ 的过渡区宽度与 $\\epsilon = \\alpha h$ 成正比。如果薄膜太薄，来自左侧界面的平滑会与来自右侧界面的平滑重叠。这会在薄膜中心附近的符号项 $S_{\\epsilon}(\\phi_0)$ 中产生模糊性，导致不正确的演化，并使两个界面合并或薄膜“被侵蚀”，从而有效地破坏该特征。\n\n### 削减缓解策略\n\n为了抵消这种侵蚀，引入了一种局部削减策略。其核心思想是在网格过于粗糙以至于无法明确确定最近界面的区域抑制重新初始化。\n\n1. 通过检测初始场 $\\phi_0$ 的过零点来找到初始界面位置 $x_L$ 和 $x_R$。\n2. 对于每个网格点 $x_i$，我们计算其到左、右界面的距离，$d_L = |x_i - x_L|$ 和 $d_R = |x_i - x_R|$。\n3. 定义一个“接近度度量” $c_i = |d_L - d_R|$。$c_i$ 的小值表示 $x_i$ 与两个界面的距离几乎相等。这是模糊区域。\n4. 基于阈值 $\\beta h$ 定义一个二元权重 $w_i$：\n   $$\n   w_i = \\begin{cases}\n   0  \\text{如果 } c_i  \\beta h \\\\\n   1  \\text{否则}\n   \\end{cases}\n   $$\n5. 该权重用于修改更新规则，通过乘以符号项，在 $w_i=0$ 的地方有效地“削减”或冻结重新初始化的速度：\n   $$\n   \\phi_i^{n+1} = \\phi_i^n - \\Delta \\tau \\, \\left(w_i S_{\\epsilon}(\\phi_{0,i})\\right)\\, \\left(G_i - 1\\right)\n   $$\n该策略有选择地应用重新初始化，从而在欠解析区域中保持薄膜的完整性。\n\n### 模拟与评估\n\n程序实现了基准和削减重新初始化两种方案。它针对三种不同的薄膜厚度与网格间距之比 $g/h$ 初始化薄膜。经过固定数量的重新初始化步骤（$N_{\\tau}=300$）后，计算两个诊断指标：\n- 过零点的数量，这表明两个界面是否已合并为一个或消失。\n- 薄膜厚度，测量为包围原点的两个过零点之间的距离，它量化了薄膜侵蚀的程度。\n\n通过比较基准方案和削减方案的结果，评估了缓解策略在不同薄膜分辨率水平下的有效性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D level set reinitialization problem for a thin film,\n    comparing a baseline scheme with a local clipping mitigation strategy.\n    \"\"\"\n\n    # Define the fixed numerical parameters from the problem statement.\n    L = 1.0\n    N = 801\n    h = 2 * L / (N - 1)\n    alpha = 1.5\n    epsilon = alpha * h\n    dt = 0.3 * h\n    N_tau = 300\n    beta = 1.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        3.0,  # Case A: g/h = 3.0\n        1.0,  # Case B: g/h = 1.0\n        0.5,  # Case C: g/h = 0.5\n    ]\n    \n    # Grid setup\n    x = np.linspace(-L, L, N, dtype=np.float64)\n    \n    results = []\n\n    def find_zero_crossings(x_grid, phi_field):\n        \"\"\"Finds subcell zero-crossing locations using linear interpolation.\"\"\"\n        crossings = []\n        # Find indices where sign changes\n        indices = np.where(phi_field[:-1] * phi_field[1:]  0)[0]\n        for i in indices:\n            phi_i, phi_i1 = phi_field[i], phi_field[i+1]\n            x_i, x_i1 = x_grid[i], x_grid[i+1]\n            # Linear interpolation formula for zero crossing\n            x_cross = x_i - phi_i * (x_i1 - x_i) / (phi_i1 - phi_i)\n            crossings.append(x_cross)\n        return sorted(crossings)\n\n    def calculate_diagnostics(crossings, h_spacing):\n        \"\"\"Calculates number of crossings and film thickness.\"\"\"\n        num_crossings = len(crossings)\n        \n        neg_crossings = [c for c in crossings if c = 0]\n        pos_crossings = [c for c in crossings if c > 0]\n        \n        thickness = 0.0\n        if neg_crossings and pos_crossings:\n            thickness = min(pos_crossings) - max(neg_crossings)\n            \n        return num_crossings, thickness / h_spacing\n\n    for gh_ratio in test_cases:\n        g = gh_ratio * h\n\n        # Build initial signed distance field phi_0\n        dist = np.minimum(np.abs(x + g / 2.0), np.abs(x - g / 2.0))\n        sign_field = np.ones_like(x)\n        sign_field[(x > -g / 2.0)  (x  g / 2.0)] = -1.0\n        phi0 = dist * sign_field\n\n        # Pre-compute the smoothed sign of the initial field\n        s_phi0 = phi0 / np.sqrt(phi0**2 + epsilon**2)\n\n        case_results = [gh_ratio]\n\n        # --- Run simulation for both baseline and clipped schemes ---\n        for use_clipping in [False, True]:\n            phi = phi0.copy()\n            \n            w = np.ones(N) # Default weights (no clipping)\n            if use_clipping:\n                # Calculate clipping weights\n                initial_crossings = find_zero_crossings(x, phi0)\n                if len(initial_crossings) >= 2:\n                    x_L, x_R = initial_crossings[0], initial_crossings[-1]\n                else: # Fallback for unexpected cases\n                    x_L, x_R = -g/2.0, g/2.0\n                \n                d_L = np.abs(x - x_L)\n                d_R = np.abs(x - x_R)\n                c = np.abs(d_L - d_R)\n                w[c  beta * h] = 0.0\n\n            # Evolve in fictitious time\n            for _ in range(N_tau):\n                # Enforce homogeneous Neumann boundary conditions via padding\n                padded_phi = np.pad(phi, 1, 'edge')\n                \n                # Compute one-sided differences\n                diffs = np.diff(padded_phi) / h\n                dm = diffs[:-1]\n                dp = diffs[1:]\n                \n                # Compute Godunov upwind scheme for |nabla phi|\n                grad_phi_sq = np.zeros(N)\n                \n                idx_pos = s_phi0 > 0\n                idx_neg = s_phi0  0\n                \n                grad_phi_sq[idx_pos] = np.maximum(np.maximum(dm[idx_pos], 0)**2, np.minimum(dp[idx_pos], 0)**2)\n                grad_phi_sq[idx_neg] = np.maximum(np.maximum(dp[idx_neg], 0)**2, np.minimum(dm[idx_neg], 0)**2)\n                \n                G = np.sqrt(grad_phi_sq)\n                \n                # Update phi\n                update_term = s_phi0\n                if use_clipping:\n                    update_term *= w\n                \n                phi -= dt * update_term * (G - 1)\n\n            # Calculate and store diagnostics for this run\n            final_crossings = find_zero_crossings(x, phi)\n            z_count, t_h_ratio = calculate_diagnostics(final_crossings, h)\n            case_results.extend([z_count, t_h_ratio])\n            \n        results.append(case_results)\n\n    # Format the final output string to be exactly as specified, without spaces\n    formatted_sublists = []\n    for sublist in results:\n        # Format: g/h (float), z_base (int), t_base/h (float), z_clip (int), t_clip/h (float)\n        # Ensure correct types for formatting\n        formatted_items = [\n            f\"{sublist[0]:.1f}\",\n            str(int(sublist[1])),\n            f\"{sublist[2]:.6f}\",\n            str(int(sublist[3])),\n            f\"{sublist[4]:.6f}\"\n        ]\n        formatted_sublists.append(f\"[{','.join(formatted_items)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3339798"}, {"introduction": "虽然标准的重新初始化可以恢复符号距离函数属性，但它本质上不保证面积或体积等物理量的守恒，这在许多物理仿真中是不可接受的。这个高级练习 [@problem_id:3339771] 将正面解决这一问题。你将推导并实现一个使用拉格朗日乘子的修正项，以构建一个明确保持面积守恒的重新初始化方案。通过在二维仿真中比较标准方案和修正方案的收敛阶，你将深入了解如何设计满足特定物理约束的高保真数值方法。", "problem": "考虑一个移动界面的二维水平集表示，该界面由一个标量场 $\\phi(x,y,t)$ 定义，其中界面是零水平集 $\\Gamma(t) = \\{(x,y) \\mid \\phi(x,y,t) = 0\\}$。在给定的速度场 $\\mathbf{u}(x,y,t)$ 下，$\\phi$ 的平流遵循守恒律 $\\partial_t \\phi + \\mathbf{u}\\cdot\\nabla \\phi = 0$。为了保持数值稳定性和几何保真度，通常通过求解一个Hamilton-Jacobi型方程，在伪时间 $\\tau$ 内周期性地将 $\\phi$ 重新初始化为符号距离函数。一种标准的重新初始化方法根据伪时间动态演化 $\\phi$：\n$$\n\\partial_\\tau \\phi + S_\\epsilon(\\phi_0)\\left(\\lvert \\nabla \\phi\\rvert - 1\\right) = 0,\n$$\n其中 $\\phi_0(x,y)$ 是在重新初始化开始时冻结的水平集场的快照，$S_\\epsilon(\\phi_0) = \\dfrac{\\phi_0}{\\sqrt{\\phi_0^2+\\epsilon^2}}$ 是一个平滑符号函数，$\\epsilon0$ 是一个小的正则化参数。\n\n然而，重新初始化可能会人为地改变演化界面所包围的面积 $A(\\tau)$（以及界面长度 $L(\\tau)$）。为了减少此类人为影响，构造一个修改后的重新初始化方法，该方法强制执行积分约束\n$$\n\\int_{\\Omega} \\delta_\\epsilon(\\phi)\\,\\partial_\\tau \\phi\\,dx\\,dy = 0,\n$$\n其中 $\\delta_\\epsilon(\\phi)$ 是一个平滑狄拉克δ函数，将计算局部化在界面附近，$\\Omega$ 是计算域。假设修正的形式为\n$$\n\\partial_\\tau \\phi + S_\\epsilon(\\phi_0)\\big(\\lvert \\nabla \\phi\\rvert - 1\\big) = \\lambda(\\tau)\\,\\delta_\\epsilon(\\phi),\n$$\n并推导标量拉格朗日乘子 $\\lambda(\\tau)$ 的表达式，以确保所述积分约束对所有伪时间 $\\tau$ 成立。使用以下正则化：\n$$\nS_\\epsilon(\\phi) = \\frac{\\phi}{\\sqrt{\\phi^2+\\epsilon^2}},\\quad \\delta_\\epsilon(\\phi) = \\frac{1}{\\pi}\\frac{\\epsilon}{\\phi^2+\\epsilon^2},\\quad H_\\epsilon(\\phi) = \\frac{1}{2}\\left(1+\\frac{2}{\\pi}\\arctan\\left(\\frac{\\phi}{\\epsilon}\\right)\\right),\n$$\n其中 $H_\\epsilon(\\phi)$ 是平滑亥维赛德函数。包围的面积可以计算为 $A(\\tau)=\\int_{\\Omega}\\left(1-H_\\epsilon(\\phi)\\right)\\,dx\\,dy$。\n\n在周期性方形域 $\\Omega=[-1,1)\\times[-1,1)$ 上实现一个显式有限差分求解器，该域具有 $N\\times N$ 个点的单元中心网格和均匀间距 $h=2/N$。在物理时间平流步骤中，对空间导数使用一阶迎风离散格式；在伪时间重新初始化中，对梯度大小使用二阶中心差分。速度场是径向的：\n$$\n\\mathbf{u}(x,y) = \\kappa\\,(x,y),\n$$\n其中 $\\kappa$ 是一个常数。选择一个满足Courant–Friedrichs–Lewy型稳定性限制的物理时间步长 $\\Delta t$。使用伪时间步长 $\\Delta \\tau = 0.1\\,h$，并在每次重新初始化调用时执行 $M$ 个重新初始化步骤。使用通过数组滚动实现的周期性边界条件。\n\n你的程序必须：\n\n1. 根据下文规定为每个测试用例初始化 $\\phi$。\n2. 如果初始 $\\phi$ 不是符号距离函数，则在物理平流之前执行初步的标准重新初始化，以近似一个符号距离场。\n3. 在 $\\mathbf{u}(x,y)$ 下将 $\\phi$ 平流一个物理时间步。\n4. 在平流后立即使用平滑亥维赛德函数计算包围面积 $A_{\\text{pre}}$。\n5. 从平流后的场开始，应用标准重新初始化（无修正）$M$ 步，并计算 $A_{\\text{post,std}}$，然后计算漂移 $E_{\\text{std}}=\\lvert A_{\\text{post,std}}-A_{\\text{pre}}\\rvert$。\n6. 从相同的平流后的场开始，应用修改后的重新初始化（带有推导的 $\\lambda(\\tau)$ 项）$M$ 步，并计算 $A_{\\text{post,mod}}$，然后计算漂移 $E_{\\text{mod}}=\\lvert A_{\\text{post,mod}}-A_{\\text{pre}}\\rvert$。\n7. 对同一测试用例，在两种分辨率 $N_{\\text{coarse}}$ 和 $N_{\\text{fine}}$ 下重复步骤1-6，并报告漂移比率 $R_{\\text{mod}}=\\dfrac{E_{\\text{mod}}^{\\text{coarse}}}{E_{\\text{mod}}^{\\text{fine}}}$ 和 $R_{\\text{std}}=\\dfrac{E_{\\text{std}}^{\\text{coarse}}}{E_{\\text{std}}^{\\text{fine}}}$。\n\n设计测试套件以检验收缩和扩张的形状：\n\n- 测试用例1（扩张的圆形）：$N_{\\text{coarse}}=64$， $N_{\\text{fine}}=128$，初始圆形半径 $r_0=0.3$，$\\kappa=0.5$，$\\Delta t=0.01$，$\\epsilon=1.5h$，$M=40$；初始化 $\\phi(x,y)=\\sqrt{x^2+y^2}-r_0$。\n- 测试用例2（收缩的圆形）：$N_{\\text{coarse}}=64$， $N_{\\text{fine}}=128$，初始圆形半径 $r_0=0.4$，$\\kappa=-0.5$，$\\Delta t=0.01$，$\\epsilon=1.5h$，$M=40$；初始化 $\\phi(x,y)=\\sqrt{x^2+y^2}-r_0$。\n- 测试用例3（扩张的椭圆，非符号距离初始化）：$N_{\\text{coarse}}=64$，$N_{\\text{fine}}=128$，半轴 $a=0.6, b=0.3$，$\\kappa=0.4$，$\\Delta t=0.01$，$\\epsilon=1.5h$，初步重新初始化 $M_{\\text{pre}}=60$，主要重新初始化 $M=40$；初始化 $\\phi(x,y)=\\sqrt{(x/a)^2+(y/b)^2}-1$。\n\n对于每个测试用例，计算如上定义的 $R_{\\text{mod}}$ 和 $R_{\\text{std}}$。修改后方法的期望标度行为是，当网格间距 $h$ 减半时，$R_{\\text{mod}}\\approx 4$（反映了 $\\mathcal{O}(h^2)$ 的误差减少），而标准方法可能无法达到这种标度行为。你的程序应生成一行输出，其中包含三个测试用例的六个比率，形式为用方括号括起来的逗号分隔列表：\n\"[R_mod_case1,R_std_case1,R_mod_case2,R_std_case2,R_mod_case3,R_std_case3]\"。\n所有报告的值必须是无量纲单位，并以Python浮点数形式打印。", "solution": "该问题要求在一个水平集方法中，推导一个用于面积保持的重新初始化方案的拉格朗日乘子 $\\lambda(\\tau)$，然后通过数值实现来比较此修改方案与标准方案的性能。\n\n### 第1部分：拉格朗日乘子 $\\lambda(\\tau)$ 的推导\n\n目标是强制执行面积净变化为零的积分约束，该约束通过平滑狄拉克δ函数 $\\delta_\\epsilon(\\phi)$ 局部化在界面附近。该约束由下式给出：\n$$\n\\int_{\\Omega} \\delta_\\epsilon(\\phi)\\,\\partial_\\tau \\phi\\,dx\\,dy = 0\n$$\n提出的修改后重新初始化方程是一个带有与 $\\lambda(\\tau)$ 成比例的修正项的Hamilton-Jacobi方程：\n$$\n\\partial_\\tau \\phi + S_\\epsilon(\\phi_0)\\left(\\lvert \\nabla \\phi\\rvert - 1\\right) = \\lambda(\\tau)\\,\\delta_\\epsilon(\\phi)\n$$\n这里，$\\phi_0$ 是重新初始化过程开始时（$\\tau=0$）的水平集场，$S_\\epsilon(\\phi_0)$ 是一个平滑符号函数，它决定了为恢复符号距离属性而演化的方向（向内或向外）。\n\n为了推导 $\\lambda(\\tau)$，我们首先从修改后的重新初始化方程中解出 $\\partial_\\tau \\phi$：\n$$\n\\partial_\\tau \\phi = -S_\\epsilon(\\phi_0)\\left(\\lvert \\nabla \\phi\\rvert - 1\\right) + \\lambda(\\tau)\\,\\delta_\\epsilon(\\phi)\n$$\n接下来，我们将这个 $\\partial_\\tau \\phi$ 的表达式代入积分约束中：\n$$\n\\int_{\\Omega} \\delta_\\epsilon(\\phi) \\left( -S_\\epsilon(\\phi_0)\\left(\\lvert \\nabla \\phi\\rvert - 1\\right) + \\lambda(\\tau)\\,\\delta_\\epsilon(\\phi) \\right) \\,dx\\,dy = 0\n$$\n由于线性性质，该积分可以分为两项：\n$$\n-\\int_{\\Omega} \\delta_\\epsilon(\\phi) S_\\epsilon(\\phi_0)\\left(\\lvert \\nabla \\phi\\rvert - 1\\right) \\,dx\\,dy + \\int_{\\Omega} \\lambda(\\tau) \\left[\\delta_\\epsilon(\\phi)\\right]^2 \\,dx\\,dy = 0\n$$\n拉格朗日乘子 $\\lambda(\\tau)$ 仅是伪时间 $\\tau$ 的函数，并且相对于空间变量 $(x,y)$ 是常数。因此，它可以从第二个积分中提出：\n$$\n-\\int_{\\Omega} \\delta_\\epsilon(\\phi) S_\\epsilon(\\phi_0)\\left(\\lvert \\nabla \\phi\\rvert - 1\\right) \\,dx\\,dy + \\lambda(\\tau) \\int_{\\Omega} \\left[\\delta_\\epsilon(\\phi)\\right]^2 \\,dx\\,dy = 0\n$$\n最后，我们重新整理方程以解出 $\\lambda(\\tau)$：\n$$\n\\lambda(\\tau) \\int_{\\Omega} \\left[\\delta_\\epsilon(\\phi)\\right]^2 \\,dx\\,dy = \\int_{\\Omega} S_\\epsilon(\\phi_0) \\delta_\\epsilon(\\phi) \\left(\\lvert \\nabla \\phi\\rvert - 1\\right) \\,dx\\,dy\n$$\n这给出了拉格朗日乘子的显式表达式：\n$$\n\\lambda(\\tau) = \\frac{\\int_{\\Omega} S_\\epsilon(\\phi_0) \\delta_\\epsilon(\\phi) \\left(\\lvert \\nabla \\phi\\rvert - 1\\right) \\,dx\\,dy}{\\int_{\\Omega} \\left[\\delta_\\epsilon(\\phi)\\right]^2 \\,dx\\,dy}\n$$\n在离散的数值设置中，积分被替换为对所有网格单元的求和，微分面积元素 $dx\\,dy$ 变为恒定的网格单元面积 $h^2$，该面积从分子和分母中约去。\n\n### 第2部分：数值实现策略\n\n数值解是基于周期性域上的有限差分法实现的。\n\n**1. 网格与初始化：** 在 $\\Omega=[-1,1)\\times[-1,1)$ 上定义一个二维单元中心网格，具有 $N \\times N$ 个点和网格间距 $h=2/N$。对于 $i,j \\in \\{0, \\dots, N-1\\}$，坐标 $(x_i, y_j)$ 由 $x_i = -1 + (i+0.5)h$ 和 $y_j = -1 + (j+0.5)h$ 给出。根据每个测试用例的规范，在该网格上初始化水平集场 $\\phi$。\n\n**2. 平流步：** 使用显式欧拉法，对方程 $\\partial_t \\phi + \\mathbf{u}\\cdot\\nabla \\phi = 0$ 求解一个时间步 $\\Delta t$。空间项 $\\mathbf{u}\\cdot\\nabla \\phi$ 使用一阶迎风格式进行离散以确保稳定性。对于速度分量 $u_x(i,j)$，如果 $u_x(i,j)  0$，则导数 $\\partial_x \\phi$ 用后向差分近似；如果 $u_x(i,j)  0$，则用前向差分近似。类似逻辑适用于 $y$ 方向。周期性边界条件通过数组滚动（例如，`numpy.roll`）来处理，它正确地实现了空间差分的环绕逻辑。\n\n**3. 重新初始化步：** 标准和修改后的重新初始化都以伪时间步长 $\\Delta \\tau = 0.1h$ 执行 $M$ 步。项 $S_\\epsilon(\\phi_0)$ 的场 $\\phi_0$ 是平流后的场，在整个重新初始化过程中保持不变。\n- **梯度计算：** 梯度大小 $\\lvert \\nabla \\phi \\rvert$ 使用 $\\partial_x \\phi$ 和 $\\partial_y \\phi$ 的二阶中心差分来计算。对于单元 $(i,j)$，$\\partial_x \\phi \\approx (\\phi_{i+1,j} - \\phi_{i-1,j})/(2h)$。\n- **标准重新初始化：** 使用显式欧拉步更新场 $\\phi$：\n  $$\n  \\phi^{n+1} = \\phi^n - \\Delta \\tau \\left[ S_\\epsilon(\\phi_0) \\left(\\lvert \\nabla \\phi^n \\rvert - 1\\right) \\right]\n  $$\n- **修改后的重新初始化：** 在每个伪时间步，首先计算 $\\lambda(\\tau)$。其离散版本是对所有网格单元 $(i,j)$ 的求和：\n  $$\n  \\lambda^n = \\frac{\\sum_{i,j} S_\\epsilon(\\phi_{0,ij}) \\delta_\\epsilon(\\phi_{ij}^n) \\left(\\lvert \\nabla \\phi_{ij}^n \\rvert - 1\\right)}{\\sum_{i,j} \\left[\\delta_\\epsilon(\\phi_{ij}^n)\\right]^2}\n  $$\n  然后，更新场 $\\phi$：\n  $$\n  \\phi^{n+1} = \\phi^n - \\Delta \\tau \\left[ S_\\epsilon(\\phi_0) \\left(\\lvert \\nabla \\phi^n \\rvert - 1\\right) - \\lambda^n \\delta_\\epsilon(\\phi^n) \\right]\n  $$\n  对于测试用例3，在主要的平流-重新初始化循环开始之前，会执行 $M_{\\text{pre}}$ 步的初步标准重新初始化，将初始的非符号距离函数转换为近似的符号距离函数。\n\n**4. 面积计算与误差度量：** 通过在域上积分平滑特征函数 $\\left(1 - H_\\epsilon(\\phi)\\right)$ 来计算包围的面积：\n$$\nA = \\sum_{i,j} \\left(1 - H_\\epsilon(\\phi_{ij})\\right) h^2\n$$\n每种方法的面积漂移 $E$ 是重新初始化后的面积（$A_{\\text{post}}$）与平流后但重新初始化前的面积（$A_{\\text{pre}}$）之间的绝对差。最终报告的量是粗网格和细网格之间这些漂移的比率，$R = E^{\\text{coarse}}/E^{\\text{fine}}$。\n\n这种系统化的方法可以定量比较标准和修改后的重新初始化方案的面积守恒性质，检验修改后的方案性能更优的假设，理想情况下，面积误差的二阶收敛率将导致比率 $R_{\\text{mod}} \\approx 4$。", "answer": "```python\nimport numpy as np\n\ndef S_epsilon(phi, epsilon):\n    \"\"\"Smoothed sign function.\"\"\"\n    return phi / np.sqrt(phi**2 + epsilon**2)\n\ndef delta_epsilon(phi, epsilon):\n    \"\"\"Smoothed Dirac delta function.\"\"\"\n    return (1.0 / np.pi) * epsilon / (phi**2 + epsilon**2)\n\ndef H_epsilon(phi, epsilon):\n    \"\"\"Smoothed Heaviside function.\"\"\"\n    return 0.5 * (1.0 + (2.0 / np.pi) * np.arctan(phi / epsilon))\n\ndef calculate_area(phi, h, epsilon):\n    \"\"\"Computes the enclosed area using the smoothed Heaviside function.\"\"\"\n    area = np.sum(1.0 - H_epsilon(phi, epsilon)) * h**2\n    return area\n\ndef get_grad_mag(phi, h):\n    \"\"\"Computes gradient magnitude using second-order central differences.\"\"\"\n    # Periodic boundary conditions are handled by np.roll\n    phi_x = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * h)\n    phi_y = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * h)\n    grad_mag = np.sqrt(phi_x**2 + phi_y**2)\n    return grad_mag\n\ndef advect_step(phi, dt, h, kappa, xx, yy):\n    \"\"\"Performs one advection step using first-order upwind scheme.\"\"\"\n    u = kappa * xx\n    v = kappa * yy\n\n    # First-order differences (forward and backward)\n    phi_dx_fwd = (np.roll(phi, -1, axis=1) - phi) / h\n    phi_dx_bwd = (phi - np.roll(phi, 1, axis=1)) / h\n    phi_dy_fwd = (np.roll(phi, -1, axis=0) - phi) / h\n    phi_dy_bwd = (phi - np.roll(phi, 1, axis=0)) / h\n\n    # Upwind scheme based on velocity sign\n    u_pos = np.maximum(u, 0)\n    u_neg = np.minimum(u, 0)\n    v_pos = np.maximum(v, 0)\n    v_neg = np.minimum(v, 0)\n\n    grad_phi_upwind = (u_pos * phi_dx_bwd + u_neg * phi_dx_fwd +\n                       v_pos * phi_dy_bwd + v_neg * phi_dy_fwd)\n\n    return phi - dt * grad_phi_upwind\n\ndef reinitialize(phi_start, M, h, epsilon, method):\n    \"\"\"Performs reinitialization for M steps.\"\"\"\n    dtau = 0.1 * h\n    phi = phi_start.copy()\n\n    # The problem freezes phi_0 at the start of reinitialization\n    phi_0_reinit = phi_start.copy()\n    S_phi0 = S_epsilon(phi_0_reinit, epsilon)\n\n    for _ in range(M):\n        grad_mag = get_grad_mag(phi, h)\n        non_corrected_term = S_phi0 * (grad_mag - 1.0)\n        \n        if method == 'standard':\n            phi -= dtau * non_corrected_term\n        elif method == 'modified':\n            delta_phi = delta_epsilon(phi, epsilon)\n            \n            numerator = np.sum(delta_phi * non_corrected_term)\n            denominator = np.sum(delta_phi**2)\n            \n            # Avoid division by zero, though unlikely\n            lambda_val = numerator / denominator if denominator != 0 else 0.0\n            \n            phi -= dtau * (non_corrected_term - lambda_val * delta_phi)\n            \n    return phi\n\ndef run_simulation(N, init_phi_func, kappa, dt, m_steps, m_pre_steps=0):\n    \"\"\"Runs one full simulation for a given resolution and returns area drifts.\"\"\"\n    h = 2.0 / N\n    epsilon = 1.5 * h\n\n    # Create a cell-centered grid\n    grid_coords = np.linspace(-1.0 + 0.5 * h, 1.0 - 0.5 * h, N)\n    xx, yy = np.meshgrid(grid_coords, grid_coords)\n\n    phi = init_phi_func(xx, yy)\n\n    # Preliminary reinitialization for non-SDF cases (Test Case 3)\n    if m_pre_steps > 0:\n        phi = reinitialize(phi, m_pre_steps, h, epsilon, 'standard')\n\n    # 1. Advect for one physical time step\n    phi_advected = advect_step(phi, dt, h, kappa, xx, yy)\n\n    # 2. Compute pre-reinitialization area\n    area_pre = calculate_area(phi_advected, h, epsilon)\n\n    # 3. Standard reinitialization and compute drift\n    phi_post_std = reinitialize(phi_advected, m_steps, h, epsilon, 'standard')\n    area_post_std = calculate_area(phi_post_std, h, epsilon)\n    E_std = np.abs(area_post_std - area_pre)\n\n    # 4. Modified reinitialization and compute drift\n    phi_post_mod = reinitialize(phi_advected, m_steps, h, epsilon, 'modified')\n    area_post_mod = calculate_area(phi_post_mod, h, epsilon)\n    E_mod = np.abs(area_post_mod - area_pre)\n\n    return E_std, E_mod\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case 1: Expanding circle\n        {'r0': 0.3, 'kappa': 0.5, 'dt': 0.01, 'm_steps': 40, 'm_pre_steps': 0,\n         'init_func': lambda x, y, r0=0.3: np.sqrt(x**2 + y**2) - r0},\n        # Case 2: Shrinking circle\n        {'r0': 0.4, 'kappa': -0.5, 'dt': 0.01, 'm_steps': 40, 'm_pre_steps': 0,\n         'init_func': lambda x, y, r0=0.4: np.sqrt(x**2 + y**2) - r0},\n        # Case 3: Expanding ellipse\n        {'a': 0.6, 'b': 0.3, 'kappa': 0.4, 'dt': 0.01, 'm_steps': 40, 'm_pre_steps': 60,\n         'init_func': lambda x, y, a=0.6, b=0.3: np.sqrt((x/a)**2 + (y/b)**2) - 1.0}\n    ]\n\n    N_coarse, N_fine = 64, 128\n    results = []\n\n    for case in test_cases:\n        # Run coarse simulation\n        E_std_coarse, E_mod_coarse = run_simulation(\n            N=N_coarse,\n            init_phi_func=case['init_func'],\n            kappa=case['kappa'],\n            dt=case['dt'],\n            m_steps=case['m_steps'],\n            m_pre_steps=case['m_pre_steps']\n        )\n        \n        # Run fine simulation\n        E_std_fine, E_mod_fine = run_simulation(\n            N=N_fine,\n            init_phi_func=case['init_func'],\n            kappa=case['kappa'],\n            dt=case['dt'],\n            m_steps=case['m_steps'],\n            m_pre_steps=case['m_pre_steps']\n        )\n\n        # Calculate ratios\n        R_mod = E_mod_coarse / E_mod_fine if E_mod_fine != 0 else 0.0\n        R_std = E_std_coarse / E_std_fine if E_std_fine != 0 else 0.0\n        \n        results.extend([R_mod, R_std])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3339771"}]}