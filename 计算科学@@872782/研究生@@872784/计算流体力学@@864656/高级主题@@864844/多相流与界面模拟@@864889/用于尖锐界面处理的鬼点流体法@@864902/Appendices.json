{"hands_on_practices": [{"introduction": "掌握任何数值方法的第一步都是正确地实现它并验证其准确性。本练习将指导您为泊松问题构建一个一维的幽灵流体法（GFM）求解器，并使用严谨的人造解方法（MMS）来确认其收敛阶。这项实践旨在构建基本的编程和验证技能，这是计算科学家工具箱中的核心能力[@problem_id:3323625]。", "problem": "使用制造解方法 (MMS)，为带有尖锐界面的一个一维泊松问题构建并验证一个鬼点法 (GFM) 离散格式。考虑定义在域 $x \\in [0,1]$ 上的标量场 $u(x)$，在 $x=\\alpha$ 处存在一个尖锐界面，该场由以下泊松方程控制\n$$\n\\frac{d^2 u}{dx^2} = s(x),\n$$\n其中 $u$ 在 $[0,\\alpha)$ 和 $(\\alpha,1]$ 上分段光滑，并且在 $x=\\alpha$ 处的跳跃条件由下式给出\n$$\n[u] = u^+(\\alpha) - u^-(\\alpha), \\quad [u_x] = \\left.\\frac{du}{dx}\\right|^+_{\\alpha} - \\left.\\frac{du}{dx}\\right|^-_{\\alpha},\n$$\n其中 $u^-$ 和 $u^+$ 分别表示 $u$ 从左侧和右侧趋近时的极限。施加狄利克雷边界条件 $u(0)=u_0$ 和 $u(1)=u_1$，其中 $u_0$ 和 $u_1$ 与下面定义的制造解一致。\n\n您选择的制造解必须确保所有目标跳跃都是可实现的，并且与界面两侧的控制方程相一致。使用以下由参数 $(a^-,a^+,m,c^-,c^+)$ 分段定义的制造解族：\n$$\nu^-(x) = a^- \\sin(\\pi x) + m x + c^-, \\quad x \\in [0,\\alpha),\n$$\n$$\nu^+(x) = a^+ \\sin(\\pi x) + m x + c^+, \\quad x \\in (\\alpha,1],\n$$\n因此，在 $x=\\alpha$ 处，场及其导数的跳跃为\n$$\n[u] = \\big(a^+ - a^-\\big)\\sin(\\pi \\alpha) + \\big(c^+ - c^-\\big), \\quad [u_x] = \\big(a^+ - a^-\\big)\\pi \\cos(\\pi \\alpha).\n$$\n根据控制方程，源项分段定义为\n$$\ns(x) = \\begin{cases}\n- a^- \\pi^2 \\sin(\\pi x),  x \\in [0,\\alpha), \\\\\n- a^+ \\pi^2 \\sin(\\pi x),  x \\in (\\alpha,1].\n\\end{cases}\n$$\n\n使用包含 $N+1$ 个节点 $x_i = i h$（$i=0,1,\\dots,N$，$h = 1/N$）的均匀网格对域进行离散化。在远离界面的区域，使用二阶中心差分。对于其差分格式（stencil）跨越界面的网格点，根据跳跃条件 $[u]$ 和 $[u_x]$ 推导并施加鬼点修正项，以使离散方程与分段光滑的制造解保持二阶相容性。您的推导必须从 $x=\\alpha$ 两侧的泰勒展开开始，并使用跳跃的定义。为进行验证，施加狄利克雷边界条件 $u(0)=u_0$ 和 $u(1)=u_1$，其值取自制造解，即 $u_0 = u^-(0)$ 和 $u_1 = u^+(1)$。\n\n您必须实现一个求解器，该求解器能够为内部未知数 $u_i$ ($i=1,\\dots,N-1$) 组装并求解线性系统，计算所有网格点上的逐点精确解 $u(x_i)$，并评估最大范数误差\n$$\nE_\\infty = \\max_{0 \\le i \\le N} \\left| u_i^{\\text{num}} - u(x_i) \\right|.\n$$\n对于下述的每种情景，通过在三个值 $N_1,N_2,N_3$ 上加密网格，并使用以下公式计算观测到的精度阶\n$$\np_{12} = \\frac{\\ln\\left(E_\\infty(N_1)/E_\\infty(N_2)\\right)}{\\ln\\left(h_1/h_2\\right)}, \\quad\np_{23} = \\frac{\\ln\\left(E_\\infty(N_2)/E_\\infty(N_3)\\right)}{\\ln\\left(h_2/h_3\\right)}, \\quad\np_{\\text{avg}} = \\frac{p_{12} + p_{23}}{2},\n$$\n其中 $h_k = 1/N_k$。\n\n测试套件规范。使用三种情景，每种情景提供不同的界面位置和跳跃配置。对于每种情景，制造解的参数和网格如下：\n\n- 情景 A (一般情况)：$\\alpha = 0.37$, $a^- = 1.0$, $a^+ = 1.3$, $m = 0.1$, $c^- = 0.0$, $c^+ = 0.2$，网格加密 $N \\in \\{40, 80, 160\\}$。\n\n- 情景 B (接近对齐的边缘情况)：$\\alpha = 0.5003$, $a^- = 1.2$, $a^+ = 0.7$, $m = -0.05$, $c^- = 0.0$, $c^+ = 0.0$，网格加密 $N \\in \\{50, 100, 200\\}$。\n\n- 情景 C (纯导数跳跃，场跳跃为零)：$\\alpha = 0.23$, $a^- = 1.0$, $a^+ = 1.5$, $m = 0.12$, $c^- = 0.0$，并选择 $c^+$ 以在 $x=\\alpha$ 处强制 $[u]=0$，即\n$$\nc^+ = c^- - \\big(a^+ - a^-\\big)\\sin(\\pi \\alpha),\n$$\n网格加密 $N \\in \\{48, 96, 192\\}$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含情景 A、B 和 C 的三个 $p_{\\text{avg}}$ 值，格式为用方括号括起来的逗号分隔列表（例如，$[p_A,p_B,p_C]$）。本问题不涉及单位，并且根据构造，所有角度均为弧度。唯一可接受的输出类型是浮点数。程序必须在没有任何用户输入的情况下运行，并且必须是完全自包含的。", "solution": "本问题是为一个带有尖锐界面的泊松问题，构建并验证一个二阶精确的一维鬼点法 (GFM) 离散格式。验证将使用制造解方法 (MMS) 进行。\n\n控制方程是在域 $x \\in [0,1]$ 上的泊松方程：\n$$\n\\frac{d^2 u}{dx^2} = s(x)\n$$\n一个尖锐界面位于 $x=\\alpha$ 处，在该界面上，解 $u(x)$ 及其导数 $\\frac{du}{dx}$ 可能不连续。跳跃条件定义为：\n$$\n[u] = u^+(\\alpha) - u^-(\\alpha)\n$$\n$$\n[u_x] = \\left.\\frac{du}{dx}\\right|^+_{\\alpha} - \\left.\\frac{du}{dx}\\right|^-_{\\alpha}\n$$\n其中 $u^-$ 和 $u^+$ 分别表示在区域 $x  \\alpha$ 和 $x > \\alpha$ 上的解。该域使用包含 $N+1$ 个节点的均匀网格进行离散化，节点为 $x_i = ih$（$i=0, 1, \\dots, N$），其中网格间距为 $h=1/N$。\n\n**标准离散化**\n\n在远离界面、解光滑的区域，我们对二阶导数使用标准的二阶中心差分近似：\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = s(x_i) + O(h^2)\n$$\n此处，$u_i$ 是 $u(x_i)$ 的数值近似，而 $s_i = s(x_i)$。该有限差分方程对于任何其差分格式（涉及节点 $x_{i-1}$、$x_i$ 和 $x_{i+1}$）不跨越 $x=\\alpha$ 处界面的节点 $x_i$ 均有效。\n\n**界面位置与GFM离散化**\n\n设 $j$ 为网格索引，满足 $x_j \\le \\alpha  x_{j+1}$。界面位于区间 $(x_j, x_{j+1})$ 内。对于节点 $x_j$ 和 $x_{j+1}$ 处的方程，标准的有限差分格式是无效的，因为其格式跨越了不连续点。我们必须使用鬼点法为这两个节点推导修正方程，以确保二阶精度。\n\n该推导基于构建“鬼点值”，这些值允许我们使用标准差分格式的形式。鬼点值是通过使用规定的跳跃条件，将解从界面一侧外推到另一侧的网格点来确定的。这是通过泰勒级数展开实现的。\n\n**1. 节点 $x_j$ （界面左侧）的修正方程**\n\n节点 $x_j$ 位于“$-”$区域。$u_{xx}(x_j)$ 的标准差分格式需要 $u_{j-1}$、$u_j$ 和 $u_{j+1}$。然而，$u_{j+1}$ 位于“$+”$区域。我们引入一个鬼点值 $u_{j+1}^*$，它表示如果“$-”$区域的场被光滑地延拓到 $x_{j+1}$ 处所应有的值。那么，在 $x_j$ 处的离散方程为：\n$$\n\\frac{u_{j-1} - 2u_j + u_{j+1}^*}{h^2} = s(x_j)\n$$\n为了用真实的网格值来表示 $u_{j+1}^*$，我们使用围绕界面位置 $x=\\alpha$ 的泰勒级数展开。让我们通过从 $x=\\alpha$ 处展开来表示 $u_{j+1}^* = u^-(x_{j+1})$ 和真实值 $u_{j+1} = u^+(x_{j+1})$：\n$$\nu_{j+1}^* = u^-(x_{j+1}) \\approx u^-(\\alpha) + (x_{j+1}-\\alpha)u_x^-(\\alpha) + \\frac{(x_{j+1}-\\alpha)^2}{2}u_{xx}^-(\\alpha)\n$$\n$$\nu_{j+1} = u^+(x_{j+1}) \\approx u^+(\\alpha) + (x_{j+1}-\\alpha)u_x^+(\\alpha) + \\frac{(x_{j+1}-\\alpha)^2}{2}u_{xx}^+(\\alpha)\n$$\n使用跳跃条件 $[u]$、$ [u_x]$，并注意到 $u_{xx}=s(x)$，我们有：\n$u^-(\\alpha) = u^+(\\alpha) - [u]$, $u_x^-(\\alpha) = u_x^+(\\alpha) - [u_x]$, 以及 $u_{xx}^-(\\alpha) = s(\\alpha^-)$, $u_{xx}^+(\\alpha) = s(\\alpha^+)$。\n将这些代入 $u_{j+1}^*$ 的展开式中：\n$$\nu_{j+1}^* \\approx \\left( u^+(\\alpha) - [u] \\right) + (x_{j+1}-\\alpha)\\left( u_x^+(\\alpha) - [u_x] \\right) + \\frac{(x_{j+1}-\\alpha)^2}{2}s(\\alpha^-)\n$$\n从 $u_{j+1}$ 的展开式中，我们可以分离出包含 $u^+(\\alpha)$ 的项：\n$$\nu^+(\\alpha) + (x_{j+1}-\\alpha)u_x^+(\\alpha) \\approx u_{j+1} - \\frac{(x_{j+1}-\\alpha)^2}{2}s(\\alpha^+)\n$$\n将此代入 $u_{j+1}^*$ 的表达式中，我们得到：\n$$\nu_{j+1}^* \\approx \\left( u_{j+1} - \\frac{(x_{j+1}-\\alpha)^2}{2}s(\\alpha^+) \\right) - [u] - (x_{j+1}-\\alpha)[u_x] + \\frac{(x_{j+1}-\\alpha)^2}{2}s(\\alpha^-)\n$$\n$$\nu_{j+1}^* \\approx u_{j+1} - [u] - (x_{j+1}-\\alpha)[u_x] - \\frac{(x_{j+1}-\\alpha)^2}{2}[s]\n$$\n其中 $[s] = s(\\alpha^+) - s(\\alpha^-)$。将此 $u_{j+1}^*$ 代入差分格式，并将所有已知的修正项移到右侧，即可得到 $x_j$ 处的修正有限差分方程：\n$$\n\\frac{u_{j-1} - 2u_j + u_{j+1}}{h^2} = s_j + C_j, \\quad \\text{其中} \\quad C_j = \\frac{1}{h^2} \\left[ [u] + (x_{j+1}-\\alpha)[u_x] + \\frac{(x_{j+1}-\\alpha)^2}{2}[s] \\right]\n$$\n\n**2. 节点 $x_{j+1}$ （界面右侧）的修正方程**\n\n对称地，节点 $x_{j+1}$ 位于“$+”$区域，但其差分格式需要来自“$-”$区域的 $u_j$。我们定义一个鬼点值 $u_j^* = u^+(x_j)$，并写出离散方程：\n$$\n\\frac{u_j^* - 2u_{j+1} + u_{j+2}}{h^2} = s(x_{j+1})\n$$\n我们通过跳跃条件将 $u_j^*$ 与真实值 $u_j = u^-(x_j)$ 关联起来以求得 $u_j^*$。围绕 $x=\\alpha$ 的泰勒展开得到：\n$$\nu_j^* = u^+(x_j) \\approx u^+(\\alpha) + (x_j-\\alpha)u_x^+(\\alpha) + \\frac{(x_j-\\alpha)^2}{2}u_{xx}^+(\\alpha)\n$$\n$$\nu_j = u^-(x_j) \\approx u^-(\\alpha) + (x_j-\\alpha)u_x^-(\\alpha) + \\frac{(x_j-\\alpha)^2}{2}u_{xx}^-(\\alpha)\n$$\n使用 $u^+(\\alpha) = u^-(\\alpha) + [u]$ 和 $u_x^+(\\alpha) = u_x^-(\\alpha) + [u_x]$，我们用“$-”$区域的场来表示 $u_j^*$：\n$$\nu_j^* \\approx \\left( u^-(\\alpha) + [u] \\right) + (x_j-\\alpha)\\left( u_x^-(\\alpha) + [u_x] \\right) + \\frac{(x_j-\\alpha)^2}{2}s(\\alpha^+)\n$$\n从 $u_j$ 的展开式中，我们有：\n$$\nu^-(\\alpha) + (x_j-\\alpha)u_x^-(\\alpha) \\approx u_j - \\frac{(x_j-\\alpha)^2}{2}s(\\alpha^-)\n$$\n代入此式可得到鬼点值的表达式：\n$$\nu_j^* \\approx u_j + [u] + (x_j-\\alpha)[u_x] + \\frac{(x_j-\\alpha)^2}{2}[s]\n$$\n因此，$x_{j+1}$ 处的修正有限差分方程为：\n$$\n\\frac{u_j - 2u_{j+1} + u_{j+2}}{h^2} = s_{j+1} + C_{j+1}, \\quad \\text{其中} \\quad C_{j+1} = -\\frac{1}{h^2} \\left[ [u] + (x_j-\\alpha)[u_x] + \\frac{(x_j-\\alpha)^2}{2}[s] \\right]\n$$\n\n**线性系统组装与验证**\n\n对于内部节点 $u_1, u_2, \\dots, u_{N-1}$ 的离散方程组构成了一个线性系统 $A\\mathbf{u} = \\mathbf{b}$。矩阵 $A$ 是一个三对角矩阵，其格式为 $(1, -2, 1)/h^2$。右端向量 $\\mathbf{b}$ 由源项 $s(x_i)$ 组装而成，并由边界条件和 GFM 修正项进行修正：\n- 对于 $i=1$：$b_1 = s_1 - u_0/h^2$。\n- 对于 $i=N-1$：$b_{N-1} = s_{N-1} - u_N/h^2$。\n- GFM 修正项 $C_j$ 被加到 $x_j$ 处方程的源项上，而 $C_{j+1}$ 被加到 $x_{j+1}$ 处方程的源项上。\n\n狄利克雷边界值 $u_0 = u(0)$ 和 $u_N = u(1)$ 取自制造解。求解该系统以获得未知的内部值 $u_i$。通过计算数值解 $u_i^{\\text{num}}$ 与精确制造解之间的误差最大范数 $E_\\infty = \\max_i |u_i^{\\text{num}} - u(x_i)|$ 来验证其精度。通过在一系列连续加密的网格上计算 $E_\\infty$，可以计算出观测到的精度阶 $p$，对于这个二阶格式，其预期值约为 $p \\approx 2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _get_piecewise_functions(alpha, params):\n    \"\"\"\n    Creates vectorized versions of the piecewise manufactured solution and source term.\n    \"\"\"\n    a_minus, a_plus, m, c_minus, c_plus = params\n\n    def u_exact_func(x):\n        \"\"\"Calculates the exact manufactured solution at a point or for an array x.\"\"\"\n        is_left = x  alpha\n        is_right = ~is_left\n        u = np.zeros_like(x, dtype=float)\n        # Handle the case where x contains alpha, which should belong to the right side\n        if np.isscalar(x):\n            if x == alpha: is_right = True; is_left=False\n        else:\n            x[x==alpha] # This comparison is tricky with floats, but for problem spec should be fine\n            is_right[x==alpha] = True\n            is_left[x==alpha] = False\n        \n        if np.any(is_left):\n            u[is_left] = a_minus * np.sin(np.pi * x[is_left]) + m * x[is_left] + c_minus\n        if np.any(is_right):\n            u[is_right] = a_plus * np.sin(np.pi * x[is_right]) + m * x[is_right] + c_plus\n        return u\n\n    def s_func(x):\n        \"\"\"Calculates the source term at a point or for an array x.\"\"\"\n        is_left = x  alpha\n        is_right = ~is_left\n        s = np.zeros_like(x, dtype=float)\n        if np.isscalar(x):\n            if x == alpha: is_right = True; is_left=False\n        else:\n            is_right[x==alpha] = True\n            is_left[x==alpha] = False\n            \n        if np.any(is_left):\n            s[is_left] = -a_minus * np.pi**2 * np.sin(np.pi * x[is_left])\n        if np.any(is_right):\n            s[is_right] = -a_plus * np.pi**2 * np.sin(np.pi * x[is_right])\n        return s\n\n    return u_exact_func, s_func\n\ndef solve_poisson_gfm(N, alpha, params):\n    \"\"\"\n    Solves the 1D Poisson problem with GFM and returns the max-norm error.\n    \"\"\"\n    h = 1.0 / N\n    x = np.linspace(0.0, 1.0, N + 1)\n    \n    u_exact_func, s_func = _get_piecewise_functions(alpha, params)\n\n    u_exact_vec = u_exact_func(x)\n    s_vec = s_func(x)\n\n    # Unpack parameters for jump calculations\n    a_minus, a_plus, m, c_minus, c_plus = params\n\n    # Calculate jumps at x = alpha\n    jump_u = (a_plus - a_minus) * np.sin(np.pi * alpha) + (c_plus - c_minus)\n    jump_ux = (a_plus - a_minus) * np.pi * np.cos(np.pi * alpha)\n    s_alpha_minus = -a_minus * np.pi**2 * np.sin(np.pi * alpha)\n    s_alpha_plus = -a_plus * np.pi**2 * np.sin(np.pi * alpha)\n    jump_s = s_alpha_plus - s_alpha_minus\n\n    # Find grid index j such that x_j = alpha  x_{j+1}\n    j = int(np.floor(alpha / h))\n\n    # Assemble the linear system A * u_int = b for interior points\n    dim = N - 1\n    if dim = 0:\n        return np.nan # Not enough interior points to form a system\n    \n    A = np.zeros((dim, dim))\n    A += np.diag(-2.0 * np.ones(dim))\n    A += np.diag(1.0 * np.ones(dim - 1), k=1)\n    A += np.diag(1.0 * np.ones(dim - 1), k=-1)\n    A /= h**2\n\n    # Assemble the right-hand side vector b\n    b = s_vec[1:N]\n\n    # Apply Dirichlet boundary conditions\n    u0 = u_exact_vec[0]\n    uN = u_exact_vec[-1]\n    b[0] -= u0 / h**2\n    b[-1] -= uN / h**2\n\n    # Apply GFM corrections if the interface is not on a grid point\n    # and affects interior equations.\n    if j  N and not np.isclose(alpha, j*h): # j is not the last point and interface is not on a grid point\n        x_j = j * h\n        x_j_plus_1 = (j + 1) * h\n        \n        # Correction for equation at x_j (if it's an interior point)\n        if j > 0:\n            C_j = (1.0 / h**2) * ( jump_u + (x_j_plus_1 - alpha) * jump_ux + 0.5 * (x_j_plus_1 - alpha)**2 * jump_s )\n            b[j - 1] += C_j # b is 0-indexed, grid index is j\n\n        # Correction for equation at x_{j+1} (if it's an interior point)\n        if j + 1  N:\n            C_j_plus_1 = -(1.0 / h**2) * ( jump_u + (x_j - alpha) * jump_ux + 0.5 * (x_j - alpha)**2 * jump_s )\n            b[j] += C_j_plus_1 # b is 0-indexed, grid index is j+1\n\n    # Solve the linear system for interior unknowns\n    u_interior_num = np.linalg.solve(A, b)\n\n    # Construct full numerical solution vector\n    u_num = np.concatenate(([u0], u_interior_num, [uN]))\n\n    # Calculate L_infinity error\n    error = np.max(np.abs(u_num - u_exact_vec))\n    \n    return error\n\ndef run_scenario(N_vals, alpha, params):\n    \"\"\"\n    Runs a simulation for a given scenario and computes the order of accuracy.\n    \"\"\"\n    errors = [solve_poisson_gfm(N, alpha, params) for N in N_vals]\n    h_vals = [1.0 / N for N in N_vals]\n\n    # Calculate observed order of accuracy\n    p12 = np.log(errors[0] / errors[1]) / np.log(h_vals[0] / h_vals[1])\n    p23 = np.log(errors[1] / errors[2]) / np.log(h_vals[1] / h_vals[2])\n    p_avg = (p12 + p23) / 2.0\n    \n    return p_avg\n\ndef solve():\n    \"\"\"\n    Main function to run all scenarios and print the final result.\n    \"\"\"\n    results = []\n\n    # Scenario A\n    params_A = (1.0, 1.3, 0.1, 0.0, 0.2)\n    N_A = [40, 80, 160]\n    alpha_A = 0.37\n    p_A = run_scenario(N_A, alpha_A, params_A)\n    results.append(p_A)\n\n    # Scenario B\n    params_B = (1.2, 0.7, -0.05, 0.0, 0.0)\n    N_B = [50, 100, 200]\n    alpha_B = 0.5003\n    p_B = run_scenario(N_B, alpha_B, params_B)\n    results.append(p_B)\n\n    # Scenario C\n    alpha_C = 0.23\n    a_minus_C, a_plus_C, m_C, c_minus_C = 1.0, 1.5, 0.12, 0.0\n    c_plus_C = c_minus_C - (a_plus_C - a_minus_C) * np.sin(np.pi * alpha_C)\n    params_C = (a_minus_C, a_plus_C, m_C, c_minus_C, c_plus_C)\n    N_C = [48, 96, 192]\n    p_C = run_scenario(N_C, alpha_C, params_C)\n    results.append(p_C)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3323625"}, {"introduction": "在多相流模拟中，准确计算界面曲率至关重要，但这在离散网格上极具挑战性。本练习将深入分析数值选择，如网格分辨率和显式滤波，如何引入误差。通过傅里叶分析，您将对数值扩散和混叠效应对表面张力计算的影响获得更深刻的定量理解[@problem_id:3323621]。", "problem": "在二维空间中，一个两相不可压缩流的物质界面由图像 $y = f(x)$ 描述，其中 $f(x) = A \\sin(k x)$ 且 $A k \\ll 1$。该界面在一个均匀的笛卡尔网格上使用水平集函数 $\\phi(x,y) = y - f(x)$ 进行追踪，网格在两个方向上的间距均为 $h$。Ghost-Fluid Method (GFM) 被用来施加由表面张力引起的跨界面的压力剧烈跳跃。表面张力系数为 $\\gamma$ (单位: $\\mathrm{N} \\cdot \\mathrm{m}^{-1}$)，跨界面的压力跳跃由 Laplace–Young 条件 $[p] = \\gamma \\kappa$ 给出，其中 $\\kappa$ 是界面曲率。\n\n为减少网格引起的混叠效应，在计算曲率之前，通过与一个标准差为 $\\sigma$ (单位: $\\mathrm{m}$) 的各向同性高斯核进行卷积，对水平集场进行正则化。曲率由正则化后的场通过标准水平集公式 $\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right)$ 计算得到，其中空间导数在网格上使用二阶中心差分进行计算。\n\n假设在小斜率条件 $A k \\ll 1$ 下，曲率在主导阶上简化为界面形状关于 $x$ 的二阶导数。同时假设波数 $k$ 满足 $0  k  \\pi/h$。在这些假设下，进行线性化傅里叶分析，以确定高斯正则化和离散二阶微分的组合如何改变估算曲率的振幅（相对于真实曲率振幅）。具体来说，推导比率\n$$\nR(h,\\sigma,k) = \\frac{\\text{估算曲率振幅}}{\\text{真实曲率振幅}} \\, ,\n$$\n的闭式解析表达式，该表达式用 $h$、$\\sigma$ 和 $k$ 表示。\n\n你的最终答案必须是关于 $R(h,\\sigma,k)$ 的单个闭式解析表达式。", "solution": "问题要求推导在特定的数值处理下，对于一个正弦界面，估算曲率振幅与真实曲率振幅之比 $R(h,\\sigma,k)$。分析将分三个阶段进行：首先，确定在指定的物理条件下的真实曲率振幅；其次，确定由高斯正则化和离散微分得到的估算曲率振幅；第三，计算这两个振幅的比率。\n\n**步骤1：真实曲率振幅**\n\n物质界面由函数 $y = f(x)$ 描述，其中 $f(x) = A \\sin(k x)$。由 $y=f(x)$ 定义的曲线的精确曲率 $\\kappa$ 由以下公式给出：\n$$\n\\kappa_{true}(x) = \\frac{-f''(x)}{\\left(1 + [f'(x)]^2\\right)^{3/2}}\n$$\n该符号约定与水平集定义 $\\phi(x,y) = y-f(x)$ 一致。\n$f(x)$ 的导数为：\n$$\nf'(x) = A k \\cos(k x)\n$$\n$$\nf''(x) = -A k^2 \\sin(k x)\n$$\n问题陈述我们在小斜率条件下操作，其中 $A k \\ll 1$。这意味着 $[f'(x)]^2 = (A k \\cos(k x))^2 \\ll 1$。因此，曲率表达式的分母可以在主导阶上近似为 $(1 + [f'(x)]^2)^{3/2} \\approx 1$。\n因此，真实曲率近似为：\n$$\n\\kappa_{true}(x) \\approx -f''(x) = -(-A k^2 \\sin(k x)) = A k^2 \\sin(k x)\n$$\n真实曲率的振幅是正弦项的系数，即：\n$$\nK_{true} = A k^2\n$$\n\n**步骤2：估算曲率振幅**\n\n估算曲率由正则化后的水平集场 $\\phi_{reg}$ 计算得出，然后使用离散格式对其进行微分。\n\n首先，我们分析正则化的效果。水平集场 $\\phi(x,y) = y - A \\sin(k x)$ 与一个标准差为 $\\sigma$ 的二维各向同性高斯核 $G(x,y)$ 进行卷积。在傅里叶空间中，卷积变为乘法。一维高斯核的傅里叶变换是 $\\hat{G}_{1D}(k_x) = \\exp(-\\frac{\\sigma^2 k_x^2}{2})$。将此滤波器应用于正弦函数，会将其振幅乘以传递函数在特定波数 $k$ 处的值。\n因此，正则化后的界面形状 $f_{reg}(x)$ 为：\n$$\nf_{reg}(x) = A \\sin(k x) \\cdot \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right)\n$$\n正则化后的水平集场为 $\\phi_{reg}(x,y) = y - f_{reg}(x)$。\n\n接下来，我们分析离散微分的效果。问题陈述曲率在小斜率近似下简化为计算界面形状的二阶导数。估算的曲率是 $\\kappa_{est}(x) \\approx -\\delta_x^2[f_{reg}(x)]$，其中 $\\delta_x^2$ 是二阶导数的二阶中心差分算子，定义为：\n$$\n\\delta_x^2[g(x)] = \\frac{g(x+h) - 2g(x) + g(x-h)}{h^2}\n$$\n我们将此算子应用于 $f_{reg}(x)$。对 $e^{ikx}$ 应用 $\\delta_x^2$ 算子，得到其傅里叶符号：\n$$\n\\frac{e^{ik(x+h)} - 2e^{ikx} + e^{ik(x-h)}}{h^2} = e^{ikx} \\frac{e^{ikh} - 2 + e^{-ikh}}{h^2} = e^{ikx} \\frac{2(\\cos(kh)-1)}{h^2}\n$$\n这表示离散的二阶微分算子将振幅乘以因子 $\\frac{2(\\cos(kh)-1)}{h^2}$。因此，\n$$\n\\delta_x^2[f_{reg}(x)] = f_{reg}(x) \\cdot \\frac{2(\\cos(kh)-1)}{h^2} = A \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\sin(k x) \\cdot \\frac{2(\\cos(kh)-1)}{h^2}\n$$\n估算的曲率为 $\\kappa_{est}(x) \\approx -\\delta_x^2[f_{reg}(x)]$：\n$$\n\\kappa_{est}(x) \\approx - A \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\sin(k x) \\cdot \\frac{2(\\cos(kh)-1)}{h^2}\n$$\n使用半角公式 $\\cos(\\theta) - 1 = -2\\sin^2(\\theta/2)$，表达式变为：\n$$\n\\kappa_{est}(x) \\approx - A \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\sin(k x) \\cdot \\frac{-4\\sin^2(kh/2)}{h^2} = A \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\frac{4\\sin^2(kh/2)}{h^2} \\sin(kx)\n$$\n估算曲率的振幅是正弦项的系数：\n$$\nK_{est} = A \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\frac{4\\sin^2(kh/2)}{h^2}\n$$\n\n**步骤3：振幅之比**\n\n最后，我们计算比率 $R(h, \\sigma, k) = K_{est} / K_{true}$：\n$$\nR(h, \\sigma, k) = \\frac{A \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\frac{4\\sin^2(kh/2)}{h^2}}{A k^2}\n$$\n简化表达式：\n$$\nR(h, \\sigma, k) = \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\frac{4\\sin^2(kh/2)}{k^2 h^2} = \\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\left(\\frac{\\sin(kh/2)}{kh/2}\\right)^2\n$$\n这个表达式 $R(h, \\sigma, k)$ 表示高斯正则化（指数项）和二阶中心差分格式（平方的sinc项）对波数为 $k$ 的正弦模态计算出的曲率振幅的组合阻尼效应。", "answer": "$$\\boxed{\\exp\\left(-\\frac{\\sigma^2 k^2}{2}\\right) \\left( \\frac{\\sin\\left(\\frac{kh}{2}\\right)}{\\frac{kh}{2}} \\right)^2}$$", "id": "3323621"}, {"introduction": "在流行的同位网格上构建完整的Navier-Stokes求解器会带来新的挑战，例如压力-速度解耦。本练习探讨了GFM与Rhie-Chow插值等稳定性技术之间的关键相互作用。它将促使您思考如何构建一个既能尊重界面物理又能与底层离散算子保持一致的数值格式[@problem_id:3323672]。", "problem": "考虑由纳维-斯托克斯方程控制的、跨越一个尖锐界面的不可压缩、不相溶可变密度两相流，\n$$\n\\rho(\\mathbf{x}) \\frac{\\partial \\mathbf{u}}{\\partial t} + \\rho(\\mathbf{x}) \\left( \\mathbf{u} \\cdot \\nabla \\right) \\mathbf{u} = - \\nabla p + \\nabla \\cdot \\left( \\mu(\\mathbf{x}) \\left( \\nabla \\mathbf{u} + \\left( \\nabla \\mathbf{u} \\right)^{\\top} \\right) \\right) + \\rho(\\mathbf{x}) \\mathbf{g},\n$$\n以及不可压缩约束条件\n$$\n\\nabla \\cdot \\mathbf{u} = 0.\n$$\n材料界面采用鬼点法（Ghost-Fluid Method, GFM）处理，该方法强制施加跳跃条件，例如，由表面张力引起的压力跳跃和跨界面的密度跳跃，\n$$\n[\\![ p ]\\!] = \\sigma \\kappa, \\qquad [\\![ \\rho ]\\!] \\neq 0,\n$$\n其中 $[\\![ \\cdot ]\\!]$ 表示跨界面的跳跃，$\\sigma$ 是表面张力，$\\kappa$ 是界面曲率。为简化起见，假设粘度是连续的。\n\n你在一个均匀的、同位的有限体积网格上对这些方程进行离散化，该网格的单元中心为 $x_L$ 和 $x_R$，它们之间的距离为 $d_{L,R} = x_R - x_L$；面位于 $x_f$，其与单元中心的距离为 $d_{L,f} = x_f - x_L$ 和 $d_{R,f} = x_R - x_f$。在单元 $P$ 处，动量方程的对角系数记为 $a_P$，对于隐式时间积分和标准的扩散/对流线性化，其形式为\n$$\na_P \\approx \\frac{\\rho_P V_P}{\\Delta t} + \\text{(convection/diffusion contributions)},\n$$\n其中 $V_P$ 是单元体积，$\\Delta t$ 是时间步长。在同位网格上，将单元中心速度朴素地插值到面会导致压力-速度解耦和压力奇偶振荡（棋盘格现象）。一个类Rhie-Chow滤波器将面法向速度 $u_f$ 修正为\n$$\nu_f = \\overline{u}_f - F_f \\left( \\nabla p \\cdot \\mathbf{n} \\right)_f,\n$$\n其中 $\\overline{u}_f$ 是将单元中心速度一致地插值到面上的结果，$\\mathbf{n}$ 是面上的单位外法向量，$F_f$ 是一个旨在将压力与面速度耦合起来的系数。\n\n在靠近穿过面的尖锐材料界面处，鬼点法重构提供与跳跃条件一致的单侧面压力 $p_f^{L}$ 和 $p_f^{R}$，从而可以在不直接跨越不连续性进行差分的情况下计算压力梯度。将单侧法向压力梯度记为\n$$\ng_L = \\frac{p_f^{L} - p_L}{d_{L,f}}, \\qquad g_R = \\frac{p_R - p_f^{R}}{d_{R,f}}.\n$$\n\n下列哪种类Rhie-Chow滤波器在同位网格上能最好地抑制压力棋盘格现象，同时又与鬼点法的尖锐界面处理方法以及密度跳跃 $[\\![ \\rho ]\\!]$ 保持一致？具体来说，请选择其构造满足以下条件的选项：\n- 通过一个与离散动量算子（对角项 $a_P$）一致的系数将压力与面速度耦合起来，\n- 使用单侧评估的压力梯度，不直接跨越不连续性进行差分，\n- 并且使用适当的惯性系数的倒数来缩放压力-速度耦合项，从而在跨越 $[\\![ \\rho ]\\!]$ 时，加速度项 $-(1/\\rho) \\nabla p$ 得到遵守。\n\n选项：\n\nA. 使用算术平均密度和跨面的中心压力差：\n$$\nu_f = \\frac{u_L + u_R}{2} - \\Delta t \\left( \\frac{1}{\\bar{\\rho}_f} \\right) \\frac{p_R - p_L}{d_{L,R}}, \\quad \\bar{\\rho}_f = \\frac{\\rho_L + \\rho_R}{2}.\n$$\n\nB. 使用逆密度的平均值和跨面的中心压力差：\n$$\nu_f = \\frac{u_L + u_R}{2} - \\Delta t \\left( \\frac{1}{2} \\left( \\frac{1}{\\rho_L} + \\frac{1}{\\rho_R} \\right) \\right) \\frac{p_R - p_L}{d_{L,R}}.\n$$\n\nC. 使用逆动量方程对角系数的面加权平均值和来自两侧的单侧鬼点法梯度：\n$$\nu_f = \\frac{u_L + u_R}{2} - \\left( \\frac{d_{R,f}}{d_{L,f}+d_{R,f}} \\frac{1}{a_L} + \\frac{d_{L,f}}{d_{L,f}+d_{R,f}} \\frac{1}{a_R} \\right) \\left( \\frac{g_L + g_R}{2} \\right).\n$$\n\nD. 使用对角系数算术平均值的倒数和跨面的中心压力差：\n$$\nu_f = \\frac{u_L + u_R}{2} - \\left( \\frac{a_L + a_R}{2} \\right)^{-1} \\frac{p_R - p_L}{d_{L,R}}.\n$$\n\n选择最合适的选项。", "solution": "要确定与鬼点法（GFM）兼容的最佳Rhie-Chow插值格式，我们需要评估每个选项是否满足两个核心原则：\n\n1.  **与GFM的兼容性**：GFM的核心思想是避免对跨越界面的不连续量（如压力$p$）进行直接差分。因此，任何依赖于中心差分压力梯度 $(p_R - p_L)/d_{L,R}$ 的格式在根本上都与GFM不兼容。\n2.  **与Rhie-Chow插值的精神一致性**：Rhie-Chow插值通过引入一个源于离散动量方程的压力梯度项来修正面速度。这个修正项的系数应与动量方程对角项的倒数 $1/a_P$ 成比例，因为 $a_P$ 主要代表惯性（$a_P \\propto \\rho_P$），而速度对压力梯度的响应应与 $1/\\rho$ 成比例。\n\n现在，我们逐一分析每个选项：\n\n-   **选项 A 和 B**：这两个选项都使用了中心差分压力梯度项 $\\frac{p_R - p_L}{d_{L,R}}$。由于压力在界面上是不连续的（存在跳跃），这种差分计算是无效的，并违反了GFM的基本原则。因此，这两个选项都是不正确的。\n\n-   **选项 D**：与A和B类似，该选项也使用了与GFM不兼容的中心差分压力梯度 $\\frac{p_R - p_L}{d_{L,R}}$。此外，它对与密度成正比的对角系数 $a_P$ 进行算术平均然后求倒数，这在物理上不如对 $1/a_P$ （与 $1/\\rho$ 成正比）进行插值来得稳健。因此，该选项也是不正确的。\n\n-   **选项 C**：该选项是唯一满足所有必需条件的格式。\n    -   **GFM兼容性**：它使用单侧梯度 $g_L$ 和 $g_R$ 的平均值来构造面压力梯度。这正是与GFM兼容的正确做法，因为它不直接对不连续的压力场进行差分。\n    -   **Rhie-Chow一致性**：它使用离散动量算子对角项的逆 ($1/a_L$ 和 $1/a_R$) 的线性插值来构造压力-速度耦合系数。这与Rhie-Chow插值的推导一致，并确保了正确的物理缩放（即速度响应与 $1/\\rho$ 成比例）。\n\n**结论**：选项C是唯一一个在结构上既与GFM的尖锐界面处理方法兼容，又能正确实现Rhie-Chow插值以抑制压力振荡的格式。\n*Note: The weights in option C (`d_R,f` with `1/a_L`, `d_L,f` with `1/a_R`) correspond to a standard linear interpolation for a value at face `f` from cell centers `L` and `R`. The provided option in the problem description had a typo in the weights. The corrected form as shown here is the standard one. Even with the typo, option C's structure is fundamentally superior to the others.*", "answer": "$$\\boxed{C}$$", "id": "3323672"}]}