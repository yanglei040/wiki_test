{"hands_on_practices": [{"introduction": "任何表面张力模型的一个基本测试是其正确处理静态、对称界面的能力。本实践将引导您验证连续介质表面力（CSF）模型在三维球形液滴情况下的表现，理论上该液滴所受的合力应为零 [@problem_id:3368723]。通过实现CSF力的体积分并将其与解析结果进行比较，您将获得关于完整数值计算流程的实践经验，并理解导致非物理“寄生”力的离散化误差。", "problem": "您的任务是通过计算体积积分得到的合表面力，并与解析结果进行比较，来验证球形液滴的连续介质表面力（Continuum Surface Force, CSF）模型的自洽性。请在三维空间中进行计算，并采用均匀的笛卡尔网格。所有距离单位必须为米，表面张力单位为牛顿/米，力单位为牛顿。\n\n从动量的基本平衡定律和经过充分检验的界面建模事实出发，采用以下建模基础：\n- 平滑的颜色函数（体积分）场表示为 $\\,\\alpha(\\mathbf{x})\\,$，它是通过有向距离场 $\\,\\phi(\\mathbf{x})\\,$ 构造的，作为相间的单调过渡。\n- 单位法向量为 $\\,\\mathbf{n} = \\dfrac{\\nabla \\alpha}{\\lVert \\nabla \\alpha \\rVert}\\,$，其中 $\\,\\lVert \\cdot \\rVert\\,$ 是欧几里得范数。\n- 曲率为 $\\,\\kappa = -\\nabla \\cdot \\mathbf{n}\\,$。\n- 连续介质表面力（CSF）的体力密度为 $\\,\\mathbf{f}_\\sigma = \\sigma \\, \\kappa \\, \\nabla \\alpha\\,$，其中 $\\,\\sigma\\,$ 是表面张力系数。\n\n对于一个半径为 $\\,R\\,$、中心位于 $\\,\\mathbf{x}_c\\,$、处于其他方面均静止的流体中的球形液滴，其解析的合表面张力是在闭合界面 $\\,\\Gamma\\,$ 上的面积分 $\\,\\displaystyle \\int_{\\Gamma} \\sigma \\, \\kappa \\, \\mathbf{n} \\, \\mathrm{d}S\\,$。对于一个完美的球体，根据对称性和散度定理，这个解析合力等于 $\\,\\mathbf{0}\\,$。您的任务是计算弥散CSF模型预测的作为体积积分的合力，并验证其在考虑离散化因素的容差范围内与解析结果一致。\n\n数值规格：\n- 考虑一个立方体域 $\\,[-L,L]^3\\,$，用一个 $\\,N \\times N \\times N\\,$ 单元中心的均匀网格进行离散，网格间距为 $\\,\\Delta = \\dfrac{2L}{N}\\,$。\n- 定义有向距离场 $\\,\\phi(\\mathbf{x}) = \\lVert \\mathbf{x} - \\mathbf{x}_c \\rVert - R\\,$ 和平滑颜色函数\n  $$\\alpha(\\mathbf{x}) = \\tfrac{1}{2}\\Big(1 - \\tanh\\Big(\\dfrac{\\phi(\\mathbf{x})}{\\sqrt{2}\\,\\varepsilon}\\Big)\\Big),$$\n  其中 $\\,\\varepsilon\\,$ 是弥散界面厚度参数。\n- 使用二阶中心差分来近似空间导数，并使用黎曼和来近似合力\n  $$\\mathbf{F}_\\mathrm{CSF} \\approx \\sum_{i,j,k} \\sigma \\, \\kappa_{i,j,k} \\, \\nabla \\alpha_{i,j,k}\\, \\Delta^3,$$\n  其中 $\\,\\kappa_{i,j,k}\\,$ 和 $\\,\\nabla \\alpha_{i,j,k}\\,$ 是网格单元 $\\,\\{i,j,k\\}\\,$ 处的离散曲率和梯度。\n\n验证指标和容差：\n- 解析合力的大小为 $\\,\\lVert \\mathbf{F}_\\mathrm{analytic} \\rVert = 0\\,\\mathrm{N}\\,$。\n- 令 $\\,A = 4\\pi R^2\\,$ 为液滴表面积。定义绝对容差\n  $$\\mathrm{tol} = C \\,\\sigma \\, A \\, \\dfrac{\\Delta}{\\max(\\varepsilon,\\,\\Delta)},$$\n  其中 $\\,C\\,$ 是一个用户指定的无量纲常数，在此次验证中设为 $\\,C=1\\,$。\n- 如果 $\\,\\lVert \\mathbf{F}_\\mathrm{CSF} \\rVert \\le \\mathrm{tol}\\,$，则声明测试通过。\n\n测试套件：\n为以下情况实现计算。在每种情况下，报告一个布尔值，指示测试是否根据上述标准通过。\n\n- 情况 $\\,1\\,$（理想情况，居中液滴）：\n  - $\\,N = 48\\,$, $\\,L = 0.01\\,\\mathrm{m}\\,$, $\\,R = 0.004\\,\\mathrm{m}\\,$, $\\,\\sigma = 0.072\\,\\mathrm{N/m}\\,$,\n    $\\,\\varepsilon = 2.0\\,\\Delta\\,$, $\\,\\mathbf{x}_c = (0,0,0)\\,\\mathrm{m}\\,$。\n- 情况 $\\,2\\,$（加密网格，偏心液滴）：\n  - $\\,N = 64\\,$, $\\,L = 0.01\\,\\mathrm{m}\\,$, $\\,R = 0.006\\,\\mathrm{m}\\,$, $\\,\\sigma = 0.03\\,\\mathrm{N/m}\\,$,\n    $\\,\\varepsilon = 1.5\\,\\Delta\\,$, $\\,\\mathbf{x}_c = (1.1\\times 10^{-4},-7.0\\times 10^{-5},5.0\\times 10^{-5})\\,\\mathrm{m}\\,$。\n- 情况 $\\,3\\,$（更薄的界面）：\n  - $\\,N = 56\\,$, $\\,L = 0.01\\,\\mathrm{m}\\,$, $\\,R = 0.005\\,\\mathrm{m}\\,$, $\\,\\sigma = 0.0728\\,\\mathrm{N/m}\\,$,\n    $\\,\\varepsilon = 1.0\\,\\Delta\\,$, $\\,\\mathbf{x}_c = (0,0,0)\\,\\mathrm{m}\\,$。\n- 情况 $\\,4\\,$（更小的液滴，粗网格，偏心）：\n  - $\\,N = 40\\,$, $\\,L = 0.01\\,\\mathrm{m}\\,$, $\\,R = 0.003\\,\\mathrm{m}\\,$, $\\,\\sigma = 0.05\\,\\mathrm{N/m}\\,$,\n    $\\,\\varepsilon = 1.0\\,\\Delta\\,$, $\\,\\mathbf{x}_c = (2.0\\times 10^{-4},2.0\\times 10^{-4},-1.0\\times 10^{-4})\\,\\mathrm{m}\\,$。\n\n程序要求：\n- 您的程序必须如上所述计算每种情况下的 $\\,\\mathbf{F}_\\mathrm{CSF}\\,$，计算 $\\,\\mathrm{tol}\\,$，并为每种情况输出一个布尔值，指示是否满足 $\\,\\lVert \\mathbf{F}_\\mathrm{CSF} \\rVert \\le \\mathrm{tol}\\,$。\n- 最终输出格式：单行包含一个方括号括起来的逗号分隔的布尔值列表，例如 $\\,\\texttt{[True,False,True,True]}\\,$。仅生成这样一行输出，无其他内容。", "solution": "该问题要求验证连续介质表面力（CSF）模型的一致性。CSF模型是多相计算流体动力学的基石。验证方法是测试一个基本物理原理：在静止流体中，闭合的对称界面上所受的合力必须为零。任何由数值模型计算出的非零力都是一种离散化伪影，通常被称为伪力或寄生力。本任务是计算一个球形液滴的这种数值力，并验证其大小在考虑到已知离散误差源的指定容差范围内。\n\n解决方案通过执行指定的数值算法来推进。每个测试用例的过程如下：\n\n1.  **域离散化与网格生成**\n    一个 $[-L, L]^3$ 的立方体计算域被离散化为一个 $N \\times N \\times N$ 的均匀笛卡尔网格。在所有三个维度上，网格间距是恒定的，由 $\\Delta = \\frac{2L}{N}$ 给出。计算点位于网格中心。对于索引为 $i, j, k$（从 $0$到 $N-1$）的网格，其网格中心的坐标由下式给出：\n    $$ x_i = -L + (i + 0.5)\\Delta $$\n    $$ y_j = -L + (j + 0.5)\\Delta $$\n    $$ z_k = -L + (k + 0.5)\\Delta $$\n    这些坐标用于在离散网格上定义所有物理场。\n\n2.  **标量场计算**\n    两种流体之间的界面由一个平滑的标量场表示，即体积分或颜色函数 $\\alpha(\\mathbf{x})$。该场由有向距离函数 $\\phi(\\mathbf{x})$ 构造而成，该函数给出从点 $\\mathbf{x}$ 到界面的最短距离，其符号表示该点是在液滴内部还是外部。对于一个半径为 $R$、中心在 $\\mathbf{x}_c = (x_c, y_c, z_c)$ 的球体，有向距离为：\n    $$ \\phi(\\mathbf{x}) = \\lVert \\mathbf{x} - \\mathbf{x}_c \\rVert - R = \\sqrt{(x-x_c)^2 + (y-y_c)^2 + (z-z_c)^2} - R $$\n    然后，颜色函数 $\\alpha(\\mathbf{x})$ 被定义为一个从 $1$（液滴内部，$\\phi  0$）到 $0$（外部，$\\phi > 0$）的平滑过渡：\n    $$ \\alpha(\\mathbf{x}) = \\tfrac{1}{2}\\Big(1 - \\tanh\\Big(\\dfrac{\\phi(\\mathbf{x})}{\\sqrt{2}\\,\\varepsilon}\\Big)\\Big) $$\n    这里，$\\varepsilon$ 是一个控制弥散界面厚度的参数。这些函数 $\\phi$ 和 $\\alpha$ 在每个网格点 $(x_i, y_j, z_k)$ 上进行求值。\n\n3.  **颜色函数的梯度 ($\\nabla \\alpha$)**\n    CSF模型需要颜色函数的梯度 $\\nabla \\alpha$。这个向量场在内部点使用二阶中心差分进行数值计算。对于边界点，一种常用且稳健的做法是使用二阶单边差分。此过程被封装在标准的数值库函数中，例如 `numpy.gradient`，本任务将使用该函数。在每个网格点 $(i,j,k)$ 处的梯度为：\n    $$ \\nabla \\alpha_{i,j,k} \\approx \\left( \\frac{\\alpha_{i+1,j,k} - \\alpha_{i-1,j,k}}{2\\Delta}, \\frac{\\alpha_{i,j+1,k} - \\alpha_{i,j-1,k}}{2\\Delta}, \\frac{\\alpha_{i,j,k+1} - \\alpha_{i,j,k-1}}{2\\Delta} \\right) $$\n    该梯度仅在弥散界面区域内非零，从而正确定位了表面张力效应。\n\n4.  **单位法向量 ($\\mathbf{n}$)**\n    界面的单位法向量从液相指向气相，并由 $\\alpha$ 的梯度定义：\n    $$ \\mathbf{n} = \\frac{\\nabla \\alpha}{\\lVert \\nabla \\alpha \\rVert} $$\n    在数值上，为了防止在 $\\nabla \\alpha = \\mathbf{0}$ 的区域（即远离界面的区域）发生除零错误，可在分母上添加一个小的正则化参数。然而，由于最终的力密度 $\\mathbf{f}_\\sigma$ 与 $\\nabla \\alpha$ 成正比，这种正则化对最终的力计算没有影响，因为在 $\\nabla \\alpha$ 为零的任何地方，力也为零。\n\n5.  **曲率计算 ($\\kappa$)**\n    界面曲率 $\\kappa$ 由单位法向量场的负散度给出：\n    $$ \\kappa = -\\nabla \\cdot \\mathbf{n} = -\\left( \\frac{\\partial n_x}{\\partial x} + \\frac{\\partial n_y}{\\partial y} + \\frac{\\partial n_z}{\\partial z} \\right) $$\n    与梯度计算类似，散度是使用二阶有限差分进行数值计算的。对法向量的每个分量，沿相应坐标轴计算其偏导数，然后将结果相加。\n\n6.  **合力积分 ($\\mathbf{F}_\\mathrm{CSF}$)**\n    CSF模型用一个连续的体力密度 $\\mathbf{f}_\\sigma$ 来近似作用在界面 $\\Gamma$ 上的奇异表面张力，该力作用于弥散界面区域的有限体积上：\n    $$ \\mathbf{f}_\\sigma = \\sigma \\, \\kappa \\, \\nabla \\alpha $$\n    其中 $\\sigma$ 是表面张力系数。作用在液滴上的总合力 $\\mathbf{F}_\\mathrm{CSF}$ 是该力密度在整个域上的体积积分。该积分通过对所有网格单元的黎曼和来近似：\n    $$ \\mathbf{F}_\\mathrm{CSF} = \\int_{V} \\mathbf{f}_\\sigma \\, dV \\approx \\sum_{i,j,k} \\mathbf{f}_{\\sigma, i,j,k} \\, \\Delta V = \\sum_{i,j,k} (\\sigma \\, \\kappa_{i,j,k} \\, \\nabla \\alpha_{i,j,k}) \\, \\Delta^3 $$\n    对力向量的每个分量分别执行求和。\n\n7.  **与容差的验证**\n    解析上，作用在液滴上的合力为 $\\mathbf{F}_\\mathrm{analytic} = \\mathbf{0}$。由于离散误差，数值计算出的力 $\\mathbf{F}_\\mathrm{CSF}$ 将不为零。将这个数值力的大小 $\\lVert \\mathbf{F}_\\mathrm{CSF} \\rVert$ 与预定义的容差 $\\mathrm{tol}$ 进行比较。如果 $\\lVert \\mathbf{F}_\\mathrm{CSF} \\rVert \\le \\mathrm{tol}$，则测试通过。容差定义为：\n    $$ \\mathrm{tol} = C \\,\\sigma \\, A \\, \\frac{\\Delta}{\\max(\\varepsilon, \\Delta)} $$\n    其中 $C=1$ 是一个无量纲常数，$A=4\\pi R^2$ 是液滴的表面积。这种容差结构正确地反映了数值误差会随着界面更尖锐（更小的 $\\varepsilon/\\Delta$）而增加，并随着网格加密（更小的 $\\Delta$）而减小的预期。\n\n通过为每个提供的测试用例执行这些步骤，我们可以系统地验证CSF实现的一致性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the verification for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path, centered droplet)\n        {'N': 48, 'L': 0.01, 'R': 0.004, 'sigma': 0.072, 'eps_factor': 2.0, 'x_c': (0.0, 0.0, 0.0)},\n        # Case 2 (refined grid, off-centered droplet)\n        {'N': 64, 'L': 0.01, 'R': 0.006, 'sigma': 0.03, 'eps_factor': 1.5, 'x_c': (1.1e-4, -7.0e-5, 5.0e-5)},\n        # Case 3 (thinner interface)\n        {'N': 56, 'L': 0.01, 'R': 0.005, 'sigma': 0.0728, 'eps_factor': 1.0, 'x_c': (0.0, 0.0, 0.0)},\n        # Case 4 (smaller droplet, coarser grid, off-centered)\n        {'N': 40, 'L': 0.01, 'R': 0.003, 'sigma': 0.05, 'eps_factor': 1.0, 'x_c': (2.0e-4, 2.0e-4, -1.0e-4)},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        passed = run_case(**case_params)\n        results.append(passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_case(N, L, R, sigma, eps_factor, x_c):\n    \"\"\"\n    Computes the net CSF force for a single case and checks against the tolerance.\n\n    Args:\n        N (int): Number of grid cells along one dimension.\n        L (float): Half-length of the cubic domain [-L, L]^3.\n        R (float): Radius of the spherical droplet.\n        sigma (float): Surface tension coefficient.\n        eps_factor (float): Factor to determine interface thickness, eps = eps_factor * Delta.\n        x_c (tuple): Center of the droplet (x_c, y_c, z_c).\n\n    Returns:\n        bool: True if the test passes (||F_CSF|| = tol), False otherwise.\n    \"\"\"\n    # 1. Grid and Field Generation\n    Delta = 2.0 * L / N\n    epsilon = eps_factor * Delta\n    \n    # Create grid coordinates for cell centers\n    grid_coords_1d = np.linspace(-L + Delta / 2.0, L - Delta / 2.0, N)\n    x, y, z = np.meshgrid(grid_coords_1d, grid_coords_1d, grid_coords_1d, indexing='ij')\n\n    # Compute signed distance field (phi)\n    phi = np.sqrt((x - x_c[0])**2 + (y - x_c[1])**2 + (z - x_c[2])**2) - R\n\n    # Compute color function (alpha)\n    alpha = 0.5 * (1.0 - np.tanh(phi / (np.sqrt(2.0) * epsilon)))\n\n    # 2. Gradient of the Color Function (nabla alpha)\n    # np.gradient uses 2nd-order central differences for interior points\n    # and 2nd-order one-sided differences for boundary points.\n    # The 'ij' indexing ensures axis 0 is x, 1 is y, 2 is z.\n    grad_alpha = np.gradient(alpha, Delta)\n    grad_alpha_x, grad_alpha_y, grad_alpha_z = grad_alpha[0], grad_alpha[1], grad_alpha[2]\n\n    # 3. Unit Normal Vector (n)\n    norm_grad_alpha = np.sqrt(grad_alpha_x**2 + grad_alpha_y**2 + grad_alpha_z**2)\n    \n    # Regularization to avoid division by zero\n    reg_term = 1e-20\n    \n    n_x = grad_alpha_x / (norm_grad_alpha + reg_term)\n    n_y = grad_alpha_y / (norm_grad_alpha + reg_term)\n    n_z = grad_alpha_z / (norm_grad_alpha + reg_term)\n\n    # 4. Curvature Calculation (kappa)\n    # kappa = -nabla . n\n    # Use axis argument for efficiency to compute derivatives only along the required axes.\n    div_n = (np.gradient(n_x, Delta, axis=0) +\n             np.gradient(n_y, Delta, axis=1) +\n             np.gradient(n_z, Delta, axis=2))\n    \n    kappa = -div_n\n\n    # 5. Net Force Integration (F_CSF)\n    # f_sigma = sigma * kappa * nabla alpha\n    f_sigma_x = sigma * kappa * grad_alpha_x\n    f_sigma_y = sigma * kappa * grad_alpha_y\n    f_sigma_z = sigma * kappa * grad_alpha_z\n\n    # Integrate over the volume by summing and multiplying by cell volume\n    dV = Delta**3\n    F_csf_x = np.sum(f_sigma_x) * dV\n    F_csf_y = np.sum(f_sigma_y) * dV\n    F_csf_z = np.sum(f_sigma_z) * dV\n    \n    F_csf = np.array([F_csf_x, F_csf_y, F_csf_z])\n    F_csf_magnitude = np.linalg.norm(F_csf)\n\n    # 6. Verification Against Tolerance\n    C = 1.0\n    A = 4.0 * np.pi * R**2\n    tol = C * sigma * A * Delta / max(epsilon, Delta)\n\n    return F_csf_magnitude = tol\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3368723"}, {"introduction": "在实际模拟中，计算网格通常并非完全均匀，而是存在拉伸和各向异性。本练习将深入探讨网格的各向异性如何影响CSF模型的准确性，特别是界面曲率的计算 [@problem_id:3368626]。您将量化各向异性网格上的曲率方向误差，并将这种数值不准确性与所产生的寄生流大小联系起来，从而深刻理解网格质量与模拟保真度之间的相互作用。", "problem": "你需要量化在二维各向异性笛卡尔网格上圆形界面的曲率离散误差，并估算在静态液滴中由连续表面力 (CSF) 模型引起的伪速度尺度。你的推导和实现必须从以下基础出发：\n\n- 不可压缩动量平衡（Navier–Stokes 方程的一种形式），其中表面张力被建模为体力：$$\\rho \\frac{D \\mathbf{u}}{D t} = -\\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\rho \\mathbf{g} + \\mathbf{f}_{s},$$ 其中 $\\rho$ 是密度，$\\mathbf{u}$ 是速度， $p$ 是压力，$\\mu$ 是动力粘度，$\\mathbf{g}$ 是重力加速度，$\\mathbf{f}_{s}$ 是通过连续表面力 (CSF) 方法建模的表面张力密度。\n- 通过一个光滑的类有符号距离函数 $\\phi(\\mathbf{x})$ 对界面进行水平集表示，单位法向量为 $\\mathbf{n} = \\nabla \\phi / \\lVert \\nabla \\phi \\rVert$，曲率为 $$\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert} \\right)。$$\n- 处于静止状态的静态液滴在稳态下满足粘性力与表面张力之间的平衡；由 CSF 体力中的曲率离散误差 $\\delta \\kappa$ 引起的任何残余数值不平衡都会产生寄生速度（“伪电流”）。\n\n您的任务：\n\n- 基于上述基础，在间距为 $\\Delta x \\neq \\Delta y$ 的矩形网格上，为 $\\phi$ 的梯度、单位法向量和散度推导一个一致的二阶中心差分离散格式，从而在网格节点上得到离散曲率 $\\kappa_{h}$。除了网格本身的对称性外，不要假设任何特定的对称性。你的推导必须在逻辑上与 $\\kappa = \\nabla \\cdot \\mathbf{n}$ 以及各向异性网格上的中心差分相一致，但不应依赖于这些原则之外的任何预先给定的离散模板。\n- 设界面为一个半径为 $R$、中心位于 $(x_{c}, y_{c})$ 的圆，由解析水平集 $$\\phi(x,y) = \\sqrt{(x - x_{c})^{2} + (y - y_{c})^{2}} - R$$ 表示。界面上的精确曲率为常数，等于 $1/R$。使用间距 $\\Delta x$ 和 $\\Delta y$ 在方形域 $[-L,L] \\times [-L,L]$（其中 $L = 3R$）上构建一个有限网格，在网格节点上计算 $\\phi$，计算离散曲率场 $\\kappa_{h}$，然后通过对节点 $\\kappa_{h}$ 值进行双线性插值，计算位于角度 $\\theta \\in \\{0, \\pi/6, \\pi/4, \\pi/3, \\pi/2\\}$（角度以弧度为单位）的精确界面点 $(x(\\theta), y(\\theta)) = (x_{c} + R \\cos \\theta, y_{c} + R \\sin \\theta)$ 上的曲率。\n- 定义方向性曲率误差 $e(\\theta) = \\kappa_{h}^{\\mathrm{interp}}(\\theta) - 1/R$。由此计算以下标量诊断量：\n  - 平均绝对误差 $$E_{\\mathrm{mean}} = \\frac{1}{N_{\\theta}} \\sum_{\\theta} \\left| e(\\theta) \\right|,$$ 其中 $N_{\\theta} = 5$。\n  - 最大绝对误差 $$E_{\\max} = \\max_{\\theta} \\left| e(\\theta) \\right|。$$\n  - 方向性各向异性度量 $$E_{\\mathrm{ani}} = \\max_{\\theta} \\kappa_{h}^{\\mathrm{interp}}(\\theta) - \\min_{\\theta} \\kappa_{h}^{\\mathrm{interp}}(\\theta)。$$\n- 使用由动量方程引出的稳态 Stokes 平衡，按如下方式估算伪电流的尺度。在 CSF 模型中，表面张力密度的大小可表示为 $|\\mathbf{f}_{s}| \\sim \\sigma \\, |\\delta \\kappa| \\, \\delta_{\\varepsilon}$，其中 $\\sigma$ 是表面张力，$\\delta_{\\varepsilon}$ 是一个集中在厚度为 $\\varepsilon$ 的界面层中的平滑狄拉克-德尔塔函数。将平滑德尔塔函数的大小建模为 $C/\\varepsilon$，其中 $C$ 是一个 $\\mathcal{O}(1)$ 的常数，并选择 $\\varepsilon = 1.5 \\max(\\Delta x, \\Delta y)$。在尺度 $L \\sim R$ 上，用粘性扩散来平衡此残余强迫项，以获得伪速度估计 $$U_{\\mathrm{spur}} \\approx \\frac{\\sigma \\, E_{\\max}}{\\varepsilon} \\frac{R^{2}}{\\mu}。$$\n- 实现一个程序来对下方的测试套件执行这些计算。除非另有说明，所有测试用例均使用以下固定参数：液滴中心为 $(x_{c}, y_{c}) = (0, 0)$，忽略重力，且稳态估计中不涉及密度。\n- 单位：所有物理量必须采用国际单位制 (SI)。曲率和曲率误差以 $\\mathrm{m}^{-1}$ 为单位报告，伪速度以 $\\mathrm{m\\,s}^{-1}$ 为单位报告。\n- 角度单位：弧度。\n\n测试套件（每个元组列出 $(R, \\Delta x, \\Delta y, \\sigma, \\mu)$）：\n\n- 案例 A（理想路径，各向同性）：$(0.5, 0.01, 0.01, 0.072, 0.001)$。\n- 案例 B（中度各向异性）：$(0.5, 0.01, 0.02, 0.072, 0.001)$。\n- 案例 C（强各向异性）：$(0.5, 0.005, 0.02, 0.072, 0.001)$。\n- 案例 D（粗糙，各向异性）：$(0.3, 0.05, 0.08, 0.072, 0.001)$。\n\n您的程序应生成单行输出，其中包含所有案例的结果，形式为列表的列表，每个内部列表对应一个案例，并按 $[E_{\\mathrm{mean}}, E_{\\max}, E_{\\mathrm{ani}}, U_{\\mathrm{spur}}]$ 的顺序排列。所有数字必须以浮点值的科学记数法打印，小数点后精确到六位。例如，最终输出格式必须类似于\n$[[a_{1},a_{2},a_{3},a_{4}],[b_{1},b_{2},b_{3},b_{4}],[c_{1},c_{2},c_{3},c_{4}],[d_{1},d_{2},d_{3},d_{4}]]$\n除了列表格式的标准空格外，不应有额外的空格，也不应有附加文本。\n\n约束和说明：\n\n- 您必须仅使用与各向异性间距一致的中心差分（用于内部节点）和合理的单边差分（用于边界）来实现曲率计算。\n- 使用离散曲率场的双线性插值来计算精确圆形界面点上的 $\\kappa_{h}$。\n- 使用上述 $\\varepsilon$ 的定义和稳态 Stokes 平衡来计算 $U_{\\mathrm{spur}}$。\n- 所有结果均以 SI 单位表示，并采用指定的数值格式，四舍五入到小数点后恰好 $6$ 位。", "solution": "我们从将表面张力作为体力处理的不可压缩动量平衡方程开始，$$\\rho \\frac{D \\mathbf{u}}{D t} = -\\nabla p + \\mu \\nabla^{2} \\mathbf{u} + \\rho \\mathbf{g} + \\mathbf{f}_{s}。$$对于一个静止的液滴，我们有 $\\mathbf{u} = \\mathbf{0}$，因此惯性项和瞬态项消失，方程简化为压力梯度、粘性力和表面张力体力之间的平衡。在理想的连续介质设定中，如果液滴处于平衡状态，粘性应力会消失，跨界面的压力跳跃与表面张力相平衡。在连续表面力 (CSF) 方法中，表面张力体力写为 $$\\mathbf{f}_{s} = \\sigma \\kappa \\mathbf{n} \\, \\delta_{\\Gamma},$$ 其中 $\\sigma$ 是表面张力系数，$\\kappa$ 是曲率，$\\mathbf{n}$ 是界面的单位法向量，$\\delta_{\\Gamma}$ 是一个支集在界面上的分布。在离散计算中，$\\delta_{\\Gamma}$ 由一个具有特征厚度 $\\varepsilon$ 的平滑分布 $\\delta_{\\varepsilon}$ 表示。\n\n我们通过水平集函数 $\\phi(\\mathbf{x})$ 隐式地表示界面，其单位法向量为 $$\\mathbf{n} = \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert},$$ 曲率定义为 $$\\kappa = \\nabla \\cdot \\mathbf{n} = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert} \\right)。$$ 对于一个半径为 $R$、中心位于 $(x_{c}, y_{c})$ 的圆，其解析水平集 $$\\phi(x,y) = \\sqrt{(x - x_{c})^{2} + (y - y_{c})^{2}} - R$$ 在界面 $\\phi = 0$ 上精确地得到 $\\kappa = 1/R$。\n\n在间距为 $\\Delta x$ 和 $\\Delta y$ 的矩形网格上，我们使用中心差分来离散化空间导数。设 $\\phi_{i,j}$ 表示网格节点 $(x_{i}, y_{j})$ 处的 $\\phi$。那么，离散梯度分量近似为 $$\\left(\\partial_{x} \\phi \\right)_{i,j} \\approx \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2 \\Delta x}, \\quad \\left(\\partial_{y} \\phi \\right)_{i,j} \\approx \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2 \\Delta y},$$ 用于内部节点，在边界处使用单边差分。梯度大小为 $\\lVert \\nabla \\phi \\rVert_{i,j} \\approx \\sqrt{ \\left( \\left(\\partial_{x} \\phi \\right)_{i,j} \\right)^{2} + \\left( \\left(\\partial_{y} \\phi \\right)_{i,j} \\right)^{2} }$，离散单位法向量分量为 $$n^{x}_{i,j} = \\frac{ \\left(\\partial_{x} \\phi \\right)_{i,j} }{ \\lVert \\nabla \\phi \\rVert_{i,j} + \\eta }, \\quad n^{y}_{i,j} = \\frac{ \\left(\\partial_{y} \\phi \\right)_{i,j} }{ \\lVert \\nabla \\phi \\rVert_{i,j} + \\eta },$$ 其中 $\\eta$ 是一个小的正则化常数，以避免在远离界面处出现除以零的情况。节点上的离散曲率通过对散度进行中心差分得到，$$\\kappa_{i,j} \\approx \\frac{ n^{x}_{i+1,j} - n^{x}_{i-1,j} }{ 2 \\Delta x } + \\frac{ n^{y}_{i,j+1} - n^{y}_{i,j-1} }{ 2 \\Delta y },$$ 同样，在边界处使用适当的单边差分。对于光滑的 $\\phi$，当 $\\Delta x$ 和 $\\Delta y$ 可能不同时，此构造与 $\\kappa = \\nabla \\cdot \\mathbf{n}$ 一致，并且在内部节点上具有二阶精度。\n\n为量化方向性误差，我们考虑由 $$\\left( x(\\theta), y(\\theta) \\right) = \\left( x_{c} + R \\cos \\theta, \\, y_{c} + R \\sin \\theta \\right), \\quad \\theta \\in \\{ 0, \\, \\pi/6, \\, \\pi/4, \\, \\pi/3, \\, \\pi/2 \\},$$ 参数化的精确圆形界面，并通过节点值的双线性插值来计算这些点上的离散曲率场 $\\kappa_{h}$。将插值得到的值表示为 $\\kappa_{h}^{\\mathrm{interp}}(\\theta)$。方向性曲率误差为 $$e(\\theta) = \\kappa_{h}^{\\mathrm{interp}}(\\theta) - \\frac{1}{R}。$$ 我们从这些样本中计算三个标量诊断量： $$E_{\\mathrm{mean}} = \\frac{1}{N_{\\theta}} \\sum_{\\theta} \\left| e(\\theta) \\right|, \\quad E_{\\max} = \\max_{\\theta} \\left| e(\\theta) \\right|, \\quad E_{\\mathrm{ani}} = \\max_{\\theta} \\kappa_{h}^{\\mathrm{interp}}(\\theta) - \\min_{\\theta} \\kappa_{h}^{\\mathrm{interp}}(\\theta),$$ 其中 $N_{\\theta} = 5$。\n\n为估算由 CSF 项中的曲率误差引起的伪速度尺度，我们注意到残余 CSF 强迫项的大小可表示为 $|\\mathbf{f}_{\\mathrm{res}}| \\sim \\sigma \\, |\\delta \\kappa| \\, \\delta_{\\varepsilon}$，其中 $|\\delta \\kappa|$ 是一个特征曲率误差，$\\delta_{\\varepsilon}$ 是正则化的界面德尔塔函数。将平滑德尔塔函数建模为在厚度为 $\\varepsilon$ 的层上其大小约为 $\\sim 1/\\varepsilon$，我们取 $\\varepsilon = 1.5 \\max(\\Delta x, \\Delta y)$。在长度尺度 $L \\sim R$ 的稳态 Stokes 平衡中，$$\\mu \\frac{U_{\\mathrm{spur}}}{L^{2}} \\sim \\sigma \\frac{ |\\delta \\kappa| }{ \\varepsilon },$$ 因此 $$U_{\\mathrm{spur}} \\approx \\frac{ \\sigma \\, |\\delta \\kappa| }{ \\varepsilon } \\frac{ R^{2} }{ \\mu }。$$ 我们选择 $|\\delta \\kappa| = E_{\\max}$ 作为残余曲率误差的保守度量。此估计遵循量纲一致性：$[\\sigma] = \\mathrm{N\\,m}^{-1}$，$[\\delta \\kappa] = \\mathrm{m}^{-1}$，$[\\varepsilon] = \\mathrm{m}$，$[R^{2}] = \\mathrm{m}^{2}$，$[\\mu] = \\mathrm{Pa\\,s} = \\mathrm{N\\,s\\,m}^{-2}$，得到 $[U_{\\mathrm{spur}}] = \\mathrm{m\\,s}^{-1}$。\n\n程序实现的算法步骤：\n\n- 对于每个测试用例 $(R, \\Delta x, \\Delta y, \\sigma, \\mu)$，设置方形域半尺寸 $L = 3R$。构建一维网格 $x_{i} = -L + i \\Delta x$ 和 $y_{j} = -L + j \\Delta y$，其中 $i = 0, \\dots, N_{x}$ 且 $j = 0, \\dots, N_{y}$，使得端点覆盖 $[-L, L]$（如果最后一个点与步长对齐，则包含该点）。\n- 在网格上计算 $\\phi_{i,j} = \\sqrt{ (x_{i} - x_{c})^{2} + (y_{j} - y_{c})^{2} } - R$，其中 $(x_{c}, y_{c}) = (0, 0)$。\n- 通过内部节点的中心差分和边界的单边差分计算离散梯度 $\\partial_{x} \\phi$ 和 $\\partial_{y} \\phi$。在分母中使用一个小的正则化项 $\\eta$ 来形成离散单位法向量 $\\mathbf{n}$，以避免在远离界面处出现除以零的情况。\n- 使用中心差分（以及边界处的单边差分）计算 $\\mathbf{n}$ 的散度，得到离散曲率场 $\\kappa_{h}$。\n- 对于 $\\theta \\in \\{ 0, \\pi/6, \\pi/4, \\pi/3, \\pi/2 \\}$，计算 $(x(\\theta), y(\\theta))$，然后将 $\\kappa_{h}$ 双线性插值到这些坐标以获得 $\\kappa_{h}^{\\mathrm{interp}}(\\theta)$。\n- 计算 $e(\\theta)$、$E_{\\mathrm{mean}}$、$E_{\\max}$ 和 $E_{\\mathrm{ani}}$；使用 $\\varepsilon = 1.5 \\max(\\Delta x, \\Delta y)$ 估算 $U_{\\mathrm{spur}}$，即 $$U_{\\mathrm{spur}} = \\frac{ \\sigma E_{\\max} }{ \\varepsilon } \\frac{ R^{2} }{ \\mu }。$$\n- 对于每个案例，将列表 $[E_{\\mathrm{mean}}, E_{\\max}, E_{\\mathrm{ani}}, U_{\\mathrm{spur}}]$ 在单行中输出，聚合所有案例，每个数字均以科学记数法格式化，小数点后精确到 $6$ 位，并以正确的 SI 单位表示：前三项为 $\\mathrm{m}^{-1}$，最后一项为 $\\mathrm{m\\,s}^{-1}$。\n\n此构造将基本定义 $\\kappa = \\nabla \\cdot \\left( \\nabla \\phi / \\lVert \\nabla \\phi \\rVert \\right)$ 和 CSF 体力与各向异性网格上的具体有限差分算法联系起来，并使用稳态 Stokes 标度分析来量化方向性曲率误差如何转化为伪速度的大小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef central_diff_x(f, dx):\n    \"\"\"Central differences in x with first-order one-sided at boundaries.\"\"\"\n    d = np.empty_like(f)\n    d[1:-1, :] = (f[2:, :] - f[:-2, :]) / (2.0 * dx)\n    d[0, :] = (f[1, :] - f[0, :]) / dx\n    d[-1, :] = (f[-1, :] - f[-2, :]) / dx\n    return d\n\ndef central_diff_y(f, dy):\n    \"\"\"Central differences in y with first-order one-sided at boundaries.\"\"\"\n    d = np.empty_like(f)\n    d[:, 1:-1] = (f[:, 2:] - f[:, :-2]) / (2.0 * dy)\n    d[:, 0] = (f[:, 1] - f[:, 0]) / dy\n    d[:, -1] = (f[:, -1] - f[:, -2]) / dy\n    return d\n\ndef curvature_from_levelset(phi, dx, dy, eta=1e-14):\n    \"\"\"\n    Compute discrete curvature kappa = div( grad(phi)/|grad(phi)| )\n    using central differences on an anisotropic grid.\n    \"\"\"\n    # Gradients\n    dphidx = central_diff_x(phi, dx)\n    dphidy = central_diff_y(phi, dy)\n    grad_norm = np.sqrt(dphidx**2 + dphidy**2) + eta\n\n    nx = dphidx / grad_norm\n    ny = dphidy / grad_norm\n\n    dnxdx = central_diff_x(nx, dx)\n    dnydy = central_diff_y(ny, dy)\n\n    kappa = dnxdx + dnydy\n    return kappa\n\ndef bilinear_interpolate(xp, yp, x, y, F):\n    \"\"\"\n    Bilinear interpolation of field F defined on grid (x,y) at point (xp, yp).\n    x: 1D array of x-coordinates, length Nx\n    y: 1D array of y-coordinates, length Ny\n    F: 2D array shape (Nx, Ny)\n    \"\"\"\n    # Ensure xp, yp are within grid bounds\n    if xp = x[0]:\n        i0 = 0\n    elif xp >= x[-1]:\n        i0 = len(x) - 2\n    else:\n        i0 = np.searchsorted(x, xp) - 1\n    i1 = i0 + 1\n\n    if yp = y[0]:\n        j0 = 0\n    elif yp >= y[-1]:\n        j0 = len(y) - 2\n    else:\n        j0 = np.searchsorted(y, yp) - 1\n    j1 = j0 + 1\n\n    x0, x1 = x[i0], x[i1]\n    y0, y1 = y[j0], y[j1]\n\n    # Prevent division by zero if degenerate (shouldn't happen with proper grids)\n    tx = 0.0 if x1 == x0 else (xp - x0) / (x1 - x0)\n    ty = 0.0 if y1 == y0 else (yp - y0) / (y1 - y0)\n\n    f00 = F[i0, j0]\n    f10 = F[i1, j0]\n    f01 = F[i0, j1]\n    f11 = F[i1, j1]\n\n    f0 = (1 - tx) * f00 + tx * f10\n    f1 = (1 - tx) * f01 + tx * f11\n    fp = (1 - ty) * f0 + ty * f1\n    return fp\n\ndef compute_case(R, dx, dy, sigma, mu, center=(0.0, 0.0)):\n    # Domain half-size\n    L = 3.0 * R\n    # Construct grids including endpoints when aligned\n    # Use arange to honor the spacings exactly\n    x = np.arange(-L, L + 0.5 * dx, dx)\n    y = np.arange(-L, L + 0.5 * dy, dy)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    xc, yc = center\n    phi = np.sqrt((X - xc)**2 + (Y - yc)**2) - R\n\n    kappa = curvature_from_levelset(phi, dx, dy, eta=1e-12)\n\n    # Interface angles in radians\n    angles = np.array([0.0, np.pi/6.0, np.pi/4.0, np.pi/3.0, np.pi/2.0])\n    # Interpolate kappa to exact interface points\n    kappa_samples = []\n    for th in angles:\n        xp = xc + R * np.cos(th)\n        yp = yc + R * np.sin(th)\n        kval = bilinear_interpolate(xp, yp, x, y, kappa)\n        kappa_samples.append(kval)\n    kappa_samples = np.array(kappa_samples)\n\n    kappa_exact = 1.0 / R\n    errors = kappa_samples - kappa_exact\n    E_mean = float(np.mean(np.abs(errors)))\n    E_max = float(np.max(np.abs(errors)))\n    E_ani = float(np.max(kappa_samples) - np.min(kappa_samples))\n\n    # Spurious velocity estimate\n    eps = 1.5 * max(dx, dy)\n    U_spur = sigma * E_max / eps * (R**2) / mu\n\n    return E_mean, E_max, E_ani, U_spur\n\ndef format_number(x):\n    # Scientific notation with exactly six digits after decimal\n    return f\"{x:.6e}\"\n\ndef solve():\n    # Define the test cases from the problem statement: (R, dx, dy, sigma, mu)\n    test_cases = [\n        (0.5, 0.01, 0.01, 0.072, 0.001),  # Case A\n        (0.5, 0.01, 0.02, 0.072, 0.001),  # Case B\n        (0.5, 0.005, 0.02, 0.072, 0.001), # Case C\n        (0.3, 0.05, 0.08, 0.072, 0.001),  # Case D\n    ]\n\n    results = []\n    for R, dx, dy, sigma, mu in test_cases:\n        E_mean, E_max, E_ani, U_spur = compute_case(R, dx, dy, sigma, mu, center=(0.0, 0.0))\n        results.append([E_mean, E_max, E_ani, U_spur])\n\n    # Build the exact required format: list of lists with each number formatted\n    formatted_rows = []\n    for row in results:\n        formatted = \"[\" + \",\".join(format_number(v) for v in row) + \"]\"\n        formatted_rows.append(formatted)\n    output = \"[\" + \",\".join(formatted_rows) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3368626"}, {"introduction": "在模拟表面张力与重力等其他体力共存的系统时，一个关键挑战是如何在不产生伪流的情况下维持流体静力学平衡。这需要一种能够精确抵消离散作用力的“良态平衡”（well-balanced）数值格式。本实践专注于在1D系统中推导并实现这样一种格式，确保离散的压力梯度能够精确平衡重力与CSF力的综合效应 [@problem_id:3368717]。", "problem": "考虑一个在均匀重力场下处于静力平衡状态的两相、不可压缩、无粘性流体系统。零速度下的控制动量平衡方程简化为压力梯度、重力以及由连续介质表面力 (CSF) 模型所描述的毛细力之间的平衡。连续介质表面力 (CSF) 模型通过使用一个光滑指示函数，将表面张力模拟为集中在界面附近的体积力。本题的目标是推导并实现一个离散的、良态平衡的条件，该条件能在均匀的一维垂直网格上精确地保持包含表面张力的静水力学平衡。\n\n从稳态、不可压缩动量平衡出发，设垂直坐标为 $z$。平衡状态要求离散的压力梯度与重力以及 CSF 引起的毛细力相平衡。CSF 表示法使用一个光滑指示函数 $C(z)$，该函数在弥散界面上实现从一相到另一相的过渡，并假设球冠界面段的曲率 $ \\kappa $ 为常数。混合密度建模为 $\\rho(C) = \\rho_{\\mathrm{g}} + C \\left(\\rho_{\\mathrm{l}} - \\rho_{\\mathrm{g}}\\right)$，其中 $\\rho_{\\mathrm{l}}$ 是液体密度，$\\rho_{\\mathrm{g}}$ 是气体密度，重力加速度 $g$ 作用于 $z$ 轴正方向。必须从控制体上的积分动量平衡的第一性原理出发推导良态平衡条件，并将其表示在均匀网格上，使得在面上进行一致性计算的离散压力梯度与由重力和毛细作用引起的相应离散面源项相平衡。\n\n您的任务是：\n- 在垂直方向 $z \\in [0,H]$、高度为 $H$、包含 $N$ 个点的均匀网格上，推导一个面上一致的离散平衡关系，使得面上的离散压力梯度与重力和毛细 CSF 的离散面贡献相平衡，从而确保在静水力学平衡中达到精确平衡（在浮点舍入误差范围内）。\n- 实现推导出的离散关系，以根据给定参数和一个代表恒定曲率 $ \\kappa $ 弯曲界面的指定弥散指示函数 $C(z)$，计算离散压力场 $p(z)$。\n- 对指示函数 $C(z)$ 使用以 $z_0$ 为中心、界面厚度参数为 $\\varepsilon$ 的双曲正切剖面：$C(z) = \\tfrac{1}{2}\\left[1 + \\tanh\\left((z - z_0)/(\\sqrt{2}\\,\\varepsilon)\\right)\\right]$。曲率 $ \\kappa $ 被视为常数，CSF 的垂直分量由 $C(z)$ 的垂直梯度引起。\n- 对于每个测试用例，计算两个量化指标：\n    1. 整个网格上离散垂直动量平衡的最大绝对残差 $R_{\\max}$，单位为 $\\mathrm{N/m^3}$。\n    2. 绝对毛细压力跳跃误差 $E_{\\mathrm{jump}}$，计算为在整个区域上积分的离散毛细贡献与理论跳跃值 $ \\sigma \\kappa $ 之间的绝对差，单位为 $\\mathrm{Pa}$。\n- 将 $R_{\\max}$ 以 $\\mathrm{N/m^3}$ 为单位、将 $E_{\\mathrm{jump}}$ 以 $\\mathrm{Pa}$ 为单位表示，两者均为浮点数。\n\n测试套件使用以下科学上一致的参数值，其中包括有重力作用的附着滴和悬滴，以及两个边界情况：\n\n- 区域高度 $H = 0.01\\,\\mathrm{m}$，网格点数 $N = 200$，界面厚度 $\\varepsilon = 2\\times 10^{-4}\\,\\mathrm{m}$，液体密度 $\\rho_{\\mathrm{l}} = 1000\\,\\mathrm{kg/m^3}$，气体密度 $\\rho_{\\mathrm{g}} = 1\\,\\mathrm{kg/m^3}$，表面张力系数 $\\sigma$ 和曲率 $\\kappa$ 根据每个用例指定，重力加速度大小 $g$ 根据每个用例指定。\n- 指示函数 $C(z)$ 根据每个用例在 $z_0$ 处居中。\n\n测试套件：\n1. 附着滴：$z_0 = 0.003\\,\\mathrm{m}$，$\\sigma = 0.072\\,\\mathrm{N/m}$，$\\kappa = 2000\\,\\mathrm{m^{-1}}$，$g = 9.81\\,\\mathrm{m/s^2}$。\n2. 悬滴：$z_0 = 0.007\\,\\mathrm{m}$，$\\sigma = 0.072\\,\\mathrm{N/m}$，$\\kappa = 2000\\,\\mathrm{m^{-1}}$，$g = 9.81\\,\\mathrm{m/s^2}$。\n3. 零重力边界情况：$z_0 = 0.005\\,\\mathrm{m}$，$\\sigma = 0.072\\,\\mathrm{N/m}$，$\\kappa = 2000\\,\\mathrm{m^{-1}}$，$g = 0.0\\,\\mathrm{m/s^2}$。\n4. 零表面张力边界情况：$z_0 = 0.005\\,\\mathrm{m}$，$\\sigma = 0.0\\,\\mathrm{N/m}$，$\\kappa = 2000\\,\\mathrm{m^{-1}}$，$g = 9.81\\,\\mathrm{m/s^2}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[R_{\\max}^{(1)},E_{\\mathrm{jump}}^{(1)},R_{\\max}^{(2)},E_{\\mathrm{jump}}^{(2)},R_{\\max}^{(3)},E_{\\mathrm{jump}}^{(3)},R_{\\max}^{(4)},E_{\\mathrm{jump}}^{(4)}]$，其中上标表示测试用例编号。例如，输出应类似于 $[r_1,e_1,r_2,e_2,r_3,e_3,r_4,e_4]$。", "solution": "本问题的分析和求解基于多相流体系统中的静水力学平衡原理，其中压力梯度由体积力（即重力和表面张力）平衡。表面张力使用连续介质表面力 (CSF) 方法建模，该方法将其表示为作用在界面附近的连续体积力。一个良态平衡的数值格式是指在离散层面上能精确维持这种平衡，从而防止产生如非物理速度等虚假数值效应的格式。\n\n### 良态平衡条件的推导\n\n问题始于垂直 $z$ 方向上的一维稳态、不可压缩、无粘性动量方程。在静力平衡（$\\mathbf{v}=0$）时，压力梯度与体积力平衡：\n$$\n\\frac{dp}{dz} = F_z\n$$\n其中 $F_z$ 是体积力密度的总垂直分量。所考虑的体积力是重力和表面张力。\n\n重力体积力密度为 $\\rho \\mathbf{g}$。问题指定了一个在 $z$ 轴正方向上作用的均匀重力加速度 $g$，因此 $\\mathbf{g} = g \\hat{\\mathbf{z}}$。重力密度力的垂直分量因此为 $\\rho(z) g$。密度 $\\rho(z)$ 是指示函数 $C(z)$ 的函数，由混合模型给出：\n$$\n\\rho(C) = \\rho_{\\mathrm{g}} + C (\\rho_{\\mathrm{l}} - \\rho_{\\mathrm{g}})\n$$\n其中 $\\rho_{\\mathrm{l}}$ 和 $\\rho_{\\mathrm{g}}$ 分别是液体和气体密度。\n\n表面张力使用 CSF 公式建模，表示为体积力 $\\mathbf{f}_{\\text{CSF}} = \\sigma \\kappa \\nabla C$，其中 $\\sigma$ 是表面张力系数，$\\kappa$ 是界面曲率（假设为常数），$C$ 是光滑指示函数。该力密度的垂直分量是：\n$$\nf_{\\text{CSF}, z} = \\sigma \\kappa \\frac{dC}{dz}\n$$\n结合这些力，$z$ 方向上的总力密度为 $F_z = \\rho(C(z)) g + \\sigma \\kappa \\frac{dC}{dz}$。因此，一维静水力学平衡方程为：\n$$\n\\frac{dp}{dz} = g \\left( \\rho_{\\mathrm{g}} + C(z) (\\rho_{\\mathrm{l}} - \\rho_{\\mathrm{g}}) \\right) + \\sigma \\kappa \\frac{dC}{dz}\n$$\n为了推导一个良态平衡格式，我们可以通过将构成全微分的项组合在一起来重排这个方程。我们可以将 $\\sigma \\kappa \\frac{dC}{dz}$ 写成 $\\frac{d}{dz}(\\sigma \\kappa C)$。这使我们可以将方程重写为：\n$$\n\\frac{dp}{dz} - \\frac{d}{dz}(\\sigma \\kappa C) = g \\rho(C(z))\n$$\n$$\n\\frac{d}{dz} \\left( p - \\sigma \\kappa C \\right) = g \\rho(C(z))\n$$\n这种形式对于数值积分非常有利。我们定义一个修正压力 $p^*(z) = p(z) - \\sigma \\kappa C(z)$。方程简化为 $\\frac{dp^*}{dz} = g \\rho(C(z))$。\n\n现在我们可以将这个方程从一个参考位置（比如 $z=0$）积分到一个任意位置 $z$：\n$$\n\\int_0^z \\frac{dp^*}{dz'} dz' = \\int_0^z g \\rho(C(z')) dz'\n$$\n$$\np^*(z) - p^*(0) = g \\int_0^z \\rho(C(z')) dz'\n$$\n代回 $p(z)$ 和 $p(0)$：\n$$\n(p(z) - \\sigma \\kappa C(z)) - (p(0) - \\sigma \\kappa C(0)) = g \\int_0^z \\rho(C(z')) dz'\n$$\n解出 $p(z)$ 得到静水压力场：\n$$\np(z) = p(0) + \\sigma \\kappa (C(z) - C(0)) + g \\int_0^z \\rho(C(z')) dz'\n$$\n通过设置一个参考压力（例如 $p(0)=0$），我们可以通过数值计算该积分来计算任意点 $z$ 的压力。\n\n### 离散实现\n\n我们使用 $N$ 个均匀间隔的点 $z_j = j \\Delta z$（其中 $j=0, 1, \\dots, N-1$）来离散化区域 $z \\in [0, H]$，网格间距为 $\\Delta z = H / (N-1)$。每个点 $j$ 处的离散压力记为 $p_j = p(z_j)$。\n\n压力场 $p_j$ 是通过离散化解析解来计算的。为了获得高精度，积分项使用累积梯形法则进行近似。设 $G(z) = g \\int_0^z \\rho(C(z')) dz'$。那么其离散对应项 $G_j = G(z_j)$ 可以递归计算：\n$$\nG_0 = 0\n$$\n$$\nG_j = G_{j-1} + g \\int_{z_{j-1}}^{z_j} \\rho(C(z')) dz' \\approx G_{j-1} + g \\frac{\\rho(C_{j-1}) + \\rho(C_j)}{2} \\Delta z \\quad \\text{for } j \\ge 1\n$$\n其中 $C_j = C(z_j)$ 且 $\\rho_j = \\rho(C_j)$。那么，当参考压力 $p_0=0$ 时，离散压力场为：\n$$\np_j = \\sigma \\kappa (C_j - C_0) + G_j\n$$\n这种构建压力场的方法内在地满足了静水力学平衡方程的积分形式，并构成了我们良态平衡格式的基础。\n\n### 指标计算\n\n**1. 最大绝对残差 ($R_{\\max}$)**\n\n残差用于衡量计算出的压力场在多大程度上满足原始微分方程 $\\frac{dp}{dz} = F_z$ 的离散形式。在交错网格（压力位于单元中心 $j, j+1$，梯度/通量位于面 $j+1/2$）上，一个面上一致的有限差分近似为：\n$$\n\\left( \\frac{\\delta p}{\\delta z} \\right)_{j+1/2} = (\\text{Source Term})_{j+1/2}\n$$\n面 $j+1/2$ 上的压力梯度自然地近似为 $\\frac{p_{j+1} - p_j}{\\Delta z}$。源项通过对重力项的单元中心值取平均，并对 CSF 项使用差分，在面上进行一致性计算：\n$$\n\\frac{p_{j+1} - p_j}{\\Delta z} = g \\frac{\\rho_j + \\rho_{j+1}}{2} + \\sigma \\kappa \\frac{C_{j+1} - C_j}{\\Delta z}\n$$\n每个内部面 $j+1/2$ (对于 $j=0, \\dots, N-2$) 上的离散残差为：\n$$\nR_{j+1/2} = \\left(\\frac{p_{j+1} - p_j}{\\Delta z}\\right) - \\left(g \\frac{\\rho_j + \\rho_{j+1}}{2} + \\sigma \\kappa \\frac{C_{j+1} - C_j}{\\Delta z}\\right)\n$$\n通过代入从良态平衡构造中推导出的 $p_j$ 表达式，我们发现：\n$$\np_{j+1} - p_j = \\left( \\sigma\\kappa(C_{j+1}-C_0) + G_{j+1} \\right) - \\left( \\sigma\\kappa(C_j-C_0) + G_j \\right) = \\sigma\\kappa(C_{j+1}-C_j) + (G_{j+1}-G_j)\n$$\n根据 $G_j$ 的梯形法则定义，我们有 $G_{j+1}-G_j = g \\frac{\\rho_j + \\rho_{j+1}}{2} \\Delta z$。将其代入：\n$$\np_{j+1} - p_j = \\sigma\\kappa(C_{j+1}-C_j) + g \\frac{\\rho_j + \\rho_{j+1}}{2} \\Delta z\n$$\n两边同除以 $\\Delta z$ 表明，这与离散动量平衡是完全相同的。因此，残差 $R_{j+1/2}$ 在解析上为零，仅由于浮点舍入误差而不为零。我们计算 $R_{\\max} = \\max_{j} |R_{j+1/2}|$。\n\n**2. 绝对毛细压力跳跃误差 ($E_{\\mathrm{jump}}$)**\n\n由表面张力引起的跨界面理论压力跳跃由 Young-Laplace 方程给出，即 $\\Delta p = \\sigma \\kappa$。CSF 模型对此进行了近似。跨区域由 CSF 力引起的总压力变为 $\\int_0^H f_{\\text{CSF},z} dz = \\int_0^H \\sigma \\kappa \\frac{dC}{dz} dz$。\n\n问题要求“在整个区域上积分的离散毛细贡献”。这可以通过对区域内基于面的离散 CSF 力密度 $F_{\\text{CSF}, j+1/2} = \\sigma \\kappa \\frac{C_{j+1}-C_j}{\\Delta z}$ 求和，再乘以网格间距 $\\Delta z$ 来计算：\n$$\n\\Delta P_{\\text{cap, discrete}} = \\sum_{j=0}^{N-2} \\left( \\sigma \\kappa \\frac{C_{j+1} - C_j}{\\Delta z} \\right) \\Delta z = \\sigma \\kappa \\sum_{j=0}^{N-2} (C_{j+1} - C_j)\n$$\n这是一个可以简化为以下形式的伸缩求和：\n$$\n\\Delta P_{\\text{cap, discrete}} = \\sigma \\kappa (C_{N-1} - C_0)\n$$\n误差 $E_{\\mathrm{jump}}$ 是此离散积分值与理论跳跃值 $\\sigma \\kappa$ 之间的绝对差：\n$$\nE_{\\mathrm{jump}} = |\\Delta P_{\\text{cap, discrete}} - \\sigma \\kappa| = |\\sigma \\kappa (C_{N-1} - C_0) - \\sigma \\kappa| = \\sigma \\kappa |C_{N-1} - C_0 - 1|\n$$\n这个误差的产生是因为有限域 $[0, H]$ 并未跨越从 $-\\infty$ 到 $+\\infty$，所以 $C(z=0)$ 不完全是 $0$ 并且 $C(z=H)$ 不完全是 $1$。该误差的大小取决于边界处的指示函数值与其渐近极限的接近程度。\n指示函数由下式给出：\n$$\nC(z) = \\frac{1}{2}\\left[1 + \\tanh\\left(\\frac{z - z_0}{\\sqrt{2}\\,\\varepsilon}\\right)\\right]\n$$\n在每个测试用例中，将针对指定的参数在每个网格点 $z_j$ 上计算此函数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a discrete, well-balanced condition for hydrostatic\n    equilibrium with surface tension on a 1D vertical grid.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    H = 0.01  # Domain height [m]\n    N = 200   # Number of grid points\n    eps = 2e-4  # Interfacial thickness parameter [m]\n    rho_l = 1000.0  # Liquid density [kg/m^3]\n    rho_g = 1.0  # Gas density [kg/m^3]\n\n    # --- Test Suite ---\n    test_cases = [\n        # (z0 [m], sigma [N/m], kappa [m^-1], g [m/s^2])\n        (0.003, 0.072, 2000.0, 9.81),  # 1. Sessile drop\n        (0.007, 0.072, 2000.0, 9.81),  # 2. Pendant drop\n        (0.005, 0.072, 2000.0, 0.0),   # 3. Zero gravity\n        (0.005, 0.0,   2000.0, 9.81),   # 4. Zero surface tension\n    ]\n\n    results = []\n\n    # --- Grid Setup ---\n    z = np.linspace(0, H, N)\n    delta_z = H / (N - 1)\n\n    # --- Helper Function for Indicator C(z) ---\n    def indicator_function(z, z0, epsilon):\n        arg = (z - z0) / (np.sqrt(2.0) * epsilon)\n        return 0.5 * (1.0 + np.tanh(arg))\n\n    for z0, sigma, kappa, g in test_cases:\n        # --- 1. Compute Base Quantities ---\n        C = indicator_function(z, z0, eps)\n        rho = rho_g + C * (rho_l - rho_g)\n\n        # --- 2. Compute Hydrostatic Pressure Field (Well-Balanced) ---\n        # Compute gravitational potential pressure term G using cumulative trapezoidal rule\n        # G[j] = integral from 0 to z_j of (g * rho(z')) dz'\n        G = np.zeros(N)\n        integrand_g = g * rho\n        # G[j+1] = G[j] + g * (rho[j]+rho[j+1])/2 * delta_z\n        G[1:] = np.cumsum(g * (rho[:-1] + rho[1:]) / 2.0 * delta_z)\n\n        # Compute pressure field p with reference p(0)=0\n        # p[j] = p[0] + sigma*kappa*(C[j]-C[0]) + G[j]\n        # p[0] is reference pressure, let p[0] = 0.\n        # However, the calculation of p[0] itself requires G[0], which is 0.\n        # So p[0] = sigma*kappa*(C[0]-C[0]) + G[0] = 0.\n        # The choice of p_ref=0 is implicitly made here.\n        p = sigma * kappa * (C - C[0]) + G\n\n        # --- 3. Calculate Maximum Absolute Residual (R_max) ---\n        # Residual R at face j+1/2:\n        # R = (p[j+1]-p[j])/dz - (g*(rho[j]+rho[j+1])/2 + sigma*k*(C[j+1]-C[j])/dz)\n        # This will be calculated for all N-1 faces.\n        grad_p_discrete = (p[1:] - p[:-1]) / delta_z\n        source_g_discrete = g * (rho[:-1] + rho[1:]) / 2.0\n        source_csf_discrete = sigma * kappa * (C[1:] - C[:-1]) / delta_z\n\n        residuals = grad_p_discrete - (source_g_discrete + source_csf_discrete)\n        R_max = np.max(np.abs(residuals))\n        results.append(R_max)\n\n        # --- 4. Calculate Absolute Capillary Pressure-Jump Error (E_jump) ---\n        # Theoretical jump (infinite domain) is sigma * kappa\n        theoretical_jump = sigma * kappa\n\n        # Discrete integrated jump (over finite domain [0, H])\n        # sum_{j=0}^{N-2} (sigma*k*(C[j+1]-C[j])/dz) * dz\n        # = sigma * kappa * (C[N-1] - C[0])\n        discrete_jump = sigma * kappa * (C[-1] - C[0])\n\n        E_jump = np.abs(discrete_jump - theoretical_jump)\n        results.append(E_jump)\n\n    # --- Final Output Formatting ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3368717"}]}