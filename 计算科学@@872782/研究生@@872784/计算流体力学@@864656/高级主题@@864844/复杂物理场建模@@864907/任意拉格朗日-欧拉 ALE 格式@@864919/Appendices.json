{"hands_on_practices": [{"introduction": "在处理复杂的流固耦合问题之前，掌握网格运动的运动学至关重要。第一个练习聚焦于一个简单的“呼吸”区域上的几何守恒律 (Geometric Conservation Law, GCL)，为推导和验证这一关键原理的解析与离散形式提供了一个基础性练习 [@problem_id:3345113]。通过对一个离散时间积分器进行检验，您将直接洞察一个数值格式在何种意义上是几何守恒的。", "problem": "考虑一个从计算坐标 $(\\xi,\\eta)$ 到物理坐标 $(x,y)$ 的二维含时坐标变换，其定义为 $x(\\xi,t)=\\xi\\left(1+\\alpha\\sin(\\omega t)\\right)$ 和 $y(\\eta,t)=\\eta$，其中 $\\alpha$ 是一个无量纲呼吸振幅，$\\omega$ 是一个角频率，$t$ 是时间。角频率 $\\omega$ 的单位是弧度/秒，所有角度都必须以弧度为单位进行解释。时间 $t$ 的单位是秒。该变换的雅可比行列式，记为 $J(\\xi,\\eta,t)$，定义为 $J=\\det\\left(\\partial(x,y)/\\partial(\\xi,\\eta)\\right)$。在任意拉格朗日-欧拉 (ALE) 格式中，几何守恒律 (GCL) 将 $J$ 的时间变化率与网格运动联系起来，并确保当进行一致离散化时，均匀场在网格变形下得以保持。\n\n仅从雅可比行列式的定义和标准微积分（链式法则和行列式性质）出发，执行以下任务：\n\n1. 对给定的映射，推导 $J(\\xi,\\eta,t)$ 及其时间导数 $\\partial_t J(\\xi,\\eta,t)$。以 $\\text{s}^{-1}$ 为单位表示 $\\partial_t J$。\n2. 将物理 $x$ 方向的网格速度定义为在 $(\\xi,\\eta)$ 固定时的 $u_g(\\xi,t)=\\partial_t x(\\xi,t)$。使用第一性原理，计算 $\\partial_\\xi u_g(\\xi,t)$ 并将其与 $\\partial_t J(\\xi,\\eta,t)$ 联系起来，从而验证连续 GCL 恒等式。\n3. 考虑从时间 $t^n$ 开始，在单个时间步长 $\\Delta t$ 上对雅可比行列式进行的显式中点时间积分：\n   $$J^{n+1}\\approx J^n + \\Delta t\\,\\left(\\partial_t J\\right)\\big|_{t^{n+\\frac{1}{2}}},\\quad t^{n+\\frac{1}{2}}=t^n+\\frac{\\Delta t}{2}。$$\n   将离散 GCL 残差 $R$ 定义为\n   $$R=J(t^n+\\Delta t)-J(t^n)-\\Delta t\\,\\left(\\partial_t J\\right)\\big|_{t^{n+\\frac{1}{2}}}。$$\n   当 $|R|\\le \\varepsilon$ 时，对于给定的容差 $\\varepsilon$，判定为离散 GCL 通过。\n4. 评估均匀初始状态下压力中的混叠效应。假设压力是均匀的，等于 $p_0$（单位为帕斯卡）。在一个在 $\\xi\\in[0,1]$ 上有 $N$ 个点且 $\\eta$ 为任意值（变换与 $\\eta$ 无关）的均匀计算网格上，使用网格节点上的有限差分来评估 $\\partial_\\xi u_g$ 的逐点离散近似。定义一个混叠度量\n   $$A=\\max_{i}\\left|p_0\\left(\\left[\\partial_\\xi u_g\\right]_{\\text{discrete}}(\\xi_i,t^n)-\\left[\\partial_\\xi u_g\\right]_{\\text{analytic}}(t^n)\\right)\\right|,$$\n   其单位必须是 $\\text{Pa}/\\text{s}$。将 $A$ 解释为当真实场是均匀时，由于节点上离散度量评估而产生的伪压力产生的幅度。\n\n您的程序必须为以下参数集测试套件计算这些量，每个参数集指定为 $(\\alpha,\\omega,t^n,\\Delta t,p_0,N)$：\n\n- 测试 1 (边界/无呼吸): $(0.0,\\,2\\pi,\\,0.0,\\,0.1,\\,101325,\\,33)$。\n- 测试 2 (正常路径/小步长): $(0.1,\\,2\\pi,\\,0.3,\\,0.001,\\,101325,\\,33)$。\n- 测试 3 (大变形/大步长): $(0.8,\\,2\\pi,\\,0.0,\\,0.2,\\,101325,\\,33)$。\n- 测试 4 (高频/小步长): $(0.1,\\,20\\pi,\\,0.01,\\,0.0001,\\,101325,\\,33)$。\n\n使用容差 $\\varepsilon=10^{-8}$ 的显式中点法则残差 $R$ 来确定离散 GCL 通过条件。对于每个测试用例，您的程序必须按以下顺序输出：\n- 在 $t^n$ 处的 $\\partial_t J$ 的解析值，单位为 $\\text{s}^{-1}$。\n- 中点残差 $R$ (无量纲)。\n- 使用 $\\varepsilon=10^{-8}$ 的离散 GCL 通过测试的布尔结果。\n- 混叠度量 $A$，单位为 $\\text{Pa}/\\text{s}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，四个测试用例的结果按上述顺序连接。例如，输出应如下所示：\n$[dJdt_1,R_1,\\text{pass}_1,A_1,dJdt_2,R_2,\\text{pass}_2,A_2,dJdt_3,R_3,\\text{pass}_3,A_3,dJdt_4,R_4,\\text{pass}_4,A_4]$,\n其中 $dJdt_i$ 的单位是 $\\text{s}^{-1}$，$R_i$ 是无量纲的，$\\text{pass}_i$ 是一个布尔值，$A_i$ 的单位是 $\\text{Pa}/\\text{s}$。", "solution": "问题陈述已经过验证，被认为是合理的、自洽的且适定的。推导和解答如下所示，遵循科学正确性和逻辑一致性的原则。\n\n分析从所提供的从计算坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的二维含时坐标变换开始：\n$$ x(\\xi,t) = \\xi \\left(1 + \\alpha \\sin(\\omega t)\\right) $$\n$$ y(\\eta,t) = \\eta $$\n此处，$\\alpha$ 是无量纲呼吸振幅，$\\omega$ 是角频率，单位为 $\\text{rad}/\\text{s}$，$t$ 是时间，单位为 $\\text{s}$。\n\n**1. 雅可比行列式及其时间导数的推导**\n\n变换的雅可比矩阵定义为 $\\mathbf{J}_{\\text{matrix}} = \\frac{\\partial(x,y)}{\\partial(\\xi,\\eta)}$。其分量是物理坐标相对于计算坐标的偏导数：\n$$ \\partial_\\xi x = \\frac{\\partial}{\\partial\\xi} \\left[ \\xi \\left(1 + \\alpha \\sin(\\omega t)\\right) \\right] = 1 + \\alpha \\sin(\\omega t) $$\n$$ \\partial_\\eta x = \\frac{\\partial}{\\partial\\eta} \\left[ \\xi \\left(1 + \\alpha \\sin(\\omega t)\\right) \\right] = 0 $$\n$$ \\partial_\\xi y = \\frac{\\partial}{\\partial\\xi} [\\eta] = 0 $$\n$$ \\partial_\\eta y = \\frac{\\partial}{\\partial\\eta} [\\eta] = 1 $$\n\n因此，雅可比矩阵为：\n$$ \\mathbf{J}_{\\text{matrix}} = \\begin{pmatrix} \\partial_\\xi x  \\partial_\\eta x \\\\ \\partial_\\xi y  \\partial_\\eta y \\end{pmatrix} = \\begin{pmatrix} 1 + \\alpha \\sin(\\omega t)  0 \\\\ 0  1 \\end{pmatrix} $$\n\n雅可比行列式 $J$ 是该矩阵的行列式：\n$$ J(\\xi, \\eta, t) = \\det(\\mathbf{J}_{\\text{matrix}}) = \\left(1 + \\alpha \\sin(\\omega t)\\right)(1) - (0)(0) = 1 + \\alpha \\sin(\\omega t) $$\n注意，对于这个特定的变换，雅可比行列式 $J$ 仅是时间 $t$ 的函数，即 $J = J(t)$。\n\n雅可比行列式的时间导数 $\\partial_t J$ 通过对 $J(t)$ 关于 $t$ 求导得到：\n$$ \\partial_t J(t) = \\frac{\\partial}{\\partial t} \\left[ 1 + \\alpha \\sin(\\omega t) \\right] = \\alpha \\omega \\cos(\\omega t) $$\n$\\alpha$ 的单位是无量纲，$\\omega$ 的单位是 $\\text{s}^{-1}$，$\\cos(\\omega t)$ 是无量纲的。因此，$\\partial_t J$ 的单位是 $\\text{s}^{-1}$，符合要求。\n\n**2. 连续几何守恒律 (GCL) 恒等式的验证**\n\n物理 $x$ 方向上的网格速度定义为在计算坐标 $\\xi$ 固定时的 $u_g(\\xi,t) = \\partial_t x(\\xi,t)$。\n$$ u_g(\\xi,t) = \\frac{\\partial}{\\partial t} \\left[ \\xi \\left(1 + \\alpha \\sin(\\omega t)\\right) \\right] = \\xi \\alpha \\omega \\cos(\\omega t) $$\n问题要求计算 $\\partial_\\xi u_g(\\xi,t)$ 并将其与 $\\partial_t J(t)$ 联系起来。对 $u_g$ 关于 $\\xi$ 求导：\n$$ \\partial_\\xi u_g(\\xi,t) = \\frac{\\partial}{\\partial \\xi} \\left[ \\xi \\alpha \\omega \\cos(\\omega t) \\right] = \\alpha \\omega \\cos(\\omega t) $$\n将此结果与上一步中 $\\partial_t J(t)$ 的表达式进行比较，我们发现：\n$$ \\partial_t J(t) = \\partial_\\xi u_g(\\xi,t) $$\n这验证了对于这种特殊的一维网格运动，连续 GCL 恒等式成立。该恒等式是一般多维 GCL $\\partial_t J = J (\\nabla_{\\mathbf{x}} \\cdot \\mathbf{u}_g)$ 的一个简化形式，此变换也满足该通用形式。\n\n**3. 离散 GCL 残差计算**\n\n问题定义了从 $t^n$ 到 $t^{n+1}$ 的一个时间步长 $\\Delta t$ 内，雅可比行列式变化的显式中点时间积分：\n$$ J^{n+1} \\approx J^n + \\Delta t\\,\\left(\\partial_t J\\right)\\big|_{t^{n+\\frac{1}{2}}} $$\n其中 $t^{n+\\frac{1}{2}} = t^n + \\frac{\\Delta t}{2}$。离散 GCL 残差 $R$ 衡量了此近似的误差：\n$$ R = J(t^n+\\Delta t) - J(t^n) - \\Delta t\\,\\left(\\partial_t J\\right)\\big|_{t^{n+\\frac{1}{2}}} $$\n代入推导出的 $J(t)$ 和 $\\partial_t J(t)$ 的表达式：\n$$ J(t^n+\\Delta t) = 1 + \\alpha \\sin(\\omega(t^n+\\Delta t)) $$\n$$ J(t^n) = 1 + \\alpha \\sin(\\omega t^n) $$\n$$ \\left(\\partial_t J\\right)\\big|_{t^{n+\\frac{1}{2}}} = \\alpha \\omega \\cos(\\omega(t^n + \\Delta t/2)) $$\n因此，残差 $R$ 计算如下：\n$$ R = \\left[1 + \\alpha \\sin(\\omega(t^n+\\Delta t))\\right] - \\left[1 + \\alpha \\sin(\\omega t^n)\\right] - \\Delta t \\left[\\alpha \\omega \\cos(\\omega(t^n + \\Delta t/2))\\right] $$\n$$ R = \\alpha \\left[ \\sin(\\omega(t^n + \\Delta t)) - \\sin(\\omega t^n) \\right] - \\alpha \\omega \\Delta t \\cos(\\omega(t^n + \\Delta t/2)) $$\n将对每个测试用例评估此表达式。如果 $|R| \\le \\varepsilon = 10^{-8}$，则离散 GCL 通过。\n\n**4. 混叠度量评估**\n\n混叠度量 $A$ 定义为：\n$$ A = \\max_{i}\\left|p_0\\left(\\left[\\partial_\\xi u_g\\right]_{\\text{discrete}}(\\xi_i,t^n)-\\left[\\partial_\\xi u_g\\right]_{\\text{analytic}}(t^n)\\right)\\right| $$\n解析导数为 $\\left[\\partial_\\xi u_g\\right]_{\\text{analytic}} = \\alpha \\omega \\cos(\\omega t^n)$。\n\n离散近似是在 $\\xi \\in [0,1]$ 上的一个包含 $N$ 个点的均匀网格上执行的，网格点为 $\\xi_i = i/(N-1)$，其中 $i=0, \\dots, N-1$。待微分的函数 $u_g(\\xi,t^n) = \\xi \\alpha \\omega \\cos(\\omega t^n)$ 是 $\\xi$ 的一个线性函数。任何在均匀网格上的一致有限差分格式都将精确计算出线性函数的导数。\n\n例如，在 $\\xi_i$ 处使用一阶向前差分：\n$$ \\left[\\partial_\\xi u_g\\right]_{\\text{discrete}}(\\xi_i,t^n) = \\frac{u_g(\\xi_{i+1},t^n) - u_g(\\xi_i,t^n)}{\\Delta\\xi} = \\frac{(\\xi_i+\\Delta\\xi) - \\xi_i}{\\Delta\\xi} \\alpha \\omega \\cos(\\omega t^n) = \\alpha \\omega \\cos(\\omega t^n) $$\n在 $\\xi_i$ 处使用二阶中心差分：\n$$ \\left[\\partial_\\xi u_g\\right]_{\\text{discrete}}(\\xi_i,t^n) = \\frac{u_g(\\xi_{i+1},t^n) - u_g(\\xi_{i-1},t^n)}{2\\Delta\\xi} = \\frac{(\\xi_i+\\Delta\\xi) - (\\xi_i-\\Delta\\xi)}{2\\Delta\\xi} \\alpha \\omega \\cos(\\omega t^n) = \\alpha \\omega \\cos(\\omega t^n) $$\n在这两种情况下，实际上对于这个均匀网格上的任何一致有限差分格式，离散导数都与解析导数相同。\n$$ \\left[\\partial_\\xi u_g\\right]_{\\text{discrete}}(\\xi_i,t^n) = \\left[\\partial_\\xi u_g\\right]_{\\text{analytic}}(t^n) $$\n因此，在混叠度量定义中的差分项对于所有网格点 $\\xi_i$ 都恒等于零。\n$$ \\left[\\partial_\\xi u_g\\right]_{\\text{discrete}}(\\xi_i,t^n) - \\left[\\partial_\\xi u_g\\right]_{\\text{analytic}}(t^n) = 0 $$\n因此，对于所有测试用例，混叠度量 $A$ 在机器浮点精度范围内均为零。这表明对于这种简单的线性网格变换，不存在由度量项的离散化引起的伪压力产生项。\n$$ A = 0 $$\n\n程序将使用推导出的公式为每个测试用例计算四个所需的量：\n-   在 $t^n$ 处的 $\\partial_t J$：$\\alpha \\omega \\cos(\\omega t^n)$\n-   残差 $R$：$\\alpha \\left[ \\sin(\\omega(t^n + \\Delta t)) - \\sin(\\omega t^n) \\right] - \\alpha \\omega \\Delta t \\cos(\\omega(t^n + \\Delta t/2))$\n-   GCL 通过：$|R| \\le 10^{-8}$\n-   混叠度量 $A$：$0.0$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite, computing a set of quantities\n    related to the Geometric Conservation Law (GCL) for a 2D coordinate transformation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (alpha, omega, t_n, delta_t, p_0, N)\n    test_cases = [\n        (0.0, 2 * np.pi, 0.0, 0.1, 101325, 33),      # Test 1 (boundary/no breathing)\n        (0.1, 2 * np.pi, 0.3, 0.001, 101325, 33),    # Test 2 (happy path/small step)\n        (0.8, 2 * np.pi, 0.0, 0.2, 101325, 33),      # Test 3 (large deformation/large step)\n        (0.1, 20 * np.pi, 0.01, 0.0001, 101325, 33)   # Test 4 (high frequency/small step)\n    ]\n\n    # Tolerance for the discrete GCL pass condition\n    epsilon = 1e-8\n\n    all_results = []\n    for case in test_cases:\n        alpha, omega, t_n, delta_t, p_0, N = case\n\n        # 1. Calculate analytic value of dJ/dt at t^n\n        # dJ/dt = alpha * omega * cos(omega * t)\n        dJdt_analytic_at_tn = alpha * omega * np.cos(omega * t_n)\n\n        # 2. Calculate the midpoint residual R\n        # R = J(t^n + dt) - J(t^n) - dt * (dJ/dt)|_{t^n + dt/2}\n        # J(t) = 1 + alpha * sin(omega * t)\n        \n        t_n_plus_1 = t_n + delta_t\n        t_mid = t_n + delta_t / 2.0\n\n        J_n_plus_1 = 1.0 + alpha * np.sin(omega * t_n_plus_1)\n        J_n = 1.0 + alpha * np.sin(omega * t_n)\n        dJdt_mid = alpha * omega * np.cos(omega * t_mid)\n\n        residual_R = J_n_plus_1 - J_n - delta_t * dJdt_mid\n        \n        # 3. Determine the discrete GCL pass condition\n        gcl_pass = np.abs(residual_R) = epsilon\n\n        # 4. Calculate the aliasing measure A\n        # A = max_i |p0 * ([d(u_g)/d(xi)]_discrete - [d(u_g)/d(xi)]_analytic)|\n        # As derived in the solution, u_g is linear in xi, so any consistent finite\n        # difference approximation on a uniform grid is exact. Thus, the difference is\n        # analytically zero. The aliasing measure A is 0.0.\n        # We set it to 0.0 directly based on this analytical conclusion.\n        aliasing_A = 0.0\n\n        # For completeness, one could implement the numerical check which would yield a\n        # result of 0.0 or a value on the order of machine epsilon.\n        # xi_grid = np.linspace(0.0, 1.0, N)\n        # u_g_vals = xi_grid * alpha * omega * np.cos(omega * t_n)\n        # du_g_dxi_analytic = alpha * omega * np.cos(omega * t_n)\n        # dx_xi = 1.0 / (N - 1)\n        # du_g_dxi_discrete = np.gradient(u_g_vals, dx_xi)\n        # aliasing_A = np.max(np.abs(p_0 * (du_g_dxi_discrete - du_g_dxi_analytic)))\n\n        all_results.extend([dJdt_analytic_at_tn, residual_R, gcl_pass, aliasing_A])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3345113"}, {"introduction": "GCL 不仅仅是一个数学上的抽象概念；违反它会带来直接的物理后果。在这个练习中，我们将模拟一个简单的活塞-气缸系统，以展示在多步时间积分格式中未能执行 GCL 如何导致压力功的计算不正确，从而在最终的内能中产生显著误差 [@problem_id:3292269]。这个实践生动地揭示了几何一致性与能量等物理量守恒之间的联系。", "problem": "您必须为一个在一维活塞-气缸配置中的可压缩理想气体实现一个任意拉格朗日-欧拉 (ALE) 时间积分器，其中右侧活塞是移动的。左壁固定在位置 $x=0$ 处，右活塞的位置由 $x_p(t)=L(t)$ 指定。气体占据一个长度随时间变化为 $L(t)$、横截面积为 $1$ 的控制体，因此物理体积为 $V(t)=L(t)$。假设在所有时刻状态都是空间均匀的，并由控制体上的可压缩欧拉方程的积分形式所控制。\n\n基本原理：\n- 质量守恒：对于不透水壁面，控制体内的质量是守恒的。如果 $\\rho(t)$ 是密度， $J(t)=L(t)$ 是雅可比行列式（体积），则有 $\\rho(t) J(t)=\\rho_0 J_0$，其中 $\\rho_0=\\rho(0)$ 且 $J_0=J(0)$。\n- 动量守恒：在双壁压力相等且无净力的情况下，对于无净冲量的对称壁面，空间平均速度保持为零，即 $u(t)=0$，这与此处使用的均匀状态假设一致。\n- ALE形式下的总能量守恒：控制体 $[0,L(t)]$ 上的积分能量平衡给出\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\big(\\rho E\\,J\\big) \\;=\\; -\\big[u(\\rho E + p) - w\\,\\rho E\\big]\\big\\rvert_{x=L(t)} \\;+\\; \\big[u(\\rho E + p) - w\\,\\rho E\\big]\\big\\rvert_{x=0},\n$$\n其中 $E$ 是比总能，$p$ 是压力，$w$ 是网格（壁面）速度。在处处 $u=0$，固定壁面处 $w(0)=0$，移动壁面处 $w(L(t))=\\dot L(t)$ 的条件下，该方程简化为\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\big(\\rho E\\,J\\big) \\;=\\; -\\,\\dot L(t)\\,p(t).\n$$\n对于比热比为 $\\gamma$ 的理想气体，$E = e + \\tfrac{1}{2}u^2$ 且 $e = \\dfrac{p}{(\\gamma-1)\\rho}$。当 $u=0$ 时，单位质量内能（比内能）$e$ 满足\n$$\n\\frac{\\mathrm{d}e}{\\mathrm{d}t} \\;=\\; -(\\gamma-1)\\,\\frac{\\dot L(t)}{L(t)}\\,e.\n$$\n这个常微分方程有精确解\n$$\ne(t) \\;=\\; e_0 \\left(\\frac{L(t)}{L_0}\\right)^{-(\\gamma-1)},\n$$\n其中 $e_0 = \\dfrac{p_0}{(\\gamma-1)\\rho_0}$，$L_0=L(0)$，$p_0=p(0)$。\n\n几何守恒律 (GCL) 和时间积分：\n- 在ALE龙格-库塔 (RK) 方法中，在RK的中间步强制执行几何守恒律 (GCL) 意味着几何量（如 $J(t)$ 和 $w(t)=\\dot L(t)$）必须在每个子步时刻进行一致的评估。对于上述常微分方程，这对应于在每个子步时刻评估系数 $-(\\gamma-1)\\,\\dot L(t)/L(t)$。\n- 一个常见的违规做法是在中间子步中不执行GCL，方法是在时间步开始时冻结几何，即对于从时间 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的一个步长的所有子步，都使用 $\\dot L(t_n)/L(t_n)$。这会在压力功的时间积分中产生偏差，从而导致最终内能出现误差。\n\n您的任务：\n1. 使用三阶强稳定性保持龙格-库塔 (SSP-RK3) 方法，在 $t\\in[0,T]$ 上以恒定时间步长 $\\Delta t$ 为常微分方程\n$$\n\\frac{\\mathrm{d}e}{\\mathrm{d}t} \\;=\\; -(\\gamma-1)\\,\\frac{\\dot L(t)}{L(t)}\\,e,\n$$\n实现一个时间积分器。\n2. 实现右端项评估的两种变体：\n   - 在子步中强制执行GCL：在每个龙格-库塔子步时刻 $t_\\ast$ 时，评估 $\\dot L(t_\\ast)$ 和 $L(t_\\ast)$，并使用瞬时比率 $\\dot L(t_\\ast)/L(t_\\ast)$。\n   - 在中间子步中不执行GCL：对于从 $t_n$ 到 $t_{n+1}$ 的一个步长内的所有子步，通过使用 $\\dot L(t_n)/L(t_n)$ 在 $t_n$ 时刻冻结几何，而不管子步的时刻如何。\n3. 对于下面测试套件中的每个测试用例，计算最终单位质量内能 $e(T)$ 相对于精确解\n$$\ne_{\\text{exact}}(T) \\;=\\; e_0 \\left(\\frac{L(T)}{L_0}\\right)^{-(\\gamma-1)}.\n$$\n的绝对误差，单位为 $\\mathrm{J/kg}$。每个测试用例报告两个误差：首先是在子步中强制执行GCL时的误差，然后是在中间子步中不执行GCL时的误差。\n\n物理参数和单位：\n- 使用 $\\gamma=1.4$，$\\rho_0=1.0\\,\\mathrm{kg/m^3}$，$p_0=100000\\,\\mathrm{Pa}$，因此 $e_0=\\dfrac{p_0}{(\\gamma-1)\\rho_0}$，单位为 $\\mathrm{J/kg}$。\n- 所有长度单位为 $\\mathrm{m}$，时间单位为 $\\mathrm{s}$，速度单位为 $\\mathrm{m/s}$。\n- 要求的输出是单位质量内能的误差，单位为 $\\mathrm{J/kg}$。\n\n测试套件：\n- 测试 1（平滑单周期正弦运动，返回初始长度）：$L_0=1.0\\,\\mathrm{m}$，$L(t)=L_0 + A\\sin\\big(2\\pi t/T\\big)$，其中 $A=0.1\\,\\mathrm{m}$，$T=1.0\\,\\mathrm{s}$，$\\Delta t = 0.01\\,\\mathrm{s}$。精确的 $L(T)=L_0$ 意味着 $e_{\\text{exact}}(T)=e_0$。\n- 测试 2（单调线性压缩）：$L_0=1.0\\,\\mathrm{m}$，$L(t)=L_0 - \\alpha t$，在 $t\\in[0,T]$ 上，其中 $\\alpha=0.4\\,\\mathrm{m/s}$，$T=0.5\\,\\mathrm{s}$，因此 $L(T)=0.8\\,\\mathrm{m}$，$\\Delta t = 0.005\\,\\mathrm{s}$。\n- 测试 3（更快的多周期正弦波，返回初始长度）：$L_0=1.0\\,\\mathrm{m}$，$L(t)=L_0 + A\\sin\\big(4\\pi t\\big)$，其中 $A=0.05\\,\\mathrm{m}$，$T=1.0\\,\\mathrm{s}$，$\\Delta t = 0.01\\,\\mathrm{s}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表中的条目是浮点数，单位为 $\\mathrm{J/kg}$，顺序为\n$$\n[\\;\\text{err}_{\\text{GCL},1},\\;\\text{err}_{\\text{noGCL},1},\\;\\text{err}_{\\text{GCL},2},\\;\\text{err}_{\\text{noGCL},2},\\;\\text{err}_{\\text{GCL},3},\\;\\text{err}_{\\text{noGCL},3}\\;].\n$$\n每个 $\\text{err}$ 是绝对差 $|e_{\\text{num}}(T)-e_{\\text{exact}}(T)|$，单位为 $\\mathrm{J/kg}$。", "solution": "该问题要求为一个活塞-气缸装置中可压缩理想气体的简化模型实现一个一维任意拉格朗日-欧拉 (ALE) 时间积分器。该问题在物理上和数学上都有明确的定义，为数值求解提供了清晰的路径。我们将首先概述其理论基础，然后是数值实现策略。\n\n物理系统由一个长度为 $L(t)$、单位横截面积的控制体 $V(t)$ 中的气体组成。气体的状态（密度 $\\rho$、压力 $p$、比内能 $e$）在所有时刻都被假定为空间均匀的。对于该系统，在指定的边界条件下（左侧固定壁面处 $u(0)=0$、$w(0)=0$，右侧移动活塞处 $w(L(t)) = \\dot{L}(t)$），质量、动量和能量守恒定律得到显著简化。\n\n质量守恒，$\\rho(t) L(t) = \\rho_0 L_0$，其中 $\\rho_0 = \\rho(0)$ 且 $L_0 = L(0)$，表明控制体内的总质量是恒定的。均匀状态假设和对称边界驱动导致流体平均速度为零，即 $u(t)=0$。\n\n问题的核心在于总能量守恒。ALE 控制体的积分能量平衡简化为关于比内能 $e(t)$ 的一个常微分方程 (ODE)。起点是 ALE 能量方程：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\big(\\rho E J\\big) = -[u(\\rho E + p) - w \\rho E]\\big|_{x=L(t)} + [u(\\rho E + p) - w \\rho E]\\big|_{x=0}\n$$\n其中 $E$ 是比总能，$p$ 是压力，$J=L(t)$ 是体积（一维中的雅可比行列式），$w$ 是网格速度。给定 $u(t)=0$，$E=e$，$w(0)=0$ 和 $w(L(t)) = \\dot{L}(t)$，该方程简化为：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\big(\\rho e L\\big) = - p(t) \\dot{L}(t)\n$$\n由于总质量 $M = \\rho L$ 是恒定的，我们有 $M \\frac{\\mathrm{d}e}{\\mathrm{d}t} = -p(t) \\dot{L}(t)$。使用理想气体状态方程 $p = (\\gamma-1)\\rho e$ 并代入 $\\rho = M/L(t)$，我们得到控制常微分方程：\n$$\nM \\frac{\\mathrm{d}e}{\\mathrm{d}t} = -(\\gamma-1)\\frac{M}{L(t)}e(t) \\dot{L}(t) \\implies \\frac{\\mathrm{d}e}{\\mathrm{d}t} = -(\\gamma-1)\\frac{\\dot{L}(t)}{L(t)}e(t)\n$$\n这是一个一阶线性齐次常微分方程。对于给定的初始条件 $e(0)=e_0$，可以通过分离变量法找到精确解：\n$$\n\\int_{e_0}^{e(t)} \\frac{\\mathrm{d}e'}{e'} = -(\\gamma-1) \\int_{0}^{t} \\frac{\\dot{L}(\\tau)}{L(\\tau)} \\mathrm{d}\\tau \\implies \\ln\\left(\\frac{e(t)}{e_0}\\right) = -(\\gamma-1)\\ln\\left(\\frac{L(t)}{L_0}\\right)\n$$\n这给出了任意时刻 $t$ 的比内能的精确解：\n$$\ne(t) = e_0 \\left(\\frac{L(t)}{L_0}\\right)^{-(\\gamma-1)}\n$$\n初始比内能 $e_0$ 由初始条件计算得出，即 $e_0 = \\frac{p_0}{(\\gamma-1)\\rho_0}$。\n\n主要任务是使用三阶强稳定性保持龙格-库塔 (SSP-RK3) 方法对该常微分方程进行数值求解。该常微分方程的形式为 $\\frac{\\mathrm{d}e}{\\mathrm{d}t} = f(t, e)$，其中右端函数为 $f(t, e) = C(t) e(t)$，其系数 $C(t) = -(\\gamma-1)\\frac{\\dot{L}(t)}{L(t)}$ 随时间变化。\n从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的一个步长的 SSP-RK3 格式如下：\n\\begin{align*}\ne^{(1)} = e_n + \\Delta t \\, f(t_n, e_n) \\\\\ne^{(2)} = \\frac{3}{4} e_n + \\frac{1}{4} \\left( e^{(1)} + \\Delta t \\, f(t_n + \\Delta t, e^{(1)}) \\right) \\\\\ne_{n+1} = \\frac{1}{3} e_n + \\frac{2}{3} \\left( e^{(2)} + \\Delta t \\, f(t_n + \\frac{1}{2}\\Delta t, e^{(2)}) \\right)\n\\end{align*}\n我们必须实现两种评估函数 $f(t,e)$ 的变体：\n\n1.  **在子步中强制执行GCL**：这是一种物理上和数值上都一致的方法。构成系数 $C(t)$ 的几何项 $L(t)$ 和 $\\dot{L}(t)$ 在龙格-库塔方法每个子步所需的特定时刻进行评估。\n    -   对于 $e^{(1)}$，$C(t)$ 在 $t_n$ 时刻评估。\n    -   对于 $e^{(2)}$，$C(t)$ 在 $t_n + \\Delta t$ 时刻评估。\n    -   对于 $e_{n+1}$，$C(t)$ 在 $t_n + \\frac{1}{2}\\Delta t$ 时刻评估。\n\n2.  **在中间子步中不执行GCL**：这是一个常见的实现错误，即在时间步开始时“冻结”几何。系数 $C(t_n) = -(\\gamma-1)\\frac{\\dot{L}(t_n)}{L(t_n)}$ 在时间 $t_n$ 计算一次，并用于该步长的所有三个子步。这在子步层面违反了几何守恒律 (GCL)，并预计会在压力功项的时间积分中引入一阶误差，从而导致精度降低。\n\n对于每个测试用例，我们将使用两种变体进行从 $t=0$ 到 $t=T$ 的时间积分。最终的数值结果 $e_{\\text{num}}(T)$ 将与精确解 $e_{\\text{exact}}(T)$ 进行比较，以计算绝对误差 $|e_{\\text{num}}(T) - e_{\\text{exact}}(T)|$。\n\n实现将包括一个主驱动函数，该函数遍历指定的测试用例。对于每个用例，它将定义函数 $L(t)$ 和 $\\dot{L}(t)$，计算初始和精确的最终能量，并调用一个专用的求解器函数。该求解器将实现 SSP-RK3 时间步进循环，并包含在强制执行GCL和不执行GCL的变体之间切换的逻辑。最终输出将是按要求格式化的这些误差的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It computes the errors in internal energy for GCL-enforced and non-GCL\n    SSP-RK3 integration schemes and prints them in the required format.\n    \"\"\"\n\n    # Physical parameters\n    GAMMA = 1.4\n    RHO_0 = 1.0  # kg/m^3\n    P_0 = 100000.0  # Pa\n    # Initial specific internal energy\n    E_0 = P_0 / ((GAMMA - 1) * RHO_0)  # J/kg\n\n    def run_ssp_rk3_integration(L_func, L_dot_func, L0, T, dt, use_gcl):\n        \"\"\"\n        Performs time integration of the internal energy ODE using SSP-RK3.\n        \n        Args:\n            L_func (callable): Function L(t) for piston position.\n            L_dot_func (callable): Function dL/dt(t) for piston velocity.\n            L0 (float): Initial piston position.\n            T (float): Total integration time.\n            dt (float): Time step.\n            use_gcl (bool): If True, enforces GCL at sub-stages. Otherwise, freezes geometry.\n            \n        Returns:\n            float: The final specific internal energy e(T).\n        \"\"\"\n        num_steps = round(T / dt)\n        e = E_0\n        t = 0.0\n\n        for _ in range(num_steps):\n            if use_gcl:\n                # GCL-enforced at stages: evaluate geometry at each stage time.\n                # Stage 1\n                t1 = t\n                C1 = -(GAMMA - 1) * (L_dot_func(t1) / L_func(t1))\n                e_stage1 = e + dt * (C1 * e)\n\n                # Stage 2\n                t2 = t + dt\n                C2 = -(GAMMA - 1) * (L_dot_func(t2) / L_func(t2))\n                e_stage2 = 0.75 * e + 0.25 * (e_stage1 + dt * (C2 * e_stage1))\n\n                # Stage 3\n                t3 = t + 0.5 * dt\n                C3 = -(GAMMA - 1) * (L_dot_func(t3) / L_func(t3))\n                e_next = (1.0 / 3.0) * e + (2.0 / 3.0) * (e_stage2 + dt * (C3 * e_stage2))\n            else:\n                # No GCL at stages: freeze geometry at the start of the time step.\n                C_frozen = -(GAMMA - 1) * (L_dot_func(t) / L_func(t))\n                \n                # Stage 1\n                e_stage1 = e + dt * (C_frozen * e)\n\n                # Stage 2\n                e_stage2 = 0.75 * e + 0.25 * (e_stage1 + dt * (C_frozen * e_stage1))\n\n                # Stage 3\n                e_next = (1.0 / 3.0) * e + (2.0 / 3.0) * (e_stage2 + dt * (C_frozen * e_stage2))\n\n            e = e_next\n            t += dt\n        \n        return e\n\n    # Test suite definition\n    test_cases = [\n        {\n            \"name\": \"Test 1\",\n            \"L0\": 1.0, \"T\": 1.0, \"dt\": 0.01,\n            \"params\": {\"A\": 0.1},\n            \"L_func\": lambda t, L0, A: L0 + A * np.sin(2 * np.pi * t / 1.0),\n            \"L_dot_func\": lambda t, L0, A: A * (2 * np.pi / 1.0) * np.cos(2 * np.pi * t / 1.0),\n        },\n        {\n            \"name\": \"Test 2\",\n            \"L0\": 1.0, \"T\": 0.5, \"dt\": 0.005,\n            \"params\": {\"alpha\": 0.4},\n            \"L_func\": lambda t, L0, alpha: L0 - alpha * t,\n            \"L_dot_func\": lambda t, L0, alpha: -alpha,\n        },\n        {\n            \"name\": \"Test 3\",\n            \"L0\": 1.0, \"T\": 1.0, \"dt\": 0.01,\n            \"params\": {\"A\": 0.05},\n            \"L_func\": lambda t, L0, A: L0 + A * np.sin(4 * np.pi * t),\n            \"L_dot_func\": lambda t, L0, A: A * (4 * np.pi) * np.cos(4 * np.pi * t),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        L0, T, dt, params = case[\"L0\"], case[\"T\"], case[\"dt\"], case[\"params\"]\n        \n        # Create specific L(t) and L_dot(t) functions for this case\n        L = lambda t: case[\"L_func\"](t, L0, **params)\n        L_dot = lambda t: case[\"L_dot_func\"](t, L0, **params)\n        \n        # Calculate the exact solution at the final time T\n        L_final = L(T)\n        e_exact = E_0 * (L_final / L0) ** (-(GAMMA - 1))\n        \n        # Calculate numerical solution and error for the GCL-enforced case\n        e_num_gcl = run_ssp_rk3_integration(L, L_dot, L0, T, dt, use_gcl=True)\n        err_gcl = abs(e_num_gcl - e_exact)\n        results.append(err_gcl)\n\n        # Calculate numerical solution and error for the non-GCL case\n        e_num_nogcl = run_ssp_rk3_integration(L, L_dot, L0, T, dt, use_gcl=False)\n        err_nogcl = abs(e_num_nogcl - e_exact)\n        results.append(err_nogcl)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3292269"}, {"introduction": "一个稳健的数值格式必须能够正确处理最简单的情况，例如均匀流场，这一特性被称为自由流保持 (free-stream preservation)。本练习将证明，这一基本属性与空间离散化层面满足离散几何守恒律 (Discrete Geometric Conservation Law, DGCL) 直接相关 [@problem_id:3292275]。通过比较一个违反 DGCL 的格式和一个修正后的格式，您将看到几何上的不一致性如何产生人为的源项和汇项，从而破坏最基本的解。", "problem": "考虑一个在任意拉格朗日-欧拉 (ALE) 框架中，由恒定流速 $\\mathbf{u}$ 平流的被动守恒标量 $q$ 在具有网格速度 $\\mathbf{w}$ 的移动网格上的有限体积公式。从积分守恒律和 Reynolds 输运定理出发，推导出适用于有限体积离散化的 ALE 形式，并陈述保证均匀解在纯网格平移下不变的离散条件。具体使用以下基本依据：\n\n- 在移动控制体积 $V(t)$ 上的积分守恒律：$\\dfrac{\\mathrm{d}}{\\mathrm{d}t}\\int_{V(t)} q \\,\\mathrm{d}V + \\int_{\\partial V(t)} q\\, (\\mathbf{u}-\\mathbf{w})\\cdot \\mathbf{n} \\,\\mathrm{d}A = 0$。\n- 对于具有向外单位法向量 $\\mathbf{n}$ 和面积元 $\\mathrm{d}A$ 的封闭曲面 $\\partial V$ 的恒等式：$\\int_{\\partial V} \\mathbf{n}\\,\\mathrm{d}A = \\mathbf{0}$。\n- 几何守恒律 (GCL)，其连续形式为 $\\dfrac{\\mathrm{d}}{\\mathrm{d}t}V(t) = \\int_{\\partial V(t)} \\mathbf{w}\\cdot \\mathbf{n} \\,\\mathrm{d}A$。\n\n从第一性原理出发，解释为什么任何一致的 ALE 离散化都必须使均匀状态 $q(\\mathbf{x},t) \\equiv q_0$ 在纯网格平移 $\\mathbf{w} = \\mathbf{c}$（其中 $\\mathbf{c}$ 是一个常数向量）下保持不变，而无论恒定流速 $\\mathbf{u}$ 为何。然后，设计一个数值测试，用于检测因不一致的面扫描引起的违规，并提出一种基于面平均 $\\mathbf{w}$ 的修正方案。\n\n您必须实现一个独立的程序，该程序对于一组构成结构化网格的二维矩形控制体积，在一个时间步长 $\\Delta t$ 后计算：\n- 不变性误差，定义为 $\\max_{K} \\left| q_K^{n+1} - q_0 \\right|$，其中 $q_K^{n+1}$ 是控制体 $K$ 进行一次 ALE 更新后的控制体平均值，$q_0$ 是均匀初始值。\n- 离散几何守恒残差，定义为 $\\max_{K} \\left| \\sum_{f\\subset \\partial K} \\mathbf{w}_f\\cdot \\mathbf{n}_f \\, L_f \\right|$，其中求和遍历控制体 $K$ 的所有面 $f$，$\\mathbf{n}_f$ 是面 $f$ 的向外单位法向量，$L_f$ 是面的长度。\n\n您的离散化必须对面积为 $V_K$ 的控制体 $K$ 上的标量使用标准的有限体积 ALE 更新：\n- $V_K^{n+1} q_K^{n+1} = V_K^{n} q_K^{n} - \\Delta t \\sum_{f\\subset \\partial K} q_f \\, (\\mathbf{u} - \\mathbf{w}_f)\\cdot \\mathbf{n}_f \\, L_f$，\n对于均匀状态和矩形控制体，其中在纯平移下 $V_K^{n+1} = V_K^{n}$，$q_f = q_K^{n}$。\n\n为了揭示这种不一致性，请构建两种方案：\n- 一种不一致的面扫描方案，当从相邻控制体观察时，为同一个几何面分配不同的 $\\mathbf{w}_f$，方法是在 $\\mathbf{c}$ 的基础上叠加故意带有偏差的、按方向扰动的值，使得即使当 $\\mathbf{w} = \\mathbf{c}$ 时，$\\sum_{f} \\mathbf{w}_f\\cdot \\mathbf{n}_f \\, L_f \\neq 0$ 依然成立。\n- 一种修正方案，为每个面分配由节点速度得到的面平均网格速度，在均匀平移下该速度恰好等于 $\\mathbf{c}$，从而确保离散几何守恒。\n\n使用以下参数值的测试套件，每个测试产生一个由两个浮点数组成的列表 $[E,R]$ 的单一结果，其中 $E$ 是不变性误差，$R$ 是离散几何守恒残差：\n\n- 测试 1 (单控制体, 不一致): $N_x=1$, $N_y=1$, $h_x=1.0$, $h_y=1.0$, $\\mathbf{u} = \\mathbf{c} = [0.7,-0.3]$, $\\Delta t = 0.2$, $q_0 = 2.5$，使用不一致的面扫描方案。\n- 测试 2 (单控制体, 修正): 与测试 1 相同，但使用修正的、面平均 $\\mathbf{w}$ 的方案。\n- 测试 3 (多控制体, 不一致): $N_x=4$, $N_y=3$, $h_x=1.0$, $h_y=1.0$, $\\mathbf{u} = \\mathbf{c} = [0.7,-0.3]$, $\\Delta t = 0.2$, $q_0 = 2.5$，使用不一致的面扫描方案。\n- 测试 4 (多控制体, 修正): 与测试 3 相同，但使用修正的、面平均 $\\mathbf{w}$ 的方案。\n- 测试 5 (多控制体, 不一致, $\\mathbf{u}\\neq \\mathbf{c}$): $N_x=5$, $N_y=2$, $h_x=1.2$, $h_y=0.8$, $\\mathbf{u} = [0.2,0.1]$, $\\mathbf{c} = [0.7,-0.3]$, $\\Delta t = 0.3$, $q_0 = 1.0$，使用不一致的面扫描方案。\n- 测试 6 (多控制体, 修正, $\\mathbf{u}\\neq \\mathbf{c}$): 与测试 5 相同，但使用修正的、面平均 $\\mathbf{w}$ 的方案。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表包含在方括号内且没有空格，每个测试用例结果格式化为 $[E,R]$，并全部聚合到一个列表中。例如：$[[E_1,R_1],[E_2,R_2],\\dots]$。所有量都是无量纲的；不需要物理单位转换。此公式中不出现角度。\n\n不一致的面扫描方案应按以下方式构造以保证被检测到：对于每个具有零基索引的控制体 $(i,j)$，为其四个面定义向外法向量和面长度为\n- 左侧面: $\\mathbf{n}_L = [-1,0]$, $L_L = h_y$,\n- 右侧面: $\\mathbf{n}_R = [1,0]$, $L_R = h_y$,\n- 底面: $\\mathbf{n}_B = [0,-1]$, $L_B = h_x$,\n- 顶面: $\\mathbf{n}_T = [0,1]$, $L_T = h_x$,\n并将控制体 $(i,j)$ 使用的面网格速度设置为\n- $\\mathbf{w}_R = \\mathbf{c} + [\\gamma_x (i+1), -\\gamma_y (j+1)]$,\n- $\\mathbf{w}_L = \\mathbf{c} + [-0.5\\,\\gamma_x (i+1), +0.25\\,\\gamma_y (j+1)]$,\n- $\\mathbf{w}_T = \\mathbf{c} + [0.1\\,\\gamma_x (i+1), +1.5\\,\\gamma_y (j+1)]$,\n- $\\mathbf{w}_B = \\mathbf{c} + [-0.2\\,\\gamma_x (i+1), -0.8\\,\\gamma_y (j+1)]$,\n其中 $\\gamma_x = 10^{-3}$ 和 $\\gamma_y = 2\\times 10^{-3}$。这将导致每个控制体的离散几何守恒残差非零，从而产生可测量的不变性误差。\n\n修正方案应对所有面 $f$ 赋值 $\\mathbf{w}_f = \\mathbf{c}$，这对应于均匀平移下的面平均节点速度。\n\n您的程序必须为所提供的测试精确实现这些计算，并按要求的格式打印聚合结果。", "solution": "该问题要求推导守恒被动标量的有限体积任意拉格朗日-欧拉 (ALE) 更新格式，并分析该格式保持均匀标量场所需的条件。这种保持特性，通常称为自由流保持，是任何有效数值格式的基本一致性要求。分析将证明，此特性与满足离散几何守恒律 (DGCL) 内在相关。\n\n出发点是标量 $q$ 在一个随时间变化的控制体积 $V(t)$（其边界为 $\\partial V(t)$，以速度 $\\mathbf{w}$ 移动）上的积分形式守恒律。流体速度为 $\\mathbf{u}$。这是应用于守恒量的 Reynolds 输运定理，在 ALE 框架中表示为：\n$$\n\\dfrac{\\mathrm{d}}{\\mathrm{d}t}\\int_{V(t)} q \\,\\mathrm{d}V + \\int_{\\partial V(t)} q\\, (\\mathbf{u}-\\mathbf{w})\\cdot \\mathbf{n} \\,\\mathrm{d}A = 0\n$$\n这里，$\\mathbf{n}$ 是指向外部的单位法向量，作用于表面元素 $\\mathrm{d}A$。\n\n对于有限体积离散化，我们将空间域划分为一组不重叠的控制体积（或称单元）$K$。对每个单元 $K$，我们将方程在一个时间步长从 $t^n$ 到 $t^{n+1} = t^n + \\Delta t$ 内进行积分。对时间导数使用一阶欧拉显式格式，我们得到：\n$$\n\\frac{1}{\\Delta t} \\left[ \\left(\\int_{V_K} q \\,\\mathrm{d}V\\right)^{n+1} - \\left(\\int_{V_K} q \\,\\mathrm{d}V\\right)^{n} \\right] + \\left(\\int_{\\partial V_K} q\\, (\\mathbf{u}-\\mathbf{w})\\cdot \\mathbf{n} \\,\\mathrm{d}A\\right)^n \\approx 0\n$$\n我们定义单元平均标量为 $q_K(t) = \\frac{1}{V_K(t)} \\int_{V_K(t)} q(\\mathbf{x}, t) \\,\\mathrm{d}V$，其中 $V_K(t)$ 是单元 $K$ 的体积（在二维中为面积）。方程变为：\n$$\n\\frac{V_K^{n+1} q_K^{n+1} - V_K^n q_K^n}{\\Delta t} + \\sum_{f \\subset \\partial K} \\int_{A_f} q\\, (\\mathbf{u}-\\mathbf{w})\\cdot \\mathbf{n}_f \\,\\mathrm{d}A = 0\n$$\n在单元边界 $\\partial V_K$ 上的面积分被替换为单元各面 $f$ 的总和。通过用面平均值与面面积（在二维中为长度 $L_f$）的乘积来近似面积分，得到全离散更新格式：\n$$\nV_K^{n+1} q_K^{n+1} = V_K^{n} q_K^{n} - \\Delta t \\sum_{f\\subset \\partial K} q_f \\, (\\mathbf{u} - \\mathbf{w}_f)\\cdot \\mathbf{n}_f \\, L_f\n$$\n这里，$q_f$ 和 $\\mathbf{w}_f$ 是面 $f$ 上标量和网格速度的代表值。\n\n现在我们分析该格式保持均匀状态 $q(\\mathbf{x}, t) \\equiv q_0$（其中 $q_0$ 是常数）所需的条件。在这种情况下，初始单元平均值完全相同，$q_K^n = q_0$ 对所有 $K$ 成立。对面值一个简单且一致的选择是 $q_f = q_K^n = q_0$。将这些代入更新公式：\n$$\nV_K^{n+1} q_K^{n+1} = V_K^{n} q_0 - \\Delta t \\sum_{f\\subset \\partial K} q_0 \\, (\\mathbf{u} - \\mathbf{w}_f)\\cdot \\mathbf{n}_f \\, L_f\n$$\n提出常数 $q_0$：\n$$\nV_K^{n+1} q_K^{n+1} = V_K^{n} q_0 - \\Delta t \\, q_0 \\sum_{f\\subset \\partial K} (\\mathbf{u} - \\mathbf{w}_f)\\cdot \\mathbf{n}_f \\, L_f\n$$\n求和项可以拆分：\n$$\n\\sum_{f\\subset \\partial K} (\\mathbf{u} - \\mathbf{w}_f)\\cdot \\mathbf{n}_f \\, L_f = \\sum_{f\\subset \\partial K} \\mathbf{u}\\cdot \\mathbf{n}_f \\, L_f - \\sum_{f\\subset \\partial K} \\mathbf{w}_f\\cdot \\mathbf{n}_f \\, L_f\n$$\n由于流速 $\\mathbf{u}$ 是恒定的，右边的第一项变为 $\\mathbf{u} \\cdot \\left(\\sum_{f\\subset \\partial K} \\mathbf{n}_f L_f\\right)$。对于任何封闭的控制体积，其指向外部、按面积加权的法向量之和为零。这是恒等式 $\\int_{\\partial V} \\mathbf{n}\\,\\mathrm{d}A = \\mathbf{0}$ 的离散等价形式。因此，$\\sum_{f\\subset \\partial K} \\mathbf{n}_f L_f = \\mathbf{0}$，涉及 $\\mathbf{u}$ 的项完全消失。这是关键一步：均匀状态的不变性必须独立于流体速度。\n\n更新方程简化为：\n$$\nV_K^{n+1} q_K^{n+1} = V_K^{n} q_0 + \\Delta t \\, q_0 \\sum_{f\\subset \\partial K} \\mathbf{w}_f\\cdot \\mathbf{n}_f \\, L_f\n$$\n现在，我们引入几何守恒律 (GCL)。在其连续形式中，它指出控制体积的体积变化率等于边界速度的通量：$\\frac{\\mathrm{d}V}{\\mathrm{d}t} = \\int_{\\partial V} \\mathbf{w}\\cdot\\mathbf{n}\\,\\mathrm{d}A$。一个一致的离散模拟，即离散几何守恒律 (DGCL)，是通过与标量输运方程相同的方式离散化该定律得到的：\n$$\n\\frac{V_K^{n+1} - V_K^n}{\\Delta t} = \\sum_{f\\subset \\partial K} \\mathbf{w}_f \\cdot \\mathbf{n}_f \\, L_f\n$$\n将这个 DGCL 代入简化的 $q_K^{n+1}$ 更新方程：\n$$\nV_K^{n+1} q_K^{n+1} = V_K^{n} q_0 + q_0 (V_K^{n+1} - V_K^n)\n$$\n$$\nV_K^{n+1} q_K^{n+1} = q_0 (V_K^n + V_K^{n+1} - V_K^n) = q_0 V_K^{n+1}\n$$\n假设单元体积 $V_K^{n+1}$ 非零，我们可以两边同除以它，得到期望的结果：\n$$\nq_K^{n+1} = q_0\n$$\n此推导表明，均匀状态 $q_0$ 保持不变当且仅当数值格式满足离散几何守恒律。此条件确保了几何演化的数值离散化与输运方程的离散化相一致，从而防止仅因网格运动而产生标量 $q$ 的人为源或汇。\n\n对于纯网格平移的特定情况，网格速度在任何地方都是一个常数向量，$\\mathbf{w}(\\mathbf{x},t) = \\mathbf{c}$。从几何上看，任何单元的体积都保持不变，因此 $V_K^{n+1} = V_K^n$。DGCL 此时要求：\n$$\n\\frac{V_K^{n+1} - V_K^n}{\\Delta t} = 0 = \\sum_{f\\subset \\partial K} \\mathbf{w}_f \\cdot \\mathbf{n}_f \\, L_f\n$$\n保证均匀解在纯网格平移下不变的离散条件是，对于每个单元 $K$，$\\sum_{f\\subset \\partial K} \\mathbf{w}_f \\cdot \\mathbf{n}_f \\, L_f = 0$。\n\n数值测试旨在揭示对此条件的违反。\n“修正”方案为每个几何面唯一地定义面速度 $\\mathbf{w}_f$，例如，作为其节点速度的平均值。对于纯平移 $\\mathbf{w}=\\mathbf{c}$，所有节点都以 $\\mathbf{c}$ 移动，因此所有面速度均为 $\\mathbf{w}_f = \\mathbf{c}$。DGCL 的和则为 $\\sum_{f} \\mathbf{c} \\cdot \\mathbf{n}_f L_f = \\mathbf{c} \\cdot (\\sum_{f} \\mathbf{n}_f L_f) = \\mathbf{c} \\cdot \\mathbf{0} = 0$。该方案满足 DGCL，并将保持均匀状态，从而产生零不变性误差和零 GCL 残差。\n\n“不一致”方案代表了一种常见的实现错误，即面速度 $\\mathbf{w}_f$ 是从以控制体为中心的视角计算的。所提供的公式故意向 $\\mathbf{c}$ 引入小的、依赖于单元索引的扰动。因此，对于两个单元之间的共享面，一个单元计算的网格速度与其邻居计算的不同。这种不一致性导致非零的和 $\\sum_{f \\subset \\partial K} \\mathbf{w}_f \\cdot \\mathbf{n}_f \\, L_f \\neq 0$。如推导所示，这种 DGCL 违规直接导致更新后标量的误差，即 $|q_K^{n+1}-q_0| = \\frac{\\Delta t |q_0|}{V_K^n} |\\sum_f \\mathbf{w}_f \\cdot \\mathbf{n}_f L_f|$，该误差与 GCL 残差成正比。数值实现将计算此误差 $E$ 和残差 $R$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the ALE invariance test suite.\n    \"\"\"\n\n    test_cases = [\n        # Test 1 (single-cell, inconsistent)\n        {'Nx': 1, 'Ny': 1, 'hx': 1.0, 'hy': 1.0, 'u': np.array([0.7, -0.3]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.2, 'q0': 2.5, 'inconsistent': True},\n        # Test 2 (single-cell, corrected)\n        {'Nx': 1, 'Ny': 1, 'hx': 1.0, 'hy': 1.0, 'u': np.array([0.7, -0.3]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.2, 'q0': 2.5, 'inconsistent': False},\n        # Test 3 (multi-cell, inconsistent)\n        {'Nx': 4, 'Ny': 3, 'hx': 1.0, 'hy': 1.0, 'u': np.array([0.7, -0.3]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.2, 'q0': 2.5, 'inconsistent': True},\n        # Test 4 (multi-cell, corrected)\n        {'Nx': 4, 'Ny': 3, 'hx': 1.0, 'hy': 1.0, 'u': np.array([0.7, -0.3]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.2, 'q0': 2.5, 'inconsistent': False},\n        # Test 5 (multi-cell, inconsistent, u != c)\n        {'Nx': 5, 'Ny': 2, 'hx': 1.2, 'hy': 0.8, 'u': np.array([0.2, 0.1]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.3, 'q0': 1.0, 'inconsistent': True},\n        # Test 6 (multi-cell, corrected, u != c)\n        {'Nx': 5, 'Ny': 2, 'hx': 1.2, 'hy': 0.8, 'u': np.array([0.2, 0.1]),\n         'c': np.array([0.7, -0.3]), 'dt': 0.3, 'q0': 1.0, 'inconsistent': False},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_simulation(**params)\n        all_results.append(result)\n\n    # Format the final output string exactly as specified.\n    result_strings = [f\"[{e},{r}]\" for e, r in all_results]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef run_simulation(Nx, Ny, hx, hy, u, c, dt, q0, inconsistent):\n    \"\"\"\n    Computes invariance error and GCL residual for a given grid and scheme.\n    \"\"\"\n    \n    # Constants for the inconsistent scheme\n    gamma_x = 1e-3\n    gamma_y = 2e-3\n    \n    max_invariance_error = 0.0\n    max_gcl_residual = 0.0\n\n    # Cell volume (constant under pure translation)\n    V_K = hx * hy\n\n    # Iterate over all cells in the grid (i = x-index, j = y-index)\n    for j in range(Ny):\n        for i in range(Nx):\n            # Define faces: normal vector, length\n            faces_geom = {\n                'R': {'n': np.array([1.0, 0.0]), 'L': hy},   # Right\n                'L': {'n': np.array([-1.0, 0.0]), 'L': hy},  # Left\n                'T': {'n': np.array([0.0, 1.0]), 'L': hx},   # Top\n                'B': {'n': np.array([0.0, -1.0]), 'L': hx}   # Bottom\n            }\n\n            # Get mesh velocities for each face\n            if inconsistent:\n                # Indices for formula are 1-based\n                ip1 = i + 1\n                jp1 = j + 1\n                w_faces = {\n                    'R': c + np.array([gamma_x * ip1, -gamma_y * jp1]),\n                    'L': c + np.array([-0.5 * gamma_x * ip1, 0.25 * gamma_y * jp1]),\n                    'T': c + np.array([0.1 * gamma_x * ip1, 1.5 * gamma_y * jp1]),\n                    'B': c + np.array([-0.2 * gamma_x * ip1, -0.8 * gamma_y * jp1])\n                }\n            else: # Corrected scheme\n                w_faces = {\n                    'R': c, 'L': c, 'T': c, 'B': c\n                }\n\n            # Calculate sum of fluxes and GCL term for the cell\n            total_flux_term = 0.0\n            gcl_sum = 0.0\n\n            for face_key in faces_geom:\n                n_f = faces_geom[face_key]['n']\n                L_f = faces_geom[face_key]['L']\n                w_f = w_faces[face_key]\n\n                # Flux for q\n                # q_f * (u - w_f) . n_f * L_f\n                # For uniform state, q_f = q0\n                flux = q0 * np.dot(u - w_f, n_f) * L_f\n                total_flux_term += flux\n\n                # Geometric Conservation Law term\n                # w_f . n_f * L_f\n                gcl_term = np.dot(w_f, n_f) * L_f\n                gcl_sum += gcl_term\n\n            # Update q for the cell\n            # V_K * q_K^{n+1} = V_K * q_K^n - dt * sum(fluxes)\n            # Since q_K^n = q0, and V_K is constant\n            q_K_np1 = q0 - (dt / V_K) * total_flux_term\n\n            # Calculate cell-wise errors\n            cell_invariance_error = abs(q_K_np1 - q0)\n            cell_gcl_residual = abs(gcl_sum)\n\n            # Update maximums\n            if cell_invariance_error > max_invariance_error:\n                max_invariance_error = cell_invariance_error\n            \n            if cell_gcl_residual > max_gcl_residual:\n                max_gcl_residual = cell_gcl_residual\n\n    return [max_invariance_error, max_gcl_residual]\n\nsolve()\n```", "id": "3292275"}]}