{"hands_on_practices": [{"introduction": "要评估和控制计算网格的质量，我们必须首先学会如何量化其几何特性。本练习将通过一个参数化的坐标变换，引导您推导三个关键的网格质量度量：雅可比行列式 $J$（衡量单元有效性和面积变化）、正交性误差 $\\mathbf{g}_\\xi \\cdot \\mathbf{g}_\\eta$（衡量网格线的垂直程度）和局部单元纵横比 $A$（衡量单元的拉伸程度）。通过分析这些量与控制参数 $\\alpha$ 的关系，您将直观地理解如何通过调整变换函数来塑造网格的几何形状。[@problem_id:3313603]", "problem": "在计算流体力学 (CFD) 椭圆网格生成的背景下，考虑一个从计算空间到物理空间的光滑映射，该映射定义在计算坐标 $(\\xi,\\eta)$ 的单位正方形 $[0,1]\\times[0,1]$ 上，由下式给出：\n$$\nx(\\xi,\\eta) = \\xi,\\qquad y(\\xi,\\eta) = \\eta + \\alpha \\sin(\\pi \\xi),\n$$\n其中 $\\alpha \\in \\mathbb{R}$ 是一个实值控制参数。在使用泊松方程的椭圆网格生成中，坐标函数满足：\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta),\\qquad y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta),\n$$\n其中给定的右端项 $P$ 和 $Q$ 用于控制网格线的聚集和平滑度。\n\n从物理平面中协变基向量的基本定义出发，\n$$\n\\mathbf{g}_{\\xi} = \\begin{pmatrix} x_{\\xi} \\\\ y_{\\xi} \\end{pmatrix},\\qquad \\mathbf{g}_{\\eta} = \\begin{pmatrix} x_{\\eta} \\\\ y_{\\eta} \\end{pmatrix},\n$$\n雅可比行列式\n$$\nJ = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi},\n$$\n正交性误差\n$$\n\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta},\n$$\n以及局部单元纵横比（对应于 $\\xi$ 和 $\\eta$ 方向单位步长的边长之比）\n$$\nA = \\frac{\\|\\mathbf{g}_{\\xi}\\|}{\\|\\mathbf{g}_{\\eta}\\|},\n$$\n推导 $J(\\xi,\\eta;\\alpha)$、$\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta}(\\xi,\\eta;\\alpha)$ 和 $A(\\xi,\\eta;\\alpha)$ 的解析表达式。然后，基于这些表达式和泊松方程的公式，简要讨论参数 $\\alpha$ 如何影响物理平面中的网格正交性和单元拉伸。\n\n以有序三元组 $\\big(J,\\ \\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta},\\ A\\big)$ 的封闭形式给出你的最终结果。不需要四舍五入，也不需要单位。", "solution": "该问题是有效的，因为它科学地基于应用于计算网格生成的微分几何原理，问题提出得当，信息充分，可得到唯一解，并以客观、正式的语言表述。我们开始推导。\n\n给定的从计算坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的变换是：\n$$\nx(\\xi,\\eta) = \\xi\n$$\n$$\ny(\\xi,\\eta) = \\eta + \\alpha \\sin(\\pi \\xi)\n$$\n其中 $\\alpha$ 是一个实值参数。\n\n首先，我们计算 $x$ 和 $y$ 关于 $\\xi$ 和 $\\eta$ 的一阶偏导数。这些导数是协变基向量的分量。\n$$\nx_{\\xi} = \\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(\\xi) = 1\n$$\n$$\nx_{\\eta} = \\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(\\xi) = 0\n$$\n$$\ny_{\\xi} = \\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial}{\\partial \\xi}(\\eta + \\alpha \\sin(\\pi \\xi)) = \\alpha \\pi \\cos(\\pi \\xi)\n$$\n$$\ny_{\\eta} = \\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial}{\\partial \\eta}(\\eta + \\alpha \\sin(\\pi \\xi)) = 1\n$$\n\n使用这些导数，我们构建协变基向量 $\\mathbf{g}_{\\xi}$ 和 $\\mathbf{g}_{\\eta}$：\n$$\n\\mathbf{g}_{\\xi} = \\begin{pmatrix} x_{\\xi} \\\\ y_{\\xi} \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ \\alpha \\pi \\cos(\\pi \\xi) \\end{pmatrix}\n$$\n$$\n\\mathbf{g}_{\\eta} = \\begin{pmatrix} x_{\\eta} \\\\ y_{\\eta} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n在物理 $(x,y)$ 平面中，这些向量分别与常数 $\\eta$ 网格线和常数 $\\xi$ 网格线相切。\n\n接下来，我们使用它们的定义推导所要求的量。\n\n**1. 雅可比行列式, $J(\\xi,\\eta;\\alpha)$**\n雅可比行列式定义为 $J = x_{\\xi} y_{\\eta} - x_{\\eta} y_{\\xi}$。代入计算出的偏导数：\n$$\nJ = (1)(1) - (0)(\\alpha \\pi \\cos(\\pi \\xi)) = 1 - 0 = 1\n$$\n雅可比行列式是常数且等于 $1$。这表明该变换是局部保面积的；计算空间中的微分面积元 $d\\xi d\\eta$ 映射到物理空间中相同大小的微分面积元 $dx dy$。\n\n**2. 正交性误差, $\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta}(\\xi,\\eta;\\alpha)$**\n网格的正交性由协变基向量的点积来衡量。值为 $0$ 表示局部正交。\n$$\n\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = x_{\\xi} x_{\\eta} + y_{\\xi} y_{\\eta}\n$$\n代入导数：\n$$\n\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = (1)(0) + (\\alpha \\pi \\cos(\\pi \\xi))(1) = \\alpha \\pi \\cos(\\pi \\xi)\n$$\n该表达式量化了在任意点 $(\\xi, \\eta)$ 处与正交性的偏差。\n\n**3. 局部单元纵横比, $A(\\xi,\\eta;\\alpha)$**\n纵横比 $A$ 是基向量模长的比值，$A = \\frac{\\|\\mathbf{g}_{\\xi}\\|}{\\|\\mathbf{g}_{\\eta}\\|}$。我们首先计算模长：\n$$\n\\|\\mathbf{g}_{\\xi}\\| = \\sqrt{x_{\\xi}^{2} + y_{\\xi}^{2}} = \\sqrt{1^{2} + (\\alpha \\pi \\cos(\\pi \\xi))^{2}} = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}\n$$\n$$\n\\|\\mathbf{g}_{\\eta}\\| = \\sqrt{x_{\\eta}^{2} + y_{\\eta}^{2}} = \\sqrt{0^{2} + 1^{2}} = 1\n$$\n因此，纵横比为：\n$$\nA = \\frac{\\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}}{1} = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}\n$$\n\n**关于 $\\alpha$ 作用的讨论：**\n\n参数 $\\alpha$ 直接控制物理平面中网格的几何属性。\n- **网格正交性**：正交性误差为 $\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = \\alpha \\pi \\cos(\\pi \\xi)$。如果 $\\alpha=0$，变换简化为恒等映射 $(x,y) = (\\xi,\\eta)$，正交性误差处处为 $0$，网格是一个简单的正交笛卡尔网格。对于 $\\alpha \\neq 0$，网格通常是非正交的。与正交性的偏差与 $|\\alpha|$ 成正比，并随 $\\xi$ 变化。对于任何非零的 $\\alpha$，只有在 $\\cos(\\pi \\xi) = 0$ 的地方才能实现完全正交，这在定义域 $[0,1]$ 中发生在 $\\xi=1/2$ 处。最大的非正交性出现在边界 $\\xi=0$ 和 $\\xi=1$ 处，此时 $|\\cos(\\pi \\xi)|=1$。\n\n- **单元拉伸**：局部单元纵横比为 $A = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}$。如果 $\\alpha=0$，$A=1$ 处处成立，表明由 $\\xi$ 和 $\\eta$ 方向的单位步长形成的单元是局部正方形。对于 $\\alpha \\neq 0$，$A \\geq 1$，表明网格单元被拉伸。单元在 $\\xi$ 方向的边长 $\\|\\mathbf{g}_{\\xi}\\|$ 相对于在 $\\eta$ 方向的边长 $\\|\\mathbf{g}_{\\eta}\\|$ 被拉伸。拉伸是 $\\alpha^2$ 的函数，因此其大小与 $\\alpha$ 的符号无关。最大的拉伸发生在 $|\\cos(\\pi \\xi)|=1$ 的地方（在 $\\xi=0, 1$ 处），而在 $\\cos(\\pi \\xi)=0$ 的地方没有拉伸（$A=1$）（在 $\\xi=1/2$ 处）。\n\n- **与泊松方程的关系**：泊松网格生成方程中的强制函数 $P$ 和 $Q$ 由映射函数的二阶导数确定。我们可以为给定的变换计算它们：\n$$\nx_{\\xi\\xi} = 0, \\quad x_{\\eta\\eta} = 0 \\implies P(\\xi,\\eta) = x_{\\xi\\xi} + x_{\\eta\\eta} = 0\n$$\n$$\ny_{\\xi\\xi} = -\\alpha \\pi^{2} \\sin(\\pi \\xi), \\quad y_{\\eta\\eta} = 0 \\implies Q(\\xi,\\eta) = y_{\\xi\\xi} + y_{\\eta\\eta} = -\\alpha \\pi^{2} \\sin(\\pi \\xi)\n$$\n这表明参数 $\\alpha$ 与强制函数 $Q$ 成正比，后者控制了 $y$ 坐标线的曲率。非零的 $\\alpha$ 引入了一个非零的强制项 $Q$，它“拉动”网格线以产生观察到的非正交性和拉伸。因此，$\\alpha$ 通过泊松方程源项的机制，作为这些网格属性的控制参数。\n\n总之，推导出的表达式是：\n$J = 1$\n$\\mathbf{g}_{\\xi}\\cdot \\mathbf{g}_{\\eta} = \\alpha \\pi \\cos(\\pi \\xi)$\n$A = \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)}$\n这些构成了最终的有序三元组。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1 & \\alpha \\pi \\cos(\\pi \\xi) & \\sqrt{1 + \\alpha^{2} \\pi^{2} \\cos^{2}(\\pi \\xi)} \\end{pmatrix}}\n$$", "id": "3313603"}, {"introduction": "从连续的偏微分方程到计算机上的离散求解，数值方法的稳定性至关重要。本练习是一个数值实验，旨在揭示离散化过程中一个核心的数值分析概念——对角占优性——与网格物理有效性之间的深刻联系。您将通过编写代码，亲眼见证即使在源项和边界条件都非常光滑的情况下，违反了对角占优性也可能导致离散最大值原理失效，并产生无效的折叠网格，从而深刻理解保证数值稳定性的实践意义。[@problem_id:3313541]", "problem": "考虑在计算单位正方形 $(\\xi,\\eta)\\in[0,1]\\times[0,1]$ 上，通过泊松系统为物理映射分量 $x(\\xi,\\eta)$ 和 $y(\\xi,\\eta)$ 生成二维椭圆网格，并采用狄利克雷边界条件。其连续形式规定 $x$ 和 $y$ 在计算空间中求解带光滑源项的泊松方程。该问题的基本依据包括：(i) 拉普拉斯算子的连续极值原理，该原理指出调和函数的极值出现在边界上；(ii) 由有限差分离散化产生的线性系统的离散极值原理的定义，该原理在系数矩阵为单调矩阵（例如，M-矩阵）时成立，其特征为非正的非对角元、正的对角元以及足以保证非负逆的对角占优条件；以及 (iii) 均匀网格上拉普拉斯算子的标准五点有限差分格式。\n\n你的任务是，使用一个具体的、可计算的构造来证明，在用于泊松网格生成器的离散线性系统中破坏对角占优性，即使在源项和边界数据都光滑的情况下，也会破坏离散极值原理并产生不可逆网格（折叠单元）；并实现一种稳定化方法来恢复对角占优性并防止网格折叠。\n\n为使任务完全明确，请使用以下设置。\n\n1. 定义精确的光滑目标映射，其内部具有小而光滑的聚类：\n   - 令 $A$ 为光滑幅度，给定值为 $A=0.158$（无量纲）。\n   - 定义\n     $$x_{\\text{exact}}(\\xi,\\eta) = \\xi + A \\sin(2\\pi \\xi)\\sin(\\pi \\eta),$$\n     $$y_{\\text{exact}}(\\xi,\\eta) = \\eta + A \\sin(2\\pi \\eta)\\sin(\\pi \\xi).$$\n   - 通过上述函数在计算空间中的拉普拉斯算子来定义源项：\n     $$P(\\xi,\\eta) = \\nabla^2 x_{\\text{exact}}(\\xi,\\eta) = -A\\,(5\\pi^2)\\,\\sin(2\\pi \\xi)\\sin(\\pi \\eta),$$\n     $$Q(\\xi,\\eta) = \\nabla^2 y_{\\text{exact}}(\\xi,\\eta) = -A\\,(5\\pi^2)\\,\\sin(2\\pi \\eta)\\sin(\\pi \\xi).$$\n   - 在单位正方形的边界上，施加从精确映射 $x_{\\text{exact}}$ 和 $y_{\\text{exact}}$ 中提取的狄利克雷边界条件。\n\n2. 使用均匀网格对内部进行离散化，每个坐标方向有 $N$ 个节点，因此网格间距为 $h = 1/(N-1)$，内部点数量为 $(N-2)^2$。对内部点使用标准的五点差分格式来表示离散拉普拉斯算子，即对应于以下算子\n   $$4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = h^2 f_{i,j}$$\n   ，并将边界邻点的贡献加到右端项。\n\n3. 构造一个单参数线性系统族，通过缩放离散算子的对角线来破坏对角占优性：\n   - 令 $s \\in \\mathbb{R}$ 为一个对角缩放参数。将标准五点差分格式中的中心系数 $4$ 替换为 $4s$，同时保持所有非对角元等于 $-1$。在矩阵形式中，这产生了一个系数矩阵为如下的线性系统\n     $$A_s = L + 4(s-1)I,$$\n     其中 $L$ 是乘以 $h^2$ 的标准五点离散拉普拉斯矩阵（形式为 $4I -$ 非对角元），$I$ 是大小为 $(N-2)^2\\times(N-2)^2$ 的单位矩阵。注意，当 $s < 1$ 时，对角占优性可能被破坏。\n   - 通过向算子添加单位矩阵的正数倍（一个反应项）来为系统增加一个稳定化参数 $\\sigma \\ge 0$，得到\n     $$A_{s,\\sigma} = L + 4(s-1+\\sigma)I.$$\n     对于 $\\sigma \\ge 1-s$，行对角占优性至少恢复到标准水平。\n\n4. 使用相同的 $A_{s,\\sigma}$ 以及由源项和边界贡献确定的右端项，求解两个解耦的泊松问题，分别计算 $x$ 和 $y$。重构包括边界在内的完整网格。\n\n5. 通过在每个计算单元上使用向前差分计算离散单元雅可比来检测网格折叠：\n   $$J_{i,j} = \\det\\begin{pmatrix}\n   x_{i+1,j} - x_{i,j} & x_{i,j+1} - x_{i,j} \\\\\n   y_{i+1,j} - y_{i,j} & y_{i,j+1} - y_{i,j}\n   \\end{pmatrix}.$$\n   如果任何 $J_{i,j} \\le 0$，则检测到折叠单元。\n\n6. 你的程序必须实现上述步骤，并为每个测试案例返回一个布尔值，指示是否有任何单元发生折叠（即是否存在 $J_{i,j} \\le 0$）。程序不得要求任何用户输入。\n\n使用以下测试套件，其中包括一个基准案例、一个不稳定的非对角占优案例、一个稳定化案例以及一个临近占优的边缘案例：\n- 测试案例 1：$N=41$, $s=1.0$, $\\sigma=0.0$。\n- 测试案例 2：$N=41$, $s=0.1$, $\\sigma=0.0$。\n- 测试案例 3：$N=41$, $s=0.1$, $\\sigma=1.0$。\n- 测试案例 4：$N=16$, $s=0.95$, $\\sigma=0.0$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起的、逗号分隔的结果列表，顺序与测试案例一致，例如，格式为 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是测试案例 $k$ 的布尔结果，指示是否发生折叠。不需要物理单位。三角函数内部使用的角度以弧度为单位。最终输出为布尔值，无需四舍五入。", "solution": "问题陈述经评估是有效的。它在科学上基于计算流体动力学和数值分析的原理，特别是关于通过泊松方程进行椭圆网格生成。该问题是适定的，为数值实验提供了一套完整且一致的定义、参数和边界条件。其目标是证明离散化线性系统中的对角占优性对于维持网格质量（即防止折叠）的重要性。这是科学计算中一个标准且富有洞察力的练习。所有术语都得到了正式定义，且任务是可通过计算验证的。\n\n求解过程如下：\n\n首先，我们建立计算域，即一个在 $(\\xi, \\eta)$ 坐标系中的单位正方形，用一个大小为 $N \\times N$ 的均匀网格进行离散化。网格间距为 $h = 1/(N-1)$。网格点为 $(\\xi_i, \\eta_j) = (i h, j h)$，其中 $i, j = 0, \\dots, N-1$。\n\n问题要求为物理坐标 $x(\\xi, \\eta)$ 和 $y(\\xi, \\eta)$ 求解两个解耦的泊松方程：\n$$ \\nabla^2 x = P(\\xi, \\eta) $$\n$$ \\nabla^2 y = Q(\\xi, \\eta) $$\n其中 $\\nabla^2 = \\frac{\\partial^2}{\\partial \\xi^2} + \\frac{\\partial^2}{\\partial \\eta^2}$。源项 $P$ 和 $Q$ 以及狄利克雷边界条件均源自一个已知的精确映射：\n$$ x_{\\text{exact}}(\\xi,\\eta) = \\xi + A \\sin(2\\pi \\xi)\\sin(\\pi \\eta) $$\n$$ y_{\\text{exact}}(\\xi,\\eta) = \\eta + A \\sin(2\\pi \\eta)\\sin(\\pi \\xi) $$\n其中幅度 $A = 0.158$。源项为 $P = \\nabla^2 x_{\\text{exact}}$ 和 $Q = \\nabla^2 y_{\\text{exact}}$，由以下公式给出：\n$$ P(\\xi,\\eta) = -A(5\\pi^2)\\sin(2\\pi \\xi)\\sin(\\pi \\eta) $$\n$$ Q(\\xi,\\eta) = -A(5\\pi^2)\\sin(2\\pi \\eta)\\sin(\\pi \\xi) $$\n\n问题的核心在于泊松方程的离散化。对内部点 $(i, j)$（其中 $i, j \\in \\{1, \\dots, N-2\\}$）使用一种修正的五点差分格式：\n$$ 4(s+\\sigma) u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} = h^2 f_{i,j} $$\n这里，$u$ 代表 $x$ 或 $y$，$f$ 代表 $P$ 或 $Q$。参数 $s$ 和 $\\sigma$ 控制最终线性系统矩阵的对角元，从而影响其对角占优性。对于一个内部节点，对角元为 $4(s+\\sigma)$，而非对角元大小之和为 $4$。如果 $|4(s+\\sigma)| \\ge 4$，即 $s+\\sigma \\ge 1$，则保证对角占优。\n\n我们为内部网格点上 $(N-2)^2$ 个 $x$ 和 $y$ 的未知值建立一个线性系统 $A_{s,\\sigma} \\mathbf{u} = \\mathbf{b}$。矩阵 $A_{s,\\sigma}$ 基于修正的差分格式构建。对于每个内部点 $(i,j)$，构建线性系统中相应的一行。矩阵的对角元素为 $4(s+\\sigma)$，对于每个内部邻居，非对角元素为 $-1$。如果一个邻居 $(i', j')$ 位于边界上，它的值 $u_{i',j'}$ 从狄利克雷条件（由 $x_{\\text{exact}}$ 或 $y_{\\text{exact}}$ 计算得出）中已知。这个已知值被移到方程的右端。因此，对于给定的内部点 $(i,j)$，右端向量 $\\mathbf{b}$ 由缩放后的源项 $h^2 f_{i,j}$ 加上来自相邻单元的任何边界值之和构成。\n\n求解得到的两个稀疏线性系统（一个用于 $x$ 坐标，一个用于 $y$ 坐标），以找到内部网格点的值。然后将这些解与已知的边界值结合，形成完整的 $N \\times N$ 物理坐标网格 $(x_{i,j}, y_{i,j})$。\n\n最后一步是检查网格折叠。如果网格的任何单元具有非正面积或方向错误，则认为该网格发生了折叠。这通过为每个四边形单元计算映射的雅可比来检测。对于左下角位于 $(\\xi_i, \\eta_j)$ 的单元，雅可比 $J_{i,j}$ 使用向前差分计算：\n$$ J_{i,j} = \\det\\begin{pmatrix}\nx_{i+1,j} - x_{i,j} & x_{i,j+1} - x_{i,j} \\\\\ny_{i+1,j} - y_{i,j} & y_{i,j+1} - y_{i,j}\n\\end{pmatrix} $$\n对所有单元（其中 $i, j = 0, \\dots, N-2$）进行此计算。如果任何 $J_{i,j} \\le 0$，则表示一个局部不可逆的映射，该网格被标记为折叠。对于每个测试案例，确定布尔结果 `True`（折叠）或 `False`（未折叠）。\n\n实现细节包括：\n1.  设置计算网格坐标。\n2.  在边界上计算精确解，在内部计算源项。\n3.  构建稀疏矩阵 $A_{s,\\sigma}$ 和右端向量 $\\mathbf{b}_x$ 及 $\\mathbf{b}_y$。使用从二维网格索引 $(i, j)$ 到一维向量索引 $k$ 的索引映射，例如，对于 $i,j \\in \\{1, \\dots, N-2\\}$，使用 $k = (j-1)(N-2) + (i-1)$。\n4.  使用 `scipy.sparse.linalg.spsolve` 求解稀疏线性系统。\n5.  重构 $x$ 和 $y$ 的完整 $N \\times N$ 解网格。\n6.  为了效率，对所有 $(N-1) \\times (N-1)$ 个单元的雅可比计算进行向量化。\n7.  如果任何雅可比小于或等于零，则返回 `True`，否则返回 `False`。\n此过程应用于每个指定的测试案例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef run_case(N, s, sigma, A_const):\n    \"\"\"\n    Sets up and solves the Poisson grid generation problem for a single test case.\n\n    Args:\n        N (int): Number of grid points in each direction.\n        s (float): Diagonal scaling parameter.\n        sigma (float): Stabilization parameter.\n        A_const (float): Amplitude for the exact solution.\n\n    Returns:\n        bool: True if the grid is folded, False otherwise.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    n_interior = (N - 2)**2\n\n    # 1. Computational grid and function definitions\n    xi_1d = np.linspace(0.0, 1.0, N)\n    eta_1d = np.linspace(0.0, 1.0, N)\n    # With indexing='xy', array[j, i] corresponds to (xi_i, eta_j)\n    xi_grid, eta_grid = np.meshgrid(xi_1d, eta_1d, indexing='xy')\n\n    def x_exact_func(xi, eta):\n        return xi + A_const * np.sin(2.0 * np.pi * xi) * np.sin(np.pi * eta)\n\n    def y_exact_func(xi, eta):\n        return eta + A_const * np.sin(2.0 * np.pi * eta) * np.sin(np.pi * xi)\n\n    def p_source_func(xi, eta):\n        return -A_const * (5.0 * np.pi**2) * np.sin(2.0 * np.pi * xi) * np.sin(np.pi * eta)\n\n    def q_source_func(xi, eta):\n        return -A_const * (5.0 * np.pi**2) * np.sin(2.0 * np.pi * eta) * np.sin(np.pi * xi)\n\n    # 2. Evaluate boundary conditions and source terms\n    x_exact_grid = x_exact_func(xi_grid, eta_grid)\n    y_exact_grid = y_exact_func(xi_grid, eta_grid)\n\n    P_interior = p_source_func(xi_grid[1:-1, 1:-1], eta_grid[1:-1, 1:-1])\n    Q_interior = q_source_func(xi_grid[1:-1, 1:-1], eta_grid[1:-1, 1:-1])\n\n    # 3. Assemble matrix A and RHS vectors b_x, b_y\n    rows, cols, data = [], [], []\n    b_x = np.zeros(n_interior)\n    b_y = np.zeros(n_interior)\n    \n    # Loop over interior grid points (eta_j, xi_i)\n    # Note: Python loops are (row, col) which is (eta_j, xi_i)\n    for j in range(1, N - 1):  # Index for eta\n        for i in range(1, N - 1):  # Index for xi\n            k = (j - 1) * (N - 2) + (i - 1)  # Row-major 1D index\n\n            rows.append(k)\n            cols.append(k)\n            data.append(4.0 * (s + sigma))\n            \n            b_x[k] = h**2 * P_interior[j-1, i-1]\n            b_y[k] = h**2 * Q_interior[j-1, i-1]\n\n            # Neighbors: west, east, south, north\n            if i == 1: # West boundary\n                b_x[k] += x_exact_grid[j, 0]\n                b_y[k] += y_exact_grid[j, 0]\n            else:\n                rows.append(k); cols.append(k - 1); data.append(-1.0)\n            \n            if i == N - 2: # East boundary\n                b_x[k] += x_exact_grid[j, N - 1]\n                b_y[k] += y_exact_grid[j, N - 1]\n            else:\n                rows.append(k); cols.append(k + 1); data.append(-1.0)\n\n            if j == 1: # South boundary\n                b_x[k] += x_exact_grid[0, i]\n                b_y[k] += y_exact_grid[0, i]\n            else:\n                rows.append(k); cols.append(k - (N - 2)); data.append(-1.0)\n                \n            if j == N - 2: # North boundary\n                b_x[k] += x_exact_grid[N - 1, i]\n                b_y[k] += y_exact_grid[N - 1, i]\n            else:\n                rows.append(k); cols.append(k + (N - 2)); data.append(-1.0)\n\n    A_matrix = coo_matrix((data, (rows, cols)), shape=(n_interior, n_interior)).tocsc()\n    \n    # 4. Solve linear systems\n    try:\n        x_interior_sol = spsolve(A_matrix, b_x)\n        y_interior_sol = spsolve(A_matrix, b_y)\n    except np.linalg.LinAlgError:\n        # A singular matrix implies catastrophic failure of the grid generation.\n        return True\n\n    # 5. Reconstruct full grid solution\n    x_sol = np.copy(x_exact_grid)\n    y_sol = np.copy(y_exact_grid)\n    x_sol[1:-1, 1:-1] = x_interior_sol.reshape((N - 2, N - 2))\n    y_sol[1:-1, 1:-1] = y_interior_sol.reshape((N - 2, N - 2))\n\n    # 6. Check for grid folding by computing cell Jacobians\n    # J_{i,j} = det([x_{i+1,j}-x_{ij}, x_{i,j+1}-x_{ij}], [y_{i+1,j}-y_{ij}, y_{i,j+1}-y_{ij}])\n    # In numpy indexing:\n    # x_{ij} -> x_sol[j,i]\n    # x_{i+1,j} -> x_sol[j,i+1]\n    # x_{i,j+1} -> x_sol[j+1,i]\n    \n    dx_dxi = x_sol[:, 1:] - x_sol[:, :-1]   # shape (N, N-1)\n    dy_dxi = y_sol[:, 1:] - y_sol[:, :-1]\n    dx_deta = x_sol[1:, :] - x_sol[:-1, :]   # shape (N-1, N)\n    dy_deta = y_sol[1:, :] - y_sol[:-1, :]\n\n    # J[j,i] corresponds to cell with bottom-left corner at (i,j)\n    J = dx_dxi[:-1, :] * dy_deta[:, :-1] - dx_deta[:, :-1] * dy_dxi[:-1, :]\n\n    return np.any(J = 0)\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (41, 1.0, 0.0),  # Baseline, diagonally dominant\n        (41, 0.1, 0.0),  # Not diagonally dominant, unstable\n        (41, 0.1, 1.0),  # Stabilized\n        (16, 0.95, 0.0),  # Near-dominance edge case\n    ]\n\n    results = []\n    A_const = 0.158\n    for case in test_cases:\n        N, s, sigma = case\n        is_folded = run_case(N, s, sigma, A_const)\n        results.append(is_folded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```", "id": "3313541"}, {"introduction": "泊松方程中的源项 $P$ 和 $Q$ 不仅仅是数学上的附加项，更是实现高级网格控制的强大工具。本练习将引导您设计一个巧妙的数值实验，其中源项被构造成模拟流场中的一个物理特征——涡对。通过求解这个受控的泊松系统，您将探索网格线如何响应源项的引导而“自适应地”对齐模拟的流线，这揭示了泊松网格生成在为复杂流动问题（如涡旋解析）创建高质量、特征适应网格方面的巨大潜力。[@problem_id:3313605]", "problem": "考虑计算流体力学 (CFD) 中使用的经典椭圆网格生成框架。设计算坐标为均匀格点上的 $\\xi \\in [0,1]$ 和 $\\eta \\in [0,1]$，物理映射为 $(x(\\xi,\\eta), y(\\xi,\\eta))$。通过泊松方程进行的椭圆网格生成方法，通过以下方程规定了坐标函数：\n$$\nx_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta), \\quad y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta),\n$$\n并使用狄利克雷边界条件将边界固定为单位映射，即 $x(\\xi,0)=\\xi$，$x(\\xi,1)=\\xi$，$x(0,\\eta)=0$，$x(1,\\eta)=1$ 以及 $y(\\xi,0)=0$，$y(\\xi,1)=1$，$y(0,\\eta)=\\eta$，$y(1,\\eta)=\\eta$。\n\n你的任务是设计一个实验，在控制函数 $P$ 和 $Q$ 中使用虚拟点源和点汇来模拟一个涡对，然后检验坐标线是否会像所施加的涡流场的流线那样缠绕。该实验必须从第一性原理出发，使用以下经过充分测试的基础：一个位于 $(c_x,c_y)$、环量强度为 $\\Gamma$ 的二维、无粘、不可压缩点涡产生的速度场为\n$$\nu(\\xi,\\eta) = -\\frac{\\Gamma}{2\\pi} \\frac{\\eta-c_y}{(\\xi-c_x)^2 + (\\eta-c_y)^2}, \\quad\nv(\\xi,\\eta) = \\phantom{-}\\frac{\\Gamma}{2\\pi} \\frac{\\xi-c_x}{(\\xi-c_x)^2 + (\\eta-c_y)^2}.\n$$\n为确保数值稳定性和物理真实性，通过将分母替换为 $(\\xi-c_x)^2 + (\\eta-c_y)^2 + \\varepsilon^2$ 来正则化奇点，其中 $\\varepsilon0$ 是一个核尺寸。通过叠加两个强度相等、方向相反（分别为 $+\\Gamma$ 和 $-\\Gamma$）且分别位于 $(c_{1x},c_{1y})$ 和 $(c_{2x},c_{2y})$ 的涡来构建一个涡对。通过对速度分量应用一个标量缩放因子 $k$ 来定义控制函数：\n$$\nP(\\xi,\\eta) = k\\,u_{\\text{pair}}(\\xi,\\eta), \\quad Q(\\xi,\\eta) = k\\,v_{\\text{pair}}(\\xi,\\eta),\n$$\n其中 $(u_{\\text{pair}}, v_{\\text{pair}})$ 是由两个涡引起的正则化速度之和。\n\n在均匀的 $\\xi$–$\\eta$ 网格上实现一个上述泊松方程的有限差分求解器，网格间距为 $h=\\frac{1}{N-1}$，其中 $N\\ge 5$ 为选定的整数。对内部节点使用高斯-赛德尔迭代法来获取 $(x,y)$，以单位映射作为初始猜测。当 $x$ 和 $y$ 在任何内部节点上的最大绝对变化量低于容差 $10^{-6}$，或达到 $10^4$ 次迭代时，以先到者为准，停止迭代。\n\n计算出 $(x,y)$ 后，通过中心差分估计坐标线的局部切线：\n$$\n\\mathbf{t}_\\xi = \\big(x_\\xi, y_\\xi\\big), \\quad \\mathbf{t}_\\eta = \\big(x_\\eta, y_\\eta\\big),\n$$\n并在同一格点上评估正则化的涡对速度 $(u_{\\text{pair}}, v_{\\text{pair}})$。对于每个切线和速度大小超过一个很小阈值（例如 $10^{-12}$）的内部节点，计算 $\\mathbf{t}_\\xi$ 与局部流线方向之间以及 $\\mathbf{t}_\\eta$ 与局部流线方向之间的无符号错位角（以弧度为单位）：\n$$\n\\theta_\\xi = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\xi \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\xi\\|\\,\\|\\mathbf{s}\\|}\\right), \\quad\n\\theta_\\eta = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\eta \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\eta\\|\\,\\|\\mathbf{s}\\|}\\right),\n$$\n其中 $\\mathbf{s} = (u_{\\text{pair}}, v_{\\text{pair}})$ 是局部速度矢量，$\\|\\cdot\\|$ 表示欧几里得范数。通过对所有内部节点求平均，将这些角聚合为一个标量：\n$$\n\\bar{\\theta} = \\frac{1}{2}\\left(\\operatorname{mean}(\\theta_\\xi) + \\operatorname{mean}(\\theta_\\eta)\\right).\n$$\n此外，估计坐标变换的局部雅可比行列式，\n$$\nJ = x_\\xi y_\\eta - x_\\eta y_\\xi,\n$$\n并报告是否在所有内部节点上都满足 $J0$（一个表示没有发生折叠的布尔值）。对内部节点使用中心差分来计算 $x_\\xi$、$x_\\eta$、$y_\\xi$、$y_\\eta$。\n\n设计一个包含三个案例的测试套件来探索其行为：\n- 案例 1（理想路径）：$N=51$，$\\Gamma=1.0$，$\\varepsilon=0.02$，$k=0.02$，$(c_{1x},c_{1y})=(0.35,0.50)$，$(c_{2x},c_{2y})=(0.65,0.50)$。\n- 案例 2（近拉普拉斯基线）：$N=51$，$\\Gamma=1.0$，$\\varepsilon=0.02$，$k=0.0$，$(c_{1x},c_{1y})=(0.35,0.50)$，$(c_{2x},c_{2y})=(0.65,0.50)$。\n- 案例 3（更强控制）：$N=51$，$\\Gamma=1.0$，$\\varepsilon=0.015$，$k=0.08$，$(c_{1x},c_{1y})=(0.35,0.50)$，$(c_{2x},c_{2y})=(0.65,0.50)$。\n\n你的程序必须为每个案例求解网格，计算以弧度为单位的 $\\bar{\\theta}$ 和表示是否所有内部节点的 $J0$ 的布尔值 $\\text{all\\_positive\\_Jacobian}$，然后生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序如下：\n$$\n[\\bar{\\theta}_1,\\text{all\\_positive\\_Jacobian}_1,\\bar{\\theta}_2,\\text{all\\_positive\\_Jacobian}_2,\\bar{\\theta}_3,\\text{all\\_positive\\_Jacobian}_3].\n$$\n角度必须以弧度报告。不允许外部输入，程序必须自包含运行。", "solution": "该问题要求在一个单位正方形上数值求解一组用于椭圆网格生成的两个泊松方程，并随后对生成的网格几何进行分析。该过程分为四个主要阶段：问题构建、离散化、数值求解和后处理分析。\n\n物理坐标 $(x, y)$ 将被确定为计算坐标 $(\\xi, \\eta)$ 的函数，其中 $(\\xi, \\eta)$ 在单位正方形 $[0,1] \\times [0,1]$ 上形成一个均匀的格点。控制方程是一对泊松方程：\n$$\n\\nabla^2 x = x_{\\xi\\xi} + x_{\\eta\\eta} = P(\\xi,\\eta)\n$$\n$$\n\\nabla^2 y = y_{\\xi\\xi} + y_{\\eta\\eta} = Q(\\xi,\\eta)\n$$\n函数 $P(\\xi,\\eta)$ 和 $Q(\\xi,\\eta)$ 是用于影响网格特性的控制函数。边界条件是狄利克雷类型，将计算正方形的边界恒等地映射到物理正方形的边界：\n$$\n\\begin{align*}\nx(\\xi,0) = \\xi,  x(\\xi,1) = \\xi,  x(0,\\eta) = 0,  x(1,\\eta) = 1 \\\\\ny(\\xi,0) = 0,  y(\\xi,1) = 1,  y(0,\\eta) = \\eta,  y(1,\\eta) = \\eta\n\\end{align*}\n$$\n控制函数由一个正则化涡对的速度场构建。一个位于 $(c_x, c_y)$、强度为 $\\Gamma$、正则化核尺寸为 $\\varepsilon$ 的单涡的速度场 $(u,v)$ 为：\n$$\n u(\\xi,\\eta) = -\\frac{\\Gamma}{2\\pi} \\frac{\\eta-c_y}{(\\xi-c_x)^2 + (\\eta-c_y)^2 + \\varepsilon^2}, \\quad\n v(\\xi,\\eta) = \\phantom{-}\\frac{\\Gamma}{2\\pi} \\frac{\\xi-c_x}{(\\xi-c_x)^2 + (\\eta-c_y)^2 + \\varepsilon^2}\n$$\n涡对场 $(u_{\\text{pair}}, v_{\\text{pair}})$ 是两个此类涡的叠加：一个强度为 $+\\Gamma$ 位于 $(c_{1x},c_{1y})$，另一个强度为 $-\\Gamma$ 位于 $(c_{2x},c_{2y})$。然后，控制函数被定义为 $P(\\xi,\\eta) = k\\,u_{\\text{pair}}(\\xi,\\eta)$ 和 $Q(\\xi,\\eta) = k\\,v_{\\text{pair}}(\\xi,\\eta)$，其中 $k$ 是一个缩放因子。\n\n为了数值求解该系统，我们将计算域离散化为一个 $N \\times N$ 个点的均匀网格。两个方向的网格间距均为 $h = 1/(N-1)$。设 $x_{i,j} = x(i h, j h)$ 和 $y_{i,j} = y(i h, j h)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。拉普拉斯算子 $\\nabla^2$ 在每个内部节点 $(i,j)$ 处使用二阶中心差分格式进行近似：\n$$\n\\nabla^2 x |_{i,j} \\approx \\frac{x_{i+1,j} - 2x_{i,j} + x_{i-1,j}}{h^2} + \\frac{x_{i,j+1} - 2x_{i,j} + x_{i,j-1}}{h^2}\n$$\n将此应用于 $x$ 的泊松方程，得到离散方程：\n$$\nx_{i+1,j} + x_{i-1,j} + x_{i,j+1} + x_{i,j-1} - 4x_{i,j} = h^2 P_{i,j}\n$$\n一个类似的方程对 $y_{i,j}$ 也成立。\n\n由此产生的针对内部节点的线性代数方程组使用高斯-赛德尔迭代法求解。从一个初始猜测（即单位映射，$x_{i,j} = i h$，$y_{i,j} = j h$）开始，每个内部节点 $(i,j)$ 的值使用其邻居的最新计算值进行更新。在第 $k+1$ 次迭代中，$x_{i,j}$ 的迭代更新公式为：\n$$\nx_{i,j}^{(k+1)} = \\frac{1}{4} \\left( x_{i+1,j}^{(k)} + x_{i-1,j}^{(k+1)} + x_{i,j+1}^{(k)} + x_{i,j-1}^{(k+1)} - h^2 P_{i,j} \\right)\n$$\n对 $y_{i,j}$ 执行类似的更新。重复此过程，直到 $x$ 和 $y$ 在任何内部节点的值在连续迭代之间的最大绝对变化量低于 $10^{-6}$ 的容差，或达到最大 $10^4$ 次迭代为止。\n\n收敛后，我们分析生成的网格。首先，我们使用二阶中心差分在每个内部节点计算坐标线的切线 $\\mathbf{t}_\\xi = (x_\\xi, y_\\xi)$ 和 $\\mathbf{t}_\\eta = (x_\\eta, y_\\eta)$：\n$$\nx_\\xi \\approx \\frac{x_{i+1,j} - x_{i-1,j}}{2h}, \\quad x_\\eta \\approx \\frac{x_{i,j+1} - x_{i,j-1}}{2h}, \\quad \\text{对于 } y \\text{ 也类似}\n$$\n计算这些切线与局部流线方向矢量 $\\mathbf{s} = (u_{\\text{pair}}, v_{\\text{pair}})$ 之间的无符号错位角 $\\theta_\\xi$ 和 $\\theta_\\eta$：\n$$\n\\theta_\\xi = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\xi \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\xi\\|\\,\\|\\mathbf{s}\\|}\\right), \\quad \\theta_\\eta = \\arccos\\left(\\frac{\\left|\\mathbf{t}_\\eta \\cdot \\mathbf{s}\\right|}{\\|\\mathbf{t}_\\eta\\|\\,\\|\\mathbf{s}\\|}\\right)\n$$\n这些仅在矢量大小超过阈值 $10^{-12}$ 的节点上计算。然后，平均错位角 $\\bar{\\theta}$ 计算为 $\\bar{\\theta} = \\frac{1}{2}(\\text{mean}(\\theta_\\xi) + \\text{mean}(\\theta_\\eta))$。\n最后，我们在所有内部节点上评估变换的雅可比行列式 $J = x_\\xi y_\\eta - x_\\eta y_\\xi$。处处为正的雅可比行列式 ($J0$) 意味着网格没有自我折叠，这是有效网格的一个关键质量指标。根据此检查报告一个布尔标志。对三个不同的测试案例执行整个过程，以探究控制函数强度的影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (N, Gamma, epsilon, k, c1, c2)\n    test_cases = [\n        # Case 1: happy path\n        (51, 1.0, 0.02, 0.02, (0.35, 0.50), (0.65, 0.50)),\n        # Case 2: near-Laplace baseline\n        (51, 1.0, 0.02, 0.0, (0.35, 0.50), (0.65, 0.50)),\n        # Case 3: stronger control\n        (51, 1.0, 0.015, 0.08, (0.35, 0.50), (0.65, 0.50)),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        bar_theta, all_positive_jacobian = run_case(*case_params)\n        results.append(f\"{bar_theta:.12f}\")\n        results.append(str(all_positive_jacobian).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_case(N, Gamma, epsilon, k, c1, c2):\n    \"\"\"\n    Solves the grid generation problem for a single set of parameters.\n    \"\"\"\n    # Unpack vortex centers\n    c1x, c1y = c1\n    c2x, c2y = c2\n\n    # Grid setup\n    h = 1.0 / (N - 1)\n    xi_coords = np.linspace(0.0, 1.0, N)\n    eta_coords = np.linspace(0.0, 1.0, N)\n    XI, ETA = np.meshgrid(xi_coords, eta_coords, indexing='ij')\n\n    # --- Step 1: Compute source terms P and Q ---\n    def vortex_velocity(grid_XI, grid_ETA, G, center, eps):\n        cx_v, cy_v = center\n        den = (grid_XI - cx_v)**2 + (grid_ETA - cy_v)**2 + eps**2\n        u = -(G / (2 * np.pi)) * (grid_ETA - cy_v) / den\n        v =  (G / (2 * np.pi)) * (grid_XI - cx_v) / den\n        return u, v\n\n    u1, v1 = vortex_velocity(XI, ETA, Gamma, c1, epsilon)\n    u2, v2 = vortex_velocity(XI, ETA, -Gamma, c2, epsilon)\n    \n    u_pair = u1 + u2\n    v_pair = v1 + v2\n    \n    P = k * u_pair\n    Q = k * v_pair\n\n    # --- Step 2: Solve the Poisson equations using Gauss-Seidel ---\n    x = XI.copy()\n    y = ETA.copy()\n\n    tol = 1e-6\n    max_iter = 10000\n    h2 = h**2\n    \n    for _ in range(max_iter):\n        x_old = x.copy()\n        y_old = y.copy()\n        \n        # Explicit point-wise Gauss-Seidel iteration over interior nodes\n        for i in range(1, N - 1):\n            for j in range(1, N - 1):\n                x[i, j] = 0.25 * (x[i+1, j] + x[i-1, j] + x[i, j+1] + x[i, j-1] - h2 * P[i, j])\n                y[i, j] = 0.25 * (y[i+1, j] + y[i-1, j] + y[i, j+1] + y[i, j-1] - h2 * Q[i, j])\n\n        # Check for convergence\n        max_change = np.max([np.abs(x - x_old), np.abs(y - y_old)])\n        if max_change  tol:\n            break\n\n    # --- Step 3: Post-processing and analysis ---\n    # Compute derivatives on interior nodes using centered differences\n    x_xi = (x[1:-1, 2:] - x[1:-1, :-2]) / (2 * h) # Swapped indexing to match standard math notation\n    x_eta = (x[2:, 1:-1] - x[:-2, 1:-1]) / (2 * h)\n    y_xi = (y[1:-1, 2:] - y[1:-1, :-2]) / (2 * h)\n    y_eta = (y[2:, 1:-1] - y[:-2, 1:-1]) / (2 * h)\n\n    # Calculate Jacobian determinant and check for folding\n    J = x_xi * y_eta - x_eta * y_xi\n    all_positive_jacobian = np.all(J > 0)\n\n    # Calculate misalignment angles\n    s_u = u_pair[1:-1, 1:-1]\n    s_v = v_pair[1:-1, 1:-1]\n    \n    # Restrict derivatives to the same interior grid\n    s_u = s_u[:,1:-1]\n    s_v = s_v[:,1:-1]\n    \n    # Calculate magnitudes of tangent and streamline vectors\n    norm_t_xi = np.sqrt(x_xi**2 + y_xi**2)\n    norm_t_eta = np.sqrt(x_eta**2 + y_eta**2)\n    norm_s = np.sqrt(s_u**2 + s_v**2)\n\n    # Filter nodes where magnitudes are too small\n    mag_tol = 1e-12\n    valid_mask = (norm_t_xi > mag_tol)  (norm_t_eta > mag_tol)  (norm_s > mag_tol)\n    \n    # Compute dot products only for valid nodes\n    dot_xi_s = x_xi[valid_mask] * s_u[valid_mask] + y_xi[valid_mask] * s_v[valid_mask]\n    dot_eta_s = x_eta[valid_mask] * s_u[valid_mask] + y_eta[valid_mask] * s_v[valid_mask]\n\n    # Filtered norms\n    norm_t_xi_f = norm_t_xi[valid_mask]\n    norm_t_eta_f = norm_t_eta[valid_mask]\n    norm_s_f = norm_s[valid_mask]\n\n    # Calculate angles, clipping to avoid domain errors with arccos\n    cos_arg_xi = np.clip(np.abs(dot_xi_s) / (norm_t_xi_f * norm_s_f), -1.0, 1.0)\n    cos_arg_eta = np.clip(np.abs(dot_eta_s) / (norm_t_eta_f * norm_s_f), -1.0, 1.0)\n\n    theta_xi = np.arccos(cos_arg_xi)\n    theta_eta = np.arccos(cos_arg_eta)\n    \n    # Compute the final average misalignment angle\n    if theta_xi.size == 0 and theta_eta.size == 0:\n        bar_theta = 0.0\n    else:\n        mean_xi = np.mean(theta_xi) if theta_xi.size > 0 else 0.0\n        mean_eta = np.mean(theta_eta) if theta_eta.size > 0 else 0.0\n        bar_theta = 0.5 * (mean_xi + mean_eta)\n\n    return bar_theta, all_positive_jacobian\n\nsolve()\n```", "id": "3313605"}]}