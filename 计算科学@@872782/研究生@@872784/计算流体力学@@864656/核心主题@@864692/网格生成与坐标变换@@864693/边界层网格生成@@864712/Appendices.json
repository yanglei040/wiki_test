{"hands_on_practices": [{"introduction": "边界层网格生成的一个核心挑战是在满足近壁面分辨率和总厚度覆盖这两个相互冲突的要求的同时，最小化网格单元的总数。这个练习通过一个约束优化问题，为您提供了选择层数和增长率的数学框架。通过推导KKT条件并求解一个理想化的连续模型，您将深入理解在计算流体动力学（CFD）中如何基于第一性原理，对这些关键的网格参数进行权衡与决策[@problem_id:3296993]。", "problem": "需要使用一个壁面法向层厚度呈几何级数增长的方式来生成一个边界层网格。设第一层的厚度为 $\\Delta y_{1}$，第 $i$ 层的厚度为 $\\Delta y_{i} = \\Delta y_{1}\\,r^{i-1}$，其中增长因子 $r1$。那么，一个包含 $N_{\\ell}$ 层的网格柱的总厚度为 $$\\sum_{i=1}^{N_{\\ell}} \\Delta y_{i} = \\Delta y_{1}\\,\\frac{r^{N_{\\ell}} - 1}{r - 1}.$$ 您的任务是最小化与壁面法向分层相关的自由度（DOF），在此网格柱中，自由度与层数 $N_{\\ell}$ 成正比。同时需要满足计算流体动力学边界层网格生成中使用的两个设计约束：\n\n1. 对第一个单元高度的壁面单位约束，由基于摩擦速度的壁面单位 $y^{+}$ 定义，要求 $y^{+}_{1} \\leq y^{+}_{\\max}$，其中 $$y^{+}_{1} = \\frac{\\Delta y_{1}\\,u_{\\tau}}{\\nu},$$ 式中 $u_{\\tau}$ 为摩擦速度，$\\nu$ 为运动粘度。\n\n2. 边界层网格的总壁面法向覆盖范围必须达到或超过一个目标厚度 $\\delta$，即 $$\\sum_{i=1}^{N_{\\ell}} \\Delta y_{i} \\geq \\delta.$$\n\n此外，为了保证网格质量，增长因子受一个给定的上限 $r_{\\max}1$ 的限制（即 $1", "solution": "在尝试求解之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n-   第 $i$ 层的厚度为 $\\Delta y_{i} = \\Delta y_{1}\\,r^{i-1}$，其中 $r1$ 是增长因子。\n-   $N_{\\ell}$ 层的总厚度为 $\\sum_{i=1}^{N_{\\ell}} \\Delta y_{i} = \\Delta y_{1}\\,\\frac{r^{N_{\\ell}} - 1}{r - 1}$。\n-   目标是最小化层数 $N_{\\ell}$。\n-   约束 1：壁面单位约束，$y^{+}_{1} \\leq y^{+}_{\\max}$，其中 $y^{+}_{1} = \\frac{\\Delta y_{1}\\,u_{\\tau}}{\\nu}$。\n-   约束 2：总厚度约束，$\\sum_{i=1}^{N_{\\ell}} \\Delta y_{i} \\geq \\delta$。\n-   约束 3：增长因子上界，$r \\leq r_{\\max}$，其中 $r1$。\n-   已知正常数：摩擦速度 $u_{\\tau}$，运动粘度 $\\nu$，最大壁面单位 $y^{+}_{\\max}$，目标厚度 $\\delta$，以及最大增长因子 $r_{\\max}  1$。\n-   层数 $N_{\\ell}$ 从 $\\mathbb{N}$ 放宽至 $\\mathbb{R}_{+}$。\n-   决策变量是 $N_{\\ell}$ 和 $r$。\n-   $\\Delta y_{1}$ 被视为由 $y^{+}$ 约束确定。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题使用了边界层网格划分中层厚度呈几何级数增长的标准且正确的公式，这是计算流体动力学（CFD）中的常见做法。$y^{+}$ 约束是壁面解析湍流模型中的一个基本概念。该问题在科学上是合理的。\n-   **适定性：** 该问题定义了一个清晰的目标函数（最小化 $N_{\\ell}$）和一组明确的约束条件。将 $N_{\\ell}$ 放宽为实数使得该问题适用于像 KKT 这样的连续优化方法。解的存在性和唯一性取决于问题参数，这将在求解过程中讨论，但其结构是适定的。\n-   **客观性：** 语言正式、精确，没有主观陈述。\n-   问题是自洽的，所有必要的参数都已定义。约束条件之间不矛盾。\n\n### 步骤 3：结论与行动\n问题被判定为有效。将提供解答。\n\n### 解答的构建与推导\n\n任务是求解一个约束优化问题。目标是最小化层数 $N_{\\ell}$。决策变量是 $N_{\\ell} \\in \\mathbb{R}_{+}$ 和增长因子 $r \\in (1, r_{\\max}]$。\n\n该优化问题可以表述为：\n最小化 $N_{\\ell}$\n约束条件为：\n1.  $\\frac{\\Delta y_{1}\\,u_{\\tau}}{\\nu} \\leq y^{+}_{\\max}$\n2.  $\\Delta y_{1}\\,\\frac{r^{N_{\\ell}} - 1}{r - 1} \\geq \\delta$\n3.  $1  r \\leq r_{\\max}$\n\n为了最小化 $N_{\\ell}$，我们应该使每一层尽可能厚。这意味着我们应该为第一层厚度 $\\Delta y_{1}$ 选择允许的最大值。从约束（1）中，通过将不等式设为等式，可以找到 $\\Delta y_{1}$ 的上界：\n$$ \\frac{\\Delta y_{1}\\,u_{\\tau}}{\\nu} = y^{+}_{\\max} \\implies \\Delta y_{1} = \\frac{y^{+}_{\\max} \\nu}{u_{\\tau}} $$\n使用这个最大的 $\\Delta y_{1}$ 将有助于用最少的层数满足总厚度要求（约束 2）。通过做出这个选择，$\\Delta y_{1}$ 不再是一个变量，而是一个由问题参数确定的固定值。\n\n同样，对于任何给定的 $r$ 和 $\\Delta y_1$，为了最小化 $N_{\\ell}$，由公式生成的总厚度必须尽可能大。这意味着总厚度约束应该是活动的，即取等式：\n$$ \\sum_{i=1}^{N_{\\ell}} \\Delta y_{i} = \\delta $$\n将 $\\Delta y_1$ 和求和的表达式代入此等式，得到：\n$$ \\left( \\frac{y^{+}_{\\max} \\nu}{u_{\\tau}} \\right) \\frac{r^{N_{\\ell}} - 1}{r - 1} = \\delta $$\n这个方程隐式地将 $N_{\\ell}$ 定义为 $r$ 的函数。我们可以解出 $N_{\\ell}(r)$：\n$$ \\frac{r^{N_{\\ell}} - 1}{r - 1} = \\frac{\\delta u_{\\tau}}{y^{+}_{\\max} \\nu} $$\n我们定义一个无量纲常数 $C = \\frac{\\delta u_{\\tau}}{y^{+}_{\\max} \\nu}$。这个常数代表目标总厚度 $\\delta$ 与允许的最大第一层厚度 $\\Delta y_1$ 之比。方程变为：\n$$ \\frac{r^{N_{\\ell}} - 1}{r - 1} = C $$\n求解 $N_{\\ell}$：\n$$ r^{N_{\\ell}} - 1 = C(r-1) $$\n$$ r^{N_{\\ell}} = 1 + C(r-1) $$\n$$ N_{\\ell} \\ln(r) = \\ln(1 + C(r-1)) $$\n$$ N_{\\ell}(r) = \\frac{\\ln(1 + C(r-1))}{\\ln(r)} $$\n优化问题已经简化为在区间 $r \\in (1, r_{\\max}]$ 上寻找函数 $N_{\\ell}(r)$ 的最小值。为了找到最小值，我们分析 $N_{\\ell}(r)$ 对 $r$ 的导数：\n$$ \\frac{dN_{\\ell}}{dr} = \\frac{\\frac{C}{1+C(r-1)}\\ln(r) - \\ln(1+C(r-1))\\frac{1}{r}}{\\left(\\ln(r)\\right)^2} $$\n导数的符号由分子的符号决定。\n对于一个具有多层的非平凡边界层网格，总厚度 $\\delta$ 必须大于第一层厚度 $\\Delta y_1$。这个物理要求意味着 $\\frac{\\delta}{\\Delta y_1}  1$，即 $C1$。我们在此假设下进行，这确保了问题在物理上是有意义且适定的。\n\n我们来分析当 $C1$ 时导数的符号。考虑函数 $k(r) = r^C - (1+C(r-1))$，其中 $r1$。它在 $r=1$ 处的值是 $k(1)=1^C - (1+0) = 0$。其导数为 $k'(r) = Cr^{C-1} - C = C(r^{C-1}-1)$。因为 $C1$ 且 $r1$，我们有 $C-10$ 且 $r^{C-1}1$，这意味着 $k'(r)0$。因此，$k(r)$ 是一个在 $r1$ 上严格递增的函数。由于 $k(1)=0$，我们有对于所有 $r1$，$k(r)0$。\n不等式 $r^C  1+C(r-1)$ 对于 $r1$ 成立，这意味着（通过取对数）：\n$$ C \\ln(r)  \\ln(1+C(r-1)) $$\n两边同除以 $\\ln(r)0$，我们得到 $C  \\frac{\\ln(1+C(r-1))}{\\ln(r)} = N_{\\ell}(r)$。虽然这提供了一个界限，但我们需要导数 $\\frac{dN_{\\ell}}{dr}$ 的符号。导数的分子与 $h(r) = Cr\\ln(r) - (1+C(r-1))\\ln(1+C(r-1))$ 成正比。对 $h(r)$ 的分析表明，当 $C1$ 和 $r1$ 时，它是负的。一个更简单的论证基于凸分析中的一个已知结果：对于一个凹函数 $f(x)$ 且 $f(0)=0$，函数 $f(x)/x$ 是递减的。将此应用于相关函数可以揭示，当 $C1$ 时，$N_{\\ell}(r)$ 是 $r$ 的单调递减函数。\n\n由于 $N_{\\ell}(r)$ 在区间 $(1, r_{\\max}]$ 上是单调递减函数，其最小值将在区间的右边界处取得，即在 $r = r_{\\max}$ 处。\n因此，最优增长因子为 $r^* = r_{\\max}$。\n\n最优层数 $N_{\\ell}^*$ 通过将 $r=r_{\\max}$ 代入 $N_{\\ell}(r)$ 的表达式得到：\n$$ N_{\\ell}^* = N_{\\ell}(r_{\\max}) = \\frac{\\ln(1 + C(r_{\\max}-1))}{\\ln(r_{\\max})} $$\n最后，将 $C$ 的定义代回表达式，得到最优连续层数的闭式解：\n$$ N_{\\ell}^* = \\frac{\\ln\\left(1 + \\frac{\\delta u_{\\tau}}{y^{+}_{\\max} \\nu} (r_{\\max} - 1)\\right)}{\\ln(r_{\\max})} $$\n这个表达式给出了满足所有设计约束所需的最小层数（作为连续变量）。", "answer": "$$\\boxed{\\frac{\\ln\\left(1 + \\frac{\\delta u_{\\tau}}{y^{+}_{\\max} \\nu} (r_{\\max} - 1)\\right)}{\\ln(r_{\\max})}}$$", "id": "3296993"}, {"introduction": "在真实的复杂几何中，例如凹角区域，标准的网格拉伸方法可能会失效，导致网格层发生碰撞和退化，严重影响计算的稳定性和准确性。这个高级实践练习要求您设计并实现一种稳健的层碰撞与合并算法，以应对这一挑战。您将通过一个迭代的、基于优化的方法来调整层厚度分布，从而在保持总边界层厚度不变的同时，满足各向异性比率的约束，最终生成高质量的网格[@problem_id:3297046]。", "problem": "您的任务是设计并实现一个基于数学原理的算法层碰撞与合并策略，用于计算流体动力学中凹角附近的二维边界层网格生成。目标是保持壁面法向边界层总厚度不变，同时限制过渡区内的各向异性比，从而在相邻层可能发生碰撞时确保网格质量的稳健性。\n\n假设一个平面分段光滑壁面，在两壁面段相交处有一个凹角，其内向单位法向量分别为 $\\mathbf{n}_1$ 和 $\\mathbf{n}_2$。考虑一个二维拉伸边界层网格，该网格通过从壁面沿法线方向以名义上的几何级数厚度推进 $N$ 层而构建。设边界层总厚度为 $\\Delta_{\\text{BL}}$，名义层数为 $N$，名义几何增长因子为 $r1$。名义壁面法向层厚度序列定义为首项为 $t_1$ 的几何级数，满足\n$$\n\\sum_{k=1}^{N} t_1 r^{k-1} = \\Delta_{\\text{BL}},\n$$\n且名义层厚度为\n$$\nt_k^{(0)} = t_1 r^{k-1}, \\quad k = 1,2,\\dots,N.\n$$\n设 $\\mathbf{n}_1$ 与 $\\mathbf{n}_2$ 之间的夹角为 $\\phi \\in (0, \\pi]$（以弧度为单位），因此 $\\mathbf{n}_1 \\cdot \\mathbf{n}_2 = \\cos \\phi$。沿每个法线方向，在壁面法向距离 $y$ 处，拉伸前缘之间的间距由它们差值的范数给出：\n$$\nw(y) = \\| (\\mathbf{c} + y\\mathbf{n}_1) - (\\mathbf{c} + y\\mathbf{n}_2) \\| = y \\| \\mathbf{n}_1 - \\mathbf{n}_2 \\| = y \\sqrt{2 - 2 \\cos \\phi},\n$$\n其中 $\\mathbf{c}$ 是角点，每侧可用的几何切向宽度为 $w(y)/2$。设期望的壁面平行（切向）网格尺寸为 $s_w0$，并将过渡区内为防止碰撞的每侧有效切向尺寸定义为\n$$\ns_{\\text{eff}}(y) = \\min\\left(s_w, \\frac{w(y)}{2}\\right) = \\min\\left(s_w, \\frac{y}{2}\\sqrt{2 - 2 \\cos \\phi}\\right).\n$$\n\n为限制局部网格度量的各向异性比，要求切向尺寸与壁面法向尺寸之比遵循\n$$\n\\frac{\\lambda_{\\max}}{\\lambda_{\\min}} \\le A_{\\max}, \\quad \\text{with} \\quad \\frac{s_{\\text{eff}}(y)}{t_k} \\le A_{\\max},\n$$\n因此，每层的厚度必须满足下界\n$$\nt_k \\ge b_k := \\frac{s_{\\text{eff}}(y_k)}{A_{\\max}},\n$$\n其中 $y_k = \\sum_{j=1}^{k} t_j$ 是直到第 $k$ 层的累积壁面法向距离。\n\n设计一个稳健的碰撞/合并策略，满足以下条件：\n\n1.  精确保持边界层总厚度：\n$$\n\\sum_{k=1}^{M} t_k = \\Delta_{\\text{BL}},\n$$\n其中 $M$ 是可能合并后的最终层数（$M \\le N$）。\n\n2.  强制执行各向异性界限\n$$\nt_k \\ge b_k = \\frac{1}{A_{\\max}} \\min\\left(s_w, \\frac{y_k}{2}\\sqrt{2 - 2 \\cos \\phi} \\right),\n$$\n在过渡区的所有层中。\n\n3.  在所有满足上述约束的向量中，以最小二乘意义最小化与名义几何厚度 $t_k^{(0)}$ 的偏差。\n\n为实现这些要求，请从第一性原理出发：\n\n-   使用拉伸法线之间的几何间距公式，推导受碰撞限制的切向尺寸 $s_{\\text{eff}}(y)$。\n-   构建约束优化问题，以调整名义厚度序列，使其在保持总厚度的同时满足累积下界。\n-   使用拉格朗日乘子，将名义厚度向量投影到带有下界的单纯形上，并通过迭代来处理 $b_k$ 对累积高度 $y_k$ 的依赖性。\n\n如果对于给定的 $N$ ，下界约束不可行（即，如果 $\\sum_{k=1}^{N} b_k  \\Delta_{\\text{BL}}$），则通过减少层数 $M$ （通过合并外层）来执行稳健的合并，直到满足可行性，然后重新计算名义几何序列并重复投影过程。合并不得改变 $\\Delta_{\\text{BL}}$。\n\n您的程序必须实现此算法，以计算每个测试用例的最终层厚度向量 $\\{t_k\\}_{k=1}^{M}$。所有厚度必须以米为单位，表示为小数。角度必须解释为弧度。最终输出必须是单行，包含一个由方括号括起来的、逗号分隔的浮点数列表的列表。\n\n测试套件。使用以下三组科学上真实的参数集：\n\n-   案例1（理想情况）：\n    -   $\\Delta_{\\text{BL}} = 0.005$ 米，\n    -   $N = 12$，\n    -   $r = 1.18$，\n    -   $s_w = 0.0015$ 米，\n    -   $A_{\\max} = 10$，\n    -   $\\phi = 2.6179938779914944$ 弧度（即 $150^\\circ$）。\n-   案例2（强凹性，有显著合并压力但可行）：\n    -   $\\Delta_{\\text{BL}} = 0.006$ 米，\n    -   $N = 20$，\n    -   $r = 1.25$，\n    -   $s_w = 0.002$ 米，\n    -   $A_{\\max} = 8$，\n    -   $\\phi = 3.0$ 弧度。\n-   案例3（由于各向异性界限需要进行激进合并的边缘情况）：\n    -   $\\Delta_{\\text{BL}} = 0.004$ 米，\n    -   $N = 18$，\n    -   $r = 1.22$，\n    -   $s_w = 0.0025$ 米，\n    -   $A_{\\max} = 3$，\n    -   $\\phi = 3.1$ 弧度。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表中的每个元素本身也是一个列表，表示对应测试用例的最终层厚度（单位为米），顺序为案例1、案例2、案例3。例如，\n\"[ [t11,t12,...], [t21,t22,...], [t31,t32,...] ]\"\n不带空格的格式是可接受的，但您的确切输出应遵循 Python 列表字面量格式，使用逗号分隔条目，并用方括号括起嵌套列表。", "solution": "所提出的问题是一个有效且适定的约束优化问题，源于计算流体动力学（CFD）领域，具体涉及边界层网格生成。所有提供的参数和约束都具有科学依据、数学上一致且物理上真实。该问题旨在设计一种算法，用于调整边界层网格层厚度的名义分布，以满足凹角附近的几何和网格质量约束，同时保持边界层总厚度不变。\n\n问题的核心是找到一个层厚度向量 $T = [t_1, t_2, \\dots, t_M]$，以解决：\n\n**最小化：**\n$$f(T) = \\sum_{k=1}^{M} (t_k - t_k^{(0)})^2$$\n\n**约束条件：**\n1.  **总厚度保持：** $\\sum_{k=1}^{M} t_k = \\Delta_{\\text{BL}}$\n2.  **各向异性界限：** $t_k \\ge b_k$，对于 $k=1, \\dots, M$\n\n其中 $M \\le N$ 是最终层数，$t_k^{(0)}$ 是 $M$ 层的几何级数名义厚度，$b_k$ 是一个取决于累积厚度 $y_k = \\sum_{j=1}^{k} t_j$ 的下界。下界由以下公式给出：\n$$b_k = \\frac{s_{\\text{eff}}(y_k)}{A_{\\max}} = \\frac{1}{A_{\\max}} \\min\\left(s_w, \\frac{y_k}{2}\\sqrt{2 - 2 \\cos \\phi} \\right)$$\n下界 $b_k$ 对解向量 $T$ 的依赖性使之成为一个非线性问题。问题陈述建议采用迭代方法，我们将对此进行形式化。\n\n整个算法由两个嵌套循环组成：一个外循环用于处理层的合并以确保可行性，一个内循环使用定点迭代法为固定层数求解约束优化问题。\n\n**外循环：合并策略**\n\n我们从名义层数 $M=N$ 开始。如果所需的最小厚度之和超过了可用的总厚度，则约束可能是不可行的。我们必须首先检查可行性。一个实际的检查方法是使用名义分布 $t_k^{(0)}$ 来估计累积高度 $y_k^{(0)}$，从而估计下界 $b_k^{\\text{est}}$。如果 $\\sum_{k=1}^{M} b_k^{\\text{est}}  \\Delta_{\\text{BL}}$，则该配置被视为不可行。在这种情况下，我们通过减少层数 $M \\leftarrow M-1$ 来合并最外层，并使用减少层数后的新名义分布重新评估。此过程持续进行，直到找到一个可行的 $M$。\n\n**内循环：用于优化的定点迭代**\n\n对于一个可行的层数 $M$，我们求解该优化问题。由于 $b_k$ 依赖于 $T$ 而产生的非线性问题通过定点迭代来处理。设 $T^{(i)}$ 为第 $i$ 次迭代时的厚度向量。\n\n1.  **初始化：** 以名义分布作为初始猜测，即 $T^{(0)} = t^{(0)}$。对于 $M$ 层和增长因子 $r$ 的名义分布为 $t_k^{(0)} = t_1 r^{k-1}$，其中 $t_1 = \\Delta_{\\text{BL}} (r-1)/(r^M-1)$。\n\n2.  **迭代：** 对于每次迭代 $i+1$：\n    a.  **更新边界：** 使用前一个解向量 $T^{(i)}$ 的累积高度计算下界 $b_k^{(i)}$：$y_k^{(i)} = \\sum_{j=1}^k t_j^{(i)}$。\n    b.  **求解 QP：** 找到向量 $T^{(i+1)}$，使其在满足线性约束 $\\sum_{k=1}^M t_k = \\Delta_{\\text{BL}}$ 和 $t_k \\ge b_k^{(i)}$ 的条件下最小化 $\\sum_{k=1}^M (t_k - t_k^{(0)})^2$。\n    c.  **检查收敛性：** 重复此过程，直到变化量 $\\|T^{(i+1)} - T^{(i)}\\|$ 小于预设的容差。\n\n**求解二次规划子问题**\n\n内循环的核心是求解约束二次规划问题。这等效于将点 $t^{(0)}$ 投影到由约束定义的可行集上。使用 Karush-Kuhn-Tucker (KKT) 条件，解可以用与等式约束 $\\sum t_k = \\Delta_{\\text{BL}}$ 相关联的单个拉格朗日乘子 $\\lambda$ 来表示。最优厚度由下式给出：\n$$t_k = \\max(b_k, t_k^{(0)} + \\lambda)$$\n其中固定的下界 $b_k$ 来自前一次定点迭代。将此代入总厚度约束，得到一个关于 $\\lambda$ 的非线性方程：\n$$g(\\lambda) = \\sum_{k=1}^{M} \\max(b_k, t_k^{(0)} + \\lambda) - \\Delta_{\\text{BL}} = 0$$\n$g(\\lambda)$ 函数是连续的、分段线性的且单调递增。只要问题是可行的（即 $\\sum b_k \\le \\Delta_{\\text{BL}}$），就保证存在唯一的 $\\lambda$ 根。这个根可以使用像 Brent-Dekker 方法这样的数值求根算法高效地找到。一旦找到 $\\lambda$，就计算更新后的厚度向量。\n\n对每个提供的测试用例都实施这个迭代过程。该算法由于其合并策略而具有稳健性，并且在数学上是可靠的，其基础是凸优化原理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        (0.005, 12, 1.18, 0.0015, 10, 2.6179938779914944),\n        # Case 2 (strong concavity)\n        (0.006, 20, 1.25, 0.002, 8, 3.0),\n        # Case 3 (aggressive merging)\n        (0.004, 18, 1.22, 0.0025, 3, 3.1)\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _calculate_thicknesses(params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The format [list1,list2] is desired, which str() on a list of lists produces.\n    # The template's format f\"[{','.join(map(str, results))}]\" leads to '[list1],[list2]'\n    # which is also acceptable per problem spec, so we adhere to template.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef _calculate_thicknesses(params):\n    \"\"\"\n    Calculates the final layer thicknesses for a single test case.\n    \n    This function implements a layer-collision and merging strategy by\n    solving a constrained optimization problem iteratively. It ensures\n    the total boundary-layer thickness is preserved while satisfying\n    anisotropy constraints near a concave corner.\n    \"\"\"\n    delta_bl, N_init, r, s_w, A_max, phi = params\n\n    # Algorithmic constants for the iterative solver\n    MAX_ITER = 100\n    TOL = 1e-12\n\n    M = N_init\n\n    # Pre-compute constants for the lower bound calculation\n    geom_factor = np.sqrt(2 - 2 * np.cos(phi))\n    c_phi = geom_factor / (2 * A_max)\n    s_w_bound = s_w / A_max\n\n    # Outer loop for layer merging\n    while M  0:\n        # Step 1: Compute the nominal geometric thickness distribution for M layers\n        if abs(r - 1.0)  1e-9:\n            t1 = delta_bl / M\n        else:\n            t1 = delta_bl * (r - 1) / (r**M - 1)\n        \n        t0 = np.array([t1 * r**k for k in range(M)])\n\n        # Step 2: Perform an initial feasibility check\n        # Estimate lower bounds using the nominal distribution's cumulative heights\n        y0 = np.cumsum(t0)\n        b_est = np.minimum(s_w_bound, c_phi * y0)\n        \n        if np.sum(b_est) > delta_bl:\n            M -= 1  # Infeasible, merge by reducing layer count\n            continue\n\n        # Step 3: If feasible, solve for thicknesses using a fixed-point iteration\n        t_current = np.copy(t0)\n        \n        for _ in range(MAX_ITER):\n            # a) Calculate lower bounds 'b' based on the current thickness vector\n            y_current = np.cumsum(t_current)\n            b = np.minimum(s_w_bound, c_phi * y_current)\n\n            # Check for the edge case where the sum of bounds equals the total thickness\n            if np.abs(np.sum(b) - delta_bl)  TOL:\n                t_new = b\n            else:\n                # b) Find the Lagrange multiplier 'lambda' by solving a root-finding problem\n                def g(lam):\n                    return np.sum(np.maximum(b, t0 + lam)) - delta_bl\n\n                try:\n                    # Use a robust bracket for the root-finding algorithm\n                    lam_sol = brentq(g, a=-2 * delta_bl, b=2 * delta_bl, xtol=TOL / 100)\n                except ValueError:\n                    # Fallback for difficult cases: refine bracket based on g(0)\n                    g0 = g(0)\n                    if g0 > 0:\n                        lam_sol = brentq(g, a=-2*delta_bl, b=0.0, xtol=TOL / 100)\n                    else:\n                        lam_sol = brentq(g, a=0.0, b=2*delta_bl, xtol=TOL / 100)\n\n                # c) Update the thickness vector using the found lambda\n                t_new = np.maximum(b, t0 + lam_sol)\n            \n            # d) Check for convergence of the inner loop\n            if np.linalg.norm(t_new - t_current)  TOL:\n                t_current = t_new\n                break  # Converged\n            \n            t_current = t_new\n        else:\n            # This 'else' belongs to the 'for' loop and executes if it finishes without 'break'\n            # This case (non-convergence) is not expected for this problem.\n            # We proceed with the last computed value.\n            pass\n\n        # If we reach here, a solution for the current M has been found.\n        # The sum is guaranteed to be delta_bl by the lambda solve.\n        return t_current.tolist()\n\n    # This part is reached only if M becomes 0, indicating failure to find a solution.\n    return []\n\nsolve()\n```", "id": "3297046"}]}