{"hands_on_practices": [{"introduction": "理论知识转化为可靠的数值模拟，第一步是精确地离散控制方程。然而，离散化过程本身会引入误差。本练习将引导您探索在计算流体力学中常见的非均匀（拉伸）网格上，二阶有限体积法离散拉普拉斯算子所产生的数值色散和耗散误差。通过执行局部傅里叶分析并计算修正波数，您将学会量化评估数值格式的质量，这超越了仅考虑形式上的精度阶数，是发展对计算方法批判性思维的关键一步。[@problem_id:3307572]", "problem": "您需要推导并实现一个对压力拉普拉斯算子 $ \\nabla^2 p $ 的二阶单元中心有限体积法 (FVM) 离散，该离散应用于一个拉伸的、非均匀的网格上。然后，您需要执行局部傅里叶（冻结系数）分析，以计算修正波数，并量化由离散化引入的色散和耗散。该分析是在计算流体动力学 (CFD) 中出现的压力泊松方程 (PPE) 的背景下进行的，但此处的最终计算仅针对离散拉普拉斯算子。角度必须以弧度表示，所有长度均为无量纲。\n\n起始点和推导要求：\n- 从不可压缩 Navier–Stokes 方程 (INS) 和不可压缩约束 $ \\nabla \\cdot \\boldsymbol{u} = 0 $ 开始，通过对动量方程应用散度算子来推导压力泊松方程 (PPE)，并明确说明所有必要的光滑性和边界假设。\n- 推导 $ \\nabla^2 p $ 在一维空间中的二阶单元中心 FVM 离散，然后推广到二维空间。在非均匀、拉伸的正交网格上，使用散度定理和面上的线性重构（与二阶精度一致）。您的推导必须是通用的，并且不得假设间距均匀。\n- 根据局部相邻间距和波数为 $ k_x $ 和 $ k_y $（单位为弧度/单位长度）的平面波 $ p(\\boldsymbol{x}) = \\exp\\left( \\mathrm{i} (k_x x + k_y y) \\right) $，定义离散算子在给定单元的局部冻结系数傅里叶符号。此处的思路是，傅里叶分析是局部应用的，邻近距离被冻结，并承认在拉伸网格上精确的平移不变性被破坏。\n- 从离散符号定义复修正波数的平方 $ k_{\\mathrm{mod}}^2 $，方法是将离散算子应用于平面波的结果与连续关系式 $ \\nabla^2 p = - (k_x^2 + k_y^2) p $ 进行匹配。通过以下两个无量纲指标来量化离散效应：\n  1. 一个类色散实部误差 $ \\epsilon_{\\mathrm{disp}} = \\dfrac{\\Re\\left(k_{\\mathrm{mod}}^2\\right) - \\left(k_x^2 + k_y^2\\right)}{k_x^2 + k_y^2} $。\n  2. 一个类耗散虚部比 $ \\epsilon_{\\mathrm{diss}} = \\dfrac{\\Im\\left(k_{\\mathrm{mod}}^2\\right)}{k_x^2 + k_y^2} $。\n- 实现一个程序，对于每个指定的测试用例，计算 $ k_{\\mathrm{mod}}^2 $ 并返回数对 $ \\left[ \\epsilon_{\\mathrm{disp}}, \\epsilon_{\\mathrm{diss}} \\right] $。\n\n要使用的网格和离散化细节：\n- 考虑一个二维、正交、单元中心的网格，其单元中心坐标为 $ (x_i, y_j) $，相邻单元中心的距离为 $ h_{x,-} = x_i - x_{i-1} $、$ h_{x,+} = x_{i+1} - x_i $、$ h_{y,-} = y_j - y_{j-1} $ 和 $ h_{y,+} = y_{j+1} - y_j $。局部单元宽度为 $ \\Delta x_i = \\dfrac{h_{x,-} + h_{x,+}}{2} $ 和 $ \\Delta y_j = \\dfrac{h_{y,-} + h_{y,+}}{2} $。\n- 使用通过相邻单元中心之间的线性重构获得的二阶面梯度。通过面的通量必须用相邻压力的差值除以相应的相邻距离来近似。离散算子由这些面通量的散度除以局部单元宽度形成，分别在 $ x $ 和 $ y $ 方向上计算，然后求和。\n\n傅里叶分析和输出：\n- 假设一个局部平面波 $ p_{i,j} = \\exp\\left( \\mathrm{i} (k_x x_i + k_y y_j) \\right) $，并使用冻结的相邻距离计算在点 $ (i,j) $ 处的局部离散算子符号。确定该复数符号，然后将 $ k_{\\mathrm{mod}}^2 $ 设为该符号的负值，以匹配连续算子 $ \\nabla^2 p = - (k_x^2 + k_y^2) p $。\n- 对于每个测试用例，将数对 $ \\left[ \\epsilon_{\\mathrm{disp}}, \\epsilon_{\\mathrm{diss}} \\right] $ 作为浮点数输出。\n\n测试套件：\n为以下五个测试用例提供结果，每个用例由元组 $ \\left( h_{x,-}, h_{x,+}, h_{y,-}, h_{y,+}, k_x, k_y \\right) $ 指定：\n- 用例 $ 1 $ （均匀网格，一维焦点）：$ \\left( 1.0, 1.0, 1.0, 1.0, 1.0, 0.0 \\right) $。\n- 用例 $ 2 $ （均匀网格，二维模式）：$ \\left( 0.5, 0.5, 0.5, 0.5, 2.0, 3.0 \\right) $。\n- 用例 $ 3 $ （$ x $ 方向轻微拉伸，$ y $ 方向均匀）：$ \\left( 0.8, 1.2, 1.0, 1.0, 2.5, 0.0 \\right) $。\n- 用例 $ 4 $ （$ x $ 方向强拉伸，$ y $ 方向均匀）：$ \\left( 0.5, 2.0, 1.0, 1.0, 3.0, 1.0 \\right) $。\n- 用例 $ 5 $ （均匀网格，在两个方向上都接近奈奎斯特频率，对于 $ h = 0.5 $）：$ \\left( 0.5, 0.5, 0.5, 0.5, 2\\pi, 2\\pi \\right) $。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应一个测试用例的列表 $ \\left[ \\epsilon_{\\mathrm{disp}}, \\epsilon_{\\mathrm{diss}} \\right] $，并保持输入测试用例的顺序。例如，输出应类似于 $ \\left[ [a_1, b_1], [a_2, b_2], \\dots \\right] $。", "solution": "该问题已经过验证，被认为是合理的。它具有科学依据、提法明确、客观，并为完整求解提供了所有必要信息。\n\n**1. 压力泊松方程 (PPE) 的推导**\n\n推导的基础在于不可压缩 Navier-Stokes (INS) 方程，它们描述了粘性不可压缩流体的运动。这些方程包括动量方程和不可压缩约束：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u} \\cdot \\nabla) \\boldsymbol{u} = -\\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2 \\boldsymbol{u} \\quad (\\text{动量})\n$$\n$$\n\\nabla \\cdot \\boldsymbol{u} = 0 \\quad (\\text{不可压缩性})\n$$\n这里，$\\boldsymbol{u}$ 是流体速度矢量，$p$ 是压力，$\\rho$ 是恒定的流体密度，$\\nu$ 是恒定的运动粘度。\n\n压力泊松方程 (PPE) 是通过对整个动量方程取散度来推导的：\n$$\n\\nabla \\cdot \\left( \\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u} \\cdot \\nabla) \\boldsymbol{u} \\right) = \\nabla \\cdot \\left( -\\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2 \\boldsymbol{u} \\right)\n$$\n我们在流体属性（$\\rho, \\nu$）恒定以及场具有足够光滑性以允许交换空间和时间导数的假设下分析每一项。\n\n1.  时间导数的散度：\n    $$\n    \\nabla \\cdot \\left( \\frac{\\partial \\boldsymbol{u}}{\\partial t} \\right) = \\frac{\\partial}{\\partial t}(\\nabla \\cdot \\boldsymbol{u})\n    $$\n    根据不可压缩约束 $\\nabla \\cdot \\boldsymbol{u} = 0$，此项为零。\n\n2.  压力梯度的散度：\n    $$\n    \\nabla \\cdot \\left( -\\frac{1}{\\rho}\\nabla p \\right) = -\\frac{1}{\\rho} \\nabla \\cdot (\\nabla p) = -\\frac{1}{\\rho} \\nabla^2 p\n    $$\n    这一项产生了压力的拉普拉斯算子，也就是我们感兴趣的算子。\n\n3.  粘性项的散度：\n    $$\n    \\nabla \\cdot (\\nu \\nabla^2 \\boldsymbol{u}) = \\nu \\nabla \\cdot (\\nabla^2 \\boldsymbol{u}) = \\nu \\nabla^2 (\\nabla \\cdot \\boldsymbol{u})\n    $$\n    再次使用不可压缩约束 $\\nabla \\cdot \\boldsymbol{u} = 0$，此项也为零。\n\n将这些简化代回取了散度的动量方程，得到：\n$$\n\\nabla \\cdot \\left( (\\boldsymbol{u} \\cdot \\nabla) \\boldsymbol{u} \\right) = -\\frac{1}{\\rho} \\nabla^2 p\n$$\n整理压力项得到 PPE：\n$$\n\\nabla^2 p = -\\rho \\nabla \\cdot \\left( (\\boldsymbol{u} \\cdot \\nabla) \\boldsymbol{u} \\right)\n$$\n这个方程建立了一种关系，其中压力场 $p$ 必须瞬时调整，以确保在数值模拟的下一个时间步中速度场 $\\boldsymbol{u}$ 保持无散度。右侧项充当泊松方程的源项。本问题专门关注左侧算子 $\\nabla^2 p$ 的离散化和分析。\n\n**2. 二阶单元中心有限体积离散**\n\n我们在一个二维、非均匀、正交的网格上推导拉普拉斯算子 $\\nabla^2 p = \\nabla \\cdot (\\nabla p)$ 的单元中心有限体积法 (FVM) 离散。该网格由位于 $(x_i, y_j)$ 的单元中心组成。到相邻单元中心的距离定义为 $h_{x,-} = x_i - x_{i-1}$、$h_{x,+} = x_{i+1} - x_i$、$h_{y,-} = y_j - y_{j-1}$ 和 $h_{y,+} = y_{j+1} - y_j$。\n\nFVM 方法涉及在控制体积 (CV) 上对控制方程进行积分，并应用散度定理。对于体积（面积）为 $V_{i,j} = \\Delta x_i \\Delta y_j$ 的二维单元 $(i, j)$，这表示为：\n$$\n\\frac{1}{V_{i,j}} \\int_{V_{i,j}} \\nabla \\cdot (\\nabla p) \\, dV = \\frac{1}{V_{i,j}} \\oint_{\\partial V_{i,j}} (\\nabla p) \\cdot \\boldsymbol{n} \\, dS\n$$\n其中 $\\boldsymbol{n}$ 是指向 CV 边界 $\\partial V_{i,j}$ 外部的法向矢量。\n\n对于正交网格，拉普拉斯算子可分离为来自每个坐标方向的独立贡献：$\\nabla^2 p = \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2}$。我们首先推导 $\\frac{\\partial^2 p}{\\partial x^2}$ 的一维离散算子 $(\\delta_{xx}p)_i$。\n\n围绕单元中心 $x_i$ 的一维控制体积从面 $x_{i-1/2}$ 延伸到 $x_{i+1/2}$，宽度为 $\\Delta x_i = \\frac{h_{x,-} + h_{x,+}}{2}$。在一维中应用散度定理得到：\n$$\n(\\delta_{xx}p)_i = \\frac{1}{\\Delta x_i} \\left[ \\left(\\frac{\\partial p}{\\partial x}\\right)_{i+1/2} - \\left(\\frac{\\partial p}{\\partial x}\\right)_{i-1/2} \\right]\n$$\n单元面上的梯度使用相邻单元中心之间的二阶精确中心差分来近似：\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i+1/2} \\approx \\frac{p_{i+1} - p_i}{x_{i+1} - x_i} = \\frac{p_{i+1} - p_i}{h_{x,+}}\n$$\n$$\n\\left(\\frac{\\partial p}{\\partial x}\\right)_{i-1/2} \\approx \\frac{p_i - p_{i-1}}{x_i - x_{i-1}} = \\frac{p_i - p_{i-1}}{h_{x,-}}\n$$\n将这些代入 $(\\delta_{xx}p)_i$ 的表达式中：\n$$\n(\\delta_{xx}p)_i = \\frac{1}{\\Delta x_i} \\left[ \\frac{p_{i+1} - p_i}{h_{x,+}} - \\frac{p_i - p_{i-1}}{h_{x,-}} \\right] = \\frac{2}{h_{x,-} + h_{x,+}} \\left[ \\frac{p_{i+1} - p_i}{h_{x,+}} - \\frac{p_i - p_{i-1}}{h_{x,-}} \\right]\n$$\n这可以写成一个三点模板：\n$$\n(\\delta_{xx}p)_i = \\left(\\frac{2}{h_{x,+}(h_{x,-} + h_{x,+})}\\right)p_{i+1} - \\left(\\frac{2}{h_{x,+}h_{x,-}}\\right)p_i + \\left(\\frac{2}{h_{x,-}(h_{x,-} + h_{x,+})}\\right)p_{i-1}\n$$\n推广到正交网格上的二维情况，离散拉普拉斯算子 $L_h(p_{i,j})$ 是一维算子的和：\n$$\nL_h(p_{i,j}) = (\\delta_{xx}p)_{i,j} + (\\delta_{yy}p)_{i,j}\n$$\n$$\nL_h(p_{i,j}) = \\frac{2}{h_{x,-} + h_{x,+}}\\left[\\frac{p_{i+1,j} - p_{i,j}}{h_{x,+}} - \\frac{p_{i,j} - p_{i-1,j}}{h_{x,-}}\\right] + \\frac{2}{h_{y,-} + h_{y,+}}\\left[\\frac{p_{i,j+1} - p_{i,j}}{h_{y,+}} - \\frac{p_{i,j} - p_{i,j-1}}{h_{y,-}}\\right]\n$$\n\n**3. 局部傅里叶分析和修正波数**\n\n为了分析此离散算子的性质，我们执行局部或“冻结系数”傅里叶分析。这涉及到将一个平面波解 $p(\\boldsymbol{x}) = \\exp(\\mathrm{i} \\boldsymbol{k} \\cdot \\boldsymbol{x})$ 代入离散算子 $L_h$。该分析是‘局部’的，因为我们将网格间距 $(h_{x,-}, h_{x,+}, h_{y,-}, h_{y,+})$ 冻结在特定单元 $(i,j)$ 处的值，并承认在非均匀网格上不存在真正的平移不变性。\n\n离散压力场为 $p_{i,j} = \\exp(\\mathrm{i}(k_x x_i + k_y y_j))$。相邻节点上的值可以用 $p_{i,j}$ 表示：\n$p_{i+1,j} = p_{i,j} \\exp(\\mathrm{i}k_x h_{x,+})$，$p_{i-1,j} = p_{i,j} \\exp(-\\mathrm{i}k_x h_{x,-})$，$p_{i,j+1} = p_{i,j} \\exp(\\mathrm{i}k_y h_{y,+})$，以及 $p_{i,j-1} = p_{i,j} \\exp(-\\mathrm{i}k_y h_{y,-})$。\n\n将这些代入算子 $L_h(p_{i,j})$ 中，得到 $L_h(p_{i,j}) = \\hat{L}_h \\cdot p_{i,j}$，其中 $\\hat{L}_h$ 是算子的复数符号。\n$$\n\\hat{L}_h = \\frac{\\hat{L}_h(p_{i,j})}{p_{i,j}} = \\hat{L}_{h,x} + \\hat{L}_{h,y}\n$$\n$$\n\\hat{L}_{h,x} = \\frac{2}{h_{x,-} + h_{x,+}}\\left[\\frac{\\exp(\\mathrm{i}k_x h_{x,+}) - 1}{h_{x,+}} + \\frac{\\exp(-\\mathrm{i}k_x h_{x,-}) - 1}{h_{x,-}}\\right]\n$$\n$$\n\\hat{L}_{h,y} = \\frac{2}{h_{y,-} + h_{y,+}}\\left[\\frac{\\exp(\\mathrm{i}k_y h_{y,+}) - 1}{h_{y,+}} + \\frac{\\exp(-\\mathrm{i}k_y h_{y,-}) - 1}{h_{y,-}}\\right]\n$$\n连续拉普拉斯算子作用于平面波的结果是 $\\nabla^2 p = -(k_x^2 + k_y^2)p = -k^2 p$。我们通过类比定义复修正波数的平方 $k_{\\mathrm{mod}}^2$，使得 $L_h(p_{i,j}) \\equiv -k_{\\mathrm{mod}}^2 p_{i,j}$。这直接意味着 $k_{\\mathrm{mod}}^2 = -\\hat{L}_h$。\n\n使用欧拉公式 $e^{\\mathrm{i}\\theta} = \\cos\\theta + \\mathrm{i}\\sin\\theta$，我们将 $k_{\\mathrm{mod}}^2$ 分解为实部和虚部：\n$$\n\\Re(k_{\\mathrm{mod}}^2) = -\\frac{2}{h_{x,-} + h_{x,+}} \\left( \\frac{\\cos(k_x h_{x,+}) - 1}{h_{x,+}} + \\frac{\\cos(k_x h_{x,-}) - 1}{h_{x,-}} \\right) - \\frac{2}{h_{y,-} + h_{y,+}} \\left( \\frac{\\cos(k_y h_{y,+}) - 1}{h_{y,+}} + \\frac{\\cos(k_y h_{y,-}) - 1}{h_{y,-}} \\right)\n$$\n$$\n\\Im(k_{\\mathrm{mod}}^2) = -\\frac{2}{h_{x,-} + h_{x,+}} \\left( \\frac{\\sin(k_x h_{x,+})}{h_{x,+}} - \\frac{\\sin(k_x h_{x,-})}{h_{x,-}} \\right) - \\frac{2}{h_{y,-} + h_{y,+}} \\left( \\frac{\\sin(k_y h_{y,+})}{h_{y,+}} - \\frac{\\sin(k_y h_{y,-})}{h_{y,-}} \\right)\n$$\n对于均匀网格，其中 $h_{x,-} = h_{x,+} = h_x$ 且 $h_{y,-} = h_{y,+} = h_y$，虚部为零，$\\Im(k_{\\mathrm{mod}}^2) = 0$，表明该格式是非耗散的。实部简化为众所周知的结果 $k_{\\mathrm{mod}}^2 = \\frac{4}{h_x^2}\\sin^2(\\frac{k_x h_x}{2}) + \\frac{4}{h_y^2}\\sin^2(\\frac{k_y h_y}{2})$。网格拉伸（$h_{+} \\neq h_{-}$）的存在会引入一个非零虚部，这对应于数值耗散或反耗散。\n\n**4. 离散效应的量化**\n\n修正波数 $k_{\\mathrm{mod}}^2$ 与精确波数 $k^2 = k_x^2 + k_y^2$ 的偏差量化了由离散化引入的误差。\n\n1.  **类色散误差**，$\\epsilon_{\\mathrm{disp}}$：这衡量了算子符号实部的误差，该误差与数值波的相速度有关。\n    $$\n    \\epsilon_{\\mathrm{disp}} = \\dfrac{\\Re\\left(k_{\\mathrm{mod}}^2\\right) - \\left(k_x^2 + k_y^2\\right)}{k_x^2 + k_y^2}\n    $$\n2.  **类耗散误差**，$\\epsilon_{\\mathrm{diss}}$：这衡量了虚部的相对大小，它关系到波幅的非物理衰减（耗散）或增长（不稳定性）。\n    $$\n    \\epsilon_{\\mathrm{diss}} = \\dfrac{\\Im\\left(k_{\\mathrm{mod}}^2\\right)}{k_x^2 + k_y^2}\n    $$\n$\\epsilon_{\\mathrm{diss}}$ 的正值对应于数值耗散（振幅衰减），因为算子 $L_h$ 的符号具有负实部。\n\n下面的程序实现了这些公式，以计算指定测试用例的误差。", "answer": "```python\nimport numpy as np\n\ndef compute_errors(h_xm: float, h_xp: float, h_ym: float, h_yp: float, kx: float, ky: float) -> list[float]:\n    \"\"\"\n    Computes dispersion and dissipation errors for the 2D FVM Laplacian.\n\n    Args:\n        h_xm: Grid spacing h_{x,-}\n        h_xp: Grid spacing h_{x,+}\n        h_ym: Grid spacing h_{y,-}\n        h_yp: Grid spacing h_{y,+}\n        kx: Wavenumber in x-direction\n        ky: Wavenumber in y-direction\n\n    Returns:\n        A list containing [epsilon_disp, epsilon_diss].\n    \"\"\"\n    # Calculate exact wavenumber squared\n    k_sq = kx**2 + ky**2\n    \n    # Handle the trivial case where the wave is a constant (k=0)\n    if k_sq == 0:\n        return [0.0, 0.0]\n\n    # --- X-direction contribution to k_mod^2 ---\n    # Real part\n    term_x_real_num_p = np.cos(kx * h_xp) - 1.0\n    term_x_real_num_m = np.cos(kx * h_xm) - 1.0\n    k_mod_sq_x_real = -2.0 / (h_xm + h_xp) * (term_x_real_num_p / h_xp + term_x_real_num_m / h_xm)\n\n    # Imaginary part\n    term_x_imag_num_p = np.sin(kx * h_xp)\n    term_x_imag_num_m = np.sin(kx * h_xm)\n    k_mod_sq_x_imag = -2.0 / (h_xm + h_xp) * (term_x_imag_num_p / h_xp - term_x_imag_num_m / h_xm)\n\n    # --- Y-direction contribution to k_mod^2 ---\n    # Real part\n    term_y_real_num_p = np.cos(ky * h_yp) - 1.0\n    term_y_real_num_m = np.cos(ky * h_ym) - 1.0\n    k_mod_sq_y_real = -2.0 / (h_ym + h_yp) * (term_y_real_num_p / h_yp + term_y_real_num_m / h_ym)\n    \n    # Imaginary part\n    term_y_imag_num_p = np.sin(ky * h_yp)\n    term_y_imag_num_m = np.sin(ky * h_ym)\n    k_mod_sq_y_imag = -2.0 / (h_ym + h_yp) * (term_y_imag_num_p / h_yp - term_y_imag_num_m / h_ym)\n\n    # --- Total k_mod^2 and errors ---\n    k_mod_sq_real = k_mod_sq_x_real + k_mod_sq_y_real\n    k_mod_sq_imag = k_mod_sq_x_imag + k_mod_sq_y_imag\n\n    epsilon_disp = (k_mod_sq_real - k_sq) / k_sq\n    epsilon_diss = k_mod_sq_imag / k_sq\n\n    return [epsilon_disp, epsilon_diss]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Test cases defined as tuples of (h_xm, h_xp, h_ym, h_yp, kx, ky)\n    test_cases = [\n        (1.0, 1.0, 1.0, 1.0, 1.0, 0.0),      # Case 1: uniform grid, 1D focus\n        (0.5, 0.5, 0.5, 0.5, 2.0, 3.0),      # Case 2: uniform grid, 2D mode\n        (0.8, 1.2, 1.0, 1.0, 2.5, 0.0),      # Case 3: mild stretch in x\n        (0.5, 2.0, 1.0, 1.0, 3.0, 1.0),      # Case 4: strong stretch in x\n        (0.5, 0.5, 0.5, 0.5, 2 * np.pi, 2 * np.pi), # Case 5: uniform grid, near-Nyquist\n    ]\n\n    results = []\n    for case in test_cases:\n        h_xm, h_xp, h_ym, h_yp, kx, ky = case\n        errors = compute_errors(h_xm, h_xp, h_ym, h_yp, kx, ky)\n        results.append(f\"[{errors[0]},{errors[1]}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3307572"}, {"introduction": "在离散压力泊松方程后，我们得到一个大型线性代数方程组。然而，这个方程组是否总是有唯一解？本练习聚焦于一个在不可压缩流模拟中至关重要且普遍存在的问题：当在整个求解域边界上施加诺伊曼 (Neumann) 边界条件时，离散拉普拉斯算子矩阵是奇异的。您将通过理论分析和数值实验，验证离散算子零空间的存在，并学习如何通过引入拉格朗日乘子来构建一个适定的增广系统，以获得唯一的、具有物理意义的压力解。[@problem_id:3307575]", "problem": "考虑一个由质量守恒和动量守恒控制的不可压缩流。对于牛顿流体，在不可压缩的假设下，质量守恒表示为 $ \\nabla \\cdot \\mathbf{u} = 0 $，其中 $ \\mathbf{u} $ 是速度场。动量方程（单位体积的牛顿第二定律）为 $ \\rho \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u} \\cdot \\nabla \\mathbf{u} \\right) = - \\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} $，其中 $ \\rho $ 是密度，$ p $ 是压力，$ \\mu $ 是动力粘度，$ \\mathbf{f} $ 是单位体积的体积力。在用于不可压缩流的投影类算法中，通过强制执行 $ \\nabla \\cdot \\mathbf{u}^{n+1} = 0 $ 来获得压力修正，其中 $ \\mathbf{u}^{n+1} $ 是更新后的速度。这一强制措施导致了形式为 $ \\nabla^2 p = g $ 的压力泊松方程，其中 $ g $ 源于对适当离散化的中间速度项和体积力项取散度。在边界上，压力边界条件源于动量的法向分量，在纯诺伊曼边界条件下，这意味着 $ \\frac{\\partial p}{\\partial n} = h $，在齐次情况下 $ h = 0 $。\n\n您的任务是推导和离散化压力泊松方程，然后设计一个离散测试来验证和消除由纯诺伊曼边界条件引起的零空间。请按以下步骤进行：\n\n- 从 $ \\nabla \\cdot \\mathbf{u} = 0 $ 和动量方程出发，推导压力泊松方程 $ \\nabla^2 p = g $，并讨论在不可压缩设定中 $ p $ 的纯诺伊曼边界条件的物理来源。具体说明为什么在所有边界上均为齐次诺伊曼情况 $ \\frac{\\partial p}{\\partial n} = 0 $ 时，连续算子 $ \\nabla^2 $ 具有一个由常数张成的零空间，这意味着压力仅在相差一个加性常数的意义下是确定的。\n- 在一个具有网格尺寸 $ N_x $ 和 $ N_y $、间距分别为 $ h_x $ 和 $ h_y $ 的矩形均匀二维网格上，离散化拉普拉斯算子 $ \\nabla^2 $。使用二阶有限差分法。通过引入法向导数为零的虚拟点来施加齐次诺伊曼边界条件，这会导致在边界处使用单边二阶导数。写出由此产生的线性系统 $ L \\mathbf{p} = \\mathbf{b} $，其中 $ L $ 是施加纯诺伊曼条件的离散拉普拉斯矩阵，$ \\mathbf{p} $ 是离散压力向量，$ \\mathbf{b} $ 是对应于 $ g $ 的离散右端项。解析地证明当 $ \\mathbf{p} $ 是全1向量 $ \\mathbf{1} $ 时，有 $ L \\mathbf{1} = \\mathbf{0} $，从而揭示离散零空间由 $ \\mathbf{1} $ 张成。\n- 解释在纯诺伊曼边界条件下，线性系统 $ L \\mathbf{p} = \\mathbf{b} $ 存在解的离散相容性条件，即 $ \\sum_i b_i = 0 $。设计一种方法来消除零空间并获得唯一解，方法是固定平均压力，例如，通过施加 $ \\frac{1}{n} \\sum_i p_i = 0 $（其中 $ n = N_x N_y $），这可以通过一个带拉格朗日乘子的增广鞍点系统来实现。\n\n实现一个完整、可运行的程序，该程序：\n- 对于给定的 $ N_x, N_y, h_x, h_y $，在齐次诺伊曼边界条件下，使用带有确保 $ \\frac{\\partial p}{\\partial n} = 0 $ 的虚拟点的二阶有限差分法构建矩阵 $ L $。\n- 通过计算三个网格上的 $ \\| L \\mathbf{1} \\|_\\infty $ 来验证零空间。\n- 构建增广系统\n$$\n\\begin{bmatrix}\nL  \\mathbf{1} \\\\\n\\mathbf{1}^\\top  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{p} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{b} \\\\\n0\n\\end{bmatrix}\n$$\n以施加 $ \\sum_i p_i = 0 $（即平均压力为零）的约束，并针对两个右端项 $ \\mathbf{b} $ 求解该系统：一个均值为零，另一个均值非零。报告增广系统的相对残差和所得 $ \\mathbf{p} $ 的均值，以证明零空间的消除和解的唯一性。\n\n使用以下网格和右端项测试套件：\n- 网格 $ 1 $：$ N_x = 8 $，$ N_y = 7 $，$ h_x = 0.1 $，$ h_y = 0.2 $。计算 $ r_1 = \\| L \\mathbf{1} \\|_\\infty $。\n- 网格 $ 2 $：$ N_x = 3 $，$ N_y = 3 $，$ h_x = 0.3 $，$ h_y = 0.5 $。计算 $ r_2 = \\| L \\mathbf{1} \\|_\\infty $。\n- 网格 $ 3 $：$ N_x = 1 $，$ N_y = 5 $，$ h_x = 1.0 $，$ h_y = 0.25 $。计算 $ r_3 = \\| L \\mathbf{1} \\|_\\infty $。\n- 在网格 $ 1 $ 上的增广系统测试：设 $ \\mathbf{b}^{(0)} $ 是一个通过减去其平均值构造的零均值随机向量，设 $ \\mathbf{b}^{(1)} $ 是一个非零均值随机向量。对于每个 $ \\mathbf{b}^{(k)} $，求解增广系统并计算相对残差 $ \\rho_k = \\frac{\\| L \\mathbf{p}^{(k)} + \\lambda^{(k)} \\mathbf{1} - \\mathbf{b}^{(k)} \\|_2}{\\| \\mathbf{b}^{(k)} \\|_2} $ 和均值 $ m_k = \\frac{1}{n} \\sum_i p^{(k)}_i $。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果顺序为 $ [ r_1, r_2, r_3, \\rho_0, m_0, \\rho_1, m_1 ] $。所有值必须打印为标准浮点数，不带任何附加文本。此问题不需要物理单位。", "solution": "此任务要求推导和离散化压力泊松方程，分析其在纯诺伊曼边界条件下的零空间，并实现一种获得唯一解的方法。\n\n### 第1部分：压力泊松方程及其边界条件的推导\n\n不可压缩牛顿流体的控制方程是质量守恒和动量守恒。\n不可压缩流的连续性方程为：\n$$ \\nabla \\cdot \\mathbf{u} = 0 $$\n其中 $\\mathbf{u}$ 是速度场。\n\n动量方程为：\n$$ \\rho \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u} \\cdot \\nabla \\mathbf{u} \\right) = - \\nabla p + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} $$\n其中 $\\rho$ 是流体密度，$p$ 是压力，$\\mu$ 是动力粘度，$\\mathbf{f}$ 是单位体积的体积力。\n\n为了推导压力泊松方程，我们对动量方程取散度。将散度算子 $\\nabla \\cdot$ 应用于每一项得到：\n$$ \\nabla \\cdot \\left( \\rho \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u} \\cdot \\nabla \\mathbf{u} \\right) \\right) = \\nabla \\cdot (-\\nabla p) + \\nabla \\cdot (\\mu \\nabla^2 \\mathbf{u}) + \\nabla \\cdot \\mathbf{f} $$\n整理以分离出压力项，并使用恒等式 $\\nabla \\cdot (\\nabla p) = \\nabla^2 p$，我们得到：\n$$ \\nabla^2 p = \\nabla \\cdot \\left( -\\rho \\frac{\\partial \\mathbf{u}}{\\partial t} - \\rho (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} \\right) $$\n这就是压力泊松方程，可以简写为 $\\nabla^2 p = g$，其中右端项 $g$ 包含所有不涉及压力的项。压力场的物理作用是瞬时调整自身，以确保速度场 $\\mathbf{u}$ 始终保持无散，从而满足不可压缩性约束。\n\n压力的边界条件由在边界处求值的动量方程导出。将动量方程投影到边界法向量 $\\mathbf{n}$上，得到压力法向导数 $\\frac{\\partial p}{\\partial n} = \\mathbf{n} \\cdot \\nabla p$ 的表达式：\n$$ \\frac{\\partial p}{\\partial n} = \\mathbf{n} \\cdot \\left( -\\rho \\left( \\frac{\\partial \\mathbf{u}}{\\partial t} + \\mathbf{u} \\cdot \\nabla \\mathbf{u} \\right) + \\mu \\nabla^2 \\mathbf{u} + \\mathbf{f} \\right) $$\n在许多情况下，特别是在瞬态模拟的投影方法中，此条件被简化为在所有边界上的齐次诺伊曼边界条件 $\\frac{\\partial p}{\\partial n} = 0$。\n\n当在区域 $\\Omega$ 的整个边界 $\\partial\\Omega$ 上应用纯齐次诺伊曼条件时，算子 $\\nabla^2$ 具有一个零空间。该零空间由所有满足在 $\\Omega$ 中 $\\nabla^2 p = 0$ 且在 $\\partial\\Omega$ 上 $\\frac{\\partial p}{\\partial n} = 0$ 的函数 $p$ 组成。为了描述这个零空间，我们使用格林第一恒等式：\n$$ \\int_\\Omega (v \\nabla^2 u + \\nabla v \\cdot \\nabla u) dV = \\oint_{\\partial\\Omega} v \\frac{\\partial u}{\\partial n} dS $$\n令 $v=u=p$，我们有：\n$$ \\int_\\Omega (p \\nabla^2 p + |\\nabla p|^2) dV = \\oint_{\\partial\\Omega} p \\frac{\\partial p}{\\partial n} dS $$\n代入条件 $\\nabla^2 p = 0$ 和 $\\frac{\\partial p}{\\partial n} = 0$：\n$$ \\int_\\Omega (p \\cdot 0 + |\\nabla p|^2) dV = \\oint_{\\partial\\Omega} p \\cdot 0 \\, dS $$\n这简化为：\n$$ \\int_\\Omega |\\nabla p|^2 dV = 0 $$\n由于被积函数 $|\\nabla p|^2$ 是非负的，该积分仅在 $|\\nabla p|^2 = 0$ 在 $\\Omega$ 中处处成立时才为零。这意味着 $\\nabla p = \\mathbf{0}$，即 $p$ 必须是一个常数函数。因此，具有纯齐次诺伊曼边界条件的连续拉普拉斯算子的零空间是常数函数的空间。这意味着如果 $p(\\mathbf{x})$ 是一个解，那么对于任何常数 $C$，$p(\\mathbf{x}) + C$ 也是一个解。压力仅在相差一个加性常数的意义下是确定的。\n\n### 第2部分：离散化和离散零空间\n\n我们在一个具有 $N_x \\times N_y$ 个点、网格间距为 $h_x, h_y$、网格点为 $(x_i, y_j) = (i h_x, j h_y)$ 的均匀矩形网格上离散化二维拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$。网格点上的压力表示为 $p_{i,j}$。我们使用二阶中心有限差分近似来计算内部点 $(i,j)$ 处的导数：\n$$ (\\nabla^2 p)_{i,j} \\approx \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{h_x^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{h_y^2} $$\n齐次诺伊曼边界条件，例如在 $x=0$ 处 $\\frac{\\partial p}{\\partial x} = 0$，通过使用虚拟点来施加。在 $i=0$ 处的一阶导数的二阶中心差分为 $\\frac{p_{1,j} - p_{-1,j}}{2h_x} = 0$，这意味着虚拟点的值为 $p_{-1,j} = p_{1,j}$。将此代入 $i=0$ 处的拉普拉斯算子模板：\n$$ (\\nabla^2 p)_{0,j} \\approx \\frac{p_{1,j} - 2p_{0,j} + p_{-1,j}}{h_x^2} + \\dots = \\frac{p_{1,j} - 2p_{0,j} + p_{1,j}}{h_x^2} + \\dots = \\frac{2(p_{1,j} - p_{0,j})}{h_x^2} + \\dots $$\n此过程应用于所有边界（左、右、底、顶），包括角点。\n\n由此产生的线性方程组可以写成矩阵系统 $L\\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{p}$ 是按字典序（例如，行主序）排列的压力值 $p_{i,j}$ 的向量，$L$ 是离散拉普拉斯矩阵。为了证明离散算子 $L$ 有一个由全1向量 $\\mathbf{1}$ 张成的零空间，我们必须证明 $L\\mathbf{1} = \\mathbf{0}$。这等价于证明 $L$ 的每一行元素之和为零。我们来检查任意网格点 $(i,j)$ 的模板中系数之和。\n- **内部点 $(i,j)$**：$p_{i-1,j}, p_{i+1,j}, p_{i,j-1}, p_{i,j+1}, p_{i,j}$ 的系数分别为 $\\frac{1}{h_x^2}, \\frac{1}{h_x^2}, \\frac{1}{h_y^2}, \\frac{1}{h_y^2}, -2(\\frac{1}{h_x^2}+\\frac{1}{h_y^2})$。它们的和为 $0$。\n- **边界点（例如，左边界，$i=0$）**：$p_{1,j}, p_{0,j-1}, p_{0,j+1}, p_{0,j}$ 的系数分别为 $\\frac{2}{h_x^2}, \\frac{1}{h_y^2}, \\frac{1}{h_y^2}, -(\\frac{2}{h_x^2}+\\frac{2}{h_y^2})$。它们的和为 $0$。\n- **角点（例如，左下角，$i=0, j=0$）**：$p_{1,0}, p_{0,1}, p_{0,0}$ 的系数分别为 $\\frac{2}{h_x^2}, \\frac{2}{h_y^2}, -(\\frac{2}{h_x^2}+\\frac{2}{h_y^2})$。它们的和也为 $0$。\n\n由于有限差分模板中每个网格点的系数之和为零，因此矩阵 $L$ 的每一行元素之和也为零。因此，$L\\mathbf{1} = \\mathbf{0}$，这意味着全1向量在 $L$ 的零空间中。\n\n### 第3部分：相容性条件和增广系统\n\n为了使奇异线性系统 $L\\mathbf{p} = \\mathbf{b}$ 有解，右端向量 $\\mathbf{b}$ 必须与伴随矩阵 $L^\\top$ 的零空间正交。如此构造的离散拉普拉斯矩阵 $L$ 是对称的（$L=L^\\top$），所以它的零空间和其伴随矩阵的零空间是相同的，都由 $\\mathbf{1}$ 张成。因此，相容性条件是 $\\mathbf{1}^\\top\\mathbf{b} = 0$，这意味着 $\\mathbf{b}$ 的元素之和必须为零：$\\sum_i b_i = 0$。这是连续条件 $\\int_\\Omega g \\, dV = 0$ 的离散模拟。\n\n如果存在解，它不是唯一的。为了获得唯一解，必须施加一个额外的约束。一个常见的选择是强制压力的平均值为零：$\\frac{1}{n} \\sum_i p_i = 0$，其中 $n=N_x N_y$。这等价于约束 $\\mathbf{1}^\\top \\mathbf{p} = 0$。\n\n这个约束系统可以通过使用拉格朗日乘子将约束并入线性系统来求解，从而得到增广鞍点系统：\n$$\n\\begin{bmatrix}\nL  \\mathbf{1} \\\\\n\\mathbf{1}^\\top  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{p} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{b} \\\\\n0\n\\end{bmatrix}\n$$\n该增广矩阵是非奇异的，求解该系统会得到一个唯一的解 $(\\mathbf{p}, \\lambda)$，其中 $\\mathbf{p}$ 是均值为零的压力向量。从分块矩阵乘法中，我们得到两个方程：\n$1. \\quad L\\mathbf{p} + \\lambda\\mathbf{1} = \\mathbf{b}$\n$2. \\quad \\mathbf{1}^\\top\\mathbf{p} = 0$\n\n将第一个方程从左侧乘以 $\\mathbf{1}^\\top$ 得到 $\\mathbf{1}^\\top L\\mathbf{p} + \\lambda \\mathbf{1}^\\top\\mathbf{1} = \\mathbf{1}^\\top\\mathbf{b}$。由于 $\\mathbf{1}^\\top L = (L^\\top \\mathbf{1})^\\top = (L\\mathbf{1})^\\top = \\mathbf{0}^\\top$，这简化为 $\\lambda n = \\sum_i b_i$，所以 $\\lambda = \\frac{1}{n} \\sum_i b_i$。拉格朗日乘子 $\\lambda$ 正是原始右端项 $\\mathbf{b}$ 的平均值。实际求解的系统是 $L\\mathbf{p} = \\mathbf{b} - \\bar{b}\\mathbf{1}$，其中 $\\bar{b}$ 是 $\\mathbf{b}$ 的平均值。这个修正确保了右端项满足相容性条件，从而使解存在，而约束 $\\mathbf{1}^\\top\\mathbf{p}=0$ 则确保其唯一性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_laplacian_neumann(Nx, Ny, hx, hy):\n    \"\"\"\n    Builds the 2D Laplacian matrix with homogeneous Neumann boundary conditions.\n\n    Args:\n        Nx (int): Number of grid points in the x-direction.\n        Ny (int): Number of grid points in the y-direction.\n        hx (float): Grid spacing in the x-direction.\n        hy (float): Grid spacing in the y-direction.\n\n    Returns:\n        numpy.ndarray: The (Nx*Ny) x (Nx*Ny) discrete Laplacian matrix.\n    \"\"\"\n    n = Nx * Ny\n    L = np.zeros((n, n), dtype=float)\n    \n    hx2i = 1.0 / (hx * hx)\n    hy2i = 1.0 / (hy * hy)\n\n    for i in range(Nx):\n        for j in range(Ny):\n            k = i * Ny + j  # Row-major index\n\n            # Contribution from d^2/dx^2\n            if Nx > 1:\n                # West neighbor contribution\n                if i > 0:\n                    L[k, (i - 1) * Ny + j] += hx2i\n                    L[k, k] -= hx2i\n                else:  # Left boundary i=0\n                    L[k, (i + 1) * Ny + j] += hx2i\n                    L[k, k] -= hx2i\n\n                # East neighbor contribution\n                if i < Nx - 1:\n                    L[k, (i + 1) * Ny + j] += hx2i\n                    L[k, k] -= hx2i\n                else:  # Right boundary i=Nx-1\n                    L[k, (i - 1) * Ny + j] += hx2i\n                    L[k, k] -= hx2i\n\n            # Contribution from d^2/dy^2\n            if Ny > 1:\n                # South neighbor contribution\n                if j > 0:\n                    L[k, i * Ny + (j - 1)] += hy2i\n                    L[k, k] -= hy2i\n                else:  # Bottom boundary j=0\n                    L[k, i * Ny + (j + 1)] += hy2i\n                    L[k, k] -= hy2i\n                \n                # North neighbor contribution\n                if j < Ny - 1:\n                    L[k, i * Ny + (j + 1)] += hy2i\n                    L[k, k] -= hy2i\n                else:  # Top boundary j=Ny-1\n                    L[k, i * Ny + (j - 1)] += hy2i\n                    L[k, k] -= hy2i\n    return L\n\n\ndef solve():\n    \"\"\"\n    Main function to perform the required computations and print the results.\n    \"\"\"\n    # Use a fixed seed for reproducibility of random vectors\n    np.random.seed(42)\n\n    results = []\n\n    # --- Part 1: Verify the nullspace for three meshes ---\n    meshes = [\n        (8, 7, 0.1, 0.2),  # Mesh 1\n        (3, 3, 0.3, 0.5),  # Mesh 2\n        (1, 5, 1.0, 0.25)  # Mesh 3\n    ]\n\n    for Nx, Ny, hx, hy in meshes:\n        n = Nx * Ny\n        L = build_laplacian_neumann(Nx, Ny, hx, hy)\n        ones_vec = np.ones(n)\n        L_times_ones = L @ ones_vec\n        r = np.linalg.norm(L_times_ones, np.inf)\n        results.append(r)\n\n    # --- Part 2: Solve the augmented system for two RHS on Mesh 1 ---\n    Nx, Ny, hx, hy = meshes[0]\n    n = Nx * Ny\n    L = build_laplacian_neumann(Nx, Ny, hx, hy)\n\n    # Case 0: RHS with zero mean\n    b0 = np.random.rand(n)\n    b0 -= np.mean(b0)\n\n    # Case 1: RHS with non-zero mean\n    b1 = np.random.rand(n)\n    if np.mean(b1) == 0: # Extremely unlikely but handle for robustness\n        b1[0] += 1.0\n\n    rhs_cases = [b0, b1]\n    \n    for b in rhs_cases:\n        # Construct the augmented saddle-point system\n        A = np.zeros((n + 1, n + 1))\n        A[:n, :n] = L\n        A[:n, n] = 1.0  # Lagrange multiplier constraint part\n        A[n, :n] = 1.0\n        \n        # Construct the augmented right-hand side vector\n        B = np.zeros(n + 1)\n        B[:n] = b\n\n        # Solve the augmented system for [p, lambda]\n        x_aug = np.linalg.solve(A, B)\n        p = x_aug[:n]\n        lmbda = x_aug[n]\n\n        # Calculate relative residual\n        residual_vec = L @ p + lmbda * np.ones(n) - b\n        \n        # Handle case where norm of b is zero (only for b0, but still good practice)\n        norm_b = np.linalg.norm(b)\n        if norm_b == 0:\n            relative_residual = np.linalg.norm(residual_vec)\n        else:\n            relative_residual = np.linalg.norm(residual_vec) / norm_b\n\n        # Calculate mean of the pressure solution\n        mean_p = np.mean(p)\n\n        results.append(relative_residual)\n        results.append(mean_p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{val:.15e}' for val in results)}]\")\n\nsolve()\n```", "id": "3307575"}, {"introduction": "在许多大规模的不可压缩流体模拟中，求解压力泊松方程所产生的线性方程组是计算成本最高的部分。多重网格法是解决此类问题的最高效的算法之一，其性能在很大程度上取决于其“光滑器”的效率。本练习将带您深入分析在各向异性拉伸网格上，经典加权雅可比 (Weighted Jacobi) 光滑器的性能。通过运用离散傅里叶分析来预测光滑因子，并与直接的数值测量结果进行对比，您将掌握一种量化评估迭代求解器性能的强大工具，这对于开发高效的计算流体力学程序至关重要。[@problem_id:3307599]", "problem": "考虑由质量守恒和动量守恒控制的不可压缩、常密度流。质量守恒表示为 $ \\nabla \\cdot \\mathbf{u} = 0$，在没有体积力且粘度恒定的情况下，动量守恒表示为 $ \\rho \\frac{\\partial \\mathbf{u}}{\\partial t} + \\rho (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} = - \\nabla p + \\mu \\nabla^2 \\mathbf{u}$。在投影法中，首先推进一个中间速度 $ \\mathbf{u}^\\star$ 而不强制执行 $ \\nabla \\cdot \\mathbf{u} = 0$ 的条件，然后使用压力进行校正以强制执行不可压缩性。通过对速度校正方程取散度并施加 $ \\nabla \\cdot \\mathbf{u}^{n+1} = 0$，可以得到一个形如 $ - \\nabla^2 p = \\text{RHS}$ 的压力泊松方程（PPE），其中右侧项涉及已知量，例如 $ \\mathbf{u}^\\star$ 的散度和任何显式项。为了分析多重网格平滑器，我们关注具有周期性边界条件的齐次算子 $ -\\nabla^2$。\n\n任务：\n- 从不可压缩投影步骤开始，推导 PPE 算子 $ -\\nabla^2$，并解释为何在周期性边界条件下，对于零均值压力，该算子是对称正定的。\n- 在均匀的笛卡尔网格上离散化 $ -\\nabla^2$，该网格可以是各向异性拉伸的，间距为 $ h_x$、$ h_y$ 以及在三维情况下的 $ h_z$，使用二阶中心有限差分法。确定作用于 $ p$ 节点值的所得矩阵的对角系数和模板系数。\n- 对周期性边界条件下的离散算子进行离散傅里叶分析（DFA）。对于二维中的傅里叶模态 $ \\exp\\left(i (\\theta_x j + \\theta_y k)\\right)$（索引 $ j$, $ k$）和三维中的傅里叶模态 $ \\exp\\left(i (\\theta_x j + \\theta_y k + \\theta_z \\ell)\\right)$（索引 $ j$, $ k$, $ \\ell$），推导算子的符号以及带松弛权重 $ \\omega$ 的加权雅可比平滑的误差传播符号。清晰地表达对角缩放以及对角度 $ \\theta_x$, $ \\theta_y$, $ \\theta_z$ 的依赖关系。\n- 使用局部傅里叶分析（LFA）对每个可用方向上以因子 $ 2$进行的标准粗化，将高频集 $ \\mathcal{H}$ 定义为至少有一个角度分量满足 $ |\\theta_d| \\in [\\pi/2, \\pi]$（角度以弧度为单位）的模态。预测平滑因子 $ \\mu_{\\text{pred}}$ 为误差传播符号幅值在高频集 $ \\mathcal{H}$ 上的上确界。\n- 通过在离散网格上测量平滑因子 $ \\mu_{\\text{meas}}$ 来验证 $ \\mu_{\\text{pred}}$：将误差初始化为单个网格点上的离散 delta，对离散算子执行一个加权雅可比步骤，计算初始误差和更新后误差的离散傅里叶变换，并取高频集 $ \\mathcal{H}$ 上振幅比的最大值。角度必须以弧度处理。\n\n您的实现必须是一个完整、可运行的程序，该程序：\n- 通过使用 $ h_x$、$ h_y$ 和（如果适用）$ h_z$ 的模板卷积，构建周期性网格上 $ -\\nabla^2$ 的离散算子作用。\n- 通过在离散角度集 $ \\theta_x = 2\\pi k_x/N_x$、$ \\theta_y = 2\\pi k_y/N_y$ 和（如果适用）$ \\theta_z = 2\\pi k_z/N_z$ 上进行离散傅里叶分析，计算预测的平滑因子 $ \\mu_{\\text{pred}}$，其中 $ N_x$、$ N_y$ 和 $ N_z$ 是每个方向上的网格点数，$ k_x$、$ k_y$、$ k_z$ 是整数索引。每个方向上的粗化因子为 2，因此高频对应于索引 $ k_d \\in [N_d/4, 3N_d/4]$。\n- 通过对离散 delta 场应用一次加权雅可比更新，然后进行离散傅里叶变换并取高频集 $ \\mathcal{H}$ 上的振幅比，来测量平滑因子 $ \\mu_{\\text{meas}}$。\n- 使用弧度作为角度单位。\n\n测试套件：\n- 情况 1：二维各向同性网格，$ N_x = 64$，$ N_y = 64$，$ h_x = 1$，$ h_y = 1$，$ \\omega = 2/3$。\n- 情况 2：二维各向异性网格，$ N_x = 64$，$ N_y = 64$，$ h_x = 1$，$ h_y = 0.1$，$ \\omega = 2/3$。\n- 情况 3：三维各向同性网格，$ N_x = 32$，$ N_y = 32$，$ N_z = 32$，$ h_x = 1$，$ h_y = 1$，$ h_z = 1$，$ \\omega = 2/3$。\n- 情况 4：三维各向异性网格，$ N_x = 32$，$ N_y = 32$，$ N_z = 16$，$ h_x = 1$，$ h_y = 0.1$，$ h_z = 10$，$ \\omega = 2/3$。\n- 情况 5：二维极端各向异性网格和不同的权重，$ N_x = 64$，$ N_y = 64$，$ h_x = 1$，$ h_y = 100$，$ \\omega = 0.8$。\n\n答案规格：\n- 对于每个测试用例，计算绝对差 $ |\\mu_{\\text{pred}} - \\mu_{\\text{meas}}|$ 作为一个浮点数。\n- 您的程序应生成单行输出，其中包含按测试套件案例顺序排列的结果，格式为方括号括起来的逗号分隔列表（例如，$ [r_1,r_2,r_3,r_4,r_5]$）。不应打印任何附加文本。", "solution": "该问题要求对压力泊松方程（PPE）算子的加权雅可比平滑器进行多方面的分析，包括推导、离散化、傅里叶分析和数值验证。该问题在科学上是合理的、适定的，并且提供了解决所需的所有必要参数。\n\n### 1. 压力泊松方程算子的推导与性质\n\n不可压缩的 Navier-Stokes 方程包括质量守恒和动量守恒。对于密度为常数 $\\rho$、运动粘度为常数 $\\nu = \\mu/\\rho$ 的流体，这些方程是：\n$$ \\nabla \\cdot \\mathbf{u} = 0 $$\n$$ \\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} = - \\frac{1}{\\rho}\\nabla p + \\nu \\nabla^2 \\mathbf{u} $$\n投影法是一类解耦速度和压力更新的时间步进算法。一个典型的分数步投影法分两个阶段进行。首先，通过推进动量方程而不包含压力梯度项，或使用上一步的压力，来计算一个中间速度场 $\\mathbf{u}^\\star$。为了清晰起见，我们使用简单的前向欧拉时间离散。对流项和扩散项被显式处理：\n$$ \\frac{\\mathbf{u}^\\star - \\mathbf{u}^n}{\\Delta t} = -(\\mathbf{u}^n \\cdot \\nabla)\\mathbf{u}^n + \\nu \\nabla^2 \\mathbf{u}^n =: \\mathbf{R}(\\mathbf{u}^n) $$\n这个中间速度场 $\\mathbf{u}^\\star$ 通常不满足不可压缩性约束，即 $\\nabla \\cdot \\mathbf{u}^\\star \\neq 0$。\n\n在第二阶段，这个速度被“投影”到无散度向量场的空间上。这是通过使用新时间步 $p^{n+1}$ 的压力梯度来校正速度实现的：\n$$ \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^\\star}{\\Delta t} = - \\frac{1}{\\rho}\\nabla p^{n+1} $$\n我们强制要求最终的速度场 $\\mathbf{u}^{n+1}$ 必须是无散度的：$\\nabla \\cdot \\mathbf{u}^{n+1} = 0$。对校正方程取散度得到：\n$$ \\nabla \\cdot \\left( \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^\\star}{\\Delta t} \\right) = \\nabla \\cdot \\left( - \\frac{1}{\\rho}\\nabla p^{n+1} \\right) $$\n$$ \\frac{1}{\\Delta t} ( \\nabla \\cdot \\mathbf{u}^{n+1} - \\nabla \\cdot \\mathbf{u}^\\star) = - \\frac{1}{\\rho} \\nabla^2 p^{n+1} $$\n代入 $\\nabla \\cdot \\mathbf{u}^{n+1} = 0$，我们得到压力泊松方程（PPE）：\n$$ \\nabla^2 p^{n+1} = \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^\\star $$\n问题要求我们关注齐次算子 $-\\nabla^2$，它构成了 PPE 的左侧，即 $-\\nabla^2 p^{n+1} = - \\frac{\\rho}{\\Delta t} \\nabla \\cdot \\mathbf{u}^\\star$。右侧是一个从已知量计算出的源项。\n\n**对称性与正定性**：令 $L = -\\nabla^2$。我们在具有周期性边界条件的域 $\\Omega$ 上分析其性质。\n*   **对称性**：我们使用 $L^2$ 内积，$\\langle f, g \\rangle = \\int_\\Omega f g \\, dV$。如果 $\\langle Lf, g \\rangle = \\langle f, Lg \\rangle$，则算子 $L$ 是对称的。\n    $$ \\langle -\\nabla^2 f, g \\rangle = - \\int_\\Omega (\\nabla^2 f) g \\, dV $$\n    使用分部积分法（格林第一恒等式），$\\int_\\Omega g(\\nabla^2 f) \\, dV = \\oint_{\\partial\\Omega} g(\\nabla f)\\cdot\\mathbf{n} \\, dS - \\int_\\Omega \\nabla g \\cdot \\nabla f \\, dV$。对于周期性边界条件，边界面积分 $\\oint_{\\partial\\Omega}$ 为零。\n    $$ \\langle -\\nabla^2 f, g \\rangle = \\int_\\Omega \\nabla f \\cdot \\nabla g \\, dV $$\n    这个最终表达式在 $f$ 和 $g$ 中是对称的，因此证明了 $\\langle -\\nabla^2 f, g \\rangle = \\langle f, -\\nabla^2 g \\rangle$。该算子是对称的。\n*   **正定性**：如果对于所有在适当空间中的非零函数 $f$，都有 $\\langle Lf, f \\rangle > 0$，则算子是正定的。\n    $$ \\langle -\\nabla^2 f, f \\rangle = \\int_\\Omega |\\nabla f|^2 \\, dV $$\n    这个积分总是非负的。它等于零当且仅当 $|\\nabla f|^2 = 0$ 处处成立，这意味着 $\\nabla f = 0$，即 $f$ 是一个常数函数。对于 PPE，压力仅能确定到一个相加常数。为了确保解的唯一性，我们通常约束压力具有零均值，即 $\\int_\\Omega p \\, dV = 0$。在零均值函数空间中，唯一的常数函数是 $f=0$。因此，对于此空间中的任何非零函数 $f$，$\\langle -\\nabla^2 f, f \\rangle > 0$，算子是正定的。\n\n### 2. 离散化\n\n我们在间距为 $h_x, h_y, h_z$ 的均匀笛卡尔网格上离散化算子 $L = -\\nabla^2$。令 $p_{j,k,\\ell}$ 为网格节点 $(x_j, y_k, z_\\ell) = (j h_x, k h_y, \\ell h_z)$ 处的压力。对偏导数使用二阶中心有限差分：\n$$ \\frac{\\partial^2 p}{\\partial x^2}\\bigg|_{j,k,\\ell} \\approx \\frac{p_{j+1,k,\\ell} - 2 p_{j,k,\\ell} + p_{j-1,k,\\ell}}{h_x^2} $$\n在三维情况下，应用于节点 $(j,k,\\ell)$ 处 $p$ 的离散算子 $L_h$ 为：\n$$ L_h p_{j,k,\\ell} = - \\left( \\frac{p_{j+1,k,\\ell} - 2p_{j,k,\\ell} + p_{j-1,k,\\ell}}{h_x^2} + \\frac{p_{j,k+1,\\ell} - 2p_{j,k,\\ell} + p_{j,k-1,\\ell}}{h_y^2} + \\frac{p_{j,k,\\ell+1} - 2p_{j,k,\\ell} + p_{j,k,\\ell-1}}{h_z^2} \\right) $$\n整理各项得到模板形式。作用于 $p$ 节点值的矩阵由其系数定义：\n*   **对角系数**：这是 $p_{j,k,\\ell}$ 的系数。\n    $$ c_0 = \\frac{2}{h_x^2} + \\frac{2}{h_y^2} + \\frac{2}{h_z^2} $$\n*   **非对角模板系数**：这些是相邻节点的系数。\n    $$ c_{j\\pm1,k,\\ell} = -\\frac{1}{h_x^2}, \\quad c_{j,k\\pm1,\\ell} = -\\frac{1}{h_y^2}, \\quad c_{j,k,\\ell\\pm1} = -\\frac{1}{h_z^2} $$\n对于二维网格，省略涉及 $h_z$ 的项。\n\n### 3. 离散傅里叶分析 (DFA)\n\nDFA分析离散线性算子在傅里叶模态上的作用。在周期性网格上，离散傅里叶模态是任何线性、平移不变算子（如我们的有限差分模板）的特征向量。一个三维傅里叶模态是 $v_{j,k,\\ell} = \\exp\\left(i (\\theta_x j + \\theta_y k + \\theta_z \\ell)\\right)$，其中 $\\theta_d = 2\\pi k_d/N_d$ 是方向 $d$ 上的相位角，对于整数波数 $k_d$ 和 $N_d$ 个网格点。\n\n将离散算子 $L_h$ 应用于此模态 $v$：\n$$ L_h v_{j,k,\\ell} = c_0 v_{j,k,\\ell} - \\frac{1}{h_x^2}(v_{j+1,k,\\ell} + v_{j-1,k,\\ell}) - \\frac{1}{h_y^2}(v_{j,k+1,\\ell} + v_{j,k-1,\\ell}) - \\frac{1}{h_z^2}(v_{j,k,\\ell+1} + v_{j,k,\\ell-1}) $$\n提出因子 $v_{j,k,\\ell}$ 并使用 $v_{j+1,k,\\ell} = e^{i\\theta_x}v_{j,k,\\ell}$，我们得到特征值，或称为**符号** $\\hat{L}(\\boldsymbol{\\theta})$：\n$$ \\hat{L}(\\boldsymbol{\\theta}) = c_0 - \\frac{1}{h_x^2}(e^{i\\theta_x} + e^{-i\\theta_x}) - \\frac{1}{h_y^2}(e^{i\\theta_y} + e^{-i\\theta_y}) - \\frac{1}{h_z^2}(e^{i\\theta_z} + e^{-i\\theta_z}) $$\n使用 $e^{i\\phi} + e^{-i\\phi} = 2\\cos\\phi$ 和 $2(1-\\cos\\phi) = 4\\sin^2(\\phi/2)$:\n$$ \\hat{L}(\\boldsymbol{\\theta}) = \\frac{2(1-\\cos\\theta_x)}{h_x^2} + \\frac{2(1-\\cos\\theta_y)}{h_y^2} + \\frac{2(1-\\cos\\theta_z)}{h_z^2} = \\frac{4}{h_x^2}\\sin^2(\\frac{\\theta_x}{2}) + \\frac{4}{h_y^2}\\sin^2(\\frac{\\theta_y}{2}) + \\frac{4}{h_z^2}\\sin^2(\\frac{\\theta_z}{2}) $$\n现在我们分析用于系统 $A\\mathbf{p} = \\mathbf{b}$ 的加权雅可比平滑器，其中 $A$ 是来自 $L_h$ 的矩阵。第 $m$ 次迭代的误差 $\\mathbf{e}^{(m)}$ 按 $\\mathbf{e}^{(m+1)} = S \\mathbf{e}^{(m)}$ 传播，其中 $S = I - \\omega D^{-1}A$ 是误差传播算子。这里，$D$ 是 $A$ 的对角线，$\\omega$ 是松弛权重。**对角缩放**是通过 $D^{-1}$，这对应于除以对角系数 $c_0$。\n\n**误差传播符号** $\\hat{S}(\\boldsymbol{\\theta})$ 是 $S$ 对模态 $\\boldsymbol{\\theta}$ 的特征值：\n$$ \\hat{S}(\\boldsymbol{\\theta}) = 1 - \\omega \\frac{\\hat{L}(\\boldsymbol{\\theta})}{c_0} = 1 - \\omega \\frac{\\frac{4}{h_x^2}\\sin^2(\\frac{\\theta_x}{2}) + \\frac{4}{h_y^2}\\sin^2(\\frac{\\theta_y}{2}) + \\frac{4}{h_z^2}\\sin^2(\\frac{\\theta_z}{2})}{\\frac{2}{h_x^2} + \\frac{2}{h_y^2} + \\frac{2}{h_z^2}} $$\n这明确地显示了对松弛权重 $\\omega$ 和傅里叶角 $\\boldsymbol{\\theta} = (\\theta_x, \\theta_y, \\theta_z)$ 的依赖关系。二维符号可以通过在分子和分母中都省略与 z 相关的项来找到。\n\n### 4. 局部傅里叶分析（LFA）和预测平滑因子\n\nLFA 扩展了 DFA，将角度 $\\theta_d$ 视为 $[-\\pi, \\pi]$ 中的连续变量。在多重网格背景下，平滑器的作用是衰减高频误差分量。对于以因子 2 进行的标准粗化，低频模态是那些可以在更粗的网格上表示的模态，对应于角度 $\\theta_d \\in [-\\pi/2, \\pi/2]$。高频集 $\\mathcal{H}$ 包含所有其他模态：即那些至少有一个角度分量 $|\\theta_d|$ 在 $[\\pi/2, \\pi]$ 中的模态。\n预测的平滑因子 $\\mu_{\\text{pred}}$ 是所有高频模态上的最坏情况（最大）衰减因子：\n$$ \\mu_{\\text{pred}} = \\sup_{\\boldsymbol{\\theta} \\in \\mathcal{H}} |\\hat{S}(\\boldsymbol{\\theta})| $$\n对于数值实现，这个上确界是在离散的高频波数集上取。如问题所述，具有索引 $\\mathbf{k}=(k_x, k_y, \\dots)$ 的模态是高频的，如果对于至少一个方向 $d$，$k_d \\in [N_d/4, 3N_d/4]$，其中索引从 $0$ 到 $N_d-1$。\n\n### 5. 测量的平滑因子\n\n为了验证 LFA 的预测，平滑因子在离散网格上直接测量。\n1. 将误差场 $e$ 初始化为离散 delta 函数，$e_{j,k,\\ell} = \\delta_{j,j_0}\\delta_{k,k_0}\\delta_{\\ell,\\ell_0}$，这会以相等的振幅激发所有傅里叶模态。\n2. 对此误差场应用一步加权雅可比平滑器：$e_{\\text{new}} = (I - \\omega D^{-1} A) e = e - \\omega D^{-1}(Ae)$。$Ae$ 项通过对 $e$ 应用离散模板并使用带周期性边界条件的卷积来计算。\n3. 计算初始误差和更新后误差的离散傅里叶变换：$\\hat{e} = \\text{FFT}(e)$ 和 $\\hat{e}_{\\text{new}} = \\text{FFT}(e_{\\text{new}})$。\n4. 每个模态 $\\mathbf{k}$ 的放大因子是傅里叶振幅之比，$|\\hat{e}_{\\text{new}}(\\mathbf{k}) / \\hat{e}(\\mathbf{k})|$。\n5. 测量的平滑因子 $\\mu_{\\text{meas}}$ 是这些放大因子在离散高频集 $\\mathcal{H}_{\\text{discrete}}$ 上的最大值。\n预测值和测量值 $\\mu_{\\text{pred}}$ 和 $\\mu_{\\text{meas}}$ 应该在浮点精度范围内一致，从而验证分析。", "answer": "```python\nimport numpy as np\n\ndef calculate_smoothing_factor_diff(N, h, omega):\n    \"\"\"\n    Calculates the absolute difference between the predicted and measured\n    smoothing factors for the Weighted Jacobi method on the Poisson equation.\n\n    Args:\n        N (tuple): Number of grid points in each dimension (e.g., (Nx, Ny)).\n        h (tuple): Grid spacing in each dimension (e.g., (hx, hy)).\n        omega (float): Relaxation weight for the Jacobi method.\n\n    Returns:\n        float: The absolute difference |mu_pred - mu_meas|.\n    \"\"\"\n    dim = len(N)\n    \n    if dim not in [2, 3]:\n        raise ValueError(\"Only 2D and 3D cases are supported.\")\n\n    # --- Prediction (mu_pred) using Discrete Fourier Analysis ---\n\n    # Create grids of integer wave numbers k\n    k_ranges = [np.arange(n) for n in N]\n    K_grids = np.meshgrid(*k_ranges, indexing='ij')\n\n    # Create boolean mask for high-frequency modes\n    # A mode is high-frequency if for at least one dimension d,\n    # its wave number k_d is in [N_d/4, 3*N_d/4].\n    high_freq_mask = np.zeros(N, dtype=bool)\n    for i in range(dim):\n        # We need to handle the indices correctly for np.fft.fftfreq correspondence\n        # The positive frequencies are in the first half of the array\n        # The negative frequencies are in the second half, in reverse order.\n        # A simpler way is to check the integer k indices.\n        # High freqs are in the \"middle half\" of the k-space indices.\n        k_d = K_grids[i]\n        n_d = N[i]\n        # np.fft.fftshift gives a centered view. [-N/2, N/2-1].\n        # High freqs for standard coarsening are outside [-pi/2, pi/2] for theta.\n        # This corresponds to k in [-N/4, N/4].\n        # In the un-shifted DFT indices (0 to N-1), this corresponds to\n        # k in [0, N/4] U [3N/4, N-1] for low freqs.\n        # So high freqs are k in (N/4, 3N/4). We use inclusive bounds for simplicity as per problem.\n        high_freq_mask |= ((k_d >= n_d // 4) & (k_d <= 3 * n_d // 4))\n\n    # The zero-frequency mode (k_d=0 for all d) is not high-frequency\n    zero_freq_indices = tuple([0] * dim)\n    high_freq_mask[zero_freq_indices] = False\n    \n    if not np.any(high_freq_mask):\n         mu_pred = 0.0 # No high frequencies to smooth\n    else:\n        # Calculate the symbol of the discrete operator L_h\n        L_hat_num = np.zeros(N)\n        c0 = 0.0\n        for i in range(dim):\n            theta_d = 2 * np.pi * K_grids[i] / N[i]\n            L_hat_num += (4.0 / h[i]**2) * np.sin(theta_d / 2.0)**2\n            c0 += 2.0 / h[i]**2\n        \n        if c0 == 0:\n            mu_pred = 1.0 # Smoother does nothing\n        else:\n            # Calculate the symbol of the smoother S\n            S_hat = 1.0 - omega * L_hat_num / c0\n            \n            # Predicted smoothing factor is the max magnitude of S_hat over high frequencies\n            mu_pred = np.max(np.abs(S_hat[high_freq_mask]))\n\n    # --- Measurement (mu_meas) using a grid-based simulation ---\n\n    # 1. Initialize error e as a discrete delta function\n    e = np.zeros(N)\n    center_indices = tuple(n // 2 for n in N)\n    e[center_indices] = 1.0\n\n    # 2. Apply one step of Weighted Jacobi to the error e\n    # e_new = (I - omega * D^-1 * A) * e = e - omega/c0 * (A*e)\n    # where D is c0*I.\n    c0 = 0.0\n    for i in range(dim):\n        c0 += 2.0 / h[i]**2\n    \n    if c0 == 0:\n        e_new = e.copy()\n    else:\n        # Apply operator A to e (convolution with periodic BCs)\n        Ae = c0 * e\n        for i in range(dim):\n            Ae -= (1.0 / h[i]**2) * (np.roll(e, 1, axis=i) + np.roll(e, -1, axis=i))\n        \n        e_new = e - omega * Ae / c0\n\n    # 3. Compute Fourier transforms\n    e_hat = np.fft.fftn(e)\n    e_new_hat = np.fft.fftn(e_new)\n\n    # 4. Compute amplification factor for each mode\n    ratio = np.zeros_like(e_hat, dtype=float)\n    # The magnitude of the FFT of a delta function is non-zero everywhere.\n    valid_mask = np.abs(e_hat) > 1e-15\n    np.divide(np.abs(e_new_hat), np.abs(e_hat), out=ratio, where=valid_mask)\n\n    # 5. Measured smoothing factor is the max ratio over high frequencies\n    if not np.any(high_freq_mask):\n        mu_meas = 0.0\n    else:\n        mu_meas = np.max(ratio[high_freq_mask])\n    \n    return np.abs(mu_pred - mu_meas)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: 2D isotropic\n        {'N': (64, 64), 'h': (1.0, 1.0), 'omega': 2/3},\n        # Case 2: 2D anisotropic\n        {'N': (64, 64), 'h': (1.0, 0.1), 'omega': 2/3},\n        # Case 3: 3D isotropic\n        {'N': (32, 32, 32), 'h': (1.0, 1.0, 1.0), 'omega': 2/3},\n        # Case 4: 3D anisotropic\n        {'N': (32, 32, 16), 'h': (1.0, 0.1, 10.0), 'omega': 2/3},\n        # Case 5: 2D extreme anisotropy, different weight\n        {'N': (64, 64), 'h': (1.0, 100.0), 'omega': 0.8},\n    ]\n\n    results = []\n    for case in test_cases:\n        diff = calculate_smoothing_factor_diff(case['N'], case['h'], case['omega'])\n        results.append(diff)\n\n    # Print output in the specified format\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3307599"}]}