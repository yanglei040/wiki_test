{"hands_on_practices": [{"introduction": "要掌握SIMPLE系列算法，关键在于理解不同变体在速度修正步骤中所做的不同近似。这个练习将通过从离散动量方程出发，推导SIMPLE和SIMPLEC算法中速度修正项的表达式，从而帮助您深入理解它们的核心差异。通过分析这两种方法的区别[@problem_id:3362268]，您将能更清晰地认识到SIMPLEC算法在保证计算收敛性与一致性方面的改进之处。", "problem": "考虑沿 $x$ 方向的稳态、一维、不可压缩流动，该流动在均匀网格上通过有限体积法进行离散。内部控制体为 $P$，其西侧和东侧相邻节点分别表示为 $W$ 和 $E$。设节点 $P$ 处 $x$ 方向动量方程的离散化线性对流-扩散形式写作 $a_{P} u_{P} = a_{W} u_{W} + a_{E} u_{E} + b + S \\left( p_{W} - p_{E} \\right)$，其中 $u_{P}$ 是节点速度，$p_{P}$ 是节点压力，$a_{P}$、$a_{W}$ 和 $a_{E}$ 是由对流-扩散通量产生的对角和相邻系数，$b$ 是已知的源项贡献，$S$ 是控制体面的横截面积。假设已经通过使用一个猜测的压力场求解动量方程，获得了临时速度 $u^{*}$ 和临时压力 $p^{*}$。通过 $u = u^{*} + u^{\\prime}$ 和 $p = p^{*} + p^{\\prime}$ 定义修正量 $u^{\\prime}$ 和 $p^{\\prime}$。在压力关联方程的半隐式方法 (SIMPLE) 和 SIMPLE-Consistent (SIMPLEC) 算法中，速度修正量 $u_{P}^{\\prime}$ 是在关于相邻速度修正量的不同一致性假设下，从动量修正方程中获得的。从控制体的动量积分守恒及其标准的有限体积离散化出发，推导 SIMPLE 和 SIMPLEC 算法在节点 $P$ 处使用的速度修正表达式，然后计算在 $P$ 处 SIMPLEC 预测和 SIMPLE 预测的速度修正量之差。假设在一维情况下修正场是缓变的，因此在主阶上 $u_{W}^{\\prime} \\approx u_{P}^{\\prime}$ 和 $u_{E}^{\\prime} \\approx u_{P}^{\\prime}$。将您的最终答案表示为关于 $a_{P}$、$a_{W}$、$a_{E}$、$S$ 和 $\\Delta p^{\\prime} = p_{W}^{\\prime} - p_{E}^{\\prime}$ 的单个简化解析表达式。不要引入任何额外的参数。您的最终答案必须是一个闭式表达式，表达式内不含单位。", "solution": "本问题要求推导计算流体动力学中 SIMPLE 和 SIMPLEC 算法的速度修正表达式，并计算这些修正量之间的差值。我们从给定的离散化动量方程和修正场的定义开始。\n\n对于节点 $P$ 及其相邻节点 $W$ 和 $E$，真实速度场 $u$ 和压力场 $p$ 的离散化动量方程给出如下：\n$$a_{P} u_{P} = a_{W} u_{W} + a_{E} u_{E} + b + S \\left( p_{W} - p_{E} \\right)$$\n通过对相邻节点（$nb$）求和，可以更紧凑地写成：\n$$a_{P} u_{P} = \\sum_{nb} a_{nb} u_{nb} + b + S \\left( p_{W} - p_{E} \\right)$$\n在 SIMPLE 系列算法中，通过使用猜测的或上一次迭代的压力场 $p^{*}$ 求解动量方程，可以计算出临时速度场 $u^{*}$：\n$$a_{P} u_{P}^{*} = \\sum_{nb} a_{nb} u_{nb}^{*} + b + S \\left( p_{W}^{*} - p_{E}^{*} \\right)$$\n真实场通过修正量（用上标 $^{\\prime}$ 表示）与临时场相关联：\n$$u = u^{*} + u^{\\prime}$$\n$$p = p^{*} + p^{\\prime}$$\n将这些定义代入第一个方程，我们得到节点 $P$ 处的方程：\n$$a_{P} (u_{P}^{*} + u_{P}^{\\prime}) = \\sum_{nb} a_{nb} (u_{nb}^{*} + u_{nb}^{\\prime}) + b + S \\left( (p_{W}^{*} + p_{W}^{\\prime}) - (p_{E}^{*} + p_{E}^{\\prime}) \\right)$$\n展开各项可得：\n$$a_{P} u_{P}^{*} + a_{P} u_{P}^{\\prime} = \\sum_{nb} a_{nb} u_{nb}^{*} + \\sum_{nb} a_{nb} u_{nb}^{\\prime} + b + S \\left( p_{W}^{*} - p_{E}^{*} \\right) + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n为了获得修正量的方程，我们从此展开式中减去临时场的方程。包含 $u^{*}$ 和 $p^{*}$ 的项相互抵消：\n$$(a_{P} u_{P}^{*} + a_{P} u_{P}^{\\prime}) - (a_{P} u_{P}^{*}) = \\left(\\sum_{nb} a_{nb} u_{nb}^{*} + \\sum_{nb} a_{nb} u_{nb}^{\\prime} + b + S(p_{W}^{*} - p_{E}^{*}) + S(p_{W}^{\\prime} - p_{E}^{\\prime})\\right) - \\left(\\sum_{nb} a_{nb} u_{nb}^{*} + b + S(p_{W}^{*} - p_{E}^{*})\\right)$$\n这简化为动量修正方程：\n$$a_{P} u_{P}^{\\prime} = \\sum_{nb} a_{nb} u_{nb}^{\\prime} + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n在我们的一个一维情况下，即为：\n$$a_{P} u_{P}^{\\prime} = a_{W} u_{W}^{\\prime} + a_{E} u_{E}^{\\prime} + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n\n现在，我们根据 SIMPLE 和 SIMPLEC 算法所做的具体近似，推导速度修正量 $u_{P}^{\\prime}$ 的表达式。\n\n**SIMPLE 算法的速度修正**\n标准的 SIMPLE 算法通过忽略相邻节点速度修正项 $\\sum_{nb} a_{nb} u_{nb}^{\\prime}$ 来简化动量修正方程。这是一个重要的近似，其基础是假设压力修正是速度变化的主要驱动力。将此应用于我们的一维方程：\n$$a_{P} u_{P}^{\\prime} \\approx S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n求解节点 $P$ 处的速度修正量，得到 SIMPLE 的预测值：\n$$u_{P, \\text{SIMPLE}}^{\\prime} = \\frac{S}{a_{P}} \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n\n**SIMPLEC 算法的速度修正**\nSIMPLEC (SIMPLE-Consistent) 算法旨在获得更一致的近似。它不是完全舍弃相邻修正项，而是对其进行近似。问题陈述要求使用速度修正场缓变的假设，即 $u_{W}^{\\prime} \\approx u_{P}^{\\prime}$ 和 $u_{E}^{\\prime} \\approx u_{P}^{\\prime}$。我们将这个近似代入完整的动量修正方程：\n$$a_{P} u_{P}^{\\prime} \\approx a_{W} u_{P}^{\\prime} + a_{E} u_{P}^{\\prime} + S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n现在，我们将包含 $u_{P}^{\\prime}$ 的项组合到左侧，并求解 $u_{P}^{\\prime}$：\n$$a_{P} u_{P}^{\\prime} - a_{W} u_{P}^{\\prime} - a_{E} u_{P}^{\\prime} \\approx S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n$$\\left( a_{P} - a_{W} - a_{E} \\right) u_{P}^{\\prime} \\approx S \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n这得出了由 SIMPLEC 预测的节点 $P$ 处的速度修正量：\n$$u_{P, \\text{SIMPLEC}}^{\\prime} = \\frac{S}{a_{P} - a_{W} - a_{E}} \\left( p_{W}^{\\prime} - p_{E}^{\\prime} \\right)$$\n\n**SIMPLEC 和 SIMPLE 修正量之差**\n最后，我们计算 SIMPLEC 预测和 SIMPLE 预测的速度修正量之间的差值。我们使用给定的定义 $\\Delta p^{\\prime} = p_{W}^{\\prime} - p_{E}^{\\prime}$。\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = \\frac{S \\Delta p^{\\prime}}{a_{P} - a_{W} - a_{E}} - \\frac{S \\Delta p^{\\prime}}{a_{P}}$$\n提取公因式 $S \\Delta p^{\\prime}$：\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{1}{a_{P} - a_{W} - a_{E}} - \\frac{1}{a_{P}} \\right)$$\n为简化，我们通过找到公分母 $a_{P} (a_{P} - a_{W} - a_{E})$ 来合并括号内的分数：\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{a_{P} - \\left( a_{P} - a_{W} - a_{E} \\right)}{a_{P} \\left( a_{P} - a_{W} - a_{E} \\right)} \\right)$$\n化简分子：\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{a_{P} - a_{P} + a_{W} + a_{E}}{a_{P} \\left( a_{P} - a_{W} - a_{E} \\right)} \\right)$$\n$$u_{P, \\text{SIMPLEC}}^{\\prime} - u_{P, \\text{SIMPLE}}^{\\prime} = S \\Delta p^{\\prime} \\left( \\frac{a_{W} + a_{E}}{a_{P} \\left( a_{P} - a_{W} - a_{E} \\right)} \\right)$$\n这给出了所要求的速度修正量之差的最终简化解析表达式。", "answer": "$$\\boxed{\\frac{S \\Delta p^{\\prime} (a_{W} + a_{E})}{a_{P} (a_{P} - a_{W} - a_{E})}}$$", "id": "3362268"}, {"introduction": "在将理论算法转化为可靠的计算程序时，代码验证是不可或缺的一步。本练习将引导您使用“制造解方法”(Method of Manufactured Solutions, MMS)，这是一个严格检验代码正确性和收敛精度的标准技术。通过构建一个已知的解析解，您将能够量化并验证您实现的压力修正泊松方程求解器是否达到了预期的二阶空间收敛精度[@problem_id:3362285]，这是确保整个SIMPLE算法框架正确运行的基础。", "problem": "考虑在单位正方形 $\\Omega = (0,1)\\times(0,1)$ 内，具有恒定密度 $\\rho$ 和运动粘度 $\\nu$ 的牛顿流体的稳态、二维、不可压缩流动。控制方程为稳态不可压缩 Navier–Stokes 方程，\n$$\n\\nabla\\cdot \\mathbf{u} = 0,\\quad\n\\rho\\,(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\rho\\,\\nu\\,\\nabla^2 \\mathbf{u} + \\mathbf{f},\n$$\n边界条件为无滑移速度边界条件，以及下文将指定的在 $\\partial\\Omega$ 上的压力修正的 Dirichlet 边界条件。这里 $\\mathbf{u} = (u,v)$ 是速度场，$p$ 是压力。\n\n您将采用“人造解方法”（Method of Manufactured Solutions）构建一个精确的解析解，并用它来验证由三种压力-速度耦合算法计算出的压力修正 $p'$ 的空间收敛阶：SIMPLE（Semi-Implicit Method for Pressure-Linked Equations）、SIMPLER（Semi-Implicit Method for Pressure-Linked Equations Revised）和 SIMPLEC（Semi-Implicit Method for Pressure-Linked Equations Consistent）。\n\n人造解析解：\n- 选择速度场\n$$\nu(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y),\\qquad v(x,y) = -\\cos(\\pi x)\\,\\sin(\\pi y),\n$$\n该速度场对所有 $(x,y)\\in\\Omega$ 都满足 $\\nabla\\cdot\\mathbf{u}=0$。选择压力场\n$$\np(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n该压力场在 $\\partial\\Omega$ 上满足 $p(x,y)=0$。利用这些场，可以构建一个体力 $\\mathbf{f}(x,y)$，使得 $(\\mathbf{u},p)$ 成为稳态方程的精确解。\n\nSIMPLE 族中的压力修正方程：\n- 在压力-速度耦合框架中，压力修正 $p'$ 满足一个泊松型压力修正方程，该方程源于对预测的质量通量强制执行质量守恒。在均匀网格、中心差分和动量方程对角线系数为常数的情况下，压力修正方程简化为\n$$\n\\nabla^2 p'(x,y) = s(x,y),\n$$\n其中在 $\\partial\\Omega$ 上具有齐次 Dirichlet 边界条件 $p'(x,y)=0$。为验证目的，设人造压力修正为 $p'(x,y) = p(x,y)$，且猜测压力为零，并一致地定义源项为\n$$\ns(x,y) = -\\nabla^2 p'(x,y) = 2\\pi^2 \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n从而使得压力修正方程的精确解为 $p'(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$。\n\n您的任务：\n- 从稳态不可压缩 Navier–Stokes 方程和 SIMPLE 族中压力修正方程的定义出发，证明在给定的人造假设（均匀网格、常系数、中心差分、Dirichlet 边界数据）下，SIMPLE、SIMPLER 和 SIMPLEC 的离散化压力修正方程均简化为关于 $p'(x,y)$ 的标量泊松问题的同一个二阶中心差分近似。\n\n- 实现一个求解器，该求解器使用二阶中心差分，在一系列覆盖 $\\Omega$ 的均匀笛卡尔网格上近似求解 $p'(x,y)$。网格由每个坐标方向上的等分数量 $N\\in\\{8,16,32,64\\}$ 指定，因此网格间距为 $h=1/N$，未知量位于每个方向上的 $N-1$ 个内部点上，且边界上 $p'=0$。对每个 $N$，组装标准的五点离散拉普拉斯算子，并求解得到的线性系统。\n\n- 对于每个 $N$，计算数值解 $p'_h$ 相对于精确人造解 $p'(x,y)$ 的离散 $\\ell^2$ 误差。离散 $\\ell^2$ 误差必须定义为\n$$\nE(h) = \\left(\\sum_{i=1}^{N-1}\\sum_{j=1}^{N-1} \\left(p'_h(x_i,y_j) - p'(x_i,y_j)\\right)^2\\right)^{1/2}\\,h,\n$$\n其中 $x_i=i\\,h$ 且 $y_j=j\\,h$，对于 $i=1,\\dots,N-1$ 和 $j=1,\\dots,N-1$。\n\n- 对于每种算法变体（SIMPLE、SIMPLER、SIMPLEC），使用两个最精细的网格计算 $p'$ 的观测收敛阶 $r$，公式如下\n$$\nr = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)},\n$$\n其中 $h=1/32$ 且 $h/2=1/64$。在这种人造设定下，所有三种算法对压力修正方程使用相同的空间离散化方法，因此观测到的 $r$ 值应该相等且接近于 $2$。\n\n测试套件和输出规范：\n- 使用网格尺寸 $N\\in\\{8,16,32,64\\}$ 作为测试套件，以涵盖粗网格的边缘情况和逐渐加密的网格。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 $[\\text{SIMPLE},\\text{SIMPLER},\\text{SIMPLEC}]$。列表中的每个条目是按上述方法计算的浮点值 $r$，例如 $[r_{\\text{SIMPLE}},r_{\\text{SIMPLER}},r_{\\text{SIMPLEC}}]$。", "solution": "控制方程为稳态不可压缩 Navier–Stokes 方程，\n$$\n\\nabla\\cdot \\mathbf{u} = 0,\\qquad\n\\rho\\,(\\mathbf{u}\\cdot\\nabla)\\mathbf{u} = -\\nabla p + \\rho\\,\\nu\\,\\nabla^2 \\mathbf{u} + \\mathbf{f}.\n$$\n我们选择人造场\n$$\nu(x,y) = \\sin(\\pi x)\\,\\cos(\\pi y),\\quad v(x,y) = -\\cos(\\pi x)\\,\\sin(\\pi y),\\quad p(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n这些场满足不可压缩性条件，因为\n$$\n\\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}\n= \\pi\\cos(\\pi x)\\,\\cos(\\pi y) - \\pi\\cos(\\pi x)\\,\\cos(\\pi y) = 0.\n$$\n给定 $\\rho$ 和 $\\nu$，可将 $(\\mathbf{u},p)$ 代入动量方程，并计算出使 $(\\mathbf{u},p)$ 成为精确解的体力 $\\mathbf{f}(x,y)$；这利用了控制定律的基本原理。\n\nSIMPLE（Semi-Implicit Method for Pressure-Linked Equations）族中的压力-速度耦合方法引入了一个根据猜测压力计算的中间速度 $\\mathbf{u}^*$，随后使用压力修正 $p'$ 来校正质量通量以满足连续性方程。该修正步骤满足一个从离散连续性方程和离散动量方程推导出的压力修正方程。在其通用的有限体积形式中，离散压力修正方程可写为\n$$\n\\sum_{f\\in \\text{faces}} \\rho\\,d_f\\,\\left(p'_N - p'_P\\right) = \\sum_{f\\in \\text{faces}} \\dot{m}^*_f,\n$$\n其中 $d_f$ 是代表逆动量对角线和几何因子的系数，$P$ 表示当前考虑的单元，$N$ 表示相邻单元，$\\dot{m}^*_f$ 是违反连续性方程的预测质量通量。在均匀网格、物性恒定和中心差分的情况下，动量方程的对角线系数 $a_P$ 在所有单元上都是常数，面系数 $d_f$ 也变为常数，预测质量通量的离散散度简化为 $p'$ 的离散拉普拉斯算子的一个均匀缩放。因此，修正方程简化为标量泊松问题\n$$\n\\nabla^2 p'(x,y) = s(x,y)\n$$\n当猜测压力为零且精确压力在边界上为零时，在 $\\partial\\Omega$ 上具有 $p'$ 的齐次 Dirichlet 边界条件。此简化仅使用了算法的核心定义和结构，而未调用快捷公式。SIMPLE（Semi-Implicit Method for Pressure-Linked Equations）、SIMPLER（Semi-Implicit Method for Pressure-Linked Equations Revised）和 SIMPLEC（Semi-Implicit Method for Pressure-Linked Equations Consistent）之间的区别在于中间速度 $\\mathbf{u}^*$ 和耦合系数的形成方式，但在人造的常系数设定下，它们对压力修正方程的空间离散化是完全相同的。\n\n为了制造源项，我们取 $p'(x,y) = p(x,y) = \\sin(\\pi x)\\,\\sin(\\pi y)$（这与猜测压力为零的情况一致），于是\n$$\n\\nabla^2 p'(x,y) = \\frac{\\partial^2}{\\partial x^2}\\sin(\\pi x)\\,\\sin(\\pi y) + \\frac{\\partial^2}{\\partial y^2}\\sin(\\pi x)\\,\\sin(\\pi y)\n= -\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y) - \\pi^2\\sin(\\pi x)\\,\\sin(\\pi y) = -2\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y),\n$$\n因此\n$$\ns(x,y) = -\\nabla^2 p'(x,y) = 2\\pi^2\\sin(\\pi x)\\,\\sin(\\pi y).\n$$\n\n我们在间距为 $h=1/N$ 的均匀网格上离散化泊松方程，内部点为 $(x_i,y_j) = (i h, j h)$，其中 $i=1,\\dots,N-1$ 且 $j=1,\\dots,N-1$。在笛卡尔网格上对 $\\nabla^2 p'$ 的标准二阶中心差分近似得到五点格式，\n$$\n\\left(\\nabla^2 p'\\right)_{i,j} \\approx \\frac{p'_{i+1,j} - 2 p'_{i,j} + p'_{i-1,j}}{h^2} + \\frac{p'_{i,j+1} - 2 p'_{i,j} + p'_{i,j-1}}{h^2},\n$$\n该格式提供了关于 $h$ 的二阶近似。在 $\\partial\\Omega$ 上应用齐次 Dirichlet 边界条件 $p'=0$，离散系统呈矩阵形式\n$$\n\\mathbf{L}\\,\\mathbf{p} = h^2\\,\\mathbf{s},\n$$\n其中 $\\mathbf{L}$ 是带有五点格式的离散二维拉普拉斯算子，$\\mathbf{p}$ 和 $\\mathbf{s}$ 是内部节点上未知数和源项值的向量。\n\n离散 $\\ell^2$ 误差定义为\n$$\nE(h) = \\left(\\sum_{i=1}^{N-1}\\sum_{j=1}^{N-1} \\left(p'_h(x_i,y_j) - p'(x_i,y_j)\\right)^2\\right)^{1/2}\\,h,\n$$\n这是对连续 $L^2$ 范数的一致性求积。对于二阶中心差分，截断误差为 $\\mathcal{O}(h^2)$，并且对于均匀网格上的光滑解，在 Dirichlet 边界条件下，离散解以关于 $h$ 的 2 阶收敛，因此我们期望\n$$\nE(h) \\approx C\\,h^2\n$$\n对于某个常数 $C$，这导致观测到的收敛阶为\n$$\nr = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)} \\approx 2.\n$$\n\n在所述的人造设定中，SIMPLE（Semi-Implicit Method for Pressure-Linked Equations）、SIMPLER（Semi-Implicit Method for Pressure-Linked Equations Revised）和 SIMPLEC（Semi-Implicit Method for Pressure-Linked Equations Consistent）对压力修正方程共享相同的空间离散化方法，因此当线性系统求解至收敛时，它们会产生相同的 $p'$ 解。因此，对 $h=1/32$ 和 $h/2=1/64$ 计算 $E(h)$ 并按上述方式构造 $r$，应得到三个相等且接近 2 的值。该实现使用了二维离散拉普拉斯算子的克罗内克和（Kronecker-sum）构造方法以及一个直接稀疏线性求解器，以消除迭代效应并分离出空间离散化误差，这与基于原理的推导和验证任务相一致。\n\n程序评估了 $N\\in\\{8,16,32,64\\}$ 的误差，并报告了从两个最精细网格计算出的三个观测阶 $[r_{\\text{SIMPLE}}, r_{\\text{SIMPLER}}, r_{\\text{SIMPLEC}}]$，从而验证了在这种人造的、常系数极限情况下，所有三种算法的 $p'$ 在网格加密下均具有二阶收敛性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, kron, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef build_poisson_matrix(m):\n    \"\"\"\n    Build the 2D Poisson matrix with Dirichlet boundary conditions\n    on an m x m interior grid using the 5-point Laplacian.\n    \"\"\"\n    # 1D Laplacian (Dirichlet interior nodes): tridiagonal [-1, 2, -1]\n    main = -2.0 * np.ones(m)\n    off = 1.0 * np.ones(m - 1)\n    L1 = diags([off, main, off], offsets=[-1, 0, 1], format='csr')\n    I = identity(m, format='csr')\n    # 2D Laplacian via Kronecker sum\n    L2 = kron(I, L1) + kron(L1, I)\n    return L2\n\ndef manufactured_source_and_exact(N):\n    \"\"\"\n    Compute source term s(x,y) = 2*pi^2*sin(pi*x)*sin(pi*y)\n    and exact p'(x,y) at interior points for grid size N (spacing h=1/N).\n    Returns (s_flat, p_exact_flat).\n    \"\"\"\n    h = 1.0 / N\n    m = N - 1\n    x = np.linspace(h, 1.0 - h, m)\n    y = np.linspace(h, 1.0 - h, m)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    p_exact = np.sin(np.pi * X) * np.sin(np.pi * Y)\n    s = 2.0 * (np.pi ** 2) * p_exact\n    return s.ravel(), p_exact.ravel()\n\ndef solve_poisson(N):\n    \"\"\"\n    Solve L p = h^2 * s for p on interior grid for given N,\n    with exact source manufactured from p'(x,y) = sin(pi*x)*sin(pi*y).\n    Returns L2 error E(h) with discrete quadrature.\n    \"\"\"\n    h = 1.0 / N\n    m = N - 1\n    L = build_poisson_matrix(m)\n    s_flat, p_exact_flat = manufactured_source_and_exact(N)\n    rhs = (h ** 2) * s_flat\n    p_num = spsolve(L, rhs)\n    # Discrete L2 error: sqrt(sum((error)^2)) * h\n    err = p_num - p_exact_flat\n    E = np.sqrt(np.sum(err ** 2)) * h\n    return E\n\ndef observed_order(e_h, e_h2):\n    \"\"\"\n    Compute observed order r = log(e_h/e_h2)/log(2),\n    where h2 = h/2 (i.e., N doubled).\n    \"\"\"\n    return np.log(e_h / e_h2) / np.log(2.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    grid_sizes = [8, 16, 32, 64]\n\n    # Compute errors for each grid size.\n    errors = {}\n    for N in grid_sizes:\n        errors[N] = solve_poisson(N)\n\n    # Compute observed order using the two finest grids N=32 and N=64.\n    e32 = errors[32]\n    e64 = errors[64]\n    r = observed_order(e32, e64)\n\n    # In this manufactured uniform-coefficient setting, SIMPLE, SIMPLER, and SIMPLEC\n    # produce identical spatial discretizations for the pressure correction equation,\n    # hence identical observed orders.\n    results = [r, r, r]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362285"}, {"introduction": "在解决了基本实现和验证后，我们来探讨一个在实践中普遍存在的数值挑战：压力参考点的缺失问题。对于无固定压力边界（例如纯Neumann边界条件）的不可压缩流，压力场的绝对值是不确定的，这会导致压力修正方程的离散算子存在零空间，进而引起迭代求解过程中的漂移或发散。这个练习模拟了这一场景，要求您实现并比较几种处理这种数值奇异性的常用策略，例如施加零平均约束 $\\int_{\\Omega} p' \\, dV = 0$ 或锚定单个节点的压力值[@problem_id:3362264]，从而掌握确保求解过程稳定收敛的关键技术。", "problem": "考虑一个在单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上的二维、定常、不可压缩流。其主导约束条件是连续性方程 $\\nabla \\cdot \\mathbf{u} = 0$，其中 $\\mathbf{u} = (u_x, u_y)$ 是速度场。在压力耦合方程组的半隐式方法 (SIMPLE) 系列算法中（包括 SIMPLE-Revised (SIMPLER) 和 SIMPLE-Consistent (SIMPLEC)），一个预测速度 $\\mathbf{u}^*$ 通过压力修正量 $p'$ 进行修正，使得修正后的速度为 $\\mathbf{u}^{\\text{new}} = \\mathbf{u}^* + \\mathbf{u}'$，并且通过形如 $\\mathbf{u}' \\approx -\\kappa \\nabla p'$ 的关系来近似满足连续性，其中 $\\kappa > 0$ 是一个常数，它将从线性化动量方程中获得的速度修正量与压力梯度联系起来。压力修正量 $p'$ 通过求解一个泊松型方程得到，该方程是通过将 $\\mathbf{u}^{\\text{new}}$ 代入连续性条件得到的。对于 $p'$ 的纯诺伊曼边界条件（法向梯度为零），$p'$ 的离散算子拥有一个包含常数的零空间。在没有压力基准的情况下，$p'$ 的值可以浮动一个任意的加法常数，并且如果由于建模或离散化缺陷导致源项的域积分不为零，则在迭代求解过程中可能会发生漂移。\n\n您的任务是使用 $\\Omega$ 上的 $N \\times N$ 节点的均匀笛卡尔网格，在程序中实现以下场景：\n\n- 使用均匀间距 $h = 1/(N-1)$ 和节点坐标 $(x_i,y_j)$，其中 $x_i = i h$，$y_j = j h$，适用于所有满足 $0 \\leq i,j \\leq N-1$ 的整数 $i,j$。\n- 通过叠加从流函数 $\\psi(x,y)$ 获得的无散分量和一个可压缩缺陷，构造一个预测速度 $\\mathbf{u}^*$：\n  - 令 $\\psi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$，并定义无散基础速度 $\\mathbf{u}^{\\text{df}} = (\\partial \\psi / \\partial y, -\\partial \\psi / \\partial x)$。\n  - 定义一个可压缩缺陷 $\\mathbf{u}^{\\text{c}} = (\\varepsilon \\sin(\\pi x)\\sin(\\pi y), 0)$，其中 $\\varepsilon > 0$ 是一个小振幅。\n  - 设置 $\\mathbf{u}^* = \\mathbf{u}^{\\text{df}} + \\mathbf{u}^{\\text{c}}$。\n- 使用内部的二阶中心差分和边界处的镜像（诺伊曼）边界处理来计算网格上的离散散度，以形成源项 $f = \\nabla \\cdot \\mathbf{u}^*$。\n- 使用标准的五点拉普拉斯模板和镜像（诺伊曼）边界条件，为 $p'$ 构造离散泊松方程。使用雅可比迭代来更新 $p'$：\n  - 对于内部点，更新基于相邻点的平均值减去 $h^2 f / 4$。\n  - 在边界上，实现与 $\\partial p'/\\partial n = 0$ 一致的镜像邻点处理。\n- 实现压力修正求解的三种算法变体：\n  $1$) 浮动的 $p'$，没有压力基准或约束。\n  $2$) 受约束的 $p'$，在每次迭代中离散地施加零均值条件，即强制执行 $\\sum_{i,j} p'_{i,j} h^2 = 0$，这是 $\\int_{\\Omega} p' \\, dV = 0$ 的离散形式。\n  $3$) 单单元格锚定，即在每次迭代中通过设置 $p'_{0,0} = 0$ 来约束特定单元格（例如 $(i,j) = (0,0)$）。\n\n为了在不正确的压力基准下分析漂移和收敛行为，用一个常数偏移量 $m$ 扰动源项 $f$，使得 $f \\leftarrow f + m$，其中 $m$ 可能非零。这模拟了源项的域积分不为零的不一致情况，该情况与诺伊曼拉普拉斯算子的零空间相互作用。\n\n对于每个变体，计算：\n- $p'$ 的最终均值（离散积分除以面积），用于量化压力漂移（无量纲）。\n- 离散泊松方程的最终残差范数 $\\|\\Delta_h p' - f\\|_2$，其中 $\\Delta_h$ 是离散拉普拉斯算子（无量纲）。\n- 通过使用中心差分计算 $\\nabla_h$ 来计算修正后速度 $\\mathbf{u}^{\\text{new}} = \\mathbf{u}^* - \\kappa \\nabla_h p'$，然后测量 $\\nabla \\cdot \\mathbf{u}^{\\text{new}}$ 的离散 $L^2$ 范数，以此评估对速度的影响（无量纲）。\n- 达到目标残差容差所需的迭代次数，如果未达到，则为执行的最大迭代次数（整数计数）。\n\n使用以下常数和数值选择：\n- 取 $\\kappa = 1$。\n- 将 $p'$ 初始化为处处为零。\n- 使用无超松弛的雅可比迭代。\n- 定义残差容差为 $\\text{tol} = 10^{-8}$，最大迭代次数为 $2000$。\n\n设计一个测试套件以检验不同的行为：\n- 情况 A（具有可观察到漂移的理想路径）：$N = 32$，$\\varepsilon = 0.2$，$m = 10^{-3}$，浮动的 $p'$（无约束）。\n- 情况 B（约束消除漂移）：$N = 32$，$\\varepsilon = 0.2$，$m = 10^{-3}$，受约束的零均值 $p'$。\n- 情况 C（锚定的参考单元格）：$N = 32$，$\\varepsilon = 0.2$，$m = 10^{-3}$，在 $(0,0)$ 进行单单元格锚定。\n- 情况 D（相容源，在无强迫项的情况下测试零空间）：$N = 32$，$\\varepsilon = 0.2$，$m = 0$，浮动的 $p'$。\n\n所有量都是无量纲的；除了迭代次数是整数外，所有输出都报告为浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含四个值的列表，顺序为 $[\\text{mean}(p'), \\|\\Delta_h p' - f\\|_2, \\|\\nabla \\cdot \\mathbf{u}^{\\text{new}}\\|_2, \\text{iterations}]$。例如，格式为 $[[r_{A1}, r_{A2}, r_{A3}, r_{A4}], [r_{B1}, r_{B2}, r_{B3}, r_{B4}], [r_{C1}, r_{C2}, r_{C3}, r_{C4}], [r_{D1}, r_{D2}, r_{D3}, r_{D4}]]$.", "solution": "该问题要求分析不可压缩流的压力修正方法，特别关注在纯诺伊曼边界条件下求解压力修正泊松方程的数值稳定性。任务的核心是实现一个数值模拟，展示不同的稳定化技术如何处理离散诺伊曼-拉普拉斯算子的零空间（常值函数），尤其是在源项不相容（即其域积分为非零）时。\n\n解决方案通过以下步骤制定：\n\n1.  **离散化和场定义**：\n    连续域 $\\Omega = [0,1] \\times [0,1]$ 被离散化为 $N \\times N$ 个节点的均匀笛卡尔网格。网格间距为 $h = 1/(N-1)$。节点坐标为 $(x_i, y_j)$，其中对于从 $0$ 到 $N-1$ 的整数 $i,j$，$x_i = i h$ 且 $y_j = j h$。\n    在该网格上构造一个预测速度场 $\\mathbf{u}^* = (u_x^*, u_y^*)$。它包含一个从流函数 $\\psi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ 导出的无散部分 $\\mathbf{u}^{\\text{df}}$ 和一个可压缩缺陷 $\\mathbf{u}^{\\text{c}}$：\n    $$ \\mathbf{u}^{\\text{df}} = \\left( \\frac{\\partial \\psi}{\\partial y}, -\\frac{\\partial \\psi}{\\partial x} \\right) = (2\\pi \\sin(2\\pi x)\\cos(2\\pi y), -2\\pi \\cos(2\\pi x)\\sin(2\\pi y)) $$\n    $$ \\mathbf{u}^{\\text{c}} = (\\varepsilon \\sin(\\pi x)\\sin(\\pi y), 0) $$\n    得到的预测速度为 $\\mathbf{u}^* = \\mathbf{u}^{\\text{df}} + \\mathbf{u}^{\\text{c}}$。\n\n2.  **源项构建**：\n    压力修正量 $p'$ 必须满足泊松方程 $\\Delta p' = f$，其中源项 $f$ 是预测速度的散度，$f = \\nabla \\cdot \\mathbf{u}^*$。解析地看，$\\nabla \\cdot \\mathbf{u}^{\\text{df}} = 0$，因此散度完全由缺陷引起：$f = \\nabla \\cdot \\mathbf{u}^{\\text{c}} = \\varepsilon \\pi \\cos(\\pi x) \\sin(\\pi y)$。\n    问题指定使用二阶中心差分算子（表示为 $\\nabla_h \\cdot$）离散地计算 $f$。对于矢量场 $\\mathbf{q}=(q_x, q_y)$，其在节点 $(i,j)$ 处的散度为：\n    $$ (\\nabla_h \\cdot \\mathbf{q})_{i,j} = \\frac{q_{x,i+1,j} - q_{x,i-1,j}}{2h} + \\frac{q_{y,i,j+1} - q_{y,i,j-1}}{2h} $$\n    在边界处，使用镜像（零诺伊曼）边界处理。这是通过使用虚拟点实现的，其中虚拟点上场的值是其相应内部点的对称反射（例如，$q_{x,-1,j} = q_{x,1,j}$）。该方法一致地应用于所有离散微分算子。\n\n3.  **压力修正泊松方程**：\n    我们求解离散泊松方程 $\\Delta_h p' = f$，其中 $\\Delta_h$ 是与零诺伊曼边界条件 $\\partial p'/\\partial n = 0$ 一致的拉普拉斯算子的标准五点模板。在第 $k+1$ 步的雅可比迭代更新规则是：\n    $$ p'^{(k+1)}_{i,j} = \\frac{1}{4} \\left( p'^{(k)}_{i+1,j} + p'^{(k)}_{i-1,j} + p'^{(k)}_{i,j+1} + p'^{(k)}_{i,j-1} - h^2 f_{i,j} \\right) $$\n    镜像边界条件通过虚拟点处理，例如在边界 $i=0$ 处：\n    $$ p'^{(k+1)}_{0,j} = \\frac{1}{4} \\left( 2p'^{(k)}_{1,j} + p'^{(k)}_{0,j+1} + p'^{(k)}_{0,j-1} - h^2 f_{0,j} \\right) $$\n    源项 $f$ 被一个常数偏移量 $m$ 扰动，因此方程变为 $\\Delta_h p' = f + m$。这模拟了一种常见的数值情况，即离散源项的总和不为零，即 $\\sum_{i,j} (f_{i,j}+m)h^2 \\neq 0$。这违反了诺伊曼-泊松问题的可解性条件，因为根据散度定理，拉普拉斯算子输出的积分总是零。\n\n4.  **处理零空间**：\n    具有诺伊曼边界条件的离散算子 $\\Delta_h$ 拥有一个由常数场组成的零空间。这意味着如果 $p'$ 是一个解，那么对于任何常数 $C$，$p' + C$ 也是解。如果源项不相容（积分非零），迭代解通常会发散或漂移。实现了三个变体来管理此问题：\n    - **浮动的 $p'$**：不施加任何约束。对于不相容的源（$m \\neq 0$），$p'$ 的均值预计会无限漂移。\n    - **受约束的 $p'$**：在每次迭代中强制执行零均值条件 $\\sum_{i,j} p'_{i,j} h^2 = 0$。这是通过计算更新后的压力场的算术平均值并从每个点减去该值来实现的：$p' \\leftarrow p' - \\text{mean}(p')$。这可以稳定均值，但不能解决根本的不相容性问题，从而阻止收敛到指定的容差。\n    - **单单元格锚定**：在每次迭代中将单个单元格的压力 $p'_{0,0}$ 固定为 $0$。这消除了常数偏移的自由度，使得线性系统非奇异，并确保即使在有不相容源的情况下也能收敛到唯一解。\n\n5.  **指标计算**：\n    在迭代求解器收敛到 $\\text{tol} = 10^{-8}$ 的容差或达到 $2000$ 次最大迭代次数后，计算四个指标：\n    - **$p'$ 的均值**：最终压力场的算术平均值，$\\frac{1}{N^2}\\sum_{i,j}p'_{i,j}$。\n    - **残差范数**：最终残差的离散 $L^2$ 范数，$\\|\\Delta_h p' - (f+m)\\|_2 = \\sqrt{\\sum_{i,j} (\\Delta_h p'_{i,j} - (f_{i,j}+m))^2}$。\n    - **修正后速度散度范数**：计算新的速度场 $\\mathbf{u}^{\\text{new}} = \\mathbf{u}^* - \\kappa \\nabla_h p'$，其中 $\\kappa=1$，$\\nabla_h$ 是离散梯度算子（使用中心差分和镜像边界）。然后计算其散度的 $L^2$ 范数 $\\|\\nabla_h \\cdot \\mathbf{u}^{\\text{new}}\\|_2$。\n    - **迭代次数**：执行的雅可比迭代次数。\n\n该实现封装了此逻辑，并将其系统地应用于四个指定的测试用例，每个用例都旨在突出数值行为的不同方面。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, epsilon, m, constraint_type, tol, max_iter, kappa):\n    \"\"\"\n    Runs a single simulation case for the pressure-correction Poisson problem.\n\n    Args:\n        N (int): Number of grid points in each dimension.\n        epsilon (float): Amplitude of the compressible defect.\n        m (float): Constant offset for the source term.\n        constraint_type (str): Type of constraint ('floating', 'mean_zero', 'anchor').\n        tol (float): Convergence tolerance for the residual norm.\n        max_iter (int): Maximum number of iterations.\n        kappa (float): Proportionality constant for pressure correction.\n\n    Returns:\n        list: A list containing [final_p_mean, residual_norm, div_u_new_norm, iterations].\n    \"\"\"\n    # 1. Grid and Coordinates\n    h = 1.0 / (N - 1)\n    x = np.linspace(0, 1, N)\n    y = np.linspace(0, 1, N)\n    # 'ij' indexing ensures xx[i, j] = x[i] and yy[i, j] = y[j]\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Velocity Field Construction\n    # Divergence-free component from streamfunction\n    ux_df = 2 * np.pi * np.sin(2 * np.pi * xx) * np.cos(2 * np.pi * yy)\n    uy_df = -2 * np.pi * np.cos(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n\n    # Compressible defect\n    ux_c = epsilon * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    uy_c = np.zeros_like(yy)\n\n    # Tentative velocity u*\n    ux_star = ux_df + ux_c\n    uy_star = uy_df + uy_c\n\n    # Helper functions for discrete operators with mirrored Neumann boundaries\n    def discr_divergence(u, v, h_val):\n        u_padded = np.pad(u, 1, mode='symmetric')\n        v_padded = np.pad(v, 1, mode='symmetric')\n        du_dx = (u_padded[2:, 1:-1] - u_padded[:-2, 1:-1]) / (2 * h_val)\n        dv_dy = (v_padded[1:-1, 2:] - v_padded[1:-1, :-2]) / (2 * h_val)\n        return du_dx + dv_dy\n\n    def discr_gradient(p, h_val):\n        p_padded = np.pad(p, 1, mode='symmetric')\n        dp_dx = (p_padded[2:, 1:-1] - p_padded[:-2, 1:-1]) / (2 * h_val)\n        dp_dy = (p_padded[1:-1, 2:] - p_padded[1:-1, :-2]) / (2 * h_val)\n        return dp_dx, dp_dy\n\n    def discr_laplacian(p, h_val):\n        p_padded = np.pad(p, 1, mode='symmetric')\n        lap_p = (p_padded[2:, 1:-1] + p_padded[:-2, 1:-1] +\n                 p_padded[1:-1, 2:] + p_padded[1:-1, :-2] - 4 * p) / h_val**2\n        return lap_p\n\n    # 3. Source Term Calculation\n    f = discr_divergence(ux_star, uy_star, h)\n    f += m  # Add perturbation\n\n    # 4. Jacobi Iteration for the Poisson equation\n    p_prime = np.zeros((N, N))\n    iterations = 0\n    residual_norm = np.inf\n\n    for k in range(max_iter):\n        iterations = k + 1\n        \n        # Jacobi update step\n        p_padded = np.pad(p_prime, 1, mode='symmetric')\n        p_new = (p_padded[2:, 1:-1] + p_padded[:-2, 1:-1] +\n                 p_padded[1:-1, 2:] + p_padded[1:-1, :-2] - h**2 * f) / 4.0\n        \n        # 5. Apply constraints based on the variant\n        if constraint_type == 'mean_zero':\n            p_new -= np.mean(p_new)\n        elif constraint_type == 'anchor':\n            p_new[0, 0] = 0.0\n        # For 'floating', no action is taken.\n        \n        p_prime = p_new\n\n        # Check for convergence based on the L2 norm of the residual\n        residual = discr_laplacian(p_prime, h) - f\n        residual_norm = np.linalg.norm(residual)\n        if residual_norm  tol:\n            break\n            \n    # 6. Post-Processing and Metrics Calculation\n    final_p_mean = np.mean(p_prime)\n    \n    # Corrected velocity divergence calculation\n    dp_dx, dp_dy = discr_gradient(p_prime, h)\n    ux_new = ux_star - kappa * dp_dx\n    uy_new = uy_star - kappa * dp_dy\n    \n    div_u_new = discr_divergence(ux_new, uy_new, h)\n    div_u_new_norm = np.linalg.norm(div_u_new)\n\n    return [final_p_mean, residual_norm, div_u_new_norm, int(iterations)]\n\n\ndef solve():\n    \"\"\"\n    Main function to define and run the test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, epsilon, m, constraint_type)\n        (32, 0.2, 1e-3, 'floating'),     # Case A\n        (32, 0.2, 1e-3, 'mean_zero'),   # Case B\n        (32, 0.2, 1e-3, 'anchor'),       # Case C\n        (32, 0.2, 0.0, 'floating'),      # Case D\n    ]\n\n    # Global constants for the simulation\n    tol = 1e-8\n    max_iter = 2000\n    kappa = 1.0\n    \n    results = []\n    for N, epsilon, m, constraint_type in test_cases:\n        result = run_simulation(N, epsilon, m, constraint_type, tol, max_iter, kappa)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362264"}]}