{"hands_on_practices": [{"introduction": "理论知识的掌握需要通过实践来巩固。本节的第一个练习将引导您深入PISO算法的核心——“预测”步骤。通过为一个紧邻入口边界的控制体手动构建离散动量方程并求解初步速度场 $u_P^*$，您将具体了解对流、扩散、瞬态项和压力梯度如何共同作用，从而为后续的校正步骤打下坚实的基础。[@problem_id:3377777]", "problem": "考虑在横截面积恒定的直管道中，牛顿流体的一维瞬态不可压缩流动。您将研究一个与给定速度入口边界相邻的有限体积单元，并执行算子分裂压力隐式 (PISO) 算法的预测步。从Navier–Stokes方程推导出的轴向速度场 $u(x,t)$ 的一维动量平衡方程开始，\n$$\n\\rho\\,\\frac{\\partial u}{\\partial t} + \\rho\\,u\\,\\frac{\\partial u}{\\partial x} \\;=\\; -\\,\\frac{\\partial p}{\\partial x} \\;+\\; \\mu\\,\\frac{\\partial^2 u}{\\partial x^2},\n$$\n并在宽度为 $\\Delta x$、横截面积为 $\\mathcal{A}$ 的控制体上使用守恒的有限体积法 (FVM) 进行离散化，预测步采用以下模型选择：\n- 对瞬态项使用一阶隐式时间离散。\n- 对对流项使用一阶迎风格式，并使用从已知时间层 $n$ 计算的面质量通量进行线性化。\n- 对扩散项使用中心差分格式，对单元 $P$ 的贡献进行隐式处理，而在预测步的组装中，对相邻单元和边界的贡献则延迟到时间层 $n$。\n- 压力梯度在时间层 $n$ 采用单元中心 $P$ 处的两点差分进行评估，即 $(\\partial p^n/\\partial x)_P \\approx (p_E^n - p_W^n)/\\Delta x$。\n\n设控制体（单元 $P$）的宽度为 $\\Delta x = 0.10\\,\\mathrm{m}$，横截面积为 $\\mathcal{A} = 0.010\\,\\mathrm{m}^2$，因此其体积为 $V = \\mathcal{A}\\,\\Delta x$。流体属性和时间步长为 $\\rho = 1000\\,\\mathrm{kg/m^3}$，$\\mu = 1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$，以及 $\\Delta t = 0.010\\,\\mathrm{s}$。在时间层 $n$ 的已知量如下：\n- 单元 $P$ 的中心速度：$u_P^n = 1.20\\,\\mathrm{m/s}$。\n- 东侧相邻单元 $E$ 的中心速度：$u_E^n = 1.15\\,\\mathrm{m/s}$。\n- 给定的入口（西侧边界）速度：$u_{\\text{inlet}}^n = 1.25\\,\\mathrm{m/s}$。\n- 入口压力（在西侧边界表面）：$p_W^n = 101000\\,\\mathrm{Pa}$。\n- 东侧相邻单元中心压力：$p_E^n = 100000\\,\\mathrm{Pa}$。\n\n假设流动方向为从西向东为正（与时间层 $n$ 的给定速度一致），因此东侧表面的迎风值为单元中心值 $u_P^n$，而西侧表面是入口边界，其表面速度等于 $u_{\\text{inlet}}^n$。定义表面质量通量为 $F_W = \\rho\\,\\mathcal{A}\\,u_{W,f}^n$ 和 $F_E = \\rho\\,\\mathcal{A}\\,u_{E,f}^n$，扩散导率为 $D_W = \\mu\\,\\mathcal{A}/\\Delta x$ 和 $D_E = \\mu\\,\\mathcal{A}/\\Delta x$。\n\n在PISO预测步方程中，为单元 $P$ 显式组装对角动量系数 $A_u$ 和累积的非压力贡献项 $\\boldsymbol{H}_u$\n$$\nA_u\\,u_P^{*} \\;=\\; \\boldsymbol{H}_u \\;-\\; V\\left(\\frac{\\partial p^n}{\\partial x}\\right)_P,\n$$\n确保在入口处包含适当的边界贡献。然后计算单元 $P$ 的暂定速度 $u_P^{*}$。以米/秒为单位表示最终的暂定速度，并将您的答案四舍五入到五位有效数字。如果出现任何角度，请仅使用弧度（此处预计不会出现）。", "solution": "该问题要求使用PISO算法的预测步，为一维瞬态不可压缩流动计算单个有限体积单元 $P$ 中的暂定速度 $u_P^{*}$。起点是对控制体 $V = \\mathcal{A}\\Delta x$ 积分的一维动量方程的守恒形式。\n\n守恒形式的控制方程为：\n$$\n\\frac{\\partial (\\rho u)}{\\partial t} + \\frac{\\partial (\\rho u^2)}{\\partial x} = -\\frac{\\partial p}{\\partial x} + \\frac{\\partial}{\\partial x}\\left(\\mu \\frac{\\partial u}{\\partial x}\\right)\n$$\n将此方程在单元 $P$ 的控制体 $V$ 上积分，得到：\n$$\n\\int_V \\frac{\\partial (\\rho u)}{\\partial t} dV + \\int_V \\frac{\\partial (\\rho u^2)}{\\partial x} dV = \\int_V \\left( -\\frac{\\partial p}{\\partial x} \\right) dV + \\int_V \\frac{\\partial}{\\partial x}\\left(\\mu \\frac{\\partial u}{\\partial x}\\right) dV\n$$\n对空间导数项应用散度定理，将体积分转换为单元表面（西侧表面 $w$ 和东侧表面 $e$）上的面积分：\n$$\nV \\frac{\\partial (\\rho u_P)}{\\partial t} + [(\\rho u^2)\\mathcal{A}]_e - [(\\rho u^2)\\mathcal{A}]_w = -V \\left(\\frac{\\partial p}{\\partial x}\\right)_P + \\left[\\mu\\mathcal{A}\\frac{\\partial u}{\\partial x}\\right]_e - \\left[\\mu\\mathcal{A}\\frac{\\partial u}{\\partial x}\\right]_w\n$$\n现在我们根据问题陈述对各项进行离散化，以求解暂定速度 $u_P^*$。\n\n1.  **瞬态项：** 使用一阶隐式格式。\n    $$ V \\frac{\\partial (\\rho u_P)}{\\partial t} \\approx V \\rho \\frac{u_P^* - u_P^n}{\\Delta t} = \\frac{\\rho V}{\\Delta t}(u_P^* - u_P^n) $$\n\n2.  **对流项：** 使用一阶迎风格式，其中表面质量通量 $F = \\rho u_f \\mathcal{A}$ 在已知的时间层 $n$ 进行评估。流动方向为从西向东 ($u^n > 0$)。\n    *   在东侧表面 ($e$)，迎风单元是 $P$。质量通量为 $F_E = \\rho \\mathcal{A} u_{E,f}^n = \\rho \\mathcal{A} u_P^n$。被对流的速度为 $u_P^*$。通量为 $F_E u_P^*$。\n    *   在西侧表面 ($w$)，即入口处，迎风速度是给定的入口速度 $u_{\\text{inlet}}^n$。质量通量为 $F_W = \\rho \\mathcal{A} u_{W,f}^n = \\rho \\mathcal{A} u_{\\text{inlet}}^n$。被对流的速度为 $u_{\\text{inlet}}^n$。通量为 $F_W u_{\\text{inlet}}^n$。\n    *   净对流通量为 $[F u]_e - [F u]_w = F_E u_P^* - F_W u_{\\text{inlet}}^n$。\n\n3.  **扩散项：** 使用中心差分格式。对于单元 $P$ 的贡献 ($u_P^*$)，该项作隐式处理；对于相邻单元和边界的贡献 ($u_E^n, u_{\\text{inlet}}^n$)，则作显式处理（延迟到时间层 $n$）。\n    *   东侧表面的通量为 $\\mu\\mathcal{A}\\frac{u_E - u_P}{\\Delta x} = D_E(u_E - u_P)$。应用时间层规则，这变为 $D_E(u_E^n - u_P^*)$。\n    *   西侧表面的通量为 $\\mu\\mathcal{A}\\frac{u_P - u_{\\text{inlet}}}{\\Delta x} = D_W(u_P - u_{\\text{inlet}})$。应用该规则，这变为 $D_W(u_P^* - u_{\\text{inlet}}^n)$。\n    *   净扩散贡献为 $D_E(u_E^n - u_P^*) - D_W(u_P^* - u_{\\text{inlet}}^n)$。\n\n4.  **压力梯度项：** 此项使用给定公式在时间层 $n$ 进行显式评估：\n    $$ -V \\left(\\frac{\\partial p^n}{\\partial x}\\right)_P = -V \\frac{p_E^n - p_W^n}{\\Delta x} $$\n\n将所有离散项组合成一个方程：\n$$\n\\frac{\\rho V}{\\Delta t}(u_P^* - u_P^n) + (F_E u_P^* - F_W u_{\\text{inlet}}^n) = -V \\frac{p_E^n - p_W^n}{\\Delta x} + D_E(u_E^n - u_P^*) - D_W(u_P^* - u_{\\text{inlet}}^n)\n$$\n我们重排此方程，将所有包含 $u_P^*$ 的项归到左侧 (LHS)，所有其他项归到右侧 (RHS)。\n$$\n\\frac{\\rho V}{\\Delta t}u_P^* + F_E u_P^* + D_E u_P^* + D_W u_P^* = \\frac{\\rho V}{\\Delta t}u_P^n + F_W u_{\\text{inlet}}^n + D_E u_E^n + D_W u_{\\text{inlet}}^n - V \\frac{p_E^n - p_W^n}{\\Delta x}\n$$\n该方程与指定形式 $A_u u_P^* = \\boldsymbol{H}_u - V(\\partial p^n / \\partial x)_P$ 相匹配，其中：\n对角动量系数为：\n$$ A_u = \\frac{\\rho V}{\\Delta t} + F_E + D_E + D_W $$\n累积的非压力贡献项为：\n$$ \\boldsymbol{H}_u = \\frac{\\rho V}{\\Delta t}u_P^n + F_W u_{\\text{inlet}}^n + D_E u_E^n + D_W u_{\\text{inlet}}^n $$\n压力项为：\n$$ -V\\left(\\frac{\\partial p^n}{\\partial x}\\right)_P = -V \\frac{p_E^n - p_W^n}{\\Delta x} $$\n\n现在，我们代入给定的数值：\n*   $\\rho = 1000\\,\\mathrm{kg/m^3}$\n*   $\\mu = 1.0 \\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$\n*   $\\Delta t = 0.010\\,\\mathrm{s}$\n*   $\\Delta x = 0.10\\,\\mathrm{m}$\n*   $\\mathcal{A} = 0.010\\,\\mathrm{m}^2$\n*   $V = \\mathcal{A}\\Delta x = (0.010\\,\\mathrm{m}^2)(0.10\\,\\mathrm{m}) = 0.0010\\,\\mathrm{m}^3$\n*   $u_P^n = 1.20\\,\\mathrm{m/s}$\n*   $u_E^n = 1.15\\,\\mathrm{m/s}$\n*   $u_{\\text{inlet}}^n = 1.25\\,\\mathrm{m/s}$\n*   $p_W^n = 101000\\,\\mathrm{Pa}$\n*   $p_E^n = 100000\\,\\mathrm{Pa}$\n\n首先，我们计算中间系数：\n*   瞬态项系数：$\\frac{\\rho V}{\\Delta t} = \\frac{1000 \\times 0.0010}{0.010} = 100\\,\\mathrm{kg/s}$\n*   质量通量 $F_W = \\rho\\mathcal{A}u_{\\text{inlet}}^n = 1000 \\times 0.010 \\times 1.25 = 12.5\\,\\mathrm{kg/s}$\n*   质量通量 $F_E = \\rho\\mathcal{A}u_P^n = 1000 \\times 0.010 \\times 1.20 = 12.0\\,\\mathrm{kg/s}$\n*   扩散导率 $D_W = D_E = \\frac{\\mu\\mathcal{A}}{\\Delta x} = \\frac{1.0\\times 10^{-3} \\times 0.010}{0.10} = 1.0 \\times 10^{-4}\\,\\mathrm{kg/s}$\n\n接下来，我们组装 $A_u$ 和 $\\boldsymbol{H}_u$：\n*   $A_u = 100 + 12.0 + 1.0 \\times 10^{-4} + 1.0 \\times 10^{-4} = 112.0002\\,\\mathrm{kg/s}$\n*   $\\boldsymbol{H}_u = (\\frac{\\rho V}{\\Delta t})u_P^n + F_W u_{\\text{inlet}}^n + D_E u_E^n + D_W u_{\\text{inlet}}^n$\n    $\\boldsymbol{H}_u = (100 \\times 1.20) + (12.5 \\times 1.25) + (1.0 \\times 10^{-4} \\times 1.15) + (1.0 \\times 10^{-4} \\times 1.25)$\n    $\\boldsymbol{H}_u = 120 + 15.625 + 0.000115 + 0.000125 = 135.62524\\,\\mathrm{N}$\n\n然后，我们计算压力源项：\n*   $-V\\left(\\frac{\\partial p^n}{\\partial x}\\right)_P = -0.0010 \\times \\frac{100000 - 101000}{0.10} = -0.0010 \\times \\frac{-1000}{0.10} = -0.0010 \\times (-10000) = 10\\,\\mathrm{N}$\n\n最后，我们求解 $u_P^*$：\n$$ A_u u_P^* = \\boldsymbol{H}_u - V\\left(\\frac{\\partial p^n}{\\partial x}\\right)_P $$\n$$ 112.0002 \\times u_P^* = 135.62524 + 10 = 145.62524 $$\n$$ u_P^* = \\frac{145.62524}{112.0002} \\approx 1.300223388\\,\\mathrm{m/s} $$\n将结果四舍五入到五位有效数字，得到 $u_P^* = 1.3002\\,\\mathrm{m/s}$。", "answer": "$$\\boxed{1.3002}$$", "id": "3377777"}, {"introduction": "在计算出初步速度场 $u^*$ 后，一个自然而然的问题是：为什么它还需要“校正”？这个练习旨在回答这一问题，它揭示了基于旧时间步压力计算出的预测速度场通常不满足质量守恒定律。通过量化这种由旧压力梯度引起的质量不平衡（即散度残差），您将清晰地理解压力校正的必要性，并明确压力泊松方程的源项究竟从何而来。[@problem_id:3377826]", "problem": "考虑一种密度为常数 $\\rho$ 的不可压缩牛顿流体，正在进行瞬态计算，该计算通过压力隐式算子分裂 (PISO) 算法推进。计算网格是一个二维正交矩形单元，其平面外方向的厚度为 $L_z = 1$，边界为 $x \\in [0.1, 0.3]$ 和 $y \\in [0.0, 0.2]$（因此 $\\Delta x = 0.2$ 且 $\\Delta y = 0.2$）。该区域在 $x$ 和 $y$ 方向上都是周期性的。时间步长为 $\\Delta t = 0.05$。离散动量预测步的执行方式是：将压力梯度显式滞后到时间层 $n$，在此单步中忽略对流和扩散，并取前一时刻的速度为零，因此预测速度场满足 $u^{*} = u^{n} - (\\Delta t/\\rho)\\nabla p^{n}$，其中 $u^{n} = 0$。\n\n面质量通量 $\\dot{m}^{*}_{f}$ 由预测速度通过 $\\dot{m}^{*}_{f} = \\rho\\,u^{*}_{f}\\cdot S_{f}$ 构建，其中 $S_{f}$ 是指向外的面面积矢量，面速度 $u^{*}_{f}$ 通过在面心处计算 $\\nabla p^{n}$ 并在每个面上应用中点法则获得。使用线性（中心）插值来计算所有面心量。时间层 $n$ 的压力规定为 $p^{n}(x,y) = p_{0} + a x^{2} + b y^{2}$，其中 $p_{0}$ 为常数，$a = 2.0 \\times 10^{3}$，$b = -1.0 \\times 10^{3}$，并且 $a$ 和 $b$ 的单位使得 $ax^2$ 和 $by^2$ 的单位为帕斯卡。\n\n从不可压缩连续性方程和上面提供的预测步定义出发，推导预测步后给定单元中残差散度 $\\sum_{f}\\dot{m}^{*}_{f}$ 的离散表达式。然后，根据指定的网格和数据计算其数值。将最终数值答案四舍五入至四位有效数字。以 $\\mathrm{kg/s}$ 为单位表示最终的残余质量不平衡。", "solution": "该问题要求推导和计算离散残差散度，它表示 PISO 算法预测步后计算单元中的净质量不平衡。该量记为 $\\sum_{f}\\dot{m}^{*}_{f}$，是单元所有面 $f$ 上的预测质量通量 $\\dot{m}^{*}_{f}$ 的总和。\n\n计算单元是一个长方体，由边界 $x \\in [0.1, 0.3]$、$y \\in [0.0, 0.2]$ 和平面外厚度 $L_z = 1$ 定义。单元的尺寸为 $\\Delta x = 0.3 - 0.1 = 0.2$ 和 $\\Delta y = 0.2 - 0.0 = 0.2$。该单元在 $x-y$ 平面有四个面：东 ($e$)、西 ($w$)、北 ($n$) 和南 ($s$)。净质量通量是穿过这四个面的通量之和：\n$$\n\\sum_{f}\\dot{m}^{*}_{f} = \\dot{m}^{*}_{e} + \\dot{m}^{*}_{w} + \\dot{m}^{*}_{n} + \\dot{m}^{*}_{s}\n$$\n通过面 $f$ 的预测质量通量由公式 $\\dot{m}^{*}_{f} = \\rho\\,u^{*}_{f}\\cdot S_{f}$ 给出，其中 $\\rho$ 是恒定的流体密度，$u^{*}_{f}$ 是面中心的预测速度矢量，$S_{f}$ 是指向外的面面积矢量。\n\n预测速度场 $u^{*}$ 由简化的动量预测方程给出：\n$$\nu^{*} = u^{n} - \\frac{\\Delta t}{\\rho}\\nabla p^{n}\n$$\n在初始速度 $u^{n}=0$ 的条件下，该方程简化为：\n$$\nu^{*} = - \\frac{\\Delta t}{\\rho}\\nabla p^{n}\n$$\n时间层 $n$ 的压力场规定为 $p^{n}(x,y) = p_{0} + a x^{2} + b y^{2}$。我们首先计算其梯度 $\\nabla p^{n}$：\n$$\n\\nabla p^{n} = \\frac{\\partial p^{n}}{\\partial x}\\mathbf{i} + \\frac{\\partial p^{n}}{\\partial y}\\mathbf{j} = 2ax\\,\\mathbf{i} + 2by\\,\\mathbf{j}\n$$\n将此代入 $u^{*}$ 的方程，得到作为位置函数的预测速度场：\n$$\nu^{*}(x,y) = - \\frac{\\Delta t}{\\rho}(2ax\\,\\mathbf{i} + 2by\\,\\mathbf{j})\n$$\n接下来，我们计算四个面各自的质量通量。问题规定，面心量在每个面的几何中心计算。面面积矢量 $S_f$ 计算为面面积乘以向外的单位法向矢量。\n\n1.  **东面 ($e$)**：\n    该面位于 $x=0.3$。其中心在 $(x_e, y_e) = (0.3, 0.1)$。\n    面积矢量为 $S_e = (\\Delta y L_z)\\mathbf{i} = (0.2 \\times 1)\\mathbf{i} = 0.2\\,\\mathbf{i}$。\n    面中心的速度为 $u^{*}_{e} = u^{*}(x_e, y_e) = -\\frac{\\Delta t}{\\rho}(2ax_e\\,\\mathbf{i} + 2by_e\\,\\mathbf{j})$。\n    质量通量为：\n    $$\n    \\dot{m}^{*}_{e} = \\rho (u^{*}_{e} \\cdot S_{e}) = \\rho \\left(-\\frac{\\Delta t}{\\rho}(2ax_e)\\right)(\\Delta y L_z) = -2a \\Delta t x_e \\Delta y L_z\n    $$\n\n2.  **西面 ($w$)**：\n    该面位于 $x=0.1$。其中心在 $(x_w, y_w) = (0.1, 0.1)$。\n    面积矢量为 $S_w = -(\\Delta y L_z)\\mathbf{i} = -0.2\\,\\mathbf{i}$。\n    面中心的速度为 $u^{*}_{w} = u^{*}(x_w, y_w) = -\\frac{\\Delta t}{\\rho}(2ax_w\\,\\mathbf{i} + 2by_w\\,\\mathbf{j})$。\n    质量通量为：\n    $$\n    \\dot{m}^{*}_{w} = \\rho (u^{*}_{w} \\cdot S_{w}) = \\rho \\left(-\\frac{\\Delta t}{\\rho}(2ax_w)\\right)(-\\Delta y L_z) = 2a \\Delta t x_w \\Delta y L_z\n    $$\n\n3.  **北面 ($n$)**：\n    该面位于 $y=0.2$。其中心在 $(x_n, y_n) = (0.2, 0.2)$。\n    面积矢量为 $S_n = (\\Delta x L_z)\\mathbf{j} = (0.2 \\times 1)\\mathbf{j} = 0.2\\,\\mathbf{j}$。\n    面中心的速度为 $u^{*}_{n} = u^{*}(x_n, y_n) = -\\frac{\\Delta t}{\\rho}(2ax_n\\,\\mathbf{i} + 2by_n\\,\\mathbf{j})$。\n    质量通量为：\n    $$\n    \\dot{m}^{*}_{n} = \\rho (u^{*}_{n} \\cdot S_{n}) = \\rho \\left(-\\frac{\\Delta t}{\\rho}(2by_n)\\right)(\\Delta x L_z) = -2b \\Delta t y_n \\Delta x L_z\n    $$\n\n4.  **南面 ($s$)**：\n    该面位于 $y=0.0$。其中心在 $(x_s, y_s) = (0.2, 0.0)$。\n    面积矢量为 $S_s = -(\\Delta x L_z)\\mathbf{j} = -0.2\\,\\mathbf{j}$。\n    面中心的速度为 $u^{*}_{s} = u^{*}(x_s, y_s) = -\\frac{\\Delta t}{\\rho}(2ax_s\\,\\mathbf{i} + 2by_s\\,\\mathbf{j})$。\n    质量通量为：\n    $$\n    \\dot{m}^{*}_{s} = \\rho (u^{*}_{s} \\cdot S_{s}) = \\rho \\left(-\\frac{\\Delta t}{\\rho}(2by_s)\\right)(-\\Delta x L_z) = 2b \\Delta t y_s \\Delta x L_z\n    $$\n\n现在，我们将这四个通量相加，得到离散残差散度：\n$$\n\\sum_{f}\\dot{m}^{*}_{f} = (-2a \\Delta t x_e \\Delta y L_z) + (2a \\Delta t x_w \\Delta y L_z) + (-2b \\Delta t y_n \\Delta x L_z) + (2b \\Delta t y_s \\Delta x L_z)\n$$\n提取公因式：\n$$\n\\sum_{f}\\dot{m}^{*}_{f} = -2a \\Delta t \\Delta y L_z (x_e - x_w) - 2b \\Delta t \\Delta x L_z (y_n - y_s)\n$$\n我们认识到 $x_e - x_w = \\Delta x$ 且 $y_n - y_s = \\Delta y$：\n$$\n\\sum_{f}\\dot{m}^{*}_{f} = -2a \\Delta t \\Delta x \\Delta y L_z - 2b \\Delta t \\Delta x \\Delta y L_z\n$$\n这就是推导出的离散表达式。它可以进一步简化为：\n$$\n\\sum_{f}\\dot{m}^{*}_{f} = -2(a+b) \\Delta t (\\Delta x \\Delta y L_z)\n$$\n项 $\\Delta x \\Delta y L_z$ 是计算单元的体积 $V_{cell}$。\n现在，我们代入给定的数值：\n$a = 2.0 \\times 10^{3}$\n$b = -1.0 \\times 10^{3}$\n$\\Delta t = 0.05$\n$\\Delta x = 0.2$\n$\\Delta y = 0.2$\n$L_z = 1$\n\n单元体积为 $V_{cell} = 0.2 \\times 0.2 \\times 1 = 0.04$。\n系数之和为 $a+b = 2.0 \\times 10^{3} - 1.0 \\times 10^{3} = 1.0 \\times 10^{3}$。\n\n将这些值代入推导出的表达式中：\n$$\n\\sum_{f}\\dot{m}^{*}_{f} = -2(1.0 \\times 10^{3}) \\times 0.05 \\times 0.04\n$$\n$$\n\\sum_{f}\\dot{m}^{*}_{f} = -2000 \\times (0.05 \\times 0.04) = -2000 \\times 0.002 = -4\n$$\n单位确认为 $\\mathrm{kg/s}$。问题要求最终数值答案四舍五入至四位有效数字。计算值恰好为 $-4$。为了用四位有效数字表示，我们写作 $-4.000$。", "answer": "$$\\boxed{-4.000}$$", "id": "3377826"}, {"introduction": "前面的练习分别聚焦于PISO算法的单个环节，而这项综合性实践则要求您审视整个算法的性能。您将采用“制造解方法”（Method of Manufactured Solutions，MMS）——一种在计算流体力学领域用于代码验证的专业技术——来系统地研究PISO校正循环次数 $N_c$ 对算法时间精度的影响。这个练习不仅能整合您对预测-校正机制的理解，还能让您体验到在实际CFD模拟中，如何通过经验性测试来确定关键算法参数，以确保计算结果的可靠性。[@problem_id:3377833]", "problem": "实现一种用于瞬态不可压缩流的压力隐式算子分裂 (PISO) 算法，并使用“制造解方法”(MMS) 来经验性地确定为使速度和离散散度在时间上达到二阶精度所需的最少压力修正循环次数，记为 $N_c$。在二维周期性域中使用无量纲变量进行研究，以分离出时间精度。\n\n基础和控制方程：\n- 从周期性方形域 $[0,1]\\times[0,1]$ 中的速度 $u(x,y,t) = (u_1,u_2)$ 和压力 $p(x,y,t)$ 的不可压缩 Navier–Stokes 方程开始：\n$$\n\\frac{\\partial u}{\\partial t} + (u\\cdot \\nabla)u = -\\nabla p + \\nu \\nabla^2 u + f(x,y,t), \\quad \\nabla\\cdot u = 0,\n$$\n其中 $\\nu$ 是运动粘度，$f(x,y,t)$ 是外部体积力。\n- 使用制造解方法：指定光滑的周期性场 $u(x,y,t)$ 和 $p(x,y,t)$，计算 $f(x,y,t)$，使得该解对任意 $(x,y,t)$ 都精确满足上述方程。\n\n制造的瞬态涡：\n- 设 $m$ 为正整数波数，$\\omega$ 为正频率。定义制造场：\n$$\nu_1(x,y,t) = \\sin(2\\pi m x)\\cos(2\\pi m y)\\cos(\\omega t), \\quad\nu_2(x,y,t) = -\\cos(2\\pi m x)\\sin(2\\pi m y)\\cos(\\omega t),\n$$\n$$\np(x,y,t) = \\cos(2\\pi m x)\\cos(2\\pi m y)\\sin(\\omega t).\n$$\n- 这些解析地对所有 $t$ 满足 $\\nabla\\cdot u = 0$。\n- 使用制造的 $u$ 和 $p$ 从控制方程计算体积力 $f(x,y,t)$：\n$$\nf(x,y,t) = \\frac{\\partial u}{\\partial t} + (u\\cdot \\nabla)u + \\nabla p - \\nu \\nabla^2 u.\n$$\n\n数值算法要求：\n- 使用具有 $N_x = N_y$ 个点的均匀笛卡尔网格，并在两个方向上采用周期性边界条件。所有计算都是无量纲的。\n- 对时间进行半隐式离散，扩散项使用 Crank–Nicolson 方法，显式项使用二阶 Adams–Bashforth 方法。具体来说，设 $\\Delta t$ 为时间步长，在时间层 $n$ 定义显式项：\n$$\n\\mathcal{E}^n = - (u^n \\cdot \\nabla) u^n + f(\\cdot,\\cdot,t^n).\n$$\n然后通过以下步骤从 $t^n$推进到 $t^{n+1} = t^n + \\Delta t$：\n1. 预测（动量）步：\n   从以下方程求解中间速度 $u^\\star$：\n   $$\n   \\left(I - \\frac{\\Delta t}{2}\\nu \\nabla^2\\right) u^\\star =\n   \\left(I + \\frac{\\Delta t}{2}\\nu \\nabla^2\\right) u^n + \\Delta t\\left(\\frac{3}{2}\\mathcal{E}^n - \\frac{1}{2}\\mathcal{E}^{n-1}\\right) - \\Delta t \\nabla p^n.\n   $$\n2. 具有 $N_c$ 个修正子的 PISO 压力修正循环：\n   在循环开始前，初始化一个累积压力场 $p_{corr} = p^n$。对于 $j = 1, \\dots, N_c$，从压力泊松方程求解压力增量 $\\phi$：\n   $$\n   \\nabla^2 \\phi = \\frac{1}{\\Delta t}\\nabla\\cdot u^\\star,\n   $$\n   然后更新速度和累积压力：\n   $$\n   u^\\star \\leftarrow u^\\star - \\Delta t \\nabla \\phi,\\quad p_{corr} \\leftarrow p_{corr} + \\phi.\n   $$\n   在循环结束后，设置 $u^{n+1} = u^\\star$ 和 $p^{n+1} = p_{corr}$。\n- 从 $t=0$ 时的制造场初始化 $u^0$ 和 $p^0$。为第一个 Adams–Bashforth 步初始化 $\\mathcal{E}^{-1} = \\mathcal{E}^{0}$。\n- 对于空间算子（梯度、散度、拉普拉斯算子和泊松求解），通过傅里叶变换在周期性网格上使用谱精确微分，以便在下面的参数范围内，将空间离散误差降低到远低于时间误差。\n\n误差度量和精度评估：\n- 对于给定情况，对于一系列三个时间步长 $\\Delta t_1, \\Delta t_2, \\Delta t_3$（其中 $\\Delta t_{k+1} = \\Delta t_k/2$），积分到固定的最终时间 $T$（该时间是每个 $\\Delta t_k$ 的精确倍数）。\n- 将 $t=T$ 时的速度误差计算为离散 $L^2$ 范数：\n$$\n\\varepsilon_u(\\Delta t) = \\left( \\frac{1}{N_x N_y} \\sum_{i,j} \\|u_{i,j}^{\\text{num}}(T) - u_{i,j}^{\\text{exact}}(T)\\|^2 \\right)^{1/2}.\n$$\n- 将 $t=T$ 时的散度误差计算为：\n$$\n\\varepsilon_{\\nabla\\cdot u}(\\Delta t) = \\left( \\frac{1}{N_x N_y} \\sum_{i,j} \\left(\\nabla\\cdot u^{\\text{num}}(T)\\big|_{i,j}\\right)^2 \\right)^{1/2}.\n$$\n- 通过以下公式估算连续步长之间的经验收敛阶数：\n$$\np_u^{(k)} = \\frac{\\log\\left(\\varepsilon_u(\\Delta t_k)/\\varepsilon_u(\\Delta t_{k+1})\\right)}{\\log\\left(\\Delta t_k/\\Delta t_{k+1}\\right)}, \\quad\np_{\\nabla\\cdot u}^{(k)} = \\frac{\\log\\left(\\varepsilon_{\\nabla\\cdot u}(\\Delta t_k)/\\varepsilon_{\\nabla\\cdot u}(\\Delta t_{k+1})\\right)}{\\log\\left(\\Delta t_k/\\Delta t_{k+1}\\right)},\n$$\n对于 $k\\in\\{1,2\\}$。\n- 判定规则：当且仅当 $p_u^{(1)}$ 和 $p_u^{(2)}$ 均至少为 1.8，并且 $p_{\\nabla\\cdot u}^{(1)}$ 和 $p_{\\nabla\\cdot u}^{(2)}$ 均至少为 1.8 时，宣布给定的 $N_c$ 在速度和散度上均达到了二阶精度。为避免因投影法中散度达到机器精度饱和而判定失败，如果对于所有三个步长，$\\varepsilon_{\\nabla\\cdot u}(\\Delta t_k) \\le 10^{-10}$，则认为该 $N_c$ 满足散度准则。\n\n测试套件：\n- 使用具有 $N_x = N_y = 48$ 个点的均匀网格。所有量均为无量纲。\n- 对于每个测试用例，使用以下参数和时间步长序列：\n   - 用例 A（理想路径）：$m=1$, $\\omega=4.0$, $\\nu=0.01$, $T=0.08$, $\\Delta t \\in \\{0.01,\\,0.005,\\,0.0025\\}$。\n   - 用例 B（更高空间频率）：$m=2$, $\\omega=6.0$, $\\nu=0.02$, $T=0.08$, $\\Delta t \\in \\{0.01,\\,0.005,\\,0.0025\\}$。\n   - 用例 C（更强对流主导）：$m=1$, $\\omega=3.0$, $\\nu=0.005$, $T=0.08$, $\\Delta t \\in \\{0.01,\\,0.005,\\,0.0025\\}$。\n\n程序所需行为和最终输出：\n- 实现上述 PISO 算法，其中 $N_c \\in \\{1,2,3\\}$，并为每个测试用例确定满足速度和散度二阶精度准则的最小 $N_c$。如果没有 $N_c \\in \\{1,2,3\\}$ 满足该准则，则为该用例返回 -1。\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，按测试用例 A、B、C 的顺序排列。例如，一个有效的输出看起来像 \"[$1$,$2$,$1$]\"，但程序输出中没有美元符号，即程序必须打印 \"[1,2,1]\"。", "solution": "目标是确定为特定数值格式实现二阶时间精度所需的最少 PISO 压力修正循环次数 $N_c$。这通过实现该格式并用制造的解析解对其进行测试来完成。\n\n### 控制方程和制造解\n\n模拟求解了在二维周期性域 $[0,1]\\times[0,1]$ 中的无量纲不可压缩 Navier-Stokes 方程：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot \\nabla)\\boldsymbol{u} = -\\nabla p + \\nu \\nabla^2 \\boldsymbol{u} + \\boldsymbol{f}(x,y,t)\n$$\n$$\n\\nabla\\cdot \\boldsymbol{u} = 0\n$$\n其中 $\\boldsymbol{u}=(u_1, u_2)$ 是速度场，$p$ 是压力，$\\nu$ 是运动粘度，$\\boldsymbol{f}$ 是体积力项。\n\n“制造解方法”(MMS) 用于验证。我们指定光滑的、周期性的速度和压力解析解：\n$$\nu_1(x,y,t) = \\sin(2\\pi m x)\\cos(2\\pi m y)\\cos(\\omega t)\n$$\n$$\nu_2(x,y,t) = -\\cos(2\\pi m x)\\sin(2\\pi m y)\\cos(\\omega t)\n$$\n$$\np(x,y,t) = \\cos(2\\pi m x)\\cos(2\\pi m y)\\sin(\\omega t)\n$$\n速度场是解析无散的：$\\nabla \\cdot \\boldsymbol{u} = 0$。然后将这些制造场代入动量方程，导出体积力 $\\boldsymbol{f} = (f_1, f_2)$：\n$$\n\\boldsymbol{f} = \\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot \\nabla)\\boldsymbol{u} + \\nabla p - \\nu \\nabla^2 \\boldsymbol{u}\n$$\n$\\boldsymbol{f}$ 的各个分量计算如下：\n$f_1(x,y,t) = -(\\omega+2\\pi m) \\sin(2\\pi m x)\\cos(2\\pi m y)\\sin(\\omega t) + \\pi m \\sin(4\\pi m x) \\cos^2(\\omega t) + 8\\pi^2 m^2 \\nu \\sin(2\\pi m x)\\cos(2\\pi m y)\\cos(\\omega t)$\n$f_2(x,y,t) = (\\omega-2\\pi m) \\cos(2\\pi m x)\\sin(2\\pi m y)\\sin(\\omega t) - \\pi m \\sin(4\\pi m y) \\cos^2(\\omega t) - 8\\pi^2 m^2 \\nu \\cos(2\\pi m x)\\sin(2\\pi m y)\\cos(\\omega t)$\n\n### 数值离散化与算法\n\n使用具有 $N_x = N_y = N$ 个点的均匀笛卡尔网格。该方法的主要特点是利用快速傅里叶变换 (FFT) 进行谱微分，这为空间导数提供了高精度，从而有效地分离出时间离散误差。\n\n**使用 FFT 的空间算子**\n对于网格上的函数 $g(x_i, y_j)$，其二维离散傅里叶变换为 $\\hat{g}(k_x, k_y)$。空间导数在傅里叶空间中计算：\n- 梯度: $\\widehat{\\nabla g} = (i 2\\pi k_x \\hat{g}, i 2\\pi k_y \\hat{g})$\n- 散度: $\\widehat{\\nabla \\cdot \\boldsymbol{u}} = i 2\\pi k_x \\hat{u}_1 + i 2\\pi k_y \\hat{u}_2$\n- 拉普拉斯算子: $\\widehat{\\nabla^2 g} = -( (2\\pi k_x)^2 + (2\\pi k_y)^2 ) \\hat{g} = -k^2 \\hat{g}$\n其中 $k_x, k_y$ 是离散波数。像求解泊松方程 $\\nabla^2 \\phi = \\rho$ 这样的操作在傅里叶空间中变成代数除法：$\\hat{\\phi} = -\\hat{\\rho}/k^2$。$k=0$ 模式必须通过确保 $\\rho$ 的均值为零并设置 $\\hat{\\phi}(0,0)=0$ 来特殊处理。\n\n**时间步进格式**\n半隐式格式将解从时间 $t^n$ 推进到 $t^{n+1} = t^n + \\Delta t$。粘性扩散项使用二阶 Crank-Nicolson 方法进行隐式处理，而显式项（对流和体积力）则用二阶 Adams-Bashforth 方法处理。\n时间层 $n$ 的显式部分定义为 $\\mathcal{E}^n = - (\\boldsymbol{u}^n \\cdot \\nabla) \\boldsymbol{u}^n + \\boldsymbol{f}(t^n)$。\n\n每个时间步的 PISO 算法分为两个主要阶段进行：\n\n**1. 预测步：**\n通过求解动量方程计算中间速度场 $\\boldsymbol{u}^\\star$，其中压力项取自前一时间步的 $p^n$。\n$$\n\\left(\\boldsymbol{I} - \\frac{\\Delta t}{2}\\nu \\nabla^2\\right) \\boldsymbol{u}^\\star = \\left(\\boldsymbol{I} + \\frac{\\Delta t}{2}\\nu \\nabla^2\\right) \\boldsymbol{u}^n + \\Delta t\\left(\\frac{3}{2}\\mathcal{E}^n - \\frac{1}{2}\\mathcal{E}^{n-1}\\right) - \\Delta t \\nabla p^n\n$$\n这是关于 $\\boldsymbol{u}^\\star$ 各分量的一组亥姆霍兹方程，可以在傅里叶空间中高效求解：\n$$\n\\hat{\\boldsymbol{u}}^\\star = \\frac{\\widehat{\\text{RHS}}}{1 + \\frac{\\Delta t}{2}\\nu k^2}\n$$\n\n**2. 修正步：**\n预测的速度 $\\boldsymbol{u}^\\star$ 并不满足时间 $t^{n+1}$ 的无散约束。PISO 算法应用 $N_c$ 个修正步骤来强制执行此约束，同时更新压力。对于每个修正步 $j=1, \\dots, N_c$：\na. 求解压力泊松方程以获得压力增量 $\\phi$：\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t} \\nabla \\cdot \\boldsymbol{u}^\\star\n$$\n其中 $\\boldsymbol{u}^\\star$ 是最新更新的速度场。该方程通过谱方法求解。\nb. 使用修正量 $\\phi$ 更新速度和压力场：\n$$\n\\boldsymbol{u}^\\star \\leftarrow \\boldsymbol{u}^\\star - \\Delta t \\nabla \\phi\n$$\n$$\np \\leftarrow p + \\phi\n$$\n（这里，$p$ 是一个临时变量，在时间步开始时初始化为 $p^n$）。\n\n在 $N_c$ 次循环之后，将最终修正的场赋给新的时间层：$\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^\\star$ 和 $p^{n+1} = p$。\n\n### 验证与精度评估\n\n为评估时间精度，模拟针对一系列三个连续减半的时间步长 $\\Delta t_1, \\Delta t_2=\\Delta t_1/2, \\Delta t_3=\\Delta t_2/2$ 运行至固定的最终时间 $T$。在 $T$ 时刻的误差使用离散 $L^2$ 范数计算：\n- 速度误差：$\\varepsilon_u(\\Delta t) = \\| \\boldsymbol{u}^{\\text{num}}(T) - \\boldsymbol{u}^{\\text{exact}}(T) \\|_{L^2}$\n- 散度误差：$\\varepsilon_{\\nabla\\cdot u}(\\Delta t) = \\| \\nabla\\cdot \\boldsymbol{u}^{\\text{num}}(T) \\|_{L^2}$\n\n然后从成对的模拟中估算经验收敛阶数 $p$：\n$$\np^{(k)} = \\frac{\\log(\\varepsilon(\\Delta t_k)/\\varepsilon(\\Delta t_{k+1}))}{\\log(2)}\n$$\n如果观察到的速度和散度的阶数都至少为 1.8，则认为 $N_c$ 的值足以达到二阶精度。一个特殊条件处理散度误差达到机器精度（$\\le 10^{-10}$）的情况，此时散度精度准则被自动视为满足。对于每个测试用例，将确定满足此要求的最小 $N_c \\in \\{1, 2, 3\\}$。\n\n### 实现策略\n该解决方案使用 Python 实现，并采用面向对象的方法。一个类处理谱运算，另一个类提供制造解，主求解器类封装 PISO 算法逻辑。该结构将问题的复杂组件模块化，从而实现清晰、可维护和可验证的实现。", "answer": "```python\nimport numpy as np\nfrom numpy.fft import fft2, ifft2, fftfreq\n\nclass SpectralOps:\n    \"\"\"\n    Handles spectral operations on a 2D periodic grid.\n    \"\"\"\n    def __init__(self, N):\n        if N % 2 != 0:\n            raise ValueError(\"Grid size N must be even for this wavenumber setup.\")\n        self.N = N\n        # Wavenumbers (multiplied by 2*pi for convenience in derivative formulas)\n        k_freq = fftfreq(N, 1.0 / N)\n        self.kx_2pi = (2 * np.pi * k_freq)[:, np.newaxis]\n        self.ky_2pi = (2 * np.pi * k_freq)[np.newaxis, :]\n        \n        # Wavenumber squared\n        self.k_sq = self.kx_2pi**2 + self.ky_2pi**2\n        \n        # Inverse Laplacian operator (precomputed for Poisson solves)\n        self.k_sq_inv = np.zeros_like(self.k_sq)\n        non_zero_k = self.k_sq > 1e-12\n        self.k_sq_inv[non_zero_k] = 1.0 / self.k_sq[non_zero_k]\n\n    def grad(self, f):\n        \"\"\"Computes gradient of a scalar field f.\"\"\"\n        f_hat = fft2(f)\n        dfdx = np.real(ifft2(1j * self.kx_2pi * f_hat))\n        dfdy = np.real(ifft2(1j * self.ky_2pi * f_hat))\n        return dfdx, dfdy\n\n    def div(self, u):\n        \"\"\"Computes divergence of a vector field u = (u1, u2).\"\"\"\n        u1_hat = fft2(u[0])\n        u2_hat = fft2(u[1])\n        div_u_hat = 1j * self.kx_2pi * u1_hat + 1j * self.ky_2pi * u2_hat\n        return np.real(ifft2(div_u_hat))\n\n    def laplacian(self, f):\n        \"\"\"Computes Laplacian of a scalar field f.\"\"\"\n        f_hat = fft2(f)\n        lap_f_hat = -self.k_sq * f_hat\n        return np.real(ifft2(lap_f_hat))\n\n    def solve_poisson(self, rhs):\n        \"\"\"Solves Poisson equation: lap(phi) = rhs.\"\"\"\n        rhs_hat = fft2(rhs)\n        rhs_hat[0, 0] = 0.0  # Ensure compatibility condition (zero mean)\n        phi_hat = -self.k_sq_inv * rhs_hat\n        return np.real(ifft2(phi_hat))\n\n    def solve_helmholtz(self, rhs, alpha):\n        \"\"\"Solves Helmholtz equation: (I - alpha*lap) u = rhs.\"\"\"\n        rhs_hat = fft2(rhs)\n        helmholtz_op_hat = 1.0 + alpha * self.k_sq\n        u_hat = rhs_hat / helmholtz_op_hat\n        return np.real(ifft2(u_hat))\n\nclass ManufacturedSolution:\n    \"\"\"\n    Provides the exact manufactured solution and derived forcing term.\n    \"\"\"\n    def __init__(self, m, omega, nu, grid_x, grid_y):\n        self.m, self.omega, self.nu = m, omega, nu\n        self.xx, self.yy = np.meshgrid(grid_x, grid_y, indexing='ij')\n\n    def get_solution(self, t):\n        \"\"\"Returns exact u and p at time t.\"\"\"\n        k = 2 * np.pi * self.m\n        cos_wt = np.cos(self.omega * t)\n        sin_wt = np.sin(self.omega * t)\n        \n        sx, cx = np.sin(k * self.xx), np.cos(k * self.xx)\n        sy, cy = np.sin(k * self.yy), np.cos(k * self.yy)\n        \n        u1 = sx * cy * cos_wt\n        u2 = -cx * sy * cos_wt\n        p = cx * cy * sin_wt\n        return (u1, u2), p\n\n    def get_forcing(self, t):\n        \"\"\"Returns the source term f at time t.\"\"\"\n        m, omega, nu = self.m, self.omega, self.nu\n        k = 2 * np.pi * m\n        cos_wt = np.cos(omega * t)\n        sin_wt = np.sin(omega * t)\n        \n        sx, cx = np.sin(k * self.xx), np.cos(k * self.xx)\n        sy, cy = np.sin(k * self.yy), np.cos(k * self.yy)\n        \n        f1 = (-(omega + k) * sx * cy * sin_wt +\n              (np.pi * m * np.sin(2 * k * self.xx) * cos_wt**2) +\n              (2 * k**2 * nu * sx * cy * cos_wt))\n\n        f2 = ((omega - k) * cx * sy * sin_wt -\n              (np.pi * m * np.sin(2 * k * self.yy) * cos_wt**2) -\n              (2 * k**2 * nu * cx * sy * cos_wt))\n        \n        return (f1, f2)\n\nclass PISOSolver:\n    \"\"\"\n    Implements the PISO solver for the numerical experiment.\n    \"\"\"\n    def __init__(self, case_params, N, Nc, dt):\n        self.params = case_params\n        self.N, self.Nc, self.dt = N, Nc, dt\n        self.T = case_params['T']\n        \n        grid_pts = np.linspace(0, 1, N, endpoint=False)\n        self.ops = SpectralOps(N)\n        self.mms = ManufacturedSolution(case_params['m'], case_params['omega'], \n                                        case_params['nu'], grid_pts, grid_pts)\n\n    def _compute_E(self, u, t):\n        \"\"\"Computes the explicit term E.\"\"\"\n        u1, u2 = u\n        \n        u1_dx, u1_dy = self.ops.grad(u1)\n        u2_dx, u2_dy = self.ops.grad(u2)\n        \n        conv1 = u1 * u1_dx + u2 * u1_dy\n        conv2 = u1 * u2_dx + u2 * u2_dy\n        \n        f1, f2 = self.mms.get_forcing(t)\n        \n        E1 = -conv1 + f1\n        E2 = -conv2 + f2\n        return (E1, E2)\n\n    def run(self):\n        \"\"\"Runs the simulation until final time T.\"\"\"\n        u, p = self.mms.get_solution(0)\n        \n        E_n = self._compute_E(u, 0)\n        E_nm1 = E_n # Initialize for first step (AB2 -> FE)\n\n        num_steps = int(round(self.T / self.dt))\n        for n in range(num_steps):\n            t_n = n * self.dt\n            t_np1 = (n + 1) * self.dt\n            nu, dt = self.params['nu'], self.dt\n            \n            # Predictor step\n            # RHS of the Helmholtz equation\n            lap_u_n = (self.ops.laplacian(u[0]), self.ops.laplacian(u[1]))\n            grad_p_n = self.ops.grad(p)\n            \n            rhs1 = (u[0] + (dt / 2) * nu * lap_u_n[0] +\n                    dt * (1.5 * E_n[0] - 0.5 * E_nm1[0]) - dt * grad_p_n[0])\n            rhs2 = (u[1] + (dt / 2) * nu * lap_u_n[1] +\n                    dt * (1.5 * E_n[1] - 0.5 * E_nm1[1]) - dt * grad_p_n[1])\n            \n            u_star1 = self.ops.solve_helmholtz(rhs1, dt / 2 * nu)\n            u_star2 = self.ops.solve_helmholtz(rhs2, dt / 2 * nu)\n            u_star = (u_star1, u_star2)\n            \n            # PISO corrector loop\n            p_corr = np.copy(p)\n            for _ in range(self.Nc):\n                div_u_star = self.ops.div(u_star)\n                phi = self.ops.solve_poisson(div_u_star / dt)\n                grad_phi = self.ops.grad(phi)\n                \n                u_star = (u_star[0] - dt * grad_phi[0],\n                          u_star[1] - dt * grad_phi[1])\n                p_corr += phi\n            \n            u_np1 = u_star\n            p_np1 = p_corr\n            \n            # Update for next step\n            u, p = u_np1, p_np1\n            E_nm1 = E_n\n            E_n = self._compute_E(u, t_np1)\n\n        # Compute errors at final time T\n        u_exact, _ = self.mms.get_solution(self.T)\n        \n        error_u = np.sqrt(np.mean((u[0] - u_exact[0])**2 + (u[1] - u_exact[1])**2))\n        \n        div_u_num = self.ops.div(u)\n        error_div = np.sqrt(np.mean(div_u_num**2))\n        \n        return error_u, error_div\n\ndef solve_case(case_params, N):\n    \"\"\"\n    Finds the minimum Nc for a given test case.\n    \"\"\"\n    dts = case_params['dts']\n    for Nc in [1, 2, 3]:\n        errors_u = []\n        errors_div = []\n        for dt in dts:\n            solver = PISOSolver(case_params, N, Nc, dt)\n            err_u, err_div = solver.run()\n            errors_u.append(err_u)\n            errors_div.append(err_div)\n\n        # Check for divergence saturation\n        if all(e <= 1e-10 for e in errors_div):\n            div_order_ok = True\n        else:\n            p_div1 = np.log(errors_div[0] / errors_div[1]) / np.log(2)\n            p_div2 = np.log(errors_div[1] / errors_div[2]) / np.log(2)\n            div_order_ok = p_div1 >= 1.8 and p_div2 >= 1.8\n        \n        p_u1 = np.log(errors_u[0] / errors_u[1]) / np.log(2)\n        p_u2 = np.log(errors_u[1] / errors_u[2]) / np.log(2)\n        u_order_ok = p_u1 >= 1.8 and p_u2 >= 1.8\n        \n        if u_order_ok and div_order_ok:\n            return Nc\n    \n    return -1\n\ndef solve():\n    \"\"\" Main function to run all test cases and print the final result. \"\"\"\n    N = 48\n    test_cases = [\n        {'m': 1, 'omega': 4.0, 'nu': 0.01, 'T': 0.08, 'dts': [0.01, 0.005, 0.0025]},  # Case A\n        {'m': 2, 'omega': 6.0, 'nu': 0.02, 'T': 0.08, 'dts': [0.01, 0.005, 0.0025]},  # Case B\n        {'m': 1, 'omega': 3.0, 'nu': 0.005, 'T': 0.08, 'dts': [0.01, 0.005, 0.0025]},# Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case, N)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3377833"}]}