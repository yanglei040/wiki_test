{"hands_on_practices": [{"introduction": "对流-扩散方程是计算流体动力学(CFD)中模拟标量输运的基石。本实践旨在深入探讨求解此类方程时常用的分离式求解器的稳定性问题。通过严谨的分析，您将推导出最大稳定欠松弛因子 $\\omega_{\\max}$ 与局部网格佩克莱数 $Pe_h$ 之间的直接关系，后者是衡量对流与扩散相对强度的关键无量纲参数。这项练习对于培养对物理与数值参数如何相互作用并最终决定迭代格式稳定性的直觉至关重要。[@problem_id:3386083]", "problem": "考虑在计算流体动力学 (CFD) 中使用的一种分离式定点迭代方法，该方法用于求解在单元宽度为 $h$ 的均匀网格上通过有限体积法 (FVM) 离散的稳态一维对流扩散方程。被动标量场 $\\phi(x)$ 的控制连续方程为 $-\\alpha\\,\\frac{d^2 \\phi}{dx^2} + u\\,\\frac{d\\phi}{dx} = s(x)$，其中 $\\alpha > 0$ 是扩散系数，$u$ 是恒定的对流速度。在分离式迭代中，扩散算子被隐式处理，而对流算子则根据上一步的迭代值进行显式处理。定义面扩散系数 $D_f = \\alpha/h$ 和面对流强度 $F_f = |u|$，以及网格佩克莱数 $Pe_h = \\dfrac{F_f}{2 D_f} = \\dfrac{|u| h}{2 \\alpha}$。\n\n从线性定常迭代和算子分裂的基本原理出发，完成以下任务：\n\n1) 将分离式迭代建模为离散单元中心未知量 $\\phi^k$ 的线性定点更新，形式为 $\\phi^{k+1} = G(\\omega)\\phi^k + c$，其中 $G(\\omega)$ 是通过欠松弛 (UR) 因子 $\\omega \\in (0,1]$ 修正后的迭代矩阵，$c$ 是由源项和边界条件产生的常数向量。通过将离散化算子分裂为隐式扩散部分和显式对流部分，推导 $G(\\omega)$ 的结构。然后，使用对流项的中心差分格式，证明预处理的对流-扩散算子 $D^{-1} C$ 的谱是纯虚数，并根据网格佩克莱数 $Pe_h$ 得出其谱半径的界。仅使用经过充分检验的矩阵分析工具，如诱导范数或 Gershgorin 型界，以及斜对称矩阵的基本性质。\n\n2) 根据推导出的界，为欠松弛因子 $\\omega$ 获得一个充分稳定性判据，使得分离式迭代是收缩的，即 $G(\\omega)$ 的谱半径严格小于 $1$。将最大稳定 $\\omega_{\\max}$ 表示为网格佩克莱数 $Pe_h$ 的函数，并根据迭代矩阵的性质严格证明每一步。您的推导必须从定点迭代结构开始，不得使用快捷公式。\n\n3) 提出一种自适应欠松弛方案，该方案利用局部（单元）网格佩克莱数 $Pe_i$ 来降低高佩克莱数区域的 $\\omega$，以避免伪振荡。该方案必须同时满足以下两点：\n   - 遵守您推导出的充分稳定性界，即没有任何单元的欠松弛因子超过其 $Pe_i$ 所对应的充分稳定值。\n   - 强制施加全局上限 $\\omega \\le 1$。\n   为明确起见，使用公式 $\\omega_i = \\min\\big( \\omega_{\\text{base}}, \\min(1, \\omega_{\\max}(Pe_i)) \\big)$ 计算逐单元因子，其中 $\\omega_{\\text{base}} \\in (0,1]$ 是用户选择的基准值。同时定义一个全局推荐值 $\\omega_{\\text{global}} = \\min\\limits_i \\omega_{\\max}(Pe_i)$，它保证了当使用单个全局 $\\omega$ 时，所有单元都满足充分稳定性界。\n\n4) 实现一个完整的程序，根据推导出的充分稳定性界，为一组给定的测试输入计算自适应的逐单元欠松弛因子和全局推荐值。本问题中的所有量均为无量纲，不需要物理单位。对于数值报告，将浮点数结果四舍五入到8位小数。\n\n测试套件：\n- 测试用例 1 (全局推荐值，“理想情况”)：$Pe = [0.5, 1.0, 2.0]$，基准值 $\\omega_{\\text{base}} = 0.95$。将 $\\omega_{\\text{global}}$ 报告为单个浮点数。\n- 测试用例 2 (逐单元自适应，混合佩克莱数)：$Pe = [0.1, 1.0, 5.0, 10.0]$，基准值 $\\omega_{\\text{base}} = 0.8$。报告列表 $[\\omega_1,\\omega_2,\\omega_3,\\omega_4]$。\n- 测试用例 3 (全局推荐值，高佩克莱数边界情况)：$Pe = [0.0, 100.0, 50.0]$，基准值 $\\omega_{\\text{base}} = 1.0$。将 $\\omega_{\\text{global}}$ 报告为单个浮点数。\n- 测试用例 4 (逐单元自适应，包括零佩克莱数)：$Pe = [0.0, 0.5, 2.0, 20.0, 100.0]$，基准值 $\\omega_{\\text{base}} = 0.9$。报告列表 $[\\omega_1,\\omega_2,\\omega_3,\\omega_4,\\omega_5]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按上述四个测试用例顺序排列的结果，结果为逗号分隔的列表并用方括号括起来。具体来说，输出格式应为\n$[\\omega_{\\text{global,TC1}}, [\\omega_i\\ \\text{for TC2}], \\omega_{\\text{global,TC3}}, [\\omega_i\\ \\text{for TC4}]]$ \n每个浮点值都四舍五入到8位小数。", "solution": "该问题要求分析并实现一种用于求解一维稳态对流扩散方程的分离式迭代求解器的欠松弛方案。分析按规定的四个部分进行。\n\n### 1) 迭代矩阵与谱半径界的推导\n\n首先，我们使用有限体积法 (FVM) 在单元宽度为 $h$ 的均匀网格上离散化控制方程 $-\\alpha\\,\\frac{d^2 \\phi}{dx^2} + u\\,\\frac{d\\phi}{dx} = s(x)$。对单元 $i$ 周围的控制体进行积分，并对扩散通量和对流通量使用中心差分，得到单元中心未知量 $\\phi_i$ 的离散方程：\n$$\n\\left(-\\frac{\\alpha}{h}(\\phi_{i+1} - \\phi_i)\\right) - \\left(-\\frac{\\alpha}{h}(\\phi_i - \\phi_{i-1})\\right) + \\left(u \\frac{\\phi_i + \\phi_{i+1}}{2}\\right) - \\left(u \\frac{\\phi_{i-1} + \\phi_i}{2}\\right) = S_i\n$$\n其中 $S_i$ 是单元 $i$ 的积分源项。对各项进行分组，我们可以分离出扩散算子和对流算子的贡献。未知量向量 $\\phi$ 的离散系统可以写成 $(D_{mat} + C_{mat})\\phi = b$，其中 $b$ 是源项和边界条件项组成的向量。矩阵 $D_{mat}$ 和 $C_{mat}$ 分别代表离散化的扩散算子和对流算子。对于内部单元 $i$，它们的非零项为：\n- **扩散矩阵 ($D_{mat}$)**：$(D_{mat}\\phi)_i = \\frac{\\alpha}{h}(- \\phi_{i-1} + 2\\phi_i - \\phi_{i+1})$。该矩阵是对称的，并且在适当的边界条件下是正定的。\n- **对流矩阵 ($C_{mat}$)**：$(C_{mat}\\phi)_i = \\frac{u}{2}(- \\phi_{i-1} + \\phi_{i+1})$。该矩阵是实数且斜对称的，即 $C_{mat}^T = -C_{mat}$。\n\n分离式迭代对扩散部分进行隐式处理，对对流部分进行显式处理。这对应于一种矩阵分裂，其中中间场 $\\phi^*$ 的迭代由下式给出：\n$$\nD_{mat} \\phi^* = -C_{mat} \\phi^k + b\n$$\n使用因子 $\\omega \\in (0, 1]$ 的欠松弛步骤利用 $\\phi^*$ 从上一步迭代值 $\\phi^k$ 更新解：\n$$\n\\phi^{k+1} = (1-\\omega)\\phi^k + \\omega \\phi^* = (1-\\omega)\\phi^k + \\omega D_{mat}^{-1}(-C_{mat} \\phi^k + b)\n$$\n重新整理可得标准线性定点形式 $\\phi^{k+1} = G(\\omega)\\phi^k + c$：\n$$\n\\phi^{k+1} = \\left((1-\\omega)I - \\omega D_{mat}^{-1} C_{mat}\\right) \\phi^k + \\omega D_{mat}^{-1} b\n$$\n因此，迭代矩阵为 $G(\\omega) = (1-\\omega)I - \\omega G_{PC}$，其中 $G_{PC} = D_{mat}^{-1} C_{mat}$ 是预处理的对流-扩散算子。常数向量为 $c = \\omega D_{mat}^{-1} b$。\n\n接下来，我们证明 $G_{PC}$ 的谱是纯虚数。设 $\\lambda$ 是 $G_{PC}$ 的一个特征值，对应的特征向量为 $v$：\n$$\nD_{mat}^{-1} C_{mat} v = \\lambda v \\implies C_{mat} v = \\lambda D_{mat} v\n$$\n对该方程取共轭转置得到 $v^* C_{mat}^* = \\bar{\\lambda} v^* D_{mat}^*$。由于 $D_{mat}$ 是实对称矩阵（$D_{mat}^* = D_{mat}$），而 $C_{mat}$ 是实斜对称矩阵（$C_{mat}^* = C_{mat}^T = -C_{mat}$），该式变为 $-v^* C_{mat} = \\bar{\\lambda} v^* D_{mat}$。\n用 $v^*$ 左乘原始特征值方程得到 $v^* C_{mat} v = \\lambda v^* D_{mat} v$。将此式与共轭转置得到的结果 $-v^* C_{mat} v = \\bar{\\lambda} v^* D_{mat} v$ 相加，得到：\n$$\n0 = (\\lambda + \\bar{\\lambda})(v^* D_{mat} v) = 2 \\text{Re}(\\lambda) (v^* D_{mat} v)\n$$\n由于 $D_{mat}$ 是正定的，对于任意非零特征向量 $v$，$v^* D_{mat} v > 0$。因此，必须有 $\\text{Re}(\\lambda) = 0$，这证明了 $G_{PC}$ 的特征值是纯虚数，即形式为 $\\lambda = i\\beta$（其中 $\\beta$ 为实数）。\n\n为了获得谱半径 $\\rho(G_{PC}) = \\max |\\lambda|$ 的界，我们进行局部分析。设 $v_k$ 是特征向量 $v$ 中模最大的分量，即对于所有 $j$ 都有 $|v_k| \\ge |v_j|$。特征值方程 $C_{mat} v = \\lambda D_{mat} v$ 的第 $k$ 行为：\n$$\n\\frac{u}{2}(v_{k+1} - v_{k-1}) = \\lambda \\frac{\\alpha}{h}(-v_{k-1} + 2v_k - v_{k+1})\n$$\n假设 $v_k \\ne 0$，我们用它来除方程，并重新整理以求解 $\\lambda$：\n$$\n\\lambda = \\frac{\\frac{u}{2}(\\frac{v_{k+1}}{v_k} - \\frac{v_{k-1}}{v_k})}{\\frac{\\alpha}{h}(2 - \\frac{v_{k-1}}{v_k} - \\frac{v_{k+1}}{v_k})} = \\frac{|u|h}{2\\alpha} \\frac{\\frac{u}{|u|}(\\frac{v_{k+1}}{v_k} - \\frac{v_{k-1}}{v_k})}{2 - (\\frac{v_{k-1}}{v_k} + \\frac{v_{k+1}}{v_k})}\n$$\n令 $z_1 = \\frac{v_{k+1}}{v_k}$ 和 $z_2 = \\frac{v_{k-1}}{v_k}$。根据 $v_k$ 的定义，有 $|z_1| \\le 1$ 和 $|z_2| \\le 1$。网格佩克莱数为 $Pe_h = \\frac{|u|h}{2\\alpha}$。取其模：\n$$\n|\\lambda| = Pe_h \\left| \\frac{z_1 - z_2}{2 - (z_1+z_2)} \\right| \\le Pe_h \\sup_{|z_1|\\le 1, |z_2|\\le 1} \\frac{|z_1 - z_2|}{|2 - (z_1+z_2)|}\n$$\n在定义的约束条件下，使右侧表达式最大化的选择是 $z_1 = i$ 和 $z_2 = -i$，其值为 $\\frac{|i - (-i)|}{|2 - (i-i)|} = \\frac{|2i|}{|2|} = 1$。因此，我们得到谱半径的界：\n$$\n\\rho(G_{PC}) = \\max |\\lambda| \\le Pe_h\n$$\n\n### 2) 稳定性判据的推导\n\n为了使迭代是收缩的，迭代矩阵 $G(\\omega)$ 的谱半径必须严格小于 $1$，即 $\\rho(G(\\omega))  1$。$G(\\omega)$ 的特征值 $\\mu$ 与 $G_{PC}$ 的特征值 $\\lambda$ 通过 $\\mu = (1-\\omega) - \\omega \\lambda$ 相关联。\n利用第 1 部分的结论，我们有 $\\lambda = i\\beta$，其中 $|\\beta| \\le Pe_h$。$\\mu$ 的模为：\n$$\n|\\mu|^2 = |(1-\\omega) - i\\omega\\beta|^2 = (1-\\omega)^2 + (\\omega\\beta)^2\n$$\n为确保稳定性，我们要求对于所有可能的 $\\beta$ 值，都有 $|\\mu|^2  1$。此条件在 $|\\beta|$ 取最大值时最为严格，因此通过设置 $|\\beta| = \\rho(G_{PC})$ 并使用我们的界 $|\\beta| \\le Pe_h$，可以找到一个充分稳定性条件：\n$$\n(1-\\omega)^2 + \\omega^2 Pe_h^2  1\n$$\n对于 $\\omega \\in (0,1]$，展开并简化该不等式：\n$$\n1 - 2\\omega + \\omega^2 + \\omega^2 Pe_h^2  1\n$$\n$$\n-2\\omega + \\omega^2(1+Pe_h^2)  0\n$$\n由于 $\\omega > 0$，我们可以用它来除不等式两边：\n$$\n-2 + \\omega(1+Pe_h^2)  0\n$$\n$$\n\\omega (1+Pe_h^2)  2 \\implies \\omega  \\frac{2}{1+Pe_h^2}\n$$\n这就是从我们的谱界推导出的充分稳定性判据。由于问题规定欠松弛因子必须在范围 $\\omega \\in (0, 1]$ 内，因此 $\\omega$ 的最大允许值必须同时满足两个约束。所以，最大稳定欠松弛因子 $\\omega_{\\max}$ 由下式给出：\n$$\n\\omega_{\\max}(Pe_h) = \\min\\left(1, \\frac{2}{1+Pe_h^2}\\right)\n$$\n\n### 3) 自适应欠松弛方案\n\n基于推导出的稳定性界，我们可以定义一个自适应欠松弛方案，该方案根据局部网格佩克莱数 $Pe_i$ 调整因子 $\\omega_i$。\n\n对于佩克莱数为 $Pe_i$ 的单元，其最大稳定欠松弛因子为 $\\omega_{\\max}(Pe_i) = \\min\\left(1, \\frac{2}{1+Pe_i^2}\\right)$。当 $Pe_i \\le 1$ 时，该函数值为 $1$，并随着 $Pe_i$ 的增加而趋向于 $0$。\n\n自适应的逐单元欠松弛因子 $\\omega_i$ 的方案由以下公式给出：\n$$\n\\omega_i = \\min\\big( \\omega_{\\text{base}}, \\min(1, \\omega_{\\max}(Pe_i)) \\big)\n$$\n正如第 2 部分所论证的，因为 $\\omega_{\\max}(Pe_i)$ 已经被限制在 $1$ 以下，所以 $\\min(1, \\omega_{\\max}(Pe_i))$ 这一项就是 $\\omega_{\\max}(Pe_i)$。因此，公式简化为：\n$$\n\\omega_i = \\min(\\omega_{\\text{base}}, \\omega_{\\max}(Pe_i)) = \\min\\left(\\omega_{\\text{base}}, \\frac{2}{1+Pe_i^2}\\right)\n$$\n请注意，由于 $\\omega_{\\text{base}} \\le 1$，组合后的表达式也被限制在 $1$ 以下。\n\n对于保证所有单元稳定性的单个全局欠松弛因子 $\\omega_{\\text{global}}$，我们必须在所有单元的稳定性限制中选择最严格（即最小）的值：\n$$\n\\omega_{\\text{global}} = \\min_{i} \\omega_{\\max}(Pe_i)\n$$\n由于当 $Pe \\ge 0$ 时，$\\omega_{\\max}(Pe)$ 是 $Pe$ 的单调递减函数，因此这个最小值对应于具有最大佩克莱数 $Pe_{\\max} = \\max_i Pe_i$ 的单元：\n$$\n\\omega_{\\text{global}} = \\omega_{\\max}(Pe_{\\max}) = \\min\\left(1, \\frac{2}{1+Pe_{\\max}^2}\\right)\n$$\n\n### 4) 程序实现\n\n以下 Python 程序实现了所推导的公式，用于为提供的测试套件计算自适应和全局欠松弛因子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating under-relaxation factors for given test cases.\n    \"\"\"\n\n    test_cases = [\n        {'type': 'global', 'Pe': [0.5, 1.0, 2.0], 'w_base': 0.95},\n        {'type': 'per-cell', 'Pe': [0.1, 1.0, 5.0, 10.0], 'w_base': 0.8},\n        {'type': 'global', 'Pe': [0.0, 100.0, 50.0], 'w_base': 1.0},\n        {'type': 'per-cell', 'Pe': [0.0, 0.5, 2.0, 20.0, 100.0], 'w_base': 0.9},\n    ]\n\n    results = []\n    \n    def get_w_max(pe):\n        \"\"\"\n        Calculates the maximum stable under-relaxation factor for a given Peclet number.\n        omega_max(Pe) = min(1, 2 / (1 + Pe^2))\n        \"\"\"\n        if pe  0:\n            # Peclet number is defined based on |u|, so it should be non-negative.\n            raise ValueError(\"Peclet number cannot be negative.\")\n        \n        # The stability bound derived from first principles.\n        bound = 2.0 / (1.0 + pe**2)\n        \n        # The final value is capped at 1.0 as per omega in (0, 1].\n        return min(1.0, bound)\n\n    for case in test_cases:\n        pe_list = case['Pe']\n        \n        if case['type'] == 'global':\n            # For the global recommendation, find the maximum Peclet number in the list.\n            if not pe_list:\n                # Handle empty list case to avoid error with max()\n                max_pe = 0.0\n            else:\n                max_pe = max(pe_list)\n            \n            # The global omega is determined by the most restrictive (highest Pe) case.\n            w_global = get_w_max(max_pe)\n            results.append(w_global)\n            \n        elif case['type'] == 'per-cell':\n            w_base = case['w_base']\n            w_adaptive_list = []\n            \n            # For the per-cell adaptive scheme, calculate omega for each cell.\n            for pe in pe_list:\n                # The local stability limit for the cell's Peclet number.\n                w_limit = get_w_max(pe)\n                \n                # The actual omega used is the minimum of the base value and the local limit.\n                # omega_i = min(omega_base, omega_max(Pe_i))\n                w_i = min(w_base, w_limit)\n                w_adaptive_list.append(w_i)\n            results.append(w_adaptive_list)\n\n    # Helper function to format results exactly as required.\n    def format_result(item):\n        if isinstance(item, list):\n            # Format each float in the list to 8 decimal places and join them.\n            formatted_list = [f\"{x:.8f}\" for x in item]\n            return f\"[{','.join(formatted_list)}]\"\n        elif isinstance(item, float):\n            # Format a single float to 8 decimal places.\n            return f\"{item:.8f}\"\n        else:\n            return str(item)\n\n    # Convert all results to the specified string format.\n    final_output_strings = [format_result(r) for r in results]\n    \n    # Print the final comma-separated list enclosed in square brackets.\n    print(f\"[{','.join(final_output_strings)}]\")\n\nsolve()\n```", "id": "3386083"}, {"introduction": "虽然解析稳定性判据富有洞察力，但对于如反应流中常见的高度非线性和刚性系统，这种判据往往难以获得。本实践将介绍一种更通用、更强大的确保迭代收敛的技术：单调性保护的欠松弛格式。您将实现一个回溯线搜索算法，该算法能自适应地寻找步长 $\\omega_k$，以确保残差范数的单调递减，从而防止发散并提高求解器的鲁棒性。通过亲手实现，您将掌握如何为复杂的多物理场问题构建一个稳健的求解器。[@problem_id:3386114]", "problem": "您必须设计并实现一种用于迭代耦合的、保证单调性的欠松弛方案，该方案在每次接受更新时强制残差减小，并在一个具代表性的反应性可压缩流简化模型上，量化其相对于迭代次数减少所带来的计算开销。目标读者为计算流体动力学（CFD）领域的高阶研究生。程序必须是完整且可运行的。\n\n考虑以下在单个控制体积内的反应性可压缩混合物的无量纲简化稳态模型。未知状态向量为 $x = [T, Y]^{\\top}$，其中 $T$ 是无量纲温度，$Y$ 是无量纲反应进程变量。控制稳态残差定义为\n$$\nr(x) =\n\\begin{bmatrix}\nr_T(T, Y) \\\\\nr_Y(T, Y)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\alpha \\,(T - T_a) + q\\,S(T, Y) \\\\\n-\\beta\\,Y + S(T, Y)\n\\end{bmatrix},\n$$\n其中反应源项为\n$$\nS(T, Y) = k_0 \\,\\exp\\!\\left(-\\frac{E}{T}\\right) \\,(1 - Y) - k_1 \\, Y,\n$$\n参数 $\\alpha$、$\\beta$、$k_0$、$E$、$k_1$、$q$ 和环境温度 $T_a$ 均为严格正值。该模型捕捉了本质的刚度和耦合特性：温度 $T$ 通过阿伦尼乌斯因子 $\\exp\\!\\left(-E/T\\right)$ 进入 $S(T, Y)$，而热释放 $q\\,S(T,Y)$ 通过能量残差 $r_T$ 反向耦合回 $T$；$Y$ 在分解项 $\\beta Y$ 和消耗项 $k_1 Y$ 的作用下松弛，并与生成项 $k_0 \\exp(-E/T)(1-Y)$ 相平衡。\n\n您将使用一个通过顺序子求解定义的迭代耦合映射 $G(x)$：\n- 将温度冻结在当前迭代值 $T^k$，通过精确求解 $r_Y(T^k, Y) = 0$ 来计算组分更新，得到\n$$\nY^{\\star}(T^k) = \\frac{k_0 \\exp\\!\\left(-\\frac{E}{T^k}\\right)}{\\beta + k_1 + k_0 \\exp\\!\\left(-\\frac{E}{T^k}\\right)}.\n$$\n- 将组分冻结在 $Y^{\\star}(T^k)$，通过在一个物理合理的区间 $T \\in [T_{\\min}, T_{\\max}]$（其中 $T_{\\min} > 0$ 且 $T_{\\max}$ 足够大以包含预期解）内求解 $r_T(T, Y^{\\star}(T^k)) = 0$ 来计算温度更新。该求解必须对由大的 $E/T$ 引起的刚性具有鲁棒性。\n\n定义候选耦合更新方向 $s^k = G(x^k) - x^k$。保证单调性的欠松弛方案通过回溯选择一个步长 $\\omega_k \\in (0, 1]$，使得接受的更新 $x^{k+1} = x^k + \\omega_k s^k$ 满足残差范数减小的条件\n$$\n\\left\\| r(x^{k+1}) \\right\\|_2 \\le \\left\\| r(x^k) \\right\\|_2,\n$$\n其中 $\\|\\cdot\\|_2$ 表示欧几里得范数。如果在某个试验步长 $\\omega$ 下不满足此条件，则将 $\\omega$ 乘上一个在 $(0,1)$ 内的常数因子进行缩减，然后重试，直到成功或达到最小步长 $\\omega_{\\min}$ 为止。若达到最小步长仍未成功，则宣告寻找单调递减步失败。\n\n您必须：\n- 从不动点耦合出发，根据第一性原理推导出保证单调性的方法，并展示其与残差范数减小条件的关系。\n- 实现两个求解器：\n  1. 一个使用固定欠松弛因子 $\\omega_{\\text{const}} \\in (0,1]$ 且不带单调性保证的基础迭代耦合求解器。\n  2. 一个对 $\\omega_k$ 进行保证单调性的回溯线搜索，强制执行 $\\left\\| r(x^{k+1}) \\right\\|_2 \\le \\left\\| r(x^{k}) \\right\\|_2$。\n- 两个求解器使用相同的耦合映射 $G(x)$。\n- 使用收敛准则 $\\left\\| r(x^{k}) \\right\\|_2 \\le \\varepsilon$，其中容差 $\\varepsilon = 10^{-6}$，最大迭代次数 $K_{\\max} = 200$。\n- 通过报告每个测试案例的以下数据，来量化开销与迭代次数的减少：\n  - 保证单调性方法收敛所需的迭代次数，以整数形式表示。\n  - 保证单调性方法执行的残差范数计算次数，以整数形式表示。仅计算用于收敛检查和回溯接受测试的 $\\left\\| r(x) \\right\\|_2$ 调用次数，不包括在 $G(x)$ 的子求解器内部的计算。\n  - 在整个运行过程中，$\\omega$ 的回溯缩减总次数，以整数形式表示。\n  - 基础方法收敛所需的迭代次数，以整数形式表示；如果未能在 $K_{\\max}$ 次迭代内收敛，则为 $-1$。\n  - 基础方法的残差范数计算次数，以整数形式表示。\n  - 开销，定义为保证单调性方法与基础方法之间残差范数计算次数的差异，以整数形式表示。\n  - 迭代次数减少量，定义为基础方法与保证单调性方法之间迭代次数的差异，以整数形式表示（正数表示使用保证单调性方法所需的迭代次数更少）。\n\n本问题中的所有变量和数字都是无量纲的；不需要物理单位。不使用角度。不得使用百分比。\n\n测试套件和参数。对于每个案例，使用 $T_a = 1$ 和下面提供的初始猜测值 $x^0 = [T^0, Y^0]^{\\top}$：\n- 案例 A（弱耦合，顺利情况）：\n  - $\\alpha = 1.0$, $\\beta = 0.5$, $k_0 = 10.0$, $E = 5.0$, $k_1 = 1.0$, $q = 1.0$, $T^0 = 0.8$, $Y^0 = 0.1$。\n- 案例 B（刚性反应，强阿伦尼乌斯非线性）：\n  - $\\alpha = 3.0$, $\\beta = 2.0$, $k_0 = 50.0$, $E = 20.0$, $k_1 = 1.0$, $q = 1.5$, $T^0 = 0.5$, $Y^0 = 0.0$。\n- 案例 C（近平衡初始条件）：\n  - $\\alpha = 1.5$, $\\beta = 1.0$, $k_0 = 30.0$, $E = 10.0$, $k_1 = 0.5$, $q = 1.5$, $T^0 = 1.0$, $Y^0 = Y^{\\star}(T^0)$，其中\n    $$\n    Y^{\\star}(T^0) = \\frac{k_0 \\exp\\!\\left(-\\frac{E}{T^0}\\right)}{\\beta + k_1 + k_0 \\exp\\!\\left(-\\frac{E}{T^0}\\right)}.\n    $$\n\n您的程序需要使用的算法设置：\n- 固定的基础欠松弛因子 $\\omega_{\\text{const}} = 0.5$。\n- 保证单调性方法的回溯缩减因子 $\\theta = 0.5$（即每次回溯时 $\\omega \\leftarrow \\theta \\,\\omega$）。\n- 最小步长 $\\omega_{\\min} = 10^{-8}$。\n- 温度子求解的区间包围：从 $T_{\\min} = 10^{-3}$ 和 $T_{\\max} = 3.0$ 开始；如果未找到 $r_T(T, Y^{\\star}(T^k))$ 的符号变化，则通过序列 $10.0$, $50.0$, $100.0$ 按几何级数增加 $T_{\\max}$，直到找到符号变化或宣告无法包围。\n\n您的程序必须生成单行输出，其中依次包含案例 A、案例 B 和案例 C 的结果，形式为一个由方括号括起来的、逗号分隔的列表的列表。每个内部列表必须具有以下形式\n$[\\text{iters\\_safe}, \\text{evals\\_safe}, \\text{backtracks\\_safe}, \\text{iters\\_base}, \\text{evals\\_base}, \\text{overhead}, \\text{iteration\\_delta}]$，\n所有条目均为整数。例如，打印的输出必须看起来像\n$[[a_1,b_1,c_1,d_1,e_1,f_1,g_1],[a_2,b_2,c_2,d_2,e_2,f_2,g_2],[a_3,b_3,c_3,d_3,e_3,f_3,g_3]]$。", "solution": "用户指定了一个问题，要求设计、实现并分析一种用于代表反应性可压缩流的耦合非线性系统的、保证单调性的欠松弛方案。该问题是有效的，具有科学依据，且定义明确。我们将着手进行推导和求解。\n\n### 理论基础\n\n核心任务是为一个由残差函数 $r(x) = 0$ 定义的非线性方程组寻找稳态解 $x$。状态向量为 $x = [T, Y]^{\\top}$，代表无量纲温度和反应进程。该系统描述如下：\n$$\nr(x) =\n\\begin{bmatrix}\nr_T(T, Y) \\\\\nr_Y(T, Y)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\alpha \\,(T - T_a) + q\\,S(T, Y) \\\\\n-\\beta\\,Y + S(T, Y)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\\n0\n\\end{bmatrix}\n$$\n其中反应源项 $S(T, Y)$ 由阿伦尼乌斯型表达式给出：\n$$\nS(T, Y) = k_0 \\,\\exp\\!\\left(-\\frac{E}{T}\\right) \\,(1 - Y) - k_1 \\, Y\n$$\n\n对于这类多物理场问题，一种常见的策略是迭代耦合或块高斯-赛德尔方法。问题定义了一个特定的耦合映射 $G(x^k)$，它通过顺序求解分量方程来生成下一个迭代的候选值 $x_{\\text{cand}} = G(x^k)$。此映射的不动点 $x = G(x)$ 是完整系统 $r(x) = 0$ 的一个解。\n\n最简单的迭代方法是直接不动点迭代，$x^{k+1} = G(x^k)$。然而，这种方法可能不稳定，特别是对于刚性系统，其迭代雅可比矩阵的特征值可能具有较大的模。为了提高鲁棒性，我们引入一个欠松弛因子 $\\omega \\in (0, 1]$。更新过程于是变为在朝向候选解方向上的一个松弛步：\n$$\nx^{k+1} = x^k + \\omega (G(x^k) - x^k)\n$$\n此处，$s^k = G(x^k) - x^k$ 是由耦合映射提供的更新方向。\n\n问题要求比较两种选择 $\\omega$ 的策略：\n1.  **基础方法**：对所有迭代使用一个恒定的欠松弛因子 $\\omega = \\omega_{\\text{const}}$。这种方法简单，但如果所选因子不适合问题的特定刚度，可能会收敛缓慢或失败。\n2.  **保证单调性的方法**：在每次迭代 $k$ 时自适应地选择步长 $\\omega_k$，以确保向解的方向取得进展。进展由残差的欧几里得范数 $\\|r(x)\\|_2$ 来衡量。该保证强制此范数简单单调递减：\n$$\n\\left\\| r(x^{k+1}) \\right\\|_2 \\le \\left\\| r(x^k) \\right\\|_2\n$$\n此条件通过回溯线搜索来强制执行。我们从一个乐观的完整步长（$\\omega_k = 1$）开始，并计算一个试验状态 $x_{\\text{trial}} = x^k + \\omega_k s^k$。如果试验状态满足单调性条件，则接受该步（$x^{k+1} = x_{\\text{trial}}$）。如果不满足，则认为该步过于激进。然后我们通过乘法方式减小步长（$\\omega_k \\leftarrow \\theta \\omega_k$，其中缩减因子 $\\theta \\in (0, 1)$）来进行“回溯”，并重复试验，直到找到可接受的步长，或者步长变得小于预设的最小值 $\\omega_{\\min}$。\n\n这种保证单调性的方法将简单的不动点迭代转变为一个更鲁棒的非线性求解器。虽然方向 $s^k$ 不一定是函数 $f(x) = \\|r(x)\\|_2$ 的正式下降方向，但线搜索确保我们不接受移动到更高残差区域的步，从而防止了在刚性、强耦合问题中常见的多种迭代发散形式。主要的权衡是，由于回溯循环中可能需要多次评估残差，每次迭代的计算成本会增加，但这可能会显著减少收敛所需的总迭代次数，特别是在困难的情况下。\n\n### 实现策略\n\n实现将包括以下组件：\n- 用于计算源项 $S(T, Y)$ 和残差向量 $r(x)$ 的函数。\n- 用于计算耦合映射 $G(x)$ 的函数。这包括两个步骤：组分更新 $Y^{\\star}$ 的解析解和温度更新 $T^{\\star}$ 的数值一维求根。`scipy.optimize.brentq` 算法是求根步骤的理想选择，因为它鲁棒且保证在函数值具有相反符号的给定区间内找到根。实现将包括指定的逻辑，即如果最初未包围根，则扩展 $T^{\\star}$ 的搜索区间。\n- 两个求解器函数：`solver_baseline` 实现固定的 $\\omega_{\\text{const}}$ 方法，`solver_safeguarded` 实现对 $\\omega_k$ 的回溯线搜索。\n- 每个求解器将跟踪迭代次数、残差范数计算次数，对于保证单调性的方法，还将跟踪回溯事件的总数。这些计数器严格按照问题的定义来实现。\n- 一个主驱动循环将为三个测试案例（A、B 和 C）中的每一个执行两个求解器，计算所要求的性能指标（开销和迭代减少量），并格式化结果以供打印。案例 C 的初始条件 $Y^0 = Y^{\\star}(T^0)$ 在启动求解器之前计算。在计算迭代减少量时，通过将未收敛情况的迭代次数（由 -1 表示）视为允许的最大值 $K_{\\max}$ 来处理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to design, run, and compare the two under-relaxation schemes.\n    \"\"\"\n\n    # --- Algorithmic and Model Settings ---\n    K_MAX = 200\n    EPSILON = 1e-6\n    OMEGA_CONST = 0.5\n    THETA = 0.5\n    OMEGA_MIN = 1e-8\n    T_A = 1.0\n\n    # --- Helper Functions for the Physics Model ---\n\n    def S_term(T, Y, params):\n        \"\"\"Computes the dimensionless reaction source term S(T, Y).\"\"\"\n        k0, E, k1 = params['k0'], params['E'], params['k1']\n        if T = 0:\n            return -k1 * Y\n        return k0 * np.exp(-E / T) * (1 - Y) - k1 * Y\n\n    def residual(x, params):\n        \"\"\"Computes the residual vector r(x) = [r_T, r_Y]^T.\"\"\"\n        T, Y = x\n        alpha, beta, q = params['alpha'], params['beta'], params['q']\n        s_val = S_term(T, Y, params)\n        r_T = -alpha * (T - T_A) + q * s_val\n        r_Y = -beta * Y + s_val\n        return np.array([r_T, r_Y])\n\n    def coupling_map_G(x, params):\n        \"\"\"Computes the coupling map G(x) via sequential sub-solves.\"\"\"\n        T_k, _ = x\n        alpha, beta, k0, E, k1, q = params['alpha'], params['beta'], params['k0'], params['E'], params['k1'], params['q']\n\n        # 1. Compute species update Y_star by solving r_Y(T_k, Y) = 0\n        if T_k = 0:\n            exp_term = 0.0\n        else:\n            exp_term = k0 * np.exp(-E / T_k)\n        Y_star = exp_term / (beta + k1 + exp_term) if (beta + k1 + exp_term) != 0 else 0.0\n\n        # 2. Compute temperature update T_star by solving r_T(T, Y_star) = 0\n        def r_T_for_solve(T):\n            s_val = S_term(T, Y_star, params)\n            return -alpha * (T - T_A) + q * s_val\n\n        T_max_search_list = [3.0, 10.0, 50.0, 100.0]\n        T_min_br = 1e-3\n        T_star = None\n\n        for T_max_br in T_max_search_list:\n            try:\n                T_star = brentq(r_T_for_solve, T_min_br, T_max_br, xtol=1e-12, rtol=1e-12)\n                break\n            except ValueError:\n                continue\n        \n        if T_star is None:\n            raise RuntimeError(f\"Failed to bracket root for Temperature sub-problem with x_k={x}\")\n            \n        return np.array([T_star, Y_star])\n\n    # --- Iterative Solver Implementations ---\n\n    def solver_baseline(x0, params):\n        \"\"\"Baseline solver with fixed under-relaxation factor.\"\"\"\n        x = np.copy(x0)\n        evals = 0\n        \n        for k in range(K_MAX):\n            norm_r = np.linalg.norm(residual(x, params))\n            evals += 1\n            if norm_r = EPSILON:\n                return k, evals\n\n            x_cand = coupling_map_G(x, params)\n            x = x + OMEGA_CONST * (x_cand - x)\n\n        norm_r = np.linalg.norm(residual(x, params))\n        evals += 1\n        return (K_MAX, evals) if norm_r = EPSILON else (-1, evals)\n\n    def solver_safeguarded(x0, params):\n        \"\"\"Solver with monotonicity-safeguarded backtracking line search.\"\"\"\n        x = np.copy(x0)\n        evals = 0\n        backtracks = 0\n        \n        for k in range(K_MAX):\n            norm_r_k = np.linalg.norm(residual(x, params))\n            evals += 1\n            if norm_r_k = EPSILON:\n                return k, evals, backtracks\n            \n            s_k = coupling_map_G(x, params) - x\n            omega = 1.0\n            \n            while True:\n                x_trial = x + omega * s_k\n                norm_r_trial = np.linalg.norm(residual(x_trial, params))\n                evals += 1\n                \n                if norm_r_trial = norm_r_k:\n                    x = x_trial\n                    break\n                \n                omega *= THETA\n                backtracks += 1\n                \n                if omega  OMEGA_MIN:\n                    return -1, evals, backtracks\n\n        norm_r = np.linalg.norm(residual(x, params))\n        evals += 1\n        return (K_MAX, evals, backtracks) if norm_r = EPSILON else (-1, evals, backtracks)\n\n    # --- Main Execution ---\n\n    # Define the test cases from the problem statement.\n    case_a_params = {'alpha': 1.0, 'beta': 0.5, 'k0': 10.0, 'E': 5.0, 'k1': 1.0, 'q': 1.0}\n    case_b_params = {'alpha': 3.0, 'beta': 2.0, 'k0': 50.0, 'E': 20.0, 'k1': 1.0, 'q': 1.5}\n    case_c_params = {'alpha': 1.5, 'beta': 1.0, 'k0': 30.0, 'E': 10.0, 'k1': 0.5, 'q': 1.5}\n\n    # Calculate special initial condition for Case C\n    T0_c = 1.0\n    exp_term_c = case_c_params['k0'] * np.exp(-case_c_params['E'] / T0_c)\n    Y0_c = exp_term_c / (case_c_params['beta'] + case_c_params['k1'] + exp_term_c)\n    \n    test_cases = [\n        (case_a_params, np.array([0.8, 0.1])),\n        (case_b_params, np.array([0.5, 0.0])),\n        (case_c_params, np.array([T0_c, Y0_c])),\n    ]\n\n    results = []\n    for params, x0 in test_cases:\n        # Run safeguarded solver\n        iters_safe, evals_safe, backtracks_safe = solver_safeguarded(x0, params)\n        \n        # Run baseline solver\n        iters_base, evals_base = solver_baseline(x0, params)\n        \n        # Calculate derived metrics\n        overhead = evals_safe - evals_base\n        \n        # Handle -1 in iteration counts for a consistent delta\n        iters_safe_for_delta = iters_safe if iters_safe != -1 else K_MAX\n        iters_base_for_delta = iters_base if iters_base != -1 else K_MAX\n        iteration_delta = iters_base_for_delta - iters_safe_for_delta\n        \n        results.append([\n            iters_safe, evals_safe, backtracks_safe,\n            iters_base, evals_base,\n            overhead, iteration_delta\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3386114"}]}