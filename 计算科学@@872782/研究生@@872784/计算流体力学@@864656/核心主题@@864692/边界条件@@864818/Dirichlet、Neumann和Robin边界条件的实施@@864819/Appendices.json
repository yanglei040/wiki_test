{"hands_on_practices": [{"introduction": "在开发或使用任何数值求解器时，首要任务之一是验证其正确性。制造解方法（Method of Manufactured Solutions, MMS）是一种强大而通用的技术，它允许我们为复杂的偏微分方程问题创建具有已知精确解的基准测试。[@problem_id:3333209] 将引导你亲手实践这一方法，通过为一个简单的一维热传导方程推导出一个预设解析解所必需的源项和边界条件数据。这项基础练习对于任何希望严谨测试其数值求解器的人来说都是至关重要的。", "problem": "考虑在有限区间 $x \\in [0,L]$ 和时间 $t \\ge 0$ 上的一个一维热传导问题，该问题由能量守恒和 Fourier 热传导定律控制。设热扩散系数为正常数 $\\kappa > 0$。带有（待定的）体积源项的控制方程为\n$$\n\\frac{\\partial u}{\\partial t} - \\kappa \\frac{\\partial^{2} u}{\\partial x^{2}} = s(x,t),\n$$\n在 $x=0$ 处有混合（Robin）边界条件，在 $x=L$ 处有 Neumann 边界条件，\n$$\n\\kappa \\frac{\\partial u}{\\partial x}(0,t) + \\beta\\, u(0,t) = r(t), \\qquad \\kappa \\frac{\\partial u}{\\partial x}(L,t) = q_{N}(t),\n$$\n其中 $\\beta>0$ 是一个给定的常数。为了检验 Robin 边界条件实现中的两项，并确保 Neumann 通量非平凡，使用人工解法，并选择如下形式的解：\n$$\nu(x,t) = \\exp(\\sigma t)\\,\\cos(a x) + x\\,\\exp(\\gamma t),\n$$\n其中 $a>0$，$\\sigma \\in \\mathbb{R}$ 和 $\\gamma \\in \\mathbb{R}$ 是常数，且 $\\sigma \\ne \\gamma$。从热方程和边界条件的定义出发，以闭合形式计算源项 $s(x,t)$、Robin 边界数据 $r(t)$、Neumann 边界数据 $q_{N}(t)$ 和初始条件 $u(x,0)$，使得该人工解在所有 $x \\in [0,L]$ 和所有 $t \\ge 0$ 上都满足问题。将您的最终答案表示为一个单行矩阵，其中按顺序包含 $s(x,t)$、$r(t)$、$q_{N}(t)$ 和 $u(x,0)$。不要进行任何数值取整；将您的答案保留为精确的解析形式。所有符号都代表物理量，其量纲由热方程隐含；本问题不需要具体单位。", "solution": "在尝试求解之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **控制方程**：$\\frac{\\partial u}{\\partial t} - \\kappa \\frac{\\partial^{2} u}{\\partial x^{2}} = s(x,t)$，对于 $x \\in [0,L]$ 和 $t \\ge 0$。\n- **热扩散系数**：$\\kappa$ 是一个正常数，$\\kappa > 0$。\n- **$x=0$ 处的 Robin 边界条件**：$\\kappa \\frac{\\partial u}{\\partial x}(0,t) + \\beta\\, u(0,t) = r(t)$，其中 $\\beta$ 是一个正常数，$\\beta > 0$。\n- **$x=L$ 处的 Neumann 边界条件**：$\\kappa \\frac{\\partial u}{\\partial x}(L,t) = q_{N}(t)$。\n- **人工解**：$u(x,t) = \\exp(\\sigma t)\\,\\cos(a x) + x\\,\\exp(\\gamma t)$。\n- **常数**：$a>0$，$\\sigma \\in \\mathbb{R}$，$\\gamma \\in \\mathbb{R}$，且 $\\sigma \\ne \\gamma$。\n- **目标**：计算源项 $s(x,t)$、Robin 边界数据 $r(t)$、Neumann 边界数据 $q_{N}(t)$ 和初始条件 $u(x,0)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题陈述。\n- **科学依据**：该问题基于一维热方程，这是输运现象的基石。人工解法是一种标准的、数学上合理的技术，用于验证偏微分方程的数值算法。该设置在科学上和数学上都是有效的。\n- **适定性**：该问题要求确定与一个指定解相符的源项和边界项。这是一个直接计算，而不是一个反问题的求解。任务定义明确，对于给定的人工解 $u(x,t)$，可以得出一组唯一的函数（$s(x,t)$, $r(t)$, $q_N(t)$, $u(x,0)$）。\n- **客观性**：问题使用精确的数学语言陈述，没有歧义或主观论断。\n- **完整性和一致性**：所有必要组成部分——控制偏微分方程、边界条件的形式以及人工解——都已提供。没有内部矛盾。例如，陈述了条件 $\\sigma \\ne \\gamma$，这确保了解的两个时间分量是不同的，尽管这个条件对于接下来的计算并非严格必需。所有参数都已明确定义。\n\n### 步骤 3：结论与行动\n该问题是**有效的**，因为它有科学依据、适定、客观且自洽。将提供解答。\n\n人工解法包括将选定的解析函数 $u(x,t)$ 代入控制偏微分方程及其边界条件，以推导出必要的源项和边界数据。\n\n给定的人工解为：\n$$\nu(x,t) = \\exp(\\sigma t)\\,\\cos(a x) + x\\,\\exp(\\gamma t)\n$$\n为继续进行，我们必须计算 $u(x,t)$ 的相关偏导数。\n\n首先，关于时间 $t$ 的偏导数：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial t} \\left( \\exp(\\sigma t)\\,\\cos(a x) + x\\,\\exp(\\gamma t) \\right) = \\sigma \\exp(\\sigma t)\\,\\cos(a x) + \\gamma x\\,\\exp(\\gamma t)\n$$\n\n接下来，关于位置 $x$ 的一阶偏导数：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\exp(\\sigma t)\\,\\cos(a x) + x\\,\\exp(\\gamma t) \\right) = -a \\exp(\\sigma t)\\,\\sin(a x) + \\exp(\\gamma t)\n$$\n\n最后，关于位置 $x$ 的二阶偏导数：\n$$\n\\frac{\\partial^{2} u}{\\partial x^{2}} = \\frac{\\partial}{\\partial x} \\left( -a \\exp(\\sigma t)\\,\\sin(a x) + \\exp(\\gamma t) \\right) = -a^2 \\exp(\\sigma t)\\,\\cos(a x)\n$$\n\n有了这些导数，我们就可以确定每一个所需的项。\n\n**1. 源项 $s(x,t)$**\n源项 $s(x,t)$ 通过将导数代入控制方程得到：\n$$\ns(x,t) = \\frac{\\partial u}{\\partial t} - \\kappa \\frac{\\partial^{2} u}{\\partial x^{2}}\n$$\n$$\ns(x,t) = \\left( \\sigma \\exp(\\sigma t)\\,\\cos(a x) + \\gamma x\\,\\exp(\\gamma t) \\right) - \\kappa \\left( -a^2 \\exp(\\sigma t)\\,\\cos(a x) \\right)\n$$\n合并各项，我们得到：\n$$\ns(x,t) = (\\sigma + \\kappa a^2) \\exp(\\sigma t)\\,\\cos(a x) + \\gamma x\\,\\exp(\\gamma t)\n$$\n\n**2. Robin 边界数据 $r(t)$**\n在 $x=0$ 处的 Robin 边界数据 $r(t)$ 由以下公式给出：\n$$\nr(t) = \\kappa \\frac{\\partial u}{\\partial x}(0,t) + \\beta\\, u(0,t)\n$$\n我们需要计算 $u(x,t)$ 和 $\\frac{\\partial u}{\\partial x}(x,t)$ 在 $x=0$ 处的值：\n$$\nu(0,t) = \\exp(\\sigma t)\\,\\cos(a \\cdot 0) + 0 \\cdot \\exp(\\gamma t) = \\exp(\\sigma t)\\,\\cos(0) = \\exp(\\sigma t)\n$$\n$$\n\\frac{\\partial u}{\\partial x}(0,t) = -a \\exp(\\sigma t)\\,\\sin(a \\cdot 0) + \\exp(\\gamma t) = -a \\exp(\\sigma t)\\,\\sin(0) + \\exp(\\gamma t) = \\exp(\\gamma t)\n$$\n将这些代入 $r(t)$ 的表达式中：\n$$\nr(t) = \\kappa (\\exp(\\gamma t)) + \\beta (\\exp(\\sigma t)) = \\beta \\exp(\\sigma t) + \\kappa \\exp(\\gamma t)\n$$\n\n**3. Neumann 边界数据 $q_{N}(t)$**\n在 $x=L$ 处的 Neumann 边界数据 $q_{N}(t)$ 定义为：\n$$\nq_{N}(t) = \\kappa \\frac{\\partial u}{\\partial x}(L,t)\n$$\n我们计算 $\\frac{\\partial u}{\\partial x}(x,t)$ 在 $x=L$ 处的值：\n$$\n\\frac{\\partial u}{\\partial x}(L,t) = -a \\exp(\\sigma t)\\,\\sin(a L) + \\exp(\\gamma t)\n$$\n因此，$q_N(t)$ 为：\n$$\nq_{N}(t) = \\kappa \\left( \\exp(\\gamma t) - a \\sin(a L) \\exp(\\sigma t) \\right)\n$$\n\n**4. 初始条件 $u(x,0)$**\n初始条件是解在时间 $t=0$ 时的值：\n$$\nu(x,0) = u(x,t)\\big|_{t=0} = \\exp(\\sigma \\cdot 0)\\,\\cos(a x) + x\\,\\exp(\\gamma \\cdot 0)\n$$\n$$\nu(x,0) = \\exp(0)\\,\\cos(a x) + x\\,\\exp(0) = 1 \\cdot \\cos(a x) + x \\cdot 1\n$$\n$$\nu(x,0) = \\cos(a x) + x\n$$\n\n四个所需的量已经以闭合形式确定。将它们汇集起来形成最终答案。", "answer": "$$\n\\boxed{\\begin{pmatrix} (\\sigma + \\kappa a^2) \\exp(\\sigma t)\\cos(a x) + \\gamma x\\exp(\\gamma t) \\\\ \\beta \\exp(\\sigma t) + \\kappa \\exp(\\gamma t) \\\\ \\kappa (\\exp(\\gamma t) - a \\sin(a L) \\exp(\\sigma t)) \\\\ \\cos(a x) + x \\end{pmatrix}}\n$$", "id": "3333209"}, {"introduction": "仅仅正确实现边界条件的离散格式是不够的；所选择的边界条件组合必须构成一个数学上适定的问题。不恰当的边界条件设定是计算流体力学中一个常见的陷阱，可能导致线性系统无解或有无穷多解。[@problem_id:3333246] 将实践从解析推导转向实际编码，要求你为稳态斯托克斯流（Stokes flow）构建一个小型有限差分求解器。通过这个练习，你将学会如何通过分析离散后线性系统的性质来诊断因边界条件“过约束”而引发的病态问题，并理解如何构建一组物理上一致且数学上适定的边界条件。", "problem": "要求您实现并分析一个用于稳态一维不可压缩 Stokes 方程的最小有限差分求解器，以验证 Dirichlet、Neumann 和 Robin 边界条件的实现，并诊断由过定入流条件引发的不适定性。数学模型是定义在长度为 $L$ 的域上、运动粘度为 $\\nu$ 的稳态一维不可压缩 Stokes 系统，由连续性方程和动量方程组成，\n$$\n\\frac{d u}{d x} = 0, \\quad -\\nu \\frac{d^2 u}{d x^2} + \\frac{d p}{d x} = 0,\n$$\n其中 $u(x)$ 是速度，$p(x)$ 是压力。假设所有量均为无量纲。您的实现应在具有 $N$ 个节点、间距为 $h = L/(N-1)$ 的均匀网格上，对内部节点使用二阶中心有限差分，并通过将边界条件与内部有限差分方程一起组合成代数方程来施加边界条件，以使总方程数等于未知数数量。未知向量按所有节点的速度后跟所有节点的压力的顺序列出，即 $x = [u_0,\\dots,u_{N-1}, p_0,\\dots,p_{N-1}]^\\top$。\n\n从以下基本概念出发：\n- 不可压缩性约束 $\\frac{d u}{d x} = 0$。\n- 无体力情况下的线性动量平衡 $-\\nu \\frac{d^2 u}{d x^2} + \\frac{d p}{d x} = 0$。\n- 边界条件的分类：\n  - 场 $q$ 的 Dirichlet 条件：在边界点上 $q = q_D$。\n  - 场 $q$ 的 Neumann 条件：在边界点上 $\\frac{d q}{d n} = q_N$，在一维中通过左边界的单边差分 $\\frac{q_1 - q_0}{h}$ 和右边界的单边差分 $\\frac{q_{N-1} - q_{N-2}}{h}$ 来实现。\n  - $u$ 的 Robin 条件：在边界点上 $\\alpha u + \\beta \\frac{d u}{d n} = \\gamma$，其中系数 $\\alpha$、$\\beta$ 和数据 $\\gamma$ 为给定值。\n- 需要单一压力参考点以消除常数压力零空间。\n- 代数秩诊断：对于线性系统 $A x = b$，如果 $\\operatorname{rank}(A) < \\operatorname{rank}([A \\mid b])$，则系统不相容（无解）。如果 $\\operatorname{rank}(A)$ 严格小于未知数的数量，则系统欠定（解不唯一）。数值秩必须使用奇异值分解和一个小容差来计算。\n\n使用以下方法对节点 $i = 1,\\dots,N-2$ 上的内部方程进行离散化：\n- 连续性方程：$(u_{i+1} - u_{i-1})/(2h) = 0$。\n- 动量方程：$-\\nu (u_{i-1} - 2 u_{i} + u_{i+1})/h^2 + (p_{i+1} - p_{i-1})/(2 h) = 0$。\n\n通过包含所有内部方程和恰好四个边界（或参考）方程来组合一个方形线性系统 $A x = b$，以使系统是方形的。根据上面给出的代数形式实现 Dirichlet、Neumann 和 Robin 边界条件。\n\n构造一个验证案例，该案例由于在入流处同时对 $u$ 和 $p$ 施加 Dirichlet 条件而导致的过定入流条件，从而表现出不适定性，并通过证明数值秩亏或不相容性来诊断这种不适定性。然后，演示一个特征兼容的简化方法，将其简化为一个适定的 Dirichlet/Neumann 混合问题：对入流速度施加 Dirichlet 条件，对入流压力施加 Neumann（零梯度）条件，并除了在出流处为 $u$ 设置适当的条件（使用 Robin 条件）之外，还包括一个单一的压力参考点（在单点上的 Dirichlet 条件）。\n\n您的程序必须使用指定的参数实现以下测试套件，并以指定的格式生成结果。所有量均为无量纲。\n\n设 $L = 1$，$\\nu = 1$，$N = 10$，入流速度 $U_0 = 1$，压力值 $P_0 = 0$，$P_1 = 1$。对于 Robin 边界条件，使用单边有限差分计算导数。对于数值秩的计算，使用奇异值容差 $\\tau = 10^{-10}$。\n\n定义四个测试案例：\n\n- 测试 $1$（适定的 Dirichlet/Neumann/Robin 混合）：施加 $u(0) = U_0$，在 $x = L$ 处施加 Robin 条件，参数为 $\\alpha = 1$, $\\beta = 0$, $\\gamma = U_0$（这实际上是强制 $u(L) = U_0$），施加 Neumann 条件 $\\frac{d p}{d x}(0) = 0$，并施加单一压力参考 $p(0) = 0$。求解该系统，并返回残差的欧几里得范数 $\\|A x - b\\|_2$（浮点数）。\n\n- 测试 $2$（出流处具有不相容压力 Dirichlet 条件的过定入流）：施加 $u(0) = U_0$, $p(0) = P_0$, $u(L) = U_0$（通过参数为 $\\alpha = 1$, $\\beta = 0$, $\\gamma = U_0$ 的 Robin 条件实现），以及 $p(L) = P_1$ 且 $P_1 \\neq P_0$。组合该系统，并使用给定的容差计算数值秩 $r_A = \\operatorname{rank}(A)$ 和 $r_{aug} = \\operatorname{rank}([A \\mid b])$。返回布尔值 $r_{aug} > r_A$ 以表示不相容性。\n\n- 测试 $3$（测试 $2$ 的特征兼容简化）：将测试 $2$ 中的入流压力 Dirichlet 条件 $p(0) = P_0$ 替换为入流压力 Neumann 条件 $\\frac{d p}{d x}(0) = 0$。保持 $u(0) = U_0$ 和 $u(L) = U_0$（通过参数为 $\\alpha = 1$, $\\beta = 0$, $\\gamma = U_0$ 的 Robin 条件实现），并设置单一压力参考 $p(0) = 0$。求解该系统，并返回残差的欧几里得范数 $\\|A x - b\\|_2$（浮点数）。\n\n- 测试 $4$（出流处为真正 Robin 条件的边界情况）：施加 $u(0) = U_0$，在 $x = L$ 处施加 Robin 条件，参数为 $\\alpha = 0$, $\\beta = 1$, $\\gamma = 0$（这强制 $\\frac{d u}{d x}(L) = 0$），施加 $\\frac{d p}{d x}(0) = 0$，并施加单一压力参考 $p(0) = 0$。求解该系统，并以浮点数形式返回平均绝对离散速度梯度 $\\frac{1}{N-1} \\sum_{i=0}^{N-2} \\left|\\frac{u_{i+1} - u_i}{h}\\right|$，由于不可压缩性约束，该值应该很小。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个测试的结果，格式为方括号括起来的逗号分隔列表（例如，“[res1,res2,res3,res4]”）。第一个、第三个和第四个条目必须是浮点数；第二个条目必须是布尔值。所有计算都是无量纲的。不涉及角度。不使用百分比。", "solution": "该问题要求在长度为 $L$ 的域上实现一个用于稳态不可压缩 Stokes 方程的一维有限差分求解器。控制方程为连续性方程 $\\frac{d u}{d x} = 0$ 和动量方程 $-\\nu \\frac{d^2 u}{d x^2} + \\frac{d p}{d x} = 0$，其中 $u(x)$ 是速度，$p(x)$ 是压力，$\\nu$ 是运动粘度。我们构建一个线性代数系统 $A x = b$，并分析其在不同边界条件下的性质，以理解适定性。\n\n该域使用具有 $N$ 个节点的均匀网格进行离散化，节点索引为 $i=0, 1, \\dots, N-1$。网格间距为 $h = L/(N-1)$。未知向量 $x$ 的大小为 $2N$，其结构是通过连接速度未知数和压力未知数构成的：\n$$\nx = [u_0, u_1, \\dots, u_{N-1}, p_0, p_1, \\dots, p_{N-1}]^\\top\n$$\n线性系统 $A x = b$ 由 $2N$ 个方程构成。其中，$2(N-2)$ 个方程来自内部节点（$i=1, \\dots, N-2$）处控制偏微分方程的离散化，其余 $4$ 个方程源自边界条件和压力参考条件。\n\n内部方程使用二阶中心差分进行离散化：\n1.  **连续性方程：** 对于 $i = 1, \\dots, N-2$，方程 $\\frac{d u}{d x} = 0$ 离散化为：\n    $$\n    \\frac{u_{i+1} - u_{i-1}}{2h} = 0\n    $$\n    该方程影响矩阵 $A$ 中对应于未知数 $u_{i-1}$ 和 $u_{i+1}$ 的条目。对于 $A$ 中代表此方程的行，我们将 $u_{i-1}$ 的系数设置为 $-1/(2h)$，将 $u_{i+1}$ 的系数设置为 $1/(2h)$。\n\n2.  **动量方程：** 对于 $i = 1, \\dots, N-2$，方程 $-\\nu \\frac{d^2 u}{d x^2} + \\frac{d p}{d x} = 0$ 离散化为：\n    $$\n    -\\nu \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} + \\frac{p_{i+1} - p_{i-1}}{2h} = 0\n    $$\n    该方程涉及未知数 $u_{i-1}, u_i, u_{i+1}$ 和 $p_{i-1}, p_{i+1}$。对于 $A$ 中代表此方程的行，系数如下：\n    - 对于 $u_{i-1}$：$-\\nu/h^2$\n    - 对于 $u_i$：$2\\nu/h^2$\n    - 对于 $u_{i+1}$：$-\\nu/h^2$\n    - 对于 $p_{i-1}$（在列索引 $N+i-1$ 处）：$-1/(2h)$\n    - 对于 $p_{i+1}$（在列索引 $N+i+1$ 处）：$1/(2h)$\n\n边界条件作为代数方程实现，构成系统的最后 $4$ 行。\n-   在节点 $k$ 处的场 $q$ 上的 **Dirichlet 条件**，$q_k = q_D$，产生的方程在对应 $q_k$ 的列中为 $1$，在 $b$ 的相应条目中为值 $q_D$。\n-   **Neumann 条件** $\\frac{dq}{dn} = q_N$ 使用一阶单边差分进行离散化。在左边界（$i=0$），即为 $\\frac{q_1 - q_0}{h} = q_N$。在右边界（$i=N-1$），即为 $\\frac{q_{N-1} - q_{N-2}}{h} = q_N$。\n-   在边界节点上的 **Robin 条件** $\\alpha u + \\beta \\frac{du}{dn} = \\gamma$ 也类似地进行离散化。在左边界（$i=0$），它变为 $\\alpha u_0 + \\beta \\frac{u_1 - u_0}{h} = \\gamma$。在右边界（$i=N-1$），它变为 $\\alpha u_{N-1} + \\beta \\frac{u_{N-1} - u_{N-2}}{h} = \\gamma$。\n\n控制方程的解析解为 $u(x) = C_1$ 和 $p(x) = C_2$，其中 $C_1$ 和 $C_2$ 为常数。这意味着速度场是恒定的，压力场也是恒定的。压力仅能确定到一个相加常数，这会产生一个零空间。需要一个单一的压力参考点，例如在某一点固定其值（例如，$p_0=0$），以获得唯一解。\n\n我们现在分析四个指定的测试案例，参数为 $L=1$, $\\nu=1$, $N=10$, $U_0=1$, $P_0=0$, $P_1=1$，以及用于秩计算的奇异值容差 $\\tau=10^{-10}$。网格间距为 $h=1/(10-1) = 1/9$。\n\n**测试 1 (适定的 Dirichlet/Neumann/Robin 混合):**\n四个边界/参考条件是：\n1.  $u(0) = U_0 \\implies u_0 = 1$（在 $x=0$ 处对 $u$ 施加 Dirichlet 条件）\n2.  在 $x=L$ 处的 Robin 条件，参数为 $\\alpha=1, \\beta=0, \\gamma=U_0$：$1 \\cdot u_{N-1} + 0 \\cdot (\\dots) = 1 \\implies u_9=1$（实际上是在 $x=L$ 处对 $u$ 施加 Dirichlet 条件）\n3.  $\\frac{dp}{dx}(0) = 0 \\implies \\frac{p_1-p_0}{h} = 0$（在 $x=0$ 处对 $p$ 施加 Neumann 条件）\n4.  $p(0) = P_0 \\implies p_0 = 0$（压力参考点）\n该系统是适定的。与这些条件兼容的解析解是 $u(x)=1$ 和 $p(x)=0$。离散系统应得出与此非常接近的解，因此残差 $\\|Ax-b\\|_2$ 预计接近机器精度。\n\n**测试 2 (出流处具有不相容压力 Dirichlet 条件的过定入流):**\n四个边界条件是：\n1.  $u(0) = U_0 \\implies u_0 = 1$\n2.  $p(0) = P_0 \\implies p_0 = 0$\n3.  $u(L) = U_0 \\implies u_9 = 1$\n4.  $p(L) = P_1 \\implies p_9 = 1$\n该系统是不适定的。速度恒定时的动量方程意味着 $\\frac{dp}{dx}=0$，即压力必须是常数。条件 $p(0)=0$ 和 $p(L)=1$ 是相互矛盾的。这导致了一个不相容的线性系统。秩亏诊断应该能揭示这一点：我们预计 $\\operatorname{rank}(A) < \\operatorname{rank}([A \\mid b])$，其中 $[A \\mid b]$ 是增广矩阵。\n\n**测试 3 (测试 2 的特征兼容简化):**\n边界/参考条件是：\n1.  $u(0) = U_0 \\implies u_0 = 1$\n2.  $u(L) = U_0 \\implies u_9 = 1$\n3.  $\\frac{dp}{dx}(0)=0 \\implies \\frac{p_1-p_0}{h} = 0$\n4.  $p(0)=0$ (压力参考点)\n这组条件与测试 1 相同。它代表了对测试 2 中不适定系统的一个适定替代方案，通过将有问题的出流压力 Dirichlet 条件替换为入流压力 Neumann 条件，这与恒定压力场的物理特性一致。预期的结果与测试 1 相同：一个接近于零的残差。\n\n**测试 4 (出流处为真正 Robin 条件的边界情况):**\n四个边界/参考条件是：\n1.  $u(0) = U_0 \\implies u_0 = 1$\n2.  在 $x=L$ 处的 Robin 条件，参数为 $\\alpha=0, \\beta=1, \\gamma=0$：$0 \\cdot u_{N-1} + 1 \\cdot \\frac{u_{N-1}-u_{N-2}}{h} = 0 \\implies \\frac{du}{dx}(L)=0$（在 $x=L$ 处对 $u$ 施加 Neumann 条件）\n3.  $\\frac{dp}{dx}(0)=0 \\implies \\frac{p_1-p_0}{h} = 0$\n4.  $p(0)=0$ (压力参考点)\n该系统也是适定的。解析解 $u(x)=1, p(x)=0$ 满足所有条件。离散解应为对所有 $i$ 都有 $u_i \\approx 1$。不可压缩性约束 $\\frac{du}{dx}=0$ 由连续性方程强制执行。因此，平均绝对离散速度梯度 $\\frac{1}{N-1}\\sum_{i=0}^{N-2} |\\frac{u_{i+1}-u_i}{h}|$ 应非常接近于 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes a finite difference solver for 1D steady\n    incompressible Stokes flow to validate boundary condition implementations.\n    \"\"\"\n\n    # Global parameters from the problem statement\n    L = 1.0\n    nu = 1.0\n    N = 10\n    U0 = 1.0\n    P0 = 0.0\n    P1 = 1.0\n    tau = 1e-10\n    h = L / (N - 1)\n    \n    # Store results for each test case\n    results = []\n\n    # --- Helper function to build the system ---\n    def build_system(bcs):\n        \"\"\"\n        Assembles the matrix A and vector b for the system Ax=b.\n        \n        Args:\n            bcs (list): A list of tuples, each defining a boundary condition.\n                        Format: (type, variable, index, value)\n                        type: 'dirichlet', 'neumann', 'robin'\n                        variable: 'u' or 'p'\n                        index: 0 for left boundary, N-1 for right\n                        value: float for dirichlet/neumann, dict for robin\n        \n        Returns:\n            A (np.ndarray): The system matrix.\n            b (np.ndarray): The right-hand-side vector.\n        \"\"\"\n        A = np.zeros((2 * N, 2 * N))\n        b = np.zeros(2 * N)\n        row = 0\n\n        # Interior equations: Continuity (N-2 equations)\n        for i in range(1, N - 1):\n            A[row, i - 1] = -1.0 / (2.0 * h)\n            A[row, i + 1] = 1.0 / (2.0 * h)\n            b[row] = 0.0\n            row += 1\n\n        # Interior equations: Momentum (N-2 equations)\n        for i in range(1, N - 1):\n            # u part\n            A[row, i - 1] = -nu / (h**2)\n            A[row, i]     = 2.0 * nu / (h**2)\n            A[row, i + 1] = -nu / (h**2)\n            # p part (indices shifted by N)\n            A[row, N + i - 1] = -1.0 / (2.0 * h)\n            A[row, N + i + 1] = 1.0 / (2.0 * h)\n            b[row] = 0.0\n            row += 1\n            \n        # Boundary/Reference conditions (4 equations)\n        for bc in bcs:\n            bc_type, var, idx, val = bc\n            var_offset = 0 if var == 'u' else N\n            \n            if bc_type == 'dirichlet':\n                A[row, var_offset + idx] = 1.0\n                b[row] = val\n            elif bc_type == 'neumann':\n                if idx == 0:  # Left boundary (forward difference)\n                    # (q_1 - q_0)/h = val\n                    A[row, var_offset + 0] = -1.0 / h\n                    A[row, var_offset + 1] = 1.0 / h\n                    b[row] = val\n                else:  # Right boundary (backward difference)\n                    # (q_{N-1} - q_{N-2})/h = val\n                    A[row, var_offset + N - 2] = -1.0 / h\n                    A[row, var_offset + N - 1] = 1.0 / h\n                    b[row] = val\n            elif bc_type == 'robin':\n                alpha, beta, gamma = val['alpha'], val['beta'], val['gamma']\n                if idx == 0: # Left boundary\n                    # alpha*u_0 + beta*(u_1-u_0)/h = gamma\n                    A[row, 0] = alpha - beta/h\n                    A[row, 1] = beta/h\n                    b[row] = gamma\n                else: # Right boundary\n                    # alpha*u_{N-1} + beta*(u_{N-1}-u_{N-2})/h = gamma\n                    A[row, N-2] = -beta/h\n                    A[row, N-1] = alpha + beta/h\n                    b[row] = gamma\n            row += 1\n            \n        return A, b\n\n    # --- Test 1: Well-posed mix ---\n    bc_test1 = [\n        ('dirichlet', 'u', 0, U0),\n        ('robin', 'u', N-1, {'alpha': 1, 'beta': 0, 'gamma': U0}),\n        ('neumann', 'p', 0, 0.0),\n        ('dirichlet', 'p', 0, P0),\n    ]\n    A1, b1 = build_system(bc_test1)\n    x1 = np.linalg.solve(A1, b1)\n    res1 = np.linalg.norm(A1 @ x1 - b1)\n    results.append(res1)\n\n    # --- Test 2: Over-specified inflow ---\n    bc_test2 = [\n        ('dirichlet', 'u', 0, U0),\n        ('dirichlet', 'p', 0, P0),\n        ('robin', 'u', N-1, {'alpha': 1, 'beta': 0, 'gamma': U0}),\n        ('dirichlet', 'p', N-1, P1),\n    ]\n    A2, b2 = build_system(bc_test2)\n    A_aug2 = np.c_[A2, b2]\n    rank_A = np.linalg.matrix_rank(A2, tol=tau)\n    rank_aug = np.linalg.matrix_rank(A_aug2, tol=tau)\n    res2 = rank_aug > rank_A\n    results.append(res2)\n\n    # --- Test 3: Characteristic-compatible reduction ---\n    bc_test3 = [\n        ('dirichlet', 'u', 0, U0),\n        ('robin', 'u', N-1, {'alpha': 1, 'beta': 0, 'gamma': U0}),\n        ('neumann', 'p', 0, 0.0),\n        ('dirichlet', 'p', 0, P0),\n    ]\n    A3, b3 = build_system(bc_test3)\n    x3 = np.linalg.solve(A3, b3)\n    res3 = np.linalg.norm(A3 @ x3 - b3)\n    results.append(res3)\n\n    # --- Test 4: Genuine Robin at outflow ---\n    bc_test4 = [\n        ('dirichlet', 'u', 0, U0),\n        ('robin', 'u', N-1, {'alpha': 0, 'beta': 1, 'gamma': 0.0}), # du/dx(L) = 0\n        ('neumann', 'p', 0, 0.0),\n        ('dirichlet', 'p', 0, P0),\n    ]\n    A4, b4 = build_system(bc_test4)\n    x4 = np.linalg.solve(A4, b4)\n    u4 = x4[:N]\n    \n    # Compute mean absolute discrete velocity gradient\n    grad_sum = 0.0\n    for i in range(N - 1):\n        grad_sum += np.abs((u4[i + 1] - u4[i]) / h)\n    res4 = grad_sum / (N - 1)\n    results.append(res4)\n\n    # Final print statement in the exact required format.\n    # The boolean for Test 2 needs to be a string in the final list.\n    formatted_results = [f\"{r:.15e}\" if isinstance(r, float) else str(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3333246"}, {"introduction": "在前两个实践的基础上，本节将挑战一个更完整、更复杂的二维验证问题。这个综合性练习 [@problem_id:3333213] 涉及为对流-扩散方程实现二阶精度的狄利克雷（Dirichlet）、诺伊曼（Neumann）和罗宾（Robin）边界条件，包括处理不同类型边界交汇处的角点这一棘手情况。通过将你的数值结果与制造解进行比较，你将执行一次收敛性研究，以正式验证你的代码实现是否达到了预期的精度等级，这是确保数值模拟可靠性的关键步骤。", "problem": "设计并实现一个针对稳态二维对流-扩散方程的人工解基准测试。该测试包含混合边界段，并使用鬼点格式来保持目标二阶精度，包括在狄利克雷(Dirichlet)、诺伊曼(Neumann)和罗宾(Robin)边界交汇的角点附近。\n\n数学模型是在方形域 $\\Omega = [0,1]\\times[0,1]$ 内的无源标量场 $u(x,y)$ 的稳态对流-扩散方程：\n$$\n- \\nabla \\cdot \\left( \\nu \\nabla u \\right) + \\mathbf{a} \\cdot \\nabla u \\;=\\; s(x,y) \\quad \\text{in } \\Omega,\n$$\n其中 $\\nu \\gt 0$ 是（常数）扩散系数，$\\mathbf{a} = (a_x,a_y)$ 是（常数）对流速度。边界 $\\partial \\Omega$ 被划分为三个不相交的段，\n$$\n\\partial \\Omega = \\Gamma_D \\cup \\Gamma_N \\cup \\Gamma_R, \\quad \\Gamma_D \\cap \\Gamma_N = \\Gamma_D \\cap \\Gamma_R = \\Gamma_N \\cap \\Gamma_R = \\emptyset,\n$$\n在这些边界段上规定了以下边界条件：\n- 狄利克雷 (Dirichlet): $u|_{\\Gamma_D} = g$,\n- 诺伊曼 (Neumann): $\\nabla u \\cdot \\mathbf{n}|_{\\Gamma_N} = h$,\n- 罗宾 (Robin): $\\alpha u + \\beta \\nabla u \\cdot \\mathbf{n}|_{\\Gamma_R} = r$,\n其中 $\\mathbf{n}$ 是单位外法向量，$\\alpha \\ge 0$, $\\beta \\ge 0$ 是常数，且 $\\alpha$ 和 $\\beta$ 中至少有一个严格为正。在边界类型交汇的角点上，为了避免过定，遵循 $\\Gamma_D \\succ \\Gamma_R \\succ \\Gamma_N$ 的优先级施加单个条件。\n\n从标量守恒和 Fick 定律作为基本出发点：稳态守恒定律为 $\\nabla \\cdot \\mathbf{J} + q = 0$，其中通量 $\\mathbf{J} = -\\nu \\nabla u + \\mathbf{a} u$，源项 $q = -s$，由此得到上述偏微分方程。\n\n为了进行定量测试，采用一个构造的解析解\n$$\nu(x,y) \\;=\\; \\sin(2\\pi x)\\,\\cos(\\pi y) \\;+\\; x\\,y,\n$$\n并将此 $u(x,y)$ 代入具有指定 $\\nu$ 和 $\\mathbf{a}$ 的控制方程中，以定义右端项 $s(x,y)$。对于边界数据，定义\n- $g(x,y) = u(x,y)$ on $\\Gamma_D$,\n- $h(x,y) = \\nabla u \\cdot \\mathbf{n}$ on $\\Gamma_N$,\n- $r(x,y) = \\alpha u + \\beta \\nabla u \\cdot \\mathbf{n}$ on $\\Gamma_R$,\n这样，该构造解就能精确满足模型。\n\n离散化要求：\n- 使用以节点为中心的均匀笛卡尔网格，在 $x$ 方向上有 $N_x+1$ 个点，在 $y$ 方向上有 $N_y+1$ 个点。其中，$x_i = i \\Delta x$, $\\Delta x = 1/N_x$, $i=0,\\dots,N_x$，$y_j = j \\Delta y$, $\\Delta y = 1/N_y$, $j=0,\\dots,N_y$。\n- 对于内部节点，使用二阶中心有限差分来离散化扩散项和对流项的微分算子，即，对于内部节点 $(i,j)$，\n$$\n- \\nu \\left( \\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{\\Delta x^2} + \\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{\\Delta y^2} \\right)\n+ a_x \\frac{u_{i+1,j} - u_{i-1,j}}{2\\Delta x}\n+ a_y \\frac{u_{i,j+1} - u_{i,j-1}}{2\\Delta y}\n= s(x_i,y_j).\n$$\n- 使用鬼点格式实现边界条件，通过代数消元，在边界节点上得到单边二阶精确的边界方程。在以节点为中心的网格上显式推导以下规范格式：\n  1. 边界节点 $(i,j)$ 处的狄利克雷条件：$u_{i,j} = g(x_i,y_j)$。\n  2. 在下边界 $y=0$ 处的诺伊曼条件，单位外法向量为 $\\mathbf{n}=(0,-1)$，因此 $\\nabla u \\cdot \\mathbf{n} = -u_y$：从包含鬼点值 $u_{i,-1}$ 的中心法向导数出发，\n     $$\n     -\\frac{u_{i,1} - u_{i,-1}}{2\\Delta y} = h(x_i,0),\n     $$\n     通过对 $u_{i,0}$, $u_{i,1}$, $u_{i,2}$ 进行二次拟合来消去 $u_{i,-1}$，从而得到二阶单边格式\n     $$\n     -\\frac{-3u_{i,0} + 4u_{i,1} - u_{i,2}}{2\\Delta y} = h(x_i,0).\n     $$\n  3. 在右边界 $x=1$ 处的罗宾条件，单位外法向量为 $\\mathbf{n}=(1,0)$，因此 $\\nabla u \\cdot \\mathbf{n} = u_x$：从包含鬼点值 $u_{N_x+1,j}$ 的 $\\alpha u + \\beta u_x = r$ 出发，通过对 $u_{N_x,j}$, $u_{N_x-1,j}$, $u_{N_x-2,j}$ 进行二次拟合来消去鬼点值，从而得到\n     $$\n     \\alpha u_{N_x,j} + \\beta \\frac{3u_{N_x,j} - 4u_{N_x-1,j} + u_{N_x-2,j}}{2\\Delta x} = r(1,y_j).\n     $$\n- 在角点附近，根据优先级 $\\Gamma_D \\succ \\Gamma_R \\succ \\Gamma_N$ 仅施加一个边界条件，并沿远离角点节点的每条边使用上述单边格式。确保最终的全局线性系统是方形且适定的。\n\n此基准测试的边界分段必须如下：\n- $\\Gamma_D$: 左边界 $x=0$ 和上边界 $y=1$,\n- $\\Gamma_N$: 下边界 $y=0$,\n- $\\Gamma_R$: 右边界 $x=1$,\n角点选择规则如前所述。\n\n数值输出：实现上述方案，使用稀疏线性求解器组装并求解关于 $u_{i,j}$ 的线性系统。在内部节点上计算与构造解的误差范数：\n- 离散 $L^2$-范数\n$$\n\\|e\\|_{L^2_h} = \\left( \\sum_{i=1}^{N_x-1} \\sum_{j=1}^{N_y-1} |u_{i,j}^{\\text{num}} - u(x_i,y_j)|^2 \\,\\Delta x \\Delta y \\right)^{1/2},\n$$\n- 离散 $L^\\infty$-范数\n$$\n\\|e\\|_{L^\\infty_h} = \\max_{1 \\le i \\le N_x-1,\\;1 \\le j \\le N_y-1} |u_{i,j}^{\\text{num}} - u(x_i,y_j)|.\n$$\n\n测试套件：您的程序必须运行以下三个测试用例，并将结果按如下规定汇总到单行输出中。\n\n- 测试1（正常路径）：$N_x=N_y=32$, $\\nu=0.07$, $a_x=1.2$, $a_y=-0.8$, $\\alpha=2.0$, $\\beta=1.0$。输出离散 $L^2$-范数，格式为浮点数。\n- 测试2（在狄利克雷-诺伊曼和狄利克雷-罗宾角点附近的精度阶）：对于 $N_x=N_y=16$ 和 $N_x=N_y=32$（参数为 $\\nu=0.07$, $a_x=1.2$, $a_y=-0.8$, $\\alpha=2.0$, $\\beta=1.0$），计算离散 $L^2$-范数，然后报告观测到的阶\n$$\np = \\log_2\\left( \\frac{\\|e\\|_{L^2_h}(N_x=16)}{\\|e\\|_{L^2_h}(N_x=32)} \\right).\n$$\n- 测试3（变更的罗宾强度和对流）：$N_x=N_y=36$, $\\nu=0.10$, $a_x=1.6$, $a_y=0.4$, $\\alpha=0.5$, $\\beta=2.0$。输出离散 $L^\\infty$-范数，格式为浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含三个测试的结果，按测试1、测试2、测试3的顺序排列，形式为方括号内由逗号分隔的列表；例如，“[result1,result2,result3]”。不使用单位；所有量均为无量纲。", "solution": "该问题要求使用人工解法为二维稳态对流-扩散方程设计并实现一个数值基准测试。这包括推导必要的解析项，在均匀网格上离散化控制偏微分方程(PDE)，实现各种边界条件（包括在不同边界类型交汇的角点处），最后通过将数值解与已知的解析解进行比较来验证实现。\n\n### 解析公式\n\n控制方程是在域 $\\Omega = [0,1]\\times[0,1]$ 上的标量场 $u(x,y)$ 的稳态对流-扩散方程：\n$$\n- \\nabla \\cdot \\left( \\nu \\nabla u \\right) + \\mathbf{a} \\cdot \\nabla u = s(x,y)\n$$\n其中 $\\nu > 0$ 是常数扩散系数，$\\mathbf{a}=(a_x, a_y)$ 是常数对流速度，$s(x,y)$ 是源项。\n\n为了验证，规定了一个人工解：\n$$\nu(x,y) = \\sin(2\\pi x)\\cos(\\pi y) + xy\n$$\n为确定使此 $u(x,y)$ 成为精确解的源项 $s(x,y)$，我们计算必要的偏导数：\n$$\nu_x = \\frac{\\partial u}{\\partial x} = 2\\pi \\cos(2\\pi x)\\cos(\\pi y) + y\n$$\n$$\nu_y = \\frac{\\partial u}{\\partial y} = -\\pi \\sin(2\\pi x)\\sin(\\pi y) + x\n$$\n$$\n\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = -4\\pi^2 \\sin(2\\pi x)\\cos(\\pi y) - \\pi^2 \\sin(2\\pi x)\\cos(\\pi y) = -5\\pi^2 \\sin(2\\pi x)\\cos(\\pi y)\n$$\n将这些代入偏微分方程(PDE)得到源项：\n$$\ns(x,y) = -\\nu(\\nabla^2 u) + a_x u_x + a_y u_y\n$$\n$$\ns(x,y) = 5\\pi^2 \\nu \\sin(2\\pi x)\\cos(\\pi y) + a_x (2\\pi \\cos(2\\pi x)\\cos(\\pi y) + y) + a_y (-\\pi \\sin(2\\pi x)\\sin(\\pi y) + x)\n$$\n边界条件定义在分段 $\\partial \\Omega = \\Gamma_D \\cup \\Gamma_N \\cup \\Gamma_R$ 上。这些条件的数据由人工解导出。\n1.  **狄利克雷边界 ($\\Gamma_D$：左边界 $x=0$，上边界 $y=1$)**：条件为 $u=g$。\n    $$\n    g(x,y) = u(x,y) = \\sin(2\\pi x)\\cos(\\pi y) + xy\n    $$\n2.  **诺伊曼边界 ($\\Gamma_N$：下边界 $y=0$)**：条件为 $\\nabla u \\cdot \\mathbf{n} = h$。外法向量为 $\\mathbf{n}=(0,-1)$，因此 $\\nabla u \\cdot \\mathbf{n} = -u_y$。\n    $$\n    h(x,0) = -u_y(x,0) = -(-\\pi \\sin(2\\pi x)\\sin(0) + x) = -x\n    $$\n3.  **罗宾边界 ($\\Gamma_R$：右边界 $x=1$)**：条件为 $\\alpha u + \\beta \\nabla u \\cdot \\mathbf{n} = r$。外法向量为 $\\mathbf{n}=(1,0)$，因此 $\\nabla u \\cdot \\mathbf{n} = u_x$。\n    $$\n    r(1,y) = \\alpha u(1,y) + \\beta u_x(1,y)\n    $$\n    由于 $u(1,y) = \\sin(2\\pi)\\cos(\\pi y) + y = y$ 且 $u_x(1,y) = 2\\pi \\cos(2\\pi)\\cos(\\pi y) + y = 2\\pi\\cos(\\pi y) + y$，我们得到：\n    $$\n    r(1,y) = \\alpha y + \\beta(2\\pi\\cos(\\pi y) + y) = (\\alpha + \\beta)y + 2\\pi\\beta\\cos(\\pi y)\n    $$\n\n### 离散化与线性系统组装\n\n我们使用以节点为中心的网格，在 $x$ 方向有 $N_x+1$ 个点，在 $y$ 方向有 $N_y+1$ 个点。网格点为 $(x_i, y_j) = (i\\Delta x, j\\Delta y)$，其中 $i=0,\\dots,N_x$，$j=0,\\dots,N_y$，$\\Delta x = 1/N_x$，$\\Delta y = 1/N_y$。在这些点上的数值解记为 $u_{i,j}$。\n\n这组未知量被排列成一个大小为 $(N_x+1)(N_y+1)$ 的单列向量 $\\mathbf{U}$，使用从二维索引 $(i,j)$ 到一维索引 $k$ 的行主序映射：$k = j(N_x+1) + i$。离散化后得到一个稀疏线性方程组 $A\\mathbf{U} = \\mathbf{b}$，其中 $A$ 是一个大小为 $((N_x+1)(N_y+1)) \\times ((N_x+1)(N_y+1))$ 的方阵。我们通过为每个网格点 $(i,j)$ 定义一个方程来组装这个系统。\n\n**内部节点 ($1 \\le i \\le N_x-1, 1 \\le j \\le N_y-1$)**：\nPDE 使用二阶中心差分进行离散化：\n$$\n- \\nu \\left( \\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{\\Delta x^2} + \\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{\\Delta y^2} \\right) + a_x \\frac{u_{i+1,j} - u_{i-1,j}}{2\\Delta x} + a_y \\frac{u_{i,j+1} - u_{i,j-1}}{2\\Delta y} = s(x_i,y_j)\n$$\n重新整理各项，得到一个定义矩阵 $A$ 中一行的 5 点格式方程：\n$$\n\\left(\\frac{2\\nu}{\\Delta x^2} + \\frac{2\\nu}{\\Delta y^2}\\right) u_{i,j} + \\left(-\\frac{\\nu}{\\Delta x^2} - \\frac{a_x}{2\\Delta x}\\right)u_{i-1,j} + \\left(-\\frac{\\nu}{\\Delta x^2} + \\frac{a_x}{2\\Delta x}\\right)u_{i+1,j} + \\left(-\\frac{\\nu}{\\Delta y^2} - \\frac{a_y}{2\\Delta y}\\right)u_{i,j-1} + \\left(-\\frac{\\nu}{\\Delta y^2} + \\frac{a_y}{2\\Delta y}\\right)u_{i,j+1} = s(x_i,y_j)\n$$\n\n**边界与角点节点**：\n边界和角点节点的方程由指定的边界条件和角点优先级规则 $\\Gamma_D \\succ \\Gamma_R \\succ \\Gamma_N$ 决定。\n\n- **左边界 ($i=0, \\Gamma_D$) 和上边界 ($j=N_y, \\Gamma_D$)**：狄利克雷条件 $u=g$。\n  对于 $i=0, 0 \\le j \\le N_y$：$u_{0,j} = g(0,y_j)$。\n  对于 $j=N_y, 1 \\le i \\le N_x$：$u_{i,N_y} = g(x_i,1)$。\n  这些是简单的恒等方程，例如，$1 \\cdot u_{0,j} = g(0,y_j)$，构成对角线上只有一个 1 的行。\n\n- **下边界 ($j=0, 1 \\le i \\le N_x-1, \\Gamma_N$)**：诺伊曼条件。二阶单边格式为 $\\nabla u \\cdot \\mathbf{n} = -u_y=h$，其离散形式为：\n  $$\n  -\\frac{-3u_{i,0} + 4u_{i,1} - u_{i,2}}{2\\Delta y} = h(x_i,0) \\implies 3u_{i,0} - 4u_{i,1} + u_{i,2} = 2\\Delta y \\cdot h(x_i,0)\n  $$\n\n- **右边界 ($i=N_x, 1 \\le j \\le N_y-1, \\Gamma_R$)**：罗宾条件。$\\alpha u + \\beta u_x = r$ 的二阶单边格式为：\n  $$\n  \\alpha u_{N_x,j} + \\beta \\frac{3u_{N_x,j} - 4u_{N_x-1,j} + u_{N_x-2,j}}{2\\Delta x} = r(1,y_j)\n  $$\n  这可以重新整理为一个涉及 $u_{N_x,j}, u_{N_x-1,j}, u_{N_x-2,j}$ 的线性方程。\n\n- **角点节点**：\n  - **$(0,0)$ (左下角)**：$\\Gamma_D$ 与 $\\Gamma_N$ 交汇。优先级为 $\\Gamma_D$。方程为狄利克雷条件：$u_{0,0} = g(0,0)$。\n  - **$(N_x,0)$ (右下角)**：$\\Gamma_R$ 与 $\\Gamma_N$ 交汇。优先级为 $\\Gamma_R$。方程为在 $(i=N_x, j=0)$ 处计算的罗宾格式：\n    $$\n    \\alpha u_{N_x,0} + \\beta \\frac{3u_{N_x,0} - 4u_{N_x-1,0} + u_{N_x-2,0}}{2\\Delta x} = r(1,0)\n    $$\n  - **$(N_x,N_y)$ (右上角)**：$\\Gamma_R$ 与 $\\Gamma_D$ 交汇。优先级为 $\\Gamma_D$。方程为狄利克雷条件：$u_{N_x,N_y} = g(1,1)$。\n  - **$(0,N_y)$ (左上角)**：$\\Gamma_D$ 与 $\\Gamma_D$ 交汇。方程为狄利克雷条件：$u_{0,N_y} = g(0,1)$。\n\n通过系统地对每个网格点应用这些规则，就形成了一个完整的方形线性系统 $A\\mathbf{U} = \\mathbf{b}$。该系统使用稀疏线性求解器求解。\n\n### 误差分析\n\n数值解 $u_{i,j}^{\\text{num}}$ 的精度通过在内部网格节点（$1 \\le i \\le N_x-1, 1 \\le j \\le N_y-1$）上与精确的人工解 $u(x_i,y_j)$ 进行比较来评估。误差 $e_{i,j} = u_{i,j}^{\\text{num}} - u(x_i,y_j)$ 使用两种离散范数进行量化：\n\n- **$L^2$-范数**：\n  $$\n  \\|e\\|_{L^2_h} = \\left( \\sum_{i=1}^{N_x-1} \\sum_{j=1}^{N_y-1} |e_{i,j}|^2 \\,\\Delta x \\Delta y \\right)^{1/2}\n  $$\n- **$L^\\infty$-范数**：\n  $$\n  \\|e\\|_{L^\\infty_h} = \\max_{1 \\le i \\le N_x-1,\\;1 \\le j \\le N_y-1} |e_{i,j}|\n  $$\n\n收敛率 $p$ 是通过网格加密研究计算的。对于一个误差 $E \\propto (\\Delta x)^p$ 的方法，比较来自两个网格（一个间距为 $h$，一个间距为 $h/2$）的误差，可以得到 $p=\\log_2(E_h / E_{h/2})$。\n\n所提供的 Python 代码实现了这整个过程，以解决指定的测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef u_exact(x, y):\n    \"\"\"Manufactured solution u(x,y).\"\"\"\n    return np.sin(2 * np.pi * x) * np.cos(np.pi * y) + x * y\n\ndef s_func(x, y, nu, ax, ay):\n    \"\"\"Source term s(x,y) derived from the manufactured solution.\"\"\"\n    term1 = 5 * np.pi**2 * nu * np.sin(2 * np.pi * x) * np.cos(np.pi * y)\n    term2 = ax * (2 * np.pi * np.cos(2 * np.pi * x) * np.cos(np.pi * y) + y)\n    term3 = ay * (-np.pi * np.sin(2 * np.pi * x) * np.sin(np.pi * y) + x)\n    return term1 + term2 + term3\n\ndef h_func_bottom(x):\n    \"\"\"Neumann boundary data h(x,0) on the bottom edge.\"\"\"\n    return -x\n\ndef r_func_right(y, alpha, beta):\n    \"\"\"Robin boundary data r(1,y) on the right edge.\"\"\"\n    return (alpha + beta) * y + 2 * np.pi * beta * np.cos(np.pi * y)\n\ndef run_simulation(Nx, Ny, nu, ax, ay, alpha, beta):\n    \"\"\"\n    Assembles and solves the linear system for the 2D advection-diffusion\n    equation with mixed boundary conditions.\n    \"\"\"\n    dx = 1.0 / Nx\n    dy = 1.0 / Ny\n    num_points = (Nx + 1) * (Ny + 1)\n\n    x = np.linspace(0, 1, Nx + 1)\n    y = np.linspace(0, 1, Ny + 1)\n\n    A = lil_matrix((num_points, num_points), dtype=np.float64)\n    b = np.zeros(num_points, dtype=np.float64)\n\n    for j in range(Ny + 1):\n        for i in range(Nx + 1):\n            k = j * (Nx + 1) + i\n\n            # Boundary conditions have priority. Corner logic is embedded.\n            # Priority: Dirichlet > Robin > Neumann\n\n            # Left boundary (Dirichlet, i=0)\n            if i == 0:\n                A[k, k] = 1.0\n                b[k] = u_exact(x[i], y[j])\n                continue\n\n            # Top boundary (Dirichlet, j=Ny)\n            if j == Ny:\n                A[k, k] = 1.0\n                b[k] = u_exact(x[i], y[j])\n                continue\n\n            # Corner (Nx, 0) needs Robin, handled before general Neumann for j=0\n            if i == Nx and j == 0:\n                k_m1 = k - 1\n                k_m2 = k - 2\n                A[k, k]   = alpha + beta * 3.0 / (2.0 * dx)\n                A[k, k_m1] = -beta * 4.0 / (2.0 * dx)\n                A[k, k_m2] = beta * 1.0 / (2.0 * dx)\n                b[k] = r_func_right(y[j], alpha, beta)\n                continue\n\n            # Right boundary (Robin, i=Nx)\n            if i == Nx:\n                k_m1 = k - 1\n                k_m2 = k - 2\n                A[k, k] = alpha + beta * 3.0 / (2.0 * dx)\n                A[k, k_m1] = -beta * 4.0 / (2.0 * dx)\n                A[k, k_m2] = beta * 1.0 / (2.0 * dx)\n                b[k] = r_func_right(y[j], alpha, beta)\n                continue\n            \n            # Bottom boundary (Neumann, j=0)\n            if j == 0:\n                k_p1_y = (j + 1) * (Nx + 1) + i\n                k_p2_y = (j + 2) * (Nx + 1) + i\n                # Stencil for -u_y = h is -(-3u_0 + 4u_1 - u_2)/(2dy) = h\n                # => (3u_0 - 4u_1 + u_2)/(2dy) = h\n                A[k, k] = 3.0 / (2.0 * dy)\n                A[k, k_p1_y] = -4.0 / (2.0 * dy)\n                A[k, k_p2_y] = 1.0 / (2.0 * dy)\n                b[k] = h_func_bottom(x[i])\n                continue\n\n            # Interior nodes\n            k_p1_x = k + 1\n            k_m1_x = k - 1\n            k_p1_y = (j + 1) * (Nx + 1) + i\n            k_m1_y = (j - 1) * (Nx + 1) + i\n            \n            A[k, k]      = 2.0 * nu / dx**2 + 2.0 * nu / dy**2\n            A[k, k_p1_x] = -nu / dx**2 + ax / (2.0 * dx)\n            A[k, k_m1_x] = -nu / dx**2 - ax / (2.0 * dx)\n            A[k, k_p1_y] = -nu / dy**2 + ay / (2.0 * dy)\n            A[k, k_m1_y] = -nu / dy**2 - ay / (2.0 * dy)\n            b[k] = s_func(x[i], y[j], nu, ax, ay)\n\n    A_csr = A.tocsr()\n    u_vec = spsolve(A_csr, b)\n    u_num = u_vec.reshape((Ny + 1, Nx + 1))\n    \n    # Calculate error norms on interior nodes\n    u_exact_grid = np.zeros_like(u_num)\n    for j in range(Ny + 1):\n        for i in range(Nx + 1):\n            u_exact_grid[j, i] = u_exact(x[i], y[j])\n            \n    error_grid = u_num - u_exact_grid\n    \n    # Interior points: 1 = i = Nx-1, 1 = j = Ny-1\n    interior_errors = error_grid[1:Ny, 1:Nx]\n    \n    l2_norm = np.sqrt(np.sum(interior_errors**2) * dx * dy)\n    linf_norm = np.max(np.abs(interior_errors))\n    \n    return l2_norm, linf_norm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    results = []\n\n    # Test 1\n    nu_1, ax_1, ay_1 = 0.07, 1.2, -0.8\n    alpha_1, beta_1 = 2.0, 1.0\n    Nx1, Ny1 = 32, 32\n    l2_norm_1, _ = run_simulation(Nx1, Ny1, nu_1, ax_1, ay_1, alpha_1, beta_1)\n    results.append(l2_norm_1)\n\n    # Test 2\n    nu_2, ax_2, ay_2 = 0.07, 1.2, -0.8\n    alpha_2, beta_2 = 2.0, 1.0\n    \n    # N=16\n    l2_norm_16, _ = run_simulation(16, 16, nu_2, ax_2, ay_2, alpha_2, beta_2)\n    # N=32\n    l2_norm_32, _ = run_simulation(32, 32, nu_2, ax_2, ay_2, alpha_2, beta_2)\n    \n    # Check for non-positive norms to avoid log errors\n    if l2_norm_16 > 0 and l2_norm_32 > 0:\n        order_p = np.log2(l2_norm_16 / l2_norm_32)\n    else:\n        order_p = 0.0 # Or some indicator of an issue\n    results.append(order_p)\n\n    # Test 3\n    nu_3, ax_3, ay_3 = 0.10, 1.6, 0.4\n    alpha_3, beta_3 = 0.5, 2.0\n    Nx3, Ny3 = 36, 36\n    _, linf_norm_3 = run_simulation(Nx3, Ny3, nu_3, ax_3, ay_3, alpha_3, beta_3)\n    results.append(linf_norm_3)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3333213"}]}