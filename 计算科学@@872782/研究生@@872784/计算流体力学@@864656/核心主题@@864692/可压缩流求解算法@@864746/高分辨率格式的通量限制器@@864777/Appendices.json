{"hands_on_practices": [{"introduction": "高阶数值格式虽然精度高，但在模拟强激波或接触间断时，有时会产生非物理结果，例如负密度或负压力。一种稳健的解决方法是通过将高阶通量与一个能保证正性的低阶通量进行混合，来构建保正格式。在本练习中 [@problem_id:3320306]，你将推导确保可压缩欧拉方程的密度和压力物理正性所需的精确混合系数。", "problem": "考虑守恒变量为 $U = (\\rho, m, E)^{\\top}$ 的一维可压缩欧拉方程，其中 $\\rho$ 是密度，$m = \\rho u$ 是动量（$u$ 为速度），$E$ 是总能量。压力 $p$ 由理想气体关系式 $p = (\\gamma - 1)\\left(E - \\frac{m^{2}}{2 \\rho}\\right)$ 给出，其中比热比 $\\gamma  1$。在间距为 $\\Delta x$ 的均匀网格上的有限体积离散通过以下形式的通量更新进行时间推进，时间步长为 $\\Delta t$：\n$$\nU_{i}^{n+1} \\;=\\; U_{i}^{n} \\;-\\; \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}\\right),\n$$\n其中 $F_{i\\pm\\frac{1}{2}}$ 是网格单元界面上的数值通量。为了构造一个针对密度和压力的保正性高分辨率更新格式，考虑一个凸通量限制器，它将高阶通量与低阶通量混合如下：\n$$\nF_{i\\pm\\frac{1}{2}}(\\theta) \\;=\\; \\theta\\,F_{i\\pm\\frac{1}{2}}^{\\mathrm{HO}} \\;+\\; (1-\\theta)\\,F_{i\\pm\\frac{1}{2}}^{\\mathrm{LO}},\n$$\n其中系数 $\\theta \\in [0,1]$。令净通量差表示为：\n$$\n\\Delta F^{\\mathrm{HO}} \\;=\\; F_{i+\\frac{1}{2}}^{\\mathrm{HO}} - F_{i-\\frac{1}{2}}^{\\mathrm{HO}}, \\qquad\n\\Delta F^{\\mathrm{LO}} \\;=\\; F_{i+\\frac{1}{2}}^{\\mathrm{LO}} - F_{i-\\frac{1}{2}}^{\\mathrm{LO}},\n$$\n这样，单元 $i$ 中的更新可以写为：\n$$\nU_{i}^{n+1}(\\theta) \\;=\\; U_{i}^{n} \\;-\\; \\lambda\\left(\\theta\\,\\Delta F^{\\mathrm{HO}} + (1-\\theta)\\,\\Delta F^{\\mathrm{LO}}\\right),\n\\qquad \\lambda \\;=\\; \\frac{\\Delta t}{\\Delta x}.\n$$\n假设 $\\gamma = 1.4$，$\\lambda = 0.1$，且初始状态为\n$$\nU_{i}^{n} \\;=\\; \\begin{pmatrix} \\rho_{i}^{n} \\\\ m_{i}^{n} \\\\ E_{i}^{n} \\end{pmatrix}\n\\;=\\; \\begin{pmatrix} 1.0 \\\\ 2.0 \\\\ 4.5 \\end{pmatrix}.\n$$\n假设高阶净通量差和低阶净通量差分别为\n$$\n\\Delta F^{\\mathrm{HO}} \\;=\\; \\begin{pmatrix} 0.8 \\\\ -3.0 \\\\ 18.0 \\end{pmatrix},\n\\qquad\n\\Delta F^{\\mathrm{LO}} \\;=\\; \\begin{pmatrix} 0.1 \\\\ 0.0 \\\\ 0.5 \\end{pmatrix},\n$$\n并进一步假设低阶通量是保证正性的，即当 $\\theta = 0$ 时，更新得到的密度和压力是非负的。从控制更新式和压力的定义出发，推导为保证 $\\rho_{i}^{n+1}(\\theta) \\ge 0$ 和 $p_{i}^{n+1}(\\theta) \\ge 0$ 所需的关于 $\\theta$ 的代数条件。然后，对于给定的数据，计算在 $[0,1]$ 范围内满足这两个条件的最大允许值 $\\theta$。将你的最终答案表示为一个四舍五入到四位有效数字的实数。答案是无量纲的，因此不需要单位。", "solution": "该问题要求找到最大的混合系数 $\\theta \\in [0,1]$，以确保更新后的密度 $\\rho_{i}^{n+1}$ 和压力 $p_{i}^{n+1}$ 是非负的。\n\n守恒变量矢量 $U_{i}^{n+1} = (\\rho_{i}^{n+1}, m_{i}^{n+1}, E_{i}^{n+1})^{\\top}$ 的更新公式如下：\n$$\nU_{i}^{n+1}(\\theta) = U_{i}^{n} - \\lambda\\left(\\theta\\,\\Delta F^{\\mathrm{HO}} + (1-\\theta)\\,\\Delta F^{\\mathrm{LO}}\\right)\n$$\n其中 $\\lambda = \\frac{\\Delta t}{\\Delta x}$。我们可以通过分离出低阶部分来重写这个方程：\n$$\nU_{i}^{n+1}(\\theta) = U_{i}^{n} - \\lambda\\Delta F^{\\mathrm{LO}} - \\theta\\lambda(\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}})\n$$\n令 $U_{i}^{\\mathrm{LO}} = U_{i}^{n} - \\lambda\\Delta F^{\\mathrm{LO}}$ 为仅使用低阶通量更新的状态。问题陈述中提到这个更新是保正的，意味着 $\\rho_{i}^{\\mathrm{LO}} \\ge 0$ 和 $p_{i}^{\\mathrm{LO}} \\ge 0$。令 $P = \\lambda(\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}})$。则更新可以简洁地写为：\n$$\nU_{i}^{n+1}(\\theta) = U_{i}^{\\mathrm{LO}} - \\theta P\n$$\n将其写为分量形式：\n$$\n\\rho_{i}^{n+1}(\\theta) = \\rho_{i}^{\\mathrm{LO}} - \\theta P_{\\rho} \\\\\nm_{i}^{n+1}(\\theta) = m_{i}^{\\mathrm{LO}} - \\theta P_{m} \\\\\nE_{i}^{n+1}(\\theta) = E_{i}^{\\mathrm{LO}} - \\theta P_{E}\n$$\n其中 $P = (P_\\rho, P_m, P_E)^\\top$。\n\n首先，我们推导密度为正的代数条件，$\\rho_{i}^{n+1}(\\theta) \\ge 0$：\n$$\n\\rho_{i}^{\\mathrm{LO}} - \\theta P_{\\rho} \\ge 0\n$$\n这是一个关于 $\\theta$ 的线性不等式。\n\n其次，我们推导压力为正的条件，$p_{i}^{n+1}(\\theta) \\ge 0$。压力由 $p = (\\gamma - 1)(E - \\frac{m^2}{2\\rho})$ 给出。由于 $\\gamma  1$，条件 $p \\ge 0$ 等价于其括号内的项为非负：\n$$\nE_{i}^{n+1}(\\theta) - \\frac{(m_{i}^{n+1}(\\theta))^2}{2\\rho_{i}^{n+1}(\\theta)} \\ge 0\n$$\n为避免除以可能为零的 $\\rho_{i}^{n+1}(\\theta)$，我们将不等式两边乘以 $\\rho_{i}^{n+1}(\\theta)$ 并整理。假设 $\\rho_{i}^{n+1}(\\theta) > 0$，该条件等价于：\n$$\nE_{i}^{n+1}(\\theta)\\rho_{i}^{n+1}(\\theta) - \\frac{1}{2}(m_{i}^{n+1}(\\theta))^2 \\ge 0\n$$\n代入关于 $\\theta$ 的表达式：\n$$\n(E_{i}^{\\mathrm{LO}} - \\theta P_{E})(\\rho_{i}^{\\mathrm{LO}} - \\theta P_{\\rho}) - \\frac{1}{2}(m_{i}^{\\mathrm{LO}} - \\theta P_{m})^2 \\ge 0\n$$\n这是一个关于 $\\theta$ 的二次不等式，形式为 $A\\theta^2 + B\\theta + C \\ge 0$。展开表达式得到各项系数：\n$$\nA = P_{E}P_{\\rho} - \\frac{1}{2}P_{m}^{2}\n$$\n$$\nB = m_{i}^{\\mathrm{LO}}P_{m} - (E_{i}^{\\mathrm{LO}}P_{\\rho} + \\rho_{i}^{\\mathrm{LO}}P_{E})\n$$\n$$\nC = E_{i}^{\\mathrm{LO}}\\rho_{i}^{\\mathrm{LO}} - \\frac{1}{2}(m_{i}^{\\mathrm{LO}})^2\n$$\n注意到 $C \\ge 0$，因为低阶更新是保正的。\n\n现在，我们代入给定的数值：\n$\\gamma = 1.4$，$\\lambda = 0.1$。\n$U_{i}^{n} = (1.0, 2.0, 4.5)^{\\top}$。\n$\\Delta F^{\\mathrm{HO}} = (0.8, -3.0, 18.0)^{\\top}$。\n$\\Delta F^{\\mathrm{LO}} = (0.1, 0.0, 0.5)^{\\top}$。\n\n首先，计算低阶状态 $U_{i}^{\\mathrm{LO}}$：\n$$\nU_{i}^{\\mathrm{LO}} = U_{i}^{n} - \\lambda \\Delta F^{\\mathrm{LO}} = \\begin{pmatrix} 1.0 \\\\ 2.0 \\\\ 4.5 \\end{pmatrix} - 0.1 \\begin{pmatrix} 0.1 \\\\ 0.0 \\\\ 0.5 \\end{pmatrix} = \\begin{pmatrix} 1.0 \\\\ 2.0 \\\\ 4.5 \\end{pmatrix} - \\begin{pmatrix} 0.01 \\\\ 0.0 \\\\ 0.05 \\end{pmatrix} = \\begin{pmatrix} 0.99 \\\\ 2.0 \\\\ 4.45 \\end{pmatrix}\n$$\n所以，$\\rho_{i}^{\\mathrm{LO}} = 0.99$，$m_{i}^{\\mathrm{LO}} = 2.0$，$E_{i}^{\\mathrm{LO}} = 4.45$。\n\n接下来，计算矢量 $P$：\n$$\n\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}} = \\begin{pmatrix} 0.8 \\\\ -3.0 \\\\ 18.0 \\end{pmatrix} - \\begin{pmatrix} 0.1 \\\\ 0.0 \\\\ 0.5 \\end{pmatrix} = \\begin{pmatrix} 0.7 \\\\ -3.0 \\\\ 17.5 \\end{pmatrix}\n$$\n$$\nP = \\lambda(\\Delta F^{\\mathrm{HO}} - \\Delta F^{\\mathrm{LO}}) = 0.1 \\begin{pmatrix} 0.7 \\\\ -3.0 \\\\ 17.5 \\end{pmatrix} = \\begin{pmatrix} 0.07 \\\\ -0.3 \\\\ 1.75 \\end{pmatrix}\n$$\n所以，$P_{\\rho} = 0.07$，$P_{m} = -0.3$，$P_{E} = 1.75$。\n\n计算密度条件：\n$$\n0.99 - \\theta(0.07) \\ge 0 \\implies 0.99 \\ge 0.07\\theta \\implies \\theta \\le \\frac{0.99}{0.07} = \\frac{99}{7} \\approx 14.14\n$$\n对于任何 $\\theta \\in [0,1]$，这个条件都满足。\n\n通过计算系数 $A$, $B$, $C$ 来评估压力条件：\n$$\nC = (4.45)(0.99) - \\frac{1}{2}(2.0)^2 = 4.4055 - 2.0 = 2.4055\n$$\n$$\nB = (2.0)(-0.3) - ((4.45)(0.07) + (0.99)(1.75)) = -0.6 - (0.3115 + 1.7325) = -0.6 - 2.044 = -2.644\n$$\n$$\nA = (1.75)(0.07) - \\frac{1}{2}(-0.3)^2 = 0.1225 - \\frac{1}{2}(0.09) = 0.1225 - 0.045 = 0.0775\n$$\n压力正性的二次不等式是：\n$$\n0.0775 \\theta^2 - 2.644 \\theta + 2.4055 \\ge 0\n$$\n为了找到此不等式成立的区域，我们使用求根公式 $\\theta = \\frac{-B \\pm \\sqrt{B^2-4AC}}{2A}$ 来求解二次方程 $0.0775 \\theta^2 - 2.644 \\theta + 2.4055 = 0$ 的根：\n$$\nB^2 - 4AC = (-2.644)^2 - 4(0.0775)(2.4055) = 6.990736 - 0.745705 = 6.245031\n$$\n$$\n\\sqrt{B^2 - 4AC} \\approx 2.499006\n$$\n根是：\n$$\n\\theta_{1,2} = \\frac{2.644 \\pm 2.499006}{2(0.0775)} = \\frac{2.644 \\pm 2.499006}{0.155}\n$$\n$$\n\\theta_1 = \\frac{2.644 - 2.499006}{0.155} = \\frac{0.144994}{0.155} \\approx 0.935445\n$$\n$$\n\\theta_2 = \\frac{2.644 + 2.499006}{0.155} = \\frac{5.143006}{0.155} \\approx 33.18068\n$$\n由于系数 $A=0.0775$ 是正数，抛物线开口向上。不等式 $A\\theta^2 + B\\theta + C \\ge 0$ 在 $\\theta \\le \\theta_1$ 或 $\\theta \\ge \\theta_2$ 时成立。因此，我们必须有：\n$$\n\\theta \\le 0.935445 \\quad \\text{或} \\quad \\theta \\ge 33.18068\n$$\n我们需要找到同时满足所有条件的最大 $\\theta$：\n1. $\\theta \\in [0,1]$ （根据限制器的定义）\n2. $\\theta \\le 14.14$ （来自密度正性条件）\n3. $\\theta \\le 0.935445$ 或 $\\theta \\ge 33.18068$ （来自压力正性条件）\n\n这些条件的交集是 $0 \\le \\theta \\le 0.935445$。\n$\\theta$ 的最大允许值是这个区间的上界，$\\theta_{max} \\approx 0.935445$。\n四舍五入到四位有效数字，结果是 $0.9354$。", "answer": "$$\\boxed{0.9354}$$", "id": "3320306"}, {"introduction": "将一维概念推广到多维并非总是直接了当，通量限制便是一个典型例子。在多维问题中，沿每个坐标轴独立地应用一维限制器可能导致严重的振荡和不准确性，特别是当流动方向与各向异性网格斜交时。本练习 [@problem_id:3320354] 将展示这一关键的失效模式，并让你实现一个考虑了流动方向的、真正的多维限制器，这是构建可靠多维求解器的关键一步。", "problem": "考虑一个标量场 $q(x,y,t)$ 的二维线性平流，其由守恒律控制\n$$\n\\partial_t q + a\\,\\partial_x q + b\\,\\partial_y q = 0,\n$$\n其中 $(a,b)$ 是一个恒定的速度矢量。在尺寸为 $\\,\\Delta x\\,$ 和 $\\,\\Delta y\\,$ 的矩形单元的均匀笛卡尔网格上，一个二阶精度的有限体积更新可以写为\n$$\nq_{i,j}^{n+1} = q_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2},j} - F_{i-\\frac{1}{2},j}\\right) - \\frac{\\Delta t}{\\Delta y}\\left(G_{i,j+\\frac{1}{2}} - G_{i,j-\\frac{1}{2}}\\right),\n$$\n带有周期性边界条件，其中 $F_{i+\\frac{1}{2},j}$ 和 $G_{i,j+\\frac{1}{2}}$ 是穿过单元面的数值通量。对于线性平流，一个迎风黎曼求解器使用 $F_{i+\\frac{1}{2},j} = a\\,q_{i+\\frac{1}{2},j}^{\\mathrm{up}}$ 和 $G_{i,j+\\frac{1}{2}} = b\\,q_{i,j+\\frac{1}{2}}^{\\mathrm{up}}$，其中 $q^{\\mathrm{up}}$ 是从迎风侧取值的、在界面上重构的标量。\n\n重构过程在每个单元内使用基于一个被限制的梯度的线性剖面。在许多多维实现中，通过沿每个坐标轴使用一维全变差递减 (TVD) 限制器，将限制分别应用于 $\\partial_x q$ 和 $\\partial_y q$ 分量。当真实梯度和特征线与网格轴线倾斜时，这种逐坐标的限制方法可能无法防止非物理行为，尤其是在长宽比 $\\Delta x/\\Delta y \\neq 1$ 的网格上。一个真正的多维限制器应该能够感知信息传播的方向，并限制沿该方向的梯度分量，而不是独立地限制 $x$ 和 $y$ 方向上的分量。\n\n任务：从上述守恒律和有限体积离散化出发，实现两种重构策略：\n- 逐坐标限制：使用应用于每个坐标轴上的向前和向后差分的一维 TVD 限制器，为 $\\partial_x q$ 和 $\\partial_y q$ 计算单独的受限斜率。\n- 方向性多维限制：使用相同的 TVD 限制器，计算沿平流方向单位矢量 $\\boldsymbol{n} = (a,b)/\\sqrt{a^2+b^2}$ 的受限斜率，然后通过将此受限方向斜率投影回 $\\boldsymbol{n}$ 来重构梯度矢量。\n\n使用一个大小为 $\\Delta t$ 的单一显式时间步，该时间步的选择需满足一个标准的稳定性约束。在周期性单位正方形域 $[0,1]\\times[0,1]$ 上，将 $q$ 初始化为一个倾斜的平面阶跃函数，\n$$\nq(x,y,0) = \\begin{cases}\n1,  \\text{if } x\\cos\\alpha + y\\sin\\alpha  s,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中 $\\alpha$ 是阶跃法线角，$s$ 是一个阈值。在周期性包裹下，一个时间步后的精确解是 $q_{\\mathrm{exact}}(x,y,\\Delta t) = q(x - a\\Delta t, y - b\\Delta t, 0)$。\n\n您必须：\n- 从基本离散化推导出受限重构，并定义您选择使用的限制器。\n- 实现两种方案并推进一个时间步。\n- 每个测试案例使用两个度量标准来量化失效和改进：\n    1. 过冲差异：逐坐标限制器的非物理有界性违背幅度减去方向性限制器的相应幅度，定义为\n       $$\n       \\Delta_{\\mathrm{over}} = \\left[\\max\\left(\\max(q_{\\mathrm{axis}} - 1), \\max(0 - q_{\\mathrm{axis}}), 0\\right)\\right] - \\left[\\max\\left(\\max(q_{\\mathrm{dir}} - 1), \\max(0 - q_{\\mathrm{dir}}), 0\\right)\\right].\n       $$\n    2. 误差比率：离散 $L^1$ 误差的比值，\n       $$\n       R_{L^1} = \\frac{\\frac{1}{N_x N_y}\\sum_{i,j}\\left|q_{i,j}^{\\mathrm{axis}} - q_{i,j}^{\\mathrm{exact}}\\right|}{\\frac{1}{N_x N_y}\\sum_{i,j}\\left|q_{i,j}^{\\mathrm{dir}} - q_{i,j}^{\\mathrm{exact}}\\right|}.\n       $$\n\n角度量必须以弧度表示。除了上述无量纲变量外，没有其他物理单位。在两个方向上都使用周期性边界条件。根据\n$$\n\\Delta t = \\mathrm{CFL}\\cdot \\min\\left( \\frac{\\Delta x}{|a|}, \\frac{\\Delta y}{|b|} \\right),\n$$\n选择 $\\Delta t$，并约定如果 $a=0$ 或 $b=0$，则在最小值计算中相应的分数被视为 $+\\infty$。\n\n测试套件：\n- 案例 $1$ (理想情况，近各向同性网格): $N_x=128$, $N_y=128$, $\\beta= \\pi/4$, $\\alpha=\\pi/4$, $s=0.5$, $\\mathrm{CFL}=0.4$, 其中 $(a,b)=(\\cos\\beta,\\sin\\beta)$。\n- 案例 $2$ (极端长宽比，斜向平流): $N_x=200$, $N_y=20$, $\\beta= \\pi/3$, $\\alpha=\\pi/3$, $s=0.5$, $\\mathrm{CFL}=0.95$, 其中 $(a,b)=(\\cos\\beta,\\sin\\beta)$。\n- 案例 $3$ (相反方向的极端长宽比): $N_x=40$, $N_y=400$, $\\beta= \\pi/6$, $\\alpha=\\pi/6$, $s=0.5$, $\\mathrm{CFL}=0.95$, 其中 $(a,b)=(\\cos\\beta,\\sin\\beta)$。\n- 案例 $4$ (边界情况，纯一维平流): $N_x=128$, $N_y=32$, $\\beta= 0$, $\\alpha=\\pi/4$, $s=0.5$, $\\mathrm{CFL}=0.8$, 其中 $(a,b)=(\\cos\\beta,\\sin\\beta)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例贡献一个双元素列表 $[\\Delta_{\\mathrm{over}}, R_{L^1}]$。例如，输出格式必须是\n$$\n\\text{[}[d_1,r_1],[d_2,r_2],[d_3,r_3],[d_4,r_4]\\text{]},\n$$\n其中每个 $d_k$ 和 $r_k$ 都以浮点数形式打印。", "solution": "该问题要求实现和比较两种用于二维线性平流方程的有限体积格式，\n$$\n\\partial_t q + \\mathbf{v} \\cdot \\nabla q = 0,\n$$\n其中 $\\mathbf{v} = (a, b)$ 是一个恒定速度矢量，$q(x,y,t)$ 是一个标量场。比较的重点是在均匀笛卡尔网格上的二阶重构步骤中使用的梯度限制策略。\n\n首先，我们建立数值框架。控制偏微分方程使用有限体积法进行离散化。对一个控制体积（单元） $\\Omega_{i,j} = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}] \\times [y_{j-\\frac{1}{2}}, y_{j+\\frac{1}{2}}]$（面积为 $|\\Omega_{i,j}| = \\Delta x \\Delta y$）进行积分，并应用散度定理，我们得到单元平均量 $q_{i,j}(t)$ 的半离散守恒律：\n$$\n\\frac{d q_{i,j}}{dt} + \\frac{1}{\\Delta x} \\left( F_{i+\\frac{1}{2},j} - F_{i-\\frac{1}{2},j} \\right) + \\frac{1}{\\Delta y} \\left( G_{i,j+\\frac{1}{2}} - G_{i,j-\\frac{1}{2}} \\right) = 0.\n$$\n这里，$F$ 和 $G$ 分别是 $x$ 和 $y$ 方向的数值通量。对于线性平流，物理通量为 $f(q) = a q$ 和 $g(q) = b q$。数值通量近似于物理通量在单元面上的积分。对于迎风格式，单元面上的通量由迎风单元中 $q$ 的值确定。例如，在单元 $(i,j)$ 和 $(i+1,j)$ 之间的界面 $x = x_{i+\\frac{1}{2}}$ 处，通量为：\n$$\nF_{i+\\frac{1}{2},j} = a^+ q_{i+\\frac{1}{2},j}^L + a^- q_{i+\\frac{1}{2},j}^R,\n$$\n其中 $a^+ = \\max(a,0)$，$a^- = \\min(a,0)$，而 $q^L$ 和 $q^R$ 分别是从左侧（单元 $i,j$）和右侧（单元 $i+1,j$）看过去，在界面上重构的 $q$ 值。\n\n为达到二阶空间精度，我们在每个单元内将 $q$ 重构为一个线性函数：\n$$\nq(x,y) = q_{i,j} + (\\partial_x q)_{i,j} (x-x_i) + (\\partial_y q)_{i,j} (y-y_j),\n$$\n其中 $(x_i, y_j)$ 是单元中心，$(\\partial_x q)_{i,j}, (\\partial_y q)_{i,j}$ 是单元 $(i,j)$ 中梯度的估计值。\n通过这种重构，界面 $x_{i+\\frac{1}{2}}$ 处的左右状态为：\n$$\nq_{i+\\frac{1}{2},j}^L = q_{i,j} + (\\partial_x q)_{i,j} \\frac{\\Delta x}{2}\n$$\n$$\nq_{i+\\frac{1}{2},j}^R = q_{i+1,j} - (\\partial_x q)_{i+1,j} \\frac{\\Delta x}{2}\n$$\n对于 $y$ 方向的界面，存在类似的表达式。\n\n为了防止在间断附近出现伪振荡（吉布斯现象），梯度分量必须被限制。这确保了重构是全变差递减 (TVD) 的。我们将使用 minmod 限制器。对于两个斜率 $s_1$ 和 $s_2$，其定义为：\n$$\n\\mathrm{minmod}(s_1, s_2) = \\begin{cases} \\min(s_1, s_2)  \\text{if } s_1, s_2  0 \\\\ \\max(s_1, s_2)  \\text{if } s_1, s_2  0 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n\n所要求的两种方案在计算受限梯度矢量 $\\nabla q_{i,j} = ((\\partial_x q)_{i,j}, (\\partial_y q)_{i,j})$ 的方式上有所不同。\n\n**1. 逐坐标限制 (`axis`)**\n这是将一维限制推广到多维的最直接方法。梯度分量沿着每个坐标轴独立地进行限制。\n我们首先计算单元 $(i,j)$ 在每个方向上的向前和向后差商：\n$$\n\\Delta_x^b q = \\frac{q_{i,j}-q_{i-1,j}}{\\Delta x}, \\quad \\Delta_x^f q = \\frac{q_{i+1,j}-q_{i,j}}{\\Delta x}\n$$\n$$\n\\Delta_y^b q = \\frac{q_{i,j}-q_{i,j-1}}{\\Delta y}, \\quad \\Delta_y^f q = \\frac{q_{i,j+1}-q_{i,j}}{\\Delta y}\n$$\n然后通过对这些差商应用 minmod 限制器来计算受限梯度分量：\n$$\n(\\partial_x q)_{i,j}^{\\mathrm{axis}} = \\mathrm{minmod}(\\Delta_x^b q, \\Delta_x^f q)\n$$\n$$\n(\\partial_y q)_{i,j}^{\\mathrm{axis}} = \\mathrm{minmod}(\\Delta_y^b q, \\Delta_y^f q)\n$$\n这种方法很简单，但当流向与网格倾斜时，可能会产生过度的耗散，因为它未能将不同坐标方向上的限制过程关联起来。\n\n**2. 方向性多维限制 (`dir`)**\n此策略旨在沿着平流方向 $\\mathbf{n} = \\mathbf{v} / \\|\\mathbf{v}\\|_2 = (n_x, n_y)$ 限制梯度。根据问题描述，我们首先使用上面计算出的向前和向后差商来构造方向导数的两个估计值：\n$$\nS_b = n_x \\Delta_x^b q + n_y \\Delta_y^b q\n$$\n$$\nS_f = n_x \\Delta_x^f q + n_y \\Delta_y^f q\n$$\n它们代表了向后和向前偏置的差分矢量在平流方向上的投影。然后我们对这些方向斜率应用 minmod 限制器：\n$$\n\\sigma_n = \\mathrm{minmod}(S_b, S_f)\n$$\n然后将这个受限的方向斜率 $\\sigma_n$ 投影回平流方向矢量 $\\mathbf{n}$，以形成最终的受限梯度矢量：\n$$\n\\nabla q_{i,j}^{\\mathrm{dir}} = \\sigma_n \\mathbf{n} = (\\sigma_n n_x, \\sigma_n n_y)\n$$\n这确保了受限梯度始终与平流速度对齐，这与逐坐标方法中受限梯度的方向可以是任意的根本不同。\n\n**时间离散化与最终算法**\n我们使用单步前向欧拉法进行时间积分。完整的更新公式是：\n$$\nq_{i,j}^{n+1} = q_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2},j}^n - F_{i-\\frac{1}{2},j}^n\\right) - \\frac{\\Delta t}{\\Delta y}\\left(G_{i,j+\\frac{1}{2}}^n - G_{i,j-\\frac{1}{2}}^n\\right),\n$$\n其中通量是使用两种限制方案之一的重构值计算的。时间步长 $\\Delta t$ 根据 CFL 条件选择以确保稳定性。初始条件通过在单元中心采样给定的阶跃函数来设置。精确解是通过平流初始条件场并应用周期性包裹得到的。周期性边界条件通过使用 `numpy.roll` 来访问邻居数据来处理。", "answer": "```python\nimport numpy as np\n\ndef minmod(s1, s2):\n    \"\"\"Vectorized minmod limiter function.\"\"\"\n    # This implementation is equivalent to the standard definition.\n    # It correctly handles arrays s1 and s2 element-wise.\n    signs = np.sign(s1) + np.sign(s2)\n    return 0.5 * signs * np.minimum(np.abs(s1), np.abs(s2))\n\ndef solve_step(q, dx, dy, dt, a, b, limiter_type):\n    \"\"\"\n    Advances the scalar field q by one time step dt.\n    \"\"\"\n    Nx, Ny = q.shape\n\n    # --- 1. Compute limited gradients ---\n    # Get neighbor values using periodic boundary conditions\n    q_im1_j = np.roll(q, 1, axis=0)\n    q_ip1_j = np.roll(q, -1, axis=0)\n    q_i_jm1 = np.roll(q, 1, axis=1)\n    q_i_jp1 = np.roll(q, -1, axis=1)\n\n    # Compute forward/backward difference quotients\n    grad_x_bwd = (q - q_im1_j) / dx\n    grad_x_fwd = (q_ip1_j - q) / dx\n    grad_y_bwd = (q - q_i_jm1) / dy\n    grad_y_fwd = (q_i_jp1 - q) / dy\n\n    if limiter_type == 'axis':\n        grad_x = minmod(grad_x_bwd, grad_x_fwd)\n        grad_y = minmod(grad_y_bwd, grad_y_fwd)\n    elif limiter_type == 'dir':\n        v_norm = np.sqrt(a**2 + b**2)\n        if v_norm == 0:\n            grad_x, grad_y = np.zeros_like(q), np.zeros_like(q)\n        else:\n            nx, ny = a / v_norm, b / v_norm\n            s_b = nx * grad_x_bwd + ny * grad_y_bwd\n            s_f = nx * grad_x_fwd + ny * grad_y_fwd\n            sigma_n = minmod(s_b, s_f)\n            grad_x = sigma_n * nx\n            grad_y = sigma_n * ny\n    else:\n        raise ValueError(\"Unknown limiter type\")\n\n    # --- 2. Reconstruct states at cell faces ---\n    # x-faces (i+1/2, j)\n    q_L_x = q + grad_x * dx / 2.0\n    q_R_x = np.roll(q, -1, axis=0) - np.roll(grad_x, -1, axis=0) * dx / 2.0\n    \n    # y-faces (i, j+1/2)\n    q_L_y = q + grad_y * dy / 2.0\n    q_R_y = np.roll(q, -1, axis=1) - np.roll(grad_y, -1, axis=1) * dy / 2.0\n\n    # --- 3. Compute upwind fluxes ---\n    # Fluxes F across x-faces\n    q_upwind_x = np.where(a > 0.0, q_L_x, q_R_x)\n    F = a * q_upwind_x\n    \n    # Fluxes G across y-faces\n    q_upwind_y = np.where(b > 0.0, q_L_y, q_R_y)\n    G = b * q_upwind_y\n\n    # --- 4. Compute flux divergence ---\n    div_F = (F - np.roll(F, 1, axis=0)) / dx\n    div_G = (G - np.roll(G, 1, axis=1)) / dy\n\n    # --- 5. Update cell averages ---\n    q_new = q - dt * (div_F + div_G)\n\n    return q_new\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute metrics.\n    \"\"\"\n    test_cases = [\n        # Case 1: Nx=128, Ny=128, beta=pi/4, alpha=pi/4, s=0.5, CFL=0.4\n        (128, 128, np.pi/4, np.pi/4, 0.5, 0.4),\n        # Case 2: Nx=200, Ny=20, beta=pi/3, alpha=pi/3, s=0.5, CFL=0.95\n        (200, 20, np.pi/3, np.pi/3, 0.5, 0.95),\n        # Case 3: Nx=40, Ny=400, beta=pi/6, alpha=pi/6, s=0.5, CFL=0.95\n        (40, 400, np.pi/6, np.pi/6, 0.5, 0.95),\n        # Case 4: Nx=128, Ny=32, beta=0, alpha=pi/4, s=0.5, CFL=0.8\n        (128, 32, 0.0, np.pi/4, 0.5, 0.8),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        Nx, Ny, beta, alpha, s, CFL = case\n        \n        # Grid setup\n        dx, dy = 1.0 / Nx, 1.0 / Ny\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        xx, yy = np.meshgrid(x_centers, y_centers, indexing='ij')\n\n        # Advection velocity\n        a, b = np.cos(beta), np.sin(beta)\n        \n        # Time step calculation\n        term_x = dx / np.abs(a) if np.abs(a) > 1e-12 else np.inf\n        term_y = dy / np.abs(b) if np.abs(b) > 1e-12 else np.inf\n        dt = CFL * min(term_x, term_y)\n\n        # Initial condition\n        q0 = np.where(xx * np.cos(alpha) + yy * np.sin(alpha) > s, 1.0, 0.0)\n\n        # Run both schemes\n        q_axis = solve_step(q0, dx, dy, dt, a, b, 'axis')\n        q_dir = solve_step(q0, dx, dy, dt, a, b, 'dir')\n\n        # Exact solution at t=dt\n        x_shifted = (xx - a * dt) % 1.0\n        y_shifted = (yy - b * dt) % 1.0\n        q_exact = np.where(x_shifted * np.cos(alpha) + y_shifted * np.sin(alpha) > s, 1.0, 0.0)\n\n        # Calculate metrics\n        # 1. Overshoot difference\n        over_axis = np.max([np.max(q_axis - 1.0), np.max(0.0 - q_axis), 0.0])\n        over_dir = np.max([np.max(q_dir - 1.0), np.max(0.0 - q_dir), 0.0])\n        delta_over = over_axis - over_dir\n\n        # 2. L1 error ratio\n        err_axis = np.sum(np.abs(q_axis - q_exact))\n        err_dir = np.sum(np.abs(q_dir - q_exact))\n        \n        # Handle cases where denominator is zero (e.g., perfect solution)\n        R_L1 = err_axis / err_dir if err_dir > 1e-15 else 1.0\n        \n        all_results.append([delta_over, R_L1])\n\n    # Format output\n    result_str = \",\".join([f\"[{d:.12f},{r:.12f}]\" for d, r in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3320354"}]}