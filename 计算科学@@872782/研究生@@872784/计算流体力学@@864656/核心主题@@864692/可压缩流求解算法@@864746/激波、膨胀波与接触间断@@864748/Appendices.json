{"hands_on_practices": [{"introduction": "准确捕捉激波、接触间断等尖锐特征是计算流体动力学（CFD）的核心挑战之一。为了在不产生非物理振荡的前提下获得高精度解，现代有限体积法广泛采用非线性自适应格式。本练习将带你亲手实现五阶加权基本无振荡（WENO）格式的核心逻辑，这是一种在现代激波捕捉方法中具有基石地位的技术。通过为包含不同流动结构（如强激波、光滑斜坡和局部极值）的单元模板计算光滑度指示因子 $\\beta_k$ 和非线性权 $\\omega_k$，你将深入理解WENO格式如何自适应地从多个候选模板中重构界面值，从而在光滑区域保持高阶精度，并在间断附近保持稳定性。[@problem_id:3361322]", "problem": "考虑一维标量守恒律 $q_t + f(q)_x = 0$ 作为可压缩欧拉方程特征场的模型，其中 $q$ 表示一个通用的守恒标量，而 $f(q)$ 是其物理通量。在空间步长为 $\\Delta x$ 的均匀网格上使用有限体积法时，主要未知量是单元上的平均值 $\\bar{q}_i$，其中单元由整数 $i$ 索引。在激波、膨胀波或接触间断附近，从单元平均值重构的逐点值必须忠实于底层的守恒律，同时避免伪振荡。一种广泛使用的方法是加权基本无振荡 (WENO) 重构，特别是五阶加权基本无振荡 (WENO) 格式。\n\n您的任务是，假设网格均匀且特征速度为正（因此左偏重构是合适的），从单元平均值 $\\bar{q}_{i-2}$、$\\bar{q}_{i-1}$、$\\bar{q}_{i}$、$\\bar{q}_{i+1}$ 和 $\\bar{q}_{i+2}$ 推导、实现和评估在界面 $x_{i+\\frac{1}{2}}$ 处左值的五阶加权基本无振荡 (WENO) 重构。该重构由三个二次候选界面值的凸组合形成，这三个候选值建立在三个三点子模板 $\\{\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_i\\}$、$\\{\\bar{q}_{i-1},\\bar{q}_i,\\bar{q}_{i+1}\\}$ 和 $\\{\\bar{q}_i,\\bar{q}_{i+1},\\bar{q}_{i+2}\\}$ 上。非线性权重基于从数据的局部变化计算出的光滑度指示子，并遵循光滑度指示子测量每个候选多项式在单元邻域上导数的 $L^2$ 范数并惩罚高频内容的基本定义。\n\n请使用以下规范：\n- 设非线性权重中的小正参数为 $\\epsilon = 10^{-6}$，幂次为 $p = 2$。\n- 使用与在光滑区域达到形式五阶精度相一致的线性权重。\n- 将给定的五个单元平均值视为重构 $x_{i+\\frac{1}{2}}$ 处左值的唯一可用数据；除了 WENO 机制外，不要引入任何额外的耗散或限制器。\n\n您必须实现一个完整的、可运行的程序，该程序为每个提供的测试用例计算：\n- 三个光滑度指示子 $\\beta_k$，其中 $k \\in \\{0,1,2\\}$。\n- 从光滑度指示子和线性权重获得的三个非线性权重 $\\omega_k$，其中 $k \\in \\{0,1,2\\}$。\n- 在界面 $x_{i+\\frac{1}{2}}$ 处重构的左值 $q_{i+\\frac{1}{2}}^{-}$。\n\n无需物理单位，因为问题是以无量纲形式提出的。不涉及角度。不涉及百分比。\n\n测试套件：\n- 案例 1（位于单元 $i$ 和 $i+1$ 之间的强激波）：$[\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_{i},\\bar{q}_{i+1},\\bar{q}_{i+2}] = [5.0,5.0,5.0,0.2,0.2]$。\n- 案例 2（光滑单调斜坡）：$[\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_{i},\\bar{q}_{i+1},\\bar{q}_{i+2}] = [0.0,0.5,1.0,1.5,2.0]$。\n- 案例 3（常数状态）：$[\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_{i},\\bar{q}_{i+1},\\bar{q}_{i+2}] = [1.0,1.0,1.0,1.0,1.0]$。\n- 案例 4（单元 $i$ 附近的局部极值）：$[\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_{i},\\bar{q}_{i+1},\\bar{q}_{i+2}] = [1.0,2.0,3.0,2.0,1.0]$。\n- 案例 5（类接触弱跳跃）：$[\\bar{q}_{i-2},\\bar{q}_{i-1},\\bar{q}_{i},\\bar{q}_{i+1},\\bar{q}_{i+2}] = [1.0,1.0,0.9,0.9,0.9]$。\n\n您的程序应生成单行输出，其中包含上述五个案例重构的界面值 $q_{i+\\frac{1}{2}}^{-}$，形式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$）。每个 $r_j$ 必须是浮点数。输出必须是确定性的，并使用指定的 $\\epsilon$ 和 $p$ 计算，无需外部输入或随机性。", "solution": "问题要求推导和实现单元界面处左状态的五阶加权基本无振荡 (WENO) 重构，记作 $q_{i+\\frac{1}{2}}^{-}$。这种重构是求解双曲守恒律（例如一维标量守恒律 $q_t + f(q)_x = 0$）的高分辨率有限体积格式的基本组成部分。其目标是在解的光滑区域获得高阶精确的近似，同时在激波、膨胀波或接触间断等间断处保持清晰、无振荡的剖面。该重构基于由五个连续单元平均值组成的模板：$\\{\\bar{q}_{i-2}, \\bar{q}_{i-1}, \\bar{q}_{i}, \\bar{q}_{i+1}, \\bar{q}_{i+2}\\}$。\n\nWENO 的核心思想是通过几个低阶候选近似的凸组合来构造一个高阶近似。组合权重（称为非线性权重）是根据每个候选模板上数据的局部光滑度动态计算的。这使得格式能够自适应，为跨越间断的模板分配接近零的权重，从而防止振荡，同时以特定方式组合候选模板以在光滑区域实现高阶精度。\n\n五阶 WENO 重构 $q_{i+\\frac{1}{2}}^{-}$ 是三个三阶（二次）重构 $q_{i+\\frac{1}{2}}^{(k)}$（其中 $k \\in \\{0, 1, 2\\}$）的凸组合：\n$$\nq_{i+\\frac{1}{2}}^{-} = \\sum_{k=0}^{2} \\omega_k q_{i+\\frac{1}{2}}^{(k)}\n$$\n此处，$\\omega_k$ 是非线性权重。每个候选重构 $q_{i+\\frac{1}{2}}^{(k)}$ 都基于从主 5 点模板中选择的唯一一个 3 点子模板。为了重构界面 $x_{i+\\frac{1}{2}}$ 处的左状态，选择的子模板向左偏置：\n-   $S_0 = \\{\\bar{q}_{i-2}, \\bar{q}_{i-1}, \\bar{q}_i\\}$\n-   $S_1 = \\{\\bar{q}_{i-1}, \\bar{q}_i, \\bar{q}_{i+1}\\}$\n-   $S_2 = \\{\\bar{q}_i, \\bar{q}_{i+1}, \\bar{q}_{i+2}\\}$\n\n候选重构 $q_{i+\\frac{1}{2}}^{(k)}$ 是在每个子模板上定义的二次多项式在界面 $x_{i+\\frac{1}{2}}$ 处的值。这些重构的标准公式源自于保持单元平均值的原理，如下所示：\n$$\n\\begin{aligned}\nq_{i+\\frac{1}{2}}^{(0)} = \\frac{2}{6}\\bar{q}_{i-2} - \\frac{7}{6}\\bar{q}_{i-1} + \\frac{11}{6}\\bar{q}_{i} \\\\\nq_{i+\\frac{1}{2}}^{(1)} = -\\frac{1}{6}\\bar{q}_{i-1} + \\frac{5}{6}\\bar{q}_{i} + \\frac{2}{6}\\bar{q}_{i+1} \\\\\nq_{i+\\frac{1}{2}}^{(2)} = \\frac{2}{6}\\bar{q}_{i} + \\frac{5}{6}\\bar{q}_{i+1} - \\frac{1}{6}\\bar{q}_{i+2}\n\\end{aligned}\n$$\n\n在流场的光滑区域，为了达到五阶精度，非线性权重 $\\omega_k$ 必须逼近一组特定的常数值，即线性权重 $d_k$。候选重构与这些线性权重的组合构成了五阶迎风线性格式。对于所选的左偏模板，这些线性权重为：\n$$\nd_0 = \\frac{1}{10}, \\quad d_1 = \\frac{6}{10}, \\quad d_2 = \\frac{3}{10}\n$$\n验证可知，$\\sum_{k=0}^2 d_k = \\frac{1}{10} + \\frac{6}{10} + \\frac{3}{10} = 1$。当使用这些权重时，得到的重构为 $\\sum_{k=0}^2 d_k q_{i+\\frac{1}{2}}^{(k)} = \\frac{1}{60}(2\\bar{q}_{i-2} - 13\\bar{q}_{i-1} + 47\\bar{q}_{i} + 27\\bar{q}_{i+1} - 3\\bar{q}_{i+2})$，这是标准的五阶线性重构公式。\n\n从线性权重到非线性权重的转换是通过光滑度指示子 $\\beta_k$ 实现的。这些指示子衡量解在每个子模板 $S_k$ 上的粗糙度。它们被定义为重构多项式在一个代表性区间上导数的平方 $L^2$-范数的缩放和。对于三个子模板 $S_0, S_1, S_2$，标准的 Jiang-Shu 光滑度指示子为：\n$$\n\\begin{aligned}\n\\beta_0 = \\frac{13}{12}(\\bar{q}_{i-2} - 2\\bar{q}_{i-1} + \\bar{q}_i)^2 + \\frac{1}{4}(\\bar{q}_{i-2} - 4\\bar{q}_{i-1} + 3\\bar{q}_i)^2 \\\\\n\\beta_1 = \\frac{13}{12}(\\bar{q}_{i-1} - 2\\bar{q}_i + \\bar{q}_{i+1})^2 + \\frac{1}{4}(\\bar{q}_{i-1} - \\bar{q}_{i+1})^2 \\\\\n\\beta_2 = \\frac{13}{12}(\\bar{q}_i - 2\\bar{q}_{i+1} + \\bar{q}_{i+2})^2 + \\frac{1}{4}(3\\bar{q}_i - 4\\bar{q}_{i+1} + \\bar{q}_{i+2})^2\n\\end{aligned}\n$$\n$\\beta_k$ 的值小表示函数在模板 $S_k$ 上是光滑的，而值大则表示存在强梯度或间断。\n\n非线性权重 $\\omega_k$ 是由光滑度指示子 $\\beta_k$ 和线性权重 $d_k$ 计算得出的。首先，计算未归一化的权重 $\\alpha_k$：\n$$\n\\alpha_k = \\frac{d_k}{(\\epsilon + \\beta_k)^p}, \\quad k \\in \\{0, 1, 2\\}\n$$\n此处，$\\epsilon$ 是一个小的正数，用于避免当模板完全光滑（$\\beta_k=0$）时出现除以零的情况，而 $p$ 是一个正整数幂，通常设为 2。问题指定 $\\epsilon = 10^{-6}$ 且 $p=2$。\n\n最后，通过对 $\\alpha_k$ 进行归一化来获得非线性权重 $\\omega_k$：\n$$\n\\omega_k = \\frac{\\alpha_k}{\\sum_{j=0}^{2} \\alpha_j}\n$$\n根据构造，$\\sum_{k=0}^{2} \\omega_k = 1$。如果一个模板 $S_k$ 跨越了一个间断，其对应的 $\\beta_k$ 会很大，从而使得 $\\alpha_k$ 以及 $\\omega_k$ 很小。这有效地移除了来自该模板的振荡贡献。在光滑区域，所有的 $\\beta_k$ 都很小且量级相似，这使得非线性权重 $\\omega_k$ 逼近线性权重 $d_k$，从而恢复五阶精度。这种自适应过程确保了高精度和无振荡行为，这是 WENO 方法的标志。\n\n计算 $q_{i+\\frac{1}{2}}^{-}$ 的完整算法如下：\n1.  给定五个单元平均值 $\\bar{q}_{i-2}, \\bar{q}_{i-1}, \\bar{q}_{i}, \\bar{q}_{i+1}, \\bar{q}_{i+2}$。\n2.  计算三个光滑度指示子 $\\beta_0, \\beta_1, \\beta_2$。\n3.  使用线性权重 $d_0=0.1, d_1=0.6, d_2=0.3$ 和参数 $\\epsilon=10^{-6}, p=2$ 计算未归一化的权重 $\\alpha_0, \\alpha_1, \\alpha_2$。\n4.  计算归一化的非线性权重 $\\omega_0, \\omega_1, \\omega_2$。\n5.  计算三个候选重构 $q_{i+\\frac{1}{2}}^{(0)}, q_{i+\\frac{1}{2}}^{(1)}, q_{i+\\frac{1}{2}}^{(2)}$。\n6.  计算最终的重构值 $q_{i+\\frac{1}{2}}^{-} = \\omega_0 q_{i+\\frac{1}{2}}^{(0)} + \\omega_1 q_{i+\\frac{1}{2}}^{(1)} + \\omega_2 q_{i+\\frac{1}{2}}^{(2)}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_weno5_reconstruction(q_stencil):\n    \"\"\"\n    Computes the 5th-order WENO reconstruction of the left state at the\n    interface i+1/2 from a 5-point stencil of cell averages.\n\n    Args:\n        q_stencil (list or np.ndarray): A list or array of 5 floating-point\n            numbers representing the cell averages [q_{i-2}, q_{i-1}, q_{i},\n            q_{i+1}, q_{i+2}].\n\n    Returns:\n        float: The reconstructed left state q_{i+1/2}^{-}.\n    \"\"\"\n    # Parameters for WENO-5\n    epsilon = 1e-6\n    p = 2\n    \n    # Linear weights for 5th order accuracy\n    d0, d1, d2 = 0.1, 0.6, 0.3\n\n    # Unpack stencil for clarity\n    q_im2, q_im1, q_i, q_ip1, q_ip2 = q_stencil\n\n    # 1. Compute smoothness indicators (beta_k)\n    # These are the standard Jiang-Shu smoothness indicators.\n    beta_0 = (13.0/12.0) * (q_im2 - 2*q_im1 + q_i)**2 + (1.0/4.0) * (q_im2 - 4*q_im1 + 3*q_i)**2\n    beta_1 = (13.0/12.0) * (q_im1 - 2*q_i + q_ip1)**2 + (1.0/4.0) * (q_im1 - q_ip1)**2\n    beta_2 = (13.0/12.0) * (q_i - 2*q_ip1 + q_ip2)**2 + (1.0/4.0) * (3*q_i - 4*q_ip1 + q_ip2)**2\n    betas = np.array([beta_0, beta_1, beta_2])\n\n    # 2. Compute nonlinear weights (omega_k)\n    alphas = np.array([d0, d1, d2]) / (epsilon + betas)**p\n    omega = alphas / np.sum(alphas)\n\n    # 3. Compute candidate reconstructions (q_k)\n    # These are the 3rd order reconstructions on each sub-stencil.\n    q_0 = (2.0/6.0)*q_im2 - (7.0/6.0)*q_im1 + (11.0/6.0)*q_i\n    q_1 = -(1.0/6.0)*q_im1 + (5.0/6.0)*q_i + (2.0/6.0)*q_ip1\n    q_2 = (2.0/6.0)*q_i + (5.0/6.0)*q_ip1 - (1.0/6.0)*q_ip2\n    qs = np.array([q_0, q_1, q_2])\n    \n    # 4. Compute the final reconstructed value\n    # This is the convex combination of the candidate reconstructions.\n    q_final = np.dot(omega, qs)\n    \n    return q_final\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: strong shock\n        [5.0, 5.0, 5.0, 0.2, 0.2],\n        # Case 2: smooth monotone ramp\n        [0.0, 0.5, 1.0, 1.5, 2.0],\n        # Case 3: constant state\n        [1.0, 1.0, 1.0, 1.0, 1.0],\n        # Case 4: local extremum\n        [1.0, 2.0, 3.0, 2.0, 1.0],\n        # Case 5: contact-like weak jump\n        [1.0, 1.0, 0.9, 0.9, 0.9],\n    ]\n\n    results = []\n    for case in test_cases:\n        q_stencil = np.array(case)\n        result = compute_weno5_reconstruction(q_stencil)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3361322"}, {"introduction": "在模拟复杂的流场时，为了提高计算效率，必须将计算资源集中在最需要的区域，例如激波和接触间断附近。本练习探讨了自适应网格加密（AMR）中加密传感器的设计，并检验其与伽利略不变性这一基本物理原理的相容性。你将通过一个包含膨胀波、接触间断和激波的合成一维欧拉方程初值问题，对比一个伽利略不变的传感器和一个非不变的传感器。通过分析它们在速度提升（伽利略变换）下的行为差异，你将更深刻地体会到数值算法的设计为何必须尊重其所模拟的物理规律，以确保其鲁棒性和可靠性。[@problem_id:3361325]", "problem": "考虑理想气体的一维 ($1$-D) 可压缩欧拉方程，其密度 $\\rho(x,t)$、动量 $\\rho(x,t) u(x,t)$ 和总能量 $E(x,t)$ 的守恒形式写作：\n$$\n\\partial_t \\rho + \\partial_x (\\rho u) = 0,\\quad\n\\partial_t (\\rho u) + \\partial_x \\left(\\rho u^2 + p\\right) = 0,\\quad\n\\partial_t E + \\partial_x \\left((E+p)u\\right) = 0,\n$$\n附带理想气体状态方程 $p = (\\gamma - 1)\\left(E - \\tfrac{1}{2}\\rho u^2\\right)$ 和声速 $a = \\sqrt{\\gamma p / \\rho}$。接触间断的特征是 $\\rho$ 发生跳跃，而 $p$ 和 $u$ 连续；激波是 $p$、$u$ 和 $\\rho$ 发生跳跃且满足 Rankine–Hugoniot 条件的间断；膨胀（稀疏）波扇则是一个连续的自相似区域，其中 $p$、$u$ 和 $\\rho$ 呈单调变化且满足等熵关系。\n\n具有恒定速度增量 $\\Delta u$ 的 Galilean 变换将 $(x,t,u,p,\\rho)$ 映射到 $(x',t',u',p',\\rho')$，通过 $x' = x - \\Delta u\\, t$, $t' = t$, $u' = u - \\Delta u$, $p' = p$ 和 $\\rho' = \\rho$。欧拉方程具有 Galilean 不变性：如果 $(\\rho,u,p)$ 是一个解，那么 $(\\rho',u',p')$ 在带撇坐标系中也是一个解。\n\n你的任务是，在一个包含相互作用的膨胀波扇、接触间断和激波的合成快照上，算法上评估两种自适应网格加密 (AMR) 加密传感器的行为，并通过将速度增加一个恒定的 $\\Delta u$ 来测试 Galilean 不变性。你将在接触间断处计算一个加密一致性度量，以量化加密决策在 Galilean 速度增量下的表现有多一致。\n\n在空间域 $x \\in [0,1]$ 上，使用 $N$ 个间距为 $\\Delta x = 1/(N-1)$ 的均匀间隔网格点，构建一个在时间 $t=0$ 的无量纲初始快照。使用以下分段光滑剖面，其中所有量均为无量纲：\n\n- 左侧状态 ($x \\le x_a$)：$\\rho = \\rho_L$, $u = u_L$, $p = p_L$。\n- 膨胀波扇 ($x \\in [x_a,x_b]$)：定义一个光滑斜坡参数 $s_r(x) = \\max\\{0,\\min\\{1,(x - x_a)/(x_b - x_a)\\}\\}$，设置 $p(x) = (1-s_r)p_L + s_r p_*$, $u(x) = (1-s_r)u_L + s_r u_*$，并使用等熵关系 $p/\\rho^\\gamma = K$ (其中 $K = p_L/\\rho_L^\\gamma$) 来设置 $\\rho(x) = \\left(p(x)/K\\right)^{1/\\gamma}$。\n- 膨胀后、接触前 ($x \\in (x_b,x_c - \\delta_c)$)：$\\rho = \\rho_1$, $u = u_*$, $p = p_*$，其中 $\\rho_1 = \\left(p_*/K\\right)^{1/\\gamma}$。\n- 以 $x_c$ 为中心、半宽为 $\\delta_c$ 的接触区域：保持 $u = u_*$ 和 $p = p_*$ 连续，但使用宽度为 $w_c$ 的双曲正切平滑，从 $\\rho_1$ 到 $\\rho_2 = f_c \\rho_1$ 施加一个平滑的密度跳跃：对于 $x \\in [x_c - \\delta_c, x_c + \\delta_c]$，$\\rho(x) = \\rho_1 + \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_c}{w_c}\\right)\\right)\\left(\\rho_2 - \\rho_1\\right)$。\n- 接触后、激波前 ($x \\in (x_c + \\delta_c, x_s - \\delta_s)$)：$\\rho = \\rho_2$, $u = u_*$, $p = p_*$。\n- 以 $x_s$ 为中心、半宽为 $\\delta_s$ 的激波区域：使用宽度为 $w_s$ 的双曲正切平滑施加平滑跳跃，以增加压力和密度并减小速度：$p(x) = p_* + \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_s}{w_s}\\right)\\right)\\left(p_3 - p_*\\right)$，$u(x) = u_* + \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_s}{w_s}\\right)\\right)\\left(u_3 - u_*\\right)$，以及 $\\rho(x) = \\rho_2 + \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_s}{w_s}\\right)\\right)\\left(\\rho_3 - \\rho_2\\right)$。\n- 激波右侧（平滑区以外的 $x \\ge x_s$）：上述平滑关系饱和到右侧状态 $(\\rho_3,u_3,p_3)$。\n\n使用参数 $N = 2048$, $\\gamma = 1.4$, $x_a = 0.25$, $x_b = 0.45$, $x_c = 0.5$, $x_s = 0.7$, $\\delta_c = 0.01$, $\\delta_s = 0.01$, $w_c = 0.002$, $w_s = 0.003$，以及基态 $\\rho_L = 1.0$, $u_L = 0.0$, $p_L = 1.0$, $p_* = 0.5$, $u_* = 0.6$, $f_c = 1.5$, $p_3 = 1.5$, $u_3 = 0.2$, $\\rho_3 = 2.0$。所有值均为无量纲。\n\n定义两种 AMR 加密传感器：\n\n- 传感器 $\\mathcal{S}_{\\mathrm{GI}}$ (Galilean 不变)：计算中心有限差分来近似 $\\partial_x p$ 和 $\\partial_x \\rho$，形成标量场\n$$\ns_{\\mathrm{GI}}(x_i) = \\frac{|\\partial_x p(x_i)|}{\\max_j |p(x_j)|} + \\frac{|\\partial_x \\rho(x_i)|}{\\max_j |\\rho(x_j)|},\n$$\n如果 $s_{\\mathrm{GI}}(x_i) \\ge \\theta \\, \\max_j s_{\\mathrm{GI}}(x_j)$ 且 $\\theta = 0.2$，则标记一个单元格 $i$。该传感器仅使用压力和密度梯度，因此在 $t = 0$ 时，对于均匀的速度增量 $u \\mapsto u + \\Delta u$ 是不变的。\n- 传感器 $\\mathcal{S}_{\\mathrm{NGI}}$ (非 Galilean 不变)：如果一个单元格被 $\\mathcal{S}_{\\mathrm{GI}}$ 标记，或者局部马赫数大小超过阈值 $M_{\\mathrm{thr}}$，则标记该单元格，即：\n$$\n\\text{flag}_{\\mathrm{NGI}}(x_i) = \\left[s_{\\mathrm{GI}}(x_i) \\ge \\theta \\, \\max_j s_{\\mathrm{GI}}(x_j)\\right] \\,\\vee\\, \\left[\\frac{|u(x_i)|}{a(x_i)} \\ge M_{\\mathrm{thr}}\\right].\n$$\n由于该传感器依赖于绝对速度大小，它不是 Galilean 不变的。\n\n为测试 Galilean 不变性，通过施加一个均匀速度增量 $\\Delta u$ 来定义 $t=0$ 时的增速后快照：$u'(x) = u(x) + \\Delta u$，其中 $p'(x) = p(x)$ 和 $\\rho'(x) = \\rho(x)$。在增速后的快照上为两种传感器重新计算标记。\n\n将接触处的加密一致性定义为原始标记与增速后标记之间的 Jaccard 指数，该指数限制在窗口 $W_c = \\{x: |x - x_c| \\le w_{\\mathrm{win}}\\}$（其中 $w_{\\mathrm{win}} = 0.02$）内，\n$$\nJ = \\frac{\\left|\\{i \\in W_c: \\text{flag}(x_i) = 1 \\wedge \\text{flag}'(x_i) = 1\\}\\right|}{\\left|\\{i \\in W_c: \\text{flag}(x_i) = 1 \\vee \\text{flag}'(x_i) = 1\\}\\right|},\n$$\n约定如果分母为零，则 $J = 1$。计算 $\\mathcal{S}_{\\mathrm{GI}}$ 的 $J_{\\mathrm{GI}}$ 和 $\\mathcal{S}_{\\mathrm{NGI}}$ 的 $J_{\\mathrm{NGI}}$。\n\n测试套件。评估以下参数集的一致性度量，其中每个测试用例是一个参数对 $(\\Delta u, M_{\\mathrm{thr}})$：\n\n- 测试 $1$: $(\\Delta u, M_{\\mathrm{thr}}) = (0.0, 0.8)$。\n- 测试 $2$: $(\\Delta u, M_{\\mathrm{thr}}) = (0.5, 0.8)$。\n- 测试 $3$: $(\\Delta u, M_{\\mathrm{thr}}) = (1.0, 0.8)$。\n- 测试 $4$ (马赫数阈值宽松的边界情况): $(\\Delta u, M_{\\mathrm{thr}}) = (0.5, 0.2)$。\n\n所有量均为无量纲。此问题不涉及角度。你的程序应将结果输出为单一行，其中包含一个按指定顺序排列的测试结果列表，每个结果是包含两个浮点数 $[J_{\\mathrm{GI}}, J_{\\mathrm{NGI}}]$ 的列表。确切格式必须是单行，用方括号括起来的逗号分隔列表，例如 $[[1.0,1.0],[1.0,0.9],[1.0,0.7],[1.0,0.5]]$（此处数字仅为示例）。最终输出必须是只有这一个带方括号列表的单行，没有额外文本。", "solution": "问题陈述是有效的。它在科学上基于气体动力学和计算方法的原理，提供了一个适定、自洽且客观的任务。所有必需的常数、方程和程序步骤都得到了明确的提供，从而可以得到唯一且可验证的解。\n\n任务是在一个合成的一维流体动力学剖面上实现和评估两种自适应网格加密 (AMR) 传感器，并测试它们在 Galilean 速度增量下的行为。问题的核心在于用数值方法验证 Galilean 不变性的概念。\n\n算法设计分几个不同的步骤进行，每个步骤都基于问题中描述的物理和数学原理。\n\n首先，我们构建气体的初始物理状态。该状态由离散一维空间域 $x \\in [0,1]$ 上的密度 $\\rho(x)$、速度 $u(x)$ 和压力 $p(x)$ 定义。此域被离散化为 $N=2048$ 个均匀间隔的网格点。根据所提供的规范，剖面是分段构建的，代表了一系列基本的流体动力学结构：一个恒定的左侧状态、一个等熵膨胀波扇、一个接触间断和一个激波。每个结构都由空间坐标 $x$ 的函数定义。为提高效率和清晰度，此构建过程使用向量化的 `numpy` 操作执行。例如，介于 $x_a=0.25$ 和 $x_b=0.45$ 之间的膨胀波扇的光滑斜坡参数 $s_r(x)$ 是使用 `numpy.clip` 实现的。接触间断和激波间断使用双曲正切函数进行平滑，例如，接触间断的密度为 $\\rho(x) = \\rho_1 + \\tfrac{1}{2}\\left(1 + \\tanh\\left(\\frac{x - x_c}{w_c}\\right)\\right)\\left(\\rho_2 - \\rho_1\\right)$，这是数值模拟中创建跳跃的可微近似的标准方法。\n\n其次，我们实现两种 AMR 加密传感器 $\\mathcal{S}_{\\mathrm{GI}}$ 和 $\\mathcal{S}_{\\mathrm{NGI}}$。\nGalilean 不变传感器 $\\mathcal{S}_{\\mathrm{GI}}$ 由标量场 $s_{\\mathrm{GI}}(x_i) = \\frac{|\\partial_x p(x_i)|}{\\max_j |p(x_j)|} + \\frac{|\\partial_x \\rho(x_i)|}{\\max_j |\\rho(x_j)|}$ 定义。空间导数 $\\partial_x p$ 和 $\\partial_x \\rho$ 使用中心有限差分进行近似。`numpy.gradient` 函数适用于此任务，因为它为内部点计算二阶精确梯度，为边界点计算一阶精确梯度。如果 $s_{\\mathrm{GI}}(x_i) \\ge \\theta \\, \\max_j s_{\\mathrm{GI}}(x_j)$，则标记网格单元 $i$ 进行加密，其中阈值为 $\\theta = 0.2$。该传感器预期是 Galilean 不变的，因为在固定时间下，压力 $p$ 和密度 $\\rho$ 本身在 Galilean 速度增量下是不变的（$p'=p$，$\\rho'=\\rho$），因此它们的空间梯度也是不变的。\n\n非 Galilean 不变传感器 $\\mathcal{S}_{\\mathrm{NGI}}$ 在单元格被 $\\mathcal{S}_{\\mathrm{GI}}$ 标记或局部马赫数大小 $M(x_i) = |u(x_i)|/a(x_i)$ 超过给定阈值 $M_{\\mathrm{thr}}$ 时标记该单元格。声速由 $a(x_i) = \\sqrt{\\gamma p(x_i) / \\rho(x_i)}$ 给出。该传感器不是 Galilean 不变的，因为根据问题指定的变换，速度变换为 $u' = u - \\Delta u$。虽然声速 $a$ 保持不变（因为 $p$ 和 $\\rho$ 不变），但马赫数变为 $M' = |u - \\Delta u|/a$，这与 $M$ 不同。因此，基于马赫数的标记决策在原始参考系和增速参考系之间可能会改变。\n\n第三，我们实现 Galilean 不变性测试。对于每个由速度增量 $\\Delta u$ 和马赫数阈值 $M_{\\mathrm{thr}}$ 定义的测试用例，我们执行以下步骤：\n$1$. 计算初始流体状态 $(\\rho, u, p)$。\n$2$. 创建增速后的状态 $(\\rho', u', p')$，其中 $\\rho'=\\rho$，$p'=p$，而 $u' = u + \\Delta u$。注意，问题陈述使用 $u' = u-\\Delta u$ 表示向移动参考系的变换，但要求通过增加一个速度来定义 $t=0$ 时的增速后快照，因此我们实现 $u_{new} = u_{old} + \\Delta u$。这是创建新初始条件的一致解释。\n$3$. 在原始状态和增速后状态上为两种传感器（$\\mathcal{S}_{\\mathrm{GI}}$、$\\mathcal{S}_{\\mathrm{NGI}}$）计算加密标记。\n$4$. 使用 Jaccard 指数 $J$ 来量化加密标记的一致性。对于每个传感器，通过比较原始状态下的标记单元格集合 $\\text{flag}(x_i)$ 和增速后状态下的集合 $\\text{flag}'(x_i)$ 来计算该度量。比较仅限于以接触间断为中心的窗口 $W_c = \\{x: |x - x_c| \\le w_{\\mathrm{win}}\\}$ 内，其中 $x_c=0.5$，$w_{\\mathrm{win}}=0.02$。Jaccard 指数 $J = |\\text{交集}|/|\\text{并集}|$，在完全一致时为 1.0。根据问题的约定，如果标记单元格的并集为空，则 $J$ 取值为 1.0。\n\n最终输出是一个列表，其中包含每个测试用例计算出的指数对 $[J_{\\mathrm{GI}}, J_{\\mathrm{NGI}}]$。根据 Galilean 不变性原理，我们预期所有测试的 $J_{\\mathrm{GI}}$ 均为 1.0，因为该传感器的定义量是不变的。相反，$J_{\\mathrm{NGI}}$ 预期会变化，仅在 $\\Delta u=0$ 或在窗口 $W_c$ 内马赫数条件在两个参考系中都满足或都不满足时才等于 1.0。对于速度增量导致马赫数越过阈值 $M_{\\mathrm{thr}}$ 的情况，$J_{\\mathrm{NGI}}$ 将小于 1.0，从而定量地证明该传感器缺乏不变性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Galilean coherence of two AMR sensors on a synthetic 1D gas dynamics profile.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (delta_u, M_thr)\n        (0.0, 0.8),\n        (0.5, 0.8),\n        (1.0, 0.8),\n        (0.5, 0.2),\n    ]\n\n    # Global parameters from the problem statement\n    N = 2048\n    gamma = 1.4\n    x_a = 0.25\n    x_b = 0.45\n    x_c = 0.5\n    x_s = 0.7\n    delta_c = 0.01\n    delta_s = 0.01\n    w_c = 0.002\n    w_s = 0.003\n    rho_L = 1.0\n    u_L = 0.0\n    p_L = 1.0\n    p_star = 0.5\n    u_star = 0.6\n    f_c = 1.5\n    p_3 = 1.5\n    u_3 = 0.2\n    rho_3 = 2.0\n    theta = 0.2\n    w_win = 0.02\n\n    # Create the spatial grid\n    x = np.linspace(0.0, 1.0, N)\n\n    def generate_profile(x_grid):\n        \"\"\"\n        Generates the 1D fluid profile (rho, u, p) based on the piecewise definitions.\n        \"\"\"\n        # Initialize arrays\n        rho = np.zeros_like(x_grid)\n        u = np.zeros_like(x_grid)\n        p = np.zeros_like(x_grid)\n\n        # Derived constants and states\n        K = p_L / (rho_L**gamma)\n        rho_1 = (p_star / K)**(1.0 / gamma)\n        rho_2 = f_c * rho_1\n\n        # Region definitions using boolean masks for clear partitioning\n        # Left state\n        cond_L = x_grid = x_a\n        rho[cond_L], u[cond_L], p[cond_L] = rho_L, u_L, p_L\n\n        # Expansion fan\n        cond_fan = (x_grid > x_a)  (x_grid = x_b)\n        s_r_fan = (x_grid[cond_fan] - x_a) / (x_b - x_a)\n        p[cond_fan] = (1.0 - s_r_fan) * p_L + s_r_fan * p_star\n        u[cond_fan] = (1.0 - s_r_fan) * u_L + s_r_fan * u_star\n        rho[cond_fan] = (p[cond_fan] / K)**(1.0 / gamma)\n\n        # Post-expansion, pre-contact\n        cond_post_fan = (x_grid > x_b)  (x_grid = x_c - delta_c)\n        rho[cond_post_fan], u[cond_post_fan], p[cond_post_fan] = rho_1, u_star, p_star\n\n        # Contact region\n        cond_contact = (x_grid > x_c - delta_c)  (x_grid = x_c + delta_c)\n        u[cond_contact], p[cond_contact] = u_star, p_star\n        tanh_c = np.tanh((x_grid[cond_contact] - x_c) / w_c)\n        rho[cond_contact] = rho_1 + 0.5 * (1.0 + tanh_c) * (rho_2 - rho_1)\n        \n        # Post-contact, pre-shock\n        cond_post_contact = (x_grid > x_c + delta_c)  (x_grid = x_s - delta_s)\n        rho[cond_post_contact], u[cond_post_contact], p[cond_post_contact] = rho_2, u_star, p_star\n\n        # Shock region\n        cond_shock = (x_grid > x_s - delta_s)  (x_grid = x_s + delta_s)\n        tanh_s = np.tanh((x_grid[cond_shock] - x_s) / w_s)\n        p[cond_shock] = p_star + 0.5 * (1.0 + tanh_s) * (p_3 - p_star)\n        u[cond_shock] = u_star + 0.5 * (1.0 + tanh_s) * (u_3 - u_star)\n        rho[cond_shock] = rho_2 + 0.5 * (1.0 + tanh_s) * (rho_3 - rho_2)\n\n        # Right state\n        cond_R = x_grid > x_s + delta_s\n        rho[cond_R], u[cond_R], p[cond_R] = rho_3, u_3, p_3\n        \n        return rho, u, p\n\n    def get_gi_flags(rho, p, x_grid, theta_val):\n        \"\"\"Computes flags for the Galilean-invariant sensor S_GI.\"\"\"\n        dp_dx = np.gradient(p, x_grid)\n        drho_dx = np.gradient(rho, x_grid)\n        \n        max_p_abs = np.max(np.abs(p))\n        max_rho_abs = np.max(np.abs(rho))\n        \n        s_gi = np.zeros_like(x_grid)\n        if max_p_abs > 1e-12:\n            s_gi += np.abs(dp_dx) / max_p_abs\n        if max_rho_abs > 1e-12:\n            s_gi += np.abs(drho_dx) / max_rho_abs\n            \n        max_s_gi = np.max(s_gi)\n        if max_s_gi  1e-12:\n            return np.zeros_like(x_grid, dtype=bool)\n            \n        return s_gi >= theta_val * max_s_gi\n\n    def get_ngi_flags(u, a, gi_flags, m_thresh):\n        \"\"\"Computes flags for the non-Galilean-invariant sensor S_NGI.\"\"\"\n        mach = np.abs(u) / a\n        mach_flags = mach >= m_thresh\n        return np.logical_or(gi_flags, mach_flags)\n\n    def calculate_jaccard_index(flags1, flags2, x_grid, center, win_half_width):\n        \"\"\"Calculates the Jaccard index between two flag arrays within a window.\"\"\"\n        window_mask = np.abs(x_grid - center) = win_half_width\n        \n        flags1_win = flags1[window_mask]\n        flags2_win = flags2[window_mask]\n        \n        intersection = np.sum(np.logical_and(flags1_win, flags2_win))\n        union = np.sum(np.logical_or(flags1_win, flags2_win))\n        \n        return 1.0 if union == 0 else float(intersection) / float(union)\n\n    results = []\n    \n    # Generate the base state once, as it's the same for all tests\n    rho_base, u_base, p_base = generate_profile(x)\n    a_base = np.sqrt(gamma * p_base / rho_base)\n\n    for delta_u, m_thr in test_cases:\n        # --- Original State Analysis ---\n        flags_gi_orig = get_gi_flags(rho_base, p_base, x, theta)\n        flags_ngi_orig = get_ngi_flags(u_base, a_base, flags_gi_orig, m_thr)\n        \n        # --- Boosted State Analysis ---\n        u_boosted = u_base + delta_u\n        p_boosted = p_base\n        rho_boosted = rho_base\n        a_boosted = a_base\n        \n        flags_gi_boosted = get_gi_flags(rho_boosted, p_boosted, x, theta)\n        flags_ngi_boosted = get_ngi_flags(u_boosted, a_boosted, flags_gi_boosted, m_thr)\n        \n        # --- Compute Coherence Metrics ---\n        J_gi = calculate_jaccard_index(flags_gi_orig, flags_gi_boosted, x, x_c, w_win)\n        J_ngi = calculate_jaccard_index(flags_ngi_orig, flags_ngi_boosted, x, x_c, w_win)\n        \n        results.append([J_gi, J_ngi])\n\n    # Format the final output string exactly as required\n    results_str = ','.join(f'[{res[0]},{res[1]}]' for res in results)\n    print(f\"[{results_str}]\")\n\nsolve()\n```", "id": "3361325"}, {"introduction": "现代CFD代码的性能在很大程度上取决于其在图形处理器（GPU）等并行硬件上的执行效率。本练习关注一个在GPU上实现流体动力学算法时常见的性能瓶颈：线程束发散（warp divergence）。当一个执行单元内的多个线程因处理不同类型的波（如激波或稀疏波）而执行不同的代码分支时，就会发生发散，导致性能下降。通过对一个包含混合波类型的黎曼问题求解器进行建模，你将分析和比较“朴素”线程分配策略与“按波形批处理”策略的性能差异，并计算改进因子、预期分支数和占用率等指标。这个练习将帮助你建立硬件感知算法设计的思维，这是高性能科学计算中的一项关键技能。[@problem_id:3361328]", "problem": "考虑比热比为 $\\gamma$ 的多方理想气体的一维欧拉方程，其守恒形式对密度 $\\rho$、动量 $\\rho u$ 和总能量 $E$ 在空间坐标 $x$ 和时间 $t$ 上表示为：\n$$\n\\frac{\\partial}{\\partial t}\n\\begin{pmatrix}\n\\rho \\\\\n\\rho u \\\\\nE\n\\end{pmatrix}\n+\n\\frac{\\partial}{\\partial x}\n\\begin{pmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu(E + p)\n\\end{pmatrix}\n= \n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n0\n\\end{pmatrix},\n\\quad\np = (\\gamma - 1)\\left(E - \\tfrac{1}{2} \\rho u^2\\right).\n$$\n黎曼问题由 $t = 0$ 时在 $x = 0$ 处的分段常数左右状态构成，其演化为一个自相似解，该解的特征是由两个非线性波（每个波是激波或稀疏波）被一个接触间断所分隔。左右非线性波的分类源于自相似解的自洽条件：星区压力 $p_\\star$ 与初始压力 $p_L$ 和 $p_R$ 的比较，决定了是出现激波（$p_\\star  p_{L}$ 或 $p_\\star  p_{R}$）还是稀疏波（$p_\\star  p_{L}$ 或 $p_\\star  p_{R}$）。接触间断在传输过程中会引起密度和内能的跳跃，但其两侧的压力和速度保持不变。\n\n在图形处理单元（GPU）上，一个线程束（warp，即单指令多线程（SIMT）组）中执行黎曼求解器的线程，会根据局部波的类型是激波、稀疏波还是仅为接触更新而进行不同分支。当同一线程束中的线程采用不同分支时，会产生线程束分化，从而迫使每个不同的分支路径被串行执行。设激波分支、稀疏波分支和接触分支的周期成本分别为 $L_S$、$L_R$ 和 $L_C$。假设周期成本对每种波类型是确定性的，并且除了分类之外不依赖于局部状态。\n\n一种有原则的批处理策略按波类型将线程分配给线程束以减少分化。相反，朴素排序则将混合的波类型任意分布在各个线程束中。为分析分化热点并量化批处理的益处，建立如下模型：\n\n- 一个核函数（kernel）启动 $N$ 个线程，这些线程被划分为大小为 $W$ 的线程束。其局部解需要激波、稀疏波或接触分支的线程数量分别为 $n_S$、$n_R$ 和 $n_C$，满足 $n_S + n_R + n_C = N$。\n- 在朴素排序中，假设线程被随机排列，然后分成多个线程束。对于从 $N$ 个线程中无放回均匀采样得到的大小为 $w$ 的线程束，该线程束包含至少一个波类型为 $T \\in \\{S, R, C\\}$ 的线程的概率，等于1减去所有 $w$ 个线程都属于大小为 $N - n_T$ 的补集的概率。因此，在大小为 $w$ 的线程束中，类型 $T$ 的缺失概率为\n$$\n\\mathbb{P}\\{\\text{no }T\\text{ in warp}\\}\n=\n\\frac{\\binom{N - n_T}{w}}{\\binom{N}{w}}\n\\quad \\text{for } w \\le N - n_T,\n$$\n当 $w  N - n_T$ 时，该概率为 $0$。对于一个大小为 $w$ 的随机线程束，其期望周期成本为\n$$\n\\mathbb{E}[C_{\\text{warp}}(w)] = L_S \\left(1 - \\frac{\\binom{N - n_S}{w}}{\\binom{N}{w}}\\right) + L_R \\left(1 - \\frac{\\binom{N - n_R}{w}}{\\binom{N}{w}}\\right) + L_C \\left(1 - \\frac{\\binom{N - n_C}{w}}{\\binom{N}{w}}\\right).\n$$\n设有 $M = \\left\\lfloor \\frac{N}{W} \\right\\rfloor$ 个大小为 $W$ 的满线程束，以及一个最后的（可能不完整的）大小为 $W_{\\text{last}} = N - M W$ 的线程束（其中 $W_{\\text{last}} = 0$ 表示没有不完整的线程束），则朴素排序的期望总周期成本为\n$$\n\\mathbb{E}[C_{\\text{naive}}] = M \\cdot \\mathbb{E}[C_{\\text{warp}}(W)] + \\begin{cases}\n\\mathbb{E}[C_{\\text{warp}}(W_{\\text{last}}),  \\text{if } W_{\\text{last}}  0,\\\\\n0,  \\text{if } W_{\\text{last}} = 0.\n\\end{cases}\n$$\n每个大小为 $w$ 的线程束执行的不同分支的期望数量（一种衡量分化热点严重程度的指标）是\n$$\n\\mathbb{E}[B(w)] = \\sum_{T \\in \\{S,R,C\\}} \\left(1 - \\frac{\\binom{N - n_T}{w}}{\\binom{N}{w}}\\right).\n$$\n\n- 在按波类型批处理中，为每种波类型形成连续队列，并从每个队列中分配线程束。类型 $T$ 消耗的线程束数量为 $\\left\\lceil \\frac{n_T}{W} \\right\\rceil$，且每个这样的线程束仅执行该分支，周期成本为 $L_T$。批处理的总周期成本为\n$$\nC_{\\text{batch}} = \\left\\lceil \\frac{n_S}{W} \\right\\rceil L_S + \\left\\lceil \\frac{n_R}{W} \\right\\rceil L_R + \\left\\lceil \\frac{n_C}{W} \\right\\rceil L_C.\n$$\n将批处理占用率定义为所有批处理线程束中活动通道的比例：\n$$\n\\mathrm{Occ}_{\\text{batch}} = \\frac{N}{W \\left( \\left\\lceil \\frac{n_S}{W} \\right\\rceil + \\left\\lceil \\frac{n_R}{W} \\right\\rceil + \\left\\lceil \\frac{n_C}{W} \\right\\rceil \\right)}.\n$$\n批处理相对于朴素排序的改进因子是\n$$\n\\mathrm{Imp} = \\frac{\\mathbb{E}[C_{\\text{naive}}]}{C_{\\text{batch}}}.\n$$\n\n从欧拉方程的守恒律结构、由 Rankine–Hugoniot 跳跃条件和稀疏扇积分曲线所蕴含的波分类出发，并使用上述 SIMT 执行模型，实现一个程序，为每个测试案例计算改进因子 $\\mathrm{Imp}$、在朴素排序下满线程束大小 $W$ 的每线程束期望执行的不同分支数 $\\mathbb{E}[B(W)]$，以及批处理占用率 $\\mathrm{Occ}_{\\text{batch}}$。\n\n你的程序应通过稳定的浮点乘积而非显式阶乘来使用精确的有限总体缺失概率 $\\frac{\\binom{N - n_T}{w}}{\\binom{N}{w}}$。所有量均为无量纲。将每个测试案例的三个指标均输出为四舍五入到六位小数的浮点数。\n\n测试套件：\n- 案例 A (平衡混合): $W = 32$, $N = 1024$, $n_S = 410$, $n_R = 410$, $n_C = 204$, $L_S = 900$, $L_R = 700$, $L_C = 250$。\n- 案例 B (激波主导): $W = 32$, $N = 320$, $n_S = 288$, $n_R = 16$, $n_C = 16$, $L_S = 1200$, $L_R = 850$, $L_C = 300$。\n- 案例 C (无激波): $W = 16$, $N = 160$, $n_S = 0$, $n_R = 80$, $n_C = 80$, $L_S = 1000$, $L_R = 500$, $L_C = 220$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序汇总案例 A、B 和 C 的结果。对于每个案例，按 $\\mathrm{Imp}$、$\\mathbb{E}[B(W)]$、$\\mathrm{Occ}_{\\text{batch}}$ 的顺序输出三个计算出的指标。例如，输出应类似于 $[\\text{Imp}_A,\\mathbb{E}[B(W)]_A,\\mathrm{Occ}_{\\text{batch},A},\\text{Imp}_B,\\mathbb{E}[B(W)]_B,\\mathrm{Occ}_{\\text{batch},B},\\text{Imp}_C,\\mathbb{E}[B(W)]_C,\\mathrm{Occ}_{\\text{batch},C}]$，每个值都四舍五入到六位小数并表示为十进制数。", "solution": "问题陈述被认为是有效的。它在科学上基于计算流体动力学（CFD）和并行计算性能建模的原理。该问题是适定的，提供了一套独立的定义、公式和数据，从而可以得到唯一且可验证的解。其语言是客观的，参数在数值模拟的背景下是物理上合理的。核心任务不是求解欧拉方程本身，而是使用所提供的概率性能模型，分析和比较在 GPU 上并行黎曼求解器的两种不同计算策略。线程类型的分布（$n_S, n_R, n_C$）是给定的，它代表了物理分类的结果，而该分类本身不是所需计算的一部分。\n\n解决方案的步骤是按描述实现朴素执行策略和批处理执行策略的数学模型。\n\n首先，我们定义一个核心函数来计算大小为 $w$ 的随机线程束不包含特定类型 $T$ 的线程的概率。给定总共 $N$ 个线程，其中 $n_T$ 个是类型 $T$，从整个总体中选择 $w$ 个线程的方法数是 $\\binom{N}{w}$。选择 $w$ 个*不*是类型 $T$ 的线程的方法数是 $\\binom{N - n_T}{w}$。缺失概率是这两个量的比值。为了在不使用可能导致溢出的阶乘的情况下稳健地计算这个比值，我们将其表示为分数的乘积：\n$$\n\\mathbb{P}\\{\\text{no }T\\text{ in warp of size } w\\} = \\prod_{i=0}^{w-1} \\frac{N - n_T - i}{N - i}\n$$\n此计算在 $w \\le N - n_T$ 时有效。如果 $w  N - n_T$，则不可能选择出 $w$ 个非 $T$ 类型的线程，因此概率为 $0$。在这种情况下，乘积形式能正确地得出 $0$，因为对于某个 $i  w$，其中一个分子项 $(N - n_T - i)$ 将变为零。这个函数，我们称之为 $p_a(N, n_T, w)$，是朴素排序模型的基础。\n\n有了此概率，我们就可以计算朴素排序策略的指标。每个大小为 $w$ 的线程束执行的不同分支的期望数量，记为 $\\mathbb{E}[B(w)]$，是每种分支类型存在的概率之和。分支类型 $T$ 存在的概率是 $1 - p_a(N, n_T, w)$。\n$$\n\\mathbb{E}[B(w)] = \\sum_{T \\in \\{S,R,C\\}} \\left(1 - p_a(N, n_T, w)\\right)\n$$\n单个大小为 $w$ 的线程束的期望周期成本，记为 $\\mathbb{E}[C_{\\text{warp}}(w)]$，是每种分支类型的周期成本之和，按其存在的概率加权。\n$$\n\\mathbb{E}[C_{\\text{warp}}(w)] = L_S \\left(1 - p_a(N, n_S, w)\\right) + L_R \\left(1 - p_a(N, n_R, w)\\right) + L_C \\left(1 - p_a(N, n_C, w)\\right)\n$$\n朴素策略的总期望成本 $\\mathbb{E}[C_{\\text{naive}}]$ 是通过对所有线程束的成本求和来计算的。问题被划分为 $M = \\lfloor N/W \\rfloor$ 个大小为 $W$ 的满线程束，以及如果 $N$ 不是 $W$ 的倍数，则有一个大小为 $W_{\\text{last}} = N \\pmod W$ 的部分线程束。\n$$\n\\mathbb{E}[C_{\\text{naive}}] = M \\cdot \\mathbb{E}[C_{\\text{warp}}(W)] + (\\mathbb{E}[C_{\\text{warp}}(W_{\\text{last}})] \\text{ if } W_{\\text{last}}  0 \\text{ else } 0)\n$$\n\n接下来，我们评估按波类型批处理策略的指标。在此策略中，线程按类型排序，从而完全消除线程束分化。总周期成本 $C_{\\text{batch}}$ 是处理每种类型的成本之和。对于具有 $n_T$ 个线程的类型 $T$，所需的线程束数量为 $\\lceil n_T/W \\rceil$。\n$$\nC_{\\text{batch}} = \\left\\lceil \\frac{n_S}{W} \\right\\rceil L_S + \\left\\lceil \\frac{n_R}{W} \\right\\rceil L_R + \\left\\lceil \\frac{n_C}{W} \\right\\rceil L_C\n$$\n对于正整数 $a, b$，向上取整函数 $\\lceil a/b \\rceil$ 可以使用整数算术计算为 $(a + b - 1) // b$。\n\n批处理占用率 $\\mathrm{Occ}_{\\text{batch}}$ 衡量 GPU 通道（lanes）的利用率。它是总线程数 $N$ 与所有线程束中分配的总通道数之比。\n$$\n\\mathrm{Occ}_{\\text{batch}} = \\frac{N}{W \\left( \\left\\lceil \\frac{n_S}{W} \\right\\rceil + \\left\\lceil \\frac{n_R}{W} \\right\\rceil + \\left\\lceil \\frac{n_C}{W} \\right\\rceil \\right)}\n$$\n\n最后，改进因子 $\\mathrm{Imp}$ 量化了批处理相对于朴素方法的性能增益。它是期望的朴素成本与确定性的批处理成本之比。\n$$\n\\mathrm{Imp} = \\frac{\\mathbb{E}[C_{\\text{naive}}]}{C_{\\text{batch}}}\n$$\n\n这些公式被应用于提供的三个测试案例中的每一个。所需的指标是 $\\mathrm{Imp}$、$\\mathbb{E}[B(W)]$（针对大小为 $W$ 的满线程束）和 $\\mathrm{Occ}_{\\text{batch}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the improvement factor, expected number of branches,\n    and batched occupancy for each case and prints the results in the\n    specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (balanced mixture)\n        {'W': 32, 'N': 1024, 'n_S': 410, 'n_R': 410, 'n_C': 204, 'L_S': 900, 'L_R': 700, 'L_C': 250},\n        # Case B (shock-dominant)\n        {'W': 32, 'N': 320, 'n_S': 288, 'n_R': 16, 'n_C': 16, 'L_S': 1200, 'L_R': 850, 'L_C': 300},\n        # Case C (no shocks)\n        {'W': 16, 'N': 160, 'n_S': 0, 'n_R': 80, 'n_C': 80, 'L_S': 1000, 'L_R': 500, 'L_C': 220},\n    ]\n\n    results = []\n    for case in test_cases:\n        imp, exp_b, occ_batch = calculate_metrics(case)\n        results.extend([f\"{imp:.6f}\", f\"{exp_b:.6f}\", f\"{occ_batch:.6f}\"])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef prob_absence(N, n_T, w):\n    \"\"\"\n    Calculates the probability that a random warp of size w contains no threads of type T.\n    P{no T in warp} = B(N - n_T, w) / B(N, w)\n    This is computed using a stable product form.\n    \n    Args:\n        N (int): Total number of threads.\n        n_T (int): Number of threads of type T.\n        w (int): Warp size.\n        \n    Returns:\n        float: Probability of absence.\n    \"\"\"\n    if w == 0:\n        return 1.0\n    if w > N - n_T:\n        return 0.0\n    \n    prob = 1.0\n    for i in range(w):\n        prob *= (N - n_T - i) / (N - i)\n    return prob\n\ndef calculate_metrics(case):\n    \"\"\"\n    Calculates the required metrics for a single test case.\n    \n    Args:\n        case (dict): A dictionary containing all parameters for the test case.\n        \n    Returns:\n        tuple: A tuple containing (Imp, E[B(W)], Occ_batch).\n    \"\"\"\n    W = case['W']\n    N = case['N']\n    n_S, n_R, n_C = case['n_S'], case['n_R'], case['n_C']\n    L_S, L_R, L_C = case['L_S'], case['L_R'], case['L_C']\n\n    # --- Naive Ordering Calculation ---\n    \n    def expected_warp_cost(w):\n        if w == 0:\n            return 0.0\n        p_absence_S = prob_absence(N, n_S, w)\n        p_absence_R = prob_absence(N, n_R, w)\n        p_absence_C = prob_absence(N, n_C, w)\n        \n        cost = L_S * (1 - p_absence_S) + L_R * (1 - p_absence_R) + L_C * (1 - p_absence_C)\n        return cost\n\n    M = N // W\n    W_last = N % W\n    \n    E_C_warp_full = expected_warp_cost(W)\n    E_C_warp_last = expected_warp_cost(W_last)\n    \n    E_C_naive = M * E_C_warp_full + E_C_warp_last\n\n    # Expected number of branches for a full warp of size W\n    p_absence_S_full = prob_absence(N, n_S, W)\n    p_absence_R_full = prob_absence(N, n_R, W)\n    p_absence_C_full = prob_absence(N, n_C, W)\n    \n    E_B_W = (1 - p_absence_S_full) + (1 - p_absence_R_full) + (1 - p_absence_C_full)\n\n    # --- Wave-Type Batching Calculation ---\n\n    def ceil_div(a, b):\n        if a == 0:\n            return 0\n        return (a + b - 1) // b\n\n    warps_S = ceil_div(n_S, W)\n    warps_R = ceil_div(n_R, W)\n    warps_C = ceil_div(n_C, W)\n\n    C_batch = warps_S * L_S + warps_R * L_R + warps_C * L_C\n    \n    total_batched_warps = warps_S + warps_R + warps_C\n    if total_batched_warps == 0:\n        Occ_batch = 0.0 # Or undefined, but 0 is safe for N=0\n    else:\n        Occ_batch = N / (W * total_batched_warps)\n\n    # --- Final Metrics ---\n    \n    if C_batch == 0:\n        Imp = 0.0 # Or undefined, depending on convention. Assume 0 improvement if no work.\n    else:\n        Imp = E_C_naive / C_batch\n\n    return Imp, E_B_W, Occ_batch\n\nsolve()\n```", "id": "3361328"}]}