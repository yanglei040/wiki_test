{"hands_on_practices": [{"introduction": "我们从格林-高斯定理最直接的应用开始。第一个练习将引导你完成在单个三维单元中计算梯度的基本步骤。通过处理一个简单的四面体单元和线性标量场，你将具体应用公式，计算如面法向面积矢量和面心等几何属性，并验证该方法的一个关键特性：其对于线性场的精确性。这个练习旨在为你构建一个坚实的力学基础。[@problem_id:3325620]", "problem": "在计算流体动力学 (CFD) 中，有限体积法 (FVM) 通常使用格林-高斯方法来重构梯度。请从散度定理和 FVM 的基本概念出发，推导一个依赖于面心标量值、面面积矢量和单元体积的显式单元梯度估计量。然后，对以下给定的四面体控制体积和标量场，评估此估计量。\n\n考虑一个三维四面体控制体积，其顶点为 $\\,\\mathbf{v}_{0}=(0,0,0)\\,$、$\\,\\mathbf{v}_{1}=(1,0,0)\\,$、$\\,\\mathbf{v}_{2}=(0,1,0)\\,$ 和 $\\,\\mathbf{v}_{3}=(0,0,1)\\,$。设标量场为 $\\,\\phi(\\mathbf{x})=2x-3y+4z+1\\,$。对该四面体的每个面计算：\n- 指向外部的面面积矢量 $\\,\\mathbf{S}_{f}\\,$，\n- 面心 $\\,\\mathbf{x}_{f}\\,$，\n\n然后，仅使用面心值 $\\,\\phi(\\mathbf{x}_{f})\\,$ 和向外的面面积矢量 $\\,\\mathbf{S}_{f}\\,$，评估此单元的格林-高斯梯度估计值。\n\n您的最终答案必须是以单行矩阵 $\\,\\big[\\partial \\phi/\\partial x,\\ \\partial \\phi/\\partial y,\\ \\partial \\phi/\\partial z\\big]\\,$ 形式表示的梯度矢量，且为精确值。无需四舍五入。不包含单位。", "solution": "此问题要求推导基于单元的格林-高斯梯度估计量，并将其应用于具有线性标量场的特定四面体控制体积。\n\n首先，我们推导通用公式。推导始于标量场 $\\phi$ 梯度的散度定理的一个变体：\n$$ \\int_V \\nabla \\phi \\, dV = \\oint_{\\partial V} \\phi \\, d\\mathbf{S} $$\n其中 $V$ 是一个控制体积，$\\partial V$ 是其边界面。$d\\mathbf{S}$ 是微分面积矢量，定义为 $\\mathbf{n} dS$，其中 $\\mathbf{n}$ 是指向外部的单位法向量。\n\n在有限体积法 (FVM) 的背景下，我们将此定理应用于单个多面体单元（控制体积），我们将其记为 $P$，其体积为 $V_P$。积分方程变为：\n$$ \\int_{V_P} \\nabla \\phi \\, dV = \\oint_{\\partial V_P} \\phi \\, d\\mathbf{S} $$\n为了获得代数近似，我们做出两个关键假设：\n1. 梯度 $\\nabla \\phi$ 假设在整个单元 $P$ 内是常数。我们将此单元平均梯度记为 $(\\nabla \\phi)_P$。这使我们可以将左侧写为：\n$$ \\int_{V_P} \\nabla \\phi \\, dV \\approx (\\nabla \\phi)_P \\int_{V_P} dV = (\\nabla \\phi)_P V_P $$\n2. 单元边界 $\\partial V_P$ 由有限数量的平面组成，以 $f$ 为索引。面积分可以写为在这些面上的积分之和：\n$$ \\oint_{\\partial V_P} \\phi \\, d\\mathbf{S} = \\sum_f \\int_{S_f} \\phi \\, d\\mathbf{S} $$\n对于每个面积分，我们假设标量值 $\\phi$ 在面 $S_f$ 上是常数，并且等于其在面心 $\\phi_f = \\phi(\\mathbf{x}_f)$ 处的值。这个近似给出了：\n$$ \\int_{S_f} \\phi \\, d\\mathbf{S} \\approx \\phi_f \\int_{S_f} d\\mathbf{S} = \\phi_f \\mathbf{S}_f $$\n其中 $\\mathbf{S}_f = \\int_{S_f} d\\mathbf{S}$ 是面 $f$ 的面积矢量。\n\n结合这些近似，我们得到：\n$$ (\\nabla \\phi)_P V_P \\approx \\sum_f \\phi_f \\mathbf{S}_f $$\n求解单元梯度 $(\\nabla \\phi)_P$ 可得到格林-高斯梯度估计量：\n$$ (\\nabla \\phi)_P = \\frac{1}{V_P} \\sum_f \\phi_f \\mathbf{S}_f $$\n该公式基于单元体积 $V_P$、面心的标量值 $\\phi_f$ 和面面积矢量 $\\mathbf{S}_f$，为单元内的梯度提供了一个显式估计。\n\n接下来，我们将此公式应用于给定的四面体，其顶点为 $\\mathbf{v}_{0}=(0,0,0)$、$\\mathbf{v}_{1}=(1,0,0)$、$\\mathbf{v}_{2}=(0,1,0)$ 和 $\\mathbf{v}_{3}=(0,0,1)$。标量场为 $\\phi(\\mathbf{x}) = \\phi(x,y,z) = 2x-3y+4z+1$。\n\n1.  **单元体积 ($V_P$)**：一个顶点在原点，其他顶点在 $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$ 的四面体的体积由 $V_P = \\frac{1}{6}|(\\mathbf{v}_1 \\times \\mathbf{v}_2) \\cdot \\mathbf{v}_3|$ 给出。\n    $$ \\mathbf{v}_1 \\times \\mathbf{v}_2 = (1,0,0) \\times (0,1,0) = (0,0,1) $$\n    $$ (\\mathbf{v}_1 \\times \\mathbf{v}_2) \\cdot \\mathbf{v}_3 = (0,0,1) \\cdot (0,0,1) = 1 $$\n    因此，体积为 $V_P = \\frac{1}{6}$。\n\n2.  **面属性**：该四面体有四个面。对于每个面 $f$，我们计算其形心 $\\mathbf{x}_f$ 和其向外的面积矢量 $\\mathbf{S}_f$。具有顶点 $A, B, C$ 的三角形面的面积矢量为 $\\mathbf{S}_f = \\frac{1}{2}\\left( (B-A) \\times (C-A) \\right)$，选择顶点顺序以确保矢量指向外部。\n\n    - **面 $f_1$ (顶点 $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$)**：\n      - 形心：$\\mathbf{x}_{f_1} = \\frac{1}{3}(\\mathbf{v}_1+\\mathbf{v}_2+\\mathbf{v}_3) = \\frac{1}{3}(1,1,1) = (\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3})$。\n      - 面积矢量：$\\mathbf{S}_{f_1} = \\frac{1}{2}((\\mathbf{v}_2-\\mathbf{v}_1) \\times (\\mathbf{v}_3-\\mathbf{v}_1)) = \\frac{1}{2}((-1,1,0) \\times (-1,0,1)) = \\frac{1}{2}(1,1,1)$。该矢量指向远离原点（顶点 $\\mathbf{v}_0$），因此是向外的。\n      - 标量值：$\\phi_{f_1} = \\phi(\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3}) = 2(\\frac{1}{3}) - 3(\\frac{1}{3}) + 4(\\frac{1}{3}) + 1 = \\frac{3}{3} + 1 = 2$。\n\n    - **面 $f_2$ (顶点 $\\mathbf{v}_0, \\mathbf{v}_3, \\mathbf{v}_2$)**：此面位于 $x=0$ 平面上。\n      - 形心：$\\mathbf{x}_{f_2} = \\frac{1}{3}(\\mathbf{v}_0+\\mathbf{v}_3+\\mathbf{v}_2) = \\frac{1}{3}(0,1,1) = (0, \\frac{1}{3}, \\frac{1}{3})$。\n      - 面积矢量：$\\mathbf{S}_{f_2} = \\frac{1}{2}((\\mathbf{v}_3-\\mathbf{v}_0) \\times (\\mathbf{v}_2-\\mathbf{v}_0)) = \\frac{1}{2}((0,0,1) \\times (0,1,0)) = \\frac{1}{2}(-1,0,0)$。该矢量指向负 $x$ 方向，远离四面体内部。\n      - 标量值：$\\phi_{f_2} = \\phi(0, \\frac{1}{3}, \\frac{1}{3}) = 2(0) - 3(\\frac{1}{3}) + 4(\\frac{1}{3}) + 1 = \\frac{1}{3} + 1 = \\frac{4}{3}$。\n\n    - **面 $f_3$ (顶点 $\\mathbf{v}_0, \\mathbf{v}_1, \\mathbf{v}_3$)**：此面位于 $y=0$ 平面上。\n      - 形心：$\\mathbf{x}_{f_3} = \\frac{1}{3}(\\mathbf{v}_0+\\mathbf{v}_1+\\mathbf{v}_3) = \\frac{1}{3}(1,0,1) = (\\frac{1}{3}, 0, \\frac{1}{3})$。\n      - 面积矢量：$\\mathbf{S}_{f_3} = \\frac{1}{2}((\\mathbf{v}_1-\\mathbf{v}_0) \\times (\\mathbf{v}_3-\\mathbf{v}_0)) = \\frac{1}{2}((1,0,0) \\times (0,0,1)) = \\frac{1}{2}(0,-1,0)$。该矢量指向负 $y$ 方向，远离内部。\n      - 标量值：$\\phi_{f_3} = \\phi(\\frac{1}{3}, 0, \\frac{1}{3}) = 2(\\frac{1}{3}) - 3(0) + 4(\\frac{1}{3}) + 1 = \\frac{6}{3} + 1 = 3$。\n\n    - **面 $f_4$ (顶点 $\\mathbf{v}_0, \\mathbf{v}_2, \\mathbf{v}_1$)**：此面位于 $z=0$ 平面上。\n      - 形心：$\\mathbf{x}_{f_4} = \\frac{1}{3}(\\mathbf{v}_0+\\mathbf{v}_2+\\mathbf{v}_1) = \\frac{1}{3}(1,1,0) = (\\frac{1}{3}, \\frac{1}{3}, 0)$。\n      - 面积矢量：$\\mathbf{S}_{f_4} = \\frac{1}{2}((\\mathbf{v}_2-\\mathbf{v}_0) \\times (\\mathbf{v}_1-\\mathbf{v}_0)) = \\frac{1}{2}((0,1,0) \\times (1,0,0)) = \\frac{1}{2}(0,0,-1)$。该矢量指向负 $z$ 方向，远离内部。\n      - 标量值：$\\phi_{f_4} = \\phi(\\frac{1}{3}, \\frac{1}{3}, 0) = 2(\\frac{1}{3}) - 3(\\frac{1}{3}) + 4(0) + 1 = -\\frac{1}{3} + 1 = \\frac{2}{3}$。\n\n3.  **求和**：我们现在计算总和 $\\sum_f \\phi_f \\mathbf{S}_f$。\n    $$ \\phi_{f_1}\\mathbf{S}_{f_1} = 2 \\cdot (\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}) = (1, 1, 1) $$\n    $$ \\phi_{f_2}\\mathbf{S}_{f_2} = \\frac{4}{3} \\cdot (-\\frac{1}{2}, 0, 0) = (-\\frac{2}{3}, 0, 0) $$\n    $$ \\phi_{f_3}\\mathbf{S}_{f_3} = 3 \\cdot (0, -\\frac{1}{2}, 0) = (0, -\\frac{3}{2}, 0) $$\n    $$ \\phi_{f_4}\\mathbf{S}_{f_4} = \\frac{2}{3} \\cdot (0, 0, -\\frac{1}{2}) = (0, 0, -\\frac{1}{3}) $$\n\n    总和为：\n    $$ \\sum_f \\phi_f \\mathbf{S}_f = (1 - \\frac{2}{3}, \\quad 1 - \\frac{3}{2}, \\quad 1 - \\frac{1}{3}) = (\\frac{1}{3}, -\\frac{1}{2}, \\frac{2}{3}) $$\n\n4.  **梯度计算**：最后，我们计算梯度估计值。\n    $$ (\\nabla \\phi)_P = \\frac{1}{V_P} \\sum_f \\phi_f \\mathbf{S}_f = \\frac{1}{1/6} (\\frac{1}{3}, -\\frac{1}{2}, \\frac{2}{3}) $$\n    $$ (\\nabla \\phi)_P = 6 \\cdot (\\frac{1}{3}, -\\frac{1}{2}, \\frac{2}{3}) = (2, -3, 4) $$\n\n估计的梯度为 $(2, -3, 4)$。\n线性标量场 $\\phi(\\mathbf{x}) = 2x-3y+4z+1$ 的解析梯度是 $\\nabla \\phi = (\\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y}, \\frac{\\partial \\phi}{\\partial z}) = (2, -3, 4)$。正如预期的那样，格林-高斯方法精确地再现了线性场的梯度，因为构成截断误差的泰勒级数展开中的高阶项为零。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2 & -3 & 4\n\\end{pmatrix}\n}\n$$", "id": "3325620"}, {"introduction": "一个数值格式的优劣取决于其应用的网格质量。本练习探讨了任何有效的有限体积方法都必须满足的一个关键先决条件：几何守恒律，即任何闭合控制体的面法向面积矢量之和 $\\sum_f \\mathbf{S}_f$ 必须为零。你将研究违反此定律（由于一个假设的网格缺陷）的后果，并观察它如何导致为恒定场计算出非物理的梯度。这突显了拥有一个“水密”且方向正确的网格的绝对必要性。[@problem_id:3325687]", "problem": "考虑一个用于计算流体力学的有限体积法中的单个六面体控制体，具体来说是一个边长为 $L$ 的立方体，其中心位于原点，各个面位于 $x=\\pm L/2$、$y=\\pm L/2$ 和 $z=\\pm L/2$。令每个面面积矢量定义为 $\\mathbf{S}_f = \\mathbf{n}_f A_f$，其中 $\\mathbf{n}_f$ 是面的单位法向量，$A_f$ 是面的面积。在一个方向正确的网格中，对于任何闭合控制体，外法线满足 $\\sum_f \\mathbf{S}_f = \\mathbf{0}$。\n\n假设由于网格预处理中的一个错误，一个面的法线方向不正确：位于 $x=-L/2$ 的面被赋予了法向量 $\\mathbf{n} = +\\hat{\\mathbf{i}}$，而不是正确的 $\\mathbf{n} = -\\hat{\\mathbf{i}}$。所有其他面的法线都是正确的，且指向外部。所有面的面积均为 $A_f = L^2$，控制体的体积为 $V = L^3$。\n\n一个恒定标量场 $\\phi(\\mathbf{x}) \\equiv \\phi_0$ 在此控制体上进行采样。从散度定理和标准的连续介质定义出发，推导控制体的离散格林-高斯梯度重构表达式（用面面积矢量和面上的值表示），然后将其应用于这个具有不正确面法线的特定单元，以获得单元内部的重构梯度。\n\n定义无量纲误差\n$$\ne \\equiv \\frac{\\left\\|\\left.\\nabla \\phi\\right|_{\\text{rec}}\\right\\|\\,L}{|\\phi_0|},\n$$\n其中 $\\left.\\nabla \\phi\\right|_{\\text{rec}}$ 是控制体内部的重构梯度，$\\|\\cdot\\|$ 表示欧几里得范数。计算上述配置下的 $e$。将最终答案表示为一个纯数（无量纲）。不要包含任何单位。无需四舍五入。", "solution": "本问题要求计算在一个具有一个错误面法线方向的立方体控制体内，对一个恒定标量场进行格林-高斯梯度重构时产生的无量纲误差。\n\n首先，我们推导格林-高斯梯度重构的一般公式。其基础是散度定理的一个推论，通常称为梯度定理，该定理指出，对于一个标量场 $\\phi$ 和一个由表面 $S$ 包围的控制体 $V$：\n$$ \\int_V \\nabla \\phi \\, dV = \\oint_S \\phi \\, \\mathbf{n} \\, dS $$\n其中 $\\mathbf{n}$ 是表面 $S$ 上的局部向外单位法向量。\n\n在有限体积法中，我们近似控制体内的平均梯度。平均梯度定义为：\n$$ \\left.\\nabla \\phi\\right|_{\\text{avg}} = \\frac{1}{V} \\int_V \\nabla \\phi \\, dV $$\n代入梯度定理，我们得到：\n$$ \\left.\\nabla \\phi\\right|_{\\text{avg}} = \\frac{1}{V} \\oint_S \\phi \\, \\mathbf{n} \\, dS $$\n为了获得离散的数值格式，连续的面积分被替换为对构成控制体边界的离散面 $f$ 的求和：\n$$ \\oint_S \\phi \\, \\mathbf{n} \\, dS = \\sum_{f} \\int_{S_f} \\phi \\, \\mathbf{n} \\, dS $$\n通过假设标量场 $\\phi$ 在每个面 $S_f$ 上具有一个恒定值 $\\phi_f$（通常是面心的值），可以近似计算每个面上的积分。这使我们能够写出：\n$$ \\int_{S_f} \\phi \\, \\mathbf{n} \\, dS \\approx \\phi_f \\int_{S_f} \\mathbf{n} \\, dS $$\n单位法向量在面面积上的积分就是面面积矢量，$\\mathbf{S}_f = A_f \\mathbf{n}_f$，其中 $A_f$ 是面 $f$ 的面积，$\\mathbf{n}_f$ 是其单位法向量。\n将其代回，控制体中梯度的离散近似，记为 $\\left.\\nabla \\phi\\right|_{\\text{rec}}$，是：\n$$ \\left.\\nabla \\phi\\right|_{\\text{rec}} = \\frac{1}{V} \\sum_{f} \\phi_f \\mathbf{S}_f $$\n这就是格林-高斯梯度重构公式。\n\n现在，我们将此公式应用于具体问题。标量场被给定为一个常数，$\\phi(\\mathbf{x}) \\equiv \\phi_0$。这意味着场在任何点（包括所有面心）的值都就是 $\\phi_0$。因此，对于所有面 $f$，我们有 $\\phi_f = \\phi_0$。公式简化为：\n$$ \\left.\\nabla \\phi\\right|_{\\text{rec}} = \\frac{1}{V} \\sum_{f} \\phi_0 \\mathbf{S}_f = \\frac{\\phi_0}{V} \\sum_{f} \\mathbf{S}_f $$\n问题简化为计算给定立方体的面面积矢量之和 $\\sum_f \\mathbf{S}_f$。该立方体边长为 $L$，中心在原点。其体积为 $V = L^3$，每个面的面积为 $A_f = L^2$。\n\n我们来列出立方体六个面的面面积矢量，并特别注意指定的错误。我们使用标准的笛卡尔坐标系，单位向量为 $\\hat{\\mathbf{i}}$、$\\hat{\\mathbf{j}}$ 和 $\\hat{\\mathbf{k}}$。\n\n1.  位于 $x=L/2$ 的面：正确的向外法线为 $\\mathbf{n} = \\hat{\\mathbf{i}}$。面积矢量为 $\\mathbf{S}_{x+} = A_f \\hat{\\mathbf{i}} = L^2 \\hat{\\mathbf{i}}$。\n2.  位于 $x=-L/2$ 的面：正确的向外法线应为 $\\mathbf{n} = -\\hat{\\mathbf{i}}$。然而，由于错误，它被赋予了法线 $\\mathbf{n} = \\hat{\\mathbf{i}}$。面积矢量为 $\\mathbf{S}_{x-} = A_f \\hat{\\mathbf{i}} = L^2 \\hat{\\mathbf{i}}$。\n3.  位于 $y=L/2$ 的面：正确的向外法线为 $\\mathbf{n} = \\hat{\\mathbf{j}}$。面积矢量为 $\\mathbf{S}_{y+} = A_f \\hat{\\mathbf{j}} = L^2 \\hat{\\mathbf{j}}$。\n4.  位于 $y=-L/2$ 的面：正确的向外法线为 $\\mathbf{n} = -\\hat{\\mathbf{j}}$。面积矢量为 $\\mathbf{S}_{y-} = -A_f \\hat{\\mathbf{j}} = -L^2 \\hat{\\mathbf{j}}$。\n5.  位于 $z=L/2$ 的面：正确的向外法线为 $\\mathbf{n} = \\hat{\\mathbf{k}}$。面积矢量为 $\\mathbf{S}_{z+} = A_f \\hat{\\mathbf{k}} = L^2 \\hat{\\mathbf{k}}$。\n6.  位于 $z=-L/2$ 的面：正确的向外法线为 $\\mathbf{n} = -\\hat{\\mathbf{k}}$。面积矢量为 $\\mathbf{S}_{z-} = -A_f \\hat{\\mathbf{k}} = -L^2 \\hat{\\mathbf{k}}$。\n\n这些矢量的和为：\n$$ \\sum_{f} \\mathbf{S}_f = \\mathbf{S}_{x+} + \\mathbf{S}_{x-} + \\mathbf{S}_{y+} + \\mathbf{S}_{y-} + \\mathbf{S}_{z+} + \\mathbf{S}_{z-} $$\n$$ \\sum_{f} \\mathbf{S}_f = (L^2 \\hat{\\mathbf{i}} + L^2 \\hat{\\mathbf{i}}) + (L^2 \\hat{\\mathbf{j}} - L^2 \\hat{\\mathbf{j}}) + (L^2 \\hat{\\mathbf{k}} - L^2 \\hat{\\mathbf{k}}) $$\n$$ \\sum_{f} \\mathbf{S}_f = 2L^2 \\hat{\\mathbf{i}} + \\mathbf{0} + \\mathbf{0} = 2L^2 \\hat{\\mathbf{i}} $$\n对于一个方向正确的闭合体积，这个和应为 $\\mathbf{0}$。非零结果完全是由网格错误引起的。\n\n现在，我们可以计算重构的梯度：\n$$ \\left.\\nabla \\phi\\right|_{\\text{rec}} = \\frac{\\phi_0}{V} \\sum_{f} \\mathbf{S}_f = \\frac{\\phi_0}{L^3} (2L^2 \\hat{\\mathbf{i}}) = \\frac{2\\phi_0}{L} \\hat{\\mathbf{i}} $$\n从解析上讲，一个恒定场的梯度为零（$\\nabla\\phi_0 = \\mathbf{0}$）。由于几何上的不一致性，数值格式产生了一个非零的梯度。\n\n最后，我们计算无量纲误差 $e$，其定义为：\n$$ e \\equiv \\frac{\\left\\|\\left.\\nabla \\phi\\right|_{\\text{rec}}\\right\\|\\,L}{|\\phi_0|} $$\n重构梯度的欧几里得范数为：\n$$ \\left\\|\\left.\\nabla \\phi\\right|_{\\text{rec}}\\right\\| = \\left\\| \\frac{2\\phi_0}{L} \\hat{\\mathbf{i}} \\right\\| = \\left| \\frac{2\\phi_0}{L} \\right| = \\frac{2|\\phi_0|}{L} $$\n将此范数代入 $e$ 的表达式中：\n$$ e = \\frac{\\left(\\frac{2|\\phi_0|}{L}\\right)L}{|\\phi_0|} = \\frac{2|\\phi_0|}{|\\phi_0|} $$\n假设 $\\phi_0 \\neq 0$，我们得到：\n$$ e = 2 $$\n这个无量纲值量化了由单个不正确的面法线引入的梯度计算误差。", "answer": "$$\n\\boxed{2}\n$$", "id": "3325687"}, {"introduction": "格林-高斯框架允许在近似面心值时采用不同策略，从而产生具有不同精度和鲁棒性的格式。这个高级练习将从纸笔计算转向计算机编程，要求你实现并比较两种流行的变体：基于单元中心的重构和基于节点的重构。通过在不同质量（例如，扭曲度、各向异性）的网格上测试这些格式，你将对何时一种方法优于另一种方法形成实践性的理解，并将数值性能与具体的网格特性联系起来。[@problem_id:3325671]", "problem": "考虑一个二维多边形控制体离散化，其中的梯度重构依赖于散度定理（也称为高斯-奥斯特罗格拉德斯基定理）。在此背景下，Green-Gauss (GG) 梯度重构是该定理的一个应用，它指出：对于一个足够光滑的标量场 $\\phi$，$\\nabla \\phi$ 在一个单元上的面积分等于 $\\phi$ 在该单元边界上由外法向单位矢量加权的线积分。本题的目标是在三角形网格上比较两种 GG 策略：一种是使用顶点值的基于节点的方案，另一种是使用单元中心值的基于单元的方案。此比较将在解析定义的场上进行，其中三角函数中的所有角度都应解释为弧度。\n\n您必须使用通过对指定点集进行 Delaunay 三角剖分获得的二维三角形网格来实现这两种重构。基于单元的策略仅使用每个三角形自身及其直接邻居的单元中心值 $\\phi_c$ 来重构该三角形上的 $\\nabla \\phi$。基于节点的策略仅使用每个三角形的三个顶点上的顶点值 $\\phi_v$ 来重构该三角形上的 $\\nabla \\phi$。两种重构都必须基于第一性原理：从散度定理所蕴含的积分恒等式出发，通过使用外法向边法线和边长的边贡献来近似边界积分。您不得使用任何跳过此推导路径的公式，也不得假设任何未经该定理证明的校正项。\n\n为了获得客观的精度比较，设 $\\phi(x,y) = \\sin(2x) + 0.5 \\cos(3y) + x y$，其梯度为 $\\nabla \\phi(x,y) = \\left(2\\cos(2x) + y,\\,-1.5 \\sin(3y) + x\\right)$。在三角形顶点处计算 $\\phi$ 以定义 $\\phi_v$，在三角形质心处计算 $\\phi$ 以定义 $\\phi_c$。对于每个三角形，使用两种策略近似 $\\nabla \\phi$，并与三角形质心处的精确梯度进行比较。计算每个三角形的误差向量的欧几里得范数。为避免边界条件带来的复杂性，误差统计仅包括所有三条边都有邻居的三角形。\n\n设计您的程序以生成四个具有不同连接性和畸变特性的网格，以探究基于节点的 GG 方法何时比基于单元的 GG 方法精度更高。使用以下确定性播种的点云生成器测试套件：\n\n1.  结构化格网：在 $[0,1]\\times[0,1]$ 上的均匀矩形网格，其中 $n_x=25$，$n_y=20$，无扰动。\n2.  扭曲网格：从相同的格网开始，然后在三角剖分前对每个格网点的两个坐标分别添加振幅为 $\\varepsilon=0.08$ 的独立均匀扰动。\n3.  各向异性拉伸网格：从均匀格网开始，然后通过 $(x,y)\\mapsto(x,\\,0.2\\,y)$ 映射点，并添加振幅为 $\\varepsilon=0.04$ 的小扰动。\n4.  聚集的非规则点集：将均匀格网与在以 $(0.5,0.5)$ 为中心、半径为 $0.3$ 的圆盘内均匀采样的附加点相结合；使用 $400$ 个额外点。\n\n对于每个网格，运行两种重构并计算所有内部三角形的平均误差。对于每个网格，确定基于节点的 GG 方法的平均误差是否严格小于基于单元的 GG 方法的平均误差。每个测试用例要输出的主要量是一个布尔值，指示基于节点的 GG 方法是否更精确。\n\n需要识别的网格连接性条件是那些在此条件下基于节点的 Green-Gauss 方法相对于基于单元的 Green-Gauss 方法精度有所提高的条件。作为算法推理的一部分，请在内部计算连接性和对齐性诊断信息（无需打印）：边外法线与质心到邻居质心方向之间的平均非正交角，以及顶点价的分布。利用这些信息来解释基于节点的重构何时能从网格连接性中受益。\n\n您的程序应生成一行输出，其中包含对应于四个测试用例的四个布尔值，格式为方括号括起来的逗号分隔列表（例如，“[true,false,true,false]”）。所有三角函数的角度都必须解释为弧度。不涉及物理单位；报告纯数值结果。最终的布尔值是唯一要求的输出。", "solution": "该问题要求在二维三角形网格上比较两种不同的 Green-Gauss (GG) 梯度重构策略：一种基于单元，一种基于节点。此比较必须是定量的，基于重构已知解析标量场梯度的精度。整个过程都基于散度定理的基本原理。\n\n### 理论基础：Green-Gauss 方法\n\n在二维空间中，散度定理指出，对于一个足够光滑的矢量场 $\\mathbf{F}$，其散度在区域 $A$ 上的积分等于该场法向分量在边界 $\\partial A$ 上的线积分。\n$$\n\\iint_A (\\nabla \\cdot \\mathbf{F}) \\, dA = \\oint_{\\partial A} \\mathbf{F} \\cdot \\mathbf{n} \\, ds\n$$\n其中 $\\mathbf{n}$ 是边界的外法向单位矢量。通过将矢量场 $\\mathbf{F}$ 设置为标量场 $\\phi$ 的梯度，即 $\\mathbf{F} = \\nabla \\phi$，可以推导出一个不太常见的定理形式（格林恒等式之一），通常称为梯度定理。为达成本题目的，我们将散度定理分别应用于矢量场 $\\mathbf{F}_x = (\\phi, 0)$ 和 $\\mathbf{F}_y = (0, \\phi)$。\n$$\n\\iint_A \\frac{\\partial \\phi}{\\partial x} \\, dA = \\oint_{\\partial A} \\phi n_x \\, ds \\quad \\text{及} \\quad \\iint_A \\frac{\\partial \\phi}{\\partial y} \\, dA = \\oint_{\\partial A} \\phi n_y \\, ds\n$$\n将它们结合起来，得到一个关于梯度的矢量恒等式，这是 Green-Gauss 方法的基础：\n$$\n\\iint_A \\nabla \\phi \\, dA = \\oint_{\\partial A} \\phi \\mathbf{n} \\, ds\n$$\n为了将此应用于离散控制体（网格中的单元 $P$），我们假设梯度 $(\\nabla \\phi)_P$ 在整个单元上是恒定的。面积分随之简化为 $(\\nabla \\phi)_P A_P$，其中 $A_P$ 是单元的面积。这给出了平均梯度的精确关系：\n$$\n(\\nabla \\phi)_P = \\frac{1}{A_P} \\oint_{\\partial A_P} \\phi \\mathbf{n} \\, ds\n$$\n线积分通过对单元的每个面（边）$f$ 的贡献求和来近似：\n$$\n\\oint_{\\partial A_P} \\phi \\mathbf{n} \\, ds \\approx \\sum_{f} \\int_f \\phi \\mathbf{n}_f \\, ds\n$$\n其中 $\\mathbf{n}_f$ 是面 $f$ 的外法向单位矢量。我们进一步将每个面上的 $\\phi$ 值近似为一个常数 $\\phi_f$。这导致了在单元 $P$ 中计算梯度的最终离散化公式：\n$$\n(\\nabla \\phi)_P \\approx \\frac{1}{A_P} \\sum_f \\phi_f (\\mathbf{n}_f \\Delta s_f) = \\frac{1}{A_P} \\sum_f \\phi_f \\mathbf{S}_f\n$$\n这里，$\\Delta s_f$ 是面 $f$ 的长度，$\\mathbf{S}_f = \\mathbf{n}_f \\Delta s_f$ 是指向外部的面法向矢量，其大小为面的长度。待比较的两种方案仅在对面值 $\\phi_f$ 的近似上有所不同。\n\n### 基于单元的 Green-Gauss 重构\n\n在基于单元的方法中，标量场值 $\\phi_c$ 在网格单元的质心处是已知的。对于分隔单元 $P$ 及其邻居 $N_f$ 的面 $f$，面值 $\\phi_f$ 通过在两个单元中心值之间进行线性插值来近似。最简单的插值是直接取平均值：\n$$\n\\phi_f \\approx \\frac{\\phi_P + \\phi_{N_f}}{2}\n$$\n将此代入通用公式，得到基于单元的梯度重构：\n$$\n(\\nabla \\phi)_P^{\\text{cell-based}} = \\frac{1}{A_P} \\sum_f \\left( \\frac{\\phi_P + \\phi_{N_f}}{2} \\right) \\mathbf{S}_f\n$$\n该近似假设面值可以很好地由相邻单元中心值的平均值表示。当网格是正交的（即连接质心 $\\mathbf{c}_P$ 和 $\\mathbf{c}_{N_f}$ 的矢量与面法线 $\\mathbf{n}_f$ 平行）且规则时，此假设的精度最高。随着网格偏斜度和非正交性的增加，精度会显著下降。\n\n### 基于节点的 Green-Gauss 重构\n\n在基于节点的方法中，标量场值 $\\phi_v$ 在网格的顶点处是已知的。对于连接顶点 $v_1$ 和 $v_2$ 的面 $f$，面值 $\\phi_f$ 通过其端点值的平均值来近似：\n$$\n\\phi_f \\approx \\frac{\\phi_{v_1(f)} + \\phi_{v_2(f)}}{2}\n$$\n这个近似表示了 $\\phi$ 在面中点处的值。最终的重构公式是：\n$$\n(\\nabla \\phi)_P^{\\text{node-based}} = \\frac{1}{A_P} \\sum_f \\left( \\frac{\\phi_{v_1(f)} + \\phi_{v_2(f)}}{2} \\right) \\mathbf{S}_f\n$$\n该方法使用的信息在几何上是面自身的局部信息，使其不那么直接依赖于单元质心的相对位置。因此，它对网格的非正交性通常更具鲁棒性，并且与基于单元的方案相比，对于更广泛类别的网格，通常被认为是形式上二阶精度的。\n\n### 算法实现与分析\n\n实现过程首先为四个测试用例中的每一个生成点云，并使用 `scipy.spatial.Delaunay` 进行 Delaunay 三角剖分。这提供了网格的连接性（单纯形和邻居）。一个关键的预处理步骤是确保所有三角形都有一致的顶点排序（例如，逆时针），以便明确定义指向外部的法向矢量 $\\mathbf{S}_f$。这通过检查三角形面积的符号并在必要时重新排序顶点来实现。\n\n对于四个生成的网格中的每一个，执行以下步骤：\n1.  在所有网格顶点处计算解析标量场 $\\phi(x,y) = \\sin(2x) + 0.5 \\cos(3y) + x y$ 以获得顶点值 $\\phi_v$，在所有三角形质心处计算以获得单元中心值 $\\phi_c$。\n2.  算法遍历所有内部三角形，这些三角形被定义为在所有三条边上都有有效邻居的三角形。此限制避免了处理边界条件时的模糊性。\n3.  对于每个内部三角形，应用基于单元和基于节点的梯度重构公式来计算近似梯度矢量。\n4.  在三角形的质心处计算精确梯度 $\\nabla \\phi(x,y) = (2\\cos(2x) + y, -1.5 \\sin(3y) + x)$。\n5.  每种方案的误差计算为近似梯度矢量与精确梯度矢量之差的欧几里得范数。\n6.  对两种方案，计算所有内部三角形的这些误差的平均值。\n7.  最后，记录一个布尔值，指示基于节点的方案的平均误差是否严格小于基于单元的方案。\n\n### 网格特性分析\n\n这四个测试用例旨在探究方法在不同网格条件下的性能：\n-   **案例 1（结构化格网）**：高质量、均匀的网格，非正交性低。预计两种方法都表现良好，基于节点的方法可能因其更高的形式精度阶数而略有优势。\n-   **案例 2（扭曲网格）**：随机扰动引入了显著的网格偏斜度和非正交性。基于单元的方法关于质心到质心插值的核心假设被违反，导致精度大幅下降。预计对这一点不太敏感的基于节点的方法会显著更精确。\n-   **案例 3（各向异性拉伸网格）**：网格被拉伸，产生大纵横比的三角形。这测试了对几何各向异性的鲁棒性。虽然这对两种方法都具挑战性，但基于节点的方案对局部顶点数据的依赖应比基于单元的方案对可能距离较远且未对齐的质心的依赖更具弹性。\n-   **案例 4（聚集的非规则点集）**：增加一个密集的点集群会产生一个高度不均匀的网格，单元大小、形状和顶点价都有很大变化。这种复杂的拓扑结构严重考验了基于单元方案的几何假设。在这种情况下，预计基于节点的重构将显著更精确。\n\n实现的结果将证实这些预期，表明基于节点的 Green-Gauss 重构通常更精确，尤其是在偏离规则性和正交性的网格上。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import Delaunay\n\ndef solve():\n    \"\"\"\n    Implements and compares cell-based and node-based Green-Gauss gradient\n    reconstructions on four different mesh types.\n    \"\"\"\n\n    # Define the analytical scalar field and its exact gradient.\n    # All trigonometric function arguments are in radians.\n    def phi_func(p):\n        x, y = p[:, 0], p[:, 1]\n        return np.sin(2 * x) + 0.5 * np.cos(3 * y) + x * y\n\n    def grad_phi_func(p):\n        x, y = p[:, 0], p[:, 1]\n        grad_x = 2 * np.cos(2 * x) + y\n        grad_y = -1.5 * np.sin(3 * y) + x\n        return np.stack([grad_x, grad_y], axis=1)\n\n    def generate_points(case_id, seed):\n        \"\"\"Generates point clouds for the four test cases.\"\"\"\n        rng = np.random.default_rng(seed)\n        nx, ny = 25, 20\n        x = np.linspace(0, 1, nx)\n        y = np.linspace(0, 1, ny)\n        xx, yy = np.meshgrid(x, y)\n        base_points = np.vstack([xx.ravel(), yy.ravel()]).T\n\n        if case_id == 1: # Structured lattice\n            return base_points\n        elif case_id == 2: # Skewed grid\n            eps = 0.08\n            perturbations = rng.uniform(-eps, eps, size=base_points.shape)\n            return base_points + perturbations\n        elif case_id == 3: # Anisotropic stretched grid\n            eps = 0.04\n            stretched_points = base_points.copy()\n            stretched_points[:, 1] *= 0.2\n            perturbations = rng.uniform(-eps, eps, size=stretched_points.shape)\n            return stretched_points + perturbations\n        elif case_id == 4: # Clustered irregular set\n            n_extra = 400\n            radius = 0.3\n            center = np.array([0.5, 0.5])\n            \n            # Sample points uniformly in a disk\n            r = radius * np.sqrt(rng.uniform(0, 1, size=n_extra))\n            theta = 2 * np.pi * rng.uniform(0, 1, size=n_extra)\n            extra_points = np.zeros((n_extra, 2))\n            extra_points[:, 0] = center[0] + r * np.cos(theta)\n            extra_points[:, 1] = center[1] + r * np.sin(theta)\n            \n            return np.vstack([base_points, extra_points])\n        else:\n            raise ValueError(\"Invalid case_id\")\n\n    def compute_gg_errors(points):\n        \"\"\"\n        Computes mean errors for cell-based and node-based GG reconstructions.\n        \"\"\"\n        tri = Delaunay(points)\n        simplices = tri.simplices\n        neighbors = tri.neighbors\n\n        # Identify interior triangles (no boundary edges)\n        interior_tri_indices = np.where(np.all(neighbors != -1, axis=1))[0]\n\n        # Pre-compute geometric properties\n        num_tris = len(simplices)\n        areas = np.zeros(num_tris)\n        centroids = np.zeros((num_tris, 2))\n        # normals will store [S_f0, S_f1, S_f2] for each triangle, where S_fi is opposite vertex i\n        normals = np.zeros((num_tris, 3, 2)) \n\n        for i in range(num_tris):\n            v_indices = simplices[i]\n            verts = points[v_indices]\n            \n            # Ensure CCW ordering for consistent outward normals\n            # Signed area calculation\n            signed_area = 0.5 * ((verts[1, 0] - verts[0, 0]) * (verts[2, 1] - verts[0, 1]) - \n                                 (verts[2, 0] - verts[0, 0]) * (verts[1, 1] - verts[0, 1]))\n\n            if signed_area  0:\n                v_indices = np.array([v_indices[0], v_indices[2], v_indices[1]])\n                simplices[i] = v_indices # Update simplices array\n                verts = points[v_indices]\n                areas[i] = -signed_area\n            else:\n                areas[i] = signed_area\n\n            centroids[i] = np.mean(verts, axis=0)\n\n            # Face normal vectors S_f = n_f * |edge_length|.\n            # The edge opposite vertex 0 is between vertices 1 and 2.\n            # Rule for outward normal of edge p1->p2: (y2-y1, -(x2-x1))\n            normals[i, 0, :] = [verts[2, 1] - verts[1, 1], -(verts[2, 0] - verts[1, 0])] # Opp. v0\n            normals[i, 1, :] = [verts[0, 1] - verts[2, 1], -(verts[0, 0] - verts[2, 0])] # Opp. v1\n            normals[i, 2, :] = [verts[1, 1] - verts[0, 1], -(verts[1, 0] - verts[0, 0])] # Opp. v2\n\n        # Evaluate scalar field at cell centroids and vertices\n        phi_c = phi_func(centroids)\n        phi_v = phi_func(points)\n\n        cell_errors = []\n        node_errors = []\n\n        exact_grads_at_centroids = grad_phi_func(centroids)\n\n        for i in interior_tri_indices:\n            p_area = areas[i]\n            p_v_indices = simplices[i]\n            p_neighbors = neighbors[i]\n\n            # --- Cell-based reconstruction ---\n            grad_cell = np.zeros(2)\n            phi_p = phi_c[i]\n            \n            # Edge opp v0 (between v1,v2), neighbor is n0\n            phi_n0 = phi_c[p_neighbors[0]]\n            phi_f0 = 0.5 * (phi_p + phi_n0)\n            grad_cell += phi_f0 * normals[i, 0, :]\n\n            # Edge opp v1 (between v2,v0), neighbor is n1\n            phi_n1 = phi_c[p_neighbors[1]]\n            phi_f1 = 0.5 * (phi_p + phi_n1)\n            grad_cell += phi_f1 * normals[i, 1, :]\n\n            # Edge opp v2 (between v0,v1), neighbor is n2\n            phi_n2 = phi_c[p_neighbors[2]]\n            phi_f2 = 0.5 * (phi_p + phi_n2)\n            grad_cell += phi_f2 * normals[i, 2, :]\n            \n            grad_cell /= p_area\n            \n            # --- Node-based reconstruction ---\n            grad_node = np.zeros(2)\n            phi_v0, phi_v1, phi_v2 = phi_v[p_v_indices]\n\n            # Contribution from edge between v1 and v2\n            phi_f_12 = 0.5 * (phi_v1 + phi_v2) \n            grad_node += phi_f_12 * normals[i, 0, :]\n            \n            # Contribution from edge between v2 and v0\n            phi_f_20 = 0.5 * (phi_v2 + phi_v0)\n            grad_node += phi_f_20 * normals[i, 1, :]\n            \n            # Contribution from edge between v0 and v1\n            phi_f_01 = 0.5 * (phi_v0 + phi_v1)\n            grad_node += phi_f_01 * normals[i, 2, :]\n\n            grad_node /= p_area\n\n            # --- Error calculation ---\n            exact_grad = exact_grads_at_centroids[i]\n            cell_errors.append(np.linalg.norm(grad_cell - exact_grad))\n            node_errors.append(np.linalg.norm(grad_node - exact_grad))\n            \n        return np.mean(cell_errors), np.mean(node_errors)\n\n    # Main execution loop\n    test_cases = [1, 2, 3, 4]\n    results = []\n    for case_id in test_cases:\n        points = generate_points(case_id, seed=42)\n        mean_cell_err, mean_node_err = compute_gg_errors(points)\n        is_node_better = mean_node_err  mean_cell_err\n        results.append(str(is_node_better).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3325671"}]}