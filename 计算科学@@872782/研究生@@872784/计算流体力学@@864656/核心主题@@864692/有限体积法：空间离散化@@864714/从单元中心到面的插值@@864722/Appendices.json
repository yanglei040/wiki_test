{"hands_on_practices": [{"introduction": "线性守恒是计算流体动力学中插值格式的一个基本要求。本练习将展示一个简单的算术平均法，虽然它在均匀正交网格上有效，但在非正交网格上却会失效。通过这个反例，你将具体理解为何几何因素至关重要，以及网格的非正交性如何直接引入插值误差。", "problem": "考虑在有限体积法 (FVM) 下的二维计算流体动力学 (CFD) 设置，其中面心通量需要对单元中心值进行插值。如果对于任何线性标量场，插值都能在面心处再现精确值，则称该面插值为保持线性的。仅从线性标量场和欧几里得 (Euclidean) 几何的定义出发，分析以下故意设置的倾斜网格和朴素插值规则。\n\n该网格由两个相邻的凸控制体组成，其单元中心分别位于 $\\boldsymbol{C}_{L}=(0,0)$ 和 $\\boldsymbol{C}_{R}=(1,0)$，它们共享一个公共直面，该面的面心位于 $\\boldsymbol{F}=(0.6,0.2)$。考虑标量场 $u(x,y)=a\\,x+b\\,y$，其中 $a$ 和 $b$ 为实常数。面上的值通过相邻单元中心值的简单算术平均值来近似，\n$$u_{f}^{\\mathrm{interp}}=\\frac{1}{2}\\big(u(\\boldsymbol{C}_{L})+u(\\boldsymbol{C}_{R})\\big).$$\n\n仅使用给定的几何形状和线性函数的基本性质，计算插值误差\n$$\\varepsilon=u_{f}^{\\mathrm{interp}}-u(\\boldsymbol{F}).$$\n将您的最终答案表示为关于 $a$ 和 $b$ 的单个简化解析表达式，不带单位。", "solution": "所述问题具有科学依据、是适定的、客观的，并且包含得出唯一解所需的所有信息。该设置是计算流体动力学中一个标准的教学案例，用于分析倾斜网格上插值格式的误差。因此，该问题是有效的，我们继续进行求解。\n\n该问题要求在指定的二维网格上，对给定的线性标量场计算插值误差 $\\varepsilon$。误差定义为面上的插值 $u_{f}^{\\mathrm{interp}}$ 与面心的精确值 $u(\\boldsymbol{F})$ 之间的差值。\n\n提供的信息如下：\n- 左侧控制体的单元中心：$\\boldsymbol{C}_{L} = (0, 0)$。\n- 右侧控制体的单元中心：$\\boldsymbol{C}_{R} = (1, 0)$。\n- 共享面的面心：$\\boldsymbol{F} = (0.6, 0.2)$。为精确起见，我们将使用等价的分数形式 $\\boldsymbol{F} = (\\frac{3}{5}, \\frac{1}{5})$。\n- 线性标量场：$u(x,y) = a\\,x + b\\,y$。\n- 插值规则：$u_{f}^{\\mathrm{interp}} = \\frac{1}{2}\\big(u(\\boldsymbol{C}_{L}) + u(\\boldsymbol{C}_{R})\\big)$。\n- 待计算的量：$\\varepsilon = u_{f}^{\\mathrm{interp}} - u(\\boldsymbol{F})$。\n\n我们的推导分三步进行：首先，计算插值 $u_{f}^{\\mathrm{interp}}$。其次，计算精确值 $u(\\boldsymbol{F})$。最后，计算它们的差值以求得误差 $\\varepsilon$。\n\n步骤1：计算插值 $u_{f}^{\\mathrm{interp}}$。\n我们在两个单元中心 $\\boldsymbol{C}_{L}$ 和 $\\boldsymbol{C}_{R}$ 处计算标量场 $u(x,y)$ 的值。\n在左侧中心 $\\boldsymbol{C}_{L} = (0, 0)$ 处：\n$$u(\\boldsymbol{C}_{L}) = u(0, 0) = a(0) + b(0) = 0$$\n在右侧中心 $\\boldsymbol{C}_{R} = (1, 0)$ 处：\n$$u(\\boldsymbol{C}_{R}) = u(1, 0) = a(1) + b(0) = a$$\n现在，我们应用指定的插值规则，即两个单元中心值的简单算术平均值：\n$$u_{f}^{\\mathrm{interp}} = \\frac{1}{2}\\big(u(\\boldsymbol{C}_{L}) + u(\\boldsymbol{C}_{R})\\big) = \\frac{1}{2}(0 + a) = \\frac{a}{2}$$\n\n注意到这个插值的几何意义是有启发性的。线性函数的一个基本性质是，函数在线段中点的值是其在两个端点处值的算术平均值。这个插值点，我们称之为 $\\boldsymbol{M}$，是连接 $\\boldsymbol{C}_{L}$ 和 $\\boldsymbol{C}_{R}$ 的线段的中点：\n$$\\boldsymbol{M} = \\frac{1}{2}(\\boldsymbol{C}_{L} + \\boldsymbol{C}_{R}) = \\frac{1}{2}\\big((0,0) + (1,0)\\big) = (\\frac{1}{2}, 0)$$\n插值 $u_{f}^{\\mathrm{interp}}$ 正是线性场 $u$ 在这一点 $\\boldsymbol{M}$ 处的值：\n$$u(\\boldsymbol{M}) = u(\\frac{1}{2}, 0) = a(\\frac{1}{2}) + b(0) = \\frac{a}{2}$$\n这证实了我们的计算。这种简单的平均格式隐含地假设了面心位于连接两个单元中心的线段的中点。对于倾斜网格，情况并非如此，而这正是误差的来源。\n\n步骤2：计算面心处的精确值 $u(\\boldsymbol{F})$。\n精确值通过在面心坐标 $\\boldsymbol{F} = (\\frac{3}{5}, \\frac{1}{5})$ 处计算函数 $u(x,y)$ 的值得到。\n$$u(\\boldsymbol{F}) = u(\\frac{3}{5}, \\frac{1}{5}) = a(\\frac{3}{5}) + b(\\frac{1}{5}) = \\frac{3a}{5} + \\frac{b}{5}$$\n\n步骤3：计算插值误差 $\\varepsilon$。\n误差是插值与精确值之间的差。\n$$\\varepsilon = u_{f}^{\\mathrm{interp}} - u(\\boldsymbol{F})$$\n代入前面步骤中推导出的表达式：\n$$\\varepsilon = \\frac{a}{2} - \\left(\\frac{3a}{5} + \\frac{b}{5}\\right)$$\n我们将含有 $a$ 和 $b$ 的项分组：\n$$\\varepsilon = \\left(\\frac{1}{2} - \\frac{3}{5}\\right)a - \\frac{1}{5}b$$\n为了合并 $a$ 的系数，我们找到公分母 $10$：\n$$\\varepsilon = \\left(\\frac{5}{10} - \\frac{6}{10}\\right)a - \\frac{2}{10}b$$\n$$\\varepsilon = -\\frac{1}{10}a - \\frac{2}{10}b$$\n这个表达式可以简化为单个分数：\n$$\\varepsilon = -\\frac{a + 2b}{10}$$\n对于任意常数 $a$ 和 $b$，该误差不为零，这表明这种简单的插值格式在给定的倾斜网格上不具有线性保持性。误差取决于标量场的梯度 $\\nabla u = (a, b)$ 和网格的几何倾斜度，后者由插值点 $\\boldsymbol{M}$ 和真实面心 $\\boldsymbol{F}$ 之间的向量差表示。\n$\\boldsymbol{M} - \\boldsymbol{F} = (\\frac{1}{2} - \\frac{3}{5}, 0 - \\frac{1}{5}) = (\\frac{5-6}{10}, -\\frac{1}{5}) = (-\\frac{1}{10}, -\\frac{1}{5})$.\n误差为 $\\varepsilon = u(\\boldsymbol{M}) - u(\\boldsymbol{F}) = \\nabla u \\cdot (\\boldsymbol{M} - \\boldsymbol{F}) = (a,b)\\cdot(-\\frac{1}{10}, -\\frac{2}{10}) = -\\frac{a}{10}-\\frac{2b}{10} = -\\frac{a+2b}{10}$，这严格地证实了我们的结果。", "answer": "$$\n\\boxed{-\\frac{a + 2b}{10}}\n$$", "id": "3337138"}, {"introduction": "认识到插值可能不准确之后，我们需要一种方法来更系统地量化这种误差。本练习运用傅里叶分析这一经典数值方法分析技术，来研究中点插值格式的误差。推导误差传递函数将揭示格式的精度如何依赖于待解析特征的波长与网格尺寸的相对关系，从而让你深入理解数值耗散的概念。", "problem": "在一维空间中，考虑一个用于计算流体力学 (CFD) 的均匀有限体积网格，其单元中心位于 $x_{c}^{-} = x_{f} - \\frac{\\Delta x}{2}$ 和 $x_{c}^{+} = x_{f} + \\frac{\\Delta x}{2}$ 位置，包围着一个位于 $x_{f}$ 的单元面。一个标量场由 $u(x) = \\sin(k x)$ 给出，其中 $k$ 是实数波数，$\\Delta x$ 是均匀的单元尺寸。中点插值使用相邻单元中心的采样值构造了单元面上值的近似，\n$$\n\\tilde{u}_{f} \\equiv \\frac{1}{2}\\big(u(x_{c}^{-}) + u(x_{c}^{+})\\big).\n$$\n将误差传递函数定义为单元面上的相对误差，\n$$\nE(\\theta) \\equiv \\frac{\\tilde{u}_{f}}{u(x_{f})} - 1,\n$$\n其中 $\\theta \\equiv k \\Delta x$。从上述定义和标准三角恒等式出发，推导出一个仅依赖于 $\\theta$ 的 $E(\\theta)$ 的闭式表达式。你的最终答案必须是只含 $\\theta$ 的单个解析表达式。不需要四舍五入，也不需要单位。", "solution": "问题陈述经过严格验证，被认为是自洽的、有科学依据且适定的。所有定义在偏微分方程数值方法领域内都是标准的，特别是在有限体积和有限差分格式的分析中。该问题要求推导应用于正弦场的中点插值格式的误差传递函数的闭式表达式。我们将进行形式化推导。\n\n目标是找到误差传递函数 $E(\\theta)$ 的表达式，其定义为\n$$\nE(\\theta) \\equiv \\frac{\\tilde{u}_{f}}{u(x_{f})} - 1,\n$$\n其中 $\\tilde{u}_{f}$ 是位于 $x_{f}$ 的单元面上的插值，而 $u(x_{f})$ 是精确值。\n\n首先，我们写下面上值 $\\tilde{u}_{f}$ 的中点插值定义。它是两个相邻单元中心 $x_{c}^{-}$ 和 $x_{c}^{+}$ 处值的算术平均值：\n$$\n\\tilde{u}_{f} = \\frac{1}{2} \\left( u(x_{c}^{-}) + u(x_{c}^{+}) \\right).\n$$\n\n单元中心的位置相对于单元面位置 $x_{f}$ 和均匀单元尺寸 $\\Delta x$ 给出如下：\n$$\nx_{c}^{-} = x_{f} - \\frac{\\Delta x}{2},\n$$\n$$\nx_{c}^{+} = x_{f} + \\frac{\\Delta x}{2}.\n$$\n\n标量场 $u(x)$ 由单个傅里叶模态给出：\n$$\nu(x) = \\sin(k x),\n$$\n其中 $k$ 是波数。\n\n我们将单元中心位置和标量场的表达式代入 $\\tilde{u}_{f}$ 的定义中：\n$$\n\\tilde{u}_{f} = \\frac{1}{2} \\left( \\sin\\left(k x_{c}^{-}\\right) + \\sin\\left(k x_{c}^{+}\\right) \\right)\n$$\n$$\n\\tilde{u}_{f} = \\frac{1}{2} \\left( \\sin\\left(k \\left(x_{f} - \\frac{\\Delta x}{2}\\right)\\right) + \\sin\\left(k \\left(x_{f} + \\frac{\\Delta x}{2}\\right)\\right) \\right).\n$$\n\n展开正弦函数的自变量，我们得到：\n$$\n\\tilde{u}_{f} = \\frac{1}{2} \\left( \\sin\\left(k x_{f} - \\frac{k \\Delta x}{2}\\right) + \\sin\\left(k x_{f} + \\frac{k \\Delta x}{2}\\right) \\right).\n$$\n\n为了简化此表达式，我们使用标准的三角和差化积恒等式：\n$$\n\\sin(A) + \\sin(B) = 2 \\sin\\left(\\frac{A+B}{2}\\right) \\cos\\left(\\frac{A-B}{2}\\right).\n$$\n\n让我们从 $\\tilde{u}_{f}$ 的表达式中确定 $A$ 和 $B$：\n$$\nA = k x_{f} - \\frac{k \\Delta x}{2},\n$$\n$$\nB = k x_{f} + \\frac{k \\Delta x}{2}.\n$$\n\n现在，我们计算恒等式所需的项：\n$$\n\\frac{A+B}{2} = \\frac{\\left(k x_{f} - \\frac{k \\Delta x}{2}\\right) + \\left(k x_{f} + \\frac{k \\Delta x}{2}\\right)}{2} = \\frac{2 k x_{f}}{2} = k x_{f}.\n$$\n$$\n\\frac{A-B}{2} = \\frac{\\left(k x_{f} - \\frac{k \\Delta x}{2}\\right) - \\left(k x_{f} + \\frac{k \\Delta x}{2}\\right)}{2} = \\frac{-k \\Delta x}{2} = -\\frac{k \\Delta x}{2}.\n$$\n\n将这些代回和差化积恒等式，正弦项的和变为：\n$$\n\\sin\\left(k x_{f} - \\frac{k \\Delta x}{2}\\right) + \\sin\\left(k x_{f} + \\frac{k \\Delta x}{2}\\right) = 2 \\sin(k x_{f}) \\cos\\left(-\\frac{k \\Delta x}{2}\\right).\n$$\n\n利用余弦函数是偶函数，即 $\\cos(-z) = \\cos(z)$ 的性质，我们有：\n$$\n2 \\sin(k x_{f}) \\cos\\left(-\\frac{k \\Delta x}{2}\\right) = 2 \\sin(k x_{f}) \\cos\\left(\\frac{k \\Delta x}{2}\\right).\n$$\n\n现在，我们将这个简化结果代回 $\\tilde{u}_{f}$ 的表达式中：\n$$\n\\tilde{u}_{f} = \\frac{1}{2} \\left[ 2 \\sin(k x_{f}) \\cos\\left(\\frac{k \\Delta x}{2}\\right) \\right] = \\sin(k x_{f}) \\cos\\left(\\frac{k \\Delta x}{2}\\right).\n$$\n\n接下来，我们计算比率 $\\frac{\\tilde{u}_{f}}{u(x_{f})}$。面上的精确值为 $u(x_{f}) = \\sin(k x_{f})$。因此，\n$$\n\\frac{\\tilde{u}_{f}}{u(x_{f})} = \\frac{\\sin(k x_{f}) \\cos\\left(\\frac{k \\Delta x}{2}\\right)}{\\sin(k x_{f})}.\n$$\n该比率对所有满足 $\\sin(k x_f) \\neq 0$ 的 $x_f$ 均有效。通过消去项 $\\sin(k x_f)$，表达式得以简化，从而消除了对面位置 $x_f$ 的表面依赖性以及在波节处的奇点。结果是：\n$$\n\\frac{\\tilde{u}_{f}}{u(x_{f})} = \\cos\\left(\\frac{k \\Delta x}{2}\\right).\n$$\n\n问题将无量纲波数定义为 $\\theta \\equiv k \\Delta x$。将其代入我们的表达式，得到：\n$$\n\\frac{\\tilde{u}_{f}}{u(x_{f})} = \\cos\\left(\\frac{\\theta}{2}\\right).\n$$\n\n最后，我们使用误差传递函数 $E(\\theta)$ 的定义：\n$$\nE(\\theta) = \\frac{\\tilde{u}_{f}}{u(x_{f})} - 1.\n$$\n将我们刚刚推导出的比率表达式代入，得到仅含 $\\theta$ 的 $E(\\theta)$ 的最终闭式表达式：\n$$\nE(\\theta) = \\cos\\left(\\frac{\\theta}{2}\\right) - 1.\n$$\n此函数量化了由中点插值引入的幅值误差。对于被网格良好解析的波（即 $\\theta \\ll 1$），误差很小，因为 $\\cos(\\theta/2) \\approx 1$。对于处于网格奈奎斯特极限的波，其中 $\\Delta x = \\lambda/2$ 且 $\\theta = k \\Delta x = (2\\pi/\\lambda)(\\lambda/2) = \\pi$，误差为 $E(\\pi) = \\cos(\\pi/2) - 1 = -1$，这表明对于此特定模态，插值幅值被完全衰减。", "answer": "$$\n\\boxed{\\cos\\left(\\frac{\\theta}{2}\\right) - 1}\n$$", "id": "3337085"}, {"introduction": "理论分析为我们提供了关于格式性能的预期（例如其精度阶数），但计算验证是确保代码实现正确的黄金标准。这个综合性练习将指导你使用“人造解方法”（Method of Manufactured Solutions, MMS），这是工程和科学计算中的一个标准验证程序。通过实现和测试几种常见的插值格式，你将通过计算验证它们的理论精度阶数，从而架起数学理论与实际软件验证之间的桥梁。", "problem": "考虑在二维笛卡尔域 $[0,1]\\times[0,1]$ 上，一个标量场的从网格中心到网格面的有限体积插值。我们将使用人造解方法（MMS），其精确解为 $u(x,y)=\\exp(x+y)$，该解在定义域上无限可微且严格为正。\n\n基本原理和定义：\n- 有限体积法将场量 $u$ 存储在网格中心，并需要 $u$ 在网格面中心的近似值来计算一致的通量。面插值算子是一个将网格中心的值映射到网格面中心 $u$ 的估计值的算子。\n- 对于一个在 $x$ 方向有 $N_x$ 个网格、在 $y$ 方向有 $N_y$ 个网格的均匀网格，令 $\\Delta x = 1/N_x$ 和 $\\Delta y = 1/N_y$。节点坐标为 $x_k = k\\Delta x$（$k=0,\\dots,N_x$）和 $y_\\ell = \\ell\\Delta y$（$\\ell=0,\\dots,N_y$）。网格中心坐标为 $x_i^c = (x_i + x_{i+1})/2$ 和 $y_j^c = (y_j + y_{j+1})/2$。\n- 对于在 $[0,1]$ 内节点为 $\\{x_k\\}_{k=0}^{N_x}$ 和 $\\{y_\\ell\\}_{\\ell=0}^{N_y}$ 的非均匀网格，网格中心坐标为 $x_i^c = (x_i + x_{i+1})/2$ 和 $y_j^c = (y_j + y_{j+1})/2$，面中心位于垂直面的 $x_{i+1}$ 处和水平面的 $y_{j+1}$ 处。\n- 面插值的离散 $L^2$ 误差定义为\n$$\nE = \\left(\\frac{1}{N_f}\\sum_{f\\in\\mathcal{F}}\\left(\\hat{u}_f - u(x_f,y_f)\\right)^2\\right)^{1/2},\n$$\n其中 $\\mathcal{F}$ 是所考虑的所有面中心的集合（包括垂直和水平的内部面），$N_f$ 是面的总数，$\\hat{u}_f$ 是在面 $f$ 上的插值。\n\n需要实现的插值格式：\n- 具有正平流分量的迎风格式（分段常数）：在网格 $(i,j)$ 和 $(i+1,j)$ 之间的垂直面上，使用左侧网格中心的值；在网格 $(i,j)$ 和 $(i,j+1)$ 之间的水平面上，使用底部网格中心的值。这对应于为具有正分量的恒定平流向量选择上游网格的值。\n- 中心算术平均：在网格 $(i,j)$ 和 $(i+1,j)$ 之间的垂直面上，使用 $(u_{i,j}+u_{i+1,j})/2$；在网格 $(i,j)$ 和 $(i,j+1)$ 之间的水平面上，使用 $(u_{i,j}+u_{i,j+1})/2$。\n- 非均匀网格上的距离加权线性插值：在网格中心 $x_L=x_i^c$ 和 $x_R=x_{i+1}^c$ 之间的垂直面 $x_f=x_{i+1}$ 处，定义\n$$\n\\hat{u}_f = \\frac{x_R - x_f}{x_R - x_L}u_L + \\frac{x_f - x_L}{x_R - x_L}u_R,\n$$\n对于 $y_L=y_j^c$ 和 $y_R=y_{j+1}^c$ 的水平面 $y_f=y_{j+1}$，可做类似处理。\n\n观测精度阶：\n- 对于由网格参数 $h$ 表征的一系列网格，定义 $h=\\max\\{\\max_i(x_{i+1}-x_i), \\max_j(y_{j+1}-y_j)\\}$。通过对网格序列进行线性最小二乘拟合 $\\log E \\approx \\log C + p \\log h$ 来获得观测阶 $p$，并报告其斜率 $p$。\n\n所需计算：\n- 设计以下网格并计算面插值，以使用 $u(x,y)=\\exp(x+y)$ 验证上述三种格式的观测精度阶：\n    1. 对迎风格式，使用 $N_x=N_y\\in\\{16,32,64,128\\}$ 的均匀网格。\n    2. 对中心算术平均格式，使用 $N_x=N_y\\in\\{16,32,64,128\\}$ 的均匀网格。\n    3. 对距离加权线性插值，使用节点为 $x_k=(k/N_x)^2$、$y_\\ell=(\\ell/N_y)^2$ 且 $N_x=N_y\\in\\{20,40,80,160\\}$ 的拉伸非均匀网格。\n- 对于序列中的每个网格，使用面中心的精确值 $u(x_f,y_f)=\\exp(x_f+y_f)$，计算所有内部垂直和水平面上的离散 $L^2$ 误差 $E$。\n- 对于上述三种情况中的每一种，通过对给定网格尺寸下的 $\\log E$ 与 $\\log h$ 进行线性拟合，计算插值格式的观测阶 $p$。\n\n测试套件和最终输出规范：\n- 测试套件包含三组参数集：\n    - 情况 A：格式为迎风格式，网格类型为均匀网格，尺寸为 (16,16), (32,32), (64,64), (128,128)。\n    - 情况 B：格式为中心平均，网格类型为均匀网格，尺寸为 (16,16), (32,32), (64,64), (128,128)。\n    - 情况 C：格式为距离加权线性插值，网格类型为拉伸网格，尺寸为 (20,20), (40,40), (80,80), (160,160)。\n- 预期输出为三个浮点数，每个浮点数是对应情况的观测阶 $p$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[pA,pB,pC]\"）。每个 $p$ 值必须四舍五入到三位小数。不涉及物理单位，也不需要角度或百分比。", "solution": "目标是确定在二维笛卡尔域 $[0,1]\\times[0,1]$ 上，三种不同有限体积插值格式的观测精度阶。这是通过使用人造解方法（MMS）实现的，该方法使用一个已知的、光滑的解析解作为基准，来量化数值方法的离散化误差。\n\n精确解为 $u(x,y) = \\exp(x+y)$。网格中心值，记为 $u_{i,j}$，是通过在每个网格 $(i,j)$ 的中心计算该精确解得到的，即 $u_{i,j} = u(x_i^c, y_j^c)$。插值格式提供了在每个面 $f$ 的中心处场值的近似值 $\\hat{u}_f$。插值的误差是与在同一面中心计算的精确解 $u(x_f, y_f)$ 进行比较测量的。\n\n误差使用离散 $L^2$ 范数进行量化，定义为：\n$$\nE = \\left(\\frac{1}{N_f}\\sum_{f\\in\\mathcal{F}}\\left(\\hat{u}_f - u(x_f,y_f)\\right)^2\\right)^{1/2}\n$$\n其中 $\\mathcal{F}$ 是所有内部面（垂直和水平）的集合，$N_f$ 是这些面的总数，$\\hat{u}_f$ 是在面 $f$ 上的插值，而 $u(x_f, y_f)$ 是精确值。对于一个 $N_x \\times N_y$ 的网格，有 $N_y(N_x-1)$ 个内部垂直面和 $N_x(N_y-1)$ 个内部水平面，因此 $N_f = N_y(N_x-1) + N_x(N_y-1)$。\n\n精度阶 $p$ 描述了当网格加密时误差 $E$ 如何减小。它由关系式 $E \\approx C h^p$ 决定，其中 $C$ 是一个常数，$h$ 是特征网格尺寸。对该关系式取对数可得 $\\log E \\approx \\log C + p \\log h$。因此，我们可以通过对从一系列网格尺寸逐渐减小的网格中获得的 $(\\log h, \\log E)$ 数据点集进行线性拟合，将其斜率作为 $p$ 来计算。网格参数 $h$ 定义为网格中最大的网格边长，即 $h=\\max\\{\\max_i(x_{i+1}-x_i), \\max_j(y_{j+1}-y_j)\\}$。\n\n分析过程如下：实现三个指定的格式，计算给定序列中每个网格的误差 $E$，然后对经过对数转换的数据进行线性最小二乘回归，以找到精度阶 $p$。\n\n**情况 A：均匀网格上的迎风格式**\n迎风格式，对于具有正速度分量的平流场，使用上游网格的值来近似面上的值。\n- 对于位于网格 $(i,j)$ 和 $(i+1,j)$ 之间的垂直面 $x_{i+1}$，上游网格是 $(i,j)$，因此 $\\hat{u}_f = u_{i,j}$。\n- 对于位于网格 $(i,j)$ 和 $(i,j+1)$ 之间的水平面 $y_{j+1}$，上游网格是 $(i,j)$，因此 $\\hat{u}_f = u_{i,j}$。\n该格式使用场的分段常数重构。对于 $N_x=N_y=N \\in \\{16, 32, 64, 128\\}$ 的均匀网格序列，网格尺寸为 $h = \\Delta x = \\Delta y = 1/N$。网格中心值为 $u_{i,j} = \\exp(x_i^c + y_j^c)$。在每个内部面上计算误差，并通过 $\\log E$ 对 $\\log h$ 的斜率确定阶数 $p$。该格式理论上具有一阶精度，因此我们预期 $p \\approx 1$。\n\n**情况 B：均匀网格上的中心算术平均格式**\n中心格式将面上的值近似为两个相邻网格值的算术平均。\n- 对于垂直面：$\\hat{u}_f = (u_{i,j} + u_{i+1,j})/2$。\n- 对于水平面：$\\hat{u}_f = (u_{i,j} + u_{i,j+1})/2$。\n这等效于在均匀网格上的线性插值，因为面中心恰好位于两个相邻网格中心的中点。使用与情况 A 相同的均匀网格序列。该格式理论上具有二阶精度，因此我们预期 $p \\approx 2$。\n\n**情况 C：拉伸网格上的距离加权线性插值**\n该格式是一种适用于非均匀网格的广义线性插值。对于位于两个网格中心 $L$（左/下）和 $R$（右/上）之间的面 $f$，插值是网格中心值 $u_L$ 和 $u_R$ 的加权平均。\n- 对于垂直面 $x_f=x_{i+1}$，网格中心为 $x_L=x_i^c$ 和 $x_R=x_{i+1}^c$：\n$$\n\\hat{u}_f = \\frac{x_R - x_f}{x_R - x_L}u_L + \\frac{x_f - x_L}{x_R - x_L}u_R\n$$\n其中 $u_L=u_{i,j}$，$u_R=u_{i+1,j}$。\n- 类似的公式适用于水平面。\n网格是非均匀的，节点由 $x_k = (k/N_x)^2$ 和 $y_\\ell = (\\ell/N_y)^2$ 定义。网格序列为 $N_x=N_y=N \\in \\{20, 40, 80, 160\\}$。网格间距 $\\Delta x_k = x_{k+1}-x_k = (2k+1)/N^2$ 不是常数。最大间距 $h$ 出现在最大索引 $k=N-1$ 处，得到 $h = (2(N-1)+1)/N^2 = (2N-1)/N^2$。由于网格变换是光滑的，该线性插值格式预期具有二阶精度，得出 $p \\approx 2$。\n\n计算步骤对每种情况都包括：\n1.  遍历指定的网格尺寸 $N$。\n2.  对于每个 $N$，构建网格（节点和网格中心）并计算网格参数 $h$。\n3.  在所有网格中心计算人造解，以获得离散场 $u_{i,j}$。\n4.  遍历所有内部垂直和水平面，通过比较插值 $\\hat{u}_f$ 与精确值 $u(x_f, y_f)$ 来计算误差平方和。\n5.  计算总误差 $E$ 并存储数据对 $(\\log h, \\log E)$。\n6.  处理完所有网格尺寸后，对存储的对数-对数数据进行线性回归，找到斜率，即观测精度阶 $p$。", "answer": "```python\nimport numpy as np\nfrom scipy import stats\n\ndef compute_order_of_accuracy(scheme, grid_type, sizes):\n    \"\"\"\n    Computes the observed order of accuracy for a given interpolation scheme.\n\n    Args:\n        scheme (str): The interpolation scheme ('upwind', 'central', 'distance-weighted').\n        grid_type (str): The type of grid ('uniform', 'stretched').\n        sizes (list of int): A list of grid sizes (N x N) for the refinement study.\n\n    Returns:\n        float: The observed order of accuracy, p.\n    \"\"\"\n    exact_sol = lambda x, y: np.exp(x + y)\n    log_h_values = []\n    log_E_values = []\n\n    for N in sizes:\n        Nx = Ny = N\n\n        # 1. Generate Grid and Mesh Parameter h\n        if grid_type == 'uniform':\n            x_nodes = np.linspace(0.0, 1.0, Nx + 1)\n            y_nodes = np.linspace(0.0, 1.0, Ny + 1)\n            h = 1.0 / N\n        elif grid_type == 'stretched':\n            k = np.arange(N + 1)\n            x_nodes = (k / N)**2\n            y_nodes = (k / N)**2\n            h = (2 * N - 1) / N**2\n        else:\n            raise ValueError(\"Unknown grid_type\")\n\n        log_h_values.append(np.log(h))\n\n        x_centers = (x_nodes[:-1] + x_nodes[1:]) / 2.0\n        y_centers = (y_nodes[:-1] + y_nodes[1:]) / 2.0\n\n        # 2. Compute Cell-Centered Values\n        u_cell_centered = exact_sol(x_centers[:, np.newaxis], y_centers[np.newaxis, :])\n\n        # 3. Iterate Over Interior Faces and Calculate Error\n        sum_sq_err = 0.0\n        num_faces = 0\n\n        # Vertical faces\n        for i in range(Nx - 1):\n            for j in range(Ny):\n                x_face = x_nodes[i + 1]\n                y_face = y_centers[j]\n                u_exact = exact_sol(x_face, y_face)\n\n                if scheme == 'upwind':\n                    u_interp = u_cell_centered[i, j]\n                elif scheme == 'central':\n                    u_interp = (u_cell_centered[i, j] + u_cell_centered[i + 1, j]) / 2.0\n                elif scheme == 'distance-weighted':\n                    x_L, x_R = x_centers[i], x_centers[i+1]\n                    u_L, u_R = u_cell_centered[i, j], u_cell_centered[i+1, j]\n                    # Note: x_face == x_nodes[i+1]\n                    # The formula simplifies, but we use the general form for clarity.\n                    weight_R = (x_face - x_L) / (x_R - x_L)\n                    u_interp = (1.0 - weight_R) * u_L + weight_R * u_R\n                else: \n                    raise ValueError(\"Unknown scheme\")\n\n                sum_sq_err += (u_interp - u_exact)**2\n                num_faces += 1\n\n        # Horizontal faces\n        for i in range(Nx):\n            for j in range(Ny - 1):\n                x_face = x_centers[i]\n                y_face = y_nodes[j + 1]\n                u_exact = exact_sol(x_face, y_face)\n\n                if scheme == 'upwind':\n                    u_interp = u_cell_centered[i, j]\n                elif scheme == 'central':\n                    u_interp = (u_cell_centered[i, j] + u_cell_centered[i, j + 1]) / 2.0\n                elif scheme == 'distance-weighted':\n                    y_L, y_R = y_centers[j], y_centers[j+1]\n                    u_L, u_R = u_cell_centered[i, j], u_cell_centered[i, j+1]\n                    weight_R = (y_face - y_L) / (y_R - y_L)\n                    u_interp = (1.0 - weight_R) * u_L + weight_R * u_R\n                else:\n                    raise ValueError(\"Unknown scheme\")\n\n                sum_sq_err += (u_interp - u_exact)**2\n                num_faces += 1\n        \n        # 4. Calculate L2 error E\n        E = np.sqrt(sum_sq_err / num_faces)\n        log_E_values.append(np.log(E))\n\n    # 5. Perform Linear Regression to find order p\n    slope, _, _, _, _ = stats.linregress(log_h_values, log_E_values)\n    return slope\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = {\n        'A': {\n            'scheme': 'upwind', \n            'grid_type': 'uniform', \n            'sizes': [16, 32, 64, 128]\n        },\n        'B': {\n            'scheme': 'central', \n            'grid_type': 'uniform', \n            'sizes': [16, 32, 64, 128]\n        },\n        'C': {\n            'scheme': 'distance-weighted', \n            'grid_type': 'stretched', \n            'sizes': [20, 40, 80, 160]\n        }\n    }\n\n    results = []\n    # Sort keys to ensure consistent order [A, B, C]\n    for key in sorted(test_cases.keys()):\n        params = test_cases[key]\n        p = compute_order_of_accuracy(**params)\n        results.append(round(p, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3337129"}]}