{"hands_on_practices": [{"introduction": "理论与实践的首次交汇发生于对核心思想的实现。本练习旨在通过编码实践，巩固您对混合格式基本原理的理解。您将亲手实现一个经典的混合差分格式，该格式根据局部单元佩克莱数 $P_{\\Delta}$ 的值，在稳定的（但扩散性强的）一阶迎风格式和精确的（但可能产生振荡的）二阶中心差分格式之间进行切换。通过网格加密研究，您将定量地验证该格式在对流主导和扩散主导两种不同流态下的实际收敛阶数，这是计算流体力学中验证代码和理解格式性能的一项基本技能。[@problem_id:3330986]", "problem": "考虑在区间 $[0,1]$ 上的稳态一维对流扩散边值问题，其带有狄利克雷（Dirichlet）边界条件：寻找一个足够光滑的函数 $u(x)$，使得\n$$\na\\,\\frac{d u}{d x}(x) - D\\,\\frac{d^2 u}{d x^2}(x) = 0,\\quad x \\in (0,1),\\qquad u(0) = 0,\\quad u(1) = 1,\n$$\n其中 $a$ 和 $D$ 分别是代表平流速度和扩散系数的实常数。所有量均为无量纲（没有物理单位）。任务是使用一种混合差分策略处理对流项，并进行网格加密研究，以提取在扩散主导和对流主导两种情况下的观测精度阶。\n\n使用有限差分法（FDM）进行空间离散化，网格间距均匀，为 $\\Delta x = h = 1/N$，其中 $N$ 是总区间数，网格节点位于 $x_i = i h$（$i=0,1,\\dots,N$）。扩散项 $-D\\,\\frac{d^2 u}{d x^2}$ 始终采用标准的二阶中心差分进行近似。对于对流项 $a\\,\\frac{d u}{d x}$，根据局部网格佩克莱特数（Peclet number）$P_{\\Delta} = \\frac{|a|\\,\\Delta x}{D}$，采用以下混合差分策略：\n- 如果 $P_{\\Delta} \\le 2$，在内部节点处对 $\\frac{d u}{d x}$ 使用二阶中心差分。\n- 如果 $P_{\\Delta} > 2$，在内部节点处对 $\\frac{d u}{d x}$ 使用与 $a$ 符号一致的一阶迎风差分（即，当 $a>0$ 时，使用后向差分；当 $a<0$ 时，使用前向差分）。\n\n您必须：\n- 为内部节点 $x_i$（$i=1,\\dots,N-1$）处的未知数 $u_i$ 建立相应的三对角线性系统，其中直接施加 $u_0=0$ 和 $u_N=1$。\n- 求解该线性系统，并计算所有节点上的数值解 $u^{(h)}(x_i)$。\n- 根据控制方程推导出的边值问题的精确解 $u(x)$，计算离散 $\\ell^2$ 误差范数，\n$$\nE(h) = \\left(\\Delta x \\sum_{i=0}^{N} \\left(u^{(h)}(x_i) - u(x_i)\\right)^2\\right)^{1/2}.\n$$\n- 对于每种测试情况，通过对加密序列上的 $\\log(E(h))$ 与 $\\log(h)$ 进行最小二乘线性回归，计算观测精度阶 $p$。也就是说，确定 $p$ 使得对于某个常数 $\\alpha$，有 $\\log(E(h)) \\approx \\alpha + p\\,\\log(h)$。\n\n测试组：\n- 所有测试均使用 $D=1$。对于每种情况，按所列出的顺序提供 $N$ 值序列。\n    $1.$ 扩散主导情况：$a=0.1$，$N\\in\\{32,64,128,256,512\\}$。\n    $2.$ 对流主导情况（正平流）：$a=400$，$N\\in\\{8,16,32,64\\}$。\n    $3.$ 纯扩散边值问题：$a=0$，$N\\in\\{32,64,128,256,512\\}$。\n    $4.$ 对流主导情况（负平流）：$a=-400$，$N\\in\\{8,16,32,64\\}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含案例 1 到 4 的四个观测精度阶，以逗号分隔的列表形式并用方括号括起，保留三位小数，例如 $[p_1,p_2,p_3,p_4]$。\n\n角度单位不适用。百分比不适用。所有量均为无量纲。用于误差评估的精确解必须从微分方程和边界条件推导得出，而不是根据经验指定。", "solution": "用户提供的问题是一个来自计算流体动力学的适定边值问题（BVP），要求进行数值求解和误差分析。该问题具有科学依据，内容自洽，并且要求应用标准的、可验证的数值方法。因此，该问题是有效的。\n\n求解过程涉及以下几个步骤：\n1.  推导边值问题的精确解析解，作为精度评估的基准。\n2.  使用指定的混合有限差分格式对控制微分方程进行离散化。\n3.  建立并求解所得到的三对角线性方程组。\n4.  为一系列加密网格计算离散 $\\ell^2$ 误差范数。\n5.  通过对误差与网格间距的对数-对数图进行线性回归，计算观测精度阶 $p$。\n\n### 1. 解析解\n该控制常微分方程（ODE）是一个二阶线性齐次常系数方程：\n$$\nD\\,\\frac{d^2 u}{d x^2}(x) - a\\,\\frac{d u}{d x}(x) = 0\n$$\n其特征方程为 $D r^2 - a r = r(D r - a) = 0$，根为 $r_1 = 0$ 和 $r_2 = a/D$。\n\n对于 $a \\neq 0$，通解的形式为 $u(x) = C_1 e^{r_1 x} + C_2 e^{r_2 x}$，即：\n$$\nu(x) = C_1 + C_2 e^{(a/D)x}\n$$\n常数 $C_1$ 和 $C_2$ 由狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 1$ 确定。\n应用 $u(0) = 0$：\n$$\nC_1 + C_2 e^0 = 0 \\implies C_1 = -C_2\n$$\n应用 $u(1) = 1$：\n$$\nC_1 + C_2 e^{a/D} = 1\n$$\n将 $C_1 = -C_2$ 代入第二个方程，得到 $-C_2 + C_2 e^{a/D} = 1$，解得 $C_2 = 1 / (e^{a/D} - 1)$。因此，$C_1 = -1 / (e^{a/D} - 1)$。\n$a \\neq 0$ 时的精确解为：\n$$\nu(x) = \\frac{e^{(a/D)x} - 1}{e^{a/D} - 1}\n$$\n\n对于 $a = 0$ 的特殊情况，常微分方程简化为 $D u''(x) = 0$，积分可得 $u(x) = C_1 x + C_2$。应用边界条件 $u(0)=0$ 和 $u(1)=1$ 分别得到 $C_2=0$ 和 $C_1=1$。因此，当 $a=0$ 时，精确解为：\n$$\nu(x) = x\n$$\n此结果也可以通过对通解在 $a \\to 0$ 时使用洛必达（L'Hôpital）法则求极限得到。\n\n### 2. 有限差分离散化\n我们使用包含 $N$ 个区间的均匀网格对定义域 $[0,1]$ 进行离散化，使得网格间距为 $h = \\Delta x = 1/N$，网格节点为 $x_i = i h$（$i = 0, 1, \\dots, N$）。这些节点上的数值解记为 $u_i \\approx u(x_i)$。值 $u_0=0$ 和 $u_N=1$ 由边界条件已知。我们需要求解内部节点的值 $u_1, \\dots, u_{N-1}$。\n\n在内部节点 $x_i$ 处的离散方程为：\n$$\na \\left(\\frac{du}{dx}\\right)_i - D \\left(\\frac{d^2u}{dx^2}\\right)_i = 0\n$$\n扩散项始终通过二阶中心差分进行近似：\n$$\n- D \\left(\\frac{d^2u}{dx^2}\\right)_i \\approx -D \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n$$\n对流项使用基于网格佩克莱特数 $P_{\\Delta} = \\frac{|a|h}{D}$ 的混合格式进行近似。\n\n**情况 A：$P_{\\Delta} \\le 2$（中心差分格式）**\n对流项通过二阶中心差分进行近似：\n$$\na \\left(\\frac{du}{dx}\\right)_i \\approx a \\frac{u_{i+1} - u_{i-1}}{2h}\n$$\n将这些近似代入控制常微分方程，并将各项重排为 $a_P u_i = a_W u_{i-1} + a_E u_{i+1}$ 的形式，可得：\n$$\n\\frac{2D}{h^2} u_i = \\left(\\frac{D}{h^2} + \\frac{a}{2h}\\right) u_{i-1} + \\left(\\frac{D}{h^2} - \\frac{a}{2h}\\right) u_{i+1}\n$$\n系数为：\n$a_W = \\frac{D}{h} + \\frac{a}{2}$，$a_E = \\frac{D}{h} - \\frac{a}{2}$，以及 $a_P = a_W + a_E = \\frac{2D}{h}$。\n\n**情况 B：$P_{\\Delta} > 2$（迎风差分格式）**\n该格式变为一阶迎风格式。\n如果 $a>0$，使用后向差分：$a \\left(\\frac{du}{dx}\\right)_i \\approx a \\frac{u_i - u_{i-1}}{h}$。\n离散方程为：\n$$\n\\left(\\frac{2D}{h^2} + \\frac{a}{h}\\right) u_i = \\left(\\frac{D}{h^2} + \\frac{a}{h}\\right) u_{i-1} + \\left(\\frac{D}{h^2}\\right) u_{i+1}\n$$\n系数为：\n$a_W = \\frac{D}{h} + a$，$a_E = \\frac{D}{h}$，以及 $a_P = a_W + a_E = \\frac{2D}{h} + a$。\n\n如果 $a<0$，使用前向差分：$a \\left(\\frac{du}{dx}\\right)_i \\approx a \\frac{u_{i+1} - u_{i}}{h}$。\n离散方程为：\n$$\n\\left(\\frac{2D}{h^2} - \\frac{a}{h}\\right) u_i = \\left(\\frac{D}{h^2}\\right) u_{i-1} + \\left(\\frac{D}{h^2} - \\frac{a}{h}\\right) u_{i+1}\n$$\n系数为：\n$a_W = \\frac{D}{h}$，$a_E = \\frac{D}{h} - a$，以及 $a_P = a_W + a_E = \\frac{2D}{h} - a$。\n\n### 3. 线性系统组装\n对于每个内部节点 $i=1, \\dots, N-1$，我们有一个形如以下的方程：\n$$\n-a_W u_{i-1} + a_P u_i - a_E u_{i+1} = 0\n$$\n由于在给定的测试案例中，$a_W, a_P, a_E$ 在整个均匀网格上是常数，这为未知数向量 $\\vec{u} = [u_1, u_2, \\dots, u_{N-1}]^T$ 构成了一个三对角线性方程组 $A\\vec{u} = \\vec{b}$。\n\n矩阵 $A$ 是一个 $(N-1) \\times (N-1)$ 的三对角矩阵：\n$$\nA = \\begin{pmatrix}\na_P  -a_E  0  \\dots  0 \\\\\n-a_W  a_P  -a_E  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n0  \\dots  -a_W  a_P  -a_E \\\\\n0  \\dots  0  -a_W  a_P\n\\end{pmatrix}\n$$\n右侧向量 $\\vec{b}$ 包含了边界条件。\n对于 $i=1$：$-a_W u_0 + a_P u_1 - a_E u_2 = 0$。由于 $u_0=0$，该式为 $a_P u_1 - a_E u_2 = 0$。\n对于 $i=N-1$：$-a_W u_{N-2} + a_P u_{N-1} - a_E u_N = 0$。由于 $u_N=1$，该式变为 $-a_W u_{N-2} + a_P u_{N-1} = a_E$。\n因此，向量 $\\vec{b}$ 为：\n$$\n\\vec{b} = [0, 0, \\dots, 0, a_E]^T\n$$\n这个三对角系统可以使用专门的算法高效求解，例如 `scipy.linalg.solve_banded`。\n\n### 4. 误差分析与精度阶\n求解得到数值解 $u^{(h)} = [u_0, u_1, \\dots, u_N]^T$ 后，我们计算其与精确解 $u(x_i)$ 之间的离散 $\\ell^2$ 误差范数：\n$$\nE(h) = \\left(h \\sum_{i=0}^{N} \\left(u_i - u(x_i)\\right)^2\\right)^{1/2}\n$$\n理论收敛率为 $E(h) \\approx C h^p$，其中 $p$ 是精度阶。为了找到观测阶，我们取对数：\n$$\n\\log(E(h)) \\approx \\log(C) + p \\log(h)\n$$\n通过为一系列网格间距 $h$ 计算 $E(h)$，我们可以对 $\\log(E(h))$ 与 $\\log(h)$ 进行线性回归。所得直线的斜率即为观测精度阶 $p$。\n\n### 5. 测试案例分析\n- **案例 1 ($a=0.1, D=1$)：** 当 $N \\ge 32$ 时，$h \\le 1/32$。最大 $P_{\\Delta} = 0.1 \\times (1/32) / 1 \\approx 0.0031$，远小于 2。此时使用二阶中心差分格式，因此我们预期 $p \\approx 2.0$。\n- **案例 2 ($a=400, D=1$)：** 当 $N \\le 64$ 时，$h \\ge 1/64$。最小 $P_{\\Delta} = 400 \\times (1/64) / 1 = 6.25$，大于 2。此时使用一阶迎风格式，因此我们预期 $p \\approx 1.0$。\n- **案例 3 ($a=0, D=1$)：** $P_{\\Delta} = 0$，因此使用中心差分格式。该格式简化为二阶导数的标准模板，且精确解为 $u(x)=x$。在没有浮点误差的情况下，有限差分法可以精确地得到该线性解。在数值上，误差将处于机器精度水平，因此对所有 $h$ 来说大致恒定。这导致观测到的精度阶 $p \\approx 0.0$。\n- **案例 4 ($a=-400, D=1$)：** 与案例 2 类似，最小 $P_{\\Delta} = |-400| \\times (1/64) / 1 = 6.25 > 2$。此时使用一阶迎风格式，我们预期 $p \\approx 1.0$。\n\n实现将遵循此逻辑来计算四个 $p$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady convection-diffusion equation using a hybrid finite\n    difference scheme and calculates the observed order of accuracy for\n    four different test regimes.\n    \"\"\"\n\n    def get_exact_solution(x, a, D):\n        \"\"\"\n        Computes the exact analytical solution to the BVP.\n        \"\"\"\n        if a == 0.0:\n            return x\n        else:\n            ratio = a / D\n            # Use np.expm1 for numerical stability when ratio is close to zero.\n            return np.expm1(ratio * x) / np.expm1(ratio)\n\n    def solve_one_case(a, D, N_values):\n        \"\"\"\n        Performs grid refinement study for a single (a, D) case.\n        Returns the observed order of accuracy.\n        \"\"\"\n        h_list = []\n        error_list = []\n\n        for N in N_values:\n            # 1. Grid setup\n            h = 1.0 / N\n            x_nodes = np.linspace(0.0, 1.0, N + 1)\n            \n            # 2. Determine scheme based on cell Peclet number\n            P_delta = np.abs(a) * h / D\n\n            if P_delta = 2.0:\n                # Central Difference Scheme for convection\n                a_W = D/h + a/2.0\n                a_E = D/h - a/2.0\n                # Per the control volume formulation, a_P = a_W + a_E for CDS\n                a_P = 2.0*D/h\n            else:\n                # Upwind Scheme for convection\n                if a > 0.0:\n                    # Backward difference\n                    a_W = D/h + a\n                    a_E = D/h\n                    a_P = a_W + a_E # = 2*D/h + a\n                else: # a  0.0\n                    # Forward difference\n                    a_W = D/h\n                    a_E = D/h - a\n                    a_P = a_W + a_E # = 2*D/h - a\n            \n            # 3. Assemble the tridiagonal linear system Au = b\n            dim = N - 1\n            ab = np.zeros((3, dim))\n            b = np.zeros(dim)\n            \n            # Fill the banded matrix 'ab' for scipy.linalg.solve_banded\n            # ab[0, 1:] = super-diagonal\n            # ab[1, :]   = main-diagonal\n            # ab[2, :-1]= sub-diagonal\n            ab[1, :] = a_P\n            if dim > 0:\n                ab[0, 1:] = -a_E\n                ab[2, :-1] = -a_W\n\n            # 4. Apply boundary conditions\n            # u_0 = 0 is handled implicitly as it doesn't add to the RHS\n            # u_N = 1 affects the last equation (for u_{N-1})\n            if dim > 0:\n                # The term -a_E * u_N becomes a_E on the RHS\n                b[-1] = a_E * 1.0\n            \n            # 5. Solve the system\n            if dim > 0:\n                u_internal = solve_banded((1, 1), ab, b)\n            else:\n                u_internal = np.array([])\n            \n            # 6. Construct full numerical solution vector\n            u_numerical = np.zeros(N + 1)\n            u_numerical[0] = 0.0\n            u_numerical[-1] = 1.0\n            u_numerical[1:-1] = u_internal\n\n            # 7. Compute the l2-error\n            u_exact = get_exact_solution(x_nodes, a, D)\n            error_sq_sum = np.sum((u_numerical - u_exact)**2)\n            error = np.sqrt(h * error_sq_sum)\n            \n            # Handle cases where error is zero to avoid log(0)\n            if error  np.finfo(np.float64).tiny:\n                error = np.finfo(np.float64).tiny\n\n            h_list.append(h)\n            error_list.append(error)\n        \n        # 8. Calculate order of accuracy using linear regression\n        log_h = np.log(np.array(h_list))\n        log_error = np.log(np.array(error_list))\n        \n        # Fit a line: log(error) = p * log(h) + const\n        p, _ = np.polyfit(log_h, log_error, 1)\n        \n        return p\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'a': 0.1,  'D': 1.0, 'N_values': [32, 64, 128, 256, 512]}, # Diffusion-dominated\n        {'a': 400.0, 'D': 1.0, 'N_values': [8, 16, 32, 64]}, # Convection-dominated, a>0\n        {'a': 0.0,  'D': 1.0, 'N_values': [32, 64, 128, 256, 512]}, # Pure diffusion\n        {'a': -400.0, 'D': 1.0, 'N_values': [8, 16, 32, 64]}, # Convection-dominated, a  0\n    ]\n\n    results = []\n    for case in test_cases:\n        order_p = solve_one_case(case['a'], case['D'], case['N_values'])\n        results.append(order_p)\n\n    # Format the final output string\n    formatted_results = [f\"{p:.3f}\" for p in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3330986"}, {"introduction": "在实际的流场中，物理量（如速度）往往不是均匀分布的，这会导致局部佩克莱数在计算域内发生剧烈变化。在这种情况下，采用全局固定的混合策略显然不是最优选择。本练习将引导您探索一种更先进的自适应混合策略，其中混合因子 $\\beta_i$ 根据每个网格点上的局部佩克莱数 $P_e(x_i)$ 动态调整。通过应用“人造解方法”（Method of Manufactured Solutions）这一强大的代码验证技术，您将能够在一个包含陡峭内部梯度的复杂问题中，精确地量化自适应格式相对于固定混合格式在 $L_2$ 和 $L_{\\infty}$ 范数下的误差改进程度，从而深刻体会自适应方法在解决实际问题中的巨大优势。[@problem_id:3331018]", "problem": "考虑在定义域 $[0,1]$ 上的一维稳态对流-扩散方程，其空间坐标为 $x$，\n$$u(x)\\,\\frac{d\\phi}{dx} \\;=\\; \\nu\\,\\frac{d^2\\phi}{dx^2} \\;+\\; s(x),$$\n其中 $u(x)$ 是给定的空间变化的对流速度，$\\nu0$ 是常数扩散系数，$s(x)$ 是一个人为构造的源项，用于强制执行一个选定的精确解。使用狄利克雷（Dirichlet）边界条件 $\\phi(0)=\\phi_{\\text{exact}}(0)$ 和 $\\phi(1)=\\phi_{\\text{exact}}(1)$。\n\n为了在保持问题可通过构造法求解的同时引入一个内层，采用“人造解法”（Method of Manufactured Solutions）。设精确解为\n$$\\phi_{\\text{exact}}(x) \\;=\\; \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right),$$\n其中小的正参数 $\\delta_\\phi$ 控制 $x=1/2$ 附近内层的厚度。定义空间变化的对流速度\n$$u(x) \\;=\\; u_0 \\;+\\; u_{\\mathrm{amp}}\\,\\tanh\\!\\left(\\frac{x - 1/2}{\\delta_u}\\right),$$\n其中参数 $u_00$、$u_{\\mathrm{amp}}\\ge 0$ 和 $\\delta_u0$ 的选择应保证对所有 $x\\in[0,1]$ 都有 $u(x)\\ge 0$。将 $\\phi_{\\text{exact}}(x)$ 和 $u(x)$ 代入控制方程，解析地计算出相应的源项 $s(x)$。\n\n将定义域离散化为一个包含 $N+1$ 个点的均匀网格，间距为 $\\Delta x = 1/N$。用标准的二阶中心差分近似扩散项\n$$\\frac{d^2\\phi}{dx^2}\\Big|_{x_i} \\approx \\frac{\\phi_{i+1} - 2\\phi_{i} + \\phi_{i-1}}{\\Delta x^2},$$\n并用一种混合差分策略近似对流项，该策略通过一个局部混合权重 $\\beta_i\\in[0,1]$ 来融合中心差分和迎风差分：\n- 节点 $i$ 处的中心差分：$$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{CD}}_i \\approx \\frac{\\phi_{i+1} - \\phi_{i-1}}{2\\Delta x}.$$\n- 对 $u(x_i)\\ge 0$，节点 $i$ 处的迎风差分：$$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{UD}}_i \\approx \\frac{\\phi_{i} - \\phi_{i-1}}{\\Delta x}.$$\n- 对 $u(x_i) 0$，节点 $i$ 处的迎风差分：$$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{UD}}_i \\approx \\frac{\\phi_{i+1} - \\phi_{i}}{\\Delta x}.$$\n- 混合格式：$$\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{HYB}}_i \\approx (1-\\beta_i)\\,\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{CD}}_i \\;+\\; \\beta_i\\,\\left(\\frac{d\\phi}{dx}\\right)^{\\mathrm{UD}}_i.$$\n\n实现两种 $\\beta_i$ 的策略：\n1. 固定混合，对所有 $i$ 有 $\\beta_i=\\beta_{\\mathrm{fixed}}$，其中 $\\beta_{\\mathrm{fixed}}$ 是从集合 $\\{0.0,\\,0.5,\\,1.0\\}$ 中选择的常数。\n2. 自适应混合，其中 $\\beta_i$ 取决于由下式定义的局部单元佩克莱数（Peclet number）$P_e(x_i)$：$$P_e(x_i) \\;=\\; \\frac{|u(x_i)|\\,\\Delta x}{\\nu}。$$ 使用一个平滑的逻辑斯蒂型过渡函数，该函数以经典的混合格式阈值 $P_e = 2$ 为中心：\n$$\\beta_i \\;=\\; \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{P_e(x_i) - 2}{w}\\right)\\right),$$\n其中 $w$ 是一个正的陡度参数（使用 $w=0.5$）。\n\n为内部未知数 $\\{\\phi_i\\}_{i=1}^{N-1}$ 组装所得到的线性系统，并使用 $x=0$ 和 $x=1$ 处的精确解值来施加狄利克雷边界条件。求解该线性系统以获得离散近似解 $\\phi^{\\mathrm{num}}$。\n\n通过在网格上比较 $\\phi^{\\mathrm{num}}$ 和 $\\phi_{\\text{exact}}$ 来计算离散化误差，并报告以下误差范数：\n- 离散 $L_2$ 范数：$$\\lVert e \\rVert_{L_2} \\;=\\; \\left(\\sum_{i=0}^{N} \\left(\\phi^{\\mathrm{num}}_i - \\phi_{\\text{exact}}(x_i)\\right)^2 \\,\\Delta x\\right)^{1/2}。$$\n- 离散 $L_\\infty$ 范数：$$\\lVert e \\rVert_{L_\\infty} \\;=\\; \\max_{0\\le i \\le N}\\left|\\phi^{\\mathrm{num}}_i - \\phi_{\\text{exact}}(x_i)\\right|。$$\n\n对于每个测试用例，计算自适应策略相对于每个固定 $\\beta_{\\mathrm{fixed}}\\in\\{0.0,\\,0.5,\\,1.0\\}$ 的改进因子，其定义为固定策略误差与自适应策略误差之比：\n- $I_{2}(\\beta_{\\mathrm{fixed}}) = \\lVert e \\rVert_{L_2}^{\\mathrm{fixed}} \\big/ \\lVert e \\rVert_{L_2}^{\\mathrm{adaptive}}$。\n- $I_{\\infty}(\\beta_{\\mathrm{fixed}}) = \\lVert e \\rVert_{L_\\infty}^{\\mathrm{fixed}} \\big/ \\lVert e \\rVert_{L_\\infty}^{\\mathrm{adaptive}}$。\n\n您的程序必须实现以上内容，并为每个测试用例输出一个包含六个浮点数的列表，排列方式如下\n$$\\left[ I_{2}(0.0),\\, I_{\\infty}(0.0),\\, I_{2}(0.5),\\, I_{\\infty}(0.5),\\, I_{2}(1.0),\\, I_{\\infty}(1.0) \\right]。$$\n将所有测试用例的结果汇总到一个列表中，并按照下面指定的精确格式打印在一行上。\n\n测试套件：\n使用以下4个测试用例，每个用例由元组 $(N,\\,\\nu,\\,u_0,\\,u_{\\mathrm{amp}},\\,\\delta_\\phi,\\,\\delta_u)$ 指定：\n- 用例 1：$(200,\\,0.001,\\,1.0,\\,0.9,\\,0.02,\\,0.02)$。\n- 用例 2：$(200,\\,0.01,\\,1.0,\\,0.5,\\,0.05,\\,0.05)$。\n- 用例 3：$(400,\\,0.0005,\\,0.5,\\,0.49,\\,0.01,\\,0.01)$。\n- 用例 4：$(100,\\,0.001,\\,0.0,\\,0.0,\\,0.02,\\,0.02)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，每个内部列表对应一个测试用例，格式为\n$$\\texttt{[[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{1,5},r_{1,6}],[r_{2,1},\\dots,r_{2,6}],[r_{3,1},\\dots,r_{3,6}],[r_{4,1},\\dots,r_{4,6}]]}$$\n其中每个 $r_{k,j}$ 是一个浮点数。", "solution": "该问题是有效的。它提出了一个在计算流体力学领域内适定且有科学依据的任务，具体涉及一维稳态对流-扩散方程的数值求解。所有参数、方程和边界条件都已明确定义，构成了一个自洽且可验证的问题。“人造解法”的使用是代码验证和数值格式分析的标准技术。所提供的测试用例与问题的约束条件一致，包括纯扩散的边缘情况，这是一个有价值的检验。\n\n求解过程包括几个步骤：推导解析源项，将控制偏微分方程离散化为线性代数方程组，针对不同的数值格式求解该系统，以及计算指定的误差度量和改进因子。\n\n首先，我们使用“人造解法”推导源项 $s(x)$。控制方程为\n$$u(x)\\,\\frac{d\\phi}{dx} \\;=\\; \\nu\\,\\frac{d^2\\phi}{dx^2} \\;+\\; s(x)$$\n因此源项为 $s(x) = u(x)\\frac{d\\phi}{dx} - \\nu\\frac{d^2\\phi}{dx^2}$。我们需要人造解 $\\phi_{\\text{exact}}(x) = \\frac{1}{2}\\left(1 + \\tanh\\!\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right)$ 的一阶和二阶导数。设 $\\theta_\\phi(x) = \\frac{x - 1/2}{\\delta_\\phi}$。\n\n一阶导数为：\n$$ \\frac{d\\phi_{\\text{exact}}}{dx} = \\frac{d}{dx}\\left[\\frac{1}{2}(1 + \\tanh(\\theta_\\phi(x)))\\right] = \\frac{1}{2} \\text{sech}^2(\\theta_\\phi(x)) \\cdot \\frac{d\\theta_\\phi}{dx} = \\frac{1}{2\\delta_\\phi}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) $$\n\n二阶导数为：\n$$ \\frac{d^2\\phi_{\\text{exact}}}{dx^2} = \\frac{d}{dx}\\left[\\frac{1}{2\\delta_\\phi}\\text{sech}^2(\\theta_\\phi(x))\\right] = \\frac{1}{2\\delta_\\phi} \\cdot \\left(-2\\,\\text{sech}^2(\\theta_\\phi(x))\\tanh(\\theta_\\phi(x))\\right) \\cdot \\frac{d\\theta_\\phi}{dx} $$\n$$ \\frac{d^2\\phi_{\\text{exact}}}{dx^2} = -\\frac{1}{\\delta_\\phi^2}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\tanh\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) $$\n\n将这些代入 $s(x)$ 的表达式，我们得到解析源项：\n$$ s(x) = u(x)\\left[\\frac{1}{2\\delta_\\phi}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right] - \\nu\\left[-\\frac{1}{\\delta_\\phi^2}\\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\tanh\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right)\\right] $$\n$$ s(x) = \\frac{1}{\\delta_\\phi} \\text{sech}^2\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) \\left[ \\frac{u(x)}{2} + \\frac{\\nu}{\\delta_\\phi}\\tanh\\left(\\frac{x - 1/2}{\\delta_\\phi}\\right) \\right] $$\n其中 $u(x) = u_0 + u_{\\mathrm{amp}}\\,\\tanh\\!\\left(\\frac{x - 1/2}{\\delta_u}\\right)$。\n\n接下来，我们将定义域 $[0,1]$ 离散化为 $N+1$ 个点 $x_i = i\\Delta x$（$i=0, 1, \\dots, N$），网格间距为 $\\Delta x = 1/N$。在内部节点 $x_i$ 处的控制方程近似为：\n$$ u_i \\left(\\frac{d\\phi}{dx}\\right)_i - \\nu \\left(\\frac{d^2\\phi}{dx^2}\\right)_i = s_i $$\n其中 $u_i = u(x_i)$，$s_i = s(x_i)$，$\\phi_i$ 是 $\\phi(x_i)$ 的数值近似。\n\n扩散项由二阶中心差分近似：\n$$ \\left(\\frac{d^2\\phi}{dx^2}\\right)_i \\approx \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{\\Delta x^2} $$\n\n对流项使用中心差分和迎风差分的混合格式进行近似。鉴于问题参数保证 $u(x_i) \\ge 0$，我们使用适用于非负速度的迎风格式。\n$$ \\left(\\frac{d\\phi}{dx}\\right)_i \\approx (1-\\beta_i)\\left(\\frac{\\phi_{i+1} - \\phi_{i-1}}{2\\Delta x}\\right) + \\beta_i\\left(\\frac{\\phi_i - \\phi_{i-1}}{\\Delta x}\\right) $$\n重新整理，按 $\\phi_j$ 对各项进行分组：\n$$ \\left(\\frac{d\\phi}{dx}\\right)_i \\approx \\frac{1}{2\\Delta x}\\left[ (1-\\beta_i)\\phi_{i+1} + 2\\beta_i\\phi_i - (1+\\beta_i)\\phi_{i-1} \\right] $$\n\n将这些近似代入控制方程并重新整理，得到每个内部节点 $i \\in \\{1, \\dots, N-1\\}$ 的线性代数方程：\n$$ \\phi_{i-1}\\left(-\\frac{u_i(1+\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2}\\right) + \\phi_i\\left(\\frac{u_i \\beta_i}{\\Delta x} + \\frac{2\\nu}{\\Delta x^2}\\right) + \\phi_{i+1}\\left(\\frac{u_i(1-\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2}\\right) = s_i $$\n这可以写成标准形式 $C_{W,i}\\phi_{i-1} + C_{P,i}\\phi_i + C_{E,i}\\phi_{i+1} = s_i$，其中：\n$$ C_{W,i} = -\\frac{u_i(1+\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2} \\quad (\\text{西侧系数}) $$\n$$ C_{P,i} = \\frac{u_i \\beta_i}{\\Delta x} + \\frac{2\\nu}{\\Delta x^2} \\quad (\\text{中心点系数}) $$\n$$ C_{E,i} = \\frac{u_i(1-\\beta_i)}{2\\Delta x} - \\frac{\\nu}{\\Delta x^2} \\quad (\\text{东侧系数}) $$\n\n混合因子 $\\beta_i$ 由以下两种策略之一确定：\n1. 固定混合：$\\beta_i = \\beta_{\\mathrm{fixed}}$，其中 $\\beta_{\\mathrm{fixed}}$ 是一个常数（$0.0$、$0.5$ 或 $1.0$）。\n2. 自适应混合：$\\beta_i$ 是局部单元佩克莱数 $P_e(x_i) = \\frac{|u(x_i)|\\Delta x}{\\nu}$ 的函数。使用指定的逻辑斯蒂函数，陡度参数 $w=0.5$：\n$$ \\beta_i = \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{P_e(x_i) - 2}{0.5}\\right)\\right) $$\n\n这些针对 $i=1, \\dots, N-1$ 的方程构成一个三对角线性系统 $A\\mathbf{\\phi}_{\\text{int}} = \\mathbf{b}$，其中 $\\mathbf{\\phi}_{\\text{int}} = [\\phi_1, \\phi_2, \\dots, \\phi_{N-1}]^T$ 是未知内部节点值的向量。矩阵 $A$ 的维度为 $(N-1) \\times (N-1)$。\n\n狄利克雷边界条件 $\\phi_0 = \\phi_{\\text{exact}}(0)$ 和 $\\phi_N = \\phi_{\\text{exact}}(1)$ 是已知的。它们的影响被移到 $i=1$ 和 $i=N-1$ 方程的右侧：\n对于 $i=1$：$C_{P,1}\\phi_1 + C_{E,1}\\phi_2 = s_1 - C_{W,1}\\phi_0$\n对于 $i=N-1$：$C_{W,N-1}\\phi_{N-2} + C_{P,N-1}\\phi_{N-1} = s_{N-1} - C_{E,N-1}\\phi_N$\n\n求解这个三对角系统以找到 $\\mathbf{\\phi}_{\\text{int}}$。然后，完整的数值解向量为 $\\phi^{\\mathrm{num}} = [\\phi_0, \\phi_1, \\dots, \\phi_{N-1}, \\phi_N]^T$。\n\n通过将 $\\phi^{\\mathrm{num}}$ 与在网格点上求值的精确解 $\\phi_{\\text{exact}}$ 进行比较来计算误差。离散 $L_2$ 和 $L_\\infty$ 误差范数按规定计算。最后，计算改进因子，该因子通过固定 $\\beta$ 格式的误差范数与自适应格式相应范数之比来量化自适应格式的相对性能。\n$$I_{2}(\\beta_{\\mathrm{fixed}}) = \\frac{\\lVert e \\rVert_{L_2}^{\\mathrm{fixed}}}{\\lVert e \\rVert_{L_2}^{\\mathrm{adaptive}}}, \\quad I_{\\infty}(\\beta_{\\mathrm{fixed}}) = \\frac{\\lVert e \\rVert_{L_\\infty}^{\\mathrm{fixed}}}{\\lVert e \\rVert_{L_\\infty}^{\\mathrm{adaptive}}}$$\n对于测试用例 4，其中 $u(x)=0$，对流项消失。因此，所有差分格式都会产生相同的结果，所有改进因子预计都将恰好为 $1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (200, 0.001, 1.0, 0.9, 0.02, 0.02),\n        (200, 0.01, 1.0, 0.5, 0.05, 0.05),\n        (400, 0.0005, 0.5, 0.49, 0.01, 0.01),\n        (100, 0.001, 0.0, 0.0, 0.02, 0.02),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, nu, u0, u_amp, delta_phi, delta_u = case\n        \n        # Calculate errors for the four schemes\n        err_fixed_00 = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'fixed', beta_fixed=0.0)\n        err_fixed_05 = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'fixed', beta_fixed=0.5)\n        err_fixed_10 = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'fixed', beta_fixed=1.0)\n        err_adaptive = solve_case(N, nu, u0, u_amp, delta_phi, delta_u, 'adaptive')\n\n        l2_err_adapt, linf_err_adapt = err_adaptive\n\n        # Calculate improvement factors\n        # For stability, if adaptive error is zero, ratio is 1 (as fixed error must also be zero).\n        # This handles the u=0 case where all errors are identical.\n        I2_00 = err_fixed_00[0] / l2_err_adapt if l2_err_adapt > 0 else 1.0\n        Iinf_00 = err_fixed_00[1] / linf_err_adapt if linf_err_adapt > 0 else 1.0\n        \n        I2_05 = err_fixed_05[0] / l2_err_adapt if l2_err_adapt > 0 else 1.0\n        Iinf_05 = err_fixed_05[1] / linf_err_adapt if linf_err_adapt > 0 else 1.0\n        \n        I2_10 = err_fixed_10[0] / l2_err_adapt if l2_err_adapt > 0 else 1.0\n        Iinf_10 = err_fixed_10[1] / linf_err_adapt if linf_err_adapt > 0 else 1.0\n\n        case_results = [I2_00, Iinf_00, I2_05, Iinf_05, I2_10, Iinf_10]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"{all_results}\")\n\ndef solve_case(N, nu, u0, u_amp, delta_phi, delta_u, beta_strategy, beta_fixed=None):\n    \"\"\"\n    Solves the 1D convection-diffusion problem for a single strategy.\n    \n    Args:\n        N, nu, u0, u_amp, delta_phi, delta_u: Problem parameters.\n        beta_strategy (str): 'fixed' or 'adaptive'.\n        beta_fixed (float, optional): Value for fixed blending.\n\n    Returns:\n        A tuple (l2_error, linf_error).\n    \"\"\"\n    # 1. Setup grid\n    x = np.linspace(0.0, 1.0, N + 1)\n    dx = 1.0 / N\n\n    # 2. Define analytical functions\n    # Using '1 - tanh^2' for sech^2 is more numerically stable than '1/cosh^2'\n    def phi_exact_func(x_):\n        theta = (x_ - 0.5) / delta_phi\n        return 0.5 * (1.0 + np.tanh(theta))\n\n    def u_func(x_):\n        theta = (x_ - 0.5) / delta_u\n        return u0 + u_amp * np.tanh(theta)\n\n    def s_func(x_):\n        u_val = u_func(x_)\n        \n        theta_phi = (x_ - 0.5) / delta_phi\n        tanh_phi = np.tanh(theta_phi)\n        sech2_phi = 1.0 - tanh_phi**2\n        \n        dphi_dx = 0.5 * sech2_phi / delta_phi\n        d2phi_dx2 = -sech2_phi * tanh_phi / delta_phi**2\n        \n        return u_val * dphi_dx - nu * d2phi_dx2\n\n    # 3. Evaluate exact solution, velocity, and source at grid points\n    phi_exact_grid = phi_exact_func(x)\n    u_grid = u_func(x)\n    s_grid = s_func(x)\n\n    # 4. Determine beta values for interior nodes\n    beta_vals_interior = np.zeros(N - 1)\n    i_int = np.arange(1, N) # Indices of interior points\n    if beta_strategy == 'fixed':\n        beta_vals_interior[:] = beta_fixed\n    else: # adaptive\n        w = 0.5\n        # Since u(x)>=0, abs is not strictly necessary but good practice\n        pe = np.abs(u_grid[i_int]) * dx / nu\n        beta_vals_interior = 0.5 * (1.0 + np.tanh((pe - 2.0) / w))\n\n    # 5. Assemble banded matrix A and vector b for interior nodes\n    num_unknowns = N - 1\n    # ab[0,:]: upper\n    # ab[1,:]: main\n    # ab[2,:]: lower\n    ab = np.zeros((3, num_unknowns))\n    b = np.zeros(num_unknowns)\n    \n    ui = u_grid[i_int]\n    betai = beta_vals_interior\n\n    # Calculate coefficients for all interior nodes at once\n    CW = -ui * (1.0 + betai) / (2.0 * dx) - nu / dx**2\n    CP = ui * betai / dx + 2.0 * nu / dx**2\n    CE = ui * (1.0 - betai) / (2.0 * dx) - nu / dx**2\n\n    # Populate banded matrix\n    ab[0, 1:] = CE[:-1]       # Upper diagonal\n    ab[1, :] = CP             # Main diagonal\n    ab[2, :-1] = CW[1:]       # Lower diagonal\n\n    # Populate RHS vector b\n    b[:] = s_grid[i_int]\n    \n    # Apply boundary conditions\n    b[0] -= CW[0] * phi_exact_grid[0]      # At i=1\n    b[-1] -= CE[-1] * phi_exact_grid[-1]   # At i=N-1\n    \n    # 6. Solve the system\n    if num_unknowns > 0:\n        phi_interior = solve_banded((1, 1), ab, b)\n    else:\n        phi_interior = np.array([])\n\n\n    # 7. Construct full numerical solution vector\n    phi_num = np.zeros(N + 1)\n    phi_num[0] = phi_exact_grid[0]\n    phi_num[-1] = phi_exact_grid[-1]\n    if num_unknowns > 0:\n        phi_num[1:N] = phi_interior\n\n    # 8. Calculate error norms\n    error = phi_num - phi_exact_grid\n    l2_error = np.sqrt(np.sum(error**2) * dx)\n    linf_error = np.max(np.abs(error))\n\n    return l2_error, linf_error\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3331018"}, {"introduction": "一个数值格式的优劣不仅取决于其收敛阶数，还取决于解的定性行为，例如是否会产生非物理的过冲或振荡。为了更深入地探究混合格式的内在特性，本练习将分析离散算子的格林函数，它揭示了格式对一个点源扰动的响应。您将实现一个使用平滑逻辑函数进行过渡的混合格式，并量化其在不同佩克莱数 $Pe$ 和过渡平滑度 $s$ 下的“过冲幅值” $A_{\\text{over}}$。这项练习将使您对如何设计兼具高精度和良好单调性的数值格式获得宝贵的洞察，理解了混合函数的设计如何直接影响解的质量。[@problem_id:3331016]", "problem": "考虑作用在单位区间 $[0,1]$ 上的未知函数 $u(x)$ 的一维、稳态、线性对流扩散算子，其齐次狄利克雷边界条件为 $u(0)=0$ 和 $u(1)=0$。其控制方程的强形式为 $$a \\frac{du}{dx} - \\nu \\frac{d^2 u}{dx^2} = s(x),$$ 其中 $a$ 是恒定对流速度，$\\nu0$ 是恒定扩散系数，$s(x)$ 是源项。本任务要求在离散环境下分析对流项的混合差分策略如何影响算子的离散格林函数，特别是，将过冲幅值量化为网格佩克莱特数和控制数值通量混合的光滑参数的函数。\n\n从以下基础出发：\n\n- 稳态一维输运的守恒声明：净对流通量加上净扩散通量与源项平衡，其强形式如上所示。\n- 使用具有 $N$ 个内部点的均匀网格对 $[0,1]$ 进行离散化，网格间距为 $h = 1/(N+1)$，内部节点索引为 $i \\in \\{1,2,\\dots,N\\}$。\n- 离散算子通过有限差分构建：扩散项使用二阶中心差分，对流项使用一种混合差分策略，该策略平滑地混合了一阶迎风格式和二阶中心差分格式。\n\n定义网格佩克莱特数 $Pe = \\dfrac{a h}{\\nu}$，其中 $h$ 是网格间距，$\\nu$ 是扩散系数。为实现混合差分策略，使用阈值为 $Pe_t=2$ 且光滑参数为 $s0$ 的逻辑斯谛过渡，定义一个中心差分与迎风差分之间的平滑混合权重 $w(Pe;s)$：\n$$ w(Pe;s) = \\frac{1}{1+\\exp\\left(\\frac{|Pe|-Pe_t}{s}\\right)}. $$\n对于内部节点 $i$ 的对流项，当 $a \\ge 0$ 时，使用混合导数\n$$ \\left.\\frac{du}{dx}\\right|_i \\approx (1-w) \\frac{u_i - u_{i-1}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h}, $$\n当 $a  0$ 时，使用\n$$ \\left.\\frac{du}{dx}\\right|_i \\approx (1-w) \\frac{u_{i+1} - u_{i}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h}. $$\n扩散项通过以下方式离散化：\n$$ -\\nu \\left.\\frac{d^2 u}{dx^2}\\right|_i \\approx -\\nu \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}. $$\n这些为每个内部节点 $i$ 产生一个三点模板，从而得到一个三对角矩阵 $\\mathbf{A}$，该矩阵将内部节点值向量映射到离散源向量。对应于节点 $i_0$ 处单位脉冲的离散格林函数 $\\mathbf{G}$ 被定义为以下方程的唯一解\n$$ \\mathbf{A} \\mathbf{G} = \\mathbf{e}_{i_0}, $$\n其中 $\\mathbf{e}_{i_0}$ 是在索引 $i_0$ 处为 $1$、其他位置为 $0$ 的向量，并强制施加狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。\n\n按如下方式定义过冲幅值。通过离散格林函数的中心峰值 $G_{i_0}$ 对其进行归一化：\n$$ g_i = \\frac{G_i}{|G_{i_0}|}. $$\n对于峰值的右侧，定义基准相邻值 $b_R = g_{i_0+1}$（如果 $i_0+1$ 存在），右侧过冲幅值候选定义为 $A_R = \\max\\left(0, \\max_{j \\ge i_0+2} (g_j - b_R)\\right)$。对于左侧，定义 $b_L = g_{i_0-1}$（如果 $i_0-1$ 存在），且 $A_L = \\max\\left(0, \\max_{j \\le i_0-2} (g_j - b_L)\\right)$。总过冲幅值是两侧的最大值：\n$$ A_{\\text{over}} = \\max(A_L, A_R). $$\n该定义捕捉了远离中心峰值的、相对于紧邻值的次级振荡极大值，对于严格单调衰减的情况返回 $0$。\n\n您的任务是实现一个完整的程序，该程序：\n\n1. 根据上述规则，在具有 $N$ 个内部点的均匀网格上，使用扩散系数 $\\nu=1$、域长度 $L=1$ 以及狄利克雷边界条件 $u(0)=0$ 和 $u(L)=0$，构建离散算子的三对角矩阵 $\\mathbf{A}$。\n2. 使用关系式 $a = \\dfrac{Pe \\, \\nu}{h}$，在选定的网格上实现给定的 $Pe$ 值，其中 $\\nu=1$。\n3. 计算中心内部索引 $i_0 = \\lfloor N/2 \\rfloor$ 处单位脉冲的离散格林函数 $\\mathbf{G}$。\n4. 计算如上定义的过冲幅值 $A_{\\text{over}}$。\n\n设计程序以处理以下由 $(Pe, s)$ 对指定的测试用例集：\n\n- 案例 1：$(Pe, s) = (0.0, 0.5)$。\n- 案例 2：$(Pe, s) = (2.0, 0.1)$。\n- 案例 3：$(Pe, s) = (2.0, 1.0)$。\n- 案例 4：$(Pe, s) = (10.0, 0.1)$。\n- 案例 5：$(Pe, s) = (10.0, 0.5)$。\n- 案例 6：$(Pe, s) = (50.0, 0.1)$。\n- 案例 7：$(Pe, s) = (-10.0, 0.5)$。\n- 案例 8：$(Pe, s) = (20.0, 2.0)$。\n- 案例 9：$(Pe, s) = (0.5, 0.5)$。\n\n对所有案例，使用 $N=101$，$\\nu=1$，$L=1$ 和 $i_0 = \\lfloor N/2 \\rfloor$。所有量都是无量纲的，因此不需要物理单位。要求的最终输出是单行文本，包含九个案例的过冲幅值，按顺序排列，形式为逗号分隔的、四舍五入到六位小数的十进制数列表，并用方括号括起来。例如，格式必须与以下完全一样\n$$ [a_1,a_2,\\dots,a_9], $$\n其中每个 $a_k$ 是案例 $k$ 的过冲幅值。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[result1,result2,result3]”）。", "solution": "用户提供了一个在计算流体力学领域中明确定义的问题，具体涉及一维稳态对流扩散方程混合差分格式的数值分析。对问题陈述的验证证实了其在科学上是合理的、自洽的、一致的和客观的。任务是计算离散格林函数的一个特定度量——“过冲幅值”，该度量用于量化数值解的非单调行为。这需要构建一个离散算子，求解一个线性系统，然后应用一个已定义的后处理公式。该问题是有效的，可以按所述方式求解。\n\n对每个由网格佩克莱特数 $Pe$ 和混合光滑参数 $s$ 指定的测试用例，解法都系统地进行。\n\n**1. 离散化与矩阵构建**\n\n控制方程为 $a \\frac{du}{dx} - \\nu \\frac{d^2 u}{dx^2} = s(x)$。我们在具有 $N$ 个内部节点和间距 $h = \\frac{L}{N+1}$ 的均匀网格上对此方程进行离散化。对于此问题，$L=1$，$N=101$，因此 $h = \\frac{1}{102}$。使用 $\\nu=1$ 和齐次狄利克雷边界条件 $u_0=0$ 和 $u_{N+1}=0$。内部节点 $i$ 处的离散方程可以写为 $C_i u_{i-1} + D_i u_i + E_i u_{i+1} = s_i$，其中 $C_i$、$D_i$ 和 $E_i$ 是三对角矩阵 $\\mathbf{A}$ 的系数。\n\n对流项和扩散项按如下方式离散：\n- 对流项 ($a \\frac{du}{dx}$): 一阶迎风差分和二阶中心差分的混合，使用权重 $w(Pe;s) = \\frac{1}{1+\\exp\\left(\\frac{|Pe|-Pe_t}{s}\\right)}$ 进行混合，其中 $Pe_t=2$。\n- 扩散项 ($-\\nu \\frac{d^2u}{dx^2}$): 标准二阶中心差分，$-\\nu \\frac{u_{i+1}-2u_i+u_{i-1}}{h^2}$。\n\n我们通过组合离散化来推导矩阵系数。让我们定义 $|a|$ 并使用网格佩克莱特数 $Pe = \\frac{ah}{\\nu}$。注意 $|Pe| = \\frac{|a|h}{\\nu}$。\n\n节点 $i$ 处的离散算子是：\n- 对于 $a \\ge 0$ ($Pe \\ge 0$): $a \\left[ (1-w) \\frac{u_i - u_{i-1}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h} \\right] - \\nu \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$\n- 对于 $a  0$ ($Pe  0$): $a \\left[ (1-w) \\frac{u_{i+1} - u_{i}}{h} + w \\frac{u_{i+1} - u_{i-1}}{2h} \\right] - \\nu \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$\n\n收集 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的项，得到矩阵系数。\n对于任何 $Pe$，主对角线系数为：\n$$ D_i = \\frac{|a|}{h}(1-w) + \\frac{2\\nu}{h^2} $$\n非对角线系数取决于 $Pe$ 的符号。我们定义两个可能的值：\n$$ V_1 = -\\frac{|a|}{h}(1-w/2) - \\frac{\\nu}{h^2} $$\n$$ V_2 = \\frac{|a|w}{2h} - \\frac{\\nu}{h^2} $$\n那么，对于 $Pe \\ge 0$：\n- 次对角线 ($C_i$): $V_1$\n- 超对角线 ($E_i$): $V_2$\n\n对于 $Pe  0$：\n- 次对角线 ($C_i$): $V_2$\n- 超对角线 ($E_i$): $V_1$\n\n这定义了 $N \\times N$ 的三对角矩阵 $\\mathbf{A}$。\n\n**2. 离散格林函数**\n\n离散格林函数 $\\mathbf{G}$ 是线性系统 $\\mathbf{A} \\mathbf{G} = \\mathbf{e}_{i_0}$ 的解，其中 $\\mathbf{e}_{i_0}$ 是在对应于中心节点 $i_0 = \\lfloor N/2 \\rfloor = \\lfloor 101/2 \\rfloor = 50$ 的位置为 $1$、其他位置为零的向量。在大小为 $N=101$ 的 0-索引数组中，这对应于索引 $49$。这个稀疏、三对角且对角占优的系统可以使用专门的算法（如 `scipy.linalg.solve_banded` 中可用的托马斯算法）高效求解。\n\n**3. 过冲幅值计算**\n\n过冲幅值 $A_{\\text{over}}$ 是根据问题中定义的精确步骤从解向量 $\\mathbf{G}$ 计算得出的：\n1. 归一化格林函数：$g_i = G_i / |G_{i_0}|$，其中 $G_{i_0}$ 是解在脉冲位置（索引 $i_0=50$，或 0-索引 $49$）的值。\n2. 为脉冲的左侧和右侧定义基准相邻值：$b_L = g_{i_0-1}$ 和 $b_R = g_{i_0+1}$。对于 $i_0=50$，这些是 $g_{49}$ 和 $g_{51}$。\n3. 计算左侧过冲幅值 $A_L$。这是任何点 $g_j$（对于 $j \\le i_0-2$）与基准值 $b_L$ 之间的最大差值，且不小于 $0$。\n   $$ A_L = \\max\\left(0, \\max_{j \\le i_0-2} (g_j - b_L)\\right) $$\n4. 类似地计算右侧过冲幅值 $A_R$。\n   $$ A_R = \\max\\left(0, \\max_{j \\ge i_0+2} (g_j - b_R)\\right) $$\n5. 总过冲是两侧的最大值：$A_{\\text{over}} = \\max(A_L, A_R)$。\n\n此过程被实现并应用于指定的九个测试用例中的每一个，结果被收集并按要求格式化。$Pe$ 的选择（特别是与阈值 $Pe_t=2$ 的关系）以及光滑度 $s$ 决定了混合权重 $w$ 的值，而 $w$ 又控制了所用中心差分的程度，从而影响了由 $A_{\\text{over}}$ 衡量的数值振荡倾向。\n- 当 $|Pe| \\ll 2$ 时，$w \\approx 1$（中心差分主导），但由于格式是稳定的，预计不会出现振荡。\n- 当 $|Pe| \\gg 2$ 时，小的 $s$ 会导致 $w \\approx 0$（迎风格式主导），从而抑制振荡。大的 $s$ 会导致非零的 $w$，混合一些中心差分，并可能重新引入振荡。\n- 当 $|Pe| \\approx 2$ 时，行为对 $s$ 的值最敏感。\n\n该实现将反映此逻辑，以计算所需的九个 $A_{\\text{over}}$ 值。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Define problem constants\n    N = 101\n    nu = 1.0\n    L = 1.0\n    \n    # Define test cases (Pe, s)\n    test_cases = [\n        (0.0, 0.5),\n        (2.0, 0.1),\n        (2.0, 1.0),\n        (10.0, 0.1),\n        (10.0, 0.5),\n        (50.0, 0.1),\n        (-10.0, 0.5),\n        (20.0, 2.0),\n        (0.5, 0.5),\n    ]\n\n    results = []\n    for Pe, s in test_cases:\n        A_over = calculate_overshoot(Pe, s, N, nu, L)\n        results.append(A_over)\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_overshoot(Pe, s, N, nu, L):\n    \"\"\"\n    Calculates the overshoot amplitude for a given set of parameters.\n    \n    Args:\n        Pe (float): Cell Peclet number.\n        s (float): Smoothness parameter for blending.\n        N (int): Number of interior grid points.\n        nu (float): Diffusion coefficient.\n        L (float): Domain length.\n\n    Returns:\n        float: The calculated overshoot amplitude.\n    \"\"\"\n    # 1. Setup constants and derived parameters\n    h = L / (N + 1)\n    i0_1based = int(np.floor(N / 2)) # Per problem spec, e.g. floor(101/2)=50\n    i0_idx = i0_1based # In a 0-indexed array of N points, this is correct.\n\n    a = Pe * nu / h\n    abs_Pe = abs(Pe)\n    Pe_t = 2.0\n    \n    # 2. Calculate blending weight `w`\n    arg_exp = (abs_Pe - Pe_t) / s\n    if arg_exp > 700:  # Avoid numpy.exp overflow\n        w = 0.0\n    else:\n        w = 1.0 / (1.0 + np.exp(arg_exp))\n\n    # 3. Construct the tridiagonal matrix A\n    abs_a = abs(a)\n    \n    # Coefficients for main, sub, and super diagonals based on derived formulas\n    main_val = abs_a / h * (1.0 - w) + 2.0 * nu / h**2\n    v1 = -abs_a / h * (1.0 - w / 2.0) - nu / h**2\n    v2 = abs_a * w / (2.0 * h) - nu / h**2\n    \n    if Pe >= 0:\n        sub_val = v1\n        sup_val = v2\n    else:  # Pe  0\n        sub_val = v2\n        sup_val = v1\n\n    # Create the banded matrix `ab` for scipy's solver\n    # `ab` format: row 0 is super-diagonal, row 1 is main, row 2 is sub\n    ab = np.zeros((3, N))\n    ab[0, 1:] = sup_val\n    ab[1, :] = main_val\n    ab[2, :-1] = sub_val\n\n    # 4. Solve the linear system A*G = e_{i_0}\n    b = np.zeros(N)\n    b[i0_idx] = 1.0\n\n    try:\n        G = linalg.solve_banded((1, 1), ab, b)\n    except np.linalg.LinAlgError:\n        return np.nan # Should not happen for this problem's parameters\n\n    # 5. Compute the overshoot amplitude\n    G_i0 = G[i0_idx]\n    if abs(G_i0)  1e-15:\n        return np.nan # Avoid division by zero\n        \n    g = G / abs(G_i0)\n\n    b_L = g[i0_idx - 1]\n    b_R = g[i0_idx + 1]\n\n    # Left-side overshoot\n    if i0_idx > 1:\n        left_indices = slice(0, i0_idx - 1)\n        max_diff_L = np.max(g[left_indices] - b_L, initial=-np.inf)\n        A_L = np.max([0, max_diff_L])\n    else:\n        A_L = 0.0\n\n    # Right-side overshoot\n    if i0_idx  N - 2:\n        right_indices = slice(i0_idx + 2, N)\n        max_diff_R = np.max(g[right_indices] - b_R, initial=-np.inf)\n        A_R = np.max([0, max_diff_R])\n    else:\n        A_R = 0.0\n    \n    A_over = np.max([A_L, A_R])\n    \n    return A_over\n\nsolve()\n```", "id": "3331016"}]}