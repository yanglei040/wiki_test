{"hands_on_practices": [{"introduction": "Schwarz 方法的收敛速度在很大程度上取决于子域交界面上使用的传输条件。本练习旨在深入探讨如何为经典的热传导方程优化这些条件。通过进行时域傅里叶分析，您将推导出能够最小化子域间误差传播的最优 Robin 参数，这是设计高效并行求解器的基础技术。[@problem_id:3519545]", "problem": "考虑在整条实线 $\\mathbb{R}$ 上的一维热方程 $u_{t}-\\nu u_{xx}=0$，其中 $\\nu0$ 是一个常数热扩散系数。将空间域分解为两个不重叠的子域 $\\Omega_{1}=(-\\infty,0)$ 和 $\\Omega_{2}=(0,\\infty)$，并考虑在界面 $x=0$ 上使用 Robin 传输条件的 Schwarz 波形松弛迭代。具体来说，设 $\\Omega_{1}$ 的单位外法向量为 $n_{1}=+1$，$\\Omega_{2}$ 的单位外法向量为 $n_{2}=-1$，并在每次迭代中，在 $x=0$ 处施加从相邻子域传递过来的形式为 $\\partial_{n} u + \\alpha u$ 的 Robin 条件，其中 $\\alpha0$ 是一个实数 Robin 参数。\n\n假设无外力作用，并专注于误差传播。在时域-傅里叶域中分析迭代：使用角频率 $\\omega\\ge 0$ 进行时间傅里叶变换，使得变换后的场 $\\widehat{u}(x,\\omega)$ 满足一个关于 $x$ 的二阶齐次常微分方程。在每个半无限子域中选择衰减解，并推导出界面 $x=0$ 处的标量误差传播因子 $r(\\omega,\\alpha)$，用 $\\alpha$、$\\nu$ 和 $\\omega$ 表示。\n\n确定使误差传播因子 $|r(\\omega,\\alpha)|$ 的大小相对于 $\\alpha\\in\\mathbb{R}_{+}$ 最小化的值 $\\alpha^{\\star}(\\omega)$，并以 $\\omega$ 和 $\\nu$ 的函数形式给出 $\\alpha^{\\star}(\\omega)$ 的封闭表达式。您的最终答案必须是 $\\alpha^{\\star}(\\omega)$ 的单个解析表达式。不需要四舍五入。最终的方框答案中不要包含单位。[@problem_id:54]", "solution": "用户希望找到应用于一维热方程的 Schwarz 波形松弛法的最优 Robin 参数。\n\n### 步骤 1：提取已知条件\n-   **方程**：一维热方程，$u_{t}-\\nu u_{xx}=0$，对于 $x \\in \\mathbb{R}$。\n-   **参数**：$\\nu  0$ 是常数热扩散系数。\n-   **区域分解**：$\\Omega_{1}=(-\\infty,0)$ 和 $\\Omega_{2}=(0,\\infty)$。界面位于 $x=0$。\n-   **方法**：Schwarz 波形松弛。\n-   **传输条件 (TCs)**：在界面 $x=0$ 处，传递形式为 $\\partial_{n} u + \\alpha u$ 的 Robin 条件，其中 $\\alpha  0$ 是一个实数参数。\n-   **外法向量**：对于 $\\Omega_{1}$ 在 $x=0$ 处，$n_{1}=+1$。对于 $\\Omega_{2}$ 在 $x=0$ 处，$n_{2}=-1$。\n-   **分析**：分析将在角频率为 $\\omega \\ge 0$ 的时域-傅里叶域中进行。\n-   **边界条件**：解 $\\widehat{u}(x, \\omega)$ 必须在 $|x| \\to \\infty$ 时衰减。\n-   **目标**：推导误差传播因子 $r(\\omega,\\alpha)$，并找到使 $|r(\\omega,\\alpha)|$ 对 $\\alpha \\in \\mathbb{R}_{+}$ 最小化的值 $\\alpha^{\\star}(\\omega)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，是适定的、客观的。它涉及对一个基本偏微分方程（热方程）的区域分解方法（Schwarz 波形松弛）的标准分析。使用傅里叶分析来确定收敛特性和优化参数是该领域中一种成熟的技术。提供了所有必要的信息，定义一致且无歧义。该问题并非无足轻重，需要严格的数学推导。因此，该问题被认为是**有效的**。\n\n### 步骤 3：结论与行动\n问题有效。现在开始求解过程。\n\n### 最优 Robin 参数的推导\n\n我们从实线上的一维热方程开始：\n$$\nu_{t} - \\nu u_{xx} = 0, \\quad x \\in \\mathbb{R}, t  0\n$$\n其中 $\\nu  0$ 是热扩散系数。我们考虑误差的传播，它满足相同的齐次方程。\n\n分析在时域傅里叶域中进行。设 $\\widehat{u}(x,\\omega)$ 是 $u(x,t)$ 的时间傅里叶变换，定义为 $\\widehat{u}(x,\\omega) = \\int_{-\\infty}^{\\infty} u(x,t) e^{-i\\omega t} dt$。将此变换应用于热方程，时间导数 $\\partial_t$ 变为乘以 $i\\omega$。这产生了一个关于空间变量 $x$ 的二阶齐次常微分方程 (ODE)：\n$$\ni\\omega \\widehat{u}(x,\\omega) - \\nu \\frac{d^2\\widehat{u}}{dx^2}(x,\\omega) = 0\n$$\n$$\n\\frac{d^2\\widehat{u}}{dx^2} - \\frac{i\\omega}{\\nu} \\widehat{u} = 0\n$$\n该 ODE 的特征方程是 $\\lambda^2 - \\frac{i\\omega}{\\nu} = 0$。其根为 $\\lambda = \\pm \\sqrt{\\frac{i\\omega}{\\nu}}$。\n为简化根，我们使用虚数单位的极坐标表示，$i = e^{i\\pi/2}$。因此，$\\sqrt{i} = e^{i\\pi/4} = \\cos(\\frac{\\pi}{4}) + i\\sin(\\frac{\\pi}{4}) = \\frac{1+i}{\\sqrt{2}}$。根变为：\n$$\n\\lambda = \\pm \\sqrt{\\frac{\\omega}{\\nu}} \\left( \\frac{1+i}{\\sqrt{2}} \\right) = \\pm \\sqrt{\\frac{\\omega}{2\\nu}}(1+i)\n$$\n我们定义 $k(\\omega) = \\sqrt{\\frac{\\omega}{2\\nu}}(1+i)$。$k(\\omega)$ 的实部是 $\\operatorname{Re}(k(\\omega)) = \\sqrt{\\frac{\\omega}{2\\nu}}$，对于 $\\omega \\ge 0$ 是非负的。该 ODE 的通解是 $\\widehat{u}(x,\\omega) = C_1 e^{k(\\omega)x} + C_2 e^{-k(\\omega)x}$。\n\n问题要求解在 $|x| \\to \\infty$ 时衰减。\n-   在子域 $\\Omega_1 = (-\\infty, 0)$ 中，解必须在 $x \\to -\\infty$ 时衰减。项 $e^{-k(\\omega)x}$ 的大小在 $x \\to -\\infty$ 时增长，因此其系数必须为零。解的形式因此为 $\\widehat{u}_1(x,\\omega) = A_1 e^{k(\\omega)x}$。\n-   在子域 $\\Omega_2 = (0, \\infty)$ 中，解必须在 $x \\to +\\infty$ 时衰减。项 $e^{k(\\omega)x}$ 的大小在 $x \\to +\\infty$ 时增长，因此其系数必须为零。解的形式因此为 $\\widehat{u}_2(x,\\omega) = A_2 e^{-k(\\omega)x}$。\n\nSchwarz 波形松弛迭代涉及在界面 $x=0$ 交换 Robin 边界数据。设迭代指数为 $j$。$\\Omega_1$ 的外法向量是 $n_1=+1$，因此 $\\partial_{n_1}=\\partial_x$。$\\Omega_2$ 的外法向量是 $n_2=-1$，因此 $\\partial_{n_2}=-\\partial_x$。迭代格式为：\n$$\n(\\partial_{n_1} + \\alpha) u_1^j(0,t) = (\\partial_{n_1} + \\alpha) u_2^{j-1}(0,t)\n$$\n$$\n(\\partial_{n_2} + \\alpha) u_2^j(0,t) = (\\partial_{n_2} + \\alpha) u_1^{j-1}(0,t)\n$$\n用空间导数 $\\partial_x$ 表示，即为：\n$$\n(\\partial_x + \\alpha) u_1^j(0,t) = (\\partial_x + \\alpha) u_2^{j-1}(0,t)\n$$\n$$\n(-\\partial_x + \\alpha) u_2^j(0,t) = (-\\partial_x + \\alpha) u_1^{j-1}(0,t)\n$$\n对这些传输条件进行傅里叶变换，得到：\n$$\n\\left(\\frac{d}{dx} + \\alpha\\right) \\widehat{u}_1^j(0,\\omega) = \\left(\\frac{d}{dx} + \\alpha\\right) \\widehat{u}_2^{j-1}(0,\\omega)\n$$\n$$\n\\left(-\\frac{d}{dx} + \\alpha\\right) \\widehat{u}_2^j(0,\\omega) = \\left(-\\frac{d}{dx} + \\alpha\\right) \\widehat{u}_1^{j-1}(0,\\omega)\n$$\n我们现在代入解的形式 $\\widehat{u}_1^j(x,\\omega) = A_1^j e^{k(\\omega)x}$ 和 $\\widehat{u}_2^j(x,\\omega) = A_2^j e^{-k(\\omega)x}$ 以及它们在 $x=0$ 处的导数：\n-   $\\widehat{u}_1^j(0,\\omega) = A_1^j$ 且 $\\frac{d\\widehat{u}_1^j}{dx}(0,\\omega) = k(\\omega) A_1^j$。\n-   $\\widehat{u}_2^j(0,\\omega) = A_2^j$ 且 $\\frac{d\\widehat{u}_2^j}{dx}(0,\\omega) = -k(\\omega) A_2^j$。\n\n将这些代入第一个变换后的传输条件：\n$$\nk(\\omega) A_1^j + \\alpha A_1^j = -k(\\omega) A_2^{j-1} + \\alpha A_2^{j-1} \\implies (k(\\omega)+\\alpha) A_1^j = (\\alpha-k(\\omega)) A_2^{j-1}\n$$\n代入第二个变换后的传输条件：\n$$\n-(-k(\\omega) A_2^j) + \\alpha A_2^j = -(k(\\omega) A_1^{j-1}) + \\alpha A_1^{j-1} \\implies (k(\\omega)+\\alpha) A_2^j = (\\alpha-k(\\omega)) A_1^{j-1}\n$$\n这些方程表明系数按以下方式更新：\n$$\nA_1^j = \\frac{\\alpha - k(\\omega)}{\\alpha + k(\\omega)} A_2^{j-1} \\quad \\text{and} \\quad A_2^j = \\frac{\\alpha - k(\\omega)}{\\alpha + k(\\omega)} A_1^{j-1}\n$$\n子域间交换的误差传播因子定义为：\n$$\nr(\\omega, \\alpha) = \\frac{\\alpha - k(\\omega)}{\\alpha + k(\\omega)}\n$$\n我们想要找到使模 $|r(\\omega, \\alpha)|$ 最小化的 $\\alpha  0$ 值。这等价于最小化 $|r(\\omega, \\alpha)|^2$。\n设 $k(\\omega) = a+ib$，其中 $a = \\operatorname{Re}(k(\\omega)) = \\sqrt{\\frac{\\omega}{2\\nu}}$ 且 $b = \\operatorname{Im}(k(\\omega)) = \\sqrt{\\frac{\\omega}{2\\nu}}$。\n$$\n|r(\\omega, \\alpha)|^2 = \\left| \\frac{\\alpha - (a+ib)}{\\alpha + (a+ib)} \\right|^2 = \\frac{|\\alpha-a-ib|^2}{|\\alpha+a+ib|^2} = \\frac{(\\alpha-a)^2 + b^2}{(\\alpha+a)^2 + b^2}\n$$\n设 $f(\\alpha) = |r(\\omega, \\alpha)|^2$。为了找到最小值，我们对 $f(\\alpha)$ 关于 $\\alpha$ 求导并令其为零，假设 $\\omega  0$（因此 $a0$）。\n$$\nf'(\\alpha) = \\frac{d}{d\\alpha} \\left( \\frac{\\alpha^2 - 2a\\alpha + a^2 + b^2}{\\alpha^2 + 2a\\alpha + a^2 + b^2} \\right)\n$$\n使用商法则，$f'(\\alpha) = \\frac{(2\\alpha-2a)(\\alpha^2+2a\\alpha+a^2+b^2) - (\\alpha^2-2a\\alpha+a^2+b^2)(2\\alpha+2a)}{(\\alpha^2+2a\\alpha+a^2+b^2)^2}$。\n令分子为零：\n$$\n(2\\alpha-2a)(\\alpha^2+2a\\alpha+a^2+b^2) - (\\alpha^2-2a\\alpha+a^2+b^2)(2\\alpha+2a) = 0\n$$\n$$\n2(\\alpha-a)(\\alpha^2+2a\\alpha+a^2+b^2) - 2(\\alpha+a)(\\alpha^2-2a\\alpha+a^2+b^2) = 0\n$$\n展开并化简得到：\n$$\n(\\alpha^3+a\\alpha^2+(b^2-a^2)\\alpha - a(a^2+b^2)) - (\\alpha^3-a\\alpha^2+(b^2-a^2)\\alpha + a(a^2+b^2)) = 0\n$$\n$$\n2a\\alpha^2 - 2a(a^2+b^2) = 0\n$$\n由于我们考虑 $\\omega  0$，所以有 $a  0$，因此我们可以除以 $2a$：\n$$\n\\alpha^2 - (a^2+b^2) = 0 \\implies \\alpha^2 = a^2+b^2\n$$\n因为 $\\alpha  0$，最优值为 $\\alpha^{\\star} = \\sqrt{a^2+b^2}$。这对应于复数 $k(\\omega)$ 的模，所以 $\\alpha^{\\star} = |k(\\omega)|$。\n\n现在，我们用给定的参数 $\\omega$ 和 $\\nu$ 来表示 $\\alpha^{\\star}$。\n$$\na^2 = \\left(\\sqrt{\\frac{\\omega}{2\\nu}}\\right)^2 = \\frac{\\omega}{2\\nu}\n$$\n$$\nb^2 = \\left(\\sqrt{\\frac{\\omega}{2\\nu}}\\right)^2 = \\frac{\\omega}{2\\nu}\n$$\n$$\n\\alpha^{\\star}(\\omega)^2 = a^2 + b^2 = \\frac{\\omega}{2\\nu} + \\frac{\\omega}{2\\nu} = \\frac{2\\omega}{2\\nu} = \\frac{\\omega}{\\nu}\n$$\n取平方根（并记住 $\\alpha  0, \\omega \\ge 0$），我们得到最优 Robin 参数的最终表达式：\n$$\n\\alpha^{\\star}(\\omega) = \\sqrt{\\frac{\\omega}{\\nu}}\n$$\n此表达式对 $\\omega \\ge 0$ 有效。对于 $\\omega=0$，$\\alpha^{\\star}(0)=0$，这超出了指定的定义域 $\\alpha \\in \\mathbb{R}_+$。在这种情况下，对于任何 $\\alpha0$，都有 $|r|=1$，因此没有最优选择。然而，推导出的公式给出了当 $\\omega \\to 0^+$ 时最优参数的极限。", "answer": "$$\\boxed{\\sqrt{\\frac{\\omega}{\\nu}}}$$", "id": "3519545"}, {"introduction": "当对流效应主导扩散效应时，标准的数值方法可能会变得不稳定或不准确。本练习将探讨如何利用迎风原理为对流-扩散问题设计交界面条件，这种原理尊重信息的流动方向。您将对物理通量进行离散化，并量化交界面上的通量不匹配程度，从而深入理解数值区域分解格式的相容性。[@problem_id:3519548]", "problem": "考虑一维稳态对流扩散算子 $-\\varepsilon u'' + c\\,u'$，其中参数 $\\varepsilon  0$ 和 $c  0$ 为常数。该算子作用于一个被分解为两个不重叠子区域的区域上，这两个子区域在一个人工界面点 $x_{\\Gamma}$ 相遇。在采用Robin传输条件的并行Schwarz方法（PSM）中，选择界面算子以强制实现跨越 $x_{\\Gamma}$ 的物理意义通量的连续性，并对对流部分使用迎风原理。\n\n从算子的守恒形式出发，定义连续通量 $f(x)$，使得控制方程可以写成关于 $f(x)$ 的守恒律。利用此定义，推导出一个在 $x_{\\Gamma}$ 处的迎风Robin传输算子，该算子包含了局部流动方向（$c0$），并论证一个合适的Robin系数，该系数能在通量连续性的意义上得到一个一致的界面条件。\n\n在间距为 $h$ 的均匀网格上，从左子区域出发，在界面处的向外单边离散导数为\n$$\nD^{-}u(x_{\\Gamma}^{-}) \\approx \\frac{u_{m}^{(L)} - u_{m-1}^{(L)}}{h},\n$$\n从右子区域出发为\n$$\nD^{+}u(x_{\\Gamma}^{+}) \\approx \\frac{u_{m+1}^{(R)} - u_{m}^{(R)}}{h},\n$$\n其中 $u_{m-1}^{(L)}, u_{m}^{(L)}$ 是左子区域的最后两个网格值，$u_{m}^{(R)}, u_{m+1}^{(R)}$ 是右子区域的最前两个网格值，且 $x_{\\Gamma}$ 与索引为 $m$ 的网格点重合。当 $c0$ 时，对界面处的对流贡献使用一阶迎风处理，计算来自每一侧的离散通量，并构成离散通量跳跃 $\\Delta f := f^{+} - f^{-}$。\n\n给定数值\n$$\n\\varepsilon = 5.0 \\times 10^{-2}, \\quad c = 2, \\quad h = 1.0 \\times 10^{-1},\n$$\n以及界面邻近的网格值\n$$\nu_{m-1}^{(L)} = 1.0, \\quad u_{m}^{(L)} = 9.0 \\times 10^{-1}, \\quad u_{m}^{(R)} = 8.8 \\times 10^{-1}, \\quad u_{m+1}^{(R)} = 8.2 \\times 10^{-1},\n$$\n计算由迎风Robin传输在 $x_{\\Gamma}$ 处引起的离散通量跳跃 $\\Delta f$，并将最终数值结果表示为一个纯数。将答案四舍五入到四位有效数字。", "solution": "本问题要求计算一维稳态对流扩散问题在区域分解界面处的离散通量跳跃。该过程首先从控制算子中识别物理通量，推导界面条件，然后应用指定的离散化和迎风规则。\n\n控制算子为 $\\mathcal{L}u = -\\varepsilon u'' + c u'$，其中常数 $\\varepsilon  0$ 和 $c  0$。该算子可以写成通量函数 $f(x)$ 的导数的守恒形式。通过对算子关于 $x$ 积分，我们将通量确定为：\n$$\nf(x) = -\\varepsilon u'(x) + c u(x)\n$$\n因此，齐次控制方程 $\\mathcal{L}u = 0$ 等价于守恒律 $f'(x) = 0$，这意味着在任何无源区域内，通量 $f(x)$ 是一个常数。在界面 $x_{\\Gamma}$ 处一个物理上一致的条件是该通量的连续性，即 $[f]_{x_{\\Gamma}} = f(x_{\\Gamma}^{+}) - f(x_{\\Gamma}^{-}) = 0$。\n\n在采用Robin传输条件的并行Schwarz方法中，形式为 $-\\varepsilon u' + p u = \\text{RHS}$ 的条件被应用于每个子区域的边界。问题要求推导一个“迎风Robin传输算子”。对于Robin参数 $p$，一个自然且物理上一致的选择是 $p=c$。通过此选择，Robin算子 $-\\varepsilon u' + c u$ 变得与物理通量算子 $f(x)$ 完全相同。这一选择直接强制了物理通量的连续性，并将对流输运的方向性（$c0$）包含在传输条件本身之中。\n\n问题接着要求计算在界面点 $x_{\\Gamma}$ 处的离散通量跳跃 $\\Delta f = f^{+} - f^{-}$，该点与索引为 $m$ 的网格点重合。这需要对界面两侧的通量表达式 $f(x)$ 进行离散化。\n\n通量的扩散部分是 $-\\varepsilon u'$。问题提供了以下在 $x_{\\Gamma}$ 处使用来自左（L）和右（R）子区域数据的导数 $u'$ 的单边有限差分近似：\n$$\nu'^{(L)}(x_{\\Gamma}) \\approx d_L = \\frac{u_{m}^{(L)} - u_{m-1}^{(L)}}{h}\n$$\n$$\nu'^{(R)}(x_{\\Gamma}) \\approx d_R = \\frac{u_{m+1}^{(R)} - u_{m}^{(R)}}{h}\n$$\n\n通量的对流部分是 $c u$。问题指定了“界面处对流贡献的一阶迎风处理”。由于对流系数 $c  0$，信息流是从左到右。因此，对流项在界面处的值 $u$ 应取自迎风（左）侧。离散值为 $u_{m}^{(L)}$。为确保一致性，计算界面左右两侧的对流通量贡献时，使用相同的迎风值。\n\n使用这些离散化，我们可以表示来自界面每一侧的离散通量。来自左侧的离散通量 $f_h^{-}$ 为：\n$$\nf_h^{-} = -\\varepsilon d_L + c u_{m}^{(L)} = -\\varepsilon \\frac{u_{m}^{(L)} - u_{m-1}^{(L)}}{h} + c u_{m}^{(L)}\n$$\n来自右侧的离散通量 $f_h^{+}$ 使用右侧的导数，但使用相同的迎风对流项：\n$$\nf_h^{+} = -\\varepsilon d_R + c u_{m}^{(L)} = -\\varepsilon \\frac{u_{m+1}^{(R)} - u_{m}^{(R)}}{h} + c u_{m}^{(L)}\n$$\n离散通量跳跃 $\\Delta f$ 是这两个量之差：\n$$\n\\Delta f = f_h^{+} - f_h^{-} = \\left(-\\varepsilon \\frac{u_{m+1}^{(R)} - u_{m}^{(R)}}{h} + c u_{m}^{(L)}\\right) - \\left(-\\varepsilon \\frac{u_{m}^{(L)} - u_{m-1}^{(L)}}{h} + c u_{m}^{(L)}\\right)\n$$\n迎风对流项是相同的，因此相互抵消：\n$$\n\\Delta f = -\\varepsilon \\frac{u_{m+1}^{(R)} - u_{m}^{(R)}}{h} + \\varepsilon \\frac{u_{m}^{(L)} - u_{m-1}^{(L)}}{h} = \\frac{\\varepsilon}{h} \\left[ (u_{m}^{(L)} - u_{m-1}^{(L)}) - (u_{m+1}^{(R)} - u_{m}^{(R)}) \\right]\n$$\n我们得到以下数值：\n$\\varepsilon = 5.0 \\times 10^{-2}$\n$c = 2$\n$h = 1.0 \\times 10^{-1}$\n$u_{m-1}^{(L)} = 1.0$\n$u_{m}^{(L)} = 9.0 \\times 10^{-1} = 0.9$\n$u_{m}^{(R)} = 8.8 \\times 10^{-1} = 0.88$\n$u_{m+1}^{(R)} = 8.2 \\times 10^{-1} = 0.82$\n\n我们将这些值代入 $\\Delta f$ 的表达式中：\n$$\n\\Delta f = \\frac{5.0 \\times 10^{-2}}{1.0 \\times 10^{-1}} \\left[ (0.9 - 1.0) - (0.82 - 0.88) \\right]\n$$\n$$\n\\Delta f = 0.5 \\left[ (-0.1) - (-0.06) \\right]\n$$\n$$\n\\Delta f = 0.5 \\left[ -0.1 + 0.06 \\right]\n$$\n$$\n\\Delta f = 0.5 \\left[ -0.04 \\right]\n$$\n$$\n\\Delta f = -0.02\n$$\n问题要求答案四舍五入到四位有效数字。数字 $-0.02$ 可以写成 $-2.000 \\times 10^{-2}$，所以用四位有效数字的小数形式表示，它是 $-0.02000$。", "answer": "$$\\boxed{-0.02000}$$", "id": "3519548"}, {"introduction": "求解非线性多物理场问题通常需要稳健且可扩展的并行算法，其中加性 Schwarz 预处理非精确牛顿 (ASPIN) 方法就是一个杰出的例子。这项动手编程挑战要求您为一个非线性扩散问题实现一次完整的 ASPIN 迭代。通过完成这项任务，您将在构建局部非线性子域求解和组装全局校正量方面获得实践经验，这些都是开发高级计算模拟的关键技能。[@problem_id:3519591]", "problem": "实现单次加性 Schwarz 预处理非精确牛顿 (ASPIN) 迭代，用于求解一个模拟多物理场环境中某个标量场耦合的非线性一维扩散问题。考虑在单位区间上的非线性泊松方程，其边界条件为齐次狄利克雷边界条件，\n$$\n-\\frac{d}{dx}\\left(\\left(1+u(x)^2\\right)\\frac{du(x)}{dx}\\right) = f(x), \\quad x \\in (0,1), \\quad u(0)=0,\\; u(1)=0.\n$$\n使用一个包含 $N$ 个内部点的均匀网格，网格尺寸为 $h = \\frac{1}{N+1}$，网格点为 $x_i = i h$（$i = 1,2,\\dots,N$）。使用标准的二阶守恒模板，通过施加通量守恒来离散化该方程。记 $u_i \\approx u(x_i)$，并通过以下公式定义在单元面上的非线性扩散系数：\n$$\na_{i+\\frac{1}{2}}(u) = 1 + \\left(\\frac{u_i + u_{i+1}}{2}\\right)^2, \\quad a_{i-\\frac{1}{2}}(u) = 1 + \\left(\\frac{u_{i-1} + u_{i}}{2}\\right)^2.\n$$\n对于 $i=1,\\dots,N$，按分量定义离散非线性残差 $F(u) \\in \\mathbb{R}^N$ 如下：\n$$\nF_i(u) = \\frac{1}{h^2}\\left(a_{i+\\frac{1}{2}}(u)\\left(u_{i+1}-u_i\\right) - a_{i-\\frac{1}{2}}(u)\\left(u_i-u_{i-1}\\right)\\right) - f_i,\n$$\n其中边界值为 $u_0=0$ 和 $u_{N+1}=0$，且 $f_i \\approx f(x_i)$。离散残差的欧几里得范数为\n$$\n\\|F(u)\\|_2 = \\left(\\sum_{i=1}^N F_i(u)^2\\right)^{1/2}.\n$$\n将内部索引集划分为两个重叠的子区域，具体如下。设 $m = \\left\\lfloor \\frac{N}{2} \\right\\rfloor$，重叠大小为 $p \\in \\mathbb{N}$，且满足 $1 \\le p \\le \\min(m, N-m)$。定义子区域索引集\n$$\n\\Omega_1 = \\{1,2,\\dots,m+p\\}, \\quad \\Omega_2 = \\{m+1-p, m+2-p, \\dots, N\\}.\n$$\n对于 $k \\in \\{1,2\\}$，在每个子区域 $\\Omega_k$ 上，通过将离散残差方程限制在 $\\Omega_k$ 内的索引上，并根据当前的全局迭代解 $u^{(0)}$ 在人工子区域边界上施加狄利克雷边界数据，来构建一个局部非线性问题：\n- 对于 $\\Omega_1$，在物理左边界处使用 $u_0=0$，并使用 $u_{m+p+1} = u^{(0)}_{m+p+1}$ 作为人工右边界条件。\n- 对于 $\\Omega_2$，使用 $u_{m-p} = u^{(0)}_{m-p}$ 作为人工左边界条件，并在物理右边界处使用 $u_{N+1}=0$。\n\n令 $G_k(u^{(0)})$ 表示在 $\\Omega_k$ 上满足这些边界条件的局部非线性系统 $F_{\\Omega_k}(v)=0$ 的解，即子区域节点值向量。通过在每个子区域上应用牛顿法来计算这些局部解，其中使用从离散残差导出的雅可比矩阵和回溯线搜索，以确保局部残差范数有足够的下降。使用 $u^{(0)}$ 在子区域上的限制值来初始化牛顿法。\n\n将每个子区域上的非线性预处理校正定义为 $c_k = G_k(u^{(0)}) - u^{(0)}|_{\\Omega_k}$，并通过在重叠区域进行等权重处理来组装全局校正 $c \\in \\mathbb{R}^N$：\n$$\nc_i = \\begin{cases}\nc_{1,i}  \\text{如果 } i \\in \\Omega_1 \\setminus \\Omega_2,\\\\\nc_{2,i}  \\text{如果 } i \\in \\Omega_2 \\setminus \\Omega_1,\\\\\n\\frac{1}{2}\\left(c_{1,i}+c_{2,i}\\right)  \\text{如果 } i \\in \\Omega_1 \\cap \\Omega_2,\\\\\n0  \\text{其他情况}.\n\\end{cases}\n$$\n执行一次 ASPIN 更新，阻尼参数为 $\\alpha \\in (0,2]$：\n$$\nu^{(1)} = u^{(0)} + \\alpha\\, c.\n$$\n您的任务是实现上述过程于一个单独的程序中，该程序为每个测试用例计算一次 ASPIN 迭代后残差范数的下降量 $\\Delta$，该下降量定义为\n$$\n\\Delta = \\|F(u^{(0)})\\|_2 - \\|F(u^{(1)})\\|_2.\n$$\n将 $f(x)$ 在网格上离散化为 $f_i = f(x_i)$，并为 $f(x)$ 使用以下选项：\n- 常数源：$f(x) = A$，其中 $A \\in \\mathbb{R}$。\n- 正弦源：$f(x) = A \\sin(\\kappa \\pi x)$，其中 $A \\in \\mathbb{R}$ 且 $\\kappa \\in \\mathbb{N}$。\n\n根据测试用例的指定，将 $u^{(0)}$ 初始化为零向量或振幅为 $B \\in \\mathbb{R}$ 的小正弦波 $u^{(0)}_i = B \\sin(\\pi x_i)$。\n\n通过对离散残差 $F_{\\Omega_k}$ 求关于子区域未知数的导数，来设计并实现在每个子区域上的牛顿法。对 $a_{i\\pm\\frac{1}{2}}(u)$ 使用链式法则，其中\n$$\n\\frac{\\partial a_{i+\\frac{1}{2}}}{\\partial u_i} = \\frac{u_i+u_{i+1}}{2}, \\quad \\frac{\\partial a_{i+\\frac{1}{2}}}{\\partial u_{i+1}} = \\frac{u_i+u_{i+1}}{2}, \\quad\n\\frac{\\partial a_{i-\\frac{1}{2}}}{\\partial u_i} = \\frac{u_{i-1}+u_{i}}{2}, \\quad \\frac{\\partial a_{i-\\frac{1}{2}}}{\\partial u_{i-1}} = \\frac{u_{i-1}+u_{i}}{2}.\n$$\n确保局部雅可比矩阵仅包含关于子区域内部未知数的导数；将边界值视为常数。\n\n测试套件：\n为以下四个测试用例提供程序输出，每个测试用例是一个元组 $(N, p, \\alpha, f\\_type, A, \\kappa, B)$，其语义如下：\n- $N$：内部点的数量。\n- $p$：以网格点数表示的重叠大小。\n- $\\alpha$：ASPIN 阻尼参数。\n- $f\\_type$：字符串，\"constant\" 或 \"sine\"。\n- $A$：$f(x)$ 中的源项振幅。\n- $\\kappa$：正弦源的整数波数（对于 \"constant\" 则忽略）。\n- $B$：$u^{(0)}_i = B \\sin(\\pi x_i)$ 中 $u^{(0)}$ 的初始振幅；如果 $B=0$，则使用零初始猜测。\n\n使用以下测试用例：\n- 用例 1：$(N=\\;63,\\, p=\\;5,\\, \\alpha=\\;1.0,\\, f\\_type=\\;\\text{\"constant\"},\\, A=\\;1.0,\\, \\kappa=\\;1,\\, B=\\;0.0)$\n- 用例 2：$(N=\\;63,\\, p=\\;1,\\, \\alpha=\\;1.0,\\, f\\_type=\\;\\text{\"constant\"},\\, A=\\;1.0,\\, \\kappa=\\;1,\\, B=\\;0.0)$\n- 用例 3：$(N=\\;63,\\, p=\\;5,\\, \\alpha=\\;0.5,\\, f\\_type=\\;\\text{\"sine\"},\\, A=\\;1.0,\\, \\kappa=\\;2,\\, B=\\;0.0)$\n- 用例 4：$(N=\\;31,\\, p=\\;3,\\, \\alpha=\\;1.0,\\, f\\_type=\\;\\text{\"sine\"},\\, A=\\;0.5,\\, \\kappa=\\;3,\\, B=\\;0.1)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个下降量 $\\Delta$，格式为用方括号括起来的逗号分隔列表（例如，\"[d1,d2,d3,d4]\"）。所有值必须表示为浮点数。本问题不使用物理单位。本问题不涉及角度，因此不需要角度单位。本问题不使用百分比。输出必须是确定性的，并且不得需要任何用户输入。", "solution": "用户提供的问题经评估有效。该问题概述了执行单次加性 Schwarz 预处理非精确牛顿 (ASPIN) 方法的完整且数值上可靠的流程。该问题在科学上基于非线性偏微分方程的数值分析，特别是一维非线性泊松方程。所有定义，包括离散化方案、非线性系数、残差、雅可比矩阵、区域分解以及 ASPIN 更新规则，都是标准的且数学上精确的。作为一个计算任务，该问题是适定的，在测试套件中提供了所有必要的参数和初始条件，使其自成体系且没有歧义。未发现矛盾或事实错误。该任务并非无关紧要，需要仔细实现嵌套的数值算法（在区域分解框架内的带线搜索的牛顿法）。因此，有必要提供完整的解决方案。\n\n解决方案是按照问题陈述中描述的算法步骤实现的。\n\n1.  **全局设置**：对于每个测试用例，初始化网格参数（$N$、$h$）、源向量 $f$ 和初始猜测 $u^{(0)}$。网格由 $N$ 个内部点 $x_i = (i+1)h$（$i=0, \\dots, N-1$）组成，网格尺寸为 $h=1/(N+1)$。\n\n2.  **初始残差**：使用提供的守恒有限体积离散化公式计算初始全局残差向量 $F(u^{(0)})$。计算并存储其欧几里得范数 $\\|F(u^{(0)})\\|_2$。这需要计算每个控制体面上的非线性扩散系数 $a_{i\\pm1/2}(u)$。\n\n3.  **区域分解**：将包含 $N$ 个网格点的全局区域根据网格点数 $N$ 和指定的重叠大小 $p$ 划分为两个重叠的子区域 $\\Omega_1$ 和 $\\Omega_2$。中间点索引为 $m = \\lfloor N/2 \\rfloor$。使用从 0 开始的索引，子区域为：\n    *   $\\Omega_1 = \\{0, 1, \\dots, m+p-1\\}$\n    *   $\\Omega_2 = \\{m-p, \\dots, N-1\\}$\n\n4.  **局部非线性求解**：在每个子区域 $\\Omega_k$ 上，使用牛顿法求解一个独立的非线性边值问题。\n    *   $\\Omega_k$ 的局部问题由所有索引 $i \\in \\Omega_k$ 的残差方程 $F_i(v)=0$ 组成。\n    *   使用全局迭代解 $u^{(0)}$ 的值在子区域边界上施加狄利克雷边界条件。对于 $\\Omega_1$，边界值为 $u_0=0$ 和 $u_{m+p} = u^{(0)}_{m+p}$。对于 $\\Omega_2$，边界值为 $u_{m-p-1} = u^{(0)}_{m-p-1}$ 和 $u_N=0$。\n    *   **牛顿法**：局部系统被迭代求解。在每个牛顿步骤中，我们求解线性系统 $J_k \\delta v = -F_k(v)$ 以获得更新量 $\\delta v$。\n        *   **雅可比矩阵 $J_k$**：局部残差 $F_k$ 的雅可比矩阵是一个三对角矩阵。其元素通过对离散残差公式求关于局部未知数 $v_j$ 的导数得出。对应于未知数 $u_i$ 的雅可比矩阵第 $i$ 行的元素为：\n            $$J_{i,i-1} = \\frac{\\partial F_i}{\\partial u_{i-1}} = \\frac{1}{h^2} \\left(a_{i-1/2} - \\frac{u_{i-1}+u_i}{2}(u_i-u_{i-1})\\right)$$\n            $$J_{i,i} = \\frac{1}{h^2} \\left[ \\left(\\frac{u_i+u_{i+1}}{2}(u_{i+1}-u_i) - a_{i+1/2}\\right) - \\left(\\frac{u_{i-1}+u_i}{2}(u_i-u_{i-1}) + a_{i-1/2}\\right) \\right]$$\n            $$J_{i,i+1} = \\frac{\\partial F_i}{\\partial u_{i+1}} = \\frac{1}{h^2} \\left(\\frac{u_i+u_{i+1}}{2}(u_{i+1}-u_i) + a_{i+1/2}\\right)$$\n        *   **线搜索**：计算出牛顿更新量 $\\delta v$ 后，采用回溯线搜索来寻找一个满足 Armijo 条件的步长 $\\lambda$，以确保局部残差范数的充分下降。然后更新解 $v \\leftarrow v + \\lambda \\delta v$。\n    *   牛顿迭代持续进行，直到局部残差的范数降至指定容差以下，从而得到局部解 $G_k(u^{(0)})$。\n\n5.  **校正组装**：计算局部校正量 $c_k = G_k(u^{(0)}) - u^{(0)}|_{\\Omega_k}$。然后将它们组合成一个全局校正向量 $c$。在子区域的非重叠部分，校正量直接取自相应的子区域。在重叠区域，对来自两个子区域的校正量进行平均：\n    $$\n    c_i = \\begin{cases}\n    c_{1,i}  \\text{如果 } i \\in \\Omega_1 \\setminus \\Omega_2\\\\\n    c_{2,i}  \\text{如果 } i \\in \\Omega_2 \\setminus \\Omega_1\\\\\n    \\frac{1}{2}\\left(c_{1,i}+c_{2,i}\\right)  \\text{如果 } i \\in \\Omega_1 \\cap \\Omega_2\n    \\end{cases}\n    $$\n\n6.  **ASPIN 更新**：使用组装好的校正量和阻尼参数 $\\alpha$ 更新全局解：\n    $$u^{(1)} = u^{(0)} + \\alpha c$$\n\n7.  **最终残差与结果**：计算最终残差向量 $F(u^{(1)})$ 及其范数 $\\|F(u^{(1)})\\|_2$。该测试用例的最终结果是残差范数的下降量，即 $\\Delta = \\|F(u^{(0)})\\|_2 - \\|F(u^{(1)})\\|_2$。\n\n整个过程被封装在一个 Python 程序中，该程序遍历所提供的测试套件并打印最终结果。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Implements a single Additive Schwarz Preconditioned Inexact Newton (ASPIN)\n    iteration for a 1D nonlinear diffusion problem and computes the\n    decrease in the residual norm for a given set of test cases.\n    \"\"\"\n\n    def _calculate_residual(u, f_sub, h, bc_left=0.0, bc_right=0.0):\n        \"\"\"Calculates the nonlinear residual vector for a given solution u.\"\"\"\n        n = len(u)\n        if n == 0:\n            return np.array([])\n        \n        u_padded = np.concatenate(([bc_left], u, [bc_right]))\n        \n        u_m = u_padded[:-2]\n        u_c = u_padded[1:-1]\n        u_p = u_padded[2:]\n\n        a_iph = 1.0 + ((u_c + u_p) / 2.0)**2\n        a_imh = 1.0 + ((u_m + u_c) / 2.0)**2\n\n        flux_p = a_iph * (u_p - u_c)\n        flux_m = a_imh * (u_c - u_m)\n\n        res = (flux_p - flux_m) / h**2 - f_sub\n        return res\n\n    def _calculate_jacobian_banded(u, h, bc_left=0.0, bc_right=0.0):\n        \"\"\"Calculates the tridiagonal Jacobian matrix in banded format.\"\"\"\n        n = len(u)\n        if n == 0:\n            return np.zeros((3, 0))\n\n        u_padded = np.concatenate(([bc_left], u, [bc_right]))\n        \n        u_m = u_padded[:-2]\n        u_c = u_padded[1:-1]\n        u_p = u_padded[2:]\n\n        a_iph = 1.0 + ((u_c + u_p) / 2.0)**2\n        a_imh = 1.0 + ((u_m + u_c) / 2.0)**2\n\n        term_p = (u_c + u_p) / 2.0 * (u_p - u_c)\n        term_m = (u_m + u_c) / 2.0 * (u_c - u_m)\n\n        # Main diagonal\n        main_diag = (term_p - a_iph - term_m - a_imh) / h**2\n        \n        # Upper diagonal\n        upper_diag = (term_p + a_iph) / h**2\n        \n        # Lower diagonal\n        lower_diag = (a_imh - term_m) / h**2\n\n        ab = np.zeros((3, n))\n        ab[0, 1:] = upper_diag[:-1]\n        ab[1, :] = main_diag\n        ab[2, :-1] = lower_diag[1:]\n        \n        return ab\n\n    def _solve_local_newton(u_initial, f_sub, h, bc_left, bc_right,\n                            max_iter=30, tol=1e-10):\n        \"\"\"Solves the local nonlinear problem using Newton's method.\"\"\"\n        v = u_initial.copy()\n        gamma = 1e-4  # Armijo condition constant\n        tau = 0.5     # Backtracking step reduction factor\n        \n        for _ in range(max_iter):\n            res_v = _calculate_residual(v, f_sub, h, bc_left, bc_right)\n            norm_res_v = np.linalg.norm(res_v)\n            \n            if norm_res_v  tol:\n                break\n\n            J_banded = _calculate_jacobian_banded(v, h, bc_left, bc_right)\n            \n            try:\n                # Solve the linear system J * dv = -F\n                delta_v = solve_banded((1, 1), J_banded, -res_v)\n            except np.linalg.LinAlgError:\n                # Failsafe for singular Jacobian\n                break\n\n            # Backtracking line search\n            lmbda = 1.0\n            v_new = v + lmbda * delta_v\n            res_v_new = _calculate_residual(v_new, f_sub, h, bc_left, bc_right)\n            norm_res_v_new = np.linalg.norm(res_v_new)\n\n            while norm_res_v_new > (1 - gamma * lmbda) * norm_res_v:\n                lmbda *= tau\n                if lmbda  1e-8: # Failsafe for line search\n                    v_new = v # No update\n                    norm_res_v_new = norm_res_v\n                    break\n                v_new = v + lmbda * delta_v\n                res_v_new = _calculate_residual(v_new, f_sub, h, bc_left, bc_right)\n                norm_res_v_new = np.linalg.norm(res_v_new)\n            \n            v = v_new\n        \n        return v\n\n    def run_aspin_iteration(N, p, alpha, f_type, A, kappa, B):\n        \"\"\"Performs one full ASPIN iteration for a given test case.\"\"\"\n        # 1. Setup grid, initial guess, and source term\n        h = 1.0 / (N + 1)\n        x = np.linspace(h, 1.0 - h, N)\n\n        if f_type == \"constant\":\n            f_vec = np.full(N, A)\n        else: # \"sine\"\n            f_vec = A * np.sin(kappa * np.pi * x)\n\n        if B == 0.0:\n            u0 = np.zeros(N)\n        else:\n            u0 = B * np.sin(np.pi * x)\n\n        # 2. Calculate initial residual norm\n        res0 = _calculate_residual(u0, f_vec, h)\n        res0_norm = np.linalg.norm(res0)\n\n        # 3. Define subdomains (0-based indexing)\n        m = N // 2\n        \n        # Subdomain 1 indices\n        idx1_start = 0\n        idx1_end = m + p\n        \n        # Subdomain 2 indices\n        idx2_start = m - p\n        idx2_end = N\n\n        # 4. Solve local nonlinear problems\n        # Subdomain 1\n        u0_sub1 = u0[idx1_start:idx1_end]\n        f_sub1 = f_vec[idx1_start:idx1_end]\n        bc_left1 = 0.0\n        bc_right1 = u0[idx1_end] if idx1_end  N else 0.0\n        v1 = _solve_local_newton(u0_sub1, f_sub1, h, bc_left1, bc_right1)\n\n        # Subdomain 2\n        u0_sub2 = u0[idx2_start:idx2_end]\n        f_sub2 = f_vec[idx2_start:idx2_end]\n        bc_left2 = u0[idx2_start - 1] if idx2_start > 0 else 0.0\n        bc_right2 = 0.0\n        v2 = _solve_local_newton(u0_sub2, f_sub2, h, bc_left2, bc_right2)\n\n        # 5. Assemble global correction vector\n        c1 = v1 - u0_sub1\n        c2 = v2 - u0_sub2\n        c = np.zeros(N)\n        \n        overlap_size = 2*p\n        \n        # Part 1: Omega1 exclusive\n        c[0 : m-p] = c1[0 : m-p]\n        # Part 2: Overlap\n        c[m-p : m+p] = 0.5 * (c1[m-p : m+p] + c2[0 : overlap_size])\n        # Part 3: Omega2 exclusive\n        c[m+p : N] = c2[overlap_size:]\n\n        # 6. Apply ASPIN update\n        u1 = u0 + alpha * c\n\n        # 7. Calculate final residual and norm decrease\n        res1 = _calculate_residual(u1, f_vec, h)\n        res1_norm = np.linalg.norm(res1)\n        \n        delta = res0_norm - res1_norm\n        return delta\n\n    test_cases = [\n        (63, 5, 1.0, \"constant\", 1.0, 1, 0.0),\n        (63, 1, 1.0, \"constant\", 1.0, 1, 0.0),\n        (63, 5, 0.5, \"sine\", 1.0, 2, 0.0),\n        (31, 3, 1.0, \"sine\", 0.5, 3, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, p, alpha, f_type, A, kappa, B = case\n        delta = run_aspin_iteration(N, p, alpha, f_type, A, kappa, B)\n        results.append(delta)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3519591"}]}