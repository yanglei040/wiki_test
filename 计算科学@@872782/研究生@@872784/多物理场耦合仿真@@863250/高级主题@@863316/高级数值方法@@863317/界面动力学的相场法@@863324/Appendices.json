{"hands_on_practices": [{"introduction": "相场模型的参数（如梯度能量系数 $\\kappa$ 和双势阱高度 $\\lambda$）如何与可测量的物理量（如表面张力）联系起来？这是一个核心问题。本练习将通过一个经典的解析推导来回答这个问题，您将运用变分原理和能量守恒定律，从一维静态界面轮廓的自由能泛函中精确计算出表面张力 $\\sigma$。这个实践不仅能加深您对模型物理意义的理解，也是进行模型参数化和验证的关键一步。[@problem_id:3521619]", "problem": "考虑一个二元体系中的一维平面平衡界面，该界面由相场序参量 $\\,\\phi(x)\\,$ 描述，且满足 $\\,\\phi(-\\infty)=-1\\,$ 和 $\\,\\phi(+\\infty)=+1\\,$。单位面积的亥姆霍兹自由能泛函取为\n$$\n\\mathcal{F}[\\phi] \\;=\\; \\int_{-\\infty}^{+\\infty} \\left[ \\frac{\\kappa}{2}\\left(\\frac{d\\phi}{dx}\\right)^{2} \\;+\\; \\lambda\\,W(\\phi) \\right]\\,dx,\n$$\n其中 $\\,\\kappa0\\,$ 是梯度能量系数，$\\,\\lambda0\\,$ 是体能量尺度，双阱势为\n$$\nW(\\phi) \\;=\\; \\frac{1}{4}\\left(\\phi^{2}-1\\right)^{2}.\n$$\n假设体系处于力学平衡状态，界面是静态且平面的，因此平衡剖面 $\\,\\phi(x)\\,$ 在给定的边界条件下使 $\\,\\mathcal{F}\\,$ 最小化。表面张力 $\\,\\sigma\\,$ 定义为与界面相关的单位面积过剩自由能，由下式给出\n$$\n\\sigma \\;=\\; \\int_{-\\infty}^{+\\infty} \\left[ \\frac{\\kappa}{2}\\left(\\frac{d\\phi}{dx}\\right)^{2} \\;+\\; \\lambda\\,W(\\phi) \\right]\\,dx,\n$$\n由于 $\\,W(\\pm 1)=0\\,$，均匀体相的贡献已被隐式减去。\n\n从基本变分原理和一维静态剖面中的能量守恒出发，推导平衡剖面 $\\,\\phi(x)\\,$ 的必要关系式，并计算 $\\,\\sigma\\,$ 的闭合形式解析表达式（用 $\\,\\kappa\\,$ 和 $\\,\\lambda\\,$ 表示）。然后，解释该值与在保持相同体相热力学性质的同时，取界面厚度趋于零的极限所得到的相应尖锐界面表面张力相比如何。\n\n请将 $\\,\\sigma\\,$ 的最终答案以 $\\,\\kappa\\,$ 和 $\\,\\lambda\\,$ 的单一、简化解析表达式形式给出。无需四舍五入。在最终的方框答案中不要包含单位。", "solution": "该问题要求推导一维相场模型的平衡剖面方程，并计算相应的表面张力 $\\sigma$。该问题陈述经核实具有科学依据、是适定且客观的。它代表了扩散界面理论中的一个典型问题。\n\n单位面积的亥姆霍兹自由能泛函由下式给出\n$$\n\\mathcal{F}[\\phi] = \\int_{-\\infty}^{+\\infty} \\mathcal{L}(\\phi, \\phi') \\,dx = \\int_{-\\infty}^{+\\infty} \\left[ \\frac{\\kappa}{2}\\left(\\frac{d\\phi}{dx}\\right)^{2} + \\lambda\\,W(\\phi) \\right]\\,dx\n$$\n其中 $\\phi' = \\frac{d\\phi}{dx}$，双阱势为 $W(\\phi) = \\frac{1}{4}(\\phi^2-1)^2$。参数 $\\kappa$ 和 $\\lambda$ 是正常数。边界条件为 $\\phi(x \\to -\\infty) = -1$ 和 $\\phi(x \\to +\\infty) = +1$。\n\n平衡剖面 $\\phi(x)$ 是使该泛函最小化的函数。根据变分法，极小值函数必须满足欧拉-拉格朗日方程：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\phi} - \\frac{d}{dx}\\left(\\frac{\\partial \\mathcal{L}}{\\partial \\phi'}\\right) = 0\n$$\n首先，我们计算被积函数 $\\mathcal{L}(\\phi, \\phi') = \\frac{\\kappa}{2}(\\phi')^2 + \\lambda W(\\phi)$ 所需的偏导数：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\phi} = \\lambda \\frac{dW}{d\\phi} = \\lambda \\frac{d}{d\\phi}\\left[\\frac{1}{4}(\\phi^4 - 2\\phi^2 + 1)\\right] = \\lambda (\\phi^3 - \\phi)\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial \\phi'} = \\kappa \\phi' = \\kappa \\frac{d\\phi}{dx}\n$$\n将这些代入欧拉-拉格朗日方程，得到平衡剖面的控制常微分方程：\n$$\n\\lambda (\\phi^3 - \\phi) - \\frac{d}{dx}\\left(\\kappa \\frac{d\\phi}{dx}\\right) = 0\n$$\n$$\n\\kappa \\frac{d^2\\phi}{dx^2} = \\lambda (\\phi^3 - \\phi)\n$$\n这就是静态一维平衡剖面 $\\phi(x)$ 的必要关系式。\n\n为了计算表面张力 $\\sigma = \\mathcal{F}[\\phi_{\\text{eq}}]$，我们可以先求出欧拉-拉格朗日方程的一阶积分。这类似于经典力学问题中的能量守恒。我们将平衡方程乘以 $\\frac{d\\phi}{dx}$：\n$$\n\\kappa \\frac{d^2\\phi}{dx^2}\\frac{d\\phi}{dx} - \\lambda (\\phi^3 - \\phi)\\frac{d\\phi}{dx} = 0\n$$\n认识到每一项都是关于 $x$ 的全导数：\n$$\n\\frac{d}{dx}\\left[\\frac{\\kappa}{2}\\left(\\frac{d\\phi}{dx}\\right)^2\\right] - \\frac{d}{dx}[\\lambda W(\\phi)] = 0\n$$\n$$\n\\frac{d}{dx}\\left[\\frac{\\kappa}{2}\\left(\\frac{d\\phi}{dx}\\right)^2 - \\lambda W(\\phi)\\right] = 0\n$$\n这意味着括号中的量沿着剖面是一个常数。我们可以利用在 $x \\to \\pm\\infty$ 处的边界条件来计算这个常数。在无穷远处，体系处于体相中，因此剖面是平坦的，$\\frac{d\\phi}{dx} \\to 0$。同时，$\\phi \\to \\pm 1$，根据定义，$W(\\pm 1) = \\frac{1}{4}((\\pm 1)^2 - 1)^2 = 0$。因此，该常数为零。这就为平衡剖面得出了一个关键关系：\n$$\n\\frac{\\kappa}{2}\\left(\\frac{d\\phi}{dx}\\right)^2 = \\lambda W(\\phi)\n$$\n该关系表明，在界面内的每一点 $x$ 处，梯度能量密度和体势能密度之间存在均分关系。\n\n现在我们可以计算表面张力 $\\sigma$，它是在平衡剖面下泛函 $\\mathcal{F}$ 的值：\n$$\n\\sigma = \\int_{-\\infty}^{+\\infty} \\left[ \\frac{\\kappa}{2}\\left(\\frac{d\\phi}{dx}\\right)^{2} + \\lambda W(\\phi) \\right]\\,dx\n$$\n使用均分关系 $\\lambda W(\\phi) = \\frac{\\kappa}{2}(\\frac{d\\phi}{dx})^2$，我们可以简化被积函数：\n$$\n\\sigma = \\int_{-\\infty}^{+\\infty} \\left[ \\frac{\\kappa}{2}\\left(\\frac{d\\phi}{dx}\\right)^{2} + \\frac{\\kappa}{2}\\left(\\frac{d\\phi}{dx}\\right)^{2} \\right]\\,dx = \\int_{-\\infty}^{+\\infty} \\kappa \\left(\\frac{d\\phi}{dx}\\right)^2 dx\n$$\n一种无需显式求解 $\\phi(x)$ 即可计算此积分的巧妙方法是，将积分变量从 $x$ 更改为 $\\phi$。从均分关系中，我们有：\n$$\n\\frac{d\\phi}{dx} = \\sqrt{\\frac{2\\lambda W(\\phi)}{\\kappa}}\n$$\n（我们取正根，因为当 $x$ 从 $-\\infty$ 增加到 $+\\infty$ 时，$\\phi$ 从 $-1$ 增加到 $+1$）。\n我们可以将 $\\sigma$ 的积分写为：\n$$\n\\sigma = \\int_{-\\infty}^{+\\infty} \\kappa \\left(\\frac{d\\phi}{dx}\\right) \\left(\\frac{d\\phi}{dx} dx\\right) = \\int_{\\phi(-\\infty)}^{\\phi(+\\infty)} \\kappa \\left(\\frac{d\\phi}{dx}\\right) d\\phi\n$$\n代入 $\\frac{d\\phi}{dx}$ 的表达式：\n$$\n\\sigma = \\int_{-1}^{+1} \\kappa \\sqrt{\\frac{2\\lambda W(\\phi)}{\\kappa}} d\\phi = \\int_{-1}^{+1} \\sqrt{2\\kappa\\lambda W(\\phi)} d\\phi\n$$\n现在，代入 $W(\\phi) = \\frac{1}{4}(\\phi^2-1)^2$ 的形式。对于 $\\phi \\in [-1, +1]$，有 $\\sqrt{W(\\phi)} = \\frac{1}{2}(1-\\phi^2)$。\n$$\n\\sigma = \\sqrt{2\\kappa\\lambda} \\int_{-1}^{+1} \\frac{1}{2}(1-\\phi^2) d\\phi\n$$\n该积分很容易计算：\n$$\n\\int_{-1}^{+1} (1-\\phi^2) d\\phi = \\left[\\phi - \\frac{\\phi^3}{3}\\right]_{-1}^{+1} = \\left(1 - \\frac{1}{3}\\right) - \\left(-1 - \\frac{(-1)^3}{3}\\right) = \\left(\\frac{2}{3}\\right) - \\left(-1 + \\frac{1}{3}\\right) = \\frac{2}{3} - \\left(-\\frac{2}{3}\\right) = \\frac{4}{3}\n$$\n将此结果代回 $\\sigma$ 的表达式中：\n$$\n\\sigma = \\sqrt{2\\kappa\\lambda} \\cdot \\frac{1}{2} \\cdot \\frac{4}{3} = \\frac{2}{3}\\sqrt{2\\kappa\\lambda}\n$$\n这可以写成最终的简化形式：\n$$\n\\sigma = \\frac{2\\sqrt{2}}{3}\\sqrt{\\kappa\\lambda}\n$$\n\n关于与尖锐界面极限的比较：此处推导出的 $\\sigma$ 值是针对特定扩散界面模型的精确表面张力。在经典的尖锐界面模型中，表面张力（比如 $\\sigma_{\\text{si}}$）是一个给定的热力学参数，代表一个零厚度数学表面的过剩能量。为了连接这两个模型，可将相场表面张力与尖锐界面值等同起来：$\\sigma = \\sigma_{\\text{si}}$。该方程为模型参数 $\\kappa$ 和 $\\lambda$ 提供了一个约束。第二个约束来自于定义一个特征界面厚度 $l$。通过对平衡方程进行无量纲化，可以发现 $l$ 的标度关系为 $l \\propto \\sqrt{\\kappa/\\lambda}$。“尖锐界面极限”指的是在 $\\sigma_{\\text{si}}$ 保持不变的情况下，$l \\to 0$ 的极限。从标度关系来看，如果 $\\sigma \\propto \\sqrt{\\kappa\\lambda}$ 且 $l \\propto \\sqrt{\\kappa/\\lambda}$，我们可以发现 $\\kappa \\propto \\sigma l$ 以及 $\\lambda \\propto \\sigma/l$。因此，在保持 $\\sigma$ 恒定的同时取 $l \\to 0$ 的极限，对应于 $\\kappa \\to 0$ 和 $\\lambda \\to \\infty$，且乘积 $\\kappa\\lambda$ 保持不变。我们的表达式正确地表明，如果 $\\kappa\\lambda$ 保持恒定，相场模型的表面张力也保持恒定，因此即使界面剖面变得无限陡峭，它也能与尖锐界面值保持一致。", "answer": "$$\\boxed{\\frac{2\\sqrt{2}}{3}\\sqrt{\\kappa\\lambda}}$$", "id": "3521619"}, {"introduction": "在理解了模型的静态物理性质后，下一步是模拟其动态演化。本练习将指导您编写代码，求解描述界面运动的经典 Allen-Cahn 方程。您将学习一种高效的半隐式数值方法，该方法利用快速傅里叶变换（FFT）来处理扩散项，并通过这个实践来探究一个重要的建模选择——迁移率函数 $M(\\phi)$ 的形式——如何影响界面的动力学行为。[@problem_id:3521556]", "problem": "本题要求您实现并分析一个一维Allen–Cahn相场模型，其中的迁移率在体相中为恒定或简并。您的目标是通过第一性原理计算界面速度，从而量化在小热力学驱动力作用下，迁移率简并如何改变界面动力学。完整的程序必须自成一体，对指定的测试套件执行所需计算，并以本问题末尾描述的精确格式打印聚合结果。\n\n考虑一个标量序参量场 $ \\phi(x,t) \\in [0,1] $，它定义在一个周期性一维域 $ x \\in [0,L) $ 上，其演化遵循Allen–Cahn动力学，由一个带有双势阱势和微小线性倾斜（该倾斜引起界面运动）的Ginzburg–Landau自由能驱动。自由能泛函为\n$$\n\\mathcal{F}[\\phi] = \\int_{0}^{L} \\left( \\frac{\\epsilon^2}{2} \\left| \\frac{\\partial \\phi}{\\partial x} \\right|^2 + W(\\phi) - h \\, \\phi \\right) \\, dx,\n$$\n其中 $ \\epsilon  0 $ 设定了界面厚度，$ W(\\phi) = \\phi^2 (1-\\phi)^2 $ 是双势阱势，$ h \\in \\mathbb{R} $ 是一个微小的常数倾斜，使两个势阱产生偏倚。其变分导数（化学势）为\n$$\n\\mu = \\frac{\\delta \\mathcal{F}}{\\delta \\phi} = - \\epsilon^2 \\frac{\\partial^2 \\phi}{\\partial x^2} + W'(\\phi) - h,\n$$\n其中 $ W'(\\phi) = 2 \\phi (1-\\phi)(1-2\\phi) $。Allen–Cahn演化是如下的弛豫动力学\n$$\n\\frac{\\partial \\phi}{\\partial t} = - M(\\phi) \\, \\mu = M(\\phi) \\left( \\epsilon^2 \\frac{\\partial^2 \\phi}{\\partial x^2} - W'(\\phi) + h \\right),\n$$\n其中 $ M(\\phi) $ 是迁移率。您将研究两种情况：\n- 恒定迁移率：$ M(\\phi) = M_0 $，其中 $ M_0  0 $ 是一个常数。\n- 简并迁移率：$ M(\\phi) = M_0 \\, \\phi^2 (1-\\phi)^2 $，它在体相 $ \\phi = 0 $ 和 $ \\phi = 1 $ 中为零，并在界面 $ \\phi \\approx 1/2 $ 附近达到最大值。\n\n初始条件：一个位于 $ x_0 = L/2 $ 中心的弥散界面，\n$$\n\\phi(x,0) = \\frac{1}{2} \\left[ 1 - \\tanh \\left( \\frac{x - x_0}{\\sqrt{2} \\, w} \\right) \\right],\n$$\n其光滑宽度 $ w $ 与 $ \\epsilon $ 成正比，以确保界面得到良好解析。\n\n您必须从第一性原理推导一个数值稳定的半隐式时间步进格式，其中线性扩散项使用一个常数算子进行隐式处理，而非线性和变系数项则进行显式处理。使用周期性空间离散化和快速傅里叶变换（FFT），通过在傅里叶空间中进行对角化来高效地实现隐式线性求解。具体来说，写出如下形式的更新方程\n$$\n\\left( I - \\Delta t \\, M_0 \\, \\epsilon^2 \\, \\frac{\\partial^2}{\\partial x^2} \\right) \\phi^{n+1} = \\phi^n + \\Delta t \\left[ \\left( M(\\phi^n) - M_0 \\right) \\epsilon^2 \\frac{\\partial^2 \\phi^n}{\\partial x^2} - M(\\phi^n) W'(\\phi^n) + M(\\phi^n) h \\right],\n$$\n其中 $ \\Delta t $ 是时间步长，上标表示时间层级。在周期性边界条件下，左侧的算子在傅里叶空间中是对角化的。\n\n将瞬时界面位置 $ x_\\ast(t) $ 定义为距离 $ x_0 $ 最近且满足 $ \\phi(x_\\ast(t),t) = 1/2 $ 的唯一位置。使用网格点之间的线性插值从离散场 $ \\phi(x,t) $ 估算 $ x_\\ast(t) $。由于域是周期性的，使用最小镜像约定计算净位移：\n$$\n\\Delta x = \\mathrm{wrap}( x_\\ast(T) - x_\\ast(0) ), \\quad \\mathrm{wrap}(d) = \n\\begin{cases}\nd - L  \\text{若 } d  L/2, \\\\\nd + L  \\text{若 } d  -L/2, \\\\\nd  \\text{其他情况。}\n\\end{cases}\n$$\n则平均界面速度为\n$$\nv = \\frac{\\Delta x}{T},\n$$\n其中 $ T $ 是最终模拟时间。\n\n实现上述数值格式，并为下面的每个测试用例，分别计算在恒定迁移率和简并迁移率下获得的速度对 $ v_{\\mathrm{const}} $ 和 $ v_{\\mathrm{deg}} $，以及它们的比率\n$$\nR = \n\\begin{cases}\n\\frac{v_{\\mathrm{deg}}}{v_{\\mathrm{const}}},  \\text{若 } |v_{\\mathrm{const}}| \\ge \\delta, \\\\\n0,  \\text{若 } |v_{\\mathrm{const}}|  \\delta,\n\\end{cases}\n$$\n其中 $ \\delta = 10^{-8} $。\n\n所有模拟都是无量纲的。请通过选择合适的 $ \\Delta t $ 和网格点数 $ N $ 来确保数值稳定性，以使界面得到解析且格式稳定。\n\n测试套件。对所有用例，使用周期域 $ [0,L) $，其中 $ L = 1 $，并在初始条件中设置 $ w = 2 \\epsilon $。使用以下参数集：\n- 用例 A (有驱动，薄界面)：$ \\epsilon = 0.01 $, $ h = 0.05 $, $ M_0 = 1.0 $, $ N = 1024 $, $ \\Delta t = 10^{-4} $, $ T = 0.2 $。\n- 用例 B (无驱动对照)：$ \\epsilon = 0.01 $, $ h = 0.0 $, $ M_0 = 1.0 $, $ N = 1024 $, $ \\Delta t = 10^{-4} $, $ T = 0.2 $。\n- 用例 C (有驱动，较宽界面)：$ \\epsilon = 0.02 $, $ h = 0.05 $, $ M_0 = 1.0 $, $ N = 1024 $, $ \\Delta t = 10^{-4} $, $ T = 0.2 $。\n\n对每个用例，计算三个浮点数 $ [v_{\\mathrm{const}}, v_{\\mathrm{deg}}, R] $。\n\n最终输出格式。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。按顺序连接用例 A 的三个浮点数、用例 B 的三个浮点数、再到用例 C 的三个浮点数，从而得到一个包含九个浮点数的扁平列表。在打印输出中，将每个浮点数四舍五入到小数点后恰好六位。例如，打印的行必须具有以下形式\n$$\n[\\text{A1},\\text{A2},\\text{A3},\\text{B1},\\text{B2},\\text{B3},\\text{C1},\\text{C2},\\text{C3}],\n$$\n其中每个占位符都是一个小数点后恰好有六位数字的十进制数。", "solution": "用户提供了一个计算物理学领域的适定问题，具体涉及Allen-Cahn方程的数值解。该问题具有科学依据，无内在矛盾，并包含获得唯一解所需的所有必要信息。我将着手进行解法的推导与实现。\n\n### 1. 理论框架与数值格式\n\n标量相场 $\\phi(x,t)$ 的演化由Allen-Cahn方程控制，这是一种针对Ginzburg-Landau自由能泛函 $\\mathcal{F}[\\phi]$ 的梯度下降动力学：\n$$\n\\frac{\\partial \\phi}{\\partial t} = -M(\\phi) \\frac{\\delta \\mathcal{F}}{\\delta \\phi}\n$$\n自由能泛函由下式给出：\n$$\n\\mathcal{F}[\\phi] = \\int_{0}^{L} \\left( \\frac{\\epsilon^2}{2} \\left| \\frac{\\partial \\phi}{\\partial x} \\right|^2 + W(\\phi) - h \\, \\phi \\right) \\, dx\n$$\n其中 $W(\\phi) = \\phi^2 (1-\\phi)^2$ 是双势阱势。变分导数，即化学势 $\\mu$，为：\n$$\n\\mu = \\frac{\\delta \\mathcal{F}}{\\delta \\phi} = - \\epsilon^2 \\frac{\\partial^2 \\phi}{\\partial x^2} + W'(\\phi) - h\n$$\n其中 $W'(\\phi) = 2\\phi(1-\\phi)(1-2\\phi)$。这导出了以下偏微分方程（PDE）：\n$$\n\\frac{\\partial \\phi}{\\partial t} = M(\\phi) \\left( \\epsilon^2 \\frac{\\partial^2 \\phi}{\\partial x^2} - W'(\\phi) + h \\right)\n$$\n我们分析迁移率 $M(\\phi)$ 的两种形式：恒定迁移率（$M(\\phi) = M_0$）和简并迁移率（$M(\\phi) = M_0 \\phi^2(1-\\phi)^2$）。\n\n题目指定了一个半隐式时间积分格式，用以处理扩散项 $\\epsilon^2 \\frac{\\partial^2 \\phi}{\\partial x^2}$ 的刚性问题。该格式将偏微分方程分离为一个具有常系数的线性部分（作隐式处理）和其余的非线性/变系数部分（作显式处理）。我们将偏微分方程重写为：\n$$\n\\frac{\\partial \\phi}{\\partial t} = M_0 \\epsilon^2 \\frac{\\partial^2 \\phi}{\\partial x^2} + \\left[ (M(\\phi) - M_0)\\epsilon^2 \\frac{\\partial^2 \\phi}{\\partial x^2} - M(\\phi)W'(\\phi) + M(\\phi)h \\right]\n$$\n对显式部分应用前向欧拉步，对隐式部分应用后向欧拉步，可得：\n$$\n\\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = M_0 \\epsilon^2 \\frac{\\partial^2 \\phi^{n+1}}{\\partial x^2} + \\left[ (M(\\phi^n) - M_0)\\epsilon^2 \\frac{\\partial^2 \\phi^n}{\\partial x^2} - M(\\phi^n)W'(\\phi^n) + M(\\phi^n)h \\right]\n$$\n整理关于 $\\phi^{n+1}$ 的项，得到题目中指定的更新方程：\n$$\n\\left( I - \\Delta t \\, M_0 \\, \\epsilon^2 \\, \\frac{\\partial^2}{\\partial x^2} \\right) \\phi^{n+1} = \\text{RHS}(\\phi^n)\n$$\n其中 $I$ 是单位算子，$\\text{RHS}(\\phi^n)$ 集合了所有在当前时间步 $n$ 计算的项：\n$$\n\\text{RHS}(\\phi^n) = \\phi^n + \\Delta t \\left[ \\left( M(\\phi^n) - M_0 \\right) \\epsilon^2 \\frac{\\partial^2 \\phi^n}{\\partial x^2} - M(\\phi^n) W'(\\phi^n) + M(\\phi^n) h \\right]\n$$\n\n### 2. 谱方法实现\n\n问题设置在周期域 $x \\in [0,L)$ 上，这使得基于快速傅里叶变换（FFT）的谱方法非常高效。空间域被离散为 $N$ 个网格点 $x_j = j \\cdot \\Delta x$，其中 $j = 0, \\dots, N-1$，$\\Delta x = L/N$。\n\n在傅里叶空间中，二阶导数算子 $\\frac{\\partial^2}{\\partial x^2}$ 变为乘以 $-q^2$，其中 $q$ 是角波数。对于离散网格，这些角波数是 $q = 2\\pi k$，其中 $k$ 是由 `numpy.fft.fftfreq(N, d=dx)` 给出的空间频率。\n\n令 $\\hat{\\phi}$ 为 $\\phi$ 的FFT。更新方程在傅里ye空间中变为：\n$$\n\\left( 1 + \\Delta t \\, M_0 \\, \\epsilon^2 \\, q^2 \\right) \\hat{\\phi}^{n+1} = \\widehat{\\text{RHS}}(\\phi^n)\n$$\n我们可以通过简单的逐元素除法求解 $\\hat{\\phi}^{n+1}$：\n$$\n\\hat{\\phi}^{n+1} = \\frac{\\widehat{\\text{RHS}}(\\phi^n)}{1 + \\Delta t \\, M_0 \\, \\epsilon^2 \\, q^2}\n$$\n然后通过逆FFT得到新时间步的场 $\\phi^{n+1}$。\n\n一个时间步的算法如下：\n1.  从实空间中的 $\\phi^n$ 和傅里叶空间中的 $\\hat{\\phi}^n$ 开始。\n2.  通过对 $-q^2 \\hat{\\phi}^n$ 应用逆FFT来计算显式项 $\\frac{\\partial^2 \\phi^n}{\\partial x^2}$。\n3.  在实空间中计算 $W'(\\phi^n)$ 和 $M(\\phi^n)$。\n4.  在实空间中组装完整的 $\\text{RHS}(\\phi^n)$ 表达式。\n5.  计算右侧项的FFT，即 $\\widehat{\\text{RHS}}$。\n6.  除以分母 $(1 + \\Delta t M_0 \\epsilon^2 q^2)$ 得到 $\\hat{\\phi}^{n+1}$。\n7.  $\\hat{\\phi}^{n+1}$ 的逆FFT的实部即为 $\\phi^{n+1}$。\n\n### 3. 界面速度计算\n\n界面的瞬时位置 $x_*(t)$ 定义为 $\\phi(x,t) = 1/2$ 处的位置。给定离散场 $\\phi_j$，通过识别发生穿越（即 $(\\phi_j - 0.5)(\\phi_{j+1} - 0.5) \\le 0$）的网格单元 $[x_j, x_{j+1}]$ 来找到该位置，并使用线性插值：\n$$\nx_* = x_j + \\Delta x \\frac{0.5 - \\phi_j}{\\phi_{j+1} - \\phi_j}\n$$\n通过检查最后一个和第一个网格点之间的穿越来处理周期性。如果存在多个穿越点，则选择最接近初始中心 $x_0 = L/2$ 的那一个。\n\n在总模拟时间 $T$ 内的净位移 $\\Delta x$ 计算为 $\\Delta x = x_*(T) - x_*(0)$，并使用最小镜像约定针对周期性进行调整：\n$$\n\\Delta x \\to \\Delta x - L \\quad \\text{如果 } \\Delta x  L/2\n$$\n$$\n\\Delta x \\to \\Delta x + L \\quad \\text{如果 } \\Delta x  -L/2\n$$\n平均速度则为 $v = \\Delta x / T$。\n\n对于每个测试用例，我们计算恒定迁移率下的速度 $v_{\\mathrm{const}}$ 和简并迁移率下的速度 $v_{\\mathrm{deg}}$。比率 $R$ 计算为 $v_{\\mathrm{deg}}/v_{\\mathrm{const}}$，并设置阈值以防止对静止界面进行除零操作。\n\n实现将包含一个主函数，该函数遍历测试套件，调用一个执行时间步进循环并计算速度的模拟函数。所有在问题陈述中提供的参数都将被直接使用。", "answer": "```python\n#\n# Meticulous and Exacting Professor: STEM Fields\n# Final Answer: Allen-Cahn Phase-Field Simulation\n#\nimport numpy as np\n\ndef W_prime(phi):\n    \"\"\"Derivative of the double-well potential W(phi) = phi^2 * (1-phi)^2.\"\"\"\n    return 2.0 * phi * (1.0 - phi) * (1.0 - 2.0 * phi)\n\ndef M_const(phi, M0):\n    \"\"\"Constant mobility function.\"\"\"\n    return np.full_like(phi, M0)\n\ndef M_degen(phi, M0):\n    \"\"\"Degenerate mobility function.\"\"\"\n    return M0 * phi**2 * (1.0 - phi)**2\n\ndef find_interface_position(x, phi, L, x0_center):\n    \"\"\"\n    Finds the interface position (phi=0.5) using linear interpolation.\n    Handles periodic boundaries and selects the crossing nearest to x0_center.\n    \"\"\"\n    N = len(x)\n    dx = L / N\n    \n    phi_shifted = np.roll(phi, -1)\n    # Find indices j where a sign change occurs for phi-0.5\n    indices = np.where((phi - 0.5) * (phi_shifted - 0.5) = 0)[0]\n\n    if indices.size == 0:\n        center_idx = np.argmin(np.abs(phi - 0.5))\n        return x[center_idx]\n        \n    crossings = []\n    for j in indices:\n        phi_j = phi[j]\n        phi_j1 = phi_shifted[j]\n        \n        delta_phi = phi_j1 - phi_j\n        if np.abs(delta_phi)  1e-12:\n            if np.abs(phi_j - 0.5)  1e-9: # Point is on the crossing\n                crossings.append(x[j])\n            continue\n        \n        pos = x[j] + dx * (0.5 - phi_j) / delta_phi\n        crossings.append(pos)\n    \n    if not crossings:\n        center_idx = np.argmin(np.abs(phi - 0.5))\n        return x[center_idx]\n        \n    crossings = np.array(crossings)\n    crossings = crossings % L\n    \n    dist = np.abs(crossings - x0_center)\n    dist = np.minimum(dist, L - dist)\n    \n    return crossings[np.argmin(dist)]\n\ndef run_simulation(L, N, T, dt, eps, h, M0, mobility_type):\n    \"\"\"Runs a single Allen-Cahn simulation.\"\"\"\n    dx = L / N\n    x = np.arange(N) * dx\n    q = 2.0 * np.pi * np.fft.fftfreq(N, d=dx)\n    laplacian_k = -q**2\n\n    w = 2.0 * eps\n    x0_center = L / 2.0\n    phi_initial = 0.5 * (1.0 - np.tanh((x - x0_center) / (np.sqrt(2.0) * w)))\n    \n    pos0 = find_interface_position(x, phi_initial, L, x0_center)\n\n    mobility_map = {'const': M_const, 'degen': M_degen}\n    M_func = mobility_map[mobility_type]\n\n    num_steps = int(round(T / dt))\n    phi_k = np.fft.fft(phi_initial)\n    \n    denominator = 1.0 - dt * M0 * eps**2 * laplacian_k\n    denominator[np.abs(denominator)  1e-12] = 1.0\n\n    for _ in range(num_steps):\n        phi = np.fft.ifft(phi_k).real\n        M_phi = M_func(phi, M0)\n        W_p = W_prime(phi)\n        \n        if mobility_type == 'const':\n            rhs = phi + dt * (-M_phi * W_p + M_phi * h)\n        else:\n            lap_phi = np.fft.ifft(laplacian_k * phi_k).real\n            rhs = phi + dt * ((M_phi - M0) * eps**2 * lap_phi - M_phi * W_p + M_phi * h)\n        \n        rhs_k = np.fft.fft(rhs)\n        phi_k = rhs_k / denominator\n\n    phi_final = np.fft.ifft(phi_k).real\n    \n    pos_final = find_interface_position(x, phi_final, L, x0_center)\n    \n    delta_x = pos_final - pos0\n    if delta_x > L / 2.0:\n        delta_x -= L\n    elif delta_x  -L / 2.0:\n        delta_x += L\n        \n    velocity = delta_x / T\n    \n    return velocity\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    test_suite = [\n        # Case A (driven, thin interface)\n        {'eps': 0.01, 'h': 0.05, 'T': 0.2, 'N': 1024, 'dt': 1e-4},\n        # Case B (undriven control)\n        {'eps': 0.01, 'h': 0.0, 'T': 0.2, 'N': 1024, 'dt': 1e-4},\n        # Case C (driven, wider interface)\n        {'eps': 0.02, 'h': 0.05, 'T': 0.2, 'N': 1024, 'dt': 1e-4},\n    ]\n    \n    common_params = {'L': 1.0, 'M0': 1.0}\n    delta_R = 1e-8\n    \n    results = []\n    for case_params in test_suite:\n        params = {**common_params, **case_params}\n        \n        v_const = run_simulation(**params, mobility_type='const')\n        v_deg = run_simulation(**params, mobility_type='degen')\n        \n        R = 0.0\n        if abs(v_const) >= delta_R:\n            R = v_deg / v_const\n            \n        results.extend([v_const, v_deg, R])\n\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "3521556"}, {"introduction": "相场模型通常是“刚性”的，这给数值求解带来了挑战，尤其是在长时间模拟或参数极端的情况下。本练习旨在解决这一问题，指导您构建一个更高级的、无条件稳定的数值格式。您将实现一个基于牛顿法的全隐式求解器，该方案旨在确保离散化的能量泛函在每个时间步单调递减，从而在数值层面严格遵守热力学第二定律，保证结果的物理真实性和鲁棒性。[@problem_id:3521544]", "problem": "您的任务是为一个使用基于耗散势的梯度流的相场界面动力学问题，构建并测试一个熵稳定的离散格式。考虑一个长度为 $L$ 的一维周期性域，其被离散为 $N$ 个均匀网格点，间距为 $\\Delta x = L/N$。设相场变量为 $\\phi(x,t)$。\n\n从以下基础出发：\n- 在 Onsager 变分原理（线性非平衡热力学）的意义下，系统根据一个由自由能泛函 $F(\\phi)$ 和耗散势 $\\Psi(\\dot{\\phi})$ 驱动的梯度流进行演化。设自由能为\n$$\nF(\\phi) = \\int_0^L \\left( \\frac{\\varepsilon^2}{2} \\left| \\frac{\\partial \\phi}{\\partial x} \\right|^2 + K \\, W(\\phi) \\right) \\, dx,\n$$\n其中 $W(\\phi)$ 是一个双阱势，$K$ 是一个放大源项的刚度参数。使用 $W(\\phi) = \\frac{1}{4}(\\phi^2 - 1)^2$，其导数为 $W'(\\phi) = \\phi^3 - \\phi$。耗散势为\n$$\n\\Psi(\\dot{\\phi}) = \\int_0^L \\frac{1}{2M} \\dot{\\phi}^2 \\, dx,\n$$\n其中迁移率 $M  0$ 为常数。\n- 通过最小化瑞利函数 $R(\\phi,\\dot{\\phi}) = \\frac{dF}{dt} + \\Psi(\\dot{\\phi})$ 导出的梯度流方程为\n$$\n\\frac{\\partial \\phi}{\\partial t} = - M \\, \\frac{\\delta F}{\\delta \\phi} = - M \\left( - \\varepsilon^2 \\frac{\\partial^2 \\phi}{\\partial x^2} + K \\left( \\phi^3 - \\phi \\right) \\right),\n$$\n使用周期性边界条件。\n\n您的目标是：\n1. 通过使用后向欧拉最小化移动格式，构建一个满足离散第二定律（即自由能在时间步进下不增加）的时间离散格式：\n$$\n\\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = - M \\left( - \\varepsilon^2 \\Delta \\phi^{n+1} + K \\left( (\\phi^{n+1})^3 - \\phi^{n+1} \\right) \\right),\n$$\n其中 $\\Delta$ 是具有周期性边界条件的离散拉普拉斯算子。\n2. 使用具有周期性边界条件的二阶精度有限差分来离散化空间导数。令离散拉普拉斯矩阵 $\\mathcal{L}$ 作用于节点值向量 $\\phi \\in \\mathbb{R}^N$ 的形式为\n$$\n(\\mathcal{L}\\phi)_i = \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{\\Delta x^2},\n$$\n采用周期性索引，使得 $\\phi_{-1} \\equiv \\phi_{N-1}$ 和 $\\phi_{N} \\equiv \\phi_0$。\n3. 实现一个牛顿法，用于在每个时间步求解非线性隐式更新。为 $\\phi^{n+1}$ 构建残差\n$$\n\\mathcal{R}(\\phi^{n+1}) = \\phi^{n+1} - \\phi^n + \\Delta t \\, M \\left( - \\varepsilon^2 \\mathcal{L}\\phi^{n+1} + K \\left( (\\phi^{n+1})^3 - \\phi^{n+1} \\right) \\right),\n$$\n以及雅可比矩阵\n$$\n\\mathcal{J}(\\phi^{n+1}) = \\mathbb{I} + \\Delta t \\, M \\left( - \\varepsilon^2 \\mathcal{L} + K \\, \\mathrm{diag}\\left( 3 (\\phi^{n+1})^2 - 1 \\right) \\right),\n$$\n其中 $\\mathbb{I}$ 是单位矩阵，$\\mathrm{diag}(\\cdot)$ 表示一个对角线元素为给定项的对角矩阵。\n\n对于节点值 $\\phi^n$，将时间步 $n$ 的离散自由能定义为\n$$\nF^n = \\sum_{i=0}^{N-1} \\left( \\frac{\\varepsilon^2}{2} \\left( \\frac{\\phi^n_{i+1} - \\phi^n_i}{\\Delta x} \\right)^2 + K \\, \\frac{ \\left( (\\phi^n_i)^2 - 1 \\right)^2 }{4} \\right) \\Delta x,\n$$\n其中对 $\\phi^n_{N} \\equiv \\phi^n_0$ 使用周期性索引。\n\n您的程序必须：\n- 将 $\\phi^0(x)$ 确定性地初始化为\n$$\n\\phi^0_i = 0.1 \\cos\\left( 2\\pi \\frac{i \\Delta x}{L} \\right), \\quad i = 0,1,\\dots,N-1.\n$$\n- 使用隐式格式和牛顿法进行规定步数的时间推进，并对残差范数设置一个合理的停止准则。\n- 在每个时间步，计算 $F^n$ 并验证离散第二定律：$F^{n+1} \\le F^n$（允许一个小的数值容差）。\n- 对于每个测试用例，返回一个布尔值，以指示自由能是否在所有时间步内都保持非递增。\n\n测试套件：\n所有用例均使用 $L = 1$。测试用例由元组 $(N, \\Delta t, T, \\varepsilon, M, K)$ 指定，其中 $T$ 是最终时间。请精确使用以下三个用例：\n- 用例 1：$(N, \\Delta t, T, \\varepsilon, M, K) = (64, 0.05, 2.0, 0.02, 1.0, 1.0)$。\n- 用例 2：$(N, \\Delta t, T, \\varepsilon, M, K) = (64, 0.05, 2.0, 0.02, 1.0, 100.0)$，用于通过一个大的 $K$ 值测试刚性源项。\n- 用例 3：$(N, \\Delta t, T, \\varepsilon, M, K) = (16, 0.1, 3.0, 0.02, 1.0, 50.0)$，用于测试粗分辨率和中等刚性的源项。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含一个由方括号括起来的、以逗号分隔的布尔值列表（例如，\"[True,False,True]\"）。不应打印任何其他文本。\n\n数值单位：\n不涉及物理单位；所有量纲均为无量纲。角度（如果存在）必须以弧度为单位；此处，$\\cos(\\cdot)$ 使用弧度。\n\n您的解决方案必须是一个单一、完整、可运行的程序。它必须实现所述的离散化方法和测试套件，并以指定的单行格式输出结果。", "solution": "The user wants to solve a numerical problem.\n\n### Step 1: Problem Validation\n\nI will first validate the problem statement to ensure its correctness and completeness.\n\n#### Extraction of Givens\n\n-   **Domain:** One-dimensional, periodic, length $L$. Discretized into $N$ uniform grid points with spacing $\\Delta x = L/N$.\n-   **Phase-field variable:** $\\phi(x,t)$.\n-   **Free Energy Functional:**\n    $$\n    F(\\phi) = \\int_0^L \\left( \\frac{\\varepsilon^2}{2} \\left| \\frac{\\partial \\phi}{\\partial x} \\right|^2 + K \\, W(\\phi) \\right) \\, dx\n    $$\n-   **Double-well Potential:** $W(\\phi) = \\frac{1}{4}(\\phi^2 - 1)^2$, with derivative $W'(\\phi) = \\phi^3 - \\phi$.\n-   **Stiffness parameter:** $K$.\n-   **Dissipation Potential:**\n    $$\n    \\Psi(\\dot{\\phi}) = \\int_0^L \\frac{1}{2M} \\dot{\\phi}^2 \\, dx\n    $$\n-   **Mobility:** Constant $M  0$.\n-   **Governing Equation (Gradient Flow):**\n    $$\n    \\frac{\\partial \\phi}{\\partial t} = - M \\, \\frac{\\delta F}{\\delta \\phi} = - M \\left( - \\varepsilon^2 \\frac{\\partial^2 \\phi}{\\partial x^2} + K \\left( \\phi^3 - \\phi \\right) \\right)\n    $$\n-   **Boundary Conditions:** Periodic.\n-   **Time Discretization (Backward Euler):**\n    $$\n    \\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = - M \\left( - \\varepsilon^2 \\Delta \\phi^{n+1} + K \\left( (\\phi^{n+1})^3 - \\phi^{n+1} \\right) \\right)\n    $$\n-   **Spatial Discretization (Finite Differences):**\n    -   Discrete Laplacian: $(\\mathcal{L}\\phi)_i = \\frac{\\phi_{i+1} - 2\\phi_i + \\phi_{i-1}}{\\Delta x^2}$, with periodic indexing ($\\phi_{-1} \\equiv \\phi_{N-1}$, $\\phi_N \\equiv \\phi_0$).\n-   **Nonlinear Solver (Newton's Method):**\n    -   Residual:\n        $$\n        \\mathcal{R}(\\phi^{n+1}) = \\phi^{n+1} - \\phi^n + \\Delta t \\, M \\left( - \\varepsilon^2 \\mathcal{L}\\phi^{n+1} + K \\left( (\\phi^{n+1})^3 - \\phi^{n+1} \\right) \\right)\n        $$\n    -   Jacobian:\n        $$\n        \\mathcal{J}(\\phi^{n+1}) = \\mathbb{I} + \\Delta t \\, M \\left( - \\varepsilon^2 \\mathcal{L} + K \\, \\mathrm{diag}\\left( 3 (\\phi^{n+1})^2 - 1 \\right) \\right)\n        $$\n-   **Discrete Free Energy:**\n    $$\n    F^n = \\sum_{i=0}^{N-1} \\left( \\frac{\\varepsilon^2}{2} \\left( \\frac{\\phi^n_{i+1} - \\phi^n_i}{\\Delta x} \\right)^2 + K \\, \\frac{ \\left( (\\phi^n_i)^2 - 1 \\right)^2 }{4} \\right) \\Delta x\n    $$\n    with periodic indexing ($\\phi^n_N \\equiv \\phi^n_0$).\n-   **Initial Condition:**\n    $$\n    \\phi^0_i = 0.1 \\cos\\left( 2\\pi \\frac{i \\Delta x}{L} \\right), \\quad i = 0,1,\\dots,N-1\n    $$\n-   **Task:** Verify the discrete second law, $F^{n+1} \\le F^n$, for all time steps. Return a boolean for each test case.\n-   **Test Suite ($L=1$ for all):**\n    -   Case 1: $(N, \\Delta t, T, \\varepsilon, M, K) = (64, 0.05, 2.0, 0.02, 1.0, 1.0)$\n    -   Case 2: $(N, \\Delta t, T, \\varepsilon, M, K) = (64, 0.05, 2.0, 0.02, 1.0, 100.0)$\n    -   Case 3: $(N, \\Delta t, T, \\varepsilon, M, K) = (16, 0.1, 3.0, 0.02, 1.0, 50.0)$\n-   **Final Output Format:** A single-line comma-separated list of booleans in square brackets (e.g., `[True,False,True]`).\n\n#### Validation using Extracted Givens\n\n1.  **Scientific or Factual Soundness:** The problem is firmly rooted in the principles of non-equilibrium thermodynamics and phase-field modeling. The Allen-Cahn equation is a canonical model for interface dynamics. The derivation of the governing equation as a gradient flow of a free energy functional is a standard and rigorous approach. The use of a backward Euler (implicit) scheme to ensure numerical stability and satisfy a discrete energy dissipation law is a well-established technique in computational science, particularly for stiff problems. All mathematical formulations are correct. The problem is scientifically and factually sound.\n2.  **Well-Posedness:** The problem provides a well-defined partial differential equation, initial conditions, periodic boundary conditions, and all necessary parameters. The numerical task is explicitly described, including the discretization schemes for space and time, the algorithm for solving the nonlinear system (Newton's method), and the metric for verification (discrete free energy). The problem is well-posed.\n3.  **Objectivity:** The problem is stated in precise, objective mathematical language. It is free from ambiguity, subjectivity, and bias.\n4.  **Completeness and Consistency:** The problem is self-contained. All necessary information, including constants, equations, initial conditions, and test parameters, is provided. There are no contradictions in the provided information.\n5.  **Realism and Feasibility:** The parameters are dimensionless, and their values are reasonable for a numerical simulation. The computational task is feasible.\n6.  **Non-Triviality:** The problem requires the implementation of a non-trivial numerical algorithm involving time-stepping, the construction of sparse matrices, and the iterative solution of a system of nonlinear algebraic equations at each time step. It is not a trivial or tautological problem.\n7.  **Scientific Verifiability:** The results of the numerical simulation are verifiable by running the implemented code. The underlying principle of energy stability for the chosen scheme is a-priori verifiable through numerical analysis.\n\n#### Verdict\n\nThe problem is **valid**. It is scientifically sound, well-posed, and complete. I will proceed with providing a solution.\n\n### Solution\n\nThe solution involves implementing a numerical simulation for the Allen-Cahn equation based on the specified implicit time-stepping scheme. The overall algorithm for each test case is as follows:\n\n1.  **Initialization:** Set up the computational grid with $N$ points over the domain of length $L=1$. Calculate the grid spacing $\\Delta x = L/N$. Initialize the phase field variable $\\phi^0$ as a discrete cosine wave according to the provided formula.\n\n2.  **Matrix Construction:** Construct the $N \\times N$ discrete Laplacian matrix $\\mathcal{L}$ that incorporates the periodic boundary conditions. This matrix is constant throughout the simulation.\n\n3.  **Time-Stepping Loop:** Iterate from time $t=0$ to the final time $T$ with a fixed time step $\\Delta t$. In each step, we compute $\\phi^{n+1}$ from $\\phi^n$.\n\n4.  **Newton-Raphson Solver:** The core of each time step is to solve the nonlinear system of equations for $\\phi^{n+1}$. This is done using Newton's method.\n    a.  **Initial Guess:** The solution from the previous time step, $\\phi^n$, is used as the initial guess for $\\phi^{n+1}$.\n    b.  **Iteration:** The Newton iteration updates the current guess $\\phi_{k}$ for $\\phi^{n+1}$ by solving the linear system $\\mathcal{J}(\\phi_k) \\delta\\phi = -\\mathcal{R}(\\phi_k)$ for the correction $\\delta\\phi$, and then updating $\\phi_{k+1} = \\phi_k + \\delta\\phi$.\n    c.  **Residual and Jacobian:** The residual vector $\\mathcal{R}$ and the Jacobian matrix $\\mathcal{J}$ are assembled at each Newton iteration using the formulas provided in the problem statement. The Jacobian matrix combines the constant Laplacian part and a diagonal part that depends on the current guess $\\phi_k$.\n    d.  **Convergence:** The iterations continue until the Euclidean norm of the residual vector falls below a predefined tolerance (e.g., $10^{-10}$), or a maximum number of iterations is reached.\n\n5.  **Energy Verification:** After a converged solution $\\phi^{n+1}$ is found, the discrete free energy $F^{n+1}$ is calculated using the provided summation formula. This value is compared to the energy from the previous step, $F^n$. The condition $F^{n+1} \\le F^n$ (up to a small floating-point tolerance) is checked. If this condition is violated at any step, a flag is set to `False` for the current test case, and the simulation for that case is terminated.\n\n6.  **Updating State:** If the energy is non-increasing, the solution and energy are updated ($\\phi^n \\leftarrow \\phi^{n+1}$, $F^n \\leftarrow F^{n+1}$), and the simulation proceeds to the next time step.\n\n7.  **Result Aggregation:** The final boolean result (indicating whether the energy was non-increasing throughout the entire simulation) is stored for each test case.\n\nThe use of a fully implicit backward Euler scheme is motivated by its unconditional stability for gradient flows. It is an L-stable method, which is highly effective for stiff equations, such as the Allen-Cahn equation, especially when the stiffness parameter $K$ is large or the time step $\\Delta t$ is not small. This stability is directly linked to the energy dissipation property. The scheme can be interpreted as finding the minimizer of a functional at each time step, which guarantees that the free energy of the system does not increase. Therefore, for all test cases, including those with stiff parameters or coarse grids, the energy is expected to be non-increasing, and the program should return `True`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required for this problem.\n\ndef solve():\n    \"\"\"\n    Constructs and tests an entropy-stable discretization for a phase-field\n    interface dynamics problem using a backward Euler minimizing movement scheme.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, dt, T, eps, M, K)\n        (64, 0.05, 2.0, 0.02, 1.0, 1.0),\n        (64, 0.05, 2.0, 0.02, 1.0, 100.0),\n        (16, 0.1, 3.0, 0.02, 1.0, 50.0),\n    ]\n\n    def build_laplacian(N, dx):\n        \"\"\"\n        Constructs the 1D finite difference Laplacian matrix with periodic boundary conditions.\n        \n        Args:\n            N (int): Number of grid points.\n            dx (float): Grid spacing.\n\n        Returns:\n            numpy.ndarray: The (N, N) Laplacian matrix.\n        \"\"\"\n        L_mat = np.zeros((N, N))\n        val = 1.0 / (dx * dx)\n        for i in range(N):\n            L_mat[i, i] = -2.0 * val\n            L_mat[i, (i + 1) % N] = val\n            L_mat[i, (i - 1 + N) % N] = val\n        return L_mat\n\n    def calculate_energy(phi, dx, eps, K):\n        \"\"\"\n        Calculates the discrete free energy of the system.\n        \n        Args:\n            phi (numpy.ndarray): The vector of phase-field values.\n            dx (float): Grid spacing.\n            eps (float): Interface width parameter.\n            K (float): Stiffness parameter.\n\n        Returns:\n            float: The total discrete free energy F.\n        \"\"\"\n        # Periodic forward difference for the gradient\n        phi_plus_1 = np.roll(phi, -1)\n        grad_phi_sq = ((phi_plus_1 - phi) / dx)**2\n        \n        # Double-well potential W(phi)\n        potential_W = 0.25 * (phi**2 - 1)**2\n        \n        # Integrate over the domain\n        integrand = (eps**2 / 2.0) * grad_phi_sq + K * potential_W\n        return np.sum(integrand) * dx\n\n    def run_simulation(N, dt, T, eps, M, K):\n        \"\"\"\n        Runs a single simulation for a given set of parameters.\n\n        Args:\n            N (int): Number of grid points.\n            dt (float): Time step size.\n            T (float): Final time.\n            eps (float): Interface width parameter.\n            M (float): Mobility.\n            K (float): Stiffness parameter.\n\n        Returns:\n            bool: True if energy is non-increasing for all steps, False otherwise.\n        \"\"\"\n        L = 1.0\n        dx = L / N\n        num_steps = int(round(T / dt))\n\n        # Grid and initial condition\n        x = np.linspace(0, L, N, endpoint=False)\n        phi_current = 0.1 * np.cos(2 * np.pi * x / L)\n\n        # Pre-compute constant matrices\n        L_mat = build_laplacian(N, dx)\n        I_mat = np.identity(N)\n        \n        # Newton solver settings\n        newton_tol = 1e-10\n        newton_max_iter = 20\n        \n        # Energy stability check settings\n        energy_is_non_increasing = True\n        energy_check_tol = 1e-9  # Tolerance for floating-point arithmetic\n\n        energy_current = calculate_energy(phi_current, dx, eps, K)\n\n        for _ in range(num_steps):\n            # Newton's method to find phi_next\n            phi_guess = phi_current.copy()\n\n            for _ in range(newton_max_iter):\n                # Residual: R = phi - phi_n + dt*M*(-eps^2*L*phi + K*(phi^3-phi))\n                residual_lin = -eps**2 * (L_mat @ phi_guess)\n                residual_nonlin = K * (phi_guess**3 - phi_guess)\n                R = phi_guess - phi_current + dt * M * (residual_lin + residual_nonlin)\n\n                if np.linalg.norm(R)  newton_tol:\n                    break\n                \n                # Jacobian: J = I + dt*M*(-eps^2*L + K*diag(3*phi^2-1))\n                diag_J_nonlin = K * (3 * phi_guess**2 - 1)\n                J = I_mat + dt * M * (-eps**2 * L_mat + np.diag(diag_J_nonlin))\n                \n                # Solve J * delta_phi = -R for the update\n                delta_phi = np.linalg.solve(J, -R)\n                phi_guess += delta_phi\n            \n            phi_next = phi_guess\n            \n            # Verify the discrete second law (energy stability)\n            energy_next = calculate_energy(phi_next, dx, eps, K)\n            \n            if energy_next > energy_current + energy_check_tol:\n                energy_is_non_increasing = False\n                break  # Stop simulation if energy increases\n            \n            # Update state for the next time step\n            phi_current = phi_next\n            energy_current = energy_next\n\n        return energy_is_non_increasing\n\n    results = []\n    for case in test_cases:\n        N, dt, T, eps, M, K = case\n        result = run_simulation(N, dt, T, eps, M, K)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3521544"}]}