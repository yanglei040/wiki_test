{"hands_on_practices": [{"introduction": "扩展有限元方法（XFEM）的核心在于通过富集函数来增强标准有限元基函数，从而在不需要网格对齐的情况下模拟不连续性。本练习提供了一个基础但至关重要的计算，您将手动推导一个被不连续面切割的单元的富集贡献矩阵[@problem_id:3506679]。通过这个过程，您将深入理解亥维赛德（Heaviside）函数富集是如何在代数层面改变离散系统的，这是掌握XFEM力学原理的第一步。", "problem": "考虑一个在扩展有限元方法 (XFEM) 中使用的等参双线性四边形单元，其中对标量场（例如，热弹性多物理场环境中的温度）的近似进行了增强，以捕捉强间断。该增强使用了亥维赛德函数，使得增强函数定义为 $\\psi(\\boldsymbol{x}) = H(\\phi(\\boldsymbol{x}))$，其中水平集 $\\phi(\\boldsymbol{x})$ 代表该间断。在单元的父（参考）坐标系中，记 $\\boldsymbol{\\xi} = (\\xi,\\eta)$，其中 $\\xi,\\eta \\in [-1,1]$。设该间断由直线 $\\phi(\\boldsymbol{\\xi}) = \\xi$ 表示，因此零水平集 $\\phi(\\boldsymbol{\\xi}) = 0$ 将单元划分为 $\\xi  0$ 和 $\\xi > 0$ 这两个子域，并且当 $\\xi \\ge 0$ 时 $H(\\phi(\\boldsymbol{\\xi}))$ 等于 $1$，当 $\\xi  0$ 时等于 $0$。标量场近似采用单位分解增强，形式如下：\n$$\nu_{h}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,u_{i} + \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,a_{i}\\,\\psi(\\boldsymbol{\\xi}),\n$$\n其中 $N_{i}(\\boldsymbol{\\xi})$ 是与该四边形四个角节点相关联的双线性形函数。\n\n假设该单元通过标准的双线性等参映射将父域 $[-1,1]\\times[-1,1]$ 映射到一个宽度为 $w$、高度为 $h$ 的矩形物理单元，使得雅可比行列式为常数，由 $|J| = \\frac{w h}{4}$ 给出，且 $d\\Omega = |J|\\,d\\xi\\,d\\eta$。定义增强节点贡献矩阵 $M^{\\mathrm{enr}} \\in \\mathbb{R}^{4\\times 4}$ 为\n$$\n(M^{\\mathrm{enr}})_{ij} \\equiv \\int_{\\Omega_{e}} N_{i}(\\boldsymbol{\\xi})\\,N_{j}(\\boldsymbol{\\xi})\\,\\psi(\\boldsymbol{\\xi})\\,d\\Omega,\n$$\n其中 $i,j \\in \\{1,2,3,4\\}$。\n\n从以上定义出发，并仅使用亥维赛德函数和双线性形函数的基本性质，为给定的直线间断 $\\phi(\\boldsymbol{\\xi}) = \\xi$ 计算 $M^{\\mathrm{enr}}$ 的精确闭式表达式。此外，从第一性原理出发，确定并明确列出在此单元中获得非零增强支撑的节点增强自由度 $a_{i}$。将最终矩阵 $M^{\\mathrm{enr}}$ 表示为以 $w$ 和 $h$ 表示的解析表达式。无需进行数值舍入，最终答案必须是单一的闭式解析表达式。", "solution": "用户在扩展有限元方法 (XFEM) 的背景下提供了一个适定的问题。我将进行验证，然后给出解答。\n\n### 第 1 步：提取已知条件\n- **方法论**：针对单个等参双线性四边形单元中强间断的扩展有限元方法 (XFEM)。\n- **标量场近似**：$u_{h}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,u_{i} + \\sum_{i=1}^{4} N_{i}(\\boldsymbol{\\xi})\\,a_{i}\\,\\psi(\\boldsymbol{\\xi})$，其中 $N_i$ 是双线性形函数，$u_i$ 是标准节点自由度，$a_i$ 是增强节点自由度。\n- **增强函数**：$\\psi(\\boldsymbol{x}) = H(\\phi(\\boldsymbol{x}))$，其中 H 是亥维赛德函数。\n- **水平集函数**：在父坐标 $\\boldsymbol{\\xi} = (\\xi,\\eta) \\in [-1,1]\\times[-1,1]$ 中，间断由 $\\phi(\\boldsymbol{\\xi}) = \\xi$ 定义。\n- **亥维赛德函数**：当 $\\xi \\ge 0$ 时 $H(\\phi(\\boldsymbol{\\xi})) = 1$，当 $\\xi  0$ 时 $H(\\phi(\\boldsymbol{\\xi})) = 0$。\n- **等参映射**：父域 $[-1,1]\\times[-1,1]$ 映射到宽度为 $w$、高度为 $h$ 的矩形物理单元。\n- **雅可比行列式与面积元**：雅可比行列式为常数， $|J| = \\frac{w h}{4}$，微分面积为 $d\\Omega = |J|\\,d\\xi\\,d\\eta$。\n- **矩阵定义**：增强节点贡献矩阵 $M^{\\mathrm{enr}}$ 定义为 $(M^{\\mathrm{enr}})_{ij} = \\int_{\\Omega_{e}} N_{i}(\\boldsymbol{\\xi})\\,N_{j}(\\boldsymbol{\\xi})\\,\\psi(\\boldsymbol{\\xi})\\,d\\Omega$，其中 $i,j \\in \\{1,2,3,4\\}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于有限元方法及其扩展（XFEM）的既定原理。使用亥维赛德函数通过单位分解增强来模拟强间断是该方法的基石。所有定义都是标准的。该问题在科学上是合理的。\n- **适定性**：所有必要信息均已提供。函数有定义，积分域已指定，待计算量已明确给出。该问题是适定的，并存在唯一解。\n- **客观性**：该问题使用精确、无歧义的数学和工程术语进行陈述。它不含主观或基于意见的论断。\n- **结论**：该问题没有任何验证清单中所列的缺陷。它是有效的。\n\n### 第 3 步：结论与行动\n该问题是有效的。我将继续提供一个完整的、有理有据的解答。\n\n### 详细解答\n\n主要任务是计算增强节点贡献矩阵 $M^{\\mathrm{enr}}$，其分量定义为：\n$$ (M^{\\mathrm{enr}})_{ij} = \\int_{\\Omega_{e}} N_{i}(\\boldsymbol{\\xi})\\,N_{j}(\\boldsymbol{\\xi})\\,\\psi(\\boldsymbol{\\xi})\\,d\\Omega $$\n积分在整个单元域 $\\Omega_e$ 上进行。通过将积分转换到父域 $\\boldsymbol{\\xi} \\in [-1,1]\\times[-1,1]$，我们使用 $d\\Omega = |J|\\,d\\xi\\,d\\eta$。代入给定的 $\\psi(\\boldsymbol{\\xi})$ 和 $|J|$ 表达式，得到：\n$$ (M^{\\mathrm{enr}})_{ij} = \\int_{-1}^{1}\\int_{-1}^{1} N_{i}(\\xi,\\eta)\\,N_{j}(\\xi,\\eta)\\,H(\\xi)\\,\\frac{wh}{4}\\,d\\xi\\,d\\eta $$\n亥维赛德函数 $H(\\xi)$ 在 $\\xi  0$ 时为 $0$，在 $\\xi \\ge 0$ 时为 $1$。这个性质将变量 $\\xi$ 的积分域从 $[-1,1]$ 限制到 $[0,1]$。\n$$ (M^{\\mathrm{enr}})_{ij} = \\frac{wh}{4} \\int_{0}^{1}\\int_{-1}^{1} N_{i}(\\xi,\\eta)\\,N_{j}(\\xi,\\eta)\\,d\\eta\\,d\\xi $$\n对于一个 4 节点四边形单元，其节点从 $(\\xi,\\eta)=(-1,-1)$ 处的节点 1 开始逆时针编号，其双线性形函数 $N_i(\\xi,\\eta)$ 如下：\n$N_1(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta)$\n$N_2(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta)$\n$N_3(\\xi,\\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta)$\n$N_4(\\xi,\\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)$\n\n两个形函数 $N_i N_j$ 的乘积为：\n$$ N_{i}(\\xi,\\eta) N_{j}(\\xi,\\eta) = \\frac{1}{16} (f_i(\\xi)g_i(\\eta)) (f_j(\\xi)g_j(\\eta)) = \\frac{1}{16} [f_i(\\xi)f_j(\\xi)][g_i(\\eta)g_j(\\eta)] $$\n其中函数 $f_k(\\xi)$ 和 $g_k(\\eta)$ 分别是 $(1\\pm\\xi)$ 或 $(1\\pm\\eta)$。这种可分离性使我们能够将 $(M^{\\mathrm{enr}})_{ij}$ 的积分写成两个一维积分的乘积：\n$$ (M^{\\mathrm{enr}})_{ij} = \\frac{wh}{4} \\frac{1}{16} \\left(\\int_{0}^{1} f_i(\\xi)f_j(\\xi)\\,d\\xi\\right) \\left(\\int_{-1}^{1} g_i(\\eta)g_j(\\eta)\\,d\\eta\\right) $$\n让我们计算这些一维积分。\n对于 $\\eta$ 坐标，在 $[-1,1]$ 上积分：\n$$ \\int_{-1}^{1} (1-\\eta)^2 \\, d\\eta = \\left[-\\frac{(1-\\eta)^3}{3}\\right]_{-1}^{1} = 0 - \\left(-\\frac{2^3}{3}\\right) = \\frac{8}{3} $$\n$$ \\int_{-1}^{1} (1+\\eta)^2 \\, d\\eta = \\left[\\frac{(1+\\eta)^3}{3}\\right]_{-1}^{1} = \\frac{2^3}{3} - 0 = \\frac{8}{3} $$\n$$ \\int_{-1}^{1} (1-\\eta)(1+\\eta) \\, d\\eta = \\int_{-1}^{1} (1-\\eta^2) \\, d\\eta = \\left[\\eta - \\frac{\\eta^3}{3}\\right]_{-1}^{1} = \\left(1-\\frac{1}{3}\\right) - \\left(-1+\\frac{1}{3}\\right) = \\frac{4}{3} $$\n\n对于 $\\xi$ 坐标，在 $[0,1]$ 上积分：\n$$ \\int_{0}^{1} (1-\\xi)^2 \\, d\\xi = \\left[-\\frac{(1-\\xi)^3}{3}\\right]_{0}^{1} = 0 - \\left(-\\frac{1^3}{3}\\right) = \\frac{1}{3} $$\n$$ \\int_{0}^{1} (1+\\xi)^2 \\, d\\xi = \\left[\\frac{(1+\\xi)^3}{3}\\right]_{0}^{1} = \\frac{2^3}{3} - \\frac{1^3}{3} = \\frac{7}{3} $$\n$$ \\int_{0}^{1} (1-\\xi)(1+\\xi) \\, d\\xi = \\int_{0}^{1} (1-\\xi^2) \\, d\\xi = \\left[\\xi - \\frac{\\xi^3}{3}\\right]_{0}^{1} = 1 - \\frac{1}{3} = \\frac{2}{3} $$\n\n现在我们可以计算矩阵 $(M^{\\mathrm{enr}})_{ij}$ 的每个元素。例如，对于 $(1,1)$ 分量：\n$f_1(\\xi) = 1-\\xi$, $g_1(\\eta) = 1-\\eta$.\n$$ (M^{\\mathrm{enr}})_{11} = \\frac{wh}{64} \\left(\\int_{0}^{1} (1-\\xi)^2 \\, d\\xi\\right) \\left(\\int_{-1}^{1} (1-\\eta)^2 \\, d\\eta\\right) = \\frac{wh}{64} \\left(\\frac{1}{3}\\right) \\left(\\frac{8}{3}\\right) = \\frac{8wh}{576} = \\frac{wh}{72} $$\n让我们将所有项表示为一个公因子的倍数。设 $\\mathbf{m}$ 为积分矩阵，使得 $M^{\\mathrm{enr}} = \\frac{wh}{64} \\mathbf{m}$。\n$$ m_{ij} = \\left(\\int f_i f_j\\right)\\left(\\int g_i g_j\\right) $$\n$m_{11} = (\\frac{1}{3})(\\frac{8}{3}) = \\frac{8}{9}$\n$m_{12} = (\\frac{2}{3})(\\frac{8}{3}) = \\frac{16}{9}$\n$m_{13} = (\\frac{2}{3})(\\frac{4}{3}) = \\frac{8}{9}$\n$m_{14} = (\\frac{1}{3})(\\frac{4}{3}) = \\frac{4}{9}$\n$m_{22} = (\\frac{7}{3})(\\frac{8}{3}) = \\frac{56}{9}$\n$m_{23} = (\\frac{7}{3})(\\frac{4}{3}) = \\frac{28}{9}$\n$m_{24} = (\\frac{2}{3})(\\frac{4}{3}) = \\frac{8}{9}$\n$m_{33} = (\\frac{7}{3})(\\frac{8}{3}) = \\frac{56}{9}$\n$m_{34} = (\\frac{2}{3})(\\frac{8}{3}) = \\frac{16}{9}$\n$m_{44} = (\\frac{1}{3})(\\frac{8}{3}) = \\frac{8}{9}$\n矩阵 $\\mathbf{m}$ 是对称的，所以 $m_{ji}=m_{ij}$。组装该矩阵：\n$$ \\mathbf{m} = \\frac{1}{9} \\begin{pmatrix}\n8   16   8   4 \\\\\n16  56  28  8 \\\\\n8   28  56  16 \\\\\n4   8   16  8\n\\end{pmatrix} = \\frac{4}{9} \\begin{pmatrix}\n2  4  2  1 \\\\\n4  14  7  2 \\\\\n2  7  14  4 \\\\\n1  2  4  2\n\\end{pmatrix} $$\n最后，我们计算 $M^{\\mathrm{enr}}$：\n$$ M^{\\mathrm{enr}} = \\frac{wh}{64} \\mathbf{m} = \\frac{wh}{64} \\frac{4}{9} \\begin{pmatrix}\n2  4  2  1 \\\\\n4  14  7  2 \\\\\n2  7  14  4 \\\\\n1  2  4  2\n\\end{pmatrix} = \\frac{wh}{144} \\begin{pmatrix}\n2  4  2  1 \\\\\n4  14  7  2 \\\\\n2  7  14  4 \\\\\n1  2  4  2\n\\end{pmatrix} $$\n\n关于问题的第二部分，我们必须确定哪些节点增强自由度 $a_i$ 获得非零支撑。在处理强间断的标准 XFEM 方法中，增强会应用于被间断切割的任何单元的所有节点。在本问题中，所考虑的单个单元被间断线 $\\phi(\\boldsymbol{\\xi}) = \\xi = 0$ 切割。因此，该单元的所有四个节点都被增强。增强自由度 $a_1$、$a_2$、$a_3$ 和 $a_4$ 都是活动的，并获得非零支撑。", "answer": "$$ \\boxed{ \\frac{wh}{144} \\begin{pmatrix} 2  4  2  1 \\\\ 4  14  7  2 \\\\ 2  7  14  4 \\\\ 1  2  4  2 \\end{pmatrix} } $$", "id": "3506679"}, {"introduction": "在许多多物理场耦合问题中，不连续界面（如裂纹扩展或相变前沿）是随时间移动的。本实践将引导您实现一个关键的算法：使用水平集（level-set）方法来描述和追踪移动的界面，并动态更新被切割的单元，从而确定哪些单元需要富集[@problem_id:3506750]。掌握界面平流输运的数值方法对于模拟动态不连续性问题至关重要。", "problem": "考虑扩展有限元法 (XFEM)，该方法通过增广标准有限元近似空间来表示不连续性，而无需将网格与界面对齐。在多物理场耦合模拟中，一个重要的步骤是对隐式表示的界面进行稳健的平流计算，并对部分切割单元的加密模式进行一致性更新。设界面由水平集函数 $ \\phi(x,y,t) $ 表示，其中零等值线 $ \\phi(x,y,t)=0 $ 定义了移动界面。描述 $ \\phi $ 被给定速度场 $ v(x,y) $ 输运的标量平流方程为 $$ \\partial_t \\phi + v \\cdot \\nabla \\phi = 0. $$ 计算域为单位正方形 $ \\Omega = [0,1] \\times [0,1] $，采用无量纲单位。初始水平集函数为到以 $ (x_0,y_0)=(0.5,0.5) $ 为中心、半径为 $ r = 0.25 $ 的圆的有向距离，即 $$ \\phi(x,y,0) = \\sqrt{(x-0.5)^2 + (y-0.5)^2} - 0.25. $$ 使用结构化的均匀四边形有限元网格，其在 $ x $ 方向有 $ N_x $ 个节点，在 $ y $ 方向有 $ N_y $ 个节点，两方向均包含边界节点。设 $ \\Delta t $ 表示时间步长。在给定时间，加密模式的定义如下：若一个单元的四个角节点的 $ \\phi $ 值符号不一或包含零，则标记该单元为加密单元，这对应于亥维赛（Heaviside）型不連續性穿过单元内部。\n\n您的任务是：\n- 从平流方程和特征线法等基本原理出发，在给定的稳定速度场 $ v(x,y) $ 下，为网格节点上的 $ \\phi $ 实现一个从 $ t^n $到$ t^{n+1}=t^n+\\Delta t $ 的物理一致的单步时间推进。假设使用无量纲单位。当出现角度时（例如角速度），必须解释为弧度/单位时间。\n- 推进 $ \\phi $ 后，更新加密模式，标记被更新后界面切割的单元。这些单元的定义为：其四个角节点在 $ t^{n+1} $ 时的 $ \\phi $ 值集合中，既包含正值也包含负值，或者包含任何等于零的值（在数值容差范围内）。\n- 对于测试套件中的每个测试用例，输出更新后时间 $ t^{n+1} $ 时的加密单元整数数量。\n\n您必须编写一个程序，使用以下测试用例套件，每个用例都指定了 $ N_x $、$ N_y $、$ \\Delta t $ 和速度场 $ v(x,y) $：\n\n- 用例 A (平移): $ N_x = 64 $, $ N_y = 64 $, $ \\Delta t = 0.05 $, $ v(x,y) = (0.3, 0.0) $.\n- 用例 B (绕计算域中心的刚体旋转): $ N_x = 64 $, $ N_y = 64 $, $ \\Delta t = 0.05 $, $ v(x,y) = \\left( -\\omega (y-0.5), \\, \\omega (x-0.5) \\right) $，其中 $ \\omega = 1.0 $ 弧度/单位时间。\n- 用例 C (简单剪切): $ N_x = 64 $, $ N_y = 64 $, $ \\Delta t = 0.05 $, $ v(x,y) = (y, 0.0) $.\n- 用例 D (无运动，边界情况): $ N_x = 64 $, $ N_y = 64 $, $ \\Delta t = 0.05 $, $ v(x,y) = (0.0, 0.0) $.\n\n在数值上，对于离开 $ \\Omega $ 的回溯特征线足点，通过将其钳位到 $ \\Omega $ 中最近的边界点来处理，以确保 $ \\phi $ 的数值插值在任何地方都有定义。使用一个小的数值容差 $ \\varepsilon $ 来判断用于加密检测的符号和零值，并在您的解答中证明该选择的合理性。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序排列结果，例如 $ [\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D] $。每个 $ \\text{result}_\\cdot $ 必须是该用例单次时间更新后加密单元数量的整数值。", "solution": "用户提供的问题被评估为**有效**。该问题在科学上是合理的、适定的，并且为获得唯一的数值解提供了所有必要信息。问题要求在相关的工程背景下，实现一个求解偏微分方程的标准数值方法。\n\n求解过程如下：首先，建立物理和数学原理。其次，基于这些原理设计数值算法。最后，将此算法应用于指定的测试用例。\n\n### 控制原理与特征线法\n\n问题要求解水平集函数 $ \\phi(x,y,t) $ 的标量平流方程：\n$$ \\partial_t \\phi + \\vec{v} \\cdot \\nabla \\phi = 0 $$\n其中 $ \\vec{v}(x,y) $ 是一个给定的稳定速度场。该方程描述了标量 $ \\phi $ 随 $ \\vec{v} $ 定义的流场输运的过程。\n\n特征线法是求解此类一阶双曲型偏微分方程的一种技术。该方程可以解释为，$ \\phi $ 的全导数沿着时空中称为特征线的特定曲线为零。这些特征曲线 $ \\vec{x}(t) $ 由以下常微分方程定义：\n$$ \\frac{d\\vec{x}}{dt} = \\vec{v}(\\vec{x}(t)) $$\n沿着这些曲线，$ \\phi $ 的变化率由下式给出：\n$$ \\frac{D\\phi}{Dt} = \\frac{\\partial\\phi}{\\partial t} + \\frac{d\\vec{x}}{dt} \\cdot \\nabla\\phi = \\partial_t \\phi + \\vec{v} \\cdot \\nabla \\phi = 0 $$\n这意味着 $ \\phi $ 沿着特征线是恒定的。因此，为了求出新时刻 $ t^{n+1} $ 网格点 $ \\vec{x}_p $ 处的 $ \\phi $ 值，我们可以沿其特征线向后追溯时间，找到其在上一时刻 $ t^n $ 的位置。这个起始位置称为出发点 $ \\vec{x}_d $。该原理给出：\n$$ \\phi(\\vec{x}_p, t^{n+1}) = \\phi(\\vec{x}_d, t^n) $$\n\n### 数值实现：半拉格朗日格式\n\n基于此原理的数值格式称为半拉格朗日法。我们已知均匀网格上所有节点在时刻 $ t^n $ 的 $ \\phi^n $ 值。为了求出这些相同网格节点在时刻 $ t^{n+1} = t^n + \\Delta t $ 的值 $ \\phi^{n+1} $，我们对每个网格节点 $ \\vec{x}_p $ 执行以下步骤：\n\n1.  **回溯**：近似计算出发点 $ \\vec{x}_d $。特征常微分方程 $ d\\vec{x}/dt = \\vec{v} $ 在一个时间步长 $ \\Delta t $ 内向后求解。一阶显式欧拉（后向）积分是最简单的方法：\n    $$ \\vec{x}_d \\approx \\vec{x}_p - \\vec{v}(\\vec{x}_p) \\Delta t $$\n    这种一阶格式是题目所要求的“单步时间推进”的直接且标准的实现。虽然存在更高阶的方法（例如，龙格-库塔法）以获得更高精度，但一阶方法已足够且与问题陈述一致。\n\n2.  **边界处理**：出发点 $ \\vec{x}_d $ 可能位于计算域 $ \\Omega = [0,1] \\times [0,1] $ 之外。按照规定，我们将其坐标钳位到计算域边界：\n    $$ \\vec{x}_{d, \\text{clamped}} = \\text{clip}(\\vec{x}_d, [0,1]) $$\n    这确保了插值步骤保持良定义。\n\n3.  **插值**：出发点 $ \\vec{x}_{d, \\text{clamped}} $通常不会与 $ t^n $ 时刻的网格节点重合。因此，必须从已知的 $ \\phi^n $ 节点值插值得到 $ \\phi(\\vec{x}_{d, \\text{clamped}}, t^n) $ 的值。对于指定的结构化四边形网格，双线性插值是自然且合适的选择。给定网格单元内的一个点，其值由四个角节点的值插值得到。将整个过程（回溯、钳位和插值）应用于所有网格节点，以计算完整的场 $ \\phi^{n+1} $。\n\n### 加密模式更新\n\n计算出更新后的水平集场 $ \\phi^{n+1} $ 后，确定加密单元的集合。一个单元（网格中的一个四边形单元）由四个角节点定义。根据问题陈述，如果一个单元被界面（$ \\phi $ 的零等值线）切割，则该单元被标记为“加密”。其判据是：“在 $ t^{n+1} $ 时刻，单元的四个角节点 $ \\phi $ 值集合中既包含正值也包含負值，或者包含任何等于零的值（在数值容差范围内）”。\n\n为了稳健地实现这一点，我们引入一个小的数值容差 $ \\varepsilon $。一个合适的值是 $ \\varepsilon = 10^{-9} $，这个值足够小，与 $ \\phi $ 的物理尺度相比可以忽略不计，但又足够大，可以处理零附近的浮点数不精确问题。对于每个单元，设 $ \\Phi_{\\text{corners}} $ 为 $ \\phi^{n+1} $ 的四个角节点值的集合。如果满足以下条件，则该单元被视为加密单元：\n$$ (\\max(\\Phi_{\\text{corners}}) > \\varepsilon \\text{ and } \\min(\\Phi_{\\text{corners}})  -\\varepsilon) \\quad \\lor \\quad (\\min(|\\phi_i|) \\le \\varepsilon \\text{ for any } \\phi_i \\in \\Phi_{\\text{corners}}) $$\n这个逻辑能正确识别其角点间存在符号变化的单元，以及界面非常靠近或穿过节点的单元。此类加密单元的总数是每个测试用例所需的输出。\n\n为提高效率，整个过程都进行了向量化。所有网格节点的出发点和速度都通过数组运算计算。对所有出发点的插值是通过单次调用 SciPy 的 `RegularGridInterpolator` 函数完成的，该函数配置为使用线性插值。", "answer": "```python\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Solves for the number of enriched elements after one time step of advecting a level set function.\n    The advection is performed using a first-order semi-Lagrangian method on a uniform grid.\n    \"\"\"\n    \n    # Define the test suite of cases.\n    test_cases = [\n        {\n            'name': 'A (translation)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (0.3 * np.ones_like(x), 0.0 * np.ones_like(y))\n        },\n        {\n            'name': 'B (rotation)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (-1.0 * (y - 0.5), 1.0 * (x - 0.5))\n        },\n        {\n            'name': 'C (shear)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (y, 0.0 * np.ones_like(y))\n        },\n        {\n            'name': 'D (no motion)',\n            'Nx': 64, \n            'Ny': 64, \n            'dt': 0.05, \n            'v_field': lambda x, y: (0.0 * np.ones_like(x), 0.0 * np.ones_like(y))\n        },\n    ]\n\n    results = []\n    # Numerical tolerance for checking for zero values.\n    eps = 1e-9\n\n    for case in test_cases:\n        Nx, Ny, dt = case['Nx'], case['Ny'], case['dt']\n        v_field = case['v_field']\n\n        # 1. Create mesh grid and define the initial level set function.\n        # The domain is the unit square [0,1] x [0,1].\n        x_coords = np.linspace(0.0, 1.0, Nx)\n        y_coords = np.linspace(0.0, 1.0, Ny)\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n\n        # Initial level set: signed distance to a circle r=0.25 at (0.5, 0.5).\n        phi_initial = np.sqrt((X - 0.5)**2 + (Y - 0.5)**2) - 0.25\n\n        # 2. Advance the level set field one time step.\n        # This is a semi-Lagrangian advection step.\n\n        # Create an interpolator for the initial field phi_initial.\n        # This will be used to find phi at the departure points.\n        # We use linear interpolation, which is bilinear for a 2D grid.\n        interpolator = RegularGridInterpolator(\n            (x_coords, y_coords), phi_initial, \n            method='linear', bounds_error=False, fill_value=None\n        )\n\n        # Calculate the velocity field at all grid points (X, Y).\n        Vx, Vy = v_field(X, Y)\n\n        # Calculate the departure points using first-order Euler back-tracing.\n        Xd = X - Vx * dt\n        Yd = Y - Vy * dt\n\n        # Clamp the departure points to the domain boundaries as per the problem.\n        Xd_clamped = np.clip(Xd, 0.0, 1.0)\n        Yd_clamped = np.clip(Yd, 0.0, 1.0)\n        \n        # Prepare points for the interpolator: a (N, 2) array.\n        departure_points = np.stack([Xd_clamped.ravel(), Yd_clamped.ravel()], axis=-1)\n\n        # Interpolate phi at departure points to find the field at the next time step.\n        phi_next_flat = interpolator(departure_points)\n        phi_next = phi_next_flat.reshape((Nx, Ny))\n\n        # 3. Count the number of enriched elements based on the updated field.\n        enriched_count = 0\n        # Iterate over all elements. An element is defined by its bottom-left node (i, j).\n        for i in range(Nx - 1):\n            for j in range(Ny - 1):\n                # Collect the four corner nodal values of phi_next for the element.\n                corner_values = np.array([\n                    phi_next[i, j],\n                    phi_next[i + 1, j],\n                    phi_next[i, j + 1],\n                    phi_next[i + 1, j + 1]\n                ])\n\n                # Check enrichment criterion: mixed signs or includes a zero (with tolerance).\n                has_pos = np.any(corner_values > eps)\n                has_neg = np.any(corner_values  -eps)\n                has_zero = np.any(np.abs(corner_values) = eps)\n\n                if (has_pos and has_neg) or has_zero:\n                    enriched_count += 1\n        \n        results.append(enriched_count)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3506750"}, {"introduction": "实际工程应用中的不连续性行为通常是高度非线性的，例如材料的内聚力模型或接触力学。本练习将带领您解决一个包含非线性内聚力裂纹的XFEM问题，您将实现一个牛顿-拉弗森（Newton-Raphson）迭代求解器来处理由此产生的非线性方程组[@problem_id:3506770]。这是将XFEM应用于更真实、更复杂的物理场景所必需的一项高级技能。", "problem": "考虑一个使用扩展有限元法 (XFEM) 建立的单一平直裂纹一维弹性杆的小应变、准静态界面模型。裂纹由一个双节点富集界面表示，裂纹张开位移场在单个积分点处使用线性形函数进行插值。所考虑的物理耦合是多物理场的：流体压力作用在裂纹面上以使裂纹张开，热载荷贡献于有效张开力。裂纹两面之间的内聚牵引力遵循一个非线性的牵引力-分离位移本构律，该定律对张开和压缩情况进行分段定义。本问题中的所有量都经过无量纲化处理；不需要物理单位。\n\n在忽略惯性力和体力的情况下，从线性动量平衡出发，裂纹面上的牵引力平衡意味着内部内聚牵引力必须与结构阻力和外部裂纹面载荷相平衡。令富集自由度为向量 $w = [w_1, w_2]^T$，代表两个富集节点处的位移跳跃参数。积分点处的裂纹张开位移插值为\n$$\nw_g = N_1 w_1 + N_2 w_2,\n$$\n其中线性形函数为 $N_1 = N_2 = \\frac{1}{2}$。定义富集刚度矩阵\n$$\nK = k_e \\begin{bmatrix}1   \\rho \\\\ \\rho   1\\end{bmatrix},\n$$\n其中 $k_e > 0$ 是富集结构刚度，$0 \\le \\rho  1$ 量化了富集自由度之间的耦合程度。流体压力载荷 $p \\ge 0$ 均匀作用于裂纹面上，并通过形函数加权对残差产生贡献。热载荷参数 $\\theta \\ge 0$ 作为与形函数成比例的有效张开力产生贡献。\n\n内聚牵引力-分离位移本构律定义为\n$$\nT(w_g) = \\begin{cases}\n\\sigma_0 \\left(1 - e^{-\\beta w_g}\\right),  \\text{if } w_g \\ge 0 \\quad \\text{(opening)}, \\\\\nk_c\\, w_g,  \\text{if } w_g  0 \\quad \\text{(compression/contact)},\n\\end{cases}\n$$\n其中 $\\sigma_0 > 0$ 是内聚强度尺度，$\\beta > 0$ 表征软化律的非线性，而 $k_c > 0$ 是压缩状态下的接触罚刚度。牵引力对裂纹张开位移的导数为\n$$\n\\frac{dT}{dw_g} = \\begin{cases}\n\\sigma_0 \\beta\\, e^{-\\beta w_g},  \\text{if } w_g \\ge 0, \\\\\nk_c,  \\text{if } w_g  0.\n\\end{cases}\n$$\n\n在 XFEM 中使用 Heaviside 富集，并在界面积分点应用加权残差声明，则两个富集自由度的离散非线性残差为\n$$\nR_i(w) = \\sum_{j=1}^{2} K_{ij} w_j + N_i\\, T(w_g) - N_i\\, p - N_i\\, \\theta, \\quad i=1,2,\n$$\n其中 $N_1 = N_2 = \\frac{1}{2}$ 且 $w_g = \\frac{1}{2}(w_1 + w_2)$。\n\nNewton's method 所需的一致切线（雅可比）矩阵由残差导出。使用链式法则，\n$$\nJ_{ij}(w) = \\frac{\\partial R_i}{\\partial w_j} = K_{ij} + N_i \\frac{dT}{dw_g} N_j, \\quad i,j=1,2,\n$$\n这可以紧凑地写为\n$$\nJ(w) = K + \\frac{dT}{dw_g} \\, (N \\otimes N),\n$$\n其中 $N = \\begin{bmatrix}\\frac{1}{2}  \\frac{1}{2}\\end{bmatrix}^T$ 且 $\\otimes$ 表示外积。\n\n任务：使用上述残差和切线，为非线性系统 $R(w) = 0$ 实现一个 Newton–Raphson 求解器，该求解器包含一个可选的回溯线搜索功能，通过减小步长来确保残差范数的减小。牛顿更新公式为\n$$\nJ(w^{(k)}) \\, \\Delta w^{(k)} = - R(w^{(k)}), \\quad w^{(k+1)} = w^{(k)} + \\lambda^{(k)} \\Delta w^{(k)},\n$$\n其中，如果启用线搜索，$0  \\lambda^{(k)} \\le 1$ 由线搜索确定，否则 $\\lambda^{(k)} = 1$。使用残差向量的欧几里得范数来评估收敛性。使用停止准则 $\\|R(w^{(k)})\\| \\le \\varepsilon$，其中 $\\varepsilon > 0$ 是指定的容差，或达到最大迭代次数。\n\n对于每个测试用例，您的程序必须返回一个包含三个值的列表：\n- 直到终止（收敛或达到最大值）所执行的牛顿迭代的整数次数。\n- 作为浮点数的最终残差范数。\n- 在所有迭代中应用的回溯线搜索步长缩减的总整数次数（如果禁用线搜索，则为零）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个结果本身也表示为一个用方括号括起来的逗号分隔列表。例如，两个测试用例的输出格式为“[[n1,r1,ls1],[n2,r2,ls2]]”。\n\n为以下测试套件实现求解器，该套件探索了一系列行为，包括典型的收敛情况、高载荷、初始压缩状态以及禁用线搜索的效果。所有量均为无量纲。\n\n测试用例 1 (理想情况):\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 20.0$, $p = 2.0$, $\\theta = 0.5$.\n- 初始猜测值 $w^{(0)} = [0.0, 0.0]^T$.\n- 启用线搜索。\n- 容差 $\\varepsilon = 10^{-10}$，最大迭代次数 $50$。\n\n测试用例 2 (高流体压力):\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 20.0$, $p = 8.0$, $\\theta = 0.0$.\n- 初始猜测值 $w^{(0)} = [0.1, 0.1]^T$.\n- 启用线搜索。\n- 容差 $\\varepsilon = 10^{-10}$，最大迭代次数 $50$。\n\n测试用例 3 (初始压缩状态):\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 30.0$, $p = 0.5$, $\\theta = 0.2$.\n- 初始猜测值 $w^{(0)} = [-0.3, -0.1]^T$.\n- 启用线搜索。\n- 容差 $\\varepsilon = 10^{-10}$，最大迭代次数 $50$。\n\n测试用例 4 (无回溯线搜索对比):\n- $k_e = 6.0$, $\\rho = 0.2$, $\\sigma_0 = 5.0$, $\\beta = 4.0$, $k_c = 20.0$, $p = 2.0$, $\\theta = 0.5$.\n- 初始猜测值 $w^{(0)} = [0.0, 0.0]^T$.\n- 禁用线搜索。\n- 容差 $\\varepsilon = 10^{-10}$，最大迭代次数 $50$。\n\n您的程序应生成单行输出，其中包含四个测试用例的结果列表，格式完全为“[[n1,r1,ls1],[n2,r2,ls2],[n3,r3,ls3],[n4,r4,ls4]]”，其中 $n_i$ 是整数，$r_i$ 是浮点数。此问题中未出现角度；因此，无需指定角度单位。所有量均为无量纲，因此无需指定物理单位。程序必须是自包含的，并且不需要任何用户输入。", "solution": "该问题是有效的，因为它在计算力学领域提出了一个适定的、有科学依据的场景，该场景是自包含的，且没有矛盾或歧义。任务是实现一种标准数值方法，即 Newton-Raphson 算法，以求解一个从裂纹的扩展有限元法 (XFEM) 模型推导出的非线性方程组。所有必要的方程、参数和边界条件均已提供。\n\n问题的核心是找到满足非线性方程组 $R(w) = 0$ 的富集自由度向量 $w = [w_1, w_2]^T$，其中 $R$ 是残差向量。Newton-Raphson 方法是一种迭代过程，用于寻找实值函数根的逐次更优的近似解。该问题的更新规则推导如下。\n\n在第 k 次迭代中，给定一个近似值 $w^{(k)}$，我们寻求一个修正量 $\\Delta w^{(k)}$，使得 $w^{(k+1)} = w^{(k)} + \\Delta w^{(k)}$ 是一个更好的近似解。我们使用一阶泰勒展开在 $w^{(k)}$ 附近对残差函数 $R(w)$进行线性化：\n$$\nR(w^{(k+1)}) \\approx R(w^{(k)}) + J(w^{(k)}) (w^{(k+1)} - w^{(k)}) = R(w^{(k)}) + J(w^{(k)}) \\Delta w^{(k)}\n$$\n其中 $J(w^{(k)})$ 是 $R$ 在 $w^{(k)}$ 处求值的雅可比矩阵。令 $R(w^{(k+1)}) = 0$，我们得到用于更新步的线性方程组：\n$$\nJ(w^{(k)}) \\Delta w^{(k)} = - R(w^{(k)})\n$$\n一旦计算出 $\\Delta w^{(k)}$，新的近似解为 $w^{(k+1)} = w^{(k)} + \\lambda^{(k)} \\Delta w^{(k)}$，其中 $\\lambda^{(k)} \\in (0, 1]$ 是由线搜索算法确定的步长参数，以确保稳健收敛。如果不使用线搜索，则 $\\lambda^{(k)} = 1$。该过程重复进行，直到残差的欧几里得范数 $\\|R(w^{(k)})\\|$ 降至指定的容差 $\\varepsilon$ 以下，或达到最大迭代次数。\n\n该问题算法的具体组成部分如下：\n\n1.  系统变量和参数：\n    该系统由富集自由度向量 $w = [w_1, w_2]^T$ 描述。单个积分点处的裂纹张开位移由 $w_g = \\frac{1}{2}(w_1 + w_2)$ 给出。模型参数包括富集结构刚度 $k_e$、耦合项 $\\rho$、内聚本构律参数 $\\sigma_0$、$\\beta$ 和 $k_c$，以及外载荷参数 $p$ 和 $\\theta$。\n\n2.  残差向量 $R(w)$：\n    残差向量是一个 $2 \\times 1$ 的向量，定义为：\n    $$\n    R(w) = K w + N T(w_g) - N(p + \\theta)\n    $$\n    其中 $K = k_e \\begin{bmatrix}1   \\rho \\\\ \\rho   1\\end{bmatrix}$ 是富集刚度矩阵，$N = [\\frac{1}{2}, \\frac{1}{2}]^T$ 是形函数向量，$T(w_g)$ 是分段内聚牵引力：\n    $$\n    T(w_g) = \\begin{cases}\n    \\sigma_0 (1 - e^{-\\beta w_g}),  w_g \\ge 0 \\\\\n    k_c w_g,  w_g  0\n    \\end{cases}\n    $$\n    在每次迭代中，$w_g$ 由当前的 $w^{(k)}$ 计算得出，这决定了在计算 $T(w_g)$ 时使用牵引力本构律的哪个分支。\n\n3.  雅可比矩阵 $J(w)$：\n    雅可比矩阵（或一致切线矩阵）是一个 $2 \\times 2$ 的矩阵，由下式给出：\n    $$\n    J(w) = K + \\frac{dT}{dw_g} (N \\otimes N)\n    $$\n    其中 $N \\otimes N$ 是外积 $N N^T$，牵引力的导数为：\n    $$\n    \\frac{dT}{dw_g} = \\begin{cases}\n    \\sigma_0 \\beta e^{-\\beta w_g},  w_g \\ge 0 \\\\\n    k_c,  w_g  0\n    \\end{cases}\n    $$\n    $\\frac{dT}{dw_g}$ 项也使用当前的 $w_g$ 进行求值。得到的雅可比矩阵为：\n    $$\n    J(w) = \\begin{bmatrix} k_e + \\frac{1}{4}\\frac{dT}{dw_g}   k_e \\rho + \\frac{1}{4}\\frac{dT}{dw_g} \\\\ k_e \\rho + \\frac{1}{4}\\frac{dT}{dw_g}   k_e + \\frac{1}{4}\\frac{dT}{dw_g} \\end{bmatrix}\n    $$\n\n4.  回溯线搜索：\n    如果启用，则采用回溯线搜索来寻找合适的步长 $\\lambda^{(k)}$。从 $\\lambda^{(k)}=1$ 开始，算法检查建议的更新是否减小了残差范数，即 $\\|R(w^{(k)} + \\lambda^{(k)} \\Delta w^{(k)})\\|  \\|R(w^{(k)})\\|$ 是否成立。如果此条件不满足，则将 $\\lambda^{(k)}$ 连续减小（例如，减半），直到条件满足或达到最大缩减次数。此类缩减的次数将被追踪记录。\n\n迭代过程：\n所实现的算法对每个测试用例遵循以下步骤：\n\n1.  初始化迭代计数器 $k=0$，总线搜索缩减次数 $ls\\_count = 0$，以及初始猜测值 $w^{(0)}$。构建刚度矩阵 $K$ 和形函数向量 $N$。\n2.  开始主循环，对于 $k$ 从 $0$ 到 `max_iterations-1`：\n    a. 计算 $w_g = N^T w^{(k)}$。\n    b. 计算 $T(w_g)$ 和总外力 $(p+\\theta)$。\n    c. 计算残差向量 $R(w^{(k)}) = K w^{(k)} + N(T(w_g) - p - \\theta)$。\n    d. 计算欧几里得范数 $\\|R(w^{(k)})\\|$。如果 $\\|R(w^{(k)})\\| \\le \\varepsilon$，则达到收敛。循环终止。\n    e. 基于 $w_g$ 计算 $\\frac{dT}{dw_g}$。\n    f. 组装雅可比矩阵 $J(w^{(k)}) = K + \\frac{dT}{dw_g} (N N^T)$。\n    g. 求解线性系统 $J(w^{(k)}) \\Delta w^{(k)} = -R(w^{(k)})$ 以得到 $\\Delta w^{(k)}$。\n    h. 如果启用线搜索：\n        i. 初始化 $\\lambda = 1$ 和用于此步骤中缩减次数的计数器。\n        ii. 进入一个循环：计算试探解 $w_{trial} = w^{(k)} + \\lambda \\Delta w^{(k)}$ 和相应的残差 $R_{trial}$。如果 $\\|R_{trial}\\|  \\|R(w^{(k)})\\|$，则跳出循环。否则，设置 $\\lambda \\leftarrow \\lambda/2$，增加缩减计数器，并重复。\n        iii. 将缩减次数加到 $ls\\_count$ 上。\n    i. 如果禁用线搜索，则设置 $\\lambda = 1$。\n    j. 更新解：$w^{(k+1)} = w^{(k)} + \\lambda \\Delta w^{(k)}$。\n3.  循环终止后（由于收敛或达到 `max_iterations`），返回最终迭代次数、最终残差范数和总线搜索缩减次数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef newton_raphson_solver(params, initial_w, settings):\n    \"\"\"\n    Solves the nonlinear system R(w) = 0 using the Newton-Raphson method.\n\n    Args:\n        params (tuple): Physical parameters (k_e, rho, sigma_0, beta, k_c, p, theta).\n        initial_w (np.ndarray): Initial guess for w = [w1, w2].\n        settings (tuple): Solver settings (tolerance, max_iterations, line_search_enabled).\n\n    Returns:\n        tuple: (iteration_count, final_residual_norm, total_line_search_reductions).\n    \"\"\"\n    k_e, rho, sigma_0, beta, k_c, p, theta = params\n    tolerance, max_iterations, line_search_enabled = settings\n\n    w = np.array(initial_w, dtype=float)\n    \n    K = k_e * np.array([[1.0, rho], [rho, 1.0]])\n    N = np.array([0.5, 0.5])\n    \n    total_ls_reductions = 0\n    residual_norm = float('inf')\n    \n    for i in range(max_iterations):\n        # 1. Calculate crack opening\n        w_g = np.dot(N, w)\n        \n        # 2. Evaluate traction T and its derivative dT/dw_g\n        if w_g >= 0:\n            exp_term = np.exp(-beta * w_g)\n            T_wg = sigma_0 * (1.0 - exp_term)\n            dT_dwg = sigma_0 * beta * exp_term\n        else:\n            T_wg = k_c * w_g\n            dT_dwg = k_c\n            \n        # 3. Compute residual vector R\n        F_ext = p + theta\n        R = K @ w + N * (T_wg - F_ext)\n        residual_norm = np.linalg.norm(R)\n        \n        # 4. Check for convergence\n        if residual_norm = tolerance:\n            return i, residual_norm, total_ls_reductions\n            \n        # 5. Assemble Jacobian matrix J\n        N_outer_N = np.outer(N, N)\n        J = K + dT_dwg * N_outer_N\n        \n        # 6. Solve for the update step delta_w\n        try:\n            delta_w = np.linalg.solve(J, -R)\n        except np.linalg.LinAlgError:\n            # Jacobian is singular, cannot proceed\n            return i + 1, residual_norm, total_ls_reductions\n\n        # 7. Apply backtracking line search (if enabled)\n        step_lambda = 1.0\n        if line_search_enabled:\n            current_residual_norm = residual_norm\n            num_reductions = 0\n            max_ls_steps = 10 # Avoid infinite loops\n            \n            for ls_step in range(max_ls_steps):\n                w_trial = w + step_lambda * delta_w\n                w_g_trial = np.dot(N, w_trial)\n                \n                if w_g_trial >= 0:\n                    exp_term_trial = np.exp(-beta * w_g_trial)\n                    T_wg_trial = sigma_0 * (1.0 - exp_term_trial)\n                else:\n                    T_wg_trial = k_c * w_g_trial\n                \n                R_trial = K @ w_trial + N * (T_wg_trial - F_ext)\n                trial_residual_norm = np.linalg.norm(R_trial)\n                \n                if trial_residual_norm  current_residual_norm:\n                    break\n                else:\n                    step_lambda /= 2.0\n                    num_reductions += 1\n            total_ls_reductions += num_reductions\n        \n        # 8. Update solution vector w\n        w += step_lambda * delta_w\n        \n    # If loop finishes, max iterations was reached\n    # Re-calculate final residual norm for the last state\n    w_g = np.dot(N, w)\n    if w_g >= 0:\n        exp_term = np.exp(-beta * w_g)\n        T_wg = sigma_0 * (1.0 - exp_term)\n    else:\n        T_wg = k_c * w_g\n    F_ext = p + theta\n    R = K @ w + N * (T_wg - F_ext)\n    final_residual_norm = np.linalg.norm(R)\n\n    return max_iterations, final_residual_norm, total_ls_reductions\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 20.0, 2.0, 0.5),\n            \"initial_w\": [0.0, 0.0],\n            \"settings\": (1e-10, 50, True)\n        },\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 20.0, 8.0, 0.0),\n            \"initial_w\": [0.1, 0.1],\n            \"settings\": (1e-10, 50, True)\n        },\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 30.0, 0.5, 0.2),\n            \"initial_w\": [-0.3, -0.1],\n            \"settings\": (1e-10, 50, True)\n        },\n        {\n            \"params\": (6.0, 0.2, 5.0, 4.0, 20.0, 2.0, 0.5),\n            \"initial_w\": [0.0, 0.0],\n            \"settings\": (1e-10, 50, False)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n_iters, final_resid, ls_count = newton_raphson_solver(\n            case[\"params\"],\n            case[\"initial_w\"],\n            case[\"settings\"]\n        )\n        results.append([n_iters, final_resid, ls_count])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3506770"}]}