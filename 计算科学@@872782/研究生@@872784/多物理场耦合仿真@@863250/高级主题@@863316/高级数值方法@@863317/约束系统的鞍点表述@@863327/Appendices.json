{"hands_on_practices": [{"introduction": "这个练习将引导您通过编码实践，直接比较两种在有限元分析中施加约束的常用技术。您将为一个简单的一维泊松问题，分别使用拉格朗日乘子法（一种鞍点系统）和罚函数法来施加狄利克雷边界条件。通过亲手实现这两种方法并量化它们的误差，您将深刻理解鞍点公式在精确执行约束方面的优势，以及罚函数法在实现简洁性与可能引入的近似误差和病态问题之间的权衡。", "problem": "考虑区间 $[0,1]$ 上具有恒定体力的的一维标量泊松问题，其主场 $u(x)$ 满足强形式 $-u''(x)=1$（对于 $x\\in(0,1)$），同时在右端点满足零诺伊曼边界条件 $u'(1)=0$，并在左端点满足边界约束 $u(0)=0$。将 $u(0)=0$ 视为一个约束，可通过拉格朗日乘子（鞍点提法）或罚函数项来施加。从 $-u''=1$ 在 $x=1$ 处具有自然（诺伊曼）边界的标准变分陈述出发，利用虚功原理建立带有拉格朗日乘子的约束弱问题，并分别通过为约束添加二次罚函数项来建立罚函数弱问题。然后，在 $[0,1]$ 上使用 $N$ 个单元、网格尺寸为 $h=1/N$ 的均匀线性有限元对两种提法进行离散化，并实现以下内容：\n\n- 对于乘子法，引入一个额外的标量未知数（乘子），在弱意义下施加 $u(0)=0$，从而产生一个将有限元刚度与约束耦合的鞍点线性系统。\n- 对于罚函数法，添加一个与标量罚参数 $\\gamma$ 成正比的对称罚双线性形式，以弱形式施加 $u(0)\\approx 0$。\n\n使用与强形式和约束条件一致的、在相同物理和数学框架内选择的精确解析解作为参考，以量化数值误差。为每种方法和每个测试用例计算以下指标：\n- $L^2$ 误差范数 $\\left(\\int_{0}^{1}\\left(u_{\\text{exact}}(x)-u_h(x)\\right)^2\\,dx\\right)^{1/2}$。\n- 误差的 $H^1$ 半范数 $\\left(\\int_{0}^{1}\\left(u'_{\\text{exact}}(x)-u'_h(x)\\right)^2\\,dx\\right)^{1/2}$。\n- 边界上的约束残差 $\\left|u_h(0)\\right|$。\n\n您的实现必须使用足够阶数的高斯求积，以精确积分在一维线性元中这些范数所产生的多项式。所有积分都必须在 $x\\in[0,1]$ 上进行。\n\n您的推导应基于：\n- 强形式 $-u''(x)=1$（对于 $x\\in(0,1)$），以及 $u'(1)=0$ 和等式约束 $u(0)=0$。\n- 在添加约束之前，对所有容许的 $v(x)$，对应的无约束弱形式为 $\\int_{0}^{1}u'(x)v'(x)\\,dx=\\int_{0}^{1}1\\cdot v(x)\\,dx$。\n\n精确定义离散提法，然后实现它们。假设使用均匀网格和线性基函数。用于比较的精确解必须从指定的强形式和边界条件推导得出。测试套件由参数对 $(N,\\gamma)$ 的集合定义，其中 $N$ 是单元数量，$\\gamma$ 是罚参数：\n- $(N,\\gamma)=(4,10)$ 作为一般情况，\n- $(N,\\gamma)=(16,10)$ 用于在小 $\\gamma$ 值下探究网格加密的影响，\n- $(N,\\gamma)=(16,1000)$ 用于在固定 $h$ 值下探究增大 $\\gamma$ 的影响，\n- $(N,\\gamma)=(64,1000)$ 作为中等 $\\gamma$ 值下的加密网格，\n- $(N,\\gamma)=(64,10^6)$ 用于探究极大 $\\gamma$ 值的影响，\n- $(N,\\gamma)=(2,1000)$ 作为粗网格的边界情况。\n\n对于每个测试用例，计算罚函数法和乘子法的三个指标（乘子法不依赖于 $\\gamma$，但为了可比性，必须在相同的 $N$ 值下进行评估）。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，其本身是按 $[E_{L^2}^{\\text{pen}},E_{H^1}^{\\text{pen}},r^{\\text{pen}},E_{L^2}^{\\text{mult}},E_{H^1}^{\\text{mult}},r^{\\text{mult}}]$ 顺序排列的六个浮点数列表，其中 $E_{L^2}$ 是 $L^2$ 误差范数，$E_{H^1}$ 是误差的 $H^1$ 半范数，$r$ 是约束残差 $\\left|u_h(0)\\right|$。\n\n所有数学符号、变量、函数、运算符和数字都必须用美元符号括起来以 LaTeX 格式书写，包括 $u$、$v$、$x$、$N$、$h$、$\\gamma$、$1$、$0$ 以及所有积分和范数。此问题不涉及物理单位；不使用角度和百分比。输出必须符合上述格式，并且所有测试用例的答案都必须是浮点数。", "solution": "该问题要求解一维泊松方程 $-u''(x) = 1$（在区间 $x \\in (0,1)$ 上），边界条件为 $u'(1)=0$ 和 $u(0)=0$。条件 $u(0)=0$ 被视为一个约束，通过两种不同的方法施加：罚函数法和拉格朗日乘子法。解将使用线性基函数的有限元法获得。\n\n### 1. 解析解\n首先，我们建立精确解析解，作为数值误差分析的基准。微分方程的强形式为：\n$$ -u''(x) = 1 $$\n对 $x$ 积分，得到：\n$$ -u'(x) = x + C_1 $$\n应用诺伊曼边界条件 $u'(1)=0$ 来确定常数 $C_1$：\n$$ -u'(1) = 1 + C_1 = 0 \\implies C_1 = -1 $$\n因此，解的导数为：\n$$ u'(x) = 1 - x $$\n再次积分，得到 $u(x)$ 的通解：\n$$ u(x) = x - \\frac{1}{2}x^2 + C_2 $$\n使用约束条件 $u(0)=0$ 来求解 $C_2$：\n$$ u(0) = 0 - 0 + C_2 = 0 \\implies C_2 = 0 $$\n因此，精确解为：\n$$ u_{\\text{exact}}(x) = x - \\frac{1}{2}x^2 $$\n其导数为 $u'_{\\text{exact}}(x) = 1 - x$。\n\n### 2. 变分提法\n我们从给定的无约束弱形式出发，它对应于双线性形式 $a(u,v) = \\int_{0}^{1} u'(x)v'(x) \\,dx$ 和线性泛函 $L(v) = \\int_{0}^{1} 1 \\cdot v(x) \\,dx$。问题是在合适的空间 $V$（此处为 $H^1(0,1)$）中找到一个函数 $u(x)$，使其满足变分方程和约束条件 $u(0)=0$。\n\n#### 2.1. 罚函数法提法\n在罚函数法中，通过向总势能泛函中添加一个罚函数项来弱施加约束 $u(0)=0$。需要最小化的修正泛函为：\n$$ J(u) = \\frac{1}{2} a(u,u) - L(u) + \\frac{1}{2}\\gamma (u(0))^2 $$\n其中 $\\gamma > 0$ 是一个大的罚参数。解 $u_\\gamma$ 通过要求 $J(u)$ 相对于任意测试函数 $v \\in V$ 的一阶变分为零来找到。这得到了罚函数弱提法：\n求 $u_\\gamma \\in V$，使得对于所有 $v \\in V$：\n$$ a(u_\\gamma, v) + \\gamma u_\\gamma(0)v(0) = L(v) $$\n代入 $a(\\cdot,\\cdot)$ 和 $L(\\cdot)$ 的定义：\n$$ \\int_{0}^{1} u_\\gamma'(x)v'(x) \\,dx + \\gamma u_\\gamma(0)v(0) = \\int_{0}^{1} v(x) \\,dx $$\n\n#### 2.2. 拉格朗日乘子法提法\n此方法引入一个拉格朗日乘子 $\\lambda$ 来精确施加约束。我们求解一对 $(u, \\lambda) \\in V \\times \\mathbb{R}$。增广泛函（拉格朗日量）为：\n$$ \\mathcal{L}(u, \\lambda) = \\frac{1}{2} a(u,u) - L(u) + \\lambda u(0) $$\n解是 $\\mathcal{L}$ 的一个驻点。对 $u$（在 $v$ 方向上）和 $\\lambda$（在 $\\mu$ 方向上）取变分并令其为零，得到以下方程组：\n1.  对所有 $v \\in V$，$\\delta_u \\mathcal{L}(v) = a(u,v) - L(v) + \\lambda v(0) = 0$。\n2.  对所有 $\\mu \\in \\mathbb{R}$，$\\delta_\\lambda \\mathcal{L}(\\mu) = \\mu u(0) = 0$，这意味着 $u(0)=0$。\n\n这导出了鞍点弱提法：求 $(u, \\lambda) \\in V \\times \\mathbb{R}$，使得：\n$$ \\int_{0}^{1} u'(x)v'(x) \\,dx + \\lambda v(0) = \\int_{0}^{1} v(x) \\,dx \\quad \\forall v \\in V $$\n$$ u(0) = 0 $$\n物理上，乘子 $\\lambda$ 可以被解释为施加约束所需的反作用通量。与分部积分产生的边界项比较可知，$\\lambda = -u'(0)$。对于精确解，$\\lambda = -(1-0) = -1$。\n\n### 3. 有限元离散化\n我们将区间 $[0,1]$ 离散化为 $N$ 个长度为 $h=1/N$ 的均匀单元。节点位于 $x_i = i h$（$i=0, 1, \\dots, N$）。我们使用线性基函数（帽函数）$\\phi_i(x)$，其中 $\\phi_i(x_j) = \\delta_{ij}$。有限元解近似为 $u_h(x) = \\sum_{j=0}^{N} u_j \\phi_j(x)$，其中 $\\mathbf{u} = (u_0, u_1, \\dots, u_N)^T$ 是节点未知数值的向量。\n\n标准刚度矩阵 $K$ 和力向量 $F$ 的组装项为：\n$$ K_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx $$\n$$ F_i = L(\\phi_i) = \\int_0^1 \\phi_i(x) \\,dx $$\n对于带有线性单元的均匀网格，这会得到 $(N+1) \\times (N+1)$ 的对称三对角刚度矩阵 $K$ 和载荷向量 $F$：\n$$ K = \\frac{1}{h} \\begin{pmatrix} 1 & -1 & & & \\\\ -1 & 2 & -1 & & \\\\ & \\ddots & \\ddots & \\ddots & \\\\ & & -1 & 2 & -1 \\\\ & & & -1 & 1 \\end{pmatrix}, \\quad F = h \\begin{pmatrix} 1/2 \\\\ 1 \\\\ \\vdots \\\\ 1 \\\\ 1/2 \\end{pmatrix} $$\n\n#### 3.1. 离散罚函数系统\n通过设置 $u_h = \\sum_j u_j \\phi_j$ 和 $v = \\phi_i$ 来离散化罚函数弱形式，得到：\n$$ \\sum_{j=0}^{N} u_j K_{ij} + \\gamma \\left(\\sum_{j=0}^{N} u_j \\phi_j(0)\\right) \\phi_i(0) = F_i \\quad \\text{for } i=0, \\dots, N $$\n由于 $\\phi_j(0) = \\delta_{j0}$ 且 $u_h(0) = u_0$，上式得以简化。罚函数项仅影响第一个方程（$i=0$），在左侧添加了 $\\gamma u_0$。这等效于在刚度矩阵的 $(0,0)$ 项上加上 $\\gamma$。得到的线性系统是：\n$$ (K + K_p) \\mathbf{u} = F \\quad \\text{where} \\quad K_p = \\begin{pmatrix} \\gamma & 0 & \\dots \\\\ 0 & 0 & \\dots \\\\ \\vdots & \\vdots & \\ddots \\end{pmatrix} $$\n\n#### 3.2. 离散拉格朗日乘子系统\n离散化鞍点提法会为未知数 $(\\mathbf{u}, \\lambda)$ 产生一个更大的分块结构线性系统。方程变为：\n$$ \\sum_{j=0}^{N} u_j K_{ij} + \\lambda \\phi_i(0) = F_i \\quad \\text{for } i=0, \\dots, N $$\n$$ u_0 = 0 $$\n令 $B$ 为约束向量，使得 $B_i = \\phi_i(0) = \\delta_{i0}$。离散系统可以写成分块矩阵形式：\n$$ \\begin{pmatrix} K & B \\\\ B^T & 0 \\end{pmatrix} \\begin{pmatrix} \\mathbf{u} \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} F \\\\ 0 \\end{pmatrix} $$\n这是一个 $(N+2) \\times (N+2)$ 的对称不定系统。\n\n### 4. 误差指标\n使用三个指标将数值解与精确解进行比较：\n1.  **$L^2$ 误差范数：** $E_{L^2} = \\left(\\int_{0}^{1}\\left(u_{\\text{exact}}(x)-u_h(x)\\right)^2\\,dx\\right)^{1/2}$\n2.  **误差的 $H^1$ 半范数：** $E_{H^1} = \\left(\\int_{0}^{1}\\left(u'_{\\text{exact}}(x)-u'_h(x)\\right)^2\\,dx\\right)^{1/2}$\n3.  **约束残差：** $r = \\left|u_h(0)\\right| = |u_0|$\n\n误差范数的积分使用高斯求积进行数值计算。在每个单元上，$u_h(x)$ 是线性的，$u_h'(x)$ 是常数，而 $u_{\\text{exact}}(x)$ 是二次的，$u'_{\\text{exact}}(x)$ 是线性的。因此，$L^2$ 误差的被积函数是一个4次多项式，需要3点高斯法则才能精确积分。误差的 $H^1$ 半范数的被积函数是一个2次多项式，需要2点高斯法则。为简单和一致起见，3点法则对两者都足够。在 $[0,1]$ 上的积分通过对每个单元的贡献求和来执行，在参考单元上应用求积法则并映射到物理单元坐标。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the 1D Poisson problem with two different constraint enforcement methods\n    and computes error metrics against the exact solution.\n    \"\"\"\n\n    test_cases = [\n        (4, 10.0),\n        (16, 10.0),\n        (16, 1000.0),\n        (64, 1000.0),\n        (64, 1.0e6),\n        (2, 1000.0),\n    ]\n\n    all_results = []\n\n    for N, gamma in test_cases:\n        h = 1.0 / N\n        num_nodes = N + 1\n\n        # Assemble stiffness matrix K and force vector F\n        K = np.zeros((num_nodes, num_nodes))\n        F = np.zeros(num_nodes)\n\n        # Diagonals\n        K.flat[::num_nodes+1] = 2.0 / h\n        K[0, 0] = 1.0 / h\n        K[N, N] = 1.0 / h\n        # Off-diagonals\n        off_diag = -1.0 / h\n        K.flat[1::num_nodes+1] = off_diag\n        K.flat[num_nodes::num_nodes+1] = off_diag\n\n        # Force vector\n        F[:] = h\n        F[0] = h / 2.0\n        F[N] = h / 2.0\n\n        # --- Penalty Method ---\n        K_pen = np.copy(K)\n        K_pen[0, 0] += gamma\n        u_pen = linalg.solve(K_pen, F)\n        \n        l2_pen, h1_pen = calculate_error_norms(u_pen, N)\n        r_pen = np.abs(u_pen[0])\n\n        # --- Lagrange Multiplier Method ---\n        # Form the saddle-point system matrix A_mult\n        A_mult = np.zeros((num_nodes + 1, num_nodes + 1))\n        A_mult[:num_nodes, :num_nodes] = K\n        B = np.zeros(num_nodes)\n        B[0] = 1.0\n        A_mult[:num_nodes, num_nodes] = B\n        A_mult[num_nodes, :num_nodes] = B.T\n\n        # Form the right-hand side vector\n        rhs_mult = np.zeros(num_nodes + 1)\n        rhs_mult[:num_nodes] = F\n\n        # Solve the system\n        sol_mult = linalg.solve(A_mult, rhs_mult)\n        u_mult = sol_mult[:num_nodes]\n        # _lambda = sol_mult[num_nodes] # The multiplier is not used further\n        \n        l2_mult, h1_mult = calculate_error_norms(u_mult, N)\n        r_mult = np.abs(u_mult[0])\n\n        case_results = [l2_pen, h1_pen, r_pen, l2_mult, h1_mult, r_mult]\n        all_results.append(case_results)\n\n    # Format output string\n    # Replace Python's default representation to remove spaces for cleaner output\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\n\ndef calculate_error_norms(u_h_coeffs, N):\n    \"\"\"\n    Computes L2 and H1 error norms using Gaussian quadrature.\n    \"\"\"\n    h = 1.0 / N\n    \n    # 3-point Gauss quadrature on [-1, 1]\n    z_pts = [-np.sqrt(3.0/5.0), 0.0, np.sqrt(3.0/5.0)]\n    w_pts = [5.0/9.0, 8.0/9.0, 5.0/9.0]\n    \n    l2_err_sq = 0.0\n    h1_err_sq = 0.0\n\n    # Exact solution and its derivative\n    u_exact_func = lambda x: x - 0.5 * x**2\n    u_exact_prime_func = lambda x: 1.0 - x\n\n    for e in range(N):\n        # Nodal coordinates and values for element e\n        x_e = e * h\n        u_e = u_h_coeffs[e]\n        u_e1 = u_h_coeffs[e+1]\n        \n        # Derivative of FE solution on element e (constant)\n        u_h_prime_val = (u_e1 - u_e) / h\n\n        # Loop over Gauss points\n        for z_k, w_k in zip(z_pts, w_pts):\n            # Map reference point to physical coordinate\n            x_q = x_e + h * (z_k + 1.0) / 2.0\n            \n            # Evaluate exact solution and its derivative\n            u_exact_val = u_exact_func(x_q)\n            u_exact_prime_val = u_exact_prime_func(x_q)\n            \n            # Evaluate FE solution at x_q\n            # Local coordinate xi is (z_k+1)/2\n            xi_q = (z_k + 1.0) / 2.0\n            u_h_val = u_e * (1.0 - xi_q) + u_e1 * xi_q\n            \n            # Accumulate squared errors\n            l2_err_sq += w_k * (u_exact_val - u_h_val)**2\n            h1_err_sq += w_k * (u_exact_prime_val - u_h_prime_val)**2\n    \n    # Apply Jacobian determinant and take square root\n    # The Jacobian factor is h/2\n    l2_err = np.sqrt(l2_err_sq * h / 2.0)\n    h1_err = np.sqrt(h1_err_sq * h / 2.0)\n    \n    return l2_err, h1_err\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3525095"}, {"introduction": "建立一个鞍点系统只是第一步，确保其离散化方案的稳定性是获得物理上有意义解的关键。这个练习将带您深入探讨著名的 inf-sup (或LBB) 稳定性条件，它是不压缩流体等问题中鞍点公式的核心。您将不再仅仅是记忆抽象的定理，而是需要在一个不稳定的速度-压力单元配对（$P_1-P_1$ 单元）上，通过解析推导来明确构造一个“伪压力模式”，从而使稳定性的概念变得具体而可见。", "problem": "考虑单位正方形域 $\\Omega = [0,1]^{2}$ 上的稳态不可压缩斯托克斯方程，速度满足齐次狄利克雷边界条件。设其弱形式由以下鞍点系统给出：求速度 $u \\in V$ 和压力 $p \\in Q$，使得\n$$\na(u,v) + b(v,p) = f(v) \\quad \\text{for all } v \\in V, \\qquad b(u,q) = 0 \\quad \\text{for all } q \\in Q,\n$$\n其中 $V$ 是在 $\\partial \\Omega$ 上迹为零、具有平方可积梯度和平方可积的向量场构成的索伯列夫空间，$Q$ 是在 $\\Omega$ 上均值为零的平方可积函数空间，$a(u,v) = \\int_{\\Omega} 2\\mu \\, \\epsilon(u) : \\epsilon(v) \\, dx$（其中 $\\epsilon(u)$ 是对称梯度），以及 $b(v,p) = -\\int_{\\Omega} p \\, \\nabla \\cdot v \\, dx$。在有限元方法（FEM）中，考虑等阶离散空间\n$$\nV_{h} = \\{ v_{h} \\in V : v_{h} \\text{ 在 } \\Omega \\text{ 的三角剖分上是连续分片线性（$P_{1}$）函数} \\}^{2},\n$$\n$$\nQ_{h} = \\{ q_{h} \\in Q : q_{h} \\text{ 在相同的三角剖分上是连续分片线性（$P_{1}$）函数} \\}.\n$$\n\n使用 $\\Omega$ 的如下协调三角剖分 $\\mathcal{T}_{h}$：顶点集由四个角点 $(0,0)$、$(1,0)$、$(1,1)$、$(0,1)$ 和内点 $C = (1/2,1/2)$ 组成。该网格由四个共享内顶点 $C$ 的三角形构成：\n- $T_{1}$，顶点为 $C$、$(0,0)$、$(1,0)$，\n- $T_{2}$，顶点为 $C$、$(1,0)$、$(1,1)$，\n- $T_{3}$，顶点为 $C$、$(1,1)$、$(0,1)$，\n- $T_{4}$，顶点为 $C$、$(0,1)$、$(0,0)$。\n\n假设离散速度空间 $V_{h}$ 强施加齐次狄利克雷边界条件，因此只有内节点 $C$ 具有速度自由度。令 $\\{N_{i}\\}$ 表示与节点 $i \\in \\{(0,0), (1,0), (1,1), (0,1), C\\}$ 相关联的标量 $P_{1}$ 节点形函数，并令速度基函数为 $\\phi_{C}^{x} = (N_{C}, 0)$ 和 $\\phi_{C}^{y} = (0, N_{C})$。离散耦合双线性形式为\n$$\nb(v_{h},q_{h}) = -\\int_{\\Omega} q_{h} \\, \\nabla \\cdot v_{h} \\, dx.\n$$\n\n从上述关于三角形上分片线性函数的基本定义和性质出发，构造一个显式的非零 $q_{h} \\in Q_{h}$，其节点值 $\\{p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_{C}\\}$ 满足\n$$\nb(v_{h}, q_{h}) = 0 \\quad \\text{for all } v_{h} \\in V_{h}.\n$$\n\n你的任务：\n- 推导由 $\\mathcal{T}_{h}$ 的结构所隐含的、使得对于所有 $v_{h} \\in V_{h}$ 都有 $b(v_{h}, q_{h})$ 为零的关于 $\\{p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_{C}\\}$ 的充分必要条件。\n- 使用这些条件构造一个具体的非零伪压力模式 $q_{h}$，用其节点值表示。\n- 以行向量的形式给出最终答案\n$$\n\\left(p_{(0,0)} \\ \\ p_{(1,0)} \\ \\ p_{(1,1)} \\ \\ p_{(0,1)} \\ \\ p_{C}\\right),\n$$\n以精确形式表示。不需要四舍五入，且不涉及物理单位。", "solution": "目标是找到一个非零离散压力场 $q_{h} \\in Q_{h}$，使其与离散散度算子的像（image）正交，即对于所有离散速度场 $v_{h} \\in V_{h}$，都有 $b(v_{h}, q_{h}) = 0$。具有此性质的压力场 $q_h$ 被称为伪压力模式，其存在表明所选的速度-压力有限元对（本例中为 $P_1-P_1$）是不稳定的。\n\n需要满足的条件是：\n$$b(v_{h}, q_{h}) = -\\int_{\\Omega} q_{h} \\, \\nabla \\cdot v_{h} \\, dx = 0 \\quad \\text{for all } v_{h} \\in V_{h}.$$\n由于此式必须对任意 $v_{h} \\in V_{h}$ 成立，因此它必须对张成 $V_{h}$ 的基函数成立。根据问题描述，齐次狄利克雷边界条件是强施加的。唯一具有非零速度自由度的节点是内节点 $C = (1/2, 1/2)$。因此，离散速度空间 $V_{h}$ 是一个二维空间，由基函数 $\\phi_{C}^{x} = (N_{C}, 0)$ 和 $\\phi_{C}^{y} = (0, N_{C})$ 张成，其中 $N_{C}$ 是与节点 $C$ 相关联的连续分片线性节点基函数。\n\n压力场 $q_{h}$ 是 $Q_{h}$ 中的一个元素，可以表示为所有五个节点（角点 $V_{(0,0)}=(0,0)$、$V_{(1,0)}=(1,0)$、$V_{(1,1)}=(1,1)$、$V_{(0,1)}=(0,1)$ 和中心点 $C$）的节点基函数 $\\{N_i\\}$ 的线性组合。设 $q_{h}$ 的节点值为 $\\{p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_{C}\\}$。那么，\n$$q_{h}(x,y) = p_{(0,0)}N_{(0,0)}(x,y) + p_{(1,0)}N_{(1,0)}(x,y) + p_{(1,1)}N_{(1,1)}(x,y) + p_{(0,1)}N_{(0,1)}(x,y) + p_{C}N_{C}(x,y).$$\n\n对所有 $v_h \\in V_h$ 成立的条件 $b(v_{h}, q_{h}) = 0$ 可以简化为两个标量方程：\n$1.$ $b(\\phi_{C}^{x}, q_{h}) = -\\int_{\\Omega} q_{h} \\nabla \\cdot \\phi_{C}^{x} \\, dx = -\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial x} \\, dx = 0$.\n$2.$ $b(\\phi_{C}^{y}, q_{h}) = -\\int_{\\Omega} q_{h} \\nabla \\cdot \\phi_{C}^{y} \\, dx = -\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial y} \\, dx = 0$.\n\n我们来分析基函数 $N_C$ 的梯度。在每个三角形 $T_k$ 上，$N_C$ 是一个线性函数，因此其梯度是一个常向量。基函数 $N_C$ 在节点 $C$ 处的值为 1，在所有其他节点处的值为 0。在四个三角形上的梯度为：\n- 在 $T_{1}$ 上（顶点为 $C, (0,0), (1,0)$）：$\\nabla N_{C}|_{T_1} = (0, 2)$。\n- 在 $T_{2}$ 上（顶点为 $C, (1,0), (1,1)$）：$\\nabla N_{C}|_{T_2} = (-2, 0)$。\n- 在 $T_{3}$ 上（顶点为 $C, (1,1), (0,1)$）：$\\nabla N_{C}|_{T_3} = (0, -2)$。\n- 在 $T_{4}$ 上（顶点为 $C, (0,1), (0,0)$）：$\\nabla N_{C}|_{T_4} = (2, 0)$。\n\n因此，$\\frac{\\partial N_C}{\\partial x}$ 仅在 $T_2$ 和 $T_4$ 上非零，而 $\\frac{\\partial N_C}{\\partial y}$ 仅在 $T_1$ 和 $T_3$ 上非零。\n\n现在我们计算第一个方程：\n$$-\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial x} \\, dx = -\\left( \\int_{T_2} q_{h} (-2) \\, dx + \\int_{T_4} q_{h} (2) \\, dx \\right) = 0.$$\n这可以简化为 $\\int_{T_2} q_{h} \\, dx = \\int_{T_4} q_{h} \\, dx$。\n一个线性函数在三角形上的积分等于其面积乘以其在顶点处节点值的平均值。每个三角形的面积是 $\\frac{1}{4}$。\n$T_2$ 的顶点是 $C, (1,0), (1,1)$。所以，$\\int_{T_2} q_{h} dx = \\frac{\\text{Area}(T_2)}{3}(p_C + p_{(1,0)} + p_{(1,1)}) = \\frac{1}{12}(p_C + p_{(1,0)} + p_{(1,1)})$。\n$T_4$ 的顶点是 $C, (0,1), (0,0)$。所以，$\\int_{T_4} q_{h} dx = \\frac{\\text{Area}(T_4)}{3}(p_C + p_{(0,1)} + p_{(0,0)}) = \\frac{1}{12}(p_C + p_{(0,1)} + p_{(0,0)})$。\n令二者相等得到 $p_C + p_{(1,0)} + p_{(1,1)} = p_C + p_{(0,1)} + p_{(0,0)}$，这就得出了我们对节点压力的第一个条件：\n$$(1) \\quad p_{(0,0)} - p_{(1,0)} - p_{(1,1)} + p_{(0,1)} = 0.$$\n\n接下来，我们计算第二个方程：\n$$-\\int_{\\Omega} q_{h} \\frac{\\partial N_{C}}{\\partial y} \\, dx = -\\left( \\int_{T_1} q_{h} (2) \\, dx + \\int_{T_3} q_{h} (-2) \\, dx \\right) = 0.$$\n这可以简化为 $\\int_{T_1} q_{h} \\, dx = \\int_{T_3} q_{h} \\, dx$。\n$T_1$ 的顶点是 $C, (0,0), (1,0)$。所以，$\\int_{T_1} q_h dx = \\frac{1}{12}(p_C + p_{(0,0)} + p_{(1,0)})$。\n$T_3$ 的顶点是 $C, (1,1), (0,1)$。所以，$\\int_{T_3} q_h dx = \\frac{1}{12}(p_C + p_{(1,1)} + p_{(0,1)})$。\n令二者相等得到 $p_C + p_{(0,0)} + p_{(1,0)} = p_C + p_{(1,1)} + p_{(0,1)}$，这就得出了我们的第二个条件：\n$$(2) \\quad p_{(0,0)} + p_{(1,0)} - p_{(1,1)} - p_{(0,1)} = 0.$$\n\n最后，空间 $Q_h$ 是 $L^2_0(\\Omega)$ 的子空间，这意味着压力场在 $\\Omega$ 上的均值必须为零：\n$$\\int_{\\Omega} q_{h} \\, dx = \\sum_{k=1}^4 \\int_{T_k} q_h \\, dx = 0.$$\n将四个三角形上的积分相加：\n$$\\frac{1}{12} \\left[ (p_C+p_{(0,0)}+p_{(1,0)}) + (p_C+p_{(1,0)}+p_{(1,1)}) + (p_C+p_{(1,1)}+p_{(0,1)}) + (p_C+p_{(0,1)}+p_{(0,0)}) \\right] = 0.$$\n这可以简化为 $\\frac{1}{12} (4p_C + 2p_{(0,0)} + 2p_{(1,0)} + 2p_{(1,1)} + 2p_{(0,1)}) = 0$。\n所以，第三个条件是：\n$$(3) \\quad p_{(0,0)} + p_{(1,0)} + p_{(1,1)} + p_{(0,1)} + 2p_C = 0.$$\n\n我们得到了一个包含五个未知数的三个线性方程组。让我们找出它们之间的关系。\n将方程 $(1)$ 和 $(2)$ 相加：\n$(p_{(0,0)} - p_{(1,0)} - p_{(1,1)} + p_{(0,1)}) + (p_{(0,0)} + p_{(1,0)} - p_{(1,1)} - p_{(0,1)}) = 0 \\implies 2p_{(0,0)} - 2p_{(1,1)} = 0 \\implies p_{(1,1)} = p_{(0,0)}$。\n从方程 $(2)$ 中减去方程 $(1)$：\n$(p_{(0,0)} + p_{(1,0)} - p_{(1,1)} - p_{(0,1)}) - (p_{(0,0)} - p_{(1,0)} - p_{(1,1)} + p_{(0,1)}) = 0 \\implies 2p_{(1,0)} - 2p_{(0,1)} = 0 \\implies p_{(0,1)} = p_{(1,0)}$。\n这些是必要条件：对角线上的角点处的节点压力必须相等。\n\n将这些关系代入方程 $(3)$：\n$p_{(0,0)} + p_{(1,0)} + p_{(0,0)} + p_{(1,0)} + 2p_C = 0 \\implies 2p_{(0,0)} + 2p_{(1,0)} + 2p_C = 0$。\n这给出了最后一个条件：$p_C = -p_{(0,0)} - p_{(1,0)}$。\n\n使得 $q_h$ 成为一个伪压力模式的节点值的充分必要条件是：\n- $p_{(1,1)} = p_{(0,0)}$\n- $p_{(0,1)} = p_{(1,0)}$\n- $p_C = -(p_{(0,0)} + p_{(1,0)})$\n\n这定义了一个二维的伪模式空间。任意选择不全为零的 $p_{(0,0)}$ 和 $p_{(1,0)}$ 都会生成一个有效的非零模式。用于说明此现象的一个典型选择是“棋盘格”模式。我们设 $p_{(0,0)} = 1$ 和 $p_{(1,0)} = -1$。\n使用推导出的条件：\n- $p_{(1,1)} = p_{(0,0)} = 1$。\n- $p_{(0,1)} = p_{(1,0)} = -1$。\n- $p_C = -(1 + (-1)) = 0$。\n\n这给出了节点压力向量 $(p_{(0,0)}, p_{(1,0)}, p_{(1,1)}, p_{(0,1)}, p_C) = (1, -1, 1, -1, 0)$。这是一个具体的、非零的伪压力模式。\n最终答案是按指定顺序排列的这些节点值的行向量。", "answer": "$$\\boxed{\\begin{pmatrix} 1 & -1 & 1 & -1 & 0 \\end{pmatrix}}$$", "id": "3525102"}, {"introduction": "最后一个练习展示了鞍点公式在不同物理领域的强大通用性，这次我们将目光投向计算电磁学。您的任务是应用拉格朗日乘子法来强制执行磁场无散度（$\\nabla \\cdot B = 0$）这一基本物理定律，这是麦克斯韦方程组的核心约束之一。该问题不仅将鞍点结构应用于三维非结构化网格上的有限体积式离散，还引入了舒尔补（Schur complement）这一关键的实用求解策略，让您体验如何在一个实际的多物理场仿真场景中解决鞍点问题。", "problem": "考虑在非均质介质中的麦克斯韦方程组的静磁学子集，其中磁通密度$\\;B\\;$和磁场$\\;H\\;$满足$\\;B=\\mu H\\;$，其中$\\;\\mu>0\\;$，且满足无散约束$\\;\\nabla\\cdot B=0\\;$（无磁单极子）。混合公式引入了一个拉格朗日乘子来强制执行$\\;\\nabla\\cdot(\\mu H)=0\\;$，从而产生一个鞍点系统。您的任务是在一个简单的四面体网格上构建一个离散的有限体积鞍点系统，组装其矩阵，并求解一个小例子，以说明乘子如何强制执行$\\;\\nabla\\cdot(\\mu H)=0\\;$。\n\n从以下基本原理开始：\n- 静磁学：$\\;\\nabla\\times H=J\\;$, $\\;B=\\mu H\\;$, $\\;\\nabla\\cdot B=0\\;$。\n- 无散约束$\\;\\nabla\\cdot B=0\\;$通过混合变分形式中的拉格朗日乘子$\\;p\\;$来强制执行。\n- 能量原理：在约束条件$\\;\\nabla\\cdot B=0\\;$下，最小化$\\;\\int \\nu \\lvert B\\rvert^2/2\\;\\mathrm{d}V - \\int \\phi\\cdot B\\;\\mathrm{d}V\\;$，其中磁阻率$\\;\\nu=1/\\mu\\;$和通用源耦合$\\;\\phi\\;$，将导出一个鞍点线性系统。\n\n离散化设置：\n- 使用一个由共享一个面的$2$个四面体组成的四面体网格。顶点（无量纲单位）如下：\n  - $v_0=(0,0,0)$，\n  - $v_1=(1,0,0)$，\n  - $v_2=(0,1,0)$，\n  - $v_3=(0,0,1)$，\n  - $v_4=(1,1,1)$。\n- 这两个四面体是：\n  - $T_0=(v_0,v_1,v_2,v_3)$，\n  - $T_1=(v_1,v_2,v_3,v_4)$。\n- 将唯一的三角形面构建为顶点索引的无序三元组；对每个面，通过将其顶点索引按升序排列来确定一个全局方向，并计算其几何量：\n  - 面质心$\\;c_f\\;$为其$3$个顶点的算术平均值。\n  - 未归一化的面法线$\\;n_f\\;$由与所选方向一致的两条边向量的叉积得出。\n  - 面面积$\\;A_f=\\frac{1}{2}\\lVert n_f\\rVert\\;$。\n\n离散散度算子的组装：\n- 为每个四面体$\\;T\\;$计算单元质心$\\;c_{T}\\;$。\n- 确定面-单元邻接关系：边界面属于一个四面体，内部面属于两个四面体。\n- 定义离散散度矩阵$\\;D\\in\\mathbb{R}^{N_c\\times N_f}\\;$，其中$\\;N_c=2\\;$是单元数，$\\;N_f\\;$是面数。其矩阵项由下式给出\n  $$\n  D_{T,f}=\\operatorname{sign}\\big(n_f\\cdot(c_f-c_T)\\big),\n  $$\n  即，如果所选面法线从单元$\\;T\\;$向外指出，则为$+1$，如果向内指向，则为$-1$。这种选择确保对于两个单元共享的面，符号相反，因此内部通量在单元的散度求和中相互抵消。\n\n未知数和矩阵：\n- 离散未知数$\\;b\\in\\mathbb{R}^{N_f}\\;$表示穿过每个面的面积分法向磁通量$\\;B\\cdot n\\;$（即面通量余链）。无散约束为$\\;D\\,b=0\\;$。\n- 定义一个对角、对称正定矩阵$\\;K\\in\\mathbb{R}^{N_f\\times N_f}\\;$，该矩阵使用面上的磁阻率对通量分量进行加权：\n  $$\n  K_{f,f}=\\nu_f\\,A_f,\\quad \\nu_f=\\frac{1}{\\mu_f},\n  $$\n  其中，面磁阻率$\\;\\nu_f\\;$由单元的$\\;\\mu\\;$值构建如下：\n  - 如果面$\\;f\\;$是与单个单元$\\;T\\;$相邻的边界面，则设置$\\;\\mu_f=\\mu_T\\;$。\n  - 如果面$\\;f\\;$是内部面，并由单元$\\;T_a\\;$和$\\;T_b\\;$共享，则将$\\;\\mu_f\\;$设置为$\\;\\mu_{T_a}\\;$和$\\;\\mu_{T_b}\\;$的调和平均值，即\n    $$\n    \\mu_f=\\frac{2}{\\frac{1}{\\mu_{T_a}}+\\frac{1}{\\mu_{T_b}}},\\quad \\nu_f=\\frac{1}{\\mu_f}.\n    $$\n- 设$\\;f\\in\\mathbb{R}^{N_f}\\;$为给定的面源向量（无量纲）。在没有约束的情况下，无约束最小化器为$\\;b_0=K^{-1}f\\;$，其离散散度通常不为零，即$\\;D\\,b_0\\neq 0\\;$。\n- 带约束的鞍点系统为\n  $$\n  \\begin{pmatrix}\n  K & D^\\top \\\\\n  D & 0\n  \\end{pmatrix}\n  \\begin{pmatrix}\n  b \\\\\n  p\n  \\end{pmatrix}\n  =\n  \\begin{pmatrix}\n  f \\\\\n  0\n  \\end{pmatrix},\n  $$\n  其中$\\;p\\in\\mathbb{R}^{N_c}\\;$是强制执行$\\;D\\,b=0\\;$的拉格朗日乘子。\n\n算法要求：\n- 组装$\\;D\\;$、$\\;K\\;$，并计算$\\;b_0\\;$及其散度$\\;D\\,b_0\\;$。\n- 使用舒尔补求解鞍点系统：\n  $$\n  S\\;p = D\\,K^{-1}\\,f,\\quad S=D\\,K^{-1}\\,D^\\top,\\quad b=K^{-1}\\big(f-D^\\top p\\big),\n  $$\n  其中$K^{-1}$是$K$的对角逆矩阵。验证$\\;D\\,b\\;$（在数值舍入误差范围内）为零向量。\n\n测试套件：\n- 使用上述网格并定义三组参数：\n  $1.$ 均匀情况：对于单元$\\;T_0,T_1\\;$，$\\;\\mu=[1,1]\\;$，源向量定义为边界面$\\;f_f=1\\;$，内部面$\\;f_f=0\\;$。\n  $2.$ 非均匀情况：$\\;\\mu=[1,4]\\;$，使用相同的源向量规则，即边界面$\\;f_f=1\\;$，内部面$\\;f_f=0\\;$。\n  $3.$ 零源情况：$\\;\\mu=[1,1]\\;$且所有面的$\\;f_f=0\\;$。\n- 对于每种情况，计算两个量：\n  - 两个单元中无约束离散散度的最大绝对值$\\;\\max\\lvert D\\,b_0\\rvert\\;$。\n  - 两个单元中带约束离散散度的最大绝对值$\\;\\max\\lvert D\\,b\\rvert\\;$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表项按情况排序如下\n  $$\n  \\big[\\max\\lvert D\\,b_0\\rvert,\\;\\max\\lvert D\\,b\\rvert\\big]_{\\text{情况 }1},\\;\\big[\\max\\lvert D\\,b_0\\rvert,\\;\\max\\lvert D\\,b\\rvert\\big]_{\\text{情况 }2},\\;\\big[\\max\\lvert D\\,b_0\\rvert,\\;\\max\\lvert D\\,b\\rvert\\big]_{\\text{情况 }3}.\n  $$\n也就是说，最终输出应为包含$6$个浮点数的单个列表：$\\;[\\text{before}_1,\\text{after}_1,\\text{before}_2,\\text{after}_2,\\text{before}_3,\\text{after}_3]\\;$。\n\n本问题中所有量都是无量纲的，因此不需要进行物理单位转换。请通过使用所描述的几何结构和组装方法确保科学真实性，并且不要引入超出上述定义的任何人造或非物理系数。", "solution": "该问题要求在简单的四面体网格上，为静磁学问题构建并求解一个离散鞍点系统。该方法采用有限体积离散化，其中磁通量与网格面相关联，而与网格单元（四面体）相关联的拉格朗日乘子则用于强制执行磁通密度的无散约束。求解过程将遵循问题陈述中概述的精确几何和代数步骤来实现。\n\n首先，我们定义网格几何结构。该网格由$N_c=2$个四面体（$T_0$和$T_1$）组成，这些四面体由$5$个顶点（$v_0$到$v_4$）构建。根据四面体的定义$T_0=(v_0,v_1,v_2,v_3)$和$T_1=(v_1,v_2,v_3,v_4)$，我们可以识别出唯一的三角形面集。一个四面体有4个面。列出两个四面体的所有面后发现，它们共享一个公共面$(v_1,v_2,v_3)$。因此，整个网格共有$N_f=7$个唯一的面。我们通过按升序存储每个面的顶点索引来为其建立一个规范表示。这给出了面集：$f_0=(0,1,2)$，$f_1=(0,1,3)$，$f_2=(0,2,3)$，$f_3=(1,2,3)$，$f_4=(1,2,4)$，$f_5=(1,3,4)$和$f_6=(2,3,4)$。面$f_3$是内部面，其余6个是边界面。\n\n接下来，我们计算每个面和单元所需的几何量。对于每个面$f$，我们将其质心$c_f$计算为其三个顶点的算术平均值。对于每个面，通过对其按索引排序的顶点所派生的两条边向量进行叉积，可以计算出一个全局定向的、未归一化的法向量$n_f$。面的面积$A_f$是该法向量模长的一半，即 $A_f = \\frac{1}{2} \\|n_f\\|$。类似地，每个四面体单元$T$的质心$c_T$是其四个顶点的算术平均值。\n\n有了这些几何量，我们就可以组装离散散度矩阵$D \\in \\mathbb{R}^{2 \\times 7}$。其元素$D_{T,f}$定义为$D_{T,f}=\\operatorname{sign}(n_f\\cdot(c_f-c_T))$。这个定义确保了对于任意内部面，其法线相对于两个相邻单元的指向是相反的，这对应于物理上通量从一个单元流出并流入另一个单元。\n\n然后，我们构建对角矩阵$K \\in \\mathbb{R}^{7 \\times 7}$。其对角元素$K_{f,f} = \\nu_f A_f = A_f / \\mu_f$。对于边界面，$\\mu_f$等于其所属单元的$\\mu$值。对于单元$T_a$和$T_b$共享的内部面，$\\mu_f$使用调和平均值计算，以确保磁通量的连续性。$K$的逆矩阵$K^{-1}$也是一个对角矩阵，其对角元素为$1/K_{f,f}$。\n\n源向量$f \\in \\mathbb{R}^7$根据问题描述进行组装。对于情况1和2，边界面上的源为1，内部面为0。对于情况3，所有源均为0。\n\n求解过程使用舒尔补方法：\n1.  **无约束解**：首先，计算忽略约束时的解$b_0 = K^{-1}f$。计算其离散散度$d_0 = D b_0$。这个散度通常不为零。\n2.  **舒尔补系统**：构建舒尔补算子$S = D K^{-1} D^\\top$。这是一个$2 \\times 2$的矩阵。然后求解关于拉格朗日乘子$p$的线性系统 $S p = d_0$。\n3.  **约束解**：一旦求得$p$，就可以校正磁通量以满足约束条件：$b = b_0 - K^{-1}D^\\top p$。\n4.  **验证**：最后，计算校正后磁通量的散度$D b$。根据代数推导，$D b = D(b_0 - K^{-1}D^\\top p) = D b_0 - (D K^{-1} D^\\top) p = d_0 - S p = d_0 - d_0 = 0$。因此，在数值精度范围内，$D b$应该为零向量。\n\n最终的输出值是通过对每个测试用例执行此过程，并分别报告无约束散度$\\max|d_0|$和约束散度$\\max|Db|$的最大绝对值来获得的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and solves a magnetostatic saddle-point problem on a fixed\n    tetrahedral mesh for three different test cases.\n    \"\"\"\n\n    def setup_geometry():\n        \"\"\"\n        Defines the mesh vertices, tetrahedra, and faces.\n        Returns canonical lists and mappings for geometric entities.\n        \"\"\"\n        vertices = np.array([\n            [0, 0, 0],  # v0\n            [1, 0, 0],  # v1\n            [0, 1, 0],  # v2\n            [0, 0, 1],  # v3\n            [1, 1, 1],  # v4\n        ], dtype=float)\n\n        tets = np.array([[0, 1, 2, 3], [1, 2, 3, 4]], dtype=int)\n\n        tet_faces = [\n            [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)],  # Faces of T0\n            [(1, 2, 4), (1, 3, 4), (2, 3, 4), (1, 2, 3)],  # Faces of T1\n        ]\n        \n        unique_faces_set = set()\n        for i_tet, tet in enumerate(tet_faces):\n            for face_verts in tet:\n                unique_faces_set.add(tuple(sorted(face_verts)))\n        \n        # Create a canonical ordering of faces\n        faces = sorted(list(unique_faces_set))\n        face_map = {face: i for i, face in enumerate(faces)}\n\n        face_to_cell_map = [[] for _ in range(len(faces))]\n        for i_tet, tet_face_list in enumerate(tet_faces):\n            for face_verts in tet_face_list:\n                face_id = face_map[tuple(sorted(face_verts))]\n                if i_tet not in face_to_cell_map[face_id]:\n                    face_to_cell_map[face_id].append(i_tet)\n\n        return vertices, tets, faces, face_to_cell_map\n\n    def compute_geometric_quantities(vertices, faces, tets):\n        \"\"\"\n        Computes face centroids, normals, areas, and cell centroids.\n        \"\"\"\n        num_faces = len(faces)\n        num_cells = len(tets)\n\n        face_centroids = np.zeros((num_faces, 3))\n        face_normals = np.zeros((num_faces, 3))\n        face_areas = np.zeros(num_faces)\n        for i, face_indices in enumerate(faces):\n            v = vertices[list(face_indices)]\n            face_centroids[i] = np.mean(v, axis=0)\n            \n            # Normal from cross product of edges based on sorted vertex indices\n            e1 = v[1] - v[0]\n            e2 = v[2] - v[0]\n            normal = np.cross(e1, e2)\n            face_normals[i] = normal\n            face_areas[i] = 0.5 * np.linalg.norm(normal)\n\n        cell_centroids = np.zeros((num_cells, 3))\n        for i, tet_indices in enumerate(tets):\n            cell_centroids[i] = np.mean(vertices[tet_indices], axis=0)\n\n        return face_centroids, face_normals, face_areas, cell_centroids\n\n    def assemble_divergence_matrix(num_cells, num_faces, faces, tets, face_to_cell_map, face_normals, face_centroids, cell_centroids):\n        \"\"\"\n        Assembles the discrete divergence matrix D.\n        \"\"\"\n        D = np.zeros((num_cells, num_faces))\n        for i_face in range(num_faces):\n            for i_cell in face_to_cell_map[i_face]:\n                # D_T,f = sign(n_f . (c_f - c_T))\n                vec_cf_ct = face_centroids[i_face] - cell_centroids[i_cell]\n                D[i_cell, i_face] = np.sign(np.dot(face_normals[i_face], vec_cf_ct))\n        return D\n\n    def run_simulation(case_params, D, face_areas, face_to_cell_map):\n        \"\"\"\n        Runs one simulation case: assembles K, f, solves, and returns results.\n        \"\"\"\n        num_faces = D.shape[1]\n        mu_cells = case_params['mu']\n        \n        # Assemble diagonal K matrix\n        K_diag = np.zeros(num_faces)\n        for i_face in range(num_faces):\n            adj_cells = face_to_cell_map[i_face]\n            if len(adj_cells) == 1: # Boundary face\n                mu_face = mu_cells[adj_cells[0]]\n            else: # Interior face\n                mu_face = 2.0 / (1.0/mu_cells[adj_cells[0]] + 1.0/mu_cells[adj_cells[1]])\n            \n            nu_face = 1.0 / mu_face\n            K_diag[i_face] = nu_face * face_areas[i_face]\n        \n        # Assemble source vector f\n        f_vec = np.zeros(num_faces)\n        if case_params['source'] == 'boundary':\n            for i_face in range(num_faces):\n                if len(face_to_cell_map[i_face]) == 1:\n                    f_vec[i_face] = 1.0\n        # For 'zero' source, f_vec remains zero.\n\n        # Unconstrained solution and its divergence\n        # Handle cases where K might have zero diagonals (if area is zero)\n        K_inv_diag = np.zeros_like(K_diag)\n        non_zero_mask = K_diag != 0\n        K_inv_diag[non_zero_mask] = 1.0 / K_diag[non_zero_mask]\n\n        b0 = K_inv_diag * f_vec\n        div_b0 = D @ b0\n        max_abs_div_b0 = np.max(np.abs(div_b0)) if div_b0.size > 0 else 0.0\n\n        # Solve saddle-point system using Schur complement\n        # S p = D K^-1 f\n        # S = D K^-1 D^T\n        S = D @ np.diag(K_inv_diag) @ D.T\n        rhs_p = D @ b0\n\n        # Handle trivial case f=0\n        if np.all(np.abs(rhs_p)  1e-15):\n            p = np.zeros(D.shape[0])\n        else:\n            p = np.linalg.solve(S, rhs_p)\n\n        # Back-substitute for b\n        # b = K^-1 (f - D^T p)\n        b = K_inv_diag * (f_vec - D.T @ p)\n        div_b = D @ b\n        max_abs_div_b = np.max(np.abs(div_b)) if div_b.size > 0 else 0.0\n        \n        return max_abs_div_b0, max_abs_div_b\n\n    # --- Main execution logic ---\n    \n    # 1. Setup mesh and geometry\n    vertices, tets, faces, face_to_cell_map = setup_geometry()\n    face_centroids, face_normals, face_areas, cell_centroids = compute_geometric_quantities(vertices, faces, tets)\n    \n    num_cells = len(tets)\n    num_faces = len(faces)\n    \n    # 2. Assemble divergence matrix D\n    D = assemble_divergence_matrix(num_cells, num_faces, faces, tets, face_to_cell_map, face_normals, face_centroids, cell_centroids)\n\n    # 3. Define and run test cases\n    test_cases = [\n        {'mu': [1.0, 1.0], 'source': 'boundary'},  # Case 1\n        {'mu': [1.0, 4.0], 'source': 'boundary'},  # Case 2\n        {'mu': [1.0, 1.0], 'source': 'zero'},      # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        b0_div, b_div = run_simulation(case, D, face_areas, face_to_cell_map)\n        results.extend([b0_div, b_div])\n\n    # 4. Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3525101"}]}