{"hands_on_practices": [{"introduction": "任何砂浆方法的核心都是“砂浆矩阵”，它负责在不匹配的网格之间传递信息。本次实践将聚焦于为简单的一维情形构建此矩阵这一基本任务。通过在重叠的单元上实现解析积分，我们强调了数值鲁棒性和精确性的重要性，这是进入更复杂场景前必须掌握的关键一步 ([@problem_id:3515676])。", "problem": "考虑一个在多物理场耦合模拟中出现的一维界面耦合问题，其中在界面的两侧使用不匹配的网格，通过带有拉格朗日乘子的 mortar 方法来施加弱连续性。该界面是实数线上的闭区间 $[0,L]$，其中 $L>0$。界面的每一侧都使用有限元法（FEM）独立进行离散化，基函数是建立在严格递增节点向量上的连续分段线性（帽状）基函数。一侧标记为“从”（slave），另一侧为“主”（master）。设从节点为 $x^{S}_0,\\dots,x^{S}_{n_S}$，其中 $x^{S}_0=0$ 且 $x^{S}_{n_S}=L$；主节点为 $x^{M}_0,\\dots,x^{M}_{n_M}$，其中 $x^{M}_0=0$ 且 $x^{M}_{n_M}=L$。在每一侧，基函数 $\\{N^{S}_i\\}_{i=0}^{n_S}$ 和 $\\{N^{M}_j\\}_{j=0}^{n_M}$ 在 $[0,L]$ 上构成单位分解，并在每个单元（连续节点之间的子区间）上是线性的。\n\n从界面上通过迹的 $L^2$ 配对施加的标准弱连续性要求出发，代数 mortar 耦合矩阵 $M\\in\\mathbb{R}^{(n_S+1)\\times(n_M+1)}$ 的元素由 $L^2$ 内积定义：\n$$\nM_{ij}=\\int_{0}^{L} N^{S}_i(x)\\,N^{M}_j(x)\\,\\mathrm{d}x,\\quad 0\\le i\\le n_S,\\;0\\le j\\le n_M.\n$$\n你的任务是以数值上稳健和精确的方式为分段线性基函数实现以下两个组件：\n- 一个相交检测算法，给定 $[0,L]$ 到单元 $[x^{S}_k,x^{S}_{k+1}]$ 和 $[x^{M}_\\ell,x^{M}_{\\ell+1}]$ 的两个划分，枚举出所有从单元和主单元对之间的非空重叠部分及其重叠区间。\n- 一个映射和积分例程，利用这些重叠部分，通过在每个重叠区间上计算线性基函数乘积的积分来精确地组装矩阵 $M$。不要使用数值求积；你必须对每个重叠区间上两个线性函数相乘产生的最多二次多项式使用精确的解析积分。\n\n仅使用以下基本依据来指导你的推导和实现：\n- $L^2$ 内积的定义及其线性等基本性质。\n- 一维网格上分段线性帽状函数的定义和单位分解性质。\n- 对于整数 $p\\ge 0$ 的单项式 $x^p$ 的基本多项式积分恒等式。\n\n程序随后必须为一组给定的测试用例验证以下两个源于单位分解性质且对于正确组装 $M$ 必须成立的恒等式：\n- 对于每个从节点索引 $i$，行和恒等式\n$$\n\\sum_{j=0}^{n_M} M_{ij}=\\int_0^L N^{S}_i(x)\\,\\mathrm{d}x,\n$$\n以及对于每个主节点索引 $j$，列和恒等式\n$$\n\\sum_{i=0}^{n_S} M_{ij}=\\int_0^L N^{M}_j(x)\\,\\mathrm{d}x.\n$$", "solution": "用户提供的问题是偏微分方程数值方法领域中一个明确定义的任务，具体涉及为耦合具有不匹配网格的子域而实现的 mortar 方法。所有提供的定义、公式和测试用例在科学上都是合理、完整且一致的。因此，该问题被视为**有效**。我们继续提供完整解答。\n\n主要目标是为域 $[0,L]$ 上的一维界面问题计算 mortar 耦合矩阵 $M \\in \\mathbb{R}^{(n_S+1)\\times(n_M+1)}$。该矩阵的元素由从基函数和主基函数的 $L^2$ 内积定义：\n$$\nM_{ij} = \\int_{0}^{L} N^{S}_i(x)\\,N^{M}_j(x)\\,\\mathrm{d}x\n$$\n其中 $\\{N^{S}_i(x)\\}$ 和 $\\{N^{M}_j(x)\\}$ 分别是在从网格和主网格上定义的连续分段线性（帽状）基函数集。\n\n任务的核心是精确地（在浮点精度范围内）计算这些积分，而不使用像 Gauss-Legendre 这样的数值求积法则。这是可以实现的，因为两个线性多项式的乘积是一个二次多项式，可以进行解析积分。\n\n解决方案分三个阶段展开：\n1.  一个识别从网格单元和主网格单元之间所有重叠区域的算法。\n2.  一种在每个重叠区域上对基函数乘积进行精确符号积分的方法。\n3.  聚合这些局部积分以组装全局矩阵 $M$，然后进行验证步骤。\n\n### 1. 网格的相交\n在整个域 $[0,L]$ 上的积分可以分解为在更小区间上的积分之和。这些区间的自然选择是从单元与主单元的非空交集的集合。设从网格的节点为 $x^{S}_0, \\dots, x^{S}_{n_S}$，定义单元 $E_k^S = [x_k^S, x_{k+1}^S]$，其中 $k = 0, \\dots, n_S-1$。类似地，主网格的节点为 $x^{M}_0, \\dots, x^{M}_{n_M}$，定义单元 $E_\\ell^M = [x_\\ell^M, x_{\\ell+1}^M]$，其中 $\\ell = 0, \\dots, n_M-1$。$M_{ij}$ 的积分可以写成：\n$$\nM_{ij} = \\sum_{k=0}^{n_S-1} \\sum_{\\ell=0}^{n_M-1} \\int_{E_k^S \\cap E_\\ell^M} N^{S}_i(x)\\,N^{M}_j(x)\\,\\mathrm{d}x\n$$\n这是因为所有交集 $E_k^S \\cap E_\\ell^M$ 的并集构成了域 $[0,L]$ 的一个划分。\n\n为了高效地找到所有非空交集，我们采用一种“拉链”或“合并”算法。由于两个网格的节点都已排序，我们可以使用两个指针（$k$ 用于从单元索引，$\\ell$ 用于主单元索引）同时遍历从单元和主单元。\n\n算法流程如下：\n- 初始化指针 $k=0$ 和 $\\ell=0$。\n- 当 $k  n_S$ 且 $\\ell  n_M$ 时：\n    1.  考虑当前从单元 $E_k^S = [x_k^S, x_{k+1}^S]$ 和主单元 $E_\\ell^M = [x_\\ell^M, x_{\\ell+1}^M]$。\n    2.  计算相交区间 $[a,b]$，其中 $a = \\max(x_k^S, x_\\ell^M)$ 且 $b = \\min(x_{k+1}^S, x_{\\ell+1}^M)$。\n    3.  如果 $a  b$，则相交区间非空。在此区间上执行积分，并将结果累加到相应的矩阵元素中（见下文）。\n    4.  通过比较单元的右端点来推进指针：\n        - 如果 $x_{k+1}^S  x_{\\ell+1}^M$，则推进从指针：$k \\leftarrow k+1$。\n        - 如果 $x_{\\ell+1}^M  x_{k+1}^S$，则推进主指针：$\\ell \\leftarrow \\ell+1$。\n        - 如果 $x_{k+1}^S = x_{\\ell+1}^M$，则同时推进两个指针：$k \\leftarrow k+1, \\ell \\leftarrow \\ell+1$。\n\n### 2. 重叠区间上的解析积分\n在任何重叠区间 $[a,b]$ 上，一个与从单元 $E_k^S$ 相关的非零基函数（$N_k^S$ 或 $N_{k+1}^S$）是一个线性函数。同样，与主单元 $E_\\ell^M$ 相关的非零基函数（$N_\\ell^M$ 或 $N_{\\ell+1}^M$）也是线性的。它们的乘积是一个次数最多为 2 的多项式。虽然我们可以通过找到这个二次多项式的系数并使用 $\\int (c_2 x^2 + c_1 x + c_0) \\mathrm{d}x$ 来进行积分，但有一种更稳健、更优雅的方法，它使用了在区间端点处的函数值。\n\n对于区间 $[a,b]$ 上的两个线性函数 $f(x)$ 和 $g(x)$，它们的乘积的精确积分由以下公式给出：\n$$\n\\int_a^b f(x)g(x)\\,\\mathrm{d}x = \\frac{b-a}{6} \\left[ \\left(2f(a) + f(b)\\right)g(a) + \\left(f(a) + 2f(b)\\right)g(b) \\right]\n$$\n这个公式可以通过使用辛普森法则推导得出，由于被积函数是二次的，辛普森法则是精确的。\n\n### 3. 矩阵组装和验证\n完整的 mortar 矩阵 $M$ 通过初始化一个零矩阵，然后遍历所有重叠的从-主单元对来组装。对于每个重叠区间 $[a,b] = E_k^S \\cap E_\\ell^M$，有四个非零的基函数乘积需要考虑：$N_k^S N_\\ell^M$，$N_k^S N_{\\ell+1}^M$，$N_{k+1}^S N_\\ell^M$ 和 $N_{k+1}^S N_{\\ell+1}^M$。\n\n对于每个这样的乘积，我们使用上述解析积分公式计算积分，并将结果累加到 $M$ 的相应元素中：\n- $\\int_a^b N_k^S N_\\ell^M \\mathrm{d}x$ 累加到 $M_{k,\\ell}$。\n- $\\int_a^b N_k^S N_{\\ell+1}^M \\mathrm{d}x$ 累加到 $M_{k,\\ell+1}$。\n- $\\int_a^b N_{k+1}^S N_\\ell^M \\mathrm{d}x$ 累加到 $M_{k+1,\\ell}$。\n- $\\int_a^b N_{k+1}^S N_{\\ell+1}^M \\mathrm{d}x$ 累加到 $M_{k+1,\\ell+1}$。\n\n组装完成后，我们通过检查行和与列和的恒等式来验证矩阵。\n- **行和验证**：对于每一行 $i$，我们计算 $\\sum_{j=0}^{n_M} M_{ij}$，并将其与 $\\int_0^L N_i^S(x)\\,\\mathrm{d}x$ 进行比较。帽状函数 $N_i^S$ 的积分是其所代表的“三角形”的面积。对于一个内部节点 $x_i^S$，该积分为 $0.5 \\times (x_{i+1}^S - x_{i-1}^S)$。\n- **列和验证**：类似地，对于每一列 $j$，我们计算 $\\sum_{i=0}^{n_S} M_{ij}$，并将其与 $\\int_0^L N_j^M(x)\\,\\mathrm{d}x$ 进行比较。\n\n这些恒等式源于单位分解性质，即 $\\sum_{j=0}^{n_M} N_j^M(x) = 1$ 对于所有 $x \\in [0,L]$ 均成立。因此，\n$$\n\\sum_{j=0}^{n_M} M_{ij} = \\sum_{j=0}^{n_M} \\int_0^L N_i^S(x) N_j^M(x)\\,\\mathrm{d}x = \\int_0^L N_i^S(x) \\left(\\sum_{j=0}^{n_M} N_j^M(x)\\right) \\mathrm{d}x = \\int_0^L N_i^S(x) \\cdot 1 \\,\\mathrm{d}x\n$$\n列和的推导也是类似的。如果计算出的和与解析积分在浮点容差范围内匹配，则实现被认为是正确的。", "answer": "```python\nimport numpy as np\n\ndef assemble_mortar_matrix(slave_nodes, master_nodes, L):\n    \"\"\"\n    Assembles the 1D mortar coupling matrix M for non-matching meshes.\n\n    M_ij = integral(N_i^S * N_j^M) over [0, L].\n    \"\"\"\n    n_S = len(slave_nodes) - 1\n    n_M = len(master_nodes) - 1\n    M = np.zeros((n_S + 1, n_M + 1))\n\n    k = 0  # Slave element index\n    l = 0  # Master element index\n\n    while k  n_S and l  n_M:\n        xS_k, xS_k1 = slave_nodes[k], slave_nodes[k+1]\n        xM_l, xM_l1 = master_nodes[l], master_nodes[l+1]\n\n        # Find intersection of slave element k and master element l\n        a = max(xS_k, xM_l)\n        b = min(xS_k1, xM_l1)\n\n        if a  b:\n            # Non-empty overlap [a, b]\n            # Element lengths\n            h_S = xS_k1 - xS_k\n            h_M = xM_l1 - xM_l\n\n            # Evaluate basis functions at endpoints of the overlap interval\n            # Slave basis functions related to element k\n            NS_k_a = (xS_k1 - a) / h_S\n            NS_k_b = (xS_k1 - b) / h_S\n            NS_k1_a = (a - xS_k) / h_S\n            NS_k1_b = (b - xS_k) / h_S\n\n            # Master basis functions related to element l\n            NM_l_a = (xM_l1 - a) / h_M\n            NM_l_b = (xM_l1 - b) / h_M\n            NM_l1_a = (a - xM_l) / h_M\n            NM_l1_b = (b - xM_l) / h_M\n\n            delta = b - a\n\n            # Define a helper for the exact integral formula\n            # integral(f*g) on [a,b] = (b-a)/6 * [ (2f(a)+f(b))g(a) + (f(a)+2f(b))g(b) ]\n            def exact_integral(fa, fb, ga, gb):\n                return (delta / 6.0) * ((2.0 * fa + fb) * ga + (fa + 2.0 * fb) * gb)\n\n            # Add contributions to the four relevant matrix entries\n            # (i, j) = (k, l)\n            M[k, l] += exact_integral(NS_k_a, NS_k_b, NM_l_a, NM_l_b)\n            # (i, j) = (k, l+1)\n            M[k, l + 1] += exact_integral(NS_k_a, NS_k_b, NM_l1_a, NM_l1_b)\n            # (i, j) = (k+1, l)\n            M[k + 1, l] += exact_integral(NS_k1_a, NS_k1_b, NM_l_a, NM_l_b)\n            # (i, j) = (k+1, l+1)\n            M[k + 1, l + 1] += exact_integral(NS_k1_a, NS_k1_b, NM_l1_a, NM_l1_b)\n\n        # Advance pointers in the zipper-like traversal\n        if xS_k1  xM_l1:\n            k += 1\n        elif xM_l1  xS_k1:\n            l += 1\n        else: # xS_k1 == xM_l1\n            k += 1\n            l += 1\n    \n    return M\n\ndef verify_identities(M, slave_nodes, master_nodes, L, tol):\n    \"\"\"\n    Verifies the row-sum and column-sum identities for the mortar matrix.\n    \"\"\"\n    n_S = len(slave_nodes) - 1\n    n_M = len(master_nodes) - 1\n\n    # --- Verify Row Sums ---\n    computed_row_sums = np.sum(M, axis=1)\n    analytical_slave_integrals = np.zeros(n_S + 1)\n    for i in range(n_S + 1):\n        integral = 0.0\n        if i > 0:\n            integral += 0.5 * (slave_nodes[i] - slave_nodes[i-1])\n        if i  n_S:\n            integral += 0.5 * (slave_nodes[i+1] - slave_nodes[i])\n        analytical_slave_integrals[i] = integral\n    \n    max_row_discrepancy = np.max(np.abs(computed_row_sums - analytical_slave_integrals))\n    row_sum_ok = max_row_discrepancy = tol\n\n    # --- Verify Column Sums ---\n    computed_col_sums = np.sum(M, axis=0)\n    analytical_master_integrals = np.zeros(n_M + 1)\n    for j in range(n_M + 1):\n        integral = 0.0\n        if j > 0:\n            integral += 0.5 * (master_nodes[j] - master_nodes[j-1])\n        if j  n_M:\n            integral += 0.5 * (master_nodes[j+1] - master_nodes[j])\n        analytical_master_integrals[j] = integral\n        \n    max_col_discrepancy = np.max(np.abs(computed_col_sums - analytical_master_integrals))\n    col_sum_ok = max_col_discrepancy = tol\n    \n    return row_sum_ok and col_sum_ok\n\n\ndef solve():\n    \"\"\"\n    Main solver function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (1.0, np.array([0.0, 0.2, 0.5, 1.0]), np.array([0.0, 0.3, 0.7, 1.0])),\n        (1.0, np.array([0.0, 0.5, 1.0]), np.array([0.0, 0.5, 1.0])),\n        (1.0, np.array([0.0, 0.0001, 0.4, 1.0]), np.array([0.0, 0.6, 0.9, 1.0])),\n        (1.0, np.array([0.0, 0.25, 0.5, 0.75, 1.0]), np.array([0.0, 0.1, 0.2, 0.6, 1.0])),\n        (1.0, np.array([0.0, 0.4, 1.0]), np.array([0.0, 0.4, 0.6, 1.0])),\n    ]\n\n    tolerance = 1e-12\n    results = []\n\n    for L, slave_nodes, master_nodes in test_cases:\n        mortar_matrix = assemble_mortar_matrix(slave_nodes, master_nodes, L)\n        is_valid = verify_identities(mortar_matrix, slave_nodes, master_nodes, L, tolerance)\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3515676"}, {"introduction": "在构建了耦合矩阵之后，下一个合理的步骤是验证整个方法的行为是否正确。本次实践引入了“分片检验”(patch test)，这是有限元分析中的一个基本概念。通过测试砂浆投影是否能精确地再现简单的多项式解（如常数和线性函数），我们可以对我们实现的正确性建立信心 ([@problem_id:3515713])。", "problem": "构造一个程序，用于验证在离散化同一界面的两个非匹配一维网格之间的砂浆投影的多项式斑片检验。物理界面是赋予标准勒贝格测度的闭区间 $\\left[0,1\\right]$。设主网格由节点 $\\left\\{x_i^{\\mathrm{M}}\\right\\}_{i=0}^{n_{\\mathrm{M}}}$ 定义，其中 $0 = x_0^{\\mathrm{M}}  x_1^{\\mathrm{M}}  \\cdots  x_{n_{\\mathrm{M}}}^{\\mathrm{M}} = 1$；从网格由节点 $\\left\\{x_j^{\\mathrm{S}}\\right\\}_{j=0}^{n_{\\mathrm{S}}}$ 定义，其中 $0 = x_0^{\\mathrm{S}}  x_1^{\\mathrm{S}}  \\cdots  x_{n_{\\mathrm{S}}}^{\\mathrm{S}} = 1$。在每个网格上，考虑由帽函数张成的标准连续分段线性有限元迹空间，在主网格上记为 $V_{\\mathrm{M}}$，在从网格上记为 $V_{\\mathrm{S}}$。\n\n砂浆投影定义如下：对于给定的函数 $u_{\\mathrm{S}} \\in V_{\\mathrm{S}}$，找到 $u_{\\mathrm{M}} \\in V_{\\mathrm{M}}$，使得\n$$\n\\int_{0}^{1} \\mu\\left(x\\right)\\,\\left(u_{\\mathrm{M}}\\left(x\\right) - u_{\\mathrm{S}}\\left(x\\right)\\right)\\,\\mathrm{d}x = 0 \\quad \\text{for all } \\mu \\in V_{\\mathrm{M}}.\n$$\n这是以 $V_{\\mathrm{M}}$ 为测试空间的 $L^2$ 正交性条件。令 $\\left\\{\\phi_i\\right\\}_{i=0}^{n_{\\mathrm{M}}}$ 表示 $V_{\\mathrm{M}}$ 的节点基，$\\left\\{\\psi_j\\right\\}_{j=0}^{n_{\\mathrm{S}}}$ 表示 $V_{\\mathrm{S}}$ 的节点基。如果 $u_{\\mathrm{M}} = \\sum_{i=0}^{n_{\\mathrm{M}}} U^{\\mathrm{M}}_i \\,\\phi_i$ 且 $u_{\\mathrm{S}} = \\sum_{j=0}^{n_{\\mathrm{S}}} U^{\\mathrm{S}}_j \\,\\psi_j$，则系数满足\n$$\n\\sum_{i=0}^{n_{\\mathrm{M}}} \\left(\\int_{0}^{1} \\phi_\\ell\\left(x\\right)\\,\\phi_i\\left(x\\right)\\,\\mathrm{d}x\\right) U^{\\mathrm{M}}_i\n=\n\\sum_{j=0}^{n_{\\mathrm{S}}} \\left(\\int_{0}^{1} \\phi_\\ell\\left(x\\right)\\,\\psi_j\\left(x\\right)\\,\\mathrm{d}x\\right) U^{\\mathrm{S}}_j\n\\quad \\text{for } \\ell = 0,\\ldots,n_{\\mathrm{M}}.\n$$\n定义主质量矩阵 $B \\in \\mathbb{R}^{\\left(n_{\\mathrm{M}}+1\\right)\\times\\left(n_{\\mathrm{M}}+1\\right)}$，其元素为\n$$\nB_{\\ell i} = \\int_{0}^{1} \\phi_\\ell\\left(x\\right)\\,\\phi_i\\left(x\\right)\\,\\mathrm{d}x,\n$$\n以及混合耦合矩阵 $C \\in \\mathbb{R}^{\\left(n_{\\mathrm{M}}+1\\right)\\times\\left(n_{\\mathrm{S}}+1\\right)}$，其元素为\n$$\nC_{\\ell j} = \\int_{0}^{1} \\phi_\\ell\\left(x\\right)\\,\\psi_j\\left(x\\right)\\,\\mathrm{d}x.\n$$\n则投影后的主网格系数满足\n$$\nB\\,U^{\\mathrm{M}} = C\\,U^{\\mathrm{S}}.\n$$\n\n从 $L^2$ 正交性和标准有限元基函数的基本定义出发，实现非匹配网格的砂浆投影 $U^{\\mathrm{M}} = B^{-1} C \\, U^{\\mathrm{S}}$。所有积分必须在由两个网格的组合单元边界形成的联合剖分上，通过精确的多项式求积来计算；为保证稳健性，在此联合剖分的每个子区间上使用阶数 $\\geq 3$ 的高斯求积。\n\n通过斑片检验进行验证：\n- 常数斑片检验要求，如果对于某个常数 $\\alpha \\in \\mathbb{R}$，有 $u\\left(x\\right) = \\alpha$，则投影后的 $u_{\\mathrm{M}}$ 能精确再现 $u$。\n- 线性斑片检验要求，如果对于 $\\alpha,\\beta \\in \\mathbb{R}$，有 $u\\left(x\\right) = \\alpha + \\beta x$，则投影后的 $u_{\\mathrm{M}}$ 能精确再现 $u$。\n- 使用 $u\\left(x\\right)=x^2$ 的高阶验证会显示预期的非零误差，因为空间是分段线性的。\n\n您的程序必须：\n1. 按照描述为任意主网格和从网格组装 $B$ 和 $C$。\n2. 对于给定的精确函数 $u\\left(x\\right)$，设置 $U^{\\mathrm{S}}_j = u\\!\\left(x_j^{\\mathrm{S}}\\right)$，计算 $U^{\\mathrm{M}}$，并评估：\n   - $L^2$ 误差 $e_{2} = \\left(\\int_{0}^{1}\\left(u_{\\mathrm{M}}\\left(x\\right) - u\\left(x\\right)\\right)^2 \\mathrm{d}x\\right)^{1/2}$，使用相同的联合剖分和高斯求积。\n   - 节点无穷大误差 $e_{\\infty} = \\max_{0 \\le i \\le n_{\\mathrm{M}}} \\left|U^{\\mathrm{M}}_i - u\\!\\left(x_i^{\\mathrm{M}}\\right)\\right|$。\n3. 对于常数和线性斑片检验，如果 $e_{2} \\le \\varepsilon$ 和 $e_{\\infty} \\le \\varepsilon$（其中 $\\varepsilon = 10^{-10}$）同时满足，则返回一个表示通过的布尔值；对于二次函数情况，返回 $L^2$ 误差 $e_{2}$ 作为浮点数。\n\n测试套件：\n- 情况 1（线性斑片检验，通用非匹配网格）：\n  - 主网格节点：$\\left[0.0,\\,0.2,\\,0.5,\\,1.0\\right]$。\n  - 从网格节点：$\\left[0.0,\\,0.33,\\,0.66,\\,1.0\\right]$。\n  - 函数：$u\\left(x\\right) = 1.0 + 0.5\\,x$。\n  - 预期输出类型：布尔值。\n- 情况 2（常数斑片检验，从网格极端粗化）：\n  - 主网格节点：$\\left[0.0,\\,0.4,\\,0.7,\\,1.0\\right]$。\n  - 从网格节点：$\\left[0.0,\\,1.0\\right]$。\n  - 函数：$u\\left(x\\right) = 2.3$。\n  - 预期输出类型：布尔值。\n- 情况 3（二次函数验证）：\n  - 主网格节点：$\\left[0.0,\\,0.2,\\,0.4,\\,0.7,\\,1.0\\right]$。\n  - 从网格节点：$\\left[0.0,\\,0.6,\\,1.0\\right]$。\n  - 函数：$u\\left(x\\right) = x^2$。\n  - 预期输出类型：浮点型 $L^2$ 误差。\n- 情况 4（线性斑片检验，高度非匹配网格）：\n  - 主网格节点：$\\left[0.0,\\,0.1,\\,0.15,\\,0.5,\\,0.9,\\,1.0\\right]$。\n  - 从网格节点：$\\left[0.0,\\,1.0\\right]$。\n  - 函数：$u\\left(x\\right) = -0.2 + 3.0\\,x$。\n  - 预期输出类型：布尔值。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含按情况 1 到 4 的顺序排列的结果，形式为逗号分隔的列表并用方括号括起。例如，输出必须看起来像 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$。所有数字都是无量纲的，不涉及单位。布尔值必须显示为 $\\text{True}$ 或 $\\text{False}$，浮点值必须以标准十进制表示法打印。", "solution": "该任务是构建一个程序，用于实现和验证非匹配有限元网格上的一维砂浆投影。验证过程通过多项式斑片检验来执行。该解决方案基于有限元法和数值积分的基本原理进行开发。\n\n### 1. 数学公式\n问题设定在域 $\\Omega = [0, 1]$ 上。该域由两个独立的、非匹配的网格进行离散化：一个是由节点 $\\{x_i^{\\mathrm{M}}\\}_{i=0}^{n_{\\mathrm{M}}}$ 定义的主网格，另一个是由节点 $\\{x_j^{\\mathrm{S}}\\}_{j=0}^{n_{\\mathrm{S}}}$ 定义的从网格。在每个网格上，我们考虑标准的连续分段线性 (P1) 有限元空间。主空间 $V_{\\mathrm{M}}$ 由节点帽函数基 $\\{\\phi_i\\}_{i=0}^{n_{\\mathrm{M}}}$ 张成，其中 $\\phi_i(x_k^{\\mathrm{M}}) = \\delta_{ik}$（$\\delta_{ik}$ 是克罗内克 δ）。类似地，从空间 $V_{\\mathrm{S}}$ 由基 $\\{\\psi_j\\}_{j=0}^{n_{\\mathrm{S}}}$ 张成。\n\n问题的核心是砂浆投影，这是一种特定类型的 $L^2$ 投影。给定一个函数 $u_{\\mathrm{S}} \\in V_{\\mathrm{S}}$，我们寻求其在 $V_{\\mathrm{M}}$ 中的投影 $u_{\\mathrm{M}}$，使得残差 $(u_{\\mathrm{M}} - u_{\\mathrm{S}})$ 与主空间 $V_{\\mathrm{M}}$ 正交。这通过弱形式表达，它是伽辽金法的基石：\n$$\n\\int_{0}^{1} \\mu(x) \\left(u_{\\mathrm{M}}(x) - u_{\\mathrm{S}}(x)\\right) \\,\\mathrm{d}x = 0 \\quad \\text{for all } \\mu \\in V_{\\mathrm{M}}.\n$$\n\n### 2. 离散化与线性系统\n为了计算解决此问题，我们将函数 $u_{\\mathrm{M}}$ 和 $u_{\\mathrm{S}}$ 展开为其各自的基函数和未知/已知节点系数 $U^{\\mathrm{M}}$ 和 $U^{\\mathrm{S}}$ 的线性组合：\n$$\nu_{\\mathrm{M}}(x) = \\sum_{i=0}^{n_{\\mathrm{M}}} U^{\\mathrm{M}}_i \\,\\phi_i(x) \\quad \\text{and} \\quad u_{\\mathrm{S}}(x) = \\sum_{j=0}^{n_{\\mathrm{S}}} U^{\\mathrm{S}}_j \\,\\psi_j(x).\n$$\n通过将这些展开式代入弱形式，并对每个主基函数 $\\mu = \\phi_\\ell$（其中 $\\ell = 0, \\ldots, n_{\\mathrm{M}}$）进行测试，我们将积分方程转化为一个线性代数方程组：\n$$\n\\sum_{i=0}^{n_{\\mathrm{M}}} \\left(\\int_{0}^{1} \\phi_\\ell(x)\\,\\phi_i(x)\\,\\mathrm{d}x\\right) U^{\\mathrm{M}}_i\n=\n\\sum_{j=0}^{n_{\\mathrm{S}}} \\left(\\int_{0}^{1} \\phi_\\ell(x)\\,\\psi_j(x)\\,\\mathrm{d}x\\right) U^{\\mathrm{S}}_j.\n$$\n这就是矩阵系统 $B\\,U^{\\mathrm{M}} = C\\,U^{\\mathrm{S}}$，其中矩阵定义如下：\n- **主质量矩阵**：$B \\in \\mathbb{R}^{(n_{\\mathrm{M}}+1)\\times(n_{\\mathrm{M}}+1)}$，其元素为 $B_{\\ell i} = \\int_{0}^{1} \\phi_\\ell(x)\\,\\phi_i(x)\\,\\mathrm{d}x$。该矩阵是对称正定的，确保存在唯一解。\n- **耦合（混合）矩阵**：$C \\in \\mathbb{R}^{(n_{\\mathrm{M}}+1)\\times(n_{\\mathrm{S}}+1)}$，其元素为 $C_{\\ell j} = \\int_{0}^{1} \\phi_\\ell(x)\\,\\psi_j(x)\\,\\mathrm{d}x$。该矩阵将从网格的自由度耦合到主网格。\n\n### 3. 数值积分方案\n一个关键的实现细节是精确计算定义矩阵 $B$ 和 $C$ 的积分。被积函数涉及来自两个可能不匹配的网格的基函数的乘积。为了稳健地处理此问题，我们通过取主网格和从网格所有唯一节点坐标的集合，并按升序排序，形成一个**联合剖分** $\\{z_k\\}$。此剖分将域 $[0, 1]$ 分割为一系列子区间 $[z_k, z_{k+1}]$。\n\n在任何这样的子区间上，每个基函数（$\\phi_i$ 或 $\\psi_j$）都是一个简单的线性多项式。因此，对于 $B$ 或 $C$ 的任何元素的被积函数都是一个次数最多为 2 的多项式。总积分是这些子区间上积分的总和。每个子积分都使用**高斯求积**来计算。问题指定了求积阶数 $p \\ge 3$。一个 $p=3$ 点的求积法则对于次数最高为 $2p-1=5$ 的多项式是精确的，这对于此处的二次被积函数来说绰绰有余，保证了计算能达到机器精度。\n\n### 4. 通过斑片检验进行验证\n实现的正确性通过**斑片检验**来验证。斑片检验评估数值方法是否能够精确再现其理论上应能表示的解。对于我们的 P1 有限元基，空间 $V_{\\mathrm{M}}$ 和 $V_{\\mathrm{S}}$ 在其各自的网格上包含所有线性多项式。\n\n验证过程如下：\n1. 选择一个精确的解析函数 $u(x)$（例如，常数 $u(x)=\\alpha$ 或线性函数 $u(x)=\\alpha + \\beta x$）。\n2. 通过在从网格节点上对精确函数进行插值来确定从网格系数向量 $U^{\\mathrm{S}}$：$U^{\\mathrm{S}}_j = u(x_j^{\\mathrm{S}})$。\n3. 使用数值积分方案组装矩阵 $B$ 和 $C$。\n4. 求解线性系统 $B\\,U^{\\mathrm{M}} = C\\,U^{\\mathrm{S}}$ 以获得投影后的主网格节点系数 $U^{\\mathrm{M}}$。\n5. 使用两种误差范数将计算出的解 $u_{\\mathrm{M}}(x) = \\sum_i U^{\\mathrm{M}}_i \\phi_i(x)$ 与原始精确函数 $u(x)$ 进行比较：\n   - **节点无穷大误差**：$e_{\\infty} = \\max_{0 \\le i \\le n_{\\mathrm{M}}} |U^{\\mathrm{M}}_i - u(x_i^{\\mathrm{M}})|$。\n   - **$L^2$ 误差**：$e_{2} = \\left(\\int_{0}^{1}(u_{\\mathrm{M}}(x) - u(x))^2 \\mathrm{d}x\\right)^{1/2}$。$e_2^2$ 的积分也通过在联合剖分上进行高斯求积来计算。\n\n如果 $e_{\\infty}$ 和 $e_{2}$ 均低于一个小公差 $\\varepsilon = 10^{-10}$，则认为斑片检验“通过”。对于使用二次函数 $u(x)=x^2$ 的测试，该函数不能被 P1 元素精确表示，预计会出现非零误差，其 $L^2$ 范数 $e_2$ 将作为投影误差的度量被报告。", "answer": "```python\nimport numpy as np\n\n# Set up Gaussian quadrature rule. Order >= 3 is specified.\nQUAD_ORDER = 3\nQUAD_POINTS, QUAD_WEIGHTS = np.polynomial.legendre.leggauss(QUAD_ORDER)\nTOLERANCE = 1e-10\n\ndef hat_function(node_index, x, nodes):\n    \"\"\"\n    Evaluates the value of the 1D linear \"hat\" basis function.\n    The function is non-zero only on the elements adjacent to the node_index.\n    \"\"\"\n    num_nodes = len(nodes)\n    \n    # The hat function is 1 at nodes[node_index] and 0 at other nodes.\n    # It is piecewise linear between them.\n    \n    # Check left segment of the hat\n    if node_index > 0:\n        x_prev = nodes[node_index - 1]\n        x_curr = nodes[node_index]\n        if x_prev = x = x_curr:\n            h = x_curr - x_prev\n            # Avoid division by zero for coincident nodes, though problem implies they aren't.\n            return (x - x_prev) / h if h > 0 else 0.0\n    \n    # Check right segment of the hat\n    if node_index  num_nodes - 1:\n        x_curr = nodes[node_index]\n        x_next = nodes[node_index + 1]\n        if x_curr = x = x_next:\n            h = x_next - x_curr\n            return (x_next - x) / h if h > 0 else 0.0\n            \n    return 0.0\n\nclass MortarVerifier:\n    \"\"\"\n    Handles the assembly, solution, and verification for a single mortar projection case.\n    \"\"\"\n    def __init__(self, master_nodes, slave_nodes, u_exact_func, test_type):\n        self.master_nodes = np.array(master_nodes, dtype=float)\n        self.slave_nodes = np.array(slave_nodes, dtype=float)\n        self.nm = len(self.master_nodes)\n        self.ns = len(self.slave_nodes)\n        self.u_exact_func = u_exact_func\n        self.test_type = test_type\n\n        # Create the union partition for integration\n        union_nodes = np.unique(np.concatenate((self.master_nodes, self.slave_nodes)))\n        self.union_intervals = list(zip(union_nodes[:-1], union_nodes[1:]))\n\n    def _integrate(self, func):\n        \"\"\"\n        Numerically integrates a given function over the union partition\n        using Gaussian quadrature.\n        \"\"\"\n        total = 0.0\n        for a, b in self.union_intervals:\n            if a == b:\n                continue\n            \n            # Map quadrature points from [-1, 1] to [a, b]\n            mapped_points = 0.5 * (b - a) * QUAD_POINTS + 0.5 * (a + b)\n            jacobian = 0.5 * (b - a)\n            \n            func_values = np.array([func(p) for p in mapped_points])\n            total += jacobian * np.sum(QUAD_WEIGHTS * func_values)\n        \n        return total\n\n    def run_test(self):\n        \"\"\"\n        Executes the full pipeline: assemble, solve, and compute errors.\n        \"\"\"\n        # Assemble master mass matrix B\n        B = np.zeros((self.nm, self.nm))\n        for l in range(self.nm):\n            for i in range(self.nm):\n                # Optimization: B is tridiagonal\n                if abs(l - i) > 1:\n                    continue\n                integrand = lambda x: hat_function(l, x, self.master_nodes) * \\\n                                      hat_function(i, x, self.master_nodes)\n                B[l, i] = self._integrate(integrand)\n\n        # Assemble coupling matrix C\n        C = np.zeros((self.nm, self.ns))\n        for l in range(self.nm):\n            for j in range(self.ns):\n                integrand = lambda x: hat_function(l, x, self.master_nodes) * \\\n                                      hat_function(j, x, self.slave_nodes)\n                C[l, j] = self._integrate(integrand)\n\n        # Get slave coefficient vector U_S by interpolating exact function\n        U_S = np.array([self.u_exact_func(x) for x in self.slave_nodes])\n        \n        # Solve for projected master coefficients U_M\n        rhs = C @ U_S\n        U_M = np.linalg.solve(B, rhs)\n\n        # --- Error Calculation ---\n\n        # 1. Nodal infinity error\n        u_exact_at_master_nodes = np.array([self.u_exact_func(x) for x in self.master_nodes])\n        e_inf = np.max(np.abs(U_M - u_exact_at_master_nodes))\n\n        # 2. L2 error\n        def u_M_eval(x):\n            val = 0.0\n            for i in range(self.nm):\n                val += U_M[i] * hat_function(i, x, self.master_nodes)\n            return val\n        \n        error_integrand = lambda x: (u_M_eval(x) - self.u_exact_func(x))**2\n        e2_squared = self._integrate(error_integrand)\n        e2 = np.sqrt(e2_squared)\n\n        # --- Return result based on test type ---\n        if self.test_type == 'boolean':\n            return e2 = TOLERANCE and e_inf = TOLERANCE\n        elif self.test_type == 'float':\n            return e2\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"master_nodes\": [0.0, 0.2, 0.5, 1.0],\n            \"slave_nodes\": [0.0, 0.33, 0.66, 1.0],\n            \"u_func\": lambda x: 1.0 + 0.5 * x,\n            \"type\": \"boolean\"\n        },\n        {\n            \"master_nodes\": [0.0, 0.4, 0.7, 1.0],\n            \"slave_nodes\": [0.0, 1.0],\n            \"u_func\": lambda x: 2.3,\n            \"type\": \"boolean\"\n        },\n        {\n            \"master_nodes\": [0.0, 0.2, 0.4, 0.7, 1.0],\n            \"slave_nodes\": [0.0, 0.6, 1.0],\n            \"u_func\": lambda x: x**2,\n            \"type\": \"float\"\n        },\n        {\n            \"master_nodes\": [0.0, 0.1, 0.15, 0.5, 0.9, 1.0],\n            \"slave_nodes\": [0.0, 1.0],\n            \"u_func\": lambda x: -0.2 + 3.0 * x,\n            \"type\": \"boolean\"\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        verifier = MortarVerifier(\n            master_nodes=case[\"master_nodes\"],\n            slave_nodes=case[\"slave_nodes\"],\n            u_exact_func=case[\"u_func\"],\n            test_type=case[\"type\"]\n        )\n        result = verifier.run_test()\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3515713"}]}