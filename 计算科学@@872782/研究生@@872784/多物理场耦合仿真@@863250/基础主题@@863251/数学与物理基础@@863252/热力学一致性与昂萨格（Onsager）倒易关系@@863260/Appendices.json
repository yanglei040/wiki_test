{"hands_on_practices": [{"introduction": "在构建复杂的数值模型之前，对如何构成一个热力学上有效的本构矩阵有深入的理解至关重要。本练习提供了一种建立这种直觉的直接方法，即从一个特意构造的有缺陷的矩阵开始，然后对其进行修复。通过将一个无效的矩阵投影回物理上允许的矩阵空间，我们可以直接应用对称性和正半定性条件，并理解它们如何定义“正确”的物理行为。[@problem_id:3529609]", "problem": "考虑一个近平衡态的一维多物理场耦合系统，其具有两个慢场：内能密度和溶质浓度。在线性不可逆区域，通量矢量 $\\mathbf{J} = (J_{q}, J_{c})^{\\top}$ 通过线性本构关系 $\\mathbf{J} = \\mathbf{L}\\,\\mathbf{X}$ 与共轭热力学力 $\\mathbf{X} = (\\partial_{x}(1/T), \\partial_{x}(\\mu/T))^{\\top}$ 相关联，其中 $\\mathbf{L} \\in \\mathbb{R}^{2 \\times 2}$ 包含了热量和质量输运之间的交叉耦合项。熵产生率为 $\\sigma = \\mathbf{X}^{\\top}\\mathbf{J}$。\n\n从一个满足 Onsager 倒易关系和热力学一致性的基准本构矩阵开始，\n$$\n\\mathbf{L}_{\\mathrm{base}} = \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix},\n$$\n该矩阵具有一个简并矢量 $\\mathbf{g} = (1,1)^{\\top}$，使得 $\\mathbf{L}_{\\mathrm{base}}\\,\\mathbf{g} = \\mathbf{0}$。这与非平衡可逆-不可逆耦合通用方程 (GENERIC) 的简并条件一致，即不可逆算符会湮灭能量梯度。\n\n设计一个违反熵产生非负性 $\\sigma \\ge 0$ 和 Onsager 对称性的修正本构关系。为此，定义一个对称微扰\n$$\n\\Delta \\mathbf{S} = -\\frac{1}{2}\\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix},\n$$\n它将 $\\mathbf{L}_{\\mathrm{base}}$ 沿 $\\mathbf{g}$ 方向的零特征值移动到一个负值，并添加一个反对称微扰\n$$\n\\mathbf{N} = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix},\n$$\n使得修正后的本构矩阵为\n$$\n\\mathbf{L}_{\\mathrm{viol}} = \\mathbf{L}_{\\mathrm{base}} + \\Delta \\mathbf{S} + \\mathbf{N}.\n$$\n\n任务：\n- 仅使用线性不可逆热力学和第二定律的基本原理，评估在特定力 $\\mathbf{X} = \\mathbf{g}$ 和矩阵 $\\mathbf{L}_{\\mathrm{viol}}$ 下的熵产生 $\\sigma$，并确定其是否违反 $\\sigma \\ge 0$。\n- 通过将 $\\mathbf{L}_{\\mathrm{viol}}$ 修复为一个满足 Onsager 倒易关系（对称性）、半正定性和 GENERIC 简并约束 $\\mathbf{L}_{\\mathrm{rep}}\\,\\mathbf{g} = \\mathbf{0}$ 的矩阵 $\\mathbf{L}_{\\mathrm{rep}}$ 来强制实现热力学一致性。在所有此类修复中，选择与 $\\mathbf{L}_{\\mathrm{viol}}$ 的 Frobenius 范数距离最小的那个。\n- 提供修复后的矩阵 $\\mathbf{L}_{\\mathrm{rep}}$ 作为最终答案。请给出精确答案，不要四舍五入。", "solution": "该问题要求对一个旨在违反热力学原理的本构矩阵 $\\mathbf{L}_{\\mathrm{viol}}$ 进行两部分分析。首先，我们必须验证对于某个特定的热力学力，它确实会导致负的熵产生。其次，我们必须修复该矩阵，以找到一个满足所有热力学约束且在 Frobenius 范数意义下最接近 $\\mathbf{L}_{\\mathrm{viol}}$ 的新矩阵 $\\mathbf{L}_{\\mathrm{rep}}$。\n\n首先，我们显式地构建矩阵 $\\mathbf{L}_{\\mathrm{viol}}$。它被定义为三个矩阵之和：\n$\\mathbf{L}_{\\mathrm{viol}} = \\mathbf{L}_{\\mathrm{base}} + \\Delta \\mathbf{S} + \\mathbf{N}$\n根据定义：\n$\\mathbf{L}_{\\mathrm{base}} = \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$，$\\Delta \\mathbf{S} = -\\frac{1}{2}\\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{2}  -\\frac{1}{2} \\\\ -\\frac{1}{2}  -\\frac{1}{2} \\end{pmatrix}$，以及 $\\mathbf{N} = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$。\n将这些矩阵逐分量相加：\n$$\n\\mathbf{L}_{\\mathrm{viol}} = \\begin{pmatrix} 1 - \\frac{1}{2} + 0  -1 - \\frac{1}{2} + 1 \\\\ -1 - \\frac{1}{2} - 1  1 - \\frac{1}{2} + 0 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{2}  -\\frac{1}{2} \\\\ -\\frac{5}{2}  \\frac{1}{2} \\end{pmatrix}\n$$\n\n接下来，我们评估在热力学力矢量为 $\\mathbf{X} = \\mathbf{g} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 的特定情况下的熵产生率 $\\sigma = \\mathbf{X}^{\\top}\\mathbf{J} = \\mathbf{X}^{\\top}\\mathbf{L}\\mathbf{X}$。\n代入 $\\mathbf{L} = \\mathbf{L}_{\\mathrm{viol}}$ 和 $\\mathbf{X} = \\mathbf{g}$：\n$$\n\\sigma = \\mathbf{g}^{\\top} \\mathbf{L}_{\\mathrm{viol}} \\mathbf{g} = \\begin{pmatrix} 1  1 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2}  -\\frac{1}{2} \\\\ -\\frac{5}{2}  \\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}\n$$\n执行矩阵乘法：\n$$\n\\sigma = \\begin{pmatrix} 1  1 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{2}(1) - \\frac{1}{2}(1) \\\\ -\\frac{5}{2}(1) + \\frac{1}{2}(1) \\end{pmatrix} = \\begin{pmatrix} 1  1 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ -2 \\end{pmatrix} = (1)(0) + (1)(-2) = -2\n$$\n由于 $\\sigma = -2$，小于 $0$，因此矩阵 $\\mathbf{L}_{\\mathrm{viol}}$ 违反了热力学第二定律，该定律要求对于所有可能的力 $\\mathbf{X}$，熵产生都应为非负值，即 $\\sigma \\ge 0$。\n\n第二个任务是找到一个修复后的矩阵 $\\mathbf{L}_{\\mathrm{rep}}$，它在满足以下三个条件的前提下，最小化与 $\\mathbf{L}_{\\mathrm{viol}}$ 的 Frobenius 范数距离 $\\|\\mathbf{L}_{\\mathrm{rep}} - \\mathbf{L}_{\\mathrm{viol}}\\|_F$：\n1.  Onsager 倒易关系：$\\mathbf{L}_{\\mathrm{rep}}$ 必须是对称的，即 $\\mathbf{L}_{\\mathrm{rep}} = \\mathbf{L}_{\\mathrm{rep}}^{\\top}$。\n2.  热力学一致性：$\\mathbf{L}_{\\mathrm{rep}}$ 必须是半正定的 (PSD)，以确保对于所有 $\\mathbf{X}$ 都有 $\\sigma = \\mathbf{X}^{\\top}\\mathbf{L}_{\\mathrm{rep}}\\mathbf{X} \\ge 0$。\n3.  GENERIC 简并性：$\\mathbf{L}_{\\mathrm{rep}}\\mathbf{g} = \\mathbf{0}$，其中 $\\mathbf{g} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$。\n\n我们来描述满足这三个条件的矩阵集合。设 $\\mathbf{L}_{\\mathrm{rep}} = \\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}$。\n对称性条件要求 $b=c$。因此，$\\mathbf{L}_{\\mathrm{rep}} = \\begin{pmatrix} a  b \\\\ b  d \\end{pmatrix}$。\n简并性条件要求：\n$$\n\\mathbf{L}_{\\mathrm{rep}}\\mathbf{g} = \\begin{pmatrix} a  b \\\\ b  d \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a+b \\\\ b+d \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\n$$\n这得到 $a = -b$ 和 $d = -b$。因此，该矩阵必须具有以下形式：\n$$\n\\mathbf{L}_{\\mathrm{rep}} = \\begin{pmatrix} -b  b \\\\ b  -b \\end{pmatrix} = -b \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n令 $k = -b$。该矩阵为 $\\mathbf{L}_{\\mathrm{rep}} = k \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} = k \\mathbf{L}_{\\mathrm{base}}$。\n\n最后，半正定条件要求 $\\mathbf{L}_{\\mathrm{rep}}$ 的所有特征值都是非负的。$\\mathbf{L}_{\\mathrm{base}}$ 的特征值为 $\\lambda_1 = 0$ 和 $\\lambda_2 = 2$。因此，$\\mathbf{L}_{\\mathrm{rep}} = k \\mathbf{L}_{\\mathrm{base}}$ 的特征值为 $0$ 和 $2k$。为使矩阵是半正定的，我们必须有 $2k \\ge 0$，这意味着 $k \\ge 0$。\n\n所以，所有有效矩阵的集合是一个凸锥 $C = \\{ k \\mathbf{L}_{\\mathrm{base}} \\mid k \\ge 0 \\}$。问题是要找到 $\\mathbf{L}_{\\mathrm{viol}}$ 在该集合 $C$ 上的投影。投影是集合 $C$ 中使 Frobenius 范数距离最小化的矩阵。这是一个标准正交投影问题。将 $\\mathbf{L}_{\\mathrm{viol}}$ 投影到由 $\\mathbf{L}_{\\mathrm{base}}$ 张成的直线上的最优系数 $k$ 由以下公式给出：\n$$\nk = \\frac{\\langle \\mathbf{L}_{\\mathrm{viol}}, \\mathbf{L}_{\\mathrm{base}} \\rangle_F}{\\|\\mathbf{L}_{\\mathrm{base}}\\|_F^2}\n$$\n其中 $\\langle \\cdot, \\cdot \\rangle_F$ 是 Frobenius 内积（逐元素乘积之和）。\n我们来计算内积：\n$$\n\\langle \\mathbf{L}_{\\mathrm{viol}}, \\mathbf{L}_{\\mathrm{base}} \\rangle_F = \\sum_{i,j} (\\mathbf{L}_{\\mathrm{viol}})_{ij} (\\mathbf{L}_{\\mathrm{base}})_{ij} = (\\frac{1}{2})(1) + (-\\frac{1}{2})(-1) + (-\\frac{5}{2})(-1) + (\\frac{1}{2})(1)\n$$\n$$\n= \\frac{1}{2} + \\frac{1}{2} + \\frac{5}{2} + \\frac{1}{2} = \\frac{1+1+5+1}{2} = \\frac{8}{2} = 4\n$$\n接下来，我们计算 $\\mathbf{L}_{\\mathrm{base}}$ 的 Frobenius 范数的平方：\n$$\n\\|\\mathbf{L}_{\\mathrm{base}}\\|_F^2 = 1^2 + (-1)^2 + (-1)^2 + 1^2 = 1 + 1 + 1 + 1 = 4\n$$\n因此，系数 $k$ 为：\n$$\nk = \\frac{4}{4} = 1\n$$\n由于 $k=1 \\ge 0$，该值位于缩放因子的允许范围内。到凸锥 $C$ 上的投影与到直线上的投影相同。因此，修复后的矩阵为：\n$$\n\\mathbf{L}_{\\mathrm{rep}} = k \\mathbf{L}_{\\mathrm{base}} = 1 \\cdot \\mathbf{L}_{\\mathrm{base}} = \\mathbf{L}_{\\mathrm{base}} = \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n这个结果可以通过注意到微扰项 $\\Delta \\mathbf{S}$ 和 $\\mathbf{N}$ 在 Frobenius 内积空间中与 $\\mathbf{L}_{\\mathrm{base}}$ 正交来理解。将 $\\mathbf{L}_{\\mathrm{viol}} = \\mathbf{L}_{\\mathrm{base}} + \\Delta \\mathbf{S} + \\mathbf{N}$ 投影到由 $\\mathbf{L}_{\\mathrm{base}}$ 张成的空间上会消除正交分量，只剩下 $\\mathbf{L}_{\\mathrm{base}}$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}}\n$$", "id": "3529609"}, {"introduction": "一个稳健的数值方法应在离散层面保留基本的物理定律。本实践将指导您设计一个用于耦合输运问题的有限体积格式，该格式能内在地遵循昂萨格倒易关系并保证非负的熵产生。通过使用矩阵调和平均等技术来处理界面属性，我们可以构建一个在设计上就符合热力学一致性的离散化方法，从而从一开始就避免非物理行为。[@problem_id:3529576]", "problem": "设计并实现一种一维单元中心有限体积法 (FVM)，用于与线性不可逆热力学一致的双场耦合扩散系统。两个热力学力是两个标量势$\\phi_1$和$\\phi_2$的梯度，两个对应的通量表示为$J_1$和$J_2$。在空间的每一点，通量矢量$J \\in \\mathbb{R}^2$和力矢量$X \\in \\mathbb{R}^2$满足线性 Onsager 关系$J = - L X$，其中$L \\in \\mathbb{R}^{2 \\times 2}$是局部 Onsager 矩阵。在域中的所有点，Onsager 矩阵都是对称且正定的。局部熵产生密度为$\\sigma = X^\\top L X$，根据热力学第二定律，该值为非负。\n\n你的任务是在一维网格上构建一个离散 FVM 算子，该算子：\n- 通过使用矩阵调和平均进行面插值，在单元面上强制执行离散互易性$L = L^\\top$。\n- 确保组装的全局刚度矩阵$K$是对称的。\n- 确保对于任何给定的场值，在所有面上求和的离散熵产生是非负的。\n\n该数值方法必须遵循以下规范：\n\n- 几何与离散化：\n  - 考虑一个具有单元中心未知量的一维域$x \\in [0, L_x]$。设有$N$个单元，宽度为$\\Delta x_i$（$i \\in \\{0, 1, \\dots, N-1\\}$），且$\\sum_{i=0}^{N-1} \\Delta x_i = L_x$。单元中心位于位置$x_i = x_{\\text{left}} + \\sum_{k=0}^{i-1} \\Delta x_k + \\tfrac{1}{2}\\Delta x_i$，其中$x_{\\text{left}} = 0$。内部面位于相邻单元中心的中间，因此单元$i$和$i+1$之间面的中心到中心距离为$d_{i+\\frac{1}{2}} = \\tfrac{1}{2}(\\Delta x_i + \\Delta x_{i+1})$。边界面位于域的端点，到最近单元中心的距离为$d_{\\frac{1}{2}} = \\tfrac{1}{2}\\Delta x_0$和$d_{N-\\frac{1}{2}} = \\tfrac{1}{2}\\Delta x_{N-1}$。\n\n- 局部本构关系：\n  - 在每个单元$i$中，Onsager 矩阵$L_i \\in \\mathbb{R}^{2 \\times 2}$是对称正定的。面上的通量使用面 Onsager 矩阵$L_f$计算，该矩阵由两个相邻单元矩阵的矩阵调和平均定义：\n    $$ L_f = \\left( \\tfrac{1}{2}\\left( L_{\\text{left}}^{-1} + L_{\\text{right}}^{-1} \\right) \\right)^{-1}, $$\n    其中对于内部面，$L_{\\text{left}} = L_i$和$L_{\\text{right}} = L_{i+1}$。对于只有一个相邻单元$i$的边界面，使用$L_f = L_i$。\n\n- 离散通量与组装：\n  - 令$u_i = \\begin{bmatrix} \\phi_{1,i} \\\\ \\phi_{2,i} \\end{bmatrix}$表示单元$i$处两个势的矢量。对于单元$i$和$i+1$之间的内部面，定义离散梯度代理$\\Delta u_{i+\\frac{1}{2}} = u_{i+1} - u_i$和如上所述的距离$d_{i+\\frac{1}{2}}$。面上的双分量通量矢量为\n    $$ J_{i+\\frac{1}{2}} = - L_f \\left( \\frac{\\Delta u_{i+\\frac{1}{2}}}{d_{i+\\frac{1}{2}}} \\right). $$\n    该面以块三对角线的方式将对称的$2 \\times 2$块$S_{i+\\frac{1}{2}} = \\tfrac{L_f}{d_{i+\\frac{1}{2}}}$贡献给全局刚度矩阵$K \\in \\mathbb{R}^{2N \\times 2N}$：\n    - 将$+S_{i+\\frac{1}{2}}$加到单元$i$的对角块和单元$i+1$的对角块上。\n    - 将$-S_{i+\\frac{1}{2}}$加到耦合$i$和$i+1$的非对角块上，同时也将$-S_{i+\\frac{1}{2}}$加到耦合$i+1$和$i$的块上。\n    通过构造，这种组装方法产生一个对称矩阵$K$。\n  - 对于一个具有边界势矢量$u_b \\in \\mathbb{R}^2$和相邻单元$i$的 Dirichlet 边界面，定义$S_b = \\tfrac{L_f}{d}$，其中$L_f = L_i$且$d$等于从单元中心到边界的距离。将$+S_b$加到单元$i$的对角块上。在构建线性系统$K u = f$的右端项时，相应的分量需要加上$S_b u_b$。在此任务中，你只需要组装$K$和逐面的熵产生；你不需要求解$u$。\n\n- 离散熵产生：\n  - 对于每个具有面矩阵$L_f$和距离$d$的面，定义面熵产生贡献\n    $$ \\sigma_f = \\left( \\frac{\\Delta u}{d} \\right)^\\top L_f \\left( \\frac{\\Delta u}{d} \\right), $$\n    其中对于内部面$\\Delta u = u_{i+1} - u_i$，对于边界面$\\Delta u = u_i - u_b$。总熵产生是所有面的总和$\\sum_f \\sigma_f$，并且每个$\\sigma_f$都必须是非负的。\n\n- 未知量的堆叠：\n  - 按顺序$[\\phi_{1,0}, \\phi_{2,0}, \\phi_{1,1}, \\phi_{2,1}, \\dots, \\phi_{1,N-1}, \\phi_{2,N-1}]$堆叠未知量，以便$K \\in \\mathbb{R}^{2N \\times 2N}$由$2 \\times 2$的块组装而成。\n\n实现一个程序，为以下三个测试用例组装$K$并计算集合$\\{\\sigma_f\\}$。在所有情况下，取横截面积为$1$，并将所有量视为无量纲。\n\n- 测试用例 $ 1 $（均匀网格，弱耦合）：\n  - $L_x = 1$和$N = 5$，所有$i$的$\\Delta x_i = 0.2$。\n  - 单元中心位于$x_i \\in \\{0.1, 0.3, 0.5, 0.7, 0.9\\}$。\n  - 对于单元$i \\in \\{0,1,2,3,4\\}$，定义\n    $$ L_i = \\begin{bmatrix} a_i  c \\\\ c  b_i \\end{bmatrix}, \\quad a_i = 1.0 + 0.2 i, \\quad b_i = 2.0 + 0.1 i, \\quad c = 0.1. $$\n  - $x$处的势为$\\phi_1(x) = \\sin(\\pi x)$和$\\phi_2(x) = \\cos(\\pi x)$，在单元中心处求值。\n  - Dirichlet 边界势：在$x=0$处，$u_b = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$；在$x=1$处，$u_b = \\begin{bmatrix} 0 \\\\ -1 \\end{bmatrix}$。\n\n- 测试用例 $ 2 $（均匀网格，极端对比度）：\n  - $L_x = 1$和$N = 4$，所有$i$的$\\Delta x_i = 0.25$。\n  - 对于单元$i$，令\n    $$ (k_1, k_2) = \\begin{cases} (10^{-3}, 10^{3})  \\text{如果 } i \\text{ 是偶数}, \\\\ (10^{3}, 10^{-3})  \\text{如果 } i \\text{ 是奇数}, \\end{cases} \\quad \\alpha = 0.2, \\quad L_i = \\begin{bmatrix} k_1  \\alpha \\\\ \\alpha  k_2 \\end{bmatrix}. $$\n  - $x$处的势为$\\phi_1(x) = x$和$\\phi_2(x) = 1 - x$，在单元中心$x_i \\in \\{0.125, 0.375, 0.625, 0.875\\}$处求值。\n  - Dirichlet 边界势：在$x=0$处，$u_b = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$；在$x=1$处，$u_b = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n\n- 测试用例 $ 3 $（非均匀网格，强但可接受的耦合）：\n  - $L_x = 1$和$N = 3$，其中$\\Delta x = [0.1, 0.7, 0.2]$，因此中心位于$x \\in \\{0.05, 0.45, 0.85\\}$。\n  - 对于单元$i \\in \\{0,1,2\\}$，定义\n    $$ d_{1,i} = 1 + i, \\quad d_{2,i} = 2 + 2 i, \\quad c_i = 0.4 \\sqrt{d_{1,i} d_{2,i}}, \\quad L_i = \\begin{bmatrix} d_{1,i}  c_i \\\\ c_i  d_{2,i} \\end{bmatrix}. $$\n  - $x$处的势为$\\phi_1(x) = x^2$和$\\phi_2(x) = -x^2 + x$，在单元中心处求值。\n  - Dirichlet 边界势：在$x=0$处，$u_b = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$；在$x=1$处，$u_b = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$。\n\n对每个测试用例，执行以下操作：\n- 按上述规定组装全局刚度矩阵$K \\in \\mathbb{R}^{2N \\times 2N}$。\n- 计算对称性缺陷的 Frobenius 范数$\\|K - K^\\top\\|_F$。\n- 计算所有面熵产生贡献$\\sigma_f$（包括边界面）并报告其中的最小值。\n\n你的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个双元素列表$[s, m]$，其中$s$是对称性缺陷的 Frobenius 范数（浮点数），$m$是最小面熵产生（浮点数）。因此，最终输出必须是按测试用例顺序排列的三个双元素列表的列表，例如$[[s_1, m_1],[s_2, m_2],[s_3, m_3]]$。所有报告的量都是无量纲实数。", "solution": "此问题的解决方案旨在构建一个一维有限体积格式，该格式在离散层面保留了耦合输运系统的基本热力学性质。关键在于确保离散算子满足昂萨格倒易关系（对称性）并保证非负熵产生（正定性）。\n\n**核心方法**\n\n1.  **保持对称性和正定性：**\n    问题的核心是选择一个合适的插值方案来计算单元交界面上的输运矩阵$L_f$。问题指定使用**矩阵调和平均**：\n    $$L_f = \\left( \\frac{1}{2}\\left( L_{\\text{left}}^{-1} + L_{\\text{right}}^{-1} \\right) \\right)^{-1}$$\n    这个选择是至关重要的，因为它保证了如果相邻单元的矩阵$L_{\\text{left}}$和$L_{\\text{right}}$是对称且正定的，那么计算出的面矩阵$L_f$也将是对称且正定的。这就确保了每个面上的离散本构关系都是物理上一致的。\n\n2.  **全局矩阵组装：**\n    离散化过程通过遍历计算域中的所有面（内部面和边界面）来组装全局刚度矩阵$K$。\n    -   对于连接单元$i$和$i+1$的内部面，计算刚度块$S_{i+\\frac{1}{2}} = L_f / d_{i+\\frac{1}{2}}$。根据指定的组装规则，该块对称地贡献给全局矩阵$K$的对角块（$K_{i,i}, K_{i+1,i+1}$）和非对角块（$K_{i,i+1}, K_{i+1,i}$）。由于$L_f$是对称的，因此$S_{i+\\frac{1}{2}}$也是对称的，这保证了全局矩阵$K$的对称性。\n    -   对于边界面，刚度块仅贡献给相邻单元的对角块，这同样保持了$K$的整体对称性。\n\n3.  **离散熵产生：**\n    对于每个面，熵产生被计算为一个二次型：\n    $$\\sigma_f = \\left( \\frac{\\Delta u}{d} \\right)^\\top L_f \\left( \\frac{\\Delta u}{d} \\right)$$\n    其中$\\Delta u$是面两侧的势差。由于$L_f$被构造为正定矩阵，这个二次型$\\sigma_f$对于任何非零的势差都保证是正的，从而在离散层面严格遵守了热力学第二定律。\n\n**实现步骤**\n\n对于每个测试用例：\n1.  根据给定的参数（单元数量$N$，单元宽度$\\Delta x_i$）设置网格几何，并计算单元中心位置$x_i$。\n2.  在每个单元中心计算势矢量$u_i$和局部Onsager矩阵$L_i$。\n3.  初始化一个全零的全局刚度矩阵$K$和一个用于存储熵产生值的列表。\n4.  **遍历内部面：** 对$i=0$到$N-2$，计算$L_f$、$S_f$和$\\sigma_f$，并将$S_f$组装到$K$中，同时记录$\\sigma_f$。\n5.  **处理边界面：** 对左右两个边界面，计算相应的$L_f$（即相邻单元的$L_i$）、$S_b$和$\\sigma_f$，更新$K$的对角块并记录$\\sigma_f$。\n6.  计算最终指标：\n    -   对称性缺陷：$\\|K - K^\\top\\|_F$。由于构造方法，该值应在浮点数精度范围内为零。\n    -   最小熵产生：从所有计算出的$\\sigma_f$值中找出最小值。该值应为非负。\n7.  将结果格式化为指定输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all three test cases.\n    \"\"\"\n\n    def run_case(N, delta_x_values, L_i_func, phi_funcs, u_b_left, u_b_right):\n        \"\"\"\n        Processes a single test case, assembles the stiffness matrix K,\n        and computes the required metrics.\n        \"\"\"\n        # 1. Setup Geometry and Fields\n        delta_x = np.array(delta_x_values)\n        # The problem defines cell centers as x_i = sum_{k=0}^{i-1} dx_k + 0.5*dx_i\n        # which can be computed efficiently.\n        x_centers = np.cumsum(delta_x) - 0.5 * delta_x\n\n        L_i_list = [L_i_func(i) for i in range(N)]\n        u_i_list = [np.array([phi_funcs[0](x), phi_funcs[1](x)]) for x in x_centers]\n\n        # 2. Initialize\n        K = np.zeros((2 * N, 2 * N))\n        sigmas = []\n\n        # 3. Loop over Internal Faces (i to i+1)\n        for i in range(N - 1):\n            L_left, L_right = L_i_list[i], L_i_list[i+1]\n            u_left, u_right = u_i_list[i], u_i_list[i+1]\n\n            d_face = 0.5 * (delta_x[i] + delta_x[i+1])\n\n            # Face matrix (matrix harmonic mean)\n            L_left_inv = np.linalg.inv(L_left)\n            L_right_inv = np.linalg.inv(L_right)\n            L_f = np.linalg.inv(0.5 * (L_left_inv + L_right_inv))\n\n            # Stiffness block\n            S_f = L_f / d_face\n\n            # Assembly into global K\n            idx1_start, idx1_end = 2 * i, 2 * i + 2\n            idx2_start, idx2_end = 2 * (i + 1), 2 * (i + 1) + 2\n            K[idx1_start:idx1_end, idx1_start:idx1_end] += S_f\n            K[idx2_start:idx2_end, idx2_start:idx2_end] += S_f\n            K[idx1_start:idx1_end, idx2_start:idx2_end] -= S_f\n            K[idx2_start:idx2_end, idx1_start:idx1_end] -= S_f\n\n            # Entropy production\n            delta_u = u_right - u_left\n            X_f = delta_u / d_face\n            sigma_f = X_f.T @ L_f @ X_f\n            sigmas.append(sigma_f)\n\n        # 4. Handle Boundary Faces\n        # Left boundary (x=0, adjacent to cell 0)\n        L_f_left = L_i_list[0]\n        d_left = 0.5 * delta_x[0]\n        S_b_left = L_f_left / d_left\n        K[0:2, 0:2] += S_b_left\n        \n        delta_u_left = u_i_list[0] - u_b_left\n        X_f_left = delta_u_left / d_left\n        sigma_f_left = X_f_left.T @ L_f_left @ X_f_left\n        sigmas.append(sigma_f_left)\n\n        # Right boundary (x=Lx, adjacent to cell N-1)\n        L_f_right = L_i_list[N - 1]\n        d_right = 0.5 * delta_x[N-1]\n        S_b_right = L_f_right / d_right\n        K[2*(N-1):2*N, 2*(N-1):2*N] += S_b_right\n\n        delta_u_right = u_i_list[N-1] - u_b_right\n        X_f_right = delta_u_right / d_right\n        sigma_f_right = X_f_right.T @ L_f_right @ X_f_right\n        sigmas.append(sigma_f_right)\n\n        # 5. Compute final metrics\n        s = np.linalg.norm(K - K.T, 'fro')\n        m = np.min(sigmas)\n\n        return [s, m]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"N\": 5, \"delta_x\": [0.2] * 5,\n            \"L_i_func\": lambda i: np.array([[1.0 + 0.2 * i, 0.1], [0.1, 2.0 + 0.1 * i]]),\n            \"phi_funcs\": [lambda x: np.sin(np.pi * x), lambda x: np.cos(np.pi * x)],\n            \"u_b_left\": np.array([0.0, 1.0]), \"u_b_right\": np.array([0.0, -1.0])\n        },\n        # Test Case 2\n        {\n            \"N\": 4, \"delta_x\": [0.25] * 4,\n            \"L_i_func\": lambda i: np.array([[1e-3, 0.2], [0.2, 1e3]]) if i % 2 == 0 else np.array([[1e3, 0.2], [0.2, 1e-3]]),\n            \"phi_funcs\": [lambda x: x, lambda x: 1.0 - x],\n            \"u_b_left\": np.array([0.0, 1.0]), \"u_b_right\": np.array([1.0, 0.0])\n        },\n        # Test Case 3\n        {\n            \"N\": 3, \"delta_x\": [0.1, 0.7, 0.2],\n            \"L_i_func\": lambda i: np.array([\n                [1.0 + i, 0.4 * np.sqrt((1.0 + i) * (2.0 + 2.0 * i))],\n                [0.4 * np.sqrt((1.0 + i) * (2.0 + 2.0 * i)), 2.0 + 2.0 * i]\n            ]),\n            \"phi_funcs\": [lambda x: x**2, lambda x: -x**2 + x],\n            \"u_b_left\": np.array([0.0, 0.0]), \"u_b_right\": np.array([1.0, 0.0])\n        }\n    ]\n\n    results = []\n    for case_data in test_cases:\n        result = run_case(case_data[\"N\"], case_data[\"delta_x\"], case_data[\"L_i_func\"],\n                          case_data[\"phi_funcs\"], case_data[\"u_b_left\"], case_data[\"u_b_right\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list includes spaces, so we remove them\n    # to match the concise output format '[[s,m],[s,m]]'.\n    print(str(results).replace(' ', ''))\n\nsolve()\n```", "id": "3529576"}, {"introduction": "即使采用精心设计的格式，来自时间积分或算子分裂等来源的数值误差也可能破坏热力学一致性。本练习通过实施一种校正方案来应对这一实际挑战，该方案将数值计算得到的迁移率矩阵投影到与之最接近的物理有效矩阵上。您将进而量化这种校正对模拟稳定性和能量耗散物理保真度的显著影响，突显在实践中强制执行这些原则的关键重要性。[@problem_id:3529587]", "problem": "考虑一个非平衡热力学的线性区中的多物理场耦合模拟，其中广义流 $J$ 与广义力 $X$ 通过线性本构关系 $J = L\\,X$ 相关联。为了保证热力学一致性，矩阵 $L$ 必须满足 Onsager 倒易关系 $L = L^\\top$ 并确保对所有 $X$ 熵产生非负 $X^\\top L X \\ge 0$，即 $L$ 必须是对称半正定的。在实践中，数值离散化和时间积分可能会产生一个违反这些属性的矩阵 $L$（例如通过舍入误差或算子分裂），这可能导致不稳定性及物理保真度的丧失。\n\n您的任务是设计并实现一种校正方案，该方案将在弗罗贝尼乌斯范数意义下，把一个数值计算得到的矩阵 $L$ 投影到同时满足 $L = L^\\top$ 和 $L \\succeq 0$ 的最近矩阵 $\\widehat{L}$ 上。然后，在一个具有二次型自由能的线性梯度流的显式时间积分中，量化此校正对稳定性和物理保真度的影响。\n\n从以下基本依据出发：\n- 热力学第二定律要求对所有力 $X$，熵产生 $\\sigma = X^\\top L X$ 均为非负，因此 $L$ 必须是对称半正定的。\n- 在一个状态向量为 $x \\in \\mathbb{R}^n$、具有二次型自由能 $F(x) = \\tfrac{1}{2} x^\\top K x$ 和半正定刚度 $K$ 的梯度流模型中，线性迁移率 $L$ 产生演化 $\\dot{x} = - L K x$。在 $L \\succeq 0$ 和 $K \\succeq 0$ 的精确连续动力学下，自由能 $F$ 是非增的。\n\n您必须：\n1. 提出并实现一个校正方案，将任意方阵 $L$ 映射到满足 $\\widehat{L} = \\widehat{L}^\\top$ 和 $\\widehat{L} \\succeq 0$ 约束下的最近矩阵 $\\widehat{L}$（在弗罗贝尼乌斯范数意义下）。\n2. 对于下面的每个测试用例，构造 $L$、$K$、时间步长 $\\Delta t$ 和初始条件 $x_0$。使用显式欧拉格式 $x_{k+1} = x_k - \\Delta t\\,L K x_k$ 进行 $N$ 步积分（$N = 100$），一次使用原始的 $L$，一次使用校正后的 $\\widehat{L}$。使用无量纲量；不需要物理单位。\n3. 对于每次运行（原始 $L$ 和校正后的 $\\widehat{L}$），计算以下量化指标：\n   - 弗罗贝尼乌斯投影距离 $d = \\|L - \\widehat{L}\\|_F$。\n   - 更新矩阵 $I - \\Delta t\\,L K$ 的谱半径 $\\rho$，即 $\\rho = \\max_i |\\lambda_i(I - \\Delta t\\,L K)|$。\n   - 轨迹上的最大正能量增量，定义为在所有步长 $k$ 上的 $\\max\\{ F(x_{k+1}) - F(x_k), 0 \\}$。\n   - 由 $\\lambda_{\\min}\\!\\left(\\tfrac{L + L^\\top}{2}\\right)$ 给出的最小熵产生代理指标。\n   - 一个布尔值，指示自由能 $F$ 在所有步骤中是否非增（单调），即对所有 $k$ 是否都满足 $F(x_{k+1}) \\le F(x_k)$。\n4. 将每个测试用例的结果按以下顺序汇总到一个列表中：\n   $[d,\\ \\rho(L),\\ \\rho(\\widehat{L}),\\ \\text{max\\_dE}(L),\\ \\text{max\\_dE}(\\widehat{L}),\\ \\lambda_{\\min}((L+L^\\top)/2),\\ \\lambda_{\\min}((\\widehat{L}+\\widehat{L}^\\top)/2),\\ \\text{is\\_monotone}(L),\\ \\text{is\\_monotone}(\\widehat{L})]$。\n\n测试套件（所有量均为无量纲，并通过固定的种子来确保确定性）：\n- 用例 $1$ ($n=3$):\n  - 构造 $L$ 为 $L = Q \\operatorname{diag}(1.5,0.8,0.2) Q^\\top + E$，其中 $Q$ 是通过对种子为 $42$ 的随机正态矩阵进行 $\\mathrm{QR}$ 分解得到的，而 $E$ 是一个小的扰动，其值为种子为 $0$ 的随机正态矩阵的 $0.01$ 倍。\n  - 构造 $K = P \\operatorname{diag}(2.0,1.0,0.5) P^\\top$，其中 $P$ 是通过对种子为 $7$ 的随机正态矩阵进行 $\\mathrm{QR}$ 分解得到的。\n  - 时间步长 $\\Delta t = 0.1$。\n  - 初始条件 $x_0$ 从种子为 $123$ 的随机正态向量中抽取。\n- 用例 $2$ ($n=4$):\n  - 从一个种子为 $1$ 的随机正态矩阵开始，形成一个试验矩阵 $L$，然后设置其对称部分 $S = (L + L^\\top)/2$ 并通过 $S \\leftarrow S - \\alpha I$（其中 $\\alpha = \\lambda_{\\min}(S) + 0.5$）对其进行平移，使得 $\\lambda_{\\min}(S) = -0.5$。添加一个由种子为 $2$ 的随机正态矩阵通过 $A = 0.3\\,(R - R^\\top)$ 构造的斜对称部分 $A$，并设置 $L = S + A$。\n  - 构造 $K = P \\operatorname{diag}(2.0,1.5,1.0,0.5) P^\\top$，其中 $P$ 是通过对种子为 $8$ 的随机正态矩阵进行 $\\mathrm{QR}$ 分解得到的。\n  - 时间步长 $\\Delta t = 0.1$。\n  - 初始条件 $x_0$ 从种子为 $124$ 的随机正态向量中抽取。\n- 用例 $3$ ($n=3$):\n  - 通过 $S = Q \\operatorname{diag}(1.0,0.5,-10^{-3}) Q^\\top$（其中 $Q$ 来自种子 $77$）构造一个几乎一致但处于不定性边界的矩阵，并添加一个小的斜对称扰动 $A = 0.02\\,(R - R^\\top)$（其中 $R$ 来自种子 $3$），然后设置 $L = S + A$。\n  - 构造 $K = P \\operatorname{diag}(1.5,1.0,0.5) P^\\top$，其中 $P$ 来自种子 $9$。\n  - 时间步长 $\\Delta t = 0.3$。\n  - 初始条件 $x_0$ 来自种子 $125$。\n- 用例 $4$ ($n=3$):\n  - 构造一个奇异半正定核心 $S = Q \\operatorname{diag}(1.0,0.0,0.2) Q^\\top$（其中 $Q$ 来自种子 $55$），并添加一个微小的扰动 $E$，$E = 0.005\\,R$（其中 $R$ 来自种子 $4$），然后设置 $L = S + E$。\n  - 构造 $K = P \\operatorname{diag}(1.2,0.9,0.4) P^\\top$，其中 $P$ 来自种子 $10$。\n  - 时间步长 $\\Delta t = 0.2$。\n  - 初始条件 $x_0$ 来自种子 $126$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的列表的列表（例如，`[[...],[...],[...],[...]]`）。每个内部列表必须遵循上述顺序，并包含以下类型：前七个条目是实数（浮点数），最后两个条目是布尔值。不应打印任何其他文本。", "solution": "该问题的核心是实施并评估一个校正方案，用于将一个任意的数值迁移率矩阵 $L$ 强制转换为一个满足热力学一致性的矩阵 $\\widehat{L}$。这意味着 $\\widehat{L}$ 必须是对称且半正定的。\n\n### 第一部分：校正方案\n\n将任意方阵 $L$ 投影到弗罗贝尼乌斯范数意义下最近的对称半正定 (SPSD) 矩阵 $\\widehat{L}$，可以分两步完成，这源于对称矩阵空间与斜对称矩阵空间的正交性。\n\n1.  **强制对称性 (Onsager 关系)**：任意矩阵 $L$ 可以分解为其对称部分 $L_S = \\frac{1}{2}(L + L^\\top)$ 和斜对称部分 $L_A = \\frac{1}{2}(L - L^\\top)$。在 SPSD 矩阵空间中，与 $L$ 最近的矩阵必然与 $L_S$ 最近，因为斜对称部分 $L_A$ 到对称空间的投影为零。因此，第一步是提取对称部分 $L_S$。\n\n2.  **强制半正定性 (第二定律)**：下一步是将对称矩阵 $L_S$ 投影到半正定锥上。这可以通过对 $L_S$ 进行谱分解（特征值分解）来实现。\n    -   计算 $L_S$ 的特征值 $\\lambda_i$ 和对应的特征向量（构成正交矩阵 $U$），使得 $L_S = U \\Lambda U^\\top$，其中 $\\Lambda = \\operatorname{diag}(\\lambda_1, \\dots, \\lambda_n)$。\n    -   将所有负特征值替换为零，得到一个新的对角矩阵 $\\Lambda_+$，其元素为 $\\lambda_i^+ = \\max(\\lambda_i, 0)$。\n    -   重新构造校正后的矩阵 $\\widehat{L} = U \\Lambda_+ U^\\top$。\n\n得到的矩阵 $\\widehat{L}$ 根据构造是对称的，并且其特征值非负，因此是半正定的。\n\n### 第二部分：模拟与评估\n\n该方案在梯度流模型 $\\dot{x} = -LKx$ 的显式欧拉时间积分中的效果通过以下指标进行量化：\n\n-   **弗罗贝尼乌斯投影距离, $d$**: 衡量原始矩阵 $L$ 偏离热力学一致性的程度。\n-   **谱半径, $\\rho$**: 显式欧拉格式 $x_{k+1} = (I - \\Delta t L K) x_k$ 的稳定性由更新矩阵的谱半径决定。$\\rho \\le 1$ 是稳定性的必要条件。不符合物理规律的 $L$ 容易导致 $\\rho > 1$ 和数值不稳定。校正后的 $\\widehat{L}$ 通常会改善稳定性。\n-   **最大正能量增量, $\\max\\Delta E$**, 和 **单调性, is_monotone**: 梯度流的物理特性是自由能 $F(x)$ 随时间永不增加。数值误差或不符合物理规律的 $L$ 可能导致 $F(x_{k+1}) > F(x_k)$。这些指标量化了这种非物理行为。\n-   **最小熵产生代理, $\\lambda_{\\min}$**: $L$ 的对称部分的最小特征值 $\\lambda_{\\min}(L_S)$ 直接反映了系统是否满足第二定律。如果该值为负，则存在导致熵减少的力，这是不符合物理规律的。校正后，该值保证为非负。\n\n通过在四个不同配置的测试用例上运行模拟并计算这些指标，我们可以清晰地看到校正方案如何恢复数值稳定性和物理保真度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    test_cases = [\n        {'n': 3, 'L_seed_Q': 42, 'L_seed_E': 0, 'K_seed_P': 7,\n         'x0_seed': 123, 'dt': 0.1, 'case_id': 1},\n        {'n': 4, 'L_seed_trial': 1, 'L_seed_R': 2, 'K_seed_P': 8,\n         'x0_seed': 124, 'dt': 0.1, 'case_id': 2},\n        {'n': 3, 'L_seed_Q': 77, 'L_seed_R': 3, 'K_seed_P': 9,\n         'x0_seed': 125, 'dt': 0.3, 'case_id': 3},\n        {'n': 3, 'L_seed_Q': 55, 'L_seed_R': 4, 'K_seed_P': 10,\n         'x0_seed': 126, 'dt': 0.2, 'case_id': 4},\n    ]\n\n    results = []\n    N_STEPS = 100\n\n    for params in test_cases:\n        L, K, x0 = _construct_matrices(params)\n        dt = params['dt']\n        \n        # 1. Propose and implement a correction scheme\n        L_hat = _project_to_spsd(L)\n        \n        # 2. Run simulations\n        traj_L = _run_simulation(L, K, x0, dt, N_STEPS)\n        traj_L_hat = _run_simulation(L_hat, K, x0, dt, N_STEPS)\n        \n        # 3. Compute quantitative metrics\n        case_results = _calculate_metrics(L, L_hat, K, dt, traj_L, traj_L_hat)\n        \n        # 4. Aggregate results\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to its string representation and join with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef _construct_matrices(params):\n    \"\"\"Constructs L, K, and x0 for a given test case.\"\"\"\n    n = params['n']\n    case_id = params['case_id']\n\n    # Construct L\n    if case_id == 1:\n        rng_q = np.random.default_rng(params['L_seed_Q'])\n        rng_e = np.random.default_rng(params['L_seed_E'])\n        Q, _ = np.linalg.qr(rng_q.normal(size=(n, n)))\n        E = rng_e.normal(size=(n, n))\n        L = Q @ np.diag([1.5, 0.8, 0.2]) @ Q.T + 0.01 * E\n    elif case_id == 2:\n        rng_trial = np.random.default_rng(params['L_seed_trial'])\n        rng_r = np.random.default_rng(params['L_seed_R'])\n        L_trial = rng_trial.normal(size=(n, n))\n        S = 0.5 * (L_trial + L_trial.T)\n        lambda_min_S = np.min(np.linalg.eigvalsh(S))\n        alpha = lambda_min_S + 0.5\n        S_shifted = S - alpha * np.eye(n)\n        R = rng_r.normal(size=(n, n))\n        A = 0.3 * (R - R.T)\n        L = S_shifted + A\n    elif case_id == 3:\n        rng_q = np.random.default_rng(params['L_seed_Q'])\n        rng_r = np.random.default_rng(params['L_seed_R'])\n        Q, _ = np.linalg.qr(rng_q.normal(size=(n, n)))\n        S = Q @ np.diag([1.0, 0.5, -1e-3]) @ Q.T\n        R = rng_r.normal(size=(n, n))\n        A = 0.02 * (R - R.T)\n        L = S + A\n    elif case_id == 4:\n        rng_q = np.random.default_rng(params['L_seed_Q'])\n        rng_r = np.random.default_rng(params['L_seed_R'])\n        Q, _ = np.linalg.qr(rng_q.normal(size=(n, n)))\n        S = Q @ np.diag([1.0, 0.0, 0.2]) @ Q.T\n        E = 0.005 * rng_r.normal(size=(n, n))\n        L = S + E\n    else:\n        raise ValueError(\"Invalid case_id\")\n\n    # Construct K\n    rng_p = np.random.default_rng(params['K_seed_P'])\n    P, _ = np.linalg.qr(rng_p.normal(size=(n, n)))\n    if case_id == 1:\n        K = P @ np.diag([2.0, 1.0, 0.5]) @ P.T\n    elif case_id == 2:\n        K = P @ np.diag([2.0, 1.5, 1.0, 0.5]) @ P.T\n    elif case_id == 3:\n        K = P @ np.diag([1.5, 1.0, 0.5]) @ P.T\n    elif case_id == 4:\n        K = P @ np.diag([1.2, 0.9, 0.4]) @ P.T\n        \n    # Construct x0\n    rng_x0 = np.random.default_rng(params['x0_seed'])\n    x0 = rng_x0.normal(size=n)\n    \n    return L, K, x0\n\n\ndef _project_to_spsd(L):\n    \"\"\"Projects matrix L onto the closest symmetric positive semidefinite matrix.\"\"\"\n    L_s = 0.5 * (L + L.T)\n    eigvals, eigvecs = np.linalg.eigh(L_s)\n    eigvals[eigvals  0] = 0\n    L_hat = eigvecs @ np.diag(eigvals) @ eigvecs.T\n    return L_hat\n\n\ndef _run_simulation(L, K, x0, dt, N):\n    \"\"\"Runs the explicit Euler simulation for N steps.\"\"\"\n    x_traj = [x0]\n    x = x0.copy()\n    update_matrix = np.eye(len(x0)) - dt * L @ K\n    for _ in range(N):\n        x = update_matrix @ x\n        x_traj.append(x)\n    return np.array(x_traj)\n\ndef _calculate_metrics(L, L_hat, K, dt, traj_L, traj_L_hat):\n    \"\"\"Calculates all required metrics for a test case.\"\"\"\n    n = L.shape[0]\n\n    # Frobenius projection distance\n    d = np.linalg.norm(L - L_hat, 'fro')\n\n    # Spectral radius of update matrix\n    update_matrix_L = np.eye(n) - dt * L @ K\n    rho_L = np.max(np.abs(np.linalg.eigvals(update_matrix_L)))\n    \n    update_matrix_L_hat = np.eye(n) - dt * L_hat @ K\n    rho_L_hat = np.max(np.abs(np.linalg.eigvals(update_matrix_L_hat)))\n    \n    # Energy calculations\n    def get_energy(x, K_mat):\n        return 0.5 * x.T @ K_mat @ x\n\n    energies_L = np.array([get_energy(vec, K) for vec in traj_L])\n    energy_increments_L = np.diff(energies_L)\n    max_dE_L = np.max(np.maximum(energy_increments_L, 0))\n    # A tolerance is prudent for floating point comparisons\n    is_monotone_L = np.all(energy_increments_L = 1e-12)\n\n    energies_L_hat = np.array([get_energy(vec, K) for vec in traj_L_hat])\n    energy_increments_L_hat = np.diff(energies_L_hat)\n    max_dE_L_hat = np.max(np.maximum(energy_increments_L_hat, 0))\n    is_monotone_L_hat = np.all(energy_increments_L_hat = 1e-12)\n\n    # Minimal entropy production proxy\n    lambda_min_L_sym = np.min(np.linalg.eigvalsh(0.5 * (L + L.T)))\n    # L_hat is already symmetric SPSD, so the min eigenvalue is non-negative\n    lambda_min_L_hat_sym = np.min(np.linalg.eigvalsh(L_hat))\n    \n    return [\n        d,\n        rho_L,\n        rho_L_hat,\n        max_dE_L,\n        max_dE_L_hat,\n        lambda_min_L_sym,\n        lambda_min_L_hat_sym,\n        is_monotone_L,\n        is_monotone_L_hat\n    ]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3529587"}]}