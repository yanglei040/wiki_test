{"hands_on_practices": [{"introduction": "本练习是构建稳健有限体积格式的基石。我们将从积分守恒律出发，为一个典型的反应扩散方程构建一个保证浓度非负性与质量守恒的离散格式。通过这个实践[@problem_id:3507785]，你将掌握如何设计数值通量与源项处理方法，以确保模拟结果的物理真实性，这是任何高保真模拟软件的核心要求。", "problem": "考虑一个关于单位体积守恒广延量的标量反应扩散方程，该方程在一个空间域上以纯守恒形式表示为：\n$$\n\\partial_t c = \\nabla \\cdot \\left( D \\nabla c \\right) + R(c),\n$$\n其中 $c$ 是浓度，单位为 $\\mathrm{mol/m^3}$，$D$ 是扩散系数，单位为 $\\mathrm{m^2/s}$，$R(c)$ 是源项，单位为 $\\mathrm{mol/(m^3\\,s)}$。从局部守恒定律和散度定理出发，构建一个在一维域上采用零通量（齐次诺伊曼）边界条件的单元中心有限体积法，该方法强制执行通量的精确离散守恒，并保持浓度的非负性。通过后向欧拉步隐式处理扩散，并使用保证 $c \\ge 0$ 的产生-消亡分解来隐式分裂源项。该分裂必须满足：仅通量部分就能精确保持总质量，而完整的更新步骤在 $R \\equiv 0$ 的特殊情况下能精确保持总质量，并且在一般情况下，总质量的变化量精确等于源项的离散积分。\n\n您必须从守恒第一性原理推导控制体界面上的离散通量。在界面上使用两点通量近似，该近似与可变扩散系数 $D$ 一致，并对空间单调状态强制保持正性。为隐式扩散步骤组装得到的线性系统。然后，对于源项，将 $R(c)$ 表示为产生-消亡分裂 $R(c) = P(c) - Q(c)\\,c$，其中 $P(c) \\ge 0$ 且 $Q(c) \\ge 0$，并设计一个对每个控制体局部的、保持 $c \\ge 0$ 的后向欧拉更新。\n\n实现一个包含以下步骤的隐式算子分裂时间步：\n- 一个隐式扩散步，\n- 随后是一个基于产生-消亡分裂的隐式源项步。\n\n在一维域 $x \\in [0,L]$ 上使用均匀单元和单位横截面积进行计算。在 $x=0$ 和 $x=L$ 处使用齐次诺伊曼边界条件（零扩散通量）。总质量应计算为黎曼和 $M = \\sum_i c_i\\,\\Delta x$（单位为 $\\mathrm{mol/m^2}$，这里指浓度在单位面积下对长度的积分）。您必须为每个测试用例数值检验以下属性：\n- 非负性：在完整步骤后，验证 $\\min_i c_i \\ge 0$。\n- 通量守恒：在扩散步后（源项步之前），验证总质量 $M$ 在指定的绝对容差内保持不变。\n- 源项一致性：在源项步后，验证总质量变化等于源项的离散积分，即 $M^{n+1} - M^{n+1/2} = \\Delta t \\sum_i \\left[P_i - Q_i\\,c_i^{n+1}\\right]\\,\\Delta x$，在指定的绝对容差内。\n\n您的程序必须实现上述方法，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目对应一个测试用例，是一个布尔值，表示非负性和质量属性是否都通过了检验。在所有情况下，用于质量检查的绝对容差为 $10^{-10}$。\n\n所有物理参数均使用上述单位表示。不使用角度。输出中的所有结果都是无量纲的布尔值。\n\n测试套件：\n- 用例 1（仅扩散，可变扩散系数）：\n  - 域长度 $L = 1\\,\\mathrm{m}$，单元数 $N = 50$，时间步长 $\\Delta t = 1\\,\\mathrm{s}$。\n  - 初始条件 $c(x) = 1 + 0.1 \\cos(2\\pi x/L)$，单位 $\\mathrm{mol/m^3}$。\n  - 扩散系数 $D(x) = 10^{-3} + 5\\times 10^{-4} \\sin(2\\pi x/L)$，单位 $\\mathrm{m^2/s}$。\n  - 源项分裂 $P \\equiv 0$ 和 $Q \\equiv 0$。\n  - 边界条件：在 $x=0$ 和 $x=L$ 处为齐次诺伊曼。\n- 用例 2（带扩散的刚性衰减）：\n  - 域长度 $L = 1\\,\\mathrm{m}$，单元数 $N = 100$，时间步长 $\\Delta t = 10^{-2}\\,\\mathrm{s}$。\n  - 初始条件 $c(x) = 1\\times 10^{-3} + \\exp\\left(-\\dfrac{(x - 0.5 L)^2}{5\\times 10^{-3}}\\right)$，单位 $\\mathrm{mol/m^3}$。\n  - 扩散系数 $D(x) = 10^{-3}\\left(1 + 0.9\\,\\exp\\left(-\\dfrac{(x - 0.5 L)^2}{10^{-2}} \\right)\\right)$，单位 $\\mathrm{m^2/s}$。\n  - 源项分裂 $P \\equiv 0$，$Q \\equiv k$，其中 $k = 10^{3}\\,\\mathrm{s^{-1}}$。\n  - 边界条件：在 $x=0$ 和 $x=L$ 处为齐次诺伊曼。\n- 用例 3（带扩散的刚性产生-消亡）：\n  - 域长度 $L = 1\\,\\mathrm{m}$，单元数 $N = 80$，时间步长 $\\Delta t = 5\\times 10^{-2}\\,\\mathrm{s}$。\n  - 初始条件 $c(x) = 0.2 + 0.2 \\sin(3\\pi x/L)$，单位 $\\mathrm{mol/m^3}$。\n  - 扩散系数 $D(x) = 5\\times 10^{-4}$，单位 $\\mathrm{m^2/s}$。\n  - 源项分裂 $P \\equiv 0.5\\,\\mathrm{mol/(m^3\\,s)}$，$Q \\equiv 200\\,\\mathrm{s^{-1}}$。\n  - 边界条件：在 $x=0$ 和 $x=L$ 处为齐次诺伊曼。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是字符串 `True` 或 `False`。", "solution": "该问题要求构建并实现一个一维、单元中心的有限体积法（FVM），用于求解一个标量反应扩散方程。该格式必须是保正且离散守恒的。推导始于局部守恒定律的积分形式。\n\n控制偏微分方程为：\n$$\n\\partial_t c = \\nabla \\cdot \\left( D \\nabla c \\right) + R(c)\n$$\n其中 $c$ 是浓度，$D$ 是扩散系数，$R(c)$ 是反应源项。\n\n我们将一维域 $x \\in [0, L]$ 离散为 $N$ 个均匀的控制体（单元），每个单元的宽度为 $\\Delta x = L/N$。第 $i$ 个单元 $V_i$ 覆盖区间 $[x_{i-1/2}, x_{i+1/2}]$，其中心位于 $x_i = (i+0.5)\\Delta x$，其中 $i=0, 1, \\dots, N-1$。单元平均浓度定义为 $c_i(t) \\approx \\frac{1}{\\Delta x} \\int_{V_i} c(x,t) dx$。\n\n将偏微分方程在控制体 $V_i$ 上积分（假设单位横截面积）得到：\n$$\n\\int_{V_i} \\partial_t c \\, dx = \\int_{V_i} \\frac{\\partial}{\\partial x} \\left( D \\frac{\\partial c}{\\partial x} \\right) dx + \\int_{V_i} R(c) \\, dx\n$$\n对扩散项应用微积分基本定理（一维散度定理）并近似积分，得到单元平均浓度 $c_i$ 的半离散方程：\n$$\n\\frac{d c_i}{dt} \\Delta x = \\left. \\left( D \\frac{\\partial c}{\\partial x} \\right) \\right|_{x_{i+1/2}} - \\left. \\left( D \\frac{\\partial c}{\\partial x} \\right) \\right|_{x_{i-1/2}} + R(c_i) \\Delta x\n$$\n令 $F = D \\frac{\\partial c}{\\partial x}$ 为扩散通量。方程变为：\n$$\n\\frac{d c_i}{dt} = \\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) + R(c_i)\n$$\n为了得到一个一致且守恒的格式，单元 $i$ 和单元 $i+1$ 之间界面上的通量 $F_{i+1/2}$ 使用两点通量近似（TPFA）进行逼近。梯度由中心差分近似，$\\frac{\\partial c}{\\partial x} \\approx \\frac{c_{i+1}-c_i}{\\Delta x}$。为处理可变的扩散系数 $D(x)$，界面上的有效扩散系数 $D_{i+1/2}$ 使用相邻单元中的值 $D_i = D(x_i)$ 和 $D_{i+1} = D(x_{i+1})$ 的调和平均值计算：\n$$\nF_{i+1/2} \\approx D_{i+1/2} \\frac{c_{i+1} - c_i}{\\Delta x}, \\quad \\text{其中} \\quad D_{i+1/2} = \\frac{2 D_i D_{i+1}}{D_i + D_{i+1}}\n$$\n这种选择确保了通量连续性和物理一致性。齐次诺伊曼边界条件对应于域边界上的零通量：在 $x=0$ 处 $F_{-1/2} = 0$，在 $x=L$ 处 $F_{N-1/2} = 0$。\n\n使用一阶算子分裂（李分裂）来分别处理扩散项和反应项。从 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的单个时间步包含两个顺序子步骤：\n1.  **隐式扩散步**：求解 $\\frac{\\partial c}{\\partial t} = \\nabla \\cdot (D \\nabla c)$ 从 $t^n$ 到 $t^{n+1}$，得到一个中间解 $c^{n+1/2}$。\n2.  **隐式源项步**：以 $c^{n+1/2}$ 作为初始条件，求解 $\\frac{\\partial c}{\\partial t} = R(c)$ 从 $t^n$ 到 $t^{n+1}$，得到最终解 $c^{n+1}$。\n\n为实现无条件稳定性，扩散步使用后向欧拉法进行离散化：\n$$\n\\frac{c_i^{n+1/2} - c_i^n}{\\Delta t} = \\frac{1}{\\Delta x} (F_{i+1/2}^{n+1/2} - F_{i-1/2}^{n+1/2})\n$$\n代入通量近似，得到关于未知浓度 $\\mathbf{c}^{n+1/2} = [c_0^{n+1/2}, \\dots, c_{N-1}^{n+1/2}]^T$ 的线性方程组。对于内部单元 $i \\in [1, N-2]$：\n$$\nc_i^{n+1/2} - \\frac{\\Delta t}{\\Delta x^2} \\left[ D_{i+1/2}(c_{i+1}^{n+1/2} - c_i^{n+1/2}) - D_{i-1/2}(c_i^{n+1/2} - c_{i-1}^{n+1/2}) \\right] = c_i^n\n$$\n整理单元 $i$ 的项：\n$$\n-\\frac{\\Delta t}{\\Delta x^2} D_{i-1/2} c_{i-1}^{n+1/2} + \\left(1 + \\frac{\\Delta t}{\\Delta x^2} (D_{i+1/2} + D_{i-1/2})\\right) c_i^{n+1/2} - \\frac{\\Delta t}{\\Delta x^2} D_{i+1/2} c_{i+1}^{n+1/2} = c_i^n\n$$\n对于边界单元，我们应用零通量条件。\n对于单元 $i=0$：$F_{-1/2}=0$，因此方程为 $-\\frac{\\Delta t}{\\Delta x^2} D_{1/2} c_{1}^{n+1/2} + \\left(1 + \\frac{\\Delta t}{\\Delta x^2} D_{1/2}\\right) c_0^{n+1/2} = c_0^n$。\n对于单元 $i=N-1$：$F_{N-1/2}=0$，因此方程为 $-\\frac{\\Delta t}{\\Delta x^2} D_{N-3/2} c_{N-2}^{n+1/2} + \\left(1 + \\frac{\\Delta t}{\\Delta x^2} D_{N-3/2}\\right) c_{N-1}^{n+1/2} = c_{N-1}^n$。\n这构成了一个对称、对角占优的三对角线性系统 $\\mathbf{A} \\mathbf{c}^{n+1/2} = \\mathbf{c}^n$，可以高效求解。得到的矩阵 $\\mathbf{A}$ 是一个M-矩阵，这确保了如果对所有 $i$ 都有 $c_i^n \\ge 0$，那么 $c_i^{n+1/2} \\ge 0$。\n\n扩散步的总质量 $M = \\sum_i c_i \\Delta x$ 是守恒的。将半离散扩散方程对所有单元求和：\n$$\n\\sum_{i=0}^{N-1} \\frac{c_i^{n+1/2} - c_i^n}{\\Delta t} \\Delta x = \\sum_{i=0}^{N-1} (F_{i+1/2}^{n+1/2} - F_{i-1/2}^{n+1/2}) = F_{N-1/2}^{n+1/2} - F_{-1/2}^{n+1/2}\n$$\n右侧的和是一个伸缩级数。在零通量边界条件下，$F_{-1/2} = F_{N-1/2} = 0$，所以 $\\sum_i (c_i^{n+1/2} - c_i^n) = 0$。这证实了扩散步的精确离散质量守恒。\n\n源项步求解每个单元的常微分方程组 $\\frac{dc_i}{dt} = R(c_i)$，从 $c_i^{n+1/2}$ 开始。源项被分裂为产生和消亡分量，$R(c) = P(c) - Q(c)c$，其中 $P(c) \\ge 0$ 且 $Q(c) \\ge 0$。应用后向欧拉法得到：\n$$\n\\frac{c_i^{n+1} - c_i^{n+1/2}}{\\Delta t} = P(c_i^{n+1}) - Q(c_i^{n+1}) c_i^{n+1}\n$$\n对于测试用例，$P$ 和 $Q$ 是常数。这允许直接求解 $c_i^{n+1}$：\n$$\nc_i^{n+1} (1 + \\Delta t Q) = c_i^{n+1/2} + \\Delta t P \\quad \\implies \\quad c_i^{n+1} = \\frac{c_i^{n+1/2} + \\Delta t P}{1 + \\Delta t Q}\n$$\n这个更新保证了正性：由于扩散步确保了 $c_i^{n+1/2} \\ge 0$，且给定 $\\Delta t > 0$，$P \\ge 0$，$Q \\ge 0$，分子是非负的，分母是正的，因此 $c_i^{n+1} \\ge 0$。\n\n源项步期间总质量的变化与积分后的源项一致。从更新规则可知：\n$$\nc_i^{n+1} - c_i^{n+1/2} = \\Delta t (P - Q c_i^{n+1})\n$$\n对所有单元求和并乘以 $\\Delta x$：\n$$\n\\sum_i (c_i^{n+1} - c_i^{n+1/2}) \\Delta x = \\Delta t \\sum_i (P - Q c_i^{n+1}) \\Delta x\n$$\n$$\nM^{n+1} - M^{n+1/2} = \\Delta t \\sum_i R(c_i^{n+1}) \\Delta x\n$$\n这验证了总质量的变化精确等于在新时间层上计算的源项的离散积分，正如隐式方法所要求的那样。\n整个格式在时间上是一阶精确的，对于常数 $D$ 在空间上是二阶精确的，并且被设计为鲁棒地守恒和保正。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_one_step(params):\n    \"\"\"\n    Performs a single operator-split time step for the reactive diffusion equation\n    and verifies conservation and positivity properties.\n    \"\"\"\n    L, N, dt, c_init_func, D_func, P, Q, tol = params\n\n    # 1. Setup Grid and Initial Conditions\n    dx = L / N\n    # Cell centers\n    x_centers = (np.arange(N) + 0.5) * dx\n    c_n = c_init_func(x_centers, L)\n\n    # 2. Implicit Diffusion Step\n    \n    # Calculate D at cell centers\n    D_cell = D_func(x_centers, L)\n    \n    # Calculate D at internal faces using harmonic mean.\n    # D_face[i] corresponds to face between cell i and i+1\n    D_face = 2 * D_cell[:-1] * D_cell[1:] / (D_cell[:-1] + D_cell[1:] + 1e-30) # Add epsilon for safety\n    \n    # Assemble the tridiagonal system matrix A for A * c_half = c_n\n    # The system is rearranged from c_h - c_n = dt * Op * c_h to (I - dt*Op)c_h = c_n\n    alpha = dt / dx**2\n    \n    # The matrix for solve_banded is specified by its diagonals.\n    # It has shape (l+u+1, N), where l=1, u=1 are lower/upper bandwidths.\n    # ab[0, 1:] = upper diagonal\n    # ab[1, :]  = main diagonal\n    # ab[2, :-1]= lower diagonal\n    ab = np.zeros((3, N))\n    \n    # Upper/Lower diagonals (symmetric matrix)\n    # The element in the upper diagonal of row i is -alpha * D_{i+1/2}\n    # solve_banded expects ab[0, i+1] to be the (i, i+1) element.\n    # The element in the lower diagonal of row i is -alpha * D_{i-1/2}\n    # solve_banded expects ab[2, i-1] to be the (i, i-1) element.\n    \n    diag_val = -alpha * D_face\n    ab[0, 1:] = diag_val\n    ab[2, :-1] = diag_val\n    \n    # Main diagonal: 1 + alpha*(D_{i+1/2} + D_{i-1/2})\n    # For i=0, it's 1 + alpha*D_{1/2}. For i=N-1, it's 1 + alpha*D_{N-3/2}\n    main_diag = np.ones(N)\n    main_diag[:-1] += alpha * D_face\n    main_diag[1:] += alpha * D_face\n    ab[1, :] = main_diag\n\n    # Solve the tridiagonal system\n    c_half_step = solve_banded((1, 1), ab, c_n)\n    \n    # 3. Implicit Source Step\n    c_final = (c_half_step + dt * P) / (1.0 + dt * Q)\n    \n    # 4. Verification Checks\n    \n    # 4.1. Non-negativity of the final concentration\n    pass_negativity = np.min(c_final) >= 0.0\n    \n    # 4.2. Mass conservation during the diffusion step\n    mass_n = np.sum(c_n) * dx\n    mass_half = np.sum(c_half_step) * dx\n    pass_flux_cons = np.abs(mass_half - mass_n) = tol\n\n    # 4.3. Consistency of mass change with the source term\n    mass_final = np.sum(c_final) * dx\n    mass_change_actual = mass_final - mass_half\n    \n    # Theoretical mass change from source term integral: dt * sum(R(c_final)) * dx\n    # Where R(c) = P - Q*c is evaluated implicitly\n    source_integral = dt * np.sum(P - Q * c_final) * dx\n    pass_source_cons = np.abs(mass_change_actual - source_integral) = tol\n\n    return pass_negativity and pass_flux_cons and pass_source_cons\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the simulation and verification for each.\n    \"\"\"\n    tol = 1e-10\n\n    test_cases = [\n        # Case 1: Diffusion-only, variable D\n        (\n            1.0, 50, 1.0, \n            lambda x, L: 1.0 + 0.1 * np.cos(2 * np.pi * x / L),\n            lambda x, L: 1e-3 + 5e-4 * np.sin(2 * np.pi * x / L),\n            0.0, 0.0, tol\n        ),\n        # Case 2: Stiff decay with diffusion\n        (\n            1.0, 100, 1e-2,\n            lambda x, L: 1e-3 + np.exp(-(x - 0.5 * L)**2 / 5e-3),\n            lambda x, L: 1e-3 * (1.0 + 0.9 * np.exp(-(x - 0.5 * L)**2 / 1e-2)),\n            0.0, 1e3, tol\n        ),\n        # Case 3: Stiff production-destruction with diffusion\n        (\n            1.0, 80, 5e-2,\n            lambda x, L: 0.2 + 0.2 * np.sin(3 * np.pi * x / L),\n            lambda x, L: 5e-4 + 0*x, # Constant D\n            0.5, 200.0, tol\n        ),\n    ]\n\n    results = []\n    for params in test_cases:\n        test_passed = run_one_step(params)\n        results.append(test_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3507785"}, {"introduction": "隐式时间积分格式是处理刚性问题和进行大规模模拟的关键，但这需要我们高效求解非线性代数方程组。本练习[@problem_id:3507801]聚焦于此挑战，你将实现一个牛顿法求解器，并探索如何通过投影技术在迭代过程中强制施加物理约束（如浓度非负）。掌握这些技术对于开发稳定且收敛快速的模拟工具至关重要。", "problem": "考虑一个长度为 $L$ 的一维域上的单物种、等温输运-反应问题，其浓度场为 $c(x,t)$。其物种平衡的基础是局部守恒定律\n$$\n\\frac{\\partial c}{\\partial t} = \\nabla \\cdot \\left( D \\nabla c \\right) + R(c),\n$$\n其中 $D$ 是扩散系数，$R(c)$ 是反应源项。在一维设定下，使用均匀 Neumann（零通量）边界条件，并采用包含 $N$ 个宽度为 $\\Delta x = L/N$ 的控制体的均匀网格。应用有限体积法 (FVM)：将守恒定律在每个控制体 $V_i$ 上积分，并对面通量使用两点通量近似，从而得到一个离散平衡方程。使用大小为 $\\Delta t$ 的时间步长进行后向欧拉时间积分，可以得到一个关于新时间层上未知浓度 $\\{c_i^{n+1}\\}_{i=1}^N$ 的非线性代数系统，该系统可以写成残差形式\n$$\nF_i(\\mathbf{c}^{n+1}) = c_i^{n+1} - c_i^{n} - \\Delta t \\left( \\frac{D}{\\Delta x^2} \\sum_{j \\in \\mathcal{N}(i)} a_{ij} c_j^{n+1} + R(c_i^{n+1}) \\right) = 0,\n$$\n其中 $\\mathcal{N}(i)$ 表示在均匀 Neumann 边界条件下由两点通量离散化所产生的单元 $i$ 的邻近单元模板，而 $a_{ij}$ 是离散拉普拉斯模板系数。对于内部单元 $i$，这些系数强制执行二阶差分，而在边界处，它们通过适当的鬼点消除来编码零通量条件。\n\n我们关注非线性反应 $R(c) = -k_2 c^2$（其中 $k_2 \\ge 0$），设定 $L = 1$，并考虑无量纲量。该非线性系统将通过牛顿法求解，其更新方式描述如下\n$$\n\\mathbf{c}^{(m+1)} = \\mathbf{c}^{(m)} + \\gamma^{(m)} \\Delta \\mathbf{c}^{(m)},\n\\quad\n\\text{其中}\n\\quad\n\\left[ \\mathbf{J}(\\mathbf{c}^{(m)}) \\right] \\Delta \\mathbf{c}^{(m)} = - \\mathbf{F}(\\mathbf{c}^{(m)}).\n$$\n这里，$\\mathbf{J}$ 是雅可比矩阵，$\\gamma^{(m)} \\in (0,1]$ 是为确保残差单调递减而选择的线搜索参数。为了在牛顿迭代过程中防止出现非物理的负浓度，一种策略是将试探性更新投影到可行集 $c_i \\ge 0$ 上，定义如下\n$$\n\\mathbf{c}^{(m+1)} = \\mathcal{P}_{\\mathbb{R}_+^N} \\left( \\mathbf{c}^{(m)} + \\gamma^{(m)} \\Delta \\mathbf{c}^{(m)} \\right),\n$$\n其中 $\\mathcal{P}_{\\mathbb{R}_+^N}$ 表示到非负象限的欧几里得投影，即当分量为负时将其逐分量截断为零。这种投影修改了可行集边界附近的牛顿步，并可能影响收敛性质和离散守恒性。\n\n您的任务是编写一个完整的程序，该程序：\n- 为所述的具有均匀 Neumann 边界条件和二次汇项 $R(c) = -k_2 c^2$ 的问题，实现一维隐式 FVM 残差 $\\mathbf{F}(\\mathbf{c})$ 和雅可比矩阵 $\\mathbf{J}(\\mathbf{c})$。\n- 使用两种变体求解非线性系统：一种是无约束牛顿法，另一种是投影牛顿法，该方法在每次试探性更新后应用投影 $\\mathcal{P}_{\\mathbb{R}_+^N}$，并使用回溯线搜索来单调地减小残差范数。\n- 对于每种变体，报告从 $\\mathbf{c}^n$ 到 $\\mathbf{c}^{n+1}$ 的单个隐式步骤的以下指标：\n    1. $I_{\\text{conv}}$：一个整数指示符，如果求解器收敛到残差范数小于容差，则为 $1$，否则为 $0$。\n    2. $k_{\\text{it}}$：执行的牛顿迭代次数。\n    3. $c_{\\min}$：最终浓度向量的最小值。\n    4. $M_{\\text{err}}$：离散质量平衡误差，定义为 $\\sum_{i=1}^{N} F_i(\\mathbf{c}^{n+1})$，在残差方程的精确解处该值为零，否则量化了守恒性的违背程度。\n    5. $r_{\\text{norm}}$：最终残差的 $2$-范数 $\\|\\mathbf{F}(\\mathbf{c}^{n+1})\\|_2$。\n\n牛顿法必须从 $\\mathbf{c}^{(0)} = \\mathbf{c}^n$ 开始。线搜索必须单调地减小残差范数，并在达到足够的减小量或步长变得过小时终止。取残差范数容差为 $\\varepsilon = 10^{-10}$，最大迭代次数为 $50$。\n\n设计一个包含 $N$ 个单元的均匀网格，其中 $L = 1$，并使用以下参数值和初始条件的测试套件，这些测试套件用于检验方法的不同方面：\n\n- 测试用例 1 (仅扩散，理想情况)：\n    - $N = 50$, $\\Delta t = 0.01$, $D = 0.1$, $k_2 = 0$。\n    - 初始条件：$c_i^n = 1 + 0.2 \\sin(2\\pi x_i)$，其中 $x_i = (i+0.5)\\Delta x$, $i=0,\\dots,N-1$。\n- 测试用例 2 (弱扩散下的刚性非线性汇项)：\n    - $N = 50$, $\\Delta t = 0.1$, $D = 0.01$, $k_2 = 50$。\n    - 初始条件：$c_i^n = 0.05 + 0.02 \\sin(2\\pi x_i)$。\n- 测试用例 3 (仅反应且含零的边界情况)：\n    - $N = 10$, $\\Delta t = 0.2$, $D = 0$, $k_2 = 100$。\n    - 初始条件：$c_i^n = \\max(0, 0.1 - 0.02 i)$。\n\n您的程序必须为每个测试用例计算一个包含 10 个结果的元组\n$$\n\\left[\nI_{\\text{conv}}^{\\text{proj}},\nk_{\\text{it}}^{\\text{proj}},\nc_{\\min}^{\\text{proj}},\nM_{\\text{err}}^{\\text{proj}},\nr_{\\text{norm}}^{\\text{proj}},\nI_{\\text{conv}}^{\\text{unproj}},\nk_{\\text{it}}^{\\text{unproj}},\nc_{\\min}^{\\text{unproj}},\nM_{\\text{err}}^{\\text{unproj}},\nr_{\\text{norm}}^{\\text{unproj}}\n\\right],\n$$\n其中“proj”和“unproj”分别表示投影牛顿法和无约束牛顿法变体。所有浮点输出必须四舍五入到六位小数。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含三个测试用例的结果，格式为无空格、逗号分隔的列表的列表，例如\n$$\n\\left[ [ r_{11}, r_{12}, \\dots, r_{1,10} ], [ r_{21}, \\dots, r_{2,10} ], [ r_{31}, \\dots, r_{3,10} ] \\right],\n$$\n精确打印为\n$[[r_{11},r_{12},\\dots,r_{1,10}],[r_{21},\\dots,r_{2,10}],[r_{31},\\dots,r_{3,10}]]$,\n其中每个 $r_{jk}$ 都遵循上述类型和四舍五入规范。\n\n角度单位不出现。由于问题已经无量纲化，因此不需要物理单位；因此，所有报告的量都是无单位的实数或整数。程序不得要求任何用户输入，并且必须是完全自包含的。", "solution": "该问题是适定的、科学上合理的，并提供了求解所需的所有必要信息。它构成了使用有限体积法与牛顿-克雷洛夫求解器耦合求解非线性偏微分方程的一个标准练习。我们着手进行求解。\n\n问题的核心是求解一个非线性代数方程组，该方程组源于对控制反应-扩散偏微分方程 (PDE) 的离散化。该 PDE 由以下公式给出：\n$$\n\\frac{\\partial c}{\\partial t} = \\nabla \\cdot \\left( D \\nabla c \\right) + R(c)\n$$\n该方程定义在一维域 $x \\in [0, L]$（其中 $L=1$）上，并受制于 $x=0$ 和 $x=L$ 处的均匀 Neumann（零通量）边界条件。指定的反应项是一个二阶汇项，$R(c) = -k_2 c^2$。\n\n我们首先对 PDE 进行离散化。在包含 $N$ 个控制体（每个宽度为 $\\Delta x = L/N$）的均匀网格上应用有限体积法 (FVM)。单元 $i$（其中 $i=0, \\dots, N-1$）的中心位于 $x_i = (i+0.5)\\Delta x$。将 PDE 在一个控制体 $V_i = [x_i - \\Delta x/2, x_i + \\Delta x/2]$ 上积分并应用散度定理，得到：\n$$\n\\int_{V_i} \\frac{\\partial c}{\\partial t} dV = \\int_{\\partial V_i} (D \\nabla c) \\cdot \\mathbf{n} dS + \\int_{V_i} R(c) dV\n$$\n对单元 $i$ 逐个单元地近似积分，我们得到：\n$$\n\\Delta x \\frac{d c_i}{d t} \\approx \\left( D \\frac{\\partial c}{\\partial x} \\right)_{i+1/2} - \\left( D \\frac{\\partial c}{\\partial x} \\right)_{i-1/2} + \\Delta x R(c_i)\n$$\n其中 $c_i$ 是单元 $i$ 中的平均浓度，导数在单元面上求值。对各面上的通量使用中心差分近似，内部单元的扩散项变为：\n$$\n\\frac{1}{\\Delta x} \\left[ D \\frac{c_{i+1}-c_i}{\\Delta x} - D \\frac{c_i-c_{i-1}}{\\Delta x} \\right] = \\frac{D}{\\Delta x^2} (c_{i-1} - 2c_i + c_{i+1})\n$$\n使用鬼点来强制执行零通量边界条件。在 $x=0$ 处，通量为零，这意味着 $c_{-1}=c_0$。在 $x=L$ 处，通量为零，这意味着 $c_N=c_{N-1}$。这导出了以下离散扩散算子：\n- 对于单元 $i=0$：$\\frac{D}{\\Delta x^2} (c_1 - c_0)$\n- 对于单元 $i \\in (0, N-1)$：$\\frac{D}{\\Delta x^2} (c_{i-1} - 2c_i + c_{i+1})$\n- 对于单元 $i=N-1$：$\\frac{D}{\\Delta x^2} (c_{N-2} - c_{N-1})$\n\n应用后向欧拉法进行时间积分，其中 $\\frac{dc_i}{dt} \\approx \\frac{c_i^{n+1} - c_i^n}{\\Delta t}$，我们得到了一个关于未知浓度 $\\mathbf{c}^{n+1} = (c_0^{n+1}, \\dots, c_{N-1}^{n+1})$ 的非线性系统。该系统可以写成残差形式 $\\mathbf{F}(\\mathbf{c}^{n+1}) = \\mathbf{0}$，其中第 $i$ 个分量是：\n$$\nF_i(\\mathbf{c}^{n+1}) = c_i^{n+1} - c_i^{n} - \\Delta t \\left( \\text{Diffusion}_i(\\mathbf{c}^{n+1}) + R(c_i^{n+1}) \\right) = 0\n$$\n代入推导出的各项，对于 $\\mathbf{c} \\equiv \\mathbf{c}^{n+1}$ 我们得到：\n- 对于 $i=0$：$F_0(\\mathbf{c}) = c_0 - c_0^n - \\Delta t \\left( \\frac{D}{\\Delta x^2}(c_1 - c_0) - k_2 c_0^2 \\right)$\n- 对于 $0  i  N-1$：$F_i(\\mathbf{c}) = c_i - c_i^n - \\Delta t \\left( \\frac{D}{\\Delta x^2}(c_{i-1} - 2c_i + c_{i+1}) - k_2 c_i^2 \\right)$\n- 对于 $i=N-1$：$F_{N-1}(\\mathbf{c}) = c_{N-1} - c_{N-1}^n - \\Delta t \\left( \\frac{D}{\\Delta x^2}(c_{N-2} - c_{N-1}) - k_2 c_{N-1}^2 \\right)$\n\n这个非线性系统使用牛顿法求解。在每次迭代 $m$ 中，我们求解线性系统以获得更新量 $\\Delta\\mathbf{c}^{(m)}$：\n$$\n\\mathbf{J}(\\mathbf{c}^{(m)}) \\Delta\\mathbf{c}^{(m)} = -\\mathbf{F}(\\mathbf{c}^{(m)})\n$$\n其中 $\\mathbf{J}$ 是雅可比矩阵，其元素为 $J_{ij} = \\frac{\\partial F_i}{\\partial c_j}$。雅可比矩阵是一个三对角矩阵。定义 $\\alpha = \\frac{D \\Delta t}{\\Delta x^2}$，其非零元素为：\n- 对角线元素 $J_{ii}$：\n  - $J_{00} = 1 + \\alpha + 2 \\Delta t k_2 c_0$\n  - $J_{ii} = 1 + 2\\alpha + 2 \\Delta t k_2 c_i$ for $0  i  N-1$\n  - $J_{N-1,N-1} = 1 + \\alpha + 2 \\Delta t k_2 c_{N-1}$\n- 非对角线元素：\n  - $J_{i, i+1} = -\\alpha$ for $i=0, \\dots, N-2$\n  - $J_{i, i-1} = -\\alpha$ for $i=1, \\dots, N-1$\n\n解通过 $\\mathbf{c}^{(m+1)} = \\mathbf{c}^{(m)} + \\gamma^{(m)} \\Delta\\mathbf{c}^{(m)}$ 更新，其中 $\\gamma^{(m)} \\in (0, 1]$ 是通过回溯线搜索确定的步长，以确保残差范数的单调递减，即 $\\|\\mathbf{F}(\\mathbf{c}^{(m+1)})\\|_2  \\|\\mathbf{F}(\\mathbf{c}^{(m)})\\|_2$。\n\n为保持物理约束 $c_i \\ge 0$，投影牛顿法修改了更新步骤：\n$$\n\\mathbf{c}^{(m+1)} = \\mathcal{P}_{\\mathbb{R}_+^N} \\left( \\mathbf{c}^{(m)} + \\gamma^{(m)} \\Delta \\mathbf{c}^{(m)} \\right)\n$$\n其中 $\\mathcal{P}_{\\mathbb{R}_+^N}(\\mathbf{v})_i = \\max(v_i, 0)$ 是到非负象限的逐分量投影。该投影在线搜索内部应用，在计算试探步之后、评估新残差之前。\n\n单个时间步的算法如下：\n1. 初始化牛顿迭代：$\\mathbf{c}^{(0)} = \\mathbf{c}^n$，迭代计数器 $k_{\\text{it}} = 0$。\n2. 迭代直至收敛或达到最大迭代次数（$50$ 次）：\n    a. 计算残差 $\\mathbf{F}(\\mathbf{c}^{(k_{\\text{it}})})$ 及其 $2$-范数 $r_{\\text{norm}}$。\n    b. 如果 $r_{\\text{norm}}  10^{-10}$，则求解器已收敛。设置 $I_{\\text{conv}}=1$ 并退出循环。\n    c. 以带状格式组装雅可比矩阵 $\\mathbf{J}(\\mathbf{c}^{(k_{\\text{it}})})$。\n    d. 使用高效的带状求解器求解三对角系统 $\\mathbf{J} \\Delta\\mathbf{c} = -\\mathbf{F}$，以获得牛顿更新量 $\\Delta\\mathbf{c}$。\n    e. 执行回溯线搜索：从 $\\gamma=1$ 开始，并减小它（例如，减半），直到满足 $\\|\\mathbf{F}(\\mathbf{c}_{\\text{new}})\\|  r_{\\text{norm}}$ 或 $\\gamma$ 变得过小。对于无约束方法，新的候选解是 $\\mathbf{c}_{\\text{new}} = \\mathbf{c}^{(k_{\\text{it}})} + \\gamma \\Delta\\mathbf{c}$；对于投影方法，则是 $\\mathbf{c}_{\\text{new}} = \\mathcal{P}_{\\mathbb{R}_+^N}(\\mathbf{c}^{(k_{\\text{it}})} + \\gamma \\Delta\\mathbf{c})$。\n    f. 如果找到合适的步长，则更新 $\\mathbf{c}^{(k_{\\text{it}}+1)} = \\mathbf{c}_{\\text{new}}$。否则，线搜索失败，迭代终止。\n    g. 增加迭代计数器。\n3. 循环终止后，计算最终指标：$I_{\\text{conv}}$, $k_{\\text{it}}$, $c_{\\min} = \\min(\\mathbf{c}^{n+1})$, $M_{\\text{err}} = \\sum_i F_i(\\mathbf{c}^{n+1})$ 以及 $r_{\\text{norm}} = \\|\\mathbf{F}(\\mathbf{c}^{n+1})\\|_2$。\n\n该过程针对无约束和投影牛顿法两种变体进行实现，并应用于三个指定的测试用例。然后按要求收集并格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef calculate_residual(c, cn, N, dx, dt, D, k2):\n    \"\"\"\n    Computes the residual vector F(c) for the nonlinear system.\n    F(c) = c - cn - dt * (Diffusion(c) + Reaction(c)) = 0\n    \"\"\"\n    if np.any(np.isinf(c)) or np.any(np.isnan(c)):\n        return np.full_like(c, np.inf)\n\n    # Diffusion term\n    diff = np.zeros(N)\n    if D > 0:\n        # Interior cells\n        diff[1:-1] = (c[:-2] - 2 * c[1:-1] + c[2:])\n        # Neumann boundary conditions\n        diff[0] = (c[1] - c[0])\n        diff[-1] = (c[-2] - c[-1])\n        diff *= (D / dx**2)\n\n    # Reaction term\n    reac = -k2 * c**2\n    \n    res = c - cn - dt * (diff + reac)\n    return res\n\ndef calculate_jacobian(c, N, dx, dt, D, k2):\n    \"\"\"\n    Computes the Jacobian matrix J(c) in banded format for solve_banded.\n    J_ij = d(F_i)/d(c_j)\n    The format is l=1 lower diagonal, u=1 upper diagonal.\n    ab[0,:] = super-diagonal\n    ab[1,:] = main-diagonal\n    ab[2,:] = sub-diagonal\n    \"\"\"\n    ab = np.zeros((3, N))\n    alpha = D * dt / dx**2\n    \n    # Main diagonal: d/dc_i (c_i - dt*Diff_i - dt*Reac_i)\n    main_diag = 1.0 - dt * (-2.0 * D / dx**2) - dt * (-2.0 * k2 * c)\n    main_diag = 1.0 + 2.0 * alpha + 2.0 * dt * k2 * c\n    \n    ab[1, :] = main_diag\n    if D > 0:\n        # Boundary corrections for main diagonal\n        ab[1, 0] = 1.0 + alpha + 2.0 * dt * k2 * c[0]\n        ab[1, -1] = 1.0 + alpha + 2.0 * dt * k2 * c[-1]\n    \n    # Off-diagonals\n    if D > 0:\n        # Upper diagonal: d/dc_{i+1}\n        ab[0, 1:] = -alpha\n        # Lower diagonal: d/dc_{i-1}\n        ab[2, :-1] = -alpha\n        \n    return ab\n\ndef newton_solver(cn, N, dx, dt, D, k2, projected):\n    \"\"\"\n    Solves the nonlinear system F(c) = 0 using a Newton method.\n    \"\"\"\n    max_iter = 50\n    tol = 1e-10\n    \n    c = cn.copy()\n    i_conv = 0\n    k_it = 0\n\n    for k in range(max_iter):\n        res = calculate_residual(c, cn, N, dx, dt, D, k2)\n        res_norm = np.linalg.norm(res)\n\n        if res_norm  tol:\n            i_conv = 1\n            break\n        \n        k_it = k + 1\n\n        J_banded = calculate_jacobian(c, N, dx, dt, D, k2)\n        \n        try:\n            delta_c = solve_banded((1, 1), J_banded, -res)\n        except np.linalg.LinAlgError:\n            # Jacobian is singular, cannot proceed\n            break\n        \n        # Backtracking line search\n        gamma = 1.0\n        c_new = c  # Fallback if line search fails\n        found_step = False\n        while gamma > 1e-8:\n            c_temp = c + gamma * delta_c\n            if projected:\n                c_temp[c_temp  0] = 0.0\n            \n            res_new = calculate_residual(c_temp, cn, N, dx, dt, D, k2)\n            res_norm_new = np.linalg.norm(res_new)\n            \n            if res_norm_new  res_norm:\n                c_new = c_temp\n                found_step = True\n                break\n            \n            gamma /= 2.0\n        \n        if not found_step:\n            break\n        \n        c = c_new\n    else: # Loop finished without break\n        # Check final residual if max_iter was reached\n        res = calculate_residual(c, cn, N, dx, dt, D, k2)\n        res_norm = np.linalg.norm(res)\n        if res_norm  tol:\n            i_conv = 1\n\n    # Final metrics\n    final_res = calculate_residual(c, cn, N, dx, dt, D, k2)\n    final_res_norm = np.linalg.norm(final_res)\n    c_min = np.min(c)\n    m_err = np.sum(final_res)\n    \n    # Final check on convergence status\n    if final_res_norm >= tol:\n        i_conv = 0\n\n    return [i_conv, k_it, c_min, m_err, final_res_norm]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # (N, dt, D, k2, ic_type, ic_params)\n    test_cases = [\n        (50, 0.01, 0.1, 0.0, 'func', [lambda x: 1 + 0.2 * np.sin(2 * np.pi * x)]),\n        (50, 0.1, 0.01, 50.0, 'func', [lambda x: 0.05 + 0.02 * np.sin(2 * np.pi * x)]),\n        (10, 0.2, 0.0, 100.0, 'vector', [0.1, 0.02]),\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        N, dt, D, k2, ic_type, ic_params = case\n        L = 1.0\n        dx = L / N\n        \n        if ic_type == 'func':\n            xi = (np.arange(N) + 0.5) * dx\n            func = ic_params[0]\n            cn = func(xi)\n        elif ic_type == 'vector':\n            c_start, slope_coeff = ic_params\n            cn = np.maximum(0, c_start - slope_coeff * np.arange(N))\n\n        # Projected Newton solver\n        res_proj = newton_solver(cn, N, dx, dt, D, k2, projected=True)\n        # Unconstrained Newton solver\n        res_unproj = newton_solver(cn, N, dx, dt, D, k2, projected=False)\n        \n        # Combine and round floats\n        combined = res_proj + res_unproj\n        \n        formatted_list = [\n            combined[0], combined[1], round(combined[2], 6), round(combined[3], 6), round(combined[4], 6),\n            combined[5], combined[6], round(combined[7], 6), round(combined[8], 6), round(combined[9], 6)\n        ]\n        \n        all_results.append(formatted_list)\n\n    # Format the final output string\n    result_strings = []\n    for res_list in all_results:\n        result_strings.append(f\"[{','.join(map(str, res_list))}]\")\n        \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3507801"}, {"introduction": "许多真实世界的多物理场问题，如流固耦合或自由表面流，都涉及移动或变形的边界。本练习将你带入处理这类问题的标准方法——任意拉格朗日-欧拉（ALE）框架。通过从第一性原理推导和验证至关重要的几何守恒律（GCL）[@problem_id:3507787]，你将理解如何在动态变化的网格上依然精确地维持物理量的守恒性，这是保证ALE模拟准确性的基石。", "problem": "考虑一个无源标量在扭曲多边形网格上的二维有限体积离散化，该网格的顶点在时间 $t^n$ 和 $t^{n+1} = t^n + \\Delta t$ 之间经历仿射运动。其目标是在用于多物理场耦合模拟的任意拉格朗日-欧拉（ALE）格式的背景下，验证作为有限体积法（FVM）基础的守恒性质。出发点是积分形式的守恒律和雷诺输运定理：移动控制体内守恒量的积分变化率等于穿过边界的净通量加上源项。对于无源标量 $ \\phi $，ALE 形式下的积分形式控制方程为\n$$\n\\frac{d}{dt} \\int_{V(t)} \\phi \\, dV \\;+\\; \\oint_{\\partial V(t)} \\phi \\, (\\boldsymbol{u} - \\boldsymbol{w}) \\cdot \\boldsymbol{n} \\, dA \\;=\\; \\int_{V(t)} S \\, dV,\n$$\n其中，$ \\boldsymbol{u} $ 是物理速度，$ \\boldsymbol{w} $ 是网格速度，$ \\boldsymbol{n} $ 是单位外法线，$ S $ 是源项。对于几何守恒律（GCL），几何恒等式\n$$\n\\frac{d}{dt} \\, V(t) \\;=\\; \\oint_{\\partial V(t)} \\boldsymbol{w} \\cdot \\boldsymbol{n} \\, dA\n$$\n确保了在 $ \\boldsymbol{u} = \\boldsymbol{0} $ 和 $ S = 0 $ 的纯网格运动下，均匀标量场保持不变，前提是离散通量精确满足此恒等式的离散对应形式。\n\n您的任务是实现一个程序，从这些基本原理出发，构建一个扭曲的多边形网格，应用仿射网格运动，并使用基于面的通量来评估守恒的 ALE 有限体积更新和通量平衡。所有几何量必须从第一性原理计算：通过鞋带公式计算多边形面积，从边向量计算面长度和单位外法线。所有面通量必须使用网格速度的中点评估来组合计算。必须遵守物理单位：位置单位为米，时间单位为秒，速度单位为米/秒。不需要角度单位。不允许以百分比形式输出；将任何比率或变化表示为小数。\n\n首次使用时的定义：\n- 有限体积法（FVM）：一种使用与积分守恒律一致的面通量来演化单元平均量的方法。\n- 任意拉格朗日-欧拉（ALE）：一种允许网格以任意速度 $ \\boldsymbol{w} $ 移动，而物理场相对于网格以速度 $ \\boldsymbol{u} $ 平流的格式。\n- 几何守恒律（GCL）：将控制体体积变化与其面扫过的净网格体积等同起来的离散恒等式。\n\n离散化要求：\n- 对于一个在时间 $t^n$ 时顶点按逆时针顺序排列为 $\\{\\boldsymbol{x}_i\\}_{i=0}^{N-1}$ 的多边形单元，定义边 $\\boldsymbol{e}_i = \\boldsymbol{x}_{i+1} - \\boldsymbol{x}_i$，其中索引以 N 为模。单位外法线 $ \\boldsymbol{n}_i $ 必须是 $ \\boldsymbol{e}_i $ 的右手旋转向量除以其长度。\n- 在中点 $ \\boldsymbol{x}_f $ 处由网格运动引起的面通量必须计算为 $ \\boldsymbol{w}(\\boldsymbol{x}_f) \\cdot \\boldsymbol{n}_i \\, L_i $，其中 $ L_i $ 是面长度。\n- 对于一个时间步长的 ALE 标量更新，使用守恒更新\n$$\nM^{n+1} \\;=\\; M^n \\;-\\; \\Delta t \\sum_{f} \\phi_f \\, (\\boldsymbol{u} - \\boldsymbol{w}_f) \\cdot \\boldsymbol{n}_f \\, L_f,\n$$\n其中 $ M^n = \\phi^n \\, V^n $，并且 $ \\phi_f $ 根据 $ (\\boldsymbol{u} - \\boldsymbol{w}_f) \\cdot \\boldsymbol{n}_f $ 使用迎风格式选择。对于纯网格运动验证，设置 $ \\boldsymbol{u} = \\boldsymbol{0} $，并对均匀场使用 $ \\phi_f = \\phi^n $。计算 $ \\phi^{n+1} = M^{n+1} / V^{n+1} $。\n\n测试套件规范：\n使用指定参数实现以下测试套件，并按下文描述的精确格式生成汇总结果。\n\n网格定义（两个共享一个内面的扭曲四边形单元），在时间 $ t^n $ 时，位置单位为米：\n- 单元 $0$：顶点（逆时针） $[(0,0),\\, (1.2,0.0),\\, (1.4,1.0),\\, (0.2,1.0)]$。\n- 单元 $1$：顶点（逆时针） $[(1.2,0.0),\\, (2.0,0.0),\\, (2.1,1.0),\\, (1.4,1.0)]$。\n\n从 $ t^n $ 到 $ t^{n+1} $ 的仿射网格运动：\n- 时间步长 $ \\Delta t = 0.2 \\,$s。\n- 网格速度 $ \\boldsymbol{w}(\\boldsymbol{x}) = \\boldsymbol{a} + \\boldsymbol{B} \\boldsymbol{x} $，其中 $ \\boldsymbol{a} = (0.05,\\, -0.02) \\,$m/s 且\n$$\n\\boldsymbol{B} \\;=\\; \\begin{bmatrix} 0.0  0.1 \\\\ -0.05  0.0 \\end{bmatrix} \\;\\text{(单位为 s}^{-1}\\text{)}.\n$$\n通过 $ \\boldsymbol{x}^{n+1} = \\boldsymbol{x}^n + \\Delta t \\, \\boldsymbol{w}(\\boldsymbol{x}^n) $ 更新顶点。\n\n静止网格上的物理平流情况：\n- 物理速度 $ \\boldsymbol{u} = (0.6,\\, -0.3) \\,$m/s，静止网格 $ \\boldsymbol{w} = \\boldsymbol{0} $。\n- 所有外表面采用无流动边界条件：将边界平流通量设置为 $0$。\n- 在共享的内面上对 $ \\phi_f $ 使用迎风格式选择。\n\n标量初始条件：\n- 均匀场情况：两个单元均为 $ \\phi^n = 3.7 $（无量纲常数）。\n- 非均匀场情况：对于单元 $[0,\\,1]$，$ \\phi^n = [2.0,\\, 1.0] $。\n\n容差：\n- 对布尔检查使用绝对容差 $ \\varepsilon = 10^{-12} $。\n\n测试套件的必需输出：\n1. 对单元 $0$ 进行局部离散 GCL 检查：计算 $ \\Delta V = V^{n+1} - V^n $ 和离散扫描体积总和 $ S = \\Delta t \\sum_f \\boldsymbol{w}_f \\cdot \\boldsymbol{n}_f \\, L_f $，并返回布尔值 $ |\\Delta V - S| \\le \\varepsilon $。\n2. 对单元 $1$ 进行局部离散 GCL 检查：同 $1$ 中一样，对单元 $1$ 返回相应的布尔值。\n3. 纯网格运动下的均匀场保持性：在 $ \\boldsymbol{u} = \\boldsymbol{0} $ 的条件下计算两个单元的 $ \\phi^{n+1} $，并返回最大绝对偏差满足 $ \\max_i |\\phi_i^{n+1} - \\phi^n| \\le \\varepsilon $ 的布尔值。\n4. 在具有无流动边界的静止网格上进行物理平流的全局质量守恒：使用 $ \\boldsymbol{u} $ 和非均匀的 $ \\phi^n = [2.0,\\, 1.0] $，计算一个时间步长内的总标量质量变化，并将其作为浮点数 $ \\Delta M_{\\text{total}} = \\sum_i M_i^{n+1} - \\sum_i M_i^n $ 返回（以标量乘以面积的一致单位）。该值在数值上应接近 $0$；不要对其进行四舍五入，也不要在输出中附加单位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[r_1, r_2, r_3, r_4]$，其中 $r_1$ 和 $r_2$ 是 GCL 检查的布尔值，$r_3$ 是均匀场保持性的布尔值，$r_4$ 是全局质量变化的浮点数。例如，输出可能看起来像 $[True,True,True,1.234e-16]$。", "solution": "问题陈述在计算流体动力学领域提出了一个定义明确且有科学依据的任务，特别涉及用于任意拉格朗日-欧拉（ALE）格式的有限体积法（FVM）。所有必需的数据、定义和离散化规则都已提供，它们内部一致且符合既定原则。该问题是有效的。\n\n解决方案将通过首先根据所提供的规范建立几何和运动学辅助函数来实现。然后，我们将依次执行四个必需的计算。\n\n**1. 几何与运动学准备**\n\n首先，我们定义计算框架，包括网格、运动和物理参数，并实现必要的辅助函数。\n\n在时间 $t^n$ 时，单元 $0$ 和单元 $1$ 的顶点初始位置（单位为米，$m$）如下：\n- 单元 $0$：$C_0^n = \\{(0,0), (1.2,0.0), (1.4,1.0), (0.2,1.0)\\}$\n- 单元 $1$：$C_1^n = \\{(1.2,0.0), (2.0,0.0), (2.1,1.0), (1.4,1.0)\\}$\n\n时间步长为 $\\Delta t = 0.2 \\, s$。仿射网格速度场为 $\\boldsymbol{w}(\\boldsymbol{x}) = \\boldsymbol{a} + \\boldsymbol{B} \\boldsymbol{x}$，其中向量 $\\boldsymbol{a} = (0.05, -0.02) \\, m/s$，矩阵 $\\boldsymbol{B} = \\begin{bmatrix} 0.0  0.1 \\\\ -0.05  0.0 \\end{bmatrix} \\, s^{-1}$。在时间 $t^{n+1}$ 的顶点位置使用前向欧拉更新计算：$\\boldsymbol{x}^{n+1} = \\boldsymbol{x}^n + \\Delta t \\, \\boldsymbol{w}(\\boldsymbol{x}^n)$。\n\n需要一个计算多边形面积的函数。鞋带公式提供了一个直接的方法：对于一个具有 $N$ 个按逆时针顺序排列的顶点 $(\\boldsymbol{x}_i)_{i=0}^{N-1}$ 的多边形，其面积 $V$ 为：\n$$\nV = \\frac{1}{2} \\sum_{i=0}^{N-1} (x_i y_{i+1} - x_{i+1} y_i)\n$$\n其中索引 $i+1$ 对 $N$ 取模。\n\n对于单元的每个面，由边向量 $\\boldsymbol{e}_i = \\boldsymbol{x}_{i+1} - \\boldsymbol{x}_i = (\\Delta x_i, \\Delta y_i)$ 定义，我们需要其长度 $L_i$、单位外法线 $\\boldsymbol{n}_i$ 和中点 $\\boldsymbol{x}_{f,i}$。对于逆时针排序的多边形，外法线通过对边向量进行右手旋转得到。\n$$\nL_i = \\|\\boldsymbol{e}_i\\| = \\sqrt{\\Delta x_i^2 + \\Delta y_i^2}\n$$\n$$\n\\boldsymbol{n}_i = \\frac{(\\Delta y_i, -\\Delta x_i)}{L_i}\n$$\n$$\n\\boldsymbol{x}_{f,i} = \\frac{\\boldsymbol{x}_i + \\boldsymbol{x}_{i+1}}{2}\n$$\n\n**2. 任务 1 和 2：离散几何守恒律（GCL）检查**\n\n离散 GCL 验证单元计算体积的变化量是否等于其面扫过的总体积。体积变化量为 $\\Delta V = V^{n+1} - V^n$。使用带中点评估的一阶格式近似的面扫过的体积为 $S = \\Delta t \\sum_f \\boldsymbol{w}(\\boldsymbol{x}_f) \\cdot \\boldsymbol{n}_f L_f$。检查需要评估在容差 $\\varepsilon=10^{-12}$ 下，是否满足 $|\\Delta V - S| \\le \\varepsilon$。\n\n对于单元 $0$ 和单元 $1$：\n- 我们使用鞋带公式对初始顶点计算它们的初始面积 $V_0^n$ 和 $V_1^n$。\n- 我们计算两个单元在 $t^{n+1}$ 时的新顶点位置。\n- 我们从更新后的顶点计算新面积 $V_0^{n+1}$ 和 $V_1^{n+1}$。\n- 对于每个单元，我们遍历其在 $t^n$ 时的面，计算面长度 $L_f$、外法线 $\\boldsymbol{n}_f$ 和中点 $\\boldsymbol{x}_f$。在中点处，我们评估网格速度 $\\boldsymbol{w}_f = \\boldsymbol{w}(\\boldsymbol{x}_f)$ 并计算通量贡献 $\\boldsymbol{w}_f \\cdot \\boldsymbol{n}_f L_f$。\n- 这些贡献的总和乘以 $\\Delta t$，得到每个单元的总扫描体积 $S$。\n- 最后，我们对每个单元比较 $|\\Delta V - S|$ 与 $\\varepsilon$。\n\n**3. 任务 3：均匀场保持性**\n\n此任务验证 GCL 的一个关键推论：如果数值格式满足 GCL，则在纯网格运动（$\\boldsymbol{u}=\\boldsymbol{0}$）下，空间均匀的标量场应保持均匀。\n初始条件是两个单元的均匀标量场 $\\phi^n = 3.7$。单元中标量总量 $M = \\phi V$ 的守恒 ALE 更新为：\n$$\nM^{n+1} = M^n - \\Delta t \\sum_f \\phi_f (\\boldsymbol{u} - \\boldsymbol{w}_f) \\cdot \\boldsymbol{n}_f L_f\n$$\n当 $\\boldsymbol{u}=\\boldsymbol{0}$ 且对均匀场指定迎风选择 $\\phi_f = \\phi^n$ 时，该式简化为：\n$$\nM^{n+1} = M^n - \\Delta t \\sum_f \\phi^n (-\\boldsymbol{w}_f) \\cdot \\boldsymbol{n}_f L_f = \\phi^n V^n + \\Delta t \\, \\phi^n \\sum_f \\boldsymbol{w}_f \\cdot \\boldsymbol{n}_f L_f = \\phi^n (V^n + S/\\Delta t)\n$$\n新的标量值为 $\\phi^{n+1} = M^{n+1}/V^{n+1}$。代入 $M^{n+1}$ 的表达式：\n$$\n\\phi^{n+1} = \\frac{\\phi^n(V^n + S/\\Delta t)}{V^{n+1}} = \\phi^n \\frac{V^n \\Delta t + S}{\\Delta t V^{n+1}}\n$$\n与原始均匀值的偏差为 $|\\phi^{n+1} - \\phi^n| = |\\phi^n| \\frac{|V^n - V^{n+1} + S/\\Delta t|}{V^{n+1}} = |\\phi^n| \\frac{|S - \\Delta V|}{\\Delta t V^{n+1}}$。这表明均匀场的保持性与 GCL 是否满足直接相关。我们使用完整更新公式计算 $\\phi_0^{n+1}$ 和 $\\phi_1^{n+1}$，并检查是否 $\\max_i |\\phi_i^{n+1} - \\phi^n| \\le \\varepsilon$。\n\n**4. 任务 4：全局质量守恒**\n\n此任务验证该格式在封闭系统中是否保守标量总量。设置包括一个静止网格（$\\boldsymbol{w}=\\boldsymbol{0}$）、一个恒定的物理速度 $\\boldsymbol{u}=(0.6, -0.3) \\, m/s$ 以及在所有外表面上的无流动边界条件。初始标量场是非均匀的：$\\phi^n = [2.0, 1.0]$。\n\n由于网格是静止的，$V^{n+1}=V^n$。更新定律为 $M^{n+1} = M^n - \\Delta t \\sum_f \\phi_f (\\boldsymbol{u} \\cdot \\boldsymbol{n}_f) L_f$。\n无流动条件意味着穿过外表面的通量为零。唯一非零的通量是穿过单元 $0$ 和单元 $1$ 之间的共享内面。设此面长度为 $L_{int}$，法线 $\\boldsymbol{n}_{01}$ 从单元 $0$ 指向单元 $1$。单元 $1$ 在此面上的法线为 $\\boldsymbol{n}_{10} = -\\boldsymbol{n}_{01}$。\n穿过该面的对流速度为 $v_n = \\boldsymbol{u} \\cdot \\boldsymbol{n}_{01}$。\n迎风格式从“上游”单元选择标量值：\n- 如果 $v_n > 0$，流动方向为 $0 \\to 1$，因此 $\\phi_f = \\phi_0^n$。\n- 如果 $v_n  0$，流动方向为 $1 \\to 0$，因此 $\\phi_f = \\phi_1^n$。\n流出单元 $0$ 的总通量为 $F_0 = \\phi_f \\cdot v_n \\cdot L_{int}$。\n流出单元 $1$ 的总通量为 $F_1 = \\phi_f \\cdot (\\boldsymbol{u} \\cdot \\boldsymbol{n}_{10}) \\cdot L_{int} = \\phi_f \\cdot (-\\boldsymbol{u} \\cdot \\boldsymbol{n}_{01}) \\cdot L_{int} = -F_0$。\n更新公式为 $M_0^{n+1} = M_0^n - \\Delta t F_0$ 和 $M_1^{n+1} = M_1^n - \\Delta t F_1 = M_1^n + \\Delta t F_0$。\n最终总质量为 $M_{total}^{n+1} = M_0^{n+1} + M_1^{n+1} = (M_0^n - \\Delta t F_0) + (M_1^n + \\Delta t F_0) = M_0^n + M_1^n = M_{total}^n$。\n因此，总质量变化量 $\\Delta M_{total} = M_{total}^{n+1} - M_{total}^n$ 在浮点精度范围内应为零。我们直接计算此值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ALE FVM problem by performing four verification tasks.\n    \"\"\"\n    \n    # ------------------\n    # 1. SETUP: Parameters and Geometry\n    # ------------------\n    \n    # Constants and parameters from the problem statement\n    dt = 0.2  # s\n    a = np.array([0.05, -0.02])  # m/s\n    B = np.array([[0.0, 0.1], [-0.05, 0.0]])  # 1/s\n    u_phys = np.array([0.6, -0.3])  # m/s\n    epsilon = 1e-12\n    phi_uniform = 3.7\n    phi_nonuniform = [2.0, 1.0]\n\n    # Initial mesh vertices (t=t^n)\n    cell0_verts_n = [\n        np.array([0.0, 0.0]), np.array([1.2, 0.0]),\n        np.array([1.4, 1.0]), np.array([0.2, 1.0])\n    ]\n    cell1_verts_n = [\n        np.array([1.2, 0.0]), np.array([2.0, 0.0]),\n        np.array([2.1, 1.0]), np.array([1.4, 1.0])\n    ]\n    cells_n = [cell0_verts_n, cell1_verts_n]\n\n    # Helper functions\n    def polygon_area(vertices):\n        \"\"\"Calculates polygon area using the shoelace formula.\"\"\"\n        area = 0.0\n        for i in range(len(vertices)):\n            p1 = vertices[i]\n            p2 = vertices[(i + 1) % len(vertices)]\n            area += p1[0] * p2[1] - p2[0] * p1[1]\n        return 0.5 * abs(area)\n\n    def get_face_props(v1, v2):\n        \"\"\"Calculates face length, outward normal, and midpoint.\"\"\"\n        edge_vec = v2 - v1\n        length = np.linalg.norm(edge_vec)\n        if length  epsilon:\n            return 0.0, np.array([0.0, 0.0]), (v1 + v2) / 2.0\n        # Right-handed rotation for CCW polygon: (dy, -dx)\n        normal_vec = np.array([edge_vec[1], -edge_vec[0]])\n        unit_normal = normal_vec / length\n        midpoint = (v1 + v2) / 2.0\n        return length, unit_normal, midpoint\n\n    def w_vel(x):\n        \"\"\"Calculates grid velocity at a point x.\"\"\"\n        return a + B @ x\n\n    # ------------------\n    # Pre-calculations for all tasks\n    # ------------------\n\n    # Initial volumes\n    V_n = [polygon_area(c) for c in cells_n]\n\n    # Calculate all unique vertices at t^n and update them to t^{n+1}\n    all_verts_n = {}\n    for cell in cells_n:\n        for v in cell:\n            all_verts_n[tuple(v)] = v\n            \n    updated_verts_map = {\n        key: v + dt * w_vel(v) for key, v in all_verts_n.items()\n    }\n\n    # Construct cells at t^{n+1}\n    cells_nplus1 = []\n    for cell_n in cells_n:\n        cell_nplus1 = [updated_verts_map[tuple(v)] for v in cell_n]\n        cells_nplus1.append(cell_nplus1)\n    \n    # Volumes at t^{n+1}\n    V_nplus1 = [polygon_area(c) for c in cells_nplus1]\n\n\n    # ------------------\n    # TASK 1  2: Local Discrete GCL Check\n    # ------------------\n    \n    delta_V = [V_nplus1[i] - V_n[i] for i in range(2)]\n    S_discrete = [0.0, 0.0]\n\n    for i in range(2):\n        cell_verts = cells_n[i]\n        num_verts = len(cell_verts)\n        flux_sum = 0.0\n        for j in range(num_verts):\n            v1 = cell_verts[j]\n            v2 = cell_verts[(j + 1) % num_verts]\n            L, n, x_f = get_face_props(v1, v2)\n            w_f = w_vel(x_f)\n            flux_sum += np.dot(w_f, n) * L\n        S_discrete[i] = flux_sum\n\n    S_total = [dt * s for s in S_discrete]\n\n    r1 = abs(delta_V[0] - S_total[0]) = epsilon\n    r2 = abs(delta_V[1] - S_total[1]) = epsilon\n\n    # ------------------\n    # TASK 3: Uniform Field Preservation\n    # ------------------\n    \n    M_n_uniform = [phi_uniform * v for v in V_n]\n    phi_nplus1_uniform = [0.0, 0.0]\n\n    for i in range(2):\n        flux_sum = 0.0\n        cell_verts = cells_n[i]\n        num_verts = len(cell_verts)\n        for j in range(num_verts):\n            v1 = cell_verts[j]\n            v2 = cell_verts[(j + 1) % num_verts]\n            L, n, x_f = get_face_props(v1, v2)\n            w_f = w_vel(x_f)\n            # u=0 for pure mesh motion, so v_rel = -w_f\n            v_rel = -w_f  \n            # phi_f = phi^n for uniform field test\n            flux_sum += phi_uniform * np.dot(v_rel, n) * L\n\n        M_nplus1_i = M_n_uniform[i] - dt * flux_sum\n        phi_nplus1_uniform[i] = M_nplus1_i / V_nplus1[i]\n\n    max_dev = max(abs(p - phi_uniform) for p in phi_nplus1_uniform)\n    r3 = max_dev = epsilon\n\n    # ------------------\n    # TASK 4: Global Mass Conservation\n    # ------------------\n\n    M_total_n = phi_nonuniform[0] * V_n[0] + phi_nonuniform[1] * V_n[1]\n\n    # Identify internal face (from cell 0's perspective)\n    # Cell 0: [(0,0), (1.2,0), (1.4,1), (0.2,1)]; Face is (1.2,0)->(1.4,1)\n    v1_int = cells_n[0][1]\n    v2_int = cells_n[0][2]\n\n    # Get internal face properties from cell 0's perspective\n    L_int, n_int_0, _ = get_face_props(v1_int, v2_int)\n    \n    # Normal velocity relative to cell 0's outward normal\n    v_n = np.dot(u_phys, n_int_0)\n    \n    # Upwind flux\n    if v_n > 0: # Flow 0 -> 1\n        phi_f = phi_nonuniform[0]\n    else: # Flow 1 -> 0 or zero flow\n        phi_f = phi_nonuniform[1]\n        \n    # Flux out of Cell 0 across the internal face\n    flux_0_out = phi_f * v_n * L_int\n\n    # Update masses. Stationary mesh, so V is constant.\n    M0_n, M1_n = phi_nonuniform[0] * V_n[0], phi_nonuniform[1] * V_n[1]\n    \n    # Flux into Cell 1 is flux out of Cell 0. So flux out of Cell 1 is -flux_0_out\n    M0_nplus1 = M0_n - dt * flux_0_out\n    M1_nplus1 = M1_n - dt * (-flux_0_out)\n\n    M_total_nplus1 = M0_nplus1 + M1_nplus1\n    \n    r4 = M_total_nplus1 - M_total_n\n\n    # ------------------\n    # Final Output\n    # ------------------\n    results = [r1, r2, r3, r4]\n    \n    # Use str() to get 'True'/'False' for booleans\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3507787"}]}