{"hands_on_practices": [{"introduction": "为在有限差分法方面打下坚实的基础，我们从一个经典问题入手：模拟一维波动方程。本练习将指导你从基本的泰勒展开式推导出数值格式，并亲手实现它，以观察至关重要的数值稳定性概念[@problem_id:3129202]。通过经验性地测试Courant-Friedrichs-Lewy (CFL)条件（即$c \\frac{\\Delta t}{\\Delta x} \\le 1$），你将直观地理解为何显式方法的时间步长受限，以及如何判断模拟何时变得不稳定。", "problem": "考虑在区间 $[0,L]$ 上一根两端固定的拉紧弦的位移 $u(x,t)$，其运动由偏微分方程 $$u_{tt}(x,t) = c^2 u_{xx}(x,t),$$ 描述，其中 $c$ 是波速。弦的两端保持固定，意味着边界条件为 $u(0,t) = 0$ 和 $u(L,t) = 0$ (对所有 $t \\ge 0$ 成立)。初始位移给定为 $$u(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right),$$ 初始速度为 $$u_t(x,0) = 0.$$ 所有距离单位为米，时间单位为秒，波速 $c$ 的单位为米/秒。按照惯例，正弦函数使用弧度。\n\n你的任务是使用均匀网格间距，为此方程推导并实现一个在时间和空间上均为二阶精度的显式有限差分方法。从泰勒展开的基本原理和中心差分的定义出发，在均匀网格上近似 $u_{tt}$ 和 $u_{xx}$，并推导出将解从离散时间层 $n$ 推进到 $n+1$ 所需的更新规则。不要假设任何已有的格式：直接从定义出发构建该方法。在所有时间层，用固定的边界条件处理两个端点。对于第一个时间步，使用一个基于给定初始位置和初始速度的一致的二阶精度公式，来获得时间层 $n=1$ 处的解。\n\n通过运行一系列参数值的格式，并观察数值解是保持有界还是发散，使用 Courant–Friedrichs–Lewy (CFL) 条件来经验性地评估稳定性。定义一个经验性发散检测器如下：令 $M_0$ 为空间网格上 $u(x,0)$ 的最大绝对值。在时间步进过程中，计算 $M_n$，即时间层 $n$ 上所有空间点的最大绝对值。如果在任何时刻 $M_n$ 变为未定义 (非数值)、无穷大或超过 $10 M_0$，则声明模拟不稳定 (发散)；否则，声明其稳定。该检测器必须在你的程序中实现。\n\n对于空间离散化，使用在 $[0,L]$ 上的一个包含 $N_x$ 个点的均匀网格，间距为 $\\Delta x = L/(N_x - 1)$ 米。对于时间离散化，使用均匀时间步长 $\\Delta t$ 秒，并模拟到最终时间 $T$ 秒。对每个测试用例，计算布尔稳定性结果，其中 $True$ 表示稳定，$False$ 表示发散。\n\n实现你的程序以运行以下测试套件，该套件涵盖一个典型情况、一个接近 CFL 极限的边界情况以及超出极限的情况：\n- 测试 $1$：$c = 1.0$ 米/秒，$L = 1.0$ 米，$N_x = 101$，$\\Delta t = 0.008$ 秒，$T = 0.5$ 秒。\n- 测试 $2$：$c = 1.0$ 米/秒，$L = 1.0$ 米，$N_x = 101$，$\\Delta t = 0.010$ 秒，$T = 0.5$ 秒。\n- 测试 $3$：$c = 1.0$ 米/秒，$L = 1.0$ 米，$N_x = 101$，$\\Delta t = 0.015$ 秒，$T = 1.0$ 秒。\n- 测试 $4$：$c = 2.0$ 米/秒，$L = 1.0$ 米，$N_x = 101$，$\\Delta t = 0.010$ 秒，$T = 0.5$ 秒。\n\n你的程序应产生单行输出，其中包含一个方括号括起来的逗号分隔的结果列表 (例如 $[result_1,result_2,result_3,result_4]$)，其中每个 $result_k$ 是你的经验性发散检测器为测试 $k$ 计算出的布尔稳定性结果。不应打印任何额外文本。输出的布尔值没有物理单位。涉及 $c$、$L$、$\\Delta x$、$\\Delta t$ 和 $T$ 的输入和计算必须按规定统一使用米和秒。", "solution": "我们从通过泰勒展开得到中心差分的基本定义开始。在一个间距为 $\\Delta x$ 的均匀空间网格和一个步长为 $\\Delta t$ 的均匀时间网格上，令 $x_i = i \\Delta x$ ($i = 0,1,\\dots,N_x-1$) 和 $t^n = n \\Delta t$ ($n = 0,1,2,\\dots$)。令 $u_i^n$ 表示 $u(x_i,t^n)$ 的数值近似。\n\n在点 $(x_i,t^n)$ 处，二阶时间导数的二阶中心差分近似由泰勒展开\n$$u(x_i,t^{n\\pm 1}) = u(x_i,t^n) \\pm \\Delta t \\, u_t(x_i,t^n) + \\frac{\\Delta t^2}{2} u_{tt}(x_i,t^n) \\pm \\frac{\\Delta t^3}{6} u_{ttt}(x_i,t^n) + \\cdots,$$\n得到\n$$u_{tt}(x_i,t^n) \\approx \\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2}.$$\n类似地，对于二阶空间导数，使用空间上的泰勒展开，\n$$u(x_{i\\pm 1},t^n) = u(x_i,t^n) \\pm \\Delta x \\, u_x(x_i,t^n) + \\frac{\\Delta x^2}{2} u_{xx}(x_i,t^n) \\pm \\frac{\\Delta x^3}{6} u_{xxx}(x_i,t^n) + \\cdots,$$\n我们得到\n$$u_{xx}(x_i,t^n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.$$\n\n将这些近似代入内部点 $i = 1,2,\\dots,N_x-2$ 处的波动方程 $u_{tt} = c^2 u_{xx}$，得到离散方程\n$$\\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2} = c^2 \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.$$\n对其进行整理以得到从时间层 $n$ 到 $n+1$ 的更新，便得到显式格式\n$$u_i^{n+1} = 2 u_i^n - u_i^{n-1} + r^2 \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right),$$\n其中我们定义了无量纲 Courant 数\n$$r = \\frac{c \\, \\Delta t}{\\Delta x}.$$\n\n边界条件是 $u_0^n = 0$ 和 $u_{N_x-1}^n = 0$ (对所有 $n$ 成立)。初始条件提供了 $u_i^0 = \\sin\\left(\\frac{\\pi x_i}{L}\\right)$ (对所有 $i$ 成立)，这与固定端点一致，因为 $\\sin(0) = 0$ 且 $\\sin(\\pi) = 0$。为了初始化该格式，我们还需要 $u_i^1$。使用在 $t=0$ 附近关于时间的二阶精度泰勒展开，并利用给定的初始速度 $u_t(x,0)=0$，我们得到\n$$u(x_i,\\Delta t) \\approx u(x_i,0) + \\Delta t \\, u_t(x_i,0) + \\frac{\\Delta t^2}{2} u_{tt}(x_i,0).$$\n将 $u_{tt}(x_i,0)$ 替换为 $c^2 u_{xx}(x_i,0)$，并在时间 $n=0$ 应用中心空间差分，得到\n$$u_i^1 = u_i^0 + \\Delta t \\cdot 0 + \\frac{1}{2} r^2 \\left(u_{i+1}^0 - 2 u_i^0 + u_{i-1}^0\\right), \\quad \\text{for } i=1,\\dots,N_x-2,$$\n其中 $u_0^1 = 0$ 且 $u_{N_x-1}^1 = 0$。\n\nCourant–Friedrichs–Lewy (CFL) 条件源于稳定性分析 (例如，通过 von Neumann 傅里叶模态分析)。对于上述显式二阶中心差分格式，应用于单个傅里叶模的放大因子 $G$ 满足一个稳定性约束，该约束导致要求\n$$r \\le 1.$$\n当 $r \\le 1$ 时，所有傅里叶模都满足 $|G| \\le 1$，方法是稳定的；当 $r > 1$ 时，某些模的 $|G| > 1$，这会导致指数增长和数值发散。\n\n算法设计原则：\n- 使用米和秒定义物理和数值参数 $c$、$L$、$N_x$、$\\Delta t$、$T$。\n- 计算网格间距 $\\Delta x = L/(N_x-1)$ 和 Courant 数 $r = c \\Delta t / \\Delta x$。\n- 初始化 $u_i^0 = \\sin(\\pi x_i / L)$ ($i=0,\\dots,N_x-1$) 和 $u_t(x,0) = 0$。\n- 使用包含 $u_{tt}(x,0) = c^2 u_{xx}(x,0)$ 的二阶公式计算 $u^1$。\n- 对于 $n \\ge 1$，在内部点使用显式更新来推进 $u^{n+1}$，并在端点强制执行边界条件。\n- 在每个时间步，计算 $M_n = \\max_i |u_i^n|$ 并应用经验性发散检测器：如果 $M_n$ 变为非数值、无穷大或超过 $10 M_0$ (其中 $M_0 = \\max_i |u_i^0|$ )，则声明为不稳定；否则继续直到最终时间 $T$。\n- 返回一个布尔值表示稳定性。\n\n测试套件原理：\n- 测试 $1$ 选择 $r = 0.8$ ($c = 1.0$, $\\Delta t = 0.008$, $\\Delta x = 0.01$) 作为一个典型的稳定情况。\n- 测试 $2$ 设置 $r = 1.0$ 作为一个边界情况，对于此格式应保持稳定。\n- 测试 $3$ 使用 $r = 1.5$ 和更长的最终时间，以确保不稳定性在经验上显现出来。\n- 测试 $4$ 使用 $r = 2.0$，远超 CFL 极限，会迅速发散。\n\n基于 CFL 条件和经验性检测的预期结果：\n- 测试 $1$：$True$ (稳定)。\n- 测试 $2$：$True$ (稳定)。\n- 测试 $3$：$False$ (发散)。\n- 测试 $4$：$False$ (发散)。\n\n最终程序将这些布尔值汇总，并按要求将它们打印为包含在方括号内的单个逗号分隔列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_wave_1d_stability(c, L, Nx, dt, T):\n    \"\"\"\n    Simulate the 1D wave equation u_tt = c^2 u_xx with fixed ends using\n    second-order central differences in space and time. Empirically detect\n    instability (blow-up) via amplitude growth and NaN/Inf checks.\n\n    Parameters:\n        c  (float): wave speed (m/s)\n        L  (float): domain length (m)\n        Nx (int):   number of spatial grid points\n        dt (float): time step (s)\n        T  (float): final time (s)\n\n    Returns:\n        bool: True if stable (no blow-up detected), False otherwise.\n    \"\"\"\n    # Spatial discretization\n    dx = L / (Nx - 1)\n    x = np.linspace(0.0, L, Nx)\n\n    # Courant number\n    r = c * dt / dx\n\n    # Initial displacement u(x,0) = sin(pi x / L), initial velocity = 0\n    u0 = np.sin(np.pi * x / L)\n    # Boundary conditions are fixed ends: u(0,t) = 0, u(L,t) = 0\n    u0[0] = 0.0\n    u0[-1] = 0.0\n\n    # Prepare arrays for time stepping\n    u_prev = u0.copy()\n\n    # Compute u^1 using second-order accurate initialization:\n    # u^1 = u^0 + dt * v^0 + (dt^2 / 2) * c^2 * u_xx^0\n    # with v^0 = 0 and u_xx^0 approximated by central differences\n    u_curr = u0.copy()\n    # interior update for the first step\n    # u_curr[i] = u_prev[i] + 0 + 0.5 * r^2 * (u_prev[i+1] - 2*u_prev[i] + u_prev[i-1])\n    for i in range(1, Nx - 1):\n        u_curr[i] = u_prev[i] + 0.5 * (r ** 2) * (u_prev[i + 1] - 2.0 * u_prev[i] + u_prev[i - 1])\n    # Enforce boundary conditions\n    u_curr[0] = 0.0\n    u_curr[-1] = 0.0\n\n    # Empirical blow-up detector thresholds\n    M0 = np.max(np.abs(u0))\n    if not np.isfinite(M0):\n        return False  # pathological, treat as blow-up\n    threshold = 10.0 * (M0 if M0 > 0 else 1.0)  # avoid zero threshold\n\n    # Number of time steps\n    n_steps = int(np.floor(T / dt))\n\n    # Time stepping\n    for _ in range(1, n_steps):\n        u_next = u_curr.copy()\n        # Explicit update for interior points:\n        # u_next[i] = 2*u_curr[i] - u_prev[i] + r^2 * (u_curr[i+1] - 2*u_curr[i] + u_curr[i-1])\n        for i in range(1, Nx - 1):\n            u_next[i] = (\n                2.0 * u_curr[i]\n                - u_prev[i]\n                + (r ** 2) * (u_curr[i + 1] - 2.0 * u_curr[i] + u_curr[i - 1])\n            )\n        # Enforce boundary conditions\n        u_next[0] = 0.0\n        u_next[-1] = 0.0\n\n        # Check for blow-up\n        M_n = np.max(np.abs(u_next))\n        if not np.isfinite(M_n) or M_n > threshold:\n            return False\n\n        # Rotate time levels\n        u_prev, u_curr = u_curr, u_next\n\n    # If reached final time without blow-up, declare stable\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (c, L, Nx, dt, T)\n    test_cases = [\n        (1.0, 1.0, 101, 0.008, 0.5),  # r = 0.8, expected stable\n        (1.0, 1.0, 101, 0.010, 0.5),  # r = 1.0, expected stable\n        (1.0, 1.0, 101, 0.015, 1.0),  # r = 1.5, expected unstable\n        (2.0, 1.0, 101, 0.010, 0.5),  # r = 2.0, expected unstable\n    ]\n\n    results = []\n    for c, L, Nx, dt, T in test_cases:\n        result = simulate_wave_1d_stability(c, L, Nx, dt, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3129202"}, {"introduction": "真实世界的问题常常涉及多种物理现象的耦合。本练习旨在探究多物理场仿真的一个关键挑战：一个组件的误差如何传播并降低整个系统的精度[@problem_id:3507199]。你将使用“制造解方法”(method of manufactured solutions)，为一个变量故意引入一个不一致的、仅有$\\mathcal{O}(\\Delta x)$精度的边界条件，并量化这个局部误差如何“污染”与之耦合的另一个变量的解，从而将整个系统的全局收敛阶从理论上的$\\mathcal{O}(\\Delta x^2)$拉低。", "problem": "构造一个自洽的数值实验，用于分析不一致的边界封闭如何影响耦合有限差分系统，并量化误差如何通过耦合泄漏。考虑在域 $[0,1]$ 上的以下对称、线性、稳态、耦合边值问题：\n- 内部方程：$-u''(x) + \\kappa\\,(u(x) - v(x)) = s_u(x)$ 和 $-v''(x) + \\kappa\\,(v(x) - u(x)) = s_v(x)$，对于 $x \\in (0,1)$，其中 $\\kappa \\ge 0$ 是一个常数耦合强度。\n- 边界条件：在 $x=0$ 处为 $u(0) = u_{\\text{exact}}(0)$ 和 $v(0) = v_{\\text{exact}}(0)$ (狄利克雷)，在 $x=1$ 处为 $u'(1) = u'_{\\text{exact}}(1)$ 和 $v'(1) = v'_{\\text{exact}}(1)$ (诺伊曼)。\n\n使用精确解方法。通过以下方式定义精确场：\n$$u_{\\text{exact}}(x) = \\sin(2\\pi x) + x,$$\n$$v_{\\text{exact}}(x) = \\cos(2\\pi x) - \\tfrac{1}{2}x,$$\n并从内部方程计算源项 $s_u(x)$ 和 $s_v(x)$，使得对于任何选定的 $\\kappa$，精确场都满足连续问题：\n$$s_u(x) = -u_{\\text{exact}}''(x) + \\kappa\\left(u_{\\text{exact}}(x) - v_{\\text{exact}}(x)\\right),$$\n$$s_v(x) = -v_{\\text{exact}}''(x) + \\kappa\\left(v_{\\text{exact}}(x) - u_{\\text{exact}}(x)\\right).$$\n\n在具有 $N$ 个相等子区间和间距 $\\Delta x = 1/N$ 的均匀网格上进行离散化，网格点为 $x_i = i\\,\\Delta x$，其中 $i \\in \\{0,1,\\dots,N\\}$。使用以下有限差分法基础：\n- 使用标准的二阶中心差分来近似内部的二阶导数：$w''(x_i) \\approx \\left(w_{i-1} - 2 w_i + w_{i+1}\\right)/\\Delta x^2$，对于 $i \\in \\{1,2,\\dots,N-1\\}$，其中 $w$ 代表 $u$ 或 $v$。\n- 在 $x=0$ 处，通过在内部模板中直接使用精确值 $u_0 = u_{\\text{exact}}(0)$ 和 $v_0 = v_{\\text{exact}}(0)$ 来施加狄利克雷数据；在 $x=0$ 处不需要边界方程。\n- 在 $x=1$ 处，通过用导数的单侧有限差分封闭替换在 $i=N$ 处的内部方程来施加诺伊曼边界条件。有两种封闭可用：\n  1. 一阶后向差分：$w'(1) \\approx \\left(w_N - w_{N-1}\\right)/\\Delta x$。\n  2. 二阶后向差分：$w'(1) \\approx \\left(3 w_N - 4 w_{N-1} + w_{N-2}\\right)/(2\\Delta x)$。\n此处 $w$ 同样代表 $u$ 或 $v$。您必须能够在 $x=1$ 处为 $u$ 和 $v$ 分配不同的封闭阶数，以有意地创建不一致的边界封闭。\n\n需要实现的任务：\n- 根据上述规则，在网格节点 $i \\in \\{1,2,\\dots,N\\}$ 处组装并求解 $(u_i,v_i)$ 的离散线性系统。\n- 对于给定的 $N$，计算每个场的节点误差的离散 $\\ell^2$-范数，定义为\n$$\\|e_u\\|_{2,h} = \\sqrt{\\Delta x \\sum_{i=0}^{N} \\left(u_i - u_{\\text{exact}}(x_i)\\right)^2}, \\quad \\|e_v\\|_{2,h} = \\sqrt{\\Delta x \\sum_{i=0}^{N} \\left(v_i - v_{\\text{exact}}(x_i)\\right)^2},$$\n其中 $u_0$ 和 $v_0$ 是施加的精确狄利克雷值，而 $u_i, v_i$ (对于 $i \\ge 1$) 是计算出的未知数。\n- 使用网格加密（使用 $N$ 和 $2N$）量化观测到的精度阶：\n$$p_u = \\log_2\\left(\\frac{\\|e_u\\|_{2,h}}{\\|e_u\\|_{2,h/2}}\\right), \\quad p_v = \\log_2\\left(\\frac{\\|e_v\\|_{2,h}}{\\|e_v\\|_{2,h/2}}\\right).$$\n\n设计一个测试套件，以揭示不一致的边界封闭和误差通过耦合泄漏的影响：\n- 测试用例 1：$\\kappa = 1$，在 $x=1$ 处对 $u$ 使用一阶诺伊曼封闭，对 $v$ 使用二阶诺伊曼封闭。\n- 测试用例 2：$\\kappa = 1$，在 $x=1$ 处对 $u$ 使用二阶诺伊曼封闭，对 $v$ 使用一阶诺伊曼封闭。\n- 测试用例 3：$\\kappa = 0$ (解耦)，在 $x=1$ 处对 $u$ 使用一阶诺伊曼封闭，对 $v$ 使用二阶诺伊曼封闭。\n- 测试用例 4：$\\kappa = 1$，在 $x=1$ 处对 $u$ 和 $v$ 都使用二阶诺伊曼封闭。\n\n对于每个测试用例，使用具有足够大的 $N$ 的加密对 $(N,2N)$ 计算 $(p_u,p_v)$，以达到渐近区域。您的程序应使用 $N=64$ 和 $2N=128$。\n\n您的程序必须生成单行输出，其中包含一个包含在方括号中的逗号分隔列表的结果，顺序为 $[p_u^{(1)},p_v^{(1)},p_u^{(2)},p_v^{(2)},p_u^{(3)},p_v^{(3)},p_u^{(4)},p_v^{(4)}]$，其中上标表示测试用例索引。每个条目都必须是浮点数。此问题不涉及物理单位，角度单位也无关紧要。\n\n目标是分析并报告一个场中的一阶边界封闭如何降低耦合系统的全局精度，并确认对两个场使用匹配的二阶封闭可以恢复二阶精度 $O(\\Delta x^2)$。", "solution": "该问题要求构建一个数值实验，以研究不一致的边界条件离散化对两个二阶常微分方程耦合系统的影响。采用精确解方法提供一个精确的解析解，以便与数值近似进行比较。分析的重点是一个变量的低阶边界封闭如何通过耦合项污染两个变量的解的精度。\n\n连续问题在域 $x \\in [0,1]$ 上由以下耦合方程定义：\n$$ -u''(x) + \\kappa\\,(u(x) - v(x)) = s_u(x) $$\n$$ -v''(x) + \\kappa\\,(v(x) - u(x)) = s_v(x) $$\n具有混合边界条件：在 $x=0$ 处为狄利克雷条件，在 $x=1$ 处为诺伊曼条件。耦合强度由常数 $\\kappa \\ge 0$ 给出。源项 $s_u(x)$ 和 $s_v(x)$ 是被构造出来的，以确保精确解 $u_{\\text{exact}}(x) = \\sin(2\\pi x) + x$ 和 $v_{\\text{exact}}(x) = \\cos(2\\pi x) - \\frac{1}{2}x$ 满足该系统。\n\n第一步是使用有限差分法在包含 $N+1$ 个点 $x_i = i\\Delta x$（其中 $i \\in \\{0, 1, \\dots, N\\}$）的均匀网格上对问题进行离散化，网格间距为 $\\Delta x = 1/N$。我们离散系统的未知数是节点值 $\\{u_i, v_i\\}$，其中 $i \\in \\{1, 2, \\dots, N\\}$，因为 $u_0$ 和 $v_0$ 由狄利克雷边界条件给出。这总共得到 $2N$ 个未知数，我们可以将它们排列成单个向量 $\\mathbf{z} = [u_1, u_2, \\dots, u_N, v_1, v_2, \\dots, v_N]^T$。\n\n对于内部网格点 $i \\in \\{1, 2, \\dots, N-1\\}$，我们使用标准的二阶中心差分公式来近似二阶导数：$w''(x_i) \\approx (w_{i-1} - 2w_i + w_{i+1})/\\Delta x^2$。将此应用于控制方程，得到：\n$$ -\\frac{u_{i-1} - 2u_i + u_{i+1}}{\\Delta x^2} + \\kappa(u_i - v_i) = s_u(x_i) $$\n$$ -\\frac{v_{i-1} - 2v_i + v_{i+1}}{\\Delta x^2} + \\kappa(v_i - u_i) = s_v(x_i) $$\n两边乘以 $\\Delta x^2$ 并将未知项归到左侧，我们得到节点 $i$ 的代数方程：\n$$ -u_{i-1} + (2 + \\kappa\\Delta x^2)u_i - u_{i+1} - \\kappa\\Delta x^2 v_i = \\Delta x^2 s_u(x_i) $$\n$$ -v_{i-1} + (2 + \\kappa\\Delta x^2)v_i - v_{i+1} - \\kappa\\Delta x^2 u_i = \\Delta x^2 s_v(x_i) $$\n\n在边界处需要特殊处理。\n在 $x_0 = 0$ 处，狄利克雷条件 $u_0 = u_{\\text{exact}}(0)$ 和 $v_0 = v_{\\text{exact}}(0)$ 是给定的。对于 $i=1$ 处的方程，涉及 $u_0$ 和 $v_0$ 的项是已知常数，并被移到线性系统的右侧：\n$$ (2 + \\kappa\\Delta x^2)u_1 - u_2 - \\kappa\\Delta x^2 v_1 = \\Delta x^2 s_u(x_1) + u_{\\text{exact}}(0) $$\n$$ (2 + \\kappa\\Delta x^2)v_1 - v_2 - \\kappa\\Delta x^2 u_1 = \\Delta x^2 s_v(x_1) + v_{\\text{exact}}(0) $$\n\n在 $x_N = 1$ 处，施加诺伊曼条件 $u'(1) = u'_{\\text{exact}}(1)$ 和 $v'(1) = v'_{\\text{exact}}(1)$。内部方程被这些导数条件的离散近似所取代。\n对于一般函数 $w$ 的一阶后向差分为：\n$$ \\frac{w_N - w_{N-1}}{\\Delta x} = w'_{\\text{exact}}(1) \\implies -w_{N-1} + w_N = \\Delta x \\, w'_{\\text{exact}}(1) $$\n二阶后向差分为：\n$$ \\frac{3w_N - 4w_{N-1} + w_{N-2}}{2\\Delta x} = w'_{\\text{exact}}(1) \\implies w_{N-2} - 4w_{N-1} + 3w_N = 2\\Delta x \\, w'_{\\text{exact}}(1) $$\n这些关于 $u$ 和 $v$ 的方程（取决于测试用例）提供了线性系统的最后两行。值得注意的是，这些特定的边界封闭方程是非耦合的；$u_N$ 的方程仅涉及其他的 $u_i$ 值，对于 $v_N$ 也类似。\n\n将这 $2N$ 个方程组合起来，得到一个形如 $A\\mathbf{z} = \\mathbf{b}$ 的线性系统，其中 $A$ 是一个 $2N \\times 2N$ 的矩阵。矩阵 $A$ 具有 $2 \\times 2$ 的块结构：\n$$ A = \\begin{pmatrix} A_{uu}  A_{uv} \\\\ A_{vu}  A_{vv} \\end{pmatrix} $$\n矩阵 $A_{uu}$ 和 $A_{vv}$ 包含离散化的二阶导数算子和耦合项的对角部分。它们的前 $N-1$ 行是三对角的，并在最后一行由诺伊曼边界条件模板修改。矩阵 $A_{uv}$ 和 $A_{vu}$ 表示非对角耦合，并且是对角矩阵，具体为 $A_{uv} = A_{vu} = -\\kappa\\Delta x^2 I_{N \\times N}$，除了它们的最后一行由于所选诺伊曼模板的非耦合性质而为零。右端向量 $\\mathbf{b}$ 包含计算出的源项值和已知的边界值。\n\n在求解系统 $A\\mathbf{z} = \\mathbf{b}$ 以获得未知向量 $\\mathbf{z}$ 后，我们得到数值解 $u_i$ 和 $v_i$，其中 $i \\in \\{1, \\dots, N\\}$。然后我们使用提供的公式计算每个场的误差的离散 $\\ell^2$-范数，$\\|e_u\\|_{2,h}$ 和 $\\|e_v\\|_{2,h}$。这个过程对两种网格分辨率 $N$ 和 $2N$ 执行。然后，观测到的精度阶 $p$ 计算如下：\n$$ p = \\log_2\\left(\\frac{\\|e\\|_{2,h}}{\\|e\\|_{2,h/2}}\\right) $$\n对于每个场，其中 $h = 1/N$。\n\n该框架被应用于四个指定的测试用例。\n- 用例 1 ($\\kappa=1$, $u$-封闭为一阶, $v$-封闭为二阶)：预计 $u$-变量中的一阶误差源会通过耦合项污染 $v$-变量，导致 $p_u \\approx 1$ 和 $p_v \\approx 1$。\n- 用例 2 (与用例 1 对称)：类似地，我们预计 $p_u \\approx 1$ 和 $p_v \\approx 1$。\n- 用例 3 ($\\kappa=0$, 解耦系统)：每个变量中的误差完全由其自身的离散化决定。我们预计 $p_u \\approx 1$ (由于其一阶边界条件) 和 $p_v \\approx 2$ (因为其离散化是一致二阶的)。\n- 用例 4 ($\\kappa=1$, 两个封闭均为二阶)：整个离散格式是二阶精确的。两个场都应该表现出二阶收敛性，$p_u \\approx 2$ 和 $p_v \\approx 2$。\n\n实现将为每个情况和分辨率构建矩阵 $A$ 和向量 $\\mathbf{b}$，求解线性系统，然后计算收敛阶 $p_u$ 和 $p_v$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_and_solve(N, kappa, u_closure_order, v_closure_order):\n    \"\"\"\n    Assembles and solves the linear system for the coupled BVP.\n\n    Args:\n        N (int): Number of subintervals on the grid.\n        kappa (float): Coupling strength.\n        u_closure_order (int): Order of the Neumann closure for u (1 or 2).\n        v_closure_order (int): Order of the Neumann closure for v (1 or 2).\n\n    Returns:\n        tuple: A tuple containing the L2 error norms for u and v.\n    \"\"\"\n    # --- Define exact solutions and source terms ---\n    def u_exact(x):\n        return np.sin(2 * np.pi * x) + x\n    def v_exact(x):\n        return np.cos(2 * np.pi * x) - 0.5 * x\n    def u_prime_exact(x):\n        return 2 * np.pi * np.cos(2 * np.pi * x) + 1.0\n    def v_prime_exact(x):\n        return -2 * np.pi * np.sin(2 * np.pi * x) - 0.5\n    def u_dprime_exact(x):\n        return -4 * np.pi**2 * np.sin(2 * np.pi * x)\n    def v_dprime_exact(x):\n        return -4 * np.pi**2 * np.cos(2 * np.pi * x)\n    def s_u(x, k):\n        return -u_dprime_exact(x) + k * (u_exact(x) - v_exact(x))\n    def s_v(x, k):\n        return -v_dprime_exact(x) + k * (v_exact(x) - u_exact(x))\n\n    # --- Discretization setup ---\n    dim = 2 * N\n    A = np.zeros((dim, dim))\n    b = np.zeros(dim)\n    dx = 1.0 / N\n    k_dx2 = kappa * dx**2\n    x_grid = np.linspace(0, 1, N + 1)\n    \n    # --- Evaluate exact solutions and sources on grid ---\n    u_ex_grid = u_exact(x_grid)\n    v_ex_grid = v_exact(x_grid)\n    su_grid = s_u(x_grid, kappa)\n    sv_grid = s_v(x_grid, kappa)\n\n    # --- Assemble matrix A and vector b ---\n\n    # Interior equations for i = 1, ..., N-1\n    for i in range(1, N):\n        # Equation for u_i\n        row = i - 1\n        A[row, i - 1] = 2.0 + k_dx2         # u_i term\n        A[row, i] = -1.0                    # u_{i+1} term\n        if i > 1:\n            A[row, i - 2] = -1.0            # u_{i-1} term\n        A[row, N + i - 1] = -k_dx2          # v_i term\n        b[row] = dx**2 * su_grid[i]\n        if i == 1:\n            b[row] += u_ex_grid[0]          # u_0 Dirichlet term\n\n        # Equation for v_i\n        row = N + i - 1\n        A[row, N + i - 1] = 2.0 + k_dx2     # v_i term\n        A[row, N + i] = -1.0                # v_{i+1} term\n        if i > 1:\n            A[row, N + i - 2] = -1.0        # v_{i-1} term\n        A[row, i - 1] = -k_dx2              # u_i term\n        b[row] = dx**2 * sv_grid[i]\n        if i == 1:\n            b[row] += v_ex_grid[0]          # v_0 Dirichlet term\n\n    # Neumann boundary equation for u_N (at i=N)\n    row_uN = N - 1\n    if u_closure_order == 1:\n        A[row_uN, N - 1] = 1.0\n        A[row_uN, N - 2] = -1.0\n        b[row_uN] = dx * u_prime_exact(1.0)\n    elif u_closure_order == 2:\n        A[row_uN, N - 1] = 3.0\n        A[row_uN, N - 2] = -4.0\n        A[row_uN, N - 3] = 1.0\n        b[row_uN] = 2 * dx * u_prime_exact(1.0)\n\n    # Neumann boundary equation for v_N (at i=N)\n    row_vN = 2 * N - 1\n    if v_closure_order == 1:\n        A[row_vN, 2 * N - 1] = 1.0\n        A[row_vN, 2 * N - 2] = -1.0\n        b[row_vN] = dx * v_prime_exact(1.0)\n    elif v_closure_order == 2:\n        A[row_vN, 2 * N - 1] = 3.0\n        A[row_vN, 2 * N - 2] = -4.0\n        A[row_vN, 2 * N - 3] = 1.0\n        b[row_vN] = 2 * dx * v_prime_exact(1.0)\n        \n    # --- Solve the linear system ---\n    sol = np.linalg.solve(A, b)\n\n    # --- Compute error norm ---\n    # Unpack solution and prepend Dirichlet values\n    u_num = np.concatenate(([u_ex_grid[0]], sol[:N]))\n    v_num = np.concatenate(([v_ex_grid[0]], sol[N:]))\n    \n    # Calculate discrete L2 norm\n    error_u = u_num - u_ex_grid\n    error_v = v_num - v_ex_grid\n    norm_u = np.sqrt(dx * np.sum(error_u**2))\n    norm_v = np.sqrt(dx * np.sum(error_v**2))\n    \n    return norm_u, norm_v\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (kappa, u_closure_order, v_closure_order)\n        (1.0, 1, 2),  # Case 1\n        (1.0, 2, 1),  # Case 2\n        (0.0, 1, 2),  # Case 3\n        (1.0, 2, 2),  # Case 4\n    ]\n    \n    N_coarse = 64\n    N_fine = 128\n    \n    results = []\n    \n    for kappa, u_closure, v_closure in test_cases:\n        # Solve for coarse grid (h)\n        err_u_h, err_v_h = build_and_solve(N_coarse, kappa, u_closure, v_closure)\n        \n        # Solve for fine grid (h/2)\n        err_u_h2, err_v_h2 = build_and_solve(N_fine, kappa, u_closure, v_closure)\n        \n        # Compute observed order of accuracy\n        p_u = np.log2(err_u_h / err_u_h2) if err_u_h2 > 0 else 0\n        p_v = np.log2(err_v_h / err_v_h2) if err_v_h2 > 0 else 0\n        \n        results.extend([p_u, p_v])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3507199"}, {"introduction": "基于稳定性和耦合的概念，这最后一个练习将深入探讨一个时变多物理场系统的形式化冯·诺依曼稳定性分析。你将分析一个耦合的相场和传热模型，推导显式时间步进格式所施加的稳定性极限[@problem_id:3507246]。通过比较平流项的中心差分与迎风差分格式所对应的稳定性区域，你将学会不同的离散化选择如何直接影响最大允许时间步长和仿真的整体稳健性。", "problem": "考虑一个一维、周期性的多物理场基准问题，该问题耦合了一个热方程和一个包含潜热的相场模型。其物理出发点是能量守恒和相场动力学。包含潜热的能量守恒定律指出，显热的变化率由热扩散以及相变过程释放或吸收的潜热来平衡。写成适合数值分析的无量纲形式，可得到以下耦合系统\n$$\n\\partial_t T = \\alpha\\,\\partial_{xx} T + \\lambda\\,\\partial_t \\phi,\n$$\n其中 $T$ 是温度，$\\phi$ 是相场序参量，$\\alpha$ 是热扩散系数，$\\lambda$ 是潜热耦合系数。在均匀亚稳态附近的相场动力学可以理想化为平流-扩散-弛豫过程，\n$$\n\\partial_t \\phi + u\\,\\partial_x \\phi = \\kappa\\,\\partial_{xx}\\phi - \\sigma\\,\\phi,\n$$\n其中 $u$ 是施加的平流速度，$\\kappa$ 是相场梯度惩罚系数，$\\sigma$ 是线性弛豫率。此问题中的所有量均为无量纲，且角度必须以弧度为单位。\n\n使用有限差分法 (FDM) 在一个具有 $N$ 个点、域长度为 $L$、间距为 $h=L/N$ 的均匀网格上求解。对两个方程中的拉普拉斯算子 $\\partial_{xx}$ 均采用二阶中心差分。用两种备选方法离散化平流项 $\\partial_x \\phi$：\n- 中心差分：$\\left(\\phi_{i+1}-\\phi_{i-1}\\right)/(2h)$。\n- 对于 $u\\ge 0$ 的迎风差分：$\\left(\\phi_i-\\phi_{i-1}\\right)/h$。\n\n对两个场均采用前向欧拉时间步进，并使用以下恒等式进行显式潜热耦合\n$$\nT^{n+1}_i = T^n_i + \\Delta t\\,\\alpha\\,(\\partial_{xx} T)^n_i + \\lambda\\,\\left(\\phi^{n+1}_i - \\phi^n_i\\right),\n\\quad\n\\phi^{n+1}_i = \\phi^n_i + \\Delta t\\,\\left(-u\\,(\\partial_x \\phi)^n_i + \\kappa\\,(\\partial_{xx}\\phi)^n_i - \\sigma\\,\\phi^n_i\\right).\n$$\n在周期性网格上使用冯·诺依曼（Von Neumann，或傅里叶）分析法进行线性稳定性分析。对于一个相位为 $\\theta=2\\pi m/N$（角度以弧度为单位）、网格间距为 $h$ 的离散傅里叶模态，离散二阶微分算子的符号为\n$$\nB(\\theta) = \\frac{e^{i\\theta}-2+e^{-i\\theta}}{h^2} = -\\frac{4}{h^2}\\,\\sin^2\\!\\left(\\frac{\\theta}{2}\\right),\n$$\n离散一阶微分算子的符号为\n$$\nA_{\\text{central}}(\\theta) = \\frac{e^{i\\theta} - e^{-i\\theta}}{2h} = \\frac{i}{h}\\,\\sin\\theta,\n\\quad\nA_{\\text{upwind}}(\\theta) = \\frac{1 - e^{-i\\theta}}{h} = \\frac{1-\\cos\\theta}{h} + i\\,\\frac{\\sin\\theta}{h}.\n$$\n使用这些符号，一个模态的相场更新具有复系数\n$$\nc(\\theta) = -\\sigma + \\kappa\\,B(\\theta) - u\\,A(\\theta),\n$$\n其中 $A(\\theta)$ 根据所选的差分格式来确定。对于一个线性模态，前向欧拉法的稳定性要求对所有 $\\theta$ 都有 $|1+\\Delta t\\,c(\\theta)|\\le 1$。热方程的更新具有放大因子 $1+\\Delta t\\,\\alpha\\,B(\\theta)$，并要求对所有 $\\theta$ 都有 $|1+\\Delta t\\,\\alpha\\,B(\\theta)|\\le 1$。因为当以 $(\\phi,T)$ 形式书写时，耦合更新是下三角矩阵，所以线性稳定区域是相场和热方程稳定性条件的交集。\n\n你的任务是编写一个程序，针对每个测试用例，计算出最大稳定时间步长 $\\Delta t_{\\max}$，使得对于两种平流项差分格式（中心差分和迎风差分），$|1+\\Delta t\\,c(\\theta)|\\le 1$ 和 $|1+\\Delta t\\,\\alpha\\,B(\\theta)|\\le 1$ 这两个条件对所有的离散傅里叶相位 $\\theta=2\\pi m/N$（其中 $m\\in\\{0,1,\\ldots,N-1\\}$）都成立。角度必须以弧度处理。\n\n使用以下测试套件，其中 $L$、$N$、$u$、$\\alpha$、$\\kappa$、$\\sigma$ 和 $\\lambda$ 均已指定。所有量都是无量纲的。\n\n- 测试用例 A（一般的耦合平流-扩散-弛豫）：$L=1$, $N=128$, $u=1.0$, $\\alpha=0.01$, $\\kappa=0.005$, $\\sigma=0.02$, $\\lambda=0.5$。\n- 测试用例 B（零平流的边界情况）：$L=1$, $N=128$, $u=0.0$, $\\alpha=0.01$, $\\kappa=0.005$, $\\sigma=0.02$, $\\lambda=0.5$。\n- 测试用例 C（强平流和弱稳定化的边缘情况）：$L=1$, $N=1024$, $u=10.0$, $\\alpha=0.001$, $\\kappa=0.0$, $\\sigma=0.001$, $\\lambda=1.0$。\n\n你的程序必须：\n- 对于给定的 $L$、$N$、$h=L/N$ 和所有在指定范围内的整数 $m$对应的 $\\theta=2\\pi m/N$，实现离散符号 $B(\\theta)$、$A_{\\text{central}}(\\theta)$ 和 $A_{\\text{upwind}}(\\theta)$，并使用弧度作为角度单位。\n- 对于给定模态的相场稳定性边界，设 $c(\\theta)=a(\\theta)+i\\,b(\\theta)$，计算前向欧拉稳定性所允许的最大 $\\Delta t$。证明不等式 $|1+\\Delta t\\,c(\\theta)|\\le 1$ 可简化为 $2\\,a(\\theta)\\,\\Delta t + (a(\\theta)^2+b(\\theta)^2)\\,\\Delta t^2 \\le 0$，从而得出以下边界\n$$\n\\Delta t_{\\phi}(\\theta) =\n\\begin{cases}\n\\frac{-2\\,a(\\theta)}{a(\\theta)^2 + b(\\theta)^2},  a(\\theta)\\le 0, (a(\\theta),b(\\theta))\\ne (0,0) \\\\\n+\\infty,  a(\\theta)=0, b(\\theta)=0 \\\\\n0,  a(\\theta)>0.\n\\end{cases}\n$$\n- 对于热方程的稳定性边界，当 $B(\\theta)  0$ 时，计算 $\\Delta t_T(\\theta) = -2/(\\alpha\\,B(\\theta))$; 当 $B(\\theta)=0$ 时，$\\Delta t_T(\\theta)=+\\infty$。\n- 对于一种差分格式，全局稳定性边界为 $\\Delta t_{\\max} = \\min\\{\\min_{\\theta}\\Delta t_{\\phi}(\\theta),\\ \\min_{\\theta}\\Delta t_T(\\theta)\\}$，此处的最小化是针对所有 $\\theta$ 上的所有有限值进行的。\n\n为每个测试用例计算并报告一对最大稳定时间步长：$(\\Delta t_{\\max}^{\\text{central}}, \\Delta t_{\\max}^{\\text{upwind}})$。\n\n最终输出格式：\n你的程序应该生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n\\left[\\Delta t_{\\max}^{\\text{central}}(\\text{A}),\\ \\Delta t_{\\max}^{\\text{upwind}}(\\text{A}),\\ \\Delta t_{\\max}^{\\text{central}}(\\text{B}),\\ \\Delta t_{\\max}^{\\text{upwind}}(\\text{B}),\\ \\Delta t_{\\max}^{\\text{central}}(\\text{C}),\\ \\Delta t_{\\max}^{\\text{upwind}}(\\text{C})\\right],\n$$\n使用默认的浮点数格式。角度必须是弧度。所有量都是无量纲的，因此输出中不需要物理单位。", "solution": "该问题要求确定一个使用有限差分法 (FDM) 离散化的一维偏微分方程耦合系统的最大稳定时间步长 $\\Delta t_{\\max}$。分析基于应用于显式前向欧拉时间积分格式的冯·诺依曼稳定性方法。\n\n控制方程的无量纲形式如下：\n$$\n\\partial_t T = \\alpha\\,\\partial_{xx} T + \\lambda\\,\\partial_t \\phi\n$$\n$$\n\\partial_t \\phi + u\\,\\partial_x \\phi = \\kappa\\,\\partial_{xx}\\phi - \\sigma\\,\\phi\n$$\n其中 $T$ 是温度，$\\phi$ 是相场序参量，$\\alpha, \\lambda, u, \\kappa, \\sigma$ 是恒定的物理参数。\n\n该系统在长度为 $L$ 的域上使用包含 $N$ 个点的均匀周期性网格进行离散化，网格间距为 $h=L/N$。我们采用前向欧拉格式进行时间步进。显式耦合格式由下式给出：\n$$\nT^{n+1}_i = T^n_i + \\Delta t\\,\\alpha\\,(\\partial_{xx} T)^n_i + \\lambda\\,\\left(\\phi^{n+1}_i - \\phi^n_i\\right)\n$$\n$$\n\\phi^{n+1}_i = \\phi^n_i + \\Delta t\\,\\left(-u\\,(\\partial_x \\phi)^n_i + \\kappa\\,(\\partial_{xx}\\phi)^n_i - \\sigma\\,\\phi^n_i\\right)\n$$\n空间导数使用二阶中心差分来近似拉普拉斯算子 $\\partial_{xx}$，并使用中心差分或迎风差分格式来近似平流项 $\\partial_x \\phi$。\n\n此数值格式的稳定性使用冯·诺依曼方法进行分析。我们考虑每个场的单个傅里叶模态，形式为 $\\phi_j^n = \\hat{\\phi}^n(k) e^{ij\\theta}$ 和 $T_j^n = \\hat{T}^n(k) e^{ij\\theta}$，其中 $j$ 是空间索引，$n$ 是时间索引，$\\theta = 2\\pi m/N$ 是模态 $m \\in \\{0, 1, \\ldots, N-1\\}$ 的离散相位。角度以弧度为单位。\n\n将有限差分算子应用于此模态，会将它们转换为代数乘子，即符号。所需算子的符号如下所示：\n- 二阶导数（拉普拉斯算子），中心差分：\n$$\nB(\\theta) = \\frac{e^{i\\theta}-2+e^{-i\\theta}}{h^2} = -\\frac{4}{h^2}\\,\\sin^2\\!\\left(\\frac{\\theta}{2}\\right)\n$$\n- 一阶导数（平流），中心差分：\n$$\nA_{\\text{central}}(\\theta) = \\frac{e^{i\\theta} - e^{-i\\theta}}{2h} = \\frac{i}{h}\\,\\sin\\theta\n$$\n- 一阶导数（平流），迎风差分（适用于 $u \\ge 0$）：\n$$\nA_{\\text{upwind}}(\\theta) = \\frac{1 - e^{-i\\theta}}{h} = \\frac{1-\\cos\\theta}{h} + i\\,\\frac{\\sin\\theta}{h}\n$$\n\n傅里叶振幅 $\\hat{\\phi}^n$ 和 $\\hat{T}^n$ 的离散方程变为：\n$$\n\\hat{\\phi}^{n+1} = \\hat{\\phi}^n + \\Delta t \\, (-\\sigma + \\kappa B(\\theta) - u A(\\theta)) \\hat{\\phi}^n = (1 + \\Delta t \\, c(\\theta)) \\hat{\\phi}^n\n$$\n$$\n\\hat{T}^{n+1} = \\hat{T}^n + \\Delta t \\, \\alpha B(\\theta) \\hat{T}^n + \\lambda (\\hat{\\phi}^{n+1} - \\hat{\\phi}^n) = (1 + \\Delta t \\, \\alpha B(\\theta)) \\hat{T}^n + \\lambda \\Delta t \\, c(\\theta) \\hat{\\phi}^n\n$$\n其中 $c(\\theta) = -\\sigma + \\kappa B(\\theta) - u A(\\theta)$ 是相场演化的复系数。\n\n这个更新系统可以写成向量 $(\\hat{\\phi}, \\hat{T})^T$ 的矩阵形式：\n$$\n\\begin{pmatrix} \\hat{\\phi}^{n+1} \\\\ \\hat{T}^{n+1} \\end{pmatrix}\n=\n\\begin{pmatrix}\n1 + \\Delta t \\, c(\\theta)  0 \\\\\n\\lambda \\Delta t \\, c(\\theta)  1 + \\Delta t \\, \\alpha B(\\theta)\n\\end{pmatrix}\n\\begin{pmatrix} \\hat{\\phi}^{n} \\\\ \\hat{T}^{n} \\end{pmatrix}\n$$\n由于放大矩阵是下三角矩阵，其特征值即为对角线元素。为了保证稳定性，对于所有傅里叶模态 $\\theta$，两个特征值的模都必须小于或等于一。这产生了两个独立的稳定性条件：\n1. 相场稳定性：$|1 + \\Delta t \\, c(\\theta)| \\le 1$\n2. 热方程稳定性：$|1 + \\Delta t \\, \\alpha B(\\theta)| \\le 1$\n\n整体稳定时间步长 $\\Delta t_{\\max}$ 必须对所有 $\\theta$ 满足这两个条件。\n\n**热方程稳定性：**\n符号 $B(\\theta)$ 是纯实数且非正。条件 $|1 + \\Delta t \\, \\alpha B(\\theta)| \\le 1$ 可简化为 $-1 \\le 1 + \\Delta t \\, \\alpha B(\\theta) \\le 1$。\n右侧不等式 $\\Delta t \\, \\alpha B(\\theta) \\le 0$ 在 $\\Delta t, \\alpha > 0$ 和 $B(\\theta) \\le 0$ 时总是满足的。\n左侧不等式 $-2 \\le \\Delta t \\, \\alpha B(\\theta)$ 在 $B(\\theta)  0$ 时意味着 $\\Delta t \\le -2 / (\\alpha B(\\theta))$。如果 $B(\\theta)=0$（当 $\\theta=0$ 时发生），则该条件对任何 $\\Delta t$ 都满足。因此，给定模态 $\\theta$ 的最大时间步长是：\n$$\n\\Delta t_T(\\theta) =\n\\begin{cases}\n\\frac{-2}{\\alpha B(\\theta)},  B(\\theta)  0 \\\\\n+\\infty,  B(\\theta) = 0\n\\end{cases}\n$$\n来自热方程的全局约束是 $\\Delta t_{T, \\min} = \\min_{\\theta} \\Delta t_T(\\theta)$。\n\n**相场稳定性：**\n系数 $c(\\theta) = a(\\theta) + i b(\\theta)$ 通常是复数。条件 $|1 + \\Delta t \\, c(\\theta)| \\le 1$ 展开为：\n$| (1 + \\Delta t \\, a(\\theta)) + i(\\Delta t \\, b(\\theta)) |^2 \\le 1$\n$(1 + \\Delta t \\, a(\\theta))^2 + (\\Delta t \\, b(\\theta))^2 \\le 1$\n$1 + 2\\Delta t \\, a(\\theta) + (\\Delta t)^2 a(\\theta)^2 + (\\Delta t)^2 b(\\theta)^2 \\le 1$\n$2\\Delta t \\, a(\\theta) + (\\Delta t)^2 (a(\\theta)^2 + b(\\theta)^2) \\le 0$\n由于 $\\Delta t>0$，我们可以用它来除，得到 $2a(\\theta) + \\Delta t (a(\\theta)^2 + b(\\theta)^2) \\le 0$。\n求解 $\\Delta t$ 可得到问题中提供的分情况讨论：\n$$\n\\Delta t_{\\phi}(\\theta) =\n\\begin{cases}\n\\frac{-2\\,a(\\theta)}{a(\\theta)^2 + b(\\theta)^2},  a(\\theta)\\le 0, (a(\\theta),b(\\theta))\\ne (0,0) \\\\\n+\\infty,  a(\\theta)=0, b(\\theta)=0 \\\\\n0,  a(\\theta)>0\n\\end{cases}\n$$\n来自相场方程的全局约束是 $\\Delta t_{\\phi, \\min} = \\min_{\\theta} \\Delta t_{\\phi}(\\theta)$。\n\n**整体稳定性：**\n该耦合系统的最大稳定时间步长是两个方程在所有傅里叶模态上的约束的最小值：\n$$\n\\Delta t_{\\max} = \\min\\left(\\Delta t_{T, \\min}, \\Delta t_{\\phi, \\min}\\right)\n$$\n\n**计算流程如下：**\n1. 对每个测试用例和每种平流差分格式（中心和迎风）：\n2. 定义参数 $L, N, u, \\alpha, \\kappa, \\sigma$。计算 $h=L/N$。\n3. 生成离散角度数组 $\\theta_m = 2\\pi m/N$，其中 $m \\in \\{0, 1, \\ldots, N-1\\}$。\n4. 矢量化计算符号 $B(\\theta)$、$A_{\\text{central}}(\\theta)$ 和 $A_{\\text{upwind}}(\\theta)$ 的数组。\n5. 计算热方程时间步长限制的数组 $\\Delta t_T(\\theta)$ 并找到其最小值 $\\Delta t_{T, \\min}$。\n6. 计算相场系数的数组 $c(\\theta)$。\n7. 将 $c(\\theta)$ 分解为实部 $a(\\theta)$ 和虚部 $b(\\theta)$。\n8. 应用分情况公式计算相场时间步长限制的数组 $\\Delta t_{\\phi}(\\theta)$ 并找到其最小值 $\\Delta t_{\\phi, \\min}$。\n9. 给定用例和差分格式的最终结果是 $\\Delta t_{\\max} = \\min(\\Delta t_{T, \\min}, \\Delta t_{\\phi, \\min})$。\n对所有测试用例和两种差分格式重复此过程。所有角度均按要求以弧度处理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the largest stable time step for a coupled PDE system\n    using Von Neumann stability analysis for different FDM stencils.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A (general coupled advection-diffusion-relaxation)\n        {'name': 'A', 'L': 1.0, 'N': 128, 'u': 1.0, 'alpha': 0.01, 'kappa': 0.005, 'sigma': 0.02, 'lambda': 0.5},\n        \n        # Test case B (boundary case with zero advection)\n        {'name': 'B', 'L': 1.0, 'N': 128, 'u': 0.0, 'alpha': 0.01, 'kappa': 0.005, 'sigma': 0.02, 'lambda': 0.5},\n        \n        # Test case C (edge case with strong advection and weak stabilization)\n        {'name': 'C', 'L': 1.0, 'N': 1024, 'u': 10.0, 'alpha': 0.001, 'kappa': 0.0, 'sigma': 0.001, 'lambda': 1.0},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        L = case['L']\n        N = case['N']\n        u = case['u']\n        alpha = case['alpha']\n        kappa = case['kappa']\n        sigma = case['sigma']\n        \n        h = L / N\n        m = np.arange(N)\n        theta = 2 * np.pi * m / N\n\n        # Symbol for second derivative (Laplacian)\n        B = (-4 / h**2) * np.sin(theta / 2)**2\n\n        # Heat equation stability limit\n        dt_T = np.full_like(B, np.inf)\n        # The mask B  0 handles B=0 case correctly, where dt_T remains inf.\n        mask_T_stable = B  0\n        dt_T[mask_T_stable] = -2.0 / (alpha * B[mask_T_stable])\n        min_dt_T = np.min(dt_T)\n\n        for stencil in ['central', 'upwind']:\n            if stencil == 'central':\n                # Symbol for first derivative (central)\n                A = (1j / h) * np.sin(theta)\n            else: # upwind\n                # Symbol for first derivative (upwind for u>=0)\n                A = ((1 - np.cos(theta)) / h) + (1j * np.sin(theta) / h)\n\n            # Complex coefficient for phase-field evolution\n            c = -sigma + kappa * B - u * A\n            a = np.real(c)\n            b = np.imag(c)\n            c_norm_sq = a**2 + b**2\n\n            # Phase-field equation stability limit\n            dt_phi = np.full_like(a, np.inf)\n\n            # Case: a > 0 implies instability for forward Euler, so dt_max = 0.\n            mask_unstable = a > 0\n            dt_phi[mask_unstable] = 0.0\n            \n            # Case: a = 0 and c != 0. The stability limit is dt = -2a / |c|^2.\n            # This also correctly handles a=0, b!=0, which gives dt_max=0.\n            # The case a=0, b=0 (c=0) is handled by the initialization to np.inf.\n            mask_stable = (a = 0)  (c_norm_sq > 1e-15)\n            dt_phi[mask_stable] = -2.0 * a[mask_stable] / c_norm_sq[mask_stable]\n\n            min_dt_phi = np.min(dt_phi)\n            \n            # The overall maximum stable time step is the minimum of the two constraints\n            dt_max = min(min_dt_T, min_dt_phi)\n            results.append(dt_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3507246"}]}