{
        "hands_on_practices": [
            {
                "introduction": "托普利茨（Toeplitz）快速算法的核心在于利用快速傅里叶变换（FFT）高效地计算矩阵向量乘积。本练习将指导您实现这一关键操作，重点在于如何将一个 $n \\times n$ 的托普利茨矩阵嵌入到一个更大的循环矩阵中，并通过选择合适的嵌入尺寸 $m$ 来控制近似误差。通过这个实践，您将深入理解矩阵生成符号的光滑度（即其傅里叶系数的衰减率）与循环近似精度之间的基本关系 ([@problem_id:3545696])。",
                "problem": "考虑一个由定义在 $[0,2\\pi)$ 上的双边傅里叶级数符号 $g(\\theta)$ 生成的 $n \\times n$ 对称托普利茨矩阵族，该符号通过满足 $t_{-k} = t_k$ 的实数、非负傅里叶系数 $\\{t_k\\}_{k \\in \\mathbb{N}_0}$ 定义。托普利茨矩阵 $T_n$ 的元素为 $(T_n)_{ij} = t_{\\lvert i-j \\rvert}$，其中 $1 \\leq i,j \\leq n$。任务是使用循环嵌入和快速傅里叶变换 (FFT) 高效地计算矩阵向量乘积 $y = T_n x$，并优化嵌入大小以最小化混叠效应。\n\n基本原理：\n- 离散傅里叶变换 (DFT) 可以对角化循环矩阵。长度为 $m$ 的核与长度为 $m$ 的向量的循环卷积可以通过 FFT 在 $\\mathcal{O}(m \\log m)$ 时间内计算。\n- 傅里叶级数表示 $g(\\theta) = \\sum_{k \\in \\mathbb{Z}} t_k \\mathrm{e}^{-\\mathrm{i} k \\theta}$ (其中 $t_{-k}=t_k$) 定义了 $m$ 阶循环群上的一个平移不变核。在 $m$ 点网格上对 $g(\\theta)$ 进行采样，可以得到一个循环矩阵，其时域核等于傅里叶系数的周期求和。\n\n混叠与周期求和原理：\n- 在 $m$ 个等距点上对 $g(\\theta)$ 进行采样并应用逆 DFT，可以得到一个时域序列 $c[r]$（$0 \\leq r  m$），它等于傅里叶系数的周期求和：\n$$\nc[r] = \\sum_{\\ell \\in \\mathbb{Z}} t_{\\lvert r + \\ell m \\rvert}.\n$$\n- 计算 $c$ 与一个补零的 $x$ 的循环卷积可以近似得到 $T_n x$。与精确托普利茨乘积的差异可以根据周期求和尾部产生的混叠误差进行界定。\n\n符号平滑度模型：\n- 指数衰减（解析符号）：$t_k = C \\mathrm{e}^{-\\alpha k}$，对于 $k \\geq 0$，参数为 $C > 0, \\alpha > 0$。\n- 代数衰减（有限平滑度）：$t_k = C (1+k)^{-p}$，对于 $k \\geq 0$，参数为 $C > 0, p > 1$。\n\n$\\{t_k\\}$ 周期求和的混叠误差界：\n- 对于指数衰减，任意固定 $r$ 的周期混叠尾部可界定为\n$$\nE_{\\mathrm{alias}}^{\\mathrm{exp}}(m) \\leq 2 C \\frac{\\mathrm{e}^{-\\alpha m}}{1 - \\mathrm{e}^{-\\alpha m}}.\n$$\n- 对于代数衰减，任意固定 $r$ 的周期混叠尾部可界定为\n$$\nE_{\\mathrm{alias}}^{\\mathrm{alg}}(m) \\leq 2 C \\zeta(p) m^{-p},\n$$\n其中 $\\zeta(p)$ 是黎曼zeta函数在 $p$ 处的值。\n\n优化目标：\n- 给定 $n$、一个已知参数的平滑度模型和一个容差 $\\varepsilon$，选择最小的2的幂次嵌入大小 $m$，使得所选模型的混叠误差界最多为 $\\varepsilon$，同时确保 $m \\geq 2n$，以使循环卷积窗口能够覆盖线性范围而不会发生输入的环绕。\n\n实现细节：\n- 使用恒等式 $c[r] = \\sum_{\\ell \\in \\mathbb{Z}} t_{\\lvert r + \\ell m \\rvert}$ 构建周期核 $c[r]$，通过忽略低于阈值 $\\tau$ 的项进行截断。由于在两种模型下 $t_k$ 随 $k$ 单调递减，只需对 $\\ell \\geq 1$ 进行一个简单的循环，当 $t_{r + \\ell m}$ 和 $t_{\\ell m - r}$ 均低于 $\\tau$ 时停止。对于 $r=0$，使用 $c[0] = t_0 + 2\\sum_{\\ell \\geq 1} t_{\\ell m}$，并在 $\\tau$ 处截断。\n- 使用 FFT，通过计算 $c$ 与补零至长度为 $m$ 的 $x$ 的循环卷积来计算近似乘积 $y_{\\mathrm{FFT}}$。\n- 通过直接求和 $y_i = \\sum_{j=1}^n t_{\\lvert i-j \\rvert} x_j$ 计算精确乘积 $y_{\\mathrm{exact}}$。\n- 测量相对误差 $\\|y_{\\mathrm{FFT}} - y_{\\mathrm{exact}}\\|_{\\infty}/\\|y_{\\mathrm{exact}}\\|_{\\infty}$。\n\n测试套件：\n对于下面的每个测试用例，使用容差 $\\varepsilon = 10^{-8}$ 和截断阈值 $\\tau = 10^{-12}$。\n\n1. 指数衰减（解析符号）：\n   - $n = 64$，$C = 1$，$\\alpha = 0.5$。\n2. 代数衰减（有限平滑度）：\n   - $n = 64$，$C = 1$，$p = 2.2$。\n3. 指数衰减（解析符号，衰减更快）：\n   - $n = 128$，$C = 1$，$\\alpha = 1.0$。\n4. 代数衰减（有限平滑度，更平滑）：\n   - $n = 128$，$C = 1$，$p = 3.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。每个结果是对应测试用例的相对 $\\ell_{\\infty}$ 误差（一个浮点数），顺序与上面列出的一致。例如：\"[e1,e2,e3,e4]\"。",
                "solution": "用户提供了一个数值线性代数领域的问题，具体涉及对称托普利茨矩阵 $T_n$ 的矩阵向量乘积的快速计算。所提出的方法包括将 $n \\times n$ 的托普利茨矩阵嵌入到一个更大的 $m \\times m$ 循环矩阵中，并使用快速傅里叶变换 (FFT) 在 $\\mathcal{O}(m \\log m)$ 时间内高效地执行卷积。\n\n### 第一步：问题验证\n\n在尝试求解之前，对问题进行了严格的验证。\n\n-   **提取已知信息**：\n    -   **矩阵**：大小为 $n \\times n$ 的对称托普利茨矩阵 $T_n$，其元素为 $(T_n)_{ij} = t_{\\lvert i-j \\rvert}$。\n    -   **系数**：序列 $\\{t_k\\}_{k \\in \\mathbb{N}_0}$ 是实数、非负，并且是偶函数 ($t_{-k} = t_k$)。\n    -   **任务**：使用大小为 $m \\times m$ 的循环嵌入和 FFT 计算 $y = T_n x$。\n    -   **循环核**：循环矩阵的第一列 $c$ 由周期求和 $c[r] = \\sum_{\\ell \\in \\mathbb{Z}} t_{\\lvert r + \\ell m \\rvert}$ 定义。\n    -   **系数衰减模型**：\n        1.  指数（解析）：$t_k = C \\mathrm{e}^{-\\alpha k}$，对于 $k \\geq 0$，其中 $C > 0, \\alpha > 0$。\n        2.  代数（有限平滑度）：$t_k = C (1+k)^{-p}$，对于 $k \\geq 0$，其中 $C > 0, p > 1$。\n    -   **混叠误差界**：为每种衰减模型，提供了由于周期求和导致的循环核误差的显式公式。\n        -   指数：$E_{\\mathrm{alias}}^{\\mathrm{exp}}(m) \\leq 2 C \\frac{\\mathrm{e}^{-\\alpha m}}{1 - \\mathrm{e}^{-\\alpha m}}$。\n        -   代数：$E_{\\mathrm{alias}}^{\\mathrm{alg}}(m) \\leq 2 C \\zeta(p) m^{-p}$。\n    -   **优化目标**：对于给定的 $n$、衰减模型和容差 $\\varepsilon$，找到最小的2的幂次整数 $m$，使得 $m \\geq 2n$ 且对应的混叠误差界不超过 $\\varepsilon$。\n    -   **实现细节**：\n        -   核的构建涉及在项低于阈值 $\\tau$ 时截断 $c[r]$ 的求和。\n        -   最终误差通过相对 $\\ell_{\\infty}$ 范数来衡量：$\\|y_{\\mathrm{FFT}} - y_{\\mathrm{exact}}\\|_{\\infty}/\\|y_{\\mathrm{exact}}\\|_{\\infty}$。\n    -   **测试套件参数**：指定了四个测试用例，包含 $n$, $C$, $\\alpha$, $p$ 的值。容差给定为 $\\varepsilon = 10^{-8}$ 和 $\\tau = 10^{-12}$。\n\n-   **验证结论**：\n    -   **科学依据**：该问题是傅里叶分析在数值线性代数中的一个经典应用。对托普利茨系统使用循环预条件子和快速卷积是一种成熟的基础技术。符号的平滑度（傅里叶系数的衰减）与循环近似收敛性之间的联系是该领域的核心概念。所提供的误差界是标准结果。该问题在科学和数学上是合理的。\n    -   **良定且完整**：问题定义清晰。所有必要的参数、模型和目标都已指定。嵌入大小 $m$ 的优化目标是明确的。唯一未指定的元素是输入向量 $x$。在测试数值算法准确性的背景下，使用固定或随机向量是一种标准做法。使用伪随机数向量（从固定种子生成以保证可复现性）是完成问题规范的有效且标准的方法。\n    -   **客观性**：语言精确且数学化，没有任何主观性或模糊性。\n\n该问题被判定为**有效**。这是一个良定且有科学依据的计算数学练习。可以进行求解。\n\n### 第二步：求解推导\n\n求解过程涉及为四个测试用例中的每一个实现所述算法。将为每个测试用例生成一个随机向量 $x$ 以执行计算。为了可复现性，使用了一个具有固定种子的伪随机数生成器。\n\n**各测试用例的算法大纲：**\n\n1.  **参数设置**：分离出当前测试用例的参数：$n$、模型类型（'exponential' 或 'algebraic'）以及模型参数（$C, \\alpha$ 或 $C, p$）。设置容差 $\\varepsilon = 10^{-8}$ 和 $\\tau = 10^{-12}$。\n\n2.  **确定嵌入大小 $m$**：\n    -   将 $m$ 初始化为大于或等于 $2n$ 的最小的2的幂。这确保了线性卷积能够正确计算而没有回卷效应。\n    -   进入一个循环：\n        -   根据当前 $m$ 的指定模型计算混叠误差界。对于代数模型，这需要 `scipy.special` 中可用的黎曼zeta函数 $\\zeta(p)$。\n        -   如果计算出的界小于或等于容差 $\\varepsilon$，则退出循环。\n        -   否则，将 $m$ 的值加倍并继续循环。\n\n3.  **生成测试数据**：\n    -   创建大小为 $n$ 的输入向量 $x$，其元素从 $[0, 1)$ 上的均匀分布中随机抽取。\n    -   定义一个辅助函数 `t_k_func(k)`，根据指定的衰减模型计算系数 $t_k$。\n\n4.  **计算精确乘积 $y_{\\mathrm{exact}}$**：\n    -   生成托普利茨矩阵 $T_n$ 的第一列，即 $[t_0, t_1, \\dots, t_{n-1}]$。\n    -   使用函数 `scipy.linalg.toeplitz` 构建完整的 $n \\times n$ 对称托普利茨矩阵 $T_n$。\n    -   计算精确的矩阵向量乘积 $y_{\\mathrm{exact}} = T_n x$。\n\n5.  **计算近似乘积 $y_{\\mathrm{FFT}}$**：\n    -   **构建循环核 $c$**：创建一个长度为 $m$ 的向量 $c$。基于恒等式 $c[r] = \\sum_{\\ell \\in \\mathbb{Z}} t_{|r+\\ell m|}$ 以及 $t_k$ 的偶性，$c$ 相对于中点 $m/2$ 也是偶的，即 $c[r] = c[m-r]$。利用此对称性可提高效率。\n        -   通过对级数 $t_r + \\sum_{\\ell=1}^{\\infty} (t_{\\ell m - r} + t_{\\ell m + r})$ 求和（对于 $r=0$ 有特殊形式）来计算 $r \\in [0, m/2]$ 范围内的 $c[r]$。当待加项低于阈值 $\\tau$ 时，对 $\\ell$ 的求和被截断。\n        -   利用对称性 $c[r] = c[m-r]$ 填充 $r \\in (m/2, m)$ 范围内的其余项 $c[r]$。\n    -   **通过 FFT 进行循环卷积**：\n        -   将输入向量 $x$ 补零至长度 $m$。\n        -   使用 `numpy.fft.fft` 计算核 $c$ 和补零后向量 $x$ 的 DFT。\n        -   将 DFT 结果逐元素相乘。\n        -   使用 `numpy.fft.ifft` 计算乘积的逆 DFT。结果即为循环卷积。\n        -   提取结果向量的前 $n$ 个分量，并取其实部（以丢弃由浮点不精确性产生的可忽略的虚部）。这就是近似乘积 $y_{\\mathrm{FFT}}$。\n\n6.  **计算相对误差**：使用 $\\ell_{\\infty}$-范数计算相对误差：\n    $$\n    \\text{error} = \\frac{\\|y_{\\mathrm{FFT}} - y_{\\mathrm{exact}}\\|_{\\infty}}{\\|y_{\\mathrm{exact}}\\|_{\\infty}}\n    $$\n    进行检查以处理 $\\|y_{\\mathrm{exact}}\\|_{\\infty}$ 可能为零的情况。\n\n7.  **存储和报告**：存储计算出的误差。在所有测试用例处理完毕后，将结果格式化为指定的单个字符串。\n\n这个系统化的过程在最终答案中提供的 Python 代码中实现。",
                "answer": "```python\nimport numpy as np\nfrom scipy.linalg import toeplitz\nfrom scipy.special import zeta\n\ndef solve():\n    \"\"\"\n    Computes the matrix-vector product y = T_n x for a symmetric Toeplitz\n    matrix T_n using a circulant embedding and FFT, and evaluates the\n    accuracy against a direct computation.\n    \"\"\"\n    # Define problem constants and test suite\n    TOL_EPS = 1e-8\n    TOL_TAU = 1e-12\n\n    test_cases = [\n        {'n': 64, 'model': 'exponential', 'params': {'C': 1.0, 'alpha': 0.5}},\n        {'n': 64, 'model': 'algebraic', 'params': {'C': 1.0, 'p': 2.2}},\n        {'n': 128, 'model': 'exponential', 'params': {'C': 1.0, 'alpha': 1.0}},\n        {'n': 128, 'model': 'algebraic', 'params': {'C': 1.0, 'p': 3.0}},\n    ]\n\n    results = []\n    # Use a seeded random number generator for reproducible results\n    rng = np.random.default_rng(12345)\n\n    for case in test_cases:\n        n = case['n']\n        model = case['model']\n        params = case['params']\n\n        # Define the tk generator function based on the model\n        if model == 'exponential':\n            C, alpha = params['C'], params['alpha']\n            t_k_func = lambda k: C * np.exp(-alpha * np.abs(k))\n        else: # algebraic\n            C, p = params['C'], params['p']\n            t_k_func = lambda k: C * (1 + np.abs(k))**(-p)\n\n        # 1. Determine the optimal embedding size m\n        # Smallest power of two >= 2n\n        m = 1  (2 * n).bit_length() if n > 0 else 1\n        if m  (2 * n):\n            m *= 2\n\n        while True:\n            if model == 'exponential':\n                bound = 2 * C * np.exp(-alpha * m) / (1 - np.exp(-alpha * m))\n            else: # algebraic\n                bound = 2 * C * zeta(p) * (m**(-p))\n            \n            if bound = TOL_EPS:\n                break\n            m *= 2\n            \n        # 2. Generate test vector x\n        x = rng.random(n)\n        \n        # 3. Compute the exact matrix-vector product\n        t_coeffs = t_k_func(np.arange(n))\n        T_n = toeplitz(t_coeffs)\n        y_exact = T_n @ x\n\n        # 4. Compute the approximate product using FFT\n        # 4.1 Construct the circulant kernel c\n        c = np.zeros(m)\n        \n        # Compute c[0] through c[m/2] by summing the periodic terms\n        for r in range(m // 2 + 1):\n            c[r] = t_k_func(r)\n            ell = 1\n            while True:\n                if r == 0:\n                    # For r=0, term is t(lm) + t(-lm) = 2*t(lm)\n                    term = 2 * t_k_func(ell * m)\n                else:\n                    # For r>0, term is t(lm+r) + t(lm-r)\n                    term = t_k_func(ell * m - r) + t_k_func(ell * m + r)\n                \n                if term  TOL_TAU:\n                    break\n                \n                c[r] += term\n                ell += 1\n        \n        # Exploit symmetry c[r] = c[m-r] for the other half of the kernel\n        for r in range(1, m // 2):\n            c[m - r] = c[r]\n\n        # 4.2 Perform circular convolution via FFT\n        x_pad = np.zeros(m)\n        x_pad[:n] = x\n        \n        y_pad = np.fft.ifft(np.fft.fft(c) * np.fft.fft(x_pad))\n        # Result should be real; take real part to discard numerical noise\n        y_fft = np.real(y_pad[:n])\n        \n        # 5. Calculate the relative l-infinity error\n        norm_y_exact = np.linalg.norm(y_exact, np.inf)\n        if norm_y_exact == 0:\n            error = 0.0\n        else:\n            error = np.linalg.norm(y_fft - y_exact, np.inf) / norm_y_exact\n            \n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```",
                "id": "3545696"
            },
            {
                "introduction": "虽然像列文森-杜宾（Levinson-Durbin）这样的经典快速算法非常高效，但当面临在实际应用中常见的病态矩阵时，其数值稳定性便成为一个重要问题。本练习旨在通过实验对比经典快速算法与更稳健的（如基于主元选择的）方法在求解由含零点符号生成的病态托普利茨系统时的表现。您将学习如何量化和诊断当矩阵生成符号接近奇异时出现的稳定性问题，从而在速度和精度之间做出明智的权衡 ([@problem_id:3545692])。",
                "problem": "从一个在单位圆上存在零点的符号出发，构建一个埃尔米特(Hermitian)托普利茨(Toeplitz)线性系统族，并设计一个参数化实验，以比较当零点趋近于 $\\{e^{\\pm i\\theta_0}\\}$ 时，Levinson–Durbin 递归与 Gohberg–Kailath–Olshevsky (GKO) 范式在数值稳定性和准确性方面的表现。请从以下基础出发。\n\n一个大小为 $n\\times n$ 的托普利茨矩阵 $T_n(f)$ 由一个 $2\\pi$-周期的符号 $f(\\theta)$ 通过其傅里叶系数生成。对于一个函数 $f(\\theta)$，其傅里叶系数为 $c_k = \\frac{1}{2\\pi}\\int_0^{2\\pi} f(\\theta)e^{-ik\\theta}\\,d\\theta$（其中 $k$ 为整数），托普利茨矩阵定义为 $[T_n(f)]_{ij} = c_{i-j}$，其中 $i,j \\in \\{1,2,\\dots,n\\}$，并约定 $c_{-k} = \\overline{c_k}$ 以确保其埃尔米特结构。\n\n考虑符号族\n$$\nf_{\\delta,\\theta_0}(\\theta) = \\delta + 2 - 2\\cos(\\theta - \\theta_0),\n$$\n其中 $\\delta  0$ 是一个坫参数，$\\theta_0 \\in (0,\\pi)$ 是一个固定值。函数 $f_{\\delta,\\theta_0}(\\theta)$ 对所有 $\\theta$ 均非负，当 $\\delta = 0$ 时，在 $\\theta = \\theta_0$ 处有一个零点，因此当 $\\delta \\to 0^+$ 时，相关的托普利茨矩阵变得越来越病态。推导 $f_{\\delta,\\theta_0}(\\theta)$ 的傅里叶系数，并用它们构建一个第一列为 $c$、第一行为 $r$ 的埃尔米特托普利茨矩阵 $T_n(f_{\\delta,\\theta_0})$。选择一个确定性的非零目标解向量 $x_{\\text{true}} \\in \\mathbb{C}^n$，构造右端项 $b = T_n(f_{\\delta,\\theta_0}) x_{\\text{true}}$，并用两种方法求解系统 $T_n(f_{\\delta,\\theta_0}) x = b$：\n- 专用于埃尔米特托普利茨矩阵的 Levinson–Durbin 递归。\n- 一种 Gohberg–Kailath–Olshevsky (GKO) 风格的带主元方法。对于本实验，您必须通过对稠密的托普利茨矩阵应用带部分主元的高斯消去法来模拟 GKO 的主元选择和稳健性，接受快速复杂度的损失，但专注于当零点趋近单位圆时的稳定性和准确性。\n\n对于每种方法计算出的解 $\\hat{x}$，评估以下可量化的指标：\n1. 相对解误差 $E = \\frac{\\| \\hat{x} - x_{\\text{true}} \\|_2}{\\| x_{\\text{true}} \\|_2}$。\n2. 相对残差范数 $R = \\frac{\\| b - T_n(f_{\\delta,\\theta_0}) \\hat{x} \\|_2}{\\| b \\|_2}$。\n3. 2-范数条件数 $\\kappa_2(T_n(f_{\\delta,\\theta_0})) = \\|T_n(f_{\\delta,\\theta_0})\\|_2 \\cdot \\|T_n(f_{\\delta,\\theta_0})^{-1}\\|_2$。\n\n设计并运行一个参数化实验，使用以下 $(n,\\theta_0,\\delta)$ 值的测试套件，以在一系列不同条件数水平和角度上探究稳定性和准确性：\n- 测试用例 1：$(n,\\theta_0,\\delta) = (32,\\frac{\\pi}{4},10^{-2})$。\n- 测试用例 2：$(n,\\theta_0,\\delta) = (64,\\frac{\\pi}{3},10^{-6})$。\n- 测试用例 3：$(n,\\theta_0,\\delta) = (64,0.01,10^{-8})$。\n- 测试用例 4：$(n,\\theta_0,\\delta) = (16,\\pi - 0.01,10^{-9})$。\n- 测试用例 5：$(n,\\theta_0,\\delta) = (8,\\frac{\\pi}{6},10^{-12})$。\n\n为保证可复现性，选择一个由下式定义的确定性非零 $x_{\\text{true}}$\n$$\nx_{\\text{true}}[j] = \\sin\\left(\\frac{2\\pi j}{n}\\right) + \\frac{1}{2}\\cos\\left(\\frac{4\\pi j}{n}\\right), \\quad j=0,1,\\dots,n-1,\n$$\n并将其视为嵌入到 $\\mathbb{C}^n$ 中的实向量。\n\n您的程序必须：\n- 针对每个测试用例，根据推导出的傅里叶系数精确构造 $T_n(f_{\\delta,\\theta_0})$。\n- 根据 $x_{\\text{true}}$ 计算 $b$。\n- 通过 Levinson–Durbin 递归和带主元的高斯消去法（作为 GKO 风格的稳定性代理）求解该系统。\n- 为每种方法和每个矩阵计算三个指标 $(E,R,\\kappa_2)$。\n- 生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，按以下顺序输出五个浮点数：\n$$\n\\left[E_{\\text{LD}},E_{\\text{GKO}},R_{\\text{LD}},R_{\\text{GKO}},\\kappa_2\\right],\n$$\n并将这五个测试用例的数组合连接成一个单一的扁平列表。例如，最终输出格式必须是\n$$\n\\left[ E_{\\text{LD}}^{(1)}, E_{\\text{GKO}}^{(1)}, R_{\\text{LD}}^{(1)}, R_{\\text{GKO}}^{(1)}, \\kappa_2^{(1)}, \\dots, E_{\\text{LD}}^{(5)}, E_{\\text{GKO}}^{(5)}, R_{\\text{LD}}^{(5)}, R_{\\text{GKO}}^{(5)}, \\kappa_2^{(5)} \\right].\n$$\n不涉及物理单位，所有角度均以弧度为单位。输出必须是严格符合所述列表格式的一行，并且数值以十进制浮点数表示。",
                "solution": "用户提供的问题是有效的。它在数值线性代数领域有坚实的科学基础，特别是关于结构化线性系统。问题设定是适定的：对于 $\\delta  0$，符号 $f_{\\delta,\\theta_0}(\\theta)$ 是严格为正的，这保证了埃尔米特托普利茨矩阵 $T_n(f)$ 是正定的，因而是可逆的。所有定义、参数和实验目标都得到了精确、客观的规定，构成了一个完整且无矛盾的问题陈述。\n\n### 步骤 1：傅里叶系数的推导与矩阵结构\n\n该问题要求从符号 $f_{\\delta,\\theta_0}(\\theta) = \\delta + 2 - 2\\cos(\\theta - \\theta_0)$ 构建一个埃尔米特托普利茨矩阵族 $T_n(f_{\\delta,\\theta_0})$。托普利茨矩阵的元素 $[T_n(f)]_{ij} = c_{i-j}$ 是符号 $f$ 的傅里叶系数。第 $k$ 个傅里叶系数 $c_k$ 定义为：\n$$\nc_k = \\frac{1}{2\\pi}\\int_0^{2\\pi} f_{\\delta,\\theta_0}(\\theta)e^{-ik\\theta}\\,d\\theta\n$$\n我们代入 $f_{\\delta,\\theta_0}(\\theta)$ 的表达式：\n$$\nc_k = \\frac{1}{2\\pi}\\int_0^{2\\pi} (\\delta + 2 - 2\\cos(\\theta - \\theta_0))e^{-ik\\theta}\\,d\\theta\n$$\n我们可以将积分分成两部分：\n1.  常数项：$\\frac{1}{2\\pi}\\int_0^{2\\pi} (\\delta + 2)e^{-ik\\theta}\\,d\\theta$。当 $k=0$ 时，该积分的值为 $\\delta + 2$；当 $k \\ne 0$ 时，值为 $0$。\n2.  余弦项：我们使用欧拉公式 $\\cos(x) = \\frac{e^{ix} + e^{-ix}}{2}$，可得 $-2\\cos(\\theta - \\theta_0) = -e^{i(\\theta - \\theta_0)} - e^{-i(\\theta - \\theta_0)} = -e^{-i\\theta_0}e^{i\\theta} - e^{i\\theta_0}e^{-i\\theta}$。\n    积分变为：\n    $$\n    -\\frac{1}{2\\pi}\\int_0^{2\\pi} (e^{-i\\theta_0}e^{i\\theta} + e^{i\\theta_0}e^{-i\\theta})e^{-ik\\theta}\\,d\\theta = -\\frac{e^{-i\\theta_0}}{2\\pi}\\int_0^{2\\pi} e^{i(1-k)\\theta}\\,d\\theta - \\frac{e^{i\\theta_0}}{2\\pi}\\int_0^{2\\pi} e^{-i(1+k)\\theta}\\,d\\theta\n    $$\n    第一个积分仅在 $1-k=0$（即 $k=1$）时非零，其值为 $-e^{-i\\theta_0}$。第二个积分仅在 $1+k=0$（即 $k=-1$）时非零，其值为 $-e^{i\\theta_0}$。\n\n综合这些结果，傅里叶系数为：\n-   当 $k=0$ 时：$c_0 = \\delta + 2$。\n-   当 $k=1$ 时：$c_1 = -e^{-i\\theta_0}$。\n-   当 $k=-1$ 时：$c_{-1} = -e^{i\\theta_0}$。\n-   当 $|k| \\ge 2$ 时：$c_k = 0$。\n\n埃尔米特属性 $c_{-k} = \\overline{c_k}$ 得到满足，因为 $c_{-1} = -e^{i\\theta_0} = -(\\cos\\theta_0 + i\\sin\\theta_0)$ 且 $\\overline{c_1} = \\overline{-e^{-i\\theta_0}} = -\\overline{\\cos(-\\theta_0) + i\\sin(-\\theta_0)} = -(\\cos\\theta_0 - i\\sin\\theta_0)$，这与 $c_{-1}$ 相等。由于当 $|k| \\ge 2$ 时系数 $c_k$ 为零，最终得到的 $n \\times n$ 矩阵 $T_n(f_{\\delta,\\theta_0})$ 是一个埃尔米特三对角托普利茨矩阵：\n$$\nT_n = \\begin{pmatrix}\nc_0  c_{-1}  0  \\dots  0 \\\\\nc_1  c_0  c_{-1}  \\dots  0 \\\\\n0  c_1  c_0  \\ddots  \\vdots \\\\\n\\vdots   \\ddots  \\ddots  c_{-1} \\\\\n0  \\dots  0  c_1  c_0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\delta+2  \\overline{c_1}  0  \\dots  0 \\\\\nc_1  \\delta+2  \\overline{c_1}  \\dots  0 \\\\\n0  c_1  \\delta+2  \\ddots  \\vdots \\\\\n\\vdots   \\ddots  \\ddots  \\overline{c_1} \\\\\n0  \\dots  0  c_1  \\delta+2\n\\end{pmatrix}\n$$\n其中 $c_1 = -e^{-i\\theta_0}$。\n\n### 步骤 2：算法设计与实验设置\n\n该实验比较了求解线性系统 $T_n x = b$ 的两种算法。定义了向量 $x_{\\text{true}}$，并通过 $b = T_n x_{\\text{true}}$ 计算右端项 $b$，从而为准确性分析建立基准真相。\n\n1.  **Levinson–Durbin 递归**：这是一种求解具有托普利茨矩阵结构的线性系统的快速算法，复杂度为 $O(n^2)$。对于由其第一列 $c = [c_0, c_1, \\dots, c_{n-1}]^T$ 定义的埃尔米特托普利茨矩阵，该算法迭代地构建解。已知它对于正定矩阵是数值稳定的。然而，当 $\\delta \\to 0$ 时，$T_n$ 变得病态，由于没有主元选择机制，舍入误差的传播可能会导致算法精度下降。将使用标准实现，例如 `scipy.linalg.solve_toeplitz`。\n\n2.  **GKO 风格的带主元方法（代理）**：Gohberg–Kailath–Olshevsky (GKO) 算法是一种针对结构化矩阵的快速（$O(n^2)$）求解器，它可以引入主元选择以保证数值稳定性。主元选择会破坏矩阵结构，使得算法变得异常复杂。作为一种稳定的、带主元的快速求解器的代理，该问题指定对稠密矩阵使用经典的部分主元高斯消去法（GEPP）。虽然其复杂度较高，为 $O(n^3)$，但它可作为一个数值稳定性的基准，用以与非主元选择的 Levinson-Durbin 方法进行比较。GEPP 是用于求解一般稠密线性系统的标准稳健算法，并在诸如 `numpy.linalg.solve` 的例程中实现。\n\n### 步骤 3：评估指标\n\n每种方法的性能通过三个指标来量化：\n\n1.  **相对解误差 ($E$)**：衡量计算出的解 $\\hat{x}$ 与已知的真实解 $x_{\\text{true}}$ 的接近程度。\n    $$\n    E = \\frac{\\| \\hat{x} - x_{\\text{true}} \\|_2}{\\| x_{\\text{true}} \\|_2}\n    $$\n2.  **相对残差范数 ($R$)**：衡量计算出的解在多大程度上满足原方程。一个小的残差表明 $\\hat{x}$ 是一个邻近问题 $T_n x = b + \\Delta b$ 的精确解。\n    $$\n    R = \\frac{\\| b - T_n \\hat{x} \\|_2}{\\| b \\|_2}\n    $$\n3.  **2-范数条件数 ($\\kappa_2$)**：矩阵 $T_n$ 的一个内在属性，它限定了输入数据（$T_n$ 和 $b$）中的误差到输出解 $x$ 的放大程度。大的条件数表示一个病态问题，其中小的输入扰动可能导致解发生大的变化。\n    $$\n    \\kappa_2(T_n) = \\|T_n\\|_2 \\cdot \\|T_n^{-1}\\|_2\n    $$\n    对于给定的方法，我们预期存在近似关系 $E \\lesssim \\kappa_2(T_n) (R + \\epsilon_{\\text{mach}})$，其中 $\\epsilon_{\\text{mach}}$ 是机器精度。\n\n该实验系统地改变参数 $(n, \\theta_0, \\delta)$，以观察矩阵大小、符号近零点的位置以及与奇异性的接近程度如何影响稳定性和准确性。随着 $\\delta$ 趋近于 $0$，$\\kappa_2(T_n)$ 预计会变得很大，从而对求解器的数值稳定性构成挑战。预期 GEPP 代理由于其主元选择策略，在严重病态的情况下，将比不带主元选择的 Levinson-Durbin 递归保持更好的准确性（即更小的 $E$）。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import toeplitz, solve_toeplitz\n\ndef solve():\n    \"\"\"\n    Designs and runs a parameterized experiment to compare the numerical stability\n    of Levinson-Durbin recursion and a GKO-style pivoted approach (proxied by GEPP)\n    for solving ill-conditioned Hermitian Toeplitz linear systems.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, np.pi/4, 1e-2),\n        (64, np.pi/3, 1e-6),\n        (64, 0.01, 1e-8),\n        (16, np.pi - 0.01, 1e-9),\n        (8, np.pi/6, 1e-12),\n    ]\n\n    results = []\n    for n, theta0, delta in test_cases:\n        # Step 1: Construct the Hermitian Toeplitz matrix T_n\n        \n        # Derive the Fourier coefficients c_k from the symbol.\n        # c_0 = delta + 2\n        # c_1 = -exp(-i*theta0)\n        # c_k = 0 for |k| >= 2\n        c0 = delta + 2.0\n        c1 = -np.exp(-1j * theta0)\n        \n        # The first column of the Toeplitz matrix\n        c_col = np.zeros(n, dtype=np.complex128)\n        c_col[0] = c0\n        if n > 1:\n            c_col[1] = c1\n\n        # The first row of the Hermitian Toeplitz matrix.\n        # r_k = c_{-k} = conjugate(c_k)\n        r_row = np.conjugate(c_col)\n\n        # Construct the dense matrix T_n.\n        # This is a tridiagonal Hermitian Toeplitz matrix.\n        T = toeplitz(c_col, r_row)\n\n        # Step 2: Define the true solution x_true and compute the RHS b\n        j = np.arange(n)\n        x_true = np.sin(2 * np.pi * j / n) + 0.5 * np.cos(4 * np.pi * j / n)\n        x_true = x_true.astype(np.complex128) # Treat as complex vector\n        \n        b = T @ x_true\n        \n        # Step 3: Solve the system T*x = b using both methods.\n        \n        # Method 1: Levinson-Durbin recursion\n        # scipy.linalg.solve_toeplitz uses Levinson-Durbin for Hermitian matrices.\n        # It takes the first column `c_col` as input.\n        x_ld = solve_toeplitz(c_col, b)\n        \n        # Method 2: GKO-style proxy (Gaussian Elimination with Partial Pivoting)\n        # numpy.linalg.solve uses LAPACK's gesv, which implements GEPP.\n        x_gko = np.linalg.solve(T, b)\n\n        # Step 4: Compute the evaluation metrics\n        \n        # Norms for relative error and residual calculations\n        norm_xtrue = np.linalg.norm(x_true, 2)\n        norm_b = np.linalg.norm(b, 2)\n\n        # Relative solution error E\n        E_ld = np.linalg.norm(x_ld - x_true, 2) / norm_xtrue\n        E_gko = np.linalg.norm(x_gko - x_true, 2) / norm_xtrue\n\n        # Relative residual norm R\n        R_ld = np.linalg.norm(b - T @ x_ld, 2) / norm_b\n        R_gko = np.linalg.norm(b - T @ x_gko, 2) / norm_b\n\n        # 2-norm condition number kappa_2\n        kappa2 = np.linalg.cond(T, p=2)\n\n        results.extend([E_ld, E_gko, R_ld, R_gko, kappa2])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{v:.15e}' for v in results)}]\")\n\nsolve()\n```",
                "id": "3545692"
            },
            {
                "introduction": "在实际计算中，仅仅达到理论上的算法复杂度（如 $O(n \\log n)$）并不足以保证最佳性能，还必须考虑算法与硬件架构之间的交互。本练习将引导您进入性能建模领域，通过一个简化的屋顶线（roofline）模型，来量化分析缓存大小、内存带宽以及具体FFT算法选择（例如 Cooley-Tukey 与分裂基算法）等因素如何影响整个迭代求解器的端到端速度。这个实践将帮助您从理论复杂度分析过渡到对现代计算平台上真实性能的预测与理解 ([@problem_id:3545756])。",
                "problem": "您将执行一项性能建模任务，旨在为使用快速傅里叶变换 (FFT) 通过循环嵌入来加速托普利茨（Toeplitz）矩阵向量乘法 (MVM) 的快速求解器进行建模。目标是量化在使用分裂基 FFT 与基-$2$ Cooley–Tukey FFT 时预测的端到端求解器加速比，并通过一个简单的 Roofline 风格模型，明确揭示缓存命中或缓存未命中机制如何在现代中央处理器 (CPU) 上改变这些加速比。\n\n您必须实现一个程序，计算一个使用 $k$ 次迭代的 Krylov 子空间求解器的预测端到端运行时间，其中每次迭代主要由一次使用 FFT 计算的托普利茨 MVM 以及标准的向量运算主导。假设托普利茨矩阵在迭代过程中是固定的，并且是厄米特正定的，因此共轭梯度法适用。您将在同一求解器结构内比较两种 FFT 实现：\n- 一种基-$2$ Cooley–Tukey FFT（记为 $\\mathrm{CT}$），\n- 一种分裂基 FFT（记为 $\\mathrm{SR}$）。\n\n您必须使用以下基本且经过充分检验的数学事实作为基础：\n- 一个大小为 $n$ 的托普利茨 MVM 可以通过嵌入到一个长度为 $m \\ge 2n-1$ 的循环卷积中，并通过 FFT 计算该卷积来执行。为了计算效率，请使用一个 2 的幂次的嵌入长度 $L = 2^{\\lceil \\log_2(2n-1) \\rceil}$。\n- 对于具有固定核的托普利茨 MVM，需要对长度为 $L$ 的核进行一次性的 FFT 预计算。随后的每次 MVM 都需要对长度为 $L$ 的填充输入进行一次正向 FFT，一次长度为 $L$ 的逐元素复数乘法，以及一次长度为 $L$ 的逆向 FFT。\n- 在双精度复数算术中，每个复数占用 $16$ 字节。\n- 采用 Roofline 风格的性能模型：对于任何总浮点运算 (FLOP) 数为 $F$、总内存流量为 $M$ 字节的操作，在峰值浮点运算速率为 $P$ FLOP/s、持续内存带宽为 $B$ 字节/s 的 CPU 上，其时间被建模为计算时间与内存时间的最大值：\n$$\nT \\;=\\; \\max\\!\\left(\\frac{F}{P}, \\frac{M}{B}\\right).\n$$\n\n按如下方式对操作计数和内存流量进行建模。\n\n1) FFT 算术功。对于长度为 $L$ 的复数 FFT：\n- 基-$2$ Cooley–Tukey 模型：FLOPs $F_{\\mathrm{CT}}(L) = c_{\\mathrm{CT}}\\, L \\log_2 L$，其中 $c_{\\mathrm{CT}} = 10$。\n- 分裂基模型：FLOPs $F_{\\mathrm{SR}}(L) = c_{\\mathrm{SR}}\\, L \\log_2 L$，其中 $c_{\\mathrm{SR}} = 9$。\n\n2) FFT 内存流量。对于在容量为 $C$ 字节的缓存上进行的长度为 $L$ 的复数 FFT：\n- 如果工作集能够容纳，即 $16L \\le C$，则假设每次 FFT 进行两次完整的数组扫描，因此 $M_{\\mathrm{fit}}(L) = 2 \\cdot 16 L$ 字节。\n- 如果无法容纳，则假设每层有依赖于算法的流式传输遍数：\n$$\nM_{\\mathrm{CT,miss}}(L) \\;=\\; \\rho_{\\mathrm{CT}} \\cdot 16 L \\log_2 L,\\quad \\rho_{\\mathrm{CT}} = 2.0,\n$$\n$$\nM_{\\mathrm{SR,miss}}(L) \\;=\\; \\rho_{\\mathrm{SR}} \\cdot 16 L \\log_2 L,\\quad \\rho_{\\mathrm{SR}} = 1.7.\n$$\n如果 $16L \\le C$，则使用 $M_{\\mathrm{FFT}}(L) = M_{\\mathrm{fit}}(L)$，否则使用 $M_{\\mathrm{FFT}}(L) = M_{\\mathrm{algo,miss}}(L)$。\n\n3) 用于卷积的逐元素复数乘法。对于长度 $L$，假设 FLOPs 为 $F_{\\times}(L) = 6L$，内存为 $M_{\\times}(L) = 3 \\cdot 16 L$ 字节（读取两个输入，写入一个输出）。\n\n4) 每次共轭梯度法迭代对长度为 $n$ 的向量进行的向量运算：\n- 两次点积，每次建模为 $F_{\\mathrm{dot}}(n) = 8n$ FLOPs 和 $M_{\\mathrm{dot}}(n) = 2 \\cdot 16 n$ 字节。\n- 三次 AXPY 运算 $z \\leftarrow \\alpha x + y$，其中 $\\alpha$ 为复数，每次建模为 $F_{\\mathrm{axpy}}(n) = 8n$ FLOPs 和 $M_{\\mathrm{axpy}}(n) = 3 \\cdot 16 n$ 字节。\n对于向量运算，无论 $C$ 为多少，都按规定方式对内存流量进行建模；这些是流式向量核。\n\n给定 $n$、$k$、$P$、$B$ 和 $C$：\n- 计算 $L = 2^{\\lceil \\log_2(2n-1) \\rceil}$。\n- 预计算时间：对长度为 $L$ 的核进行一次 FFT。\n- 每次迭代中托普利茨 MVM 的时间：一次长度为 $L$ 的正向 FFT，一次长度为 $L$ 的逐元素复数乘法，以及一次长度为 $L$ 的逆向 FFT。\n- 每次迭代中向量操作的时间：对长度为 $n$ 的向量进行两次点积和三次 AXPY 运算。\n- 算法 $\\mathrm{algo} \\in \\{\\mathrm{CT}, \\mathrm{SR}\\}$ 的总端到端时间：\n$$\nT_{\\mathrm{algo}} \\;=\\; T_{\\mathrm{FFT,pre}}^{(\\mathrm{algo})}(L) \\;+\\; k \\,\\Big( T_{\\mathrm{FFT,fwd}}^{(\\mathrm{algo})}(L) + T_{\\times}(L) + T_{\\mathrm{FFT,inv}}^{(\\mathrm{algo})}(L) + 2\\,T_{\\mathrm{dot}}(n) + 3\\,T_{\\mathrm{axpy}}(n) \\Big),\n$$\n其中每个分量的时间根据 $T=\\max(F/P,\\, M/B)$ 计算，使用上述模型中该分量和算法对应的 $F$ 和 $M$。\n\n您的程序必须为每个测试用例输出预测的加速因子\n$$\nS \\;=\\; \\frac{T_{\\mathrm{CT}}}{T_{\\mathrm{SR}}},\n$$\n表示为一个浮点数，四舍五入到小数点后六位，无单位。\n\n测试套件。请精确使用以下四个测试用例，每个都是一个元组 $(n,k,P,B,C)$：\n- 案例 1（小规模，缓存命中，中等带宽）：$(n,k,P,B,C) = (4096,\\,100,\\,3\\times 10^{11},\\,1\\times 10^{11},\\,32\\times 10^{6})$。\n- 案例 2（小规模，缓存命中，高带宽）：$(n,k,P,B,C) = (4096,\\,100,\\,3\\times 10^{11},\\,4\\times 10^{11},\\,32\\times 10^{6})$。\n- 案例 3（大规模，无法容纳，中等带宽）：$(n,k,P,B,C) = (10^{6},\\,30,\\,3\\times 10^{11},\\,1\\times 10^{11},\\,32\\times 10^{6})$。\n- 案例 4（边界规模，在较小缓存下无法容纳）：$(n,k,P,B,C) = (524288,\\,20,\\,3\\times 10^{11},\\,1\\times 10^{11},\\,16\\times 10^{6})$。\n\n最终输出格式。您的程序应生成单行输出，其中包含按测试套件顺序排列的四个加速比，形式为用方括号括起来的逗号分隔列表，每个加速比四舍五入到小数点后六位。例如，格式必须如下所示：\n\"[1.000000,1.123456,1.234567,1.345678]\"。",
                "solution": "用户提供的问题经评估有效。其科学基础扎根于数值线性代数和高性能计算原理，问题陈述清晰，定义和参数完整且一致，并且表述客观。因此，提供了解决方案。\n\n目标是计算加速因子 $S = T_{\\mathrm{CT}} / T_{\\mathrm{SR}}$，其中 $T_{\\mathrm{CT}}$ 和 $T_{\\mathrm{SR}}$ 分别是使用基-$2$ Cooley-Tukey (CT) 和分裂基 (SR) FFT 算法的共轭梯度求解器的总执行时间。该解决方案通过系统地应用所提供的性能模型推导得出。\n\n首先，对于给定的问题规模 $n$，确定循环嵌入所需的 FFT 长度 $L$。一个大小为 $n$ 的托普利茨 MVM 被嵌入到一个长度至少为 $2n-1$ 的循环卷积中。为获得最佳 FFT 性能，长度将被填充到下一个 2 的幂：\n$$\nL = 2^{\\lceil \\log_2(2n-1) \\rceil}\n$$\n值 $\\log_2 L$ 就是指数 $\\lceil \\log_2(2n-1) \\rceil$。\n\n接下来，我们使用指定的 Roofline 模型建立每个基本运算的时间成本：$T = \\max(F/P, M/B)$，其中 $F$ 是浮点运算次数， $M$ 是以字节为单位的内存流量， $P$ 是峰值浮点运算速率， $B$ 是内存带宽。\n\n我们计算求解器中涉及的五个基本运算中每一个的时间：\n\n1.  **FFT 时间 ($T_{\\mathrm{FFT}}$)**：成本取决于算法（$\\mathrm{CT}$ 或 $\\mathrm{SR}$）。对于长度为 $L$ 的 FFT，FLOP 计数为：\n    - $F_{\\mathrm{CT}}(L) = c_{\\mathrm{CT}}\\, L \\log_2 L$，其中 $c_{\\mathrm{CT}} = 10$。\n    - $F_{\\mathrm{SR}}(L) = c_{\\mathrm{SR}}\\, L \\log_2 L$，其中 $c_{\\mathrm{SR}} = 9$。\n    内存流量 $M_{\\mathrm{FFT}}(L)$ 取决于大小为 $16L$ 字节的工作集是否能装入容量为 $C$ 的缓存中。\n    - 如果 $16L \\le C$ （缓存命中），则两种算法的 $M_{\\mathrm{fit}}(L) = 2 \\cdot 16 L = 32L$。\n    - 如果 $16L  C$ （缓存未命中），则流量与算法相关：\n      - $M_{\\mathrm{CT,miss}}(L) = \\rho_{\\mathrm{CT}} \\cdot 16 L \\log_2 L$，其中 $\\rho_{\\mathrm{CT}} = 2.0$。\n      - $M_{\\mathrm{SR,miss}}(L) = \\rho_{\\mathrm{SR}} \\cdot 16 L \\log_2 L$，其中 $\\rho_{\\mathrm{SR}} = 1.7$。\n    对于给定的算法 $\\mathrm{algo} \\in \\{\\mathrm{CT}, \\mathrm{SR}\\}$，FFT 时间为：\n    $$\n    T_{\\mathrm{FFT}}^{(\\mathrm{algo})}(L) = \\max\\left(\\frac{F_{\\mathrm{algo}}(L)}{P}, \\frac{M_{\\mathrm{FFT}}^{(\\mathrm{algo})}(L)}{B}\\right)\n    $$\n\n2.  **逐元素乘法时间 ($T_{\\times}$)**：对于长度为 $L$ 的向量的卷积步骤，FLOP 计数为 $F_{\\times}(L) = 6L$，内存流量为 $M_{\\times}(L) = 3 \\cdot 16 L = 48L$。时间为：\n    $$\n    T_{\\times}(L) = \\max\\left(\\frac{6L}{P}, \\frac{48L}{B}\\right)\n    $$\n\n3.  **点积时间 ($T_{\\mathrm{dot}}$)**：对于长度为 $n$ 的向量，FLOP 计数为 $F_{\\mathrm{dot}}(n) = 8n$，内存流量为 $M_{\\mathrm{dot}}(n) = 2 \\cdot 16 n = 32n$。时间为：\n    $$\n    T_{\\mathrm{dot}}(n) = \\max\\left(\\frac{8n}{P}, \\frac{32n}{B}\\right)\n    $$\n\n4.  **AXPY 时间 ($T_{\\mathrm{axpy}}$)**：对于长度为 $n$ 的向量，FLOP 计数为 $F_{\\mathrm{axpy}}(n) = 8n$，内存流量为 $M_{\\mathrm{axpy}}(n) = 3 \\cdot 16 n = 48n$。时间为：\n    $$\n    T_{\\mathrm{axpy}}(n) = \\max\\left(\\frac{8n}{P}, \\frac{48n}{B}\\right)\n    $$\n\n每种算法的总端到端时间是预计算时间与 $k$ 次迭代时间的总和。预计算包括对托普利茨核进行一次 FFT。每次迭代涉及一次托普利茨 MVM（两次 FFT 和一次逐元素乘法）和向量运算（两次点积和三次 AXPY）。逆向 FFT 的成本模型与正向 FFT 相同。\n\n算法 $\\mathrm{algo} \\in \\{\\mathrm{CT}, \\mathrm{SR}\\}$ 的总时间为：\n$$\nT_{\\mathrm{algo}} = T_{\\mathrm{FFT,pre}}^{(\\mathrm{algo})}(L) + k \\cdot \\left( T_{\\mathrm{FFT,fwd}}^{(\\mathrm{algo})}(L) + T_{\\mathrm{FFT,inv}}^{(\\mathrm{algo})}(L) + T_{\\times}(L) + 2 \\cdot T_{\\mathrm{dot}}(n) + 3 \\cdot T_{\\mathrm{axpy}}(n) \\right)\n$$\n这可以简化为：\n$$\nT_{\\mathrm{algo}} = (1 + 2k) \\cdot T_{\\mathrm{FFT}}^{(\\mathrm{algo})}(L) + k \\cdot \\left( T_{\\times}(L) + 2 \\cdot T_{\\mathrm{dot}}(n) + 3 \\cdot T_{\\mathrm{axpy}}(n) \\right)\n$$\n\n对于每个测试用例 $(n, k, P, B, C)$，流程是首先使用上述公式和相应参数计算 $T_{\\mathrm{CT}}$ 和 $T_{\\mathrm{SR}}$。然后计算最终的加速比，即比率 $S = T_{\\mathrm{CT}} / T_{\\mathrm{SR}}$。每个案例的最终结果四舍五入到小数点后六位。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to calculate and print the speedup factors for the given test cases.\n    \"\"\"\n    # Test suite: each element is a tuple (n, k, P, B, C)\n    test_cases = [\n        # Case 1 (small, cache-fitting, moderate bandwidth)\n        (4096, 100, 3e11, 1e11, 32e6),\n        # Case 2 (small, cache-fitting, high bandwidth)\n        (4096, 100, 3e11, 4e11, 32e6),\n        # Case 3 (large, non-fitting, moderate bandwidth)\n        (1e6, 30, 3e11, 1e11, 32e6),\n        # Case 4 (boundary-scale, non-fitting under smaller cache)\n        (524288, 20, 3e11, 1e11, 16e6),\n    ]\n\n    # Algorithm-specific parameters\n    # Radix-2 Cooley-Tukey (CT)\n    params_ct = {'c_fft': 10.0, 'rho_fft': 2.0}\n    # Split-Radix (SR)\n    params_sr = {'c_fft': 9.0, 'rho_fft': 1.7}\n\n    results = []\n\n    for n, k, P, B, C in test_cases:\n        # Cast n to int if it's float from scientific notation 1e6\n        n = int(n)\n        \n        # Calculate total time for CT algorithm\n        t_ct = calculate_total_time(n, k, P, B, C, params_ct)\n\n        # Calculate total time for SR algorithm\n        t_sr = calculate_total_time(n, k, P, B, C, params_sr)\n\n        # Compute speedup and round to 6 decimal places\n        speedup = t_ct / t_sr\n        results.append(f\"{speedup:.6f}\")\n\n    # Print the results in the required format\n    print(f\"[{','.join(results)}]\")\n\ndef get_op_time(F, M, P, B):\n    \"\"\"\n    Computes the time for an operation using the roofline model.\n    T = max(time_compute, time_memory)\n    \"\"\"\n    time_compute = F / P\n    time_memory = M / B\n    return max(time_compute, time_memory)\n\ndef calculate_total_time(n, k, P, B, C, algo_params):\n    \"\"\"\n    Calculates the total end-to-end time for a given algorithm configuration.\n    \"\"\"\n    # 1. Calculate FFT length L\n    # Handle case n=0 or n=1\n    if n == 0:\n        log2_val = -np.inf\n    elif (2 * n - 1) = 0:\n        log2_val = 0\n    else:\n        log2_val = np.log2(2 * n - 1)\n    \n    log2L = np.ceil(log2_val)\n    L = 1  int(log2L)\n\n    # Convert log2L to float for multiplication\n    log2L_float = float(log2L)\n\n    # 2. Calculate time for each elementary operation\n    \n    # FFT time T_fft\n    c_fft = algo_params['c_fft']\n    rho_fft = algo_params['rho_fft']\n    bytes_per_complex = 16\n\n    F_fft = c_fft * L * log2L_float\n    \n    # Check cache-fit condition\n    if bytes_per_complex * L = C:\n        # Cache-fit\n        M_fft = 2.0 * bytes_per_complex * L\n    else:\n        # Cache-miss\n        M_fft = rho_fft * bytes_per_complex * L * log2L_float\n        \n    T_fft = get_op_time(F_fft, M_fft, P, B)\n\n    # Elementwise multiplication time T_mul\n    F_mul = 6.0 * L\n    M_mul = 3.0 * bytes_per_complex * L\n    T_mul = get_op_time(F_mul, M_mul, P, B)\n\n    # Dot product time T_dot\n    F_dot = 8.0 * n\n    M_dot = 2.0 * bytes_per_complex * n\n    T_dot = get_op_time(F_dot, M_dot, P, B)\n    \n    # AXPY time T_axpy\n    F_axpy = 8.0 * n\n    M_axpy = 3.0 * bytes_per_complex * n\n    T_axpy = get_op_time(F_axpy, M_axpy, P, B)\n    \n    # 3. Aggregate total time\n    # T_total = T_precompute + k * T_iteration\n    # T_precompute = 1 * T_fft\n    # T_iteration = (2 * T_fft + T_mul) + (2 * T_dot + 3 * T_axpy)\n    total_time = (1 + 2 * k) * T_fft + k * (T_mul + 2 * T_dot + 3 * T_axpy)\n\n    return total_time\n\n# Execute the solver\nsolve()\n```",
                "id": "3545756"
            }
        ]
    }