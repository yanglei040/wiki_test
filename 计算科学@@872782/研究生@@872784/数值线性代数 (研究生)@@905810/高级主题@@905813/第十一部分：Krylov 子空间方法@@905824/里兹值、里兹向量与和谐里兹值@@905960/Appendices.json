{
        "hands_on_practices": [
            {
                "introduction": "标准里兹方法在计算矩阵的极值特征值时非常有效，但往往难以捕捉内部特征值。这个练习通过一个精心设计的简单例子，直观地揭示了标准里兹方法为何会失效，以及调和里兹方法如何通过巧妙地改变投影测试子空间来成功定位内部特征值。通过这个实践，你将深入理解两种方法在几何直观和代数原理上的根本差异。",
                "problem": "令 $A \\in \\mathbb{R}^{3 \\times 3}$ 为对称矩阵 $A = \\operatorname{diag}(1, 2, 100)$。考虑二维试验子空间 $\\mathcal{K} = \\operatorname{span}\\{u_{1}, u_{2}\\}$，其中 $u_{1} = \\frac{1}{\\sqrt{1+\\varepsilon^{2}}}(e_{1} + \\varepsilon e_{2})$ 且 $u_{2} = e_{3}$，$e_{1}, e_{2}, e_{3}$ 是 $\\mathbb{R}^{3}$ 中的标准基向量，$\\varepsilon > 0$ 是一个固定的但其他方面任意的实数参数。记 $W \\in \\mathbb{R}^{3 \\times 2}$ 是以 $u_{1}$ 和 $u_{2}$ 为列的矩阵，使得 $\\mathcal{K} = \\operatorname{range}(W)$ 且 $W^{\\mathsf{T}}W = I$。\n\n仅使用基本定义，完成以下任务。\n\n1. 使用 Rayleigh–Ritz 投影原理，通过构建 $2 \\times 2$ 投影矩阵 $T = W^{\\mathsf{T}} A W$ 并计算其特征值来推导 Ritz 值。根据子空间的几何结构和对称矩阵的 Rayleigh 商刻画，解释为何对于小的 $\\varepsilon$，即使重复使用相同的子空间 $\\mathcal{K}$（如在具有固定子空间维数的重启动投影方法中），此过程也无法近似内部特征值 $2$。\n\n2. 使用带位移 $s \\in \\mathbb{R}$ 的和谐投影原理，该原理通过强制执行 Petrov–Galerkin 条件，即残差 $r(\\lambda, y) = A(Wy) - \\lambda (Wy)$ 与 $(A - s I)\\mathcal{K}$ 正交，来定义。在基 $W$ 中推导降维的广义特征值问题，并显式求解，以获得作为 $s$ 和 $\\varepsilon$ 函数的和谐 Ritz 值。\n\n3. 将您的表达式特化到位移 $s = 1$ 的情况。确定近似内部特征值的和谐 Ritz 值，并说明其精确值。然后，从机理上解释为什么在此子空间上，和谐投影能够成功，而标准的 Rayleigh–Ritz 投影却在内部特征值上停滞不前。\n\n您最终报告的答案必须是当 $s=1$ 时近似内部特征值的那个和谐 Ritz 值。不需要四舍五入，也不涉及单位。请以精确值的形式表示您的最终答案。",
                "solution": "该问题要求分析在一个特定的二维子空间 $\\mathcal{K}$ 中，使用 Rayleigh-Ritz 和和谐 Ritz 方法来近似给定 $3 \\times 3$ 对称矩阵 $A$ 的特征值。\n\n给定的矩阵是 $A = \\operatorname{diag}(1, 2, 100)$，它是 $\\mathbb{R}^{3 \\times 3}$ 中的一个元素。其特征值为 $\\lambda_1 = 1$, $\\lambda_2 = 2$ 和 $\\lambda_3 = 100$，对应的特征向量为标准基向量 $e_1$, $e_2$ 和 $e_3$。\n\n试验子空间为 $\\mathcal{K} = \\operatorname{span}\\{u_1, u_2\\}$，其中基向量为 $u_1 = \\frac{1}{\\sqrt{1+\\varepsilon^2}}(e_1 + \\varepsilon e_2)$ 和 $u_2 = e_3$。参数 $\\varepsilon$ 是一个固定的正实数。矩阵 $W \\in \\mathbb{R}^{3 \\times 2}$ 以 $u_1$ 和 $u_2$ 为列，并且题目给出 $W^{\\mathsf{T}}W = I$，这很容易验证。\n$W = \\begin{pmatrix} \\frac{1}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ \\frac{\\varepsilon}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ 0 & 1 \\end{pmatrix}$。\n\n**1. Rayleigh–Ritz 投影及其对内部特征值的失效**\n\nRayleigh-Ritz 方法通过寻找投影矩阵 $T = W^{\\mathsf{T}}AW$ 的特征值，来从子空间 $\\mathcal{K}$ 中求取 $A$ 的近似特征值。这些特征值被称为 Ritz 值。\n\n首先，我们计算矩阵 $AW$：\n$$ AW = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 2 & 0 \\\\ 0 & 0 & 100 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ \\frac{\\varepsilon}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ \\frac{2\\varepsilon}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ 0 & 100 \\end{pmatrix} $$\n接下来，我们计算 $T = W^{\\mathsf{T}}AW$：\n$$ T = \\begin{pmatrix} \\frac{1}{\\sqrt{1+\\varepsilon^2}} & \\frac{\\varepsilon}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ \\frac{2\\varepsilon}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ 0 & 100 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{1+\\varepsilon^2} + \\frac{2\\varepsilon^2}{1+\\varepsilon^2} & 0 \\\\ 0 & 100 \\end{pmatrix} = \\begin{pmatrix} \\frac{1+2\\varepsilon^2}{1+\\varepsilon^2} & 0 \\\\ 0 & 100 \\end{pmatrix} $$\n投影矩阵 $T$ 是对角矩阵。因此，其特征值，即 Ritz 值，就是对角线上的元素：\n$\\theta_1 = \\frac{1+2\\varepsilon^2}{1+\\varepsilon^2}$ 和 $\\theta_2 = 100$。\n\n对于小的 $\\varepsilon > 0$，第一个 Ritz 值可以分析为 $\\theta_1 = \\frac{1+\\varepsilon^2+\\varepsilon^2}{1+\\varepsilon^2} = 1 + \\frac{\\varepsilon^2}{1+\\varepsilon^2}$。当 $\\varepsilon \\to 0$ 时，$\\theta_1 \\to 1$。第二个 Ritz 值恰好是 $\\theta_2 = 100$。\n因此，Ritz 值近似了 $A$ 的极值特征值 $\\lambda_1 = 1$ 和 $\\lambda_3 = 100$。两者都不能近似内部特征值 $\\lambda_2 = 2$。\n\n这种失败的原因在于子空间 $\\mathcal{K}$ 的几何结构以及 Rayleigh 商的性质。Ritz 值是 Rayleigh 商 $R_A(x) = \\frac{x^{\\mathsf{T}}Ax}{x^{\\mathsf{T}}x}$ 在 $x \\in \\mathcal{K}$ 上的平稳值。Rayleigh-Ritz 方法能为那些其对应特征向量在试验子空间 $\\mathcal{K}$ 中有良好表示的特征值提供很好的近似。\n对于小的 $\\varepsilon$，基向量 $u_1$ 是特征向量 $e_1$ 的一个小扰动：$u_1 \\approx e_1$。另一个基向量 $u_2$ 恰好是特征向量 $e_3$。因此，子空间 $\\mathcal{K} = \\operatorname{span}\\{u_1, u_2\\}$ 与对应于极值特征值的特征子空间 $\\operatorname{span}\\{e_1, e_3\\}$ 紧密对齐。\n相反地，对应于内部特征值 $\\lambda_2=2$ 的特征向量 $e_2$ 几乎与 $\\mathcal{K}$ 正交。具体来说，$e_2$ 在 $\\mathcal{K}$ 上的投影范数为 $\\sqrt{(e_2^{\\mathsf{T}}u_1)^2 + (e_2^{\\mathsf{T}}u_2)^2} = \\sqrt{(\\frac{\\varepsilon}{\\sqrt{1+\\varepsilon^2}})^2 + 0} = \\frac{\\varepsilon}{\\sqrt{1+\\varepsilon^2}}$，对于小的 $\\varepsilon$ 来说，这个值很小。由于 $\\mathcal{K}$ 缺少 $e_2$ 方向上的重要分量，对于 $x \\in \\mathcal{K}$，Rayleigh 商 $R_A(x)$ 无法近似 $\\lambda_2 = R_A(e_2) = 2$。因此，标准的 Ritz 过程无法找到内部特征值。\n\n**2. 和谐 Ritz 投影**\n\n和谐 Ritz 方法在另一个不同的测试子空间上使用 Petrov-Galerkin 条件。给定一个位移 $s \\in \\mathbb{R}$，使残差 $r(\\lambda, y) = A(Wy) - \\lambda (Wy)$ 与测试子空间 $(A-sI)\\mathcal{K}$ 正交。这给出了条件：\n对于所有 $y \\in \\mathbb{R}^2$，都有 $((A-sI)W)^{\\mathsf{T}} (A-\\lambda I)Wy = 0$。\n由于 $A$ 是对称的，这导致了 $2 \\times 2$ 的广义特征值问题：\n$$ (W^{\\mathsf{T}}(A-sI)AW)y = \\lambda (W^{\\mathsf{T}}(A-sI)W)y $$\n令 $T_{std} = W^{\\mathsf{T}}AW$ 和 $S_{std} = W^{\\mathsf{T}}A^2W$。该问题可以写成 $(S_{std} - s T_{std})y = \\lambda (T_{std} - sI)y$。\n我们已经计算出 $T_{std} = \\begin{pmatrix} \\frac{1+2\\varepsilon^2}{1+\\varepsilon^2} & 0 \\\\ 0 & 100 \\end{pmatrix}$。\n现在我们计算 $S_{std} = W^{\\mathsf{T}}A^2W$。由于 $A^2 = \\operatorname{diag}(1, 4, 10000)$：\n$$ A^2W = \\begin{pmatrix} 1 & 0 & 0 \\\\ 0 & 4 & 0 \\\\ 0 & 0 & 10000 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ \\frac{\\varepsilon}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ \\frac{4\\varepsilon}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ 0 & 10000 \\end{pmatrix} $$\n$$ S_{std} = W^{\\mathsf{T}}A^2W = \\begin{pmatrix} \\frac{1}{\\sqrt{1+\\varepsilon^2}} & \\frac{\\varepsilon}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ 0 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} \\frac{1}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ \\frac{4\\varepsilon}{\\sqrt{1+\\varepsilon^2}} & 0 \\\\ 0 & 10000 \\end{pmatrix} = \\begin{pmatrix} \\frac{1+4\\varepsilon^2}{1+\\varepsilon^2} & 0 \\\\ 0 & 10000 \\end{pmatrix} $$\n由于两个矩阵都是对角矩阵，广义特征值问题解耦。令和谐 Ritz 值为 $\\lambda^{(H)}$。\n对于第一个特征值：\n$$ \\lambda_1^{(H)} = \\frac{(S_{std})_{11} - s(T_{std})_{11}}{(T_{std})_{11} - s} = \\frac{\\frac{1+4\\varepsilon^2}{1+\\varepsilon^2} - s\\frac{1+2\\varepsilon^2}{1+\\varepsilon^2}}{\\frac{1+2\\varepsilon^2}{1+\\varepsilon^2} - s} = \\frac{1+4\\varepsilon^2 - s(1+2\\varepsilon^2)}{1+2\\varepsilon^2 - s(1+\\varepsilon^2)} $$\n对于第二个特征值（假设 $s \\neq 100$）：\n$$ \\lambda_2^{(H)} = \\frac{(S_{std})_{22} - s(T_{std})_{22}}{(T_{std})_{22} - s} = \\frac{10000 - s(100)}{100 - s} = \\frac{100(100 - s)}{100 - s} = 100 $$\n和谐 Ritz 值为 $\\lambda_1^{(H)} = \\frac{1+4\\varepsilon^2 - s - 2s\\varepsilon^2}{1+2\\varepsilon^2 - s - s\\varepsilon^2}$ 和 $\\lambda_2^{(H)} = 100$。\n\n**3. 特化到 $s=1$ 的情况及解释**\n\n我们现在将结果特化到位移 $s=1$ 的情况。\n第二个和谐 Ritz 值保持为 $\\lambda_2^{(H)} = 100$。\n第一个和谐 Ritz 值变为：\n$$ \\lambda_1^{(H)} = \\frac{1+4\\varepsilon^2 - 1(1+2\\varepsilon^2)}{1+2\\varepsilon^2 - 1(1+\\varepsilon^2)} = \\frac{1+4\\varepsilon^2 - 1 - 2\\varepsilon^2}{1+2\\varepsilon^2 - 1 - \\varepsilon^2} = \\frac{2\\varepsilon^2}{\\varepsilon^2} = 2 $$\n对于任何 $\\varepsilon > 0$，这个和谐 Ritz 值恰好是 $2$，也就是 $A$ 的内部特征值。\n\n当 $s=1$ 时和谐投影的成功归功于测试子空间 $(A-sI)\\mathcal{K}$ 的选择。当 $s=1$ 时，测试子空间变为 $(A-I)\\mathcal{K}$。让我们求这个空间的一组基。$\\mathcal{K}$ 的基向量是 $u_1$ 和 $u_2$。测试空间的基是 $\\{(A-I)u_1, (A-I)u_2\\}$。\n$$ (A-I)u_1 = (A-I)\\frac{1}{\\sqrt{1+\\varepsilon^2}}(e_1 + \\varepsilon e_2) = \\frac{1}{\\sqrt{1+\\varepsilon^2}}((A-I)e_1 + \\varepsilon(A-I)e_2) $$\n由于 $Ae_1 = 1e_1$ 且 $Ae_2 = 2e_2$，我们有 $(A-I)e_1 = 0$ 和 $(A-I)e_2 = e_2$。因此：\n$$ (A-I)u_1 = \\frac{1}{\\sqrt{1+\\varepsilon^2}}(0 + \\varepsilon e_2) = \\frac{\\varepsilon}{\\sqrt{1+\\varepsilon^2}} e_2 $$\n对于第二个基向量：\n$$ (A-I)u_2 = (A-I)e_3 = Ae_3 - e_3 = 100e_3 - e_3 = 99e_3 $$\n测试空间为 $(A-I)\\mathcal{K} = \\operatorname{span}\\{e_2, e_3\\}$。\n\n对于一个近似特征对 $(\\theta, x)$，其中 $x \\in \\mathcal{K}$，和谐 Ritz 条件是残差 $Ax-\\theta x$ 必须与该测试空间正交。这意味着残差必须同时与 $e_2$ 和 $e_3$ 正交。\n考虑向量 $u_1 \\in \\mathcal{K}$。我们来求值 $\\theta$ 使得 $(Au_1 - \\theta u_1) \\perp \\operatorname{span}\\{e_2, e_3\\}$。残差为：\n$$ Au_1 - \\theta u_1 = \\frac{1}{\\sqrt{1+\\varepsilon^2}}(e_1 + 2\\varepsilon e_2) - \\frac{\\theta}{\\sqrt{1+\\varepsilon^2}}(e_1 + \\varepsilon e_2) = \\frac{1}{\\sqrt{1+\\varepsilon^2}} \\left[ (1-\\theta)e_1 + (2-\\theta)\\varepsilon e_2 \\right] $$\n为使该残差与 $e_2$ 正交，其 $e_2$ 分量必须为零。这要求 $(2-\\theta)\\varepsilon = 0$。由于 $\\varepsilon > 0$，我们必须有 $\\theta = 2$。当 $\\theta=2$ 时，残差变为 $\\frac{-1}{\\sqrt{1+\\varepsilon^2}}e_1$，它确实与 $e_2$ 和 $e_3$ 都正交。\n因此，$(\\theta=2, x=u_1)$ 是一个和谐 Ritz 对。位移 $s=1=\\lambda_1$ 的选择从测试空间中滤除了 $e_1$ 方向，迫使该方法使用 $e_2$ 方向上的可用信息。相比之下，标准的 Rayleigh-Ritz 方法使用一个测试空间 $\\mathcal{K} \\approx \\operatorname{span}\\{e_1, e_3\\}$，该空间几乎对 $e_2$ 方向“视而不见”，从而导致其失败。\n\n当 $s=1$ 时，近似内部特征值的和谐 Ritz 值恰好是 $2$。",
                "answer": "$$\\boxed{2}$$",
                "id": "3574738"
            },
            {
                "introduction": "理解了调和里兹方法的优势后，下一个关键问题是如何高效地实现它。直接根据定义计算需要处理大规模矩阵的乘积，这在计算上是昂贵的。本练习将指导你如何利用 Arnoldi 分解关系，推导出一个仅依赖于小规模 Hessenberg 矩阵的等价广义特征值问题。这不仅是理论上的一个优雅技巧，更是将调和里兹方法应用于实际大规模问题中的核心步骤。",
                "problem": "设 $A \\in \\mathbb{C}^{n \\times n}$ 为一个一般矩阵，且 $m \\ll n$。使用 $m$ 步 Arnoldi 过程，为一个由非零向量 $b \\in \\mathbb{C}^{n}$ 生成的 Krylov 子空间构造一组标准正交基 $V_{m} \\in \\mathbb{C}^{n \\times m}$，并令 $V_{m+1} \\in \\mathbb{C}^{n \\times (m+1)}$ 表示由额外增加一个 Arnoldi 向量扩展而来的相同基底。Arnoldi 关系式是一个基本恒等式\n$$\nA V_{m} \\;=\\; V_{m+1} \\,\\widehat{H}_{m},\n$$\n其中 $\\widehat{H}_{m} \\in \\mathbb{C}^{(m+1) \\times m}$ 是上 Hessenberg 矩阵，其顶部的 $m \\times m$ 子块记为 $H_{m} \\in \\mathbb{C}^{m \\times m}$。关于子空间 $\\mathrm{range}(V_{m})$ 的一个 Ritz 对 $(\\lambda, u)$ 满足 $u = V_{m} y$（对于某个 $y \\in \\mathbb{C}^{m}$）以及 Galerkin 条件，即残量 $A u - \\lambda u$ 与 $\\mathrm{range}(V_{m})$ 正交。关于复位移 $\\sigma \\in \\mathbb{C}$ 的一个和谐 Ritz 对 $(\\theta, u)$ 满足 $u = V_{m} y$（对于某个 $y \\in \\mathbb{C}^{m}$）以及 Petrov-Galerkin 条件，即残量 $A u - \\theta u$ 与 $(A - \\sigma I)\\mathrm{range}(V_{m})$ 正交。\n\n仅从 Arnoldi 关系式和这些定义出发，推导一个降维的 $m \\times m$ 广义特征值问题，该问题能够产生相对于位移 $\\sigma$ 的和谐 Ritz 值与和谐 Ritz 向量，而无需显式构造 $(A - \\sigma I) V_{m}$。你的推导必须仅依赖于小矩阵 $H_{m}$、$\\widehat{H}_{m}$ 以及提取前 $m$ 行的选择算子 $E^{*} \\in \\mathbb{C}^{m \\times (m+1)}$，即 $E^{*} = [\\,I_{m} \\;\\; 0\\,]$，从而 $E^{*} \\widehat{H}_{m} = H_{m}$。然后，设计并实现一个算法，该算法：\n- 对每个测试用例，通过 $m$ 步 Arnoldi 过程计算 $V_{m+1}$ 和 $\\widehat{H}_{m}$。\n- 通过求解 $H_{m}$ 上的投影特征问题来计算 Ritz 值与 Ritz 向量。\n- 通过求解你推导出的、仅使用 $H_{m}$ 和 $\\widehat{H}_{m}$（而不使用 $(A - \\sigma I) V_{m}$）的降维广义特征值问题来计算和谐 Ritz 值与和谐 Ritz 向量。\n- 对每个测试用例，选择（在绝对差意义下）最接近 $\\sigma$ 的 Ritz 值与和谐 Ritz 值，构造相应的近似特征向量 $u_{\\mathrm{ritz}}$ 和 $u_{\\mathrm{harm}}$，并报告所选对的残量范数 $\\lVert A u - \\lambda u \\rVert_{2}$。\n\n你的程序必须实现上述完整流程，并针对以下测试套件生成所要求的输出。所有矩阵、向量和标量均被明确给出：\n- 测试用例 1 (实对称矩阵，靠近最小特征值的内部位移)：\n  - $n = 6$, \n  $$\n  A_{1} = \\begin{bmatrix}\n  2  -1  0  0  0  0 \\\\\n  -1  2  -1  0  0  0 \\\\\n  0  -1  2  -1  0  0 \\\\\n  0  0  -1  2  -1  0 \\\\\n  0  0  0  -1  2  -1 \\\\\n  0  0  0  0  -1  2\n  \\end{bmatrix},\n  \\quad\n  b_{1} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\n  \\quad\n  m_{1} = 4,\n  \\quad\n  \\sigma_{1} = 0.1.\n  $$\n- 测试用例 2 (实非 Hermitian 上 Hessenberg 矩阵，靠近内部特征值的位移)：\n  - $n = 5$,\n  $$\n  A_{2} = \\begin{bmatrix}\n  4  1  0  0  0 \\\\\n  2  3  1  0  0 \\\\\n  0  2  3  1  0 \\\\\n  0  0  2  3  1 \\\\\n  0  0  0  2  3\n  \\end{bmatrix},\n  \\quad\n  b_{2} = \\frac{1}{\\sqrt{5}} \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1 \\end{bmatrix},\n  \\quad\n  m_{2} = 4,\n  \\quad\n  \\sigma_{2} = 2.9.\n  $$\n- 测试用例 3 (复、轻度非正规矩阵，位于目标特征值的位移)：\n  - $n = 5$,\n  $$\n  A_{3} = \\begin{bmatrix}\n  1 + 2\\mathrm{i}  0.1  0  0  0 \\\\\n  0  2 + \\mathrm{i}  0.1  0  0 \\\\\n  0  0  3 + 0.5\\mathrm{i}  0.1  0 \\\\\n  0  0  0  4  0.1 \\\\\n  0  0  0  0  5 - \\mathrm{i}\n  \\end{bmatrix},\n  \\quad\n  b_{3} = \\frac{1}{\\sqrt{5}} \\begin{bmatrix} 1 \\\\ \\mathrm{i} \\\\ 1 \\\\ -\\mathrm{i} \\\\ 1 \\end{bmatrix},\n  \\quad\n  m_{3} = 3,\n  \\quad\n  \\sigma_{3} = 3 + 0.5\\mathrm{i}.\n  $$\n\n对每个测试用例 $j \\in \\{1,2,3\\}$，你的程序必须：\n- 选择最接近 $\\sigma_{j}$ 的和谐 Ritz 值 $\\theta_{j}$ 及其向量 $u_{\\mathrm{harm},j} = V_{m_{j}} y_{\\mathrm{harm},j}$，并计算残量范数 $r_{\\mathrm{harm},j} = \\lVert A_{j} u_{\\mathrm{harm},j} - \\theta_{j} u_{\\mathrm{harm},j} \\rVert_{2}$。\n- 选择最接近 $\\sigma_{j}$ 的 Ritz 值 $\\lambda_{j}$ 及其向量 $u_{\\mathrm{ritz},j} = V_{m_{j}} y_{\\mathrm{ritz},j}$，并计算残量范数 $r_{\\mathrm{ritz},j} = \\lVert A_{j} u_{\\mathrm{ritz},j} - \\lambda_{j} u_{\\mathrm{ritz},j} \\rVert_{2}$。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，包含一个长度为3的 Python 风格列表，其中每个元素本身是对应于测试用例 $j$ 的一个长度为4的列表，格式为\n  $$\n  [ \\,\\mathrm{Re}(\\theta_{j}),\\ \\mathrm{Im}(\\theta_{j}),\\ r_{\\mathrm{harm},j},\\ r_{\\mathrm{ritz},j} - r_{\\mathrm{harm},j} \\,],\n  $$\n  每个数字四舍五入到8位小数。全部输出应为一行，不含空格，例如\n  $$\n  [[a_{11},a_{12},a_{13},a_{14}],[a_{21},a_{22},a_{23},a_{24}],[a_{31},a_{32},a_{33},a_{34}]].\n  $$\n\n科学真实性约束：\n- 你必须完全由 Arnoldi 关系式和给定的正交性条件推导出降维广义特征值问题。你不得使用任何用于提取和谐 Ritz 值的、已经包含了目标结论的预封装公式，也不得在任何时候显式构造 $(A - \\sigma I)\\,V_{m}$。你的实现必须仅使用从 Arnoldi 过程中获得的小投影矩阵来执行计算。\n\n所有答案均为纯数（无单位）。本问题不涉及角度和物理单位。最终打印输出必须遵循上述确切格式。",
                "solution": "此问题是有效的。这是一个数值线性代数中的适定问题，基于已确立的科学原理和 Krylov 子空间方法的定义。所有数据和条件都已提供且一致。\n\n解决方案包含两个主要部分：首先，推导 Ritz 对与和谐 Ritz 对的降维特征值问题；其次，实现一个算法来计算这些量及其对给定测试用例的相应残量范数。\n\n### 降维特征值问题的推导\n\n设 $A \\in \\mathbb{C}^{n \\times n}$ 为一个矩阵，$\\mathrm{range}(V_m)$ 是一个由 $V_m \\in \\mathbb{C}^{n \\times m}$ 的标准正交列向量张成的 $m$ 维子空间。这些列向量构成了从向量 $b$ 开始，经过 $m$ 步 Arnoldi 过程生成的 Krylov 子空间 $\\mathcal{K}_m(A, b)$ 的一组基。Arnoldi 过程产生关系式 $A V_m = V_{m+1} \\widehat{H}_m$，其中 $V_{m+1} \\in \\mathbb{C}^{n \\times (m+1)}$ 是一组标准正交基，$\\widehat{H}_m \\in \\mathbb{C}^{(m+1) \\times m}$ 是一个上 Hessenberg 矩阵。矩阵 $H_m \\in \\mathbb{C}^{m \\times m}$ 由 $\\widehat{H}_m$ 的前 $m$ 行组成。\n\n**1. Ritz 对**\n\n关于子空间 $\\mathrm{range}(V_m)$ 的一个 Ritz 对 $(\\lambda, u)$ 由一个近似特征向量 $u = V_m y$（对于某个非零向量 $y \\in \\mathbb{C}^m$）和 Galerkin 条件定义。该条件规定残量 $r = A u - \\lambda u$ 与子空间 $\\mathrm{range}(V_m)$ 正交。此条件表示为：\n$$ V_m^* (A u - \\lambda u) = 0 $$\n代入 $u = V_m y$：\n$$ V_m^* (A V_m y - \\lambda V_m y) = 0 $$\n分配 $V_m^*$ 并利用 $V_m$ 列向量的标准正交性 ($V_m^* V_m = I_m$)：\n$$ (V_m^* A V_m) y - \\lambda (V_m^* V_m) y = 0 $$\n$$ (V_m^* A V_m) y = \\lambda y $$\n为简化 $V_m^* A V_m$，我们使用 Arnoldi 关系式。设 $E^* = [I_m \\;\\; 0] \\in \\mathbb{C}^{m \\times (m+1)}$ 为提取前 $m$ 行的选择算子，使得 $H_m = E^* \\widehat{H}_m$。我们也可以写出 $V_m = V_{m+1} E$，其中 $E = [I_m^T \\;\\; 0^T]^T$。\n$$ V_m^* A V_m = (V_{m+1} E)^* (V_{m+1} \\widehat{H}_m) = E^* V_{m+1}^* V_{m+1} \\widehat{H}_m $$\n由于 $V_{m+1}$ 是标准正交的，因此 $V_{m+1}^* V_{m+1} = I_{m+1}$。\n$$ V_m^* A V_m = E^* \\widehat{H}_m = H_m $$\n因此，Galerkin 条件导出了一个大小为 $m \\times m$ 的降维标准特征值问题：\n$$ H_m y = \\lambda y $$\n$H_m$ 的特征值 $\\lambda$ 是 Ritz 值，对应的近似特征向量为 $u = V_m y$，其中 $y$ 是 $H_m$ 的一个特征向量。\n\n**2. 和谐 Ritz 对**\n\n关于位移 $\\sigma \\in \\mathbb{C}$ 的一个和谐 Ritz 对 $(\\theta, u)$ 由一个近似特征向量 $u = V_m y$ 和 Petrov-Galerkin 条件定义。该条件要求残量 $r = A u - \\theta u$ 与测试子空间 $(A - \\sigma I)\\mathrm{range}(V_m)$ 正交。这表示为：\n$$ ((A - \\sigma I)V_m)^* (A u - \\theta u) = 0 $$\n代入 $u = V_m y$：\n$$ ((A - \\sigma I)V_m)^* (A V_m y - \\theta V_m y) = 0 $$\n该方程必须对测试空间中的任何基的选择都成立，这导出了矩阵方程：\n$$ V_m^* (A^* - \\bar{\\sigma}I) (A - \\theta I) V_m y = 0 $$\n其中 $\\bar{\\sigma}$ 是 $\\sigma$ 的复共轭。我们展开各项：\n$$ \\left( V_m^* A^* A V_m - \\theta V_m^* A^* V_m - \\bar{\\sigma} V_m^* A V_m + \\theta\\bar{\\sigma} V_m^* V_m \\right) y = 0 $$\n我们使用 Arnoldi 关系式来计算每个投影矩阵项：\n- $V_m^* V_m = I_m$ (根据标准正交性)。\n- $V_m^* A V_m = H_m$ (如 Ritz 对部分所示)。\n- $V_m^* A^* V_m = (V_m^* A V_m)^* = H_m^*$。\n- 对于 $V_m^* A^* A V_m$ 项，我们使用完整的 Arnoldi 关系式：\n$$ V_m^* A^* A V_m = (A V_m)^* (A V_m) = (V_{m+1} \\widehat{H}_m)^* (V_{m+1} \\widehat{H}_m) = \\widehat{H}_m^* V_{m+1}^* V_{m+1} \\widehat{H}_m = \\widehat{H}_m^* I_{m+1} \\widehat{H}_m = \\widehat{H}_m^* \\widehat{H}_m $$\n将这些代入展开的方程中得到：\n$$ \\left( \\widehat{H}_m^* \\widehat{H}_m - \\theta H_m^* - \\bar{\\sigma} H_m + \\theta\\bar{\\sigma} I_m \\right) y = 0 $$\n为了将其表述为关于 $\\theta$ 的广义特征值问题，我们将包含 $\\theta$ 的项归类：\n$$ (\\widehat{H}_m^* \\widehat{H}_m - \\bar{\\sigma} H_m) y = \\theta (H_m^* - \\bar{\\sigma} I_m) y $$\n这就是所要求的 $m \\times m$ 广义特征值问题 $K y = \\theta M y$，其中矩阵 $K$ 和 $M$ 为：\n$$ K = \\widehat{H}_m^* \\widehat{H}_m - \\bar{\\sigma} H_m $$\n$$ M = H_m^* - \\bar{\\sigma} I_m $$\n这些矩阵仅依赖于 Arnoldi 过程的产物 $\\widehat{H}_m$ 及其子矩阵 $H_m$ 和位移 $\\sigma$。此推导成功避免了显式构造或使用 $(A - \\sigma I)V_m$。\n\n### 算法实现\n\n对每个测试用例 $(A_j, b_j, m_j, \\sigma_j)$，算法流程如下：\n1.  **Arnoldi 过程**：\n    -   使用带有修正 Gram-Schmidt 正交化的 $m_j$ 步 Arnoldi 迭代，计算出 Krylov 子空间 $\\mathcal{K}_{m_j+1}(A_j, b_j)$ 的一组标准正交基 $V_{m_j+1} \\in \\mathbb{C}^{n_j \\times (m_j+1)}$ 和上 Hessenberg 矩阵 $\\widehat{H}_{m_j} \\in \\mathbb{C}^{(m_j+1) \\times m_j}$。使用修正 Gram-Schmidt 是为了数值稳定性。\n2.  **Ritz 对计算**：\n    -   从 $\\widehat{H}_{m_j}$ 的前 $m_j$ 行中提取矩阵 $H_{m_j}$。\n    -   求解标准特征问题 $H_{m_j} y = \\lambda y$ 以找到 Ritz 值 $\\lambda$ 和对应的特征向量 $y$。\n    -   选择最接近位移 $\\sigma_j$ 的 Ritz 值 $\\lambda_j$。\n    -   完整的近似特征向量被重构为 $u_{\\mathrm{ritz},j} = V_{m_j} y_{\\mathrm{ritz},j}$，其中 $V_{m_j}$ 包含 $V_{m_j+1}$ 的前 $m_j$ 列。向量 $u_{\\mathrm{ritz},j}$ 具有单位范数。\n    -   计算残量范数 $r_{\\mathrm{ritz},j} = \\lVert A_j u_{\\mathrm{ritz},j} - \\lambda_j u_{\\mathrm{ritz},j} \\rVert_{2}$。\n3.  **和谐 Ritz 对计算**：\n    -   构造矩阵 $K = \\widehat{H}_{m_j}^* \\widehat{H}_{m_j} - \\bar{\\sigma}_j H_{m_j}$ 和 $M = H_{m_j}^* - \\bar{\\sigma}_j I_{m_j}$。\n    -   求解广义特征问题 $K y = \\theta M y$ 以得到和谐 Ritz 值 $\\theta$ 和特征向量 $y$。\n    -   从有限解的集合中选择最接近位移 $\\sigma_j$ 的和谐 Ritz 值 $\\theta_j$。\n    -   完整的近似特征向量被重构为 $u_{\\mathrm{harm},j} = V_{m_j} y_{\\mathrm{harm},j}$。由于广义特征问题的特征向量不一定是单位范数，为了公平地比较残量，$u_{\\mathrm{harm},j}$被归一化为单位范数。\n    -   计算残量范数 $r_{\\mathrm{harm},j} = \\lVert A_j u_{\\mathrm{harm},j} - \\theta_j u_{\\mathrm{harm},j} \\rVert_{2}$。\n4.  **输出格式化**：\n    -   对每个测试用例，创建一个包含 $[\\mathrm{Re}(\\theta_j), \\mathrm{Im}(\\theta_j), r_{\\mathrm{harm},j}, r_{\\mathrm{ritz},j} - r_{\\mathrm{harm},j}]$ 的列表，其中每个值都四舍五入到8位小数。\n\n提供的 Python 代码实现了这一完整流程。",
                "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases, including Arnoldi iteration,\n    Ritz and Harmonic Ritz analysis, and residual norm computation.\n    \"\"\"\n    # Test case 1 data\n    A1 = np.array([\n        [2., -1., 0., 0., 0., 0.],\n        [-1., 2., -1., 0., 0., 0.],\n        [0., -1., 2., -1., 0., 0.],\n        [0., 0., -1., 2., -1., 0.],\n        [0., 0., 0., -1., 2., -1.],\n        [0., 0., 0., 0., -1., 2.]\n    ], dtype=np.float64)\n    b1 = np.array([1., 0., 0., 0., 0., 0.], dtype=np.float64)\n    m1 = 4\n    sigma1 = 0.1\n\n    # Test case 2 data\n    A2 = np.array([\n        [4., 1., 0., 0., 0.],\n        [2., 3., 1., 0., 0.],\n        [0., 2., 3., 1., 0.],\n        [0., 0., 2., 3., 1.],\n        [0., 0., 0., 2., 3.]\n    ], dtype=np.float64)\n    b2 = np.ones(5, dtype=np.float64) / np.sqrt(5)\n    m2 = 4\n    sigma2 = 2.9\n\n    # Test case 3 data\n    A3 = np.array([\n        [1. + 2.j, 0.1, 0., 0., 0.],\n        [0., 2. + 1.j, 0.1, 0., 0.],\n        [0., 0., 3. + 0.5j, 0.1, 0.],\n        [0., 0., 0., 4., 0.1],\n        [0., 0., 0., 0., 5. - 1.j]\n    ], dtype=np.complex128)\n    b3 = np.array([1., 1.j, 1., -1.j, 1.], dtype=np.complex128) / np.sqrt(5)\n    m3 = 3\n    sigma3 = 3. + 0.5j\n\n    test_cases = [ (A1, b1, m1, sigma1), (A2, b2, m2, sigma2), (A3, b3, m3, sigma3) ]\n    \n    final_results = []\n    \n    for A, b, m, sigma in test_cases:\n        n = A.shape[0]\n        dtype = A.dtype\n\n        # 1. Arnoldi Process using Modified Gram-Schmidt\n        V = np.zeros((n, m + 1), dtype=dtype)\n        H_hat = np.zeros((m + 1, m), dtype=dtype)\n        \n        V[:, 0] = b / np.linalg.norm(b)\n\n        for j in range(m):\n            w = A @ V[:, j]\n            for i in range(j + 1):\n                H_hat[i, j] = V[:, i].conj().T @ w\n                w = w - H_hat[i, j] * V[:, i]\n            \n            h_next = np.linalg.norm(w)\n            H_hat[j + 1, j] = h_next\n            \n            # Avoid division by zero in case of breakdown (unlikely for these tests)\n            if h_next > 1e-14:\n                V[:, j + 1] = w / h_next\n            # else: breakdown occurred, H_hat[j+1,j] is 0, V[:,j+1] is 0.\n\n        V_m = V[:, :m]\n        H_m = H_hat[:m, :m]\n\n        # 2. Ritz values and vectors\n        ritz_vals, ritz_vecs_y = eig(H_m)\n        idx_ritz = np.argmin(np.abs(ritz_vals - sigma))\n        lambda_ritz = ritz_vals[idx_ritz]\n        y_ritz = ritz_vecs_y[:, idx_ritz]\n        u_ritz = V_m @ y_ritz\n        # u_ritz is already unit norm as y_ritz is and V_m is orthonormal\n        r_ritz_norm = np.linalg.norm(A @ u_ritz - lambda_ritz * u_ritz)\n\n        # 3. Harmonic Ritz values and vectors\n        K = H_hat.conj().T @ H_hat - np.conj(sigma) * H_m\n        M = H_m.conj().T - np.conj(sigma) * np.eye(m, dtype=dtype)\n        \n        harm_vals, harm_vecs_y = eig(K, M)\n\n        # Filter out non-finite eigenvalues (e.g., inf) before finding the closest\n        finite_mask = np.isfinite(harm_vals)\n        finite_harm_vals = harm_vals[finite_mask]\n        finite_indices = np.where(finite_mask)[0]\n\n        if len(finite_harm_vals) == 0:\n             # Should not happen in this problem\n             raise ValueError(\"No finite harmonic Ritz values found.\")\n\n        idx_in_finite = np.argmin(np.abs(finite_harm_vals - sigma))\n        idx_harm = finite_indices[idx_in_finite]\n        \n        theta_harm = harm_vals[idx_harm]\n        y_harm = harm_vecs_y[:, idx_harm]\n\n        u_harm = V_m @ y_harm\n        # Normalize u_harm for fair residual comparison, as generalized eigenvectors are not unit-norm\n        u_harm = u_harm / np.linalg.norm(u_harm)\n        r_harm_norm = np.linalg.norm(A @ u_harm - theta_harm * u_harm)\n        \n        # 4. Store results with specified rounding\n        result_for_case = [\n            round(theta_harm.real, 8),\n            round(theta_harm.imag, 8),\n            round(r_harm_norm, 8),\n            round(r_ritz_norm - r_harm_norm, 8)\n        ]\n        final_results.append(result_for_case)\n\n    # Final print statement in the exact required format\n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n```",
                "id": "3574726"
            },
            {
                "introduction": "为了获得一个好的内部特征值近似，Krylov 子空间的维度需要多大？这个问题涉及到算法的收敛速度和计算效率。这个最终的练习将引导你对标准里兹和调和里兹方法的收敛性进行深入的量化分析。你将探索子空间维度 $m$、初始向量 $b$ 的选择（通过最小多项式的阶体现）以及目标特征向量在子空间中的“可捕获性”之间的关系，从而具体地看到调和里兹方法在收敛速度上的显著优势。",
                "problem": "考虑一个方阵 $A \\in \\mathbb{C}^{n \\times n}$ 和一个非零起始向量 $b \\in \\mathbb{C}^{n}$。由 $(A,b)$ 生成的 $m$ 阶克雷洛夫子空间定义为\n$$\n\\mathcal{K}_m(A,b) = \\operatorname{span}\\{b, Ab, A^2 b, \\dots, A^{m-1} b\\}。\n$$\n设 $A$ 相对于 $b$ 的最小多项式是次数最小的首一多项式 $p$，使得 $p(A) b = 0$。其次数等于 Arnoldi 过程（或带正交化的幂基）遇到崩溃时的第一个 $m$，也等于 $\\mathcal{K}_m(A,b)$ 停止增长时的维数。瑞利-里兹方法通过寻找满足伽辽金正交性条件的 $(\\theta, v)$（其中 $v \\in \\mathcal{K}_m(A,b)$）来近似 $A$ 的特征对 $(\\lambda, u)$\n$$\nA v - \\theta v \\perp \\mathcal{K}_m(A,b)。\n$$\n对于接近目标位移 $\\sigma \\in \\mathbb{C}$ 的内部特征值，谐波瑞利-里兹方法修改了彼得罗夫-伽辽金条件，以强制要求\n$$\nA v - \\theta v \\perp (A - \\sigma I)\\mathcal{K}_m(A,b),\n$$\n这会产生以下小型广义特征值问题\n$$\nV_m^H (A - \\sigma I)^H A V_m \\, y \\;=\\; \\theta \\, V_m^H (A - \\sigma I)^H V_m \\, y,\n$$\n其中 $V_m \\in \\mathbb{C}^{n \\times m}$ 具有标准正交列，这些列张成 $\\mathcal{K}_m(A,b)$，$H$ 表示共轭转置，$y \\in \\mathbb{C}^m$ 提供谐波里兹向量 $v = V_m y$ 和谐波里兹值 $\\theta$。\n\n您的任务是以定量和程序化的方式，分析最小多项式次数在谐波里兹方法成功求解内部特征值中所扮演的角色。具体来说，对于每个给定的测试用例 $(A,b,\\sigma)$：\n\n1. 通过从归一化的 $b$ 开始运行 Arnoldi 过程，并检测由于线性相关性导致的第一次崩溃（使用下一个向量的范数小于 $10^{-12}$ 的数值阈值），计算 $A$ 相对于 $b$ 的最小多项式的次数，记为 $d_b(A)$。\n\n2. 将 $A$ 的内部目标特征值 $\\lambda_\\star$ 识别为其实部最接近给定偏移 $\\sigma$ 的特征值。令 $u_\\star$ 表示相应的右特征向量，归一化为单位 $2$-范数。\n\n3. 对于每个 $m = 1, 2, \\dots, n$，通过 Arnoldi 过程为 $\\mathcal{K}_m(A,b)$ 构建一个标准正交基 $V_m$。将目标特征向量的子空间捕获质量定义为\n$$\n\\cos(\\angle(u_\\star, \\mathcal{K}_m)) \\;=\\; \\lVert V_m^H \\, u_\\star \\rVert_2,\n$$\n这是 $u_\\star$ 和 $\\mathcal{K}_m(A,b)$ 之间最小主角的余弦。确定最小的 $m$ 使得 $\\cos(\\angle(u_\\star, \\mathcal{K}_m)) \\ge \\tau_v$，其中阈值为 $\\tau_v = 0.95$。如果不存在这样的 $m \\le n$，则报告 $n+1$。\n\n4. 对于标准的瑞利-里兹方法，将里兹值计算为投影矩阵 $H_m = V_m^H A V_m$ 的特征值。确定最小的 $m$，使得存在一个里兹值 $\\theta^{\\mathrm{RR}}$ 满足 $|\\operatorname{Re}(\\theta^{\\mathrm{RR}}) - \\operatorname{Re}(\\lambda_\\star)| \\le \\tau_\\lambda$，使用容差 $\\tau_\\lambda = 10^{-3}$。如果不存在这样的 $m \\le n$，则报告 $n+1$。\n\n5. 对于给定 $\\sigma$ 的谐波瑞利-里兹方法，求解广义特征值问题\n$$\nV_m^H (A - \\sigma I)^H A V_m \\, y \\;=\\; \\theta \\, V_m^H (A - \\sigma I)^H V_m \\, y。\n$$\n确定最小的 $m$，使得存在一个谐波里兹值 $\\theta^{\\mathrm{HR}}$ 满足 $|\\operatorname{Re}(\\theta^{\\mathrm{HR}}) - \\operatorname{Re}(\\lambda_\\star)| \\le \\tau_\\lambda$。如果不存在这样的 $m \\le n$，则报告 $n+1$。\n\n对于每个测试用例，报告列表\n$$\n[d_b(A), \\, m_{\\text{vec}}, \\, m_{\\text{RR}}, \\, m_{\\text{HR}}],\n$$\n其中 $m_{\\text{vec}}$ 来自步骤 3，$m_{\\text{RR}}$ 来自步骤 4，$m_{\\text{HR}}$ 来自步骤 5。\n\n推导和算法设计的基本依据必须仅依赖于上述定义：克雷洛夫子空间、通过克雷洛夫崩溃得到的最小多项式、瑞利-里兹伽辽金投影，以及与 $(A - \\sigma I)\\mathcal{K}_m$ 的残差正交性的谐波瑞利-里兹彼得罗夫-伽辽金投影。\n\n程序必须实现这些步骤，并生成单行输出，其中包含所有测试用例的结果，形式为由方括号括起来的、每个案例列表组成的逗号分隔列表，例如\n$$\n[\\,[d_1, m_{v,1}, m_{\\mathrm{RR},1}, m_{\\mathrm{HR},1}], \\,[d_2, m_{v,2}, m_{\\mathrm{RR},2}, m_{\\mathrm{HR},2}], \\,[d_3, m_{v,3}, m_{\\mathrm{RR},3}, m_{\\mathrm{HR},3}]\\,]。\n$$\n不涉及物理单位。角度通过内积计算的主角隐式处理，因此不需要明确的角度单位。不使用百分比；所有阈值均以小数形式指定。\n\n测试套件：\n\n- 案例 1 (对称、对角、内部接近零):\n  $$\n  n_1 = 10,\\quad\n  A_1 = \\operatorname{diag}(-8, -4, -1.1, -0.35, 0.07, 0.19, 0.92, 2.1, 4.0, 7.3),\n  $$\n  $$\n  b_1 = (1.0, 0.8, 0.6, 0.4, 0.4, 0.3, 0.2, 0.1, 0.05, 0.025)^T,\\quad\n  \\sigma_1 = 0.0.\n  $$\n\n- 案例 2 (非对称、带若尔当块、内部接近二):\n  $$\n  n_2 = 8,\\quad\n  A_2 = \\operatorname{diag}(-6.0, -2.5, -0.2, 1.8, 1.8, 3.5, 5.5, 8.0),\\quad\n  (A_2)_{4,5} = 1.0,\n  $$\n  $$\n  b_2 = (0.1, 0.9, 0.2, 1.0, 0.0, 0.3, 0.2, 0.1)^T,\\quad\n  \\sigma_2 = 2.0.\n  $$\n\n- 案例 3 (对称、对角、缺少分量的边缘情况):\n  $$\n  n_3 = 6,\\quad\n  A_3 = \\operatorname{diag}(-3.0, -1.0, 0.5, 2.0, 4.0, 6.0),\n  $$\n  $$\n  b_3 = (0.2, -0.5, 0.0, 0.1, 0.3, -0.4)^T,\\quad\n  \\sigma_3 = 0.0.\n  $$\n\n对所有案例使用阈值 $\\tau_v = 0.95$ 和 $\\tau_\\lambda = 10^{-3}$。在 Arnoldi 过程中进行数值崩溃检测时，将候选的下一个基向量的范数小于 $10^{-12}$ 视为崩溃。如果在步骤 3-5 中的任何标准对于所有 $m \\le n$ 都不满足，则为该数量返回 $n+1$。\n\n您的程序应生成单行输出，其中包含所有结果，格式为方括号括起来的逗号分隔列表，格式完全如下\n$$\n[\\,[d_b(A_1), m_{\\text{vec},1}, m_{\\text{RR},1}, m_{\\text{HR},1}],\\,[d_b(A_2), m_{\\text{vec},2}, m_{\\text{RR},2}, m_{\\text{HR},2}],\\,[d_b(A_3), m_{\\text{vec},3}, m_{\\text{RR},3}, m_{\\text{HR},3}]\\,]。\n$$",
                "solution": "用户提供的问题是数值线性代数中一个明确定义的任务，要求实现和分析克雷洛夫子空间方法。该问题是有效的，因为它具有科学依据、自洽、客观且可通过算法求解。我们将继续提供完整的解决方案。\n\n### 数学框架\n\n问题的核心在于克雷洛夫子空间的构建和应用。\n\n1.  **克雷洛夫子空间和 Arnoldi 迭代：**\n    对于矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 和向量 $b \\in \\mathbb{C}^n$，第 $m$ 个克雷洛夫子空间为 $\\mathcal{K}_m(A,b) = \\operatorname{span}\\{b, Ab, \\dots, A^{m-1} b\\}$。Arnoldi 迭代是为 $\\mathcal{K}_m(A,b)$ 构建一个标准正交基 $V_m = [v_1, \\dots, v_m]$ 的过程。它通过将 $A v_j$ 与所有先前的向量 $\\{v_1, \\dots, v_j\\}$ 正交化来迭代生成向量 $v_{j+1}$。该过程产生 Arnoldi 关系式：\n    $$\n    A V_m = V_m H_m + h_{m+1,m} v_{m+1} e_m^T\n    $$\n    其中 $V_m \\in \\mathbb{C}^{n \\times m}$ 具有标准正交列，$H_m \\in \\mathbb{C}^{m \\times m}$ 是一个上 Hessenberg 矩阵，$h_{m+1,m}$ 是一个标量，$v_{m+1} \\in \\mathbb{C}^n$ 是一个与 $V_m$ 的列正交的单位向量，$e_m$ 是 $\\mathbb{C}^m$ 中的第 $m$ 个标准基向量。\n\n2.  **最小多项式次数 $d_b(A)$：**\n    $A$ 相对于 $b$ 的最小多项式的次数，记作 $d_b(A)$，是可能的最大克雷洛夫子空间 $\\mathcal{K}_m(A,b)$ 的维数。这恰好是 Arnoldi 迭代崩溃时的步数 $m$，意味着向量 $w_j = A v_j - \\sum_{i=1}^j (v_i^H A v_j) v_i$ 变为零（或数值上接近零）。在我们的算法中，这对应于找到第一个 $m$ 使得 $h_{m+1,m}  10^{-12}$。如果对于 $m  n$ 没有发生此类崩溃，则 $d_b(A) = n$。\n\n3.  **瑞利-里兹方法：**\n    此方法寻求一个近似特征对 $(\\theta, v)$，其中 $v \\in \\mathcal{K}_m(A,b)$ 且残差 $Av - \\theta v$ 与子空间 $\\mathcal{K}_m(A,b)$ 正交。设 $v = V_m y$，条件 $V_m^H(AV_m y - \\theta V_m y) = 0$ 导出标准特征值问题：\n    $$\n    V_m^H A V_m y = \\theta y \\implies H_m y = \\theta y\n    $$\n    $H_m$ 的特征值是里兹值 $\\theta^{\\mathrm{RR}}$。\n\n4.  **谐波瑞利-里兹方法：**\n    此方法旨在寻找接近位移 $\\sigma \\in \\mathbb{C}$ 的内部特征值。正交性条件被修改：残差 $Av - \\theta v$ 被要求与测试子空间 $(A - \\sigma I)\\mathcal{K}_m(A,b)$ 正交。设 $v = V_m y$，这给出 $V_m^H (A-\\sigma I)^H (AV_m y - \\theta V_m y) = 0$，它定义了广义特征值问题：\n    $$\n    \\left(V_m^H (A - \\sigma I)^H A V_m\\right) y = \\theta \\left(V_m^H (A - \\sigma I)^H V_m\\right) y\n    $$\n    这个矩阵束的特征值 $\\theta$ 是谐波里兹值 $\\theta^{\\mathrm{HR}}$。\n\n### 算法设计\n\n对于每个测试用例 $(A, b, \\sigma)$:\n\n1.  **目标识别：** 首先，我们计算矩阵 $A$ 的完整特征系统。目标特征值 $\\lambda_\\star$ 被识别为其实部最接近给定偏移 $\\sigma$ 的那个。相应的归一化特征向量记为 $u_\\star$。\n\n2.  **Arnoldi 分解：** 我们执行一个完整的 Arnoldi 迭代，从归一化向量 $b/\\|b\\|_2$ 开始，为 $m=1, \\dots, n$ 生成标准正交基 $V_m$ 和相应的 Hessenberg 矩阵 $H_m$。在此过程中，我们检测第一个迭代索引 $m$，在该索引处，待正交化的新向量的范数低于阈值 $10^{-12}$。此索引是最小多项式的次数 $d_b(A)$。令克雷洛夫空间的最大维数为 $m_{\\max} = d_b(A)$。\n\n3.  **迭代分析：** 然后我们让 $m$ 从 $1$ 循环到 $m_{\\max}$。在每次迭代中，如果三个指定的条件尚未满足，我们会检查它们：\n    a.  **向量捕获 ($m_{\\text{vec}}$):** 通过 $\\lVert V_m^H u_\\star \\rVert_2$ 计算 $u_\\star$ 与 $\\mathcal{K}_m(A,b)$ 之间主角的余弦。第一个使该值超过 $\\tau_v=0.95$ 的 $m$ 被记录为 $m_{\\text{vec}}$。\n    b.  **瑞利-里兹收敛 ($m_{\\text{RR}}$):** 求解 $H_m = V_m^H A V_m$ 的标准特征值问题以找到里兹值。第一个使至少一个里兹值 $\\theta^{\\mathrm{RR}}$ 满足 $|\\operatorname{Re}(\\theta^{\\mathrm{RR}}) - \\operatorname{Re}(\\lambda_\\star)| \\le \\tau_\\lambda=10^{-3}$ 的 $m$ 被记录为 $m_{\\text{RR}}$。\n    c.  **谐波里兹收敛 ($m_{\\text{HR}}$):** 构造矩阵 $A_{\\text{HR}} = V_m^H (A - \\sigma I)^H A V_m$ 和 $B_{\\text{HR}} = V_m^H (A - \\sigma I)^H V_m$。求解广义特征值问题 $A_{\\text{HR}}y = \\theta B_{\\text{HR}}y$ 以获得谐波里兹值。第一个使至少一个有限谐波里兹值 $\\theta^{\\mathrm{HR}}$ 满足 $|\\operatorname{Re}(\\theta^{\\mathrm{HR}}) - \\operatorname{Re}(\\lambda_\\star)| \\le \\tau_\\lambda=10^{-3}$ 的 $m$ 被记录为 $m_{\\text{HR}}$。\n\n4.  **结果汇编：** 如果对于所有 $m \\le m_{\\max}$ 仍有任何条件未满足，其相应的值将保持为 $n+1$。测试用例的最终结果是列表 $[d_b(A), m_{\\text{vec}}, m_{\\text{RR}}, m_{\\text{HR}}]$。\n\n此过程应用于所有提供的测试用例。一个值得注意的特例是案例3，其中起始向量 $b$ 与目标特征向量 $u_\\star$ 正交。因此，$u_\\star$ 在任何克雷洛夫子空间 $\\mathcal{K}_m(A,b)$ 中都没有分量，因此两种里兹方法都无法近似相应的特征值 $\\lambda_\\star$。这导致收敛标准永远不会被满足。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef process_case(A, b, sigma, n):\n    \"\"\"\n    Analyzes a single test case (A, b, sigma) as per the problem description.\n    \"\"\"\n    # Define problem constants and numerical thresholds\n    TOL_BREAKDOWN = 1e-12\n    TAU_V = 0.95\n    TAU_L = 1e-3\n\n    # Ensure data types are complex for all calculations\n    A = A.astype(np.complex128)\n    b = b.astype(np.complex128)\n    sigma = np.complex128(sigma)\n\n    # Initialize result variables with the \"not found\" value\n    m_vec_res = n + 1\n    m_rr_res = n + 1\n    m_hr_res = n + 1\n\n    # Step 2: Identify the interior target eigenvalue and eigenvector\n    evals, evecs = np.linalg.eig(A)\n    target_idx = np.argmin(np.abs(np.real(evals) - np.real(sigma)))\n    lambda_star = evals[target_idx]\n    u_star = evecs[:, target_idx]\n    u_star = u_star / np.linalg.norm(u_star)\n\n    # Step 1: Compute Arnoldi factorization and minimal polynomial degree\n    V = np.zeros((n, n), dtype=np.complex128)\n    H = np.zeros((n + 1, n), dtype=np.complex128)\n    \n    # Normalize the starting vector b\n    norm_b = np.linalg.norm(b)\n    if norm_b == 0: # Should not happen based on problem, but robust\n        return [0, n + 1, n + 1, n + 1]\n    V[:, 0] = b / norm_b\n\n    d_b_A = n\n    m_max = n\n    for j in range(n):\n        w = A @ V[:, j]\n        # Modified Gram-Schmidt\n        for i in range(j + 1):\n            H[i, j] = V[:, i].conj().T @ w\n            w = w - H[i, j] * V[:, i]\n        \n        if j  n - 1:\n            H[j + 1, j] = np.linalg.norm(w)\n            if H[j + 1, j]  TOL_BREAKDOWN:\n                # Arnoldi breakdown detected\n                d_b_A = j + 1\n                m_max = j + 1\n                break\n            V[:, j + 1] = w / H[j + 1, j]\n\n    # Steps 3-5: Analyze convergence for m = 1 to m_max\n    for m in range(1, m_max + 1):\n        V_m = V[:, :m]\n        H_m = H[:m, :m]\n\n        # Step 3: Check vector capture quality\n        if m_vec_res == n + 1:\n            cos_angle = np.linalg.norm(V_m.conj().T @ u_star)\n            if cos_angle >= TAU_V:\n                m_vec_res = m\n\n        # Step 4: Check Rayleigh-Ritz convergence\n        if m_rr_res == n + 1 and m > 0:\n            ritz_vals_rr = np.linalg.eigvals(H_m)\n            if np.any(np.abs(np.real(ritz_vals_rr) - np.real(lambda_star)) = TAU_L):\n                m_rr_res = m\n\n        # Step 5: Check Harmonic Rayleigh-Ritz convergence\n        if m_hr_res == n + 1 and m > 0:\n            # Form matrices for the generalized eigenvalue problem\n            A_Vm = A @ V_m\n            A_minus_sigma_I_Vm = A_Vm - sigma * V_m\n            \n            A_hr = A_minus_sigma_I_Vm.conj().T @ A_Vm\n            B_hr = A_minus_sigma_I_Vm.conj().T @ V_m\n            \n            try:\n                # Solve the GEP; discard eigenvectors\n                ritz_vals_hr, _ = eig(A_hr, B_hr)\n                # Filter out non-finite eigenvalues (e.g., inf)\n                finite_ritz_vals_hr = ritz_vals_hr[np.isfinite(ritz_vals_hr)]\n                if len(finite_ritz_vals_hr) > 0:\n                    if np.any(np.abs(np.real(finite_ritz_vals_hr) - np.real(lambda_star)) = TAU_L):\n                        m_hr_res = m\n            except np.linalg.LinAlgError:\n                # GEP solver might fail if B_hr is singular and ill-conditioned.\n                # If so, the condition is not met for this m.\n                pass\n\n    return [d_b_A, m_vec_res, m_rr_res, m_hr_res]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1\n    n1 = 10\n    A1 = np.diag(np.array([-8.0, -4.0, -1.1, -0.35, 0.07, 0.19, 0.92, 2.1, 4.0, 7.3]))\n    b1 = np.array([1.0, 0.8, 0.6, 0.4, 0.4, 0.3, 0.2, 0.1, 0.05, 0.025])\n    sigma1 = 0.0\n\n    # Case 2\n    n2 = 8\n    A2 = np.diag(np.array([-6.0, -2.5, -0.2, 1.8, 1.8, 3.5, 5.5, 8.0]))\n    A2[3, 4] = 1.0  # Note: A[i,j] in problem is 1-indexed, here 0-indexed\n    b2 = np.array([0.1, 0.9, 0.2, 1.0, 0.0, 0.3, 0.2, 0.1])\n    sigma2 = 2.0\n\n    # Case 3\n    n3 = 6\n    A3 = np.diag(np.array([-3.0, -1.0, 0.5, 2.0, 4.0, 6.0]))\n    b3 = np.array([0.2, -0.5, 0.0, 0.1, 0.3, -0.4])\n    sigma3 = 0.0\n\n    test_cases = [\n        (A1, b1, sigma1, n1),\n        (A2, b2, sigma2, n2),\n        (A3, b3, sigma3, n3),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, b, sigma, n = case\n        result = process_case(A, b, sigma, n)\n        results.append(result)\n\n    # Final print statement in the exact required format without spaces.\n    # e.g., [[1,2,3],[4,5,6]]\n    formatted_results = ','.join([f'[{\",\".join(map(str, item))}]' for item in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n\n```",
                "id": "3574747"
            }
        ]
    }