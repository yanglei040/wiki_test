{
        "hands_on_practices": [
            {
                "introduction": "使用张量网络格式的一个关键动机是其计算效率。此练习将指导你推导并比较在张量链 (TT) 和分层塔克 (HT) 两种格式中，执行一项基本操作——检查正交性——所需的计算成本。通过这项实践，你将对这两种格式的结构差异及其对计算复杂度的影响有一个定量的理解。[@problem_id:3583915]",
                "problem": "考虑一个以$d$阶张量（$d$-way tensor）表示的张量，该张量分别采用张量链（tensor-train, TT）格式和层次化Tucker（hierarchical Tucker, HT）格式。您将分析用于正交性检查的Gram矩阵的计算成本（浮点运算次数，计为加法和乘法的总和），以及存储这些Gram矩阵所需的空间，然后在一些科学标准假设下，通过比较TT和HT将这些成本与总体复杂度联系起来。\n\n对于张量链（TT）格式：TT表示由$d$个三维核心张量$\\mathcal{G}_{k} \\in \\mathbb{R}^{r_{k-1} \\times n \\times r_{k}}$（$k = 1, \\dots, d$）组成，其中$r_{0} = r_{d} = 1$，内部秩$r_{1}, \\dots, r_{d-1}$假定等于一个统一的值$r \\geq 1$。所有模的物理维度大小相同，$n_{1} = \\dots = n_{d} = n \\geq 1$。为了检查TT核心的左正交性，我们考虑从$\\mathcal{G}_{k}$获得的左展开矩阵$X_{k} \\in \\mathbb{R}^{(r_{k-1} n) \\times r_{k}}$，并构建Gram矩阵$G_{k} = X_{k}^{\\top} X_{k} \\in \\mathbb{R}^{r_{k} \\times r_{k}}$。假设Gram矩阵是通过直接的密集矩阵乘法形成的，除了计算$X_{k}^{\\top} X_{k}$的常规算术计数外，不利用对称性。您必须分析在所有核心$k = 1, \\dots, d-1$上为左正交性检查而形成所有Gram矩阵$G_{k}$的总算术成本，以及存储这些Gram矩阵所需的标量条目总数。\n\n对于层次化Tucker（HT）格式：考虑一个具有$d$个叶节点的平衡二叉维度树（假设$d$是2的幂），其中每个叶节点对应一个大小为$n$的物理维度，并配备一个具有$r_{\\ell} \\geq 1$列的基矩阵$U_{\\ell} \\in \\mathbb{R}^{n \\times r_{\\ell}}$。每个内部节点$t$都有一个转移张量$B_{t} \\in \\mathbb{R}^{r_{t} \\times r_{t_{\\mathrm{left}}} \\times r_{t_{\\mathrm{right}}}}$，其内部秩$r_{t} = r$和子节点秩$r_{t_{\\mathrm{left}}} = r_{t_{\\mathrm{right}}} = r$是统一的。在标准的HT构造下，内部节点的节点基$U_{t}$是通过组合其子节点的基和转移张量得到的。对于正交性检查，叶节点处的Gram矩阵为$G_{\\ell} = U_{\\ell}^{\\top} U_{\\ell} \\in \\mathbb{R}^{r_{\\ell} \\times r_{\\ell}}$，而在内部节点$t$处，假设子基是标准正交的，Gram矩阵等于对$B_{t}$的子索引进行收缩，从而得到$G_{t} \\in \\mathbb{R}^{r \\times r}$。您必须分析在平衡二叉树中所有节点（叶节点和内部节点）上形成Gram矩阵的总算术成本，以及存储这些Gram矩阵所需的标量条目总数。\n\n在您的推导中，请使用以下科学标准依据：\n- 用于正交性检查的TT核心及其左展开的定义。\n- 平衡二叉树上带转移张量的HT节点基的定义，以及当子基为标准正交时，通过收缩在内部节点产生Gram矩阵的方法。\n- 密集矩阵乘法（对于$A \\in \\mathbb{R}^{m \\times p}$形成$A^{\\top} A$）和密集张量收缩（计为标量乘加运算的总数）的经过充分验证的算术成本。\n\n在推导出TT和HT的总算术成本和总存储计数（以标量为单位）后，通过比较TT和HT的算术成本，将它们与总体复杂度联系起来。您的最终答案应为该比率的单个闭式解析表达式：\n$$R(d,n,r,r_{\\ell}) = \\frac{\\text{TT Gram矩阵形成的总浮点运算次数}}{\\text{HT Gram矩阵形成的总浮点运算次数}}.$$\n不要四舍五入；提供$R(d,n,r,r_{\\ell})$的精确表达式，不带单位。",
                "solution": "本问题的目标是分析和比较以张量链（TT）和层次化Tucker（HT）格式表示的张量，在进行正交性检查时形成Gram矩阵的计算成本，该成本以浮点运算次数（flops）衡量。此分析的最终成果将是推导出这些成本的比率。\n\n首先，我们讨论张量链（TT）格式。一个$d$阶张量由$d$个三维核心张量$\\mathcal{G}_{k} \\in \\mathbb{R}^{r_{k-1} \\times n \\times r_{k}}$（$k = 1, \\dots, d$）表示。边界秩为$r_{0} = r_{d} = 1$，所有内部秩都是统一的，$r_{k} = r$（$k = 1, \\dots, d-1$）。物理维度大小是统一的，$n_{k}=n$。为了检查左正交性，我们为每个核心的左展开$X_{k} \\in \\mathbb{R}^{(r_{k-1} n) \\times r_{k}}$构建Gram矩阵$G_{k} = X_{k}^{\\top} X_{k}$。分析是针对索引为$k = 1, \\dots, d-1$的核心进行的。\n\n对于矩阵$A \\in \\mathbb{R}^{m \\times p}$，计算乘积$A^{\\top}A$的标准成本约为$2mp^{2}$次浮点运算（计算加法和乘法）。\n对于一个通用的TT核心$\\mathcal{G}_{k}$，其展开$X_{k}$的维度为$m = r_{k-1}n$和$p = r_{k}$。因此，计算其Gram矩阵$G_{k}$的浮点运算次数为$2(r_{k-1}n)r_{k}^{2}$。\n\n我们必须在指定的范围$k = 1, \\dots, d-1$上对这些成本求和。\n对于第一个核心（$k=1$），秩为$r_{0}=1$和$r_{1}=r$。计算成本是：\n$$ C_{1} = 2(r_{0}n)r_{1}^{2} = 2(1 \\cdot n)r^{2} = 2nr^{2} $$\n对于后续的内部核心（$k=2, \\dots, d-1$），秩为$r_{k-1}=r$和$r_{k}=r$。每个此类核心的成本是：\n$$ C_{k} = 2(r_{k-1}n)r_{k}^{2} = 2(rn)r^{2} = 2nr^{3} $$\n有$(d-1) - 2 + 1 = d-2$个这样的核心。\nTT格式的总浮点运算次数，记为$C_{\\text{TT}}$，是第一个核心的成本与其余$d-2$个内部核心成本的总和：\n$$ C_{\\text{TT}} = C_{1} + \\sum_{k=2}^{d-1} C_{k} = 2nr^{2} + (d-2)2nr^{3} $$\n提取公因式$2nr^{2}$得到：\n$$ C_{\\text{TT}} = 2nr^{2}(1 + (d-2)r) $$\n为了完整起见，存储这$d-1$个大小为$r \\times r$的Gram矩阵所需的总存储量是$(d-1)r^2$个标量。\n\n接下来，我们分析层次化Tucker（HT）格式。该张量定义在一个具有$d$个叶节点的平衡二叉树上，其中$d$是2的幂。这样的树有$d-1$个内部节点。\n在$d$个叶节点中的每一个（记为$\\ell$）处，都有一个基矩阵$U_{\\ell} \\in \\mathbb{R}^{n \\times r_{\\ell}}$。相应的Gram矩阵是$G_{\\ell} = U_{\\ell}^{\\top} U_{\\ell} \\in \\mathbb{R}^{r_{\\ell} \\times r_{\\ell}}$。形成一个这样的矩阵的浮点运算次数是$2nr_{\\ell}^{2}$。因为有$d$个叶节点，所有叶节点的总成本是：\n$$ C_{\\text{leaves}} = d \\cdot (2nr_{\\ell}^{2}) = 2dnr_{\\ell}^{2} $$\n在$d-1$个内部节点中的每一个（记为$t$）处，都有一个转移张量$B_{t} \\in \\mathbb{R}^{r_{t} \\times r_{t_{\\mathrm{left}}} \\times r_{t_{\\mathrm{right}}}}$。问题陈述了统一的秩$r_{t} = r_{t_{\\mathrm{left}}} = r_{t_{\\mathrm{right}}} = r$，所以$B_{t} \\in \\mathbb{R}^{r \\times r \\times r}$。Gram矩阵$G_t \\in \\mathbb{R}^{r \\times r}$是通过对子索引进行收缩而形成的。设$B_t$的索引为$(i,j,k)$，这对应于计算：\n$$ G_{t}(i, i') = \\sum_{j=1}^{r} \\sum_{k=1}^{r} B_{t}(i, j, k) B_{t}(i', j, k) $$\n这等价于形成矩阵乘积$M M^{\\top}$，其中$M \\in \\mathbb{R}^{r \\times r^2}$是$B_t$的模-1矩阵化。成本是$2 \\cdot (\\text{M的行数}) \\cdot (\\text{M的列数})^2 = 2r(r^2)^2 = 2r^5$次浮点运算。但是，这是不正确的。计算$MM^\\top$的成本是 $2 \\cdot (\\text{M的行数}) \\cdot (\\text{M的列数}) \\cdot (\\text{M}^\\top\\text{的列数}) = 2 \\cdot r \\cdot r^2 \\cdot r = 2r^4$次浮点运算。这个成本发生在$d-1$个内部节点中的每一个上。所有内部节点的总成本是：\n$$ C_{\\text{interiors}} = (d-1)2r^{4} $$\nHT格式的总浮点运算次数$C_{\\text{HT}}$是叶节点和内部节点成本的总和：\n$$ C_{\\text{HT}} = C_{\\text{leaves}} + C_{\\text{interiors}} = 2dnr_{\\ell}^{2} + (d-1)2r^{4} = 2(dnr_{\\ell}^{2} + (d-1)r^{4}) $$\n为了完整起见，HT Gram矩阵的总存储量包括$d$个大小为$r_{\\ell} \\times r_{\\ell}$的矩阵和$d-1$个大小为$r \\times r$的矩阵，总共为$dr_{\\ell}^{2} + (d-1)r^{2}$个标量。\n\n最后，我们构建所需的比率$R(d, n, r, r_{\\ell})$，即TT总浮点运算次数与HT总浮点运算次数之比：\n$$ R(d, n, r, r_{\\ell}) = \\frac{C_{\\text{TT}}}{C_{\\text{HT}}} = \\frac{2nr^{2}(1 + (d-2)r)}{2(dnr_{\\ell}^{2} + (d-1)r^{4})} $$\n消去公因数2，得到最终表达式：\n$$ R(d, n, r, r_{\\ell}) = \\frac{nr^{2}(1 + (d-2)r)}{dnr_{\\ell}^{2} + (d-1)r^{4}} $$",
                "answer": "$$\\boxed{\\frac{nr^{2}(1 + (d-2)r)}{dnr_{\\ell}^{2} + (d-1)r^{4}}}$$",
                "id": "3583915"
            },
            {
                "introduction": "张量链 (TT) 格式的效率不仅取决于其链状结构，还取决于张量各个维度在该结构中的排列方式。本练习探讨模式排序这一关键概念，展示不同的维度排列如何显著影响 TT 秩，进而影响存储和计算成本。你将通过设计一种启发式算法来寻找优化的维度顺序，从而将理论付诸实践。[@problem_id:3583892]",
                "problem": "设 $d \\in \\mathbb{N}$，且设 $X \\in \\mathbb{R}^{n_1 \\times n_2 \\times \\cdots \\times n_d}$ 是一个实的 $d$ 阶张量。考虑一个作用于 $d$ 个模上的置换 $\\pi \\in S_d$，并令 $X^\\pi$ 表示其轴已根据 $\\pi$ 重新排序的置换后张量。$X$ 的张量链 (TT) 分解由一系列核定义，其最小 TT 秩 $\\{r_k\\}_{k=1}^{d-1}$ 等于 $X$ 沿连续模切分的矩阵展开的秩。具体来说，对于每个 $k \\in \\{1,\\ldots,d-1\\}$，定义将前 $k$ 个模与其余 $d-k$ 个模分组的展开，并注意到 TT 秩 $r_k$ 等于该展开的矩阵秩。本问题要求您从数值线性代数和多重线性代数的基础定义出发，确定置换模对 TT 秩的影响，并设计和评估一种计算启发式方法，以选择一个能最小化最大 TT 秩的模置换。\n\n您的任务是：\n1. 使用矩阵秩和矩阵化（展开）的定义，证明对于任何置换 $\\pi \\in S_d$，$X^\\pi$ 的 TT 秩满足\n$$\nr_k^\\pi \\;=\\; \\mathrm{rank}\\!\\left(\\mathrm{unfold}_{\\{\\pi(1),\\ldots,\\pi(k)\\}|\\{\\pi(k+1),\\ldots,\\pi(d)\\}}(X)\\right), \\quad k=1,\\ldots,d-1,\n$$\n其中 $\\mathrm{unfold}_{S|\\bar S}(X)$ 表示通过将 $S$ 中的模分组为行、将 $\\bar S$ 中的模分组为列而得到的矩阵，并保持由 $\\pi$ 导出的顺序。您的推导必须仅依赖于张量矩阵化和矩阵秩的基本定义，以及诸如代数秩在行和列置换下的不变性以及最小 TT 秩由展开的秩来表征等经过充分检验的事实。\n\n2. 设计一种启发式方法来选择一个置换 $\\pi$，以试图最小化 $\\max_{k \\in \\{1,\\ldots,d-1\\}} r_k^\\pi$。该启发式方法必须仅能从 $X$ 的数据中计算得出，并应从第一性原理进行论证。您的启发式方法必须避免使用任何目标公式作为捷径，并应阐明所选策略为何倾向于降低最大 TT 秩的理由。\n\n3. 在一个完整的、可运行的程序中实现以下内容：\n   - 一个函数，用于通过形成适当的矩阵展开并计算其在 $\\mathbb{R}$ 上的秩，来计算给定张量 $X$ 和置换 $\\pi$ 的 TT 秩列表 $\\{r_k^\\pi\\}_{k=1}^{d-1}$。\n   - 对所提供的小型测试张量的所有置换 $\\pi \\in S_d$ 进行穷举搜索，以找到 $\\max_k r_k^\\pi$ 的最优可能最小值；这将为每个测试用例建立基准真相。\n   - 您选择置换 $\\pi_{\\mathrm{heur}}$ 的启发式方法，并为每个测试用例计算 $\\max_k r_k^{\\pi_{\\mathrm{heur}}}$。\n   - 对于每个测试用例，输出一个布尔值，指示启发式方法是否达到了最优的最小最大 TT 秩（即，$\\max_k r_k^{\\pi_{\\mathrm{heur}}}$ 是否等于 $\\min_{\\pi \\in S_d} \\max_k r_k^\\pi$）。\n\n您必须使用以下在 $\\mathbb{R}$ 上的张量测试套件，其元素有精确定义：\n- 测试用例 1（通用稠密， $d=5$）：$X \\in \\mathbb{R}^{2 \\times 3 \\times 2 \\times 3 \\times 2}$，其元素 $X[i_1,i_2,i_3,i_4,i_5]$ 从一个具有固定种子的伪随机数生成器中确定性地抽取，确保在维度限制下具有通用的满秩。\n- 测试用例 2（克罗内克结构， $d=4$）：$X \\in \\mathbb{R}^{3 \\times 2 \\times 3 \\times 2}$，定义为 $X[i,j,k,\\ell] = M[i,k] \\cdot N[j,\\ell]$，其中 $M \\in \\mathbb{R}^{3 \\times 3}$ 是秩-1 矩阵（构造为 $M = u v^\\top$，对于非零 $u \\in \\mathbb{R}^3, v \\in \\mathbb{R}^3$），而 $N \\in \\mathbb{R}^{2 \\times 2}$ 是满秩矩阵（例如，单位矩阵）。\n- 测试用例 3（秩-1 可分， $d=6$）：$X \\in \\mathbb{R}^{2 \\times 2 \\times 2 \\times 2 \\times 2 \\times 2}$，定义为 $X = g^{(1)} \\otimes g^{(2)} \\otimes g^{(3)} \\otimes g^{(4)} \\otimes g^{(5)} \\otimes g^{(6)}$，对于非零向量 $g^{(m)} \\in \\mathbb{R}^{2}$，$m=1,\\ldots,6$。\n- 测试用例 4（结构化规范多项式和， $d=4$）：$X \\in \\mathbb{R}^{3 \\times 3 \\times 2 \\times 2}$，定义为 $X = a \\otimes b \\otimes c \\otimes d \\;+\\; a \\otimes b \\otimes c' \\otimes d'$，其中 $a \\in \\mathbb{R}^3, b \\in \\mathbb{R}^3$ 在两项中都是固定的且相同，而 $c,c' \\in \\mathbb{R}^2, d,d' \\in \\mathbb{R}^2$ 被选为线性无关对。\n\n所有秩都必须通过基于奇异值分解 (SVD) 的数值秩计算为在 $\\mathbb{R}$ 上的代数秩；角度单位不适用；不出现物理单位。您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_t$ 是一个布尔值，指示启发式方法是否在测试用例 $t$ 上达到了最优的最小最大 TT 秩。\n\n您的推导和论证必须基于：\n- 矩阵秩和张量矩阵化的基本定义。\n- 最小张量链秩由连续展开的秩来表征。\n- 关于矩阵秩在行和列置换下不变性的经过充分检验的事实。\n\n不允许使用其他快捷公式。实现必须是自包含的，并且不需要用户输入、外部文件或网络访问。最终输出必须严格为指定格式的单行。",
                "solution": "### 第 1 部分：置换后张量的 TT 秩推导\n\n设 $X \\in \\mathbb{R}^{n_1 \\times n_2 \\times \\cdots \\times n_d}$ 是一个 $d$ 阶张量。设 $\\pi \\in S_d$ 是模索引 $\\{1, \\ldots, d\\}$ 的一个置换。我们定义置换后的张量 $X^\\pi$ 为一个尺寸为 $n_{\\pi(1)} \\times \\cdots \\times n_{\\pi(d)}$ 的张量，其元素由下式给出：\n$$ (X^\\pi)_{i_1, \\ldots, i_d} = X_{j_1, \\ldots, j_d} \\quad \\text{其中} \\quad j_{\\pi(k)} = i_k \\text{ 对于 } k=1, \\ldots, d. $$\n该定义表明 $X^\\pi$ 的第 $k$ 个模对应于 $X$ 的第 $\\pi(k)$ 个模。\n\n根据最小张量链 (TT) 秩的定义，张量 $X^\\pi$ 的第 $k$ 个 TT 秩（我们表示为 $r_k^\\pi$）是 $X^\\pi$ 的矩阵化（展开）的秩，该展开将其前 $k$ 个模与其余 $d-k$ 个模分组。\n$$ r_k^\\pi \\triangleq \\mathrm{rank}\\left(\\mathrm{unfold}_{\\{1, \\ldots, k\\} | \\{k+1, \\ldots, d\\}}(X^\\pi)\\right). $$\n我们将右侧的矩阵展开表示为 $M_\\pi$。矩阵 $M_\\pi$ 的维度为 $(\\prod_{m=1}^k n_{\\pi(m)}) \\times (\\prod_{m=k+1}^d n_{\\pi(m)})$。其行由一个多重索引 $(i_1, \\ldots, i_k)$ 索引，其列由一个多重索引 $(i_{k+1}, \\ldots, i_d)$ 索引。与这些多重索引对应的矩阵位置的元素是 $(X^\\pi)_{i_1, \\ldots, i_d}$。\n\n我们需要证明这个秩等价于直接应用于原始张量 $X$ 的另一个展开的秩：\n$$ r_k^\\pi_? = \\mathrm{rank}\\left(\\mathrm{unfold}_{\\{\\pi(1), \\ldots, \\pi(k)\\} | \\{\\pi(k+1), \\ldots, \\pi(d)\\}}(X)\\right). $$\n我们将右侧的矩阵表示为 $M_X$。此展开的行模是 $S = \\{\\pi(1), \\ldots, \\pi(k)\\}$，列模是 $\\bar{S} = \\{\\pi(k+1), \\ldots, \\pi(d)\\}$。设 $X$ 的索引为 $(j_1, \\ldots, j_d)$，其中 $j_m \\in \\{1, \\ldots, n_m\\}$。矩阵 $M_X$ 的维度为 $(\\prod_{m \\in S} n_m) \\times (\\prod_{m \\in \\bar{S}} n_m)$。问题陈述指明，展开中模的内部排序是“由 $\\pi$ 导出的”。这意味着行多重索引可以与元组 $(j_{\\pi(1)}, \\ldots, j_{\\pi(k)})$ 等同，列多重索引可以与 $(j_{\\pi(k+1)}, \\ldots, j_{\\pi(d)})$ 等同。与这些多重索引对应的矩阵位置的元素是 $X_{j_1, \\ldots, j_d}$。\n\n让我们建立矩阵 $M_\\pi$ 和 $M_X$ 之间的对应关系。\n$M_\\pi$ 的任意元素对应于一个元素 $(X^\\pi)_{i_1, \\ldots, i_d}$，其中 $(i_1, \\ldots, i_k)$ 决定行，$(i_{k+1}, \\ldots, i_d)$ 决定列。根据定义，该值等于 $X_{j_1, \\ldots, j_d}$，其中 $j_{\\pi(m)} = i_m$ 对 $m=1, \\ldots, d$ 成立。\n\n$M_X$ 的任意元素对应于一个元素 $X_{j_1, \\ldots, j_d}$。其行由索引 $\\{j_m\\}_{m \\in S} = \\{j_{\\pi(1)}, \\ldots, j_{\\pi(k)}\\}$ 决定，其列由 $\\{j_m\\}_{m \\in \\bar{S}} = \\{j_{\\pi(k+1)}, \\ldots, j_{\\pi(d)}\\}$ 决定。\n\n如果我们将 $i_m = j_{\\pi(m)}$ 代入 $M_\\pi$ 的描述中，我们会发现以下几点：\n1.  两个矩阵中包含的值集合是相同的，即张量 $X$ 的所有元素。\n2.  $M_\\pi$ 中一个元素的行由 $(i_1, \\ldots, i_k)$ 决定，这与 $(j_{\\pi(1)}, \\ldots, j_{\\pi(k)})$ 相同。这正是决定 $M_X$ 中相应元素行的索引集合。\n3.  $M_\\pi$ 中一个元素的列由 $(i_{k+1}, \\ldots, i_d)$ 决定，这与 $(j_{\\pi(k+1)}, \\ldots, j_{\\pi(d)})$ 相同。这正是决定 $M_X$ 中相应元素列的索引集合。\n\n鉴于问题指明了“保持由 $\\pi$ 导出的顺序”，从多重索引到单一矩阵索引的字典序映射对于两个矩阵是相同的。因此，这两个矩阵不仅仅是彼此的置换；它们是完全相同的：$M_\\pi = M_X$。\n因此，它们的秩必须相等：\n$$ \\mathrm{rank}(M_\\pi) = \\mathrm{rank}(M_X). $$\n这完成了推导，证明了\n$$ r_k^\\pi = \\mathrm{rank}\\left(\\mathrm{unfold}_{\\{\\pi(1), \\ldots, \\pi(k)\\} | \\{\\pi(k+1), \\ldots, \\pi(d)\\}}(X)\\right), \\quad k=1, \\ldots, d-1. $$\n这个结果是基础性的，因为它允许我们通过对原始张量 $X$ 进行展开来确定任何模置换的 TT 秩，而无需显式地构造 $X^\\pi$。\n\n### 第 2 部分：最小化最大 TT 秩的启发式方法设计\n\n我们的目标是找到一个置换 $\\pi \\in S_d$，以最小化 $\\max_{k \\in \\{1,\\ldots,d-1\\}} r_k^\\pi$。根据第 1 部分，这等价于最小化 $\\max_{k} \\mathrm{rank}(\\mathrm{unfold}_{\\{\\pi(1),\\ldots,\\pi(k)\\}|\\{\\pi(k+1),\\ldots,\\pi(d)\\}}(X))$。\n\n任何矩阵的秩都受其维度的限制。对于展开 $\\mathrm{unfold}_{S|\\bar{S}}(X)$，其秩受以下限制：\n$$ \\mathrm{rank} \\le \\min\\left( \\prod_{i \\in S} n_i, \\prod_{j \\in \\bar{S}} n_j \\right). $$\n对于一个通用张量，这个界限通常是紧的。因此，一个合理的启发式方法是找到一个置换 $\\pi$，使得在所有切分 $k \\in \\{1, \\ldots, d-1\\}$ 上，这些界限的最大值最小化。这是一个组合优化问题。贪心策略可以提供高质量的解。核心思想是平衡 TT 链两侧维度的累积乘积。这表明可以采用一种从外向内地构建置换的贪心算法。\n\n**启发式算法：**\n1.  按维度升序对模索引进行排序。\n2.  初始化一个长度为 $d$ 的空置换列表 $\\pi$，以及左右指针 $l=0, r=d-1$。\n3.  初始化链左右两侧的累积乘积：$P_{left} = 1$, $P_{right} = 1$。\n4.  遍历排序后的模索引。对于每个模索引 $m$：\n    a. 如果 $P_{left} \\le P_{right}$，则将模 $m$ 放置在当前左侧位置：$\\pi[l] = m$。更新 $P_{left} \\leftarrow P_{left} \\cdot n_m$ 并递增 $l$。\n    b. 否则，将模 $m$ 放置在当前右侧位置：$\\pi[r] = m$。更新 $P_{right} \\leftarrow P_{right} \\cdot n_m$ 并递减 $r$。\n5.  最终得到的列表 $\\pi$ 即为所需的置换。\n\n这种启发式方法仅从张量维度即可计算，其合理性在于通过平衡维度乘积来最小化所有 TT 切分上的秩界限的原理。\n\n### 第 3 部分：实现\n\n实现包括创建指定的测试张量、一个用于计算给定置换的 TT 秩的函数、启发式函数，以及一个用于寻找最优解以进行比较的穷举搜索。对于每个测试用例，我们确定启发式方法是否达到了真正的最小最大 TT 秩。\n\n```python\nimport numpy as np\nimport itertools\nfrom functools import reduce\n\ndef compute_tt_ranks(X, pi):\n    \"\"\"\n    Computes the TT ranks for a tensor X with modes permuted by pi.\n    \"\"\"\n    d = X.ndim\n    if d == 1:\n        return []\n\n    # Permute the tensor's modes according to pi.\n    X_perm = np.transpose(X, pi)\n    \n    ranks = []\n    # Iterate through the d-1 contiguous cuts of the permuted tensor.\n    for k in range(1, d):\n        shape = X_perm.shape\n        # Unfold the permuted tensor across the k-th cut by reshaping into a matrix.\n        dim_rows = np.prod(shape[:k]).astype(int)\n        dim_cols = np.prod(shape[k:]).astype(int)\n        matrix = np.reshape(X_perm, (dim_rows, dim_cols))\n        \n        # Compute the algebraic rank of the resulting matrix.\n        rank = np.linalg.matrix_rank(matrix)\n        ranks.append(rank)\n        \n    return ranks\n\ndef heuristic_permutation(dims):\n    \"\"\"\n    Computes a permutation pi that aims to minimize the maximum TT rank.\n    \"\"\"\n    d = len(dims)\n    mode_indices = list(range(d))\n    \n    # Sort mode indices in ascending order of their corresponding dimension size.\n    sorted_modes = sorted(mode_indices, key=lambda i: dims[i])\n    \n    pi = [0] * d\n    left_ptr, right_ptr = 0, d - 1\n    prod_left, prod_right = 1, 1\n    \n    # Greedily build the permutation from the outside in.\n    for mode_idx in sorted_modes:\n        # Place this mode on the side of the chain with the smaller cumulative product.\n        if prod_left = prod_right:\n            pi[left_ptr] = mode_idx\n            prod_left *= dims[mode_idx]\n            left_ptr += 1\n        else:\n            pi[right_ptr] = mode_idx\n            prod_right *= dims[mode_idx]\n            right_ptr -= 1\n            \n    return tuple(pi)\n\ndef evaluate_case(X):\n    \"\"\"\n    Finds the optimal maximum TT rank via exhaustive search and compares it with the heuristic.\n    \"\"\"\n    dims = X.shape\n    d = X.ndim\n    \n    if d == 1:\n        return True # Trivial case, no ranks to compute.\n\n    # --- Exhaustive search for ground truth ---\n    optimal_min_max_rank = float('inf')\n    all_permutations = itertools.permutations(range(d))\n\n    for pi in all_permutations:\n        ranks = compute_tt_ranks(X, pi)\n        current_max_rank = max(ranks) if ranks else 0\n        if current_max_rank  optimal_min_max_rank:\n            optimal_min_max_rank = current_max_rank\n\n    # --- Heuristic ---\n    pi_heuristic = heuristic_permutation(dims)\n    ranks_heuristic = compute_tt_ranks(X, pi_heuristic)\n    heuristic_max_rank = max(ranks_heuristic) if ranks_heuristic else 0\n\n    # --- Comparison ---\n    is_optimal = (heuristic_max_rank == optimal_min_max_rank)\n    return is_optimal\n\ndef define_test_cases():\n    \"\"\"Generates the four test tensors as specified in the problem.\"\"\"\n    test_suite = []\n\n    # Test Case 1: Generic dense tensor, d=5\n    rng = np.random.default_rng(seed=42)\n    X1 = rng.random(size=(2, 3, 2, 3, 2))\n    test_suite.append(X1)\n\n    # Test Case 2: Kronecker structure, d=4\n    u = np.array([1., 2., 3.])\n    v = np.array([4., 5., 6.])\n    M = np.outer(u, v)  # 3x3 rank-1 matrix\n    N = np.eye(2)       # 2x2 full-rank matrix\n    X2 = np.einsum('ik,jl->ijkl', M, N, dtype=np.float64)\n    test_suite.append(X2)\n\n    # Test Case 3: Rank-1 separable tensor, d=6\n    g_vectors = [\n        np.array([1.1, 2.2]), np.array([3.3, 1.1]), np.array([1.1, 4.4]),\n        np.array([2.2, 1.1]), np.array([1.1, 1.1]), np.array([2.2, 3.3])\n    ]\n    X3 = reduce(np.multiply.outer, g_vectors)\n    test_suite.append(X3)\n\n    # Test Case 4: Structured Canonical Polyadic sum, d=4\n    a = np.array([1., 2., 3.])\n    b = np.array([4., 5., 6.])\n    c = np.array([1., 0.])\n    d_vec = np.array([1., 1.])\n    c_p = np.array([0., 1.])\n    d_p = np.array([1., -1.])\n    T1 = reduce(np.multiply.outer, [a, b, c, d_vec])\n    T2 = reduce(np.multiply.outer, [a, b, c_p, d_p])\n    X4 = T1 + T2\n    test_suite.append(X4)\n    \n    return test_suite\n\ndef solve():\n    \"\"\"\n    Main function to run the evaluation on all test cases and print the results.\n    \"\"\"\n    test_cases = define_test_cases()\n    results = []\n\n    for X in test_cases:\n        is_optimal = evaluate_case(X)\n        results.append(is_optimal)\n\n    # The final print statement must follow the specified format exactly.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# if __name__ == '__main__':\n#     solve()\n```",
                "answer": "[True,True,True,True]",
                "id": "3583892"
            }
        ]
    }