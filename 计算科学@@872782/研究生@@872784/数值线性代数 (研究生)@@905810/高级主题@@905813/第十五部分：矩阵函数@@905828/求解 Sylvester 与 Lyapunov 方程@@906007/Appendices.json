{
        "hands_on_practices": [
            {
                "introduction": "本练习旨在解决Sylvester方程的基本直接解法——Bartels-Stewart算法。理解该方法至关重要，因为它构成了许多标准数值软件库函数（如MATLAB中的 `lyap` 和 `sylv`）的核心。该练习[@problem_id:3578476]将引导您从第一性原理出发，通过矩阵分块和递推，推导出该算法的核心步骤，让您对求解过程有一个深刻的、构造性的理解。",
                "problem": "设 $T \\in \\mathbb{R}^{n \\times n}$ 和 $S \\in \\mathbb{R}^{m \\times m}$ 为实舒尔形式，即它们都是块上拟三角矩阵，其对角块的大小为 $1 \\times 1$ 或 $2 \\times 2$。考虑Sylvester方程 $T Y + Y S = \\tilde{C}$，其中未知矩阵为 $Y \\in \\mathbb{R}^{n \\times m}$，给定的右端项为 $\\tilde{C} \\in \\mathbb{R}^{n \\times m}$。将 $T$ 和 $S$ 沿其舒尔块进行分块，并对 $Y$ 和 $\\tilde{C}$ 进行共形分块，得到分块矩阵 $Y_{ij}$ 和 $\\tilde{C}_{ij}$，其中每个 $Y_{ij}$ 的行数等于 $T$ 的第 $i$ 个对角块的大小，列数等于 $S$ 的第 $j$ 个对角块的大小。\n\n从实舒尔形式、Sylvester方程和上三角块结构的定义出发，推导出块回代方程，该方程将 $Y_{ij}$ 用先前已计算的块表示出来。在由对角块大小决定的四种情况下，显式写出 $Y_{ij}$ 的系数算子：\n\n- $T$ 中为 $1 \\times 1$ 块，$S$ 中为 $1 \\times 1$ 块，\n- $T$ 中为 $2 \\times 2$ 块，$S$ 中为 $1 \\times 1$ 块，\n- $T$ 中为 $1 \\times 1$ 块，$S$ 中为 $2 \\times 2$ 块，\n- $T$ 中为 $2 \\times 2$ 块，$S$ 中为 $2 \\times 2$ 块。\n\n对于每种情况，写出求解 $Y_{ij}$ 所得的线性系统，并用 $T$ 和 $S$ 相应的对角块来确定其显式系数矩阵。\n\n最后，专门研究 $2 \\times 2$–$2 \\times 2$ 的情况。假设 $T$ 的 $2 \\times 2$ 对角块具有复特征值 $\\lambda$ 和 $\\overline{\\lambda}$，而 $S$ 的 $2 \\times 2$ 对角块具有复特征值 $\\mu$ 和 $\\overline{\\mu}$，且每个块都为实舒尔形式。设 $M$ 为控制 $2 \\times 2$–$2 \\times 2$ 块 $Y_{ij}$ 的向量化线性系统的 $4 \\times 4$ 系数矩阵。计算 $\\det(M)$，并提供一个仅用 $\\lambda$、$\\overline{\\lambda}$、$\\mu$ 和 $\\overline{\\mu}$ 表示的闭式解析表达式。无需四舍五入；提供精确表达式。",
                "solution": "问题要求推导Sylvester方程 $T Y + Y S = \\tilde{C}$ 的块回代方法（其中 $T$ 和 $S$ 为实舒尔形式），并分析待解的局部线性系统，包括针对一个特定情况的行列式计算。\n\n\\subsection*{第一部分：块回代方程的推导}\n设矩阵 $T \\in \\mathbb{R}^{n \\times n}$ 和 $S \\in \\mathbb{R}^{m \\times m}$ 根据其实舒尔形式进行分块。这意味着它们是块上拟三角矩阵。设 $T$ 有 $p$ 个对角块，$S$ 有 $q$ 个对角块。\n$$\nT = \\begin{pmatrix} T_{11} & T_{12} & \\cdots & T_{1p} \\\\ & T_{22} & \\cdots & T_{2p} \\\\ & & \\ddots & \\vdots \\\\ & & & T_{pp} \\end{pmatrix}, \\quad\nS = \\begin{pmatrix} S_{11} & S_{12} & \\cdots & S_{1q} \\\\ & S_{22} & \\cdots & S_{2q} \\\\ & & \\ddots & \\vdots \\\\ & & & S_{qq} \\end{pmatrix}\n$$\n此处，当 $i>k$ 时 $T_{ik} = 0$，当 $l>j$ 时 $S_{lj} = 0$。对角块 $T_{ii}$ 和 $S_{jj}$ 的大小为 $1 \\times 1$ 或 $2 \\times 2$。矩阵 $Y \\in \\mathbb{R}^{n \\times m}$ 和 $\\tilde{C} \\in \\mathbb{R}^{n \\times m}$ 进行共形分块，其块 $Y_{ij}$ 和 $\\tilde{C}_{ij}$ 的大小为 $n_i \\times m_j$，其中 $n_i$ 是 $T_{ii}$ 的大小，$m_j$ 是 $S_{jj}$ 的大小。\n\nSylvester方程 $T Y + Y S = \\tilde{C}$ 可以写成块形式。该方程的第 $(i,j)$ 个块由下式给出：\n$$\n(T Y)_{ij} + (Y S)_{ij} = \\tilde{C}_{ij}\n$$\n矩阵乘积 $TY$ 的第 $(i,j)$ 个块是 $\\sum_{k=1}^{p} T_{ik} Y_{kj}$。由于 $T$ 是块上三角矩阵（当 $i>k$ 时 $T_{ik}=0$），该和式简化为 $\\sum_{k=i}^{p} T_{ik} Y_{kj}$。\n$YS$ 的第 $(i,j)$ 个块是 $\\sum_{l=1}^{q} Y_{il} S_{lj}$。由于 $S$ 是块上三角矩阵（当 $l>j$ 时 $S_{lj}=0$），该和式简化为 $\\sum_{l=1}^{j} Y_{il} S_{lj}$。\n\n将这些代入块方程，得到：\n$$\n\\sum_{k=i}^{p} T_{ik} Y_{kj} + \\sum_{l=1}^{j} Y_{il} S_{lj} = \\tilde{C}_{ij}\n$$\n我们可以分离出包含 $Y_{ij}$ 的项（对应于第一个和式中的 $k=i$ 和第二个和式中的 $l=j$）：\n$$\n\\left( T_{ii} Y_{ij} + \\sum_{k=i+1}^{p} T_{ik} Y_{kj} \\right) + \\left( Y_{ij} S_{jj} + \\sum_{l=1}^{j-1} Y_{il} S_{lj} \\right) = \\tilde{C}_{ij}\n$$\n整理以求解含 $Y_{ij}$ 的项：\n$$\nT_{ii} Y_{ij} + Y_{ij} S_{jj} = \\tilde{C}_{ij} - \\sum_{k=i+1}^{p} T_{ik} Y_{kj} - \\sum_{l=1}^{j-1} Y_{il} S_{lj}\n$$\n此方程为块 $Y_{ij}$ 定义了一个小型的Sylvester方程。其右端项，我们称之为 $C'_{ij}$，仅依赖于 $k > i$ 的块 $Y_{kj}$（即第 $i$ 块行下方的块）和 $l < j$ 的块 $Y_{il}$（即第 $j$ 块列左侧的块）。\n\n这种结构表明了计算 $Y$ 的块的特定顺序。我们可以通过迭代计算 $Y_{ij}$ 块，其中 $i$ 从 $p$ 递减到 $1$，并对每个 $i$，$j$ 从 $1$ 递增到 $q$。在步骤 $(i,j)$，所有需要的块 $Y_{kj}$ ($k>i$) 和 $Y_{il}$ ($l<j$) 都已在之前的步骤中计算出来。此过程需要求解一个与 $T_{ii}$ 和 $S_{jj}$ 的大小相关的线性系统。\n\n\\subsection*{第二部分：$2 \\times 2$–$2 \\times 2$ 情况的行列式}\n对于 $2 \\times 2$–$2 \\times 2$ 的情况，求解 $Y_{ij}$ 的方程是 $T_{ii} Y_{ij} + Y_{ij} S_{jj} = C'_{ij}$。通过向量化，这变成了一个 $4 \\times 4$ 的线性系统 $(I_2 \\otimes T_{ii} + S_{jj}^T \\otimes I_2) \\mathrm{vec}(Y_{ij}) = \\mathrm{vec}(C'_{ij})$。系数矩阵 $M = I_2 \\otimes T_{ii} + S_{jj}^T \\otimes I_2$。\n\n$M$ 的行列式是其特征值的乘积。$M$ 的特征值是 $\\lambda'_k + \\mu'_l$，其中 $\\lambda'_k$ 是 $T_{ii}$ 的特征值，$\\mu'_l$ 是 $S_{jj}$ 的特征值。根据题意，$T_{ii}$ 的特征值为 $\\lambda, \\overline{\\lambda}$，$S_{jj}$ 的特征值为 $\\mu, \\overline{\\mu}$。因此，$M$ 的四个特征值是 $\\lambda+\\mu$, $\\lambda+\\overline{\\mu}$, $\\overline{\\lambda}+\\mu$, 和 $\\overline{\\lambda}+\\overline{\\mu}$。\n行列式 $\\det(M)$ 是这些特征值的乘积。",
                "answer": "$$\n\\boxed{(\\lambda+\\mu)(\\overline{\\lambda}+\\overline{\\mu})(\\lambda+\\overline{\\mu})(\\overline{\\lambda}+\\mu)}\n$$",
                "id": "3578476"
            },
            {
                "introduction": "在学习了如何求解之后，一个自然而关键的问题是：解的可靠性如何？它对问题数据的微小扰动有多敏感？本实践探讨了Sylvester方程的条件数概念，并揭示了传统的特征值分析在处理非正规矩阵时可能具有误导性。通过一个计算实验[@problem_id:3578480]，您将亲身体验谱分离如何决定解的敏感性，并了解像伪谱这样的现代理论工具如何为问题的稳定性提供更精确、更可靠的描绘。",
                "problem": "构建一个完整、可运行的程序，研究当 $A$ 和 $-B$ 的谱几乎碰撞时，Sylvester 方程 $AX+XB=C$ 对扰动的敏感性。你的任务必须从数值线性代数中最基本、广为接受的定义开始，并遵循第一性原理进行推理。具体来说，从 Sylvester 映射的线性算子角度和 $\\varepsilon$-伪谱的定义出发，并且除了这些基础事实外，不假设任何特殊情况的公式。核心目标是通过伪谱方面的考量，量化谱分离度 $\\mathrm{sep}(A,-B)$ 如何决定逆 Sylvester 映射的条件数。\n\n你必须完成以下任务，并且只能使用以下基本事实：(i) 由 $L[X]=AX+XB$ 定义的 Sylvester 映射 $L:\\mathbb{C}^{n\\times m}\\to\\mathbb{C}^{n\\times m}$ 是线性的，(ii) 向量化 $\\operatorname{vec}(\\cdot)$ 是从 $\\left(\\mathbb{C}^{n\\times m},\\|\\cdot\\|_F\\right)$ 到 $\\left(\\mathbb{C}^{nm},\\|\\cdot\\|_2\\right)$ 的一个线性等距同构，以及 (iii) 方阵 $M$ 的 $\\varepsilon$-伪谱是 $\\Lambda_{\\varepsilon}(M)=\\{z\\in\\mathbb{C}:\\sigma_{\\min}(zI-M)\\le \\varepsilon\\}$，其中 $\\sigma_{\\min}(\\cdot)$ 表示最小奇异值。\n\n1) 根据给定的基本事实，且不预设任何专门公式，推导谱分离度量 $\\mathrm{sep}(A,-B)$ 的一个精确且可实现的计算方法，将其表示为 Sylvester 算子 $L$ 的一个具体的、有限维矩阵表示的最小奇异值。然后实现这个计算，以数值方式获得 $\\mathrm{sep}(A,-B)$。\n\n2) 仅利用 $L$ 的线性性质和范数定义，设计并实现一个蒙特卡洛程序来估计由 Frobenius 范数诱导的 $L^{-1}$ 的算子范数，即 $\\|L^{-1}\\|=\\sup_{\\|E\\|_F=1}\\|L^{-1}[E]\\|_F$，方法是通过对随机抽取的满足 $\\|E\\|_F=1$ 的右端项 $E$ 反复求解 $AX+XB=E$，并取观测到的 $\\|X\\|_F$ 的最大值。在需要时明确设置伪随机种子，以确保数值可复现性。\n\n3) 从 $\\varepsilon$-伪谱的定义出发，构建并实现一个 $A$ 和 $-B$ 之间分离度的伪谱代理，方法如下。对于复平面中的一个有界矩形搜索区域和候选点 $z$ 的均匀网格，计算 $s_A(z)=\\sigma_{\\min}(zI-A)$ 和 $s_{-B}(z)=\\sigma_{\\min}(zI+ B)$，然后计算\n$$\n\\mu=\\inf_{z\\ \\text{in the grid}} \\max\\{s_A(z), s_{-B}(z)\\}.\n$$\n使用这个 $\\mu$ 作为伪谱分离度的替代指标，并报告其倒数 $1/\\mu$ 作为 $\\|L^{-1}\\|$ 的一个启发式上界预测值。设计必须清楚地解释如何选择网格以捕捉 $A$ 和 $-B$ 谱之间的相关相互作用。\n\n4) 对于下面列出的包含三个案例的测试套件，每个案例的维度均为 $n=m=3$，报告每个案例的三元实数组\n$$\n\\big(\\ \\mathrm{sep}(A,-B),\\ \\widehat{\\|L^{-1}\\|},\\ 1/\\mu\\ \\big),\n$$\n其中 $\\widehat{\\|L^{-1}\\|}$ 是你的蒙特卡洛估计值，$1/\\mu$ 是伪谱代理。所有范数必须是 Frobenius 范数，并使用标准的由欧几里得范数诱导的奇异值计算。\n\n测试套件规范：\n\n- 案例 1 (正规，中等分离)：令 $A=\\operatorname{diag}(1,2,3)$ 和 $B=\\operatorname{diag}(-1-\\delta,-2-\\delta,-3-\\delta)$，其中 $\\delta=10^{-1}$。使用一个搜索网格，其构建方法为：实部取 $\\{\\operatorname{Re}\\lambda:\\lambda\\in\\Lambda(A)\\cup\\Lambda(-B)\\}$ 的最小值到最大值，两侧各填充 0.5 的边距；虚部取 -0.5 到 0.5，两者都在一个 $101\\times 101$ 的均匀格点上采样。\n\n- 案例 2 (正规，几乎碰撞)：令 $A=\\operatorname{diag}(1,2,3)$ 和 $B=\\operatorname{diag}(-1-\\delta,-2-\\delta,-3-\\delta)$，其中 $\\delta=10^{-4}$，并使用与案例 1 相同的网格构造和分辨率。\n\n- 案例 3 (高度非正规的 $A$)：令 $A$ 为上三角矩阵，其对角线元素为 1，上对角线元素等于 $\\alpha=20$，即\n$$\nA=\\begin{bmatrix}\n1 & \\alpha & 0\\\\\n0 & 1 & \\alpha\\\\\n0 & 0 & 1\n\\end{bmatrix},\n$$\n并令 $B=-\\left(1+\\delta\\right)I$，其中 $\\delta=10^{-3}$。使用与案例 1 相同的网格构造和分辨率。\n\n对于每个案例中的蒙特卡洛估计，使用伪随机种子 1，抽取 $M=200$ 个独立的矩阵 $E$，其元素从标准正态分布中采样，并重新缩放以满足 $\\|E\\|_F=1$。求解 $AX+XB=E$ 得到 $X$，并记录观测到的最大 $\\|X\\|_F$。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。按顺序连接三个案例的三元组，因此输出格式为\n$$\n[\\ \\mathrm{sep}_1,\\ \\widehat{\\|L^{-1}\\|}_1,\\ (1/\\mu)_1,\\ \\mathrm{sep}_2,\\ \\widehat{\\|L^{-1}\\|}_2,\\ (1/\\mu)_2,\\ \\mathrm{sep}_3,\\ \\widehat{\\|L^{-1}\\|}_3,\\ (1/\\mu)_3\\ ].\n$$\n所有量都必须是标准浮点十进制形式的实数，不带单位。此问题不涉及物理单位，也不需要角度。程序必须是自包含的，不需要用户输入，并且只使用指定的数值库。\n\n设计约束与覆盖范围：\n\n- 这三个案例共同覆盖了一般的良好分离的正规情况、近乎碰撞的情况以及强非正规情况，以探究伪谱效应。\n\n- 你的推导必须仅依赖于 Sylvester 算子、向量化映射、奇异值和 $\\varepsilon$-伪谱的定义；并基于这些，推导出用于计算 $\\mathrm{sep}(A,-B)$ 的有限维奇异值问题，并论证用于计算 $\\|L^{-1}\\|$ 的蒙特卡洛估计策略的合理性。\n\n- 程序必须计算所有要求的值，并以确切的格式打印最终结果行。",
                "solution": "对 Sylvester 方程 $AX+XB=C$（其中 $A \\in \\mathbb{C}^{n\\times n}$，$B \\in \\mathbb{C}^{m\\times m}$，$C, X \\in \\mathbb{C}^{n\\times m}$）的分析始于将其重构为一个线性算子。我们定义 Sylvester 算子 $L: \\mathbb{C}^{n\\times m} \\to \\mathbb{C}^{n\\times m}$，其作用于矩阵 $X$ 的方式为 $L[X] = AX+XB$。因此，该问题等价于求解线性系统 $L[X]=C$。解 $X$ 对 $C$ 中扰动的敏感性由逆算子的范数 $\\|L^{-1}\\|$ 决定。大的范数意味着 $C$ 的微小变化可能导致 $X$ 的巨大变化，这是病态问题的标志。本解答将推导并计算表征此条件数的三个量：谱分离度 $\\mathrm{sep}(A,-B)$、$\\|L^{-1}\\|$ 的蒙特卡洛估计值，以及 $\\|L^{-1}\\|$ 的一个伪谱代理。\n\n**1. $\\mathrm{sep}(A,-B)$ 的推导与计算**\n\n问题要求从第一性原理出发推导谱分离度 $\\mathrm{sep}(A,-B)$。两个矩阵 $M_1$ 和 $M_2$ 之间的分离度形式上定义为 $\\mathrm{sep}(M_1, M_2) = \\inf_{\\|X\\|_F=1} \\|M_1 X - X M_2\\|_F$。对于我们的 Sylvester 方程，相关的量是 $\\mathrm{sep}(A,-B) = \\inf_{\\|X\\|_F=1} \\|A X - X(-B)\\|_F = \\inf_{\\|X\\|_F=1} \\|AX+XB\\|_F$。这正是在算子 $L$ 作用下单位球面像的范数的下确界，它对应于算子 $L$ 的最小奇异值。\n\n为了计算这个量，我们必须找到 $L$ 的一个有限维矩阵表示。这可以通过使用向量化算子 $\\operatorname{vec}(\\cdot)$ 来实现，该算子将矩阵的列堆叠成一个单独的列向量。根据题目所给条件，$\\operatorname{vec}$ 是从配备 Frobenius 范数的矩阵空间 $(\\mathbb{C}^{n\\times m}, \\|\\cdot\\|_F)$ 到配备欧几里得 $2$-范数的向量空间 $(\\mathbb{C}^{nm}, \\|\\cdot\\|_2)$ 的一个线性等距同构。这意味着 $\\|X\\|_F = \\|\\operatorname{vec}(X)\\|_2$。\n\n将 $\\operatorname{vec}$ 算子应用于 Sylvester 方程 $AX+XB=C$ 得到：\n$$\n\\operatorname{vec}(AX+XB) = \\operatorname{vec}(C)\n$$\n利用 $\\operatorname{vec}$ 的线性性质和克罗内克积 ($\\otimes$) 的一个基本性质，我们可以写出：\n$$\n\\operatorname{vec}(AXB) = (B^T \\otimes A)\\operatorname{vec}(X)\n$$\n将此性质应用于 Sylvester 表达式中的每一项：\n$$\n\\operatorname{vec}(AX) = \\operatorname{vec}(AXI_m) = (I_m^T \\otimes A)\\operatorname{vec}(X) = (I_m \\otimes A)\\operatorname{vec}(X)\n$$\n$$\n\\operatorname{vec}(XB) = \\operatorname{vec}(I_nXB) = (B^T \\otimes I_n)\\operatorname{vec}(X)\n$$\n这里，$I_k$ 是 $k \\times k$ 单位矩阵。对于本问题，$n=m=3$，所以单位矩阵的尺寸是 $3 \\times 3$。\n结合这些，向量化的 Sylvester 方程变成一个标准的矩阵-向量方程：\n$$\n\\big( (I_m \\otimes A) + (B^T \\otimes I_n) \\big) \\operatorname{vec}(X) = \\operatorname{vec}(C)\n$$\n令 Sylvester 算子的矩阵表示为 $K = (I_m \\otimes A) + (B^T \\otimes I_n)$。这里，$K$ 是一个 $\\mathbb{C}^{nm \\times nm}$ 中的矩阵。方程现在是 $K\\mathbf{x} = \\mathbf{c}$，其中 $\\mathbf{x}=\\operatorname{vec}(X)$ 且 $\\mathbf{c}=\\operatorname{vec}(C)$。\n\n现在可以用这个矩阵表示来表达量 $\\mathrm{sep}(A,-B)$。\n$$\n\\mathrm{sep}(A,-B) = \\inf_{\\|X\\|_F=1} \\|L[X]\\|_F = \\inf_{\\|\\operatorname{vec}(X)\\|_2=1} \\|K \\operatorname{vec}(X)\\|_2\n$$\n右侧恰好是矩阵 $K$ 的最小奇异值的定义，记为 $\\sigma_{\\min}(K)$。因此，我们推导出了精确的计算公式：\n$$\n\\mathrm{sep}(A,-B) = \\sigma_{\\min}(I_m \\otimes A + B^T \\otimes I_n)\n$$\n对于每个测试案例，我们将构造 $9 \\times 9$ 矩阵 $K$ 并计算其最小奇异值。这个值在理论上也等于 $1/\\|L^{-1}\\|$。\n\n**2. $\\|L^{-1}\\|$ 的蒙特卡洛估计**\n\n由 Frobenius 范数诱导的逆 Sylvester 算子的范数定义为：\n$$\n\\|L^{-1}\\| = \\sup_{C \\neq 0} \\frac{\\|L^{-1}[C]\\|_F}{\\|C\\|_F} = \\sup_{\\|C\\|_F=1} \\|L^{-1}[C]\\|_F\n$$\n令 $X = L^{-1}[C]$，这等价于寻找 $\\sup_{\\|L[X]\\|_F=1} \\|X\\|_F$。蒙特卡洛程序通过抽样为这个量提供一个数值估计值 $\\widehat{\\|L^{-1}\\|}$。该方法包括在右端生成一组随机矩阵 $E$，将其归一化以具有单位 Frobenius 范数，对每个 $E$ 求解 Sylvester 方程 $AX+XB=E$，并找出所得范数 $\\|X\\|_F$ 的最大值。\n\n步骤如下：\n1. 使用固定种子（1）初始化一个伪随机数生成器，以保证可复现性。\n2. 初始化一个变量 `max_norm` 为 $0$。\n3. 进行 $M=200$ 次迭代：\n    a. 生成一个 $n \\times m$ 矩阵 $E_{raw}$，其元素是来自标准正态分布 $\\mathcal{N}(0,1)$ 的独立样本。\n    b. 将此矩阵归一化：$E = E_{raw} / \\|E_{raw}\\|_F$。现在，$\\|E\\|_F=1$。\n    c. 对矩阵 $X$ 求解 Sylvester 方程 $AX+XB=E$。这可以使用专门的求解器（如 `scipy.linalg.solve_sylvester`）高效完成。\n    d. 计算解的 Frobenius 范数 $\\|X\\|_F$。\n    e. 更新 `max_norm = max(max_norm, \\|X\\|_F)`。\n4. 最终值 `max_norm` 就是估计值 $\\widehat{\\|L^{-1}\\|}$。随着样本数量 $M$ 的增加，这个估计值会逼近真实范数，因为随机右端项 $E$ 中有一个与 $L^{-1}$ 的最大放大方向对齐的可能性越来越大。\n\n**3. 用于敏感性分析的伪谱代理**\n\n矩阵 $M$ 的伪谱提供了关于其对扰动敏感性的信息。$\\varepsilon$-伪谱 $\\Lambda_{\\varepsilon}(M)$ 是复数 $z$ 的集合，其中 $z$ 是某个扰动矩阵 $M+E$（$\\|E\\| \\le \\varepsilon$）的特征值。问题中给出的一个等价定义是 $\\Lambda_{\\varepsilon}(M) = \\{ z \\in \\mathbb{C} : \\sigma_{\\min}(zI-M) \\le \\varepsilon \\}$。$\\sigma_{\\min}(zI-M)$ 的值很小，表示 $z$ “接近”于 $M$ 的一个特征值。\n\n当 $A$ 和 $-B$ 的谱接近时，Sylvester 方程的敏感性很高。伪谱推广了这一概念：当 $A$ 和 $-B$ 的伪谱接近或重叠时，敏感性很高。我们可以通过找到函数 $z \\mapsto \\sigma_{\\min}(zI-A)$ 和 $z \\mapsto \\sigma_{\\min}(zI+B)$ 的等位集相交的最小“高度” $\\varepsilon$ 来量化这种邻近性。\n\n代理 $\\mu$ 定义为在一个搜索网格上这两个函数最大值的最小值：\n$$\n\\mu = \\inf_{z\\ \\text{in grid}} \\max \\{ \\sigma_{\\min}(zI-A), \\sigma_{\\min}(zI+B) \\}\n$$\n$\\mu$ 值很小意味着在复平面中存在一个点 $z$，使得 $\\sigma_{\\min}(zI-A)$ 和 $\\sigma_{\\min}(zI+B)$ 的值都很小。这个点 $z$ 同时位于 $\\Lambda_{\\mu}(A)$ 和 $\\Lambda_{\\mu}(-B)$ 中，表明 $A$ 和 $-B$ 的 $\\mu$-伪谱发生了重叠。这种重叠是病态条件的一个强有力指标。因此，倒数 $1/\\mu$ 有望成为 $\\|L^{-1}\\|$ 的一个启发式预测值，通常是一个上界。\n\n网格的构建旨在覆盖 $A$ 和 $-B$ 的谱相互作用的区域。对于每个案例，我们计算 $A$ 和 $-B$ 的特征值，找出实部的极值，并在其周围定义一个矩形网格，填充 0.5 的边距。虚轴范围设置为 $[-0.5, 0.5]$。对于给定的测试案例，这是一个合理的选择，因为特征值全部是实数或接近实轴。然后我们遍历这个 $101 \\times 101$ 的复数网格 $z$，在每个点计算 $\\sigma_{\\min}(zI-A)$ 和 $\\sigma_{\\min}(zI+B)$，并找到它们最大值的最小值，从而得到 $\\mu$。\n\n**4. 数值实现与结果**\n\n这三种方法将针对三个测试案例分别实现。\n- **案例 1：** $A$ 和 $B$ 是正规（对角）矩阵。$A$ 和 $-B$ 的谱分别是 $\\Lambda(A)=\\{1,2,3\\}$ 和 $\\Lambda(-B)=\\{1.1, 2.1, 3.1\\}$。最小谱距离是 $\\delta=0.1$。由于矩阵是正规的，$\\|L^{-1}\\| = 1/\\mathrm{sep}(A,-B)$，我们预期计算出的三个量会很接近。\n- **案例 2：** A 和 B 是正规的，但谱几乎碰撞，最小距离为 $\\delta=10^{-4}$。我们预期所有三个量都会很大，数量级约为 $1/\\delta = 10000$。\n- **案例 3：** $A$ 是一个高度非正规的上三角矩阵，而 $B$ 是单位矩阵的标量倍。$A$ 的特征值全部为 $1$，而 $-B$ 的特征值全部为 $1+\\delta = 1.001$。谱分离度很小，为 $\\delta=10^{-3}$。然而，由于 $A$ 的高度非正规性，其伪谱比谱距离 $\\delta$ 所暗示的要大得多。因此我们预计 $\\widehat{\\|L^{-1}\\|}$ 和 $1/\\mu$ 将显著大于 $1/\\mathrm{sep}(A,-B)$，这表明简单的谱分离度在预测非正规矩阵的条件数方面是失败的。\n\n以下程序实现了这些计算，并以要求的格式报告了九个指定的值。",
                "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_sylvester\n\ndef solve():\n    \"\"\"\n    Performs the required derivations and computations for the Sylvester equation\n    sensitivity analysis across three test cases.\n    \"\"\"\n    \n    # Test suite specifications\n    n = 3\n    m = 3\n    alpha = 20.0\n    \n    test_cases = [\n        {\n            \"name\": \"Case 1: Normal, moderately separated\",\n            \"A\": np.diag([1.0, 2.0, 3.0]),\n            \"B\": np.diag([-1.0 - 1e-1, -2.0 - 1e-1, -3.0 - 1e-1]),\n        },\n        {\n            \"name\": \"Case 2: Normal, nearly colliding\",\n            \"A\": np.diag([1.0, 2.0, 3.0]),\n            \"B\": np.diag([-1.0 - 1e-4, -2.0 - 1e-4, -3.0 - 1e-4]),\n        },\n        {\n            \"name\": \"Case 3: Highly nonnormal A\",\n            \"A\": np.array([[1.0, alpha, 0.0], [0.0, 1.0, alpha], [0.0, 0.0, 1.0]]),\n            \"B\": -(1.0 + 1e-3) * np.eye(m),\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        A = case[\"A\"]\n        B = case[\"B\"]\n\n        # 1. Compute sep(A, -B)\n        # K = I_m kron A + B^T kron I_n\n        K = np.kron(np.eye(m), A) + np.kron(B.T, np.eye(n))\n        # sep(A, -B) = sigma_min(K)\n        # Use svdvals to avoid computing U and Vh, which is more efficient.\n        singular_values_K = np.linalg.svd(K, compute_uv=False)\n        sep_A_minus_B = np.min(singular_values_K)\n        results.append(sep_A_minus_B)\n\n        # 2. Monte Carlo estimation of ||L^-1||\n        M = 200\n        rng = np.random.default_rng(seed=1)\n        max_norm_X = 0.0\n        for _ in range(M):\n            E_raw = rng.standard_normal(size=(n, m))\n            E = E_raw / np.linalg.norm(E_raw, 'fro')\n            \n            # Solve AX + XB = E\n            X = solve_sylvester(A, B, E)\n            \n            norm_X = np.linalg.norm(X, 'fro')\n            if norm_X > max_norm_X:\n                max_norm_X = norm_X\n        \n        estimated_norm_L_inv = max_norm_X\n        results.append(estimated_norm_L_inv)\n\n        # 3. Compute pseudospectral proxy 1/mu\n        # Define the grid\n        eigs_A = np.linalg.eigvals(A)\n        eigs_minus_B = np.linalg.eigvals(-B)\n        all_eigs = np.concatenate((eigs_A, eigs_minus_B))\n        \n        re_min = np.min(np.real(all_eigs))\n        re_max = np.max(np.real(all_eigs))\n        \n        grid_re = np.linspace(re_min - 0.5, re_max + 0.5, 101)\n        grid_im = np.linspace(-0.5, 0.5, 101)\n        \n        mu = np.inf\n        I_n = np.eye(n)\n\n        for re_z in grid_re:\n            for im_z in grid_im:\n                z = re_z + 1j * im_z\n                \n                # s_A(z) = sigma_min(zI - A)\n                s_A_z = np.min(np.linalg.svd(z * I_n - A, compute_uv=False))\n                \n                # s_-B(z) = sigma_min(zI + B)\n                s_minusB_z = np.min(np.linalg.svd(z * I_n + B, compute_uv=False))\n                \n                max_s = max(s_A_z, s_minusB_z)\n                \n                if max_s  mu:\n                    mu = max_s\n        \n        proxy_1_over_mu = 1.0 / mu\n        results.append(proxy_1_over_mu)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```",
                "id": "3578480"
            },
            {
                "introduction": "Sylvester方程并非一个孤立的数学难题，而是贯穿于数值线性代数领域的强大分析工具。这个实践[@problem_id:3578469]展示了它在不变子空间微扰分析中的一个经典应用，这对于理解和计算特征值问题的敏感性至关重要。您将推导出不变子空间的导数与一个特定Sylvester方程的解之间惊人而优雅的联系，这深刻体现了为何掌握此类方程对于解决更高级的矩阵计算问题是必不可少的。",
                "problem": "考虑一个实方阵 $A \\in \\mathbb{R}^{n \\times n}$，其具有实舒尔分解 $A = Q T Q^{\\top}$，其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$T \\in \\mathbb{R}^{n \\times n}$ 是上拟三角矩阵。令 $A(t) = A + t E$ 为一个光滑扰动，其中 $E \\in \\mathbb{R}^{n \\times n}$ 是一个固定矩阵，$t \\in \\mathbb{R}$ 是一个小标量，并假设 $A(t)$ 以实舒尔形式表示为 $A(t) = Q(t) T(t) Q(t)^{\\top}$，且满足 $Q(0) = Q$ 和 $T(0) = T$。根据一个选定的 $k$ 维不变子空间，将舒尔形式分块写作\n$$\nT = \\begin{bmatrix}\nT_{11}  T_{12} \\\\\n0  T_{22}\n\\end{bmatrix}, \\quad Q = \\begin{bmatrix} Q_1  Q_2 \\end{bmatrix},\n$$\n其中 $T_{11} \\in \\mathbb{R}^{k \\times k}$ 对应于所选的特征值簇，$T_{22} \\in \\mathbb{R}^{(n-k) \\times (n-k)}$ 对应于其补集，且 $T_{12} \\in \\mathbb{R}^{k \\times (n-k)}$。\n\n从数值线性代数的第一性原理出发，即正交因子分解和实舒尔形式的可微性，推导连接 $E$、舒尔因子的导数以及由 $Q(t)$ 的斜对称生成元导出的交换子的一阶关系。具体来说，证明如果为了保持块上三角结构，强制 $T$ 的导数在 $t = 0$ 处的左下块为零，那么 $Q(t)$ 的生成元的非对角块必须满足一个Sylvester方程。你的推导必须从恒等式 $Q(t)^{\\top} Q(t) = I$ 和 $A(t) = Q(t) T(t) Q(t)^{\\top}$ 开始，并通过在 $t=0$ 处对 $t$ 求导来进行，仅使用这些基本性质和矩阵交换子的定义。\n\n实现一个算法，在给定 $(Q, T)$、一个扰动 $E$ 以及块大小 $k$ 的情况下，执行以下步骤：\n- 计算 $F = Q^{\\top} E Q$ 并根据 $T$ 的分块方式对其进行相应的分块。\n- 通过构建并求解相应的Sylvester方程，求解关系式 $Q^{\\top} \\dot{Q} = \\Omega$ 中斜对称生成元 $\\Omega \\in \\mathbb{R}^{n \\times n}$ 的非对角块。\n- 用求解出的非对角块和对角块上的零构造一个斜对称矩阵 $\\Omega$，并计算与所推导关系一致的一阶扰动 $dT$。\n- 用一个小步长 $\\varepsilon$ 形成更新后的正交因子 $Q' = Q + \\varepsilon Q \\Omega$，并实施一个正交性控制步骤，使用一种在Frobenius范数下保持与 $Q'$ 邻近的数值稳定方法对 $Q'$ 进行重新正交化。\n\n你的程序必须生成定量诊断信息，以验证Sylvester方程解的正确性和正交性控制的有效性。对于每个测试案例，计算：\n1. Sylvester残差的Frobenius范数 $\\| T_{22} \\Omega_{21} - \\Omega_{21} T_{11} + F_{21} \\|_F$。\n2. $dT$ 左下块的Frobenius范数，即 $\\| (dT)_{21} \\|_F$。\n3. $Q'$ 的正交性缺陷的Frobenius范数，定义为 $\\| Q'^{\\top} Q' - I \\|_F$。\n4. 重新正交化后的相同正交性缺陷，定义为 $\\| \\widehat{Q}^{\\top} \\widehat{Q} - I \\|_F$，其中 $\\widehat{Q}$ 是 $Q'$ 的重新正交化版本。\n5. 一个布尔值，指示正交性控制是否减少了缺陷，即控制后的缺陷是否严格小于控制前的缺陷。\n\n设计一个包含四个案例的测试套件，使用固定种子生成的可复现数据，涵盖一个良好分离的特征值簇、一个近共振的特征值簇、一个最小子空间维度以及一个对称情况：\n- 案例1（良好分离的特征值簇）：$n = 6$，$k = 3$。设 $T_{11}$ 的对角线元素为 $[1.0, 1.5, 2.0]$，$T_{22}$ 的对角线元素为 $[4.0, 5.0, 6.0]$，并使用种子 $10$ 的伪随机生成从 $[-0.1, 0.1]$ 区间均匀抽取 $T_{12}$ 的元素。通过对种子为 $11$ 的标准正态矩阵进行 $\\mathrm{QR}$ 分解来构造 $Q$。设 $E$ 为一个由种子 $12$ 生成、并乘以 $10^{-3}$ 的标准正态矩阵。\n- 案例2（近共振的特征值簇）：$n = 6$，$k = 3$。设 $T_{11}$ 的对角线元素为 $[2.00, 2.10, 2.20]$，$T_{22}$ 的对角线元素为 $[2.05, 2.15, 2.25]$，并使用种子 $20$ 从 $[-0.5, 0.5]$ 区间均匀抽取 $T_{12}$ 的元素。通过对种子为 $21$ 的标准正态矩阵进行 $\\mathrm{QR}$ 分解来构造 $Q$。设 $E$ 为一个由种子 $22$ 生成、并乘以 $10^{-3}$ 的标准正态矩阵。\n- 案例3（最小子空间维度）：$n = 3$，$k = 1$。设 $T_{11}$ 的对角线元素为 $[1.0]$，$T_{22}$ 的对角线元素为 $[3.0, 4.0]$，且 $T_{12} = 0$。使用 $Q = I$。设 $E$ 为一个由种子 $30$ 生成、并乘以 $10^{-2}$ 的标准正态矩阵。\n- 案例4（对称情况）：$n = 5$，$k = 2$。构造 $A$ 为 $A = Q D Q^{\\top}$，其中 $D = \\mathrm{diag}(1.0, 2.0, 3.0, 4.0, 5.0)$，$Q$ 通过对种子为 $41$ 的标准正态矩阵进行 $\\mathrm{QR}$ 分解得到，因此 $T = D$ 是对角矩阵。设 $E$ 为一个对称矩阵，通过对一个种子为 $42$ 的标准正态矩阵进行对称化并乘以 $10^{-3}$ 得到。\n\n在所有案例中，使用 $\\varepsilon = 10^{-3}$ 进行 $Q'$ 更新。你的程序应生成单行输出，包含一个由逗号分隔的列表，并用方括号括起来，其中每个测试案例贡献一个包含五个条目的列表，顺序如上所述。例如，输出格式必须为\n$$\n[ [r_1, d_1, o^{\\mathrm{pre}}_1, o^{\\mathrm{post}}_1, b_1], [r_2, d_2, o^{\\mathrm{pre}}_2, o^{\\mathrm{post}}_2, b_2], [r_3, d_3, o^{\\mathrm{pre}}_3, o^{\\mathrm{post}}_3, b_3], [r_4, d_4, o^{\\mathrm{pre}}_4, o^{\\mathrm{post}}_4, b_4] ].\n$$\n所有数值量都应报告为浮点数，不带任何物理单位。此任务不涉及角度。布尔值必须打印为True或False。程序必须是自包含的，不需要任何输入，并且必须遵守指定的执行环境。",
                "solution": "该问题要求推导一个Sylvester方程，该方程控制矩阵 $A$ 在光滑扰动 $A(t) = A+tE$ 下其不变子空间的一阶扰动。推导之后是一个数值实现，用于求解该方程并验证相关理论结果。推导从第一性原理开始，考虑实舒尔分解的定义性质。\n\n令 $A(t) = A + tE$ 是一个光滑矩阵值函数，其中 $A, E \\in \\mathbb{R}^{n \\times n}$，$t \\in \\mathbb{R}$ 是一个小标量。$A(t)$ 的实舒尔分解由 $A(t) = Q(t) T(t) Q(t)^{\\top}$ 给出，其中 $Q(t)$ 是一个正交矩阵，$T(t)$ 是一个上拟三角矩阵。在 $t=0$ 时，我们有 $A(0)=A$，$Q(0)=Q$ 和 $T(0)=T$。\n\n我们的推导从两个在 $t=0$ 邻域内对所有 $t$ 都成立的基本恒等式开始：\n1. 正交性条件：$Q(t)^{\\top} Q(t) = I$，其中 $I$ 是单位矩阵。\n2. 舒尔分解恒等式：$A(t) = Q(t) T(t) Q(t)^{\\top}$。\n\n我们对这些恒等式关于 $t$ 求导，并在 $t=0$ 处计算结果。令 $\\dot{Q} = \\frac{d Q(t)}{dt}|_{t=0}$ 和 $\\dot{T} = \\frac{d T(t)}{dt}|_{t=0}$。\n\n首先，对正交性条件使用乘法法则求导，得到：\n$$\n\\frac{d}{dt} (Q(t)^{\\top} Q(t)) = \\dot{Q}(t)^{\\top} Q(t) + Q(t)^{\\top} \\dot{Q}(t) = \\frac{d}{dt}(I) = 0\n$$\n在 $t=0$ 处计算：\n$$\n\\dot{Q}^{\\top} Q + Q^{\\top} \\dot{Q} = 0\n$$\n我们定义旋转的生成元 $\\Omega \\in \\mathbb{R}^{n \\times n}$ 为 $\\Omega = Q^{\\top} \\dot{Q}$。将此代入方程，我们得到 $(\\dot{Q}^{\\top} Q) + \\Omega = (Q^{\\top} \\dot{Q})^{\\top} + \\Omega = \\Omega^{\\top} + \\Omega = 0$。这证明了 $\\Omega$ 是一个斜对称矩阵，即 $\\Omega^{\\top} = -\\Omega$。从 $\\Omega = Q^{\\top} \\dot{Q}$，我们可以将正交因子的导数表示为 $\\dot{Q} = Q\\Omega$。\n\n其次，我们对舒尔分解恒等式求导。左侧的导数是 $\\frac{d}{dt}A(t) = \\frac{d}{dt}(A+tE) = E$。对右侧应用乘法法则得到：\n$$\nE = \\dot{Q} T Q^{\\top} + Q \\dot{T} Q^{\\top} + Q T \\dot{Q}^{\\top}\n$$\n我们将 $\\dot{Q} = Q\\Omega$ 和 $\\dot{Q}^{\\top} = \\Omega^{\\top} Q^{\\top} = -\\Omega Q^{\\top}$ 代入 $E$ 的表达式中：\n$$\nE = (Q\\Omega) T Q^{\\top} + Q \\dot{T} Q^{\\top} + Q T (-\\Omega Q^{\\top}) = Q ( \\Omega T + \\dot{T} - T \\Omega ) Q^{\\top}\n$$\n左乘 $Q^{\\top}$ 并右乘 $Q$ 得到：\n$$\nQ^{\\top} E Q = \\Omega T - T \\Omega + \\dot{T}\n$$\n令 $F = Q^{\\top} E Q$。该方程可以用矩阵交换子 $[\\Omega, T] = \\Omega T - T \\Omega$ 来写：\n$$\n\\dot{T} = F - [\\Omega, T]\n$$\n现在，我们根据维度为 $k$ 的不变子空间，对矩阵 $T$、$F$、$\\Omega$ 和 $\\dot{T}$ 进行相应的分块：\n$$\nT = \\begin{bmatrix} T_{11}  T_{12} \\\\ 0  T_{22} \\end{bmatrix}, \\quad F = \\begin{bmatrix} F_{11}  F_{12} \\\\ F_{21}  F_{22} \\end{bmatrix}, \\quad \\Omega = \\begin{bmatrix} \\Omega_{11}  \\Omega_{12} \\\\ \\Omega_{21}  \\Omega_{22} \\end{bmatrix}, \\quad \\dot{T} = \\begin{bmatrix} \\dot{T}_{11}  \\dot{T}_{12} \\\\ \\dot{T}_{21}  \\dot{T}_{22} \\end{bmatrix}\n$$\n其中 $T_{11} \\in \\mathbb{R}^{k \\times k}$，$F_{11} \\in \\mathbb{R}^{k \\times k}$，等等。由于 $\\Omega$ 是斜对称的，$\\Omega_{11}$ 和 $\\Omega_{22}$ 必须是斜对称的，且 $\\Omega_{12} = -\\Omega_{21}^{\\top}$。\n\n交换子的分块形式为：\n$$\n[\\Omega, T] = \\begin{bmatrix} [\\Omega_{11}, T_{11}] - T_{12}\\Omega_{21}  \\Omega_{11}T_{12} + \\Omega_{12}T_{22} - T_{11}\\Omega_{12} - T_{12}\\Omega_{22} \\\\ \\Omega_{21}T_{11} - T_{22}\\Omega_{21}  [\\Omega_{22}, T_{22}] + \\Omega_{21}T_{12} \\end{bmatrix}\n$$\n将此代入 $\\dot{T} = F - [\\Omega, T]$ 并考察 $(2,1)$ 块，得到：\n$$\n\\dot{T}_{21} = F_{21} - (\\Omega_{21}T_{11} - T_{22}\\Omega_{21}) = F_{21} + T_{22}\\Omega_{21} - \\Omega_{21}T_{11}\n$$\n问题指出，我们必须强制 $T(t)$ 的块上三角结构在小的 $t$ 值下得以保持。这意味着其导数 $\\dot{T}$ 的 $(2,1)$ 块必须为零：$\\dot{T}_{21}=0$。这个条件得出：\n$$\n0 = F_{21} + T_{22}\\Omega_{21} - \\Omega_{21}T_{11}\n$$\n整理后得到关于非对角块 $\\Omega_{21}$ 的Sylvester方程：\n$$\nT_{22} \\Omega_{21} - \\Omega_{21} T_{11} = -F_{21}\n$$\n这个基本方程决定了在扰动 $E$ 下不变子空间的旋转。解 $\\Omega_{21}$ 的存在性和唯一性取决于 $T_{11}$ 和 $T_{22}$ 的谱是互不相交的。\n\n接下来的实现将计算问题中指定的量。它将求解这个Sylvester方程以得到 $\\Omega_{21}$。为了唯一确定 $\\Omega$，我们施加一个规范条件，即其对角块为零，即 $\\Omega_{11}=0$ 和 $\\Omega_{22}=0$。这得到 $\\Omega = \\begin{bsmallmatrix} 0  -\\Omega_{21}^{\\top} \\\\ \\Omega_{21}  0 \\end{bsmallmatrix}$。当 $\\Omega$ 完全确定后，$\\dot{T}$ 也随之确定。然后我们将计算 $Q$ 的一阶更新 $Q' = Q + \\varepsilon\\dot{Q} = Q(I + \\varepsilon\\Omega)$ 并评估其与正交性的偏差。最后，我们将使用极分解对 $Q'$ 应用重新正交化程序，该程序在Frobenius范数下找到最接近的正交矩阵，并量化正交性的改善。所要求的诊断数据将验证此过程的每一步。",
                "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_sylvester, polar, qr\n\ndef solve():\n    \"\"\"\n    Solves the numerical linear algebra problem for four test cases.\n    \"\"\"\n\n    def run_case(n, k, T, Q, E, epsilon):\n        \"\"\"\n        Executes the logic for a single test case.\n        \"\"\"\n        # Step 1: Compute F and partition it\n        F = Q.T @ E @ Q\n        F11 = F[:k, :k]\n        F12 = F[:k, k:]\n        F21 = F[k:, :k]\n        F22 = F[k:, k:]\n        \n        T11 = T[:k, :k]\n        T22 = T[k:, k:]\n\n        # Step 2: Solve the Sylvester equation for Omega_21\n        # T22 * Omega_21 - Omega_21 * T11 = -F21\n        # Scipy solves AX + XB = Q, so A=T22, X=Omega_21, B=-T11, Q=-F21\n        Omega_21 = solve_sylvester(T22, -T11, -F21)\n        \n        # Diagnostic 1: Sylvester residual norm\n        sylvester_residual = np.linalg.norm(T22 @ Omega_21 - Omega_21 @ T11 + F21, 'fro')\n\n        # Step 3: Construct Omega and compute dT\n        Omega_11 = np.zeros((k, k))\n        Omega_22 = np.zeros((n - k, n - k))\n        Omega_12 = -Omega_21.T\n        Omega = np.block([\n            [Omega_11, Omega_12],\n            [Omega_21, Omega_22]\n        ])\n        \n        # dT = F - [Omega, T] = F - (Omega @ T - T @ Omega)\n        dT = F - (Omega @ T - T @ Omega)\n        \n        # Diagnostic 2: Norm of the (2,1) block of dT\n        dT_21_norm = np.linalg.norm(dT[k:, :k], 'fro')\n        \n        # Step 4: Form updated Q' and perform orthogonality control\n        I_n = np.identity(n)\n        # Q' = Q + eps * dQ = Q + eps * Q @ Omega = Q @ (I + eps * Omega)\n        Q_prime = Q @ (I_n + epsilon * Omega)\n        \n        # Diagnostic 3: Pre-control orthogonality defect\n        pre_ortho_defect = np.linalg.norm(Q_prime.T @ Q_prime - I_n, 'fro')\n\n        # Re-orthonormalize Q' using polar decomposition to find the closest orthogonal matrix.\n        Q_hat, _ = polar(Q_prime)\n        \n        # Diagnostic 4: Post-control orthogonality defect\n        post_ortho_defect = np.linalg.norm(Q_hat.T @ Q_hat - I_n, 'fro')\n        \n        # Diagnostic 5: Boolean for defect reduction\n        defect_reduced = post_ortho_defect  pre_ortho_defect\n        \n        return [sylvester_residual, dT_21_norm, pre_ortho_defect, post_ortho_defect, defect_reduced]\n\n    test_cases = []\n    epsilon = 1e-3\n\n    # Case 1: Well-separated cluster\n    n, k = 6, 3\n    rng_T12 = np.random.default_rng(10)\n    rng_Q = np.random.default_rng(11)\n    rng_E = np.random.default_rng(12)\n    \n    T11 = np.diag([1.0, 1.5, 2.0])\n    T22 = np.diag([4.0, 5.0, 6.0])\n    T12 = rng_T12.uniform(-0.1, 0.1, size=(k, n - k))\n    T = np.block([[T11, T12], [np.zeros((n - k, k)), T22]])\n    Q, _ = qr(rng_Q.standard_normal(size=(n, n)))\n    E = rng_E.standard_normal(size=(n, n)) * 1e-3\n    test_cases.append(('Case 1', n, k, T, Q, E, epsilon))\n\n    # Case 2: Near-resonant cluster\n    n, k = 6, 3\n    rng_T12 = np.random.default_rng(20)\n    rng_Q = np.random.default_rng(21)\n    rng_E = np.random.default_rng(22)\n    \n    T11 = np.diag([2.00, 2.10, 2.20])\n    T22 = np.diag([2.05, 2.15, 2.25])\n    T12 = rng_T12.uniform(-0.5, 0.5, size=(k, n - k))\n    T = np.block([[T11, T12], [np.zeros((n - k, k)), T22]])\n    Q, _ = qr(rng_Q.standard_normal(size=(n, n)))\n    E = rng_E.standard_normal(size=(n, n)) * 1e-3\n    test_cases.append(('Case 2', n, k, T, Q, E, epsilon))\n    \n    # Case 3: Minimal subspace dimension\n    n, k = 3, 1\n    rng_E = np.random.default_rng(30)\n    \n    T11 = np.array([[1.0]])\n    T22 = np.diag([3.0, 4.0])\n    T12 = np.zeros((k, n-k))\n    T = np.block([[T11, T12], [np.zeros((n - k, k)), T22]])\n    Q = np.identity(n)\n    E = rng_E.standard_normal(size=(n, n)) * 1e-2\n    test_cases.append(('Case 3', n, k, T, Q, E, epsilon))\n    \n    # Case 4: Symmetric case\n    n, k = 5, 2\n    rng_Q = np.random.default_rng(41)\n    rng_E = np.random.default_rng(42)\n    \n    T = np.diag([1.0, 2.0, 3.0, 4.0, 5.0])\n    Q, _ = qr(rng_Q.standard_normal(size=(n, n)))\n    E_rand = rng_E.standard_normal(size=(n, n))\n    E = (E_rand + E_rand.T) / 2 * 1e-3\n    test_cases.append(('Case 4', n, k, T, Q, E, epsilon))\n\n    results = []\n    for _, n_case, k_case, T_case, Q_case, E_case, eps_case in test_cases:\n        result = run_case(n_case, k_case, T_case, Q_case, E_case, eps_case)\n        results.append(result)\n\n    # Format the final output string\n    # E.g., [[1.23, ...], [4.56, ...]]\n    output_str = \"[\" + \", \".join([str(res) for res in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```",
                "id": "3578469"
            }
        ]
    }