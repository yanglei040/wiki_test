{
        "hands_on_practices": [
            {
                "introduction": "在现代计算机体系结构中，内存地址到缓存集的映射并非随机。本练习探讨了矩阵的规则内存布局如何与缓存的集索引机制相互作用，这可能导致降低性能的冲突未命中。通过解决这个问题 [@problem_id:3542736]，您将学会诊断此类问题，并应用“填充”（padding）这一实用技术，以确保连续的矩阵行映射到不同的缓存集，从而改善数据访问模式。",
                "problem": "考虑一个计算机系统，其单级数据缓存具有容量 $C$、相联度 $A$ 和缓存行大小 $L$，这些值都被选为2的幂。对于这样的缓存，其组数 $S = \\frac{C}{A L}$，内存地址 $a$ 的组索引由广泛使用的2的幂次映射规则定义为 $s(a) = \\left( \\left\\lfloor \\frac{a}{L} \\right\\rfloor \\right) \\bmod S$。一个稠密矩阵 $M \\in \\mathbb{R}^{n \\times m}$ 以行主序在内存中连续存储，元素大小为 $b$ 字节。第 $i$ 行的起始地址是 $\\alpha + i B$，其中 $B = m b + p$ 是以字节为单位的行步长，包含一个可选的填充 $p \\geq 0$。为确保科学真实性和地址对齐无关的行为，必须选择填充 $p$，使得 $B$ 是 $L$ 的整数倍。\n\n给定具体参数：$C = 32 \\times 2^{10}$ 字节，$A = 8$，$L = 64$ 字节，$b = 8$ 字节（双精度），$m = 1024$，以及一个与缓存行边界对齐的基地址 $\\alpha$，使得 $\\frac{\\alpha}{L} \\in \\mathbb{Z}$。请根据行主序布局和缓存的2的幂次组索引的基本原理，推导出最小的非负填充 $p$ (以字节为单位)，使得任意连续的两行 $i$ 和 $i+1$ 映射到不同的缓存组。\n\n以字节为单位表示你的最终答案。无需四舍五入。",
                "solution": "问题要求找到一个行主序矩阵的最小非负填充 $p$，以确保连续的行不会映射到相同的缓存组。问题的核心在于理解内存地址、行步长和缓存的组索引机制之间的关系。\n\n首先，我们根据给定的参数确定缓存的几何结构。缓存容量为 $C = 32 \\times 2^{10}$ 字节，相联度为 $A = 8$，缓存行大小为 $L = 64$ 字节。由于这些都是2的幂，我们可以将它们写为 $C = 2^5 \\times 2^{10} = 2^{15}$ 字节，$A = 2^3$，$L = 2^6$ 字节。缓存中的组数 $S$ 由以下公式给出：\n$$S = \\frac{C}{A L} = \\frac{2^{15} \\text{ bytes}}{(8) \\cdot (64 \\text{ bytes})} = \\frac{2^{15}}{2^3 \\cdot 2^6} = \\frac{2^{15}}{2^9} = 2^6 = 64$$\n因此，缓存中有 $S=64$ 个组。\n\n内存地址 $a$ 被映射到索引为 $s(a)$ 的组，该索引由2的幂次映射规则给出：\n$$s(a) = \\left( \\left\\lfloor \\frac{a}{L} \\right\\rfloor \\right) \\bmod S$$\n其中，$\\lfloor a/L \\rfloor$ 项表示内存地址 $a$ 的缓存块地址或块索引。\n\n矩阵以行主序存储。第 $i$ 行的起始内存地址是 $a_i = \\alpha + iB$，其中 $\\alpha$ 是矩阵的基地址，$B$ 是以字节为单位的行步长。行步长定义为 $B = m b + p$，其中 $m=1024$ 是列数，$b=8$ 字节是每个元素的大小，$p \\ge 0$ 是填充。\n\n问题提出了两个关键约束：\n1. 基地址 $\\alpha$ 与缓存行边界对齐，这意味着 $\\frac{\\alpha}{L}$ 是一个整数。令 $\\frac{\\alpha}{L} = k_{\\alpha}$，其中 $k_{\\alpha} \\in \\mathbb{Z}$。\n2. 行步长 $B$ 是缓存行大小 $L$ 的整数倍。这意味着 $\\frac{B}{L}$ 是一个整数。令 $\\frac{B}{L} = k_{B}$，其中 $k_{B} \\in \\mathbb{Z}$。\n\n需要满足的条件是，对于任何行索引 $i$，连续的两行 $i$ 和 $i+1$ 都会映射到不同的缓存组。这可以用数学语言表述为 $s(a_i) \\neq s(a_{i+1})$，其中 $a_i$ 和 $a_{i+1}$ 分别是第 $i$ 行和第 $i+1$ 行的起始地址。\n\n让我们分析第 $i$ 行起始地址的组索引 $s(a_i)$：\n$$s(a_i) = \\left( \\left\\lfloor \\frac{a_i}{L} \\right\\rfloor \\right) \\bmod S = \\left( \\left\\lfloor \\frac{\\alpha + iB}{L} \\right\\rfloor \\right) \\bmod S$$\n利用对齐约束，我们可以简化取整表达式：\n$$\\left\\lfloor \\frac{\\alpha + iB}{L} \\right\\rfloor = \\left\\lfloor \\frac{\\alpha}{L} + i\\frac{B}{L} \\right\\rfloor = \\lfloor k_{\\alpha} + i k_{B} \\rfloor$$\n由于 $i$，$k_{\\alpha}$ 和 $k_{B}$ 都是整数，它们的和也是整数，所以取整操作是多余的。\n$$s(a_i) = (k_{\\alpha} + ik_{B}) \\bmod S$$\n类似地，对于第 $i+1$ 行，起始地址是 $a_{i+1} = \\alpha + (i+1)B$。其组索引为：\n$$s(a_{i+1}) = (k_{\\alpha} + (i+1)k_{B}) \\bmod S = (k_{\\alpha} + ik_{B} + k_{B}) \\bmod S$$\n\n条件 $s(a_i) \\neq s(a_{i+1})$ 必须对任意 $i$ 成立。这等价于声明组索引的差模 $S$ 不为零：\n$$(k_{\\alpha} + ik_{B} + k_{B}) - (k_{\\alpha} + ik_{B}) \\not\\equiv 0 \\pmod S$$\n$$k_{B} \\not\\equiv 0 \\pmod S$$\n这个简单的条件——以缓存行大小为单位的行步长（$k_B$）不能是缓存组数（$S$）的倍数——是解决这个问题的关键。\n\n现在我们必须用填充 $p$ 来表示 $k_{B}$ 并应用约束条件。\n$$k_{B} = \\frac{B}{L} = \\frac{m b + p}{L}$$\n代入给定值：$m=1024$，$b=8$，$L=64$。\n$$k_{B} = \\frac{1024 \\times 8 + p}{64} = \\frac{8192 + p}{64}$$\n$B$ 必须是 $L$ 的倍数这一约束意味着 $mb+p$ 必须是 $64$ 的倍数。\n$$1024 \\times 8 + p = 8192 + p$$\n由于 $8192 = 128 \\times 64$，所以 $8192$ 已经是 $64$ 的倍数。为了使和 $8192+p$ 成为 $64$ 的倍数，$p$ 也必须是 $64$ 的倍数。\n因此，我们可以将 $p$ 写成 $p = q \\cdot L = 64q$ 的形式，其中 $q \\ge 0$ 是某个非负整数。\n\n让我们将 $p=64q$ 代回到 $k_B$ 的表达式中：\n$$k_{B} = \\frac{8192 + 64q}{64} = \\frac{8192}{64} + \\frac{64q}{64} = 128 + q$$\n现在我们应用条件 $k_{B} \\not\\equiv 0 \\pmod S$，其中 $S=64$：\n$$128 + q \\not\\equiv 0 \\pmod{64}$$\n由于 $128 = 2 \\times 64$，我们有 $128 \\equiv 0 \\pmod{64}$。该条件简化为：\n$$q \\not\\equiv 0 \\pmod{64}$$\n我们需要找到最小的非负填充 $p$。这对应于找到满足此条件的最小非负整数 $q$。$q$ 的可能值为 $0, 1, 2, \\dots$。\n- 如果 $q=0$，则 $q \\equiv 0 \\pmod{64}$。这违反了该条件。这种情况对应于 $p=0$，它会导致连续的行映射到同一个组。\n- 不为 $64$ 的倍数的最小非负整数是 $q=1$。\n\n因此，$q$ 的最小值为 $1$。那么最小填充 $p$ 为：\n$$p_{\\min} = q_{\\min} \\cdot L = 1 \\cdot 64 = 64$$\n所需的最小非負填充為 $64$ 字節。",
                "answer": "$$\\boxed{64}$$",
                "id": "3542736"
            },
            {
                "introduction": "数据一旦加载到缓存中，性能便取决于我们在其被逐出前能多有效地使用它。本练习聚焦于空间局部性——即充分利用取入的缓存行中所有数据的原则。这个问题 [@problem_id:3542775] 要求您建立一个简洁而强大的分析模型，来量化内存访问步长（stride）与缓存命中概率之间的关系，从而让您具体地理解为何单位步长访问对性能至关重要。",
                "problem": "考虑一个以行主序存储的二维数组，其基地址为 $a_0$。元素 $(i,j)$ 的地址为 $a(i,j) = a_0 + e \\cdot (i \\cdot ld + j)$，其中元素大小为 $e$ 字节，导维（列数）为 $ld$。一个嵌套循环以 $i \\in \\{0,1,\\dots,I-1\\}$ 和 $j \\in \\{0,1,\\dots,J-1\\}$ 的形式访问索引为 $(i \\cdot s_i, j \\cdot s_j)$ 的数组元素，其中 $s_i$ 和 $s_j$ 是正整数步长。机器拥有一个高速缓存，其缓存行大小为 $C$ 字节。假设如下：\n- 第一个被访问元素在其缓存行内的初始偏移量，即 $a(0,0) \\bmod C$，在 $[0,C)$ 区间内均匀分布，并与所有其他因素无关。\n- 唯一考虑的未命中源是两次连续访问是否落入同一缓存行；忽略容量、冲突以及超出紧邻前一次访问之外的时间重用。\n- 缓存行一旦被访问，即可用于下一次访问而不会被驱逐。\n\n对于参数为 $e = 8$，$C = 64$，$ld = 1024$，$I = 100$，$J = 50$，$s_i = 1$ 和 $s_j = 3$ 的特定情况，将整个执行过程建模为一个由嵌套循环排序的 $I \\cdot J$ 次访问序列，并将“连续对”定义为该序列中两次连续的访问。运用地址算术和关于缓存行边界的模运算推理的第一性原理，计算在整个执行过程中，其两个地址位于同一缓存行内的连续对的比例。将你的答案四舍五入到 $5$ 位有效数字。",
                "solution": "### 第一步：提取已知条件\n- 数组存储：行主序。\n- 基地址：$a_0$。\n- 数组中元素 $(i,j)$ 的地址：$a(i,j) = a_0 + e \\cdot (i \\cdot ld + j)$。\n- 元素大小：$e = 8$ 字节。\n- 导维（列数）：$ld = 1024$。\n- 缓存行大小：$C = 64$ 字节。\n- 循环边界：$i \\in \\{0, 1, \\dots, I-1\\}$，$I=100$；$j \\in \\{0, 1, \\dots, J-1\\}$，$J=50$。\n- 访问步长：$s_i = 1$，$s_j = 3$。\n- 循环迭代 $(i,j)$ 时访问的数组索引：$(i \\cdot s_i, j \\cdot s_j)$。\n- 初始偏移量假设：第一个被访问地址的偏移量 $a_0 \\pmod C$ 在 $[0, C)$ 上均匀分布。\n- 缓存模型：当且仅当一次连续访问落入其前驱的同一缓存行时，发生一次命中。所有其他缓存效应均被忽略。\n\n### 第二步：使用提取的已知条件进行验证\n该问题有科学依据，植根于计算机体系结构和数值线性代数中关于数据局部性的原理。问题提法明确，提供了所有必需的参数和一个清晰定义（尽管简化了）的缓存模型。参数是现实的。语言是客观且无歧义的。该问题要求基于一个明确指定的模型进行计算，这是性能分析中的一种标准方法。标准的嵌套循环顺序（外层循环是 $i$，内层循环是 $j$）的假设是隐含的，但在此背景下是普遍理解的。该问题是有效的。\n\n### 第三步：进行求解\n\n在循环迭代 $(i,j)$ 时访问的元素地址，可以通过将有效索引 $i' = i \\cdot s_i$ 和 $j' = j \\cdot s_j$ 代入通用地址公式得到。设 $A(i,j)$ 为此地址：\n$$A(i,j) = a_0 + e \\cdot ((i \\cdot s_i) \\cdot ld + (j \\cdot s_j))$$\n两个地址 $A_1$ 和 $A_2$ 位于大小为 $C$ 的同一缓存行内，当且仅当它们除以 $C$ 的整数除法得到相同的商，即 $\\lfloor A_1/C \\rfloor = \\lfloor A_2/C \\rfloor$。\n\n设 $A_2 = A_1 + \\Delta A$，其中 $\\Delta A > 0$ 是两次连续内存访问之间的地址差。如果两次访问之间没有跨越缓存行边界，则它们位于同一缓存行内。缓存行边界是 $C$ 的倍数的地址。条件是区间 $(A_1, A_1 + \\Delta A]$ 不包含任何形如 $k \\cdot C$（对于某个整数 $k$）的地址。\n\n这等价于条件 $\\lfloor (A_1 + \\Delta A)/C \\rfloor = \\lfloor A_1/C \\rfloor$。设 $A_1 = qC + r$，其中 $q = \\lfloor A_1/C \\rfloor$ 是缓存行号，$r = A_1 \\pmod C$ 是行内偏移量，$r \\in [0, C)$。该条件变为 $\\lfloor (qC + r + \\Delta A)/C \\rfloor = q$，可简化为 $\\lfloor (r + \\Delta A)/C \\rfloor = 0$。这当且仅当 $r + \\Delta A  C$ 时成立。\n\n问题陈述，初始偏移量 $a_0 \\pmod C$ 是均匀分布的。任何后续地址为 $A(i,j) = a_0 + \\delta_{ij}$，其中 $\\delta_{ij} = e \\cdot (is_ild + js_j)$ 对于给定的 $(i,j)$ 是一个常数。因此，$A(i,j)$ 在其缓存行内的偏移量 $A(i,j) \\pmod C$ 也在 $[0, C)$ 上均匀分布。因此，对于任何给定的访问，其偏移量 $r$ 小于某个值 $v \\in [0,C)$ 的概率是 $v/C$。\n\n两次连续访问的地址位于同一缓存行的概率 $P_{\\text{same}}$，是 $r  C - \\Delta A$ 的概率。\n- 如果 $\\Delta A \\ge C$，那么 $C - \\Delta A \\le 0$，所以概率为 $0$。\n- 如果 $0  \\Delta A  C$，概率为 $P(r  C - \\Delta A) = \\frac{C - \\Delta A}{C} = 1 - \\frac{\\Delta A}{C}$。\n综合这些，对于一个向前的地址步长 $\\Delta A$，保持在同一缓存行内的概率是：\n$$P_{\\text{same}}(\\Delta A) = \\max\\left(0, 1 - \\frac{\\Delta A}{C}\\right)$$\n\n执行顺序遵循标准的嵌套循环，其中内层循环（对 $j$）在外层循环（对 $i$）的每次迭代中都会完整运行。这会产生两种类型的连续访问对：\n\n1.  **内层循环转换：** 对于 $j \\in \\{0, 1, \\dots, J-2\\}$，在 $(i,j)$ 的访问之后是 $(i, j+1)$ 的访问。\n2.  **外层循环转换：** 对于 $i \\in \\{0, 1, \\dots, I-2\\}$，在 $(i, J-1)$ 的访问之后是 $(i+1, 0)$ 的访问。\n\n我们为每种情况计算地址差 $\\Delta A$。\n\n**情况1：内层循环转换**\n地址差为 $\\Delta A_{\\text{inner}} = A(i, j+1) - A(i,j)$。\n$$\\Delta A_{\\text{inner}} = \\left[a_0 + e \\cdot (is_ild + (j+1)s_j)\\right] - \\left[a_0 + e \\cdot (is_ild + js_j)\\right]$$\n$$\\Delta A_{\\text{inner}} = e \\cdot s_j$$\n使用给定参数 $e=8$ 和 $s_j=3$：\n$$\\Delta A_{\\text{inner}} = 8 \\cdot 3 = 24 \\text{ 字节}$$\n\n**情况2：外层循环转换**\n地址差为 $\\Delta A_{\\text{outer}} = A(i+1, 0) - A(i, J-1)$。\n$$\\Delta A_{\\text{outer}} = \\left[a_0 + e \\cdot ((i+1)s_ild)\\right] - \\left[a_0 + e \\cdot (is_ild + (J-1)s_j)\\right]$$\n$$\\Delta A_{\\text{outer}} = e \\cdot [(i+1)s_ild - is_ild - (J-1)s_j] = e \\cdot [s_ild - (J-1)s_j]$$\n使用参数 $e=8$，$s_i=1$，$ld=1024$，$J=50$，$s_j=3$：\n$$\\Delta A_{\\text{outer}} = 8 \\cdot [1 \\cdot 1024 - (50-1) \\cdot 3] = 8 \\cdot [1024 - 49 \\cdot 3]$$\n$$\\Delta A_{\\text{outer}} = 8 \\cdot [1024 - 147] = 8 \\cdot 877 = 7016 \\text{ 字节}$$\n\n现在我们计算每种转换类型下保持在同一缓存行内的概率，其中 $C = 64$ 字节。\n\n对于内层循环转换：$\\Delta A_{\\text{inner}} = 24  C = 64$。\n$$P_{\\text{same, inner}} = 1 - \\frac{\\Delta A_{\\text{inner}}}{C} = 1 - \\frac{24}{64} = 1 - \\frac{3}{8} = \\frac{5}{8}$$\n对于外层循环转换：$\\Delta A_{\\text{outer}} = 7016  C = 64$。\n$$P_{\\text{same, outer}} = \\max\\left(0, 1 - \\frac{7016}{64}\\right) = 0$$\n\n接下来，我们计算每种转换类型的出现次数。总访问次数为 $I \\cdot J = 100 \\cdot 50 = 5000$。连续对的总数为 $N_{\\text{pairs}} = I \\cdot J - 1 = 4999$。\n\n-   内层循环转换次数 $N_{\\text{inner}}$：对于 $I=100$ 行中的每一行，都有 $J-1=49$ 次转换。\n    $$N_{\\text{inner}} = I \\cdot (J-1) = 100 \\cdot 49 = 4900$$\n-   外层循环转换次数 $N_{\\text{outer}}$：这些转换发生在除最后一行外的每一行的末尾。\n    $$N_{\\text{outer}} = I - 1 = 100 - 1 = 99$$\n    作为检验，$N_{\\text{inner}} + N_{\\text{outer}} = 4900 + 99 = 4999 = N_{\\text{pairs}}$。\n\n位于同一缓存行内的连续对的比例是此类对的总期望数量除以总的连续对数。\n位于同一缓存行的连续对的期望数量是每种转换类型的次数乘以其各自概率的总和：\n$$E[\\text{Hits}] = N_{\\text{inner}} \\cdot P_{\\text{same, inner}} + N_{\\text{outer}} \\cdot P_{\\text{same, outer}}$$\n$$E[\\text{Hits}] = 4900 \\cdot \\frac{5}{8} + 99 \\cdot 0 = \\frac{24500}{8} = 3062.5$$\n比例 $F$ 是这个期望数量除以总的连续对数：\n$$F = \\frac{E[\\text{Hits}]}{N_{\\text{pairs}}} = \\frac{3062.5}{4999}$$\n$$F \\approx 0.6126225245...$$\n四舍五入到 $5$ 位有效数字，我们得到 $0.61262$。",
                "answer": "$$\\boxed{0.61262}$$",
                "id": "3542775"
            },
            {
                "introduction": "对于那些数据量过大而无法完全装入缓存的问题，我们必须重构算法以显式地管理数据移动。本练习介绍了分块（tiling），一种将大型矩阵运算分解为更小、缓存友好块的基本优化技术。通过分析一个分块矩阵转置操作 [@problem_id:3542785]，您将确定最优的块大小，以确保活动工作集能装入缓存，从而最大化数据重用并最小化代价高昂的容量未命中。",
                "problem": "考虑一个稠密矩阵的分块转置操作，从输入矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 转置到输出矩阵 $B \\in \\mathbb{R}^{n \\times n}$，两者均以行主序存储。该算法处理大小为 $b \\times b$ 的方形分块，从 $A$ 中读取一个分块 $\\mathcal{T}_A(i,j)$，并将其转置写入 $B$ 中对应的分块 $\\mathcal{T}_B(j,i)$，直到整个矩阵完成转置。每个矩阵元素占用 $s$ 字节。假设一个理想的两级存储模型，其中有一个全相联、采用最近最少使用 (LRU) 替换策略且总容量为 $M$ 字节的单个数据缓存。假设采用写分配、写回策略，并忽略如标签存储等额外的元数据空间。在此问题中，缓存行大小是无关紧要的；你可以以字节为粒度来模拟容量效应，并且由于缓存是全相联的，你可以忽略冲突未命中。\n\n你需要根据容量模型的基本原理进行推导：当计算的某个阶段内需要重用的不同数据的集合大小超过了缓存容量 $M$ 时，就会发生容量未命中。对于分块转置，假设其实现方式是这样的：在处理单个分块对 $(i,j)$ 的过程中，所有的访问都局限于这两个分块 $\\mathcal{T}_A(i,j)$ 和 $\\mathcal{T}_B(j,i)$ 之内，直到这对分块处理完毕。\n\n请以闭式解的形式，推导出作为 $M$ 和 $s$ 的函数的最佳整数分块大小 $b^{\\star}$，该大小通过确保两个分块在处理期间能同时驻留在缓存中，从而最小化容量未命中。将你的最终答案表示为一个单一的解析表达式。不需要进行数值计算或四舍五入。最终答案必须是一个单一的符号数学表达式。",
                "solution": "分块转置算法处理 $b \\times b$ 大小的分块。在所述的理想缓存模型（全相联、采用最近最少使用 (LRU) 替换策略且容量为 $M$ 字节）下，容量未命中是由处理单个分块对期间的工作集大小决定的。根据假设，实现在转置该分块对时，将其访问局限于两个分块 $\\mathcal{T}_A(i,j)$ 和 $\\mathcal{T}_B(j,i)$ 之内。\n\n我们从基本容量原理出发：在全相联缓存的 LRU 策略下，如果两次使用之间引用的不同数据总量不超过缓存容量，那么所有未经驱逐而被重用的数据都将命中。形式上，如果任何数据项的重用距离（以字节为单位）至多为 $M$，那么该数据项在被重用时将存在于缓存中，并且该访问将是一次缓存命中。\n\n在当前的分块转置中，处理一个分块对期间的工作集是两个分块的并集：\n- 分块 $\\mathcal{T}_A(i,j)$ 包含 $b \\times b$ 个元素，占用 $b^{2} \\cdot s$ 字节。\n- 分块 $\\mathcal{T}_B(j,i)$ 包含 $b \\times b$ 个元素，占用 $b^{2} \\cdot s$ 字节。\n\n因此，要将两个分块同时保留在缓存中所需的总驻留数据量为\n$$\nW(b) \\;=\\; b^{2} s \\;+\\; b^{2} s \\;=\\; 2 b^{2} s.\n$$\n在理想容量模型下，如果 $W(b) \\leq M$，那么一旦分块被加载到缓存中，LRU 策略将保留它们直到处理完成，并且在初始的强制加载或写分配行填充之后，大部分分块内的访问都将作为缓存命中来处理。如果 $W(b)  M$，缓存无法同时容纳两个分块，LRU 策略在访问一个分块时会驱逐另一个分块的某些部分，从而导致重复的容量未命中和颠簸。\n\n为了在分块计算期间最小化容量未命中，应该选择能使两个分块都放入缓存的最大的 $b$，即满足 $W(b) \\leq M$。这就得出了不等式\n$$\n2 b^{2} s \\;\\leq\\; M.\n$$\n对 $b$ 求解可得\n$$\nb^{2} \\;\\leq\\; \\frac{M}{2 s}\n\\qquad\\Longrightarrow\\qquad\nb \\;\\leq\\; \\sqrt{\\frac{M}{2 s}}.\n$$\n由于 $b$ 必须是正整数，在容量约束下使 $b$ 最大化的最佳选择 $b^{\\star}$ 是\n$$\nb^{\\star} \\;=\\; \\left\\lfloor \\sqrt{\\frac{M}{2 s}} \\right\\rfloor.\n$$\n该表达式确保了两个 $b \\times b$ 分块最多占用 $M$ 字节，因此在 LRU 策略下，它们可以在整个处理过程中被保留在缓存中，从而最小化分块转置中的容量未命中。",
                "answer": "$$\\boxed{\\left\\lfloor \\sqrt{\\frac{M}{2 s}} \\right\\rfloor}$$",
                "id": "3542785"
            }
        ]
    }