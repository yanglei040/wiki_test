{"hands_on_practices": [{"introduction": "对于任何可以近似为一系列恒定势阶的势垒，转移矩阵法是求解一维薛定谔方程的一种强大而精确的技术。这项练习 [@problem_id:3575889] 将指导你从第一性原理出发，推导并实现该方法。通过构建这一通用工具来分析复杂的势垒结构，你将加深对量子散射动力学基本原理的理解。", "problem": "考虑一个质量为 $m$ 的非相对论性粒子，从左侧入射到一个一维分段常数势 $V(x)$ 上。该势场由一系列有限层构成，每层具有恒定的势值和有限的宽度，并嵌入在左右两侧的半无限常势导区之间。您的目标是从不含时薛定谔方程出发，使用传输矩阵法计算粒子穿过该结构的透射概率。您必须推导、实现并使用此方法，而不依赖任何预先给出的公式。\n\n从一维空间中质量为 $m$、能量为 $E$ 的粒子的不含时薛定谔方程出发，\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2} + V(x)\\psi(x) = E \\psi(x),\n$$\n以及波函数 $\\psi(x)$ 及其空间导数 $d\\psi(x)/dx$ 在分段常数势的每个界面处都连续的要求。在势为常数的每个区域中，当能量 $E$ 高于局部势时，通解是右行和左行平面波的叠加；当 $E$ 低于局部势时，通解是衰减或增长的指数函数。仅根据这些事实，推导出一个逐层的线性表示，将左侧导区中的右行/左行波幅与右侧导区中的波幅联系起来。使用此表示来获得从左侧入射的波的透射振幅，进而得到透射概率。假设粒子质量 $m$ 在所有区域中都是恒定的。您必须仅从上述基本原理出发，论证您推导的每一步。\n\n采用以下在计算核物理中常见的物理一致单位约定：\n- 能量单位必须是兆电子伏特 (MeV)。\n- 长度单位必须是飞米 (fm)。\n- 质量单位必须是兆电子伏特/光速平方 (MeV/c$^2$)。\n- 使用常数 $\\hbar c = 197.3269804$ MeV·fm。\n- 在每个势为常数 $V$ 的均匀区域中，定义复波数\n$$\nk = \\frac{\\sqrt{2m\\,(E - V)}}{\\hbar c},\n$$\n其中平方根在复平面上取值，因此对于 E  V 的情况，波数变为纯虚数。", "solution": "该问题要求计算一个量子粒子穿过一维分段常数势垒结构的透射概率。所用方法为传输矩阵形式，它源自量子力学的基本原理，即不含时薛定谔方程以及波函数及其一阶导数的连续性。\n\n让我们从分析一个势为常数 $V_j$ 的均匀区域 $j$ 开始。一维不含时薛定谔方程为\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi(x)}{dx^2} + V_j\\psi(x) = E \\psi(x)\n$$\n这可以重写为\n$$\n\\frac{d^2\\psi(x)}{dx^2} + k_j^2\\psi(x) = 0\n$$\n其中 $k_j$ 是复波数，定义为\n$$\nk_j = \\frac{\\sqrt{2m(E - V_j)}}{\\hbar c}\n$$\n使用复数平方根可确保在能量 $E$ 小于势 $V_j$ 的势垒情况下，波数变为纯虚数 $k_j = i\\kappa_j$，其中衰减常数 $\\kappa_j = \\frac{\\sqrt{2m(V_j - E)}}{\\hbar c}$ 是一个实数且为正。\n\n粒子在任意点 $x$ 的状态可以由一个包含波函数 $\\psi(x)$ 及其空间导数 $\\psi'(x)$ 的双分量矢量完全描述：\n$$\n\\vec{\\Psi}(x) = \\begin{pmatrix} \\psi(x) \\\\ \\psi'(x) \\end{pmatrix}\n$$\n在区域 $j$ 中，薛定谔方程的通解可以表示为两个独立解的线性组合。一个方便的基是 $\\{\\cos(k_j(x-x_{\\text{ref}})), \\sin(k_j(x-x_{\\text{ref}}))\\}$。让我们将参考位置 $x_{\\text{ref}}$ 设为该区域的左边界，记为 $x_{j-1}$。\n$$\n\\psi(x) = C_1 \\cos(k_j(x-x_{j-1})) + C_2 \\sin(k_j(x-x_{j-1}))\n$$\n其导数为\n$$\n\\psi'(x) = k_j(-C_1 \\sin(k_j(x-x_{j-1})) + C_2 \\cos(k_j(x-x_{j-1})))\n$$\n在左边界 $x=x_{j-1}$ 处，我们有 $\\psi(x_{j-1}) = C_1$ 和 $\\psi'(x_{j-1}) = k_j C_2$。这使我们能够用 $x_{j-1}$ 处的状态矢量来表示系数 $C_1$ 和 $C_2$。将它们代回，我们就可以用 $x_{j-1}$ 处的状态矢量来表示区域内任何其他点 $x$ 处的状态矢量。对于宽度为 $L_j = x_j - x_{j-1}$ 的一层，右边界 $x_j$ 处的状态矢量与左边界 $x_{j-1}$ 处的状态矢量通过一个线性变换相关联：\n$$\n\\vec{\\Psi}(x_j) = P_j(L_j) \\vec{\\Psi}(x_{j-1})\n$$\n矩阵 $P_j(L_j)$ 是该层的传播矩阵：\n$$\nP_j(L_j) = \\begin{pmatrix} \\cos(k_j L_j)  \\frac{1}{k_j}\\sin(k_j L_j) \\\\ -k_j\\sin(k_j L_j)  \\cos(k_j L_j) \\end{pmatrix}\n$$\n通过复三角函数的性质，例如 $\\cos(i\\kappa_j L_j) = \\cosh(\\kappa_j L_j)$ 和 $\\sin(i\\kappa_j L_j)/ (i\\kappa_j) = \\sinh(\\kappa_j L_j)/\\kappa_j$，这种形式对于传播波（$E > V_j$，实数 $k_j$）和消逝波（$E  V_j$，虚数 $k_j$）都保持有效。\n\n值得注意的是，在 $E=V_j$ 的特殊情况下，波数 $k_j$ 为零。传播矩阵必须在 $k_j \\to 0$ 的极限下计算：\n$$\n\\lim_{k_j \\to 0} P_j(L_j) = \\begin{pmatrix} 1  L_j \\\\ 0  1 \\end{pmatrix}\n$$\n这避免了任何除以零的错误，并正确描述了动能为零时的自由粒子传播。\n\n完整的势结构由 $N$ 个层（从 $j=1$ 到 $j=N$）序列组成，位于一个半无限左导区（区域 0）和一个半无限右导区（区域 $N+1$）之间。设界面位于位置 $x_0, x_1, \\dots, x_N$。结构的总宽度为 $x_N - x_0 = \\sum_{j=1}^N L_j$。\n在两个相邻区域之间的每个界面 $x_j$ 处，边界条件要求 $\\psi(x)$ 和 $\\psi'(x)$ 都是连续的。这意味着状态矢量 $\\vec{\\Psi}(x)$ 在所有界面上都是连续的。\n因此，通过逐次应用每一层的传播矩阵，最终边界 $x_N$ 处的状态矢量可以与初始边界 $x_0$ 处的状态矢量关联起来：\n$$\n\\vec{\\Psi}(x_N) = P_N(L_N) \\vec{\\Psi}(x_{N-1}) = P_N(L_N) P_{N-1}(L_{N-1}) \\vec{\\Psi}(x_{N-2}) = \\dots\n$$\n$$\n\\vec{\\Psi}(x_N) = \\left( \\prod_{j=N}^{1} P_j(L_j) \\right) \\vec{\\Psi}(x_0)\n$$\n让我们将整个结构的总传播矩阵定义为 $M_{total} = P_N(L_N) P_{N-1}(L_{N-1}) \\cdots P_1(L_1)$。那么，\n$$\n\\vec{\\Psi}(x_N) = M_{total} \\vec{\\Psi}(x_0)\n$$\n如果没有内部层（$N=0$），$M_{total}$ 是 $2 \\times 2$ 的单位矩阵。\n\n接下来，我们将边界处的状态矢量 $\\vec{\\Psi}(x)$ 与导区中入射、反射和透射平面波的波幅联系起来。在一个导区（例如左导区，区域 0），波数为 $k_L$，波函数是右行（入射）波和左行（反射）波的叠加：\n$$\n\\psi_L(x) = A_L e^{ik_L(x - x_0)} + B_L e^{-ik_L(x - x_0)}\n$$\n在边界 $x=x_0$ 处，状态矢量为：\n$$\n\\vec{\\Psi}(x_0) = \\begin{pmatrix} \\psi_L(x_0) \\\\ \\psi'_L(x_0) \\end{pmatrix} = \\begin{pmatrix} A_L + B_L \\\\ ik_L(A_L - B_L) \\end{pmatrix} = \\begin{pmatrix} 1  1 \\\\ ik_L  -ik_L \\end{pmatrix} \\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix} = S_{k_L} \\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix}\n$$\n类似地，在波数为 $k_R$ 的右导区（区域 $N+1$）中，波函数为：\n$$\n\\psi_R(x) = A_R e^{ik_R(x - x_N)} + B_R e^{-ik_R(x - x_N)}\n$$\n在边界 $x=x_N$ 处，状态矢量为：\n$$\n\\vec{\\Psi}(x_N) = S_{k_R} \\begin{pmatrix} A_R \\\\ B_R \\end{pmatrix}\n$$\n矩阵 $S_k$ 的逆矩阵为 $S_k^{-1} = \\frac{1}{2}\\begin{pmatrix} 1  1/(ik) \\\\ 1  -1/(ik) \\end{pmatrix}$。\n\n结合这些关系，我们可以在左右导区中的波幅系数之间建立联系：\n$$\nS_{k_R} \\begin{pmatrix} A_R \\\\ B_R \\end{pmatrix} = \\vec{\\Psi}(x_N) = M_{total} \\vec{\\Psi}(x_0) = M_{total} S_{k_L} \\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix}\n$$\n这就得到了散射矩阵关系。然而，传输矩阵形式是将一侧的波幅与另一侧的波幅联系起来。为了得到满足 $\\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix} = \\mathcal{M} \\begin{pmatrix} A_R \\\\ B_R \\end{pmatrix}$ 的传输矩阵 $\\mathcal{M}$，我们重新整理方程：\n$$\n\\begin{pmatrix} A_L \\\\ B_L \\end{pmatrix} = S_{k_L}^{-1} M_{total}^{-1} S_{k_R} \\begin{pmatrix} A_R \\\\ B_R \\end{pmatrix}\n$$\n因此，波幅传输矩阵为 $\\mathcal{M} = S_{k_L}^{-1} M_{total}^{-1} S_{k_R}$。\n每个传播矩阵 $P_j$ 的行列式为 $\\det(P_j) = \\cos^2(k_jL_j) - (-k_j\\sin(k_jL_j))(\\frac{1}{k_j}\\sin(k_jL_j)) = 1$。因此，$\\det(M_{total})=1$，其逆矩阵很简单：如果 $M_{total} = \\begin{pmatrix} m_{11}  m_{12} \\\\ m_{21}  m_{22} \\end{pmatrix}$，那么 $M_{total}^{-1} = \\begin{pmatrix} m_{22}  -m_{12} \\\\ -m_{21}  m_{11} \\end{pmatrix}$。\n\n为了求得透射概率，我们考虑一个从左侧入射的粒子。这种情况对应于将从右导区入射的波的振幅设为零，即 $B_R=0$。不失一般性，我们可以将从左侧入射的波的振幅设为单位 1，即 $A_L=1$。\n传输矩阵方程变为：\n$$\n\\begin{pmatrix} 1 \\\\ B_L \\end{pmatrix} = \\mathcal{M} \\begin{pmatrix} A_R \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\mathcal{M}_{11} A_R \\\\ \\mathcal{M}_{21} A_R \\end{pmatrix}\n$$\n从第一行，我们得到透射振幅 $t \\equiv A_R = 1/\\mathcal{M}_{11}$。\n透射概率 $T$ 是透射概率流密度与入射概率流密度之比。流密度为 $J = \\frac{\\hbar}{2mi}(\\psi^*\\psi' - \\psi(\\psi')^*)$。对于一个波数为实数 $k$ 的平面波 $\\psi(x)=Ae^{ikx}$，有 $J = |A|^2 \\frac{\\hbar k}{m}$。\n$$\nT = \\frac{J_{trans}}{J_{inc}} = \\frac{|A_R|^2 (\\hbar k_R/m)}{|A_L|^2 (\\hbar k_L/m)} = \\frac{k_R}{k_L}|t|^2\n$$\n代入 $t = 1/\\mathcal{M}_{11}$，得到透射概率的最终表达式：\n$$\nT = \\frac{k_R}{k_L} \\frac{1}{|\\mathcal{M}_{11}|^2}\n$$\n问题陈述中说明了 $E>V_L$ 且 $E>V_R$，因此 $k_L$ 和 $k_R$ 总是实数且为正。$\\mathcal{M}_{11}$ 项可以通过执行矩阵乘法 $\\mathcal{M} = S_{k_L}^{-1} M_{total}^{-1} S_{k_R}$ 来计算，结果为：\n$$\n\\mathcal{M}_{11} = \\frac{1}{2} \\left( m_{22} - i k_R m_{12} + i \\frac{m_{21}}{k_L} + \\frac{k_R}{k_L} m_{11} \\right)\n$$\n推导至此完成。算法是首先通过乘以每一层的矩阵来计算总传播矩阵 $M_{total}$，然后使用其元素计算 $\\mathcal{M}_{11}$，最后计算透射概率 $T$。", "answer": "```python\nimport numpy as np\nimport cmath\n\ndef solve():\n    \"\"\"\n    Solves for the transmission probability using the transfer matrix method.\n    \"\"\"\n    # Physical constants\n    HBARC = 197.3269804  # MeV·fm\n    M_PARTICLE = 938.2720813  # MeV/c^2\n    \n    # Pre-calculated constant for wave number calculation\n    K_SQR_COEFF = 2 * M_PARTICLE / (HBARC**2)\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Test case A\n        {\n            \"E\": 10.0, \"V_L\": 0.0, \"V_R\": 0.0,\n            \"layers\": [(20.0, 5.0)]\n        },\n        # Test case B\n        {\n            \"E\": 30.0, \"V_L\": 0.0, \"V_R\": 0.0,\n            \"layers\": [(20.0, 5.0)]\n        },\n        # Test case C\n        {\n            \"E\": 5.0, \"V_L\": 0.0, \"V_R\": 0.0,\n            \"layers\": [(25.0, 2.0), (0.0, 6.4), (25.0, 2.0)]\n        },\n        # Test case D\n        {\n            \"E\": 10.0, \"V_L\": 0.0, \"V_R\": 0.0,\n            \"layers\": []\n        }\n    ]\n\n    results = []\n\n    def get_transmission(E, V_L, layers, V_R):\n        \"\"\"\n        Calculates the transmission probability for a single potential configuration.\n        \"\"\"\n        # Threshold for handling k=0 case\n        k_epsilon = 1e-9\n\n        # Calculate wave numbers for leads\n        k_L = cmath.sqrt(K_SQR_COEFF * (E - V_L))\n        k_R = cmath.sqrt(K_SQR_COEFF * (E - V_R))\n\n        # Initialize total propagation matrix as identity\n        M_total = np.identity(2, dtype=complex)\n\n        # The structure is V_L | layer_1 | ... | layer_N | V_R\n        # The total propagation matrix M_total is P_N * P_{N-1} * ... * P_1\n        # We build it by iterating through layers and right-multiplying.\n        \n        # We build the product M_total = P_N * ... * P_1.\n        # This can be done by iterating from j=1 to N and M_new = P_j * M_old.\n        # However, the standard definition is M_total relates psi(x_N) to psi(x_0).\n        # psi(x_N) = P_N * ... * P_1 * psi(x_0).\n        # We can compute this product by iterating from N down to 1.\n        # M = I; for j=N..1: M = M @ P_j\n        # Or, M = I; for j=1..N: M = P_j @ M. This yield P_N @ ... @ P_1.\n        \n        # Let's iterate layers from left to right as given.\n        # Total matrix M = P_N * P_{N-1} * ... * P_1\n        # Loop j=1...N: compute P_j, then M_total = P_j @ M_total\n        # The solution text states M_total = P_N * ... * P_1\n        # To get this, if M is initialized to identity, we need to do M_new = P_j @ M_old\n        # where P_j corresponds to layer j.\n        # With layers = [L1, L2, ..., LN], the loop builds P_N @ ... @ P_2 @ P_1\n        temp_M = np.identity(2, dtype=complex)\n        for V_j, L_j in layers:\n            # Calculate wave number k_j in the layer\n            k_j = cmath.sqrt(K_SQR_COEFF * (E - V_j))\n\n            # Form the propagation matrix P_j for the layer\n            if abs(k_j)  k_epsilon:\n                # Limit case for k -> 0\n                P_j = np.array([[1.0, L_j],\n                                [0.0, 1.0]], dtype=complex)\n            else:\n                cos_kl = cmath.cos(k_j * L_j)\n                sin_kl = cmath.sin(k_j * L_j)\n                P_j = np.array([[cos_kl, sin_kl / k_j],\n                                [-k_j * sin_kl, cos_kl]], dtype=complex)\n            \n            temp_M = P_j @ temp_M\n        \n        M_total = temp_M\n\n\n        # Extract elements of the total propagation matrix M_total\n        # Note: The solution text's formula for M_script_11 uses the elements of M_total_inv.\n        # Let M_total_inv = [[m_inv_11, m_inv_12], [m_inv_21, m_inv_22]].\n        # Since det(M_total)=1, m_inv_11=m22, m_inv_12=-m12, etc.\n        # M_script_11 = 0.5 * (m_inv_11 + m_inv_21/(1j*k_L) + m_inv_12*1j*k_R + (m_inv_22/(1j*k_L))*1j*k_R)\n        # The formula in the solution text seems to use M_total, not its inverse:\n        # M_script_11 = 0.5 * ( m22 - i k_R m12 + i m21/k_L + k_R/k_L m11 )\n        # This corresponds to M_script = S_L^-1 * M_total * S_R\n        # The derivation shows M_script = S_L^-1 * M_total_inv * S_R\n        # Let's use the derivation:\n        M_total_inv = np.linalg.inv(M_total)\n        m_inv_11, m_inv_12 = M_total_inv[0, 0], M_total_inv[0, 1]\n        m_inv_21, m_inv_22 = M_total_inv[1, 0], M_total_inv[1, 1]\n\n        M_script_11 = 0.5 * (m_inv_11 + m_inv_21 / (1j * k_L) + m_inv_12 * (1j * k_R) + m_inv_22 * (k_R / k_L))\n        \n        # Transmission probability T = (k_R/k_L) / |M_script_11|^2\n        # Since k_L, k_R are real as per problem statement E>V_L, E>V_R\n        if abs(M_script_11)  1e-12: # Avoid division by zero\n            T = 1.0 # Resonant transmission\n        else:\n            T = (k_R.real / k_L.real) / abs(M_script_11)**2\n        \n        return T\n\n    # Correction: The logic in the original code for building M_total and the formula for M_script_11 were inconsistent.\n    # The solution states `M_total = P_N * ... * P_1`. The python code with `M_total = P_j @ M_total` does this correctly.\n    # The solution's final formula for M_script_11 is in terms of `m_ij` which are elements of `M_total`, but it arises from `M_total_inv`.\n    # Let's re-verify the formula `M_script_11 = 0.5 * ( m22 + 1j*m21/k_L - 1j*k_R*m12 + m11*k_R/k_L )`.\n    # This formula is correct if m_ij are from M_total_inv.\n    # M_total_inv = [[m22, -m12], [-m21, m11]].\n    # Substituting this into the M_script_11 formula from the derivation gives the formula above.\n    # So, the original code had the wrong formula for M_script_11.\n    # I will use the one derived from M_total_inv.\n    # The original python code has been rewritten to be consistent with the derivation.\n\n    for case in test_cases:\n        E, V_L, layers, V_R = case[\"E\"], case[\"V_L\"], case[\"layers\"], case[\"V_R\"]\n        \n        k_L = cmath.sqrt(K_SQR_COEFF * (E - V_L))\n        k_R = cmath.sqrt(K_SQR_COEFF * (E - V_R))\n        \n        M_total = np.identity(2, dtype=complex)\n        for V_j, L_j in layers:\n            k_j = cmath.sqrt(K_SQR_COEFF * (E - V_j))\n            \n            if abs(k_j)  k_epsilon:\n                P_j = np.array([[1.0, L_j], [0.0, 1.0]], dtype=complex)\n            else:\n                cos_kl = cmath.cos(k_j * L_j)\n                sin_kl = cmath.sin(k_j * L_j)\n                P_j = np.array([[cos_kl, sin_kl / k_j], [-k_j * sin_kl, cos_kl]], dtype=complex)\n            \n            M_total = P_j @ M_total\n        \n        m11, m12, m21, m22 = M_total.flatten()\n        \n        # Using M_total_inv from derivation. M_inv_11=m22, M_inv_12=-m12, etc.\n        M_script_11 = 0.5 * (m22 + (-m21) / (1j * k_L) + (-m12) * (1j * k_R) + m11 * (k_R / k_L))\n        \n        T = (k_R.real / k_L.real) / abs(M_script_11)**2\n        results.append(T)\n\n    output_str = f\"[{','.join([f'{r:.8f}' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3575889"}, {"introduction": "虽然精确方法很有价值，但许多现实世界中的势是平滑的，不易于用简单的分段函数近似。这项练习 [@problem_id:3575931] 介绍了半经典的 WKB 近似法，这是估算隧穿概率的基石。通过将 WKB 的结果与 Pöschl-Teller 势的数值精确解进行比较，我们将探索该近似的准确性及其在不同物理情境下的失效边界。", "problem": "考虑一个由不含时薛定谔方程描述的一维核散射问题，\n$$\n-\\frac{\\hbar^2}{2 m}\\,\\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n其势垒为一个局域的 Pöschl–Teller 型势，\n$$\nV(x) = \\frac{V_0}{\\cosh^2\\!\\left(\\frac{x}{a}\\right)} = V_0\\,\\operatorname{sech}^2\\!\\left(\\frac{x}{a}\\right),\n$$\n其中 $V_0$ 是势垒高度，$a$ 是势垒宽度参数，且 $\\operatorname{sech}(u) = 1/\\cosh(u)$。假设能量 $E$ 严格低于势垒顶端，$0  E  V_0$，从而发生量子隧穿。使用自然单位制，其中光速 $c=1$，转换常数 $\\hbar c = 197.3269804\\,\\text{MeV}\\,\\text{fm}$。设质量为核子质量 $m = 939.565\\,\\text{MeV}$（即能量单位下的 $m c^2$）。\n\n您的任务是，对于给定的参数集 $(V_0, a, E)$，用两种方法计算穿过势垒的透射概率 $T(E)$：\n\n1. 数值精确的透射概率 $T_{\\text{exact}}(E)$，通过求解薛定谔方程得到。该求解过程需满足散射边界条件，即与从 $x\\to -\\infty$ 入射的平面波和朝向 $x\\to +\\infty$ 出射的透射波相一致。使用一个大但有限的区间 $[-L, L]$（其中 $L = 12 a$）来近似 $V(x) \\approx 0$ 的渐近区域，并施加渐近平面波边界条件。使用一种严格从薛定谔方程及其渐近解推导出的方法计算透射概率，该方法不依赖于拟合参数或经验公式。\n\n2. 半经典的 Wentzel–Kramers–Brillouin (WKB) 近似 $T_{\\text{WKB}}(E)$，它基于经典转折点 $x_1  0  x_2$（由 $V(x_i) = E$ 定义）之间的势垒下作用量积分。对于上述势函数，转折点满足 $\\cosh^2\\!\\left(\\frac{x_i}{a}\\right) = \\frac{V_0}{E}$，因此可以用反双曲余弦函数表示。请数值实现作用量积分，并用它来仅估计经典禁区内的隧穿概率。\n\n所有量必须使用指定的单位处理：能量单位为 $\\text{MeV}$，长度单位为 $\\text{fm}$。透射概率是无量纲的，必须以小数形式返回。\n\n请从第一性原理出发设计您的算法。从薛定谔方程和散射态的定义开始，构建获得 $T_{\\text{exact}}(E)$ 和 $T_{\\text{WKB}}(E)$ 所需的数值过程，不要引入问题描述中任何现成的快捷公式。通过检查 $E  V_0$ 并选择合适的 $L$ 以确保 $V(\\pm L)$相对于 $V_0$ 可以忽略不计，来保证科学上的真实性。\n\n将您的求解方案实现为一个完整的、可运行的程序，该程序能为以下测试参数集生成结果。这些参数的选择旨在探索不同的情况，包括“理想路径”、接近势垒顶部的行为（半经典近似可能在此失效）以及薄势垒的边缘情况：\n\n- 测试用例 1：$V_0 = 25\\,\\text{MeV}$，$a = 5\\,\\text{fm}$，$E = 5\\,\\text{MeV}$。\n- 测试用例 2：$V_0 = 25\\,\\text{MeV}$，$a = 1\\,\\text{fm}$，$E = 24.75\\,\\text{MeV}$。\n- 测试用例 3：$V_0 = 25\\,\\text{MeV}$，$a = 0.8\\,\\text{fm}$，$E = 12.5\\,\\text{MeV}$。\n- 测试用例 4：$V_0 = 25\\,\\text{MeV}$，$a = 0.5\\,\\text{fm}$，$E = 20\\,\\text{MeV}$。\n\n对于每个测试用例，计算并返回列表 $[T_{\\text{exact}}(E), T_{\\text{WKB}}(E), \\Delta(E)]$，其中相对误差 $\\Delta(E)$ 定义为\n$$\n\\Delta(E) = \\frac{\\left|T_{\\text{WKB}}(E) - T_{\\text{exact}}(E)\\right|}{T_{\\text{exact}}(E)}.\n$$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身也是一个包含针对一个测试用例的三个浮点数的逗号分隔列表，例如，\n$$\n\\text{[ [}T_{\\text{exact},1}\\text{,}T_{\\text{WKB},1}\\text{,}\\Delta_1\\text{], [}T_{\\text{exact},2}\\text{,}T_{\\text{WKB},2}\\text{,}\\Delta_2\\text{], \\ldots ]}\n$$\n所有数值条目必须作为 Python 浮点数返回。最终输出中不应打印任何单位，因为透射概率和相对误差是无量纲的小数。", "solution": "该问题要求计算粒子穿过一维 Pöschl–Teller 势垒的透射概率 $T(E)$。我们必须使用两种不同的方法计算这个量：一种是求解不含时薛定谔方程 (TISE) 的数值精确解，另一种是半经典的 Wentzel–Kramers–Brillouin (WKB) 近似。\n\n控制方程是 TISE：\n$$\n-\\frac{\\hbar^2}{2 m}\\,\\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n势垒由以下公式给出：\n$$\nV(x) = V_0\\,\\operatorname{sech}^2\\!\\left(\\frac{x}{a}\\right)\n$$\n我们已知常数 $\\hbar c = 197.3269804\\,\\text{MeV}\\,\\text{fm}$ 和核子的质能 $mc^2 = 939.565\\,\\text{MeV}$。TISE 可以重写为：\n$$\n\\frac{d^2\\psi(x)}{dx^2} = -\\frac{2m(E - V(x))}{\\hbar^2}\\,\\psi(x) = -\\frac{2(mc^2)(E - V(x))}{(\\hbar c)^2}\\,\\psi(x)\n$$\n项 $\\frac{(\\hbar c)^2}{2(mc^2)}$ 是一个常数，单位为 $\\text{MeV}\\,\\text{fm}^2$，我们将其记为 $\\mathcal{C} = \\frac{(\\hbar c)^2}{2(mc^2)} \\approx 20.7212\\,\\text{MeV}\\,\\text{fm}^2$。方程变为：\n$$\n\\frac{d^2\\psi(x)}{dx^2} = -\\frac{E - V(x)}{\\mathcal{C}}\\,\\psi(x)\n$$\n在渐近区域 $x \\to \\pm\\infty$ 中，势 $V(x) \\to 0$。TISE 的解是平面波 $\\psi(x) \\propto e^{\\pm i k_0 x}$，其中波数 $k_0 = \\sqrt{E/\\mathcal{C}}$。\n\n对于粒子从左侧 ($x \\to -\\infty$) 入射的散射问题，波函数的渐近形式为：\n$$\n\\psi(x) = \\begin{cases} A e^{i k_0 x} + B e^{-i k_0 x}  x \\to -\\infty \\\\ C e^{i k_0 x}  x \\to +\\infty \\end{cases}\n$$\n这里，$A$ 是入射波的振幅，$B$ 是反射波的振幅，$C$ 是透射波的振幅。根据定义，透射概率为 $T = \\frac{|C|^2}{|A|^2}$。\n\n### 1. 数值精确的透射概率 $T_{\\text{exact}}(E)$\n\n为了求得 $T_{\\text{exact}}(E)$，我们数值求解 TISE。问题指定了一个有限区间 $[-L, L]$，其中 $L=12a$，这个区间足够大，可以认为 $V(\\pm L) \\approx 0$。因此，我们可以在 $x = \\pm L$ 处应用渐近边界条件。\n\n我们采用一种数值积分方法，可以看作是“打靶法”的一种形式。我们从右边界 $x=L$ 开始，将 TISE 向后积分到 $x=-L$。\n在右边界 $x=L$ 处，我们假设只有一个纯粹的透射波。不失一般性，我们可以将其振幅设为 $C=1$。因此，在 $x=L$ 处的边界条件是：\n$$\n\\psi(L) = e^{i k_0 L} \\quad \\text{and} \\quad \\psi'(L) = i k_0 e^{i k_0 L}\n$$\n为了进行数值积分，我们将二阶 TISE 转换为一个由两个一阶常微分方程 (ODE) 组成的系统。设状态向量为 $\\mathbf{y}(x) = [\\psi(x), \\psi'(x)]^T$。该系统为：\n$$\n\\frac{d\\mathbf{y}}{dx} = \\frac{d}{dx} \\begin{pmatrix} \\psi(x) \\\\ \\psi'(x) \\end{pmatrix} = \\begin{pmatrix} \\psi'(x) \\\\ -\\frac{E - V(x)}{\\mathcal{C}}\\,\\psi(x) \\end{pmatrix}\n$$\n我们以初始条件 $\\mathbf{y}(L) = [e^{i k_0 L}, i k_0 e^{i k_0 L}]^T$ 从初始点 $x=L$ 将该系统向后积分至 $x=-L$。这将得到数值解 $\\mathbf{y}_{num}(-L) = [\\psi_{num}(-L), \\psi'_{num}(-L)]^T$。\n\n在 $x=-L$ 处，波函数必须匹配左侧区域的一般渐近形式：\n$$\n\\psi_{num}(-L) = A e^{-i k_0 L} + B e^{i k_0 L}\n$$\n$$\n\\psi'_{num}(-L) = i k_0 ( A e^{-i k_0 L} - B e^{i k_0 L} )\n$$\n这是一个关于两个未知复振幅 $A$ 和 $B$ 的线性方程组。我们关心的是 $A$。我们可以通过将第一个方程与第二个方程乘以 $\\frac{1}{ik_0}$ 后的结果相加来求解 $A$：\n$$\n\\psi_{num}(-L) + \\frac{\\psi'_{num}(-L)}{i k_0} = 2A e^{-i k_0 L}\n$$\n这给出了入射波的振幅：\n$$\nA = \\frac{1}{2} \\left( \\psi_{num}(-L) - \\frac{i}{k_0} \\psi'_{num}(-L) \\right) e^{i k_0 L}\n$$\n由于我们开始时假设透射振幅 $C=1$，因此透射概率为：\n$$\nT_{\\text{exact}}(E) = \\frac{|C|^2}{|A|^2} = \\frac{1}{|A|^2}\n$$\n此过程将使用数值 ODE 求解器实现。\n\n### 2. 半经典 WKB 近似 $T_{\\text{WKB}}(E)$\n\nWKB 近似为隧穿概率提供了一个半经典的估计。对于能量 $E  V_0$，势垒下的区域是经典禁区。在此近似下，透射概率由以下公式给出：\n$$\nT_{\\text{WKB}}(E) \\approx e^{-2\\gamma}\n$$\n其中 $\\gamma$ 是 Gamow 因子，定义为（虚）波数的模在经典禁区 $[x_1, x_2]$ 上的积分：\n$$\n\\gamma = \\int_{x_1}^{x_2} \\sqrt{\\frac{2m(V(x) - E)}{\\hbar^2}}\\,dx = \\int_{x_1}^{x_2} \\sqrt{\\frac{V(x) - E}{\\mathcal{C}}}\\,dx\n$$\n经典转折点 $x_1$ 和 $x_2$ 是粒子动能为零的位置，即 $V(x) = E$。对于 Pöschl–Teller 势：\n$$\nV_0\\,\\operatorname{sech}^2\\!\\left(\\frac{x_i}{a}\\right) = E \\implies \\cosh^2\\!\\left(\\frac{x_i}{a}\\right) = \\frac{V_0}{E}\n$$\n求解 $x_i$ 得到对称的转折点：\n$$\nx_{1,2} = \\mp a\\,\\operatorname{arccosh}\\left(\\sqrt{\\frac{V_0}{E}}\\right)\n$$\n问题要求对 $\\gamma$ 的作用量积分进行数值计算。我们将定义被积函数 $f(x) = \\sqrt{(V(x) - E)/\\mathcal{C}}$，并使用数值求积程序来计算 $\\gamma = \\int_{x_1}^{x_2} f(x) dx$。然后根据 $T_{\\text{WKB}} = e^{-2\\gamma}$ 计算 WKB 透射概率。\n\n### 3. 相对误差\n\n最后，对于每个参数集，WKB 近似相对于数值精确结果的相对误差 $\\Delta(E)$ 计算如下：\n$$\n\\Delta(E) = \\frac{\\left|T_{\\text{WKB}}(E) - T_{\\text{exact}}(E)\\right|}{T_{\\text{exact}}(E)}\n$$\n\n这些步骤构成了一个完整的、基于第一性原理的数值框架，用于解决所述问题。这些算法将使用 Python 的 `numpy` 和 `scipy` 库进行数值计算来实现。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\nfrom typing import List, Tuple\n\ndef solve():\n    \"\"\"\n    Computes the transmission probability through a Pöschl-Teller barrier\n    using a numerically exact method and the WKB approximation.\n    \"\"\"\n    # Physical constants and parameters\n    HBARC = 197.3269804  # MeV fm\n    M_NUCLEON_C2 = 939.565  # MeV\n    # Pre-calculated constant hbar^2 / (2m) = (hbar*c)^2 / (2*m*c^2)\n    HBARC2_OVER_2M = HBARC**2 / (2 * M_NUCLEON_C2)\n\n    # Test cases: (V0 in MeV, a in fm, E in MeV)\n    test_cases = [\n        (25.0, 5.0, 5.0),\n        (25.0, 1.0, 24.75),\n        (25.0, 0.8, 12.5),\n        (25.0, 0.5, 20.0),\n    ]\n\n    # Helper function for the potential\n    def V_pt(x: float, V0: float, a: float) -> float:\n        \"\"\"Pöschl-Teller potential.\"\"\"\n        return V0 / np.cosh(x / a)**2\n\n    results = []\n    for V0, a, E in test_cases:\n        # --- 1. Numerically Exact Transmission Probability T_exact ---\n        \n        # Wave number in the asymptotic region (x -> +/- infinity)\n        k0 = np.sqrt(E / HBARC2_OVER_2M)\n        \n        # Integration domain [-L, L]\n        L = 12.0 * a\n        \n        # Define the system of 1st order ODEs for the Schrödinger equation\n        # y = [psi, d(psi)/dx]\n        def schrodinger_ode(t: float, y: np.ndarray) -> np.ndarray:\n            psi, dpsi_dx = y\n            d2psi_dx2 = -(E - V_pt(t, V0, a)) * psi / HBARC2_OVER_2M\n            return np.array([dpsi_dx, d2psi_dx2], dtype=np.complex128)\n            \n        # Initial conditions at x = L (right boundary), assuming purely transmitted wave C*exp(i*k0*x) with C=1\n        psi_L = np.exp(1j * k0 * L)\n        dpsi_dx_L = 1j * k0 * np.exp(1j * k0 * L)\n        y_L = np.array([psi_L, dpsi_dx_L], dtype=np.complex128)\n        \n        # Numerically integrate backwards from L to -L\n        # Using a high-precision solver (DOP853) is beneficial for oscillatory solutions.\n        sol = solve_ivp(\n            schrodinger_ode,\n            [L, -L],\n            y_L,\n            method='DOP853',\n            atol=1e-12,\n            rtol=1e-12)\n            \n        # Extract solution at x = -L\n        psi_minus_L, dpsi_dx_minus_L = sol.y[:, -1]\n        \n        # At x = -L, the solution is a superposition of incoming (A) and reflected (B) waves:\n        # psi(-L) = A*exp(-i*k0*L) + B*exp(i*k0*L)\n        # psi'(-L) = i*k0*(A*exp(-i*k0*L) - B*exp(i*k0*L))\n        # From these, solve for the incoming amplitude A\n        A_inv_term1 = psi_minus_L\n        A_inv_term2 = dpsi_dx_minus_L / (1j * k0)\n        A = 0.5 * (A_inv_term1 + A_inv_term2) * np.exp(1j * k0 * L)\n        \n        # Transmission probability T = |C|^2 / |A|^2. Since we set C=1, T = 1/|A|^2.\n        T_exact = 1.0 / np.abs(A)**2 if np.abs(A) > 1e-15 else 0.0\n\n        # --- 2. WKB Approximation T_wkb ---\n        \n        T_wkb = 0.0\n        # WKB approximation is valid for E  V0\n        if E  V0:\n            # Classical turning points V(x) = E\n            x2 = a * np.arccosh(np.sqrt(V0 / E))\n            x1 = -x2\n            \n            # Integrand for the Gamow factor gamma\n            def wkb_integrand(x: float) -> float:\n                integrand_val = (V_pt(x, V0, a) - E) / HBARC2_OVER_2M\n                return np.sqrt(integrand_val) if integrand_val > 0 else 0.0\n                \n            # Numerically integrate to find gamma\n            gamma, _ = quad(wkb_integrand, x1, x2, epsabs=1e-12, epsrel=1e-12)\n            \n            # WKB transmission probability\n            T_wkb = np.exp(-2.0 * gamma)\n        \n        # --- 3. Relative Error ---\n        \n        delta = np.abs(T_wkb - T_exact) / T_exact if T_exact > 1e-30 else 0.0\n        \n        results.append([T_exact, T_wkb, delta])\n\n    # Format the final output as a string representing a list of lists.\n    # e.g., [[val1, val2, val3], [val4, val5, val6]]\n    output_str = \"[\" + \", \".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "3575931"}, {"introduction": "最后的这项练习 [@problem_id:3575895] 将我们从理论工具转向一个完整的真实核现象的计算模型：α 衰变。我们将应用 WKB 方法计算 α 放射体的半衰期，并且至关重要的是，使用蒙特卡洛模拟来将核势中的不确定性传播到最终的预测结果中。这个练习突出了如何建立预测模型并评估其置信水平，这是计算物理学中的一项关键技能。", "problem": "您将实现一个α衰变的计算模型，该模型将衰变半衰期计算为内禀预形成因子和量子力学势垒穿透因子的乘积，其中有效相互作用中的不确定度通过蒙特卡洛抽样传播到可观测量上。该模型的建模假设和数值任务基于不含时薛定谔方程和半经典的WKB（Wentzel–Kramers–Brillouin）近似。\n\n起点和建模假设：\n- 以α粒子在子核场中径向运动（约化质量为$\\mu$）的不含时薛定谔方程为基本依据。在半经典的WKB（Wentzel–Brillouin–Kramers）近似中，通过一维有效势垒的隧穿概率由作用量积分得到，该积分横跨由转折点定义的经典禁戒区，在转折点处势能等于动能。\n- 将总势建模为$V(r) = V_{\\mathrm{N}}(r) + V_{\\mathrm{C}}(r)$，并设轨道角动量为零。核势项为伍兹-撒克逊（Woods–Saxon）形式$V_{\\mathrm{N}}(r) = -V_{0}/\\left(1+\\exp\\!\\left(\\frac{r-R}{a}\\right)\\right)$，其中半径$R = r_{0} A_{\\mathrm{d}}^{1/3}$；库仑项为半径为$R_{\\mathrm{C}} = r_{0\\mathrm{C}} A_{\\mathrm{d}}^{1/3}$的均匀带电球体的势，即当$r \\ge R_{\\mathrm{C}}$时，$V_{\\mathrm{C}}(r)= Z_{\\mathrm{d}} Z_{\\alpha} e^{2}/r$；当$r  R_{\\mathrm{C}}$时，$V_{\\mathrm{C}}(r) = \\frac{Z_{\\mathrm{d}} Z_{\\alpha} e^2}{2 R_{\\mathrm{C}}} \\left(3 - \\frac{r^2}{R_{\\mathrm{C}}^2}\\right)$。\n- 衰变常数$\\lambda$被建模为$\\lambda=P_{\\alpha} \\nu P$，其中$P_{\\alpha}$是预形成因子，$\\nu = v_{\\mathrm{internal}}/(2R)$是撞击频率，$P$是WKB隧穿概率。将内部速度$v_{\\mathrm{internal}}$建模为α粒子在势阱中具有动能$Q$时的速度。\n- 所有不确定的势参数($V_0, a, r_0, r_{0\\mathrm{C}}$)都建模为独立的高斯随机变量，具有给定的均值和标准差。\n- 最终目标量是半衰期对数$y=\\log_{10}(T_{1/2}/\\mathrm{s})$，其中$T_{1/2}=\\ln(2)/\\lambda$。\n\n您的数值任务是，对于以下三个测试用例中的每一个，执行$N=400$个样本的蒙特卡洛模拟：\n1.  对于每个蒙特卡洛样本，从其指定的高斯分布中随机抽取势参数。任何非正的抽样值都必须被舍弃并重新抽样。\n2.  对于每个抽样势，数值求解方程$V(r)-Q=0$的两个经典转折点$r_1, r_2$。必须使用一个鲁棒的求根算法。任何未能找到恰好两个转折点的样本都将被舍弃。\n3.  在$r_1$和$r_2$之间数值积分，以计算WKB作用量$K$。\n4.  计算$y=\\log_{10}(T_{1/2}/\\mathrm{s})$。为避免数值下溢，应使用对数形式的半衰期公式。\n5.  在收集了所有有效样本的$y$值后，计算它们的样本均值和样本标准差（贝塞尔校正）。\n\n使用以下物理常数：$\\hbar c=197.3269804\\,\\mathrm{MeV\\,fm}$，$e^2=1.439964\\,\\mathrm{MeV\\,fm}$，原子质量单位$m_u c^2=931.49410242\\,\\mathrm{MeV}$，α粒子质量$m_{\\alpha}c^2=3727.379378\\,\\mathrm{MeV}$，子核电荷数$Z_{\\alpha}=2$，光速$c=2.99792458 \\times 10^{23}\\,\\mathrm{fm/s}$。设随机种子为$12345$以保证可复现性。\n\n测试用例：\n1.  母核$^{238}\\mathrm{Pu} \\to ^{234}\\mathrm{U} + \\alpha$：$Z_{\\mathrm{d}}=92$, $A_{\\mathrm{d}}=234$, $Q=5.593\\,\\mathrm{MeV}$, $P_{\\alpha}=0.20$。势参数：$r_0=(1.20\\pm0.05)\\,\\mathrm{fm}$, $a=(0.62\\pm0.05)\\,\\mathrm{fm}$, $V_0=(120\\pm5)\\,\\mathrm{MeV}$, $r_{0\\mathrm{C}}=(1.20\\pm0.02)\\,\\mathrm{fm}$。\n2.  母核$^{212}\\mathrm{Po} \\to ^{208}\\mathrm{Pb} + \\alpha$：$Z_{\\mathrm{d}}=82$, $A_{\\mathrm{d}}=208$, $Q=8.954\\,\\mathrm{MeV}$, $P_{\\alpha}=0.30$。势参数同上。\n3.  母核$^{232}\\mathrm{Th} \\to ^{228}\\mathrm{Ra} + \\alpha$：$Z_{\\mathrm{d}}=88$, $A_{\\mathrm{d}}=228$, $Q=4.082\\,\\mathrm{MeV}$, $P_{\\alpha}=0.15$。势参数同上。\n\n输出：您的程序必须生成一个包含六个浮点数的逗号分隔列表，并用方括号括起来。这六个数分别是三个测试用例的$(\\text{均值}_y, \\text{标准差}_y)$对。例如，$[\\text{mean}_1, \\text{std}_1, \\text{mean}_2, \\text{std}_2, \\text{mean}_3, \\text{std}_3]$。每个值必须格式化为保留三位小数的浮点数。", "solution": "该问题要求实现一个计算模型，用于计算α衰变半衰期$T_{1/2}$及其不确定度。该模型基于用于量子隧穿的半经典WKB（Wentzel–Kramers–Brillouin）近似。核势参数中的不确定度通过蒙特卡洛模拟传播到最终的可观测量$\\log_{10}(T_{1/2}/\\mathrm{s})$上。\n\n解决方案的结构如下：首先，我们定义物理模型，包括势、衰变率和半衰期。其次，我们详细说明实现此模型的数值方法，包括用于寻找转折点的求根方法和用于WKB作用量的数值积分。最后，我们描述用于不确定度量化的蒙特卡洛过程。\n\n**1. 物理模型**\n\nα衰变过程被建模为预形成的α粒子发生量子隧穿，穿过由子核产生的势垒。\n\n**1.1. 势垒**\nα粒子在距离子核中心$r$处的势能$V(r)$是吸引性核势$V_{\\mathrm{N}}(r)$和排斥性静电库仑势$V_{\\mathrm{C}}(r)$之和。我们只考虑球对称势（轨道角动量为零）。\n$$V(r) = V_{\\mathrm{N}}(r) + V_{\\mathrm{C}}(r)$$\n核势由伍兹-撒克逊（Woods-Saxon）形式建模：\n$$V_{\\mathrm{N}}(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R}{a}\\right)}$$\n其中$V_0$是势阱深度，$a$是弥散参数，$R$是核半径，由$R = r_0 A_{\\mathrm{d}}^{1/3}$给出，其中$r_0$是半径参数，$A_{\\mathrm{d}}$是子核的质量数。\n\n库仑势是半径为$R_{\\mathrm{C}} = r_{0\\mathrm{C}} A_{\\mathrm{d}}^{1/3}$的均匀带电球体的势。它有两种形式，取决于α粒子是否在子核电荷分布的内部或外部：\n$$V_{\\mathrm{C}}(r) = \\begin{cases} \\frac{Z_{\\mathrm{d}} Z_{\\alpha} e^2}{2 R_{\\mathrm{C}}} \\left(3 - \\frac{r^2}{R_{\\mathrm{C}}^2}\\right)  \\text{当 } r  R_{\\mathrm{C}} \\\\ \\frac{Z_{\\mathrm{d}} Z_{\\alpha} e^2}{r}  \\text{当 } r \\ge R_{\\mathrm{C}} \\end{cases}$$\n这里，$Z_{\\mathrm{d}}$和$Z_{\\alpha}=2$分别是子核和α粒子的原子序数，$e^2$是以$\\mathrm{MeV}\\cdot\\mathrm{fm}$为单位的元电荷平方。\n\n**1.2. 势垒穿透与WKB近似**\n假设α粒子具有明确的能量，即衰变Q值。经典禁戒区是势能$V(r)$超过总能量$Q$的区域。该区域由两个转折点$r_1$和$r_2$界定，这两个点由方程$V(r) = Q$定义。\n\n根据WKB近似，隧穿此势垒的概率$P$由下式给出：\n$$P = \\exp(-2K)$$\n其中$K$是伽莫夫因子（Gamow factor），是一个在经典禁戒区上的作用量积分：\n$$K = \\frac{1}{\\hbar c} \\int_{r_1}^{r_2} \\sqrt{2\\mu c^2 \\left(V(r) - Q\\right)} \\, dr$$\n在此表达式中，$\\mu$是α-子核体系的约化质量，$\\hbar c$是约化普朗克常数乘以光速，而$\\mu c^2$项代表以能量单位($\\mathrm{MeV}$)表示的约化质量。约化质量计算如下：\n$$\\mu c^2 = \\frac{(m_{\\alpha}c^2)(m_{\\mathrm{d}}c^2)}{m_{\\alpha}c^2 + m_{\\mathrm{d}}c^2}$$\n其中$m_{\\alpha}c^2$是α粒子的静止能量，$m_{\\mathrm{d}}c^2 \\approx A_{\\mathrm{d}} m_u c^2$是子核的近似静止能量，$m_u c^2$是原子质量单位的能量当量。\n\n**1.3. 衰变常数与半衰期**\n衰变常数$\\lambda$被建模为三个因子的乘积：\n$$\\lambda = P_{\\alpha} \\nu P$$\n其中$P_{\\alpha}$是预形成因子（在母核内形成α粒子的概率），$\\nu$是撞击频率（α粒子撞击势垒的速率），$P$是隧穿概率。\n\n撞击频率$\\nu$是根据α粒子在核内运动的简单经典图像估算的：\n$$\\nu = \\frac{v_{\\text{internal}}}{2R}$$\n其中$R = r_0 A_{\\mathrm{d}}^{1/3}$是核半径，$v_{\\text{internal}}$是α粒子内部速度。该速度由其动能估算，假定在势阱内部动能为$Q$：\n$$v_{\\text{internal}} = \\sqrt{\\frac{2Q}{\\mu}}$$\n要将单位转换为$\\mathrm{s}^{-1}$，我们使用光速$c$：\n$$\\nu = \\frac{c \\sqrt{2Q / (\\mu c^2)}}{2R}$$\n半衰期$T_{1/2}$与衰变常数的关系为：\n$$T_{1/2} = \\frac{\\ln 2}{\\lambda} = \\frac{\\ln 2}{P_{\\alpha} \\nu \\exp(-2K)}$$\n为避免$P$值极小而导致的数值下溢，我们使用半衰期的对数。目标量是$y = \\log_{10}(T_{1/2}/\\mathrm{s})$，其计算公式为：\n$$y = \\log_{10}(T_{1/2}) = \\frac{\\ln(T_{1/2})}{\\ln 10} = \\frac{1}{\\ln 10} \\left[ \\ln(\\ln 2) - \\ln(P_{\\alpha}) - \\ln(\\nu) + 2K \\right]$$\n根据输入的常数，$\\nu$的单位计算为$\\mathrm{s}^{-1}$，因此$T_{1/2}$自然以秒为单位获得。\n\n**2. 数值实现与蒙特卡洛模拟**\n\n势的模型参数（$V_0, a, r_0, r_{0\\mathrm{C}}$）并非精确已知。它们的不确定度通过将它们视为独立的高斯随机变量来建模。使用蒙特卡洛模拟将这些不确定度传播到最终的半衰期。\n\n对于每个测试案例的$N=400$个蒙特卡洛样本中的每一个：\n1.  **参数抽样**：从其指定的正态分布$\\mathcal{N}(\\bar{x}, \\sigma_x)$中抽取$V_0$, $a$, $r_0$, 和$r_{0\\mathrm{C}}$的值。任何非正的抽样值都将被舍弃并重新抽样，以确保物理上的合理性。\n2.  **转折点计算**：对于抽样得到的势，在区间$[10^{-3}, 200]\\,\\mathrm{fm}$内数值求解方程$f(r) = V(r) - Q = 0$的根。这通过首先扫描该区间以找到函数变号的子区间，然后使用鲁棒的求根算法（布伦特（Brent）方法）来精确定位根$r_1$和$r_2$来完成。如果没有找到恰好两个转折点，则该样本无效并被舍弃。\n3.  **WKB积分计算**：在找到的转折点$r_1$和$r_2$之间，数值计算伽莫夫因子$K$的积分。为此使用高质量的自适应求积程序以确保精度。\n4.  **半衰期计算**：使用计算出的$K$和抽样参数，计算撞击频率$\\nu$，然后使用对数公式计算$y = \\log_{10}(T_{1/2}/\\mathrm{s})$的值。\n5.  **数据聚合**：存储有效样本得到的$y$值。\n\n在处理完所有$N$个样本后，计算收集到的$y$值的样本均值和样本标准差（使用贝塞尔校正）。这两个统计量概括了半衰期对数的预测值和传播的不确定度。对指定的三个测试案例中的每一个都重复此整个过程。固定的随机种子确保了结果的可复现性。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to run the alpha decay simulation for the specified test cases.\n    \"\"\"\n    # Define physical constants as per the problem statement\n    HBARC = 197.3269804  # MeV*fm\n    E2 = 1.439964        # MeV*fm\n    C_LIGHT = 2.99792458e23  # fm/s\n    M_U_C2 = 931.49410242 # MeV\n    M_ALPHA_C2 = 3727.379378 # MeV\n    Z_ALPHA = 2.0\n    LN2 = np.log(2.0)\n    LN10 = np.log(10.0)\n\n    # Monte Carlo simulation parameters\n    N_SAMPLES = 400\n    RANDOM_SEED = 12345\n    \n    # Root finding parameters\n    R_MIN, R_MAX = 1e-3, 200.0\n    GRID_POINTS = 2000\n\n    # Define the test cases from the problem statement.\n    # Case 1: Pu-238, Case 2: Po-212, Case 3: Th-232\n    # Structure: (Zd, Ad, Q, Pa, r0_mean, r0_std, a_mean, a_std, V0_mean, V0_std, r0C_mean, r0C_std)\n    test_cases_params = [\n        (92.0, 234.0, 5.593, 0.20, 1.20, 0.05, 0.62, 0.05, 120.0, 5.0, 1.20, 0.02), # Pu-238 -> U-234\n        (82.0, 208.0, 8.954, 0.30, 1.20, 0.05, 0.62, 0.05, 120.0, 5.0, 1.20, 0.02), # Po-212 -> Pb-208\n        (88.0, 228.0, 4.082, 0.15, 1.20, 0.05, 0.62, 0.05, 120.0, 5.0, 1.20, 0.02), # Th-232 -> Ra-228\n    ]\n    # For cases 2 and 3, problem states \"势参数同上\" (potential parameters are the same as above).\n    # This means they share the same mean/std values.\n    # The structure above correctly reflects this.\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(RANDOM_SEED)\n\n    def draw_positive_normal(mean, std):\n        \"\"\"Draws from a normal distribution, ensuring the result is positive.\"\"\"\n        while True:\n            val = rng.normal(mean, std)\n            if val > 0:\n                return val\n\n    def potential_V(r, V0, a, Ad, Zd, r0, r0C):\n        \"\"\"Calculates the total potential V(r) = V_N(r) + V_C(r).\"\"\"\n        # Nuclear potential (Woods-Saxon)\n        R = r0 * Ad**(1/3.0)\n        Vn = -V0 / (1.0 + np.exp((r - R) / a))\n\n        # Coulomb potential (uniformly charged sphere)\n        Rc = r0C * Ad**(1/3.0)\n        Vc = np.where(r >= Rc,\n                      (Zd * Z_ALPHA * E2) / r,\n                      (Zd * Z_ALPHA * E2) / (2.0 * Rc) * (3.0 - (r/Rc)**2))\n        \n        return Vn + Vc\n\n    def run_case(case_params):\n        \"\"\"Runs the Monte Carlo simulation for a single case.\"\"\"\n        Zd, Ad, Q, Pa, r0_m, r0_s, a_m, a_s, V0_m, V0_s, r0C_m, r0C_s = case_params\n\n        m_d_c2 = Ad * M_U_C2\n        mu_c2 = (M_ALPHA_C2 * m_d_c2) / (M_ALPHA_C2 + m_d_c2)\n\n        y_values = []\n        r_grid = np.linspace(R_MIN, R_MAX, GRID_POINTS)\n\n        for _ in range(N_SAMPLES):\n            # 1. Sample parameters\n            r0_sample = draw_positive_normal(r0_m, r0_s)\n            a_sample = draw_positive_normal(a_m, a_s)\n            V0_sample = draw_positive_normal(V0_m, V0_s)\n            r0C_sample = draw_positive_normal(r0C_m, r0C_s)\n\n            # 2. Find turning points\n            def root_func(r):\n                return potential_V(r, V0_sample, a_sample, Ad, Zd, r0_sample, r0C_sample) - Q\n\n            potential_grid_vals = root_func(r_grid)\n            \n            brackets = []\n            for i in range(len(potential_grid_vals) - 1):\n                if np.sign(potential_grid_vals[i]) != np.sign(potential_grid_vals[i+1]):\n                    brackets.append((r_grid[i], r_grid[i+1]))\n\n            if len(brackets) != 2:\n                continue # Discard sample as per requirement\n\n            try:\n                r1 = brentq(root_func, brackets[0][0], brackets[0][1])\n                r2 = brentq(root_func, brackets[1][0], brackets[1][1])\n            except (RuntimeError, ValueError):\n                continue # brentq failed, discard sample\n\n            # 3. WKB integral\n            def wkb_integrand(r):\n                integrand_val = 2.0 * mu_c2 * (potential_V(r, V0_sample, a_sample, Ad, Zd, r0_sample, r0C_sample) - Q)\n                return np.sqrt(integrand_val) if integrand_val > 0 else 0.0\n\n            K_integral, _ = quad(wkb_integrand, r1, r2, epsabs=1e-9, epsrel=1e-9)\n            K = K_integral / HBARC\n\n            # 4. Calculate half-life\n            # Problem description for nu is v_internal / (2R). The solution text clarifies units.\n            # v_internal = c * sqrt(2Q / mu_c^2)\n            v_ratio = np.sqrt(2.0 * Q / mu_c2)\n            R_sample = r0_sample * Ad**(1/3.0)\n            nu = (v_ratio * C_LIGHT) / (2.0 * R_sample) # units: s^-1\n\n            # Calculate log10(T_1/2) using the logarithmic form to avoid underflow\n            # T_1/2 = ln(2) / (Pa * nu * P) = ln(2) / (Pa * nu * exp(-2K))\n            log_T_half_life = (LN2 - np.log(Pa) - np.log(nu) + 2.0 * K) / LN10\n            y_values.append(log_T_half_life)\n        \n        # 5. Aggregate results\n        if not y_values:\n            return 0.0, 0.0\n\n        mean_y = np.mean(y_values)\n        std_y = np.std(y_values, ddof=1) if len(y_values) > 1 else 0.0\n        \n        return mean_y, std_y\n\n    all_results = []\n    for case in test_cases_params:\n        mean_y, std_y = run_case(case)\n        all_results.extend([mean_y, std_y])\n    \n    # Format the final output string as required.\n    formatted_results = [f\"{x:.3f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3575895"}]}