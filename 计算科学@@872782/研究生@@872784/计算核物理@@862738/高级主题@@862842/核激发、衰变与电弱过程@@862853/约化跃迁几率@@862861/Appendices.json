{"hands_on_practices": [{"introduction": "掌握了选择定则后，下一步是在一个实际的微观框架内计算跃迁强度。这项练习 [@problem_id:3585971] 将指导你在核壳模型中计算约化跃迁几率 $B(E2)$。它清晰地展示了如何从单体跃迁密度（OBTDs）和单粒子矩阵元出发，构建起一个复杂的多体矩阵元，并引入有效电荷来解释模型空间外的效应。", "problem": "考虑一个在组态相互作用壳模型框架内描述的非相对论性核多体系统。多体态之间的 $L$ 阶电四极跃迁算符由作用于单核子轨道上的单体算符构建而成，这些单体算符按质子和中子子空间进行区分，并通过有效电荷进行缩放以计入缺失的关联。在计算环境中，角动量为 $J_i$ 的初态与角动量为 $J_f$ 的末态之间的 $L$ 阶电多极跃迁的约化跃迁几率，是根据一个多体约化矩阵元来定义的，而后者可以由单体组成部分和有效电荷组装而成。您的任务是，从第一性原理出发，推导如何使用 Wigner–Eckart 定理、具有单体算符的二次量子化，以及将多体约化矩阵元分解为单体跃迁密度（OBTDs）和单粒子约化矩阵元的方法，来计算约化跃迁几率 $B(EL; J_i \\rightarrow J_f)$，然后将得到的表达式用代码实现，以评估一个指定的测试套件。\n\n仅使用以下基本出发点：\n- 作用于角动量本征态之间的 $L$ 阶球张量算符的 Wigner–Eckart 定理。\n- 以约化矩阵元定义的约化跃迁几率 $B(EL; J_i \\rightarrow J_f)$。\n- 二次量子化中单体算符的结构及其对多体态的作用。\n- 有效电荷 $e_p$ 和 $e_n$ 的概念，它们分别作为质子和中子的加权和，进入电多极算符的定义中。\n\n您不得假定或使用任何预先引用的、明确用以下量表示 $B(EL)$ 的最终计算公式；相反，您必须从上述基本原理开始推导计算表达式。\n\n在所提供的计算模型中，输入为：\n- 初态和末态的角动量 $J_i$ 和 $J_f$。\n- 算符的阶数 $L$，此处固定为电四极情况 $L = 2$。\n- 质子有效电荷 $e_p$ 和中子有效电荷 $e_n$（无量纲乘子）。\n- 分别为质子和中子提供的项列表。每一项都包含一个 OBTD 值和相应的 $L$ 阶电多极算符的单粒子约化矩阵元，该矩阵元已包含单粒子空间上的角动量约化。OBTD 是一个标量系数，它编码了由于在一个轨道上产生一个粒子并在另一个轨道上湮灭它所引起的多体结构变化，并约化至 $L$ 阶。与某一项关联的单粒子约化矩阵元的单位为 $\\mathrm{fm}^L$，此处对于 $L=2$ 为 $\\mathrm{fm}^2$。\n\n您必须为以下每个测试案例生成约化跃迁几率值 $B(E2; J_i \\rightarrow J_f)$，单位为 $\\mathrm{e}^2\\,\\mathrm{fm}^4$。每个测试案例由以下内容完全指定：\n- $J_i$, $J_f$\n- $e_p$, $e_n$\n- 质子项：$\\{(\\text{OBTD}_p^{(k)}, \\text{SPME}_p^{(k)})\\}$，其中每个单粒子约化矩阵元 $\\text{SPME}$ 的单位为 $\\mathrm{fm}^2$。\n- 中子项：$\\{(\\text{OBTD}_n^{(k)}, \\text{SPME}_n^{(k)})\\}$，其中每个单粒子约化矩阵元 $\\text{SPME}$ 的单位为 $\\mathrm{fm}^2$。\n\n计算以下五个案例的 $B(E2)$，确保数值稳定性和符号的正确处理：\n\n- 案例 $1$ (单核素、单项、仅质子):\n  - $J_i = 2$, $J_f = 0$, $L = 2$\n  - $e_p = 1.5$, $e_n = 0.5$\n  - 质子项: $\\{(0.8, 5.0)\\}$\n  - 中子项: $\\{\\}$\n\n- 案例 $2$ (两种核素、多项):\n  - $J_i = 4$, $J_f = 2$, $L = 2$\n  - $e_p = 1.5$, $e_n = 0.5$\n  - 质子项: $\\{(0.25, 6.0), (0.10, 4.0)\\}$\n  - 中子项: $\\{(0.40, 5.0), (0.15, 3.0)\\}$\n\n- 案例 $3$ (通过符号实现的相消干涉):\n  - $J_i = 2$, $J_f = 2$, $L = 2$\n  - $e_p = 1.5$, $e_n = 0.5$\n  - 质子项: $\\{(0.50, 7.0), (0.20, -2.0)\\}$\n  - 中子项: $\\{(-0.80, 6.0)\\}$\n\n- 案例 $4$ (单体跃迁密度为零的边界情况):\n  - $J_i = 6$, $J_f = 4$, $L = 2$\n  - $e_p = 1.5$, $e_n = 0.5$\n  - 质子项: $\\{(0.0, 10.0), (0.0, -7.0)\\}$\n  - 中子项: $\\{\\}$\n\n- 案例 $5$ ($J_i = 0$ 导致统计因子为一的边界情况):\n  - $J_i = 0$, $J_f = 2$, $L = 2$\n  - $e_p = 1.5$, $e_n = 0.5$\n  - 质子项: $\\{(-0.30, 8.0)\\}$\n  - 中子项: $\\{(0.20, 6.0)\\}$\n\n要求：\n- 从上述基本原理推导 $B(E2; J_i \\rightarrow J_f)$ 的计算表达式，明确展示连接单体算符结构、单体跃迁密度和有效电荷与多体约化矩阵元的步骤。\n- 将推导出的表达式实现为一个完整的、可运行的程序，用于评估所有五个案例。\n- 将每个最终结果以 $\\mathrm{e}^2\\,\\mathrm{fm}^4$ 为单位表示，并精确到 $6$ 位小数。\n- 最终输出格式：您的程序应生成单行输出，包含一个用方括号括起来的、以逗号分隔的结果列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$）。", "solution": "该问题要求在核壳模型的背景下，推导并实现约化跃迁几率 $B(E2; J_i \\rightarrow J_f)$ 的公式。推导必须从基本原理开始：$B(EL)$ 的定义、Wigner–Eckart 定理、单体算符的二次量子化形式，以及有效电荷的概念。\n\n设初态和末态的多体核态分别表示为 $|\\Psi_i\\rangle = |\\alpha_i J_i M_i\\rangle$ 和 $|\\Psi_f\\rangle = |\\alpha_f J_f M_f\\rangle$，其中 $J$ 是总角动量，$M$ 是其投影，$\\alpha$ 代表所有其他量子数。\n\n**步骤 1：约化跃迁几率的定义**\n\n由电多极算符 $\\hat{O}(EL)$ 引发的多极性为 $L$ 的跃迁，其约化跃迁几率 $B(EL; J_i \\rightarrow J_f)$ 定义为：\n$$ B(EL; J_i \\rightarrow J_f) = \\frac{1}{2J_i + 1} |\\langle \\Psi_f || \\hat{O}(EL) || \\Psi_i \\rangle|^2 $$\n此处，$\\langle \\Psi_f || \\hat{O}(EL) || \\Psi_i \\rangle$ 是算符的多体约化矩阵元（MBRME）。根据 Wigner–Eckart 定理，其值与磁量子数 $M_i$ 和 $M_f$ 无关。因子 $(2J_i + 1)^{-1}$ 代表对所有可能的初态进行平均。对于此问题，多极性固定为电四极情况，因此 $L=2$。\n\n**步骤 2：电四极算符的结构**\n\n电四极算符 $\\hat{O}(E2M)$ 是一个单体算符，意味着它是作用于单个核子上的算符之和：\n$$ \\hat{O}(E2M) = \\sum_{k=1}^{A} \\hat{o}_k(E2M) $$\n其中 $A$ 是核子的总数。为了计入核芯极化以及模型空间中未包含的其他关联，引入了有效电荷 $e_p$ 和 $e_n$。它们是无量纲乘子。因此，算符被分离为质子和中子的贡献：\n$$ \\hat{O}(E2M) = e_p \\sum_{k \\in \\text{protons}} \\hat{o}_k(E2M) + e_n \\sum_{k \\in \\text{neutrons}} \\hat{o}_k(E2M) $$\n其中算符 $\\hat{o}_k(E2M)$ 通常与 $r_k^2 Y_{2M}(\\hat{r}_k)$ 成正比。基本电荷 $e$ 通常被吸收到 $B(E2)$ 的最终单位中，即 $\\mathrm{e}^2 \\mathrm{fm}^4$。\n\n**步骤 3：多体约化矩阵元**\n\n由于算符的线性结构，多体约化矩阵元也可以写成质子和中子贡献之和：\n$$ \\langle \\Psi_f || \\hat{O}(E2) || \\Psi_i \\rangle = e_p \\langle \\Psi_f || \\hat{O}_p(E2) || \\Psi_i \\rangle + e_n \\langle \\Psi_f || \\hat{O}_n(E2) || \\Psi_i \\rangle $$\n其中 $\\hat{O}_p(E2)$ 和 $\\hat{O}_n(E2)$ 分别代表仅对质子和仅对中子的求和。\n\n壳模型的关键洞见在于将这些多体矩阵元用更基本的量来表示。任何单体算符的多体约化矩阵元都可以展开为对所有可能的单粒子跃迁的求和。设单粒子轨道用 $\\alpha$ 和 $\\beta$ 等指标表示。对于质子部分，该展开式为：\n$$ \\langle \\Psi_f || \\hat{O}_p(E2) || \\Psi_i \\rangle = \\sum_{\\alpha, \\beta} \\text{OBTD}_{p, \\alpha\\beta} \\cdot \\langle \\alpha || \\hat{o}(E2) || \\beta \\rangle_p $$\n在此表达式中：\n- $\\langle \\alpha || \\hat{o}(E2) || \\beta \\rangle_p$ 是质子从轨道 $\\beta$ 跃迁到轨道 $\\alpha$ 的单粒子约化矩阵元（SPME）。该量仅取决于单粒子波函数和算符形式。\n- $\\text{OBTD}_{p, \\alpha\\beta}$ 是质子的单体跃迁密度。这个标量包含了关于跃迁的所有复杂多体信息，本质上给出了系统通过从 $\\beta$ 到 $\\alpha$ 的特定单粒子跳跃，从 $|\\Psi_i\\rangle$ 变为 $|\\Psi_f\\rangle$ 的振幅。在二次量子化中，OBTD 是一个耦合的产生-湮灭算符对 $(\\hat{a}^\\dagger_\\alpha \\otimes \\tilde{a}_\\beta)^{(L=2)}$ 的多体约化矩阵元。\n\n问题提供的输入不是完整的轨道集合 $(\\alpha, \\beta)$，而是预先计算好的非零贡献项列表，其中每一项 $k$ 都是一个对 $(\\text{OBTD}^{(k)}, \\text{SPME}^{(k)})$。这简化了求和。我们用 $S_p$ 表示质子的和，用 $S_n$ 表示中子的和：\n$$ S_p = \\sum_{k} \\text{OBTD}_{p}^{(k)} \\cdot \\text{SPME}_{p}^{(k)} $$\n$$ S_n = \\sum_{j} \\text{OBTD}_{n}^{(j)} \\cdot \\text{SPME}_{n}^{(j)} $$\n$S_p$ 和 $S_n$ 的单位是 $\\mathrm{fm}^2$，因为 OBTD 是无量纲的，而 SPME 的单位是 $\\mathrm{fm}^2$。\n\n总的多体约化矩阵元（不含电荷单位 $e$）是质子和中子振幅的相干求和，并按各自的有效电荷进行缩放：\n$$ M = \\langle \\Psi_f || \\hat{O}(E2) || \\Psi_i \\rangle = e_p S_p + e_n S_n $$\n$M$ 的值是一个实数，单位为 $\\mathrm{fm}^2$。\n\n**步骤 4：最终计算公式**\n\n将多体约化矩阵元的表达式代入 $B(E2)$ 的定义，即可得到最终的计算公式。多体约化矩阵元为 $M$，单位是 $\\mathrm{fm}^2$，其完整的物理值为 $e \\cdot M$。\n$$ B(E2; J_i \\rightarrow J_f) = \\frac{1}{2J_i + 1} |e \\cdot M|^2 = \\frac{M^2}{2J_i+1} $$\n最终单位为所要求的 $\\mathrm{e}^2 \\mathrm{fm}^4$。需要实现的推导公式是：\n$$ B(E2; J_i \\rightarrow J_f) = \\frac{1}{2J_i + 1} \\left( e_p \\sum_{k} (\\text{OBTD}_{p}^{(k)} \\cdot \\text{SPME}_{p}^{(k)}) + e_n \\sum_{j} (\\text{OBTD}_{n}^{(j)} \\cdot \\text{SPME}_{n}^{(j)}) \\right)^2 $$\n该表达式是前述基本原理的直接结果，可用于数值实现。每个测试案例的计算包括：对质子和中子列表中的乘积进行求和，用有效电荷进行缩放，将这两部分贡献相加，对结果取平方，最后除以统计因子 $(2J_i + 1)$。一个特殊情况是初态的 $J_i=0$，此时统计因子为 $(2 \\cdot 0 + 1) = 1$。平方运算确保最终结果为非负数，这符合几率的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and calculates the reduced transition probability B(E2) for a set of test cases\n    within the nuclear shell model framework.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"Ji\": 2, \"Jf\": 0, \"L\": 2,\n            \"ep\": 1.5, \"en\": 0.5,\n            \"proton_terms\": [(0.8, 5.0)],\n            \"neutron_terms\": []\n        },\n        {\n            \"name\": \"Case 2\",\n            \"Ji\": 4, \"Jf\": 2, \"L\": 2,\n            \"ep\": 1.5, \"en\": 0.5,\n            \"proton_terms\": [(0.25, 6.0), (0.10, 4.0)],\n            \"neutron_terms\": [(0.40, 5.0), (0.15, 3.0)]\n        },\n        {\n            \"name\": \"Case 3\",\n            \"Ji\": 2, \"Jf\": 2, \"L\": 2,\n            \"ep\": 1.5, \"en\": 0.5,\n            \"proton_terms\": [(0.50, 7.0), (0.20, -2.0)],\n            \"neutron_terms\": [(-0.80, 6.0)]\n        },\n        {\n            \"name\": \"Case 4\",\n            \"Ji\": 6, \"Jf\": 4, \"L\": 2,\n            \"ep\": 1.5, \"en\": 0.5,\n            \"proton_terms\": [(0.0, 10.0), (0.0, -7.0)],\n            \"neutron_terms\": []\n        },\n        {\n            \"name\": \"Case 5\",\n            \"Ji\": 0, \"Jf\": 2, \"L\": 2,\n            \"ep\": 1.5, \"en\": 0.5,\n            \"proton_terms\": [(-0.30, 8.0)],\n            \"neutron_terms\": [(0.20, 6.0)]\n        }\n    ]\n\n    results = []\n    \n    # The derived computational formula for B(E2) is:\n    # B(E2) = (1 / (2*Ji + 1)) * (ep * sum(OBTD_p * SPME_p) + en * sum(OBTD_n * SPME_n))^2\n\n    for case in test_cases:\n        # Calculate the sum of (OBTD * SPME) for protons\n        sum_p = 0.0\n        for obtd_p, spme_p in case[\"proton_terms\"]:\n            sum_p += obtd_p * spme_p\n\n        # Calculate the sum of (OBTD * SPME) for neutrons\n        sum_n = 0.0\n        for obtd_n, spme_n in case[\"neutron_terms\"]:\n            sum_n += obtd_n * spme_n\n\n        # Calculate the total many-body transition amplitude M\n        # M = ep * S_p + en * S_n\n        total_amplitude = case[\"ep\"] * sum_p + case[\"en\"] * sum_n\n\n        # Retrieve the initial angular momentum Ji\n        Ji = case[\"Ji\"]\n        \n        # Calculate the statistical factor. Handle Ji=0 case correctly, though algebra is the same.\n        if 2 * Ji + 1 == 0:\n            # This case is physically impossible for non-zero J, but as a safeguard.\n            b_e2 = 0.0\n        else:\n            statistical_factor = 1.0 / (2 * Ji + 1)\n            # Calculate B(E2)\n            b_e2 = statistical_factor * (total_amplitude ** 2)\n\n        results.append(b_e2)\n\n    # Format results to 6 decimal places and create the final output string.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3585971"}, {"introduction": "除了微观模型，原子核跃迁也可以用更宏观的集体模型来描述。最后的这项练习 [@problem_id:3585886] 通过从给定的径向跃迁密度计算跃迁几率，将微观图像与连续描述联系起来。这个实践不仅揭示了不同理论模型之间的关系，还引入了处理连续谱描述时至关重要的数值积分技术。", "problem": "给定一个源于原子核中电磁跃迁的计算任务。从电多极算符和约化矩阵元的定义出发，建立阶数为 $\\lambda$ 的电多极的约化跃迁几率（表示为 $B(E\\lambda)$）如何用径向跃迁密度表示。将原子核系统视为球对称，并关注跃迁密度的标量（径向）内容。从第一性原理出发，通过对角度进行积分来推导分离出纯径向贡献的表达式，并证明约化跃迁几率的数值计算等同于计算一个由跃迁密度乘以适当半径幂次加权的单一径向积分。\n\n然后，你必须实现一个程序，通过对 $r \\in [0,\\infty)$ 进行所需的径向积分，来为一组指定的测试用例数值计算约化跃迁几率 $B(E\\lambda)$。跃迁密度 $\\delta\\rho_\\lambda(r)$ 的物理量纲为 $\\text{fm}^{-3}$，积分必须在以 $\\text{fm}$ 为单位的径向坐标 $r$ 上进行。所得的 $B(E\\lambda)$ 必须以 $\\text{e}^2\\,\\text{fm}^{2\\lambda}$ 为单位表示，并理解有效电荷为单位1，因此报告的数值以 $\\text{fm}^{2\\lambda}$ 为单位，因子 $\\text{e}^2$ 是隐含的。在中间推导过程中出现的任何角度都必须以弧度为单位，并在径向简化过程中被完全积分掉。你的数值输出必须报告为浮点数，并且你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3]$）。\n\n你的实现必须处理在无限区间上的数值积分以及乘以跃迁密度的权重 $r^{\\lambda+2}$。在你的解决方案中，讨论对于衰减、缓慢衰减和轻微振荡的跃迁密度具有鲁棒性的数值积分算法选择，包括潜在的相消误差和步长控制。你必须通过选择在原点处正则且在无穷远处可积的物理上合理的函数 $\\delta\\rho_\\lambda(r)$ 来确保科学真实性。\n\n测试套件：\n对以下四种情况计算 $B(E\\lambda)$。对于每种情况，使用指定的参数。所有半径 $r$ 的单位均为 $\\text{fm}$；任何波数 $k$ 的单位均为 $\\text{fm}^{-1}$。\n\n- 情况A（通用衰减密度）：$\\lambda=2$，$\\delta\\rho_\\lambda(r) = \\rho_0 \\exp(-r/a)$，其中 $\\rho_0 = 0.02$ 且 $a = 1.2$。\n- 情况B（$\\lambda=0$ 的边界条件）：$\\lambda=0$，$\\delta\\rho_\\lambda(r) = \\rho_0 \\exp(-r/a)$，其中 $\\rho_0 = 0.02$ 且 $a = 1.2$。\n- 情况C（振荡阻尼密度）：$\\lambda=3$，$\\delta\\rho_\\lambda(r) = \\rho_0 j_0(k r)\\exp(-r/R)$，其中 $\\rho_0 = 0.01$，$k = 1.0$，$R=5.0$，其中 $j_0(x)$ 是球贝塞尔函数 $j_0(x)=\\sin(x)/x$，且 $j_0(0)=1$。\n- 情况D（缓慢衰减的代数尾部）：$\\lambda=1$，$\\delta\\rho_\\lambda(r) = \\rho_0 \\left(1+(r/R)^6\\right)^{-1}$，其中 $\\rho_0 = 0.03$ 且 $R=3.0$。\n\n对于每种情况，你的程序必须计算通过对 $r$ 进行径向积分得到的量，然后取其绝对值的平方以产生 $B(E\\lambda)$，并以 $\\text{fm}^{2\\lambda}$ 为单位的浮点数形式报告。你的程序可以使用任何适用于 $[0,\\infty)$ 且能确保在受控误差容限下收敛的科学上合理的数值积分方法。最终输出必须是单行文本，按 A, B, C, D 的顺序显示四个结果，格式为 $[B_A,B_B,B_C,B_D]$，其中每个 $B$ 都是一个浮点数。\n\n你的推导必须从以下基础开始：\n- 由电荷密度构建的秩为 $\\lambda$ 的电多极算符。\n- 用于分离角度和径向贡献的约化矩阵元定义和 Wigner–Eckart 定理。\n- 与球对称性和原点正则性一致的径向跃迁密度定义。\n\n不要引用或假设任何预先推导出的 $B(E\\lambda)$ 目标公式；从这些基础出发进行推导。然后忠实于推导出的径向积分，实现计算评估。明确陈述并论证你的数值积分策略，并讨论可能的数值问题，例如 $r=0$ 附近的行为、无穷大上限、振荡被积函数、相消以及自适应容差选择。\n\n你的程序必须只生成所需格式的单行输出。不应打印任何其他文本。数值输出必须是代表 $B(E\\lambda)$ 的浮点数，单位为 $\\text{fm}^{2\\lambda}$。", "solution": "该问题要求根据径向跃迁密度推导约化电跃迁几率 $B(E\\lambda)$ 的公式，并随后对几个测试用例进行数值计算。推导必须从核物理学的基本定义开始。\n\n### $B(E\\lambda)$ 公式的推导\n\n约化跃迁几率 $B(E\\lambda)$ 量化了原子核在初态 $|J_i M_i\\rangle$ 和末态 $|J_f M_f\\rangle$ 之间发生电性的且多极性为 $\\lambda$ 的电磁跃迁的可能性。\n\n1.  **电多极算符**：该过程由电磁场与原子核电荷分布的相互作用驱动。在长波近似下，这种相互作用由一组多极算符描述。秩为 $\\lambda$、投影为 $\\mu$ 的电多极算符 $\\hat{O}(E\\lambda, \\mu)$ 根据核电荷密度算符 $\\hat{\\rho}(\\vec{r})$ 定义如下：\n    $$\n    \\hat{O}(E\\lambda, \\mu) = \\int \\hat{\\rho}(\\vec{r}) r^\\lambda Y_{\\lambda\\mu}(\\hat{r}) \\, d^3r\n    $$\n    此处，$\\vec{r}$ 是从原子核中心出发的位置矢量，$r=|\\vec{r}|$，$\\hat{r}=\\vec{r}/r$，$Y_{\\lambda\\mu}(\\hat{r})$ 是球谐函数。该算符以电荷乘以长度$^\\lambda$的单位表示（例如 $\\text{e} \\cdot \\text{fm}^\\lambda$）。\n\n2.  **约化跃迁几率与 Wigner-Eckart 定理**：跃迁的强度与磁亚态的取向无关。约化跃迁几率 $B(E\\lambda)$ 捕捉了这种内禀强度。对于从总角动量为 $J_i$ 的初态到末态 $J_f$ 的跃迁，其定义为：\n    $$\n    B(E\\lambda; J_i \\to J_f) = \\frac{1}{2J_i+1} |\\langle J_f || \\hat{O}(E\\lambda) || J_i \\rangle|^2\n    $$\n    该定义利用了约化矩阵元 $\\langle J_f || \\hat{O}(E\\lambda) || J_i \\rangle$，它包含了跃迁的动力学信息，并通过 Wigner-Eckart 定理与几何方面分离。电荷 $e$ 已隐含在算符中，因此 $B(E\\lambda)$ 的单位是 $\\text{e}^2 \\cdot \\text{fm}^{2\\lambda}$。\n\n3.  **径向跃迁密度的引入**：问题的核心是将约化矩阵元与一个径向积分联系起来。算符 $\\hat{O}(E\\lambda, \\mu)$ 的矩阵元为：\n    $$\n    \\langle J_f M_f | \\hat{O}(E\\lambda, \\mu) | J_i M_i \\rangle = \\int \\langle J_f M_f | \\hat{\\rho}(\\vec{r}) | J_i M_i \\rangle r^\\lambda Y_{\\lambda\\mu}(\\hat{r}) \\, d^3r\n    $$\n    项 $\\langle J_f M_f | \\hat{\\rho}(\\vec{r}) | J_i M_i \\rangle$ 是跃迁电荷密度 $\\rho_{tr}(\\vec{r})$。在一个球对称系统中，该密度可以在球谐函数基中展开。对于连接态 $|J_i\\rangle$ 和 $|J_f\\rangle$ 的确定多极性 $\\lambda$ 的跃迁，跃迁密度的角度结构由这些角动量的耦合决定。径向依赖性被封装在一个称为径向跃迁密度的函数中。\n    \n    问题提供了一个单一的径向函数 $\\delta\\rho_\\lambda(r)$，它被定义为特定于多极性 $\\lambda$ 的跃迁密度的径向部分。这是核模型中的标准做法，其中 $\\delta\\rho_\\lambda(r)$ 的定义使得多极算符的约化矩阵元直接由以下径向积分给出：\n    $$\n    \\langle J_f || \\hat{O}(E\\lambda) || J_i \\rangle = \\int_0^\\infty \\delta\\rho_\\lambda(r) r^\\lambda r^2 \\, dr = \\int_0^\\infty \\delta\\rho_\\lambda(r) r^{\\lambda+2} \\, dr\n    $$\n    该关系源于对矩阵元表达式进行形式上的角度积分，从而投影出具有正确多极性的分量。Wigner-Eckart 定理和球张量积的性质确保了对于给定的跃迁，只有一个这样的径向积分有贡献。\n\n4.  **数值计算的最终表达式**：将 $B(E\\lambda)$ 的定义与约化矩阵元的积分形式相结合，我们得到：\n    $$\n    B(E\\lambda; J_i \\to J_f) = \\frac{1}{2J_i+1} \\left| \\int_0^\\infty \\delta\\rho_\\lambda(r) r^{\\lambda+2} \\, dr \\right|^2\n    $$\n    问题通过要求计算径向积分本身的绝对值的平方来简化上下文，这意味着几何因子 $(2J_i+1)^{-1}$ 要么是1（例如，对于从 $J_i=0$ 态开始的跃迁），要么在概念上被吸收到所计算量的定义中。因此，要计算的量是：\n    $$\n    B(E\\lambda) = \\left| \\int_0^\\infty \\delta\\rho_\\lambda(r) r^{\\lambda+2} \\, dr \\right|^2\n    $$\n    我们检查单位是否一致：$\\delta\\rho_\\lambda(r)$ 的单位是 $\\text{fm}^{-3}$，$r$ 的单位是 $\\text{fm}$。被积函数 $\\delta\\rho_\\lambda(r) r^{\\lambda+2}$ 的单位是 $\\text{fm}^{-3} \\cdot \\text{fm}^{\\lambda+2} = \\text{fm}^{\\lambda-1}$。对 $dr$ 的积分得到的结果单位是 $\\text{fm}^{\\lambda-1} \\cdot \\text{fm} = \\text{fm}^{\\lambda}$。将此结果平方得到的单位是 $\\text{fm}^{2\\lambda}$，这与要求单位 $\\text{e}^2\\,\\text{fm}^{2\\lambda}$ 的数值部分相匹配。\n\n### 数值积分策略\n\n任务简化为为每个指定情况计算积分 $I_\\lambda = \\int_0^\\infty \\delta\\rho_\\lambda(r) r^{\\lambda+2} \\, dr$。我们将使用 `scipy.integrate.quad` 函数，这是一个基于 QUADPACK 库的鲁棒数值积分程序。\n\n1.  **无限区间**：`quad` 函数原生支持无限积分限。它采用变量变换将区间 $[0, \\infty)$ 映射到有限区间，通常是 $[0, 1)$，例如通过 $r = t/(1-t)$。然后将标准的自适应积分技术（如 Gauss-Kronrod）应用于变换后的积分。这种方法对于当 $r \\to \\infty$ 时衰减足够快的被积函数是有效的，所有测试用例都满足此条件。\n2.  **被积函数行为**：\n    -   **$r=0$ 附近**：对于所有情况，所提供的跃迁密度 $\\delta\\rho_\\lambda(r)$ 在 $r=0$ 处是正则的（有限的）。总的被积函数形式为 $\\delta\\rho_\\lambda(r) r^{\\lambda+2}$。由于所有情况中 $\\lambda \\geq 0$，项 $r^{\\lambda+2}$ 确保了被积函数在 $r \\to 0$ 时平滑地趋于零，不会造成数值困难。\n    -   **当 $r \\to \\infty$ 时**：\n        -   情况A和B具有指数衰减 $\\exp(-r/a)$，`quad` 可以非常有效地处理这种情况。\n        -   情况C包含一个阻尼振荡项 $j_0(kr)\\exp(-r/R)$。指数阻尼确保振荡消失，从而防止收敛问题。`quad` 的自适应特性会自动增加振荡区域的求值点密度以保持精度。虽然如果被积函数的正负波瓣几乎相等，存在相消误差的可能，但强阻尼使得这不太可能成为一个严重问题。\n        -   情况D有一个代数（幂律）尾部，$(1+(r/R)^6)^{-1} \\sim r^{-6}$。对于大的 $r$，被积函数的行为类似于 $r^{-6} \\cdot r^{1+2} = r^{-3}$。由于指数小于-1，积分收敛，`quad` 处理无限区间的算法非常适合此类衰减。\n3.  **精度和误差控制**：`quad` 函数提供积分区间的自适应细分，以达到指定的绝对和相对误差容限（`atol` 和 `rtol`）。我们将依赖默认容限，这对于典型物理问题所需的精度通常是足够的。该函数还返回绝对误差的估计值，可用于验证结果的质量。\n\n该策略是鲁棒的，适用于测试套件中提供的所有不同形式的跃迁密度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Derives and computes the reduced transition probability B(Eλ)\n    for a set of test cases based on a radial transition density.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary with parameters for lambda and the transition density.\n    test_cases = [\n        {\n            \"case_id\": \"A\",\n            \"lambda\": 2,\n            \"density_func\": lambda r, p: p['rho0'] * np.exp(-r / p['a']),\n            \"params\": {\"rho0\": 0.02, \"a\": 1.2}\n        },\n        {\n            \"case_id\": \"B\",\n            \"lambda\": 0,\n            \"density_func\": lambda r, p: p['rho0'] * np.exp(-r / p['a']),\n            \"params\": {\"rho0\": 0.02, \"a\": 1.2}\n        },\n        {\n            \"case_id\": \"C\",\n            \"lambda\": 3,\n            \"density_func\": lambda r, p: p['rho0'] * spherical_jn(0, p['k'] * r) * np.exp(-r / p['R']),\n            \"params\": {\"rho0\": 0.01, \"k\": 1.0, \"R\": 5.0} \n        },\n        {\n            \"case_id\": \"D\",\n            \"lambda\": 1,\n            \"density_func\": lambda r, p: p['rho0'] / (1 + (r / p['R'])**6),\n            \"params\": {\"rho0\": 0.03, \"R\": 3.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        lam = case[\"lambda\"]\n        density_func = case[\"density_func\"]\n        params = case[\"params\"]\n\n        # The integrand for the radial integral is δρ_λ(r) * r^(λ+2)\n        integrand = lambda r: density_func(r, params) * (r**(lam + 2))\n\n        # Perform the numerical quadrature over r from 0 to infinity.\n        # quad returns a tuple (integral_value, estimated_error).\n        # We only need the integral value.\n        radial_integral_val, _ = quad(integrand, 0, np.inf)\n\n        # The reduced transition probability B(Eλ) is the square of the\n        # absolute value of this radial integral.\n        # The units are implicitly e^2 fm^(2λ).\n        b_e_lambda = np.abs(radial_integral_val)**2\n        \n        results.append(b_e_lambda)\n\n    # Final print statement in the exact required format.\n    # The output format is a single line with a comma-separated list of floats\n    # enclosed in square brackets.\n    print(f\"[{','.join(f'{r:.7f}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3585886"}]}