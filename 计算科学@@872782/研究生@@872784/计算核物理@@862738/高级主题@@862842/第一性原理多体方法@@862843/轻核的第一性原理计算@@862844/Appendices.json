{"hands_on_practices": [{"introduction": "现实的核哈密顿量包含很强的短程排斥，这导致低动量和高动量态之间存在强烈的耦合，使得在截断基矢空间中的直接对角化收敛非常缓慢。相似性重整化群 (Similarity Renormalization Group, SRG) 是一个强大的工具，它通过连续的幺正变换来演化哈密顿量，从而抑制这些棘手的非对角耦合，加速计算的收敛性。这项练习 [@problem_id:3541264] 让您亲手实践 SRG 流方程，通过对一个小的模型哈密顿量进行数值积分，您将能验证其核心性质：能谱的守恒和矩阵的解耦，这些性质是其在大型核结构计算中发挥作用的关键。", "problem": "考虑一个在截断基下的轻核从头计算描述，其中多体哈密顿量由一个有限维实对称矩阵表示。相似性重整化群 (SRG) 是一种幺正变换，旨在连续演化哈密顿量以压制非对角耦合，同时保持其能谱不变。从非相对论哈密顿量和幺正相似变换保持本征值不变的原理出发，可以定义一个流，其生成元由一个固定的参考算符构造。在本问题中，将生成元取为动能算符与演化中的哈密顿量的对易子。\n\n基本原理：\n- 令 $H_s$ 表示流参数为 $s$ 时的哈密顿量。SRG 流由一个满足常微分方程 (ODE) 的反厄米算符 $\\eta_s$ 生成：$$\\frac{dH_s}{ds} = [\\eta_s, H_s],$$ 其中 $[\\cdot,\\cdot]$ 表示对易子。\n- 选择生成元 $\\eta_s$ 为：$$\\eta_s = [T, H_s],$$ 其中 $T$ 是固定的动能算符（在所选基中是对角的）。\n- 该流是幺正的，因此只要常微分方程被精确积分，它就能对所有 $s$ 保持 $H_s$ 的本征值不变。\n\n任务：\n- 对于给定的 $T$ 和初始哈密顿量 $H_0 = H_{s=0}$，以矩阵形式实现 SRG 常微分方程：$$\\frac{dH_s}{ds} = [[T, H_s], H_s].$$\n- 对每个指定的测试用例，将常微分方程从 $s=0$ 数值积分到 $s=s_{\\text{end}}$。\n- 对每个测试用例，在 $s=s_{\\text{end}}$ 处计算两个量：\n  1. $H_0$ 和 $H_{s_{\\text{end}}}$ 的排序后本征值之间的最大绝对差，记为 $d_{\\text{spec}}$，以兆电子伏特 (MeV) 为单位。计算公式为：$$d_{\\text{spec}} = \\max_i \\left| \\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}}) \\right|,$$ 其中本征值按升序排序。\n  2. $H_{s_{\\text{end}}}$ 的非对角部分的弗罗贝尼乌斯范数，记为 $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$，以兆电子伏特 (MeV) 为单位。计算公式为：$$\\|H_{\\text{off}}(s_{\\text{end}})\\|_F = \\sqrt{\\sum_{i\\neq j} \\left(H_{s_{\\text{end}},ij}\\right)^2}.$$\n\n科学真实性：\n- $T$ 是对角矩阵，其对角元对应于单粒子动能，单位为兆电子伏特 (MeV)。初始哈密顿量 $H_0$ 包含动能和势能的贡献，并且是实对称的。\n- 流参数 $s$ 的单位是 $\\text{MeV}^{-2}$。所有能量都以 MeV 为单位。\n\n数值和输出要求：\n- 使用一个鲁棒的常微分方程积分器求解 $H_s$ 直到 $s_{\\text{end}}$，并具有足够的精度以在数值上展示能谱不变性。\n- 将每个报告的浮点数四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,...]\"）。对于每个测试用例，按顺序输出两个浮点数 $d_{\\text{spec}}$ 和 $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$，以便最终输出按顺序汇总所有测试用例的结果。\n\n测试套件：\n- 测试用例 1（两能级，非简并动能；中等强度的流）：\n  - $$T = \\begin{pmatrix} 5  0 \\\\ 0  25 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 2  8 \\\\ 8  24 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.02 \\text{ MeV}^{-2}.$$\n- 测试用例 2（边界情况，零流）：\n  - $$T = \\begin{pmatrix} 5  0 \\\\ 0  25 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 2  8 \\\\ 8  24 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0 \\text{ MeV}^{-2}.$$\n- 测试用例 3（简并动能；生成元为零）：\n  - $$T = \\begin{pmatrix} 10  0 \\\\ 0  10 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 12  4 \\\\ 4  9 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.2 \\text{ MeV}^{-2}.$$\n- 测试用例 4（三能级，动能间隔宽；显著的去耦合）：\n  - $$T = \\begin{pmatrix} 5  0  0 \\\\ 0  15  0 \\\\ 0  0  40 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 4  3  -2 \\\\ 3  17  4 \\\\ -2  4  37 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.05 \\text{ MeV}^{-2}.$$\n- 测试用例 5（三能级，近简并对；更强的流）：\n  - $$T = \\begin{pmatrix} 20  0  0 \\\\ 0  20.1  0 \\\\ 0  0  60 \\end{pmatrix} \\text{ MeV}, \\quad H_0 = \\begin{pmatrix} 20.5  5  -4 \\\\ 5  19.9  3 \\\\ -4  3  58.5 \\end{pmatrix} \\text{ MeV}, \\quad s_{\\text{end}} = 0.1 \\text{ MeV}^{-2}.$$\n\n答案规格：\n- 程序必须输出一个包含 10 个浮点数的列表（每个测试用例两个），每个浮点数四舍五入到六位小数，以 MeV 为单位，并严格按照以下顺序：$[d_{\\text{spec}}^{(1)}, \\|H_{\\text{off}}^{(1)}\\|_F, d_{\\text{spec}}^{(2)}, \\|H_{\\text{off}}^{(2)}\\|_F, \\dots, d_{\\text{spec}}^{(5)}, \\|H_{\\text{off}}^{(5)}\\|_F]$。", "solution": "所述问题已通过验证。\n\n### 步骤 1：提取给定条件\n- **控制方程 (SRG ODE)**：流参数为 $s$ 时的哈密顿量 $H_s$ 根据常微分方程（ODE）演化：\n$$\n\\frac{dH_s}{ds} = [\\eta_s, H_s]\n$$\n- **生成元选择**：生成元 $\\eta_s$ 被选为动能算符 $T$ 与演化中的哈密顿量 $H_s$ 的对易子：\n$$\n\\eta_s = [T, H_s]\n$$\n- **组合的 ODE**：将生成元代入 SRG ODE，得到需要求解的具体流方程：\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s]\n$$\n- **初始条件**：积分从初始哈密顿量 $H_0 = H_{s=0}$ 开始。\n- **性质**：$H_s$ 是实对称矩阵。$T$ 是实对角矩阵。在精确积分下，$H_s$ 的本征值对所有 $s$ 保持不变。\n- **在 $s=s_{\\text{end}}$ 处计算的量**：\n    1.  **能谱偏差 ($d_{\\text{spec}}$)**：$d_{\\text{spec}} = \\max_i \\left| \\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}}) \\right|$，其中本征值 $\\lambda_i$ 按升序排序。单位为 MeV。\n    2.  **非对角弗罗贝尼乌斯范数 ($\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$)**：$\\|H_{\\text{off}}(s_{\\text{end}})\\|_F = \\sqrt{\\sum_{i\\neq j} \\left(H_{s_{\\text{end}},ij}\\right)^2}$。单位为 MeV。\n- **单位**：所有能量（$T$，$H$）的单位都是 MeV。流参数 $s$ 的单位是 $\\text{MeV}^{-2}$。\n- **数值要求**：使用鲁棒的常微分方程积分器。将最终的浮点数值四舍五入到六位小数。\n- **测试用例**：\n    - **用例 1**：$T = \\begin{pmatrix} 5  0 \\\\ 0  25 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 2  8 \\\\ 8  24 \\end{pmatrix}$, $s_{\\text{end}} = 0.02$。\n    - **用例 2**：$T = \\begin{pmatrix} 5  0 \\\\ 0  25 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 2  8 \\\\ 8  24 \\end{pmatrix}$, $s_{\\text{end}} = 0$。\n    - **用例 3**：$T = \\begin{pmatrix} 10  0 \\\\ 0  10 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 12  4 \\\\ 4  9 \\end{pmatrix}$, $s_{\\text{end}} = 0.2$。\n    - **用例 4**：$T = \\begin{pmatrix} 5  0  0 \\\\ 0  15  0 \\\\ 0  0  40 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 4  3  -2 \\\\ 3  17  4 \\\\ -2  4  37 \\end{pmatrix}$, $s_{\\text{end}} = 0.05$。\n    - **用例 5**：$T = \\begin{pmatrix} 20  0  0 \\\\ 0  20.1  0 \\\\ 0  0  60 \\end{pmatrix}$, $H_0 = \\begin{pmatrix} 20.5  5  -4 \\\\ 5  19.9  3 \\\\ -4  3  58.5 \\end{pmatrix}$, $s_{\\text{end}} = 0.1$。\n\n### 步骤 2：使用提取的给定条件进行验证\n- **科学依据**：该问题基于相似性重整化群，这是计算核物理中一种用于解耦哈密顿量的标准且成熟的方法。生成元 $\\eta_s = [T, H_s]$ 的选择是一种常见的选择，旨在将哈密顿量驱动到动能算符基中的带对角或对角形式。涉及对易子和幺正变换的数学表述是量子力学的基础。该问题是这些原理的直接应用。\n- **良态问题（Well-Posed）**：该问题是一阶常微分方程组的初值问题。对于一个大小为 $N \\times N$ 的有限维矩阵 $H_s$，其控制方程代表了一个由 $N^2$ 个关于其元素的耦合常微分方程组成的系统。方程的右侧 $f(H_s) = [[T, H_s], H_s]$ 涉及矩阵乘法和加法，是 $H_s$ 元素的多项式。该函数在任何紧凑域上都是光滑且全局利普希茨的，这保证了对于给定的初始条件 $H_0$，解的存在性和唯一性。该任务在计算上是明确定义的。\n- **客观性**：该问题由精确的数学对象（矩阵、常微分方程、范数）和所有测试用例的具体数值定义。没有歧义或主观性语言。\n\n### 步骤 3：结论与行动\n该问题是有效的。它是一个科学上合理、良态且客观的计算任务。将提供一个解决方案。\n\n### 解决方案\n\n该问题要求对一个描述核哈密顿量相似性重整化群（SRG）流的矩阵值常微分方程进行数值积分。目标是将一个初始哈密顿量 $H_0$ 演化到一个最终哈密顿量 $H_{s_{\\text{end}}}$，并分析结果的性质。\n\n问题的核心在于求解以下初值问题：\n$$\n\\frac{dH_s}{ds} = [[T, H_s], H_s], \\quad H(s=0) = H_0\n$$\n其中 $T$ 是动能矩阵，$H_s$ 是流参数为 $s$ 时的哈密顿矩阵，$[A, B] = AB - BA$ 是矩阵对易子。\n\n该方程代表了一个包含 $N^2$ 个耦合非线性一阶常微分方程的系统，其中 $N$ 是矩阵的维度。为了数值求解这个系统，我们采用标准的常微分方程求解器，例如 `scipy.integrate` 库提供的求解器。这些求解器对一维状态向量进行操作。因此，必须将 $N \\times N$ 的矩阵 $H_s$ 展平为一个长度为 $N^2$ 的向量，作为求解器的状态变量。\n\n实现包括以下步骤：\n\n1.  **定义常微分方程系统函数**：我们必须创建一个函数，例如 `f(s, y)`，用于计算状态向量 `y` 的时间导数。在我们的情况下，`y` 是哈密顿矩阵 $H_s$ 的展平表示。该函数将：\n    a.  接受当前流参数 `s` 和展平的哈密顿向量 `y`。它还需要恒定的动能矩阵 $T$ 和矩阵维度 $N$ 作为辅助参数。\n    b.  将长度为 $N^2$ 的输入向量 `y` 重塑为 $N \\times N$ 的矩阵，我们将其识别为 $H_s$。\n    c.  通过计算双重对易子来计算导数 $\\frac{dH_s}{ds}$：\n        i.  首先，计算内层对易子，它充当生成元：$\\eta_s = [T, H_s] = T H_s - H_s T$。\n        ii. 其次，计算外层对易子，得到导数：$\\frac{dH_s}{ds} = [\\eta_s, H_s] = \\eta_s H_s - H_s \\eta_s$。\n    d.  将得到的 $N \\times N$ 矩阵 $\\frac{dH_s}{ds}$ 展平回一个长度为 $N^2$ 的一维向量并返回。\n\n2.  **为每个测试用例积分常微分方程**：对于每个提供的测试用例 $(T, H_0, s_{\\text{end}})$：\n    a.  处理平凡流情况：如果 $s_{\\text{end}}=0$（如测试用例 2）或者生成元 $[T, H_s]$ 恒为零，则哈密顿量不演化，因此 $H_{s_{\\text{end}}} = H_0$。如果 $T$ 是单位矩阵的标量倍（即其所有对角元素相等，如测试用例 3），则生成元恒为零，因为它会与任何 $H_s$ 对易。在这些情况下，我们绕过数值积分。\n    b.  对于非平凡流，调用一个数值常微分方程求解器（例如 `scipy.integrate.solve_ivp`），使用步骤 1 中定义的函数、积分区间 $[0, s_{\\text{end}}]$、展平的初始哈密顿量 $H_0$ 以及高精度容差（例如 `rtol=1e-8`, `atol=1e-11`）来精确捕捉本征值的近乎完美的守恒性。\n    c.  提取在 $s_{\\text{end}}$ 处的解，并将其重塑回 $N \\times N$ 的矩阵 $H_{s_{\\text{end}}}$。\n\n3.  **计算最终量**：获得 $H_{s_{\\text{end}}}$ 后，计算所需的两个指标：\n    a.  **能谱偏差, $d_{\\text{spec}}$**：这个量衡量积分的数值误差，因为在精确的幺正变换下，本征值必须守恒。\n        i.  计算初始哈密顿量 $H_0$ 的本征值，记为 $\\{\\lambda_i(H_0)\\}$。由于 $H_0$ 是实对称的，因此使用专门的算法（`numpy.linalg.eigvalsh`）以提高效率和稳定性。\n        ii. 计算最终哈密顿量 $H_{s_{\\text{end}}}$ 的本征值，记为 $\\{\\lambda_i(H_{s_{\\text{end}})\\}$.\n        iii. 将两组本征值按升序排序。\n        iv. 计算相应本征值之间绝对差的最大值：$d_{\\text{spec}} = \\max_i |\\lambda_i(H_0) - \\lambda_i(H_{s_{\\text{end}}})|$。\n    b.  **非对角弗罗贝尼乌斯范数, $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$**：这个量衡量哈密顿量被去耦合的程度（被驱动向对角或带对角形式）。该流旨在压制非对角矩阵元。\n        i.  通过将其对角元素置零来构造最终哈密顿量的非对角部分 $H_{\\text{off}}(s_{\\text{end}})$：$H_{\\text{off}} = H_{s_{\\text{end}}} - \\text{diag}(\\text{diag}(H_{s_{\\text{end}}'}))$。\n        ii. 计算该矩阵的弗罗贝尼乌斯范数：$\\|H_{\\text{off}}\\|_F = \\sqrt{\\sum_{i \\neq j} (H_{s_{\\text{end}},ij})^2}$。这可以使用 `numpy.linalg.norm` 直接完成。\n\n4.  **格式化输出**：将每个测试用例计算出的 $d_{\\text{spec}}$ 和 $\\|H_{\\text{off}}(s_{\\text{end}})\\|_F$ 的值四舍五入到六位小数，并按规定汇总成一个单一的逗号分隔列表。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the SRG ODE for a series of test cases and computes specified metrics.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"T\": np.array([[5.0, 0.0], [0.0, 25.0]]),\n            \"H0\": np.array([[2.0, 8.0], [8.0, 24.0]]),\n            \"s_end\": 0.02,\n        },\n        {\n            \"T\": np.array([[5.0, 0.0], [0.0, 25.0]]),\n            \"H0\": np.array([[2.0, 8.0], [8.0, 24.0]]),\n            \"s_end\": 0.0,\n        },\n        {\n            \"T\": np.array([[10.0, 0.0], [0.0, 10.0]]),\n            \"H0\": np.array([[12.0, 4.0], [4.0, 9.0]]),\n            \"s_end\": 0.2,\n        },\n        {\n            \"T\": np.array([[5.0, 0.0, 0.0], [0.0, 15.0, 0.0], [0.0, 0.0, 40.0]]),\n            \"H0\": np.array([[4.0, 3.0, -2.0], [3.0, 17.0, 4.0], [-2.0, 4.0, 37.0]]),\n            \"s_end\": 0.05,\n        },\n        {\n            \"T\": np.array([[20.0, 0.0, 0.0], [0.0, 20.1, 0.0], [0.0, 0.0, 60.0]]),\n            \"H0\": np.array([[20.5, 5.0, -4.0], [5.0, 19.9, 3.0], [-4.0, 3.0, 58.5]]),\n            \"s_end\": 0.1,\n        },\n    ]\n\n    results = []\n\n    def srg_flow_ode(s, h_flat, T, n):\n        \"\"\"\n        Computes the RHS of the SRG ODE: dH/ds = [[T, H], H].\n        The state vector h_flat is the flattened Hamiltonian matrix.\n        \"\"\"\n        H = h_flat.reshape((n, n))\n        \n        # Generator: eta = [T, H]\n        eta = T @ H - H @ T\n        \n        # Derivative: dH/ds = [eta, H]\n        dHds = eta @ H - H @ eta\n        \n        return dHds.flatten()\n\n    for case in test_cases:\n        T = case[\"T\"]\n        H0 = case[\"H0\"]\n        s_end = case[\"s_end\"]\n        n = T.shape[0]\n\n        # Since H is real and symmetric, we use eigvalsh for stability and performance.\n        eigvals0 = np.sort(np.linalg.eigvalsh(H0))\n\n        # Check for trivial flow cases:\n        # 1. Integration time s_end is 0.\n        # 2. T is a scalar multiple of identity, so [T, H] = 0 for any H.\n        #    Since T is given as diagonal, we just check if all diagonal elements are equal.\n        diag_T = np.diag(T)\n        is_T_scalar_multiple = np.allclose(diag_T, diag_T[0])\n\n        if s_end == 0.0 or is_T_scalar_multiple:\n            H_end = H0\n        else:\n            # Numerically integrate the ODE\n            sol = solve_ivp(\n                srg_flow_ode,\n                t_span=[0, s_end],\n                y0=H0.flatten(),\n                args=(T, n),\n                method='RK45',  # A robust standard choice\n                rtol=1e-9,    # Relative tolerance for high precision\n                atol=1e-12    # Absolute tolerance for high precision\n            )\n            H_end = sol.y[:, -1].reshape((n, n))\n        \n        # Compute the spectral deviation d_spec\n        eigvals_end = np.sort(np.linalg.eigvalsh(H_end))\n        d_spec = np.max(np.abs(eigvals0 - eigvals_end))\n\n        # Compute the Frobenius norm of the off-diagonal part of H(s_end)\n        H_off = H_end - np.diag(np.diag(H_end))\n        norm_H_off = np.linalg.norm(H_off, 'fro')\n\n        # Append rounded results to the list\n        results.append(round(d_spec, 6))\n        results.append(round(norm_H_off, 6))\n\n    # Format the final output string exactly as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3541264"}, {"introduction": "无核芯壳模型 (No-Core Shell Model, NCSM) 是一种领先的从头计算方法，但其计算结果依赖于有限基矢的参数：谐振子频率 $\\hbar\\Omega$ 和截断参数 $N_{\\max}$。为了获得具有物理意义的结果，必须消除这些依赖性。这通常通过对一系列 $N_{\\max}$ 值进行计算，并外推到无限基矢空间极限 ($N_{\\max} \\to \\infty$) 来实现，其收敛模式通常呈指数形式，从而可以进行稳健的拟合。这项练习 [@problem_id:3541307] 将指导您完成 NCSM 计算中至关重要的数据分析流程，您将实现这种指数收敛的拟合过程，并制定策略来选择最佳的基矢频率，这是从原始计算输出中获得可靠理论预测的关键技能。", "problem": "考虑使用谐振子单粒子基计算 alpha 粒子 ${}^{4}\\mathrm{He}$ 的基态能量的无核壳模型 (No-Core Shell Model, NCSM) 描述。该基由频率 $\\hbar\\Omega$ 和一个限制总激发量子数的截断参数 $N_{\\max}$ 表征。在第一性原理方法中，核哈密顿量 $\\hat{H}$ 包含现实的双核子以及可能的三核子相互作用，其基态通过求解薛定谔方程 $\\hat{H}\\lvert\\Psi_0\\rangle = E_0 \\lvert\\Psi_0\\rangle$ 得到。变分原理保证了对于固定的 $\\hbar\\Omega$ 和增大的 $N_{\\max}$，计算出的基态能量 $E(N_{\\max};\\hbar\\Omega)$ 会从上方单调趋近于真实能量 $E_{\\infty}$。\n\n对于足够大的 $N_{\\max}$，一个广泛使用且科学合理的收敛拟设是指数趋近，\n$$\nE(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}},\n$$\n其中 $c(\\hbar\\Omega) > 0$ 和 $d(\\hbar\\Omega) > 0$ 取决于基频 $\\hbar\\Omega$。该拟设体现了这样一种预期：随着 $N_{\\max}$ 的增加，由于核相互作用的短程特性以及 $\\hat{H}$ 的谱特性，截断误差会呈指数衰减。\n\n您的任务是设计并实现一种外推策略，该策略在给定几组不同 $\\hbar\\Omega$ 值的 $(N_{\\max}, E)$ 数据点集的情况下，拟合上述模型以估计 $E_{\\infty}$，然后选择在该数据集可用的最大 $N_{\\max}$ 处使估计的截断偏差最小化的 $\\hbar\\Omega$。将在最大 $N_{\\max}$ 处的截断偏差定义为\n$$\n\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega) = c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}^{\\mathrm{max}}},\n$$\n其中 $N_{\\max}^{\\mathrm{max}}$ 是用于该 $\\hbar\\Omega$ 的最大 $N_{\\max}$。最优外推策略是选择产生最小 $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$ 的 $\\hbar\\Omega$，并报告相应的外推能量 $E_{\\infty}$。\n\n实现一个完整、可运行的程序，严格按照给定顺序执行以下操作：\n\n- 对每个 $\\hbar\\Omega$ 数据集，通过非线性最小二乘法拟合模型 $E(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c\\,\\mathrm{e}^{-d\\,N_{\\max}}$ 中的参数 $\\{E_{\\infty}, c, d\\}$，强制施加 $c>0$、$d>0$ 和 $E_{\\infty}  \\min_{N_{\\max}} E(N_{\\max};\\hbar\\Omega)$ 以与变分上界性质保持一致。\n- 根据拟合得到的 $c$ 和 $d$ 以及数据集中的最大 $N_{\\max}$，计算 $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$。\n- 选择使 $\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega)$ 最小化的 $\\hbar\\Omega$，并记录其 $\\hbar\\Omega$ 值和相应的拟合 $E_{\\infty}$。\n- 对下面描述的测试套件中的每个情景重复上述步骤。\n\n使用以下科学上合理的合成 $^{4}\\mathrm{He}$ 收敛数据集测试套件，这些数据集由模型生成，具有已知的底层 $E_{\\infty}$ 和频率相关参数，且不含统计噪声。能量和频率必须以兆电子伏特 (MeV) 为单位处理。整数值 $N_{\\max}$ 是无量纲的。对于每个情景，程序必须构建数据集，然后执行拟合和选择。\n\n- 情景 A（理想情况，多频率，数据充足）：\n  - 真实渐近值 $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$。\n  - 频率和参数：\n    - $\\hbar\\Omega = 12.0\\,\\mathrm{MeV}$，其中 $c = 10.0\\,\\mathrm{MeV}$，$d = 0.35$。\n    - $\\hbar\\Omega = 16.0\\,\\mathrm{MeV}$，其中 $c = 7.0\\,\\mathrm{MeV}$，$d = 0.50$。\n    - $\\hbar\\Omega = 20.0\\,\\mathrm{MeV}$，其中 $c = 5.0\\,\\mathrm{MeV}$，$d = 0.60$。\n    - $\\hbar\\Omega = 24.0\\,\\mathrm{MeV}$，其中 $c = 6.5\\,\\mathrm{MeV}$，$d = 0.45$。\n  - 截断值：$N_{\\max} \\in \\{4, 6, 8, 10, 12\\}$。\n\n- 情景 B（边界条件，各频率数据点较少）：\n  - 真实渐近值 $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$。\n  - 频率和参数：\n    - $\\hbar\\Omega = 10.0\\,\\mathrm{MeV}$，其中 $c = 12.0\\,\\mathrm{MeV}$，$d = 0.30$。\n    - $\\hbar\\Omega = 16.0\\,\\mathrm{MeV}$，其中 $c = 8.0\\,\\mathrm{MeV}$，$d = 0.40$。\n    - $\\hbar\\Omega = 22.0\\,\\mathrm{MeV}$，其中 $c = 6.0\\,\\mathrm{MeV}$，$d = 0.50$。\n  - 截断值：$N_{\\max} \\in \\{4, 6, 8\\}$。\n\n- 情景 C（边缘情况，收敛缓慢）：\n  - 真实渐近值 $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$。\n  - 频率和参数：\n    - $\\hbar\\Omega = 14.0\\,\\mathrm{MeV}$，其中 $c = 9.0\\,\\mathrm{MeV}$，$d = 0.25$。\n    - $\\hbar\\Omega = 18.0\\,\\mathrm{MeV}$，其中 $c = 7.0\\,\\mathrm{MeV}$，$d = 0.28$。\n    - $\\hbar\\Omega = 22.0\\,\\mathrm{MeV}$，其中 $c = 5.0\\,\\mathrm{MeV}$，$d = 0.33$。\n  - 截断值：$N_{\\max} \\in \\{6, 8, 10, 12, 14\\}$。\n\n对于每个情景，程序必须输出选定的最优 $\\hbar\\Omega$（单位为 MeV）和相应的外推 $E_{\\infty}$（单位为 MeV），两者均四舍五入到三位小数。最终输出格式必须是单行，包含一个由方括号括起来的、由逗号分隔的六个浮点值列表：\n$[\\hbar\\Omega_{\\mathrm{opt}}^{A}, E_{\\infty}^{A}, \\hbar\\Omega_{\\mathrm{opt}}^{B}, E_{\\infty}^{B}, \\hbar\\Omega_{\\mathrm{opt}}^{C}, E_{\\infty}^{C}]$。\n输出行中不允许有任何额外文本。", "solution": "所提出的问题是计算核物理中一个有效且适定的任务。它要求实现一个标准的数据分析程序，用于将*从头计算*无核壳模型 (NCSM) 的结果外推到无限模型空间极限。该问题具有科学依据，采用了一个被广泛接受的指数收敛拟设，并为确定最优基参数和相应的外推能量提供了一个清晰、客观的程序。所有需要的数据和约束条件都已完全指定。因此，我们将着手提供一个完整的解决方案。\n\n基本目标是通过求解多体薛定谔方程 $\\hat{H}\\lvert\\Psi_0\\rangle = E_0 \\lvert\\Psi_0\\rangle$ 来确定 alpha 粒子 ${}^{4}\\text{He}$ 的基态能量 $E_0$。在 NCSM 框架中，核哈密顿量 $\\hat{H}$ 在一个由单粒子谐振子波函数构建的多体态基中被对角化。为了计算上的可行性，该基必须被截断。这种截断由参数 $N_{\\max}$ 控制，它限制了基态中允许的谐振子激发量子总数。单粒子基本身由谐振子频率 $\\hbar\\Omega$ 定义。\n\n计算出的基态能量，记作 $E(N_{\\max};\\hbar\\Omega)$，取决于这两个截断参数。变分原理保证了该能量是真实能量的上界，即 $E(N_{\\max};\\hbar\\Omega) \\ge E_0$。当 $N_{\\max}$ 趋于无穷大时，对于固定的 $\\hbar\\Omega$，计算出的能量预期会收敛到真实能量。对于足够大的 $N_{\\max}$，这种收敛可以很好地用指数模型描述：\n$$\nE(N_{\\max};\\hbar\\Omega) = E_{\\infty} + c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}}\n$$\n这里，$E_{\\infty}$ 代表在无限基极限 ($N_{\\max} \\to \\infty$) 下的外推基态能量。参数 $c(\\hbar\\Omega)  0$ 和 $d(\\hbar\\Omega)  0$ 是表征收敛速率的、与频率相关的正常数。\n\n任务是分析由该模型针对几种 $\\hbar\\Omega$ 选择生成的 $(N_{\\max}, E)$ 点的合成数据集。对于所提供的每种情景，我们必须确定最优的 $\\hbar\\Omega$ 和相应的外推能量 $E_{\\infty}$。最优性准则是在可用的最大 $N_{\\max}$（记作 $N_{\\max}^{\\mathrm{max}}$）处使截断偏差最小化。该偏差定义为在 $N_{\\max}^{\\mathrm{max}}$ 处的能量与外推渐近线之间的差值：\n$$\n\\Delta_{\\mathrm{trunc}}(\\hbar\\Omega) = E(N_{\\max}^{\\mathrm{max}};\\hbar\\Omega) - E_{\\infty} = c(\\hbar\\Omega)\\,\\mathrm{e}^{-d(\\hbar\\Omega)\\,N_{\\max}^{\\mathrm{max}}}\n$$\n较小的 $\\Delta_{\\mathrm{trunc}}$ 表示更快的收敛速度，因此对于给定的计算量（即给定的 $N_{\\max}^{\\mathrm{max}}$）来说，外推结果更可靠。\n\n算法流程如下：\n\n1.  **数据生成**：对于每个情景和每个指定的 $\\hbar\\Omega$，我们首先构建合成数据集。使用提供的真实渐近值 $E_{\\infty}^{\\mathrm{true}} = -28.30\\,\\mathrm{MeV}$、特定于频率的参数 $c$ 和 $d$ 以及 $N_{\\max}$ 值集，我们计算能量点 $E(N_{\\max}) = E_{\\infty}^{\\mathrm{true}} + c\\,\\mathrm{e}^{-d\\,N_{\\max}}$。\n\n2.  **约束非线性最小二乘拟合**：对于每个对应于单个 $\\hbar\\Omega$ 的数据集，我们拟合指数模型的参数 $\\{E_{\\infty}, c, d\\}$。该拟合使用 `scipy.optimize` 库中的 `curve_fit` 函数执行。为确保拟合的物理合理性，通过函数的 `bounds` 参数严格执行以下约束：\n    *   $E_{\\infty}  \\min_{i} E(N_{\\max,i};\\hbar\\Omega)$：外推能量必须低于任何计算数据点，以符合变分原理。\n    *   $c  0$：必须从上方收敛。\n    *   $d  0$：能量必须随着 $N_{\\max}$ 的增加而收敛。\n    由于数据集是由无噪声模型生成的，拟合过程预期将恢复数据生成步骤中使用的精确参数 $\\{E_{\\infty}^{\\mathrm{true}}, c, d\\}$。尽管如此，执行拟合是展示完整工作流程的关键部分。\n\n3.  **截断偏差计算**：利用拟合得到的参数 $\\{E_{\\infty}^{\\mathrm{fit}}, c^{\\mathrm{fit}}, d^{\\mathrm{fit}}\\}$，我们计算截断偏差 $\\Delta_{\\mathrm{trunc}} = c^{\\mathrm{fit}}\\,\\mathrm{e}^{-d^{\\mathrm{fit}}\\,N_{\\max}^{\\mathrm{max}}}$，其中 $N_{\\max}^{\\mathrm{max}}$ 是相应数据集中 $N_{\\max}$ 的最大值。\n\n4.  **最优参数选择**：在每个情景中，我们比较所有可用 $\\hbar\\Omega$ 频率下计算出的 $\\Delta_{\\mathrm{trunc}}$ 值。最优频率 $\\hbar\\Omega_{\\mathrm{opt}}$ 被确定为对应于最小 $\\Delta_{\\mathrm{trunc}}$ 的频率。该情景的最终结果包括这个 $\\hbar\\Omega_{\\mathrm{opt}}$ 及其相关的外推能量 $E_{\\infty}^{\\mathrm{fit}}$。\n\n对三个情景（A、B 和 C）中的每一个都重复此过程。最终输出将所有情景的最优频率和外推能量对聚合到一个格式化的字符串中。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Implements an extrapolation strategy for No-Core Shell Model calculations.\n    For each scenario, it fits an exponential convergence model to synthetic\n    data sets for several basis frequencies, selects the optimal frequency\n    based on minimum truncation bias, and reports the corresponding\n    extrapolated energy.\n    \"\"\"\n\n    def exponential_model(n_max, e_inf, c, d):\n        \"\"\"\n        Calculates energy based on the exponential convergence ansatz.\n        E(N_max) = E_inf + c * exp(-d * N_max)\n        \"\"\"\n        return e_inf + c * np.exp(-d * n_max)\n\n    scenarios = {\n        'A': {\n            'e_true': -28.30,\n            'n_max': [4, 6, 8, 10, 12],\n            'frequencies': [\n                {'hw': 12.0, 'c': 10.0, 'd': 0.35},\n                {'hw': 16.0, 'c': 7.0, 'd': 0.50},\n                {'hw': 20.0, 'c': 5.0, 'd': 0.60},\n                {'hw': 24.0, 'c': 6.5, 'd': 0.45},\n            ]\n        },\n        'B': {\n            'e_true': -28.30,\n            'n_max': [4, 6, 8],\n            'frequencies': [\n                {'hw': 10.0, 'c': 12.0, 'd': 0.30},\n                {'hw': 16.0, 'c': 8.0, 'd': 0.40},\n                {'hw': 22.0, 'c': 6.0, 'd': 0.50},\n            ]\n        },\n        'C': {\n            'e_true': -28.30,\n            'n_max': [6, 8, 10, 12, 14],\n            'frequencies': [\n                {'hw': 14.0, 'c': 9.0, 'd': 0.25},\n                {'hw': 18.0, 'c': 7.0, 'd': 0.28},\n                {'hw': 22.0, 'c': 5.0, 'd': 0.33},\n            ]\n        }\n    }\n\n    final_results = []\n    \n    # Iterate through scenarios in alphabetical order of keys to ensure consistent output\n    for scenario_key in sorted(scenarios.keys()):\n        scenario_data = scenarios[scenario_key]\n        e_true = scenario_data['e_true']\n        n_max_values = np.array(scenario_data['n_max'], dtype=float)\n        n_max_max = np.max(n_max_values)\n        \n        scenario_fit_results = []\n\n        for freq_params in scenario_data['frequencies']:\n            hw = freq_params['hw']\n            c_true = freq_params['c']\n            d_true = freq_params['d']\n\n            # Step 1: Generate synthetic data\n            e_values = exponential_model(n_max_values, e_true, c_true, d_true)\n\n            # Step 2: Perform constrained nonlinear least-squares fit\n            # Initial guess for the parameters [e_inf, c, d]\n            p0 = [e_values[-1] - 1.0, e_values[0] - e_values[-1], 0.5]\n            \n            # Define bounds: [E_inf, c, d]\n            # E_inf must be  min(E_values), c > 0, d > 0\n            lower_bounds = [-np.inf, 0, 0]\n            upper_bounds = [np.min(e_values), np.inf, np.inf]\n            bounds = (lower_bounds, upper_bounds)\n\n            try:\n                popt, _ = curve_fit(\n                    exponential_model,\n                    n_max_values,\n                    e_values,\n                    p0=p0,\n                    bounds=bounds,\n                    method='trf'\n                )\n                e_inf_fit, c_fit, d_fit = popt\n            except RuntimeError:\n                # In case of fit failure, we would handle it here.\n                # For this problem with perfect data, it's not expected.\n                e_inf_fit, c_fit, d_fit = np.nan, np.nan, np.nan\n\n            # Step 3: Compute truncation bias\n            delta_trunc = c_fit * np.exp(-d_fit * n_max_max)\n            \n            scenario_fit_results.append({\n                'hw': hw,\n                'e_inf': e_inf_fit,\n                'delta_trunc': delta_trunc\n            })\n\n        # Step 4: Select the optimal hw based on minimum truncation bias\n        best_fit = min(scenario_fit_results, key=lambda x: x['delta_trunc'])\n        \n        final_results.append(best_fit['hw'])\n        final_results.append(best_fit['e_inf'])\n\n    # Format the final output string as specified\n    output_str = '[' + ','.join(f'{v:.3f}' for v in final_results) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "3541307"}, {"introduction": "除了能量，从头计算方法还能预测丰富的核结构信息，例如核子的动量分布 $n(p)$。$n(p)$ 的高动量部分尤其引人关注，因为它直接探测了作为核力关键特征的短程关联。然而，这种物理行为不可避免地与核相互作用正则化所带来的赝象相混合。因此，理解如何区分物理标度行为和正则化因子引起的抑制效应，对于解释计算结果至关重要。通过一个可控的合成模型 [@problem_id:3541315]，这项练习让您能够探索源于短程物理的内禀幂律行为与不同正则化因子所产生的截断效应之间的相互作用，您将学习使用对数-对数分析这一标准技术来量化局域标度指数，从而提升您批判性分析和解读理论数据的能力。", "problem": "考虑一个轻核（如 ${}^{4}\\mathrm{He}$）的动量分布 $n(p)$，它由单体密度矩阵的傅里叶变换 (Fourier transform) 定义。从根本上说，一个有限、自束缚的费米系统 (Fermi system) 中的短程关联会在 $n(p)$ 的高动量尾部产生幂律行为，而真实的从头算 (ab initio) 相互作用中引入的调节子会改变其紫外行为。在本问题中，您将为 $n(p)$ 构建一个可控的合成模型，以分离出调节子赝象，并估计高 $p$ 尾部的局域标度指数。\n\n出发点（基本依据和建模假设）：\n- 单体动量分布 $n(p)$ 通过傅里叶变换 (Fourier transform) 与单体密度矩阵相关。对于具有短程关联的系统，在足够大的 $p$ 值下，$n(p)$ 的尾部表现出幂律标度行为。\n- 我们用一个有限程、短程主导的形式来模拟未经调节的“真实”尾部\n$$\nn_{\\mathrm{true}}(p) \\equiv \\frac{C}{\\left(1 + \\left(\\frac{p}{p_{0}}\\right)^{2}\\right)^{2}},\n$$\n该形式在大 $p$ 值下能正确地定性趋近于幂律，其中 $C$ 是一个归一化常数，$p_{0}$ 是一个动量标度，用于设定渐近区域的起始点。\n- 调节子 $R(p;\\Lambda,\\nu)$ 模拟了动量空间中经过调节的核相互作用或算符的效果。您将考虑两种选择：\n  1. 有理（软）调节子：\n  $$\n  R_{\\mathrm{rat}}(p;\\Lambda,\\nu) \\equiv \\frac{1}{1 + \\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}},\n  $$\n  其中 $\\Lambda$ 是一个截断标度，$\\nu$ 控制光滑度。\n  2. 指数（类高斯）调节子：\n  $$\n  R_{\\exp}(p;\\Lambda,\\nu) \\equiv \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}\\right].\n  $$\n- 经过调节的分布则为\n$$\nn_{\\mathrm{reg}}(p;\\Lambda,\\nu,\\mathrm{kind}) \\equiv n_{\\mathrm{true}}(p) \\times R(p;\\Lambda,\\nu),\n$$\n其中 $\\mathrm{kind}\\in\\{\\mathrm{rat},\\exp\\}$ 表示调节子的类型。\n\n任务：\n- 对于每个指定的测试用例，在一个包含 $N$ 个点（其中 $N=200$）的线性间隔动量网格 $p \\in [p_{\\min},p_{\\max}]$ 上构建 $n_{\\mathrm{reg}}(p)$。使用 $C = 1$（无量纲）和 $p_{0} = 0.5$（单位为反费米）。所有动量 $p$、$p_{\\min}$、$p_{\\max}$、$\\Lambda$ 和 $p_{0}$ 都必须以反费米（$\\mathrm{fm}^{-1}$）为单位处理。\n- 通过对网格上的 $\\ln n_{\\mathrm{reg}}(p)$ 与 $\\ln p$ 进行最小二乘线性拟合，来估计尾部的局域幂律指数 $\\alpha$。如果在窗口内的任何 $p$ 值处，$\\ln n_{\\mathrm{reg}}(p)$ 变得数值上病态（例如，由于下溢），则在取对数之前，将 $n_{\\mathrm{reg}}(p)$ 替换为 $\\max\\!\\left(n_{\\mathrm{reg}}(p),\\varepsilon\\right)$，其中 $\\varepsilon = 10^{-300}$。将拟合指数定义为\n$$\n\\alpha \\equiv -\\frac{d\\,\\ln n_{\\mathrm{reg}}(p)}{d\\,\\ln p}\n$$\n该指数由最佳拟合线的斜率得出。\n- 对于每个测试用例，返回单个拟合的 $\\alpha$ 值（无量纲），四舍五入到三位小数。\n\n测试套件（每行是一个测试用例，指定了 $(\\mathrm{kind},\\Lambda,\\nu,p_{\\min},p_{\\max})$）：\n- 用例 1：$(\\mathrm{rat},\\,20.0,\\,2,\\,4.0,\\,8.0)$\n- 用例 2：$(\\mathrm{rat},\\,2.5,\\,2,\\,4.0,\\,6.0)$\n- 用例 3：$(\\mathrm{rat},\\,3.5,\\,1,\\,2.5,\\,3.5)$\n- 用例 4：$(\\exp,\\,2.0,\\,1,\\,3.0,\\,4.0)$\n\n所有动量的单位均为 $\\mathrm{fm}^{-1}$，输出的 $\\alpha$ 值为无量纲。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\left[\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}\\right]$），每个 $\\alpha_{i}$ 都四舍五入到三位小数，且不含任何额外文本。本问题不涉及角度。请勿在数值输出中包含任何单位；仅报告四舍五入后的数字。\n\n科学真实性与自洽性：\n- 模型 $n_{\\mathrm{true}}(p)$ 捕捉了一种有限程趋近幂律尾部的行为，这与原子核中的短程关联一致。\n- 调节子族 $R_{\\mathrm{rat}}$ 和 $R_{\\exp}$ 代表了从头算核理论中常用的光滑调节子，它们具有预期的紫外抑制效应，可以改变尾部表现出的标度行为。\n- 通过对数-对数斜率提取指数是在数值数据中量化幂律行为的标准方法。\n\n最终输出格式：\n- 单行输出，包含列表 $\\left[\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}\\right]$，其中每个 $\\alpha_{i}$ 是一个浮点数，四舍五入到三位小数，按顺序对应于用例 1 到 4。", "solution": "该问题是有效的，因为它在科学上基于核物理原理，数学上是适定的，并且给出了客观、明确的规范。因此，我们可以着手求解。\n\n目标是计算在指定动量范围内，一个合成的核动量分布 $n_{\\mathrm{reg}}(p)$ 的高动量尾部的有效幂律指数 $\\alpha$。该分布模拟了有限费米系统 (Fermi system) 中的行为，包括从头算 (ab initio) 计算中常用调节子的效应。指数 $\\alpha$ 由关系式 $n(p) \\propto p^{-\\alpha}$ 定义，并通过在对数-对数表示中进行线性最小二乘拟合来提取。\n\n该过程包括三个主要步骤：（1）为每个测试用例构建经过调节的动量分布 $n_{\\mathrm{reg}}(p)$，（2）将数据转换到对数标度，以及（3）执行线性回归以找到斜率，从而确定 $\\alpha$。\n\n首先，我们定义模型的各个组成部分。在任何调节之前的“真实”基础动量分布由下式给出：\n$$\nn_{\\mathrm{true}}(p) \\equiv \\frac{C}{\\left(1 + \\left(\\frac{p}{p_{0}}\\right)^{2}\\right)^{2}}\n$$\n这种形式正确地捕捉了导致幂律尾部的短程关联的定性行为。对于大动量 $p \\gg p_0$，$n_{\\mathrm{true}}(p)$ 渐近趋近于 $\\frac{C p_0^4}{p^4}$，意味着幂律指数为 4。问题指定了无量纲常数 $C=1$ 和动量标度 $p_0=0.5\\,\\mathrm{fm}^{-1}$。\n\n接下来，我们引入一个调节子函数 $R(p;\\Lambda,\\nu)$，它模拟了来自经过调节的核相互作用的紫外抑制。考虑了两种类型的调节子：\n1. 有理调节子：\n$$\nR_{\\mathrm{rat}}(p;\\Lambda,\\nu) \\equiv \\frac{1}{1 + \\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}}\n$$\n2. 指数调节子：\n$$\nR_{\\exp}(p;\\Lambda,\\nu) \\equiv \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{2\\nu}\\right]\n$$\n在这里，$\\Lambda$ 是截断动量标度，$\\nu$ 是控制截断光滑度的参数。经过调节的动量分布是真实分布与调节子的乘积：\n$$\nn_{\\mathrm{reg}}(p;\\Lambda,\\nu,\\mathrm{kind}) \\equiv n_{\\mathrm{true}}(p) \\times R(p;\\Lambda,\\nu)\n$$\n其中 `kind` 指定了有理（`rat`）或指数（`exp`）形式。\n\n为了估计指数 $\\alpha$，我们分析分布的对数形式。假设在某个范围内存在局域幂律行为 $n_{\\mathrm{reg}}(p) \\approx A p^{-\\alpha}$，我们可以写出：\n$$\n\\ln n_{\\mathrm{reg}}(p) \\approx \\ln A - \\alpha \\ln p\n$$\n这表明 $\\ln n_{\\mathrm{reg}}(p)$ 近似是 $\\ln p$ 的线性函数。这个线性关系的斜率等于 $-\\alpha$。因此，指数 $\\alpha$ 可以确定为拟合点 $(\\ln p, \\ln n_{\\mathrm{reg}}(p))$ 的最佳拟合线斜率的相反数。\n\n对于每个测试用例，我们都给定了调节子类型（`kind`）、参数 $\\Lambda$ 和 $\\nu$ 以及一个动量窗口 $[p_{\\min}, p_{\\max}]$。数值计算步骤如下：\n1. 生成一个包含 $N=200$ 个点的离散动量网格 $p_i$，这些点在线性上均匀分布于 $p_{\\min}$ 和 $p_{\\max}$ 之间。\n2. 对于网格上的每个点 $p_i$，使用该测试用例指定的参数计算经过调节的分布值 $n_{\\mathrm{reg}}(p_i)$。\n3. 为了处理对极小数取对数时可能出现的数值下溢问题，我们应用一个下限值。我们计算 $n'_{\\mathrm{reg}}(p_i) = \\max(n_{\\mathrm{reg}}(p_i), \\varepsilon)$，其中 $\\varepsilon=10^{-300}$。\n4. 为线性拟合创建两个数据数组：$x_i = \\ln p_i$ 和 $y_i = \\ln n'_{\\mathrm{reg}}(p_i)$。\n5. 对数据点 $(x_i, y_i)$ 执行线性最小二乘回归以找到斜率 $m$。斜率的公式为：\n$$\nm = \\frac{\\sum_{i=1}^{N} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n$$\n其中 $\\bar{x}$ 和 $\\bar{y}$ 分别是对应数据数组的平均值。这个计算可以使用标准的数值库轻松实现。\n6. 那么，所求的局域标度指数为 $\\alpha = -m$。\n7. 每个用例的最终结果四舍五入到三位小数。\n\n将此过程应用于问题陈述中指定的全部四个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the local power-law exponent of a regulated nuclear momentum\n    distribution for a set of test cases.\n    \"\"\"\n    # Define constants and parameters from the problem statement.\n    C = 1.0  # Dimensionless normalization constant\n    p0 = 0.5  # Momentum scale in fm^-1\n    N = 200   # Number of points in the momentum grid\n    epsilon = 1e-300 # Floor value for numerical stability\n\n    # Test suite: (kind, Lambda, nu, p_min, p_max)\n    # Momenta are in fm^-1.\n    test_cases = [\n        ('rat', 20.0, 2, 4.0, 8.0),  # Case 1\n        ('rat', 2.5, 2, 4.0, 6.0),   # Case 2\n        ('rat', 3.5, 1, 2.5, 3.5),   # Case 3\n        ('exp', 2.0, 1, 3.0, 4.0),   # Case 4\n    ]\n\n    results = []\n    \n    # Define the model components as functions for clarity.\n    def n_true(p, c_val, p0_val):\n        \"\"\"Calculates the 'true' momentum distribution.\"\"\"\n        return c_val / (1 + (p / p0_val)**2)**2\n\n    def r_rat(p, lambda_val, nu_val):\n        \"\"\"Calculates the rational regulator.\"\"\"\n        return 1.0 / (1 + (p / lambda_val)**(2 * nu_val))\n\n    def r_exp(p, lambda_val, nu_val):\n        \"\"\"Calculates the exponential regulator.\"\"\"\n        return np.exp(-(p / lambda_val)**(2 * nu_val))\n        \n    for case in test_cases:\n        kind, Lambda, nu, p_min, p_max = case\n\n        # Step 1: Generate the momentum grid.\n        p_grid = np.linspace(p_min, p_max, N)\n\n        # Step 2: Construct the regulated distribution n_reg(p).\n        nt = n_true(p_grid, C, p0)\n        \n        if kind == 'rat':\n            R = r_rat(p_grid, Lambda, nu)\n        elif kind == 'exp':\n            R = r_exp(p_grid, Lambda, nu)\n        else:\n            # This case should not be reached with the given test suite.\n            raise ValueError(f\"Unknown regulator kind: {kind}\")\n            \n        n_reg = nt * R\n\n        # Step 3: Apply floor for numerical stability before taking the logarithm.\n        n_reg_stable = np.maximum(n_reg, epsilon)\n\n        # Step 4: Transform data to log-log scale.\n        log_p = np.log(p_grid)\n        log_n_reg = np.log(n_reg_stable)\n\n        # Step 5: Perform a linear least-squares fit to find the slope.\n        # np.polyfit with deg=1 returns [slope, intercept].\n        slope, _ = np.polyfit(log_p, log_n_reg, 1)\n\n        # Step 6: The exponent alpha is the negative of the slope.\n        alpha = -slope\n\n        # Step 7: Round to three decimal places and store the result.\n        results.append(round(alpha, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3541315"}]}