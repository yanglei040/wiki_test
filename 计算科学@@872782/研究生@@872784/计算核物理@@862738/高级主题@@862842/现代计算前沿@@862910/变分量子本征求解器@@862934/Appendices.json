{"hands_on_practices": [{"introduction": "在将量子计算机应用于核物理问题之前，我们必须首先将描述原子核的费米子哈密顿量转化为量子计算机可以直接处理的量子比特算符形式。这个练习将带你实践 Jordan-Wigner 变换，这是一种实现此转化的基本技术。通过亲手推导一个典型的双体相互作用项的泡利算符表示，你将掌握处理费米子算符及其在量子比特表象下性质的关键技能。[@problem_id:3611049]", "problem": "在计算核物理中，变分量子本征求解器（VQE）旨在最小化一个映射后的二次量子化哈密顿量的期望值，该哈密顿量包含形如 $a_{p}^{\\dagger} a_{q}^{\\dagger} a_{r} a_{s}$ 的两体正规序项。考虑一个壳模型哈密顿量项，它包含四个不同的单粒子轨道，由满足 $s  r  q  p$ 的整数索引 $\\{s, r, q, p\\}$ 指定。您的任务是确定在 Jordan–Wigner 变换下，这个费米子算符与粒子数算符之间的对易关系。\n\n具体来说，让 $\\tilde{O}$ 表示费米子算符 $O \\equiv a_{p}^{\\dagger} a_{q}^{\\dagger} a_{r} a_{s}$ 的 Jordan–Wigner 像，$\\tilde{n}_{k}$ 表示第 $k$ 个模式的粒子数算符 $n_{k} \\equiv a_{k}^{\\dagger} a_{k}$ 的 Jordan–Wigner 像。计算对易子 $[\\tilde{n}_{k}, \\tilde{O}]$，并用 $\\tilde{O}$ 本身来表示结果。您的答案应该对所有可能的 $k$ 值有效，包括那些与 $\\{s, r, q, p\\}$ 中的索引重合的情况。", "solution": "问题要求两个主要结果：首先，费米子算符 $O \\equiv a_{p}^{\\dagger} a_{q}^{\\dagger} a_{r} a_{s}$ 的 Jordan–Wigner (JW) 像 $\\tilde{O}$ 的显式泡利算符表达式；其次，对易子 $[\\tilde{n}_{k}, \\tilde{O}]$，其中 $\\tilde{n}_{k}$ 是粒子数算符 $n_{k} \\equiv a_{k}^{\\dagger} a_{k}$ 的 JW 像。给出的单粒子轨道整数索引是互不相同的，且顺序为 $s  r  q  p$。\n\n首先，我们回忆一下 Jordan-Wigner (JW) 变换：\n$$ a_j^\\dagger = \\left(\\prod_{k=0}^{j-1} (-i\\sigma_k^z)\\right) \\frac{\\sigma_j^x - i\\sigma_j^y}{2} = Z_0 Z_1 \\dots Z_{j-1} Q_j^\\dagger $$\n$$ a_j = \\left(\\prod_{k=0}^{j-1} (i\\sigma_k^z)\\right) \\frac{\\sigma_j^x + i\\sigma_j^y}{2} = Z_0 Z_1 \\dots Z_{j-1} Q_j $$\n其中 $Z_k \\equiv \\sigma_k^z$，而 $Q_j \\equiv (\\sigma_j^x + i\\sigma_j^y)/2$ 是泡利下降算符。\n粒子数算符 $n_k = a_k^\\dagger a_k$ 在 JW 变换下变为 $\\tilde{n}_k = (I - Z_k)/2$。\n\n最直接的方法是在费米子层面计算对易子，然后进行变换，因为 JW 变换是同构的。我们使用基本对易关系 $[n_k, a_j^\\dagger] = \\delta_{kj} a_j^\\dagger$ 和 $[n_k, a_j] = -\\delta_{kj} a_j$。\n利用算符乘积的对易子恒等式 $[A, BCD] = [A,B]CD + B[A,C]D + BC[A,D]$，我们有：\n$$\n[n_k, O] = [n_k, a_p^\\dagger a_q^\\dagger a_r a_s]\n$$\n$$\n= [n_k, a_p^\\dagger] a_q^\\dagger a_r a_s + a_p^\\dagger [n_k, a_q^\\dagger] a_r a_s + a_p^\\dagger a_q^\\dagger [n_k, a_r] a_s + a_p^\\dagger a_q^\\dagger a_r [n_k, a_s]\n$$\n$$\n= (\\delta_{kp} a_p^\\dagger) a_q^\\dagger a_r a_s + a_p^\\dagger (\\delta_{kq} a_q^\\dagger) a_r a_s + a_p^\\dagger a_q^\\dagger (-\\delta_{kr} a_r) a_s + a_p^\\dagger a_q^\\dagger a_r (-\\delta_{ks} a_s)\n$$\n由于费米子算符 $a_i^\\dagger, a_j^\\dagger$（$i \\neq j$）是反交换的，我们可以重新排列这些项以恢复原始算符 $O$ 的顺序。例如，对于第二项，我们有 $a_p^\\dagger (\\delta_{kq} a_q^\\dagger) = \\delta_{kq} (a_p^\\dagger a_q^\\dagger)$。因此，所有项的费米子算符部分都与 $O$ 的算符部分相同，只是前面有一个系数。\n$$\n[n_k, O] = \\delta_{kp} O + \\delta_{kq} O - \\delta_{kr} O - \\delta_{ks} O\n$$\n$$\n[n_k, O] = (\\delta_{kp} + \\delta_{kq} - \\delta_{kr} - \\delta_{ks}) O\n$$\n由于 JW 变换是一个同构映射，费米子算符的代数关系在映射到量子比特算符后保持不变。因此，对易子 $[\\tilde{n}_k, \\tilde{O}]$ 遵循相同的关系：\n$$\n[\\tilde{n}_{k}, \\tilde{O}] = (\\delta_{kp} + \\delta_{kq} - \\delta_{kr} - \\delta_{ks}) \\tilde{O}\n$$\n这个结果的物理意义是，粒子数算符 $n_k$ 测量模式 $k$ 是否被占据。如果 $O$ 中不涉及模式 $k$（即 $k \\notin \\{p,q,r,s\\}$），那么 $n_k$ 与 $O$ 对易。如果 $O$ 中涉及模式 $k$，则对易子非零。具体来说，如果 $O$ 在模式 $k$ 上有一个产生算符（$k=p$ 或 $k=q$），它会使 $k$ 模式的粒子数加一，因此 $[n_k, O]$ 的结果是 $+O$。如果 $O$ 在模式 $k$ 上有一个湮灭算符（$k=r$ 或 $k=s$），它会使 $k$ 模式的粒子数减一，因此 $[n_k, O]$ 的结果是 $-O$。将这些情况加起来就得到了最终的表达式。这个结论对于任何费米子-量子比特映射都是成立的，只要该映射保持了代数结构。", "answer": "$$\n\\boxed{(\\delta_{kp} + \\delta_{kq} - \\delta_{kr} - \\delta_{ks})\\tilde{O}}\n$$", "id": "3611049"}, {"introduction": "拥有了量子比特哈密顿量后，下一步是构建一个高效的变分拟设（ansatz）来制备基态的近似。在核物理中，酉耦合簇（Unitary Coupled Cluster, UCC）等拟设通常由费米子激发算符构建，这些算符必须被编译成量子门线路才能在硬件上运行。本练习模拟了将一个基本的费米子激发酉算符编译到具有特定连接性约束的真实量子设备上的过程，让你能够量化评估量子算法的资源成本。[@problem_id:3611068]", "problem": "你需要形式化并分析在用于二次量子化中原子核哈密顿量的变分量子本征求解器（VQE）拟设（ansätze）中，单个反厄米费米子激发的编译过程。考虑幺正算符\n$$\nU_{p,q}(\\theta) \\equiv \\exp\\!\\big(\\,\\theta\\,(a_p^\\dagger a_q - a_q^\\dagger a_p)\\big),\n$$\n其中 $a_j^\\dagger$ 和 $a_j$ 是正则费米子产生和湮滅算符，满足 $\\{a_i,a_j\\}=\\{a_i^\\dagger,a_j^\\dagger\\}=0$ 和 $\\{a_i,a_j^\\dagger\\}=\\delta_{ij}$，且 $\\theta \\in \\mathbb{R}$ 是一个以弧度为单位指定的角度。采用 Jordan–Wigner 变换将费米子映射到量子比特，模式的标准线性排序为 $0,1,\\dots,n-1$，并假设以下设备和编译模型：\n- 原生单量子比特门是任意旋转门，其产生的双量子比特深度为零。\n- 唯一的原生双量子比特纠缠门是受控非门（CNOT），可在量子比特的无向连通图 $G=(V,E)$ 上使用，每并行执行一层互不相交的 CNOT 门，其代价为一个单位的双量子比特深度。\n- 一个 SWAP 门编译为一条边上的恰好三个 CNOT 门，并调度为该边上的三个串行的双量子比特层。\n- 对于在 Jordan–Wigner 排序中相邻且在硬件连通图上是邻居的模式 $p$ 和 $q$，幺正算符 $U_{p,q}(\\theta)$ 可以用恰好两个与单量子比特旋转交错的 CNOT 层来编译。\n- 对于非相邻或非邻居的模式，您必须遵循硬件连通性：要在远程量子比特 $p$ 和 $q$ 之间执行双量子比特操作，您必须沿着长度为 $D$ 条边的最短路径路由一个量子比特，直到两个量子比特相邻且成为邻居，然后应用相邻激发的双 CNOT 实现，最后通过反向执行 SWAP 门来恢复原始布局。此路由过程需要 $D-1$ 个 SWAP 门将量子比特聚集在一起，再需要 $D-1$ 个 SWAP 门恢复原始布局，每个 SWAP 门贡献三个 CNOT 层。\n\n将已编译线路的双量子比特深度定义为在上述模型下编译所需的 CNOT 门串行层的最小数量。在该模型下，对于作用于模式 $p$ 和 $q$ 的单个激发 $U_{p,q}(\\theta)$，其在连通图上的最短路径长度为 $D$（以边的数量计），并约定如果 $p=q$ 则 $U_{p,p}(\\theta)$ 是单位算符，要报告的深度如下：\n- 如果 $p=q$，报告 $0$。\n- 否则，如果 $p$ 和 $q$ 在图中不连通，报告 $-1$。\n- 否则，报告整数值\n$$\nd_{\\mathrm{two\\mbox{-}qubit}}(D) \\;=\\; 6\\,(D-1) \\;+\\; 2.\n$$\n\n你的任务是编写一个完整的、可运行的程序，对于下面描述的每个测试用例，该程序需要构建连通图，计算 $p$ 和 $q$ 之间的最短路径距离 $D$（以边的数量计），并根据上述规则输出相应的双量子比特深度。角度 $\\theta$ 以弧度给出；在此编译模型中，双量子比特深度不依赖于 $\\theta$ 的值，但为了完整性，你仍需将 $\\theta$ 视为输入参数。\n\n需要实现的测试套件：\n- 测试用例 1（正常路径）：包含 $n=6$ 个节点（标记为 0 到 5）的线性链，边为 $\\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$，参数为 $(p,q,\\theta)=(1,4,0.7)$。\n- 测试用例 2（相邻对）：与测试用例 1 相同的线性链，参数为 $(p,q,\\theta)=(2,3,1.2)$。\n- 测试用例 3（星形拓扑）：包含 $n=6$ 个节点的星形图，中心节点 0 连接到叶节点 1 到 5，边为 $\\{(0,1),(0,2),(0,3),(0,4),(0,5)\\}$，参数为 $(p,q,\\theta)=(1,5,0.3)$。\n- 测试用例 4（不连通图）：两个不相交的链，分别位于节点 $\\{0,1,2\\}$ 和 $\\{3,4,5\\}$ 上，边为 $\\{(0,1),(1,2),(3,4),(4,5)\\}$，参数为 $(p,q,\\theta)=(1,5,0.9)$。\n- 测试用例 5（单位算符边界情况）：包含 $n=5$ 个节点（标记为 0 到 4）的线性链，边为 $\\{(0,1),(1,2),(2,3),(3,4)\\}$，参数为 $(p,q,\\theta)=(2,2,2.0)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”）。每个结果必须是为上面列出的相应测试用例计算出的双量子比特深度的整数值。", "solution": "问题陈述经评估有效。其科学基础在于量子计算和凝聚态物理学的原理，特别是关于变分量子本征求解器（VQE）算法中费米算符的编译。该问题是良构的、客观的，并为得出唯一且可验证的解提供了完整且一致的定义和约束集。\n\n核心任务是计算在具有指定量子比特连通图 $G=(V,E)$ 的量子计算机上实现幺正算符 $U_{p,q}(\\theta) = \\exp(\\theta(a_p^\\dagger a_q - a_q^\\dagger a_p))$ 所需的双量子比特门深度。该深度由一套规则决定，这些规则取决于图中量子比特（节点）$p$ 和 $q$ 之间的最短路径距离 $D$。\n\n解决每个测试用例的计算策略如下：\n\n首先，我们处理 $p=q$ 的平凡情况。在这种情况下，算符生成元为 $a_p^\\dagger a_p - a_p^\\dagger a_p = 0$，使得幺正算符为 $U_{p,p}(\\theta) = \\exp(0) = I$，即单位算符。实现单位算符不需要任何门，因此其双量子比特深度正确地报告为 $0$。\n\n其次，对于 $p \\neq q$ 的情况，我们必须确定图 $G$ 中节点 $p$ 和 $q$ 之间的连通性和距离。该图的边是未加权的，意味着遍历任何边的成本都是统一的。因此，最短路径距离 $D$ 就是连接 $p$ 和 $q$ 的路径中的最小边数。广度优先搜索（BFS）算法是在未加权图中寻找最短路径的标准方法。\nBFS 算法从源节点 $p$ 开始，逐层探索图：先探索其邻居，然后是这些邻居的邻居，依此类推。我们维护一个从 $p$ 到所有其他节点的距离数组，并将其初始化为一个表示不可达的值（例如 $-1$）。到起始节点 $p$ 的距离为 $0$。当 BFS 探索到达目标节点 $q$ 时，记录的距离即为最短路径长度 $D$。如果 BFS 算法完成时从未到达 $q$，则意味着 $p$ 和 $q$位于图的不连通分量中。\n\n第三，一旦确定了最短路径距离 $D$，我们就应用问题陈述中提供的规则来计算双量子比特深度：\n- 如果节点 $p$ 和 $q$ 不连通，深度报告为 $-1$。这对应于我们的 BFS 搜索从 $p$ 出发未能到达 $q$ 的情况。\n- 如果节点连通，最短路径距离为 $D \\ge 1$，则使用公式 $d_{\\mathrm{two\\mbox{-}qubit}}(D) = 6(D-1) + 2$ 计算深度。该公式由编译模型推导得出：为了使量子比特 $p$ 和 $q$ 相互作用，必须将其中一个沿着最短路径移动到另一个旁边。这需要 $D-1$ 个 SWAP 门，每个编译为 $3$ 个串行的 CNOT 层。此路由操作之后，在现在相邻的量子比特 $p'$ 和 $q'$ 上执行核心操作 $U_{p',q'}(\\theta)$，这需要 $2$ 个 CNOT 层。最后，通过另外 $D-1$ 个 SWAP 门反向执行路由以恢复原始的量子比特映射，这又增加了 $3(D-1)$ 个 CNOT 层。因此，总深度为 $3(D-1) + 2 + 3(D-1) = 6(D-1) + 2$。对于 $p$ 和 $q$ 已经是邻居的基本情况，$D=1$，公式正确地得出 $d(1) = 6(1-1) + 2 = 2$。\n\n作为一个具体例子，让我们追踪测试用例 1：在一个具有 6 个节点和边 $\\{(i, i+1)\\}$ 的线性链上，节点为 $p=1$ 和 $q=4$。\n1.  我们构建该线性链图的邻接表表示。\n2.  我们从源节点 $p=1$ 开始进行 BFS。\n    - 队列初始化为 $[(1, 0)]$，距离数组中 $d[1]=0$。\n    - 将 $(1,0)$ 出队。将邻居 $(0,1)$ 和 $(2,1)$ 入队。设置 $d[0]=1, d[2]=1$。\n    - 将 $(0,1)$ 出队。邻居 $1$ 已被访问。\n    - 将 $(2,1)$ 出队。将邻居 $(3,2)$ 入队。设置 $d[3]=2$。\n    - 将 $(3,2)$ 出队。将邻居 $(4,3)$ 入队。设置 $d[4]=3$。\n3.  目标节点 $q=4$ 已到达，距离 $D=3$。\n4.  我们应用深度公式：$d(3) = 6(3-1) + 2 = 6(2) + 2 = 12 + 2 = 14$。此用例的结果是 $14$。\n\n此系统性步骤将应用于每个测试用例，以生成所需的整数结果列表。角度 $\\theta$ 是幺正算符的一个参数，但在该编译模型中不影响 CNOT 的数量，因此在计算中不使用它。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Computes the two-qubit depth for implementing a fermionic excitation\n    U_{p,q}(theta) on a quantum device with a given connectivity graph.\n    \"\"\"\n    \n    # Test suite to implement as per the problem description.\n    # Each tuple is (n, edges, p, q, theta).\n    test_cases = [\n        # Test case 1: linear chain, n=6, (p,q)=(1,4)\n        (6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)], 1, 4, 0.7),\n        # Test case 2: linear chain, n=6, (p,q)=(2,3)\n        (6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)], 2, 3, 1.2),\n        # Test case 3: star topology, n=6, (p,q)=(1,5)\n        (6, [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)], 1, 5, 0.3),\n        # Test case 4: disconnected graph, n=6, (p,q)=(1,5)\n        (6, [(0, 1), (1, 2), (3, 4), (4, 5)], 1, 5, 0.9),\n        # Test case 5: identity edge case, n=5, (p,q)=(2,2)\n        (5, [(0, 1), (1, 2), (2, 3), (3, 4)], 2, 2, 2.0),\n    ]\n\n    results = []\n\n    for n, edges, p, q, theta in test_cases:\n        # Case 1: p = q. Unitary is identity, depth is 0.\n        if p == q:\n            results.append(0)\n            continue\n\n        # Build adjacency list for the graph\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        # Use Breadth-First Search (BFS) to find the shortest path distance\n        # Initialize distances array to -1, indicating unreachability.\n        distances = [-1] * n\n        queue = deque([(p, 0)])  # Queue stores tuples of (node, distance)\n        distances[p] = 0\n\n        # Process the queue until it's empty\n        path_found = False\n        while queue:\n            node, dist = queue.popleft()\n\n            # If we find the target node, we can stop early\n            if node == q:\n                path_found = True\n                break\n\n            for neighbor in adj[node]:\n                # If neighbor has not been visited yet\n                if distances[neighbor] == -1:\n                    distances[neighbor] = dist + 1\n                    queue.append((neighbor, dist + 1))\n        \n        # Get the shortest-path distance D to node q\n        D = distances[q]\n\n        # Case 2: p and q are disconnected.\n        if D == -1:\n            results.append(-1)\n        # Case 3: p and q are connected.\n        else:\n            # Apply the given formula for two-qubit depth\n            depth = 6 * (D - 1) + 2\n            results.append(depth)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3611068"}, {"introduction": "VQE 算法的核心是一个经典的优化循环，它不断调整变分参数以最小化在量子计算机上测量的能量。然而，真实的量子设备存在噪声，这使得能量测量值充满不确定性，对优化过程构成了巨大挑战。这个练习将引导你深入分析不同经典优化器在现实噪声模型下的表现，通过权衡各种噪声来源和有限的测量次数，学习如何选择最稳健的优化策略。[@problem_id:3611032]", "problem": "您正在为一个低原子质量数（小$A$）的原子核系统，特别是氘核（$A=2$），设计一个变分量子本征求解器（VQE）。您使用的是一个具有$d$个实数参数（记为$\\boldsymbol{\\theta}\\in\\mathbb{R}^d$）的硬件高效拟设（hardware-efficient ansatz）。目标函数是基于一个真实的低能原子核哈密顿量$\\hat{H}$的参数化基态能量$E(\\boldsymbol{\\theta})=\\langle \\psi(\\boldsymbol{\\theta})|\\hat{H}|\\psi(\\boldsymbol{\\theta})\\rangle$。假设在最优点$\\boldsymbol{\\theta}^{\\star}$附近，能量景观是局部强凸的，其海森矩阵的特征值被限制在区间$[m,L]$内，其中$m0$且$Lm$。实验在一个有噪声的量子设备上运行。每次能量评估返回一个估计值$\\widehat{E}(\\boldsymbol{\\theta})=E(\\boldsymbol{\\theta})+\\epsilon$，其中误差$\\epsilon$有两个来源：\n- 一个散粒噪声项，模型为近似高斯分布，方差为$\\sigma_{s}^2/N$，其中$N$是分配给该次能量评估的测量次数（shots），$\\sigma_{s}^2=\\mathrm{Var}_{\\psi(\\boldsymbol{\\theta})}(\\hat{H})$是在参数$\\boldsymbol{\\theta}$处的内禀能量方差，\n- 一个设备噪声项$\\eta(t)$，可以建模为一个零均值、平稳过程，其方差为$\\sigma_{d}^2$，相关函数为$C(\\Delta t)=\\sigma_{d}^2 e^{-|\\Delta t|/\\tau_c}$，其中$\\tau_c$是相关时间，$t$是评估的挂钟时间。\n\n假设在一个小基组下的氘核VQE实验中，有以下实际参数值：\n- 参数维度$d=12$，\n- 海森矩阵特征值界限 $m=0.5\\,\\mathrm{MeV}/\\mathrm{rad}^2$ 和 $L=5\\,\\mathrm{MeV}/\\mathrm{rad}^2$ （条件数 $\\kappa=L/m=10$），\n- 每次迭代的测量总预算 $S_{\\mathrm{tot}}=4\\times 10^4$，\n- 在局部盆地内，内禀方差上限为 $\\sigma_{s}^2\\leq (1\\,\\mathrm{MeV})^2$，\n- 设备噪声方差 $\\sigma_{d}^2=(0.05\\,\\mathrm{MeV})^2$ 且相关时间 $\\tau_c=1\\,\\mathrm{s}$，\n- 单次能量评估的挂钟时间约为 $t_{\\mathrm{eval}}=0.05\\,\\mathrm{s}$（主要由电路编程和采样开销决定，而单次评估内的测量采样速度足够快，可以认为是同步的），\n- 当两次能量评估在宽度为 $\\Delta t\\ll \\tau_c$ 的时间窗口内背靠背执行时，设备噪声分量高度相关，相关系数为 $\\rho\\simeq e^{-\\Delta t/\\tau_c}$。\n\n您需要从三种经典优化器中做出选择：\n- 有限内存的Broyden-Fletcher-Goldfarb-Shanno（L-BFGS）算法，使用参数移位（parameter-shift）梯度和回溯Armijo-Wolfe线搜索，\n- 同步扰动随机近似（SPSA）算法，采用半径为$c0$的两点随机扰动、衰减的步长$a_k$、衰减的扰动半径$c_k$以及Polyak-Ruppert迭代平均，\n- 协方差矩阵自适应演化策略（CMA-ES）算法，采用秩-$\\mu$更新和中等大小的种群，种群大小$\\lambda$由启发式规则$\\lambda=4+\\lfloor 3\\log d\\rfloor$选择，除非您的分析证明有必要，否则不进行显式重采样。\n\n所有方法都必须在每次迭代固定的测量总预算$S_{\\mathrm{tot}}$下运行。您可以假设，对于SPSA，每次迭代的两次能量评估是在一个宽度约为$\\Delta t\\simeq 2 t_{\\mathrm{eval}}$的窗口内背靠背执行的；而对于CMA-ES，$\\lambda$次评估则分布在整个迭代过程中，其时间间隔在$t_{\\mathrm{eval}}$到$10\\,t_{\\mathrm{eval}}$的量级。对于L-BFGS，假设参数移位梯度在每次迭代中每个参数需要$2$次能量评估，线搜索平均每次迭代额外需要$4$次能量评估；对于给定的参数，所有用于计算梯度的成对评估都是背靠背执行的。\n\n请从以上定义以及关于随机近似和拟牛顿法的标准知识出发，推断哪种优化器有望在固定的挂钟时间预算内，实现最稳健的收敛，达到一个半径与噪声基底相当的$\\boldsymbol{\\theta}^{\\star}$邻域。请通过推导由噪声模型、每次迭代的测量分配以及曲率信息$[m,L]$产生的相关信噪比权衡来证明您的选择。在您的论证中，请明确分析相关的设备噪声如何影响成对差分估计量的方差，以及每次迭代的测量分配如何与优化器的采样模式相互作用。\n\n您选择哪个选项？\n\nA. L-BFGS，使用参数移位梯度和回溯Armijo-Wolfe线搜索，因为拟牛顿法的曲率加速作用能够主导噪声效应；成对的梯度评估能充分抵消设备噪声，且线搜索能在随机噪声下可靠地优化步长。\n\nB. SPSA，使用两点对称扰动、衰减的增益序列和Polyak-Ruppert迭代平均，因为背靠背的测量利用了差分估计器中的共模设备噪声抵消效应，同时每次迭代仅使用2次评估，从而集中了测量次数，提高了梯度信噪比，并确保了在强凸盆地中的随机近似收敛。\n\nC. CMA-ES，使用$\\lambda=4+\\lfloor 3\\log d\\rfloor$且不进行重采样，因为基于排序的选择对单调噪声失真具有不变性，且基于种群的搜索能够平均掉不同候选者之间的设备噪声，从而在低维度下实现稳健的进展。\n\nD. CMA-ES，使用相同的$\\lambda$但对排名前$\\mu$的候选者各重采样$r=3$次以减少测量噪声，因为即使在设备噪声占主导地位时，重采样也能消除排序错误，并且每次迭代增加的评估次数仍与固定的测量预算兼容。", "solution": "该问题要求在一个真实的噪声模型和一个固定的计算预算下，对三种优化算法——L-BFGS、SPSA和CMA-ES——进行比较分析，以应用于一个变分量子本征求解器（VQE）实验。目标是确定哪种优化器在寻找氘核基态方面最为稳健和高效。\n\n首先，我将形式化噪声模型，并分析其对有限差分测量的影响，这是L-BFGS和SPSA中梯度估计的基础。\n\n在挂钟时间$t$进行一次使用$N$次测量的能量评估，会得到一个带噪声的估计值$\\widehat{E}(\\boldsymbol{\\theta}) = E(\\boldsymbol{\\theta}) + \\epsilon_s + \\eta(t)$。单次测量的总噪声方差为$\\mathrm{Var}(\\widehat{E}) = \\mathrm{Var}(\\epsilon_s) + \\mathrm{Var}(\\eta(t)) = \\sigma_s^2/N + \\sigma_d^2$。\n\n优化器通常使用两点有限差分来估计梯度或能量变化：$\\Delta \\widehat{E} = \\widehat{E}_1 - \\widehat{E}_2$，其中两次评估的时间间隔为$\\Delta t = |t_1 - t_2|$。该差值的方差为：\n$$ \\mathrm{Var}(\\Delta \\widehat{E}) = \\mathrm{Var}(\\widehat{E}_1) + \\mathrm{Var}(\\widehat{E}_2) - 2\\mathrm{Cov}(\\widehat{E}_1, \\widehat{E}_2) $$\n散粒噪声$\\epsilon_s$对于不同的评估是独立的。设备噪声$\\eta(t)$随时间是相关的。假设每次评估分配的测量次数相等（$N_1 = N_2 = N$），则方差变为：\n$$ \\mathrm{Var}(\\Delta \\widehat{E}) = \\left(\\frac{\\sigma_s^2}{N} + \\sigma_d^2\\right) + \\left(\\frac{\\sigma_s^2}{N} + \\sigma_d^2\\right) - 2\\mathrm{Cov}(\\eta(t_1), \\eta(t_2)) $$\n使用给定的相关函数$C(\\Delta t) = \\mathrm{Cov}(\\eta(t_1), \\eta(t_2)) = \\sigma_d^2 e^{-|\\Delta t|/\\tau_c}$：\n$$ \\mathrm{Var}(\\Delta \\widehat{E}) = \\frac{2\\sigma_s^2}{N} + 2\\sigma_d^2 - 2\\sigma_d^2 e^{-\\Delta t/\\tau_c} = \\frac{2\\sigma_s^2}{N} + 2\\sigma_d^2(1 - e^{-\\Delta t/\\tau_c}) $$\n这个方程是分析的核心。它揭示了两个关键效应：\n1.  **散粒噪声**：来自散粒噪声的贡献$2\\sigma_s^2/N$，可以通过增加每次评估的测量次数$N$来减小。\n2.  **设备噪声**：来自设备噪声的贡献$2\\sigma_d^2(1 - e^{-\\Delta t/\\tau_c})$，可以通过使两次测量在时间上非常接近（即$\\Delta t \\ll \\tau_c$）来减小。这种效应被称为共模噪声抑制。\n\n现在，让我们在给定参数的背景下分析每种优化器：$d=12$, $S_{\\mathrm{tot}}=4\\times 10^4$, $\\sigma_s^2 \\le (1\\,\\mathrm{MeV})^2$, $\\sigma_d^2=(0.05\\,\\mathrm{MeV})^2 = 0.0025\\,\\mathrm{MeV}^2$, $\\tau_c=1\\,\\mathrm{s}$以及$t_{\\mathrm{eval}}=0.05\\,\\mathrm{s}$。\n\n**1. L-BFGS (Limited-memory Broyden-Fletcher-Goldfarb-Shanno)**\n*   **每次迭代的评估次数**：通过参数移位（此处等同于中心差分）计算梯度需要$2d = 2 \\times 12 = 24$次评估。线搜索假设需要额外$4$次评估，总计$N_{\\mathrm{eval}} = 28$。\n*   **每次评估的测量次数**：测量预算被分散得很薄：$N = S_{\\mathrm{tot}} / N_{\\mathrm{eval}} = 40000 / 28 \\approx 1428$。\n*   **噪声分析**：参数$\\theta_j$的梯度分量是通过一对评估来估计的。这些评估是背靠背执行的，因此可以假设$\\Delta t \\approx 2t_{\\mathrm{eval}} = 0.1\\,\\mathrm{s}$。相关因子为$e^{-\\Delta t/\\tau_c} = e^{-0.1/1} \\approx 0.905$。\n    梯度分量的能量差方差为：\n    $$ \\mathrm{Var}(\\Delta \\widehat{E})_{\\text{L-BFGS}} \\approx \\frac{2(1)^2}{1428} + 2(0.0025)(1 - 0.905) \\approx 0.00140 + 0.005(0.095) \\approx 0.00188\\,\\mathrm{MeV}^2 $$\n    散粒噪声项（$0.00140$）占主导地位。每次评估的测量次数少导致梯度噪声大。此外，像L-BFGS这样的拟牛顿法对梯度中的噪声非常敏感，因为噪声会破坏海森矩阵逆的近似。在随机函数评估下，回溯线搜索也不可靠，因为Armijo-Wolfe条件可能会因统计波动而满足或不满足。\n\n**2. SPSA (Simultaneous Perturbation Stochastic Approximation)**\n*   **每次迭代的评估次数**：SPSA非常高效，每次迭代仅需$N_{\\mathrm{eval}} = 2$次评估，与维度$d$无关。\n*   **每次评估的测量次数**：这使得测量预算可以大规模集中：$N = S_{\\mathrm{tot}} / N_{\\mathrm{eval}} = 40000 / 2 = 20000$。\n*   **噪声分析**：两次评估是背靠背执行的，$\\Delta t \\approx 2t_{\\mathrm{eval}} = 0.1\\,\\mathrm{s}$，与L-BFGS的成对评估相同。相关因子同样为$e^{-0.1} \\approx 0.905$。\n    能量差的方差为：\n    $$ \\mathrm{Var}(\\Delta \\widehat{E})_{\\text{SPSA}} \\approx \\frac{2(1)^2}{20000} + 2(0.0025)(1 - 0.905) \\approx 0.00010 + 0.00048 \\approx 0.00058\\,\\mathrm{MeV}^2 $$\n    两个噪声项都得到了显著抑制。由于测量次数多，与L-BFGS相比，散粒噪声减少了一个数量级以上。由于是背靠背测量，相关的设备噪声被有效抵消。这使得梯度估计的信噪比大大提高。作为一种具有衰减步长和Polyak-Ruppert平均的随机近似算法，SPSA从设计上就是为了在存在零均值噪声的情况下收敛。它的主要弱点是缺乏曲率信息，但在这种场景下，对噪声的稳健性比曲率信息更重要。\n\n**3. CMA-ES (Covariance Matrix Adaptation Evolution Strategy)**\n*   **每次迭代的评估次数**：种群大小为$\\lambda = 4 + \\lfloor 3\\log d\\rfloor = 4 + \\lfloor 3\\log 12\\rfloor = 4 + 7 = 11$。因此，$N_{\\mathrm{eval}} = 11$。\n*   **每次评估的测量次数**：$N = S_{\\mathrm{tot}} / N_{\\mathrm{eval}} = 40000 / 11 \\approx 3636$。\n*   **噪声分析**：问题描述指出，评估在时间上是分布的，间隔在$t_{\\mathrm{eval}}$到$10\\,t_{\\mathrm{eval}}$（$0.05\\,\\mathrm{s}$到$0.5\\,\\mathrm{s}$）的量级。这意味着种群中不同成员之间的设备噪声基本上是不相关的。因此，影响每个候选者适应度的噪声近似独立。单次能量评估的方差为：\n    $$ \\mathrm{Var}(\\widehat{E})_{\\text{CMA-ES}} \\approx \\frac{(1)^2}{3636} + 0.0025 \\approx 0.000275 + 0.0025 = 0.002775\\,\\mathrm{MeV}^2 $$\n    噪声标准差为$\\sigma_{\\epsilon} = \\sqrt{0.002775} \\approx 0.053\\,\\mathrm{MeV}$。占主导地位的项是设备噪声$\\sigma_d^2$，它没有被抵消。CMA-ES的核心机制是根据候选者的适应度对其进行排序。如果噪声水平$\\sigma_{\\epsilon}$与候选者之间的典型能量差异相当，排序将被破坏，导致搜索分布的均值和协方差矩阵的更新不正确。这会严重阻碍或使收敛停滞。\n\n**结论**\nSPSA提供了最引人注目的策略。它是唯一能够同时有效缓解散粒噪声（通过集中测量预算）和相关设备噪声（通过利用背靠背测量的共模抑制）的方法。这使得每次迭代能获得最高质量的梯度信息。L-BFGS的函数调用次数太多，使其易受散粒噪声影响，且其内部机制对噪声不稳健。CMA-ES未能利用设备噪声的相关性，导致其排序过程不可靠。\n\n**评估选项：**\n\n*   **A. L-BFGS**：此选项不正确。它错误地声称拟牛顿加速将主导噪声效应，且线搜索是可靠的。在高噪声环境中，情况恰恰相反：噪声主导了算法的稳定性。\n*   **B. SPSA**：此选项正确。它正确地指出了SPSA在这种场景下的两个关键优势。它强调了通过背靠背测量实现的共模设备噪声抵消，以及通过集中测量预算提高的信噪比。它还正确地提到了用于确保收敛的随机近似的理论基础。这与推导完全一致。\n*   **C. CMA-ES**：此选项不正确。它误解了CMA-ES的稳健性。声称基于种群的搜索能“平均掉”设备噪声在这种情况下是错误的；相反，未被抵消的噪声会破坏作为该算法更新规则核心的排序过程。\n*   **D. CMA-ES与重采样**：此选项为CMA-ES的噪声脆弱性提出了一个补丁，但忽略了其成本。重采样需要更多评估，这会摊薄每次评估的测量预算，可能导致初始排序的散粒噪声增加得比重采样带来的帮助还多。它没有解决CMA-ES未能利用设备噪声时间相关性这一根本问题，而SPSA则“免费”获得了这一好处。因此，这不是最优策略。\n\n针对指定问题，最稳健有效的优化器是SPSA。", "answer": "$$\\boxed{B}$$", "id": "3611032"}]}