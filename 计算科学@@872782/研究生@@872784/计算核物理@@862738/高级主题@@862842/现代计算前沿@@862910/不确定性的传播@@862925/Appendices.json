{"hands_on_practices": [{"introduction": "不确定性传播的基石之一是泰勒级数展开。该方法通过使用简单的多项式（通常是线性的）来近似一个复杂的函数，从而可以直接计算输出量的矩。本练习 [@problem_id:3581693] 提供了一个具体示例，使用函数 $y=x^2$ 来直接比较一阶和二阶近似的结果与精确的解析解，这有助于培养关于近似误差来源和大小的直观理解。", "problem": "在计算核物理的不确定性量化中，通常需要将模型参数的不确定性传播到导出的可观测量。考虑一个由 $y=f(x)=x^{2}$ 定义的简化代理可观测量，其中标量参数 $x$ 代表输运响应模型中的一个无量纲校准缩放因子，并被建模为高斯随机变量 $x \\sim \\mathcal{N}(\\mu,\\sigma^{2})$。设 $\\mu=1.2$ 且 $\\sigma=0.15$。\n\n从期望和方差的定义出发，并利用高斯分布的已知矩，推导出 $y$ 的均值 $\\mathbb{E}[y]$ 和方差 $\\mathrm{Var}(y)$ 的精确表达式。然后，使用 $f$ 在 $x=\\mu$ 附近的 Taylor 展开进行不确定性传播：\n\n- 一阶传播：在关于 $\\mu$ 的 Taylor 展开中保留线性项。\n- 二阶传播：在关于 $\\mu$ 的 Taylor 展开中保留至二次项。\n\n对于这两种近似，分别求出 $y$ 的近似均值和方差。为了量化近似的质量，定义无量纲相对误差（分别对应均值和方差）为\n$$\\epsilon_{\\text{mean}}=\\frac{|\\mathbb{E}_{\\text{approx}}[y]-\\mathbb{E}[y]|}{\\mathbb{E}[y]}, \\quad \\epsilon_{\\text{var}}=\\frac{|\\mathrm{Var}_{\\text{approx}}(y)-\\mathrm{Var}(y)|}{\\mathrm{Var}(y)}.$$\n\n使用给定的 $\\mu$ 和 $\\sigma$ 的数值，计算分别对应于均值和方差的一阶和二阶近似的四个相对误差。将你的最终答案以一个单行向量的形式报告，其中包含这四个数字，顺序为\n$$\\big(\\epsilon_{\\text{mean, 1st}},\\,\\epsilon_{\\text{mean, 2nd}},\\,\\epsilon_{\\text{var, 1st}},\\,\\epsilon_{\\text{var, 2nd}}\\big),$$\n并四舍五入到六位有效数字。最终答案是无量纲的。", "solution": "用户要求我解决一个不确定性传播问题。我的计划如下：\n\n1.  **验证问题：**\n    *   **提取已知条件：** 列出所有提供的信息：函数 `y = f(x) = x^2`，`x` 的分布为高斯分布 `x ~ N(μ, σ^2)`，数值 `μ = 1.2` 和 `σ = 0.15`，相对误差 `ε_mean` 和 `ε_var` 的定义，以及要求的输出格式。\n    *   **验证：** 检查科学合理性、适定性、客观性、完整性等。\n        *   **科学依据：** 该问题涉及标准概率论和统计学（随机变量的矩，用于不确定性传播的 Taylor 展开）。这是应用数学和物理学中一个成熟的方法。“计算核物理”的背景只是一个框架，核心问题是一个标准的统计计算。它是科学合理的。\n        *   **适定性：** 该问题是适定的。它要求进行具体的计算（精确矩，使用 Taylor 级数的近似矩）和比较。存在唯一解。\n        *   **客观性：** 语言精确且数学化。没有主观陈述。\n        *   **完整性：** 提供了所有必要的信息（`f(x)`，`x` 的分布，参数 `μ`、`σ`，误差公式）。\n        *   **现实性：** 对于一个缩放因子来说，数值 `μ = 1.2` 和 `σ = 0.15` 是合理的。\n        *   **其他缺陷：** 该问题不平庸，不是同义反复，并且是可验证的。\n\n    *   **结论：** 该问题有效。\n\n2.  **解决问题（如果有效）：**\n\n    *   **第一部分：精确均值和方差**\n        *   可观测量为 `y = x^2`。\n        *   `x` 是一个高斯随机变量：`x ~ N(μ, σ^2)`。\n        *   **精确均值 `E[y]`：**\n            *   `E[y] = E[x^2]`。\n            *   我知道方差、均值和二阶矩之间的关系：`Var(x) = E[x^2] - (E[x])^2`。\n            *   对于高斯分布 `x ~ N(μ, σ^2)`，我们有 `E[x] = μ` 和 `Var(x) = σ^2`。\n            *   因此，`E[x^2] = Var(x) + (E[x])^2 = σ^2 + μ^2`。\n            *   所以，精确均值为 `E[y] = μ^2 + σ^2`。\n\n        *   **精确方差 `Var(y)`：**\n            *   `Var(y) = Var(x^2) = E[(x^2)^2] - (E[x^2])^2 = E[x^4] - (μ^2 + σ^2)^2`。\n            *   我需要高斯分布的四阶矩 `E[x^4]`。\n            *   中心高斯分布 `z ~ N(0, σ^2)` 的矩为：当 `n` 为奇数时 `E[z^n] = 0`，当 `n` 为偶数时 `E[z^n] = (n-1)!! σ^n`。\n            *   令 `x = μ + z`，其中 `z ~ N(0, σ^2)`。\n            *   `E[x^4] = E[(μ + z)^4] = E[μ^4 + 4μ^3z + 6μ^2z^2 + 4μz^3 + z^4]`。\n            *   利用期望的线性性质：`E[x^4] = μ^4 + 4μ^3E[z] + 6μ^2E[z^2] + 4μE[z^3] + E[z^4]`。\n            *   我知道 `E[z] = 0`，`E[z^2] = σ^2`，`E[z^3] = 0`，以及 `E[z^4] = 3!! σ^4 = 3σ^4`。\n            *   所以，`E[x^4] = μ^4 + 6μ^2σ^2 + 3σ^4`。\n            *   现在，将此代回方差公式：\n                `Var(y) = (μ^4 + 6μ^2σ^2 + 3σ^4) - (μ^2 + σ^2)^2`\n                `Var(y) = (μ^4 + 6μ^2σ^2 + 3σ^4) - (μ^4 + 2μ^2σ^2 + σ^4)`\n                `Var(y) = 4μ^2σ^2 + 2σ^4`。\n            *   所以，精确方差为 `Var(y) = 2σ^2(2μ^2 + σ^2)`。\n\n    *   **第二部分：一阶近似**\n        *   将 `f(x) = x^2` 在 `x = μ` 附近进行 Taylor 展开：`f(x) ≈ f(μ) + f'(μ)(x - μ)`。\n        *   `f(μ) = μ^2`。\n        *   `f'(x) = 2x`，所以 `f'(μ) = 2μ`。\n        *   `y` 的一阶近似为 `y_{1} = μ^2 + 2μ(x - μ)`。\n        *   **近似均值 `E_approx[y]` (一阶)：**\n            *   `E[y_1] = E[μ^2 + 2μ(x - μ)] = μ^2 + 2μE[x - μ]`。\n            *   因为 `E[x] = μ`，所以 `E[x - μ] = E[x] - μ = 0`。\n            *   所以，`E_{approx, 1st}[y] = μ^2`。\n        *   **近似方差 `Var_approx(y)` (一阶)：**\n            *   `Var(y_1) = Var(μ^2 + 2μ(x - μ))`。\n            *   使用方差性质 `Var(a + bX) = b^2 Var(X)`：\n            *   `Var(y_1) = Var(2μx - 2μ^2 + μ^2) = Var(2μx - μ^2) = (2μ)^2 Var(x) = 4μ^2σ^2`。\n            *   所以，`Var_{approx, 1st}(y) = 4μ^2σ^2`。\n\n    *   **第三部分：二阶近似**\n        *   将 `f(x) = x^2` 在 `x = μ` 附近展开到二阶项：`f(x) ≈ f(μ) + f'(μ)(x - μ) + (1/2)f''(μ)(x - μ)^2`。\n        *   `f''(x) = 2`，所以 `f''(μ) = 2`。\n        *   `y` 的二阶近似为 `y_{2} = μ^2 + 2μ(x - μ) + (1/2)(2)(x - μ)^2 = μ^2 + 2μ(x - μ) + (x - μ)^2`。\n        *   **近似均值 `E_approx[y]` (二阶)：**\n            *   `E[y_2] = E[μ^2 + 2μ(x - μ) + (x - μ)^2]`。\n            *   `E[y_2] = μ^2 + 2μE[x - μ] + E[(x - μ)^2]`。\n            *   我们知道 `E[x - μ] = 0` 且 `E[(x - μ)^2]` 是方差的定义，即 `Var(x) = σ^2`。\n            *   所以，`E_{approx, 2nd}[y] = μ^2 + σ^2`。\n            *   注意这与精确均值相同。\n\n        *   **近似方差 `Var_approx(y)` (二阶)：**\n            *   我们来简化 `y_2`：`y_2 = μ^2 + 2μx - 2μ^2 + x^2 - 2μx + μ^2 = x^2`。\n            *   `f(x) = x^2` 的二阶 Taylor 展开*恰好*是 `f(x)` 本身。这是因为 `f(x)` 是一个二次多项式，其 2 阶（或更高阶）的 Taylor 级数就是该多项式本身。所有更高阶的导数都为零。\n            *   因此，“近似” `y_2` 实际上就是精确函数 `y`。\n            *   `y_2 = x^2`。\n            *   `E_{approx, 2nd}[y] = E[x^2] = μ^2 + σ^2`。（与我之前的计算相符）。\n            *   `Var_{approx, 2nd}(y) = Var(x^2) = 4μ^2σ^2 + 2σ^4`。（与精确方差相符）。\n            *   这是一个特殊情况。Taylor 展开是精确的。\n\n    *   **第四部分：计算相对误差**\n        *   **给定值：** `μ = 1.2`，`σ = 0.15`。\n        *   `μ^2 = (1.2)^2 = 1.44`。\n        *   `σ^2 = (0.15)^2 = 0.0225`。\n\n        *   **精确值：**\n            *   `E[y] = μ^2 + σ^2 = 1.44 + 0.0225 = 1.4625`。\n            *   `Var(y) = 4μ^2σ^2 + 2σ^4 = 4(1.44)(0.0225) + 2(0.0225)^2`。\n                *   `4 * 1.44 * 0.0225 = 0.1296`。\n                *   `2 * (0.0225)^2 = 2 * 0.00050625 = 0.0010125`。\n                *   `Var(y) = 0.1296 + 0.0010125 = 0.1306125`。\n\n        *   **近似值 (一阶)：**\n            *   `E_{approx, 1st}[y] = μ^2 = 1.44`。\n            *   `Var_{approx, 1st}(y) = 4μ^2σ^2 = 4(1.44)(0.0225) = 0.1296`。\n\n        *   **近似值 (二阶)：**\n            *   `E_{approx, 2nd}[y] = μ^2 + σ^2 = 1.44 + 0.0225 = 1.4625`。（这是精确值）。\n            *   `Var_{approx, 2nd}(y) = 4μ^2σ^2 + 2σ^4 = 0.1306125`。（这是精确值）。\n\n        *   **误差计算：**\n            *   `ε_mean, 1st`:\n                `|E_{approx, 1st}[y] - E[y]| / E[y] = |1.44 - 1.4625| / 1.4625 = |-0.0225| / 1.4625 = 0.0225 / 1.4625 = 0.015384615...`\n                四舍五入到六位有效数字：`1.53846 \\times 10^{-2}`。\n\n            *   `ε_mean, 2nd`:\n                `|E_{approx, 2nd}[y] - E[y]| / E[y] = |1.4625 - 1.4625| / 1.4625 = 0 / 1.4625 = 0`。用六位有效数字表示为 `0.000000`。\n\n            *   `ε_var, 1st`:\n                `|Var_{approx, 1st}(y) - Var(y)| / Var(y) = |0.1296 - 0.1306125| / 0.1306125 = |-0.0010125| / 0.1306125 = 0.0010125 / 0.1306125`。\n                `0.0010125 / 0.1306125 = 0.0077519379...`\n                四舍五入到六位有效数字：`7.75194 \\times 10^{-3}`。\n\n            *   `ε_var, 2nd`:\n                `|Var_{approx, 2nd}(y) - Var(y)| / Var(y) = |0.1306125 - 0.1306125| / 0.1306125 = 0 / 0.1306125 = 0`。用六位有效数字表示为 `0.000000`。\n\n    *   **最终答案格式化：**\n        *   一个单行向量：`(ε_mean, 1st, ε_mean, 2nd, ε_var, 1st, ε_var, 2nd)`。\n        *   顺序正确。\n        *   数值四舍五入到六位有效数字。\n        *   `ε_mean, 1st = 0.0153846`\n        *   `ε_mean, 2nd = 0.000000`\n        *   `ε_var, 1st = 0.00775194`\n        *   `ε_var, 2nd = 0.000000`\n整个逻辑是合理的。我现在将写出最终解。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.0153846  0.000000  0.00775194  0.000000\n\\end{pmatrix}\n}\n$$", "id": "3581693"}, {"introduction": "在单变量情况的基础上，本实践探讨了更现实的多变量、相关不确定参数的场景，并引入了物理建模中的一个关键概念：约束。本练习 [@problem_id:3581738] 使用一个假设的核反应网络，其中质量分数总和必须为一。它展示了如何正确地结合这类约束，从而有效降低最终可观测量中的传播不确定性，阐明了一种提高预测精度的强大技术。", "problem": "考虑一个用于燃耗模拟的三同位素核反应网络，其中物种由索引 $i \\in \\{1,2,3\\}$ 标记。设质量分数向量为 $\\mathbf{x} = (x_{1}, x_{2}, x_{3})^{\\top}$，其在标称组分附近有小的随机涨落。假设 $\\mathbf{x}$ 的涨落被建模为一个零均值高斯随机向量，其协方差矩阵为 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{3 \\times 3}$，并且物理归一化约束 $x_{1} + x_{2} + x_{3} = 1$ 必须严格成立。单群反应率响应（在固定通量和几何形状下单位质量的中子产生率）在标称组分附近一阶近似下被建模为线性泛函\n$$\nR(\\mathbf{x}) = c_{1} x_{1} + c_{2} x_{2} + c_{3} x_{3},\n$$\n其灵敏度系数为\n$$\nc_{1} = 1.3 \\times 10^{5} \\ \\text{s}^{-1}, \\quad c_{2} = 0.8 \\times 10^{5} \\ \\text{s}^{-1}, \\quad c_{3} = 1.6 \\times 10^{5} \\ \\text{s}^{-1}.\n$$\n假设质量分数的一个无约束协方差估计（从一个在样本层面不强制执行归一化的计算系综中获得）为\n$$\n\\boldsymbol{\\Sigma} =\n\\begin{pmatrix}\n1.0 \\times 10^{-4}  2.0 \\times 10^{-5}  -3.0 \\times 10^{-5} \\\\\n2.0 \\times 10^{-5}  2.5 \\times 10^{-4}  4.0 \\times 10^{-5} \\\\\n-3.0 \\times 10^{-5}  4.0 \\times 10^{-5}  1.8 \\times 10^{-4}\n\\end{pmatrix}.\n$$\n在小涨落和 $R(\\mathbf{x})$ 在标称组分附近线性化的假设下，将 $\\mathbf{x}$ 中的不确定性传播到标量响应 $R$，同时强制执行严格的归一化约束 $x_{1} + x_{2} + x_{3} = 1$。计算施加约束后 $R$ 的约化标准差。将最终数值答案四舍五入到四位有效数字。以 $\\text{s}^{-1}$ 为单位表示最终的标准差。", "solution": "本问题要求计算线性响应函数 $R(\\mathbf{x})$ 的标准差，其中输入变量 $\\mathbf{x}$ 受到归一化约束。输入变量是质量分数 $x_1, x_2, x_3$，它们存在小的随机涨落。\n\n设质量分数向量为 $\\mathbf{x} = (x_1, x_2, x_3)^\\top$。问题陈述这些变量在标称组分附近有小的涨落，并且这些涨落被建模为一个零均值高斯随机向量。设此涨落向量为 $\\delta\\mathbf{x}$。这些涨落的无约束协方差矩阵由 $\\boldsymbol{\\Sigma}$ 给出：\n$$\n\\boldsymbol{\\Sigma} = \\begin{pmatrix}\n1.0 \\times 10^{-4}  2.0 \\times 10^{-5}  -3.0 \\times 10^{-5} \\\\\n2.0 \\times 10^{-5}  2.5 \\times 10^{-4}  4.0 \\times 10^{-5} \\\\\n-3.0 \\times 10^{-5}  4.0 \\times 10^{-5}  1.8 \\times 10^{-4}\n\\end{pmatrix}\n$$\n反应率响应是质量分数的线性函数：\n$$\nR(\\mathbf{x}) = c_1 x_1 + c_2 x_2 + c_3 x_3 = \\mathbf{c}^\\top \\mathbf{x}\n$$\n其中灵敏度系数向量为 $\\mathbf{c} = (c_1, c_2, c_3)^\\top$。给定的值为：\n$$\nc_1 = 1.3 \\times 10^{5} \\ \\text{s}^{-1}, \\quad c_2 = 0.8 \\times 10^{5} \\ \\text{s}^{-1}, \\quad c_3 = 1.6 \\times 10^{5} \\ \\text{s}^{-1}\n$$\n或者，以向量形式表示：\n$$\n\\mathbf{c} = 10^5 \\begin{pmatrix} 1.3 \\\\ 0.8 \\\\ 1.6 \\end{pmatrix} \\text{s}^{-1}\n$$\n质量分数必须满足物理归一化约束：\n$$\nx_1 + x_2 + x_3 = 1\n$$\n这可以写成向量形式 $\\mathbf{u}^\\top \\mathbf{x} = 1$，其中 $\\mathbf{u} = (1, 1, 1)^\\top$。由于此约束必须严格成立，因此涨落之和必须为零：$\\delta x_1 + \\delta x_2 + \\delta x_3 = 0$，或 $\\mathbf{u}^\\top \\delta\\mathbf{x} = 0$。\n\n我们需要计算的是响应的方差 $\\sigma_R^2$。由于响应函数是线性的，其方差由不确定性传播的标准公式给出：\n$$\n\\sigma_R^2 = \\text{Var}(R) = \\text{Var}(\\mathbf{c}^\\top \\mathbf{x}) = \\text{Var}(\\mathbf{c}^\\top (\\mathbf{x}_0 + \\delta\\mathbf{x})) = \\text{Var}(\\mathbf{c}^\\top \\delta\\mathbf{x}) = \\mathbf{c}^\\top \\text{Cov}(\\delta\\mathbf{x}) \\mathbf{c}\n$$\n其中 $\\text{Cov}(\\delta\\mathbf{x})$ 是*在给定约束下*的涨落的协方差矩阵。所提供的矩阵 $\\boldsymbol{\\Sigma}$ 是无约束协方差。我们必须推导受约束（或条件）协方差矩阵 $\\boldsymbol{\\Sigma}_{\\text{cond}}$，它描述了在条件 $\\mathbf{u}^\\top \\delta\\mathbf{x} = 0$ 下 $\\delta\\mathbf{x}$ 的分布。\n\n对于一个均值为 $\\mathbf{0}$、协方差为 $\\boldsymbol{\\Sigma}$ 的多元正态分布，以线性约束 $\\mathbf{A} \\delta\\mathbf{x} = \\mathbf{0}$ 为条件的协方差矩阵由下式给出：\n$$\n\\boldsymbol{\\Sigma}_{\\text{cond}} = \\boldsymbol{\\Sigma} - \\boldsymbol{\\Sigma} \\mathbf{A}^\\top (\\mathbf{A} \\boldsymbol{\\Sigma} \\mathbf{A}^\\top)^{-1} \\mathbf{A} \\boldsymbol{\\Sigma}\n$$\n在我们的例子中，$\\mathbf{A} = \\mathbf{u}^\\top = \\begin{pmatrix} 1  1  1 \\end{pmatrix}$。因此，公式变为：\n$$\n\\boldsymbol{\\Sigma}_{\\text{cond}} = \\boldsymbol{\\Sigma} - \\boldsymbol{\\Sigma} \\mathbf{u} (\\mathbf{u}^\\top \\boldsymbol{\\Sigma} \\mathbf{u})^{-1} \\mathbf{u}^\\top \\boldsymbol{\\Sigma}\n$$\n响应 $R$ 的方差则为：\n$$\n\\sigma_R^2 = \\mathbf{c}^\\top \\boldsymbol{\\Sigma}_{\\text{cond}} \\mathbf{c} = \\mathbf{c}^\\top \\left( \\boldsymbol{\\Sigma} - \\frac{(\\boldsymbol{\\Sigma} \\mathbf{u})(\\mathbf{u}^\\top \\boldsymbol{\\Sigma})}{\\mathbf{u}^\\top \\boldsymbol{\\Sigma} \\mathbf{u}} \\right) \\mathbf{c}\n$$\n由于 $\\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{u}$ 是一个标量，上式可简化为：\n$$\n\\sigma_R^2 = \\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{c} - \\frac{(\\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{u}) (\\mathbf{u}^\\top \\boldsymbol{\\Sigma} \\mathbf{c})}{\\mathbf{u}^\\top \\boldsymbol{\\Sigma} \\mathbf{u}} = \\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{c} - \\frac{(\\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{u})^2}{\\mathbf{u}^\\top \\boldsymbol{\\Sigma} \\mathbf{u}}\n$$\n这个公式表示了由于施加约束而导致的方差相较于无约束情况（$\\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{c}$）的减小量。我们现在计算所需的三个标量值。\n\n1.  $\\mathbf{u}^\\top \\boldsymbol{\\Sigma} \\mathbf{u}$：这是矩阵 $\\boldsymbol{\\Sigma}$ 所有元素的总和。\n$$\n\\mathbf{u}^\\top \\boldsymbol{\\Sigma} \\mathbf{u} = \\sum_{i=1}^3 \\sum_{j=1}^3 \\Sigma_{ij} = (1.0 + 0.2 - 0.3 + 0.2 + 2.5 + 0.4 - 0.3 + 0.4 + 1.8) \\times 10^{-4} = 5.9 \\times 10^{-4}\n$$\n\n2.  $\\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{c}$：$R$ 的无约束方差。\n首先，我们计算乘积 $\\boldsymbol{\\Sigma} \\mathbf{c}$：\n$$\n\\boldsymbol{\\Sigma} \\mathbf{c} = 10^{-4} \\begin{pmatrix}\n1.0  0.2  -0.3 \\\\\n0.2  2.5  0.4 \\\\\n-0.3  0.4  1.8\n\\end{pmatrix} \\left( 10^5 \\begin{pmatrix} 1.3 \\\\ 0.8 \\\\ 1.6 \\end{pmatrix} \\right) = 10^1 \\begin{pmatrix}\n1.0(1.3) + 0.2(0.8) - 0.3(1.6) \\\\\n0.2(1.3) + 2.5(0.8) + 0.4(1.6) \\\\\n-0.3(1.3) + 0.4(0.8) + 1.8(1.6)\n\\end{pmatrix} = 10 \\begin{pmatrix}\n1.3 + 0.16 - 0.48 \\\\\n0.26 + 2.0 + 0.64 \\\\\n-0.39 + 0.32 + 2.88\n\\end{pmatrix} = 10 \\begin{pmatrix} 0.98 \\\\ 2.90 \\\\ 2.81 \\end{pmatrix}\n$$\n现在我们计算 $\\mathbf{c}^\\top (\\boldsymbol{\\Sigma} \\mathbf{c})$：\n$$\n\\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{c} = \\left( 10^5 \\begin{pmatrix} 1.3  0.8  1.6 \\end{pmatrix} \\right) \\left( 10 \\begin{pmatrix} 0.98 \\\\ 2.90 \\\\ 2.81 \\end{pmatrix} \\right) = 10^6 (1.3(0.98) + 0.8(2.90) + 1.6(2.81))\n$$\n$$\n\\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{c} = 10^6 (1.274 + 2.32 + 4.496) = 10^6 (8.09) = 8.09 \\times 10^6 \\ \\text{s}^{-2}\n$$\n\n3.  $\\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{u}$：此项将灵敏度与约束耦合起来。\n首先，我们求 $\\boldsymbol{\\Sigma} \\mathbf{u}$，即 $\\boldsymbol{\\Sigma}$ 的行和向量：\n$$\n\\boldsymbol{\\Sigma} \\mathbf{u} = 10^{-4} \\begin{pmatrix}\n1.0 + 0.2 - 0.3 \\\\\n0.2 + 2.5 + 0.4 \\\\\n-0.3 + 0.4 + 1.8\n\\end{pmatrix} = 10^{-4} \\begin{pmatrix} 0.9 \\\\ 3.1 \\\\ 1.9 \\end{pmatrix}\n$$\n现在，我们计算 $\\mathbf{c}^\\top (\\boldsymbol{\\Sigma} \\mathbf{u})$：\n$$\n\\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{u} = \\left( 10^5 \\begin{pmatrix} 1.3  0.8  1.6 \\end{pmatrix} \\right) \\left( 10^{-4} \\begin{pmatrix} 0.9 \\\\ 3.1 \\\\ 1.9 \\end{pmatrix} \\right) = 10^1 (1.3(0.9) + 0.8(3.1) + 1.6(1.9))\n$$\n$$\n\\mathbf{c}^\\top \\boldsymbol{\\Sigma} \\mathbf{u} = 10 (1.17 + 2.48 + 3.04) = 10 (6.69) = 66.9 \\ \\text{s}^{-1}\n$$\n\n现在我们将这些值代入受约束方差 $\\sigma_R^2$ 的公式中：\n$$\n\\sigma_R^2 = 8.09 \\times 10^6 - \\frac{(66.9)^2}{5.9 \\times 10^{-4}} = 8.09 \\times 10^6 - \\frac{4475.61}{5.9 \\times 10^{-4}}\n$$\n$$\n\\sigma_R^2 = 8.09 \\times 10^6 - 7585779.66... = 8090000 - 7585779.66... = 504220.33... \\ \\text{s}^{-2}\n$$\n最后一步是计算标准差 $\\sigma_R$，即方差的平方根，并将其四舍五入到四位有效数字。\n$$\n\\sigma_R = \\sqrt{504220.33...} \\approx 710.08474... \\ \\text{s}^{-1}\n$$\n四舍五入到四位有效数字，我们得到：\n$$\n\\sigma_R \\approx 710.1 \\ \\text{s}^{-1}\n$$", "answer": "$$\n\\boxed{710.1}\n$$", "id": "3581738"}, {"introduction": "泰勒级数近似在处理轻度非线性模型时效果很好，但当非线性很强时会发生什么？本实践 [@problem_id:3581708] 引入了一种计算诊断方法，以帮助决定何时应放弃解析近似，转而采用更稳健（但计算成本更高）的蒙特卡洛抽样方法。通过实现一个量化模型曲率（非线性）影响的工具，您将掌握一项在实际计算物理问题中选择合适的不确定性量化方法的实用技能。", "problem": "考虑一个来自计算核物理的可观测量，其定义为对反应率的麦克斯韦平均单共振贡献。设该标量可观测量为积分 $$R(A,E_r,\\Gamma;kT) = \\int_{0}^{\\infty} y e^{-y} \\frac{A}{\\big(kT\\,y - E_r\\big)^2 + \\big(\\Gamma/2\\big)^2}\\,dy,$$ 其中 $A$ 是一个标度参数（单位为靶恩），$E_r$ 是共振能量（单位为兆电子伏特），$\\Gamma$ 是总共振宽度（单位为兆电子伏特），而 $kT$ 是热能（单位为兆电子伏特）。权重函数 $y e^{-y}$ 源于在进行变量替换 $y = E/(kT)$ 后的 Maxwell-Boltzmann 谱，该替换保持了量纲一致性，并确保 $R$ 是一个具有物理意义的类反应率可观测量。\n\n假设参数向量 $$\\boldsymbol{\\theta} = \\begin{bmatrix} A \\\\ E_r \\\\ \\Gamma \\end{bmatrix}$$ 被建模为一个多元正态随机变量，其均值为 $$\\boldsymbol{\\mu} = \\begin{bmatrix} \\mu_A \\\\ \\mu_{E_r} \\\\ \\mu_{\\Gamma} \\end{bmatrix}$$ 且协方差矩阵为 $$\\mathbf{C} \\in \\mathbb{R}^{3\\times 3}。$$ 任务是实现一个不确定性传播的诊断程序，该程序为每个指定的测试用例确定：是应该使用高阶（二阶 Taylor）传播，还是由于非线性而必须使用 Monte Carlo（随机抽样）传播。\n\n从多元标量函数的 Taylor 展开和多元正态分布的性质出发，您必须：\n- 使用中心有限差分法，推导并实现梯度 $$\\mathbf{g} = \\nabla_{\\boldsymbol{\\theta}} R(\\boldsymbol{\\mu};kT)$$ 和 Hessian 矩阵 $$\\mathbf{H} = \\nabla^2_{\\boldsymbol{\\theta}} R(\\boldsymbol{\\mu};kT)$$ 的数值近似。使用维度步长 $$h_i = \\varepsilon \\max\\big(|\\mu_i|, 1\\big)$$，其中 $$\\varepsilon = 10^{-4}。$$\n- 使用量 $$\\mathbf{g}$$ 和 $$\\mathbf{H}$$ 以及协方差 $$\\mathbf{C},$$ 计算：\n  1. 主要（线性）方差贡献 $$V_1$$，由梯度和协方差引起。\n  2. 主要的由曲率引起的（二阶）方差修正项 $$V_2$$，由 Hessian 矩阵和协方差引起。\n  3. 由曲率引起的均值偏移（偏差）$$b_2$$，由 Hessian 矩阵和协方差引起。\n- 定义诊断指标：\n  - 曲率分数 $$\\kappa_{\\mathrm{var}} = V_2 / V_1。$$\n  - 归一化偏差 $$\\kappa_{\\mathrm{bias}} = |b_2| / \\sqrt{V_1}。$$\n- 决策规则：对于每个测试用例，如果同时满足 $$\\kappa_{\\mathrm{var}} \\leq 0.25$$ 和 $$\\kappa_{\\mathrm{bias}} \\leq 0.25$$，则判定应使用高阶（二阶 Taylor）传播；否则，判定应使用 Monte Carlo（随机抽样）传播。将决策报告为整数 $$0$$ 代表高阶传播，$$1$$ 代表 Monte Carlo 传播。\n\n完全按照给定的形式实现积分，在 $$y \\in [0,\\infty)$$ 上进行数值求积。此问题不涉及角度；无需角度单位。所有能量单位必须理解为兆电子伏特，振幅 $$A$$ 的单位必须理解为靶恩；然而，所要求的输出是无单位的整数，因此您只需报告每个测试用例的决策。\n\n测试套件：\n- 用例 $$1$$（理想情况，曲率温和）：\n  - $$kT = 0.5。$$\n  - $$\\boldsymbol{\\mu} = [5.0,\\,1.5,\\,0.4]。$$\n  - $$\\mathbf{C} = \\mathrm{diag}\\big([0.2^2,\\,0.05^2,\\,0.04^2]\\big) = \\mathrm{diag}([0.04,\\,0.0025,\\,0.0016])。$$\n- 用例 $$2$$（近共振，中等曲率，弱相关）：\n  - $$kT = 0.5。$$\n  - $$\\boldsymbol{\\mu} = [5.0,\\,0.7,\\,0.2]。$$\n  - 标准差 $$[0.5,\\,0.07,\\,0.02]，$$ $$E_r$$ 和 $$\\Gamma$$ 之间的相关性等于 $$0.3。$$ 因此 $$\\mathbf{C}$$ 的对角线元素为 $$[0.25,\\,0.0049,\\,0.0004]$$，非对角线元素为 $$C_{E_r,\\Gamma} = C_{\\Gamma,E_r} = 0.3 \\cdot 0.07 \\cdot 0.02 = 0.00042,$$ 其他非对角线元素为零。\n- 用例 $$3$$（较强曲率，强相关）：\n  - $$kT = 0.4。$$\n  - $$\\boldsymbol{\\mu} = [5.0,\\,0.52,\\,0.05]。$$\n  - 标准差 $$[1.0,\\,0.08,\\,0.02]，$$ $$E_r$$ 和 $$\\Gamma$$ 之间的相关性等于 $$0.8。$$ 因此 $$\\mathbf{C}$$ 的对角线元素为 $$[1.0,\\,0.0064,\\,0.0004]$$，非对角线元素为 $$C_{E_r,\\Gamma} = C_{\\Gamma,E_r} = 0.8 \\cdot 0.08 \\cdot 0.02 = 0.00128,$$ 其他非对角线元素为零。\n- 用例 $$4$$（共振处宽度窄，非线性边缘，负相关）：\n  - $$kT = 0.6。$$\n  - $$\\boldsymbol{\\mu} = [5.0,\\,0.5,\\,0.02]。$$\n  - 标准差 $$[0.1,\\,0.005,\\,0.004]，$$ $$E_r$$ 和 $$\\Gamma$$ 之间的相关性等于 $$-0.6。$$ 因此 $$\\mathbf{C}$$ 的对角线元素为 $$[0.01,\\,2.5\\times 10^{-5},\\,1.6\\times 10^{-5}]$$，非对角线元素为 $$C_{E_r,\\Gamma} = C_{\\Gamma,E_r} = -0.6 \\cdot 0.005 \\cdot 0.004 = -1.2\\times 10^{-5},$$ 其他非对角线元素为零。\n\n您的程序应生成单行输出，其中包含四个用例的决策，形式为方括号括起来的逗号分隔列表（例如，$$[0,1,0,1]$$）。输出元素必须是整数 $$0$$ 或 $$1。$$", "solution": "问题陈述已经过评估，被认为是有效的。它在科学上基于核反应理论和统计不确定性传播的原理。该问题是适定的（well-posed），提供了所有必要的数据、定义和约束，从而能够得出唯一的解。其语言客观且数学上精确。因此，我们可以着手求解。\n\n问题的核心是在从多元正态分布 $\\boldsymbol{\\theta} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{C})$ 传播不确定性的背景下，评估函数 $R(\\boldsymbol{\\theta})$ 相对于其参数 $\\boldsymbol{\\theta} = [A, E_r, \\Gamma]^T$ 的非线性程度。诊断工具源自 $R(\\boldsymbol{\\theta})$ 在均值参数向量 $\\boldsymbol{\\mu}$ 周围的二阶 Taylor 级数展开。\n\nTaylor 展开由下式给出：\n$$ R(\\boldsymbol{\\theta}) \\approx R(\\boldsymbol{\\mu}) + (\\boldsymbol{\\theta} - \\boldsymbol{\\mu})^T \\mathbf{g} + \\frac{1}{2} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu})^T \\mathbf{H} (\\boldsymbol{\\theta} - \\boldsymbol{\\mu}) $$\n其中 $\\mathbf{g} = \\nabla_{\\boldsymbol{\\theta}} R(\\boldsymbol{\\mu})$ 是梯度向量，$\\mathbf{H} = \\nabla^2_{\\boldsymbol{\\theta}} R(\\boldsymbol{\\mu})$ 是在均值 $\\boldsymbol{\\mu}$ 处求值的 $R$ 的 Hessian 矩阵。梯度和 Hessian 矩阵的分量分别是偏导数 $g_i = \\partial R / \\partial \\theta_i$ 和 $H_{ij} = \\partial^2 R / (\\partial \\theta_i \\partial \\theta_j)$。\n\n根据此展开式，我们可以找到 $R(\\boldsymbol{\\theta})$ 分布的近似矩。\n$R$ 的期望值（均值）通过对展开式取期望来求得。令 $\\boldsymbol{\\delta} = \\boldsymbol{\\theta} - \\boldsymbol{\\mu}$。根据定义，$\\mathbb{E}[\\boldsymbol{\\delta}] = \\mathbf{0}$ 且协方差为 $\\mathbb{E}[\\boldsymbol{\\delta}\\boldsymbol{\\delta}^T] = \\mathbf{C}$。\n$$ \\mathbb{E}[R(\\boldsymbol{\\theta})] \\approx \\mathbb{E}[R(\\boldsymbol{\\mu}) + \\mathbf{g}^T\\boldsymbol{\\delta} + \\frac{1}{2}\\boldsymbol{\\delta}^T\\mathbf{H}\\boldsymbol{\\delta}] $$\n$$ \\mathbb{E}[R(\\boldsymbol{\\theta})] \\approx R(\\boldsymbol{\\mu}) + \\mathbf{g}^T\\mathbb{E}[\\boldsymbol{\\delta}] + \\frac{1}{2}\\mathbb{E}[\\boldsymbol{\\delta}^T\\mathbf{H}\\boldsymbol{\\delta}] $$\n$$ \\mathbb{E}[R(\\boldsymbol{\\theta})] \\approx R(\\boldsymbol{\\mu}) + \\frac{1}{2}\\mathbb{E}[\\text{Tr}(\\mathbf{H}\\boldsymbol{\\delta}\\boldsymbol{\\delta}^T)] = R(\\boldsymbol{\\mu}) + \\frac{1}{2}\\text{Tr}(\\mathbf{H}\\mathbb{E}[\\boldsymbol{\\delta}\\boldsymbol{\\delta}^T]) = R(\\boldsymbol{\\mu}) + \\frac{1}{2}\\text{Tr}(\\mathbf{H}\\mathbf{C}) $$\n项 $b_2 = \\frac{1}{2}\\text{Tr}(\\mathbf{H}\\mathbf{C})$ 是由函数 $R$ 的曲率引起的二阶偏差或均值偏移。\n\n$R$ 的方差更为复杂。在一阶近似下，我们只考虑线性项：\n$$ R(\\boldsymbol{\\theta}) \\approx R(\\boldsymbol{\\mu}) + \\mathbf{g}^T\\boldsymbol{\\delta} $$\n则方差为：\n$$ \\text{Var}(R) \\approx \\text{Var}(\\mathbf{g}^T\\boldsymbol{\\delta}) = \\mathbb{E}[(\\mathbf{g}^T\\boldsymbol{\\delta})(\\mathbf{g}^T\\boldsymbol{\\delta})^T] = \\mathbb{E}[\\mathbf{g}^T\\boldsymbol{\\delta}\\boldsymbol{\\delta}^T\\mathbf{g}] = \\mathbf{g}^T\\mathbb{E}[\\boldsymbol{\\delta}\\boldsymbol{\\delta}^T]\\mathbf{g} = \\mathbf{g}^T\\mathbf{C}\\mathbf{g} $$\n这是对方差的主要线性贡献，记为 $V_1 = \\mathbf{g}^T\\mathbf{C}\\mathbf{g}$。\n\n对方差的次要主要贡献来自 Taylor 展开中的二次项。对于一个多元正态输入，二次型 $\\frac{1}{2}\\boldsymbol{\\delta}^T\\mathbf{H}\\boldsymbol{\\delta}$ 的方差由 $\\frac{1}{2}\\text{Tr}((\\mathbf{H}\\mathbf{C})^2)$ 给出。线性和二次部分之间也存在一个协方差项，但对于像正态分布这样的对称分布，如果三阶中心矩为零，则该项为零。因此，由曲率引起的主要方差修正是 $V_2 = \\frac{1}{2}\\text{Tr}((\\mathbf{H}\\mathbf{C})^2)$。\n\n求解策略如下：\n1.  对于任意给定的参数向量 $\\boldsymbol{\\theta}$ 和热能 $kT$，数值计算可观测量 $R(\\boldsymbol{\\theta}; kT)$。该积分在半无限域上进行，这建议使用专门的数值求积例程，例如 `scipy.integrate.quad`。被积函数为 $f(y; \\boldsymbol{\\theta}, kT) = y e^{-y} A \\left[ (kT\\,y - E_r)^2 + (\\Gamma/2)^2 \\right]^{-1}$。\n2.  按照要求，使用中心有限差分法在 $\\boldsymbol{\\theta} = \\boldsymbol{\\mu}$ 处数值近似梯度 $\\mathbf{g}$ 和 Hessian 矩阵 $\\mathbf{H}$。对于函数 $R(\\boldsymbol{\\theta})$，其导数为：\n    - 梯度分量：$g_i \\approx \\frac{R(\\boldsymbol{\\mu} + h_i\\mathbf{e}_i) - R(\\boldsymbol{\\mu} - h_i\\mathbf{e}_i)}{2h_i}$\n    - Hessian 矩阵对角分量：$H_{ii} \\approx \\frac{R(\\boldsymbol{\\mu} + h_i\\mathbf{e}_i) - 2R(\\boldsymbol{\\mu}) + R(\\boldsymbol{\\mu} - h_i\\mathbf{e}_i)}{h_i^2}$\n    - Hessian 矩阵非对角分量：$H_{ij} \\approx \\frac{R(\\boldsymbol{\\mu}+h_i\\mathbf{e}_i+h_j\\mathbf{e}_j) - R(\\boldsymbol{\\mu}+h_i\\mathbf{e}_i-h_j\\mathbf{e}_j) - R(\\boldsymbol{\\mu}-h_i\\mathbf{e}_i+h_j\\mathbf{e}_j) + R(\\boldsymbol{\\mu}-h_i\\mathbf{e}_i-h_j\\mathbf{e}_j)}{4h_i h_j}$\n    其中 $\\mathbf{e}_i$ 是第 $i$ 个标准基向量，而 $h_i = \\varepsilon \\max(|\\mu_i|, 1)$ 是步长，$\\varepsilon = 10^{-4}$。\n3.  对于每个测试用例，构建均值向量 $\\boldsymbol{\\mu}$ 和协方差矩阵 $\\mathbf{C}$。\n4.  计算量 $V_1 = \\mathbf{g}^T\\mathbf{C}\\mathbf{g}$、$b_2 = \\frac{1}{2}\\text{Tr}(\\mathbf{H}\\mathbf{C})$ 和 $V_2 = \\frac{1}{2}\\text{Tr}((\\mathbf{H}\\mathbf{C})^2)$。\n5.  计算诊断指标 $\\kappa_{\\mathrm{var}} = V_2/V_1$ 和 $\\kappa_{\\mathrm{bias}} = |b_2|/\\sqrt{V_1}$。\n6.  应用决策规则：如果 $\\kappa_{\\mathrm{var}} \\leq 0.25$ 且 $\\kappa_{\\mathrm{bias}} \\leq 0.25$，则决策为高阶传播（编码为 $0$）。否则，应使用 Monte Carlo 方法（编码为 $1$）。\n\n此过程将对所提供的四个测试用例中的每一个进行实施。实施过程需要小心处理数值精度并正确应用矩阵代数。最终输出将是一个整数列表，代表每个用例的决策。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the uncertainty propagation diagnostic problem for all test cases.\n    \"\"\"\n\n    def R_integrand(y, A, Er, Gamma, kT):\n        \"\"\"The integrand for the observable R.\"\"\"\n        denominator = (kT * y - Er)**2 + (Gamma / 2)**2\n        # A small constant is added to avoid potential division by zero if Gamma and (kT*y-Er) are both zero.\n        # This is physically unlikely but good for numerical stability.\n        if denominator == 0:\n            return 0.0  # The peak is infinitely narrow and contributes zero to the integral\n        return y * np.exp(-y) * A / denominator\n\n    def R_func(theta, kT):\n        \"\"\"\n        Computes the observable R for a given parameter vector theta and thermal energy kT.\n        \n        Args:\n            theta (np.ndarray): Parameter vector [A, Er, Gamma].\n            kT (float): Thermal energy.\n        \n        Returns:\n            float: The value of the integral R.\n        \"\"\"\n        A, Er, Gamma = theta\n        # All parameters must be physically meaningful, e.g., A > 0, Gamma > 0.\n        if A <= 0 or Gamma <= 0:\n            return np.nan\n\n        # Use scipy.integrate.quad for the semi-infinite integral.\n        # The integral converges rapidly due to the exp(-y) term.\n        result, _ = quad(R_integrand, 0, np.inf, args=(A, Er, Gamma, kT))\n        return result\n\n    def compute_gradient(func, mu, kT, epsilon=1e-4):\n        \"\"\"\n        Computes the gradient of func using central finite differences.\n        \"\"\"\n        n = len(mu)\n        g = np.zeros(n)\n        h_vec = epsilon * np.maximum(np.abs(mu), 1.0)\n        \n        for i in range(n):\n            h_i = h_vec[i]\n            mu_plus = mu.copy()\n            mu_plus[i] += h_i\n            mu_minus = mu.copy()\n            mu_minus[i] -= h_i\n            g[i] = (func(mu_plus, kT) - func(mu_minus, kT)) / (2 * h_i)\n            \n        return g\n\n    def compute_hessian(func, mu, kT, epsilon=1e-4):\n        \"\"\"\n        Computes the Hessian of func using central finite differences.\n        \"\"\"\n        n = len(mu)\n        H = np.zeros((n, n))\n        h_vec = epsilon * np.maximum(np.abs(mu), 1.0)\n\n        f0 = func(mu, kT)\n\n        # Diagonal elements\n        for i in range(n):\n            h_i = h_vec[i]\n            mu_plus = mu.copy()\n            mu_plus[i] += h_i\n            mu_minus = mu.copy()\n            mu_minus[i] -= h_i\n            f_plus = func(mu_plus, kT)\n            f_minus = func(mu_minus, kT)\n            H[i, i] = (f_plus - 2 * f0 + f_minus) / (h_i**2)\n\n        # Off-diagonal elements\n        for i in range(n):\n            for j in range(i + 1, n):\n                h_i = h_vec[i]\n                h_j = h_vec[j]\n                \n                mu_pp = mu.copy()\n                mu_pp[i] += h_i\n                mu_pp[j] += h_j\n                f_pp = func(mu_pp, kT)\n\n                mu_pm = mu.copy()\n                mu_pm[i] += h_i\n                mu_pm[j] -= h_j\n                f_pm = func(mu_pm, kT)\n\n                mu_mp = mu.copy()\n                mu_mp[i] -= h_i\n                mu_mp[j] += h_j\n                f_mp = func(mu_mp, kT)\n\n                mu_mm = mu.copy()\n                mu_mm[i] -= h_i\n                mu_mm[j] -= h_j\n                f_mm = func(mu_mm, kT)\n                \n                H[i, j] = (f_pp - f_pm - f_mp + f_mm) / (4 * h_i * h_j)\n                H[j, i] = H[i, j]\n                \n        return H\n\n    # Define test cases\n    test_cases = [\n        # Case 1\n        {\n            \"kT\": 0.5,\n            \"mu\": np.array([5.0, 1.5, 0.4]),\n            \"C\": np.diag([0.04, 0.0025, 0.0016])\n        },\n        # Case 2\n        {\n            \"kT\": 0.5,\n            \"mu\": np.array([5.0, 0.7, 0.2]),\n            \"C\": np.array([\n                [0.25, 0, 0],\n                [0, 0.0049, 0.00042],\n                [0, 0.00042, 0.0004]\n            ])\n        },\n        # Case 3\n        {\n            \"kT\": 0.4,\n            \"mu\": np.array([5.0, 0.52, 0.05]),\n            \"C\": np.array([\n                [1.0, 0, 0],\n                [0, 0.0064, 0.00128],\n                [0, 0.00128, 0.0004]\n            ])\n        },\n        # Case 4\n        {\n            \"kT\": 0.6,\n            \"mu\": np.array([5.0, 0.5, 0.02]),\n            \"C\": np.array([\n                [0.01, 0, 0],\n                [0, 2.5e-5, -1.2e-5],\n                [0, -1.2e-5, 1.6e-5]\n            ])\n        }\n    ]\n\n    decisions = []\n    for case in test_cases:\n        kT = case[\"kT\"]\n        mu = case[\"mu\"]\n        C = case[\"C\"]\n\n        # Compute gradient and Hessian\n        g = compute_gradient(R_func, mu, kT)\n        H = compute_hessian(R_func, mu, kT)\n\n        # Compute V1, b2, V2\n        V1 = g.T @ C @ g\n        HC = H @ C\n        b2 = 0.5 * np.trace(HC)\n        V2 = 0.5 * np.trace(HC @ HC)\n\n        # Compute diagnostic metrics\n        if V1 == 0:\n            # This indicates a flat function or numerical instability.\n            # If V1 is zero, any non-zero curvature implies MC is needed.\n            kappa_var = np.inf if V2 > 0 else 0\n            kappa_bias = np.inf if abs(b2) > 0 else 0\n        else:\n            kappa_var = V2 / V1\n            kappa_bias = abs(b2) / np.sqrt(V1)\n            \n        # Apply decision rule\n        if kappa_var <= 0.25 and kappa_bias <= 0.25:\n            decision = 0  # Higher-order Taylor is warranted\n        else:\n            decision = 1  # Monte Carlo is warranted\n            \n        decisions.append(decision)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, decisions))}]\")\n\nsolve()\n```", "id": "3581708"}]}