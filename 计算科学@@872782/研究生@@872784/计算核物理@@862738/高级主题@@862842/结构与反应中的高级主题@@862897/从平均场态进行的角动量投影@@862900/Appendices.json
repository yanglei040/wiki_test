{"hands_on_practices": [{"introduction": "角动量投影算符是建立在对 Wigner D 矩阵在旋转群上积分的基础之上的。任何投影代码的正确性都取决于这些矩阵的精确实现和数值积分的准确性。本实践利用 D 矩阵的基本正交关系——群表示论的基石。通过数值方法验证这一解析恒等式，您将构建并验证投影代码的核心组件，包括角动量算符的构造和多维求积的实现，这是开发稳健代码时必不可少的单元测试。[@problem_id:3542272]", "problem": "考虑在计算核物理中，从平均场态进行角动量投影的背景下，数值验证Wigner旋转矩阵元正交性的问题。Wigner旋转矩阵元定义为 $D^{J}_{M K}(\\alpha,\\beta,\\gamma) = \\langle J M | \\hat{R}(\\alpha,\\beta,\\gamma) | J K \\rangle$，其中 $\\hat{R}(\\alpha,\\beta,\\gamma) = e^{-i \\alpha \\hat{J}_{z}} e^{-i \\beta \\hat{J}_{y}} e^{-i \\gamma \\hat{J}_{z}}$，且 $\\alpha,\\beta,\\gamma$ 是以弧度为单位的欧拉角。旋转群上的积分测度为Haar测度，$d\\Omega = d\\alpha\\,\\sin\\beta\\,d\\beta\\,d\\gamma$，其中 $\\alpha \\in [0,2\\pi)$，$\\beta \\in [0,\\pi]$，且 $\\gamma \\in [0,2\\pi)$。\n\n根据三阶特殊正交群 (SO(3)) 的酉不可约表示的基本性质及其与二阶特殊酉群 (SU(2)) 的关系，可以推断出矩阵元 $D^{J}_{M K}(\\alpha,\\beta,\\gamma)$ 在群流形上相对于Haar测度满足正交关系。该恒等式对于构建和验证用于将平均场态投影到好总角动量态上的角动量投影算符至关重要。\n\n你的任务是编写一个完整的程序，该程序能：\n- 通过因子分解 $D^{J}_{M K}(\\alpha,\\beta,\\gamma) = e^{-i M \\alpha}\\, d^{J}_{M K}(\\beta)\\, e^{-i K \\gamma}$ 实现 $D^{J}_{M K}(\\alpha,\\beta,\\gamma)$，其中 $d^{J}_{M K}(\\beta)$ 对于给定的 $J$ 在 $\\hat{J}_{z}$ 本征基中作为 $e^{-i \\beta \\hat{J}_{y}}$ 的矩阵元进行计算。\n- 使用以下求积选择和角度单位，数值计算三重积分\n$$\nI(J,J',M,M',K,K') = \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta\\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; D^{J}_{M K}(\\alpha,\\beta,\\gamma)\\, \\left[D^{J'}_{M' K'}(\\alpha,\\beta,\\gamma)\\right]^{*}\n$$\n  - 角度以弧度为单位。\n  - $\\alpha$ 和 $\\gamma$ 积分必须在 $[0,2\\pi)$ 上使用具有 $N_{\\alpha} = N_{\\gamma} = 128$ 个节点的等距梯形法则。\n  - $\\beta$ 积分必须在 $[-1,1]$ 上使用具有 $N_{\\beta} = 64$ 个节点的Gauss–Legendre求积，并应用于变量替换 $x = \\cos\\beta$，从而 $\\int_{0}^{\\pi} \\sin\\beta f(\\beta)\\, d\\beta = \\int_{-1}^{1} f(\\arccos x)\\, dx$。\n- 将数值积分 $I(J,J',M,M',K,K')$ 与解析值\n$$\nI_{\\text{analytic}}(J,J',M,M',K,K') = \\frac{8\\pi^{2}}{2J+1}\\, \\delta_{J J'}\\, \\delta_{M M'}\\, \\delta_{K K'}\n$$\n进行比较，并使用判据\n$$\n\\left| I - I_{\\text{analytic}} \\right| \\le \\varepsilon \\times \\max\\!\\left(1, \\left| I_{\\text{analytic}} \\right| \\right),\n$$\n对每个测试用例返回布尔值的通过/失败结果，容差为 $\\varepsilon = 10^{-6}$。\n\n实现细节和约束：\n- 在标准 $\\hat{J}_{z}$ 本征基 $\\{ |J m\\rangle \\}_{m=-J,\\dots,+J}$ 中，使用升降算符 $\\hat{J}_{\\pm}$ 和 $\\hat{J}_{z}$ 来构建 $\\hat{J}_{y}$，其中 $\\hat{J}_{+} |J m\\rangle = \\sqrt{J(J+1) - m(m+1)} |J (m+1)\\rangle$，$\\hat{J}_{-} = \\hat{J}_{+}^{\\dagger}$，$\\hat{J}_{x} = (\\hat{J}_{+} + \\hat{J}_{-})/2$，以及 $\\hat{J}_{y} = (\\hat{J}_{+} - \\hat{J}_{-})/(2i)$。设 $\\hbar = 1$。\n- 将 $d^{J}_{M K}(\\beta)$ 计算为 $e^{-i \\beta \\hat{J}_{y}}$ 的 $(M,K)$ 矩阵元。你不能对 $d^{J}_{M K}(\\beta)$ 使用闭合形式级数；必须通过 $\\hat{J}_{y}$ 的矩阵指数来计算它。\n- 所有角度必须以弧度处理。\n- 积分必须按上述指定的数值求积方法计算，而不是通过解析约化。\n\n测试套件：\n评估以下六个案例的布尔通过/失败结果，每个案例指定为元组 $(J,J',M,M',K,K')$，其中所有量子数均为整数，满足 $-J \\le M,K \\le J$ 和 $-J' \\le M',K' \\le J'$：\n- 案例 1: $(0,0,0,0,0,0)$。\n- 案例 2: $(1,1,1,1,-1,-1)$。\n- 案例 3: $(2,2,0,1,2,2)$。\n- 案例 4: $(2,3,0,0,-1,-1)$。\n- 案例 5: $(3,3,-2,-2,1,-1)$。\n- 案例 6: $(4,4,0,0,0,0)$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，其顺序与上述案例的顺序完全一致。例如，一个有效的输出应如下所示：\"[True,False,True,True,True,True]\"。", "solution": "该问题要求对Wigner D-矩阵元的正交关系进行数值验证，这是从旋转群 $SO(3)$ 的表示论中导出的一个基本性质。该关系由积分给出：\n$$\nI(J,J',M,M',K,K') = \\int d\\Omega \\; D^{J}_{M K}(\\Omega)\\, \\left[D^{J'}_{M' K'}(\\Omega)\\right]^{*} = \\frac{8\\pi^{2}}{2J+1}\\, \\delta_{J J'}\\, \\delta_{M M'}\\, \\delta_{K K'}\n$$\n其中 $\\Omega = (\\alpha, \\beta, \\gamma)$ 表示欧拉角，$d\\Omega = d\\alpha\\,\\sin\\beta\\,d\\beta\\,d\\gamma$ 是Haar测度。我们的任务是实现一个数值程序，为给定的量子数组 $(J,J',M,M',K,K')$ 计算该积分，并验证结果在指定的容差 $\\varepsilon = 10^{-6}$ 内与解析公式相符。\n\n算法解决方案涉及四个主要阶段：\n1.  构建角动量算符 $\\hat{J}_y$ 的矩阵表示。\n2.  通过矩阵指数化计算Wigner d-矩阵 $d^J(\\beta)$。\n3.  使用规定的数值求积方法计算在 $(\\alpha, \\beta, \\gamma)$ 上的三维积分。\n4.  将数值结果与解析值进行比较，以确定通过/失败的结果。\n\n**1. 角动量算符的矩阵表示**\n\n对于一个给定总角动量量子数 $J$ 的系统，其状态空间由 $2J+1$ 个正交归一的基矢 $|\\,J, M\\rangle$ 张成，其中磁量子数 $M$ 的取值为 $M = -J, -J+1, \\dots, J$。我们可以在一个 $(2J+1)$ 维复向量空间中将这些基态表示为列向量。一个标准的约定是通过关系 $i=M+J$ 将量子数 $M$ 映射到从零开始的矩阵索引 $i$。\n\n角动量算符 $\\hat{J}_{\\pm}$ 和 $\\hat{J}_z$ 作用于这些基态。问题要求从升降算符构建 $\\hat{J}_y$，其作用定义如下：\n$$\n\\hat{J}_{+} |\\,J, M\\rangle = \\sqrt{J(J+1) - M(M+1)} \\,|\\,J, M+1\\rangle\n$$\n$$\n\\hat{J}_{-} |\\,J, M\\rangle = \\sqrt{J(J+1) - M(M-1)} \\,|\\,J, M-1\\rangle\n$$\n在所选基中，矩阵元 $\\langle J, M'| \\hat{J}_+ | J, M \\rangle$ 仅在 $M' = M+1$ 时非零。这意味着 $\\hat{J}_+$ 是一个仅在超对角线上有非零元素的矩阵。其厄米共轭 $\\hat{J}_- = \\hat{J}_+^{\\dagger}$ 在次对角线上有非零元素。当 $\\hbar=1$ 时，$\\hat{J}_y$ 的矩阵表示则计算为：\n$$\n\\hat{J}_y = \\frac{\\hat{J}_+ - \\hat{J}_-}{2i}\n$$\n这将得到一个纯虚、反对称的 $(2J+1) \\times (2J+1)$ 矩阵。\n\n**2. Wigner d-矩阵和D-矩阵的计算**\n\n问题指明了Wigner D-矩阵的因子分解：\n$$\nD^{J}_{M K}(\\alpha,\\beta,\\gamma) = e^{-i M \\alpha}\\, d^{J}_{M K}(\\beta)\\, e^{-i K \\gamma}\n$$\n核心部分，即Wigner（小）d-矩阵元 $d^{J}_{M K}(\\beta)$，是绕y轴旋转算符的矩阵元：\n$$\nd^{J}_{M K}(\\beta) = \\langle J, M | e^{-i \\beta \\hat{J}_{y}} | J, K \\rangle\n$$\n按照规定，这不是通过解析公式计算的，而是首先计算矩阵指数 $d^J(\\beta) = \\exp(-i\\beta \\hat{J}_y)$，其中 $\\hat{J}_y$ 是上一步构建的矩阵。然后从这个得到的 $(2J+1) \\times (2J+1)$ 矩阵的第 $i=M+J$ 行和第 $j=K+J$ 列中提取所需的元素 $d^{J}_{M K}(\\beta)$。\n\n**3. 正交性积分的数值计算**\n\n需要计算的积分是：\n$$\nI = \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta\\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; D^{J}_{M K}(\\alpha,\\beta,\\gamma)\\, \\left[D^{J'}_{M' K'}(\\alpha,\\beta,\\gamma)\\right]^{*}\n$$\n代入 $D$ 及其复共轭的因子分解，得到：\n$$\nI = \\int_{0}^{2\\pi} e^{-i(M-M')\\alpha}d\\alpha \\int_{0}^{\\pi} d^{J}_{M K}(\\beta)\\left[d^{J'}_{M' K'}(\\beta)\\right]^{*} \\sin\\beta d\\beta \\int_{0}^{2\\pi} e^{-i(K-K')\\gamma}d\\gamma\n$$\n问题严格要求使用对每个维度不同的方法来数值计算这个三重积分。\n\n**$\\alpha$ 和 $\\gamma$ 积分：** 这些积分使用梯形法则在区间 $[0, 2\\pi)$ 上用 $N_\\alpha=128$ 和 $N_\\gamma=128$ 个点进行计算。对于形式为 $\\int_0^{2\\pi} e^{-i\\Delta n \\theta} d\\theta$ 的积分，梯形近似为 $\\frac{2\\pi}{N} \\sum_{j=0}^{N-1} e^{-i\\Delta n \\theta_j}$，其中 $\\theta_j = 2\\pi j / N$。这个和是一个几何级数，如果 $\\Delta n$ 是 $N$ 的倍数（包括0），其值为 $N$，否则为 $0$。对于测试用例中的整数值 $M, M', K, K'$，有 $|M-M'| \\ll N_\\alpha$ 和 $|K-K'| \\ll N_\\gamma$。因此，数值积分将是精确的，得到 $2\\pi \\delta_{MM'}$ 和 $2\\pi \\delta_{KK'}$。\n\n**$\\beta$ 积分：** $\\beta$ 积分为 $I_\\beta = \\int_0^\\pi f(\\beta) \\sin\\beta d\\beta$，其中 $f(\\beta) = d^{J}_{M K}(\\beta)\\left[d^{J'}_{M' K'}(\\beta)\\right]^{*}$。应用变量替换 $x = \\cos\\beta$，使得 $dx = -\\sin\\beta d\\beta$，积分变为 $I_\\beta = \\int_{-1}^1 f(\\arccos x) dx$。这使用 $N_\\beta=64$ 点的Gauss-Legendre求积法进行计算。我们得到一组节点 $x_k$ 和权重 $w_k$，积分由以下和式近似：\n$$\nI_\\beta \\approx \\sum_{k=0}^{N_\\beta-1} w_k \\, d^{J}_{M K}(\\arccos x_k)\\left[d^{J'}_{M' K'}(\\arccos x_k)\\right]^{*}\n$$\n\n总的数值积分 $I_{\\text{numeric}}$ 是三个一维求积结果的乘积。\n\n**4. 比较与验证**\n\n对于每个测试用例，将数值计算的积分 $I_{\\text{numeric}}$ 与解析值 $I_{\\text{analytic}} = \\frac{8\\pi^{2}}{2J+1}\\, \\delta_{J J'}\\, \\delta_{M M'}\\, \\delta_{K K'}$ 进行比较。验证标准是一个混合的绝对-相对误差测试：\n$$\n\\left| I_{\\text{numeric}} - I_{\\text{analytic}} \\right| \\le \\varepsilon \\times \\max\\!\\left(1, \\left| I_{\\text{analytic}} \\right| \\right)\n$$\n其中 $\\varepsilon = 10^{-6}$。这确保了在 $I_{\\text{analytic}}=0$ 的情况下，测试变为对绝对容差 $\\varepsilon$ 的检查，而对于非零的 $I_{\\text{analytic}}$，则是一个相对容差检查。根据此比较返回一个布尔结果（`True`/`False`）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for validating the orthogonality of Wigner D-matrices.\n    \"\"\"\n    \n    # Test suite: each tuple is (J, J', M, M', K, K')\n    test_cases = [\n        (0, 0, 0, 0, 0, 0),    # Case 1\n        (1, 1, 1, 1, -1, -1), # Case 2\n        (2, 2, 0, 1, 2, 2),    # Case 3\n        (2, 3, 0, 0, -1, -1), # Case 4\n        (3, 3, -2, -2, 1, -1),# Case 5\n        (4, 4, 0, 0, 0, 0),    # Case 6\n    ]\n\n    # Memoization caches for angular momentum matrices and their exponentials\n    jy_matrices_cache = {}\n    \n    def get_jy(j_val):\n        \"\"\"\n        Constructs the matrix representation of the J_y angular momentum operator.\n        Uses memoization to avoid redundant calculations.\n        \"\"\"\n        if j_val in jy_matrices_cache:\n            return jy_matrices_cache[j_val]\n\n        if not isinstance(j_val, int) or j_val  0:\n            raise ValueError(\"J must be a non-negative integer.\")\n        \n        dim = 2 * j_val + 1\n        if dim == 1: # Handle J=0 case explicitly\n            jy_matrix = np.zeros((1, 1), dtype=np.complex128)\n            jy_matrices_cache[j_val] = jy_matrix\n            return jy_matrix\n            \n        m_values = np.arange(-j_val, j_val + 1)\n        \n        jp_matrix = np.zeros((dim, dim), dtype=np.float64)\n        \n        for i in range(dim - 1):\n            m = m_values[i]\n            jp_matrix[i + 1, i] = np.sqrt(j_val * (j_val + 1) - m * (m + 1))\n            \n        jm_matrix = jp_matrix.T\n        \n        jy_matrix = (jp_matrix - jm_matrix) / (2j)\n        \n        jy_matrices_cache[j_val] = jy_matrix\n        return jy_matrix\n\n    d_matrices_cache = {}\n    def get_d_matrix(j_val, beta):\n        \"\"\"\n        Computes the Wigner d-matrix for a given J and beta via matrix exponentiation.\n        \"\"\"\n        if (j_val, beta) in d_matrices_cache:\n            return d_matrices_cache[(j_val, beta)]\n        \n        jy = get_jy(j_val)\n        d_mat = expm(-1j * beta * jy)\n        d_matrices_cache[(j_val, beta)] = d_mat\n        return d_mat\n\n    def get_d_element(j_val, m_val, k_val, beta):\n        \"\"\"\n        Extracts a single element d^J_{MK}(beta) from the full d-matrix.\n        \"\"\"\n        d_mat = get_d_matrix(j_val, beta)\n        row_idx = int(m_val + j_val)\n        col_idx = int(k_val + j_val)\n        return d_mat[row_idx, col_idx]\n\n    def trapezoidal_integral(delta_n, N):\n        \"\"\"Computes integral of exp(-i*delta_n*theta) from 0 to 2pi using trapezoidal rule.\"\"\"\n        theta = np.linspace(0, 2 * np.pi, N, endpoint=False)\n        integrand = np.exp(-1j * delta_n * theta)\n        return (2 * np.pi / N) * np.sum(integrand)\n\n    # Integration parameters\n    N_alpha = 128\n    N_gamma = 128\n    N_beta = 64\n    epsilon = 1e-6\n    \n    x_beta, w_beta = leggauss(N_beta)\n    beta_nodes = np.arccos(x_beta)\n\n    results = []\n    for J, J_prime, M, M_prime, K, K_prime in test_cases:\n        \n        int_alpha = trapezoidal_integral(M - M_prime, N_alpha)\n        int_gamma = trapezoidal_integral(K - K_prime, N_gamma)\n\n        integrand_beta = np.zeros(N_beta, dtype=np.complex128)\n        if J >= 0 and J_prime >= 0:\n            for i in range(N_beta):\n                beta = beta_nodes[i]\n                d_J_MK = get_d_element(J, M, K, beta)\n                d_Jp_MpKp = get_d_element(J_prime, M_prime, K_prime, beta)\n                integrand_beta[i] = d_J_MK * np.conj(d_Jp_MpKp)\n        \n        int_beta = np.sum(w_beta * integrand_beta)\n\n        I_numeric = int_alpha * int_beta * int_gamma\n        \n        I_analytic = 0.0\n        if J == J_prime and M == M_prime and K == K_prime:\n            if 2 * J + 1 > 0:\n                I_analytic = (8 * np.pi**2) / (2 * J + 1)\n        \n        max_val = max(1.0, abs(I_analytic))\n        is_pass = abs(I_numeric - I_analytic) = epsilon * max_val\n        results.append(is_pass)\n\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"True\").replace(\"False\", \"False\"))\n```", "id": "3542272"}, {"introduction": "在实现了投影积分之后，一个关键问题随之而来：数值积分网格需要多精细才能获得可靠的结果？使用固定的、任意的网格可能会导致显著的计算误差。本实践将探讨数值收敛性的概念。投影观测量（例如，范数）的准确性取决于离散求积网格对被积函数特征的解析能力，该被积函数结合了平滑的重叠核心与可能振荡的 Wigner D 函数。您将实现一种自适应网格细化策略，这是一种在科学计算中用于高效达到所需精度的强大技术。通过将一个模型核心的收敛数值结果与精确解析解进行比较，您将在设计和验证稳健数值程序方面获得宝贵的实践经验。[@problem_id:3542290]", "problem": "您的任务是设计、实现并验证一个收敛性测试策略，该策略用于通过对三个欧拉角进行数值积分来计算角动量投影观测量。考虑将一个平均场态投影到具有确定总角动量的态上。从投影算符的算符级定义开始\n$$\n\\hat{P}^{J}_{MK} = \\frac{2J+1}{8\\pi^2} \\int d\\Omega \\, \\mathcal{D}^{J}_{MK}(\\Omega)^{\\ast} \\, \\hat{R}(\\Omega),\n$$\n其中 $J$ 是总角动量，$M$ 和 $K$ 是其投影，$\\hat{R}(\\Omega)$ 是通过欧拉角 $\\Omega \\equiv (\\alpha,\\beta,\\gamma)$ 的转动算符，其不变测度为\n$$\nd\\Omega = d\\alpha \\; \\sin\\beta \\; d\\beta \\; d\\gamma,\n$$\n$\\mathcal{D}^{J}_{MK}(\\Omega)$ 是 Wigner D-矩阵。对于一个一般的平均场态 $|\\Phi\\rangle$，其投影模核为\n$$\n\\mathcal{N}^{J}_{MK} = \\langle \\Phi | \\hat{P}^{J}_{MK} | \\Phi \\rangle = \\frac{2J+1}{8\\pi^2} \\int d\\Omega \\, \\mathcal{D}^{J}_{MK}(\\Omega)^{\\ast} \\, \\langle \\Phi | \\hat{R}(\\Omega) | \\Phi \\rangle.\n$$\n对于本任务，我们特化到 $M=K=0$ 的情况，并将交叠核建模为一个光滑、可因子化的函数\n$$\nn(\\Omega) \\equiv \\langle \\Phi | \\hat{R}(\\Omega) | \\Phi \\rangle = \\exp\\big(\\kappa \\cos\\beta\\big)\\, \\exp\\big(\\rho \\cos\\alpha\\big)\\, \\exp\\big(\\sigma \\cos\\gamma\\big),\n$$\n其中 $\\kappa \\ge 0$、$\\rho \\ge 0$ 和 $\\sigma \\ge 0$ 是实数参数。利用当 $M=K=0$ 时 $\\mathcal{D}^{J}_{00}(\\alpha,\\beta,\\gamma) = P_{J}(\\cos\\beta)$ 这一事实，其中 $P_J$ 是 $J$ 阶 Legendre 多项式。\n\n您的目标是：\n- 推导出投影模的精确闭式表达式（用常见的特殊函数表示）\n$$\n\\mathcal{N}^{J} \\equiv \\mathcal{N}^{J}_{00} = \\frac{2J+1}{8\\pi^2} \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta \\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; P_{J}(\\cos\\beta)\\, \\exp(\\kappa \\cos\\beta)\\, \\exp(\\rho \\cos\\alpha)\\, \\exp(\\sigma \\cos\\gamma).\n$$\n- 使用欧拉角的离散网格，并根据以下求积法则，为 $\\mathcal{N}^{J}$ 构建一个数值积分器：\n  1. 对于 $\\alpha \\in [0,2\\pi)$ 和 $\\gamma \\in [0,2\\pi)$，分别使用具有 $N_{\\alpha}$ 和 $N_{\\gamma}$ 个等距节点和恒定权重的均匀梯形法则。角度单位必须是弧度。\n  2. 对于 $\\beta \\in [0,\\pi]$，在变换后的变量 $x = \\cos\\beta \\in [-1,1]$ 上使用 Gauss-Legendre 求积，使得\n     $$\n     \\int_{0}^{\\pi} \\sin\\beta \\, g(\\cos\\beta) \\, d\\beta = \\int_{-1}^{1} g(x) \\, dx,\n     $$\n     其中，使用 Gauss-Legendre 节点和权重来近似计算具有 $N_{\\beta}$ 个节点的变量 $x$ 上的积分。\n- 设计一个收敛性测试程序，该程序通过将当前对投影观测量产生最大变化的维度中的 $N_{\\alpha}$、$N_{\\beta}$ 或 $N_{\\gamma}$ 加倍来动态加密欧拉角网格。使用一个基于当前估计值与在每个维度上将网格点数加倍后得到的估计值之间的最大相对变化的实用停止判据。具体来说，当这三个单步相对变化中的最大值严格小于用户指定的容差 $\\varepsilon$ 时，终止加密过程。\n- 为了进行验证，将最终的数值估计值与精确表达式进行比较，以计算后验误差。当精确值的量级大于 $10^{-14}$ 时，报告相对误差；否则，报告绝对误差。\n\n实现细节和约束：\n- 数值积分必须以弧度为单位进行。\n- 程序必须是自包含的，且不得需要用户输入。\n- 您必须实现上述的自适应加密过程。从 $N_{\\alpha}=N_{\\beta}=N_{\\gamma}=4$ 开始加密，并在每一步中只将对应于最大单步相对变化的那个维度的网格点数加倍。当满足停止判据或任何维度中的网格点数达到指定的上限 $N$ 时停止。\n- 仅使用上文详述的标准科学函数和求积法则；不要使用任何预封装的角动量投影例程。\n\n根据需要，使用常见的特殊函数提供精确表达式。您的推导应基于给定的基本定义以及关于正交多项式和特殊函数的经过充分检验的恒等式，但不要在没有给出理由的情况下直接跳到最终表达式。\n\n测试套件：\n实现您的程序以运行以下五个测试用例。对于每个用例，使用给定的参数 $(J,\\kappa,\\rho,\\sigma)$、停止容差 $\\varepsilon$ 和最大网格尺寸 $(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max})$。在所有用例中，角度单位均为弧度。\n\n- 用例 1 (基线光滑): $(J,\\kappa,\\rho,\\sigma) = (0, 0.5, 0.5, 0.5)$，$\\varepsilon = 10^{-9}$，$(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (256,256,256)$。\n- 用例 2 ($\\beta$ 方向存在大的 $J$ 振荡): $(J,\\kappa,\\rho,\\sigma) = (6, 8.0, 1.0, 1.5)$，$\\varepsilon = 10^{-8}$，$(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (256,512,256)$。\n- 用例 3 ($\\alpha$ 方向存在陡峭结构): $(J,\\kappa,\\rho,\\sigma) = (4, 1.0, 6.0, 0.0)$，$\\varepsilon = 10^{-8}$，$(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (512,256,256)$。\n- 用例 4 (所有角度方向同时存在陡峭变化): $(J,\\kappa,\\rho,\\sigma) = (10, 12.0, 3.0, 3.0)$，$\\varepsilon = 10^{-7}$，$(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (512,512,512)$。\n- 用例 5 ($\\beta$ 方向近乎平坦，$\\alpha$ 和 $\\gamma$ 方向非常陡峭): $(J,\\kappa,\\rho,\\sigma) = (2, 0.01, 10.0, 10.0)$，$\\varepsilon = 10^{-9}$，$(N_{\\alpha}^{\\max},N_{\\beta}^{\\max},N_{\\gamma}^{\\max}) = (1024,512,1024)$。\n\n最终输出规范：\n- 对于每个测试用例，使用自适应程序计算最终的数值估计值，然后根据上述规定计算与精确表达式的误差。\n- 您的程序应生成单行输出，其中包含一个 Python 风格的列表，内有五个浮点数，每个数分别是按上文顺序排列的相应测试用例的误差。该行必须严格格式化为由方括号括起来的逗号分隔列表，例如：\"[e1,e2,e3,e4,e5]\"。", "solution": "提出的问题是为一个特定的角动量投影模推导精确表达式，为其构建一个自适应数值积分器，并针对一系列测试用例，用精确结果验证数值结果。该问题定义明确、科学上合理且计算上可行。我们按要求进行推导和实现。\n\n### 1. 投影模的解析推导\n\n需要计算的投影模由以下积分给出：\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} \\int_{0}^{2\\pi} d\\alpha \\int_{0}^{\\pi} \\sin\\beta \\, d\\beta \\int_{0}^{2\\pi} d\\gamma \\; P_{J}(\\cos\\beta)\\, \\exp(\\kappa \\cos\\beta)\\, \\exp(\\rho \\cos\\alpha)\\, \\exp(\\sigma \\cos\\gamma)\n$$\n其中 $J$、$\\kappa$、$\\rho$ 和 $\\sigma$ 是非负实数参数，$P_J(x)$ 是 $J$ 阶 Legendre 多项式。被积函数相对于三个欧拉角 $\\alpha$、$\\beta$ 和 $\\gamma$ 是可分离的。因此，该三重积分可以分解为三个一维积分的乘积：\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} \\left[ \\int_{0}^{2\\pi} \\exp(\\rho \\cos\\alpha) \\, d\\alpha \\right] \\left[ \\int_{0}^{\\pi} P_{J}(\\cos\\beta) \\exp(\\kappa \\cos\\beta) \\sin\\beta \\, d\\beta \\right] \\left[ \\int_{0}^{2\\pi} \\exp(\\sigma \\cos\\gamma) \\, d\\gamma \\right]\n$$\n我们分别计算这些积分。\n\n**关于 $\\alpha$ 和 $\\gamma$ 的积分**\n\n关于 $\\alpha$ 和 $\\gamma$ 的积分形式相同。考虑关于 $\\alpha$ 的积分：\n$$\nI_\\alpha = \\int_{0}^{2\\pi} \\exp(\\rho \\cos\\alpha) \\, d\\alpha\n$$\n该积分是零阶第一类修正 Bessel 函数 $I_0(z)$ 的一个标准表示，由以下恒等式给出：\n$$\nI_0(z) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(z \\cos\\theta) \\, d\\theta\n$$\n因此，我们有：\n$$\nI_\\alpha = 2\\pi I_0(\\rho)\n$$\n根据相同的推理，关于 $\\gamma$ 的积分为：\n$$\nI_\\gamma = \\int_{0}^{2\\pi} \\exp(\\sigma \\cos\\gamma) \\, d\\gamma = 2\\pi I_0(\\sigma)\n$$\n\n**关于 $\\beta$ 的积分**\n\n关于 $\\beta$ 的积分为：\n$$\nI_\\beta = \\int_{0}^{\\pi} P_{J}(\\cos\\beta) \\exp(\\kappa \\cos\\beta) \\sin\\beta \\, d\\beta\n$$\n我们进行变量代换 $x = \\cos\\beta$，这意味着 $dx = -\\sin\\beta \\, d\\beta$。积分限 $\\beta \\in [0, \\pi]$ 变为 $x \\in [1, -1]$。\n$$\nI_\\beta = \\int_{1}^{-1} P_{J}(x) \\exp(\\kappa x) (-dx) = \\int_{-1}^{1} P_{J}(x) \\exp(\\kappa x) \\, dx\n$$\n该积分可以利用指数函数在 Legendre 多项式基上的展开式来计算：\n$$\ne^{zx} = \\sum_{l=0}^{\\infty} (2l+1) i_l(z) P_l(x)\n$$\n其中 $i_l(z)$ 是 $l$ 阶第一类修正球 Bessel 函数。利用 Legendre 多项式的正交性，\n$$\n\\int_{-1}^{1} P_J(x) P_l(x) dx = \\frac{2}{2l+1} \\delta_{Jl}\n$$\n我们将展开式乘以 $P_J(x)$ 并在 $x \\in [-1, 1]$ 上积分：\n$$\n\\int_{-1}^{1} P_J(x) e^{\\kappa x} dx = \\sum_{l=0}^{\\infty} (2l+1) i_l(\\kappa) \\int_{-1}^{1} P_J(x) P_l(x) dx = \\sum_{l=0}^{\\infty} (2l+1) i_l(\\kappa) \\left( \\frac{2}{2l+1} \\delta_{Jl} \\right)\n$$\n求和式对 $l=J$ 塌缩为一项：\n$$\nI_\\beta = 2 i_J(\\kappa)\n$$\n\n**最终表达式**\n\n将 $I_\\alpha$、$I_\\beta$ 和 $I_\\gamma$ 的结果代入 $\\mathcal{N}^{J}$ 的表达式中：\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} (2\\pi I_0(\\rho)) (2 i_J(\\kappa)) (2\\pi I_0(\\sigma))\n$$\n$$\n\\mathcal{N}^{J} = \\frac{2J+1}{8\\pi^2} (8\\pi^2) I_0(\\rho) I_0(\\sigma) i_J(\\kappa)\n$$\n因此，投影模的精确闭式表达式为：\n$$\n\\mathcal{N}^{J} = (2J+1) \\, I_0(\\rho) \\, I_0(\\sigma) \\, i_J(\\kappa)\n$$\n该表达式依赖于标准科学库中提供的常见特殊函数。\n\n### 2. 数值积分方案\n\n$\\mathcal{N}^{J}$ 的数值积分是通过将三维积分在欧拉角上离散化来执行的。由于被积函数是可分离的，我们可以分别对每个一维积分进行数值计算，然后将结果相乘。\n\n- **关于 $\\alpha$ 和 $\\gamma$**：积分区间为 $[0, 2\\pi)$。我们使用周期函数的梯形法则，这涉及到对 $N$ 个等距点上的函数值求和，然后乘以步长 $h=2\\pi/N$。对于一组节点 $\\{\\theta_i = i \\frac{2\\pi}{N}\\}_{i=0}^{N-1}$，积分近似为：\n$$\n\\int_0^{2\\pi} f(\\theta) d\\theta \\approx \\frac{2\\pi}{N} \\sum_{i=0}^{N-1} f(\\theta_i)\n$$\n对于光滑的周期函数，该法则具有谱精度。\n\n- **关于 $\\beta$**：关于 $\\beta$ 的积分被转换为在 $[-1, 1]$ 上关于 $x = \\cos\\beta$ 的积分。这种形式非常适合使用 Gauss-Legendre 求积。使用 $N_\\beta$ 个节点 $x_j$ 和权重 $w_j$，积分近似为：\n$$\n\\int_{-1}^{1} g(x) dx \\approx \\sum_{j=0}^{N_\\beta-1} w_j g(x_j)\n$$\n对于光滑的被积函数，此方法非常高效，用相对较少的节点就能达到很高的精度。\n\n完整的数值估计值是这三个数值积分的乘积，再乘以原始定义中的相应前置因子：\n$$\n\\mathcal{N}^{J}_{\\text{num}} = \\frac{2J+1}{8\\pi^2} \\left[ \\frac{2\\pi}{N_\\alpha} \\sum_{i=0}^{N_\\alpha-1} e^{\\rho\\cos\\alpha_i} \\right] \\left[ \\sum_{j=0}^{N_\\beta-1} w_j P_J(x_j) e^{\\kappa x_j} \\right] \\left[ \\frac{2\\pi}{N_\\gamma} \\sum_{k=0}^{N_\\gamma-1} e^{\\sigma\\cos\\gamma_k} \\right]\n$$\n这可以简化为：\n$$\n\\mathcal{N}^{J}_{\\text{num}} = \\frac{2J+1}{2} \\left[ \\frac{1}{N_\\alpha} \\sum_{i=0}^{N_\\alpha-1} e^{\\rho\\cos\\alpha_i} \\right] \\left[ \\sum_{j=0}^{N_\\beta-1} w_j P_J(x_j) e^{\\kappa x_j} \\right] \\left[ \\frac{1}{N_\\gamma} \\sum_{k=0}^{N_\\gamma-1} e^{\\sigma\\cos\\gamma_k} \\right]\n$$\n\n### 3. 自适应加密策略\n\n一个稳健的数值计算需要进行收敛性测试。我们实现一个自适应网格加密程序，以自动确定达到所需容差 $\\varepsilon$ 所需的求积点数 ($N_\\alpha, N_\\beta, N_\\gamma$)。\n\n该程序从一个粗网格开始，例如 $N_\\alpha=N_\\beta=N_\\gamma=4$。然后，它在对结果影响最显著的单个维度上迭代地加密网格。\n在具有网格 $(N_\\alpha, N_\\beta, N_\\gamma)_k$ 的每一步 $k$：\n1.  计算当前模值，$V_k = \\mathcal{N}^{J}_{\\text{num}}((N_\\alpha, N_beta, N_\\gamma)_k)$。\n2.  分别将每个维度的点数加倍来加密，并计算三个测试值：\n    - $V_{\\alpha} = \\mathcal{N}^{J}_{\\text{num}}((2N_\\alpha, N_\\beta, N_\\gamma)_k)$\n    - $V_{\\beta} = \\mathcal{N}^{J}_{\\text{num}}((N_\\alpha, 2N_\\beta, N_\\gamma)_k)$\n    - $V_{\\gamma} = \\mathcal{N}^{J}_{\\text{num}}((N_\\alpha, N_\\beta, 2N_\\gamma)_k)$\n3.  计算每个维度的一步相对变化：\n    - $\\delta_\\alpha = |V_\\alpha - V_k| / |V_k|$\n    - $\\delta_\\beta = |V_\\beta - V_k| / |V_k|$\n    - $\\delta_\\gamma = |V_\\gamma - V_k| / |V_k|$\n    （对分母 $|V_k|$ 使用一个小的阈值以防止除以零，必要时回退到绝对变化）。\n4.  找到最大变化，$\\delta_{\\max} = \\max(\\delta_\\alpha, \\delta_\\beta, \\delta_\\gamma)$。\n5.  如果 $\\delta_{\\max}  \\varepsilon$，程序已收敛，并将 $V_k$ 作为最终的数值估计值。\n6.  否则，通过将产生 $\\delta_{\\max}$ 的维度中的点数加倍来创建下一次迭代的网格 $(N_\\alpha, N_\\beta, N_\\gamma)_{k+1}$。例如，如果 $\\delta_\\alpha = \\delta_{\\max}$，则 $(N_\\alpha, N_\\beta, N_\\gamma)_{k+1} = (2N_\\alpha, N_\\beta, N_\\gamma)_k$。这将计算资源优先分配给被积函数变化最剧烈的维度，从而实现资源的有效分配。\n7.  如果任何网格尺寸超过其指定的上限，循环也会终止。\n\n这种自适应方法确保了数值积分的准确性和效率，它能自动根据每个测试用例中被积函数的特性调整网格密度。然后将最终收敛的数值与精确的解析表达式进行比较，以计算后验误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0, spherical_in, legendre\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for adaptive angular momentum projection.\n    \"\"\"\n    \n    # (Parameter set), tolerance, max_mesh_sizes\n    test_cases = [\n        # Case 1 (baseline smooth)\n        ((0, 0.5, 0.5, 0.5), 1e-9, (256, 256, 256)),\n        # Case 2 (large J-oscillations in beta)\n        ((6, 8.0, 1.0, 1.5), 1e-8, (256, 512, 256)),\n        # Case 3 (sharp structure in alpha)\n        ((4, 1.0, 6.0, 0.0), 1e-8, (512, 256, 256)),\n        # Case 4 (simultaneously sharp in all angles)\n        ((10, 12.0, 3.0, 3.0), 1e-7, (512, 512, 512)),\n        # Case 5 (nearly flat in beta, very sharp in alpha and gamma)\n        ((2, 0.01, 10.0, 10.0), 1e-9, (1024, 512, 1024)),\n    ]\n\n    # Caches for memoizing quadrature results to improve performance\n    alpha_integral_cache = {}\n    beta_integral_cache = {}\n    gamma_integral_cache = {}\n\n    def integrate_alpha(rho, n_alpha):\n        \"\"\"Computes the integral over the Euler angle alpha.\"\"\"\n        if (rho, n_alpha) in alpha_integral_cache:\n            return alpha_integral_cache[(rho, n_alpha)]\n        \n        # Trapezoidal rule for a periodic function\n        alpha_nodes = np.linspace(0, 2 * np.pi, n_alpha, endpoint=False)\n        integrand_values = np.exp(rho * np.cos(alpha_nodes))\n        integral = (2 * np.pi / n_alpha) * np.sum(integrand_values)\n        \n        alpha_integral_cache[(rho, n_alpha)] = integral\n        return integral\n\n    def integrate_gamma(sigma, n_gamma):\n        \"\"\"Computes the integral over the Euler angle gamma.\"\"\"\n        if (sigma, n_gamma) in gamma_integral_cache:\n            return gamma_integral_cache[(sigma, n_gamma)]\n\n        # Trapezoidal rule for a periodic function\n        gamma_nodes = np.linspace(0, 2 * np.pi, n_gamma, endpoint=False)\n        integrand_values = np.exp(sigma * np.cos(gamma_nodes))\n        integral = (2 * np.pi / n_gamma) * np.sum(integrand_values)\n        \n        gamma_integral_cache[(sigma, n_gamma)] = integral\n        return integral\n\n    gauss_legendre_cache = {}\n    def get_gauss_legendre_points(n_beta):\n        if n_beta in gauss_legendre_cache:\n            return gauss_legendre_cache[n_beta]\n        nodes, weights = np.polynomial.legendre.leggauss(n_beta)\n        gauss_legendre_cache[n_beta] = (nodes, weights)\n        return nodes, weights\n\n    def integrate_beta(J, kappa, n_beta):\n        \"\"\"Computes the integral over the Euler angle beta.\"\"\"\n        if (J, kappa, n_beta) in beta_integral_cache:\n            return beta_integral_cache[(J, kappa, n_beta)]\n\n        # Gauss-Legendre quadrature\n        x_nodes, weights = get_gauss_legendre_points(n_beta)\n        P_J = legendre(J)\n        integrand_values = P_J(x_nodes) * np.exp(kappa * x_nodes)\n        integral = np.sum(weights * integrand_values)\n        \n        beta_integral_cache[(J, kappa, n_beta)] = integral\n        return integral\n\n    def calculate_norm(params, n_alpha, n_beta, n_gamma):\n        \"\"\"Calculates the projected norm for a given mesh.\"\"\"\n        J, kappa, rho, sigma = params\n        \n        integral_alpha = integrate_alpha(rho, n_alpha)\n        integral_beta = integrate_beta(J, kappa, n_beta)\n        integral_gamma = integrate_gamma(sigma, n_gamma)\n        \n        prefactor = (2 * J + 1) / (8 * np.pi**2)\n        \n        return prefactor * integral_alpha * integral_beta * integral_gamma\n\n    def calculate_exact_norm(params):\n        \"\"\"Calculates the exact projected norm using special functions.\"\"\"\n        J, kappa, rho, sigma = params\n        \n        if kappa == 0:\n            i_j_kappa = 1.0 if J == 0 else 0.0\n        else:\n            i_j_kappa = spherical_in(J, kappa)\n\n        return (2 * J + 1) * i0(rho) * i0(sigma) * i_j_kappa\n\n    results = []\n    for params, epsilon, max_Ns in test_cases:\n        alpha_integral_cache.clear()\n        beta_integral_cache.clear()\n        gamma_integral_cache.clear()\n        gauss_legendre_cache.clear()\n\n        J, kappa, rho, sigma = params\n        n_alpha_max, n_beta_max, n_gamma_max = max_Ns\n\n        n_alpha, n_beta, n_gamma = 4, 4, 4\n        \n        while True:\n            current_norm = calculate_norm(params, n_alpha, n_beta, n_gamma)\n\n            # Test refinement in alpha\n            if 2 * n_alpha = n_alpha_max:\n                norm_alpha = calculate_norm(params, 2 * n_alpha, n_beta, n_gamma)\n                if abs(current_norm) > 1e-20:\n                    change_alpha = abs(norm_alpha - current_norm) / abs(current_norm)\n                else:\n                    change_alpha = abs(norm_alpha - current_norm)\n            else:\n                change_alpha = 0.0\n\n            # Test refinement in beta\n            if 2 * n_beta = n_beta_max:\n                norm_beta = calculate_norm(params, n_alpha, 2 * n_beta, n_gamma)\n                if abs(current_norm) > 1e-20:\n                    change_beta = abs(norm_beta - current_norm) / abs(current_norm)\n                else:\n                    change_beta = abs(norm_beta - current_norm)\n            else:\n                change_beta = 0.0\n            \n            # Test refinement in gamma\n            if 2 * n_gamma = n_gamma_max:\n                norm_gamma = calculate_norm(params, n_alpha, n_beta, 2 * n_gamma)\n                if abs(current_norm) > 1e-20:\n                    change_gamma = abs(norm_gamma - current_norm) / abs(current_norm)\n                else:\n                    change_gamma = abs(norm_gamma - current_norm)\n            else:\n                change_gamma = 0.0\n\n            max_change = max(change_alpha, change_beta, change_gamma)\n\n            if max_change  epsilon or max_change == 0.0:\n                final_numerical_norm = current_norm\n                break\n            \n            # Refine the dimension with the largest change\n            if change_alpha >= change_beta and change_alpha >= change_gamma:\n                n_alpha *= 2\n            elif change_beta >= change_alpha and change_beta >= change_gamma:\n                n_beta *= 2\n            else:\n                n_gamma *= 2\n\n        exact_norm = calculate_exact_norm(params)\n        \n        if abs(exact_norm) > 1e-14:\n            error = abs(final_numerical_norm - exact_norm) / abs(exact_norm)\n        else:\n            error = abs(final_numerical_norm - exact_norm)\n        \n        results.append(error)\n\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3542290"}, {"introduction": "角动量投影通常用于为组态相互作用计算生成一组基矢。然而，这些投影态通常不是正交的，甚至可能是近似线性相关的，这带来了重大的数值挑战。本实践将处理在非正交基中出现的广义本征值问题 $H \\mathbf{c} = E S \\mathbf{c}$。它着重于正则正交化，这是一种消除线性相关性并将问题转化为稳定标准本征值问题的标准程序。通过一个精心构造的模型系统，您将学习如何诊断和处理重叠矩阵 $S$ 中的病态条件，并研究用于筛选 $S$ 的小本征值的截断阈值选择如何直接影响计算的稳定性以及最终得到的能谱的物理内容。[@problem_id:3542310]", "problem": "在原子核多体理论中，考虑 Hartree-Fock-Bogoliubov (HFB) 平均场态的角动量投影组态混合。投影基态的非正交性导致在由投影组态张成的子空间中，哈密顿量存在一个广义本征值问题。您的任务是实现正则正交化以解决线性相关问题，并研究截断阈值对重叠矩阵小本征值以及最终能谱的影响。\n\n从非正交子空间中定态的变分原理出发：在非正交投影态的线性组合上最小化哈密顿量的瑞利商，会得到一个形如 $H \\mathbf{c} = E S \\mathbf{c}$ 的广义本征值问题，其中 $S$ 是基态之间的重叠矩阵，$H$ 是哈密顿量矩阵。线性相关表现为 $S$ 的近零本征值，而正则正交化（也称为对称正交化）过程通过对角化 $S$ 并丢弃范数非常小的模式，来纠正非正交性和近线性相关性。\n\n您必须以纯数学形式构造一个维度为 $5$ 的对称半正定重叠矩阵 $S$ 和一个对称哈密顿量矩阵 $H$，使用确定性的正交变换和预设的本征值。具体来说：\n\n- 令 $n = 5$。\n- 定义在 $\\mathbb{R}^5$ 上的一系列由弧度角参数化的 Givens 旋转，以构造一个正交矩阵 $Q$：\n  - 在 $(0,1)$-平面中旋转角度 $\\alpha = 0.3$ (弧度)。\n  - 在 $(2,3)$-平面中旋转角度 $\\beta = -0.7$ (弧度)。\n  - 在 $(1,2)$-平面中旋转角度 $\\gamma = 0.5$ (弧度)。\n  - 在 $(0,4)$-平面中旋转角度 $\\delta = 0.2$ (弧度)。\n  这些旋转的乘积（按所述顺序应用）定义了 $Q$。\n- 使用 $Q$ 定义重叠矩阵 $S = Q \\,\\mathrm{diag}(s)\\, Q^{\\mathsf{T}}$，其本征值为 $s = [\\,1.0,\\;0.5,\\;0.05,\\;10^{-8},\\;0.2\\,]$。这个选择模拟了一个本征值为 $10^{-8}$ 的近似冗余方向和其他条件良好的方向。\n- 通过按以下顺序应用 Givens 旋转（以弧度为单位）定义另一个正交矩阵 $R$：\n  - 在 $(0,2)$-平面中旋转角度 $\\theta_1 = -0.4$。\n  - 在 $(3,4)$-平面中旋转角度 $\\theta_2 = 0.65$。\n  - 在 $(1,4)$-平面中旋转角度 $\\theta_3 = -0.25$。\n  - 在 $(0,3)$-平面中旋转角度 $\\theta_4 = 0.15$。\n- 使用 $R$ 定义哈密顿量 $H = R \\,\\mathrm{diag}(e)\\, R^{\\mathsf{T}}$，其能量为 $e = [\\,-8.0,\\,-2.0,\\;1.0,\\;3.0,\\;7.0\\,]$（单位为兆电子伏特 (MeV)）。\n\n请按以下步骤实现正则正交化，不使用任何快捷公式：对角化重叠矩阵 $S$，丢弃本征值低于截断阈值的本征模式，构建相应的正交归一子空间，将哈密顿量映射到该正交归一子空间中，并求解普通本征值问题以获得能量谱（单位 MeV）。如果在应用截断后没有本征模式剩下，则返回一个空列表，表示在这种情况下没有定义物理谱。\n\n使用以下截断阈值测试套件（均为绝对值，对于小于或等于截断值的本征值强制移除）：$\\epsilon \\in \\{\\,10^{-12},\\;10^{-6},\\;10^{-1},\\;6\\times 10^{-1},\\;2.0\\,\\}$。这些阈值覆盖了：\n- 保留几乎所有模式（包括近似冗余模式）的情况 ($\\epsilon = 10^{-12}$)。\n- 移除近零模式但保留所有条件良好模式的情况 ($\\epsilon = 10^{-6}$)。\n- 移除多个小范数模式的情况 ($\\epsilon = 10^{-1}$)。\n- 只保留一个模式的边界情况 ($\\epsilon = 6\\times 10^{-1}$)。\n- 移除所有模式的极端情况 ($\\epsilon = 2.0$）。\n\n对于每个阈值 $\\epsilon$，通过正则正交化和在保留的正交归一子空间中对角化哈密顿量来计算能量，并返回按升序排序的能量。将能量表示为四舍五入到六位小数的浮点数（单位为兆电子伏特 MeV）。最终输出必须将所有测试用例的结果聚合到单行中，格式为方括号内包含的逗号分隔列表，其中每个阈值的结果本身也是一个方括号内的逗号分隔列表，例如：$\"[[E_{1}^{(1)},E_{2}^{(1)},\\dots],[E_{1}^{(2)},\\dots],\\dots]\"$，其中每个 $E_{k}^{(i)}$ 都是一个 MeV 单位的浮点数。整个过程中角度均以弧度为单位。", "solution": "当前的问题是计算多体物理中一个适定且科学上合理的练习，具体涉及对建立在非正交投影平均场态基上的组态相互作用方法的数值稳定性处理。核心任务是通过应用正则正交化程序，求解广义本征值问题 (GEP) $H \\mathbf{c} = E S \\mathbf{c}$，以得到能谱 $E$。在投影 Hartree-Fock-Bogoliubov (HFB) 态的基组中，会出现近似线性相关性，这在重叠矩阵 $S$ 中表现为近零本征值，而此方法对于处理这种情况至关重要。\n\n解决方案包括三个主要阶段：\n1. 根据指定的谱分解，构造对称哈密顿量矩阵 $H$ 和对称半正定重叠矩阵 $S$。\n2. 实现正则正交化算法，该算法将 GEP 转换为一个在物理相关的、更小子空间内的标准本征值问题 (SEP)。\n3. 对一系列截断阈值 $\\epsilon$ 应用此程序，以研究它们对所得能谱的影响。\n\n**1. 矩阵的构造**\n\n矩阵 $H$ 和 $S$ 被构造为维度 $n=5$。它们的谱特性（本征值）是预先定义的，其本征向量分别由特定的正交变换矩阵 $R$ 和 $Q$ 决定，而这些矩阵本身是 Givens 旋转的乘积。\n\n在 $(i,j)$-平面上旋转角度 $\\phi$ 的 Givens 旋转由一个矩阵 $G_{i,j}(\\phi)$ 表示，该矩阵是单位矩阵，但有四个元素不同：$G_{ii} = G_{jj} = \\cos(\\phi)$，$G_{ij} = -\\sin(\\phi)$，以及 $G_{ji} = \\sin(\\phi)$。\n\n用于重叠矩阵 $S$ 的正交矩阵 $Q$ 定义为四个连续旋转的乘积：\n$$Q = G_{0,4}(\\delta) G_{1,2}(\\gamma) G_{2,3}(\\beta) G_{0,1}(\\alpha)$$\n角度分别为 $\\alpha = 0.3$，$\\beta = -0.7$，$\\gamma = 0.5$ 和 $\\delta = 0.2$ 弧度。然后，重叠矩阵 $S$ 构造为：\n$$S = Q \\,\\mathrm{diag}(s)\\, Q^{\\mathsf{T}}$$\n其中指定的本征值为 $s = [\\,1.0,\\;0.5,\\;0.05,\\;10^{-8},\\;0.2\\,]$。这种构造确保 $S$ 是对称且半正定的，其中一个本征值（$10^{-8}$）极小，模拟了基中的近似线性相关性。\n\n类似地，用于哈密顿量矩阵 $H$ 的正交矩阵 $R$ 是四个旋转的乘积：\n$$R = G_{0,3}(\\theta_4) G_{1,4}(\\theta_3) G_{3,4}(\\theta_2) G_{0,2}(\\theta_1)$$\n角度分别为 $\\theta_1 = -0.4$，$\\theta_2 = 0.65$，$\\theta_3 = -0.25$ 和 $\\theta_4 = 0.15$ 弧度。然后，哈密顿量矩阵 $H$ 定义为：\n$$H = R \\,\\mathrm{diag}(e)\\, R^{\\mathsf{T}}$$\n其中指定的本征值为 $e = [\\,-8.0,\\,-2.0,\\;1.0,\\;3.0,\\;7.0\\,]$，单位为兆电子伏特 (MeV)。这种构造确保 $H$ 是对称的，符合要求。\n\n**2. 正则正交化程序**\n\n当 $S$ 是病态的（即条件数大，源于小本征值）时，直接求解 GEP $H \\mathbf{c} = E S \\mathbf{c}$ 在数值上是不稳定的。正则正交化按以下步骤进行：\n\n首先，对重叠矩阵 $S$ 进行对角化：\n$$S U = U D_s$$\n其中 $U$ 是本征向量 $u_i$ 构成的正交矩阵，$D_s$ 是相应本征值 $s_i$ 构成的对角矩阵。这些本征值是非负的。\n\n其次，引入一个截断阈值 $\\epsilon$ 以丢弃与过小本征值 $s_i$ 相关联的本征模式。根据问题说明，我们保留 $s_i  \\epsilon$ 的模式。设保留的模式数量为 $k$，其中 $k \\le n$。如果 $k=0$，则得到的物理空间为空，无法确定能谱。\n\n第三，我们构造一个维度为 $n \\times k$ 的变换矩阵 $X$。$X$ 的列定义了新的 $k$ 个正交归一基向量在原始 $n$ 个非正交基向量上的系数。该矩阵由 $S$ 的保留本征向量和本征值构造而成：\n$$X = U_{kept} (D_s)_{kept}^{-1/2}$$\n其中 $U_{kept}$ 是一个 $n \\times k$ 矩阵，其列是保留的本征向量，$(D_s)_{kept}^{-1/2}$ 是一个 $k \\times k$ 的对角矩阵，其对角元为保留本征值对应的 $1/\\sqrt{s_i}$。由 $X$ 变换后的基是正交归一的，因为 $X^{\\mathsf{T}}SX = I_k$，其中 $I_k$ 是 $k \\times k$ 的单位矩阵。\n\n最后，将哈密顿量投影到这个新的正交归一子空间上：\n$$\\tilde{H} = X^{\\mathsf{T}} H X$$\n所得矩阵 $\\tilde{H}$ 是一个 $k \\times k$ 的对称矩阵。问题被简化为在稳定子空间中的一个标准本征值问题：\n$$\\tilde{H} \\mathbf{d} = E \\mathbf{d}$$\n$\\tilde{H}$ 的本征值 $E$ 构成了具有物理意义的能谱。\n\n**3. 应用于测试用例**\n\n对每个指定的截断阈值 $\\epsilon \\in \\{\\,10^{-12},\\;10^{-6},\\;10^{-1},\\;6\\times 10^{-1},\\;2.0\\,\\}$ 应用此程序。\n\n- 对于 $\\epsilon = 10^{-12}$：此阈值小于 $S$ 的最小本征值（$10^{-8}$）。因此，所有 $5$ 个 $S$ 的本征模式都被保留（$k=5$），GEP 被转换为一个 $5 \\times 5$ 的 SEP。\n- 对于 $\\epsilon = 10^{-6}$：此阈值大于 $10^{-8}$ 但小于 $S$ 的所有其他本征值。对应于 $10^{-8}$ 本征值的模式被丢弃，得到一个 $4 \\times 4$ 的 SEP（$k=4$）。\n- 对于 $\\epsilon = 10^{-1}$：本征值 $10^{-8}$ 和 $0.05$ 均 $\\le \\epsilon$。因此，丢弃两个模式，得到一个 $3 \\times 3$ 的 SEP（$k=3$）。\n- 对于 $\\epsilon = 6 \\times 10^{-1}$：四个本征值（$10^{-8}, 0.05, 0.2, 0.5$）均 $\\le \\epsilon$。只保留对应于最大本征值（$1.0$）的模式，得到一个 $1 \\times 1$ 的问题（$k=1$），其解为一个单一的能量值。\n- 对于 $\\epsilon = 2.0$：$S$ 的所有本征值都小于此阈值。所有模式都被丢弃（$k=0$），所得能谱为空集。\n\n每种情况下计算出的能量按升序排序并四舍五入到六位小数，以满足要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the generalized eigenvalue problem Hc = ESc using canonical\n    orthonormalization for a set of cutoff thresholds.\n    \"\"\"\n    \n    # Define problem parameters\n    n = 5\n    s_eigvals = [1.0, 0.5, 0.05, 1e-8, 0.2]\n    e_eigvals = [-8.0, -2.0, 1.0, 3.0, 7.0] # in MeV\n    \n    # Angles for rotations in radians\n    alpha, beta, gamma, delta = 0.3, -0.7, 0.5, 0.2\n    theta1, theta2, theta3, theta4 = -0.4, 0.65, -0.25, 0.15\n    \n    # Test suite of cutoff thresholds\n    test_cases = [1e-12, 1e-6, 1e-1, 6e-1, 2.0]\n\n    def givens_rotation(dim, i, j, angle):\n        \"\"\"Constructs a Givens rotation matrix.\"\"\"\n        G = np.identity(dim)\n        c, s = np.cos(angle), np.sin(angle)\n        G[i, i] = c\n        G[j, j] = c\n        G[i, j] = -s\n        G[j, i] = s\n        return G\n\n    # Construct the orthogonal matrix Q for the overlap matrix S\n    G1_Q = givens_rotation(n, 0, 1, alpha)\n    G2_Q = givens_rotation(n, 2, 3, beta)\n    G3_Q = givens_rotation(n, 1, 2, gamma)\n    G4_Q = givens_rotation(n, 0, 4, delta)\n    Q = np.linalg.multi_dot([G4_Q, G3_Q, G2_Q, G1_Q])\n\n    # Construct the overlap matrix S\n    D_s = np.diag(s_eigvals)\n    S = Q @ D_s @ Q.T\n\n    # Construct the orthogonal matrix R for the Hamiltonian H\n    G1_R = givens_rotation(n, 0, 2, theta1)\n    G2_R = givens_rotation(n, 3, 4, theta2)\n    G3_R = givens_rotation(n, 1, 4, theta3)\n    G4_R = givens_rotation(n, 0, 3, theta4)\n    R = np.linalg.multi_dot([G4_R, G3_R, G2_R, G1_R])\n\n    # Construct the Hamiltonian matrix H\n    D_e = np.diag(e_eigvals)\n    H = R @ D_e @ R.T\n\n    all_results = []\n    \n    for epsilon in test_cases:\n        # Step 1: Diagonalize the overlap matrix S\n        # np.linalg.eigh returns eigenvalues in ascending order\n        s_vals, U = np.linalg.eigh(S)\n\n        # Step 2: Filter eigenmodes based on the cutoff threshold epsilon\n        # Keep modes where eigenvalue s > epsilon\n        keep_mask = s_vals > epsilon\n        num_kept = np.sum(keep_mask)\n        \n        if num_kept == 0:\n            all_results.append([])\n            continue\n\n        s_kept = s_vals[keep_mask]\n        U_kept = U[:, keep_mask]\n\n        # Step 3: Construct the transformation matrix X\n        # X = U_kept * (D_s_kept)^(-1/2)\n        X = U_kept / np.sqrt(s_kept)\n\n        # Step 4: Transform the Hamiltonian to the new orthonormal basis\n        H_tilde = X.T @ H @ X\n\n        # Step 5: Solve the standard eigenvalue problem for the transformed Hamiltonian\n        # np.linalg.eigh returns sorted eigenvalues\n        energies = np.linalg.eigh(H_tilde)[0]\n\n        # Round the resulting energies to six decimal places\n        rounded_energies = np.round(energies, 6).tolist()\n        all_results.append(rounded_energies)\n\n    # Format the final output string exactly as required\n    output_parts = []\n    for res_list in all_results:\n        # Format each number to have 6 decimal places.\n        formatted_energies = [f\"{val:.6f}\" for val in res_list]\n        inner_string = f\"[{','.join(formatted_energies)}]\"\n        output_parts.append(inner_string)\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3542310"}]}