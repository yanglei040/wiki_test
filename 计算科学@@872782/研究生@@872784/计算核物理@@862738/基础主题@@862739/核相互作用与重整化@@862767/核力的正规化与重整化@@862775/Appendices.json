{"hands_on_practices": [{"introduction": "这第一个练习是一个基础的起点。它将指导你完成数值求解Lippmann-Schwinger方程的过程，这是两体散射理论中的核心工具。你将学习如何将动量空间积分离散化，以及最关键的，如何对一个简单的接触相互作用实施重整化步骤，以确保你的计算结果具有物理意义。[@problem_id:3586306]", "problem": "要求您设计、实现并测试一种两体 $s$ 波 Lippmann–Schwinger (LS) 方程的动量空间离散化方法，该方法在具有尖锐紫外动量截断 $\\Lambda$ 和正则化接触相互作用的情况下保持重整化。您的程序必须计算一个重整化的低能可观测量，并分析当网格大小 $N$ 以及求积的族和阶数变化时数值收敛性。\n\n出发点是具有尖锐截断 $\\Lambda$ 的动量空间 $s$ 波 LS 方程，用于求解半离壳跃迁矩阵 $T(k',k;E)$：\n$$\nT(k',k;E) = V(k',k) + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq q^{2} V(k',q) G_{0}(E,q) T(q,k;E),\n$$\n其中 $k$ 和 $k'$ 是相对动量，$E$ 是质心能量，$G_{0}(E,q) = (E - q^{2}/(2\\mu) + i0)^{-1}$ 是约化质量为 $\\mu$ 的自由预解式。使用 $\\hbar = 1$ 的单位制，以使能量和动量的量纲保持一致；下面要求的所有输出都是无量纲数（不需要物理单位）。\n\n考虑一个正则化的、可分离的接触相互作用，\n$$\nV(k',k) = C(\\Lambda) g(k') g(k),\\quad g(k) = \\exp(- (k/\\Lambda)^{2}),\n$$\n其中 $C(\\Lambda)$ 是一个通过重整化调整的、依赖于截断的低能常数。由于相互作用是可分离的，LS 方程允许可分离形式的解 $T(k',k;E) = g(k') \\tau(E) g(k)$，其中约化振幅 $\\tau(E)$ 满足\n$$\n\\tau(E) = \\frac{1}{C(\\Lambda)^{-1} - I(E,\\Lambda)},\n\\quad\nI(E,\\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq q^{2} g(q)^{2} G_{0}(E,q).\n$$\n\n在零能量 $E=0$ 时，对于所选的 LS 归一化，施加 $s$ 波在壳跃迁矩阵和散射长度 $a_{0}$ 之间的标准阈值关系，\n$$\nT(0,0;0) = -\\frac{2\\pi}{\\mu} a_{0}.\n$$\n利用可分离拟设 $T(0,0;0) = \\tau(0)$，这就确定了 $\\tau(0)$。然后，重整化条件产生一个跑动耦合 $C(\\Lambda)$，使得低能可观测量 $a_{0}$ 在连续极限下被精确地再现。\n\n您的任务：\n\n1) 从 LS 方程和可分离拟设出发，推导在动量网格 $\\{q_{i}, w_{i}\\}_{i=1}^{N}$ 上 $I(0,\\Lambda)$ 的离散近似。该网格用于将 $\\int_{0}^{\\Lambda} dq f(q)$ 近似为 $\\sum_{i=1}^{N} w_{i} f(q_{i})$。明确证明当 $E=0$ 时，自由预解式简化了被积函数，使得\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq g(q)^{2},\n\\quad\nI_{N}(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i} g(q_{i})^{2}.\n$$\n然后，将离散约化振幅表示为\n$$\n\\tau_{N}(0) = \\frac{1}{C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)}.\n$$\n\n2) 使用阈值关系 $T(0,0;0) = - 2\\pi a_{0}/\\mu$ 和可分离形式，确定阈值处的 $\\tau(0)$，并用它来构建 $C(\\Lambda)$ 的重整化条件，\n$$\n\\frac{1}{\\tau(0)} = C(\\Lambda)^{-1} - I(0,\\Lambda).\n$$\n对于正则化子 $g(k)=\\exp(-(k/\\Lambda)^{2})$，将 $I(0,\\Lambda)$ 作为 $\\mu$ 和 $\\Lambda$ 的函数进行解析计算。使用此解析结果来获得在连续情况下能再现目标 $a_{0}$ 的 $C(\\Lambda)$。然后，必须在离散化方案中使用这个 $C(\\Lambda)$，以测试当 $N$ 和求积方法的选择变化时，离散化是否保持了重整化。\n\n3) 为动量积分 $q\\in[0,\\Lambda]$ 实现两种求积族：\n- 包含端点在内的 $N$ 个点的均匀网格，采用梯形法则（记为 TRAP）。\n- 从 $[-1,1]$ 映射到 $[0,\\Lambda]$ 的 $N$ 阶 Gauss–Legendre (GL) 求积。\n\n对于给定的 $(\\mu, a_{0}, \\Lambda, N, \\text{family})$，计算散射长度的离散估计值，\n$$\n\\hat{a}_{0}^{(N,\\text{family})} = -\\frac{\\mu}{2\\pi} \\tau_{N}(0),\n$$\n以及绝对相对误差 $\\varepsilon = | (\\hat{a}_{0}^{(N,\\text{family})} - a_{0})/a_{0} |$。\n\n4) 设计您的程序，使其生成单行输出，将下面给出的测试套件的结果汇总为一个用方括号括起来的逗号分隔列表。对于所有计算，使用 $\\mu = 1.0$（无量纲）、$\\hbar = 1$（无量纲）和指定的 $g(k)$。所有输出都是不带单位的纯数字。\n\n测试套件：\n- 情况 $1$（理想路径，GL 的精度）：$a_{0} = 5.0$，$\\Lambda = 6.0$，GL 求积，$N = 16$。以浮点数形式输出绝对相对误差 $\\varepsilon$。\n- 情况 $2$（相同参数，TRAP 与 GL 比较）：$a_{0} = 5.0$，$\\Lambda = 6.0$，TRAP 求积，$N = 16$。输出 $\\varepsilon$。\n- 情况 $3$（小截断，适中的 $N$）：$a_{0} = 5.0$，$\\Lambda = 2.0$，GL 求积，$N = 8$。输出 $\\varepsilon$。\n- 情况 $4$（小截断，TRAP）：$a_{0} = 5.0$，$\\Lambda = 2.0$，TRAP 求积，$N = 8$。输出 $\\varepsilon$。\n- 情况 $5$（跨截断的重整化不变性）：$a_{0} = 5.0$，GL 求积，$N = 24$，比较 $\\Lambda_{1} = 3.0$ 和 $\\Lambda_{2} = 9.0$ 处的结果。以浮点数形式输出绝对差 $\\Delta = | \\hat{a}_{0}^{(N,\\text{GL})}(\\Lambda_{1}) - \\hat{a}_{0}^{(N,\\text{GL})}(\\Lambda_{2}) |$。\n- 情况 $6$（边缘情况，大截断，较小的散射长度）：$a_{0} = 0.5$，$\\Lambda = 20.0$，GL 求积，$N = 64$。输出 $\\varepsilon$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4,r5,r6]”），其中每个 $r_{i}$ 是上述相应情况指定的浮点数。不应打印任何其他文本。", "solution": "用户提供的问题是计算核物理领域一个有效且适定的练习，特别关注 Lippmann-Schwinger 方程的数值解和重整化原理。该问题具有科学依据、内部一致，并需要应用量子散射理论和数值分析中的标准、非平凡的技术。我们将着手给出一个完整的、有理有据的解答。\n\n### 1. 阈值处离散 Lippmann-Schwinger 方程的推导\n\n出发点是具有紫外动量截断 $\\Lambda$ 的、用于求解半离壳跃迁矩阵 $T(k',k;E)$ 的 $s$ 波 Lippmann-Schwinger (LS) 方程：\n$$\nT(k',k;E) = V(k',k) + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, V(k',q) \\, G_{0}(E,q) \\, T(q,k;E)\n$$\n势 $V(k',k)$ 是一种形式为 $V(k',k) = C(\\Lambda) g(k') g(k)$ 的正则化、可分离的接触相互作用，其中 $g(k) = \\exp(-(k/\\Lambda)^2)$。这种可分离的势形式意味着 T 矩阵有可分离的解 $T(k',k;E) = g(k') \\tau(E) g(k)$。将 $V$ 和 $T$ 的可分离形式代入 LS 方程，得到：\n$$\ng(k') \\tau(E) g(k) = C(\\Lambda) g(k') g(k) + \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} [C(\\Lambda) g(k') g(q)] G_{0}(E,q) [g(q) \\tau(E) g(k)]\n$$\n我们可以从所有项中消去公因子 $g(k')g(k)$（假设它们不为零），从而得到关于约化振幅 $\\tau(E)$ 的代数方程：\n$$\n\\tau(E) = C(\\Lambda) + C(\\Lambda) \\tau(E) \\left[ \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q) \\right]\n$$\n将圈图积分 $I(E,\\Lambda)$ 定义为\n$$\nI(E,\\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\, G_{0}(E,q),\n$$\n关于 $\\tau(E)$ 的方程变为 $\\tau(E) = C(\\Lambda) + C(\\Lambda) \\tau(E) I(E,\\Lambda)$。求解 $\\tau(E)$：\n$$\n\\tau(E) (1 - C(\\Lambda)I(E,\\Lambda)) = C(\\Lambda) \\implies \\tau(E) = \\frac{C(\\Lambda)}{1 - C(\\Lambda)I(E,\\Lambda)} = \\frac{1}{C(\\Lambda)^{-1} - I(E,\\Lambda)}\n$$\n这就是问题描述中提供的表达式。\n\n对于任务 1，我们必须在零能量 $E=0$ 处计算该式。自由预解式 $G_{0}(E,q) = (E - q^2/(2\\mu) + i0)^{-1}$ 简化为：\n$$\nG_{0}(0,q) = \\left( -\\frac{q^2}{2\\mu} \\right)^{-1} = -\\frac{2\\mu}{q^2}\n$$\n将此式代入 $E=0$ 时的圈图积分 $I(E, \\Lambda)$ 表达式中：\n$$\nI(0,\\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\Lambda} dq\\, q^{2} \\, g(q)^{2} \\left(-\\frac{2\\mu}{q^2}\\right) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, g(q)^{2}\n$$\n这验证了 $I(0,\\Lambda)$ 所需的表达式。\n\n为离散化该积分，我们采用一种由一组动量网格点 $\\{q_i\\}_{i=1}^N$ 和相应权重 $\\{w_i\\}_{i=1}^N$ 定义的数值求积方案。该积分通过加权和来近似：\n$$\n\\int_{0}^{\\Lambda} dq\\, f(q) \\approx \\sum_{i=1}^{N} w_{i} f(q_{i})\n$$\n将此方法应用于我们关于 $I(0,\\Lambda)$ 的表达式，我们得到其离散近似 $I_{N}(0,\\Lambda)$：\n$$\nI_{N}(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i}\\, g(q_{i})^{2}\n$$\n相应的离散约化振幅 $\\tau_N(0)$ 是通过在 $\\tau(E)$ 的公式中用其离散对应项 $I_N(0,\\Lambda)$ 替换连续积分 $I(0,\\Lambda)$ 而得到的：\n$$\n\\tau_{N}(0) = \\frac{1}{C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)}\n$$\n\n### 2. 重整化条件与解析计算\n\n任务 2 要求我们通过施加一个物理条件来确定依赖于截断的耦合常数 $C(\\Lambda)$。我们将该理论锚定于再现一个已知的低能可观测量，即 $s$ 波散射长度 $a_0$。在壳 T 矩阵在零能量时与 $a_0$ 之间的关系如下：\n$$\nT(0,0;0) = -\\frac{2\\pi}{\\mu} a_0\n$$\n使用我们的可分离 T 矩阵拟设 $T(k',k;E) = g(k')\\tau(E)g(k)$，在 $k=k'=E=0$ 时，我们有：\n$$\nT(0,0;0) = g(0) \\tau(0) g(0)\n$$\n对于正则化子 $g(k) = \\exp(-(k/\\Lambda)^2)$，我们有 $g(0)=\\exp(0)=1$。因此，$T(0,0;0) = \\tau(0)$。将两个在壳 T 矩阵的表达式等同起来，可以得到阈值处约化振幅的物理值：\n$$\n\\tau(0) = -\\frac{2\\pi a_0}{\\mu}\n$$\n这作为我们的重整化条件。我们要求我们的连续理论能够精确再现 $\\tau(0)$ 的这个值。通过对 $\\tau(0)$ 的表达式求逆，我们得到关于跑动耦合 $C(\\Lambda)$ 的条件：\n$$\n\\frac{1}{\\tau(0)} = C(\\Lambda)^{-1} - I(0,\\Lambda) \\implies C(\\Lambda)^{-1} = \\frac{1}{\\tau(0)} + I(0,\\Lambda)\n$$\n代入 $\\tau(0) = -2\\pi a_0/\\mu$，我们得到：\n$$\nC(\\Lambda)^{-1} = -\\frac{\\mu}{2\\pi a_0} + I(0,\\Lambda)\n$$\n为了获得 $C(\\Lambda)$ 的完全解析表达式，我们必须对特定的正则化子 $g(q)^2 = \\exp(-2(q/\\Lambda)^2)$ 计算积分 $I(0,\\Lambda)$：\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\Lambda} dq\\, e^{-2(q/\\Lambda)^2}\n$$\n我们进行变量替换。令 $u = \\sqrt{2} q/\\Lambda$，这意味着 $dq = (\\Lambda/\\sqrt{2}) du$。积分限从 $[0, \\Lambda]$ 变为 $[0, \\sqrt{2}]$。\n$$\nI(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\int_{0}^{\\sqrt{2}} e^{-u^2} \\frac{\\Lambda}{\\sqrt{2}} du = -\\frac{4\\mu\\Lambda}{\\pi\\sqrt{2}} \\int_{0}^{\\sqrt{2}} e^{-u^2} du\n$$\n该积分与误差函数 $\\mathrm{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt$ 有关，因此 $\\int_0^x e^{-t^2} dt = \\frac{\\sqrt{\\pi}}{2}\\mathrm{erf}(x)$。\n$$\nI(0,\\Lambda) = -\\frac{4\\mu\\Lambda}{\\pi\\sqrt{2}} \\left( \\frac{\\sqrt{\\pi}}{2} \\mathrm{erf}(\\sqrt{2}) \\right) = -\\frac{2\\mu\\Lambda}{\\sqrt{2\\pi}} \\mathrm{erf}(\\sqrt{2}) = -\\mu\\Lambda\\sqrt{\\frac{2}{\\pi}} \\mathrm{erf}(\\sqrt{2})\n$$\n最后，将此解析结果代回 $C(\\Lambda)^{-1}$ 的表达式中：\n$$\nC(\\Lambda)^{-1} = -\\frac{\\mu}{2\\pi a_0} - \\mu\\Lambda\\sqrt{\\frac{2}{\\pi}} \\mathrm{erf}(\\sqrt{2})\n$$\n该表达式定义了在任何截断 $\\Lambda$ 下，为在连续理论中精确再现散射长度 $a_0$ 所需的耦合 $C(\\Lambda)$ 的值。在我们的离散计算中必须使用这个耦合，以测试离散化是否保持了这一性质。\n\n### 3. 数值实现与求积方案\n\n目标是计算散射长度的数值估计值 $\\hat{a}_{0}^{(N,\\text{family})}$，并将其与目标值 $a_0$ 进行比较。估计的散射长度从离散约化振幅 $\\tau_N(0)$ 获得：\n$$\n\\hat{a}_{0}^{(N,\\text{family})} = -\\frac{\\mu}{2\\pi} \\tau_{N}(0) = -\\frac{\\mu}{2\\pi} \\left( \\frac{1}{C(\\Lambda)^{-1} - I_{N}(0,\\Lambda)} \\right)\n$$\n数值任务的核心是为两种不同的求积族计算离散圈图积分 $I_{N}(0, \\Lambda)$。\n\n- **均匀网格上的梯形法则 (TRAP)：**\n对于包含端点 $0$ 和 $\\Lambda$ 在内的 $N$ 个点的网格，步长为 $h = \\Lambda/(N-1)$。网格点为 $q_i = (i-1)h$，其中 $i=1, ..., N$。梯形法则将积分近似为权重为 $w_1 = h/2$、$w_N = h/2$ 且当 $i=2, ..., N-1$ 时 $w_i = h$ 的和。\n\n- **Gauss–Legendre (GL) 求积：**\n该方法通常在区间 $[-1, 1]$ 上定义。我们使用一个线性变换将标准 GL 节点 $x_i \\in [-1, 1]$ 和权重 $w_i^{\\text{GL}}$ 映射到动量区间 $q \\in [0, \\Lambda]$。\n该变换为 $q(x) = \\frac{\\Lambda}{2}(x+1)$，其微分为 $dq = \\frac{\\Lambda}{2}dx$。积分变为：\n$$\n\\int_0^\\Lambda f(q) dq = \\int_{-1}^1 f\\left( \\frac{\\Lambda}{2}(x+1) \\right) \\frac{\\Lambda}{2} dx \\approx \\sum_{i=1}^N \\frac{\\Lambda}{2} w_i^{\\text{GL}} f\\left( \\frac{\\Lambda}{2}(x_i+1) \\right)\n$$\n因此，我们动量网格的求积点和权重为：\n$$\nq_i = \\frac{\\Lambda}{2}(x_i+1), \\quad w_i = \\frac{\\Lambda}{2}w_i^{\\text{GL}}\n$$\n\n每个测试用例的总体算法如下：\n1.  给定参数 $(\\mu, a_{0}, \\Lambda, N, \\text{family})$，首先使用第 2 节中推导的公式计算逆耦合 $C(\\Lambda)^{-1}$ 的解析值。\n2.  为指定的族（TRAP 或 GL）、大小 $N$ 和范围 $[0, \\Lambda]$ 生成求积点集 $\\{q_i\\}$ 和权重集 $\\{w_i\\}$。\n3.  在网格上计算正则化子函数值 $g(q_i)^2 = \\exp(-2(q_i/\\Lambda)^2)$。\n4.  计算离散圈图积分 $I_{N}(0,\\Lambda) = -\\frac{4\\mu}{\\pi} \\sum_{i=1}^{N} w_{i} g(q_i)^2$。\n5.  计算离散约化振幅 $\\tau_N(0) = (C(\\Lambda)^{-1} - I_{N}(0,\\Lambda))^{-1}$。\n6.  计算估计的散射长度 $\\hat{a}_{0} = -\\mu/(2\\pi) \\tau_N(0)$。\n7.  最后，计算指定的输出度量：绝对相对误差 $\\varepsilon = \\lvert (\\hat{a}_{0} - a_{0})/a_{0} \\rvert$ 或两次计算之间的绝对差 $\\Delta$。\n\n此过程测试给定的离散化方案（求积法则和网格大小）在多大程度上近似了连续极限，在连续极限下 $\\hat{a}_0$ 将完全等于 $a_0$。误差 $\\varepsilon$ 量化了数值近似的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    Designs, implements, and tests a momentum-space discretization of the\n    two-body s-wave Lippmann–Schwinger equation.\n    \"\"\"\n\n    # --- Problem constants ---\n    MU = 1.0  # Reduced mass (dimensionless)\n\n    def get_quadrature(Lambda, N, family):\n        \"\"\"\n        Generates quadrature points and weights for the integral from 0 to Lambda.\n\n        Args:\n            Lambda (float): The momentum cutoff.\n            N (int): The number of quadrature points.\n            family (str): The quadrature family ('GL' for Gauss-Legendre, 'TRAP' for Trapezoidal).\n\n        Returns:\n            tuple: A tuple containing:\n                - q (np.ndarray): The momentum grid points.\n                - w (np.ndarray): The corresponding quadrature weights.\n        \"\"\"\n        if family == 'GL':\n            # Gauss-Legendre quadrature mapped from [-1, 1] to [0, Lambda]\n            x_gl, w_gl = np.polynomial.legendre.leggauss(N)\n            q = 0.5 * Lambda * (x_gl + 1.0)\n            w = 0.5 * Lambda * w_gl\n        elif family == 'TRAP':\n            # Trapezoidal rule on a uniform grid\n            if N  2:\n                # Handle edge case of N  2 for trapezoidal rule\n                if N == 1:\n                    return np.array([0.0]), np.array([Lambda])\n                else: # N=0\n                    return np.array([]), np.array([])\n            q = np.linspace(0.0, Lambda, N)\n            h = Lambda / (N - 1.0)\n            w = np.full(N, h)\n            w[0] = h / 2.0\n            w[-1] = h / 2.0\n        else:\n            raise ValueError(f\"Unknown quadrature family: {family}\")\n        return q, w\n\n    def compute_scattering_length(a0, Lambda, N, family):\n        \"\"\"\n        Computes the discrete estimate of the scattering length.\n\n        Args:\n            a0 (float): The target scattering length for renormalization.\n            Lambda (float): The momentum cutoff.\n            N (int): The number of quadrature points.\n            family (str): The quadrature family ('GL' or 'TRAP').\n\n        Returns:\n            float: The computed estimate of the scattering length, a0_hat.\n        \"\"\"\n        # Regulator function g(k)^2\n        g2 = lambda k: np.exp(-2.0 * (k / Lambda)**2)\n\n        # 1. Analytically determine the inverse coupling C(Lambda)^-1\n        # This is the renormalization condition.\n        # I(0, Lambda) = - (4*mu/pi) * integral(g(q)^2 dq, 0, Lambda)\n        # integral = (Lambda * sqrt(pi)) / (2*sqrt(2)) * erf(sqrt(2))\n        I_continuum = -MU * Lambda * np.sqrt(2.0 / np.pi) * erf(np.sqrt(2.0))\n        \n        # C(Lambda)^-1 = 1/tau(0) + I(0, Lambda), with tau(0) = -2*pi*a0/mu\n        C_inv = -MU / (2.0 * np.pi * a0) + I_continuum\n\n        # 2. Generate quadrature points and weights\n        q, w = get_quadrature(Lambda, N, family)\n\n        # 3. Compute the discrete loop integral I_N(0, Lambda)\n        integrand_vals = g2(q)\n        I_discrete = - (4.0 * MU / np.pi) * np.sum(w * integrand_vals)\n\n        # 4. Compute the discrete reduced amplitude tau_N(0)\n        tau_N_0 = 1.0 / (C_inv - I_discrete)\n\n        # 5. Compute the estimated scattering length a0_hat\n        a0_hat = -MU / (2.0 * np.pi) * tau_N_0\n        \n        return a0_hat\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1: a0=5.0, Lambda=6.0, GL, N=16. Output epsilon.\n        {'a0': 5.0, 'Lambda': 6.0, 'N': 16, 'family': 'GL', 'type': 'error'},\n        # Case 2: a0=5.0, Lambda=6.0, TRAP, N=16. Output epsilon.\n        {'a0': 5.0, 'Lambda': 6.0, 'N': 16, 'family': 'TRAP', 'type': 'error'},\n        # Case 3: a0=5.0, Lambda=2.0, GL, N=8. Output epsilon.\n        {'a0': 5.0, 'Lambda': 2.0, 'N': 8, 'family': 'GL', 'type': 'error'},\n        # Case 4: a0=5.0, Lambda=2.0, TRAP, N=8. Output epsilon.\n        {'a0': 5.0, 'Lambda': 2.0, 'N': 8, 'family': 'TRAP', 'type': 'error'},\n        # Case 5: a0=5.0, GL, N=24. Compare Lambda1=3.0 and Lambda2=9.0. Output abs diff.\n        {'a0': 5.0, 'N': 24, 'family': 'GL', 'Lambda1': 3.0, 'Lambda2': 9.0, 'type': 'diff'},\n        # Case 6: a0=0.5, Lambda=20.0, GL, N=64. Output epsilon.\n        {'a0': 0.5, 'Lambda': 20.0, 'N': 64, 'family': 'GL', 'type': 'error'},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'error':\n            a0 = case['a0']\n            a0_hat = compute_scattering_length(\n                a0=a0,\n                Lambda=case['Lambda'],\n                N=case['N'],\n                family=case['family']\n            )\n            error = np.abs((a0_hat - a0) / a0)\n            results.append(error)\n        \n        elif case['type'] == 'diff':\n            a0_hat1 = compute_scattering_length(\n                a0=case['a0'],\n                Lambda=case['Lambda1'],\n                N=case['N'],\n                family=case['family']\n            )\n            a0_hat2 = compute_scattering_length(\n                a0=case['a0'],\n                Lambda=case['Lambda2'],\n                N=case['N'],\n                family=case['family']\n            )\n            diff = np.abs(a0_hat1 - a0_hat2)\n            results.append(diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3586306"}, {"introduction": "掌握了零能量下的基础知识后，我们现在来处理有限能量下的散射问题。这引入了一个新的挑战：自由传播子中的在壳奇异性，它需要特定的数值处理方法，并会导致复数值的解。本练习侧重于实现这一方法，并比较不同形式的调节函数——我们框架中的一个关键工具——如何影响Lippmann-Schwinger方程的解。[@problem_id:3586326]", "problem": "考虑在自然单位制下的分波、无自旋、非相对论性双体散射问题。在该单位制中，普朗克常数 ($\\hbar$) 等于 $1$，约化质量 ($\\mu$) 等于 $1/2$。因此，自由格林函数的分母为 $k^2 - q^2 + i\\varepsilon$，其中 $k$ 是在壳动量，$q$ 是圈动量，$\\varepsilon$ 是一个正无穷小量。在S波情况下，Lippmann–Schwinger (LS) 方程通过以下积分方程将T矩阵 $T(p,p';E)$ 与相互作用核 $V(p,p')$ 联系起来：\n$$\nT(p,p';E) = V(p,p') + \\frac{2}{\\pi} \\int_{0}^{\\infty} dq \\; q^2 \\; V(p,q) \\; \\frac{1}{k^2 - q^2 + i\\varepsilon} \\; T(q,p';E),\n$$\n其中由于选择 $\\mu = 1/2$，能量 $E = k^2$。考虑一个形式如下的正则化的、秩一可分离的相互作用：\n$$\nV(p,p') = C_0 f\\left(\\frac{p}{\\Lambda}\\right) f\\left(\\frac{p'}{\\Lambda}\\right),\n$$\n其中 $C_0$ 是一个耦合常数，$\\Lambda$ 是一个动量标度，$f(x)$ 是一个无量纲调节子。对于本问题，请使用以下调节子选择：\n- 平滑高斯调节子：$f(x) = \\exp(-x^2)$。\n- 锐截止调节子：$f(x) = \\theta(1 - x)$，其中 $\\theta$ 是赫维赛德阶跃函数。\n\n你将使用标准出射波规定来处理 $q = k$ 处的实轴奇点，即在分母中加入一个小的虚部 $i\\varepsilon$；取 $\\varepsilon = 10^{-6}$。本问题中的所有量都是无量纲的。你应该完全使用无量纲数进行计算，并且不要报告任何物理单位。\n\n仅从上述积分方程和给定的 $V$ 的可分离形式出发，推导一个计算方法，通过使用数值积分来近似该积分，以评估在壳 $T$ 矩阵\n$$\nT_{\\text{on}}(k) \\equiv T(k,k;E=k^2),\n$$\n对于给定的调节子 $f$、耦合常数 $C_0$ 和截止标度 $\\Lambda$。将数值积分解释为一种隐式正则化过程，因为其有限的分辨率和有限的区间会有效地改变积分的紫外和红外行为。你的程序必须实现以下求积法则来近似动量空间积分：\n- 高斯-勒让德 (GL) 求积，作用于有限区间。\n- 均匀中点法则（使用中点的矩形法则）。\n- 复合辛普森法则。\n\n对于锐截止调节子，积分范围是 $q \\in [0,\\Lambda]$。对于高斯调节子，积分范围是 $q \\in [0,Q_{\\max}]$，其中 $Q_{\\max} = L_{\\text{cut}} \\Lambda$ 且 $L_{\\text{cut}} = 8$。在所有情况下，你都必须包含因子 $2/\\pi$ 和来自S波相空间测度的权重 $q^2$。在所有数值计算中，分母都使用相同的 $\\varepsilon = 10^{-6}$。对于复合辛普森法则，子区间的数量必须是偶数。\n\n由于势是秩一可分离的，你可以将该积分方程简化为一个关于能量的单一函数的标量方程，并据此评估 $T_{\\text{on}}(k)$，但除了从可分离性和LS结构直接导出的结论外，你不能假设任何进一步的“快捷”公式。在壳量 $T_{\\text{on}}(k)$ 通常是复数，这是由 $i\\varepsilon$ 规定所致。为量化离散化引起的赝象，你必须为每个测试案例计算一个高精度参考值 $T_{\\text{ref}}(k)$。对于锐截止，通过在 $[0,\\Lambda]$ 上使用高精度自适应方法对同一积分进行数值评估；对于高斯调节子，则在 $[0,Q_{\\max}^{\\text{ref}}]$ 上进行评估，其中 $Q_{\\max}^{\\text{ref}} = L_{\\text{ref}} \\Lambda$ 且 $L_{\\text{ref}} = 40$。计算绝对相对误差\n$$\n\\delta \\equiv \\frac{\\left|T_{\\text{on}}(k) - T_{\\text{ref}}(k)\\right|}{\\left|T_{\\text{ref}}(k)\\right|}.\n$$\n\n实现三种求积法则，并对以下参数集测试套件评估 $\\delta$，每个测试由一个元组 $(\\text{reg}, \\text{quad}, N, \\Lambda, k, C_0, \\varepsilon)$ 指定：\n- 测试 $1$: $(\\text{gauss}, \\text{gl}, 16, 2.0, 1.0, -1.0, 10^{-6})$。\n- 测试 $2$: $(\\text{gauss}, \\text{mid}, 16, 2.0, 1.0, -1.0, 10^{-6})$。\n- 测试 $3$: $(\\text{gauss}, \\text{simpson}, 32, 2.0, 1.0, -1.0, 10^{-6})$。\n- 测试 $4$: $(\\text{sharp}, \\text{gl}, 16, 2.0, 1.0, -1.0, 10^{-6})$。\n- 测试 $5$: $(\\text{sharp}, \\text{mid}, 16, 2.0, 1.0, -1.0, 10^{-6})$。\n- 测试 $6$: $(\\text{sharp}, \\text{simpson}, 32, 2.0, 1.0, -1.0, 10^{-6})$。\n- 测试 $7$: $(\\text{sharp}, \\text{gl}, 64, 2.0, 1.9, -1.0, 10^{-6})$。\n- 测试 $8$: $(\\text{sharp}, \\text{mid}, 64, 2.0, 1.9, -1.0, 10^{-6})$。\n\n对于高斯调节子测试，求积评估时设置 $Q_{\\max} = L_{\\text{cut}} \\Lambda$ 且 $L_{\\text{cut}} = 8$，参考值评估时设置 $Q_{\\max}^{\\text{ref}} = L_{\\text{ref}} \\Lambda$ 且 $L_{\\text{ref}} = 40$。对于锐截止测试，求积评估和参考值评估都始终使用 $[0,\\Lambda]$。\n\n你的程序必须生成单行输出，其中包含对应于测试1到8的八个 $\\delta$ 值，格式为一个用方括号括起来的逗号分隔列表，每个数字使用科学记数法表示，并保留八位有效数字，例如 `[1.23456789e-04,...]`。不使用角度。由于所有量在构造上都是无量纲的，因此不出现物理单位。最终输出必须严格匹配此单行格式。", "solution": "该问题要求对一个由Lippmann-Schwinger (LS) 方程描述的非相对论性双体散射问题，数值计算其在壳 $T$ 矩阵 $T_{\\text{on}}(k)$。解决方案主要分两个阶段进行：首先，利用给定的可分离势对LS方程进行解析简化；其次，使用指定的求积法则对得到的积分表达式进行数值评估。\n\n出发点是动量空间中的S波Lippmann-Schwinger方程：\n$$\nT(p,p';E) = V(p,p') + \\frac{2}{\\pi} \\int_{0}^{\\infty} dq \\; q^2 \\; V(p,q) \\; \\frac{1}{k^2 - q^2 + i\\varepsilon} \\; T(q,p';E)\n$$\n其中由于选择了约化质量 $\\mu=1/2$ 和 $\\hbar=1$，能量为 $E=k^2$。相互作用势 $V(p,p')$ 是一个秩一可分离形式：\n$$\nV(p,p') = C_0 f\\left(\\frac{p}{\\Lambda}\\right) f\\left(\\frac{p'}{\\Lambda}\\right)\n$$\n在这里，$C_0$ 是耦合强度，$\\Lambda$ 是动量截止标度，$f(x)$ 是一个无量纲调节子函数。\n\n势的可分离性质意味着 $T$ 矩阵在其动量宗量上也是可分离的。因此，我们可以做出以下假设：\n$$\nT(p,p';E) = \\tau(E) f\\left(\\frac{p}{\\Lambda}\\right) f\\left(\\frac{p'}{\\Lambda}\\right)\n$$\n其中 $\\tau(E)$ 是一个仅与能量有关的函数，它包含了非平凡的散射动力学。\n\n将 $V(p,p')$ 和 $T(p,p';E)$ 的表达式代入LS方程，得到：\n$$\n\\tau(E) f\\left(\\frac{p}{\\Lambda}\\right) f\\left(\\frac{p'}{\\Lambda}\\right) = C_0 f\\left(\\frac{p}{\\Lambda}\\right) f\\left(\\frac{p'}{\\Lambda}\\right) + \\frac{2}{\\pi} \\int_{0}^{\\infty} dq \\, q^2 \\left[C_0 f\\left(\\frac{p}{\\Lambda}\\right) f\\left(\\frac{q}{\\Lambda}\\right)\\right] \\frac{1}{k^2 - q^2 + i\\varepsilon} \\left[\\tau(E) f\\left(\\frac{q}{\\Lambda}\\right) f\\left(\\frac{p'}{\\Lambda}\\right)\\right]\n$$\n项 $f(p/\\Lambda)$ 和 $f(p'/\\Lambda)$ 与积分变量 $q$ 无关，可以从积分中提出。这使我们能够将整个方程除以 $f(p/\\Lambda)f(p'/\\Lambda)$（假设它们非零），从而得到一个关于 $\\tau(E)$ 的标量代数方程：\n$$\n\\tau(E) = C_0 + C_0 \\tau(E) \\left[ \\frac{2}{\\pi} \\int_{0}^{\\infty} dq \\; q^2 \\; \\frac{\\left[f(q/\\Lambda)\\right]^2}{k^2 - q^2 + i\\varepsilon} \\right]\n$$\n让我们定义圈积分 $I(k, \\Lambda)$:\n$$\nI(k, \\Lambda) = \\frac{2}{\\pi} \\int_{0}^{\\infty} dq \\; q^2 \\; \\frac{\\left[f(q/\\Lambda)\\right]^2}{k^2 - q^2 + i\\varepsilon}\n$$\n关于 $\\tau(E)$ 的方程变为：\n$$\n\\tau(E) = C_0 + C_0 \\tau(E) I(k, \\Lambda)\n$$\n在 $E=k^2$ 的条件下求解 $\\tau(E)$:\n$$\n\\tau(E)(1 - C_0 I(k, \\Lambda)) = C_0 \\quad \\implies \\quad \\tau(E=k^2) = \\frac{C_0}{1 - C_0 I(k, \\Lambda)}\n$$\n问题要求计算在壳 $T$ 矩阵，$T_{\\text{on}}(k) \\equiv T(k,k;E=k^2)$。使用我们的假设：\n$$\nT_{\\text{on}}(k) = \\tau(E=k^2) \\left[f(k/\\Lambda)\\right]^2\n$$\n代入 $\\tau(E=k^2)$ 的表达式，我们得到 $T_{\\text{on}}(k)$ 的最终解析表达式：\n$$\nT_{\\text{on}}(k) = \\frac{C_0 [f(k/\\Lambda)]^2}{1 - C_0 I(k, \\Lambda)}\n$$\n计算任务的核心是评估复值积分 $I(k, \\Lambda)$。积分范围由调节子函数 $f(x)$ 决定。\n- 对于锐截止 $f(x) = \\theta(1-x)$，调节子 $[f(q/\\Lambda)]^2$ 在 $q \\le \\Lambda$ 时为 $1$，否则为 $0$。有效积分范围是 $[0, \\Lambda]$。\n- 对于高斯调节子 $f(x) = \\exp(-x^2)$，被积函数迅速衰减。问题指定了一个有限积分区间 $[0, Q_{\\max}]$，其中 $Q_{\\max} = L_{\\text{cut}}\\Lambda = 8\\Lambda$。\n\n$I(k, \\Lambda)$ 的被积函数是实变量 $q$ 的一个复函数：\n$$\ng(q; k, \\Lambda, \\varepsilon) = \\frac{2}{\\pi} q^2 \\frac{[f(q/\\Lambda)]^2}{k^2 - q^2 + i\\varepsilon}\n$$\n该积分将使用三种数值求积法则进行近似：高斯-勒让德 (GL)、均匀中点和复合辛普森。得到的值 $I_{\\text{quad}}(k, \\Lambda)$ 用于计算近似的在壳T矩阵 $T_{\\text{on}}(k)$。\n\n参考值 $T_{\\text{ref}}(k)$ 使用与 $T_{\\text{on}}(k)$ 相同的公式计算，但其中的积分 $I(k, \\Lambda)$ 是使用自适应求积方法高精度评估的。为此，我们使用 `scipy.integrate.quad`。参考值计算的积分区间，对于锐截止是 $[0, \\Lambda]$，对于高斯调节子是 $[0, Q_{\\max}^{\\text{ref}}]$，其中 $Q_{\\max}^{\\text{ref}} = L_{\\text{ref}}\\Lambda = 40\\Lambda$。高斯情况下使用更大的区间是为了更准确地捕捉函数的尾部。\n\n数值实现将把被积函数 $g(q)$ 定义为一个复值函数，并应用指定的求积法则来计算积分 $I(k, \\Lambda)$。\n- **高斯-勒让德求积**：在 $[a, b]$ 上的积分近似为 $\\int_a^b g(q) dq \\approx \\frac{b-a}{2} \\sum_{i=1}^N w_i g(\\frac{b-a}{2}x_i + \\frac{a+b}{2})$，其中 $x_i$ 和 $w_i$ 分别是 $[-1, 1]$ 上 $N$ 点勒让德多项式的横坐标和权重。\n- **均匀中点法则**：在 $[a,b]$ 上的积分通过将区间分成 $N$ 个宽度为 $h=(b-a)/N$ 的子区间，并对中点处的函数值求和来近似：$\\int_a^b g(q) dq \\approx h \\sum_{i=0}^{N-1} g(a + (i+0.5)h)$。\n- **复合辛普森法则**：在 $[a,b]$ 上的积分通过将区间分成偶数个 $N$ 的子区间（宽度 $h=(b-a)/N$）来近似。节点为 $q_j = a + j h$，公式为 $\\int_a^b g(q) dq \\approx \\frac{h}{3} [g(q_0) + 4\\sum_{j=1, \\text{odd}}^{N-1} g(q_j) + 2\\sum_{j=2, \\text{even}}^{N-2} g(q_j) + g(q_N)]$。这是使用 `scipy.integrate.simpson` 实现的。\n\n最后，为每个测试案例计算绝对相对误差 $\\delta$：\n$$\n\\delta = \\frac{|T_{\\text{on}}(k) - T_{\\text{ref}}(k)|}{|T_{\\text{ref}}(k)|}\n$$\n这个误差度量量化了定点求积法则的结果与高精度自适应参考值之间的差异，突显了所选数值方法中的离散化赝象。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\nfrom scipy.special import lpmv\n\n# Note: scipy.special.lpmv is not used, but np.polynomial.legendre.leggauss is.\n# The `leggauss` function is part of the numpy.polynomial module.\n\ndef solve():\n    \"\"\"\n    Solves the Lippmann-Schwinger equation for a separable potential\n    and calculates the relative error of different quadrature methods.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (reg_type, quad_type, N, Lambda, k, C0, eps)\n        ('gauss', 'gl', 16, 2.0, 1.0, -1.0, 1e-6),\n        ('gauss', 'mid', 16, 2.0, 1.0, -1.0, 1e-6),\n        ('gauss', 'simpson', 32, 2.0, 1.0, -1.0, 1e-6),\n        ('sharp', 'gl', 16, 2.0, 1.0, -1.0, 1e-6),\n        ('sharp', 'mid', 16, 2.0, 1.0, -1.0, 1e-6),\n        ('sharp', 'simpson', 32, 2.0, 1.0, -1.0, 1e-6),\n        ('sharp', 'gl', 64, 2.0, 1.9, -1.0, 1e-6),\n        ('sharp', 'mid', 64, 2.0, 1.9, -1.0, 1e-6),\n    ]\n\n    L_cut = 8.0\n    L_ref = 40.0\n\n    # ----- Regulator Functions -----\n    def regulator_gauss(p, Lambda):\n        return np.exp(-(p/Lambda)**2)\n\n    def regulator_sharp(p, Lambda):\n        # Using np.where for vectorization compatibility\n        return np.where(p = Lambda, 1.0, 0.0)\n    \n    reg_funcs = {'gauss': regulator_gauss, 'sharp': regulator_sharp}\n\n    # ----- Loop Integral Calculation -----\n    def get_integrand(k, Lambda, eps, reg_func):\n        \"\"\"Returns the function g(q) for the loop integral I(k, Lambda).\"\"\"\n        k_sq = k**2\n        prefactor = 2.0 / np.pi\n        \n        def integrand(q):\n            regulator_val = reg_func(q, Lambda)\n            # Use complex numbers directly for the denominator\n            propagator = 1.0 / (k_sq - q**2 + 1j * eps)\n            return prefactor * q**2 * regulator_val**2 * propagator\n            \n        return integrand\n\n    # ----- Quadrature Methods -----\n    def quad_gl(func, a, b, N):\n        \"\"\"Gauss-Legendre quadrature on interval [a, b] with N points.\"\"\"\n        x, w = np.polynomial.legendre.leggauss(N)\n        # Transform points from [-1, 1] to [a, b]\n        q_points = 0.5 * (b - a) * x + 0.5 * (b + a)\n        f_vals = func(q_points)\n        integral = 0.5 * (b - a) * np.sum(w * f_vals)\n        return integral\n\n    def quad_mid(func, a, b, N):\n        \"\"\"Uniform midpoint rule on [a, b] with N intervals.\"\"\"\n        h = (b - a) / N\n        q_points = a + (np.arange(N) + 0.5) * h\n        f_vals = func(q_points)\n        integral = h * np.sum(f_vals)\n        return integral\n\n    def quad_simpson(func, a, b, N):\n        \"\"\"Composite Simpson rule on [a, b] with N intervals.\"\"\"\n        # N must be even. N+1 points must be odd.\n        if N % 2 != 0:\n            raise ValueError(\"Number of intervals N for Simpson's rule must be even.\")\n        q_points = np.linspace(a, b, N + 1)\n        f_vals = func(q_points)\n        return integrate.simpson(f_vals, q_points)\n        \n    quad_methods = {'gl': quad_gl, 'mid': quad_mid, 'simpson': quad_simpson}\n\n    # ----- T-matrix Calculation -----\n    def compute_T_on(k, Lambda, C0, reg_func, I_val):\n        \"\"\"Computes on-shell T-matrix given the loop integral value.\"\"\"\n        reg_on_shell_sq = reg_func(k, Lambda)**2\n        numerator = C0 * reg_on_shell_sq\n        denominator = 1.0 - C0 * I_val\n        return numerator / denominator\n\n    results = []\n    for case in test_cases:\n        reg_type, quad_type, N, Lambda, k, C0, eps = case\n        \n        reg_func = reg_funcs[reg_type]\n        quad_func = quad_methods[quad_type]\n        \n        # Define integration limits for quadrature and reference\n        if reg_type == 'gauss':\n            q_upper_quad = L_cut * Lambda\n            q_upper_ref = L_ref * Lambda\n        else: # 'sharp'\n            q_upper_quad = Lambda\n            q_upper_ref = Lambda\n\n        # Create the specific integrand for this test case\n        integrand_func = get_integrand(k, Lambda, eps, reg_func)\n\n        # 1. Calculate the high-accuracy reference integral I_ref and T_ref\n        I_ref_real, _ = integrate.quad(lambda q: integrand_func(q).real, 0, q_upper_ref, limit=200, epsabs=1e-12, epsrel=1e-12)\n        I_ref_imag, _ = integrate.quad(lambda q: integrand_func(q).imag, 0, q_upper_ref, limit=200, epsabs=1e-12, epsrel=1e-12)\n        I_ref = I_ref_real + 1j * I_ref_imag\n        T_ref = compute_T_on(k, Lambda, C0, reg_func, I_ref)\n\n        # 2. Calculate the approximate integral I_quad and T_on\n        I_quad = quad_func(integrand_func, 0, q_upper_quad, N)\n        T_on = compute_T_on(k, Lambda, C0, reg_func, I_quad)\n        \n        # 3. Compute relative error\n        if np.abs(T_ref) == 0:\n            # Handle the unlikely case of a zero reference value\n            delta = np.abs(T_on - T_ref)\n        else:\n            delta = np.abs(T_on - T_ref) / np.abs(T_ref)\n        \n        results.append(delta)\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.8e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3586326"}, {"introduction": "这个综合性练习处理一个更真实的情景，涉及一种奇异相互作用，类似于核物理中由张量力产生的情况。在这种情况下，微扰论是不够的，需要一个完全非微扰的重整化方法。你将实现一个有效场论理论学家的完整工作流程：利用一个实验数据点来拟合一个抵消项以吸收截断依赖性，然后使用这个重整化后的相互作用对另一个可观测量做出可验证的预测。[@problem_id:3586377]", "problem": "您需要通过将非耦合的三重态$P$波 $^{3}P_{0}$ 建模为一个吸引性长程张量诱导相互作用外加一个领头阶抵消项，来研究奇异张量通道中的非微扰重整化。采用自然单位制，其中 $\\hbar = 1$ 且 $2\\mu = 1$，因此两体质心能量为 $E = k^2$，所有量均为无量纲。完全在动量空间和单个分波中进行计算。\n\n基本基础和模型：\n- 从单个通道中分波反应（K-）矩阵的 Lippmann–Schwinger 方程出发，\n$$\nK(p,p';E) = V(p,p') + \\frac{2}{\\pi}\\mathcal{P}\\int_{0}^{\\infty} dq \\frac{q^2 V(p,q) K(q,p';E)}{E - q^2},\n$$\n其中 $\\mathcal{P}$ 表示柯西主值。\n- 将 $^{3}P_{0}$ 通道的正则化领头阶势建模为一个代表张量力的长程可分离项和一个领头阶$P$波抵消项之和，\n$$\nV(p,p';\\Lambda) = R_{\\Lambda}(p) R_{\\Lambda}(p')\\left[-g \\frac{p}{p^2+\\beta^2} \\frac{p'}{{p'}^2+\\beta^2} + C(\\Lambda) p p' \\right],\n$$\n其中高斯型正则化因子为\n$$\nR_{\\Lambda}(p) = \\exp\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{4}\\right].\n$$\n此处 $g  0$ 是长程部分的固定耦合常数，$\\beta  0$ 设定了一个有限力程标度，而 $C(\\Lambda)$ 是一个跑动抵消项，需要在每个截断 $\\Lambda$ 下进行拟合。\n\n可观测量与重整化方案：\n- 定义$P$波中的在壳反应矩阵元为 $K_1(k;\\Lambda) \\equiv K(k,k;E=k^2)$。您将通过以下非微扰重整化方案来评估正则化因子无关性：\n  1. 对于给定的 $\\Lambda$，通过对数据点进行重新拟合来确定 $C(\\Lambda)$\n     $$\n     K_1(k_{\\mathrm{ref}};\\Lambda) = K_{\\mathrm{ref}},\n     $$\n     该拟合在下述的参考动量 $k_{\\mathrm{ref}}$ 和目标值 $K_{\\mathrm{ref}}$ 处进行。\n  2. 在拟合的 $C(\\Lambda)$ 固定的情况下，预测在测试动量 $k_{\\mathrm{test}}$ 处的 $K_1(k_{\\mathrm{test}};\\Lambda)$。\n  3. 比较当 $\\Lambda$ 变化时 $K_1(k_{\\mathrm{test}};\\Lambda)$ 的预测值。重新拟合后的正则化因子无关性对应于这些值在 $\\Lambda$ 增大时趋向于一个共同的极限。\n\n计算要求：\n- 通过在 $q = k$ 处分割积分域，并排除极点周围的一个无穷小邻域，来数值处理主值积分。将积分上限截断为一个有限的 $Q_{\\max}$，该值须由正则化因子证明其合理性，并确保数值收敛。\n- 您不能使用微扰理论；必须非微扰地求解该积分方程。如果您能从第一性原理推导，可以利用模型势的可分离性将积分方程简化为一个有限维代数系统。\n\n参数值与单位：\n- 使用 $g = 5.0$ 和 $\\beta = 1.0$。\n- 使用 $k_{\\mathrm{ref}} = 1.0$ 和 $K_{\\mathrm{ref}} = -0.4$。\n- 使用 $k_{\\mathrm{test}} = 1.5$。\n- 由于选择了 $\\hbar = 1$ 和 $2\\mu = 1$，所有量均为无量纲。\n\n测试组：\n- 针对以下截断值，评估 $K_1(k_{\\mathrm{test}};\\Lambda)$ 的预测值：\n  - 边缘情况的小截断：$\\Lambda = 2.0$。\n  - 中等截断：$\\Lambda = 4.0$。\n  - 大截断：$\\Lambda = 8.0$。\n  - 非常大的截断：$\\Lambda = 16.0$。\n- 另外，作为边界敏感性探针，包含 $\\Lambda = 1.5$。\n\n最终输出规范：\n- 您的程序必须计算对于列表 $[\\;1.5,\\;2.0,\\;4.0,\\;8.0,\\;16.0\\;]$ 中的每个 $\\Lambda$，在将 $C(\\Lambda)$ 于 $k_{\\mathrm{ref}}$ 处重新拟合到数据点 $K_{\\mathrm{ref}}$ 之后，$K_1(k_{\\mathrm{test}};\\Lambda)$ 的值。\n- 程序必须输出单行，其中包含这五个结果，形式为方括号内以逗号分隔的列表，顺序与上述 $\\Lambda$ 的顺序相同。每个数字必须是四舍五入到小数点后六位的小数。例如，\n$$\n[x_1, x_2, x_3, x_4, x_5]\n$$\n其中每个 $x_i$ 是一个小数点后恰有六位的浮点数。", "solution": "该问题要求对存在奇异势的情况下，分波反应矩阵 $K$ 的 Lippmann-Schwinger (LS) 方程进行非微扰求解。所规定的重整化过程涉及将一个抵消项拟合到一个参考能标下的单个数据点，然后预测在另一能标下的一个可观测量。该预测值对于正则化截断 $\\Lambda$ 的稳定性，是衡量重整化是否成功的标准。\n\n首先，我们验证问题陈述的有效性。\n\n**第 1 步：提取已知条件**\n- Lippmann–Schwinger 方程：$K(p,p';E) = V(p,p') + \\frac{2}{\\pi}\\,\\mathcal{P}\\int_{0}^{\\infty} dq\\, \\frac{q^2\\, V(p,q)\\, K(q,p';E)}{E - q^2}$。\n- 势模型：$V(p,p';\\Lambda) = R_{\\Lambda}(p)\\, R_{\\Lambda}(p')\\left[\\,-\\,g\\, \\frac{p}{p^2+\\beta^2}\\, \\frac{p'}{{p'}^2+\\beta^2} + C(\\Lambda)\\, p\\,p' \\right]$。\n- 正则化因子：$R_{\\Lambda}(p) = \\exp\\!\\left[-\\left(\\frac{p}{\\Lambda}\\right)^{4}\\right]$。\n- 单位与运动学：$\\hbar = 1$, $2\\mu = 1$，因此 $E = k^2$。\n- 可观测量：在壳反应矩阵元 $K_1(k;\\Lambda) \\equiv K(k,k;E=k^2)$。\n- 重整化条件：$K_1(k_{\\mathrm{ref}};\\Lambda) = K_{\\mathrm{ref}}$。\n- 参数：$g = 5.0$, $\\beta = 1.0$, $k_{\\mathrm{ref}} = 1.0$, $K_{\\mathrm{ref}} = -0.4$, $k_{\\mathrm{test}} = 1.5$。\n- 测试组：$\\Lambda \\in \\{\\;1.5,\\;2.0,\\;4.0,\\;8.0,\\;16.0\\;\\}$。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题具有坚实的科学基础，根植于标准的量子散射理论和有效场论原理。所用势为一个秩为2的可分离势，这是一个常见且被充分理解的模型。LS方程是该领域的一个基本方程。重整化方案是在截断框架下处理不可重整化相互作用的标准程序。所有参数和函数都已明确定义，使得问题自洽且适定。此任务是一个虽不平凡但计算上可行的数值练习。不存在矛盾、歧义或事实不准确之处。\n\n**第 3 步：结论与行动**\n问题有效。我们继续求解。\n\n非微扰地求解该积分方程的关键在于利用势 $V(p,p';\\Lambda)$ 的可分离特性。我们可以将势表示为矩阵形式：\n$$\nV(p,p';\\Lambda) = \\mathbf{v}(p, \\Lambda)^T \\mathbf{G}(\\Lambda) \\mathbf{v}(p', \\Lambda)\n$$\n其中 $\\mathbf{v}(p, \\Lambda)$ 是一个代表势的动量依赖部分的列向量，而 $\\mathbf{G}(\\Lambda)$ 是一个耦合常数矩阵。我们定义基向量为：\n$$\nv_1(p, \\Lambda) = R_{\\Lambda}(p) \\frac{p}{p^2+\\beta^2} \\quad \\text{和} \\quad v_2(p, \\Lambda) = R_{\\Lambda}(p) p\n$$\n因此 $\\mathbf{v}(p, \\Lambda) = \\begin{pmatrix} v_1(p, \\Lambda) \\\\ v_2(p, \\Lambda) \\end{pmatrix}$。耦合矩阵 $\\mathbf{G}(\\Lambda)$ 是对角的：\n$$\n\\mathbf{G}(\\Lambda) = \\begin{pmatrix} -g  0 \\\\ 0  C(\\Lambda) \\end{pmatrix}\n$$\n势的可分离形式意味着 K-矩阵 $K(p,p';E)$ 在同一组基下也是可分离的：\n$$\nK(p,p';E) = \\mathbf{v}(p, \\Lambda)^T \\mathbf{M}(E, \\Lambda) \\mathbf{v}(p', \\Lambda)\n$$\n其中 $\\mathbf{M}(E, \\Lambda)$ 是一个待确定的 $2 \\times 2$ 矩阵。将此拟设代入 LS 方程，得到一个关于 $\\mathbf{M}(E, \\Lambda)$ 的代数方程：\n$$\n\\mathbf{M}(E, \\Lambda) = \\mathbf{G}(\\Lambda) + \\mathbf{G}(\\Lambda) \\mathbf{I}(E, \\Lambda) \\mathbf{M}(E, \\Lambda)\n$$\n此处，$\\mathbf{I}(E, \\Lambda)$ 是一个 $2 \\times 2$ 矩阵，其元素为主值积分：\n$$\nI_{ij}(E, \\Lambda) = \\frac{2}{\\pi} \\mathcal{P}\\!\\!\\int_0^\\infty dq\\, \\frac{q^2\\, v_i(q, \\Lambda)\\, v_j(q, \\Lambda)}{E-q^2}\n$$\n通过矩阵求逆解此代数方程，可得 $\\mathbf{M}$ 的非微扰解：\n$$\n\\mathbf{M}(E, \\Lambda) = \\left[ \\mathbf{1} - \\mathbf{G}(\\Lambda) \\mathbf{I}(E, \\Lambda) \\right]^{-1} \\mathbf{G}(\\Lambda) \\equiv \\left[ \\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(E, \\Lambda) \\right]^{-1}\n$$\n我们感兴趣的可观测量是在壳 K-矩阵元 $K_1(k; \\Lambda) = K(k,k;E=k^2)$:\n$$\nK_1(k; \\Lambda) = \\mathbf{v}(k, \\Lambda)^T \\left[ \\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(k^2, \\Lambda) \\right]^{-1} \\mathbf{v}(k, \\Lambda)\n$$\n待求逆的矩阵是：\n$$\n\\mathbf{G}(\\Lambda)^{-1} - \\mathbf{I}(k^2, \\Lambda) = \\begin{pmatrix} -1/g - I_{11}(k^2, \\Lambda)  -I_{12}(k^2, \\Lambda) \\\\ -I_{12}(k^2, \\Lambda)  1/C(\\Lambda) - I_{22}(k^2, \\Lambda) \\end{pmatrix}\n$$\n这里利用了对称性 $I_{12}=I_{21}$。对该矩阵求逆并随后乘以 $\\mathbf{v}(k, \\Lambda)$，便可得到用积分 $I_{ij}$ 和抵消项 $C(\\Lambda)$ 表示的 $K_1(k; \\Lambda)$ 的闭合形式表达式。\n\n数值计算的挑战在于计算积分 $I_{ij}(E, \\Lambda)$。正则化因子 $R_\\Lambda(p)$ 确保了积分收敛，因此我们可以在一个积分上限 $Q_{\\max}$ 处截断积分，该上限处被积函数变得可以忽略不计（例如，$Q_{\\max} = 10\\Lambda$）。柯西主值采用减除法处理。令 $k=\\sqrt{E}$ 和 $F(q) = q^2 v_i(q) v_j(q)$。积分为：\n$$\n\\mathcal{P}\\!\\!\\int_0^{Q_{\\max}} dq \\frac{F(q)}{k^2-q^2} = \\int_0^{Q_{\\max}} dq \\frac{F(q) - F(k)}{k^2-q^2} + F(k) \\mathcal{P}\\!\\!\\int_0^{Q_{\\max}} \\frac{dq}{k^2-q^2}\n$$\n第一项的被积函数在 $q=k$ 处是正则的，可以用标准的数值积分法计算。第二项有解析解：\n$$\nF(k) \\mathcal{P}\\!\\!\\int_0^{Q_{\\max}} \\frac{dq}{k^2-q^2} = F(k) \\frac{1}{2k} \\ln\\left|\\frac{Q_{\\max}+k}{Q_{\\max}-k}\\right|\n$$\n整体算法如下：\n1.  对于每个给定的截断 $\\Lambda$：\n    a.  **拟合 $C(\\Lambda)$**：设置 $k = k_{\\mathrm{ref}} = 1.0$。计算必要的积分 $I_{ij}(k_{\\mathrm{ref}}^2, \\Lambda)$。对 $K_1(k_{\\mathrm{ref}}; \\Lambda)$ 的表达式求逆（该表达式是 $1/C(\\Lambda)$ 的线性函数），以解出满足 $K_1(k_{\\mathrm{ref}}; \\Lambda) = K_{\\mathrm{ref}} = -0.4$ 的 $C(\\Lambda)$ 值。\n    b.  **预测 $K_1(k_{\\mathrm{test}})$**：设置 $k = k_{\\mathrm{test}} = 1.5$。计算积分 $I_{ij}(k_{\\mathrm{test}}^2, \\Lambda)$。使用上一步拟合得到的 $C(\\Lambda)$ 值，计算可观测量 $K_1(k_{\\mathrm{test}}; \\Lambda)$ 的预测值。\n2.  收集所有 $\\Lambda$ 的预测值，并按规定格式化输出。\n此过程在下面的 Python 代码中实现，使用 `numpy` 进行数组操作，`scipy.integrate.quad` 进行数值积分。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\n# Problem parameters are defined globally for clarity.\nG_COUPLING = 5.0\nBETA = 1.0\nK_REF = 1.0\nK_REF_VAL = -0.4\nK_TEST = 1.5\n\ndef regulator(p, cutoff_lambda):\n    \"\"\"Gaussian-type regulator function R_Lambda(p).\"\"\"\n    if cutoff_lambda == 0:\n        return 0.0\n    return np.exp(- (p / cutoff_lambda)**4)\n\ndef v1(p, cutoff_lambda):\n    \"\"\"Potential basis vector v_1(p).\"\"\"\n    return regulator(p, cutoff_lambda) * p / (p**2 + BETA**2)\n\ndef v2(p, cutoff_lambda):\n    \"\"\"Potential basis vector v_2(p).\"\"\"\n    return regulator(p, cutoff_lambda) * p\n\ndef principal_value_integral(F, k, q_max):\n    \"\"\"\n    Computes the Cauchy Principal Value of the integral of F(q)/(k^2-q^2)\n    from 0 to q_max using the subtraction method.\n    \"\"\"\n    if k == 0 or k >= q_max:\n        raise ValueError(\"Pole k must be in (0, q_max) for this PV method.\")\n\n    F_at_k = F(k)\n\n    def integrand_subtracted(q):\n        # This integrand has a removable singularity at q=k.\n        # scipy.integrate.quad can handle this robustly.\n        if np.isclose(q, k):\n            # The limit is complicated to compute analytically, but quad's adaptive\n            # nature means it will sample points around k and converge correctly.\n            # A direct hit is highly unlikely.\n            return 0.0\n        return (F(q) - F_at_k) / (k**2 - q**2)\n\n    integral_part, _ = integrate.quad(integrand_subtracted, 0, q_max)\n    log_part = F_at_k * (1.0 / (2.0 * k)) * np.log((q_max + k) / (q_max - k))\n    \n    return integral_part + log_part\n\ndef compute_integrals(k, cutoff_lambda):\n    \"\"\"\n    Computes the three unique elements of the integral matrix I(k^2).\n    \"\"\"\n    q_max = 10.0 * cutoff_lambda\n\n    # Define the functions F(q) = q^2 * v_i(q) * v_j(q) for each integral.\n    def F11(q): return q**2 * v1(q, cutoff_lambda)**2\n    def F12(q): return q**2 * v1(q, cutoff_lambda) * v2(q, cutoff_lambda)\n    def F22(q): return q**2 * v2(q, cutoff_lambda)**2\n\n    I11 = (2.0 / np.pi) * principal_value_integral(F11, k, q_max)\n    I12 = (2.0 / np.pi) * principal_value_integral(F12, k, q_max)\n    I22 = (2.0 / np.pi) * principal_value_integral(F22, k, q_max)\n\n    return I11, I12, I22\n\ndef solve():\n    \"\"\"\n    Main function to perform renormalization and prediction for each cutoff.\n    \"\"\"\n    cutoffs = [1.5, 2.0, 4.0, 8.0, 16.0]\n    results = []\n\n    for cutoff_lambda in cutoffs:\n        # --- Step 1: Fit C(Lambda) using the reference datum ---\n        # Calculate integrals at the reference momentum k_ref.\n        I11_ref, I12_ref, I22_ref = compute_integrals(K_REF, cutoff_lambda)\n\n        # Evaluate basis vectors at k_ref.\n        v1_ref = v1(K_REF, cutoff_lambda)\n        v2_ref = v2(K_REF, cutoff_lambda)\n\n        # Solve for 1/C(Lambda) algebraically.\n        A0_ref = -1.0/G_COUPLING - I11_ref\n        \n        num_c = (K_REF_VAL * (A0_ref * I22_ref + I12_ref**2) - \n                 I22_ref * v1_ref**2 + \n                 2 * I12_ref * v1_ref * v2_ref + \n                 A0_ref * v2_ref**2)\n        \n        den_c = K_REF_VAL * A0_ref - v1_ref**2\n        \n        if np.isclose(den_c, 0):\n            # This case indicates a potential issue with the chosen parameters,\n            # but is unlikely for this problem.\n            raise RuntimeError(f\"Denominator for C(Lambda) is zero at Lambda={cutoff_lambda}\")\n        \n        one_over_C = num_c / den_c\n        \n        # --- Step 2: Predict K1 at the test momentum k_test ---\n        # Calculate integrals at the test momentum k_test.\n        I11_test, I12_test, I22_test = compute_integrals(K_TEST, cutoff_lambda)\n        \n        # Evaluate basis vectors at k_test.\n        v1_test = v1(K_TEST, cutoff_lambda)\n        v2_test = v2(K_TEST, cutoff_lambda)\n        \n        # Calculate K1(k_test) using the fitted C(Lambda).\n        A = -1.0/G_COUPLING - I11_test\n        B = -I12_test\n        D = one_over_C - I22_test\n        \n        det = A * D - B**2\n        \n        if np.isclose(det, 0):\n            raise RuntimeError(f\"Matrix is singular at Lambda={cutoff_lambda}\")\n            \n        k1_predicted = (D * v1_test**2 - 2 * B * v1_test * v2_test + A * v2_test**2) / det\n        results.append(k1_predicted)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3586377"}]}