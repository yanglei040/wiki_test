{"hands_on_practices": [{"introduction": "在深入研究复杂的核系统之前，我们必须掌握角动量的计算表示。这项实践旨在将轨道角动量 $l$ 与自旋角动量 $s$ 耦合的抽象代数转化为具体的矩阵运算，这对任何计算物理学家来说都是一项基本技能。通过构建和对角化总角动量算符，您将学习如何从非耦合基底过渡到耦合基底，并验证其量子数 $j$ 和 $m$ [@problem_id:3584511]。", "problem": "给定轨道角动量量子数 $l \\in \\{0,1,2,\\dots\\}$ 和内禀自旋量子数 $s \\in \\{0,\\tfrac{1}{2},1,\\tfrac{3}{2},\\dots\\}$，考虑非耦合基 $\\{\\vert l\\, m_l\\rangle \\otimes \\vert s\\, m_s\\rangle\\}$，其中 $m_l \\in \\{-l,-l+1,\\dots,l\\}$ 且 $m_s \\in \\{-s,-s+1,\\dots,s\\}$。在非相对论量子力学中，设约化普朗克常数 $\\hbar = 1$，轨道角动量算符 $\\mathbf{L} = (L_x,L_y,L_z)$ 和自旋算符 $\\mathbf{S} = (S_x,S_y,S_z)$ 分别作用于它们各自的子空间，并满足对易关系 $[L_i,L_j] = i \\epsilon_{ijk} L_k$，$[S_i,S_j] = i \\epsilon_{ijk} S_k$，且 $\\mathbf{L}$ 的所有分量与 $\\mathbf{S}$ 的所有分量对易。总角动量算符定义为 $\\mathbf{J} = \\mathbf{L} + \\mathbf{S}$，其平方大小为 $J^2 = J_x^2 + J_y^2 + J_z^2$，投影为 $J_z$。耦合基态 $\\vert (l s)\\, j\\, m\\rangle$ 是 $J^2$ 和 $J_z$ 的共同本征态，其本征值分别为 $j(j+1)$ 和 $m$，其中 $j$ 的取值范围为 $\\{|l-s|,|l-s|+1,\\dots,l+s\\}$，$m \\in \\{-j,-j+1,\\dots,j\\}$。\n\n您的任务是实现一个算法，该算法：\n- 对于给定的 $l$ 构建 $L_x, L_y, L_z$ 的矩阵表示，对于给定的 $s$ 构建 $S_x, S_y, S_z$ 的矩阵表示。这通过使用升降算符 $L_{\\pm} = L_x \\pm i L_y$ 和 $S_{\\pm} = S_x \\pm i S_y$ 以及经过充分检验的作用关系 $L_{\\pm} \\vert l\\, m_l\\rangle = \\sqrt{l(l+1) - m_l(m_l \\pm 1)} \\vert l\\, m_l \\pm 1\\rangle$ 和 $S_{\\pm} \\vert s\\, m_s\\rangle = \\sqrt{s(s+1) - m_s(m_s \\pm 1)} \\vert s\\, m_s \\pm 1\\rangle$，并结合 $L_z \\vert l\\, m_l\\rangle = m_l \\vert l\\, m_l\\rangle$ 和 $S_z \\vert s\\, m_s\\rangle = m_s \\vert s\\, m_s\\rangle$ 来完成。\n- 使用恒等式 $J^2 = L^2 \\otimes I_s + I_l \\otimes S^2 + 2\\,(L_x \\otimes S_x + L_y \\otimes S_y + L_z \\otimes S_z)$ 来构成 $J_z = L_z \\otimes I_s + I_l \\otimes S_z$ 和 $J^2$，其中 $L^2 = l(l+1) I_l$ 且 $S^2 = s(s+1) I_s$。\n- 对角化 $J^2$ 以识别由 $j$ 标记的子空间，并在每个 $j$-子空间内，对角化 $J_z$ 以获得以非耦合基表示的耦合基矢量 $\\vert (l s)\\, j\\, m\\rangle$。\n- 通过计算所有耦合态的最大绝对范数偏差 $\\max \\lVert J^2 \\vert (l s)\\, j\\, m\\rangle - j(j+1) \\vert (l s)\\, j\\, m\\rangle \\rVert$ 和 $\\max \\lVert J_z \\vert (l s)\\, j\\, m\\rangle - m \\vert (l s)\\, j\\, m\\rangle \\rVert$，数值上验证每个构造的耦合矢量是 $J^2$ 的本征矢量（本征值为 $j(j+1)$）和 $J_z$ 的本征矢量（本征值为 $m$）。同时，根据轨道角动量报告内禀宇称 $\\pi = (-1)^l$。\n- 假设同位旋 (isospin) $t$ 在此构造中是一个旁观量子数，并且在此任务中不与自旋轨道耦合；因此，您只需为每种情况报告 $\\pi = (-1)^l$，而无需计算同位旋算符。\n\n设计您的程序，使其对每个测试用例 $(l,s)$ 输出一个列表，其中包含：\n- 耦合态的总数，应等于 $(2l+1)(2s+1)$。\n- $J^2$ 的最大验证误差，为一个实值浮点数。\n- $J_z$ 的最大验证误差，为一个实值浮点数。\n- 内禀宇称 $\\pi = (-1)^l$，为一个整数 $+1$ 或 $-1$。\n- 发现的不同 $j$ 值的排序列表。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身是一个形如 $[N,\\mathrm{err}_{J^2},\\mathrm{err}_{J_z},\\pi,[j\\_1,j\\_2,\\dots]]$ 的列表，聚合输出必须是 $[[\\cdots],[\\cdots],\\dots]$ 的形式。\n\n要实现和评估的测试套件：\n- 情况 1：$(l,s) = \\left(1,\\tfrac{1}{2}\\right)$。\n- 情况 2：$(l,s) = \\left(2,\\tfrac{1}{2}\\right)$。\n- 情况 3：$(l,s) = \\left(0,1\\right)$。\n- 情况 4：$(l,s) = \\left(3,0\\right)$。\n- 情况 5：$(l,s) = \\left(2,1\\right)$。\n\n在此算符代数中，角度是无量纲的相位变量，因此不需要角度单位。输出中没有需要报告的物理单位，您必须使用指定的精确数字。\n\n您的程序不得读取任何输入，并且必须以指定格式精确打印一行。[@problem_id:442]", "solution": "用户提供了一个来自计算量子力学领域的有效且定义明确的问题陈述。任务是对于给定的轨道 ($l$) 和自旋 ($s$) 量子数，从非耦合的张量积基构造并验证耦合的角动量基态。该问题在科学上基于量子角动量理论的原理，并提供了一套清晰、客观的指令和测试用例。\n\n解决方案通过实现一个遵循已建立的角动量耦合算符代数的数值算法来推进。核心步骤是：\n1.  在各自的希尔伯特空间中，构建基本角动量算符（$\\mathbf{L}$ 和 $\\mathbf{S}$）的矩阵表示。\n2.  在张量积空间中，构成总角动量算符（$\\mathbf{J} = \\mathbf{L} + \\mathbf{S}$）。\n3.  对总角动量算符进行数值对角化，以找到共同的本征基，这对应于耦合基态。\n4.  验证结果并提取所需的物理量。\n\n### 理论与算法框架\n\n**1. 单粒子角动量算符**\n\n对于一个通用的角动量量子数 $j_0$（可以是 $l$ 或 $s$），希尔伯特空间由 $d = 2j_0+1$ 个基态 $\\vert j_0, m \\rangle$ 张成，其中 $m \\in \\{-j_0, -j_0+1, \\dots, j_0\\}$。我们采用一个标准的基排序，其中 $m$ 是递减的，即 $(\\vert j_0, j_0 \\rangle, \\vert j_0, j_0-1 \\rangle, \\dots, \\vert j_0, -j_0 \\rangle)$。\n\n$z$-分量算符 $J_z$ 的矩阵在此基下是对角的，矩阵元为：\n$$\n\\langle j_0, m' \\vert J_z \\vert j_0, m \\rangle = m \\, \\delta_{m'm}\n$$\n升降算符 $J_{\\pm} = J_x \\pm iJ_y$ 的作用如下：\n$$\nJ_{\\pm} \\vert j_0, m \\rangle = \\sqrt{j_0(j_0+1) - m(m \\pm 1)} \\, \\vert j_0, m \\pm 1 \\rangle\n$$\n这定义了它们的矩阵元。例如，在我们选择的基排序中，$J_+$ 仅在超对角线上有非零元素，而 $J_-$ 仅在次对角线上有非零元素。\n$$\n\\langle j_0, m' \\vert J_+ \\vert j_0, m \\rangle = \\sqrt{j_0(j_0+1) - m(m+1)} \\, \\delta_{m', m+1}\n$$\n$$\n\\langle j_0, m' \\vert J_- \\vert j_0, m \\rangle = \\sqrt{j_0(j_0+1) - m(m-1)} \\, \\delta_{m', m-1}\n$$\n然后，通过反转升降算符的定义来找到笛卡尔分量 $J_x$ 和 $J_y$：\n$$\nJ_x = \\frac{1}{2}(J_+ + J_-)\n$$\n$$\nJ_y = \\frac{1}{2i}(J_+ - J_-) = -\\frac{i}{2}(J_+ - J_-)\n$$\n此过程用于构建 $\\mathbf{L} = (L_x, L_y, L_z)$ 的 $(2l+1) \\times (2l+1)$ 矩阵和 $\\mathbf{S} = (S_x, S_y, S_z)$ 的 $(2s+1) \\times (2s+1)$ 矩阵。\n\n**2. 乘积空间中的总角动量算符**\n\n组合系统在维度为 $D = (2l+1)(2s+1)$ 的张量积希尔伯特空间中描述。非耦合基态为 $\\vert l, m_l \\rangle \\otimes \\vert s, m_s \\rangle$。作用于整个空间的算符使用克罗内克积 ($\\otimes$) 构建。\n总角动量算符由以下公式给出：\n$$\n\\mathbf{J} = \\mathbf{L} + \\mathbf{S} \\implies J_k = L_k \\otimes I_s + I_l \\otimes S_k \\quad (\\text{对于 } k=x,y,z)\n$$\n其中 $I_l$ 和 $I_s$ 分别是维度为 $(2l+1)$ 和 $(2s+1)$ 的单位矩阵。\n\n总角动量平方算符 $J^2$ 由以下公式给出：\n$$\nJ^2 = (\\mathbf{L}+\\mathbf{S}) \\cdot (\\mathbf{L}+\\mathbf{S}) = L^2 + S^2 + 2\\mathbf{L} \\cdot \\mathbf{S}\n$$\n在张量积空间中，这变为：\n$$\nJ^2 = (L^2 \\otimes I_s) + (I_l \\otimes S^2) + 2(L_x \\otimes S_x + L_y \\otimes S_y + L_z \\otimes S_z)\n$$\n由于 $L^2$ 和 $S^2$ 在它们各自的空间中与单位矩阵成比例，其本征值分别为 $l(l+1)$ 和 $s(s+1)$，因此这可以简化为：\n$$\nJ^2 = l(l+1) I_D + s(s+1) I_D + 2(L_x \\otimes S_x + L_y \\otimes S_y + L_z \\otimes S_z)\n$$\n其中 $I_D = I_l \\otimes I_s$ 是完整乘积空间中的单位矩阵。\n\n**3. 同时对角化**\n\n耦合基态 $\\vert (ls)j, m \\rangle$ 是 $J^2$ 和 $J_z$ 的共同本征态。一个稳健的数值方法来找到这个共同基是对两个对易算符 $J^2$ 和 $J_z$ 的线性组合进行对角化。我们构建厄米矩阵：\n$$\nM = J^2 + \\epsilon J_z\n$$\n其中 $\\epsilon$ 是一个小的非零实数（例如 $10^{-6}$）。$M$ 的本征值近似为 $\\lambda_M \\approx j(j+1) + \\epsilon m$。由于不同 $j(j+1)$ 值之间的间距远大于任何可能的 $\\epsilon m$ 项，这个选择消除了所有简并。对角化 $M$ 得到一组 $D$ 个标准正交本征向量 $\\{\\psi_i\\}$ 和相应的本征值 $\\{\\lambda_i\\}$。\n\n对于每个本征对 $(\\lambda_i, \\psi_i)$：\n- 总角动量量子数 $j_i$ 通过数值识别主导项来找到：\n  $$ j_i(j_i+1) \\approx \\lambda_i \\implies j_i = \\text{round}\\left(\\frac{\\sqrt{1+4\\lambda_i}-1}{2}\\right) $$\n  四舍五入是必要的，以校正浮点不精确性和小的 $\\epsilon m$ 贡献。\n- 然后从微扰项中提取磁量子数 $m_i$：\n  $$ m_i = \\text{round}\\left(\\frac{\\lambda_i - j_i(j_i+1)}{\\epsilon}\\right) $$\n此过程产生完整的耦合基态集合 $\\psi_i = \\vert (ls)j_i, m_i \\rangle$ 及其相关的量子数。\n\n**4. 验证和输出生成**\n\n为了验证数值解，我们检验每个计算出的本征向量 $\\psi_{jm}$ 确实是原始算符 $J^2$ 和 $J_z$ 的本征向量，并具有正确的本征值。这通过计算残差向量的欧几里得范数来量化：\n$$\n\\text{err}_{J^2} = \\max_{j,m} \\lVert J^2 \\psi_{jm} - j(j+1)\\psi_{jm} \\rVert_2\n$$\n$$\n\\text{err}_{J_z} = \\max_{j,m} \\lVert J_z \\psi_{jm} - m\\psi_{jm} \\rVert_2\n$$\n对于成功的计算，这些最大误差应该在机器精度的数量级。\n\n最后，对于每个测试用例 $(l,s)$，我们汇编所需的输出：\n- 耦合态的总数，$N = (2l+1)(2s+1)$。\n- $J^2$ 的最大验证误差，$\\text{err}_{J^2}$。\n- $J_z$ 的最大验证误差，$\\text{err}_{J_z}$。\n- 内禀宇称，$\\pi = (-1)^l$。\n- 在对角化过程中发现的唯一 $j$ 值的排序列表。\n\n这种结构化的方法为角动量耦合问题提供了一个全面且可验证的解决方案。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef get_angular_momentum_matrices(j_val):\n    \"\"\"\n    Constructs matrix representations of angular momentum operators Jx, Jy, Jz for a given quantum number j.\n\n    Args:\n        j_val (float): The angular momentum quantum number (integer or half-integer).\n\n    Returns:\n        tuple[np.ndarray, np.ndarray, np.ndarray]: A tuple containing the Jx, Jy, Jz matrices.\n    \"\"\"\n    if j_val  0:\n        raise ValueError(\"Angular momentum quantum number j cannot be negative.\")\n    \n    dim = int(2 * j_val + 1)\n    if dim == 0: # Should not happen with j_val = 0\n        return (np.array([[]]), np.array([[]]), np.array([[]]))\n    if dim == 1: # Trivial case j=0\n        return (np.array([[0.]]), np.array([[0.]]), np.array([[0.]]))\n\n    m_vals = np.arange(j_val, -j_val - 1, -1)\n    \n    # Construct Jz\n    Jz = np.diag(m_vals)\n    \n    # Construct J+ (raising operator)\n    J_plus = np.zeros((dim, dim))\n    for i in range(dim - 1):\n        m = m_vals[i+1] # State being raised from\n        # Transition from m - m+1. Basis is ordered j, j-1, ...\n        # So we want transition from state i+1 to state i.\n        val = np.sqrt(j_val * (j_val + 1) - m * (m + 1))\n        J_plus[i, i+1] = val\n        \n    # J- is the hermitian conjugate of J+\n    J_minus = J_plus.T\n    \n    # Construct Jx and Jy\n    Jx = 0.5 * (J_plus + J_minus)\n    Jy = -0.5j * (J_plus - J_minus)\n    \n    return Jx, Jy, Jz\n\ndef process_case(l, s):\n    \"\"\"\n    Solves the angular momentum coupling problem for a given (l, s) pair.\n\n    Args:\n        l (float): The orbital angular momentum quantum number.\n        s (float): The intrinsic spin quantum number.\n\n    Returns:\n        list: A list containing [N, err_J2, err_Jz, pi, [j_values]].\n    \"\"\"\n    dim_l = int(2 * l + 1)\n    dim_s = int(2 * s + 1)\n    N = dim_l * dim_s\n\n    # 1. Construct single-particle operators\n    Lx, Ly, Lz = get_angular_momentum_matrices(l)\n    Sx, Sy, Sz = get_angular_momentum_matrices(s)\n\n    # Identity matrices\n    I_l = np.eye(dim_l)\n    I_s = np.eye(dim_s)\n\n    # 2. Construct total angular momentum operators in the product space\n    Jx = np.kron(Lx, I_s) + np.kron(I_l, Sx)\n    Jy = np.kron(Ly, I_s) + np.kron(I_l, Sy)\n    Jz = np.kron(Lz, I_s) + np.kron(I_l, Sz)\n\n    # Construct J^2 using the formula J^2 = L^2 + S^2 + 2L.S\n    L_dot_S = np.kron(Lx, Sx) + np.kron(Ly, Sy) + np.kron(Lz, Sz)\n    L2_val = l * (l + 1)\n    S2_val = s * (s + 1)\n    J2 = (L2_val + S2_val) * np.eye(N) + 2 * L_dot_S\n\n    # 3. Simultaneous diagonalization\n    # Use a small perturbation to lift degeneracies\n    epsilon = 1e-6\n    M = J2 + epsilon * Jz\n    \n    # eigh for Hermitian matrices; returns sorted eigenvalues\n    eigvals_M, eigvecs_M = linalg.eigh(M)\n\n    # 4. Extract quantum numbers, validate, and collect results\n    found_j_values = set()\n    max_err_J2 = 0.0\n    max_err_Jz = 0.0\n\n    for i in range(N):\n        eigenvector = eigvecs_M[:, i]\n        eigenvalue = eigvals_M[i]\n        \n        # Extract j and m\n        # round(x * 2) / 2 rounds to the nearest half-integer\n        j = round((np.sqrt(1 + 4 * eigenvalue) - 1) / 2 * 2) / 2\n        m = round((eigenvalue - j * (j + 1)) / epsilon * 2) / 2\n        \n        found_j_values.add(j)\n        \n        # Validation\n        j2_val_expected = j * (j + 1)\n        err_vec_J2 = J2 @ eigenvector - j2_val_expected * eigenvector\n        max_err_J2 = max(max_err_J2, np.linalg.norm(err_vec_J2))\n        \n        m_val_expected = m\n        err_vec_Jz = Jz @ eigenvector - m_val_expected * eigenvector\n        max_err_Jz = max(max_err_Jz, np.linalg.norm(err_vec_Jz))\n\n    parity = (-1)**l\n    sorted_j = sorted(list(found_j_values))\n    \n    return [N, max_err_J2, max_err_Jz, parity, sorted_j]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        (1, 0.5), # (l, s) = (1, 1/2)\n        (2, 0.5), # (l, s) = (2, 1/2)\n        (0, 1),   # (l, s) = (0, 1)\n        (3, 0),   # (l, s) = (3, 0)\n        (2, 1),   # (l, s) = (2, 1)\n    ]\n\n    results_str = []\n    for case in test_cases:\n        l, s = case\n        result = process_case(l, s)\n        \n        # Format the result list into the required string format\n        # [N, err_J2, err_Jz, pi, [j1,j2,...]]\n        num_states, err_j2, err_jz, parity, j_vals = result\n        j_list_str = f\"[{','.join(map(str, j_vals))}]\"\n        case_str = f\"[{num_states},{err_j2},{err_jz},{parity},{j_list_str}]\"\n        results_str.append(case_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3584511"}, {"introduction": "自旋-轨道相互作用是核力的一个关键特征，它解释了原子核的壳层结构。这项实践将您从抽象的代数概念带入物理现实，要求您数值求解包含自旋-轨道势的薛定谔方程。通过这种方式，您将亲自计算由总角动量 $j=l \\pm 1/2$ 产生的可观测能量分裂，从而加深对这些量子数物理意义的理解 [@problem_id:3584524]。", "problem": "一个在球对称平均场势中运动的单核子由三维不含时薛定谔方程描述。在球坐标系中，通过分离变量法可将问题简化为关于约化径向波函数 $u(r)$ 的径向方程，\n$$\n\\left[-\\frac{\\hbar^2}{2\\mu}\\frac{d^2}{dr^2} + \\frac{\\hbar^2 \\ell(\\ell+1)}{2\\mu r^2} + V_{\\text{cent}}(r) + V_{\\text{so}}(r)\\right] u(r) = E\\,u(r),\n$$\n其中 $\\mu$ 是核子-核芯系统的约化质量，$\\ell$ 是轨道角动量，$V_{\\text{cent}}(r)$ 是中心势，$V_{\\text{so}}(r)$ 是单体自旋轨道势。对于中子，不存在依赖于电荷的库仑相互作用。考虑 Woods-Saxon (WS) 中心势和一个导数形式的 Woods-Saxon 自旋轨道项：\n$$\nV_{\\text{cent}}(r) = -V_0\\, f(r), \\quad f(r) = \\frac{1}{1 + \\exp\\!\\left(\\frac{r - R}{a}\\right)},\n$$\n其半径为 $R = r_0 A^{1/3}$，弥散度为 $a$。自旋轨道算符为 $\\mathbf{\\ell}\\cdot\\mathbf{s}$，其本征值为\n$$\n\\langle \\mathbf{\\ell}\\cdot\\mathbf{s}\\rangle = \\frac{1}{2}\\left[j(j+1) - \\ell(\\ell+1) - s(s+1)\\right], \\quad s = \\frac{1}{2}, \\quad j=\\ell\\pm\\frac{1}{2}.\n$$\n使用以下唯象形式表示自旋轨道势能的贡献，\n$$\nV_{\\text{so}}(r) = V_{\\text{so0}}\\left(\\frac{1}{r}\\frac{df}{dr}\\right)\\langle \\mathbf{\\ell}\\cdot\\mathbf{s}\\rangle,\n$$\n其中 $V_{\\text{so0}}$ 的单位经过选取，以使 $V_{\\text{so}}(r)$ 的单位为能量单位。WS 形状因子的导数为\n$$\n\\frac{df}{dr} = -\\frac{1}{a} f(r)\\left[1-f(r)\\right].\n$$\n采用约化质量 $\\mu = m_n \\frac{A-1}{A}$，其中 $m_n c^2 = 939.565\\,\\text{MeV}$ 且 $\\hbar c = 197.3269804\\,\\text{MeV}\\cdot\\text{fm}$。在能量单位为兆电子伏 (MeV) 和长度单位为飞米 (fm) 的单位制下进行计算。离心项应完全按照上述给定的形式处理。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n- 在一个均匀网格上，使用动能算符的二阶中心有限差分近似来构建径向哈密顿量，并在 $r=0$ 和 $r=R_{\\max}$ 处施加狄利克雷边界条件。\n- 对于每个指定的测试用例，计算对应于相同径向节数 $n_r$（对于固定的 $\\ell$ 和 $j$，$n_r=0$ 是无节态）的两个总角动量 $j_{\\pm}=\\ell\\pm\\frac{1}{2}$ 的最低束缚态能量 $E_{\\ell,j_+}^{(n_r)}$ 和 $E_{\\ell,j_-}^{(n_r)}$。如果 $\\ell=0$，由于只存在 $j=\\frac{1}{2}$，按照惯例将自旋轨道分裂定义为 $0$。\n- 将自旋轨道能量分裂定义为\n$$\n\\Delta E_{\\text{calc}} = E_{\\ell,j_+}^{(n_r)} - E_{\\ell,j_-}^{(n_r)}.\n$$\n- 通过计算差值，将计算出的分裂 $\\Delta E_{\\text{calc}}$ 与给定的经验分裂 $\\Delta E_{\\text{emp}}$ 进行比较\n$$\n\\delta = \\Delta E_{\\text{calc}} - \\Delta E_{\\text{emp}}.\n$$\n\n数值与实现要求：\n- 使用从 $r=\\Delta r$ 到 $r=R_{\\max}$ 的均匀径向网格，其中 $R_{\\max} = 20\\,\\text{fm}$ 且 $\\Delta r = 0.05\\,\\text{fm}$。\n- 使用三对角有限差分动能算符，并将离心项和势能项包含在对角线上。\n- 将能量 $E0$ 的态识别为束缚态。对于每个 $(\\ell,j)$，当能量从低到高排序时，选择与指定的径向节数 $n_r$ 相对应的本征值。\n- 所有能量均以兆电子伏 (MeV) 表示。\n\n测试套件：\n对于每个元组，其条目为 $(A, V_0\\,\\text{[MeV]}, r_0\\,\\text{[fm]}, a\\,\\text{[fm]}, V_{\\text{so0}}\\,\\text{[MeV}\\cdot\\text{fm}^2], \\ell, n_r, \\Delta E_{\\text{emp}}\\,\\text{[MeV]})$。所有核子均为中子。\n- 情况1：$(16,\\; 52.0,\\; 1.25,\\; 0.65,\\; 12.0,\\; 1,\\; 0,\\; 6.2)$。\n- 情况2：$(40,\\; 50.0,\\; 1.27,\\; 0.67,\\; 12.0,\\; 3,\\; 0,\\; 6.0)$。\n- 情况3：$(208,\\; 50.0,\\; 1.27,\\; 0.67,\\; 12.0,\\; 5,\\; 0,\\; 5.5)$。\n- 情况4 (边界情况: $\\ell=0$)：$(40,\\; 50.0,\\; 1.27,\\; 0.67,\\; 12.0,\\; 0,\\; 0,\\; 0.0)$。\n- 情况5 (边界情况: $V_{\\text{so0}}=0$)：$(40,\\; 50.0,\\; 1.27,\\; 0.67,\\; 0.0,\\; 3,\\; 0,\\; 0.0)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按测试用例顺序排列的结果，每个条目是浮点数 $\\delta$ 并四舍五入到三位小数。例如，输出格式必须与 $[\\delta_1,\\delta_2,\\delta_3,\\delta_4,\\delta_5]$ 完全一样。", "solution": "该问题要求数值求解一个在中子在球对称平均场势中的不含时径向薛定谔方程。目标是计算指定原子核构型下由自旋轨道相互作用引起的能量分裂，并将其与经验值进行比较。该模型对中心相互作用采用 Woods-Saxon 势，对自旋轨道项采用导数形式的 Woods-Saxon 势。\n\n径向薛定谔方程由下式给出：\n$$\n\\left[-\\frac{\\hbar^2}{2\\mu}\\frac{d^2}{dr^2} + \\frac{\\hbar^2 \\ell(\\ell+1)}{2\\mu r^2} + V_{\\text{cent}}(r) + V_{\\text{so}}(r)\\right] u(r) = E\\,u(r)\n$$\n该方程描述了约化质量为 $\\mu$、轨道角动量量子数为 $\\ell$ 的核子的运动。我们将通过在均匀径向网格上将其离散化并将其转换为矩阵本征值问题来求解该方程。\n\n首先，我们建立数值框架。径向坐标 $r$ 在一个由点 $r_i = i \\cdot \\Delta r$（$i=1, 2, \\dots, N-1$）组成的均匀网格上离散化，其中网格间距为 $\\Delta r = 0.05\\,\\text{fm}$，网格延伸至最大半径 $R_{\\max} = 20\\,\\text{fm}$。网格区间数为 $N = R_{\\max} / \\Delta r$，因此有 $N-1$ 个内部网格点。波函数 $u(r)$ 表示为一个向量 $\\mathbf{u}$，其分量为 $u_i = u(r_i)$。施加狄利克雷边界条件 $u(0)=0$ 和 $u(R_{\\max})=0$。在 $r=0$ 处的条件由从 $r_1=\\Delta r$ 开始的网格上的有限差分格式自然满足，而在 $R_{\\max}$ 处的条件意味着解空间的基不包括该边界点。\n\n二阶导数算符 $\\frac{d^2}{dr^2}$ 使用二阶中心有限差分公式近似：\n$$\n\\frac{d^2u}{dr^2}\\bigg|_{r_i} \\approx \\frac{u(r_{i-1}) - 2u(r_i) + u(r_{i+1})}{(\\Delta r)^2} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{(\\Delta r)^2}\n$$\n将此代入薛定谔方程，我们得到关于分量 $u_i$ 的线性方程组。该系统可以写成矩阵本征值方程 $\\mathbf{H}\\mathbf{u} = E\\mathbf{u}$，其中 $\\mathbf{H}$ 是哈密顿矩阵。$\\mathbf{H}$ 是一个实对称三对角矩阵。其元素为：\n- 对角元：$H_{ii} = \\frac{\\hbar^2}{\\mu (\\Delta r)^2} + V_{\\text{total}}(r_i)$\n- 非对角元：$H_{i,i\\pm 1} = -\\frac{\\hbar^2}{2\\mu (\\Delta r)^2}$\n\n每个网格点 $r_i$ 处的总势 $V_{\\text{total}}(r_i)$ 是离心势、中心势和自旋轨道势之和：\n$V_{\\text{total}}(r) = V_{\\text{cf}}(r) + V_{\\text{cent}}(r) + V_{\\text{so}}(r)$。\n\n各项势的定义如下：\n1.  **中心势**：Woods-Saxon 势由 $V_{\\text{cent}}(r) = -V_0 f(r)$ 给出，其中 $f(r) = \\frac{1}{1 + \\exp((r-R)/a)}$。原子核半径为 $R = r_0 A^{1/3}$，$A$ 是核芯的质量数。\n\n2.  **离心势**：离心势垒为 $V_{\\text{cf}}(r) = \\frac{\\hbar^2 \\ell(\\ell+1)}{2\\mu r^2}$。对于 s 波（$\\ell=0$），此项为零。\n\n3.  **自旋轨道势**：自旋轨道势为 $V_{\\text{so}}(r) = V_{\\text{so0}}\\left(\\frac{1}{r}\\frac{df}{dr}\\right)\\langle \\mathbf{\\ell}\\cdot\\mathbf{s}\\rangle$。形状因子的导数为 $\\frac{df}{dr} = -\\frac{1}{a} f(r)[1-f(r)]$。算符 $\\mathbf{\\ell}\\cdot\\mathbf{s}$ 的本征值取决于总角动量量子数 $j$，它可以是 $j = \\ell \\pm 1/2$（对于 $\\ell  0$）。核子自旋为 $s=1/2$。其本征值为：\n    - 对于 $j_+ = \\ell + 1/2$: $\\langle \\mathbf{\\ell}\\cdot\\mathbf{s}\\rangle = \\frac{1}{2}\\left[j(j+1) - \\ell(\\ell+1) - s(s+1)\\right] = \\frac{\\ell}{2}$。\n    - 对于 $j_- = \\ell - 1/2$: $\\langle \\mathbf{\\ell}\\cdot\\mathbf{s}\\rangle = \\frac{1}{2}\\left[j(j+1) - \\ell(\\ell+1) - s(s+1)\\right] = -\\frac{\\ell+1}{2}$。\n对于 $\\ell=0$，只有 $j=1/2$ 是可能的，且 $\\langle\\mathbf{\\ell}\\cdot\\mathbf{s}\\rangle = 0$。\n\n常数以 MeV 和 fm 为单位处理。动能预因子为 $\\frac{\\hbar^2}{2\\mu} = \\frac{(\\hbar c)^2}{2\\mu c^2} = \\frac{(\\hbar c)^2}{2(m_n c^2) \\frac{A-1}{A}} = \\left(\\frac{(\\hbar c)^2}{2 m_n c^2}\\right) \\frac{A}{A-1}$。我们使用 $m_n c^2 = 939.565\\,\\text{MeV}$ 和 $\\hbar c = 197.3269804\\,\\text{MeV}\\cdot\\text{fm}$。\n\n对于每个测试用例，计算算法如下：\n1.  设置径向网格 `r` 和物理常数。\n2.  对于给定的一组参数 $(A, V_0, r_0, a, V_{so0}, \\ell, n_r, \\Delta E_{\\text{emp}})$：\n3.  如果 $\\ell=0$，则理论自旋轨道分裂 $\\Delta E_{\\text{calc}}$ 定义为 $0$。差值 $\\delta$ 于是为 $0 - \\Delta E_{\\text{emp}}$。\n4.  如果 $\\ell0$，则执行两次独立的计算：\n    a. 对于 $j_+ = \\ell+1/2$，使用 $\\langle\\mathbf{\\ell}\\cdot\\mathbf{s}\\rangle = \\ell/2$ 构建总势 $V_{\\text{total}, +}(r)$。构成哈密顿矩阵 $\\mathbf{H}_+$ 并求解其本征值。\n    b. 对于 $j_- = \\ell-1/2$，使用 $\\langle\\mathbf{\\ell}\\cdot\\mathbf{s}\\rangle = -(\\ell+1)/2$ 构建总势 $V_{\\text{total}, -}(r)$。构成哈密顿矩阵 $\\mathbf{H}_-$ 并求解其本征值。\n5.  对于 $j_+$ 和 $j_-$ 两种情况，束缚态能量被识别为那些本征值 $E  0$。将这些能量按升序排序。所需的能量 ($E_{\\ell, j}^{(n_r)}$) 是排序后列表中索引为 $n_r$ 的那个（其中 $n_r=0$ 对应于最低能量的束缚态）。\n6.  计算出的自旋轨道分裂为 $\\Delta E_{\\text{calc}} = E_{\\ell,j_+}^{(n_r)} - E_{\\ell,j_-}^{(n_r)}$。\n7.  该测试用例的最终结果是差值 $\\delta = \\Delta E_{\\text{calc}} - \\Delta E_{\\text{emp}}$。\n\n对所有测试用例重复此过程，并将得到的 $\\delta$ 值收集并格式化。使用一个专门用于三对角矩阵的数值例程 `scipy.linalg.eigh_tridiagonal`，以高效、准确地计算本征值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\n# Global constants and grid configuration\nM_N_C2 = 939.565  # MeV\nHBARC = 197.3269804  # MeV fm\nKINETIC_CONST = HBARC**2 / (2 * M_N_C2)  # hbar^2/(2m_n) in MeV fm^2\n\nDR = 0.05  # fm, grid spacing\nR_MAX = 20.0  # fm, maximum radius\nr_grid = np.arange(DR, R_MAX, DR)\nN_POINTS = len(r_grid)\n\ndef compute_level_energy(potential_params, l, j, nr):\n    \"\"\"\n    Computes the energy of a nucleon state for given quantum numbers and potential.\n\n    Args:\n        potential_params (tuple): (A, V0, r0, a, V_so0) defining the potential.\n        l (int): Orbital angular momentum quantum number.\n        j (float): Total angular momentum quantum number.\n        nr (int): Radial node index (0 for nodeless state).\n        \n    Returns:\n        float: The calculated energy of the state in MeV.\n    \"\"\"\n    A, V0, r0, a, V_so0 = potential_params\n\n    if A = 1:\n        raise ValueError(\"Mass number A must be greater than 1.\")\n\n    kinetic_factor = KINETIC_CONST * A / (A - 1.0)\n    R = r0 * A**(1.0 / 3.0)\n\n    # Calculate the eigenvalue of the l.s operator\n    if abs(j - (l + 0.5))  1e-6: # j = l + 1/2\n        ls_coupling = l / 2.0\n    elif abs(j - (l - 0.5))  1e-6: # j = l - 1/2\n        ls_coupling = -(l + 1.0) / 2.0\n    else:\n        # This case occurs for l=0, where j=0.5, but ls_coupling is 0\n        if l == 0:\n            ls_coupling = 0.0\n        else:\n            raise ValueError(f\"Invalid j={j} for l={l}\")\n\n    # Calculate potential terms on the grid\n    f_r = 1.0 / (1.0 + np.exp((r_grid - R) / a))\n    \n    V_cent = -V0 * f_r\n    \n    # Derivative term for spin-orbit potential\n    dfdr_term = -(1.0 / (a * r_grid)) * f_r * (1.0 - f_r)\n    V_so = V_so0 * dfdr_term * ls_coupling\n    \n    V_cf = kinetic_factor * l * (l + 1) / r_grid**2\n    \n    V_total = V_cent + V_so + V_cf\n\n    # Construct the tridiagonal Hamiltonian matrix\n    diag_kinetic = kinetic_factor * 2.0 / DR**2\n    offdiag_kinetic = -kinetic_factor / DR**2\n    \n    H_diag = diag_kinetic + V_total\n    H_offdiag = np.full(N_POINTS - 1, offdiag_kinetic)\n    \n    # Solve the eigenvalue problem\n    eigenvalues = eigh_tridiagonal(H_diag, H_offdiag, eigvals_only=True)\n    \n    # Filter for bound states (E  0)\n    bound_energies = eigenvalues[eigenvalues  0]\n\n    if len(bound_energies) = nr:\n        # If the state is not bound or not enough states exist\n        return np.nan\n    \n    return bound_energies[nr]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (A, V0 [MeV], r0 [fm], a [fm], V_so0 [MeV*fm^2], l, nr, dE_emp [MeV])\n        (16, 52.0, 1.25, 0.65, 12.0, 1, 0, 6.2),\n        (40, 50.0, 1.27, 0.67, 12.0, 3, 0, 6.0),\n        (208, 50.0, 1.27, 0.67, 12.0, 5, 0, 5.5),\n        (40, 50.0, 1.27, 0.67, 12.0, 0, 0, 0.0),\n        (40, 50.0, 1.27, 0.67, 0.0, 3, 0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, V0, r0, a, V_so0, l, nr, dE_emp = case\n        \n        # Handle cases for l=0 or V_so0=0 where splitting is zero\n        if l == 0 or V_so0 == 0.0:\n            dE_calc = 0.0\n        else:\n            potential_params = (A, V0, r0, a, V_so0)\n            j_plus = l + 0.5\n            j_minus = l - 0.5\n            \n            E_plus = compute_level_energy(potential_params, l, j_plus, nr)\n            E_minus = compute_level_energy(potential_params, l, j_minus, nr)\n            \n            if np.isnan(E_plus) or np.isnan(E_minus):\n                delta = np.nan # Mark as invalid if a state wasn't found\n            else:\n                dE_calc = E_plus - E_minus\n        \n        delta = dE_calc - dE_emp\n        results.append(delta)\n\n    # Format the output as a comma-separated list of floats rounded to 3 decimal places\n    results_formatted = [f\"{val:.3f}\" for val in results]\n    print(f\"[{','.join(results_formatted)}]\")\n\nsolve()\n```", "id": "3584524"}, {"introduction": "核壳层模型是描述原子核结构的主要理论工具，它将复杂的核多体问题简化为在平均场中运动的价核子问题。这项高级实践将指导您完成壳层模型计算的核心步骤：构建多体基矢（斯莱特行列式）并确定其总角动量 $J$ 和宇称 $\\pi$ 等“好”量子数。通过在二次量子化框架下实现角动量算符，您将体验到单粒子量子数如何组合决定整个原子核的性质 [@problem_id:3584469]。", "problem": "实现一个完整的程序，该程序针对有限的原子核壳模型价态组态，为一组指定单粒子轨道中的全同核子构建一个 $m$‑方案斯莱特行列式基，在二次量子化中构建总角动量算符 $J_z$、$J_{+}$、$J_{-}$，使用算符恒等式 $J^2 = J_{-}J_{+} + J_z^2 + J_z$ 组装 $J^2$，对角化 $J^2$ 以提取总角动量 $J$ 值，为得到的良好 $J$ 本征态指定 $J^\\pi$ 标签，并验证多体宇称算符对每个基矢量的作用是一致的。\n\n基本依据和假设：\n\n- 在原子核壳模型（也称为 Nuclear Shell Model）中工作，采用 $j$–$j$ 耦合和 $m$‑方案基。每个单粒子轨道由轨道角动量 $l$ 和单粒子总角动量 $j$ 表征，其磁亚态为 $m \\in \\{-j,-j+1,\\dots,j\\}$。\n- 使用一种同位旋种类的全同核子（例如中子），这固定了总同位旋投影，但在本任务中不需要显式的同位旋代数。\n- 使用二次量子化，其中费米子产生和湮灭算符分别为 $a^\\dagger_{\\alpha m}$ 和 $a_{\\alpha m}$，对应于轨道 $\\alpha$ 和投影 $m$。宇称算符 $P$ 的作用为 $P\\, a^\\dagger_{\\alpha m}\\, P^{-1} = \\eta_\\alpha\\, a^\\dagger_{\\alpha m}$，其中 $\\eta_\\alpha = (-1)^{l_\\alpha}$。\n- 单粒子基中的总角动量算符满足标准角动量代数。特别是，\n  - $J_z = \\sum_{\\alpha m} m\\, a^\\dagger_{\\alpha m} a_{\\alpha m}$，\n  - $J_+ = \\sum_{\\alpha m} \\sqrt{j_\\alpha(j_\\alpha+1) - m(m+1)}\\, a^\\dagger_{\\alpha\\, m+1} a_{\\alpha m}$，\n  - $J_- = (J_+)^\\dagger$，\n  - 以及 $J^2 = J_{-}J_{+} + J_z^2 + J_z$。\n- 在此基中的一个多体斯莱特行列式是宇称算符的本征矢，其本征值为 $\\Pi = \\prod_{\\text{occupied }\\alpha} \\eta_\\alpha = (-1)^{\\sum_{\\text{occupied}} l_\\alpha}$。\n\n程序要求：\n\n- 根据指定的轨道和每个轨道的固定占据数，枚举全同核子的多体 $m$‑方案基，表示为斯莱特行列式，并将其表达为单粒子态上的位串。这些单粒子态在每个轨道内按 $m$ 递增排序，并按轨道指标排序。\n- 在此多体基中构建 $J_+$、$J_-$ 和 $J_z$ 的稠密矩阵表示。程序在将单体算符 $a^\\dagger_i a_j$ 应用于行列式时，必须正确处理费米子符号。然后从 $J_-$、$J_+$ 和 $J_z$ 组装 $J^2$，并对 $J^2$ 进行数值对角化。\n- 通过求解 $J(J+1) = \\lambda$ 得到 $J$ 并四舍五入到最近的半整数，将每个 $J^2$ 的本征值 $\\lambda$ 映射到一个总角动量 $J$。按 $J$ 对本征值进行分组以获得简并度，并指定 $J^\\pi$ 标签，其中 $\\pi$ 是该组态的共同宇称。\n- 通过将 $P$ 显式地应用于每个基矢量 $\\lvert \\Phi_k \\rangle$ 并检查每个基矢量是否满足 $P\\lvert \\Phi_k \\rangle = \\Pi_k \\lvert \\Phi_k \\rangle$（其中 $\\Pi_k = \\prod_{\\text{occupied }\\alpha\\in \\Phi_k} (-1)^{l_\\alpha}$），来验证宇称算符的一致性。\n\n角度单位不适用。不需要物理单位，因为算符采用自然角动量单位，其中 $\\hbar = 1$。\n\n测试套件：\n\n为以下五个测试组态实现并运行程序。每个组态指定了一组单粒子轨道和每个轨道中固定数量的全同核子。对于每个组态，提供了预期的总 $J$ 值集合和预期宇称 $\\pi$ 以供验证。\n\n- 测试 1：一个中子位于 $l = 1, j = 3/2$ 的单个轨道（一个 $p_{3/2}$ 轨道），占据数为 $[1]$。预期 $J$ 值集合为 $\\{3/2\\}$，预期宇称为 $\\pi = -1$。\n- 测试 2：两个中子位于 $l = 1, j = 3/2$ 的单个轨道（一个 $p_{3/2}$ 轨道），占据数为 $[2]$。预期 $J$ 值集合为 $\\{0, 2\\}$，预期宇称为 $\\pi = +1$。\n- 测试 3：一个中子位于 $l = 2, j = 5/2$ 的轨道（一个 $d_{5/2}$ 轨道），另一个中子位于 $l = 1, j = 3/2$ 的轨道（一个 $p_{3/2}$ 轨道），占据数为 $[1, 1]$。预期 $J$ 值集合为 $\\{1, 2, 3, 4\\}$，预期宇称为 $\\pi = -1$。\n- 测试 4：空的价空间（无粒子），在 $l = 1, j = 3/2$ 轨道中的占据数为 $[0]$。预期 $J$ 值集合为 $\\{0\\}$，预期宇称为 $\\pi = +1$。\n- 测试 5：闭合子壳：四个中子完全填充 $l = 1, j = 3/2$ 轨道，占据数为 $[4]$。预期 $J$ 值集合为 $\\{0\\}$，预期宇称为 $\\pi = +1$。\n\n对于测试 1-5，还需检查通过对角化 $J^2$ 得到的每个 $J$ 的简并度是否等于 $2J+1$ 乘以该 $J$ 在组态中由角动量耦合决定的预期多重性：\n- 测试 1：$\\{3/2: 1\\}$，\n- 测试 2：$\\{0: 1,\\; 2: 1\\}$，\n- 测试 3：$\\{1: 1,\\; 2: 1,\\; 3: 1,\\; 4: 1\\}$，\n- 测试 4：$\\{0: 1\\}$，\n- 测试 5：$\\{0: 1\\}$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目对应一个测试用例，是一个布尔值，指示该测试的所有检查是否都通过（正确的 $J$ 值集合、正确的宇称、正确的 $J$ 简并度以及显式宇称作用已验证）。例如：`[True,True,False,True,True]`。", "solution": "我们从标准角动量代数和二次量子化出发，设计一个算法，该算法能够构建 $m$‑方案斯莱特行列式、建立总角动量算符、从 $J^2$ 的谱中恢复总角动量 $J$、指定宇称，并验证宇称算符的作用。\n\n1. 基于核心定义的基的构建：\n   - 单粒子轨道 $\\alpha$ 由轨道角动量 $l_\\alpha$ 和总角动量 $j_\\alpha$ 指定。该轨道中可用的磁量子数为 $m \\in \\{-j_\\alpha, -j_\\alpha + 1, \\dots, j_\\alpha\\}$。\n   - 对于每个轨道固定的占据数 $n_\\alpha$，多体 $m$‑方案基由所有反对称斯莱特行列式组成。这些行列式是通过从每个轨道的 $(2 j_\\alpha + 1)$ 个可用磁亚态中选择 $n_\\alpha$ 个亚态，并将这些选择跨轨道串联起来而形成的。基矢量可以表示为单粒子态有序列表上的位串（按轨道指标和递增的 $m$ 排序），其中 1 表示占据态，0 表示未占据态。\n   - 对于指定的占据数，基的维度是所有轨道 $\\alpha$ 的 $\\binom{2 j_\\alpha + 1}{n_\\alpha}$ 的乘积。\n\n2. 基于基本事实的宇称算符：\n   - 宇称作用于球谐函数时变换为 $P \\, Y_{l m}(\\hat{r}) = (-1)^l Y_{l m}(\\hat{r})$。在 $j$–$j$ 耦合中，创建一个在轨道 $\\alpha$ 中的核子的产生算符在宇称变换下会获得一个相位 $\\eta_\\alpha = (-1)^{l_\\alpha}$：\n     $$\n     P\\, a^\\dagger_{\\alpha m}\\, P^{-1} = \\eta_\\alpha\\, a^\\dagger_{\\alpha m}.\n     $$\n   - 于是，一个多体行列式 $|\\Phi \\rangle = a^\\dagger_{i_1} a^\\dagger_{i_2} \\cdots a^\\dagger_{i_N} |0\\rangle$ 是 $P$ 的本征态，其本征值为\n     $$\n     \\Pi_\\Phi = \\prod_{k=1}^{N} \\eta_{\\alpha(i_k)} = (-1)^{\\sum_{k=1}^{N} l_{\\alpha(i_k)}},\n     $$\n     其中 $\\alpha(i_k)$ 表示单粒子态 $i_k$ 的轨道指标。因此，对于固定的占据数，宇称在 $m$‑方案基中是平凡对角的。将 $P$ 显式地应用于一个基矢量会使该矢量乘以 $\\Pi_\\Phi$。\n\n3. 作为单体算符的总角动量算符：\n   - 二次量子化中的总角动量算符由其单粒子对应部分构建，并对所有粒子求和：\n     $$\n     J_z = \\sum_{\\alpha m} m \\, a^\\dagger_{\\alpha m} a_{\\alpha m},\\quad\n     J_+ = \\sum_{\\alpha m} \\sqrt{j_\\alpha(j_\\alpha + 1) - m(m+1)} \\, a^\\dagger_{\\alpha, m+1} a_{\\alpha m},\\quad\n     J_- = (J_+)^\\dagger.\n     $$\n   - 这些算符满足代数关系 $[J_+, J_-] = 2 J_z$, $[J_z, J_\\pm] = \\pm J_\\pm$。\n   - 卡西米尔算符为\n     $$\n     J^2 = J_- J_+ + J_z^2 + J_z,\n     $$\n     这源于标准的角动量恒等式。这种形式在计算上特别有用，因为它用 $J_\\pm$ 和 $J_z$ 来表示 $J^2$。\n\n4. 多体基中的矩阵元：\n   - 算符 $J_z$ 在 $m$‑方案基中是对角的。对于一个在单粒子态 $i$ 上具有占据数 $\\{n_i\\}$ 和投影 $m_i$ 的行列式，我们有\n     $$\n     \\langle \\Phi | J_z | \\Phi \\rangle = \\sum_i n_i m_i.\n     $$\n   - 算符 $J_+$ 是单体项 $a^\\dagger_{q} a_p$ 的和，其系数由角动量代数确定。它在行列式之间的矩阵元仅在末态行列式 $|\\Phi'\\rangle$ 与初态行列式 $|\\Phi\\rangle$ 相差一个粒子从态 $p$ 移动到态 $q$ 时（其中 $q$ 与 $p$ 属于同一轨道且 $m_q = m_p + 1$），并且在 $|\\Phi\\rangle$ 中 $p$ 被占据而 $q$ 未被占据时才非零。\n   - 该矩阵元的大小是单粒子因子\n     $$\n     c_{p \\to q} = \\sqrt{j_\\alpha(j_\\alpha + 1) - m_p(m_p + 1)},\n     $$\n     其中 $\\alpha$ 是 $p$ 和 $q$ 的轨道。\n   - 费米子符号源于反对易关系。在二次量子化中，$a_p$ 作用于一个行列式会产生一个因子 $(-1)^{N_{\\text{occ}}(", "answer": "```python\nimport numpy as np\nfrom itertools import combinations, product\n\n# We work in units with ħ = 1.\n\ndef orbit(l, j):\n    # Build an orbit descriptor\n    # m values in ascending order\n    two_j = int(round(2*j))\n    m_vals = [(-j + k) for k in range(two_j + 1)]\n    return {\n        'l': l,\n        'j': j,\n        'm_list': m_vals,\n        'eta': (-1) ** l\n    }\n\ndef build_single_particle_space(orbits):\n    # Flatten single-particle states with indices across all orbits\n    states = []\n    for oi, o in enumerate(orbits):\n        for m in o['m_list']:\n            states.append({\n                'orbit_index': oi,\n                'j': o['j'],\n                'l': o['l'],\n                'm': m,\n                'eta': o['eta'],\n            })\n    return states\n\ndef enumerate_basis(orbits, occupancies):\n    # occupancies is list n_i for each orbit\n    # For each orbit choose n_i indices from its m_list; combine across orbits\n    # Build bitmask over full single-particle state list ordered by orbit then m.\n    # Return list of bitmasks and mapping to index\n    sp_states = build_single_particle_space(orbits)\n    # Precompute offsets per orbit in the flattened list\n    offsets = []\n    offset = 0\n    for o in orbits:\n        offsets.append(offset)\n        offset += len(o['m_list'])\n    # For each orbit, list of local indices 0..g-1\n    local_choices = []\n    for o, n in zip(orbits, occupancies):\n        g = len(o['m_list'])\n        # handle n == 0 gracefully\n        if n  0 or n  g:\n            raise ValueError(\"Invalid occupancy\")\n        local_choices.append(list(combinations(range(g), n)))\n    basis_bitmasks = []\n    for choices in product(*local_choices):\n        # choices is a tuple of tuples of local indices per orbit\n        bitmask = 0\n        for oi, loc_idx_tuple in enumerate(choices):\n            base = offsets[oi]\n            for li in loc_idx_tuple:\n                idx = base + li\n                bitmask |= (1  idx)\n        basis_bitmasks.append(bitmask)\n    # Map bitmask to basis index\n    index_of = {bm: i for i, bm in enumerate(basis_bitmasks)}\n    return basis_bitmasks, index_of, sp_states\n\ndef popcount(x):\n    return x.bit_count()\n\ndef occ_at(bitmask, idx):\n    return (bitmask  idx)  1\n\ndef set_bit(bitmask, idx, val):\n    if val:\n        return bitmask | (1  idx)\n    else:\n        return bitmask  ~(1  idx)\n\ndef fermion_sign_for_annihilation(bitmask, idx):\n    # Sign for a_idx acting on determinant with bitmask: (-1)^{# occupied below idx}\n    below_mask = (1  idx) - 1\n    n_below = popcount(bitmask  below_mask)\n    return -1 if (n_below % 2 == 1) else 1\n\ndef fermion_sign_for_creation(bitmask, idx):\n    # Sign for a^\\dagger_idx acting on determinant with bitmask: (-1)^{# occupied below idx}\n    below_mask = (1  idx) - 1\n    n_below = popcount(bitmask  below_mask)\n    return -1 if (n_below % 2 == 1) else 1\n\ndef build_J_operators(orbits, occupancies):\n    # Build many-body J_plus, J_minus, Jz matrices in the basis\n    basis_bitmasks, index_of, sp_states = enumerate_basis(orbits, occupancies)\n    dim = len(basis_bitmasks)\n    S = len(sp_states)\n    # Precompute, for each sp_state index p, the index q for m+1 within same orbit or None\n    # We rely on the ordering: within each orbit, m increases by 1 per next state\n    orbit_offsets = []\n    off = 0\n    for o in orbits:\n        orbit_offsets.append(off)\n        off += len(o['m_list'])\n    idx_to_next_m = [None] * S\n    coeff_for_raise = [0.0] * S\n    for oi, o in enumerate(orbits):\n        j = o['j']\n        base = orbit_offsets[oi]\n        m_list = o['m_list']\n        for local_idx, m in enumerate(m_list):\n            global_idx = base + local_idx\n            if local_idx  len(m_list) - 1:\n                next_global_idx = base + (local_idx + 1)\n                idx_to_next_m[global_idx] = next_global_idx\n            else:\n                idx_to_next_m[global_idx] = None\n            # Coefficient sqrt(j(j+1)-m(m+1)) for raising from m to m+1\n            coeff = np.sqrt(j * (j + 1.0) - m * (m + 1.0)) if (local_idx  len(m_list) - 1) else 0.0\n            coeff_for_raise[global_idx] = coeff\n    # Build J_plus\n    Jplus = np.zeros((dim, dim), dtype=np.float64)\n    # Build Jz diagonal vector\n    Jz_diag = np.zeros(dim, dtype=np.float64)\n    # Also build parity diag for explicit application\n    parity_diag = np.zeros(dim, dtype=np.int64)\n    # For each basis determinant\n    for col_idx, bm in enumerate(basis_bitmasks):\n        # Jz diagonal entry\n        M = 0.0\n        parity_ev = 1\n        # Iterate over all occupied single-particle indices\n        x = bm\n        idx = 0\n        while x:\n            if x  1:\n                st = sp_states[idx]\n                M += st['m']\n                parity_ev *= st['eta']\n            x = 1\n            idx += 1\n        Jz_diag[col_idx] = M\n        parity_diag[col_idx] = parity_ev\n        # J_plus action: sum over all p with occupied and q=p+1 unoccupied within same orbit\n        for p in range(S):\n            if occ_at(bm, p) == 1:\n                q = idx_to_next_m[p]\n                if q is not None and occ_at(bm, q) == 0:\n                    coeff = coeff_for_raise[p]\n                    if coeff == 0.0:\n                        continue\n                    # Apply a_q^\\dagger a_p with fermion signs\n                    # First annihilate at p\n                    sign_a = fermion_sign_for_annihilation(bm, p)\n                    bm_after_ann = set_bit(bm, p, 0)\n                    # Then create at q\n                    sign_c = fermion_sign_for_creation(bm_after_ann, q)\n                    bm_final = set_bit(bm_after_ann, q, 1)\n                    row_idx = index_of[bm_final]\n                    amp = coeff * sign_a * sign_c\n                    Jplus[row_idx, col_idx] += amp\n    # J_minus is transpose of J_plus (real matrix)\n    Jminus = Jplus.T.copy()\n    # Build J2 = Jminus*Jplus + Jz^2 + Jz\n    # Represent Jz as diagonal; perform multiplications accordingly\n    Jz_sq = (Jz_diag ** 2)\n    J2 = Jminus @ Jplus\n    J2 += np.diag(Jz_sq + Jz_diag)\n    return Jplus, Jminus, Jz_diag, J2, parity_diag, basis_bitmasks, sp_states\n\ndef extract_J_spectrum(J2, tol=1e-8):\n    # Diagonalize J2 and map eigenvalues to J\n    evals, evecs = np.linalg.eigh(J2)\n    # Numerical clean-up: clip small negatives to zero\n    evals = np.where(evals  0.0, np.maximum(evals, 0.0), evals)\n    # Map to J via quadratic formula\n    Js = []\n    for lam in evals:\n        J_est = (-1.0 + np.sqrt(1.0 + 4.0 * lam)) / 2.0\n        # Round to nearest half-integer\n        J_round = np.round(2.0 * J_est) / 2.0\n        # Validate\n        if abs(J_round * (J_round + 1.0) - lam)  1e-6:\n            # Try to force to nearest allowed by recomputation\n            lam_round = J_round * (J_round + 1.0)\n            if abs(lam_round - lam)  1e-4:\n                # As a fallback, keep J_est rounded\n                pass\n        Js.append(J_round)\n    Js = np.array(Js)\n    # Count degeneracies by grouping Js\n    unique_Js = []\n    degeneracies = []\n    # Sort Js to group\n    order = np.argsort(Js)\n    Js_sorted = Js[order]\n    i = 0\n    while i  len(Js_sorted):\n        J0 = Js_sorted[i]\n        cnt = 1\n        i += 1\n        while i  len(Js_sorted) and abs(Js_sorted[i] - J0)  tol:\n            cnt += 1\n            i += 1\n        unique_Js.append(J0)\n        degeneracies.append(cnt)\n    return np.array(unique_Js), np.array(degeneracies), evals, evecs\n\ndef parity_from_config(orbits, occupancies):\n    # Global parity for fixed occupancy configuration\n    parity = 1\n    for o, n in zip(orbits, occupancies):\n        parity *= (o['eta'] ** n)\n    return parity\n\ndef verify_parity_application(parity_diag):\n    # Check that P|basis_k = parity_diag[k] * |basis_k holds exactly for diagonal parity operator.\n    # Since P is diagonal with parity_diag entries, this is tautologically true, but we still check numerical consistency.\n    # We verify that all entries in parity_diag are either +1 or -1 and square to 1.\n    unique_vals = set(int(v) for v in parity_diag.tolist())\n    if not unique_vals.issubset({-1, 1}):\n        return False\n    return True\n\ndef run_test(orbits, occupancies, expected_Js, expected_parity, expected_multiplicities):\n    Jplus, Jminus, Jz_diag, J2, parity_diag, basis_bitmasks, sp_states = build_J_operators(orbits, occupancies)\n    unique_Js, degeneracies, evals, evecs = extract_J_spectrum(J2)\n    # Sort expected Js\n    exp_Js_sorted = sorted(expected_Js)\n    # Compare J sets (within tolerance)\n    comp_Js = np.allclose(sorted(unique_Js.tolist()), exp_Js_sorted, atol=1e-8, rtol=0.0)\n    # Compare degeneracies to expected multiplicities * (2J+1)\n    # Build expected degeneracy list matching unique_Js order\n    J_to_deg_exp = {J: int((2*J + 1) * expected_multiplicities[J]) for J in expected_multiplicities}\n    deg_ok = True\n    if len(unique_Js) != len(exp_Js_sorted):\n        deg_ok = False\n    else:\n        for J, deg in zip(unique_Js, degeneracies):\n            expected_deg = J_to_deg_exp.get(J, None)\n            if expected_deg is None or int(deg) != expected_deg:\n                deg_ok = False\n                break\n    # Parity checks\n    glob_parity = parity_from_config(orbits, occupancies)\n    parity_ok = (glob_parity == expected_parity)\n    parity_application_ok = verify_parity_application(parity_diag)\n    return bool(comp_Js and deg_ok and parity_ok and parity_application_ok)\n\ndef solve():\n    results = []\n\n    # Test 1: One neutron in p3/2 (l=1, j=1.5), occupancy [1]\n    orbits1 = [orbit(l=1, j=1.5)]\n    occ1 = [1]\n    expected_Js1 = [1.5]\n    expected_parity1 = -1\n    expected_mult1 = {1.5: 1}\n    results.append(run_test(orbits1, occ1, expected_Js1, expected_parity1, expected_mult1))\n\n    # Test 2: Two neutrons in p3/2, occupancy [2]\n    orbits2 = [orbit(l=1, j=1.5)]\n    occ2 = [2]\n    expected_Js2 = [0.0, 2.0]\n    expected_parity2 = +1\n    expected_mult2 = {0.0: 1, 2.0: 1}\n    results.append(run_test(orbits2, occ2, expected_Js2, expected_parity2, expected_mult2))\n\n    # Test 3: One neutron in d5/2 and one in p3/2, occupancy [1,1]\n    orbits3 = [orbit(l=2, j=2.5), orbit(l=1, j=1.5)]\n    occ3 = [1, 1]\n    expected_Js3 = [1.0, 2.0, 3.0, 4.0]\n    expected_parity3 = -1\n    expected_mult3 = {1.0: 1, 2.0: 1, 3.0: 1, 4.0: 1}\n    results.append(run_test(orbits3, occ3, expected_Js3, expected_parity3, expected_mult3))\n\n    # Test 4: Empty valence space in p3/2, occupancy [0]\n    orbits4 = [orbit(l=1, j=1.5)]\n    occ4 = [0]\n    expected_Js4 = [0.0]\n    expected_parity4 = +1\n    expected_mult4 = {0.0: 1}\n    results.append(run_test(orbits4, occ4, expected_Js4, expected_parity4, expected_mult4))\n\n    # Test 5: Closed subshell p3/2 with 4 neutrons, occupancy [4]\n    orbits5 = [orbit(l=1, j=1.5)]\n    occ5 = [4]\n    expected_Js5 = [0.0]\n    expected_parity5 = +1\n    expected_mult5 = {0.0: 1}\n    results.append(run_test(orbits5, occ5, expected_Js5, expected_parity5, expected_mult5))\n\n    print(f\"[{','.join('True' if r else 'False' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3584469"}]}