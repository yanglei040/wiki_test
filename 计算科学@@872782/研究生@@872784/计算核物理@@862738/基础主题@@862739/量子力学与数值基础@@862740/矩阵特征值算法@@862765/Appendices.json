{"hands_on_practices": [{"introduction": "在启动计算成本高昂的特征值求解过程之前，预先估计其可能的位置是极其有价值的。盖尔圆定理（Gershgorin circle theorem）为此提供了一个简单而强大的工具。本练习将指导您如何应用该定理分析一个模型哈密顿量，以确定谱的分布区域，并为诸如位移反演（shift-invert）等高级算法选择一个安全有效的位移参数 $\\sigma$。[@problem_id:3568887]", "problem": "一个用于截断组态空间的原子核壳模型哈密顿量，在单粒子基中由实对称矩阵 $H \\in \\mathbb{R}^{6 \\times 6}$（在底层的复数表示中为厄米矩阵）表示，其矩阵元以兆电子伏特（MeV）为单位给出：\n$$\nH \\;=\\; \\begin{pmatrix}\n-8.1  -0.25  0.20  0  0.05  0 \\\\\n-0.25  -7.4  -0.15  0  0  0 \\\\\n0.20  -0.15  -7.9  0.05  0.10  0 \\\\\n0  0  0.05  4.3  -0.30  -0.10 \\\\\n0.05  0  0.10  -0.30  5.0  -0.20 \\\\\n0  0  0  -0.10  -0.20  6.2\n\\end{pmatrix}.\n$$\n使用数值线性代数的第一性原理工具，计算 $H$ 特征值的盖尔什戈林界 (Gershgorin bounds)，并构成所得一维盖尔什戈林区间的并集（该矩阵是厄米矩阵，因此谱是实的）。然后，为了执行一个保证安全（可逆分解）的位移反演计算，同时仍以与激发态相关的正能区为目标，请选择一个正位移 $\\sigma$ 作为相邻正盖尔什戈林区间之间最大有界开间隙的中点。以兆电子伏特（MeV）为单位给出此 $\\sigma$ 值，并四舍五入到四位有效数字。最终答案必须是一个实数。", "solution": "该问题要求为位移反演特征值算法计算一个合适的位移参数 $\\sigma$。这涉及到使用盖尔什戈林圆盘定理 (Gershgorin's circle theorem) 来定位给定的哈密顿矩阵 $H$ 的特征值，在谱的正半部分中识别一个间隙，并找到该间隙的中点。\n\n给定的哈密顿矩阵为：\n$$\nH \\;=\\; \\begin{pmatrix}\n-8.1  -0.25  0.20  0  0.05  0 \\\\\n-0.25  -7.4  -0.15  0  0  0 \\\\\n0.20  -0.15  -7.9  0.05  0.10  0 \\\\\n0  0  0.05  4.3  -0.30  -0.10 \\\\\n0.05  0  0.10  -0.30  5.0  -0.20 \\\\\n0  0  0  -0.10  -0.20  6.2\n\\end{pmatrix}\n$$\n矩阵元以兆电子伏特（MeV）为单位。由于 $H$ 是一个实对称矩阵，其特征值是实数。盖尔什戈林圆盘定理指出，一个矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 的每个特征值都位于复平面内至少一个盖尔什戈林圆盘 $D(A_{ii}, R_i)$ 之中，其中 $A_{ii}$ 是第 $i$ 个对角元，而 $R_i = \\sum_{j \\neq i} |A_{ij}|$ 是第 $i$ 行非对角元绝对值之和。对于像 $H$ 这样的实对称矩阵，特征值是实的，因此盖尔什戈林圆盘变成了实轴上的闭区间 $G_i = [H_{ii} - R_i, H_{ii} + R_i]$。\n\n首先，我们计算每一行 $i = 1, \\dots, 6$ 的半径 $R_i$：\n$R_1 = |-0.25| + |0.20| + |0| + |0.05| + |0| = 0.25 + 0.20 + 0 + 0.05 + 0 = 0.50$\n$R_2 = |-0.25| + |-0.15| + |0| + |0| + |0| = 0.25 + 0.15 + 0 + 0 + 0 = 0.40$\n$R_3 = |0.20| + |-0.15| + |0.05| + |0.10| + |0| = 0.20 + 0.15 + 0.05 + 0.10 + 0 = 0.50$\n$R_4 = |0| + |0| + |0.05| + |-0.30| + |-0.10| = 0 + 0 + 0.05 + 0.30 + 0.10 = 0.45$\n$R_5 = |0.05| + |0| + |0.10| + |-0.30| + |-0.20| = 0.05 + 0 + 0.10 + 0.30 + 0.20 = 0.65$\n$R_6 = |0| + |0| + |0| + |-0.10| + |-0.20| = 0 + 0 + 0 + 0.10 + 0.20 = 0.30$\n\n接下来，我们确定盖尔什戈林区间 $G_i = [H_{ii} - R_i, H_{ii} + R_i]$：\n$G_1 = [-8.1 - 0.50, -8.1 + 0.50] = [-8.60, -7.60]$\n$G_2 = [-7.4 - 0.40, -7.4 + 0.40] = [-7.80, -7.00]$\n$G_3 = [-7.9 - 0.50, -7.9 + 0.50] = [-8.40, -7.40]$\n$G_4 = [4.3 - 0.45, 4.3 + 0.45] = [3.85, 4.75]$\n$G_5 = [5.0 - 0.65, 5.0 + 0.65] = [4.35, 5.65]$\n$G_6 = [6.2 - 0.30, 6.2 + 0.30] = [5.90, 6.50]$\n\n$H$ 的全谱，记为 $\\Lambda(H)$，包含在这些区间的并集中：$\\Lambda(H) \\subseteq \\bigcup_{i=1}^6 G_i$。问题要求关注正能区，这对应于区间 $G_4$、$G_5$ 和 $G_6$。我们构成这些正区间的并集。\n\n区间 $G_4 = [3.85, 4.75]$ 和 $G_5 = [4.35, 5.65]$ 有重叠，因为 $G_5$ 的起点（$4.35$）小于 $G_4$ 的终点（$4.75$）。它们的并集是：\n$G_4 \\cup G_5 = [\\min(3.85, 4.35), \\max(4.75, 5.65)] = [3.85, 5.65]$。\n\n第三个正区间是 $G_6 = [5.90, 6.50]$。这个区间与并集 $G_4 \\cup G_5$ 不相交，因为 $G_4 \\cup G_5$ 的上界（$5.65$）小于 $G_6$ 的下界（$5.90$）。\n\n因此，根据盖尔什戈林定理，包含正特征值的区域是两个不相交集合的并集：\n$[3.85, 5.65] \\cup [5.90, 6.50]$。\n\n问题要求找到“相邻正盖尔什戈林区间之间最大有界开间隙”的中点。在本例中，只有一个这样的间隙。这个间隙是我们找到的两个不相交集合之间的开区间：\n间隙 $= (5.65, 5.90)$。\n\n位移 $\\sigma$ 定义为该间隙的中点。\n$$\n\\sigma = \\frac{5.65 + 5.90}{2} = \\frac{11.55}{2} = 5.775\n$$\n$\\sigma$ 的这个值位于间隙内，确保了 $\\sigma$ 不是 $H$ 的特征值。因此，矩阵 $(H - \\sigma I)$ 是可逆的，使得位移反演过程是良定义的。\n\n问题要求答案四舍五入到四位有效数字。数字 $5.775$ 已经恰好有四位有效数字（$5$、$7$、$7$、$5$）。因此，无需进一步四舍五入。位移的值是 $5.775$ MeV。", "answer": "$$\\boxed{5.775}$$", "id": "3568887"}, {"introduction": "对于核物理中常见的大型稀疏矩阵，直接对角化是不可行的。Lanczos算法是一种基石性的迭代方法，它在Krylov子空间内构建一个哈密顿量的小型三对角表示。在本练习中，您将亲手实现Lanczos算法，以求解一个模型哈密顿量的基态能量（最小特征值），并学习如何高效地估计计算结果的精度。[@problem_id:3568855]", "problem": "考虑一个一维单核子哈密顿量的实对称矩阵表示，该表示是通过在有界域上对不含时薛定谔算符进行有限差分离散化得到的，并采用狄利克雷边界条件。设哈密顿矩阵定义如下。对于给定的内部格点数 $N \\in \\mathbb{N}$ 和半域长度 $L \\in \\mathbb{R}_{0}$，在内部格点 $x_i = -L + i h$（其中 $i \\in \\{1,2,\\dots,N\\}$）上定义一个间距为 $h = \\dfrac{2L}{N+1}$ 的均匀网格。动能算符通过标准的二阶中心差分进行离散化，生成一个三对角矩阵 $T \\in \\mathbb{R}^{N \\times N}$，其对角元为 $T_{ii} = \\dfrac{2}{h^2}$，第一副对角元为 $T_{i,i+1} = T_{i+1,i} = -\\dfrac{1}{h^2}$（对所有有效索引）。施加一个深度为 $V_0 \\in \\mathbb{R}_{\\ge 0}$、半宽为 $a \\in \\mathbb{R}_{\\ge 0}$ 的方势阱，其定义为：若 $|x| \\le a$，则 $V(x) = -V_0$，否则 $V(x) = 0$。设 $D \\in \\mathbb{R}^{N \\times N}$ 为对角矩阵，其对角元为 $D_{ii} = V(x_i)$。哈密顿矩阵为 $H = T + D \\in \\mathbb{R}^{N \\times N}$。\n\n给定一个起始向量 $b \\in \\mathbb{R}^N$ 且 $\\|b\\|_2 = 1$，其$m$维Krylov子空间定义为 $\\mathcal{K}_m(H,b) = \\operatorname{span}\\{b, Hb, H^2 b, \\dots, H^{m-1} b\\}$。使用从 $b$ 开始的Lanczos构造法，得到与 $\\mathcal{K}_m(H,b)$ 的标准正交基相关的三对角Rayleigh-Ritz矩阵 $T_m \\in \\mathbb{R}^{m \\times m}$。Ritz值是 $T_m$ 的特征值。取最小的Ritz值作为 $H$ 的最小特征值的近似值。设 $\\theta_m \\in \\mathbb{R}$ 表示 $T_m$ 的最小特征值，并设 $y_m \\in \\mathbb{R}^m$ 表示其对应的单位范数特征向量。通过Lanczos基将 $y_m$ 投影回全空间，定义Ritz向量 $v_m \\in \\mathbb{R}^N$。此Ritz对的残差范数为 $\\|H v_m - \\theta_m v_m\\|_2$，它可作为最低特征值近似的后验精度估计。不需要物理单位；所有数值结果均报告为无量纲量。\n\n任务：实现一个程序，对下面指定的每个测试用例，从 $(N,L,V_0,a)$ 构造 $H$，将 $b$ 设置为 $\\mathbb{R}^N$ 中归一化的全1向量，构建 $m$ 步Lanczos三对角矩阵 $T_m$，计算最小Ritz值 $\\theta_m$，并通过残差范数 $\\|H v_m - \\theta_m v_m\\|_2$ 估计其精度。您必须完全按照定义计算残差范数，或者使用一个对于以 $b$ 初始化的Lanczos三对角化有效的等价恒等式。对所有向量范数，使用欧几里得范数。\n\n您的实现必须对给定的大小具有通用性和数值稳定性。必须按此确切顺序执行以下三个测试用例：\n\n- 用例1：$N = 40$, $L = 10$, $V_0 = 5$, $a = 2$, $m = 8$。\n- 用例2：$N = 80$, $L = 8$, $V_0 = 10$, $a = 0.5$, $m = 20$。\n- 用例3：$N = 12$, $L = 1$, $V_0 = 0$, $a = 0$, $m = 12$。\n\n对于所有用例，选择 $b$ 为归一化向量，其分量为 $b_i = 1$（$i \\in \\{1,2,\\dots,N\\}$）。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个数对列表，每个测试用例对应一个数对，并按给定顺序排列。每个数对必须是 $[\\theta_m,\\rho_m]$ 的形式，其中 $\\theta_m$ 是最小Ritz值，$\\rho_m = \\|H v_m - \\theta_m v_m\\|_2$ 是残差范数。所有浮点数必须以科学记数法打印，并保留恰好 $10$ 位有效数字，输出中不得包含任何空格。例如，包含两个用例的输出可能看起来像 $[[1.234567890e+00,9.876543210e-05],[\\dots,\\dots]]$，但需使用此问题的相应值。程序不得读取任何输入，并且必须只打印一行。\n\n您的答案必须是一个完整、可运行的程序。", "solution": "该问题要求确定一个离散化的一维单核子哈密顿量的最低近似特征值（一个Ritz值）及其相关精度。此分析使用Lanczos算法执行，这是一种著名的Krylov子空间方法，非常适合用于寻找大型对称矩阵的极端特征值。\n\n首先，我们形式化地构建哈密顿矩阵 $H$。该物理系统由不含时薛定谔方程 $\\hat{H}\\psi = E\\psi$ 建模。对于一个质量为 $M$ 的核子在势 $V(x)$ 中运动，哈密顿算符为 $\\hat{H} = -\\dfrac{\\hbar^2}{2M} \\dfrac{d^2}{dx^2} + V(x)$。通过采用一个单位制，使得常数项 $\\dfrac{\\hbar^2}{2M}$ 等于 $1$，该算符简化为 $\\hat{H} = -\\dfrac{d^2}{dx^2} + V(x)$。我们在有界域 $[-L, L]$ 上的均匀网格上离散化此算符，该网格有 $N$ 个内部点，并服从狄利克雷边界条件 $\\psi(-L) = \\psi(L) = 0$。\n\n网格间距定义为 $h = \\dfrac{2L}{N+1}$，内部格点位于 $x_i = -L + i h$，其中 $i \\in \\{1, 2, \\dots, N\\}$。二阶导数算符使用二阶中心差分格式进行近似：$\\dfrac{d^2\\psi}{dx^2}\\bigg|_{x_i} \\approx \\dfrac{\\psi(x_{i+1}) - 2\\psi(x_i) + \\psi(x_{i-1})}{h^2}$。这种离散化方法导出了动能算符的矩阵表示 $T \\in \\mathbb{R}^{N \\times N}$，其元素为：\n$$\nT_{ij} = \\begin{cases}\n    \\dfrac{2}{h^2}   \\text{若 } i = j \\\\\n    -\\dfrac{1}{h^2}  \\text{若 } |i - j| = 1 \\\\\n    0              \\text{其他情况}\n\\end{cases}\n$$\n势能算符由一个对角矩阵 $D \\in \\mathbb{R}^{N \\times N}$ 表示，其中对角元由势函数在格点处的值给出，$D_{ii} = V(x_i)$。指定的势是深度为 $V_0$、半宽为 $a$ 的方势阱：\n$$\nV(x_i) = \\begin{cases}\n    -V_0  \\text{若 } |x_i| \\le a \\\\\n    0       \\text{其他情况}\n\\end{cases}\n$$\n总的离散哈密顿矩阵是动能和势能矩阵之和，得到实对称矩阵 $H = T + D \\in \\mathbb{R}^{N \\times N}$。\n\n接下来，我们采用Lanczos算法来近似 $H$ 的特征值。该算法为Krylov子空间 $\\mathcal{K}_m(H, b) = \\operatorname{span}\\{b, Hb, \\dots, H^{m-1}b\\}$ 构建一个标准正交基，其中 $b$ 是给定的起始向量。在此过程中，它生成一系列标准正交向量 $\\{q_j\\}_{j=1}^m$ 和一个实对称三对角矩阵 $T_m \\in \\mathbb{R}^{m \\times m}$。过程如下：\n初始化：令 $q_0 = 0 \\in \\mathbb{R}^N$，$\\beta_0 = 0$，并将起始向量 $b$ 归一化以得到 $q_1 = b / \\|b\\|_2$。\n对于 $j=1, 2, \\dots, m$：\n1. 计算矩阵-向量乘积 $w_j = H q_j$。\n2. 计算 $T_m$ 的对角元：$\\alpha_j = q_j^T w_j$。\n3. 计算未归一化的下一个向量：$\\tilde{w}_j = w_j - \\alpha_j q_j - \\beta_{j-1} q_{j-1}$。此步骤确保 $\\tilde{w}_j$ 与 $q_j$ 和 $q_{j-1}$ 正交。由于 $H$ 的对称性，三项递推关系保证了与所有先前的基向量 $q_k$（$kj-1$）的正交性，只要使用精确算术。\n4. 计算 $T_m$ 的副对角元：$\\beta_j = \\|\\tilde{w}_j\\|_2$。\n5. 如果 $\\beta_j=0$，则算法终止（这是一个“幸运的”分解）。否则，将下一个基向量归一化：$q_{j+1} = \\tilde{w}_j / \\beta_j$。\n\n在 $m$ 步之后，我们得到一个三对角矩阵 $T_m$，其对角元为 $\\{\\alpha_j\\}_{j=1}^m$，副对角元为 $\\{\\beta_j\\}_{j=1}^{m-1}$。$T_m$ 的特征值被称为Ritz值，它们是原矩阵 $H$ 的特征值的近似。我们对 $T_m$ 进行对角化，并选择其最小的特征值 $\\theta_m$ 作为 $H$ 基态能量的近似值。$T_m$ 对应的特征向量 $y_m$ 被用来构造Ritz向量 $v_m = Q_m y_m$，其中 $Q_m$ 是以 $\\{q_j\\}$ 为列的矩阵。\n\n残差范数 $\\|H v_m - \\theta_m v_m\\|_2$ 是衡量Ritz对 $(\\theta_m, v_m)$ 精度的标准度量。对于Lanczos算法，这个范数可以被高效地计算，而无需显式构造 $v_m$。它等于 $|\\beta_m y_{m,m}|$，其中 $y_{m,m}$ 是 $T_m$ 的特征向量 $y_m$ 的最后一个分量，而 $\\beta_m$ 是在第 $m$ 步生成的最后一个 $\\beta$ 值。这种高效的计算方法对于评估收敛性至关重要。\n\n我们实现一个Python程序来执行这些步骤，使用NumPy进行向量和矩阵操作，使用`scipy.linalg.eigh_tridiagonal`来高效求解三对角特征问题。该程序将遍历所有给定的测试用例，并以指定的科学记数法格式输出结果对 $[\\theta_m, \\rho_m]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef compute_ritz_pair(N, L, V0, a, m):\n    \"\"\"\n    Constructs the Hamiltonian, runs the Lanczos algorithm, and computes the\n    lowest Ritz value and its residual norm.\n    \"\"\"\n    # Step 1: Construct the Hamiltonian matrix H\n    h = (2.0 * L) / (N + 1.0)\n    x = np.array([-L + (i + 1.0) * h for i in range(N)])\n\n    # Kinetic energy matrix T\n    diag_T = np.full(N, 2.0 / h**2)\n    off_diag_T = np.full(N - 1, -1.0 / h**2)\n    T = np.diag(diag_T) + np.diag(off_diag_T, k=1) + np.diag(off_diag_T, k=-1)\n\n    # Potential energy matrix D\n    V_values = -V0 * (np.abs(x) = a)\n    D = np.diag(V_values)\n\n    H = T + D\n\n    # Step 2: Initialize Lanczos algorithm\n    b = np.ones(N)\n    q = b / np.linalg.norm(b)\n    q_prev = np.zeros(N)\n    beta = 0.0\n\n    alphas = []\n    betas_off_diag = []\n\n    # Step 3: Perform m iterations of Lanczos algorithm\n    for j in range(m):\n        w = H @ q\n        alpha = np.dot(w, q)\n        alphas.append(alpha)\n\n        # The three-term recurrence ensures orthogonality\n        w_hat = w - alpha * q - beta * q_prev\n        beta = np.linalg.norm(w_hat)\n\n        q_prev = q\n        # Handle breakdown (beta is numerically zero)\n        if beta > 1e-15:\n            q = w_hat / beta\n        else:\n            # If breakdown occurs, subsequent beta values would be zero.\n            # beta_m will be this zero value.\n            break\n\n        if j  m - 1:\n            betas_off_diag.append(beta)\n    \n    # This is beta_m needed for the residual norm calculation\n    beta_m = beta\n    \n    # If the loop broke early due to lucky breakdown, right-pad alpha and beta lists\n    # to form a matrix of size j+1. The final m in this case is effectively j+1.\n    current_m = len(alphas)\n    if current_m  m:\n        # The remaining T_m entries are effectively undefined, but we need\n        # a matrix of size 'current_m'\n        pass\n    \n    # Step 4: Solve the tridiagonal eigenproblem for T_m\n    if not betas_off_diag: # handles m=1 case\n        eigvals = np.array(alphas)\n        eigvecs = np.array([[1.0]])\n    else:\n        eigvals, eigvecs = eigh_tridiagonal(np.array(alphas), np.array(betas_off_diag))\n    \n    # Step 5: Identify the smallest Ritz value and its eigenvector\n    min_eig_idx = np.argmin(eigvals)\n    theta_m = eigvals[min_eig_idx]\n    y_m = eigvecs[:, min_eig_idx]\n    \n    # Step 6: Calculate the residual norm\n    # The last component of the eigenvector y_m of the matrix T of size current_m\n    y_m_last = y_m[-1] if current_m > 0 else 0.0\n    rho_m = np.abs(beta_m * y_m_last)\n\n    return theta_m, rho_m\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, V0, a, m)\n        (40, 10.0, 5.0, 2.0, 8),\n        (80, 8.0, 10.0, 0.5, 20),\n        (12, 1.0, 0.0, 0.0, 12),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, V0, a, m = case\n        theta_m, rho_m = compute_ritz_pair(N, L, V0, a, m)\n        results.append([theta_m, rho_m])\n\n    # Final print statement in the exact required format.\n    results_str = [f\"[{val[0]:.10e},{val[1]:.10e}]\" for val in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3568855"}, {"introduction": "特征值通常代表能量等物理量，理解这些量如何随模型参数的变化而改变至关重要。本练习将介绍著名的Hellmann-Feynman定理，它为计算特征值对模型参数的导数提供了一种优雅的方法。您将推导该结论，并应用它来计算基态能量的敏感性，同时将该解析结果与数值有限差分近似进行比较。[@problem_id:3568968]", "problem": "给定一个实对称矩阵族，该矩阵族在有限区间上以狄利克雷边界条件近似一个一维薛定谔哈密顿量。该哈密顿量通过一个 Woods–Saxon 势平滑地依赖于一个标量参数 $\\alpha$。你的任务是仅从特征值问题和归一化条件出发，使用瑞利商微分法推导最小特征值关于 $\\alpha$ 的变化率表达式，然后实现该解析导数，并将其与通过仅使用矩阵-向量乘积的迭代特征求解器计算出的有限差分估计值进行比较。\n\n考虑以下构造。设 $N$ 为内部网格点的数量，空间域为 $[-L,L]$，其中有 $N$ 个等距的内部点，并在端点处施加齐次狄利克雷边界条件。设 $\\Delta x = \\dfrac{2L}{N+1}$，网格点为 $x_i = -L + i \\,\\Delta x$，$i=1,2,\\dots,N$。定义有限差分动能矩阵 $T \\in \\mathbb{R}^{N \\times N}$，它是对 $-\\dfrac{d^2}{dx^2}$ 的标准二阶中心差分近似，\n$$\nT = \\frac{1}{\\Delta x^2}\\,\\mathrm{tridiag}(-1,\\,2,\\,-1),\n$$\n其中 $\\mathrm{tridiag}(-1,2,-1)$ 表示主对角线元素为 $2$，第一条次对角线和超对角线元素均为 $-1$ 的三对角矩阵。定义网格点 $x_i$ 处的 Woods–Saxon 势为\n$$\nV_i(\\alpha) = -\\frac{\\alpha}{1 + \\exp\\!\\left(\\dfrac{|x_i| - R}{a}\\right)},\n$$\n其中形状参数 $R0$ 和 $a0$ 是固定的。哈密顿矩阵为\n$$\nA(\\alpha) = T + \\mathrm{diag}\\!\\big(V_1(\\alpha),\\dots,V_N(\\alpha)\\big).\n$$\n\n对于一个简单的、孤立的最小特征值 $\\lambda_0(\\alpha)$ 及其满足 $A(\\alpha) u_0(\\alpha) = \\lambda_0(\\alpha)\\,u_0(\\alpha)$ 和 $u_0(\\alpha)^\\top u_0(\\alpha) = 1$ 的相应归一化特征向量 $u_0(\\alpha)$，请仅使用特征值方程、归一化条件和瑞利商的定义，从第一性原理出发，推导一个用 $A(\\alpha)$、其关于 $\\alpha$ 的导数以及 $u_0(\\alpha)$ 表示的 $\\dfrac{d\\lambda_0}{d\\alpha}$ 的表达式。\n\n然后实现一个程序，该程序：\n- 对于指定的 $(N,L,R,a)$，在网格上构造 $A(\\alpha)$。\n- 使用依赖于矩阵-向量乘积的迭代对称特征求解器（例如，Lanczos 型方法）计算最小特征对。\n- 计算从你的推导中得到的解析导数 $\\dfrac{d\\lambda_0}{d\\alpha}$。\n- 使用以下公式计算 $\\dfrac{d\\lambda_0}{d\\alpha}$ 的中心有限差分估计值：\n$$\n\\frac{\\lambda_0(\\alpha+h) - \\lambda_0(\\alpha-h)}{2h},\n$$\n其中每个 $\\lambda_0(\\cdot)$ 都使用相同的迭代特征求解器和所要求的容差进行计算。\n\n- 对于每个测试用例，报告解析导数和有限差分估计值之间的绝对差，结果为一个浮点数。\n\n对所有测试使用以下固定的离散化和物理形状参数：\n- $N = 400$,\n- $L = 20$,\n- $R = 6$,\n- $a = 0.65$。\n\n使用迭代对称特征求解器来获得最小代数特征值及其归一化特征向量，绝对收敛容差为 $10^{-10}$ 或更小。\n\n测试套件。对于下面的每个有序对 $(\\alpha_0, h)$，计算在 $\\alpha=\\alpha_0$ 处解析导数与有限差分估计值之间的绝对误差：\n1. $(\\alpha_0, h) = (2.0, 10^{-2})$,\n2. $(\\alpha_0, h) = (8.0, 10^{-4})$,\n3. $(\\alpha_0, h) = (12.0, 10^{-6})$,\n4. $(\\alpha_0, h) = (0.5, 5\\times 10^{-3})$。\n\n最终输出格式。你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4]$），其中 $r_j$ 是测试用例 $j$ 的浮点数绝对误差。不应打印任何其他文本。\n\n所有计算都是无量纲的；不需要物理单位。不出现角度。不出现百分比。输出为实数。", "solution": "任务的核心是推导特征值关于参数的导数表达式，这个结果在量子力学中被称为 Hellmann-Feynman 定理。推导需从瑞利商、特征值方程和归一化条件开始。设 $\\lambda_0(\\alpha)$ 是实对称矩阵 $A(\\alpha)$ 的一个简单的、孤立的实特征值，其对应的归一化特征向量为 $u_0(\\alpha)$。特征值方程为 $A(\\alpha)u_0(\\alpha) = \\lambda_0(\\alpha)u_0(\\alpha)$，归一化条件为 $u_0(\\alpha)^\\top u_0(\\alpha) = 1$。\n\n特征值 $\\lambda_0(\\alpha)$ 可以表示为在其对应特征向量处求值的瑞利商：\n$$\n\\lambda_0(\\alpha) = \\frac{u_0(\\alpha)^\\top A(\\alpha) u_0(\\alpha)}{u_0(\\alpha)^\\top u_0(\\alpha)}\n$$\n根据归一化条件 $u_0(\\alpha)^\\top u_0(\\alpha) = 1$，上式可简化为：\n$$\n\\lambda_0(\\alpha) = u_0(\\alpha)^\\top A(\\alpha) u_0(\\alpha)\n$$\n为了求出 $\\lambda_0$ 关于 $\\alpha$ 的变化率，我们对该表达式进行微分。为简洁起见，我们将省略对 $\\alpha$ 的显式依赖，写作 $\\lambda_0$、$A$ 和 $u_0$。应用乘法法则进行微分，得到：\n$$\n\\frac{d\\lambda_0}{d\\alpha} = \\left(\\frac{du_0}{d\\alpha}\\right)^\\top A u_0 + u_0^\\top \\left(\\frac{dA}{d\\alpha}\\right) u_0 + u_0^\\top A \\left(\\frac{du_0}{d\\alpha}\\right)\n$$\n由于 $A$ 是实对称矩阵（$A = A^\\top$），第三项可以重写。项 $u_0^\\top A \\frac{du_0}{d\\alpha}$ 是一个标量，因此它等于其转置：$u_0^\\top A \\frac{du_0}{d\\alpha} = \\left(u_0^\\top A \\frac{du_0}{d\\alpha}\\right)^\\top = \\left(\\frac{du_0}{d\\alpha}\\right)^\\top A^\\top u_0 = \\left(\\frac{du_0}{d\\alpha}\\right)^\\top A u_0$。因此，第一项和第三项是相同的。表达式变为：\n$$\n\\frac{d\\lambda_0}{d\\alpha} = 2 \\left(\\frac{du_0}{d\\alpha}\\right)^\\top A u_0 + u_0^\\top \\left(\\frac{dA}{d\\alpha}\\right) u_0\n$$\n现在我们将特征值方程 $A u_0 = \\lambda_0 u_0$ 代入该表达式：\n$$\n\\frac{d\\lambda_0}{d\\alpha} = 2 \\left(\\frac{du_0}{d\\alpha}\\right)^\\top (\\lambda_0 u_0) + u_0^\\top \\left(\\frac{dA}{d\\alpha}\\right) u_0 = 2 \\lambda_0 \\left(\\frac{du_0}{d\\alpha}\\right)^\\top u_0 + u_0^\\top \\left(\\frac{dA}{d\\alpha}\\right) u_0\n$$\n剩下的包含特征向量导数的未知项，可以通过对归一化条件 $u_0^\\top u_0 = 1$ 关于 $\\alpha$ 求导来消去：\n$$\n\\frac{d}{d\\alpha} \\left( u_0^\\top u_0 \\right) = \\left(\\frac{du_0}{d\\alpha}\\right)^\\top u_0 + u_0^\\top \\frac{du_0}{d\\alpha} = 2 \\left(\\frac{du_0}{d\\alpha}\\right)^\\top u_0 = \\frac{d}{d\\alpha}(1) = 0\n$$\n这意味着 $\\left(\\frac{du_0}{d\\alpha}\\right)^\\top u_0 = 0$。将此结果代入 $\\frac{d\\lambda_0}{d\\alpha}$ 的表达式中，使得第一项消失：\n$$\n\\frac{d\\lambda_0}{d\\alpha} = 2 \\lambda_0 (0) + u_0^\\top \\left(\\frac{dA}{d\\alpha}\\right) u_0 = u_0^\\top \\left(\\frac{dA}{d\\alpha}\\right) u_0\n$$\n这就是特征值导数的最终解析表达式。现在我们必须求出哈密顿矩阵 $A(\\alpha)$ 的导数。给定 $A(\\alpha) = T + \\mathrm{diag}(V_1(\\alpha), \\dots, V_N(\\alpha))$，并且由于动能矩阵 $T$ 与 $\\alpha$ 无关，我们有：\n$$\n\\frac{dA}{d\\alpha} = \\frac{d}{d\\alpha} \\left(T + V(\\alpha)\\right) = \\frac{dV(\\alpha)}{d\\alpha} = \\mathrm{diag}\\left(\\frac{dV_1}{d\\alpha}, \\dots, \\frac{dV_N}{d\\alpha}\\right)\n$$\n势由 $V_i(\\alpha) = -\\frac{\\alpha}{1 + \\exp((|x_i| - R)/a)}$ 给出。它关于 $\\alpha$ 的导数很简单：\n$$\n\\frac{dV_i}{d\\alpha} = -\\frac{1}{1 + \\exp\\left(\\frac{|x_i| - R}{a}\\right)}\n$$\n因此，特征值的导数是在态 $u_0$ 下算子 $\\frac{dV}{d\\alpha}$ 的期望值：\n$$\n\\frac{d\\lambda_0}{d\\alpha} = \\sum_{i=1}^{N} (u_{0,i}(\\alpha))^2 \\frac{dV_i}{d\\alpha}\n$$\n其中 $u_{0,i}$ 是特征向量 $u_0$ 的分量。\n\n对于数值实现，固定参数为 $N = 400$，$L = 20$，$R = 6$ 和 $a = 0.65$。相应地构造空间网格 $x_i$ 和网格间距 $\\Delta x$。动能矩阵 $T$ 被构造为一个稀疏三对角矩阵。势 $V(\\alpha)$ 及其导数 $\\frac{dV}{d\\alpha}$ 是对角矩阵，因此它们作为其对角线元素的向量进行存储。完整的哈密顿量 $A(\\alpha)$ 使用 `scipy.sparse.linalg` 中的 `LinearOperator` 处理，它封装了矩阵-向量乘积 $A(\\alpha)v = T v + V(\\alpha) \\odot v$（其中 $\\odot$ 是逐元素乘积）。这种方法遵守了问题中要求使用基于矩阵-向量乘积的方法的规定。最小特征对 $(\\lambda_0, u_0)$ 使用 `scipy.sparse.linalg.eigsh` 计算，该函数实现了一种适用于大型稀疏对称矩阵的 Lanczos 型算法，容差设置为 $10^{-12}$。\n\n对于每个测试用例 $(\\alpha_0, h)$，算法按以下步骤进行：\n1. 首先求解在 $\\alpha_0$ 处的特征向量 $u_0(\\alpha_0)$，然后计算二次型 $u_0(\\alpha_0)^\\top \\frac{dA}{d\\alpha}(\\alpha_0) u_0(\\alpha_0)$，从而得到在 $\\alpha_0$ 处的解析导数。\n2. 分别求解特征值 $\\lambda_0(\\alpha_0+h)$ 和 $\\lambda_0(\\alpha_0-h)$，然后应用中心差分公式 $\\frac{\\lambda_0(\\alpha_0+h) - \\lambda_0(\\alpha_0-h)}{2h}$ 来计算有限差分估计值。\n3. 计算并存储解析结果与有限差分结果之间的绝对差。\n\n对所有测试用例重复此过程，并打印最终的绝对误差列表。", "answer": "```python\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n#   - name: scipy\n#     version: 1.11.4\n\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import eigsh, LinearOperator\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving, implementing, and comparing analytic \n    and finite-difference derivatives of a matrix eigenvalue.\n    \"\"\"\n    # Define fixed discretization and physical parameters\n    N = 400\n    L = 20.0\n    R = 6.0\n    a = 0.65\n    TOL = 1e-12  # Set tolerance tighter than the required 1e-10\n\n    # Define the test suite\n    test_cases = [\n        (2.0, 1e-2),\n        (8.0, 1e-4),\n        (12.0, 1e-6),\n        (0.5, 5e-3),\n    ]\n\n    # Set up the spatial grid\n    dx = 2 * L / (N + 1)\n    x = -L + np.arange(1, N + 1) * dx\n\n    # Construct the kinetic energy matrix T as a sparse matrix.\n    # This matrix is constant with respect to alpha.\n    diagonals_T = [-1.0, 2.0, -1.0]\n    offsets_T = [-1, 0, 1]\n    T = diags(diagonals_T, offsets_T, shape=(N, N), format='csr') / (dx**2)\n\n    # The diagonal of the derivative of the potential matrix, dV/d(alpha),\n    # is also constant with respect to alpha. Store it as a vector.\n    # dV_i/d(alpha) = -1 / (1 + exp((|x_i| - R)/a))\n    dV_dalpha_diag = -1.0 / (1.0 + np.exp((np.abs(x) - R) / a))\n\n    def get_potential_diag(alpha):\n        \"\"\"Returns the diagonal of the potential matrix V(alpha) as a vector.\"\"\"\n        # V_i(alpha) = alpha * (dV_i/d(alpha))\n        return alpha * dV_dalpha_diag\n\n    def solve_eigen_pair(alpha):\n        \"\"\"\n        Computes the smallest eigenvalue and its corresponding eigenvector for\n        the Hamiltonian A(alpha) using an iterative solver.\n        \"\"\"\n        V_diag = get_potential_diag(alpha)\n\n        # Define the matrix-vector product for A(alpha) * v\n        def matvec(v):\n            return T @ v + V_diag * v\n\n        # Create a LinearOperator to represent A(alpha) without forming it explicitly.\n        A_op = LinearOperator((N, N), matvec=matvec, dtype=np.float64)\n        \n        # Use eigsh to find the smallest algebraic eigenpair.\n        # This is an iterative Lanczos-based method.\n        # k=1: find one eigenpair.\n        # which='SA': find the one with the Smallest Algebraic value.\n        eigenvalues, eigenvectors = eigsh(A_op, k=1, which='SA', tol=TOL)\n        \n        # eigsh returns arrays, so we extract the scalar eigenvalue and vector.\n        return eigenvalues[0], eigenvectors[:, 0]\n\n    def compute_analytic_derivative(u_0):\n        \"\"\"\n        Computes the analytic derivative d(lambda)/d(alpha) using the\n        Hellmann-Feynman theorem result.\n        d(lambda)/d(alpha) = u_0^T * (dV/d(alpha)) * u_0\n        \"\"\"\n        # Since dV/d(alpha) is diagonal, the quadratic form is a simple sum.\n        return np.dot(u_0, dV_dalpha_diag * u_0)\n\n    results = []\n    for alpha_0, h in test_cases:\n        # 1. Compute the analytic derivative at alpha = alpha_0\n        # First, find the eigenvector u_0 at alpha_0.\n        _, u_0_at_alpha0 = solve_eigen_pair(alpha_0)\n        analytic_derivative = compute_analytic_derivative(u_0_at_alpha0)\n\n        # 2. Compute the finite-difference derivative at alpha = alpha_0\n        # Find the eigenvalues at alpha_0 + h and alpha_0 - h.\n        lambda_plus_h, _ = solve_eigen_pair(alpha_0 + h)\n        lambda_minus_h, _ = solve_eigen_pair(alpha_0 - h)\n        \n        # Apply the central difference formula.\n        finite_diff_derivative = (lambda_plus_h - lambda_minus_h) / (2.0 * h)\n        \n        # 3. Calculate the absolute error between the two methods.\n        error = abs(analytic_derivative - finite_diff_derivative)\n        results.append(error)\n\n    # Print the results in the specified format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3568968"}]}