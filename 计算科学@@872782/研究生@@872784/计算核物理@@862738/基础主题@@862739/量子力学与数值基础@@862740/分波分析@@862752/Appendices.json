{"hands_on_practices": [{"introduction": "分波分析的第一步通常是将散射势（一个矢量函数）投影到分波基上，后者仅依赖于动量大小。这个过程将一个复杂的多维问题转化为一组更简单的一维方程。这个练习 [@problem_id:3579009] 提供了对这一基本投影积分的动手实践，要求您实现一个稳健的数值积分方法（高斯-勒让德求积），并将其结果与精确的解析解进行比较，以理解和量化数值误差。", "problem": "考虑在动量空间中进行两体散射分波分析（PWA）背景下的一个计算任务。令 $l \\in \\mathbb{N}_0$ 为轨道角动量量子数，$p \\ge 0$ 和 $p' \\ge 0$ 为入射和出射动量的大小（通过适当的缩放处理为无量纲），并令 $\\alpha  0$ 为一个无量纲程参数。将球对称模型核的分波投影 $V_l(p,p')$ 定义为\n$$\nV_l(p,p') \\equiv \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, V(p,p',x),\n$$\n其中 $x \\equiv \\cos \\theta$，$P_l(x)$ 是 $l$ 阶 Legendre 多项式。对于本问题，使用光滑、旋转不变的模型\n$$\nV(p,p',x) \\equiv \\exp\\!\\big(-\\alpha\\,[p^2 + p'^2 - 2 p p' x]\\big).\n$$\n您的任务是：\n- 从 Legendre 多项式的基本定义、在区间 $[-1,1]$ 上的正交性以及高斯求积的性质出发，推导出一个用已知特殊函数表示的 $V_l(p,p')$ 的闭式表达式，该表达式可作为数值误差评估的参考（基准真相）。除所述的解析性和球对称性外，不要引入任何新的假设。\n- 实现具有 $N$ 个节点的高精度高斯-勒让德求积法来近似 $V_l(p,p')$ 的积分：\n$$\nV_l^{(N)}(p,p') \\approx \\sum_{i=1}^{N} w_i \\, P_l(x_i)\\, V(p,p',x_i),\n$$\n其中 $\\{x_i,w_i\\}_{i=1}^N$ 是在 $[-1,1]$ 上的高斯-勒让德求积的节点和权重。\n- 对于下述每个测试用例，计算绝对截断误差\n$$\n\\varepsilon \\equiv \\big|V_l^{(N)}(p,p') - V_l(p,p')\\big|,\n$$\n其中 $V_l(p,p')$ 是您推导出的闭式参考值。\n\n角度通过 $x=\\cos\\theta$ 以弧度为单位测量，但积分变量是 $x$，无需进行角度转换。根据构造，所有量均为无量纲，因此最终答案中不需要物理单位。\n\n您必须实现一个独立完整的程序，仅使用指定的数值库来计算这些误差。您的实现必须是通用的，并适用于任意允许的参数。\n\n使用以下测试套件，其设计旨在覆盖一般情况、较高 $l$ 时的振荡行为、一个边界条件、一个具有大有效宗量的近共线构型，以及一个在大 $l$ 和相对小的 $N$ 情况下的挑战性案例：\n- 情况 1：$l=0$，$p=0.8$，$p'=1.1$，$\\alpha=0.6$，$N=16$。\n- 情况 2：$l=12$，$p=1.0$，$p'=1.0$，$\\alpha=0.4$，$N=32$。\n- 情况 3：$l=5$，$p=0.0$，$p'=1.7$，$\\alpha=0.3$，$N=8$。\n- 情况 4：$l=4$，$p=2.0$，$p'=2.0$，$\\alpha=0.75$，$N=24$。\n- 情况 5：$l=20$，$p=1.5$，$p'=1.5$，$\\alpha=0.2$，$N=12$。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含 5 个测试用例的绝对误差，以逗号分隔的列表形式呈现并用方括号括起来，每个误差都以科学记数法格式化，小数点后保留 10 位数字（例如，$1.2345678900\\mathrm{e}{-6}$），即，严格遵循 `[误差_1,误差_2,误差_3,误差_4,误差_5]` 的形式，无空格。", "solution": "该问题是适定的、有科学依据且自洽的。所有必要的定义和参数均已提供，且没有矛盾之处。因此，我们可以着手求解。\n\n任务是解析和数值地计算特定模型核的分波投影 $V_l(p,p')$，然后对一组给定的测试用例，确定数值近似的绝对误差。\n\n分波投影由以下积分定义：\n$$\nV_l(p,p') \\equiv \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, V(p,p',x)\n$$\n其中 $P_l(x)$ 是 $l$ 阶 Legendre 多项式，模型核由下式给出：\n$$\nV(p,p',x) \\equiv \\exp\\!\\big(-\\alpha\\,[p^2 + p'^2 - 2 p p' x]\\big)\n$$\n所有参数 $l$、$p$、$p'$ 和 $\\alpha$ 都是无量纲量。\n\n**1. 闭式表达式的推导**\n\n为推导 $V_l(p,p')$ 的闭式表达式，我们将核代入积分定义中。我们可以将指数中不依赖于积分变量 $x$ 的项提取出来：\n$$\nV_l(p,p') = \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, \\exp\\!\\big(-\\alpha(p^2 + p'^2)\\big) \\exp\\!\\big(2 \\alpha p p' x\\big)\n$$\n$$\nV_l(p,p') = \\exp\\big(-\\alpha(p^2 + p'^2)\\big) \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, \\exp\\big( (2 \\alpha p p') x\\big)\n$$\n我们将指数的宗量定义为 $z \\equiv 2\\alpha p p'$。该积分变为：\n$$\nI_l(z) = \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x)\\, e^{zx}\n$$\n该积分是一个与第一类修正球贝塞尔函数（记为 $i_l(z)$）相关的标准积分表示。函数 $i_l(z)$ 可以通过将指数函数展开为 Legendre 多项式级数来定义：\n$$\ne^{zx} = \\sum_{n=0}^{\\infty} (2n+1) i_n(z) P_n(x)\n$$\n对于 $x \\in [-1,1]$，此级数一致收敛。我们可以将此展开式代入积分 $I_l(z)$，乘以 $P_l(x)$，并在 $x \\in [-1,1]$ 上积分。利用 Legendre 多项式的正交性，\n$$\n\\int_{-1}^{1} P_l(x) P_n(x) \\mathrm{d}x = \\frac{2}{2l+1} \\delta_{ln}\n$$\n其中 $\\delta_{ln}$ 是克罗内克 δ (Kronecker delta)，我们可以确定积分 $I_l(z)$：\n$$\nI_l(z) = \\int_{-1}^{1} \\mathrm{d}x \\, P_l(x) \\sum_{n=0}^{\\infty} (2n+1) i_n(z) P_n(x)\n$$\n$$\nI_l(z) = \\sum_{n=0}^{\\infty} (2n+1) i_n(z) \\int_{-1}^{1} P_l(x) P_n(x) \\mathrm{d}x\n$$\n$$\nI_l(z) = \\sum_{n=0}^{\\infty} (2n+1) i_n(z) \\left(\\frac{2}{2l+1} \\delta_{ln}\\right)\n$$\n当 $n=l$ 时，该求和坍缩为一项：\n$$\nI_l(z) = (2l+1) i_l(z) \\left(\\frac{2}{2l+1}\\right) = 2 i_l(z)\n$$\n将此结果代回 $V_l(p,p')$ 的表达式，我们得到闭式解：\n$$\nV_l(p,p') = 2 \\exp\\big(-\\alpha(p^2 + p'^2)\\big) \\, i_l(2 \\alpha p p')\n$$\n此表达式作为我们误差分析的精确参考值。函数 $i_l(z)$ 与第一类修正贝塞尔函数 $I_{\\nu}(z)$ 通过 $i_l(z) = \\sqrt{\\frac{\\pi}{2z}} I_{l+1/2}(z)$ 相关。在计算上，我们将依赖于一个 $i_l(z)$ 的高精度库实现。\n\n当 $p=0$ 或 $p'=0$ 时会出现一个特殊情况。在这种情况下，宗量 $z=2\\alpha p p'$ 变为零。积分简化为：\n$$\nV_l(p, p')|_{p=0} = \\exp(-\\alpha p'^2) \\int_{-1}^{1} P_l(x) \\mathrm{d}x\n$$\n根据与 $P_0(x)=1$ 的正交关系，我们有 $\\int_{-1}^{1} P_l(x) \\mathrm{d}x = 2\\delta_{l0}$。因此，对于 $p=0$ 或 $p'=0$：\n$$\nV_l(p, p') =\n\\begin{cases}\n2 \\exp\\big(-\\alpha(p^2+p'^2)\\big)  \\text{如果 } l=0 \\\\\n0  \\text{如果 } l0\n\\end{cases}\n$$\n这个结果与闭式公式一致，因为修正球贝塞尔函数在原点附近的行为是，当 $z \\to 0$ 时，$i_l(z) \\to \\delta_{l0}$。\n\n**2. 通过高斯-勒让德求积进行数值近似**\n\n问题指定使用具有 $N$ 个节点的高斯-勒让德求积来近似该积分。该近似值记为 $V_l^{(N)}(p,p')$，由下式给出：\n$$\nV_l^{(N)}(p,p') = \\sum_{i=1}^{N} w_i \\, P_l(x_i)\\, V(p,p',x_i)\n$$\n这里，$\\{x_i\\}_{i=1}^N$ 是 Legendre 多项式 $P_N(x)$ 的根，称为求积节点，而 $\\{w_i\\}_{i=1}^N$ 是相应的求积权重。该方法对于次数最高为 $2N-1$ 的任意多项式被积函数都是精确的。我们的被积函数 $P_l(x)\\exp(2\\alpha p p' x)$ 不是多项式，但它是解析的且通常是光滑的。求积的精度取决于被积函数能被一个 $2N-1$ 次多项式近似得有多好。\n\n数值计算的算法步骤如下：\n1.  对于给定的求积阶数 $N$，获取区间 $[-1,1]$ 上的节点 $\\{x_i\\}$ 和权重 $\\{w_i\\}$ 集合。\n2.  在每个节点 $x_i$ 处，计算被积函数的分量：Legendre 多项式 $P_l(x_i)$ 和核 $V(p,p',x_i) = \\exp\\big(-\\alpha(p^2 + p'^2 - 2 p p' x_i)\\big)$。\n3.  计算这些值与相应权重的乘积之和：$\\sum_{i=1}^{N} w_i P_l(x_i) V(p,p',x_i)$。\n\n**3. 误差计算与实现**\n\n绝对截断误差 $\\varepsilon$ 是数值近似与精确解析解之间差值的绝对值：\n$$\n\\varepsilon \\equiv \\big|V_l^{(N)}(p,p') - V_l(p,p')\\big|\n$$\n将使用 Python 中的 `numpy` 和 `scipy` 库来实现。\n- 高斯-勒让德节点和权重使用 `scipy.special.roots_legendre(N)` 计算。\n- Legendre 多项式 $P_l(x_i)$ 使用 `scipy.special.eval_legendre(l, nodes)` 进行求值。\n- 用于精确解的修正球贝塞尔函数 $i_l(z)$ 使用 `scipy.special.spherical_in(l, z)` 计算。\n\n最终的程序将定义一个函数，该函数接受一个测试用例的参数 $(l, p, p', \\alpha, N)$，计算 $V_l(p,p')$ 和 $V_l^{(N)}(p,p')$，计算绝对误差 $\\varepsilon$ 并返回它。此函数将应用于每个指定的测试用例，结果将按要求格式化为单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre, eval_legendre, spherical_in\n\ndef solve():\n    \"\"\"\n    Computes the absolute truncation error for the partial-wave projection integral\n    for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (l, p, p_prime, alpha, N)\n        (0, 0.8, 1.1, 0.6, 16),\n        (12, 1.0, 1.0, 0.4, 32),\n        (5, 0.0, 1.7, 0.3, 8),\n        (4, 2.0, 2.0, 0.75, 24),\n        (20, 1.5, 1.5, 0.2, 12),\n    ]\n\n    results = []\n    for l, p, p_prime, alpha, N in test_cases:\n        # Step 1: Calculate the exact analytical solution V_l(p, p')\n        # V_l(p,p') = 2 * exp(-alpha*(p^2 + p'^2)) * i_l(2*alpha*p*p')\n        # where i_l is the modified spherical Bessel function of the first kind.\n        \n        prefactor = 2.0 * np.exp(-alpha * (p**2 + p_prime**2))\n        argument_bessel = 2.0 * alpha * p * p_prime\n        \n        # The scipy function spherical_in correctly handles the z=0 case,\n        # where i_l(0) is 1 for l=0 and 0 for l0.\n        i_l_val = spherical_in(l, argument_bessel)\n        exact_Vl = prefactor * i_l_val\n\n        # Step 2: Calculate the numerical approximation V_l^(N)(p, p')\n        # using N-point Gauss-Legendre quadrature.\n        \n        # Get Gauss-Legendre nodes (x_i) and weights (w_i) on [-1, 1]\n        nodes, weights = roots_legendre(N)\n        \n        # Evaluate the components of the integrand at the nodes\n        # Legendre polynomials P_l(x_i)\n        legendre_vals = eval_legendre(l, nodes)\n        \n        # Kernel V(p, p', x_i) = exp(-alpha * (p^2 + p'^2 - 2*p*p'*x_i))\n        kernel_vals = np.exp(-alpha * (p**2 + p_prime**2 - 2.0 * p * p_prime * nodes))\n\n        # Compute the quadrature sum\n        numerical_Vl = np.sum(weights * legendre_vals * kernel_vals)\n\n        # Step 3: Compute the absolute truncation error\n        error = np.abs(numerical_Vl - exact_Vl)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.10e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3579009"}, {"introduction": "分波分析将理论模型与可观测的实验量（如相移）联系起来。在低能区，有效力程展开（Effective Range Expansion, ERE）为散射提供了一个强有力的、不依赖于模型的描述。本实践 [@problem_id:3579075] 模拟了实验物理学家或现象学家的真实任务：从散射数据中提取基本物理参数（散射长度 $a_0$ 和有效力程 $r_0$）。它介绍了加权线性回归和不确定性传播的关键技术，并深入探讨了模型截断的影响，这是评估系统误差的一个重要方面。", "problem": "给定 s 波分波的低能弹性散射相移数据。您的目标是根据带有不确定度的相移测量值，构建一个基于统计原理的方法来提取 s 波散射长度 $a_{0}$ 和有效力程 $r_{0}$，并量化在低能展开中截断高阶形状参数所带来的影响。使用的单位制中，动量以反费米（inverse femtometers）为单位，即 $k$ 的单位是 $\\mathrm{fm}^{-1}$，而诸如 $a_{0}$ 和 $r_{0}$ 之类的长度单位是费米（femtometers） $\\mathrm{fm}$。角度必须以弧度处理。\n\n从非相对论量子散射理论的基本原理以及在复能量平面上在壳散射振幅的解析性出发，您必须首先论证 s 波相移允许一个关于碰撞动量大小 $k$ 的收敛的低能展开，该展开可以组织成一个层次结构。仅基于这些原理和定义，并且不假设任何预先给定的最终公式，执行以下步骤：\n\n1. 从 s 波相移 $\\delta_{0}(k)$ 的定义和短程相互作用分波散射振幅的解析性出发，推导一个可观测量的低能展开式。该展开式在 $k^{2}$ 阶之前是两个参数的线性函数，当包含下一个更高阶的形状参数时，在 $k^{4}$ 阶会增加一个额外的线性项。确定如何将测量的相移转换为这个可观测量，以便可以应用具有已知高斯误差的加权线性回归。清楚地确定回归参数及其与 $a_{0}$ 和 $r_{0}$ 的映射关系。\n\n2. 在测量的相移具有已知标准差的独立高斯误差的假设下，构建一个统计上合理的估计器。使用等效于加权最小二乘法的最大似然估计器。通过不确定度传播来证明您所选择的权重的合理性，这种传播将相移不确定度与所选线性可观测量的-不确定度联系起来。提供一种有原则的方法，将线性拟合中的参数不确定度传播到 $a_{0}$ 和 $r_{0}$ 的不确定度上。\n\n3. 将两个模型拟合到所提供的数据：\n   - 一个截断到 $k^{2}$ 阶的模型（双参数拟合），从中提取 $a_{0}$ 和 $r_{0}$。\n   - 一个扩展到 $k^{4}$ 阶的模型（三参数拟合），从中也提取 $a_{0}$ 和 $r_{0}$，同时对额外的线性形状参数进行边缘化处理。\n   使用这两个结果，通过比较双参数和三参数估计的 $a_{0}$ 和 $r_{0}$，来量化截断高阶项的影响。您的比较应表示为绝对差异和以组合标准差为单位的统计显著性，即一个根据两次拟合传播的不确定度构建的 $z$ 分数。\n\n4. 物理和数值单位：\n   - $k$ 的单位为 $\\mathrm{fm}^{-1}$。\n   - $\\delta$ 的单位为弧度。\n   - $a_{0}$ 和 $r_{0}$ 的单位为 $\\mathrm{fm}$。\n   - 所有中间的角度量必须以弧度为单位。\n   - 您最终报告的数值必须四舍五入到六位小数。\n\n5. 测试套件和要求的输出：\n   使用以下三个数据集。在每个数据集中，动量值 $k_{i}$ 的单位是 $\\mathrm{fm}^{-1}$，测量的 s 波相移 $\\delta_{i}$ 的单位是弧度，单西格玛不确定度 $\\sigma_{\\delta,i}$ 的单位也是弧度。\n\n   - 数据集 A（一般低能情况）：\n     - $k = [0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40]$\n     - $\\delta = [0.371000, 0.631000, 0.775000, 0.851000, 0.888000, 0.900000, 0.896000, 0.889000]$\n     - $\\sigma_{\\delta} = [0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000]$\n\n   - 数据集 B（具有极小动量的近阈值情况）：\n     - $k = [0.01, 0.02, 0.03, 0.04, 0.05]$\n     - $\\delta = [0.020000, 0.040000, 0.059800, 0.079400, 0.099100]$\n     - $\\sigma_{\\delta} = [0.002000, 0.002000, 0.002000, 0.002000, 0.002000]$\n\n   - 数据集 C（更高阶项更重要的更宽低能范围）：\n     - $k = [0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60]$\n     - $\\delta = [0.243000, 0.444000, 0.597000, 0.703000, 0.811000, 0.849000, 0.844000, 0.818000]$\n     - $\\sigma_{\\delta} = [0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000]$\n\n   对于每个数据集，执行两种拟合（到 $k^{2}$ 阶和到 $k^{4}$ 阶），传播不确定度以获得 $a_{0}$ 和 $r_{0}$ 的不确定度，然后计算双参数和三参数估计的 $a_{0}$ 和 $r_{0}$ 之间差异的绝对 $z$ 分数，分母使用它们单西格玛标准差的平方和的平方根。\n\n   您的程序必须生成单行输出，其中包含一个含三个子列表的列表，每个子列表对应一个数据集，每个子列表中的顺序如下：\n   - $a_{0}^{(k^{2})}$，单位 $\\mathrm{fm}$，\n   - $r_{0}^{(k^{2})}$，单位 $\\mathrm{fm}$，\n   - $a_{0}^{(k^{4})}$，单位 $\\mathrm{fm}$，\n   - $r_{0}^{(k^{4})}$，单位 $\\mathrm{fm}$，\n   - $a_{0}$ 差异的 $z$ 分数，\n   - $r_{0}$ 差异的 $z$ 分数。\n\n   所有数字必须四舍入到六位小数。最终输出格式为单行：\n   “您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，[[a0_k2_A,r0_k2_A,a0_k4_A,r0_k4_A,zA0_A,zR0_A],[...数据集 B...],[...数据集 C...]]）”。", "solution": "用户提供了一个计算核物理问题，涉及从相移数据中提取 s 波散射参数。解决方案要求从第一性原理推导相关物理模型，制定统计上可靠的拟合程序，并将其应用于多个数据集以评估模型截断的影响。\n\n该问题被验证为科学上可靠、适定、客观且自洽。这是一个源于基本量子力学和统计数据分析的分波分析中的标准且非平凡的练习。因此，我们可以着手提供完整解决方案。\n\n解决方案分为三部分：\n1.  推导作为理论模型的有效力程展开（ERE）。\n2.  加权最小二乘拟合程序和误差传播的构建。\n3.  模型拟合与比较的计算协议规范。\n\n### 1. 理论基础：有效力程展开\n\n短程相互作用的低能散射理论的基础是散射振幅的解析性。对于 s 波（$l=0$）分波，散射矩阵元 $S_0(k)$ 通过 $S_0(k) = e^{2i\\delta_0(k)}$ 与相移 $\\delta_0(k)$ 相关，其中 $k$ 是相对动量的大小。\n\n分波散射振幅 $f_0(k)$ 定义为：\n$$f_0(k) = \\frac{S_0(k) - 1}{2ik} = \\frac{e^{2i\\delta_0(k)} - 1}{2ik} = \\frac{e^{i\\delta_0(k)}(e^{i\\delta_0(k)} - e^{-i\\delta_0(k)})}{2ik} = \\frac{e^{i\\delta_0(k)}\\sin\\delta_0(k)}{k}$$\n该表达式可以反转，通过函数 $\\cot\\delta_0(k)$ 将 $f_0(k)$ 与相移联系起来：\n$$f_0(k) = \\frac{1}{k \\cot\\delta_0(k) - ik}$$\n由 Bethe 建立的散射理论的一个基本结果是，对于短程势，函数 $k\\cot\\delta_0(k)$ 是能量 $E \\propto k^2$ 的解析函数。因此，它允许在 $k=0$ 附近按 $k^2$ 的幂次进行收敛的泰勒级数展开。这被称为有效力程展开（ERE）：\n$$k\\cot\\delta_0(k) = c_0 + c_1 k^2 + c_2 k^4 + O(k^6)$$\n该展开的系数定义了低能散射参数。s 波散射长度 $a_0$ 由零能极限定义：\n$$\\lim_{k \\to 0} (-k \\cot\\delta_0(k)) = \\frac{1}{a_0}$$\n这意味着首项系数为 $c_0 = -1/a_0$。下一项系数定义了有效力程 $r_0$：\n$$c_1 = \\frac{1}{2}r_0$$\n更高阶的项定义了形状参数。一个常见的约定将 $k^4$ 的系数设为 $c_2 = -P_0 r_0^3$，其中 $P_0$ 是第一个形状参数。因此，ERE 可以写成：\n$$k\\cot\\delta_0(k) = -\\frac{1}{a_0} + \\frac{1}{2}r_0k^2 - P_0 r_0^3 k^4 + O(k^6)$$\n这个方程为线性回归分析提供了基础。我们定义一个可观测量 $y(k) = k\\cot\\delta_0(k)$ 和一个自变量 $x = k^2$。ERE 随后可以被转换成线性模型。\n\n-   **截断模型（$k^2$ 阶）：**通过在 $k^2$ 阶截断级数，我们得到一个双参数线性模型：\n    $$y(k) \\approx \\beta_0 + \\beta_1 x \\quad \\text{其中} \\quad x=k^2$$\n    回归参数与物理参数直接相关：$\\beta_0 = -1/a_0$ 和 $\\beta_1 = r_0/2$。\n\n-   **扩展模型（$k^4$ 阶）：**包含下一项可得到一个三参数线性模型：\n    $$y(k) \\approx \\beta_0 + \\beta_1 x + \\beta_2 x^2 \\quad \\text{其中} \\quad x=k^2$$\n    这里，$\\beta_0 = -1/a_0$，$\\beta_1 = r_0/2$，以及 $\\beta_2 = -P_0 r_0^3$。目标是从 $\\beta_0$ 和 $\\beta_1$ 中提取 $a_0$ 和 $r_0$，并将 $\\beta_2$ 视为一个由拟合决定的参数。\n\n### 2. 统计方法与不确定度传播\n\n我们给定 $N$ 个数据点 $(k_i, \\delta_i)$，其相移具有不确定度 $\\sigma_{\\delta,i}$。为了执行线性拟合，我们首先将这些数据转换为我们线性模型的数据点：$(x_i, y_i) = (k_i^2, k_i\\cot\\delta_i)$。\n\n不确定度必须从 $\\delta_i$ 传播到 $y_i$。使用一阶泰勒展开进行误差传播， $y_i$ 的方差，记为 $\\sigma_{y,i}^2$，是：\n$$\\sigma_{y,i}^2 \\approx \\left( \\frac{\\partial y_i}{\\partial \\delta_i} \\right)^2 \\sigma_{\\delta,i}^2$$\n导数为 $\\frac{\\partial}{\\partial\\delta}(k\\cot\\delta) = -k\\csc^2\\delta = -k/\\sin^2\\delta$。因此，每个 $y_i$ 的方差是：\n$$\\sigma_{y,i}^2 = \\left( \\frac{-k_i}{\\sin^2\\delta_i} \\right)^2 \\sigma_{\\delta,i}^2 = \\frac{k_i^2}{(\\sin^2\\delta_i)^2} \\sigma_{\\delta,i}^2$$\n假设测量误差 $\\sigma_{\\delta,i}$ 是高斯的和独立的，参数 $\\beta$ 的最佳线性无偏估计量可通过加权最小二乘法（WLS）最小化 $\\chi^2$ 统计量来获得。$\\chi^2$ 定义为：\n$$\\chi^2 = \\sum_{i=1}^{N} \\left( \\frac{y_i - f(x_i; \\beta)}{\\sigma_{y,i}} \\right)^2 = \\sum_{i=1}^{N} w_i \\left(y_i - \\sum_{j=0}^{m-1} \\beta_j X_{ij}\\right)^2$$\n其中 $f(x_i; \\beta)$ 是线性模型，$w_i = 1/\\sigma_{y,i}^2$ 是权重，$X$ 是设计矩阵，其元素 $X_{ij}$ 是在数据点 $i$ 处求值的基函数。对于 $k^4$ 模型，$X_{i0}=1$，$X_{i1}=k_i^2$，$X_{i2}=k_i^4$。\n\n以矩阵形式，最小化 $\\chi^2$ 的解是：\n$$\\hat{\\beta} = (X^T W X)^{-1} X^T W y$$\n这里，$\\hat{\\beta}$ 是估计参数的向量，$y$ 是观测值 $y_i$ 的列向量，$W$ 是一个对角矩阵，其对角元素为 $W_{ii} = w_i$。\n\n估计参数 $\\hat{\\beta}$ 的协方差矩阵由下式给出：\n$$C_{\\beta} = (X^T W X)^{-1}$$\n每个参数的方差 $\\sigma_{\\beta_j}^2$ 是该矩阵的第 $j$ 个对角元素，即 $\\sigma_{\\beta_j}^2 = (C_{\\beta})_{jj}$。\n\n最后，通过从 $\\hat{\\beta}_0$ 和 $\\hat{\\beta}_1$ 传播不确定度，可以获得物理参数 $a_0$ 和 $r_0$ 的不确定度：\n-   对于 $a_0 = -1/\\beta_0$：\n    $$\\sigma_{a_0}^2 = \\left( \\frac{\\partial a_0}{\\partial \\beta_0} \\right)^2 \\sigma_{\\beta_0}^2 = \\left( \\frac{1}{\\beta_0^2} \\right)^2 \\sigma_{\\beta_0}^2 = \\frac{\\sigma_{\\beta_0}^2}{\\beta_0^4} = a_0^4 \\sigma_{\\beta_0}^2 \\implies \\sigma_{a_0} = a_0^2 \\sigma_{\\beta_0}$$\n-   对于 $r_0 = 2\\beta_1$：\n    $$\\sigma_{r_0}^2 = \\left( \\frac{\\partial r_0}{\\partial \\beta_1} \\right)^2 \\sigma_{\\beta_1}^2 = (2)^2 \\sigma_{\\beta_1}^2 = 4\\sigma_{\\beta_1}^2 \\implies \\sigma_{r_0} = 2\\sigma_{\\beta_1}$$\n\n### 3. 计算协议与模型比较\n\n对于提供的每个数据集，执行以下协议：\n1.  **数据转换：**为所有数据点计算 $y_i = k_i\\cot\\delta_i$ 和相应的权重 $w_i = (\\sin^2\\delta_i / (k_i \\sigma_{\\delta,i}))^2$。\n2.  **拟合 $k^2$ 阶模型：**\n    -   构建设计矩阵 $X^{(2)}$，其列为基函数 $1$ 和 $k^2$。\n    -   使用 WLS 公式计算 $\\hat{\\beta}^{(k^2)}$ 及其协方差矩阵 $C_{\\beta}^{(k^2)}$。\n    -   计算 $a_0^{(k^2)} = -1/\\hat{\\beta}_0^{(k^2)}$、$r_0^{(k^2)} = 2\\hat{\\beta}_1^{(k^2)}$ 以及它们的不确定度 $\\sigma_{a_0}^{(k^2)}$ 和 $\\sigma_{r_0}^{(k^2)}$。\n3.  **拟合 $k^4$ 阶模型：**\n    -   构建设计矩阵 $X^{(4)}$，其列为基函数 $1$、$k^2$ 和 $k^4$。\n    -   计算 $\\hat{\\beta}^{(k^4)}$ 及其协方差矩阵 $C_{\\beta}^{(k^4)}$。\n    -   使用 $C_{\\beta}^{(k^4)}$ 中前两个参数的方差，计算 $a_0^{(k^4)} = -1/\\hat{\\beta}_0^{(k^4)}$、$r_0^{(k^4)} = 2\\hat{\\beta}_1^{(k^4)}$ 以及它们的不确定度 $\\sigma_{a_0}^{(k^4)}$ 和 $\\sigma_{r_0}^{(k^4)}$。\n4.  **模型比较：**为量化截断 ERE 引入的系统不确定度，我们计算从两个模型中提取的参数之间差异的统计显著性。这通过 z 分数完成，其定义为两个估计值之间的绝对差除以它们的组合不确定度（各项不确定度的平方和的平方根）：\n    $$z_{a_0} = \\frac{|a_0^{(k^2)} - a_0^{(k^4)}|}{\\sqrt{(\\sigma_{a_0}^{(k^2)})^2 + (\\sigma_{a_0}^{(k^4)})^2}}$$\n    $$z_{r_0} = \\frac{|r_0^{(k^2)} - r_0^{(k^4)}|}{\\sqrt{(\\sigma_{r_0}^{(k^2)})^2 + (\\sigma_{r_0}^{(k^4)})^2}}$$\n一个大的 z 分数（例如，$z  2$）表明更高阶的 $k^4$ 项在统计上是显著的，并且截断模型对于给定的数据范围是不充分的。一个小的 z 分数则意味着更简单的模型是足够的，并且数据没有提供足够的信息来分辨更高阶的项。对于所提供的三个数据集，将对整个过程进行数值实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all datasets and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset A (general low-energy case)\n        {\n            \"k\": [0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40],\n            \"delta\": [0.371000, 0.631000, 0.775000, 0.851000, 0.888000, 0.900000, 0.896000, 0.889000],\n            \"sigma_delta\": [0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000, 0.010000]\n        },\n        # Dataset B (near-threshold case with tiny momenta)\n        {\n            \"k\": [0.01, 0.02, 0.03, 0.04, 0.05],\n            \"delta\": [0.020000, 0.040000, 0.059800, 0.079400, 0.099100],\n            \"sigma_delta\": [0.002000, 0.002000, 0.002000, 0.002000, 0.002000]\n        },\n        # Dataset C (broader low-energy range where higher orders matter more)\n        {\n            \"k\": [0.05, 0.10, 0.15, 0.20, 0.30, 0.40, 0.50, 0.60],\n            \"delta\": [0.243000, 0.444000, 0.597000, 0.703000, 0.811000, 0.849000, 0.844000, 0.818000],\n            \"sigma_delta\": [0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000, 0.005000]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = _solve_for_dataset(case[\"k\"], case[\"delta\"], case[\"sigma_delta\"])\n        all_results.append(result)\n\n    # Format the final output string as specified.\n    # [[a0_k2_A,r0_k2_A,a0_k4_A,r0_k4_A,zA0_A,zR0_A],[...B...],[...C...]]\n    formatted_sublists = []\n    for res_list in all_results:\n        # Round each number to six decimal places\n        formatted_numbers = [f\"{x:.6f}\" for x in res_list]\n        formatted_sublists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output_string)\n\ndef _solve_for_dataset(k_vals, delta_vals, sigma_delta_vals):\n    \"\"\"\n    Performs the effective range expansion analysis for a single dataset.\n    \n    Args:\n        k_vals (list): Momenta in fm^-1.\n        delta_vals (list): Phase shifts in radians.\n        sigma_delta_vals (list): Uncertainties on phase shifts in radians.\n        \n    Returns:\n        list: A list containing [a0_k2, r0_k2, a0_k4, r0_k4, z_a0, z_r0].\n    \"\"\"\n    k = np.array(k_vals)\n    delta = np.array(delta_vals)\n    sigma_delta = np.array(sigma_delta_vals)\n    \n    # 1. Transform data and propagate uncertainties\n    # y = k * cot(delta)\n    y = k / np.tan(delta)\n    \n    # Uncertainty propagation: sigma_y^2 = (dy/d_delta)^2 * sigma_delta^2\n    # dy/d_delta = -k / sin^2(delta)\n    dyd_delta = -k / (np.sin(delta)**2)\n    sigma_y_sq = (dyd_delta**2) * (sigma_delta**2)\n    \n    # Weights for WLS: w = 1 / sigma_y^2\n    weights = 1.0 / sigma_y_sq\n    W = np.diag(weights)\n    \n    # --- 2. Fit truncated model (order k^2) ---\n    # Model: y = beta_0 + beta_1 * k^2\n    X2 = np.vstack([np.ones_like(k), k**2]).T\n    \n    # WLS solution: beta = (X^T W X)^-1 X^T W y\n    # Covariance matrix: C_beta = (X^T W X)^-1\n    XTWX2 = X2.T @ W @ X2\n    XTWy2 = X2.T @ W @ y\n    \n    C_beta2 = np.linalg.inv(XTWX2)\n    beta_hat2 = C_beta2 @ XTWy2\n    \n    beta0_k2, beta1_k2 = beta_hat2\n    var_beta0_k2, var_beta1_k2 = np.diag(C_beta2)\n    \n    # Extract physical parameters and propagate errors\n    a0_k2 = -1.0 / beta0_k2\n    r0_k2 = 2.0 * beta1_k2\n    \n    sigma_a0_k2 = np.abs(a0_k2**2) * np.sqrt(var_beta0_k2)\n    sigma_r0_k2 = 2.0 * np.sqrt(var_beta1_k2)\n\n    # --- 3. Fit extended model (order k^4) ---\n    # Model: y = beta_0 + beta_1 * k^2 + beta_2 * k^4\n    X4 = np.vstack([np.ones_like(k), k**2, k**4]).T\n    \n    XTWX4 = X4.T @ W @ X4\n    XTWy4 = X4.T @ W @ y\n    \n    C_beta4 = np.linalg.inv(XTWX4)\n    beta_hat4 = C_beta4 @ XTWy4\n    \n    beta0_k4, beta1_k4, _ = beta_hat4\n    var_beta0_k4, var_beta1_k4, _ = np.diag(C_beta4)\n    \n    # Extract physical parameters and propagate errors\n    a0_k4 = -1.0 / beta0_k4\n    r0_k4 = 2.0 * beta1_k4\n    \n    sigma_a0_k4 = np.abs(a0_k4**2) * np.sqrt(var_beta0_k4)\n    sigma_r0_k4 = 2.0 * np.sqrt(var_beta1_k4)\n\n    # --- 4. Calculate z-scores for comparison ---\n    # z = |val1 - val2| / sqrt(sigma1^2 + sigma2^2)\n    z_a0 = np.abs(a0_k2 - a0_k4) / np.sqrt(sigma_a0_k2**2 + sigma_a0_k4**2) if (sigma_a0_k2 > 0 or sigma_a0_k4 > 0) else 0.0\n    z_r0 = np.abs(r0_k2 - r0_k4) / np.sqrt(sigma_r0_k2**2 + sigma_r0_k4**2) if (sigma_r0_k2 > 0 or sigma_r0_k4 > 0) else 0.0\n    \n    return [a0_k2, r0_k2, a0_k4, r0_k4, z_a0, z_r0]\n\nsolve()\n```", "id": "3579075"}, {"introduction": "从数据中提取的参数不仅仅是数字，它们蕴含着关于底层物理的深刻信息，这些信息体现在散射振幅（S矩阵）的解析结构中。S矩阵在复动量平面上的极点对应于束缚态、虚态或共振态。这最后一个练习 [@problem_id:3578992] 将有效力程展开中的低能参数与这些基本物理概念联系起来。通过计算虚态极点的位置并数值验证修正的列文森定理（Levinson's theorem），您将具体理解S矩阵的抽象数学性质如何表现为可观测的近阈值现象。", "problem": "在分波分析框架内，考虑中心 $S$ 波通道中的无自旋核子-核子弹性散射。使用自然单位制，其中约化质量不显式出现，并使用低能有效力程展开作为 $S$ 波的计算模型。模型假设和定义如下。\n\n1. $S$ 波的 $S$ 矩阵定义为 $S_{0}(k) = \\exp\\!\\left(2 i \\delta_{0}(k)\\right)$，其中 $\\delta_{0}(k)$ 是作为在壳波数 $k$ 的函数的 $S$ 波相移。\n2. $S$ 波散射振幅与相移的关系为\n$$\nf_{0}(k) \\;=\\; \\frac{1}{k \\cot \\delta_{0}(k) - i k},\n$$\n这是短程势的幺正性和解析性的标准推论。\n3. 在足够低的能量下，$S$ 波相移遵循有效力程展开\n$$\nk \\cot \\delta_{0}(k) \\;=\\; -\\frac{1}{a} + \\frac{r_{e}}{2}\\,k^{2} + \\mathcal{O}(k^{4}),\n$$\n其中 $a$ 是散射长度，$r_{e}$ 是有效力程。在本问题中，忽略 $\\mathcal{O}(k^{4})$ 及更高阶项。\n\n使用此模型探讨与负虚 $k$ 轴上的极点相关的虚态效应，并在阈值附近数值验证修正的 Levinson 关系。虚态对应于 $f_{0}(k)$ 在 $k = - i \\kappa$（其中 $\\kappa  0$）处的极点，而束缚态对应于在 $k = + i \\kappa$（其中 $\\kappa  0$）处的极点。对于短程相互作用，假设高能极限满足 $\\delta_{0}(\\infty) = 0$。\n\n你的任务：\n\nA. 对于给定的参数 $(a, r_{e})$，通过在趋近于 $k \\to 0^{+}$ 的对数网格上评估 $\\delta_{0}(k)$ 并取其极限值，计算阈值相移 $\\delta_{0}(0)$（以弧度为单位）的数值稳定估计。具体来说，使用主支表示\n$$\n\\delta_{0}(k) \\;=\\; \\arctan2\\!\\left(k,\\, -\\frac{1}{a} + \\frac{r_{e}}{2}\\,k^{2}\\right),\n$$\n并用网格上最小 $k$ 处的值来近似 $\\delta_{0}(0)$。使用对数间隔的网格 $k \\in [10^{-6},\\,10^{-2}]$，单位为逆费米 (fm$^{-1}$)，角度以弧度为单位。对于无穷散射长度的特殊情况（即 $a = \\infty$，因此 $1/a = 0$），通过精确取极限 $-1/a \\to 0$ 来解释该公式。\n\nB. 使用相同的参数 $(a, r_{e})$，通过求解\n$$\n\\frac{r_{e}}{2}\\,\\kappa^{2} + \\kappa + \\frac{1}{a} \\;=\\; 0,\n$$\n中的 $\\kappa  0$ 来计算虚态极点位置。该方程由极点条件 $k \\cot \\delta_{0}(k) - i k = 0$ 在 $k = - i \\kappa$ 处求值得到。如果 $a = \\infty$，对于近阈值半束缚态的情况，取 $\\kappa = 0$。报告 $\\kappa$ 的值，单位为 fm$^{-1}$。\n\nC. 定义\n$$\n\\Delta \\;\\equiv\\; \\delta_{0}(0) - \\delta_{0}(\\infty),\n$$\n并且在短程假设 $\\delta_{0}(\\infty) = 0$ 下，计算 $m \\equiv \\Delta/\\pi$。根据短程相互作用的修正 Levinson 关系，对于没有束缚态的纯虚态情景，$m$ 应趋近于 $0$；而在存在零能半束缚态（无穷散射长度）的情况下，$m$ 应趋近于 $1/2$。数值验证这些行为。\n\n物理和数值单位：\n- 波数 $k$ 和极点位置 $\\kappa$ 必须以逆费米 (fm$^{-1}$) 表示。\n- 相移必须以弧度表示。\n- 整个过程中角度均以弧度处理。\n\n测试组：\n评估并报告以下三组参数集的结果，这些参数集旨在探究不同的近阈值行为：\n1. $(a, r_{e}) = (-2.0\\,\\text{fm},\\, 2.5\\,\\text{fm})$。\n2. $(a, r_{e}) = (-20.0\\,\\text{fm},\\, 2.5\\,\\text{fm})$。\n3. $(a, r_{e}) = (\\infty,\\, 2.5\\,\\text{fm})$。\n\n对于每个测试用例 $i \\in \\{1,2,3\\}$，你的程序必须计算：\n- $m_{i} = \\Delta_{i}/\\pi$，为一个浮点数，\n- $\\kappa_{i}$，单位为 fm$^{-1}$，为一个浮点数。\n\n最终输出格式：\n你的程序应生成单行输出，包含按顺序排列的六个结果 $[m_{1}, \\kappa_{1}, m_{2}, \\kappa_{2}, m_{3}, \\kappa_{3}]$，形式为一个用方括号括起来的逗号分隔列表。每个浮点数必须四舍五入到六位小数。例如：“[0.000000,0.123456,0.500000,0.000000,0.000000,0.987654]”。", "solution": "该问题是适定的、科学上合理的且内部一致的。它提供了一个计算量子散射理论中的标准练习，特别关注 $S$ 波核子-核子散射的低能有效力程展开。任务涉及计算虚态极点的位置，并为不同的散射参数区间验证修正的 Levinson 定理。我们可以继续进行完整解答。\n\n理论框架是针对 $S$ 波（轨道角动量 $l=0$）相移 $\\delta_{0}(k)$ 的低能有效力程展开（ERE），其中 $k$ 是在壳波数。忽略 $\\mathcal{O}(k^4)$ 及更高阶项的核心关系是\n$$\nk \\cot \\delta_{0}(k) = -\\frac{1}{a} + \\frac{r_{e}}{2}\\,k^{2}\n$$\n此处，$a$ 是 $S$ 波散射长度，$r_{e}$ 是有效力程。$S$ 波散射振幅 $f_{0}(k)$ 由下式给出\n$$\nf_{0}(k) = \\frac{1}{k \\cot \\delta_{0}(k) - i k}\n$$\n散射振幅在复 $k$ 平面上的极点具有深远的物理意义。虚态的特征是负虚轴上的一个极点，$k = -i\\kappa$ 且 $\\kappa  0$。极点条件是 $f_0(k)$ 的分母为零。将 ERE 和 $k = -i\\kappa$ 代入此条件 $k \\cot \\delta_{0}(k) - ik = 0$，得到：\n$$\n\\left(-\\frac{1}{a} + \\frac{r_{e}}{2}(-i\\kappa)^{2}\\right) - i(-i\\kappa) = 0\n$$\n$$\n-\\frac{1}{a} - \\frac{r_{e}}{2}\\kappa^{2} - \\kappa = 0\n$$\n两边乘以 $-1$ 得到关于虚态极点位置 $\\kappa$ 的二次方程：\n$$\n\\frac{r_{e}}{2}\\kappa^{2} + \\kappa + \\frac{1}{a} = 0\n$$\n我们必须为每个参数集 $(a, r_e)$ 求解此方程以找到 $\\kappa_i$。\n\n问题的第二部分涉及修正的 Levinson 定理，该定理将相移的行为与束缚态和半束缚态的数量联系起来。我们需要计算 $m = \\Delta/\\pi$，其中 $\\Delta = \\delta_{0}(0) - \\delta_{0}(\\infty)$。给定短程相互作用的假设 $\\delta_{0}(\\infty) = 0$，这简化为 $m = \\delta_0(0)/\\pi$。在没有束缚态的情况下（如 $a0$ 的虚态情景），$m$ 的值预期为 $0$；而在存在零能半束缚态的情况下（$a=\\infty$ 的情况），$m$ 的值预期为 $1/2$。\n\n为计算 $\\delta_0(0)$，我们使用所提供的主支表示：\n$$\n\\delta_{0}(k) = \\arctan2\\!\\left(y, x\\right) \\quad \\text{with} \\quad y=k, \\quad x = k \\cot \\delta_{0}(k) = -\\frac{1}{a} + \\frac{r_{e}}{2}\\,k^{2}\n$$\n我们通过在一个非常小的波数 $k_{min} = 10^{-6}\\,\\text{fm}^{-1}$ 处评估 $\\delta_0(k)$ 来数值近似 $\\delta_0(0)$。\n\n每个测试用例 $(a_i, r_{ei})$ 的计算过程如下：\n\n1.  **计算虚态极点位置 $\\kappa_i$**：\n    对于有限的 $a  0$，我们求解二次方程 $A\\kappa^2 + B\\kappa + C = 0$，其中 $A = r_e/2$, $B=1$, $C=1/a$。由于 $r_e  0$ 且 $a  0$，判别式 $B^2 - 4AC = 1 - 2r_e/a$ 大于 $1$，保证有两个实根。物理解必须满足 $\\kappa  0$，这对应于根：\n    $$\n    \\kappa = \\frac{-1 + \\sqrt{1 - 2r_{e}/a}}{r_{e}}\n    $$\n    对于 $a = \\infty$ 的特殊情况，问题指定取 $\\kappa = 0$，这与 $1/a \\to 0$ 时的二次方程是一致的。\n\n2.  **计算 Levinson 关系参数 $m_i$**：\n    首先，我们近似 $\\delta_0(0)$。我们使用 `arctan2` 函数评估 $\\delta_0(k_{min})$，其参数为 $y = k_{min}$ 和 $x = -1/a + (r_e/2)k_{min}^2$。\n    -   对于 $a  0$，当 $k_{min} \\to 0$ 时，$y \\to 0^+$ 且 $x \\to -1/a  0$。因此，$\\delta_0(0) = \\arctan2(0^+, \\text{正数}) = 0$。在小的 $k_{min}$ 处的数值评估将得到一个非常接近 $0$ 的值。\n    -   对于 $a = \\infty$，当 $k_{min} \\to 0$ 时，$y \\to 0^+$ 且 $x = (r_e/2)k_{min}^2 \\to 0^+$。比值 $y/x = 2/(r_e k_{min})$ 趋向于 $+\\infty$。这意味着角度趋近于 $\\pi/2$。因此，$\\delta_0(0) = \\pi/2$。数值评估将得到一个非常接近 $\\pi/2$ 的值。\n    最后，我们计算 $m_i = \\delta_0(k_{min}) / \\pi$。基于以上分析，我们预期对于 $a  0$ 的情况，$m_i \\approx 0$；对于 $a = \\infty$ 的情况，$m_i \\approx 0.5$。\n\n此过程应用于三个指定的测试用例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational nuclear physics problem for three test cases.\n    For each case (a, r_e), it computes the Levinson parameter m and the\n    virtual-state pole position kappa.\n    \"\"\"\n\n    def calculate_values(a, re):\n        \"\"\"\n        Calculates m and kappa for a given scattering length 'a' and effective range 're'.\n\n        Args:\n            a (float): The scattering length in fm. Can be np.inf.\n            re (float): The effective range in fm.\n\n        Returns:\n            tuple: A tuple containing (m, kappa).\n        \"\"\"\n        # Task A  C: Compute m = delta_0(0) / pi\n        # We approximate delta_0(0) by evaluating at a small k.\n        k_min = 1e-6  # fm^-1\n\n        if np.isinf(a):\n            inv_a = 0.0\n        else:\n            inv_a = 1.0 / a\n        \n        # Arguments for arctan2(y, x) where y = k and x = k*cot(delta_0)\n        x_arg = -inv_a + 0.5 * re * k_min**2\n        y_arg = k_min\n        delta_0_at_0_approx = np.arctan2(y_arg, x_arg)\n        \n        m = delta_0_at_0_approx / np.pi\n\n        # Task B: Compute the virtual-state pole position kappa\n        # This involves solving the quadratic equation: (re/2)*kappa^2 + kappa + 1/a = 0\n        kappa = 0.0\n        if np.isinf(a):\n            # For infinite scattering length, the pole is at zero energy (half-bound state).\n            kappa = 0.0\n        else:\n            # For a finite scattering length, solve the quadratic equation for kappa  0.\n            # The general solution is kappa = (-1 +/- sqrt(1 - 2*re/a)) / re.\n            # For a virtual state (a  0), the discriminant is  1.\n            # We select the '+' sign to ensure kappa  0.\n            discriminant = 1.0 - 2.0 * re / a\n            if discriminant = 0:\n                kappa = (-1.0 + np.sqrt(discriminant)) / re\n            else:\n                # This case (complex kappa) would not correspond to a simple virtual or bound state\n                # on the imaginary axis, and is not expected for the given problem parameters.\n                kappa = np.nan\n\n        return m, kappa\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (-2.0, 2.5),       # Case 1: (a, r_e) in fm\n        (-20.0, 2.5),      # Case 2\n        (np.inf, 2.5),     # Case 3: Infinite scattering length\n    ]\n\n    results = []\n    for case in test_cases:\n        a_val, re_val = case\n        m_val, kappa_val = calculate_values(a_val, re_val)\n        \n        # Append formatted results to the list\n        results.append(f\"{m_val:.6f}\")\n        results.append(f\"{kappa_val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3578992"}]}