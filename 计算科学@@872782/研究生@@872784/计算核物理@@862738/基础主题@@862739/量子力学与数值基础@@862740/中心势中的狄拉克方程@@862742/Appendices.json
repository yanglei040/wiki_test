{"hands_on_practices": [{"introduction": "在深入研究狄拉克方程的数值解之前，深刻理解其解的结构至关重要。本练习将通过解析计算自旋-轨道算符 $\\mathbf{L}\\cdot\\mathbf{S}$ 的期望值，来揭示狄拉克量子数 $\\kappa$ 如何巧妙地封装了总角动量、轨道角动量和自旋角动量之间的关系。这个推导不仅是角动量理论的基本应用，也为后续理解中心势中狄拉克旋量的物理内涵奠定了坚实的基础 [@problem_id:3598235]。", "problem": "一个自旋为 $s=\\frac{1}{2}$ 的核子在球对称平均场势 $V(r)$ 中运动，其行为由中心势中的狄拉克方程描述。经过变量分离后，狄拉克旋量的角向依赖性由旋量球谐函数 $\\Omega_{\\kappa m}(\\hat{\\mathbf{r}})$ 承载，该函数由总角动量 $j$、其投影 $m$ 和狄拉克量子数 $\\kappa$ 标记。总角动量算符为 $\\mathbf{J}=\\mathbf{L}+\\mathbf{S}$，其中 $\\mathbf{L}$ 是轨道角动量，$\\mathbf{S}$ 是自旋角动量。态 $\\Omega_{\\kappa m}$ 是 $\\mathbf{J}^{2}$、$\\mathbf{L}^{2}$ 和 $\\mathbf{S}^{2}$ 的本征函数，其本征值分别为 $j(j+1)\\hbar^{2}$、$l(l+1)\\hbar^{2}$ 和 $s(s+1)\\hbar^{2}$，其中 $l$ 是通过标准的旋量球谐函数关系与 $\\kappa$ 相关联的轨道角动量：当 $j=l+\\frac{1}{2}$ 时 $\\kappa=-(l+1)$，当 $j=l-\\frac{1}{2}$ 时 $\\kappa=+l$。仅关注角向部分，确定自旋-轨道算符 $\\mathbf{L}\\cdot\\mathbf{S}$ 在态 $\\Omega_{\\kappa m}$ 中的期望值，表示为\n$$\\langle \\mathbf{L}\\cdot\\mathbf{S} \\rangle = C\\,\\hbar^{2},$$\n并提供无量纲系数 $C$ 仅用 $\\kappa$ 和 $j$ 表示的闭式解析表达式。将你的最终答案表示为 $C$ 的解析表达式；无需进行数值计算。", "solution": "中心势 $V(r)$ 中的狄拉克方程存在 $\\mathbf{J}^{2}$、$J_{z}$、$\\mathbf{L}^{2}$ 和 $\\mathbf{S}^{2}$ 的共同本征态，因为该势是球对称的，因此与转动生成元对易。狄拉克旋量的角向依赖性体现在旋量球谐函数 $\\Omega_{\\kappa m}(\\hat{\\mathbf{r}})$ 中，这些函数在转动下是不可约的，并由总角动量 $j$、其投影 $m$ 和狄拉克量子数 $\\kappa$ 表征。根据其构造，这些谐函数满足\n$$\n\\mathbf{J}^{2}\\,\\Omega_{\\kappa m} = j(j+1)\\hbar^{2}\\,\\Omega_{\\kappa m}, \\quad\n\\mathbf{L}^{2}\\,\\Omega_{\\kappa m} = l(l+1)\\hbar^{2}\\,\\Omega_{\\kappa m}, \\quad\n\\mathbf{S}^{2}\\,\\Omega_{\\kappa m} = s(s+1)\\hbar^{2}\\,\\Omega_{\\kappa m},\n$$\n其中 $s=\\frac{1}{2}$。\n\n基本的角动量恒等式\n$$\n\\mathbf{J}^{2} = \\mathbf{L}^{2} + \\mathbf{S}^{2} + 2\\,\\mathbf{L}\\cdot\\mathbf{S}\n$$\n作为希尔伯特空间上的算符等式成立。在归一化态 $\\Omega_{\\kappa m}$ 中（角向部分，因此径向因子不参与）取期望值，我们得到\n$$\n\\langle \\mathbf{L}\\cdot\\mathbf{S} \\rangle = \\frac{1}{2}\\left(\\langle \\mathbf{J}^{2} \\rangle - \\langle \\mathbf{L}^{2} \\rangle - \\langle \\mathbf{S}^{2} \\rangle\\right).\n$$\n使用作用于 $\\Omega_{\\kappa m}$ 上的本征值，上式变为\n$$\n\\langle \\mathbf{L}\\cdot\\mathbf{S} \\rangle = \\frac{\\hbar^{2}}{2}\\left(j(j+1) - l(l+1) - s(s+1)\\right).\n$$\n对于一个核子，$s=\\frac{1}{2}$，所以 $s(s+1)=\\frac{3}{4}$。因此，\n$$\n\\langle \\mathbf{L}\\cdot\\mathbf{S} \\rangle = \\frac{\\hbar^{2}}{2}\\left(j(j+1) - l(l+1) - \\frac{3}{4}\\right).\n$$\n\n为了用 $\\kappa$ 和 $j$ 来表示这个结果，我们使用旋量球谐函数中 $\\kappa$ 和 $(l,j)$ 之间的定义关系：\n- 如果 $\\kappa  0$，则 $\\kappa=-(l+1)$ 且 $j=l+\\frac{1}{2}$，这意味着 $l=j-\\frac{1}{2}$。\n- 如果 $\\kappa > 0$，则 $\\kappa=+l$ 且 $j=l-\\frac{1}{2}$，这意味着 $l=j+\\frac{1}{2}$。\n\n我们在每种情况下计算 $j(j+1) - l(l+1) - \\frac{3}{4}$ 的值。\n\n情况 $\\kappa  0$ ($l=j-\\frac{1}{2}$):\n$$\nl(l+1) = \\left(j-\\frac{1}{2}\\right)\\left(j+\\frac{1}{2}\\right) = j^{2} - \\frac{1}{4},\n$$\n所以\n$$\nj(j+1) - l(l+1) - \\frac{3}{4} = \\left(j^{2}+j\\right) - \\left(j^{2}-\\frac{1}{4}\\right) - \\frac{3}{4}\n= j + \\frac{1}{4} - \\frac{3}{4} = j - \\frac{1}{2}.\n$$\n因此，\n$$\n\\langle \\mathbf{L}\\cdot\\mathbf{S} \\rangle = \\frac{\\hbar^{2}}{2}\\left(j - \\frac{1}{2}\\right), \\quad \\kappa  0.\n$$\n\n情况 $\\kappa > 0$ ($l=j+\\frac{1}{2}$):\n$$\nl(l+1) = \\left(j+\\frac{1}{2}\\right)\\left(j+\\frac{3}{2}\\right) = j^{2} + 2j + \\frac{3}{4},\n$$\n所以\n$$\nj(j+1) - l(l+1) - \\frac{3}{4} = \\left(j^{2}+j\\right) - \\left(j^{2}+2j+\\frac{3}{4}\\right) - \\frac{3}{4}\n= -j - \\frac{3}{2}.\n$$\n因此，\n$$\n\\langle \\mathbf{L}\\cdot\\mathbf{S} \\rangle = -\\frac{\\hbar^{2}}{2}\\left(j + \\frac{3}{2}\\right), \\quad \\kappa > 0.\n$$\n\n注意到 $j=|\\kappa| - \\frac{1}{2}$ 并且分段结果在代数上等价于\n$$\n\\langle \\mathbf{L}\\cdot\\mathbf{S} \\rangle = -\\frac{\\hbar^{2}}{2}\\left(\\kappa + 1\\right).\n$$\n这两个表达式可以仅用 $\\kappa$ 紧凑地写出。\n为了显式地验证这个统一形式：\n- 对于 $\\kappa  0$，$\\kappa+1 = -(l+1) + 1 = -l$，因此 $-\\frac{\\hbar^{2}}{2}(\\kappa+1) = \\frac{\\hbar^{2}}{2}l = \\frac{\\hbar^{2}}{2}\\left(j - \\frac{1}{2}\\right)$。\n- 对于 $\\kappa > 0$，$\\kappa+1 = l+1$，因此 $-\\frac{\\hbar^{2}}{2}(\\kappa+1) = -\\frac{\\hbar^{2}}{2}\\left(l+1\\right) = -\\frac{\\hbar^{2}}{2}\\left(j + \\frac{3}{2}\\right)$。\n\n因此，由 $\\langle \\mathbf{L}\\cdot\\mathbf{S} \\rangle = C\\,\\hbar^{2}$ 定义的无量纲系数 $C$ 是\n$$\nC = -\\frac{\\kappa + 1}{2}.\n$$\n这是一个用 $\\kappa$ 表示的闭式解析表达式（因此通过 $j=|\\kappa| - \\frac{1}{2}$ 也隐含地用 $j$ 表示），它对狄拉克中心势问题中所有的旋量球谐函数 $\\Omega_{\\kappa m}$ 都有效。", "answer": "$$\\boxed{-\\frac{\\kappa + 1}{2}}$$", "id": "3598235"}, {"introduction": "将狄拉克方程从连续的微分形式转化为可计算的离散形式，是计算物理学的核心任务之一，而径向坐标的离散化——即网格选择——是此过程的第一步，也是决定性的一步。本练习旨在通过一个计算实验，比较不同类型的径向网格（如均匀网格、对数网格和切比雪夫网格）在求解狄拉克方程时的表现。通过评估它们在描述波函数近原点和长程渐近行为上的精度，你将亲身体会到，恰当的网格选择对于获得物理上准确的数值解是多么重要 [@problem_id:3598244]。", "problem": "考虑一个在中心势中的自旋-$\\frac{1}{2}$粒子的球对称狄拉克方程，使用自然单位制，其中约化普朗克常数 $\\hbar$、光速 $c$ 均为1，质量 $m$ 被缩放为 $m=1$。在这些单位中，所有量都是无量纲的。状态矢量由一个双分量径向旋量 $(g(r), f(r))$ 表示，这两个分量通过使用旋量球谐函数分离变量后得到的一阶系统耦合在一起。总角动量量子数 $j$ 和轨道角动量 $l$ 被编码在狄拉克角量子数 $\\kappa$ 中，其标准关系定义为：当 $j = l + \\frac{1}{2}$ 时，$\\kappa = -(l+1)$；当 $j = l - \\frac{1}{2}$ 时，$\\kappa = +l$。对于球对称矢量势 $V(r)$，约化径向狄拉克方程的形式为\n$$\n\\frac{d g}{d r} = -\\frac{\\kappa}{r} g(r) + \\left(m + E - V(r)\\right) f(r),\n\\qquad\n\\frac{d f}{d r} = +\\frac{\\kappa}{r} f(r) - \\left(m - E + V(r)\\right) g(r),\n$$\n其中 $m=1$，束缚态能量 $E$ 满足 $0  E  m$。\n\n对于在原点 $r=0$ 处有限的中心势，正则性要求上分量在 $r \\to 0$ 时表现为 $g(r) \\propto r^{l+1}$，而下分量则被 $r$ 的高一次幂抑制。在大半径处，当 $V(r) \\to 0$ 且 $0  E  m$ 时，解以 $g(r) \\sim A \\exp(-\\lambda r)$ 的形式衰减，其渐近衰减率 $\\lambda$ 由自由狄拉克色散关系给出\n$$\n\\lambda = \\sqrt{m^2 - E^2}.\n$$\n您需要通过一个计算实验来评估，对于弱束缚能量 $E$，径向网格的选择如何影响近原点幂律行为和 大半径 $r$ 指数渐近行为的数值解析度。需要比较的三种网格类型是：\n- 均匀网格：$r_j = r_{\\min} + j \\Delta r$，其中 $j=0,1,\\dots,N-1$，$\\Delta r = \\frac{r_{\\max} - r_{\\min}}{N-1}$。\n- 基于 $x = \\ln r$ 的对数网格：$x_j = \\ln r_{\\min} + j \\Delta x$，其中 $\\Delta x = \\frac{\\ln r_{\\max} - \\ln r_{\\min}}{N-1}$，且 $r_j = \\exp(x_j)$。\n- 映射切比雪夫网格：定义切比雪夫节点 $\\xi_j = \\cos\\left(\\frac{j \\pi}{N-1}\\right)$，映射 $u_j = \\frac{1+\\xi_j}{2} \\in [0,1]$，并设置 $r_j = r_{\\min} + (r_{\\max} - r_{\\min}) u_j^p$，其中聚类指数 $p  1$ 用于在原点附近集中点。\n\n使用以下球对称 Woods–Saxon (WS) 矢量势，这是一个在计算核物理中经过充分检验的模型：\n$$\nV(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R}{a}\\right)},\n$$\n其中 $V_0$ 是深度，$R$ 是半径，$a$ 是弥散度。严格在上述指定的无量纲系统下工作。能量 $E$ 被设为一个参数，不必是 WS 势的精确本征值；在此任务中，它仅控制渐近衰减率和弱束缚的程度。\n\n算法要求：\n1. 在每个网格上，使用一致的显式二阶龙格－库塔方法（中点法），以局部步长 $\\Delta r_j = r_{j+1} - r_j$ 从 $r_{\\min}$ 到 $r_{\\max}$ 对耦合一阶系统进行外向积分。在 $r_{\\min}$ 处初始化正则解，使用 $g(r_{\\min}) = r_{\\min}^{l+1}$，$f(r_{\\min}) = 0$，其中 $l$ 根据关系式 $l = -\\kappa - 1$（对于 $\\kappa  0$）和 $l = \\kappa$（对于 $\\kappa > 0$）从 $\\kappa$ 计算得出。\n2. 通过对数值解的前 $M$ 个点的 $\\ln |g(r)|$ 与 $\\ln r$ 进行最小二乘线性拟合来估计近原点幂律指数 $\\alpha_{\\text{est}}$，其斜率即为指数的估计值。理论指数为 $\\alpha_{\\text{th}} = l + 1$。将近原点指数误差量化为\n$$\n\\varepsilon_{\\text{origin}} = |\\alpha_{\\text{est}} - \\alpha_{\\text{th}}|.\n$$\n3. 通过对数值解的最后 $L$ 个点的 $\\ln |g(r)|$ 与 $r$ 进行最小二乘线性拟合来估计大半径 $r$ 指数衰减率 $\\lambda_{\\text{est}}$，拟合仅限于 $|g(r)|$ 大于一个小的数值阈值的点，以避免下溢。理论衰减率为 $\\lambda_{\\text{th}} = \\sqrt{m^2 - E^2}$。将尾部误差量化为\n$$\n\\varepsilon_{\\text{tail}} = |\\lambda_{\\text{est}} - \\lambda_{\\text{th}}|.\n$$\n\n数值参数：\n- 所有网格使用 $r_{\\min} = 10^{-4}$，$r_{\\max} = 20$，以及 $N = 2000$ 个网格点。\n- 使用切比雪夫映射指数 $p = 2$。\n- 使用 Woods–Saxon 参数 $V_0 = 0.3$，$R = 5.0$，$a = 0.6$。\n- 使用 $M = 100$ 个点进行近原点拟合，使用 $L = 200$ 个点进行尾部拟合。\n- 在尾部拟合中使用一个小的阈值 $\\tau = 10^{-12}$ 来排除 $|g(r)|  \\tau$ 的点。\n\n测试套件：\n计算以下六个测试用例的 $\\varepsilon_{\\text{origin}}$ 和 $\\varepsilon_{\\text{tail}}$，每个用例由三元组 $(\\text{grid}, \\kappa, E)$ 指定：\n1. $(\\text{uniform}, -1, 0.95)$\n2. $(\\text{log}, -1, 0.95)$\n3. $(\\text{chebyshev}, -1, 0.95)$\n4. $(\\text{uniform}, -2, 0.99)$\n5. $(\\text{log}, -2, 0.99)$\n6. $(\\text{chebyshev}, -2, 0.99)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果；每个元素对应一个测试用例，并且必须是一个双元素列表，按顺序包含近原点误差和尾部误差。例如，输出格式必须如下所示\n$$\n[\\,[\\varepsilon_{\\text{origin},1},\\varepsilon_{\\text{tail},1}],\\,[\\varepsilon_{\\text{origin},2},\\varepsilon_{\\text{tail},2}],\\,\\dots,\\, [\\varepsilon_{\\text{origin},6},\\varepsilon_{\\text{tail},6}]\\,].\n$$\n不需要物理单位，因为计算在指定的自然单位制中是完全无量纲的，并且所有角度都与此径向问题无关。", "solution": "用户提供了一个相对论量子力学中的计算问题，特别关注于在中心 Woods-Saxon 势中径向狄拉克方程的数值解。任务是比较三种不同径向网格（均匀、对数、切比雪夫映射）在解析波函数在小半径和大半径处的特征行为时的数值精度。\n\n### 步骤 1：问题验证\n\n首先，我将提取给定信息并验证问题陈述。\n\n**已知条件：**\n- **方程系统**：在中心矢量势 $V(r)$ 中，关于双分量旋量 $(g(r), f(r))$ 的约化径向狄拉克方程：\n    $$\n    \\frac{d g}{d r} = -\\frac{\\kappa}{r} g(r) + \\left(m + E - V(r)\\right) f(r)\n    $$\n    $$\n    \\frac{d f}{d r} = +\\frac{\\kappa}{r} f(r) - \\left(m - E + V(r)\\right) g(r)\n    $$\n- **常数和单位**：自然单位制，$\\hbar=1$，$c=1$，粒子质量 $m=1$。束缚态能量 $E$ 满足 $0  E  m$。\n- **狄拉克量子数 $\\kappa$**：定义为当 $j = l + \\frac{1}{2}$ 时 $\\kappa = -(l+1)$，当 $j = l - \\frac{1}{2}$ 时 $\\kappa = +l$。轨道角动量 $l$ 由 $l = \\kappa$（若 $\\kappa > 0$）和 $l = -\\kappa - 1$（若 $\\kappa  0$）导出。\n- **势**：球对称 Woods-Saxon 矢量势：\n    $$\n    V(r) = -\\frac{V_0}{1 + \\exp\\left(\\frac{r - R}{a}\\right)}\n    $$\n- **渐近行为**：\n    - 近原点 ($r \\to 0$)：$g(r) \\propto r^{\\alpha_{\\text{th}}}$，其中 $\\alpha_{\\text{th}} = l+1$。\n    - 大半径 ($r \\to \\infty$)：$g(r) \\sim A \\exp(-\\lambda_{\\text{th}} r)$，其中 $\\lambda_{\\text{th}} = \\sqrt{m^2 - E^2}$。\n- **网格类型**：\n    1.  **均匀**：$r_j = r_{\\min} + j \\Delta r$，$\\Delta r = \\frac{r_{\\max} - r_{\\min}}{N-1}$。\n    2.  **对数**：$r_j = \\exp(\\ln r_{\\min} + j \\Delta x)$，$\\Delta x = \\frac{\\ln r_{\\max} - \\ln r_{\\min}}{N-1}$。\n    3.  **切比雪夫映射**：$r_j = r_{\\min} + (r_{\\max} - r_{\\min}) \\left(\\frac{1+\\cos(j \\pi/(N-1))}{2}\\right)^p$。\n- **数值参数**：\n    - 积分范围：$r_{\\min} = 10^{-4}$，$r_{\\max} = 20$。\n    - 网格点数：$N = 2000$。\n    - 切比雪夫映射指数：$p = 2$。\n    - Woods-Saxon 参数：$V_0 = 0.3$，$R = 5.0$，$a = 0.6$。\n    - 拟合区域：$M = 100$（原点），$L = 200$（尾部）。\n    - 尾部拟合阈值：$\\tau = 10^{-12}$。\n- **算法**：\n    1.  使用显式二阶龙格－库塔（中点）方法积分系统。\n    2.  在 $r_{\\min}$ 处使用 $g(r_{\\min}) = r_{\\min}^{l+1}$ 和 $f(r_{\\min}) = 0$ 初始化解。\n    3.  通过对前 $M$ 个点的 $\\ln|g(r)|$ vs. $\\ln r$ 进行最小二乘拟合，估计近原点指数 $\\alpha_{\\text{est}}$。\n    4.  通过对后 $L$ 个点（满足 $|g(r)| > \\tau$）的 $\\ln|g(r)|$ vs. $r$ 进行最小二乘拟合，估计尾部衰减率 $\\lambda_{\\text{est}}$。\n    5.  计算误差：$\\varepsilon_{\\text{origin}} = |\\alpha_{\\text{est}} - \\alpha_{\\text{th}}|$ 和 $\\varepsilon_{\\text{tail}} = |\\lambda_{\\text{est}} - \\lambda_{\\text{th}}|$。\n- **测试套件**：由 $(\\text{grid}, \\kappa, E)$ 定义的六个测试用例：\n    1. $(\\text{uniform}, -1, 0.95)$\n    2. $(\\text{log}, -1, 0.95)$\n    3. $(\\text{chebyshev}, -1, 0.95)$\n    4. $(\\text{uniform}, -2, 0.99)$\n    5. $(\\text{log}, -2, 0.99)$\n    6. $(\\text{chebyshev}, -2, 0.99)$\n- **输出格式**：单行列表的列表：$[[\\varepsilon_{\\text{origin},1},\\varepsilon_{\\text{tail},1}], \\dots, [\\varepsilon_{\\text{origin},6},\\varepsilon_{\\text{tail},6}]]$。\n\n**验证结论：**\n- **具有科学依据**：该问题基于相对论量子力学的基石——狄拉克方程，并使用了一个标准模型势（Woods-Saxon）。指定的渐近行为是正确的。所选的单位制是标准做法。该问题在科学上是合理的。\n- **适定的**：该任务是一个定义明确的计算实验。它涉及求解一个常微分方程组 (ODEs) 的初值问题，鉴于势和系数在 $r > 0$ 时是光滑的，该问题是适定的。分析过程（例如最小二乘拟合）是明确的。\n- **客观性**：问题以精确、定量的术语陈述，没有主观性。\n- **完整性和一致性**：提供了所有必要的参数、方程和算法。没有矛盾之处。能量值 $E  m$ 与束缚态假设和指数衰减相符。积分通过从 $r_{\\min} > 0$ 开始，避免了 $r=0$ 处的坐标奇点。\n\n该问题是**有效的**。这是一个标准且表述良好的计算物理练习。\n\n### 步骤 2：求解设计\n\n解法将以一个 Python 脚本的形式实现，并遵循指定的执行环境。整体结构将包含一个遍历六个测试用例的主循环。对于每个用例，脚本将执行网格生成、数值积分和误差分析。\n\n**1. 理论量：**\n对于每个测试用例 $(\\kappa, E)$，我们首先计算理论参考值。\n- 轨道角动量量子数 $l$ 从 $\\kappa$ 计算得出。由于所有测试用例的 $\\kappa  0$，公式为 $l = -\\kappa - 1$。\n- 理论近原点指数为 $\\alpha_{\\text{th}} = l+1$。\n- 理论大半径衰减率为 $\\lambda_{\\text{th}} = \\sqrt{m^2 - E^2}$，其中 $m=1$。\n\n**2. 网格生成：**\n一个函数将根据指定的类型（`'uniform'`, `'log'`, 或 `'chebyshev'`）以及参数 $r_{\\min}$、$r_{\\max}$、$N$ 和 $p$ 来生成径向网格 `r`。非均匀网格（对数网格和切比雪夫映射网格）预计在 $r=0$ 附近提供更高的分辨率，这应该会提高近原点分析的准确性。\n\n**3. ODE 系统与积分：**\n耦合的一阶狄拉克方程定义了待解系统。该系统的右侧 (RHS) 将被封装在一个函数 `dirac_rhs(r, g, f, ...)` 中。\n积分将通过一个实现二阶龙格－库塔（中点）方法的循环来执行。对于从 $r_j$到 $r_{j+1}$ 的每一步，步长为 $\\Delta r_j = r_{j+1} - r_j$：\n令状态矢量为 $\\mathbf{y} = (g, f)^T$，RHS 函数为 $\\mathbf{F}(r, \\mathbf{y})$。\n1.  计算中点斜率：$\\mathbf{k}_1 = \\mathbf{F}(r_j, \\mathbf{y}_j)$。\n2.  估计中点状态：$\\mathbf{y}_{\\text{mid}} = \\mathbf{y}_j + \\frac{\\Delta r_j}{2} \\mathbf{k}_1$。\n3.  计算中点处的最终斜率：$\\mathbf{k}_2 = \\mathbf{F}(r_j + \\frac{\\Delta r_j}{2}, \\mathbf{y}_{\\text{mid}})$。\n4.  更新状态：$\\mathbf{y}_{j+1} = \\mathbf{y}_j + \\Delta r_j \\mathbf{k}_2$。\n积分从 $r_0 = r_{\\min}$ 处的初始条件开始：$g_0 = r_{\\min}^{l+1}$ 和 $f_0 = 0$。生成的数组 `g_sol` 和 `f_sol` 将存储完整的数值解。\n\n**4. 误差分析：**\n两个独立的程序将分析数值解 `g_sol`。\n- **近原点误差 ($\\varepsilon_{\\text{origin}}$)**：我们取解的前 $M$ 个点，即 $(r_j, g_j)$ for $j=0, \\dots, M-1$。我们对变换后的数据 $(\\ln r_j, \\ln|g_j|)$ 进行线性回归。此拟合的斜率给出 $\\alpha_{\\text{est}}$。然后误差为 $\\varepsilon_{\\text{origin}} = |\\alpha_{\\text{est}} - \\alpha_{\\text{th}}|$。\n- **尾部误差 ($\\varepsilon_{\\text{tail}}$)**：我们取解的最后 $L$ 个点，即 $(r_j, g_j)$ for $j=N-L, \\dots, N-1$。我们首先过滤掉 $|g_j|  \\tau=10^{-12}$ 的点，以避免在对数计算中出现数值噪声和下溢问题。对剩余的点，我们对 $(r_j, \\ln|g_j|)$ 进行线性回归。此拟合的斜率（将为负值）给出 $-\\lambda_{\\text{est}}$。然后误差为 $\\varepsilon_{\\text{tail}} = |\\lambda_{\\text{est}} - \\lambda_{\\text{th}}|$。\n对于两个拟合，将使用 `numpy.polyfit(x, y, 1)` 来高效计算最佳拟合线的斜率。\n\n**5. 最终组装：**\n主函数将为六个指定的测试用例中的每一个协调这些步骤。每个用例的误差对 $(\\varepsilon_{\\text{origin}}, \\varepsilon_{\\text{tail}})$ 将被收集到一个列表的列表中。最后，这个数据结构将被格式化为所需的字符串表示形式并打印到标准输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the Dirac equation on different grids and computes numerical errors.\n    \"\"\"\n    # Define the global parameters from the problem statement.\n    m = 1.0  # Scaled mass\n    r_min = 1e-4\n    r_max = 20.0\n    N = 2000\n    p = 2.0  # Chebyshev mapping exponent\n    V0 = 0.3\n    R = 5.0\n    a = 0.6\n    M = 100  # Number of points for origin fit\n    L = 200  # Number of points for tail fit\n    tau = 1e-12 # Threshold for tail fit\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('uniform', -1, 0.95),\n        ('log', -1, 0.95),\n        ('chebyshev', -1, 0.95),\n        ('uniform', -2, 0.99),\n        ('log', -2, 0.99),\n        ('chebyshev', -2, 0.99),\n    ]\n\n    def generate_grid(grid_type, N_pts, rmin, rmax, p_exp):\n        \"\"\"Generates the radial grid.\"\"\"\n        if grid_type == 'uniform':\n            return np.linspace(rmin, rmax, N_pts)\n        elif grid_type == 'log':\n            return np.geomspace(rmin, rmax, N_pts)\n        elif grid_type == 'chebyshev':\n            # Chebyshev nodes on [-1, 1]\n            xi = np.cos(np.pi * np.arange(N_pts) / (N_pts - 1))\n            # Map to u in [0, 1] (reversed to start from r_min)\n            u = (1.0 - xi) / 2.0\n            # Map to r in [r_min, r_max] with clustering\n            return rmin + (rmax - rmin) * (u ** p_exp)\n        else:\n            raise ValueError(\"Unknown grid type\")\n\n    def woods_saxon(r, V0_p, R_p, a_p):\n        \"\"\"Calculates the Woods-Saxon potential.\"\"\"\n        return -V0_p / (1.0 + np.exp((r - R_p) / a_p))\n\n    def dirac_rhs(r, g, f, kappa, E):\n        \"\"\"Computes the right-hand side of the radial Dirac equations.\"\"\"\n        V_r = woods_saxon(r, V0, R, a)\n        # Handle r=0 case, though integration starts at r_min > 0\n        if r == 0:\n            return 0.0, 0.0\n        dg_dr = -kappa / r * g + (m + E - V_r) * f\n        df_dr = kappa / r * f - (m - E + V_r) * g\n        return dg_dr, df_dr\n\n    def integrate_dirac(r_grid, kappa, E):\n        \"\"\"\n        Integrates the Dirac system using the midpoint (RK2) method.\n        \"\"\"\n        # Determine l from kappa\n        if kappa > 0:\n            l = kappa\n        else: # kappa  0\n            l = -kappa - 1\n\n        g_sol = np.zeros_like(r_grid)\n        f_sol = np.zeros_like(r_grid)\n\n        # Initial conditions at r_min\n        g_sol[0] = r_grid[0] ** (l + 1)\n        f_sol[0] = 0.0\n        \n        # Integration loop using RK2\n        for j in range(N - 1):\n            r_j = r_grid[j]\n            g_j, f_j = g_sol[j], f_sol[j]\n            h = r_grid[j+1] - r_j\n\n            # k1\n            k1_g, k1_f = dirac_rhs(r_j, g_j, f_j, kappa, E)\n            \n            # Midpoint evaluation\n            r_mid = r_j + h / 2.0\n            g_mid = g_j + h / 2.0 * k1_g\n            f_mid = f_j + h / 2.0 * k1_f\n\n            # k2\n            k2_g, k2_f = dirac_rhs(r_mid, g_mid, f_mid, kappa, E)\n\n            # Update\n            g_sol[j+1] = g_j + h * k2_g\n            f_sol[j+1] = f_j + h * k2_f\n            \n        return g_sol, f_sol\n\n    def calculate_errors(r_grid, g_sol, kappa, E):\n        \"\"\"\n        Calculates near-origin and tail errors from the numerical solution.\n        \"\"\"\n        # Theoretical values\n        if kappa > 0:\n            l = kappa\n        else:\n            l = -kappa - 1\n            \n        alpha_th = l + 1.0\n        lambda_th = np.sqrt(m**2 - E**2)\n\n        # Near-origin fit\n        r_origin = r_grid[:M]\n        g_origin = g_sol[:M]\n        \n        # Filter out any points where g is numerically zero to avoid log(0)\n        valid_origin_indices = np.where(np.abs(g_origin)>0)\n        log_r_origin = np.log(r_origin[valid_origin_indices])\n        log_g_origin = np.log(np.abs(g_origin[valid_origin_indices]))\n        \n        if len(log_r_origin)  2: # Not enough points for a fit\n            alpha_est = np.nan\n        else:\n            alpha_est = np.polyfit(log_r_origin, log_g_origin, 1)[0]\n        \n        eps_origin = np.abs(alpha_est - alpha_th)\n\n        # Tail fit\n        r_tail = r_grid[-L:]\n        g_tail = g_sol[-L:]\n        \n        valid_tail_indices = np.where(np.abs(g_tail) > tau)\n        r_tail_fit = r_tail[valid_tail_indices]\n        g_tail_fit = g_tail[valid_tail_indices]\n        \n        if len(r_tail_fit)  2: # Not enough points for a fit\n            lambda_est = np.nan\n        else:\n            log_g_tail = np.log(np.abs(g_tail_fit))\n            slope_tail = np.polyfit(r_tail_fit, log_g_tail, 1)[0]\n            lambda_est = -slope_tail\n        \n        eps_tail = np.abs(lambda_est - lambda_th)\n\n        return [eps_origin, eps_tail]\n\n    results = []\n    for case in test_cases:\n        grid_type, kappa, E = case\n        \n        # 1. Generate grid\n        r = generate_grid(grid_type, N, r_min, r_max, p)\n        \n        # 2. Integrate\n        g, f = integrate_dirac(r, kappa, E)\n        \n        # 3. Calculate errors\n        errors = calculate_errors(r, g, kappa, E)\n        results.append(errors)\n    \n    # Format the final output string\n    # e.g., [[err1, err2], [err3, err4]]\n    result_str = '[' + ','.join([f\"[{e[0]},{e[1]}]\" for e in results]) + ']'\n    print(result_str)\n\nsolve()\n```", "id": "3598244"}, {"introduction": "一个数值解，无论其计算过程多么复杂，如果它违背了系统所遵循的基本物理定律，那么它就是没有意义的。对于狄拉克方程而言，概率守恒是一个必须严格满足的根本要求，它体现为概率流的连续性方程。本练习将指导你编写一个程序，通过数值方法来检验狄拉克方程解的概率流守恒性质，例如验证束缚态的总流出为零，以及散射态的流在空间中保持不变。这项实践是验证数值求解器正确性和可靠性的关键步骤 [@problem_id:3598169]。", "problem": "你的任务是推导并实现一个对球对称（中心）势中狄拉克方程解的径向概率流的计算验证，该验证适用于计算核物理的背景。所有推导和计算都必须在自然单位制下进行，其中 $\\hbar = c = 1$，静止质量为 $m=1$。在此单位制中，径向概率流密度 $j_r(r)$ 的单位是长度的平方分之一，而通过半径为 $r$ 的球面的总径向通量是 $J(r) = r^2 j_r(r)$，该量是无量纲的。你的实现必须对特定的测试案例数值积分狄拉克径向方程，并返回布尔值结果来验证基于物理的性质。最终输出必须是单行，包含一个由方括号括起来的逗号分隔列表。\n\n从具有球对称（中心）势 $V(r)$ 和由狄拉克量子数 $\\kappa$ 表征的总角动量量子数的定态狄拉克方程出发，旋量 $\\psi(\\mathbf{r})$ 可以分解为径向函数 $F(r)$ 和 $G(r)$ 与旋量球谐函数的乘积。狄拉克方程简化为关于径向函数 $F(r)$ 和 $G(r)$ 的耦合一阶常微分方程组。对于固定的能量 $E$、质量 $m$ 和势 $V(r)$，其通用形式为\n$$\n\\frac{dF}{dr} = -\\frac{\\kappa}{r} F + \\big(E - V(r) + m\\big) G, \\quad\n\\frac{dG}{dr} = +\\frac{\\kappa}{r} G - \\big(E - V(r) - m\\big) F.\n$$\n这些方程是通过在球坐标下使用旋量球谐函数对狄拉克方程进行标准的分离变量法得到的。概率密度和概率流满足连续性方程，概率流密度由 $\\mathbf{j}(\\mathbf{r}) = \\psi^\\dagger(\\mathbf{r}) \\boldsymbol{\\alpha} \\psi(\\mathbf{r})$ 给出，其中 $\\boldsymbol{\\alpha}$ 表示标准表象中的狄拉克矩阵矢量。径向分量 $j_r(r)$ 和总径向通量 $J(r)$ 可以通过使用旋量球谐函数的性质和定态的连续性方程，用径向函数 $F(r)$ 和 $G(r)$ 来推导。根据这些原理，必须证明，对于在完整旋量中以 $(F(r)/r, i\\,G(r)/r)$ 形式出现的约化径向函数，通过球面的总通量满足\n$$\nJ(r) = r^2 j_r(r) = 2 \\,\\mathrm{Im}\\!\\big(F^*(r)\\,G(r)\\big),\n$$\n并且对于具有实势 $V(r)$ 的定态，$J(r)$ 与 $r$ 无关。\n\n此外，对于具有相同实值 $E$ 和 $V(r)$ 的同一一阶方程组的任意两个线性无关解 $\\big(F_1(r),G_1(r)\\big)$ 和 $\\big(F_2(r),G_2(r)\\big)$，由下式定义的朗斯基行列式（Wronskian）：\n$$\nW(r) = F_1(r)\\,G_2(r) - G_1(r)\\,F_2(r)\n$$\n是一个不随 $r$ 变化的常数。这种恒定性是一阶线性系统 Liouville 公式以及狄拉克径向系统中出现的系数矩阵的迹为零的结果。\n\n你的程序必须对以下测试套件数值求解狄拉克径向方程，并返回布尔值结果以验证其基本物理性质：\n\n- 测试案例 1 (束缚态通量为零)：使用方势阱中心势 $V(r) = -V_0$（对于 $0 \\le r  R$）和 $V(r) = 0$（对于 $r \\ge R$），参数为 $V_0 = 5.0$，$R = 2.0$，静止质量 $m = 1.0$，能量 $E = 0.8$（低于 $m$），以及狄拉克量子数 $\\kappa = -1$（对应于最低总角动量通道）。使用原点附近的正则初始条件，将径向系统从一个小的半径 $r_0 = 10^{-4}$ 向外积分到 $r_{\\max} = 10.0$。沿着积分网格计算总通量 $J(r)$，并验证网格上 $J(r)$ 的最大绝对值低于容差 $\\varepsilon = 10^{-6}$，这反映了在实势中，一个静态、可归一化的束缚态的净通量为零。返回一个布尔值，指示是否 $\\max_r |J(r)|  \\varepsilon$。\n\n- 测试案例 2 (阈值附近的散射态通量守恒)：使用自由粒子情况 $V(r) = 0$，其中 $m = 1.0$，能量 $E = 1.05$（略高于阈值），以及 $\\kappa = -1$。在原点附近构造一个复数初始条件以生成一个具有非零流的解，并如上所述向外积分至 $r_{\\max} = 10.0$。在网格上计算 $J(r)$，并通过检查 $\\max_r |J(r) - J(r_0)|$ 是否低于 $\\varepsilon = 10^{-6}$ 来验证其恒定性。返回一个布尔值，指示通量是否在容差范围内保持恒定。\n\n- 测试案例 3 (在弱短程势中通过朗斯基行列式验证散射态的流入/流出匹配)：使用弱高斯中心势 $V(r) = -V_0 \\exp\\big(-r^2/a^2\\big)$，参数为 $V_0 = 0.2$，$a = 1.0$，质量 $m = 1.0$，能量 $E = 1.5$，以及 $\\kappa = -1$。通过在 $r_0 = 10^{-4}$ 处使用复共轭初始条件构造两个线性无关解，将两者都积分到 $r_{\\max} = 10.0$，并计算 $J_1(r)$ 和 $J_2(r)$，以及朗斯基行列式 $W(r)$。验证两个性质：(i) 朗斯基行列式在网格上于容差 $\\varepsilon = 10^{-6}$ 内保持恒定，即 $\\max_r |W(r) - W(r_0)|  \\varepsilon$，以及 (ii) 流入/流出匹配成立，即 $\\max_r |J_1(r) + J_2(r)|  \\varepsilon$，这表明在实势中，复共轭解的流相互抵消。返回一个布尔值，指示两个条件是否都满足。\n\n实现要求：\n\n- 使用自然单位制，其中 $\\hbar=c=1$ 和 $m=1$。所有流 $j_r(r)$ 都隐式地以长度平方分之一为单位表示，通量 $J(r)$ 是无量纲的。程序必须计算并使用 $J(r) = 2\\,\\mathrm{Im}(F^*(r) G(r))$ 和 $j_r(r) = J(r)/r^2$。\n\n- 数值积分必须针对复数值的 $F(r)$ 和 $G(r)$ 实现，使用一种稳定的显式方法，如四阶 Runge–Kutta 方法，并采用固定的步长以确保测试的收敛性。对于束缚态情况，使用原点附近的正则初始条件（对于 $\\kappa = -1$，可以取 $F(r_0) \\propto r_0$ 和 $G(r_0)$ 与 $r_0$ 或 $r_0^2$ 成正比，以符合正则性要求）；对于散射情况，使用复数值初始条件。\n\n- 最终输出必须是单行，分别包含测试案例 1、测试案例 2 和测试案例 3 的布尔结果，形式为一个由方括号括起来的逗号分隔列表，例如 \"[True,True,False]\"。\n\n你的程序必须产生单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果（例如，\"[result1,result2,result3]\"）。", "solution": "该问题要求对中心势中定态狄拉克方程解的基本性质进行计算验证。具体来说，我们需要对三种不同的物理情景数值积分狄拉克径向方程，并验证 (i) 束缚态概率通量的消失，(ii) 散射态通量的守恒，以及 (iii) 朗斯基行列式（Wronskian）的恒定性和复共轭解通量的抵消。\n\n### 1. 理论框架\n\n出发点是中心势 $V(r)$ 中狄拉克旋量的径向分量 $F(r)$ 和 $G(r)$ 的耦合一阶常微分方程组。在自然单位制（$\\hbar=c=m=1$）下，它们是：\n$$\n\\frac{dF}{dr} = -\\frac{\\kappa}{r} F(r) + \\big(E - V(r) + 1\\big) G(r)\n$$\n$$\n\\frac{dG}{dr} = +\\frac{\\kappa}{r} G(r) - \\big(E - V(r) - 1\\big) F(r)\n$$\n其中 $E$ 是能量，$\\kappa$ 是狄拉克量子数。\n\n单位立体角的径向概率通量 $J(r)$ 定义为 $J(r) = r^2 j_r(r)$，其中 $j_r(r)$ 是概率流密度 $\\mathbf{j} = \\psi^\\dagger \\boldsymbol{\\alpha} \\psi$ 的径向分量。用径向函数 $F(r)$ 和 $G(r)$ 表示，通量由下式给出：\n$$\nJ(r) = 2 \\, \\mathrm{Im}\\big(F^*(r) G(r)\\big)\n$$\n\n对于实值势 $V(r)$ 中的定态，连续性方程 $\\nabla \\cdot \\mathbf{j} = 0$ 意味着通过任何以原点为中心的球面的总通量必须是恒定的。这意味着 $\\frac{d}{dr}(r^2 j_r(r)) = 0$，从而得出 $J(r)$ 与 $r$ 无关的结论。我们可以直接从径向方程中验证这一点。将 $J(r)$ 对 $r$ 求导得到：\n$$\n\\frac{dJ}{dr} = 2 \\, \\mathrm{Im}\\left(\\frac{dF^*}{dr} G + F^* \\frac{dG}{dr}\\right)\n$$\n代入导数的表达式（及其复共轭，注意 $E, V, \\kappa, m$ 都是实数）：\n$$\n\\frac{dF^*}{dr} = -\\frac{\\kappa}{r} F^* + (E - V + 1) G^*\n$$\n$$\n\\frac{dG}{dr} = \\frac{\\kappa}{r} G - (E - V - 1) F\n$$\n我们发现：\n$$\n\\frac{dJ}{dr} = 2 \\, \\mathrm{Im}\\left[ \\left(-\\frac{\\kappa}{r} F^* + (E-V+1)G^*\\right)G + F^*\\left(\\frac{\\kappa}{r}G - (E-V-1)F\\right) \\right]\n$$\n$$\n\\frac{dJ}{dr} = 2 \\, \\mathrm{Im}\\left[ -\\frac{\\kappa}{r}F^*G + (E-V+1)|G|^2 + \\frac{\\kappa}{r}F^*G - (E-V-1)|F|^2 \\right]\n$$\n$$\n\\frac{dJ}{dr} = 2 \\, \\mathrm{Im}\\left[ (E-V+1)|G|^2 - (E-V-1)|F|^2 \\right]\n$$\n由于 $|F|^2$、$|G|^2$、$E$、$V$ 和质量 $m=1$ 都是实数量，$\\mathrm{Im}[\\cdot]$ 的宗量是纯实数。因此，$\\frac{dJ}{dr} = 0$，这证实了 $J(r)$ 是一个常数。\n\n对于同一径向系统的任意两个线性无关解 $(F_1, G_1)$ 和 $(F_2, G_2)$，朗斯基行列式（Wronskian）定义为 $W(r) = F_1(r)G_2(r) - G_1(r)F_2(r)$。该径向系统可以写成矩阵形式 $\\frac{d\\mathbf{y}}{dr} = A(r)\\mathbf{y}$，其中 $\\mathbf{y} = [F, G]^T$，系数矩阵 $A(r)$ 的迹为 $\\mathrm{Tr}(A(r)) = -\\kappa/r + \\kappa/r = 0$。根据 Abel 恒等式，朗斯基行列式的导数由 $\\frac{dW}{dr} = \\mathrm{Tr}(A(r))W(r)$ 给出，这意味着 $\\frac{dW}{dr} = 0$。因此，朗斯基行列式 $W(r)$ 必须是常数。\n\n### 2. 数值实现\n\n解决方案的核心是用于求解两个复数值一阶常微分方程组的数值积分器。按照规定，实现了一个采用固定步长的四阶 Runge-Kutta (RK4) 方法。\n\n#### 原点附近的初始条件\n方程在 $r=0$ 处是奇异的。我们必须在一个小的半径 $r_0 > 0$ 处开始积分，并使用对应于正则解的初始条件。一个正则解要求旋量分量在原点处是有限的，对于给定的定义，这意味着 $F(r)/r$ 和 $G(r)/r$ 是有限的。对于 $\\kappa=-1$，大分量 $F(r)$ 对应于 s 波（$l=0$），小分量 $G(r)$ 对应于 p 波（$l=1$）。这意味着对于小的 $r$，其行为为 $F(r) \\sim c_1 r$ 和 $G(r) \\sim c_2 r^2$。将这些形式代入 $\\kappa=-1$ 的第二个径向方程中：\n$$\n\\frac{d(c_2 r^2)}{dr} = -\\frac{1}{r}(c_2 r^2) - (E - V(r) - 1)(c_1 r)\n$$\n$$\n2c_2 r = -c_2 r - (E - V(0) - 1) c_1 r\n$$\n$$\n3c_2 = -(E - V(0) - 1) c_1\n$$\n这提供了系数之间的关系：$c_2 = -\\frac{1}{3}(E-V(0)-1)c_1$。我们可以选择归一化常数 $c_1$，然后确定 $c_2$。对于从 $r_0$ 开始的数值积分，我们设置：\n$$\nF(r_0) = c_1 r_0 \\quad \\text{and} \\quad G(r_0) = -\\frac{1}{3}(E - V(r_0) - 1) c_1 r_0^2\n$$\n常数 $c_1$ 可以是实数或复数。\n\n### 3. 测试案例与验证\n\n程序执行三个测试，每个测试验证一个物理性质。所有案例都使用一个从 $r_0 = 10^{-4}$ 到 $r_{\\max} = 10.0$，步数为 $N=20000$ 的固定积分网格。所有检查的容差为 $\\varepsilon = 10^{-6}$。\n\n**测试案例 1：束缚态通量为零**\n- **原理**：在实势中，一个可归一化的定态束缚态其净概率流为零。这样的解可以用实值径向函数 $F(r)$ 和 $G(r)$ 来描述，对于这些函数，$J(r) = 2 \\, \\mathrm{Im}(F^*G) = 2 \\, \\mathrm{Im}(FG) = 0$。\n- **设置**：一个方势阱 $V(r) = -5.0$（对于 $r2.0$）和 $V(r)=0$（对于 $r \\ge 2.0$），束缚态能量 $E = 0.8  m=1.0$，且 $\\kappa=-1$。\n- **实现**：我们选择一个实数归一化常数 $c_1=1.0$。初始条件为 $F(r_0)=r_0$ 和 $G(r_0) = \\frac{1}{3}(E+V_0-1)r_0^2$。积分后，计算通量 $J(r)$。\n- **验证**：如果 $\\max_r |J(r)|  \\varepsilon$，则测试通过。\n\n**测试案例 2：散射态通量守恒**\n- **原理**：对于任何定态解（束缚态或散射态），通量 $J(r)$ 必须是恒定的，这是从连续性方程推导出来的。\n- **设置**：一个自由粒子（$V(r)=0$），散射能量 $E = 1.05 > m=1.0$，且 $\\kappa=-1$。为了产生非零流，需要一个复数解。\n- **实现**：我们选择一个复数归一化常数 $c_1 = 1.0 + 1.0j$。使用这个复数 $c_1$ 按上述方法计算初始条件 $F(r_0)$ 和 $G(r_0)$。积分后，在整个网格上计算通量 $J(r)$。\n- **验证**：如果守恒性成立，即 $\\max_r |J(r) - J(r_0)|  \\varepsilon$，则测试通过。\n\n**测试案例 3：朗斯基行列式（Wronskian）恒定性与流入/流出匹配**\n- **原理**：此测试同时检验两个性质：(i) 两个线性无关解的朗斯基行列式是常数的数学性质，以及 (ii) 对于实势，如果 $(F_1, G_1)$ 是一个解，那么它的复共轭 $(F_1^*, G_1^*)$ 也是一个解，并且其通量 $J_2$ 是原始通量 $J_1$ 的负值，即 $J_1+J_2=0$ 的物理性质。\n- **设置**：一个弱高斯势 $V(r) = -0.2 \\exp(-r^2)$，散射能量 $E=1.5$，且 $\\kappa=-1$。\n- **实现**：进行两次积分。\n    1. 解 1：以 $c_1 = 1.0 + 1.0j$ 初始化。\n    2. 解 2：以 $c_2 = c_1^* = 1.0 - 1.0j$ 初始化。由于常微分方程组是线性的且系数为实数，对于所有 $r$，第二个解将是第一个解的复共轭，即 $(F_2(r), G_2(r)) = (F_1(r)^*, G_1(r)^*)$。\n- **验证**：如果两个条件都满足，则测试通过：\n    1. $\\max_r |W(r) - W(r_0)|  \\varepsilon$，其中 $W(r) = F_1(r)G_2(r) - G_1(r)F_2(r)$。\n    2. $\\max_r |J_1(r) + J_2(r)|  \\varepsilon$，其中 $J_1 = 2 \\, \\mathrm{Im}(F_1^*G_1)$ 且 $J_2 = 2 \\, \\mathrm{Im}(F_2^*G_2)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Dirac radial equations for three test cases and verifies\n    physical properties of the solutions.\n    \"\"\"\n\n    # --- Core numerical components ---\n\n    def rk4_step(dydr, r, y, h, params):\n        \"\"\"\n        Performs a single step of the 4th-order Runge-Kutta method for a\n        system of complex-valued ODEs.\n        y is a numpy array of complex numbers.\n        \"\"\"\n        k1 = h * dydr(r, y, params)\n        k2 = h * dydr(r + 0.5 * h, y + 0.5 * k1, params)\n        k3 = h * dydr(r + 0.5 * h, y + 0.5 * k2, params)\n        k4 = h * dydr(r + h, y + k3, params)\n        return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n\n    def dirac_radial_ode(r, y, params):\n        \"\"\"\n        Defines the system of Dirac radial ODEs dy/dr.\n        y = [F, G]\n        \"\"\"\n        F, G = y\n        E, m, kappa, V_func, V_params = params['E'], params['m'], params['kappa'], params['V_func'], params['V_params']\n        \n        # Avoid division by zero at the exact start, though r0 is small.\n        if r == 0:\n            return np.array([0j, 0j])\n\n        V_r = V_func(r, **V_params)\n        \n        dFdr = -kappa / r * F + (E - V_r + m) * G\n        dGdr = kappa / r * G - (E - V_r - m) * F\n        \n        return np.array([dFdr, dGdr])\n\n    def integrate_dirac(params):\n        \"\"\"\n        Integrates the Dirac radial equations from r0 to r_max.\n        \"\"\"\n        r0 = params['r0']\n        r_max = params['r_max']\n        n_steps = params['n_steps']\n        \n        r_grid = np.linspace(r0, r_max, n_steps)\n        h = r_grid[1] - r_grid[0]\n        \n        # Initialize arrays for solutions\n        sols = np.zeros((n_steps, 2), dtype=np.complex128)\n        \n        # Regular initial conditions at r0\n        c1 = params['c1']\n        V_at_r0 = params['V_func'](r0, **params['V_params'])\n        F0 = c1 * r0\n        G0 = -1/3 * (params['E'] - V_at_r0 - params['m']) * c1 * r0**2\n        sols[0] = [F0, G0]\n        \n        # Integration loop\n        for i in range(n_steps - 1):\n            sols[i+1] = rk4_step(dirac_radial_ode, r_grid[i], sols[i], h, params)\n            \n        return r_grid, sols[:, 0], sols[:, 1] # r, F, G\n\n    # --- Potential functions ---\n\n    def V_square_well(r, V0, R):\n        return -V0 if r  R else 0.0\n\n    def V_free(r):\n        return 0.0\n\n    def V_gaussian(r, V0, a):\n        return -V0 * np.exp(-r**2 / a**2)\n\n    # --- Main Test Case Logic ---\n    \n    results = []\n    \n    # Common parameters\n    r0 = 1e-4\n    r_max = 10.0\n    n_steps = 20000\n    m = 1.0\n    kappa = -1.0\n    epsilon = 1e-6\n\n    # Test Case 1: Bound-state flux vanishing\n    params1 = {\n        'V_func': V_square_well, 'V_params': {'V0': 5.0, 'R': 2.0},\n        'm': m, 'E': 0.8, 'kappa': kappa,\n        'r0': r0, 'r_max': r_max, 'n_steps': n_steps,\n        'c1': 1.0 + 0.0j # Real initial condition\n    }\n    r, F, G = integrate_dirac(params1)\n    J = 2 * (F.conj() * G).imag\n    result1 = np.max(np.abs(J))  epsilon\n    results.append(result1)\n\n    # Test Case 2: Scattering-state flux constancy\n    params2 = {\n        'V_func': V_free, 'V_params': {},\n        'm': m, 'E': 1.05, 'kappa': kappa,\n        'r0': r0, 'r_max': r_max, 'n_steps': n_steps,\n        'c1': 1.0 + 1.0j # Complex initial condition for non-zero flux\n    }\n    r, F, G = integrate_dirac(params2)\n    J = 2 * (F.conj() * G).imag\n    J0 = J[0]\n    result2 = np.max(np.abs(J - J0))  epsilon\n    results.append(result2)\n\n    # Test Case 3: Wronskian and inflow/outflow matching\n    params3_base = {\n        'V_func': V_gaussian, 'V_params': {'V0': 0.2, 'a': 1.0},\n        'm': m, 'E': 1.5, 'kappa': kappa,\n        'r0': r0, 'r_max': r_max, 'n_steps': n_steps,\n    }\n    \n    # Solution 1\n    params3_1 = params3_base.copy()\n    params3_1['c1'] = 1.0 + 1.0j\n    r, F1, G1 = integrate_dirac(params3_1)\n    \n    # Solution 2 (complex conjugate initial condition)\n    params3_2 = params3_base.copy()\n    params3_2['c1'] = 1.0 - 1.0j\n    r, F2, G2 = integrate_dirac(params3_2)\n\n    # Verification (i): Wronskian constancy\n    W = F1 * G2 - G1 * F2\n    W0 = W[0]\n    wronskian_const = np.max(np.abs(W - W0))  epsilon\n    \n    # Verification (ii): Inflow/outflow matching\n    J1 = 2 * (F1.conj() * G1).imag\n    J2 = 2 * (F2.conj() * G2).imag\n    flux_cancel = np.max(np.abs(J1 + J2))  epsilon\n    \n    result3 = wronskian_const and flux_cancel\n    results.append(result3)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r.capitalize() for r in results]))}]\")\n\nsolve()\n\n```", "id": "3598169"}]}