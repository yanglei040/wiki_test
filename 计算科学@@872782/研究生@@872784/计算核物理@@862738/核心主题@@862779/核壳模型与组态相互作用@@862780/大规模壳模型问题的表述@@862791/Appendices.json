{"hands_on_practices": [{"introduction": "在进行任何大规模核壳模型计算之前，首要任务是定义计算所用的多体希尔伯特空间。这个空间由价核子在给定单粒子轨道上所有可能的组态（即斯莱特行列式）张成。这个练习让您亲身体验如何通过枚举和计数来确定这个空间的维数，特别是利用角动量投影 $M$ 和宇称 $\\Pi$ 这类守恒量，将巨大的模型空间分解为可以独立处理的子块。通过这个过程 [@problem_id:3560216]，您将深刻理解多体问题的组合复杂性，以及对称性在简化计算中扮演的关键角色。", "problem": "你需要从量子力学的第一性原理出发，为一个大尺度核壳模型问题形式化并计算良好$M$方案基的维度。考虑一个由单粒子态定义的价空间，其中每个单粒子态由其两倍的磁量子数和内禀宇称来标记。对于每个斯莱特行列式，总角动量投影必须满足可加性约束，宇称必须满足可乘性约束。全同费米子不能占据同一个单粒子态。你的任务是，对于几个指定的测试用例，计算满足这些约束的质子-中子斯莱特行列式的数量。\n\n基本原理：\n- 斯莱特行列式的磁量子数投影是可加的：如果被占据的单粒子态的投影为 $m_{j_1}, m_{j_2}, \\dots, m_{j_A}$，那么总投影为 $M = \\sum_{i=1}^{A} m_{j_i}$。\n- 斯莱特行列式的内禀宇称是可乘的：如果被占据的单粒子态的宇称为 $\\pi_1, \\pi_2, \\dots, \\pi_A \\in \\{+1,-1\\}$，那么总宇称为 $\\Pi = \\prod_{i=1}^{A} \\pi_i$。\n- 泡利不相容原理分别对质子和中子成立：最多只有一个质子（或中子）可以占据一个给定的单粒子态。\n- 在核壳模型空间中，每个单粒子态由一个半整数投影 $m_{j}$ 表征；为避免浮点数问题，我们使用两倍的投影 $m_{\\!2} \\equiv 2 m_{j}$ 和 $M_{\\!2} \\equiv 2 M$，从而使 $m_{\\!2}$ 和 $M_{\\!2}$ 成为整数。约束条件则变为 $\\sum_{i} m_{\\!2,i} = M_{\\!2}$ 和 $\\prod_{i} \\pi_i = \\Pi$。\n\n模型空间设定：\n- 质子空间由两个轨道组成，每个轨道产生一组由 $m_{\\!2}$ 和宇称 $\\pi$ 表征的单粒子态：\n  - 总角动量 $j = 3/2$ 且内禀宇称为负的轨道（例如 $p_{3/2}$）：$m_{\\!2} \\in \\{-3,-1,1,3\\}$，每个态的 $\\pi = -1$。\n  - 总角动量 $j = 3/2$ 且内禀宇称为正的轨道（例如 $d_{3/2}$）：$m_{\\!2} \\in \\{-3,-1,1,3\\}$，每个态的 $\\pi = +1$。\n  这总共产生 8 个质子单粒子态。\n- 中子空间由两个轨道组成：\n  - 总角动量 $j = 5/2$ 且内禀宇称为负的轨道（例如 $f_{5/2}$）：$m_{\\!2} \\in \\{-5,-3,-1,1,3,5\\}$，每个态的 $\\pi = -1$。\n  - 总角动量 $j = 1/2$ 且内禀宇称为正的轨道（例如 $s_{1/2}$）：$m_{\\!2} \\in \\{-1,1\\}$，每个态的 $\\pi = +1$。\n  这总共产生 8 个中子单粒子态。\n\n计数问题：\n- 设 $Z$ 是价质子数，$N$ 是价中子数，它们将被放置在各自的空间中。\n- 一个斯莱特行列式是 $Z$ 个不同质子态和 $N$ 个不同中子态的任意一种选择。\n- 一个有效的斯莱特行列式必须满足 $\\sum m_{\\!2} = M_{\\!2}$ 和 $\\prod \\pi = \\Pi$，其中求和与求积遍及所有被占据的质子和中子态。\n\n你的程序必须为每个测试用例计算有效斯莱特行列式的总数。程序不得对选择约束执行浮点运算；对 $m_{\\!2}$ 和 $M_{\\!2}$ 以及宇称 $\\Pi \\in \\{+1,-1\\}$ 使用整数算术。\n\n测试套件：\n- 单粒子空间与上述规定完全相同，并对所有测试用例固定。\n- 每个测试用例是一个四元组 $(Z,N,M_{\\!2},\\Pi)$，其值如下：\n  1. $(Z,N,M_{\\!2},\\Pi) = (2,0,0,+1)$。\n  2. $(Z,N,M_{\\!2},\\Pi) = (1,1,2,-1)$。\n  3. $(Z,N,M_{\\!2},\\Pi) = (0,0,0,+1)$。\n  4. $(Z,N,M_{\\!2},\\Pi) = (2,0,1,+1)$。\n  5. $(Z,N,M_{\\!2},\\Pi) = (8,0,0,+1)$。\n\n计算与物理现实性约束：\n- 确保在每种粒子内部强制执行泡利不相容原理。\n- 独立处理质子和中子空间，仅通过对 $M_{\\!2}$ 和 $\\Pi$ 的约束将它们组合起来。\n- 你的算法应基于与上述物理定律一致的组合枚举原理，并且必须使用确定性整数运算。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个 Python 风格的五整数列表，每个整数对应给定顺序的一个测试用例。例如，输出可能看起来像“[10,20,30,40,50]”，但其中的值是为指定测试套件计算出的正确值。", "solution": "我们从斯莱特行列式的角动量投影可加性和宇称可乘性的基本规则出发，并结合全同费米子的泡利不相容原理。每个斯莱特行列式由一个被质子占据的单粒子态子集和一个被中子占据的单粒子态子集指定。约束条件用两倍的投影 $m_{\\!2}$ 和 $M_{\\!2}$ 以及宇称 $\\Pi \\in \\{+1,-1\\}$ 来表示。\n\n原理：\n- 对于任意一组选定的被占据态，总的两倍投影为 $M_{\\!2} = \\sum_{i \\in \\mathcal{P}} m_{\\!2,i}^{(p)} + \\sum_{j \\in \\mathcal{N}} m_{\\!2,j}^{(n)}$，其中 $\\mathcal{P}$ 索引 $Z$ 个被占据的质子态，$\\mathcal{N}$ 索引 $N$ 个被占据的中子态。\n- 总宇称为 $\\Pi = \\left(\\prod_{i \\in \\mathcal{P}} \\pi_{i}^{(p)}\\right)\\left(\\prod_{j \\in \\mathcal{N}} \\pi_{j}^{(n)}\\right)$。\n- 泡利原理禁止在每种粒子内部多次选择同一个单粒子态；质子和中子占据不同的空间，如果它们属于不同种类，可以独立地占据具有相同 $m_{\\!2}$ 值的态。\n\n算法表述：\n- 对所有子集进行直接枚举的复杂度是单粒子态数量的指数函数。然而，对于适中大小的空间，一种基于可加和可乘不变量的动态规划 (DP) 方法使我们能够高效地对有效选择进行计数。\n- 对于一个固定的粒子种类（例如质子），定义一个 DP 映射 $D^{(p)}(k,S,\\pi)$，它计算选择 $k$ 个不同质子态的方法数，这些态的两倍投影和为 $S$，宇称乘积为 $\\pi$。初始化 $D^{(p)}(0,0,+1) = 1$，所有其他条目为零。对于每个具有属性 $(m_{\\!2},\\pi)$ 的质子单粒子态，通过将此态添加到现有的部分选择中来更新 DP，将 $k$ 增加 1，将 $m_{\\!2}$ 加到 $S$ 中，并乘以宇称 $\\pi$。\n- 对中子重复类似的操作以获得 $D^{(n)}(k,S,\\pi)$。\n\n组合步骤：\n- 对于给定的 $(Z,N,M_{\\!2},\\Pi)$，有效斯莱特行列式的总数为\n$$\n\\sum_{S_p,\\pi_p} D^{(p)}(Z,S_p,\\pi_p)\\, D^{(n)}\\big(N, M_{\\!2} - S_p, \\Pi \\cdot \\pi_p\\big),\n$$\n这强制执行了可加性约束 $S_p + S_n = M_{\\!2}$ 和可乘性约束 $\\pi_p \\cdot \\pi_n = \\Pi$。\n\n从第一性原理出发的正确性：\n- $M_{\\!2}$ 的可加性源于总角动量投影被定义为单粒子投影之和。\n- 宇称的可乘性源于内禀宇称在直积态下是一个可乘的量子数。\n- DP 构造对态空间的所有子集恰好枚举一次，并通过其构造强制执行了泡利不相容原理（每个态要么被包括，要么不被包括，从不重复）。\n\n计算上的影响：\n- 设 $S_p$ 和 $S_n$ 分别是质子和中子单粒子态的数量。朴素枚举的复杂度为 $\\mathcal{O}\\!\\left(\\binom{S_p}{Z} + \\binom{S_n}{N}\\right)$，随着空间增大，这会变得（计算量）过大，这是大尺度壳模型计算中的一个标志性挑战。\n- DP 方法的复杂度为 $\\mathcal{O}(S_p \\cdot Z \\cdot R_p + S_n \\cdot N \\cdot R_n)$，其中 $R_p$ 和 $R_n$ 表示所存储的可达到的和与宇称的有效范围，对于结构化空间，这通常远小于朴素枚举。这反映了使用良好$M$截断来减小希尔伯特空间维数的思想。\n- 对于非常大的空间，进一步的改进包括中途相遇子集卷积、跟踪 $M_{\\!2}$ 指数和宇称通道的生成函数方法以及位集卷积。这些方法利用跨粒子种类的可分离性和约束来避免构造完整的$m$方案基。\n\n应用于指定的模型空间：\n- 质子态：总共有 8 个，其中 $m_{\\!2} \\in \\{-3,-1,1,3\\}$ 出现两次（一次 $\\pi=-1$，一次 $\\pi=+1$）。\n- 中子态：总共有 8 个，其中 $m_{\\!2} \\in \\{-5,-3,-1,1,3,5\\}$ 对应 $\\pi=-1$，另外 $\\{-1,1\\}$ 对应 $\\pi=+1$。\n\n对某些情况的手动推导验证了 DP 方法：\n- 对于 $(Z,N,M_{\\!2},\\Pi) = (2,0,0,+1)$，和为 $M_{\\!2}=0$ 的质子对必须是 $(+a,-a)$ 的形式。对于每个大小 $a \\in \\{1,3\\}$，有 $2 \\times 2 = 4$ 个这样的对（$+a$ 有两种选择，$-a$ 有两种选择），其中恰好有 2 个对的宇称为 $+1$。因此，总共有 4 个有效行列式。\n- 对于 $(Z,N,M_{\\!2},\\Pi) = (1,1,2,-1)$，对质子 $m_{\\!2} \\in \\{-3,-1,1,3\\}$ 和中子 $m_{\\!2} = 2 - m_{\\!2}^{(p)}$ 求和，在强制执行宇称匹配后，会得到 6 个有效的组合。\n- 对于 $(Z,N,M_{\\!2},\\Pi) = (0,0,0,+1)$，根据惯例，真空选择只给出一个行列式。\n- 对于 $(Z,N,M_{\\!2},\\Pi) = (2,0,1,+1)$，两个奇数 $m_{\\!2}$ 值之和为偶数，因此不可能达到 $M_{\\!2}=1$，结果为零。\n- 对于 $(Z,N,M_{\\!2},\\Pi) = (8,0,0,+1)$，填满所有 8 个质子态，由于每个 $j=3/2$ 轨道内的两两抵消，得到 $M_{\\!2}=0$，总宇称为 $(-1)^4 (+1)^4 = +1$，所以只有一个行列式。\n\n因此，测试套件的预期输出是与这些计数相对应的整数。程序应为通用性实现 DP 方法，并按规定在单行中生成有序的结果列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# We only use the Python standard library for this task.\nfrom collections import defaultdict\nfrom typing import List, Tuple, Dict\n\ndef build_species_states() -> Tuple[List[Tuple[int, int]], List[Tuple[int, int]]]:\n    \"\"\"\n    Construct the proton and neutron single-particle state lists.\n    Each state is represented as a tuple (m2, parity), where m2 = 2*m_j and parity in {+1, -1}.\n    Proton space:\n      - j=3/2, negative parity (e.g., p3/2): m2 in {-3,-1,1,3}, parity -1\n      - j=3/2, positive parity (e.g., d3/2): m2 in {-3,-1,1,3}, parity +1\n    Neutron space:\n      - j=5/2, negative parity (e.g., f5/2): m2 in {-5,-3,-1,1,3,5}, parity -1\n      - j=1/2, positive parity (e.g., s1/2): m2 in {-1,1}, parity +1\n    \"\"\"\n    proton_states = []\n    for m2 in (-3, -1, 1, 3):\n        proton_states.append((m2, -1))  # negative parity orbit\n    for m2 in (-3, -1, 1, 3):\n        proton_states.append((m2, +1))  # positive parity orbit\n\n    neutron_states = []\n    for m2 in (-5, -3, -1, 1, 3, 5):\n        neutron_states.append((m2, -1))  # negative parity orbit\n    for m2 in (-1, 1):\n        neutron_states.append((m2, +1))  # positive parity orbit\n\n    return proton_states, neutron_states\n\ndef dp_species_counts(states: List[Tuple[int, int]], k_target: int) -> Dict[Tuple[int, int, int], int]:\n    \"\"\"\n    Dynamic programming to count selections within one species.\n    Returns a dictionary mapping (k, sum_m2, parity) -> count,\n    for 0 = k = k_target.\n    \"\"\"\n    # Initialize: selecting 0 states yields sum_m2=0 and parity=+1 in 1 way.\n    dp = defaultdict(int)\n    dp[(0, 0, +1)] = 1\n\n    for m2, pi in states:\n        # We must iterate over a snapshot of current dp to avoid using the same state twice.\n        current_items = list(dp.items())\n        for (k, s, p), count in current_items:\n            if k + 1 = k_target:\n                dp[(k + 1, s + m2, p * pi)] += count\n\n    # Filter out entries with k > k_target to keep the dict small (though we never add such entries).\n    filtered = {key: val for key, val in dp.items() if key[0] = k_target}\n    return filtered\n\ndef count_determinants(Z: int, N: int, M2: int, parity_target: int,\n                       proton_states: List[Tuple[int, int]],\n                       neutron_states: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Count the number of valid Slater determinants for given (Z, N, M2, parity_target).\n    \"\"\"\n    # Build DP maps for each species.\n    dp_p = dp_species_counts(proton_states, Z)\n    dp_n = dp_species_counts(neutron_states, N)\n\n    total = 0\n    # If Z == 0 or N == 0, the logic below still works because dp maps contain k=0 entries.\n    for (k_p, s_p, p_p), count_p in dp_p.items():\n        if k_p != Z:\n            continue\n        # We need neutron tuple (N, M2 - s_p, parity_target * p_p)\n        key_n = (N, M2 - s_p, parity_target * p_p)\n        count_n = dp_n.get(key_n, 0)\n        if count_n:\n            total += count_p * count_n\n    return total\n\ndef solve():\n    # Define the fixed single-particle spaces from the problem statement.\n    proton_states, neutron_states = build_species_states()\n\n    # Define the test cases from the problem statement:\n    # Each as (Z, N, M2, parity)\n    test_cases = [\n        (2, 0, 0, +1),   # Case 1\n        (1, 1, 2, -1),   # Case 2\n        (0, 0, 0, +1),   # Case 3\n        (2, 0, 1, +1),   # Case 4\n        (8, 0, 0, +1),   # Case 5\n    ]\n\n    results = []\n    for Z, N, M2, par in test_cases:\n        result = count_determinants(Z, N, M2, par, proton_states, neutron_states)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3560216"}, {"introduction": "在确定了模型空间的维数之后，下一步是在这个基矢上构建哈密顿量矩阵。这个练习 [@problem_id:3560194] 引导您完成一个微型但完整的壳模型计算流程：从用比特掩码表示多体基矢，到构建包含单体和两体相互作用的哈密顿量矩阵，再到通过精确对角化求解基态。这个实践是大型壳模型代码的一个缩影，它将抽象的物理算符（如第二量子化形式的哈密顿量）转化为具体的、可由计算机执行的数值任务，是连接理论与计算的桥梁。", "problem": "考虑一个有限价空间下的原子核壳模型表述，其中费米子分布在一组离散化的单粒子轨道上。假设质子和中子各有 $M$ 个轨道，每个轨道都是无自旋的，且根据泡利不相容原理，每种核子在每个轨道上的最大占据数为1。在由正则排序的产生算符构建的、粒子数守恒的 $m$-方案福克基（即Slater行列式基）中进行计算。未微扰哈密顿量 $H_0$ 是同位旋对称的，由对质子和中子相同的单体动能加平均场项，以及一个同位旋对称的两体吸引作用构成，该作用对价空间中的每对粒子（不区分种类）都贡献一个能量 $-G$。库仑和电荷对称性破缺微扰 $\\delta H_C$ 定义为一个仅作用于质子的单体能量移动，加上一个两体质子-质子排斥作用，这两项在所选的 $m$-方案基中都是对角的。使用一阶非简并微扰理论，对于 $H_0$ 的一个归一化本征态 $|\\Psi\\rangle$，其能量修正是 $\\Delta E^{(1)}=\\langle \\Psi | \\delta H_C | \\Psi \\rangle$。\n\n你的任务是实现一个程序，该程序能针对给定的价空间参数和同位素组成，构建 $H_0$，通过精确对角化找到其基态 $|\\Psi\\rangle$，并以基加权的 $\\delta H_C$ 期望值的形式计算 $\\Delta E^{(1)}$。计算必须基于以下基本原理：\n\n- 非简并本征态的一阶微扰理论：若 $H=H_0+\\lambda \\delta H_C$ 且 $\\lambda$ 很小，则一阶能量移动为 $\\Delta E^{(1)}=\\langle \\Psi | \\delta H_C | \\Psi \\rangle$，其中 $|\\Psi\\rangle$ 是 $H_0$ 的一个归一化本征态。\n- 费米子算符的二次量子化定义、其正则反对易关系，以及在有序基中矩阵元的诱导符号约定。\n- 在所选基中对角的算符，其期望值等于其对角矩阵元的概率加权和。", "solution": "任务是计算原子核壳模型哈密顿量 $H_0$ 的基态 $|\\Psi\\rangle$ 的一阶非简并微扰理论能量修正 $\\Delta E^{(1)} = \\langle \\Psi | \\delta H_C | \\Psi \\rangle$。这需要为价空间中 $M$ 个轨道内的给定数量的质子($Z$)和中子($N$)构建多体福克基，建立哈密顿量 $H_0$ 和 $\\delta H_C$ 的矩阵表示，通过精确对角化找到 $H_0$ 的基态，并最终计算期望值。\n\n计算的基础是多体基。对于一个在 $M$ 个轨道中有 $Z$ 个质子和 $N$ 个中子的系统， $m$-方案中的一个基矢是由每种核子所占据的轨道定义的Slater行列式。这样一个态可以由一对整数位掩码 $(\\nu_p, \\nu_n)$唯一表示。整数 $\\nu_p$ 是一个 $M$ 位的数，其中恰好有 $Z$ 个比特位被置位，表示被占据的质子轨道。类似地，$\\nu_n$ 是一个 $M$ 位的数，其中有 $N$ 个比特位被置位，用于表示中子。决定哈密顿矩阵维度的基矢总数为 $D = \\binom{M}{Z} \\binom{M}{N}$。\n\n未微扰哈密顿量 $H_0 = H_{0,1} + H_{0,2}$ 表示为一个 $D \\times D$ 矩阵。其矩阵元 $H_{ij} = \\langle \\Psi_i | H_0 | \\Psi_j \\rangle$ 计算如下：\n$H_0$ 同时具有对角和非对角分量。对于一个基矢 $|\\Psi_k\\rangle = |\\nu_p, \\nu_n\\rangle$，其对角矩阵元由单粒子能量 ($e_a$) 和两体吸引作用 ($H_{0,2}$) 贡献。\n来自单粒子能量的贡献是 $\\sum_{s \\in \\{p,n\\}} \\sum_{a=0}^{M-1} e_a n_{as}$，其中数算符 $n_{as}$ 在轨道 $a$ 被种类为 $s$ 的核子占据时为1，否则为0。这可以通过检查 $\\nu_p$ 和 $\\nu_n$ 的比特位来确定。\n来自两体吸引作用 $H_{0,2}$ 的贡献是对每对被占据的单粒子态（不区分质子或中子）加一个 $-G$ 的能量。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations, product\n\ndef solve():\n    \"\"\"\n    Main function to run the shell model calculation for the specified test cases.\n    \"\"\"\n    # Define problem parameters\n    M = 3\n    e = np.array([0.0, 1.5, 3.0])\n    t = np.zeros((M, M))\n    t[0, 1] = t[1, 0] = -0.4\n    t[1, 2] = t[2, 1] = -0.25\n    G = 0.25\n    eps_C = np.array([0.3, 0.15, 0.08])\n    V_pp = np.zeros((M, M))\n    V_pp[0, 1] = V_pp[1, 0] = 0.7\n    V_pp[0, 2] = V_pp[2, 0] = 0.5\n    V_pp[1, 2] = V_pp[2, 1] = 0.6\n\n    test_cases = [\n        (0, 2),  # Case A\n        (1, 1),  # Case B\n        (2, 1),  # Case C\n        (3, 0)   # Case D\n    ]\n\n    results = []\n    for Z, N in test_cases:\n        delta_e = compute_delta_e(Z, N, M, e, t, G, eps_C, V_pp)\n        results.append(f'{delta_e:.6f}')\n\n    print(f\"[{','.join(results)}]\")\n\ndef get_bit_count(n):\n    \"\"\"Helper function to count set bits in an integer.\"\"\"\n    count = 0\n    while n > 0:\n        n = (n - 1)\n        count += 1\n    return count\n\ndef compute_delta_e(Z, N, M, e, t, G, eps_C, V_pp):\n    \"\"\"\n    Computes the first-order energy correction for a given (Z, N) configuration.\n    \"\"\"\n    # 1. Generate basis\n    p_orbitals_configs = list(combinations(range(M), Z))\n    n_orbitals_configs = list(combinations(range(M), N))\n\n    p_masks = [sum(1  i for i in combo) for combo in p_orbitals_configs]\n    n_masks = [sum(1  i for i in combo) for combo in n_orbitals_configs]\n    \n    basis = list(product(p_masks, n_masks))\n    dim = len(basis)\n    if dim == 0:\n        return 0.0\n\n    state_to_idx = {state: i for i, state in enumerate(basis)}\n\n    # 2. Construct H0 and diagonal of delta_H_C\n    H0 = np.zeros((dim, dim))\n    V_c_diag = np.zeros(dim)\n\n    for i, (p_mask, n_mask) in enumerate(basis):\n        # Diagonal elements of H0\n        diag_H0 = 0.0\n        # Single-particle energy part\n        for k in range(M):\n            if (p_mask >> k)  1: diag_H0 += e[k]\n            if (n_mask >> k)  1: diag_H0 += e[k]\n        \n        # Two-body monopole part\n        p_indices = [k for k in range(M) if (p_mask >> k)  1]\n        n_indices = [k for k in range(M) if (n_mask >> k)  1]\n        \n        # p-p interaction\n        for k1_idx in range(len(p_indices)):\n            for k2_idx in range(k1_idx + 1, len(p_indices)):\n                diag_H0 -= G\n        # n-n interaction\n        for k1_idx in range(len(n_indices)):\n            for k2_idx in range(k1_idx + 1, len(n_indices)):\n                diag_H0 -= G\n        # p-n interaction\n        for p_idx in p_indices:\n            for n_idx in n_indices:\n                diag_H0 -= G\n        \n        H0[i, i] = diag_H0\n\n        # Diagonal elements of delta_H_C\n        diag_Vc = 0.0\n        # One-body Coulomb part\n        for k in p_indices:\n            diag_Vc += eps_C[k]\n        # Two-body Coulomb part\n        for k1_idx in range(len(p_indices)):\n            for k2_idx in range(k1_idx + 1, len(p_indices)):\n                k1, k2 = p_indices[k1_idx], p_indices[k2_idx]\n                diag_Vc += V_pp[k1, k2]\n        V_c_diag[i] = diag_Vc\n\n        # Off-diagonal elements of H0 (hopping term)\n        for a in range(M):\n            for b in range(a + 1, M):\n                if t[a, b] == 0: continue\n                # Hopping for protons\n                if Z > 0:\n                    # Hop b->a\n                    if ((p_mask >> b)  1) and not ((p_mask >> a)  1):\n                        new_p_mask = p_mask - (1  b) + (1  a)\n                        j = state_to_idx.get((new_p_mask, n_mask))\n                        if j is not None:\n                            mask_between = (1  b) - (1  (a + 1))\n                            sign = (-1)**get_bit_count(p_mask  mask_between)\n                            H0[i, j] += t[a, b] * sign\n                            H0[j, i] += t[b, a] * sign\n\n                # Hopping for neutrons\n                if N > 0:\n                    # Hop b->a\n                    if ((n_mask >> b)  1) and not ((n_mask >> a)  1):\n                        new_n_mask = n_mask - (1  b) + (1  a)\n                        j = state_to_idx.get((p_mask, new_n_mask))\n                        if j is not None:\n                            mask_between = (1  b) - (1  (a + 1))\n                            sign = (-1)**get_bit_count(n_mask  mask_between)\n                            H0[i, j] += t[a, b] * sign\n                            H0[j, i] += t[b, a] * sign\n    \n    # Handle the trivial 1x1 case without diagonalization\n    if dim == 1:\n        return V_c_diag[0]\n\n    # 3. Diagonalize H0 to find ground state\n    eigenvalues, eigenvectors = np.linalg.eigh(H0)\n    ground_state_idx = np.argmin(eigenvalues)\n    ground_state_vector = eigenvectors[:, ground_state_idx]\n\n    # 4. Calculate expectation value\n    delta_E = np.sum(ground_state_vector**2 * V_c_diag)\n    \n    return delta_E\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3560194"}, {"introduction": "虽然精确对角化对于小型系统是可行的，但正如第一个练习所揭示的，随着粒子数和轨道数的增加，模型空间的维数会呈指数级增长，使得精确对角化变得不切实际。这个最后的练习 [@problem_id:3560221] 介绍了一种应对这一“大规模”挑战的强大技术：重要性截断。您将学习如何从微扰论出发，推导出一个衡量基矢重要性的指标，并用它来筛选出一个尺寸小得多但物理上最重要的子空间，从而在可控的计算成本内获得对真实基态能量的精确近似。这种方法是现代大规模壳模型计算的核心策略之一。", "problem": "考虑一个由正交归一的壳模型基矢 $\\{ \\vert \\alpha \\rangle \\}$ 张成的有限维希尔伯特空间，以及一个在该基矢下矩阵表示为 $\\mathbf{H}$ 的实对称哈密顿算符 $\\hat{H}$。设一个归一化参考态 $\\vert \\Psi_0 \\rangle$ 被选为单个基矢 $\\vert \\alpha_0 \\rangle$（第一个基矢），其未微扰能量为 $E_0 = H_{00}$，其中 $H_{ij}$ 表示矩阵元 $\\langle \\alpha_i \\vert \\hat{H} \\vert \\alpha_j \\rangle$。在任何截断子空间中通过对角化得到的基态能量，都必须满足 Rayleigh–Ritz 变分原理：对于任何包含 $\\vert \\Psi_0 \\rangle$ 的子空间 $\\mathcal{S}$，$\\hat{H}$ 限制在 $\\mathcal{S}$ 上的最低本征值 $E_{\\mathcal{S}}$ 遵循 $E_{\\mathcal{S}} \\geq E_{\\text{full}}$，其中 $E_{\\text{full}}$ 是 $\\hat{H}$ 在全空间中的最低本征值。\n\n您的任务是从第一性原理出发，为单个基矢推导一个重要性度量，并构建一个能保持变分界的算法截断方案，然后实现它并在提供的测试套件上进行评估。\n\n推导要求：\n- 从定态薛定谔方程 $\\hat{H} \\vert \\Psi \\rangle = E \\vert \\Psi \\rangle$ 和标准的非简并一阶微扰理论出发，应用于将空间划分为参考态 $\\vert \\Psi_0 \\rangle$ 和其余基矢，推导每个基矢 $\\vert \\alpha \\rangle$ 的一个态选择重要性度量。该度量应与耦合 $\\langle \\alpha \\vert \\hat{H} \\vert \\Psi_0 \\rangle$ 成正比，与未微扰能量差 $(E_0 - E_\\alpha)$ 成反比。不要使用简便写法；从基本定义和微扰展开假设出发，明确地进行推理。\n\n算法要求：\n- 使用推导出的重要性度量，定义一个带有阈值参数 $\\tau > 0$ 的截断判据：选择所有绝对重要性超过 $\\tau$ 的基矢 $\\vert \\alpha \\rangle$。为了处理 $\\vert E_0 - E_\\alpha \\vert$ 极小的近简并情况，引入一个非负正则化参数 $\\epsilon$，并指明如何处理满足 $\\vert E_0 - E_\\alpha \\vert  \\epsilon$ 的态，以保持数值稳定性和变分单调性。\n- 构建截断子空间 $\\mathcal{S}_\\tau$，该子空间由参考态 $\\vert \\Psi_0 \\rangle$ 和所有被选中的 $\\vert \\alpha \\rangle$ 组成，形成哈密顿子矩阵 $\\mathbf{H}_{\\mathcal{S}_\\tau}$，并通过直接对角化计算最低本征值 $E_{\\tau}$。解释为什么仅使用对角化结果（不添加任何后验能量修正）就能保持变分界 $E_{\\tau} \\geq E_{\\text{full}}$。同时解释当 $\\tau_2  \\tau_1$ 且子空间增大时，$E_{\\tau_2} \\leq E_{\\tau_1}$ 的单调行为。\n\n实现要求：\n- 实现一个程序，给定一个哈密顿矩阵 $\\mathbf{H}$、一个参考态索引 $0$、一个阈值 $\\tau$ 和一个正则化参数 $\\epsilon$，该程序基于推导的重要性度量构建 $\\mathcal{S}_\\tau$ 并计算：\n  $$\n  E_{\\tau} = \\min \\operatorname{eig}(\\mathbf{H}_{\\mathcal{S}_\\tau}), \\quad E_{\\text{full}} = \\min \\operatorname{eig}(\\mathbf{H})\n  $$\n  其中 $\\min \\operatorname{eig}(\\cdot)$ 表示最小本征值。输出要求以兆电子伏特（MeV）为单位的浮点值表示。最终输出必须将所有测试用例的结果聚合到单行中：一个顶层列表，其中包含每个测试用例的列表，每个内部列表包含三个条目 $[E_{\\tau}, E_{\\text{full}}, \\text{bound\\_ok}]$，其中 $\\text{bound\\_ok}$ 是一个布尔值，表示 $E_{\\tau} \\geq E_{\\text{full}}$ 是否成立（在可忽略的数值容差范围内）。\n\n测试套件和参数：\n- 使用以下测试套件，旨在探测截断和变分性质的不同方面。所有能量单位均为兆电子伏特。\n\n测试用例 A（一般情况，中等耦合，阈值排除了弱重要性态）：\n维度 $6$，哈密顿量\n$$\n\\mathbf{H}_A =\n\\begin{pmatrix}\n0.0  -0.30  -0.25  -0.10  -0.05  -0.02 \\\\\n-0.30  0.8  -0.15  -0.10  -0.05  0.0 \\\\\n-0.25  -0.15  1.2  -0.20  -0.07  -0.03 \\\\\n-0.10  -0.10  -0.20  1.7  -0.12  -0.04 \\\\\n-0.05  -0.05  -0.07  -0.12  2.3  -0.01 \\\\\n-0.02  0.0  -0.03  -0.04  -0.01  3.1\n\\end{pmatrix}\n$$\n阈值 $\\tau = 0.1$，正则化参数 $\\epsilon = 10^{-10}$。\n\n测试用例 B（近简并态与参考态强耦合，因分母小而重要性大）：\n维度 $5$，哈密顿量\n$$\n\\mathbf{H}_B =\n\\begin{pmatrix}\n0.0  -0.01  -0.08  -0.04  -0.02 \\\\\n-0.01  10^{-6}  -0.02  -0.01  0.0 \\\\\n-0.08  -0.02  0.6  -0.05  -0.02 \\\\\n-0.04  -0.01  -0.05  1.4  -0.03 \\\\\n-0.02  0.0  -0.02  -0.03  2.2\n\\end{pmatrix}\n$$\n阈值 $\\tau = 0.5$，正则化参数 $\\epsilon = 10^{-8}$。\n\n测试用例 C（无耦合，除参考态外无选择，能量不变）：\n维度 $4$，哈密顿量\n$$\n\\mathbf{H}_C =\n\\begin{pmatrix}\n0.0  0.0  0.0  0.0 \\\\\n0.0  1.0  0.0  0.0 \\\\\n0.0  0.0  2.0  0.0 \\\\\n0.0  0.0  0.0  3.0\n\\end{pmatrix}\n$$\n阈值 $\\tau = 0.05$，正则化参数 $\\epsilon = 10^{-10}$。\n\n测试用例 D（与 A 相同的哈密顿量，更低的阈值包含更多态，应降低截断能量）：\n使用上述 $\\mathbf{H}_A$，阈值 $\\tau = 0.01$，正则化参数 $\\epsilon = 10^{-10}$。\n\n答案规格和最终输出格式：\n- 对每个测试用例，计算 $E_{\\tau}$ 和 $E_{\\text{full}}$（单位 MeV）以及一个布尔值 $\\text{bound\\_ok}$，表示在 $10^{-12}$ 的数值容差内 $E_{\\tau} \\geq E_{\\text{full}}$ 是否成立。您的程序应生成单行输出，包含一个由方括号括起的逗号分隔列表，其中每个测试用例的结果表示为一个内部列表：例如，`[[E_{\\tau}^{(A)},E_{\\text{full}}^{(A)},\\text{bound\\_ok}^{(A)}],[E_{\\tau}^{(B)},E_{\\text{full}}^{(B)},\\text{bound\\_ok}^{(B)}],\\ldots]`。所有能量必须以兆电子伏特（MeV）为单位，作为浮点值报告。", "solution": "该问题被评估为有效，因为它在科学上基于量子力学，是良置、客观且内部一致的。它提出了计算物理学中一个标准的、非平凡的任务，可以用所提供的信息解决。\n\n### 态重要性度量的推导\n\n目标是基于一阶微扰理论推导基矢的重要性度量。我们从在由正交归一基矢 $\\{ \\vert \\alpha_i \\rangle \\}$ 张成的有限维希尔伯特空间中的定态薛定谔方程开始：\n$$\n\\hat{H} \\vert \\Psi \\rangle = E \\vert \\Psi \\rangle\n$$\n其中 $\\hat{H}$ 是哈密顿算符，$\\vert \\Psi \\rangle$ 是一个本征态，E 是对应的本征值。\n\n哈密顿算符 $\\hat{H}$ 可以被划分为一个未微扰部分 $\\hat{H}_0$ 和一个微扰 $\\hat{V}$：\n$$\n\\hat{H} = \\hat{H}_0 + \\hat{V}\n$$\n在给定的基矢 $\\{ \\vert \\alpha_i \\rangle \\}$ 中，对此划分的一个自然选择是将 $\\hat{H}_0$ 定义为哈密顿矩阵的对角部分，将 $\\hat{V}$ 定义为非对角部分。根据构造，基矢 $\\vert \\alpha_i \\rangle$ 是 $\\hat{H}_0$ 的本征态：\n$$\n\\hat{H}_0 \\vert \\alpha_i \\rangle = \\langle \\alpha_i \\vert \\hat{H} \\vert \\alpha_i \\rangle \\vert \\alpha_i \\rangle = H_{ii} \\vert \\alpha_i \\rangle\n$$\n态 $\\vert \\alpha_i \\rangle$ 的未微扰能量是 $E_i^{(0)} = H_{ii}$。\n\n我们感兴趣的是与未微扰参考态 $\\vert \\Psi_0 \\rangle = \\vert \\alpha_0 \\rangle$ 绝热连接的真实本征态 $\\vert \\Psi \\rangle$。该参考态的未微扰能量是 $E_0 \\equiv E_0^{(0)} = H_{00}$。根据标准的非简并微扰理论，对参考态 $\\vert \\alpha_0 \\rangle$ 的一阶修正由所有其他未微扰本征态 $\\vert \\alpha_k \\rangle$（其中 $k \\neq 0$）的线性组合给出：\n$$\n\\vert \\Psi \\rangle \\approx \\vert \\Psi^{(1)} \\rangle = \\mathcal{N} \\left( \\vert \\alpha_0 \\rangle + \\sum_{k \\neq 0} c_k^{(1)} \\vert \\alpha_k \\rangle \\right)\n$$\n其中 $\\mathcal{N}$ 是归一化常数，系数 $c_k^{(1)}$ 决定了由于微扰 $\\hat{V}$，每个态 $\\vert \\alpha_k \\rangle$ 混合到参考态中的程度。\n\n这些系数的公式是一阶微扰理论的一个标准结果：\n$$\nc_k^{(1)} = \\frac{\\langle \\alpha_k \\vert \\hat{V} \\vert \\alpha_0 \\rangle}{E_0^{(0)} - E_k^{(0)}}\n$$\n对于我们选择的划分，微扰 $\\hat{V}$ 的矩阵元是：\n$$\n\\langle \\alpha_k \\vert \\hat{V} \\vert \\alpha_0 \\rangle = \\langle \\alpha_k \\vert (\\hat{H} - \\hat{H}_0) \\vert \\alpha_0 \\rangle = \\langle \\alpha_k \\vert \\hat{H} \\vert \\alpha_0 \\rangle - \\langle \\alpha_k \\vert \\hat{H}_0 \\vert \\alpha_0 \\rangle\n$$\n由于 $\\hat{H}_0$ 在此基矢下是对角的，且 $k \\neq 0$，第二项为零：$\\langle \\alpha_k \\vert \\hat{H}_0 \\vert \\alpha_0 \\rangle = E_0^{(0)} \\langle \\alpha_k \\vert \\alpha_0 \\rangle = 0$。因此，耦合就是完整哈密顿量的非对角矩阵元：\n$$\n\\langle \\alpha_k \\vert \\hat{V} \\vert \\alpha_0 \\rangle = \\langle \\alpha_k \\vert \\hat{H} \\vert \\alpha_0 \\rangle = H_{k0}\n$$\n未微扰能量分母是 $E_0^{(0)} - E_k^{(0)} = H_{00} - H_{kk}$。根据问题中 $E_\\alpha = H_{\\alpha\\alpha}$ 的记法，这即是 $E_0 - E_k$。\n\n将这些代入 $c_k^{(1)}$ 的表达式中，我们得到：\n$$\nc_k^{(1)} = \\frac{H_{k0}}{H_{00} - H_{kk}}\n$$\n该系数的模 $|c_k^{(1)}|$ 量化了基矢 $\\vert \\alpha_k \\rangle$ 对于真实本征态一阶描述的“重要性”。具有较大 $|c_k^{(1)}|$ 的态贡献更显著。因此，我们可以将态 $\\vert \\alpha_k \\rangle$（其中 $k \\neq 0$）的重要性度量 $\\mathcal{I}_k$ 定义为这个量本身：\n$$\n\\mathcal{I}_k = \\frac{\\langle \\alpha_k \\vert \\hat{H} \\vert \\alpha_0 \\rangle}{E_0 - E_k} = \\frac{H_{k0}}{H_{00} - H_{kk}}\n$$\n该度量与态和参考态之间的耦合 $H_{k0}$ 成正比，与它们的未微扰能量差 $H_{00} - H_{kk}$ 成反比，正如要求所述。\n\n### 算法截断方案\n\n**截断判据和正则化：**\n基于推导的重要性度量 $\\mathcal{I}_k$，我们构建一个截断方案。给定一个阈值参数 $\\tau > 0$，如果一个基矢 $\\vert \\alpha_k \\rangle$（对于 $k \\neq 0$）的重要性度量的绝对值大于 $\\tau$，则该基矢被认为是重要的并被包含在截断模型空间中。\n\n当能量分母 $|E_0 - E_k| = |H_{00} - H_{kk}|$ 非常小，即态是近简并的时，会出现一个关键问题。在这种情况下，一阶微扰理论无效，重要性度量 $\\mathcal{I}_k$ 将会发散。为了处理这个问题，我们引入一个非负正则化参数 $\\epsilon$。任何与参考态近简并的态 $\\vert \\alpha_k \\rangle$，即满足条件 $|H_{00} - H_{kk}|  \\epsilon$ 的态，都必须被包含在模型空间中，无论其耦合强度 $H_{k0}$ 如何。即使是微小的微扰也会使这类态强混合，必须通过对角化来处理。\n\n对一个态 $\\vert \\alpha_k \\rangle$（其中 $k \\neq 0$）的完整选择判据是：\n如果满足以下任一条件，则选择 $\\vert \\alpha_k \\rangle$：\n1.  **近简并：** $|H_{00} - H_{kk}|  \\epsilon$\n2.  **重要性：** $|H_{00} - H_{kk}| \\ge \\epsilon$ 且 $|\\mathcal{I}_k| = \\left| \\frac{H_{k0}}{H_{00} - H_{kk}} \\right| > \\tau$\n\n**子空间构造和变分界：**\n截断子空间，记为 $\\mathcal{S}_\\tau$，由参考态 $\\vert \\alpha_0 \\rangle$ 和所有满足选择判据的其他基矢 $\\vert \\alpha_k \\rangle$ 张成。然后将哈密顿量投影到这个子空间上，形成子矩阵 $\\mathbf{H}_{\\mathcal{S}_\\tau}$。该子矩阵的元素就是原始哈密顿矩阵元素 $H_{ij}$，其中 $i, j$ 对应于 $\\mathcal{S}_\\tau$ 中态的索引。\n\n该子矩阵的最低本征值 $E_{\\tau} = \\min \\operatorname{eig}(\\mathbf{H}_{\\mathcal{S}_\\tau})$ 是对真实基态能量 $E_{\\text{full}}$ 的一个近似。该过程内在地保持了变分界 $E_{\\tau} \\geq E_{\\text{full}}$。这是 Rayleigh-Ritz 变分原理的直接结果，更具体地说是 Hylleraas-Undheim-MacDonald 定理的结果。该定理指出，厄米算符在子空间中的第 n 个本征值是该算符在全空间中第 n 个本征值的上界。对于最低本征值（$n=1$），这意味着在子空间 $\\mathcal{S}_\\tau$ 内可以获得的最小能量期望值不能低于在整个希尔伯特空间中的全局最小能量期望值。由于直接对角化找到了子空间内的这个最小值，我们保证了 $E_\\tau \\geq E_{\\text{full}}$。\n\n**随阈值 $\\tau$ 的单调性：**\n考虑两个阈值 $\\tau_1$ 和 $\\tau_2$，使得 $\\tau_2  \\tau_1$。设 $\\mathcal{S}_{\\tau_1}$ 和 $\\mathcal{S}_{\\tau_2}$ 是相应的截断子空间。任何为阈值 $\\tau_1$ 选择的态 $\\vert \\alpha_k \\rangle$ 必须满足简并条件或 $|\\mathcal{I}_k| > \\tau_1$。如果它满足简并条件，它也同样会被为 $\\tau_2$ 选择。如果它满足重要性判据 $|\\mathcal{I}_k| > \\tau_1$，那么它必然也满足 $|\\mathcal{I}_k| > \\tau_2$。因此，任何包含在 $\\mathcal{S}_{\\tau_1}$ 中的态也包含在 $\\mathcal{S}_{\\tau_2}$ 中。这意味着 $\\mathcal{S}_{\\tau_1}$ 是 $\\mathcal{S}_{\\tau_2}$ 的一个子空间，即 $\\mathcal{S}_{\\tau_1} \\subseteq \\mathcal{S}_{\\tau_2}$。\n\n根据同一个 Hylleraas-Undheim-MacDonald 定理，如果我们有一个嵌套的子空间序列，相应的最低本征值是单调不增的。由于 $\\mathcal{S}_{\\tau_1} \\subseteq \\mathcal{S}_{\\tau_2}$，从 $\\mathcal{S}_{\\tau_1}$ 获得的最低本征值 $E_{\\tau_1}$ 必须大于或等于从更大的子空间 $\\mathcal{S}_{\\tau_2}$ 获得的最低本征值 $E_{\\tau_2}$。因此，我们有单调行为 $E_{\\tau_1} \\geq E_{\\tau_2}$。随着我们降低阈值 $\\tau$，变分空间增大，计算出的基态能量得到改善（即减小或保持不变），从上方系统地逼近 $E_{\\text{full}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the shell model truncation problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case A (general case)\n        {\n            \"H\": np.array([\n                [0.0, -0.30, -0.25, -0.10, -0.05, -0.02],\n                [-0.30, 0.8, -0.15, -0.10, -0.05, 0.0],\n                [-0.25, -0.15, 1.2, -0.20, -0.07, -0.03],\n                [-0.10, -0.10, -0.20, 1.7, -0.12, -0.04],\n                [-0.05, -0.05, -0.07, -0.12, 2.3, -0.01],\n                [-0.02, 0.0, -0.03, -0.04, -0.01, 3.1]\n            ]),\n            \"tau\": 0.1,\n            \"epsilon\": 1e-10\n        },\n        # Test case B (near-degenerate state)\n        {\n            \"H\": np.array([\n                [0.0, -0.01, -0.08, -0.04, -0.02],\n                [-0.01, 1e-6, -0.02, -0.01, 0.0],\n                [-0.08, -0.02, 0.6, -0.05, -0.02],\n                [-0.04, -0.01, -0.05, 1.4, -0.03],\n                [-0.02, 0.0, -0.02, -0.03, 2.2]\n            ]),\n            \"tau\": 0.5,\n            \"epsilon\": 1e-8\n        },\n        # Test case C (no couplings)\n        {\n            \"H\": np.array([\n                [0.0, 0.0, 0.0, 0.0],\n                [0.0, 1.0, 0.0, 0.0],\n                [0.0, 0.0, 2.0, 0.0],\n                [0.0, 0.0, 0.0, 3.0]\n            ]),\n            \"tau\": 0.05,\n            \"epsilon\": 1e-10\n        },\n        # Test case D (same as A, lower threshold)\n        {\n            \"H\": np.array([\n                [0.0, -0.30, -0.25, -0.10, -0.05, -0.02],\n                [-0.30, 0.8, -0.15, -0.10, -0.05, 0.0],\n                [-0.25, -0.15, 1.2, -0.20, -0.07, -0.03],\n                [-0.10, -0.10, -0.20, 1.7, -0.12, -0.04],\n                [-0.05, -0.05, -0.07, -0.12, 2.3, -0.01],\n                [-0.02, 0.0, -0.03, -0.04, -0.01, 3.1]\n            ]),\n            \"tau\": 0.01,\n            \"epsilon\": 1e-10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        H = case[\"H\"]\n        tau = case[\"tau\"]\n        epsilon = case[\"epsilon\"]\n        ref_idx = 0\n        \n        result = calculate_energy_truncation(H, ref_idx, tau, epsilon)\n        results.append(result)\n\n    # Format the final output as a single-line string representation of a list of lists.\n    # The default str() representation of a list matches the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_energy_truncation(H, ref_idx, tau, epsilon):\n    \"\"\"\n    Calculates the lowest eigenvalue in a truncated subspace and the full space.\n\n    Args:\n        H (np.ndarray): The full Hamiltonian matrix.\n        ref_idx (int): The index of the reference state.\n        tau (float): The importance threshold for state selection.\n        epsilon (float): The regularization parameter for near-degeneracies.\n\n    Returns:\n        list: A list containing [E_tau, E_full, bound_ok].\n    \"\"\"\n    n = H.shape[0]\n\n    # 1. Compute the lowest eigenvalue in the full space\n    full_eigenvalues = np.linalg.eigh(H)[0]\n    E_full = np.min(full_eigenvalues)\n\n    # 2. Determine the truncated subspace based on the importance measure\n    E0 = H[ref_idx, ref_idx]\n    subspace_indices = {ref_idx}\n\n    for k in range(n):\n        if k == ref_idx:\n            continue\n\n        Ek = H[k, k]\n        delta_E = E0 - Ek\n        \n        # Condition 1: Near-degeneracy\n        if abs(delta_E)  epsilon:\n            subspace_indices.add(k)\n            continue\n        \n        # Condition 2: Importance measure\n        Hk0 = H[k, ref_idx]\n        importance = Hk0 / delta_E\n        \n        if abs(importance) > tau:\n            subspace_indices.add(k)\n\n    # Convert to a sorted list for deterministic submatrix construction\n    sorted_indices = sorted(list(subspace_indices))\n    \n    # 3. Construct the submatrix and compute its lowest eigenvalue\n    # Using np.ix_ to perform advanced indexing\n    H_subspace = H[np.ix_(sorted_indices, sorted_indices)]\n    \n    subspace_eigenvalues = np.linalg.eigh(H_subspace)[0]\n    E_tau = np.min(subspace_eigenvalues)\n\n    # 4. Check if the variational bound is satisfied\n    tolerance = 1e-12\n    bound_ok = (E_tau >= E_full - tolerance)\n\n    return [E_tau, E_full, bound_ok]\n\nsolve()\n```", "id": "3560221"}]}