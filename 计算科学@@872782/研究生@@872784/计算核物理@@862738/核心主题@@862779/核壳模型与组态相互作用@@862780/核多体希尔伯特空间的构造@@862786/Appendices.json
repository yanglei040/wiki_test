{"hands_on_practices": [{"introduction": "在了解了基矢状态的庞大数量后，下一个实际挑战是如何在计算机程序中高效地表示和访问它们。本练习将探讨壳模型代码的一个基石：为每个斯莱特行列式创建一个唯一的、保持词典序的整数索引。这种被称为排序（ranking）和解排序（unranking）的映射，对于存储状态向量和构建哈密顿量矩阵元至关重要，它将一个抽象的状态集合转变为一个计算上可管理的对象。[@problem_id:3575545]", "problem": "您正在为一个核壳模型多体基矢建模，其中的多体希尔伯特空间由占据固定单粒子轨道的质子和中子的斯莱特行列式构成。每个斯莱特行列式由两个占据数位串表示：一个用于质子，一个用于中子。根据费米-狄拉克反对称性，每个单粒子轨道可以未被占据或被占据，因此一个占据数位串是长度等于单粒子轨道数的比特序列，其中恰好有固定数量的1，该数量等于该种粒子的数量。\n\n形式上，设质子空间有 $\\Omega_p$ 个单粒子轨道，中子空间有 $\\Omega_n$ 个单粒子轨道。设 $Z$ 为质子数，$N$ 为中子数，其中 $0 \\le Z \\le \\Omega_p$ 且 $0 \\le N \\le \\Omega_n$。一个质子基矢态是一个占据数位串 $b^p \\in \\{0,1\\}^{\\Omega_p}$，其中恰好有 $Z$ 个1；一个中子基矢态是 $b^n \\in \\{0,1\\}^{\\Omega_n}$，其中恰好有 $N$ 个1。一个完整的多体基矢态是一个有序对 $(b^p,b^n)$。\n\n定义位串的字典序为从最左边的比特读到最右边的比特，在它们不同的第一个位置进行比较，其中 $0  1$。定义有序对 $(b^p,b^n)$ 的字典序为首先按字典序比较质子位串 $b^p$，如果它们相等，则按字典序比较中子位串 $b^n$。\n\n您的任务是设计并实现一个从有序对 $(b^p,b^n)$ 到连续整数索引的双射，该映射保持此字典序，并能为哈密顿量应用实现快速查找。该映射必须满足以下所有条件：\n\n- 它将每个有效的有序对 $(b^p,b^n)$ 映射到 $\\{0,1,2,\\dots,D-1\\}$ 中的一个唯一整数索引，其中 $D$ 是给定 $\\Omega_p$、$\\Omega_n$、$Z$ 和 $N$ 的基矢态总数。\n- 它保持 $(b^p,b^n)$ 上的字典序：如果 $(b^p_1,b^n_1)$ 在字典序中位于 $(b^p_2,b^n_2)$ 之前，则 $(b^p_1,b^n_1)$ 的映射索引严格小于 $(b^p_2,b^n_2)$ 的映射索引。\n- 它提供从索引到 $(b^p,b^n)$ 的逆映射。\n- 它能为哈密顿量应用实现快速查找，意味着计算单个状态的索引或逆索引的时间复杂度与位串长度呈线性关系，即 $\\mathcal{O}(\\Omega_p + \\Omega_n)$，且仅使用整数运算和预计算的常数。\n\n您可以使用的基本事实包括：费米子占据数为 $0$ 或 $1$，长度为 $\\Omega$ 且恰好有 $K$ 个1的不同占据构型的数量由二项式系数 $\\binom{\\Omega}{K}$ 给出，且字典序可以通过计算前缀来表征。\n\n您必须生成一个完整的、可运行的程序，实现此映射及其逆映射，然后评估以下测试套件。所有位串都以显式的比特列表形式给出，列表最左边的元素对应于最左边的比特。每个测试所需的输出是一个布尔值，指示所述条件是否成立。此问题不涉及任何物理单位或角度。\n\n测试套件：\n\n- 测试1（正常路径，字典序保持）：$\\Omega_p = 6$，$Z = 3$，$\\Omega_n = 5$，$N = 2$。设 $A^p = [0,0,1,1,1,0]$，$A^n = [0,1,0,1,0]$，$B^p = [0,1,0,1,1,0]$，$B^n = [0,0,1,1,0]$。计算 $(A^p,A^n)$ 和 $(B^p,B^n)$ 的索引。当且仅当 $(A^p,A^n)$ 的索引严格小于 $(B^p,B^n)$ 的索引时，输出true。\n\n- 测试2（往返双射）：$\\Omega_p = 6$，$Z = 3$，$\\Omega_n = 5$，$N = 2$。设 $C^p = [1,0,1,0,1,0]$，$C^n = [0,1,1,0,0]$。将 $(C^p,C^n)$ 映射到一个索引，然后将该索引映射回一个有序对。当且仅当恢复的有序对等于原始有序对时，输出true。\n\n- 测试3（零粒子边界情况）：$\\Omega_p = 4$，$Z = 0$，$\\Omega_n = 3$，$N = 0$。设 $Z^p = [0,0,0,0]$，$Z^n = [0,0,0]$。将 $(Z^p,Z^n)$ 映射到一个索引。当且仅当该索引等于 $0$ 时，输出true。\n\n- 测试4（全占据边界情况）：$\\Omega_p = 5$，$Z = 5$，$\\Omega_n = 4$，$N = 4$。设 $F^p = [1,1,1,1,1]$，$F^n = [1,1,1,1]$。设 $D$ 是这些参数下的基矢态总数。将 $(F^p,F^n)$ 映射到一个索引。当且仅当该索引等于 $D - 1$ 时，输出true。\n\n- 测试5（哈密顿量应用下单体移动的快速查找）：$\\Omega_p = 6$，$Z = 3$，$\\Omega_n = 5$，$N = 2$。设 $D^p = [0,1,0,1,0,1]$，$D^n = [1,0,0,1,0]$。应用一个质子单体移动，将位置 $i=1$ 处的占据轨道移动到位置 $j=2$ 处的未占据轨道，产生 $D^{p'} = [0,0,1,1,0,1]$，同时保持 $D^n$ 不变。使用您的映射计算 $(D^p,D^n)$ 和 $(D^{p'},D^n)$ 的索引。同时，构建一个从位串的整数打包表示到索引的哈希映射，并用它来检索 $(D^{p'},D^n)$ 的索引。当且仅当两种方法为 $(D^{p'},D^n)$ 产生的索引相同时，输出true。\n\n- 测试6（固定质子构型下的相邻中子构型）：$\\Omega_p = 5$，$Z = 2$，$\\Omega_n = 5$，$N = 3$。设质子构型固定为 $P^p = [0,1,0,0,1]$。设 $A^n = [0,0,1,1,1]$ 和 $B^n = [0,1,0,1,1]$。计算 $(P^p,A^n)$ 和 $(P^p,B^n)$ 的索引。当且仅当 $(P^p,B^n)$ 的索引等于 $(P^p,A^n)$ 的索引加 $1$ 时，输出true。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，\"[true1,true2,true3,true4,true5,true6]\"）。所有布尔值必须使用编程语言的原生布尔文字打印。", "solution": "用户提供的问题陈述已经过分析，并被确定为**有效**。它在科学上是合理的、适定的和客观的，提出了一个计算多体物理学中的标准问题。任务是创建一个从核壳模型态的基矢到连续整数集的双射、保序映射及其逆映射。\n\n### 基于原理的设计\n\n问题的核心是为组合构建一个保持字典序的映射，通常称为“排序”（ranking）函数。多体基矢态是位串的有序对 $(b^p, b^n)$，它们的整体字典序表明可以使用行主序（row-major）索引方案。总索引可以表示为质子和中子位串各自索引的函数。\n\n#### 1. 将单个位串映射到索引（排序）\n\n首先，我们考虑单个粒子种类的映射，例如，将一个长度为 $\\Omega_p$、有 $Z$ 个1的质子位串 $b^p$ 映射到一个整数索引。这种不同位串的总数是 $D_p = \\binom{\\Omega_p}{Z}$。目标是找到一个双射且保持字典序的函数 $\\mathcal{M}_{\\text{lex}}(b^p) \\to \\{0, 1, \\dots, D_p-1\\}$。\n\n位串 $b$ 的字典序索引恰好是所有字典序上小于 $b$ 的有效位串的数量。我们可以通过从左到右遍历位串来确定这个数量。\n\n设位串为 $b = (b_0, b_1, \\dots, b_{\\Omega-1})$，长度为 $\\Omega$，有 $K$ 个1。通过累加在每个位置“跳过”的组合数来构建排序值。组合数由二项式系数 $\\binom{n}{k}$ 给出，为了效率，我们可以预先计算并存储在查找表中。\n\n映射算法如下：\n初始化排序值为 $0$，需要放置的1的数量为 $k=K$，可用位置数为 $\\omega=\\Omega$。从左到右迭代（位置 $i=0$ 到 $\\Omega-1$）：\n1. 可用位置数减一，$\\omega \\leftarrow \\omega - 1$。\n2. 检查比特 $b_i$。\n   - 如果 $b_i=0$：该字符串属于以当前前缀后跟一个0开头的组合块。这些组合在字典序上都小于在当前位置以1开头的组合。我们不增加排序值，并继续处理下一个比特。尚需放置的1的数量 $k$ 保持不变。\n   - 如果 $b_i=1$：该字符串在字典序上大于所有在位置 $i$ 处为0（给定相同前缀）的有效组合。必须将这些较小编号的组合数量加到我们的排序值中。如果我们在位置 $i$ 放置一个0，那么我们需要在剩余的 $\\omega$ 个位置中放置剩下的 $k$ 个1。实现这一点的方法数是 $\\binom{\\omega}{k}$。我们将此值加到排序值上。由于我们现在已经放置了一个1，我们将剩余要放置的1的数量减一，$k \\leftarrow k - 1$。\n\n这个过程唯一地确定了任何给定比特串的字典序排序值。对于一个有 $K$ 个1的位串 $b = (b_i)_{i=0}^{\\Omega-1}$，其索引为：\n$$\n\\text{Index}(b) = \\sum_{i=0}^{\\Omega-1} b_i \\cdot \\binom{\\Omega-1-i}{K - \\sum_{j=0}^{i-1} b_j}\n$$\n这种迭代公式是高效的，仅依赖于整数运算和预计算的二项式系数表，达到了所需的 $\\mathcal{O}(\\Omega)$ 复杂度。\n\n#### 2. 将索引映射回位串（逆排序）\n\n逆映射，或称逆排序（unranking），从其字典序索引重建位串。给定一个排序值 $I \\in \\{0, 1, \\dots, \\binom{\\Omega}{K}-1\\}$，我们从左到右逐个确定字符串 $b$ 的比特。\n\n在每个位置 $i=0, \\dots, \\Omega-1$：\n1. 我们确定 $b_i$ 应该是 $0$ 还是 $1$。\n2. 考虑一个假设的比特 $b_i=0$。完成该位串（在剩余的 $\\omega$ 个位置中放置剩下的 $k$ 个1）的可能有效方式的数量是 $\\binom{\\omega}{k}$。\n3. 将当前的排序值 $I$ 与此计数进行比较。\n   - 如果 $I  \\binom{\\omega}{k}$：目标位串位于这块组合中。因此，$b_i$ 必须是 $0$。我们设置 $b_i=0$ 并继续到下一个位置。排序值 $I$ 和剩余的1的数量 $k$ 保持不变。\n   - 如果 $I \\ge \\binom{\\omega}{k}$：目标位串在字典序上大于所有在当前位置为0的组合。因此，$b_i$ 必须是 $1$。我们设置 $b_i=1$，从排序值中减去 $\\binom{\\omega}{k}$（$I \\leftarrow I - \\binom{\\omega}{k}$），并减少要放置的1的数量（$k \\leftarrow k-1$）。\n4. 我们对所有位置重复此过程以构建完整的位串。这也是一个 $\\mathcal{O}(\\Omega)$ 的过程。\n\n#### 3. 组合质子和中子空间\n\n基矢态是有序对 $(b^p, b^n)$。这些对的字典序定义为首先比较 $b^p$，仅当它们相同时才比较 $b^n$。这对应于一个二维矩阵的行主序布局，其中行由质子态索引，列由中子态索引。\n\n设 $\\mathcal{M}_p(b^p)$ 是质子态 $b^p$ 在其大小为 $D_p = \\binom{\\Omega_p}{Z}$ 的空间中的排序值，$\\mathcal{M}_n(b^n)$ 是中子态 $b^n$ 在其大小为 $D_n = \\binom{\\Omega_n}{N}$ 的空间中的排序值。有序对 $(b^p, b^n)$ 的总索引 $I$ 由下式给出：\n$$\nI(b^p, b^n) = \\mathcal{M}_p(b^p) \\cdot D_n + \\mathcal{M}_n(b^n)\n$$\n基矢的总维度是 $D = D_p \\cdot D_n$。\n\n从总索引 $I$ 到有序对 $(b^p, b^n)$ 的逆映射使用整数除法和模运算找到：\n$$\n\\mathcal{M}_p = I \\ // \\ D_n\n$$\n$$\n\\mathcal{M}_n = I \\ \\% \\ D_n\n$$\n然后，使用上面描述的单粒子种类逆排序算法，从它们各自的排序值 $\\mathcal{M}_p$ 和 $\\mathcal{M}_n$ 重建单个位串 $b^p$ 和 $b^n$。对于组合系统，正向和逆向映射的时间复杂度均为 $\\mathcal{O}(\\Omega_p + \\Omega_n)$，满足所有问题要求。", "answer": "```python\nimport numpy as np\n\nclass NuclearBasisMapper:\n    \"\"\"\n    Manages the mapping between nuclear many-body basis states (represented by\n    proton and neutron occupancy bitstrings) and unique integer indices.\n\n    The mapping preserves lexicographical order and is designed for fast\n    computation, suitable for constructing and applying Hamiltonians in\n    shell-model calculations.\n    \"\"\"\n    _C = None\n    _MAX_OMEGA = 0\n\n    def __init__(self, omega_p, z, omega_n, n):\n        \"\"\"\n        Initializes the mapper for a given nuclear system.\n\n        Args:\n            omega_p (int): Number of single-particle orbitals for protons.\n            z (int): Number of protons.\n            omega_n (int): Number of single-particle orbitals for neutrons.\n            n (int): Number of neutrons.\n        \"\"\"\n        self.omega_p = omega_p\n        self.z = z\n        self.omega_n = omega_n\n        self.n_neutrons = n\n\n        max_omega_needed = max(omega_p, omega_n, 0)\n        self._precompute_binom(max_omega_needed)\n        \n        # Guard against invalid parameters (e.g., more particles than orbitals)\n        if not (0 = self.z = self.omega_p and 0 = self.n_neutrons = self.omega_n):\n             self.dim_p = 0\n             self.dim_n = 0\n        else:\n             self.dim_p = self._C[self.omega_p, self.z]\n             self.dim_n = self._C[self.omega_n, self.n_neutrons]\n\n        self.total_dim = self.dim_p * self.dim_n\n\n    @classmethod\n    def _precompute_binom(cls, max_val):\n        \"\"\"Precomputes binomial coefficients up to max_val.\"\"\"\n        if max_val = cls._MAX_OMEGA:\n            return\n        \n        cls._MAX_OMEGA = max_val\n        c = np.zeros((max_val + 1, max_val + 1), dtype=np.int64)\n        for i in range(max_val + 1):\n            c[i, 0] = 1\n            for j in range(1, i + 1):\n                c[i, j] = c[i - 1, j - 1] + c[i - 1, j]\n        cls._C = c\n\n    def _get_rank_lex(self, b_list, omega, k):\n        \"\"\"Calculates the lexicographical rank of a single bitstring.\"\"\"\n        if k  0 or k > omega:\n            raise ValueError(f\"Number of particles {k} must be in [0, {omega}]\")\n\n        rank = 0\n        rem_k = k\n        rem_omega = omega\n        for bit in b_list:\n            rem_omega -= 1\n            if rem_k == 0:\n                break\n            \n            if bit == 1:\n                # This bit is 1, so we skip all combinations where this bit is 0.\n                # The number of such combinations is the number of ways to place\n                # the remaining rem_k particles in the remaining rem_omega slots.\n                if rem_omega >= rem_k:\n                    rank += self._C[rem_omega, rem_k]\n                rem_k -= 1\n        return rank\n\n    def _get_state_from_lex_rank(self, rank, omega, k):\n        \"\"\"Reconstructs a bitstring from its lexicographical rank.\"\"\"\n        if k  0 or k > omega:\n            raise ValueError(f\"Number of particles {k} must be in [0, {omega}]\")\n\n        b = []\n        rem_k = k\n        current_rank = rank\n        \n        for i in range(omega):\n            rem_omega_suffix = omega - 1 - i\n            \n            # Optimization: if all remaining must be 1s or 0s\n            if rem_k == rem_omega_suffix + 1:\n                b.extend([1] * rem_k)\n                break\n            if rem_k == 0:\n                b.extend([0] * (rem_omega_suffix + 1))\n                break\n\n            # Number of combinations if we choose 0 at this position\n            comb_with_zero = self._C[rem_omega_suffix, rem_k]\n            \n            if current_rank  comb_with_zero:\n                b.append(0)\n            else:\n                b.append(1)\n                current_rank -= comb_with_zero\n                rem_k -= 1\n        return b\n\n    def get_index(self, b_p, b_n):\n        \"\"\"Computes the total index for a given proton-neutron state pair.\"\"\"\n        idx_p = self._get_rank_lex(b_p, self.omega_p, self.z)\n        idx_n = self._get_rank_lex(b_n, self.omega_n, self.n_neutrons)\n        return idx_p * self.dim_n + idx_n\n\n    def get_state(self, total_idx):\n        \"\"\"Recovers the proton-neutron state pair from a total index.\"\"\"\n        if total_idx >= self.total_dim:\n            raise ValueError(\"Total index is out of bounds.\")\n            \n        idx_p = total_idx // self.dim_n\n        idx_n = total_idx % self.dim_n\n        \n        b_p = self._get_state_from_lex_rank(idx_p, self.omega_p, self.z)\n        b_n = self._get_state_from_lex_rank(idx_n, self.omega_n, self.n_neutrons)\n        return (b_p, b_n)\n\ndef solve():\n    \"\"\"Runs the test suite specified in the problem statement.\"\"\"\n    \n    test_cases_params = [\n        (6, 3, 5, 2),  # Test 1\n        (6, 3, 5, 2),  # Test 2\n        (4, 0, 3, 0),  # Test 3\n        (5, 5, 4, 4),  # Test 4\n        (6, 3, 5, 2),  # Test 5\n        (5, 2, 5, 3),  # Test 6\n    ]\n\n    results = []\n\n    # Test 1: Lexicographic order preservation\n    omega_p, z, omega_n, n = test_cases_params[0]\n    mapper1 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    a_p, a_n = [0,0,1,1,1,0], [0,1,0,1,0]\n    b_p, b_n = [0,1,0,1,1,0], [0,0,1,1,0]\n    idx_A = mapper1.get_index(a_p, a_n)\n    idx_B = mapper1.get_index(b_p, b_n)\n    results.append(idx_A  idx_B)\n\n    # Test 2: Round-trip bijection\n    omega_p, z, omega_n, n = test_cases_params[1]\n    mapper2 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    c_p, c_n = [1,0,1,0,1,0], [0,1,1,0,0]\n    idx_C = mapper2.get_index(c_p, c_n)\n    rec_p, rec_n = mapper2.get_state(idx_C)\n    results.append(c_p == rec_p and c_n == rec_n)\n\n    # Test 3: Boundary case with zero particles\n    omega_p, z, omega_n, n = test_cases_params[2]\n    mapper3 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    z_p, z_n = [0,0,0,0], [0,0,0]\n    idx_Z = mapper3.get_index(z_p, z_n)\n    results.append(idx_Z == 0)\n\n    # Test 4: Boundary case with full occupancy\n    omega_p, z, omega_n, n = test_cases_params[3]\n    mapper4 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    f_p, f_n = [1,1,1,1,1], [1,1,1,1]\n    idx_F = mapper4.get_index(f_p, f_n)\n    D = mapper4.total_dim\n    results.append(idx_F == D - 1)\n\n    # Test 5: Fast lookup under a one-body move\n    omega_p, z, omega_n, n = test_cases_params[4]\n    mapper5 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    d_p, d_n = [0,1,0,1,0,1], [1,0,0,1,0]\n    d_p_prime = [0,0,1,1,0,1]\n    idx1 = mapper5.get_index(d_p_prime, d_n)\n    \n    # Simulate a hash map lookup as described\n    int_p_prime = int(\"\".join(map(str, d_p_prime)), 2)\n    int_n = int(\"\".join(map(str, d_n)), 2)\n    key = (int_p_prime, int_n)\n    hash_map = {key: idx1}\n    idx2 = hash_map[key]\n    results.append(idx1 == idx2)\n\n    # Test 6: Adjacent neutron configurations\n    omega_p, z, omega_n, n = test_cases_params[5]\n    mapper6 = NuclearBasisMapper(omega_p, z, omega_n, n)\n    p_p = [0,1,0,0,1]\n    a_n, b_n = [0,0,1,1,1], [0,1,0,1,1] # These are adjacent in lex order\n    idx_A_pair = mapper6.get_index(p_p, a_n)\n    idx_B_pair = mapper6.get_index(p_p, b_n)\n    results.append(idx_B_pair == idx_A_pair + 1)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "3575545"}, {"introduction": "所构建的希尔伯特空间不仅仅是一个状态列表，它更是物理算符作用的舞台，其中包括那些用于恢复在平均场层面被破坏的对称性的算符。这个高级练习深入探讨了对称性恢复，重点关注如何从一个宇称不再是好量子数的基中投影出具有确定宇称的本征态。本练习提供了一个具体的例子，展示了如何操作基矢状态以构建具有明确物理性质的状态，这是现代核结构理论中的一项关键技术。[@problem_id:3575598]", "problem": "在原子核的反射不对称平均场描述中，宇称算符 $\\Pi$ 与平均场哈密顿量不对易，单粒子本征态是相反宇称组分的混合态。设 $\\{|u_{i}^{+}\\rangle\\}_{i=1}^{M}$ 和 $\\{|v_{i}^{-}\\rangle\\}_{i=1}^{M}$ 是两组具有确定宇称的单粒子态的正交归一集，满足 $\\Pi|u_{i}^{+}\\rangle=+|u_{i}^{+}\\rangle$ 和 $\\Pi|v_{i}^{-}\\rangle=-|v_{i}^{-}\\rangle$，以及 $\\langle u_{i}^{+}|u_{j}^{+}\\rangle=\\delta_{ij}$，$\\langle v_{i}^{-}|v_{j}^{-}\\rangle=\\delta_{ij}$，和 $\\langle u_{i}^{+}|v_{j}^{-}\\rangle=0$。一个形变平均场单粒子态可参数化为\n$$\n|\\phi_{i}\\rangle=\\cos\\theta_{i}\\,|u_{i}^{+}\\rangle+\\sin\\theta_{i}\\,|v_{i}^{-}\\rangle,\n$$\n其中 $0\\leq\\theta_{i}\\leq\\frac{\\pi}{2}$。\n\n利用宇称算符 $\\Pi$ 和投影算符 $P_{\\pm}=\\frac{1\\pm\\Pi}{2}$ 的基本性质，从 $\\{|\\phi_{i}\\rangle\\}$ 构建一个宇称投影的单粒子基。然后，在二次量子化 (SQ) 框架内，设 $c_{u_{i}^{+}}^{\\dagger}$ 和 $c_{v_{i}^{-}}^{\\dagger}$ 分别表示 $|u_{i}^{+}\\rangle$ 和 $|v_{i}^{-}\\rangle$ 的产生算符，并定义混合宇称产生算符\n$$\na_{i}^{\\dagger}=\\cos\\theta_{i}\\,c_{u_{i}^{+}}^{\\dagger}+\\sin\\theta_{i}\\,c_{v_{i}^{-}}^{\\dagger},\n$$\n作用在粒子真空态 $|0\\rangle$ 上。考虑两费米子反对称 Slater 态\n$$\n|\\Phi_{12}\\rangle=a_{1}^{\\dagger}a_{2}^{\\dagger}|0\\rangle,\n$$\n以及作用在两粒子扇区上的两体宇称算符 $\\Pi^{(2)}=\\Pi_{1}\\Pi_{2}$（其作用方式为乘法）。构造正宇称投影的两体态 $|\\Phi_{12}^{(+)}\\rangle=P_{+}^{(2)}|\\Phi_{12}\\rangle$，其中 $P_{+}^{(2)}=\\frac{1+\\Pi^{(2)}}{2}$，并推导其在由 $\\{c_{u_{i}^{+}}^{\\dagger},c_{v_{i}^{-}}^{\\dagger}\\}$ 生成的正交归一 Slater 基中的显式展开。\n\n最后，确定归一化因子 $N_{+}$，使得归一化的正宇称两体态 $|\\Psi_{12}^{(+)}\\rangle=N_{+}|\\Phi_{12}^{(+)}\\rangle$ 满足 $\\langle\\Psi_{12}^{(+)}|\\Psi_{12}^{(+)}\\rangle=1$。将 $N_{+}$ 的最终答案表示为关于 $\\theta_{1}$ 和 $\\theta_{2}$ 的闭合形式解析表达式。不需要进行数值计算，也不涉及单位。", "solution": "该问题要求从反射不对称平均场描述中构建宇称投影的两体态，并确定其归一化常数。我们首先将验证问题的陈述。\n\n### 问题验证\n**步骤 1：提取已知条件**\n- **宇称算符：** $\\Pi$。\n- **正交归一的单粒子基：** $\\{|u_{i}^{+}\\rangle\\}_{i=1}^{M}$ 满足 $\\Pi|u_{i}^{+}\\rangle=+|u_{i}^{+}\\rangle$ 和 $\\{|v_{i}^{-}\\rangle\\}_{i=1}^{M}$ 满足 $\\Pi|v_{i}^{-}\\rangle=-|v_{i}^{-}\\rangle$。\n- **正交归一性条件：** $\\langle u_{i}^{+}|u_{j}^{+}\\rangle=\\delta_{ij}$，$\\langle v_{i}^{-}|v_{j}^{-}\\rangle=\\delta_{ij}$，$\\langle u_{i}^{+}|v_{j}^{-}\\rangle=0$。\n- **形变单粒子态：** $|\\phi_{i}\\rangle=\\cos\\theta_{i}\\,|u_{i}^{+}\\rangle+\\sin\\theta_{i}\\,|v_{i}^{-}\\rangle$，其中 $0\\leq\\theta_{i}\\leq\\frac{\\pi}{2}$。\n- **投影算符：** $P_{\\pm}=\\frac{1\\pm\\Pi}{2}$。\n- **二次量子化算符：** $c_{u_{i}^{+}}^{\\dagger}$， $c_{v_{i}^{-}}^{\\dagger}$，以及 $a_{i}^{\\dagger}=\\cos\\theta_{i}\\,c_{u_{i}^{+}}^{\\dagger}+\\sin\\theta_{i}\\,c_{v_{i}^{-}}^{\\dagger}$。\n- **两费米子态：** $|\\Phi_{12}\\rangle=a_{1}^{\\dagger}a_{2}^{\\dagger}|0\\rangle$。\n- **两体算符：** 宇称 $\\Pi^{(2)}=\\Pi_{1}\\Pi_{2}$ 和投影 $P_{+}^{(2)}=\\frac{1+\\Pi^{(2)}}{2}$。\n- **投影态：** 未归一化的 $|\\Phi_{12}^{(+)}\\rangle=P_{+}^{(2)}|\\Phi_{12}\\rangle$ 和归一化的 $|\\Psi_{12}^{(+)}\\rangle=N_{+}|\\Phi_{12}^{(+)}\\rangle$ 满足 $\\langle\\Psi_{12}^{(+)}|\\Psi_{12}^{(+)}\\rangle=1$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，植根于对称性破缺和恢复（特别是宇称）的标准核多体形式体系。平均场理论、二次量子化和投影算符等概念的表述正确，并与量子力学的既定原理一致。该问题提法得当，提供了推导归一化因子 $N_{+}$ 的唯一解析解所需的所有必要定义和约束。语言客观、正式。问题本身是自洽的，没有矛盾。\n\n**步骤 3：结论和行动**\n问题是有效的。我们将着手推导解答。\n\n### 解答推导\n问题陈述包括三个部分：构建单粒子投影基，展开投影的两体态，以及求其归一化。\n\n首先，我们解决从集合 $\\{|\\phi_{i}\\rangle\\}$ 构建宇称投影单粒子基的问题。将宇称投影算符 $P_{\\pm}=\\frac{1\\pm\\Pi}{2}$ 应用于态 $|\\phi_{i}\\rangle$ 会得到其定宇称组分。\n$$P_{+} |\\phi_{i}\\rangle = \\frac{1+\\Pi}{2} (\\cos\\theta_{i}\\,|u_{i}^{+}\\rangle+\\sin\\theta_{i}\\,|v_{i}^{-}\\rangle) = \\frac{1}{2}(\\cos\\theta_{i}\\,|u_{i}^{+}\\rangle+\\sin\\theta_{i}\\,|v_{i}^{-}\\rangle + \\cos\\theta_{i}\\,|u_{i}^{+}\\rangle-\\sin\\theta_{i}\\,|v_{i}^{-}\\rangle) = \\cos\\theta_{i}\\,|u_{i}^{+}\\rangle$$\n$$P_{-} |\\phi_{i}\\rangle = \\frac{1-\\Pi}{2} (\\cos\\theta_{i}\\,|u_{i}^{+}\\rangle+\\sin\\theta_{i}\\,|v_{i}^{-}\\rangle) = \\frac{1}{2}(\\cos\\theta_{i}\\,|u_{i}^{+}\\rangle+\\sin\\theta_{i}\\,|v_{i}^{-}\\rangle - \\cos\\theta_{i}\\,|u_{i}^{+}\\rangle+\\sin\\theta_{i}\\,|v_{i}^{-}\\rangle) = \\sin\\theta_{i}\\,|v_{i}^{-}\\rangle$$\n将这些投影组分归一化（分别对于 $\\theta_i \\neq \\frac{\\pi}{2}$ 和 $\\theta_i \\neq 0$ 的情况）可以恢复原始的正交归一基态 $|u_{i}^{+}\\rangle$ 和 $|v_{i}^{-}\\rangle$。因此，集合 $\\{|u_{i}^{+}\\rangle, |v_{i}^{-}\\rangle\\}_{i=1}^{M}$ 构成了所需的宇称投影正交归一基。\n\n接下来，我们推导正宇称投影的两体态 $|\\Phi_{12}^{(+)}\\rangle$ 的展开式。我们首先展开未投影的态 $|\\Phi_{12}\\rangle=a_{1}^{\\dagger}a_{2}^{\\dagger}|0\\rangle$。\n$$a_{1}^{\\dagger} = \\cos\\theta_{1}\\,c_{u_{1}^{+}}^{\\dagger}+\\sin\\theta_{1}\\,c_{v_{1}^{-}}^{\\dagger}$$\n$$a_{2}^{\\dagger} = \\cos\\theta_{2}\\,c_{u_{2}^{+}}^{\\dagger}+\\sin\\theta_{2}\\,c_{v_{2}^{-}}^{\\dagger}$$\n算符 $c_{u_{1}^{+}}^{\\dagger}, c_{v_{1}^{-}}^{\\dagger}, c_{u_{2}^{+}}^{\\dagger}, c_{v_{2}^{-}}^{\\dagger}$ 被假定对应于四个不同的、正交的单粒子态，因此它们反对易。\n$$|\\Phi_{12}\\rangle = (\\cos\\theta_{1}\\,c_{u_{1}^{+}}^{\\dagger}+\\sin\\theta_{1}\\,c_{v_{1}^{-}}^{\\dagger})(\\cos\\theta_{2}\\,c_{u_{2}^{+}}^{\\dagger}+\\sin\\theta_{2}\\,c_{v_{2}^{-}}^{\\dagger})|0\\rangle$$\n$$|\\Phi_{12}\\rangle = (\\cos\\theta_{1}\\cos\\theta_{2}\\,c_{u_{1}^{+}}^{\\dagger}c_{u_{2}^{+}}^{\\dagger} + \\cos\\theta_{1}\\sin\\theta_{2}\\,c_{u_{1}^{+}}^{\\dagger}c_{v_{2}^{-}}^{\\dagger} + \\sin\\theta_{1}\\cos\\theta_{2}\\,c_{v_{1}^{-}}^{\\dagger}c_{u_{2}^{+}}^{\\dagger} + \\sin\\theta_{1}\\sin\\theta_{2}\\,c_{v_{1}^{-}}^{\\dagger}c_{v_{2}^{-}}^{\\dagger})|0\\rangle$$\n让我们将正交归一的两体 Slater 基态表示为 $|k_{1}k_{2}\\rangle = c_{k_{1}}^{\\dagger}c_{k_{2}}^{\\dagger}|0\\rangle$。展开式为：\n$$|\\Phi_{12}\\rangle = \\cos\\theta_{1}\\cos\\theta_{2}\\,|u_{1}^{+}u_{2}^{+}\\rangle + \\cos\\theta_{1}\\sin\\theta_{2}\\,|u_{1}^{+}v_{2}^{-}\\rangle + \\sin\\theta_{1}\\cos\\theta_{2}\\,|v_{1}^{-}u_{2}^{+}\\rangle + \\sin\\theta_{1}\\sin\\theta_{2}\\,|v_{1}^{-}v_{2}^{-}\\rangle$$\n两体宇称算符 $\\Pi^{(2)}$ 作用于这些基态的结果取决于构成它们的单粒子态的宇称。一个态 $|k_{1}k_{2}\\rangle$ 的宇称为 $p_{1}p_{2}$。\n- $\\Pi^{(2)}|u_{1}^{+}u_{2}^{+}\\rangle = (+1)(+1)|u_{1}^{+}u_{2}^{+}\\rangle = +|u_{1}^{+}u_{2}^{+}\\rangle$ (正宇称)\n- $\\Pi^{(2)}|u_{1}^{+}v_{2}^{-}\\rangle = (+1)(-1)|u_{1}^{+}v_{2}^{-}\\rangle = -|u_{1}^{+}v_{2}^{-}\\rangle$ (负宇称)\n- $\\Pi^{(2)}|v_{1}^{-}u_{2}^{+}\\rangle = (-1)(+1)|v_{1}^{-}u_{2}^{+}\\rangle = -|v_{1}^{-}u_{2}^{+}\\rangle$ (负宇称)\n- $\\Pi^{(2)}|v_{1}^{-}v_{2}^{-}\\rangle = (-1)(-1)|v_{1}^{-}v_{2}^{-}\\rangle = +|v_{1}^{-}v_{2}^{-}\\rangle$ (正宇称)\n\n现在，我们应用正宇称投影算符 $P_{+}^{(2)}=\\frac{1+\\Pi^{(2)}}{2}$：\n$$|\\Phi_{12}^{(+)}\\rangle = P_{+}^{(2)}|\\Phi_{12}\\rangle$$\n投影算符会湮灭负宇称组分（$|u_{1}^{+}v_{2}^{-}\\rangle$ 和 $|v_{1}^{-}u_{2}^{+}\\rangle$），并对正宇称组分（$|u_{1}^{+}u_{2}^{+}\\rangle$ 和 $|v_{1}^{-}v_{2}^{-}\\rangle$）起到单位算符的作用。\n$$P_{+}^{(2)}(\\cos\\theta_{1}\\sin\\theta_{2}|u_{1}^{+}v_{2}^{-}\\rangle) = \\frac{1-1}{2}\\cos\\theta_{1}\\sin\\theta_{2}|u_{1}^{+}v_{2}^{-}\\rangle = 0$$\n$$P_{+}^{(2)}(\\sin\\theta_{1}\\cos\\theta_{2}|v_{1}^{-}u_{2}^{+}\\rangle) = \\frac{1-1}{2}\\sin\\theta_{1}\\cos\\theta_{2}|v_{1}^{-}u_{2}^{+}\\rangle = 0$$\n$$P_{+}^{(2)}(\\cos\\theta_{1}\\cos\\theta_{2}|u_{1}^{+}u_{2}^{+}\\rangle) = \\frac{1+1}{2}\\cos\\theta_{1}\\cos\\theta_{2}|u_{1}^{+}u_{2}^{+}\\rangle = \\cos\\theta_{1}\\cos\\theta_{2}|u_{1}^{+}u_{2}^{+}\\rangle$$\n$$P_{+}^{(2)}(\\sin\\theta_{1}\\sin\\theta_{2}|v_{1}^{-}v_{2}^{-}\\rangle) = \\frac{1+1}{2}\\sin\\theta_{1}\\sin\\theta_{2}|v_{1}^{-}v_{2}^{-}\\rangle = \\sin\\theta_{1}\\sin\\theta_{2}|v_{1}^{-}v_{2}^{-}\\rangle$$\n将这些结果相加，得到投影态的显式展开：\n$$|\\Phi_{12}^{(+)}\\rangle = \\cos\\theta_{1}\\cos\\theta_{2}\\,|u_{1}^{+}u_{2}^{+}\\rangle + \\sin\\theta_{1}\\sin\\theta_{2}\\,|v_{1}^{-}v_{2}^{-}\\rangle$$\n\n最后，我们根据条件 $\\langle\\Psi_{12}^{(+)}|\\Psi_{12}^{(+)}\\rangle=1$ 确定归一化因子 $N_{+}$，这意味着 $N_{+}^{-2} = \\langle\\Phi_{12}^{(+)}|\\Phi_{12}^{(+)}\\rangle$。我们计算 $|\\Phi_{12}^{(+)}\\rangle$ 的模方：\n$$\\langle\\Phi_{12}^{(+)}|\\Phi_{12}^{(+)}\\rangle = \\langle(\\cos\\theta_{1}\\cos\\theta_{2}\\,\\langle u_{1}^{+}u_{2}^{+}| + \\sin\\theta_{1}\\sin\\theta_{2}\\,\\langle v_{1}^{-}v_{2}^{-}|) | (\\cos\\theta_{1}\\cos\\theta_{2}\\,|u_{1}^{+}u_{2}^{+}\\rangle + \\sin\\theta_{1}\\sin\\theta_{2}\\,|v_{1}^{-}v_{2}^{-}\\rangle)\\rangle$$\n基态 $|u_{1}^{+}u_{2}^{+}\\rangle$ 和 $|v_{1}^{-}v_{2}^{-}\\rangle$ 是正交归一的，因为它们是由四个不同的正交归一单粒子态构建的。因此，$\\langle u_{1}^{+}u_{2}^{+}|u_{1}^{+}u_{2}^{+}\\rangle=1$，$\\langle v_{1}^{-}v_{2}^{-}|v_{1}^{-}v_{2}^{-}\\rangle=1$，且交叉项 $\\langle u_{1}^{+}u_{2}^{+}|v_{1}^{-}v_{2}^{-}\\rangle=0$。内积简化为：\n$$\\langle\\Phi_{12}^{(+)}|\\Phi_{12}^{(+)}\\rangle = (\\cos\\theta_{1}\\cos\\theta_{2})^{2}\\langle u_{1}^{+}u_{2}^{+}|u_{1}^{+}u_{2}^{+}\\rangle + (\\sin\\theta_{1}\\sin\\theta_{2})^{2}\\langle v_{1}^{-}v_{2}^{-}|v_{1}^{-}v_{2}^{-}\\rangle$$\n$$\\langle\\Phi_{12}^{(+)}|\\Phi_{12}^{(+)}\\rangle = \\cos^{2}\\theta_{1}\\cos^{2}\\theta_{2} + \\sin^{2}\\theta_{1}\\sin^{2}\\theta_{2}$$\n归一化因子 $N_{+}$ 是该量平方根的倒数（假设 $N_{+}$ 是实数且为正）：\n$$N_{+} = \\frac{1}{\\sqrt{\\cos^{2}\\theta_{1}\\cos^{2}\\theta_{2} + \\sin^{2}\\theta_{1}\\sin^{2}\\theta_{2}}}$$\n此表达式即为所求的归一化因子的闭合形式解析结果。", "answer": "$$\n\\boxed{\\frac{1}{\\sqrt{\\cos^{2}\\theta_{1}\\cos^{2}\\theta_{2} + \\sin^{2}\\theta_{1}\\sin^{2}\\theta_{2}}}}\n$$", "id": "3575598"}]}