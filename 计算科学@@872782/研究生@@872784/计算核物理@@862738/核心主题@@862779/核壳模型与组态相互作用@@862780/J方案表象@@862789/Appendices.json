{"hands_on_practices": [{"introduction": "`J`方案表示法的核心优势在于直接使用具有确定总角动量`J`的基态。这种方法虽然在概念上很清晰，但在实践中需要熟练掌握角动量耦合代数。本练习提供了一个具体的操作机会，通过耦合核子对来构建多体态，这是许多原子核模型中的基本构造单元。通过该练习，您将深入理解如何运用重耦合系数（如9j符号）来处理费米子反对称性，这是构建J方案基矢的核心技术之一 ([@problem_id:3602884])。", "problem": "考虑四个相同的核子，它们被限制在总单粒子角动量为 $j \\geq \\frac{5}{2}$ 的单个轨道上，因此总角动量 $J=0$ 的子空间维数为 2（对应 seniority 数 $v=0$ 和 $v=4$）。在总角动量耦合表示（$J$ 方案）下进行计算。定义归一化的双费米子对产生算符\n$$\nA^{\\dagger}_{J M} \\equiv \\frac{1}{\\sqrt{2}} \\sum_{m_{1},m_{2}} \\langle j m_{1}\\, j m_{2} \\mid J M \\rangle\\, a^{\\dagger}_{j m_{1}} a^{\\dagger}_{j m_{2}},\n$$\n并通过将两个相同的对耦合至总 $J=0$ 来构造反对称化的四费米子态，\n$$\n\\lvert \\Phi_{J_{p}} \\rangle \\equiv \\bigl[ A^{\\dagger}_{J_{p}} \\times A^{\\dagger}_{J_{p}} \\bigr]_{00} \\lvert 0 \\rangle,\n$$\n其中对角动量为偶数 $J_{p} \\in \\{0,2\\}$，$[\\,\\cdot \\times \\cdot\\,]_{00}$ 表示耦合到总 $J=0$, $M=0$，而 $\\lvert 0 \\rangle$ 是粒子真空。\n\n(a) 从角动量耦合代数和费米子反对易关系出发，推导交叠矩阵元 $\\langle \\Phi_{J_{p}'} \\mid \\Phi_{J_{p}} \\rangle$ 的通用表达式，该表达式用一个重耦合系数表示，并通过一个依赖于 $j$、$J_{p}$、$J_{p}'$ 和总 $J=0$ 的 Wigner $9j$ 符号来表达交换（非正交性）贡献。\n\n(b) 利用 (a) 部分的结果论证，两个态 $\\{ \\lvert \\Phi_{0} \\rangle, \\lvert \\Phi_{2} \\rangle \\}$ 张成了 $J=0$ 的四粒子子空间（在此扇区内是完备的），并且可以通过一个 $2\\times 2$ 的 Gram-Schmidt 变换进行正交归一化。给出保证 Gram 矩阵正定性的交叠的明确条件。\n\n(c) 提供非对角交叠元 $\\langle \\Phi_{0} \\mid \\Phi_{2} \\rangle$ 作为 $j$ 的函数的闭合形式解析表达式，用单个 Wigner $9j$ 符号表示。你的最终答案必须是单个闭合形式的解析表达式。不需要进行数值计算，也不需要四舍五入。", "solution": "该问题要求分析单 $j$ 壳层中通过耦合相同核子对构建的四粒子态。我们必须首先验证问题陈述的有效性。\n\n### 步骤 1：提取已知条件\n-   **系统**：四个相同核子，位于单粒子角动量为 $j$ 的单个轨道上。\n-   **约束**：$j \\geq \\frac{5}{2}$。\n-   **子空间**：总角动量 $J=0$ 的子空间是二维的，由 seniority 数 $v=0$ 和 $v=4$ 的态张成。\n-   **对产生算符**：$A^{\\dagger}_{J M} \\equiv \\frac{1}{\\sqrt{2}} \\sum_{m_{1},m_{2}} \\langle j m_{1}\\, j m_{2} \\mid J M \\rangle\\, a^{\\dagger}_{j m_{1}} a^{\\dagger}_{j m_{2}}$。对于相同的费米子，只有当 $J$ 为偶数时，此算符才不为零。\n-   **四粒子态**：$\\lvert \\Phi_{J_{p}} \\rangle \\equiv \\bigl[ A^{\\dagger}_{J_{p}} \\times A^{\\dagger}_{J_{p}} \\bigr]_{00} \\lvert 0 \\rangle$，其中 $J_{p} \\in \\{0,2\\}$ 是相同对的角动量。符号 $[\\,\\cdot \\times \\cdot\\,]_{00}$ 表示耦合到总角动量 $J=0, M=0$。\n-   **真空**：$\\lvert 0 \\rangle$ 是粒子真空。\n-   **(a) 部分**：推导交叠 $\\langle \\Phi_{J_{p}'} \\mid \\Phi_{J_{p}} \\rangle$ 的通用表达式，其中交换贡献通过一个 Wigner $9j$ 符号表示。\n-   **(b) 部分**：论证 $\\{\\lvert \\Phi_{0} \\rangle, \\lvert \\Phi_{2} \\rangle\\}$ 张成 $J=0$ 子空间并且可以被正交归一化，并为此提供条件。\n-   **(c) 部分**：提供 $\\langle \\Phi_{0} \\mid \\Phi_{2} \\rangle$ 以单个 Wigner $9j$ 符号表示的闭合形式表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上基于原子核壳模型和量子力学中的角动量理论。算符和态的定义在该领域是标准的。约束条件 $j \\geq \\frac{5}{2}$ 是合适的，因为对于更小的 $j$ 值，四粒子 $J=0$ 空间的结构是不同的（例如，对于 $j=3/2$，只有一个 $J=0$ 态）。该问题提法得当、客观，并包含足够的信息以获得严谨的解。不存在科学缺陷、矛盾或模糊之处。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### (a) 交叠矩阵元的推导\n\n态 $\\lvert \\Phi_{J_p} \\rangle$ 是通过将两个相同的费米子对（每个对的角动量为 $J_p$）耦合到总角动量 $J=0$ 来构建的。具体来说，\n$$\n\\lvert \\Phi_{J_p} \\rangle = \\sum_{M_p} \\langle J_p M_p J_p (-M_p) \\mid 00 \\rangle A^{\\dagger}_{J_p M_p} A^{\\dagger}_{J_p, -M_p} \\lvert 0 \\rangle = \\frac{1}{\\sqrt{2J_p+1}} \\sum_{M_p} (-1)^{J_p-M_p} A^{\\dagger}_{J_p M_p} A^{\\dagger}_{J_p, -M_p} \\lvert 0 \\rangle.\n$$\n这些态是未归一化的。交叠矩阵元是 $\\langle \\Phi_{J_p'} \\mid \\Phi_{J_p} \\rangle$。这些态表示四粒子态，但表达式没有显现出不同对中粒子之间的完全反对称性。完整的计算涉及考虑对之间的粒子交换，这在“直接”项之外引入了一个“重耦合”项。直接项源于将对算符视为玻色子，而交换项则修正了它们的费米子子结构。\n\n对于这些未归一化的态，其完整的交叠是壳模型理论中的一个标准结果。它可以通过将对算符展开为单粒子算符并使用反对易关系来推导，或者更优雅地通过重耦合代数来推导。结果由下式给出：\n$$\n\\langle \\Phi_{J_p'} \\mid \\Phi_{J_p} \\rangle = 2\\delta_{J_p, J_p'} + 4\\sqrt{(2J_p+1)(2J_p'+1)} \\begin{Bmatrix} j & j & J_p \\\\ j & j & J_p' \\\\ J_p & J_p' & 0 \\end{Bmatrix}.\n$$\n此处，$\\begin{Bmatrix} \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot \\\\ \\cdot & \\cdot & \\cdot \\end{Bmatrix}$ 是 Wigner $9j$ 符号。\n\n第一项 $2\\delta_{J_p, J_p'}$ 是直接项。它来自于将算符当作简单玻色子进行缩并的两种方式：$\\langle 0 \\rvert A_{J_p'} A_{J_p'} A^{\\dagger}_{J_p} A^{\\dagger}_{J_p} \\lvert 0 \\rangle \\to \\langle A' A^{\\dagger} \\rangle \\langle A' A^{\\dagger} \\rangle + \\langle A' A^{\\dagger} \\rangle \\langle A' A^{\\dagger} \\rangle$。\n第二项是交换贡献，源于作用在属于不同对的费米子之间的泡利不相容原理。该项涉及将四个粒子的角动量从一个 $( (12)J_p', (34)J_p' )0$ 方案重耦合到一个 $( (12)J_p, (34)J_p )0$ 方案，但这需要经过一次粒子置换，例如 $P_{13}$。从像 $((12), (34))$ 这样的划分到 $((13), (24))$ 的重耦合是由 $9j$ 符号决定的。公式中特定的 $9j$ 符号捕捉了我们正在考虑的总角动量 $J=0$ 情况下这种重耦合的几何结构。\n\n### (b) 张成子空间与正交归一化\n\n问题陈述指出，对于 $j \\geq \\frac{5}{2}$，四粒子 $J=0$ 子空间的维数为 2。这些态按 seniority 数 $v$ 进行分类，即未耦合到角动量为零的对中的粒子数。两个基态分别是 seniority 数 $v=0$ 的态和 seniority 数 $v=4$ 的态。\n1.  **态 $\\lvert \\Phi_0 \\rangle$**：这个态是由 $J_p=0$ 的对构建的。算符 $A^{\\dagger}_{00}$ 产生一个总角动量为 0 的粒子对。根据定义，态 $\\lvert \\Phi_0 \\rangle \\propto (A^{\\dagger}_{00})^2 \\lvert 0 \\rangle$ 是 seniority 数 $v=0$ 的态。\n2.  **态 $\\lvert \\Phi_2 \\rangle$**：这个态是由 $J_p=2$ 的对构建的。因为它不是完全由 $J_p=0$ 的对构建的，所以它不是一个纯 seniority 数 $v=0$ 的态。可以证明，这个态是 seniority 数 $v=0$ 和 $v=4$ 基态的线性组合。\n\n由于 $\\lvert \\Phi_0 \\rangle$ 是纯 $v=0$ 态，而 $\\lvert \\Phi_2 \\rangle$ 同时具有 $v=0$ 和 $v=4$ 的分量，所以这两个态是线性无关的。因为我们在一个二维空间中有两个线性无关的态，它们构成一组基，因此张成了这个空间。\n\n对于任何一组线性无关的向量，都可以使用像 Gram-Schmidt 过程这样的方法将其正交归一化。这当且仅当内积的 Gram 矩阵 $G$ 是正定的才可能实现。Gram 矩阵为\n$$\nG = \\begin{pmatrix} \\langle \\Phi_0 \\mid \\Phi_0 \\rangle & \\langle \\Phi_0 \\mid \\Phi_2 \\rangle \\\\ \\langle \\Phi_2 \\mid \\Phi_0 \\rangle & \\langle \\Phi_2 \\mid \\Phi_2 \\rangle \\end{pmatrix}.\n$$\n正定性要求对角元素为正 ($G_{ii} > 0$) 且行列式为正 ($\\det(G) > 0$)。\n由于任何非零态矢量的范数都是正的，即 $\\langle \\Phi_{J_p} \\mid \\Phi_{J_p} \\rangle > 0$。因此，能够进行正交归一化的条件简化为要求行列式为正：\n$$\n\\det(G) = \\langle \\Phi_0 \\mid \\Phi_0 \\rangle \\langle \\Phi_2 \\mid \\Phi_2 \\rangle - |\\langle \\Phi_0 \\mid \\Phi_2 \\rangle|^2 > 0.\n$$\n这是严格形式的柯西-施瓦茨不等式，它当且仅当向量 $\\lvert \\Phi_0 \\rangle$ 和 $\\lvert \\Phi_2 \\rangle$ 线性无关时成立。正如我们从 seniority 数的角度论证的，它们是线性无关的，所以该条件得到满足。\n\n### (c) $\\langle \\Phi_{0} \\mid \\Phi_{2} \\rangle$ 的闭合形式表达式\n\n我们使用在 (a) 部分中推导的通用公式，来处理 $J_p' = 0$ 和 $J_p = 2$ 的特定非对角情况。\n$$\n\\langle \\Phi_{0} \\mid \\Phi_{2} \\rangle = 2\\delta_{0, 2} + 4\\sqrt{(2(0)+1)(2(2)+1)} \\begin{Bmatrix} j & j & 0 \\\\ j & j & 2 \\\\ 0 & 2 & 0 \\end{Bmatrix}.\n$$\n克罗内克 δ 函数 $\\delta_{0,2}$ 为 $0$。平方根下的项是 $(1)(5)=5$。\n因此，交叠为：\n$$\n\\langle \\Phi_{0} \\mid \\Phi_{2} \\rangle = 4\\sqrt{5} \\begin{Bmatrix} j & j & 0 \\\\ j & j & 2 \\\\ 0 & 2 & 0 \\end{Bmatrix}.\n$$\n问题要求用单个 Wigner $9j$ 符号来表示答案。这个表达式满足了该要求。不需要对 $9j$ 符号进行进一步简化。", "answer": "$$\n\\boxed{4\\sqrt{5} \\begin{Bmatrix} j & j & 0 \\\\ j & j & 2 \\\\ 0 & 2 & 0 \\end{Bmatrix}}\n$$", "id": "3602884"}, {"introduction": "在`J`方案中构建哈密顿量矩阵是一个复杂的过程，特别是在计算涉及Wigner `6j`或`9j`符号的重耦合矩阵元时，很容易引入数值误差，从而破坏体系的旋转不变性。本练习旨在开发一个至关重要的诊断工具，通过检验哈密顿量矩阵`H`是否与总角动量算符的平方`\\hat{J}^2`对易，来验证其是否真正保持了旋转对称性。这是一个在开发和使用任何大规模壳模型计算程序时都必不可少的质量控制步骤 ([@problem_id:3602898])。", "problem": "考虑一个旋转不变的核多体哈密顿量 $\\hat{H}$ 中的总角动量算符 $\\hat{J}$。在一个总角动量耦合基（即 $J$-方案表示）中，精确的旋转不变性意味着 $[\\hat{H},\\hat{J}^2]=\\hat{0}$。在一个由总角动量量子数 $\\{J_i\\}_{i=0}^{N-1}$（其中 $i$ 是基态的索引）标记的基中，$\\hat{J}^2$ 的矩阵是对角的，其对角元为 $J_i(J_i+1)$。假设给定一个实对称矩阵 $H \\in \\mathbb{R}^{N \\times N}$，它代表了由单体和双体矩阵元通过 Wigner $6j$ 符号重耦合后组合成的哈密顿量，以及每个基态的总角动量标签 $J_i$ 的列表。数值上的不一致（例如，源于不正确或不一致的 Wigner $6j$ 系数）会引入非物理的总角动量混合，这表现为一个非零的对易子 $[H,\\hat{J}^2]$。\n\n你的任务是实现一个诊断程序，该程序对每个提供的测试用例，从第一性原理出发执行以下操作：\n- 构建对角矩阵 $D \\in \\mathbb{R}^{N \\times N}$，其元素为 $D_{ii} = J_i(J_i+1)$。\n- 根据矩阵乘法的定义和对易子 $[A,B] = AB - BA$ 的定义，构建对易矩阵 $C = [H,D] = HD - DH$。\n- 计算弗罗贝尼乌斯范数 $\\|C\\|_F = \\sqrt{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} |C_{ij}|^2}$。\n- 判断哈密顿量是否表现出非物理的总角动量混合，这里定义为 $\\|C\\|_F > \\varepsilon_{\\text{norm}}$，其中 $\\varepsilon_{\\text{norm}}$ 是给定的阈值。\n- 通过将违背归因于特定的非对角元素对 $(i,j)$（其中 $i<j$) 来识别违规的源头。具体来说，返回一个列表，其中包含最多 $K$ 个对 $(i,j)$，这些对的 $|C_{ij}|$ 值超过元素级阈值 $\\varepsilon_{\\text{elem}}$，并按 $|C_{ij}|$ 的降序排列。", "solution": "该问题要求实现一个数值诊断程序，以验证给定核哈密顿矩阵 $H$ 的旋转不变性。此诊断的基础依赖于量子力学的一个基本原理：在具有旋转对称性的系统中，哈密顿算符 $\\hat{H}$ 必须与总角动量平方算符 $\\hat{J}^2$ 对易。在数学上，这表示为对易子为零：\n$$\n[\\hat{H}, \\hat{J}^2] = \\hat{H}\\hat{J}^2 - \\hat{J}^2\\hat{H} = \\hat{0}\n$$\n该问题在所谓的 $J$-方案表示中进行描述。这是一个由 $\\hat{J}^2$ 的本征态 $\\{|i\\rangle\\}_{i=0}^{N-1}$ 构成的基。每个基态 $|i\\rangle$ 都与一个总角动量量子数 $J_i$ 相关联。在此基中，算符 $\\hat{J}^2$ 由一个对角矩阵表示，我们将其记为 $D$。该矩阵的对角元素是 $\\hat{J}^2$ 的本征值，由著名公式给出：\n$$\nD_{ij} = \\langle i | \\hat{J}^2 | j \\rangle = \\delta_{ij} J_i(J_i+1)\n$$\n其中 $\\delta_{ij}$ 是克罗内克 δ 符号。给定的哈密顿矩阵 $H$ 的元素为 $H_{ij} = \\langle i | \\hat{H} | j \\rangle$。\n\n我们的任务是检查对易子的矩阵表示是否为零，即 $[H, D] = 0$ 是否成立。矩阵 $C = [H, D]$ 中偏离零的元素表明所提供的哈密顿矩阵 $H$ 未能完美地遵守旋转对称性，这种情况可能源于其构建过程中的数值误差，例如，在涉及 Wigner $6j$ 符号的复杂角动量重耦合计算中。\n\n算法流程如下：\n\n1.  **构建对易矩阵 $C$**：题目要求我们从第一性原理出发推导此过程。对易子定义为 $C = HD - DH$。矩阵乘积 $HD$ 的 $(i,j)$ 元素由下式给出：\n    $$\n    (HD)_{ij} = \\sum_{k=0}^{N-1} H_{ik} D_{kj}\n    $$\n    由于 $D$ 是对角矩阵，其元素为 $D_{kj} = \\delta_{kj} J_j(J_j+1)$，求和可以简化为：\n    $$\n    (HD)_{ij} = \\sum_{k=0}^{N-1} H_{ik} \\delta_{kj} J_j(J_j+1) = H_{ij} J_j(J_j+1)\n    $$\n    类似地，对于乘积 $DH$：\n    $$\n    (DH)_{ij} = \\sum_{k=0}^{N-1} D_{ik} H_{kj} = \\sum_{k=0}^{N-1} \\delta_{ik} J_i(J_i+1) H_{kj} = J_i(J_i+1) H_{ij}\n    $$\n    结合这些结果，对易矩阵的 $C_{ij}$ 元素为：\n    $$\n    C_{ij} = (HD)_{ij} - (DH)_{ij} = H_{ij} J_j(J_j+1) - J_i(J_i+1) H_{ij} = H_{ij} \\left( J_j(J_j+1) - J_i(J_i+1) \\right)\n    $$\n    这个公式是我们算法的核心。它表明，一个元素 $C_{ij}$ 非零的充要条件是对应的哈密顿元素 $H_{ij}$ 非零*且*耦合态的角动量不同 ($J_i \\neq J_j$)。在常数 $J$ 的子块内部的耦合（即 $J_i=J_j$ 的 $H_{ij}$）不会对对易子产生贡献，这在物理上是正确的。\n\n2.  **量化违背程度**：为了衡量对称性违背的总体“大小”，我们计算对易矩阵 $C$ 的弗罗贝尼乌斯范数。弗罗贝尼乌斯范数定义为其所有元素绝对值平方和的平方根：\n    $$\n    \\|C\\|_F = \\sqrt{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} |C_{ij}|^2}\n    $$\n    一个完全对称的哈密顿量将得到 $\\|C\\|_F = 0$。一个小的非零范数可能归因于浮点计算的不精确性，而一个大的范数则表明存在显著的、非物理的违背。该问题将违背定义为当 $\\|C\\|_F > \\varepsilon_{\\text{norm}}$ 时发生，其中 $\\varepsilon_{\\text{norm}}$ 是给定的容差阈值。\n\n3.  **识别并排序违背项**：为辅助调试哈密顿量，我们必须精确定位 $H$ 中导致违背的主要元素。从 $C_{ij}$ 的表达式可知，对于给定的态对 $(i,j)$（其中 $J_i \\neq J_j$），$|C_{ij}|$ 的大小与 $|H_{ij}|$ 成正比。因此，对范数的最大贡献来自于最大的 $|C_{ij}|$ 值，这反过来又指向了最有问题的 $H_{ij}$ 耦合项。\n    回溯过程包括：\n    - 遍历所有唯一的非对角索引对 $(i,j)$（其中 $i<j$），并计算 $|C_{ij}|$。\n    - 筛选出那些 $|C_{ij}| \\ge \\varepsilon_{\\text{elem}}$ 的对。\n    - 将这些“违规”对按 $|C_{ij}|$ 的降序排列。\n    - 返回排序后列表中的前 $K$ 个对。\n\n通过这个过程，我们可以得到一个量化的违背度量和一个按重要性排序的违规耦合列表，这为调试和验证 $J$-方案哈密顿矩阵的构建提供了直接的指导。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the processing of all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"N\": 5,\n            \"J\": [0, 0, 1, 1, 2],\n            \"H\": np.array([\n                [1.0, 0.05, 0, 0, 0],\n                [0.05, 1.2, 0, 0, 0],\n                [0, 0, 0.8, -0.03, 0],\n                [0, 0, -0.03, 1.1, 0],\n                [0, 0, 0, 0, 2.0]\n            ]),\n            \"eps_norm\": 1e-10,\n            \"eps_elem\": 1e-10,\n            \"K\": 3\n        },\n        # Test case 2\n        {\n            \"N\": 5,\n            \"J\": [0, 0, 1, 1, 2],\n            \"H\": np.array([\n                [1.0, 0.05, 0.001, 0, 0],\n                [0.05, 1.2, 0, 0, 0],\n                [0.001, 0, 0.8, -0.03, 0],\n                [0, 0, -0.03, 1.1, 0],\n                [0, 0, 0, 0, 2.0]\n            ]),\n            \"eps_norm\": 1e-5,\n            \"eps_elem\": 1e-4,\n            \"K\": 2\n        },\n        # Test case 3\n        {\n            \"N\": 4,\n            \"J\": [1, 1, 1, 2],\n            \"H\": np.array([\n                [0.9, 0.02, 0.01, 3e-8],\n                [0.02, 1.0, 0.015, -2e-8],\n                [0.01, 0.015, 1.1, 1e-8],\n                [3e-8, -2e-8, 1e-8, 1.5]\n            ]),\n            \"eps_norm\": 1e-6,\n            \"eps_elem\": 1e-7,\n            \"K\": 3\n        },\n        # Test case 4\n        {\n            \"N\": 6,\n            \"J\": [0, 1, 1, 2, 2, 3],\n            \"H\": np.array([\n                [1.0, 0, 0, 0.1, 0, 0],\n                [0, 1.2, 0.04, 0, 0, 0.02],\n                [0, 0.04, 1.15, 0, -0.03, 0],\n                [0.1, 0, 0, 2.0, 0.05, 0],\n                [0, 0, -0.03, 0.05, 2.1, 0],\n                [0, 0.02, 0, 0, 0, 2.5]\n            ]),\n            \"eps_norm\": 1e-3,\n            \"eps_elem\": 1e-2,\n            \"K\": 2\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        norm_F, is_mixing, offending_pairs = diagnose_hamiltonian(\n            case[\"N\"], case[\"J\"], case[\"H\"], case[\"eps_norm\"], case[\"eps_elem\"], case[\"K\"]\n        )\n        \n        # Format the result list into the exact string representation required.\n        # The float must be formatted to 6 decimal places.\n        # Python's default str() for lists and booleans is sufficient.\n        norm_F_str = f\"{norm_F:.6f}\"\n        result_str = f\"[{norm_F_str}, {is_mixing}, {offending_pairs}]\"\n        results_as_strings.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\ndef diagnose_hamiltonian(N, J_list, H, eps_norm, eps_elem, K):\n    \"\"\"\n    Performs the diagnostic check for a single Hamiltonian matrix.\n\n    Args:\n        N (int): Dimension of the matrix.\n        J_list (list): List of total angular momentum quantum numbers.\n        H (np.ndarray): The Hamiltonian matrix.\n        eps_norm (float): Threshold for the Frobenius norm.\n        eps_elem (float): Threshold for individual commutator elements.\n        K (int): Maximum number of offending pairs to return.\n\n    Returns:\n        tuple: A tuple containing:\n            - float: The Frobenius norm of the commutator, ||[H, D]||_F.\n            - bool: True if the norm exceeds eps_norm, False otherwise.\n            - list: A list of up to K offending (i,j) pairs.\n    \"\"\"\n    # 1. Construct the diagonal of the J^2 operator matrix D.\n    # D_ii = J_i * (J_i + 1)\n    d_diag = np.array([j * (j + 1) for j in J_list])\n\n    # 2. Form the commutator matrix C = [H, D] using the derived formula\n    # C_ij = H_ij * (D_jj - D_ii)\n    C = np.zeros_like(H)\n    for i in range(N):\n        for j in range(N):\n            C[i, j] = H[i, j] * (d_diag[j] - d_diag[i])\n\n    # 3. Compute the Frobenius norm of C\n    norm_F = np.linalg.norm(C, 'fro')\n\n    # 4. Decide whether unphysical mixing is present\n    is_mixing = norm_F > eps_norm\n\n    # 5. Backtrace the dominant contributions\n    offending_pairs_with_mag = []\n    for i in range(N):\n        # 遍历上三角部分 (i  j)\n        for j in range(i + 1, N): \n            if J_list[i] != J_list[j]:\n                abs_Cij = np.abs(C[i, j])\n                if abs_Cij = eps_elem:\n                    offending_pairs_with_mag.append((abs_Cij, (i, j)))\n    \n    # Sort pairs by descending magnitude of C_ij\n    offending_pairs_with_mag.sort(key=lambda x: x[0], reverse=True)\n\n    # Extract the index pairs and limit to K\n    final_pairs = [pair for mag, pair in offending_pairs_with_mag[:K]]\n\n    return norm_F, is_mixing, final_pairs\n\nsolve()\n```", "id": "3602898"}, {"introduction": "即使我们成功构建了一个有效的`J`方案哈密顿量，实际计算中也常常面临另一个挑战：来自非物理“赝态”（spurious states）的污染，例如那些描述原子核整体运动的质心运动态。本练习将演示一种标准技术——Lawson方法，即通过在哈密顿量中加入一个惩罚项来有效移除这些赝态。通过一个可计算的玩具模型，您将亲眼见证该方法如何将赝态能量推高，从而“净化”我们关心的低能物理谱 ([@problem_id:3602888])。", "problem": "考虑一个在 $J$-方案（基态由总角动量 $J$ 标记）中表述的旋转不变的原子核壳模型哈密顿量。在谐振子单粒子基中，质心（COM）自由度可以通过一个计算质心量子的数算符 $N_{\\text{COM}}$ 来表示。为了在不影响内禀（物理）谱的情况下抑制赝质心激发，添加一个 Lawson 项：$H_{\\text{Lawson}} = \\beta N_{\\text{COM}}$，其中 $\\beta$ 是一个无量纲的惩罚参数。在 $\\beta$ 很大时，赝质心激发的能量被推高，而物理态则不受影响。\n\n从第一性原理出发，使用以下基本事实：\n- 旋转不变性意味着哈密顿量可以块对角化为具有确定总角动量 $J$ 的扇区，因此 $H = \\bigoplus_J H^{(J)}$。\n- 质心数算符 $N_{\\text{COM}}$ 在一个将内禀分量与赝分量分开的基中是对角的，对于物理分量，$N_{\\text{COM}}=0$；对于赝分量，$N_{\\text{COM}}0$。\n- 添加 $H_{\\text{Lawson}}=\\beta N_{\\text{COM}}$ 会使每个态的能量移动 $\\beta$ 乘以该态中 $N_{\\text{COM}}$ 的期望值，同时保持 $J$ 不变。\n\n在本问题中，你将以 $\\hbar\\omega=1$（无量纲）的自然谐振子单位构建明确的玩具 $J$-方案哈密顿量 $H^{(J)}(\\beta)$，将其对角化，并量化当 $\\beta$ 变化时赝态如何移动，同时通过监测 $N_{\\text{COM}}$ 期望值来证明物理 $J$-耦合谱在大的 $\\beta$ 下不受影响。\n\n对于每个 $J\\in\\{0,2,4\\}$，定义一个由物理态和一个赝质心态组成的基。每个扇区中的哈密顿量为\n$$\nH^{(J)}(\\beta) \\;=\\; H_0^{(J)} \\;+\\; V_{\\text{mix}}^{(J)} \\;+\\; \\beta\\, N_{\\text{COM}}^{(J)}\\,,\n$$\n其中：\n- $H_0^{(J)}$ 是对角矩阵，其对角元等于物理态和赝态的未微扰能量。\n- $V_{\\text{mix}}^{(J)}$ 在相同的 $J$ 内（保持 $J$ 守恒）耦合赝和物理基态。\n- $N_{\\text{COM}}^{(J)}$ 是对角的，物理基态对应的对角元为 $0$，赝基态对应的对角元为 $1$。\n\n使用以下扇区定义（所有能量均以自然谐振子单位表示，无量纲）：\n- 扇区 $J=0$：\n  - 物理能量：$E_{\\text{phys}}^{(0)} = [1.20,\\,2.00]$。\n  - 赝能量：$E_{\\text{spur}}^{(0)} = [1.35]$。\n  - 与赝态的混合耦合：$\\epsilon^{(0)} = [0.08,\\,0.04]$，意味着赝基态与两个物理基态之间的非对角元分别为 $0.08$ 和 $0.04$。\n  - $N_{\\text{COM}}^{(0)}=\\mathrm{diag}(0,0,1)$。\n- 扇区 $J=2$：\n  - 物理能量：$E_{\\text{phys}}^{(2)} = [2.30,\\,3.10]$。\n  - 赝能量：$E_{\\text{spur}}^{(2)} = [2.00]$。\n  - 混合耦合：$\\epsilon^{(2)} = [0.05,\\,0.03]$。\n  - $N_{\\text{COM}}^{(2)}=\\mathrm{diag}(0,0,1)$。\n- 扇区 $J=4$：\n  - 物理能量：$E_{\\text{phys}}^{(4)} = [3.80]$。\n  - 赝能量：$E_{\\text{spur}}^{(4)} = [3.70]$。\n  - 混合耦合：$\\epsilon^{(4)} = [0.00]$。\n  - $N_{\\text{COM}}^{(4)}=\\mathrm{diag}(0,1)$。\n\n对于每个扇区，$H_0^{(J)}$ 是通过连接物理能量和单个赝能量形成的对角矩阵，物理能量在前。混合矩阵 $V_{\\text{mix}}^{(J)}$ 在赝基矢和每个物理基矢之间具有对称的非对角元，由 $\\epsilon^{(J)}$ 的相应条目设置，其他元素为零。算符 $N_{\\text{COM}}^{(J)}$ 是对角的，物理条目上为零，赝条目上为一。\n\n对于通过对角化 $H^{(J)}(\\beta)$ 得到的本征对 $\\{E_k^{(J)}(\\beta),\\,|\\psi_k^{(J)}(\\beta)\\rangle\\}$，定义质心期望值\n$$\nn_k^{(J)}(\\beta) = \\langle \\psi_k^{(J)}(\\beta) |\\, N_{\\text{COM}}^{(J)} \\,| \\psi_k^{(J)}(\\beta) \\rangle,\n$$\n这简化为在赝分量上的概率之和，因为 $N_{\\text{COM}}^{(J)}$ 在物理分量上为零，在赝分量上为一，且是对角的。\n\n对于测试套件中的每个 $\\beta$，执行以下计算：\n1. 对于每个扇区 $J\\in\\{0,2,4\\}$，构建 $H^{(J)}(\\beta)$，将其对角化以获得本征值 $E_k^{(J)}(\\beta)$ 和归一化本征矢 $|\\psi_k^{(J)}(\\beta)\\rangle$，并为所有 $k$ 计算 $n_k^{(J)}(\\beta)$。\n2. 将扇区 $J$ 中的赝本征态识别为使 $n_k^{(J)}(\\beta)$ 最大化的本征态。设其能量为 $E_{\\text{spur}}^{(J)}(\\beta)$。使用在 $\\beta=0$ 时的相应值 $E_{\\text{spur}}^{(J)}(0)$（通过对角化同一扇区在 $\\beta=0$ 时的哈密顿量一致地计算），定义赝能量移动\n$$\nS^{(J)}(\\beta) = E_{\\text{spur}}^{(J)}(\\beta) - E_{\\text{spur}}^{(J)}(0).\n$$\n3. 将扇区 $J$ 中的物理本征态识别为那些 $n_k^{(J)}(\\beta)  \\tau$ 的态，其中阈值为 $\\tau = 0.5$。将其能量升序排序，并与该扇区的基准物理能量 $E_{\\text{phys}}^{(J)}$ 进行比较。定义跨所有扇区和物理态的最大绝对漂移为\n$$\nD(\\beta) = \\max_{J}\\,\\max_{i} \\left| \\tilde{E}_{i}^{(J)}(\\beta) - E_{\\text{phys},i}^{(J)} \\right|,\n$$\n其中 $\\tilde{E}_{i}^{(J)}(\\beta)$ 是扇区 $J$ 中已识别的物理本征态的排序能量。\n4. 对于每个扇区 $J$，取能量最低的两个本征态（如果少于两个则取所有态），并计算它们的 $n_k^{(J)}(\\beta)$。定义\n$$\nM(\\beta) = \\max_{J}\\,\\max_{k\\in\\text{lowest two of sector }J} \\, n_k^{(J)}(\\beta)\\,.\n$$\n5. 定义一个布尔值\n$$\nU(\\beta) = \\begin{cases}\n\\text{True},  \\text{如果 } D(\\beta) \\leq 10^{-3} \\text{ 且 } M(\\beta) \\leq 10^{-3},\\\\\n\\text{False},  \\text{否则}.\n\\end{cases}\n$$\n这量化了在大的 $\\beta$ 极限下，物理 $J$-耦合谱不受影响，并且低洼本征态的质心污染可以忽略不计。\n6. 定义跨扇区的平均赝能量移动\n$$\n\\bar{S}(\\beta) = \\frac{1}{3} \\sum_{J\\in\\{0,2,4\\}} S^{(J)}(\\beta)\\,.\n$$\n\n测试套件：\n- 使用 $\\beta$ 值 $\\{0.0,\\,0.5,\\,5.0,\\,50.0\\}$。\n- 能量以自然谐振子单位表示，$\\hbar\\omega=1$（无量纲数）。\n- 不需要角度。\n\n程序输出规范：\n- 对于测试套件中的每个 $\\beta$，计算并输出一个包含五个量的条目\n$$\n\\left[ \\beta,\\; \\bar{S}(\\beta),\\; D(\\beta),\\; M(\\beta),\\; U(\\beta) \\right].\n$$\n- 你的程序应生成单行输出，其中包含结果，结果为这些条目的逗号分隔列表，每个条目都用方括号括起来。例如：\"[[beta1,meanShift1,maxDrift1,maxLowNcom1,unaffected1],[beta2,meanShift2,maxDrift2,maxLowNcom2,unaffected2],...]\"。", "solution": "该问题被验证为科学上合理、定义明确且客观。它提出了 Lawson 方法的一个简化但概念上正确的玩具模型，Lawson 方法是核壳模型计算中用于抑制赝质心运动的标准技术。所有参数、定义和计算步骤都已明确提供，从而可以得到唯一且可验证的解。该问题与计算核物理领域直接相关，并按规定使用了 $J$-方案表示。\n\n该问题要求我们分析向核壳模型哈密顿量中添加 Lawson 项 $H_{\\text{Lawson}} = \\beta N_{\\text{COM}}$ 的效果。目标是证明对于足够大的惩罚参数 $\\beta$，该项能有效地将对应于原子核质心（COM）运动的“赝”本征态与描述原子核内部结构的“物理”本征态分开。这种分离是通过显著提高赝态的能量而又不影响物理能谱来实现的。\n\n具有固定总角动量 $J$ 的扇区的总哈密顿量由下式给出\n$$\nH^{(J)}(\\beta) = H_0^{(J)} + V_{\\text{mix}}^{(J)} + \\beta N_{\\text{COM}}^{(J)}\n$$\n该哈密顿量是在一个包含物理态和单个赝质心激发态的基中构建的。给定扇区 $J$ 的基可以写为 $\\{|p_1^{(J)}\\rangle, \\dots, |p_{N_p}^{(J)}\\rangle, |s^{(J)}\\rangle\\}$，其中 $|p_i^{(J)}\\rangle$ 是 $N_p$ 个物理基态，而 $|s^{(J)}\\rangle$ 是赝基态。\n\n哈密顿量的分量定义如下：\n1.  $H_0^{(J)}$ 是未微扰能量的对角矩阵。基态的排序方式是物理态在前，赝态在后。\n    $$\n    H_0^{(J)} = \\mathrm{diag}\\left(E_{\\text{phys},1}^{(J)}, \\dots, E_{\\text{phys},N_p}^{(J)}, E_{\\text{spur}}^{(J)}\\right)\n    $$\n2.  $V_{\\text{mix}}^{(J)}$ 是一个对称的非对角矩阵，它引入了物理态和赝态之间的耦合。其唯一的非零元素位于最后一行和最后一列，以强度 $\\epsilon_i^{(J)}$ 将每个物理基态 $|p_i^{(J)}\\rangle$ 与赝基态 $|s^{(J)}\\rangle$ 耦合。\n3.  $N_{\\text{COM}}^{(J)}$ 是此基中的质心数算符。它是对角的，物理基态的本征值为 $0$，赝基态的本征值为 $1$。这是因为物理态对应于质心处于其基态（$N_{\\text{COM}}=0$），而赝态表示一个质心激发量子（$N_{\\text{COM}}=1$）。\n    $$\n    N_{\\text{COM}}^{(J)} = \\mathrm{diag}(0, \\dots, 0, 1)\n    $$\n\n对于每个扇区 $J \\in \\{0, 2, 4\\}$ 以及测试套件中的每个 $\\beta$ 值，执行以下计算过程：\n首先，我们根据为该扇区提供的能量和耦合，构建 $H^{(J)}(\\beta)$ 的数值矩阵。\n\n对于 $J=0$ 扇区，基的维度为 $3$（$2$ 个物理态， $1$ 个赝态）。哈密顿矩阵为：\n$$\nH^{(0)}(\\beta) = \\begin{pmatrix} 1.20  0  0.08 \\\\ 0  2.00  0.04 \\\\ 0.08  0.04  1.35 + \\beta \\end{pmatrix}\n$$\n对于 $J=2$ 扇区，基的维度为 $3$（$2$ 个物理态， $1$ 个赝态）：\n$$\nH^{(2)}(\\beta) = \\begin{pmatrix} 2.30  0  0.05 \\\\ 0  3.10  0.03 \\\\ 0.05  0.03  2.00 + \\beta \\end{pmatrix}\n$$\n对于 $J=4$ 扇区，基的维度为 $2$（$1$ 个物理态， $1$ 个赝态）：\n$$\nH^{(4)}(\\beta) = \\begin{pmatrix} 3.80  0.00 \\\\ 0.00  3.70 + \\beta \\end{pmatrix}\n$$\n请注意，对于 $J=4$，混合耦合为 $0$，这意味着物理空间和赝空间已经解耦。\n\n接下来，我们对每个矩阵求解不含时薛定谔方程，这是一个标准的本征值问题：\n$$\nH^{(J)}(\\beta) |\\psi_k^{(J)}(\\beta)\\rangle = E_k^{(J)}(\\beta) |\\psi_k^{(J)}(\\beta)\\rangle\n$$\n这是通过数值对角化完成的，得到本征值（能量）$E_k^{(J)}(\\beta)$ 和相应的本征矢 $|\\psi_k^{(J)}(\\beta)\\rangle$。由于哈密顿矩阵是实对称的，本征值将是实数，本征矢将构成一个标准正交基。\n\n每个本征态的特性（即其“赝”性程度）通过 $N_{\\text{COM}}$ 算符的期望值来量化：\n$$\nn_k^{(J)}(\\beta) = \\langle \\psi_k^{(J)}(\\beta) | N_{\\text{COM}}^{(J)} | \\psi_k^{(J)}(\\beta) \\rangle\n$$\n如果一个本征矢表示为 $|\\psi_k^{(J)}(\\beta)\\rangle = \\sum_i c_i |p_i^{(J)}\\rangle + c_s |s^{(J)}\\rangle$，那么 $n_k^{(J)}(\\beta) = |c_s|^2$。这个值范围从 $0$ 到 $1$，表示系统处于赝基态的概率。如果一个本征态的 $n_k^{(J)}(\\beta)$ 是最大的（并且大于阈值 $\\tau=0.5$），则它被识别为“赝”态，否则为“物理”态。\n\n然后，算法对每个 $\\beta$ 继续进行以下计算：\n1.  **赝能量移动 $S^{(J)}(\\beta)$**：我们首先通过对角化 $H^{(J)}(0)$ 来找到 $\\beta=0$ 时赝本征态的能量，记为 $E_{\\text{spur}}^{(J)}(0)$。然后，对于每个 $\\beta  0$，我们找到具有最大 $n_k^{(J)}(\\beta)$ 的态的能量，记为 $E_{\\text{spur}}^{(J)}(\\beta)$。能量移动为 $S^{(J)}(\\beta) = E_{\\text{spur}}^{(J)}(\\beta) - E_{\\text{spur}}^{(J)}(0)$。平均移动 $\\bar{S}(\\beta)$ 是 $S^{(J)}(\\beta)$ 在 $J \\in \\{0,2,4\\}$ 上的平均值。随着 $\\beta$ 的增加，我们期望 $S^{(J)}(\\beta) \\approx \\beta$。\n2.  **物理谱漂移 $D(\\beta)$**：我们识别出物理本征态（那些 $n_k^{(J)}(\\beta)  0.5$ 的态），对它们的能量 $\\tilde{E}_{i}^{(J)}(\\beta)$ 进行排序，并计算这些能量与基准未微扰物理能量 $E_{\\text{phys},i}^{(J)}$ 之间的最大绝对差。这衡量了物理谱因混合和 Lawson 过程而产生的扭曲程度。在大的 $\\beta$ 极限下，这个漂移应该趋近于零。\n3.  **低洼态质心污染 $M(\\beta)$**：我们计算每个扇区中能量最低的两个本征态中的最大 $n_k^{(J)}(\\beta)$ 值。这个量在大的 $\\beta$ 下也应该趋近于零，表明主要物理关注的低能谱没有赝质心污染。\n4.  **未受影响谱标志 $U(\\beta)$**：一个布尔标志，如果 $D(\\beta)$ 和 $M(\\beta)$ 都低于一个小的容差（$10^{-3}$），则设置为 True，确认 Lawson 方法对于给定的 $\\beta$ 是成功的。\n\n通过对一系列 $\\beta$ 值执行这些计算，我们可以定量地观察到物理自由度与赝自由度的逐步解耦，这是进行现实核结构计算的基石。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the nuclear shell-model problem with a Lawson term.\n    \n    This function constructs and diagonalizes Hamiltonians for different angular\n    momentum sectors (J=0, 2, 4) and for various values of the Lawson penalty\n    parameter beta. It then calculates several metrics to quantify the \n    separation of spurious center-of-mass states from the physical spectrum.\n    \"\"\"\n\n    # --- Problem Givens ---\n    sector_data = {\n        0: {'E_phys': [1.20, 2.00], 'E_spur': [1.35], 'epsilon': [0.08, 0.04]},\n        2: {'E_phys': [2.30, 3.10], 'E_spur': [2.00], 'epsilon': [0.05, 0.03]},\n        4: {'E_phys': [3.80], 'E_spur': [3.70], 'epsilon': [0.00]}\n    }\n    beta_values = [0.0, 0.5, 5.0, 50.0]\n    j_sectors = [0, 2, 4]\n    n_com_threshold = 0.5\n    unaffected_threshold = 1e-3\n\n    # --- Pre-calculate spurious energies at beta=0 for the shift calculation ---\n    e_spur_j_at_beta0 = {}\n    for j in j_sectors:\n        data = sector_data[j]\n        e_phys = data['E_phys']\n        e_spur = data['E_spur']\n        epsilon = data['epsilon']\n        beta = 0.0\n\n        num_phys = len(e_phys)\n        dim = num_phys + 1\n\n        h0 = np.diag(e_phys + e_spur)\n        v_mix = np.zeros((dim, dim))\n        if num_phys  0:\n            v_mix[-1, :num_phys] = epsilon\n            v_mix[:num_phys, -1] = epsilon\n        n_com_op = np.diag([0] * num_phys + [1])\n        \n        hamiltonian = h0 + v_mix + beta * n_com_op\n        \n        evals, evecs = np.linalg.eigh(hamiltonian)\n        \n        # n_k is the probability of the spurious component, i.e., |c_spur|^2\n        n_k = evecs[-1, :]**2\n        \n        spur_idx = np.argmax(n_k)\n        e_spur_j_at_beta0[j] = evals[spur_idx]\n\n    # --- Main Calculation Loop ---\n    all_results = []\n    for beta in beta_values:\n        total_s_j = 0.0\n        max_drift_d = 0.0\n        max_low_n_com_m = 0.0\n\n        for j in j_sectors:\n            data = sector_data[j]\n            e_phys = data['E_phys']\n            e_spur = data['E_spur']\n            epsilon = data['epsilon']\n\n            num_phys = len(e_phys)\n            dim = num_phys + 1\n\n            # 1. Construct Hamiltonian H(J)(beta)\n            h0 = np.diag(e_phys + e_spur)\n            v_mix = np.zeros((dim, dim))\n            if num_phys  0:\n                v_mix[-1, :num_phys] = epsilon\n                v_mix[:num_phys, -1] = epsilon\n            n_com_op = np.diag([0] * num_phys + [1])\n            \n            hamiltonian = h0 + v_mix + beta * n_com_op\n            \n            # Diagonalize to get eigenvalues and eigenvectors\n            evals, evecs = np.linalg.eigh(hamiltonian)\n            \n            # Compute COM expectation values n_k\n            n_k = evecs[-1, :]**2\n\n            # 2. Spurious energy shift S(J)(beta)\n            spur_idx = np.argmax(n_k)\n            e_spur_j_at_beta = evals[spur_idx]\n            s_j = e_spur_j_at_beta - e_spur_j_at_beta0[j]\n            total_s_j += s_j\n\n            # 3. Maximum absolute drift D(beta)\n            phys_indices = np.where(n_k  n_com_threshold)[0]\n            if len(phys_indices)  0:\n                phys_energies_beta = np.sort(evals[phys_indices])\n                baseline_phys_energies = np.sort(e_phys)\n                \n                # Check for matching dimensions before comparison\n                if len(phys_energies_beta) == len(baseline_phys_energies):\n                    drift_j = np.max(np.abs(phys_energies_beta - baseline_phys_energies))\n                    max_drift_d = max(max_drift_d, drift_j)\n\n            # 4. Max COM contamination of low-lying states M(beta)\n            # Eigenvalues from eigh are already sorted\n            num_lowest = min(2, dim)\n            n_com_lowest_two = n_k[:num_lowest]\n            max_low_n_com_m = max(max_low_n_com_m, np.max(n_com_lowest_two))\n\n        # 6. Average spurious energy shift\n        avg_s = total_s_j / len(j_sectors)\n\n        # 5. Unaffected spectrum boolean U(beta)\n        unaffected_u = (max_drift_d = unaffected_threshold) and (max_low_n_com_m = unaffected_threshold)\n        \n        # Store results for this beta\n        result_entry = [beta, avg_s, max_drift_d, max_low_n_com_m, unaffected_u]\n        all_results.append(result_entry)\n\n    # --- Final Output Formatting ---\n    # Manually format the string to avoid spaces and match the example format\n    output_parts = []\n    for res in all_results:\n        # res is [beta, avg_s, max_drift_d, max_low_n_com_m, unaffected_u]\n        formatted_entry = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]}]\"\n        output_parts.append(formatted_entry)\n        \n    final_output_string = f\"[{','.join(output_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "3602888"}]}