{"hands_on_practices": [{"introduction": "在计算核物理中，理论上的对称性守恒直接转化为强大的计算优势。轴对称尼尔森哈密顿量保持总角动量投影 $\\Omega$ 和宇称 $\\pi$ 守恒，这意味着在由这些量子数标记的基底下，哈密顿量矩阵会呈现块对角结构。本练习 [@problem_id:3604804] 将通过量化分析，展示利用这种块对角化策略相比于对角化整个巨大矩阵，能够在计算速度和内存使用上带来多大的提升，这是任何实际尼尔森模型计算的基石。", "problem": "考虑用于轴对称形变核的单粒子尼尔森（Nilsson）哈密顿量，其中形变保持一个对称轴。该哈密顿量由一个形变的各向异性谐振子加上自旋轨道项和轨道项构成。在轴对称情况下，哈密顿量 $\\hat{H}$ 与总角动量在对称轴上的投影 $\\hat{J}_z$ 以及宇称算符 $\\hat{\\Pi}$ 对易，即 $[\\hat{H},\\hat{J}_z]=0$ 和 $[\\hat{H},\\hat{\\Pi}]=0$。因此，量子数 $\\Omega$（$\\hat{J}_z$ 的本征值，以 $\\hbar$ 为单位）和 $\\pi$（$\\hat{\\Pi}$ 的本征值，等于 $+1$ 或 $-1$）是守恒的。这使得在以 $(\\Omega,\\pi)$ 标记的状态基中表示的哈密顿量矩阵可以被重组为独立的块，每个块对应一个 $(\\Omega,\\pi)$ 分区。瑞利-里兹（Rayleigh-Ritz）变分原理确保，只要基矢遵守守恒量子数，对每个块进行对角化所得到的本征值与对角化完整哈密顿量所得到的本征值相同。\n\n你的任务是形式化一个利用 $(\\Omega,\\pi)$ 守恒的块对角化策略，并估算计算量随基矢大小和形变数量的标度关系。使用以下基本原理：\n- 厄米性和对称性：如果对于某个算符 $\\hat{A}$ 有 $[\\hat{H},\\hat{A}]=0$，则 $\\hat{H}$ 和 $\\hat{A}$ 共享一个共同的本征基，这意味着按 $\\hat{A}$ 的本征值组织的 $\\hat{H}$ 的表示具有块结构。\n- 稠密厄米本征值问题的复杂度：对于一个稠密的 $n \\times n$ 厄米矩阵，广泛使用的算法进行完全对角化的计算复杂度与 $n^3$ 次浮点运算成正比，存储矩阵的内存使用量与 $n^2$ 成正比。\n\n为 $D$ 个不同形变（例如，由不同值的参数 $\\beta$ 表征的不同四极形变）的计算定义以下量：\n- 设总基矢维度为 $N$，通过对所有块的大小 $n_k$ 求和得到，其中每个块由一对 $(\\Omega,\\pi)$ 标识，并包含所有具有这些守恒量子数的基态。\n- 对角化一个稠密厄米矩阵的成本与每个形变的 $N^3$ 成正比，因此不利用对称性的总参考成本与 $D N^3$ 成正比。\n- 使用块对角化，每个形变的成本与 $\\sum_{k} n_k^3$ 成正比，而在 $D$ 个形变上的总成本与 $D \\sum_k n_k^3$ 成正比。\n- 存储完整矩阵所需的内存与 $N^2$ 成正比，而块表示的内存与 $\\sum_k n_k^2$ 成正比。\n\n实现一个程序，对下面的每个测试用例计算：\n1. 加速因子 $S$，定义为 $S = \\dfrac{D N^3}{D \\sum_k n_k^3} = \\dfrac{N^3}{\\sum_k n_k^3}$。\n2. 内存减少因子 $M$，定义为 $M = \\dfrac{N^2}{\\sum_k n_k^2}$。\n\n你的程序应假设比例常数为单位1，即为了计算 $S$ 和 $M$，将成本和内存标度视为精确值。你的程序的输入通过下面给出的测试套件隐式提供。对于每个测试用例，你会得到一个块大小列表 $\\{n_k\\}$（每个都是正整数）和形变数量 $D$（一个正整数）。程序必须为每个测试用例计算 $S$ 和 $M$ 作为实数，并报告四舍五-入到六位小数的结果。\n\n测试套件：\n- 用例1（跨多个 $(\\Omega,\\pi)$ 分区的平衡块）：$\\{n_k\\} = [\\,12,12,13,13,12,12,13,13\\,]$，$D=5$。此处，$N=100$。\n- 用例2（未利用对称性，单个块）：$\\{n_k\\} = [\\,100\\,]$，$D=5$。此处，$N=100$。\n- 用例3（$(\\Omega,\\pi)$ 分区分布极不均匀）：$\\{n_k\\} = [\\,64,16,16,8,8,8,4,4\\,]$，$D=10$。此处，$N=128$。\n- 用例4（许多小块）：$\\{n_k\\} = [\\,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4\\,]$，$D=3$。此处，$N=96$。\n- 用例5（仅按宇称划分块）：$\\{n_k\\} = [\\,60,60\\,]$，$D=4$。此处，$N=120$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，列表内容是按顺序排列的每个用例的 $(S,M)$ 对。\n- 具体来说，输出应为 $[S_1,M_1,S_2,M_2,S_3,M_3,S_4,M_4,S_5,M_5]$，其中每个 $S_i$ 和 $M_i$ 都四舍五入到六位小数。\n- 不应打印任何额外文本。", "solution": "该问题要求分析在轴对称形变核的单粒子尼尔森（Nilsson）哈密顿量中利用对称性所获得的计算优势。核心原理是，如果一个哈密顿算符 $\\hat{H}$ 与另一个算符 $\\hat{A}$ 对易，即 $[\\hat{H}, \\hat{A}] = 0$，那么它们共享一组共同的本征态。这使得哈密顿量矩阵可以被组织成块对角形式，其中每个块对应于 $\\hat{A}$ 的一个特定本征值。\n\n在轴对称尼尔森（Nilsson）模型的背景下，哈密顿量 $\\hat{H}$ 与总角动量在对称轴上的投影算符 $\\hat{J}_z$ 以及宇称算符 $\\hat{\\Pi}$ 都对易。这些算符的本征值，分别为 $\\Omega$ 和 $\\pi$，是守恒量子数。因此，任何基态都可以用一对 $(\\Omega, \\pi)$ 来标记，并且哈密顿量矩阵在连接具有不同 $(\\Omega, \\pi)$ 对的状态之间不会有任何非零元素。\n\n设基矢空间的总维度为 $N$。如果我们忽略对称性，我们将构建一个大小为 $N \\times N$ 的单个大哈密顿量矩阵。对角化一个大小为 $n \\times n$ 的稠密厄米矩阵的计算成本与其维度的立方成正比，即与 $n^3$ 成正比。因此，对于 $D$ 个不同的核形变，寻找完整的 $N \\times N$ 矩阵的本征值和本征向量的总计算成本将与 $D N^3$ 成正比。存储该矩阵所需的内存与其元素数量 $N^2$ 成正比。\n\n通过利用 $(\\Omega, \\pi)$ 对称性，基矢可以被划分为更小的集合，每个集合包含具有相同 $(\\Omega, \\pi)$ 值的状态。假设有 $k$ 个这样的块，第 $k$ 个块的大小（即具有特定 $(\\Omega, \\pi)$ 组合的基态数量）为 $n_k$。总基矢大小是各块大小之和：$N = \\sum_k n_k$。完整的哈密顿量矩阵变成块对角形式，块的维度为 $n_k \\times n_k$。\n\n对角化一个块对角矩阵等同于独立地对角化每个块。一个形变的总计算成本是每个块成本的总和：$\\sum_k n_k^3$。对于 $D$ 个形变，总成本与 $D \\sum_k n_k^3$ 成正比。同样，所需的内存是每个块内存的总和，与 $\\sum_k n_k^2$ 成正比。\n\n为了量化计算增益，我们定义加速因子 $S$ 和内存减少因子 $M$。按照指示假设比例常数为单位1，这些因子是无对称性成本与有对称性成本的比率。\n\n加速因子 $S$ 定义为：\n$$\nS = \\frac{\\text{无对称性成本}}{\\text{有对称性成本}} = \\frac{D N^3}{D \\sum_k n_k^3} = \\frac{N^3}{\\sum_k n_k^3}\n$$\n形变数量 $D$ 被约去，表明相对加速与计算的形变点数量无关。\n\n内存减少因子 $M$ 定义为：\n$$\nM = \\frac{\\text{无对称性内存}}{\\text{有对称性内存}} = \\frac{N^2}{\\sum_k n_k^2}\n$$\n\n解决该问题的算法如下：对于每个测试用例，给定一个块大小列表 $\\{n_k\\}$：\n1.  通过对块大小求和来计算总基矢维度 $N$：$N = \\sum_k n_k$。\n2.  计算块大小的立方和：$\\sum_k n_k^3$。\n3.  计算块大小的平方和：$\\sum_k n_k^2$。\n4.  使用公式 $S = N^3 / (\\sum_k n_k^3)$ 计算加速因子 $S$。\n5.  使用公式 $M = N^2 / (\\sum_k n_k^2)$ 计算内存减少因子 $M$。\n6.  按要求报告每个用例的结果，四舍五入到六位小数。\n此过程将应用于所提供的五个测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes speedup and memory reduction factors for block-diagonalization\n    of a Hamiltonian matrix based on symmetry principles.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each inner list represents the sizes {n_k} of the Hamiltonian matrix blocks.\n    test_cases = [\n        # Case 1: balanced blocks across multiple (Omega,pi) sectors\n        [12, 12, 13, 13, 12, 12, 13, 13],\n        # Case 2: no symmetry exploited, single block\n        [100],\n        # Case 3: highly uneven distribution of (Omega,pi) sectors\n        [64, 16, 16, 8, 8, 8, 4, 4],\n        # Case 4: many small blocks\n        [2]*16 + [4]*16,\n        # Case 5: parity-only block split\n        [60, 60]\n    ]\n\n    results = []\n    for block_sizes in test_cases:\n        # Use numpy arrays for efficient computation.\n        # Use a floating-point dtype to prevent potential integer overflow with large N.\n        n_k = np.array(block_sizes, dtype=np.float64)\n\n        # Calculate the total basis size N.\n        N = np.sum(n_k)\n\n        # Calculate the sum of squares and cubes of block sizes.\n        sum_n_k_squared = np.sum(np.power(n_k, 2))\n        sum_n_k_cubed = np.sum(np.power(n_k, 3))\n\n        # Calculate N^2 and N^3.\n        N_squared = np.power(N, 2)\n        N_cubed = np.power(N, 3)\n\n        # Compute the speedup factor S.\n        # This is the ratio of computational cost without symmetry (N^3)\n        # to the cost with symmetry (sum of n_k^3).\n        # Check for division by zero, although not expected for this problem's constraints.\n        if sum_n_k_cubed == 0:\n            S = 1.0 if N_cubed == 0 else np.inf\n        else:\n            S = N_cubed / sum_n_k_cubed\n\n        # Compute the memory reduction factor M.\n        # This is the ratio of memory usage without symmetry (N^2)\n        # to the usage with symmetry (sum of n_k^2).\n        if sum_n_k_squared == 0:\n            M = 1.0 if N_squared == 0 else np.inf\n        else:\n            M = N_squared / sum_n_k_squared\n\n        # Append the formatted results to the list.\n        results.append(f\"{S:.6f}\")\n        results.append(f\"{M:.6f}\")\n\n    # Final print statement in the exact required format.\n    # The output is a single line containing a comma-separated list of\n    # S and M values for all test cases, enclosed in square brackets.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "3604804"}, {"introduction": "尼尔森图是原子核结构理论中的核心工具，它描绘了单粒子能级如何随形变演化。一个关键的挑战是处理“避免交叉”现象：具有相同量子数的能级在交叉点附近会相互推斥，导致基于能量排序的朴素标记方法失效。本练习 [@problem_id:3604776] 旨在建立并实现一个更稳健的算法，该算法结合了态的交叠和可观测量期望值的平滑演化，以在避免交叉区域正确地追踪能级，从而确保物理属性随形变的演化是连续和可信的。", "problem": "您将获得一个与参数相关的厄米矩阵族，旨在以一种简化的、计算上易于处理的方式，模拟形变原子核的 Nilsson 模型中单粒子态随轴向四极形变参数演化的过程。目标是建立并实现一个算法判据，该判据同时使用态与态之间的交叠和一个选定算符的期望值，在穿越“避免交叉”时一致地重新标记量子态，从而使渐近标签随形变平滑演化。该算法必须是通用的、数学上良定的，并且必须最小化“避免交叉”附近的伪标签交换。\n\n从以下基本基础开始：\n- 一个与参数相关的厄米哈密顿量 $H(\\lambda)$，在每个固定的参数值 $\\lambda$ 处，都有一套完备正交的本征态 $\\{ \\lvert \\psi_j(\\lambda) \\rangle \\}_{j=1}^{n}$ 及其对应的本征值 $\\{ E_j(\\lambda) \\}_{j=1}^{n}$，这可以通过求解矩阵本征值问题 $H(\\lambda) \\mathbf{v}_j(\\lambda) = E_j(\\lambda) \\mathbf{v}_j(\\lambda)$ 获得。\n- 两个归一化态 $\\lvert \\phi \\rangle$ 和 $\\lvert \\chi \\rangle$ 之间的内积（交叠）为 $\\langle \\phi \\mid \\chi \\rangle$，两个态之间的保真度交叠为 $\\left\\lvert \\langle \\phi \\mid \\chi \\rangle \\right\\rvert^2 \\in [0,1]$。\n- 厄米算符 $\\hat{O}$ 在态 $\\lvert \\psi \\rangle$ 中的期望值为 $\\langle \\psi \\rvert \\hat{O} \\lvert \\psi \\rangle$。\n- 当 $\\lambda$ 发生微小变化时，若演化是平滑的，且具有相同量子数的能级不发生精确交叉，则由态 $\\lvert \\psi_j(\\lambda) \\rangle$ 张成的子空间在变化的尺度上应是 $\\lambda$ 的连续函数，并且慢变或渐近守恒算符的期望值也应平滑变化。\n\n在下文的计算设置中，非绝热渐近基矢表示 Nilsson 模型的渐近态 $\\lvert \\chi_i \\rangle$ （例如，渐近的类 $\\lvert N n_z \\Lambda \\Sigma \\rangle$ 基矢态），一个选定的对角算符 $\\hat{O}$ 通过其本征值编码一个渐近标签（例如，近似的 $\\langle n_z \\rangle$ 或 $\\langle \\Lambda \\rangle$）。\n\n您的任务：\n- 对于一个具有小增量的离散网格 $\\{ \\lambda_k \\}_{k=0}^{K-1}$，推导、论证并实现一个判据，该判据通过结合保真度交叠 $\\left\\lvert \\langle \\psi_i(\\lambda_{k-1}) \\mid \\psi_j(\\lambda_k) \\rangle \\right\\rvert^2$ 和期望值 $\\langle \\psi(\\lambda) \\rvert \\hat{O} \\lvert \\psi(\\lambda) \\rangle$ 的平滑变化，在 $\\lambda_{k-1}$ 处的本征态与 $\\lambda_{k}$ 处的本征态之间建立一一对应的分配。得到的分配应重新标记量子态，以便标签在穿越“避免交叉”时平滑演化。问题明确要求使用交叠和期望值两者来定义一个用于分配的、需要被最小化的成本函数，并以一种可普遍实现的方式来表达。\n- 在给定的哈密顿量族测试套件上，同时实现以下两种方案：\n  1. 一种朴素的标记方案，该方案在每个 $\\lambda_k$ 处独立地按能量递增顺序对本征态进行排序。\n  2. 您的算法判据，该判据在每一步使用交叠和期望值来建立并求解一个最小成本分配问题，以将标签从 $\\lambda_{k-1}$ 延续到 $\\lambda_k$。\n- 对于每种方案，计算一个由下式定义的定量平滑度度量：\n  $$ D \\equiv \\sum_{k=1}^{K-1} \\sum_{i=1}^{n} \\left( \\langle \\psi_i(\\lambda_k) \\rvert \\hat{O} \\lvert \\psi_i(\\lambda_k) \\rangle - \\langle \\psi_i(\\lambda_{k-1}) \\rvert \\hat{O} \\lvert \\psi_i(\\lambda_{k-1}) \\rangle \\right)^2, $$\n  其中，对于算法方案，指数 $i$ 追踪由您的分配判据传播的标签；对于朴素方案，$i$ 是在每个 $\\lambda_k$ 处固定的按能量排序的指数。较小的 $D$ 值表示渐近标签的演化更平滑。\n\n哈密顿量族和算符定义：\n- 所有矩阵都在一个固定的非绝热基 $\\{ \\lvert \\chi_i \\rangle \\}_{i=1}^{n}$ 上定义，并具有形式 $H(\\lambda) = D(\\lambda) + V(\\lambda)$，其中 $D(\\lambda)$ 是对角矩阵，其元素为 $e_i(\\lambda)$，$V(\\lambda)$ 是实对称矩阵，其选定的非对角耦合项 $v_{ij}(\\lambda)$ 被建模为局域的高斯耦合以引发避免交叉。算符 $\\hat{O}$ 在非绝热基中是对角的，其本征值为 $o_i$。\n\n提供以下三个测试用例：\n- 测试用例 #1 (两能级避免交叉):\n  - 维度 $n = 2$。\n  - 非绝热能量 $e_1(\\lambda) = -a\\,\\lambda$, $e_2(\\lambda) = +a\\,\\lambda$，其中 $a = 1.0$。\n  - 耦合 $v_{12}(\\lambda) = v_0 \\exp\\!\\left( - (\\lambda - \\lambda_0)^2 / (2 \\sigma^2) \\right)$，其中 $v_0 = 0.15$, $\\lambda_0 = 0.0$, $\\sigma = 0.2$；并且 $v_{21}(\\lambda) = v_{12}(\\lambda)$。\n  - 所有其他 $v_{ij}(\\lambda) = 0$。\n  - 算符 $\\hat{O}$ 具有 $o_1 = 0.0$, $o_2 = 1.0$。\n  - 网格 $\\lambda \\in [-2.0, 2.0]$，以步长 $\\Delta \\lambda = 0.05$ 均匀采样。\n- 测试用例 #2 (三能级，两个分离的避免交叉):\n  - 维度 $n = 3$。\n  - 非绝热能量 $e_1(\\lambda) = -1.0 + 0.5\\,\\lambda$, $e_2(\\lambda) = 0.0$, $e_3(\\lambda) = +1.0 - 0.5\\,\\lambda$。\n  - 耦合项:\n    - $v_{12}(\\lambda) = v_{0,12} \\exp\\!\\left( - (\\lambda - \\lambda_{12})^2 / (2 \\sigma_{12}^2) \\right)$，其中 $v_{0,12} = 0.12$, $\\lambda_{12} = -0.5$, $\\sigma_{12} = 0.15$。\n    - $v_{23}(\\lambda) = v_{0,23} \\exp\\!\\left( - (\\lambda - \\lambda_{23})^2 / (2 \\sigma_{23}^2) \\right)$，其中 $v_{0,23} = 0.12$, $\\lambda_{23} = +0.5$, $\\sigma_{23} = 0.15$。\n    - $v_{13}(\\lambda) = v_{31}(\\lambda) = 0.0$。\n    - 对称性 $v_{ij}(\\lambda) = v_{ji}(\\lambda)$ 成立。\n  - 算符 $\\hat{O}$ 具有 $o_1 = 0.0$, $o_2 = 1.0$, $o_3 = 2.0$。\n  - 网格 $\\lambda \\in [-1.5, 1.5]$，以步长 $\\Delta \\lambda = 0.05$ 均匀采样。\n- 测试用例 #3 (三能级精确交叉):\n  - 维度 $n = 3$。\n  - 非绝热能量 $e_1(\\lambda) = -0.3\\,\\lambda$, $e_2(\\lambda) = +0.3\\,\\lambda$, $e_3(\\lambda) = 1.2$。\n  - 对于所有 $i \\neq j$，所有耦合 $v_{ij}(\\lambda) = 0.0$。\n  - 算符 $\\hat{O}$ 具有 $o_1 = 0.0$, $o_2 = 1.0$, $o_3 = 2.0$。\n  - 网格 $\\lambda \\in [-1.0, 1.0]$，以步长 $\\Delta \\lambda = 0.05$ 均匀采样。\n\n实现与输出要求：\n- 在每个网格点上实现 $H(\\lambda)$ 的对角化，以获得所有 $k$ 的本征对 $\\{ E_j(\\lambda_k), \\lvert \\psi_j(\\lambda_k) \\rangle \\}$。\n- 实现朴素的按能量排序的标记方案，并按规定计算 $D_{\\text{naive}}$。\n- 使用交叠和期望值推导您的算法判据，实现该判据以生成 $\\lambda_{k-1}$ 和 $\\lambda_k$ 之间态的逐步分配，该分配最小化一个合适的总成本，并按规定计算 $D_{\\text{algo}}$。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其嵌套列表结构如下：\n  - 对于测试用例 #1, #2, #3，按顺序输出序对 $\\left[D_{\\text{naive}}, D_{\\text{algo}}\\right]$。\n  - 将它们聚合为 $\\left[ [D_{\\text{naive}}^{(1)}, D_{\\text{algo}}^{(1)}], [D_{\\text{naive}}^{(2)}, D_{\\text{algo}}^{(2)}], [D_{\\text{naive}}^{(3)}, D_{\\text{algo}}^{(3)}] \\right]$。\n- 所有量都是无量纲的；不需要物理单位。不使用角度。为保证可复现性，最终打印的数字应四舍五入到 $10^{-6}$ 的精度。", "solution": "问题陈述已经过仔细验证，并被确定为有效。它在科学上植根于量子力学原理，特别是关于参数相关系统中“避免交叉”的研究，这是分子物理学和原子核物理学的基石之一。这个问题是良定的，所有参数、模型和目标都得到了清晰明确的定义。它提出了计算物理学中一个标准的、非平凡的挑战：开发并实现一个鲁棒的状态追踪算法。\n\n问题的核心是设计一种方法，在系统参数 $\\lambda$ 变化时，能够一致地标记量子态。在“避免交叉”附近，哈密顿量 $H(\\lambda)$ 的本征态特性会发生急剧变化。一种朴素的标记方案，即在每个 $\\lambda$ 值处按能量 $E_j(\\lambda)$ 对态进行排序，将导致标签在不同态之间交换。这会导致与给定标签相关的物理可观测量发生不连续的演化，从而掩盖了态潜在的平滑（或称“非绝热”）本性。\n\n任务是实现并比较两种标记方案。第一种是朴素的能量排序方案。第二种是一种复杂的算法方案，它通过最小化一个同时考虑了态矢量的几何交叠和所选可观测量期望值平滑演化的成本函数来追踪态的身份。每种方案的性能都通过一个平滑度度量 $D$ 来量化。\n\n首先，我们将计算设置形式化。哈密顿量 $H(\\lambda)$ 和算符 $\\hat{O}$ 在一个固定的、不含时的“非绝热”基 $\\{ \\lvert \\chi_i \\rangle \\}_{i=1}^n$ 中表示为 $n \\times n$ 矩阵。在网格上的每个离散点 $\\lambda_k$ 处，我们求解定态薛定谔方程，它表现为矩阵本征值问题：\n$$ H(\\lambda_k) \\lvert \\psi_j(\\lambda_k) \\rangle = E_j(\\lambda_k) \\lvert \\psi_j(\\lambda_k) \\rangle $$\n这在计算上通过对角化 $H(\\lambda_k)$ 的矩阵表示来求解。求解过程得到一组 $n$ 个本征值 $\\{E_j(\\lambda_k)\\}$ 和相应的一组正交归一的本征矢量 $\\{\\lvert \\psi_j(\\lambda_k) \\rangle\\}$。算符 $\\hat{O}$ 在非绝热基中是对角的，其本征值为 $\\{o_i\\}$。一个本征矢量 $\\lvert \\psi_j \\rangle$ 是非绝热基矢的线性组合，$\\lvert \\psi_j \\rangle = \\sum_i c_{ji} \\lvert \\chi_i \\rangle$。它对于算符 $\\hat{O}$ 的期望值为 $\\langle \\psi_j \\rvert \\hat{O} \\lvert \\psi_j \\rangle = \\sum_i \\lvert c_{ji} \\rvert^2 o_i$。\n\n朴素标记方案是直接了当的。在每个 $\\lambda_k$ 处，本征态根据其能量本征值 $E_j(\\lambda_k)$ 的升序进行索引 $j=1, \\dots, n$。然后，平滑度度量 $D_{\\text{naive}}$ 计算如下：\n$$ D_{\\text{naive}} = \\sum_{k=1}^{K-1} \\sum_{i=1}^{n} \\left( \\langle \\psi_i^{\\text{naive}}(\\lambda_k) \\rvert \\hat{O} \\lvert \\psi_i^{\\text{naive}}(\\lambda_k) \\rangle - \\langle \\psi_i^{\\text{naive}}(\\lambda_{k-1}) \\rvert \\hat{O} \\lvert \\psi_i^{\\text{naive}}(\\lambda_{k-1}) \\rangle \\right)^2 $$\n其中 $\\lvert \\psi_i^{\\text{naive}}(\\lambda_k) \\rangle$ 是在 $\\lambda_k$ 处能量排序列表中的第 $i$ 个态。对于有避免交叉的系统，这个度量值预计会很大，因为第 $i$ 个能量本征态的特性会发生突变。\n\n为了开发更鲁棒的算法方案，我们建立一个判据，用于将 $\\lambda_{k-1}$ 步的已标记态连接到 $\\lambda_k$ 步新计算出的、初始未标记的本征态上。基本原则是，对于一个足够小的步长 $\\Delta \\lambda = \\lambda_k - \\lambda_{k-1}$，一个物理态应该演化到在希尔伯特空间中与其“接近”且性质变化最小的另一个态上。这启发我们采用成本最小化的方法。设 $\\{\\lvert \\psi_i^{\\text{old}} \\rangle\\}_{i=1}^n$ 为来自 $\\lambda_{k-1}$ 步的已标记态集合，设 $\\{\\lvert \\phi_j^{\\text{new}} \\rangle\\}_{j=1}^n$ 为在 $\\lambda_k$ 处新的、按能量排序的本征态集合。我们寻求一个一一对应的分配（一个置换）$i \\to j=\\pi(i)$，使得总成本最小。\n\n将旧标签 $i$ 分配给新态 $j$ 的成本 $C_{ij}$ 必须被公式化。问题要求结合两个独立的判据：\n1.  保真度交叠：两个态之间的相似性通过保真度 $F_{ij} = \\left\\lvert \\langle \\psi_i^{\\text{old}} \\mid \\phi_j^{\\text{new}} \\rangle \\right\\rvert^2$ 来衡量。成本可以定义为 $1 - F_{ij}$，当两个态几乎相同时该成本很小，而当它们几乎正交时该成本很大。\n2.  期望值平滑性：代表一个近似量子数的算符 $\\hat{O}$ 的期望值应该平滑演化。平方差 $(\\langle \\phi_j^{\\text{new}} \\rvert \\hat{O} \\lvert \\phi_j^{\\text{new}} \\rangle - \\langle \\psi_i^{\\text{old}} \\rvert \\hat{O} \\lvert \\psi_i^{\\text{old}} \\rangle)^2$ 会惩罚那些导致该量发生巨大跳跃的分配。\n\n为了将这些项组合成一个单一、平衡且无量纲的成本，我们使用加权和。期望值项通过期望值的最大可能范围 $\\Delta O_{\\text{max}} = \\max(o_l) - \\min(o_l)$ 进行归一化，以确保其量级与保真度项相当。最终得到的成本矩阵元 $C_{ij}$ 为：\n$$ C_{ij} = w \\left(1 - \\left\\lvert \\langle \\psi_i^{\\text{old}} \\mid \\phi_j^{\\text{new}} \\rangle \\right\\rvert^2\\right) + (1-w) \\left( \\frac{\\langle \\phi_j^{\\text{new}} \\rvert \\hat{O} \\lvert \\phi_j^{\\text{new}} \\rangle - \\langle \\psi_i^{\\text{old}} \\rvert \\hat{O} \\lvert \\psi_i^{\\text{old}} \\rangle}{\\Delta O_{\\text{max}}} \\right)^2 $$\n权重因子 $w=0.5$ 是一个平衡的选择，给予两个判据同等的重要性。寻找最优标签分配的问题，就变成了寻找能最小化总成本 $\\sum_{i=1}^n C_{i, \\pi(i)}$ 的置换 $\\pi$ 的问题。这是著名的线性总和分配问题，可以使用标准算法（如匈牙利算法）高效求解。\n\n算法流程如下：\n1. 在 $\\lambda_0$ 处，对角化 $H(\\lambda_0)$ 并根据能量顺序为本征态分配初始标签。记此集合为 $\\{\\lvert \\psi_i(\\lambda_0) \\rangle\\}$。\n2. 对于每个后续步骤 $k = 1, \\dots, K-1$：\n    a. 设 $\\{\\lvert \\psi_i(\\lambda_{k-1}) \\rangle\\}$ 为前一步的已标记态。\n    b. 对角化 $H(\\lambda_k)$ 以获得一组新的、按能量排序的本征态 $\\{\\lvert \\phi_j(\\lambda_k) \\rangle\\}$。\n    c. 根据上面定义的元素 $C_{ij}$ 构建 $n \\times n$ 的成本矩阵 $C$。\n    d. 对 $C$ 求解线性总和分配问题，找到将旧标签 $i$ 映射到新索引 $j$ 的最优置换 $\\pi$。\n    e. 新标记的态为 $\\{\\lvert \\psi_i(\\lambda_k) \\rangle = \\lvert \\phi_{\\pi(i)}(\\lambda_k) \\rangle\\}$。存储它们的属性。\n3. 所有步骤完成后，使用追踪的期望值计算平滑度度量 $D_{\\text{algo}}$。\n\n该算法方案旨在遵循态的非绝热特性，防止在“避免交叉”处发生标签交换，因此与朴素方案相比，会产生一个更小的平滑度度量 $D$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef gaussian(x, mu, sigma, amplitude):\n    return amplitude * np.exp(-((x - mu)**2) / (2 * sigma**2))\n\ndef run_test_case(n, e_funcs, v_funcs, o_diag, lambda_range, d_lambda):\n    \"\"\"\n    Runs a single test case for state tracking.\n\n    Args:\n        n (int): Dimension of the Hilbert space.\n        e_funcs (list): List of lambda functions for diagonal energies e_i(lambda).\n        v_funcs (dict): Dictionary of lambda functions for off-diagonal couplings v_ij(lambda).\n        o_diag (list): List of diagonal elements of the operator O.\n        lambda_range (tuple): Start and end of the lambda grid.\n        d_lambda (float): Step size for the lambda grid.\n\n    Returns:\n        tuple: A pair of floats (D_naive, D_algo).\n    \"\"\"\n    lambdas = np.arange(lambda_range[0], lambda_range[1] + d_lambda / 2.0, d_lambda)\n    K = len(lambdas)\n    O_diag_np = np.array(o_diag)\n\n    evals_sorted = np.zeros((K, n))\n    evecs_sorted = np.zeros((K, n, n))\n\n    for k, lmbda in enumerate(lambdas):\n        H = np.zeros((n, n), dtype=np.float64)\n        for i in range(n):\n            H[i, i] = e_funcs[i](lmbda)\n        for (i, j), func in v_funcs.items():\n            val = func(lmbda)\n            H[i, j] = val\n            H[j, i] = val\n        \n        evals, evecs = np.linalg.eigh(H)\n        evals_sorted[k, :] = evals\n        evecs_sorted[k, :, :] = evecs\n\n    exp_vals_sorted = np.sum(evecs_sorted**2 * O_diag_np[np.newaxis, :, np.newaxis], axis=1).T\n    \n    diff_sq_naive = (exp_vals_sorted[:, 1:] - exp_vals_sorted[:, :-1])**2\n    D_naive = np.sum(diff_sq_naive)\n\n    labeled_evecs = np.zeros_like(evecs_sorted)\n    labeled_exp_vals = np.zeros_like(exp_vals_sorted)\n    labeled_evecs[0] = evecs_sorted[0]\n    labeled_exp_vals[0] = exp_vals_sorted[:, 0]\n    \n    delta_O_max = np.max(O_diag_np) - np.min(O_diag_np)\n    if delta_O_max  1e-9:\n        delta_O_max = 1.0\n    \n    w = 0.5\n\n    for k in range(1, K):\n        old_vecs = labeled_evecs[k - 1].T\n        old_exp_vals = labeled_exp_vals[k-1]\n        \n        new_vecs_sorted_k = evecs_sorted[k].T\n        new_exp_vals_sorted_k = exp_vals_sorted[:, k]\n        \n        cost_matrix = np.zeros((n, n))\n        for i in range(n):\n            for j in range(n):\n                overlap = np.abs(np.dot(old_vecs[:, i].conj(), new_vecs_sorted_k[:, j]))**2\n                cost_fidelity = 1.0 - overlap\n                exp_val_diff_sq = ((new_exp_vals_sorted_k[j] - old_exp_vals[i]) / delta_O_max)**2\n                cost_matrix[i, j] = w * cost_fidelity + (1 - w) * exp_val_diff_sq\n        \n        row_ind, col_ind = linear_sum_assignment(cost_matrix)\n        \n        labeled_evecs[k] = new_vecs_sorted_k[:, col_ind].T\n        labeled_exp_vals[k] = new_exp_vals_sorted_k[col_ind]\n\n    labeled_exp_vals_T = labeled_exp_vals.T\n    diff_sq_algo = (labeled_exp_vals_T[:, 1:] - labeled_exp_vals_T[:, :-1])**2\n    D_algo = np.sum(diff_sq_algo)\n    \n    return D_naive, D_algo\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the analysis.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 2,\n            \"e_funcs\": [lambda l: -1.0 * l, lambda l: 1.0 * l],\n            \"v_funcs\": {(0, 1): lambda l: gaussian(l, 0.0, 0.2, 0.15)},\n            \"o_diag\": [0.0, 1.0],\n            \"lambda_range\": (-2.0, 2.0),\n            \"d_lambda\": 0.05,\n        },\n        {\n            \"n\": 3,\n            \"e_funcs\": [lambda l: -1.0 + 0.5 * l, lambda l: 0.0, lambda l: 1.0 - 0.5 * l],\n            \"v_funcs\": {\n                (0, 1): lambda l: gaussian(l, -0.5, 0.15, 0.12),\n                (1, 2): lambda l: gaussian(l, 0.5, 0.15, 0.12),\n            },\n            \"o_diag\": [0.0, 1.0, 2.0],\n            \"lambda_range\": (-1.5, 1.5),\n            \"d_lambda\": 0.05,\n        },\n        {\n            \"n\": 3,\n            \"e_funcs\": [lambda l: -0.3 * l, lambda l: 0.3 * l, lambda l: 1.2],\n            \"v_funcs\": {},\n            \"o_diag\": [0.0, 1.0, 2.0],\n            \"lambda_range\": (-1.0, 1.0),\n            \"d_lambda\": 0.05,\n        }\n    ]\n\n    final_results = []\n    for case in test_cases:\n        D_naive, D_algo = run_test_case(**case)\n        final_results.append(f\"[{D_naive:.6f}, {D_algo:.6f}]\")\n    \n    print(f\"[{', '.join(final_results)}]\")\n\nsolve()\n```", "id": "3604776"}, {"introduction": "在静态的轴对称原子核中，角动量在对称轴上的投影 $K$ 是一个好量子数。然而，当原子核旋转时，科里奥利力会介入，可能导致具有不同 $K$ 值的态发生混合，从而破坏这一对称性。本练习 [@problem_id:3604826] 通过构建一个简化的双能级模型，让您动手计算科里奥利耦合如何导致 $K$ 混合，并量化这种混合的程度。这个实践将帮助您深入理解旋转是如何影响原子核的内禀结构和量子数的。", "problem": "要求您编写一个完整、可运行的程序，通过计算近简并尼尔森态（Nilsson states）之间由非对角科里奥利耦合（Coriolis couplings）引起的混合，来评估总角动量投影（K）量子数随形变增加的稳健性。分析必须从计算核物理中适用于轴对称形变核的尼尔森模型的第一性原理出发，避免使用简化公式，并得出定量结果。\n\n从以下基本依据开始：\n- 在轴对称形变平均场中的尼尔森单粒子哈密顿量可以写成一个有效哈密顿量，包含一个形变相关项和一个科里奥利项。在内禀参考系中，科里奥利相互作用源于绕垂直于对称轴的轴的转动，并由一个与角动量算符在该轴上投影成正比的项来建模。\n- 在轴对称形变平均场中，单粒子能量的一阶微扰移动可以表示为无量纲四极形变参数 $ \\varepsilon_2 $ 的线性函数，其依赖于投影量子数 $ K $ 和总单粒子角动量 $ j $。\n- 角动量算符遵循标准的对易关系，升降算符 $ J_{+} $ 和 $ J_{-} $ 分别使投影量子数改变 $ +1 $ 和 $ -1 $。\n\n在由两个尼尔森态 $ \\lvert j, K_1 \\rangle $ 和 $ \\lvert j, K_2 \\rangle $ 张成的空间中构造一个两能级模型，这两个态具有相同的总单粒子角动量 $ j $，但投影量子数 $ K_1 $ 和 $ K_2 $ 不同。假设轴对称性，并绕垂直于对称轴的轴转动，从而使得相关的科里奥利项混合 $ K $ 相差 $ \\pm 1 $ 的态。\n\n定义以下参数化：\n- 使用自然单位制，其中约化普朗克常数 $ \\hbar $ 等于 $ 1 $，因此转动频率 $ \\omega_{\\mathrm{rot}} $ 的单位为兆电子伏（MeV），所有能量的单位也为兆电子伏（MeV）。\n- 设未微扰基底能量为 $ E_{\\mathrm{base}} $（单位为MeV）。\n- 将态 $ \\lvert j, K \\rangle $ 的一阶形变引起的能量移动建模为\n$$\n\\Delta E_{\\mathrm{def}}(j,K,\\varepsilon_2) = c_{\\mathrm{def}} \\, \\varepsilon_2 \\, \\left( 3 K^2 - j(j+1) \\right),\n$$\n其中 $ c_{\\mathrm{def}} $ 是单位为MeV的形变斜率系数，$ \\varepsilon_2 $ 是无量纲四极形变，$ j $ 是总单粒子角动量，$ K $ 是其投影。\n- 总对角能量为\n$$\nE_1 = E_{\\mathrm{base}} + \\Delta E_{\\mathrm{def}}(j,K_1,\\varepsilon_2), \\quad\nE_2 = E_{\\mathrm{base}} + \\Delta E_{\\mathrm{def}}(j,K_2,\\varepsilon_2).\n$$\n- 绕 $ x $ 轴转动的科里奥利耦合与 $ J_x $ 成正比。在 $ \\lvert j, K \\rangle $ 基中，使用角动量阶梯算符 $ J_{\\pm} $ 连接 $ K \\leftrightarrow K \\pm 1 $ 以获得 $ \\lvert j, K_1 \\rangle $ 和 $ \\lvert j, K_2 \\rangle $ 之间的非对角矩阵元 $ V $。只有当 $ \\lvert K_1 - K_2 \\rvert = 1 $ 时，混合才非零。\n\n构造 $ 2 \\times 2 $ 哈密顿量\n$$\nH =\n\\begin{pmatrix}\nE_1  V \\\\\nV  E_2\n\\end{pmatrix},\n$$\n将其对角化，并计算低能本征态中的混合。对于较低的本征矢量 $ \\lvert \\psi_- \\rangle = c_1 \\lvert j, K_1 \\rangle + c_2 \\lvert j, K_2 \\rangle $，将K混合分数定义为\n$$\nf = \\min\\left( \\lvert c_1 \\rvert^2, \\lvert c_2 \\rvert^2 \\right),\n$$\n它量化了低能本征态中少数 $ K $ 组分的概率权重。较小的 $ f $ 表示 $ K $ 量子数更稳健，而较大的 $ f $ 则表示混合更强。\n\n您的程序必须实现此模型，并为以下测试套件生成 $ f $ 的数值。在每种情况下，输入均为 $ \\left( j, K_1, K_2, \\varepsilon_2, \\omega_{\\mathrm{rot}}, E_{\\mathrm{base}}, c_{\\mathrm{def}} \\right) $，单位如前所述：\n- 情况 1：$ \\left( j = \\frac{11}{2}, K_1 = \\frac{5}{2}, K_2 = \\frac{7}{2}, \\varepsilon_2 = 0.05, \\omega_{\\mathrm{rot}} = 0.05 \\, \\mathrm{MeV}, E_{\\mathrm{base}} = 10.0 \\, \\mathrm{MeV}, c_{\\mathrm{def}} = 1.75 \\, \\mathrm{MeV} \\right) $。\n- 情况 2：$ \\left( j = \\frac{11}{2}, K_1 = \\frac{5}{2}, K_2 = \\frac{7}{2}, \\varepsilon_2 = 0.0, \\omega_{\\mathrm{rot}} = 0.10 \\, \\mathrm{MeV}, E_{\\mathrm{base}} = 10.0 \\, \\mathrm{MeV}, c_{\\mathrm{def}} = 1.75 \\, \\mathrm{MeV} \\right) $。\n- 情况 3：$ \\left( j = \\frac{11}{2}, K_1 = \\frac{5}{2}, K_2 = \\frac{7}{2}, \\varepsilon_2 = 0.20, \\omega_{\\mathrm{rot}} = 0.30 \\, \\mathrm{MeV}, E_{\\mathrm{base}} = 10.0 \\, \\mathrm{MeV}, c_{\\mathrm{def}} = 1.75 \\, \\mathrm{MeV} \\right) $。\n- 情况 4：$ \\left( j = \\frac{9}{2}, K_1 = \\frac{1}{2}, K_2 = \\frac{5}{2}, \\varepsilon_2 = 0.0, \\omega_{\\mathrm{rot}} = 0.20 \\, \\mathrm{MeV}, E_{\\mathrm{base}} = 10.0 \\, \\mathrm{MeV}, c_{\\mathrm{def}} = 1.75 \\, \\mathrm{MeV} \\right) $。\n- 情况 5：$ \\left( j = \\frac{7}{2}, K_1 = \\frac{1}{2}, K_2 = \\frac{3}{2}, \\varepsilon_2 = 0.03, \\omega_{\\mathrm{rot}} = 0.20 \\, \\mathrm{MeV}, E_{\\mathrm{base}} = 10.0 \\, \\mathrm{MeV}, c_{\\mathrm{def}} = 1.75 \\, \\mathrm{MeV} \\right) $。\n\n要求：\n- 使用自然单位制，其中 $ \\hbar = 1 $。所有能量和频率均以兆电子伏（MeV）表示。\n- 您的程序必须为每种情况构建哈密顿量，将其对角化，计算低能本征态的 $ f $，并汇总结果。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述情况一致，例如 $ \\left[ r_1, r_2, r_3, r_4, r_5 \\right] $，其中每个 $ r_i $ 是为情况 $ i $ 计算出的混合分数 $ f $。", "solution": "问题陈述为分析轴对称形变核中科里奥利耦合对角动量投影量子数 $K$ 纯度的影响提供了一个定义明确且具有科学依据的框架。所有参数和明确的目标都已指定，允许基于量子力学原理和尼尔森（Nilsson）模型进行直接的数值实现。因此，该问题被认为是有效的。\n\n问题的核心是在一个旋转的、形变的核势中，构建并对角化一个 $2 \\times 2$ 的哈密顿矩阵，该矩阵代表了两个单粒子尼尔森态 $\\lvert j, K_1 \\rangle$ 和 $\\lvert j, K_2 \\rangle$ 之间的相互作用。分析过程如下。\n\n**1. 两能级哈密顿模型**\n\n系统由一个在两个标准正交态 $\\{\\lvert j, K_1 \\rangle, \\lvert j, K_2 \\rangle\\}$ 的基底下描述的哈密顿量 $H$ 所描述，其中 $j$ 是总单粒子角动量，$K$ 是其在核对称轴上的投影。该哈密顿量是一个 $2 \\times 2$ 矩阵：\n$$\nH =\n\\begin{pmatrix}\n\\langle j, K_1 \\rvert H \\lvert j, K_1 \\rangle  \\langle j, K_1 \\rvert H \\lvert j, K_2 \\rangle \\\\\n\\langle j, K_2 \\rvert H \\lvert j, K_1 \\rangle  \\langle j, K_2 \\rvert H \\lvert j, K_2 \\rangle\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nE_1  V \\\\\nV^*  E_2\n\\end{pmatrix}\n$$\n这里，$E_1$ 和 $E_2$ 是基态的对角能量，$V$ 是非对角耦合项。\n\n**2. 对角矩阵元：形变能**\n\n对角能量由一个基底能量 $E_{\\mathrm{base}}$ 和一个与形变相关的能量移动 $\\Delta E_{\\mathrm{def}}$ 组成。后者由一阶近似给出：\n$$\n\\Delta E_{\\mathrm{def}}(j, K, \\varepsilon_2) = c_{\\mathrm{def}} \\, \\varepsilon_2 \\, \\left( 3 K^2 - j(j+1) \\right)\n$$\n其中 $c_{\\mathrm{def}}$ 是一个形变系数，$\\varepsilon_2$ 是四极形变参数，$j(j+1)$ 代表总单粒子角动量的平方（其中 $\\hbar = 1$）。因此，态 $\\lvert j, K_1 \\rangle$ 和 $\\lvert j, K_2 \\rangle$ 的总对角能量为：\n$$\nE_1 = E_{\\mathrm{base}} + \\Delta E_{\\mathrm{def}}(j, K_1, \\varepsilon_2)\n$$\n$$\nE_2 = E_{\\mathrm{base}} + \\Delta E_{\\mathrm{def}}(j, K_2, \\varepsilon_2)\n$$\n\n**3. 非对角矩阵元：科里奥利耦合**\n\n非对角耦合源于科里奥利相互作用，该作用描述了核转动对单粒子的影响。对于一个绕垂直于对称轴（例如内禀 $x$ 轴）的轴以角频率 $\\omega_{\\mathrm{rot}}$ 转动的原子核，其科里奥利哈密顿量为：\n$$\nH_{\\mathrm{Coriolis}} = - \\omega_{\\mathrm{rot}} J_x\n$$\n其中 $J_x$ 是单粒子角动量算符在转动轴上的投影。我们使用阶梯算符 $J_+$ 和 $J_-$ 来表示 $J_x$：\n$$\nJ_x = \\frac{1}{2} (J_+ + J_-)\n$$\n非对角矩阵元 $V$ 则为 $V = \\langle j, K_1 | H_{\\mathrm{Coriolis}} | j, K_2 \\rangle$。阶梯算符具有连接 $K$ 量子数相差 $\\pm 1$ 的态的特性：\n$$\nJ_{\\pm} \\lvert j, K \\rangle = \\sqrt{j(j+1) - K(K \\pm 1)} \\, \\lvert j, K \\pm 1 \\rangle = \\sqrt{(j \\mp K)(j \\pm K + 1)} \\, \\lvert j, K \\pm 1 \\rangle\n$$\n由于 $\\lvert j, K \\rangle$ 态的正交性，矩阵元 $V$ 仅在 $\\lvert K_1 - K_2 \\rvert = 1$ 时非零。不失一般性地假设 $K_1  K_2$ 且 $K_1 = K_2 + 1$，则矩阵元变为：\n$$\nV = \\langle j, K_1 | (-\\omega_{\\mathrm{rot}}) \\frac{1}{2} (J_+ + J_-) | j, K_2 \\rangle = -\\frac{\\omega_{\\mathrm{rot}}}{2} \\langle j, K_1 | J_+ | j, K_2 \\rangle\n$$\n$$\nV = -\\frac{\\omega_{\\mathrm{rot}}}{2} \\sqrt{(j - K_2)(j + K_2 + 1)}\n$$\n如果我们定义 $K_ = \\min(K_1, K_2)$，则对于任何满足 $\\lvert K_1 - K_2 \\rvert = 1$ 的对，其通用表达式为：\n$$\nV = -\\frac{\\omega_{\\mathrm{rot}}}{2} \\sqrt{(j - K_)(j + K_ + 1)}\n$$\n这是一个实数值，所以 $V = V^*$，哈密顿矩阵是实对称的。如果 $\\lvert K_1 - K_2 \\rvert \\neq 1$，则直接的一阶耦合 $V$ 为零。\n\n**4. 对角化与K混合**\n\n哈密顿量被对角化以找到能量本征值 $E_{\\pm}$ 及相应的本征矢量。本征值由标准解给出：\n$$\nE_{\\pm} = \\frac{E_1 + E_2}{2} \\pm \\frac{1}{2} \\sqrt{(E_1 - E_2)^2 + 4V^2}\n$$\n低能本征态是 $\\lvert \\psi_- \\rangle$，对应本征值 $E_-$。该态是原始基态的线性组合：\n$$\n\\lvert \\psi_- \\rangle = c_1 \\lvert j, K_1 \\rangle + c_2 \\lvert j, K_2 \\rangle\n$$\n系数 $c_1$ 和 $c_2$ 是对应于 $E_-$ 的归一化本征矢量的分量。发现系统处于态 $\\lvert j, K_1 \\rangle$ 和 $\\lvert j, K_2 \\rangle$ 的概率分别是 $\\lvert c_1 \\rvert^2$ 和 $\\lvert c_2 \\rvert^2$，其中 $\\lvert c_1 \\rvert^2 + \\lvert c_2 \\rvert^2 = 1$。K混合分数 $f$ 定义为该低能态中少数组分的概率：\n$$\nf = \\min(\\lvert c_1 \\rvert^2, \\lvert c_2 \\rvert^2)\n$$\n$f=0$ 的值表示无混合（纯 $K$ 态），而 $f=0.5$（可能的最大值）表示最大混合。\n\n**5. 算法**\n\n每个测试用例的计算步骤如下：\n1.  接收输入参数：$j, K_1, K_2, \\varepsilon_2, \\omega_{\\mathrm{rot}}, E_{\\mathrm{base}}, c_{\\mathrm{def}}$。\n2.  使用提供的 $\\Delta E_{\\mathrm{def}}$ 公式计算对角能量 $E_1$ 和 $E_2$。\n3.  检查是否 $\\lvert K_1 - K_2 \\rvert = 1$。\n    - 如果不满足，则设置耦合 $V=0$。此时哈密顿量已是对角化的，本征矢量为 $(1, 0)^T$ 和 $(0, 1)^T$，混合分数 $f$ 自然为 $0$。\n    - 如果满足，则使用科里奥利公式计算非对角耦合 $V$。\n4.  构建 $2 \\times 2$ 实对称矩阵 $H$。\n5.  数值对角化 $H$ 以获得其本征值和本征矢量。标准库（例如 `numpy.linalg.eigh`）提供排序后的本征值，因此可以轻松识别出最低的本征值及其对应的本征矢量。\n6.  提取最低本征值对应的本征矢量 $(c_1, c_2)^T$。\n7.  计算概率 $\\lvert c_1 \\rvert^2$ 和 $\\lvert c_2 \\rvert^2$。\n8.  确定K混合分数 $f = \\min(\\lvert c_1 \\rvert^2, \\lvert c_2 \\rvert^2)$。\n9.  返回 $f$ 的值。\n\n此算法针对提供的测试用例实现，以量化 $K$ 量子数在不同形变和转动条件下的稳健性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the K-mixing fraction for a two-level Nilsson model\n    due to Coriolis coupling.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: (j, K1, K2, epsilon2, omega_rot, E_base, c_def)\n    test_cases = [\n        # Case 1\n        (11/2, 5/2, 7/2, 0.05, 0.05, 10.0, 1.75),\n        # Case 2\n        (11/2, 5/2, 7/2, 0.0, 0.10, 10.0, 1.75),\n        # Case 3\n        (11/2, 5/2, 7/2, 0.20, 0.30, 10.0, 1.75),\n        # Case 4\n        (9/2, 1/2, 5/2, 0.0, 0.20, 10.0, 1.75),\n        # Case 5\n        (7/2, 1/2, 3/2, 0.03, 0.20, 10.0, 1.75),\n    ]\n\n    results = []\n    for case in test_cases:\n        j, k1, k2, eps2, omega_rot, e_base, c_def = case\n\n        # 1. Calculate diagonal energies E1 and E2\n        def delta_e_def(j_val, k_val, eps2_val, c_def_val):\n            \"\"\"Calculates the deformation-induced energy shift.\"\"\"\n            j_term = j_val * (j_val + 1)\n            k_term = 3 * k_val**2\n            return c_def_val * eps2_val * (k_term - j_term)\n\n        e1 = e_base + delta_e_def(j, k1, eps2, c_def)\n        e2 = e_base + delta_e_def(j, k2, eps2, c_def)\n\n        # 2. Calculate off-diagonal Coriolis coupling V\n        v = 0.0\n        # The first-order Coriolis coupling is non-zero only if |K1 - K2| = 1\n        if abs(k1 - k2) == 1.0:\n            k_lesser = min(k1, k2)\n            # V = - (omega_rot / 2) * sqrt(j(j+1) - K_ * (K_ + 1))\n            # which is equivalent to - (omega_rot / 2) * sqrt((j - K_)(j + K_ + 1))\n            # The h-bar=1 factor is implicit.\n            v = -0.5 * omega_rot * np.sqrt((j - k_lesser) * (j + k_lesser + 1))\n\n        # 3. Construct and diagonalize the Hamiltonian\n        hamiltonian = np.array([\n            [e1, v],\n            [v, e2]\n        ])\n\n        # numpy.linalg.eigh returns eigenvalues in ascending order\n        # and corresponding eigenvectors as columns.\n        eigenvalues, eigenvectors = np.linalg.eigh(hamiltonian)\n        \n        # The lowest energy eigenstate corresponds to the first column\n        lower_eigenvector = eigenvectors[:, 0]\n        \n        c1 = lower_eigenvector[0]\n        c2 = lower_eigenvector[1]\n\n        # 4. Compute the K-mixing fraction f\n        # f = min(|c1|^2, |c2|^2)\n        prob_c1 = c1**2\n        prob_c2 = c2**2\n        \n        mixing_fraction = min(prob_c1, prob_c2)\n        results.append(mixing_fraction)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "3604826"}]}