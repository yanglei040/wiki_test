{"hands_on_practices": [{"introduction": "在深入研究复杂的数值解之前，研究一个简化但功能强大的案例是很有启发性的。这项练习使用可分离相互作用——核理论中的一个常用工具——将动量依赖的积分形式的能隙方程简化为单个标量方程。这种简化不仅使问题更易于处理，而且在一个简化的模型中可以得到解析解，为理解相互作用强度、能量截断和配对能隙之间的关系提供了一个清晰、直观的基准。[@problem_id:3594578]", "problem": "考虑在零温下，用 Bardeen–Cooper–Schrieffer (BCS) 平均场理论建模的均匀中子物质。重点关注动量空间中的自旋单态 $^{1}S_{0}$ 配对，其中配对能隙函数通过反常非对角场定义为\n$$\n\\Delta(\\mathbf{k}) \\equiv -\\sum_{\\mathbf{k}'} V(\\mathbf{k},\\mathbf{k}') \\,\\langle c_{-\\mathbf{k}'\\downarrow} c_{\\mathbf{k}'\\uparrow} \\rangle,\n$$\n其中 $V(\\mathbf{k},\\mathbf{k}')$ 是动量空间中的两体相互作用，$c_{\\mathbf{k}\\sigma}$ 是自旋投影为 $\\sigma$ 的费米子湮灭算符。设相互作用是可分离的，\n$$\nV(\\mathbf{k},\\mathbf{k}') = -g\\, f(k)\\, f(k'),\n$$\n其中 $g>0$，$f(k)$ 是一个仅依赖于动量大小 $k=|\\mathbf{k}|$ 的实数非负形式因子。假设物质是均匀的，具有化学势 $\\mu$、单粒子色散关系 $\\epsilon_{k}$，并定义 $\\xi_{k} \\equiv \\epsilon_{k} - \\mu$。在 BCS 框架内，通过 Bogoliubov 变换进行对角化，得到准粒子能量\n$$\nE_{k} = \\sqrt{\\xi_{k}^{2} + \\Delta(k)^{2}}.\n$$\n\n任务1（推导）：从上述 $\\Delta(\\mathbf{k})$ 的定义和 BCS 准粒子真空的结构出发，推导对于可分离相互作用，能隙可以写成 $\\Delta(k) = \\Delta\\, f(k)$ 的形式，其中 $\\Delta$ 是一个标量振幅。证明相应的自洽性可简化为关于 $\\Delta$ 的单个标量非线性方程，该方程涉及一个对 $\\xi$ 的积分，权重为 $f(k)^{2}$ 和 $E_{k}$。\n\n任务2（锐截止下的闭式解）：将问题特化为一个计算上方便的锐截止模型，其中在费米面周围的对称能量窗口 $|\\xi| \\leq \\omega_{c}$ 内，态密度 $N(0)$ 为常数，窗口外为零，并选择形式因子为\n$$\nf(k) = \\Theta\\left(\\omega_{c} - |\\xi_{k}|\\right),\n$$\n其中 $\\Theta$ 是 Heaviside 阶跃函数，$\\omega_c>0$ 是一个能量截止参数。在零温下的这些假设下，显式地计算该标量非线性方程，并获得能隙振幅 $\\Delta$ 作为 $g$、$N(0)$ 和 $\\omega_{c}$ 函数的闭式解析表达式。\n\n任务3（基准值计算）：使用您的闭式表达式，计算当参数选择为 $g\\,N(0) = 0.30$ 和 $\\omega_{c} = 10\\,\\text{MeV}$ 时的能隙数值。将您的答案四舍五入到四位有效数字。最终能隙以 MeV 为单位表示。", "solution": "该问题基于应用于核物质的BCS理论标准框架，被验证为具有科学依据、问题明确且客观。所提供的定义和假设是一致的，并且足以得出一个完整的解。\n\n### 任务1（推导）\n出发点是零温下动量依赖的能隙函数 $\\Delta(\\mathbf{k})$ 的自洽方程，形式如下：\n$$\n\\Delta(\\mathbf{k}) \\equiv -\\sum_{\\mathbf{k}'} V(\\mathbf{k},\\mathbf{k}') \\,\\langle c_{-\\mathbf{k}'\\downarrow} c_{\\mathbf{k}'\\uparrow} \\rangle\n$$\n在 BCS 基态中，对湮灭算符的期望值（称为反常密度或对振幅）由对应于态 $\\mathbf{k}'$ 的 Bogoliubov 系数 $u_{k'}$ 和 $v_{k'}$ 的乘积给出。标准结果是：\n$$\n\\langle c_{-\\mathbf{k}'\\downarrow} c_{\\mathbf{k}'\\uparrow} \\rangle = u_{k'}v_{k'} = \\frac{\\Delta(k')}{2E_{k'}}\n$$\n其中 $E_{k'} = \\sqrt{\\xi_{k'}^{2} + \\Delta(k')^{2}}$ 是准粒子能量，$\\xi_{k'} = \\epsilon_{k'} - \\mu$ 是相对于化学势 $\\mu$ 的单粒子能量。\n\n我们将此表达式和给定的可分离相互作用 $V(\\mathbf{k},\\mathbf{k}') = -g\\, f(k)\\, f(k')$ 代入 $\\Delta(\\mathbf{k})$ 的定义中：\n$$\n\\Delta(\\mathbf{k}) = -\\sum_{\\mathbf{k}'} \\left(-g\\, f(k)\\, f(k')\\right) \\frac{\\Delta(k')}{2E_{k'}}\n$$\n$$\n\\Delta(\\mathbf{k}) = g\\, f(k) \\sum_{\\mathbf{k}'} \\frac{f(k') \\, \\Delta(k')}{2E_{k'}}\n$$\n该方程的结构中，右侧是 $f(k)$ 与一个对所有态 $\\mathbf{k}'$ 求和的项的乘积，因此该项与 $\\mathbf{k}$ 无关。这种函数形式意味着任何解 $\\Delta(\\mathbf{k})$ 都必须与形式因子 $f(k)$ 成正比。因此我们可以做出以下拟设：\n$$\n\\Delta(k) = \\Delta \\, f(k)\n$$\n其中 $\\Delta$ 是一个标量振幅，相对于动量为常数。将此拟设代回能隙方程：\n$$\n\\Delta \\, f(k) = g \\, f(k) \\sum_{\\mathbf{k}'} \\frac{f(k') \\, (\\Delta \\, f(k'))}{2 E_{k'}}\n$$\n准粒子能量 $E_{k'}$ 现在用标量振幅 $\\Delta$ 表示：\n$$\nE_{k'} = \\sqrt{\\xi_{k'}^{2} + \\Delta(k')^2} = \\sqrt{\\xi_{k'}^{2} + (\\Delta \\, f(k'))^2}\n$$\n将此代入方程得到：\n$$\n\\Delta \\, f(k) = g \\, f(k) \\sum_{\\mathbf{k}'} \\frac{\\Delta \\, f(k')^2}{2\\sqrt{\\xi_{k'}^{2} + \\Delta^2 f(k')^2}}\n$$\n对于非平凡配对解（$\\Delta \\neq 0$）以及 $f(k) \\neq 0$ 的动量，我们可以将方程两边同除以 $\\Delta f(k)$。这得到了关于标量振幅 $\\Delta$ 的自洽方程：\n$$\n1 = g \\sum_{\\mathbf{k}'} \\frac{f(k')^2}{2\\sqrt{\\xi_{k'}^{2} + \\Delta^2 f(k')^2}}\n$$\n该方程表明问题简化为求解关于 $\\Delta$ 的单个标量非线性方程。在大型系统的连续极限下，对动量态 $\\mathbf{k}'$ 的求和可以转换为对能量 $\\xi'$ 的积分，并由单个自旋投影的态密度 (DOS) $N(\\xi')$ 加权。假设 DOS 在费米面附近近似为常数，$N(\\xi') \\approx N(0)$，方程变为：\n$$\n1 = g \\int d\\xi' \\, N(\\xi') \\, \\frac{f(k(\\xi'))^2}{2\\sqrt{\\xi'^2 + \\Delta^2 f(k(\\xi'))^2}} \\approx \\frac{g N(0)}{2} \\int \\frac{f(k(\\xi'))^2}{\\sqrt{\\xi'^2 + \\Delta^2 f(k(\\xi'))^2}} \\, d\\xi'\n$$\n这就是任务1所要求的结果，证明了问题可简化为关于 $\\Delta$ 的标量非线性方程。\n\n### 任务2（闭式解）\n现在我们特化到锐截止模型。假设如下：\n1.  态密度 $N(0)$ 在 $|\\xi| \\leq \\omega_{c}$ 区间为常数，其他地方为零。\n2.  形式因子为 $f(k) = \\Theta(\\omega_{c} - |\\xi_{k}|)$，这意味着当 $|\\xi| \\leq \\omega_c$ 时 $f(k(\\xi)) = 1$，否则 $f(k(\\xi)) = 0$。\n\n在这些条件下，能隙方程中的积分被限制在区间 $[-\\omega_c, \\omega_c]$ 内，并且在此区间内，$f(k(\\xi))^2 = 1$。能隙方程简化为：\n$$\n1 = \\frac{g N(0)}{2} \\int_{-\\omega_c}^{\\omega_c} \\frac{1}{\\sqrt{\\xi^2 + \\Delta^2 \\cdot 1^2}} \\, d\\xi\n$$\n被积函数是 $\\xi$ 的偶函数。因此我们可以简化积分为：\n$$\n1 = \\frac{g N(0)}{2} \\cdot 2 \\int_{0}^{\\omega_c} \\frac{d\\xi}{\\sqrt{\\xi^2 + \\Delta^2}} = g N(0) \\int_{0}^{\\omega_c} \\frac{d\\xi}{\\sqrt{\\xi^2 + \\Delta^2}}\n$$\n这是一个标准积分，其值为：\n$$\n\\int \\frac{d\\xi}{\\sqrt{\\xi^2 + \\Delta^2}} = \\mathrm{arcsinh}\\left(\\frac{\\xi}{\\Delta}\\right) + C\n$$\n计算该定积分：\n$$\n\\int_{0}^{\\omega_c} \\frac{d\\xi}{\\sqrt{\\xi^2 + \\Delta^2}} = \\left[\\mathrm{arcsinh}\\left(\\frac{\\xi}{\\Delta}\\right)\\right]_{0}^{\\omega_c} = \\mathrm{arcsinh}\\left(\\frac{\\omega_c}{\\Delta}\\right) - \\mathrm{arcsinh}(0) = \\mathrm{arcsinh}\\left(\\frac{\\omega_c}{\\Delta}\\right)\n$$\n将此结果代回能隙方程得到：\n$$\n1 = g N(0) \\, \\mathrm{arcsinh}\\left(\\frac{\\omega_c}{\\Delta}\\right)\n$$\n为了得到 $\\Delta$ 的闭式表达式，我们重排方程：\n$$\n\\frac{1}{g N(0)} = \\mathrm{arcsinh}\\left(\\frac{\\omega_c}{\\Delta}\\right)\n$$\n对两边应用双曲正弦函数：\n$$\n\\sinh\\left(\\frac{1}{g N(0)}\\right) = \\frac{\\omega_c}{\\Delta}\n$$\n最后，解出 $\\Delta$ 得到所求的解析表达式：\n$$\n\\Delta = \\frac{\\omega_c}{\\sinh\\left(\\frac{1}{g N(0)}\\right)}\n$$\n\n### 任务3（基准值计算）\n我们使用任务2中的闭式表达式和给定参数：$g N(0) = 0.30$ 和 $\\omega_c = 10\\,\\text{MeV}$。\n$$\n\\Delta = \\frac{10\\,\\text{MeV}}{\\sinh\\left(\\frac{1}{0.30}\\right)} = \\frac{10\\,\\text{MeV}}{\\sinh\\left(\\frac{10}{3}\\right)}\n$$\n我们计算其数值：\n$$\n\\frac{1}{0.30} = \\frac{10}{3} \\approx 3.33333\n$$\n$$\n\\sinh\\left(\\frac{10}{3}\\right) \\approx 13.997965\n$$\n$$\n\\Delta \\approx \\frac{10}{13.997965} \\,\\text{MeV} \\approx 0.7143740\\,\\text{MeV}\n$$\n将结果四舍五入到四位有效数字，我们得到：\n$$\n\\Delta \\approx 0.7144\\,\\text{MeV}\n$$", "answer": "$$\\boxed{0.7144}$$", "id": "3594578"}, {"introduction": "从无限物质的连续动量空间过渡到有限原子核或壳模型计算中典型的离散单粒子能级。这项练习提出了离散基底下BCS理论的典型问题，要求同时、自洽地求解化学势（$\\mu$）和配对能隙（$\\Delta$）的耦合方程。成功地为该系统实现数值求解器是计算核结构物理学中的一项基本技能，它教授了如何强制执行粒子数守恒等约束条件。[@problem_id:3594622]", "problem": "给定一个零温下的偶-偶费米子系统，该系统由一个简化对力哈密顿量建模，其具有恒定的对力强度 $G$ 作用于围绕参考能量的一个能量窗口内。单粒子谱是分立、等间距且关于参考能量对称的，其能量为 $ \\epsilon_n = n \\delta $，其中整数 $n$ 满足 $ |\\epsilon_n| \\leq E_c $，$ \\delta $ 是能级间距，$ E_c $ 是对力窗口的截断能量。每个能级都具有时间反演（二重）简并度。任务是确定化学势 $ \\mu $ 和对力能隙 $ \\Delta $，它们在零温平均场近似下自洽地描述该系统，同时在巨正则系综中保持指定的总粒子数 $ N $ 守恒。\n\n从简化对力模型和配对费米子的零温平均场框架出发，推导确定准粒子谱和占据振幅的必要自洽条件。基于这些条件，建立确定 $ \\mu $ 和 $ \\Delta $ 的耦合非线性方程组。您的推导必须确保解满足对偶-偶系统平均粒子数 $ N $ 的约束。\n\n然后，针对一组指定的参数值，为求解 $ \\mu $ 和 $ \\Delta $ 的耦合非线性方程组实现一个数值求解器。您必须确保数值方法强制 $ \\Delta > 0 $，能处理对力窗口 $ |\\epsilon_n| \\leq E_c $ 上的离散求和，并且即使在无相互作用的费米能级接近某个分立能级时也能得出解。为确保收敛，需要提供一个鲁棒的初始猜测值，并在必要时提供后备策略。\n\n所有能量均须以兆电子伏特（MeV）为单位表示。输出值 $ \\mu $ 和 $ \\Delta $ 必须以 MeV 为单位报告，并各自四舍五入到小数点后六位。\n\n使用以下单位为 MeV 和粒子数的参数集 $ (\\delta, E_c, G, N) $ 测试套件：\n- 测试用例 1（一般情况）：$ \\delta = 0.2 $, $ E_c = 5.0 $, $ G = 0.4 $, $ N = 40 $。\n- 测试用例 2（接近空壳填充）：$ \\delta = 0.5 $, $ E_c = 4.0 $, $ G = 0.6 $, $ N = 2 $。\n- 测试用例 3（高填充）：$ \\delta = 0.1 $, $ E_c = 3.0 $, $ G = 0.25 $, $ N = 80 $。\n- 测试用例 4（小模型空间，接近满壳）：$ \\delta = 0.5 $, $ E_c = 1.0 $, $ G = 0.8 $, $ N = 8 $。\n- 测试用例 5（弱对力）：$ \\delta = 0.3 $, $ E_c = 3.0 $, $ G = 0.15 $, $ N = 20 $。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，列表中的每个元素对应一个测试用例，并且本身就是一个列表 $ [\\mu, \\Delta] $，其中的两个条目均以 MeV 为单位并四舍五入到小数点后六位。例如：$ [[\\mu_1,\\Delta_1],[\\mu_2,\\Delta_2],\\dots] $。\n\n注意：在您的推导或数值方法中出现的任何三角函数或角度量，都必须以弧度为单位进行处理。最终的数值答案必须以浮点数形式提供，单位为 MeV，并按指定要求进行四舍五入，除列表结构外，输出行不應出现任何单位或其他文本。", "solution": "用户希望在一个简化的 Bardeen-Cooper-Schrieffer (BCS) 模型中，求解零温下偶-偶费米子系统的化学势 $\\mu$ 和对力能隙 $\\Delta$。这需要推导耦合的自洽 BCS 方程并对其进行数值求解。\n\n### 步骤 1：BCS 方程的理论推导\n\n该系统由一个在指定模型空间内的简化对力哈密顿量描述。我们在巨正则系综中进行研究，引入化学势 $\\mu$ 以固定平均粒子数 $N$。巨正则哈密顿量为 $K = H - \\mu N$。\n\n对力哈密顿量由下式给出：\n$$\nH = \\sum_{n, \\sigma} \\epsilon_n a_{n\\sigma}^\\dagger a_{n\\sigma} - G \\sum_{n, n'} a_{n\\uparrow}^\\dagger a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}'\\downarrow} a_{n' \\uparrow}\n$$\n其中 $a_{n\\sigma}^\\dagger$ 创建一个处于态 $n$、自旋投影为 $\\sigma$ 的费米子。在原子核物理的背景下，这些代表时间反演态。每个能级 $n$ 的能量为 $\\epsilon_n$，并具有对应于态 $|n\\rangle$ 及其时间反演伙伴 $|\\bar{n}\\rangle$ 的二重简并度。$G$ 是恒定对力强度。\n\n在 BCS 平均场近似中，四费米子相互作用项被线性化。我们将对力能隙参数 $\\Delta$ 定义为：\n$$\n\\Delta = G \\sum_{n'} \\langle a_{\\bar{n}'\\downarrow} a_{n'\\uparrow} \\rangle\n$$\n期望值是相对于 BCS 基态计算的。通过选择合适的相位，$\\Delta$ 可以被视为一个实的正数，即 $\\Delta > 0$。平均场巨正则哈密顿量 $K_{MF} = H_{MF} - \\mu N$ 变为：\n$$\nK_{MF} = \\sum_{n} (\\epsilon_n - \\mu) (a_{n\\uparrow}^\\dagger a_{n\\uparrow} + a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}\\downarrow}) - \\sum_n \\left( \\Delta a_{n\\uparrow}^\\dagger a_{\\bar{n}\\downarrow}^\\dagger + \\Delta a_{\\bar{n}\\downarrow} a_{n\\uparrow} \\right) + \\frac{\\Delta^2}{G}\n$$\n该哈密顿量是费米子算符的二次型，可以使用 Bogoliubov 变换进行对角化，该变换引入了准粒子算符 $\\alpha$：\n$$\n\\alpha_{n\\uparrow} = u_n a_{n\\uparrow} - v_n a_{\\bar{n}\\downarrow}^\\dagger\n$$\n$$\n\\alpha_{\\bar{n}\\downarrow} = u_n a_{\\bar{n}\\downarrow} + v_n a_{n\\uparrow}^\\dagger\n$$\n系数 $u_n$ 和 $v_n$ 是实数，并满足归一化条件 $u_n^2 + v_n^2 = 1$。此变换是正则的，并将 $K_{MF}$ 对角化为以下形式：\n$$\nK_{MF} = E_0 + \\sum_n E_n (\\alpha_{n\\uparrow}^\\dagger \\alpha_{n\\uparrow} + \\alpha_{\\bar{n}\\downarrow}^\\dagger \\alpha_{\\bar{n}\\downarrow})\n$$\n其中 $E_0$ 是基态能量，$E_n$ 是能级 $n$ 的准粒子能量：\n$$\nE_n = \\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}\n$$\nBCS 基态 $|\\Psi_{BCS}\\rangle$ 是这些准粒子的真空态，即对所有 $n, \\sigma$ 都有 $\\alpha_{n\\sigma} |\\Psi_{BCS}\\rangle = 0$。系数 $u_n$ 和 $v_n$ 由对角化过程确定：\n$$\nu_n^2 = \\frac{1}{2} \\left( 1 + \\frac{\\epsilon_n - \\mu}{E_n} \\right)\n$$\n$$\nv_n^2 = \\frac{1}{2} \\left( 1 - \\frac{\\epsilon_n - \\mu}{E_n} \\right)\n$$\n系数 $v_n^2$ 表示对态 $(n\\uparrow, \\bar{n}\\downarrow)$ 在基态中被占据的概率，而 $u_n^2 = 1 - v_n^2$ 是其未被占据的概率。\n\n从这个框架中可以推导出两个自洽方程。\n\n**1. 粒子数守恒方程：**\n基态中的平均粒子数 $N$ 是固定的。每个能级 $n$ 可以容纳两个粒子（一个时间反演对）。总粒子数是所有能级占据概率的总和：\n$$\nN = \\sum_n \\langle a_{n\\uparrow}^\\dagger a_{n\\uparrow} + a_{\\bar{n}\\downarrow}^\\dagger a_{\\bar{n}\\downarrow} \\rangle = \\sum_n (v_n^2 + v_n^2) = \\sum_n 2 v_n^2\n$$\n代入 $v_n^2$ 的表达式：\n$$\nN = \\sum_n 2 \\cdot \\frac{1}{2} \\left( 1 - \\frac{\\epsilon_n - \\mu}{E_n} \\right) = \\sum_n \\left( 1 - \\frac{\\epsilon_n - \\mu}{\\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}} \\right)\n$$\n这是第一个方程，它将 $\\mu$ 和 $\\Delta$ 与总粒子数 $N$ 联系起来。\n\n**2. 能隙方程：**\n第二个方程来自 $\\Delta$ 的自洽定义。期望值 $\\langle a_{\\bar{n}'\\downarrow} a_{n'\\uparrow} \\rangle$ 可以在准粒子真空中计算，得到 $u_{n'}v_{n'}$。\n$$\n\\Delta = G \\sum_{n'} u_{n'}v_{n'}\n$$\n我们可以将 $u_n v_n$ 表示为：\n$$\nu_n v_n = \\sqrt{u_n^2 v_n^2} = \\sqrt{\\frac{1}{4} \\left( 1 - \\left(\\frac{\\epsilon_n - \\mu}{E_n}\\right)^2 \\right)} = \\sqrt{\\frac{1}{4} \\frac{E_n^2 - (\\epsilon_n - \\mu)^2}{E_n^2}} = \\sqrt{\\frac{\\Delta^2}{4E_n^2}} = \\frac{\\Delta}{2E_n}\n$$\n这里我们使用了 $\\Delta > 0$。将其代回 $\\Delta$ 的定义中：\n$$\n\\Delta = G \\sum_n \\frac{\\Delta}{2E_n}\n$$\n对于一个非平庸的对力解（$\\Delta > 0$），我们可以两边同除以 $\\Delta$ 来获得能隙方程：\n$$\n1 = \\frac{G}{2} \\sum_n \\frac{1}{E_n} \\implies \\frac{2}{G} = \\sum_n \\frac{1}{\\sqrt{(\\epsilon_n - \\mu)^2 + \\Delta^2}}\n$$\n这是第二个自洽方程。\n\n求和 $\\sum_n$ 是对对力窗口内分立的单粒子能级集进行的。能级由 $\\epsilon_n = n \\delta$ 给出，其中整数 $n$ 满足 $|n\\delta| \\leq E_c$。这意味着 $n$ 的范围从 $n_{min} = -\\lfloor E_c/\\delta \\rfloor$ 到 $n_{max} = \\lfloor E_c/\\delta \\rfloor$。\n\n### 步骤 2：数值实现\n\n任务是求解关于变量 $(\\mu, \\Delta)$ 的以下耦合非线性方程组：\n$$\nf_1(\\mu, \\Delta) = N - \\sum_{n=n_{min}}^{n_{max}} \\left( 1 - \\frac{n\\delta - \\mu}{\\sqrt{(n\\delta - \\mu)^2 + \\Delta^2}} \\right) = 0\n$$\n$$\nf_2(\\mu, \\Delta) = \\frac{2}{G} - \\sum_{n=n_{min}}^{n_{max}} \\frac{1}{\\sqrt{(n\\delta - \\mu)^2 + \\Delta^2}} = 0\n$$\n该方程组将使用数值求根算法求解，具体来说是 `scipy.optimize.root`。\n\n**算法设计：**\n1.  **模型空间定义**：对于给定的参数集 $(\\delta, E_c, G, N)$，首先确定单粒子能级的范围。最大整数索引为 $n_{max} = \\lfloor E_c/\\delta \\rfloor$。能级集是一个能量数组 $\\epsilon_n = n\\delta$，其中 $n \\in \\{-n_{max}, -n_{max}+1, \\dots, n_{max}\\}$。\n\n2.  **方程组**：定义一个 Python 函数，它接受一个向量 `[mu, delta]` 并返回 `[f1(mu, delta), f2(mu, delta)]` 的值。求和是在预先计算的能级能量数组上进行的。注意，方程依赖于 $\\Delta^2$。因此，如果 $(\\mu, \\Delta)$ 是一个解，那么 $(\\mu, -\\Delta)$ 也是一个解。根据惯例，物理上的对力能隙是正的，所以我们取求解器找到的 $\\Delta$ 的绝对值。\n\n3.  **初始猜测值**：一个好的初始猜测值对于求根算法的收敛性和稳定性至关重要。\n    *   **对于 $\\mu$**：配对系统中的化学势 $\\mu$ 通常接近无相互作用系统的费米能级 $\\epsilon_F$。对于给定的对称谱，我们填充最低的 $N/2$ 个能级。最后一个占据能级的索引为 $n_{occ} = N/2 - n_{max} - 1$，第一个未占据能级的索引为 $n_{unocc} = N/2 - n_{max}$。初始猜测值 $\\mu_0$ 设置为中点：$\\mu_0 = (\\epsilon_{n_{occ}} + \\epsilon_{n_{unocc}})/2 = (N/2 - n_{max} - 0.5)\\delta$。这避免了将 $\\mu_0$ 精确地放在一个能级上，从而提高了鲁棒性。\n    *   **对于 $\\Delta$**：对力强度 $G$ 本身为能隙 $\\Delta$ 提供了一个合理的量级估计。因此，我们选择初始猜测值 $\\Delta_0 = G$。\n\n4.  **求解器执行**：我们采用 `scipy.optimize.root` 函数和 `hybr` 方法，这是一个用于非线性方程组的成熟且鲁棒的算法。使用方程函数和初始猜测值 `[mu_0, delta_0]` 调用求解器。如果主要猜测未能收敛，则通过尝试一个更小的能隙初始猜测值（例如 $\\Delta_0 = 0.1 G$）来实现后备策略，以处理弱对力的情况。\n\n5.  **输出格式化**：提取最终解向量 `[mu, delta]`。取 `delta` 的绝对值，并将两个值都按要求四舍五入到小数点后六位。对每个测试用例重复此过程，并将结果汇总到指定的列表格式中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main function to solve the BCS equations for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (delta, Ec, G, N) in MeV and particle count.\n    test_cases = [\n        (0.2, 5.0, 0.4, 40),   # Test case 1 (general case)\n        (0.5, 4.0, 0.6, 2),    # Test case 2 (near-empty filling)\n        (0.1, 3.0, 0.25, 80),  # Test case 3 (high filling)\n        (0.5, 1.0, 0.8, 8),    # Test case 4 (small model space, near full)\n        (0.3, 3.0, 0.15, 20),  # Test case 5 (weak pairing)\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_sol, delta_sol = solve_bcs(*case)\n        results.append([round(mu_sol, 6), round(delta_sol, 6)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_bcs(delta_e, Ec, G, N):\n    \"\"\"\n    Solves the coupled BCS equations for mu and delta for a single parameter set.\n\n    Args:\n        delta_e (float): Single-particle level spacing in MeV.\n        Ec (float): Pairing window cutoff energy in MeV.\n        G (float): Pairing strength in MeV.\n        N (int): Total even number of particles.\n\n    Returns:\n        tuple[float, float]: The solved chemical potential (mu) and pairing gap (delta).\n    \"\"\"\n\n    # 1. Define the model space\n    n_max = int(np.floor(Ec / delta_e))\n    eps_levels = np.arange(-n_max, n_max + 1) * delta_e\n\n    # 2. Define the system of equations for the root finder\n    def bcs_equations(variables):\n        mu, delta_gap = variables\n        \n        # Use delta_gap^2 in equations to handle potential negative values during iteration.\n        delta_gap_sq = delta_gap**2\n        \n        # Add a small epsilon to the denominator to prevent any potential sqrt(0) issues,\n        # though with floating point arithmetic it's highly unlikely.\n        quasiparticle_energies = np.sqrt((eps_levels - mu)**2 + delta_gap_sq)\n\n        # Equation 1: Number conservation\n        # N = sum_{n} (1 - (eps_n - mu) / E_n)\n        # We compute the residual: f1 = N - sum(...)\n        eq1 = N - np.sum(1.0 - (eps_levels - mu) / quasiparticle_energies)\n\n        # Equation 2: Gap equation\n        # 2/G = sum_{n} 1 / E_n\n        # We compute the residual: f2 = 2/G - sum(...)\n        # For G=0 this would be a problem, but G>0 in all test cases.\n        eq2 = 2.0 / G - np.sum(1.0 / quasiparticle_energies)\n\n        return [eq1, eq2]\n\n    # 3. Determine a robust initial guess\n    # For mu: non-interacting Fermi level, placed between the last occupied\n    # and first unoccupied levels.\n    mu_0 = (N / 2.0 - n_max - 0.5) * delta_e\n    \n    # For delta: The pairing strength G is a reasonable order-of-magnitude estimate.\n    delta_0 = G\n\n    # 4. Call the solver\n    solution = root(bcs_equations, [mu_0, delta_0], method='hybr', tol=1e-9)\n    \n    # Optional: Implement fallback strategy as mentioned in the problem description.\n    # If the first attempt fails, try a smaller initial delta.\n    if not solution.success:\n        solution = root(bcs_equations, [mu_0, 0.1 * G], method='hybr', tol=1e-9)\n        # If it still fails, the problem might be ill-conditioned. For this problem set,\n        # we assume one of these initial guesses will lead to convergence.\n        if not solution.success:\n            # This indicates a failure to converge, return NaNs or raise an error.\n            # In this contest, the problem is well-posed, so this path is not expected.\n            return (np.nan, np.nan)\n\n    mu_sol, delta_sol = solution.x\n    \n    # 5. Finalize the result\n    # The physical pairing gap Delta is positive. Since the equations depend on Delta^2,\n    # the solver might converge to a negative value. We take the absolute value.\n    delta_sol = abs(delta_sol)\n    \n    # Handle the trivial solution case for weak pairing\n    # if the gap equation cannot be satisfied for any Delta > 0.\n    # This can be checked by evaluating the gap equation at Delta=0.\n    # If 2/G > sum(1/|eps-mu|), then Delta=0 is the only solution.\n    # However, the problem formulation implies a paired solution (Delta>0) exists.\n    # The numerical value of delta_sol will be very close to zero in this case.\n\n    return mu_sol, delta_sol\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3594622"}, {"introduction": "最后，我们通过一个在概念上更深入、在计算上要求更高的练习来探讨现代物理学中的一个核心问题：重整化。这个问题探讨了如何正确处理使用简化接触（零程）相互作用时出现的紫外发散。通过将裸相互作用强度与一个物理可观测量（散射长度）联系起来，您将验证一个深刻的原理：当理论被正确重整化时，物理预测（如配对能隙）应独立于非物理的正则化截断（$\\Lambda$）。这项练习提供了有效场论基石概念的实践经验。[@problem_id:3594665]", "problem": "您的任务是，在一个均匀费米系统的零温 Bardeen–Cooper–Schrieffer (BCS) 理论中，使用动量截断来实现并验证三维零程（接触）相互作用的重整化。请完全在自然单位制下进行计算，其中 $\\hbar = 1$ 且 $2m = 1$，这意味着 $\\varepsilon_k = k^2$ 并且所有量都是无量纲的。在此设定下，动量的单位是长度的倒数，能量的单位是动量的平方，s波散射长度 $a_s$ 的单位是长度。核心目标是将裸耦合拟合到目标散射长度，然后证明在费米动量处得到的BCS能隙与动量截断无关。\n\n基本原理和定义：\n- 接触相互作用定义为 $V = -g$，其中 $g$ 是一个正的常数，将通过重整化来确定。\n- 在双体部分，零能壳上$T$矩阵与散射长度 $a_s$ 相关，并且必须用于在施加锐利动量截断 $k \\leq \\Lambda$ 时，将依赖于截断的裸耦合拟合到目标 $a_s$。推导必须从 Lippmann–Schwinger 方程和零能散射振幅的定义开始；不要使用任何简便公式。\n- 在零温的多体部分，均匀各向同性s波 Bardeen–Cooper–Schrieffer (BCS) 能隙满足一个关于动量的自洽积分方程，该方程带有锐利截断 $k \\leq \\Lambda$。准粒子能量为 $E_k = \\sqrt{(\\varepsilon_k - \\mu)^2 + \\Delta^2}$，其中 $\\varepsilon_k = k^2$。化学势 $\\mu$ 必须设置为等于自由费米能 $\\varepsilon_F = k_F^2$，这适用于弱耦合费米系统。对于s波通道中的接触相互作用，能隙参数 $\\Delta$ 与动量无关。能隙方程涉及到三维空间中的态密度因子。\n\n任务：\n1) 从零能下带有锐利动量截断 $k \\leq \\Lambda$ 的零程相互作用的 Lippmann–Schwinger 方程出发，推导出用所选单位制下目标散射长度 $a_s$ 表示依赖于截断的裸耦合 $g(\\Lambda)$ 的关系式。\n2) 使用针对带有锐利截断 $k \\leq \\Lambda$ 的接触相互作用的零温 Bardeen–Cooper–Schrieffer (BCS) 能隙方程，在固定费米动量 $k_F$ 和使用 $\\mu = k_F^2$ 的条件下，实现一个求解 $\\Delta$ 的数值求解器。\n3) 对于下面的每个测试用例，使用从步骤1得到的 $g(\\Lambda)$，为每个列出的截断 $\\Lambda$ 计算能隙 $\\Delta$，然后验证这组 $\\Delta$ 值在指定容差范围内相对于 $\\Lambda$ 是不变的。这里的不变性意味着，与平均能隙的最大相对偏差 $\\max_i \\left|\\Delta_i - \\overline{\\Delta}\\right|/\\overline{\\Delta}$ 小于或等于给定的容差。\n\n数值与实现要求：\n- 所有计算必须使用上述指定的单位制进行，在本问题陈述中这些单位是无量纲的。\n- Bardeen–Cooper–Schrieffer (BCS) 能隙方程中的动量积分必须以足够的数值精度计算。当 $\\Delta$ 很小时，请特别注意被积函数在 $k = k_F$ 附近的可积峰值。\n- 能隙的求根过程必须有稳健的区间界定，并且收敛到 $\\Delta > 0$。\n- 不允许外部输入。所有参数都在下面给出，并且必须硬编码。\n\n测试套件：\n对于每个测试用例，给定 $(k_F, a_s, [\\Lambda\\ \\text{值}], \\text{容差})$。按所列顺序为每个 $\\Lambda$ 计算能隙 $\\Delta$，然后使用该容差计算如上所述的不变性布尔值。\n\n- 测试用例1（正常路径）：$k_F = 1.0$， $a_s = -0.5$， $\\Lambda \\in \\{2.0, 3.0, 4.0\\}$， 容差 $= 0.05$。\n- 测试用例2（边界，低截断值）：$k_F = 0.75$， $a_s = -1.0$， $\\Lambda \\in \\{1.5, 2.0, 3.0\\}$， 容差 $= 0.08$。\n- 测试用例3（边缘，大截断值和弱耦合）：$k_F = 1.25$， $a_s = -0.3$， $\\Lambda \\in \\{3.0, 6.0, 9.0\\}$， 容差 $= 0.06$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，该列表必须按顺序连接以下内容：按照给定 $\\Lambda$ 值的顺序排列的三个计算出的能隙（浮点数），后面跟着一个布尔值，表示在给定容差内不变性是否成立。因此，最终输出必须完全包含12个条目，顺序如下：\n$[\\Delta^{(1)}(\\Lambda_1), \\Delta^{(1)}(\\Lambda_2), \\Delta^{(1)}(\\Lambda_3), \\text{invariant}^{(1)}, \\Delta^{(2)}(\\Lambda_1), \\Delta^{(2)}(\\Lambda_2), \\Delta^{(2)}(\\Lambda_3), \\text{invariant}^{(2)}, \\Delta^{(3)}(\\Lambda_1), \\Delta^{(3)}(\\Lambda_2), \\Delta^{(3)}(\\Lambda_3), \\text{invariant}^{(3)}]$.", "solution": "该问题经评估在科学上成立、问题明确、客观且内部一致。它提出了计算多体物理学中一个标准的、非平凡的任务：接触相互作用的重整化及其在 Bardeen–Cooper–Schrieffer (BCS) 能隙方程中的应用。所提供的参数和条件在物理上是合理的，在数学上是健全的。因此，有必要提供完整的解决方案。\n\n解决方案分为三部分呈现：首先，推导正则化的耦合常数 $g(\\Lambda)$；其次，推导待求解的 BCS 能隙方程；第三，阐述求解此方程并验证所需截断无关性的数值策略。\n\n**1. 耦合常数的重整化**\n\n裸耦合常数 $g$ 与物理 s 波散射长度 $a_s$ 之间的关系通过双体散射问题建立。我们从质心系中的 $T$ 矩阵的 Lippmann-Schwinger 方程开始：\n$$ T(E) = V + V G_0(E) T(E) $$\n其中 $V$ 是相互作用势，$G_0(E)$ 是自由双粒子传播子。对于零程接触相互作用，势矩阵元与动量无关，$\\langle \\mathbf{k}' | V | \\mathbf{k} \\rangle = -g$，对于吸引势，$g>0$。因此，$T$ 矩阵也与动量无关，即 $T(E)$。Lippmann-Schwinger 方程变为一个关于 $T(E)$ 的代数方程：\n$$ \\frac{1}{T(E)} = -\\frac{1}{g} - \\int \\frac{d^3 q}{(2\\pi)^3} \\frac{1}{E - 2\\varepsilon_q + i\\eta} $$\n在指定的单位制中，$2m=1$ 且 $\\hbar=1$，单粒子能量为 $\\varepsilon_q = q^2$。该积分是紫外发散的，通过使用锐利动量截断 $\\Lambda$ 进行正则化：\n$$ \\frac{1}{T(E)} = -\\frac{1}{g(\\Lambda)} - \\int_{q \\le \\Lambda} \\frac{d^3 q}{(2\\pi)^3} \\frac{1}{E - 2q^2 + i\\eta} $$\n散射长度 $a_s$ 与零能壳上 $T$ 矩阵相关。在低能物理学中，一个标准的约定（与不支持束缚态的吸引势 $a_s < 0$ 相一致）通过 $T_{phys} = \\frac{4\\pi \\hbar^2 a_s}{m}$ 将壳上 $T$ 矩阵与 $a_s$ 联系起来。在我们的单位制中，这得到 $T(E=0) = 8\\pi a_s$。将 $E=0$ 代入 $T(E)$ 的方程中：\n$$ \\frac{1}{8\\pi a_s} = -\\frac{1}{g(\\Lambda)} - \\int_0^\\Lambda \\frac{4\\pi q^2 dq}{(2\\pi)^3} \\frac{1}{-2q^2} $$\n计算该积分：\n$$ \\int_0^\\Lambda \\frac{4\\pi q^2 dq}{8\\pi^3} \\frac{1}{-2q^2} = -\\frac{1}{4\\pi^2} \\int_0^\\Lambda dq = -\\frac{\\Lambda}{4\\pi^2} $$\n将此结果代回得到：\n$$ \\frac{1}{8\\pi a_s} = -\\frac{1}{g(\\Lambda)} + \\frac{\\Lambda}{4\\pi^2} $$\n求解依赖于截断的裸耦合常数 $1/g(\\Lambda)$：\n$$ \\frac{1}{g(\\Lambda)} = \\frac{\\Lambda}{4\\pi^2} - \\frac{1}{8\\pi a_s} $$\n对于给定的测试用例，$a_s  0$，这确保了 $1/g(\\Lambda) > 0$ 从而 $g(\\Lambda) > 0$，与 BCS 配对所需的吸引相互作用一致。\n\n**2. BCS 能隙方程**\n\n在零温下，由接触相互作用产生的、与动量无关的能隙 $\\Delta$ 的自洽BCS能隙方程为：\n$$ 1 = g(\\Lambda) \\sum_{\\mathbf{k}}' \\frac{1}{2E_k} $$\n其中求和遍历所有动量态，直至截断 $\\Lambda$，而 $E_k = \\sqrt{(\\varepsilon_k - \\mu)^2 + \\Delta^2}$ 是准粒子能量。题目要求我们对化学势使用弱耦合近似，即 $\\mu \\approx \\varepsilon_F = k_F^2$。求和被转换为积分：\n$$ \\sum_{\\mathbf{k}}' \\to \\int_{k \\le \\Lambda} \\frac{d^3 k}{(2\\pi)^3} = \\int_0^\\Lambda \\frac{4\\pi k^2 dk}{(2\\pi)^3} = \\frac{1}{2\\pi^2} \\int_0^\\Lambda k^2 dk $$\n能隙方程变为：\n$$ 1 = g(\\Lambda) \\frac{1}{2\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{2\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\n求解 $1/g(\\Lambda)$：\n$$ \\frac{1}{g(\\Lambda)} = \\frac{1}{4\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\n通过将来自双体和多体部分得到的两个 $1/g(\\Lambda)$ 表达式相等，我们得到了一个关于能隙 $\\Delta$ 的单一方程：\n$$ \\frac{\\Lambda}{4\\pi^2} - \\frac{1}{8\\pi a_s} = \\frac{1}{4\\pi^2} \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\n两边乘以 $4\\pi^2$ 得到最终需要求解 $\\Delta$ 的方程：\n$$ \\Lambda - \\frac{\\pi}{2a_s} = \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} $$\n这个方程将多体可观测量 $\\Delta$ 与双体可观测量 $a_s$ 和费米动量 $k_F$ 联系起来，并通过截断 $\\Lambda$ 进行正则化。问题的核心在于证明，当 $\\Lambda \\gg k_F$ 时，此方程的解 $\\Delta$ 近似地与 $\\Lambda$ 无关。\n\n**3. 数值策略**\n\n寻找 $\\Delta$ 的问题现在是一个求根问题。我们定义一个函数 $H(\\Delta)$，使其根为所求的能隙值：\n$$ H(\\Delta) = \\int_0^\\Lambda \\frac{k^2 dk}{\\sqrt{(k^2 - k_F^2)^2 + \\Delta^2}} - \\Lambda + \\frac{\\pi}{2a_s} $$\n我们需要找到使 $H(\\Delta) = 0$ 的 $\\Delta > 0$。\n为了指导数值方法，我们分析 $H(\\Delta)$ 的性质：\n- **单调性**：导数 $\\frac{\\partial H}{\\partial \\Delta} = -\\Delta \\int_0^\\Lambda \\frac{k^2 dk}{[(k^2 - k_F^2)^2 + \\Delta^2]^{3/2}}$ 对于 $\\Delta > 0$ 严格为负。因此，$H(\\Delta)$ 是 $\\Delta$ 的单调递减函数，这保证了如果根存在，则其是唯一的。\n- **渐近行为**：\n  - 当 $\\Delta \\to 0^+$ 时，积分在 $k=k_F$ 处对数发散，所以 $H(\\Delta \\to 0^+) \\to +\\infty$。\n  - 当 $\\Delta \\to \\infty$ 时，被积函数趋近于0，所以积分趋向于0。因此，$H(\\Delta \\to \\infty) \\to -\\Lambda + \\frac{\\pi}{2a_s}$。由于在所有测试用例中 $a_s  0$，该极限值总是负的。\n\n由于 $H(\\Delta)$ 在定义域 $\\Delta \\in (0, \\infty)$ 上是连续的、单调的，并且从正值变为负值，因此必须存在一个唯一的正根 $\\Delta$。\n这种结构非常适合使用像 Brent-Dekker 方法这样的区间求根算法。数值实现过程如下：\n1. 对于每个测试用例 $(k_F, a_s, \\Lambda)$，如上定义函数 $H(\\Delta)$。\n2. $H(\\Delta)$ 内的积分使用稳健的求积程序 `scipy.integrate.quad`进行数值计算。点 $k=k_F$ 是被积函数快速变化的区域，因此将其指定为积分器的关注点以提高精度。\n3. 使用 `scipy.optimize.root_scalar` 的 `brentq` 方法求解 $H(\\Delta)=0$ 的根，对于有界定的单调函数，该方法高效且可靠。基于渐近分析找到一个合适的区间，例如 $[\\delta_{min}, \\delta_{max}]$，其中 $\\delta_{min}$ 是一个很小的正数，而 $\\delta_{max}$ 与 $k_F^2$ 同数量级。\n4. 在一个测试用例中，对所有的 $\\Lambda$ 值重复此过程，以获得一组能隙值 $\\{\\Delta_i\\}$。\n5. 通过计算与平均能隙的最大相对偏差 $\\max_i |\\Delta_i - \\overline{\\Delta}| / |\\overline{\\Delta}|$，并将其与指定的容差进行比较，来检查截断不变性。\n最终的程序为每个测试用例实现此策略，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the BCS gap equation for a series of test cases and verifies\n    the cutoff independence of the gap parameter.\n    \"\"\"\n    test_cases = [\n        {'kF': 1.0, 'a_s': -0.5, 'Lambdas': [2.0, 3.0, 4.0], 'tolerance': 0.05},\n        {'kF': 0.75, 'a_s': -1.0, 'Lambdas': [1.5, 2.0, 3.0], 'tolerance': 0.08},\n        {'kF': 1.25, 'a_s': -0.3, 'Lambdas': [3.0, 6.0, 9.0], 'tolerance': 0.06},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        kF = case['kF']\n        a_s = case['a_s']\n        Lambdas = case['Lambdas']\n        tolerance = case['tolerance']\n\n        delta_values = []\n        for Lambda in Lambdas:\n            # -------------------------------------------------------------\n            # Define the function H(delta) whose root is the BCS gap.\n            # The equation to solve is H(delta) = 0, where:\n            # H(delta) = integral - (Lambda - pi / (2*a_s)) = 0\n            # -------------------------------------------------------------\n            target_integral_val = Lambda - np.pi / (2.0 * a_s)\n\n            def integrand(k, delta, kF_val):\n                # The integrand of the gap equation.\n                denominator = np.sqrt((k**2 - kF_val**2)**2 + delta**2)\n                # Avoid division by zero if delta is exactly zero, although\n                # root finder will use small positive numbers.\n                if denominator == 0:\n                    return np.inf\n                return k**2 / denominator\n\n            def H(delta, kF_val, Lambda_val):\n                # The function to find the root of.\n                \n                # Specify points of interest for the integrator if they are\n                # inside the integration interval. The integrand is sharply\n                # peaked at k=kF.\n                integration_points = []\n                if 0  kF_val  Lambda_val:\n                    integration_points.append(kF_val)\n\n                # Use quad for numerical integration.\n                integral_val, _ = quad(\n                    integrand, 0, Lambda_val, args=(delta, kF_val), points=integration_points\n                )\n                \n                return integral_val - target_integral_val\n\n            # -------------------------------------------------------------\n            # Find the root of H(delta) using a bracketing method.\n            # -------------------------------------------------------------\n            # Based on asymptotic analysis, a root is guaranteed to exist\n            # for delta  0.\n            # Lower bound: a small positive number (delta - 0, H - +inf)\n            delta_min = 1e-8 * kF**2\n            # Upper bound: a value on the scale of the Fermi energy\n            # (delta - inf, H - -inf)\n            delta_max = 5.0 * kF**2\n\n            # Ensure the bracket is valid before calling the solver.\n            # This should not be an issue given the function's monotonic nature.\n            try:\n                if H(delta_max, kF, Lambda) > 0:\n                    # The chosen upper bound is too small, increase it.\n                    # This is unlikely but handled for robustness.\n                    delta_max *= 10\n            except (ValueError, OverflowError):\n                 delta_max *= 10\n                 \n            # Find the root using Brent's method.\n            sol = root_scalar(H, args=(kF, Lambda), bracket=[delta_min, delta_max], method='brentq')\n            delta_values.append(sol.root)\n        \n        # -------------------------------------------------------------\n        # Verify the invariance of the calculated gap values.\n        # -------------------------------------------------------------\n        mean_delta = np.mean(delta_values)\n        if mean_delta == 0:\n            # This case is unlikely, but if it happens, deviation is 0.\n            max_rel_dev = 0.0\n        else:\n            deviations = np.abs(np.array(delta_values) - mean_delta)\n            max_rel_dev = np.max(deviations) / np.abs(mean_delta)\n        \n        is_invariant = max_rel_dev = tolerance\n\n        # Append the results for this test case to the final list.\n        results.extend(delta_values)\n        results.append(is_invariant)\n\n    # Final print statement in the exact required format.\n    # Format: [d_11, d_12, d_13, inv_1, d_21, d_22, d_23, inv_2, ...]\n    formatted_results = []\n    for item in results:\n        if isinstance(item, bool):\n            formatted_results.append(str(item).lower())\n        else:\n            # Use sufficient precision to avoid rounding issues in verification\n            # The problem does not specify output rounding for the gaps,\n            # so using a reasonable high precision is safe.\n            formatted_results.append(f\"{item:.8f}\") \n    \n    # Re-join with more precision for the float values\n    final_output_string = \"[\"\n    for i, item in enumerate(results):\n        if isinstance(item, bool):\n            final_output_string += str(item).lower()\n        else:\n            final_output_string += f\"{item:.10f}\"\n        if i  len(results) - 1:\n            final_output_string += \",\"\n    final_output_string += \"]\"\n    \n    print(final_output_string)\n\n# This block is for executing the solve function.\n# In the target environment, only the solve() call is needed.\nif __name__ == '__main__':\n    solve()\n```", "id": "3594665"}]}