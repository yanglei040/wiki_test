{"hands_on_practices": [{"introduction": "R-矩阵理论的一个基本原则是，物理可观测量必须独立于模型中任意选择的参数，例如通道半径 $a$。这个练习将通过一个思想实验来阐明这一概念。我们将探讨当通道半径发生微小变化时，为了保持物理散射长度 $a_s$ 不变，必须如何相应地调整远能级背景项 $R^\\infty$ [@problem_id:421956]。", "problem": "在 Wigner-Eisenbud 的核反应R矩阵理论中，物理可观测量与一个确定的道半径 $a$ 内的复合核性质相关联。对于单道中的低能s波 ($l=0$) 中子散射，散射相移 $\\delta_0$ 与依赖于能量的R矩阵 $R_0(E)$ 相关。在动能趋于零 ($E \\to 0$) 的极限情况下，这个关系可以用来定义s波散射长度 $a_s$，它是一个关键的物理可观测量。该关系式为：\n$$a_s = a(1 - R_0(0))$$\n其中 $R_0(0)$ 是在零能量下求值的R矩阵。\n\n在许多实际应用中，R矩阵通过对几个邻近的共振能级求和，并加上一个背景项 $R^\\infty$ 来近似，该背景项用于计入所有远能级的集体效应。在没有显著低能共振的情况下，R矩阵可以仅由这个背景项来近似，即 $R_0(0) \\approx R^\\infty$。\n\n道半径 $a$ 在某种程度上是模型的一个任意参数。然而，物理散射长度 $a_s$ 必须与 $a$ 的选择无关。这意味着如果我们改变道半径，R矩阵模型的参数必须进行调整，以保持物理可观测量不变。\n\n假设道半径从 $a$ 变为 $a+\\delta a$，变化量很小。为确保散射长度 $a_s$ 保持不变，远能级参数 $R^\\infty$ 必须相应地调整一个量 $\\delta R^\\infty$。假设 $\\delta a$ 是无穷小量，请找出所需的变化量 $\\delta R^\\infty$ 用初始参数 $a$、$R^\\infty$ 和变化量 $\\delta a$ 表示的表达式。", "solution": "问题要求我们找出，在道半径发生微小变化 $\\delta a$ 的情况下，为保持s波散射长度 $a_s$ 不变所需的 $\\delta R^\\infty$ 的变化量。\n\n1.  **陈述不变性原理和控制方程。**\n    物理s波散射长度 $a_s$ 必须独立于非物理道半径 $a$ 的选择。在给定模型中，这些量之间的关系是：\n    $$a_s = a(1 - R^\\infty)$$\n    这里我们使用了近似 $R_0(0) \\approx R^\\infty$。\n\n2.  **引入微扰。**\n    我们考虑道半径从其初始值 $a$ 变为新值 $a' = a + \\delta a$。为了保持 $a_s$ 的不变性，远能级参数 $R^\\infty$ 必须从其初始值变为新值 $R'^\\infty = R^\\infty + \\delta R^\\infty$。\n\n3.  **建立不变性条件。**\n    用新参数计算的散射长度必须等于原始散射长度。设原始散射长度为 $a_s$，新散射长度为 $a_s'$。条件是 $a_s' = a_s$。\n    对初始和最终状态使用控制方程，我们得到：\n    $$a'(1 - R'^\\infty) = a(1 - R^\\infty)$$\n    代入 $a'$ 和 $R'^\\infty$ 的表达式：\n    $$(a + \\delta a)(1 - (R^\\infty + \\delta R^\\infty)) = a(1 - R^\\infty)$$\n\n4.  **展开方程。**\n    我们展开方程的左边：\n    $$(a + \\delta a)(1 - R^\\infty - \\delta R^\\infty) = a(1 - R^\\infty - \\delta R^\\infty) + \\delta a(1 - R^\\infty - \\delta R^\\infty)$$\n    $$= a - a R^\\infty - a \\delta R^\\infty + \\delta a - \\delta a R^\\infty - \\delta a \\delta R^\\infty$$\n\n5.  **应用一阶近似。**\n    问题指明变化量 $\\delta a$ 是无穷小。因此，引起的变化 $\\delta R^\\infty$ 也将是无穷小。两个无穷小量之积 $\\delta a \\delta R^\\infty$ 是二阶小量，在一阶分析中可以忽略。\n    展开后的方程变为：\n    $$a(1 - R^\\infty) - a \\delta R^\\infty + \\delta a (1 - R^\\infty) \\approx a(1 - R^\\infty)$$\n\n6.  **求解变化量 $\\delta R^\\infty$。**\n    我们可以从近似式的两边消去项 $a(1 - R^\\infty)$：\n    $$-a \\delta R^\\infty + \\delta a (1 - R^\\infty) \\approx 0$$\n    整理各项以求解 $\\delta R^\\infty$：\n    $$a \\delta R^\\infty \\approx \\delta a (1 - R^\\infty)$$\n    最后，两边同除以 $a$（假设 $a \\neq 0$），我们得到远能级参数所需变化量的表达式：\n    $$\\delta R^\\infty = \\frac{1 - R^\\infty}{a} \\delta a$$\n    这个表达式表示当道半径发生无穷小变化时，为保持物理散射长度不变，对 $R^\\infty$ 所需的一阶修正。", "answer": "$$ \\boxed{\\frac{(1 - R^\\infty) \\delta a}{a}} $$", "id": "421956"}, {"introduction": "R矩阵计算的核心在于能级矩阵 $A(E)$ 的求逆。然而，这个求逆过程在数值上可能是不稳定的，尤其是在接近共振能量点时，这会导致计算结果不可靠。本练习旨在解决一个实际的计算物理问题：通过实现并比较一种直接求逆方法和一种更稳健的、基于奇异值分解（SVD）的伪逆方法，来确保计算结果的稳定性和准确性 [@problem_id:3585517]。", "problem": "考虑核反应的多能级、多道 Wigner–Eisenbud $R$ 矩阵表示。对于耦合到 $N_c$ 个开放道的 $N_\\lambda$ 个复合核能级，其能级矩阵 $A_{\\lambda\\lambda'}(E)$ 由以下要素定义：\n\n1. 一组以兆电子伏特 (MeV) 为单位的实数能级能量 $E_\\lambda$。\n2. 对于每个能级 $\\lambda$ 和道 $c$，其单位为能量平方根（具体为 $\\sqrt{\\text{MeV}}$）的实数约化宽度振幅 $\\gamma_{\\lambda c}$。\n3. 实数道边界条件常数 $B_c$（无量纲）。\n4. 复数道函数 $L_c(E)$（无量纲），其中 $L_c(E) = S_c(E) + i P_c(E)$, $S_c(E)$ 是实数位移函数，$P_c(E)$ 是实数穿透因子。在本问题中，假设为具有硬球边界的中性 s 波道，因此 $S_c(E) = 0$ 且 $P_c(E) = \\rho_c(E)$，其中 $\\rho_c(E) = k_c(E) a_c$，道半径 $a_c$ 的单位是飞米 (fm)，约化质量 $\\mu_c$ 的单位是兆电子伏特 (MeV)，理解为 $\\mu_c c^2$，波数 $k_c(E)$ 由 $k_c(E) = \\sqrt{2 \\mu_c E}/(\\hbar c)$ 给出。使用 $\\hbar c = 197.3269804\\,\\text{MeV}\\cdot\\text{fm}$。\n\n在这些假设下，能级矩阵为\n$$\nA_{\\lambda\\lambda'}(E) = (E_\\lambda - E)\\,\\delta_{\\lambda\\lambda'} - \\sum_{c=1}^{N_c} \\gamma_{\\lambda c}\\,\\big[L_c(E) - B_c\\big]\\,\\gamma_{\\lambda' c},\n$$\n该矩阵通常是复数且依赖于能量。\n\n根据 Wigner–Eisenbud 的构造，道-道 $R$ 矩阵 $R_{cc'}(E)$ 通过以下方式获得\n$$\nR_{cc'}(E) = \\sum_{\\lambda=1}^{N_\\lambda}\\sum_{\\lambda'=1}^{N_\\lambda} \\gamma_{\\lambda c}\\,\\big[A^{-1}(E)\\big]_{\\lambda\\lambda'}\\,\\gamma_{\\lambda' c'}.\n$$\n在同样的硬球简化（硬球相移为零）下，碰撞（散射）矩阵 $U_{cc'}(E)$ 为\n$$\nU(E) = I - 2 i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2},\n$$\n其中 $P(E) = \\operatorname{diag}\\big(P_1(E),\\dots,P_{N_c}(E)\\big)$，$I$ 是 $N_c\\times N_c$ 的单位矩阵。当模型假设得到满足且数值误差得到控制时，矩阵 $U(E)$ 应近似幺正。\n\n$A(E)$ 的求逆过程可能是病态的，尤其是在 $E \\approx E_\\lambda$ 的共振点附近，或者当约化宽度振幅横跨数个数量级时。为改善矩阵的条件，需实现对角缩放和奇异值分解 (SVD) 伪逆。具体步骤如下：\n\n1. 根据给定的输入构建 $A(E)$。\n2. 在可能的情况下，通过直接稠密矩阵求逆计算 $A(E)$ 的朴素逆。\n3. 计算 $A(E)$ 的缩放-SVD伪逆：\n   (a) 定义一个实数正定对角缩放矩阵 $S(E) = \\operatorname{diag}(s_1,\\dots,s_{N_\\lambda})$，其中\n   $$\n   s_\\lambda = \\left(|E_\\lambda - E|^2 + \\sum_{c=1}^{N_c} |\\gamma_{\\lambda c}|^2\\,\\big|L_c(E) - B_c\\big|^2\\right)^{-1/2}.\n   $$\n   (b) 构造缩放后的矩阵 $A_s(E) = S(E)\\,A(E)\\,S(E)$。\n   (c) 计算 SVD 分解 $A_s(E) = U \\Sigma V^\\dagger$，其中 $\\Sigma$ 的对角线上为非负奇异值 $\\sigma_i$。\n   (d) 通过替换每个 $\\sigma_i$ 来构造截断伪逆 $\\Sigma^+$：如果 $\\sigma_i \\ge \\tau$，则替换为 $\\sigma_i^{-1}$，否则替换为 0。容差 $\\tau = \\epsilon\\,\\sigma_{\\max}\\,N_\\lambda$，其中 $\\epsilon$ 是双精度浮点数的机器精度。\n   (e) 令 $A_s^+(E) = V\\,\\Sigma^+ U^\\dagger$，然后取消缩放以获得 $A^+(E) \\approx S(E)\\,A_s^+(E)\\,S(E)$，作为 $A^{-1}(E)$ 的一个稳定近似。\n4. 计算 $R(E)$ 和两个版本的 $U(E)$：一个是由朴素逆得到的 $U_{\\text{naive}}(E)$，另一个是由缩放-SVD伪逆得到的 $U_{\\text{svd}}(E)$。\n5. 使用以下诊断指标评估对 $U(E)$ 的数值影响：\n   (a) $A(E)$ 的条件数，由 $A(E)$ 的 SVD 定义为 $\\kappa\\big(A(E)\\big) = \\sigma_{\\max}/\\sigma_{\\min}$。约定当 $\\sigma_{\\min}$ 在数值上为零时，$\\kappa = 10^{18}$。\n   (b) 类似地定义的缩放矩阵 $A_s(E)$ 的条件数。\n   (c) $U_{\\text{naive}}(E)$ 和 $U_{\\text{svd}}(E)$ 的幺正性偏差，通过弗罗贝尼乌斯范数 $\\|U^\\dagger U - I\\|_F$ 衡量。\n   (d) 弗罗贝尼乌斯范数 $\\|U_{\\text{naive}}(E) - U_{\\text{svd}}(E)\\|_F$。\n\n所有能量必须以兆电子伏特 (MeV) 为单位处理，质量 $\\mu_c$ 以 MeV 为单位（解释为 $\\mu_c c^2$），半径 $a_c$ 以飞米 (fm) 为单位。角度不出现，没有需要指定的角度单位。输出为无量纲浮点数。\n\n实现一个程序，为以下固定数据和测试套件计算这些量。除非测试用例覆盖默认参数，否则使用 $N_\\lambda = 3$ 个能级和 $N_c = 2$ 个道，以及默认参数：\n\n- 能级：$E_\\lambda = [0.30,\\,1.10,\\,2.00]\\,\\text{MeV}$。\n- 约化质量：$\\mu_1 = 469.0\\,\\text{MeV}$，$\\mu_2 = 931.5\\,\\text{MeV}$。\n- 道半径：$a_1 = 5.0\\,\\text{fm}$，$a_2 = 5.5\\,\\text{fm}$。\n- 边界常数：$B_1 = 0.0$, $B_2 = 0.0$。\n- 以 $\\sqrt{\\text{MeV}}$ 为单位的约化宽度振幅：\n  $$\n  \\gamma = \\begin{bmatrix}\n  0.050  0.030\\\\\n  0.020  0.040\\\\\n  0.010  0.025\n  \\end{bmatrix}.\n  $$\n\n测试套件（每个用例指定能量 $E$ (单位 MeV) 和任何覆盖项）：\n\n1. 用例 1（共振点附近，使用默认的 $B_c$ 和 $\\gamma$）：$E = 1.10$。\n2. 用例 2（阈值附近，使用默认的 $B_c$ 和 $\\gamma$）：$E = 0.001$。\n3. 用例 3（更高能量，使用默认的 $B_c$ 和 $\\gamma$）：$E = 2.00$。\n4. 用例 4（非零边界条件）：$E = 1.10$，$B_1 = 0.30$，$B_2 = -0.20$。\n5. 用例 5（病态宽度）：$E = 1.10$，覆盖\n   $$\n   \\gamma = \\begin{bmatrix}\n   0.0001  0.0001\\\\\n   0.2000  0.2500\\\\\n   0.0001  0.0001\n   \\end{bmatrix}.\n   $$\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的列表组成的列表。对于每个测试用例，按以下顺序输出包含五个浮点数的列表：\n$[\\kappa(A),\\,\\kappa(A_s),\\,\\|U_{\\text{naive}}^\\dagger U_{\\text{naive}} - I\\|_F,\\,\\|U_{\\text{svd}}^\\dagger U_{\\text{svd}} - I\\|_F,\\,\\|U_{\\text{naive}} - U_{\\text{svd}}\\|_F]$。\n\n格式示例（使用占位符）：\"[[condA1,condAs1,unitNaive1,unitSvd1,diff1],[condA2,condAs2,unitNaive2,unitSvd2,diff2],...]\"。", "solution": "问题陈述经过严格验证，并被确定为有效。它在科学上基于 Wigner-Eisenbud R 矩阵核反应理论，这是计算核物理学中一个成熟的形式体系。该问题是适定的，为获得唯一的数值解提供了完整且一致的定义、参数和方程。其语言客观而精确，提议的任务——将朴素矩阵求逆与基于 SVD 的稳定化伪逆进行比较——是数值分析在物理学应用中的一个标准且有意义的练习。\n\n解决方案通过为每个提供的测试用例逐步实现指定的计算来展开。\n\n**1. R 矩阵形式体系设置**\n计算首先为给定的 $N_c=2$ 个道在指定的入射能量 $E$ 下定义依赖于能量的量。对于中性 s 波散射，位移函数 $S_c(E)$ 为零，穿透因子 $P_c(E)$ 由 $\\rho_c(E) = k_c(E) a_c$ 给出。波数 $k_c(E)$ 使用适用于 MeV 单位的非相对论动能表达式计算：\n$$k_c(E) = \\frac{\\sqrt{2 \\mu_c E}}{\\hbar c}$$\n其中 $\\mu_c$ 是以 MeV 为单位的约化质量（作为 $\\mu_c c^2$），常数 $\\hbar c = 197.3269804\\,\\text{MeV}\\cdot\\text{fm}$。因此，复数道函数 $L_c(E)$ 简化为 $L_c(E) = S_c(E) + i P_c(E) = i P_c(E)$。对每个开放道计算这些量。\n\n**2. 能级矩阵构造**\n构建 $N_\\lambda \\times N_\\lambda$（在本问题中为 $3 \\times 3$）的复数能级矩阵 $A(E)$。其元素由以下公式给出：\n$$A_{\\lambda\\lambda'}(E) = (E_\\lambda - E)\\,\\delta_{\\lambda\\lambda'} - \\sum_{c=1}^{N_c} \\gamma_{\\lambda c}\\,\\gamma_{\\lambda' c}\\,\\big[L_c(E) - B_c\\big]$$\n在矩阵表示法中，这表示为 $A(E) = \\operatorname{diag}(E_\\lambda - E) - \\gamma D(E) \\gamma^T$，其中 $\\gamma$ 是 $N_\\lambda \\times N_c$ 的约化宽度振幅矩阵，$D(E)$ 是一个对角元的元素为 $L_c(E) - B_c$ 的 $N_c \\times N_c$ 对角矩阵。此矩阵是复数且对称的，但不一定是厄米的。如果能量 $E$ 与某个能级能量 $E_\\lambda$ 相匹配，对角线上的项 $(E_\\lambda - E)$ 可能变为零，这是病态的主要来源。\n\n**3. 朴素求逆与碰撞矩阵**\n第一种方法是使用标准的线性代数库函数直接计算 $A(E)$ 的逆。\n$$A^{-1}_{\\text{naive}}(E) = \\operatorname{inv}\\big(A(E)\\big)$$\n然后通过矩阵乘法计算道-道 R 矩阵 $R_{cc'}$：\n$$R_{\\text{naive}}(E) = \\gamma^T A^{-1}_{\\text{naive}}(E) \\gamma$$\n最后，根据问题的硬球公式计算朴素碰撞矩阵 $U_{\\text{naive}}(E)$：\n$$U_{\\text{naive}}(E) = I - 2 i\\,P(E)^{1/2}\\,R_{\\text{naive}}(E)\\,P(E)^{1/2}$$\n其中 $I$ 是 $N_c \\times N_c$ 的单位矩阵，$P(E)^{1/2}$ 是对角元为 $\\sqrt{P_c(E)}$ 的对角矩阵。\n\n**4. 缩放 SVD 伪逆稳定化**\n第二种数值上更稳健的方法涉及几个步骤来稳定 $A(E)$ 的求逆过程。\n(a) **缩放**：引入一个对角缩放矩阵 $S(E) = \\operatorname{diag}(s_1, \\dots, s_{N_\\lambda})$ 来对能级矩阵进行预处理。定义缩放因子以近似地归一化 $A(E)$ 的行：\n$$s_\\lambda = \\left(|E_\\lambda - E|^2 + \\sum_{c=1}^{N_c} |\\gamma_{\\lambda c}|^2\\,\\big|L_c(E) - B_c\\big|^2\\right)^{-1/2}$$\n这会产生一个实数正定对角矩阵 $S(E)$。\n(b) **缩放矩阵**：对原始矩阵进行对称缩放，以平衡其元素的量级：\n$$A_s(E) = S(E)\\,A(E)\\,S(E)$$\n这种缩放旨在改善矩阵在求逆前的条件数。\n(c) **SVD**：计算缩放矩阵 $A_s(E)$ 的奇异值分解：\n$$A_s(E) = U \\Sigma V^\\dagger$$\n(d) **截断伪逆**：构造奇异值矩阵的伪逆 $\\Sigma^+$。低于特定容差 $\\tau$ 的奇异值 $\\sigma_i$ 被视为零，以滤除由病态条件产生的数值噪声。容差是相对于最大奇异值 $\\sigma_{\\max}$ 定义的，以适应矩阵的尺度：\n$$\\tau = \\epsilon\\,\\sigma_{\\max}\\,N_\\lambda$$\n其中 $\\epsilon$ 是双精度浮点数的机器精度。如果 $\\sigma_i \\ge \\tau$，则 $\\Sigma^+$ 的对角元设为 $\\sigma_i^{-1}$，否则设为 0。\n(e) **取消缩放**：计算缩放矩阵的伪逆 $A_s^+(E) = V \\Sigma^+ U^\\dagger$。然后将其取消缩放，以获得原始能级矩阵的稳定化伪逆：\n$$A^+(E) = S(E)\\,A_s^+(E)\\,S(E)$$\n\n**5. 基于 SVD 的碰撞矩阵**\n使用这个稳定化的伪逆 $A^+(E)$，以与朴素情况类似的方式计算相应的 R 矩阵和碰撞矩阵：\n$$R_{\\text{svd}}(E) = \\gamma^T A^+(E) \\gamma$$\n$$U_{\\text{svd}}(E) = I - 2 i\\,P(E)^{1/2}\\,R_{\\text{svd}}(E)\\,P(E)^{1/2}$$\n\n**6. 数值诊断**\n为了比较这两种方法，为每个测试用例计算五个诊断指标：\n- **条件数**：$\\kappa(A)$ 和 $\\kappa(A_s)$，通过各自矩阵的 SVD 计算为比率 $\\sigma_{\\max}/\\sigma_{\\min}$。如果 $\\sigma_{\\min}$ 在数值上与零无法区分，则赋值为 $10^{18}$，表示矩阵是奇异的或极端病态的。\n- **幺正性偏差**：$U$ 与幺正矩阵的偏差通过弗罗贝尼乌斯范数 $\\|U^\\dagger U - I\\|_F$ 对 $U_{\\text{naive}}$ 和 $U_{\\text{svd}}$ 进行量化。对于一个完备的模型空间，$U$ 应该是幺正的；偏离此性质凸显了数值误差。\n- **方法差异**：差异的弗罗贝尼乌斯范数 $\\|U_{\\text{naive}} - U_{\\text{svd}}\\|_F$ 衡量稳定化过程在多大程度上改变了最终的物理可观测量。一个大的差异表明朴素方法正在产生不可靠的结果。\n\n该算法被应用于五个测试用例中的每一个，并且为每个用例收集到的一组五个诊断值被格式化为所需的输出结构。", "answer": "```python\nimport numpy as np\n\n# A meticulous and exacting professor in the STEM fields.\n\ndef solve():\n    \"\"\"\n    Main function to run the R-matrix calculations for all test cases.\n    \"\"\"\n    # Global constants for the calculation\n    HBARC = 197.3269804  # MeV*fm\n    MACHINE_EPSILON = np.finfo(np.float64).eps\n    ILL_COND_THRESHOLD = 1e-18  # Threshold to declare a matrix singular for condition number\n\n    # Default parameters as specified in the problem\n    DEFAULT_E_LAMBDA = np.array([0.30, 1.10, 2.00])\n    DEFAULT_MU_C = np.array([469.0, 931.5])  # in MeV\n    DEFAULT_A_C = np.array([5.0, 5.5])  # in fm\n    DEFAULT_B_C = np.array([0.0, 0.0])\n    DEFAULT_GAMMA = np.array([\n        [0.050, 0.030],\n        [0.020, 0.040],\n        [0.010, 0.025]\n    ])  # in sqrt(MeV)\n\n    def calculate_diagnostics(E, E_lambda, mu_c, a_c, B_c, gamma):\n        \"\"\"\n        Performs the R-matrix calculations for a given set of parameters.\n        \"\"\"\n        N_lambda = len(E_lambda)\n        N_c = len(mu_c)\n\n        if E  0:\n            raise ValueError(\"Energy E must be non-negative.\")\n        \n        # Step A: Calculate channel-dependent quantities\n        k_c = np.sqrt(2 * mu_c * E) / HBARC\n        P_c = k_c * a_c\n        L_c = 1j * P_c  # S_c(E) = 0 for simplified hard-sphere channels\n\n        # Step B: Construct the level matrix A(E)\n        A = np.diag(E_lambda - E).astype(np.complex128)\n        for c in range(N_c):\n            gamma_c = gamma[:, c:c+1]\n            A -= (gamma_c @ gamma_c.T) * (L_c[c] - B_c[c])\n\n        # Step C: Compute diagnostics for A(E)\n        s_A = np.linalg.svd(A, compute_uv=False)\n        sigma_max_A = np.max(s_A) if s_A.size > 0 else 0\n        sigma_min_A = np.min(s_A) if s_A.size > 0 else 0\n        \n        if sigma_min_A  ILL_COND_THRESHOLD:\n            kappa_A = 1e18\n        else:\n            kappa_A = sigma_max_A / sigma_min_A\n\n        # Step D: Naive inversion and collision matrix\n        try:\n            A_inv_naive = np.linalg.inv(A)\n            R_naive = gamma.T @ A_inv_naive @ gamma\n            P_sqrt_mat = np.diag(np.sqrt(P_c))\n            U_naive = np.eye(N_c, dtype=np.complex128) - 2j * (P_sqrt_mat @ R_naive @ P_sqrt_mat)\n            unitarity_naive = np.linalg.norm(U_naive.conj().T @ U_naive - np.eye(N_c), 'fro')\n        except np.linalg.LinAlgError:\n            U_naive = np.full((N_c, N_c), np.nan, dtype=np.complex128)\n            unitarity_naive = np.inf\n\n        # Step E: Scaled SVD pseudoinverse\n        # (a) Define scaling matrix S\n        s_lambda = np.zeros(N_lambda)\n        for l_idx in range(N_lambda):\n            term1_sq = (E_lambda[l_idx] - E)**2\n            term2 = sum(gamma[l_idx, c_idx]**2 * (B_c[c_idx]**2 + P_c[c_idx]**2) for c_idx in range(N_c))\n            s_lambda[l_idx] = 1.0 / np.sqrt(term1_sq + term2)\n        S_mat = np.diag(s_lambda)\n        \n        # (b) Form scaled matrix A_s\n        A_s = S_mat @ A @ S_mat\n        \n        # (c) Compute SVD of A_s and its condition number\n        U_s, s_s, Vh_s = np.linalg.svd(A_s)\n        sigma_max_As = np.max(s_s) if s_s.size > 0 else 0\n        sigma_min_As = np.min(s_s) if s_s.size > 0 else 0\n        \n        if sigma_min_As  ILL_COND_THRESHOLD:\n            kappa_As = 1e18\n        else:\n            kappa_As = sigma_max_As / sigma_min_As\n\n        # (d) Form truncated pseudoinverse of singular values\n        tau = MACHINE_EPSILON * sigma_max_As * N_lambda\n        s_plus_diag_vals = np.array([1/s if s >= tau else 0 for s in s_s])\n        Sigma_plus = np.diag(s_plus_diag_vals)\n\n        # (e) Compute pseudoinverse A_plus\n        As_plus = Vh_s.conj().T @ Sigma_plus @ U_s.conj().T\n        A_plus = S_mat @ As_plus @ S_mat\n\n        # Step F: Calculate R_svd and U_svd\n        R_svd = gamma.T @ A_plus @ gamma\n        P_sqrt_mat = np.diag(np.sqrt(P_c))\n        U_svd = np.eye(N_c, dtype=np.complex128) - 2j * (P_sqrt_mat @ R_svd @ P_sqrt_mat)\n\n        # Step G: Compute final diagnostics\n        unitarity_svd = np.linalg.norm(U_svd.conj().T @ U_svd - np.eye(N_c), 'fro')\n        diff_U = np.linalg.norm(U_naive - U_svd, 'fro') if not np.any(np.isnan(U_naive)) else np.inf\n\n        return [kappa_A, kappa_As, unitarity_naive, unitarity_svd, diff_U]\n\n    test_cases = [\n        # Case 1: E on a resonance, default params\n        {'E': 1.10, 'B_c': DEFAULT_B_C, 'gamma': DEFAULT_GAMMA},\n        # Case 2: Near threshold, default params\n        {'E': 0.001, 'B_c': DEFAULT_B_C, 'gamma': DEFAULT_GAMMA},\n        # Case 3: E on another resonance, default params\n        {'E': 2.00, 'B_c': DEFAULT_B_C, 'gamma': DEFAULT_GAMMA},\n        # Case 4: Non-zero boundary conditions\n        {'E': 1.10, 'B_c': np.array([0.30, -0.20]), 'gamma': DEFAULT_GAMMA},\n        # Case 5: Ill-conditioned widths\n        {'E': 1.10, 'B_c': DEFAULT_B_C, 'gamma': np.array([\n            [0.0001, 0.0001],\n            [0.2000, 0.2500],\n            [0.0001, 0.0001]\n        ])}\n    ]\n\n    results = []\n    for case in test_cases:\n        res = calculate_diagnostics(\n            case['E'],\n            DEFAULT_E_LAMBDA,\n            DEFAULT_MU_C,\n            DEFAULT_A_C,\n            case['B_c'],\n            case['gamma']\n        )\n        results.append(res)\n    \n    # Format the final output string exactly as specified, without spaces\n    print(str(results).replace(' ', ''))\n\nsolve()\n```", "id": "3585517"}, {"introduction": "在我们掌握了如何稳定地求解能级矩阵的逆之后，下一个挑战是如何高效地完成这一任务，特别是在需要对大量能级或能量点进行计算时。这个练习将深入探讨能级矩阵的数学结构，利用其耦合项的低秩特性来推导并实现一种更快速的求逆算法。这种基于矩阵恒等式的优化技术对于大规模核数据评估中的R矩阵代码至关重要 [@problem_id:3585560]。", "problem": "考虑核反应R矩阵理论的一个多能级、少通道的公式，其中能级矩阵依赖于能量 $E$ 和耦合向量。在 Wigner–Eisenbud 形式理论中，当选择的通道边界条件使得边界常数等于移动函数时，能级矩阵可以写作\n$$\nA(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T},\n$$\n其中 $D(E)$ 是一个大小为 $N \\times N$ 的对角矩阵，其元素为 $d_\\lambda(E) = E_\\lambda - E$（对于每个能级指标 $\\lambda = 1,\\dots,N$），$U$ 是一个 $N \\times C$ 矩阵，其列是对应于通道指标 $c = 1,\\dots,C$ 的能级到通道的约化宽度振幅向量 $\\gamma_c$，$W(E)$ 是一个对角的 $C \\times C$ 矩阵，其元素为 $w_c(E) = i\\,P_c(E)$，其中 $i$ 是虚数单位，$P_c(E)$ 是通道 $c$ 在能量 $E$ 处的穿透因子。这种结构反映了耦合项的低秩特性，因为即使在 $N \\gg C$ 的情况下，$U\\,W(E)\\,U^{\\mathsf T}$ 的秩最多为 $C$。\n\n对于单通道中性s波的情况，穿透因子可以建模为 $P(E) = k(E)\\,a$，其中 $k(E) = \\sqrt{2\\,\\mu\\,E}/\\hbar$ 是波数，$\\mu$ 是约化质量，$a$ 是通道半径，$\\hbar$ 是约化普朗克常数。使用计算核物理的常规单位，取 $\\hbar c = 197.3269804$ MeV·fm，这样就可以从以兆电子伏特 (MeV) 为单位的 $E$、以 MeV$/c^2$ 为单位的 $\\mu$ 和以飞米 (fm) 为单位的 $a$ 计算出 $k(E)$，从而得到一个无量纲的穿透因子 $P(E)$。对于多通道情况，为每个通道定义一个独特的 $P_c(E) = k_c(E)\\,a_c$，并具有相应的 $\\mu_c$ 和 $a_c$。\n\n通道-通道R矩阵定义为\n$$\nR(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U,\n$$\n它是一个 $C \\times C$ 的复对称矩阵。当边界常数等于移动函数（因此实色散位移被吸收），碰撞矩阵（也称为散射矩阵）简化为\n$$\nU(E) = I_C - 2i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2},\n$$\n其中 $I_C$ 是 $C \\times C$ 的单位矩阵，$P(E)^{1/2}$ 是对角元素为 $\\sqrt{P_c(E)}$ 的对角矩阵。在理想数学模型中，这个 $U(E)$ 是幺正的。\n\n你的任务是设计并实现一个程序，对于一组指定的能级能量 $E_\\lambda$、$U$ 中的约化宽度振幅和通道参数 $(\\mu_c, a_c)$，使用两种对 $A(E)$ 的求逆策略，计算在一系列能量点上的 $U(E)$：\n- 对 $A(E)$ 进行直接稠密矩阵求逆。\n- 一种求逆更新方法，该方法从 $D(E)$ 出发，利用 $U\\,W(E)\\,U^{\\mathsf T}$ 的低秩结构，并应用一个基本的矩阵恒等式来避免对整个 $N \\times N$ 矩阵求逆。\n\n你必须：\n1. 从基础线性代数和R矩阵的定义出发，推导、实现并使用对角矩阵的低秩修正所对应的、有数学保证的高效求逆更新方法，而不依赖任何预先给出的快捷公式。\n2. 对每个能量点，使用两种求逆方法计算碰撞矩阵 $U(E)$，并通过计算两个 $U(E)$ 矩阵之间逐元素绝对差的最大值来量化数值误差。\n3. 将每个测试案例的误差汇总为指定能量集合上的最大误差。\n4. 所有能量以兆电子伏特 (MeV) 表示，质量以兆电子伏特每光速平方 (MeV$/c^2$) 表示，半径以飞米 (fm) 表示，并以无量纲浮点数报告最终误差。\n5. 通过避免使 $D(E)$ 的任何对角元素恰好为零的能量值来确保数值稳定性。\n\n测试套件与参数：\n- 案例1（单通道，离共振区和近共振区，中性s波）：\n  - 能级：$N=3$，能量为 $E_\\lambda = [0.2,\\,1.0,\\,3.0]$ MeV。\n  - 约化质量：$\\mu = 469.5$ MeV$/c^2$。\n  - 通道半径：$a = 5.0$ fm。\n  - 约化宽度振幅：$\\gamma = [0.06,\\,0.02,\\,0.01]$，单位为 $\\sqrt{\\text{MeV}}$。\n  - 能量：$E = [0.05,\\,0.1999,\\,0.5,\\,1.0]$ MeV。\n- 案例2（单通道，近阈值）：\n  - 能级：$N=5$，能量为 $E_\\lambda = [0.01,\\,0.5,\\,1.5,\\,2.5,\\,4.0]$ MeV。\n  - 约化质量：$\\mu = 469.5$ MeV$/c^2$。\n  - 通道半径：$a = 5.0$ fm。\n  - 约化宽度振幅：$\\gamma = [0.03,\\,0.015,\\,0.008,\\,0.004,\\,0.002]$，单位为 $\\sqrt{\\text{MeV}}$。\n  - 能量：$E = [10^{-6},\\,10^{-4},\\,10^{-2}]$ MeV。\n- 案例3（双通道，多能级）：\n  - 能级：$N=4$，能量为 $E_\\lambda = [0.4,\\,0.8,\\,1.6,\\,2.8]$ MeV。\n  - 通道1：$\\mu_1 = 469.5$ MeV$/c^2$，$a_1 = 4.5$ fm，约化宽度振幅 $\\gamma_1 = [0.05,\\,0.02,\\,0.03,\\,0.01]$，单位为 $\\sqrt{\\text{MeV}}$。\n  - 通道2：$\\mu_2 = 300.0$ MeV$/c^2$，$a_2 = 6.0$ fm，约化宽度振幅 $\\gamma_2 = [0.04,\\,0.015,\\,0.02,\\,0.008]$，单位为 $\\sqrt{\\text{MeV}}$。\n  - 能量：$E = [0.3,\\,0.8,\\,1.6,\\,2.5]$ MeV。\n- 案例4（单通道，近共振区的病态条件）：\n  - 能级：$N=3$，能量为 $E_\\lambda = [1.0000,\\,1.5000,\\,2.0000]$ MeV。\n  - 约化质量：$\\mu = 469.5$ MeV$/c^2$。\n  - 通道半径：$a = 5.0$ fm。\n  - 约化宽度振幅：$\\gamma = [0.10,\\,0.05,\\,0.02]$，单位为 $\\sqrt{\\text{MeV}}$。\n  - 能量：$E = [0.9999,\\,1.0001,\\,1.2]$ MeV。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中每个 $r_j$ 是第 $j$ 个案例中，在所有能量点上计算出的两个碰撞矩阵 $U(E)$ 之间逐元素绝对差的最大值，以无量綱浮点数形式报告。", "solution": "该问题要求使用两种不同的计算策略对能级矩阵 $A(E)$ 求逆，从而计算核碰撞矩阵 $U(E)$。这两种方法（直接求逆和高效的低秩更新）的结果将被比较，以量化数值误差。其理论基础是核反应的R矩阵理论。\n\n### 理论框架\n\n该问题基于R矩阵理论的 Wigner–Eisenbud 公式。关键量定义如下：\n\n1.  **能级矩阵, $A(E)$**: 一个 $N \\times N$ 的复数矩阵，其中 $N$ 是所包含的共振能级的数量。\n    $$A(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T}$$\n    -   $D(E)$ 是一个对角矩阵，其元素为 $d_\\lambda(E) = E_\\lambda - E$，其中 $E_\\lambda$ 是能级能量，$E$ 是散射能量。\n    -   $U$ 是一个 $N \\times C$ 的实数矩阵，其列是 $C$ 个反应通道中每个通道的约化宽度振幅向量 $\\gamma_c$。元素 $U_{\\lambda c}$ 对应于振幅 $\\gamma_{\\lambda c}$。\n    -   $W(E)$ 是一个 $C \\times C$ 的对角矩阵，其元素为 $w_c(E) = i\\,P_c(E)$，其中 $i$ 是虚数单位，$P_c(E)$ 是通道 $c$ 的穿透因子。\n\n2.  **穿透因子, $P_c(E)$**: 对于 $s$ 波 ($l=0$) 通道中的中性粒子，该因子由 $P_c(E) = k_c(E)\\,a_c$ 给出。\n    -   $k_c(E)$ 是波数， $k_c(E) = \\sqrt{2\\mu_c E}/\\hbar$。使用提供的常数 $\\hbar c = 197.3269804 \\text{ MeV}\\cdot\\text{fm}$，并将约化质量 $\\mu_c$ 表示为 $\\text{MeV}/c^2$、能量 $E$ 表示为 MeV，则以 $\\text{fm}^{-1}$ 为单位的波数是：\n        $$k_c(E) = \\frac{\\sqrt{2(\\mu_c c^2)E}}{\\hbar c}$$\n    -   $a_c$ 是以 fm 为单位的通道半径，这使得 $P_c(E)$ 成为一个无量纲的量。\n\n3.  **R矩阵, $R(E)$**: 一个 $C \\times C$ 的复对称矩阵，它将内部区域边界上的波函数值与其导数联系起来。它通过能级矩阵的逆来计算：\n    $$R(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U$$\n\n4.  **碰撞矩阵, $U(E)$**: 一个 $C \\times C$ 的幺正矩阵，其元素 $U_{cc'}(E)$关联了入射和出射波的振幅。在指定的边界条件下，它由以下公式给出：\n    $$U(E) = I_C - 2i\\,P(E)^{1/2}\\,R(E)\\,P(E)^{1/2}$$\n    -   $I_C$ 是 $C \\times C$ 的单位矩阵。\n    -   $P(E)^{1/2}$ 是对角元素为 $\\sqrt{P_c(E)}$ 的对角矩阵。由于 $E > 0$ 且 $\\mu_c > 0$，$P_c(E)$ 是实数且非负，因此其平方根是良定义且为实数。\n\n### $A(E)^{-1}$ 的计算方法\n\n核心任务是计算 $R(E)$，这需要 $A(E)$ 的逆。我们将实现两种方法。\n\n**方法1：直接稠密矩阵求逆**\n\n这是最直接的方法。对于给定的能量 $E$：\n1.  构建 $N \\times N$ 对角矩阵 $D(E)$。\n2.  构建 $N \\times C$ 矩阵 $U$ 和 $C \\times C$ 对角矩阵 $W(E)$。\n3.  计算完整的 $N \\times N$ 矩阵 $A(E) = D(E) + U\\,W(E)\\,U^{\\mathsf T}$。\n4.  使用标准的数值线性代数程序对 $A(E)$ 求逆，得到 $A(E)^{-1}$。\n5.  计算R矩阵：$R_{\\text{direct}}(E) = U^{\\mathsf T}\\,A(E)^{-1}\\,U$。\n\n对于大的 $N$，这种方法的计算成本很高，矩阵求逆步骤的时间复杂度通常为 $\\mathcal{O}(N^3)$。如果 $A(E)$ 是病态的（这可能在共振能量 $E_\\lambda$ 附近发生），它也可能遭受数值不稳定性的影响。\n\n**方法2：低秩更新求逆**\n\n该方法利用了这样一个事实：$U\\,W(E)\\,U^{\\mathsf T}$ 项是对简单对角矩阵 $D(E)$ 的一个低秩更新。该更新的秩最多为 $C$（通道数），而 $C$ 通常远小于 $N$。我们可以推导出一种更高效的 $R(E)$ 表达式，而无需显式构造或求逆完整的 $N \\times N$ 矩阵 $A(E)$。推导过程如下，从 $R(E)$ 的定义和 $A(E)$ 的逆开始：\n\n令 $x$ 是一个定义为 $x = A(E)^{-1}U$ 的 $N \\times C$ 矩阵。根据定义，R矩阵为 $R(E) = U^{\\mathsf T}x$。\n我们可以通过乘以 $A(E)$ 来写出 $x$ 的方程：\n$$A(E)x = U$$\n代入 $A(E)$ 的表达式：\n$$(D(E) + U\\,W(E)\\,U^{\\mathsf T})x = U$$\n展开左侧：\n$$D(E)x + U\\,W(E)\\,(U^{\\mathsf T}x) = U$$\n注意到括号中的项 $U^{\\mathsf T}x$ 就是R矩阵 $R(E)$：\n$$D(E)x + U\\,W(E)\\,R(E) = U$$\n由于 $D(E)$ 是对角矩阵，其逆矩阵 $D(E)^{-1}$ 也是一个对角矩阵，元素为 $1/(E_\\lambda - E)$，只要对所有 $\\lambda$ 都有 $E \\neq E_\\lambda$，计算就非常简单。我们可以解出 $x$：\n$$D(E)x = U - U\\,W(E)\\,R(E) = U(I_C - W(E)\\,R(E))$$\n$$x = D(E)^{-1}\\,U\\,(I_C - W(E)\\,R(E))$$\n现在，将这个 $x$ 的表达式代回到R矩阵的定义 $R(E) = U^{\\mathsf T}x$ 中：\n$$R(E) = U^{\\mathsf T}\\,[D(E)^{-1}\\,U\\,(I_C - W(E)\\,R(E))]$$\n$$R(E) = (U^{\\mathsf T}D(E)^{-1}U)\\,(I_C - W(E)\\,R(E))$$\n让我们定义 $C \\times C$ 矩阵 $Z(E) = U^{\\mathsf T}D(E)^{-1}U$。这个矩阵是高效方法的核心。其元素由 $Z_{cd}(E) = \\sum_{\\lambda=1}^N \\frac{\\gamma_{\\lambda c} \\gamma_{\\lambda d}}{E_\\lambda - E}$ 给出。方程变为：\n$$R(E) = Z(E)\\,(I_C - W(E)\\,R(E)) = Z(E) - Z(E)\\,W(E)\\,R(E)$$\n我们现在可以用代数方法解出 $R(E)$：\n$$R(E) + Z(E)\\,W(E)\\,R(E) = Z(E)$$\n$$(I_C + Z(E)\\,W(E))\\,R(E) = Z(E)$$\n最后，假如矩阵 $(I_C + Z(E)W(E))$ 是可逆的，我们得到R矩阵的表达式：\n$$R_{\\text{update}}(E) = (I_C + Z(E)\\,W(E))^{-1} \\, Z(E)$$\n这个推导满足了从第一性原理出发的要求。其计算优势是巨大的：最昂贵的步骤是求一个 $C \\times C$ 矩阵的逆，其时间复杂度为 $\\mathcal O(C^3)$。由于在许多实际应用中 $C \\ll N$，这比直接方法的 $\\mathcal O(N^3)$ 复杂度要高效得多。\n\n### 实现与误差分析\n\n用于比较的算法如下。对于每个测试案例：\n1.  为该案例初始化一个最大误差，$\\epsilon_{\\text{max}} = 0$。\n2.  遍历每个指定的散射能量 $E$。\n3.  在每个 $E$ 点，使用 $R(E)$ 的直接求逆方法计算碰撞矩阵 $U_{\\text{direct}}(E)$。\n4.  在相同的 $E$ 点，使用 $R(E)$ 的低秩更新方法计算 $U_{\\text{update}}(E)$。\n5.  计算逐元素绝对差矩阵 $\\Delta U(E) = |U_{\\text{direct}}(E) - U_{\\text{update}}(E)|$。\n6.  找到该差分矩阵中的最大元素 $\\epsilon(E) = \\max_{ij} \\Delta U_{ij}(E)$。\n7.  更新案例的最大误差：$\\epsilon_{\\text{max}} = \\max(\\epsilon_{\\text{max}}, \\epsilon(E))$。\n8.  遍历完所有能量后，该测试案例的最终结果是 $\\epsilon_{\\text{max}}$。\n\n这个过程将对所有四个测试案例执行，并报告由此产生的最大误差。此比较既可作为对所推导的低秩更新公式的验证，也凸显了两种数学上等价的路径之间潜在的数值精度差异。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the R-matrix problem for four test cases, comparing direct and \n    low-rank update inversion methods for the collision matrix.\n    \"\"\"\n    HBAR_C = 197.3269804  # MeV·fm\n\n    def get_P_matrices(E, mu_vec, a_vec):\n        \"\"\"Calculates the diagonal P(E) and P(E)^(1/2) matrices.\"\"\"\n        C = len(mu_vec)\n        p_diag = np.zeros(C, dtype=np.float64)\n        for c in range(C):\n            # E can be zero or very close to it, sqrt will be handled correctly.\n            # The calculation is valid for E >= 0.\n            if E >= 0:\n                k_c = np.sqrt(2 * mu_vec[c] * E) / HBAR_C\n                p_diag[c] = k_c * a_vec[c]\n        \n        P_matrix = np.diag(p_diag)\n        P_sqrt_matrix = np.diag(np.sqrt(p_diag))\n        return P_matrix, P_sqrt_matrix\n\n    def calculate_U_direct(E, E_levels, U_mat, mu_vec, a_vec):\n        \"\"\"Computes the collision matrix U(E) using direct inversion.\"\"\"\n        N, C = U_mat.shape\n        I_C = np.identity(C, dtype=np.complex128)\n        \n        # Diagonal matrix D(E)\n        d_diag = E_levels - E\n        D_matrix = np.diag(d_diag)\n\n        # Diagonal matrix W(E)\n        P_matrix, P_sqrt_matrix = get_P_matrices(E, mu_vec, a_vec)\n        W_matrix = 1j * P_matrix\n        \n        # Level matrix A(E)\n        A_matrix = D_matrix.astype(np.complex128) + U_mat @ W_matrix @ U_mat.T\n        \n        # R-matrix R(E)\n        try:\n            A_inv = np.linalg.inv(A_matrix)\n        except np.linalg.LinAlgError:\n            # This should not happen with the given test cases, but is good practice.\n            return np.full((C, C), np.nan, dtype=np.complex128)\n            \n        R_matrix = U_mat.T @ A_inv @ U_mat\n        \n        # Collision matrix U(E)\n        U_collision_matrix = I_C - 2j * P_sqrt_matrix @ R_matrix @ P_sqrt_matrix\n        \n        return U_collision_matrix\n\n    def calculate_U_update(E, E_levels, U_mat, mu_vec, a_vec):\n        \"\"\"Computes the collision matrix U(E) using the low-rank update method.\"\"\"\n        N, C = U_mat.shape\n        I_C = np.identity(C, dtype=np.complex128)\n\n        # Inverse of D(E)\n        d_inv_diag = 1.0 / (E_levels - E)\n        D_inv_matrix = np.diag(d_inv_diag)\n        \n        # Z(E) matrix\n        Z_matrix = U_mat.T @ D_inv_matrix.astype(np.complex128) @ U_mat\n        \n        # W(E) matrix and P_sqrt\n        P_matrix, P_sqrt_matrix = get_P_matrices(E, mu_vec, a_vec)\n        W_matrix = 1j * P_matrix\n        \n        # R-matrix R(E) using the derived formula\n        M_matrix = I_C + Z_matrix @ W_matrix\n        \n        try:\n            M_inv = np.linalg.inv(M_matrix)\n        except np.linalg.LinAlgError:\n            return np.full((C, C), np.nan, dtype=np.complex128)\n            \n        R_matrix = M_inv @ Z_matrix\n        \n        # Collision matrix U(E)\n        U_collision_matrix = I_C - 2j * P_sqrt_matrix @ R_matrix @ P_sqrt_matrix\n        \n        return U_collision_matrix\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        { # Case 1\n            \"E_levels\": np.array([0.2, 1.0, 3.0]),\n            \"U_mat\": np.array([[0.06], [0.02], [0.01]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([0.05, 0.1999, 0.5, 1.0])\n        },\n        { # Case 2\n            \"E_levels\": np.array([0.01, 0.5, 1.5, 2.5, 4.0]),\n            \"U_mat\": np.array([[0.03], [0.015], [0.008], [0.004], [0.002]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([1e-6, 1e-4, 1e-2])\n        },\n        { # Case 3\n            \"E_levels\": np.array([0.4, 0.8, 1.6, 2.8]),\n            \"U_mat\": np.array([\n                [0.05, 0.04], [0.02, 0.015], [0.03, 0.02], [0.01, 0.008]\n            ]),\n            \"mu_vec\": np.array([469.5, 300.0]),\n            \"a_vec\": np.array([4.5, 6.0]),\n            \"energies\": np.array([0.3, 0.8, 1.6, 2.5])\n        },\n        { # Case 4\n            \"E_levels\": np.array([1.0, 1.5, 2.0]),\n            \"U_mat\": np.array([[0.10], [0.05], [0.02]]),\n            \"mu_vec\": np.array([469.5]),\n            \"a_vec\": np.array([5.0]),\n            \"energies\": np.array([0.9999, 1.0001, 1.2])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_case_error = 0.0\n        for E in case[\"energies\"]:\n            U_direct = calculate_U_direct(E, case[\"E_levels\"], case[\"U_mat\"], case[\"mu_vec\"], case[\"a_vec\"])\n            U_update = calculate_U_update(E, case[\"E_levels\"], case[\"U_mat\"], case[\"mu_vec\"], case[\"a_vec\"])\n\n            # Quantify numerical error\n            error_E = np.max(np.abs(U_direct - U_update))\n            if error_E > max_case_error:\n                max_case_error = error_E\n        \n        results.append(max_case_error)\n\n    # Format output as specified\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3585560"}]}