{"hands_on_practices": [{"introduction": "在我们能够计算任何复合核反应截面之前，我们必须首先确定其关键输入：透射系数 $T_{c\\ell j}^{J\\pi}(E)$。这些系数从量子散射理论中导出，量化了粒子进入或离开复合核的概率。本练习将引导你基于一个物理上合理的参数化模型，从头开始实现一个高效且数值稳定的计算核心，用于计算透射系数，这是构建任何大规模 Hauser-Feshbach 计算代码的基础步骤 [@problem_id:3602112]。", "problem": "您的任务是设计并实现一个高效的计算核心，用于在Hauser-Feshbach复合核反应理论的背景下评估道传输系数 $T_{c\\ell j}^{J\\pi}(E)$。重点在于设计数据结构和缓存策略，以便在保证可复现性和数值稳定性的同时，能够对多个能量和道进行快速评估。该实现必须遵循散射理论的第一性原理推导。所有能量必须以兆电子伏特（MeV）表示，所有角度必须以弧度表示，所有长度必须以飞米（fm）表示。\n\n请从以下适用于Hauser-Feshbach理论的、公认的量子散射和复合核形成基础出发：\n\n- 对于一个道 $c$、分波 $\\ell$、总角动量 $j$ 和复合核自旋宇称 $J\\pi$ 的单道分波散射矩阵元可以写为 $S_{c\\ell j}^{J\\pi}(E) = \\eta_{c\\ell j}^{J\\pi}(E) \\exp\\left(2 i \\delta_{c\\ell j}^{J\\pi}(E)\\right)$，其中 $0 \\le \\eta_{c\\ell j}^{J\\pi}(E) \\le 1$ 是一个吸收（非弹性）因子，$\\delta_{c\\ell j}^{J\\pi}(E)$ 是一个实散射相移。这在复合核形成假设下，与S矩阵的幺正性和时间反演对称性是一致的。\n\n- 弹靶体系的约化波数为 $k(E) = \\sqrt{2 \\mu E}/(\\hbar c)$，其中 $\\mu$ 是以 $\\mathrm{MeV}/c^2$ 为单位的约化质量，$E$ 是以 $\\mathrm{MeV}$ 为单位的质心系能量，$\\hbar c$ 是常数 $\\hbar c = 197.3269804\\,\\mathrm{MeV\\,fm}$。\n\n您的目标是：\n\n1. 从上述基础和S矩阵幺正性出发，推导传输系数 $T_{c\\ell j}^{J\\pi}(E)$ 关于 $S_{c\\ell j}^{J\\pi}(E)$ 的表达式。\n\n2. 为了进行计算评估，请对 $\\eta_{c\\ell j}^{J\\pi}(E)$ 和 $\\delta_{c\\ell j}^{J\\pi}(E)$ 采用以下参数化的、物理上合理的模型假设，这些假设编码了吸收强度、离心势垒抑制和平滑的相演化：\n   - $\\eta_{c\\ell j}^{J\\pi}(E) = \\exp\\left(-\\alpha_c\\, f_\\ell(E)\\right)$,\n   - $f_\\ell(E) = \\dfrac{E}{E + E_{0,c}} \\cdot g_\\ell(E)$,\n   - $g_\\ell(E) = \\dfrac{1}{1 + \\dfrac{(\\ell + 1/2)^2}{\\left(k(E) R_c\\right)^2}}$,\n   - $\\delta_{c\\ell j}^{J\\pi}(E) = \\arctan\\left(\\dfrac{\\beta_c \\, k(E) R_c}{1 + \\left(k(E) R_c\\right)^2}\\right)$.\n   在此，$\\alpha_c$, $E_{0,c}$, $R_c$, $\\beta_c$, 和 $\\mu_c$ 是依赖于道的参数，满足 $\\alpha_c  0$, $E_{0,c}  0$, $R_c  0$, 和 $\\beta_c \\ge 0$，且 $\\mu_c$ 是以 $\\mathrm{MeV}/c^2$ 为单位的约化质量。\n\n3. 设计数据结构以明确表示道并高效缓存评估结果。您的设计必须：\n   - 使用一个包含 $c$, $\\ell$, $j$, $J$, 和 $\\pi$ 的规范化、可哈希的道密钥。\n   - 在每个道的能量网格上预计算并存储 $\\eta_{c\\ell j}^{J\\pi}(E)$ 的平滑插值函数，以支持在测试范围内对任意能量的快速查询。\n   - 为相同或数值上相近的能量的重复评估实现记忆化（memoization）；定义一个量化方案，将实数能量 $E$ 映射到一个缓存键 $E_q$，容差为 $q_E = 10^{-6}\\,\\mathrm{MeV}$，以确保可复现性并避免浮点漂移。\n\n4. 确保 $T_{c\\ell j}^{J\\pi}(E)$ 计算的数值稳定性，尤其是在 $E$ 很小时，要避免灾难性抵消。实现中应使用适合于处理接近于零的差值表达式的数值稳定变换。\n\n5. 实现程序以评估 $T_{c\\ell j}^{J\\pi}(E)$，使用以下测试套件。所有能量单位均为 MeV：\n\n   道参数集（每个参数均使用上述单位指定）：\n   - 道 $\\mathsf{A}$：$c=\\text{\"n+}^{56}\\text{Fe\"}$，$\\ell=0$，$j=1/2$，$J=1/2$，$\\pi=+1$，$\\alpha_c=0.9$，$E_{0,c}=1.5$，$R_c=5.0\\,\\mathrm{fm}$，$\\beta_c=0.2$，$\\mu_c=469.5\\,\\mathrm{MeV}/c^2$。\n   - 道 $\\mathsf{B}$：$c=\\text{\"n+}^{56}\\text{Fe\"}$，$\\ell=5$，$j=11/2$，$J=3/2$，$\\pi=+1$，$\\alpha_c=0.4$，$E_{0,c}=3.0$，$R_c=5.0\\,\\mathrm{fm}$，$\\beta_c=0.1$，$\\mu_c=469.5\\,\\mathrm{MeV}/c^2$。\n   - 道 $\\mathsf{C}$：$c=\\text{\"n+}^{90}\\text{Zr\"}$，$\\ell=2$，$j=5/2$，$J=1/2$，$\\pi=-1$，$\\alpha_c=0.7$，$E_{0,c}=2.0$，$R_c=5.5\\,\\mathrm{fm}$，$\\beta_c=0.15$，$\\mu_c=469.5\\,\\mathrm{MeV}/c^2$。\n\n   能量集：\n   - 对于道 $\\mathsf{A}$，在 $E \\in \\{0.01, 0.5, 5.0, 15.0\\}$ 处进行评估。\n   - 对于道 $\\mathsf{B}$，在 $E \\in \\{0.01, 0.5, 5.0, 30.0\\}$ 处进行评估。\n   - 对于道 $\\mathsf{C}$，在 $E \\in \\{0.0, 100.0\\}$ 处进行评估。\n   - 对于道 $\\mathsf{B}$，在密集网格 $E_m = 0.2 m$（其中 $m=0,1,\\dots,100$，即 $E \\in [0.0, 20.0]$，步长为 $0.2$）上进行评估。\n\n   针对此测试套件，计算以下四个结果：\n   - 结果 1：道 $\\mathsf{A}$ 在其能量集上 $T_{c\\ell j}^{J\\pi}(E)$ 的算术平均值。\n   - 结果 2：道 $\\mathsf{B}$ 在其能量集上 $T_{c\\ell j}^{J\\pi}(E)$ 的算术平均值。\n   - 结果 3：一个布尔值，说明道 $\\mathsf{C}$ 的 $T_{c\\ell j}^{J\\pi}(0.0)$ 在 $10^{-12}$ 的容差内是否等于零。\n   - 结果 4：一个布尔值，说明道 $\\mathsf{B}$ 的 $T_{c\\ell j}^{J\\pi}(E)$ 在密集网格上是否单调非递减，连续差值的容差为 $10^{-12}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4]$）。前两项必须是浮点数，后两项必须是布尔值。程序必须完全自包含、可复现，且不依赖任何用户输入或外部文件。", "solution": "此问题的分析和解决方案分为三个主要阶段：首先，从给定的散射矩阵形式推导传输系数；其次，详细设计计算核心，包括数据结构、缓存策略和数值稳定性考量；第三，将此核心应用于指定的测试套件。\n\n## 1. 传输系数的推导\n\n问题始于一个基本陈述，即在Hauser-Feshbach理论的假设下，单道分波散射矩阵元由下式给出：\n$$S_{c\\ell j}^{J\\pi}(E) = \\eta_{c\\ell j}^{J\\pi}(E) \\exp\\left(2 i \\delta_{c\\ell j}^{J\\pi}(E)\\right)$$\n在此，$\\eta_{c\\ell j}^{J\\pi}(E)$ 是实值非弹性因子，其中 $0 \\le \\eta \\le 1$，而 $\\delta_{c\\ell j}^{J\\pi}(E)$ 是实值散射相移。所提供的 $S$ 矩阵元形式在存在吸收的情况下与幺正性是一致的。\n\n传输系数 $T_{c\\ell j}^{J\\pi}(E)$ 代表了入射到道 $c$ 且具有量子数 $\\ell$ 和 $j$ 的粒子被复合核吸收，从而引发反应的概率。在散射理论中，总概率是守恒的。对于单位通量的入射波，出射通量被分配到弹性散射和所有其他过程（反应）之间。该分波的弹性散射概率由 $|S_{c\\ell j}^{J\\pi}(E)|^2$ 给出。因此，总反应概率，即传输系数的定义，是剩余的部分：\n$$T_{c\\ell j}^{J\\pi}(E) = 1 - |S_{c\\ell j}^{J\\pi}(E)|^2$$\n这种关系是完整 $S$ 矩阵幺正性的直接结果，它意味着对于任何与其他道（无论是其他散射道还是内部复合核态）耦合的开放道，都有 $|S_{c\\ell j}^{J\\pi}(E)| \\le 1$。\n\n为了找到 $T$ 的显式表达式，我们计算 $S$ 矩阵元的模平方：\n$$|S_{c\\ell j}^{J\\pi}(E)|^2 = \\left| \\eta_{c\\ell j}^{J\\pi}(E) \\exp\\left(2 i \\delta_{c\\ell j}^{J\\pi}(E)\\right) \\right|^2$$\n由于 $\\eta$ 和 $\\delta$ 都是实数，这可以简化为：\n$$|S_{c\\ell j}^{J\\pi}(E)|^2 = (\\eta_{c\\ell j}^{J\\pi}(E))^2 \\left| \\exp\\left(2 i \\delta_{c\\ell j}^{J\\pi}(E)\\right) \\right|^2$$\n项 $\\exp(2i\\delta)$ 是一个纯相位因子，因此其模为1。所以，\n$$|S_{c\\ell j}^{J\\pi}(E)|^2 = \\left(\\eta_{c\\ell j}^{J\\pi}(E)\\right)^2$$\n将此代入传输系数的表达式中，得到：\n$$T_{c\\ell j}^{J\\pi}(E) = 1 - \\left(\\eta_{c\\ell j}^{J\\pi}(E)\\right)^2$$\n提供的 $\\eta$ 的参数模型与 $j$、$J$ 和 $\\pi$ 无关，仅依赖于道类别 $c$（通过其参数 $\\alpha_c, E_{0,c}, R_c, \\mu_c$）和轨道角动量 $\\ell$。因此，为了本次计算，我们可以写作 $T_{c\\ell}(E)$。使用给定的形式 $\\eta_{c\\ell}(E) = \\exp\\left(-\\alpha_c\\, f_\\ell(E)\\right)$，我们得到传输系数的最终表达式：\n$$T_{c\\ell}(E) = 1 - \\left( \\exp\\left(-\\alpha_c\\, f_\\ell(E)\\right) \\right)^2 = 1 - \\exp\\left(-2\\alpha_c\\, f_\\ell(E)\\right)$$\n\n## 2. 计算核心设计\n\n任务的核心是基于所提供的物理模型，实现一个稳健且高效的函数来评估 $T_{c\\ell}(E)$。这涉及到仔细实现参数化函数，关注数值稳定性，以及使用缓存机制来避免重复计算。\n\n### 2.1. 模型评估\n\n评估 $T_{c\\ell}(E)$ 需要计算函数 $f_\\ell(E)$，而它又依赖于约化波数 $k(E)$ 和类穿透率函数 $g_\\ell(E)$。\n\n约化波数为 $k(E) = \\sqrt{2 \\mu_c E}/(\\hbar c)$。常数已给出为 $\\hbar c = 197.3269804\\,\\mathrm{MeV\\,fm}$。这个计算很直接，但对于 $E=0$，$k(0)=0$。\n\n函数 $g_\\ell(E)$ 定义为：\n$$g_\\ell(E) = \\dfrac{1}{1 + \\dfrac{(\\ell + 1/2)^2}{\\left(k(E) R_c\\right)^2}}$$\n直接实现此公式在 $k(E)=0$ 时（即 $E=0$ 时）容易出现除零错误。为确保数值稳定性，我们可以将表达式重写为：\n$$g_\\ell(E) = \\dfrac{\\left(k(E) R_c\\right)^2}{\\left(k(E) R_c\\right)^2 + (\\ell + 1/2)^2}$$\n这种形式在数学上是等价的，并且在 $E=0$ 时表现良好，能够正确地评估为 $0$。\n\n然后函数 $f_\\ell(E)$ 是 $f_\\ell(E) = \\dfrac{E}{E + E_{0,c}} \\cdot g_\\ell(E)$。在 $E=0$ 时，因子 $E/(E+E_{0,c})$ 为 $0$，且 $g_\\ell(0)=0$。因此，对于所有道和所有 $\\ell$，$f_\\ell(0)=0$。\n\n最后，传输系数为 $T_{c\\ell}(E) = 1 - \\exp\\left(-2\\alpha_c\\, f_\\ell(E)\\right)$。对于小能量 $E \\to 0$，我们有 $f_\\ell(E) \\to 0$。指数的参数 $-2\\alpha_c f_\\ell(E)$ 趋近于零。计算 $1 - e^{-x}$（其中 $x$ 很小）容易因两个非常接近 $1$ 的数相减而导致灾难性抵消。一个标准的、数值稳定的替代方法是使用 `expm1(y)` 函数，该函数能为较小的 $y$ 精确计算 $e^y-1$。我们可以将我们的表达式重写为：\n$$T_{c\\ell}(E) = - \\left( \\exp\\left(-2\\alpha_c\\, f_\\ell(E)\\right) - 1 \\right) = -\\mathrm{expm1}\\left(-2\\alpha_c\\, f_\\ell(E)\\right)$$\n在实现中将使用此公式，以在所有能量下保持精度。\n\n### 2.2. 数据结构与缓存\n\n为了满足高效和可复现评估的要求，我们设计一个类来封装计算过程。\n\n**道的表示：** 问题为三个不同的道指定了参数。一个字典将把规范的道标识符（例如，字符串名称）映射到其物理参数 $(\\alpha_c, E_{0,c}, R_c, \\beta_c, \\mu_c)$ 的集合。完整的道量子态由一个元组 $(c, \\ell, j, J, \\pi)$ 指定。\n\n**记忆化：** 为了加速对相同道和能量的重复计算，需要一种记忆化（缓存）策略。一个字典将用作缓存。问题要求使用特定的键控方案以确保可复现性。\n- **道密钥：** 密钥必须唯一地标识道的状态。虽然 $T$ 的模型只依赖于 $c$ 和 $\\ell$，但问题要求一个包含 $(c, \\ell, j, J, \\pi)$ 的规范化密钥以进行无歧义的标识。我们将使用一个元组 `(c_id, l, j, J, pi)`，其中 `c_id` 是每个道参数集的唯一整数。\n- **能量量化：** 为了处理浮点数比较，能量被量化。对于给定的能量 $E$ 和容差 $q_E = 10^{-6}\\,\\mathrm{MeV}$，可以通过将 $E$ 四舍五入到固定的小数位数（例如6位）来生成量化能量键 $E_q$。\n- **缓存键：** 用于记忆化计算的最终密钥将是一个复合元组 `(channel_key, energy_key)`，例如 `((c_id, l, j, J, pi), round(E, 6))`。\n\n评估函数将首先构造此键，检查缓存，只有当结果尚未存储时才执行完整计算。\n\n## 3. 测试套件计算分析\n\n该实现将被应用于四个指定的任务。\n\n**结果1和2（平均传输系数）：** 对于道 $\\mathsf{A}$ 和 $\\mathsf{B}$，我们将遍历它们各自的离散能量列表，使用设计的核心计算每个能量下的 $T_{c\\ell}(E)$，然后计算所得值的算术平均值。\n\n**结果3（零能行为）：** 对于道 $\\mathsf{C}$，我们需要评估 $T_{c\\ell}(E=0.0)$。如上文推导，对于任何 $\\ell$，$f_\\ell(0)=0$。因此，$T_{c\\ell}(0) = 1 - \\exp(0) = 1-1=0$。这是一个解析结果。使用稳定形式的数值实现应该得到一个非常接近零的值。我们将检查计算出的 $T_{c\\ell}(0.0)$ 的绝对值是否小于容差 $10^{-12}$。\n\n**结果4（单调性）：** 对于道 $\\mathsf{B}$，在密集能量网格 $E_m = 0.2m$（其中 $m=0, \\dots, 100$）上，我们必须检查 $T(E)$ 是否非递减。这意味着要验证对于所有 $m \\in \\{1, \\dots, 100\\}$，条件 $T(E_m) \\ge T(E_{m-1})$ 都成立。为了考虑浮点运算，我们将使用指定的 $10^{-12}$ 容差，并检查是否 $T(E_m) - T(E_{m-1}) \\ge -10^{-12}$。如果所有连续对都满足此条件，则总结果为 `True`，否则为 `False`。该逻辑将计算 $T(E_m)$ 值的列表，然后遍历它以检查差值。\n\n最终程序会将这四个结果组合成一个列表 `[r1, r2, r3, r4]` 并以所需格式打印。", "answer": "```python\nimport numpy as np\nimport collections\n\n# It is specified that the scipy version is 1.11.4. In this version,\n# `scipy.special.expm1` is available. However, `math.expm1` from the\n# standard library also exists and serves the same purpose with high precision.\n# To minimize dependencies per the spirit of using minimal libraries,\n# we use the standard library's math.expm1.\nimport math\n\nclass HauserFeshbachKernel:\n    \"\"\"\n    A computational kernel for evaluating Hauser-Feshbach transmission coefficients.\n    \n    This class implements the calculation of the transmission coefficient T(E) based on\n    a parametric model and includes caching mechanisms for efficiency and reproducibility.\n    \"\"\"\n    \n    _HBAR_C = 197.3269804  # MeV fm\n    _ENERGY_QUANTIZATION_TOLERANCE = 1e-6\n    _ENERGY_DECIMALS = 6 # Derived from tolerance 1e-6\n\n    def __init__(self):\n        \"\"\"Initializes the kernel, setting up the cache.\"\"\"\n        self.cache = {}\n\n    def _get_cache_key(self, channel_id, l, j, J, pi, E):\n        \"\"\"\n        Generates a canonical, hashable key for memoization.\n        \n        The key includes the full channel specification and a quantized energy value\n        to ensure reproducibility and handle floating-point nuances.\n        \"\"\"\n        # Quantize the energy to a fixed precision to treat numerically close energies as identical.\n        quantized_E = round(E, self._ENERGY_DECIMALS)\n        \n        # Create a full channel key tuple.\n        channel_key = (channel_id, l, float(j), int(J), int(pi))\n        \n        return (channel_key, quantized_E)\n\n    def _calculate_transmission(self, channel_params, l, E):\n        \"\"\"\n        Performs the core physics calculation for the transmission coefficient.\n        This method is called only on a cache miss.\n        \"\"\"\n        alpha_c = channel_params['alpha_c']\n        E0_c = channel_params['E0_c']\n        R_c = channel_params['R_c']\n        mu_c = channel_params['mu_c']\n        \n        # Guard against negative energy, which is unphysical.\n        if E  0:\n            return 0.0\n\n        # Handle E=0 case separately to avoid sqrt domain errors and ensure correctness.\n        if E == 0.0:\n            return 0.0\n\n        # Calculate the reduced wave number k(E).\n        # k(E) = sqrt(2 * mu * E) / (hbar * c)\n        k = math.sqrt(2.0 * mu_c * E) / self._HBAR_C\n        k_R_sq = (k * R_c)**2\n        \n        # Calculate the penetrability-like function g_l(E) using a numerically stable form.\n        # g_l(E) = (k*R)^2 / ((k*R)^2 + (l + 0.5)^2)\n        l_term_sq = (l + 0.5)**2\n        g_l = k_R_sq / (k_R_sq + l_term_sq)\n        \n        # Calculate the function f_l(E).\n        # f_l(E) = (E / (E + E_0)) * g_l(E)\n        f_l = (E / (E + E0_c)) * g_l\n        \n        # Calculate the transmission coefficient T(E) using a numerically stable function.\n        # T(E) = 1 - exp(-2 * alpha * f_l) is rewritten as -expm1(-2 * alpha * f_l)\n        # to avoid catastrophic cancellation when the argument is close to zero.\n        arg = -2.0 * alpha_c * f_l\n        T = -math.expm1(arg)\n        \n        return T\n\n    def get_transmission(self, channel_id, channel_params, l, j, J, pi, E):\n        \"\"\"\n        Public method to get the transmission coefficient.\n        \n        This method orchestrates the caching and calculation. It checks the cache\n        for a pre-computed value. If not found, it triggers the calculation,\n        stores the result, and then returns it.\n        \"\"\"\n        cache_key = self._get_cache_key(channel_id, l, j, J, pi, E)\n        \n        if cache_key in self.cache:\n            return self.cache[cache_key]\n        \n        # Cache miss: compute, store, and return.\n        result = self._calculate_transmission(channel_params, l, E)\n        self.cache[cache_key] = result\n        return result\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem's test suite and print the results.\n    \"\"\"\n    # Define channel parameters as specified in the problem.\n    # The 'beta_c' parameter is not used in T calculation, but included for completeness.\n    channel_definitions = {\n        \"A\": {\"id\": 0, \"c\": \"n+56Fe\", \"l\": 0, \"j\": 0.5, \"J\": 0.5, \"pi\": 1,\n              \"params\": {\"alpha_c\": 0.9, \"E0_c\": 1.5, \"R_c\": 5.0, \"beta_c\": 0.2, \"mu_c\": 469.5}},\n        \"B\": {\"id\": 1, \"c\": \"n+56Fe\", \"l\": 5, \"j\": 5.5, \"J\": 1.5, \"pi\": 1,\n              \"params\": {\"alpha_c\": 0.4, \"E0_c\": 3.0, \"R_c\": 5.0, \"beta_c\": 0.1, \"mu_c\": 469.5}},\n        \"C\": {\"id\": 2, \"c\": \"n+90Zr\", \"l\": 2, \"j\": 2.5, \"J\": 0.5, \"pi\": -1,\n              \"params\": {\"alpha_c\": 0.7, \"E0_c\": 2.0, \"R_c\": 5.5, \"beta_c\": 0.15, \"mu_c\": 469.5}},\n    }\n    \n    # Instantiate the computational kernel.\n    kernel = HauserFeshbachKernel()\n    \n    results = []\n\n    # --- Result 1: Mean of T for Channel A ---\n    chan_A = channel_definitions[\"A\"]\n    energies_A = [0.01, 0.5, 5.0, 15.0]\n    T_values_A = [kernel.get_transmission(\n        chan_A[\"id\"], chan_A[\"params\"], chan_A[\"l\"], chan_A[\"j\"], chan_A[\"J\"], chan_A[\"pi\"], E\n    ) for E in energies_A]\n    result_1 = np.mean(T_values_A)\n    results.append(result_1)\n\n    # --- Result 2: Mean of T for Channel B ---\n    chan_B = channel_definitions[\"B\"]\n    energies_B = [0.01, 0.5, 5.0, 30.0]\n    T_values_B = [kernel.get_transmission(\n        chan_B[\"id\"], chan_B[\"params\"], chan_B[\"l\"], chan_B[\"j\"], chan_B[\"J\"], chan_B[\"pi\"], E\n    ) for E in energies_B]\n    result_2 = np.mean(T_values_B)\n    results.append(result_2)\n\n    # --- Result 3: T at E=0 for Channel C ---\n    chan_C = channel_definitions[\"C\"]\n    T_at_zero_C = kernel.get_transmission(\n        chan_C[\"id\"], chan_C[\"params\"], chan_C[\"l\"], chan_C[\"j\"], chan_C[\"J\"], chan_C[\"pi\"], 0.0\n    )\n    result_3 = abs(T_at_zero_C)  1e-12\n    results.append(result_3)\n\n    # --- Result 4: Monotonicity of T for Channel B on a dense grid ---\n    # Dense grid: E_m = 0.2*m for m = 0, 1, ..., 100\n    grid_energies_B = np.linspace(0.0, 20.0, 101)\n    T_values_grid_B = [kernel.get_transmission(\n        chan_B[\"id\"], chan_B[\"params\"], chan_B[\"l\"], chan_B[\"j\"], chan_B[\"J\"], chan_B[\"pi\"], E\n    ) for E in grid_energies_B]\n    \n    is_monotonic = True\n    mono_tolerance = -1e-12 # Tolerance for floating point comparison\n    for i in range(1, len(T_values_grid_B)):\n        if (T_values_grid_B[i] - T_values_grid_B[i-1])  mono_tolerance:\n            is_monotonic = False\n            break\n    result_4 = is_monotonic\n    results.append(result_4)\n\n    # Format the final output as a comma-separated list in brackets.\n    # Booleans are automatically converted to \"True\" or \"False\" strings.\n    formatted_results = [\n        f\"{results[0]:.12f}\",\n        f\"{results[1]:.12f}\",\n        str(results[2]),\n        str(results[3])\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3602112"}, {"introduction": "在掌握了如何计算透射系数后，我们现在可以将这些构件组装起来，实现完整的 Hauser-Feshbach 公式。本练习要求你从角动量守恒和统计假设等第一性原理出发，推导并实现一个计算具体反应截面的程序。通过这个实践，你将深刻理解统计权重和衰变分支比如何共同决定最终的反应结果 [@problem_id:3551257]。", "problem": "您的任务是推导并实现一个计算，用于计算在入射中子能量 $E_n = 1\\,\\mathrm{MeV}$ 时，中子诱发铁发生质子发射反应的复合核反应截面，具体是 $n + {}^{56}\\mathrm{Fe} \\to p + {}^{56}\\mathrm{Mn}$ 道。该计算必须基于复合核（Hauser-Feshbach）框架，并使用基本原理：角动量和宇称守恒、按自旋简并度加权的复合核统计形成概率，以及通过透射系数表示的平均分支比。在问题陈述中不得使用任何预先推导好的公式；相反，您必须从这些原理出发，在您的解法中推导出必要的表达式。\n\n已知物理输入：\n- 靶核为处于基态的 ${}^{56}\\mathrm{Fe}$，其自旋宇称为 $I^\\pi = 0^+$。\n- 入射中子的自旋为 $s_n = \\tfrac{1}{2}$。\n- 入射中子的实验室能量为 $E_n = 1\\,\\mathrm{MeV}$。\n- 使用通过约化质量和质心能量计算的非相对论波数：\n  - 中子质量为 $m_n = 939.5654133\\,\\mathrm{MeV}/c^2$。\n  - ${}^{56}\\mathrm{Fe}$ 的原子质量为 $m_{\\mathrm{Fe}} = 55.9349375\\,\\mathrm{u}$，且 $1\\,\\mathrm{u} = 931.49410242\\,\\mathrm{MeV}/c^2$。\n  - 约化质量为 $\\mu = \\dfrac{m_n m_{\\mathrm{Fe}}}{m_n + m_{\\mathrm{Fe}}}$。\n  - 质心能量为 $E_{\\mathrm{cm}} = E_n \\dfrac{m_{\\mathrm{Fe}}}{m_n + m_{\\mathrm{Fe}}}$。\n  - 使用 $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\,\\mathrm{fm}$ 来获得以 $\\mathrm{fm}^{-1}$ 为单位的波数 $k = \\sqrt{2 \\mu E_{\\mathrm{cm}}}/(\\hbar c)$。\n- 反应截面必须以靶（barns）为单位表示；回顾 $1\\,\\mathrm{barn} = 100\\,\\mathrm{fm}^2$。\n\n核反应模型输入：\n- 对于每个由总自旋 $J$ 和宇称 $\\pi$ 标记的可及复合核态，在与指定 $E_n$ 对应的复合激发能下，为您提供了各道 $c \\in \\{n, p, \\alpha, \\gamma\\}$ 的无量纲透射系数 $T_c^{J\\pi}$。这些透射系数表示与各道的平均耦合概率，并且必须与适当的自旋统计权重以及从 $T_c^{J\\pi}$ 推导出的平均分支比相结合。\n- 您必须包含基于 $s_n$ 和 $I$ 的正确入射道自旋统计因子，并对所有提供的 $J^\\pi$ 求和。\n- 假设不存在宽度涨落修正（即，使用平均统计处理，不含额外的相关因子），并假设列表中的 $T_c^{J\\pi}$ 已经包含了入射道中任何相关的轨道角动量平均。\n\n测试套件：\n实现您的程序以计算以下四个参数集的 $(n,p)$ 截面 $\\sigma_{n,p}$。在每个参数集中，提供了一个复合核态 $(J^\\pi)$ 列表，以及相应的道透射系数 $T_n^{J\\pi}$、$T_p^{J\\pi}$、$T_\\alpha^{J\\pi}$ 和 $T_\\gamma^{J\\pi}$。所有 $T$ 值都是无量纲的。\n\n- 测试用例 1（多个 $J^\\pi$ 有贡献，质子透射率小但开放）：\n  - $J^\\pi = \\tfrac{1}{2}^+$: $T_n = 0.90$, $T_p = 0.002$, $T_\\alpha = 1\\times 10^{-5}$, $T_\\gamma = 0.05$.\n  - $J^\\pi = \\tfrac{3}{2}^+$: $T_n = 0.80$, $T_p = 0.003$, $T_\\alpha = 2\\times 10^{-5}$, $T_\\gamma = 0.06$.\n  - $J^\\pi = \\tfrac{5}{2}^-$: $T_n = 0.10$, $T_p = 0.0005$, $T_\\alpha = 1\\times 10^{-6}$, $T_\\gamma = 0.02$.\n- 测试用例 2（在此能量下质子道有效关闭）：\n  - $J^\\pi = \\tfrac{1}{2}^+$: $T_n = 0.85$, $T_p = 0.0$, $T_\\alpha = 1\\times 10^{-5}$, $T_\\gamma = 0.04$.\n  - $J^\\pi = \\tfrac{3}{2}^-$: $T_n = 0.60$, $T_p = 0.0$, $T_\\alpha = 1\\times 10^{-5}$, $T_\\gamma = 0.03$.\n- 测试用例 3（混合宇称集，其中一个不可及的入射道分量由 $T_n = 0$ 反映）：\n  - $J^\\pi = \\tfrac{1}{2}^-$: $T_n = 0.50$, $T_p = 0.002$, $T_\\alpha = 5\\times 10^{-6}$, $T_\\gamma = 0.10$.\n  - $J^\\pi = \\tfrac{3}{2}^+$: $T_n = 0.0$, $T_p = 0.004$, $T_\\alpha = 1\\times 10^{-5}$, $T_\\gamma = 0.08$.\n  - $J^\\pi = \\tfrac{5}{2}^+$: $T_n = 0.20$, $T_p = 0.0002$, $T_\\alpha = 1\\times 10^{-5}$, $T_\\gamma = 0.05$.\n- 测试用例 4（透射率非常小的边缘情况）：\n  - $J^\\pi = \\tfrac{1}{2}^+$: $T_n = 0.01$, $T_p = 1\\times 10^{-6}$, $T_\\alpha = 1\\times 10^{-7}$, $T_\\gamma = 0.001$.\n  - $J^\\pi = \\tfrac{3}{2}^-$: $T_n = 0.02$, $T_p = 2\\times 10^{-6}$, $T_\\alpha = 1\\times 10^{-7}$, $T_\\gamma = 0.0015$.\n\n编程与输出要求：\n- 根据所述原理推导截面表达式并加以实现。\n- 使用给定的物理常数和定义来计算入射道波数 $k$ 和几何预因子。\n- 对每个测试用例，计算以靶（barns）为单位的 $(n,p)$ 截面 $\\sigma_{n,p}$。\n- 您的程序应生成单行输出，其中包含四个结果，格式为方括号内的逗号分隔列表，每个值四舍五入到六位小数，例如 $\\texttt{[x_1,x_2,x_3,x_4]}$。", "solution": "该问题要求使用 Hauser-Feshbach 统计模型推导并实现反应 $n + {}^{56}\\mathrm{Fe} \\to p + {}^{56}\\mathrm{Mn}$ 的复合核反应截面。推导必须如指定的那样，源于量子力学和统计物理学的基本原理。\n\n### Hauser-Feshbach 公式的推导\n\n对于从入射道 $n$ 经过复合核到出射道 $p$ 的反应，其角积分截面 $\\sigma_{n,p}$ 的计算遵循 Bohr 独立性假说提出的两步过程。\n1.  从靶核 ${}^{56}\\mathrm{Fe}$ 和入射中子 $n$ 形成复合核 ($^{57}\\mathrm{Fe}^*$)。\n2.  复合核衰变为出射道，该道由剩余核 ${}^{56}\\mathrm{Mn}$ 和发射的质子 $p$ 组成。\n\n截面通过对复合核所有可能的中间态的贡献求和来计算，这些中间态由总角动量 $J$ 和宇称 $\\pi$ 来表征。总截面由下式给出：\n$$\n\\sigma_{n,p} = \\sum_{J,\\pi} \\sigma_{\\mathrm{CN}}(J^\\pi) \\cdot P_{p}(J^\\pi)\n$$\n其中 $\\sigma_{\\mathrm{CN}}(J^\\pi)$ 是在自旋宇称为 $J^\\pi$ 的态上形成复合核的截面，而 $P_{p}(J^\\pi)$ 是该态衰变到质子道的分支比或概率。\n\n**1. 复合核形成截面**\n从入射道（中子 + ${}^{56}\\mathrm{Fe}$）形成复合核态 $J^\\pi$ 的截面由分波反应截面给出。对于非极化的束和靶，它表示为：\n$$\n\\sigma_{\\mathrm{CN}}(J^\\pi) = \\frac{\\pi}{k^2} g_J T_n^{J\\pi}\n$$\n这里，$k$ 是入射道质心系中相对运动的波数。$\\pi/k^2$ 项是 s-波反应截面的几何极限。\n\n$g_J$ 项是自旋统计因子，表示入射粒子自旋 $s_n$、靶核自旋 $I$ 以及它们的相对轨道角动量耦合到总角动量 $J$ 的概率。它由下式给出：\n$$\ng_J = \\frac{2J+1}{(2s_n+1)(2I+1)}\n$$\n对于本问题，靶核是 ${}^{56}\\mathrm{Fe}$，其基态自旋为 $I=0$，入射粒子是自旋为 $s_n = \\tfrac{1}{2}$ 的中子。因此，自旋统计因子的分母为 $(2 \\cdot \\tfrac{1}{2} + 1)(2 \\cdot 0 + 1) = 2$。\n\n$T_n^{J\\pi}$ 是入射中子道的透射系数。它表示一个具有形成 $J^\\pi$ 态所需的正确角动量和宇称并到达核表面的中子被吸收形成复合核的概率。问题陈述中指出，这些系数是已知的，并且已经对有贡献的轨道角动量进行了平均。\n\n波数 $k$ 以非相对论方式计算：\n$$\nk = \\frac{\\sqrt{2\\mu E_{\\mathrm{cm}}}}{\\hbar}\n$$\n其中 $\\mu$ 是 $n$-${}^{56}\\mathrm{Fe}$ 体系的约化质量，$E_{\\mathrm{cm}}$ 是质心能量，$\\hbar$ 是约化普朗克常数。问题提供了 $\\hbar c$，所以我们使用等效形式 $k = \\sqrt{2\\mu E_{\\mathrm{cm}}}/(\\hbar c)$。必要的质量和能量为：\n- 约化质量：$\\mu = \\dfrac{m_n m_{\\mathrm{Fe}}}{m_n + m_{\\mathrm{Fe}}}$\n- 质心能量：$E_{\\mathrm{cm}} = E_n \\dfrac{m_{\\mathrm{Fe}}}{m_n + m_{\\mathrm{Fe}}}$，其中 $E_n = 1\\,\\mathrm{MeV}$。\n\n**2. 复合核衰变概率（分支比）**\n一旦形成，复合核态 $J^\\pi$ 可以衰变到任何能量上可及的道 $c$（例如，$n, p, \\alpha, \\gamma$）。统计模型假设衰变与形成无关。衰变到特定道 $p$ 的概率由该道的分波衰变宽度 $\\Gamma_p^{J\\pi}$ 与总衰变宽度 $\\Gamma_{\\mathrm{tot}}^{J\\pi}$（即所有分波宽度之和）的比值给出：\n$$\nP_p(J^\\pi) = \\frac{\\Gamma_p^{J\\pi}}{\\Gamma_{\\mathrm{tot}}^{J\\pi}} = \\frac{\\Gamma_p^{J\\pi}}{\\sum_c \\Gamma_c^{J\\pi}}\n$$\n统计模型的一个基本原则是，平均分波宽度 $\\langle\\Gamma_c^{J\\pi}\\rangle$ 与该道的透射系数 $T_c^{J\\pi}$ 成正比。由于我们处理的是平均截面（无宽度涨落修正），我们可以用透射系数代替宽度：\n$$\nP_p(J^\\pi) \\approx \\frac{T_p^{J\\pi}}{\\sum_c T_c^{J\\pi}}\n$$\n问题指定了四个衰变道：弹性/非弹性中子散射 ($n$)、质子发射 ($p$)、α粒子发射 ($\\alpha$) 和伽马衰变 ($\\gamma$)。因此，总透射系数为 $T_{\\mathrm{tot}}^{J\\pi} = T_n^{J\\pi} + T_p^{J\\pi} + T_\\alpha^{J\\pi} + T_\\gamma^{J\\pi}$。衰变到质子道的分支比变为：\n$$\nP_p(J^\\pi) = \\frac{T_p^{J\\pi}}{T_{\\mathrm{tot}}^{J\\pi}}\n$$\n\n**3. 总 (n,p) 截面**\n结合形成和衰变的表达式，并对所有有贡献的态 $J^\\pi$ 求和：\n$$\n\\sigma_{n,p} = \\sum_{J,\\pi} \\left[ \\frac{\\pi}{k^2} \\frac{2J+1}{(2s_n+1)(2I+1)} T_n^{J\\pi} \\right] \\left[ \\frac{T_p^{J\\pi}}{T_n^{J\\pi} + T_p^{J\\pi} + T_\\alpha^{J\\pi} + T_\\gamma^{J\\pi}} \\right]\n$$\n将不依赖于求和指标 $(J,\\pi)$ 的项提取出来，我们得到截面的最终表达式：\n$$\n\\sigma_{n,p} = \\frac{\\pi}{k^2} \\frac{1}{(2s_n+1)(2I+1)} \\sum_{J,\\pi} (2J+1) \\frac{T_n^{J\\pi} T_p^{J\\pi}}{\\sum_c T_c^{J\\pi}}\n$$\n\n### 实现\n算法首先计算常数预因子，然后对每个测试用例，对每个指定的复合核态的贡献求和。\n\n**常数和预因子计算：**\n使用提供的物理常数：\n- $m_n = 939.5654133\\,\\mathrm{MeV}/c^2$\n- $m_{\\mathrm{Fe}} = 55.9349375\\,\\mathrm{u} \\times 931.49410242\\,\\mathrm{MeV}/c^2/\\mathrm{u} \\approx 52101.4081\\,\\mathrm{MeV}/c^2$\n- $E_n = 1\\,\\mathrm{MeV}$\n- $\\hbar c = 197.3269804\\,\\mathrm{MeV}\\,\\mathrm{fm}$\n- $s_n = \\tfrac{1}{2}$, $I=0$\n\n导出的量为：\n- 约化质量：$\\mu = \\dfrac{m_n m_{\\mathrm{Fe}}}{m_n + m_{\\mathrm{Fe}}} \\approx 922.9550\\,\\mathrm{MeV}/c^2$\n- 质心能量：$E_{\\mathrm{cm}} = E_n \\dfrac{m_{\\mathrm{Fe}}}{m_n + m_{\\mathrm{Fe}}} \\approx 0.982286\\,\\mathrm{MeV}$\n- 波数平方：$k^2 = \\dfrac{2 \\mu E_{\\mathrm{cm}}}{(\\hbar c)^2} \\approx \\dfrac{2 \\cdot 922.9550 \\cdot 0.982286}{(197.3269804)^2} \\approx 0.0465696\\,\\mathrm{fm}^{-2}$\n- 自旋因子分母：$(2s_n+1)(2I+1) = 2$\n\n截面的总预因子为：\n$$\n\\text{预因子} = \\frac{\\pi}{k^2} \\frac{1}{2} \\approx \\frac{\\pi}{0.0465696} \\frac{1}{2} \\approx 33.7441\\,\\mathrm{fm}^2\n$$\n为将最终结果以靶（barns）表示，我们使用转换关系 $1\\,\\mathrm{barn} = 100\\,\\mathrm{fm}^2$。\n$$\n\\text{预因子 (靶)} = 33.7441\\,\\mathrm{fm}^2 \\times \\frac{1\\,\\mathrm{barn}}{100\\,\\mathrm{fm}^2} \\approx 0.337441\\,\\mathrm{barns}\n$$\n\n**测试用例计算：**\n对每个测试用例，我们计算总和：\n$$\nS = \\sum_{J,\\pi} (2J+1) \\frac{T_n^{J\\pi} T_p^{J\\pi}}{T_{\\mathrm{tot}}^{J\\pi}}\n$$\n该用例的最终截面为 $\\sigma_{n,p} = \\text{预因子 (靶)} \\times S$。提供的 Python 代码精确地实现了这一逻辑，计算预因子，然后遍历测试用例来计算并格式化结果。注意，如果 $T_n^{J\\pi}$ 或 $T_p^{J\\pi}$ 为零，或者一个态通过入射道是不可及的（如 $T_n^{J\\pi} = 0$ 所示），其对总和的贡献为零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and computes the compound-nucleus reaction cross section for\n    n + 56-Fe - p + 56-Mn at E_n = 1 MeV using the Hauser-Feshbach framework.\n    \"\"\"\n    \n    # --- Part 1: Define physical constants and calculate prefactor ---\n    \n    # Known physical inputs from the problem statement\n    M_N_MEV = 939.5654133      # Neutron mass in MeV/c^2\n    M_FE_U = 55.9349375       # 56Fe mass in atomic mass units (u)\n    U_TO_MEV = 931.49410242    # Conversion factor from u to MeV/c^2\n    HBARC_MEV_FM = 197.3269804 # h-bar * c in MeV*fm\n    BARN_TO_FM2 = 100.0         # 1 barn = 100 fm^2\n    \n    E_N_LAB_MEV = 1.0           # Incident neutron laboratory energy in MeV\n    S_N = 0.5                   # Neutron spin\n    I_TGT = 0.0                 # Target 56Fe spin\n\n    # Calculate derived quantities for the prefactor\n    m_fe_mev = M_FE_U * U_TO_MEV\n    \n    # Reduced mass of the n-56Fe system in MeV/c^2\n    mu_mev = (M_N_MEV * m_fe_mev) / (M_N_MEV + m_fe_mev)\n    \n    # Center-of-mass energy in MeV\n    e_cm_mev = E_N_LAB_MEV * m_fe_mev / (M_N_MEV + m_fe_mev)\n    \n    # Square of the wave number in the entrance channel, in fm^-2\n    k_squared_fm_inv2 = (2 * mu_mev * e_cm_mev) / (HBARC_MEV_FM ** 2)\n    \n    # Spin statistical factor denominator: (2*s_n + 1) * (2*I + 1)\n    spin_stat_denom = (2 * S_N + 1) * (2 * I_TGT + 1)\n    \n    # Overall prefactor for the cross section formula, converted to barns.\n    # The formula is sigma = (pi/k^2) * (1/spin_stat_denom) * sum(...)\n    prefactor_barns = (np.pi / k_squared_fm_inv2) / spin_stat_denom / BARN_TO_FM2\n\n    # --- Part 2: Define test cases ---\n    # Each test case is a list of dictionaries, where each dictionary\n    # represents a compound nucleus state (J^pi) and its transmission coefficients.\n    test_cases = [\n        # Test case 1\n        [\n            {'J': 0.5, 'Tn': 0.90, 'Tp': 0.002, 'Ta': 1e-5, 'Tg': 0.05},\n            {'J': 1.5, 'Tn': 0.80, 'Tp': 0.003, 'Ta': 2e-5, 'Tg': 0.06},\n            {'J': 2.5, 'Tn': 0.10, 'Tp': 0.0005, 'Ta': 1e-6, 'Tg': 0.02},\n        ],\n        # Test case 2\n        [\n            {'J': 0.5, 'Tn': 0.85, 'Tp': 0.0, 'Ta': 1e-5, 'Tg': 0.04},\n            {'J': 1.5, 'Tn': 0.60, 'Tp': 0.0, 'Ta': 1e-5, 'Tg': 0.03},\n        ],\n        # Test case 3\n        [\n            {'J': 0.5, 'Tn': 0.50, 'Tp': 0.002, 'Ta': 5e-6, 'Tg': 0.10},\n            {'J': 1.5, 'Tn': 0.0, 'Tp': 0.004, 'Ta': 1e-5, 'Tg': 0.08},\n            {'J': 2.5, 'Tn': 0.20, 'Tp': 0.0002, 'Ta': 1e-5, 'Tg': 0.05},\n        ],\n        # Test case 4\n        [\n            {'J': 0.5, 'Tn': 0.01, 'Tp': 1e-6, 'Ta': 1e-7, 'Tg': 0.001},\n            {'J': 1.5, 'Tn': 0.02, 'Tp': 2e-6, 'Ta': 1e-7, 'Tg': 0.0015},\n        ]\n    ]\n\n    results = []\n    # --- Part 3: Calculate the cross section for each test case ---\n    for case_states in test_cases:\n        sum_term = 0.0\n        for state in case_states:\n            J = state['J']\n            Tn = state['Tn']\n            Tp = state['Tp']\n            Ta = state['Ta']\n            Tg = state['Tg']\n            \n            T_total = Tn + Tp + Ta + Tg\n            \n            # The contribution is non-zero only if Tn > 0, Tp > 0, and T_total > 0.\n            # We check T_total > 0 to avoid division by zero in the unlikely event\n            # that all transmission coefficients are zero.\n            if T_total > 0:\n                # This is the term inside the sum: (2J+1) * (Tn * Tp) / T_total\n                sum_term += (2 * J + 1) * (Tn * Tp) / T_total\n        \n        # Final cross section in barns is the prefactor times the summed term.\n        cross_section_barns = prefactor_barns * sum_term\n        results.append(f\"{cross_section_barns:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3551257"}, {"introduction": "复杂的物理模型在实际应用中常常被简化以提高计算效率，但理解这些简化的代价至关重要。本练习通过将完整的 Hauser-Feshbach 模型与忽略了衰变过程中角动量守恒的 Weisskopf-Ewing 近似进行直接比较，来量化这种简化所带来的误差。这将使你能够判断何时可以使用简化模型，并深入理解角动量在复合核反应中的核心作用 [@problem_id:3551261]。", "problem": "构建一个程序，该程序针对一组指定的复合核形成和衰变参数，计算单个出射道的两个反应截面：一个完全遵循对总角动量和宇称（记作 $J^\\pi$）的依赖性，另一个则本着 Weisskopf-Ewing 假设的精神移除了这种依赖性。目标是量化在一个表现出强自旋选择性的反应中，因忽略 $J^\\pi$ 依赖性而产生的误差。程序必须为每个测试用例计算定义为 $(\\sigma_{\\mathrm{WE}} - \\sigma_{\\mathrm{HF}})/\\sigma_{\\mathrm{HF}}$ 的相对误差，并将其表示为一个四舍五入到六位小数的小数。\n\n在推导和实现中必须使用的基本依据包括以下广为接受的原理和定义：\n- 复合核反应中的角动量和宇称守恒，这意味着入射和出射过程通过以 $J$ 和 $\\pi$ 标记的复合态进行。\n- 复合核衰变的统计性质，通过作为微观相互作用和可用相空间函数的透射系数来处理每个衰变道。\n- 质心系中波数 $k$ 的定义，由 $k = \\sqrt{2 \\mu E}/(\\hbar c)$ 给出，其中 $E$ 是质心能量，$\\mu$ 是约化质量，$\\hbar c$ 是一个常数。\n- 基于弹核自旋 $s_a$ 和靶核自旋 $I_A$ 的自旋统计因子，它说明了初始自旋取向的数量。\n\n程序必须实现两种模型：\n- 具有 $J^\\pi$ 依赖性的模型：在计算所选出射道的截面时，使用形成和衰变对 $J$ 和 $\\pi$ 的完全依赖性。\n- Weisskopf-Ewing 型模型：通过为出射道使用一个不依赖于 $J^\\pi$ 的平均发射概率，来移除分支比中的 $J^\\pi$ 依赖性，同时保留正确的形成截面。\n\n您必须遵守以下算法和数值要求：\n1. 对每个测试用例，使用弹核质量 $m_a$ 和靶核质量 $m_A$ 计算约化质量 $\\mu$，然后计算波数 $k$。使用 $\\hbar c = 197.3269804\\,\\mathrm{MeV\\cdot fm}$。质量以 $\\mathrm{MeV}/c^2$ 为单位提供，能量以 $\\mathrm{MeV}$ 为单位提供。视 $c=1$。\n2. 使用适用于入射道构型的自旋统计因子，该因子由弹核自旋 $s_a$ 和靶核自旋 $I_A$ 构造。\n3. 在依赖于 $J^\\pi$ 的模型中，对提供的 $J^\\pi$ 态进行加和，每个态都有一个入射透射系数 $T_a^{J\\pi}$、一个出射道透射系数 $T_b^{J\\pi}$ 和一个竞争透射系数 $T_{\\mathrm{rest}}^{J\\pi}$。衰变的总透射系数为 $T_{\\mathrm{tot}}^{J\\pi} = T_b^{J\\pi} + T_{\\mathrm{rest}}^{J\\pi}$。只有指定的 $J^\\pi$ 态有贡献，这与自旋选择性一致。\n4. 在 Weisskopf-Ewing 型模型中，根据提供的 $J^\\pi$ 透射系数为出射道构造一个不依赖于 $J^\\pi$ 的分支概率，然后将其乘以正确计算的形成截面。\n5. 在最终截面中，使用 $1\\,\\mathrm{barn} = 100\\,\\mathrm{fm}^2$ 将面积单位从 $\\mathrm{fm}^2$ 转换为靶恩 (barn)。\n6. 对每个测试用例，计算相对误差 $(\\sigma_{\\mathrm{WE}} - \\sigma_{\\mathrm{HF}})/\\sigma_{\\mathrm{HF}}$ 并四舍五入到六位小数。\n\n物理单位：内部以靶恩报告截面，并且仅输出无量纲的相对误差，表示为四舍五入到六位小数的小数。\n\n角度单位：不适用。\n\n百分比：相对误差必须表示为小数，而不是百分比。\n\n测试套件和参数：\n- 所有用例的通用常数：$\\hbar c = 197.3269804\\,\\mathrm{MeV\\cdot fm}$；弹核为中子，其 $s_a = \\tfrac{1}{2}$ 且 $m_a = 939.565\\,\\mathrm{MeV}/c^2$；靶核宇称 $\\pi_A = +1$。靶核质量由 $m_A = A \\times 931.494\\,\\mathrm{MeV}/c^2$ 给出，其中 $A=59$。\n- 对于每个用例，指定靶核自旋 $I_A$、质心能量 $E$，以及有贡献的 $(J,\\pi)$ 态的列表及其透射系数 $(T_a^{J\\pi}, T_b^{J\\pi}, T_{\\mathrm{rest}}^{J\\pi})$。所有透射系数都是无量纲的，且介于 0 和 1 之间。\n\n测试用例：\n1. 一般强选择性用例：\n   - $I_A = \\tfrac{7}{2}$, $E = 2.0\\,\\mathrm{MeV}$。\n   - 态：\n     - $(J=\\tfrac{7}{2}, \\pi=+1): T_a^{J\\pi}=0.6, T_b^{J\\pi}=0.3, T_{\\mathrm{rest}}^{J\\pi}=0.5$。\n     - $(J=\\tfrac{9}{2}, \\pi=+1): T_a^{J\\pi}=0.9, T_b^{J\\pi}=0.05, T_{\\mathrm{rest}}^{J\\pi}=0.7$。\n     - $(J=\\tfrac{11}{2}, \\pi=+1): T_a^{J\\pi}=0.2, T_b^{J\\pi}=0.4, T_{\\mathrm{rest}}^{J\\pi}=0.3$。\n2. 极端单 $J$ 选择性用例：\n   - $I_A = \\tfrac{7}{2}$, $E = 1.0\\,\\mathrm{MeV}$。\n   - 态：\n     - $(J=\\tfrac{7}{2}, \\pi=+1): T_a^{J\\pi}=0.95, T_b^{J\\pi}=0.02, T_{\\mathrm{rest}}^{J\\pi}=0.90$。\n     - $(J=\\tfrac{9}{2}, \\pi=+1): T_a^{J\\pi}=0.0, T_b^{J\\pi}=0.40, T_{\\mathrm{rest}}^{J\\pi}=0.20$。\n     - $(J=\\tfrac{11}{2}, \\pi=+1): T_a^{J\\pi}=0.0, T_b^{J\\pi}=0.10, T_{\\mathrm{rest}}^{J\\pi}=0.40$。\n3. 弱选择性（均匀入射）用例：\n   - $I_A = \\tfrac{7}{2}$, $E = 3.0\\,\\mathrm{MeV}$。\n   - 态（负宇称主导）：\n     - $(J=\\tfrac{7}{2}, \\pi=-1): T_a^{J\\pi}=0.5, T_b^{J\\pi}=0.25, T_{\\mathrm{rest}}^{J\\pi}=0.25$。\n     - $(J=\\tfrac{9}{2}, \\pi=-1): T_a^{J\\pi}=0.5, T_b^{J\\pi}=0.25, T_{\\mathrm{rest}}^{J\\pi}=0.25$。\n     - $(J=\\tfrac{11}{2}, \\pi=-1): T_a^{J\\pi}=0.5, T_b^{J\\pi}=0.25, T_{\\mathrm{rest}}^{J\\pi}=0.25$。\n4. 宇称筛选入射用例：\n   - $I_A = \\tfrac{7}{2}$, $E = 2.0\\,\\mathrm{MeV}$。\n   - 态（仅形成负宇称）：\n     - $(J=\\tfrac{7}{2}, \\pi=+1): T_a^{J\\pi}=0.0, T_b^{J\\pi}=0.30, T_{\\mathrm{rest}}^{J\\pi}=0.40$。\n     - $(J=\\tfrac{9}{2}, \\pi=-1): T_a^{J\\pi}=0.8, T_b^{J\\pi}=0.10, T_{\\mathrm{rest}}^{J\\pi}=0.60$。\n     - $(J=\\tfrac{11}{2}, \\pi=-1): T_a^{J\\pi}=0.6, T_b^{J\\pi}=0.20, T_{\\mathrm{rest}}^{J\\pi}=0.50$。\n5. 竞争道主导用例：\n   - $I_A = \\tfrac{7}{2}$, $E = 4.0\\,\\mathrm{MeV}$。\n   - 态：\n     - $(J=\\tfrac{7}{2}, \\pi=+1): T_a^{J\\pi}=0.7, T_b^{J\\pi}=0.01, T_{\\mathrm{rest}}^{J\\pi}=0.90$。\n     - $(J=\\tfrac{9}{2}, \\pi=+1): T_a^{J\\pi}=0.4, T_b^{J\\pi}=0.05, T_{\\mathrm{rest}}^{J\\pi}=0.95$。\n     - $(J=\\tfrac{11}{2}, \\pi=+1): T_a^{J\\pi}=0.3, T_b^{J\\pi}=0.02, T_{\\mathrm{rest}}^{J\\pi}=0.98$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[r1,r2,r3,r4,r5]”），其中每个条目是相应测试用例的相对误差，按上述规定四舍五入到六位小数。", "solution": "该问题已经过仔细验证，并被确定为具有科学依据、提法恰当且完整。所有提供的参数在物理上都是合理的，且其理论框架是核反应理论中的标准框架。因此，该问题被视为 **有效**。\n\n这个问题的核心是比较计算复合核反应 $A(a, b)B$ 截面的两种模型。第一种模型是完整的 Hauser-Feshbach (HF) 形式理论，该理论在反应的每一步都遵循总角动量 $J$ 和宇称 $\\pi$ 的守恒。第二种是简化的 Weisskopf-Ewing (WE) 型模型，该模型对衰变性质进行平均，从而打破了给定 $J^\\pi$ 的形成道和衰变道之间的严格关联。\n\n首先，我们定义两种模型共有的量。反应在质心系中进行考察。入射道（弹核 $a$ 轰击靶核 $A$）的约化质量 $\\mu$ 由下式给出：\n$$ \\mu = \\frac{m_a m_A}{m_a + m_A} $$\n其中 $m_a$ 和 $m_A$ 分别是弹核和靶核的质量。质心波数 $k$ 则为：\n$$ k = \\frac{\\sqrt{2 \\mu E}}{\\hbar c} $$\n其中 $E$ 是质心能量，$\\hbar c$ 是普朗克常数与光速的乘积。\n\n从具有弹核自旋 $s_a$ 和靶核自旋 $I_A$ 的初态道形成处于特定量子数 $(J, \\pi)$ 态的复合核，其截面由下式给出：\n$$ \\sigma_{CN}^{J\\pi} = \\frac{\\pi}{k^2} \\frac{2J+1}{(2s_a+1)(2I_A+1)} T_a^{J\\pi} $$\n此处，$T_a^{J\\pi}$ 是入射道“a”通向复合态 $(J, \\pi)$ 的透射系数。项 $\\frac{2J+1}{(2s_a+1)(2I_A+1)}$ 是自旋统计因子。\n\n**1. Hauser-Feshbach（$J^\\pi$ 依赖）模型（$\\sigma_{\\mathrm{HF}}$）**\n\nHauser-Feshbach 理论假定反应分两个独立的步骤进行：复合核的形成及其随后的衰变。然而，衰变概率特定于衰变态的 $(J, \\pi)$。反应进入特定出射道“b”的截面是形成截面乘以该衰变的分支比：\n$$ \\sigma_{ab}^{J\\pi} = \\sigma_{CN}^{J\\pi} \\times P_b^{J\\pi} $$\n分支比 $P_b^{J\\pi}$ 是道 b 的透射系数 $T_b^{J\\pi}$ 与所有可能衰变道的透射系数之和的比值：\n$$ P_b^{J\\pi} = \\frac{T_b^{J\\pi}}{\\sum_c T_c^{J\\pi}} = \\frac{T_b^{J\\pi}}{T_{\\mathrm{tot}}^{J\\pi}} $$\n问题给出了感兴趣道的 $T_b^{J\\pi}$ 和一个用于所有其他竞争道的集总系数 $T_{\\mathrm{rest}}^{J\\pi}$，使得 $T_{\\mathrm{tot}}^{J\\pi} = T_b^{J\\pi} + T_{\\mathrm{rest}}^{J\\pi}$。\n\n总截面 $\\sigma_{\\mathrm{HF}}$ 是对所有有贡献的复合核态 $(J, \\pi)$ 的非相干求和：\n$$ \\sigma_{\\mathrm{HF}} = \\sum_{J,\\pi} \\sigma_{ab}^{J\\pi} = \\frac{\\pi}{k^2} \\frac{1}{(2s_a+1)(2I_A+1)} \\sum_{J,\\pi} (2J+1) T_a^{J\\pi} \\frac{T_b^{J\\pi}}{T_b^{J\\pi} + T_{\\mathrm{rest}}^{J\\pi}} $$\n\n**2. Weisskopf-Ewing（近似）模型（$\\sigma_{\\mathrm{WE}}$）**\n\nWeisskopf-Ewing 模型引入了一个关键的简化：复合核的衰变与其形成模式（包括其特定的 $J$ 和 $\\pi$）无关。因此，截面由总形成截面乘以一个单一的、不依赖于 $J^\\pi$ 的分支比给出。\n\n首先，总形成截面 $\\sigma_{CN}$ 是所有部分形成截面之和：\n$$ \\sigma_{CN} = \\sum_{J,\\pi} \\sigma_{CN}^{J\\pi} = \\frac{\\pi}{k^2} \\frac{1}{(2s_a+1)(2I_A+1)} \\sum_{J,\\pi} (2J+1) T_a^{J\\pi} $$\n接下来，我们构造一个不依赖于 $J^\\pi$ 的平均分支概率 $P_b^{\\mathrm{WE}}$。这是通过对出射道“b”的自旋加权透射系数求和，再除以所有自旋加权总衰变透射系数之和来实现的：\n$$ P_b^{\\mathrm{WE}} = \\frac{\\sum_{J,\\pi}(2J+1)T_b^{J\\pi}}{\\sum_{J,\\pi}(2J+1)T_{\\mathrm{tot}}^{J\\pi}} = \\frac{\\sum_{J,\\pi}(2J+1)T_b^{J\\pi}}{\\sum_{J,\\pi}(2J+1)(T_b^{J\\pi} + T_{\\mathrm{rest}}^{J\\pi})} $$\nWE 截面是这两个量的乘积：\n$$ \\sigma_{\\mathrm{WE}} = \\sigma_{CN} \\times P_b^{\\mathrm{WE}} = \\left( \\frac{\\pi}{k^2} \\frac{\\sum_{J,\\pi} (2J+1) T_a^{J\\pi}}{(2s_a+1)(2I_A+1)} \\right) \\times \\left( \\frac{\\sum_{J,\\pi}(2J+1)T_b^{J\\pi}}{\\sum_{J,\\pi}(2J+1)T_{\\mathrm{tot}}^{J\\pi}} \\right) $$\n\n**3. 相对误差计算**\n\n目标是计算相对误差 $\\epsilon$，其定义为：\n$$ \\epsilon = \\frac{\\sigma_{\\mathrm{WE}} - \\sigma_{\\mathrm{HF}}}{\\sigma_{\\mathrm{HF}}} $$\n注意，$\\sigma_{\\mathrm{HF}}$ 和 $\\sigma_{\\mathrm{WE}}$ 都包含共同因子 $C = \\frac{\\pi}{k^2} \\frac{1}{(2s_a+1)(2I_A+1)}$。在计算相对误差时，这个因子会消掉。\n令 $S_{\\mathrm{HF}} = \\sum_{J,\\pi} (2J+1) T_a^{J\\pi} \\frac{T_b^{J\\pi}}{T_{\\mathrm{tot}}^{J\\pi}}$。\n令 $S_{\\mathrm{form}} = \\sum_{J,\\pi} (2J+1) T_a^{J\\pi}$。\n令 $S_{\\mathrm{decay},b} = \\sum_{J,\\pi} (2J+1) T_b^{J\\pi}$。\n令 $S_{\\mathrm{decay,tot}} = \\sum_{J,\\pi} (2J+1) T_{\\mathrm{tot}}^{J\\pi}$。\n那么 $\\sigma_{\\mathrm{HF}} = C \\cdot S_{\\mathrm{HF}}$ 且 $\\sigma_{\\mathrm{WE}} = C \\cdot S_{\\mathrm{form}} \\frac{S_{\\mathrm{decay},b}}{S_{\\mathrm{decay,tot}}}$。\n相对误差简化为：\n$$ \\epsilon = \\frac{S_{\\mathrm{form}} \\cdot S_{\\mathrm{decay},b} / S_{\\mathrm{decay,tot}}}{S_{\\mathrm{HF}}} - 1 $$\n这避免了计算前置因子 $C$ 以及从 $\\mathrm{fm}^2$ 到靶恩的转换，因为它们与最终的无量纲量无关。实现将为每个测试用例计算这些中间和，然后计算相对误差，并按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative error between the Hauser-Feshbach and Weisskopf-Ewing\n    cross section models for several test cases of compound nucleus reactions.\n    \"\"\"\n    \n    # Define physical constants and common parameters\n    HBARC = 197.3269804  # MeV fm\n    M_NEUTRON = 939.565  # MeV/c^2\n    MASS_PER_AMU = 931.494 # MeV/c^2\n    \n    # Common parameters for all test cases\n    s_a = 0.5  # Projectile (neutron) spin\n    m_a = M_NEUTRON\n    A_target = 59.0\n    m_A = A_target * MASS_PER_AMU\n    # Reduced mass is not needed as the prefactor cancels in relative error.\n    # mu = (m_a * m_A) / (m_a + m_A)\n\n    test_cases = [\n        {\n            \"I_A\": 7.0/2.0, \"E\": 2.0,\n            \"states\": [\n                {\"J\": 7.0/2.0, \"Ta\": 0.6, \"Tb\": 0.3, \"Trest\": 0.5},\n                {\"J\": 9.0/2.0, \"Ta\": 0.9, \"Tb\": 0.05, \"Trest\": 0.7},\n                {\"J\": 11.0/2.0, \"Ta\": 0.2, \"Tb\": 0.4, \"Trest\": 0.3},\n            ]\n        },\n        {\n            \"I_A\": 7.0/2.0, \"E\": 1.0,\n            \"states\": [\n                {\"J\": 7.0/2.0, \"Ta\": 0.95, \"Tb\": 0.02, \"Trest\": 0.90},\n                {\"J\": 9.0/2.0, \"Ta\": 0.0, \"Tb\": 0.40, \"Trest\": 0.20},\n                {\"J\": 11.0/2.0, \"Ta\": 0.0, \"Tb\": 0.10, \"Trest\": 0.40},\n            ]\n        },\n        {\n            \"I_A\": 7.0/2.0, \"E\": 3.0,\n            \"states\": [\n                {\"J\": 7.0/2.0, \"Ta\": 0.5, \"Tb\": 0.25, \"Trest\": 0.25},\n                {\"J\": 9.0/2.0, \"Ta\": 0.5, \"Tb\": 0.25, \"Trest\": 0.25},\n                {\"J\": 11.0/2.0, \"Ta\": 0.5, \"Tb\": 0.25, \"Trest\": 0.25},\n            ]\n        },\n        {\n            \"I_A\": 7.0/2.0, \"E\": 2.0,\n            \"states\": [\n                {\"J\": 7.0/2.0, \"Ta\": 0.0, \"Tb\": 0.30, \"Trest\": 0.40},\n                {\"J\": 9.0/2.0, \"Ta\": 0.8, \"Tb\": 0.10, \"Trest\": 0.60},\n                {\"J\": 11.0/2.0, \"Ta\": 0.6, \"Tb\": 0.20, \"Trest\": 0.50},\n            ]\n        },\n        {\n            \"I_A\": 7.0/2.0, \"E\": 4.0,\n            \"states\": [\n                {\"J\": 7.0/2.0, \"Ta\": 0.7, \"Tb\": 0.01, \"Trest\": 0.90},\n                {\"J\": 9.0/2.0, \"Ta\": 0.4, \"Tb\": 0.05, \"Trest\": 0.95},\n                {\"J\": 11.0/2.0, \"Ta\": 0.3, \"Tb\": 0.02, \"Trest\": 0.98},\n            ]\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Sums for the unscaled cross sections\n        sum_hf = 0.0\n        sum_form_we = 0.0\n        sum_decay_b_we = 0.0\n        sum_decay_tot_we = 0.0\n\n        for state in case[\"states\"]:\n            J = state[\"J\"]\n            Ta = state[\"Ta\"]\n            Tb = state[\"Tb\"]\n            Trest = state[\"Trest\"]\n            \n            J_weight = 2 * J + 1\n            T_tot = Tb + Trest\n\n            # Hauser-Feshbach sum\n            if T_tot > 1e-12: # Avoid division by zero\n                branch_ratio_hf = Tb / T_tot\n                sum_hf += J_weight * Ta * branch_ratio_hf\n            \n            # Weisskopf-Ewing sums\n            sum_form_we += J_weight * Ta\n            sum_decay_b_we += J_weight * Tb\n            sum_decay_tot_we += J_weight * T_tot\n            \n        # Calculate the unscaled cross section terms\n        sigma_hf_unscaled = sum_hf\n        \n        if sum_decay_tot_we > 1e-12:\n             branch_ratio_we = sum_decay_b_we / sum_decay_tot_we\n        else:\n            branch_ratio_we = 0.0\n        \n        sigma_we_unscaled = sum_form_we * branch_ratio_we\n\n        # Calculate relative error\n        if abs(sigma_hf_unscaled)  1e-12:\n            # If sigma_hf is zero, sigma_we is also zero under non-pathological\n            # conditions. The relative error is defined as 0.\n            relative_error = 0.0\n        else:\n            relative_error = (sigma_we_unscaled - sigma_hf_unscaled) / sigma_hf_unscaled\n            \n        results.append(round(relative_error, 6))\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3551261"}]}