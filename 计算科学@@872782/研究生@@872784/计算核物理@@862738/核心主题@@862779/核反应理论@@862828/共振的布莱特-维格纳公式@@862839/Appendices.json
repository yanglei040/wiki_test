{"hands_on_practices": [{"introduction": "虽然统计理论提供了基础，但将非线性模型拟合到数据中会带来实际的数值计算难题。本练习 ([@problem_id:3596455]) 深入探讨了非线性最小二乘法拟合的内部机制，重点关注决定优化算法稳定性和收敛性的雅可比矩阵 (Jacobian matrix)。您将研究为何拟合可能因病态条件 (ill-conditioning) 而失败，并学习如何使用参数缩放和正则化等技术来诊断和解决这些问题，从而确保您的拟合过程稳健可靠。", "problem": "给定一个针对单核共振和多项式本底的非线性最小二乘模型，其中因变量是作为能量函数的截面。该模型假设观测数据点为 $\\{(E_i, y_i, \\sigma_i)\\}_{i=1}^N$，其中能量 $E_i$ 的单位为 $\\mathrm{MeV}$，截面 $y_i$ 的单位为 $\\mathrm{barn}$，测量不确定度 $\\sigma_i$ 的单位为 $\\mathrm{barn}$。参数模型是 Breit-Wigner 共振和多项式本底之和，\n$$\n\\hat{y}(E;\\boldsymbol{\\theta}) = A\\,S(E;E_0,\\Gamma) + \\sum_{k=0}^{m} c_k\\,x(E)^k,\n$$\n其中 $A$ 是共振振幅（单位 $\\mathrm{barn}$），$E_0$ 是共振质心能量（单位 $\\mathrm{MeV}$），$\\Gamma$ 是总宽度（单位 $\\mathrm{MeV}$），本底系数 $c_k$ 的单位为 $\\mathrm{barn}$。归一化本底基使用\n$$\nx(E) = \\frac{E - E_c}{E_s},\n$$\n其中 $E_c$ 是能量窗口的中心（单位 $\\mathrm{MeV}$），$E_s$ 是其半宽（单位 $\\mathrm{MeV}$），因此 $x(E) \\in [-1,1]$。非相对论性 Breit-Wigner 形状为\n$$\nS(E;E_0,\\Gamma) = \\frac{(\\Gamma/2)^2}{(E - E_0)^2 + (\\Gamma/2)^2}.\n$$\n\n考虑未加权最小二乘的残差向量，\n$$\n\\mathbf{r}(\\boldsymbol{\\theta}) = \\mathbf{y} - \\hat{\\mathbf{y}}(\\boldsymbol{\\theta}),\n$$\n及其雅可比矩阵 $J(\\boldsymbol{\\theta}) = \\partial \\mathbf{r}/\\partial \\boldsymbol{\\theta} \\in \\mathbb{R}^{N \\times P}$，其中 $P = m+4$ 是参数的数量。$J$ 的条件直接影响 Gauss-Newton 收敛。您的任务是计算雅可比矩阵，评估其条件，并研究缩放和简单的高斯先验如何改善近似 Hessian 矩阵的条件和正定性。使用以下基本定义：\n\n- 最小二乘残差定义 $\\mathbf{r}(\\boldsymbol{\\theta}) = \\mathbf{y} - \\hat{\\mathbf{y}}(\\boldsymbol{\\theta})$。\n- 雅可比矩阵定义 $J(\\boldsymbol{\\theta}) = \\partial \\mathbf{r}/\\partial \\boldsymbol{\\theta}$。\n- 奇异值分解条件数 $\\kappa(J) = \\sigma_{\\max}(J)/\\sigma_{\\min}(J)$，其中 $\\sigma_{\\max}$、$\\sigma_{\\min}$ 分别是最大和最小奇异值。\n- 未加权最小二乘的 Gauss-Newton 近似 Hessian 矩阵为 $H \\approx J^\\top J$，加权最小二乘的为 $H \\approx J_w^\\top J_w$，其中 $J_w = WJ$ 且 $W = \\mathrm{diag}(1/\\sigma_i)$。\n\n从第一性原理出发，通过对 $\\hat{y}(E;\\boldsymbol{\\theta})$ 直接微分来计算雅可比矩阵的元素。不要假设任何现成的捷径。然后：\n\n1. 在指定的初始猜测值 $\\boldsymbol{\\theta}_0$ 处计算未加权的雅可比矩阵 $J(\\boldsymbol{\\theta})$ 及其对应的条件数 $\\kappa_{\\mathrm{raw}}$。\n2. 定义一个缩放后的雅可比矩阵 $J_{\\mathrm{scaled}} = W J C^{-1}$，其中 $W = \\mathrm{diag}(1/\\sigma_i)$ 用于白化残差，而 $C$ 是一个由 $WJ$ 的列范数构成的对角矩阵，使得 $J_{\\mathrm{scaled}}$ 的每一列都具有单位欧几里得范数。计算 $\\kappa_{\\mathrm{scaled}}$。\n3. 为具有独立先验的参数构造一个高斯先验精度矩阵 $\\Lambda = \\mathrm{diag}(\\lambda_j)$：\n   - $A \\sim \\mathcal{N}(0, \\sigma_A^2)$，其中 $\\sigma_A = 10\\,\\mathrm{barn}$，因此 $\\lambda_A = 1/\\sigma_A^2$。\n   - $E_0 \\sim \\mathcal{N}(0, \\sigma_{E_0}^2)$，其中 $\\sigma_{E_0} = 0.5\\,\\mathrm{MeV}$，因此 $\\lambda_{E_0} = 1/\\sigma_{E_0}^2$。\n   - $\\Gamma \\sim \\mathcal{N}(0, \\sigma_{\\Gamma}^2)$，其中 $\\sigma_{\\Gamma} = 0.2\\,\\mathrm{MeV}$，因此 $\\lambda_{\\Gamma} = 1/\\sigma_{\\Gamma}^2$。\n   - $c_k \\sim \\mathcal{N}(0, \\sigma_{c,k}^2)$，其中 $\\sigma_{c,k} = \\sigma_c/(k+1)$，$\\sigma_c = 0.5\\,\\mathrm{barn}$，因此 $\\lambda_{c,k} = 1/\\sigma_{c,k}^2$。\n   评估未正则化的近似 Hessian 矩阵 $H_0 = J^\\top J$ 的最小特征值，并报告其是否严格为正（布尔值），以及正则化的近似 Hessian 矩阵 $H_{\\mathrm{prior}} = J_w^\\top J_w + \\Lambda$ 的最小特征值，并报告其是否严格为正（布尔值）。在相应的参数单位下，使用严格正性阈值 $\\varepsilon = 10^{-12}$。\n\n设计一个程序，对以下测试用例集执行上述计算。每个用例都指定了能量窗口和采样方式、用于生成合成数据（为了真实性，尽管雅可比矩阵仅依赖于当前参数值）的真实参数，以及用于评估雅可比矩阵的初始猜测值 $\\boldsymbol{\\theta}_0$。所有能量单位必须是 $\\mathrm{MeV}$，宽度单位是 $\\mathrm{MeV}$，截面和本底系数单位是 $\\mathrm{barn}$。\n\n- 用例 $1$（理想路径，良态）：\n  - 能量窗口：$E \\in [3,7]\\,\\mathrm{MeV}$，在 $N=200$ 个等间距点上采样。\n  - 真实参数：$E_0 = 5\\,\\mathrm{MeV}$，$\\Gamma = 0.5\\,\\mathrm{MeV}$，$A = 2.0\\,\\mathrm{barn}$，多项式阶数 $m=2$，$c_0 = 0.5\\,\\mathrm{barn}$，$c_1 = 0.1\\,\\mathrm{barn}$，$c_2 = -0.02\\,\\mathrm{barn}$。\n  - 测量不确定度：对所有 $i$，$\\sigma_i = 0.02\\,\\mathrm{barn}$。\n  - 初始猜测值：$E_0^{(0)} = 5.1\\,\\mathrm{MeV}$，$\\Gamma^{(0)} = 0.55\\,\\mathrm{MeV}$，$A^{(0)} = 1.8\\,\\mathrm{barn}$，对所有 $k$，$c_k^{(0)} = c_k$。\n\n- 用例 $2$（边界情况，极窄宽度，可能欠采样）：\n  - 能量窗口：$E \\in [4.8,5.2]\\,\\mathrm{MeV}$，在 $N=100$ 个等间距点上采样。\n  - 真实参数：$E_0 = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.05\\,\\mathrm{MeV}$，$A = 2.0\\,\\mathrm{barn}$，多项式阶数 $m=2$，$c_0 = 0.5\\,\\mathrm{barn}$，$c_1 = 0.1\\,\\mathrm{barn}$，$c_2 = -0.02\\,\\mathrm{barn}$。\n  - 测量不确定度：对所有 $i$，$\\sigma_i = 0.02\\,\\mathrm{barn}$。\n  - 初始猜测值：$E_0^{(0)} = 5.02\\,\\mathrm{MeV}$，$\\Gamma^{(0)} = 0.06\\,\\mathrm{MeV}$，$A^{(0)} = 1.9\\,\\mathrm{barn}$，对所有 $k$，$c_k^{(0)} = c_k$。\n\n- 用例 $3$（边缘情况，高阶本底，可能存在共线性）：\n  - 能量窗口：$E \\in [0,10]\\,\\mathrm{MeV}$，在 $N=300$ 个等间距点上采样。\n  - 真实参数：$E_0 = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.3\\,\\mathrm{MeV}$，$A = 1.5\\,\\mathrm{barn}$，多项式阶数 $m=5$，$c_0 = 0.3\\,\\mathrm{barn}$，$c_1 = -0.15\\,\\mathrm{barn}$，$c_2 = 0.05\\,\\mathrm{barn}$，$c_3 = -0.02\\,\\mathrm{barn}$，$c_4 = 0.01\\,\\mathrm{barn}$，$c_5 = -0.005\\,\\mathrm{barn}$。\n  - 测量不确定度：对所有 $i$，$\\sigma_i = 0.03\\,\\mathrm{barn}$。\n  - 初始猜测值：$E_0^{(0)} = 5.2\\,\\mathrm{MeV}$，$\\Gamma^{(0)} = 0.27\\,\\mathrm{MeV}$，$A^{(0)} = 1.35\\,\\mathrm{barn}$，对所有 $k$，$c_k^{(0)} = c_k$。\n\n- 用例 $4$（边缘情况，低振幅共振被本底掩盖）：\n  - 能量窗口：$E \\in [3,7]\\,\\mathrm{MeV}$，在 $N=200$ 个等间距点上采样。\n  - 真实参数：$E_0 = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.5\\,\\mathrm{MeV}$，$A = 0.1\\,\\mathrm{barn}$，多项式阶数 $m=2$，$c_0 = 0.5\\,\\mathrm{barn}$，$c_1 = 0.1\\,\\mathrm{barn}$，$c_2 = -0.02\\,\\mathrm{barn}$。\n  - 测量不确定度：对所有 $i$，$\\sigma_i = 0.02\\,\\mathrm{barn}$。\n  - 初始猜测值：$E_0^{(0)} = 5.1\\,\\mathrm{MeV}$，$\\Gamma^{(0)} = 0.55\\,\\mathrm{MeV}$，$A^{(0)} = 0.12\\,\\mathrm{barn}$，对所有 $k$，$c_k^{(0)} = c_k$。\n\n对于每个用例，您的程序必须计算并返回一个包含以下内容的列表：\n- $\\kappa_{\\mathrm{raw}}$（浮点数），\n- $\\kappa_{\\mathrm{scaled}}$（浮点数），\n- 改善比 $\\rho = \\kappa_{\\mathrm{raw}}/\\kappa_{\\mathrm{scaled}}$（浮点数），\n- 一个布尔值，指示 $\\min\\operatorname{eig}(H_0) > \\varepsilon$ 是否成立，\n- 一个布尔值，指示 $\\min\\operatorname{eig}(H_{\\mathrm{prior}}) > \\varepsilon$ 是否成立。\n\n最终输出格式：您的程序应生成一行输出，其中包含四个用例的结果，形式为一个包含四个子列表的逗号分隔列表，每个子列表按上述格式表示并用方括号括起来，不含空格（例如，$\\big[\\,[1.0,0.5,2.0,\\mathrm{True},\\mathrm{True}],\\ldots\\,\\big]$）。$\\kappa_{\\mathrm{raw}}$、$\\kappa_{\\mathrm{scaled}}$ 和 $\\rho$ 的值是无量纲浮点数。正定性布尔值必须是精确的逻辑值。在内部以以上提供的单位表示所有物理量；输出按规定为无单位值或布尔值。", "solution": "该问题要求分析核共振非线性最小二乘模型中雅可比矩阵的条件。分析过程包括在给定的参数猜测值处计算雅可比矩阵，评估其在有无缩放情况下的条件数，并评估相应的近似 Hessian 矩阵在有无源自高斯先验的 Tikhonov 正则化的情况下的正定性。\n\n截面 $\\hat{y}$ 作为能量 $E$ 函数的参数模型由一个 Breit-Wigner 共振项和一个多项式本底項的和给出：\n$$\n\\hat{y}(E;\\boldsymbol{\\theta}) = A\\,S(E;E_0,\\Gamma) + \\sum_{k=0}^{m} c_k\\,x(E)^k\n$$\n尺寸为 $P=m+4$ 的参数向量 $\\boldsymbol{\\theta}$ 由共振振幅 $A$、共振能量 $E_0$、共振宽度 $\\Gamma$ 和 $m+1$ 个本底系数 $\\{c_k\\}_{k=0}^m$ 组成。我们将参数向量排序为 $\\boldsymbol{\\theta} = [A, E_0, \\Gamma, c_0, c_1, \\dots, c_m]^\\top$。\n\nBreit-Wigner 线型函数 $S(E;E_0,\\Gamma)$ 定义为：\n$$\nS(E;E_0,\\Gamma) = \\frac{(\\Gamma/2)^2}{(E - E_0)^2 + (\\Gamma/2)^2}\n$$\n本底多项式用归一化基 $x(E)$ 表示：\n$$\nx(E) = \\frac{E - E_c}{E_s}\n$$\n其中 $E_c$ 是能量区间的中心，$E_s$ 是其半宽，确保在拟合窗口内 $x(E) \\in [-1,1]$。\n\n对于一组 $N$ 个能量点 $\\{E_i\\}_{i=1}^N$，最小二乘问题旨在最小化残差平方和。残差向量为 $\\mathbf{r}(\\boldsymbol{\\theta}) = \\mathbf{y} - \\hat{\\mathbf{y}}(\\boldsymbol{\\theta})$，其中 $\\mathbf{y}$ 是观测截面向量，$\\hat{\\mathbf{y}}(\\boldsymbol{\\theta})$ 是模型预测值向量。残差向量的雅可比矩阵是像 Gauss-Newton 算法这类迭代求解器的关键组成部分。其定义为：\n$$\nJ(\\boldsymbol{\\theta}) = \\frac{\\partial \\mathbf{r}(\\boldsymbol{\\theta})}{\\partial \\boldsymbol{\\theta}} = - \\frac{\\partial \\hat{\\mathbf{y}}(\\boldsymbol{\\theta})}{\\partial \\boldsymbol{\\theta}}\n$$\n元素 $J_{ij}$ 对应于第 $i$ 个残差关于第 $j$ 个参数的偏导数，在 $E_i$ 处求值。我们从第一性原理计算这些导数。\n\n$\\hat{y}(E; \\boldsymbol{\\theta})$ 关于各参数的偏导数如下：\n1.  关于振幅 $A$ 的导数：\n    $$ \\frac{\\partial \\hat{y}}{\\partial A} = S(E;E_0,\\Gamma) $$\n2.  关于共振能量 $E_0$ 的导数：\n    $$ \\frac{\\partial \\hat{y}}{\\partial E_0} = A \\frac{\\partial S}{\\partial E_0} = A \\left( (\\Gamma/2)^2 \\frac{-1}{((E-E_0)^2+(\\Gamma/2)^2)^2} (2(E-E_0)(-1)) \\right) = A \\frac{2(E-E_0)(\\Gamma/2)^2}{((E-E_0)^2+(\\Gamma/2)^2)^2} $$\n3.  关于共振宽度 $\\Gamma$ 的导数：\n    $$ \\frac{\\partial \\hat{y}}{\\partial \\Gamma} = A \\frac{\\partial S}{\\partial \\Gamma} = A \\frac{ \\frac{\\partial}{\\partial\\Gamma}((\\Gamma/2)^2) \\cdot ((E-E_0)^2+(\\Gamma/2)^2) - (\\Gamma/2)^2 \\cdot \\frac{\\partial}{\\partial\\Gamma}((E-E_0)^2+(\\Gamma/2)^2) }{ ((E-E_0)^2+(\\Gamma/2)^2)^2 } $$\n    $$ \\frac{\\partial \\hat{y}}{\\partial \\Gamma} = A \\frac{ (\\Gamma/2) \\cdot ((E-E_0)^2+(\\Gamma/2)^2) - (\\Gamma/2)^2 \\cdot (\\Gamma/2) }{ ((E-E_0)^2+(\\Gamma/2)^2)^2 } = A \\frac{(\\Gamma/2)(E-E_0)^2}{((E-E_0)^2+(\\Gamma/2)^2)^2} $$\n4.  关于本底系数 $c_k$ 的导数：\n    $$ \\frac{\\partial \\hat{y}}{\\partial c_k} = \\frac{\\partial}{\\partial c_k} \\sum_{j=0}^{m} c_j\\,x(E)^j = x(E)^k $$\n\n在特定参数猜测值 $\\boldsymbol{\\theta}_0$ 处的雅可比矩阵 $J$ 的列，是通过使用这些表达式（取负）在每个能量 $E_i$ 和 $\\boldsymbol{\\theta}_0$ 中的每个参数上求值来构建的。\n\n第一个任务是计算这个未加权雅可比矩阵 $J$ 的条件数 $\\kappa_{\\mathrm{raw}}$。它由最大奇异值与最小奇异值的比值给出：$\\kappa_{\\mathrm{raw}}(J) = \\sigma_{\\max}(J) / \\sigma_{\\min}(J)$。大的条件数表明最小二乘问题是病态的。\n\n第二个任务是通过缩放改善一个相关的条件数。我们定义一个加权雅可比矩阵 $J_w = WJ$，其中 $W = \\mathrm{diag}(1/\\sigma_i)$ 是一个由测量不确定度的倒数构成的对角矩阵。此变换等效于白化残差。对 $J_w$ 的列应用进一步的缩放。我们定义一个对角矩阵 $C$，其对角元素 $C_{jj}$ 是 $J_w$ 各列的欧几里得范数，即 $C_{jj} = \\|(J_w)_{:,j}\\|_2$。完全缩放后的雅可比矩阵是 $J_{\\mathrm{scaled}} = J_w C^{-1}$。根据构造，$J_{\\mathrm{scaled}}$ 的每一列都具有单位欧几里得范数。然后我们计算其条件数 $\\kappa_{\\mathrm{scaled}}$，该值通常比 $\\kappa_{\\mathrm{raw}}$ 大大改善。改善程度由比率 $\\rho = \\kappa_{\\mathrm{raw}} / \\kappa_{\\mathrm{scaled}}$ 量化。\n\n第三个任务涉及 Hessian 矩阵的 Gauss-Newton 近似。对于未加权最小二乘，这是 $H_0 \\approx J^\\top J$。为使算法稳定，$H_0$ 必须是正定的。我们通过计算其特征值并验证最小特征值是否严格为正（即 $\\min\\operatorname{eig}(H_0) > \\varepsilon$，对于小阈值 $\\varepsilon = 10^{-12}$）来检查这一点。\n当 $H_0$ 是病态或奇异时，可以引入正则化。对参数使用高斯先验会导致一个正则化或最大后验 (MAP) 估计问题。相应目标函数的 Hessian 矩阵近似为 $H_{\\mathrm{prior}} = J_w^\\top J_w + \\Lambda$，其中 $\\Lambda$ 是先验精度矩阵（先验协方差矩阵的逆）。对于指定的独立高斯先验，$\\Lambda = \\mathrm{diag}(\\lambda_j)$，其中 $\\lambda_j = 1/\\sigma_j^2$，$\\sigma_j$ 是参数 $\\theta_j$ 先验的标准差。具体值为 $\\lambda_A = 1/\\sigma_A^2 = 1/10^2 = 0.01$，$\\lambda_{E_0} = 1/\\sigma_{E_0}^2 = 1/0.5^2 = 4$，$\\lambda_{\\Gamma} = 1/\\sigma_{\\Gamma}^2 = 1/0.2^2 = 25$，以及 $\\lambda_{c,k} = 1/\\sigma_{c,k}^2 = ((k+1)/\\sigma_c)^2 = (2(k+1))^2$，其中 $\\sigma_c=0.5$。将对角正定矩阵 $\\Lambda$ 加到半正定的 $J_w^\\top J_w$ 上，通常能确保得到的正则化 Hessian 矩阵 $H_{\\mathrm{prior}}$ 是严格正定的。我们通过检查是否 $\\min\\operatorname{eig}(H_{\\mathrm{prior}}) > \\varepsilon$ 来验证这一点。\n\n每个测试用例的计算流程如下：\n1.  设置能量网格 $\\{E_i\\}$ 和初始参数猜测值 $\\boldsymbol{\\theta}_0$。\n2.  使用在 $\\boldsymbol{\\theta}_0$ 处求值的推导出的偏导数，构建 $N \\times P$ 未加权雅可比矩阵 $J$。\n3.  计算 $\\kappa_{\\mathrm{raw}} = \\operatorname{cond}(J)$。\n4.  构建加权矩阵 $W$ 和加权雅可比矩阵 $J_w = WJ$。\n5.  计算 $J_w$ 的列范数以形成对角矩阵 $C$。\n6.  构建缩放后的雅可比矩阵 $J_{\\mathrm{scaled}} = J_w C^{-1}$ 并计算 $\\kappa_{\\mathrm{scaled}} = \\operatorname{cond}(J_{\\mathrm{scaled}})$。\n7.  计算改善比 $\\rho = \\kappa_{\\mathrm{raw}} / \\kappa_{\\mathrm{scaled}}$。\n8.  计算未正则化的 Hessian 矩阵 $H_0 = J^\\top J$ 并确定其最小特征值是否大于 $\\varepsilon = 10^{-12}$。\n9.  构建先验精度矩阵 $\\Lambda$。\n10. 计算正则化的 Hessian 矩阵 $H_{\\mathrm{prior}} = J_w^\\top J_w + \\Lambda$ 并确定其最小特征值是否大于 $\\varepsilon = 10^{-12}$。\n11. 收集这五个结果：$\\kappa_{\\mathrm{raw}}$、$\\kappa_{\\mathrm{scaled}}$、$\\rho$ 以及两个表示正定性的布尔值。\n对所有四个指定的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the final result.\n    \"\"\"\n    \n    # Test cases defined as a list of dictionaries.\n    test_cases = [\n        {\n            \"E_range\": (3.0, 7.0), \"N\": 200, \"m\": 2,\n            \"sigma\": 0.02,\n            \"theta0\": np.array([1.8, 5.1, 0.55, 0.5, 0.1, -0.02])\n        },\n        {\n            \"E_range\": (4.8, 5.2), \"N\": 100, \"m\": 2,\n            \"sigma\": 0.02,\n            \"theta0\": np.array([1.9, 5.02, 0.06, 0.5, 0.1, -0.02])\n        },\n        {\n            \"E_range\": (0.0, 10.0), \"N\": 300, \"m\": 5,\n            \"sigma\": 0.03,\n            \"theta0\": np.array([1.35, 5.2, 0.27, 0.3, -0.15, 0.05, -0.02, 0.01, -0.005])\n        },\n        {\n            \"E_range\": (3.0, 7.0), \"N\": 200, \"m\": 2,\n            \"sigma\": 0.02,\n            \"theta0\": np.array([0.12, 5.1, 0.55, 0.5, 0.1, -0.02])\n        }\n    ]\n\n    # Prior definitions\n    prior_params = {\n        \"sigma_A\": 10.0,\n        \"sigma_E0\": 0.5,\n        \"sigma_Gamma\": 0.2,\n        \"sigma_c\": 0.5\n    }\n\n    epsilon = 1e-12\n    \n    results = []\n    for case in test_cases:\n        result = process_case(case, prior_params, epsilon)\n        results.append(result)\n\n    # Format output to be a list of lists string with no spaces.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef get_jacobian(E, theta0, m, E_c, E_s):\n    \"\"\"\n    Computes the Jacobian matrix for the given model.\n    J = -d(y_hat)/d(theta)\n    \"\"\"\n    N = len(E)\n    P = m + 4\n    J = np.zeros((N, P))\n    \n    A, E0, Gamma = theta0[0], theta0[1], theta0[2]\n    c_coeffs = theta0[3:]\n    \n    # Breit-Wigner common terms\n    G2 = Gamma / 2.0\n    G2_sq = G2**2\n    E_minus_E0 = E - E0\n    E_minus_E0_sq = E_minus_E0**2\n    den = E_minus_E0_sq + G2_sq\n    den_sq = den**2\n    \n    # Column for A\n    # d(y_hat)/dA = S(E)\n    S = G2_sq / den\n    J[:, 0] = -S\n    \n    # Column for E0\n    # d(y_hat)/dE0 = A * 2 * (E - E0) * (Gamma/2)^2 / ((E-E0)^2 + (Gamma/2)^2)^2\n    J[:, 1] = -A * 2 * E_minus_E0 * G2_sq / den_sq\n    \n    # Column for Gamma\n    # d(y_hat)/dGamma = A * (Gamma/2) * (E-E0)^2 / ((E-E0)^2 + (Gamma/2)^2)^2\n    J[:, 2] = -A * G2 * E_minus_E0_sq / den_sq\n    \n    # Columns for c_k\n    # d(y_hat)/dc_k = x(E)^k\n    x = (E - E_c) / E_s\n    for k in range(m + 1):\n        J[:, 3 + k] = -np.power(x, k)\n        \n    return J\n\ndef process_case(case_params, prior_params, epsilon):\n    \"\"\"\n    Processes a single test case to compute all required values.\n    \"\"\"\n    E_min, E_max = case_params[\"E_range\"]\n    N = case_params[\"N\"]\n    m = case_params[\"m\"]\n    sigma = case_params[\"sigma\"]\n    theta0 = case_params[\"theta0\"]\n    \n    E = np.linspace(E_min, E_max, N)\n    E_c = (E_max + E_min) / 2.0\n    E_s = (E_max - E_min) / 2.0\n    \n    # 1. Unweighted Jacobian and condition number\n    J = get_jacobian(E, theta0, m, E_c, E_s)\n    kappa_raw = np.linalg.cond(J)\n    \n    # 2. Scaled Jacobian and condition number\n    W = np.diag(np.full(N, 1.0/sigma))\n    J_w = W @ J\n    \n    col_norms = np.linalg.norm(J_w, axis=0)\n    # Handle potential zero columns to avoid division by zero\n    col_norms[col_norms == 0] = 1.0\n    C_inv = np.diag(1.0 / col_norms)\n    \n    J_scaled = J_w @ C_inv\n    kappa_scaled = np.linalg.cond(J_scaled)\n    \n    improvement_ratio = kappa_raw / kappa_scaled if kappa_scaled > 0 else float('inf')\n\n    # 3. Hessian analysis\n    # Unregularized Hessian H0\n    H0 = J.T @ J\n    eigvals_H0 = np.linalg.eigvalsh(H0)\n    is_H0_pos_def = bool(np.min(eigvals_H0) > epsilon)\n    \n    # Regularized Hessian H_prior\n    sigma_A = prior_params[\"sigma_A\"]\n    sigma_E0 = prior_params[\"sigma_E0\"]\n    sigma_Gamma = prior_params[\"sigma_Gamma\"]\n    sigma_c = prior_params[\"sigma_c\"]\n    \n    lambda_A = 1.0 / sigma_A**2\n    lambda_E0 = 1.0 / sigma_E0**2\n    lambda_Gamma = 1.0 / sigma_Gamma**2\n    lambda_c = [((k + 1) / sigma_c)**2 for k in range(m + 1)]\n    \n    Lambda_diag = np.concatenate(([lambda_A, lambda_E0, lambda_Gamma], lambda_c))\n    Lambda = np.diag(Lambda_diag)\n    \n    H_prior = J_w.T @ J_w + Lambda\n    eigvals_H_prior = np.linalg.eigvalsh(H_prior)\n    is_H_prior_pos_def = bool(np.min(eigvals_H_prior) > epsilon)\n    \n    return [kappa_raw, kappa_scaled, improvement_ratio, is_H0_pos_def, is_H_prior_pos_def]\n    \n\n# The problem defines a specific program structure. Calling solve() will execute it.\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3596455"}, {"introduction": "获得参数的最佳拟合值只是成功了一半；理解其不确定性和相互依赖性对于完整的物理解释至关重要。最后一个练习 ([@problem_id:3596468]) 聚焦于拟合后的分析，利用参数的协方差矩阵来探索解的结构。您将学习计算和解释共振能量 $E_R$ 和宽度 $\\Gamma$ 之间的相关性，并建立一个定量标准来判断这些参数是否能从给定的数据集中被唯一地确定。", "problem": "要求您编写一个完整且可运行的程序，该程序对核散射截面中一个具有物理动机的共振模型进行加权非线性最小二乘拟合，然后分析共振能量和宽度的参数相关性与可辨识性。该模型由一个孤立的共振构成，该共振由一个符合概率守恒和幺正性的洛伦兹线型描述，外加一个平滑的线性背景。您的程序必须从散射矩阵的定义和共振散射的基本结构出发，并在代码注释中证明拟合所用模型的合理性。拟合应针对具有已知测量不确定度（被视作独立且服从高斯分布）的合成数据集进行，并且必须从与加权最小二乘目标相关的费雪信息中估计参数协方差。程序必须计算共振能量和宽度的协方差矩阵、相应的相关系数，以及基于一个数值指定准则的可辨识性标志。\n\n定义与要求：\n\n- 设自变量为质心能量 $E$（单位为 $\\mathrm{MeV}$），可观测量为截面 $y(E)$（单位为 barns）。共振结构由散射矩阵在靠近实能量轴的一个极点来表征，其极点位置为 $E_R - i \\Gamma/2$，其中 $E_R$ 是共振能量（单位为 $\\mathrm{MeV}$），$\\Gamma$ 是总宽度（单位为 $\\mathrm{MeV}$）。假设背景在能量窗口内变化缓慢。\n- 将参数向量定义为 $\\theta = (E_R, \\Gamma, A, B_0, B_1)$，其中 $A$ 是一个正的振幅参数（单位为 barns），$B_0$ 是背景截距（单位为 barns），$B_1$ 是背景斜率（单位为 barns/$\\mathrm{MeV}$）。\n- 给定 $N$ 个数据点 $\\{(E_i, y_i, \\sigma_i)\\}_{i=1}^N$，其中 $\\sigma_i$ 是已知的标准差（单位为 barns），加权非线性最小二乘目标函数为\n$$\n\\chi^2(\\theta) = \\sum_{i=1}^N \\frac{\\left[y_i - y(E_i;\\theta)\\right]^2}{\\sigma_i^2}.\n$$\n- 在最佳拟合 $\\hat{\\theta}$ 处，参数协方差矩阵可通过独立高斯误差的费雪信息的逆来近似，\n$$\n\\mathrm{Cov}(\\hat{\\theta}) \\approx \\left(J^\\top W J\\right)^{-1},\n$$\n其中 $J$ 是雅可比矩阵，其元素 $J_{ij} = \\partial y(E_i;\\theta)/\\partial \\theta_j$ 在 $\\hat{\\theta}$ 处求值，而 $W$ 是对角矩阵，其元素 $W_{ii} = 1/\\sigma_i^2$。\n- 提取对应于 $(E_R, \\Gamma)$ 的 $2\\times 2$ 协方差子矩阵，计算其相关系数\n$$\n\\rho_{E_R,\\Gamma} = \\frac{\\mathrm{Cov}(E_R,\\Gamma)}{\\sqrt{\\mathrm{Var}(E_R)\\,\\mathrm{Var}(\\Gamma)}},\n$$\n并计算此 $2\\times 2$ 协方差子矩阵的 2-范数条件数，\n$$\n\\kappa = \\|C\\|_2 \\,\\|C^{-1}\\|_2,\n$$\n其中 $C$ 是 $(E_R,\\Gamma)$ 的协方差子矩阵。\n- 为 $(E_R,\\Gamma)$ 定义一个可辨识性标志 $I$ 如下：如果 $|\\rho_{E_R,\\Gamma}| > 0.95$ 或 $\\kappa > 10^8$，则将 $I$ 设置为 $\\mathrm{False}$（不可辨识），否则设置为 $\\mathrm{True}$。\n\n您的程序必须使用与单能级共振散射和线性背景一致的共振线型来生成合成数据集。能量单位必须是 $\\mathrm{MeV}$，截面单位必须是 barns。使用关于 $E_R$ 对称的均匀间隔能量网格，窗口的半宽与 $\\Gamma$ 成正比。不要添加随机噪声；使用模型精确生成 $y_i$，并为每个测试案例分配一个恒定的 $\\sigma_i$。\n\n为每个测试案例实现加权非线性最小二乘拟合，强制执行不确定度的绝对权重，然后计算：\n- 相关系数 $\\rho_{E_R,\\Gamma}$（无量纲）。\n- 条件数 $\\kappa$（无量纲）。\n- 可辨识性标志 $I$（布尔值）。\n\n测试套件：\n\n提供并解决以下三个测试案例。对于每个案例，能量单位必须是 $\\mathrm{MeV}$，宽度单位是 $\\mathrm{MeV}$，截面单位是 barns，不确定度单位是 barns。每个能量网格必须从 $E_{\\min} = E_R - m\\,\\Gamma$ 到 $E_{\\max} = E_R + m\\,\\Gamma$，包含 $N$ 个均匀间隔的点，其中 $m$ 是一个无量纲的乘数：\n\n- 案例 1（采样良好的共振，中等背景）：\n  - $E_R = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.2\\,\\mathrm{MeV}$，$A = 10.0\\,\\mathrm{barns}$，$B_0 = 1.0\\,\\mathrm{barns}$，$B_1 = 0.2\\,\\mathrm{barns}/\\mathrm{MeV}$，\n  - $m = 8$，$N = 121$，对所有 $i$，$\\sigma_i \\equiv 0.05\\,\\mathrm{barns}$。\n\n- 案例 2（采样粗糙的窄共振）：\n  - $E_R = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.01\\,\\mathrm{MeV}$，$A = 10.0\\,\\mathrm{barns}$，$B_0 = 1.0\\,\\mathrm{barns}$，$B_1 = 0.2\\,\\mathrm{barns}/\\mathrm{MeV}$，\n  - $m = 6$，$N = 21$，对所有 $i$，$\\sigma_i \\equiv 0.05\\,\\mathrm{barns}$。\n\n- 案例 3（窗口有限且背景斜率大）：\n  - $E_R = 5.0\\,\\mathrm{MeV}$，$\\Gamma = 0.5\\,\\mathrm{MeV}$，$A = 5.0\\,\\mathrm{barns}$，$B_0 = 1.0\\,\\mathrm{barns}$，$B_1 = 5.0\\,\\mathrm{barns}/\\mathrm{MeV}$，\n  - $m = 2$，$N = 41$，对所有 $i$，$\\sigma_i \\equiv 0.05\\,\\mathrm{barns}$。\n\n算法期望：\n\n- 您的代码必须从共振散射的基本原理出发证明共振线型的合理性，并使用现代数值程序实现加权非线性最小二乘拟合。\n- 使用适当的权重计算参数协方差，其中 $\\sigma_i$ 被视为绝对不确定度。\n- 提取 $(E_R,\\Gamma)$ 的协方差子矩阵，计算 $\\rho_{E_R,\\Gamma}$ 和 $\\kappa$，并根据上述准则设置可辨识性标志 $I$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，并且本身是一个 $[\\rho_{E_R,\\Gamma}, \\kappa, I]$ 形式的列表。例如，打印的行必须看起来像\n$[[r_1, c_1, b_1],[r_2, c_2, b_2],[r_3, c_3, b_3]]$，\n其中 $r_k$ 和 $c_k$ 是浮点数，$b_k$ 是案例 $k$ 的布尔值。", "solution": "该问题要求实现对一个具有物理动机的共振模型的加权非线性最小二乘拟合，并随后分析参数的相关性和可辨识性。解决方案围绕三个核心部分构建：物理模型的定义、数值拟合过程以及参数不确定度的统计分析。\n\n**1. 物理模型：Breit-Wigner共振**\n\n核散射截面模型基于量子力学中共振散射的基本原理。共振对应于一个准稳中间态的形成，该中间态具有特征能量 $E_R$ 和有限的寿命，其寿命与衰变宽度 $\\Gamma$ 成反比。这种状态的存在导致能量依赖的截面出现一个尖锐的峰。\n\n这种行为由散射矩阵（$S$矩阵）形式化描述。为了保持概率守恒，$S$矩阵必须是幺正的，即 $S^\\dagger S = I$。对于单散射通道中的单个孤立共振，在共振附近，$S$矩阵元可以通过复能量平面中位于 $E = E_R - i\\Gamma/2$ 的一个极点来参数化。这导出了$S$矩阵元的Breit-Wigner公式：\n$$\nS(E) \\approx e^{2i\\delta_{bg}} \\frac{E - E_R - i\\Gamma/2}{E - E_R + i\\Gamma/2}\n$$\n其中 $\\delta_{bg}$ 代表一个缓慢变化的背景相移。对于我们的唯象模型，我们可以通过设置 $\\delta_{bg}=0$ 来简化。弹性散射截面的共振部分 $\\sigma_{\\text{res}}(E)$ 与 $|1 - S(E)|^2$ 成正比。直接计算可得：\n$$\n\\sigma_{\\text{res}}(E) \\propto \\left|1 - \\frac{E - E_R - i\\Gamma/2}{E - E_R + i\\Gamma/2}\\right|^2 = \\left|\\frac{(E - E_R + i\\Gamma/2) - (E - E_R - i\\Gamma/2)}{E - E_R + i\\Gamma/2}\\right|^2 = \\left|\\frac{i\\Gamma}{E - E_R + i\\Gamma/2}\\right|^2 = \\frac{\\Gamma^2}{(E - E_R)^2 + (\\Gamma/2)^2}\n$$\n该函数具有洛伦兹形状。问题指定了一个将此共振结构与简单线性背景相结合的模型。因此，截面 $y(E)$ 的完整模型定义为：\n$$\ny(E; \\theta) = A \\frac{(\\Gamma/2)^2}{(E - E_R)^2 + (\\Gamma/2)^2} + B_0 + B_1 E\n$$\n参数向量为 $\\theta = (E_R, \\Gamma, A, B_0, B_1)$，其中 $E_R$ 是共振能量，$\\Gamma$ 是其半峰全宽（FWHM），$A$ 是共振部分的峰值振幅，$B_0$ 和 $B_1$ 分别是线性背景的截距和斜率。\n\n**2. 加权非线性最小二乘拟合**\n\n任务是为给定的一组合成数据点 $\\{(E_i, y_i, \\sigma_i)\\}_{i=1}^N$ 找到最佳拟合参数 $\\hat{\\theta}$。这是通过最小化加权残差平方和，即卡方统计量 $\\chi^2$ 来实现的：\n$$\n\\chi^2(\\theta) = \\sum_{i=1}^N \\left(\\frac{y_i - y(E_i;\\theta)}{\\sigma_i}\\right)^2\n$$\n最小化此值是一个非线性最小二乘问题。该算法将利用 `scipy.optimize.curve_fit`，这是一个基于 Levenberg-Marquardt 算法的标准程序。每个测试案例的合成数据都是由模型本身生成，没有添加随机噪声，这意味着真实参数 $\\theta_{\\text{true}}$ 对应于全局最小值，此时 $\\chi^2(\\theta_{\\text{true}}) = 0$。拟合使用 $\\theta_{\\text{true}}$ 进行初始化，以确保立即且精确地收敛。将 `absolute_sigma=True` 参数传递给 `curve_fit`，以确保不确定度 $\\sigma_i$ 被作为绝对值处理，这对于输出协方差矩阵的正确缩放至关重要。\n\n**3. 参数协方差与可辨识性分析**\n\n最后一步是评估共振能量 $E_R$ 和宽度 $\\Gamma$ 的可辨识性。这通过分析参数协方差矩阵 $\\mathrm{Cov}(\\hat{\\theta})$ 来完成，该矩阵量化了最佳拟合参数的不确定度和相关性。在非线性最小二乘法中，该矩阵通过费雪信息矩阵的逆来近似。对于独立的高斯误差，其形式为：\n$$\n\\mathrm{Cov}(\\hat{\\theta}) \\approx (J^\\top W J)^{-1}\n$$\n其中 $J$ 是模型关于参数的雅可比矩阵，其元素 $J_{ij} = \\frac{\\partial y(E_i;\\theta)}{\\partial \\theta_j}$ 在最佳拟合解 $\\hat{\\theta}$ 处求值，而 $W$ 是对角权重矩阵，其元素为 $W_{ii} = 1/\\sigma_i^2$。带有 `absolute_sigma=True` 的 `curve_fit` 函数返回的正是这个矩阵。\n\n分析重点关注 $\\mathrm{Cov}(\\hat{\\theta})$ 中对应于参数 $(E_R, \\Gamma)$ 的 $2 \\times 2$ 子矩阵 $C$：\n$$\nC = \\begin{pmatrix} \\mathrm{Var}(E_R)  \\mathrm{Cov}(E_R, \\Gamma) \\\\ \\mathrm{Cov}(\\Gamma, E_R)  \\mathrm{Var}(\\Gamma) \\end{pmatrix}\n$$\n从该子矩阵中计算两个度量：\na) **相关系数** $\\rho_{E_R,\\Gamma}$，它衡量 $E_R$ 和 $\\Gamma$ 估计量之间的线性相互依赖关系：\n$$\n\\rho_{E_R,\\Gamma} = \\frac{C_{12}}{\\sqrt{C_{11}C_{22}}}\n$$\n$|\\rho_{E_R,\\Gamma}|$ 的值接近 1 表示强相关性，这使得区分这两个参数的影响变得困难。\n\nb) 协方差子矩阵 $C$ 的 **2-范数条件数** $\\kappa$，定义为 $\\kappa = \\|C\\|_2 \\|C^{-1}\\|_2$。对于像 $C$ 这样的对称正定矩阵，这是其最大特征值与最小特征值的比值，即 $\\kappa = \\lambda_{\\max}/\\lambda_{\\min}$。大的条件数表示确定 $E_R$ 和 $\\Gamma$ 的问题是病态的，意味着数据中的微小扰动可能导致参数估计值发生巨大变化。\n\n最后，根据指定的准则确定一个**可辨识性标志** $I$：如果 $|\\rho_{E_R,\\Gamma}| > 0.95$ 或者 $\\kappa > 10^8$，则将 $I$ 设置为 $\\mathrm{False}$，否则设置为 $\\mathrm{True}$。程序为所提供的三个测试案例实现了这个完整的工作流程，每个案例代表一个不同的实验情景，并为每个案例输出结果元组 $[\\rho_{E_R,\\Gamma}, \\kappa, I]$。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\nfrom numpy.linalg import cond\n\ndef solve():\n    \"\"\"\n    Performs a weighted nonlinear least-squares fit of a Breit-Wigner resonance model\n    to synthetic data and analyzes the parameter identifiability.\n    \"\"\"\n\n    # --- Model Definition and Justification ---\n    # In nuclear scattering, an isolated resonance can be described by the Breit-Wigner formula.\n    # This arises from parameterizing the S-matrix near a pole E_R - i*Gamma/2 on the complex energy plane,\n    # a consequence of a quasi-bound state with finite lifetime. For single-channel scattering,\n    # the cross-section exhibits a Lorentzian energy dependence. The phenomenological model used here\n    # combines a Lorentzian peak with a linear background, which is a common approach for analyzing\n    # experimental data. The model is:\n    # y(E) = A * (Gamma/2)^2 / ((E - E_R)^2 + (Gamma/2)^2) + B_0 + B_1 * E\n    # The parameters are theta = (E_R, Gamma, A, B0, B1).\n    def resonance_model(E, E_R, Gamma, A, B0, B1):\n        \"\"\"\n        Defines the resonance model: a Breit-Wigner-like Lorentzian plus a linear background.\n\n        Args:\n            E (float or array): Center-of-mass energy in MeV.\n            E_R (float): Resonance energy in MeV.\n            Gamma (float): Resonance total width in MeV.\n            A (float): Resonance amplitude in barns.\n            B0 (float): Background intercept in barns.\n            B1 (float): Background slope in barns/MeV.\n\n        Returns:\n            float or array: Cross section in barns.\n        \"\"\"\n        lorentzian = A * (Gamma / 2.0)**2 / ((E - E_R)**2 + (Gamma / 2.0)**2)\n        background = B0 + B1 * E\n        return lorentzian + background\n\n    test_cases = [\n        # Case 1: Well-sampled resonance, moderate background.\n        {\"params\": (5.0, 0.2, 10.0, 1.0, 0.2), \"m\": 8.0, \"N\": 121, \"sigma\": 0.05},\n        # Case 2: Narrow resonance with coarse sampling.\n        {\"params\": (5.0, 0.01, 10.0, 1.0, 0.2), \"m\": 6.0, \"N\": 21, \"sigma\": 0.05},\n        # Case 3: Limited window with strong background slope.\n        {\"params\": (5.0, 0.5, 5.0, 1.0, 5.0), \"m\": 2.0, \"N\": 41, \"sigma\": 0.05},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        p_true = case[\"params\"]\n        E_R_true, Gamma_true, _, _, _ = p_true\n        m, N, sigma_val = case[\"m\"], case[\"N\"], case[\"sigma\"]\n\n        # --- Step 1: Generate Synthetic Data ---\n        # The data is generated without noise, so y_i = y(E_i; theta_true).\n        E_min = E_R_true - m * Gamma_true\n        E_max = E_R_true + m * Gamma_true\n        E_data = np.linspace(E_min, E_max, N)\n        y_data = resonance_model(E_data, *p_true)\n        sigma_data = np.full_like(y_data, sigma_val)\n\n        # --- Step 2: Perform Weighted Nonlinear Least-Squares Fit ---\n        # We use the true parameters as the initial guess to ensure convergence\n        # to the exact solution, as the data is noise-free.\n        # 'absolute_sigma=True' is crucial. It ensures the covariance matrix pcov\n        # is calculated as (J^T W J)^-1, where W_ii = 1/sigma_i^2, as required.\n        try:\n            _, pcov = curve_fit(\n                resonance_model,\n                E_data,\n                y_data,\n                p0=p_true,\n                sigma=sigma_data,\n                absolute_sigma=True,\n                check_finite=True\n            )\n        except RuntimeError:\n            # In ill-conditioned cases, the fit might fail.\n            # Represent this scenario with NaN values.\n            all_results.append([np.nan, np.nan, False])\n            continue\n        \n        # --- Step 3: Analyze Parameter Covariance and Identifiability ---\n        # Extract the 2x2 covariance submatrix for (E_R, Gamma).\n        # The order of parameters is (E_R, Gamma, A, B0, B1).\n        C_ER_Gamma = pcov[0:2, 0:2]\n\n        # Compute the correlation coefficient rho_{E_R, Gamma}.\n        var_ER = C_ER_Gamma[0, 0]\n        var_Gamma = C_ER_Gamma[1, 1]\n        cov_ER_Gamma = C_ER_Gamma[0, 1]\n        \n        # Avoid division by zero if variances are zero or negative (numerical instability)\n        if var_ER = 0 or var_Gamma = 0:\n            rho = np.nan\n        else:\n            rho = cov_ER_Gamma / np.sqrt(var_ER * var_Gamma)\n\n        # Compute the 2-norm condition number kappa of the submatrix.\n        kappa = cond(C_ER_Gamma, 2)\n\n        # Determine the identifiability flag I based on the given criteria.\n        is_identifiable = not (np.abs(rho) > 0.95 or kappa > 1e8)\n\n        # Append results for this case. Ensure boolean is a native Python bool.\n        all_results.append([rho, kappa, bool(is_identifiable)])\n\n    # --- Final Output Formatting ---\n    # The output must be a single line: [[r1, c1, b1],[r2, c2, b2],...].\n    # The `str` representation of a list of lists matches this format.\n    formatted_results = \",\".join(map(str, all_results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "3596468"}]}