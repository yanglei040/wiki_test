{"hands_on_practices": [{"introduction": "xorshift 生成器以其高效和简洁的实现而闻名，但其背后是建立在有限域 $GF(2)$ 上的严谨线性代数结构。要深入分析这类生成器的周期、随机性等理论性质，第一步也是最关键的一步，就是将其位运算更新规则转化为一个线性变换矩阵。这项练习 [@problem_id:3320137] 将指导你完成这一过程，通过构建 `xorshift128` 生成器的状态转移矩阵，让你亲身体验如何将算法实现与抽象的数学模型联系起来。", "problem": "考虑一个称为 xorshift128 的四字 xorshift 生成器。其在步骤 $n$ 的内部状态是一个 $128$ 位向量 $s_{n} \\in \\{0,1\\}^{128}$，划分为四个 $32$ 位字 $x_{n}, y_{n}, z_{n}, w_{n} \\in \\{0,1\\}^{32}$。按位异或是伽罗瓦域 (GF) $\\mathbb{F}_{2}$ 上向量空间中的群运算，因此所有更新都是在 $\\mathbb{F}_{2}$ 上线性的。在一个 $32$ 位字上定义左移 $k$ 位和右移 $k$ 位的映射，通过补零和丢弃移出的位来实现。令 $S_{L}(k) \\in \\mathbb{F}_{2}^{32 \\times 32}$ 和 $S_{R}(k) \\in \\mathbb{F}_{2}^{32 \\times 32}$ 表示实现这些映射的矩阵，使得对于任何 $u \\in \\{0,1\\}^{32}$，都有 $(u \\ll k) = S_{L}(k) u$ 和 $(u \\gg k) = S_{R}(k) u$。具体来说，对于索引 $i,j \\in \\{0,1,\\dots,31\\}$，取\n$$\n\\big(S_{L}(k)\\big)_{i,j} =\n\\begin{cases}\n1  \\text{if } j+k = i, \\\\\n0  \\text{otherwise},\n\\end{cases}\n\\qquad\n\\big(S_{R}(k)\\big)_{i,j} =\n\\begin{cases}\n1  \\text{if } j = i+k, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n考虑以下更新规则（移位参数为 $a = 11$, $b = 8$ 和 $c = 19$）：\n$$\nt_{n} = x_{n} \\oplus (x_{n} \\ll a), \\quad\nx_{n+1} = y_{n}, \\quad\ny_{n+1} = z_{n}, \\quad\nz_{n+1} = w_{n}, \\quad\nw_{n+1} = w_{n} \\oplus (w_{n} \\gg c) \\oplus t_{n} \\oplus (t_{n} \\gg b),\n$$\n其中 $\\oplus$ 表示在 $\\mathbb{F}_{2}$ 中的加法，$\\ll, \\gg$ 表示上面定义的左移和右移。通过堆叠这些字，将状态表示为列向量\n$$\ns_{n} =\n\\begin{pmatrix}\nx_{n} \\\\\ny_{n} \\\\\nz_{n} \\\\\nw_{n}\n\\end{pmatrix}\n\\in \\mathbb{F}_{2}^{128}.\n$$\n任务：\n- 仅使用 $\\mathbb{F}_{2}$ 上的线性代数基元以及 $S_{L}(k)$ 和 $S_{R}(k)$ 的定义，构造 $\\mathbb{F}_{2}$-线性转移矩阵 $M \\in \\mathbb{F}_{2}^{128 \\times 128}$，使得 $s_{n+1} = M s_{n}$，其形式为包含 $32 \\times 32$ 分块的分块矩阵。用 $I_{32}$、$S_{L}(a)$ 和 $S_{R}(b), S_{R}(c)$ 表示这些分块。\n- 计算 $M$ 的特征多项式 $p(\\lambda) \\in \\mathbb{F}_{2}[\\lambda]$，使用一个关于 $\\lambda$ 的 $32 \\times 32$ 矩阵多项式的行列式，以闭合形式表示它。\n- 根据有限域上线性递推的第一性原理，确定生成器在非零状态空间 $\\mathbb{F}_{2}^{128} \\setminus \\{0\\}$ 上的周期。\n\n将您的最终答案以单行矩阵的形式提供，该矩阵包含三个条目：$M$ 的分块表达式、特征多项式 $p(\\lambda)$ 和周期表达式；条目可以是矩阵或标量解析表达式，周期必须精确表示，无需数值近似。不需要四舍五入，也不涉及物理单位。答案必须是指定格式的计算对象。", "solution": "用户希望我解决一个关于 xorshift128 生成器的问题。\n\n### 步骤 1：问题验证\n\n我将首先验证问题陈述。\n\n#### 步骤 1.1：提取已知条件\n\n-   **状态空间**：在步骤 $n$ 的状态是一个 $128$ 位向量 $s_{n} \\in \\{0,1\\}^{128}$，它被划分为四个 $32$ 位字 $x_{n}, y_{n}, z_{n}, w_{n} \\in \\{0,1\\}^{32}$。\n-   **域**：所有运算都在伽罗瓦域 $\\mathbb{F}_{2}$ 中进行。按位异或 ($\\oplus$) 对应于加法。\n-   **移位算子**：左移 ($u \\ll k$) 和右移 ($u \\gg k$) 映射分别由矩阵 $S_{L}(k) \\in \\mathbb{F}_{2}^{32 \\times 32}$ 和 $S_{R}(k) \\in \\mathbb{F}_{2}^{32 \\times 32}$ 表示。它们的定义如下：\n    $$ \\big(S_{L}(k)\\big)_{i,j} = \\begin{cases} 1  \\text{if } j+k = i, \\\\ 0  \\text{otherwise}, \\end{cases} \\qquad \\big(S_{R}(k)\\big)_{i,j} = \\begin{cases} 1  \\text{if } j = i+k, \\\\ 0  \\text{otherwise}. \\end{cases} $$\n-   **常数**：给定的移位参数为 $a = 11$, $b = 8$ 和 $c = 19$。\n-   **递推关系**：状态更新规则如下：\n    $$\n    t_{n} = x_{n} \\oplus (x_{n} \\ll a) \\\\\n    x_{n+1} = y_{n} \\\\\n    y_{n+1} = z_{n} \\\\\n    z_{n+1} = w_{n} \\\\\n    w_{n+1} = w_{n} \\oplus (w_{n} \\gg c) \\oplus t_{n} \\oplus (t_{n} \\gg b)\n    $$\n-   **状态向量**：状态由列向量 $s_{n} = (x_{n}^T, y_{n}^T, z_{n}^T, w_{n}^T)^T \\in \\mathbb{F}_{2}^{128}$ 表示。\n-   **任务**：\n    1.  构造转移矩阵 $M \\in \\mathbb{F}_{2}^{128 \\times 128}$ 使得 $s_{n+1} = M s_{n}$，并用 $I_{32}$、$S_{L}(a)$、$S_{R}(b)$ 和 $S_{R}(c)$ 表示其 $32 \\times 32$ 的分块。\n    2.  计算 $M$ 的特征多项式 $p(\\lambda) \\in \\mathbb{F}_{2}[\\lambda]$。\n    3.  确定生成器在非零状态空间 $\\mathbb{F}_{2}^{128} \\setminus \\{0\\}$ 上的周期。\n\n#### 步骤 1.2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题描述了一个称为 xorshift 生成器的线性反馈移位寄存器 (LFSR)。这是计算数学和计算机科学中的一个标准且易于理解的课题，特别是在伪随机数生成领域。其数学框架是基于有限域 $\\mathbb{F}_{2}$ 上的线性代数，这是严谨且完善的。该问题具有科学合理性。\n-   **适定性**：该问题提供了一个线性动力系统的完整定义，并要求求解其转移矩阵、特征多项式和周期。这些都是明确定义的数学对象，可以从给定信息中唯一确定。该问题是适定的。\n-   **客观性**：该问题以精确、形式化的数学语言陈述，没有任何主观性、模糊性或观点。它纯粹是客观的。\n\n#### 步骤 1.3：结论与行动\n\n该问题是有效的，因为它具有科学依据、适定性和客观性。我将继续进行求解。\n\n### 步骤 2：求解过程\n\n#### 任务 1：构造转移矩阵 $M$\n\n状态更新由线性变换 $s_{n+1} = M s_n$ 给出。我们需要找到 $\\mathbb{F}_2$ 上的 $128 \\times 128$ 矩阵 $M$ 的 $4 \\times 4$ 分块形式，其中每个分块是一个 $32 \\times 32$ 的矩阵。状态向量为 $s_n = (x_n^T, y_n^T, z_n^T, w_n^T)^T$ 和 $s_{n+1} = (x_{n+1}^T, y_{n+1}^T, z_{n+1}^T, w_{n+1}^T)^T$。\n\n前三个字的更新规则是分块向量中的简单移位：\n$x_{n+1} = y_n \\implies x_{n+1} = 0 \\cdot x_n + I_{32} \\cdot y_n + 0 \\cdot z_n + 0 \\cdot w_n$\n$y_{n+1} = z_n \\implies y_{n+1} = 0 \\cdot x_n + 0 \\cdot y_n + I_{32} \\cdot z_n + 0 \\cdot w_n$\n$z_{n+1} = w_n \\implies z_{n+1} = 0 \\cdot x_n + 0 \\cdot y_n + 0 \\cdot z_n + I_{32} \\cdot w_n$\n\n这些方程确定了矩阵 $M$ 的前三个分块行：\n- 第 1 行：$[0, I_{32}, 0, 0]$\n- 第 2 行：$[0, 0, I_{32}, 0]$\n- 第 3 行：$[0, 0, 0, I_{32}]$\n\n现在我们分析 $w_{n+1}$ 的更新。首先，我们将中间项 $t_n$ 表示为矩阵形式：\n$t_n = x_n \\oplus (x_n \\ll a) = I_{32} x_n + S_L(a) x_n = (I_{32} + S_L(a)) x_n$。\n\n接下来，我们用第 $n$ 步的字来表示 $w_{n+1}$。所有算术运算都在 $\\mathbb{F}_2$ 中。\n$w_{n+1} = w_n \\oplus (w_n \\gg c) \\oplus t_n \\oplus (t_n \\gg b)$\n利用移位算子的线性性质，我们可以将其写成矩阵形式：\n$w_{n+1} = (I_{32} w_n + S_R(c) w_n) + (I_{32} t_n + S_R(b) t_n)$\n$w_{n+1} = (I_{32} + S_R(c)) w_n + (I_{32} + S_R(b)) t_n$\n\n现在代入 $t_n$ 的表达式：\n$w_{n+1} = (I_{32} + S_R(c)) w_n + (I_{32} + S_R(b)) (I_{32} + S_L(a)) x_n$\n\n该方程给出了 $M$ 的第四个分块行：\n$w_{n+1} = M_{41} x_n + M_{42} y_n + M_{43} z_n + M_{44} w_n$。\n通过比较系数，我们确定这些分块：\n$M_{41} = (I_{32} + S_R(b))(I_{32} + S_L(a))$\n$M_{42} = 0$\n$M_{43} = 0$\n$M_{44} = I_{32} + S_R(c)$\n\n组合这些分块，转移矩阵 $M$ 是一个分块友矩阵：\n$$\nM = \\begin{pmatrix}\n0 & I_{32} & 0 & 0 \\\\\n0 & 0 & I_{32} & 0 \\\\\n0 & 0 & 0 & I_{32} \\\\\n(I_{32} + S_R(b))(I_{32} + S_L(a)) & 0 & 0 & I_{32} + S_R(c)\n\\end{pmatrix}\n$$\n\n#### 任务 2：计算特征多项式 $p(\\lambda)$\n\n特征多项式是 $p(\\lambda) = \\det(M - \\lambda I_{128})$。因为我们工作在 $\\mathbb{F}_2$ 上，这等价于 $p(\\lambda) = \\det(M + \\lambda I_{128})$。\n$$\nM + \\lambda I_{128} = \\begin{pmatrix}\n\\lambda I_{32} & I_{32} & 0 & 0 \\\\\n0 & \\lambda I_{32} & I_{32} & 0 \\\\\n0 & 0 & \\lambda I_{32} & I_{32} \\\\\nA & 0 & 0 & B + \\lambda I_{32}\n\\end{pmatrix}\n$$\n其中 $A = (I_{32} + S_R(b))(I_{32} + S_L(a))$ 且 $B = I_{32} + S_R(c)$。\n对于形如\n$$ C = \\begin{pmatrix} 0 & I & \\dots & 0 \\\\ \\vdots &  & \\ddots & \\\\ 0 & 0 & \\dots & I \\\\ C_0 & C_1 & \\dots & C_{k-1} \\end{pmatrix} $$\n的分块友矩阵，其特征多项式由 $\\det(\\lambda^k I - \\sum_{i=0}^{k-1} \\lambda^i C_i)$ 给出。\n在我们的情况下，$k=4$，分块是 $32 \\times 32$ 的矩阵。系数是：\n$C_0 = A = (I_{32} + S_R(b))(I_{32} + S_L(a))$\n$C_1 = 0$\n$C_2 = 0$\n$C_3 = B = I_{32} + S_R(c)$\n\n在一般域上，特征多项式将是 $\\det(\\lambda^4 I_{32} - \\lambda^3 C_3 - \\lambda^2 C_2 - \\lambda^1 C_1 - C_0)$。\n在 $\\mathbb{F}_2$ 中工作，减法与加法相同。因此，特征多项式是：\n$p(\\lambda) = \\det(\\lambda^4 I_{32} + \\lambda^3 C_3 + \\lambda^2 C_2 + \\lambda C_1 + C_0)$\n代入 $C_i$ 的值：\n$p(\\lambda) = \\det(\\lambda^4 I_{32} + \\lambda^3 (I_{32} + S_R(c)) + \\lambda^2(0) + \\lambda(0) + (I_{32} + S_R(b))(I_{32} + S_L(a)))$\n这简化为：\n$$\np(\\lambda) = \\det(\\lambda^4 I_{32} + \\lambda^3 (I_{32} + S_R(c)) + (I_{32} + S_R(b))(I_{32} + S_L(a)))\n$$\n这是一个在 $\\mathbb{F}_2[\\lambda]$ 中次数为 $4 \\times 32 = 128$ 的多项式。\n\n#### 任务 3：确定生成器的周期\n\n状态序列由 $s_{n+1} = M s_n$ 生成。由于变换 $M$ 是线性的且可逆的（因为 $\\det(M) = \\det(A) = \\det(I+S_R(b))\\det(I+S_L(a)) = 1 \\cdot 1 = 1$，因为 $S_L(a)$ 和 $S_R(b)$ 是幂零矩阵，而在特征为 2 的域中，对于幂零矩阵 $N$，$I+N$ 是可逆的），状态 $s_n=0$ 是一个不动点。对于任何非零初始状态 $s_0 \\in \\mathbb{F}_2^{128} \\setminus \\{0\\}$，状态序列 $s_n$ 是周期的。周期是使 $s_k=s_0$ 的最小正整数 $k$，这等价于求矩阵 $M$ 在一般线性群 $GL(128, \\mathbb{F}_2)$ 中的阶。\n\n根据有限域上线性递推的理论，一个 $d$ 维递推的最大可能周期是 $2^d - 1$。当且仅当转移矩阵的特征多项式 $p(\\lambda)$ 是 $\\mathbb{F}_2$ 上的一个 $d$ 次本原多项式时，才能达到这个最大周期。本原多项式是一个不可约多项式，它同时也是扩域 $\\mathbb{F}_{2^d}$ 的乘法群的生成元。\n\n本问题中描述的生成器，其参数为 $a=11, b=8, c=19$，是由 George Marsaglia 设计的 `xorshift128` 生成器的一个具体实例。这类生成器是通过仔细选择移位参数来构造的，以确保最终的特征多项式是本原的。问题指明了生成器的名称，这隐含地提供了它具有最大周期的信息。从第一性原理证明一个 128 次多项式的本原性是一项计算复杂度极高的任务，超出了本问题的范围。这里要应用的原理是本原特征多项式与最长序列之间的联系。\n\n鉴于特征多项式 $p(\\lambda)$ 是 $\\mathbb{F}_2$ 上的一个 128 次本原多项式，转移矩阵 $M$ 是 $GL(128, \\mathbb{F}_2)$ 中一个阶为 $2^{128}-1$ 的循环子群的生成元。因此，状态空间 $\\mathbb{F}_2^{128} \\setminus \\{0\\}$ 被划分为一个长度为 $2^{128}-1$ 的单一循环。\n\n因此，生成器在非零状态空间上的周期是 $2^{128} - 1$。", "answer": "$$ \\boxed{ \\begin{pmatrix} \\begin{pmatrix} 0 & I_{32} & 0 & 0 \\\\ 0 & 0 & I_{32} & 0 \\\\ 0 & 0 & 0 & I_{32} \\\\ (I_{32} + S_R(b))(I_{32} + S_L(a)) & 0 & 0 & I_{32} + S_R(c) \\end{pmatrix} & \\det(\\lambda^4 I_{32} + \\lambda^3 (I_{32} + S_R(c)) + (I_{32} + S_R(b))(I_{32} + S_L(a))) & 2^{128} - 1 \\end{pmatrix} } $$", "id": "3320137"}, {"introduction": "伪随机数生成器的质量与其状态空间的循环结构密切相关，而这又由其转移矩阵的特征多项式决定。一个理想的生成器拥有一个巨大的主循环，但当特征多项式不是本原多项式时，状态空间会分裂成多个长短不一的循环，这通常是设计缺陷的标志。这项练习 [@problem_id:3320141] 模拟了这种情况，通过分析一个具有可约特征多项式的类梅森旋转生成器，让你能够运用代数理论来精确预测和量化这些“短循环”的存在。", "problem": "梅森旋转算法 (MT) 状态转移的一个抽象是在二元域 $\\mathbb{F}_{2}$ 上的一个可逆线性映射，作用于一个有限维 $\\mathbb{F}_{2}$-向量空间。考虑一个作用于 $\\mathbb{F}_{2}^{12}$ 上的玩具梅森旋转算法 (MT) 状态转移 $T$，其具有以下性质。\n\n1. $T$ 的特征多项式为 \n$$\nP(x) \\;=\\; p_{1}(x)\\,p_{2}(x),\n$$\n其中 $p_{1}(x)$ 和 $p_{2}(x)$ 是 $\\mathbb{F}_{2}$ 上次数分别为 $8$ 和 $4$ 的不同首一不可约多项式，每个都有非零常数项。假设 $p_{2}(x)=x^{4}+x+1$ 且 $p_{1}(x)$ 是某个固定的 $8$ 次不可约多项式。\n\n2. 将 $\\mathbb{F}_{2}^{12}$ 视为由 $T$ 的作用 $x\\cdot v := T(v)$ 得到的 $\\mathbb{F}_{2}[x]$-模。根据模的中国剩余定理以及 $p_{1}$ 和 $p_{2}$ 的互质性，该空间分解为一个 $\\mathbb{F}_{2}[x]$-模\n$$\n\\mathbb{F}_{2}^{12} \\;\\cong\\; \\mathbb{F}_{2}[x]/(p_{1}) \\;\\oplus\\; \\mathbb{F}_{2}[x]/(p_{2}),\n$$\n其中 $T$ 的作用对应于在每个分量中乘以 $x$ 的剩余类。\n\n3. 设 $m_{i}$ 表示 $x$ 的剩余类在单位群 $\\big(\\mathbb{F}_{2}[x]/(p_{i})\\big)^{\\times}$ 中的乘法阶，它能整除 $2^{\\deg p_{i}}-1$。已知 $\\deg p_{2}=4$ 且 $p_{2}(x)=x^{4}+x+1$ 是本原多项式，阶为 $m_{2}=15$，并且存在一个 $8$ 次不可约多项式 $p_{1}$，其阶为 $m_{1}=17$（非本原）。假设对于给定的 $p_{1}$ 和 $p_{2}$，这些阶成立。\n\n仅使用 $\\mathbb{F}_{2}$ 上的线性性和上述结构性事实，完成以下任务：\n\na) 根据状态对 $(u,v) \\in \\mathbb{F}_{2}[x]/(p_{1}) \\oplus \\mathbb{F}_{2}[x]/(p_{2})$ 在每个分量上是零或非零的四种不相交的类别，推导出 $T$ 在 $\\mathbb{F}_{2}^{12}$ 上的圈结构。用 $m_{1}$ 和 $m_{2}$ 表示每个类别中状态的周期，并从第一性原理证明你的结论。\n\nb) 计算一个一般非零状态（即分量 $u$ 和 $v$ 均非零）的周期。并计算有多少状态具有此一般周期，以及存在多少个此一般周期的圈。\n\nc) 定义“短圈”为长度严格小于一般周期的任何圈。确定总共有多少个短圈。将你的最终答案以单个整数形式给出（无单位）。", "solution": "问题描述了在二元域 $\\mathbb{F}_{2}$ 上的向量空间 $V = \\mathbb{F}_{2}^{12}$ 上的一个线性变换 $T$。该变换的结构由其特征多项式 $P(x) = p_{1}(x)p_{2}(x)$ 给出，其中 $p_{1}(x)$ 和 $p_{2}(x)$ 是 $\\mathbb{F}_{2}$ 上次数分别为 $\\deg p_{1} = 8$ 和 $\\deg p_{2} = 4$ 的不同不可约多项式。\n\n由于 $p_{1}(x)$ 和 $p_{2}(x)$ 互质，多项式环的中国剩余定理意味着空间 $V$ 可分解为 $T$-不变子空间 $V_1$ 和 $V_2$ 的直和：\n$$\nV \\cong V_1 \\oplus V_2\n$$\n其中 $V_1 = \\ker(p_1(T))$ 和 $V_2 = \\ker(p_2(T))$。作为 $\\mathbb{F}_{2}[x]$-模，其中 $x$ 的作用对应于 $T$ 的作用，该分解给出为：\n$$\nV \\cong \\frac{\\mathbb{F}_{2}[x]}{(p_{1}(x))} \\oplus \\frac{\\mathbb{F}_{2}[x]}{(p_{2}(x))}\n$$\n子空间 $V_1$ 和 $V_2$ 分别是 $\\mathbb{F}_2$ 上维度为 $\\deg p_1 = 8$ 和 $\\deg p_2 = 4$ 的向量空间。因此， $|V_1| = 2^8 = 256$ 且 $|V_2| = 2^4 = 16$。$V$ 中状态的总数为 $|V_1| \\times |V_2| = 2^8 \\times 2^4 = 2^{12} = 4096$。\n\n$V$ 中的任何状态 $w$ 都可以唯一地表示为一个对 $(u, v)$，其中 $u \\in V_1$ 且 $v \\in V_2$。$T$ 在这样的对上的作用是分量式的：$T(w) = T((u, v)) = (T_1(u), T_2(v))$，其中 $T_1$ 和 $T_2$ 是 $T$ 在 $V_1$ 和 $V_2$ 上的限制。在模表示中，$T_1$ 对应于在 $\\mathbb{F}_2[x]/(p_1(x))$ 中乘以 $x$，$T_2$ 对应于在 $\\mathbb{F}_2[x]/(p_2(x))$ 中乘以 $x$。\n\n状态 $w=(u,v)$ 的周期是使 $T^k(w) = w$ 的最小正整数 $k$。这等价于条件 $T_1^k(u) = u$ 和 $T_2^k(v) = v$。\n\na) 为了推导圈结构，我们根据分量 $u$ 和 $v$ 是零还是非零来对状态进行分类。\n\n1.  **第1类：$u=0, v=0$**。这对应于零状态 $w=(0,0) \\in V$。$T(0,0) = (0,0)$，所以周期为 $1$。恰好有 $1$ 个这样的状态，形成一个长度为 $1$ 的单个圈。\n\n2.  **第2类：$u \\neq 0, v=0$**。状态为 $w=(u,0)$，其中 $u \\in V_1 \\setminus \\{0\\}$。周期 $k$ 是使 $T_1^k(u) = u$ 的最小整数。由于 $p_1(x)$ 是不可约的，$V_1 \\cong \\mathbb{F}_2[x]/(p_1(x))$ 是一个域，具体来说是有限域 $\\mathbb{F}_{2^8}$。对于任何非零 $u \\in V_1$，方程 $T_1^k(u) = u$ 等价于 $x^k u = u$。因为 $V_1$ 是一个域，我们可以乘以 $u^{-1}$ 得到 $V_1$ 中的 $x^k = 1$。满足此条件的最小正整数 $k$ 是 $x$ 的剩余类在群 $(\\mathbb{F}_2[x]/(p_1(x)))^\\times$ 中的乘法阶。问题给出这个阶为 $m_1 = 17$。因此，此类中的每个状态的周期都为 $m_1 = 17$。\n\n3.  **第3类：$u=0, v \\neq 0$**。状态为 $w=(0,v)$，其中 $v \\in V_2 \\setminus \\{0\\}$。通过与第2类完全相同的推理，周期由 $x$ 在域 $V_2 \\cong \\mathbb{F}_2[x]/(p_2(x)) = \\mathbb{F}_{2^4}$ 中的乘法阶确定。问题给出 $p_2(x) = x^4+x+1$ 是本原多项式，所以这个阶是 $m_2 = 2^4 - 1 = 15$。因此，此类中的每个状态的周期都为 $m_2 = 15$。\n\n4.  **第4类：$u \\neq 0, v \\neq 0$**。周期 $k$ 必须同时满足 $T_1^k(u)=u$ 和 $T_2^k(v)=v$。这等价于在 $V_1$ 中 $x^k=1$ 且在 $V_2$ 中 $x^k=1$。这意味着 $k$ 必须是阶 $m_1$ 和 $m_2$ 的公倍数。满足此条件的最小正整数 $k$ 是这些阶的最小公倍数。此类中任何状态的周期都是 $\\operatorname{lcm}(m_1, m_2)$。\n\nb) 一个一般非零状态是两个分量都非零的状态，即来自第4类的状态。\n\n一般状态的周期是 $\\operatorname{lcm}(m_1, m_2) = \\operatorname{lcm}(17, 15)$。因为 $17$ 是素数且 $15 = 3 \\times 5$，所以 $\\gcd(17, 15) = 1$。因此，周期是 $\\operatorname{lcm}(17, 15) = 17 \\times 15 = 255$。\n\n具有此一般周期的状态数是选择一个非零 $u \\in V_1$ 和一个非零 $v \\in V_2$ 的方式数。\n选择非零 $u$ 的数量是 $|V_1| - 1 = 2^8 - 1 = 256 - 1 = 255$。\n选择非零 $v$ 的数量是 $|V_2| - 1 = 2^4 - 1 = 16 - 1 = 15$。\n具有一般周期的状态总数为 $(2^8-1)(2^4-1) = 255 \\times 15 = 3825$。\n\n这 $3825$ 个状态被划分为不相交的圈，每个圈的长度为 $255$。此类圈的数量是状态总数除以圈长：\n圈数 = $\\frac{3825}{255} = 15$。\n\nc) “短圈”是长度严格小于一般周期 $255$ 的圈。这些对应于第1、2和3类中的状态。我们必须计算圈的数量，而不是状态的数量。\n\n-   **长度为 1 的圈**：这些来自第1类的状态。有 $1$ 个这样的状态，$(0,0)$，它形成 $1$ 个长度为 $1$ 的圈。\n\n-   **长度为 17 的圈**：这些来自第2类的状态 ($u \\neq 0, v=0$)。有 $|V_1|-1 = 2^8-1 = 255$ 个这样的状态。这些状态中的每一个都位于一个长度为 $m_1=17$ 的圈上。此类圈的数量是 $\\frac{255}{17} = 15$。\n\n-   **长度为 15 的圈**：这些来自第3类的状态 ($u=0, v \\neq 0$)。有 $|V_2|-1 = 2^4-1 = 15$ 个这样的状态。这些状态中的每一个都位于一个长度为 $m_2=15$ 的圈上。此类圈的数量是 $\\frac{15}{15} = 1$。\n\n长度 $1$、$15$ 和 $17$ 都严格小于 $255$。短圈的总数是这些长度的圈数的总和。\n短圈总数 = (长度为 $1$ 的圈数) + (长度为 $15$ 的圈数) + (长度为 $17$ 的圈数)。\n短圈总数 = $1 + 1 + 15 = 17$。", "answer": "$$\\boxed{17}$$", "id": "3320141"}, {"introduction": "理论分析揭示了生成器的内部结构，而经验测试则检验其在实际应用中的表现。一个常见的实践问题是，某些“简单”的初始种子（如汉明权重极低的种子）可能会导致生成器需要很长一段时间的“预热”才能产生统计上看似随机的序列。这项编码练习 [@problem_id:3320097] 要求你通过编程来量化这一“瞬态”效应，比较 xorshift 和梅森旋转生成器在不同种子下的行为，从而将抽象的位级动态与最终浮点数输出的统计特性联系起来。", "problem": "您需要设计并实现一个程序，该程序对两类伪随机数生成器的汉明权重动态进行经验性研究，并评估低汉明权重的种子是否会在相关的单位区间均匀分布 (U(0,1)) 输出序列中引发长瞬态。这两种生成器是梅森旋转算法 (Mersenne Twister, MT) 和单步异或移位 (xorshift) 生成器。\n\n从以下基本概念开始：\n- 伪随机数生成器 (PRNG) 是一个确定性映射，它生成一个序列，旨在近似来自目标分布（通常是单位区间上的均匀分布 U(0,1)）的独立样本。\n- 许多 PRNG 的状态天然地在二元域上建模，其状态转移在二元域上是线性的，或者是位运算的组合。对于表示为 $w$ 位字的状态，一个字 $x$ 的汉明权重 $H(x)$ 是其等于 $1$ 的位置数量。\n- 对于一个 $w$ 位的输出 $x$，到单位区间均匀分布 (U(0,1)) 的映射定义为 $u = x / 2^w$。\n\n需要研究的两种 PRNG 是：\n1. 梅森旋转算法 (Mersenne Twister, MT)，其内部状态转移可以写成二元域上的线性变换，$x_{n+1} = A x_n$，其中 $A$ 是由算法决定的固定矩阵。在实现中，不要构建 $A$；而是使用一个参考实现来生成 $w$ 位输出，并将更新规则抽象地视为线性的。\n2. 一个单步 xorshift 生成器，定义如下：\n$$\nx_{n+1} = x_n \\oplus (x_n \\ll a) \\oplus (x_n \\gg b),\n$$\n其中 $\\oplus$ 表示按位异或，$\\ll$ 表示左移，$\\gg$ 表示右移。每次更新后，通过与 $2^w - 1$ 进行掩码操作，将状态保持为 $w$ 位。\n\n对于两种生成器：\n- 将输出字表示为一个 $w$ 位无符号整数，并将其映射为 $u_n = x_n / 2^w$ 以获得一个在 $[0,1)$ 区间内的值。\n- 定义在时间 $n$ 的经验样本均值为 $m_n = \\frac{1}{n}\\sum_{k=1}^n u_k$。\n- 定义在时间 $n$ 的瞬时归一化汉明权重为 $r_n = H(x_n)/w$。\n\n对于给定的生成器和种子，将瞬态长度 $T$ 定义为最小的索引 $n^\\star$，使得对于索引窗口 $j \\in \\{n^\\star, n^\\star+1, \\dots, n^\\star+W-1\\}$，以下两个条件\n$$\n\\lvert m_j - 0.5 \\rvert \\le \\varepsilon \\quad \\text{和} \\quad \\lvert r_j - 0.5 \\rvert \\le \\delta\n$$\n同时成立，并附加约束条件 $n^\\star \\ge n_{\\min}$。如果在 $N_{\\max}$ 范围内不存在这样的 $n^\\star$，则设 $T = N_{\\max}$。\n\n在所有测试中使用以下固定参数：\n- 字宽 $w = 32$。\n- Xorshift 参数 $a = 13$ 和 $b = 17$。\n- 窗口长度 $W = 512$。\n- 最小起始索引 $n_{\\min} = 64$。\n- 最大步数 $N_{\\max} = 100000$。\n- 均值容差 $\\varepsilon = 0.01$。\n- 汉明权重容差 $\\delta = 0.125$。\n- 对于到 U(0,1) 的映射，始终使用 $u_n = x_n / 2^w$。\n\n完全按照所述实现 xorshift 更新。对于梅森旋转算法 (MT)，使用一个 MT19937 的参考实现来产生 $w$ 位输出，并应用 U(0,1) 映射。\n\n测试套件：\n使用以下 $w$ 位种子，为两种生成器计算瞬态长度 $T$：\n- $s^{(1)} = 1$ (汉明权重为 $1$)。\n- $s^{(2)} = 2^{31} + 1$ (汉明权重为 $2$)。\n- $s^{(3)} = 0x12345678$ (一个典型的中等权重模式)。\n- $s^{(4)} = 2^{32} - 1$ (汉明权重为 $32$)。\n- $s^{(5)} = 0$ (xorshift 的吸收态)。\n\n对于顺序为 $s^{(1)}, s^{(2)}, s^{(3)}, s^{(4)}, s^{(5)}$ 的每个种子 $s^{(i)}$，计算并报告数对 $[T_{\\text{xorshift}}, T_{\\text{MT}}]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个与种子对应的 5 个数对的逗号分隔列表，用方括号括起来，不含空格。例如：\n$$\n[ [T_{\\text{xorshift}}^{(1)},T_{\\text{MT}}^{(1)}],[T_{\\text{xorshift}}^{(2)},T_{\\text{MT}}^{(2)}],\\dots,[T_{\\text{xorshift}}^{(5)},T_{\\text{MT}}^{(5)}] ]\n$$\n但渲染为不含空格的形式\n$[[T_{\\text{xorshift}}^{(1)},T_{\\textMT}^{(1)}],[T_{\\text{xorshift}}^{(2)},T_{\\text{MT}}^{(2)}],[T_{\\text{xorshift}}^{(3)},T_{\\text{MT}}^{(3)}],[T_{\\text{xorshift}}^{(4)},T_{\\text{MT}}^{(4)}],[T_{\\text{xorshift}}^{(5)},T_{\\text{MT}}^{(5)}]]$.\n\n所有数值输出必须是整数。程序必须是自包含的，并且不需要任何输入。", "solution": "将首先根据指定的科学合理性、良定性和客观性标准对该问题进行验证。\n\n### 问题验证\n\n#### 步骤 1：提取给定条件\n\n从问题陈述中逐字提取的给定条件如下：\n\n- **伪随机数生成器 (PRNGs):**\n    1.  **Mersenne Twister (MT):** 状态转移是抽象线性的，$x_{n+1} = A x_n$。使用一个 MT19937 的参考实现来生成 $w$ 位输出。\n    2.  **xorshift:** 一个由 $x_{n+1} = x_n \\oplus (x_n \\ll a) \\oplus (x_n \\gg b)$ 定义的单步生成器，其状态通过掩码操作保持为 $w$ 位。\n\n- **固定参数:**\n    - 字宽: $w = 32$。\n    - Xorshift 参数: $a = 13$, $b = 17$。\n    - 窗口长度: $W = 512$。\n    - 最小起始索引: $n_{\\min} = 64$。\n    - 最大步数: $N_{\\max} = 100000$。\n    - 均值容差: $\\varepsilon = 0.01$。\n    - 汉明权重容差: $\\delta = 0.125$。\n\n- **定义与映射:**\n    - 均匀映射: $u_n = x_n / 2^w$。\n    - 经验样本均值: $m_n = \\frac{1}{n}\\sum_{k=1}^n u_k$。\n    - 瞬时归一化汉明权重: $r_n = H(x_n)/w$，其中 $H(x)$ 是 $x$ 的汉明权重。\n\n- **瞬态长度 ($T$):**\n    - 最小索引 $n^\\star$，使得：\n        1. $n^\\star \\ge n_{\\min}$。\n        2. 对于所有 $j \\in \\{n^\\star, n^\\star+1, \\dots, n^\\star+W-1\\}$，条件 $\\lvert m_j - 0.5 \\rvert \\le \\varepsilon$ 和 $\\lvert r_j - 0.5 \\rvert \\le \\delta$ 同时成立。\n    - 如果在 $N_{\\max}$ 范围内不存在这样的 $n^\\star$，则 $T = N_{\\max}$。\n\n- **测试套件 (种子):**\n    - $s^{(1)} = 1$\n    - $s^{(2)} = 2^{31} + 1$\n    - $s^{(3)} = 0x12345678$\n    - $s^{(4)} = 2^{32} - 1$\n    - $s^{(5)} = 0$\n\n- **输出要求:**\n    - 对每个种子 $s^{(i)}$，计算 $[T_{\\text{xorshift}}, T_{\\text{MT}}]$。\n    - 最终输出是这些数对组成的单行字符串，格式为 $[[...],[...],...]$。\n\n#### 步骤 2：使用提取的给定条件进行验证\n\n根据验证标准对问题进行评估：\n\n- **科学依据：** 该问题深深植根于计算机科学、数值方法和统计学领域。Mersenne Twister 和 xorshift 生成器是标准的、有良好文档记录的 PRNG。对其状态空间动态的研究，特别是低汉明权重种子的行为以及在达到平稳分布之前的瞬态周期，是随机模拟中一个有效且重要的课题。所使用的度量（样本均值、汉明权重）是分析 PRNG 输出的标准工具。\n\n- **良定性：** 该问题是良定的。它提供了所有必要的参数和明确的定义，以确定性地计算瞬态长度 $T$。解的存在性是有保证的，因为模拟具有最大长度 $N_{\\max}$，如果稳定性标准未满足，该值将作为 $T$ 的默认值。该过程是确定性的，确保每个测试用例都有唯一的解。\n\n- **客观性：** 该问题完全客观，使用精确的数学定义和数值常量进行规定。没有任何主观或基于意见的陳述。\n\n- **缺陷分析:**\n    1.  **科学/事实不准确：** 无。前提条件在事实上是正确的。将种子 $s^{(5)} = 0$ 识别为给定 xorshift 生成器的吸收态 ($0 \\oplus (0 \\ll a) \\oplus (0 \\gg b) = 0$) 是准确的。\n    2.  **非形式化或不相关：** 无。该问题是可形式化的，并与 PRNGs 的主题直接相关。\n    3.  **不完整或矛盾的设置：** 无。所有需要的数据和定义都已提供且相互一致。\n    4.  **不切实际或不可行：** 无。模拟长度 $N_{\\max} = 100000$ 及其他参数定义了一个计算上可行的任务。\n    5.  **病态或结构不良：** 无。瞬态长度 $T$ 的定义是精确的，并允许唯一确定。\n    6.  **伪深刻、琐碎或同义反复：** 无。该问题需要非平凡的模拟和分析。该研究将种子属性（汉明权重）与输出质量联系起来，这是 PRNG 评估中的一个核心概念。\n    7.  **超出科学可验证性范围：** 无。结果可以通过重新实现指定的算法进行计算验证。\n\n#### 步骤 3：结论与行动\n该问题是 **有效的**。将提供完整的解决方案。\n\n### 解决方案设计\n\n问题的核心是为两个 PRNG 实现一个模拟，并根据其输出序列的统计特性来确定“瞬态长度”$T$。解决方案将分为三个主要部分：PRNG 的实现、计算 $T$ 的算法以及测试套件的主执行循环。\n\n#### 1. PRNG 实现\n\n将创建两个生成器函数，一个用于 xorshift，另一个用于 Mersenne Twister。每个函数都将用一个种子进行初始化，并生成一个 $w=32$ 位的无符号整数序列。\n\n- **xorshift 生成器：** 状态更新规则为 $x_{n+1} = x_n \\oplus (x_n \\ll a) \\oplus (x_n \\gg b)$。初始状态 $x_0$ 是提供的种子。所有操作都在 $32$ 位无符号整数上执行，这需要在 Python 中进行位运算后与 $2^{32}-1$ (或 $0xFFFFFFFF$) 进行掩码操作，以模拟定宽整数算术。种子 $s^{(5)}=0$ 是一个不动点，将产生一个零序列。\n\n- **Mersenne Twister (MT19937):** 问题指定使用参考实现。为此，`numpy.random.MT19937` 位生成器是指定 Python 环境中的标准且正确的选择。该生成器将被播种，并使用一个 `numpy.random.Generator` 实例来抽取 $32$ 位无符号整数。NumPy 实现能正确处理特殊种子（例如 0），通过对其进行加扰来初始化一个非退化的状态向量。\n\n#### 2. 瞬态长度 ($T$) 的算法\n\n一种直接的双循环方法（遍历所有可能的开始时间 $n^\\star$，并对每个时间检查接下来的 $W$ 个值）计算成本会很高 ($O(N_{\\max} \\cdot W)$)。将使用一种更高效的单遍算法 ($O(N_{\\max})$)。\n\n单遍算法的流程如下：\n1. 初始化一个连续成功步数的计数器 `consecutive_successes`为 $0$。\n2. 从 $n=1$ 迭代到 $N_{\\max}$。在每一步中：\n    a. 从 PRNG 生成下一个 $w$ 位值 $x_n$。\n    b. 计算派生量：$u_n = x_n / 2^w$、运行均值 $m_n = \\frac{1}{n}\\sum_{k=1}^n u_k$ 和归一化汉明权重 $r_n = H(x_n)/w$。\n    c. 检查是否满足稳定性条件：$C_n = (\\lvert m_n - 0.5 \\rvert \\le \\varepsilon) \\land (\\lvert r_n - 0.5 \\rvert \\le \\delta)$。\n    d. 如果 $C_n$ 为真，则增加 `consecutive_successes`。否则，将其重置为 $0$。\n    e. 更新后，检查 `consecutive_successes` 是否已达到窗口长度 $W$。如果达到，则表示刚刚完成了一个稳定窗口。该窗口的起始索引为 $n^\\star = n - W + 1$。\n    f. 我们还必须满足约束条件 $n^\\star \\ge n_{\\min}$。如果 `consecutive_successes` $\\ge W$ 且 $n - W + 1 \\ge n_{\\min}$，我们就找到了满足所有标准的最小 $n^\\star$。返回值 $T = n - W + 1$，并终止此生成器-种子对的模拟。\n3. 如果循环完成仍未找到这样的窗口，则瞬态长度 $T$ 取为 $N_{\\max}$。\n\n该算法正确地识别出长度为 $W$ 且起始索引 $n^\\star$ 至少为 $n_{\\min}$ 的稳定窗口的*首次*出现。\n\n#### 3. 主执行与输出格式化\n\n一个主函数将协调整个过程。\n1. 定义固定参数（$w$, $a$, $b$, $W$, $n_{\\min}$, $N_{\\max}$, $\\varepsilon$, $\\delta$）以及种子列表。\n2. 创建一个列表来存储最终结果。\n3. 按指定顺序遍历每个种子。\n4. 对每个种子，调用计算 `xorshift` 和 `MT` 生成器的 $T$ 值的函数。\n5. 将结果对 $[T_{\\text{xorshift}}, T_{\\text{MT}}]$ 存储到结果列表中。\n6. 处理完所有种子后，将数对列表格式化为所需的紧凑字符串格式，例如 `[[...],[...]]`，并将其打印到标准输出。\n\n此设计是模块化、高效的，并直接实现了已验证问题陈述中描述的逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to conduct the PRNG study and produce the final output.\n    \"\"\"\n    \n    # Fixed parameters as specified in the problem statement.\n    W = 512          # Window length\n    N_MIN = 64       # Minimum starting index for T\n    N_MAX = 100000   # Maximum number of steps\n    EPSILON = 0.01   # Mean tolerance\n    DELTA = 0.125    # Hamming-weight tolerance\n    W_BITS = 32      # Word width\n    XOR_A = 13       # Xorshift parameter a\n    XOR_B = 17       # Xorshift parameter b\n\n    # Test suite of seeds.\n    test_cases = [\n        1,\n        2**31 + 1,\n        0x12345678,\n        2**32 - 1,\n        0,\n    ]\n\n    def compute_transient_length(generator_type, seed):\n        \"\"\"\n        Computes the transient length T for a given generator and seed.\n\n        Args:\n            generator_type (str): 'xorshift' or 'mt'.\n            seed (int): The initial seed for the generator.\n\n        Returns:\n            int: The computed transient length T.\n        \"\"\"\n        # Constants for 32-bit arithmetic and normalization.\n        TWO_POW_W = 2**W_BITS\n        MASK = TWO_POW_W - 1\n\n        # Initialize the appropriate generator.\n        if generator_type == 'xorshift':\n            x_state = seed & MASK\n            # The 0 state is a fixed point for this xorshift variant.\n            # The loop will never terminate because conditions are never met.\n            # Handle this as a special case to avoid unnecessary computation.\n            if x_state == 0:\n                return N_MAX\n            def next_val():\n                nonlocal x_state\n                # The state updates and the new state is the output value.\n                x_state = (x_state ^ (x_state << XOR_A) ^ (x_state >> XOR_B)) & MASK\n                return x_state\n        elif generator_type == 'mt':\n            bg = np.random.MT19937(seed)\n            rg = np.random.Generator(bg)\n            def next_val():\n                return int(rg.integers(TWO_POW_W, dtype=np.uint32))\n        else:\n            raise ValueError(\"Unknown generator type\")\n\n        total_u = 0.0\n        consecutive_successes = 0\n\n        # Main simulation loop from n=1 to N_MAX.\n        for n in range(1, N_MAX + 1):\n            x_n = next_val()\n\n            # Calculate derived metrics for the current step.\n            u_n = x_n / TWO_POW_W\n            total_u += u_n\n            m_n = total_u / n\n            r_n = bin(x_n).count('1') / W_BITS\n\n            # Check if the stability conditions are met.\n            is_success = (abs(m_n - 0.5) <= EPSILON) and (abs(r_n - 0.5) <= DELTA)\n            \n            if is_success:\n                consecutive_successes += 1\n            else:\n                consecutive_successes = 0\n\n            # Check if a stable window of length W has been found.\n            # The window is [n - W + 1, n]. Its start must be >= N_MIN.\n            if consecutive_successes >= W:\n                n_star = n - W + 1\n                if n_star >= N_MIN:\n                    return n_star # Found the smallest T.\n\n        # If the loop finishes, no such window was found.\n        return N_MAX\n\n    results = []\n    for seed in test_cases:\n        t_xorshift = compute_transient_length('xorshift', seed)\n        t_mt = compute_transient_length('mt', seed)\n        results.append([t_xorshift, t_mt])\n    \n    # Format the final output string exactly as specified.\n    final_output = str(results).replace(' ', '')\n    print(final_output)\n\nsolve()\n```", "id": "3320097"}]}