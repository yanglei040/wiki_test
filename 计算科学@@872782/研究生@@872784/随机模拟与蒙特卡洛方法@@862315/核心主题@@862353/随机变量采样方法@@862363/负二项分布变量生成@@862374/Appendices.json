{"hands_on_practices": [{"introduction": "深入理解任何概率分布的第一步是掌握其概率质量函数 (PMF) 的局部行为。本练习将指导您从负二项分布的 PMF 出发，推导相邻结果概率之间的递推关系。掌握这项分析技巧不仅能加深您对分布形态的理解，更是设计高效生成算法（如接受-拒绝采样）和进行数值计算的基石。[@problem_id:3323089]", "problem": "在为负二项分布设计递归接受-拒绝生成器时，您需要一个连续概率的显式比率，以便从其最大值处向外高效地遍历质量函数。考虑一个负二项随机变量 $X$，其定义为在一系列成功概率为 $p \\in (0,1)$ 的独立伯努利试验中，在第 $r$ 次成功之前的失败次数。假设 $r \\in \\{1,2,3,\\dots\\}$。$X$ 的概率质量函数 (PMF) 为\n$$\n\\mathbb{P}(X=k) \\;=\\; \\binom{k+r-1}{k}\\, p^{r}\\, (1-p)^{k},\\quad k\\in\\{0,1,2,\\dots\\}.\n$$\n严格地从该 PMF 和二项式系数的基本代数操作出发，完成以下任务：\n- 以 $k$、$r$ 和 $p$ 的函数形式，推导出递推比率 $R(k) = \\dfrac{\\mathbb{P}(X=k+1)}{\\mathbb{P}(X=k)}$ 的闭合形式。\n- 仅使用比率 $R(k)$ 和基本的单调性推理，在 $r \\ge 1$ 的情况下，以 $r$ 和 $p$ 的函数的闭合形式，确定精确的整数众数 $m$（即 PMF 达到其全局最大值时的最大整数）。\n\n最后，对于特定参数 $r=7$ 和 $p=0.37$，计算众数 $m$ 作为一个整数。无需四舍五入。", "solution": "出发点是参数为 $r \\in \\{1,2,3,\\dots\\}$ 和 $p \\in (0,1)$ 的负二项随机变量 $X$ 的概率质量函数 (PMF)：\n$$\n\\mathbb{P}(X=k) = \\binom{k+r-1}{k} p^{r} (1-p)^{k}, \\quad k \\in \\{0, 1, 2, \\dots\\}\n$$\n第一个任务是推导递推比率 $R(k) = \\dfrac{\\mathbb{P}(X=k+1)}{\\mathbb{P}(X=k)}$。\n\n我们通过在 PMF 公式中用 $k+1$ 替换 $k$ 来写出 $\\mathbb{P}(X=k+1)$ 的表达式：\n$$\n\\mathbb{P}(X=k+1) = \\binom{(k+1)+r-1}{k+1} p^{r} (1-p)^{k+1} = \\binom{k+r}{k+1} p^{r} (1-p)^{k+1}\n$$\n现在，我们构造比率 $R(k)$：\n$$\nR(k) = \\frac{\\mathbb{P}(X=k+1)}{\\mathbb{P}(X=k)} = \\frac{\\binom{k+r}{k+1} p^{r} (1-p)^{k+1}}{\\binom{k+r-1}{k} p^{r} (1-p)^{k}}\n$$\n我们通过消去公因子来化简这个表达式。项 $p^r$ 被消去。$(1-p)$ 的幂的比率为：\n$$\n\\frac{(1-p)^{k+1}}{(1-p)^{k}} = 1-p\n$$\n接下来，我们化简二项式系数的比率。使用阶乘定义 $\\binom{n}{k} = \\frac{n!}{k!(n-k)!}$，我们有：\n$$\n\\binom{k+r-1}{k} = \\frac{(k+r-1)!}{k!((k+r-1)-k)!} = \\frac{(k+r-1)!}{k!(r-1)!}\n$$\n和\n$$\n\\binom{k+r}{k+1} = \\frac{(k+r)!}{(k+1)!((k+r)-(k+1))!} = \\frac{(k+r)!}{(k+1)!(r-1)!}\n$$\n它们的比率是：\n$$\n\\frac{\\binom{k+r}{k+1}}{\\binom{k+r-1}{k}} = \\frac{(k+r)!}{(k+1)!(r-1)!} \\cdot \\frac{k!(r-1)!}{(k+r-1)!}\n$$\n我们可以化简阶乘：$\\frac{(k+r)!}{(k+r-1)!} = k+r$ 且 $\\frac{k!}{(k+1)!} = \\frac{1}{k+1}$。项 $(r-1)!$ 被消去。\n$$\n\\frac{\\binom{k+r}{k+1}}{\\binom{k+r-1}{k}} = \\frac{k+r}{k+1}\n$$\n综合各部分，递推比率 $R(k)$ 为：\n$$\nR(k) = \\frac{k+r}{k+1} (1-p)\n$$\n这就完成了问题的第一部分。\n\n第二个任务是找到分布的众数 $m$。众数是使 PMF $\\mathbb{P}(X=k)$ 最大化的 $k$ 值。如果一个值 $m$ 满足对于 $m \\ge 1$ 有 $\\mathbb{P}(X=m) \\ge \\mathbb{P}(X=m-1)$ 且 $\\mathbb{P}(X=m) \\ge \\mathbb{P}(X=m+1)$，则 $m$ 是一个众数。用我们的比率 $R(k)$ 来表示，这些条件等价于 $R(m-1) \\ge 1$ 和 $R(m) \\le 1$。\n\n我们分析不等式 $R(k) \\ge 1$，它指出了 PMF 在何处是非递减的：\n$$\n\\frac{k+r}{k+1} (1-p) \\ge 1\n$$\n由于 $k \\ge 0$，$k+1$ 是正数，所以我们可以在不等式两边同乘以 $k+1$ 而不改变不等号的方向：\n$$\n(k+r)(1-p) \\ge k+1\n$$\n$$\nk(1-p) + r(1-p) \\ge k+1\n$$\n$$\nr(1-p) - 1 \\ge k - k(1-p)\n$$\n$$\nr(1-p) - 1 \\ge k(1 - (1-p))\n$$\n$$\nr(1-p) - 1 \\ge kp\n$$\n由于 $p \\in (0,1)$，$p$ 是正数，所以我们可以除以 $p$：\n$$\nk \\le \\frac{r(1-p) - 1}{p}\n$$\n令 $C = \\frac{r(1-p) - 1}{p}$。因此，众数 $m$ 是满足 $R(m-1) \\ge 1$ 且 $R(m) \\le 1$ 的整数。这对应于 $m-1 \\le C$ 且 $m \\ge C$，即 $C \\le m \\le C+1$。因此，任何众数 $m$ 必须位于长度为1的区间 $[C, C+1]$ 内。\n\n情况1：$C$ 不是整数。在区间 $[C, C+1]$ 中存在一个唯一的整数 $m$，它必然是 $m = \\lfloor C \\rfloor + 1$。对于这个 $m$，我们有 $R(m-1) > 1$ 和 $R(m)  1$，所以它是唯一的众数。\n\n情况2：$C$ 是一个整数，比如 $C=I$。不等式 $k \\le I$ 意味着对于 $k  I$ 有 $R(k) > 1$ 且 $R(I) = 1$。$R(I)=1$ 意味着 $\\mathbb{P}(X=I+1) = \\mathbb{P}(X=I)$。对于 $k > I$，我们有 $R(k)  1$。因此，PMF 的最大值在 $k=I$ 和 $k=I+1$ 处同时达到。问题要求的是最大整数众数，即 $m=I+1$。\n\n在所有情况下，最大整数众数可以由 $m = \\lfloor C+1 \\rfloor$ 给出。\n$$\nm = \\left\\lfloor \\frac{r(1-p) - 1}{p} + 1 \\right\\rfloor = \\left\\lfloor \\frac{r(1-p) - 1 + p}{p} \\right\\rfloor\n$$\n$$\nm = \\left\\lfloor \\frac{r - rp - 1 + p}{p} \\right\\rfloor = \\left\\lfloor \\frac{(r-1) - p(r-1)}{p} \\right\\rfloor\n$$\n$$\nm = \\left\\lfloor \\frac{(r-1)(1-p)}{p} \\right\\rfloor\n$$\n该表达式对于 $r \\ge 1$ 是有效的。如果 $r=1$，$m=\\lfloor 0 \\rfloor = 0$，这对于几何分布是正确的。如果 $(r-1)(1-p)/p  0$，这在给定的参数约束下不可能发生，因为 $(r-1)\\ge0$ 且 $(1-p)/p > 0$，所以该表达式是非负的。\n\n最后，我们为特定参数 $r=7$ 和 $p=0.37$ 计算众数 $m$。\n我们有 $r-1 = 6$ 和 $1-p = 1 - 0.37 = 0.63$。\n将这些值代入众数的公式中：\n$$\nm = \\left\\lfloor \\frac{(7-1)(1-0.37)}{0.37} \\right\\rfloor = \\left\\lfloor \\frac{6 \\times 0.63}{0.37} \\right\\rfloor\n$$\n$$\nm = \\left\\lfloor \\frac{3.78}{0.37} \\right\\rfloor\n$$\n为了计算向下取整，我们进行除法运算：\n$$\n\\frac{3.78}{0.37} = \\frac{378}{37}\n$$\n$$\n\\frac{378}{37} = \\frac{370 + 8}{37} = \\frac{370}{37} + \\frac{8}{37} = 10 + \\frac{8}{37} \\approx 10.216\n$$\n$$\nm = \\lfloor 10 + \\frac{8}{37} \\rfloor = 10\n$$\n对于给定的参数，众数是 $10$。", "answer": "$$\\boxed{10}$$", "id": "3323089"}, {"introduction": "理论模型的优雅性固然重要，但在蒙特卡洛模拟中，生成随机数的计算成本是衡量算法优劣的关键指标。本练习将引导您从一个基本视角——生成过程所消耗的均匀分布随机数的期望数量——来分析负二项分布的直接模拟成本。通过将负二项过程分解为一系列独立的几何等待时间，您将学会如何运用期望的线性性质来评估模拟算法的平均效率。[@problem_id:3323098]", "problem": "一个模拟引擎提供一串独立同分布 (i.i.d.) 的 $\\mathrm{Uniform}(0,1)$ 随机变量。单次 $\\mathrm{Bernoulli}(p)$ 试验（其成功概率固定为 $p \\in (0,1]$）通过抽取一个 $\\mathrm{Uniform}(0,1)$ 随机变量 $U$ 并返回指示函数 $\\mathbf{1}\\{U \\leq p\\}$ 来实现。考虑基于这些 $\\mathrm{Bernoulli}(p)$ 试验构建的两个生成器：\n\n- 一个几何生成器，它输出观测到首次成功所需的 $\\mathrm{Bernoulli}(p)$ 试验次数。每次 $\\mathrm{Bernoulli}(p)$ 试验恰好消耗一个 $\\mathrm{Uniform}(0,1)$ 随机变量。\n- 一个负二项生成器，其参数为 $(r,p)$，其中 $r \\in \\mathbb{N}$ 是一个固定的正整数。该生成器输出第 $r$ 次成功之前失败的次数，并且其实现方式可以是 对 $r$ 个独立同分布的几何等待时间求和，或者等价地，通过运行 $\\mathrm{Bernoulli}(p)$ 试验直到第 $r$ 次成功发生。每次 $\\mathrm{Bernoulli}(p)$ 试验恰好消耗一个 $\\mathrm{Uniform}(0,1)$ 随机变量。\n\n设 $C_{\\mathrm{Geo}}(p)$ 表示生成一个几何分布随机数所需的 $\\mathrm{Uniform}(0,1)$ 调用的期望次数，设 $C_{\\mathrm{NB}}(r,p)$ 表示生成一个负二项分布随机数所需的 $\\mathrm{Uniform}(0,1)$ 调用的期望次数。仅使用概率论的基本定义（独立性、从单个 $\\mathrm{Uniform}(0,1)$ 变量构造 $\\mathrm{Bernoulli}(p)$ 变量的指示函数法，以及几何和负二项等待时间的定义），推导 $C_{\\mathrm{Geo}}(p)$，然后推断出 $C_{\\mathrm{NB}}(r,p)$。\n\n以单个封闭形式的解析表达式报告 $C_{\\mathrm{NB}}(r,p)$ 的最终答案，该表达式用 $r$ 和 $p$ 表示。不需要四舍五入，也不涉及单位。", "solution": "问题要求推导生成一个几何分布随机数（记为 $C_{\\mathrm{Geo}}(p)$）和一个负二项分布随机数（记为 $C_{\\mathrm{NB}}(r,p)$）所需的 $\\mathrm{Uniform}(0,1)$ 随机变量的期望数量。\n\n首先，我们必须验证问题陈述的有效性。\n\n### 第1步：提取已知条件\n- 提供一串独立同分布 (i.i.d.) 的 $\\mathrm{Uniform}(0,1)$ 随机变量。\n- 通过抽取一个 $\\mathrm{Uniform}(0,1)$ 随机变量 $U$ 并返回指示函数 $\\mathbf{1}\\{U \\leq p\\}$ 来实现一次 $\\mathrm{Bernoulli}(p)$ 试验。成功概率为 $p \\in (0,1]$。\n- 每次 $\\mathrm{Bernoulli}(p)$ 试验恰好消耗一个 $\\mathrm{Uniform}(0,1)$ 随机变量。\n- 几何生成器输出观测到首次成功所需的 $\\mathrm{Bernoulli}(p)$ 试验次数。\n- 负二项生成器的参数为 $(r,p)$，其中 $r \\in \\mathbb{N}$ 是一个固定的正整数。它输出第 $r$ 次成功之前失败的次数。\n- 负二项生成器通过对 $r$ 个独立同分布的几何等待时间求和，或等价地，通过运行伯努利试验直到第 $r$ 次成功发生来实现。\n- $C_{\\mathrm{Geo}}(p)$ 是生成一个几何分布随机数所需的 $\\mathrm{Uniform}(0,1)$ 调用的期望次数。\n- $C_{\\mathrm{NB}}(r,p)$ 是生成一个负二项分布随机数所需的 $\\mathrm{Uniform}(0,1)$ 调用的期望次数。\n- 任务是推导 $C_{\\mathrm{Geo}}(p)$，然后推断出 $C_{\\mathrm{NB}}(r,p)$。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学依据、提法恰当且客观。它基于概率论和随机模拟中的标准、基本定义。通过反演法从均匀分布随机变量构造伯努利随机变量是蒙特卡洛方法的基石。几何分布和负二项分布的定义是标准的。所有参数和约束（$p \\in (0,1]$, $r \\in \\mathbb{N}$）都已明确指定。问题是自洽且逻辑一致的，没有缺失或矛盾的信息。它要求推导一个明确定义的量，即期望计算成本，该量具有唯一且有意义的解。该问题不违反任何无效性标准。\n\n### 第3步：结论与行动\n问题是有效的。我们将继续进行求解。\n\n### 推导过程\n问题的核心在于认识到 $\\mathrm{Uniform}(0,1)$ 调用的次数与执行的 $\\mathrm{Bernoulli}(p)$ 试验次数相同。因此，$C_{\\mathrm{Geo}}(p)$ 和 $C_{\\mathrm{NB}}(r,p)$ 分别是它们各自生成方案所需的伯努利试验的期望次数。\n\n**第1部分：$C_{\\mathrm{Geo}}(p)$ 的推导**\n\n设 $X$ 是为获得首次成功所需的试验次数的随机变量。根据定义，$X$ 服从成功概率为 $p$ 的几何分布。$X$ 的概率质量函数 (PMF) 由下式给出：\n$$P(X=k) = (1-p)^{k-1}p, \\quad \\text{for } k \\in \\{1, 2, 3, \\ldots\\}$$\n几何生成器输出 $X$ 的值。为生成这一个几何分布随机数而进行的 $\\mathrm{Uniform}(0,1)$ 调用次数恰好是随机的试验次数 $X$。因此，期望调用次数 $C_{\\mathrm{Geo}}(p)$ 就是 $X$ 的期望值。\n$$C_{\\mathrm{Geo}}(p) = E[X]$$\n期望通过对 $X$ 的支撑集求和来计算：\n$$E[X] = \\sum_{k=1}^{\\infty} k \\cdot P(X=k) = \\sum_{k=1}^{\\infty} k (1-p)^{k-1}p$$\n设 $q = 1-p$。表达式变为：\n$$E[X] = p \\sum_{k=1}^{\\infty} k q^{k-1}$$\n我们认识到这个和是一个几何级数的导数。对于 $|q|  1$，我们有标准恒等式：\n$$\\sum_{k=0}^{\\infty} q^k = \\frac{1}{1-q}$$\n对两边关于 $q$ 求导，得到：\n$$\\frac{d}{dq} \\left( \\sum_{k=0}^{\\infty} q^k \\right) = \\sum_{k=1}^{\\infty} k q^{k-1} = \\frac{d}{dq} \\left( \\frac{1}{1-q} \\right) = \\frac{1}{(1-q)^2}$$\n由于 $p \\in (0,1]$，我们有 $q = 1-p \\in [0,1)$，因此对于 $p \\in (0,1)$，满足 $|q|1$。$p=1$ ($q=0$) 的情况是平凡的。\n将此结果代回期望的表达式中：\n$$E[X] = p \\left( \\frac{1}{(1-q)^2} \\right)$$\n现在，将 $q=1-p$ 代回：\n$$E[X] = p \\left( \\frac{1}{(1-(1-p))^2} \\right) = p \\left( \\frac{1}{p^2} \\right) = \\frac{1}{p}$$\n因此，生成一个几何分布随机数所需的期望均匀调用次数为：\n$$C_{\\mathrm{Geo}}(p) = \\frac{1}{p}$$\n\n**第2部分：$C_{\\mathrm{NB}}(r,p)$ 的推断**\n\n问题陈述，负二项生成器可以通过对 $r$ 个独立同分布的几何等待时间求和来实现。更精确地说，实现 $r$ 次成功所需的总试验次数是 $r$ 个独立同分布的几何随机变量之和。设 $N$ 为观测到第 $r$ 次成功所需的总试验次数。设 $X_i$ 为从第 $(i-1)$ 次成功到第 $i$ 次成功所需的试验次数，其中 $i=1, 2, \\ldots, r$。\n- $X_1$ 是首次成功所需的试验次数。$X_1 \\sim \\mathrm{Geometric}(p)$。\n- $X_2$ 是第二次成功所需的额外试验次数。由于伯努利过程的无记忆性，$X_2$ 也服从 $\\mathrm{Geometric}(p)$ 分布，且与 $X_1$ 独立。\n- ...\n- $X_r$ 是第 $r$ 次成功所需的额外试验次数。$X_r \\sim \\mathrm{Geometric}(p)$ 且与 $X_1, \\ldots, X_{r-1}$ 独立。\n\n总试验次数 $N$ 是这些单个等待时间之和：\n$$N = X_1 + X_2 + \\cdots + X_r$$\n负二项生成器运行此过程，消耗 $N$ 个均匀分布随机变量。尽管生成器的*输出值*定义为失败次数 $N-r$，但产生此输出的*成本*是总试验次数 $N$。问题要求的是 $C_{\\mathrm{NB}}(r,p)$，即期望成本。\n$$C_{\\mathrm{NB}}(r,p) = E[N]$$\n使用期望的线性性质：\n$$E[N] = E[X_1 + X_2 + \\cdots + X_r] = E[X_1] + E[X_2] + \\cdots + E[X_r]$$\n由于每个 $X_i$ 都是独立同分布的 $\\mathrm{Geometric}(p)$ 随机变量，它们的期望是相同的：\n$$E[X_i] = E[X_1] = C_{\\mathrm{Geo}}(p) = \\frac{1}{p} \\quad \\text{for all } i \\in \\{1, \\ldots, r\\}$$\n因此，期望总试验次数是 $r$ 个相同期望之和：\n$$C_{\\mathrm{NB}}(r,p) = \\sum_{i=1}^{r} E[X_i] = \\sum_{i=1}^{r} \\frac{1}{p} = r \\cdot \\frac{1}{p} = \\frac{r}{p}$$\n这就是生成一个参数为 $(r,p)$ 的负二项分布随机数所需的 $\\mathrm{Uniform}(0,1)$ 调用的期望次数的最终表达式。", "answer": "$$\\boxed{\\frac{r}{p}}$$", "id": "3323098"}, {"introduction": "在计算科学领域，理论推导与经验验证是相辅相成的。这个综合性练习将理论与实践相结合，要求您构建一个蒙特卡洛单元测试框架，以统计学上严谨的方式验证负二项分布的一个核心结构特性。您将通过模拟生成大量数据，并运用假设检验和置信区间的思想，判断理论公式（例如在练习 [@problem_id:3323089] 中推导的公式）与模拟结果是否一致，这充分体现了计算实验在现代科学研究中的重要作用。[@problem_id:3323022]", "problem": "您的任务是编写一个完整、可运行的程序，该程序实现一个自动化的单元测试框架，通过蒙特卡洛模拟来验证负二项分布的一个核心结构恒等式。该测试框架必须仅以基本定义和经过充分检验的基础事实作为出发点，从中推导出所需的目标量，并应用规范的统计推断程序来检测系统性偏差。您的实现不能假设或硬编码待检验的恒等式；它必须从负二项分布的定义出发，根据第一性原理计算所有必要的理论量。\n\n本问题中的负二项分布由一个正实数形状参数 $r \\in (0,\\infty)$ 和一个成功概率 $p \\in (0,1)$ 参数化，它模拟了在一系列成功概率为 $p$ 的独立伯努利试验中，第 $r$ 次成功之前失败的次数 $K \\in \\{0,1,2,\\dots\\}$。其概率质量函数 (Probability Mass Function, PMF) 对所有 $k \\in \\{0,1,2,\\dots\\}$ 定义如下：\n$$\n\\mathbb{P}(K=k) \\;=\\; f(k) \\;=\\; \\binom{k+r-1}{k}\\,p^{\\,r}\\,(1-p)^{\\,k}\n\\;=\\; \\frac{\\Gamma(k+r)}{\\Gamma(r)\\,\\Gamma(k+1)}\\,p^{\\,r}\\,(1-p)^{\\,k},\n$$\n其中 $\\Gamma(\\cdot)$ 是伽马函数，并且 $\\binom{k+r-1}{k}$ 是通过伽马函数定义的，这使得 $r$ 可以为非整数。该恒等式是您推导下文所要求的所有关于 $f(k)$ 的理论量的唯一允许的出发点。\n\n您的程序必须实现以下组件。\n\n- 模拟引擎：\n  - 为一般的实数 $r0$ 和 $p \\in (0,1)$，从负二项分布中生成独立同分布的样本。仅使用对实数 $r$ 有效的基本构造方法，例如泊松-伽马混合表示：如果 $\\Lambda \\sim \\mathrm{Gamma}(\\text{shape}=r,\\text{scale}=(1-p)/p)$，并且在给定 $\\Lambda$ 的条件下，$X \\mid \\Lambda \\sim \\mathrm{Poisson}(\\Lambda)$，则 $X$ 服从参数为 $r$ 和 $p$ 的负二项分布。这是一个经过充分检验的恒等式，您可以将其作为模拟器的基础。\n  - 随机数生成器必须使用确定性种子，以确保输出结果完全可复现。\n\n- 经验直方图与相邻比率估计器：\n  - 从大小为 $n$ 的模拟样本中，构建 $k \\in \\{0,1,2,\\dots\\}$ 的直方图计数 $N_k$。\n  - 对于每个满足 $M_k := N_k + N_{k+1} \\ge m_{\\min}$ 的 $k$，定义两单元格条件比例 $q_k := \\frac{f(k+1)}{f(k) + f(k+1)}$ 及其经验估计量 $\\hat{q}_k := \\frac{N_{k+1}}{M_k}$。\n  - 使用变换 $g(q) = \\frac{q}{1-q}$ 来定义 PMF 的相邻比率 $R_k := \\frac{f(k+1)}{f(k)} = g(q_k)$ 以及其经验对应量 $\\hat{R}_k := g(\\hat{q}_k)$，前提是 $\\hat{q}_k \\in [0,1)$ 以确保 $g$ 是有限的。\n  - 计算 $q_k$ 所需的量 $f(k)$ 和 $f(k+1)$ 必须根据上述 PMF 定义进行计算，不得使用任何快捷恒等式。\n\n- 置信区间 (CI) 构建与系统性偏差标记：\n  - 对于每个满足 $M_k \\ge m_{\\min}$ 和 $\\hat{q}_k \\in [0,1)$ 的合格 $k$，为 $R_k$ 构建一个近似的双边水平为 $1-\\alpha$ 的置信区间 (CI)。该区间基于 $N_{k+1} \\mid M_k \\sim \\mathrm{Binomial}(M_k, q_k)$ 的二项分布模型以及对 $g(q)=\\frac{q}{1-q}$ 使用德尔塔方法 (Delta method) 进行的线性化。通过将德尔塔方法应用于二项比例来确定标准误差的形式。\n  - 令 $z_{1-\\alpha/2}$ 表示尾部概率为 $\\alpha/2$ 的标准正态分位数。构建以 $\\hat{R}_k$ 为中心的置信区间，其半宽等于 $z_{1-\\alpha/2}$ 乘以由德尔塔方法得出的适当标准误差，该标准误差用 $q_k$ 和 $M_k$ 表示。在标准误差的计算中使用 $q_k$（而非 $\\hat{q}_k$），以避免方差项依赖于数据。\n  - 如果索引为 $k$ 的理论推导值 $R_k$ 不在为该 $k$ 构建的置信区间内，则声明一次违规。将该测试用例的违规总数计为一个整数。\n\n- 聚合与输出：\n  - 对于每个指定的测试用例，计算所有合格 $k$ 的违规整数总数。如果没有合格的 $k$，则该用例返回整数 $0$。\n  - 您的程序必须生成单行输出，其中包含所有给定测试用例的这些整数，按测试用例顺序排列，形式为用方括号括起来的逗号分隔列表，例如 $[v_1,v_2,\\dots,v_T]$，其中 $T$ 是测试用例的数量，$v_t$ 是测试用例 $t$ 的违规计数。\n\n要实现的参数选择和测试套件：\n\n- 使用固定的显著性水平 $\\alpha = 0.01$，对应置信水平为 $1-\\alpha = 0.99$。任何地方都不要使用百分号；所有覆盖水平都以小数或分数表示。\n- 使用最小合并阈值 $m_{\\min} = 50$ 来决定索引 $k$ 是否有资格进行测试。\n- 实现以下5个测试用例，每个用例由 $(r,p,n)$ 指定：\n  - 用例 1: $(r,p,n) = (5,\\,0.3,\\,200000)$。\n  - 用例 2: $(r,p,n) = (2.5,\\,0.7,\\,150000)$。\n  - 用例 3: $(r,p,n) = (0.7,\\,0.2,\\,300000)$。\n  - 用例 4: $(r,p,n) = (20,\\,0.5,\\,80000)$。\n  - 用例 5: $(r,p,n) = (1.3,\\,0.95,\\,120000)$。\n\n附加要求：\n\n- 实现该测试框架所需的所有数学推导必须仅从 PMF 定义和泊松-伽马混合恒等式开始。在没有推导的情况下，不要假设或引用任何额外的目标恒等式。在代码中提供最终的表达式，而不是在输出中。\n- 不涉及角度和物理单位。\n- 最终输出必须是如上所述的单行文本，不含任何额外文字。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[v_1,v_2,v_3,v_4,v_5]$。", "solution": "问题陈述已经过分析并被确定为有效。这是一个计算统计学领域中定义明确、有科学依据的问题，提供了构建唯一且可验证解所需的所有必要定义、参数和程序。\n\n任务是构建一个基于蒙特卡洛的测试框架，以验证负二项分布的一个结构特性。这涉及几个步骤：推导理论量、从分布中模拟数据、对模拟数据进行统计分析，并将经验结果与理论预测进行比较。\n\n问题的核心在于检验相邻计数值概率之间的关系。该关系由比率 $R_k = f(k+1)/f(k)$ 捕捉。测试方法依赖于将该比率的理论推导值与从大量模拟样本中获得的经验估计值进行比较。\n\n首先，我们从给定的负二项分布 $K \\sim \\mathrm{NB}(r, p)$ 的概率质量函数 (PMF) 出发，推导相邻计数值比率 $R_k$ 的理论值：\n$$\nf(k) = \\mathbb{P}(K=k) = \\frac{\\Gamma(k+r)}{\\Gamma(r)\\,\\Gamma(k+1)}\\,p^{\\,r}\\,(1-p)^{\\,k}\n$$\n比率 $R_k$ 定义为：\n$$\nR_k = \\frac{f(k+1)}{f(k)} = \\frac{\\frac{\\Gamma(k+1+r)}{\\Gamma(r)\\,\\Gamma(k+2)}\\,p^{\\,r}\\,(1-p)^{\\,k+1}}{\\frac{\\Gamma(k+r)}{\\Gamma(r)\\,\\Gamma(k+1)}\\,p^{\\,r}\\,(1-p)^{\\,k}}\n$$\n通过约去公因子（$p^r$、$(1-p)^k$ 的一部分以及 $\\Gamma(r)$）来简化表达式：\n$$\nR_k = \\frac{\\Gamma(k+r+1)}{\\Gamma(k+r)} \\cdot \\frac{\\Gamma(k+1)}{\\Gamma(k+2)} \\cdot \\frac{(1-p)^{k+1}}{(1-p)^k}\n$$\n利用伽马函数的基本性质 $\\Gamma(z+1)=z\\Gamma(z)$，我们可以简化伽马函数的比率：\n$$\n\\frac{\\Gamma(k+r+1)}{\\Gamma(k+r)} = k+r\n$$\n$$\n\\frac{\\Gamma(k+1)}{\\Gamma(k+2)} = \\frac{\\Gamma(k+1)}{(k+1)\\Gamma(k+1)} = \\frac{1}{k+1}\n$$\n将这些代回 $R_k$ 的表达式中，得到待检验的简单结构恒等式：\n$$\nR_k = (k+r) \\cdot \\left(\\frac{1}{k+1}\\right) \\cdot (1-p) = \\frac{k+r}{k+1}(1-p)\n$$\n这就是相邻概率比率的理论目标值。\n\n统计检验是基于从大小为 $n$ 的大样本中观察到的单元格计数 $N_k$ 构建的。对于任何一对相邻的单元格 $k$ 和 $k+1$，我们考虑其总计数 $M_k = N_k + N_{k+1}$。在给定总数 $M_k$ 的条件下，单元格 $k+1$ 中的观测数 $N_{k+1}$ 服从二项分布：\n$$\nN_{k+1} \\mid M_k \\sim \\mathrm{Binomial}(M_k, q_k)\n$$\n其中 $q_k$ 是在观测值落入单元格 $k$ 或 $k+1$ 的条件下，其落入单元格 $k+1$ 的条件概率：\n$$\nq_k = \\frac{f(k+1)}{f(k) + f(k+1)}\n$$\n通过将分子和分母同时除以 $f(k)$，我们可以用 $R_k$ 来表示 $q_k$：\n$$\nq_k = \\frac{f(k+1)/f(k)}{1 + f(k+1)/f(k)} = \\frac{R_k}{1+R_k}\n$$\n$q_k$ 的自然估计量是经验比例 $\\hat{q}_k = N_{k+1}/M_k$。问题通过变换 $g(q) = q/(1-q)$ 来定义 $R_k$ 的估计量。很容易看出 $g(q_k) = R_k$。因此，我们对 $R_k$ 的经验估计量是 $\\hat{R}_k = g(\\hat{q}_k) = \\hat{q}_k/(1-\\hat{q}_k)$。\n\n为了构建 $R_k$ 的置信区间，我们应用德尔塔方法 (Delta method) 来找到 $\\hat{R}_k$ 的近似方差。对于大量的试验次数 $M_k$，二项比例估计量 $\\hat{q}_k$ 的方差为 $\\mathrm{Var}(\\hat{q}_k) = q_k(1-q_k)/M_k$。德尔塔方法将变换后估计量的方差近似为 $\\mathrm{Var}(\\hat{R}_k) \\approx [g'(q_k)]^2 \\mathrm{Var}(\\hat{q}_k)$。我们计算 $g(q)$ 的导数：\n$$\ng'(q) = \\frac{d}{dq}\\left(\\frac{q}{1-q}\\right) = \\frac{1(1-q) - q(-1)}{(1-q)^2} = \\frac{1}{(1-q)^2}\n$$\n将其代入方差近似式中：\n$$\n\\mathrm{Var}(\\hat{R}_k) \\approx \\left(\\frac{1}{(1-q_k)^2}\\right)^2 \\frac{q_k(1-q_k)}{M_k} = \\frac{q_k}{M_k(1-q_k)^3}\n$$\n标准误差 (SE) 是该方差的平方根。根据规定，我们在此公式中使用理论值 $q_k$。\n$$\n\\mathrm{SE}(\\hat{R}_k) = \\sqrt{\\frac{q_k}{M_k(1-q_k)^3}}\n$$\n$R_k$ 的一个近似 $1-\\alpha$ 置信区间以经验估计值 $\\hat{R}_k$ 为中心，其半宽由标准正态分位数 $z_{1-\\alpha/2}$ 决定：\n$$\n\\mathrm{CI}_k = \\left[ \\hat{R}_k - z_{1-\\alpha/2} \\mathrm{SE}(\\hat{R}_k), \\; \\hat{R}_k + z_{1-\\alpha/2} \\mathrm{SE}(\\hat{R}_k) \\right]\n$$\n如果理论比率 $R_k$ 落在此经验构建的置信区间之外，则对索引 $k$ 计为一次违规。这种情况发生在 $|\\hat{R}_k - R_k| > z_{1-\\alpha/2} \\mathrm{SE}(\\hat{R}_k)$ 时。\n\n对于每个测试用例 $(r, p, n)$，总体算法流程如下：\n1. 对一个确定性随机数生成器进行播种。\n2. 使用指定的泊松-伽马混合方法从 $\\mathrm{NB}(r,p)$ 中生成 $n$ 个样本：对每个样本，抽取 $\\Lambda \\sim \\mathrm{Gamma}(r, (1-p)/p)$，然后从 $\\mathrm{Poisson}(\\Lambda)$ 中抽取样本值。\n3. 将样本聚合到频率直方图中，产生计数 $N_k$。\n4. 一个循环遍历从 $0$ 到最大观测值的所有整数 $k$。\n5. 对每个 $k$，计算合并计数 $M_k = N_k + N_{k+1}$。\n6. 如果 $M_k \\ge m_{\\min}$ 且 $\\hat{q}_k = N_{k+1}/M_k  1$，则认为索引 $k$ 有资格进行测试。\n7. 对每个合格的 $k$，计算理论量 $R_k$ 和 $q_k$，以及经验估计值 $\\hat{R}_k$。\n8. 使用理论值 $q_k$ 和观测值 $M_k$ 计算标准误差 $\\mathrm{SE}(\\hat{R}_k)$。\n9. 检查违规条件：$|R_k - \\hat{R}_k| > z_{1-\\alpha/2} \\mathrm{SE}(\\hat{R}_k)$。如果为真，则记录一次违规。\n10. 将所有合格 $k$ 的违规总数相加，并作为该测试用例的结果报告。如果没有合格的 $k$，则计数为 $0$。\n对所有指定的测试用例重复此过程。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run the Monte Carlo validation harness for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (r, p, n)\n        (5.0, 0.3, 200000),\n        (2.5, 0.7, 150000),\n        (0.7, 0.2, 300000),\n        (20.0, 0.5, 80000),\n        (1.3, 0.95, 120000),\n    ]\n\n    # Fixed parameters for the test harness\n    alpha = 0.01\n    m_min = 50\n    # Seed for reproducibility, as requested.\n    seed = 42\n    \n    # Pre-calculate the standard normal quantile\n    z_quantile = norm.ppf(1 - alpha / 2.0)\n    \n    # Initialize the random number generator\n    rng = np.random.default_rng(seed=seed)\n\n    results = []\n    \n    # Process each test case\n    for r, p, n in test_cases:\n        violation_count = run_test_case(r, p, n, m_min, z_quantile, rng)\n        results.append(violation_count)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_test_case(r, p, n, m_min, z_quantile, rng):\n    \"\"\"\n    Runs the simulation and analysis for a single test case.\n    \n    Args:\n        r (float): Shape parameter of the Negative Binomial distribution.\n        p (float): Success probability parameter.\n        n (int): Sample size for the simulation.\n        m_min (int): Minimum pooled count for a cell pair to be eligible.\n        z_quantile (float): The z-score for the confidence interval.\n        rng (numpy.random.Generator): The random number generator instance.\n        \n    Returns:\n        int: The total count of violations for the test case.\n    \"\"\"\n    \n    # --- Step 1: Simulation Engine ---\n    # Generate samples using the Poisson-Gamma mixture representation\n    # Lambda ~ Gamma(shape=r, scale=(1-p)/p)\n    # X | Lambda ~ Poisson(Lambda)\n    if n == 0:\n        return 0\n        \n    gamma_scale = (1.0 - p) / p\n    lambda_samples = rng.gamma(shape=r, scale=gamma_scale, size=n)\n    nb_samples = rng.poisson(lam=lambda_samples, size=n)\n\n    # --- Step 2: Empirical Histogram ---\n    # Form the histogram counts Nk for k = 0, 1, 2, ...\n    if nb_samples.size == 0:\n        max_k_obs = -1\n    else:\n        max_k_obs = np.max(nb_samples)\n    \n    # We need counts up to max_k_obs + 1 for the loop\n    hist_counts = np.bincount(nb_samples, minlength=max_k_obs + 2)\n    \n    violations = 0\n    \n    # Iterate through all possible k values where Nk and N_{k+1} can be non-zero\n    for k in range(max_k_obs + 1):\n        N_k = hist_counts[k]\n        N_k_plus_1 = hist_counts[k + 1]\n        \n        M_k = N_k + N_k_plus_1\n        \n        # --- Step 3: Check Eligibility ---\n        if M_k  m_min:\n            continue\n            \n        # --- Step 4: Empirical and Theoretical Calculations ---\n        # Empirical two-cell conditional proportion\n        hat_q_k = N_k_plus_1 / M_k\n        \n        # According to the problem, the estimator for Rk is only defined for hat_q_k  1.\n        if hat_q_k >= 1.0:\n            continue\n            \n        # Empirical adjacent ratio\n        hat_R_k = hat_q_k / (1.0 - hat_q_k)\n        \n        # Theoretical adjacent ratio R_k = (k+r)/(k+1) * (1-p)\n        R_k = (k + r) / (k + 1.0) * (1.0 - p)\n        \n        # Theoretical two-cell conditional proportion q_k = R_k / (1 + R_k)\n        q_k = R_k / (1.0 + R_k)\n\n        # --- Step 5: Confidence Interval and Violation Check ---\n        # The standard error of hat_R_k uses the theoretical q_k as specified.\n        # SE(hat_R_k) = sqrt( q_k / (M_k * (1-q_k)^3) )\n        if q_k == 0.0 or q_k >= 1.0:\n            # This case is theoretically unlikely but guards against numerical issues.\n            continue\n        \n        var_hat_R_k_numerator = q_k\n        var_hat_R_k_denominator = M_k * ((1.0 - q_k)**3)\n        \n        if var_hat_R_k_denominator == 0:\n            continue\n            \n        std_err_hat_R_k = np.sqrt(var_hat_R_k_numerator / var_hat_R_k_denominator)\n        \n        # CI half-width\n        half_width = z_quantile * std_err_hat_R_k\n        \n        # Check if the theoretical R_k is outside the CI\n        if np.abs(hat_R_k - R_k) > half_width:\n            violations += 1\n            \n    return violations\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3323022"}]}