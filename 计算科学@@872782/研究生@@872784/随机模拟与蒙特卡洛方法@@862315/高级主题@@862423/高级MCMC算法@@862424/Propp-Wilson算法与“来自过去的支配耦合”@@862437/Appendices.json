{"hands_on_practices": [{"introduction": "这个首个练习将 Propp-Wilson 算法剥离至其最基本的核心。通过分析一个简单的三状态生灭链，你将从第一性原理出发，推导出耦合发生的精确概率。这项实践对于建立关于极值状态“夹逼”过程如何运作的坚实直觉，以及理解耦合过程的动力学如何决定耦合时间至关重要。[@problem_id:3356322]", "problem": "考虑一个在有限偏序状态空间 $\\{0,1,2\\}$ 上的时间齐次生灭马尔可夫链，其在每个离散时间步的转移概率如下：\n- 从状态 $0$：以概率 $1/2$ 移动到 $1$，以概率 $1/2$ 停留在 $0$。\n- 从状态 $1$：以概率 $1/4$ 移动到 $0$，以概率 $1/4$ 停留在 $1$，以概率 $1/2$ 移动到 $2$。\n- 从状态 $2$：以概率 $1/2$ 移动到 $1$，以概率 $1/2$ 停留在 $2$。\n\n假设更新规则由一系列独立同分布的随机输入实现：在每个时间 $n$，从 $\\text{Uniform}(0,1)$ 分布中抽取一个输入 $U_{n}$，下一个状态由为每个当前状态 $i \\in \\{0,1,2\\}$ 定义的阈值映射 $F(i,U_{n})$ 给出，具体如下：\n$$\nF(0,u) = \\begin{cases}\n0,  0 \\le u  \\tfrac{1}{2},\\\\\n1,  \\tfrac{1}{2} \\le u \\le 1,\n\\end{cases}\n\\quad\nF(1,u) = \\begin{cases}\n0,  0 \\le u  \\tfrac{1}{4},\\\\\n1,  \\tfrac{1}{4} \\le u  \\tfrac{1}{2},\\\\\n2,  \\tfrac{1}{2} \\le u \\le 1,\n\\end{cases}\n\\quad\nF(2,u) = \\begin{cases}\n1,  0 \\le u  \\tfrac{1}{2},\\\\\n2,  \\tfrac{1}{2} \\le u \\le 1.\n\\end{cases}\n$$\n\n此更新函数相对于 $\\{0,1,2\\}$ 上的自然顺序是单调的，因此可以使用夹逼法实现 Propp–Wilson 从过去耦合 (CFTP) 方法：给定一个时间范围 $t \\in \\mathbb{N}$，在时间 $-t$ 从下界状态 $L_{0}=0$ 和上界状态 $U_{0}=2$ 开始，并将相同的更新输入 $U_{-t}, U_{-(t-1)}, \\dots, U_{-1}$ 向前应用到时间 $0$，以获得边界像 $L_{t}$ 和 $U_{t}$。到时间 $t$ 发生耦合当且仅当 $L_{t} = U_{t}$。\n\n仅使用单调马尔可夫链、Propp–Wilson CFTP 和上述更新规则的基本定义，从此夹逼方案下，从第一性原理推导到时间 $t$ 发生耦合的概率的精确闭式表达式（作为 $t$ 的函数）。您的最终答案必须是单一的解析表达式。不需要四舍五入，也不应包含单位。", "solution": "问题要求计算 Propp-Wilson 从过去耦合 (CFTP) 过程中到时间 $t$ 的耦合概率。该过程定义在状态空间 $S = \\{0, 1, 2\\}$ 上，其自然排序为 $0 \\le 1 \\le 2$。CFTP 算法采用夹逼法实现，从极端状态开始，设置一个下链 $L$ 和一个上链 $U$。模拟运行一个 $t$ 步的时间范围，从时间 $-t$ 到时间 $0$。\n\n设在给定时间下链的状态为 $l$，上链的状态为 $u$。模拟在时间 $-t$ 开始，初始状态为 $l_{-t} = 0$ 和 $u_{-t} = 2$。在从 $-t$ 到 $-1$ 的每一步 $k$，两个链都使用相同的随机数 $U_k \\sim \\text{Uniform}(0,1)$ 和单调更新函数 $F(i,u)$ 进行更新。设模拟 $n$ 步后（即在时间 $-t+n$）链的状态为 $(l_n, u_n)$。这个配对过程的初始状态是 $(l_0, u_0) = (0,2)$。$n$ 步后的状态是 $(l_n, u_n) = (F(l_{n-1}, U_{n-1}), F(u_{n-1}, U_{n-1}))$。我们关心的是 $t$ 步后链耦合的概率，即 $P(l_t = u_t)$。\n\n由于 $F$ 的单调性，我们保证对所有 $n \\ge 0$都有 $l_n \\le u_n$。配对过程 $(l_n, u_n)$ 的状态是集合 $\\{(i,j) \\in S \\times S \\mid i \\le j\\}$ 中的一个元素。当 $l_n = u_n$ 时发生耦合。因此，状态 $(0,0)$、$(1,1)$ 和 $(2,2)$ 是该配对过程的吸收态。一旦达到一个配对 $(i,i)$，所有后续状态都将是 $(F(i,U), F(i,U))$，这意味着链将保持耦合状态。\n\n配对过程的未耦合状态，即瞬态，是 $(0,1)$、$(0,2)$ 和 $(1,2)$。我们来分析这些瞬态之间的转移。设随机变量 $U$ 从 $\\text{Uniform}(0,1)$ 中抽取。下一个状态 $(l', u')$ 由 $(F(l,U), F(u,U))$ 给出。\n\n为了分析未耦合动态，我们定义三个状态：\n- 状态 $A$：配对为 $(0,2)$。\n- 状态 $B$：配对为 $(0,1)$。\n- 状态 $C$：配对为 $(1,2)$。\n- 状态 $D$：链已耦合（配对在 $\\{(0,0), (1,1), (2,2)\\}$ 中）。状态 $D$ 是吸收态。\n\n模拟的初始状态是 $(l_0, u_0) = (0,2)$，即状态 $A$。\n\n我们现在计算状态 $A, B, C$ 的单步转移概率。\n1.  从状态 $A = (0,2)$：\n    - 如果 $U \\in [0, \\frac{1}{2})$：$l' = F(0,U)=0$, $u' = F(2,U)=1$。新状态是 $(0,1)$，即 $B$。概率为 $P(U  \\frac{1}{2}) = \\frac{1}{2}$。\n    - 如果 $U \\in [\\frac{1}{2}, 1]$：$l' = F(0,U)=1$, $u' = F(2,U)=2$。新状态是 $(1,2)$，即 $C$。概率为 $P(U \\ge \\frac{1}{2}) = \\frac{1}{2}$。\n    - 转移总结：$P(A \\to A) = 0$, $P(A \\to B) = \\frac{1}{2}$, $P(A \\to C) = \\frac{1}{2}$, $P(A \\to D) = 0$。\n\n2.  从状态 $B = (0,1)$：\n    - 如果 $U \\in [0, \\frac{1}{4})$：$l' = F(0,U)=0$, $u' = F(1,U)=0$。新状态是 $(0,0)$，即 $D$ (耦合)。概率为 $P(U  \\frac{1}{4}) = \\frac{1}{4}$。\n    - 如果 $U \\in [\\frac{1}{4}, \\frac{1}{2})$：$l' = F(0,U)=0$, $u' = F(1,U)=1$。新状态是 $(0,1)$，即 $B$。概率为 $P(\\frac{1}{4} \\le U  \\frac{1}{2}) = \\frac{1}{4}$。\n    - 如果 $U \\in [\\frac{1}{2}, 1]$：$l' = F(0,U)=1$, $u' = F(1,U)=2$。新状态是 $(1,2)$，即 $C$。概率为 $P(U \\ge \\frac{1}{2}) = \\frac{1}{2}$。\n    - 转移总结：$P(B \\to B) = \\frac{1}{4}$, $P(B \\to C) = \\frac{1}{2}$, $P(B \\to D) = \\frac{1}{4}$。\n\n3.  从状态 $C = (1,2)$：\n    - 如果 $U \\in [0, \\frac{1}{4})$：$l' = F(1,U)=0$, $u' = F(2,U)=1$。新状态是 $(0,1)$，即 $B$。概率为 $P(U  \\frac{1}{4}) = \\frac{1}{4}$。\n    - 如果 $U \\in [\\frac{1}{4}, \\frac{1}{2})$：$l' = F(1,U)=1$, $u' = F(2,U)=1$。新状态是 $(1,1)$，即 $D$ (耦合)。概率为 $P(\\frac{1}{4} \\le U  \\frac{1}{2}) = \\frac{1}{4}$。\n    - 如果 $U \\in [\\frac{1}{2}, 1]$：$l' = F(1,U)=2$, $u' = F(2,U)=2$。新状态是 $(2,2)$，即 $D$ (耦合)。概率为 $P(U \\ge \\frac{1}{2}) = \\frac{1}{2}$。\n    - 转移总结：$P(C \\to B) = \\frac{1}{4}$, $P(C \\to D) = \\frac{1}{4} + \\frac{1}{2} = \\frac{3}{4}$。\n\n设 $p_n(S)$ 是 $n$ 步后处于瞬态 $S \\in \\{A, B, C\\}$ 的概率。设 $v_n = [p_n(A), p_n(B), p_n(C)]^T$ 是这些概率的列向量。该向量的演化由 $v_{n+1} = T v_n$ 给出，其中 $T$ 是瞬态的转移矩阵。\n$$\nT = \\begin{pmatrix}\nP(A \\to A)  P(B \\to A)  P(C \\to A) \\\\\nP(A \\to B)  P(B \\to B)  P(C \\to B) \\\\\nP(A \\to C)  P(B \\to C)  P(C \\to C)\n\\end{pmatrix} = \\begin{pmatrix}\n0  0  0 \\\\\n\\frac{1}{2}  \\frac{1}{4}  \\frac{1}{4} \\\\\n\\frac{1}{2}  \\frac{1}{2}  0\n\\end{pmatrix}\n$$\n模拟从状态 $A$ 开始，因此初始概率向量为 $v_0 = [1, 0, 0]^T$。$t$ 步后，概率向量为 $v_t = T^t v_0$。到时间 $t$ 仍未耦合的概率 $S_t$ 是 $v_t$ 各分量之和。所求的耦合概率为 $P_c(t) = 1 - S_t$。\n\n为了计算 $T^t$，我们求 $T$ 的特征值和特征向量。特征方程为 $\\det(T - \\lambda I) = 0$：\n$$ \\det \\begin{pmatrix} -\\lambda  0  0 \\\\ \\frac{1}{2}  \\frac{1}{4}-\\lambda  \\frac{1}{4} \\\\ \\frac{1}{2}  \\frac{1}{2}  -\\lambda \\end{pmatrix} = -\\lambda \\left( \\left(\\frac{1}{4}-\\lambda\\right)(-\\lambda) - \\left(\\frac{1}{4}\\right)\\left(\\frac{1}{2}\\right) \\right) = -\\lambda \\left( \\lambda^2 - \\frac{1}{4}\\lambda - \\frac{1}{8} \\right) = 0 $$\n特征值为 $\\lambda_3 = 0$以及 $8\\lambda^2 - 2\\lambda - 1 = 0$ 的根，即 $\\lambda = \\frac{2 \\pm \\sqrt{4 - 4(8)(-1)}}{16} = \\frac{2 \\pm 6}{16}$。\n因此，特征值为 $\\lambda_1 = \\frac{8}{16} = \\frac{1}{2}$，$\\lambda_2 = \\frac{-4}{16} = -\\frac{1}{4}$ 和 $\\lambda_3 = 0$。\n\n接下来，我们求对应的特征向量：\n- 对于 $\\lambda_1 = \\frac{1}{2}$：$(T - \\frac{1}{2}I)x = 0$ 得到特征向量 $e_1 = [0, 1, 1]^T$。\n- 对于 $\\lambda_2 = -\\frac{1}{4}$：$(T + \\frac{1}{4}I)x = 0$ 得到特征向量 $e_2 = [0, 1, -2]^T$。\n- 对于 $\\lambda_3 = 0$：$Tx = 0$ 得到特征向量 $e_3 = [1, -1, -1]^T$。\n\n我们将初始向量 $v_0$ 表示为特征向量的线性组合：$v_0 = c_1 e_1 + c_2 e_2 + c_3 e_3$。\n$$ \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} = c_1 \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} + c_2 \\begin{pmatrix} 0 \\\\ 1 \\\\ -2 \\end{pmatrix} + c_3 \\begin{pmatrix} 1 \\\\ -1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} c_3 \\\\ c_1 + c_2 - c_3 \\\\ c_1 - 2c_2 - c_3 \\end{pmatrix} $$\n这给出了一个关于 $(c_1, c_2, c_3)$ 的线性方程组，解得 $c_1=1$, $c_2=0$, $c_3=1$。所以，$v_0 = e_1 + e_3$。\n\n现在我们可以计算 $v_t = T^t v_0$:\n$$ v_t = T^t(e_1 + e_3) = T^t e_1 + T^t e_3 = \\lambda_1^t e_1 + \\lambda_3^t e_3 $$\n问题指定 $t \\in \\mathbb{N}$，通常解释为 $t \\ge 1$。对于 $t \\ge 1$，$\\lambda_3^t = 0^t = 0$。\n$$ v_t = \\left(\\frac{1}{2}\\right)^t e_1 = \\left(\\frac{1}{2}\\right)^t \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ (\\frac{1}{2})^t \\\\ (\\frac{1}{2})^t \\end{pmatrix} $$\n这个向量给出了 $t$ 步后处于状态 $A, B, C$ 的概率。\n$p_t(A) = 0$, $p_t(B) = (\\frac{1}{2})^t$, $p_t(C) = (\\frac{1}{2})^t$。\n\n到时间 $t$ 仍未耦合的概率 $S_t$ 是这些概率的和：\n$$ S_t = p_t(A) + p_t(B) + p_t(C) = 0 + \\left(\\frac{1}{2}\\right)^t + \\left(\\frac{1}{2}\\right)^t = 2 \\left(\\frac{1}{2}\\right)^t = \\left(\\frac{1}{2}\\right)^{t-1} $$\n这个结果对 $t \\ge 1$ 成立。\n\n最后，到时间 $t$ 发生耦合的概率 $P_c(t)$ 是 $1$ 减去未耦合的概率：\n$$ P_c(t) = 1 - S_t = 1 - \\left(\\frac{1}{2}\\right)^{t-1} $$\n这可以重写为 $1 - 2^{1-t}$。这就是耦合概率作为时间范围 $t$ 的函数的闭式表达式。\n对于 $t=1$，$P_c(1) = 1 - 2^0 = 0$。这是正确的，因为第一步只能导致未耦合的状态 $(0,1)$ 或 $(1,2)$。对于 $t \\to \\infty$，$P_c(t) \\to 1$，这对于一个不可约且非周期的有限状态马尔可夫链是符合预期的。", "answer": "$$\n\\boxed{1 - 2^{1-t}}\n$$", "id": "3356322"}, {"introduction": "在理解了单调耦合的基础之后，这个练习将探讨其局限性。它提出了一个场景——在非二分图上的反铁磁伊辛模型——其中由于“阻挫”（frustration）现象，标准的单调CFTP算法不再适用。这个练习旨在挑战你理解单调性为何失效，并向你介绍“受控过去耦合”（Dominated Coupling From The Past, DCFTP），这是一种即使在特定条件下对非单调系统也有效的强大扩展。[@problem_id:3356306]", "problem": "考虑一个无向有限图 $G=(V,E)$ 和一个伊辛模型，其中自旋 $\\sigma_i \\in \\{-1,+1\\}$ （对于 $i \\in V$），吉布斯分布正比于 $\\exp\\big(\\sum_{\\{i,j\\}\\in E} J_{ij}\\sigma_i\\sigma_j + \\sum_{i\\in V} h_i \\sigma_i\\big)$，并采用单点热浴格劳伯动力学。回顾以下基本概念。\n\n- 如果对于任意两个满足逐坐标 $\\sigma \\le \\tau$ 的构型，在任何位点 $i$ 的更新映射都可以被耦合，使得更新后的自旋也几乎必然满足 $\\sigma' \\le \\tau'$，那么我们称马尔可夫链的更新相对于 $\\{-1,+1\\}^V$ 上的乘积偏序是单调的。对于位点 $i$ 的伊辛热浴更新，条件概率 $p_i(\\sigma_{-i}) := \\mathbb{P}(\\sigma_i=+1 \\mid \\sigma_{-i})$ 对每个邻居自旋 $\\sigma_j$ 都是非减的，当且仅当所有耦合 $\\{J_{ij}\\}_{j\\sim i}$ 都是非负的。\n\n- 逐点符号变换是一个映射 $\\tau_i = s_i \\sigma_i$，其中对每个 $i \\in V$ 都有 $s_i \\in \\{-1,+1\\}$。该变换将耦合变为 $J'_{ij} = J_{ij} s_i s_j$，将场变为 $h'_i = h_i s_i$。\n\n- 一个图 $G$ 是二分图，当且仅当其顶点集可以进行 2-着色，即 $V = U \\cup W$，使得每条边的两个端点一个在 $U$ 中，一个在 $W$ 中。等价地，$G$ 不包含奇圈。\n\n- Propp–Wilson 的从过去耦合 (CFTP) 算法的单调形式需要一个带有顶元和底元的偏序以及一个单调的更新映射，以确保从极端的初始状态出发能够合并。受控从过去耦合 (DCFTP) 算法构建一个由随机占优过程控制的逆时依赖图；如果此逆向探索几乎必然终止，则无需单调性即可产生精确样本。\n\n关注在三角图 $C_3$ 上的反铁磁情况，其中所有 $\\{i,j\\}\\in E$ 的成对耦合均为 $J_{ij} = -\\beta$，所有 $i\\in V$ 的外场均为 $h_i=0$，且 $\\beta > 0$ 是一个固定的正常数。分析非二分性对单调变换的存在性以及完美采样的可行性的影响。\n\n以下哪个陈述是正确的？\n\nA. 存在一组符号 $\\{s_i\\}_{i\\in V}$ 的选择，使得逐点符号变换 $\\tau_i = s_i \\sigma_i$ 能将 $C_3$ 上的反铁磁伊辛模型变为一个铁磁模型，其中对所有 $\\{i,j\\}\\in E$ 都有 $J'_{ij} \\ge 0$，从而使得能够从顶元和底元开始进行单调的 Propp–Wilson CFTP。\n\nB. 在任何非二分图上，特别是在 $C_3$ 上，当所有原始耦合 $J_{ij}  0$ 时，没有任何逐点符号变换可以使所有变换后的耦合 $J'_{ij}$ 变为非负。因此，热浴更新在任何乘积序下都不是吸引的，标准的、使用顶和底边界链的单调 Propp–Wilson CFTP 算法无法应用。\n\nC. 即使没有吸引性，对于足够小的 $\\beta$（高温），也存在基于受控从过去耦合（DCFTP）的完美模拟方案。这些方案构建一个由一个亚临界分支过程主导的逆向依赖图，该分支过程保证几乎必然会消亡，从而为 $C_3$ 上的反铁磁伊辛模型产生精确样本。\n\nD. 非二分性意味着不存在任何适用于 $C_3$ 上该模型的完美采样算法，因为单调性是完美采样的必要条件。\n\nE. 通过修改动力学，改为使用热浴规则一次性对两个相邻自旋进行块更新，总能在 $C_3$ 上恢复一个单调的更新映射，因此无论 $\\beta$ 为何值，单调的 Propp–Wilson CFTP 都变得适用。", "solution": "该问题要求分析三角图 $C_3$ 上的反铁磁伊辛模型，特别是关于完美采样算法如从过去耦合 (CFTP) 的适用性。\n\n该模型定义在图 $G=(V,E)$ 上，其中 $V=\\{1,2,3\\}$ 且 $E=\\{\\{1,2\\}, \\{2,3\\}, \\{3,1\\}\\}$。吉布斯分布正比于 $\\exp\\big(\\sum_{\\{i,j\\}\\in E} J_{ij}\\sigma_i\\sigma_j\\big)$，其中耦合为 $J_{ij} = -\\beta$（对于常数 $\\beta>0$），外场为 $h_i=0$。哈密顿量为 $H(\\sigma) = -\\sum_{\\{i,j\\}\\in E} J_{ij}\\sigma_i\\sigma_j = \\beta(\\sigma_1\\sigma_2 + \\sigma_2\\sigma_3 + \\sigma_3\\sigma_1)$。系统倾向于最小化这个能量，这有利于相邻自旋的反向排列，是反铁磁体的典型特征。\n\n标准的单调 Propp-Wilson CFTP 算法对于单点热浴动力学要求更新规则是单调的。这当且仅当所有耦合 $J_{ij}$ 都是非负的（铁磁模型）时才成立。问题探讨了给定的反铁磁模型是否可以通过逐点符号变换 $\\tau_i = s_i \\sigma_i$（其中 $s_i \\in \\{-1, +1\\}$）变为铁磁模型。这样的变换将耦合变为 $J'_{ij} = J_{ij} s_i s_j$。对于我们的模型，$J'_{ij} = (-\\beta) s_i s_j$。为了使这些耦合非负，我们需要对所有相邻对 $\\{i,j\\}$ 都有 $s_i s_j = -1$。这意味着相邻的顶点必须有不同的符号。这等价于为图 $G$ 找到一个 2-着色。一个图是 2-可着色的当且仅当它是二分图（不包含奇数长度的圈）。图 $C_3$ 是一个长度为 3 的圈，是奇圈，因此它不是二分图。因此，不可能找到一组符号 $\\{s_i\\}$ 使得所有变换后的耦合 $J'_{ij}$ 都非负。这种反铁磁相互作用在非二分图上不能同时被满足的现象被称为阻挫。\n\n现在我们评估每个陈述。\n\n**A. 存在一组符号 $\\{s_i\\}_{i\\in V}$ 的选择，使得逐点符号变换 $\\tau_i = s_i \\sigma_i$ 能将 $C_3$ 上的反铁磁伊辛模型变为一个铁磁模型，其中对所有 $\\{i,j\\}\\in E$ 都有 $J'_{ij} \\ge 0$，从而使得能够从顶元和底元开始进行单调的 Propp–Wilson CFTP。**\n\n如上所述，这样的符号变换等价于为图 $C_3$ 找到一个 2-着色。由于 $C_3$ 是一个奇圈，它不是二分图，因此不是 2-可着色的。不存在这样的符号 $\\{s_i\\}$ 选择。沿圈所需的符号关系之积为 $(s_1 s_2)(s_2 s_3)(s_3 s_1) = (-1)^3 = -1$，而代数上该表达式为 $s_1^2 s_2^2 s_3^2=1$，这是一个矛盾。因此，该模型不能被转换为铁磁模型，这条应用单调 CFTP 的路径是行不通的。\n**结论：不正确。**\n\n**B. 在任何非二分图上，特别是在 $C_3$ 上，当所有原始耦合 $J_{ij}  0$ 时，没有任何逐点符号变换可以使所有变换后的耦合 $J'_{ij}$ 变为非负。因此，热浴更新在任何乘积序下都不是吸引的，标准的、使用顶和底边界链的单调 Propp–Wilson CFTP 算法无法应用。**\n\n这个陈述是正确的。第一部分是上面讨论的阻挫的一般原理：非二分图上的反铁磁模型不能通过规范变换变为铁磁模型。第二部分是其直接后果。单点热浴动力学相对于 $\\{-1,+1\\}^V$ 上的标准乘积序的吸引性（单调性）要求所有耦合 $J_{ij}$ 都为非负。相对于一个不同的（由符号 $\\{s_i\\}$ 关联的）乘积序的吸引性等价于变换后的变量 $\\{\\tau_i\\}$ 相对于标准序的吸引性，这要求所有 $J'_{ij}$ 都为非负。由于这无法实现，该动力学在任何乘积序下都不是吸引的。标准的单调 Propp-Wilson CFTP 算法的机制，即耦合从极端状态（全为 $+1$ 和全为 $-1$）开始的链，根本上依赖于这种吸引性。没有它，该算法的标准形式就无法应用。\n**结论：正确。**\n\n**C. 即使没有吸引性，对于足够小的 $\\beta$（高温），也存在基于受控从过去耦合（DCFTP）的完美模拟方案。这些方案构建一个由一个亚临界分支过程主导的逆向依赖图，该分支过程保证几乎必然会消亡，从而为 $C_3$ 上的反铁磁伊辛模型产生精确样本。**\n\n这个陈述正确地描述了一种替代的完美采样方法，即 DCFTP，它不需要单调性。它的收敛性取决于系统中的依赖关系是否足够弱。对于伊辛模型，这对应于高温区（小 $\\beta$）。在这个区域，系统满足诸如 Dobrushin 唯一性条件之类的条件，这意味着任何单个自旋对另一个自旋的影响会迅速衰减。DCFTP 的逆向依赖探索于是可以被一个简单的过程（如 Galton-Watson 分支过程）随机主导。如果这个主导过程中“后代”的期望数量小于 1（即它是亚临界的），该过程几乎必然会消亡，这意味着 DCFTP 算法会终止并产生一个精确样本。对于任何有限图上的有限范围伊辛模型，包括我们在 $C_3$ 上的情况，只要 $\\beta$ 足够小，这样的高温区总是存在的。\n**结论：正确。**\n\n**D. 非二分性意味着不存在任何适用于 $C_3$ 上该模型的完美采样算法，因为单调性是完美采样的必要条件。**\n\n这个陈述在事实上是不正确的。单调性是完美采样的充分条件，但不是必要条件。正如在选项 C 的分析中确立的，DCFTP 算法是一种有效的完美采样方法，它不需要单调性，并且可以应用于高温区的 $C_3$ 上的反铁磁伊辛模型。DCFTP 的存在为“不存在任何完美采样算法”这一论断提供了一个直接的反例。\n**结论：不正确。**\n\n**E. 通过修改动力学，改为使用热浴规则一次性对两个相邻自旋进行块更新，总能在 $C_3$ 上恢复一个单调的更新映射，因此无论 $\\beta$ 为何值，单调的 Propp–Wilson CFTP 都变得适用。**\n\n这个陈述提议通过使用块更新来恢复单调性。让我们分析在自旋 $\\sigma_3$ 状态给定的条件下，对自旋块 $\\{\\sigma_1, \\sigma_2\\}$ 的更新。该块的热浴规则意味着从条件吉布斯分布 $\\mathbb{P}(\\sigma_1, \\sigma_2 \\mid \\sigma_3) \\propto \\exp(-H(\\sigma_1,\\sigma_2|\\sigma_3))$ 中采样，其中 $H$ 是哈密顿量。哈密顿量的相关部分是 $H = \\beta(\\sigma_1\\sigma_2 + \\sigma_2\\sigma_3 + \\sigma_3\\sigma_1)$。条件概率正比于 $\\exp(-\\beta\\sigma_1\\sigma_2 - \\beta\\sigma_3(\\sigma_1+\\sigma_2))$。为了检查单调性，我们分析当 $\\sigma_3$ 从 $-1$ 翻转到 $+1$ 时，这个分布如何变化。概率之比为：\n$$ \\frac{\\mathbb{P}(\\sigma_1, \\sigma_2 \\mid \\sigma_3=+1)}{\\mathbb{P}(\\sigma_1, \\sigma_2 \\mid \\sigma_3=-1)} = \\frac{\\exp(-\\beta\\sigma_1\\sigma_2 - \\beta(\\sigma_1+\\sigma_2))}{\\exp(-\\beta\\sigma_1\\sigma_2 + \\beta(\\sigma_1+\\sigma_2))} = \\exp(-2\\beta(\\sigma_1+\\sigma_2)) $$\n这个比率随着和 $\\sigma_1+\\sigma_2$ 的增加而减小。例如，当 $\\sigma_3$ 从 $-1$ 翻转到 $+1$ 时，状态 $(\\sigma_1, \\sigma_2) = (+1,+1)$（和为 $2$）相对于状态 $(-1,-1)$（和为 $-2$）变得更不可能。这是相对于块上标准乘积序的反单调性的定义。该更新没有恢复单调性，而是逆转了它。声称这“总是”有效且“无论 $\\beta$ 为何值”是错误的。\n**结论：不正确。**", "answer": "$$\\boxed{BC}$$", "id": "3356306"}, {"introduction": "最后的这项实践将从理论过渡到实际的代码实现。你的任务是为波茨模型的 Fortuin-Kasteleyn (FK) 表示应用单调CFTP，这是计算统计物理学的一个基石。这个动手编程练习将演示如何在更抽象的状态空间（键构型）上定义合适的偏序，并通过与一种会失败的朴素方法的对比，强调选择正确动力学以确保单调性的重要性。[@problem_id:3356348]", "problem": "你的任务是设计、分析并实现一个程序，通过 Fortuin–Kasteleyn (FK) 表示来探索过去耦合 (CFTP) 和受控 CFTP 思想在铁磁 Potts 模型中进行精确抽样的应用。重点是通过在键构型上定义偏序来研究 Swendsen–Wang 动力学的单调 CFTP 可行性，并评估在该序下合并检测的实用性。\n\n必须使用以下基本基础，不得走捷径：\n- 一个有限无向图由一个顶点集 $V$（其中 $\\lvert V \\rvert = n$）和一个边集 $E \\subseteq \\{ \\{u,v\\} : u,v \\in V, u \\neq v \\}$（其中 $\\lvert E \\rvert = m$）给出。\n- 图 $G=(V,E)$ 上的 $q$ 态铁磁 Potts 模型的自旋为 $\\sigma \\in \\{1,2,\\dots,q\\}^{V}$，其概率与 $\\exp\\left(\\beta \\sum_{\\{u,v\\}\\in E} \\mathbf{1}\\{\\sigma(u)=\\sigma(v)\\}\\right)$ 成正比，其中逆温度 $\\beta \\ge 0$。\n- Edwards–Sokal (ES) 耦合将 Potts 模型与参数为 $(p,q)$ 的 FK 随机簇测度联系起来，其中 $p = 1 - e^{-\\beta}$；键构型 $\\omega \\in \\{0,1\\}^{E}$ 上的 FK 测度的概率与 $p^{\\lvert \\omega \\rvert} (1-p)^{m - \\lvert \\omega \\rvert} q^{k(\\omega)}$ 成正比，其中 $k(\\omega)$ 是由开边 $\\{e \\in E : \\omega(e)=1\\}$ 诱导的子图中的连通分量数。\n- Swendsen–Wang (SW) 动力学使用 ES 耦合：给定一个自旋构型 $\\sigma_t$，当且仅当 $\\sigma_t(u)=\\sigma_t(v)$ 时，在边 $\\{u,v\\}$ 上以概率 $p$ 独立地打开键 $B_t$；然后，$(V, B_t)$ 的每个连通分量被赋予一个从 $\\{1,\\dots,q\\}$ 中均匀抽取的新自旋，各分量之间独立。\n- 键构型上的一个偏序是逐坐标包含关系：对于 $\\omega, \\omega' \\in \\{0,1\\}^{E}$，定义 $\\omega \\preceq \\omega'$ 当且仅当 $\\{e \\in E : \\omega(e)=1\\} \\subseteq \\{e \\in E : \\omega'(e)=1\\}$。\n\n你的程序必须执行两个实验，并报告在 CFTP 风格的构造下合并的可行性：\n1. FK 随机簇单边热浴动力学的单调 CFTP：\n   - 考虑对从 $E$ 中均匀选择的一条边 $e = \\{u,v\\}$ 进行热浴更新。给定当前键构型 $\\omega$，令 $\\omega^{\\setminus e}$ 表示移除了边 $e$ 的构型。$\\omega(e)$ 的条件开放概率为：\n     - 如果 $u$ 和 $v$ 在由 $\\omega^{\\setminus e}$ 的开边诱导的图中是连通的，则设置 $\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e}) = p$。\n     - 否则，设置 $\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e}) = \\dfrac{p}{p + (1-p) q}$。\n   - 已知对于 $q \\ge 1$，此链在包含序下是吸引的。使用由固定的边选择序列和独立的均匀变量驱动的宏大耦合，以实现带有包含序的单调 CFTP。使用倍增调度：从时间 $-1$ 到 $0$ 模拟链，然后从 $-2$ 到 $0$，再从 $-4$ 到 $0$，依此类推，使用相同的驱动随机性。将下链和上链分别从最小和最大键构型（所有边都关闭和所有边都打开）开始。当时间 $0$ 时下构型和上构型一致时，声明合并。\n   - 你必须为测试用例报告的合并时间是产生合并的最小倍增窗口中的单边更新次数。如果在指定的最大窗口大小内未检测到合并，则报告 $-1$。\n\n2. 尝试通过键序控制为 Swendsen–Wang 实现单调 CFTP：\n   - 如上定义键序偏序 $\\preceq$。对于 SW，时间 $t$ 的键形成使用逐边均匀变量 $U_{t,e} \\sim \\mathrm{Uniform}(0,1)$，并且当且仅当 $U_{t,e}  p$ 且自旋相等时打开 $\\{u,v\\}$。在键空间中的一种朴素的受控界定方法忽略自旋，并在每个时间 $t$ 提出一个上界键集 $U_t^{\\mathrm{up}} = \\{ e \\in E : U_{t,e}  p \\}$ 和一个下界键集 $U_t^{\\mathrm{low}} = \\varnothing$。\n   - 实现一个类似于 FK 情况的倍增调度，但使用上述朴素的键序界限；你的每个时间步的“上”和“下”键集仅由均匀变量 $U_{t,e}$ 驱动。在这种朴素方案下，仅当对于所有可能的自旋路径，上界和下界过程在时间 $0$ 必然重合时，才声明合并。在这种朴素方案中，一个必要条件是在模拟窗口的每个时间步中，对于所有 $e \\in E$ 都有 $U_{t,e} \\ge p$，在这种情况下，两个界限都强制键构型为 $\\varnothing$，SW 自旋重着色变得无关紧要。如果在最大窗口内未满足此条件，则报告 $-1$ 作为未能检测到合并。\n   - 这种构造旨在评估实用性：预计它只会在平凡或接近平凡的情况下（例如，$p=0$）检测到合并。\n\n你的实现约束：\n- 所有图必须被视为抽象的有限无向图，顶点索引为 $0,1,\\dots,n-1$，边指定为无序对 $\\{u,v\\}$，其中 $u \\neq v$。\n- 对于 FK 热浴动力学，你必须使用逻辑上正确的图搜索算法，计算当前开边子图（不包括正在更新的边）中端点的“连通性”。\n- 对于 CFTP，你必须实现一个倍增调度。驱动随机性（边选择和均匀变量）必须对一个测试用例是固定的，并可按时间可复现地索引，以便在不同倍增中单调耦合有效。\n- 所有随机变量必须使用每个测试用例中指定的固定种子生成，以确保可复现性。不允许外部数据或用户输入。\n\n测试套件：\n对于下面的每个测试用-例，你的程序必须计算并按规定返回一个整数。程序必须生成一行包含这些整数的逗号分隔列表，并用方括号括起来。\n\n- 案例 1 (FK 热浴，“理想路径”)：$n=4$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,3\\}, \\{3,0\\}\\}$, $q=2$, $p=0.5$, 最大倍增次数 $=12$, 种子 $=123$。\n- 案例 2 (FK 热浴，强耦合)：$n=4$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,3\\}\\}$, $q=3$, $p=0.9$, 最大倍增次数 $=12$, 种子 $=456$。\n- 案例 3 (SW 朴素键序尝试，不切实际的情况)：$n=3$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,0\\}\\}$, $q=2$, $p=0.5$, 最大倍增次数 $=12$, 种子 $=789$。\n- 案例 4 (SW 朴素键序尝试，边界情况)：$n=3$, $E=\\{\\{0,1\\}, \\{1,2\\}, \\{2,0\\}\\}$, $q=2$, $p=0.0$, 最大倍增次数 $=12$, 种子 $=42$。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔的结果列表（例如，“[r1,r2,r3,r4]”），其中 $r_i$ 是案例 $i$ 的整数结果。\n- 不涉及物理单位。所有数字都是纯整数。\n\n你的实现必须是完整的，可直接运行，并严格遵守最终输出格式和上述约束。", "solution": "核心任务是实现两个基于 CFTP 范式的不同模拟实验，两者都采用倍增窗口调度来寻找合并时间。第一个实验将标准的单调 CFTP 算法应用于 FK 随机簇模型，而第二个实验则分析了一种用于 Swendsen-Wang 算法的朴素 CFTP 式构造的可行性。\n\n### 实验 1：FK 热浴动力学的单调 CFTP\n\n**理论基础**\n过去耦合 (CFTP) 算法，特别是其单调变体，提供了一种从马尔可夫链的平稳分布中生成精确样本的方法。其有效性依赖于三个关键组成部分：\n$1$. 一个具有偏序 $\\preceq$ 的状态空间 $\\mathcal{S}$。\n$2$. $\\mathcal{S}$ 中有一个最小元 $\\omega_{\\min}$ 和一个最大元 $\\omega_{\\max}$，使得对于任何 $\\omega \\in \\mathcal{S}$，都有 $\\omega_{\\min} \\preceq \\omega \\preceq \\omega_{\\max}$。\n$3$. 一族由随机性 $U$ 参数化的更新函数 $\\{f(\\cdot, U)\\}$，这些函数关于偏序是单调的。也就是说，对于任意两个状态 $\\omega_1, \\omega_2 \\in \\mathcal{S}$，如果 $\\omega_1 \\preceq \\omega_2$，那么对于相同的随机性实现 $U$，有 $f(\\omega_1, U) \\preceq f(\\omega_2, U)$。\n\n在这个问题中，状态空间 $\\mathcal{S}$ 是图 $G=(V,E)$ 上所有键构型的集合，即 $\\mathcal{S} = \\{0,1\\}^E$。偏序是逐坐标包含关系：$\\omega \\preceq \\omega'$ 当且仅当 $\\omega$ 中的开边集合是 $\\omega'$ 中开边集合的子集。最小元 $\\omega_{\\min}$ 是所有边都关闭（$0$）的构型，最大元 $\\omega_{\\max}$ 是所有边都打开（$1$）的构型。\n\n更新函数对应于 FK 随机簇测度的单边热浴 Gibbs 采样器。选择一条边 $e=\\{u,v\\}$，并根据所有其他边 $\\omega^{\\setminus e}$ 的状态，从条件分布中重新采样它的状态。边 $e$ 为开的条件概率为：\n$$\n\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e}) = \n\\begin{cases} \np,  \\text{如果 } u \\text{ 和 } v \\text{ 在 } (V, \\omega^{\\setminus e}) \\text{ 中是连通的} \\\\\n\\frac{p}{p + (1-p)q},  \\text{否则} \n\\end{cases}\n$$\n对于 $q \\ge 1$，此更新确实是单调的。要理解这一点，设 $\\omega_1 \\preceq \\omega_2$。在 $\\omega^{\\setminus e}$ 中端点 $\\{u,v\\}$ 的连通性是一个单调属性：如果 $u$ 和 $v$ 在 $\\omega_1^{\\setminus e}$ 中是连通的，那么它们在 $\\omega_2^{\\setminus e}$ 中也必定是连通的。因为 $q \\ge 1$，我们有 $p + (1-p)q \\ge p + (1-p) = 1$，这意味着 $\\frac{p}{p + (1-p)q} \\le p$。因此，概率 $\\mathbb{P}(\\omega(e)=1 \\mid \\omega^{\\setminus e})$ 是 $\\omega^{\\setminus e}$ 在包含序下的一个非减函数。当使用一个共同的均匀随机变量 $U$ 来决定更新时（即，如果 $U  \\mathbb{P}(\\omega(e)=1 | \\omega^{\\setminus e})$ 则设置 $\\omega(e)=1$），产生的更新构型将保持偏序。\n\n**算法设计**\n该算法实现了一个倍增调度。我们寻找一个时间窗口 $[-T, 0)$，使得如果我们从时间 $-T$ 开始，分别在 $\\omega_{\\min}$ 和 $\\omega_{\\max}$ 启动两个链，并使用*完全相同的随机数序列*将它们演化到时间 $0$，它们在时间 $0$ 的状态是相同的。\n$1$. 初始化窗口大小 $T=1$。\n$2$. 开始一个循环，直到合并或达到最大倍增次数。\n$3$. 设置 $\\omega_{\\text{low}}( -T ) = \\omega_{\\min}$（所有边都关闭）和 $\\omega_{\\text{high}}( -T ) = \\omega_{\\max}$（所有边都打开）。\n$4$. 对于从 $-T$ 到 $-1$ 的每个时间步 $t$：\n    a. 生成此时间步的随机性：一个均匀选择的边索引 $i_t \\in \\{0, \\dots, m-1\\}$ 和一个均匀随机数 $U_t \\in [0,1)$。为确保有效的宏大耦合，此随机性必须是时间索引 $t$ 的确定性函数，并且在不同的倍增窗口中是可复现的。\n    b. 更新 $\\omega_{\\text{low}}$：令 $e = E[i_t]$。检查 $e$ 的端点在由 $\\omega_{\\text{low}}$ 的开边（不包括 $e$）定义的图中的连通性。这通过广度优先搜索（BFS）或深度优先搜索（DFS）完成。根据连通性，计算 $e$ 为开的概率 $P_{\\text{low}}$。如果 $U_t  P_{\\text{low}}$，则将 $\\omega_{\\text{low}}$ 中边 $e$ 的新状态设置为 $1$，否则为 $0$。\n    c. 使用相同的边 $e$ 和均匀变量 $U_t$，按照与 $\\omega_{\\text{low}}$ 相同的过程更新 $\\omega_{\\text{high}}$。\n$5$. 在时间 $0$，检查是否 $\\omega_{\\text{low}}(0) = \\omega_{\\text{high}}(0)$。\n$6$. 如果它们相同（已合并），算法终止。所需的合并时间是窗口大小 $T$。\n$7$. 如果它们不同，将窗口大小加倍 $T \\leftarrow 2T$ 并从步骤 3 重复。如果超过了允许的最大窗口大小，报告 $-1$。\n\n### 实验 2：为 Swendsen-Wang 尝试单调 CFTP\n\n**理论基础**\nSwendsen-Wang (SW) 动力学是自旋构型空间 $\\{1, \\dots, q\\}^V$ 上的一个马尔可夫链。单个更新步骤 $\\sigma_t \\to \\sigma_{t+1}$ 通过一个辅助键构型 $\\omega_t$ 进行：\n$1$. 给定 $\\sigma_t$，对于每条边 $e=\\{u,v\\}$，如果 $\\sigma_t(u)=\\sigma_t(v)$，则键 $\\omega_t(e)$ 以概率 $p$ 设置为 $1$。如果 $\\sigma_t(u) \\neq \\sigma_t(v)$，则 $\\omega_t(e)$ 设置为 $0$。这可以写成 $\\omega_t(e) = 1$ 当且仅当 $U_{t,e}  p$ 且 $\\sigma_t(u) = \\sigma_t(v)$，其中 $U_{t,e}$ 是 i.i.d. 的 $\\mathrm{Uniform}(0,1)$ 变量。\n$2$. 通过识别图 $(V, \\omega_t)$ 中的连通分量，并为每个分量从 $\\{1, \\dots, q\\}$ 中均匀且独立地分配一个新自旋，生成一个新的自旋构型 $\\sigma_{t+1}$。\n\n问题要求评估在键空间中的一种朴素控制方案。在每个时间 $t$，独立于自旋构型 $\\sigma_t$，我们可以为产生的键构型 $\\omega_t$ 定义一个下界和一个上界。\n- **下界：** $\\omega_{\\text{low}, t} = \\varnothing$（所有边都关闭）。这是一个有效的下界，因为一条边只有在自旋匹配时才能被激活，所以没有边能保证被激活。\n- **上界：** $\\omega_{\\text{up}, t} = \\{e \\in E : U_{t,e}  p\\}$。这是一个有效的上界，因为一条边只有在 $U_{t,e}  p$ 时才能被激活。\n\n**算法设计**\n该实验旨在寻找键构型 $\\omega_t$ 在所有可能的自旋路径下都唯一确定的条件。这发生当且仅当在模拟窗口内的所有时间步中，下界和上界都重合，即对于 $t \\in [-T, -1)$，$\\omega_{\\text{low}, t} = \\omega_{\\text{up}, t}$。这个条件简化为在窗口中的所有 $t$ 都有 $\\varnothing = \\{e \\in E : U_{t,e}  p\\}$。这等价于要求在窗口中的所有时间步 $t$ 和所有边 $e$ 上都有 $U_{t,e} \\ge p$。该算法是对这个条件的直接检查。\n\n$1$. 初始化窗口大小 $T=1$。\n$2$. 开始一个循环，直到条件满足或达到最大倍增次数。\n$3$. 对于窗口 $[-T, 0)$：\n    a. 假设条件成立 (`coalesced = True`)。\n    b. 对于从 $-T$ 到 $-1$ 的每个时间步 $t$：\n        i. 生成此步骤的随机性：一组 $m$ 个均匀随机数 $\\{U_{t,e}\\}_{e \\in E}$。\n        ii. 检查对于所有 $e \\in E$ 是否都有 $U_{t,e} \\ge p$。\n        iii. 如果对任何边此检查失败，则此窗口不满足条件。设置 `coalesced = False` 并跳出内层循环。\n$4$. 如果在检查窗口中所有时间步后 `coalesced` 仍然为 `True`，则算法终止。结果是窗口大小 $T$。\n$5$. 如果 `coalesced` 为 `False`，则将窗口大小加倍 $T \\leftarrow 2T$ 并重复。如果超过了允许的最大窗口大小，则报告 $-1$。\n这个实验旨在显示这种朴素方法的不可行性。所有 $m$ 条边同时满足 $U_{t,e} \\ge p$ 的概率是 $(1-p)^m$。要在大小为 $T$ 的窗口内一直保持此条件，概率为 $((1-p)^m)^T$，这个概率呈指数级衰减，使得对于任何非平凡的 $p > 0$ 和 $m > 0$，合并都极不可能。对于 $p=0$ 的特殊情况，条件 $U_{t,e} \\ge 0$ 总是为真，所以立即以 $T=1$ 找到合并。\n\n### 实现策略\n\n该解决方案将使用 Python 实现，并利用 `numpy` 库进行数值操作和随机数生成。每个测试用例都使用一个有种子的 `numpy.random.Generator` 实例以确保可复现性。对于宏大耦合，预先生成一个对应于最大可能模拟窗口的大量随机数（用于边选择和均匀变量）的缓冲区。大小为 $T$ 的窗口的模拟将确定性地使用此缓冲区的最后 $T$ 个条目，确保时间 $t$ 的随机性在不同倍增中保持不变。FK 情况下的图连通性将使用标准的 BFS 算法和 `collections.deque` 来实现。", "answer": "```python\nimport numpy as np\nimport collections\n\ndef is_connected(u, v, n, edges, omega):\n    \"\"\"\n    检查节点 u 和 v 在由开边诱导的子图中是否连通。\n    使用广度优先搜索（BFS）。\n    \n    Args:\n        u (int): 第一个顶点。\n        v (int): 第二个顶点。\n        n (int): 图中的顶点数。\n        edges (list): 图中所有边的列表。\n        omega (np.ndarray): 键构型（1 为开，0 为闭）。\n    \n    Returns:\n        bool: 如果 u 和 v 连通则为 True，否则为 False。\n    \"\"\"\n    if u == v:\n        return True\n    \n    adj = collections.defaultdict(list)\n    open_edges = np.where(omega)[0]\n    for edge_idx in open_edges:\n        n1, n2 = edges[edge_idx]\n        adj[n1].append(n2)\n        adj[n2].append(n1)\n        \n    q = collections.deque([u])\n    visited = {u}\n    \n    while q:\n        curr = q.popleft()\n        if curr == v:\n            return True\n        for neighbor in adj.get(curr, []):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                q.append(neighbor)\n    return False\n\ndef solve_fk_case(n, E, q, p, max_doublings, seed):\n    \"\"\"\n    解决实验 1：FK 热浴动力学的单调 CFTP。\n    \"\"\"\n    m = len(E)\n    edges = [tuple(e) for e in E]\n    max_window_size = 2**(max_doublings) # 稍大以避免切片时差一\n\n    # 预生成随机性以确保宏大耦合\n    rng = np.random.default_rng(seed)\n    random_edge_indices = rng.integers(0, m, size=max_window_size)\n    random_uniforms = rng.uniform(size=max_window_size)\n\n    window_size = 1\n    for d in range(max_doublings):\n        # 演化发生在时间 -window_size 到 -1\n        # 对应于索引 max_window_size - window_size 到 max_window_size - 1\n        start_idx = max_window_size - window_size\n        \n        # 下链从所有边都关闭开始\n        omega_low = np.zeros(m, dtype=bool)\n        # 上链从所有边都打开开始\n        omega_high = np.ones(m, dtype=bool)\n\n        for i in range(window_size):\n            t_idx = start_idx + i\n            edge_idx = random_edge_indices[t_idx]\n            U = random_uniforms[t_idx]\n            u, v = edges[edge_idx]\n\n            # 更新下链\n            omega_low_temp = np.copy(omega_low)\n            omega_low_temp[edge_idx] = False\n            conn_low = is_connected(u, v, n, edges, omega_low_temp)\n            prob_open_low = p if conn_low else p / (p + (1 - p) * q)\n            omega_low[edge_idx] = U  prob_open_low\n\n            # 使用相同的随机性更新上链\n            omega_high_temp = np.copy(omega_high)\n            omega_high_temp[edge_idx] = False\n            conn_high = is_connected(u, v, n, edges, omega_high_temp)\n            prob_open_high = p if conn_high else p / (p + (1 - p) * q)\n            omega_high[edge_idx] = U  prob_open_high\n        \n        if np.array_equal(omega_low, omega_high):\n            return window_size\n        \n        window_size *= 2\n\n    return -1\n\ndef solve_sw_case(n, E, q, p, max_doublings, seed):\n    \"\"\"\n    解决实验 2：为 Swendsen-Wang 尝试单调 CFTP。\n    \"\"\"\n    m = len(E)\n    max_window_size = 2**(max_doublings)\n    \n    # 预生成随机性。每个时间步需要 m 个均匀分布的数。\n    rng = np.random.default_rng(seed)\n    random_uniforms = rng.uniform(size=(max_window_size, m))\n\n    window_size = 1\n    for d in range(max_doublings):\n        start_idx = max_window_size - window_size\n        \n        coalesced_in_window = True\n        for i in range(window_size):\n            t_idx = start_idx + i\n            uniforms_t = random_uniforms[t_idx]\n            \n            # 朴素界在步骤 t 合并的条件是\n            # 对于所有边 e，U_{t,e} = p。\n            if not np.all(uniforms_t = p):\n                coalesced_in_window = False\n                break\n        \n        if coalesced_in_window:\n            return window_size\n        \n        window_size *= 2\n\n    return -1\n\ndef solve():\n    test_cases = [\n        # 案例 1 (FK 热浴，“理想路径”)\n        {'type': 'fk', 'n': 4, 'E': [[0,1], [1,2], [2,3], [3,0]], 'q': 2, 'p': 0.5, 'max_doublings': 12, 'seed': 123},\n        # 案例 2 (FK 热浴，强耦合)\n        {'type': 'fk', 'n': 4, 'E': [[0,1], [1,2], [2,3]], 'q': 3, 'p': 0.9, 'max_doublings': 12, 'seed': 456},\n        # 案例 3 (SW 朴素键序尝试，不切实际的情况)\n        {'type': 'sw', 'n': 3, 'E': [[0,1], [1,2], [2,0]], 'q': 2, 'p': 0.5, 'max_doublings': 12, 'seed': 789},\n        # 案例 4 (SW 朴素键序尝试，边界情况)\n        {'type': 'sw', 'n': 3, 'E': [[0,1], [1,2], [2,0]], 'q': 2, 'p': 0.0, 'max_doublings': 12, 'seed': 42},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'fk':\n            result = solve_fk_case(case['n'], case['E'], case['q'], case['p'], case['max_doublings'], case['seed'])\n        elif case['type'] == 'sw':\n            result = solve_sw_case(case['n'], case['E'], case['q'], case['p'], case['max_doublings'], case['seed'])\n        else:\n            raise ValueError(\"Unknown test case type\")\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()", "id": "3356348"}]}