{"hands_on_practices": [{"introduction": "为了有效地使用并行退火，我们必须首先理解其探索复杂能量景观的核心机制：副本交换。本练习邀请您为一个基础模型系统推导交换接受概率。通过此过程，您将对系统维度和温度间隔等因素如何关键性地影响算法效率获得定量的直觉理解[@problem_id:3326637]。", "problem": "考虑马尔可夫链蒙特卡洛（MCMC）框架下的并行退火方法，其中，逆温为 $\\beta$ 时的目标是 $d$ 维高斯乘积，其能量为 $U(x) = \\frac{1}{2}\\|x\\|^{2}$，密度为 $\\pi_{\\beta}(x) \\propto \\exp(-\\beta U(x))$。设两个相邻的逆温为 $\\beta_{1}$ 和 $\\beta_{2}$，满足 $\\beta_{2} - \\beta_{1} = \\Delta \\beta > 0$，平均逆温为 $\\bar{\\beta} = (\\beta_{1} + \\beta_{2})/2$。在一次交换移动中，提议交换独立状态 $x \\sim \\pi_{\\beta_{1}}$ 和 $y \\sim \\pi_{\\beta_{2}}$，其Metropolis接受概率为\n$$\n\\alpha = \\min\\left\\{1, \\exp\\big((\\beta_{1} - \\beta_{2})(U(x) - U(y))\\big)\\right\\}。\n$$\n从高斯乘积的定义和 $\\chi^{2}$ 分布的性质出发，对于大维度 $d$ 的情况，使用正态分布来近似能量差 $U(x) - U(y)$，并推导在这些相邻逆温之间，期望交换接受率 $\\mathbb{E}[\\alpha]$ 的主阶近似（对于小的 $\\Delta \\beta$）。你的推导必须清楚地展示该近似如何依赖于维度 $d$ 和平均逆温 $\\bar{\\beta}$。使用标准正态累积分布函数 $\\Phi$，将最终答案表示为包含 $d$、$\\bar{\\beta}$ 和 $\\Delta \\beta$ 的单个闭式解析表达式。无需四舍五入，且不涉及单位。", "solution": "用户希望推导并行退火模拟中期望交换接受概率的近似值。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件：**\n- 框架：并行退火，马尔可夫链蒙特卡洛（MCMC）。\n- 逆温 $\\beta$ 下的目标密度：$\\pi_{\\beta}(x) \\propto \\exp(-\\beta U(x))$，对于 $x \\in \\mathbb{R}^d$。\n- 能量函数：$U(x) = \\frac{1}{2}\\|x\\|^{2}$，即 $\\frac{1}{2}\\sum_{i=1}^{d} x_i^2$。\n- 逆温：两个相邻的层级，$\\beta_{1}$ 和 $\\beta_{2}$。\n- 温度差：$\\beta_{2} - \\beta_{1} = \\Delta \\beta > 0$。\n- 平均逆温：$\\bar{\\beta} = (\\beta_{1} + \\beta_{2})/2$。\n- 交换提议：交换独立状态 $x \\sim \\pi_{\\beta_{1}}$ 和 $y \\sim \\pi_{\\beta_{2}}$。\n- Metropolis接受概率：$\\alpha = \\min\\left\\{1, \\exp\\big((\\beta_{1} - \\beta_{2})(U(x) - U(y))\\big)\\right\\}$。\n- 任务：对于大维度 $d$ 和小 $\\Delta \\beta$ 的情况，推导期望交换接受率 $\\mathbb{E}[\\alpha]$ 的主阶近似。\n- 方法：使用 $\\chi^{2}$ 分布的性质，通过正态分布来近似能量差 $U(x) - U(y)$。\n- 要求的最终形式：一个依赖于 $d$、$\\bar{\\beta}$、$\\Delta \\beta$ 和标准正态累积分布函数 $\\Phi$ 的闭式表达式。\n\n**1.2. 使用已知条件进行验证：**\n- **科学依据：** 该问题牢固地植根于MCMC方法的理论，特别是并行退火。选择多维高斯分布作为目标分布是一个标准且易于解析处理的模型。交换接受概率是对此交换正确的Metropolis-Hastings概率。在高维系统中使用中心极限定理（通过 $\\chi^2$ 分布）是统计物理和计算统计学中的一种标准且有效的技术。所有概念在科学上都是合理的。\n- **良定性：** 问题陈述清晰、自洽，并提供了一个明确定义的目标：推导一个特定的近似。约束条件（大 $d$，小 $\\Delta \\beta$）指导着推导过程。预期会有一个唯一的解析解。\n- **客观性：** 问题使用精确的数学语言表述，没有歧义或主观因素。\n\n**1.3. 结论与行动：**\n该问题是有效的。它在科学上是合理的，是良定的，客观的，并且没有可辨别的缺陷。我将继续进行推导。\n\n### 步骤2：求解推导\n\n逆温为 $\\beta$ 时的目标概率密度由下式给出\n$$ \\pi_{\\beta}(x) = C_{\\beta} \\exp(-\\beta U(x)) = C_{\\beta} \\exp\\left(-\\frac{\\beta}{2} \\sum_{i=1}^d x_i^2\\right) = \\prod_{i=1}^d \\left(\\sqrt{\\frac{\\beta}{2\\pi}} \\exp\\left(-\\frac{\\beta}{2} x_i^2\\right)\\right) $$\n其中 $C_{\\beta}$ 是归一化常数。这表明，对于一个状态 $x \\sim \\pi_{\\beta}(x)$，每个分量 $x_i$ 都是从一个零均值的高斯分布 $\\mathcal{N}(0, \\sigma^2)$ 中抽取的独立随机变量，其方差为 $\\sigma^2 = 1/\\beta$。\n\n让我们来刻画能量 $U(x)$ 的分布。如果 $x_i \\sim \\mathcal{N}(0, 1/\\beta)$，那么 $\\sqrt{\\beta}x_i \\sim \\mathcal{N}(0, 1)$。一个标准正态变量的平方服从自由度为1的卡方分布，因此 $(\\sqrt{\\beta}x_i)^2 = \\beta x_i^2 \\sim \\chi^2_1$。\n\n能量为 $U(x) = \\frac{1}{2}\\sum_{i=1}^d x_i^2$。让我们考虑缩放后的能量 $2\\beta U(x)$：\n$$ 2\\beta U(x) = \\beta \\sum_{i=1}^d x_i^2 = \\sum_{i=1}^d (\\beta x_i^2) $$\n由于每一项 $\\beta x_i^2$ 都是一个独立的 $\\chi^2_1$ 变量，它们的和是一个自由度为 $d$ 的卡方变量：$2\\beta U(x) \\sim \\chi^2_d$。\n这意味着从 $\\pi_{\\beta}(x)$ 抽样的状态其能量 $U(x)$ 服从分布 $U(x) \\sim \\frac{1}{2\\beta}\\chi^2_d$。这是一个形状参数为 $k=d/2$ 且尺度参数为 $\\theta=1/\\beta$ 的伽马分布。\n\n一个 $\\chi^2_d$ 分布的均值和方差分别为 $d$ 和 $2d$。我们可以求出能量 $U(x)$ 的均值和方差：\n$$ \\mathbb{E}[U(x)] = \\mathbb{E}\\left[\\frac{1}{2\\beta}\\chi^2_d\\right] = \\frac{1}{2\\beta}\\mathbb{E}[\\chi^2_d] = \\frac{d}{2\\beta} $$\n$$ \\text{Var}(U(x)) = \\text{Var}\\left(\\frac{1}{2\\beta}\\chi^2_d\\right) = \\left(\\frac{1}{2\\beta}\\right)^2\\text{Var}(\\chi^2_d) = \\frac{2d}{4\\beta^2} = \\frac{d}{2\\beta^2} $$\n对于大的 $d$，中心极限定理指出 $\\chi^2_d$ 分布可以用正态分布来近似。因此，对于大的 $d$，$U(x)$ 的分布近似为正态分布：\n$$ U(x) \\approx \\mathcal{N}\\left(\\frac{d}{2\\beta}, \\frac{d}{2\\beta^2}\\right) $$\n我们关心的是能量差 $\\Delta U = U(x) - U(y)$，其中 $x \\sim \\pi_{\\beta_1}$ 和 $y \\sim \\pi_{\\beta_2}$ 是独立的。对于大的 $d$ 使用正态近似：\n$$ U(x) \\approx \\mathcal{N}\\left(\\frac{d}{2\\beta_1}, \\frac{d}{2\\beta_1^2}\\right) \\quad \\text{and} \\quad U(y) \\approx \\mathcal{N}\\left(\\frac{d}{2\\beta_2}, \\frac{d}{2\\beta_2^2}\\right) $$\n由于 $U(x)$ 和 $U(y)$ 是独立的，它们的差 $\\Delta U$ 也近似服从正态分布，$\\Delta U \\approx \\mathcal{N}(\\mu_{\\Delta U}, \\sigma^2_{\\Delta U})$，其均值和方差为：\n$$ \\mu_{\\Delta U} = \\mathbb{E}[U(x)] - \\mathbb{E}[U(y)] = \\frac{d}{2\\beta_1} - \\frac{d}{2\\beta_2} = \\frac{d(\\beta_2 - \\beta_1)}{2\\beta_1\\beta_2} = \\frac{d \\Delta\\beta}{2\\beta_1\\beta_2} $$\n$$ \\sigma^2_{\\Delta U} = \\text{Var}(U(x)) + \\text{Var}(U(y)) = \\frac{d}{2\\beta_1^2} + \\frac{d}{2\\beta_2^2} = \\frac{d}{2}\\left(\\frac{1}{\\beta_1^2} + \\frac{1}{\\beta_2^2}\\right) $$\n问题要求对小的 $\\Delta\\beta$ 作主阶近似。我们使用 $\\beta_1 = \\bar{\\beta} - \\Delta\\beta/2$ 和 $\\beta_2 = \\bar{\\beta} + \\Delta\\beta/2$。对于小的 $\\Delta\\beta$：\n$$ \\beta_1\\beta_2 = \\bar{\\beta}^2 - (\\Delta\\beta/2)^2 \\approx \\bar{\\beta}^2 $$\n$$ \\frac{1}{\\beta_1^2} + \\frac{1}{\\beta_2^2} \\approx \\frac{1}{\\bar{\\beta}^2} + \\frac{1}{\\bar{\\beta}^2} = \\frac{2}{\\bar{\\beta}^2} $$\n将这些代入均值和方差的表达式中，得到主阶近似：\n$$ \\mu_{\\Delta U} \\approx \\frac{d \\Delta\\beta}{2\\bar{\\beta}^2} $$\n$$ \\sigma^2_{\\Delta U} \\approx \\frac{d}{2}\\left(\\frac{2}{\\bar{\\beta}^2}\\right) = \\frac{d}{\\bar{\\beta}^2} $$\n交换接受概率为 $\\alpha = \\min\\{1, \\exp((\\beta_1 - \\beta_2)\\Delta U)\\}$。由于 $\\beta_1 - \\beta_2 = -\\Delta\\beta$，我们有：\n$$ \\alpha = \\min\\{1, \\exp(-\\Delta\\beta \\cdot \\Delta U)\\} $$\n让我们定义一个新的随机变量 $K = \\Delta\\beta \\cdot \\Delta U$。由于 $\\Delta U$ 近似服从正态分布，$K$ 也近似服从正态分布，$K \\approx \\mathcal{N}(\\mu_K, \\sigma_K^2)$，其中：\n$$ \\mu_K = \\Delta\\beta \\cdot \\mu_{\\Delta U} \\approx \\Delta\\beta \\cdot \\frac{d \\Delta\\beta}{2\\bar{\\beta}^2} = \\frac{d(\\Delta\\beta)^2}{2\\bar{\\beta}^2} $$\n$$ \\sigma_K^2 = (\\Delta\\beta)^2 \\cdot \\sigma^2_{\\Delta U} \\approx (\\Delta\\beta)^2 \\cdot \\frac{d}{\\bar{\\beta}^2} = \\frac{d(\\Delta\\beta)^2}{\\bar{\\beta}^2} $$\n从这些近似中出现了一个关键关系：$\\mu_K \\approx \\frac{1}{2}\\sigma_K^2$。从现在起，我们将对我们的近似变量使用这个精确关系。\n\n我们需要计算 $\\mathbb{E}[\\alpha] = \\mathbb{E}[\\min\\{1, \\exp(-K)\\}]$。设 $f_K(k)$ 是 $K \\approx \\mathcal{N}(\\mu_K, \\sigma_K^2)$ 的概率密度函数。期望由下式给出：\n$$ \\mathbb{E}[\\alpha] = \\int_{-\\infty}^{\\infty} \\min\\{1, e^{-k}\\} f_K(k) \\,dk $$\n我们根据 $k$ 的值将积分拆分：\n$$ \\mathbb{E}[\\alpha] = \\int_{-\\infty}^{0} 1 \\cdot f_K(k) \\,dk + \\int_{0}^{\\infty} e^{-k} f_K(k) \\,dk $$\n第一个积分是累积概率 $P(K \\le 0)$：\n$$ \\int_{-\\infty}^{0} f_K(k) \\,dk = P(K \\le 0) = \\Phi\\left(\\frac{0 - \\mu_K}{\\sigma_K}\\right) = \\Phi\\left(-\\frac{\\mu_K}{\\sigma_K}\\right) $$\n对于第二个积分，我们有：\n$$ \\int_{0}^{\\infty} e^{-k} f_K(k) \\,dk = \\int_{0}^{\\infty} e^{-k} \\frac{1}{\\sqrt{2\\pi\\sigma_K^2}} \\exp\\left(-\\frac{(k - \\mu_K)^2}{2\\sigma_K^2}\\right) \\,dk $$\n我们对被积函数指数中的项进行配方。指数内部的项为：\n$$ -k - \\frac{(k - \\mu_K)^2}{2\\sigma_K^2} = -\\frac{2k\\sigma_K^2 + k^2 - 2k\\mu_K + \\mu_K^2}{2\\sigma_K^2} = -\\frac{k^2 - 2k(\\mu_K - \\sigma_K^2) + \\mu_K^2}{2\\sigma_K^2} $$\n$$ = -\\frac{(k - (\\mu_K - \\sigma_K^2))^2 - (\\mu_K - \\sigma_K^2)^2 + \\mu_K^2}{2\\sigma_K^2} = -\\frac{(k - (\\mu_K - \\sigma_K^2))^2}{2\\sigma_K^2} - \\mu_K + \\frac{\\sigma_K^2}{2} $$\n所以被积函数变为：\n$$ \\exp\\left(-\\mu_K + \\frac{\\sigma_K^2}{2}\\right) \\frac{1}{\\sqrt{2\\pi\\sigma_K^2}} \\exp\\left(-\\frac{(k - (\\mu_K - \\sigma_K^2))^2}{2\\sigma_K^2}\\right) $$\n第二部分是正态分布 $\\mathcal{N}(\\mu_K - \\sigma_K^2, \\sigma_K^2)$ 的概率密度函数（PDF）。我们称服从此分布的随机变量为 $K'$。该积分变为：\n$$ \\exp\\left(-\\mu_K + \\frac{\\sigma_K^2}{2}\\right) \\int_{0}^{\\infty} f_{K'}(k) \\,dk = \\exp\\left(-\\mu_K + \\frac{\\sigma_K^2}{2}\\right) P(K' > 0) $$\n$$ P(K' > 0) = 1 - \\Phi\\left(\\frac{0 - (\\mu_K - \\sigma_K^2)}{\\sigma_K}\\right) = 1 - \\Phi\\left(\\frac{-\\mu_K + \\sigma_K^2}{\\sigma_K}\\right) = \\Phi\\left(\\frac{\\mu_K - \\sigma_K^2}{\\sigma_K}\\right) $$\n现在，我们使用关键关系 $\\mu_K = \\frac{1}{2}\\sigma_K^2$。指数前因子变为 $\\exp(-\\frac{1}{2}\\sigma_K^2 + \\frac{1}{2}\\sigma_K^2) = \\exp(0) = 1$。\n第一个积分部分中 $\\Phi$ 的参数变为：\n$$ -\\frac{\\mu_K}{\\sigma_K} = -\\frac{\\frac{1}{2}\\sigma_K^2}{\\sigma_K} = -\\frac{\\sigma_K}{2} $$\n第二个积分部分中 $\\Phi$ 的参数变为：\n$$ \\frac{\\mu_K - \\sigma_K^2}{\\sigma_K} = \\frac{\\frac{1}{2}\\sigma_K^2 - \\sigma_K^2}{\\sigma_K} = \\frac{-\\frac{1}{2}\\sigma_K^2}{\\sigma_K} = -\\frac{\\sigma_K}{2} $$\n结合这些结果，期望接受概率为：\n$$ \\mathbb{E}[\\alpha] \\approx \\Phi\\left(-\\frac{\\sigma_K}{2}\\right) + 1 \\cdot \\Phi\\left(-\\frac{\\sigma_K}{2}\\right) = 2\\Phi\\left(-\\frac{\\sigma_K}{2}\\right) $$\n最后，我们代入 $\\sigma_K$ 的表达式。由于 $\\Delta\\beta > 0$ 且 $\\bar{\\beta} > 0$，标准差为：\n$$ \\sigma_K = \\sqrt{\\frac{d(\\Delta\\beta)^2}{\\bar{\\beta}^2}} = \\frac{\\sqrt{d}\\Delta\\beta}{\\bar{\\beta}} $$\n期望接受概率的最终近似值为：\n$$ \\mathbb{E}[\\alpha] \\approx 2\\Phi\\left(-\\frac{\\sqrt{d}\\Delta\\beta}{2\\bar{\\beta}}\\right) $$\n该表达式将交换接受率与维度 $d$ 以及温度方案参数 $\\bar{\\beta}$ 和 $\\Delta\\beta$ 联系起来。", "answer": "$$\\boxed{2\\Phi\\left(-\\frac{\\sqrt{d}\\Delta\\beta}{2\\bar{\\beta}}\\right)}$$", "id": "3326637"}, {"introduction": "虽然并行退火和模拟退火都旨在增强采样，但它们的运作原理不同，导致了不同的实践权衡。本练习使用一个简单、直观的能量模型来比较PT和ST的混合特性，重点关注模拟退火的一个关键弱点：其对数权重 $g_k$ 准确性的敏感度。通过这个动手编程问题，您将明白为何并行退火在实践中通常被认为更具鲁棒性[@problem_id:3326582]。", "problem": "考虑一个具有三个微观态（表示为 $L$、$C$ 和 $R$）的离散能量景观，其能量函数 $U$ 由 $U(L) = 0$、$U(C) = h$ 和 $U(R) = 0$ 指定，其中 $h > 0$ 表示势垒高度。在逆温度 $\\beta$下，局部 Metropolis–Hastings 更新的一个宏观步定义为两次连续的提议，试图从一个势阱移动到势垒，然后从势垒移动到另一个势阱。在此宏观步定义下，并假设采用标准的 Metropolis 接受/拒绝机制，其中提议确定性地试图从任一势阱移动到 $C$，并确定性地试图从势垒移动到另一个势阱，那么在一个宏观步内，在逆温度 $\\beta$ 下从 $L$ 翻转到 $R$（对称地，从 $R$ 翻转到 $L$）的概率为 $e^{-\\beta h}$。\n\n模拟退火（Simulated Tempering, ST）的目标是状态 $x \\in \\{L,C,R\\}$ 和逆温度指数 $k \\in \\{1,\\dots,K\\}$ 的联合分布，其密度正比于 $\\exp(-\\beta_k U(x) + g_k)$，其中 $\\beta_k$ 是逆温度阶梯，$g_k$ 是标量对数权重。在 ST 中，关于温度的稳态边缘分布与配分函数 $Z(\\beta_k)$ 乘以对数权重的指数成正比，即\n$$\n\\pi_k^{\\mathrm{ST}} \\propto Z(\\beta_k)\\, e^{g_k}, \\quad \\text{其中} \\quad Z(\\beta) = \\sum_{x \\in \\{L,C,R\\}} e^{-\\beta U(x)} = 2 + e^{-\\beta h}.\n$$\n并行退火（Parallel Tempering, PT）使用 $K$ 个副本，每个副本对应一个逆温度 $\\beta_k$，并尝试进行相邻交换；在目前的构造中，对于限制在 $\\{L,R\\}$ 的状态，交换总是被接受，因为 $U(L) = U(R)$，所以在稳态下，在 $\\beta=1$ 处执行更新的副本标识在温度阶梯上是均匀分布的。因此，在 PT 下，$\\beta=1$ 处的势阱状态每个宏观步发生变化的概率等于整个温度阶梯上的平均转移概率，\n$$\nM_{\\mathrm{PT}} = \\frac{1}{K} \\sum_{k=1}^K e^{-\\beta_k h}.\n$$\n相反，在 ST 下，$\\beta=1$ 处的势阱状态每个宏观步发生变化的概率等于该温度下的稳态占据率与该处的局部翻转概率的乘积，\n$$\nM_{\\mathrm{ST}} = \\pi_1^{\\mathrm{ST}}\\, e^{-\\beta_1 h}, \\quad \\text{其中} \\quad \\pi_1^{\\mathrm{ST}} = \\frac{Z(\\beta_1)\\, e^{g_1}}{\\sum_{j=1}^K Z(\\beta_j) e^{g_j}}.\n$$\n这种构造隔离了 ST 中不准确的 $g_k$ 的影响，这些不准确的 $g_k$ 通过稳态分布导致了不同温度下占据率的倾斜，从而改变了 $\\beta=1$ 处的 $M_{\\mathrm{ST}}$，而 $M_{\\mathrm{PT}}$ 只依赖于温度阶梯。\n\n你的任务是实现一个程序，对于给定的势垒高度 $h$、逆温度阶梯 $(\\beta_1,\\dots,\\beta_K)$ 和对数权重 $(g_1,\\dots,g_K)$，计算退化比\n$$\nR = \\frac{M_{\\mathrm{ST}}}{M_{\\mathrm{PT}}}.\n$$\n较小的 $R$ 值表示，相对于使用相同温度阶梯的 PT，ST 在 $\\beta=1$ 处的混合效果更差。请基于指定的联合 ST 目标、配分函数和宏观步翻转概率 $e^{-\\beta h}$，从第一性原理推导出该比率，而不使用任何非由这些定义所蕴含的额外公式。\n\n请使用以下参数值测试套件：\n\n- 测试用例 1（一般情况，权重不准确，默认偏向高温）：$h = 6.0$，$(\\beta_1,\\beta_2,\\beta_3) = (1.0,0.5,0.2)$，$(g_1,g_2,g_3) = (0.0,0.0,0.0)$。\n- 测试用例 2（更严重不准确的 $g_k$ 使其偏向高温）：$h = 6.0$，$(\\beta_1,\\beta_2,\\beta_3) = (1.0,0.5,0.2)$，$(g_1,g_2,g_3) = (0.0,1.5,2.0)$。\n- 测试用例 3（势垒较低，权重与测试用例1同样不准确）：$h = 3.0$，$(\\beta_1,\\beta_2,\\beta_3) = (1.0,0.5,0.2)$，$(g_1,g_2,g_3) = (0.0,0.0,0.0)$。\n- 测试用例 4（ST 中使用完美权重的对照组）：$h = 6.0$，$(\\beta_1,\\beta_2,\\beta_3) = (1.0,0.5,0.2)$，且 $g_k = -\\log Z(\\beta_k)$ 对 $k=1,2,3$ 成立。\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，结果按测试用例的顺序排列，每个元素是对应测试用例的 $R$ 的浮点数值。例如，输出格式必须严格为 $[r_1,r_2,r_3,r_4]$ 的形式，不得包含任何额外文本。\n\n此计算不涉及物理单位；所有量均为无量纲量。本问题不涉及角度。请将所有数字表示为十进制浮点值。", "solution": "该问题要求计算退化比 $R$，其定义为模拟退火（$M_{\\mathrm{ST}}$）和并行退火（$M_{\\mathrm{PT}}$）混合概率之比，$R = M_{\\mathrm{ST}}/M_{\\mathrm{PT}}$。该比率量化了在目标逆温度 $\\beta_1=1$ 下，模拟退火相对于在相同温度阶梯上理想化的并行退火设置的性能。推导和计算完全基于所提供的原理和定义。\n\n首先，我们回顾两种方法每个宏观步的翻转概率的定义。对于并行退火（PT），问题指定了一种构造，其中目标逆温度 $\\beta_1$ 处的副本从整个 $K$ 个逆温度的阶梯 $\\{\\beta_k\\}_{k=1}^K$ 中均匀采样。因此，其有效翻转概率是整个阶梯上局部翻转概率 $e^{-\\beta_k h}$ 的平均值：\n$$\nM_{\\mathrm{PT}} = \\frac{1}{K} \\sum_{k=1}^K e^{-\\beta_k h}\n$$\n\n对于模拟退火（ST），系统在状态 $x$ 和温度指数 $k$ 的联合空间中演化。在目标逆温度 $\\beta_1$ 处状态翻转的概率是系统处于该温度的稳态概率 $\\pi_1^{\\mathrm{ST}}$ 与该温度下局部翻转概率 $e^{-\\beta_1 h}$ 的乘积。\n$$\nM_{\\mathrm{ST}} = \\pi_1^{\\mathrm{ST}}\\, e^{-\\beta_1 h}\n$$\n稳态概率 $\\pi_1^{\\mathrm{ST}}$ 依赖于对数权重 $g_k$ 和每个温度下的配分函数 $Z(\\beta_k)$。问题给出了关于温度的稳态边缘概率的表达式：\n$$\n\\pi_k^{\\mathrm{ST}} \\propto Z(\\beta_k)\\, e^{g_k}\n$$\n对此进行归一化，得到 $k=1$ 时的概率：\n$$\n\\pi_1^{\\mathrm{ST}} = \\frac{Z(\\beta_1)\\, e^{g_1}}{\\sum_{j=1}^K Z(\\beta_j) e^{g_j}}\n$$\n我们还得到了具有能量势垒 $h$ 的三态系统的配分函数 $Z(\\beta)$：\n$$\nZ(\\beta) = \\sum_{x \\in \\{L,C,R\\}} e^{-\\beta U(x)} = e^{-\\beta \\cdot 0} + e^{-\\beta h} + e^{-\\beta \\cdot 0} = 2 + e^{-\\beta h}\n$$\n\n为了推导退化比 $R$，我们将 $M_{\\mathrm{ST}}$ 和 $M_{\\mathrm{PT}}$ 的表达式代入其定义中：\n$$\nR = \\frac{M_{\\mathrm{ST}}}{M_{\\mathrm{PT}}} = \\frac{\\pi_1^{\\mathrm{ST}}\\, e^{-\\beta_1 h}}{\\frac{1}{K} \\sum_{k=1}^K e^{-\\beta_k h}}\n$$\n接下来，我们代入 $\\pi_1^{\\mathrm{ST}}$ 的完整表达式：\n$$\nR = \\frac{\\left( \\frac{Z(\\beta_1)\\, e^{g_1}}{\\sum_{j=1}^K Z(\\beta_j) e^{g_j}} \\right) e^{-\\beta_1 h}}{\\frac{1}{K} \\sum_{k=1}^K e^{-\\beta_k h}}\n$$\n整理此表达式可得到退化比的最终公式，该公式可以直接通过编程实现：\n$$\nR = \\frac{K \\cdot Z(\\beta_1) \\cdot e^{g_1} \\cdot e^{-\\beta_1 h}}{\\left(\\sum_{j=1}^K Z(\\beta_j) e^{g_j}\\right) \\left(\\sum_{k=1}^K e^{-\\beta_k h}\\right)}\n$$\n此公式仅依赖于给定的参数：势垒高度 $h$、逆温度阶梯 $\\boldsymbol{\\beta} = (\\beta_1, \\dots, \\beta_K)$ 和对数权重 $\\mathbf{g} = (g_1, \\dots, g_K)$。\n\n对每个测试用例，算法实现将遵循以下步骤：\n1.  给定 $h$、$\\boldsymbol{\\beta}$ 和 $\\mathbf{g}$，确定温度数量 $K$。对于测试用例 4，首先计算配分函数 $Z(\\beta_k)$ 以确定 $g_k = -\\log(Z(\\beta_k))$ 的值。\n2.  对所有 $k=1, \\dots, K$，计算配分函数值的数组，$Z(\\beta_k) = 2 + e^{-\\beta_k h}$。\n3.  计算表达式 $R$ 分母中的各项：\n    - ST 归一化项：$\\sum_{j=1}^K Z(\\beta_j) e^{g_j}$。\n    - PT 混合项：$\\sum_{k=1}^K e^{-\\beta_k h}$。\n4.  计算表达式 $R$ 分子中的项：$K \\cdot Z(\\beta_1) \\cdot e^{g_1} \\cdot e^{-\\beta_1 h}$。\n5.  计算最终比率 $R$。\n\n此过程将应用于四个指定的测试用例中的每一个，以生成最终的结果列表。", "answer": "```python\nimport numpy as np\n\ndef calculate_ratio(h, betas, gs):\n    \"\"\"\n    Computes the degradation ratio R for a given set of parameters.\n\n    Args:\n        h (float): The energy barrier height.\n        betas (list or np.ndarray): The inverse temperature ladder.\n        gs (list or np.ndarray): The log-weights for ST.\n\n    Returns:\n        float: The degradation ratio R.\n    \"\"\"\n    betas = np.array(betas, dtype=float)\n    gs = np.array(gs, dtype=float)\n    K = len(betas)\n\n    # --- Calculation for M_PT ---\n    # The term e^(-beta_k * h) appears in both PT and ST calculations.\n    exp_beta_h = np.exp(-betas * h)\n    \n    # PT mixing probability is the average transition probability over the ladder.\n    m_pt_sum_term = np.sum(exp_beta_h)\n    m_pt = (1.0 / K) * m_pt_sum_term\n\n    # --- Calculation for M_ST ---\n    # The partition function Z(beta) = 2 + e^(-beta * h).\n    z_vals = 2.0 + exp_beta_h\n    \n    # Stationary probability pi_1^ST at the target temperature beta_1.\n    st_normalization_term = np.sum(z_vals * np.exp(gs))\n    \n    # Handle the case where the normalization term might be zero, although\n    # it is positive definite for finite z_vals and gs.\n    if st_normalization_term == 0.0:\n        pi_1_st = 0.0\n    else:\n        pi_1_st_numerator = z_vals[0] * np.exp(gs[0])\n        pi_1_st = pi_1_st_numerator / st_normalization_term\n\n    # ST mixing probability at the target temperature.\n    m_st = pi_1_st * exp_beta_h[0]\n\n    # --- Degradation Ratio R ---\n    # The ratio R = M_ST / M_PT.\n    # Handle the division-by-zero case, though unlikely with given problem constraints.\n    # If m_pt is 0, exp_beta_h are all 0, so m_st is also 0. R -> 0/0.\n    # In this limit, R can be shown to be K * pi_1_st, but here we can just return 0.\n    if m_pt == 0.0:\n        return 0.0\n    \n    return m_st / m_pt\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Test case 1 (general case with inaccurate weights favoring hot temperatures by default): \n    # h = 6.0, (beta_1,beta_2,beta_3) = (1.0,0.5,0.2), (g_1,g_2,g_3) = (0.0,0.0,0.0).\n    tc1 = (6.0, [1.0, 0.5, 0.2], [0.0, 0.0, 0.0])\n\n    # Test case 2 (more severely inaccurate g_k skewing towards hot temperatures): \n    # h = 6.0, (beta_1,beta_2,beta_3) = (1.0,0.5,0.2), (g_1,g_2,g_3) = (0.0,1.5,2.0).\n    tc2 = (6.0, [1.0, 0.5, 0.2], [0.0, 1.5, 2.0])\n\n    # Test case 3 (lower barrier with the same inaccurate weights as test case 1): \n    # h = 3.0, (beta_1,beta_2,beta_3) = (1.0,0.5,0.2), (g_1,g_2,g_3) = (0.0,0.0,0.0).\n    tc3 = (3.0, [1.0, 0.5, 0.2], [0.0, 0.0, 0.0])\n\n    # Test case 4 (control case with perfect weights in ST): \n    # h = 6.0, (beta_1,beta_2,beta_3) = (1.0,0.5,0.2), and g_k = -log Z(beta_k) for k=1,2,3.\n    h4 = 6.0\n    betas4 = np.array([1.0, 0.5, 0.2])\n    z_vals4 = 2.0 + np.exp(-betas4 * h4)\n    gs4 = -np.log(z_vals4)\n    tc4 = (h4, betas4.tolist(), gs4.tolist())\n    \n    test_cases = [tc1, tc2, tc3, tc4]\n    \n    results = []\n    for h_val, betas_val, gs_val in test_cases:\n        ratio = calculate_ratio(h_val, betas_val, gs_val)\n        results.append(ratio)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3326582"}, {"introduction": "从理论走向实践，一个关键问题随之而来：我们如何调整并行退火以达到最高效率？本问题解决了交换尝试频率的优化问题，这是一个关键参数，它平衡了交换带来的去相关增益与其计算开销。通过推导并实现一个最小化成本归一化积分自相关时间的解决方案，您将为在MCMC模拟中做出有原则、数据驱动的决策建立一个框架[@problem_id:3326598]。", "problem": "您的任务是在马尔可夫链蒙特卡洛 (MCMC) 领域中，为平行退火 (PT) 的交换尝试频率推导并实现一个优化。考虑一个 PT 算法，其温度阶梯包含逆温度 $\\beta = 1$，在该温度下测量一个感兴趣的观测量。$\\beta = 1$ 处的动力学建模如下。\n\n假设与建模基元：\n- 在 $\\beta = 1$ 处的副本内更新是一个可逆马尔可夫核，其平稳分布对应于 $\\beta = 1$，并具有一个观测量特定的谱隙 $g_{\\mathrm{w}} \\in (0,1]$。\n- 相邻副本之间的交换尝试以接受概率 $a \\in (0,1]$ 进行。当涉及 $\\beta = 1$ 副本的交换被接受时，它会对观测量产生额外的去相关作用，该作用通过一个有效因子 $\\kappa \\in [0,1]$ 来建模，这个因子概括了相邻阶梯连通性对该观测量的影响。交换步骤被认为是相对于联合 PT 目标分布可逆的。\n- 在每个离散步骤中，以频率 $f \\in [0,1]$ (决策变量) 进行一次交换尝试；否则，在 $\\beta = 1$ 处进行一次副本内更新。这产生了一个混合核 $P_f = (1-f) K_{\\mathrm{w}} + f K_{\\mathrm{s}}$，其中 $K_{\\mathrm{w}}$ 是副本内核，$K_{\\mathrm{s}}$ 是交换核。\n- 对于 $\\beta = 1$ 处的观测量，将其滞后-1 相关性近似为1阶自回归 (AR($1$))，系数为 $r(f) = 1 - g_{\\mathrm{eff}}(f)$，其中\n$$\ng_{\\mathrm{eff}}(f) = (1-f)\\, g_{\\mathrm{w}} + f \\, a \\, \\kappa.\n$$\n这对应于对可逆混合使用 Dirichlet 形式的标准凸性，以及对影响观测量的最慢模式进行单模 AR($1$) 简化。\n- 在 AR($1$) 模型下，观测量的积分自相关时间 (IACT) 为\n$$\n\\tau_{\\mathrm{int}}(f) = \\frac{1 + r(f)}{1 - r(f)} = \\frac{2 - g_{\\mathrm{eff}}(f)}{g_{\\mathrm{eff}}(f)} = \\frac{2}{g_{\\mathrm{eff}}(f)} - 1.\n$$\n- 每个离散步骤的计算成本与决策 $f$ 呈线性关系，成本为\n$$\nc(f) = (1-f)\\, c_{\\mathrm{w}} + f \\, c_{\\mathrm{s}},\n$$\n其中 $c_{\\mathrm{w}} > 0$ 是在 $\\beta = 1$ 处进行一次副本内更新的成本，$c_{\\mathrm{s}} > 0$ 是一次交换尝试的成本。\n\n目标：\n- 对于给定的参数元组 $(g_{\\mathrm{w}}, a, \\kappa, c_{\\mathrm{w}}, c_{\\mathrm{s}})$，选择 $f \\in [0,1]$ 以最小化成本归一化积分自相关时间\n$$\nJ(f) = \\tau_{\\mathrm{int}}(f) \\, c(f) = \\left(\\frac{2}{g_{\\mathrm{eff}}(f)} - 1\\right)\\left((1-f)\\, c_{\\mathrm{w}} + f \\, c_{\\mathrm{s}}\\right).\n$$\n\n任务：\n- 仅从上述建模假设以及可逆马尔可夫链、谱隙和 AR($1$) IACT 的基本定义出发，推导一个基于原理的算法来计算最小化频率 $f^{\\star} \\in [0,1]$。您的推导必须论证目标函数 $J(f)$ 在闭区间 $[0,1]$ 上的结构，包括边界行为和任何可采纳性约束（例如，在评估 $J(f)$ 时确保 $g_{\\mathrm{eff}}(f) > 0$）。\n- 您的程序必须稳健地实现此算法。具体来说：\n  - 通过求解从 $dJ/df = 0$ 导出的一阶最优性条件，计算 $J(f)$ 在 $(0,1)$ 内的所有驻点（如果存在）。\n  - 将区间端点 $f=0$ 和 $f=1$ 包括在候选点中。\n  - 对所有可采纳的候选点（即满足 $g_{\\mathrm{eff}}(f) > 0$ 的点）评估 $J(f)$。选择使 $J(f)$ 最小化的 $f^{\\star}$。如果在数值容差范围内出现平局，则选择较小的 $f$。\n  - 在测试 $g_{\\mathrm{eff}}(f) > 0$ 时使用一个小的正阈值以避免除以零；指定并使用阈值 $\\varepsilon = 10^{-12}$。\n\n测试套件：\n按此确切顺序，对以下参数元组（每个元组以 5元组 $(g_{\\mathrm{w}}, a, \\kappa, c_{\\mathrm{w}}, c_{\\mathrm{s}})$ 的形式给出）运行您的程序：\n- 情况 A (显著改进，交换成本适中): $(0.1, 0.4, 0.8, 1.0, 1.5)$。\n- 情况 B (交换损害混合，交换成本高): $(0.3, 0.5, 0.4, 1.0, 5.0)$。\n- 情况 C (成本相等，交换损害混合): $(0.2, 0.3, 0.5, 2.0, 2.0)$。\n- 情况 D (混合效率相等，成本不等): $(0.25, 0.5, 0.5, 1.5, 4.0)$。\n- 情况 E (改进非常显著，交换成本极高): $(0.05, 0.9, 0.8, 1.0, 200.0)$。\n- 情况 F (交换有益且更便宜): $(0.3, 0.6, 0.6, 2.0, 0.5)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含按顺序排列的测试用例的最优频率，形式为用方括号括起来的逗号分隔列表。每个最优频率必须打印为小数点后恰好有六位的小数。例如，格式必须像\n$$\n[0.123456,0.000000,1.000000]\n$$\n不含空格也无其他文本。\n\n角度或物理单位不适用。所有数值输出必须是按规定格式的无单位浮点值。", "solution": "我们从可逆马尔可夫链和谱隙的基本定义开始。设 $K_{\\mathrm{w}}$ 和 $K_{\\mathrm{s}}$ 是平行退火 (PT) 联合状态空间上的可逆马尔可夫核，两者都相对于 PT 目标分布可逆。对于逆温度 $\\beta = 1$ 处的单观测量动力学，假设最慢模式的标量简化主导了该观测量的弛豫。那么，对于以频率 $f \\in [0,1]$ 作为随机扫描复合步应用的混合核 $P_f = (1-f) K_{\\mathrm{w}} + f K_{\\mathrm{s}}$，其 Dirichlet 形式是各组分 Dirichlet 形式的仿射组合。特别地，对于可逆核和任何固定的观测量子空间，可以获得一个有效谱隙下界，该下界是主导模式的各个谱隙的凸组合。在单模近似下，我们写出\n$$\ng_{\\mathrm{eff}}(f) = (1-f)\\, g_{\\mathrm{w}} + f \\, g_{\\mathrm{s}},\n$$\n其中 $g_{\\mathrm{w}}$ 是在 $\\beta = 1$ 处副本内更新的观测量特定谱隙，$g_{\\mathrm{s}}$ 是交换步骤对该观测量的有效谱隙贡献。由于交换尝试以概率 $a \\in (0,1]$ 被接受，并且当被接受时，会产生一个由因子 $\\kappa \\in [0,1]$ 概括的额外去相关，我们设定\n$$\ng_{\\mathrm{s}} = a \\, \\kappa,\n$$\n这捕捉了交换步骤对特定观测量的期望谱隙贡献。由此得到\n$$\ng_{\\mathrm{eff}}(f) = (1-f)\\, g_{\\mathrm{w}} + f \\, a \\, \\kappa = g_{\\mathrm{w}} + f \\, (a \\kappa - g_{\\mathrm{w}}).\n$$\n定义\n$$\nA := a \\kappa - g_{\\mathrm{w}}.\n$$\n\n对于一个可逆马尔可夫链，如果其给定观测量的慢动力学可以被 1 阶自回归 (AR($1$)) 近似很好地捕捉，则滞后-1 相关性可以通过 $r(f) = 1 - g_{\\mathrm{eff}}(f)$ 与谱隙相关联。积分自相关时间 (IACT) 则为\n$$\n\\tau_{\\mathrm{int}}(f) = \\frac{1 + r(f)}{1 - r(f)} = \\frac{2 - g_{\\mathrm{eff}}(f)}{g_{\\mathrm{eff}}(f)} = \\frac{2}{g_{\\mathrm{eff}}(f)} - 1.\n$$\n我们假设仅当 $g_{\\mathrm{eff}}(f) > 0$ 时才具有可采纳性，否则 IACT 为无穷大，这样的 $f$ 是次优的。\n\n每个离散步骤的计算成本与 $f$ 呈线性关系：\n$$\nc(f) = (1-f)\\, c_{\\mathrm{w}} + f \\, c_{\\mathrm{s}} = c_{\\mathrm{w}} + f \\, (c_{\\mathrm{s}} - c_{\\mathrm{w}}).\n$$\n定义\n$$\nB := c_{\\mathrm{s}} - c_{\\mathrm{w}}.\n$$\n\n要最小化的目标是成本归一化的 IACT：\n$$\nJ(f) = \\left(\\frac{2}{g_{\\mathrm{eff}}(f)} - 1\\right) c(f) = \\left(\\frac{2}{g_{\\mathrm{w}} + A f} - 1\\right) \\left(c_{\\mathrm{w}} + B f\\right),\n$$\n于紧区间 $f \\in [0,1]$ 上，并以 $g_{\\mathrm{eff}}(f) > 0$ 为可采纳性条件。\n\n为分析 $J(f)$，计算当 $g_{\\mathrm{eff}}(f) > 0$ 时的导数：\n$$\n\\frac{dJ}{df} = \\frac{d}{df}\\left(\\frac{2 C}{G} - C\\right) = 2\\left(\\frac{C'}{G} - \\frac{C G'}{G^2}\\right) - C',\n$$\n其中 $G := g_{\\mathrm{w}} + A f$, $C := c_{\\mathrm{w}} + B f$, $G' = A$, 且 $C' = B$。因此，\n$$\n\\frac{dJ}{df} = \\frac{2(B G - C A)}{G^2} - B.\n$$\n等价地，使用公分母 $G^2$，\n$$\n\\frac{dJ}{df} = \\frac{N(f)}{G^2}, \\quad \\text{其中}\n$$\n$$\nN(f) = 2(B G - C A) - B G^2.\n$$\n代入 $G = g_{\\mathrm{w}} + A f$ 和 $C = c_{\\mathrm{w}} + B f$，我们得到分子的一个显式二次多项式：\n$$\nN(f) = - B A^2 f^2 - 2 B g_{\\mathrm{w}} A f + \\left(2 B g_{\\mathrm{w}} - 2 A c_{\\mathrm{w}} - B g_{\\mathrm{w}}^2\\right).\n$$\n因此，$(0,1)$ 内的驻点是 $N(f) = 0$ 在 $(0,1)$ 内且满足 $G > 0$ (可采纳性) 的实根。特殊的退化情况如下：\n- 如果 $A = 0$，则 $g_{\\mathrm{eff}}(f) \\equiv g_{\\mathrm{w}}$，且 $J(f)$ 是 $f$ 的线性函数，因为 $C(f)$ 是线性的；最优值在边界处取得：如果 $B \\ge 0$，则 $f^{\\star} = 0$；如果 $B < 0$，则 $f^{\\star} = 1$。\n- 如果 $B = 0$，则 $c(f) \\equiv c_{\\mathrm{w}}$，且 $J(f)$ 是 $f$ 的单调函数，其导数为\n$$\n\\frac{dJ}{df} = - \\frac{2 c_{\\mathrm{w}} A}{G^2},\n$$\n其符号恒定；最优值在边界处取得：如果 $A > 0$，则 $f^{\\star} = 1$；如果 $A \\le 0$，则 $f^{\\star} = 0$。\n- 否则，求解 $N(f) = 0$（一个二次方程，或者当二次项系数为零时为线性方程）以获得内部候选点，筛选出满足 $G > 0$ 的可采纳点，并在所有候选点以及 $f = 0$ 和 $f = 1$ 处评估 $J(f)$。选择使 $J(f)$ 最小的 $f$；若出现平局，则选择较小的 $f$。\n\n定性形状分析：\n- 当 $B > 0$ 时，$N(f)$ 的首项系数为 $- B A^2 \\le 0$。因此 $N(f)$ 是一个凹二次函数，而 $\\frac{dJ}{df}$ (即 $N(f)$ 除以正数 $G^2$) 最多改变两次符号，在根之间导数为正，在根之外为负。因此，任何内部驻点都是一个局部最大值。所以，最小值出现在边界 $f = 0$ 或 $f = 1$ 处。\n- 当 $B < 0$ 时，$N(f)$ 的首项系数为 $- B A^2 \\ge 0$。在这种情况下，内部驻点可以是一个局部最小值；然而，紧区间上的全局最小值是在边界和任何可采纳的内部驻点中取得的。\n\n算法规定：\n- 对于每个元组 $(g_{\\mathrm{w}}, a, \\kappa, c_{\\mathrm{w}}, c_{\\mathrm{s}})$，计算 $A = a \\kappa - g_{\\mathrm{w}}$ 和 $B = c_{\\mathrm{s}} - c_{\\mathrm{w}}$。\n- 定义 $G(f) = g_{\\mathrm{w}} + A f$ 和 $J(f) = \\left(\\frac{2}{G(f)} - 1\\right)\\left(c_{\\mathrm{w}} + B f\\right)$。\n- 用边界点 $\\{0, 1\\}$ 初始化候选集。\n- 如果 $|A|$ 和 $|B|$ 不都低于一个小阈值，则构建 $N(f)$ 的系数：\n$$\nn_2 = - B A^2, \\quad n_1 = - 2 B g_{\\mathrm{w}} A, \\quad n_0 = 2 B g_{\\mathrm{w}} - 2 A c_{\\mathrm{w}} - B g_{\\mathrm{w}}^2.\n$$\n求解 $n_2 f^2 + n_1 f + n_0 = 0$：\n  - 如果 $|n_2|  \\varepsilon$ 且 $|n_1| \\ge \\varepsilon$，求解线性根 $f = - n_0 / n_1$。\n  - 如果 $|n_2| \\ge \\varepsilon$，计算判别式 $D = n_1^2 - 4 n_2 n_0$；如果 $D \\ge 0$，添加实根 $f = \\frac{- n_1 \\pm \\sqrt{D}}{2 n_2}$。\n筛选出在 $[0,1]$ 内且满足 $G(f) > \\varepsilon$ 的候选点。\n- 对所有可采纳的候选点评估 $J(f)$，并选择使 $J(f)$ 最小的 $f^{\\star}$，通过选择较小的 $f$ 来打破平局。\n\n将此应用于指定的测试套件会产生以下定性结果：\n- 情况 A：显著改进且交换成本适中 $\\Rightarrow f^{\\star} = 1$。\n- 情况 B：交换损害混合且成本高昂 $\\Rightarrow f^{\\star} = 0$。\n- 情况 C：成本相等但交换损害混合 $\\Rightarrow f^{\\star} = 0$。\n- 情况 D：混合效率相等，成本不等 $\\Rightarrow f^{\\star} = 0$ (选择更便宜的步骤)。\n- 情况 E：改进非常显著但交换成本极高 $\\Rightarrow $ 边界比较倾向于 $f^{\\star} = 0$。\n- 情况 F：交换有益且更便宜 $\\Rightarrow f^{\\star} = 1$。\n\n该程序实现了上述算法，使用阈值 $\\varepsilon = 10^{-12}$ 稳健地处理退化情况，并按要求将列表 $[f^{\\star}_{A}, f^{\\star}_{B}, f^{\\star}_{C}, f^{\\star}_{D}, f^{\\star}_{E}, f^{\\star}_{F}]$ 打印出来，其中每个条目都格式化为小数点后六位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef objective_J(f, gw, a, kappa, cw, cs, eps=1e-12):\n    \"\"\"\n    Compute J(f) = tau_int(f) * cost(f) with tau_int(f) = 2/g_eff(f) - 1,\n    g_eff(f) = (1 - f) * gw + f * a * kappa, and cost(f) = (1 - f) * cw + f * cs.\n    Returns np.inf if g_eff(f) <= eps (inadmissible).\n    \"\"\"\n    g_eff = gw + (a * kappa - gw) * f\n    if g_eff <= eps:\n        return np.inf\n    tau = 2.0 / g_eff - 1.0\n    cost = (1.0 - f) * cw + f * cs\n    return tau * cost\n\ndef stationary_points(gw, a, kappa, cw, cs, eps=1e-12):\n    \"\"\"\n    Solve for interior stationary points of J(f) in (0,1) by setting dJ/df = 0.\n    Based on the numerator quadratic N(f) = 0, where:\n        N(f) = -B A^2 f^2 - 2 B gw A f + (2 B gw - 2 A cw - B gw^2)\n    Returns a list of candidate roots (not filtered for domain or admissibility).\n    \"\"\"\n    A = a * kappa - gw\n    B = cs - cw\n\n    # If both A and B are near zero, derivative is approximately zero everywhere: no interior candidates.\n    if abs(A) < eps and abs(B) < eps:\n        return []\n\n    # Coefficients of N(f) = n2 f^2 + n1 f + n0 = 0\n    n2 = -B * (A ** 2)\n    n1 = -2.0 * B * gw * A\n    n0 = 2.0 * B * gw - 2.0 * A * cw - B * (gw ** 2)\n\n    candidates = []\n    if abs(n2) < eps:\n        # Linear case: n1 f + n0 = 0\n        if abs(n1) >= eps:\n            f_lin = -n0 / n1\n            candidates.append(f_lin)\n        # If both n2 and n1 ~ 0, then N(f) ~ n0, so derivative sign is constant: no interior stationary point.\n    else:\n        # Quadratic case\n        D = n1 * n1 - 4.0 * n2 * n0\n        # Numerical safety: clamp tiny negative due to rounding\n        if D >= -1e-18:\n            D = max(D, 0.0)\n            sqrtD = np.sqrt(D)\n            denom = 2.0 * n2\n            f1 = (-n1 + sqrtD) / denom\n            f2 = (-n1 - sqrtD) / denom\n            candidates.extend([f1, f2])\n\n    return candidates\n\ndef optimal_frequency(gw, a, kappa, cw, cs, eps=1e-12):\n    \"\"\"\n    Compute the optimal swap frequency f* in [0,1] minimizing J(f).\n    Consider boundaries and any admissible interior stationary points.\n    Tie-break by choosing the smaller f.\n    \"\"\"\n    A = a * kappa - gw\n\n    # Collect candidate points: boundaries\n    cands = [0.0, 1.0]\n\n    # Add stationary points\n    for f in stationary_points(gw, a, kappa, cw, cs, eps=eps):\n        if np.isfinite(f):\n            cands.append(f)\n\n    # Filter candidates to [0,1] and admissible g_eff > eps\n    def admissible(f):\n        if f < 0.0 - 1e-12 or f > 1.0 + 1e-12:\n            return False\n        # Project tiny out-of-range numerical noise\n        f_proj = min(max(f, 0.0), 1.0)\n        g_eff = gw + (a * kappa - gw) * f_proj\n        return g_eff > eps\n\n    filtered = []\n    for f in cands:\n        # Project minor numerical drift into [0,1]\n        f_proj = min(max(f, 0.0), 1.0)\n        if admissible(f_proj):\n            filtered.append(f_proj)\n\n    # Deduplicate with tolerance\n    unique = []\n    for f in filtered:\n        if not any(abs(f - u) < 1e-10 for u in unique):\n            unique.append(f)\n\n    # Evaluate objective and pick minimum; tie-break by smaller f\n    best_f = None\n    best_J = np.inf\n    for f in unique:\n        J = objective_J(f, gw, a, kappa, cw, cs, eps=eps)\n        if (J < best_J - 1e-14) or (abs(J - best_J) <= 1e-14 and (best_f is None or f < best_f)):\n            best_J = J\n            best_f = f\n\n    # Safety fallback (should not trigger): if no admissible candidate, choose f=0.0\n    if best_f is None:\n        best_f = 0.0\n\n    # Clip to [0,1]\n    best_f = min(max(best_f, 0.0), 1.0)\n    return best_f\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each is a tuple: (g_w, a, kappa, c_w, c_s)\n    test_cases = [\n        (0.1, 0.4, 0.8, 1.0, 1.5),    # Case A\n        (0.3, 0.5, 0.4, 1.0, 5.0),    # Case B\n        (0.2, 0.3, 0.5, 2.0, 2.0),    # Case C\n        (0.25, 0.5, 0.5, 1.5, 4.0),   # Case D\n        (0.05, 0.9, 0.8, 1.0, 200.0), # Case E\n        (0.3, 0.6, 0.6, 2.0, 0.5),    # Case F\n    ]\n\n    results = []\n    for gw, a, kappa, cw, cs in test_cases:\n        f_star = optimal_frequency(gw, a, kappa, cw, cs, eps=1e-12)\n        results.append(f_star)\n\n    # Final print statement in the exact required format, six decimals, no spaces.\n    print(\"[\" + \",\".join(f\"{r:.6f}\" for r in results) + \"]\")\n\nsolve()\n```", "id": "3326598"}]}