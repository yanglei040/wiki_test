{"hands_on_practices": [{"introduction": "在模拟随机过程之前，理解其基本解析性质至关重要。本练习将引导您推导金融工程中的基石模型——几何布朗运动（GBM）的精确解，并计算其关键矩 [@problem_id:3321531]。掌握这些推导不仅能为您奠定坚实的理论基础，也为验证数值模拟结果提供了基准。", "problem": "考虑单一风险资产，其价格过程 $\\{S_{t}\\}_{t \\geq 0}$ 在一个带滤概率空间 $(\\Omega,\\mathcal{F},\\{\\mathcal{F}_{t}\\}_{t \\geq 0},\\mathbb{P})$ 上由以下随机微分方程 (SDE) 建模：\n$$\n\\mathrm{d}S_{t}=\\mu S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{P}}, \\quad S_{0}0,\n$$\n其中 $\\mu \\in \\mathbb{R}$ 和 $\\sigma0$ 为常数，$\\{W_{t}^{\\mathbb{P}}\\}_{t \\geq 0}$ 是在物理测度 $\\mathbb{P}$ 下的标准布朗运动。假设存在一个具有确定性短期利率 $r \\in \\mathbb{R}$ 的货币市场账户，并且无套利条件成立，因此存在一个等价鞅测度（风险中性测度）$\\mathbb{Q}$，在该测度下，折现后的资产价格是一个鞅。在 $\\mathbb{Q}$ 下，资产动态满足：\n$$\n\\mathrm{d}S_{t}=r S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{Q}},\n$$\n其中 $\\{W_{t}^{\\mathbb{Q}}\\}_{t \\geq 0}$ 是在 $\\mathbb{Q}$ 下的标准布朗运动。\n\n仅使用适用于常系数扩散过程的基本随机微积分工具和测度变换原理，完成以下任务：\n\n- 推导在固定时间 $T0$ 时 $S_{T}$ 的精确路径解，用 $S_{0}$、模型参数和驱动布朗运动表示。\n- 计算在物理测度 $\\mathbb{P}$ 下的期望 $\\mathbb{E}_{\\mathbb{P}}[S_{T}]$ 和方差 $\\mathrm{Var}_{\\mathbb{P}}(S_{T})$。\n- 计算在风险中性测度 $\\mathbb{Q}$ 下的期望 $\\mathbb{E}_{\\mathbb{Q}}[S_{T}]$ 和方差 $\\mathrm{Var}_{\\mathbb{Q}}(S_{T})$。\n\n将您的最终答案表示为一个单行矩阵，按顺序包含 $\\mathbb{E}_{\\mathbb{P}}[S_{T}]$, $\\mathrm{Var}_{\\mathbb{P}}(S_{T})$, $\\mathbb{E}_{\\mathbb{Q}}[S_{T}]$ 和 $\\mathrm{Var}_{\\mathbb{Q}}(S_{T})$。无需进行数值四舍五入；请提供闭式解析表达式。无需物理单位。", "solution": "用户请求解答一个量化金融问题，该问题涉及推导几何布朗运动随机微分方程的解，并计算其在物理测度和风险中性测度下的前两阶矩。\n\n### 步骤 1：提取已知条件\n-   资产价格 $S_t$ 在物理测度 $\\mathbb{P}$ 下的随机微分方程 (SDE)：$\\mathrm{d}S_{t}=\\mu S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{P}}$。\n-   初始资产价格：$S_{0}0$。\n-   $\\mathbb{P}$ 下的漂移系数：$\\mu \\in \\mathbb{R}$ (常数)。\n-   波动率系数：$\\sigma0$ (常数)。\n-   $\\mathbb{P}$ 下的驱动过程：$\\{W_{t}^{\\mathbb{P}}\\}_{t \\geq 0}$ 是一个标准布朗运动。\n-   确定性短期利率：$r \\in \\mathbb{R}$。\n-   资产价格 $S_t$ 在风险中性测度 $\\mathbb{Q}$ 下的随机微分方程 (SDE)：$\\mathrm{d}S_{t}=r S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{Q}}$。\n-   $\\mathbb{Q}$ 下的驱动过程：$\\{W_{t}^{\\mathbb{Q}}\\}_{t \\geq 0}$ 是一个标准布朗运动。\n-   目标：推导 $S_T$ 的路径解并计算 $\\mathbb{E}_{\\mathbb{P}}[S_{T}]$, $\\mathrm{Var}_{\\mathbb{P}}(S_{T})$, $\\mathbb{E}_{\\mathbb{Q}}[S_{T}]$, 和 $\\mathrm{Var}_{\\mathbb{Q}}(S_{T})$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题描述了 Black-Scholes-Merton 模型，这是金融数学中一个基本且完善的框架。Itô 微积分、几何布朗运动和测度变换技术的使用都是标准概念。该问题在科学上是合理的。\n-   **适定性**：该问题完整地指定了所有必要的参数 ($\\mu, \\sigma, r, S_0$) 和初始条件。目标明确。该 SDE 具有唯一的稳定解。问题是适定的。\n-   **客观性**：该问题以精确的数学术语陈述，没有任何主观性或模糊性。\n\n### 步骤 3：结论与行动\n该问题是有效的。将提供完整解答。\n\n### 路径解的推导\n在物理测度 $\\mathbb{P}$ 下，资产价格 $S_t$ 的 SDE 是一个几何布朗运动：\n$$\n\\mathrm{d}S_{t}=\\mu S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{P}}\n$$\n为了找到 $S_t$ 的显式解，我们对函数 $f(S_t) = \\ln(S_t)$ 应用 Itô 引理。$f(S_t)$ 的偏导数是：\n$$\n\\frac{\\partial f}{\\partial t} = 0, \\quad \\frac{\\partial f}{\\partial S_t} = \\frac{1}{S_t}, \\quad \\frac{\\partial^2 f}{\\partial S_t^2} = -\\frac{1}{S_t^2}\n$$\n根据 Itô 引理，$X_t = f(S_t) = \\ln(S_t)$ 的微分由下式给出：\n$$\n\\mathrm{d}X_t = \\left( \\frac{\\partial f}{\\partial t} + \\mu S_t \\frac{\\partial f}{\\partial S_t} + \\frac{1}{2} (\\sigma S_t)^2 \\frac{\\partial^2 f}{\\partial S_t^2} \\right) \\mathrm{d}t + \\sigma S_t \\frac{\\partial f}{\\partial S_t} \\mathrm{d}W_t^{\\mathbb{P}}\n$$\n代入偏导数，我们得到：\n$$\n\\mathrm{d}(\\ln S_t) = \\left( 0 + \\mu S_t \\left(\\frac{1}{S_t}\\right) + \\frac{1}{2} \\sigma^2 S_t^2 \\left(-\\frac{1}{S_t^2}\\right) \\right) \\mathrm{d}t + \\sigma S_t \\left(\\frac{1}{S_t}\\right) \\mathrm{d}W_t^{\\mathbb{P}}\n$$\n$$\n\\mathrm{d}(\\ln S_t) = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right) \\mathrm{d}t + \\sigma \\mathrm{d}W_t^{\\mathbb{P}}\n$$\n这是一个关于 $\\ln(S_t)$ 的算术布朗运动。我们对此 SDE 从 $t=0$ 到 $t=T$ 进行积分：\n$$\n\\int_0^T \\mathrm{d}(\\ln S_t) = \\int_0^T \\left(\\mu - \\frac{1}{2}\\sigma^2\\right) \\mathrm{d}t + \\int_0^T \\sigma \\mathrm{d}W_t^{\\mathbb{P}}\n$$\n$$\n\\ln(S_T) - \\ln(S_0) = \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T + \\sigma (W_T^{\\mathbb{P}} - W_0^{\\mathbb{P}})\n$$\n由于对于标准布朗运动有 $W_0^{\\mathbb{P}} = 0$，我们得到：\n$$\n\\ln(S_T) = \\ln(S_0) + \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T^{\\mathbb{P}}\n$$\n对两边取指数，得到 $S_T$ 的路径解：\n$$\nS_T = S_0 \\exp\\left(\\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T^{\\mathbb{P}}\\right)\n$$\n\n### 物理测度 $\\mathbb{P}$ 下的矩\n在测度 $\\mathbb{P}$ 下，随机变量 $W_T^{\\mathbb{P}}$ 服从均值为 $0$、方差为 $T$ 的正态分布，即 $W_T^{\\mathbb{P}} \\sim N(0, T)$。因此，$\\ln(S_T)$ 是一个正态分布的随机变量：\n$$\n\\ln(S_T) \\sim N\\left(\\ln(S_0) + \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T, \\sigma^2 T\\right)\n$$\n这意味着 $S_T$ 服从对数正态分布。对于一个对数正态分布的随机变量 $Y = \\exp(Z)$，其中 $Z \\sim N(m, s^2)$，其前两阶矩由以下公式给出：\n$$\n\\mathbb{E}[Y] = \\exp\\left(m + \\frac{1}{2}s^2\\right)\n$$\n$$\n\\mathrm{Var}(Y) = (\\exp(s^2)-1)\\exp(2m+s^2) = (\\mathbb{E}[Y])^2(\\exp(s^2)-1)\n$$\n对于 $\\mathbb{P}$ 下的 $S_T$，我们确定 $m = \\ln(S_0) + (\\mu - \\frac{1}{2}\\sigma^2)T$ 和 $s^2 = \\sigma^2 T$。\n期望 $\\mathbb{E}_{\\mathbb{P}}[S_T]$ 是：\n$$\n\\mathbb{E}_{\\mathbb{P}}[S_T] = \\exp\\left( \\ln(S_0) + \\left(\\mu - \\frac{1}{2}\\sigma^2\\right)T + \\frac{1}{2}\\sigma^2 T \\right) = \\exp(\\ln(S_0) + \\mu T) = S_0 \\exp(\\mu T)\n$$\n方差 $\\mathrm{Var}_{\\mathbb{P}}(S_T)$ 是：\n$$\n\\mathrm{Var}_{\\mathbb{P}}(S_T) = (\\mathbb{E}_{\\mathbb{P}}[S_T])^2 (\\exp(s^2)-1) = (S_0 \\exp(\\mu T))^2 (\\exp(\\sigma^2 T) - 1) = S_0^2 \\exp(2\\mu T) (\\exp(\\sigma^2 T) - 1)\n$$\n\n### 风险中性测度 $\\mathbb{Q}$ 下的矩\n在风险中性测度 $\\mathbb{Q}$ 下 $S_t$ 的 SDE 如下：\n$$\n\\mathrm{d}S_{t}=r S_{t}\\,\\mathrm{d}t+\\sigma S_{t}\\,\\mathrm{d}W_{t}^{\\mathbb{Q}}\n$$\n该方程与 $\\mathbb{P}$ 下的 SDE 形式相同，只是漂移参数 $\\mu$ 被无风险利率 $r$ 替代。过程 $\\{W_{t}^{\\mathbb{Q}}\\}_{t \\geq 0}$ 是在 $\\mathbb{Q}$ 下的标准布朗运动，因此在 $\\mathbb{Q}$ 下 $W_T^{\\mathbb{Q}} \\sim N(0, T)$。\n通过直接类比，用 $\\mathbb{Q}$-布朗运动表示的 $S_T$ 的路径解是：\n$$\nS_T = S_0 \\exp\\left(\\left(r - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T^{\\mathbb{Q}}\\right)\n$$\n并且在 $\\mathbb{Q}$ 下 $\\ln(S_T)$ 的分布是：\n$$\n\\ln(S_T) \\sim N\\left(\\ln(S_0) + \\left(r - \\frac{1}{2}\\sigma^2\\right)T, \\sigma^2 T\\right)\n$$\n为了计算 $\\mathbb{Q}$ 下的矩，我们可以使用与之前相同的公式，只需将 $\\mu$ 替换为 $r$。\n期望 $\\mathbb{E}_{\\mathbb{Q}}[S_T]$ 是：\n$$\n\\mathbb{E}_{\\mathbb{Q}}[S_T] = S_0 \\exp(r T)\n$$\n方差 $\\mathrm{Var}_{\\mathbb{Q}}(S_T)$ 是：\n$$\n\\mathrm{Var}_{\\mathbb{Q}}(S_T) = (\\mathbb{E}_{\\mathbb{Q}}[S_T])^2 (\\exp(\\sigma^2 T)-1) = (S_0 \\exp(r T))^2 (\\exp(\\sigma^2 T) - 1) = S_0^2 \\exp(2r T) (\\exp(\\sigma^2 T) - 1)\n$$\n这四个量构成了最终答案。", "answer": "$$\n\\boxed{\\begin{pmatrix} S_0 \\exp(\\mu T)  S_0^2 \\exp(2\\mu T) (\\exp(\\sigma^2 T) - 1)  S_0 \\exp(r T)  S_0^2 \\exp(2r T) (\\exp(\\sigma^2 T) - 1) \\end{pmatrix}}\n$$", "id": "3321531"}, {"introduction": "蒙特卡洛方法的一个核心挑战是计算效率，而高方差往往是其主要瓶颈。本练习将介绍控制变量这一强大的方差缩减技术 [@problem_id:3321573]。通过从第一性原理出发推导最优控制系数，您将学会如何利用一个具有解析解的简单问题（例如普通欧式期权）来显著提高对更复杂衍生品价格估计的精度。", "problem": "考虑一个风险中性测度下的金融市场，其中标的资产价格过程 $\\{S_{t}\\}_{t \\in [0,T]}$ 服从几何布朗运动，其动态为 $dS_{t} = r S_{t}\\,dt + \\sigma S_{t}\\,dW_{t}$，其中 $S_{0} \\gt 0$、无风险利率 $r \\ge 0$、波动率 $\\sigma \\gt 0$ 和到期日 $T \\gt 0$ 均为常数，$\\{W_{t}\\}$ 是一个标准布朗运动。设 $K \\gt 0$ 为一个固定的行权价。对于一个给定的、至多为多项式增长的Borel可测收益函数 $g:\\mathbb{R}_{+}\\to\\mathbb{R}_{+}$，定义折现目标收益为 $Y := \\exp(-rT)\\,g(S_{T})$。要求您通过对 $\\{S_{T}\\}$ 进行蒙特卡洛模拟，来为价值为 $V := \\mathbb{E}[Y]$ 的衍生品定价。\n\n为使用控制变量法来缩减方差，您决定使用折现欧式看涨期权收益 $X := \\exp(-rT)\\,(S_{T}-K)_{+}$ 作为控制变量，其风险中性期望可以通过Black–Scholes公式以闭式解形式得知。将此已知量表示为 $C_{\\mathrm{BS}}(S_{0},K,r,\\sigma,T)$。\n\n仅从无偏蒙特卡洛估计、方差、协方差和相关性的定义，以及上述几何布朗运动模型和风险中性定价原理出发（不得假设任何额外的专用方差缩减公式），完成以下任务：\n\n- 构建一个使用 $X$ 和 $C_{\\mathrm{BS}}(S_{0},K,r,\\sigma,T)$ 的 $V$ 的无偏控制变量估计量。\n- 推导使单样本控制变量的方差最小化的系数，该系数用 $Y$ 和 $X$ 的协方差和方差表示。\n- 将控制变量的最小化方差与 $Y$ 的方差之比，纯粹用 $Y$ 和 $X$ 之间的相关性来表示。\n\n您的最终答案必须是单个闭式解析表达式或单行闭式解析表达式。不需要数值近似，最终答案中也不需要单位。如果提供多个表达式，请将它们表示为单行矩阵。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于金融数学和随机微积分的既定原理（Black-Scholes模型、风险中性定价），是蒙特卡洛方法领域中一个定义明确的客观问题。该问题提供了一个自洽且一致的设定，允许按要求从第一性原理进行严格的数学推导。\n\n任务是在蒙特卡洛定价的背景下，执行与控制变量方差缩减技术相关的三项推导。设 $Y := \\exp(-rT)\\,g(S_{T})$ 为折现目标收益， $X := \\exp(-rT)\\,(S_{T}-K)_{+}$ 为折现控制收益。我们已知它们的期望为 $V = \\mathbb{E}[Y]$（待估计的量）和 $\\mathbb{E}[X] = C_{\\mathrm{BS}}(S_{0},K,r,\\sigma,T)$（已知值）。\n\n首先，我们构建控制变量估计量。控制变量法的核心思想是利用关于 $X$ 的已知信息为 $V$ 构建一个新的估计量。我们定义一个新的随机变量，即控制变量，记为 $Y_c(\\beta)$，作为 $Y$ 和中心化控制变量 $(X - \\mathbb{E}[X])$ 的线性组合。对于任意实数系数 $\\beta$，其形式为：\n$$\nY_c(\\beta) = Y - \\beta (X - \\mathbb{E}[X])\n$$\n使用问题中提供的记法，其中 $\\mathbb{E}[X]$ 已知为 $C_{\\mathrm{BS}}$，构建的变量为：\n$$\nY_c(\\beta) = Y - \\beta (X - C_{\\mathrm{BS}})\n$$\n要成为 $V = \\mathbb{E}[Y]$ 的有效估计量，这个新的随机变量必须是无偏的，即其期望必须为 $V$。我们利用期望算子的线性性来验证这一点：\n$$\n\\mathbb{E}[Y_c(\\beta)] = \\mathbb{E}[Y - \\beta (X - C_{\\mathrm{BS}})] = \\mathbb{E}[Y] - \\beta \\mathbb{E}[X - C_{\\mathrm{BS}}]\n$$\n$$\n\\mathbb{E}[Y_c(\\beta)] = \\mathbb{E}[Y] - \\beta (\\mathbb{E}[X] - \\mathbb{E}[C_{\\mathrm{BS}}])\n$$\n由于 $C_{\\mathrm{BS}}$ 是一个表示 $X$ 真实期望的常数，我们有 $\\mathbb{E}[X] = C_{\\mathrm{BS}}$ 和 $\\mathbb{E}[C_{\\mathrm{BS}}] = C_{\\mathrm{BS}}$。代入这些值可得：\n$$\n\\mathbb{E}[Y_c(\\beta)] = V - \\beta (C_{\\mathrm{BS}} - C_{\\mathrm{BS}}) = V - 0 = V\n$$\n这证实了对于常数系数 $\\beta$ 的任何选择，$Y_c(\\beta)$ 都是 $V$ 的无偏估计量。至此估计量的构建完成。然后，通过对 $N$ 个独立的 $Y_c(\\beta)$ 实现取样本均值，可以构成 $V$ 的蒙特卡洛估计。\n\n其次，我们推导使估计量方差最小化的系数 $\\beta^*$。蒙特卡洛估计量的效率由其方差决定。我们寻求选择 $\\beta$ 来最小化 $\\mathrm{Var}(Y_c(\\beta))$。\n控制变量的方差为：\n$$\n\\mathrm{Var}(Y_c(\\beta)) = \\mathrm{Var}(Y - \\beta (X - C_{\\mathrm{BS}}))\n$$\n由于加上或减去一个常数（$-\\beta C_{\\mathrm{BS}}$）不影响方差，这可以简化为：\n$$\n\\mathrm{Var}(Y_c(\\beta)) = \\mathrm{Var}(Y - \\beta X)\n$$\n使用两个随机变量线性组合的方差标准公式 $\\mathrm{Var}(A - B) = \\mathrm{Var}(A) + \\mathrm{Var}(B) - 2\\mathrm{Cov}(A,B)$，我们得到：\n$$\n\\mathrm{Var}(Y_c(\\beta)) = \\mathrm{Var}(Y) + \\mathrm{Var}(\\beta X) - 2\\mathrm{Cov}(Y, \\beta X)\n$$\n对于常数 $c$，使用性质 $\\mathrm{Var}(cZ) = c^2\\mathrm{Var}(Z)$ 和 $\\mathrm{Cov}(Z_1, cZ_2) = c\\mathrm{Cov}(Z_1, Z_2)$：\n$$\n\\mathrm{Var}(Y_c(\\beta)) = \\mathrm{Var}(Y) + \\beta^2 \\mathrm{Var}(X) - 2\\beta \\mathrm{Cov}(Y, X)\n$$\n这个表达式是关于 $\\beta$ 的二次函数。为了找到使该方差最小化的值 $\\beta^*$，我们对其关于 $\\beta$ 求一阶导数并令其为零：\n$$\n\\frac{d}{d\\beta} \\mathrm{Var}(Y_c(\\beta)) = 2\\beta \\mathrm{Var}(X) - 2\\mathrm{Cov}(Y, X)\n$$\n为求最优系数 $\\beta^*$，将导数设为零：\n$$\n2\\beta^* \\mathrm{Var}(X) - 2\\mathrm{Cov}(Y, X) = 0\n$$\n解出 $\\beta^*$，我们得到：\n$$\n\\beta^* = \\frac{\\mathrm{Cov}(Y, X)}{\\mathrm{Var}(X)}\n$$\n二阶导数 $\\frac{d^2}{d\\beta^2}\\mathrm{Var}(Y_c(\\beta)) = 2\\mathrm{Var}(X)$ 是正的，因为 $\\sigma  0$ 意味着 $S_T$ 是一个非退化随机变量，因此收益 $X = \\exp(-rT)(S_T - K)_{+}$ 的方差为正。这证实了 $\\beta^*$ 对应一个最小值。\n\n第三，我们将最小化方差与原始方差之比用 $Y$ 和 $X$ 之间的相关性来表示。最小化方差为 $\\mathrm{Var}(Y_c(\\beta^*))$。我们将 $\\beta^*$ 的表达式代入方差公式中：\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var}(Y) + (\\beta^*)^2 \\mathrm{Var}(X) - 2\\beta^* \\mathrm{Cov}(Y, X)\n$$\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var(Y)} + \\left(\\frac{\\mathrm{Cov}(Y, X)}{\\mathrm{Var}(X)}\\right)^2 \\mathrm{Var}(X) - 2 \\left(\\frac{\\mathrm{Cov}(Y, X)}{\\mathrm{Var}(X)}\\right) \\mathrm{Cov}(Y, X)\n$$\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var}(Y) + \\frac{\\mathrm{Cov}(Y, X)^2}{\\mathrm{Var}(X)} - 2\\frac{\\mathrm{Cov}(Y, X)^2}{\\mathrm{Var}(X)}\n$$\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var}(Y) - \\frac{\\mathrm{Cov}(Y, X)^2}{\\mathrm{Var}(X)}\n$$\n现在，我们使用 $Y$ 和 $X$ 之间的相关系数 $\\rho_{Y,X}$ 的定义：\n$$\n\\rho_{Y,X} = \\frac{\\mathrm{Cov}(Y, X)}{\\sqrt{\\mathrm{Var}(Y)\\mathrm{Var}(X)}}\n$$\n由此，我们可以写出 $\\mathrm{Cov}(Y, X)^2 = \\rho_{Y,X}^2 \\mathrm{Var}(Y) \\mathrm{Var}(X)$。将此式代入最小化方差的表达式中可得：\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var}(Y) - \\frac{\\rho_{Y,X}^2 \\mathrm{Var}(Y) \\mathrm{Var}(X)}{\\mathrm{Var}(X)} = \\mathrm{Var}(Y) - \\rho_{Y,X}^2 \\mathrm{Var}(Y)\n$$\n$$\n\\mathrm{Var}(Y_c(\\beta^*)) = \\mathrm{Var}(Y) (1 - \\rho_{Y,X}^2)\n$$\n所要求的控制变量的最小化方差与原始变量 $Y$ 的方差之比为：\n$$\n\\frac{\\mathrm{Var}(Y_c(\\beta^*))}{\\mathrm{Var}(Y)} = \\frac{\\mathrm{Var}(Y) (1 - \\rho_{Y,X}^2)}{\\mathrm{Var}(Y)} = 1 - \\rho_{Y,X}^2\n$$\n这个结果表明，方差缩减的程度由目标收益和控制变量之间相关性的平方决定。绝对相关性 $|\\rho_{Y,X}|$ 越高，方差缩减的幅度就越大。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nY - \\beta(X - C_{\\mathrm{BS}})  \\frac{\\mathrm{Cov}(Y, X)}{\\mathrm{Var}(X)}  1 - \\rho_{Y,X}^2\n\\end{pmatrix}\n}\n$$", "id": "3321573"}, {"introduction": "除了统计方差，时间离散化带来的系统性偏差是为路径依赖期权定价时的一个关键问题。这个动手实践问题要求您通过编写代码实现蒙特卡洛模拟，并亲手观察亚洲期权和障碍期权中的这种偏差 [@problem_id:3321511]。您将进一步实现理查森外推法——一种消除主要阶离散化误差的强大技术，从而学会在实际应用中诊断和修正模拟偏差。", "problem": "考虑一个单资产模型下的风险中性定价，其中标的价格过程由几何布朗运动（GBM）建模。在风险中性测度下，资产价格过程满足随机微分方程（SDE）$dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$，初始值为 $S_0$，其中 $r$ 是连续复利无风险利率，$\\sigma$ 是波动率，$W_t$ 是标准布朗运动。其精确解满足 $S_{t+\\Delta} = S_t \\exp\\left(\\left(r - \\tfrac{1}{2}\\sigma^2\\right)\\Delta + \\sigma \\sqrt{\\Delta} Z\\right)$，其中 $Z \\sim \\mathcal{N}(0,1)$ 在各个时间步之间是独立的。\n\n一个到期日为 $T$、具有路径依赖支付泛函 $\\Phi$ 的欧式或有债权在时间 $0$ 的定价为 $V = \\mathrm{e}^{-rT} \\mathbb{E}[\\Phi(S_{[0,T]})]$，其中 $\\Phi$ 可能依赖于整个轨迹 $S_{[0,T]}$。在路径依赖支付的时间离散化蒙特卡洛（MC）模拟中，路径在一个网格尺寸为 $h = T/N$ 的离散时间网格上被观测，并使用离散时间近似 $\\Phi_h$。将弱误差（偏差）定义为 $\\mathbb{E}[\\Phi_h] - \\mathbb{E}[\\Phi]$。关于 GBM 下时间离散化泛函的弱收敛，一个经过充分检验的事实是：\n- 对于通过在均匀时间网格上使用矩形法则平均计算的算术平均亚式期权，其价格的弱误差为 $O(h)$，即阶数 $\\alpha = 1$。\n- 对于在均匀网格上进行朴素离散监测的向上敲出障碍期权（即，仅在网格点检查是否穿越障碍，不进行布朗桥修正），其价格的弱误差为 $O(h^{1/2})$，即阶数 $\\alpha = \\tfrac{1}{2}$，这是由于观测时间之间错过的障碍穿越事件的概率缩放特性所致。\n\n如果误差允许展开为 $\\mathbb{E}[\\Phi_h] = \\mathbb{E}[\\Phi] + c h^{\\alpha} + o(h^{\\alpha})$（其中 $c$ 为某个常数），Richardson 外推法可以消除主阶弱误差。给定以加密比率 $r  1$ 计算出的估计值 $P_h$ 和 $P_{h/r}$，能够消除 $h^{\\alpha}$ 项的外推估计量为\n$$\nP_{\\mathrm{RE}} = \\frac{r^{\\alpha} P_{h/r} - P_h}{r^{\\alpha} - 1}.\n$$\n您的任务是：\n- 从 GBM 模型和风险中性估值出发，解释弱阶数 $\\alpha$ 如何影响两种路径依赖支付（算术平均亚式看涨期权和在朴素离散监测下的向上敲出看涨期权）的时间离散化 MC 价格的偏差。\n- 推导适用于弱阶数 $\\alpha$ 的 Richardson 外推公式，并说明如何使用公共随机数来实现它，以确保粗糙和精细网格的估计量以一致的方式共享相同的底层布朗路径增量。\n- 实现一个完整的、可运行的程序，该程序：\n  1. 使用标准正态增量的精确转移，在离散时间点上精确模拟 GBM 路径。\n  2. 通过将粗糙网格的布朗增量构造为连续精细网格增量除以 $\\sqrt{r}$ 后的和，在粗糙和精细网格之间使用公共随机数。\n  3. 通过 MC 对两种网格尺寸 $h$ 和 $h/2$（即加密比率 $r=2$）的每种支付进行定价，并计算针对该支付的正确弱阶数 $\\alpha$ 调整的 Richardson 外推值。\n  4. 使用风险中性折现 $\\mathrm{e}^{-rT}$。\n  5. 按照下文指定的方式生成最终输出。\n\n需要实现的支付：\n- 算术平均亚式看涨期权：$\\Phi_{\\text{Asian}} = \\max\\left(\\frac{1}{N} \\sum_{k=1}^{N} S_{t_k} - K,\\; 0\\right)$，其中 $t_k = k h$。\n- 采用朴素离散监测的向上敲出看涨期权：$\\Phi_{\\text{UO}} = \\mathbf{1}\\{\\max_{k=1,\\dots,N} S_{t_k}  B\\} \\max(S_T - K,\\; 0)$，其中 $B$ 是障碍水平，指示函数仅在离散观测时间检查是否突破障碍。\n\n实现要求：\n- Richardson 外推法使用加密比率 $r = 2$。\n- 通过配对精细级别的增量，以通过按 $\\sqrt{2}$ 缩放的平均值获得粗糙级别的标准正态增量，从而在粗糙和精细网格之间使用公共随机数，确保粗糙增量等于两个连续精细增量在布朗时间上的和。\n- 在每个时间步使用 $S_{t+\\Delta}$ 的精确 GBM 转移，以消除 SDE 离散化误差，从而只有路径泛函的时间离散化对偏差有贡献。\n\n测试套件：\n提供以下三个测试用例，具有固定的蒙特卡洛样本量和种子以保证可复现性。对于每个测试，计算三个数字：粗糙网格价格 $P_h$、精细网格价格 $P_{h/2}$ 和 Richardson 外推价格 $P_{\\mathrm{RE}}$。\n\n- 测试 A（算术平均亚式看涨期权，阶数 $\\alpha = 1$）：\n  - 参数：$S_0 = 100$, $K = 100$, $r = 0.05$, $\\sigma = 0.2$, $T = 1$, $N_{\\text{coarse}} = 64$，加密比率 $r = 2$。\n  - 蒙特卡洛：路径数 $M = 120000$，随机种子 $= 12345$。\n\n- 测试 B（向上敲出看涨期权，离散监测，阶数 $\\alpha = \\tfrac{1}{2}$）：\n  - 参数：$S_0 = 100$, $K = 100$, $B = 130$, $r = 0.03$, $\\sigma = 0.25$, $T = 1$, $N_{\\text{coarse}} = 64$，加密比率 $r = 2$。\n  - 蒙特卡洛：路径数 $M = 120000$，随机种子 $= 54321$。\n\n- 测试 C（向上敲出看涨期权，障碍实际上无效，一个重要的边界情况；该期权行为几乎与普通看涨期权相同）：\n  - 参数：$S_0 = 100$, $K = 100$, $B = 1000$, $r = 0.03$, $\\sigma = 0.25$, $T = 1$, $N_{\\text{coarse}} = 64$，加密比率 $r = 2$。\n  - 蒙特卡洛：路径数 $M = 120000$，随机种子 $= 67890$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 九个输出按以下顺序出现：首先是测试 A 的输出 $[P_h, P_{h/2}, P_{\\mathrm{RE}}]$，然后是测试 B 的输出 $[P_h, P_{h/2}, P_{\\mathrm{RE}}]$，最后是测试 C 的输出 $[P_h, P_{h/2}, P_{\\mathrm{RE}}]$，连接成一个长度为 9 的单一列表。\n- 所有输出都必须是浮点数（以货币单位计，无特殊单位转换），并按规定使用风险中性折现。", "solution": "该问题被评估为有效。它在科学上基于金融工程的成熟理论，特别是风险中性定价、资产价格的随机微分方程以及蒙特卡洛模拟方法。这是一个适定的问题，提供了所有必要的参数和定义。它要求推导并实现一种标准的数值技术——Richardson 外推法，并将其应用于众所周知的路径依赖期权。整个设置是自洽、一致且客观的。\n\n### 理论基础与算法设计\n\n#### 1. 风险中性定价与几何布朗运动\n\n在风险中性的世界里，衍生品的价格是其未来支付的折现期望值。标的资产价格 $S_t$ 由几何布朗运动（GBM）过程建模，该过程由以下随机微分方程（SDE）描述：\n$$\ndS_t = r S_t \\, dt + \\sigma S_t \\, dW_t\n$$\n这里，$S_t$ 是时间 $t$ 的资产价格，$r$ 是恒定的无风险利率，$\\sigma$ 是恒定的波动率，$W_t$ 是一个标准的维纳过程（布朗运动）。\n\n对于蒙特卡洛模拟，我们需要在离散时间网格 $0=t_0, t_1, \\dots, t_N=T$ 上生成 $S_t$ 的路径，时间步长均匀为 $\\Delta t = T/N$。SDE 的精确解使我们能够在不引入任何 SDE 离散化误差的情况下模拟下一个时间步的价格。给定 $S_{t_k}$，下一个时间步 $S_{t_{k+1}}$ 的价格由下式给出：\n$$\nS_{t_{k+1}} = S_{t_k} \\exp\\left(\\left(r - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_{k+1}\\right)\n$$\n其中 $Z_1, Z_2, \\dots, Z_N$ 是独立同分布的标准正态随机变量，$Z_k \\sim \\mathcal{N}(0,1)$。\n\n一个到期日为 $T$、支付泛函为 $\\Phi$ 的欧式或有债权的价格由风险中性估值公式给出：\n$$\nV_0 = e^{-rT} \\mathbb{E}[\\Phi(S_{[0,T]})]\n$$\n其中 $\\mathbb{E}[\\cdot]$ 表示在风险中性测度下的期望。\n\n#### 2. 时间离散化支付中的弱误差\n\n对于路径依赖期权，支付泛函 $\\Phi$ 可能依赖于整个路径 $S_{[0,T]}$。在离散时间模拟中，我们用一个仅依赖于离散网格点 $\\{S_{t_k}\\}_{k=0}^N$ 上的价格的泛函 $\\Phi_h$ 来近似 $\\Phi$，其中 $h = T/N$ 是网格尺寸。这种近似引入了时间离散化误差，也称为偏差或弱误差，定义为 $\\mathbb{E}[\\Phi_h] - \\mathbb{E}[\\Phi]$。这个误差的阶数 $\\alpha$ 取决于离散泛函 $\\Phi_h$ 如何收敛到连续泛函 $\\Phi$。\n\n- **算术平均亚式看涨期权：** 支付基于路径上的平均价格。连续时间支付涉及一个积分：$\\max(\\frac{1}{T}\\int_0^T S_u du - K, 0)$。离散时间近似使用一个和：$\\Phi_{\\text{Asian}} = \\max(\\frac{1}{N}\\sum_{k=1}^N S_{t_k} - K, 0)$。这个和是该积分的矩形法则近似。这种数值积分方案的误差阶数为 $h$。这转化为价格估计量的弱收敛阶数为 $\\alpha=1$，意味着偏差与 $h$ 成正比。\n\n- **向上敲出障碍看涨期权：** 支付依赖于路径上的最大价格：$\\Phi_{\\text{UO}} = \\mathbf{1}\\{\\sup_{u \\in [0,T]} S_u  B\\} \\max(S_T - K, 0)$。朴素离散监测方法仅在网格点上检查障碍条件：$\\Phi_{\\text{UO},h} = \\mathbf{1}\\{\\max_{k=1,\\dots,N} S_{t_k}  B\\} \\max(S_T - K, 0)$。一个主要的误差来源是连续路径 $S_u$ 可能在观测点 $t_k$ 和 $t_{k+1}$ *之间* 穿越障碍 $B$ 而未被检测到。在长度为 $h$ 的小区间内发生这种未被检测到的穿越的概率与 $\\sqrt{h}$ 成比例。这导致了对真实敲出概率的系统性低估，从而高估了期权价格。最终的弱收敛阶数为 $\\alpha = 1/2$，意味着偏差与 $\\sqrt{h}$ 成正比。\n\n#### 3. Richardson 外推法\n\nRichardson 外推法是一种通过消除主阶误差项来提高数值近似精度的技术。假设离散化支付估计量的期望值 $P_h = e^{-rT}\\mathbb{E}[\\Phi_h]$ 允许一个关于步长 $h$ 的幂次方的误差展开式：\n$$\nP_h = V_0 + c h^{\\alpha} + O(h^{\\beta}) \\quad \\text{其中 } \\beta  \\alpha\n$$\n这里 $V_0$ 是真实价格，$c$ 是一个常数，$\\alpha$ 是弱收敛阶数。\n\n我们可以使用两种不同的步长来计算价格：一个粗糙步长 $h$ 和一个精细步长 $h/r$，其中加密比率 $r  1$。设 $P_h$ 和 $P_{h/r}$ 是我们从蒙特卡洛模拟中得到的相应价格估计。我们有以下近似方程组：\n\\begin{align*}\nP_h \\approx V_0 + c h^{\\alpha} \\quad (1) \\\\\nP_{h/r} \\approx V_0 + c \\left(\\frac{h}{r}\\right)^{\\alpha} = V_0 + \\frac{c}{r^{\\alpha}} h^{\\alpha} \\quad (2)\n\\end{align*}\n我们的目标是消除未知的误差项 $c h^{\\alpha}$ 以获得对 $V_0$ 的更好估计。我们将方程 $(2)$ 乘以 $r^{\\alpha}$：\n$$\nr^{\\alpha} P_{h/r} \\approx r^{\\alpha} V_0 + c h^{\\alpha} \\quad (3)\n$$\n从 $(3)$ 中减去方程 $(1)$ 得到：\n$$\nr^{\\alpha} P_{h/r} - P_h \\approx (r^{\\alpha} - 1) V_0\n$$\n解出 $V_0$ 得到 Richardson 外推估计量 $P_{\\mathrm{RE}}$：\n$$\nP_{\\mathrm{RE}} = \\frac{r^{\\alpha} P_{h/r} - P_h}{r^{\\alpha} - 1}\n$$\n该估计量具有更高阶的精度，其主阶误差项为 $O(h^{\\beta})$。此公式严重依赖于正确的弱收敛阶数 $\\alpha$。对于亚式看涨期权，我们使用 $\\alpha=1$。对于离散监测的障碍期权，我们使用 $\\alpha=1/2$。指定的加密比率为 $r=2$。\n\n#### 4. 使用公共随机数（CRN）的实现\n\nRichardson 外推法的有效性取决于对 $P_h$ 和 $P_{h/r}$ 的准确估计。为了减小组合估计量 $P_{\\mathrm{RE}}$ 的方差，使用公共随机数（CRN）至关重要。该技术通过使用相同的底层随机源为粗糙和精细网格生成路径，来确保差值 $P_{h/r} - P_h$ 具有较小的方差。\n\n我们首先为 $M$ 条蒙特卡洛路径中的每一条生成一组 $N_{\\text{fine}}$ 个标准正态变量 $\\{Z_k\\}_{k=1}^{N_{\\text{fine}}}$。这里，$N_{\\text{fine}} = r \\times N_{\\text{coarse}}$。在我们的例子中，$r=2$，所以 $N_{\\text{fine}} = 2 N_{\\text{coarse}}$。\n\n1.  **精细路径模拟：** 使用步长为 $h_{\\text{fine}} = T/N_{\\text{fine}}$ 的精确 GBM 转移公式和随机变量 $Z_k$ 来模拟一条包含 $N_{\\text{fine}}$ 个步骤的完整路径。设此路径为 $\\{S_{t_k}^{\\text{fine}}\\}_{k=0}^{N_{\\text{fine}}}$。\n\n2.  **粗糙路径构造：** 粗糙路径是从精细路径中以一致的方式构造出来的。一个粗糙时间步 $h_{\\text{coarse}} = T/N_{\\text{coarse}} = r h_{\\text{fine}}$ 对应于 $r$ 个精细时间步。粗糙网格点 $t'_j = j h_{\\text{coarse}}$ 上的资产价格就是对应精细网格点 $t_k$（其中 $k=j \\times r$）上的价格。因此，我们可以通过简单地从模拟的精细路径中每隔 $r$ 个点选取一个点来获得粗糙路径：$\\{S_{t'_j}^{\\text{coarse}}\\} = \\{S_{t_{j \\times r}}^{\\text{fine}}\\}$。对于 $r=2$，这意味着 `S_coarse = S_fine[::2]`。这正确地实现了 CRN 方案，其中粗糙步长的布朗增量是底层精细步长增量的缩放和，确保两条路径的终点价格 $S_T$ 相同，这是 CRN 的一个关键特性。\n\n在模拟了 $M$ 对（粗糙，精细）路径后，我们计算平均支付，并将其折现以获得价格估计值 $P_h$ 和 $P_{h/2}$，最后应用适当的 Richardson 外推公式来计算 $P_{\\mathrm{RE}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef price_with_richardson(\n    S0, K, r, sigma, T,\n    N_coarse, B, M, seed,\n    option_type, alpha\n):\n    \"\"\"\n    Prices a path-dependent option using Monte Carlo simulation with two grid sizes\n    and applies Richardson extrapolation to reduce the weak error (bias).\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility.\n        T (float): Time to maturity.\n        N_coarse (int): Number of time steps for the coarse grid.\n        B (float or None): Barrier level for barrier options.\n        M (int): Number of Monte Carlo paths.\n        seed (int): Random seed for reproducibility.\n        option_type (str): Type of option ('asian_call' or 'barrier_call').\n        alpha (float): Weak convergence order.\n\n    Returns:\n        tuple[float, float, float]: A tuple containing the coarse-grid price,\n                                     the fine-grid price, and the Richardson-\n                                     extrapolated price.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Grid parameters\n    refinement_ratio = 2\n    N_fine = refinement_ratio * N_coarse\n    h_fine = T / N_fine\n\n    # Generate all standard normal random numbers for all fine paths at once\n    Z = rng.standard_normal(size=(M, N_fine))\n\n    # --- Simulate all fine paths in a vectorized manner ---\n    # We use the exact log-normal solution for GBM\n    S_fine = np.zeros((M, N_fine + 1))\n    S_fine[:, 0] = S0\n    \n    # Calculate log-returns for each step\n    drift = (r - 0.5 * sigma**2) * h_fine\n    diffusion = sigma * np.sqrt(h_fine)\n    log_returns = drift + diffusion * Z\n    \n    # Cumulatively sum log-returns to get log-path, then exponentiate\n    log_paths = np.cumsum(log_returns, axis=1)\n    S_fine[:, 1:] = S0 * np.exp(log_paths)\n\n    # --- Extract coarse paths using Common Random Numbers (CRN) ---\n    # The coarse path consists of every `refinement_ratio`-th point of the fine path.\n    # This correctly implements CRN as the Brownian increments are nested.\n    S_coarse = S_fine[:, ::refinement_ratio]\n    \n    # --- Calculate payoffs for both grids ---\n    # Per problem definition, path-dependent features (avg, max) are computed\n    # over the discrete observation points t_1, ..., t_N.\n    # This corresponds to array slices [:, 1:].\n    \n    if option_type == 'asian_call':\n        # Fine grid payoff\n        avg_fine = np.mean(S_fine[:, 1:], axis=1)\n        payoff_fine = np.maximum(avg_fine - K, 0)\n        # Coarse grid payoff\n        avg_coarse = np.mean(S_coarse[:, 1:], axis=1)\n        payoff_coarse = np.maximum(avg_coarse - K, 0)\n    \n    elif option_type == 'barrier_call':\n        # Fine grid payoff\n        max_fine = np.max(S_fine[:, 1:], axis=1)\n        indicator_fine = (max_fine  B)\n        # Payoff is based on terminal price S_T = S_fine[:, -1]\n        payoff_fine = np.maximum(S_fine[:, -1] - K, 0) * indicator_fine\n        \n        # Coarse grid payoff\n        max_coarse = np.max(S_coarse[:, 1:], axis=1)\n        indicator_coarse = (max_coarse  B)\n        # Terminal price is identical due to CRN: S_coarse[:, -1] == S_fine[:, -1]\n        payoff_coarse = np.maximum(S_coarse[:, -1] - K, 0) * indicator_coarse\n    else:\n        raise ValueError(\"Unknown option type specified.\")\n\n    # --- Calculate discounted expected payoffs (prices) ---\n    discount_factor = np.exp(-r * T)\n    P_coarse = discount_factor * np.mean(payoff_coarse) # This is P_h\n    P_fine = discount_factor * np.mean(payoff_fine)     # This is P_{h/r}\n    \n    # --- Richardson Extrapolation ---\n    # P_RE = (r^alpha * P_{h/r} - P_h) / (r^alpha - 1)\n    P_RE = (refinement_ratio**alpha * P_fine - P_coarse) / (refinement_ratio**alpha - 1)\n    \n    return P_coarse, P_fine, P_RE\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A: Arithmetic-average Asian call, weak order alpha = 1.0\n        {'S0': 100, 'K': 100, 'r': 0.05, 'sigma': 0.2, 'T': 1, 'N_coarse': 64, \n         'B': None, 'M': 120000, 'seed': 12345, 'option_type': 'asian_call', 'alpha': 1.0},\n        \n        # Test B: Up-and-out barrier call, discrete monitoring, weak order alpha = 0.5\n        {'S0': 100, 'K': 100, 'B': 130, 'r': 0.03, 'sigma': 0.25, 'T': 1, 'N_coarse': 64, \n         'M': 120000, 'seed': 54321, 'option_type': 'barrier_call', 'alpha': 0.5},\n        \n        # Test C: Up-and-out barrier call, effectively inactive barrier, alpha = 0.5\n        {'S0': 100, 'K': 100, 'B': 1000, 'r': 0.03, 'sigma': 0.25, 'T': 1, 'N_coarse': 64, \n         'M': 120000, 'seed': 67890, 'option_type': 'barrier_call', 'alpha': 0.5},\n    ]\n\n    results = []\n    for params in test_cases:\n        p_coarse, p_fine, p_re = price_with_richardson(**params)\n        results.extend([p_coarse, p_fine, p_re])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3321511"}]}