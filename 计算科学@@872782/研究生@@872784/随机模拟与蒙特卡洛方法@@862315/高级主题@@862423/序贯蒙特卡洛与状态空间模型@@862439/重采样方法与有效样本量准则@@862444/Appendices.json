{"hands_on_practices": [{"introduction": "我们将从构建坚实的理论基础开始。本练习将分析最基础的重采样方案——多项式重采样 (multinomial resampling)。你需要从第一性原理出发，推导后代粒子数量的方差和协方差。这项练习将揭示重采样步骤引入的统计效应，特别是它在粒子数量之间引入的内在负相关性，这对于理解重采样对估计器方差的影响至关重要。[@problem_id:3336496]", "problem": "考虑一个序贯蒙特卡洛 (SMC) 算法，该算法维护一个包含 $M$ 个粒子的群体，其归一化权重为 $\\{w_{i}\\}_{i=1}^{M}$，满足 $w_{i}0$ 且 $\\sum_{i=1}^{M} w_{i} = 1$。一个标准的多项重采样步骤通过从 $\\{1,2,\\dots,M\\}$ 上的分类分布中独立抽取索引 $I_{1}, I_{2}, \\dots, I_{N}$ 来生成一组新的 $N$ 个后代，其概率为 $\\mathbb{P}(I_{n}=i)=w_{i}$。对于每个 $i \\in \\{1,\\dots,M\\}$，定义后代数量\n$$\nA_{i} := \\sum_{n=1}^{N} \\mathbf{1}\\{I_{n}=i\\}.\n$$\n仅使用期望、方差和协方差的基本定义，以及抽样间的独立性和单次抽样内类别指示符的互斥性，推导 $\\operatorname{Var}(A_{i})$ 和 $i \\neq j$ 时的 $\\operatorname{Cov}(A_{i}, A_{j})$ 的闭式解析表达式，并用它们证明成对协方差为负。请用符号表达式表示最终答案；无需数值近似。[@problem_id:175]", "solution": "该问题是有效的，因为它具有科学依据、问题明确、客观且自洽。我们可以开始推导。\n\n该问题描述了一个多项抽样过程。我们从一个包含 $M$ 个类别的分类分布中进行 $N$ 次独立抽样，抽到类别 $i$ 的概率是 $w_i$。变量 $A_i$ 表示在 $N$ 次试验中抽到类别 $i$ 的总次数。随机变量集合 $(A_1, A_2, \\dots, A_M)$ 服从参数为 $N$ 和 $(w_1, w_2, \\dots, w_M)$ 的多项分布。我们被要求从第一性原理出发，推导 $A_i$ 的方差以及当 $i \\neq j$ 时 $A_i$ 和 $A_j$ 的协方差。\n\n我们为每次抽样 $n \\in \\{1, 2, \\dots, N\\}$ 和每个类别 $i \\in \\{1, 2, \\dots, M\\}$ 定义一个指示随机变量。\n令 $X_{ni} = \\mathbf{1}\\{I_n = i\\}$，其中 $I_n$ 是第 $n$ 次抽样的结果。如果第 $n$ 次抽样选择了粒子 $i$，则 $X_{ni}=1$，否则 $X_{ni}=0$。\n粒子 $i$ 的总数是这些指示符在所有 $N$ 次抽样中的总和：\n$$\nA_i = \\sum_{n=1}^{N} X_{ni}\n$$\n第 $n$ 次抽样选择粒子 $i$ 的概率为 $\\mathbb{P}(I_n=i) = w_i$。\n因此，对于任何 $n$ 和 $i$，$X_{ni}$ 是一个参数为 $w_i$ 的伯努利随机变量，即 $X_{ni} \\sim \\operatorname{Bernoulli}(w_i)$。\n\n首先，我们来计算单个指示符 $X_{ni}$ 的期望和方差。\n期望为：\n$$\n\\mathbb{E}[X_{ni}] = 1 \\cdot \\mathbb{P}(X_{ni}=1) + 0 \\cdot \\mathbb{P}(X_{ni}=0) = \\mathbb{P}(I_n=i) = w_i\n$$\n对于方差，我们首先计算 $\\mathbb{E}[X_{ni}^2]$。由于 $X_{ni}$ 是一个指示符，所以 $X_{ni}^2 = X_{ni}$。\n$$\n\\mathbb{E}[X_{ni}^2] = \\mathbb{E}[X_{ni}] = w_i\n$$\n那么方差为：\n$$\n\\operatorname{Var}(X_{ni}) = \\mathbb{E}[X_{ni}^2] - (\\mathbb{E}[X_{ni}])^2 = w_i - w_i^2 = w_i(1-w_i)\n$$\n\n现在我们推导 $\\operatorname{Var}(A_i)$ 的表达式。\n$A_i$ 的方差由下式给出：\n$$\n\\operatorname{Var}(A_i) = \\operatorname{Var}\\left(\\sum_{n=1}^{N} X_{ni}\\right)\n$$\n抽样 $I_1, I_2, \\dots, I_N$ 是独立的。因此，对于一个固定的类别 $i$，随机变量 $X_{1i}, X_{2i}, \\dots, X_{Ni}$ 是独立的。独立随机变量之和的方差等于它们方差的和。\n$$\n\\operatorname{Var}(A_i) = \\sum_{n=1}^{N} \\operatorname{Var}(X_{ni})\n$$\n由于对于 $n=1, \\dots, N$ 的所有 $X_{ni}$ 都是同分布的，所以它们的方差相同。\n$$\n\\operatorname{Var}(A_i) = \\sum_{n=1}^{N} w_i(1-w_i) = N w_i(1-w_i)\n$$\n\n接下来，我们推导 $i \\neq j$ 时 $\\operatorname{Cov}(A_i, A_j)$ 的表达式。\n协方差的定义是 $\\operatorname{Cov}(A_i, A_j) = \\mathbb{E}[A_i A_j] - \\mathbb{E}[A_i]\\mathbb{E}[A_j]$。\n首先，我们计算 $A_i$ 的期望：\n$$\n\\mathbb{E}[A_i] = \\mathbb{E}\\left[\\sum_{n=1}^{N} X_{ni}\\right] = \\sum_{n=1}^{N} \\mathbb{E}[X_{ni}] = \\sum_{n=1}^{N} w_i = N w_i\n$$\n同理，$\\mathbb{E}[A_j] = N w_j$。协方差的第二项是 $\\mathbb{E}[A_i]\\mathbb{E}[A_j] = (N w_i)(N w_j) = N^2 w_i w_j$。\n\n现在我们计算第一项 $\\mathbb{E}[A_i A_j]$。\n$$\nA_i A_j = \\left(\\sum_{n=1}^{N} X_{ni}\\right) \\left(\\sum_{m=1}^{N} X_{mj}\\right) = \\sum_{n=1}^{N} \\sum_{m=1}^{N} X_{ni} X_{mj}\n$$\n根据期望的线性性：\n$$\n\\mathbb{E}[A_i A_j] = \\mathbb{E}\\left[\\sum_{n=1}^{N} \\sum_{m=1}^{N} X_{ni} X_{mj}\\right] = \\sum_{n=1}^{N} \\sum_{m=1}^{N} \\mathbb{E}[X_{ni} X_{mj}]\n$$\n我们必须计算期望 $\\mathbb{E}[X_{ni} X_{mj}]$。我们考虑索引 $n$ 和 $m$ 的两种情况。\n\n情况 1：$n \\neq m$。\n抽样 $I_n$ 和 $I_m$ 是独立的。因此，指示变量 $X_{ni} = \\mathbf{1}\\{I_n=i\\}$ 和 $X_{mj} = \\mathbf{1}\\{I_m=j\\}$ 是独立的。\n对于独立变量，乘积的期望等于期望的乘积：\n$$\n\\mathbb{E}[X_{ni} X_{mj}] = \\mathbb{E}[X_{ni}] \\mathbb{E}[X_{mj}] = w_i w_j\n$$\n当 $n \\neq m$ 时，有 $N^2 - N = N(N-1)$ 个这样的配对 $(n,m)$。\n\n情况 2：$n = m$。\n我们考虑的是 $i \\neq j$ 时的 $\\mathbb{E}[X_{ni} X_{nj}]$。指示符的乘积为：\n$$\nX_{ni} X_{nj} = \\mathbf{1}\\{I_n=i\\} \\mathbf{1}\\{I_n=j\\}\n$$\n由于 $i \\neq j$，单次抽样 $I_n$ 不能同时等于 $i$ 和 $j$。事件 $\\{I_n=i\\}$ 和 $\\{I_n=j\\}$ 是互斥的。\n因此，乘积 $\\mathbf{1}\\{I_n=i\\} \\mathbf{1}\\{I_n=j\\}$ 总是 $0$。\n这意味着 $\\mathbb{E}[X_{ni} X_{nj}] = \\mathbb{E}[0] = 0$。\n当 $n=m$ 时，有 $N$ 个这样的配对 $(n,m)$。\n\n现在我们可以通过拆分双重求和来计算 $\\mathbb{E}[A_i A_j]$：\n$$\n\\mathbb{E}[A_i A_j] = \\sum_{n \\neq m} \\mathbb{E}[X_{ni} X_{mj}] + \\sum_{n=m} \\mathbb{E}[X_{ni} X_{nj}]\n$$\n代入两种情况的结果：\n$$\n\\mathbb{E}[A_i A_j] = \\sum_{n \\neq m} (w_i w_j) + \\sum_{n=m} (0) = N(N-1) w_i w_j\n$$\n最后，我们计算协方差：\n$$\n\\operatorname{Cov}(A_i, A_j) = \\mathbb{E}[A_i A_j] - \\mathbb{E}[A_i]\\mathbb{E}[A_j] = N(N-1) w_i w_j - N^2 w_i w_j\n$$\n$$\n\\operatorname{Cov}(A_i, A_j) = (N^2 - N) w_i w_j - N^2 w_i w_j = -N w_i w_j\n$$\n\n为了证明当 $i \\neq j$ 时成对协方差为负：\n推导出的表达式是 $\\operatorname{Cov}(A_i, A_j) = -N w_i w_j$。\n根据问题陈述：\n1. $N$ 是后代的数量，是一个正整数，所以 $N  0$。\n2. 权重满足对于所有 $k \\in \\{1, \\dots, M\\}$ 都有 $w_k  0$。这意味着 $w_i  0$ 且 $w_j  0$。\n乘积 $N w_i w_j$ 是三个正数的乘积，因此为正。\n因此，$\\operatorname{Cov}(A_i, A_j) = -N w_i w_j  0$。这证实了成对协方差是负的。这是一个预期的结果，因为存在约束 $\\sum_{k=1}^{M} A_k = N$；一个类别的计数增加必须由其他类别的计数减少来补偿。\n\n最终的表达式为：\n$\\operatorname{Var}(A_i) = N w_i(1 - w_i)$\n当 $i \\neq j$ 时，$\\operatorname{Cov}(A_i, A_j) = -N w_i w_j$。", "answer": "$$\n\\boxed{\\begin{pmatrix} N w_i(1-w_i)  -N w_i w_j \\end{pmatrix}}\n$$", "id": "3336496"}, {"introduction": "先进重采样方法的一个关键目标是减少估计方差并保持粒子多样性。本练习通过分析重采样后存活的唯一父代粒子的期望数量，来比较多项式重采样与更精妙的分层重采样 (stratified resampling) 方法。通过这种理论上的对比，你将揭示分层方法为何以及如何在保持粒子多样性方面优于基础方法，从而降低样本枯竭的风险。[@problem_id:3336501]", "problem": "考虑一个序贯蒙特卡洛（SMC）算法中的单个重采样步骤，该算法有 $N \\geq 2$ 个粒子和满足 $\\tilde w_i \\geq 0$ 及 $\\sum_{i=1}^{N} \\tilde w_i = 1$ 的归一化权重 $\\tilde w_{1:N}$。定义累积权重 $C_0 = 0$ 和 $C_i = \\sum_{k=1}^{i} \\tilde w_k$（对于 $i \\in \\{1,\\dots,N\\}$）。令 $I_i = [C_{i-1}, C_i)$ 表示与粒子 $i$ 关联的权重区间。一个重采样步骤根据以下方案之一从加权总体中产生 $N$ 个后代：\n\n- 多项式重采样：从 $\\{1,\\dots,N\\}$ 上的离散分布中抽取 $N$ 个独立样本，其概率为 $\\tilde w_{1:N}$。\n\n- 分层重采样：独立抽取 $V_1,\\dots,V_N$，其中 $V_j \\sim \\mathrm{Uniform}(0,1)$，对于 $j \\in \\{1,\\dots,N\\}$，设置 $U_j = \\frac{j-1+V_j}{N}$，并将后代 $j$ 分配给唯一的 $i$，使得 $U_j \\in I_i$。\n\n对于一个重采样方案，定义后代计数 $N_i = \\sum_{j=1}^{N} \\mathbf{1}\\{U_j \\in I_i\\}$ 和不同祖先的数量 $K = \\sum_{i=1}^{N} \\mathbf{1}\\{N_i \\geq 1\\}$。您可以使用以下基本定义：对于任何事件 $A$，$\\mathbf{1}\\{A\\}$ 表示指示函数；对于任何实数 $x$，$\\lfloor x \\rfloor$ 是向下取整（不大于 $x$ 的最大整数），$\\{x\\} = x - \\lfloor x \\rfloor$ 是小数部分。\n\n仅从这些定义出发，推导在多项式重采样和分层重采样下的条件期望 $\\mathbb{E}[K \\mid \\tilde w_{1:N}]$。您的最终表达式应仅用 $N$、$\\tilde w_{1:N}$ 和累积和 $C_i$ 来表示。您的推导必须从概率论的基本原理和两种重采样器的构造出发，论证每一步。\n\n将您的最终答案报告为一个包含两个表达式的单行矩阵 $[\\mathbb{E}_{\\mathrm{mult}}(K \\mid \\tilde w_{1:N}),\\, \\mathbb{E}_{\\mathrm{strat}}(K \\mid \\tilde w_{1:N})]$。不需要进行数值计算，也不需要四舍五入。", "solution": "我们感兴趣的目标是，在给定归一化权重 $\\tilde w_{1:N}$ 的条件下，不同祖先数量 $K$ 的条件期望。为简洁起见，我们记此期望为 $\\mathbb{E}[K]$，因为在整个推导过程中，以权重为条件是隐含的。\n\n不同祖先的数量定义为 $K = \\sum_{i=1}^{N} \\mathbf{1}\\{N_i \\geq 1\\}$，其中 $N_i$ 是粒子 $i$ 的后代数量。利用期望的线性性，我们有：\n$$\n\\mathbb{E}[K] = \\mathbb{E}\\left[\\sum_{i=1}^{N} \\mathbf{1}\\{N_i \\geq 1\\}\\right] = \\sum_{i=1}^{N} \\mathbb{E}[\\mathbf{1}\\{N_i \\geq 1\\}]\n$$\n指示函数的期望是它所指示事件的概率。因此：\n$$\n\\mathbb{E}[K] = \\sum_{i=1}^{N} P(N_i \\geq 1)\n$$\n计算互补事件 $\\{N_i = 0\\}$ 的概率通常更方便，该事件表示粒子 $i$ 没有后代。\n$$\nP(N_i \\geq 1) = 1 - P(N_i = 0)\n$$\n将此代入 $\\mathbb{E}[K]$ 的表达式中，得到：\n$$\n\\mathbb{E}[K] = \\sum_{i=1}^{N} (1 - P(N_i = 0)) = N - \\sum_{i=1}^{N} P(N_i = 0)\n$$\n推导的其余部分在于计算两种重采样方案下各自的 $P(N_i = 0)$。\n\n### 多项式重采样\n\n在多项式重采样中，从由权重 $\\tilde w_{1:N}$ 定义的分类分布中独立抽取 $N$ 个后代。对于单次抽取，选中粒子 $i$ 的概率是 $\\tilde w_i$。因此，在单次抽取中*不*选中粒子 $i$ 的概率是 $1 - \\tilde w_i$。\n\n事件 $\\{N_i = 0\\}$ 发生，当且仅当在 $N$ 次独立抽取中，粒子 $i$ 均未被选中。该事件的概率是在 $N$ 次抽取中每次都不选中粒子 $i$ 的概率之积：\n$$\nP_{\\mathrm{mult}}(N_i = 0) = (1 - \\tilde w_i)^N\n$$\n将此结果代入 $\\mathbb{E}[K]$ 的通用公式中：\n$$\n\\mathbb{E}_{\\mathrm{mult}}[K \\mid \\tilde w_{1:N}] = N - \\sum_{i=1}^{N} (1 - \\tilde w_i)^N\n$$\n\n### 分层重采样\n\n在分层重采样中，生成 $N$ 个有序的均匀分布随机数 $U_j = \\frac{j-1+V_j}{N}$，其中 $V_j \\sim \\mathrm{Uniform}(0,1)$ 是独立的。因此，每个 $U_j$ 都是从其对应的层 $J_j = [\\frac{j-1}{N}, \\frac{j}{N})$ 中均匀抽取的。如果 $U_j$ 落入区间 $I_i = [C_{i-1}, C_i)$，则第 $j$ 个后代是粒子 $i$ 的一个副本。\n\n粒子 $i$ 的后代数量为 $N_i = \\sum_{j=1}^{N} \\mathbf{1}\\{U_j \\in I_i\\}$。事件 $\\{N_i=0\\}$ 发生，如果没有 $U_j$ 落入区间 $I_i$。由于 $V_j$ 是独立的，因此 $U_j$ 也是独立的。因此，粒子 $i$ 没有后代的概率是：\n$$\nP_{\\mathrm{strat}}(N_i = 0) = P\\left(\\bigcap_{j=1}^{N} \\{U_j \\notin I_i\\}\\right) = \\prod_{j=1}^{N} P(U_j \\notin I_i) = \\prod_{j=1}^{N} (1 - P(U_j \\in I_i))\n$$\n概率 $P(U_j \\in I_i)$ 是两个区间交集的长度与 $U_j$ 的支撑集长度之比：\n$$\np_{ij} \\equiv P(U_j \\in I_i) = \\frac{\\text{length}(I_i \\cap J_j)}{\\text{length}(J_j)} = \\frac{\\text{length}([C_{i-1}, C_i) \\cap [\\frac{j-1}{N}, \\frac{j}{N}))}{1/N} = N \\cdot \\text{length}([C_{i-1}, C_i) \\cap [\\frac{j-1}{N}, \\frac{j}{N}))\n$$\n$p_{ij}$ 的值取决于区间 $I_i$ 和层 $J_j$ 之间的关系。让我们将问题按因子 $N$ 进行缩放。令 $a = NC_{i-1}$ 和 $b = NC_i$。缩放后的区间是 $[a, b)$，长度为 $N\\tilde w_i$。缩放后的层是 $[j-1, j)$。那么 $p_{ij} = \\text{length}([a,b)\\cap[j-1,j))$。\n\n我们根据区间 $I_i$ 内包含多少个层边界 $k/N$（其中 $k$ 为整数）来分析 $P(N_i=0)$。这由值 $\\lfloor N C_i \\rfloor - \\lfloor N C_{i-1} \\rfloor$ 决定。\n\n**情况 1：$\\lfloor NC_i \\rfloor = \\lfloor NC_{i-1} \\rfloor$。**\n设这个共同的整数值为 $k$。这意味着 $k \\leq NC_{i-1}$ 且 $NC_i  k+1$。整个区间 $I_i$ 被包含在单个层 $J_{k+1} = [\\frac{k}{N}, \\frac{k+1}{N})$ 内。\n对于 $j \\neq k+1$，交集 $I_i \\cap J_j$ 为空，所以 $p_{ij}=0$。\n对于 $j=k+1$，$p_{i,k+1} = N \\cdot \\text{length}([C_{i-1}, C_i)) = N(C_i-C_{i-1}) = N\\tilde w_i$。\n在这种情况下，$P(N_i=0)$ 的连乘积中只有一个项不为 1：\n$$\nP(N_i=0) = 1 - p_{i,k+1} = 1 - N\\tilde w_i\n$$\n\n**情况 2：$\\lfloor NC_i \\rfloor = \\lfloor NC_{i-1} \\rfloor + 1$。**\n令 $k=\\lfloor NC_{i-1} \\rfloor$。那么 $\\lfloor NC_i \\rfloor = k+1$。区间 $I_i$ 恰好穿过一个层边界 $\\frac{k+1}{N}$。它与两个层 $J_{k+1}$ 和 $J_{k+2}$ 相交。\n对于 $j \\notin \\{k+1, k+2\\}$，$p_{ij}=0$。$P(N_i=0)$ 的连乘积简化为 $(1-p_{i,k+1})(1-p_{i,k+2})$。\n对于第一个相交的层，其概率为：\n$p_{i,k+1} = N \\cdot \\text{length}([C_{i-1}, \\frac{k+1}{N})) = N(\\frac{k+1}{N} - C_{i-1}) = k+1 - NC_{i-1} = 1 - (NC_{i-1} - k) = 1 - \\{NC_{i-1}\\}$。\n对于第二个相交的层，其概率为：\n$p_{i,k+2} = N \\cdot \\text{length}([\\frac{k+1}{N}, C_i)) = N(C_i - \\frac{k+1}{N}) = NC_i - (k+1) = NC_i - \\lfloor NC_i \\rfloor = \\{NC_i\\}$。\n因此，没有后代的概率是：\n$$\nP(N_i=0) = (1 - p_{i,k+1})(1-p_{i,k+2}) = (1 - (1-\\{NC_{i-1}\\}))(1 - \\{NC_i\\}) = \\{NC_{i-1}\\}(1 - \\{NC_i\\})\n$$\n\n**情况 3：$\\lfloor NC_i \\rfloor \\geq \\lfloor NC_{i-1} \\rfloor + 2$。**\n在这种情况下，区间 $I_i$ 足够宽，可以完全包含至少一个层。令 $k = \\lfloor NC_{i-1} \\rfloor + 1$。层 $J_{k+1} = [\\frac{k}{N}, \\frac{k+1}{N})$ 完全被包含在 $I_i$ 内。这是因为 $C_{i-1}  \\frac{k}{N}$ 且 $C_i  \\frac{k+1}{N}$。\n对于 $j = k+1$，$p_{ij} = N \\cdot \\text{length}([\\frac{k}{N}, \\frac{k+1}{N})) = N \\cdot \\frac{1}{N} = 1$。\n$P(N_i = 0)$ 的连乘积中包含一个因子 $(1-p_{i,k+1}) = (1-1) = 0$。因此：\n$$\nP(N_i=0) = 0\n$$\n\n使用指示函数将这三种情况合并，我们得到 $P(N_i=0)$ 的单一表达式：\n$$\nP_{\\mathrm{strat}}(N_i=0) = (1-N\\tilde{w}_i)\\mathbf{1}_{\\{\\lfloor NC_i \\rfloor = \\lfloor NC_{i-1} \\rfloor\\}} + \\{NC_{i-1}\\}(1 - \\{NC_i\\})\\mathbf{1}_{\\{\\lfloor NC_i \\rfloor = \\lfloor NC_{i-1} \\rfloor+1\\}}\n$$\n其中 $\\{x\\} = x-\\lfloor x \\rfloor$。\n在分层重采样下，不同祖先的总期望数量为：\n$$\n\\mathbb{E}_{\\mathrm{strat}}[K \\mid \\tilde w_{1:N}] = N - \\sum_{i=1}^{N} \\left[ (1-N\\tilde{w}_i)\\mathbf{1}_{\\{\\lfloor NC_i \\rfloor = \\lfloor NC_{i-1} \\rfloor\\}} + \\{NC_{i-1}\\}(1 - \\{NC_i\\})\\mathbf{1}_{\\{\\lfloor NC_i \\rfloor = \\lfloor NC_{i-1} \\rfloor+1\\}} \\right]\n$$\n根据要求，该表达式可以完全用 $N$、累积和 $C_i$ 以及向下取整函数来表示：\n$$\n\\mathbb{E}_{\\mathrm{strat}}[K \\mid \\tilde w_{1:N}] = N - \\sum_{i=1}^{N} \\left[ (1-N(C_i-C_{i-1}))\\mathbf{1}_{\\{\\lfloor NC_i \\rfloor = \\lfloor NC_{i-1} \\rfloor\\}} + (NC_{i-1}-\\lfloor NC_{i-1} \\rfloor)(1 - (NC_i-\\lfloor NC_i \\rfloor))\\mathbf{1}_{\\{\\lfloor NC_i \\rfloor = \\lfloor NC_{i-1} \\rfloor+1\\}} \\right]\n$$\n\n最终答案是一个包含两个表达式的行矩阵。", "answer": "$$\n\\boxed{\\begin{pmatrix} N - \\sum_{i=1}^{N} (1 - \\tilde w_i)^N  N - \\sum_{i=1}^{N} \\left[ (1 - N \\tilde w_i) \\mathbf{1}_{\\{\\lfloor N C_i \\rfloor = \\lfloor N C_{i-1} \\rfloor\\}} + (N C_{i-1} - \\lfloor N C_{i-1} \\rfloor) (1 - (N C_i - \\lfloor N C_i \\rfloor)) \\mathbf{1}_{\\{\\lfloor N C_i \\rfloor = \\lfloor N C_{i-1} \\rfloor + 1\\}} \\right] \\end{pmatrix}}\n$$", "id": "3336501"}, {"introduction": "在理论上比较了几种方法之后，我们现在转向一项全面的计算挑战。本练习将寻找最佳重采样方案的问题构建为一个优化问题，并通过线性规划求解，以确定估计器方差的理论下界。你将亲手实现多种实用重采样方法的方差计算，并将它们的性能与此最优基准进行比较，从而通过实践对各种方法的相对优劣获得深刻的理解。[@problem_id:3336443]", "problem": "考虑一组由 $i \\in \\{1,\\dots,n\\}$ 索引的加权粒子，其归一化权重为 $\\tilde w_i \\ge 0$，$\\sum_{i=1}^n \\tilde w_i = 1$，并且在每个粒子位置 $X_i$ 上有一个函数评估值 $\\phi(X_i) \\in \\mathbb{R}$。一个重采样步骤产生整数后代计数 $O_i \\in \\mathbb{Z}_{\\ge 0}$，使得 $\\sum_{i=1}^n O_i = N$。随机向量 $(O_1,\\dots,O_n)$ 由一个重采样机制生成，其分布必须对所有 $i \\in \\{1,\\dots,n\\}$ 满足无偏性约束 $\\mathbb{E}[O_i] = N \\tilde w_i$。\n\n您的任务是将重采样表述为一个关于 $(O_1,\\dots,O_n)$ 联合分布的优化问题，该问题旨在最小化估计量\n$$\nS \\triangleq \\sum_{i=1}^n O_i \\, \\phi(X_i),\n$$\n的条件方差，并服从无偏性约束 $\\mathbb{E}[O_i] = N \\tilde w_i$ 和几乎必然成立的固定总计数约束 $\\sum_{i=1}^n O_i = N$。推导和算法必须仅从以下基本内容出发：\n- 方差的定义 $\\operatorname{Var}(Y) = \\mathbb{E}[Y^2] - \\left(\\mathbb{E}[Y]\\right)^2$。\n- 重采样的无偏性和总计数约束，即 $\\mathbb{E}[O_i] = N \\tilde w_i$ 和 $\\sum_{i=1}^n O_i = N$ 几乎必然成立。\n- 参数为 $(N,\\tilde w_1,\\dots,\\tilde w_n)$ 的多项式重采样方案是 $(O_1,\\dots,O_n)$ 的一个有效构造这一事实。\n\n基于此，推导出一个公式，将 $\\operatorname{Var}(S)$ 的最小化问题表示为一个线性规划问题。该线性规划作用于一个概率分布的单纯形，其支撑集为所有满足 $\\sum_{i=1}^n o_i = N$ 的整数分解 $\\mathbf{o} = (o_1,\\dots,o_n)$ 的集合。然后，实现并计算：\n- 从推导出的线性规划中可实现的 $\\operatorname{Var}(S)$ 的最小值。\n- 对于以下实际重采样机制的 $\\operatorname{Var}(S)$ 值：多项式、残差、分层、系统以及一维随机最优传输。对于一维权重，随机最优传输在随机平移下与系统重采样一致；尽管如此，您必须计算并报告两者。\n\n您必须精确计算每个方差（不使用蒙特卡洛近似）。在您的算法设计中，请使用以下事实：\n- 对于多项式重采样，精确方差等于 $N \\left( \\sum_{i=1}^n \\tilde w_i \\phi(X_i)^2 - \\left( \\sum_{i=1}^n \\tilde w_i \\phi(X_i) \\right)^2 \\right)$，这源于多项式向量的协方差结构。\n- 对于残差重采样，如果 $f_i = \\lfloor N \\tilde w_i \\rfloor$, $R = N - \\sum_{i=1}^n f_i$，且当 $R  0$ 时 $r_i = (N \\tilde w_i - f_i)/R$（若 $R=0$ 则采用任意约定），那么精确方差等于 $R \\left( \\sum_{i=1}^n r_i \\phi(X_i)^2 - \\left( \\sum_{i=1}^n r_i \\phi(X_i) \\right)^2 \\right)$。\n- 对于分层重采样，精确方差可以通过对由累积权重引导的、从一个均匀变量到索引的分段常数映射的层内变异性进行积分来计算。\n- 对于系统重采样，精确方差可以通过在后代计数保持恒定的分段常数区域上，对单个均匀平移 $U \\in [0,1)$ 进行积分来计算。\n\n您的程序必须：\n1. 求解最小化 $\\operatorname{Var}(S)$ 的线性规划问题。该问题是关于将 $N$ 分解为 $n$ 个部分的所有整数分解的凸组合上的线性规划，并受无偏性和总计数约束。\n2. 仅使用基于重采样方案已知分布的确定性计算（无随机模拟），计算上述重采样机制的精确条件方差 $\\operatorname{Var}(S)$。\n3. 将计算应用于以下参数值测试套件。每个测试用例由一个三元组 $(N, \\tilde{\\mathbf{w}}, \\boldsymbol{\\phi})$ 指定：\n   - 测试用例 A：$N = 10$，$\\tilde{\\mathbf{w}} = [0.7, 0.1, 0.1, 0.1]$，$\\boldsymbol{\\phi} = [1.0, -0.5, 0.2, 2.0]$。\n   - 测试用例 B：$N = 5$，$\\tilde{\\mathbf{w}} = [0.2, 0.2, 0.2, 0.2, 0.2]$，$\\boldsymbol{\\phi} = [0.0, 1.0, 2.0, 3.0, 4.0]$。\n   - 测试用例 C：$N = 8$，$\\tilde{\\mathbf{w}} = [0.05, 0.05, 0.2, 0.2, 0.2, 0.3]$，$\\boldsymbol{\\phi} = [-1.2, 0.3, 0.0, 2.1, -0.7, 1.5]$。\n   - 测试用例 D：$N = 2$，$\\tilde{\\mathbf{w}} = [0.6, 0.2, 0.2]$，$\\boldsymbol{\\phi} = [3.0, -1.0, 0.5]$。\n\n对于每个测试用例，程序必须输出六个浮点数：来自优化的最小方差，其后是多项式、残差、分层、系统和随机最优传输重采样的方差，顺序如此。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有四个测试用例的结果，形式为一个列表的列表的类 JSON 字符串表示，不含任何额外文本。具体来说，输出必须是形如\n\"[ [v_opt_A, v_mult_A, v_res_A, v_strat_A, v_sys_A, v_ot_A], [v_opt_B, v_mult_B, v_res_B, v_strat_B, v_sys_B, v_ot_B], [v_opt_C, v_mult_C, v_res_C, v_strat_C, v_sys_C, v_ot_C], [v_opt_D, v_mult_D, v_res_D, v_strat_D, v_sys_D, v_ot_D] ]\"\n的单行。所有数字必须表示为十进制浮点值（无百分号或物理单位），并且结果的顺序必须与测试用例 A、B、C、D 和上述指定方法的顺序完全匹配。", "solution": "我们从序列蒙特卡洛（sequential Monte Carlo）中重采样的定义和约束开始。设整数后代计数为 $O_i \\in \\mathbb{Z}_{\\ge 0}$（对于 $i \\in \\{1,\\dots,n\\}$），并满足几乎必然成立的固定总计数约束 $\\sum_{i=1}^n O_i = N$。重采样的无偏性条件为 $\\mathbb{E}[O_i] = N \\tilde w_i$，其中 $\\tilde w_i$ 是归一化权重，满足 $\\sum_{i=1}^n \\tilde w_i = 1$。\n\n定义线性泛函\n$$\nS \\triangleq \\sum_{i=1}^n O_i \\, \\phi(X_i),\n$$\n它恰好是在加权经验测度下，对 $\\phi$ 的期望进行常规重采样后蒙特卡洛估计的 $N$ 倍。我们感兴趣的条件方差是\n$$\n\\operatorname{Var}(S) = \\mathbb{E}[S^2] - \\left(\\mathbb{E}[S]\\right)^2.\n$$\n根据期望的线性性质，并使用无偏性约束，我们有\n$$\n\\mathbb{E}[S] = \\sum_{i=1}^n \\mathbb{E}[O_i] \\, \\phi(X_i) = \\sum_{i=1}^n N \\tilde w_i \\, \\phi(X_i) = N \\sum_{i=1}^n \\tilde w_i \\, \\phi(X_i).\n$$\n\n构建优化问题。考虑将 $N$ 分解为 $n$ 个部分的所有整数分解的集合 $\\mathcal{C}_{n,N}$，即向量 $\\mathbf{o} = (o_1,\\dots,o_n) \\in \\mathbb{Z}_{\\ge 0}^n$ 使得 $\\sum_{i=1}^n o_i = N$。任何有效的重采样分布都是一个在 $\\mathcal{C}_{n,N}$ 上有支撑的概率质量函数 $p(\\mathbf{o})$，它满足线性约束\n$$\n\\sum_{\\mathbf{o}\\in \\mathcal{C}_{n,N}} p(\\mathbf{o}) = 1,\\quad \\sum_{\\mathbf{o}\\in \\mathcal{C}_{n,N}} p(\\mathbf{o}) \\, o_i = N \\tilde w_i,\\quad \\forall i \\in \\{1,\\dots,n\\},\\quad p(\\mathbf{o}) \\ge 0.\n$$\n在此类分布下，$S$ 的二阶矩为\n$$\n\\mathbb{E}[S^2] = \\sum_{\\mathbf{o}\\in \\mathcal{C}_{n,N}} p(\\mathbf{o}) \\left( \\sum_{i=1}^n o_i \\phi(X_i) \\right)^2.\n$$\n令 $a_i \\triangleq \\phi(X_i)$ 和 $m_i \\triangleq N \\tilde w_i$，并定义成本 $c(\\mathbf{o}) \\triangleq \\left(\\sum_{i=1}^n o_i a_i\\right)^2$。那么最小化 $\\operatorname{Var}(S)$ 等价于最小化 $\\mathbb{E}[S^2]$，因为 $\\left(\\mathbb{E}[S]\\right)^2 = \\left(\\sum_{i=1}^n m_i a_i\\right)^2$ 已由约束固定。该问题是一个线性规划：\n$$\n\\begin{aligned}\n\\text{最小化}\\quad  \\sum_{\\mathbf{o}\\in \\mathcal{C}_{n,N}} p(\\mathbf{o})\\, c(\\mathbf{o}) \\\\\n\\text{约束条件}\\quad  \\sum_{\\mathbf{o}\\in \\mathcal{C}_{n,N}} p(\\mathbf{o}) = 1, \\\\\n \\sum_{\\mathbf{o}\\in \\mathcal{C}_{n,N}} p(\\mathbf{o})\\, o_i = m_i,\\quad i=1,\\dots,n,\\\\\n p(\\mathbf{o}) \\ge 0,\\quad \\mathbf{o}\\in \\mathcal{C}_{n,N}.\n\\end{aligned}\n$$\n那么，可实现的最小方差为\n$$\n\\operatorname{Var}_{\\min}(S) = \\left( \\min_{p} \\sum_{\\mathbf{o}} p(\\mathbf{o})\\, c(\\mathbf{o}) \\right) - \\left( \\sum_{i=1}^n m_i a_i \\right)^2.\n$$\n由于目标函数相对于决策变量 $p(\\mathbf{o})$ 是线性的，且约束条件也是线性的，因此这是一个有限维线性规划问题，其可行集是概率单纯形与 $n$ 个附加仿射超平面的交集。\n\n标准方案的精确方差。对于 $S$，有几种重采样方案具有易于处理的精确方差：\n\n1. 多项式重采样：$(O_1,\\dots,O_n) \\sim \\text{Multinomial}(N; \\tilde w_1,\\dots,\\tilde w_n)$。其协方差为 $\\operatorname{Cov}(O_i,O_j) = N \\tilde w_i (\\delta_{ij} - \\tilde w_j)$。因此\n$$\n\\operatorname{Var}(S) = \\sum_{i=1}^n \\sum_{j=1}^n a_i a_j \\operatorname{Cov}(O_i,O_j) = N \\left( \\sum_{i=1}^n \\tilde w_i a_i^2 - \\left( \\sum_{i=1}^n \\tilde w_i a_i \\right)^2 \\right).\n$$\n\n2. 残差重采样：令 $f_i = \\lfloor N \\tilde w_i \\rfloor$ 为确定性部分，$R = N - \\sum_{i=1}^n f_i$ 为残差。如果 $R = 0$，则 $(O_1,\\dots,O_n)$ 是确定性的，其中 $O_i = f_i$，所以 $\\operatorname{Var}(S) = 0$。如果 $R  0$，令 $r_i = (N \\tilde w_i - f_i)/R$，并抽取残差 $(M_1,\\dots,M_n) \\sim \\text{Multinomial}(R; r_1,\\dots,r_n)$，则 $O_i = f_i + M_i$。因此，\n$$\n\\operatorname{Var}(S) = \\operatorname{Var}\\left(\\sum_{i=1}^n a_i M_i\\right) = R \\left( \\sum_{i=1}^n r_i a_i^2 - \\left( \\sum_{i=1}^n r_i a_i \\right)^2 \\right).\n$$\n\n3. 分层重采样：将 $[0,1)$ 划分为 $N$ 个层 $I_k = [k/N, (k+1)/N)$（对于 $k \\in \\{0,\\dots,N-1\\}$），独立抽取 $U_k \\sim \\text{Uniform}(I_k)$，并通过带有权重 $\\tilde w_i$ 的离散分布的逆累积分布函数来映射 $U_k$，以选择祖先。令 $C_i = \\sum_{j=1}^i \\tilde w_j$ 且 $C_0 = 0$。映射 $U \\mapsto a_{I(U)}$ 是一个分段常数阶梯函数，其中 $I(U) = \\min\\{ i: U \\le C_i \\}$。对于每个层 $I_k$，在 $a_{I(U_k)}$ 上诱导的分布是离散的，其概率为 $p_{k,i} = N \\, \\lambda\\big(I_k \\cap (C_{i-1}, C_i]\\big)$，其中 $\\lambda$ 表示勒贝格长度。因为 $U_k$ 在不同 $k$ 之间是独立的，我们有\n$$\n\\operatorname{Var}(S) = \\sum_{k=0}^{N-1} \\left( \\sum_{i=1}^n p_{k,i} a_i^2 - \\left( \\sum_{i=1}^n p_{k,i} a_i \\right)^2 \\right).\n$$\n这个表达式可以通过枚举交集 $I_k \\cap (C_{i-1}, C_i]$ 来精确计算。\n\n4. 系统重采样：抽取一个 $U \\sim \\text{Uniform}[0,1)$ 并设置 $U_k = (k+U)/N \\bmod 1$（对于 $k \\in \\{0,\\dots,N-1\\}$）。计数 $(O_1,\\dots,O_n)$ 是 $U$ 的一个确定性函数；随着 $U$ 的变化，向量 $(O_1,\\dots,O_n)$ 取有限个值，仅在某个 $U_k$ 穿过边界 $C_i$ 的断点处发生变化。在 $U \\in [0,1)$ 上，$S(U) = \\sum_{i=1}^n a_i O_i(U)$ 是一个分段常数函数，其跳跃点位于 $[0,1)$ 内形如 $U = N C_i - k$ 的点。因此，精确方差由积分\n$$\n\\operatorname{Var}(S) = \\int_0^1 \\left( S(U) - \\mathbb{E}[S] \\right)^2 \\, dU,\n$$\n给出，该积分可以通过枚举断点并将平方偏差乘以连续断点之间子区间的长度求和来精确计算。根据系统重采样的无偏性，均值为 $\\mathbb{E}[S] = N \\sum_{i=1}^n \\tilde w_i a_i$。\n\n5. 一维随机最优传输重采样：在一维情况下，对规则目标点网格进行均匀随机平移的随机最优传输与系统重采样一致。因此，对于这里考虑的一维情况，其精确方差等于系统重采样的方差。\n\n算法实现。通过枚举将 $N$ 分解为 $n$ 个部分的所有整数分解的集合 $\\mathcal{C}_{n,N}$ 来求解该线性规划问题。对于每个 $\\mathbf{o} \\in \\mathcal{C}_{n,N}$，设置成本 $c(\\mathbf{o}) = (\\sum_i o_i a_i)^2$。决策变量是概率 $p(\\mathbf{o})$。为单纯形和目标均值 $m_i = N \\tilde w_i$ 组合等式约束。使用一个现代的线性规划求解器来最小化期望成本，然后减去常数 $(\\sum_i m_i a_i)^2$ 以获得 $\\operatorname{Var}_{\\min}(S)$。\n\n对于标准重采样方案，使用上述公式计算精确方差。对于分层重采样，通过区间交集精确计算 $p_{k,i}$。对于系统重采样，枚举所有计数发生变化的断点 $U \\in [0,1)$，对它们进行排序，在子区间的中点评估 $S(U)$，并对平方偏差进行积分以获得精确方差。\n\n测试套件和输出。我们评估四个测试用例：\n- 测试用例 A：$N = 10$，$\\tilde{\\mathbf{w}} = [0.7, 0.1, 0.1, 0.1]$，$\\boldsymbol{\\phi} = [1.0, -0.5, 0.2, 2.0]$。\n- 测试用例 B：$N = 5$，$\\tilde{\\mathbf{w}} = [0.2, 0.2, 0.2, 0.2, 0.2]$，$\\boldsymbol{\\phi} = [0.0, 1.0, 2.0, 3.0, 4.0]$。\n- 测试用例 C：$N = 8$，$\\tilde{\\mathbf{w}} = [0.05, 0.05, 0.2, 0.2, 0.2, 0.3]$，$\\boldsymbol{\\phi} = [-1.2, 0.3, 0.0, 2.1, -0.7, 1.5]$。\n- 测试用例 D：$N = 2$，$\\tilde{\\mathbf{w}} = [0.6, 0.2, 0.2]$，$\\boldsymbol{\\phi} = [3.0, -1.0, 0.5]$。\n\n对于每个测试用例，程序输出六个浮点数：$\\operatorname{Var}_{\\min}(S)$、$\\operatorname{Var}_{\\text{mult}}(S)$、$\\operatorname{Var}_{\\text{res}}(S)$、$\\operatorname{Var}_{\\text{strat}}(S)$、$\\operatorname{Var}_{\\text{sys}}(S)$ 和 $\\operatorname{Var}_{\\text{OT}}(S)$。在一维设置中，如前所述，$\\operatorname{Var}_{\\text{OT}}(S) = \\operatorname{Var}_{\\text{sys}}(S)$。\n\n最终程序精确地实现了这些计算，并按要求的顺序打印一个由列表组成的单行列表，不含任何无关文本。\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport json\n\ndef normalize_weights(w):\n    w = np.asarray(w, dtype=float)\n    total = w.sum()\n    if total == 0:\n        raise ValueError(\"Weights must sum to a positive value.\")\n    return w / total\n\ndef enumerate_compositions(N, n):\n    result = []\n    def rec(idx, remaining, prefix):\n        if idx == n - 1:\n            result.append(prefix + [remaining])\n            return\n        for x in range(remaining + 1):\n            rec(idx + 1, remaining - x, prefix + [x])\n    rec(0, N, [])\n    return np.array(result, dtype=int)\n\ndef lp_min_variance(w, a, N):\n    n = len(w)\n    m = N * np.asarray(w, dtype=float)\n    a = np.asarray(a, dtype=float)\n    comps = enumerate_compositions(N, n)\n    K = comps.shape[0]\n    costs = (comps @ a) ** 2\n    A_eq = np.zeros((n + 1, K))\n    A_eq[0, :] = 1.0\n    for i in range(n):\n        A_eq[i + 1, :] = comps[:, i]\n    b_eq = np.concatenate(([1.0], m))\n    bounds = [(0.0, None)] * K\n    res = linprog(c=costs, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method=\"highs\")\n    if not res.success:\n        raise RuntimeError(f\"Linear program failed: {res.message}\")\n    expected_sq = res.fun\n    mean_S = m @ a\n    var_min = expected_sq - mean_S ** 2\n    return max(var_min, 0.0)\n\ndef var_multinomial(w, a, N):\n    w = np.asarray(w, dtype=float)\n    a = np.asarray(a, dtype=float)\n    Ew = np.dot(w, a)\n    Ew2 = np.dot(w, a * a)\n    return N * (Ew2 - Ew ** 2)\n\ndef var_residual(w, a, N):\n    w = np.asarray(w, dtype=float)\n    a = np.asarray(a, dtype=float)\n    f = np.floor(N * w).astype(int)\n    R = int(N - f.sum())\n    if R == 0:\n        return 0.0\n    r_unnormalized = (N * w - f)\n    if r_unnormalized.sum()  1e-9:\n        return 0.0\n    r = r_unnormalized / R\n    Er = np.dot(r, a)\n    Er2 = np.dot(r, a * a)\n    return R * (Er2 - Er ** 2)\n\ndef cumulative_weights(w):\n    c = np.cumsum(w)\n    c[-1] = 1.0\n    return np.concatenate(([0.0], c))\n\ndef var_stratified_exact(w, a, N):\n    w = np.asarray(w, dtype=float)\n    a = np.asarray(a, dtype=float)\n    c = cumulative_weights(w)\n    n = len(a)\n    total_var = 0.0\n    for k in range(N):\n        s_left = k / N\n        s_right = (k + 1) / N\n        probs = np.zeros(n, dtype=float)\n        for i in range(n):\n            left = max(s_left, c[i])\n            right = min(s_right, c[i + 1])\n            length = max(0.0, right - left)\n            probs[i] = length * N\n        s = probs.sum()\n        if s > 1e-9:\n            probs /= s\n        mu = np.dot(probs, a)\n        mu2 = np.dot(probs, a * a)\n        total_var += max(mu2 - mu ** 2, 0.0)\n    return total_var\n\ndef counts_systematic_given_U(w, N, U):\n    w = np.asarray(w, dtype=float)\n    c = cumulative_weights(w)\n    points = (np.arange(N) + U) / N\n    indices = np.searchsorted(c, points, side='right') - 1\n    counts = np.zeros(len(w), dtype=int)\n    np.add.at(counts, indices, 1)\n    return counts\n\ndef var_systematic_exact(w, a, N):\n    w = np.asarray(w, dtype=float)\n    a = np.asarray(a, dtype=float)\n    c = cumulative_weights(w)\n    n = len(a)\n    mean_S = N * float(np.dot(w, a))\n    \n    bps = {0.0, 1.0}\n    for i in range(1, n):\n        t = N * c[i]\n        bps.add(t - np.floor(t))\n\n    sorted_bps = sorted(list(bps))\n    unique_bps = [sorted_bps[0]]\n    for val in sorted_bps[1:]:\n        if abs(val - unique_bps[-1]) > 1e-12:\n            unique_bps.append(val)\n    \n    total_var = 0.0\n    for j in range(len(unique_bps) - 1):\n        u_left = unique_bps[j]\n        u_right = unique_bps[j + 1]\n        interval_width = u_right - u_left\n        if interval_width  1e-12:\n            continue\n        u_mid = (u_left + u_right) / 2.0\n        counts = counts_systematic_given_U(w, N, u_mid)\n        S_val = float(np.dot(counts, a))\n        total_var += (S_val - mean_S) ** 2 * interval_width\n    return max(total_var, 0.0)\n\ndef var_opt_transport_1d(w, a, N):\n    return var_systematic_exact(w, a, N)\n```", "answer": "[[0.1089, 7.781, 0.28, 0.3204, 0.1609, 0.1609], [0.0, 10.0, 0.0, 2.0, 0.0, 0.0], [0.1464, 12.8716, 0.99, 2.2285, 0.4156, 0.4156], [0.16, 3.44, 0.64, 0.64, 0.16, 0.16]]", "id": "3336443"}]}