{"hands_on_practices": [{"introduction": "要深入理解高维福尔序列 (Faure sequence)，我们必须首先掌握其最基本的构件：一维根倒函数 (radical inverse function)。这个练习 [@problem_id:3308091] 将带领你亲手计算该序列的最初几项，并直观地验证其显著的分层 (stratification) 特性。正是这种特性，构成了其低差异性质 (low-discrepancy behavior) 的基础。", "problem": "在采用低差异序列（LDS）的准蒙特卡洛（QMC）方法中，一维 Faure 序列可简化为素数基底下的根倒数函数。设基底为 $3$。对于任意非负整数 $n \\in \\mathbb{N}_{0}$，将其写为以 $a_{k} \\in \\{0,1,2\\}$ 为数位的 $3$ 进制展开式 $n = \\sum_{k=0}^{K} a_{k} 3^{k}$。$3$ 基根倒数定义为\n$$\n\\phi_{3}(n) = \\sum_{k=0}^{K} a_{k} 3^{-(k+1)}.\n$$\n这种构造是 Faure 序列一维分量的基本要素，用于在 $[0,1)$ 上生成分层样本。\n\n计算 $n=0,1,2,\\dots,9$ 时的 $\\phi_{3}(n)$。然后，仅使用 $3$ 进制数位表示和上述定义，验证对于 $m=1$ 和 $m=2$，集合 $\\{\\phi_{3}(n) : 0 \\leq n  3^{m}\\}$ 在每个区间\n$$\nI_{j,m} = \\left[\\frac{j}{3^{m}}, \\frac{j+1}{3^{m}}\\right), \\quad j = 0,1,\\dots,3^{m}-1,\n$$\n中恰好放置一个点。将区间解释为左闭右开。\n\n在您的最终答案中，将前 $10$ 个项 $\\phi_{3}(n)$ 按 $n$ 递增的顺序，使用 LaTeX 的 $\\texttt{pmatrix}$ 环境表示为单个行向量。无需四舍五入，也不涉及物理单位。", "solution": "出发点是 $3$ 基根倒数 $\\phi_{3}(n)$ 的定义，它将整数 $n$ 的 $3$ 进制数位从整数次幂映射到负数次幂，从而在 $[0,1)$ 区间内生成一个点。这种数位反转机制是 Faure 序列和 van der Corput 序列一维分量的核心构造。\n\n首先，通过将每个 $n$ 表示为 $3$ 进制来计算 $n=0,1,\\dots,9$ 时的 $\\phi_{3}(n)$：\n- 对于 $n=0$，$3$ 进制展开为 $0$，所以 $a_{0}=0$ 且\n$$\n\\phi_{3}(0) = 0.\n$$\n- 对于 $n=1$，$3$ 进制展开为 $1$，所以 $a_{0}=1$ 且\n$$\n\\phi_{3}(1) = \\frac{1}{3}.\n$$\n- 对于 $n=2$，$3$ 进制展开为 $2$，所以 $a_{0}=2$ 且\n$$\n\\phi_{3}(2) = \\frac{2}{3}.\n$$\n- 对于 $n=3$，$3$ 进制展开为 $10$，所以 $a_{0}=0, a_{1}=1$ 且\n$$\n\\phi_{3}(3) = \\frac{0}{3} + \\frac{1}{9} = \\frac{1}{9}.\n$$\n- 对于 $n=4$，$3$ 进制展开为 $11$，所以 $a_{0}=1, a_{1}=1$ 且\n$$\n\\phi_{3}(4) = \\frac{1}{3} + \\frac{1}{9} = \\frac{4}{9}.\n$$\n- 对于 $n=5$，$3$ 进制展开为 $12$，所以 $a_{0}=2, a_{1}=1$ 且\n$$\n\\phi_{3}(5) = \\frac{2}{3} + \\frac{1}{9} = \\frac{7}{9}.\n$$\n- 对于 $n=6$，$3$ 进制展开为 $20$，所以 $a_{0}=0, a_{1}=2$ 且\n$$\n\\phi_{3}(6) = \\frac{0}{3} + \\frac{2}{9} = \\frac{2}{9}.\n$$\n- 对于 $n=7$，$3$ 进制展开为 $21$，所以 $a_{0}=1, a_{1}=2$ 且\n$$\n\\phi_{3}(7) = \\frac{1}{3} + \\frac{2}{9} = \\frac{5}{9}.\n$$\n- 对于 $n=8$，$3$ 进制展开为 $22$，所以 $a_{0}=2, a_{1}=2$ 且\n$$\n\\phi_{3}(8) = \\frac{2}{3} + \\frac{2}{9} = \\frac{8}{9}.\n$$\n- 对于 $n=9$，$3$ 进制展开为 $100$，所以 $a_{0}=0, a_{1}=0, a_{2}=1$ 且\n$$\n\\phi_{3}(9) = \\frac{0}{3} + \\frac{0}{9} + \\frac{1}{27} = \\frac{1}{27}.\n$$\n\n因此，前 $10$ 个项为\n$$\n\\phi_{3}(n) = 0,\\ \\frac{1}{3},\\ \\frac{2}{3},\\ \\frac{1}{9},\\ \\frac{4}{9},\\ \\frac{7}{9},\\ \\frac{2}{9},\\ \\frac{5}{9},\\ \\frac{8}{9},\\ \\frac{1}{27}\n$$\n分别对应 $n=0,1,\\dots,9$。\n\n接下来，验证对于 $m=1$ 和 $m=2$，在长度为 $3^{-m}$ 的区间上的分层性质。考虑 $m \\in \\mathbb{N}$，且 $n$ 限制在 $0 \\leq n  3^{m}$。那么 $n$ 有一个最多使用 $m$ 个数位的 $3$ 进制展开式：\n$$\nn = \\sum_{k=0}^{m-1} a_{k} 3^{k}, \\quad a_{k} \\in \\{0,1,2\\}.\n$$\n根据 $\\phi_{3}(n)$ 的定义，\n$$\n\\phi_{3}(n) = \\sum_{k=0}^{m-1} a_{k} 3^{-(k+1)} = \\frac{1}{3^{m}} \\sum_{k=0}^{m-1} a_{k} 3^{m-1-k}.\n$$\n定义整数\n$$\nj(n) = \\sum_{k=0}^{m-1} a_{k} 3^{m-1-k}.\n$$\n由于从数位向量 $(a_{0},a_{1},\\dots,a_{m-1})$ 到 $j$ 的映射是从 $\\{0,1,2\\}^{m}$ 到 $\\{0,1,\\dots,3^{m}-1\\}$ 的一个双射（这正是标准的 $3$ 进制编码，但数位顺序相反），每一种数位的选择都会在 $\\{0,1,\\dots,3^{m}-1\\}$ 中产生一个唯一的 $j$，反之，每个这样的 $j$ 也对应一个唯一的数位向量。因此，\n$$\n\\phi_{3}(n) = \\frac{j(n)}{3^{m}},\n$$\n并且当 $n$ 遍历 $0,1,\\dots,3^{m}-1$ 时，集合 $\\{\\phi_{3}(n)\\}$ 恰好是集合 $\\left\\{\\frac{j}{3^{m}} : j = 0,1,\\dots,3^{m}-1\\right\\}$，每个值恰好出现一次。\n\n这直接意味着分层性质：对于划分为左闭右开区间的\n$$\nI_{j,m} = \\left[\\frac{j}{3^{m}}, \\frac{j+1}{3^{m}}\\right), \\quad j = 0,1,\\dots,3^{m}-1,\n$$\n每个区间 $I_{j,m}$ 包含集合 $\\{\\phi_{3}(n) : 0 \\leq n  3^{m}\\}$ 中的恰好一个点，即 $\\frac{j}{3^{m}}$ 本身。\n\n将此应用于所要求的特定情况：\n- 对于 $m=1$，集合 $\\{\\phi_{3}(n) : 0 \\leq n  3\\}$ 是 $\\{0,\\frac{1}{3},\\frac{2}{3}\\}$，区间为 $I_{0,1}=[0,\\frac{1}{3})$, $I_{1,1}=[\\frac{1}{3},\\frac{2}{3})$, $I_{2,1}=[\\frac{2}{3},1)$。在这些值中，每个区间恰好包含其左端点，因此每个区间中恰好有一个点。\n- 对于 $m=2$，集合 $\\{\\phi_{3}(n) : 0 \\leq n  9\\}$ 是 $\\left\\{\\frac{j}{9} : j=0,1,\\dots,8\\right\\}$，具体来说是 $\\{0,\\frac{1}{9},\\frac{2}{9},\\dots,\\frac{8}{9}\\}$（以某种顺序排列）。区间 $I_{j,2}=\\left[\\frac{j}{9},\\frac{j+1}{9}\\right)$ 每个都恰好包含该集合中的 $\\frac{j}{9}$，因此每个区间中恰好有一个点。\n\n因此，对于 $m=1$ 和 $m=2$，前 $3^{m}$ 个项在 $[0,1)$ 的三进剖分（区间长度为 $3^{-m}$）上是完美分层的。第十项 $\\phi_{3}(9)=\\frac{1}{27}$ 开始了对应于 $m=3$ 的下一个区块，并且与同样的数位反转原则相一致。\n\n所要求的最终报告是按 $n$ 递增顺序排列的前 $10$ 个项的行向量。", "answer": "$$\\boxed{\\begin{pmatrix}\n0  \\frac{1}{3}  \\frac{2}{3}  \\frac{1}{9}  \\frac{4}{9}  \\frac{7}{9}  \\frac{2}{9}  \\frac{5}{9}  \\frac{8}{9}  \\frac{1}{27}\n\\end{pmatrix}}$$", "id": "3308091"}, {"introduction": "在一维情形的基础上，本实践 [@problem_id:3308024] 将指导你完成一个多维福尔序列的完整构建过程。这涉及到在有限域上使用帕斯卡矩阵 (Pascal matrix)，它是序列结构背后的代数引擎。通过证明该序列构成一个 $(t,m,s)$-net，你将能验证其卓越的均匀性，这是确保点集尽可能均匀分布的准蒙特卡洛 (quasi-Monte Carlo) 理论的基石。", "problem": "考虑在准蒙特卡罗 (QMC) 方法中使用的低差异序列的数字构造。设基数为 $b=3$ （一个素数），并考虑空间维度 $s=3$ 的 Faure 序列。在阶为 $3$ 的有限域 (FF) 上进行计算，记为 $\\mathbb{F}_{3}$。\n\n使用以下基本定义和事实：\n\n- 基数为 $b$ 的数字序列是通过将 $\\mathbb{F}_{b}$ 上的生成矩阵应用于非负整数索引 $n$ 的 $b$ 基数位向量来定义的。设 $n=\\sum_{k=0}^{\\infty} a_{k} b^{k}$，其中各位数字 $a_{k} \\in \\{0,1,\\dots,b-1\\}$，并将前 $m$ 位数字收集到列向量 $\\boldsymbol{a}=(a_{0},a_{1},\\dots,a_{m-1})^{\\top}$ 中。坐标 $j$ 的数字向量 $\\boldsymbol{y}^{(j)}=(y^{(j)}_{1},\\dots,y^{(j)}_{m})^{\\top}$ 是通过在 $\\mathbb{F}_{b}$ 上计算 $\\boldsymbol{y}^{(j)}=C_{j}\\,\\boldsymbol{a}$ 得到的，其中 $C_{j}$ 是一个下三角生成矩阵。在 $[0,1)$ 中对应的坐标是 $x^{(j)}(n)=\\sum_{r=1}^{m} y^{(j)}_{r}\\,b^{-r}$。\n- 在 $b$ 为素数且 $s \\leq b$ 的 Faure 构造中，矩阵 $C_{j}$ 是帕斯卡矩阵模 $b$ 的幂。设 $P$ 为下三角帕斯卡矩阵，其元素为 $p_{r,k} \\equiv \\binom{k-1}{r-1} \\bmod b$ (对于 $1 \\leq r \\leq k \\leq m$)，且当 $rk$ 时 $p_{r,k}=0$。那么对于 $j=1,2,\\dots,s$，有 $C_{j}=P^{j-1}$。\n\n取 $m=3$ 位数字。执行以下任务：\n\n1. 为 $m=3$ 的情况，在 $\\mathbb{F}_{3}$ 上显式构造矩阵 $P$、$P^{2}$，并由此构造 $C_{1}$、$C_{2}$、$C_{3}$。\n2. 使用这些 $C_{j}$，推导坐标 $x^{(1)}(n)$、$x^{(2)}(n)$、$x^{(3)}(n)$ 关于 $n$ 的基数-3 数字 $(a_{0},a_{1},a_{2})$ 的三位数公式，其中 $n=0,1,\\dots,26$ (即，对于所有 $\\boldsymbol{a} \\in \\mathbb{F}_{3}^{3}$)。\n3. 考虑在分辨率 $m=3$ 且各位数字深度相等 $d_{1}=d_{2}=d_{3}=1$ 的情况下，$[0,1)^{3}$ 中的 $3$-adic 基本盒的集合。这些是形如 $\\prod_{j=1}^{3} \\left[\\frac{t_{j}}{3},\\frac{t_{j}+1}{3}\\right)$ 的 $3^{3}$ 个盒子，其中 $(t_{1},t_{2},t_{3}) \\in \\{0,1,2\\}^{3}$。仅使用上述形式化定义，确定 Faure 序列的前 $b^{m}=27$ 个点在这 $3^{3}$ 个盒子中的占据数。\n4. 定义用于检验这 $3^{3}$ 个盒子中均匀占据情况的多项卡方统计量为\n$$\n\\chi^{2} \\;=\\; \\sum_{i=1}^{27} \\frac{(O_{i}-E_{i})^{2}}{E_{i}},\n$$\n其中 $O_{i}$ 是盒子 $i$ 中的观测计数，$E_{i}$ 是在完全均匀性下的期望计数。为上面构造的 $27$ 个点计算 $\\chi^{2}$。将最终答案表示为单个实数值。无需四舍五入，不涉及物理单位。", "solution": "该问题要求对基数为 $b=3$、维度为 $s=3$、使用 $m=3$ 位数字的 Faure 序列进行多部分分析。分析内容包括构造生成矩阵、推导坐标公式、确定点在基本盒中的分布，以及计算卡方统计量。所有计算都在有限域 $\\mathbb{F}_{3}$ 上进行。\n\n首先，对给定条件进行验证。问题陈述是自洽的，科学上基于准蒙特卡罗方法的理论，并且是适定的。所有定义和参数 ($b=3$, $s=3$, $m=3$) 都已指定且一致。任务是顺序的，并导向一个唯一的、可验证的解。因此，该问题是有效的。\n\n**第1部分：生成矩阵的构造**\n\nFaure 序列的生成矩阵由 $C_{j} = P^{j-1}$ 给出，其中 $j=1, 2, \\dots, s$。这里，$s=3$，所以我们需要 $C_{1}$、$C_{2}$ 和 $C_{3}$。这需要在 $\\mathbb{F}_{3}$ 上计算 $m \\times m = 3 \\times 3$ 的帕斯卡矩阵 $P$ 及其平方 $P^{2}$。\n\n下三角帕斯卡矩阵 $P$ 的元素由 $p_{r,k} \\equiv \\binom{k-1}{r-1} \\pmod b$ 给出，其中 $1 \\le r \\le k \\le m$。当 $b=3$ 和 $m=3$ 时，元素计算如下 (全部对 $3$ 取模)：\n$p_{1,1} = \\binom{1-1}{1-1} = \\binom{0}{0} = 1$\n$p_{1,2} = \\binom{2-1}{1-1} = \\binom{1}{0} = 1$\n$p_{2,2} = \\binom{2-1}{2-1} = \\binom{1}{1} = 1$\n$p_{1,3} = \\binom{3-1}{1-1} = \\binom{2}{0} = 1$\n$p_{2,3} = \\binom{3-1}{2-1} = \\binom{2}{1} = 2$\n$p_{3,3} = \\binom{3-1}{3-1} = \\binom{2}{2} = 1$\n所有其他 $rk$ 的元素 $p_{r,k}$ 均为 $0$。这给出了矩阵：\n$$ P = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} $$\n接下来，我们在 $\\mathbb{F}_{3}$ 上计算 $P^{2}$：\n$$ P^{2} = P \\cdot P = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} $$\n$$ = \\begin{pmatrix} 1 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 0  1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 0  1 \\cdot 1 + 1 \\cdot 2 + 1 \\cdot 1 \\\\ 0 \\cdot 1 + 1 \\cdot 0 + 2 \\cdot 0  0 \\cdot 1 + 1 \\cdot 1 + 2 \\cdot 0  0 \\cdot 1 + 1 \\cdot 2 + 2 \\cdot 1 \\\\ 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0  0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 0  0 \\cdot 1 + 0 \\cdot 2 + 1 \\cdot 1 \\end{pmatrix} \\pmod 3 $$\n$$ = \\begin{pmatrix} 1  2  4 \\\\ 0  1  4 \\\\ 0  0  1 \\end{pmatrix} \\pmod 3 = \\begin{pmatrix} 1  2  1 \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix} $$\n对于 $j=1, 2, 3$ 的生成矩阵 $C_{j}$ 是：\n$C_{1} = P^{1-1} = P^{0} = I = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$\n$C_{2} = P^{2-1} = P^{1} = P = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix}$\n$C_{3} = P^{3-1} = P^{2} = \\begin{pmatrix} 1  2  1 \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix}$\n\n**第2部分：坐标公式**\n\n坐标 $j$ 的数字向量 $\\boldsymbol{y}^{(j)} = (y_1^{(j)}, y_2^{(j)}, y_3^{(j)})^{\\top}$ 是通过将 $C_j$ 应用于索引 $n = a_0 + 3a_1 + 9a_2$ 的基数-3 数字向量 $\\boldsymbol{a} = (a_0, a_1, a_2)^{\\top}$ 来找到的。坐标值为 $x^{(j)}(n) = \\sum_{r=1}^{3} y_r^{(j)} 3^{-r}$。“三位数公式”是关于 $a_0, a_1, a_2$ 的数字 $y_r^{(j)}$ 的表达式。\n\n对于坐标 $j=1$：\n$\\boldsymbol{y}^{(1)} = C_1 \\boldsymbol{a} = I \\boldsymbol{a} = \\boldsymbol{a}$。\n$y_1^{(1)} = a_0$\n$y_2^{(1)} = a_1$\n$y_3^{(1)} = a_2$\n\n对于坐标 $j=2$：\n$\\boldsymbol{y}^{(2)} = C_2 \\boldsymbol{a} = P \\boldsymbol{a}$。\n$$ \\begin{pmatrix} y_1^{(2)} \\\\ y_2^{(2)} \\\\ y_3^{(2)} \\end{pmatrix} = \\begin{pmatrix} 1  1  1 \\\\ 0  1  2 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} a_0 + a_1 + a_2 \\\\ a_1 + 2a_2 \\\\ a_2 \\end{pmatrix} \\pmod 3 $$\n\n对于坐标 $j=3$：\n$\\boldsymbol{y}^{(3)} = C_3 \\boldsymbol{a} = P^2 \\boldsymbol{a}$。\n$$ \\begin{pmatrix} y_1^{(3)} \\\\ y_2^{(3)} \\\\ y_3^{(3)} \\end{pmatrix} = \\begin{pmatrix} 1  2  1 \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} a_0 + 2a_1 + a_2 \\\\ a_1 + a_2 \\\\ a_2 \\end{pmatrix} \\pmod 3 $$\n\n**第3部分：占据数**\n\n我们考虑形如 $B_{t_1, t_2, t_3} = \\prod_{j=1}^{3} \\left[\\frac{t_{j}}{3},\\frac{t_{j}+1}{3}\\right)$ 的 $3^3 = 27$ 个基本盒，其中 $(t_1, t_2, t_3) \\in \\{0,1,2\\}^3$。\n一个点 $\\boldsymbol{x}(n) = (x^{(1)}(n), x^{(2)}(n), x^{(3)}(n))$ 位于盒子 $B_{t_1, t_2, t_3}$ 中，当且仅当对于每个 $j \\in \\{1,2,3\\}$ 都有 $\\lfloor 3x^{(j)}(n) \\rfloor = t_j$。\n根据公式 $x^{(j)}(n) = \\frac{y_1^{(j)}}{3} + \\frac{y_2^{(j)}}{9} + \\frac{y_3^{(j)}}{27}$，我们有 $3x^{(j)}(n) = y_1^{(j)} + \\frac{y_2^{(j)}}{3} + \\frac{y_3^{(j)}}{9}$。由于 $y_r^{(j)} \\in \\{0, 1, 2\\}$，小数部分总是小于 $1$，所以 $\\lfloor 3x^{(j)}(n) \\rfloor = y_1^{(j)}$。\n因此，一个点 $\\boldsymbol{x}(n)$ 在盒子 $B_{t_1, t_2, t_3}$ 中，当且仅当其第一位数字的向量 $(y_1^{(1)}, y_1^{(2)}, y_1^{(3)})$ 等于 $(t_1, t_2, t_3)$。\n\n使用第2部分的公式，这个条件可以转化为关于输入数字 $(a_0, a_1, a_2)$ 在 $\\mathbb{F}_3$ 上的线性方程组：\n$$ y_1^{(1)} = a_0 = t_1 $$\n$$ y_1^{(2)} = a_0 + a_1 + a_2 = t_2 $$\n$$ y_1^{(3)} = a_0 + 2a_1 + a_2 = t_3 $$\n这可以写成矩阵形式 $M \\boldsymbol{a} = \\boldsymbol{t}$：\n$$ \\begin{pmatrix} 1  0  0 \\\\ 1  1  1 \\\\ 1  2  1 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} t_1 \\\\ t_2 \\\\ t_3 \\end{pmatrix} $$\n给定盒子中的点的数量对应于相应 $\\boldsymbol{t} \\in \\mathbb{F}_3^3$ 的解 $\\boldsymbol{a} \\in \\mathbb{F}_3^3$ 的数量。序列的前 $27$ 个点对应于 $n=0, 1, \\dots, 26$，这恰好遍历了 $\\mathbb{F}_3^3$ 中所有可能的向量 $\\boldsymbol{a} = (a_0, a_1, a_2)^\\top$ 一次。\n为了找到解的数量，我们通过计算其在 $\\mathbb{F}_3$ 中的行列式来检查矩阵 $M$ 是否可逆：\n$$ \\det(M) = 1 \\cdot \\det\\begin{pmatrix} 1  1 \\\\ 2  1 \\end{pmatrix} - 0 + 0 = 1(1 \\cdot 1 - 1 \\cdot 2) = 1 - 2 = -1 \\equiv 2 \\pmod 3 $$\n由于在 $\\mathbb{F}_3$ 中 $\\det(M) = 2 \\neq 0$，矩阵 $M$ 是可逆的。这意味着对于每个目标向量 $\\boldsymbol{t} = (t_1, t_2, t_3) \\in \\mathbb{F}_3^3$，都存在一个唯一的解向量 $\\boldsymbol{a} = (a_0, a_1, a_2) \\in \\mathbb{F}_3^3$。\n因此，$27$ 个盒子中的每一个都恰好包含序列前 $27$ 个点中的一个点。每个盒子 $i$ 的占据数 $O_i$ 为 $1$。\n\n**第4部分：卡方统计量计算**\n\n多项卡方统计量由 $\\chi^{2} = \\sum_{i=1}^{27} \\frac{(O_{i}-E_{i})^{2}}{E_{i}}$ 给出。\n我们有 $N=27$ 个点分布在 $K=27$ 个盒子中。\n如第3部分所确定的，观测计数对于所有 $i=1, \\dots, 27$ 都是 $O_i = 1$。\n在完全均匀性假设下的期望计数对于所有 $i=1, \\dots, 27$ 都是 $E_i = N/K = 27/27 = 1$。\n将这些值代入公式：\n$$ \\chi^{2} = \\sum_{i=1}^{27} \\frac{(1-1)^{2}}{1} = \\sum_{i=1}^{27} \\frac{0^2}{1} = \\sum_{i=1}^{27} 0 = 0 $$\n卡方统计量为 $0$，这表示前 $27$ 个 Faure 点的观测分布与 $27$ 个基本盒上的均匀分布完全一致。这是被称为 $(t,m,s)$-网的低差异序列的一个特征。", "answer": "$$\\boxed{0}$$", "id": "3308024"}, {"introduction": "尽管福尔序列展现出极佳的均匀性，其在实际应用中的表现也可能受到不同坐标之间统计依赖性的影响。这个高级计算练习 [@problem_id:3308033] 将超越基本性质，深入分析这种维度间的结构。通过编写一个生成器，并将经验相关性 (empirical correlation) 与一个线性代理模型 (linear surrogate model) 进行比较，你将洞察其代数构造（帕斯卡矩阵的幂）如何转化为最终点集中的几何模式和依赖关系。", "problem": "要求您实现并分析一个Faure点生成器，并量化所选坐标对之间的经验互相关。分析必须基于第一性原理，并且必须明确阐述观察到的相关结构与Faure生成器中使用的Pascal矩阵的代数幂之间的联系。该设定是纯数学的，并使用一个有限、完备的点集，因此在均匀枚举下，经验平均值与总体平均值一致。\n\n定义与基本原理：\n- 设$b$为一个素数，$m$为一个正整数。设$N = b^m$。每个整数$n \\in \\{0,1,\\dots,N-1\\}$都有一个唯一的$m$位$b$进制表示，$n = \\sum_{k=0}^{m-1} a_k b^k$，其中每个$a_k \\in \\{0,1,\\dots,b-1\\}$。\n- 定义以$b$为基数的根倒置映射为$\\varphi_b(a_0,a_1,\\dots,a_{m-1}) = \\sum_{k=0}^{m-1} a_k b^{-(k+1)}$。\n- 定义$m \\times m$的Pascal矩阵$P$，$P_{ij} = \\binom{j}{i}$（对于$0 \\le i \\le j \\le m-1$）以及$P_{ij} = 0$（对于$i  j$）。考虑在素数$b$下的模运算，使得矩阵元素在$\\mathbb{Z}_b$中进行化简，并且$P$的幂次也在模$b$下计算。\n- $d$维（$d \\in \\{1,2,\\dots\\}$）Faure序列由以下变换定义：给定以$b$为基数的数字向量$a = (a_0,a_1,\\dots,a_{m-1})^\\top$，计算$c^{(d)} \\equiv P^{d-1} a \\pmod{b}$，其中指数表示重复矩阵乘法，其元素在模$b$下进行化简。Faure点的第$d$个坐标则是$x^{(d)} = \\sum_{k=0}^{m-1} c^{(d)}_k b^{-(k+1)} = \\varphi_b(c^{(d)}_0,\\dots,c^{(d)}_{m-1})$。\n\n经验互相关：\n- 对于一对维度$(d_1,d_2)$，定义序列$\\{x^{(d_1)}(n)\\}_{n=0}^{N-1}$和$\\{x^{(d_2)}(n)\\}_{n=0}^{N-1}$之间的经验皮尔逊相关系数为\n$$\n\\rho_{\\mathrm{emp}}(d_1,d_2) = \\frac{\\sum_{n=0}^{N-1} \\left(x^{(d_1)}(n) - \\overline{x^{(d_1)}}\\right)\\left(x^{(d_2)}(n) - \\overline{x^{(d_2)}}\\right)}{\\sqrt{\\sum_{n=0}^{N-1} \\left(x^{(d_1)}(n) - \\overline{x^{(d_1)}}\\right)^2}\\sqrt{\\sum_{n=0}^{N-1} \\left(x^{(d_2)}(n) - \\overline{x^{(d_2)}}\\right)^2}},\n$$\n其中$\\overline{x^{(d)}} = \\frac{1}{N}\\sum_{n=0}^{N-1} x^{(d)}(n)$。\n\n通过线性代理关联到Pascal矩阵的幂：\n- 设$L = P^{\\Delta}$，其中$\\Delta = d_2 - d_1$，在整数上计算（不进行模$b$的化简），并设$L_{\\mathrm{mod}} \\equiv P^{\\Delta} \\pmod{b}$。对于每个$n$，数字向量$c^{(d_1)}(n)$在模$b$下计算。通过$\\widetilde{c}^{(d_2)}(n) = L \\, c^{(d_1)}(n)$为第$d_2$维的数字定义一个线性代理，其中乘法在整数上执行，此阶段不应用模$b$的化简。然后定义代理坐标$\\widetilde{x}^{(d_2)}(n) = \\sum_{k=0}^{m-1} \\widetilde{c}^{(d_2)}_k(n) b^{-(k+1)}$和代理相关性\n$$\n\\rho_{\\mathrm{sur}}(d_1,d_2) = \\frac{\\sum_{n=0}^{N-1} \\left(x^{(d_1)}(n) - \\overline{x^{(d_1)}}\\right)\\left(\\widetilde{x}^{(d_2)}(n) - \\overline{\\widetilde{x}^{(d_2)}}\\right)}{\\sqrt{\\sum_{n=0}^{N-1} \\left(x^{(d_1)}(n) - \\overline{x^{(d_1)}}\\right)^2}\\sqrt{\\sum_{n=0}^{N-1} \\left(\\widetilde{x}^{(d_2)}(n) - \\overline{\\widetilde{x}^{(d_2)}}\\right)^2}}.\n$$\n同时计算$L_{\\mathrm{mod}}$的弗罗贝尼乌斯范数$\\|L_{\\mathrm{mod}}\\|_F = \\sqrt{\\sum_{i,j} (L_{\\mathrm{mod}})_{ij}^2}$，作为由Pascal矩阵的幂在模$b$下引起的数字空间中混合强度的标量摘要。\n\n您的任务：\n- 实现一个程序，使用上述定义为指定参数构建Faure点，为每个测试用例计算$\\rho_{\\mathrm{emp}}(d_1,d_2)$，使用线性代理计算$\\rho_{\\mathrm{sur}}(d_1,d_2)$，并计算相应$L_{\\mathrm{mod}}$的$\\|L_{\\mathrm{mod}}\\|_F$。\n- 使用对$n \\in \\{0,1,\\dots,N-1\\}$（其中$N = b^m$）的精确枚举，无随机性。\n- 每个测试用例的最终输出必须是包含三个浮点数的列表$[\\rho_{\\mathrm{emp}}, \\rho_{\\mathrm{sur}}, \\|L_{\\mathrm{mod}}\\|_F]$。\n\n测试套件：\n- 情况1: $b=3$, $m=4$, $(d_1,d_2)=(1,2)$。\n- 情况2: $b=3$, $m=4$, $(d_1,d_2)=(1,3)$。\n- 情况3: $b=5$, $m=3$, $(d_1,d_2)=(2,4)$。\n- 情况4: $b=5$, $m=1$, $(d_1,d_2)=(1,3)$。\n- 情况5: $b=7$, $m=2$, $(d_1,d_2)=(3,5)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素本身是一个包含三个浮点数的列表，顺序为$[\\rho_{\\mathrm{emp}}, \\rho_{\\mathrm{sur}}, \\|L_{\\mathrm{mod}}\\|_F]$，对应五个测试用例，例如$[[r_{11},r_{12},r_{13}],[r_{21},r_{22},r_{23}],\\dots]$。", "solution": "该问题是有效的，因为它在数学上是良定义的、自洽的，并且基于成熟的拟蒙特卡洛方法理论，特别是Faure序列。它提出了一个清晰的计算任务，没有任何科学或逻辑上的矛盾。\n\n解决方案涉及实现一个Faure序列生成器，然后按规定执行相关性分析。每个测试用例$(b, m, d_1, d_2)$的处理过程遵循一个结构化的、基于原理的方法。\n\n**1. Faure序列的基本原理**\n\nFaure序列是一种用于数值积分和模拟的低差异序列。其构造依赖于三个核心概念：\n\n- **$b$进制表示法：** 该序列由整数$n \\in \\{0, 1, \\dots, N-1\\}$索引，其中$N=b^m$，b为素数基数，m为数字位数。每个整数$n$都有一个唯一的$b$进制表示$n = \\sum_{k=0}^{m-1} a_k b^k$，从而得到一个数字向量$a(n) = (a_0, a_1, \\dots, a_{m-1})^\\top$。\n\n- **通过Pascal矩阵进行数字置乱：** Faure序列低差异特性的关键在于对这些数字进行置乱。对于每个维度$d \\ge 1$，生成矩阵$C^{(d)}$被定义为下三角Pascal矩阵$P$的$(d-1)$次幂，所有算术运算都在模$b$下进行。大小为$m \\times m$的Pascal矩阵$P$的元素为$P_{ij} = \\binom{j}{i}$（对于$i \\le j$）。因此，$C^{(d)} \\equiv P^{d-1} \\pmod{b}$。第$n$个点的第$d$个坐标的数字向量$c^{(d)}(n)$是通过变换索引$n$的数字向量$a(n)$得到的：\n$$\nc^{(d)}(n) \\equiv C^{(d)} a(n) \\pmod{b}\n$$\n\n- **根倒置函数：** 然后，使用根倒置函数$\\varphi_b$将置乱后的数字映射到单位区间$[0, 1)$中的一个点。该函数将数字向量解释为$b$进制数的小数部分：\n$$\nx^{(d)}(n) = \\varphi_b(c^{(d)}_0(n), \\dots, c^{(d)}_{m-1}(n)) = \\sum_{k=0}^{m-1} c^{(d)}_k(n) b^{-(k+1)}\n$$\n对于第一维($d=1$)，$C^{(1)} = P^0 = I$（单位矩阵），所以$c^{(1)}(n) = a(n)$。这意味着Faure序列的第一维就是以$b$为基数的van der Corput序列。\n\n**2. 算法实现与分析**\n\n实现过程首先生成所需的点集，然后计算指定的统计量。\n\n**步骤2.1：序列生成**\n对于给定的维度对$(d_1, d_2)$，我们需要生成序列$\\{x^{(d_1)}(n)\\}_{n=0}^{N-1}$和$\\{x^{(d_2)}(n)\\}_{n=0}^{N-1}$。它们各自的数字向量为$c^{(d_1)}(n) \\equiv P^{d_1-1} a(n) \\pmod{b}$和$c^{(d_2)}(n) \\equiv P^{d_2-1} a(n) \\pmod{b}$。一个关键的简化来自矩阵指数运算的性质：\n$$\nc^{(d_2)}(n) \\equiv P^{d_2-1} a(n) \\equiv P^{d_2-d_1} P^{d_1-1} a(n) \\pmod{b}\n$$\n令$\\Delta = d_2 - d_1$且$L_{\\mathrm{mod}} \\equiv P^{\\Delta} \\pmod b$，我们得到高效的递归关系：\n$$\nc^{(d_2)}(n) \\equiv L_{\\mathrm{mod}} c^{(d_1)}(n) \\pmod{b}\n$$\n算法遍历$n \\in \\{0, \\dots, N-1\\}$，计算$b$进制数字$a(n)$，然后计算$c^{(d_1)}(n)$，并由此计算$c^{(d_2)}(n)$。最后，应用根倒置函数$\\varphi_b$获得点坐标$x^{(d_1)}(n)$和$x^{(d_2)}(n)$。\n\n**步骤2.2：经验相关性 $\\rho_{\\mathrm{emp}}$**\n一旦生成了完整的序列$X_{d_1} = \\{x^{(d_1)}(n)\\}$和$X_{d_2} = \\{x^{(d_2)}(n)\\}$，就计算经验皮尔逊相关系数$\\rho_{\\mathrm{emp}}(d_1, d_2)$。这衡量了两组坐标之间的线性关联。由于问题指定使用$N$个点的完整有限集，经验公式给出了精确的总体相关性。\n\n**步骤2.3：代理模型与相关性 $\\rho_{\\mathrm{sur}}$**\n引入代理模型是为了通过线性化数字向量之间的变换来分析相关结构。真实的变换$c^{(d_2)}(n) \\equiv L_{\\mathrm{mod}} c^{(d_1)}(n) \\pmod{b}$涉及两个非线性部分：模$b$的矩阵乘法和最后的逐元素模$b$运算。代理模型分离了底层线性变换的影响。它使用整数矩阵$L = P^{\\Delta}$（无模运算化简）定义了一个代理数字向量$\\widetilde{c}^{(d_2)}(n)$：\n$$\n\\widetilde{c}^{(d_2)}(n) = L \\, c^{(d_1)}(n)\n$$\n现在$\\widetilde{c}^{(d_2)}(n)$的分量是可能大于$b-1$的整数。然后使用根倒置函数对这些整数字计算代理坐标$\\widetilde{x}^{(d_2)}(n)$。代理相关性$\\rho_{\\mathrm{sur}}(d_1, d_2)$是序列$\\{x^{(d_1)}(n)\\}$和$\\{\\widetilde{x}^{(d_2)}(n)\\}$之间的皮尔逊系数。这个量有助于理解相关结构在多大程度上是由生成器的线性混合部分解释的，而不是由模运算的非线性“环绕”效应解释的。\n\n**步骤2.4：弗罗贝尼乌斯范数 $\\|L_{\\mathrm{mod}}\\|_F$**\n置乱矩阵$L_{\\mathrm{mod}} \\equiv P^{\\Delta} \\pmod b$的弗罗贝尼乌斯范数计算为$\\|L_{\\mathrm{mod}}\\|_F = \\sqrt{\\sum_{i,j} (L_{\\mathrm{mod}})_{ij}^2}$。这提供了对维度$d_1$和$d_2$之间数字置乱变换“强度”的单一标量度量。范数越大，意味着数字值的 shuffling 越显著。\n\n最终的程序为每个测试用例实现这些步骤，利用数值库进行稳健的矩阵运算和统计计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It generates Faure points, computes empirical and surrogate correlations,\n    and the Frobenius norm of the generator matrix.\n    \"\"\"\n\n    # Helper function for modular matrix exponentiation (exponentiation by squaring)\n    def matrix_power_mod(A, exp, mod):\n        size = A.shape[0]\n        if exp == 0:\n            return np.identity(size, dtype=np.int64)\n        if exp  0: # Not needed for this problem, but good practice\n            raise ValueError(\"Exponent must be non-negative\")\n        \n        # Ensure input matrix is already mod b, though not strictly necessary\n        base = A.copy() % mod\n        res = np.identity(size, dtype=np.int64)\n        \n        while exp > 0:\n            if exp % 2 == 1:\n                res = (res @ base) % mod\n            base = (base @ base) % mod\n            exp //= 2\n        return res\n\n    # Helper function to get base-b digits of n\n    def get_digits(n, b, m):\n        digits = np.zeros(m, dtype=np.int64)\n        temp_n = n\n        for k in range(m):\n            digits[k] = temp_n % b\n            temp_n //= b\n        return digits\n\n    # Helper function for the radical-inverse map\n    def radical_inverse(digits, b):\n        val = 0.0\n        # Use a single division at the end for better precision\n        b_powers = np.power(float(b), np.arange(1, len(digits) + 1, dtype=np.float64))\n        val = np.sum(digits / b_powers)\n        return val\n\n    # Helper function to construct the Pascal matrix\n    def get_pascal_matrix(m):\n        P = np.zeros((m, m), dtype=np.int64)\n        for j in range(m):\n            for i in range(j + 1):\n                P[i, j] = comb(j, i, exact=True)\n        return P\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (3, 4, 1, 2), # Case 1\n        (3, 4, 1, 3), # Case 2\n        (5, 3, 2, 4), # Case 3\n        (5, 1, 1, 3), # Case 4\n        (7, 2, 3, 5), # Case 5\n    ]\n\n    results = []\n    for b, m, d1, d2 in test_cases:\n        N = b**m\n        \n        # 1. Construct matrices\n        P_int = get_pascal_matrix(m)\n        \n        # Generator for dimension d1\n        C1_mod = matrix_power_mod(P_int, d1 - 1, b)\n        \n        # Transformation matrices from d1 to d2\n        Delta = d2 - d1\n        L_int = np.linalg.matrix_power(P_int, Delta)\n        L_mod = matrix_power_mod(P_int, Delta, b)\n\n        # 2. Generate point sets\n        x_d1_pts = np.zeros(N, dtype=np.float64)\n        x_d2_pts = np.zeros(N, dtype=np.float64)\n        x_d2_sur_pts = np.zeros(N, dtype=np.float64)\n        \n        for n in range(N):\n            a_n = get_digits(n, b, m)\n            \n            c_d1 = (C1_mod @ a_n) % b\n            c_d2 = (L_mod @ c_d1) % b\n            c_d2_sur = L_int @ c_d1\n            \n            x_d1_pts[n] = radical_inverse(c_d1, b)\n            x_d2_pts[n] = radical_inverse(c_d2, b)\n            x_d2_sur_pts[n] = radical_inverse(c_d2_sur, b)\n            \n        # 3. Compute correlations\n        # np.corrcoef returns a 2x2 matrix, we need the off-diagonal element\n        # Check for zero variance to avoid NaN, although not expected for Faure seq.\n        if np.std(x_d1_pts) == 0 or np.std(x_d2_pts) == 0:\n            rho_emp = 1.0 if np.std(x_d1_pts) == np.std(x_d2_pts) else 0.0\n        else:\n            rho_emp = np.corrcoef(x_d1_pts, x_d2_pts)[0, 1]\n\n        if np.std(x_d1_pts) == 0 or np.std(x_d2_sur_pts) == 0:\n            rho_sur = 1.0 if np.std(x_d1_pts) == np.std(x_d2_sur_pts) else 0.0\n        else:\n            rho_sur = np.corrcoef(x_d1_pts, x_d2_sur_pts)[0, 1]\n            \n        # 4. Compute Frobenius norm\n        norm_L_mod_F = np.linalg.norm(L_mod, 'fro')\n        \n        results.append([rho_emp, rho_sur, norm_L_mod_F])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3308033"}]}