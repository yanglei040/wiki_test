{"hands_on_practices": [{"introduction": "理论的正确性最终需要通过实验来验证。在数值模拟领域，确保我们编写的代码准确反映其底层数学原理至关重要。本实践旨在通过经验性地测量两种基本数值格式——欧拉-丸山（Euler-Maruyama）法和米尔斯坦（Milstein）法的强收敛阶，来巩固您对随机微分方程（SDE）数值解的理解。您将通过蒙特卡洛模拟，针对具有不同噪声结构的SDE，动手验证欧拉-丸山格式的 $0.5$ 阶和米尔斯坦格式的 $1.0$ 阶强收敛性 [@problem_id:3339961]，从而深入体会理论与实践的联系。", "problem": "考虑一个形式为 $dX_t = a(X_t)\\,dt + b(X_t)\\,dW_t$ 的一维伊藤随机微分方程（SDE），其初始条件为 $X_0 = x_0$，其中 $W_t$ 是标准布朗运动，$a(\\cdot)$ 和 $b(\\cdot)$ 是充分光滑的函数。强收敛阶量化了路径近似误差如何随时间步长的减小而减小。在本任务中，您将实现蒙特卡洛估计量，以凭经验测量两种广泛使用的数值格式在终端时刻 $T$ 的强收敛阶：欧拉-丸山（EM）方法和米尔斯坦（Milstein）方法。您必须使用嵌套布朗增量来耦合不同的时间步长，确保路径比较的一致性。\n\n从以下基本概念开始：\n- 一维伊藤SDE的定义：$dX_t = a(X_t)\\,dt + b(X_t)\\,dW_t$，其中 $X_0 = x_0$，$W_t$ 是标准布朗运动。\n- 终端时刻 $T$ 的强误差概念，即量 $\\mathbb{E}\\left[\\,|\\,X_T - X_T^{(h)}\\,|\\,\\right]$，其中 $X_T$ 是精确解，$X_T^{(h)}$ 是时间步长为 $h$ 的数值近似解。\n- 理解SDE的数值格式可以从伊藤-泰勒展开导出，并且其截断产生了涉及 $a(\\cdot)$、$b(\\cdot)$ 和布朗增量的离散时间更新规则。\n\n您的程序必须：\n- 使用蒙特卡洛采样和固定的随机种子以确保可复现性。\n- 在 $[0,T]$ 上构建一个具有 $N_{\\text{fine}}$ 个步长的最精细网格，并生成方差为 $T/N_{\\text{fine}}$ 的独立同分布正态增量。对于每个具有 $N$ 个步长的更粗糙网格，通过对精细网格增量的连续块求和来获得其布朗增量。这保证了在不同离散化中使用相同的底层布朗路径。\n- 对于每种格式（欧拉-丸山和米尔斯坦）和每个测试案例，计算几个步长 $h = T/N$ 下终端时刻的平均绝对强误差，然后通过对 $\\log\\big(\\text{error}(h)\\big)$ 与 $\\log(h)$ 进行线性回归的斜率来估计经验强收敛阶 $p$。\n\n使用以下三个测试案例，每个案例都科学一致并涵盖不同情况：\n- 测试案例1（几何布朗运动）：$dX_t = \\mu X_t\\,dt + \\sigma X_t\\,dW_t$，其中 $x_0 = 1.0$，$T = 1.0$，$\\mu = 0.3$，$\\sigma = 0.6$。精确的终端值已知：$X_T = x_0 \\exp\\big((\\mu - \\tfrac{1}{2}\\sigma^2)T + \\sigma W_T\\big)$，其中 $W_T$ 是终端布朗值。\n- 测试案例2（奥恩斯坦-乌伦贝克型，带加性噪声）：$dX_t = \\alpha X_t\\,dt + \\beta\\,dW_t$，其中 $x_0 = 1.0$，$T = 1.0$，$\\alpha = -1.5$，$\\beta = 0.5$。不使用精确的终端值；相反，对于每种格式，使用在非常精细的时间步长下采用相同格式的路径作为参考路径来计算强误差。\n- 测试案例3（确定性极限）：$dX_t = \\alpha X_t\\,dt$，其中 $x_0 = 1.2$，$T = 1.0$，$\\alpha = 0.8$。这里 $b(\\cdot)\\equiv 0$，精确的终端值为 $X_T = x_0 e^{\\alpha T}$。\n\n蒙特卡洛和离散化参数：\n- 蒙特卡洛路径数 $M = 10000$。\n- 最精细网格尺寸 $N_{\\text{fine}} = 1024$。\n- 更粗糙的网格 $N \\in \\{16, 32, 64, 128\\}$，因此 $h = T/N$ 跨越四个尺度。\n- 对于每个测试案例，所有更粗糙的网格都使用来自最精细网格的嵌套增量。\n- 使用固定的随机种子 $42$。\n\n计算要求：\n- 对于测试案例1，通过将每种格式的终端近似值与使用由最精细网格所蕴含的共享 $W_T$ 计算出的精确终端值进行比较，来计算每个 $N$ 的强误差。\n- 对于测试案例2，通过将每种格式在每个 $N$ 处的终端近似值与在最精细网格 $N_{\\text{fine}}$ 上使用相同格式的终端近似值进行比较，来计算强误差。\n- 对于测试案例3，通过将每种格式的终端近似值与精确终端值进行比较，来计算每个 $N$ 的强误差。\n\n然后，对于每个测试案例和格式，将经验强收敛阶 $p$ 估计为四个 $h$ 值上 $\\log\\big(\\text{error}(h)\\big)$ 对 $\\log(h)$ 的最佳拟合线的斜率。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含六个估计的阶数，形式为逗号分隔的列表，并用方括号括起来，顺序为 $[\\text{p\\_EM\\_1}, \\text{p\\_Milstein\\_1}, \\text{p\\_EM\\_2}, \\text{p\\_Milstein\\_2}, \\text{p\\_EM\\_3}, \\text{p\\_Milstein\\_3}]$，其中下标表示测试案例的索引。\n- 每个条目必须是浮点数。\n\n不涉及物理单位。不出现角度。不得使用百分比。\n\n测试套件覆盖范围的基本原理：\n- 测试案例1使用具有已知精确解的乘性噪声，探测欧拉-丸山和米尔斯坦方法在光滑系数下预期的典型强收敛阶。\n- 测试案例2使用加性噪声，其扩散是恒定的，导数项消失，从而揭示当扩散项恒定时，这些格式在离散层面上对随机积分进行精确处理时的行为。\n- 测试案例3是一个没有噪声的边界条件，将SDE离散化简化为常微分方程离散化，测试强收敛阶是否与确定性数值积分行为一致。\n\n您的程序必须严格遵守指定的最终输出格式。", "solution": "该问题要求经验性地估计欧拉-丸山和米尔斯坦数值格式在一维伊藤随机微分方程（SDEs）应用中的强收敛阶。强收敛阶，记为 $p$，描述了在终端时刻 $T$ 的路径近似误差随时间步长 $h$ 减小的速率。\n\n一个一维伊藤SDE由以下形式的微分方程描述：\n$$ dX_t = a(X_t) \\, dt + b(X_t) \\, dW_t, \\quad X_0 = x_0 $$\n其中 $X_t$ 是随机过程，$a(\\cdot)$ 是漂移系数，$b(\\cdot)$ 是扩散系数，$W_t$ 是标准的一维布朗运动（维纳过程）。\n\n对于步长为 $h$ 的数值近似 $X_T^{(h)}$，其在终端时刻 $T$ 的强误差定义为数值解与真实解之间绝对差的期望值：\n$$ \\epsilon(h) = \\mathbb{E}\\left[ \\,|\\, X_T - X_T^{(h)} \\,|\\, \\right] $$\n如果对于小的 $h$，$\\epsilon(h) = \\mathcal{O}(h^p)$，那么一个格式具有 $p$ 阶强收敛。取对数后，我们有 $\\log(\\epsilon(h)) \\approx C + p \\log(h)$，这意味着 $p$ 可以通过对 $\\log(\\epsilon(h))$ 关于 $\\log(h)$进行线性回归的斜率来估计。我们将使用蒙特卡洛方法来估计这个期望。\n\n### 数值格式\n\nSDE的数值格式通常由过程 $X_t$ 的伊藤-泰勒展开推导而来。\n\n**欧拉-丸山（EM）** 格式是最简单的方法，通过截断伊藤-泰勒展开得到。对于一个恒定步长为 $h = t_{n+1} - t_n$ 的离散时间网格 $0 = t_0  t_1  \\dots  t_N = T$，其更新规则为：\n$$ X_{n+1} = X_n + a(X_n) h + b(X_n) \\Delta W_n $$\n其中 $X_n$ 是 $X_{t_n}$ 的近似值，$\\Delta W_n = W_{t_{n+1}} - W_{t_n}$ 是一个布朗增量，服从正态分布 $\\mathcal{N}(0, h)$。在 $a$ 和 $b$ 的适当光滑性条件下，EM格式的强收敛阶为 $p=0.5$。\n\n**米尔斯坦（Milstein）** 格式包含了伊藤-泰勒展开中的一个附加项，该项解释了扩散项与自身的相互作用。其更新规则为：\n$$ X_{n+1} = X_n + a(X_n) h + b(X_n) \\Delta W_n + \\frac{1}{2} b(X_n) b'(X_n) \\left( (\\Delta W_n)^2 - h \\right) $$\n其中 $b'(x) = \\frac{db}{dx}$。这个修正项通常能提高精度，对于具有光滑系数的SDE，米尔斯坦格式的强收敛阶为 $p=1.0$。\n\n### 仿真与估计方法\n\n我们将对一组步长 $h_k = T/N_k$（其中 $N_k \\in \\{16, 32, 64, 128\\}$）估计强误差 $\\epsilon(h)$。期望值通过在 $M=10000$ 条模拟路径上的蒙特卡洛平均来近似：\n$$ \\epsilon(h) \\approx \\frac{1}{M} \\sum_{i=1}^{M} \\left| \\, X_T^{(i)} - X_{T,h}^{(i)} \\, \\right| $$\n其中 $X_T^{(i)}$ 是第 $i$ 条路径的参考解，$X_{T,h}^{(i)}$ 是数值近似解。\n\n为确保路径上的一致性比较，采用了**嵌套增量**方法。在具有 $N_{\\text{fine}}=1024$ 个步长的精细网格上生成一条布朗路径。这条精细路径的增量是独立同分布的随机变量 $\\Delta W_k^{\\text{fine}} \\sim \\mathcal{N}(0, T/N_{\\text{fine}})$。对于任何具有 $N$ 个步长的更粗糙网格（其中 $N$ 是 $N_{\\text{fine}}$ 的因子），其增量通过对 $R = N_{\\text{fine}}/N$ 个连续的精细增量求和来构建。这确保了所有离散化使用的底层布朗运动是相同的，从而减少了误差估计的方差。\n\n然后，通过对数据对 $(\\log(h_k), \\log(\\epsilon(h_k)))$ 进行线性回归，为每种格式和每个测试案例估计收敛阶 $p$。该回归线的斜率提供了 $p$ 的经验估计。\n\n### 测试案例分析\n\n这三个测试案例旨在探究格式在不同条件下的行为。\n\n**测试案例1：几何布朗运动**\n- SDE: $dX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t$，其中 $X_0 = 1.0$，$T=1.0$，$\\mu=0.3$，$\\sigma=0.6$。\n- 系数：$a(x) = \\mu x$，$b(x) = \\sigma x$，以及 $b'(x) = \\sigma$。\n- EM规则：$X_{n+1} = X_n(1 + \\mu h + \\sigma \\Delta W_n)$。\n- 米尔斯坦规则：$X_{n+1} = X_n(1 + \\mu h + \\sigma \\Delta W_n) + \\frac{1}{2} \\sigma^2 X_n ((\\Delta W_n)^2 - h)$。\n- 参考：在时刻 $T$ 的精确解是 $X_T = X_0 \\exp\\left((\\mu - \\frac{1}{2}\\sigma^2)T + \\sigma W_T\\right)$，其中 $W_T$ 是所有精细网格布朗增量之和。\n- 预期阶数：这是一个具有乘性噪声的标准案例。理论上的阶数对于EM是 $p=0.5$，对于米尔斯坦是 $p=1.0$。\n\n**测试案例2：奥恩斯坦-乌伦贝克型，带加性噪声**\n- SDE: $dX_t = \\alpha X_t \\, dt + \\beta \\, dW_t$，其中 $X_0 = 1.0$，$T=1.0$，$\\alpha=-1.5$，$\\beta=0.5$。\n- 系数：$a(x) = \\alpha x$，$b(x) = \\beta$ (常数)，以及 $b'(x) = 0$。\n- 由于 $b'(x) = 0$，米尔斯坦格式中的修正项消失。因此，米尔斯坦格式与欧拉-丸山格式相同：$X_{n+1} = X_n + \\alpha X_n h + \\beta \\Delta W_n$。\n- 参考：由于不使用精确解，参考解是使用相同格式在具有 $N_{\\text{fine}}=1024$ 步长的精细网格上进行的高精度数值模拟。\n- 预期阶数：因为扩散系数 $b(x)$ 是常数，所以随机积分部分被两种格式精确离散化。近似误差仅来源于漂移项的离散化，这是一个一阶的欧拉方法。因此，预计两种格式都将表现出 $p=1.0$ 的强收敛阶。\n\n**测试案例3：确定性极限**\n- SDE: $dX_t = \\alpha X_t \\, dt$，其中 $X_0 = 1.2$，$T=1.0$，$\\alpha=0.8$。\n- 这是一个常微分方程（ODE），因为扩散项为零，$b(x) \\equiv 0$，这也意味着 $b'(x) \\equiv 0$。\n- EM和米尔斯坦格式都简化为ODE的显式欧拉方法：$X_{n+1} = X_n + \\alpha X_n h = X_n(1 + \\alpha h)$。\n- 参考：精确解是 $X_T = X_0 e^{\\alpha T}$。\n- 预期阶数：ODE的显式欧拉方法的收敛阶为 $1.0$。因此，预计两种格式都将得到 $p \\approx 1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Estimates the strong convergence order for the Euler-Maruyama and Milstein\n    schemes across three different SDE test cases.\n    \"\"\"\n    # Define global simulation parameters.\n    M = 10000\n    N_fine = 1024\n    Ns = np.array([16, 32, 64, 128])\n    SEED = 42\n    rng = np.random.default_rng(SEED)\n    \n    results = []\n\n    # === Test Case 1: Geometric Brownian Motion ===\n    x0_1, T_1, mu_1, sigma_1 = 1.0, 1.0, 0.3, 0.6\n    h_values_1 = T_1 / Ns\n    \n    # Generate one set of fine Brownian increments for all paths\n    fine_dWs_1 = rng.normal(loc=0.0, scale=np.sqrt(T_1 / N_fine), size=(M, N_fine))\n    \n    # Calculate exact terminal value as reference\n    W_T_1 = np.sum(fine_dWs_1, axis=1)\n    exact_XT_1 = x0_1 * np.exp((mu_1 - 0.5 * sigma_1**2) * T_1 + sigma_1 * W_T_1)\n\n    em_errors_1, milstein_errors_1 = [], []\n    for N in Ns:\n        h = T_1 / N\n        R = N_fine // N\n        coarse_dWs = fine_dWs_1.reshape(M, N, R).sum(axis=2)\n        \n        # Euler-Maruyama simulation\n        X_em = np.full(M, x0_1)\n        for i in range(N):\n            dW = coarse_dWs[:, i]\n            X_em += mu_1 * X_em * h + sigma_1 * X_em * dW\n        em_errors_1.append(np.mean(np.abs(X_em - exact_XT_1)))\n\n        # Milstein simulation\n        X_milstein = np.full(M, x0_1)\n        for i in range(N):\n            dW = coarse_dWs[:, i]\n            X_milstein += mu_1 * X_milstein * h + sigma_1 * X_milstein * dW + \\\n                          0.5 * sigma_1 * sigma_1 * X_milstein * (dW**2 - h)\n        milstein_errors_1.append(np.mean(np.abs(X_milstein - exact_XT_1)))\n\n    p_em_1 = np.polyfit(np.log(h_values_1), np.log(em_errors_1), 1)[0]\n    p_milstein_1 = np.polyfit(np.log(h_values_1), np.log(milstein_errors_1), 1)[0]\n    results.extend([p_em_1, p_milstein_1])\n\n    # === Test Case 2: Ornstein-Uhlenbeck-type (Additive Noise) ===\n    x0_2, T_2, alpha_2, beta_2 = 1.0, 1.0, -1.5, 0.5\n    h_values_2 = T_2 / Ns\n\n    fine_dWs_2 = rng.normal(loc=0.0, scale=np.sqrt(T_2 / N_fine), size=(M, N_fine))\n    \n    # Reference solution is the fine-grid simulation.\n    # For additive noise, EM and Milstein are identical (b'(x)=0).\n    X_ref_2 = np.full(M, x0_2)\n    h_fine = T_2 / N_fine\n    for i in range(N_fine):\n        dW = fine_dWs_2[:, i]\n        X_ref_2 += alpha_2 * X_ref_2 * h_fine + beta_2 * dW\n        \n    errors_2 = []\n    for N in Ns:\n        h = T_2 / N\n        R = N_fine // N\n        coarse_dWs = fine_dWs_2.reshape(M, N, R).sum(axis=2)\n\n        X_num = np.full(M, x0_2)\n        for i in range(N):\n            dW = coarse_dWs[:, i]\n            X_num += alpha_2 * X_num * h + beta_2 * dW\n        \n        errors_2.append(np.mean(np.abs(X_num - X_ref_2)))\n    \n    p_2 = np.polyfit(np.log(h_values_2), np.log(errors_2), 1)[0]\n    # EM and Milstein orders are the same.\n    p_em_2 = p_2\n    p_milstein_2 = p_2\n    results.extend([p_em_2, p_milstein_2])\n\n    # === Test Case 3: Deterministic Limit (ODE) ===\n    x0_3, T_3, alpha_3 = 1.2, 1.0, 0.8\n    h_values_3 = T_3 / Ns\n\n    # Exact solution for the ODE\n    exact_XT_3 = x0_3 * np.exp(alpha_3 * T_3)\n\n    # For b=0, EM and Milstein are identical (Euler method for ODEs).\n    # The simulation is deterministic, so no Monte Carlo paths are needed.\n    errors_3 = []\n    for N in Ns:\n        h = T_3 / N\n        X_num = float(x0_3) # Use a scalar\n        for _ in range(N):\n            X_num += alpha_3 * X_num * h\n            \n        errors_3.append(np.abs(X_num - exact_XT_3))\n\n    p_3 = np.polyfit(np.log(h_values_3), np.log(errors_3), 1)[0]\n    # EM and Milstein orders are the same.\n    p_em_3 = p_3\n    p_milstein_3 = p_3\n    results.extend([p_em_3, p_milstein_3])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3339961"}, {"introduction": "在验证了数值格式的收敛阶之后，我们必须深入探讨实现的细节，以确保代码的稳健性。高阶格式虽然在理论上更精确，但有时会引入对数值误差更敏感的项。本练习 [@problem_id:3081440] 聚焦于米尔斯坦格式中一个微妙但关键的实现问题：校正项 $(\\Delta W_n)^2 - h$ 在小步长 $h$ 下的计算。您需要批判性地思考“灾难性抵消”（catastrophic cancellation）这一浮点运算陷阱，并识别出能够保证计算精度和数值稳定性的正确策略，这对于编写可靠的科学计算代码至关重要。", "problem": "考虑标量随机微分方程 (SDE) $dX_t = a(X_t)\\,dt + \\sigma(X_t)\\,dW_t$，其中 $W_t$ 是一个维纳过程，$\\Delta W_n = W_{t_{n+1}} - W_{t_n}$ 表示在时间步长 $h = t_{n+1} - t_n$ 上的布朗增量。在用于 SDEs 数值积分的 Milstein 格式中，出现了一个包含 $(\\Delta W_n)^2 - h$ 的修正项。\n\n根据维纳增量的定义，$\\Delta W_n \\sim \\mathcal{N}(0,h)$，因此 $\\mathbb{E}\\big[(\\Delta W_n)^2\\big] = h$。\n\n要求你使用标准的双精度浮点数，在浮点运算中稳健地实现 Milstein 修正项，特别是对于非常小的时间步长 $h$ ($10^{-12} \\le h \\le 10^{-6}$)。假设采用标准的浮点模型，其机器精度为 $\\varepsilon_{\\text{mach}}$，并使用典型的编译器和处理器默认设置（除非明确说明，否则不启用特殊模式）。布朗增量由 $\\Delta W_n = \\sqrt{h}\\,Z_n$ 生成，其中 $Z_n \\sim \\mathcal{N}(0,1)$。\n\n请识别直接计算 $(\\Delta W_n)^2 - h$ 的潜在陷阱，并选择所有能够避免在 $h$ 非常小时发生灾难性抵消和精度损失，同时保持 Milstein 项正确分布行为的可靠保障措施。\n\n以下哪种策略是可靠的保障措施，可以避免灾难性抵消，并保持 Milstein 修正项在小 $h$ 值下的数值稳健性？\n\nA. 使用相同的抽样 $Z_n \\sim \\mathcal{N}(0,1)$ 计算 $h\\,(Z_n^2 - 1)$，而不是从 $\\Delta W_n$ 构造 $(\\Delta W_n)^2 - h$。\n\nB. 在模拟过程中用 $0$ 替换 $(\\Delta W_n)^2 - h$，因为其期望为 $0$，从而消除减法中的数值误差。\n\nC. 使用融合乘加运算将 $(\\Delta W_n)^2 - h$ 计算为 $\\mathrm{fma}(\\Delta W_n,\\Delta W_n,-h)$，或者如果可用，则使用扩展精度计算该差值。\n\nD. 从 $(-\\sqrt{h},\\sqrt{h})$ 上的均匀分布中抽样 $\\Delta W_n$，以避免平方运算，从而减少减法中的舍入误差。\n\nE. 计算缩放后的差值 $((\\Delta W_n)^2/h - 1)\\cdot h$，或者等价地，先计算 $(\\Delta W_n/\\sqrt{h})^2 - 1$（其值应接近 $Z_n^2 - 1$），然后再乘以 $h$。", "solution": "问题陈述在科学上是合理的、适定的且客观的。它涉及随机微分方程数值解中一个众所周知且实际的问题。所提供的参数和上下文是完整和一致的。该问题是有效的。\n\n核心问题是在时间步长 $h$ 非常小时如何计算表达式 $(\\Delta W_n)^2 - h$。我们已知布朗增量 $\\Delta W_n$ 是通过 $\\Delta W_n = \\sqrt{h} Z_n$ 生成的，其中 $Z_n \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量。\n\n将此代入表达式得到：\n$$ (\\Delta W_n)^2 - h = (\\sqrt{h} Z_n)^2 - h = h Z_n^2 - h $$\n由于 $Z_n \\sim \\mathcal{N}(0,1)$， $Z_n$ 的值通常是 $1$ 的量级。例如，大约 $68\\%$ 的抽样值会落在区间 $[-1, 1]$ 内，超过 $95\\%$ 会落在 $[-2, 2]$ 内。因此，$Z_n^2$ 也是一个量级为 $1$ 的随机变量。（具体来说，$Z_n^2 \\sim \\chi^2(1)$，其均值为 $1$，方差为 $2$）。\n这意味着项 $(\\Delta W_n)^2 = h Z_n^2$ 是一个在量级上与 $h$ 非常接近的量。当 $h$ 很小时（例如 $h \\approx 10^{-12}$），直接对两个几乎相等的数 $(\\Delta W_n)^2$ 和 $h$ 进行浮点减法运算，即 $(\\Delta W_n)^2 - h$，会导致大部分甚至所有有效数字的损失。这种现象被称为灾难性抵消，会急剧降低结果的精度。\n\n目标是找到在数学上等价（即保持该项的分布）但在数值上稳定的策略。\n\n让我们逐一评估每个选项：\n\n**A. 使用相同的抽样 $Z_n \\sim \\mathcal{N}(0,1)$ 计算 $h\\,(Z_n^2 - 1)$，而不是从 $\\Delta W_n$ 构造 $(\\Delta W_n)^2 - h$。**\n\n该策略依赖于代数重排：\n$$ (\\Delta W_n)^2 - h = h Z_n^2 - h = h(Z_n^2 - 1) $$\n在数学上，这两个表达式是相同的。在数值上，运算的顺序被改变了。我们首先计算 $Z_n^2 - 1$。由于 $Z_n^2$ 的量级为 $1$，减法 $Z_n^2 - 1$ 是两个量级为 $1$ 的数之差。这个运算不会遭受灾难性抵消。然后，这个减法的结果再乘以小数 $h$。乘法是一种数值稳定的运算。这个方法成功地避免了两个相近的小数相减，是标准的稳健实现方式。\n\n该策略是合理的。**正确**。\n\n**B. 在模拟过程中用 $0$ 替换 $(\\Delta W_n)^2 - h$，因为其期望为 $0$，从而消除减法中的数值误差。**\n\n该项的期望确实为零：$\\mathbb{E}[(\\Delta W_n)^2 - h] = \\mathbb{E}[(\\Delta W_n)^2] - h = h - h = 0$。然而，$(\\Delta W_n)^2 - h$ 是一个随机变量，不是一个常数。它的方差非零：\n$$ \\text{Var}((\\Delta W_n)^2 - h) = \\text{Var}(h Z_n^2 - h) = h^2 \\text{Var}(Z_n^2) = 2h^2 $$\n（因为 $Z_n^2 \\sim \\chi^2(1)$，其方差为 $2$）。Milstein 格式的更高阶强收敛性（相对于 Euler-Maruyama 格式的 $0.5$ 阶，其为 $1.0$ 阶）正是通过包含这个随机修正项来实现的。用一个随机变量的期望值（在这里是零）来代替它，会消除该项对路径方差的贡献，实际上是将 Milstein 格式退化为 Euler-Maruyama 格式。这违反了保持正确分布行为的要求。\n\n该策略存在根本性缺陷。**不正确**。\n\n**C. 使用融合乘加运算将 $(\\Delta W_n)^2 - h$ 计算为 $\\mathrm{fma}(\\Delta W_n,\\Delta W_n,-h)$，或者如果可用，则使用扩展精度计算该差值。**\n\n融合乘加 (FMA) 运算以单次最终舍入误差计算形如 $ax+b$ 的表达式。它在加 $b$ 之前，以完整的内部精度计算乘积 $ax$。在我们的例子中，这将以高精度计算 $(\\Delta W_n)^2$，然后减去 $h$，最后将最终结果舍入为标准双精度。这显著地缓解了灾难性抵消，因为减法本身是在一个有效精度高得多的情况下执行的（例如，标准双精度 FMA 的尾数有 106 位）。类似地，使用更高精度的浮点类型（例如，80 位扩展精度或 128 位四倍精度）来执行计算 $(\\Delta W_n)^2 - h$，会为尾数分配更多的比特位，从而可以保留差值的有效数字。在这类特定场景下，这两种方法都是有效的硬件级或库级技术，用以提高数值精度。\n\n该策略是一种合理且实用的保障措施。**正确**。\n\n**D. 从 $(-\\sqrt{h},\\sqrt{h})$ 上的均匀分布中抽样 $\\Delta W_n$，以避免平方运算，从而减少减法中的舍入误差。**\n\n该策略提议改变布朗增量的基本统计特性。维纳过程增量 $\\Delta W_n$ 必须是正态分布的，即 $\\Delta W_n \\sim \\mathcal{N}(0,h)$，方差为 $h$。从 $(-\\sqrt{h},\\sqrt{h})$ 上的均匀分布中抽样的随机变量 $U_n$ 的均值为 $0$，但其方差为：\n$$ \\text{Var}(U_n) = \\mathbb{E}[U_n^2] = \\frac{1}{2\\sqrt{h}}\\int_{-\\sqrt{h}}^{\\sqrt{h}} x^2 dx = \\frac{1}{2\\sqrt{h}} \\left[ \\frac{x^3}{3} \\right]_{-\\sqrt{h}}^{\\sqrt{h}} = \\frac{h}{3} $$\n方差不正确，差了 $3$ 倍。此外，所有更高阶的矩也不同。Milstein 格式从 Itô-Taylor 展开的推导，关键性地依赖于增量的高斯性。改变分布会使该格式的整个数学基础失效。这违反了保持正确分布行为的要求。\n\n该策略在理论上是无效的。**不正确**。\n\n**E. 计算缩放后的差值 $((\\Delta W_n)^2/h - 1)\\cdot h$，或者等价地，先计算 $(\\Delta W_n/\\sqrt{h})^2 - 1$（其值应接近 $Z_n^2 - 1$），然后再乘以 $h$。**\n\n这是代数重排的另一种形式，概念上与策略 A 相同。\n$$ (\\Delta W_n)^2 - h = h \\cdot \\left(\\frac{(\\Delta W_n)^2}{h} - 1\\right) $$\n在数值上，我们首先计算 $(\\Delta W_n)^2$（一个 $\\mathcal{O}(h)$ 的数），然后除以 $h$。除法的结果 $(\\Delta W_n)^2/h$ 是一个 $\\mathcal{O}(1)$ 的数，等于 $Z_n^2$。然后我们减去 $1$，这是两个 $\\mathcal{O}(1)$ 的数之间的数值稳定运算。最后，结果乘以 $h$。另一种表述，即先计算 $((\\Delta W_n)/\\sqrt{h})^2 - 1$，使得这一点更加清晰。由于 $\\Delta W_n = \\sqrt{h}Z_n$，那么 $(\\Delta W_n)/\\sqrt{h} = Z_n$，表达式就变成了 $(Z_n^2 - 1)$，然后乘以 $h$。这正是策略 A 中的计算。在这两种解释中，通过对量级为 1 的数执行关键的减法，都避免了灾难性抵消。\n\n该策略是合理的。**正确**。\n\n结论总结：\n- A: 正确\n- B: 不正确\n- C: 正确\n- D: 不正确\n- E: 正确\n\n合理的保障措施是 A、C 和 E。", "answer": "$$\\boxed{ACE}$$", "id": "3081440"}, {"introduction": "固定步长的数值方法雖然简单，但在效率上并非最优。许多随机微分方程的解在不同区域表现出迥异的“刚性”或波动性。一个更智能的方法是采用自适应步长策略，即根据解的局部特性动态调整步长 $h$，在“困难”区域使用小步长以保证精度，在“平滑”区域使用大步长以提升效率。本实践 [@problem_id:3339942] 将指导您从第一性原理出发，设计并实现一个基于局部误差估计的自适应步长欧拉-丸山格式，将局部误差指标与全局误差控制联系起来，以达到预设的精度目标。", "problem": "要求您设计、论证并实现一个自适应时间步长方案，用于使用 Euler–Maruyama 积分法模拟一个标量随机微分方程（SDE），其局部步长控制源于漂移项和扩散项的敏感度。该 SDE 的形式为\n$$\ndX_t = a(X_t)\\,dt + b(X_t)\\,dW_t,\n$$\n其中 $W_t$ 是一个标准维纳过程。您的设计必须基于 Itō 微积分的基本事实以及 Euler–Maruyama 方法的强误差属性。目标是确保在固定的最终时间 $T$ 时的均方强误差，\n$$\n\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr],\n$$\n达到或低于指定的目标容差。\n\n从以下公认的基础出发：\n- 用于 $dX_t = a(X_t)\\,dt + b(X_t)\\,dW_t$ 的 Itō 随机微积分。\n- Euler–Maruyama 方案作为一种弱一阶、强半阶方法，其全局均方强误差随步长呈小步长渐近关系。\n- 局部均方单步误差取决于 $a(\\cdot)$ 和 $b(\\cdot)$ 的局部变化，这些变化由它们的导数捕捉。\n\n设计要求：\n1. 基于在当前数值状态下评估的量级 $|a'(X_t)|$ 和 $|b'(X_t)|$ 的瞬时估计，设计一个自适应时间步长选择方法。您的设计应使用这些导数来调节步长，以控制在 $[0,T]$ 上的累积均方强误差，使其满足为 $\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]$ 指定的目标容差 $\\varepsilon^2$。\n2. 您的方案必须可使用 Euler–Maruyama 更新式实现\n$$\n\\hat{X}_{t+h} = \\hat{X}_t + a(\\hat{X}_t)\\,h + b(\\hat{X}_t)\\,\\Delta W,\n$$\n其中 $\\Delta W \\sim \\mathcal{N}(0,h)$，并且必须构造一个自适应的步长序列 $h$ 来精确覆盖区间 $[0,T]$（如有必要，调整最后一步）。\n3. 您的步长选择必须用可根据 $a(\\cdot)$、$b(\\cdot)$、$a'(\\cdot)$、$b'(\\cdot)$ 及问题参数（包括 $\\varepsilon^2$ 和 $T$）在运行时计算的量来明确表示。您可以包含最小的正则化常数和安全因子，前提是您在解决方案中对其进行论证。\n\n蒙特卡洛评估协议：\n- 使用相同的已实现维纳路径来耦合精确解 $X_T$ 和数值解 $\\hat{X}_T$ 以估计强误差。对于每个模拟路径，为您的自适应步长序列抽取高斯增量 $\\Delta W \\sim \\mathcal{N}(0,h)$，并为该路径定义 $W_T := \\sum \\Delta W$。对于仅依赖于 $W_T$ 的具有闭式解的 SDE，使用 $W_T$ 精确计算 $X_T$。使用许多独立路径上的平方误差的样本均值作为 $\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]$ 的蒙特卡洛估计。\n- 为随机数生成器固定一个确定性种子以保证可复现性。\n\n测试套件：\n实现您的算法并在以下三个测试用例上进行评估。没有物理单位；将所有量视为无量纲。不出现角度。输出应为指定的无单位实数或布尔值。\n\n1. 几何布朗运动（GBM），参数如下\n   - $a(x) = \\mu x$，$b(x) = \\sigma x$，导数为 $a'(x) = \\mu$，$b'(x) = \\sigma$，\n   - $X_0 = 1.0$，$T = 1.0$，$\\mu = 0.5$，$\\sigma = 0.7$，目标 $\\varepsilon^2 = 5\\times 10^{-3}$，\n   - 在给定维纳终值 $W_T$ 时，时间 $T$ 的精确解为：\n     $$\n     X_T = X_0 \\exp\\bigl((\\mu - \\tfrac{1}{2}\\sigma^2)T + \\sigma W_T\\bigr).\n     $$\n2. 几何布朗运动（GBM），参数如下\n   - $a(x) = \\mu x$，$b(x) = \\sigma x$，导数为 $a'(x) = \\mu$，$b'(x) = \\sigma$，\n   - $X_0 = 0.5$，$T = 1.5$，$\\mu = 1.2$，$\\sigma = 1.5$，目标 $\\varepsilon^2 = 2\\times 10^{-2}$，\n   - 精确解如上，使用给定参数。\n3. 常系数加性噪声 SDE\n   - $a(x) = \\alpha$，$b(x) = \\beta$，导数为 $a'(x) = 0$，$b'(x) = 0$，\n   - $X_0 = -1.0$，$T = 2.0$，$\\alpha = 0.3$，$\\beta = 0.8$，目标 $\\varepsilon^2 = 10^{-8}$，\n   - 精确解：\n     $$\n     X_T = X_0 + \\alpha T + \\beta W_T.\n     $$\n\n蒙特卡洛配置：\n- 每个测试用例使用恰好 $N = 4000$ 条独立路径。\n- 为伪随机数生成器使用单个固定种子，以确保跨次运行结果的可复现性。\n\n最终程序输出：\n- 对于每个测试用例，计算 $\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]$ 的蒙特卡洛估计，并将其与目标容差 $\\varepsilon^2$ 进行比较。\n- 您的程序应生成单行输出，其中包含一个 Python 风格列表中的三个布尔结果，每个布尔值表示估计的均方强误差是否不超过相应测试用例的目标容差。例如，输出格式必须与以下完全一样：\n\"[True,False,True]\".", "solution": "任务是为形式为 $dX_t = a(X_t)\\,dt + b(X_t)\\,dW_t$ 的标量随机微分方程（SDE）的数值模拟，设计、论证并实现一个自适应时间步长方案。该方案必须使用 Euler-Maruyama 方法，并自适应调整步长 $h$ 以控制全局均方强误差 $\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]$ 低于指定容差 $\\varepsilon^2$。步长控制必须基于漂移和扩散系数的导数 $a'(x)$ 和 $b'(x)$。\n\n### 基于原理的自适应方案设计\n\n自适应步长控制器的设计基于一个启发式但标准的 SDE 强解误差累积模型。\n\n**1. Euler-Maruyama 方法的强误差**\n\n对于一个恒定的步长 $h$，已知 Euler-Maruyama 方法的强收敛阶为 $0.5$。这意味着在固定的时间 $T$，对于小的 $h$，全局均方强误差与步长成线性关系：\n$$\n\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr] \\approx C \\cdot h\n$$\n常数 $C$ 取决于时间区间 $T$以及沿解路径的系数 $a(x)$ 和 $b(x)$ 的性质。对于一个“刚性”或敏感度（由导数 $a'$ 和 $b'$ 捕捉）变化的过程，可以合理地假设 $C$ 可以表示为某个局部误差指示函数 $G(x)$ 在路径上的积分。这得到：\n$$\n\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr] \\approx h \\int_0^T \\mathbb{E}[G(X_s)] ds\n$$\n\n**2. 推广到自适应步长**\n\n对于自适应方案，步长 $h$ 不再是常数，而是成为当前状态的函数，$h_t = h(X_t)$。我们通过用依赖于状态的步长 $h_s$ 替换积分内的常数 $h$ 来推广误差模型：\n$$\n\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr] \\approx \\int_0^T \\mathbb{E}[G(X_s) h_s] ds\n$$\n该模型假定总误差是局部误差贡献之和，其中在时间 $s$ 的贡献“率”为 $G(X_s) h_s$。虽然这是对复杂误差传播动力学的简化，但该模型为 I-控制器（积分控制器）的设计提供了实践基础。\n\n**3. 通过误差均匀分布的步长控制律**\n\n为了控制总误差以满足目标容差 $\\varepsilon^2$，我们采用误差均匀分布原理。我们力求在整个模拟过程中保持瞬时误差率恒定。也就是说，我们施加条件：\n$$\nG(X_t) h_t = K\n$$\n其中 $K$ 是一个常数。将其代入我们的全局误差模型：\n$$\n\\int_0^T \\mathbb{E}[K] ds = K \\int_0^T ds = KT\n$$\n为满足容差，我们设定 $KT = \\varepsilon^2$，这确定了常数 $K = \\varepsilon^2 / T$。由此得出自适应步长控制律：\n$$\nh_t = \\frac{\\varepsilon^2}{T \\cdot G(X_t)}\n$$\n\n**4. 误差指示函数 $G(x)$**\n\n问题要求控制器基于 $|a'(x)|$ 和 $|b'(x)|$。Euler-Maruyama 方案的局部误差源于在一个步长 $[t, t+h]$ 内将系数 $a(s)$ 和 $b(s)$ 近似为常数。此近似误差的大小与系数的导数以及过程本身的变化有关，后者由扩散项 $b(x)$ 驱动。局部误差的 Itō-Taylor 展开中的主导项涉及诸如 $a'(x)b(x)$ 和 $b'(x)b(x)$ 的乘积。这启发我们设计一个结合这些效应的误差指示函数。我们为 $G(x)$ 提出以下形式：\n$$\nG(x) = |b(x)| \\left( |a'(x)| + |b'(x)| \\right)\n$$\n这种形式捕捉了所要求的依赖关系：当导数很大（高敏感度）或扩散项很大（高波动性）时，步长将减小。为简单起见，比例常数取为 $1$，因为其影响可以被吸收到安全因子中。\n\n**5. 带正则化的最终控制算法**\n\n在实践中，我们引入一个安全因子 $\\gamma  1$（例如 $\\gamma=0.9$）以使其更为保守，并增加满足容差的概率。此外，我们在分母中加入一个小的正则化参数 $\\delta > 0$，以防止当 $G(x)$ 为零或接近零时出现除以零或步长过大的情况。这对于像常系数情况那样的 SDE 至关重要，因为其导数为零，Euler-Maruyama 方案在这种情况下是精确的，非常大的步长是合适的。\n\n在状态 $\\hat{X}_t$ 下，最终可实现的步长规则是：\n$$\nh = \\frac{\\gamma \\cdot \\varepsilon^2}{T \\cdot (G(\\hat{X}_t) + \\delta)}\n$$\n其中 $G(\\hat{X}_t) = |b(\\hat{X}_t)| \\left( |a'(\\hat{X}_t)| + |b'(\\hat{X}_t)| \\right)$。\n\n单路径模拟的完整算法如下：\n1. 初始化 $t=0$，$\\hat{X}=\\hat{X}_0$，以及累积维纳增量 $W_T=0$。\n2. 当 $t  T$ 时：\n   a. 使用上述控制律计算步长 $h$。\n   b. 为确保模拟在 $T$ 时刻精确终止，裁剪步长：$h = \\min(h, T-t)$。\n   c. 执行 Euler-Maruyama 更新：\n      i. 生成一个标准正态随机变量 $Z \\sim \\mathcal{N}(0,1)$。\n      ii. 计算维纳增量 $\\Delta W = Z \\sqrt{h}$。\n      iii. 更新状态：$\\hat{X} \\leftarrow \\hat{X} + a(\\hat{X})h + b(\\hat{X})\\Delta W$。\n   d. 更新总维纳增量：$W_T \\leftarrow W_T + \\Delta W$。\n   e. 时间推进：$t \\leftarrow t+h$。\n3. 模拟得出数值近似解 $\\hat{X}_T$ 和相应的总维纳增量 $W_T$。\n\n通过对许多独立路径运行此过程，并对数值解 $\\hat{X}_T$ 与精确解 $X_T(W_T)$ 之间的平方差求平均，我们得到均方强误差 $\\mathbb{E}\\bigl[\\,|X_T - \\hat{X}_T|^2\\,\\bigr]$ 的蒙特卡洛估计。", "answer": "```python\nimport numpy as np\nfrom typing import Callable, List, Tuple\n\ndef solve():\n    \"\"\"\n    Designs, implements, and evaluates an adaptive Euler-Maruyama scheme\n    for three SDE test cases.\n    \"\"\"\n\n    # Set a fixed seed for the random number generator for reproducibility.\n    np.random.seed(42)\n\n    def adaptive_sde_solver(\n        a: Callable[[float], float],\n        b: Callable[[float], float],\n        a_prime: Callable[[float], float],\n        b_prime: Callable[[float], float],\n        exact_sol: Callable[[float, float, float, float], float],\n        x0: float,\n        T: float,\n        target_error_sq: float,\n        num_paths: int\n    ) - bool:\n        \"\"\"\n        Solves an SDE using an adaptive Euler-Maruyama scheme and evaluates if the\n        mean-square strong error meets the target tolerance.\n\n        Args:\n            a: Drift coefficient function a(x).\n            b: Diffusion coefficient function b(x).\n            a_prime: Derivative of the drift function a'(x).\n            b_prime: Derivative of the diffusion function b'(x).\n            exact_sol: Function to compute the exact solution at time T given W_T.\n            x0: Initial condition.\n            T: Final time.\n            target_error_sq: The target mean-square strong error (epsilon^2).\n            num_paths: The number of Monte Carlo paths to simulate.\n\n        Returns:\n            A boolean indicating whether the estimated mean-square error is\n            less than or equal to the target tolerance.\n        \"\"\"\n        \n        total_squared_error = 0.0\n        \n        # Controller parameters\n        gamma = 0.9  # Safety factor\n        delta = 1e-12 # Regularization parameter\n\n        for _ in range(num_paths):\n            t = 0.0\n            x_hat = x0\n            w_T = 0.0\n\n            while t  T:\n                # Calculate coefficients and their derivatives at the current state\n                a_val = a(x_hat)\n                b_val = b(x_hat)\n                ap_val = a_prime(x_hat)\n                bp_val = b_prime(x_hat)\n\n                # Calculate the error indicator G(x)\n                g_val = abs(b_val) * (abs(ap_val) + abs(bp_val))\n                \n                # Calculate the adaptive step size h\n                h = (gamma * target_error_sq) / (T * (g_val + delta))\n                \n                # Adjust the last step to land exactly on T\n                if t + h > T:\n                    h = T - t\n                \n                # Generate Wiener increment\n                dw = np.random.normal(0, np.sqrt(h))\n                \n                # Euler-Maruyama step\n                x_hat += a_val * h + b_val * dw\n                \n                # Accumulate Wiener increment for the exact solution\n                w_T += dw\n                \n                # Advance time\n                t += h\n            \n            x_hat_T = x_hat\n            x_exact_T = exact_sol(x0, T, w_T, 0) # Placeholder for mu/alpha\n            \n            total_squared_error += (x_hat_T - x_exact_T)**2\n            \n        mean_squared_error = total_squared_error / num_paths\n        \n        return mean_squared_error = target_error_sq\n\n    # --- Test Cases Definition ---\n    \n    # Common parameters\n    N_PATHS = 4000\n\n    # Case 1: Geometric Brownian Motion\n    test_case_1_params = {\n        'mu': 0.5, 'sigma': 0.7, 'x0': 1.0, 'T': 1.0, \n        'eps2': 5e-3\n    }\n    a1 = lambda x: test_case_1_params['mu'] * x\n    b1 = lambda x: test_case_1_params['sigma'] * x\n    ap1 = lambda x: test_case_1_params['mu']\n    bp1 = lambda x: test_case_1_params['sigma']\n    def exact_gbm(x0, T, Wt, mu, sigma):\n        return x0 * np.exp((mu - 0.5 * sigma**2) * T + sigma * Wt)\n    \n    # Case 2: Geometric Brownian Motion\n    test_case_2_params = {\n        'mu': 1.2, 'sigma': 1.5, 'x0': 0.5, 'T': 1.5,\n        'eps2': 2e-2\n    }\n    a2 = lambda x: test_case_2_params['mu'] * x\n    b2 = lambda x: test_case_2_params['sigma'] * x\n    ap2 = lambda x: test_case_2_params['mu']\n    bp2 = lambda x: test_case_2_params['sigma']\n\n    # Case 3: Constant-coefficient SDE\n    test_case_3_params = {\n        'alpha': 0.3, 'beta': 0.8, 'x0': -1.0, 'T': 2.0,\n        'eps2': 1e-8\n    }\n    a3 = lambda x: test_case_3_params['alpha']\n    b3 = lambda x: test_case_3_params['beta']\n    ap3 = lambda x: 0.0\n    bp3 = lambda x: 0.0\n    def exact_const_coeff(x0, T, Wt, alpha, beta):\n        return x0 + alpha * T + beta * Wt\n        \n    # --- Execution of Test Suite ---\n\n    results = []\n\n    # Run Case 1\n    p1 = test_case_1_params\n    result1 = adaptive_sde_solver(\n        a1, b1, ap1, bp1, \n        lambda x0, T, Wt, _: exact_gbm(x0, T, Wt, p1['mu'], p1['sigma']),\n        p1['x0'], p1['T'], p1['eps2'], N_PATHS\n    )\n    results.append(result1)\n\n    # Run Case 2\n    p2 = test_case_2_params\n    result2 = adaptive_sde_solver(\n        a2, b2, ap2, bp2, \n        lambda x0, T, Wt, _: exact_gbm(x0, T, Wt, p2['mu'], p2['sigma']),\n        p2['x0'], p2['T'], p2['eps2'], N_PATHS\n    )\n    results.append(result2)\n\n    # Run Case 3\n    p3 = test_case_3_params\n    result3 = adaptive_sde_solver(\n        a3, b3, ap3, bp3,\n        lambda x0, T, Wt, _: exact_const_coeff(x0, T, Wt, p3['alpha'], p3['beta']),\n        p3['x0'], p3['T'], p3['eps2'], N_PATHS\n    )\n    results.append(result3)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3339942"}]}