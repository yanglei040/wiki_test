{"hands_on_practices": [{"introduction": "分析马尔可夫链的第一步是直接从其转移矩阵中理解其基本性质。本练习提供了一个具有二分结构的链的具体例子，这是周期性的一个常见来源。通过从第一性原理应用不可约性和周期的定义，你将巩固对这些性质如何体现在链的转移动态中的理解。[@problem_id:3329415]", "problem": "考虑一个时间齐次的离散时间马尔可夫链，其状态空间为 $\\{1,2,3,4\\}$，转移矩阵 $P \\in \\mathbb{R}^{4 \\times 4}$ 由下式给出\n$$\nP =\n\\begin{pmatrix}\n0  \\frac{1}{3}  0  \\frac{2}{3} \\\\\n\\frac{1}{2}  0  \\frac{1}{2}  0 \\\\\n0  \\frac{3}{5}  0  \\frac{2}{5} \\\\\n\\frac{1}{4}  0  \\frac{3}{4}  0\n\\end{pmatrix}.\n$$\n矩阵 $P$ 的结构为：对角线元素为零，非对角线上的正值元素在两个划分之间交替，形成一个二部交互模式：状态 $\\{1,3\\}$ 只转移到状态 $\\{2,4\\}$，反之亦然。仅使用马尔可夫链理论的基础定义，不借助任何快捷结论，确定每个状态的周期，并验证该链是否是不可约的。从状态 $i$ 的周期 $d(i)$ 定义为集合 $\\{n \\geq 1 : (P^{n})_{ii} > 0\\}$ 的最大公约数开始，以及不可约性的定义为对于任意状态对 $i,j$，存在 $n \\geq 1$ 使得 $(P^{n})_{ij} > 0$。\n\n使用 LaTeX 的 `pmatrix` 环境，将最终答案表示为一个单行矩阵，包含五个条目：按状态顺序 $(1,2,3,4)$ 排列的四个周期，以及一个指示符 $I$（如果链是不可约的，则 $I$ 等于 $1$，否则等于 $0$）。无需四舍五入。", "solution": "我们从马尔可夫链的基本定义开始。对于一个具有转移矩阵 $P$ 的时间齐次马尔可夫链，状态 $i$ 的周期 $d(i)$ 定义为\n$$\nd(i) = \\gcd\\big\\{ n \\geq 1 : (P^{n})_{ii} > 0 \\big\\}.\n$$\n该链是不可约的，当且仅当对于所有状态 $i,j$，存在 $n \\geq 1$ 使得 $(P^{n})_{ij} > 0$。\n\n我们分析 $P$ 的结构。$P$ 的非零元素满足\n- 对于状态 $1$ 和 $3$，转移只发生到状态 $2$ 和 $4$，\n- 对于状态 $2$ 和 $4$，转移只发生到状态 $1$ 和 $3$，\n- 所有对角线元素满足 $(P)_{ii} = 0$。\n\n这导致状态空间的一个二部划分为 $A = \\{1,3\\}$ 和 $B = \\{2,4\\}$，并且每一步都在 $A$ 和 $B$ 之间交替。因此，任何从同一状态开始并结束的路径必须具有偶数长度。特别地，对于任何状态 $i$，对于所有奇数 $n$，都有 $(P^{n})_{ii} = 0$。因此，可能的返回时间属于偶数整数集合。\n\n为了证明对于每个 $i$ 都有 $(P^{2})_{ii} > 0$，我们显式地计算 $P^{2} = P \\cdot P$。由于其二部结构，$(P^{2})$ 仅在同一划分内的状态之间有非零元素。我们计算对角线元素：\n- 对于 $i = 1$，\n$$\n(P^{2})_{11} = P_{12} P_{21} + P_{14} P_{41} = \\frac{1}{3} \\cdot \\frac{1}{2} + \\frac{2}{3} \\cdot \\frac{1}{4} = \\frac{1}{6} + \\frac{1}{6} = \\frac{1}{3}.\n$$\n- 对于 $i = 2$，\n$$\n(P^{2})_{22} = P_{21} P_{12} + P_{23} P_{32} = \\frac{1}{2} \\cdot \\frac{1}{3} + \\frac{1}{2} \\cdot \\frac{3}{5} = \\frac{1}{6} + \\frac{3}{10} = \\frac{7}{15}.\n$$\n- 对于 $i = 3$，\n$$\n(P^{2})_{33} = P_{32} P_{23} + P_{34} P_{43} = \\frac{3}{5} \\cdot \\frac{1}{2} + \\frac{2}{5} \\cdot \\frac{3}{4} = \\frac{3}{10} + \\frac{3}{10} = \\frac{3}{5}.\n$$\n- 对于 $i = 4$，\n$$\n(P^{2})_{44} = P_{41} P_{14} + P_{43} P_{34} = \\frac{1}{4} \\cdot \\frac{2}{3} + \\frac{3}{4} \\cdot \\frac{2}{5} = \\frac{1}{6} + \\frac{3}{10} = \\frac{7}{15}.\n$$\n因此，对于所有 $i \\in \\{1,2,3,4\\}$，都有 $(P^{2})_{ii} > 0$。\n\n接下来，注意到对于所有奇数 $n$，都有 $(P^{n})_{ii} = 0$，因为一步是从 $A$ 移动到 $B$ 或从 $B$ 移动到 $A$，因此返回到同一状态需要偶数步。对于 $n = 2$，我们已经证明 $(P^{2})_{ii} > 0$；对于 $n = 4$，我们有 $(P^{4}) = (P^{2})^{2}$，并且相同的划分内正性意味着 $(P^{4})_{ii} \\geq (P^{2})_{ii}^{2} > 0$，通过迭代两步转移，对于任何偶数 $n$ 也是类似的。因此，返回状态 $i$ 的时间集合包括所有大于或等于 $2$ 的偶数，并且不包括任何奇数。集合 $\\{2,4,6,\\dots\\}$ 的最大公约数是 $2$。因此，对于每个 $i \\in \\{1,2,3,4\\}$，\n$$\nd(i) = 2.\n$$\n\n我们现在验证不可约性。我们必须证明对于任何状态 $i,j$，存在 $n \\geq 1$ 使得 $(P^{n})_{ij} > 0$。\n- 如果 $i \\in A$ 且 $j \\in B$（或反之），通过直接观察 $P$ 可知 $(P)_{ij} > 0$：例如，$(P)_{12} = \\frac{1}{3} > 0$，$(P)_{14} = \\frac{2}{3} > 0$，$(P)_{32} = \\frac{3}{5} > 0$，$(P)_{34} = \\frac{2}{5} > 0$，从 $B$ 到 $A$ 的转移也类似。\n- 如果 $i,j$ 位于同一划分中，则 $(P^{2})_{ij} > 0$。例如，$(P^{2})_{13} = P_{12} P_{23} + P_{14} P_{43} = \\frac{1}{3} \\cdot \\frac{1}{2} + \\frac{2}{3} \\cdot \\frac{3}{4} = \\frac{1}{6} + \\frac{1}{2} = \\frac{2}{3} > 0$，以及 $(P^{2})_{24} = P_{21} P_{14} + P_{23} P_{34} = \\frac{1}{2} \\cdot \\frac{2}{3} + \\frac{1}{2} \\cdot \\frac{2}{5} = \\frac{1}{3} + \\frac{1}{5} = \\frac{8}{15} > 0$。类似的计算可以显示其他相同划分内的状态对也具有正值。\n\n因此，对于每对 $i,j$，都存在 $n \\in \\{1,2\\}$ 使得 $(P^{n})_{ij} > 0$。这证明了该链是不可约的。\n\n汇总结果，按状态顺序 $(1,2,3,4)$ 的周期都等于 $2$，不可约性指示符 $I$ 等于 $1$。\n\n所要求的最终答案是具有条目 $\\big(d(1), d(2), d(3), d(4), I\\big) = (2,2,2,2,1)$ 的行矩阵。", "answer": "$$\\boxed{\\begin{pmatrix} 2  2  2  2  1 \\end{pmatrix}}$$", "id": "3329415"}, {"introduction": "周期性会阻碍马尔可夫链收敛到其平稳分布。本练习展示了一种通过引入微小的随机扰动来消除周期性的强大技术。你将分析一个高度周期性的简单确定性循环，然后观察添加“重置”机制不仅使链变为非周期性，还显著改善了其收敛速度，这个概念可以通过松弛时间来量化。[@problem_id:3329433]", "problem": "考虑一个定义在有限状态空间 $\\{0,1,\\dots,m-1\\}$ 上的离散时间马尔可夫链，该空间与循环群 $\\mathbb{Z}_{m}$ 等同。设基准动态为确定性旋转：链从状态 $x$ 以概率 $1$ 转移到 $x+1 \\bmod m$。然后通过引入到特定状态 $0$ 的随机重置来修改此基准链：在每一步中，从任何当前状态 $x$，链以概率 $\\epsilon \\in (0,1)$ 移动到 $0$，并以概率 $1-\\epsilon$ 移动到 $x+1 \\bmod m$。将基准链的转移矩阵记为 $S$，修改后链的转移矩阵记为 $P$。\n\n使用以下基本定义和事实：\n- 离散时间马尔可夫链由一个转移矩阵 $P$ 指定，其元素非负且行和为 $1$，描述了在状态之间移动的概率。\n- 状态 $i$ 的周期 $d(i)$ 定义为 $d(i) = \\gcd\\{n \\geq 1 : (P^{n})_{ii} > 0\\}$，其中 $(P^{n})_{ii}$ 是 $n$ 步转移矩阵 $P^{n}$ 的第 $i,i$ 个元素。在不可约链中，所有状态共享相同的周期。\n- 弛豫时间 $\\tau_{\\mathrm{rel}}$ 通过第二大特征值模 (SLEM) 定义：如果 $1=\\lambda_{1}$ 是 $P$ 的 Perron 根，则 $\\tau_{\\mathrm{rel}} = \\frac{1}{1 - \\max\\{|\\lambda| : \\lambda \\in \\mathrm{spec}(P), \\lambda \\neq 1\\}}$，假设矩阵可对角化，或更一般地，将 $\\max\\{|\\lambda| : \\lambda \\neq 1\\}$ 解释为 $P$ 的次主导特征值的模。\n\n任务：\n1. 对于基准确定性旋转链 $S$（即 $\\epsilon = 0$），确定任何状态 $i \\in \\mathbb{Z}_{m}$ 的周期 $d(i)$。\n2. 对于修改后的链 $P$（其中 $\\epsilon \\in (0,1)$），证明其不可约性并确定任何状态 $i \\in \\mathbb{Z}_{m}$ 的周期 $d(i)$。\n3. 对于修改后的链 $P$，推导其完整的特征值集合，并由此计算弛豫时间 $\\tau_{\\mathrm{rel}}$，使其成为 $\\epsilon$ 和 $m$ 的显式函数。\n\n将最终答案以单行矩阵的形式给出，包含三个条目，顺序为：基准周期、修改后周期和修改后弛豫时间。不需要近似或四舍五入，也不涉及物理单位。", "solution": "问题要求分析定义在状态空间 $\\mathbb{Z}_m = \\{0, 1, \\dots, m-1\\}$ 上的两个离散时间马尔可夫链。在验证问题设置后，我们将依次处理这三个任务。\n\n问题陈述定义明确、数学上合理且自成体系。周期和弛豫时间的定义在马尔可夫链理论中是标准的。在任何状态的转移概率之和必须为一的约束下，修改后链的动态描述是明确的。对于任何状态 $x \\in \\{0, 1, \\dots, m-2\\}$，两个可能的下一个状态 $0$ 和 $x+1$ 是不同的。因此，转移是 $x \\to 0$ 的概率为 $\\epsilon$，以及 $x \\to x+1$ 的概率为 $1-\\epsilon$。对于状态 $x=m-1$，确定性旋转下的下一个状态是 $(m-1)+1 \\pmod m = 0$。在这种情况下，两种机制——重置和旋转——都导致相同的状态 $0$。因此，从 $m-1$ 转移到 $0$ 的总概率是 $\\epsilon + (1-\\epsilon) = 1$。因此，该问题是有效的。\n\n**任务1：基准链 S 的周期**\n\n基准链是 $\\mathbb{Z}_m$ 上的一个确定性旋转。从任何状态 $i$，链以概率 $1$ 移动到状态 $i+1 \\pmod m$。这是一个简单的循环 $0 \\to 1 \\to \\dots \\to m-1 \\to 0$。\n\n状态 $i$ 的周期，记为 $d(i)$，由 $d(i) = \\gcd\\{n \\geq 1 : (S^n)_{ii} > 0\\}$ 给出，其中 $(S^n)_{ii}$ 是在恰好 $n$ 步内返回状态 $i$ 的概率。\n\n对于这个确定性循环，从状态 $i$ 开始，链在 $n$ 步后的状态是 $i+n \\pmod m$。为了让链返回到状态 $i$，我们必须有 $i+n \\equiv i \\pmod m$，这简化为 $n \\equiv 0 \\pmod m$。这意味着 $n$ 必须是 $m$ 的倍数。\n\n返回任何状态 $i$ 的可能时间集合是 $\\{m, 2m, 3m, \\dots\\}$。周期是这个集合的最大公约数 (GCD)。\n$$\nd(i) = \\gcd(\\{m, 2m, 3m, \\dots\\}) = m\n$$\n由于这对单个循环成立，所有状态都在一个单一的互通类中，并且它们都共享相同的周期。因此，任何状态 $i$ 的周期都是 $m$。\n\n**任务2：修改后链 P 的不可约性和周期**\n\n修改后链的转移定义如下：从状态 $x$，链以概率 $\\epsilon \\in (0,1)$ 移动到 $0$，并以概率 $1-\\epsilon$ 移动到 $x+1 \\pmod m$。如在验证阶段所确立的，对于 $x=m-1$，转移到状态 $0$ 的概率为 $1$。\n\n为了证明不可约性，我们必须证明可以以正概率在有限步数内从任何状态 $i$ 到达任何状态 $j$。\n1.  从任何状态 $i \\in \\{0, 1, \\dots, m-2\\}$，存在到状态 $0$ 的转移，概率为 $P_{i0} = \\epsilon > 0$。从状态 $m-1$，到 $0$ 的转移以概率 $P_{m-1,0}=1 > 0$ 发生。因此，状态 $0$ 可以从任何状态 $i \\in \\mathbb{Z}_m$ 到达。\n2.  从状态 $0$，我们可以以概率 $P_{01}=1-\\epsilon > 0$ 到达状态 $1$。从状态 $1$，我们可以以概率 $P_{12}=1-\\epsilon > 0$ 到达状态 $2$。通过归纳法，我们可以通过采取 $j$ 次连续的“旋转”步骤（$0 \\to 1 \\to \\dots \\to j$）从状态 $0$ 到达任何状态 $j \\in \\{1, \\dots, m-1\\}$。这条路径的概率是 $(1-\\epsilon)^j > 0$。状态 $0$ 可以以概率 $P_{00}=\\epsilon > 0$ 到达自身。因此，状态 $0$ 可以到达任何状态 $j \\in \\mathbb{Z}_m$。\n\n结合这两点，任何状态 $i$ 都可以通过首先转移到状态 $0$（这总是可能的），然后从状态 $0$ 转移到状态 $j$，从而到达任何其他状态 $j$。因此，该马尔可夫链是不可约的。\n\n对于一个不可约链，所有状态共享相同的周期 $d$。我们可以计算状态 $0$ 的周期。我们需要找到 $d(0) = \\gcd\\{n \\geq 1 : (P^n)_{00} > 0\\}$。\n从状态 $0$ 一步之内返回自身的转移概率是 $P_{00} = \\epsilon$。由于 $\\epsilon \\in (0,1)$，我们有 $P_{00} > 0$。\n这意味着 $n=1$ 是状态 $0$ 的一个可能的返回时间。返回时间集合 $\\{n \\geq 1: (P^n)_{00}>0\\}$ 包含整数 $1$。任何包含 $1$ 的正整数集合的最大公约数是 $1$。\n因此，$d(0) = \\gcd(\\{1, \\dots\\}) = 1$。\n由于链是不可约的，每个状态的周期都是 $d(i)=1$。周期为 $1$ 的链称为非周期链。\n\n**任务3：修改后链 P 的特征值和弛豫时间**\n\n修改后链的转移矩阵 $P$ 为：\n$$\nP_{ij} =\n\\begin{cases}\n\\epsilon  \\text{如果 } j=0, i \\in \\{0, \\dots, m-2\\} \\\\\n1-\\epsilon  \\text{如果 } j=i+1, i \\in \\{0, \\dots, m-2\\} \\\\\n1  \\text{如果 } j=0, i=m-1 \\\\\n0  \\text{其他情况}\n\\end{cases}\n$$\n设 $v = (v_0, v_1, \\dots, v_{m-1})^T$ 是 $P$ 的一个特征向量，其特征值为 $\\lambda$。特征值方程 $Pv = \\lambda v$ 给出以下线性方程组：\n对于 $i \\in \\{0, 1, \\dots, m-2\\}$：$\\epsilon v_0 + (1-\\epsilon)v_{i+1} = \\lambda v_i$。\n对于 $i=m-1$：$v_0 = \\lambda v_{m-1}$。\n\n从 $i \\in \\{0, \\dots, m-2\\}$ 的一般方程，我们可以写出特征向量分量的递推关系：\n$v_{i+1} = \\frac{\\lambda v_i - \\epsilon v_0}{1-\\epsilon}$。\n这是一个关于 $v_i$ 的一阶线性非齐次递推关系。\n我们来分析 $\\lambda-1+\\epsilon = 0$ 的情况，即 $\\lambda = 1-\\epsilon$。递推关系变为 $v_{i+1} - v_i = -\\frac{\\epsilon v_0}{1-\\epsilon}$。这描述了一个等差数列。解为 $v_i = v_0 - i \\frac{\\epsilon v_0}{1-\\epsilon}$。使用方程组的最后一个方程 $v_0 = \\lambda v_{m-1} = (1-\\epsilon)v_{m-1}$，我们得到 $v_0 = (1-\\epsilon) \\left(v_0 - (m-1)\\frac{\\epsilon v_0}{1-\\epsilon}\\right)$。假设 $v_0 \\neq 0$，我们有 $1 = (1-\\epsilon) - (m-1)\\epsilon = 1 - m\\epsilon$。这意味着 $m\\epsilon=0$，这是不可能的，因为 $m \\geq 1$ 且 $\\epsilon > 0$。因此，$\\lambda=1-\\epsilon$ 不是一个特征值。\n\n对于 $\\lambda \\neq 1-\\epsilon$，递推关系的解形式为 $v_i = A r^i + C$，其中 $r = \\frac{\\lambda}{1-\\epsilon}$ 是齐次部分的特征方程的根，$C$ 是一个特解。我们找到 $C = \\frac{\\epsilon v_0}{\\lambda-1+\\epsilon}$。常数 $A$ 由 $i=0$ 时的初始条件决定：$v_0 = A+C$，这给出 $A = v_0 - C = v_0\\left(1-\\frac{\\epsilon}{\\lambda-1+\\epsilon}\\right) = v_0\\frac{\\lambda-1}{\\lambda-1+\\epsilon}$。\n所以，特征向量分量的通解是：\n$$\nv_i = v_0 \\frac{\\lambda-1}{\\lambda-1+\\epsilon} \\left(\\frac{\\lambda}{1-\\epsilon}\\right)^i + v_0 \\frac{\\epsilon}{\\lambda-1+\\epsilon}\n$$\n这也必须满足方程组的最后一个方程 $v_0 = \\lambda v_{m-1}$。代入 $i=m-1$ 并除以 $v_0$（假设 $v_0 \\neq 0$）：\n$$\n1 = \\lambda \\left[ \\frac{\\lambda-1}{\\lambda-1+\\epsilon} \\left(\\frac{\\lambda}{1-\\epsilon}\\right)^{m-1} + \\frac{\\epsilon}{\\lambda-1+\\epsilon} \\right]\n$$\n乘以 $\\lambda-1+\\epsilon$：\n$$\n\\lambda-1+\\epsilon = \\lambda (\\lambda-1) \\left(\\frac{\\lambda}{1-\\epsilon}\\right)^{m-1} + \\lambda\\epsilon\n$$\n$$\n(\\lambda-1) - \\epsilon(\\lambda-1) = (\\lambda-1) \\frac{\\lambda^m}{(1-\\epsilon)^{m-1}}\n$$\n$$\n(\\lambda-1)(1-\\epsilon) = (\\lambda-1) \\frac{\\lambda^m}{(1-\\epsilon)^{m-1}}\n$$\n这个方程有两种类型的解。\n第一种，如果 $\\lambda-1 = 0$，则 $\\lambda=1$。这是 Perron-Frobenius 特征值，任何随机矩阵都必须存在该特征值。\n第二种，如果 $\\lambda \\neq 1$，我们可以除以 $(\\lambda-1)$：\n$$\n1-\\epsilon = \\frac{\\lambda^m}{(1-\\epsilon)^{m-1}} \\implies \\lambda^m = (1-\\epsilon)^m\n$$\n这个方程的解是 $\\lambda_k = (1-\\epsilon)\\omega^k$，其中 $k \\in \\{0, 1, \\dots, m-1\\}$，$\\omega = \\exp(2\\pi i/m)$ 是一个 $m$ 次单位主根。\n$k=0$ 的解是 $\\lambda_0 = 1-\\epsilon$。然而，我们已经证明了 $\\lambda=1-\\epsilon$ 不是一个特征值，因为它会导致矛盾。这个增根的出现是因为我们对 $v_i$ 的推导假设了 $\\lambda-1+\\epsilon \\neq 0$。\n因此，特征值为 $\\lambda=1$ 和 $\\lambda_k = (1-\\epsilon)\\omega^k$，其中 $k \\in \\{1, 2, \\dots, m-1\\}$。这给出了一整套 $m$ 个不同的特征值。\n\n弛豫时间 $\\tau_{\\mathrm{rel}}$ 由第二大特征值模 (SLEM) 定义，它是除 Perron 根 $\\lambda=1$ 之外所有特征值的最大模。\n除 $1$ 以外的特征值是 $\\lambda_k = (1-\\epsilon)\\omega^k$，其中 $k=1, \\dots, m-1$。\n我们计算它们的模：\n$$\n|\\lambda_k| = |(1-\\epsilon)\\omega^k| = |1-\\epsilon| \\cdot |\\omega^k|\n$$\n由于 $\\epsilon \\in (0,1)$，所以 $|1-\\epsilon| = 1-\\epsilon$。由于 $\\omega^k$ 是单位根，所以 $|\\omega^k|=1$。\n所以，对于所有 $k \\in \\{1, \\dots, m-1\\}$，都有 $|\\lambda_k| = 1-\\epsilon$。\nSLEM 是 $\\max_{k \\in \\{1, \\dots, m-1\\}} |\\lambda_k| = 1-\\epsilon$。\n\n那么弛豫时间是：\n$$\n\\tau_{\\mathrm{rel}} = \\frac{1}{1 - \\mathrm{SLEM}} = \\frac{1}{1 - (1-\\epsilon)} = \\frac{1}{\\epsilon}\n$$\n\n结果摘要：\n1.  基准周期：$m$。\n2.  修改后周期：$1$。\n3.  修改后弛豫时间：$1/\\epsilon$。", "answer": "$$\n\\boxed{\\begin{pmatrix} m  1  \\frac{1}{\\epsilon} \\end{pmatrix}}\n$$", "id": "3329433"}, {"introduction": "在实际的蒙特卡洛模拟中，转移矩阵可能是未知的或过于复杂以至于无法预先分析。本练习挑战你设计一个智能的自适应算法，能够“实时”诊断周期性。你将实现一个流式检测器，它监控模拟路径的返回时间，并在检测到周期性时自动切换到链的“惰性”版本，以确保非周期性和稳健的收敛性。[@problem_id:3329404]", "problem": "考虑一个在有限状态空间 $\\mathcal{S} = \\{0,1,\\dots, n-1\\}$ 上的离散时间、时齐马尔可夫链，其转移矩阵为 $P \\in \\mathbb{R}^{n \\times n}$，其中对所有 $i \\in \\mathcal{S}$，都有 $P(i,j) \\geq 0$ 且 $\\sum_{j=0}^{n-1} P(i,j) = 1$。状态 $i$ 的周期，记为 $d(i)$，定义为所有使得从 $i$ 到其自身的 $n$ 步转移概率为正的正整数 $n$ 的最大公约数，即\n$$\nd(i) = \\gcd\\{\\, n \\in \\mathbb{N} \\,:\\, (P^n)(i,i)  0 \\, \\}.\n$$\n如果 $d(i)=1$，则状态 $i$ 是非周期的。如果一个马尔可夫链的所有状态都是非周期的（等价地，一个互通类中的所有状态的周期都为 $1$），则该马尔可夫链是非周期的。\n\n在流式模拟中，通常不直接计算 $(P^n)(i,i)$。取而代之的是，可以通过跟踪观测到的返回各个状态的时间来在线检测周期性。假设该链生成一条路径 $X_0, X_1, \\dots, X_T$，其中 $X_t \\in \\mathcal{S}$。对每个状态 $i$，记录其访问时间 $\\tau_0^{(i)}, \\tau_1^{(i)}, \\dots$，在这些时间点 $X_{\\tau_k^{(i)}} = i$，并定义观测到的返回间隔\n$$\nR_k^{(i)} = \\tau_k^{(i)} - \\tau_{k-1}^{(i)} \\quad \\text{for } k \\geq 1.\n$$\n使用最大公约数运算，通过以下递归方式为周期估计值 $d(i)$ 定义一个流式更新\n$$\nd(i) \\leftarrow \\gcd\\big(d(i), R_k^{(i)}\\big),\n$$\n初始化为 $d(i) \\leftarrow 0$，并约定 $\\gcd(0, r) = r$。为减少有限样本效应带来的假阳性，要求在宣布一个状态是周期性之前，至少已观测到两次返回该状态 $i$（即至少三次访问，从而至少有两个间隔 $R_k^{(i)}$ 已被计入）。当任何状态 $i$ 在此流式更新下满足 $d(i) > 1$ 并且至少有两次观测到的返回时，触发切换到惰性核。\n\n惰性核 $P_{\\ell}$ 定义为\n$$\nP_{\\ell} = \\tfrac{1}{2}\\,I + \\tfrac{1}{2}\\,P,\n$$\n其中 $I$ 是单位矩阵。在模拟时，惰性核意味着：以概率 $\\tfrac{1}{2}$ 停留在当前状态，以概率 $\\tfrac{1}{2}$ 根据 $P$ 进行转移。已知这种修改会产生一个非周期链，并保持 $P$ 的平稳分布。\n\n任务：设计并实现一个程序，该程序能够\n- 对每个测试用例，使用 $P$ 模拟一条路径 $X_0, X_1, \\dots, X_T$，从指定的初始状态 $X_0$ 开始，并在检测到任何状态 $i$ 满足 $d(i) > 1$ 且至少有两次观测返回时，立即切换到惰性核 $P_{\\ell}$。\n- 对所有状态 $i \\in \\mathcal{S}$，仅使用上述观测到的返回间隔来维护流式估计值 $d(i)$。\n- 对每个测试用例，报告一个布尔标志，指示是否发生了向 $P_{\\ell}$ 的切换；对于触发切换的状态，报告在切换瞬间的整数值 $d(i)$（如果没有发生切换则使用 $0$）；以及在模拟结束后所有状态最终 $d(i)$ 值中的整数最大值（如果某个状态从未被再次访问，其 $d(i)$ 保持为 $0$，则使用 $0$）。\n\n您必须在马尔可夫链蒙特卡洛 (MCMC) 的背景下实现此检测器和切换机制，此处理解为从马尔可夫链核进行模拟；当惰性核启用时，通过将恒等转移与根据 $P$ 的转移按指定方式混合来模拟下一步。\n\n测试套件：\n- 案例1 (周期为2的双状态链): $P = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}$，$n = 2$，$T = 50$，初始状态 $X_0 = 0$。该链的状态周期为 $2$。\n- 案例2 (非周期双状态链): $P = \\begin{pmatrix} 0.7  0.3 \\\\ 0.4  0.6 \\end{pmatrix}$，$n = 2$，$T = 400$，初始状态 $X_0 = 0$。该链是不可约且非周期的，每个状态的周期为 $1$。使用固定的随机种子以确保可复现性。\n- 案例3 (周期为3的三状态环): $P = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{pmatrix}$，$n = 3$，$T = 60$，初始状态 $X_0 = 0$。该链的状态周期为 $3$。\n- 案例4 (短时运行且未返回起点): $P = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\\\ 1  0  0  0 \\end{pmatrix}$，$n = 4$，$T = 3$，初始状态 $X_0 = 0$。运行时间太短，无法重新访问起始点，因此流式 $d(i)$ 可能保持为 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起的逗号分隔列表。每个元素对应一个测试用例，并且必须是 $[\\text{toggle\\_flag}, d_{\\text{at\\_toggle}}, \\max\\_d_{\\text{final}}]$ 的形式，其中 $\\text{toggle\\_flag}$ 是一个布尔值，而 $d_{\\text{at\\_toggle}}$ 和 $\\max\\_d_{\\text{final}}$ 是整数。例如：$[[True, 2, 1], [False, 0, 1], \\dots]$。\n\n不涉及物理单位，不适用角度，也不需要百分比；所有数值答案必须按规定表示为整数或布尔值。", "solution": "设计一个用于检测马尔可夫链周期性的流式检测器并切换到惰性核的问题是有效的。它在科学上基于随机过程和马尔可夫链蒙特卡洛 (MCMC) 方法的理论，问题定义良好，有清晰的算法描述，并使用标准的数学形式主义客观地陈述。该问题是自包含的，并为指定的测试用例提供了所有必要的数据。\n\n该解决方案涉及模拟一个离散时间马尔可夫链，并为每个状态维护其周期的在线估计。每次返回该状态时，此估计值都会更新。如果某个状态的估计周期变得大于1，并且已收集到足够的证据（至少两次返回），则通过从原始转移核 $P$ 切换到惰性核 $P_{\\ell}$ 来改变模拟动态。此过程执行固定的步数 $T$，并报告检测器的最终状态。\n\n### 1. 算法框架\n\n路径 $X_0, X_1, \\dots, X_T$ 的模拟是迭代执行的。对于从 $1$ 到 $T$ 的每个时间步 $t$，下一个状态 $X_t$ 是基于当前状态 $X_{t-1}$ 和活动的转移核进行采样的。我们必须维护几个数据结构来跟踪每个状态 $i \\in \\mathcal{S} = \\{0, 1, \\dots, n-1\\}$ 的必要信息：\n\n- **上次访问时间, $\\text{last\\_visit\\_time}[i]$**: 存储最近一次访问状态 $i$ 的时间步。对于 $i \\neq X_0$ 初始化为 $-1$，对于 $i=X_0$ 初始化为 $0$。\n- **访问次数, $\\text{visit\\_counts}[i]$**: 统计对状态 $i$ 的总访问次数。对所有 $i$ 初始化为 $0$，每次访问时递增。初始状态 $X_0$ 的计数从 $1$ 开始。\n- **估计周期, $d[i]$**: 状态 $i$ 周期的流式估计值。对所有 $i$ 初始化为 $0$。\n\n一个全局布尔标志 `toggle_flag` 初始化为 `False`，如果满足切换条件，则永久设置为 `True`。\n\n### 2. 模拟步骤与状态转移\n\n在每个时间步 $t \\in \\{1, \\dots, T\\}$，模拟按以下方式进行：\n\n1.  **选择核**: 转移核的选择取决于 `toggle_flag`：\n    - 如果 `toggle_flag` 为 `False`，则使用标准转移矩阵 $P$。下一个状态 $X_t$ 从由行 $P(X_{t-1}, \\cdot)$ 给出的概率分布中抽取。\n    - 如果 `toggle_flag` 为 `True`，则使用惰性核 $P_{\\ell} = \\tfrac{1}{2}I + \\tfrac{1}{2}P$。这通过抽取一个均匀随机数 $u \\in [0,1)$ 来实现。如果 $u  0.5$，链保持在当前状态（$X_t = X_{t-1}$）。否则（如果 $u \\ge 0.5$），下一个状态 $X_t$ 从分布 $P(X_{t-1}, \\cdot)$ 中抽取。\n\n2.  **更新状态**: 链的当前状态更新为 $X_t$。\n\n对于确定性情况（其中 $P$ 中的概率仅为 $0$ 或 $1$），“抽取”仅是选择转移概率为 $1$ 的唯一状态。对于随机情况，使用随机数生成器。为确保所有模拟的可复现性，在程序开始时设置一个固定的随机种子。\n\n### 3. 周期性检测与切换\n\n在时间 $t$ 转移到新状态 $X_t = i$ 后，更新状态 $i$ 的跟踪变量。\n\n1.  **更新访问数据**: `visit_counts[i]` 递增。如果这是一次返回访问（即 `visit_counts[i] > 1`），则观测到的返回间隔 $R^{(i)}$ 计算为当前时间 $t$ 与 `last_visit_time[i]` 之间的差值。\n\n2.  **更新周期估计**: 使用最大公约数 (GCD) 运算更新估计周期 $d[i]$：\n    $$\n    d[i] \\leftarrow \\gcd(d[i], R^{(i)})\n    $$\n    初始值为 $d[i]=0$，我们使用约定 $\\gcd(0, r) = r$（对于任何正整数 $r$）。这确保了第一个观测到的返回间隔会初始化周期估计值。\n\n3.  **更新上次访问时间**: `last_visit_time[i]` 设置为当前时间 $t$。\n\n4.  **检查切换条件**: 如果 `toggle_flag` 仍为 `False`，我们检查当前状态 $i=X_t$ 是否满足切换条件：\n    - 估计周期 $d[i]$ 大于 $1$。\n    - 状态 $i$ 至少发生了两次返回，这等价于总访问次数 `visit_counts[i]` 至少为 $3$。\n\n    如果两个条件都满足，`toggle_flag` 设置为 `True`，并将在此时的 $d[i]$ 值记录为 $d_{\\text{at\\_toggle}}$。从下一步 ($t+1$) 开始，模拟将使用惰性核 $P_{\\ell}$。\n\n### 4. 最终输出生成\n\n在模拟运行 $T$ 步之后，该测试用例的结果被编译成一个列表 $[\\text{toggle\\_flag}, d_{\\text{at\\_toggle}}, \\max\\_d_{\\text{final}}]$。\n- `toggle_flag`: 布尔标志的最终状态，指示是否发生切换。\n- $d_{\\text{at\\_toggle}}$: 触发切换的状态在其发生切换瞬间的周期估计值。如果没有发生切换，此值为 $0$。\n- $\\max\\_d_{\\text{final}}$: 所有最终估计周期 $\\{d[0], d[1], \\dots, d[n-1]\\}$ 中的最大值。如果一个状态从未被再次访问，其周期估计值保持为其初始值 $0$。\n\n对问题陈述中提供的每个测试用例重复这整个过程。然后将收集到的结果格式化为所需的单行字符串输出。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # A single fixed random seed for reproducibility of all stochastic parts.\n    np.random.seed(42)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"P\": np.array([[0, 1], [1, 0]], dtype=float),\n            \"n\": 2,\n            \"T\": 50,\n            \"X0\": 0,\n        },\n        {\n            \"P\": np.array([[0.7, 0.3], [0.4, 0.6]], dtype=float),\n            \"n\": 2,\n            \"T\": 400,\n            \"X0\": 0,\n        },\n        {\n            \"P\": np.array([[0, 1, 0], [0, 0, 1], [1, 0, 0]], dtype=float),\n            \"n\": 3,\n            \"T\": 60,\n            \"X0\": 0,\n        },\n        {\n            \"P\": np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [1, 0, 0, 0]], dtype=float),\n            \"n\": 4,\n            \"T\": 3,\n            \"X0\": 0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case[\"P\"], case[\"n\"], case[\"T\"], case[\"X0\"])\n        results.append(result)\n\n    # Format the results into the exact required string format.\n    formatted_results = [f\"[{'True' if r[0] else 'False'},{r[1]},{r[2]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(P, n, T, X0):\n    \"\"\"\n    Simulates a Markov chain with an online periodicity detector.\n\n    Args:\n        P (np.ndarray): The transition matrix.\n        n (int): The number of states.\n        T (int): The total number of simulation steps (path length will be T+1).\n        X0 (int): The initial state.\n\n    Returns:\n        list: A list containing [toggle_flag, d_at_toggle, max_d_final].\n    \"\"\"\n    current_state = X0\n    \n    # Data structures for tracking state visits and period estimates\n    last_visit_time = {i: -1 for i in range(n)}\n    visit_counts = {i: 0 for i in range(n)}\n    estimated_periods = {i: 0 for i in range(n)}\n    \n    # Output variables\n    toggle_flag = False\n    d_at_toggle = 0\n    \n    # Process initial state at t=0\n    last_visit_time[X0] = 0\n    visit_counts[X0] = 1\n    \n    states_range = np.arange(n)\n\n    for t in range(1, T + 1):\n        # 1. Determine next state based on the active kernel\n        if toggle_flag:\n            # Lazy kernel P_l = 0.5*I + 0.5*P\n            if np.random.rand()  0.5:\n                next_state = current_state\n            else:\n                p_dist = P[current_state]\n                next_state = np.random.choice(states_range, p=p_dist)\n        else:\n            # Standard kernel P\n            p_dist = P[current_state]\n            next_state = np.random.choice(states_range, p=p_dist)\n\n        current_state = next_state\n        \n        # 2. Update statistics for the newly visited state\n        i = current_state\n        \n        # Check if it's a return visit to update period estimate\n        if visit_counts[i] > 0:\n            return_interval = t - last_visit_time[i]\n            \n            # The streaming GCD update. math.gcd(0, r) = r, fulfilling the requirement.\n            old_d = estimated_periods[i]\n            if return_interval > 0:\n                estimated_periods[i] = math.gcd(old_d, return_interval)\n\n        last_visit_time[i] = t\n        visit_counts[i] += 1\n\n        # 3. Check for toggle condition if not already toggled\n        if not toggle_flag:\n            # Condition: d(i) > 1 AND at least 2 returns (i.e., 3 visits)\n            num_returns = visit_counts[i] - 1\n            if num_returns >= 2 and estimated_periods[i] > 1:\n                toggle_flag = True\n                d_at_toggle = estimated_periods[i]\n                \n    # 4. Finalize results after the simulation ends\n    max_d_final = 0\n    if estimated_periods:\n        max_d_final = max(estimated_periods.values())\n\n    return [toggle_flag, d_at_toggle, max_d_final]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3329404"}]}