{"hands_on_practices": [{"introduction": "在许多由表面张力驱动的物理现象中，精确计算界面的曲率 $\\kappa$ 至关重要。然而，在计算区域的边界附近，标准的有限差分法会遇到挑战。本练习将引导你通过理论推导，设计一种适用于 Neumann 边界条件的“幽灵节点”格式，以确保在壁面处的曲率计算达到二阶精度，这是保证数值模拟稳定性和准确性的核心技能之一。[@problem_id:3607078]", "problem": "在计算地球物理学中，诸如岩浆前缘或盐水入侵舌等移动界面通常由一个标量水平集函数 $\\phi(x,y)$ 来表示，其零水平集描绘了前进的边界。水平集的平均曲率 $\\kappa$ 定义为单位法向量场 $\\,\\mathbf{n} = \\nabla \\phi / |\\nabla \\phi|\\,$ 的散度，即 $\\kappa = \\nabla \\cdot \\mathbf{n}$。在不可渗透壁面附近精确计算 $\\kappa$ 需要仔细处理边界条件和虚拟节点模板，以确保离散近似保持二阶精度。\n\n考虑一个二维笛卡尔网格，其在 $y$ 方向上的间距均匀为 $h$，在 $y=0$ 处有一个壁面，内部节点位于 $y_j = j h$（其中 $j \\geq 0$）。假设 $\\phi$ 是光滑的，并且在靠近壁面的一个局部邻域内，其形式为\n$$\n\\phi(x,y) = y + a y^{2} + s x,\n$$\n其中常数 $a$ 和 $s$ 分别表示壁面法向上的局部二次变化和壁面切向上的均匀梯度。这个通用的局部模型旨在揭示曲率对壁面法向二阶导数的敏感性以及切向梯度的作用。\n\n为了使用二阶中心差分在壁面节点 $(x_i,y_0)$ 处近似 $\\kappa$，需要一个位于 $y=-h$ 处的虚拟值 $\\phi_{i,-1}$。假设在 $y=0$ 处施加了壁面法向诺伊曼(Neumann)边界条件：\n$$\n\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = g,\n$$\n其中对于给定的 $\\phi$，$g$ 等于精确值 $\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0}$。提出一族形式如下的单虚拟节点诺伊曼(Neumann)模板\n$$\n\\phi_{i,-1} = \\phi_{i,1} - m\\, h\\, g,\n$$\n其中 $m$ 是一个待定常数，其取值需使得在 $(x_i,y_0)$ 处由 $\\phi$ 计算出的离散曲率 $\\kappa$ 在 $h$ 上保持二阶精度。\n\n从几何定义 $\\kappa = \\nabla \\cdot \\left( \\nabla \\phi / |\\nabla \\phi| \\right)$ 出发，并在 $x$ 和 $y$ 方向上均使用二阶中心差分，分析上述诺伊曼(Neumann)虚拟节点模板对计算曲率所需的离散壁面法向二阶导数的影响。对于给定的局部模型 $\\phi(x,y) = y + a y^{2} + s x$，推导标量 $m$ 的唯一值，该值能够消除 $\\mathcal{O}(h^{-1})$ 阶的污染，并确保在壁面节点处的离散曲率具有二阶精度。\n\n将 $m$ 的最终答案表示为单个实数。无需四舍五入。无需单位。", "solution": "问题要求我们确定在用于诺伊曼(Neumann)边界条件的虚拟节点模板中的常数 $m$ 的值，以使得平均曲率 $\\kappa$ 的有限差分近似在壁面处达到二阶精度。\n\n水平集 $\\phi(x,y)=C$ 的平均曲率 $\\kappa$ 由单位法向量 $\\mathbf{n} = \\nabla \\phi / |\\nabla \\phi|$ 的散度给出。其完整表达式为：\n$$\n\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right) = \\frac{\\phi_{xx} \\phi_y^2 - 2 \\phi_x \\phi_y \\phi_{xy} + \\phi_{yy} \\phi_x^2}{(\\phi_x^2 + \\phi_y^2)^{3/2}}\n$$\n其中下标表示偏导数（例如，$\\phi_x = \\frac{\\partial \\phi}{\\partial x}$，$\\phi_{yy} = \\frac{\\partial^2 \\phi}{\\partial y^2}$）。\n\n我们被要求在壁面节点 $(x_i, y_0)$（其中 $y_0=0$）处评估 $\\kappa$ 的离散近似。问题指定使用二阶中心差分。主要的挑战在于在边界 $y=0$ 处近似导数，这需要一个在域外的“虚拟”节点上的值 $\\phi_{i,-1} = \\phi(x_i, -h)$。\n\n提供的水平集函数的局部模型是：\n$$\n\\phi(x,y) = y + a y^{2} + s x\n$$\n在 $y=0$ 处的诺伊曼(Neumann)边界条件是 $\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = g$。我们可以从给定的 $\\phi(x,y)$ 精确计算出 $g$：\n$$\n\\frac{\\partial \\phi}{\\partial y} = 1 + 2ay\n$$\n$$\ng = \\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{y=0} = 1 + 2a(0) = 1\n$$\n\n提出的虚拟节点模板是：\n$$\n\\phi_{i,-1} = \\phi_{i,1} - m h g\n$$\n由于 $g=1$，这可以简化为 $\\phi_{i,-1} = \\phi_{i,1} - m h$。\n\n问题指出，离散曲率中的 $\\mathcal{O}(h^{-1})$ 阶污染源于壁面法向二阶导数 $\\phi_{yy}$。让我们分析在壁面节点 $(x_i, y_0=0)$ 处 $\\phi_{yy}$ 的中心差分近似。令 $\\tilde{\\phi}_{yy}$ 表示该离散近似。\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{\\phi(x_i, h) - 2\\phi(x_i, 0) + \\phi(x_i, -h)}{h^2} = \\frac{\\phi_{i,1} - 2\\phi_{i,0} + \\phi_{i,-1}}{h^2}\n$$\n将虚拟节点模板 $\\phi_{i,-1} = \\phi_{i,1} - m h g$ 代入此表达式中：\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{\\phi_{i,1} - 2\\phi_{i,0} + (\\phi_{i,1} - m h g)}{h^2} = \\frac{2\\phi_{i,1} - 2\\phi_{i,0} - m h g}{h^2}\n$$\n为分析此近似的精度，我们对 $\\phi_{i,1} = \\phi(x_i, h)$ 在点 $(x_i, 0)$ 附近进行泰勒级数展开：\n$$\n\\phi(x_i, h) = \\phi(x_i, 0) + h \\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{(x_i,0)} + \\frac{h^2}{2} \\left.\\frac{\\partial^2 \\phi}{\\partial y^2}\\right|_{(x_i,0)} + \\mathcal{O}(h^3)\n$$\n使用记号 $\\phi_{i,0} = \\phi(x_i, 0)$、$\\left.\\frac{\\partial \\phi}{\\partial y}\\right|_{(x_i,0)} = g$ 和 $\\left.\\frac{\\partial^2 \\phi}{\\partial y^2}\\right|_{(x_i,0)} = \\phi_{yy}(x_i,0)$，我们得到：\n$$\n\\phi_{i,1} = \\phi_{i,0} + h g + \\frac{h^2}{2}\\phi_{yy}(x_i,0) + \\mathcal{O}(h^3)\n$$\n现在，将此展开式代回 $\\tilde{\\phi}_{yy}$ 的表达式中：\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{2\\left(\\phi_{i,0} + h g + \\frac{h^2}{2}\\phi_{yy}(x_i,0) + \\mathcal{O}(h^3)\\right) - 2\\phi_{i,0} - m h g}{h^2}\n$$\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{2\\phi_{i,0} + 2hg + h^2\\phi_{yy}(x_i,0) - 2\\phi_{i,0} - mhg + \\mathcal{O}(h^3)}{h^2}\n$$\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\frac{(2-m)hg + h^2\\phi_{yy}(x_i,0) + \\mathcal{O}(h^3)}{h^2}\n$$\n$$\n\\tilde{\\phi}_{yy}(x_i, 0) = \\phi_{yy}(x_i,0) + \\frac{(2-m)g}{h} + \\mathcal{O}(h)\n$$\n二阶导数的精确值为 $\\phi_{yy}(x_i,0)$。我们近似的误差是 $\\tilde{\\phi}_{yy}(x_i, 0) - \\phi_{yy}(x_i,0) = \\frac{(2-m)g}{h} + \\mathcal{O}(h)$。\n\n此表达式清楚地显示了一个 $\\mathcal{O}(h^{-1})$ 阶的误差项，这正是问题中提到的污染。除非该项被消除，否则随着网格间距 $h$ 的减小，它将导致数值解发散。为消除此项，其系数必须为零：\n$$\n(2-m)g = 0\n$$\n正如我们所计算的，$g=1$。由于 $g \\neq 0$，我们必须有：\n$$\n2 - m = 0 \\implies m = 2\n$$\n这是消除 $\\mathcal{O}(h^{-1})$ 阶污染的唯一 $m$ 值。\n当 $m=2$ 时，二阶导数的近似变为 $\\tilde{\\phi}_{yy}(x_i, 0) = \\phi_{yy}(x_i,0) + \\mathcal{O}(h)$，这是一个一阶精度的近似。\n\n对于特定的 $\\phi(x,y)=y+ay^2+sx$，我们有 $\\phi_{yyy} = 0$，因此 $\\phi_{i,1}$ 的泰勒展开终止，$\\mathcal{O}(h^3)$ 项为零。这使得当 $m=2$ 时，$\\phi_{yy}$ 的近似是精确的：$\\tilde{\\phi}_{yy} = \\phi_{yy} = 2a$。\n此外，对于这个特定的多项式，$\\phi_x, \\phi_{xx}, \\phi_{xy}$ 的中心差分近似是精确的。当 $m=2$ 时，近似 $\\tilde{\\phi}_y = \\frac{\\phi_{i,1}-\\phi_{i,-1}}{2h} = \\frac{mhg}{2h} = \\frac{2(1)(1)}{2}=1$ 也是精确的。由于曲率公式中的所有导数都被精确近似，离散曲率 $\\tilde{\\kappa}$ 将等于精确曲率 $\\kappa$。零误差自然是 $\\mathcal{O}(h^2)$ 阶的，因此满足了二阶精度的要求。\n\n关键步骤，也是问题的明确要求，是消除 $\\mathcal{O}(h^{-1})$ 项，这唯一地确定了 $m$。\n$m$ 的值为 $2$。", "answer": "$$\\boxed{2}$$", "id": "3607078"}, {"introduction": "地球物理问题常常涉及具有不同物理属性（如热导率或地震波速）的多种材料。当界面移动时，精确地在界面两侧施加正确的物理条件是一个关键挑战。本练习将通过一个热传导问题，让你亲手实现幽灵流体法（Ghost-Fluid Method, GFM），这是一种强大的技术，用于在由水平集函数隐式定义的界面上处理不连续性。[@problem_id:3607108]", "problem": "考虑沿空间坐标为 $x \\in [0,L]$ 的线段上的一维热传导问题，其稳态下的未知温度场为 $T(x)$。材料的热导率是不连续的，由一个水平集函数 $\\phi(x,t)$ 描述，该函数在 $\\phi=0$ 处确定一个移动界面。在本问题中，界面位置为 $x=s(t)$，水平集函数为 $\\phi(x,t)=x-s(t)$。热导率是分段常数：当 $x  s$ 时为 $k_{-}$，当 $x > s$ 时为 $k_{+}$。在界面 $x=s(t)$ 处，温度场和热通量都是连续的。整个区域受狄利克雷边界条件 $T(0)=T_0$ 和 $T(L)=T_L$ 的约束。\n\n您的任务是实现一个一维有限体积求解器，使用幽灵流体法（GFM）来处理热导率的不连续性。具体来说，对于跨越界面的控制体单元面，您需要推导并实现一个有效的热导，该热导能够精确地满足界面处的物理条件。您的实现应能处理界面位于任意位置（包括恰好在节点上或非常靠近节点）的情况。\n\n使用一个具有 $N$ 个节点的均匀网格，网格间距为 $\\Delta x = L/(N-1)$。在您的程序中，对于给定的五个测试用例，计算数值解与精确解析解之间的最大绝对误差 $\\max_{i}|T_i^{\\text{numerical}} - T_i^{\\text{exact}}|$。您的程序应输出一个包含五个误差值的列表，每个值对应一个测试用例。\n\n**测试用例**（每个案例指定 $L, N, k_-, k_+, s, T_0, T_L$）：\n1.  $L=1.0, N=129, k_-=1.0, k_+=5.0, s=0.37, T_0=0.0, T_L=1.0$\n2.  $L=1.0, N=129, k_-=1.0, k_+=10.0, s=0.5, T_0=100.0, T_L=300.0$\n3.  $L=1.0, N=257, k_-=0.1, k_+=1000.0, s=0.8, T_0=10.0, T_L=11.0$\n4.  $L=1.0, N=129, k_-=2.0, k_+=2.0, s=0.499, T_0=0.0, T_L=1.0$\n5.  $L=1.0, N=129, k_-=0.5, k_+=3.5, s=0.02, T_0=0.0, T_L=1.0$\n\n将您的最终答案格式化为方括号内由逗号分隔的浮点数列表，例如 `[1.23e-15, 2.34e-15, ...]`。", "solution": "### 1. 理论框架\n\n#### 1.1. 精确解析解\n该问题描述了由方程 $\\frac{d}{dx}\\left(k(x)\\frac{dT}{dx}\\right)=0$ 控制的一维稳态热传导。对该方程积分一次可得，热通量 $q(x) = -k(x)\\frac{dT}{dx}$ 在整个区域 $x \\in [0, L]$ 内必须为常数。设该恒定通量为 $q_c$。\n\n热导率 $k(x)$ 是分段常数，在界面 $x=s$ 处存在不连续性：\n$$\nk(x) = \\begin{cases} k_{-},  x  s \\\\ k_{+},  x > s \\end{cases}\n$$\n对傅里叶定律 $dT/dx = -q_c/k(x)$ 进行积分，得到分段线性的温度分布。\n对于 $x \\in [0, s]$，应用边界条件 $T(0)=T_0$：\n$$ T(x) = T_0 - \\frac{q_c}{k_{-}}x $$\n界面处的温度为 $T(s) = T_0 - \\frac{q_c s}{k_{-}}$。由于温度的连续性，该值被用作第二个区域的起始点。\n对于 $x \\in [s, L]$：\n$$ T(x) = T(s) - \\frac{q_c}{k_{+}}(x-s) = \\left(T_0 - \\frac{q_c s}{k_{-}}\\right) - \\frac{q_c}{k_{+}}(x-s) $$\n应用边界条件 $T(L)=T_L$：\n$$ T_L = T_0 - q_c \\left( \\frac{s}{k_{-}} + \\frac{L-s}{k_{+}} \\right) $$\n括号中的项是复合材料的总热阻，即两个部分串联热阻之和：$R_{total} = \\frac{s}{k_{-}} + \\frac{L-s}{k_{+}}$。\n求解恒定通量 $q_c$：\n$$ q_c = - \\frac{T_L - T_0}{R_{total}} = - \\frac{T_L - T_0}{\\frac{s}{k_{-}} + \\frac{L-s}{k_{+}}} $$\n已知 $q_c$ 后，可以计算任意点的精确温度 $T_{\\mathrm{exact}}(x)$。这可作为我们数值解的基准。\n\n#### 1.2. 鬼点法 (GFM) 和界面通量\n我们被要求使用 GFM 论证来推导跨越界面的控制体面上的通量。考虑一个均匀网格 $x_i = i\\Delta x$ 以及两个相邻节点 $x_j$ 和 $x_{j+1}$，使得界面位于它们之间：$x_j  s  x_{j+1}$。温度和通量连续性的物理原理必须在 $x=s$ 处成立。\n\n假设温度分布局部线性，恒定通量 $q_c$ 可以从界面的左右两侧近似得到：\n来自左侧的通量，使用位于 $x_j$ 的节点 $T_j$ 和位于 $x=s$ 的未知界面温度 $T_s$：\n$$ q_c \\approx -k_{-} \\frac{T_s - T_j}{s - x_j} $$\n来自右侧的通量，使用位于 $x_{j+1}$ 的节点 $T_{j+1}$ 和位于 $x=s$ 的 $T_s$：\n$$ q_c \\approx -k_{+} \\frac{T_{j+1} - T_s}{x_{j+1} - s} $$\n通过令这两个表达式相等来强制通量连续，我们可以求解界面温度 $T_s$：\n$$ k_{-} \\frac{T_s - T_j}{s - x_j} = k_{+} \\frac{T_{j+1} - T_s}{x_{j+1} - s} \\implies T_s = \\frac{k_{-}(x_{j+1}-s)T_j + k_{+}(s-x_j)T_{j+1}}{k_{-}(x_{j+1}-s) + k_{+}(s-x_j)} $$\n将此 $T_s$ 代回任一通量近似式，可得到节点 $j$ 和 $j+1$ 之间的期望通量，记为 $q_{j+1/2}$：\n$$ q_{j+1/2} = -k_{-} \\frac{1}{s-x_j} \\left( \\frac{k_{-}(x_{j+1}-s)T_j + k_{+}(s-x_j)T_{j+1}}{k_{-}(x_{j+1}-s) + k_{+}(s-x_j)} - T_j \\right) $$\n经过代数化简，得到：\n$$ q_{j+1/2} = - \\left( \\frac{k_{-}k_{+}}{k_{+}(s-x_j) + k_{-}(x_{j+1}-s)} \\right) (T_{j+1} - T_j) $$\n此表达式等效于一个串联热阻模型。乘以温差的分数的分母是节点间的总热阻：$R_{j,j+1} = \\frac{s-x_j}{k_{-}} + \\frac{x_{j+1}-s}{k_{+}}$。因此，数值通量为 $q_{j+1/2} = -\\frac{T_{j+1}-T_j}{R_{j,j+1}}$。这个单元对的有效热导为 $C^{\\text{eff}}_{j+1/2} = 1/R_{j,j+1}$。\n\n### 2. 数值实现\n\n我们使用以节点为中心的有限体积法。对于一个内部节点 $i$（从 $i=1$ 到 $N-2$），控制体为 $[x_{i-1/2}, x_{i+1/2}]$，其中 $x_{i\\pm1/2} = (x_i+x_{i\\pm1})/2$。在该控制体上对守恒定律进行积分，得到通量平衡：\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\frac{d}{dx}q(x) dx = q(x_{i+1/2}) - q(x_{i-1/2}) = 0 $$\n面上的通量近似为 $q_{i+1/2} = -C_{i+1/2}(T_{i+1}-T_i)$，其中 $C_{i+1/2}$ 是节点 $i$ 和 $i+1$ 之间的热导。\n节点 $i$ 的方程为：\n$$ -C_{i-1/2}(T_i - T_{i-1}) - (-C_{i+1/2}(T_{i+1} - T_i)) = 0 $$\n$$ C_{i-1/2}T_{i-1} - (C_{i-1/2} + C_{i+1/2})T_i + C_{i+1/2}T_{i+1} = 0 $$\n热导 $C_{i+1/2}$ 取决于界面 $s$ 是否位于区间 $(x_i, x_{i+1})$ 内：\n- **无界面：** 如果区间 $(x_i, x_{i+1})$ 内的热导率 $k$ 为常数（若 $x_{i+1/2}  s$ 则为 $k_{-}$，若 $x_{i+1/2} > s$ 则为 $k_{+}$），则标准热导为 $C_{i+1/2} = k / \\Delta x$。\n- **存在界面：** 如果 $x_i  s  x_{i+1}$，则热导为从 GFM 推导出的有效热导：$C_{i+1/2} = C^{\\text{eff}}_{i+1/2} = \\left(\\frac{s-x_i}{k_{-}} + \\frac{x_{i+1}-s}{k_{+}}\\right)^{-1}$。\n\n这些关于 $i=1, \\dots, N-2$ 的方程，连同狄利克雷边界条件 $T_0=T_0$ 和 $T_{N-1}=T_L$，构成一个关于节点温度向量 $\\mathbf{T} = [T_0, \\dots, T_{N-1}]^T$ 的 $N \\times N$ 三对角线性系统 $A\\mathbf{T}=\\mathbf{b}$。求解该系统即可得到数值解。\n\n### 3. 误差计算\n由于数值格式是作为连续问题（其解为分段线性）的精确模拟而构建的，因此在节点处求得的数值解应该与在相同节点处求得的精确解析解相同，直至机器浮点精度。计算最大绝对误差 $\\max_i |T_i - T_{\\mathrm{exact}}(x_i)|$ 以验证这一点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (happy path)\n        {'L': 1.0, 'N': 129, 'k_minus': 1.0, 'k_plus': 5.0, 's': 0.37, 'T0': 0.0, 'T_L': 1.0},\n        # Test 2 (interface exactly at a node)\n        {'L': 1.0, 'N': 129, 'k_minus': 1.0, 'k_plus': 10.0, 's': 0.5, 'T0': 100.0, 'T_L': 300.0},\n        # Test 3 (extreme conductivity contrast)\n        {'L': 1.0, 'N': 257, 'k_minus': 0.1, 'k_plus': 1000.0, 's': 0.8, 'T0': 10.0, 'T_L': 11.0},\n        # Test 4 (near-face intersection and k-=k+)\n        {'L': 1.0, 'N': 129, 'k_minus': 2.0, 'k_plus': 2.0, 's': 0.499, 'T0': 0.0, 'T_L': 1.0},\n        # Test 5 (interface near boundary)\n        {'L': 1.0, 'N': 129, 'k_minus': 0.5, 'k_plus': 3.5, 's': 0.02, 'T0': 0.0, 'T_L': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_error_for_case(**case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_error_for_case(L, N, k_minus, k_plus, s, T0, T_L):\n    \"\"\"\n    Computes the maximum absolute error for a single test case.\n    \"\"\"\n    # 1. Setup Grid\n    dx = L / (N - 1)\n    x = np.linspace(0.0, L, N)\n\n    # 2. Assemble Linear System Ax = b\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Boundary Conditions\n    A[0, 0] = 1.0\n    b[0] = T0\n    A[N - 1, N - 1] = 1.0\n    b[N - 1] = T_L\n\n    # Function to get conductance between nodes i and i+1\n    def get_conductance(i):\n        # Check if interface s is strictly within the interval (x[i], x[i+1])\n        if x[i]  s and x[i+1] > s:\n            # GFM / Series Resistance model for interface-straddling cell\n            dist_minus = s - x[i]\n            dist_plus = x[i+1] - s\n            resistance = dist_minus / k_minus + dist_plus / k_plus\n            return 1.0 / resistance\n        else:\n            # Standard model for cell with constant conductivity\n            # Use conductivity at the face midpoint to decide which k to use.\n            mid_point = (x[i] + x[i+1]) / 2.0\n            k = k_minus if mid_point  s else k_plus\n            return k / dx\n\n    # Interior Nodes: assemble equations from i=1 to N-2\n    for i in range(1, N - 1):\n        # Conductance for flux q_{i-1/2} (between i-1 and i)\n        C_left = get_conductance(i - 1)\n        \n        # Conductance for flux q_{i+1/2} (between i and i+1)\n        C_right = get_conductance(i)\n        \n        A[i, i - 1] = C_left\n        A[i, i] = -(C_left + C_right)\n        A[i, i + 1] = C_right\n        b[i] = 0.0\n\n    # 3. Solve for Numerical Temperature\n    T_num = np.linalg.solve(A, b)\n\n    # 4. Calculate Exact Solution\n    res_minus = s / k_minus if s > 0 else 0.0\n    res_plus = (L - s) / k_plus if s  L else 0.0\n    total_resistance = res_minus + res_plus\n    \n    # Avoid division by zero if total_resistance is 0 (e.g., L=0)\n    q_c = -(T_L - T0) / total_resistance if total_resistance > 0 else 0.0\n\n    # Vectorized calculation of exact temperature at all grid points\n    resistance_at_x = np.where(x = s, x / k_minus, s / k_minus + (x - s) / k_plus)\n    T_exact = T0 - q_c * resistance_at_x\n    \n    # 5. Compute Maximum Absolute Error\n    max_error = np.max(np.abs(T_num - T_exact))\n    \n    return max_error\n\n# Execute the solver\nsolve()\n```", "id": "3607108"}, {"introduction": "水平集方法和相场方法最显著的优点之一是它们能够自然地处理界面的拓扑变化，如合并与分裂。尽管两种方法都能处理拓扑变化，但其内在机制截然不同，导致了不同的行为。本练习将通过模拟两个涡环的碰撞与合并，让你直接对比尖锐界面（水平集）和弥散界面（相场）在拓扑变化过程中的差异，从而深刻理解这两种方法的根本特性和适用场景。[@problem_id:2408605]", "problem": "考虑在周期性方形域上的两种替代隐式界面模型，通过在二维平面中传输闭合曲线来近似两个同轴涡环横截面的碰撞。设计算域为方形 $\\left[-1,1\\right]\\times\\left[-1,1\\right]$，在两个方向上均具有周期性边界。设 $N\\times N$ 为均匀网格分辨率，网格间距为 $\\Delta x=\\Delta y=\\dfrac{2}{N}$。定义一个空间变化、时间无关的速度场 $\\mathbf{u}(x,y)=\\left(u_x(x),u_y(x)\\right)$，其中\n$$\nu_x(x)=-U\\tanh\\!\\left(\\dfrac{x}{\\delta}\\right),\\quad u_y(x)=0,\n$$\n这里 $U0$ 和 $\\delta0$ 是给定的常数。两个初始圆形界面代表两个相同涡环的横截面：分别是半径为 $R$、中心位于 $\\left(-a,0\\right)$ 和 $\\left(+a,0\\right)$ 的圆，其中 $0Ra1$。\n\n您必须实现并随时间推进以下两种界面描述，直至指定的最终时间 $T$：\n\n1. 水平集公式。设 $\\phi(x,y,t)$ 是一个标量场，其零水平集表示界面，其负值区域表示“涡核”集合的内部。其演化由线性平流方程给出\n$$\n\\partial_t \\phi + \\mathbf{u}\\cdot\\nabla \\phi = 0,\n$$\n初始条件 $\\phi(x,y,0)=d(x,y)$ 等于到两个初始圆并集的有向距离，即\n$$\nd(x,y)=\\min\\!\\Big(\\sqrt{(x+a)^2+y^2}-R,\\;\\sqrt{(x-a)^2+y^2}-R\\Big),\n$$\n在任一圆的内部 $d(x,y)0$。\n\n2. 相场公式（平流 Allen–Cahn）。设 $c(x,y,t)$ 是一个标量序参量，它近似一个厚度由 $\\epsilon0$ 控制的弥散界面。其演化由平流 Allen–Cahn 方程给出\n$$\n\\partial_t c + \\mathbf{u}\\cdot\\nabla c = \\dfrac{1}{\\tau}\\Big(\\epsilon^2\\nabla^2 c - f'(c)\\Big),\n$$\n其中 $\\tau0$ 是一个弛豫时间，$f(c)=\\dfrac{1}{2}c^2(1-c)^2$ 以至于 $f'(c)=c(1-c)(1-2c)$。初始条件是同样两个圆的平滑弥散表示，\n$$\nc(x,y,0)=\\dfrac{1}{2}\\left(1-\\tanh\\!\\left(\\dfrac{d(x,y)}{\\sqrt{2}\\,\\epsilon}\\right)\\right),\n$$\n使得内部 $c\\approx 1$，外部 $c\\approx 0$。\n\n对于每种公式，在时间 $t=T$ 时，定义二元“核心”集合\n$$\n\\Omega_{\\mathrm{LS}}(T)=\\{(x,y):\\phi(x,y,T)  0\\},\\qquad \\Omega_{\\mathrm{PF}}(T)=\\{(x,y):c(x,y,T)\\tfrac{1}{2}\\}.\n$$\n在周期性域上，使用带有周期性环绕的 $8$-连通性来定义一个二元集合的连通分量数量。为减少虚假的数值斑点，在计数分量之前，丢弃任何面积（以网格点数计）严格小于 $A_{\\min}$ 的连通分量，其中\n$$\nA_{\\min}=\\left\\lfloor \\theta N^2 \\right\\rfloor,\\quad \\theta=0.002.\n$$\n\n您的任务是，为下面的测试套件中的每个参数集，计算整数对 $\\left(C_{\\mathrm{LS}},C_{\\mathrm{PF}}\\right)$，其中 $C_{\\mathrm{LS}}$ 是 $\\Omega_{\\mathrm{LS}}(T)$ 的连通分量数量，$C_{\\mathrm{PF}}$ 是 $\\Omega_{\\mathrm{PF}}(T)$ 的连通分量数量。\n\n测试套件（每个案例指定 $\\left(N,R,a,U,\\delta,\\epsilon,\\tau,T\\right)$）：\n\n- 案例 1: $\\left(96,\\;0.22,\\;0.34,\\;0.40,\\;0.10,\\;0.03,\\;1.0,\\;0.295\\right)$。\n- 案例 2: $\\left(96,\\;0.22,\\;0.34,\\;0.20,\\;0.10,\\;0.02,\\;1.0,\\;0.12\\right)$。\n- 案例 3: $\\left(96,\\;0.22,\\;0.34,\\;0.50,\\;0.10,\\;0.03,\\;1.0,\\;0.35\\right)$。\n\n所有量均为无量纲。如果您的实现中出现任何角度，必须使用弧度。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的、由六个整数组成的逗号分隔列表，顺序为\n$$\n\\left[C_{\\mathrm{LS}}^{(1)},C_{\\mathrm{PF}}^{(1)},C_{\\mathrm{LS}}^{(2)},C_{\\mathrm{PF}}^{(2)},C_{\\mathrm{LS}}^{(3)},C_{\\mathrm{PF}}^{(3)}\\right],\n$$\n对应于测试套件中的案例 1、2 和 3。例如，形如 $\\left[2,1,2,2,1,1\\right]$ 的输出表示案例 1 中水平集有两个分量，相场有一个分量；案例 2 中各有二个分量；案例 3 中各有一个分量。", "solution": "解决方案要求在二维周期性域上对两个偏微分方程（PDE）进行数值积分。控制方程分别是水平集场 $\\phi$ 的线性平流方程和相场序参量 $c$ 的平流 Allen-Cahn 方程。\n\n首先，建立一个计算网格。将域 $\\left[-1,1\\right]\\times\\left[-1,1\\right]$ 离散化为一个 $N\\times N$ 点的均匀网格，网格间距为 $\\Delta x = \\Delta y = 2/N$。网格坐标定义为 $x_i = -1 + i\\Delta x$ 和 $y_j = -1 + j\\Delta y$，其中 $i,j \\in \\{0, \\dots, N-1\\}$。速度场 $\\mathbf{u}(x,y)$ 是纯水平的，$u_x(x)=-U\\tanh(x/\\delta)$，$u_y=0$，在每个网格点 $x_i$ 上进行评估。\n\nPDE 中的空间算子使用遵守周期性边界条件的有限差分法进行离散化。周期性通过使用 `numpy.roll` 来移动网格数据得到高效处理。\n平流项 $\\mathbf{u}\\cdot\\nabla\\psi = u_x(x)\\partial_x\\psi$ 使用一阶迎风格式进行离散化。在平流主导的问题中，这一选择对于维持数值稳定性至关重要。该格式在速度 $u_x$ 为正时使用后向差分计算空间导数 $\\partial_x\\psi$，在 $u_x$ 为负时使用前向差分。\nAllen-Cahn 方程中的拉普拉斯算子 $\\nabla^2 c$ 使用标准的五点模板进行离散化，这是一种二阶精确的中心差分近似。\n\n场 $\\phi(x,y,t)$ 和 $c(x,y,t)$ 的时间演化是通过将半离散化方程（一个关于时间的常微分方程组）从 $t=0$ 积分到最终时间 $T$ 来实现的。由于其高精度和良好的稳定性，采用四阶 Runge-Kutta (RK4) 方法进行此积分。时间步长 $\\Delta t$ 的选择必须满足所有参数集下对流和扩散过程的 Courant-Friedrichs-Lewy (CFL) 稳定性条件。一个保守的全局 $\\Delta t$ 是基于最严格的条件计算的：$\\Delta t \\le \\nu \\cdot \\min(\\Delta x/U_{max}, \\tau (\\Delta x)^2/(4\\epsilon_{min}^2))$，其中使用了一个安全系数 $\\nu  1$。\n\n单个测试用例的演化过程如下：\n1. 根据提供的初始条件公式，在网格上初始化场 $\\phi_0 = \\phi(x,y,0)$ 和 $c_0 = c(x,y,0)$。这些公式基于到初始圆对的有向距离函数 $d(x,y)$。\n2. 对于每个模型（水平集和相场），使用 RK4 格式向前积分，直到 $t=T$。\n3. 在 $t=T$ 时，通过应用指定的阈值：$\\phi(x,y,T)  0$ 和 $c(x,y,T) > 1/2$，分别创建二元核心集 $\\Omega_{\\mathrm{LS}}(T)$ 和 $\\Omega_{\\mathrm{PF}}(T)$。\n\n最后一步是计算每个二元集合的连通分量数量，这受两个关键约束：周期性边界和最小面积过滤器。\n标准的连通分量算法，例如 `scipy.ndimage.label`，本身不处理周期性连接。因此，需要一个针对周期性域的正确实现。步骤如下：\n1. 对二元掩码应用标准的 `scipy.ndimage.label`（使用 $8$-连通性），它为每个非周期性分量分配一个唯一的整数标签。\n2. 创建一个不相交集并 (DSU) 数据结构，以追踪跨周期性边界连接的标签的合并情况。\n3. 遍历域边界上的像素（例如，$x= -1$ 和 $y=-1$）。对于属于某个分量的每个像素，在周期性意义下检查其八个邻居。如果邻居属于一个具有不同标签的分量，则使用 DSU 的 `union` 操作合并这两个标签。\n4. 处理完所有边界像素后，DSU 结构包含了形成真正周期性分量的标签的等价类。\n5. 通过将其所有构成标签的面积（像素计数）相加，计算每个周期性分量的总面积。初始标签的像素计数可通过使用 `numpy.bincount` 高效获得。\n6. 最后，计算总面积大于或等于最小面积阈值 $A_{\\min} = \\lfloor \\theta N^2 \\rfloor$ 的合并分量的数量。这得出了最终的分量计数 $C_{\\mathrm{LS}}$ 和 $C_{\\mathrm{PF}}$。\n\n对测试套件中提供的三个参数集中的每一个都重复此整个过程，并将得到的六个整数格式化为所需的输出字符串。", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the vortex collision problem for all test cases.\n    \"\"\"\n\n    # --- Data structure for periodic component merging ---\n    class DSU:\n        def __init__(self, n):\n            self.parent = list(range(n))\n        def find(self, i):\n            if self.parent[i] == i:\n                return i\n            self.parent[i] = self.find(self.parent[i])\n            return self.parent[i]\n        def union(self, i, j):\n            root_i = self.find(i)\n            root_j = self.find(j)\n            if root_i != root_j:\n                self.parent[root_j] = root_i\n\n    # --- Periodic connected component counting function ---\n    def count_components_periodic(mask, N, theta):\n        s = np.ones((3, 3), dtype=int)  # 8-connectivity\n        labeled_array, num_features = label(mask, structure=s, output=np.int32)\n\n        if num_features == 0:\n            return 0\n\n        dsu = DSU(num_features + 1)\n        \n        # Check connections across periodic boundaries (8-connectivity)\n        # Left-Right boundary\n        for i in range(N):\n            if mask[i, 0]:\n                label_left = labeled_array[i, 0]\n                # Neighbors of (i, 0) across the boundary are at x = -1 (N-1)\n                for i_offset in [-1, 0, 1]:\n                    ni = (i + i_offset + N) % N\n                    if mask[ni, -1]:\n                        dsu.union(label_left, labeled_array[ni, -1])\n        \n        # Top-Bottom boundary\n        for j in range(N):\n            if mask[0, j]:\n                label_top = labeled_array[0, j]\n                # Neighbors of (0, j) across the boundary are at y = -1 (N-1)\n                for j_offset in [-1, 0, 1]:\n                    nj = (j + j_offset + N) % N\n                    if mask[-1, nj]:\n                        dsu.union(label_top, labeled_array[-1, nj])\n\n        # Calculate areas of merged components\n        pixel_counts = np.bincount(labeled_array.ravel())\n        root_areas = {}\n        for i in range(1, num_features + 1):\n            if pixel_counts[i] > 0:\n                root = dsu.find(i)\n                if root not in root_areas:\n                    root_areas[root] = 0\n                root_areas[root] += pixel_counts[i]\n\n        # Filter by area\n        A_min = math.floor(theta * N**2)\n        valid_components = sum(1 for area in root_areas.values() if area >= A_min)\n        \n        return valid_components\n\n    # --- PDE Solver for a single case ---\n    def solve_single_case(params):\n        N, R, a, U, delta, epsilon, tau, T = params\n        theta = 0.002\n        \n        # Grid setup\n        dx = 2.0 / N\n        grid_pts = np.linspace(-1, 1, N, endpoint=False)\n        x, y = np.meshgrid(grid_pts, grid_pts)\n\n        # Velocity field\n        ux = -U * np.tanh(x / delta)\n\n        # Initial conditions\n        d = np.minimum(np.sqrt((x + a)**2 + y**2) - R, np.sqrt((x - a)**2 + y**2) - R)\n        phi0 = d\n        c0 = 0.5 * (1.0 - np.tanh(d / (np.sqrt(2.0) * epsilon)))\n        \n        # --- Spatial operators ---\n        inv_dx = 1.0 / dx\n        inv_dx2 = 1.0 / (dx**2)\n\n        def advection(field, u_field):\n            grad_fwd = (np.roll(field, -1, axis=1) - field) * inv_dx\n            grad_bwd = (field - np.roll(field, 1, axis=1)) * inv_dx\n            return np.where(u_field >= 0, u_field * grad_bwd, u_field * grad_fwd)\n\n        def laplacian(field):\n            return (np.roll(field, -1, axis=1) + np.roll(field, 1, axis=1) +\n                    np.roll(field, -1, axis=0) + np.roll(field, 1, axis=0) - 4 * field) * inv_dx2\n\n        # --- RHS of PDEs for RK4 ---\n        def rhs_ls(phi):\n            return -advection(phi, ux)\n\n        def rhs_pf(c):\n            f_prime = c * (1.0 - c) * (1.0 - 2.0 * c)\n            adv = advection(c, ux)\n            reaction_diffusion = (1.0 / tau) * (epsilon**2 * laplacian(c) - f_prime)\n            return -adv + reaction_diffusion\n            \n        # --- RK4 Time Stepper ---\n        def rk4_step(field, rhs_func, dt):\n            k1 = rhs_func(field)\n            k2 = rhs_func(field + 0.5 * dt * k1)\n            k3 = rhs_func(field + 0.5 * dt * k2)\n            k4 = rhs_func(field + dt * k3)\n            return field + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n        # CFL-based time step\n        dt_adv = dx / U\n        dt_diff = tau * dx**2 / (4 * epsilon**2)\n        dt = 0.25 * min(dt_adv, dt_diff)\n        \n        # --- Time integration loop ---\n        # Level-Set\n        phi = np.copy(phi0)\n        t = 0.0\n        while t  T:\n            current_dt = min(dt, T - t)\n            phi = rk4_step(phi, rhs_ls, current_dt)\n            t += current_dt\n\n        # Phase-Field\n        c = np.copy(c0)\n        t = 0.0\n        while t  T:\n            current_dt = min(dt, T - t)\n            c = rk4_step(c, rhs_pf, current_dt)\n            t += current_dt\n        \n        # --- Component Counting ---\n        mask_ls = phi  0\n        mask_pf = c > 0.5\n        \n        C_LS = count_components_periodic(mask_ls, N, theta)\n        C_PF = count_components_periodic(mask_pf, N, theta)\n\n        return C_LS, C_PF\n\n    # --- Test Suite ---\n    test_cases = [\n        (96, 0.22, 0.34, 0.40, 0.10, 0.03, 1.0, 0.295),\n        (96, 0.22, 0.34, 0.20, 0.10, 0.02, 1.0, 0.12),\n        (96, 0.22, 0.34, 0.50, 0.10, 0.03, 1.0, 0.35),\n    ]\n\n    results = []\n    for params in test_cases:\n        C_LS, C_PF = solve_single_case(params)\n        results.extend([C_LS, C_PF])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2408605"}]}