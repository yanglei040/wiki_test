{"hands_on_practices": [{"introduction": "地球物理材料，如地幔，在不同时间尺度上表现出弹性（固体）和粘性（流体）行为。本练习探讨了广义麦克斯韦模型，这是一种捕捉这种粘弹性行为的基本框架。通过从第一性原理推导单个麦克斯韦分支中应力的演化方程，并为其实现一个无条件稳定的时间积分方案，您将掌握模拟瞬态地球物理过程（如震后松弛）的核心计算技术。[@problem_id:3581349]", "problem": "考虑一个由一个平衡弹簧与一组Maxwell支路并联组成的小应变、单轴广义Maxwell固体。每个Maxwell支路由一个线性弹性弹簧和一个线性粘性阻尼器串联而成。建模的基本依据是弹簧的胡克定律和阻尼器的牛顿粘性定律，以及力学元件的串并联连接规则。具体而言，对于弹簧，应力通过 $\\sigma = E \\, \\epsilon^{e}$ 与弹性应变相关；对于阻尼器，应力通过 $\\sigma = \\eta \\, \\dot{\\epsilon}^{v}$ 与粘性应变率相关。对于串联，两个元件中的应力相等，而应变相加；对于并联，各个支路的应变相等，而应力相加。\n\n您的任务是推导由Maxwell支路承载的内应力的演化方程，并为一个应变步构建一个无条件稳定的指数时间积分更新。该应变步中，应变从步初的已知值线性变化到步末的已知值。\n\n任务：\n- 从上述基本定律和定义出发，并且不引入任何先验的目标公式，推导在小应变条件下，承受给定应变历史 $\\epsilon(t)$ 的单个Maxwell支路所承载应力的时间演化控制方程（一阶线性常微分方程）。清晰地陈述所使用的任何假设。\n- 在从时间 $t_n$ 到 $t_{n+1}$ 的时间步 $\\Delta t$ 内，使用恒定应变率，其中 $\\epsilon(t)$ 线性变化，即 $\\epsilon(t) = \\epsilon_n + \\dfrac{t - t_n}{\\Delta t} \\, \\Delta \\epsilon$，推导用于将该Maxwell支路的应力从时间 $t_n$ 推进到 $t_{n+1}$ 的精确指数更新表达式。您的推导必须基于使用积分因子求解所推导的微分方程，并对步内的分段线性应变精确计算所得的卷积。\n- 将结果推广到一个模量为 $E_{\\mathrm{eq}}$ 的平衡弹簧与两个Maxwell支路并联的情况，并将步末的总柯西应力表示为平衡弹簧应力与Maxwell支路应力之和。明确定义所有量。\n- 在一个程序中实现所得的更新。对于每个测试用例，该程序接受以下输入：\n  - 平衡弹簧模量 $E_{\\mathrm{eq}}$，单位为 $\\mathrm{Pa}$。\n  - 对于两个Maxwell支路中的每一个 $i \\in \\{1,2\\}$：弹簧模量 $E_i$（单位 $\\mathrm{Pa}$）和粘度 $\\eta_i$（单位 $\\mathrm{Pa \\cdot s}$）。\n  - 初始应变 $\\epsilon_n$（无量纲），步内应变增量 $\\Delta \\epsilon$（无量纲），以及初始支路应力 $s_{i,n}$（单位 $\\mathrm{Pa}$）。\n  - 时间步长 $\\Delta t$，单位为 $\\mathrm{s}$。\n- 您的程序必须为每个测试用例计算更新后的支路应力 $s_{1,n+1}$ 和 $s_{2,n+1}$（单位 $\\mathrm{Pa}$），以及更新后的总应力 $\\sigma_{n+1}$（单位 $\\mathrm{Pa}$），假设步内应变路径随时间线性变化。\n- 所有应力以 $\\mathrm{Pa}$ 表示，时间以 $\\mathrm{s}$ 表示，应变为无量纲。角度单位不适用。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个测试用例，输出一个包含三个浮点数的列表 $[s_{1,n+1}, s_{2,n+1}, \\sigma_{n+1}]$；将所有测试用例的结果聚合到单行上的单个列表中，例如 $[[a,b,c],[d,e,f]]$。可将每个数字四舍五入到小数点后六位。\n\n使用以下科学上一致的测试套件，其选择旨在检验典型、小步长、大步长、零增量和混合符号加载行为。对于任何支路模量 $E_i$ 为零的情况，将该支路视为非活动状态，其应力为零。\n\n测试套件：\n- 案例 A (中等步长；单个活动Maxwell支路)：\n  - $E_{\\mathrm{eq}} = 3 \\times 10^{10} \\ \\mathrm{Pa}$，$E_1 = 1 \\times 10^{10} \\ \\mathrm{Pa}$，$\\eta_1 = 1 \\times 10^{14} \\ \\mathrm{Pa \\cdot s}$，$E_2 = 0 \\ \\mathrm{Pa}$，$\\eta_2 = 1 \\ \\mathrm{Pa \\cdot s}$，\n  - $\\epsilon_n = 0$，$\\Delta \\epsilon = 1 \\times 10^{-5}$，$s_{1,n} = 0 \\ \\mathrm{Pa}$，$s_{2,n} = 0 \\ \\mathrm{Pa}$，$\\Delta t = 1 \\times 10^{3} \\ \\mathrm{s}$。\n- 案例 B (零应变增量；仅松弛)：\n  - $E_{\\mathrm{eq}} = 3 \\times 10^{10} \\ \\mathrm{Pa}$，$E_1 = 5 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_1 = 1 \\times 10^{12} \\ \\mathrm{Pa \\cdot s}$，$E_2 = 2 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_2 = 5 \\times 10^{11} \\ \\mathrm{Pa \\cdot s}$，\n  - $\\epsilon_n = 1 \\times 10^{-4}$，$\\Delta \\epsilon = 0$，$s_{1,n} = 5 \\times 10^{5} \\ \\mathrm{Pa}$，$s_{2,n} = -1 \\times 10^{5} \\ \\mathrm{Pa}$，$\\Delta t = 1 \\times 10^{5} \\ \\mathrm{s}$。\n- 案例 C (极小时间步；Maxwell支路中近似弹性响应)：\n  - $E_{\\mathrm{eq}} = 0 \\ \\mathrm{Pa}$，$E_1 = 2 \\times 10^{10} \\ \\mathrm{Pa}$，$\\eta_1 = 1 \\times 10^{16} \\ \\mathrm{Pa \\cdot s}$，$E_2 = 8 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_2 = 4 \\times 10^{15} \\ \\mathrm{Pa \\cdot s}$，\n  - $\\epsilon_n = 0$，$\\Delta \\epsilon = 1 \\times 10^{-6}$，$s_{1,n} = 0 \\ \\mathrm{Pa}$，$s_{2,n} = 0 \\ \\mathrm{Pa}$，$\\Delta t = 1 \\ \\mathrm{s}$。\n- 案例 D (极大时间步；阻尼器主导的响应接近粘度乘以应变率)：\n  - $E_{\\mathrm{eq}} = 0 \\ \\mathrm{Pa}$，$E_1 = 5 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_1 = 1 \\times 10^{10} \\ \\mathrm{Pa \\cdot s}$，$E_2 = 3 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_2 = 3 \\times 10^{10} \\ \\mathrm{Pa \\cdot s}$，\n  - $\\epsilon_n = 0$，$\\Delta \\epsilon = 1 \\times 10^{-2}$，$s_{1,n} = 0 \\ \\mathrm{Pa}$，$s_{2,n} = 0 \\ \\mathrm{Pa}$，$\\Delta t = 1 \\times 10^{5} \\ \\mathrm{s}$。\n- 案例 E (混合符号和部分松弛)：\n  - $E_{\\mathrm{eq}} = 1 \\times 10^{10} \\ \\mathrm{Pa}$，$E_1 = 7 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_1 = 7 \\times 10^{12} \\ \\mathrm{Pa \\cdot s}$，$E_2 = 1 \\times 10^{9} \\ \\mathrm{Pa}$，$\\eta_2 = 1 \\times 10^{11} \\ \\mathrm{Pa \\cdot s}$，\n  - $\\epsilon_n = 2 \\times 10^{-4}$，$\\Delta \\epsilon = -5 \\times 10^{-5}$，$s_{1,n} = 1 \\times 10^{6} \\ \\mathrm{Pa}$，$s_{2,n} = -2 \\times 10^{5} \\ \\mathrm{Pa}$，$\\Delta t = 5 \\times 10^{2} \\ \\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个案例对应一个子列表，顺序与上文相同。每个子列表必须是 $[s_{1,n+1}, s_{2,n+1}, \\sigma_{n+1}]$ 的形式，单位为 $\\mathrm{Pa}$，每个数字四舍五入到小数点后六位，例如 $[[x_{A,1}, x_{A,2}, x_{A,3}],[x_{B,1}, x_{B,2}, x_{B,3}],\\ldots]$。", "solution": "该问题被评估为**有效的**。它在科学上植根于线性粘弹性理论，这是连续介质力学和地球物理学中的一个基本课题。该问题是适定的，为获得唯一且稳定的解提供了所有必要的参数和条件。语言客观，任务明确。我现在将着手提供一个完整的解答。\n\n### Maxwell支路控制方程的推导\n\n单个Maxwell支路由一个线性弹性弹簧和一个线性粘性阻尼器串联而成。设 $s$ 为支路中的单轴应力，$\\epsilon$ 为支路上的总单轴应变。\n\n**假设：**\n1.  材料行为在小应变假设下进行描述。\n2.  材料参数，即弹簧模量 $E$ 和阻尼器粘度 $\\eta$，是恒定的。\n3.  应力和应变处于单轴状态。\n\n**基本定律和定义：**\n-   对于串联，应力在所有元件中是均匀的，总应变是各个应变之和。设 $\\epsilon^e$ 为弹簧中的应变，$\\epsilon^v$ 为阻尼器中的应变。\n    $$s = s^e = s^v$$\n    $$\\epsilon = \\epsilon^e + \\epsilon^v$$\n-   弹簧的胡克定律将应力与弹性应变联系起来：\n    $$s = E \\epsilon^e \\implies \\epsilon^e = \\frac{s}{E}$$\n-   阻尼器的牛顿粘性定律将应力与粘性应变率联系起来：\n    $$s = \\eta \\dot{\\epsilon}^v \\implies \\dot{\\epsilon}^v = \\frac{s}{\\eta}$$\n    其中点号表示对时间 $t$ 求导，即 $\\dot{\\epsilon}^v = \\frac{d\\epsilon^v}{dt}$。\n\n**推导：**\n为找到总应变历史 $\\epsilon(t)$ 与支路应力响应 $s(t)$ 之间的关系，我们将总应变方程对时间求导：\n$$\\dot{\\epsilon} = \\dot{\\epsilon}^e + \\dot{\\epsilon}^v$$\n我们可以用应力 $s$ 来表示右侧的应变率。将弹簧的本构律对时间求导，得到：\n$$\\dot{\\epsilon}^e = \\frac{d}{dt}\\left(\\frac{s}{E}\\right) = \\frac{1}{E}\\dot{s}$$\n阻尼器的定律已经给出了粘性应变率：\n$$\\dot{\\epsilon}^v = \\frac{s}{\\eta}$$\n将这两个表达式代入时间微分后的总应变方程，得到：\n$$\\dot{\\epsilon}(t) = \\frac{1}{E}\\dot{s}(t) + \\frac{1}{\\eta}s(t)$$\n乘以 $E$ 并整理各项，我们得到在应变历史 $\\epsilon(t)$ 作用下，Maxwell支路中应力 $s(t)$ 的控制方程，即一阶线性常微分方程 (ODE)：\n$$\\dot{s}(t) + \\frac{E}{\\eta}s(t) = E\\dot{\\epsilon}(t)$$\n通常将Maxwell支路的松弛时间定义为 $\\tau = \\eta/E$。根据此定义，ODE变为：\n$$\\dot{s}(t) + \\frac{1}{\\tau}s(t) = E\\dot{\\epsilon}(t)$$\n这就是所要求的演化方程。\n\n### 指数时间积分更新的推导\n\n我们的任务是在一个持续时间为 $\\Delta t = t_{n+1} - t_n$ 的离散时间步上求解此ODE，其中应变从时间 $t_n$ 的 $\\epsilon_n$ 线性变化到时间 $t_{n+1}$ 的 $\\epsilon_{n+1}$。\n该步内的应变历史由下式给出：\n$$\\epsilon(t) = \\epsilon_n + \\frac{t - t_n}{\\Delta t}\\Delta\\epsilon \\quad \\text{for } t \\in [t_n, t_{n+1}]$$\n其中 $\\Delta\\epsilon = \\epsilon_{n+1} - \\epsilon_n$。因此，此区间内的应变率是恒定的：\n$$\\dot{\\epsilon}(t) = \\frac{d\\epsilon}{dt} = \\frac{\\Delta\\epsilon}{\\Delta t}$$\n将这个恒定应变率代入控制ODE，对于 $t \\in [t_n, t_{n+1}]$，我们有：\n$$\\dot{s}(t) + \\frac{1}{\\tau}s(t) = E\\frac{\\Delta\\epsilon}{\\Delta t}$$\n这是一个具有常系数的一阶线性非齐次ODE。我们按照要求，使用积分因子来求解它。积分因子 $I(t)$ 是：\n$$I(t) = \\exp\\left(\\int \\frac{1}{\\tau} dt\\right) = e^{t/\\tau}$$\n将ODE乘以 $I(t)$:\n$$e^{t/\\tau}\\dot{s}(t) + \\frac{1}{\\tau}e^{t/\\tau}s(t) = E\\frac{\\Delta\\epsilon}{\\Delta t}e^{t/\\tau}$$\n左边是一个乘积的导数：\n$$\\frac{d}{dt}\\left(s(t)e^{t/\\tau}\\right) = E\\frac{\\Delta\\epsilon}{\\Delta t}e^{t/\\tau}$$\n我们对两边从 $t_n$ 到 $t_{n+1}$ 进行积分：\n$$\\int_{t_n}^{t_{n+1}} \\frac{d}{dt}\\left(s(t)e^{t/\\tau}\\right) dt = \\int_{t_n}^{t_{n+1}} E\\frac{\\Delta\\epsilon}{\\Delta t}e^{t/\\tau} dt$$\n$$[s(t)e^{t/\\tau}]_{t_n}^{t_{n+1}} = E\\frac{\\Delta\\epsilon}{\\Delta t} [\\tau e^{t/\\tau}]_{t_n}^{t_{n+1}}$$\n$$s(t_{n+1})e^{t_{n+1}/\\tau} - s(t_n)e^{t_n/\\tau} = E\\frac{\\Delta\\epsilon}{\\Delta t} \\tau (e^{t_{n+1}/\\tau} - e^{t_n/\\tau})$$\n记 $s(t_n) = s_n$ 和 $s(t_{n+1}) = s_{n+1}$，并求解 $s_{n+1}$:\n$$s_{n+1} = s_n e^{(t_n-t_{n+1})/\\tau} + E\\tau\\frac{\\Delta\\epsilon}{\\Delta t}(1 - e^{(t_n-t_{n+1})/\\tau})$$\n利用 $t_n - t_{n+1} = -\\Delta t$ 这一事实，更新后应力的最终表达式为：\n$$s_{n+1} = s_n e^{-\\Delta t/\\tau} + E\\tau\\frac{\\Delta\\epsilon}{\\Delta t}(1 - e^{-\\Delta t/\\tau})$$\n对于数值实现，特别是当无量纲时间步 $\\Delta t/\\tau$ 的值很小时，将方程改写为以下形式是有利的：\n$$s_{n+1} = s_n e^{-\\Delta t/\\tau} + E\\Delta\\epsilon \\left( \\frac{1 - e^{-\\Delta t/\\tau}}{\\Delta t/\\tau} \\right)$$\n这种形式将括号中的项分离出来，当 $\\Delta t/\\tau \\to 0$ 时，该项趋近于 $1$ 并且是良态的，从而防止了精度损失。对于分段线性应变路径，此更新是精确的，并且对于任何正的 $\\Delta t$ 和 $\\tau$ 都是无条件稳定的。\n\n### 对广义Maxwell模型的推广\n\n该模型由一个平衡弹簧（模量 $E_{\\mathrm{eq}}$）与两个Maxwell支路（索引为 $i=1,2$）并联组成。\n-   对于并联，所有元件的应变相同，总应力是每个元件中应力之和。\n-   在时间 $t$ 施加于系统的总应变为 $\\epsilon(t)$。这是平衡弹簧和两个Maxwell支路所承受的应变。\n-   总柯西应力 $\\sigma(t)$ 是平衡应力 $s_{\\mathrm{eq}}(t)$ 与两个Maxwell支路中的应力 $s_1(t)$ 和 $s_2(t)$ 之和。\n    $$\\sigma(t) = s_{\\mathrm{eq}}(t) + s_1(t) + s_2(t)$$\n\n**在时间 $t_{n+1}$ 的应力更新：**\n时间步结束时的总应力 $\\sigma_{n+1}$ 是：\n$$\\sigma_{n+1} = s_{\\mathrm{eq},n+1} + s_{1,n+1} + s_{2,n+1}$$\n各个分量计算如下：\n1.  **平衡弹簧应力：** 平衡弹簧是纯弹性的。其在时间 $t_{n+1}$ 的应力仅取决于该时刻的应变，$\\epsilon_{n+1} = \\epsilon_n + \\Delta\\epsilon$。\n    $$s_{\\mathrm{eq},n+1} = E_{\\mathrm{eq}}\\epsilon_{n+1} = E_{\\mathrm{eq}}(\\epsilon_n + \\Delta\\epsilon)$$\n2.  **Maxwell支路应力：** 每个Maxwell支路 $i \\in \\{1,2\\}$ 中的应力使用推导出的指数公式进行更新。对于每个具有参数 $E_i, \\eta_i$ 和初始应力 $s_{i,n}$ 的支路 $i$：\n    -   首先，我们处理问题中指定的分支可能处于非活动状态的情况。如果 $E_i = 0$，则分支应力 $s_{i,n+1}$ 设置为 $0$。\n    -   如果 $E_i  0$，我们计算其松弛时间 $\\tau_i = \\eta_i/E_i$。更新后的应力 $s_{i,n+1}$ 则为：\n        $$s_{i,n+1} = s_{i,n} e^{-\\Delta t/\\tau_i} + E_i \\Delta\\epsilon \\left( \\frac{1 - e^{-\\Delta t/\\tau_i}}{\\Delta t/\\tau_i} \\right)$$\n        该公式在 $\\tau_i  0$ 的条件下成立。如果 $\\tau_i = 0$（即 $\\eta_i=0$），则应力 $s_{i,n+1}$ 为 $0$。如果 $\\Delta t=0$，假设 $\\Delta\\epsilon=0$，则 $s_{i,n+1} = s_{i,n}$。我们的实现将处理参数 $\\Delta t/\\tau_i$ 为零的情况。\n\n程序将为每个给定的测试用例实现这三个计算，以求得 $s_{1,n+1}$、$s_{2,n+1}$ 和 $\\sigma_{n+1}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the viscoelastic stress update problem for a series of test cases.\n    The model is a generalized Maxwell solid with one equilibrium spring and two\n    Maxwell branches in parallel. The stress update is derived for a linear\n    strain increment over a time step.\n    \"\"\"\n\n    test_cases = [\n        # Case A\n        {'E_eq': 3e10, 'E1': 1e10, 'eta1': 1e14, 'E2': 0, 'eta2': 1.0,\n         'eps_n': 0.0, 'd_eps': 1e-5, 's1_n': 0.0, 's2_n': 0.0, 'dt': 1e3},\n        # Case B\n        {'E_eq': 3e10, 'E1': 5e9, 'eta1': 1e12, 'E2': 2e9, 'eta2': 5e11,\n         'eps_n': 1e-4, 'd_eps': 0.0, 's1_n': 5e5, 's2_n': -1e5, 'dt': 1e5},\n        # Case C\n        {'E_eq': 0.0, 'E1': 2e10, 'eta1': 1e16, 'E2': 8e9, 'eta2': 4e15,\n         'eps_n': 0.0, 'd_eps': 1e-6, 's1_n': 0.0, 's2_n': 0.0, 'dt': 1.0},\n        # Case D\n        {'E_eq': 0.0, 'E1': 5e9, 'eta1': 1e10, 'E2': 3e9, 'eta2': 3e10,\n         'eps_n': 0.0, 'd_eps': 1e-2, 's1_n': 0.0, 's2_n': 0.0, 'dt': 1e5},\n        # Case E\n        {'E_eq': 1e10, 'E1': 7e9, 'eta1': 7e12, 'E2': 1e9, 'eta2': 1e11,\n         'eps_n': 2e-4, 'd_eps': -5e-5, 's1_n': 1e6, 's2_n': -2e5, 'dt': 500.0}\n    ]\n\n    def compute_branch_stress_update(s_n, E, eta, d_eps, dt):\n        \"\"\"\n        Computes the updated stress for a single Maxwell branch.\n        \"\"\"\n        # Per problem statement, if E_i = 0, the branch is inactive and stress is 0.\n        if E == 0.0:\n            return 0.0\n\n        # The relaxation time tau = eta / E. If eta is 0, tau is 0.\n        # If tau is 0, the dashpot offers no resistance, so stress is 0.\n        if eta == 0.0:\n            return 0.0\n\n        tau = eta / E\n        \n        # Dimensionless time step x = dt / tau\n        x = dt / tau\n\n        # The update formula is s_{n+1} = s_n * exp(-x) + E * d_eps * F(x)\n        # where F(x) = (1 - exp(-x)) / x.\n        # This can be unstable for small x. We use a stable formulation.\n        if x == 0.0:\n            # L'Hopital's rule on F(x) gives 1 as x - 0.\n            # This corresponds to a purely elastic increment.\n            F = 1.0\n        else:\n            # np.expm1(y) computes exp(y) - 1 with high accuracy for small y.\n            # F(x) = - (exp(-x) - 1) / x = -expm1(-x) / x\n            F = -np.expm1(-x) / x\n        \n        s_n_plus_1 = s_n * np.exp(-x) + E * d_eps * F\n        return s_n_plus_1\n\n    results = []\n    for params in test_cases:\n        s1_n_plus_1 = compute_branch_stress_update(\n            params['s1_n'], params['E1'], params['eta1'], params['d_eps'], params['dt']\n        )\n\n        s2_n_plus_1 = compute_branch_stress_update(\n            params['s2_n'], params['E2'], params['eta2'], params['d_eps'], params['dt']\n        )\n        \n        # Calculate total strain at the end of the step\n        eps_n_plus_1 = params['eps_n'] + params['d_eps']\n        \n        # Calculate stress in the equilibrium spring\n        s_eq_n_plus_1 = params['E_eq'] * eps_n_plus_1\n        \n        # Total stress is the sum of stresses in parallel components\n        sigma_n_plus_1 = s_eq_n_plus_1 + s1_n_plus_1 + s2_n_plus_1\n        \n        results.append([s1_n_plus_1, s2_n_plus_1, sigma_n_plus_1])\n    \n    # Format the output string as required: [[r1,r2,r3],[r4,r5,r6],...]\n    # with 6 digits after the decimal point and no spaces.\n    outer_parts = []\n    for r in results:\n        inner_parts = [f\"{v:.6f}\" for v in r]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_string)\n\nsolve()\n```", "id": "3581349"}, {"introduction": "当岩石和土壤等材料的应力达到临界阈值时，它们会发生永久性、不可恢复的变形，这种行为被塑性力学所描述。本练习的核心是莫尔-库仑塑性模型，这是一个广泛用于描述摩擦材料破坏的模型。您将实现“返回映射”算法，这是计算塑性力学中的一个基石，用于在试验弹性步骤违反屈服准则后，将应力状态强制返回到屈服面上。[@problem_id:3581296]", "problem": "考虑一个服从 Mohr–Coulomb 准则的黏聚摩擦岩土材料，在轴对称压缩状态下的小应变、率无关弹塑性问题。应力采用压缩为正的符号约定。弹性响应是各向同性的，体积模量为 $K$，剪切模量为 $G$。设主应力满足 $\\sigma_1 \\ge \\sigma_2 = \\sigma_3$，并假设加载和返回映射步骤不改变主方向。定义应力第一不变量（平均应力）为 $p = (\\sigma_1 + \\sigma_2 + \\sigma_3)/3$，偏应力张量为 $\\mathbf{s} = \\boldsymbol{\\sigma} - p \\mathbf{I}$，第二不变量为 $J_2 = \\tfrac{1}{2} \\mathbf{s}:\\mathbf{s}$。定义偏应力量度为 $q = \\sqrt{3 J_2}$。在 $\\sigma_2 = \\sigma_3$ 的轴对称压缩条件下，一个基本事实是 $q = \\sigma_1 - \\sigma_3$ 且 $p = (\\sigma_1 + 2 \\sigma_3)/3$。\n\n设沿三轴压缩子午线的 Mohr–Coulomb 屈服函数以不变量形式表示为 $f(p,q) = q - M_c p - k_c$，其中摩擦相关性项为 $M_c = \\dfrac{6 \\sin \\phi}{3 - \\sin \\phi}$，黏聚力相关的截距为 $k_c = \\dfrac{6 c \\cos \\phi}{3 - \\sin \\phi}$。考虑非关联塑性流动，其塑性势函数为 $g(p,q) = q - M_g p$，其中 $M_g = \\dfrac{6 \\sin \\psi}{3 - \\sin \\psi}$ 使用了剪胀角 $\\psi$。返回映射步骤更新试探应力状态，使其在遵守各向同性弹性和流动法则的同时，满足屈服条件和一致性条件。\n\n从上述基本定义（各向同性线弹性、不变量 $p$ 和 $q$、屈服条件 $f(p,q) \\le 0$、塑性势 $g(p,q)$，以及 $\\dot{\\boldsymbol{\\sigma}} = \\mathbb{D} : (\\dot{\\boldsymbol{\\varepsilon}} - \\dot{\\boldsymbol{\\varepsilon}}^p)$，其中 $\\dot{\\boldsymbol{\\varepsilon}}^p = \\dot{\\lambda} \\, \\partial g/\\partial \\boldsymbol{\\sigma}$）出发，基于第一性原理，为三轴压缩子午线上的轴对称试探状态推导一个封闭形式的返回映射更新。具体而言，对于给定的试探主应力状态 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}})$（其中 $\\sigma_2^{\\text{tr}} = \\sigma_3^{\\text{tr}}$）、材料参数 $(\\phi, c, \\psi)$ 和弹性模量 $(K, G)$，确定：\n- 从一致性条件获得的塑性乘子增量 $\\Delta \\gamma$，\n- 同一主应力基下的更新后主应力 $(\\sigma_1^{\\text{new}}, \\sigma_2^{\\text{new}}, \\sigma_3^{\\text{new}})$。\n\n如果试探状态严格满足屈服条件（即在数值容差内 $f(p^{\\text{tr}}, q^{\\text{tr}}) \\le 0$），则更新过程必须保持应力不变，并使用 $\\Delta \\gamma = 0$。\n\n输入的角度 $\\phi$ 和 $\\psi$ 必须以度为单位进行解释，并在进行三角函数求值时转换为弧度。所有应力和模量必须以兆帕（MPa）为单位处理。更新后应力的最终答案必须以 MPa 表示。程序必须将每个测试用例的结果输出为一个列表 $[\\Delta \\gamma, \\sigma_1^{\\text{new}}, \\sigma_2^{\\text{new}}, \\sigma_3^{\\text{new}}]$，其中的浮点数四舍五入到六位小数。\n\n测试套件：\n- 案例1（弹性内部）：$K = 5000$ MPa, $G = 3000$ MPa, $\\phi = 30$ 度, $c = 30$ MPa, $\\psi = 5$ 度, 试探主应力 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}}) = (50, 45, 45)$ MPa。\n- 案例2（向光滑子午线的塑性返回）：$K = 5000$ MPa, $G = 3000$ MPa, $\\phi = 30$ 度, $c = 5$ MPa, $\\psi = 10$ 度, 试探主应力 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}}) = (28, 1, 1)$ MPa。\n- 案例3（在屈服面上，边界情况）：$K = 5000$ MPa, $G = 3000$ MPa, $\\phi = 30$ 度, $c = 5$ MPa, $\\psi = 10$ 度, 试探主应力 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}}) = (33.928, 5.536, 5.536)$ MPa。\n- 案例4（塑性返回，零剪胀）：$K = 5000$ MPa, $G = 3000$ MPa, $\\phi = 30$ 度, $c = 5$ MPa, $\\psi = 0$ 度, 试探主应力 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}}) = (28, 1, 1)$ MPa。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应一个测试用例的列表 $[\\Delta \\gamma_1,\\sigma_{1,1}^{\\text{new}},\\sigma_{2,1}^{\\text{new}},\\sigma_{3,1}^{\\text{new}}]$，顺序与上面列出的案例相同。例如，输出应如下所示：\n$[[\\Delta \\gamma_1,\\sigma_{1,1}^{\\text{new}},\\sigma_{2,1}^{\\text{new}},\\sigma_{3,1}^{\\text{new}}],[\\Delta \\gamma_2,\\sigma_{1,2}^{\\text{new}},\\sigma_{2,2}^{\\text{new}},\\sigma_{3,2}^{\\text{new}}],\\ldots]$\n所有报告的数字必须四舍五入到六位小数。角度单位为度，所有应力和模量单位为 MPa。角度单位已明确指定为度；请勿在输入中使用弧度。", "solution": "该问题要求为由 Mohr-Coulomb 屈服准则和非关联流动法则控制的小应变、率无关弹塑性材料，推导并实现一个封闭形式的返回映射算法。该分析专门针对轴对称压缩应力状态。\n\n该算法的基础在于计算塑性力学中常用的算子分裂方法。在该方法中，首先假设总应变增量产生纯弹性应力响应，得到一个“试探”应力状态。如果该试探状态违反了屈服条件，则应用一个塑性修正步骤，将应力状态返回到更新后的屈服面上。此过程采用后向 Euler 积分格式进行离散化，以保证其无条件稳定性。\n\n应力率 $\\dot{\\boldsymbol{\\sigma}}$、弹性刚度张量 $\\mathbb{D}$、总应变率 $\\dot{\\boldsymbol{\\varepsilon}}$ 和塑性应变率 $\\dot{\\boldsymbol{\\varepsilon}}^p$ 之间的基本关系由下式给出：\n$$ \\dot{\\boldsymbol{\\sigma}} = \\mathbb{D} : (\\dot{\\boldsymbol{\\varepsilon}} - \\dot{\\boldsymbol{\\varepsilon}}^p) $$\n在一个时间步 $\\Delta t$上积分，我们得到增量更新。试探应力状态 $\\boldsymbol{\\sigma}^{\\text{tr}}$ 定义为如果整个应变增量 $\\Delta\\boldsymbol{\\varepsilon}$ 完全是弹性的，将会达到的应力状态：\n$$ \\boldsymbol{\\sigma}^{\\text{tr}} = \\boldsymbol{\\sigma}^{\\text{old}} + \\mathbb{D} : \\Delta\\boldsymbol{\\varepsilon} $$\n其中 $\\boldsymbol{\\sigma}^{\\text{old}}$ 是该步骤开始时的应力。然后，更新后的应力 $\\boldsymbol{\\sigma}^{\\text{new}}$ 通过对塑性应变增量 $\\Delta\\boldsymbol{\\varepsilon}^p$ 进行修正，与试探应力相关联：\n$$ \\boldsymbol{\\sigma}^{\\text{new}} = \\boldsymbol{\\sigma}^{\\text{tr}} - \\mathbb{D} : \\Delta\\boldsymbol{\\varepsilon}^p $$\n塑性应变增量由流动法则确定。对于后向 Euler 格式，流动法则在步骤结束时的状态下进行计算：\n$$ \\Delta\\boldsymbol{\\varepsilon}^p = \\Delta\\gamma \\, \\left. \\frac{\\partial g}{\\partial \\boldsymbol{\\sigma}} \\right|_{\\boldsymbol{\\sigma} = \\boldsymbol{\\sigma}^{\\text{new}}} $$\n其中 $\\Delta\\gamma$ 是非负塑性乘子增量，$g$ 是塑性势函数。最终的应力状态 $\\boldsymbol{\\sigma}^{\\text{new}}$ 必须满足屈服条件，即一致性条件：$f(\\boldsymbol{\\sigma}^{\\text{new}}) = 0$。\n\n对于各向同性弹性和压力相关的塑性模型，将应力和应变张量分解为体积和偏量分量是有利的。弹性本构关系由下式给出：\n$$ p = K \\varepsilon_v^e $$\n$$ \\mathbf{s} = 2G \\mathbf{e}^e $$\n其中 $p$ 是平均应力，$\\mathbf{s}$ 是偏应力张量，$\\varepsilon_v^e$ 是弹性体积应变，$\\mathbf{e}^e$ 是弹性偏应变张量，$K$ 是体积模量，$G$ 是剪切模量。应力更新方程可以写成不变量的形式：\n$$ p^{\\text{new}} = p^{\\text{tr}} - K \\Delta\\varepsilon_v^p $$\n$$ \\mathbf{s}^{\\text{new}} = \\mathbf{s}^{\\text{tr}} - 2G \\Delta\\mathbf{e}^p $$\n塑性应变增量从塑性势 $g(p, q)$ 导出，其中 $q = \\sqrt{3J_2}$ 是偏应力量度。所需的导数为：\n$$ \\Delta\\varepsilon_v^p = \\Delta\\gamma \\frac{\\partial g}{\\partial p} $$\n$$ \\Delta\\mathbf{e}^p = \\Delta\\gamma \\frac{\\partial g}{\\partial \\mathbf{s}} = \\Delta\\gamma \\frac{\\partial g}{\\partial q} \\frac{\\partial q}{\\partial \\mathbf{s}} $$\n塑性势为 $g(p,q) = q - M_g p$。其导数为：\n$$ \\frac{\\partial g}{\\partial p} = -M_g $$\n$$ \\frac{\\partial g}{\\partial q} = 1 $$\n将这些代入不变量更新方程：\n$$ p^{\\text{new}} = p^{\\text{tr}} - K (\\Delta\\gamma (-M_g)) = p^{\\text{tr}} + K M_g \\Delta\\gamma $$\n对于偏量更新，我们注意到 $\\frac{\\partial q}{\\partial \\mathbf{s}} = \\frac{3}{2q}\\mathbf{s}$。因此，$\\Delta\\mathbf{e}^p = \\Delta\\gamma \\frac{3}{2q^{\\text{new}}}\\mathbf{s}^{\\text{new}}$。更新过程为：\n$$ \\mathbf{s}^{\\text{new}} = \\mathbf{s}^{\\text{tr}} - 2G \\left( \\Delta\\gamma \\frac{3}{2q^{\\text{new}}}\\mathbf{s}^{\\text{new}} \\right) \\implies \\mathbf{s}^{\\text{new}}\\left(1 + \\frac{3G\\Delta\\gamma}{q^{\\text{new}}}\\right) = \\mathbf{s}^{\\text{tr}} $$\n这表明 $\\mathbf{s}^{\\text{new}}$ 与 $\\mathbf{s}^{\\text{tr}}$ 共线，从而允许我们为 $q$ 写出一个标量更新式：\n$$ q^{\\text{new}} = q^{\\text{tr}} - 3G\\Delta\\gamma $$\n现在我们有了关于不变量 $(p^{\\text{new}}, q^{\\text{new}})$ 的两个更新方程和一个未知数 $\\Delta\\gamma$。最后一步是一致性条件 $f(p^{\\text{new}}, q^{\\text{new}}) = 0$。Mohr-Coulomb 屈服函数是 $f(p,q) = q - M_c p - k_c$。代入 $p^{\\text{new}}$ 和 $q^{\\text{new}}$ 的表达式：\n$$ (q^{\\text{tr}} - 3G\\Delta\\gamma) - M_c (p^{\\text{tr}} + K M_g \\Delta\\gamma) - k_c = 0 $$\n重新整理各项，得到塑性乘子 $\\Delta\\gamma$ 的显式表达式：\n$$ q^{\\text{tr}} - M_c p^{\\text{tr}} - k_c = \\Delta\\gamma(3G + K M_c M_g) $$\n左边的项是屈服函数在试探状态下的值，即 $f^{\\text{tr}} = f(p^{\\text{tr}}, q^{\\text{tr}})$。因此，我们求解 $\\Delta\\gamma$：\n$$ \\Delta\\gamma = \\frac{f^{\\text{tr}}}{3G + K M_c M_g} $$\n仅当 $f^{\\text{tr}}  0$ 时才执行此计算。如果 $f^{\\text{tr}} \\le 0$，则该步为弹性步，且 $\\Delta\\gamma = 0$，从而得到 $\\boldsymbol{\\sigma}^{\\text{new}} = \\boldsymbol{\\sigma}^{\\text{tr}}$。\n\n一旦确定了塑性步的 $\\Delta\\gamma$，就计算更新后的不变量。最后，从更新后的不变量 $(p^{\\text{new}}, q^{\\text{new}})$ 重构主应力。对于指定的轴对称压缩状态（$\\sigma_1 \\ge \\sigma_2 = \\sigma_3$），其关系为：\n$$ p = \\frac{\\sigma_1 + 2\\sigma_3}{3}, \\quad q = \\sigma_1 - \\sigma_3 $$\n反解这个方程组，得到主应力作为不变量的函数：\n$$ \\sigma_1 = p + \\frac{2}{3}q $$\n$$ \\sigma_3 = p - \\frac{1}{3}q $$\n$$ \\sigma_2 = \\sigma_3 $$\n因此，通过将 $(p^{\\text{new}}, q^{\\text{new}})$ 代入这些重构公式，即可求得更新后的主应力 $(\\sigma_1^{\\text{new}}, \\sigma_2^{\\text{new}}, \\sigma_3^{\\text{new}})$。\n\n完整的算法如下：\n1.  给定材料参数 $(K, G, \\phi, c, \\psi)$ 和试探应力状态 $(\\sigma_1^{\\text{tr}}, \\sigma_2^{\\text{tr}}, \\sigma_3^{\\text{tr}})$。\n2.  计算 Mohr-Coulomb 参数 $M_c$ 和 $k_c$ 以及非关联流动参数 $M_g$。输入的角度 $\\phi$ 和 $\\psi$（单位为度）必须转换为弧度以用于三角函数计算。\n3.  计算试探不变量 $p^{\\text{tr}}$ 和 $q^{\\text{tr}}$。\n4.  计算屈服函数值 $f^{\\text{tr}} = q^{\\text{tr}} - M_c p^{\\text{tr}} - k_c$。\n5.  如果 $f^{\\text{tr}} \\le \\epsilon$（其中 $\\epsilon$ 是一个很小的容差，例如 $10^{-9}$），则为弹性步。设置 $\\Delta\\gamma = 0$ 且 $\\boldsymbol{\\sigma}^{\\text{new}} = \\boldsymbol{\\sigma}^{\\text{tr}}$。\n6.  如果 $f^{\\text{tr}}  \\epsilon$，则为塑性步。计算 $\\Delta\\gamma = f^{\\text{tr}} / (3G + K M_c M_g)$。\n7.  更新不变量：$p^{\\text{new}} = p^{\\text{tr}} + K M_g \\Delta\\gamma$ 和 $q^{\\text{new}} = q^{\\text{tr}} - 3G\\Delta\\gamma$。\n8.  重构新的主应力：$\\sigma_1^{\\text{new}} = p^{\\text{new}} + \\frac{2}{3}q^{\\text{new}}$ 和 $\\sigma_2^{\\text{new}} = \\sigma_3^{\\text{new}} = p^{\\text{new}} - \\frac{1}{3}q^{\\text{new}}$。\n9.  每个案例的最终输出是列表 $[\\Delta\\gamma, \\sigma_1^{\\text{new}}, \\sigma_2^{\\text{new}}, \\sigma_3^{\\text{new}}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_update(K, G, phi_deg, c, psi_deg, sigma_tr):\n    \"\"\"\n    Performs a return-mapping update for a Mohr-Coulomb material in axisymmetric compression.\n\n    Args:\n        K (float): Bulk modulus in MPa.\n        G (float): Shear modulus in MPa.\n        phi_deg (float): Friction angle in degrees.\n        c (float): Cohesion in MPa.\n        psi_deg (float): Dilation angle in degrees.\n        sigma_tr (tuple): Trial principal stresses (s1, s2, s3) in MPa.\n\n    Returns:\n        list: A list containing [delta_gamma, s1_new, s2_new, s3_new].\n    \"\"\"\n    # 1. Convert angles to radians\n    phi_rad = np.deg2rad(phi_deg)\n    psi_rad = np.deg2rad(psi_deg)\n\n    # 2. Calculate material constants\n    sin_phi = np.sin(phi_rad)\n    cos_phi = np.cos(phi_rad)\n    sin_psi = np.sin(psi_rad)\n\n    denominator_mc = 3.0 - sin_phi\n    Mc = (6.0 * sin_phi) / denominator_mc\n    kc = (6.0 * c * cos_phi) / denominator_mc\n\n    denominator_mg = 3.0 - sin_psi\n    Mg = (6.0 * sin_psi) / denominator_mg\n\n    # 3. Trial state from principal stresses\n    s1_tr, s2_tr, s3_tr = sigma_tr\n\n    # Calculate trial invariants\n    p_tr = (s1_tr + s2_tr + s3_tr) / 3.0\n    # For axisymmetric compression with s1 = s3, q = s1 - s3\n    q_tr = s1_tr - s3_tr\n\n    # 4. Evaluate yield function at trial state\n    f_tr = q_tr - Mc * p_tr - kc\n\n    # 5. Check for plasticity. Use a small tolerance for floating-point comparison.\n    if f_tr = 1e-9:\n        # Elastic step or on the yield surface\n        delta_gamma = 0.0\n        s1_new, s2_new, s3_new = s1_tr, s2_tr, s3_tr\n    else:\n        # Plastic step: perform return mapping\n        # Calculate plastic multiplier increment\n        denominator_dg = 3.0 * G + K * Mc * Mg\n        delta_gamma = f_tr / denominator_dg\n\n        # Update invariants\n        p_new = p_tr + K * Mg * delta_gamma\n        q_new = q_tr - 3.0 * G * delta_gamma\n\n        # Reconstruct updated principal stresses from new invariants\n        s1_new = p_new + (2.0 / 3.0) * q_new\n        s3_new = p_new - (1.0 / 3.0) * q_new\n        s2_new = s3_new\n\n    return [delta_gamma, s1_new, s2_new, s3_new]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (K, G, phi, c, psi, (s1_tr, s2_tr, s3_tr))\n        (5000.0, 3000.0, 30.0, 30.0, 5.0, (50.0, 45.0, 45.0)),\n        (5000.0, 3000.0, 30.0, 5.0, 10.0, (28.0, 1.0, 1.0)),\n        (5000.0, 3000.0, 30.0, 5.0, 10.0, (33.928, 5.536, 5.536)),\n        (5000.0, 3000.0, 30.0, 5.0, 0.0, (28.0, 1.0, 1.0)),\n    ]\n\n    all_results_formatted = []\n    for case in test_cases:\n        K, G, phi, c, psi, sigma_tr = case\n        result = calculate_update(K, G, phi, c, psi, sigma_tr)\n        \n        # Format each number to 6 decimal places and create the list string\n        formatted_numbers = [f\"{num:.6f}\" for num in result]\n        all_results_formatted.append(f\"[{','.join(formatted_numbers)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_formatted)}]\")\n\nsolve()\n```", "id": "3581296"}, {"introduction": "断层的摩擦行为是控制地震循环的关键。本练习将介绍速率和状态摩擦（RSF）定律，这是模拟断层滑动的现代物理学框架。通过求解一个简单的速度阶跃实验的耦合演化方程，您将能够观察到摩擦的“直接效应”和“演化效应”，从而理解断层如何既能稳定蠕滑又能失稳产生地震。[@problem_id:3581299]", "problem": "一个承受法向应力 $\\sigma_n$ 的速率-状态摩擦 (RSF) 界面，其行为由摩擦系数 $\\mu(t)$ 的本构关系决定。该摩擦系数取决于滑动速率 $V(t)$ 和一个具有时间量纲的内部状态变量 $\\theta(t)$。采用 Dieterich-Ruina (老化) 状态演化。使用以下基本且被广泛接受的初始定律：\n\n- 摩擦定律：$\\mu(t) = \\mu_\\star + a \\ln\\!\\left(\\dfrac{V(t)}{V_\\star}\\right) + b \\ln\\!\\left(\\dfrac{\\theta(t)\\,V_\\star}{D_c}\\right)$，其中 $\\mu_\\star$ 是在参考速率 $V_\\star$ 下的参考摩擦系数，$a$ 和 $b$ 是无量纲的经验参数，$D_c$ 是具有长度量纲的特征滑动距离。\n- 状态变量的老化定律 (一个常微分方程 (ODE))：$\\dfrac{d\\theta}{dt} = 1 - \\dfrac{V(t)\\,\\theta(t)}{D_c}$。\n- 剪切应力：$\\tau(t) = \\sigma_n\\,\\mu(t)$。\n\n考虑一个给定的速率阶跃历史：在时间 $t  0$ 时，界面处于速率为 $V_1$ 的稳态；在 $t = 0$ 时，滑动速率阶跃到一个恒定值 $V_2$，并在 $t \\in [0, T_{\\text{end}}]$ 期间保持不变。假设系统在 $t=0^-$ 时处于稳态，这意味着初始条件为 $\\theta(0) = D_c / V_1$。仅以此些定律和定义为出发点，推导在 $t \\in [0, T_{\\text{end}}]$ 内获得 $\\mu(t)$ 的计算过程，并计算该时间间隔内的累积应力降，定义为 $\\Delta \\tau = \\tau(0^-) - \\tau(T_{\\text{end}})$，以帕斯卡 (Pascals) 为单位表示。其中 $\\tau(0^-)=\\sigma_n\\,\\mu_{\\text{ss}}(V_1)$ 是阶跃前瞬间的稳态剪切应力。所有速率必须严格为正。\n\n全程使用的物理单位：\n- 滑动速率 $V$ 的单位为米/秒 ($\\text{m/s}$)。\n- 特征滑动距离 $D_c$ 的单位为米 ($\\text{m}$)。\n- 时间 $t$ 的单位为秒 ($\\text{s}$)。\n- 法向应力 $\\sigma_n$ 的单位为帕斯卡 ($\\text{Pa}$)。\n- 摩擦系数 $\\mu$ 是无量纲的。\n- 最终应力降 $\\Delta \\tau$ 必须以帕斯卡表示。\n\n你的程序必须为以下测试套件实现解决方案。每个测试用例是一个元组 $(a, b, D_c, \\sigma_n, \\mu_\\star, V_\\star, V_1, V_2, T_{\\text{end}})$，其值如下：\n- A用例 (速率阶跃上升，速率弱化，短瞬态)：\n  - $(a, b, D_c, \\sigma_n, \\mu_\\star, V_\\star, V_1, V_2, T_{\\text{end}}) = (\\,0.008,\\,0.012,\\,10^{-5},\\,5\\times 10^{7},\\,0.6,\\,10^{-6},\\,10^{-6},\\,10^{-3},\\,1\\,)$。\n- B用例 (速率阶跃下降，速率弱化，长瞬态)：\n  - $(a, b, D_c, \\sigma_n, \\mu_\\star, V_\\star, V_1, V_2, T_{\\text{end}}) = (\\,0.008,\\,0.012,\\,10^{-5},\\,5\\times 10^{7},\\,0.6,\\,10^{-6},\\,10^{-4},\\,10^{-6},\\,50\\,)$。\n- C用例 (速率阶跃上升且 $a=b$，稳态净变化为零)：\n  - $(a, b, D_c, \\sigma_n, \\mu_\\star, V_\\star, V_1, V_2, T_{\\text{end}}) = (\\,0.01,\\,0.01,\\,10^{-5},\\,5\\times 10^{7},\\,0.6,\\,10^{-6},\\,10^{-6},\\,10^{-3},\\,1\\,)$。\n\n对每个用例，计算并报告以下三个量：\n- $\\mu(0^+)$，在 $t=0^+$ 时速率阶跃后的瞬时摩擦值。\n- $\\mu(T_{\\text{end}})$，在结束时间的摩擦值。\n- $\\Delta \\tau = \\tau(0^-) - \\tau(T_{\\text{end}})$，以帕斯卡为单位。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对每个用例，输出一个三元素列表 $[\\mu(0^+), \\mu(T_{\\text{end}}), \\Delta \\tau]$，每个浮点数四舍五入到六位小数，并将三个用例的结果聚合成一个顶层列表。例如，所需的格式类似于 $[[x_1,x_2,x_3],[y_1,y_2,y_3],[z_1,z_2,z_3]]$，不含额外的空格或文本。", "solution": "该问题在科学上是有效且定义明确的，它基于计算地球物理学和地震学中常用的速率-状态摩擦模型的既定原理。我们可以对感兴趣的量进行形式推导。\n\n该系统由三个基本定律描述：\n$1$. 摩擦定律：$\\mu(t) = \\mu_\\star + a \\ln\\left(\\dfrac{V(t)}{V_\\star}\\right) + b \\ln\\left(\\dfrac{\\theta(t)\\,V_\\star}{D_c}\\right)$。\n$2$. 状态演化定律 (老化)：$\\dfrac{d\\theta}{dt} = 1 - \\dfrac{V(t)\\,\\theta(t)}{D_c}$。\n$3$. 剪切应力定义：$\\tau(t) = \\sigma_n\\,\\mu(t)$。\n\n我们的目标是计算速率阶跃瞬间的摩擦系数 $\\mu(0^+)$、稍后时刻的摩擦系数 $\\mu(T_{\\text{end}})$ 以及该时间间隔内的总应力降 $\\Delta \\tau = \\tau(0^-) - \\tau(T_{\\text{end}})$。\n\n首先，我们分析稳态 (ss) 条件，这对于定义系统的初始状态至关重要。在稳态下，所有时间导数均为零，因此 $\\dfrac{d\\theta}{dt} = 0$。根据状态演化定律，这意味着：\n$$1 - \\dfrac{V_{\\text{ss}}\\,\\theta_{\\text{ss}}}{D_c} = 0 \\implies \\theta_{\\text{ss}}(V) = \\dfrac{D_c}{V}$$\n状态变量的稳态值 $\\theta_{\\text{ss}}$ 与稳态速率 $V_{\\text{ss}}$ 成反比。将此代入摩擦定律，可得出作为速率 $V$ 函数的稳态摩擦系数 $\\mu_{\\text{ss}}$：\n$$ \\mu_{\\text{ss}}(V) = \\mu_\\star + a \\ln\\left(\\dfrac{V}{V_\\star}\\right) + b \\ln\\left(\\dfrac{(D_c/V)\\,V_\\star}{D_c}\\right) $$\n$$ \\mu_{\\text{ss}}(V) = \\mu_\\star + a \\ln\\left(\\dfrac{V}{V_\\star}\\right) + b \\ln\\left(\\dfrac{V_\\star}{V}\\right) = \\mu_\\star + (a-b)\\ln\\left(\\dfrac{V}{V_\\star}\\right) $$\n\n问题陈述系统在 $t  0$ 时以速率 $V_1$ 处于稳态。因此，在 $t=0$ 时状态变量的初始条件为：\n$$ \\theta(0) = \\theta_{\\text{ss}}(V_1) = \\dfrac{D_c}{V_1} $$\n在阶跃前瞬间，$t=0^-$ 时的剪切应力基于 $V_1$ 下的稳态摩擦：\n$$ \\tau(0^-) = \\sigma_n\\,\\mu_{\\text{ss}}(V_1) = \\sigma_n\\left[\\mu_\\star + (a-b)\\ln\\left(\\dfrac{V_1}{V_\\star}\\right)\\right] $$\n\n在 $t=0$ 时，速率瞬时阶跃到 $V_2$。状态变量 $\\theta$ 不能瞬时改变，因此 $\\theta(0^+) = \\theta(0^-) = D_c/V_1$。然而，摩擦系数 $\\mu$ 会对 $V$ 的变化立即作出响应。为了求得 $\\mu(0^+)$，我们将 $V(0^+) = V_2$ 和 $\\theta(0) = D_c/V_1$ 代入摩擦定律：\n$$ \\mu(0^+) = \\mu_\\star + a \\ln\\left(\\dfrac{V_2}{V_\\star}\\right) + b \\ln\\left(\\dfrac{\\theta(0)\\,V_\\star}{D_c}\\right) $$\n$$ \\mu(0^+) = \\mu_\\star + a \\ln\\left(\\dfrac{V_2}{V_\\star}\\right) + b \\ln\\left(\\dfrac{(D_c/V_1)\\,V_\\star}{D_c}\\right) = \\mu_\\star + a \\ln\\left(\\dfrac{V_2}{V_\\star}\\right) - b \\ln\\left(\\dfrac{V_1}{V_\\star}\\right) $$\n这个表达式给出了第一个所需量 $\\mu(0^+)$。这被称为速率变化的“直接效应”。\n\n对于 $t > 0$，速率保持恒定在 $V(t) = V_2$。状态演化定律变为关于 $\\theta(t)$ 的一阶线性常微分方程：\n$$ \\dfrac{d\\theta}{dt} = 1 - \\dfrac{V_2\\,\\theta(t)}{D_c} \\quad \\text{或} \\quad \\dfrac{d\\theta}{dt} + \\left(\\dfrac{V_2}{D_c}\\right)\\theta = 1 $$\n这个带有初始条件 $\\theta(0) = D_c/V_1$ 的常微分方程的解可以通过使用积分因子或识别其标准形式来求得。其通解为 $\\theta(t) = \\theta_{\\text{ss}}(V_2) + C \\exp(-t / (D_c/V_2))$，其中 $\\theta_{\\text{ss}}(V_2) = D_c/V_2$ 是新的稳态值。我们求解积分常数 $C$：\n$$ \\theta(0) = \\dfrac{D_c}{V_1} = \\dfrac{D_c}{V_2} + C \\implies C = \\dfrac{D_c}{V_1} - \\dfrac{D_c}{V_2} $$\n对于 $t \\ge 0$，状态变量的特解是：\n$$ \\theta(t) = \\dfrac{D_c}{V_2} + \\left(\\dfrac{D_c}{V_1} - \\dfrac{D_c}{V_2}\\right) e^{-t\\,V_2/D_c} $$\n\n为了求出 $t=T_{\\text{end}}$ 时的摩擦系数，我们首先使用上述解来计算 $\\theta(T_{\\text{end}})$：\n$$ \\theta(T_{\\text{end}}) = \\dfrac{D_c}{V_2} + \\left(\\dfrac{D_c}{V_1} - \\dfrac{D_c}{V_2}\\right) e^{-T_{\\text{end}}\\,V_2/D_c} $$\n然后，我们将这个值和 $V=V_2$ 代入摩擦定律，以获得第二个所需量 $\\mu(T_{\\text{end}})$：\n$$ \\mu(T_{\\text{end}}) = \\mu_\\star + a \\ln\\left(\\dfrac{V_2}{V_\\star}\\right) + b \\ln\\left(\\dfrac{\\theta(T_{\\text{end}})\\,V_\\star}{D_c}\\right) $$\n\n最后，我们计算累积应力降 $\\Delta\\tau = \\tau(0^-) - \\tau(T_{\\text{end}})$。使用应力的表达式：\n$$ \\Delta\\tau = \\sigma_n\\,\\mu_{\\text{ss}}(V_1) - \\sigma_n\\,\\mu(T_{\\text{end}}) = \\sigma_n\\left(\\mu_{\\text{ss}}(V_1) - \\mu(T_{\\text{end}})\\right) $$\n其中 $\\mu_{\\text{ss}}(V_1)$ 和 $\\mu(T_{\\text{end}})$ 由上面推导的公式给出。这是第三个也是最后一个所需量。计算步骤就是实现这些推导出的解析表达式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (a, b, Dc, sigma_n, mu_star, V_star, V1, V2, T_end)\n    test_cases = [\n        # Case A (step up in velocity, velocity-weakening, short transient)\n        (0.008, 0.012, 1e-5, 5e7, 0.6, 1e-6, 1e-6, 1e-3, 1),\n        # Case B (step down in velocity, velocity-weakening, long transient)\n        (0.008, 0.012, 1e-5, 5e7, 0.6, 1e-6, 1e-4, 1e-6, 50),\n        # Case C (step up with a=b, zero net steady-state change)\n        (0.01, 0.01, 1e-5, 5e7, 0.6, 1e-6, 1e-6, 1e-3, 1),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        a, b, Dc, sigma_n, mu_star, V_star, V1, V2, T_end = case\n\n        # 1. Calculate mu(0+), the immediate friction value after the velocity step.\n        # Formula: mu(0+) = mu_star + a*ln(V2/V_star) - b*ln(V1/V_star)\n        term_a = a * np.log(V2 / V_star)\n        term_b = b * np.log(V1 / V_star)\n        mu_0_plus = mu_star + term_a - term_b\n\n        # 2. Calculate theta(T_end), the state variable at the end of the interval.\n        # This is the solution to the ODE d(theta)/dt = 1 - V2*theta/Dc\n        # with initial condition theta(0) = Dc/V1.\n        # Formula: theta(t) = Dc/V2 + (Dc/V1 - Dc/V2) * exp(-t*V2/Dc)\n        C = Dc / V1 - Dc / V2\n        exponent = -T_end * V2 / Dc\n        theta_T_end = (Dc / V2) + C * np.exp(exponent)\n\n        # 3. Calculate mu(T_end), the friction value at the end time.\n        # Formula: mu(T_end) = mu_star + a*ln(V2/V_star) + b*ln(theta(T_end)*V_star/Dc)\n        log_term_b = b * np.log(theta_T_end * V_star / Dc)\n        mu_T_end = mu_star + term_a + log_term_b\n        \n        # 4. Calculate Delta tau = tau(0-) - tau(T_end).\n        # First, find mu_ss(V1), the steady-state friction before the step.\n        # Formula: mu_ss(V) = mu_star + (a-b)*ln(V/V_star)\n        mu_ss_V1 = mu_star + (a - b) * np.log(V1 / V_star)\n        \n        # Delta tau is then sigma_n * (mu_ss(V1) - mu(T_end))\n        delta_tau = sigma_n * (mu_ss_V1 - mu_T_end)\n\n        # Append the results for the current case.\n        all_results.append([mu_0_plus, mu_T_end, delta_tau])\n\n    # Format the final output string exactly as required.\n    # Example: [[x1,x2,x3],[y1,y2,y3],[z1,z2,z3]]\n    # with 6 decimal places for each float and no extra whitespace.\n    result_strings = []\n    for res in all_results:\n        # Format each number to 6 decimal places\n        mu0_str = f\"{res[0]:.6f}\"\n        muT_str = f\"{res[1]:.6f}\"\n        dT_str = f\"{res[2]:.6f}\"\n        # Construct the inner list string\n        inner_str = f\"[{mu0_str},{muT_str},{dT_str}]\"\n        result_strings.append(inner_str)\n    \n    # Join the inner list strings and enclose in the outer list brackets\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3581299"}]}