{"hands_on_practices": [{"introduction": "在许多物理问题中，最有效的网格加密并非总是各向同性的。对于像激波或边界层这样的定向特征，使用各向异性（拉伸的）网格单元效率更高。本练习将指导您如何从一个标量场计算出基于Hessian矩阵的加密度量，并探索其特征值和特征向量如何直接转化为所需的单元纵横比和方向，为智能化的各向异性网格自适应奠定基础。[@problem_id:3573786]", "problem": "给定一个在均匀笛卡尔网格上采样得到的二次连续可微标量场 $u(x,y)$，网格间距分别为 $h_x$ 和 $h_y$。您的任务是实现一个完整的程序，该程序针对几个指定的测试场和点，计算一个对称的基于Hessian矩阵的各向异性加密度量，并推导出最终的方向性加密信息。\n\n从 $u$ 在点 $(x_0,y_0)$ 处的二阶泰勒展开式开始，Hessian矩阵 $H(u)$ 捕捉了其二阶变化：\n$$\nu(x_0+\\Delta x,y_0+\\Delta y) \\approx u(x_0,y_0) + \\nabla u(x_0,y_0) \\cdot \\begin{bmatrix}\\Delta x\\\\ \\Delta y\\end{bmatrix} + \\tfrac{1}{2} \\begin{bmatrix}\\Delta x  \\Delta y\\end{bmatrix} H(u)(x_0,y_0) \\begin{bmatrix}\\Delta x\\\\ \\Delta y\\end{bmatrix}.\n$$\n在均匀网格上，使用最小的 $3 \\times 3$ 模板，通过二阶中心差分来近似 $H(u)(x_0,y_0)$：\n- 二阶偏导数的近似如下\n$$\n\\partial_{xx} u(x_0,y_0) \\approx \\frac{u(x_0+h_x,y_0) - 2\\,u(x_0,y_0) + u(x_0-h_x,y_0)}{h_x^2},\n$$\n$$\n\\partial_{yy} u(x_0,y_0) \\approx \\frac{u(x_0,y_0+h_y) - 2\\,u(x_0,y_0) + u(x_0,y_0-h_y)}{h_y^2},\n$$\n$$\n\\partial_{xy} u(x_0,y_0) \\approx \\frac{u(x_0+h_x,y_0+h_y) - u(x_0+h_x,y_0-h_y) - u(x_0-h_x,y_0+h_y) + u(x_0-h_x,y_0-h_y)}{4\\,h_x\\,h_y}.\n$$\n构造对称的Hessian矩阵\n$$\nH(u)(x_0,y_0) \\approx \\begin{bmatrix} \\partial_{xx}u  \\partial_{xy}u \\\\ \\partial_{xy}u  \\partial_{yy}u \\end{bmatrix}.\n$$\n将用于各向异性加密的度量张量定义为 $M = \\alpha\\,H(u)$，其中 $\\alpha  0$ 是用户指定的标量。将 $H(u)$ 的特征分解表示为 $H(u)=Q \\Lambda Q^\\top$，其中 $Q$ 是正交矩阵，$\\Lambda=\\mathrm{diag}(\\lambda_1,\\lambda_2)$，$\\lambda_i$ 是实数特征值，$q_i$ 是标准正交的特征向量。\n\n为了确定方向性加密尺度，使用特征值的绝对值。引入一个小的下限值 $\\delta  0$ 以避免除以零，并计算\n$$\nh_i = \\sqrt{\\frac{\\alpha}{\\max(|\\lambda_i|,\\delta)}},\n$$\n然后通过以下方式将其限制在边界 $h_{\\min} \\le h_i \\le h_{\\max}$ 内：\n$$\nh_i \\leftarrow \\min\\left(h_{\\max}, \\max\\left(h_{\\min}, h_i\\right)\\right).\n$$\n将纵横比定义为\n$$\n\\mathrm{AR} = \\frac{\\max(h_1,h_2)}{\\min(h_1,h_2)}.\n$$\n将最强加密方向的方位角 $\\theta$（以弧度为单位）定义为与最小 $h_i$（即最大 $|\\lambda_i|$）相关联的特征向量的角度。如果 $|\\lambda_i|$ 出现相等的情况，选择对应于代数值较大的 $\\lambda_i$ 的特征向量。对于所选的单位特征向量 $v=[v_x,v_y]^\\top$，计算 $\\theta = \\mathrm{atan2}(v_y,v_x)$，并通过加或减 $\\pi$ 将 $\\theta$ 归一化到区间 $[-\\pi/2,\\pi/2)$ 内，以确保其在该范围内。\n\n为以下测试套件实现上述过程，套件包含场 $u(x,y)$、点 $(x_0,y_0)$ 和参数 $(h_x,h_y,\\alpha,h_{\\min},h_{\\max},\\delta)$：\n\n- 测试 1：$u(x,y) = x^2 + 3\\,y^2$，$(x_0,y_0)=(0,0)$，$h_x=h_y=0.01$，$\\alpha=1.0$，$h_{\\min}=0.05$，$h_{\\max}=1.0$，$\\delta=10^{-12}$。\n- 测试 2：$u(x,y) = (x+y)^2$，$(x_0,y_0)=(0,0)$，$h_x=h_y=0.01$，$\\alpha=1.0$，$h_{\\min}=0.05$，$h_{\\max}=1.0$，$\\delta=10^{-6}$。\n- 测试 3：$u(x,y) = x^2 - y^2$，$(x_0,y_0)=(0,0)$，$h_x=h_y=0.01$，$\\alpha=1.0$，$h_{\\min}=0.05$，$h_{\\max}=1.0$，$\\delta=10^{-12}$。\n- 测试 4：$u(x,y) = e^{0.5\\,x}\\cos(y)$，$(x_0,y_0)=(0.1,-0.2)$，$h_x=h_y=0.01$，$\\alpha=0.25$，$h_{\\min}=0.05$，$h_{\\max}=0.5$，$\\delta=10^{-12}$。\n\n您的程序应针对每个测试，在点 $(x_0,y_0)$ 处计算：\n- Hessian矩阵的元素 $H_{xx}$、$H_{xy}$、$H_{yy}$，\n- 根据上述规则排序的特征值 $\\lambda_1, \\lambda_2$（按 $|\\lambda_i|$ 降序，相等时按 $\\lambda_i$ 降序），\n- 纵横比 $\\mathrm{AR}$，\n- 方位角 $\\theta$（以弧度为单位），\n- 度量张量的元素 $M_{xx}$、$M_{xy}$、$M_{yy}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形如下式的子列表\n$$\n[H_{xx}, H_{xy}, H_{yy}, \\lambda_1, \\lambda_2, \\mathrm{AR}, \\theta, M_{xx}, M_{xy}, M_{yy}],\n$$\n所有值都四舍五入到 $6$ 位小数。也就是说，最终输出必须是像 $[[\\cdots],[\\cdots],[\\cdots],[\\cdots]]$ 这样的单行，不含空格。角度必须以弧度为单位。不涉及物理单位。打印输出中的所有数字必须按规定四舍五入到 $6$ 位小数。", "solution": "该问题要求为给定的标量场 $u(x,y)$ 计算一个基于Hessian矩阵的各向异性加密度量。这在计算科学中是一项标准技术，尤其是在为求解偏微分方程而进行的自适应网格生成中，其中网格密度和方向会根据解的局部特征（如尖锐梯度或高曲率区域）进行调整。Hessian矩阵包含场的二阶偏导数，提供了关于场的局部曲率信息。Hessian矩阵的特征值和特征向量指明了该曲率的主方向和大小。这些信息随后被用来定义一个度量张量，该张量规定了所需的网格单元尺寸和方向。\n\n求解过程分为以下顺序步骤，这些步骤将应用于每个测试用例。\n\n**步骤 1：Hessian矩阵的数值近似**\n\n给定一个标量场 $u(x,y)$，其Hessian矩阵定义为：\n$$\nH(u) = \\begin{bmatrix} \\partial_{xx}u  \\partial_{xy}u \\\\ \\partial_{yx}u  \\partial_{yy}u \\end{bmatrix}\n$$\n由于问题声明 $u(x,y)$ 是二次连续可微的，Schwarz定理保证了 $\\partial_{xy}u = \\partial_{yx}u$，从而使Hessian矩阵对称。问题提供了二阶精度的中心差分公式，用于在网格间距为 $h_x$ 和 $h_y$ 的网格上近似点 $(x_0, y_0)$ 处的偏导数。\n\n二阶偏导数的计算如下：\n- 关于 $x$ 的纯二阶导数：\n$$\nH_{xx} = \\partial_{xx} u(x_0,y_0) \\approx \\frac{u(x_0+h_x,y_0) - 2\\,u(x_0,y_0) + u(x_0-h_x,y_0)}{h_x^2}\n$$\n- 关于 $y$ 的纯二阶导数：\n$$\nH_{yy} = \\partial_{yy} u(x_0,y_0) \\approx \\frac{u(x_0,y_0+h_y) - 2\\,u(x_0,y_0) + u(x_0,y_0-h_y)}{h_y^2}\n$$\n- 混合二阶导数：\n$$\nH_{xy} = \\partial_{xy} u(x_0,y_0) \\approx \\frac{u(x_0+h_x,y_0+h_y) - u(x_0+h_x,y_0-h_y) - u(x_0-h_x,y_0+h_y) + u(x_0-h_x,y_0-h_y)}{4\\,h_x\\,h_y}\n$$\n这三个值构成了在点 $(x_0,y_0)$ 处的近似对称Hessian矩阵：\n$$\nH \\approx \\begin{bmatrix} H_{xx}  H_{xy} \\\\ H_{xy}  H_{yy} \\end{bmatrix}\n$$\n\n**步骤 2：Hessian矩阵的特征分解**\n\nHessian矩阵 $H$ 是一个 $2 \\times 2$ 的实对称矩阵。因此，它有两个实数特征值 $\\lambda_1$ 和 $\\lambda_2$，以及一组相应的标准正交特征向量 $q_1$ 和 $q_2$。其特征分解为 $H = Q \\Lambda Q^\\top$，其中 $\\Lambda = \\mathrm{diag}(\\lambda_1, \\lambda_2)$，而 $Q = [q_1 | q_2]$ 是一个正交矩阵，其列为特征向量。\n\n问题规定了特征值的排序顺序：它们主要按其绝对值的降序排列。如果出现相等的情况（即 $|\\lambda_a| = |\\lambda_b|$），则按其代数值的降序来打破僵局。这定义了有序对 $(\\lambda_1, \\lambda_2)$，使得要么 $|\\lambda_1|  |\\lambda_2|$，要么 $|\\lambda_1| = |\\lambda_2|$ 且 $\\lambda_1 \\ge \\lambda_2$。\n\n**步骤 3：加密尺度和纵横比的计算**\n\nHessian矩阵的特征值量化了曲率。在需要高分辨率的方向（大曲率，大的 $|\\lambda_i|$），期望的网格尺寸 $h_i$ 应该较小。此关系由下式给出：\n$$\nh_i = \\sqrt{\\frac{\\alpha}{\\max(|\\lambda_i|,\\delta)}}\n$$\n其中 $\\alpha$ 是一个缩放因子，$\\delta$ 是一个小的正常数，用于防止除以零或接近零的特征值，这种情况会导致网格尺寸过大。\n\n计算出的尺度 $h_i$ 随后被限制在预定的有效范围 $[h_{\\min}, h_{\\max}]$ 内：\n$$\nh_i \\leftarrow \\min\\left(h_{\\max}, \\max\\left(h_{\\min}, h_i\\right)\\right)\n$$\n限制后，期望的各向异性网格单元的纵横比 $\\mathrm{AR}$ 计算为较大加密尺度与较小加密尺度之比：\n$$\n\\mathrm{AR} = \\frac{\\max(h_1, h_2)}{\\min(h_1, h_2)}\n$$\n\n**步骤 4：方位角的确定**\n\n期望的加密方向与曲率的主方向对齐，即Hessian矩阵的特征向量。最强的加密方向对应于最小的期望网格尺寸 $h_i$，这又对应于绝对值最大的特征值 $\\lambda_i$。根据我们的排序规则，这总是 $\\lambda_1$。\n\n方位角 $\\theta$ 被定义为与 $\\lambda_1$ 相关联的特征向量 $q_1$ 的角度。对于一个特征向量 $q_1 = [v_x, v_y]^\\top$，其角度使用双参数反正切函数计算：\n$$\n\\theta_{\\text{raw}} = \\mathrm{atan2}(v_y, v_x)\n$$\n这个角度位于 $(-\\pi, \\pi]$ 区间内，代表了特征向量的方向。然而，对于网格方向来说，一个方向与其相反方向是等效的（例如，由 $q_1$ 定义的直线与由 $-q_1$ 定义的直线相同）。因此，通过加或减 $\\pi$ 的倍数，将角度归一化到区间 $[-\\pi/2, \\pi/2)$ 内。一个方便的归一化公式是 $\\theta = \\mathrm{mod}(\\theta_{\\text{raw}} + \\pi/2, \\pi) - \\pi/2$。\n\n**步骤 5：度量张量的构建**\n\n最后，度量张量 $M$ 被定义为Hessian矩阵的一个简单缩放：\n$$\nM = \\alpha H = \\begin{bmatrix} \\alpha H_{xx}  \\alpha H_{xy} \\\\ \\alpha H_{xy}  \\alpha H_{yy} \\end{bmatrix}\n$$\n这个张量 $M$ 可以被网格生成软件用来创建在高曲率方向上小而对齐、在低曲率方向上大而拉长的单元。\n\n**测试用例的执行**\n\n上述五步过程被系统地应用于所提供的每个测试用例。对每个用例，我们定义函数 $u(x,y)$、点 $(x_0, y_0)$ 和参数集 $(h_x, h_y, \\alpha, h_{\\min}, h_{\\max}, \\delta)$。然后执行算法以计算十个所需的输出值：$(H_{xx}, H_{xy}, H_{yy}, \\lambda_1, \\lambda_2, \\mathrm{AR}, \\theta, M_{xx}, M_{xy}, M_{yy})$。然后将数值结果四舍五入到六位小数以供最终输出。整个过程都封装在所提供的Python程序中。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes Hessian-based refinement metrics and formats the output.\n    \"\"\"\n    \n    test_cases = [\n        {'u': lambda x, y: x**2 + 3*y**2, 'p': (0.0, 0.0), 'h': (0.01, 0.01), 'alpha': 1.0, 'h_bounds': (0.05, 1.0), 'delta': 1e-12},\n        {'u': lambda x, y: (x + y)**2, 'p': (0.0, 0.0), 'h': (0.01, 0.01), 'alpha': 1.0, 'h_bounds': (0.05, 1.0), 'delta': 1e-6},\n        {'u': lambda x, y: x**2 - y**2, 'p': (0.0, 0.0), 'h': (0.01, 0.01), 'alpha': 1.0, 'h_bounds': (0.05, 1.0), 'delta': 1e-12},\n        {'u': lambda x, y: np.exp(0.5*x)*np.cos(y), 'p': (0.1, -0.2), 'h': (0.01, 0.01), 'alpha': 0.25, 'h_bounds': (0.05, 0.5), 'delta': 1e-12},\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        result = compute_refinement_info(case)\n        all_results.append(result)\n\n    # Format the final output string as a list of lists, with values rounded to 6 decimal places.\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join(f\"{val:.6f}\" for val in res) + \"]\" for res in all_results\n    ) + \"]\"\n    print(output_str)\n\ndef compute_refinement_info(case):\n    \"\"\"\n    Computes the anisotropic refinement information for a single test case.\n    \"\"\"\n    u_func = case['u']\n    x0, y0 = case['p']\n    hx, hy = case['h']\n    alpha = case['alpha']\n    h_min, h_max = case['h_bounds']\n    delta = case['delta']\n\n    # Step 1: Compute Hessian components using central differences\n    u_c = u_func(x0, y0)\n    \n    # H_xx\n    u_xp = u_func(x0 + hx, y0)\n    u_xm = u_func(x0 - hx, y0)\n    H_xx = (u_xp - 2*u_c + u_xm) / hx**2\n    \n    # H_yy\n    u_yp = u_func(x0, y0 + hy)\n    u_ym = u_func(x0, y0 - hy)\n    H_yy = (u_yp - 2*u_c + u_ym) / hy**2\n    \n    # H_xy\n    u_pp = u_func(x0 + hx, y0 + hy)\n    u_pm = u_func(x0 + hx, y0 - hy)\n    u_mp = u_func(x0 - hx, y0 + hy)\n    u_mm = u_func(x0 - hx, y0 - hy)\n    H_xy = (u_pp - u_pm - u_mp + u_mm) / (4 * hx * hy)\n    \n    H = np.array([[H_xx, H_xy], [H_xy, H_yy]])\n\n    # Step 2: Eigendecomposition and sorting\n    evals, evecs = np.linalg.eig(H)\n    \n    # Pair eigenvalues with eigenvectors and sort\n    # Sort by |lambda| descending. Break ties with lambda descending.\n    e_pairs = sorted(zip(evals, evecs.T), key=lambda p: (abs(p[0]), p[0]), reverse=True)\n    \n    lambda1, q1 = e_pairs[0]\n    lambda2, q2 = e_pairs[1]\n\n    # Step 3: Refinement scales and aspect ratio\n    h1 = np.sqrt(alpha / max(abs(lambda1), delta))\n    h2 = np.sqrt(alpha / max(abs(lambda2), delta))\n    \n    # Clamp to [h_min, h_max]\n    h1_clamped = min(h_max, max(h_min, h1))\n    h2_clamped = min(h_max, max(h_min, h2))\n    \n    # Aspect Ratio\n    AR = max(h1_clamped, h2_clamped) / min(h1_clamped, h2_clamped)\n\n    # Step 4: Orientation angle\n    # The orientation is the angle of the eigenvector q1 (associated with lambda1)\n    vx, vy = q1\n    theta = np.arctan2(vy, vx)\n    \n    # Normalize theta to [-pi/2, pi/2)\n    # This formula maps theta to the desired interval.\n    theta = np.mod(theta + np.pi/2, np.pi) - np.pi/2\n\n    # Step 5: Metric Tensor\n    M = alpha * H\n    M_xx, M_xy, M_yy = M[0,0], M[0,1], M[1,1]\n\n    return [H_xx, H_xy, H_yy, lambda1, lambda2, AR, theta, M_xx, M_xy, M_yy]\n\nsolve()\n```", "id": "3573786"}, {"introduction": "一旦确定了加密区域，下一步就是用来自粗网格的数据填充新生成的细网格——这一过程称为“延拓”（prolongation）。本练习的核心是实现一种稳定的延拓方案，它使用分段线性重构和斜率限制器来防止产生虚假的极值。这对于维持模拟的物理真实性至关重要，特别是在处理具有接触间断等特征的流体动力学问题时。[@problem_id:3503480]", "problem": "考虑在计算天体物理学背景下，一个带有接触间断的可压缩流密度的一维有限体积表示。自适应网格加密 (AMR) 旨在从粗网格单元平均值构造细网格初始数据，同时保持守恒性并避免伪极值。其基本基础是单元平均值的有限体积定义以及使用斜率限制器的总变差递减 (TVD) 重构。\n\n设粗网格是均匀的，单元中心位于 $x_i$，宽度为 $\\Delta x$。粗网格单元平均密度为 $\\bar{\\rho}_i = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} \\rho(x)\\,dx$。为了进行延拓，每个粗单元 $i$ 被细分为 $r$ 个细子单元，索引为 $j \\in \\{0,1,\\dots,r-1\\}$，每个子单元的宽度为 $\\Delta x / r$。在每个粗单元 $i$ 内使用分段线性重构，\n$$\n\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x},\n$$\n其中 $s_i$ 是根据相邻粗单元平均值计算的受限斜率，以强制执行 TVD 属性。定义后向和前向差分\n$$\n\\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1}, \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i,\n$$\n以及以下斜率限制器：\n- Minmod 限制器：$\\mathrm{mm}(a,b) = \\begin{cases}\\mathrm{sign}(a)\\min(|a|,|b|),  ab  0, \\\\ 0,  \\text{otherwise.}\\end{cases}$，其中 $s_i = \\mathrm{mm}(\\Delta_-,\\Delta_+)$。\n- 单调中心 (MC) 限制器：$s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)$，其中如果 $ab0$ 和 $ac0$，$\\mathrm{mm}_3(a,b,c)$ 返回 $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$，否则返回 $0$。\n- Van Leer 限制器：$s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+},  \\Delta_- \\Delta_+  0, \\\\ 0,  \\text{otherwise.}\\end{cases}$。\n\n在域边界处，当邻居单元不可用时，设置 $s_i = 0$ 以保持守恒性。粗单元 $i$ 内子单元 $j$ 的子单元平均密度为\n$$\n\\bar{\\rho}_{i,j} = \\frac{r}{\\Delta x}\\int_{x_{i-1/2} + \\frac{j}{r}\\Delta x}^{x_{i-1/2} + \\frac{j+1}{r}\\Delta x} \\rho_i(x)\\,dx.\n$$\n对于上述分段线性的 $\\rho_i(x)$，子单元平均值等于其在子单元中点处的值，从而得到\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j,\\quad c_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right).\n$$\n为了避免接触间断处的伪极值，对每个粗单元 $i$ 施加一个具有局部界限的保界裁剪\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\\quad \\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{i-1},\\bar{\\rho}_i,\\bar{\\rho}_{i+1}\\},\n$$\n在边界处仅使用可用的邻居单元。强制执行\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right).\n$$\n\n实现一个程序，该程序：\n1. 根据指定的限制器计算受限斜率 $s_i$。\n2. 使用上述公式，为给定的加密比 $r$ 计算细网格子单元平均值 $\\bar{\\rho}_{i,j}$。\n3. 对每个粗单元应用保界裁剪。\n4. 将每个测试用例的加密后子单元平均值作为浮点数列表输出。\n\n所有密度均采用无量纲代码单位；无需进行物理单位转换。不涉及角度。程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应测试用例的加密后单元平均密度的一个用方括号括起来的逗号分隔列表，不含空格。例如：$[[a_1,a_2,\\dots],[b_1,b_2,\\dots]]$。\n\n使用以下测试套件，其设计旨在覆盖平滑行为、尖锐接触间断、振荡模式和边界效应：\n- 测试 $1$（平滑单调增加，Minmod，$r=2$）：粗网格平均值 $\\left[\\,1.0,\\,1.1,\\,1.2,\\,1.3\\,\\right]$。\n- 测试 $2$（接触间断，MC，$r=2$）：粗网格平均值 $\\left[\\,1.0,\\,1.0,\\,5.0,\\,5.0\\,\\right]$。\n- 测试 $3$（振荡模式，Van Leer，$r=4$）：粗网格平均值 $\\left[\\,3.0,\\,1.0,\\,3.0,\\,1.0\\,\\right]$。\n- 测试 $4$（具有对称邻居的孤立跳跃，Minmod，$r=2$）：粗网格平均值 $\\left[\\,0.5,\\,0.5,\\,2.0,\\,0.5,\\,0.5\\,\\right]$。\n\n对于每个测试用例，输出应为展平的细网格列表 $\\left[\\,\\bar{\\rho}_{0,0},\\dots,\\bar{\\rho}_{0,r-1},\\bar{\\rho}_{1,0},\\dots,\\bar{\\rho}_{1,r-1},\\dots\\,\\right]$，并采用指定格式。最终输出必须是单行形式 $[ \\text{case1\\_list}, \\text{case2\\_list}, \\text{case3\\_list}, \\text{case4\\_list} ]$，且不含任何空格。", "solution": "问题陈述经评估有效。它提出了一个明确定义的计算任务，该任务基于流体动力学数值方法的既定原理，特别是关于自适应网格加密 (AMR) 的原理。所提供的分段线性重构、斜率限制器和子单元平均的公式是标准且正确的。问题是自包含的，指定了所有必要的数据和边界条件，使得每个测试用例都有唯一的解。\n\n将粗网格单元平均密度 $\\bar{\\rho}_i$ 延拓到加密比为 $r$ 的细网格上的过程包括三个主要步骤：斜率计算、子单元平均值计算和保界裁剪。\n\n### 1. 受限斜率计算\n对于每个粗单元 $i$，计算一个斜率 $s_i$ 来定义分段线性重构 $\\rho_i(x) = \\bar{\\rho}_i + s_i \\frac{x - x_i}{\\Delta x}$，其中 $x_i$ 是单元 $i$ 的中心，$\\Delta x$ 是其宽度。为了防止在尖锐特征附近引入伪振荡（这一性质被称为总变差递减或 TVD），斜率 $s_i$ 会根据局部数据进行限制。\n\n计算取决于单元的位置：\n-   **边界单元**：对于域中的第一个 ($i=0$) 和最后一个 ($i=N-1$) 单元，完整的邻居单元集是不可用的。为了保持守恒和简化处理，斜率设为零，即 $s_0 = 0$ 和 $s_{N-1} = 0$。这对应于边界处的分段常数重构。\n-   **内部单元**：对于任何内部单元 $i$，斜率由其直接邻居决定。我们首先计算后向和前向差分：\n    $$\n    \\Delta_- = \\bar{\\rho}_i - \\bar{\\rho}_{i-1} \\quad ; \\quad \\Delta_+ = \\bar{\\rho}_{i+1} - \\bar{\\rho}_i\n    $$\n    然后将这些差分传递给一个斜率限制器函数。问题指定了三种这样的限制器：\n\n    1.  **Minmod 限制器**：这是最具耗散性的限制器，它能强力抑制振荡。斜率由以下公式给出：\n        $$\n        s_i = \\mathrm{mm}(\\Delta_-, \\Delta_+) = \\begin{cases}\\mathrm{sign}(\\Delta_-)\\min(|\\Delta_-|,|\\Delta_+|),  \\Delta_- \\Delta_+  0 \\\\ 0,  \\text{otherwise}\\end{cases}\n        $$\n        只有当数据是局部单调时（即 $\\Delta_-$ 和 $\\Delta_+$ 符号相同），斜率才为非零。在局部极值点，斜率为零。\n\n    2.  **单调中心 (MC) 限制器**：该限制器设计用于在平滑区域比 Minmod 更精确。它使用一个三参数的 minmod 函数定义：\n        $$\n        s_i = \\mathrm{mm}_3\\left(\\frac{\\Delta_- + \\Delta_+}{2}, 2\\Delta_-, 2\\Delta_+\\right)\n        $$\n        其中，如果 $a, b, c$ 符号全部相同，$\\mathrm{mm}_3(a,b,c)$ 返回 $\\mathrm{sign}(a)\\min(|a|,|b|,|c|)$，否则返回 $0$。该限制器考虑中心差分斜率 $(\\Delta_- + \\Delta_+)/2$，并用两倍的单边差分来限制它。\n\n    3.  **Van Leer 限制器**：该限制器在单边差分之间提供平滑过渡，并以能良好解析接触间断而闻名。它是两个差分的调和平均：\n        $$\n        s_i = \\begin{cases}\\frac{2\\Delta_- \\Delta_+}{\\Delta_- + \\Delta_+},  \\Delta_- \\Delta_+  0 \\\\ 0,  \\text{otherwise}\\end{cases}\n        $$\n\n### 2. 子单元平均值延拓\n一旦每个粗单元 $i$ 的斜率 $s_i$ 已知，我们就可以确定其中每个（共 $r$ 个）子单元的平均密度 $\\bar{\\rho}_{i,j}$。子单元的索引为 $j \\in \\{0, 1, \\dots, r-1\\}$。一个线性函数在一个区间上的平均值等于该函数在区间中点处的值。这将积分定义简化为代数定义。粗单元 $i$ 中子单元 $j$ 的中点与粗单元中心 $x_i$ 之间有一个距离因子的偏移。这引出了以下公式：\n$$\n\\bar{\\rho}_{i,j} = \\bar{\\rho}_i + s_i\\,c_j\n$$\n其中系数 $c_j$ 仅取决于子单元索引 $j$ 和加密比 $r$：\n$$\nc_j = \\left(\\frac{j+\\frac{1}{2}}{r} - \\frac{1}{2}\\right)\n$$\n这些系数表示每个子单元中心到父单元中心的归一化距离。例如，对于 $r=2$，我们有 $c_0 = -0.25$ 和 $c_1 = 0.25$。\n\n### 3. 保界裁剪\nTVD 斜率限制器旨在防止在单元界面处重构的点值产生新的极值。然而，为了严格强制新的*单元平均值*也不产生新的局部极值，会额外应用一个裁剪步骤。对于每个粗单元 $i$，我们基于其自身的单元平均值及其可用邻居来定义局部界限：\n$$\n\\rho_{\\min,i} = \\min\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n$$\n\\rho_{\\max,i} = \\max\\{\\bar{\\rho}_{k} \\mid k \\in \\{i-1, i, i+1\\} \\cap [0, N-1]\\}\n$$\n对于边界单元 $i=0$，邻域为 $\\{0, 1\\}$。对于内部单元，邻域为 $\\{i-1, i, i+1\\}$。\n\n然后，每个计算出的子单元平均值 $\\bar{\\rho}_{i,j}$ 被强制限制在这些界限内：\n$$\n\\bar{\\rho}_{i,j} \\leftarrow \\min\\left(\\rho_{\\max,i}, \\max\\left(\\rho_{\\min,i}, \\bar{\\rho}_{i,j}\\right)\\right)\n$$\n这确保了加密后的数据场在局部上仍然受限于原始粗糙数据，这对于稳定性、物理真实性至关重要，尤其是在接触间断处。\n\n### 示例演练：测试用例 1\n-   **输入**：粗网格平均值 $\\bar{\\rho} = [1.0, 1.1, 1.2, 1.3]$，限制器：Minmod，$r=2$。\n-   **斜率**：\n    -   $s_0 = 0$ (边界)。\n    -   $i=1$: $\\Delta_- = 1.1-1.0=0.1$, $\\Delta_+ = 1.2-1.1=0.1$。$\\mathrm{mm}(0.1, 0.1) = 0.1$。因此，$s_1=0.1$。\n    -   $i=2$: $\\Delta_- = 1.2-1.1=0.1$, $\\Delta_+ = 1.3-1.2=0.1$。$\\mathrm{mm}(0.1, 0.1) = 0.1$。因此，$s_2=0.1$。\n    -   $s_3 = 0$ (边界)。\n    -   斜率向量为 $s = [0, 0.1, 0.1, 0]$。\n-   **子单元平均值 ($r=2 \\implies c_0=-0.25, c_1=0.25$)**：\n    -   $i=0$: $\\bar{\\rho}_{0,0} = 1.0 + 0 \\cdot (-0.25) = 1.0$; $\\bar{\\rho}_{0,1} = 1.0 + 0 \\cdot (0.25) = 1.0$。\n    -   $i=1$: $\\bar{\\rho}_{1,0} = 1.1 + 0.1 \\cdot (-0.25) = 1.075$; $\\bar{\\rho}_{1,1} = 1.1 + 0.1 \\cdot (0.25) = 1.125$。\n    -   $i=2$: $\\bar{\\rho}_{2,0} = 1.2 + 0.1 \\cdot (-0.25) = 1.175$; $\\bar{\\rho}_{2,1} = 1.2 + 0.1 \\cdot (0.25) = 1.225$。\n    -   $i=3$: $\\bar{\\rho}_{3,0} = 1.3 + 0 \\cdot (-0.25) = 1.3$; $\\bar{\\rho}_{3,1} = 1.3 + 0 \\cdot (0.25) = 1.3$。\n-   **裁剪**：\n    -   $i=0$: 界限为 $[\\min(1.0, 1.1), \\max(1.0, 1.1)] = [1.0, 1.1]$。值 $[1.0, 1.0]$ 在界限内。\n    -   $i=1$: 界限为 $[\\min(1.0, 1.1, 1.2), \\max(1.0, 1.1, 1.2)] = [1.0, 1.2]$。值 $[1.075, 1.125]$ 在界限内。\n    -   $i=2$: 界限为 $[\\min(1.1, 1.2, 1.3), \\max(1.1, 1.2, 1.3)] = [1.1, 1.3]$。值 $[1.175, 1.225]$ 在界限内。\n    -   $i=3$: 界限为 $[\\min(1.2, 1.3), \\max(1.2, 1.3)] = [1.2, 1.3]$。值 $[1.3, 1.3]$ 在界限内。\n    -   在此情况下，裁剪步骤没有改变任何值，因为 Minmod 限制器已经确保了重构是非振荡的。\n-   **最终结果**：展平后的细单元平均值列表为 $[1.0, 1.0, 1.075, 1.125, 1.175, 1.225, 1.3, 1.3]$。", "answer": "```python\nimport numpy as np\n\ndef minmod_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Minmod limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        return np.sign(delta_minus) * min(abs(delta_minus), abs(delta_plus))\n    return 0.0\n\ndef mm3(a, b, c):\n    \"\"\"Generalized minmod function for three arguments.\"\"\"\n    sa, sb, sc = np.sign(a), np.sign(b), np.sign(c)\n    if sa == sb and sa == sc:\n        return sa * min(abs(a), abs(b), abs(c))\n    return 0.0\n\ndef mc_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Monotonized Central (MC) limited slope.\"\"\"\n    return mm3((delta_minus + delta_plus) / 2.0, 2.0 * delta_minus, 2.0 * delta_plus)\n\ndef van_leer_limiter(delta_minus, delta_plus):\n    \"\"\"Computes the Van Leer limited slope.\"\"\"\n    if delta_minus * delta_plus > 0:\n        # The check for d- * d+ > 0 prevents division by zero,\n        # as d- + d+ could only be zero if both were zero.\n        return (2.0 * delta_minus * delta_plus) / (delta_minus + delta_plus)\n    return 0.0\n\ndef process_case(coarse_rho, limiter_name, r):\n    \"\"\"\n    Performs AMR prolongation for a given set of coarse cell averages.\n\n    Args:\n        coarse_rho (list[float]): The coarse-level cell averages.\n        limiter_name (str): The name of the slope limiter to use ('Minmod', 'MC', 'Van Leer').\n        r (int): The refinement ratio.\n\n    Returns:\n        list[float]: The flattened list of fine-level cell averages after clipping.\n    \"\"\"\n    limiter_funcs = {\n        'Minmod': minmod_limiter,\n        'MC': mc_limiter,\n        'Van Leer': van_leer_limiter\n    }\n    \n    n_coarse = len(coarse_rho)\n    slopes = np.zeros(n_coarse)\n    limiter_func = limiter_funcs[limiter_name]\n\n    # 1. Compute limited slopes for interior cells\n    for i in range(1, n_coarse - 1):\n        delta_minus = coarse_rho[i] - coarse_rho[i-1]\n        delta_plus = coarse_rho[i+1] - coarse_rho[i]\n        slopes[i] = limiter_func(delta_minus, delta_plus)\n    # Slopes at boundaries (i=0, i=n_coarse-1) remain 0\n\n    # 2. Compute fine-level subcell averages with bound-preserving clipping\n    c_j_coeffs = (np.arange(r, dtype=float) + 0.5) / r - 0.5\n    fine_rho = []\n    \n    for i in range(n_coarse):\n        # Determine local bounds from available neighbors\n        neighbors = [coarse_rho[i]]\n        if i > 0:\n            neighbors.append(coarse_rho[i-1])\n        if i  n_coarse - 1:\n            neighbors.append(coarse_rho[i+1])\n        \n        rho_min_i = min(neighbors)\n        rho_max_i = max(neighbors)\n\n        # Compute, clip, and store subcell values\n        for j in range(r):\n            # Calculate value from piecewise linear reconstruction\n            val = coarse_rho[i] + slopes[i] * c_j_coeffs[j]\n            # Apply bound-preserving clipping\n            clipped_val = min(rho_max_i, max(rho_min_i, val))\n            fine_rho.append(clipped_val)\n            \n    return fine_rho\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        {'coarse_rho': [1.0, 1.1, 1.2, 1.3], 'limiter': 'Minmod', 'r': 2},\n        {'coarse_rho': [1.0, 1.0, 5.0, 5.0], 'limiter': 'MC', 'r': 2},\n        {'coarse_rho': [3.0, 1.0, 3.0, 1.0], 'limiter': 'Van Leer', 'r': 4},\n        {'coarse_rho': [0.5, 0.5, 2.0, 0.5, 0.5], 'limiter': 'Minmod', 'r': 2},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        result = process_case(case['coarse_rho'], case['limiter'], case['r'])\n        # Format the list of floats into a string \"[f1,f2,...]\"\n        result_str = '[' + ','.join(map(str, result)) + ']'\n        all_results_str.append(result_str)\n\n    # Combine all case strings into the final output format \"[[...],[...],...]\"\n    # with no spaces.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3503480"}, {"introduction": "在多层级网格结构上进行时间积分是一个核心挑战，因为根据CFL稳定性条件，更精细的网格需要更小的时间步长。本练习将引导您实现“子循环”（subcycling）技术，即在粗网格的每单个时间步内，细网格会执行多个更小的时间步。通过这种方式，您可以确保整个模拟在满足所有层级稳定性要求的同时，最大限度地提高计算效率。[@problem_id:3503472]", "problem": "考虑一个在计算天体物理模拟中采用自适应网格加密（AMR）的一维显式有限体积法求解器，用于求解双曲守恒律。网格层级结构包含三个层级：一个粗网格层级 $\\ell = 0$，一个相对于层级 $\\ell = 0$ 加密因子为 $r_{1} = 3$ 的较细网格层级 $\\ell = 1$，以及一个相对于层级 $\\ell = 1$ 加密因子为 $r_{2} = 2$ 的最细网格层级 $\\ell = 2$。粗网格层级的空间步长为 $\\Delta x_{0} = 9.6 \\times 10^{9}$ 米，因此 $\\Delta x_{1} = \\Delta x_{0}/r_{1}$ 且 $\\Delta x_{2} = \\Delta x_{1}/r_{2}$。在每个层级上解析的最大特征速度（通量雅可比矩阵特征值的最大绝对值）分别为：层级 $\\ell = 0$ 上 $a_{0} = 2.0 \\times 10^{7}$ 米/秒，层级 $\\ell = 1$ 上 $a_{1} = 3.3 \\times 10^{7}$ 米/秒，以及层级 $\\ell = 2$ 上 $a_{2} = 4.0 \\times 10^{7}$ 米/秒。Courant–Friedrichs–Lewy (CFL) 数为 $C_{\\mathrm{CFL}} = 0.45$。\n\n使用适用于双曲系统显式有限体积离散化的 Courant–Friedrichs–Lewy 稳定性要求，首先计算每个 AMR 层级上允许的时间步长，记为 $\\Delta t_{\\ell}^{\\max}$（其中 $\\ell \\in \\{0,1,2\\}$）。然后，假设粗网格层级前进一个时间步长，其长度为 $\\Delta t_{0} = \\Delta t_{0}^{\\max}$。通过选择整数 $n_{1}$ 和 $n_{2}$ 在较细层级上实现层级同步的子循环，使得在一个粗网格层级步长内，层级 $\\ell = 1$ 执行 $n_{1}$ 个子步，层级 $\\ell = 2$ 执行 $n_{2}$ 个子步，同时满足 $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$ 和 $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$，并且 $n_{2}$ 是 $n_{1}$ 的正整数倍以确保嵌套同步。在所有允许的选择中，选取满足这些约束条件的最小的 $n_{1}$ 和最小的倍数 $n_{2}$。\n\n将时间区间 $[0,\\Delta t_{0}]$ 内的同步时间定义为所有较细层级同时完成其整数个子步并因此可以与其父层级进行通量修正的时间点集合；在上述 $n_{2}$ 是 $n_{1}$ 的倍数的约束下，这些时间点即为层级 $\\ell = 1$ 的子步边界。列出这些时间，包括粗网格层级步长的开始和结束时间。所有时间量均以秒为单位表示。\n\n请在最终答案中，按顺序将三元组 $\\left(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}\\right)$、实际的子循环时间步长 $\\left(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}\\right)$ 以及一个粗网格层级步长内的有序同步时间 $\\left(t_{0}, t_{1}, t_{2}, t_{3}, t_{4}, t_{5}\\right)$ 作为单行提供。无需四舍五入。", "solution": "用户提供了一个关于计算天体物理学中自适应网格加密（AMR）模拟时间步进的问题。该问题要求基于 Courant-Friedrichs-Lewy (CFL) 稳定性条件计算时间步长，并确定子循环参数和同步时间。\n\n首先根据所需标准对问题进行验证。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- AMR 层级：$\\ell \\in \\{0, 1, 2\\}$。\n- 从层级 $\\ell=0$ 到 $\\ell=1$ 的加密因子：$r_{1} = 3$。\n- 从层级 $\\ell=1$ 到 $\\ell=2$ 的加密因子：$r_{2} = 2$。\n- 粗网格层级的空间步长：$\\Delta x_{0} = 9.6 \\times 10^{9}$ 米。\n- 空间步长关系：$\\Delta x_{1} = \\Delta x_{0}/r_{1}$ 和 $\\Delta x_{2} = \\Delta x_{1}/r_{2}$。\n- 每个层级上的最大特征速度：$a_{0} = 2.0 \\times 10^{7}$ 米/秒，$a_{1} = 3.3 \\times 10^{7}$ 米/秒，$a_{2} = 4.0 \\times 10^{7}$ 米/秒。\n- Courant-Friedrichs-Lewy (CFL) 数：$C_{\\mathrm{CFL}} = 0.45$。\n- 推进的粗网格层级时间步长：$\\Delta t_{0} = \\Delta t_{0}^{\\max}$。\n- 子循环约束：\n  - 层级 $\\ell=1$ 执行 $n_{1}$ 个子步，且 $\\Delta t_{1} = \\Delta t_{0}/n_{1} \\le \\Delta t_{1}^{\\max}$。\n  - 层级 $\\ell=2$ 执行 $n_{2}$ 个子步，且 $\\Delta t_{2} = \\Delta t_{0}/n_{2} \\le \\Delta t_{2}^{\\max}$。\n- 同步约束：$n_{2}$ 是 $n_{1}$ 的正整数倍。\n- 最小性约束：$n_{1}$ 是满足其约束的最小整数，$n_{2}$ 是满足其约束的 $n_{1}$ 的最小倍数。\n- 同步时间：在粗网格层级步长区间 $[0, \\Delta t_{0}]$ 内，层级 $\\ell=1$ 的子步边界。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学基础**：该问题基于 CFL 条件，这是求解双曲方程的显式数值方法稳定性的一个基本原则。带子循环的 AMR 是计算流体动力学和天体物理学中一种标准的、科学上有效的方法。该问题牢固地建立在成熟的数值分析基础之上。\n- **良定性**：所有必要的参数（$\\Delta x_0$, $r_1$, $r_2$, $a_\\ell$, $C_{\\mathrm{CFL}}$）都已给出。对子循环整数（$n_1, n_2$）的约束定义清晰，并能导出一个唯一的、最小的解。该问题是自洽的，并且在数学上是良定的。\n- **客观性**：该问题使用精确、无歧义的数学术语和物理量来表述。它不含主观性语言。\n\n**第3步：结论与操作**\n该问题是有效的，因为它科学合理、良定且客观。将提供一个完整的解答。\n\n### 解答\n\n解答过程分为几个步骤：\n1.  计算每个层级 $\\ell$ 的空间步长 $\\Delta x_{\\ell}$。\n2.  使用 CFL 条件计算每个层级的最大允许时间步长 $\\Delta t_{\\ell}^{\\max}$。\n3.  确定满足给定约束条件的整数子循环次数 $n_{1}$ 和 $n_{2}$。\n4.  计算用于子循环推进的实际时间步长 $\\Delta t_{\\ell}$。\n5.  列出一个粗网格层级步长内的同步时间。\n\n**1. 空间步长**\n较细层级的空间步长由给定的加密因子确定。\n- 层级 $\\ell=0$：$\\Delta x_{0} = 9.6 \\times 10^{9} \\, \\text{米}$。\n- 层级 $\\ell=1$：$\\Delta x_{1} = \\frac{\\Delta x_{0}}{r_{1}} = \\frac{9.6 \\times 10^{9}}{3} = 3.2 \\times 10^{9} \\, \\text{米}$。\n- 层级 $\\ell=2$：$\\Delta x_{2} = \\frac{\\Delta x_{1}}{r_{2}} = \\frac{3.2 \\times 10^{9}}{2} = 1.6 \\times 10^{9} \\, \\text{米}$。\n\n**2. 最大允许时间步长**\n对于一维显式有限体积格式，CFL 条件指出，为保证稳定性，时间步长 $\\Delta t$ 必须满足 $\\Delta t \\le C_{\\mathrm{CFL}} \\frac{\\Delta x}{a}$，其中 $a$ 是最大特征速度。因此，层级 $\\ell$ 上的最大允许时间步长为 $\\Delta t_{\\ell}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{\\ell}}{a_{\\ell}}$。\n\n- 层级 $\\ell=0$：\n$$ \\Delta t_{0}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{0}}{a_{0}} = 0.45 \\times \\frac{9.6 \\times 10^{9} \\, \\text{米}}{2.0 \\times 10^{7} \\, \\text{米/秒}} = 0.45 \\times (4.8 \\times 10^{2} \\, \\text{秒}) = 216 \\, \\text{秒} $$\n- 层级 $\\ell=1$：\n$$ \\Delta t_{1}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{1}}{a_{1}} = 0.45 \\times \\frac{3.2 \\times 10^{9} \\, \\text{米}}{3.3 \\times 10^{7} \\, \\text{米/秒}} = 0.45 \\times \\frac{3.2}{3.3} \\times 10^{2} \\, \\text{秒} = \\frac{1.44}{3.3} \\times 10^{2} \\, \\text{秒} = \\frac{144}{3.3} \\, \\text{秒} = \\frac{1440}{33} \\, \\text{秒} = \\frac{480}{11} \\, \\text{秒} $$\n- 层级 $\\ell=2$：\n$$ \\Delta t_{2}^{\\max} = C_{\\mathrm{CFL}} \\frac{\\Delta x_{2}}{a_{2}} = 0.45 \\times \\frac{1.6 \\times 10^{9} \\, \\text{米}}{4.0 \\times 10^{7} \\, \\text{米/秒}} = 0.45 \\times (0.4 \\times 10^{2} \\, \\text{秒}) = 18 \\, \\text{秒} $$\n第一组要求的值是 $(216, \\frac{480}{11}, 18)$。\n\n**3. 子循环整数**\n粗网格层级以大小为 $\\Delta t_{0} = \\Delta t_{0}^{\\max} = 216 \\, \\text{秒}$ 的步长前进一个步。\n对于层级 $\\ell=1$，子步数 $n_{1}$ 必须满足 $\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} \\le \\Delta t_{1}^{\\max}$。这意味着：\n$$ n_{1} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{1}^{\\max}} = \\frac{216}{\\frac{480}{11}} = \\frac{216 \\times 11}{480} = \\frac{9 \\times 24 \\times 11}{20 \\times 24} = \\frac{99}{20} = 4.95 $$\n由于 $n_{1}$ 必须是整数，因此 $n_{1}$ 的最小值为 $\\lceil 4.95 \\rceil = 5$。\n\n对于层级 $\\ell=2$，子步数 $n_{2}$ 必须满足 $\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} \\le \\Delta t_{2}^{\\max}$。这意味着：\n$$ n_{2} \\ge \\frac{\\Delta t_{0}}{\\Delta t_{2}^{\\max}} = \\frac{216}{18} = 12 $$\n此外，$n_{2}$ 必须是 $n_{1}=5$ 的正整数倍。我们必须找到大于或等于 $12$ 的 $5$ 的最小倍数。$5$ 的相关倍数是 $5, 10, 15, \\dots$。最小的此类倍数是 $15$。\n因此，所选的子循环整数为 $n_{1} = 5$ 和 $n_{2} = 15$。\n\n**4. 实际的子循环时间步长**\n每个层级的实际时间步长是根据子循环整数计算的。\n- 层级 $\\ell=0$：$\\Delta t_{0} = 216 \\, \\text{秒}$。\n- 层级 $\\ell=1$：$\\Delta t_{1} = \\frac{\\Delta t_{0}}{n_{1}} = \\frac{216}{5} = 43.2 \\, \\text{秒}$。\n- 层级 $\\ell=2$：$\\Delta t_{2} = \\frac{\\Delta t_{0}}{n_{2}} = \\frac{216}{15} = \\frac{72}{5} = 14.4 \\, \\text{秒}$。\n第二组要求的值是 $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$。\n\n**5. 同步时间**\n同步时间是层级 $\\ell=1$ 的子步边界。由于层级 $\\ell=1$ 执行 $n_{1}=5$ 个子步，每个子步持续时间为 $\\Delta t_{1} = 43.2 \\, \\text{秒}$，因此同步时间 $t_j$ 由 $t_j = j \\cdot \\Delta t_{1}$ 给出，其中 $j=0, 1, \\dots, 5$。\n- $t_{0} = 0 \\times 43.2 = 0 \\, \\text{秒}$\n- $t_{1} = 1 \\times 43.2 = 43.2 \\, \\text{秒}$\n- $t_{2} = 2 \\times 43.2 = 86.4 \\, \\text{秒}$\n- $t_{3} = 3 \\times 43.2 = 129.6 \\, \\text{秒}$\n- $t_{4} = 4 \\times 43.2 = 172.8 \\, \\text{秒}$\n- $t_{5} = 5 \\times 43.2 = 216.0 \\, \\text{秒}$\n第三组要求的值是 $(0, 43.2, 86.4, 129.6, 172.8, 216.0)$。\n\n这三组结果合并成一个单行矩阵作为最终答案。\n- $(\\Delta t_{0}^{\\max}, \\Delta t_{1}^{\\max}, \\Delta t_{2}^{\\max}) = (216, \\frac{480}{11}, 18)$\n- $(\\Delta t_{0}, \\Delta t_{1}, \\Delta t_{2}) = (216, 43.2, 14.4)$\n- $(t_0, \\dots, t_5) = (0, 43.2, 86.4, 129.6, 172.8, 216)$", "answer": "[[216.0,43.636363636363635,18.0],[216.0,43.2,14.4],[0.0,43.2,86.4,129.6,172.8,216.0]]", "id": "3503472"}]}