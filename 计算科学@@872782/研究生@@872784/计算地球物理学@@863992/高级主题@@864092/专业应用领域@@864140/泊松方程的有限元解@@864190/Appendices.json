{"hands_on_practices": [{"introduction": "在我们着手解决复杂的大型网格问题之前，我们必须首先理解有限元方法的基本构件。这些构件是在一个简单的、标准化的几何形状（称为参考单元）上定义的“形函数”多项式。本练习将指导您构建线性和二次近似的形函数，并验证它们的基本数学性质[@problem_id:3595599]。", "problem": "考虑一个定义在区域 $\\Omega \\subset \\mathbb{R}^{2}$ 上的二维泊松方程 $-\\nabla \\cdot \\left( \\kappa \\nabla u \\right) = f$，其中 $\\kappa$ 是一个空间变化的标量传导系数，代表计算地球物理学中的地下材料，而 $f$ 是一个源项，例如代表由密度变化引起的体力。在有限元法（FEM）中，使用协调拉格朗日元来逼近弱解，这需要在一个参考单元上构造形函数并验证其插值性质。\n\n设参考三角形为 $\\hat{K} = \\{ (\\xi,\\eta) \\in \\mathbb{R}^{2} : \\xi \\ge 0,\\ \\eta \\ge 0,\\ \\xi + \\eta \\le 1 \\}$，其顶点位于 $(0,0)$、$(1,0)$ 和 $(0,1)$。用 $\\lambda_{1} = 1 - \\xi - \\eta$、$\\lambda_{2} = \\xi$ 和 $\\lambda_{3} = \\eta$ 表示重心坐标。\n\n任务：\n- 构造 $\\hat{K}$ 上的分片线性（$P_{1}$）拉格朗日元的形函数，并在三个顶点节点处验证其单位分解性质和克罗内克-δ插值性质。\n- 构造与六个节点（三个顶点和三个边中点）相关的 $\\hat{K}$ 上的分片二次（$P_{2}$）拉格朗日元的形函数，并在所有六个节点处验证其单位分解性质和克罗内克-δ插值性质。\n- 作为与泊松方程的有限元离散化中质量矩阵组装相关的定量一致性检验，计算标量积分\n$$\nJ_{2} \\;=\\; \\int_{\\hat{K}} \\left( \\sum_{i=1}^{6} \\phi_{i}^{(2)}(\\xi,\\eta)^{2} \\right)\\, d\\xi\\, d\\eta,\n$$\n其中 $\\{ \\phi_{i}^{(2)} \\}_{i=1}^{6}$ 是在 $\\hat{K}$ 上构造的 $P_{2}$ 形函数。请提供 $J_{2}$ 的精确值，作为一个实数。不要四舍五入；给出精确值。", "solution": "该问题要求在参考三角形 $\\hat{K}$ 上为线性（$P_1$）和二次（$P_2$）多项式构造并验证拉格朗日有限元形函数，随后通过计算一个涉及 $P_2$ 形函数的特定积分进行定量检验。该问题是适定的，并且在科学上是合理的，它基于有限元法的基本原理。\n\n设参考三角形为 $\\hat{K} = \\{ (\\xi,\\eta) \\in \\mathbb{R}^{2} : \\xi \\ge 0,\\ \\eta \\ge 0,\\ \\xi + \\eta \\le 1 \\}$。其顶点位于 $v_{1} = (0,0)$、$v_{2} = (1,0)$ 和 $v_{3} = (0,1)$。重心坐标是 $\\hat{K}$ 上的线性函数，给定为 $\\lambda_{1} = 1 - \\xi - \\eta$、$\\lambda_{2} = \\xi$ 和 $\\lambda_{3} = \\eta$。重心坐标的一个关键性质是，在 $\\hat{K}$ 中的任意点 $(\\xi, \\eta)$，它们都是非负的并且和为一：$\\lambda_{1} + \\lambda_{2} + \\lambda_{3} = 1$。此外，坐标 $\\lambda_i$ 在顶点 $v_i$ 处等于 $1$，在另外两个顶点处等于 $0$。\n\n**第一部分：$P_1$ 拉格朗日元**\n\n三角形 $\\hat{K}$ 上的分片线性（$P_1$）拉格朗日元由一组3个节点定义，即三角形的顶点：$n_1 = v_1 = (0,0)$、$n_2 = v_2 = (1,0)$ 和 $n_3 = v_3 = (0,1)$。相应的形函数，记作 $\\phi_i^{(1)}$，必须是线性多项式，并满足克罗内克-δ性质，$\\phi_i^{(1)}(n_j) = \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克-δ。\n\n重心坐标本身就是线性函数，并且在顶点处固有地满足此性质。因此，$P_1$ 形函数就是重心坐标：\n- $\\phi_{1}^{(1)}(\\xi,\\eta) = \\lambda_{1} = 1 - \\xi - \\eta$\n- $\\phi_{2}^{(1)}(\\xi,\\eta) = \\lambda_{2} = \\xi$\n- $\\phi_{3}^{(1)}(\\xi,\\eta) = \\lambda_{3} = \\eta$\n\n我们来验证所需的性质：\n1.  **克罗内克-δ性质**：我们在每个节点上评估每个形函数。\n    - 在 $n_1 = (0,0)$ 处：$(\\lambda_1, \\lambda_2, \\lambda_3) = (1,0,0)$。因此，$\\phi_{1}^{(1)}(n_1)=1$，$\\phi_{2}^{(1)}(n_1)=0$，$\\phi_{3}^{(1)}(n_1)=0$。\n    - 在 $n_2 = (1,0)$ 处：$(\\lambda_1, \\lambda_2, \\lambda_3) = (0,1,0)$。因此，$\\phi_{1}^{(1)}(n_2)=0$，$\\phi_{2}^{(1)}(n_2)=1$，$\\phi_{3}^{(1)}(n_2)=0$。\n    - 在 $n_3 = (0,1)$ 处：$(\\lambda_1, \\lambda_2, \\lambda_3) = (0,0,1)$。因此，$\\phi_{1}^{(1)}(n_3)=0$，$\\phi_{2}^{(1)}(n_3)=0$，$\\phi_{3}^{(1)}(n_3)=1$。\n    对于 $i,j \\in \\{1,2,3\\}$，性质 $\\phi_i^{(1)}(n_j) = \\delta_{ij}$ 得到满足。\n\n2.  **单位分解性质**：在单元上的任何地方，形函数的和必须等于 $1$。\n    $$ \\sum_{i=1}^{3} \\phi_{i}^{(1)}(\\xi,\\eta) = \\phi_{1}^{(1)} + \\phi_{2}^{(1)} + \\phi_{3}^{(1)} = \\lambda_{1} + \\lambda_{2} + \\lambda_{3} = (1-\\xi-\\eta) + \\xi + \\eta = 1 $$\n    对于所有 $(\\xi, \\eta) \\in \\hat{K}$，此性质都得到满足。\n\n**第二部分：$P_2$ 拉格朗日元**\n\n分片二次（$P_2$）拉格朗日元由 $6$ 个节点定义：$3$ 个顶点和 $3$ 个边的中点。我们将节点定义如下：\n- 顶点：$n_1 = (0,0)$、$n_2 = (1,0)$、$n_3 = (0,1)$。\n- 边中点：$n_4 = (\\frac{1}{2},0)$（$n_1$-$n_2$ 的中点）、$n_5 = (\\frac{1}{2},\\frac{1}{2})$（$n_2$-$n_3$ 的中点）以及 $n_6 = (0,\\frac{1}{2})$（$n_3$-$n_1$ 的中点）。\n\n这些节点的重心坐标是：\n- $n_1 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (1,0,0)$\n- $n_2 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (0,1,0)$\n- $n_3 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (0,0,1)$\n- $n_4 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{2},\\frac{1}{2},0)$\n- $n_5 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (0,\\frac{1}{2},\\frac{1}{2})$\n- $n_6 \\rightarrow (\\lambda_1, \\lambda_2, \\lambda_3) = (\\frac{1}{2},0,\\frac{1}{2})$\n\n$P_2$ 形函数 $\\phi_i^{(2)}$ 是使用重心坐标的乘积构造的二次多项式。\n- 对于顶点节点 $n_i$（其中 $i=1,2,3$），形函数的形式为 $\\phi_{i}^{(2)} = c_i \\lambda_i (\\lambda_i - \\frac{1}{2})$。归一化常数 $c_i$ 通过要求 $\\phi_i^{(2)}(n_i)=1$ 来找到。在 $n_i$ 处，$\\lambda_i=1$，所以 $c_i(1)(1-\\frac{1}{2}) = 1 \\implies c_i = 2$。因此，$\\phi_{i}^{(2)} = 2\\lambda_i(\\lambda_i - \\frac{1}{2}) = \\lambda_i(2\\lambda_i - 1)$。\n- 对于位于顶点 $n_i$ 和 $n_j$ 之间边上的中点节点 $n_k$（其中 $k=4,5,6$），形函数的形式为 $\\phi_{k}^{(2)} = c_k \\lambda_i \\lambda_j$。常数 $c_k$ 通过要求 $\\phi_k^{(2)}(n_k)=1$ 来找到。在 $n_k$ 处，$\\lambda_i=\\lambda_j=\\frac{1}{2}$，所以 $c_k(\\frac{1}{2})(\\frac{1}{2})=1 \\implies c_k=4$。因此，形函数为 $\\phi_{k}^{(2)} = 4\\lambda_i \\lambda_j$。\n\n这 $6$ 个形函数是：\n- 顶点节点：\n  - $\\phi_{1}^{(2)} = \\lambda_{1}(2\\lambda_{1} - 1)$\n  - $\\phi_{2}^{(2)} = \\lambda_{2}(2\\lambda_{2} - 1)$\n  - $\\phi_{3}^{(2)} = \\lambda_{3}(2\\lambda_{3} - 1)$\n- 中点节点：\n  - $\\phi_{4}^{(2)} = 4\\lambda_{1}\\lambda_{2}$ (对于 $n_1$ 和 $n_2$ 之间的节点 $n_4$)\n  - $\\phi_{5}^{(2)} = 4\\lambda_{2}\\lambda_{3}$ (对于 $n_2$ 和 $n_3$ 之间的节点 $n_5$)\n  - $\\phi_{6}^{(2)} = 4\\lambda_{3}\\lambda_{1}$ (对于 $n_3$ 和 $n_1$ 之间的节点 $n_6$)\n\n我们来验证这些性质：\n1.  **克罗内克-δ性质**：我们必须验证对于所有 $i,j \\in \\{1, \\dots, 6\\}$，$\\phi_i^{(2)}(n_j) = \\delta_{ij}$。这是一个系统性的检查。\n    - 对于顶点形函数 $\\phi_i^{(2)}$（$i \\in \\{1,2,3\\}$）：在任意顶点 $n_j$ 处，一个 $\\lambda_k$ 为 $1$，其余为 $0$。因此 $\\phi_i^{(2)}(n_j) = \\delta_{ij}(2\\delta_{ij}-1)|_{n_j} = \\delta_{ij}$。在任意中点 $n_k$ 处，两个 $\\lambda$ 为 $\\frac{1}{2}$，一个为 $0$。如果 $\\phi_i^{(2)}$ 对应于不在此边上的顶点，则其 $\\lambda_i=0$，所以 $\\phi_i^{(2)}=0$。如果它对应于边上的一个顶点，则其 $\\lambda_i=\\frac{1}{2}$，所以 $\\phi_i^{(2)} = \\frac{1}{2}(2(\\frac{1}{2})-1)=0$。因此，顶点形函数在自己的节点上为 $1$，在所有其他节点上为 $0$。\n    - 对于中点形函数 $\\phi_k^{(2)}$（$k \\in \\{4,5,6\\}$），例如 $\\phi_4^{(2)} = 4\\lambda_1\\lambda_2$：在任意顶点 $n_j$ 处，$\\lambda_1=0$ 或 $\\lambda_2=0$（或两者都为零），所以 $\\phi_4^{(2)}(n_j)=0$。在其自身的节点 $n_4$ 处，$\\lambda_1=\\lambda_2=\\frac{1}{2}$，所以 $\\phi_4^{(2)}(n_4) = 4(\\frac{1}{2})(\\frac{1}{2})=1$。在其他中点 $n_5$ 或 $n_6$ 处，$\\lambda_1=0$ 或 $\\lambda_2=0$，所以 $\\phi_4^{(2)}$ 为零。\n    所有 $6$ 个形函数都满足克罗内克-δ性质。\n\n2.  **单位分解性质**：\n    $$ \\sum_{i=1}^{6} \\phi_i^{(2)} = \\sum_{i=1}^{3} \\lambda_i(2\\lambda_i - 1) + 4\\lambda_1\\lambda_2 + 4\\lambda_2\\lambda_3 + 4\\lambda_3\\lambda_1 $$\n    $$ = (2\\lambda_1^2 - \\lambda_1) + (2\\lambda_2^2 - \\lambda_2) + (2\\lambda_3^2 - \\lambda_3) + 4\\lambda_1\\lambda_2 + 4\\lambda_2\\lambda_3 + 4\\lambda_3\\lambda_1 $$\n    $$ = 2(\\lambda_1^2 + \\lambda_2^2 + \\lambda_3^2 + 2\\lambda_1\\lambda_2 + 2\\lambda_2\\lambda_3 + 2\\lambda_3\\lambda_1) - (\\lambda_1 + \\lambda_2 + \\lambda_3) $$\n    使用恒等式 $(\\lambda_1+\\lambda_2+\\lambda_3)^2 = \\lambda_1^2+\\lambda_2^2+\\lambda_3^2+2\\lambda_1\\lambda_2+2\\lambda_2\\lambda_3+2\\lambda_3\\lambda_1$，此表达式可简化为：\n    $$ = 2(\\lambda_1 + \\lambda_2 + \\lambda_3)^2 - (\\lambda_1 + \\lambda_2 + \\lambda_3) $$\n    由于 $\\lambda_1 + \\lambda_2 + \\lambda_3 = 1$，和为 $2(1)^2 - 1 = 1$。单位分解性质得到满足。\n\n**第三部分：积分 $J_2$ 的计算**\n\n我们需要计算 $J_{2} = \\int_{\\hat{K}} \\left( \\sum_{i=1}^{6} \\phi_{i}^{(2)}(\\xi,\\eta)^{2} \\right)\\, d\\xi\\, d\\eta$。我们可以计算每个形函数平方的积分，然后将结果相加。为此，我们使用三角形上重心坐标中多项式的积分公式：\n$$ \\int_{\\hat{K}} \\lambda_1^a \\lambda_2^b \\lambda_3^c \\, d\\xi d\\eta = 2A \\frac{a! b! c!}{(a+b+c+2)!} $$\n其中 $A$ 是三角形的面积。对于我们的参考三角形 $\\hat{K}$，面积为 $A = \\frac{1}{2}$。该公式简化为：\n$$ \\int_{\\hat{K}} \\lambda_1^a \\lambda_2^b \\lambda_3^c \\, d\\xi d\\eta = \\frac{a! b! c!}{(a+b+c+2)!} $$\n\n1.  **顶点形函数（$\\phi_1^{(2)}, \\phi_2^{(2)}, \\phi_3^{(2)}$）的积分**：\n    根据对称性，它们平方的积分是相同的。我们计算 $\\phi_1^{(2)}$ 的情况：\n    $$ (\\phi_1^{(2)})^2 = (\\lambda_1(2\\lambda_1-1))^2 = 4\\lambda_1^4 - 4\\lambda_1^3 + \\lambda_1^2 $$\n    $$ \\int_{\\hat{K}} (\\phi_1^{(2)})^2 \\, d\\xi d\\eta = \\int_{\\hat{K}} (4\\lambda_1^4 - 4\\lambda_1^3 + \\lambda_1^2) \\, d\\xi d\\eta $$\n    $$ = 4 \\int_{\\hat{K}} \\lambda_1^4 \\,d\\xi d\\eta - 4 \\int_{\\hat{K}} \\lambda_1^3 \\,d\\xi d\\eta + \\int_{\\hat{K}} \\lambda_1^2 \\,d\\xi d\\eta $$\n    使用该公式：\n    - $\\int_{\\hat{K}} \\lambda_1^4 = \\frac{4!0!0!}{(4+0+0+2)!} = \\frac{24}{720} = \\frac{1}{30}$\n    - $\\int_{\\hat{K}} \\lambda_1^3 = \\frac{3!0!0!}{(3+0+0+2)!} = \\frac{6}{120} = \\frac{1}{20}$\n    - $\\int_{\\hat{K}} \\lambda_1^2 = \\frac{2!0!0!}{(2+0+0+2)!} = \\frac{2}{24} = \\frac{1}{12}$\n    积分为 $4(\\frac{1}{30}) - 4(\\frac{1}{20}) + \\frac{1}{12} = \\frac{2}{15} - \\frac{1}{5} + \\frac{1}{12} = \\frac{8-12+5}{60} = \\frac{1}{60}$。\n    三个顶点形函数的和为 $3 \\times \\frac{1}{60} = \\frac{3}{60} = \\frac{1}{20}$。\n\n2.  **中点形函数（$\\phi_4^{(2)}, \\phi_5^{(2)}, \\phi_6^{(2)}$）的积分**：\n    根据对称性，这些积分也是相同的。我们计算 $\\phi_4^{(2)}$ 的情况：\n    $$ (\\phi_4^{(2)})^2 = (4\\lambda_1\\lambda_2)^2 = 16\\lambda_1^2\\lambda_2^2 $$\n    $$ \\int_{\\hat{K}} (\\phi_4^{(2)})^2 \\, d\\xi d\\eta = 16 \\int_{\\hat{K}} \\lambda_1^2\\lambda_2^2 \\, d\\xi d\\eta $$\n    使用公式，其中 $a=2, b=2, c=0$：\n    $$ \\int_{\\hat{K}} \\lambda_1^2\\lambda_2^2 = \\frac{2!2!0!}{(2+2+0+2)!} = \\frac{4}{6!} = \\frac{4}{720} = \\frac{1}{180} $$\n    积分为 $16 \\times \\frac{1}{180} = \\frac{4}{45}$。\n    三个中点形函数的和为 $3 \\times \\frac{4}{45} = \\frac{12}{45} = \\frac{4}{15}$。\n\n3.  **总积分 $J_2$**：\n    将所有六个形函数的贡献相加：\n    $$ J_2 = \\sum_{i=1}^{6} \\int_{\\hat{K}} (\\phi_i^{(2)})^2 d\\xi d\\eta = \\frac{1}{20} + \\frac{4}{15} $$\n    为了对这些分数求和，我们找到一个公分母，即 $60$：\n    $$ J_2 = \\frac{3}{60} + \\frac{16}{60} = \\frac{19}{60} $$\n积分 $J_2$ 的精确值为 $\\frac{19}{60}$。", "answer": "$$\n\\boxed{\\frac{19}{60}}\n$$", "id": "3595599"}, {"introduction": "在理解了单个单元上的形函数之后，下一步是了解如何将这些局部贡献组合起来，形成描述整个问题域的全局方程组。此实践涉及为一个简单的双单元网格手动组装刚度矩阵和载荷向量。这种手动计算对于揭开组装过程的神秘面纱至关重要，并有助于理解诸如各向异性电导率张量等材料属性是如何被纳入模型中的[@problem_id:3595596]。", "problem": "考虑一个二维均匀但各向异性介质的稳态扩散模型，该模型代表了地下流的一个横截面。设控制方程为带有线性本构关系的守恒定律：质量守恒要求通量的散度等于源项，并且通量通过一个各向异性导率张量与势的梯度成正比。这就得到了强形式的扩散方程\n$$\n- \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right) = f \\quad \\text{in } \\Omega,\n$$\n在域 $\\Omega = [0,1] \\times [0,1]$ 上，边界条件为\n$$\nu = 0 \\quad \\text{on } \\Gamma_{\\mathrm{D}} := \\{ (x,y) \\in \\partial \\Omega : x = 0 \\text{ or } y = 0 \\}, \\qquad \\left( \\mathbf{K} \\nabla u \\right) \\cdot \\mathbf{n} = 0 \\quad \\text{on } \\Gamma_{\\mathrm{N}} := \\partial \\Omega \\setminus \\Gamma_{\\mathrm{D}}.\n$$\n假设源项 $f(x,y) = 1$ 为常数，导率张量为一个恒定的、对称正定的张量\n$$\n\\mathbf{K} = \\begin{pmatrix} 2  1 \\\\ 1  3 \\end{pmatrix}.\n$$\n所有量都已无量纲化；将 $u$ 报告为一个纯数。\n\n使用一阶连续 Lagrange 有限元（通常记为 $P_1$ 元）在单纯复形网格上对 $\\Omega$ 进行离散化，该网格是通过沿从 $(0,0)$ 到 $(1,1)$ 的对角线将单位正方形划分为两个三角形而形成的。将网格顶点标记如下：节点 $1$ 在 $(0,0)$，节点 $2$ 在 $(1,0)$，节点 $3$ 在 $(0,1)$，节点 $4$ 在 $(1,1)$。设三角形 $T_1$ 的顶点为 $(1,2,4)$，三角形 $T_2$ 的顶点为 $(1,4,3)$，两者均按逆时针排序。\n\n从控制守恒定律和本构关系出发，推导其弱形式，然后在此网格上构建协调 $P_1$ 有限元离散化。手动组装：\n- $T_1$ 和 $T_2$ 上的单元刚度矩阵和单元载荷向量，\n- 在施加本质边界条件之前的全局刚度矩阵和全局载荷向量。\n\n然后通过消元法在 $\\Gamma_{\\mathrm{D}}$ 上施加本质边界条件。求解得到的线性系统，以求得节点 $4$ 处唯一剩余的自由度。在节点 $4$ 处，有限元近似解 $u$ 的值是多少？请提供精确值（不要四舍五入），并且不带单位。", "solution": "首先根据指定标准对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- **控制方程：** $- \\nabla \\cdot \\left( \\mathbf{K} \\, \\nabla u \\right) = f$\n- **域：** $\\Omega = [0,1] \\times [0,1]$\n- **导率张量：** $\\mathbf{K} = \\begin{pmatrix} 2  1 \\\\ 1  3 \\end{pmatrix}$\n- **源项：** $f(x,y) = 1$\n- **边界条件：**\n  - Dirichlet: $u = 0$ on $\\Gamma_{\\mathrm{D}} := \\{ (x,y) \\in \\partial \\Omega : x = 0 \\text{ or } y = 0 \\}$\n  - Neumann: $\\left( \\mathbf{K} \\nabla u \\right) \\cdot \\mathbf{n} = 0$ on $\\Gamma_{\\mathrm{N}} := \\partial \\Omega \\setminus \\Gamma_{\\mathrm{D}}$\n- **离散化：** 在单纯复形网格上的一阶连续 Lagrange 有限元 ($P_1$)。\n- **网格顶点（节点）：**\n  - 节点 1: $(0,0)$\n  - 节点 2: $(1,0)$\n  - 节点 3: $(0,1)$\n  - 节点 4: $(1,1)$\n- **网格单元（三角形）：**\n  - $T_1$：顶点 $(1, 2, 4)$，对应坐标 $((0,0), (1,0), (1,1))$\n  - $T_2$：顶点 $(1, 4, 3)$，对应坐标 $((0,0), (1,1), (0,1))$\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：** 该问题描述了一个各向异性介质中的稳态扩散过程，由一个二阶椭圆型偏微分方程控制。这是许多STEM（科学、技术、工程和数学）领域中的一个基础且成熟的模型，包括物理学（热传导）、工程学（地下流）和计算地球物理学。导率张量 $\\mathbf{K}$ 是对称正定的（$\\det(\\mathbf{K}) = 2 \\cdot 3 - 1 \\cdot 1 = 5  0$；主子式为 $20, 50$），这确保了扩散问题的物理和数学上的适定性。\n- **适定性：** 该问题是泊松型方程的一个标准边值问题。在分割的边界上使用混合 Dirichlet 和齐次 Neumann 边界条件，确保了解的存在性和唯一性（根据 Lax-Milgram 定理）。\n- **客观性：** 该问题使用精确的数学语言和客观数据进行规定。没有主观或模糊的陈述。注意到了一个微小的不精确之处：$T_2$ 的顶点被列为 $(1,4,3)$ 并被描述为“按逆时针排序”，但其对应的坐标 $((0,0), (1,1), (0,1))$ 描绘出的是一条顺时针路径。这种描述上的不一致并不会使问题无效，因为几何形状已由坐标明确定义。计算可以基于给定的坐标一致地进行。\n\n### 步骤3：结论和行动\n该问题是有效的。它在科学上是合理的、适定的、客观的，并提供了进行求解所需的所有必要信息。\n\n### 弱形式的推导\n控制方程的强形式为：\n$$ - \\nabla \\cdot (\\mathbf{K} \\nabla u) = f \\quad \\text{in } \\Omega $$\n我们将其与一个来自合适空间的检验函数 $v$ 相乘，并在域 $\\Omega$ 上积分：\n$$ - \\int_{\\Omega} v (\\nabla \\cdot (\\mathbf{K} \\nabla u)) \\, d\\Omega = \\int_{\\Omega} v f \\, d\\Omega $$\n使用散度定理（或 Green 第一恒等式），我们进行分部积分：\n$$ \\int_{\\Omega} (\\nabla v)^T (\\mathbf{K} \\nabla u) \\, d\\Omega - \\int_{\\partial \\Omega} v (\\mathbf{K} \\nabla u) \\cdot \\mathbf{n} \\, d\\Gamma = \\int_{\\Omega} v f \\, d\\Omega $$\n边界 $\\partial \\Omega$ 被划分为 $\\Gamma_D$ 和 $\\Gamma_N$。检验函数 $v$ 必须属于满足齐次 Dirichlet 条件（即在 $\\Gamma_D$ 上 $v=0$）的有限能量函数空间。这使得在 $\\Gamma_D$ 上的边界积分为零。由于指定的齐次 Neumann 条件 $(\\mathbf{K} \\nabla u) \\cdot \\mathbf{n} = 0$ 在 $\\Gamma_N$ 上成立，因此在 $\\Gamma_N$ 上的边界积分也为零。\n得到的弱形式是：寻找 $u \\in H^1(\\Omega)$ 且在 $\\Gamma_D$ 上 $u=0$，使得对于所有检验函数 $v \\in H^1_0(\\Omega, \\Gamma_D)$：\n$$ \\int_{\\Omega} (\\nabla v)^T \\mathbf{K} \\nabla u \\, d\\Omega = \\int_{\\Omega} v f \\, d\\Omega $$\n这可以写成 $a(u,v) = L(v)$ 的形式，其中 $a(u,v) = \\int_{\\Omega} (\\nabla v)^T \\mathbf{K} \\nabla u \\, d\\Omega$ 是一个双线性形式，而 $L(v) = \\int_{\\Omega} v f \\, d\\Omega$ 是一个线性泛函。\n\n### 有限元离散化\n域 $\\Omega$ 被离散化为有限元。在每个单元 $T_e$ 内，解被近似为节点基函数 $N_i$ 的线性组合：$u_h(x,y) = \\sum_{j} U_j N_j(x,y)$。应用 Galerkin 方法，我们使用基函数 $N_i$ 作为检验函数。这导出一个线性系统 $\\mathbf{S} \\mathbf{U} = \\mathbf{F}$，其中全局刚度矩阵 $\\mathbf{S}$ 和全局载荷向量 $\\mathbf{F}$ 的项为：\n$$ S_{ij} = a(N_j, N_i) = \\int_{\\Omega} (\\nabla N_i)^T \\mathbf{K} \\nabla N_j \\, d\\Omega, \\quad F_i = L(N_i) = \\int_{\\Omega} N_i f \\, d\\Omega $$\n这些是由单元贡献组装而成的：$\\mathbf{s}^{(e)}_{ij} = \\int_{T_e} (\\nabla N_i)^T \\mathbf{K} \\nabla N_j \\, dA$ 和 $\\mathbf{f}^{(e)}_{i} = \\int_{T_e} N_i f \\, dA$。\n\n对于一个 $P_1$ 三角形单元，重心坐标基函数的梯度是常数。单元刚度矩阵由 $\\mathbf{s}^{(e)} = A_e (\\mathbf{B}^{(e)})^T \\mathbf{K} \\mathbf{B}^{(e)}$ 给出，其中 $A_e$ 是单元面积，$\\mathbf{B}^{(e)}$ 是一个矩阵，其列是局部基函数的梯度。对于一个常数源 $f$，单元中每个节点 $i$ 的单元载荷向量为 $\\mathbf{f}^{(e)}_i = f \\frac{A_e}{3}$。\n\n### 单元矩阵计算\n**三角形 $T_1$：** 顶点 (1, 2, 4) 分别位于 $(0,0)$, $(1,0)$, $(1,1)$。\n面积 $A_1 = \\frac{1}{2}$。对应于全局节点 $(1,2,4)$ 的局部节点 $(1,2,3)$ 的梯度矩阵是：\n$$ \\mathbf{B}^{(1)} = \\begin{pmatrix} -1  1  0 \\\\ 0  -1  1 \\end{pmatrix} $$\n节点 $(1,2,4)$ 的单元刚度矩阵 $\\mathbf{s}^{(1)}$ 是：\n$$ \\mathbf{s}^{(1)} = A_1 (\\mathbf{B}^{(1)})^T \\mathbf{K} \\mathbf{B}^{(1)} = \\frac{1}{2} \\begin{pmatrix} -1  0 \\\\ 1  -1 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 2  1 \\\\ 1  3 \\end{pmatrix} \\begin{pmatrix} -1  1  0 \\\\ 0  -1  1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 2  -1  -1 \\\\ -1  3  -2 \\\\ -1  -2  3 \\end{pmatrix} $$\n单元载荷向量 $\\mathbf{f}^{(1)}$ 是：\n$$ \\mathbf{f}^{(1)} = f \\frac{A_1}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = 1 \\cdot \\frac{1/2}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{6} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\n\n**三角形 $T_2$：** 顶点 (1, 4, 3) 分别位于 $(0,0)$, $(1,1)$, $(0,1)$。\n面积 $A_2 = \\frac{1}{2}$。对应于全局节点 $(1,4,3)$ 的局部节点 $(1,2,3)$ 的梯度矩阵是：\n$$ \\mathbf{B}^{(2)} = \\begin{pmatrix} 0  1  -1 \\\\ -1  0  1 \\end{pmatrix} $$\n节点 $(1,4,3)$ 的单元刚度矩阵 $\\mathbf{s}^{(2)}$ 是：\n$$ \\mathbf{s}^{(2)} = A_2 (\\mathbf{B}^{(2)})^T \\mathbf{K} \\mathbf{B}^{(2)} = \\frac{1}{2} \\begin{pmatrix} 0  -1 \\\\ 1  0 \\\\ -1  1 \\end{pmatrix} \\begin{pmatrix} 2  1 \\\\ 1  3 \\end{pmatrix} \\begin{pmatrix} 0  1  -1 \\\\ -1  0  1 \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 3  -1  -2 \\\\ -1  2  -1 \\\\ -2  -1  3 \\end{pmatrix} $$\n单元载荷向量 $\\mathbf{f}^{(2)}$ 是：\n$$ \\mathbf{f}^{(2)} = f \\frac{A_2}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = 1 \\cdot \\frac{1/2}{3} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{6} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\n\n### 全局系统的组装与求解\n全局矩阵 $\\mathbf{S}$ 和 $\\mathbf{F}$ 是通过对单元贡献求和来组装的。\n全局刚度矩阵是：\n$$ \\mathbf{S} = \\frac{1}{2} \\begin{pmatrix}\ns^{(1)}_{11}+s^{(2)}_{11}  s^{(1)}_{12}  s^{(2)}_{13}  s^{(1)}_{13}+s^{(2)}_{12} \\\\\ns^{(1)}_{21}  s^{(1)}_{22}  0  s^{(1)}_{23} \\\\\ns^{(2)}_{31}  0  s^{(2)}_{33}  s^{(2)}_{32} \\\\\ns^{(1)}_{31}+s^{(2)}_{21}  s^{(1)}_{32}  s^{(2)}_{23}  s^{(1)}_{33}+s^{(2)}_{22}\n\\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix}\n2+3  -1  -2  -1-1 \\\\\n-1  3  0  -2 \\\\\n-2  0  3  -1 \\\\\n-1-1  -2  -1  3+2\n\\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix}\n5  -1  -2  -2 \\\\\n-1  3  0  -2 \\\\\n-2  0  3  -1 \\\\\n-2  -2  -1  5\n\\end{pmatrix} $$\n全局载荷向量是：\n$$ \\mathbf{F} = \\begin{pmatrix} f^{(1)}_1+f^{(2)}_1 \\\\ f^{(1)}_2 \\\\ f^{(2)}_3 \\\\ f^{(1)}_3+f^{(2)}_2 \\end{pmatrix} = \\begin{pmatrix} 1/6+1/6 \\\\ 1/6 \\\\ 1/6 \\\\ 1/6+1/6 \\end{pmatrix} = \\begin{pmatrix} 1/3 \\\\ 1/6 \\\\ 1/6 \\\\ 1/3 \\end{pmatrix} $$\n完整的系统是 $\\mathbf{S} \\mathbf{U} = \\mathbf{F}$。\n在 $\\Gamma_D$ 上的 Dirichlet 边界条件 $u=0$ 应用于节点 $1$、$2$ 和 $3$。因此，我们有 $U_1=0$、$U_2=0$ 和 $U_3=0$。\n我们只需要求解未知自由度 $U_4$。我们使用线性系统的第四个方程：\n$$ S_{41}U_1 + S_{42}U_2 + S_{43}U_3 + S_{44}U_4 = F_4 $$\n代入已知值和矩阵项：\n$$ \\frac{1}{2}(-2)U_1 + \\frac{1}{2}(-2)U_2 + \\frac{1}{2}(-1)U_3 + \\frac{1}{2}(5)U_4 = \\frac{1}{3} $$\n$$ \\frac{1}{2}(-2(0) - 2(0) - 1(0) + 5 U_4) = \\frac{1}{3} $$\n$$ \\frac{5}{2}U_4 = \\frac{1}{3} $$\n求解 $U_4$：\n$$ U_4 = \\frac{1}{3} \\cdot \\frac{2}{5} = \\frac{2}{15} $$\n在节点 $4$ 处有限元近似解 $u$ 的值是 $U_4$。", "answer": "$$\\boxed{\\frac{2}{15}}$$", "id": "3595596"}, {"introduction": "一个数值方法的好坏取决于其准确性和效率。本计算练习将从理论转向验证，要求您实现一个一维有限元求解器来研究其收敛行为。通过将数值解与带有点源问题的精确解析解进行比较，您将凭经验测量该方法的误差衰减率，并发现局部网格细化对求解精度的深远影响，这是真实地球物理建模中的一项关键技术[@problem_id:3595604]。", "problem": "考虑在开区间 $\\Omega = (0,1)$ 上带有一个集中点源的一维泊松方程，\n$$\n- \\frac{d^2 u}{dx^2} = f \\quad \\text{in } \\Omega,\n$$\n服从齐次狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。设源是位于点 $x_0 \\in (0,1)$ 的单位狄拉克分布，即\n$$\nf = \\delta_{x_0}.\n$$\n其弱形式为：求 $u \\in H^1_0(\\Omega)$，使得\n$$\n\\int_0^1 u'(x) v'(x)\\,dx = v(x_0)\n$$\n对所有测试函数 $v \\in H^1_0(\\Omega)$ 成立。您将使用标准一阶拉格朗日基函数（通常称为 $P_1$ 单元），在 $\\Omega$ 的一个剖分（网格）上，通过有限元法 (FEM) 来近似求解此问题。\n\n目标是计算当网格加密时，有限元法解在 $H^1$ 半范数和 $L^2$ 范数下的经验误差衰减率，并比较：\n- 均匀加密策略（所有单元大小相等），以及\n- 在点源 $x_0$ 附近放置更多、更小单元的局部加密策略。\n\n您的程序必须：\n1. 从弱形式推导出点源对应的正确离散载荷向量。具体来说，对于节点基函数 $\\{\\phi_i\\}$，载荷向量的分量必须满足\n$$\nF_i = \\phi_i(x_0).\n$$\n2. 为 $P_1$ 单元组装全局刚度矩阵。对于长度为 $h_e$ 的单元，其单元刚度矩阵为\n$$\n\\begin{pmatrix}\n1  -1 \\\\\n-1  1\n\\end{pmatrix} \\frac{1}{h_e}.\n$$\n3. 通过仅求解内部自由度来施加齐次狄利克雷边界条件。\n4. 使用精确连续解进行验证。对于 $(0,1)$ 上带有齐次狄利克雷边界条件和位于 $x_0$ 的单位狄拉克源的算子 $-d^2/dx^2$，其唯一的弱解是格林函数\n$$\nG(x;x_0) =\n\\begin{cases}\n(1 - x_0)\\, x,  \\text{if } x \\le x_0,\\\\\nx_0\\, (1 - x),  \\text{if } x \\ge x_0,\n\\end{cases}\n$$\n且 $u(x) = G(x;x_0)$。在 $x_0$ 的两侧，$u'(x)$ 是常数：当 $x  x_0$ 时，$u'(x) = (1 - x_0)$；当 $x  x_0$ 时，$u'(x) = -x_0$。\n5. 对每个网格，计算有限元解 $u_h$ 相对于 $u$ 的误差：\n   - $H^1$ 半范数误差\n   $$\n   \\|u - u_h\\|_{H^1_0(\\Omega)} := \\left( \\int_0^1 |u'(x) - u_h'(x)|^2\\,dx \\right)^{1/2}.\n   $$\n   - $L^2$ 范数误差\n   $$\n   \\|u - u_h\\|_{L^2(\\Omega)} := \\left( \\int_0^1 |u(x) - u_h(x)|^2\\,dx \\right)^{1/2}.\n   $$\n   $H^1$ 半范数误差积分可以逐单元精确计算，因为 $u'(x)$ 和 $u_h'(x)$ 均为分片常数。对于 $L^2$ 范数，通过分割任何包含 $x_0$ 的单元，并在每个子段上应用两点高斯求积来进行精确的逐单元计算（这对分片线性函数的差是精确的，因为其平方至多是二次的）。\n6. 定义加密策略如下：\n   - 均匀加密：在 $(0,1)$ 上使用 $N \\in \\{32, 64, 128, 256\\}$ 个大小相等的单元。\n   - 围绕 $x_0$ 的局部加密：对于每个 $N \\in \\{32, 64, 128, 256\\}$，选择一个包含 $x_0$ 的子区间 $I = [x_{\\mathrm{L}}, x_{\\mathrm{R}}]$，其中 $x_{\\mathrm{L}} = \\max(0, x_0 - w_{\\mathrm{L}})$，$x_{\\mathrm{R}} = \\min(1, x_0 + w_{\\mathrm{R}})$，且 $w_{\\mathrm{L}} = 0.282$ 和 $w_{\\mathrm{R}} = 0.318$。将总单元数的比例 $p = 0.6$ 均匀分配给 $I$，并将其余单元根据区间长度按比例均匀分布到 $(0, x_{\\mathrm{L}})$ 和 $(x_{\\mathrm{R}}, 1)$。\n7. 对于每种加密策略和每个 $N$，进行组装、求解，并计算 $H^1$ 和 $L^2$ 误差。然后，通过对 $\\log(\\text{error})$ 与 $\\log(N)$ 进行线性回归来计算经验衰减率，报告由下式定义的斜率大小 $\\alpha$\n$$\n\\log(\\text{error}) \\approx C - \\alpha \\log(N),\n$$\n使得 $\\alpha$ 是一个正数，表示相对于总单元数 $N$ 的衰减率。\n8. 使用以下源位置测试套件：\n   - 测试用例 1：$x_0 = 0.37$（一个普通的内部点）。\n   - 测试用例 2：$x_0 = 0.05$（靠近边界 $x=0$）。\n   - 测试用例 3：$x_0 = \\sqrt{2}/4$（一个无理数位置，以避免偶然对齐）。\n9. 最终输出格式：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，按顺序附加四个浮点数\n$$\n[\\alpha_{H^1,\\mathrm{uniform}},\\, \\alpha_{H^1,\\mathrm{local}},\\, \\alpha_{L^2,\\mathrm{uniform}},\\, \\alpha_{L^2,\\mathrm{local}}],\n$$\n然后将三个测试用例的结果连接起来，形成一个包含 $12$ 个浮点数的单一列表：\n$$\n[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5,\\alpha_6,\\alpha_7,\\alpha_8,\\alpha_9,\\alpha_{10},\\alpha_{11},\\alpha_{12}].\n$$\n不涉及物理单位；所有量均为无量纲。未使用角度。\n\n您的程序必须是一个完整、可运行的 Python $3.12$ 脚本，实现上述要求并仅打印指定的单行输出。它不得要求任何用户输入、文件或网络访问，并且只能使用 Python 标准库、NumPy $1.23.5$ 和 SciPy $1.11.4$。", "solution": "用户要求编写一个 Python 程序，使用有限元法 (FEM) 求解带狄拉克 $\\delta$ 源的一维泊松方程。这涉及在均匀和局部加密的网格策略下，比较数值解与精确解析解的收敛性。通过计算 $H^1$ 半范数和 $L^2$ 范数误差的衰减率来量化收敛性。\n\n### 1. 问题陈述的验证\n在尝试求解之前，问题经过了严格的验证过程。\n\n- **步骤 1：提取的已知条件**\n    - **控制方程**：$- \\frac{d^2 u}{dx^2} = f$ 在 $\\Omega = (0,1)$ 上。\n    - **边界条件**：齐次狄利克雷，$u(0)=0$ 和 $u(1)=0$。\n    - **源项**：$f = \\delta_{x_0}$，在 $x_0 \\in (0,1)$ 的单位狄拉克 $\\delta$ 函数。\n    - **弱形式**：求 $u \\in H^1_0(\\Omega)$ 使得 $\\int_0^1 u'(x) v'(x)\\,dx = v(x_0)$ 对所有 $v \\in H^1_0(\\Omega)$ 成立。\n    - **有限元离散化**：一阶拉格朗日 ($P_1$) 单元。\n    - **载荷向量**：$F_i = \\phi_i(x_0)$，其中 $\\{\\phi_i\\}$ 是节点基函数。\n    - **单元刚度矩阵**：对于长度为 $h_e$ 的单元，$k_e = \\frac{1}{h_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n    - **精确解**：$u(x) = G(x;x_0)$，其中 $G(x;x_0) = (1-x_0)x$ 对于 $x \\le x_0$ 且 $G(x;x_0) = x_0(1-x)$ 对于 $x \\ge x_0$。\n    - **精确导数**：$u'(x) = 1-x_0$ 对于 $x  x_0$ 且 $u'(x) = -x_0$ 对于 $x  x_0$。\n    - **误差范数**：$H^1$ 半范数 $\\|u - u_h\\|_{H^1_0(\\Omega)}$ 和 $L^2$ 范数 $\\|u - u_h\\|_{L^2(\\Omega)}$。\n    - **误差积分**：\n        - $H^1$ 误差：逐单元精确积分，分割包含 $x_0$ 的单元。\n        - $L^2$ 误差：在通过在 $x_0$ 处分割单元创建的子段上使用两点高斯求积。\n    - **网格加密**：\n        - 均匀：$N \\in \\{32, 64, 128, 256\\}$ 个相等单元。\n        - 局部：对每个 $N$，一部分 $p=0.6$ 的单元集中在区间 $I = [x_0 - w_{\\mathrm{L}}, x_0 + w_{\\mathrm{R}}]$ (裁剪到 $[0,1]$)，其中 $w_{\\mathrm{L}}=0.282$ 和 $w_{\\mathrm{R}}=0.318$。剩余单元均匀分布在 $I$ 之外。\n    - **速率计算**：$\\log(\\text{error})$ 对 $\\log(N)$ 的线性回归，以求得斜率大小 $\\alpha$。\n    - **测试用例**：$x_0 \\in \\{0.37, 0.05, \\sqrt{2}/4\\}$。\n    - **输出格式**：一个包含 12 个浮点数的列表：$[\\alpha_{H^1,\\mathrm{uniform}}, \\alpha_{H^1,\\mathrm{local}}, \\alpha_{L^2,\\mathrm{uniform}}, \\alpha_{L^2,\\mathrm{local}}]$ 对每个测试用例进行连接。\n\n- **步骤 2：使用提取的已知条件进行验证**\n    - **科学基础**：该问题是偏微分方程数值分析（特别是有限元法）中的一个典型例子。泊松方程、弱形式、$P_1$ 单元的使用以及作为精确解的格林函数都是标准的且基础稳固。\n    - **适定性**：该问题是适定的。算子是椭圆型的，齐次狄利克雷边界条件确保在 $H^1_0(\\Omega)$ 中存在唯一解。计算任务定义明确。\n    - **客观性**：所有参数、程序和定义都以数学精度指定，没有主观解释的余地。\n    - **无缺陷**：该问题未违反任何无效性标准。它是自包含的、科学上正确的且计算上可行的。所有必要信息均已提供。\n\n- **步骤 3：结论与行动**\n    问题是**有效的**。现在将开发一个完整的解决方案。\n\n### 2. 方法与实现\n\n解决方案通过遵循概述的步骤来实现。算法的关键组成部分是：\n\n1.  **网格生成**：创建一个函数 `_generate_mesh`，用于为给定的单元数 $N$、源位置 $x_0$ 和策略（'uniform' 或 'local'）生成节点坐标数组。局部加密策略将 $N$ 个单元仔细地划分到三个子域：围绕 $x_0$ 的一个加密中心区域和两侧的两个较粗糙区域。\n\n2.  **有限元求解器**：`_solve_fem` 函数实现核心的有限元程序。\n    - 它为内部自由度组装全局刚度矩阵 $K$ 和载荷向量 $F$。由于问题的一维性质和使用最近邻 $P_1$ 基函数，刚度矩阵是三对角的。\n    - 载荷向量 $F$ 基于 $F_i = v_i(x_0)$ 原理进行组装。对于 $P_1$ 节点基函数 $\\phi_i$，这简化为 $F_i = \\phi_i(x_0)$。只有其支撑域包含 $x_0$ 的两个基函数会产生非零项。\n    - 使用 `numpy.linalg.solve` 求解得到的线性系统 $K U_{\\text{interior}} = F$，以获得内部节点值 $U_{\\text{interior}}$。\n    - 通过将 $U_{\\text{interior}}$ 与边界处的零值（由狄利克雷条件要求）扩充，构造完整的解向量 $U_h$。\n\n3.  **误差计算**：`_compute_errors` 函数计算数值误差。\n    - 它遍历网格的每个单元。\n    - **$H^1$ 半范数误差** 是通过在每个单元上积分导数之差的平方 $(u' - u_h')^2$ 来计算的。由于 $u'$ 和 $u_h'$ 都是分片常数，这个积分是精确的。如果一个单元包含奇异点 $x_0$，积分在 $x_0$ 处被分成两部分。\n    - **$L^2$ 范数误差** 是通过积分 $(u - u_h)^2$ 来计算的。在每个单元上，$u_h$ 是线性的。精确解 $u$ 是分片线性的。因此，被积函数是分片二次的。按照规定，使用两点高斯求积精确计算积分。如果一个单元包含 $x_0$，它被分成两个子区间，并对每个子区间应用求积。\n\n4.  **收敛率计算**：`_compute_rate` 函数接收为网格序列 $N \\in \\{32, 64, 128, 256\\}$ 计算的误差列表，并计算收敛率 $\\alpha$。这是通过对 log-log 数据进行线性最小二乘拟合来完成的：$\\log(\\text{error})$ 对 $\\log(N)$。速率 $\\alpha$ 是这条线的斜率的负值。\n\n5.  **主执行循环**：主函数遍历为 $x_0$ 指定的测试用例。对于每个 $x_0$，它对整个 $N$ 范围内的均匀和局部加密策略运行模拟，收集误差，计算四个所需的收敛率（$\\alpha_{H^1,\\text{uniform}}$, $\\alpha_{H^1,\\text{local}}$, $\\alpha_{L^2,\\text{uniform}}$, $\\alpha_{L^2,\\text{local}}$），并将它们附加到结果列表中。最后，程序以指定的格式打印连接后的列表。\n\n对于这个问题（带有奇异源），在均匀网格上的预期理论收敛率是 $\\alpha_{H^1} \\approx 0.5$ 和 $\\alpha_{L^2} \\approx 1.5$。通过适当的局部加密，应该能恢复最优收敛率 $\\alpha_{H^1} \\approx 1.0$ 和 $\\alpha_{L^2} \\approx 2.0$（对于光滑问题）。计算出的结果将与这些理论预期进行基准比较。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM simulation and compute convergence rates.\n    \"\"\"\n    \n    # Constants and parameters from the problem statement\n    W_L = 0.282\n    W_R = 0.318\n    P_REFINE = 0.6\n    Ns = np.array([32, 64, 128, 256], dtype=int)\n    TEST_CASES = [\n        0.37,\n        0.05,\n        np.sqrt(2.0)/4.0,\n    ]\n\n    # --- Helper Functions ---\n\n    def u_exact(x, x0):\n        \"\"\"Computes the exact solution u(x) for a given x0.\"\"\"\n        return np.where(x = x0, (1.0 - x0) * x, x0 * (1.0 - x))\n\n    def du_exact(x, x0):\n        \"\"\"Computes the exact derivative u'(x) for a given x0.\"\"\"\n        return np.where(x  x0, 1.0 - x0, -x0)\n\n    def generate_mesh(N, x0, strategy):\n        \"\"\"Generates the mesh nodes for uniform or local refinement.\"\"\"\n        if strategy == 'uniform':\n            return np.linspace(0.0, 1.0, N + 1)\n        \n        elif strategy == 'local':\n            x_L = max(0.0, x0 - W_L)\n            x_R = min(1.0, x0 + W_R)\n\n            N_refine = int(np.round(P_REFINE * N))\n            N_coarse = N - N_refine\n\n            len_left = x_L\n            len_right = 1.0 - x_R\n            total_coarse_len = len_left + len_right\n            \n            if total_coarse_len > 1e-12:\n                N_left = int(np.round(N_coarse * len_left / total_coarse_len))\n            else:\n                N_left = 0\n            N_right = N_coarse - N_left\n            \n            # Ensure total number of elements is exactly N due to rounding\n            current_sum = N_left + N_refine + N_right\n            if current_sum != N:\n                N_right += (N - current_sum)\n\n            nodes_list = []\n            if N_left > 0:\n                nodes_list.append(np.linspace(0.0, x_L, N_left, endpoint=False))\n            if N_refine > 0:\n                nodes_list.append(np.linspace(x_L, x_R, N_refine, endpoint=False))\n            if N_right > 0:\n                nodes_list.append(np.linspace(x_R, 1.0, N_right, endpoint=False))\n            \n            nodes = np.concatenate(nodes_list) if nodes_list else np.array([])\n            nodes = np.append(nodes, 1.0)\n            \n            return nodes\n\n    def solve_fem(nodes, x0):\n        \"\"\"Assembles and solves the FEM system for P1 elements.\"\"\"\n        N_elements = len(nodes) - 1\n        N_nodes = N_elements + 1\n        N_interior = N_nodes - 2\n\n        if N_interior = 0:\n            return np.zeros(N_nodes)\n\n        K = np.zeros((N_interior, N_interior))\n        F = np.zeros(N_interior)\n\n        # Assemble stiffness matrix K (tridiagonal) for interior nodes\n        for i in range(N_interior): # Diagonals based on node i+1\n            glob_idx = i + 1\n            h_left = nodes[glob_idx] - nodes[glob_idx - 1]\n            h_right = nodes[glob_idx + 1] - nodes[glob_idx]\n            K[i, i] = 1.0/h_left + 1.0/h_right\n        for i in range(N_interior - 1): # Off-diagonals\n            glob_idx = i + 1\n            h_right = nodes[glob_idx + 1] - nodes[glob_idx]\n            K[i, i+1] = -1.0/h_right\n            K[i+1, i] = -1.0/h_right\n\n        # Assemble load vector F\n        elem_idx = np.searchsorted(nodes, x0, side='right') - 1\n        elem_idx = min(elem_idx, N_elements - 1)\n        \n        x_j, x_j1 = nodes[elem_idx], nodes[elem_idx+1]\n        h_j = x_j1 - x_j\n        \n        val_phi_j = (x_j1 - x0) / h_j if h_j > 1e-14 else (1.0 if np.isclose(x0, x_j) else 0.0)\n        val_phi_j1 = (x0 - x_j) / h_j if h_j > 1e-14 else (1.0 if np.isclose(x0, x_j1) else 0.0)\n\n        if elem_idx > 0:\n            F[elem_idx - 1] += val_phi_j\n        if elem_idx + 1  N_nodes - 1:\n            F[elem_idx] += val_phi_j1\n\n        U_interior = np.linalg.solve(K, F)\n        U_h = np.zeros(N_nodes)\n        U_h[1:-1] = U_interior\n        return U_h\n\n    def compute_errors(nodes, U_h, x0):\n        \"\"\"Computes H1-seminorm and L2-norm errors.\"\"\"\n        N_elements = len(nodes) - 1\n        h1_err_sq, l2_err_sq = 0.0, 0.0\n\n        gauss_pts = np.array([-1.0/np.sqrt(3.0), 1.0/np.sqrt(3.0)])\n        gauss_w = np.array([1.0, 1.0])\n\n        for i in range(N_elements):\n            x_i, x_i1 = nodes[i], nodes[i+1]\n            h_e = x_i1 - x_i\n            if h_e  1e-14: continue\n\n            # H1 seminorm error\n            du_h = (U_h[i+1] - U_h[i]) / h_e\n            if x0 = x_i or x0 >= x_i1:\n                du_val = du_exact((x_i + x_i1) / 2.0, x0)\n                h1_err_sq += (du_val - du_h)**2 * h_e\n            else:\n                h1_err_sq += (du_exact(x_i, x0) - du_h)**2 * (x0 - x_i)\n                h1_err_sq += (du_exact(x_i1, x0) - du_h)**2 * (x_i1 - x0)\n            \n            # L2 norm error\n            def u_h_local(x): return U_h[i] * (x_i1 - x) / h_e + U_h[i+1] * (x - x_i) / h_e\n            def integrand_sq(x): return (u_exact(x, x0) - u_h_local(x))**2\n\n            def quad_gauss2(func, a, b):\n                h_sub = b - a\n                if h_sub  1e-14: return 0.0\n                pts = 0.5 * h_sub * gauss_pts + 0.5 * (a + b)\n                return 0.5 * h_sub * np.sum(gauss_w * func(pts))\n\n            if x0 = x_i or x0 >= x_i1:\n                l2_err_sq += quad_gauss2(integrand_sq, x_i, x_i1)\n            else:\n                l2_err_sq += quad_gauss2(integrand_sq, x_i, x0)\n                l2_err_sq += quad_gauss2(integrand_sq, x0, x_i1)\n            \n        return np.sqrt(h1_err_sq), np.sqrt(l2_err_sq)\n    \n    def compute_rate(errors):\n        \"\"\"Computes convergence rate alpha from log(error) vs log(N).\"\"\"\n        if any(e  1e-16 for e in errors): return np.nan\n        log_N = np.log(Ns)\n        log_err = np.log(errors)\n        slope, _ = np.polyfit(log_N, log_err, 1)\n        return -slope\n\n    # --- Main Calculation Loop ---\n    all_results = []\n    for x0 in TEST_CASES:\n        \n        errors_h1_uni, errors_l2_uni = [], []\n        errors_h1_loc, errors_l2_loc = [], []\n\n        for N in Ns:\n            # Uniform refinement\n            nodes_uni = generate_mesh(N, x0, 'uniform')\n            U_h_uni = solve_fem(nodes_uni, x0)\n            h1, l2 = compute_errors(nodes_uni, U_h_uni, x0)\n            errors_h1_uni.append(h1)\n            errors_l2_uni.append(l2)\n\n            # Local refinement\n            nodes_loc = generate_mesh(N, x0, 'local')\n            U_h_loc = solve_fem(nodes_loc, x0)\n            h1, l2 = compute_errors(nodes_loc, U_h_loc, x0)\n            errors_h1_loc.append(h1)\n            errors_l2_loc.append(l2)\n            \n        # Compute rates for the current test case\n        alpha_h1_uni = compute_rate(errors_h1_uni)\n        alpha_h1_loc = compute_rate(errors_h1_loc)\n        alpha_l2_uni = compute_rate(errors_l2_uni)\n        alpha_l2_loc = compute_rate(errors_l2_loc)\n        \n        all_results.extend([alpha_h1_uni, alpha_h1_loc, alpha_l2_uni, alpha_l2_loc])\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3595604"}]}