{"hands_on_practices": [{"introduction": "高斯波束方法的一个关键优势在于它能够自然地处理传统射线理论失效的焦散区。这种能力源于其在射线中心坐标系中引入了复值相位，从而避免了振幅的奇异性。本练习旨在通过具体的编程实践，将焦散区的两种处理方式——实射线理论中的马斯洛夫（Maslov）相移校正和高斯波束中的复曲率演化——联系起来。通过动手实现和比较这两种方法，您将深刻理解高斯波束方法是如何在焦散区正则化波场并保持振幅有限的，从而掌握该方法的核心机制之一。[@problem_id:3599623]", "problem": "考虑在计算地球物理学中用于高斯波束法的各向同性介质中二维高频声波传播的傍轴公式。沿着由弧长 $s$（单位：$\\mathrm{m}$）参数化的给定中心射线，小的横向扰动遵循从哈密顿射线理论推导出的线性化（雅可比）方程。在单一横向自由度中，基本解可以用求解一阶线性哈密顿系统的一对 $(Q,P)$ 来表示\n$$\n\\frac{d}{ds}\n\\begin{bmatrix}\nQ \\\\ P\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0  I \\\\\n- K(s)  0\n\\end{bmatrix}\n\\begin{bmatrix}\nQ \\\\ P\n\\end{bmatrix},\n$$\n其中在此设定中 $Q$ 和 $P$ 是标量，$I$ 是单位矩阵（此处等于 $1$），$K(s)$ 是哈密顿流的标量截面曲率，由沿着射线计算的哈密顿量的二阶导数确定。对于恒定聚焦曲率 $K(s) \\equiv k \\ge 0$，该系统简化为 $Q$ 的谐振子型演化：\n$$\n\\frac{d^2 Q}{ds^2} + k Q = 0,\n$$\n其中共轭（焦点）点出现在 $Q(s) = 0$ 的 $s$ 值处。高斯波束复曲率 $M$ 定义为 $M = P Q^{-1}$，并满足黎卡提方程\n$$\n\\frac{dM}{ds} + M^2 + k = 0.\n$$\n在共轭点处，由于 $Q=0$，任何纯实数构造的 $M = P Q^{-1}$ 都有一个极点，而标准高斯波束正则化用一个小的正虚部来初始化 $Q$，即 $Q(0) = i \\varepsilon$，$P(0) = 1$，这确保了 $\\operatorname{Im} M > 0$ 并在共轭点上产生一个连续的 $M(s)$。相反，纯实数初始化 $Q(0) = 0$，$P(0) = 1$ 对 $k \\ge 0$ 产生实数 $Q(s)$，因此 $\\det Q = Q$ 在每个共轭点处改变符号。Maslov 指数 $\\mu$ 统计这种符号变化，每当 $\\det Q$ 随着 $s$ 的增加而改变符号时，$\\mu$ 就增加 $1$。由实数基本解构造的场振幅因子通过 Maslov 相位 $-\\mu \\pi / 2$ 进行修正，以与连续复曲率构造保持一致。\n\n从这些基本定律和定义出发，执行以下操作：\n\n- 对于恒定曲率 $k \\ge 0$，在任意复数初始数据 $Q(0) = Q_0$, $P(0) = P_0$ ($Q_0, P_0 \\in \\mathbb{C}$) 下，推导闭式基本解 $(Q,P)$。然后特化为：\n  1. 实数初始化 $Q_0 = 0$, $P_0 = 1$，产生实数 $Q_{\\mathrm{real}}(s)$ 和 $P_{\\mathrm{real}}(s)$。\n  2. 正则化复数初始化 $Q_0 = i \\varepsilon$, $P_0 = 1$（其中 $\\varepsilon > 0$ 为一个固定的小的实数），产生 $Q_{\\mathrm{cx}}(s)$ 和 $P_{\\mathrm{cx}}(s)$ 以及在共轭点上连续的 $M_{\\mathrm{cx}}(s) = P_{\\mathrm{cx}}(s)/Q_{\\mathrm{cx}}(s)$。\n\n- 定义 Maslov 指数更新规则如下：给定一个递增弧长样本的有序列表 $s_1  s_2  \\cdots  s_N$，初始化 $\\mu = 0$，并在实数量 $Q_{\\mathrm{real}}(s)$ 在连续样本之间每次改变符号时更新 $\\mu \\leftarrow \\mu + 1$。对于 $k=0$，在实数初始化下将 $Q_{\\mathrm{real}}(s)$ 解释为 $s$；对于 $k>0$，使用为 $Q_{\\mathrm{real}}(s)$ 推导出的闭式。\n\n- 定义在每个 $s_j$ 处计算的以下两个振幅因子：\n  - Maslov 修正的实数振幅代理\n    $$\n    G_{\\mathrm{real}}(s_j) = \\frac{1}{\\sqrt{\\lvert Q_{\\mathrm{real}}(s_j) \\rvert}} \\exp\\!\\left(- i \\frac{\\pi}{2} \\mu(s_j)\\right),\n    $$\n    其中 $\\mu(s_j)$ 是累积到（并包括）$s_j$ 的 Maslov 指数。平方根是在正实轴上的主支。\n  - 连续复曲率振幅代理\n    $$\n    G_{\\mathrm{cx}}(s_j) = \\frac{1}{\\sqrt{Q_{\\mathrm{cx}}(s_j)}},\n    $$\n    定义为复数平方根的主支。\n\n- 为消除因初始条件不同而导致的平凡的整体复数缩放，通过 $C = G_{\\mathrm{cx}}(s_1) / G_{\\mathrm{real}}(s_1)$ 在第一个样本 $s_1$ 处校准一个恒定复数因子 $C$，并对 $j=1,\\dots,N$ 比较 $G_{\\mathrm{cx}}(s_j)$ 与 $C \\, G_{\\mathrm{real}}(s_j)$。通过相对上确界范数量化差异。\n  $$\n  \\mathcal{E} = \\frac{\\max_{1 \\le j \\le N} \\left\\lvert G_{\\mathrm{cx}}(s_j) - C \\, G_{\\mathrm{real}}(s_j) \\right\\rvert}{\\max_{1 \\le j \\le N} \\left\\lvert G_{\\mathrm{cx}}(s_j) \\right\\rvert}.\n  $$\n\n- 三角函数的角度必须以弧度为单位解释，弧长 $s$ 必须以米为单位解释。曲率参数 $k$ 必须以 $\\mathrm{m}^{-2}$ 为单位解释。下面要求的输出是无量纲的。\n\n实现一个程序，对下面的每个测试用例，计算：\n1. 处理完完整的 $s$ 值有序列表后的最终 Maslov 指数 $\\mu$。\n2. 上面定义的相对差异 $\\mathcal{E}$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个双元素列表 $[\\mu,\\mathcal{E}]$。\n\n测试套件：\n- 案例 A（正常路径，对于 $k>0$ 有一次共轭穿越）：$k = 1.0 \\,\\mathrm{m}^{-2}$，$\\varepsilon = 0.05$，以及 $s$ 列表 $[0.2\\pi,\\, 0.8\\pi,\\, 1.2\\pi,\\, 1.8\\pi] \\,\\mathrm{m}$。\n- 案例 B（边缘情况，非常接近一个共轭点）：$k = 1.0 \\,\\mathrm{m}^{-2}$，$\\varepsilon = 0.02$，以及 $s$ 列表 $[0.95\\pi,\\, 1.05\\pi] \\,\\mathrm{m}$。\n- 案例 C（不同曲率，共轭点位置偏移）：$k = 0.25 \\,\\mathrm{m}^{-2}$，$\\varepsilon = 0.03$，以及 $s$ 列表 $[1.5\\pi,\\, 2.5\\pi,\\, 3.5\\pi] \\,\\mathrm{m}$。\n- 案例 D（边界情况，零曲率，在正 $s$ 处无共轭穿越）：$k = 0.0 \\,\\mathrm{m}^{-2}$，$\\varepsilon = 0.05$，以及 $s$ 列表 $[0.5,\\, 1.0,\\, 2.0] \\,\\mathrm{m}$。\n\n所有三角函数参数必须以弧度为单位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[[\\mu_A,\\mathcal{E}_A],[\\mu_B,\\mathcal{E}_B],[\\mu_C,\\mathcal{E}_C],[\\mu_D,\\mathcal{E}_D]]$，并用数值代替符号。", "solution": "用户提供的问题被评估为有效。它在科学上基于哈密顿射线理论和高斯波束法的原理，是数学上适定、客观且自洽的。求解过程将如下进行。\n\n### 1. 基本解 $(Q,P)$ 的推导\n\n问题始于基本解矩阵分量 $(Q,P)$ 的一阶线性哈密顿系统：\n$$\n\\frac{d}{ds}\n\\begin{bmatrix}\nQ \\\\ P\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0  1 \\\\\n-k  0\n\\end{bmatrix}\n\\begin{bmatrix}\nQ \\\\ P\n\\end{bmatrix}\n$$\n其中 $k \\ge 0$ 是一个恒定曲率。该系统等价于关于 $Q(s)$ 的二阶线性常微分方程 (ODE)：\n$$\n\\frac{d^2 Q}{ds^2} + k Q = 0\n$$\n其中 $P(s) = \\frac{dQ}{ds}$。我们针对任意复数初始条件 $Q(0) = Q_0$ 和 $P(0) = P_0$ 求解此 ODE。\n\n#### 情况 1: $k > 0$ (聚焦介质)\n令 $\\omega = \\sqrt{k}$。ODE 变为 $Q'' + \\omega^2 Q = 0$，这是一个简谐振子方程。其通解为：\n$$\nQ(s) = A \\cos(\\omega s) + B \\sin(\\omega s)\n$$\n其中 $A$ 和 $B$ 是常数。$P(s)$ 对应的解是 $Q(s)$ 的导数：\n$$\nP(s) = \\frac{dQ}{ds} = -A\\omega \\sin(\\omega s) + B\\omega \\cos(\\omega s)\n$$\n应用 $s=0$ 处的初始条件：\n$$\nQ(0) = A \\cos(0) + B \\sin(0) = A = Q_0\n$$\n$$\nP(0) = -A\\omega \\sin(0) + B\\omega \\cos(0) = B\\omega = P_0 \\implies B = \\frac{P_0}{\\omega}\n$$\n代入 $A=Q_0$，$B=P_0/\\omega$ 和 $\\omega=\\sqrt{k}$，对于 $k>0$ 的通解是：\n$$\nQ(s) = Q_0 \\cos(\\sqrt{k} s) + \\frac{P_0}{\\sqrt{k}} \\sin(\\sqrt{k} s)\n$$\n$$\nP(s) = -Q_0 \\sqrt{k} \\sin(\\sqrt{k} s) + P_0 \\cos(\\sqrt{k} s)\n$$\n\n#### 情况 2: $k = 0$ (均匀介质)\nODE 简化为 $Q'' = 0$。积分两次得到通解：\n$$\nQ(s) = A s + B\n$$\n对应的 $P(s)$ 是：\n$$\nP(s) = \\frac{dQ}{ds} = A\n$$\n应用 $s=0$ 处的初始条件：\n$$\nQ(0) = B = Q_0\n$$\n$$\nP(0) = A = P_0\n$$\n对于 $k=0$ 的通解是：\n$$\nQ(s) = P_0 s + Q_0\n$$\n$$\nP(s) = P_0\n$$\n\n### 2. 特化为实数和复数初始化\n\n我们现在将通解特化为问题中指定的两种初始化。\n\n#### 实数初始化: $Q_0 = 0$, $P_0 = 1$\n这种初始化对应于一个点源。\n- 对于 $k>0$：\n  $$\n  Q_{\\mathrm{real}}(s) = \\frac{1}{\\sqrt{k}} \\sin(\\sqrt{k} s)\n  $$\n  $$\n  P_{\\mathrm{real}}(s) = \\cos(\\sqrt{k} s)\n  $$\n  共轭点，即 $Q_{\\mathrm{real}}(s)=0$ 的点，出现在 $\\sqrt{k} s = n\\pi$ 处，其中 $n \\ge 1$ 为整数。\n- 对于 $k=0$：\n  $$\n  Q_{\\mathrm{real}}(s) = s\n  $$\n  $$\n  P_{\\mathrm{real}}(s) = 1\n  $$\n  对于 $s > 0$ 不存在共轭点。\n\n#### 复数初始化: $Q_0 = i\\varepsilon$, $P_0 = 1$ ($\\varepsilon > 0$)\n这对应于一个正则化的高斯波束源。\n- 对于 $k>0$：\n  $$\n  Q_{\\mathrm{cx}}(s) = i\\varepsilon \\cos(\\sqrt{k} s) + \\frac{1}{\\sqrt{k}} \\sin(\\sqrt{k} s)\n  $$\n  $$\n  P_{\\mathrm{cx}}(s) = -i\\varepsilon \\sqrt{k} \\sin(\\sqrt{k} s) + \\cos(\\sqrt{k} s)\n  $$\n  $Q_0$ 的虚部确保了对于实数 $s$，$Q_{\\mathrm{cx}}(s)$ 永不为零，从而避免了复曲率 $M=P/Q$ 中的奇点。\n- 对于 $k=0$：\n  $$\n  Q_{\\mathrm{cx}}(s) = s + i\\varepsilon\n  $$\n  $$\n  P_{\\mathrm{cx}}(s) = 1\n  $$\n\n### 3. 算法实现\n\n任务是为几个测试用例计算最终的 Maslov 指数 $\\mu$ 和差异 $\\mathcal{E}$。对于每个用例 $(k, \\varepsilon, \\{s_j\\}_{j=1}^N)$，算法按以下步骤进行。\n\n1.  **计算 $Q$ 值**：对于给定的弧长数组 $s_j$，使用上面推导的特化公式计算对应的 $Q_{\\mathrm{real}}(s_j)$ 和 $Q_{\\mathrm{cx}}(s_j)$ 数组。\n\n2.  **计算 Maslov 指数历史**：Maslov 指数 $\\mu(s_j)$ 统计了序列中直到 $s_j$ 时 $Q_{\\mathrm{real}}(s)$ 的符号变化次数。我们通过初始化一个计数器 $\\mu_{\\mathrm{current}} = 0$ 和一个数组 $\\mu_{\\mathrm{values}}$ 来存储 $\\mu(s_j)$ 以实现此功能。我们从 $j=2$ 迭代到 $N$。对于每个 $j$，$\\mu(s_j)$ 继承自 $\\mu(s_{j-1})$，如果 $Q_{\\mathrm{real}}(s_{j-1}) \\cdot Q_{\\mathrm{real}}(s_j)  0$，则增加 $1$。最终的 Maslov 指数是 $s_N$ 处的值。\n\n3.  **计算振幅因子**：\n    -   实数振幅代理 $G_{\\mathrm{real}}(s_j)$ 是使用先前计算的 $Q_{\\mathrm{real}}(s_j)$ 和 $\\mu(s_j)$ 为每个样本 $s_j$ 计算的：\n        $$\n        G_{\\mathrm{real}}(s_j) = \\frac{1}{\\sqrt{\\lvert Q_{\\mathrm{real}}(s_j) \\rvert}} \\exp\\!\\left(-i \\frac{\\pi}{2} \\mu(s_j)\\right)\n        $$\n    -   复数振幅代理 $G_{\\mathrm{cx}}(s_j)$ 是使用 $Q_{\\mathrm{cx}}(s_j)$ 计算的。平方根是主支，这是标准数值库中复数参数的默认值。\n        $$\n        G_{\\mathrm{cx}}(s_j) = \\frac{1}{\\sqrt{Q_{\\mathrm{cx}}(s_j)}}\n        $$\n\n4.  **计算差异 $\\mathcal{E}$**：\n    -   首先，在第一个样本 $s_1$ 处计算复数校准常数 $C$：\n        $$\n        C = \\frac{G_{\\mathrm{cx}}(s_1)}{G_{\\mathrm{real}}(s_1)}\n        $$\n    -   然后，使用所有样本 $j=1, \\dots, N$ 上的上确界范数计算相对差异：\n        $$\n        \\mathcal{E} = \\frac{\\max_{j} \\left\\lvert G_{\\mathrm{cx}}(s_j) - C \\, G_{\\mathrm{real}}(s_j) \\right\\rvert}{\\max_{j} \\left\\lvert G_{\\mathrm{cx}}(s_j) \\right\\rvert}\n        $$\n        这涉及对代表 $G_{\\mathrm{cx}}$ 和 $G_{\\mathrm{real}}$ 的数组进行逐元素计算，然后找到模的最大值。\n\n将此过程应用于每个测试用例，以生成所需的输出对 $[\\mu, \\mathcal{E}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Gaussian beam problem for the specified test cases.\n\n    This function implements the calculation of the Maslov index and the\n    discrepancy between two formulations of the geometric amplitude factor\n    in Gaussian beam theory.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        (1.0, 0.05, [0.2 * np.pi, 0.8 * np.pi, 1.2 * np.pi, 1.8 * np.pi]),\n        # Case B\n        (1.0, 0.02, [0.95 * np.pi, 1.05 * np.pi]),\n        # Case C\n        (0.25, 0.03, [1.5 * np.pi, 2.5 * np.pi, 3.5 * np.pi]),\n        # Case D\n        (0.0, 0.05, [0.5, 1.0, 2.0]),\n    ]\n\n    results = []\n    \n    for k, eps, s_list in test_cases:\n        s_arr = np.array(s_list, dtype=float)\n        \n        # 1. Compute Q_real and Q_cx\n        if k > 0:\n            omega = np.sqrt(k)\n            q_real = (1 / omega) * np.sin(omega * s_arr)\n            q_cx = (1 / omega) * np.sin(omega * s_arr) + 1j * eps * np.cos(omega * s_arr)\n        else:  # k == 0\n            q_real = s_arr\n            q_cx = s_arr + 1j * eps\n        \n        # 2. Compute Maslov index history mu(s_j)\n        mu_values = []\n        current_mu = 0\n        if len(s_arr) > 0:\n            # The condition for changing sign does not apply at the first point.\n            # So the first point is handled outside the loop.\n            mu_values.append(current_mu)\n            for j in range(1, len(s_arr)):\n                # Check for sign change between consecutive samples\n                if q_real[j - 1] * q_real[j]  0:\n                    current_mu += 1\n                mu_values.append(current_mu)\n        \n        mu_values = np.array(mu_values, dtype=int)\n        final_mu = current_mu\n\n        # 3. Compute Amplitude Factors G_real and G_cx\n        # G_real requires handling of absolute value and the Maslov phase\n        # The square root is applied to a non-negative real number.\n        g_real_mag = 1 / np.sqrt(np.abs(q_real))\n        g_real_phase = np.exp(-1j * np.pi / 2.0 * mu_values)\n        g_real = g_real_mag * g_real_phase\n        \n        # G_cx uses the principal branch of the complex square root,\n        # which is the default in numpy.\n        g_cx = 1 / np.sqrt(q_cx)\n\n        # 4. Compute Discrepancy E\n        # Calibration constant C\n        C = g_cx[0] / g_real[0]\n        \n        # Supremum norm of the difference, scaled by C\n        diff_vector = g_cx - C * g_real\n        numerator = np.max(np.abs(diff_vector))\n        \n        # Supremum norm of the reference solution G_cx\n        denominator = np.max(np.abs(g_cx))\n        \n        # Relative discrepancy E\n        E = numerator / denominator if denominator != 0 else 0.0\n        \n        results.append([final_mu, E])\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) correctly serializes the inner lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3599623"}, {"introduction": "除了理论上的完备性，高斯波束方法的实际应用还要求在计算效率和精度之间做出权衡。本练习将引导您进入波场模拟的实际设计环节，学习如何根据给定的目标区域、传播距离和频率，估算所需的最小波束数量和出射角采样率。通过实现这些基于物理原理的设计准则，您将掌握在满足特定误差容限的前提下，有效规划数值模拟、控制计算成本的关键技能，这是计算地球物理学家必备的实践能力。[@problem_id:3599671]", "problem": "给定一个均匀的二维声学介质和一个高频环境，在此环境下使用高斯波束方法来合成波场。对于每个测试用例，您必须确定横向目标孔径上所需的高斯波束整数数量，以及为覆盖该孔径同时保持指定误差容限所需的离散出射角的整数数量。您的程序必须实现一个基于标量波动方程和傍轴近似的原则性设计，并且必须计算出满足下述覆盖和采样约束的最小数量。\n\n从标量波动方程及其在波速为常数 $c$ 的均匀介质中的时谐亥姆霍兹方程开始：\n$$ \\nabla^2 u + k^2 u = 0, \\quad k = \\frac{\\omega}{c}, $$\n其中 $u$ 是复值压力场，$k$ 是波数，$\\omega$ 是角频率，$c$ 是波速。在高斯波束构造中，在传播距离 $z$ 上采用傍轴近似，一个源平面束腰为 $w_0$ 的波束会演变为一个横向强度包络，其特征是有效宽度 $w(z)$，其中\n$$ w(z) = \\sqrt{w_0^2 + \\left(\\frac{2 z}{k w_0}\\right)^2}。$$\n平衡波束设计选择瑞利范围 $z_R = \\frac{k w_0^2}{2}$ 等于传播距离 $z$，这得出\n$$ w_0 = \\sqrt{\\frac{2 z}{k}}, \\qquad w(z) = \\sqrt{w_0^2 + \\left(\\frac{2 z}{k w_0}\\right)^2} = \\sqrt{\\frac{4 z}{k}}。$$\n假设所有测试用例都采用此平衡波束设计。\n\n物理空间中的覆盖要求：设在观测距离 $z$ 处的横向目标孔径直径为 $D$（单位为米）。考虑在 $z$ 处相邻波束中心的间距为 $\\Delta x$。高斯波束在横向偏移 $x$ 处的轴上振幅包络表现为 $\\exp\\!\\left(-x^2 / w(z)^2\\right)$。要求在相邻波束之间的中点处的最大相对包络下降为 $\\varepsilon$，这意味着\n$$ 1 - \\exp\\!\\left(-\\frac{(\\Delta x/2)^2}{w(z)^2}\\right) \\le \\varepsilon, \\quad \\text{所以} \\quad \\Delta x \\le 2\\, w(z)\\, \\sqrt{-\\ln(1-\\varepsilon)}。$$\n设 $\\Delta x_{\\max}$ 表示右侧的表达式。用 $N_{\\mathrm{beams}}$ 个等间距的波束中心跨越直径 $D$，则间距为 $D/(N_{\\mathrm{beams}}-1)$。强制 $D/(N_{\\mathrm{beams}}-1) \\le \\Delta x_{\\max}$ 并选择满足此不等式的最小整数 $N_{\\mathrm{beams}} \\ge 2$。\n\n角度采样要求：设 $\\theta$ 表示源处的出射角（以弧度为单位），在目标距离 $z$ 处有小角度关系 $x \\approx z \\theta$。两个约束条件决定了最大允许的角度步长 $\\Delta \\theta$：\n- 几何覆盖：横向间距约束意味着 $z\\, \\Delta \\theta \\le \\Delta x_{\\max}$，因此 $\\Delta \\theta \\le \\Delta \\theta_1 := \\Delta x_{\\max}/z$。\n- 振荡相位采样：平面波相位项 $k\\, x \\sin\\theta$ 的最大角频率分量受 $k\\, x_{\\max}$ 限制，其中 $x_{\\max} = D/2$，这给出了一个奈奎斯特界限 $\\Delta \\theta \\le \\Delta \\theta_2 := \\pi / (k x_{\\max})$。\n使用更严格的界限 $\\Delta \\theta_{\\max} = \\min(\\Delta \\theta_1, \\Delta \\theta_2)$。为了跨越到达距离 $z$ 处横向边缘所需的完整角孔径，设\n$$ \\theta_{\\max} = \\arctan\\!\\left(\\frac{D/2}{z}\\right)。$$\n对于覆盖 $[-\\theta_{\\max}, \\theta_{\\max}]$ 且步长最多为 $\\Delta \\theta_{\\max}$ 的对称网格，选择最小整数\n$$ N_{\\mathrm{angles}} \\ge 2 \\quad \\text{使得} \\quad \\frac{2 \\theta_{\\max}}{N_{\\mathrm{angles}} - 1} \\le \\Delta \\theta_{\\max}。$$\n\n您的任务：对于下面的每个测试用例，使用上述原则性构造计算并返回整数对 $[N_{\\mathrm{beams}}, N_{\\mathrm{angles}}]$。所有角度必须以弧度为单位。所有长度必须以米为单位，时间以秒为单位，角频率以弧度/秒为单位。误差容限 $\\varepsilon$ 是无量纲的，并且必须满足 $0  \\varepsilon  1$。\n\n测试套件：\n- 情况 1：$D = 2000\\,\\text{米}$，$z = 3000\\,\\text{米}$，$c = 3000\\,\\text{米/秒}$，$\\omega = 2\\pi \\cdot 10\\,\\text{弧度/秒}$，$\\varepsilon = 0.05$。\n- 情况 2：$D = 500\\,\\text{米}$，$z = 2000\\,\\text{米}$，$c = 2000\\,\\text{米/秒}$，$\\omega = 2\\pi \\cdot 40\\,\\text{弧度/秒}$，$\\varepsilon = 0.01$。\n- 情况 3：$D = 10000\\,\\text{米}$，$z = 5000\\,\\text{米}$，$c = 4000\\,\\text{米/秒}$，$\\omega = 2\\pi \\cdot 2\\,\\text{弧度/秒}$，$\\varepsilon = 0.10$。\n- 情况 4：$D = 10000\\,\\text{米}$，$z = 4000\\,\\text{米}$，$c = 1500\\,\\text{米/秒}$，$\\omega = 2\\pi \\cdot 100\\,\\text{弧度/秒}$，$\\varepsilon = 0.20$。\n- 情况 5：$D = 3000\\,\\text{米}$，$z = 2500\\,\\text{米}$，$c = 3500\\,\\text{米/秒}$，$\\omega = 2\\pi \\cdot 20\\,\\text{弧度/秒}$，$\\varepsilon = 0.001$。\n\n最终输出格式：您的程序应生成单行输出，包含一个逗号分隔的对的列表，用方括号括起来，不含空格。例如，输出必须看起来像\n$$ \\texttt{[[N\\_b^{(1)},N\\_a^{(1)}],[N\\_b^{(2)},N\\_a^{(2)}],\\dots,[N\\_b^{(5)},N\\_a^{(5)}]]} $$\n其中 $N\\_b^{(i)}$ 和 $N\\_a^{(i)}$ 分别表示测试用例 $i$ 的波束数量和角度数量。", "solution": "我们从标量波动方程开始，对于时谐场 $u(\\mathbf{x}) e^{-i \\omega t}$，该方程简化为亥姆霍兹方程 $\\nabla^2 u + k^2 u = 0$，其中 $k = \\omega / c$。在均匀介质中，高斯波束方法将场近似为在中心射线附近满足傍轴形式亥姆霍兹方程的局部化波束解的叠加。对于从源平面发射的具有横向束腰 $w_0$ 的给定高斯波束，在距离 $z$ 处的横向包络的傍轴解具有宽度\n$$ w(z) = \\sqrt{w_0^2 + \\left(\\frac{2 z}{k w_0}\\right)^2}, $$\n这是傍轴波动方程高斯模式的标准结果。瑞利范围是 $z_R = k w_0^2 / 2$。选择 $z_R = z$ 可以在传播距离上平衡波束的发散和聚焦，并最小化对 $w_0$ 选择的敏感性。求解 $z = k w_0^2 / 2$ 得到\n$$ w_0 = \\sqrt{\\frac{2 z}{k}}。$$\n代入宽度演化公式，\n$$ w(z) = \\sqrt{w_0^2 + \\left(\\frac{2 z}{k w_0}\\right)^2} = \\sqrt{\\frac{2 z}{k} + \\frac{2 z}{k}} = \\sqrt{\\frac{4 z}{k}}。$$\n\n为确保在距离 $z$ 处覆盖直径为 $D$ 的横向孔径，我们必须限制在 $z$ 处相邻波束中心之间的间距 $\\Delta x$，使得高斯包络在中点 $x = \\Delta x/2$ 处的下降不超过其轴上值的相对量 $\\varepsilon$。包络因子是 $\\exp(-x^2/w(z)^2)$，因此我们要求\n$$ 1 - \\exp\\!\\left(-\\frac{(\\Delta x/2)^2}{w(z)^2}\\right) \\le \\varepsilon。$$\n求解 $\\Delta x$ 得出\n$$ \\exp\\!\\left(-\\frac{(\\Delta x/2)^2}{w(z)^2}\\right) \\ge 1 - \\varepsilon \\quad \\Rightarrow \\quad \\frac{(\\Delta x/2)^2}{w(z)^2} \\le -\\ln(1 - \\varepsilon), $$\n因此\n$$ \\Delta x_{\\max} = 2\\, w(z)\\, \\sqrt{-\\ln(1-\\varepsilon)}。$$\n用 $N_{\\mathrm{beams}}$ 个等间距的波束中心跨越 $D$，间距为 $D/(N_{\\mathrm{beams}} - 1)$。强制 $D/(N_{\\mathrm{beams}} - 1) \\le \\Delta x_{\\max}$ 和 $N_{\\mathrm{beams}} \\ge 2$ 给出最小整数\n$$ N_{\\mathrm{beams}} = \\max\\!\\left(2,\\, \\left\\lceil 1 + \\frac{D}{\\Delta x_{\\max}} \\right\\rceil \\right)。$$\n\n接下来我们确定角度采样。为了在距离 $z$ 处达到横向极值 $\\pm D/2$，所需的角度范围是\n$$ \\theta_{\\max} = \\arctan\\!\\left(\\frac{D/2}{z}\\right)。$$\n对角度步长 $\\Delta \\theta$ 有两个约束：\n\n1. 几何覆盖：小角度关系 $x \\approx z \\theta$ 意味着角度增量 $\\Delta \\theta$ 在距离 $z$ 处引起横向位移 $z \\Delta \\theta$。为了维持用于波束间距的相同中点包络标准，我们施加 $z \\Delta \\theta \\le \\Delta x_{\\max}$，所以\n$$ \\Delta \\theta \\le \\Delta \\theta_1 := \\frac{\\Delta x_{\\max}}{z}。$$\n\n2. 振荡相位采样：场的平面波分量贡献一个因子 $\\exp\\!\\big(i k (x \\sin\\theta + z \\cos\\theta)\\big)$。对于固定的 $(x,z)$，相位的角度变化主要由大 $x$ 的 $k x \\sin\\theta$ 主导。感兴趣的最大横向坐标是 $x_{\\max} = D/2$。相位对角度的导数是 $\\frac{d}{d\\theta}(k x \\sin\\theta) = k x \\cos\\theta$，其大小最多为 $k x_{\\max}$。为防止角度混叠，采样步长的类奈奎斯特界限是\n$$ \\Delta \\theta \\le \\Delta \\theta_2 := \\frac{\\pi}{k x_{\\max}} = \\frac{\\pi}{k (D/2)}。$$\n\n采用最严格的步长，\n$$ \\Delta \\theta_{\\max} = \\min\\!\\left(\\Delta \\theta_1, \\Delta \\theta_2\\right), $$\n覆盖 $[-\\theta_{\\max}, \\theta_{\\max}]$ 所需的最小角度样本数是\n$$ N_{\\mathrm{angles}} = \\max\\!\\left(2,\\, \\left\\lceil 1 + \\frac{2 \\theta_{\\max}}{\\Delta \\theta_{\\max}} \\right\\rceil \\right)。$$\n\n算法：\n- 对于每个测试用例，分别读取 $(D, z, c, \\omega, \\varepsilon)$，单位分别为米、米、米/秒、弧度/秒和无量纲。\n- 计算 $k = \\omega / c$。\n- 通过平衡波束选择 $z_R = z$ 计算 $w(z) = \\sqrt{4 z / k}$。\n- 计算 $\\Delta x_{\\max} = 2\\, w(z)\\, \\sqrt{-\\ln(1-\\varepsilon)}$。\n- 计算 $N_{\\mathrm{beams}} = \\max\\!\\left(2,\\, \\left\\lceil 1 + D/\\Delta x_{\\max} \\right\\rceil \\right)$。\n- 计算 $\\theta_{\\max} = \\arctan\\!\\left(\\frac{D/2}{z}\\right)$，$\\Delta \\theta_1 = \\Delta x_{\\max}/z$，$\\Delta \\theta_2 = \\pi/(k (D/2))$。\n- 计算 $\\Delta \\theta_{\\max} = \\min(\\Delta \\theta_1, \\Delta \\theta_2)$，然后计算 $N_{\\mathrm{angles}} = \\max\\!\\left(2,\\, \\left\\lceil 1 + 2 \\theta_{\\max} / \\Delta \\theta_{\\max} \\right\\rceil \\right)$。\n- 对于每个测试用例，输出对 $[N_{\\mathrm{beams}}, N_{\\mathrm{angles}}]$，并按规定汇总成一个单一列表。\n\n单位和角度约定：\n- 所有长度 $D$ 和 $z$ 必须以米为单位。\n- 波速 $c$ 必须以米/秒为单位。\n- 角频率 $\\omega$ 必须以弧度/秒为单位。\n- 角度 $\\theta$ 和 $\\Delta \\theta$ 必须以弧度为单位。\n- 容限 $\\varepsilon$ 必须满足 $0  \\varepsilon  1$。\n\n程序为五个测试用例实现上述步骤，并按要求的确切格式打印单行：\n$$ \\texttt{[[N\\_b^{(1)},N\\_a^{(1)}],[N\\_b^{(2)},N\\_a^{(2)}],[N\\_b^{(3)},N\\_a^{(3)}],[N\\_b^{(4)},N\\_a^{(4)}],[N\\_b^{(5)},N\\_a^{(5)}]]}。$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_counts(D, z, c, omega, eps):\n    # Validate tolerance bounds\n    if not (0.0  eps  1.0):\n        raise ValueError(\"eps must satisfy 0  eps  1\")\n    # Wavenumber\n    k = omega / c  # [1/m]\n    # Balanced Gaussian beam width at range z: w(z) = sqrt(4 z / k)\n    w_z = np.sqrt(4.0 * z / k)\n    # Max allowable lateral spacing from envelope criterion\n    delta_x_max = 2.0 * w_z * np.sqrt(-np.log1p(-eps))  # use log1p for stability\n    # Number of beams across diameter D\n    N_beams = int(np.ceil(1.0 + D / max(delta_x_max, 1e-18)))  # avoid division by zero\n    N_beams = max(N_beams, 2)\n    # Angular span to reach +/- D/2 at range z\n    theta_max = np.arctan((0.5 * D) / z)\n    # Angular steps from geometric coverage and phase Nyquist\n    delta_theta_1 = delta_x_max / z\n    x_max = 0.5 * D\n    delta_theta_2 = np.pi / (k * x_max)\n    delta_theta_max = min(delta_theta_1, delta_theta_2)\n    # Number of angles across [-theta_max, theta_max]\n    N_angles = int(np.ceil(1.0 + (2.0 * theta_max) / max(delta_theta_max, 1e-18)))\n    N_angles = max(N_angles, 2)\n    return N_beams, N_angles\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (D [m], z [m], c [m/s], omega [rad/s], eps [-])\n    test_cases = [\n        (2000.0, 3000.0, 3000.0, 2.0*np.pi*10.0, 0.05),\n        (500.0, 2000.0, 2000.0, 2.0*np.pi*40.0, 0.01),\n        (10000.0, 5000.0, 4000.0, 2.0*np.pi*2.0, 0.10),\n        (10000.0, 4000.0, 1500.0, 2.0*np.pi*100.0, 0.20),\n        (3000.0, 2500.0, 3500.0, 2.0*np.pi*20.0, 0.001),\n    ]\n\n    results = []\n    for case in test_cases:\n        D, z, c, omega, eps = case\n        N_beams, N_angles = compute_counts(D, z, c, omega, eps)\n        results.append((N_beams, N_angles))\n\n    # Build the exact output format without spaces: [[Nb1,Na1],[Nb2,Na2],...]\n    pairs = [f\"[{nb},{na}]\" for (nb, na) in results]\n    print(f\"[{','.join(pairs)}]\")\n\nsolve()\n```", "id": "3599671"}, {"introduction": "一个稳健的高斯波束算法必须在数值上保持稳定，尤其是在波束穿过由复杂介质引起的强聚焦区域（即焦散区）时。本练习聚焦于高斯波束传播中的一个高级数值技术，通过对比两种不同的曲率矩阵演化方案——直接积分非线性的里卡蒂（Riccati）方程与积分等价的线性哈密顿（Hamiltonian）系统——来分析和解决数值不稳定性问题。您将实现一个混合算法，该算法在曲率矩阵变得病态时自动切换到更稳定的演化方程，从而学习到一种构建精确且可靠的高斯波束建模程序的实用策略。[@problem_id:3599627]", "problem": "考虑高频声波在各向同性非均匀介质中的传播。在高频（短波长）渐近机制下，高斯波束是标量波动方程的一个局域化渐近解，其相位由程函方程给出，其振幅和宽度由一个复曲率矩阵控制。沿着一条由弧长 $s$ 参数化的参考射线，限制在波束坐标系内的相位横向 Hessian 矩阵根据高斯波束曲率矩阵 $\\mathbf{M}(s)$ 演化。推导的基本依据包括以下来自几何光学和哈密顿射线理论的经过充分检验的事实和定义：\n\n- 程函方程通过哈密顿流确定相位和射线。哈密顿流在横向方向上的线性化给出了波束的傍轴（二阶）动力学。\n- 复对称曲率矩阵 $\\mathbf{M}(s)$ 控制高斯波束的宽度；其虚部 $\\operatorname{Im}\\,\\mathbf{M}(s)$ 的正定性确保了振幅的平方可积性并防止解的爆破。\n- 曲率矩阵遵循一个矩阵 Riccati 常微分方程 (ODE)。等价地，引入典则变量 $(\\mathbf{Q}(s),\\mathbf{P}(s))$，可以得到一个关于 $(\\mathbf{Q},\\mathbf{P})$ 的线性哈密顿系统，使得 $\\mathbf{M}(s)=\\mathbf{P}(s)\\mathbf{Q}(s)^{-1}$，而 Riccati 方程可从此商形式导出。\n\n在一个具有两个横向维度的典则傍轴模型中，假设线性化系数为常数，并由分块矩阵 $\\mathbf{A}(s)=\\mathbf{0}$、$\\mathbf{D}(s)=\\mathbf{0}$、$\\mathbf{B}(s)=\\mathbf{I}$ 和 $\\mathbf{C}(s)=-\\operatorname{diag}(k_1^2,k_2^2)$ 给出，其中 $k_10$ 且 $k_20$。在这种情况下，\n\n- $(\\mathbf{Q},\\mathbf{P})$ 的演化方程为\n$$\n\\frac{d\\mathbf{Q}}{ds}=\\mathbf{P},\\qquad \\frac{d\\mathbf{P}}{ds}=\\mathbf{C}\\,\\mathbf{Q}.\n$$\n- 曲率 Riccati 方程为\n$$\n\\frac{d\\mathbf{M}}{ds}=\\mathbf{C}-\\mathbf{M}^2,\n$$\n其中 $\\mathbf{M}(s)$ 是复对称矩阵，且 $\\operatorname{Im}\\,\\mathbf{M}(s)$ 是正定矩阵。\n\n你的任务是分析 Riccati 演化在焦散面附近的数值稳定性，在焦散面附近 $(\\mathbf{Q},\\mathbf{P})$ 系统可能产生很小的 $\\mathbf{Q}$，并且曲率矩阵可能变得病态。你需要实现一个混合传播算法，该算法以 Riccati ODE 开始，当虚部 $\\operatorname{Im}\\,\\mathbf{M}$ 变得病态时，切换到 $(\\mathbf{Q},\\mathbf{P})$ 演化来计算 $\\mathbf{M}(s)=\\mathbf{P}(s)\\mathbf{Q}(s)^{-1}$。\n\n算法要求：\n\n1. 使用四阶龙格-库塔方法 (Runge–Kutta 4 (RK4)) 在复数运算下对 Riccati ODE 和线性 $(\\mathbf{Q},\\mathbf{P})$ 系统进行积分。\n2. 使用 $\\mathbf{M}(0)=i\\,\\operatorname{diag}(\\alpha_1,\\alpha_2)$、$\\mathbf{Q}(0)=\\mathbf{I}$ 和 $\\mathbf{P}(0)=\\mathbf{M}(0)\\mathbf{Q}(0)$ 进行初始化。\n3. 将任意 $s$ 处虚部的条件数定义为\n$$\n\\kappa\\big(\\operatorname{Im}\\,\\mathbf{M}(s)\\big)=\\frac{\\lambda_{\\max}\\big(\\tfrac{1}{2}(\\operatorname{Im}\\,\\mathbf{M}+\\operatorname{Im}\\,\\mathbf{M}^{\\mathsf{T}})\\big)}{\\lambda_{\\min}\\big(\\tfrac{1}{2}(\\operatorname{Im}\\,\\mathbf{M}+\\operatorname{Im}\\,\\mathbf{M}^{\\mathsf{T}})\\big)},\n$$\n其中 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 分别表示 $\\operatorname{Im}\\,\\mathbf{M}$ 对称部分的最大和最小特征值。\n4. 当 $\\kappa\\big(\\operatorname{Im}\\,\\mathbf{M}\\big)T$ 或 $\\lambda_{\\min}\\le \\varepsilon$ 时，从 Riccati 演化切换到 $(\\mathbf{Q},\\mathbf{P})$ 求值，阈值 $T=10^3$ 且 $\\varepsilon=10^{-9}$。切换后，不再对 Riccati 方程进行积分；而是在继续积分 $(\\mathbf{Q},\\mathbf{P})$ 的同时，通过 $\\mathbf{M}(s)=\\mathbf{P}(s)\\mathbf{Q}(s)^{-1}$ 计算区间剩余部分的 $\\mathbf{M}(s)$。\n5. 另外，通过在整个区间上积分 Riccati ODE 且不进行切换，计算一个仅使用 Riccati 方法的参考解。\n6. 使用固定步长 $h=10^{-3}$ 并传播到指定的终点 $s=s_{\\text{end}}$。\n\n每个测试用例的性能指标：\n\n- 计算混合算法得到的最终条件数 $\\kappa\\big(\\operatorname{Im}\\,\\mathbf{M}(s_{\\text{end}})\\big)$，结果为浮点数。\n- 计算仅使用 Riccati 方法的最终曲率 $\\mathbf{M}_{\\text{Riccati}}(s_{\\text{end}})$ 与混合算法的最终曲率 $\\mathbf{M}_{\\text{hybrid}}(s_{\\text{end}})$ 之间的相对 Frobenius 范数误差：\n$$\nE=\\frac{\\left\\|\\mathbf{M}_{\\text{Riccati}}(s_{\\text{end}})-\\mathbf{M}_{\\text{hybrid}}(s_{\\text{end}})\\right\\|_F}{\\left\\|\\mathbf{M}_{\\text{hybrid}}(s_{\\text{end}})\\right\\|_F},\n$$\n结果为浮点数。如果仅使用 Riccati 方法的解在 $s_{\\text{end}}$ 处产生非有限值条目，则设置 $E=+\\infty$。\n- 报告在传播过程中是否发生了切换，结果为布尔值。\n\n测试组：\n\n- 案例1（理想路径，区间内无焦散面）：$k_1=0.5$, $k_2=0.8$, $\\alpha_1=1.0$, $\\alpha_2=0.2$, $s_{\\text{end}}=1.0$。\n- 案例2（边界靠近第一个焦散面）：$k_1=1.0$, $k_2=0.9$, $\\alpha_1=0.3$, $\\alpha_2=0.05$, $s_{\\text{end}}=1.55$。\n- 案例3（强聚焦，穿越焦散面）：$k_1=1.0$, $k_2=0.6$, $\\alpha_1=0.2$, $\\alpha_2=0.02$, $s_{\\text{end}}=3.2$。\n\n所有量均为无量纲。由 $k_j s$ 隐含的角度以弧度为单位。你的程序应生成单行输出，其中包含按顺序聚合的结果，形式为方括号括起来的逗号分隔列表，每个案例的条目为最终条件数、相对误差和布尔切换标志。具体来说，输出格式为\n\"[κ1,E1,flag1,κ2,E2,flag2,κ3,E3,flag3]\"。", "solution": "用户要求我解决一个计算地球物理学中的问题，具体与高斯波束方法有关。\n\n以下是我的计划：\n1.  **验证问题陈述**：我需要检查我严格的验证清单。\n    *   **提取已知信息**：我将列出问题描述中提供的所有方程、条件、参数和算法。\n    *   **验证**：我将检查科学合理性、良构性、客观性、完整性以及所有其他标准。\n\n2.  **分析问题**：如果问题有效，我将分解其组成部分。\n    *   **物理/数学**：问题涉及求解两个相关的常微分方程组：一个矩阵 Riccati 方程和一个线性哈密顿系统。它们之间的联系是 $\\mathbf{M}(s) = \\mathbf{P}(s)\\mathbf{Q}(s)^{-1}$。背景是一个简化的 Gaussian 波束传播模型，其中某些矩阵为常数或零。\n    *   **数值方法**：指定的方法是四阶龙格-库塔 (RK4) 方法。这是一种用于常微分方程的标准、成熟的数值积分器。\n    *   **算法**：问题的核心是一个混合算法。\n        *   开始时，对 $\\mathbf{M}(s)$ 的 Riccati 方程进行积分：$\\frac{d\\mathbf{M}}{ds} = \\mathbf{C} - \\mathbf{M}^2$。\n        *   在每一步，计算 $\\operatorname{Im}\\,\\mathbf{M}(s)$ 的条件数。虚部是一个复矩阵，但定义中指定了首先取其对称部分：$\\frac{1}{2}(\\operatorname{Im}\\,\\mathbf{M} + \\operatorname{Im}\\,\\mathbf{M}^{\\mathsf{T}})$。然后找到它的最大和最小特征值。\n        *   定义了一个切换条件：$\\kappa(\\operatorname{Im}\\,\\mathbf{M}) > T=10^3$ 或 $\\lambda_{\\min} \\le \\varepsilon=10^{-9}$。\n        *   如果满足切换条件：\n            *   停止积分 Riccati ODE。\n            *   从此以后，积分 $(\\mathbf{Q}, \\mathbf{P})$ 系统：$\\frac{d\\mathbf{Q}}{ds}=\\mathbf{P}, \\frac{d\\mathbf{P}}{ds}=\\mathbf{C}\\,\\mathbf{Q}$。\n            *   使用商 $\\mathbf{M}(s) = \\mathbf{P}(s)\\mathbf{Q}(s)^{-1}$ 计算 $\\mathbf{M}(s)$。\n        *   给出了初始条件：$\\mathbf{M}(0) = i\\,\\operatorname{diag}(\\alpha_1, \\alpha_2)$, $\\mathbf{Q}(0) = \\mathbf{I}$, $\\mathbf{P}(0) = \\mathbf{M}(0)$。注意 $\\mathbf{P}(0) = \\mathbf{M}(0)\\mathbf{Q}(0)$ 是一致的。\n    *   **参考解**：我还需要通过在整个区间 $[0, s_{\\text{end}}]$ 上积分 Riccati 方程而不使用任何切换逻辑来计算一个“纯 Riccati”解，用于比较。\n    *   **指标**：对于每个测试用例，我需要计算三件事：\n        1.  来自混合方法的最终条件数 $\\kappa(\\operatorname{Im}\\,\\mathbf{M}(s_{\\text{end}}))$。\n        2.  在 $s_{\\text{end}}$ 处，混合解和纯 Riccati 解之间的相对 Frobenius 范数误差。一个特殊情况是当纯 Riccati 解爆破（产生 `NaN` 或 `Inf`）时，误差应为 `+inf`。\n        3.  一个指示是否发生切换的布尔标志。\n\n3.  **用 Python 实现解决方案**：\n    *   我将使用 `numpy` 进行矩阵运算（加法、乘法、求逆、特征值、范数）。`scipy` 被列出但如果我从头实现 RK4 可能不需要它，这很简单。让我们遵循问题陈述，看看 `numpy` 是否足够。是的，`numpy.linalg.eigvalsh` 用于 Hermitian 矩阵的特征值，`numpy.linalg.inv` 用于矩阵求逆，`numpy.linalg.norm` 用于 Frobenius 范数。`scipy` 在这里并非必需。\n    *   状态变量是 $2 \\times 2$ 的复矩阵：$\\mathbf{M}$、$\\mathbf{Q}$ 和 $\\mathbf{P}$。\n    *   我需要实现 RK4 步进函数。它将当前状态、步长 `h` 和导数函数作为输入。\n    *   导数函数是：\n        *   对于 Riccati：`dM_ds(M, C) = C - M @ M`。\n        *   对于 $(\\mathbf{Q}, \\mathbf{P})$：`dQ_ds = P`，`dP_ds = C @ Q`。这可以写成一个针对分块状态向量 $\\begin{pmatrix} \\mathbf{Q} \\\\ \\mathbf{P} \\end{pmatrix}$ 的单一系统。其导数为 $\\begin{pmatrix} \\mathbf{0}  \\mathbf{I} \\\\ \\mathbf{C}  \\mathbf{0} \\end{pmatrix} \\begin{pmatrix} \\mathbf{Q} \\\\ \\mathbf{P} \\end{pmatrix}$。\n    *   我将构建主循环，以步长 $h=10^{-3}$ 从 $s=0$ 迭代到 $s=s_{\\text{end}}$。\n    *   在混合模型的循环内部：\n        *   检查 `switched` 标志是否为 `True`。\n        *   如果没有切换：\n            *   为 $\\mathbf{M}(s)$ 执行一个 RK4 步长。\n            *   计算条件数 $\\kappa$。\n            *   检查切换条件。如果满足，设置 `switched = True`。\n            *   还需要并行维护 $(\\mathbf{Q}, \\mathbf{P})$，因为切换后需要它们来继续积分。因此，在切换前的每一步，我必须同时积分两个系统。这是必要的，因为在切换点需要 $(\\mathbf{Q}, \\mathbf{P})$ 的状态。\n        *   如果已切换：\n            *   为 $(\\mathbf{Q}, \\mathbf{P})$ 系统执行一个 RK4 步长。\n        *   循环结束后，计算最终的 $\\mathbf{M}_{\\text{hybrid}}$。如果发生了切换，它来自 $\\mathbf{P}(s_{\\text{end}})\\mathbf{Q}(s_{\\text{end}})^{-1}$。如果没有切换，它就是 Riccati 积分的结果。\n    *   我将为纯 Riccati 参考解编写一个单独的循环。这更简单，只需在整个区间上积分 Riccati ODE。\n    *   在得到 $\\mathbf{M}_{\\text{hybrid}}(s_{\\text{end}})$ 和 $\\mathbf{M}_{\\text{Riccati}}(s_{\\text{end}})$ 之后，我将计算最终的指标。\n    *   问题指定了复数运算。`numpy` 通过 `dtype=np.complex128` 自动处理。\n\n让我们再次检查验证。\n\n---\n### **步骤1：提取已知信息**\n\n- **物理系统**：高频声波在各向同性非均匀介质中的传播。\n- **模型**：高频渐近机制下的高斯波束方法。\n- **相位和振幅控制**：相位由程函方程控制，振幅/宽度由复曲率矩阵 $\\mathbf{M}(s)$ 控制。\n- **曲率矩阵属性**：$\\mathbf{M}(s)$ 是复对称矩阵。$\\operatorname{Im}\\,\\mathbf{M}(s)$ 是正定矩阵。\n- **演化方程**：\n    - 矩阵 Riccati ODE：$\\frac{d\\mathbf{M}}{ds} = \\mathbf{C} - \\mathbf{M}^2$。\n    - 典则变量 $(\\mathbf{Q}(s), \\mathbf{P}(s))$ 的线性哈密顿系统：$\\frac{d\\mathbf{Q}}{ds}=\\mathbf{P}$, $\\frac{d\\mathbf{P}}{ds}=\\mathbf{C}\\,\\mathbf{Q}$。\n    - 关系：$\\mathbf{M}(s)=\\mathbf{P}(s)\\mathbf{Q}(s)^{-1}$。\n- **特定模型系数**（常数）：\n    - $\\mathbf{A}(s)=\\mathbf{0}$\n    - $\\mathbf{D}(s)=\\mathbf{0}$\n    - $\\mathbf{B}(s)=\\mathbf{I}$ ($2 \\times 2$ 单位矩阵)\n    - $\\mathbf{C}(s)=-\\operatorname{diag}(k_1^2,k_2^2)$，其中 $k_10$ 且 $k_20$。\n- **算法**：混合传播算法。\n    - **数值积分器**：复数运算下的四阶龙格-库塔 (RK4) 方法。\n    - **步长**：固定步长 $h=10^{-3}$。\n    - **积分区间**：$[0, s_{\\text{end}}]$。\n- **初始条件**：\n    - $\\mathbf{M}(0)=i\\,\\operatorname{diag}(\\alpha_1,\\alpha_2)$\n    - $\\mathbf{Q}(0)=\\mathbf{I}$\n    - $\\mathbf{P}(0)=\\mathbf{M}(0)\\mathbf{Q}(0) = i\\,\\operatorname{diag}(\\alpha_1, \\alpha_2)$。\n- **切换条件**：\n    - 条件数：$\\kappa\\big(\\operatorname{Im}\\,\\mathbf{M}(s)\\big)=\\frac{\\lambda_{\\max}\\big(\\tfrac{1}{2}(\\operatorname{Im}\\,\\mathbf{M}+\\operatorname{Im}\\,\\mathbf{M}^{\\mathsf{T}})\\big)}{\\lambda_{\\min}\\big(\\tfrac{1}{2}(\\operatorname{Im}\\,\\mathbf{M}+\\operatorname{Im}\\,\\mathbf{M}^{\\mathsf{T}})\\big)}$。\n    - 阈值：$T=10^3$, $\\varepsilon=10^{-9}$。\n    - 当 $\\kappa > T$ 或 $\\lambda_{\\min} \\le \\varepsilon$ 时切换。\n    - 切换后，继续使用 $(\\mathbf{Q},\\mathbf{P})$ 系统进行积分，并通过商来计算 $\\mathbf{M}$。\n- **参考解**：通过在整个区间上积分 Riccati ODE 得到的纯 Riccati 解。\n- **性能指标**：\n    1. 混合算法的最终条件数 $\\kappa\\big(\\operatorname{Im}\\,\\mathbf{M}(s_{\\text{end}})\\big)$。\n    2. 相对 Frobenius 范数误差 $E=\\frac{\\left\\|\\mathbf{M}_{\\text{Riccati}}(s_{\\text{end}})-\\mathbf{M}_{\\text{hybrid}}(s_{\\text{end}})\\right\\|_F}{\\left\\|\\mathbf{M}_{\\text{hybrid}}(s_{\\text{end}})\\right\\|_F}$，如果 Riccati 解非有限，则 $E=+\\infty$。\n    3. 是否发生切换的布尔标志。\n- **测试用例**：\n    1.  $k_1=0.5, k_2=0.8, \\alpha_1=1.0, \\alpha_2=0.2, s_{\\text{end}}=1.0$。\n    2.  $k_1=1.0, k_2=0.9, \\alpha_1=0.3, \\alpha_2=0.05, s_{\\text{end}}=1.55$。\n    3.  $k_1=1.0, k_2=0.6, \\alpha_1=0.2, \\alpha_2=0.02, s_{\\text{end}}=3.2$。\n- **输出格式**：单行字符串 `\"[κ1,E1,flag1,κ2,E2,flag2,κ3,E3,flag3]\"`。\n\n---\n### **步骤2：使用提取的已知信息进行验证**\n\n- **科学上合理**：是。该问题基于高频波传播和高斯波束方法的既定原理。用于波束曲率的矩阵 Riccati 方程和等效的线性哈密顿 $(\\mathbf{Q}, \\mathbf{P})$ 系统是该领域的标准表述。在焦散面附近使用 $(\\mathbf{Q},\\mathbf{P})$ 系统以保证数值稳定性的动机是计算地震学和地球物理学中众所周知的技术。\n- **良构性**：是。问题指定了两个具有明确初始条件的常微分方程 (ODE) 系统。混合方法的数值积分方法 (RK4)、步长和算法逻辑都已明确说明。该问题的结构旨在为每个测试用例产生唯一的数值解。\n- **客观性**：是。语言精确、正式，没有任何主观或基于意见的陈述。所有参数和标准都已量化定义。\n\n对无效性标准的详细检查未发现任何缺陷：\n1.  **科学/事实上不合理**：无。物理和数学在指定领域内是标准的。\n2.  **非形式化/不相关**：无。该问题是一个直接关系到计算地球物理学的形式化数值练习。\n3.  **不完整/矛盾的设置**：设置是全面的。仔细阅读表明，对于混合算法，Riccati 和 $(\\mathbf{Q},\\mathbf{P})$ 系统必须并行积分，直到满足切换条件。切换后，只积分 $(\\mathbf{Q},\\mathbf{P})$ 系统。这是一个一致且完整的规范。此外，问题指出 $\\mathbf{M}$ 是复对称的。由于 $\\mathbf{M}(0)$ 和 $\\mathbf{C}$ 是对称的，可以从数学上证明 $\\mathbf{M}(s)$ 对所有 $s$ 保持对称。这意味着其虚部 $\\operatorname{Im}\\,\\mathbf{M}(s)$ 是一个实对称矩阵。因此，涉及 $\\operatorname{Im}\\,\\mathbf{M}$ 对称部分的条件数 $\\kappa$ 的表达式简化为基于 $\\operatorname{Im}\\,\\mathbf{M}$ 本身特征值的表达式。这是一种一致性，而非缺陷。\n4.  **不切实际/不可行**：无。参数是无量纲的，代表一个有效的物理场景，尽管是简化的。\n5.  **病态/结构不良**：无。问题结构清晰，解有明确定义。\n6.  **伪深刻/琐碎**：无。该问题解决了在高斯波束方法的实际实现中遇到的一个真实且不平凡的数值稳定性问题。直接 Riccati 积分与混合方法之间的比较突出了一个关键的算法权衡。\n7.  **超出科学可验证性**：无。结果可以通过独立实现进行数值验证。\n\n### **步骤3：结论与行动**\n问题是有效的。我将继续提供一个完整的解决方案。\n\n### 算法设计与原理\n\n问题的核心是实现并比较两种数值策略，用于沿一条由弧长 $s$ 参数化的中心射线传播高斯波束的复曲率矩阵 $\\mathbf{M}(s)$。高斯波束是波动方程的渐近解，其性质由动力学射线追踪方程控制，这些方程可以以两种等价的方式表述：一种是关于 $\\mathbf{M}(s)$ 的非线性矩阵 Riccati ODE，另一种是关于一对矩阵 $(\\mathbf{Q}(s), \\mathbf{P}(s))$ 的线性哈密顿系统。它们之间的联系是 $\\mathbf{M}(s) = \\mathbf{P}(s)\\mathbf{Q}(s)^{-1}$。\n\nRiccati 方程 $\\frac{d\\mathbf{M}}{ds} = \\mathbf{C} - \\mathbf{M}^2$ 可能会变得数值不稳定，尤其是在焦散面附近，那里波束聚焦，$\\mathbf{M}$ 的振幅会变得很大。像 RK4 这样的显式积分方案可能会失败或累积显著误差。相比之下，线性系统 $\\frac{d\\mathbf{Q}}{ds}=\\mathbf{P}$ 和 $\\frac{d\\mathbf{P}}{ds}=\\mathbf{C}\\mathbf{Q}$ 是完全正则的，其数值积分非常稳定。混合算法利用了 $(\\mathbf{Q},\\mathbf{P})$ 系统的稳定性。\n\n算法流程如下：\n1.  **初始化**：我们从两个并行的模拟开始：一个“纯 Riccati”参考和一个“混合”模型。两者都以相同的初始条件 $\\mathbf{M}(0)$、$\\mathbf{Q}(0)$ 和 $\\mathbf{P}(0)$ 开始。\n2.  **时间步进**：我们使用固定步长的 RK4 积分器将解从 $s=0$ 推进到 $s=s_{\\text{end}}$。在每一步中：\n    - 纯 Riccati 解 $\\mathbf{M}_{\\text{Riccati}}$ 向前推进一步。\n    - 混合解向前推进。在切换之前，这涉及通过 Riccati ODE 积分 $\\mathbf{M}_{\\text{hybrid}}$ 以及积分 $(\\mathbf{Q},\\mathbf{P})$ 系统。在每一步之后，检查 $\\mathbf{M}_{\\text{hybrid}}$ 矩阵的稳定性。\n3.  **切换条件**：稳定性由 $\\mathbf{M}_{\\text{hybrid}}$ 虚部的条件数 $\\kappa$ 来量化。如果 $\\kappa$ 超过阈值 $T=10^3$ 或 $\\operatorname{Im}\\,\\mathbf{M}_{\\text{hybrid}}$ 的最小特征值 $\\lambda_{\\min}$ 低于阈值 $\\varepsilon=10^{-9}$，算法将进行切换。\n4.  **切换后**：切换后，通过 Riccati 方程积分 $\\mathbf{M}_{\\text{hybrid}}$ 的过程被终止。算法仅通过积分 $(\\mathbf{Q},\\mathbf{P})$ 系统继续进行。\n5.  **最终求值**：在 $s = s_{\\text{end}}$ 时：\n    - 如果混合算法从未切换，其最终状态是直接积分得到的 $\\mathbf{M}_{\\text{hybrid}}(s_{\\text{end}})$。\n    - 如果它切换了，最终状态由商 $\\mathbf{M}_{\\text{hybrid}}(s_{\\text{end}}) = \\mathbf{P}(s_{\\text{end}})\\mathbf{Q}(s_{\\text{end}})^{-1}$ 计算得出。\n    - 记录参考模拟的最终状态 $\\mathbf{M}_{\\text{Riccati}}(s_{\\text{end}})$。\n6.  **指标计算**：然后计算所需的指标——混合解的最终条件数以及混合解与纯 Riccati 解之间的相对误差。如果纯 Riccati 积分失败并产生非有限值，相对误差将为无穷大，这证明了该方法的崩溃。\n\n该实现将对所有积分使用四阶龙格-库塔方法。对于 $(\\mathbf{Q},\\mathbf{P})$ 系统，状态被视为一个矩阵元组，并且 RK4 更新应用于元组中的每个矩阵。所有算术都按要求在复数中执行。条件数是使用曲率矩阵虚部的特征值来计算的，由于对于复对称矩阵 $\\mathbf{M}$，$\\operatorname{Im}(\\mathbf{M})$ 是一个实对称矩阵，这个过程被简化了。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef riccati_rhs(s, M, C):\n    \"\"\"Right-hand side of the matrix Riccati ODE: dM/ds = C - M^2.\"\"\"\n    return C - M @ M\n\ndef qp_rhs(s, qp_state, C):\n    \"\"\"Right-hand side of the linear (Q,P) system.\"\"\"\n    Q, P = qp_state\n    dQ_ds = P\n    dP_ds = C @ Q\n    return (dQ_ds, dP_ds)\n\ndef rk4_step_matrix(f, s, y, h, **kwargs):\n    \"\"\"Fourth-order Runge-Kutta step for a single matrix-valued state y.\"\"\"\n    k1 = f(s, y, **kwargs)\n    k2 = f(s + 0.5 * h, y + 0.5 * h * k1, **kwargs)\n    k3 = f(s + 0.5 * h, y + 0.5 * h * k2, **kwargs)\n    k4 = f(s + h, y + h * k3, **kwargs)\n    return y + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\ndef rk4_step_tuple(f, s, y, h, **kwargs):\n    \"\"\"Fourth-order Runge-Kutta step for a tuple-valued state y.\"\"\"\n    k1_tuple = f(s, y, **kwargs)\n    \n    y_temp_2 = tuple(y[i] + 0.5 * h * k1_tuple[i] for i in range(len(y)))\n    k2_tuple = f(s + 0.5 * h, y_temp_2, **kwargs)\n    \n    y_temp_3 = tuple(y[i] + 0.5 * h * k2_tuple[i] for i in range(len(y)))\n    k3_tuple = f(s + 0.5 * h, y_temp_3, **kwargs)\n    \n    y_temp_4 = tuple(y[i] + h * k3_tuple[i] for i in range(len(y)))\n    k4_tuple = f(s + h, y_temp_4, **kwargs)\n    \n    y_new = tuple(y[i] + (h / 6.0) * (k1_tuple[i] + 2 * k2_tuple[i] + 2 * k3_tuple[i] + k4_tuple[i]) for i in range(len(y)))\n    return y_new\n\ndef get_condition_info(M):\n    \"\"\"\n    Calculates the condition number and minimum eigenvalue of the imaginary part of M.\n    Since M is complex symmetric, Im(M) is real symmetric.\n    \"\"\"\n    if not np.all(np.isfinite(M)):\n        return np.inf, -1.0\n        \n    Im_M = np.imag(M)\n    \n    try:\n        # Use eigvalsh for real symmetric (or complex Hermitian) matrices.\n        eigenvalues = np.linalg.eigvalsh(Im_M)\n    except np.linalg.LinAlgError:\n        return np.inf, -1.0\n        \n    l_min = np.min(eigenvalues)\n    l_max = np.max(eigenvalues)\n\n    if l_min = 1e-15:  # Effectively zero or negative\n        kappa = np.inf\n    else:\n        kappa = l_max / l_min\n        \n    return kappa, l_min\n\ndef solve_case(k1, k2, alpha1, alpha2, s_end):\n    \"\"\"Solves one test case of the Gaussian beam propagation problem.\"\"\"\n    h = 1e-3\n    T_thresh = 1e3\n    eps_thresh = 1e-9\n\n    C = -np.diag([k1**2, k2**2]).astype(np.complex128)\n    M0 = np.diag([1j * alpha1, 1j * alpha2]).astype(np.complex128)\n    Q0 = np.identity(2, dtype=np.complex128)\n    P0 = M0 @ Q0\n\n    # Hybrid simulation variables\n    M_h = np.copy(M0)\n    Q_h = np.copy(Q0)\n    P_h = np.copy(P0)\n    switched = False\n\n    # Riccati-only simulation variable\n    M_r = np.copy(M0)\n\n    num_steps = int(round(s_end / h))\n    s = 0.0\n\n    for _ in range(num_steps):\n        # --- Riccati-only Reference Step ---\n        if np.all(np.isfinite(M_r)):\n            M_r = rk4_step_matrix(riccati_rhs, s, M_r, h, C=C)\n        \n        # --- Hybrid Algorithm Step ---\n        if not switched:\n            M_h = rk4_step_matrix(riccati_rhs, s, M_h, h, C=C)\n            kappa, l_min = get_condition_info(M_h)\n            if kappa > T_thresh or l_min = eps_thresh:\n                switched = True\n                # At the point of switching, we trust the (Q,P) system which has been\n                # integrated in parallel. The M matrix will be computed from it.\n        \n        # In the hybrid method, (Q, P) is always integrated to be ready for the switch.\n        Q_h, P_h = rk4_step_tuple(qp_rhs, s, (Q_h, P_h), h, C=C)\n        \n        s += h\n    \n    # --- Final Calculations ---\n    if switched:\n        try:\n            M_h_final = P_h @ np.linalg.inv(Q_h)\n        except np.linalg.LinAlgError:\n            M_h_final = np.full_like(M0, np.inf)\n    else:\n        M_h_final = M_h\n\n    final_kappa, _ = get_condition_info(M_h_final)\n\n    M_r_final = M_r\n    if not np.all(np.isfinite(M_r_final)):\n        rel_err = np.inf\n    elif not np.all(np.isfinite(M_h_final)):\n        rel_err = np.inf\n    else:\n        norm_diff = np.linalg.norm(M_r_final - M_h_final, 'fro')\n        norm_hybrid = np.linalg.norm(M_h_final, 'fro')\n        if norm_hybrid  1e-12: # Handle case of near-zero matrix\n            rel_err = np.inf if norm_diff > 1e-9 else 0.0\n        else:\n            rel_err = norm_diff / norm_hybrid\n            \n    return final_kappa, rel_err, switched\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k1, k2, alpha1, alpha2, s_end)\n        (0.5, 0.8, 1.0, 0.2, 1.0),\n        (1.0, 0.9, 0.3, 0.05, 1.55),\n        (1.0, 0.6, 0.2, 0.02, 3.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        k1, k2, alpha1, alpha2, s_end = case\n        kappa, err, flag = solve_case(k1, k2, alpha1, alpha2, s_end)\n        results.extend([kappa, err, str(flag).lower()])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3599627"}]}