{"hands_on_practices": [{"introduction": "任何可靠的数值方法都必须是可验证的。第一个练习提供了一项计算科学中的基础训练：实现一个求解程函方程的一阶求解器，并进行网格加密研究。通过将数值结果与已知的解析解进行比较，你将根据经验测量该方法的收敛阶，从而证实你的实现与理论预期相符。", "problem": "考虑用于各向同性介质中首波走时的二维程函方程，其偏微分方程形式为 $|\\nabla T(\\mathbf{x})| = s$，其中 $T(\\mathbf{x})$ 是以秒为单位的走时场，$\\mathbf{x} = (x,y)$ 是以米为单位的位置，而 $s$ 是单位为秒/米的常数慢度。在以米为单位的矩形域 $[0,1]\\times[0,1]$ 上，考虑一个位于中心 $(x_s,y_s) = (0.5,0.5)$ 米处的点源，其边界条件为 $T(x_s,y_s) = 0$ 秒。对于常数 $s$，其在连续统中的解析解为\n$$T(x,y) = s \\sqrt{(x-x_s)^2 + (y-y_s)^2}.$$\n\n您的任务是，使用程函方程的一阶单调迎风离散化方法建立一个网格加密研究，并在误差范数 $\\| T_h - T \\|$ 与网格间距 $h$ 的对数-对数图上，计算多个慢度值下的经验收敛斜率。此处，$T_h$ 表示在间距为 $h$ 的均匀笛卡尔网格上计算的数值解，$T$ 表示解析解。使用适合一阶格式的求解器（例如，快速行进法或快速扫描法），该求解器需与单调迎风离散化方法一致并能产生因果解。\n\n基本原理和要求：\n- 使用由程函方程 $|\\nabla T| = s$ 控制的各向同性介质中的走时定义，其中 $s$ 为常数，狄利克雷数据为 $T(x_s,y_s)=0$。\n- 在间距为 $h$ 米的均匀网格上，使用经过充分测试的一阶 Godunov 迎风离散化方法。在具有离散邻居值的网格节点 $(i,j)$ 处，离散走时 $T_{i,j}$ 的局部更新必须通过求解一个二次方程来获得，该方程使用坐标方向上最小的迎风邻居值来强制执行离散的程函方程条件。具体来说，如果 $a$ 是 $x$ 方向上两个邻居中的最小值，$b$ 是 $y$ 方向上两个邻居中的最小值，则更新值 $U$ 满足\n$$\\left(\\max\\left(\\frac{U-a}{h},0\\right)\\right)^2 + \\left(\\max\\left(\\frac{U-b}{h},0\\right)\\right)^2 = s^2,$$\n并带有可采纳条件 $U \\ge \\max(a,b)$。这会得到以下闭式更新\n$$\nU =\n\\begin{cases}\n\\min(a,b) + h s,  & \\text{if } |a-b| \\ge h s, \\\\\n\\dfrac{a+b + \\sqrt{2(h s)^2 - (a-b)^2}}{2},  & \\text{otherwise}.\n\\end{cases}\n$$\n- 数值解必须以秒为单位计算。网格间距必须以米为单位。慢度必须以秒/米为单位。\n- 为了在远离点源奇点处分离出渐近阶，计算误差范数时应排除源点周围半径为 $2h$ 的小圆盘。也就是说，只包括那些与 $(x_s,y_s)$ 的欧几里得距离严格大于 $2h$ 的节点。\n\n误差范数和收敛斜率：\n- 对于给定的网格间距 $h$，计算离散 $L^2$ 误差\n$$\\| T_h - T \\|_{2,h} = \\sqrt{ h^2 \\sum_{i,j} \\left(T_{i,j} - T(x_i,y_j)\\right)^2 },$$\n以及离散 $L^\\infty$ 误差\n$$\\| T_h - T \\|_{\\infty,h} = \\max_{i,j} |T_{i,j} - T(x_i,y_j)|,$$\n其中求和与求最大值操作的对象是位于以 $(x_s,y_s)$ 为中心、半径为 $2h$ 的排除圆盘之外的网格节点。\n- 对于一组网格间距 $\\{h_k\\}$，使用最小二乘法对数据点 $(\\log_{10} h_k, \\log_{10} \\| T_h - T \\|)$ 进行直线拟合，以获得每种范数下的经验斜率。一阶格式预计将产生接近 $1$ 的斜率。\n\n测试套件和最终输出：\n- 使用以下以秒/米为单位的慢度值：$s \\in \\{0.75, 1.5, 3.0\\}$。\n- 对于每个 $s$，使用每维包含 $N \\in \\{33, 65, 129, 257\\}$ 个节点的均匀网格。网格间距为 $h = 1/(N-1)$ 米。\n- 对于每个 $s$，基于四个网格级别计算 $L^2$ 误差和 $L^\\infty$ 误差的经验斜率。\n- 您的程序应生成单行输出，其中包含六个结果，格式为方括号内以逗号分隔的列表，顺序如下\n$$[\\text{slope}_{L^2}(s{=}0.75), \\text{slope}_{L^\\infty}(s{=}0.75), \\text{slope}_{L^2}(s{=}1.5), \\text{slope}_{L^\\infty}(s{=}1.5), \\text{slope}_{L^2}(s{=}3.0), \\text{slope}_{L^\\infty}(s{=}3.0)]。$$\n所有数字必须以十进制数形式打印（输出行中不含单位），并由程序自行决定舍入方式。在内部，确保所有走时单位为秒，所有距离单位为米，所有慢度值单位为秒/米。", "solution": "该问题要求进行一次网格加密研究，以确定二维程函方程一阶数值解的经验收敛阶。该问题在科学和数学上是适定的，提供了所有必要的组成部分：控制偏微分方程、一个具有解析解的特例、数值离散格式、误差度量以及研究参数。\n\n其物理问题是求解在慢度为常数 $s$ 的介质中，从一个点源发出的波的首波走时 $T(\\mathbf{x})$。这由定义在域 $\\mathbf{x} = (x,y) \\in [0,1] \\times [0,1]$ 米上的程函方程 $|\\nabla T(\\mathbf{x})| = s$ 控制。给定点源位于 $(x_s, y_s) = (0.5, 0.5)$ 米，此处的走时定义为零，$T(x_s, y_s) = 0$ 秒，其在连续统中的解析解为 $T(x,y) = s \\sqrt{(x-x_s)^2 + (y-y_s)^2}$ 秒。\n\n为了数值求解该方程，我们采用指定的一阶 Godunov 迎风有限差分格式。该格式将域离散化为间距为 $h$ 的均匀笛卡尔网格，并在每个网格节点 $(i,j)$ 处近似程函方程。走时 $T_{i,j}$ 基于其迎风邻居（即波前到达方向的邻居）的走时进行更新。问题提供了节点处更新后走时 $U$ 的正确闭式解，该解由离散化梯度算子产生的二次方程导出：\n$$\nU =\n\\begin{cases}\n\\min(a,b) + h s,  & \\text{if } |a-b| \\ge h s, \\\\\n\\dfrac{a+b + \\sqrt{2(h s)^2 - (a-b)^2}}{2},  & \\text{otherwise},\n\\end{cases}\n$$\n其中 $a$ 和 $b$ 分别是 $x$ 和 $y$ 方向上邻居中的最小走时。这个非线性方程组需要一个专门的求解器。\n\n快速行进法（FMM）是为求解该离散系统所选择的算法。FMM 是一种高效的单遍算法，它通过按走时递增的顺序传播波前，从而正确捕捉粘性解，这类似于图上的 Dijkstra 算法。该方法通过维护三组网格点来运作：`KNOWN`（其最终走时已计算出的点）、`TRIAL`（代表当前波前的、邻近已知区域的窄带点集）和 `FAR`（所有其他点）。一个最小优先队列管理 `TRIAL` 点。该算法迭代进行：\n1. 初始化走时网格，除源点 $T(x_s, y_s) = 0$ 外，所有点的值均为 $\\infty$。将源点添加到优先队列中。\n2. 当优先队列不为空时，提取具有最小走时的 `TRIAL` 点。\n3. 将此点从 `TRIAL` 集合移动到 `KNOWN` 集合。\n4. 对于这个新成为 `KNOWN` 点的每个邻居，使用 Godunov 更新公式计算一个潜在的新走时。如果这个新时间小于该邻居当前的时间，则更新邻居的时间，并将其添加到队列中（或更新其在队列中的优先级）。\n\n对于收敛性研究，这个 FMM 求解器将在每个指定的慢度 $s \\in \\{0.75, 1.5, 3.0\\}$ 秒/米下，在一系列包含 $N \\in \\{33, 65, 129, 257\\}$ 个边节点的四个网格上执行。网格间距为 $h = 1/(N-1)$ 米。在每个网格上计算出数值解 $T_h$ 后，我们通过将其与解析解 $T$ 进行比较来计算误差。离散的 $L^2$ 和 $L^\\infty$ 误差范数按规定计算：\n$$ \\| T_h - T \\|_{2,h} = \\sqrt{ h^2 \\sum_{i,j} \\left(T_{i,j} - T(x_i,y_j)\\right)^2 }, \\quad \\| T_h - T \\|_{\\infty,h} = \\max_{i,j} |T_{i,j} - T(x_i,y_j)|. $$\n关键的是，求和与求最大值的操作仅在以源点为中心、半径为 $2h$ 的圆盘之外的网格点上进行。这排除了点源奇点周围的区域，在该区域解析解不可微，且数值误差不遵循格式的渐近行为，因此可以清晰地测量收敛率。\n\n最后，对于每个慢度 $s$ 和每种误差范数，经验收敛阶由对四个数据点 $(\\log_{10} h_k, \\log_{10} \\text{error}_k)$ 进行线性最小二乘回归得到的最佳拟合线的斜率确定。对于一阶格式，该斜率预计将接近 $1$。该实现将计算这六个斜率，并将其格式化为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to perform the grid-refinement study and compute convergence slopes.\n    \"\"\"\n    \n    def godunov_update(a, b, h, s):\n        \"\"\"\n        Computes the travel time update using the first-order Godunov scheme.\n        a: min travel time in x-direction\n        b: min travel time in y-direction\n        h: grid spacing\n        s: slowness\n        \"\"\"\n        hs = h * s\n        # This handles the case where one or both of a, b are np.inf\n        # abs(np.inf - finite) is np.inf, correctly triggering the 1D update\n        if np.abs(a - b) >= hs:\n            return min(a, b) + hs\n        else:\n            # This case requires both a and b to be finite\n            term_under_sqrt = 2 * (hs**2) - (a - b)**2\n            # A numerically robust check to prevent sqrt of small negative number\n            if term_under_sqrt  0:\n                return min(a, b) + hs\n            return (a + b + np.sqrt(term_under_sqrt)) / 2\n\n    def run_fmm(N, h, s):\n        \"\"\"\n        Solves the Eikonal equation using the Fast Marching Method.\n        \"\"\"\n        # Constants for node states\n        KNOWN = 2\n        TRIAL = 1\n        FAR = 0\n        \n        T = np.full((N, N), np.inf, dtype=np.float64)\n        states = np.full((N, N), FAR, dtype=np.int8)\n        \n        # Source setup\n        source_idx = (N - 1) // 2\n        isrc, jsrc = source_idx, source_idx\n        T[isrc, jsrc] = 0.0\n        \n        trial_heap = [(0.0, isrc, jsrc)]\n        \n        while trial_heap:\n            t, i, j = heapq.heappop(trial_heap)\n            \n            if states[i, j] == KNOWN:\n                continue\n                \n            states[i, j] = KNOWN\n            \n            # Update neighbors\n            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if not (0 = ni  N and 0 = nj  N):\n                    continue\n                \n                if states[ni, nj] == KNOWN:\n                    continue\n\n                t_x1 = T[ni - 1, nj] if ni > 0 else np.inf\n                t_x2 = T[ni + 1, nj] if ni  N - 1 else np.inf\n                a = min(t_x1, t_x2)\n\n                t_y1 = T[ni, nj - 1] if nj > 0 else np.inf\n                t_y2 = T[ni, nj + 1] if nj  N - 1 else np.inf\n                b = min(t_y1, t_y2)\n                \n                if a == np.inf and b == np.inf:\n                    continue\n\n                U = godunov_update(a, b, h, s)\n\n                if U  T[ni, nj]:\n                    T[ni, nj] = U\n                    states[ni, nj] = TRIAL\n                    heapq.heappush(trial_heap, (U, ni, nj))\n                    \n        return T\n\n    def calculate_analytical(N, h, s, source_pos):\n        \"\"\"\n        Computes the analytical solution on the grid.\n        \"\"\"\n        grid_coords = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(grid_coords, grid_coords, indexing='ij')\n        xs, ys = source_pos\n        T_exact = s * np.sqrt((xx - xs)**2 + (yy - ys)**2)\n        return T_exact\n\n    def calculate_errors(T_h, T_exact, N, h, source_pos):\n        \"\"\"\n        Computes L2 and Linf errors, excluding a disk of radius 2h around the source.\n        \"\"\"\n        exclusion_radius = 2.0 * h\n        xs, ys = source_pos\n        \n        sum_sq_err = 0.0\n        max_abs_err = 0.0\n        \n        grid_coords = np.linspace(0.0, 1.0, N)\n        \n        for i in range(N):\n            for j in range(N):\n                xi, yj = grid_coords[i], grid_coords[j]\n                dist_from_source = np.sqrt((xi - xs)**2 + (yj - ys)**2)\n                \n                if dist_from_source > exclusion_radius:\n                    abs_err = np.abs(T_h[i, j] - T_exact[i, j])\n                    sum_sq_err += abs_err**2\n                    if abs_err > max_abs_err:\n                        max_abs_err = abs_err\n        \n        l2_err = np.sqrt(h**2 * sum_sq_err)\n        linf_err = max_abs_err\n        \n        return l2_err, linf_err\n\n    # --- Main Execution Logic ---\n    s_values = [0.75, 1.5, 3.0]\n    N_values = [33, 65, 129, 257]\n    source_pos = (0.5, 0.5)\n    \n    all_slopes = []\n\n    for s in s_values:\n        log_h_vals = []\n        log_l2_errors = []\n        log_linf_errors = []\n\n        for N in N_values:\n            h = 1.0 / (N - 1)\n            \n            T_h = run_fmm(N, h, s)\n            T_exact = calculate_analytical(N, h, s, source_pos)\n            \n            l2_err, linf_err = calculate_errors(T_h, T_exact, N, h, source_pos)\n            \n            if l2_err > 0 and linf_err > 0:\n                log_h_vals.append(np.log10(h))\n                log_l2_errors.append(np.log10(l2_err))\n                log_linf_errors.append(np.log10(linf_err))\n\n        # Perform linear regression to find the slope (order of convergence)\n        # using numpy.polyfit for least-squares\n        if len(log_h_vals) > 1:\n            slope_l2 = np.polyfit(log_h_vals, log_l2_errors, 1)[0]\n            slope_linf = np.polyfit(log_h_vals, log_linf_errors, 1)[0]\n            all_slopes.extend([slope_l2, slope_linf])\n        else:\n            # Handle case where not enough data points were collected\n            all_slopes.extend([np.nan, np.nan])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_slopes))}]\")\n\nsolve()\n```", "id": "3591153"}, {"introduction": "地球物理问题很少建立在简单的笛卡尔坐标系中，而常常涉及地球的球形几何。本练习旨在弥合抽象理论与实际应用之间的鸿沟，要求你在球坐标系中推导程函方程并进行离散化。然后，你将把推导出的更新公式应用于一个具体算例，从而获得如何将这些方法应用于全球尺度地震学建模的实践经验。", "problem": "考虑在一个三维、非均匀但各向同性的地球模型中传播的高频纵波，其慢度场为 $s(\\mathbf{x}) = \\frac{1}{v(\\mathbf{x})}$。波场相位的前导高频渐近近似（Wentzel–Kramers–Brillouin–Jeffreys (WKBJ) 拟设）导出了一个关于走时 $T(\\mathbf{x})$ 的一阶非线性偏微分方程，称为程函方程。在球坐标系 $(r,\\theta,\\phi)$ 中进行计算，其中余纬 $\\theta \\in [0,\\pi]$ 和经度 $\\phi \\in [0,2\\pi)$ 采用常规定义。\n\n第一部分（推导）：从声波方程的高频拟设和正交曲线坐标系中通过坐标尺度因子定义的梯度模长出发，推导程函方程的显式球坐标形式，该形式将 $\\nabla T$ 的范数与 $s(r,\\theta,\\phi)$ 联系起来。\n\n第二部分（离散化）：对于一个径向变化的地球模型，其中 $s(\\mathbf{x}) = s(r)$，考虑一种适用于快速行进法（FMM）的一阶Godunov迎风离散格式。在一个球坐标网格上，节点 $(r_i,\\theta_j,\\phi_k)$ 处的局部间距为 $\\Delta r$、$\\Delta \\theta$ 和 $\\Delta \\phi$，使用与单调性一致的单边差分来构建一个关于 $T_{i,j,k}$ 的局部代数方程。该方程用沿每个坐标方向已接受的最小邻近点走时表示，\n- $t_r = \\min\\{T_{i-1,j,k},\\,T_{i+1,j,k}\\}$,\n- $t_\\theta = \\min\\{T_{i,j-1,k},\\,T_{i,j+1,k}\\}$,\n- $t_\\phi = \\min\\{T_{i,j,k-1},\\,T_{i,j,k+1}\\}$,\n以及度量尺度化系数\n- $a = \\frac{1}{\\Delta r^2}$,\n- $b = \\frac{1}{(r_i \\,\\Delta \\theta)^2}$,\n- $c = \\frac{1}{(r_i \\sin\\theta_j \\,\\Delta \\phi)^2}$.\n推导 $T_{i,j,k}$ 的通用二次更新公式，该公式使用其邻近点满足因果性条件 $T_{i,j,k} \\ge t_{\\cdot}$ 的方向子集，并说明确定在更新中包含一个、两个还是三个方向的接受准则。\n\n第三部分（数值更新）：在节点 $(r_i,\\theta_j,\\phi_k)$ 处，取 $r_i = 6000\\,\\mathrm{km}$，$\\theta_j = 50^\\circ$（在所有计算中使用弧度），$\\Delta r = 20\\,\\mathrm{km}$，以及 $\\Delta \\theta = \\Delta \\phi = \\frac{\\pi}{360}$。设局部速度是径向变化的，\n$$\nv(r) = 8.0 + 2.0 \\times 10^{-4}\\,(r - 3480)\\quad\\text{km/s},\n$$\n因此慢度为 $s(r) = \\frac{1}{v(r)}$，单位是 $\\mathrm{s/km}$。假设已接受的邻近点值为\n$$\nT_{i-1,j,k} = 125.0\\,\\mathrm{s},\\quad T_{i+1,j,k} = 130.0\\,\\mathrm{s},\\quad T_{i,j-1,k} = 131.5\\,\\mathrm{s},\\quad T_{i,j+1,k} = 135.0\\,\\mathrm{s},\\quad T_{i,j,k-1} = 129.6\\,\\mathrm{s},\\quad T_{i,j,k+1} = 132.8\\,\\mathrm{s}.\n$$\n使用你在第二部分中推导的更新公式和标准的FMM接受准则，计算该节点上 $T_{i,j,k}$ 的数值。所有长度使用千米，时间使用秒，角度使用弧度。将你的最终答案四舍五入到五位有效数字，并以秒为单位表示。", "solution": "该问题被验证为具有科学依据、良态且客观的。它提出了一个计算地球物理学中标准而全面的问题，涵盖了控制方程的理论推导、数值格式的构建以及具体的数值计算。所有必要的数据都已提供，其物理和数学前提都是合理的。\n\n### 第一部分：球坐标系下程函方程的推导\n\n程函方程是波动方程的高频渐近极限，其一般形式为：\n$$|\\nabla T|^2 = s^2(\\mathbf{x})$$\n其中 $T(\\mathbf{x})$ 是走时场，$s(\\mathbf{x})$ 是慢度（速度的倒数）场。我们需要将此方程用球坐标 $(r, \\theta, \\phi)$ 表示。\n\n在一个具有相应尺度因子 $(h_1, h_2, h_3)$ 的通用正交曲线坐标系 $(q_1, q_2, q_3)$ 中，标量场 $T$ 的梯度由下式给出：\n$$\\nabla T = \\frac{1}{h_1}\\frac{\\partial T}{\\partial q_1}\\hat{\\mathbf{e}}_1 + \\frac{1}{h_2}\\frac{\\partial T}{\\partial q_2}\\hat{\\mathbf{e}}_2 + \\frac{1}{h_3}\\frac{\\partial T}{\\partial q_3}\\hat{\\mathbf{e}}_3$$\n因此，梯度的模的平方 $|\\nabla T|^2 = \\nabla T \\cdot \\nabla T$ 为：\n$$|\\nabla T|^2 = \\left(\\frac{1}{h_1}\\frac{\\partial T}{\\partial q_1}\\right)^2 + \\left(\\frac{1}{h_2}\\frac{\\partial T}{\\partial q_2}\\right)^2 + \\left(\\frac{1}{h_3}\\frac{\\partial T}{\\partial q_3}\\right)^2$$\n对于球坐标系 $(r, \\theta, \\phi)$，坐标和尺度因子为：\n- $q_1 = r$，尺度因子 $h_r = 1$。\n- $q_2 = \\theta$，尺度因子 $h_\\theta = r$。\n- $q_3 = \\phi$，尺度因子 $h_\\phi = r \\sin\\theta$。\n\n将这些特定的尺度因子代入梯度模的平方的通用表达式中，得到：\n$$|\\nabla T|^2 = \\left(\\frac{1}{1}\\frac{\\partial T}{\\partial r}\\right)^2 + \\left(\\frac{1}{r}\\frac{\\partial T}{\\partial \\theta}\\right)^2 + \\left(\\frac{1}{r \\sin\\theta}\\frac{\\partial T}{\\partial \\phi}\\right)^2$$\n因此，程函方程的显式球坐标形式为：\n$$\\left(\\frac{\\partial T}{\\partial r}\\right)^2 + \\frac{1}{r^2}\\left(\\frac{\\partial T}{\\partial \\theta}\\right)^2 + \\frac{1}{(r \\sin\\theta)^2}\\left(\\frac{\\partial T}{\\partial \\phi}\\right)^2 = s^2(r, \\theta, \\phi)$$\n\n### 第二部分：离散化与更新公式\n\n对于径向变化的慢度场 $s(\\mathbf{x}) = s(r)$，在网格节点 $(r_i, \\theta_j, \\phi_k)$ 处的程函方程为：\n$$\\left(\\frac{\\partial T}{\\partial r}\\right)^2 + \\frac{1}{r_i^2}\\left(\\frac{\\partial T}{\\partial \\theta}\\right)^2 + \\frac{1}{(r_i \\sin\\theta_j)^2}\\left(\\frac{\\partial T}{\\partial \\phi}\\right)^2 = s_i^2$$\n其中 $s_i = s(r_i)$。\n\n快速行进法（FMM）使用一种迎风、一阶Godunov型格式来离散化偏导数。这种格式遵循波传播的因果性原理：一个节点的走时 $T_{i,j,k}$ 只能由走时更小的邻近点决定。问题将这些最小邻近点走时定义为 $t_r, t_\\theta, t_\\phi$。导数使用单边有限差分近似，从最小走时邻近点（“迎风”方向）指向正在计算的节点。对于一个潜在的新走时 $T \\equiv T_{i,j,k}$：\n- $\\left(\\frac{\\partial T}{\\partial r}\\right)^2 \\approx \\left(\\frac{T - t_r}{\\Delta r}\\right)^2$\n- $\\left(\\frac{\\partial T}{\\partial \\theta}\\right)^2 \\approx \\left(\\frac{T - t_\\theta}{\\Delta \\theta}\\right)^2$\n- $\\left(\\frac{\\partial T}{\\partial \\phi}\\right)^2 \\approx \\left(\\frac{T - t_\\phi}{\\Delta \\phi}\\right)^2$\n\n将这些代入程函方程，得到：\n$$\\left(\\frac{T - t_r}{\\Delta r}\\right)^2 + \\frac{1}{r_i^2}\\left(\\frac{T - t_\\theta}{\\Delta \\theta}\\right)^2 + \\frac{1}{(r_i \\sin\\theta_j)^2}\\left(\\frac{T - t_\\phi}{\\Delta \\phi}\\right)^2 = s_i^2$$\n使用指定的系数 $a = \\frac{1}{\\Delta r^2}$，$b = \\frac{1}{(r_i \\Delta \\theta)^2}$ 和 $c = \\frac{1}{(r_i \\sin\\theta_j \\Delta \\phi)^2}$，方程变为：\n$$a(T - t_r)^2 + b(T - t_\\theta)^2 + c(T - t_\\phi)^2 = s_i^2$$\n此公式仅包含满足因果性条件 $T  t_k$（其中 $k \\in \\{r, \\theta, \\phi\\}$）的项。设 $D \\subseteq \\{r, \\theta, \\phi\\}$ 是更新中包含的方向子集。令 $\\alpha_r = a, \\alpha_\\theta = b, \\alpha_\\phi = c$。关于 $T$ 的方程是：\n$$\\sum_{k \\in D} \\alpha_k (T - t_k)^2 = s_i^2$$\n展开后得到通用的二次更新公式：\n$$\\left(\\sum_{k \\in D} \\alpha_k\\right) T^2 - 2\\left(\\sum_{k \\in D} \\alpha_k t_k\\right) T + \\left(\\sum_{k \\in D} \\alpha_k t_k^2 - s_i^2\\right) = 0$$\n这是一个形如 $A T^2 + B T + C = 0$ 的二次方程，我们选择较大的根 $T = \\frac{-B + \\sqrt{B^2 - 4AC}}{2A}$，这对应于波前的正向传播。\n\n确定在集合 $D$ 中包含哪些方向的接受准则是一个迭代过程：\n1.  对迎风邻近点走时进行排序：$t_{(1)} \\le t_{(2)} \\le t_{(3)}$，其中 $(1), (2), (3)$ 代表排序后方向（来自 $\\{r, \\theta, \\phi\\}$）的索引。\n2.  仅使用具有最小邻近点走时 $t_{(1)}$ 的方向，计算一个试探性更新值 $T_{up}$。解方程 $\\alpha_{(1)}(T_{up} - t_{(1)})^2 = s_i^2$，得到 $T_{up} = t_{(1)} + s_i/\\sqrt{\\alpha_{(1)}}$。\n3.  对下一个最快方向进行因果性检查：将 $T_{up}$ 与 $t_{(2)}$ 进行比较。\n    - 如果 $T_{up} \\le t_{(2)}$，则更新是一致的。解的特征线仅源于第一个方向。接受此更新：$T_{i,j,k} = T_{up}$。\n    - 如果 $T_{up}  t_{(2)}$，则一维更新是不充分的。特征线至少涉及两个方向。进入下一步。\n4.  使用前两个方向计算一个新的试探性更新值 $T_{up}$。解二次方程 $\\alpha_{(1)}(T_{up} - t_{(1)})^2 + \\alpha_{(2)}(T_{up} - t_{(2)})^2 = s_i^2$。\n5.  对最后一个方向进行因果性检查：将这个新的 $T_{up}$ 与 $t_{(3)}$ 进行比较。\n    - 如果 $T_{up} \\le t_{(3)}$，则二维更新是一致的。接受此更新：$T_{i,j,k} = T_{up}$。\n    - 如果 $T_{up}  t_{(3)}$，则二维更新也是不充分的。特征线必须涉及所有三个方向。\n6.  如果前两个检查都失败了，则通过解包含所有三个邻近点走时 $t_r, t_\\theta, t_\\phi$ 的完整三维二次方程来计算最终更新值 $T_{i,j,k}$。\n\n### 第三部分：数值更新\n\n首先，我们整理所需的数值。\n- 节点位置：$r_i = 6000 \\, \\mathrm{km}$，$\\theta_j = 50^\\circ = 50 \\frac{\\pi}{180} \\, \\mathrm{rad}$。\n- 网格间距：$\\Delta r = 20 \\, \\mathrm{km}$，$\\Delta \\theta = \\frac{\\pi}{360} \\, \\mathrm{rad}$，$\\Delta \\phi = \\frac{\\pi}{360} \\, \\mathrm{rad}$。\n- 局部速度：$v(r_i) = 8.0 + 2.0 \\times 10^{-4}\\,(6000 - 3480) = 8.0 + 2.0 \\times 10^{-4}\\,(2520) = 8.0 + 0.504 = 8.504 \\, \\mathrm{km/s}$。\n- 局部慢度：$s_i = \\frac{1}{v(r_i)} = \\frac{1}{8.504} \\, \\mathrm{s/km}$。\n- 已接受的邻近点走时：$T_{i-1,j,k} = 125.0\\,\\mathrm{s}$，$T_{i+1,j,k} = 130.0\\,\\mathrm{s}$，$T_{i,j-1,k} = 131.5\\,\\mathrm{s}$，$T_{i,j+1,k} = 135.0\\,\\mathrm{s}$，$T_{i,j,k-1} = 129.6\\,\\mathrm{s}$，$T_{i,j,k+1} = 132.8\\,\\mathrm{s}$。\n\n接下来，我们找到每个方向的最小迎风走时：\n- $t_r = \\min\\{125.0, 130.0\\} = 125.0 \\, \\mathrm{s}$。\n- $t_\\theta = \\min\\{131.5, 135.0\\} = 131.5 \\, \\mathrm{s}$。\n- $t_\\phi = \\min\\{129.6, 132.8\\} = 129.6 \\, \\mathrm{s}$。\n\n现在，我们应用迭代的FMM更新过程。\n1. 对邻近点走时排序：$t_r = 125.0  t_\\phi = 129.6  t_\\theta = 131.5$。要考虑的维度顺序是径向（$r$）、然后是经向（$\\phi$）、然后是纬向（$\\theta$）。\n\n2. 仅使用 $r$ 方向计算一维更新 $T_{up}$。系数为 $a = \\frac{1}{\\Delta r^2} = \\frac{1}{20^2} = \\frac{1}{400}$。\n更新方程为 $T_{up} = t_r + s_i / \\sqrt{a} = t_r + s_i \\Delta r$。\n$$T_{up} = 125.0 + \\frac{1}{8.504} \\times 20 \\approx 125.0 + 2.351834666 = 127.351834666 \\, \\mathrm{s}$$\n\n3. 执行因果性检查。下一个最快的邻近点走时是 $t_\\phi = 129.6 \\, \\mathrm{s}$。\n我们检查是否 $T_{up} > t_\\phi$：\n$127.35183...$ 不大于 $129.6$。\n条件不满足。这表示一个纯粹从径向传播的波前将会在 $127.35183... \\, \\mathrm{s}$ 到达，这早于任何来自 $\\phi$ 或 $\\theta$ 方向的影响可能到达的时间（分别为 $129.6 \\, \\mathrm{s}$ 和 $131.5 \\, \\mathrm{s}$）。因此，一维更新是该节点的正确且最终的更新。\n\n计算出的走时为 $T_{i,j,k} \\approx 127.35183 \\, \\mathrm{s}$。\n按要求四舍五入到五位有效数字，我们得到 $127.35 \\, \\mathrm{s}$。", "answer": "$$\\boxed{127.35}$$", "id": "3591135"}, {"introduction": "标准的有限差分方法在处理奇点（例如走时梯度未定义的点源）时会遇到困难，从而导致显著的数值误差。这项高级练习介绍了一种强大的技术——加性分解程函方程法，它通过将解分解为一个解析的奇异部分 $T_0(\\mathbf{x})$ 和一个光滑的数值校正项 $\\tau(\\mathbf{x})$ 来缓解这个问题。通过实现并比较快速行进法（FMM）和快速扫描法（FSM）的标准版本与分解版本，你将定量地评估该方法如何提高解的精度。", "problem": "您的任务是实现并比较两种用于求解二维空间中各向同性程函方程的一阶数值方法，以及它们用于减少点源奇异性的加性分解变体。这些方法是快速行进法 (FMM) 和快速扫描法 (FSM)。您的程序必须是一个完整、可运行的 Python 脚本，用于在存在闭式解的均匀介质中计算定量的误差减小度量。\n\n基本原理：\n- 在波速为 $c(\\mathbf{x})$ 的介质中，走时 $T(\\mathbf{x})$ 的各向同性程函方程为\n$$ \\|\\nabla T(\\mathbf{x})\\| = \\frac{1}{c(\\mathbf{x})}, \\quad \\mathbf{x} \\in \\Omega \\subset \\mathbb{R}^2, $$\n服从源点位置 $\\mathbf{x}_s$ 处的点源边界条件 $T(\\mathbf{x}_s) = 0$。\n- 对于波速恒为 $c_0$ 的均匀介质，其精确点源解为\n$$ T_0(\\mathbf{x}) = \\frac{\\|\\mathbf{x} - \\mathbf{x}_s\\|}{c_0}. $$\n\n离散化基础：\n- 在两个空间方向上使用间距为 $h$ (单位：米) 的均匀笛卡尔网格。设网格大小为 $N \\times N$，索引为 $i,j \\in \\{0,\\dots,N-1\\}$。源点位于与物理坐标 $\\mathbf{x}_s$ 对应的中心网格点 $(i_s, j_s)$。\n- 对各向同性程函方程应用标准的迎风 Godunov 离散格式。对于网格节点 $(i,j)$，使用 $x$ 方向的最小值 $a = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $y$ 方向的最小值 $b = \\min(T_{i,j-1}, T_{i,j+1})$， $T_{i,j}$ 的局部更新值 $t^\\star$ 满足以下二次条件\n$$ \\left( \\max\\left( \\frac{t^\\star - a}{h}, 0 \\right) \\right)^2 + \\left( \\max\\left( \\frac{t^\\star - b}{h}, 0 \\right) \\right)^2 = \\left(\\frac{1}{c_{i,j}}\\right)^2, $$\n其中 $c_{i,j} = c_0$。采用与迎风因果关系一致的最小可接受非负解。\n- 在加性分解形式中，写作 $T(\\mathbf{x}) = T_0(\\mathbf{x}) + \\tau(\\mathbf{x})$，其中 $T_0(\\mathbf{x})$ 是如上所述的精确均匀介质解，而 $\\tau(\\mathbf{x})$ 满足\n$$ \\|\\nabla \\tau(\\mathbf{x}) + \\nabla T_0(\\mathbf{x})\\| = \\frac{1}{c(\\mathbf{x})}. $$\n使用相同的 Godunov 离散化原理，但现在应用于 $\\tau$，在网格节点 $(i,j)$ 处，$\\tau_{i,j}$ 的局部更新使用平移后的邻居量\n$$ a_\\tau = \\min\\left( \\tau_{i-1,j} + T_{0,i-1,j} - T_{0,i,j}, \\ \\tau_{i+1,j} + T_{0,i+1,j} - T_{0,i,j} \\right), $$\n$$ b_\\tau = \\min\\left( \\tau_{i,j-1} + T_{0,i,j-1} - T_{0,i,j}, \\ \\tau_{i,j+1} + T_{0,i,j+1} - T_{0,i,j} \\right), $$\n并且使用与未分解情况相同的二次条件，但用 $a_\\tau$ 和 $b_\\tau$ 替换 $a$ 和 $b$。这通过精确地考虑 $T_0$ 的离散增量来实现加性分解。\n\n算法基础：\n- 快速行进法 (FMM) 是一种类似于 Dijkstra 算法的标签设置法，它对“尝试”节点使用最小堆（优先队列），这些节点按其当前的 $T$ 值排序。节点根据最小的 $T$ 值从“未知”状态转换到“尝试”状态，再到“接受”状态。每当一个节点被接受时，它的近邻节点会使用上述局部二次公式进行更新。对于加性分解 FMM，您必须维护 $\\tau$ 值，并使用平移后的邻居量计算总走时 $T = \\tau + T_0$ 的更新值，但堆的排序和接受测试始终基于总走时 $T$。\n- 快速扫描法 (FSM) 是一种高斯-赛德尔不动点迭代法，它以四种交替的扫描顺序（例如，四个对角线方向的字典序）遍历网格。在每个网格节点（固定的源点除外），FSM 使用当前邻居的值应用局部二次更新。对于加性分解 FSM，$\\tau$ 使用如上所述的平移邻居量进行更新，并导出总走时 $T = \\tau + T_0$ 用于评估误差。\n\n科学真实性与单位：\n- 使用恒定波速 $c_0 = 2000$ m/s。\n- 在 $x$ 和 $y$ 方向上使用网格间距 $h = 10$ m。\n- 区域为边长 $L = h (N-1)$ m 的正方形，源点位于几何中心。\n- 所有走时输出和误差必须以秒为单位表示。\n\n任务：\n1. 在均匀介质的二维网格上，为程函方程实现标准 FMM（未分解）和加性分解 FMM。\n2. 为同一问题实现标准 FSM（未分解）和加性分解 FSM。\n3. 对于每个计算出的走时场 $T_{ij}$，计算其相对于精确均匀介质解 $T_0(\\mathbf{x}_{ij})$ 的均方根误差 (RMSE)：\n$$ \\mathrm{RMSE} = \\sqrt{ \\frac{1}{N^2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( T_{ij} - T_0(\\mathbf{x}_{ij}) \\right)^2 }. $$\nRMSE 必须以秒为单位报告。\n\n测试套件和输出规范：\n- 测试套件包含四种情况，用于探究不同方法类型和网格分辨率下的性能：\n  - 情况 1：快速行进法，粗网格 $N=21$。\n  - 情况 2：快速行进法，细网格 $N=101$。\n  - 情况 3：快速扫描法，粗网格 $N=21$。\n  - 情况 4：快速扫描法，细网格 $N=101$。\n- 对于每种情况，计算标准求解器的 RMSE（$\\mathrm{RMSE}_\\mathrm{std}$）和加性分解求解器的 RMSE（$\\mathrm{RMSE}_\\mathrm{fact}$），然后计算误差减小因子\n$$ R = \\frac{\\mathrm{RMSE}_\\mathrm{std}}{\\max(\\mathrm{RMSE}_\\mathrm{fact}, 10^{-12})}. $$\n较大的 $R$ 值表示加性分解方法对奇异性引起的误差有更显著的减小效果。\n- 最终输出格式：您的程序应生成单行输出，其中包含四个情况下对应的四个减小因子，以逗号分隔列表的形式用方括号括起来，并严格按照 [情况1, 情况2, 情况3, 情况4] 的顺序排列。例如：\"[r1,r2,r3,r4]\"。", "solution": "该问题要求实现并比较两种用于求解二维各向同性程函方程的一阶数值方法：快速行进法 (FMM) 和快速扫描法 (FSM)。对于每种方法，我们必须实现一个标准版本和一个旨在提高点源附近精度的加性分解版本。比较的依据是在均匀介质中（其中已知精确解析解）均方根误差 (RMSE) 的减小程度。\n\n首先，我们建立数学和数值框架。各向同性程函方程是一个描述波前走时 $T(\\mathbf{x})$ 的非线性偏微分方程：\n$$ \\|\\nabla T(\\mathbf{x})\\| = \\frac{1}{c(\\mathbf{x})} $$\n此处，$\\mathbf{x}$ 是域 $\\Omega \\subset \\mathbb{R}^2$ 中的一个点，$c(\\mathbf{x})$ 是波速。给定源点位置 $\\mathbf{x}_s$ 处的点源条件 $T(\\mathbf{x}_s) = 0$。对于波速恒为 $c(\\mathbf{x}) = c_0$ 的均匀介质这一特定情况，其精确解是到源点的距离乘以慢度 ($1/c_0$)：\n$$ T_0(\\mathbf{x}) = \\frac{\\|\\mathbf{x} - \\mathbf{x}_s\\|}{c_0} $$\n该解在 $\\mathbf{x}_s$ 处有一个锥形奇异点，其梯度在该点未定义。这种奇异性对标准数值格式构成了挑战。\n\n该域被离散化为一个大小为 $N \\times N$、网格间距为 $h$ 的均匀笛卡尔网格。网格节点由 $(i,j)$ 索引。标准的一阶 Godunov 迎风有限差分格式用于近似梯度的大小。为了更新网格节点 $(i,j)$ 处的走时 $T_{i,j}$，我们定义邻居值 $a = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $b = \\min(T_{i,j-1}, T_{i,j+1})$。更新后的时间 $t^\\star$ 是以下二次方程的最小非负解：\n$$ \\left( \\max\\left( \\frac{t^\\star - a}{h}, 0 \\right) \\right)^2 + \\left( \\max\\left( \\frac{t^\\star - b}{h}, 0 \\right) \\right)^2 = s_{i,j}^2 $$\n其中 $s_{i,j} = 1/c_{i,j}$ 是慢度。对于恒定慢度 $s_0 = 1/c_0$，解 $t^\\star$ 由下式给出：\n$$ t^\\star = \\begin{cases} \\min(a, b) + h s_0   \\text{if } |a-b| \\ge h s_0 \\\\ \\frac{a+b + \\sqrt{2(h s_0)^2 - (a-b)^2}}{2}   \\text{if } |a-b|  h s_0 \\end{cases} $$\n这个更新规则是因果的，只使用走时较小方向（即迎风向）的信息。\n\n加性分解法旨在减轻源点奇异性带来的误差。它通过将总走时 $T(\\mathbf{x})$ 写成已知奇异解 $T_0(\\mathbf{x})$ 和一个修正项 $\\tau(\\mathbf{x})$ 的和来重构问题：$T(\\mathbf{x}) = T_0(\\mathbf{x}) + \\tau(\\mathbf{x})$。将此代入程函方程，得到一个关于 $\\tau(\\mathbf{x})$ 的方程：\n$$ \\|\\nabla \\tau(\\mathbf{x}) + \\nabla T_0(\\mathbf{x})\\| = s(\\mathbf{x}) $$\n在离散层面上，这通过应用相同的 Godunov 更新逻辑来处理，但对象是 $\\tau_{i,j}$ 而不是 $T_{i,j}$。邻居值被修改以包含已知的解析解 $T_0$。平移后的邻居值为：\n$$ a_\\tau = \\min\\left( \\tau_{i-1,j} + T_{0,i-1,j} - T_{0,i,j}, \\ \\tau_{i+1,j} + T_{0,i+1,j} - T_{0,i,j} \\right) $$\n$$ b_\\tau = \\min\\left( \\tau_{i,j-1} + T_{0,i,j-1} - T_{0,i,j}, \\ \\tau_{i,j+1} + T_{0,i,j+1} - T_{0,i,j} \\right) $$\n然后，使用以 $a_\\tau$ 和 $b_\\tau$ 为输入的相同二次更新公式计算新的 $\\tau_{i,j}$。由于 $\\tau(\\mathbf{x})$ 在源点附近通常比 $T(\\mathbf{x})$ 平滑得多，该方法能够产生更精确的数值解。\n\n求解所得方程组的两种算法是：\n\n$1$. **快速行进法 (FMM)**：这是一种标签设置算法，类似于 Dijkstra 算法。网格节点被分为三类：`ACCEPTED`（已确定时间的）、`TRIAL`（具有临时时间值的）和 `UNKNOWN`（未知的）。该算法维护一个 `TRIAL` 节点的最小优先队列，按其走时排序。在每一步中，具有最小走时的 `TRIAL` 节点被移至 `ACCEPTED` 集合。然后，其非 `ACCEPTED` 的邻居节点使用 Godunov 格式进行更新，其状态被设置为 `TRIAL`，并被添加或更新到优先队列中。该过程从源节点开始，向外行进。对于分解 FMM，优先队列按总时间 $T = \\tau + T_0$ 排序，但更新是针对 $\\tau$ 计算的。\n\n$2$. **快速扫描法 (FSM)**：这是一种基于高斯-赛德尔迭代的迭代法。它以不同方向反复扫描整个网格。问题指定了四种交替的扫描方向（例如，按 $i$ 和 $j$ 索引的递增/递减顺序）。在每次扫描中，除了固定的源点外，每个网格点都使用其邻居的最新值，通过 Godunov 格式进行更新。这个迭代过程会持续固定的迭代次数或直到收敛。多种扫描方向确保了特征线（信息流）在整个域内正确传播。对于分解 FSM，扫描更新的是 $\\tau$ 场而不是 $T$ 场。\n\n实现将按以下步骤进行：\n- 设置网格参数：$N \\in \\{21, 101\\}$，$h = 10$ m，$c_0 = 2000$ m/s。源点位于中心网格点。\n- 在网格上预计算精确解 $T_0$。\n- 为 Godunov 更新规则实现一个函数。\n- 实现 FMM（标准版和分解版）。FMM 将使用 Python 的 `heapq` 模块实现优先队列。\n- 实现 FSM（标准版和分解版）。FSM 将执行 $20$ 次迭代，每次迭代包括四次扫描。\n- 对于指定的四个测试用例（粗/细网格上的 FMM，粗/细网格上的 FSM），计算走时场 $T_{\\text{std}}$ 和 $T_{\\text{fact}} = \\tau_{\\text{fact}} + T_0$。\n- 计算相对于精确解 $T_0$ 的均方根误差 $\\mathrm{RMSE}_\\mathrm{std}$ 和 $\\mathrm{RMSE}_\\mathrm{fact}$。\n- 计算误差减小因子 $R = \\mathrm{RMSE}_\\mathrm{std} / \\max(\\mathrm{RMSE}_\\mathrm{fact}, 10^{-12})$。\n- 最终输出将是四个计算出的 $R$ 值的列表。", "answer": "```python\nimport numpy as np\nimport heapq\n\n# Per the problem context, scipy is available but not strictly necessary for this implementation.\n# The core algorithms are implemented from scratch using numpy and the standard library.\n\ndef solve_eikonal_update(a, b, h, c_val):\n    \"\"\"\n    Solves the Godunov update for the Eikonal equation.\n    \n    Args:\n        a (float): Minimum travel time from x-neighbors.\n        b (float): Minimum travel time from y-neighbors.\n        h (float): Grid spacing.\n        c_val (float): Wave speed.\n\n    Returns:\n        float: Updated travel time.\n    \"\"\"\n    a, b = float(a), float(b)\n    \n    if np.isinf(a) and np.isinf(b):\n        return np.inf\n\n    h_over_c = h / c_val\n\n    if np.isinf(a) or np.isinf(b):\n        return min(a, b) + h_over_c\n\n    if abs(a - b) >= h_over_c:\n        return min(a, b) + h_over_c\n    else:\n        discriminant = 2 * h_over_c**2 - (a - b)**2\n        # Discriminant should be non-negative due to the check above,\n        # but floating point issues might make it slightly negative.\n        if discriminant  0:\n            return min(a,b) + h_over_c\n        return (a + b + np.sqrt(discriminant)) / 2.0\n\n\ndef fast_marching_method(N, h, c0, isrc, jsrc, factored, T0):\n    \"\"\"\n    Implements the Fast Marching Method for the Eikonal equation.\n    \"\"\"\n    if factored:\n        values = np.full((N, N), np.inf)  # This will store tau\n        values[isrc, jsrc] = 0.0\n    else:\n        values = np.full((N, N), np.inf)  # This will store T\n        values[isrc, jsrc] = 0.0\n\n    states = np.zeros((N, N), dtype=int)  # 0: UNKNOWN, 1: TRIAL, 2: ACCEPTED\n    heap = []\n\n    # Initializing the source\n    T_val = T0[isrc, jsrc] if factored else 0.0\n    heapq.heappush(heap, (T_val, (isrc, jsrc)))\n    states[isrc, jsrc] = 1\n\n    while heap:\n        t_total, (i, j) = heapq.heappop(heap)\n\n        if states[i, j] == 2:\n            continue\n        \n        current_T_val = (values[i, j] + T0[i, j]) if factored else values[i, j]\n        if t_total > current_T_val:\n            continue\n\n        states[i, j] = 2  # Accept the node\n\n        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            ni, nj = i + di, j + dj\n\n            if not (0 = ni  N and 0 = nj  N and states[ni, nj] != 2):\n                continue\n            \n            if not factored:\n                a = min(values[ni-1, nj] if ni > 0 else np.inf, values[ni+1, nj] if ni  N-1 else np.inf)\n                b = min(values[ni, nj-1] if nj > 0 else np.inf, values[ni, nj+1] if nj  N-1 else np.inf)\n\n                if np.isinf(a) and np.isinf(b): continue\n                \n                t_new = solve_eikonal_update(a, b, h, c0)\n\n                if t_new  values[ni, nj]:\n                    values[ni, nj] = t_new\n                    states[ni, nj] = 1\n                    heapq.heappush(heap, (t_new, (ni, nj)))\n            else: # Factored\n                val_x1 = (values[ni-1, nj] + T0[ni-1, nj] - T0[ni, nj]) if ni > 0 else np.inf\n                val_x2 = (values[ni+1, nj] + T0[ni+1, nj] - T0[ni, nj]) if ni  N-1 else np.inf\n                a_tau = min(val_x1, val_x2)\n\n                val_y1 = (values[ni, nj-1] + T0[ni, nj-1] - T0[ni, nj]) if nj > 0 else np.inf\n                val_y2 = (values[ni, nj+1] + T0[ni, nj+1] - T0[ni, nj]) if nj  N-1 else np.inf\n                b_tau = min(val_y1, val_y2)\n\n                if np.isinf(a_tau) and np.isinf(b_tau): continue\n                \n                tau_new = solve_eikonal_update(a_tau, b_tau, h, c0)\n\n                if tau_new  values[ni, nj]:\n                    values[ni, nj] = tau_new\n                    T_new = tau_new + T0[ni, nj]\n                    states[ni, nj] = 1\n                    heapq.heappush(heap, (T_new, (ni, nj)))\n\n    return values\n\n\ndef fast_sweeping_method(N, h, c0, isrc, jsrc, factored, T0, num_iter=20):\n    \"\"\"\n    Implements the Fast Sweeping Method for the Eikonal equation.\n    \"\"\"\n    if factored:\n        values = np.full((N, N), np.inf)  # tau\n        values[isrc, jsrc] = 0.0\n    else:\n        values = np.full((N, N), np.inf)  # T\n        values[isrc, jsrc] = 0.0\n\n    sweep_ranges = [\n        (range(N), range(N)),\n        (range(N - 1, -1, -1), range(N)),\n        (range(N - 1, -1, -1), range(N - 1, -1, -1)),\n        (range(N), range(N - 1, -1, -1))\n    ]\n\n    for _ in range(num_iter):\n        for i_range, j_range in sweep_ranges:\n            for i in i_range:\n                for j in j_range:\n                    if (i, j) == (isrc, jsrc):\n                        continue\n                    \n                    if not factored:\n                        a = min(values[i-1,j] if i > 0 else np.inf, values[i+1,j] if i  N-1 else np.inf)\n                        b = min(values[i,j-1] if j > 0 else np.inf, values[i,j+1] if j  N-1 else np.inf)\n                        \n                        t_new = solve_eikonal_update(a, b, h, c0)\n                        if t_new  values[i, j]:\n                            values[i, j] = t_new\n                    else: # Factored\n                        val_x1 = (values[i-1, j] + T0[i-1, j] - T0[i, j]) if i > 0 else np.inf\n                        val_x2 = (values[i+1, j] + T0[i+1, j] - T0[i, j]) if i  N-1 else np.inf\n                        a_tau = min(val_x1, val_x2)\n\n                        val_y1 = (values[i, j-1] + T0[i, j-1] - T0[i, j]) if j > 0 else np.inf\n                        val_y2 = (values[i, j+1] + T0[i, j+1] - T0[i, j]) if j  N-1 else np.inf\n                        b_tau = min(val_y1, val_y2)\n\n                        tau_new = solve_eikonal_update(a_tau, b_tau, h, c0)\n                        if tau_new  values[i, j]:\n                            values[i, j] = tau_new\n                            \n    return values\n\n\ndef main():\n    c0 = 2000.0\n    h = 10.0\n    test_cases = [\n        {'method': 'fmm', 'N': 21},\n        {'method': 'fmm', 'N': 101},\n        {'method': 'fsm', 'N': 21},\n        {'method': 'fsm', 'N': 101}\n    ]\n    \n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        method = case['method']\n\n        isrc, jsrc = (N - 1) // 2, (N - 1) // 2\n        xs, ys = h * isrc, h * jsrc\n\n        # Pre-compute analytical solution T0\n        x = np.arange(N) * h\n        y = np.arange(N) * h\n        xx, yy = np.meshgrid(x, y, indexing='ij')\n        T0 = np.sqrt((xx - xs)**2 + (yy - ys)**2) / c0\n\n        # Run standard solver\n        if method == 'fmm':\n            T_std_raw = fast_marching_method(N, h, c0, isrc, jsrc, False, T0)\n        else: # fsm\n            T_std_raw = fast_sweeping_method(N, h, c0, isrc, jsrc, False, T0)\n        \n        # Run factored solver\n        if method == 'fmm':\n            tau_fact_raw = fast_marching_method(N, h, c0, isrc, jsrc, True, T0)\n        else: # fsm\n            tau_fact_raw = fast_sweeping_method(N, h, c0, isrc, jsrc, True, T0)\n\n        # Reconstruct T for factored method\n        T_fact = tau_fact_raw + T0\n\n        # Calculate RMSE\n        rmse_std = np.sqrt(np.mean((T_std_raw - T0)**2))\n        rmse_fact = np.sqrt(np.mean((T_fact - T0)**2))\n\n        # Calculate reduction factor\n        reduction_factor = rmse_std / max(rmse_fact, 1e-12)\n        results.append(reduction_factor)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nif __name__ == '__main__':\n    main()\n```", "id": "3591136"}]}