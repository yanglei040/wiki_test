{"hands_on_practices": [{"introduction": "在地震学中，求解程函方程 $|\\nabla T| = s(\\mathbf{x})$ 是计算地震波走时的基础。本练习将介绍并比较两种广泛应用的网格化算法：基于图论的最短路径迪科斯彻（Dijkstra）算法和作为偏微分方程求解器的快速行进算法（Fast Marching Method）。通过在一个均匀介质中实现这两种方法，你将能量化它们各自引入的数值各向异性——这是一个关键的数值伪影，理解它对于评估这些强大工具的精度和局限性至关重要。[@problem_id:3614039]", "problem": "给定一个大小为 $N \\times N$ 的二维笛卡尔网格，其空间步长为 $h$（单位：米），慢度场均匀，为 $s(\\mathbf{x}) \\equiv s_0$（单位：秒/米）。点源位于网格中心。在平滑变化的各向同性介质中，地震射线的首波走时场 $T(\\mathbf{x})$ 由程函方程 $|\\nabla T(\\mathbf{x})| = s(\\mathbf{x})$ 控制。在计算地球物理学中，两种广泛使用的数值方法是：\n\n1. 基于图的最短路径方法，在网格图上使用 Dijkstra 算法，其中边连接网格邻居，每条边的成本等于慢度沿该边的路径积分。\n2. 快速行进法（FMM），这是一种用于求解程函方程的单调、迎风有限差分解法器。\n\n您的任务是针对均匀慢度场 $s(\\mathbf{x}) = s_0$ 实现这两种方法，并量化每种数值模板引入的方向偏差。从基本原理出发：费马原理指出，地震射线遵循走时平稳的路径，而程函方程是波动方程的高频极限。在网格上，Dijkstra 算法最小化边成本的离散和，而 FMM 则通过耦合正交方向的局部更新来强制执行程函关系的迎风离散化。您必须：\n\n- 在 4-邻域网格图（边仅沿笛卡尔坐标轴）上实现 Dijkstra 算法，边成本等于慢度与几何边长的乘积。使用中心点作为源点，其 $T=0$。\n- 在同一网格上实现快速行进法（FMM），对各向同性程函方程使用一阶、单调的迎风离散化，通过按 $T$ 值递增的顺序接受节点来确保因果性。\n\n定义各向异性指数 $\\mathcal{A}$，方法为：在一个给定的物理半径 $r$（单位：米）处，在 $[0, 2\\pi)$ 上均匀采样方向 $\\theta_k$（单位：弧度），将每个方向映射到目标半径处最近的网格节点，并计算视慢度 $s_{\\mathrm{app}}(\\theta_k) = T_{\\mathrm{num}}(\\theta_k)/d(\\theta_k)$，其中 $d(\\theta_k)$ 是从源点到采样网格节点的欧几里得距离（单位：米）。各向异性指数为\n$$\n\\mathcal{A} = \\frac{\\max_k s_{\\mathrm{app}}(\\theta_k)}{\\min_k s_{\\mathrm{app}}(\\theta_k)} - 1,\n$$\n该值为无量纲。这个量捕捉了方向偏差：对于均匀介质中的完美各向同性离散化，$s_{\\mathrm{app}}(\\theta)$ 将是一个常数，且 $\\mathcal{A}$ 将为 $0$。\n\n角度单位必须是弧度。走时必须以秒为单位计算。距离必须以米为单位计算。您必须将报告的每个各向异性指数四舍五入到六位小数。\n\n测试套件：\n- 情况 1 (正常路径): $N=101$, $h=10$ 米, $s_0 = 0.0005$ 秒/米, $r=200$ 米, $K=36$ 个角度。\n- 情况 2 (近源边界条件): $N=101$, $h=10$ 米, $s_0 = 0.0005$ 秒/米, $r=10$ 米, $K=36$ 个角度。\n- 情况 3 (更大区域，更大半径): $N=201$, $h=10$ 米, $s_0 = 0.0005$ 秒/米, $r=700$ 米, $K=72$ 个角度。\n\n对于每种情况，计算两个数值：Dijkstra 4-邻域方法的各向异性指数和快速行进法的各向异性指数。最终输出为包含三个情况结果的单行逗号分隔列表，其中每个情况的结果本身就是一个双元素列表，顺序为 $[\\mathcal{A}_{\\text{Dijkstra}},\\mathcal{A}_{\\text{FMM}}]$。确切的输出格式必须是\n$$\n\\texttt{[[a\\_11,a\\_12],[a\\_21,a\\_22],[a\\_31,a\\_32]]}\n$$\n不含空格，且每个 $a\\_{ij}$ 都四舍五入到六位小数。", "solution": "用户希望量化在网格上求解程函方程的两种常用方法所产生的数值各向异性：Dijkstra 算法和快速行进法（FMM）。\n\n### 基于原理的设计\n\n此问题处于波传播物理学和数值分析的交叉领域。其核心原理是，程函方程 $|\\nabla T| = s$ 描述了波前在慢度为 $s$ 的介质中传播的走时 $T$。在均匀介质（$s(\\mathbf{x}) = s_0$）中，点源解为 $T(\\mathbf{x}) = s_0 d(\\mathbf{x}, \\mathbf{x}_{\\text{source}})$，其中 $d$ 是欧几里得距离。走时等值线（等时线）是标准圆形。\n\n在笛卡尔网格上应用的数值方法不可避免地会引入误差，这些误差依赖于传播方向相对于网格轴线的关系。这种方向依赖性被称为数值各向异性。我们的任务是实现两种标准算法并测量这种效应。\n\n#### 1. 在 4-邻域图上应用 Dijkstra 算法\n\n**基本原理**：Dijkstra 算法在具有非负边权重的图中找到从源点到所有其他节点的最短路径。通过将网格建模为一个图（其中节点是网格点，边连接邻居），我们可以近似计算走时。在这里，平稳时间原理（费马原理）被离散路径最小化所取代。\n\n**算法设计**：\n-   **图表示**：$N \\times N$ 的网格点是图的顶点。边将每个点 $(i, j)$ 与其四个基本方向的邻居连接起来：$(i\\pm1, j)$ 和 $(i, j\\pm1)$。\n-   **边成本**：沿一条边的走时是慢度 $s_0$ 和路径长度的乘积。由于相邻网格点之间的距离是网格间距 $h$，因此每条边的成本是均匀的：$w = s_0 h$。\n-   **实现**：标准的 Dijkstra 算法实现使用一个最小优先队列，以走时递增的顺序高效地探索节点。\n    1.  初始化一个大小为 $N \\times N$ 的走时数组 $T$，所有值均为无穷大，并在源节点处设置 $T=0$。\n    2.  将源节点 `(time=0, index)` 添加到优先队列中。\n    3.  当队列不为空时，提取时间最小的节点。\n    4.  如果此节点已被最终确定，则跳过。否则，将其标记为最终确定。\n    5.  对于其四个邻居中的每一个，计算潜在的新走时。如果此时间小于邻居当前记录的时间，则更新 $T$ 数组中邻居的时间，并将其添加到优先队列中。\n\n**预期各向异性**：该方法将路径限制在网格线上。两点之间的最短路径是一条“曼哈顿”路径。相对于源点，点 $(i, j)$ 的走时为 $T_{\\text{Dijkstra}} = s_0 h (|i| + |j|)$。视慢度为 $s_{\\text{app}} = T / d = s_0 h (|i|+|j|) / (h\\sqrt{i^2+j^2}) = s_0 (|i|+|j|)/\\sqrt{i^2+j^2}$。这个值在网格轴线方向上最小（为 $s_0$），在网格对角线方向上最大（为 $\\sqrt{2} s_0$），导致的理论各向异性指数为 $\\mathcal{A}_{\\text{Dijkstra}} = \\sqrt{2} - 1 \\approx 0.414$。\n\n#### 2. 一阶快速行进法（FMM）\n\n**基本原理**：FMM 是一种更复杂的基于网格的方法，它直接求解程函方程的有限差分近似。它通过从源点向外传播解来尊重因果性，这与波的传播方式类似。与 Dijkstra 算法一样，它也使用优先队列来选择下一个要最终确定的节点。\n\n**算法设计**：\n-   **离散化**：梯度算子 $\\nabla T$ 使用迎风有限差分进行近似。对于各向同性程函方程 $|\\nabla T|^2 = s_0^2$，在一个网格点 $(i,j)$ 处的一阶格式为：\n    $$ \\left( \\frac{T_{i,j} - T_x}{h} \\right)^2 + \\left( \\frac{T_{i,j} - T_y}{h} \\right)^2 = s_0^2 $$\n    此处，$T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ 是已计算邻居节点的走时。\n-   **更新规则**：为计算新节点的时间 $T_{i,j}$，我们求解上述二次方程。设 $a$ 和 $b$ 分别是 x 和 y 方向上迎风邻居的已知走时。方程为 $(T-a)^2 + (T-b)^2 = (s_0 h)^2$。为确保因果性（$T > a$ 和 $T > b$），我们必须取较大的根：\n    $$ T = \\frac{a+b + \\sqrt{2(s_0 h)^2 - (a-b)^2}}{2} $$\n    该公式仅在平方根下的项为非负时有效。如果为负，则意味着特征方向与其中一个坐标轴对齐，更新简化为一维传播：$T = \\min(a,b) + s_0 h$。\n-   **实现**：总体结构与 Dijkstra 算法相似。节点分为三类：KNOWN（已确定时间的）、TRIAL（在优先队列中的）和 FAR（未访问的）。算法系统地将节点从 TRIAL 移动到 KNOWN，并更新它们的 FAR 邻居，将其变为 TRIAL 节点。\n\n**预期各向异性**：该方法在其更新规则中耦合了空间维度，与 4-邻域 Dijkstra 算法相比，能产生更准确、更各向同性的波前。然而，作为一种一阶格式，它仍然表现出一些网格各向异性。分析表明，视慢度在坐标轴方向上最小（为 $s_0$），在对角线方向上最大，值为 $s_0(1/\\sqrt{2}+1/2)$。这导致的理论各向异性指数为 $\\mathcal{A}_{\\text{FMM}} = 1/\\sqrt{2} - 1/2 \\approx 0.207$。\n\n#### 3. 各向异性指数计算\n\n各向异性指数 $\\mathcal{A}$ 是方向误差的定量度量。\n$$\n\\mathcal{A} = \\frac{\\max_k s_{\\mathrm{app}}(\\theta_k)}{\\min_k s_{\\mathrm{app}}(\\theta_k)} - 1\n$$\n-   **步骤**：我们在以源点为中心、物理半径为 $r$ 的圆上采样 $K$ 个点。对于每个角度 $\\theta_k$，我们找到最近的网格节点。\n-   **视慢度**：对于每个采样的网格节点，我们计算视慢度 $s_{\\text{app}} = T_{\\text{num}} / d$，其中 $T_{\\text{num}}$ 是由数值方法计算出的走时，而 $d$ 是从源点到该特定网格节点的真实欧几里得距离。\n-   **解释**：在一个完全各向同性的模拟中，$s_{\\text{app}}$ 将是一个等于 $s_0$ 的常数，从而得出 $\\mathcal{A}=0$。一个非零的 $\\mathcal{A}$ 揭示了数值误差的方向依赖程度。\n\n实现将包含三个主要函数：一个用于 Dijkstra 算法，一个用于 FMM，以及一个用于从生成的走时场计算各向异性指数。将为每个测试用例调用这些函数以生成最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    # --- State Constants for FMM ---\n    _FAR = 0\n    _TRIAL = 1\n    _KNOWN = 2\n\n    def dijkstra_4n(N, h, s0):\n        \"\"\"\n        Computes first-arrival times using Dijkstra's algorithm on a 4-neighbor graph.\n        \"\"\"\n        center_idx = (N - 1) // 2\n        source = (center_idx, center_idx)\n\n        times = np.full((N, N), np.inf, dtype=np.float64)\n        times[source] = 0.0\n\n        pq = [(0.0, source[0], source[1])]\n        visited = np.zeros((N, N), dtype=bool)\n        edge_cost = s0 * h\n\n        while pq:\n            time, r, c = heapq.heappop(pq)\n\n            if visited[r, c]:\n                continue\n            \n            visited[r, c] = True\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n\n                if 0 = nr  N and 0 = nc  N:\n                    new_time = time + edge_cost\n                    if new_time  times[nr, nc]:\n                        times[nr, nc] = new_time\n                        heapq.heappush(pq, (new_time, nr, nc))\n        \n        return times\n\n    def fmm_1st_order(N, h, s0):\n        \"\"\"\n        Computes first-arrival times using the first-order Fast Marching Method.\n        \"\"\"\n        center_idx = (N - 1) // 2\n        source = (center_idx, center_idx)\n\n        times = np.full((N, N), np.inf, dtype=np.float64)\n        states = np.full((N, N), _FAR, dtype=np.int8)\n        \n        times[source] = 0.0\n        \n        pq = [(0.0, source[0], source[1])] # The 'TRIAL' set\n        states[source] = _TRIAL\n        \n        c_sq = (s0 * h)**2\n\n        while pq:\n            time, r, c = heapq.heappop(pq)\n            \n            if states[r, c] == _KNOWN:\n                continue\n            \n            states[r, c] = _KNOWN\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                \n                if not (0 = nr  N and 0 = nc  N) or states[nr, nc] == _KNOWN:\n                    continue\n\n                # Find minimum times of KNOWN neighbors in x and y directions\n                t_x_min = np.inf\n                if nr > 0 and states[nr - 1, nc] == _KNOWN:\n                    t_x_min = min(t_x_min, times[nr - 1, nc])\n                if nr  N - 1 and states[nr + 1, nc] == _KNOWN:\n                    t_x_min = min(t_x_min, times[nr + 1, nc])\n\n                t_y_min = np.inf\n                if nc > 0 and states[nr, nc - 1] == _KNOWN:\n                    t_y_min = min(t_y_min, times[nr, nc - 1])\n                if nc  N - 1 and states[nr, nc + 1] == _KNOWN:\n                    t_y_min = min(t_y_min, times[nr, nc + 1])\n                \n                # Solve for new time at (nr, nc)\n                new_time_cand = np.inf\n                has_x = t_x_min != np.inf\n                has_y = t_y_min != np.inf\n                \n                if has_x and has_y:\n                    diff_sq = (t_x_min - t_y_min)**2\n                    if c_sq * 2.0 >= diff_sq:\n                        term_sqrt = np.sqrt(c_sq * 2.0 - diff_sq)\n                        new_time_cand = (t_x_min + t_y_min + term_sqrt) / 2.0\n                    else:\n                        new_time_cand = min(t_x_min, t_y_min) + s0 * h\n                elif has_x:\n                    new_time_cand = t_x_min + s0 * h\n                elif has_y:\n                    new_time_cand = t_y_min + s0 * h\n                \n                if new_time_cand  times[nr, nc]:\n                    times[nr, nc] = new_time_cand\n                    heapq.heappush(pq, (new_time_cand, nr, nc))\n                    states[nr, nc] = _TRIAL\n                    \n        return times\n\n    def compute_anisotropy(times_field, N, h, r, K):\n        \"\"\"\n        Computes the anisotropy index for a given travel time field.\n        \"\"\"\n        center_idx = (N - 1) // 2\n        y_c = center_idx * h # physical y-coord of source (row)\n        x_c = center_idx * h # physical x-coord of source (col)\n        \n        thetas = np.linspace(0, 2 * np.pi, K, endpoint=False)\n        \n        s_app_list = []\n        \n        for theta in thetas:\n            # Target coordinates on the geometric circle\n            x_target = x_c + r * np.cos(theta)\n            y_target = y_c + r * np.sin(theta)\n            \n            # Find nearest grid node, mapping physical (x,y) to grid (j,i)\n            j_target = np.round(x_target / h).astype(int)\n            i_target = np.round(y_target / h).astype(int)\n            \n            # Clamp to grid bounds\n            i_target = max(0, min(N - 1, i_target))\n            j_target = max(0, min(N - 1, j_target))\n            \n            t_num = times_field[i_target, j_target]\n            \n            # Physical coordinates of the sampled node\n            x_node = j_target * h\n            y_node = i_target * h\n            \n            dist = np.sqrt((x_node - x_c)**2 + (y_node - y_c)**2)\n            \n            if dist > 1e-9:\n                s_app = t_num / dist\n                s_app_list.append(s_app)\n        \n        if not s_app_list or len(s_app_list)  2:\n            return 0.0\n            \n        min_s_app = np.min(s_app_list)\n        max_s_app = np.max(s_app_list)\n\n        if min_s_app  1e-9:\n            return np.inf\n\n        anisotropy = max_s_app / min_s_app - 1.0\n        return anisotropy\n\n    test_cases = [\n        # (N, h, s0, r, K)\n        (101, 10.0, 0.0005, 200.0, 36),\n        (101, 10.0, 0.0005, 10.0, 36),\n        (201, 10.0, 0.0005, 700.0, 72),\n    ]\n\n    results = []\n    for N, h, s0, r, K in test_cases:\n        # Dijkstra's method\n        times_dijkstra = dijkstra_4n(N, h, s0)\n        anisotropy_dijkstra = compute_anisotropy(times_dijkstra, N, h, r, K)\n        \n        # Fast Marching Method\n        times_fmm = fmm_1st_order(N, h, s0)\n        anisotropy_fmm = compute_anisotropy(times_fmm, N, h, r, K)\n        \n        results.append([anisotropy_dijkstra, anisotropy_fmm])\n\n    case_strings = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in results]\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3614039"}, {"introduction": "在利用快速行进算法计算出走时场后，下一步自然是提取相应的射线路径。本练习旨在通过在计算出的走时梯度场中追踪射线，来探索程函方程与其特征射线之间的内在联系。通过比较直接从走时场插值得到的走时与沿着射线路径积分慢度得到的走时，我们可以量化数值方法的自洽性，并深入了解其在焦散等复杂区域可能产生的误差。[@problem_id:3614052]", "problem": "设计并实现一个完整的程序，该程序针对具有空间变化的慢度的二维各向同性介质，通过比较在预设接收点位置上两个独立计算的量，来量化首至走时的数值误差：(i) 由偏微分方程 $|\\nabla T| = s(\\mathbf{x})$ 定义的程函走时场的插值解，以及 (ii) 沿数值追踪的射线（通过遵循走时场的局部梯度获得）对慢度进行的线积分。您的实现必须从计算地球物理学中地震射线追踪方法的基本原理出发，即费马原理（Fermat’s principle）和程函方程的哈密顿-雅可比（Hamilton–Jacobi）形式。除这些基础之外，不得假定任何快捷公式；所有算法步骤都必须由因果性和迎风一致性来证明其合理性。您必须解决以下要求。\n\n- 物理和数学设定：\n  - 考虑一个二维笛卡尔域 $\\Omega = \\{(x,z): 0 \\le x \\le 4 \\ \\text{km}, \\ 0 \\le z \\le 2 \\ \\text{km}\\}$，在 $x$ 和 $z$ 方向上均采用均匀网格间距 $h = 0.02 \\ \\text{km}$。\n  - 定义背景速度为 $v_0 = 3.0 \\ \\text{km/s}$，因此背景慢度为 $s_0 = 1/v_0 \\ \\text{s/km}$。\n  - 叠加一个中心位于 $(x_c,z_c) = (2.0 \\ \\text{km}, 1.0 \\ \\text{km})$ 的聚焦高斯慢透镜（慢度较高），其相对振幅为 $A = 0.5$，标准差为 $\\sigma = 0.3 \\ \\text{km}$，因此慢度场为\n    $$ s(x,z) = s_0 \\left( 1 + A \\exp\\!\\left( -\\frac{(x-x_c)^2 + (z-z_c)^2}{2 \\sigma^2} \\right) \\right) \\ \\text{s/km}. $$\n  - 在 $(x_s,z_s) = (0.2 \\ \\text{km}, 1.0 \\ \\text{km})$ 处放置一个点源。\n\n- 需实现的基础和算法任务：\n  - 根据费马原理，沿参数化路径 $\\gamma(\\ell)$（其弧长参数为 $\\ell$）累积的走时是泛函\n    $$ \\mathcal{T}[\\gamma] = \\int_{\\ell_0}^{\\ell_1} s(\\gamma(\\ell)) \\, d\\ell \\ \\text{s}. $$\n    首至走时场 $T(\\mathbf{x})$ 是哈密顿-雅可比程函方程的粘性解\n    $$ |\\nabla T(\\mathbf{x})| = s(\\mathbf{x}). $$\n  - 实现一个一阶、单调、迎风的快速行进法（Fast Marching Method），为给定的慢度 $s(x,z)$ 计算网格上的离散走时场 $T_h$，并遵循因果性。除了从迎风一致性和离散哈密顿-雅可比结构所隐含的局部二次求解中得出的结论外，不要假定任何闭式更新。在最接近 $(x_s,z_s)$ 的网格节点处将 $T_h$ 初始化为 $T = 0 \\ \\text{s}$。\n  - 实现从接收点位置 $\\mathbf{x}_r$ 到震源的射线反向追踪，方法是遵循计算出的 $T_h$ 的负归一化梯度（即特征曲线），使用弧长步长 $\\Delta \\ell$ 以及对离网格点的 $T_h$ 和 $s$ 进行双线性插值。需要积分的常微分方程是\n    $$ \\frac{d\\mathbf{x}}{d\\ell} = - \\frac{\\nabla T(\\mathbf{x})}{|\\nabla T(\\mathbf{x})|}, $$\n    当 $\\|\\mathbf{x} - \\mathbf{x}_s\\|$ 在一个网格间距内时终止。累积线积分\n    $$ \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) = \\int_0^{L(\\mathbf{x}_r)} s(\\mathbf{x}(\\ell)) \\, d\\ell \\ \\text{s}, $$\n    其中 $L(\\mathbf{x}_r)$ 是追踪到震源的路径长度。同时，通过在 $\\mathbf{x}_r$ 处对 $T_h$ 进行双线性插值，计算插值得到的程函时 $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$。\n  - 对于每个接收点，报告有符号失配\n    $$ \\Delta(\\mathbf{x}_r) = \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) - \\widehat{T}_{\\text{eik}}(\\mathbf{x}_r) \\ \\text{s}. $$\n\n- 单位与数值：\n  - 所有距离必须以公里为单位，所有走时以秒为单位，所有慢度值以秒/公里为单位。不需要角度。在积分射线时，使用恒定的弧长步长 $\\Delta \\ell = 0.005 \\ \\text{km}$，并在到 $(x_s,z_s)$ 的欧几里得距离小于 $0.02 \\ \\text{km}$ 或达到最大步数 $10000$ 步时终止，以先发生者为准。对离网格点的场样本使用双线性插值。\n\n- 测试套件：\n  - 使用以下接收点坐标（单位：公里）来检验正常传播、沿光轴的近焦散聚焦、离轴近焦散行为、穿过透镜以及远场边界情况：\n    - $\\mathbf{x}_{r,1} = (0.5, 1.0)$\n    - $\\mathbf{x}_{r,2} = (3.5, 1.0)$\n    - $\\mathbf{x}_{r,3} = (3.5, 0.8)$\n    - $\\mathbf{x}_{r,4} = (2.0, 1.0)$\n    - $\\mathbf{x}_{r,5} = (3.9, 1.0)$\n\n- 所需输出：\n  - 您的程序必须生成单行输出，其中包含上述接收点的有符号失配列表（单位：秒），顺序相同，格式化为小数点后六位的小数，并用方括号括起来、用逗号分隔（例如，$[0.000123,-0.000456,\\dots]$）。以秒为单位表示最终值，并保留符号。\n\n您的设计必须是完全自包含且确定性的，程序不得读取任何输入或需要任何外部文件或网络访问。程序必须根据上述描述从第一性原理实现数值方法，并按指定格式生成所需输出。", "solution": "该问题要求设计并实现一个数值实验，以量化地震走时计算中的自洽性误差。这是通过比较从同一底层数值构造中派生的两个量来完成的：(i) 在接收点位置通过插值程函方程的解获得的走时 $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$，以及 (ii) 通过沿着程函解场中追踪出的射线路径积分慢度场计算出的走时 $\\widehat{T}_{\\text{ray}}(\\mathbf{x}_r)$。整个过程基于费马原理（Fermat's principle），该原理指出，地震波在两点之间所走的路径是走时平稳的路径，对于首至波而言，是走时最小的路径。\n\n该原理的数学表述导出了哈密顿-雅可比程函方程（Hamilton-Jacobi eikonal equation），这是地球物理学中的一个基本偏微分方程：\n$$ |\\nabla T(\\mathbf{x})| = s(\\mathbf{x}) $$\n其中 $T(\\mathbf{x})$ 是从某个震源发出的首至走时场，$s(\\mathbf{x})$ 是介质在位置 $\\mathbf{x}$ 处的慢度（速度的倒数）。射线路径是该方程的特征线。\n\n求解过程分为两个主要阶段：首先，在网格上计算离散走时场 $T_h$；其次，利用该场追踪射线并积分走时。\n\n**1. 物理与计算域设置**\n\n问题设定在一个二维笛卡尔域 $\\Omega = \\{(x,z) \\mid 0 \\le x \\le 4 \\ \\text{km}, \\ 0 \\le z \\le 2 \\ \\text{km}\\}$ 中。该域被离散化为一个均匀网格，网格间距为 $h = 0.02 \\ \\text{km}$。这产生了一个 $N_x \\times N_z$ 的网格，其中 $N_x = 4/0.02 + 1 = 201$，$N_z = 2/0.02 + 1 = 101$。\n\n慢度场 $s(x,z)$ 由一个恒定的背景慢度 $s_0 = 1/v_0 = 1/3.0 \\ \\text{s/km}$ 和一个叠加的高斯异常定义：\n$$ s(x,z) = s_0 \\left( 1 + A \\exp\\!\\left( -\\frac{(x-x_c)^2 + (z-z_c)^2}{2 \\sigma^2} \\right) \\right) $$\n参数为 $A = 0.5$，$(x_c, z_c) = (2.0, 1.0) \\ \\text{km}$，以及 $\\sigma = 0.3 \\ \\text{km}$。该慢度函数在每个网格节点 $(x_i, z_j)$ 上求值，以创建一个离散慢度场 $s_{i,j}$。\n\n**2. 通过快速行进法 (FMM) 求解程函方程**\n\n离散走时场 $T_h$ 是使用一阶快速行进法（Fast Marching Method）计算的。FMM 是一种高效的基于网格的算法，它通过系统地推进波前并遵循因果性来求解程函方程。这类似于惠更斯原理（Huygens' principle）。该算法使用一个最小优先队列来确保网格点按走时递增的顺序进行处理。\n\n每个网格节点的状态分为以下三种类型之一：\n- `KNOWN` (已确定): 走时已最终确定。\n- `TRIAL` (试验): 存在一个走时估计值；该节点是待最终确定的候选节点。这些节点构成了窄带或波前。\n- `FAR` (远): 节点尚未被触及。\n\nFMM 算法流程如下：\n- **初始化**：将走时数组 $T_h$ 中所有节点的值初始化为无穷大。将最接近震源 $(x_s, z_s) = (0.2, 1.0) \\ \\text{km}$ 的网格节点 $(i_s, j_s)$ 的走时赋值为 $T_{i_s, j_s} = 0$。此节点被添加到一个最小优先队列中，其状态被设为 `TRIAL`。\n- **迭代**：算法的主循环反复从优先队列中提取具有最小走时的 `TRIAL` 节点。该节点的状态变为 `KNOWN`。然后，为其每个非 `KNOWN` 状态的邻居计算新的走时。\n- **迎风有限差分更新**：节点 $(i,j)$ 的走时根据其已确定 (`KNOWN`) 邻居的值进行更新。这种迎风格式承认信息是从震源向外传播的。设 $T_x$ 和 $T_z$ 分别是节点 $(i,j)$ 沿 $x$ 和 $z$ 轴的 `KNOWN` 邻居的最小走时。设 $s_{i,j}$ 是该节点的慢度。更新后的时间 $T'_{i,j}$ 由一个 Godunov 格式确定：\n  1. 如果只有一个迎风邻居可用（例如，$T_x$ 是有限的，$T_z$ 是无限的），或者如果波从一个方向到达的时间远早于另一个方向，则使用一维更新。这种情况发生在 $|\\min(T_x,T_z) + h s_{i,j}| \\le \\max(T_x,T_z)$ 时。更新公式为 $T'_{i,j} = \\min(T_x, T_z) + h s_{i,j}$。\n  2. 否则，波前由两个轴向的贡献共同构成。通过求解从离散化程函方程导出的二次方程 $(\\frac{T' - T_x}{h})^2 + (\\frac{T' - T_z}{h})^2 = s_{i,j}^2$ 来找到更新值。正确的因果解是 $T'_{i,j} = \\frac{T_x + T_z + \\sqrt{2(h s_{i,j})^2 - (T_x-T_z)^2}}{2}$。\n- 如果新计算的时间 $T'_{i,j}$ 小于节点 $(i,j)$ 当前存储的时间，则更新该值，将节点状态设为 `TRIAL`，并将其添加到优先队列中。当优先队列为空时，算法终止。\n\n最后，任意接收点位置 $\\mathbf{x}_r$ 处的走时，记为 $\\widehat{T}_{\\text{eik}}(\\mathbf{x}_r)$，是通过对最终的离散走时场 $T_h$ 进行双线性插值获得的。\n\n**3. 射线追踪与走时积分**\n\n地震射线是程函方程的特征曲线，其方向沿着走时场的梯度 $\\nabla T$。为了从接收点 $\\mathbf{x}_r$ 反向追踪到震源 $\\mathbf{x}_s$，我们对由弧长 $\\ell$ 参数化的射线路径 $\\mathbf{x}(\\ell)$ 的常微分方程（ODE）进行积分：\n$$ \\frac{d\\mathbf{x}}{d\\ell} = - \\frac{\\nabla T(\\mathbf{x})}{|\\nabla T(\\mathbf{x})|} $$\n负号表示向源方向的反向传播。该 ODE 通过数值方法求解。\n\n- **数值积分**：使用前向欧拉法（forward Euler method）和恒定的弧长步长 $\\Delta \\ell = 0.005 \\ \\text{km}$：\n  $$ \\mathbf{x}_{k+1} = \\mathbf{x}_k - \\Delta\\ell \\frac{\\nabla T_h(\\mathbf{x}_k)}{|\\nabla T_h(\\mathbf{x}_k)|} $$\n  其中 $\\mathbf{x}_k$ 是第 $k$ 步的位置。每一步都需要计算场 $\\nabla T_h(\\mathbf{x}_k)$ 的梯度。由于 $\\mathbf{x}_k$ 通常不在网格节点上，其值需要通过首先使用二阶有限差分计算整个网格上 $T_h$ 的梯度，然后使用双线性插值来评估 $\\mathbf{x}_k$ 处的梯度分量来找到。范数 $|\\nabla T_h(\\mathbf{x}_k)|$ 由此插值梯度向量计算得出。\n- **走时累积**：沿射线的总走时 $\\widehat{T}_{\\text{ray}}(\\mathbf{x}_r)$ 是慢度场沿追踪路径的线积分。该积分通过求和（一个简单的矩形求积法则）来近似：\n  $$ \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) = \\int_{0}^{L} s(\\mathbf{x}(\\ell)) \\, d\\ell \\approx \\sum_{k} s(\\mathbf{x}_k) \\Delta\\ell $$\n  每个离网格点处的慢度 $s(\\mathbf{x}_k)$ 也通过对离散慢度场 $s_{i,j}$ 进行双线性插值获得。\n- **终止条件**：对于给定的接收点，当其到震源 $(x_s, z_s)$ 的欧几里得距离小于一个网格间距（$h = 0.02 \\ \\text{km}$），或达到最大步数 $10000$ 步时，射线追踪过程终止。\n\n**4. 误差量化**\n\n核心任务是为每个指定的接收点 $\\mathbf{x}_r$ 计算有符号失配 $\\Delta(\\mathbf{x}_r)$。该值定义为：\n$$ \\Delta(\\mathbf{x}_r) = \\widehat{T}_{\\text{ray}}(\\mathbf{x}_r) - \\widehat{T}_{\\text{eik}}(\\mathbf{x}_r) $$\n一个非零的 $\\Delta(\\mathbf{x}_r)$ 是预料之中的，它代表了由多个来源累积的数值误差：FMM 的一阶精度、有限差分梯度估计的不准确性、用于射线积分的欧拉法的一阶精度，以及重复双线性插值带来的误差。这个度量标准可作为所实现数值方法自洽性的衡量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Computes numerical error in seismic travel times by comparing an FMM eikonal solution\n    with line integrals along traced rays.\n    \"\"\"\n    # 1. Physical and mathematical setting\n    W, H = 4.0, 2.0  # Domain size in km\n    h = 0.02  # Grid spacing in km\n    v0 = 3.0  # Background velocity in km/s\n    s0 = 1.0 / v0  # Background slowness in s/km\n\n    # Gaussian lens parameters\n    xc, zc = 2.0, 1.0  # Center in km\n    A = 0.5  # Relative amplitude (dimensionless)\n    sigma = 0.3  # Standard deviation in km\n\n    # Source and receiver locations\n    xs, zs = 0.2, 1.0  # Source in km\n    source_pos_np = np.array([xs, zs])\n    receivers = [\n        (0.5, 1.0),\n        (3.5, 1.0),\n        (3.5, 0.8),\n        (2.0, 1.0),\n        (3.9, 1.0),\n    ]\n\n    # Numerical parameters for ray tracing\n    delta_l = 0.005  # Arclength step in km\n    max_ray_steps = 10000\n    termination_dist = h\n\n    # 2. Grid and slowness field setup\n    nx = int(W / h) + 1\n    nz = int(H / h) + 1\n    x_ax = np.linspace(0, W, nx)\n    z_ax = np.linspace(0, H, nz)\n    X, Z = np.meshgrid(x_ax, z_ax)\n\n    s_field = s0 * (1.0 + A * np.exp(-((X - xc)**2 + (Z - zc)**2) / (2.0 * sigma**2)))\n\n    # 3. Fast Marching Method (FMM)\n    T = np.full((nz, nx), np.inf)\n    FAR, TRIAL, KNOWN = 0, 1, 2\n    states = np.zeros((nz, nx), dtype=np.int8)\n    pq = []\n\n    # Initialize source\n    isrc = int(np.round(xs / h))\n    jsrc = int(np.round(zs / h))\n    \n    T[jsrc, isrc] = 0.0\n    states[jsrc, isrc] = TRIAL\n    heapq.heappush(pq, (0.0, jsrc, isrc))\n\n    # FMM main loop\n    while pq:\n        time, j, i = heapq.heappop(pq)\n\n        if states[j, i] == KNOWN:\n            continue\n        states[j, i] = KNOWN\n\n        # Process neighbors\n        for dj, di in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            jn, i_n = j + dj, i + di\n\n            if not (0 = jn  nz and 0 = i_n  nx):\n                continue\n            if states[jn, i_n] == KNOWN:\n                continue\n\n            # Get minimum times from known neighbors of the target node (jn, i_n)\n            tx_min = np.inf\n            if i_n > 0 and states[jn, i_n - 1] == KNOWN:\n                tx_min = T[jn, i_n - 1]\n            if i_n  nx - 1 and states[jn, i_n + 1] == KNOWN:\n                tx_min = min(tx_min, T[jn, i_n + 1])\n\n            tz_min = np.inf\n            if jn > 0 and states[jn - 1, i_n] == KNOWN:\n                tz_min = T[jn - 1, i_n]\n            if jn  nz - 1 and states[jn + 1, i_n] == KNOWN:\n                tz_min = min(tz_min, T[jn + 1, i_n])\n\n            if tx_min == np.inf and tz_min == np.inf:\n                continue\n\n            # Godunov upwind update\n            t_cand = sorted([tx_min, tz_min])\n            t1, t2 = t_cand[0], t_cand[1]\n            s_val = s_field[jn, i_n]\n            h_s = h * s_val\n            t_new = np.inf\n\n            if t1 + h_s = t2 or t2 == np.inf:  # 1D update\n                t_new = t1 + h_s\n            else:  # 2D update\n                # Solve: (t-t1)^2 + (t-t2)^2 = (h*s)^2\n                a, b, c = 2.0, -2.0 * (t1 + t2), t1**2 + t2**2 - h_s**2\n                discriminant = b**2 - 4 * a * c\n                if discriminant >= 0:\n                    t_new = (-b + np.sqrt(discriminant)) / (2.0 * a)\n\n            if t_new  T[jn, i_n]:\n                T[jn, i_n] = t_new\n                states[jn, i_n] = TRIAL\n                heapq.heappush(pq, (t_new, jn, i_n))\n\n    # 4. Ray Tracing setup\n    # Create interpolators for T, s, and gradients\n    # Note: RegularGridInterpolator expects points in (z, x) order\n    interp_T = RegularGridInterpolator((z_ax, x_ax), T, bounds_error=False, fill_value=None)\n    interp_s = RegularGridInterpolator((z_ax, x_ax), s_field, bounds_error=False, fill_value=None)\n\n    # Gradients of T: dT/dz, dT/dx\n    gz, gx = np.gradient(T, h, h)\n    interp_dTdx = RegularGridInterpolator((z_ax, x_ax), gx, bounds_error=False, fill_value=None)\n    interp_dTdz = RegularGridInterpolator((z_ax, x_ax), gz, bounds_error=False, fill_value=None)\n    \n    results = []\n    \n    # 5. Compute mismatch for each receiver\n    for xr, zr in receivers:\n        # (i) Get interpolated eikonal travel time\n        T_eik = interp_T([zr, xr])[0]\n\n        # (ii) Trace ray and integrate slowness\n        current_pos = np.array([xr, zr])\n        ray_time = 0.0\n\n        for _ in range(max_ray_steps):\n            if np.linalg.norm(current_pos - source_pos_np)  termination_dist:\n                break\n            \n            # Interpolator expects (z, x) point format\n            pos_for_interp = [current_pos[1], current_pos[0]] \n\n            s_val = interp_s(pos_for_interp)[0]\n            grad_T_x = interp_dTdx(pos_for_interp)[0]\n            grad_T_z = interp_dTdz(pos_for_interp)[0]\n            grad_T = np.array([grad_T_x, grad_T_z])\n            grad_T_norm = np.linalg.norm(grad_T)\n\n            if grad_T_norm  1e-12: # Avoid division by zero\n                break\n\n            # Euler step for ray path ODE\n            direction = -grad_T / grad_T_norm\n            current_pos += direction * delta_l\n\n            # Accumulate time via line integral (simple quadrature)\n            ray_time += s_val * delta_l\n        \n        delta = ray_time - T_eik\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3614052"}, {"introduction": "除了基于场的方法，许多地震学问题本质上是以射线为中心的，其中一个经典问题便是找到连接震源和接收点的特定射线。本练习将实现并比较两种解决此“两点边值问题”的强大策略：直观的“打靶法”和更为复杂的牛顿法，后者需要推导并积分相应的敏感度（变分）方程。这项实践将使你深入理解基于射线的优化算法及其数值实现，并体会不同算法策略之间的权衡。[@problem_id:3614051]", "problem": "您的任务是实现并比较两种数值策略，用于解决二维、各向同性、速度平滑变化介质中的两点地震射线追踪问题。目标是确定震源的初始出射方向和走时，使得由射线常微分方程（ODE）控制的射线能够到达指定的接收点位置。您的程序必须输出一个列表，该列表汇总了多个测试用例的量化比较指标。\n\n从以下地震学和哈密顿力学的基本原理开始：\n\n- 根据费马原理，射线路径是走时的平稳曲线。\n- 程函方程将走时场的梯度与慢度的大小联系起来，在各向同性介质中，可以采用射线的哈密顿表示。\n- 在速度场为 $c(\\mathbf{x})$ 的各向同性介质中，其中 $\\mathbf{x} = (x,z)$，走时参数 $t$ 可用于射线参数化。将慢度矢量的水平和垂直分量分别定义为 $p = \\partial T / \\partial x$ 和 $q = \\partial T / \\partial z$。使用哈密顿量 $H(\\mathbf{x},\\mathbf{p}) = \\tfrac{1}{2} c(\\mathbf{x})^2 \\lVert \\mathbf{p} \\rVert^2 - \\tfrac{1}{2}$，其中 $\\mathbf{p} = (p,q)$，哈密顿方程可以导出一个关于状态 $\\mathbf{y} = (x,z,p,q)$ 的常微分方程组，该方程组由走时 $t$ 参数化。\n\n您的任务是：\n\n$1.$ 基于上述基本原理，对于垂直分层速度 $c(x,z) = c(z)$，使用哈密顿方程和走时参数化，推导出形式为 $\\dfrac{d \\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 的射线常微分方程组。将您的推导应用于线性速度梯度模型\n$$\nc(z) = c_0 + g z,\n$$\n其中 $c_0$ 和 $g$ 是常数，$c_0 > 0$，且 $g \\ge 0$。\n\n$2.$ 推导相关的状态对初始出射角 $\\theta$ 的偏导数的一阶变分（灵敏度）方程，其中在震源深度 $z = z_S$ 处，初始慢度矢量的大小为 $1/c(z_S)$，方向 $\\theta$ 是从 x 轴正方向测量的弧度。具体来说，令 $\\mathbf{y}_\\theta = \\partial \\mathbf{y} / \\partial \\theta$。推导出线性时变系统\n$$\n\\frac{d}{dt} \\mathbf{y}_\\theta = \\mathbf{A}(t) \\, \\mathbf{y}_\\theta,\n$$\n其中 $\\mathbf{A}(t) = \\dfrac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}}\\big\\rvert_{\\mathbf{y}(t)}$，并给出 $\\mathbf{y}_\\theta$ 关于 $\\theta$ 和 $c(z_S)$ 的初始条件。\n\n$3.$ 实现两种数值策略，用于从震源位置 $\\mathbf{x}_S = (x_S, z_S)$ 追踪到接收点位置 $\\mathbf{x}_R = (x_R, z_R)$：\n\n$3.1.$ 打靶法（无导数优化）：构建并数值最小化关于出射角 $\\theta$ 和最终走时 $t_f$ 的失配函数\n$$\n\\Phi(\\theta, t_f) = \\left\\| \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R \\right\\|_2^2,\n$$\n同时满足将 $(\\theta, t_f)$ 映射到最终位置 $\\mathbf{x}(\\theta, t_f)$ 的射线常微分方程约束。使用一种鲁棒的无导数方法来找到近似最小化 $\\Phi$ 的 $(\\hat{\\theta}_{\\mathrm{shoot}}, \\hat{t}_{\\mathrm{shoot}})$。确保在搜索过程中 $t_f$ 保持为严格正值。\n\n$3.2.$ 两点边值牛顿法：将边值问题描述为求解 $(\\theta, t_f)$ 使得\n$$\n\\mathbf{F}(\\theta, t_f) = \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R = \\mathbf{0}.\n$$\n推导并实现牛顿迭代\n$$\n\\begin{bmatrix}\n\\theta \\\\\nt_f\n\\end{bmatrix}_{k+1}\n=\n\\begin{bmatrix}\n\\theta \\\\\nt_f\n\\end{bmatrix}_{k}\n-\n\\mathbf{J}(\\theta_k, t_{f,k})^{-1}\n\\mathbf{F}(\\theta_k, t_{f,k}),\n$$\n其中雅可比矩阵 $\\mathbf{J} \\in \\mathbb{R}^{2 \\times 2}$ 的列为 $\\partial \\mathbf{x}/\\partial \\theta$ 和 $\\partial \\mathbf{x}/\\partial t_f$。解析地表示第二列，使其为 $t_f$ 时刻的射线状态的函数，并通过积分任务 $2$ 中的变分方程来计算第一列。如果需要，使用合适的步长阻尼策略以确保收敛。\n\n$4.$ 数值实现要求：\n\n$4.1.$ 介质：使用线性速度模型 $c(z) = c_0 + g z$。\n\n$4.2.$ 单位：位置使用米，速度使用米/秒，时间使用秒。出射角必须使用弧度。\n\n$4.3.$ 积分：对射线常微分方程和耦合的变分方程实现一个固定步长的显式四阶龙格-库塔方法。通过选择一个合理的、作为 $t_f$ 函数的步数来确保稳定性和准确性。\n\n$4.4.$ 初始猜测：对于两种方法，均使用直线几何猜测\n$$\n\\theta_0 = \\operatorname{atan2}(z_R - z_S, x_R - x_S), \\quad\nt_{0} = \\frac{\\sqrt{(x_R - x_S)^2 + (z_R - z_S)^2}}{\\bar{c}},\n$$\n其中 $\\bar{c} = c_0 + g \\, (z_S + z_R)/2$。\n\n$5.$ 测试套件和输出：\n\n实现您的程序，使其运行以下三个测试用例，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按顺序包含每个测试用例的三个浮点数。对于每个测试用例，生成：\n\n- 两种方法的出射角绝对差，即 $|\\hat{\\theta}_{\\mathrm{shoot}} - \\hat{\\theta}_{\\mathrm{Newton}}|$，单位为弧度。\n- 两种方法的最终走时绝对差，即 $|\\hat{t}_{\\mathrm{shoot}} - \\hat{t}_{\\mathrm{Newton}}|$，单位为秒。\n- 两点边值方法的最终残差范数，即 $\\left\\| \\mathbf{F}(\\hat{\\theta}_{\\mathrm{Newton}}, \\hat{t}_{\\mathrm{Newton}}) \\right\\|_2$，单位为米。\n\n将所有测试用例的结果按案例顺序汇总到一个扁平列表中。\n\n使用以下测试套件：\n\n- 案例 1（常规路径）：$c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0, 0)$ m, $\\mathbf{x}_R = (3000, 1500)$ m。\n- 案例 2（边界情况：匀速）：$c_0 = 2000$ m/s, $g = 0.0$ s$^{-1}$, $\\mathbf{x}_S = (0, 0)$ m, $\\mathbf{x}_R = (4000, 1000)$ m。\n- 案例 3（浅深度远距离边缘追踪）：$c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0, 0)$ m, $\\mathbf{x}_R = (6000, 500)$ m。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序完全如下：\n$[$案例1角度差, 案例1时间差, 案例1残差, 案例2角度差, 案例2时间差, 案例2残差, 案例3角度差, 案例3时间差, 案例3残差$]$。所有值都必须是浮点数，并使用上述指定单位。不允许有其他额外输出。", "solution": "我们从各向同性介质中的程函方程开始，该方程用走时场 $T(\\mathbf{x})$ 表示为 $\\lVert \\nabla T \\rVert = 1/c(\\mathbf{x})$，其中 $c(\\mathbf{x})$ 是波速。引入慢度矢量 $\\mathbf{p} = \\nabla T$，其分量为 $p = \\partial T / \\partial x$ 和 $q = \\partial T / \\partial z$，我们采用哈密顿量\n$$\nH(\\mathbf{x}, \\mathbf{p}) = \\frac{1}{2} c(\\mathbf{x})^2 \\lVert \\mathbf{p} \\rVert^2 - \\frac{1}{2},\n$$\n这在物理射线上强制执行了程函约束 $H = 0$。用走时 $t$ 对射线进行参数化，哈密顿方程给出\n$$\n\\frac{d \\mathbf{x}}{dt} = \\frac{\\partial H}{\\partial \\mathbf{p}}, \\qquad\n\\frac{d \\mathbf{p}}{dt} = - \\frac{\\partial H}{\\partial \\mathbf{x}}.\n$$\n写作 $\\mathbf{x} = (x,z)$ 和 $\\mathbf{p} = (p,q)$，我们计算\n$$\n\\frac{dx}{dt} = \\frac{\\partial H}{\\partial p} = c(\\mathbf{x})^2 \\, p, \\qquad\n\\frac{dz}{dt} = \\frac{\\partial H}{\\partial q} = c(\\mathbf{x})^2 \\, q,\n$$\n以及\n$$\n\\frac{dp}{dt} = - \\frac{\\partial H}{\\partial x} = - \\frac{1}{2} \\frac{\\partial (c^2)}{\\partial x} \\, (p^2 + q^2), \\qquad\n\\frac{dq}{dt} = - \\frac{\\partial H}{\\partial z} = - \\frac{1}{2} \\frac{\\partial (c^2)}{\\partial z} \\, (p^2 + q^2).\n$$\n对于垂直分层介质 $c(\\mathbf{x}) = c(z)$，我们有 $\\partial (c^2)/\\partial x = 0$，因此\n$$\n\\frac{dp}{dt} = 0, \\qquad\n\\frac{dq}{dt} = - \\frac{1}{2} \\frac{d (c^2)}{dz} (p^2+q^2).\n$$\n对于线性梯度模型\n$$\nc(z) = c_0 + g z,\n$$\n其中 $c_0 > 0$ 且 $g \\ge 0$，我们有\n$$\n\\frac{d (c^2)}{dz} = \\frac{d}{dz} \\big( (c_0 + g z)^2 \\big) = 2 (c_0 + g z) g = 2 c g.\n$$\n因此，射线常微分方程组变为\n$$\n\\frac{dx}{dt} = c^2 p, \\qquad\n\\frac{dz}{dt} = c^2 q, \\qquad\n\\frac{dp}{dt} = 0, \\qquad\n\\frac{dq}{dt} = - c g \\, (p^2 + q^2),\n$$\n其中 $c = c(z) = c_0 + g z$。注意，沿着射线，$H=0$ 意味着 $c^2(p^2+q^2) = 1$，因此 $p^2+q^2 = 1/c^2$，但我们不在常微分方程的右侧显式地强制使用这个恒等式，以保持一致的变分形式。\n\n震源 $\\mathbf{x}_S = (x_S, z_S)$ 处的初始条件由从 x 轴正方向测量的出射角 $\\theta$（以弧度为单位）定义。初始慢度大小为 $1/c(z_S)$，所以\n$$\nx(0) = x_S, \\quad z(0) = z_S, \\quad p(0) = \\frac{\\cos \\theta}{c(z_S)}, \\quad q(0) = \\frac{\\sin \\theta}{c(z_S)}.\n$$\n\n对于关于 $\\theta$ 的变分方程，令 $\\mathbf{y} = (x,z,p,q)^\\top$ 且 $\\mathbf{y}_\\theta = \\partial \\mathbf{y}/\\partial \\theta$。线性化动力学方程为\n$$\n\\frac{d}{dt} \\mathbf{y}_\\theta = \\mathbf{A}(t) \\, \\mathbf{y}_\\theta,\n$$\n其中 $\\mathbf{A}(t) = \\partial \\mathbf{f} / \\partial \\mathbf{y}$ 是射线方程右端项沿射线路径求值的雅可比矩阵。记 $c = c(z)$ 和 $c^2 = c^2(z)$，\n$$\n\\mathbf{f}(\\mathbf{y}) =\n\\begin{bmatrix}\nc^2 p \\\\\nc^2 q \\\\\n0 \\\\\n- \\tfrac{1}{2} \\, \\frac{d (c^2)}{dz} \\, (p^2 + q^2)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nc^2 p \\\\\nc^2 q \\\\\n0 \\\\\n- c g \\, (p^2 + q^2)\n\\end{bmatrix}.\n$$\n雅可比矩阵的元素通过偏导数计算。使用 $\\frac{d (c^2)}{dz} = 2 c g$ 和 $\\frac{d^2 (c^2)}{dz^2} = 2 g^2$，我们得到\n$$\n\\frac{\\partial f_1}{\\partial x} = 0, \\quad\n\\frac{\\partial f_1}{\\partial z} = \\frac{d (c^2)}{dz} \\, p = 2 c g \\, p, \\quad\n\\frac{\\partial f_1}{\\partial p} = c^2, \\quad\n\\frac{\\partial f_1}{\\partial q} = 0,\n$$\n$$\n\\frac{\\partial f_2}{\\partial x} = 0, \\quad\n\\frac{\\partial f_2}{\\partial z} = \\frac{d (c^2)}{dz} \\, q = 2 c g \\, q, \\quad\n\\frac{\\partial f_2}{\\partial p} = 0, \\quad\n\\frac{\\partial f_2}{\\partial q} = c^2,\n$$\n$$\n\\frac{\\partial f_3}{\\partial x} = 0, \\quad\n\\frac{\\partial f_3}{\\partial z} = 0, \\quad\n\\frac{\\partial f_3}{\\partial p} = 0, \\quad\n\\frac{\\partial f_3}{\\partial q} = 0,\n$$\n$$\n\\frac{\\partial f_4}{\\partial x} = 0, \\quad\n\\frac{\\partial f_4}{\\partial z} = - \\frac{1}{2} \\frac{d^2 (c^2)}{dz^2} (p^2 + q^2) = - g^2 (p^2 + q^2), \\quad\n\\frac{\\partial f_4}{\\partial p} = - \\frac{d (c^2)}{dz} \\, p = - 2 c g \\, p, \\quad\n\\frac{\\partial f_4}{\\partial q} = - \\frac{d (c^2)}{dz} \\, q = - 2 c g \\, q.\n$$\n因此 $\\mathbf{A}(t)$ 是由这些元素填充的 $4 \\times 4$ 矩阵。\n\n变分状态 $\\mathbf{y}_\\theta$ 的初始条件通过对初始状态关于 $\\theta$ 求导得出：\n$$\n\\left. \\frac{\\partial x}{\\partial \\theta} \\right|_{t=0} = 0, \\quad\n\\left. \\frac{\\partial z}{\\partial \\theta} \\right|_{t=0} = 0, \\quad\n\\left. \\frac{\\partial p}{\\partial \\theta} \\right|_{t=0} = - \\frac{\\sin \\theta}{c(z_S)}, \\quad\n\\left. \\frac{\\partial q}{\\partial \\theta} \\right|_{t=0} = \\frac{\\cos \\theta}{c(z_S)}.\n$$\n\n我们现在概述两种数值策略。\n\n对于打靶法，我们定义一个失配函数\n$$\n\\Phi(\\theta, t_f) = \\left\\| \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R \\right\\|_2^2,\n$$\n其中 $\\mathbf{x}(\\theta, t_f)$ 是通过将射线常微分方程从 $t=0$ 积分到 $t=t_f$ 得到的，初始条件由 $\\theta$ 设定。采用对 $(\\theta, t_f)$ 的无导数搜索来最小化 $\\Phi$，并通过惩罚项强制 $t_f > 0$。通过合理的初始猜测和对 $t_f$ 的边界约束来增强鲁棒性。\n\n对于两点边值牛顿法，我们求解 $\\mathbf{F}(\\theta, t_f) = \\mathbf{x}(\\theta, t_f) - \\mathbf{x}_R = \\mathbf{0}$。牛顿步长为\n$$\n\\begin{bmatrix}\n\\delta \\theta \\\\\n\\delta t_f\n\\end{bmatrix}\n=\n\\mathbf{J}(\\theta, t_f)^{-1}\n\\left( - \\mathbf{F}(\\theta, t_f) \\right),\n$$\n更新步骤为 $(\\theta, t_f) \\leftarrow (\\theta, t_f) + \\alpha \\, (\\delta \\theta, \\delta t_f)$，使用一个通过回溯法选择的阻尼因子 $\\alpha \\in (0,1]$ 来减小 $\\lVert \\mathbf{F} \\rVert_2$。雅可比矩阵的列是\n$$\n\\frac{\\partial \\mathbf{x}}{\\partial \\theta} (t_f) = \\begin{bmatrix} \\partial x / \\partial \\theta \\\\ \\partial z / \\partial \\theta \\end{bmatrix}(t_f),\n\\quad\n\\frac{\\partial \\mathbf{x}}{\\partial t_f} (t_f) = \\frac{d \\mathbf{x}}{dt} (t_f) = \\begin{bmatrix} c(t_f)^2 p(t_f) \\\\ c(t_f)^2 q(t_f) \\end{bmatrix}.\n$$\n第一列通过与射线常微分方程同时积分变分方程来计算，从上面给出的初始条件开始。第二列是 $t_f$ 时刻的射线速度。\n\n对于数值积分，我们对射线状态和变分状态都应用一个固定步长的显式四阶龙格-库塔方案。通过选择一个与 $t_f$ 成比例的步数并强制一个最小步数来控制精度。\n\n我们采用直线初始猜测\n$$\n\\theta_0 = \\operatorname{atan2}(z_R - z_S, x_R - x_S), \\quad\nt_0 = \\frac{\\sqrt{(x_R - x_S)^2 + (z_R - z_S)^2}}{\\bar{c}},\n\\quad \\bar{c} = c_0 + g \\, \\frac{z_S + z_R}{2},\n$$\n这对于速度平滑变化的介质是合理的。\n\n每个测试用例的输出包括角度的绝对差 $|\\hat{\\theta}_{\\mathrm{shoot}} - \\hat{\\theta}_{\\mathrm{Newton}}|$（弧度）、时间的绝对差 $|\\hat{t}_{\\mathrm{shoot}} - \\hat{t}_{\\mathrm{Newton}}|$（秒），以及最终的牛顿法残差 $\\lVert \\mathbf{F}(\\hat{\\theta}_{\\mathrm{Newton}}, \\hat{t}_{\\mathrm{Newton}}) \\rVert_2$（米）。对于 $g=0$ 的匀速情况，射线是一条直线；因此，两种方法的结果应在数值容差范围内一致，产生非常小的差异和残差。\n\n最后，我们实现三个测试用例：\n\n- 案例 1：$c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0,0)$ m, $\\mathbf{x}_R = (3000,1500)$ m。\n- 案例 2：$c_0 = 2000$ m/s, $g = 0.0$ s$^{-1}$, $\\mathbf{x}_S = (0,0)$ m, $\\mathbf{x}_R = (4000,1000)$ m。\n- 案例 3：$c_0 = 2000$ m/s, $g = 0.5$ s$^{-1}$, $\\mathbf{x}_S = (0,0)$ m, $\\mathbf{x}_R = (6000,500)$ m。\n\n一个具有足够步长解析度和牛顿更新中带有阻尼的鲁棒实现，会对所有三个案例产生方法间的微小差异和接近零的残差。程序会按规定顺序生成包含9个浮点数的单行聚合结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\n# Ray ODEs in 2D isotropic medium with linear vertical velocity gradient c(z) = c0 + g*z.\n# State y = [x, z, p, q], where p=Tx, q=Tz are slowness components. Parametrized by traveltime t.\n\ndef c_and_derivs(z, c0, g):\n    c = c0 + g * z\n    c2 = c * c\n    dc2_dz = 2.0 * c * g\n    d2c2_dz2 = 2.0 * g * g\n    return c, c2, dc2_dz, d2c2_dz2\n\ndef ray_rhs(y, c0, g):\n    x, z, p, q = y\n    c, c2, dc2_dz, _ = c_and_derivs(z, c0, g)\n    dxdt = c2 * p\n    dzdt = c2 * q\n    dpdt = 0.0\n    dqdt = -0.5 * dc2_dz * (p*p + q*q)  # = -c*g*(p^2+q^2)\n    return np.array([dxdt, dzdt, dpdt, dqdt], dtype=float)\n\ndef jacobian_A(y, c0, g):\n    # Jacobian of ray_rhs with respect to state y = [x,z,p,q]\n    x, z, p, q = y\n    c, c2, dc2_dz, d2c2_dz2 = c_and_derivs(z, c0, g)\n    # Initialize 4x4 zero matrix\n    A = np.zeros((4,4), dtype=float)\n    # df1/dz = (dc2/dz)*p, df1/dp = c2\n    A[0,1] = dc2_dz * p\n    A[0,2] = c2\n    # df2/dz = (dc2/dz)*q, df2/dq = c2\n    A[1,1] = dc2_dz * q\n    A[1,3] = c2\n    # df3 all zeros\n    # df4/dz = -0.5 * d2c2/dz2 * (p^2+q^2)\n    A[3,1] = -0.5 * d2c2_dz2 * (p*p + q*q)\n    # df4/dp = - (dc2/dz) * p\n    A[3,2] = - dc2_dz * p\n    # df4/dq = - (dc2/dz) * q\n    A[3,3] = - dc2_dz * q\n    return A\n\ndef rk4_step(y, dt, func, *fargs):\n    k1 = func(y, *fargs)\n    k2 = func(y + 0.5*dt*k1, *fargs)\n    k3 = func(y + 0.5*dt*k2, *fargs)\n    k4 = func(y + dt*k3, *fargs)\n    return y + (dt/6.0)*(k1 + 2*k2 + 2*k3 + k4)\n\ndef integrate_ray(theta, tf, c0, g, xS, zS, with_sensitivity=False):\n    # Initial conditions\n    cS = c0 + g * zS\n    p0 = np.cos(theta) / cS\n    q0 = np.sin(theta) / cS\n    y = np.array([xS, zS, p0, q0], dtype=float)\n\n    # Sensitivity initial condition dy/dtheta at t=0\n    if with_sensitivity:\n        dxdth = 0.0\n        dzdth = 0.0\n        dpdth = -np.sin(theta) / cS\n        dqdth =  np.cos(theta) / cS\n        Yth = np.array([dxdth, dzdth, dpdth, dqdth], dtype=float)\n    else:\n        Yth = None\n\n    # Time stepping\n    t_end = tf\n    # Ensure minimum steps for stability and accuracy\n    nsteps = max(400, int(np.ceil(200.0 * t_end))) if t_end > 0 else 400\n    dt = t_end / nsteps if nsteps > 0 else 0.0\n\n    if dt == 0.0:\n        if with_sensitivity:\n            return y, Yth\n        else:\n            return y\n\n    for _ in range(nsteps):\n        # Standard RK4 for state\n        y = rk4_step(y, dt, ray_rhs, c0, g)\n        if with_sensitivity:\n            # Variational equation: dYth/dt = A(t) * Yth\n            def var_rhs(Y, c0_, g_):\n                A = jacobian_A(y, c0_, g_)\n                return A @ Y\n            Yth = rk4_step(Yth, dt, var_rhs, c0, g)\n\n    if with_sensitivity:\n        return y, Yth\n    else:\n        return y\n\ndef straight_line_guess(xS, zS, xR, zR, c0, g):\n    dx = xR - xS\n    dz = zR - zS\n    theta0 = np.arctan2(dz, dx)\n    dist = np.hypot(dx, dz)\n    cbar = c0 + g * 0.5 * (zS + zR)\n    # Prevent division by zero\n    cbar = max(cbar, 1e-6)\n    t0 = dist / cbar\n    # Ensure positive time\n    t0 = max(t0, 1e-3)\n    return theta0, t0\n\ndef shooting_method(xS, zS, xR, zR, c0, g):\n    theta0, t0 = straight_line_guess(xS, zS, xR, zR, c0, g)\n\n    def phi(vars_):\n        th, tf = vars_\n        # Penalize non-positive time\n        if tf = 0.0 or tf > 50.0:\n            return 1e20 + (abs(tf) + 1.0) * 1e20\n        y = integrate_ray(th, tf, c0, g, xS, zS, with_sensitivity=False)\n        xr, zr = y[0], y[1]\n        dx = xr - xR\n        dz = zr - zR\n        return dx*dx + dz*dz\n\n    x0 = np.array([theta0, t0], dtype=float)\n    res = minimize(phi, x0, method='Nelder-Mead', options=dict(maxiter=400, xatol=1e-8, fatol=1e-12, disp=False))\n    th_opt, tf_opt = res.x\n    # Clamp final time\n    tf_opt = max(tf_opt, 1e-6)\n    return th_opt, tf_opt\n\ndef newton_two_point(xS, zS, xR, zR, c0, g, max_iter=30, tol=1e-8):\n    theta, tf = straight_line_guess(xS, zS, xR, zR, c0, g)\n    # Newton iterations with backtracking\n    for _ in range(max_iter):\n        # Integrate ray and sensitivity\n        y, Yth = integrate_ray(theta, tf, c0, g, xS, zS, with_sensitivity=True)\n        x_tf, z_tf, p_tf, q_tf = y\n        # Residual F = x(tf) - xR, z(tf) - zR\n        F = np.array([x_tf - xR, z_tf - zR], dtype=float)\n        res_norm = np.linalg.norm(F)\n        if res_norm  tol:\n            return theta, tf, res_norm\n        # Jacobian columns\n        # Column 1: d x / d theta, d z / d theta from Yth\n        J_col1 = np.array([Yth[0], Yth[1]], dtype=float)\n        # Column 2: d x / d tf = dx/dt, d z / d tf = dz/dt\n        c_tf, c2_tf, _, _ = c_and_derivs(z_tf, c0, g)\n        J_col2 = np.array([c2_tf * p_tf, c2_tf * q_tf], dtype=float)\n        J = np.column_stack([J_col1, J_col2])\n\n        # Solve for Newton step via least squares (in case of near-singularity)\n        try:\n            delta, *_ = np.linalg.lstsq(J, -F, rcond=None)\n        except np.linalg.LinAlgError:\n            # Fallback small perturbation\n            delta = np.array([0.0, 0.0])\n\n        dtheta, dtf = delta\n\n        # Backtracking line search\n        alpha = 1.0\n        improved = False\n        for _ls in range(12):\n            th_try = theta + alpha * dtheta\n            tf_try = tf + alpha * dtf\n            if tf_try = 0.0:\n                alpha *= 0.5\n                continue\n            y_try = integrate_ray(th_try, tf_try, c0, g, xS, zS, with_sensitivity=False)\n            F_try = np.array([y_try[0] - xR, y_try[1] - zR], dtype=float)\n            if np.linalg.norm(F_try)  res_norm:\n                theta = th_try\n                tf = tf_try\n                improved = True\n                break\n            alpha *= 0.5\n        if not improved:\n            # Could not improve; terminate\n            break\n    # Final residual\n    y = integrate_ray(theta, tf, c0, g, xS, zS, with_sensitivity=False)\n    F = np.array([y[0] - xR, y[1] - zR], dtype=float)\n    res_norm = np.linalg.norm(F)\n    return theta, tf, res_norm\n\ndef run_case(c0, g, xS, zS, xR, zR):\n    # Shooting method\n    th_shoot, tf_shoot = shooting_method(xS, zS, xR, zR, c0, g)\n    # Newton two-point boundary method\n    th_newt, tf_newt, res_newt = newton_two_point(xS, zS, xR, zR, c0, g)\n\n    dtheta = abs(th_shoot - th_newt)\n    dt = abs(tf_shoot - tf_newt)\n    return float(dtheta), float(dt), float(res_newt)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case 1: c0=2000 m/s, g=0.5 s^-1, S=(0,0) m, R=(3000,1500) m\n    # Case 2: c0=2000 m/s, g=0.0 s^-1, S=(0,0) m, R=(4000,1000) m\n    # Case 3: c0=2000 m/s, g=0.5 s^-1, S=(0,0) m, R=(6000,500) m\n    test_cases = [\n        (2000.0, 0.5, 0.0, 0.0, 3000.0, 1500.0),\n        (2000.0, 0.0, 0.0, 0.0, 4000.0, 1000.0),\n        (2000.0, 0.5, 0.0, 0.0, 6000.0, 500.0),\n    ]\n\n    results = []\n    for c0, g, xS, zS, xR, zR in test_cases:\n        dtheta, dt, res = run_case(c0, g, xS, zS, xR, zR)\n        results.extend([dtheta, dt, res])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3614051"}]}