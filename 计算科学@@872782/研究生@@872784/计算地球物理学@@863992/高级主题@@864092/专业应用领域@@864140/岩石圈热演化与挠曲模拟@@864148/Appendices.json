{"hands_on_practices": [{"introduction": "理解岩石圈状态的第一步是确定其温度分布。本练习将引导你解决一个经典的、可解析求解的问题：计算含有内部放射性生热的大陆地殼的稳态地温梯度。通过从第一性原理推导解，你将建立起关于边界条件和内部生热如何共同控制岩石圈热结构的关键物理直觉。[@problem_id:3611228]", "problem": "考虑一个导热的大陆地壳，将其理想化为一个厚度为 $L$ 的有限、均匀的一维（1D）板块，其中垂直坐标 $z$ 从地表（$z=0$）向下测量至地壳底部（$z=L$）。假设热导率 $k$ 为常数，且能量守恒处于稳态，并存在体积内部热生成 $H(z)$。控制方程为带内部热源的一维稳态热方程，\n$$\n\\frac{d}{dz}\\!\\left(k\\,\\frac{dT}{dz}\\right)+H(z)=0,\n$$\n其边界条件为固定的温度 $T(0)=T_s$ 和 $T(L)=T_b$。设地壳内的放射性生热在地壳内空间上是均匀的，$H(z)=H_0$ 对于 $0\\le z\\le L$。\n\n从上述基本定律和定义出发，推导出温度分布 $T(z)$，求出板块内部温度 $T(z)$ 达到最大值时的深度 $z_{\\max}$，并将其与无放射性生热情况（$H_0=0$）进行比较。使用以下参数值，\n- $L=60\\,\\mathrm{km}$，\n- $k=3\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$，\n- $T_s=273\\,\\mathrm{K}$，\n- $T_b=823\\,\\mathrm{K}$，\n- $H_0=2.0\\times10^{-6}\\,\\mathrm{W\\,m^{-3}}$，\n计算相对于无放射性生热情况，温度最大值的向上位移，定义为 $\\Delta z=L-z_{\\max}$。最终答案以公里为单位，并四舍五入至三位有效数字。", "solution": "用户提供了一个计算地球物理学中适定的问题。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件**\n- **控制方程**: $\\frac{d}{dz}\\!\\left(k\\,\\frac{dT}{dz}\\right)+H(z)=0$，对于 $0\\le z\\le L$。\n- **热导率**: $k$ 为常数。\n- **内部热生成**: $H(z) = H_0$（常数），对于 $0\\le z\\le L$。\n- **边界条件**: $T(0)=T_s$ 和 $T(L)=T_b$。\n- **板块厚度**: $L = 60\\,\\mathrm{km}$。\n- **热导率值**: $k=3\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$。\n- **表面温度**: $T_s = 273\\,\\mathrm{K}$。\n- **底部温度**: $T_b = 823\\,\\mathrm{K}$。\n- **热生成值**: $H_0=2.0\\times10^{-6}\\,\\mathrm{W\\,m^{-3}}$。\n- **任务**: 推导 $T(z)$，找到最高温度深度 $z_{\\max}$，并计算相对于无放射性生热情况（$H_0=0$）的向上位移 $\\Delta z=L-z_{\\max}$。$\\Delta z$ 的最终答案必须以公里为单位，并四舍五入到三位有效数字。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学依据**: 该问题基于一维稳态热方程，这是地球物理学热模拟的基石。所有参数对于大陆地壳都是物理上现实的。\n- **适定性**: 该问题是一个带有两个狄利克雷（Dirichlet）边界条件的二阶常微分方程。这构成了一个适定的边值问题，确保了唯一且稳定的解。\n- **客观性**: 该问题使用精确、无歧义的科学语言陈述。\n\n**1.3. 结论与行动**\n该问题科学上合理、适定且客观。判定为**有效**。我们继续进行求解。\n\n### 步骤2：推导温度分布 $T(z)$\n\n对于一维稳态热传导，当热导率 $k$ 为常数且内部热生成 $H_0$ 均匀时，其控制方程为：\n$$\nk\\frac{d^2T}{dz^2} + H_0 = 0\n$$\n这可以重写为：\n$$\n\\frac{d^2T}{dz^2} = -\\frac{H_0}{k}\n$$\n将此方程对 $z$ 积分一次，得到温度梯度：\n$$\n\\frac{dT}{dz} = -\\frac{H_0}{k}z + C_1\n$$\n其中 $C_1$ 是一个积分常数。再次积分得到温度分布 $T(z)$：\n$$\nT(z) = -\\frac{H_0}{2k}z^2 + C_1 z + C_2\n$$\n其中 $C_2$ 是第二个积分常数。我们通过应用边界条件来确定常数 $C_1$ 和 $C_2$。\n\n在地表 $z=0$ 处，温度为 $T(0) = T_s$：\n$$\nT(0) = -\\frac{H_0}{2k}(0)^2 + C_1(0) + C_2 = T_s\n$$\n这直接给出 $C_2 = T_s$。现在的温度分布为：\n$$\nT(z) = -\\frac{H_0}{2k}z^2 + C_1 z + T_s\n$$\n在地壳底部 $z=L$ 处，温度为 $T(L) = T_b$：\n$$\nT(L) = -\\frac{H_0}{2k}L^2 + C_1 L + T_s = T_b\n$$\n我们求解 $C_1$：\n$$\nC_1 L = T_b - T_s + \\frac{H_0 L^2}{2k}\n$$\n$$\nC_1 = \\frac{T_b - T_s}{L} + \\frac{H_0 L}{2k}\n$$\n将 $C_1$ 和 $C_2$ 的表达式代入 $T(z)$ 的通解，我们得到完整的温度分布：\n$$\nT(z) = -\\frac{H_0}{2k}z^2 + \\left(\\frac{T_b - T_s}{L} + \\frac{H_0 L}{2k}\\right)z + T_s\n$$\n这可以重新整理，以分离线性的传导分量和放射性生热分量：\n$$\nT(z) = T_s + (T_b - T_s)\\frac{z}{L} + \\frac{H_0}{2k}(Lz - z^2)\n$$\n\n### 步骤3：最高温度深度 $z_{\\max}$\n\n板块内的最高温度出现在温度梯度为零的深度 $z_{\\max}$ 处，即 $\\frac{dT}{dz}|_{z=z_{\\max}} = 0$。使用前面推导出的梯度表达式：\n$$\n\\frac{dT}{dz} = -\\frac{H_0}{k}z + C_1\n$$\n令 $z=z_{\\max}$ 处的梯度为零：\n$$\n0 = -\\frac{H_0}{k}z_{\\max} + C_1\n$$\n求解 $z_{\\max}$：\n$$\nz_{\\max} = \\frac{k C_1}{H_0}\n$$\n代入推导出的 $C_1$ 表达式：\n$$\nz_{\\max} = \\frac{k}{H_0}\\left(\\frac{T_b - T_s}{L} + \\frac{H_0 L}{2k}\\right)\n$$\n$$\nz_{\\max} = \\frac{k(T_b - T_s)}{H_0 L} + \\frac{L}{2}\n$$\n这是温度达到最大值时的深度。为使该最大值物理上位于地壳内部，必须满足 $0 \\le z_{\\max} \\le L$。\n\n### 步骤4：无放射性生热情况与向上位移 $\\Delta z$\n\n在无放射性生热情况下，$H_0 = 0$。控制方程简化为 $\\frac{d^2T}{dz^2} = 0$，温度分布变为线性：\n$$\nT(z) = T_s + (T_b - T_s)\\frac{z}{L}\n$$\n温度梯度为 $\\frac{dT}{dz} = \\frac{T_b - T_s}{L}$。因为 $T_b > T_s$，该梯度是一个正常数，意味着温度随深度单调增加。因此，最高温度出现在底部边界 $z = L$ 处。\n\n问题将温度最大值的向上位移 $\\Delta z$ 定义为无放射性生热情况下的最大值深度（$L$）与放射性生热情况下的最大值深度（$z_{\\max}$）之差。\n$$\n\\Delta z = L - z_{\\max}\n$$\n代入 $z_{\\max}$ 的表达式：\n$$\n\\Delta z = L - \\left(\\frac{k(T_b - T_s)}{H_0 L} + \\frac{L}{2}\\right)\n$$\n$$\n\\Delta z = \\frac{L}{2} - \\frac{k(T_b - T_s)}{H_0 L}\n$$\n\n### 步骤5：数值计算\n\n我们已知以下参数值，必须将其转换为国际单位制（SI）基本单位：\n- $L = 60\\,\\mathrm{km} = 6 \\times 10^4\\,\\mathrm{m}$\n- $k = 3\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$\n- $T_s = 273\\,\\mathrm{K}$\n- $T_b = 823\\,\\mathrm{K}$，所以 $T_b - T_s = 550\\,\\mathrm{K}$\n- $H_0 = 2.0 \\times 10^{-6}\\,\\mathrm{W\\,m^{-3}}$\n\n现在我们将这些值代入 $\\Delta z$ 的表达式中：\n$$\n\\Delta z = \\frac{6 \\times 10^4\\,\\mathrm{m}}{2} - \\frac{(3\\,\\mathrm{W\\,m^{-1}\\,K^{-1}})(550\\,\\mathrm{K})}{(2.0 \\times 10^{-6}\\,\\mathrm{W\\,m^{-3}})(6 \\times 10^4\\,\\mathrm{m})}\n$$\n首先，计算第二项：\n$$\n\\frac{k(T_b - T_s)}{H_0 L} = \\frac{1650\\,\\mathrm{W\\,m^{-1}}}{1.2 \\times 10^{-1}\\,\\mathrm{W\\,m^{-2}}} = \\frac{1650}{0.12}\\,\\mathrm{m} = 13750\\,\\mathrm{m}\n$$\n现在，计算 $\\Delta z$：\n$$\n\\Delta z = 30000\\,\\mathrm{m} - 13750\\,\\mathrm{m} = 16250\\,\\mathrm{m}\n$$\n问题要求答案以公里为单位：\n$$\n\\Delta z = 16.25\\,\\mathrm{km}\n$$\n四舍五入到三位有效数字，我们得到：\n$$\n\\Delta z \\approx 16.3\\,\\mathrm{km}\n$$\n作为检验，最高温度的深度为 $z_{\\max} = L - \\Delta z = 60\\,\\mathrm{km} - 16.25\\,\\mathrm{km} = 43.75\\,\\mathrm{km}$。由于 $0  43.75  60$，该最大值如预期般位于地壳内部。", "answer": "$$\\boxed{16.3}$$", "id": "3611228"}, {"introduction": "在现实世界中，材料属性很少是恒定的；例如，导热系数在很大程度上取决于温度。这种依赖性使得热方程变为非线性，通常无法解析求解。本练习将为你装备一个强大的数值工具箱——有限差分法结合牛顿-拉弗森求解器——来解决这类非线性问题，掌握这项技能对于开发更真实、更精确的地球物理模型至关重要。[@problem_id:3611187]", "problem": "考虑一个一维、垂直分层的海洋岩石圈板块，该板块处于稳态导热状态，且无内部热源。垂直坐标为 $z \\in [0,L]$，从 $z=0$ 处的海底开始，正方向朝下，直到 $z=L$ 处的热边界层底部。设海底温度为 $T_s$，底部温度为 $T_m$，单位均为开尔文。热导率 $k(T)$ 与温度相关，其模型为 $k(T) = \\dfrac{k_0}{1+\\beta T}$，其中 $k_0$ 是一个单位为 $\\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$ 的正常数，$\\beta$ 是一个单位为 $\\text{K}^{-1}$ 的非负常数。其控制方程为稳态能量方程，即傅里叶（Fourier）热传导定律下的能量守恒，在一维情况下简化为\n$$\n\\frac{d}{dz}\\left(k(T)\\frac{dT}{dz}\\right) = 0,\n$$\n边界条件为狄利克雷（Dirichlet）边界条件 $T(0) = T_s$ 和 $T(L) = T_m$。\n\n您必须实现一个牛顿法（Newton scheme）来求解使用有限差分法（Finite Difference Method, FDM）离散化后的非线性边值问题。离散化应使用 $N$ 个网格点，均匀间距为 $\\Delta z = L/(N-1)$，并使用以边为中心的热导率来近似传导算子，以确保离散通量的连续性。具体来说，对于任意内部节点索引 $i$（$i=1,\\dots,N-2$），定义 $k_{i+1/2} = k\\!\\left(\\frac{T_i + T_{i+1}}{2}\\right)$ 和 $k_{i-1/2} = k\\!\\left(\\frac{T_{i-1} + T_i}{2}\\right)$，并强制执行离散残差\n$$\nR_i(T) = \\frac{k_{i+1/2}(T_{i+1}-T_i) - k_{i-1/2}(T_i - T_{i-1})}{\\Delta z^2} = 0.\n$$\n通过组合包含由链式法则（包括 $\\frac{dk}{dT}(T)$）导出的精确偏导数 $\\partial R_i/\\partial T_j$ 的雅可比矩阵（Jacobian matrix），构建牛顿-拉夫逊（Newton-Raphson, NR）线性化方程，并迭代至收敛。当内部残差向量的无穷范数 $\\|R\\|_\\infty$ 小于 $10^{-10}$ 时，必须判定为收敛。\n\n对于年龄为 $t$ 的海洋板块的物理相关厚度 $L$，使用扩散长度尺度 $L = 2\\sqrt{\\kappa t}$，其中 $\\kappa$ 是热扩散率，单位为 $\\text{m}^2\\,\\text{s}^{-1}$，$t$ 是年龄，单位为秒。取年龄 $t$ 对应于3000万年（$30$ Myr），并使用每年 $365.25$ 天将 $t$ 计算为秒。\n\n在求解出温度分布 $T(z)$ 后，计算海底的向上热通量大小为\n$$\nq_{\\text{nl}} = \\left| -\\,k\\!\\left(\\frac{T_0 + T_1}{2}\\right)\\frac{T_1 - T_0}{\\Delta z} \\right|,\n$$\n单位为 $\\text{W}\\,\\text{m}^{-2}$。然后，通过计算常数热导率下的热通量\n$$\nq_{\\text{const}} = \\frac{k_{\\text{const}}(T_m - T_s)}{L},\n$$\n来量化假设热导率恒等于其冷表面值 $k_{\\text{const}} = k(T_s)$ 所引入的误差，单位为 $\\text{W}\\,\\text{m}^{-2}$，以及相对误差\n$$\nE = \\frac{q_{\\text{const}} - q_{\\text{nl}}}{q_{\\text{nl}}},\n$$\n以小数形式表示（无量纲）。所有通量必须以 $\\text{W}\\,\\text{m}^{-2}$ 计算和解释，所有温度必须以开尔文为单位。\n\n实现该算法并为以下参数集的测试套件生成结果；对于每种情况，使用相同的年龄 $t=30$ Myr 和热扩散率 $\\kappa = 1.0\\times 10^{-6}\\ \\text{m}^2\\,\\text{s}^{-1}$，并改变温度依赖性和分辨率以测试解的不同方面：\n\n- 情况 A（基准“理想路径”）：$k_0 = 3.2\\ \\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，$\\beta = 4.0\\times 10^{-4}\\ \\text{K}^{-1}$，$T_s = 273\\ \\text{K}$，$T_m = 1573\\ \\text{K}$，$N=101$。\n- 情况 B（温度依赖性可忽略的边界情况）：$k_0 = 3.2\\ \\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，$\\beta = 0.0\\ \\text{K}^{-1}$，$T_s = 273\\ \\text{K}$，$T_m = 1573\\ \\text{K}$，$N=101$。\n- 情况 C（强温度依赖性和加密网格）：$k_0 = 3.2\\ \\text{W}\\,\\text{m}^{-1}\\,\\text{K}^{-1}$，$\\beta = 1.0\\times 10^{-3}\\ \\text{K}^{-1}$，$T_s = 273\\ \\text{K}$，$T_m = 1573\\ \\text{K}$，$N=201$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n[q_{\\text{nl}}^{(A)}, q_{\\text{const}}^{(A)}, E^{(A)}, q_{\\text{nl}}^{(B)}, q_{\\text{const}}^{(B)}, E^{(B)}, q_{\\text{nl}}^{(C)}, q_{\\text{const}}^{(C)}, E^{(C)}].\n$$\n通量必须以 $\\text{W}\\,\\text{m}^{-2}$ 计算，误差以小数形式表示；打印的值应为不带单位符号的浮点数。", "solution": "用户提供的问题被评估为有效。这是一个适定（well-posed）且具有科学依据的计算地球物理学练习，具体涉及对海洋岩石圈中热传导的非线性边值问题进行数值求解。该问题是自洽的，所有必需的方程、参数和边界条件都已明确指定。所采用的方法，即有限差分法（FDM）结合牛顿-拉夫逊（Newton-Raphson, NR）求解器，是解决此类问题的标准且合适的技术。其中没有矛盾、歧义或事实错误。\n\n求解过程如下：首先，我们离散化一维稳态热传导控制方程。然后，对于得到的非线性代数方程组，我们推导牛顿-拉夫逊算法的组成部分，即残差向量和雅可比矩阵。最后，我们实现此算法以求解温度分布，并为每个指定的测试用例计算所需的热通量和相对误差。\n\n**1. 控制方程与离散化**\n\n问题始于稳态、一维且无内部热源的热传导方程：\n$$\n\\frac{d}{dz}\\left(k(T)\\frac{dT}{dz}\\right) = 0\n$$\n其中 $z \\in [0,L]$ 是垂直坐标，$T(z)$ 是温度，$k(T)$ 是与温度相关的热导率，由下式给出：\n$$\nk(T) = \\frac{k_0}{1+\\beta T}\n$$\n该区域受狄利克雷（Dirichlet）边界条件约束：\n$$\nT(0) = T_s, \\quad T(L) = T_m\n$$\n我们使用 $N$ 个网格点 $z_i = i \\Delta z$（$i=0, 1, \\dots, N-1$）来离散化该区域，网格间距为 $\\Delta z = L/(N-1)$。这些点上的温度记为 $T_i = T(z_i)$。边界条件固定了 $T_0 = T_s$ 和 $T_{N-1} = T_m$。余下的 $N-2$ 个内部温度 $T_1, \\dots, T_{N-2}$ 是未知数。\n\n控制方程使用确保热通量守恒的有限差分格式进行离散化。在每个内部节点 $i \\in \\{1, \\dots, N-2\\}$，我们强制残差 $R_i$ 为零：\n$$\nR_i(\\mathbf{T}) = \\frac{k_{i+1/2}(T_{i+1}-T_i) - k_{i-1/2}(T_i - T_{i-1})}{\\Delta z^2} = 0\n$$\n为确保离散通量的连续性，热导率在节点之间的中点（单元边缘）进行评估：\n$$\nk_{i+1/2} = k\\left(\\frac{T_i + T_{i+1}}{2}\\right), \\quad k_{i-1/2} = k\\left(\\frac{T_{i-1} + T_i}{2}\\right)\n$$\n这样就得到了一个关于未知内部温度向量 $\\mathbf{T}_{\\text{int}} = [T_1, T_2, \\dots, T_{N-2}]^T$ 的包含 $N-2$ 个非线性代数方程的方程组。\n\n**2. 牛顿-拉夫逊法**\n\n为了求解非线性系统 $\\mathbf{R}(\\mathbf{T}_{\\text{int}}) = \\mathbf{0}$，我们采用牛顿-拉夫逊法。从一个初始猜测值 $\\mathbf{T}^{(0)}$ 开始，我们使用以下更新规则迭代地改进解：\n$$\n\\mathbf{T}^{(k+1)} = \\mathbf{T}^{(k)} + \\delta\\mathbf{T}\n$$\n其中更新步长 $\\delta\\mathbf{T}$ 是以下线性系统的解：\n$$\nJ(\\mathbf{T}^{(k)}) \\delta\\mathbf{T} = -\\mathbf{R}(\\mathbf{T}^{(k)})\n$$\n这里，$J$ 是雅可比矩阵，其元素为 $J_{ij} = \\frac{\\partial R_i}{\\partial T_j}$（其中 $i,j$ 指的是内部节点的索引，$1, \\dots, N-2$）。迭代持续进行，直到残差向量的无穷范数小于指定的容差 $\\|R\\|_\\infty  10^{-10}$。一个线性的温度分布，$T_i = T_s + (T_m-T_s) \\frac{z_i}{L}$，可作为一个极好的初始猜测值。\n\n**3. 雅可比矩阵推导**\n\n关键步骤是构建雅可比矩阵。由于残差 $R_i$ 仅依赖于 $T_{i-1}$、$T_i$ 和 $T_{i+1}$，因此雅可比矩阵是一个三对角矩阵。我们使用链式法则和热导率函数的导数 $k'(T) = \\frac{dk}{dT} = -\\beta k_0 (1+\\beta T)^{-2}$ 来推导其元素。\n\n$R_i$ 对未知温度的非零偏导数如下：\n\n*   **次对角线 ($J_{i,i-1}$)**：对于 $i \\in \\{2, \\dots, N-2\\}$\n    $$\n    \\frac{\\partial R_i}{\\partial T_{i-1}} = \\frac{1}{\\Delta z^2} \\frac{\\partial}{\\partial T_{i-1}} \\left[ -k_{i-1/2}(T_i - T_{i-1}) \\right] = \\frac{1}{\\Delta z^2} \\left[ -\\frac{1}{2}k'_{i-1/2}(T_i - T_{i-1}) + k_{i-1/2} \\right]\n    $$\n*   **主对角线 ($J_{i,i}$)**：对于 $i \\in \\{1, \\dots, N-2\\}$\n    $$\n    \\frac{\\partial R_i}{\\partial T_i} = \\frac{1}{\\Delta z^2} \\frac{\\partial}{\\partial T_i} \\left[ k_{i+1/2}(T_{i+1}-T_i) - k_{i-1/2}(T_i - T_{i-1}) \\right] \\\\\n    = \\frac{1}{\\Delta z^2} \\left[ \\frac{1}{2}k'_{i+1/2}(T_{i+1}-T_i) - k_{i+1/2} - \\frac{1}{2}k'_{i-1/2}(T_i - T_{i-1}) - k_{i-1/2} \\right]\n    $$\n*   **超对角线 ($J_{i,i+1}$)**：对于 $i \\in \\{1, \\dots, N-3\\}$\n    $$\n    \\frac{\\partial R_i}{\\partial T_{i+1}} = \\frac{1}{\\Delta z^2} \\frac{\\partial}{\\partial T_{i+1}} \\left[ k_{i+1/2}(T_{i+1}-T_i) \\right] = \\frac{1}{\\Delta z^2} \\left[ \\frac{1}{2}k'_{i+1/2}(T_{i+1}-T_i) + k_{i+1/2} \\right]\n    $$\n\n这个三对角系统 $J\\delta\\mathbf{T} = -\\mathbf{R}$ 可以使用诸如托马斯算法（Thomas algorithm）之类的算法在 $O(N)$ 时间内高效求解，该算法在 `scipy.linalg.solve_banded` 中可用。\n\n**4. 物理参数与后处理**\n\n岩石圈的厚度 $L$ 由年龄为 $t=3000$ 万年的板块的热扩散长度尺度决定。使用 $1 \\text{ yr} = 365.25 \\times 86400 \\text{ s}$，我们将 $t$ 计算为秒。\n$$\nL = 2\\sqrt{\\kappa t}\n$$\n其中 $\\kappa=1.0\\times 10^{-6}\\ \\text{m}^2\\,\\text{s}^{-1}$。\n\n在收敛到最终温度分布 $T(z)$ 后，我们计算所需的量。海底（$z=0$）的向上热通量大小由求解得到的近地表温度梯度计算得出：\n$$\nq_{\\text{nl}} = \\left| -k\\left(\\frac{T_0 + T_1}{2}\\right) \\frac{T_1 - T_0}{\\Delta z} \\right| = k\\left(\\frac{T_s + T_1}{2}\\right) \\frac{T_1 - T_s}{\\Delta z}\n$$\n对于常数热导率 $k_{\\text{const}} = k(T_s)$ 的参考热通量为：\n$$\nq_{\\text{const}} = \\frac{k_{\\text{const}}(T_m - T_s)}{L}\n$$\n然后相对误差计算如下：\n$$\nE = \\frac{q_{\\text{const}} - q_{\\text{nl}}}{q_{\\text{nl}}}\n$$\n对问题中指定的三个测试用例（A、B、C）中的每一个重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\n# Define global constants\nT_YR_TO_S = 365.25 * 24.0 * 3600.0\n\ndef solve_case(k0, beta, Ts, Tm, N, kappa, t_myr):\n    \"\"\"\n    Solves the 1D steady-state heat conduction problem for a single parameter set.\n    \n    Args:\n        k0 (float): Thermal conductivity constant (W/m/K).\n        beta (float): Temperature dependence of conductivity (1/K).\n        Ts (float): Surface temperature (K).\n        Tm (float): Mantle temperature (K).\n        N (int): Number of grid points.\n        kappa (float): Thermal diffusivity (m^2/s).\n        t_myr (float): Age of the lithosphere (million years).\n\n    Returns:\n        tuple: A tuple containing q_nl, q_const, and E.\n    \"\"\"\n    # 1. Define physical and numerical parameters\n    t_s = t_myr * 1e6 * T_YR_TO_S\n    L = 2.0 * np.sqrt(kappa * t_s)\n    dz = L / (N - 1.0)\n    num_unknowns = N - 2\n    convergence_tol = 1e-10\n\n    # 2. Define temperature-dependent functions for conductivity\n    def k_func(T):\n        return k0 / (1.0 + beta * T)\n\n    def k_prime_func(T):\n        return -beta * k0 / (1.0 + beta * T)**2\n\n    # 3. Initial guess for temperature profile (linear)\n    T = np.linspace(Ts, Tm, N, dtype=np.float64)\n\n    # 4. Newton-Raphson iteration\n    max_iterations = 50 # A safeguard against non-convergence\n    for _ in range(max_iterations):\n        # We solve for the `num_unknowns` interior points T[1]...T[N-2]\n        # The full vector T is T[0]...T[N-1]\n        \n        # Assemble the residual vector R for interior nodes i=1...N-2\n        R = np.zeros(num_unknowns, dtype=np.float64)\n        \n        T_int = T[1:-1]\n        T_plus = T[2:]\n        T_minus = T[:-2]\n        \n        T_mid_right = (T_int + T_plus) / 2.0\n        T_mid_left = (T_minus + T_int) / 2.0\n        \n        k_right = k_func(T_mid_right)\n        k_left = k_func(T_mid_left)\n        \n        R = (k_right * (T_plus - T_int) - k_left * (T_int - T_minus)) / dz**2\n\n        # Check for convergence\n        inf_norm_R = np.max(np.abs(R))\n        if inf_norm_R  convergence_tol:\n            break\n\n        # Assemble the Jacobian matrix J (tridiagonal)\n        # J is (_num_unknowns x num_unknowns)\n        J_banded = np.zeros((3, num_unknowns), dtype=np.float64)\n        \n        k_prime_right = k_prime_func(T_mid_right)\n        k_prime_left = k_prime_func(T_mid_left)\n\n        # Main diagonal\n        term1 = 0.5 * k_prime_right * (T_plus - T_int) - k_right\n        term2 = -0.5 * k_prime_left * (T_int - T_minus) - k_left\n        J_banded[1, :] = (term1 + term2) / dz**2\n\n        # Super-diagonal\n        J_banded[0, 1:] = (0.5 * k_prime_right[:-1] * (T_plus[:-1] - T_int[:-1]) + k_right[:-1]) / dz**2\n        \n        # Sub-diagonal\n        J_banded[2, :-1] = (-0.5 * k_prime_left[1:] * (T_int[1:] - T_minus[1:]) + k_left[1:]) / dz**2\n      \n        # Solve the linear system J * delta_T = -R\n        delta_T = solve_banded((1, 1), J_banded, -R)\n        \n        # Update the temperature vector\n        T[1:-1] += delta_T\n\n    # 5. Post-processing and output calculation\n    # Nonlinear heat flux magnitude (upward)\n    T0, T1 = T[0], T[1]\n    q_nl = k_func((T0 + T1) / 2.0) * (T1 - T0) / dz\n    \n    # Constant-conductivity heat flux\n    k_const = k_func(Ts)\n    q_const = k_const * (Tm - Ts) / L\n    \n    # Relative error\n    # Handle the case where q_nl is zero to avoid division by zero\n    if q_nl == 0.0:\n        E = 0.0 if q_const == 0.0 else np.inf\n    else:\n        E = (q_const - q_nl) / q_nl\n    \n    return q_nl, q_const, E\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: baseline \"happy path\"\n        {'k0': 3.2, 'beta': 4.0e-4, 'Ts': 273.0, 'Tm': 1573.0, 'N': 101, 'kappa': 1.0e-6, 't_myr': 30.0},\n        # Case B: negligible temperature dependence\n        {'k0': 3.2, 'beta': 0.0, 'Ts': 273.0, 'Tm': 1573.0, 'N': 101, 'kappa': 1.0e-6, 't_myr': 30.0},\n        # Case C: strong temperature dependence and refined grid\n        {'k0': 3.2, 'beta': 1.0e-3, 'Ts': 273.0, 'Tm': 1573.0, 'N': 201, 'kappa': 1.0e-6, 't_myr': 30.0},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        qnl, qconst, E = solve_case(**case_params)\n        results.extend([qnl, qconst, E])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3611187"}, {"introduction": "地球物理建模的一个关键目标是解释观测数据并约束地球的属性。本练习通过将岩石圈的热状态与其力学强度（由有效弹性厚度 $T_e$ 参数化）联系起来，弥合了理论与应用之间的鸿沟。你将实现一个反演算法，从合成的重力和地形数据中估计 $T_e$，从而获得参数估计、不确定性分析和反演理论核心原理的实践经验。[@problem_id:3611244]", "problem": "你的任务是实现一个自包含的程序，该程序使用一个基于物理的、带有已知高斯噪声的弯曲模型生成的合成频带平均重力-地形导纳观测数据，对均匀弹性岩石圈板块的有效弹性厚度（EET），记为 $T_e$，进行最大似然反演。接着，你必须使用费雪信息（FI）来量化 $T_e$ 估算值作为波数带函数的分辨率。该场景源于线性板块弯曲和引力势理论，你必须严格遵守下述规范。\n\n本问题的基础由以下经过充分检验并广泛使用的定律和定义构成：\n- 线性弹性板在垂直载荷下的弯曲：一个挠曲刚度为 $D$ 的薄弹性板漂浮在密度为 $\\rho_m$ 的流体半空间上，其垂直挠度 $w(x,y)$ 遵循包含浮力的双谐波平衡。在谱域中，对于径向波数 $k$（单位为弧度/米），表面载荷 $q_s$ 下的力平衡为：\n$$\n\\left(D k^4 + \\rho_m g\\right)\\, w(k) = q_s(k),\n$$\n其中 $g$ 是引力加速度。\n- EET为 $T_e$ 的板块的挠曲刚度为：\n$$\nD = \\frac{E T_e^3}{12 \\left(1 - \\nu^2\\right)},\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n- 对于振幅为 $h(k)$、岩石密度为 $\\rho_c$ 的地形表面载荷，谱域载荷为 $q_s(k) = \\rho_c g\\, h(k)$，相应的挠度为：\n$$\nw(k) = \\frac{\\rho_c g}{D k^4 + \\rho_m g}\\, h(k).\n$$\n- 带均自由空气重力-地形导纳 $Z(k;T_e)$（单位地形振幅的重力），假设其贡献来自具有密度差 $\\Delta \\rho_t$ 的表面地形和从深度 $z_m$ 向上延拓的、具有密度差 $\\Delta \\rho_m$ 的莫霍面起伏，其模型为：\n$$\nZ(k;T_e) = 2\\pi G\\left[\\Delta \\rho_t + \\Delta \\rho_m\\, e^{-k z_m}\\, \\frac{\\rho_c g}{D k^4 + \\rho_m g}\\right],\n$$\n其中 $G$ 是万有引力常数。该模型假设只有表面载荷、线性响应和小坡度。\n\n你必须实现以下步骤以生成所要求的输出：\n1. 使用指定的单位定义物理常数和参数：\n   - $E = 70\\times 10^9$ 帕斯卡（牛顿/平方米），\n   - $\\nu = 0.25$,\n   - $\\rho_c = 2700$ 千克/立方米,\n   - $\\rho_m = 3300$ 千克/立方米,\n   - $\\Delta \\rho_t = 2700$ 千克/立方米,\n   - $\\Delta \\rho_m = 600$ 千克/立方米,\n   - $g = 9.81$ 米/平方秒,\n   - $G = 6.67430\\times 10^{-11}$ 立方米/千克/平方秒,\n   - $z_m = 35\\times 10^3$ 米。\n2. 对每个波数带，使用上述公式计算 $Z(k;T_e)$，并通过对该带内均匀采样的 $k$ 上的 $Z(k;T_e)$ 进行平均，形成带均导纳 $\\mu_j(T_e)$。\n3. 通过计算 $\\mu_j(T_e^\\text{true})$ 并为该频带添加均值为零、已知标准差为 $\\sigma_j$ 的高斯噪声，来生成合成的带均观测值 $\\hat{Z}_j$。\n4. 对每个频带独立地进行 $T_e$ 的最大似然反演，使用一维网格搜索，范围为 $T_e \\in [2, 60]$ 千米。假设观测模型为高斯模型：\n$$\n\\ln \\mathcal{L}(T_e\\,|\\,\\hat{Z}_j) = -\\frac{1}{2}\\,\\frac{\\left(\\hat{Z}_j - \\mu_j(T_e)\\right)^2}{\\sigma_j^2} + \\text{constant}.\n$$\n返回每个频带的最大似然估计值 $\\widehat{T}_{e,j}$。\n5. 使用单个带均观测值的费雪信息来量化每个频带的分辨率：\n$$\n\\mathcal{I}_j(T_e) = \\frac{1}{\\sigma_j^2}\\left(\\frac{\\partial \\mu_j(T_e)}{\\partial T_e}\\right)^2,\n$$\n并计算标准差的克拉默-拉奥下界为：\n$$\n\\sigma_{T_e,j} = \\mathcal{I}_j\\left(\\widehat{T}_{e,j}\\right)^{-1/2}.\n$$\n使用数值稳定的有限差分法来近似计算 $\\widehat{T}_{e,j}$ 处的导数。\n\n单位：\n- 你必须以千米为单位报告所有的 $T_e$ 值和分辨率值。波数 $k$ 的单位是弧度/米，重力-地形导纳 $Z$ 的单位是反平方秒。\n\n你的程序必须为以下测试用例套件实现上述过程，每个用例都包含三个波数带和指定的噪声：\n- 波数带（在 $k$ 上均匀采样）：\n  - 带 1（长波长）：$\\lambda \\in [200\\times 10^3,\\, 500\\times 10^3]$ 米，即 $k \\in \\left[\\frac{2\\pi}{500\\times 10^3},\\, \\frac{2\\pi}{200\\times 10^3}\\right]$ 弧度/米。\n  - 带 2（中波长）：$\\lambda \\in [80\\times 10^3,\\, 200\\times 10^3]$ 米，即 $k \\in \\left[\\frac{2\\pi}{200\\times 10^3},\\, \\frac{2\\pi}{80\\times 10^3}\\right]$ 弧度/米。\n  - 带 3（短波长）：$\\lambda \\in [40\\times 10^3,\\, 80\\times 10^3]$ 米，即 $k \\in \\left[\\frac{2\\pi}{80\\times 10^3},\\, \\frac{2\\pi}{40\\times 10^3}\\right]$ 弧度/米。\n  - 对于每个频带，在 $k$上使用 $64$ 个均匀间隔的样本。\n- 测试用例 A（理想路径）：$T_e^\\text{true} = 25$ 千米；噪声标准差 $(\\sigma_1, \\sigma_2, \\sigma_3) = (1.0\\times 10^{-8},\\, 1.5\\times 10^{-8},\\, 2.0\\times 10^{-8})$ 反平方秒。\n- 测试用例 B（薄板，低噪声）：$T_e^\\text{true} = 5$ 千米；$(\\sigma_1, \\sigma_2, \\sigma_3) = (1.0\\times 10^{-9},\\, 1.0\\times 10^{-9},\\, 1.0\\times 10^{-9})$ 反平方秒。\n- 测试用例 C（厚板，高噪声）：$T_e^\\text{true} = 50$ 千米；$(\\sigma_1, \\sigma_2, \\sigma_3) = (5.0\\times 10^{-8},\\, 5.0\\times 10^{-8},\\, 5.0\\times 10^{-8})$ 反平方秒。\n\n数值要求：\n- 使用带有固定种子的可复现随机数生成器来创建噪声实现。\n- 使用从 $2$ 到 $60$ 千米的 $T_e$ 搜索网格，间距为 $0.1$ 千米。\n- 在最大似然估计值处计算导数的有限差分步长必须为 $0.1$ 千米，并进行边界安全处理。\n\n最终输出格式：\n- 对于每个测试用例，独立报告一个列表，按顺序包含频带 $1$、$2$ 和 $3$ 的：该频带的最大似然估计值 $\\widehat{T}_{e,j}$（单位为千米）和分辨率 $\\sigma_{T_e,j}$（单位为千米）。将三个测试用例的列表聚合到一个单一列表中，并将它们打印在单行上，作为用方括号括起来的逗号分隔列表。例如：\n\"[[Te_hat_band1_caseA,res_band1_caseA,Te_hat_band2_caseA,res_band2_caseA,Te_hat_band3_caseA,res_band3_caseA],[...caseB...],[...caseC...]]\"。", "solution": "用户提供的问题被认为是有效的。它在科学上基于计算地球物理学的既定原理，特别是岩石圈弯曲理论和引力势场理论。该问题是适定的，提供了计算唯一解所必需的一整套完整且一致的物理常数、控制方程和数值参数。其目标和方法都以科学和数学的精确性进行了陈述，没有任何模糊之处。\n\n解决方案将遵循一种结构化的、基于原则的方法来实现。首先，我们将建立重力-地形导纳的理论正演模型。其次，我们将详细说明生成合成数据的数值程序。第三，我们将描述通过网格搜索来估计有效弹性厚度（$T_e$）的最大似然反演。最后，我们将概述使用费雪信息和克拉默-拉奥下界来量化估计分辨率的方法。\n\n**1. 理论框架：正演模型**\n\n问题的核心是预测重力-地形导纳 $Z$ 作为波数 $k$ 和有效弹性厚度 $T_e$ 函数的正演模型。\n\n模型始于薄弹性板的挠曲刚度 $D$，它量化了其抗弯曲能力。对于一个杨氏模量为 $E$、泊松比为 $\\nu$、有效弹性厚度为 $T_e$ 的板块，其挠曲刚度由下式给出：\n$$\nD(T_e) = \\frac{E T_e^3}{12 (1 - \\nu^2)}\n$$\n此处，$T_e$ 以千米为单位提供，但在物理计算中必须转换为米以保证量纲一致性。\n\n当施加表面载荷 $q_s(k)$（在谱域中）时，板块会发生垂直挠曲。这种挠曲由板块内部的弹性应力和下方流体地幔的浮力相平衡。对于一个漂浮在密度为 $\\rho_m$ 的流体上、处于重力加速度 $g$ 下的板块，其垂直挠度 $w(k)$与载荷的关系为：\n$$\n\\left(D k^4 + \\rho_m g\\right) w(k) = q_s(k)\n$$\n其中 $k$ 是径向波数。该方程代表了谱域中的力平衡。\n\n对于振幅为 $h(k)$、密度为 $\\rho_c$ 的表面地形载荷，载荷为 $q_s(k) = \\rho_c g h(k)$。将此代入平衡方程，我们可以求解挠度与地形的比值，该比值代表了均衡补偿：\n$$\n\\frac{w(k)}{h(k)} = \\frac{\\rho_c g}{D(T_e) k^4 + \\rho_m g}\n$$\n\n自由空气重力-地形导纳 $Z(k; T_e)$ 是重力异常与地形高度的比值。它源于两个主要来源：表面地形本身的质量和补偿性莫霍面挠度 $w(k)$ 造成的质量虧損。提供的模型是：\n$$\nZ(k; T_e) = 2\\pi G \\left[ \\Delta \\rho_t + \\Delta \\rho_m e^{-k z_m} \\frac{w(k)}{h(k)} \\right]\n$$\n代入 $w(k)/h(k)$ 的表达式，得到特定波数 $k$ 下导纳的完整正演模型：\n$$\nZ(k; T_e) = 2\\pi G \\left[ \\Delta \\rho_t + \\Delta \\rho_m e^{-k z_m} \\frac{\\rho_c g}{D(T_e) k^4 + \\rho_m g} \\right]\n$$\n其中 $G$ 是引力常数，$\\Delta \\rho_t$ 是地形相对于周围介质（空气，因此 $\\Delta \\rho_t = \\rho_c$）的密度差，$\\Delta \\rho_m$ 是穿过莫霍面的密度差，$z_m$ 是莫霍面的平均深度。项 $e^{-k z_m}$ 是向上延拓算子，它解释了从深度 $z_m$ 处的莫霍面到地表的引力信号衰减。\n\n最后，对于每个波数带 $j$，通过对该带内均匀采样的 $N_k=64$ 个波数集合上的 $Z(k; T_e)$ 取算術平均值，来计算带均导纳 $\\mu_j(T_e)$。\n\n**2. 合成数据生成**\n\n为了测试反演方法，我们首先生成合成的“观测”数据。对于一个给定的、具有已知真实弹性厚度 $T_e^{\\text{true}}$ 和指定噪声标准差 $(\\sigma_1, \\sigma_2, \\sigma_3)$ 的测试用例，我们对每个频带 $j$ 执行以下操作：\n1.  使用上述正演模型计算真实的带均导纳 $\\mu_j(T_e^{\\text{true}})$。\n2.  从一个均值为零、标准差为指定值 $\\sigma_j$ 的高斯（正态）分布中生成一个随机数。这是通过使用一个带种子的随机数生成器来实现的，以确保可复现性。\n3.  频带 $j$ 的合成观测值则为 $\\hat{Z_j} = \\mu_j(T_e^{\\text{true}}) + \\text{noise}$。\n\n**3. $T_e$ 的最大似然估计**\n\n目标是找到能最好地解释合成观测值 $\\hat{Z_j}$ 的 $T_e$ 值。假设噪声是高斯的，给定模型参数 $T_e$ 时观测到 $\\hat{Z_j}$ 的似然函数为：\n$$\n\\mathcal{L}(T_e | \\hat{Z_j}) \\propto \\exp\\left(-\\frac{1}{2}\\frac{(\\hat{Z_j} - \\mu_j(T_e))^2}{\\sigma_j^2}\\right)\n$$\n最大化似然函数 $\\mathcal{L}$（或其对数 $\\ln\\mathcal{L}$）等价于最小化残差平方项 $R(T_e) = (\\hat{Z_j} - \\mu_j(T_e))^2$。\n\n我们使用一维网格搜索来执行此最小化过程。创建一个候选 $T_e$ 值的网格，范围从 $2$ 到 $60$ 公里，步长为 $0.1$ 公里。对于每个频带 $j$，我们计算该网格上每个 $T_e$ 对应的模型预测值 $\\mu_j(T_e)$。然后，我们计算每个网格点的残差平方，并找出产生最小残差的 $T_e$ 值。这个值就是我们的最大似然估计值 $\\widehat{T}_{e,j}$。\n\n**4. 通过费雪信息进行分辨率分析**\n\n我们的估计值 $\\widehat{T}_{e,j}$ 的分辨率量化了数据对参数的约束程度。高分辨率（低不确定性）意味着 $T_e$ 的微小变化会在预测的导纳中产生大的变化，从而使参数易于确定。我们使用费雪信息 $\\mathcal{I}_j(T_e)$ 来量化这一点。对于单个高斯观测，其定义为：\n$$\n\\mathcal{I}_j(T_e) = \\left( \\frac{\\partial \\mu_j(T_e)}{\\partial T_e} \\right)^2 \\frac{1}{\\sigma_j^2}\n$$\n导数 $\\frac{\\partial \\mu_j(T_e)}{\\partial T_e}$ 衡量了模型对 $T_e$ 变化的敏感度。\n\n克拉默-拉奥下界（CRLB）指出，任何 $T_e$ 的无偏估计量的方差至少是费雪信息的倒数。我们使用 CRLB 导出的标准差作为分辨率的度量：\n$$\n\\sigma_{T_e,j} = \\sqrt{\\text{Var}(\\widehat{T}_{e,j})} \\ge \\mathcal{I}_j(T_e)^{-1/2}\n$$\n我们在我们的估计值 $\\widehat{T}_{e,j}$ 处计算这个界限：$\\sigma_{T_e,j} = \\mathcal{I}_j(\\widehat{T}_{e,j})^{-1/2}$。\n\n导数 $\\frac{\\partial \\mu_j}{\\partial T_e}$ 使用有限差分格式进行数值计算。由于我们已经在规则网格上计算了模型 $\\mu_j(T_e)$，并且指定的有限差分步长（$0.1$ 公里）与网格间距相匹配，因此我们可以利用其邻近点高效地近似计算与 $\\widehat{T}_{e,j}$ 对应的网格点处的导数。对于内部点，使用中心差分；而在网格边界处，则使用前向或后向差分以确保稳定性。使用的是相对于以千米为单位的 $T_e$ 的导数，因此得到的分辨率 $\\sigma_{T_e,j}$ 也以千米为单位。\n\n该实现封装了这些步骤，独立处理每个测试用例和每个频带，并按照指定格式输出最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs maximum likelihood inversion for Effective Elastic Thickness (EET)\n    and quantifies resolution using Fisher Information.\n    \"\"\"\n\n    # 1. Define physical constants and parameters in SI units\n    CONSTANTS = {\n        'E': 70e9,             # Young's modulus (Pa)\n        'nu': 0.25,            # Poisson's ratio\n        'rho_c': 2700.,        # Crust/load density (kg/m^3)\n        'rho_m': 3300.,        # Mantle density (kg/m^3)\n        'Delta_rho_t': 2700.,  # Topography density contrast (kg/m^3)\n        'Delta_rho_m': 600.,   # Moho density contrast (kg/m^3)\n        'g': 9.81,             # Gravitational acceleration (m/s^2)\n        'G': 6.67430e-11,      # Gravitational constant (m^3/kg/s^2)\n        'z_m': 35e3,           # Mean Moho depth (m)\n    }\n\n    # Define wavenumber bands and test cases\n    BANDS = [\n        (2 * np.pi / 500e3, 2 * np.pi / 200e3),  # Band 1: 200-500 km wavelength\n        (2 * np.pi / 200e3, 2 * np.pi / 80e3),   # Band 2: 80-200 km wavelength\n        (2 * np.pi / 80e3, 2 * np.pi / 40e3),    # Band 3: 40-80 km wavelength\n    ]\n    N_K_SAMPLES = 64\n\n    TEST_CASES = {\n        'A': {'Te_true_km': 25.0, 'sigmas': (1.0e-8, 1.5e-8, 2.0e-8)},\n        'B': {'Te_true_km': 5.0,  'sigmas': (1.0e-9, 1.0e-9, 1.0e-9)},\n        'C': {'Te_true_km': 50.0, 'sigmas': (5.0e-8, 5.0e-8, 5.0e-8)},\n    }\n    \n    # Numerical parameters for inversion\n    TE_GRID_KM = np.linspace(2.0, 60.0, int((60.0 - 2.0) / 0.1) + 1)\n    FD_STEP_KM = 0.1\n\n    # Initialize a reproducible random number generator\n    RNG = np.random.default_rng(seed=42)\n\n    def calculate_band_mean_admittance(k_range, Te_km, n_samples, consts):\n        \"\"\"\n        Computes the band-averaged gravity-topography admittance for a given Te.\n        \"\"\"\n        Te_m = Te_km * 1000.0  # Convert Te from km to m\n        _E, _nu, _rho_c, _rho_m, _Delta_rho_t, _Delta_rho_m, _g, _G, _z_m = (\n            consts['E'], consts['nu'], consts['rho_c'], consts['rho_m'],\n            consts['Delta_rho_t'], consts['Delta_rho_m'], consts['g'], \n            consts['G'], consts['z_m']\n        )\n\n        # Flexural rigidity D\n        D = (_E * Te_m**3) / (12 * (1 - _nu**2))\n\n        # Wavenumber samples for the band\n        k_vec = np.linspace(k_range[0], k_range[1], n_samples)\n        \n        # Admittance model Z(k; Te)\n        flexure_term = (_rho_c * _g) / (D * k_vec**4 + _rho_m * _g)\n        Z_k = 2 * np.pi * _G * (_Delta_rho_t + _Delta_rho_m * np.exp(-k_vec * _z_m) * flexure_term)\n\n        # Band-averaged admittance mu\n        return np.mean(Z_k)\n\n    all_results = []\n    \n    for case_id in ['A', 'B', 'C']:\n        case = TEST_CASES[case_id]\n        Te_true_km = case['Te_true_km']\n        sigmas = case['sigmas']\n        \n        case_results = []\n        \n        for band_idx, (k_range, sigma_j) in enumerate(zip(BANDS, sigmas)):\n            \n            # --- Generate Synthetic Data ---\n            mu_true = calculate_band_mean_admittance(k_range, Te_true_km, N_K_SAMPLES, CONSTANTS)\n            noise = RNG.normal(loc=0.0, scale=sigma_j)\n            Z_hat_j = mu_true + noise\n\n            # --- Maximum Likelihood Inversion (Grid Search) ---\n            mu_grid = np.array([\n                calculate_band_mean_admittance(k_range, te, N_K_SAMPLES, CONSTANTS) for te in TE_GRID_KM\n            ])\n            \n            residuals_sq = (Z_hat_j - mu_grid)**2\n            best_idx = np.argmin(residuals_sq)\n            Te_hat_km = TE_GRID_KM[best_idx]\n\n            # --- Quantify Resolution using Fisher Information ---\n            # Use pre-computed grid for efficient finite difference\n            if best_idx == 0:  # Forward difference at lower boundary\n                dmu_dTe = (mu_grid[1] - mu_grid[0]) / FD_STEP_KM\n            elif best_idx == len(TE_GRID_KM) - 1:  # Backward difference at upper boundary\n                dmu_dTe = (mu_grid[best_idx] - mu_grid[best_idx - 1]) / FD_STEP_KM\n            else:  # Central difference for interior points\n                dmu_dTe = (mu_grid[best_idx + 1] - mu_grid[best_idx - 1]) / (2 * FD_STEP_KM)\n\n            fisher_info = (dmu_dTe**2) / (sigma_j**2)\n\n            if fisher_info > 1e-30: # Avoid division by zero for flat likelihoods\n                resolution_km = 1.0 / np.sqrt(fisher_info)\n            else:\n                resolution_km = np.inf # Unconstrained\n\n            case_results.extend([Te_hat_km, resolution_km])\n            \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    case_strs = []\n    for res_list in all_results:\n        # Using repr to get good precision without scientific notation for these numbers\n        case_strs.append(f\"[{','.join(map(repr, res_list))}]\")\n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "3611244"}]}