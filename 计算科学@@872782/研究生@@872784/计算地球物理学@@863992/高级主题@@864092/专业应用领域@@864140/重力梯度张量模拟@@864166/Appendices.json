{"hands_on_practices": [{"introduction": "要真正掌握重力梯度张量建模，我们必须从第一性原理开始构建模型。该练习 [@problem_id:3602058] 将指导您完成将连续密度异常体离散化为体元网格，并通过对重力势进行数值微分来计算重力梯度张量的全过程。这项实践提供了核心计算技术（如有限差分法）的必要动手经验，并为理解后续更高级的方法奠定了坚实的基础。", "problem": "您需要基于第一性原理为三个测试案例实现一个重力梯度张量的数值模型。使用牛顿引力来模拟在均匀笛卡尔网格上离散化的体积密度异常体的引力势。重力梯度张量将通过使用有限差分对引力势进行数值微分来获得。您的程序必须以指定的物理单位和格式为每个测试案例输出量化结果。\n\n基本原理。从密度分布产生的牛顿引力势开始。对于三维空间中的质量密度场 $\\rho(\\mathbf{r}')$，在位置 $\\mathbf{r}$ 处的引力势 $\\Phi(\\mathbf{r})$ 为\n$$\n\\Phi(\\mathbf{r}) = G \\int_{\\mathbb{R}^3} \\frac{\\rho(\\mathbf{r}')}{\\|\\mathbf{r} - \\mathbf{r}'\\|} \\, dV',\n$$\n其中 $G$ 是引力常数。重力梯度张量 $\\mathbf{T}$ 定义为引力势的 Hessian 矩阵，\n$$\nT_{ij}(\\mathbf{r}) = \\frac{\\partial^2 \\Phi(\\mathbf{r})}{\\partial x_i \\, \\partial x_j},\n$$\n对于笛卡尔坐标 $\\{x_1,x_2,x_3\\} \\equiv \\{x,y,z\\}$。\n\n离散化策略。在每轴有 $N$ 个节点的奇数尺寸网格上，使用边长为 $h$ 的均匀体素来离散化密度场。将质量分布表示为体素中心处点质量的集合。对于密度为 $\\rho$、体素体积为 $h^3$ 的均匀密度异常体，每个被占用的体素质量为 $m = \\rho h^3$。通过黎曼和来近似点 $\\mathbf{r}$ 处的引力势\n$$\n\\Phi(\\mathbf{r}) \\approx G \\sum_{n=1}^{M} \\frac{m}{\\|\\mathbf{r} - \\mathbf{r}_n\\|},\n$$\n其中 $\\{\\mathbf{r}_n\\}_{n=1}^M$ 是被占用体素的中心。\n\n数值微分。使用网格间距为 $h$ 的二阶精度有限差分来近似网格节点上 $\\Phi$ 的二阶导数：\n\n- 对于内部节点上沿 $x$ 轴的纯二阶导数，\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x^2} \\bigg|_{i,j,k} \\approx \\frac{\\Phi_{i+1,j,k} - 2\\Phi_{i,j,k} + \\Phi_{i-1,j,k}}{h^2}.\n$$\n\n- 对于内部节点上的混合导数，例如 $\\partial^2 \\Phi / \\partial x \\partial y$，\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x \\partial y} \\bigg|_{i,j,k} \\approx \\frac{\\Phi_{i+1,j+1,k} - \\Phi_{i+1,j-1,k} - \\Phi_{i-1,j+1,k} + \\Phi_{i-1,j-1,k}}{4h^2}.\n$$\n\n- 在中心差分格式不可用的边界节点上，对纯二阶导数使用二阶精度的单边差分格式。例如，在沿 $z$ 轴的上边界使用后向差分，\n$$\n\\frac{\\partial^2 \\Phi}{\\partial z^2} \\bigg|_{i,j,K} \\approx \\frac{2\\Phi_{i,j,K} - 5\\Phi_{i,j,K-1} + 4\\Phi_{i,j,K-2} - \\Phi_{i,j,K-3}}{h^2}.\n$$\n\n坐标系与网格。使用一个 $N$ 为奇数的立方体网格，以使原点位于中心节点。设索引 $i,j,k \\in \\{0,1,\\dots,N-1\\}$。节点 $(i,j,k)$ 的物理坐标为\n$$\nx_i = \\left(i - \\frac{N-1}{2}\\right) h, \\quad y_j = \\left(j - \\frac{N-1}{2}\\right) h, \\quad z_k = \\left(k - \\frac{N-1}{2}\\right) h.\n$$\n\n物理常数与单位。使用引力常数 $G = 6.67430 \\times 10^{-11}$，单位为 $\\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}$。使用密度 $\\rho$（单位为 $\\mathrm{kg} \\, \\mathrm{m}^{-3}$），长度（单位为 $\\mathrm{m}$）。以 Eötvös 为单位表示重力梯度张量的分量，其中 $1$ Eötvös $= 10^{-9} \\, \\mathrm{s}^{-2}$。您的程序必须以 Eötvös 为单位输出每个要求的张量分量，并四舍五入到六位小数。\n\n测试套件与要求输出。所有案例均使用 $N = 33$ 和 $h = 100$ $\\mathrm{m}$。所有异常体均使用均匀密度 $\\rho = 2670$ $\\mathrm{kg} \\, \\mathrm{m}^{-3}$。通过选择坐标位于指定坐标轴对齐边界（含边界）内的所有体素中心来定义异常体素。\n\n- 测试案例 1（内部中心差分与迹约束）：一个边长为 $600$ $\\mathrm{m}$ 的单一均匀立方体异常体，中心位于原点，即被占用的体素中心满足 $x \\in [-300,300]$ $\\mathrm{m}$，$y \\in [-300,300]$ $\\mathrm{m}$，$z \\in [-300,300]$ $\\mathrm{m}$。在坐标为 $(x,y,z) = (0,0,500)$ $\\mathrm{m}$ 的节点处进行评估。计算该点的纯二阶导数以形成迹 $S = T_{xx} + T_{yy} + T_{zz}$。以 Eötvös 为单位输出 $S$，四舍五入到六位小数。\n\n- 测试案例 2（混合导数对称性）：两个相同的均匀立方体异常体，每个边长为 $400$ $\\mathrm{m}$，中心分别位于 $(x,y,z) = (-600,0,0)$ $\\mathrm{m}$ 和 $(x,y,z) = (600,0,0)$ $\\mathrm{m}$。即，左侧立方体被占用的体素中心满足 $x \\in [-800,-400]$ $\\mathrm{m}$，$y \\in [-200,200]$ $\\mathrm{m}$，$z \\in [-200,200]$ $\\mathrm{m}$，右侧立方体满足 $x \\in [400,800]$ $\\mathrm{m}$，y 和 z 边界相同。在原点 $(0,0,0)$ $\\mathrm{m}$ 处进行评估。使用中心差分计算该点的混合导数 $T_{xy}$。以 Eötvös 为单位输出 $T_{xy}$，四舍五入到六位小数。\n\n- 测试案例 3（边界单边差分格式）：一个边长为 $400$ $\\mathrm{m}$ 的单一均匀立方体异常体，中心位于 $(x,y,z) = (0,0,-700)$ $\\mathrm{m}$，即被占用的体素中心满足 $x \\in [-200,200]$ $\\mathrm{m}$，$y \\in [-200,200]$ $\\mathrm{m}$，$z \\in [-900,-500]$ $\\mathrm{m}$。在顶部边界节点 $(x,y,z) = (0,0,1600)$ $\\mathrm{m}$ 处进行评估。使用二阶精度的单边后向差分格式计算 $T_{zz}$。以 Eötvös 为单位输出 $T_{zz}$，四舍五入到六位小数。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个以逗号分隔的列表，用方括号括起来，顺序为 $[S_{\\text{case 1}}, T_{xy,\\text{case 2}}, T_{zz,\\text{case 3}}]$，例如，“[1.234567,0.000001,-0.123456]”。所有三个数字都必须以 Eötvös 为单位，并四舍五入到六位小数，列表中没有空格。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上以牛顿物理学为基础，在数学上是适定的、客观的且自洽的。所提供的参数和测试案例是一致的，能够得出一个唯一的、有意义的解。因此，我们可以继续开发计算模型。\n\n任务是实现一个数值模型，用于计算三种不同质量异常体构型下的重力梯度张量 $\\mathbf{T}$ 的分量。该模型基于牛顿引力的第一性原理，并采用离散化和数值微分方法。\n\n**1. 基本原理：引力势**\n\n由连续质量密度分布 $\\rho(\\mathbf{r}')$ 在位置 $\\mathbf{r}$ 处产生的引力势 $\\Phi$ 由以下体积积分给出：\n$$\n\\Phi(\\mathbf{r}) = G \\int_{\\mathbb{R}^3} \\frac{\\rho(\\mathbf{r}')}{\\|\\mathbf{r} - \\mathbf{r}'\\|} \\, dV'\n$$\n其中 $G = 6.67430 \\times 10^{-11} \\, \\mathrm{m}^3 \\, \\mathrm{kg}^{-1} \\, \\mathrm{s}^{-2}$ 是引力常数。\n\n**2. 离散化策略**\n\n为便于数值计算，我们将连续密度异常体建模为离散点质量的集合。源体积被离散化为一个由体素组成的均匀网格，每个体素的边长为 $h = 100 \\, \\mathrm{m}$。对于均匀密度异常体 $\\rho = 2670 \\, \\mathrm{kg} \\, \\mathrm{m}^{-3}$，每个体素由位于其几何中心的点质量 $m = \\rho h^3$ 表示。因此，引力势的积分可以用黎曼和来近似：\n$$\n\\Phi(\\mathbf{r}) \\approx G \\sum_{n=1}^{M} \\frac{m}{\\|\\mathbf{r} - \\mathbf{r}_n\\|}\n$$\n这里，$\\{\\mathbf{r}_n\\}_{n=1}^M$ 是构成密度异常体的 $M$ 个体素中心的坐标向量。用于计算引力势的评估点 $\\mathbf{r}$ 与所有质量点位置 $\\mathbf{r}_n$ 均不相同，从而避免了奇异点。\n\n**3. 通过数值微分计算重力梯度张量**\n\n重力梯度张量 $\\mathbf{T}$ 是引力势的 Hessian 矩阵，其分量为 $T_{ij}(\\mathbf{r}) = \\frac{\\partial^2 \\Phi(\\mathbf{r})}{\\partial x_i \\, \\partial x_j}$。我们在计算网格上使用有限差分公式来近似这些二阶导数。问题指定了二阶精度的差分格式。\n\n**4. 测试案例的实现**\n\n建立一个计算网格，每轴有 $N=33$ 个节点，间距为 $h=100 \\, \\mathrm{m}$。坐标以原点为中心，任意轴上索引为 $k \\in \\{0, \\dots, N-1\\}$ 的节点的物理坐标为 $(k - \\frac{N-1}{2})h = (k - 16)h$。\n\n对每个测试案例，执行以下步骤：\n1.  识别出满足给定异常体几何边界的体素中心坐标集 $\\{\\mathbf{r}_n\\}$。\n2.  围绕指定的评估点 $\\mathbf{r}_{\\text{eval}}$ 定义所需的差分格式点。\n3.  使用离散化公式计算每个差分格式点上的引力势 $\\Phi$。\n4.  应用适当的有限差分公式计算所需的张量分量。\n5.  将结果乘以 $10^9$，从国际单位制（$\\mathrm{s}^{-2}$）转换为 Eötvös（$1 \\text{ Eötvös} = 10^{-9} \\, \\mathrm{s}^{-2}$）。\n\n**测试案例 1：内部点的迹**\n-   **异常体：**由体素中心坐标满足 $x, y, z \\in [-300, 300] \\, \\mathrm{m}$ 的单个立方体定义。\n-   **评估点：**$\\mathbf{r}_{\\text{eval}} = (0, 0, 500) \\, \\mathrm{m}$。这是计算网格的一个内部节点。\n-   **任务：**计算迹 $S = T_{xx} + T_{yy} + T_{zz}$。\n-   **方法：**使用二阶中心差分格式计算纯二阶导数：\n    $$\n    T_{xx}(\\mathbf{r}) \\approx \\frac{\\Phi(x+h, y, z) - 2\\Phi(x, y, z) + \\Phi(x-h, y, z)}{h^2}\n    $$\n    对 $T_{yy}$ 和 $T_{zz}$ 使用类似的公式。三个差分格式共需要九次引力势计算（部分点是共用的）。评估点位于质量分布之外，在该区域引力势满足 Laplace 方程，$\\nabla^2 \\Phi = T_{xx} + T_{yy} + T_{zz} = 0$。因此，计算出的数值迹 $S$ 应该是一个很小的值，代表了数值近似的误差。\n\n**测试案例 2：原点处的混合导数**\n-   **异常体：**两个立方体，一个满足 $x \\in [-800, -400] \\, \\mathrm{m}$，另一个满足 $x \\in [400, 800] \\, \\mathrm{m}$，两者都满足 $y, z \\in [-200, 200] \\, \\mathrm{m}$。\n-   **评估点：**$\\mathbf{r}_{\\text{eval}} = (0, 0, 0) \\, \\mathrm{m}$。\n-   **任务：**计算混合导数 $T_{xy}$。\n-   **方法：**使用二阶中心差分格式计算混合导数：\n    $$\n    T_{xy}(\\mathbf{r}) \\approx \\frac{\\Phi(x+h, y+h, z) - \\Phi(x+h, y-h, z) - \\Phi(x-h, y+h, z) + \\Phi(x-h, y-h, z)}{4h^2}\n    $$\n    质量分布关于 x-z 平面（即 $y=0$ 处）对称。这种对称性意味着 $\\Phi(x, y, z) = \\Phi(x, -y, z)$，因此 $\\frac{\\partial \\Phi}{\\partial y}$ 在 x-z 平面上的任何地方都必须为零。因此，$T_{xy} = \\frac{\\partial}{\\partial x}(\\frac{\\partial \\Phi}{\\partial y})$ 在原点也必须为零。数值结果预计接近于零，受浮点精度限制。\n\n**测试案例 3：边界处的纯导数**\n-   **异常体：**由 $x, y \\in [-200, 200] \\, \\mathrm{m}$ 和 $z \\in [-900, -500] \\, \\mathrm{m}$ 定义的单个立方体。\n-   **评估点：**$\\mathbf{r}_{\\text{eval}} = (0, 0, 1600) \\, \\mathrm{m}$。此坐标对应于索引为 $k=32$ 的节点，该节点是网格的顶部边界（$k_{\\text{max}} = N-1 = 32$）。\n-   **任务：**计算 $T_{zz}$。\n-   **方法：**由于网格内无法获取前向差分点，必须使用指定的二阶精度单边后向差分公式：\n    $$\n    T_{zz}(\\mathbf{r}) \\approx \\frac{2\\Phi(x, y, z) - 5\\Phi(x, y, z-h) + 4\\Phi(x, y, z-2h) - \\Phi(x, y, z-3h)}{h^2}\n    $$\n    这需要计算评估点本身以及其下方沿 z 轴的三个点的引力势。\n\n最终的实现将这些步骤封装到一个程序中，该程序计算并按指定格式输出三个所要求的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes gravity gradient tensor components for three test cases.\n    \"\"\"\n    # Physical constants and parameters\n    G = 6.67430e-11  # m^3 kg^-1 s^-2\n    RHO = 2670.0      # kg m^-3\n    N = 33            # Grid nodes per axis\n    H = 100.0         # m, grid spacing / voxel edge length\n    MASS = RHO * H**3 # kg, mass of a single voxel\n    EOTVOS_CONVERSION = 1e9\n\n    def get_mass_locations(case_params):\n        \"\"\"\n        Generates the coordinates of voxel centers for a given anomaly definition.\n        \n        Args:\n            case_params (list of tuples): Each tuple contains (min_coord, max_coord)\n                                          for x, y, z axes respectively.\n        \n        Returns:\n            np.ndarray: An (M, 3) array of mass point coordinates.\n        \"\"\"\n        all_mass_locs = []\n        for x_bounds, y_bounds, z_bounds in case_params:\n            x_coords = np.arange(x_bounds[0], x_bounds[1] + 1, H)\n            y_coords = np.arange(y_bounds[0], y_bounds[1] + 1, H)\n            z_coords = np.arange(z_bounds[0], z_bounds[1] + 1, H)\n            \n            xx, yy, zz = np.meshgrid(x_coords, y_coords, z_coords, indexing='ij')\n            mass_locs = np.vstack([xx.ravel(), yy.ravel(), zz.ravel()]).T\n            all_mass_locs.append(mass_locs)\n        \n        if not all_mass_locs:\n            return np.empty((0, 3))\n        \n        return np.vstack(all_mass_locs)\n\n    def compute_potential(eval_point, mass_locations):\n        \"\"\"\n        Calculates the gravitational potential at a single evaluation point.\n        \n        Args:\n            eval_point (tuple or np.ndarray): The (x, y, z) coordinate for evaluation.\n            mass_locations (np.ndarray): An (M, 3) array of mass point coordinates.\n\n        Returns:\n            float: The gravitational potential in SI units (m^2 s^-2).\n        \"\"\"\n        if mass_locations.shape[0] == 0:\n            return 0.0\n\n        eval_point = np.array(eval_point)\n        diffs = eval_point - mass_locations\n        distances = np.linalg.norm(diffs, axis=1)\n        \n        # The problem is set up to avoid singularities (distances > 0)\n        potential_contribs = MASS / distances\n        total_potential = G * np.sum(potential_contribs)\n        return total_potential\n\n    results = []\n\n    # --- Test Case 1: Trace S at (0, 0, 500) m ---\n    case1_params = [((-300.0, 300.0), (-300.0, 300.0), (-300.0, 300.0))]\n    mass_locs_1 = get_mass_locations(case1_params)\n    r_eval_1 = (0.0, 0.0, 500.0)\n    \n    phi_center = compute_potential(r_eval_1, mass_locs_1)\n    \n    # T_xx\n    phi_xp1 = compute_potential((r_eval_1[0] + H, r_eval_1[1], r_eval_1[2]), mass_locs_1)\n    phi_xm1 = compute_potential((r_eval_1[0] - H, r_eval_1[1], r_eval_1[2]), mass_locs_1)\n    T_xx = (phi_xp1 - 2 * phi_center + phi_xm1) / (H**2)\n    \n    # T_yy\n    phi_yp1 = compute_potential((r_eval_1[0], r_eval_1[1] + H, r_eval_1[2]), mass_locs_1)\n    phi_ym1 = compute_potential((r_eval_1[0], r_eval_1[1] - H, r_eval_1[2]), mass_locs_1)\n    T_yy = (phi_yp1 - 2 * phi_center + phi_ym1) / (H**2)\n    \n    # T_zz\n    phi_zp1 = compute_potential((r_eval_1[0], r_eval_1[1], r_eval_1[2] + H), mass_locs_1)\n    phi_zm1 = compute_potential((r_eval_1[0], r_eval_1[1], r_eval_1[2] - H), mass_locs_1)\n    T_zz = (phi_zp1 - 2 * phi_center + phi_zm1) / (H**2)\n    \n    S_case1 = T_xx + T_yy + T_zz\n    results.append(S_case1 * EOTVOS_CONVERSION)\n\n    # --- Test Case 2: T_xy at (0, 0, 0) m ---\n    case2_params = [\n        ((-800.0, -400.0), (-200.0, 200.0), (-200.0, 200.0)),\n        ((400.0, 800.0), (-200.0, 200.0), (-200.0, 200.0))\n    ]\n    mass_locs_2 = get_mass_locations(case2_params)\n    r_eval_2 = (0.0, 0.0, 0.0)\n    \n    phi_xp1_yp1 = compute_potential((r_eval_2[0] + H, r_eval_2[1] + H, r_eval_2[2]), mass_locs_2)\n    phi_xp1_ym1 = compute_potential((r_eval_2[0] + H, r_eval_2[1] - H, r_eval_2[2]), mass_locs_2)\n    phi_xm1_yp1 = compute_potential((r_eval_2[0] - H, r_eval_2[1] + H, r_eval_2[2]), mass_locs_2)\n    phi_xm1_ym1 = compute_potential((r_eval_2[0] - H, r_eval_2[1] - H, r_eval_2[2]), mass_locs_2)\n    \n    T_xy_case2 = (phi_xp1_yp1 - phi_xp1_ym1 - phi_xm1_yp1 + phi_xm1_ym1) / (4 * H**2)\n    results.append(T_xy_case2 * EOTVOS_CONVERSION)\n\n    # --- Test Case 3: T_zz at (0, 0, 1600) m ---\n    case3_params = [((-200.0, 200.0), (-200.0, 200.0), (-900.0, -500.0))]\n    mass_locs_3 = get_mass_locations(case3_params)\n    r_eval_3 = (0.0, 0.0, 1600.0)\n    \n    phi_k = compute_potential(r_eval_3, mass_locs_3)\n    phi_km1 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - H), mass_locs_3)\n    phi_km2 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - 2 * H), mass_locs_3)\n    phi_km3 = compute_potential((r_eval_3[0], r_eval_3[1], r_eval_3[2] - 3 * H), mass_locs_3)\n    \n    T_zz_case3 = (2 * phi_k - 5 * phi_km1 + 4 * phi_km2 - phi_km3) / (H**2)\n    results.append(T_zz_case3 * EOTVOS_CONVERSION)\n\n    # Final print statement in the exact required format.\n    # The format string \"{:.6f}\" handles rounding to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3602058"}, {"introduction": "重力梯度张量包含丰富的信息，但其九个分量可能难以直接解释。这项实践 [@problem_id:3602059] 介绍了张量不变量这一强大概念，它如同“指纹”一样，能够表征异常体的内在几何形态。通过编写一个算法来对球体和线性体等典型几何形态进行分类，您将学习如何从重力梯度张量数据中提取具有地质意义的见解，这是任何计算地球物理学家都需具备的关键技能。", "problem": "您需要编写一个完整的、自包含的程序，该程序计算重力梯度张量 (GGT) 的不变量组合，以对典型异常几何形态进行分类。从牛顿引力势和重力梯度张量的定义出发，推导并实现针对几种几何形态的张量模型，计算不变量，然后基于这些不变量对几何形态进行分类。\n\n使用的科学和数学基础：\n- 牛顿引力势：$$\\Phi(\\mathbf{x}) = G \\int \\frac{\\rho(\\mathbf{x}')}{\\|\\mathbf{x} - \\mathbf{x}'\\|} \\, dV',$$ 其中 $G$ 是引力常数，$\\rho$ 是质量密度，$\\mathbf{x}$ 是观测点。\n- 重力梯度张量 (GGT)：$$T_{ij}(\\mathbf{x}) = \\frac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}.$$\n- 不变量：$$I_2 = \\frac{1}{2}\\left[(\\operatorname{tr} T)^2 - \\operatorname{tr}(T^2)\\right], \\quad I_3 = \\det T.$$\n\n任务：\n1. 使用上述基本定义，为以下每种典型几何形态在指定的观测点推导并实现 GGT $T$：\n   - 位于原点、质量为 $m$ 的点质量。\n   - 沿 $y$ 轴对齐、线密度为 $\\lambda$ 的无限长直线质量。\n   - 位于 $z=0$、面密度为 $\\sigma$ 的无限大平面薄层。\n   - 密度为 $\\rho$、半径为 $a$ 的均匀实心球体，观测点位于球体内部或外部。\n\n2. 对于测试套件中提供的每种几何形态和参数集，在给定的观测点 $\\mathbf{x}$ 计算张量 $T$，然后计算不变量 $I_2$ 和 $I_3$、迹 $\\operatorname{tr} T$ 以及弗罗贝尼乌斯范数尺度 $$s = \\sqrt{\\operatorname{tr}(T^2)}.$$\n\n3. 基于以下使用不变量的决策规则对几何形态进行分类。使用量纲一致的绝对和相对阈值：\n   - 定义 $$\\varepsilon = 10^{-30} \\, \\mathrm{s}^{-2}, \\quad t = \\frac{|\\operatorname{tr} T|}{s + \\delta}, \\quad d = \\frac{|I_3|}{(s + \\delta)^3},$$ 其中 $\\delta = 10^{-300}$ 是一个在 $s=0$ 时避免除以零的保护值。$s$ 的单位是 $\\mathrm{s}^{-2}$，因此 $\\varepsilon$ 与其单位相同。比率 $t$ 和 $d$ 是无量纲的。\n   - 决策规则：\n     - 如果 $s \\le \\varepsilon$，分类为 $0$ (类平面体或有效零梯度区域)。\n     - 否则，如果 $t \\le 10^{-12}$ 且 $d \\le 10^{-12}$，分类为 $1$ (类线体，具有一个零特征值和零行列式)。\n     - 否则，如果 $t \\le 10^{-12}$ 且 $I_3 > 0$ 且 $I_2  0$，分类为 $2$ (类点体，在无源区域中观测到的紧凑源，其迹为零且行列式为正)。\n     - 否则，如果 $t > 10^{-12}$ 且 $I_3  0$，分类为 $3$ (体积内部区域，例如均匀球体内部)。\n     - 否则，分类为 $2$。\n\n物理常数和单位：\n- 使用 $$G = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}.$$\n- 所有距离单位为 $\\mathrm{m}$，质量单位为 $\\mathrm{kg}$，密度单位为 $\\mathrm{kg/m^3}$，线密度单位为 $\\mathrm{kg/m}$，面密度单位为 $\\mathrm{kg/m^2}$。重力梯度张量分量 $T_{ij}$ 必须以 $\\mathrm{s}^{-2}$ 为单位计算。\n\n测试套件：\n计算并分类以下五个案例：\n- 案例 1：位于原点的点质量，$$m = 5 \\times 10^{12} \\, \\mathrm{kg}, \\quad \\mathbf{x} = (100, 0, 0) \\, \\mathrm{m}.$$\n- 案例 2：沿 $y$ 轴的无限长直线质量，$$\\lambda = 1 \\times 10^{9} \\, \\mathrm{kg/m}, \\quad \\mathbf{x} = (50, 0, 50) \\, \\mathrm{m}.$$\n- 案例 3：位于 $z=0$ 的无限大平面薄层，$$\\sigma = 3.0 \\times 10^{3} \\, \\mathrm{kg/m^2}, \\quad \\mathbf{x} = (0, 0, 100) \\, \\mathrm{m}.$$\n- 案例 4：均匀球体，$$\\rho = 2.5 \\times 10^{3} \\, \\mathrm{kg/m^3}, \\quad a = 50 \\, \\mathrm{m}, \\quad \\mathbf{x} = (10, 0, 0) \\, \\mathrm{m} \\text{ (内部)}.$$\n- 案例 5：与案例 4 相同的球体，在外部观测，$$\\mathbf{x} = (200, 0, 0) \\, \\mathrm{m}.$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个案例的整数分类代码，格式为方括号内以逗号分隔的列表，例如 $$[c_1,c_2,c_3,c_4,c_5],$$ 其中每个 $c_i$ 是由上述决策规则生成的整数。", "solution": "该问题要求开发一种计算方法，以基于重力梯度张量 (GGT) 的不变量对典型质量几何形态进行分类。这包括为几种理想化的质量分布推导 GGT，以数值方式实现这些模型，然后应用一个基于张量不变量的特定决策树。\n\n基本原理是牛顿引力势和 GGT 的定义。由密度为 $\\rho$ 的质量分布在观测点 $\\mathbf{x}$ 产生的引力势 $\\Phi$ 由下式给出\n$$\\Phi(\\mathbf{x}) = G \\int \\frac{\\rho(\\mathbf{x}')}{\\|\\mathbf{x} - \\mathbf{x}'\\|} \\, dV'$$\n其中 $G$ 是引力常数，积分范围是源的体积。GGT，记为 $T$，是一个对称张量，其分量 $T_{ij}$ 是引力势的二阶偏导数：\n$$T_{ij}(\\mathbf{x}) = \\frac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}$$\nGGT 的迹 $\\operatorname{tr}(T) = \\sum_i T_{ii}$ 通过引力的泊松方程 $\\nabla^2 \\Phi = -4\\pi G \\rho$ 与局部质量密度相关。因此，$\\operatorname{tr}(T) = -4\\pi G \\rho(\\mathbf{x})$。在 $\\rho(\\mathbf{x})=0$ 的无源区域，GGT 的迹为零。\n\n解决方案分两个阶段进行：首先，为每种指定的几何形态推导 GGT；其次，使用这些张量模型实现分类算法。\n\n**1. 重力梯度张量模型的推导**\n\n设观测点为 $\\mathbf{r} = (x, y, z)$。GGT 分量由每种几何形态的引力势 $\\Phi$ 推导而来。\n\n**A. 位于原点的点质量**\n对于位于原点的点质量 $m$，在位置 $\\mathbf{r}$ (其大小为 $r = \\|\\mathbf{r}\\| = \\sqrt{x^2+y^2+z^2}$) 的引力势为 $\\Phi(r) = Gm/r$。通过求二阶导数可找到 GGT 分量 $T_{ij}$：\n$$T_{ij} = \\frac{\\partial^2}{\\partial x_i \\partial x_j} \\left(\\frac{Gm}{r}\\right) = Gm \\left( \\frac{3x_i x_j}{r^5} - \\frac{\\delta_{ij}}{r^3} \\right)$$\n其中 $\\delta_{ij}$ 是克罗内克δ。其矩阵形式为：\n$$ T = \\frac{Gm}{r^5} \\begin{pmatrix} 3x^2 - r^2  3xy  3xz \\\\ 3xy  3y^2 - r^2  3yz \\\\ 3xz  3yz  3z^2 - r^2 \\end{pmatrix} $$\n迹为 $\\operatorname{tr}(T) = \\frac{Gm}{r^5} (3(x^2+y^2+z^2) - 3r^2) = 0$，这与在无源区域的预期相符。\n\n**B. 无限长直线质量**\n对于沿 $y$ 轴对齐、线密度为 $\\lambda$ 的无限长直线质量，在点 $(x, y, z)$ 的引力势仅取决于到直线的垂直距离 $R = \\sqrt{x^2+z^2}$。根据问题中 $\\Phi$ 的定义，其引力势为 $\\Phi(R) = -G\\lambda \\ln(R^2) = -2G\\lambda \\ln(R)$ (这是一个在物理上有问题的势，但在数学上是明确的)。\n通过对 $\\Phi = -G\\lambda \\ln(x^2+z^2)$求导来计算 GGT 分量。\n$$T_{xx} = \\frac{\\partial^2 \\Phi}{\\partial x^2} = -2G\\lambda \\frac{\\partial}{\\partial x}\\left(\\frac{x}{x^2+z^2}\\right) = 2G\\lambda \\frac{x^2-z^2}{(x^2+z^2)^2}$$\n$$T_{zz} = \\frac{\\partial^2 \\Phi}{\\partial z^2} = 2G\\lambda \\frac{z^2-x^2}{(x^2+z^2)^2}$$\n$$T_{xz} = \\frac{\\partial^2 \\Phi}{\\partial x \\partial z} = -2G\\lambda \\frac{\\partial}{\\partial z}\\left(\\frac{x}{x^2+z^2}\\right) = 4G\\lambda \\frac{xz}{(x^2+z^2)^2}$$\n所有其他分量，包括 $T_{yy}$ 和涉及对 $y$ 求导的分量，均为零。得到的张量为：\n$$ T = \\frac{2G\\lambda}{(x^2+z^2)^2} \\begin{pmatrix} x^2 - z^2  0  2xz \\\\ 0  0  0 \\\\ 2xz  0  z^2 - x^2 \\end{pmatrix} $$\n迹和行列式均为零。\n\n**C. 无限大平面薄层**\n对于位于 $z=0$ 平面、面密度为 $\\sigma$ 的无限大质量薄层，其引力场是均匀的。由于对于任何 $z \\neq 0$，场都是恒定的，其梯度为零。\n$$ T_{ij} = \\frac{\\partial g_i}{\\partial x_j} = 0 $$\n因此，对于不在薄层上的任何观测点，GGT 都是零矩阵。\n\n**D. 均匀实心球体**\n对于半径为 $a$、密度恒为 $\\rho$ 的球体，我们有两种情况。\n- **球体外部 ($r > a$)**：根据牛顿壳层定理，球体的作用如同一个位于原点、质量为 $M = \\frac{4}{3}\\pi a^3 \\rho$ 的点质量。因此，其 GGT 与点质量情况相同，只是用 $M$ 替换了 $m$。\n- **球体内部 ($r  a$)**：引力势为 $\\Phi(r) = \\frac{2\\pi G \\rho}{3}(3a^2 - r^2)$。\n其二阶导数很容易计算：\n$$T_{xx} = \\frac{\\partial^2 \\Phi}{\\partial x^2} = \\frac{\\partial}{\\partial x}\\left(-\\frac{4\\pi G \\rho}{3}x\\right) = -\\frac{4\\pi G \\rho}{3}$$\n类似地，$T_{yy} = T_{zz} = -\\frac{4\\pi G \\rho}{3}$。非对角线分量为零。GGT 是单位矩阵 $I$ 的一个标量倍：\n$$ T = -\\frac{4\\pi G \\rho}{3} I $$\n迹为 $\\operatorname{tr}(T) = -4\\pi G \\rho$，这与质量分布内部一点的泊松方程相符。\n\n**2. 分类算法**\n\n分类是使用一个基于几个计算量的决策树来执行的：\n- 迹 $\\operatorname{tr}(T)$。\n- 弗罗贝尼乌斯范数尺度 $s = \\sqrt{\\operatorname{tr}(T^2)}$。\n- 不变量 $I_2 = \\frac{1}{2}\\left[(\\operatorname{tr} T)^2 - \\operatorname{tr}(T^2)\\right]$ 和 $I_3 = \\det T$。\n- 无量纲比率 $t = \\frac{|\\operatorname{tr} T|}{s + \\delta}$ 和 $d = \\frac{|I_3|}{(s + \\delta)^3}$，其中有一个小的保护值 $\\delta=10^{-300}$。\n\n分类规则按顺序应用：\n1.  如果 $s \\le 10^{-30} \\, \\mathrm{s}^{-2}$：分类为 $0$ (平面体或零梯度)。\n2.  否则，如果 $t \\le 10^{-12}$ 且 $d \\le 10^{-12}$：分类为 $1$ (类线体)。\n3.  否则，如果 $t \\le 10^{-12}$，$I_3 > 0$ 且 $I_2  0$：分类为 $2$ (类点体)。\n4.  否则，如果 $t > 10^{-12}$ 且 $I_3  0$：分类为 $3$ (体积内部)。\n5.  否则：分类为 $2$。\n\n**测试案例应用**\n\n- **案例 1 (点质量)**：$m = 5 \\times 10^{12} \\, \\mathrm{kg}$, $\\mathbf{x}=(100, 0, 0)\\,\\mathrm{m}$。张量是对角的，其特征值与 $(2, -1, -1)$ 成比例。这导致 $\\operatorname{tr}(T)=0$ ($t=0$)，$I_3 > 0$ 且 $I_2  0$。$d$ 的值不可忽略。根据规则，分类代码为 $2$。\n- **案例 2 (直线质量)**：$\\lambda = 1 \\times 10^{9} \\, \\mathrm{kg/m}$, $\\mathbf{x}=(50, 0, 50)\\,\\mathrm{m}$。张量有一个零行和一个零列，导致 $\\operatorname{tr}(T)=0$ 和 $I_3=0$。因此，$t=0$ 且 $d=0$。根据规则，分类代码为 $1$。\n- **案例 3 (平面薄层)**：$\\sigma = 3.0 \\times 10^{3} \\, \\mathrm{kg/m^2}$, $\\mathbf{x}=(0, 0, 100)\\,\\mathrm{m}$。GGT 是零矩阵。$s=0$，因此应用第一条规则。分类为 $0$。\n- **案例 4 (球体内部)**：$\\rho = 2.5 \\times 10^{3} \\, \\mathrm{kg/m^3}$, $a=50\\,\\mathrm{m}$, $\\mathbf{x}=(10, 0, 0)\\,\\mathrm{m}$。张量是单位矩阵的负数倍。$\\operatorname{tr}(T)$ 非零，使得 $t > 10^{-12}$。$I_3$ 是负数。根据规则，分类代码为 $3$。\n- **案例 5 (球体外部)**：同一球体，$\\mathbf{x}=(200, 0, 0)\\,\\mathrm{m}$。观测点在球体外部，因此球体的行为与点质量相同。分析与案例 1 相同。分类为 $2$。\n\n最终的分类代码序列是 $[2, 1, 0, 3, 2]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes invariant combinations of the Gravity Gradient Tensor (GGT)\n    to classify canonical anomaly geometries for a given set of test cases.\n    \"\"\"\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    \n    # Classification parameters\n    EPSILON = 1e-30\n    DELTA = 1e-300\n    T_THRESH = 1e-12\n    D_THRESH = 1e-12\n\n    def compute_ggt_point(m, x_obs):\n        \"\"\"Computes GGT for a point mass at the origin.\"\"\"\n        r = np.linalg.norm(x_obs)\n        if r == 0:\n            return np.full((3, 3), np.inf)\n        \n        r_inv3 = 1.0 / r**3\n        r_inv5 = 1.0 / r**5\n        \n        T = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                delta_ij = 1 if i == j else 0\n                T[i, j] = G * m * (3 * x_obs[i] * x_obs[j] * r_inv5 - delta_ij * r_inv3)\n        return T\n\n    def compute_ggt_line(lambda_val, x_obs):\n        \"\"\"Computes GGT for an infinite line mass along the y-axis.\"\"\"\n        x, _, z = x_obs\n        R2 = x**2 + z**2\n        if R2 == 0:\n            return np.full((3, 3), np.inf)\n\n        factor = 2 * G * lambda_val / (R2**2)\n        T = np.zeros((3, 3))\n        T[0, 0] = factor * (x**2 - z**2)\n        T[0, 2] = T[2, 0] = factor * (2 * x * z)\n        T[2, 2] = factor * (z**2 - x**2)\n        return T\n\n    def compute_ggt_sheet(sigma, x_obs):\n        \"\"\"Computes GGT for an infinite plane sheet at z=0.\"\"\"\n        # GGT is zero everywhere off the plane\n        return np.zeros((3, 3))\n\n    def compute_ggt_sphere(rho, a, x_obs):\n        \"\"\"Computes GGT for a homogeneous sphere.\"\"\"\n        r = np.linalg.norm(x_obs)\n        if r  a:  # Outside sphere\n            M = (4.0 / 3.0) * np.pi * (a**3) * rho\n            return compute_ggt_point(M, x_obs)\n        else:  # Inside sphere\n            factor = -4.0 * np.pi * G * rho / 3.0\n            return factor * np.identity(3)\n\n    test_cases = [\n        {'type': 'point', 'params': {'m': 5e12}, 'x_obs': np.array([100.0, 0.0, 0.0])},\n        {'type': 'line', 'params': {'lambda_val': 1e9}, 'x_obs': np.array([50.0, 0.0, 50.0])},\n        {'type': 'sheet', 'params': {'sigma': 3e3}, 'x_obs': np.array([0.0, 0.0, 100.0])},\n        {'type': 'sphere', 'params': {'rho': 2.5e3, 'a': 50.0}, 'x_obs': np.array([10.0, 0.0, 0.0])},\n        {'type': 'sphere', 'params': {'rho': 2.5e3, 'a': 50.0}, 'x_obs': np.array([200.0, 0.0, 0.0])},\n    ]\n\n    results = []\n    for case in test_cases:\n        T = np.zeros((3, 3))\n        if case['type'] == 'point':\n            T = compute_ggt_point(case['params']['m'], case['x_obs'])\n        elif case['type'] == 'line':\n            T = compute_ggt_line(case['params']['lambda_val'], case['x_obs'])\n        elif case['type'] == 'sheet':\n            T = compute_ggt_sheet(case['params']['sigma'], case['x_obs'])\n        elif case['type'] == 'sphere':\n            T = compute_ggt_sphere(case['params']['rho'], case['params']['a'], case['x_obs'])\n\n        # Compute invariants and classification parameters\n        tr_T = np.trace(T)\n        T_squared = T @ T\n        tr_T_squared = np.trace(T_squared)\n        \n        s = np.sqrt(tr_T_squared)\n        \n        # Invariants I2 and I3\n        I2 = 0.5 * (tr_T**2 - tr_T_squared)\n        I3 = np.linalg.det(T)\n        \n        # Dimensionless ratios t and d\n        t = np.abs(tr_T) / (s + DELTA)\n        d = np.abs(I3) / ((s + DELTA)**3)\n        \n        # Apply decision rule\n        classification = 0\n        if s = EPSILON:\n            classification = 0\n        elif t = T_THRESH and d = D_THRESH:\n            classification = 1\n        elif t = T_THRESH and I3  0 and I2  0:\n            classification = 2\n        elif t  T_THRESH and I3  0:\n            classification = 3\n        else:\n            classification = 2\n            \n        results.append(classification)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3602059"}, {"introduction": "地球物理学的一个主要目标是反演——利用场测量数据来推断地下介质的属性。这项练习 [@problem_id:3602043] 从正演建模转向反演问题，要求您根据重力梯度张量数据估算质量分布。至关重要的是，它引入了现实世界中的不确定性这一复杂性，挑战您分析引力常数 $G$ 的误差如何通过最小二乘反演进行传播，并设计一个校准方案来修正这些误差。", "problem": "您的任务是为点质量配置建立重力梯度张量模型并进行反演，并量化引力常数中的不确定性如何通过反演传播。您必须从基础物理出发，然后进行数值实现，以产生指定的输出。基础物理是牛顿引力势和重力梯度张量的定义。所有推导和推理都必须基于此基础进行，不得使用任何捷径公式。物理单位必须明确说明并保持一致：质量单位为千克，位置单位为米，重力梯度分量单位为平方秒分之一。本问题不涉及角度。您的程序必须为提供的测试套件生成结果，并将所有结果以浮点数形式打印在一个由方括号括起来的、逗号分隔的列表中。\n\n推导的起点：\n- 点质量的牛顿引力势为 $\\Phi(\\mathbf{x}) = \\dfrac{G m}{\\|\\mathbf{x}\\|}$，其中 $G$ 是引力常数，$m$ 是质量，$\\mathbf{x}$ 是相对于该质量测量的位置矢量。\n- 重力梯度张量 (GGT) $T_{ij}(\\mathbf{x})$ 定义为 $T_{ij}(\\mathbf{x}) = \\dfrac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}$，其中 $i$ 和 $j$ 表示笛卡尔分量。\n- 此处考虑的观测量是给定观测点上的 $T_{zz}$ 分量。\n\n任务：\n- 仅从 $\\Phi(\\mathbf{x}) = \\dfrac{G m}{\\|\\mathbf{x}\\|}$ 和定义 $T_{ij}(\\mathbf{x}) = \\dfrac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}$ 出发，推导单个点质量的重力梯度张量 $T_{ij}(\\mathbf{x})$，并用 $G$、$m$ 和几何关系表示结果。\n- 证明对于一组观测点上的 $N$ 个点质量，其 $T_{zz}$ 分量可以写成线性模型 $\\mathbf{d} = G \\mathbf{A} \\mathbf{m}$，其中 $\\mathbf{d}$ 是 $T_{zz}$ 观测值向量，$\\mathbf{m}$ 是质量向量，$\\mathbf{A}$ 是一个与几何相关的矩阵，其元素取决于质量与观测点之间的相对位置。\n- 在无噪声条件下且 $\\mathbf{A}$ 矩阵为满列秩的情况下，推导 $G$ 中的乘性不确定性如何通过对 $\\mathbf{m}$ 的线性最小二乘反演进行传播，明确阐述估算质量与真实质量之间的比例关系。\n- 提出一个校准协议，该协议使用已知位置的已知参考质量，通过最小二乘法最小化预测与实测 $T_{zz}$ 数据之间的差异，来估算 $G$ 的有效比例因子（以及仪器尺度）。在线性模型下，为最佳拟合比例因子提供一个闭式表达式。\n\n实现要求：\n- 为每个观测点上由每个点质量引起的 $T_{zz}$ 分量实现一个正演模型，该模型直接根据推导出的点质量重力梯度张量构建。除双精度算术外，不使用任何近似。\n- 使用正演算子中假定的 $G$ 值，实现线性最小二乘反演，以从数据中估算质量。反演必须使用指定语言环境中可用的确定性算法。对于欠定或病态情况，使用最小范数最小二乘解。\n- 使用已知的参考质量配置，通过求解将预测数据映射到实测数据的最佳拟合标量比例因子，来实现所提出的 $G$ 校准协议，然后构建校准后的引力常数。\n\n单位：\n- 质量单位必须为千克 ($\\mathrm{kg}$)。\n- 位置单位必须为米 ($\\mathrm{m}$)。\n- $T_{zz}$ 重力梯度单位必须为平方秒分之一 ($\\mathrm{s}^{-2}$)。\n- 输出为无量纲浮点数。\n\n测试套件：\n- 在所有情况下，$G_{\\text{assumed}} = 6.67430 \\times 10^{-11}$，$G_{\\text{true}} = G_{\\text{assumed}} \\times (1 + \\delta)$，其中 $\\delta = 5 \\times 10^{-5}$。\n- 使用以下三个测试用例，每个用例由质量位置、观测位置、真实质量和噪声水平定义。在所有情况下，质量单位使用千克，位置单位使用米，并以 $\\mathrm{s}^{-2}$ 为单位计算 $T_{zz}$。\n\n用例 1 (良态，无噪声)：\n- 质量位置：$(-0.5, 0, 0)$ 和 $(+0.5, 0, 0)$。\n- 观测位置：$(0, 0, 1)$、$(0.5, 0, 1)$、$(-0.5, 0, 1)$、$(0, 0.5, 1)$。\n- 真实质量：$(10, 10)$。\n- 噪声标准差：$0$。\n\n用例 2 (良态，带噪声)：\n- 质量位置：$(-0.5, 0, 0)$ 和 $(+0.5, 0, 0)$。\n- 观测位置：$(0, 0, 1)$、$(0.5, 0, 1)$、$(-0.5, 0, 1)$、$(0, 0.5, 1)$。\n- 真实质量：$(10, 10)$。\n- 噪声标准差：$2.0 \\times 10^{-12}$。高斯噪声生成器使用确定性种子 $42$。\n\n用例 3 (病态几何，无噪声)：\n- 质量位置：$(-0.001, 0, 0)$ 和 $(+0.001, 0, 0)$。\n- 观测位置：$(0, 0, 1)$、$(0, 0, 1.5)$、$(0, 0, 2)$。\n- 真实质量：$(10, 10)$。\n- 噪声标准差：$0$。\n\n对每个用例，执行：\n- 使用 $G_{\\text{true}}$ 和真实质量对 $\\mathbf{d}$ 进行正演建模。\n- 使用 $G_{\\text{assumed}}$ 对 $\\hat{\\mathbf{m}}$ 进行线性最小二乘反演，必要时返回最小范数估计。\n- 计算总质量相对误差 $e_m = \\dfrac{\\sum_j \\hat{m}_j - \\sum_j m_j}{\\sum_j m_j}$。\n- 计算校准比例因子 $s$，该因子最小化 $\\| s \\mathbf{p} - \\mathbf{d} \\|_2$，其中 $\\mathbf{p} = G_{\\text{assumed}} \\mathbf{A} \\mathbf{m}$ 由已知的参考质量、位置和 $G_{\\text{assumed}}$ 构建。构成 $\\hat{G} = s \\, G_{\\text{assumed}}$，并计算引力常数相对误差 $e_G = \\dfrac{\\hat{G} - G_{\\text{true}}}{G_{\\text{true}}}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，顺序为 $[e_{m,1}, e_{G,1}, e_{m,2}, e_{G,2}, e_{m,3}, e_{G,3}]$，其中下标表示测试用例编号。例如，像 $[r_1,r_2,r_3,r_4,r_5,r_6]$ 这样打印结果。", "solution": "该问题是有效的，因为它在科学上基于牛顿物理学，问题设定良好，目标明确，并为获得唯一解提供了所有必要信息。\n\n**问题验证**\n\n**步骤 1：提取给定信息**\n- **基础物理：**\n    - 点质量的牛顿引力势：$\\Phi(\\mathbf{x}) = \\dfrac{G m}{\\|\\mathbf{x}\\|}$。\n    - 重力梯度张量 (GGT) 定义：$T_{ij}(\\mathbf{x}) = \\dfrac{\\partial^2 \\Phi(\\mathbf{x})}{\\partial x_i \\partial x_j}$。\n    - 观测量是 GGT 的 $T_{zz}$ 分量。\n- **物理常数：**\n    - 假定引力常数：$G_{\\text{assumed}} = 6.67430 \\times 10^{-11} \\, \\mathrm{m^3 \\, kg^{-1} \\, s^{-2}}$。\n    - 真实引力常数：$G_{\\text{true}} = G_{\\text{assumed}} \\times (1 + \\delta)$，其中 $\\delta = 5 \\times 10^{-5}$。\n- **单位：**\n    - 质量：千克 ($\\mathrm{kg}$)。\n    - 位置：米 ($\\mathrm{m}$)。\n    - 重力梯度：平方秒分之一 ($\\mathrm{s}^{-2}$)。\n- **任务：**\n    1. 推导单个点质量的 GGT $T_{ij}(\\mathbf{x})$。\n    2. 证明 $T_{zz}$ 观测的线性模型形式 $\\mathbf{d} = G \\mathbf{A} \\mathbf{m}$。\n    3. 推导 $G$ 中的乘性不确定性如何通过最小二乘反演传播。\n    4. 提出校准协议并推导比例因子的闭式表达式。\n- **测试用例：**\n    - **用例 1 (良态，无噪声)：**\n        - 质量位置：$[(-0.5, 0, 0), (0.5, 0, 0)] \\, \\mathrm{m}$。\n        - 观测位置：$[(0, 0, 1), (0.5, 0, 1), (-0.5, 0, 1), (0, 0.5, 1)] \\, \\mathrm{m}$。\n        - 真实质量：$[10, 10] \\, \\mathrm{kg}$。\n        - 噪声标准差：$0 \\, \\mathrm{s}^{-2}$。\n    - **用例 2 (良态，带噪声)：**\n        - 几何形状和质量与用例 1 相同。\n        - 噪声标准差：$2.0 \\times 10^{-12} \\, \\mathrm{s}^{-2}$。\n        - 噪声生成器种子：$42$。\n    - **用例 3 (病态，无噪声)：**\n        - 质量位置：$[(-0.001, 0, 0), (0.001, 0, 0)] \\, \\mathrm{m}$。\n        - 观测位置：$[(0, 0, 1), (0, 0, 1.5), (0, 0, 2)] \\, \\mathrm{m}$。\n        - 真实质量：$[10, 10] \\, \\mathrm{kg}$。\n        - 噪声标准差：$0 \\, \\mathrm{s}^{-2}$。\n- **要求输出：**\n    - 对每个用例，计算总质量相对误差 $e_m = \\dfrac{\\sum_j \\hat{m}_j - \\sum_j m_j}{\\sum_j m_j}$。\n    - 对每个用例，计算引力常数相对误差 $e_G = \\dfrac{\\hat{G} - G_{\\text{true}}}{G_{\\text{true}}}$。\n    - 最终输出必须是单行：$[e_{m,1}, e_{G,1}, e_{m,2}, e_{G,2}, e_{m,3}, e_{G,3}]$。\n\n**步骤 2：使用提取的给定信息进行验证**\n- **科学基础：** 该问题基于牛顿力学和势理论，这些是物理学的基本原理。重力梯度及其反演的概念是地球物理学和大地测量学的标准实践。所有方面都具有科学合理性。\n- **适定性：** 该问题提供了明确的目标、所有必要的数据和定义明确的测试用例。任务结构清晰，旨在导出一个唯一的、有意义的数值解。\n- **客观性：** 问题陈述以精确、定量和无偏见的语言表达，不含主观论断。\n\n**步骤 3：结论与行动**\n问题是有效的。将提供一个完整的解决方案。\n\n**推导与算法设计**\n\n**1. 点质量重力梯度张量的推导**\n\n相对于位于原点的点质量 $m$，在位置 $\\mathbf{x} = (x_1, x_2, x_3)$ 处的引力势 $\\Phi$ 由下式给出：\n$$ \\Phi(\\mathbf{x}) = \\frac{G m}{\\|\\mathbf{x}\\|} = Gm(x_1^2 + x_2^2 + x_3^2)^{-1/2} $$\n令 $R = \\|\\mathbf{x}\\| = (x_1^2 + x_2^2 + x_3^2)^{1/2}$。重力梯度张量 $T_{ij}$ 是二阶偏导数矩阵，$T_{ij} = \\frac{\\partial^2 \\Phi}{\\partial x_i \\partial x_j}$。\n$$ \\frac{\\partial \\Phi}{\\partial x_j} = Gm \\frac{\\partial}{\\partial x_j} (R^{-1}) = Gm (-1)R^{-2} \\frac{\\partial R}{\\partial x_j} = -Gm \\frac{x_j}{R^3} $$\n二阶导数为：\n$$ T_{ij}(\\mathbf{x}) = \\frac{\\partial}{\\partial x_i} \\left( -Gm \\frac{x_j}{R^3} \\right) = -Gm \\left[ \\frac{\\delta_{ij} R^3 - x_j (3R^2 \\frac{\\partial R}{\\partial x_i})}{R^6} \\right] $$\n其中 $\\delta_{ij}$ 是克罗内克δ。代入 $\\frac{\\partial R}{\\partial x_i} = \\frac{x_i}{R}$：\n$$ T_{ij}(\\mathbf{x}) = -Gm \\left[ \\frac{\\delta_{ij} R^3 - 3x_j R x_i}{R^6} \\right] = Gm \\frac{3x_i x_j - \\delta_{ij} R^2}{R^5} $$\n所需的特定分量是 $T_{zz}$，对应于 $i=j=3$。令 $\\mathbf{x} = (x, y, z)$，则 $R^2 = x^2+y^2+z^2$：\n$$ T_{zz}(\\mathbf{x}) = Gm \\frac{3z^2 - \\delta_{33} R^2}{R^5} = Gm \\frac{3z^2 - R^2}{R^5} $$\n\n**2. 线性模型的构建**\n\n对于一个由 $N$ 个点质量 $m_k$（位于位置 $\\mathbf{q}_k$）和 $M$ 个观测点（位于位置 $\\mathbf{p}_l$）组成的系统，在 $\\mathbf{p}_l$ 处的总势是每个质量产生势的总和：\n$$ \\Phi(\\mathbf{p}_l) = \\sum_{k=1}^{N} \\frac{G m_k}{\\|\\mathbf{p}_l - \\mathbf{q}_k\\|} $$\n由于微分的线性性质，总 GGT 也是一个和：\n$$ T_{zz}(\\mathbf{p}_l) = \\sum_{k=1}^{N} T_{zz,k}(\\mathbf{p}_l - \\mathbf{q}_k) $$\n令 $\\mathbf{r}_{lk} = \\mathbf{p}_l - \\mathbf{q}_k = (x_{lk}, y_{lk}, z_{lk})$ 为相对位置矢量。令 $R_{lk} = \\|\\mathbf{r}_{lk}\\|$。质量 $m_k$ 对 $\\mathbf{p}_l$ 处 $T_{zz}$ 测量的贡献为：\n$$ T_{zz,k} = Gm_k \\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5} $$\n令 $d_l = T_{zz}(\\mathbf{p}_l)$ 为第 $l$ 个观测值。我们可以写出：\n$$ d_l = G \\sum_{k=1}^{N} m_k \\left( \\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5} \\right) $$\n该表达式对于质量 $m_k$ 是线性的。我们可以定义一个几何矩阵 $\\mathbf{A}$，其元素为 $A_{lk} = \\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5}$。所有 $M$ 个观测的方程组可以写成矩阵形式：\n$$ \\mathbf{d} = G \\mathbf{A} \\mathbf{m} $$\n其中 $\\mathbf{d}$ 是 $M \\times 1$ 的观测向量，$\\mathbf{A}$ 是 $M \\times N$ 的几何矩阵，$\\mathbf{m}$ 是 $N \\times 1$ 的未知质量向量。\n\n**3. $G$ 中不确定性的传播**\n\n我们用 $G_{\\text{true}}$ 合成“真实”数据：$\\mathbf{d} = G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}$。我们使用一个可能不正确的 $G_{\\text{assumed}}$ 进行最小二乘反演来估计质量 $\\hat{\\mathbf{m}}$。反演模型为 $\\mathbf{d} = (G_{\\text{assumed}} \\mathbf{A}) \\hat{\\mathbf{m}}$。\n线性最小二乘解 $\\hat{\\mathbf{m}}$ 最小化 $\\| \\mathbf{d} - G_{\\text{assumed}} \\mathbf{A} \\hat{\\mathbf{m}} \\|_2^2$。该解由下式给出：\n$$ \\hat{\\mathbf{m}} = (G_{\\text{assumed}} \\mathbf{A})^{+} \\mathbf{d} $$\n其中 $(\\cdot)^{+}$ 表示 Moore-Penrose 伪逆。代入 $\\mathbf{d}$ 的表达式：\n$$ \\hat{\\mathbf{m}} = (G_{\\text{assumed}} \\mathbf{A})^{+} (G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}) $$\n对于标量 $c \\neq 0$，使用属性 $(c\\mathbf{X})^{+} = c^{-1} \\mathbf{X}^{+}$：\n$$ \\hat{\\mathbf{m}} = \\frac{1}{G_{\\text{assumed}}} \\mathbf{A}^{+} (G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}) = \\frac{G_{\\text{true}}}{G_{\\text{assumed}}} (\\mathbf{A}^{+} \\mathbf{A}) \\mathbf{m}_{\\text{true}} $$\n对于一个满列秩矩阵 $\\mathbf{A}$，$\\mathbf{A}^{+}\\mathbf{A} = \\mathbf{I}$，即单位矩阵。在这种情况下，关系是一个简单的缩放：\n$$ \\hat{\\mathbf{m}} = \\frac{G_{\\text{true}}}{G_{\\text{assumed}}} \\mathbf{m}_{\\text{true}} $$\n这表明 $G$ 中的乘性误差直接作为乘性误差传播到估算质量中。即使在秩亏的情况下，$\\mathbf{A}^{+}\\mathbf{A}$ 是到 $\\mathbf{A}$ 行空间上的一个投影。如果 $\\mathbf{m}_{\\text{true}}$ 完全位于此空间内（本问题设置中即是如此），则该关系成立。\n\n**4. 校准协议**\n\n目标是找到一个标量校正因子 $s$，使预测数据 $\\mathbf{p}$ 与测量数据 $\\mathbf{d}$ 最佳对齐。预测基于已知的参考质量 $\\mathbf{m}_{\\text{ref}}$ 和假定的常数 $G_{\\text{assumed}}$：$\\mathbf{p} = G_{\\text{assumed}} \\mathbf{A} \\mathbf{m}_{\\text{ref}}$。测量数据为 $\\mathbf{d}$。我们寻求最小化残差的L2范数平方：\n$$ E(s) = \\| s \\mathbf{p} - \\mathbf{d} \\|_2^2 = (s \\mathbf{p} - \\mathbf{d})^T (s \\mathbf{p} - \\mathbf{d}) = s^2 (\\mathbf{p}^T \\mathbf{p}) - 2s (\\mathbf{p}^T \\mathbf{d}) + \\mathbf{d}^T \\mathbf{d} $$\n为了找到最优的 $s$，我们将 $E(s)$ 对 $s$ 的导数设为零：\n$$ \\frac{dE}{ds} = 2s (\\mathbf{p}^T \\mathbf{p}) - 2 (\\mathbf{p}^T \\mathbf{d}) = 0 $$\n求解 $s$ 可得闭式表达式：\n$$ s = \\frac{\\mathbf{p}^T \\mathbf{d}}{\\mathbf{p}^T \\mathbf{p}} = \\frac{\\langle \\mathbf{p}, \\mathbf{d} \\rangle}{\\| \\mathbf{p} \\|_2^2} $$\n校准后的引力常数则为 $\\hat{G} = s \\cdot G_{\\text{assumed}}$。在无噪声场景中，$\\mathbf{d} = G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{ref}}$，我们有 $\\mathbf{d} = (G_{\\text{true}}/G_{\\text{assumed}}) \\mathbf{p}$。将此代入 $s$ 的方程，得到 $s = G_{\\text{true}}/G_{\\text{assumed}}$，因此 $\\hat{G} = G_{\\text{true}}$，这表明校准完美地修正了 $G$ 中的误差。\n\n**实施计划**\n对于每个测试用例，数值解将遵循以下步骤：\n1.  定义几何结构（质量和观测位置）以及真实质量 $\\mathbf{m}_{\\text{true}}$。\n2.  构建 $M \\times N$ 几何矩阵 $\\mathbf{A}$，其中每个元素 $A_{lk}$ 计算为 $\\frac{3z_{lk}^2 - R_{lk}^2}{R_{lk}^5}$。\n3.  使用 $\\mathbf{d} = G_{\\text{true}} \\mathbf{A} \\mathbf{m}_{\\text{true}}$ 合成“测量”数据向量 $\\mathbf{d}$。对于用例 2，添加具有指定标准差和种子的高斯噪声。\n4.  通过求解 $\\mathbf{d} = (G_{\\text{assumed}} \\mathbf{A}) \\hat{\\mathbf{m}}$ 来进行最小二乘反演，以求得 $\\hat{\\mathbf{m}}$。这通过使用 `numpy.linalg.lstsq` 来完成，该函数通过提供最小范数解，能正确处理良态和病态系统。\n5.  计算总质量相对误差 $e_m = (\\sum \\hat{m}_j - \\sum m_j) / (\\sum m_j)$。\n6.  执行校准。计算预测数据向量 $\\mathbf{p} = G_{\\text{assumed}} \\mathbf{A} \\mathbf{m}_{\\text{true}}$。使用推导出的公式 $s = (\\mathbf{p} \\cdot \\mathbf{d}) / (\\mathbf{p} \\cdot \\mathbf{p})$ 计算比例因子 $s$。\n7.  计算校准后的 $\\hat{G} = s \\cdot G_{\\text{assumed}}$ 和相应的相对误差 $e_G = (\\hat{G} - G_{\\text{true}}) / G_{\\text{true}}$。\n8.  收集六个结果误差值（三个用例各有一个 $e_m$ 和 $e_G$），并将它们格式化为所需的字符串输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravity gradient tensor modeling and inversion problem\n    for three test cases.\n    \"\"\"\n    # Define physical constants\n    G_assumed = 6.67430e-11  # m^3 kg^-1 s^-2\n    delta = 5e-5\n    G_true = G_assumed * (1 + delta)\n\n    # Define test suite\n    test_cases = [\n        {\n            \"name\": \"Case 1 (well-conditioned, noise-free)\",\n            \"mass_positions\": np.array([[-0.5, 0, 0], [0.5, 0, 0]]),\n            \"obs_positions\": np.array([(0, 0, 1), (0.5, 0, 1), (-0.5, 0, 1), (0, 0.5, 1)]),\n            \"true_masses\": np.array([10.0, 10.0]),\n            \"noise_std\": 0.0,\n        },\n        {\n            \"name\": \"Case 2 (well-conditioned, with noise)\",\n            \"mass_positions\": np.array([[-0.5, 0, 0], [0.5, 0, 0]]),\n            \"obs_positions\": np.array([(0, 0, 1), (0.5, 0, 1), (-0.5, 0, 1), (0, 0.5, 1)]),\n            \"true_masses\": np.array([10.0, 10.0]),\n            \"noise_std\": 2.0e-12,\n        },\n        {\n            \"name\": \"Case 3 (ill-conditioned, noise-free)\",\n            \"mass_positions\": np.array([[-0.001, 0, 0], [0.001, 0, 0]]),\n            \"obs_positions\": np.array([(0, 0, 1), (0, 0, 1.5), (0, 0, 2)]),\n            \"true_masses\": np.array([10.0, 10.0]),\n            \"noise_std\": 0.0,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        mass_pos = case[\"mass_positions\"]\n        obs_pos = case[\"obs_positions\"]\n        m_true = case[\"true_masses\"]\n        noise_std = case[\"noise_std\"]\n\n        num_obs = obs_pos.shape[0]\n        num_masses = mass_pos.shape[0]\n\n        # 1. Construct the geometry matrix A\n        A = np.zeros((num_obs, num_masses))\n        for l in range(num_obs):\n            for k in range(num_masses):\n                r_vec = obs_pos[l, :] - mass_pos[k, :]\n                R_sq = np.dot(r_vec, r_vec)\n                R = np.sqrt(R_sq)\n                z = r_vec[2]\n                A[l, k] = (3 * z**2 - R_sq) / (R**5)\n\n        # 2. Forward model the \"measured\" data vector d\n        d_true = G_true * (A @ m_true)\n        if noise_std  0:\n            rng = np.random.default_rng(42)  # Seed for reproducibility\n            noise = rng.normal(0, noise_std, size=d_true.shape)\n            d = d_true + noise\n        else:\n            d = d_true\n\n        # 3. Perform linear least-squares inversion for m_hat\n        forward_operator = G_assumed * A\n        m_hat, _, _, _ = np.linalg.lstsq(forward_operator, d, rcond=None)\n\n        # 4. Compute the mass-total relative error e_m\n        sum_m_hat = np.sum(m_hat)\n        sum_m_true = np.sum(m_true)\n        e_m = (sum_m_hat - sum_m_true) / sum_m_true\n        results.append(e_m)\n\n        # 5. Perform calibration to find G_hat\n        # Use true masses as reference masses for calibration\n        p = G_assumed * (A @ m_true)\n        \n        # Calculate the scale factor s\n        s = np.dot(p, d) / np.dot(p, p)\n        \n        G_hat = s * G_assumed\n        \n        # 6. Compute the G relative error e_G\n        e_G = (G_hat - G_true) / G_true\n        results.append(e_G)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```", "id": "3602043"}]}