{"hands_on_practices": [{"introduction": "任何成功的全波形反演都依赖于一个数值稳定的波传播求解器。本实践聚焦于显式有限差分格式稳定性的基石：Courant–Friedrichs–Lewy (CFL) 条件。通过为二维声波方程推导此条件，您将对如何选择一个保证模拟稳定性的时间步长有一个基本的理解，这是正向模拟和伴随反向传播的先决条件。[@problem_id:3598910]", "problem": "考虑恒定密度的声波全波形反演 (FWI)，其中正向和伴随波场通过二维声波方程进行传播。设压力场表示为 $p(x,z,t)$，并考虑一个在均匀但可能各向异性的笛卡尔网格上离散化的矩形计算域，其在水平和垂直方向上的网格间距分别为 $\\Delta x$ 和 $\\Delta z$，并具有均匀的时间步长 $\\Delta t$。声波方程为\n$$\\frac{\\partial^{2} p}{\\partial t^{2}}(x,z,t) = v(x,z)^{2} \\nabla^{2} p(x,z,t) + s(x,z,t),$$\n其中 $v(x,z)$ 是空间变化的波速，$s(x,z,t)$ 是一个源项。在伴随状态 FWI 中，正向传播和伴随反向传播都需要稳定的时间步进，以确保目标函数的梯度是良定义的。\n\n从上述连续偏微分方程出发，在给定网格上仅使用空间和时间上的二阶中心差分，推导在网格节点 $(i,j)$ 和时间索引 $n$ 处将 $p_{i,j}^{n}$ 推进到 $p_{i,j}^{n+1}$ 的显式离散更新公式，该公式应使用时间索引 $n$ 处相邻空间节点上的 $p$ 值以及前一个时间层 $p_{i,j}^{n-1}$ 的值来表示。然后，对具有恒定波速 $v(x,z) = v_{\\max}$ 的齐次情况 $s(x,z,t)=0$ 进行傅里叶 (von Neumann) 稳定性分析，以获得用 $v_{\\max}$、$\\Delta t$、$\\Delta x$ 和 $\\Delta z$ 表示的 Courant–Friedrichs–Lewy (CFL) 稳定性条件。\n\n最后，为一个生产 FWI 工作流程中使用的以下物理真实建模参数计算最大稳定时间步长：$v_{\\max} = 3600 \\,\\text{m/s}$，$\\Delta x = 7.5 \\,\\text{m}$，$\\Delta z = 10 \\,\\text{m}$。报告允许的最大 $\\Delta t$（以秒为单位），结果四舍五入至四位有效数字。最终答案以秒表示。", "solution": "该问题是适定的，具有科学依据，并提供了获得唯一解所需的所有信息。我们首先对给定的偏微分方程进行离散化，然后进行稳定性分析以找到对时间步长的约束，最后根据给定参数评估此约束。\n\n连续二维声波方程由下式给出：\n$$\n\\frac{\\partial^{2} p}{\\partial t^{2}}(x,z,t) = v(x,z)^{2} \\nabla^{2} p(x,z,t) + s(x,z,t)\n$$\n其中 $\\nabla^{2} = \\frac{\\partial^{2}}{\\partial x^{2}} + \\frac{\\partial^{2}}{\\partial z^{2}}$。\n\n首先，我们推导显式离散更新公式。我们在一个由点 $(x_i, z_j, t_n) = (i\\Delta x, j\\Delta z, n\\Delta t)$ 构成的网格上，对偏导数使用二阶中心差分近似。该点的压力表示为 $p_{i,j}^{n}$。\n\n二阶时间导数近似为：\n$$\n\\frac{\\partial^{2} p}{\\partial t^{2}} \\bigg|_{i,j,n} \\approx \\frac{p_{i,j}^{n+1} - 2 p_{i,j}^{n} + p_{i,j}^{n-1}}{\\Delta t^2}\n$$\n\n二阶空间导数近似为：\n$$\n\\frac{\\partial^{2} p}{\\partial x^{2}} \\bigg|_{i,j,n} \\approx \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2}\n$$\n$$\n\\frac{\\partial^{2} p}{\\partial z^{2}} \\bigg|_{i,j,n} \\approx \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta z^2}\n$$\n\n将这些近似值代入网格点 $(i,j)$ 和时间层 $n$ 处的波动方程，并令 $v_{i,j} = v(x_i, z_j)$ 和 $s_{i,j}^n = s(x_i, z_j, t_n)$，我们得到：\n$$\n\\frac{p_{i,j}^{n+1} - 2 p_{i,j}^{n} + p_{i,j}^{n-1}}{\\Delta t^2} = v_{i,j}^{2} \\left( \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta z^2} \\right) + s_{i,j}^n\n$$\n为了找到 $p_{i,j}^{n+1}$ 的显式更新公式，我们重新整理该方程：\n$$\np_{i,j}^{n+1} = 2 p_{i,j}^{n} - p_{i,j}^{n-1} + (v_{i,j} \\Delta t)^{2} \\left( \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta z^2} \\right) + \\Delta t^2 s_{i,j}^n\n$$\n这就是所要求的离散更新公式。\n\n接下来，我们对具有恒定波速 ($v(x,z) = v_{\\max}$) 的齐次情况 ($s(x,z,t)=0$) 进行傅里叶 (von Neumann) 稳定性分析。离散方程简化为：\n$$\np_{i,j}^{n+1} = 2 p_{i,j}^{n} - p_{i,j}^{n-1} + (v_{\\max} \\Delta t)^{2} \\left( \\frac{p_{i+1,j}^{n} - 2 p_{i,j}^{n} + p_{i-1,j}^{n}}{\\Delta x^2} + \\frac{p_{i,j+1}^{n} - 2 p_{i,j}^{n} + p_{i,j-1}^{n}}{\\Delta z^2} \\right)\n$$\n我们考虑一个形如下式的单傅里叶模式解：\n$$\np_{i,j}^{n} = G^{n} \\exp(I (k_x i \\Delta x + k_z j \\Delta z))\n$$\n其中 $G$ 是放大因子，$k_x$ 和 $k_z$ 分别是 $x$ 和 $z$ 方向的波数，$I = \\sqrt{-1}$。为了使该格式稳定，放大因子的模必须对所有波数都满足 $|G| \\leq 1$。\n\n将傅里叶模式解代入齐次离散方程，并除以 $p_{i,j}^{n-1} = G^{n-1} \\exp(I(k_x i \\Delta x + k_z j \\Delta z))$，得到关于 $G$ 的方程：\n$$\nG^2 = 2G - 1 + G \\frac{(v_{\\max} \\Delta t)^2}{\\Delta x^2} \\left[ \\exp(I k_x \\Delta x) - 2 + \\exp(-I k_x \\Delta x) \\right] + G \\frac{(v_{\\max} \\Delta t)^2}{\\Delta z^2} \\left[ \\exp(I k_z \\Delta z) - 2 + \\exp(-I k_z \\Delta z) \\right]\n$$\n使用恒等式 $\\exp(I\\theta) + \\exp(-I\\theta) = 2\\cos(\\theta)$，方括号中的项变为 $2\\cos(k_x\\Delta x) - 2 = -2(1-\\cos(k_x\\Delta x))$ 和 $2\\cos(k_z\\Delta z) - 2 = -2(1-\\cos(k_z\\Delta z))$。再使用半角恒等式 $1-\\cos(\\theta) = 2\\sin^2(\\theta/2)$，它们分别简化为 $-4\\sin^2(k_x\\Delta x/2)$ 和 $-4\\sin^2(k_z\\Delta z/2)$。\n\n将这些代回原式得到：\n$$\nG^2 = 2G - 1 - 4G(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right]\n$$\n将其重新整理为关于 $G$ 的标准二次型 $aG^2+bG+c=0$：\n$$\nG^2 - 2G \\left( 1 - 2(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right] \\right) + 1 = 0\n$$\n这是一个形如 $G^2 - 2\\alpha G + 1 = 0$ 的二次方程，其中\n$$\n\\alpha = 1 - 2(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right]\n$$\n其根为 $G = \\alpha \\pm \\sqrt{\\alpha^2-1}$。为了使稳定性条件 $|G| \\leq 1$ 成立，根必须是复数或位于单位圆上，这要求平方根下的项为非正，即 $\\alpha^2 - 1 \\leq 0$。这等价于 $|\\alpha| \\leq 1$。\n\n条件 $\\alpha \\leq 1$ 总是满足的，因为从 1 中减去的项是非负量的和。稳定性的关键条件来自于 $\\alpha \\geq -1$：\n$$\n1 - 2(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right] \\geq -1\n$$\n$$\n2 \\geq 2(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right]\n$$\n$$\n(v_{\\max} \\Delta t)^2 \\left[ \\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_z\\Delta z/2)}{\\Delta z^2} \\right] \\leq 1\n$$\n这个不等式必须对所有的波数 $k_x$ 和 $k_z$ 都成立。对 $\\Delta t$ 的最严格约束发生在方括号中的项最大化时。这发生在 $\\sin^2(k_x\\Delta x/2)=1$ 和 $\\sin^2(k_z\\Delta z/2)=1$ 时，对应于网格上可分辨的最高频率（奈奎斯特频率，$k_x = \\pi/\\Delta x$ 和 $k_z = \\pi/\\Delta z$）。\n因此，括号内项的最大值为 $\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta z^2}$。\n\n稳定性条件变为：\n$$\n(v_{\\max} \\Delta t)^2 \\left( \\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta z^2} \\right) \\leq 1\n$$\n取平方根，我们得到 Courant–Friedrichs–Lewy (CFL) 稳定性条件：\n$$\n\\Delta t \\leq \\frac{1}{v_{\\max} \\sqrt{\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta z^2}}}\n$$\n\n最后，我们为给定参数计算最大稳定时间步长 $\\Delta t_{\\max}$：$v_{\\max} = 3600 \\,\\text{m/s}$，$\\Delta x = 7.5 \\,\\text{m}$，$\\Delta z = 10 \\,\\text{m}$。\n$$\n\\Delta t_{\\max} = \\frac{1}{3600 \\sqrt{\\frac{1}{7.5^2} + \\frac{1}{10^2}}}\n$$\n我们计算平方根下的项：\n$$\n\\frac{1}{7.5^2} + \\frac{1}{10^2} = \\frac{1}{56.25} + \\frac{1}{100} = \\frac{16}{900} + \\frac{9}{900} = \\frac{25}{900} = \\frac{1}{36}\n$$\n平方根为：\n$$\n\\sqrt{\\frac{1}{36}} = \\frac{1}{6}\n$$\n将此代回 $\\Delta t_{\\max}$ 的表达式中：\n$$\n\\Delta t_{\\max} = \\frac{1}{3600 \\times \\frac{1}{6}} = \\frac{6}{3600} = \\frac{1}{600} \\,\\text{s}\n$$\n作为小数，$\\Delta t_{\\max} = 0.001666... \\,\\text{s}$。四舍五入到四位有效数字，我们得到：\n$$\n\\Delta t_{\\max} \\approx 0.001667 \\,\\text{s}\n$$", "answer": "$$\\boxed{0.001667}$$", "id": "3598910"}, {"introduction": "伴随状态法提供了一种高效的梯度计算方法，但其实现错综复杂且容易出错。本练习将指导您使用“梯度测试”来验证您的实现，该测试将伴随法得到的梯度与有限差分近似进行比较。在尝试进行反演之前，掌握这种验证技术是调试任何 FWI 代码并建立对其可靠性信心的必备技能。[@problem_id:3598829]", "problem": "您的任务是设计并验证一个用于一维空间中全波形反演 (FWI) 的综合基准测试，该测试使用伴随法。目标是检验梯度和Hessian向量积的正确性，并对照已知的真值数据展示反演收敛性。所有量必须根据计算地球物理学的第一性原理进行定义和实现，所有数学实体必须使用 LaTeX 符号表示。\n\n其物理基础是一维声波方程，描述了在波速 $c(x)$ 随空间变化的介质中，标量粒子位移场 $u(x,t)$ 的行为。该方程通过平方慢度 $m(x) = 1/c(x)^2$ 表示：\n$$\nm(x)\\,\\frac{\\partial^2 u(x,t)}{\\partial t^2} - \\frac{\\partial^2 u(x,t)}{\\partial x^2} = s(x,t),\n$$\n其中 $s(x,t)$ 是一个给定的源项。观测算子是在一组有限的接收点位置 $\\{x_r\\}$ 进行采样，提供数据 $u(x_r,t)$。目标函数定义为模拟数据与观测数据之间的最小二乘失配：\n$$\nJ(m) = \\frac{1}{2}\\sum_{r}\\int_{0}^{T}\\left(u(x_r,t;m) - d_r(t)\\right)^2 \\,\\mathrm{d}t,\n$$\n其中 $d_r(t)$ 是由真值模型 $m^\\star(x)$ 生成的观测数据，$T$ 是记录时长。\n\n针对此目标函数的伴随状态法，使用相同的波算子，引入满足伴随偏微分方程的伴随场 $\\lambda(x,t)$\n$$\nm(x)\\,\\frac{\\partial^2 \\lambda(x,t)}{\\partial t^2} - \\frac{\\partial^2 \\lambda(x,t)}{\\partial x^2} = \\sum_{r}\\delta(x-x_r)\\,\\left(u(x_r,t;m)-d_r(t)\\right),\n$$\n在 $t = T$ 和 $t = 0$ 处具有齐次终端条件。在这些条件下，目标函数相对于 $m(x)$ 的梯度为\n$$\n\\frac{\\delta J}{\\delta m}(x) = -\\int_{0}^{T}\\frac{\\partial^2 u(x,t)}{\\partial t^2}\\,\\lambda(x,t)\\,\\mathrm{d}t.\n$$\n\n您的程序必须在均匀空间网格上对上述方程进行离散化，空间步长为 $\\Delta x$，时间步长为 $\\Delta t$，采用满足 Courant–Friedrichs–Lewy 条件的蛙跳格式。离散拉普拉斯算子必须通过二阶中心差分算子实现。为了科学上的一致性，您必须施加固定值边界条件 $u(0,t)=0$ 和 $u(L,t)=0$。源 $s(x,t)$ 必须是中心频率为 $f_0$ 的带限 Ricker 子波，位于指定的震源位置 $x_s$。接收器必须放置在远离边界的指定位置 $\\{x_r\\}$。所有长度单位均为米，所有时间单位均为秒。失配函数 $J(m)$ 是无量纲的。\n\n您必须针对由已知真值模型 $m^\\star(x)$ 生成的综合数据执行三项验证任务：\n\n1. 通过方向导数一致性进行梯度检验。对于一个非平凡的扰动方向 $p(x)$，验证以下恒等式\n$$\n\\frac{J(m+\\epsilon p)-J(m)}{\\epsilon} \\approx \\int_{0}^{L}\\frac{\\delta J}{\\delta m}(x)\\,p(x)\\,\\mathrm{d}x,\n$$\n对于一系列递减的步长 $\\epsilon$。报告测试序列中的最大相对差异，以及该差异是否随 $\\epsilon$ 单调递减。\n\n2. 通过二阶泰勒余项进行Hessian向量检验。对于一个扰动方向 $v(x)$，定义有限差分Hessian向量标量\n$$\nv^\\top H(m)v \\approx \\int_{0}^{L} v(x)\\,\\frac{\\frac{\\delta J}{\\delta m}(x;m+\\epsilon v)-\\frac{\\delta J}{\\delta m}(x;m-\\epsilon v)}{2\\epsilon}\\,\\mathrm{d}x,\n$$\n并检验二阶泰勒模型\n$$\nJ(m+\\epsilon v) \\approx J(m) + \\epsilon\\,\\int_{0}^{L}\\frac{\\delta J}{\\delta m}(x)\\,v(x)\\,\\mathrm{d}x + \\frac{1}{2}\\epsilon^2\\,v^\\top H(m)v.\n$$\n计算在所用的最小 $\\epsilon$ 下此近似的相对误差。\n\n3. 反演收敛性。从一个初始模型 $m_0(x)$ 开始，运行基于梯度的迭代更新，迭代固定次数，并采用满足 Armijo 条件的回溯线搜索来减小 $J(m)$。对梯度使用一个简单的平滑预条件子来稳定更新。报告迭代后的比率 $J(m_{\\text{final}})/J(m_0)$。\n\n您必须实现一个包含三个案例的独立测试套件，每个案例都由具有物理意义的参数完全指定。答案必须是无量纲的布尔值，根据此处提供的接受阈值指示通过或失败：\n\n- 梯度检验接受标准：在最小 $\\epsilon$ 处的最大相对差异不得超过 $0.10$，并且差异必须在测试的 $\\epsilon$ 值上单调递减。\n- Hessian检验接受标准：在最小 $\\epsilon$ 处，二阶泰勒模型的相对误差不得超过 $0.25$。\n- 反演收敛性接受标准：最终失配比率必须小于或等于特定案例的阈值。\n\n所有答案必须汇总到一行中，作为一个用方括号括起来的逗号分隔列表。每个案例的结果必须是一个包含三个布尔值的列表，形式为 $[\\text{gradient\\_pass},\\text{hessian\\_pass},\\text{convergence\\_pass}]$。\n\n测试套件规范：\n\n- 案例1（理想路径）：区域长度 $L=1000\\,\\mathrm{m}$，网格点数 $N_x=201$，震源位置 $x_s=200\\,\\mathrm{m}$，Ricker子波频率 $f_0=10\\,\\mathrm{Hz}$，记录时长 $T=1.0\\,\\mathrm{s}$。真值波速剖面 $c^\\star(x)$ 是一个双层模型：当 $x  500\\,\\mathrm{m}$ 时 $c^\\star(x)=2000\\,\\mathrm{m/s}$，否则 $c^\\star(x)=2500\\,\\mathrm{m/s}$。初始模型在所有位置均为 $c_0(x)=2200\\,\\mathrm{m/s}$。接收器位置为 $x_r=\\{600,700,800\\}\\,\\mathrm{m}$。收敛阈值：如果 $J(m_{\\text{final}})/J(m_0)\\le 0.60$，则报告通过。\n- 案例2（接近Courant边界）：区域长度 $L=500\\,\\mathrm{m}$，网格点数 $N_x=101$，震源位置 $x_s=100\\,\\mathrm{m}$，Ricker子波频率 $f_0=15\\,\\mathrm{Hz}$，记录时长 $T=0.6\\,\\mathrm{s}$。真值波速剖面 $c^\\star(x)$ 是线性的：$c^\\star(x)=2200+600x/L\\,\\mathrm{m/s}$。初始模型在所有位置均为 $c_0(x)=2300\\,\\mathrm{m/s}$。接收器位置为 $x_r=\\{300,400\\}\\,\\mathrm{m}$。选择 $\\Delta t$ 为最大速度稳定性极限的 $0.99$ 倍。收敛阈值：如果 $J(m_{\\text{final}})/J(m_0)\\le 0.70$，则报告通过。\n- 案例3（低对比度异常）：区域长度 $L=800\\,\\mathrm{m}$，网格点数 $N_x=161$，震源位置 $x_s=150\\,\\mathrm{m}$，Ricker子波频率 $f_0=12\\,\\mathrm{Hz}$，记录时长 $T=0.8\\,\\mathrm{s}$。真值波速剖面 $c^\\star(x)=2500+100\\exp\\left(-\\frac{(x-500)^2}{2\\cdot 50^2}\\right)\\,\\mathrm{m/s}$。初始模型在所有位置均为 $c_0(x)=2500\\,\\mathrm{m/s}$。接收器位置为 $x_r=\\{450,550,650\\}\\,\\mathrm{m}$。收敛阈值：如果 $J(m_{\\text{final}})/J(m_0)\\le 0.85$，则报告通过。\n\n此问题不涉及角度单位。所有报告的布尔值都是无量纲的。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如：使用Python布尔字面量的 \"[[true,true,true],[true,true,false],[true,true,true]]\"。", "solution": "用户为设计和验证一维全波形反演 (FWI) 基准测试提供了一个定义明确且科学严谨的问题陈述。根据所有指定标准，该问题是有效的。\n\n-   **科学基础**：该问题建立在标准的一维声波方程、最小二乘目标函数以及用于梯度计算的伴随状态法之上。这些都是计算地球物理学中的基本且正确的原理。\n-   **适定性**：该问题得到了完全指定，为三个不同的测试案例提供了所有必需的物理参数、模型定义和数值设置。验证任务（梯度检验、Hessian向量检验和反演收敛性）是验证数值优化代码的标准和客观程序。\n-   **客观性与完整性**：问题陈述语言精确、无歧义。所有约束、边界条件、震源定义和接受阈值都已明确给出，没有主观解释的余地。完整实现所需的所有参数都已提供。\n\n该问题没有矛盾，物理上合理，并且计算上可行。因此，我将继续提供完整的解决方案。\n\n该解决方案涉及几个关键组成部分：\n1.  **波动方程求解器**：一个用于一维声波方程 $m(x)\\,\\frac{\\partial^2 u}{\\partial t^2} - \\frac{\\partial^2 u}{\\partial x^2} = s(x,t)$ 的时域有限差分 (FDTD) 求解器。空间导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用二阶精度的中心差分，时间步进使用二阶蛙跳格式。更新器由下式给出：\n    $$\n    u_i^{j+1} = 2u_i^j - u_i^{j-1} + \\frac{(\\Delta t)^2}{m_i} \\left( \\frac{u_{i+1}^j - 2u_i^j + u_{i-1}^j}{(\\Delta x)^2} + s_i^j \\right)\n    $$\n    其中 $i$ 是空间索引，$j$ 是时间索引。强制执行固定边界条件 $u(0,t)=0$ 和 $u(L,t)=0$。\n\n2.  **伴随求解器**：伴随波动方程 $m(x)\\,\\frac{\\partial^2 \\lambda}{\\partial t^2} - \\frac{\\partial^2 \\lambda}{\\partial x^2} = \\sum_{r}\\delta(x-x_r)\\,(u(x_r,t)-d_r(t))$ 是在时间上向后求解的。其数值格式与正向求解器相同，但从 $t=T$ 步进到 $t=0$，并带有零终端条件 $\\lambda(x,T)=0$ 和 $\\frac{\\partial \\lambda}{\\partial t}(x,T)=0$。源项是在接收点位置注入的数据残差。\n\n3.  **目标函数与梯度**：目标函数 $J(m)$ 是残差的离散平方和：\n    $$\n    J(m) = \\frac{1}{2}\\sum_{r}\\sum_{j=0}^{N_t-1} \\left(u(x_r, t_j; m) - d_r(t_j)\\right)^2 \\Delta t\n    $$\n    梯度通过正向和伴随波场的互相关来计算，根据所提供的公式：\n    $$\n    \\frac{\\delta J}{\\delta m}(x_i) = -\\sum_{j=0}^{N_t-1} \\left(\\frac{u_i^{j+1} - 2u_i^j + u_i^{j-1}}{(\\Delta t)^2}\\right)\\,\\lambda_i^j\\,\\Delta t\n    $$\n    这需要存储整个正向波场 $u(x,t)$。\n\n4.  **验证测试**：\n    -   **梯度检验**：通过将基于伴随的方向导数与有限差分近似进行比较来验证梯度计算。泰勒展开式 $J(m+\\epsilon p) = J(m) + \\epsilon \\langle \\nabla J, p \\rangle + \\mathcal{O}(\\epsilon^2)$ 意味着当 $\\epsilon \\to 0$ 时，$(\\frac{J(m+\\epsilon p)-J(m)}{\\epsilon}) / \\langle \\nabla J, p \\rangle \\to 1$。我们通过检查一系列 $\\epsilon$ 的相对差异是否单调递减来测试二阶收敛性。\n    -   **Hessian向量检验**：通过测试目标函数的二阶泰勒展开来验证梯度的一致性。Hessian向量积 $H v$ 通过梯度的中心差分来近似：$\\frac{\\nabla J(m+\\epsilon v) - \\nabla J(m-\\epsilon v)}{2\\epsilon}$。然后，该测试检验近似的相对误差：$J(m+\\epsilon v) \\approx J(m) + \\epsilon \\langle \\nabla J, v \\rangle + \\frac{1}{2} \\epsilon^2 \\langle v, H v \\rangle$。\n    -   **反演检验**：执行固定迭代次数的简单梯度下降优化。更新方向由预处理后的负梯度给出。使用回溯线搜索来找到一个满足 Armijo 条件的合适步长 $\\alpha_k$，以确保目标函数充分下降。模型通过 $m_{k+1} = m_k - \\alpha_k P \\nabla J(m_k)$ 进行更新，其中 $P$ 是一个平滑预条件子（高斯滤波器）。\n\n这些组件被封装在一个类结构中，以清晰地处理每个测试案例的参数和方法。最终脚本执行三个指定的测试案例，并按要求格式化布尔型的通过/失败结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter1d\n\n# Define global constants for inversion\nARMIJO_C1 = 1e-4\nARMIJO_TAU = 0.5\nINVERSION_ITERATIONS = 10\nGRADIENT_TEST_EPSILONS = [1e-4, 1e-5, 1e-6, 1e-7]\nHESSIAN_TEST_EPSILON = 1e-5\n\nclass FWI1DBenchmark:\n    \"\"\"\n    Encapsulates the 1D FWI problem setup and validation tests.\n    \"\"\"\n    def __init__(self, L, Nx, T, f0, xs_pos, xr_pos, c_true_func, c_init_func, cfl_factor=0.5):\n        # Spatial grid\n        self.L = L\n        self.Nx = Nx\n        self.x = np.linspace(0, L, Nx, dtype=np.float64)\n        self.dx = self.x[1] - self.x[0]\n\n        # Velocity and slowness models\n        self.c_true = c_true_func(self.x)\n        self.m_true = 1.0 / self.c_true**2\n        self.c_init = c_init_func(self.x)\n        self.m_init = 1.0 / self.c_init**2\n\n        # Time grid (CFL condition)\n        c_max = np.max([np.max(self.c_true), np.max(self.c_init)])\n        self.dt = cfl_factor * self.dx / c_max\n        self.T = T\n        self.Nt = int(T / self.dt)\n        self.t = np.arange(self.Nt) * self.dt\n\n        # Source wavelet\n        self.f0 = f0\n        self.src_idx = np.argmin(np.abs(self.x - xs_pos))\n        self.source_wavelet = self._create_ricker()\n\n        # Receiver setup\n        self.rec_indices = [np.argmin(np.abs(self.x - pos)) for pos in xr_pos]\n\n        # Generate \"observed\" data from the true model\n        self.d_obs, _ = self._wave_solver(self.m_true, store_full_field=False)\n\n    def _create_ricker(self):\n        t0 = 1.2 / self.f0  # Shift to ensure wavelet peak is not at t=0\n        arg = (np.pi * self.f0 * (self.t - t0))**2\n        return (1.0 - 2.0 * arg) * np.exp(-arg)\n\n    def _wave_solver(self, m, store_full_field=True):\n        u_prev = np.zeros(self.Nx, dtype=np.float64)\n        u_curr = np.zeros(self.Nx, dtype=np.float64)\n        m_inv_dt2 = (self.dt**2) / m\n\n        rec_data = np.zeros((len(self.rec_indices), self.Nt), dtype=np.float64)\n        full_field = np.zeros((self.Nx, self.Nt), dtype=np.float64) if store_full_field else None\n\n        for j in range(self.Nt):\n            laplacian = np.zeros(self.Nx, dtype=np.float64)\n            laplacian[1:-1] = (u_curr[2:] - 2*u_curr[1:-1] + u_curr[:-2]) / self.dx**2\n            \n            source_term = np.zeros(self.Nx, dtype=np.float64)\n            source_term[self.src_idx] = self.source_wavelet[j]\n\n            u_next = 2*u_curr - u_prev + m_inv_dt2 * (laplacian + source_term)\n            u_next[0] = 0.0\n            u_next[-1] = 0.0\n\n            u_prev, u_curr = u_curr, u_next\n\n            rec_data[:, j] = u_curr[self.rec_indices]\n            if store_full_field:\n                full_field[:, j] = u_curr\n        \n        return rec_data, full_field\n\n    def _adjoint_solver(self, m, residual):\n        lambda_prev = np.zeros(self.Nx, dtype=np.float64)\n        lambda_curr = np.zeros(self.Nx, dtype=np.float64)\n        m_inv_dt2 = (self.dt**2) / m\n\n        adj_src_grid = np.zeros((self.Nx, self.Nt), dtype=np.float64)\n        for i, rec_idx in enumerate(self.rec_indices):\n            adj_src_grid[rec_idx, :] = residual[i, :]\n\n        full_adjoint_field = np.zeros((self.Nx, self.Nt), dtype=np.float64)\n\n        for j in range(self.Nt - 1, -1, -1):\n            laplacian = np.zeros(self.Nx, dtype=np.float64)\n            laplacian[1:-1] = (lambda_curr[2:] - 2*lambda_curr[1:-1] + lambda_curr[:-2]) / self.dx**2\n            \n            lambda_next = 2*lambda_curr - lambda_prev + m_inv_dt2 * (laplacian + adj_src_grid[:, j])\n            lambda_next[0] = 0.0\n            lambda_next[-1] = 0.0\n\n            lambda_prev, lambda_curr = lambda_curr, lambda_next\n            full_adjoint_field[:, j] = lambda_curr\n            \n        return full_adjoint_field\n\n    def _compute_objective(self, m):\n        sim_data, _ = self._wave_solver(m, store_full_field=False)\n        residual = sim_data - self.d_obs\n        return 0.5 * np.sum(residual**2) * self.dt\n\n    def _compute_gradient(self, m):\n        sim_data, u_full = self._wave_solver(m, store_full_field=True)\n        residual = sim_data - self.d_obs\n        lambda_full = self._adjoint_solver(m, residual)\n\n        u_tt = np.zeros_like(u_full)\n        u_tt[:, 1:-1] = (u_full[:, 2:] - 2*u_full[:, 1:-1] + u_full[:, :-2]) / self.dt**2\n        \n        grad = -np.sum(u_tt * lambda_full, axis=1) * self.dt\n        return grad\n\n    def run_gradient_test(self):\n        m = self.m_init\n        p = np.random.randn(self.Nx)\n        p = gaussian_filter1d(p, sigma=2.0)\n        p[0] = p[-1] = 0.0\n        p /= np.linalg.norm(p)\n\n        grad_m = self._compute_gradient(m)\n        grad_dot_p = np.sum(grad_m * p) * self.dx\n\n        discrepancies = []\n        J_m = self._compute_objective(m)\n        \n        for eps in GRADIENT_TEST_EPSILONS:\n            J_m_eps_p = self._compute_objective(m + eps * p)\n            fd_dot_prod = (J_m_eps_p - J_m) / eps\n            if abs(grad_dot_p) > 1e-15:\n                discrepancy = np.abs(fd_dot_prod - grad_dot_p) / np.abs(grad_dot_p)\n                discrepancies.append(discrepancy)\n        \n        if len(discrepancies)  2: return False\n\n        monotonic = all(discrepancies[i] > discrepancies[i+1] for i in range(len(discrepancies)-1))\n        pass_test = monotonic and (discrepancies[-1]  0.10)\n        return pass_test\n\n    def run_hessian_test(self):\n        m = self.m_init\n        eps = HESSIAN_TEST_EPSILON\n        \n        v = np.random.randn(self.Nx)\n        v = gaussian_filter1d(v, sigma=2.0)\n        v[0] = v[-1] = 0.0\n        v /= np.linalg.norm(v)\n\n        J_m = self._compute_objective(m)\n        grad_m = self._compute_gradient(m)\n        T1 = eps * np.sum(grad_m * v) * self.dx\n\n        grad_plus = self._compute_gradient(m + eps * v)\n        grad_minus = self._compute_gradient(m - eps * v)\n        Hv = (grad_plus - grad_minus) / (2 * eps)\n        vHv = np.sum(v * Hv) * self.dx\n        T2 = 0.5 * eps**2 * vHv\n\n        J_approx = J_m + T1 + T2\n        J_true = self._compute_objective(m + eps * v)\n        \n        denominator = np.abs(J_true)\n        if denominator  1e-15: return np.abs(J_true - J_approx)  1e-15\n\n        relative_error = np.abs(J_true - J_approx) / denominator\n        return relative_error  0.25\n\n    def run_inversion_test(self, conv_threshold):\n        m = self.m_init.copy()\n        J_initial = self._compute_objective(m)\n        if J_initial  1e-15: return True\n\n        for _ in range(INVERSION_ITERATIONS):\n            grad = self._compute_gradient(m)\n            search_dir = -gaussian_filter1d(grad, sigma=1.0)\n            search_dir[0] = search_dir[-1] = 0.0\n\n            alpha = 1.0\n            J_current = self._compute_objective(m)\n            grad_dot_s = np.sum(grad * search_dir) * self.dx\n            \n            for _ in range(10): # Max backtracking steps\n                if self._compute_objective(m + alpha * search_dir) = J_current + ARMIJO_C1 * alpha * grad_dot_s:\n                    break\n                alpha *= ARMIJO_TAU\n            else: # Line search failed\n                break\n            \n            m += alpha * search_dir\n        \n        J_final = self._compute_objective(m)\n        return (J_final / J_initial) = conv_threshold\n\ndef solve():\n    np.random.seed(0)\n\n    test_specs = [\n        { # Case 1: Happy path\n            \"L\": 1000.0, \"Nx\": 201, \"T\": 1.0, \"f0\": 10.0, \"xs_pos\": 200.0,\n            \"xr_pos\": [600.0, 700.0, 800.0],\n            \"c_true_func\": lambda x: np.where(x  500.0, 2000.0, 2500.0),\n            \"c_init_func\": lambda x: np.full_like(x, 2200.0),\n            \"cfl_factor\": 0.5, \"conv_thresh\": 0.60\n        },\n        { # Case 2: Near-Courant boundary\n            \"L\": 500.0, \"Nx\": 101, \"T\": 0.6, \"f0\": 15.0, \"xs_pos\": 100.0,\n            \"xr_pos\": [300.0, 400.0],\n            \"c_true_func\": lambda x: 2200.0 + 600.0 * x / 500.0,\n            \"c_init_func\": lambda x: np.full_like(x, 2300.0),\n            \"cfl_factor\": 0.99, \"conv_thresh\": 0.70\n        },\n        { # Case 3: Low-contrast anomaly\n            \"L\": 800.0, \"Nx\": 161, \"T\": 0.8, \"f0\": 12.0, \"xs_pos\": 150.0,\n            \"xr_pos\": [450.0, 550.0, 650.0],\n            \"c_true_func\": lambda x: 2500.0 + 100.0 * np.exp(-(x-500.0)**2 / (2 * 50.0**2)),\n            \"c_init_func\": lambda x: np.full_like(x, 2500.0),\n            \"cfl_factor\": 0.5, \"conv_thresh\": 0.85\n        }\n    ]\n\n    all_results = []\n    for spec in test_specs:\n        benchmark = FWI1DBenchmark(\n            L=spec[\"L\"], Nx=spec[\"Nx\"], T=spec[\"T\"], f0=spec[\"f0\"],\n            xs_pos=spec[\"xs_pos\"], xr_pos=spec[\"xr_pos\"],\n            c_true_func=spec[\"c_true_func\"], c_init_func=spec[\"c_init_func\"],\n            cfl_factor=spec[\"cfl_factor\"]\n        )\n        \n        grad_pass = benchmark.run_gradient_test()\n        hess_pass = benchmark.run_hessian_test()\n        conv_pass = benchmark.run_inversion_test(spec[\"conv_thresh\"])\n        \n        all_results.append([grad_pass, hess_pass, conv_pass])\n\n    output_str = \",\".join([f'[{\",\".join(map(lambda b: str(b).lower(), res))}]' for res in all_results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "3598829"}, {"introduction": "在FWI实现中，一个常见的困惑点是如何在伴随模拟中处理吸收边界。本问题通过应用离散伴随原理来解决此问题，该原理要求伴随算子必须是正向算子的精确数学转置。您将看到该原理如何应用于海绵层阻尼项，从而确保梯度计算与正向问题的物理和数值方法完全一致。[@problem_id:3598938]", "problem": "考虑一个在二维（2D）矩形域中的一阶声波系统，其体积模量 $\\kappa(\\mathbf{x})$ 和密度 $\\rho(\\mathbf{x})$ 空间可变，该系统通过显式交错网格有限差分格式进行时间推进。为了在外边界吸收外向波，正演求解器使用了一个海绵层，该海绵层实现为仅在邻近边界的少数外部网格单元内有定义的线性阻尼项。增加了海绵阻尼的连续方程为\n$$\n\\partial_t p + \\kappa(\\mathbf{x}) \\,\\nabla \\cdot \\mathbf{v} + \\sigma_p(\\mathbf{x})\\, p = s_p(\\mathbf{x},t),\n$$\n$$\n\\rho(\\mathbf{x})\\, \\partial_t \\mathbf{v} + \\nabla p + \\sigma_v(\\mathbf{x})\\, \\mathbf{v} = \\mathbf{s}_v(\\mathbf{x},t),\n$$\n其中，$p$ 是压力，$\\mathbf{v}$ 是质点速度，$\\sigma_p$ 和 $\\sigma_v$ 是非负阻尼剖面，它们在远离边界处为零，在吸收区域内为正，$s_p, \\mathbf{s}_v$ 是源项。\n\n在交错网格上，令 $G_h$ 表示将压力节点映射到速度节点的离散梯度算子，令 $D_h$ 表示将速度节点映射到压力节点的离散散度算子。令 $K$ 为压力节点上 $\\kappa$ 值的对角矩阵，$M$ 为速度节点上 $\\rho$ 值的对角矩阵，令 $\\Sigma_p$ 和 $\\Sigma_v$ 为在各自交错位置上包含离散阻尼剖面的对角矩阵。在时间步长 $\\Delta t$ 上的正演显式时间步进使用半时间步的速度和整时间步的压力：\n$$\n\\mathbf{v}^{n+\\frac{1}{2}} = \\left(I - \\Delta t\\, \\Sigma_v\\right)\\, \\mathbf{v}^{n-\\frac{1}{2}} - \\Delta t\\, M^{-1} G_h\\, p^n,\n$$\n$$\np^{n+1} = \\left(I - \\Delta t\\, \\Sigma_p\\right)\\, p^{n} - \\Delta t\\, K^{-1} D_h\\, \\mathbf{v}^{n+\\frac{1}{2}},\n$$\n并带有适当的源注入（为清晰起见在此省略）。假设空间算子的构造使得关于质量加权内积\n$$\n\\langle (p,\\mathbf{v}), (q,\\mathbf{w}) \\rangle = p^{\\top} K\\, q + \\mathbf{v}^{\\top} M\\, \\mathbf{w},\n$$\n离散散度和梯度满足 $D_h = -K^{-1} G_h^{\\top} M$。\n\n在使用伴随状态法的全波形反演（FWI）中，必须在相同的计算域中对离散伴随方程进行时间反向积分，并累积正演波场和伴随波场的零延迟互相关以形成梯度。正确性的一个必要条件是，离散伴随时间积分器是离散正演时间步进映射的精确伴随（在所选内积下的转置），包括所有边界项。\n\n在伴随计算中，以下哪条关于吸收边界的实现规则能确保离散伴随与正演求解器的边界处理保持一致？\n\nA. 在相同的交错位置上使用完全相同的阻尼系数场 $\\sigma_p(\\mathbf{x})$ 和 $\\sigma_v(\\mathbf{x})$，在时间反向的伴随步进中对相应的伴随变量应用相同的乘性阻尼因子 $\\left(I - \\Delta t\\, \\Sigma_p\\right)$ 和 $\\left(I - \\Delta t\\, \\Sigma_v\\right)$，并且，如果使用分裂场完全匹配层（PML）或卷积完全匹配层（CPML），则引入由具有相同系数的转置线性递归控制的伴随辅助状态；这与 $D_h = -K^{-1} G_h^{\\top} M$ 一起，产生了离散正演边界算子的精确伴随。\n\nB. 在伴随计算中，翻转所有阻尼系数的符号（即将 $\\Sigma_p$ 和 $\\Sigma_v$ 替换为 $-\\Sigma_p$ 和 $-\\Sigma_v$），使吸收层变为放大层，从而抵消边界附近的正演能量损失并确保时间反向积分的稳定性。\n\nC. 在伴随计算中禁用吸收边界，而是在边界附近的缓冲区内强制实施齐次截断（即零残差）；这样做可以在保持离散伴随性的同时，从梯度中移除边界偏差。\n\nD. 如果正演使用 CPML，只需使用相同的系数将相同的 CPML 更新方程沿时间反向运行，而无需存储或重新计算任何辅助记忆变量；递归会自动反转并产生正确的离散伴随。\n\nE. 当正演海绵层仅对压力应用阻尼（即 $\\Sigma_v = 0$）时，在伴随计算中仅对速度应用阻尼，以保持算子关于质量加权内积的对称性。\n\n选择所有适用项。", "solution": "用户希望我验证并解决一个关于在伴随状态全波形反演（FWI）背景下实现吸收边界的问题。\n\n### 步骤1：提取已知条件\n\n问题陈述提供了以下信息：\n1.  **连续控制方程（声学，一阶，带阻尼）：**\n    $$\n    \\partial_t p + \\kappa(\\mathbf{x}) \\,\\nabla \\cdot \\mathbf{v} + \\sigma_p(\\mathbf{x})\\, p = s_p(\\mathbf{x},t)\n    $$\n    $$\n    \\rho(\\mathbf{x})\\, \\partial_t \\mathbf{v} + \\nabla p + \\sigma_v(\\mathbf{x})\\, \\mathbf{v} = \\mathbf{s}_v(\\mathbf{x},t)\n    $$\n    其中，$p$ 是压力，$\\mathbf{v}$ 是质点速度，$\\kappa(\\mathbf{x})$ 是体积模量，$\\rho(\\mathbf{x})$ 是密度，$\\sigma_p$ 和 $\\sigma_v$ 是用于海绵层的非负阻尼剖面，$s_p, \\mathbf{s}_v$ 是源项。\n\n2.  **离散有限差分格式（显式，交错网格）：**\n    -   速度更新：\n        $$\n        \\mathbf{v}^{n+\\frac{1}{2}} = \\left(I - \\Delta t\\, \\Sigma_v\\right)\\, \\mathbf{v}^{n-\\frac{1}{2}} - \\Delta t\\, M^{-1} G_h\\, p^n\n        $$\n    -   压力更新：\n        $$\n        p^{n+1} = \\left(I - \\Delta t\\, \\Sigma_p\\right)\\, p^{n} - \\Delta t\\, K^{-1} D_h\\, \\mathbf{v}^{n+\\frac{1}{2}}\n        $$\n    -   $p^n$ 是时间步 $n$ 的压力，$\\mathbf{v}^{n \\pm \\frac{1}{2}}$ 是半时间步的速度。\n    -   $G_h$ 是离散梯度，$D_h$ 是离散散度。\n    -   $K$ 是压力节点上 $\\kappa$ 值的对角矩阵。\n    -   $M$ 是速度节点上 $\\rho$ 值的对角矩阵。\n    -   $\\Sigma_p, \\Sigma_v$ 分别是压力和速度节点上阻尼剖面的对角矩阵。\n\n3.  **内积和伴随关系：**\n    -   状态向量 $(p, \\mathbf{v})$ 和 $(q, \\mathbf{w})$ 的质量加权内积定义为：\n        $$\n        \\langle (p,\\mathbf{v}), (q,\\mathbf{w}) \\rangle = p^{\\top} K\\, q + \\mathbf{v}^{\\top} M\\, \\mathbf{w}\n        $$\n    -   离散空间算子满足伴随关系：\n        $$\n        D_h = -K^{-1} G_h^{\\top} M\n        $$\n\n4.  **目标：**\n    -   确定离散伴随计算中吸收边界的正确实现规则，以确保伴随时间步进算子是正演时间步进算子的精确伴随。\n\n### 步骤2：使用提取的已知条件进行验证\n\n-   **科学依据：** 该问题牢固地植根于计算地球物理学。一阶声波方程、交错网格有限差分法、海绵层吸收边界以及用于FWI的伴随状态法都是该领域标准和基本的概念。\n-   **良态问题：** 问题具体且可回答。它要求找到给定离散线性算子的伴随，这是一个明确定义的数学问题。\n-   **客观性：** 问题使用精确的数学和计算术语陈述，没有歧义或主观断言。\n-   **完备性：** 问题提供了所有必要的信息：正演时间步进格式、内积定义以及离散空间算子之间的关系。这足以推导出离散伴随算子。\n-   **一致性：** 所提供的信息内部一致。关系 $D_h = -K^{-1} G_h^{\\top} M$ 是在指定质量加权内积下，散度算子和梯度算子之间正确的离散伴随条件（在符号约定下）。\n\n### 步骤3：判断与行动\n\n问题陈述科学合理、良态且内部一致。这是一个有效的问题。我现在将进行推导和求解。\n\n### 推导与求解\n\n问题的核心是找到离散时间步进算子的伴随。从时间步 $n$ 到 $n+1$ 的正演传播是一系列两个线性操作。设给定时间的状态向量由压力场和速度场组成。一系列操作 $L = L_2 L_1$ 的伴随是这些操作的伴随以相反顺序组成的序列：$L^* = L_1^* L_2^*$。\n\n正演传播由以下给出：\n1.  **速度更新 ($L_1$)：** 此步骤将 $(p^n, \\mathbf{v}^{n-\\frac{1}{2}})$ 映射到 $\\mathbf{v}^{n+\\frac{1}{2}}$。\n    $$\n    \\mathbf{v}^{n+\\frac{1}{2}} = \\underbrace{\\left(I - \\Delta t\\, \\Sigma_v\\right)}_{A_v} \\mathbf{v}^{n-\\frac{1}{2}} + \\underbrace{\\left(-\\Delta t\\, M^{-1} G_h\\right)}_{B_v} p^n\n    $$\n2.  **压力更新 ($L_2$)：** 此步骤将 $(p^n, \\mathbf{v}^{n+\\frac{1}{2}})$ 映射到 $p^{n+1}$。\n    $$\n    p^{n+1} = \\underbrace{\\left(I - \\Delta t\\, \\Sigma_p\\right)}_{A_p} p^n + \\underbrace{\\left(-\\Delta t\\, K^{-1} D_h\\right)}_{B_p} \\mathbf{v}^{n+\\frac{1}{2}}\n    $$\n\n伴随计算必须按相反顺序应用这些操作的伴随（$L_2^*$，然后是 $L_1^*$），以将伴随状态向量 $(\\hat{p}, \\hat{\\mathbf{v}})$ 向后传播。\n\n算子 $A$ 关于指定内积的伴随记为 $A^*$。对于一个从空间 $Y$ 映射到 $X$ 的算子 $A$，其伴随 $A^*$ 从 $X$ 映射到 $Y$。定义关系为 $\\langle Ax, y \\rangle_X = \\langle x, A^*y \\rangle_Y$。\n压力的内积为 $\\langle p, q \\rangle_K = q^\\top K p$，速度的内积为 $\\langle \\mathbf{v}, \\mathbf{w} \\rangle_M = \\mathbf{w}^\\top M \\mathbf{v}$。\n\n我们需要找到算子 $A_p, B_p, A_v, B_v$ 的伴随。对于此问题，关键部分是包含在 $A_p$ 和 $A_v$ 中的阻尼项。\n\n**压力阻尼算子 ($A_p$) 的伴随：**\n$A_p = (I - \\Delta t \\Sigma_p)$ 将压力映射到压力。其伴随 $A_p^*$ 必须对所有 $p,q$ 满足 $\\langle A_p p, q \\rangle_K = \\langle p, A_p^* q \\rangle_K$。\n$$\nq^\\top K (I - \\Delta t \\Sigma_p) p = (A_p^* q)^\\top K p = q^\\top (A_p^*)^\\top K p\n$$\n这要求 $K(I - \\Delta t \\Sigma_p) = (A_p^*)^\\top K$。\n由于 $K$ 和 $\\Sigma_p$ 是在相同（压力）网格点上定义的对角矩阵，它们是可交换的：$K \\Sigma_p = \\Sigma_p K$。\n因此，$K(I - \\Delta t \\Sigma_p) = (I - \\Delta t \\Sigma_p)K$。\n如果我们设 $A_p^* = (I - \\Delta t \\Sigma_p)$，我们必须检查是否 $(I - \\Delta t \\Sigma_p)K = (I - \\Delta t \\Sigma_p)^\\top K$。\n矩阵 $(I - \\Delta t \\Sigma_p)$ 是对角的，因此它等于其转置。等式成立。\n所以，$A_p^* = A_p = (I - \\Delta t \\Sigma_p)$。压力阻尼算子是自伴随的。\n\n**速度阻尼算子 ($A_v$) 的伴随：**\n$A_v = (I - \\Delta t \\Sigma_v)$ 将速度映射到速度。类似的论证表明，它关于 $\\langle \\cdot, \\cdot \\rangle_M$ 内积是自伴随的。\n$M$ 和 $\\Sigma_v$ 是速度节点上的对角矩阵，因此它们是可交换的。算子 $(I - \\Delta t \\Sigma_v)$ 是对角的，因此是自伴随的。\n所以，$A_v^* = A_v = (I - \\Delta t \\Sigma_v)$。速度阻尼算子也是自伴随的。\n\n**推导结论：**\n正演时间步进格式的伴随，在时间反向运行时，将对相应的伴随场 $\\hat{p}$ 和 $\\hat{\\mathbf{v}}$ 应用完全相同的乘性阻尼因子 $(I - \\Delta t \\Sigma_p)$ 和 $(I - \\Delta t \\Sigma_v)$。阻尼系数 $\\sigma_p$ 和 $\\sigma_v$ 不会被修改。\n\n这使我们能够评估给定的选项。\n\n### 逐项分析\n\n**A. 在相同的交错位置上使用完全相同的阻尼系数场 $\\sigma_p(\\mathbf{x})$ 和 $\\sigma_v(\\mathbf{x})$，在时间反向的伴随步进中对相应的伴随变量应用相同的乘性阻尼因子 $\\left(I - \\Delta t\\, \\Sigma_p\\right)$ 和 $\\left(I - \\Delta t\\, \\Sigma_v\\right)$，并且，如果使用分裂场完全匹配层（PML）或卷积完全匹配层（CPML），则引入由具有相同系数的转置线性递归控制的伴随辅助状态；这与 $D_h = -K^{-1} G_h^{\\top} M$ 一起，产生了离散正演边界算子的精确伴随。**\n\n该陈述与我们的推导完全一致。海绵层阻尼算子是自伴随的，这意味着在伴随计算中使用相同的系数和因子。对 PML/CPML 的扩展在概念上也是正确的：PML/CPML 是一个线性系统，其伴随涉及伴随辅助状态和转置的更新方程。该陈述正确地指出了创建离散伴随的一个关键原则。\n\n**结论：正确**\n\n**B. 在伴随计算中，翻转所有阻尼系数的符号（即将 $\\Sigma_p$ 和 $\\Sigma_v$ 替换为 $-\\Sigma_p$ 和 $-\\Sigma_v$），使吸收层变为放大层，从而抵消边界附近的正演能量损失并确保时间反向积分的稳定性。**\n\n这是不正确的。如推导所示，阻尼算子是自伴随的，因此符号不会翻转。此外，伴随方程中的放大项 $(I + \\Delta t \\Sigma)$，在时间反向积分时，将导致伴随波场的指数增长，造成严重的数值不稳定性。伴随模型中的阻尼对其稳定性是必要的。伴随方法的目的不是物理上的时间反演，而是梯度信息的正确传播，这需要数学上的伴随算子。\n\n**结论：错误**\n\n**C. 在伴随计算中禁用吸收边界，而是在边界附近的缓冲区内强制实施齐次截断（即零残差）；这样做可以在保持离散伴随性的同时，从梯度中移除边界偏差。**\n\n这是不正确的。正演算子包括阻尼项。要使伴随关系成立，伴随算子必须是完整正演算子的伴随，包括边界处理。在伴随模型中禁用阻尼会破坏这种关系（$L^* \\neq (\\text{正演算子})^*$）。由此产生的梯度将是不正确的，因为它不对应于实际求解的正演问题的真实目标函数失配梯度。\n\n**结论：错误**\n\n**D. 如果正演使用 CPML，只需使用相同的系数将相同的 CPML 更新方程沿时间反向运行，而无需存储或重新计算任何辅助记忆变量；递归会自动反转并产生正确的离散伴随。**\n\n这是不正确的。CPML 涉及其辅助记忆变量的递归更新。这些递归的伴随与原始递归的时间反向应用不同。伴随更新的结构是不同的，并且它们通常需要访问正演传播的场或辅助变量，这些变量必须被存储或重新计算。这个选项是一个严重的过度简化。\n\n**结论：错误**\n\n**E. 当正演海绵层仅对压力应用阻尼（即 $\\Sigma_v = 0$）时，在伴随计算中仅对速度应用阻尼，以保持算子关于质量加权内积的对称性。**\n\n这是不正确的。如推导所示，阻尼算子在其各自的场上是自伴随的。如果正演算子对压力有阻尼（$\\Sigma_p \\neq 0$）而对速度没有阻尼（$\\Sigma_v=0$），那么其伴随将对伴随压力（$\\hat{p}$）有阻尼，而对伴随速度（$\\hat{\\mathbf{v}}$）没有阻尼。伴随操作不会交换应用阻尼的变量。\n\n**结论：错误**", "answer": "$$\\boxed{A}$$", "id": "3598938"}]}