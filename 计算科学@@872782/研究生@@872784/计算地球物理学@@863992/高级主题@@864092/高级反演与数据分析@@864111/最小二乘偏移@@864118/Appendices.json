{"hands_on_practices": [{"introduction": "本练习将指导您实现一个一维有限差分波传播器及其伴随算子。通过执行点积测试，您将获得关于反向模式自动微分原理的实践经验，并验证核心成像算子的正确性。这项实践对于构建可靠的偏移和反演工作流至关重要。", "problem": "以一维常密度声波方程为基本物理基础，其中位移场 $u(x,t)$ 的时间二阶导数等于空间二阶导数乘以波速的平方再加上一个外源项。其连续模型由下式给出\n$$\n\\frac{\\partial^2 u(x,t)}{\\partial t^2} = c^2 \\frac{\\partial^2 u(x,t)}{\\partial x^2} + f(x,t),\n$$\n其中 $c$ 是波速，$f(x,t)$ 是一个源项。我们将空间域离散化为 $N_x$ 个网格点，间距为 $\\Delta x$，将时间域离散化为 $T$ 个时间步，步长为 $\\Delta t$。在时间和空间上使用二阶精度中心有限差分格式，时间索引为 $t$ 的场 $u^t \\in \\mathbb{R}^{N_x}$ 的离散更新公式为\n$$\nu^{t+1} = 2 u^t - u^{t-1} + \\alpha \\, L \\, u^t + \\Delta t^2 \\, f^t,\n$$\n其中 $L$ 表示离散拉普拉斯算子，$\\alpha = \\left( \\frac{c \\, \\Delta t}{\\Delta x} \\right)^2$。离散拉普拉斯算子 $L$ 可用狄利克雷边界条件（边界处位移为零）或周期性边界条件（环绕邻居）构建，在标准欧几里得内积下，这两种边界条件都会产生一个对称的 $L$。假设初始条件为 $u^{-1} = 0$ 和 $u^0 = 0$。\n\n将模型参数 $m \\in \\mathbb{R}^{N_x}$ 定义为一个空间权重，它在所有空间网格点上以相同的方式缩放给定的时间源子波 $s^t \\in \\mathbb{R}$，因此\n$$\nf^t = s^t \\, m.\n$$\n令接收点采样算子在接收点索引集 $\\{r_k\\}_{k=1}^R$ 处提取场 $u^t$，得到数据 $d^{t,k} = u^t[r_k]$。这通过时间步进传播算子和接收点采样定义了一个线性正演算子 $F : \\mathbb{R}^{N_x} \\to \\mathbb{R}^{T \\times R}$，它将 $m$ 映射到数据 $d$。\n\n在最小二乘偏移中，验证离散模拟算子的伴随一致性至关重要。在欧几里得内积下，伴随算子 $F^\\ast$ 定义为\n$$\n\\langle F m, y \\rangle = \\langle m, F^\\ast y \\rangle\n$$\n对于所有 $m \\in \\mathbb{R}^{N_x}$ 和 $y \\in \\mathbb{R}^{T \\times R}$，其中\n$$\n\\langle F m, y \\rangle = \\sum_{t=0}^{T-1} \\sum_{k=1}^{R} d^{t,k} \\, y^{t,k}, \\quad \\text{以及} \\quad \\langle m, n \\rangle = \\sum_{i=0}^{N_x-1} m_i \\, n_i.\n$$\n您必须构建一个可微的分离散波传播算子，并对其计算图使用逆向模式自动微分来计算任意 $y$ 的 $F^\\ast y$。具体来说，逆向模式扫描必须从离散更新方程导出，使用正向传播中遇到的线性算子的转置，并从源注入项 $\\Delta t^2 \\, s^t \\, m$ 累积关于 $m$ 的梯度。\n\n您的任务：\n- 实现离散正演传播算子，该算子使用上述有限差分格式将 $F$ 应用于 $m$ 以生成数据 $d$，并支持狄利克雷和周期性两种边界条件。拉普拉斯算子 $L$ 必须是与所选边界条件一致构建的标准二阶模板。\n- 通过时间步进格式的反向传播，实现逆向模式自动微分来计算任意 $y \\in \\mathbb{R}^{T \\times R}$ 的 $F^\\ast y$。逆向模式更新必须使用正演格式的转置操作，注意在欧几里得内积下，离散拉普拉斯算子以及由此产生的线性算子 $A = 2 I + \\alpha L$ 都是对称的。\n- 对于每个测试用例，计算标量梯度失配\n$$\n\\Delta = \\left| \\langle F m, y \\rangle - \\langle m, F^\\ast y \\rangle \\right|.\n$$\n所有量均为无量纲；输出必须是实值浮点数。\n\n测试套件：\n提供四个测试用例，这些用例改变离散化和边界设置，以衡量不同配置下的失配。每个测试用例由元组 $(N_x, T, \\Delta x, \\Delta t, c, \\text{boundary}, \\text{receivers})$ 定义：\n1. $(64, 120, 1.0, 0.5, 1.0, \\text{Dirichlet}, [16,48])$，使用主频为 $f_p = 0.05$ 的 Ricker 子波。\n2. $(64, 120, 1.0, 0.5, 1.0, \\text{Periodic}, [16,48])$，子波参数与案例1相同。\n3. $(16, 80, 1.0, 0.5, 1.0, \\text{Dirichlet}, [4,12])$，其中 $f_p = 0.08$。\n4. $(64, 100, 1.0, 0.9, 1.0, \\text{Dirichlet}, [20,44])$，其中 $f_p = 0.06$。\n\n为保证可复现性，对于每个案例，从每个案例唯一确定的固定随机种子生成长度为 $N_x$ 的向量 $m$ 和一个 $(T \\times R)$ 的数组 $y$。使用由下式定义的 Ricker 子波 $s^t$\n$$\ns(t) = \\left(1 - 2 (\\pi f_p t)^2 \\right) \\exp\\left( - (\\pi f_p t)^2 \\right),\n$$\n在离散时间 $t = t^t = t \\, \\Delta t$（其中 $t = 0,1,\\dots,T-1$）处求值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按上述测试用例顺序排列的四个失配值，格式为用方括号括起来的逗号分隔列表，例如 `[v1,v2,v3,v4]`。每个 $v_i$ 必须是浮点数。\n\n您的实现必须是一个单一、完整、可运行的程序。不允许用户输入、文件操作和网络访问。", "solution": "该问题要求实现并验证一个一维声波方程传播算子的伴随算子。验证将通过点积测试进行，这是在最小二乘反演和偏移背景下断定伴随算子正确性的基本要求。该问题具有科学依据，是适定的，并为获得唯一、可验证的解提供了所有必要信息。因此，该问题被认为是有效的。\n\n问题的核心在于特定内积下线性算子 $F$ 与其伴随算子 $F^\\ast$ 之间的关系。对于模型参数向量 $m \\in \\mathbb{R}^{N_x}$ 和数据向量 $y \\in \\mathbb{R}^{T \\times R}$，伴随算子的定义属性是：\n$$\n\\langle F m, y \\rangle = \\langle m, F^\\ast y \\rangle\n$$\n在此，$F$ 代表将模型 $m$ 映射到预测数据 $d$ 的整个运算序列，即 $d=Fm$。算子 $F^\\ast$ 将数据空间向量 $y$ 映射回模型空间。我们将构建 $F$ 和 $F^\\ast$，然后计算绝对差 $\\Delta = \\left| \\langle F m, y \\rangle - \\langle m, F^\\ast y \\rangle \\right|$ 以验证一致性。接近机器精度的 $\\Delta$ 值表示实现是正确的。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, lil_matrix\n\ndef get_ricker_wavelet(T, dt, fp):\n    \"\"\"\n    Generates a Ricker wavelet.\n    \"\"\"\n    t_vals = np.arange(T, dtype=np.float64) * dt\n    arg_sq = (np.pi * fp * t_vals) ** 2\n    return (1.0 - 2.0 * arg_sq) * np.exp(-arg_sq)\n\ndef get_laplacian(Nx, dx, boundary='Dirichlet'):\n    \"\"\"\n    Constructs the 1D discrete Laplacian operator as a sparse matrix.\n    \"\"\"\n    diagonals = [np.ones(Nx - 1), -2.0 * np.ones(Nx), np.ones(Nx - 1)]\n    offsets = [-1, 0, 1]\n    # Use LIL format for efficient item assignment, then convert to CSR for mat-vec products\n    L = diags(diagonals, offsets, shape=(Nx, Nx), format='lil', dtype=np.float64)\n\n    if boundary == 'Periodic':\n        L[0, -1] = 1.0\n        L[-1, 0] = 1.0\n    \n    return L.asformat('csr') / (dx**2)\n\ndef forward_propagator(m, Nx, T, dx, dt, c, boundary, receivers, fp):\n    \"\"\"\n    Applies the forward operator F to a model m.\n    \"\"\"\n    # Setup operators and sources\n    s = get_ricker_wavelet(T, dt, fp)\n    L = get_laplacian(Nx, dx, boundary)\n    alpha = (c * dt / dx)**2\n    I = diags([np.ones(Nx)], [0], shape=(Nx, Nx), dtype=np.float64, format='csr')\n    A = (2.0 * I) + (alpha * L)\n    \n    # Initialize wavefields\n    u_prev = np.zeros(Nx, dtype=np.float64)\n    u_curr = np.zeros(Nx, dtype=np.float64)\n    \n    # Initialize data array\n    R = len(receivers)\n    d = np.zeros((T, R), dtype=np.float64)\n    \n    # Time-stepping loop\n    for t in range(T):\n        # Sample data at current time step\n        d[t, :] = u_curr[receivers]\n        \n        # Compute source injection\n        source_term = (dt**2 * s[t]) * m\n        \n        # Compute next wavefield\n        u_next = A @ u_curr - u_prev + source_term\n        \n        # Update wavefields\n        u_prev, u_curr = u_curr, u_next\n        \n    return d\n\ndef adjoint_propagator(y, Nx, T, dx, dt, c, boundary, receivers, fp):\n    \"\"\"\n    Applies the adjoint operator F* to a data-space vector y.\n    \"\"\"\n    # Setup operators and sources\n    s = get_ricker_wavelet(T, dt, fp)\n    L = get_laplacian(Nx, dx, boundary)\n    alpha = (c * dt / dx)**2\n    I = diags([np.ones(Nx)], [0], shape=(Nx, Nx), dtype=np.float64, format='csr')\n    A = (2.0 * I) + (alpha * L)\n    \n    # Initialize adjoint variables\n    grad_m = np.zeros(Nx, dtype=np.float64)\n    v_curr = np.zeros(Nx, dtype=np.float64)\n    v_next = np.zeros(Nx, dtype=np.float64)\n    \n    # Adjoint time-stepping loop (backward in time)\n    for t in range(T - 1, -1, -1):\n        # Inject adjoint source from data\n        adj_source = np.zeros(Nx, dtype=np.float64)\n        adj_source[receivers] = y[t, :]\n        \n        # Compute previous adjoint wavefield\n        v_prev = A @ v_curr - v_next + adj_source\n        \n        # Accumulate gradient w.r.t. m\n        grad_m += (dt**2 * s[t]) * v_curr\n        \n        # Update adjoint fields\n        v_next, v_curr = v_curr, v_prev\n        \n    return grad_m\n\ndef run_dot_product_test(case_params, seed):\n    \"\"\"\n    Runs the full dot-product test for a single case.\n    \"\"\"\n    Nx, T, dx, dt, c, boundary, receivers, fp = case_params\n    R = len(receivers)\n    \n    # Generate reproducible random vectors for m and y\n    rng = np.random.default_rng(seed)\n    m = rng.standard_normal(size=Nx, dtype=np.float64)\n    y = rng.standard_normal(size=(T, R), dtype=np.float64)\n    \n    # Forward operation: d = F(m)\n    d = forward_propagator(m, Nx, T, dx, dt, c, boundary, receivers, fp)\n\n    # Adjoint operation: g = F*(y)\n    g = adjoint_propagator(y, Nx, T, dx, dt, c, boundary, receivers, fp)\n\n    # Compute dot products\n    lhs = np.sum(d * y)\n    rhs = np.sum(m * g)\n    \n    # Return the mismatch\n    return np.abs(lhs - rhs)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (64, 120, 1.0, 0.5, 1.0, 'Dirichlet', [16, 48], 0.05),\n        (64, 120, 1.0, 0.5, 1.0, 'Periodic', [16, 48], 0.05),\n        (16, 80, 1.0, 0.5, 1.0, 'Dirichlet', [4, 12], 0.08),\n        (64, 100, 1.0, 0.9, 1.0, 'Dirichlet', [20, 44], 0.06),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        mismatch = run_dot_product_test(case, seed=i)\n        results.append(mismatch)\n\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3606465"}, {"introduction": "本练习将从算子的正确性转向算子的质量，通过分析有限差分格式的数值频散。您将推导频散关系，并量化诸如模板阶数和时间步长等选择如何导致相速度误差，从而降低图像分辨率并引入各向异性。理解这些数值伪影是为最小二乘偏移设计高保真波传播器的关键。", "problem": "考虑在均匀介质中，由标量波动方程 $ \\partial_{t}^{2} u(\\mathbf{x},t) = c^{2} \\nabla^{2} u(\\mathbf{x},t) $ 控制的二维常密度声波传播，其中 $ c $ 是以 $ \\mathrm{m/s} $ 为单位的恒定波速。使用时间上二阶精度的离散有限差分时间步进格式来近似波场传播，空间拉普拉斯算子则由二阶或四阶精度的差分格式近似。假设使用均匀方形网格，网格间距为 $ \\Delta x = \\Delta y $（单位为 $ \\mathrm{m} $），时间步长为 $ \\Delta t $（单位为 $ \\mathrm{s} $）。定义库朗-弗里德里希斯-列维（CFL）数为 $ S = c \\Delta t / \\Delta x $（无量纲）。\n\n平面波拟设 $ u(\\mathbf{x},t) = \\exp\\{ i (k_{x} x + k_{y} y - \\omega t) \\} $ 可导出蛙跳格式的离散色散关系\n$$ \\cos(\\omega_{\\mathrm{num}} \\Delta t) = 1 + \\tfrac{1}{2} c^{2} \\Delta t^{2} \\, \\mathcal{L}(\\phi_{x},\\phi_{y}), $$\n其中 $ \\omega_{\\mathrm{num}} $ 是数值角频率，$ \\phi_{x} = k_{x} \\Delta x $，$ \\phi_{y} = k_{y} \\Delta x $，且 $ \\mathcal{L}(\\phi_{x},\\phi_{y}) $ 是离散拉普拉斯算子的符号。对于二阶空间差分格式，\n$$ \\mathcal{L}_{2}(\\phi_{x},\\phi_{y}) = \\frac{2}{\\Delta x^{2}} \\left[ \\cos(\\phi_{x}) - 1 \\right] + \\frac{2}{\\Delta x^{2}} \\left[ \\cos(\\phi_{y}) - 1 \\right]. $$\n对于在每个轴上使用系数为 $ \\left[ -\\tfrac{1}{12}, \\tfrac{4}{3}, -\\tfrac{5}{2}, \\tfrac{4}{3}, -\\tfrac{1}{12} \\right] $ 的标准四阶精度一维二阶导数，二维拉普拉斯算子符号是一维符号之和，\n$$ \\mathcal{L}_{4}(\\phi_{x},\\phi_{y}) = \\frac{1}{\\Delta x^{2}} \\left[ -\\tfrac{5}{2} + \\tfrac{8}{3} \\cos(\\phi_{x}) - \\tfrac{1}{6} \\cos(2 \\phi_{x}) \\right] + \\frac{1}{\\Delta x^{2}} \\left[ -\\tfrac{5}{2} + \\tfrac{8}{3} \\cos(\\phi_{y}) - \\tfrac{1}{6} \\cos(2 \\phi_{y}) \\right]. $$\n\n定义目标角频率 $ \\omega = 2 \\pi f_{0} $ 的真实波数大小为 $ k_{\\mathrm{true}} = \\omega / c $，单位为 $ \\mathrm{rad/m} $，并由 $ \\theta \\in [0, \\pi/2] $（以弧度为单位）参数化方向，因此 $ k_{x} = k_{\\mathrm{true}} \\cos \\theta $ 且 $ k_{y} = k_{\\mathrm{true}} \\sin \\theta $。数值相速度为 $ v_{\\mathrm{ph}}(\\theta) = \\omega_{\\mathrm{num}}(\\theta) / k_{\\mathrm{true}} $。\n\n在最小二乘偏移（LSM）中，离散正演算子 $ F $ 的相速度（以及波数）误差会降低成像分辨率。考虑以下基于伴随成像条件中相对波数膨胀的分辨率损失代理：定义方向性波数膨胀因子\n$$ \\rho(\\theta) = \\frac{c}{v_{\\mathrm{ph}}(\\theta)}, $$\n以及平均绝对相对分辨率损失\n$$ \\bar{r} = \\frac{1}{N_{\\theta}} \\sum_{j=1}^{N_{\\theta}} \\left| \\rho(\\theta_{j}) - 1 \\right|, $$\n其中 $ \\{ \\theta_{j} \\}_{j=1}^{N_{\\theta}} $ 是对 $ [0, \\pi/2] $ 的均匀采样。定义数值各向异性振幅\n$$ A = \\max_{\\theta} \\rho(\\theta) - \\min_{\\theta} \\rho(\\theta). $$\n\n可以通过对伴随算子使用权重 $ W(\\theta) $ 进行预处理来构建一个频散感知的伴随校正，以抵消因子 $ \\rho(\\theta) $。考虑两种选择：\n- 各向同性标量校正 $ W_{\\mathrm{iso}} = 1 / \\left( \\frac{1}{N_{\\theta}} \\sum_{j=1}^{N_{\\theta}} \\rho(\\theta_{j}) \\right) $，得到校正后的损失\n$$ \\bar{r}_{\\mathrm{iso}} = \\frac{1}{N_{\\theta}} \\sum_{j=1}^{N_{\\theta}} \\left| W_{\\mathrm{iso}} \\, \\rho(\\theta_{j}) - 1 \\right|. $$\n- 方向性理想校正 $ W_{\\mathrm{dir}}(\\theta) = \\frac{v_{\\mathrm{ph}}(\\theta)}{c} $，得到\n$$ \\bar{r}_{\\mathrm{dir}} = \\frac{1}{N_{\\theta}} \\sum_{j=1}^{N_{\\theta}} \\left| W_{\\mathrm{dir}}(\\theta_{j}) \\, \\rho(\\theta_{j}) - 1 \\right|. $$\n\n您的任务：\n- 从声波方程和平面波拟设出发，推导上述离散色散关系，并推导 $ \\mathcal{L}_{2}(\\phi_{x},\\phi_{y}) $ 和 $ \\mathcal{L}_{4}(\\phi_{x},\\phi_{y}) $ 的显式表达式。\n- 使用色散关系，为给定的测试套件计算 $ \\omega_{\\mathrm{num}}(\\theta) $、$ v_{\\mathrm{ph}}(\\theta) $、$ \\rho(\\theta) $、$ \\bar{r} $、$ \\bar{r}_{\\mathrm{iso}} $ 和 $ A $。\n- 使用以下固定的物理和数值参数：$ c = 2000 \\, \\mathrm{m/s} $，$ \\Delta x = \\Delta y = 10 \\, \\mathrm{m} $，$ f_{0} = 20 \\, \\mathrm{Hz} $，以及在 $ [0, \\pi/2] $ 上均匀间隔的 $ N_{\\theta} = 181 $ 个角度（以弧度为单位）。角度必须以弧度处理。\n- 定义测试套件为以下差分格式阶数和 CFL 数 $ S $ 的组合：\n    1.  二阶差分格式，CFL 数 $ S = 0.3 $。\n    2.  二阶差分格式，CFL 数 $ S = 0.5 $。\n    3.  四阶差分格式，CFL 数 $ S = 0.5 $。\n    4.  四阶差分格式，CFL 数 $ S = 0.7 $。\n- 对每个测试用例，计算并报告元组 $ [\\bar{r}, \\bar{r}_{\\mathrm{iso}}, \\bar{r}_{\\mathrm{dir}}, A] $，其中所有值为实数（无量纲），且 $ \\bar{r}_{\\mathrm{dir}} $ 将受数值精度限制。\n- 您的程序应生成单行输出，其中包含结果，格式为一个由四个列表组成的逗号分隔列表，每个列表都用方括号括起来，顺序与测试套件相同，例如 $ [ [a_{1},b_{1},c_{1},d_{1}], [a_{2},b_{2},c_{2},d_{2}], [a_{3},b_{3},c_{3},d_{3}], [a_{4},b_{4},c_{4},d_{4}] ] $。\n\n输出中的所有浮点数都应表示为小数。不应打印其他文本。结果是无量纲的，因此输出中不需要物理单位。确保所有三角函数运算使用弧度制角度。", "solution": "该问题具有科学依据、适定且客观，因此是有效的。它提出了一个计算地球物理学中的标准数值分析任务。我们将首先推导所需的理论表达式，然后概述计算过程。\n\n### 步骤 1：理论推导\n\n#### 离散色散关系的推导\n二维常密度声波方程为\n$$\n\\partial_{t}^{2} u(\\mathbf{x},t) = c^{2} \\nabla^{2} u(\\mathbf{x},t)\n$$\n其中 $u$ 是压力波场，$\\mathbf{x} = (x,y)$ 是空间坐标，$t$ 是时间，$c$ 是恒定波速。\n我们在均匀网格上离散化该方程，空间步长为 $\\Delta x = \\Delta y$，时间步长为 $\\Delta t$。二阶时间导数使用二阶精度的中心差分（蛙跳格式）进行近似：\n$$\n\\partial_{t}^{2} u(t) \\approx \\frac{u(t+\\Delta t) - 2u(t) + u(t-\\Delta t)}{\\Delta t^{2}}\n$$\n令 $u_{j,k}^{n} = u(j\\Delta x, k\\Delta y, n\\Delta t)$。令 $\\mathcal{D}^2$ 为近似拉普拉斯算子 $\\nabla^2$ 的离散算子。全离散方程为：\n$$\n\\frac{u_{j,k}^{n+1} - 2u_{j,k}^{n} + u_{j,k}^{n-1}}{\\Delta t^{2}} = c^{2} \\mathcal{D}^{2} u_{j,k}^{n}\n$$\n我们通过代入平面波拟设 $u(\\mathbf{x},t) = \\exp\\{i(k_x x + k_y y - \\omega_{\\text{num}} t)\\}$ 来分析此格式的行为，其中 $(k_x, k_y)$ 是空间波数分量，$\\omega_{\\text{num}}$ 是数值角频率。其离散形式为 $u_{j,k}^{n} = \\exp\\{i(k_x j\\Delta x + k_y k\\Delta y - \\omega_{\\text{num}} n\\Delta t)\\}$。\n\n左侧（LHS）变为：\n$$\n\\text{LHS} = \\frac{u_{j,k}^n \\left( e^{-i\\omega_{\\text{num}}\\Delta t} - 2 + e^{i\\omega_{\\text{num}}\\Delta t} \\right)}{\\Delta t^2} = u_{j,k}^n \\frac{2\\cos(\\omega_{\\text{num}}\\Delta t) - 2}{\\Delta t^2}\n$$\n对于右侧（RHS），将像 $\\mathcal{D}^2$ 这样的线性、移不变离散算子应用于复指数，等价于将该指数乘以算子的符号（其傅里叶表示）。令 $\\mathcal{D}^2$ 的符号为 $\\mathcal{L}(\\phi_x, \\phi_y)$，其中 $\\phi_x = k_x \\Delta x$ 且 $\\phi_y = k_y \\Delta y$。则：\n$$\n\\text{RHS} = c^2 \\mathcal{L}(\\phi_x, \\phi_y) u_{j,k}^n\n$$\n令两侧相等并消去 $u_{j,k}^n$：\n$$\n\\frac{2(\\cos(\\omega_{\\text{num}}\\Delta t) - 1)}{\\Delta t^2} = c^2 \\mathcal{L}(\\phi_x, \\phi_y)\n$$\n整理得到 $\\cos(\\omega_{\\text{num}}\\Delta t)$，即为离散色散关系：\n$$\n\\cos(\\omega_{\\text{num}} \\Delta t) = 1 + \\frac{1}{2} c^{2} \\Delta t^{2} \\mathcal{L}(\\phi_{x},\\phi_{y})\n$$\n这与问题描述中给出的表达式相符。\n\n#### 拉普拉斯算子符号的推导\n符号 $\\mathcal{L}$ 取决于用于拉普拉斯算子 $\\nabla^2 = \\partial_x^2 + \\partial_y^2$ 的具体有限差分格式。\n\n**二阶差分格式 ($\\mathcal{L}_2$)**：\n$\\partial_x^2$ 的标准二阶中心差分为：\n$$\n(\\mathcal{D}_x^2 u)_{j,k} = \\frac{u_{j+1,k} - 2u_{j,k} + u_{j-1,k}}{\\Delta x^2}\n$$\n代入平面波 $u_{j,k} = e^{i(k_x j\\Delta x + k_y k\\Delta y)}$：\n$$\n(\\mathcal{D}_x^2 u)_{j,k} = \\frac{u_{j,k} (e^{ik_x\\Delta x} - 2 + e^{-ik_x\\Delta x})}{\\Delta x^2} = u_{j,k} \\frac{2(\\cos(k_x\\Delta x) - 1)}{\\Delta x^2}\n$$\n$\\mathcal{D}_x^2$ 算子的符号是 $\\frac{2(\\cos(\\phi_x) - 1)}{\\Delta x^2}$。\n二维拉普拉斯算子 $\\mathcal{D}^2 = \\mathcal{D}_x^2 + \\mathcal{D}_y^2$ 的符号是每个维度符号的和。当 $\\Delta x = \\Delta y$ 时：\n$$\n\\mathcal{L}_{2}(\\phi_{x},\\phi_{y}) = \\frac{2}{\\Delta x^{2}} [ \\cos(\\phi_{x}) - 1 ] + \\frac{2}{\\Delta x^{2}} [ \\cos(\\phi_{y}) - 1 ]\n$$\n\n**四阶差分格式 ($\\mathcal{L}_4$)**：\n$\\partial_x^2$ 的一维四阶差分格式在 5 点邻域上使用系数 $[-\\frac{1}{12}, \\frac{4}{3}, -\\frac{5}{2}, \\frac{4}{3}, -\\frac{1}{12}]$：\n$$\n(\\mathcal{D}_x^2 u)_{j,k} = \\frac{1}{\\Delta x^2} \\left[ -\\tfrac{1}{12}u_{j+2,k} + \\tfrac{4}{3}u_{j+1,k} - \\tfrac{5}{2}u_{j,k} + \\tfrac{4}{3}u_{j-1,k} - \\tfrac{1}{12}u_{j-2,k} \\right]\n$$\n代入平面波并提出公因子 $u_{j,k}$：\n$$\n(\\mathcal{D}_x^2 u)_{j,k} = \\frac{u_{j,k}}{\\Delta x^2} \\left[ -\\tfrac{1}{12} e^{2ik_x\\Delta x} + \\tfrac{4}{3} e^{ik_x\\Delta x} - \\tfrac{5}{2} + \\tfrac{4}{3} e^{-ik_x\\Delta x} - \\tfrac{1}{12} e^{-2ik_x\\Delta x} \\right]\n$$\n使用 $e^{i\\alpha} + e^{-i\\alpha} = 2\\cos(\\alpha)$ 对各项进行分组：\n$$\n(\\mathcal{D}_x^2 u)_{j,k} = \\frac{u_{j,k}}{\\Delta x^2} \\left[ -\\tfrac{5}{2} + \\tfrac{8}{3}\\cos(k_x\\Delta x) - \\tfrac{1}{6}\\cos(2k_x\\Delta x) \\right]\n$$\n一维符号为 $\\frac{1}{\\Delta x^2} [-\\frac{5}{2} + \\frac{8}{3}\\cos(\\phi_x) - \\frac{1}{6}\\cos(2\\phi_x)]$。将 $x$ 和 $y$ 维度的符号相加，得到二维符号：\n$$\n\\mathcal{L}_{4}(\\phi_{x},\\phi_{y}) = \\frac{1}{\\Delta x^{2}} \\left[ -\\tfrac{5}{2} + \\tfrac{8}{3}\\cos(\\phi_x) - \\tfrac{1}{6}\\cos(2\\phi_x) \\right] + \\frac{1}{\\Delta x^{2}} \\left[ -\\tfrac{5}{2} + \\tfrac{8}{3}\\cos(\\phi_y) - \\tfrac{1}{6}\\cos(2\\phi_y) \\right]\n$$\n两种推导都证实了问题描述中提供的公式。\n\n### 步骤 2：计算方法\n对于由差分格式阶数和 CFL 数 $S$ 定义的每个测试用例，我们执行以下计算。\n\n1.  **定义常量**：\n    物理和数值参数是固定的：波速 $c = 2000 \\, \\mathrm{m/s}$，网格间距 $\\Delta x = 10 \\, \\mathrm{m}$，目标频率 $f_0 = 20 \\, \\mathrm{Hz}$，以及角度数量 $N_{\\theta} = 181$。\n    由此推导其他常量：\n    - 真实角频率：$\\omega = 2 \\pi f_0$。\n    - 真实波数大小：$k_{\\mathrm{true}} = \\omega / c$。\n    - 时间步长：$\\Delta t = S \\Delta x / c$。\n    - 角度数组：$\\theta_j$ 在 $0$ 到 $\\pi/2$ 之间均匀采样 $N_{\\theta}$ 个点。\n\n2.  **计算与方向相关的量**：\n    计算过程对角度数组 $\\theta_j$ 进行矢量化。\n    - 波数分量：$k_x = k_{\\mathrm{true}} \\cos(\\theta_j)$ 和 $k_y = k_{\\mathrm{true}} \\sin(\\theta_j)$。\n    - 无量纲波数：$\\phi_x = k_x \\Delta x$ 和 $\\phi_y = k_y \\Delta x$。\n    - 拉普拉斯算子符号 $\\mathcal{L}(\\phi_x, \\phi_y)$：根据测试用例，使用 $\\mathcal{L}_2$ 或 $\\mathcal{L}_4$ 的相应公式。\n    - 色散关系参数：令 $X = 1 + \\frac{1}{2} c^2 \\Delta t^2 \\mathcal{L}$。通过代入 $S = c\\Delta t/\\Delta x$ 可简化为 $X = 1 + \\frac{1}{2} S^2 \\Delta x^2 \\mathcal{L}$。\n    - 数值角频率：$\\omega_{\\mathrm{num}}(\\theta_j) = \\frac{1}{\\Delta t} \\arccos(X)$。必须满足 $|X| \\le 1$ 条件才能保证稳定性。所选参数对于感兴趣的频率处于稳定范围内。\n    - 数值相速度：$v_{\\mathrm{ph}}(\\theta_j) = \\omega_{\\mathrm{num}}(\\theta_j) / k_{\\mathrm{true}}$。这与问题中的定义一致。\n    - 波数膨胀因子：$\\rho(\\theta_j) = c / v_{\\mathrm{ph}}(\\theta_j) = \\omega / \\omega_{\\mathrm{num}}(\\theta_j)$。该因子量化了频率（或相速度）误差。\n\n3.  **计算最终指标**：\n    使用 $\\rho(\\theta_j)$ 的值数组，我们计算所需的指标。\n    - 平均绝对相对分辨率损失：$\\bar{r} = \\frac{1}{N_{\\theta}} \\sum_{j} |\\rho(\\theta_j) - 1|$。这可计算为 `mean(abs(rho - 1))`。\n    - 数值各向异性振幅：$A = \\max_j(\\rho(\\theta_j)) - \\min_j(\\rho(\\theta_j))$。\n    - 各向同性校正：各向同性权重为 $W_{\\mathrm{iso}} = 1 / (\\frac{1}{N_{\\theta}} \\sum_j \\rho(\\theta_j))$。校正后的损失为 $\\bar{r}_{\\mathrm{iso}} = \\frac{1}{N_{\\theta}} \\sum_j |W_{\\mathrm{iso}}\\rho(\\theta_j) - 1|$。\n    - 理想方向性校正：方向性权重为 $W_{\\mathrm{dir}}(\\theta_j) = v_{\\mathrm{ph}}(\\theta_j) / c = 1/\\rho(\\theta_j)$。校正后的损失为 $\\bar{r}_{\\mathrm{dir}} = \\frac{1}{N_{\\theta}} \\sum_j |W_{\\mathrm{dir}}(\\theta_j)\\rho(\\theta_j) - 1| = \\frac{1}{N_{\\theta}} \\sum_j |1 - 1| = 0$。由于浮点运算，该值将是一个接近机器精度的非零小数。\n\n对所有四个测试用例重复此过程，并收集生成的元组 $[\\bar{r}, \\bar{r}_{\\mathrm{iso}}, \\bar{r}_{\\mathrm{dir}}, A]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical dispersion analysis problem for four test cases.\n    \"\"\"\n\n    # Fixed physical and numerical parameters\n    c = 2000.0  # m/s\n    dx = 10.0   # m\n    f0 = 20.0   # Hz\n    N_theta = 181\n\n    # Derived constants\n    omega = 2.0 * np.pi * f0\n    k_true = omega / c\n    thetas = np.linspace(0.0, np.pi / 2.0, N_theta)\n\n    test_cases = [\n        ('2nd', 0.3),\n        ('2nd', 0.5),\n        ('4th', 0.5),\n        ('4th', 0.7)\n    ]\n\n    # Pre-calculate common components for vectorization\n    kx = k_true * np.cos(thetas)\n    ky = k_true * np.sin(thetas)\n    phi_x = kx * dx\n    phi_y = ky * dx\n\n    def calculate_metrics(stencil_order, S):\n        \"\"\"\n        Calculates the required metrics for a given stencil order and CFL number.\n        \"\"\"\n        dt = S * dx / c\n\n        if stencil_order == '2nd':\n            L = (2.0 / dx**2) * (np.cos(phi_x) - 1.0) + \\\n                (2.0 / dx**2) * (np.cos(phi_y) - 1.0)\n        elif stencil_order == '4th':\n            L_x = (1.0 / dx**2) * (-5.0 / 2.0 + (8.0 / 3.0) * np.cos(phi_x) - (1.0 / 6.0) * np.cos(2.0 * phi_x))\n            L_y = (1.0 / dx**2) * (-5.0 / 2.0 + (8.0 / 3.0) * np.cos(phi_y) - (1.0 / 6.0) * np.cos(2.0 * phi_y))\n            L = L_x + L_y\n        else:\n            raise ValueError(\"Invalid stencil order\")\n\n        # Argument for arccos from dispersion relation\n        # X = 1 + 0.5 * c**2 * dt**2 * L\n        # Simplified form:\n        X = 1.0 + 0.5 * S**2 * dx**2 * L\n\n        # Clip X to the valid domain of arccos to handle potential floating-point inaccuracies\n        X = np.clip(X, -1.0, 1.0)\n        \n        omega_num = np.arccos(X) / dt\n\n        # Numerical phase velocity and wavenumber inflation factor\n        # Avoid division by zero if k_true is zero (not the case here)\n        v_ph = omega_num / k_true\n        rho = c / v_ph\n\n        # Calculate final metrics\n        r_bar = np.mean(np.abs(rho - 1.0))\n        A = np.max(rho) - np.min(rho)\n        \n        # Isotropic correction\n        W_iso = 1.0 / np.mean(rho)\n        r_iso = np.mean(np.abs(W_iso * rho - 1.0))\n\n        # Directional correction\n        W_dir = 1.0 / rho\n        r_dir = np.mean(np.abs(W_dir * rho - 1.0))\n\n        return [r_bar, r_iso, r_dir, A]\n\n    all_results = []\n    for order, S_val in test_cases:\n        result_tuple = calculate_metrics(order, S_val)\n        all_results.append(result_tuple)\n\n    # Format the output string to match the required format: [[...],[...],...]\n    # This construction avoids spaces within the list representations.\n    sublist_strings = [f\"[{','.join(map(str, sublist))}]\" for sublist in all_results]\n    final_output_string = f\"[{','.join(sublist_strings)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3606517"}, {"introduction": "本练习建立在最小二乘框架之上，旨在解决非高斯噪声这一实际地震数据中的常见挑战。您将通过迭代重加权最小二乘法（IRLS）求解，用学生t分布损失函数替代标准的$L_2$数据失配，从而实现一个稳健的偏移算法。这项实践展示了如何扩展最小二乘偏移的目标函数，以生成对异常值和相干噪声污染更具弹性的图像。", "problem": "考虑在Born近似下的线性化声学成像设置，其中反射率模型 $m \\in \\mathbb{R}^n$ 通过一个已知的线性算子 $A \\in \\mathbb{R}^{p \\times n}$ 映射到观测数据 $d \\in \\mathbb{R}^p$，其关系为 $d = A m + \\varepsilon$。在最小二乘偏移中，我们寻求一个估计 $\\hat{m}$，它既能解释数据 $d$ 又能控制模型的粗糙度。在重尾噪声的情况下，用鲁棒的学生t损失函数替代 $L_2$ 失配项可以提高稳定性。带有Tikhonov正则化参数 $\\lambda > 0$ 的鲁棒目标函数为\n$$\nJ(m) = \\sum_{i=1}^p \\frac{\\nu+1}{2}\\,\\log\\!\\left(1 + \\frac{r_i(m)^2}{\\nu\\,\\sigma^2}\\right) + \\frac{\\lambda}{2}\\,\\lVert m \\rVert_2^2,\n$$\n其中 $r(m) = A m - d$ 是残差，$\\nu > 0$ 是自由度参数，$\\sigma > 0$ 是一个尺度参数。迭代重加权最小二乘（IRLS）方法源于得分函数 $\\psi(r_i) = \\partial J/\\partial r_i$，并产生对角权重 $w_i = \\psi(r_i)/r_i$。这些权重随后被用来求解一系列加权正规方程。\n\n从Born近似下的线性反问题以及重尾噪声下的最大似然估计的基本定义和原理出发，推导针对学生t损失函数的IRLS更新式，并实现它以执行鲁棒最小二乘偏移。使用一个物理上合理的合成算子 $A$，该算子构建为一个带有离散Ricker子波核的Toeplitz卷积矩阵，以模拟带限的地震正演过程。具体如下：\n\n- 令模型大小为 $n = 64$，Ricker子波长度为 $\\ell = 15$。使用以下公式定义离散Ricker核 $h \\in \\mathbb{R}^\\ell$\n$$\nh_k = \\Big(1 - 2\\,(\\pi\\,f_0\\,t_k)^2\\Big)\\,\\exp\\!\\Big(-(\\pi\\,f_0\\,t_k)^2\\Big),\n$$\n对于 $k = 0, 1, \\dots, \\ell-1$，其中 $t_k = (k - (\\ell-1)/2)\\,\\Delta t$，且 $\\Delta t = 1$，中心频率 $f_0 = 0.25$。构建 $A$ 使得当索引 $i-j$ 满足 $0 \\le i-j \\le \\ell-1$ 时，$(A m)_i = \\sum_{j=0}^{n-1} h_{i-j}\\,m_j$，否则 $(A m)_i = 0$。这得到的数据长度为 $p = n + \\ell - 1$。\n\n- 生成一个稀疏的真实反射率模型 $m_{\\text{true}} \\in \\mathbb{R}^n$，其包含 $k=8$ 个非零脉冲，脉冲位置是无放回随机选择的，其振幅在 $[-1,1]$ 区间内均匀分布。为确保可复现性，每个测试用例使用指定的伪随机种子。\n\n- 将相干多次波污染模型 $m_{\\text{mult}}$ 定义为 $m_{\\text{true}}$ 的一个平移和平滑版本。设平移量为 $s=5$。通过将 $m_{\\text{true}}$ 循环平移 $s$ 个采样点，并与一个长度为3的盒状核 $b = [1/3, 1/3, 1/3]$ 进行卷积来构建 $m_{\\text{mult}}$。那么，受污染的数据为 $d = A m_{\\text{true}} + \\gamma\\,A m_{\\text{mult}} + \\eta$，其中 $\\gamma \\ge 0$ 控制相干污染的程度，而 $\\eta$ 是随机噪声。\n\n- 通过 $\\eta_i \\sim \\sigma\\,\\mathrm{Student}\\text{-}t(\\nu)$（对于 $i=1,\\dots,p$ 独立同分布）来模拟重尾随机噪声，这里使用由 $\\sigma$ 缩放的标准学生t分布。在一个极端情况下，向噪声中加入 $q$ 个振幅为 $A_{\\text{out}}$ 的随机异常值脉冲。\n\n- 推导学生t损失函数的IRLS权重，并实现一个迭代过程，在第 $k$ 次迭代中求解\n$$\n\\big(A^\\top W^{(k)} A + \\lambda I\\big)\\,m^{(k+1)} = A^\\top W^{(k)} d,\n$$\n其中 $W^{(k)} = \\mathrm{diag}\\big(w_i^{(k)}\\big)$，而 $w_i^{(k)}$ 是根据当前残差 $r^{(k)} = A m^{(k)} - d$ 计算的。使用 $m^{(0)} = 0$ 进行初始化，当目标函数的相对变化 $\\Delta J / J$ 低于 $\\epsilon$ 或迭代次数达到 $K_{\\max}$ 时停止。\n\n- 在不同的噪声机制和污染下，量化收敛性和偏差。对于每个测试用例，报告：\n    1. 停止前所用的IRLS迭代次数 $k^\\star$。\n    2. 相对模型误差 $e_{\\text{rel}} = \\lVert m^{(k^\\star)} - m_{\\text{true}} \\rVert_2 / \\lVert m_{\\text{true}} \\rVert_2$。\n    3. 相干多次波偏差 $b_{\\text{mult}}$，定义为模型误差在 $m_{\\text{mult}}$ 上的标量投影，\n    $$\n    b_{\\text{mult}} = \\frac{\\langle m^{(k^\\star)} - m_{\\text{true}},\\, m_{\\text{mult}} \\rangle}{\\|m_{\\text{mult}}\\|_2^2}.\n    $$\n\n在单个程序中实现以上内容，以评估以下测试套件，每个测试由 $(\\nu, \\sigma, \\gamma, \\text{seed}, q, A_{\\text{out}})$ 指定：\n\n- 测试1（重尾，理想情况）：$(\\nu = 3,\\, \\sigma = 0.1,\\, \\gamma = 0.0,\\, \\text{seed} = 123,\\, q = 0,\\, A_{\\text{out}} = 0.0)$。\n- 测试2（带异常值的极端重尾）：$(\\nu = 2,\\, \\sigma = 0.15,\\, \\gamma = 0.0,\\, \\text{seed} = 456,\\, q = 3,\\, A_{\\text{out}} = 5.0)$。\n- 测试3（相干多次波污染）：$(\\nu = 3,\\, \\sigma = 0.05,\\, \\gamma = 0.6,\\, \\text{seed} = 789,\\, q = 0,\\, A_{\\text{out}} = 0.0)$。\n- 测试4（近高斯基线）：$(\\nu = 100,\\, \\sigma = 0.1,\\, \\gamma = 0.0,\\, \\text{seed} = 101112,\\, q = 0,\\, A_{\\text{out}} = 0.0)$。\n\n使用固定的正则化参数 $\\lambda = 10^{-3}$、容差 $\\epsilon = 10^{-6}$ 和最大迭代次数 $K_{\\max} = 50$。所有量均为无量纲。您的程序应生成单行输出，其中包含按以下顺序聚合为逗号分隔列表并用方括号括起来的结果\n$$\n[\\;k^\\star_1,\\, e_{\\text{rel},1},\\, b_{\\text{mult},1},\\, k^\\star_2,\\, e_{\\text{rel},2},\\, b_{\\text{mult},2},\\, k^\\star_3,\\, e_{\\text{rel},3},\\, b_{\\text{mult},3},\\, k^\\star_4,\\, e_{\\text{rel},4},\\, b_{\\text{mult},4}\\;].\n$$", "solution": "该问题要求使用迭代重加权最小二乘（IRLS）方法，推导并实现一个鲁棒的最小二乘偏移算法。其鲁棒性是通过将标准的二次（$L_2$）数据失配项替换为学生t对数似然函数来实现的，该函数对异常值和重尾噪声不那么敏感。该方法被应用于一个在Born近似下的合成一维地震成像问题。\n\n正演模型由线性系统 $d = A m + \\varepsilon$ 给出，其中 $m \\in \\mathbb{R}^n$ 是地下反射率模型，$d \\in \\mathbb{R}^p$ 是观测数据，$A \\in \\mathbb{R}^{p \\times n}$ 是正演模拟算子（反偏移），$\\varepsilon$ 代表噪声。我们通过最小化以下正则化目标函数来寻求真实模型 $m_{\\text{true}}$ 的一个估计 $\\hat{m}$：\n$$\nJ(m) = \\sum_{i=1}^p \\frac{\\nu+1}{2}\\,\\log\\!\\left(1 + \\frac{r_i(m)^2}{\\nu\\,\\sigma^2}\\right) + \\frac{\\lambda}{2}\\,\\lVert m \\rVert_2^2\n$$\n在此，$r(m) = A m - d$ 是残差向量，$\\lambda > 0$ 是控制模型平滑度的Tikhonov正则化参数，$\\nu > 0$ 是学生t分布的自由度，$\\sigma > 0$ 是一个尺度参数。第一项与假设噪声 $\\varepsilon$ 服从缩放的学生t分布的数据的负对数似然成正比，第二项是正则化惩罚项。\n\n$J(m)$ 的最小值在其关于 $m$ 的梯度为零处找到。梯度为：\n$$\n\\nabla_m J(m) = \\nabla_m \\left( \\sum_{i=1}^p \\frac{\\nu+1}{2}\\,\\log\\!\\left(1 + \\frac{( (Am)_i - d_i )^2}{\\nu\\,\\sigma^2}\\right) \\right) + \\nabla_m \\left( \\frac{\\lambda}{2}\\,m^\\top m \\right)\n$$\n使用链式法则，和式中第 $i$ 项关于模型参数 $m_j$ 的导数为：\n$$\n\\frac{\\partial}{\\partial m_j} \\left( \\dots \\right) = \\frac{\\partial J}{\\partial r_i} \\frac{\\partial r_i}{\\partial m_j}\n$$\n首先，我们求关于残差 $r_i$ 的导数：\n$$\n\\psi(r_i) = \\frac{\\partial J}{\\partial r_i} = \\frac{\\nu+1}{2} \\frac{1}{1 + \\frac{r_i^2}{\\nu\\,\\sigma^2}} \\left( \\frac{2r_i}{\\nu\\,\\sigma^2} \\right) = \\frac{(\\nu+1)r_i}{\\nu\\,\\sigma^2 + r_i^2}\n$$\n这个函数 $\\psi(r_i)$ 被称为得分函数。导数 $\\partial r_i / \\partial m_j$ 就是算子矩阵的元素 $A_{ij}$。组合成梯度向量：\n$$\n\\nabla_m J(m) = A^\\top \\psi(r(m)) + \\lambda m\n$$\n其中 $\\psi(r(m))$ 是分量为 $\\psi(r_i(m))$ 的向量。将梯度设为零可得到最小值的必要条件：\n$$\nA^\\top \\psi(r(m)) + \\lambda m = 0\n$$\n这是一个关于 $m$ 的非线性方程组，因为得分函数 $\\psi$ 非线性地依赖于残差 $r$，而残差 $r$ 又依赖于 $m$。\n\nIRLS算法提供了一个求解该系统的迭代过程。它基于这样一个观察：得分函数可以写成 $\\psi(r_i) = w_i r_i$ 的形式，其中 $w_i$ 是一个权重。从我们推导出的 $\\psi(r_i)$ 表达式可得：\n$$\nw_i = \\frac{\\psi(r_i)}{r_i} = \\frac{\\nu+1}{\\nu\\,\\sigma^2 + r_i^2}\n$$\n这些权重依赖于残差。IRLS方法通过求解一系列加权最小二乘问题来近似解。在每次迭代 $k$ 中，使用当前模型估计 $m^{(k)}$ 产生的残差 $r^{(k)} = A m^{(k)} - d$ 来计算权重 $w_i^{(k)}$。然后将这些权重固定，用于将模型更新到 $m^{(k+1)}$。将 $\\psi(r) = W r$ 代入梯度为零的条件：\n$$\nA^\\top W(r) (Am - d) + \\lambda m = 0 \\implies (A^\\top W(r) A + \\lambda I) m = A^\\top W(r) d\n$$\n因此，IRLS的更新步骤可以表述为：使用第 $k$ 次迭代的权重来求解第 $k+1$ 次迭代的模型：\n$$\n\\big(A^\\top W^{(k)} A + \\lambda I\\big)\\,m^{(k+1)} = A^\\top W^{(k)} d\n$$\n其中 $W^{(k)} = \\mathrm{diag}(w_1^{(k)}, \\dots, w_p^{(k)})$。这是一个关于 $m^{(k+1)}$ 的线性系统，可以使用标准方法求解。该过程从一个初始猜测（通常是 $m^{(0)} = 0$）开始，并迭代直到满足收敛准则。\n\n实现计划如下：\n1.  **合成模型设置**：对于每个测试用例，使用给定的种子建立一个可复现的随机环境。\n    - 正演算子 $A$ 被构建为一个Toeplitz矩阵，表示与长度为 $\\ell=15$、中心频率为 $f_0=0.25$ 的离散Ricker子波的卷积。这模拟了带限地震源的作用。模型大小为 $n=64$，产生的数据长度为 $p = n+\\ell-1 = 78$。\n    - 生成一个稀疏的真实模型 $m_{\\text{true}}$，其中包含 $k=8$ 个随机放置、随机振幅的脉冲。\n    - 通过对 $m_{\\text{true}}$ 进行循环平移和平滑来创建一个相干噪声模型 $m_{\\text{mult}}$。\n    - 最终数据 $d$ 合成为 $d = A m_{\\text{true}} + \\gamma\\,A m_{\\text{mult}} + \\eta$，其中 $\\eta$ 是从带有参数 $\\nu$ 和 $\\sigma$ 的缩放学生t分布中抽取的噪声，可能包含大振幅异常值。\n\n2.  **IRLS迭代**：算法用 $m^{(0)} = 0$ 初始化。循环最多进行 $K_{\\max} = 50$ 次迭代：\n    - 在每次迭代 $k$ 中，计算残差 $r^{(k)} = A m^{(k)} - d$。\n    - 计算目标函数值 $J(m^{(k)})$。如果相对变化 $|J(m^{(k)}) - J(m^{(k-1)})| / |J(m^{(k)})|$ 低于容差 $\\epsilon = 10^{-6}$，则判断为收敛。\n    - 计算对角权重 $w_i^{(k)} = (\\nu+1) / (\\nu\\sigma^2 + (r_i^{(k)})^2)$。\n    - 构建并求解加权正规方程 $(A^\\top W^{(k)} A + \\lambda I) m^{(k+1)} = A^\\top W^{(k)} d$ 以获得下一个模型估计 $m^{(k+1)}$，其中正则化参数为 $\\lambda=10^{-3}$。\n\n3.  **性能评估**：在IRLS算法收敛或达到最大迭代次数后，使用三个指标评估最终估计模型 $\\hat{m} = m^{(k^\\star)}$ 的质量：\n    - 迭代次数 $k^\\star$。\n    - 相对模型误差 $e_{\\text{rel}} = \\|\\hat{m} - m_{\\text{true}}\\|_2 / \\|m_{\\text{true}}\\|_2$。\n    - 相干多次波偏差 $b_{\\text{mult}} = \\langle \\hat{m} - m_{\\text{true}}, m_{\\text{mult}} \\rangle / \\|m_{\\text{mult}}\\|_2^2$，它量化了模型误差在相干噪声结构上的投影。\n\n这个全面的程序允许在各种噪声条件下对鲁棒偏移算法进行定量评估，这些条件包括重尾、离散异常值和相干干扰。测试用例旨在探究这些不同的机制，从简单的重尾情况到包含极端异常值、相干伪影的场景，以及用于比较的近高斯基线（大 $\\nu$）。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import toeplitz\n\ndef run_irls_test(nu, sigma, gamma, seed, q, A_out):\n    \"\"\"\n    Performs a robust least-squares migration using IRLS for a single test case.\n    \"\"\"\n    # Fixed parameters\n    n = 64  # Model size\n    l = 15  # Ricker wavelet length\n    p = n + l - 1  # Data size\n    f0 = 0.25  # Ricker wavelet central frequency\n    dt = 1.0  # Time sampling interval\n    k_spikes = 8  # Number of spikes in true model\n    s_shift = 5  # Shift for coherent multiple model\n    lambda_reg = 1e-3  # Tikhonov regularization parameter\n    epsilon = 1e-6  # Convergence tolerance\n    K_max = 50  # Maximum number of iterations\n\n    # Set seed for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # 1. Generate operators and models\n    \n    # Ricker wavelet kernel h\n    t = (np.arange(l) - (l - 1) / 2.0) * dt\n    arg_sq = (np.pi * f0 * t)**2\n    h = (1.0 - 2.0 * arg_sq) * np.exp(-arg_sq)\n\n    # Forward operator A (convolution matrix)\n    first_col = np.zeros(p)\n    first_col[:l] = h\n    first_row = np.zeros(n)\n    first_row[0] = h[0]\n    A = toeplitz(first_col, first_row)\n    A_T = A.T\n\n    # Ground truth model m_true\n    m_true = np.zeros(n)\n    spike_pos = rng.choice(n, k_spikes, replace=False)\n    spike_amps = rng.uniform(-1.0, 1.0, k_spikes)\n    m_true[spike_pos] = spike_amps\n\n    # Coherent multiple model m_mult\n    boxcar_kernel = np.array([1/3.0, 1/3.0, 1/3.0])\n    m_true_shifted = np.roll(m_true, s_shift)\n    m_mult = np.convolve(m_true_shifted, boxcar_kernel, mode='same')\n\n    # 2. Generate data d\n    \n    # Noise-free data component\n    d_clean = A @ m_true\n    if gamma > 0:\n        d_clean += gamma * (A @ m_mult)\n\n    # Heavy-tailed noise eta\n    eta = sigma * rng.standard_t(nu, size=p)\n    \n    # Add outliers if specified\n    if q > 0:\n        outlier_pos = rng.choice(p, q, replace=False)\n        eta[outlier_pos] += A_out\n\n    d = d_clean + eta\n\n    # 3. IRLS Loop\n    \n    m_k = np.zeros(n)\n    j_prev = np.inf\n    k_star = K_max\n\n    for k_iter in range(K_max):\n        # Calculate residuals and objective function\n        r_k = A @ m_k - d\n        \n        # Student-t log-likelihood term\n        log_term = np.sum(np.log(1 + r_k**2 / (nu * sigma**2)))\n        # Full objective function\n        j_k = 0.5 * (nu + 1) * log_term + 0.5 * lambda_reg * np.dot(m_k, m_k)\n\n        # Check for convergence\n        if k_iter > 0:\n            # Using abs(j_k) in denominator as J is non-negative\n            if abs(j_k) > 1e-9 and abs(j_k - j_prev) / abs(j_k)  epsilon:\n                k_star = k_iter # Number of iterations is k, so 1 to k_iter\n                break\n        j_prev = j_k\n\n        # Calculate IRLS weights\n        w_k = (nu + 1) / (nu * sigma**2 + r_k**2)\n\n        # Solve the weighted normal equations for m_k+1\n        # (A.T @ W @ A + lambda*I) m = A.T @ W @ d\n        # W is diagonal, so W@A can be done by row-wise multiplication\n        # and A.T@W by column-wise multiplication before transpose.\n        # Let's use broadcasting: w_k[:, None] * A\n        \n        LHS = A_T @ (w_k[:, None] * A) + lambda_reg * np.eye(n)\n        RHS = A_T @ (w_k * d)\n\n        try:\n            m_k_plus_1 = np.linalg.solve(LHS, RHS)\n        except np.linalg.LinAlgError:\n            # If solver fails, stop and report failure with K_max\n            break\n\n        m_k = m_k_plus_1\n    \n    m_final = m_k\n\n    # 4. Calculate output metrics\n    \n    # Relative model error\n    norm_m_true = np.linalg.norm(m_true)\n    if norm_m_true > 1e-9:\n        e_rel = np.linalg.norm(m_final - m_true) / norm_m_true\n    else:\n        e_rel = np.linalg.norm(m_final)\n\n    # Coherent multiple bias\n    model_error = m_final - m_true\n    norm_sq_m_mult = np.dot(m_mult, m_mult)\n    if norm_sq_m_mult > 1e-9:\n        b_mult = np.dot(model_error, m_mult) / norm_sq_m_mult\n    else:\n        b_mult = 0.0\n\n    return k_star, e_rel, b_mult\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases: (nu, sigma, gamma, seed, q, A_out)\n    test_cases = [\n        (3.0, 0.1, 0.0, 123, 0, 0.0),      # Test 1\n        (2.0, 0.15, 0.0, 456, 3, 5.0),     # Test 2\n        (3.0, 0.05, 0.6, 789, 0, 0.0),     # Test 3\n        (100.0, 0.1, 0.0, 101112, 0, 0.0), # Test 4\n    ]\n\n    results = []\n    for params in test_cases:\n        nu, sigma, gamma, seed, q, A_out = params\n        k_star, e_rel, b_mult = run_irls_test(nu, sigma, gamma, seed, q, A_out)\n        results.extend([k_star, e_rel, b_mult])\n\n    # Format output as a single comma-separated list in brackets\n    # Example format from problem description suggests this formatting style\n    # [k1, erel1, bmult1, k2, erel2, bmult2, ...]\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "3606487"}]}