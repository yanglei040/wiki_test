{"hands_on_practices": [{"introduction": "在将计算出的梯度用于复杂的反演算法之前，我们必须严格验证其正确性。最基本的检查是离散伴随测试，它从代数层面确保伴随算子的实现确实是切线性算子的精确转置。这个实践练习 [@problem_id:3574147] 提供了一个小规模的、动手的编码任务来实施这一测试，为构建更复杂的模型打下坚实的数值基础。", "problem": "考虑一个半离散线性动力系统，该系统表示状态向量在依赖于模型的线性算子作用下的时间演化，并使用显式 Euler 格式进行积分。设状态维数为 $n_u = 3$，模型维数为 $n_m = 2$，数据（接收器）维数为 $n_d = 2$，时间步数为 $T = 3$。离散时间正演模型为\n$$\n\\mathbf{u}_{n+1} = \\mathbf{A}(\\mathbf{m})\\,\\mathbf{u}_n + \\mathbf{s}_n \\quad \\text{for } n = 0,1,2,\n$$\n其中包含初始条件 $\\mathbf{u}_0$、源项 $\\mathbf{s}_n$ 以及显式 Euler 时间积分器\n$$\n\\mathbf{A}(\\mathbf{m}) = \\mathbf{I} + \\Delta t \\,\\mathbf{M}(\\mathbf{m}),\n\\quad\n\\mathbf{M}(\\mathbf{m}) = \\mathbf{L}_0 + m_1 \\mathbf{L}_1 + m_2 \\mathbf{L}_2,\n$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 单位矩阵，$\\Delta t$ 是时间步长。每个时间 $n$ 的数据由线性采样算子给出\n$$\n\\mathbf{d}_n = \\mathbf{C}\\,\\mathbf{u}_n, \\quad n = 0,1,2,3.\n$$\n设数据空间内积为 $\\langle \\mathbf{x}, \\mathbf{y} \\rangle_D = \\mathbf{x}^\\top \\mathbf{W}_d \\,\\mathbf{y}$，模型空间内积为 $\\langle \\mathbf{p}, \\mathbf{q} \\rangle_M = \\mathbf{p}^\\top \\mathbf{W}_m \\,\\mathbf{q}$，其中 $\\mathbf{W}_d \\in \\mathbb{R}^{n_d \\times n_d}$ 和 $\\mathbf{W}_m \\in \\mathbb{R}^{n_m \\times n_m}$ 是对称正定矩阵。离散伴随检验旨在验证，对于所有 $\\delta \\mathbf{m} \\in \\mathbb{R}^{n_m}$ 以及所有残差序列 $\\{\\mathbf{r}_n\\}_{n=0}^T$（其中 $\\mathbf{r}_n \\in \\mathbb{R}^{n_d}$），下式成立：\n$$\n\\left\\langle \\mathbf{J}\\,\\delta \\mathbf{m}, \\mathbf{r} \\right\\rangle_D \\;=\\; \\left\\langle \\delta \\mathbf{m}, \\mathbf{J}^\\top \\mathbf{r} \\right\\rangle_M,\n$$\n其中 $\\mathbf{J}$ 是离散雅可比矩阵（灵敏度算子），它将模型扰动 $\\delta \\mathbf{m}$ 映射到诱导的数据扰动 $\\{\\delta \\mathbf{d}_n\\}_{n=0}^T$，而 $\\mathbf{J}^\\top$ 表示 $\\mathbf{J}$ 在指定内积下的伴随。对于显式 Euler 格式，正演状态的变分遵循切线性递推关系\n$$\n\\delta \\mathbf{u}_{n+1} = \\mathbf{A}(\\mathbf{m})\\,\\delta \\mathbf{u}_n + \\Delta t \\sum_{i=1}^{n_m} \\delta m_i \\,\\mathbf{L}_i\\,\\mathbf{u}_n,\n\\quad\n\\delta \\mathbf{u}_0 = \\mathbf{0},\n$$\n且诱导的数据变分为 $\\delta \\mathbf{d}_n = \\mathbf{C}\\,\\delta \\mathbf{u}_n$。\n\n您的任务是实现一个程序，该程序针对下面指定的数值，计算离散伴随检验等式的两边，并在一个固定的容差范围内验证它们在数值上相等。您必须实现与显式 Euler 时间积分器和所选内积一致的伴随状态法。必须使用正演和切线性传播来计算 $\\mathbf{J}\\,\\delta \\mathbf{m}$，并必须使用反向伴随递推在给定内积下计算 $\\mathbf{J}^\\top \\mathbf{r}$。\n\n使用以下数值规格：\n- 时间步长：$\\Delta t = 0.1$。\n- 初始状态：\n$$\n\\mathbf{u}_0 = \\begin{bmatrix} 0.2 \\\\ -0.1 \\\\ 0.3 \\end{bmatrix}.\n$$\n- 源项：\n$$\n\\mathbf{s}_0 = \\begin{bmatrix} 1.0 \\\\ -0.5 \\\\ 0.2 \\end{bmatrix},\\quad\n\\mathbf{s}_1 = \\begin{bmatrix} 0.3 \\\\ 0.0 \\\\ -0.1 \\end{bmatrix},\\quad\n\\mathbf{s}_2 = \\begin{bmatrix} 0.0 \\\\ 0.4 \\\\ 0.0 \\end{bmatrix}.\n$$\n- 采样算子：\n$$\n\\mathbf{C} = \\begin{bmatrix}\n1.0  0.0  0.0 \\\\\n0.0  0.0  1.0\n\\end{bmatrix}.\n$$\n- 模型：\n$$\n\\mathbf{m} = \\begin{bmatrix} 1.2 \\\\ -0.7 \\end{bmatrix}.\n$$\n- 算子分量：\n$$\n\\mathbf{L}_0 = \\begin{bmatrix}\n-1.0  0.2  0.0 \\\\\n0.0  -0.5  0.3 \\\\\n0.1  0.0  -0.8\n\\end{bmatrix},\\quad\n\\mathbf{L}_1 = \\begin{bmatrix}\n0.0  0.5  0.0 \\\\\n0.0  0.0  0.2 \\\\\n0.1  0.0  0.0\n\\end{bmatrix},\\quad\n\\mathbf{L}_2 = \\begin{bmatrix}\n-0.3  0.0  0.1 \\\\\n0.2  -0.1  0.0 \\\\\n0.0  0.4  -0.2\n\\end{bmatrix}.\n$$\n\n实现与显式 Euler 递推和指定内积一致的伴随状态法。具体而言：\n- 使用 $\\mathbf{A}(\\mathbf{m})$ 和源项 $\\mathbf{s}_n$（对于 $n=0,1,2$）来传播正演状态 $\\mathbf{u}_n$（对于 $n = 0,1,2,3$）。\n- 在显式 Euler 切线模型下传播切线性变分 $\\delta \\mathbf{u}_n$（对于 $n = 0,1,2,3$）。\n- 将左侧 $\\langle \\mathbf{J}\\delta \\mathbf{m}, \\mathbf{r} \\rangle_D$ 计算为 $\\sum_{n=0}^{T} \\left(\\mathbf{C}\\,\\delta \\mathbf{u}_n\\right)^\\top \\mathbf{W}_d\\,\\mathbf{r}_n$。\n- 使用与显式 Euler 积分器和数据空间内积注入一致的递推关系，在时间上反向计算伴随变量 $\\boldsymbol{\\lambda}_n$，然后在模型空间中构建 $\\mathbf{J}^\\top \\mathbf{r}$。使用模型空间内积来评估 $\\langle \\delta \\mathbf{m}, \\mathbf{J}^\\top \\mathbf{r} \\rangle_M$。\n\n测试套件：\n对以下四种情况评估离散伴随检验，使用上述固定的正演模型参数，但改变内积、模型扰动和残差序列 $\\{\\mathbf{r}_n\\}_{n=0}^{3}$：\n\n情况 1：\n- $\\mathbf{W}_m = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix}$,\n- $\\mathbf{W}_d = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix}$,\n- $\\delta \\mathbf{m} = \\begin{bmatrix} 0.1 \\\\ -0.3 \\end{bmatrix}$,\n- $\\mathbf{r}_0 = \\begin{bmatrix} 0.2 \\\\ -0.1 \\end{bmatrix}$,\n  $\\mathbf{r}_1 = \\begin{bmatrix} -0.3 \\\\ 0.05 \\end{bmatrix}$,\n  $\\mathbf{r}_2 = \\begin{bmatrix} 0.0 \\\\ 0.2 \\end{bmatrix}$,\n  $\\mathbf{r}_3 = \\begin{bmatrix} 0.1 \\\\ -0.05 \\end{bmatrix}$.\n\n情况 2：\n- $\\mathbf{W}_m = \\begin{bmatrix} 2.0  0.2 \\\\ 0.2  1.0 \\end{bmatrix}$,\n- $\\mathbf{W}_d = \\begin{bmatrix} 1.5  0.0 \\\\ 0.0  0.7 \\end{bmatrix}$,\n- $\\delta \\mathbf{m} = \\begin{bmatrix} 0.05 \\\\ 0.02 \\end{bmatrix}$,\n- $\\mathbf{r}_0 = \\begin{bmatrix} 0.05 \\\\ 0.02 \\end{bmatrix}$,\n  $\\mathbf{r}_1 = \\begin{bmatrix} -0.02 \\\\ 0.01 \\end{bmatrix}$,\n  $\\mathbf{r}_2 = \\begin{bmatrix} 0.03 \\\\ -0.04 \\end{bmatrix}$,\n  $\\mathbf{r}_3 = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$.\n\n情况 3：\n- $\\mathbf{W}_m = \\begin{bmatrix} 1.3  0.1 \\\\ 0.1  0.9 \\end{bmatrix}$,\n- $\\mathbf{W}_d = \\begin{bmatrix} 0.8  0.0 \\\\ 0.0  1.2 \\end{bmatrix}$,\n- $\\delta \\mathbf{m} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$,\n- $\\mathbf{r}_0 = \\begin{bmatrix} 0.25 \\\\ -0.15 \\end{bmatrix}$,\n  $\\mathbf{r}_1 = \\begin{bmatrix} 0.1 \\\\ 0.05 \\end{bmatrix}$,\n  $\\mathbf{r}_2 = \\begin{bmatrix} -0.2 \\\\ 0.3 \\end{bmatrix}$,\n  $\\mathbf{r}_3 = \\begin{bmatrix} 0.05 \\\\ -0.02 \\end{bmatrix}$.\n\n情况 4：\n- $\\mathbf{W}_m = \\begin{bmatrix} 1.1  0.0 \\\\ 0.0  0.7 \\end{bmatrix}$,\n- $\\mathbf{W}_d = \\begin{bmatrix} 1.0  0.0 \\\\ 0.0  1.0 \\end{bmatrix}$,\n- $\\delta \\mathbf{m} = \\begin{bmatrix} -0.2 \\\\ 0.4 \\end{bmatrix}$,\n- $\\mathbf{r}_0 = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$,\n  $\\mathbf{r}_1 = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$,\n  $\\mathbf{r}_2 = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$,\n  $\\mathbf{r}_3 = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$.\n\n数值容差：\n如果等式两边的绝对差小于或等于 $10^{-12}$，则认为离散伴随检验得到满足。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$），每个条目都是一个布尔值，指示相应情况是否满足离散伴随检验。", "solution": "该问题陈述已经过仔细验证，并被确定为**有效**。它在科学上基于线性代数和数值分析的原理，特别是关于离散时间动力系统灵敏度分析的伴随状态法。该问题是适定的，所有必需的参数、矩阵和条件都已指明，且维度一致。术语精确，目标明确：对给定系统数值验证离散伴随恒等式。所提供的测试用例，包括那些扰动或残差为零的用例，适合于验证实现的正确性。\n\n问题的核心是验证使用显式 Euler 格式离散化的线性系统的离散伴随关系\n$$\n\\left\\langle \\mathbf{J}\\,\\delta \\mathbf{m}, \\mathbf{r} \\right\\rangle_D \\;=\\; \\left\\langle \\delta \\mathbf{m}, \\mathbf{J}^\\top \\mathbf{r} \\right\\rangle_M\n$$\n左侧（LHS）使用切线性模型计算，将扰动在时间上向前传播。右侧（RHS）使用伴随模型计算，将信息在时间上向后传播。\n\n**1. 左侧（LHS）计算：切线性方法**\n\nLHS 需要计算雅可比算子 $\\mathbf{J}$ 对模型扰动 $\\delta \\mathbf{m}$ 的作用，然后与残差序列 $\\mathbf{r}$ 求内积。这通过以下步骤实现：\n\n**1.1. 正演状态传播：**\n首先，通过迭代正演模型计算“背景”状态序列 $\\{\\mathbf{u}_n\\}_{n=0}^T$。给定初始状态 $\\mathbf{u}_0$，我们计算：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{A}(\\mathbf{m})\\,\\mathbf{u}_n + \\mathbf{s}_n \\quad \\text{for } n = 0, 1, \\dots, T-1\n$$\n其中 $T=3$。对于给定的模型 $\\mathbf{m}$，矩阵 $\\mathbf{A}(\\mathbf{m})$ 是恒定的：\n$$\n\\mathbf{A}(\\mathbf{m}) = \\mathbf{I} + \\Delta t \\,(\\mathbf{L}_0 + m_1 \\mathbf{L}_1 + m_2 \\mathbf{L}_2)\n$$\n这会得到完整的状态轨迹 $\\mathbf{u}_0, \\mathbf{u}_1, \\mathbf{u}_2, \\mathbf{u}_3$。\n\n**1.2. 切线性状态传播：**\n接下来，计算由模型扰动 $\\delta \\mathbf{m} = [\\delta m_1, \\delta m_2]^\\top$ 引起的状态变分 $\\{\\delta \\mathbf{u}_n\\}_{n=0}^T$。这是通过在背景轨迹周围对正演模型进行线性化来完成的。得到的切线性模型是：\n$$\n\\delta \\mathbf{u}_{n+1} = \\mathbf{A}(\\mathbf{m})\\,\\delta \\mathbf{u}_n + \\frac{\\partial \\mathbf{A}(\\mathbf{m})}{\\partial \\mathbf{m}}[\\delta \\mathbf{m}]\\,\\mathbf{u}_n\n$$\n其中 $\\frac{\\partial \\mathbf{A}(\\mathbf{m})}{\\partial \\mathbf{m}}[\\delta \\mathbf{m}]$ 表示方向导数。对于给定的模型，$\\frac{\\partial \\mathbf{A}}{\\partial m_i} = \\Delta t \\, \\mathbf{L}_i$。递推关系变为：\n$$\n\\delta \\mathbf{u}_{n+1} = \\mathbf{A}(\\mathbf{m})\\,\\delta \\mathbf{u}_n + \\Delta t \\left(\\sum_{i=1}^{n_m} \\delta m_i \\,\\mathbf{L}_i\\right)\\mathbf{u}_n, \\quad \\text{with } \\delta \\mathbf{u}_0 = \\mathbf{0}\n$$\n该递推对 $n=0, 1, \\dots, T-1$ 运行，以获得状态变分轨迹 $\\delta \\mathbf{u}_0, \\delta \\mathbf{u}_1, \\delta \\mathbf{u}_2, \\delta \\mathbf{u}_3$。\n\n**1.3. 内积计算：**\n数据的变分为 $\\delta \\mathbf{d}_n = \\mathbf{C}\\,\\delta \\mathbf{u}_n$。伴随检验的 LHS 是在数据空间中的内积，对所有时间步求和：\n$$\n\\left\\langle \\mathbf{J}\\,\\delta \\mathbf{m}, \\mathbf{r} \\right\\rangle_D = \\sum_{n=0}^{T} \\left\\langle \\delta \\mathbf{d}_n, \\mathbf{r}_n \\right\\rangle_D = \\sum_{n=0}^{T} (\\mathbf{C}\\,\\delta \\mathbf{u}_n)^\\top \\mathbf{W}_d\\,\\mathbf{r}_n\n$$\n\n**2. 右侧（RHS）计算：伴随状态法**\n\nRHS 涉及计算伴随算子 $\\mathbf{J}^\\top$ 对残差序列 $\\mathbf{r}$ 的作用。通过定义和求解伴随方程可以高效地完成此操作。推导这些方程的一种正式方法是通过拉格朗日乘子法。我们定义一个目标泛函 $\\mathcal{F}(\\mathbf{m}) = \\sum_{n=0}^{T} \\langle \\mathbf{C}\\mathbf{u}_n, \\mathbf{r}_n \\rangle_D$。量 $\\langle \\mathbf{J}\\delta\\mathbf{m}, \\mathbf{r} \\rangle_D$ 是 $\\mathcal{F}$ 在方向 $\\delta\\mathbf{m}$ 上的 Gateaux 导数。向量 $\\mathbf{J}^\\top\\mathbf{r}$ 是 $\\mathcal{F}$ 在 $\\mathbf{m}$ 处的梯度。\n\n**2.1. 伴随状态方程：**\n伴随方程是通过强制拉格朗日量相对于状态变量的梯度为零来推导的。这导致了一组关于伴随状态变量（拉格朗日乘子）$\\{\\boldsymbol{\\lambda}_n\\}_{n=1}^T$ 的方程，这些方程在时间上反向传播。在时间 $T=3$ 时伴随状态的最终条件由目标函数对最终状态 $\\mathbf{u}_T$ 的依赖性确定：\n$$\n\\boldsymbol{\\lambda}_T = \\mathbf{C}^\\top \\mathbf{W}_d\\,\\mathbf{r}_T\n$$\n前面伴随状态的递推关系是通过对 $n$ 从 $T-1$ 到 $0$ 进行反向递推得到的。从 $\\boldsymbol{\\lambda}_T$ 开始，反向递推遵循：\n$$\n\\boldsymbol{\\lambda}_n = \\mathbf{A}(\\mathbf{m})^\\top \\boldsymbol{\\lambda}_{n+1} + \\mathbf{C}^\\top \\mathbf{W}_d\\,\\mathbf{r}_n.\n$$\n然后，梯度 $\\mathbf{g} = \\mathbf{J}^\\top \\mathbf{r}$ 的第 $i$ 个分量通过将伴随状态与正演状态相关联来计算：\n$$\ng_i = \\Delta t \\sum_{n=0}^{T-1} (\\mathbf{L}_i \\, \\mathbf{u}_n)^\\top \\boldsymbol{\\lambda}_{n+1}.\n$$\n最后，RHS 的计算为 $\\langle \\delta \\mathbf{m}, \\mathbf{g} \\rangle_M = \\delta \\mathbf{m}^\\top \\mathbf{W}_m \\mathbf{g}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the discrete adjoint test problem for four specified cases.\n    \"\"\"\n    \n    # --- Fixed Parameters ---\n    dt = 0.1\n    u0 = np.array([0.2, -0.1, 0.3])\n    s = [\n        np.array([1.0, -0.5, 0.2]),\n        np.array([0.3, 0.0, -0.1]),\n        np.array([0.0, 0.4, 0.0])\n    ]\n    C = np.array([\n        [1.0, 0.0, 0.0],\n        [0.0, 0.0, 1.0]\n    ])\n    m = np.array([1.2, -0.7])\n    L0 = np.array([\n        [-1.0, 0.2, 0.0],\n        [0.0, -0.5, 0.3],\n        [0.1, 0.0, -0.8]\n    ])\n    L1 = np.array([\n        [0.0, 0.5, 0.0],\n        [0.0, 0.0, 0.2],\n        [0.1, 0.0, 0.0]\n    ])\n    L2 = np.array([\n        [-0.3, 0.0, 0.1],\n        [0.2, -0.1, 0.0],\n        [0.0, 0.4, -0.2]\n    ])\n    \n    TOLERANCE = 1e-12\n    I = np.identity(3)\n    \n    # --- Test Cases ---\n    test_cases = [\n        # Case 1\n        {\n            \"Wm\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"Wd\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"dm\": np.array([0.1, -0.3]),\n            \"r\": [\n                np.array([0.2, -0.1]),\n                np.array([-0.3, 0.05]),\n                np.array([0.0, 0.2]),\n                np.array([0.1, -0.05]),\n            ]\n        },\n        # Case 2\n        {\n            \"Wm\": np.array([[2.0, 0.2], [0.2, 1.0]]),\n            \"Wd\": np.array([[1.5, 0.0], [0.0, 0.7]]),\n            \"dm\": np.array([0.05, 0.02]),\n            \"r\": [\n                np.array([0.05, 0.02]),\n                np.array([-0.02, 0.01]),\n                np.array([0.03, -0.04]),\n                np.array([0.0, 0.0]),\n            ]\n        },\n        # Case 3\n        {\n            \"Wm\": np.array([[1.3, 0.1], [0.1, 0.9]]),\n            \"Wd\": np.array([[0.8, 0.0], [0.0, 1.2]]),\n            \"dm\": np.array([0.0, 0.0]),\n            \"r\": [\n                np.array([0.25, -0.15]),\n                np.array([0.1, 0.05]),\n                np.array([-0.2, 0.3]),\n                np.array([0.05, -0.02]),\n            ]\n        },\n        # Case 4\n        {\n            \"Wm\": np.array([[1.1, 0.0], [0.0, 0.7]]),\n            \"Wd\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"dm\": np.array([-0.2, 0.4]),\n            \"r\": [\n                np.array([0.0, 0.0]),\n                np.array([0.0, 0.0]),\n                np.array([0.0, 0.0]),\n                np.array([0.0, 0.0]),\n            ]\n        }\n    ]\n\n    results = []\n    \n    # --- Pre-computation for the fixed forward model ---\n    M = L0 + m[0] * L1 + m[1] * L2\n    A = I + dt * M\n    \n    # 1. Forward State Propagation\n    u_states = [u0]\n    for n in range(3): # n = 0, 1, 2\n        u_next = A @ u_states[n] + s[n]\n        u_states.append(u_next)\n    # u_states now contains u_0, u_1, u_2, u_3\n    \n    for case in test_cases:\n        dm = case[\"dm\"]\n        Wm = case[\"Wm\"]\n        Wd = case[\"Wd\"]\n        r = case[\"r\"]\n        \n        # --- Left-Hand Side (LHS) Calculation ---\n        \n        # 2. Tangent-Linear State Propagation\n        du_source_op = dt * (dm[0] * L1 + dm[1] * L2)\n        du_states = [np.zeros_like(u0)]\n        for n in range(3): # n = 0, 1, 2\n            du_source_term = du_source_op @ u_states[n]\n            du_next = A @ du_states[n] + du_source_term\n            du_states.append(du_next)\n        # du_states now contains delta_u_0, ..., delta_u_3\n        \n        # 3. LHS Inner Product Calculation\n        lhs = 0.0\n        for n in range(4): # n = 0, 1, 2, 3\n            ddn = C @ du_states[n]\n            lhs += ddn.T @ Wd @ r[n]\n            \n        # --- Right-Hand Side (RHS) Calculation ---\n        \n        # 4. Adjoint State Propagation (Backward)\n        # We need lambda_1, lambda_2, lambda_3, and also lambda_0 for full recurrence\n        # In this problem, T=3, so we have states u0, u1, u2, u3 and data/residuals r0, r1, r2, r3.\n        # Adjoint state lambda_4 = 0 (final condition)\n        lambda_3 = C.T @ Wd @ r[3]\n        lambda_2 = A.T @ lambda_3 + C.T @ Wd @ r[2]\n        lambda_1 = A.T @ lambda_2 + C.T @ Wd @ r[1]\n        \n        # We only need lambda_1, lambda_2, lambda_3 for the gradient sum\n        lambda_plus_1_states = [lambda_1, lambda_2, lambda_3]\n        \n        # 5. Gradient Calculation (J^T * r)\n        g = np.zeros(2)\n        for n in range(3): # n = 0, 1, 2\n            # term n uses u_n and lambda_{n+1}\n            # lambda_plus_1_states[0] is lambda_1, etc.\n            # g_i = sum_{n=0..T-1} (L_i u_n)^T lambda_{n+1}\n            g[0] += (L1 @ u_states[n]).T @ lambda_plus_1_states[n]\n            g[1] += (L2 @ u_states[n]).T @ lambda_plus_1_states[n]\n        g *= dt\n        \n        # 6. RHS Inner Product Calculation\n        rhs = dm.T @ Wm @ g\n        \n        # --- Verification ---\n        results.append(np.abs(lhs - rhs) = TOLERANCE)\n\n    print(f\"[{','.join(str(res).lower() for res in results)}]\")\n\nsolve()\n```", "id": "3574147"}, {"introduction": "一旦我们信任梯度计算的正确性，下一步就是理解梯度或敏感度核在物理上告诉我们什么。这个练习 [@problem_id:3574116] 探讨了不同的数据测量方式（例如，单点采样与空间平均）如何直接影响伴随源的形态，并因此决定最终敏感度核的空间分辨率。这项实践将抽象的数学推导与具体的物理直觉联系起来，帮助你理解反演能“看到”什么模型特征。", "problem": "考虑一个由域 $\\Omega \\subset \\mathbb{R}^2$ 表示的二维合成沉积盆地，其边界为吸收边界。声压场 $u(\\mathbf{x}, t)$ 由常密度声波方程控制\n$$\n\\partial_t^2 u(\\mathbf{x}, t) - m(\\mathbf{x}) \\nabla^2 u(\\mathbf{x}, t) = f(\\mathbf{x}, t),\n$$\n其中 $m(\\mathbf{x}) = c(\\mathbf{x})^2$ 是随空间变化的波速平方，$f(\\mathbf{x}, t) = s(t)\\,\\delta(\\mathbf{x} - \\mathbf{x}_s)$ 是位于 $\\mathbf{x}_s$ 的一个点源，其震源时间函数为 $s(t)$，峰值频率为 $f_0$。拟合泛函定义为\n$$\nJ(u) = \\frac{1}{2} \\int_0^T \\| B u(t) - d(t) \\|_{\\mathbf{W}}^2 \\, dt,\n$$\n其中 $B$ 是一个线性测量算子，将波场映射到接收系统处的观测数据，$d(t)$ 是观测到的时间序列，$\\mathbf{W}$ 是一个对称正定加权矩阵，且 $\\|\\mathbf{y}\\|_{\\mathbf{W}}^2 = \\mathbf{y}^\\top \\mathbf{W} \\mathbf{y}$。考虑 $B$ 的两种选择：\n\n$1.$ 在 $N$ 个接收点位置 $\\{\\mathbf{x}_r\\}_{r=1}^N$ 进行点采样：\n$$\n(B_{\\mathrm{pt}} u)_r(t) = u(\\mathbf{x}_r, t), \\quad r = 1, \\dots, N.\n$$\n\n$2.$ 在接收区域 $\\{\\Gamma_r\\}_{r=1}^N$ 上进行空间平均，使用支撑集在 $\\Gamma_r$ 上的非负、归一化权重 $w_r(\\mathbf{x})$：\n$$\n(B_{\\mathrm{avg}} u)_r(t) = \\int_{\\Gamma_r} w_r(\\mathbf{x})\\, u(\\mathbf{x}, t)\\, d\\mathbf{x}, \\quad \\int_{\\Gamma_r} w_r(\\mathbf{x})\\, d\\mathbf{x} = 1.\n$$\n\n假设 $\\mathbf{W}$ 是对角矩阵，其元素为 $W_r  0$，时间窗口 $[0, T]$ 足够长以捕捉完整的波形，并且分部积分后的边界项为零。盆地中的波速 $c_{\\mathrm{basin}}$ 比周围基底的波速 $c_{\\mathrm{basement}}$ 慢，其中 $c_{\\mathrm{basin}} = 2\\,\\mathrm{km/s}$，$c_{\\mathrm{basement}} = 4\\,\\mathrm{km/s}$，且 $f_0 = 5\\,\\mathrm{Hz}$。接收区域的宽度满足 $a \\approx 0.2\\,\\mathrm{km}$，而盆地内部的特征波长为 $\\lambda_{\\mathrm{basin}} \\approx c_{\\mathrm{basin}}/f_0$。\n\n任务：\n$1.$ 从给定的控制方程和拟合泛函的定义出发，推导对于一个通用线性算子 $B$ 的伴随状态方程以及关于 $m(\\mathbf{x})$ 的梯度 $\\nabla J(\\mathbf{x})$。然后，通过写出时空域中对应的伴随源，将你的结果具体化到每个测量算子 $B_{\\mathrm{pt}}$ 和 $B_{\\mathrm{avg}}$。\n\n$2.$ 基于推导出的形式，分析测量算子的选择如何影响盆地内部 $\\nabla J(\\mathbf{x})$ 的空间分辨率。使用给定的数值尺度，论证解析特征尺寸小于或可比于 $a$ 和 $\\lambda_{\\mathrm{basin}}$ 的相对能力。\n\n以下哪个陈述与推导和分辨率分析最相符？\n\nA. 对于点采样，伴随源是在接收点位置处由残差加权的空间 Dirac 分布之和，即 $r_{\\mathrm{pt}}(\\mathbf{x}, t) = \\sum_{r=1}^N W_r\\,[u(\\mathbf{x}_r, t) - d_r(t)]\\,\\delta(\\mathbf{x} - \\mathbf{x}_r)$。对于使用权重 $w_r(\\mathbf{x})$ 在片元上进行空间平均，伴随源是 $r_{\\mathrm{avg}}(\\mathbf{x}, t) = \\sum_{r=1}^N W_r\\left[\\int_{\\Gamma_r} w_r(\\mathbf{y})\\,u(\\mathbf{y}, t)\\, d\\mathbf{y} - d_r(t)\\right] w_r(\\mathbf{x})$。在两种情况下，梯度均为 $\\nabla J(\\mathbf{x}) = -\\int_0^T \\nabla u(\\mathbf{x}, t)\\cdot \\nabla \\lambda(\\mathbf{x}, t)\\, dt$。空间平均展宽了伴随场，因此在近似平均窗口尺度 $a$ 上对梯度进行了低通滤波，所以在盆地内部，与点采样相比，尺寸小于 $a$ 的特征更难被解析，其中 $\\lambda_{\\mathrm{basin}} \\approx 0.4\\,\\mathrm{km}$ 且 $a \\approx 0.2\\,\\mathrm{km}$。\n\nB. 测量算子不影响伴随源，伴随源总是在 $\\Omega$ 上均匀分布的 $r(\\mathbf{x}, t) = \\sum_{r=1}^N W_r[u(\\mathbf{x}, t) - d_r(t)]$，因此点采样和空间平均下 $\\nabla J(\\mathbf{x})$ 的分辨率是相同的。\n\nC. 空间平均在伴随源中引入了一个额外的拉普拉斯算子，$r_{\\mathrm{avg}}(\\mathbf{x}, t) = \\nabla^2\\left(\\sum_{r=1}^N W_r[(B_{\\mathrm{avg}} u)_r(t) - d_r(t)]\\right)$，这增加了 $\\nabla J(\\mathbf{x})$ 中的高频成分，并增强了盆地内的分辨率。\n\nD. 对于点采样，梯度简化为 $\\nabla J(\\mathbf{x}) = -\\int_0^T u(\\mathbf{x}, t)\\,\\lambda(\\mathbf{x}, t)\\, dt$，而对于空间平均，它保持为 $\\nabla J(\\mathbf{x}) = -\\int_0^T \\nabla u(\\mathbf{x}, t)\\cdot \\nabla \\lambda(\\mathbf{x}, t)\\, dt$，这意味着空间平均能产生更尖锐的灵敏度局部化。\n\nE. 由于终端条件，两种测量算子产生的伴随源都仅在 $t=T$ 时非零，因此任何分辨率差异仅取决于源的带宽，而与 $B$ 的空间支撑集无关。", "solution": "该问题要求在两种不同的测量情景下，推导和分析声波方程的伴随状态灵敏度核。我们将首先验证问题的陈述，然后基于变分法和伴随状态法进行严格的推导。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **控制方程**：$\\partial_t^2 u(\\mathbf{x}, t) - m(\\mathbf{x}) \\nabla^2 u(\\mathbf{x}, t) = f(\\mathbf{x}, t)$ 在域 $\\Omega \\subset \\mathbb{R}^2$ 中，带有吸收边界。\n- **模型参数**：$m(\\mathbf{x}) = c(\\mathbf{x})^2$。\n- **源项**：$f(\\mathbf{x}, t) = s(t)\\,\\delta(\\mathbf{x} - \\mathbf{x}_s)$。\n- **拟合泛函**：$J(u) = \\frac{1}{2} \\int_0^T \\| B u(t) - d(t) \\|_{\\mathbf{W}}^2 \\, dt$。\n- **加权**：$\\mathbf{W}$ 是一个对角矩阵，其元素为 $W_r  0$。范数为 $\\|\\mathbf{y}\\|_{\\mathbf{W}}^2 = \\mathbf{y}^\\top \\mathbf{W} \\mathbf{y}$。\n- **测量算子**：\n    1.  点采样：$(B_{\\mathrm{pt}} u)_r(t) = u(\\mathbf{x}_r, t)$。\n    2.  空间平均：$(B_{\\mathrm{avg}} u)_r(t) = \\int_{\\Gamma_r} w_r(\\mathbf{x})\\, u(\\mathbf{x}, t)\\, d\\mathbf{x}$，其中 $\\int_{\\Gamma_r} w_r(\\mathbf{x})\\, d\\mathbf{x} = 1$。\n- **假设**：分部积分后的边界项为零。时间窗口 $[0, T]$ 足够长。\n- **物理参数**：$c_{\\mathrm{basin}} = 2\\,\\mathrm{km/s}$，$c_{\\mathrm{basement}} = 4\\,\\mathrm{km/s}$，$f_0 = 5\\,\\mathrm{Hz}$，接收区域宽度 $a \\approx 0.2\\,\\mathrm{km}$。\n- **派生参数**：$\\lambda_{\\mathrm{basin}} \\approx c_{\\mathrm{basin}}/f_0$。\n\n**步骤2：使用提取的已知条件进行验证**\n问题陈述具有科学依据，描述了地球物理学中全波形反演（FWI）的标准设置。控制方程、拟合泛函和测量算子都定义明确。所有提供的参数对于盆地尺度的地震成像问题在物理上都是现实的。假设标准的隐式初始条件（例如，震源作用前的静止介质），该问题是客观且适定的。\n\n问题陈述中有一个微妙的歧义。“常密度声波方程”这一术语最准确地对应于形式 $\\partial_t^2 u - \\nabla \\cdot (m(\\mathbf{x}) \\nabla u) = f$。问题提供了简化形式 $\\partial_t^2 u - m(\\mathbf{x}) \\nabla^2 u = f$，这仅在 $m(\\mathbf{x})$ 是常数时才等价。由于上下文是空间变化的波速，这种简化使得空间算子非自伴。然而，这在一些文献中是常见的简化。与非均匀介质中波传播的物理学相一致的严格处理，应从 $\\nabla \\cdot (m(\\mathbf{x}) \\nabla u)$ 的形式开始。问题所述的形式在数学上仍然有效，但我们将假设物理上更准确的形式进行推导，因为它能导出该领域使用且选项中呈现的标准梯度表达式。这并不会使问题无效，但需要对数学模型进行澄清。\n\n**步骤3：结论和行动**\n问题是**有效的**。我们通过采用物理上标准的波方程形式来求解。\n\n### 任务1：伴随方程和梯度的推导\n\n为了求出拟合泛函 $J$ 关于模型参数 $m(\\mathbf{x})$ 的梯度，我们使用伴随状态法。我们通过用控制偏微分方程增广泛函 $J$ 来构造拉格朗日量 $\\mathcal{L}$，并通过一个拉格朗日乘子场 $\\lambda(\\mathbf{x}, t)$（即伴随场）来强制约束：\n$$\n\\mathcal{L}(u, \\lambda, m) = J(u) - \\int_0^T \\int_\\Omega \\lambda \\left[ \\partial_t^2 u - \\nabla \\cdot (m \\nabla u) - f \\right] d\\mathbf{x} dt\n$$\n我们考虑模型中的一个微小扰动 $m \\to m + \\delta m$，这会引起波场的一个扰动 $u \\to u + \\delta u$。在驻点处，拉格朗日量的一阶变化为零，即 $\\delta \\mathcal{L} = 0$。\n总变分为 $\\delta \\mathcal{L} = \\frac{\\partial \\mathcal{L}}{\\partial u} \\delta u + \\frac{\\partial \\mathcal{L}}{\\partial m} \\delta m + \\frac{\\partial \\mathcal{L}}{\\partial \\lambda} \\delta \\lambda$。\n关于 $\\delta \\lambda$ 的项恢复了正演偏微分方程。我们关注关于 $u$ 和 $m$ 的变分。\n\n关于 $u$ 的变分由两部分组成：\n1.  来自泛函 $J$：$\\delta_u J = \\int_0^T (B u - d)^\\top \\mathbf{W} (B \\delta u) \\, dt$。使用伴随算子 $B^\\dagger$ 的定义，这可以写成场域上的积分：$\\delta_u J = \\int_0^T \\int_\\Omega [B^\\dagger (\\mathbf{W}(Bu - d))] \\delta u \\, d\\mathbf{x} dt$。\n2.  来自偏微分方程约束项：$-\\int_0^T \\int_\\Omega \\lambda \\left[ \\partial_t^2 \\delta u - \\nabla \\cdot (m \\nabla \\delta u) \\right] d\\mathbf{x} dt$。\n我们对该项进行分部积分。使用所述的边界项消失的假设（在空间和时间上，具有终端条件 $\\lambda(T)=0, \\partial_t \\lambda(T)=0$ 和初始条件 $u(0)=0, \\partial_t u(0)=0$），我们将微分算子从 $\\delta u$ 转移到 $\\lambda$：\n$$\n-\\int_0^T \\int_\\Omega \\delta u \\left[ \\partial_t^2 \\lambda - \\nabla \\cdot (m \\nabla \\lambda) \\right] d\\mathbf{x} dt\n$$\n伴随状态法将 $\\delta u$ 的总系数设为零。这定义了**伴随方程**：\n$$\n\\partial_t^2 \\lambda(\\mathbf{x}, t) - \\nabla \\cdot (m(\\mathbf{x}) \\nabla \\lambda(\\mathbf{x}, t)) = r_\\lambda(\\mathbf{x}, t)\n$$\n其终端条件为 $\\lambda(\\mathbf{x}, T) = 0$ 和 $\\partial_t\\lambda(\\mathbf{x}, T) = 0$。右边的项是**伴随源** $r_\\lambda(\\mathbf{x}, t)$：\n$$\nr_\\lambda(\\mathbf{x}, t) = B^\\dagger (\\mathbf{W}(B u(t) - d(t)))\n$$\n在消除了 $\\delta u$ 项后，剩余的变分 $\\delta \\mathcal{L}$ 给出了梯度。关于 $m$ 的变分为：\n$$\n\\delta_m \\mathcal{L} = - \\int_0^T \\int_\\Omega \\lambda \\left[ - \\nabla \\cdot (\\delta m \\nabla u) \\right] d\\mathbf{x} dt = \\int_0^T \\int_\\Omega \\lambda \\nabla \\cdot (\\delta m \\nabla u) d\\mathbf{x} dt\n$$\n再次分部积分：\n$$\n\\delta_m \\mathcal{L} = - \\int_0^T \\int_\\Omega \\nabla \\lambda \\cdot (\\delta m \\nabla u) d\\mathbf{x} dt = \\int_\\Omega \\delta m(\\mathbf{x}) \\left( -\\int_0^T \\nabla u(\\mathbf{x}, t) \\cdot \\nabla \\lambda(\\mathbf{x}, t) dt \\right) d\\mathbf{x}\n$$\n根据定义，Fréchet 导数（梯度）$\\nabla J(\\mathbf{x}) = \\frac{\\delta J}{\\delta m(\\mathbf{x})}$ 是该积分的核：\n$$\n\\nabla J(\\mathbf{x}) = -\\int_0^T \\nabla u(\\mathbf{x}, t) \\cdot \\nabla \\lambda(\\mathbf{x}, t) dt\n$$\n该表达式是正演波场和伴随波场梯度的相关。\n\n**对测量算子的具体化**\n我们现在通过找到每个算子 $B$ 的伴随算子 $B^\\dagger$ 来求出伴随源 $r_\\lambda$ 的显式形式。\n\n1.  **点采样 ($B_{\\mathrm{pt}}$)**：\n    定义性的内积关系是 $\\int_0^T \\langle B_{\\mathrm{pt}}^\\dagger \\mathbf{y}, u \\rangle_{\\Omega} dt = \\int_0^T \\langle \\mathbf{y}, B_{\\mathrm{pt}} u \\rangle_N dt$。\n    $$ \\int_0^T \\sum_{r=1}^N y_r(t) (B_{\\mathrm{pt}} u)_r(t) dt = \\int_0^T \\sum_{r=1}^N y_r(t) u(\\mathbf{x}_r, t) dt $$\n    $$ = \\int_0^T \\int_\\Omega \\left( \\sum_{r=1}^N y_r(t) \\delta(\\mathbf{x} - \\mathbf{x}_r) \\right) u(\\mathbf{x}, t) d\\mathbf{x} dt $$\n    因此，$(B_{\\mathrm{pt}}^\\dagger \\mathbf{y})(\\mathbf{x}, t) = \\sum_{r=1}^N y_r(t) \\delta(\\mathbf{x} - \\mathbf{x}_r)$。通过设置 $\\mathbf{y}(t) = \\mathbf{W}(B_{\\mathrm{pt}}u(t) - d(t))$ 来得到伴随源，其分量为 $y_r(t) = W_r(u(\\mathbf{x}_r, t) - d_r(t))$。\n    $$ r_{\\mathrm{pt}}(\\mathbf{x}, t) = \\sum_{r=1}^N W_r [u(\\mathbf{x}_r, t) - d_r(t)] \\delta(\\mathbf{x} - \\mathbf{x}_r) $$\n\n2.  **空间平均 ($B_{\\mathrm{avg}}$)**：\n    类似地，\n    $$ \\int_0^T \\sum_{r=1}^N y_r(t) (B_{\\mathrm{avg}} u)_r(t) dt = \\int_0^T \\sum_{r=1}^N y_r(t) \\left( \\int_{\\Gamma_r} w_r(\\mathbf{x'}) u(\\mathbf{x'}, t) d\\mathbf{x'} \\right) dt $$\n    $$ = \\int_0^T \\int_\\Omega \\left( \\sum_{r=1}^N y_r(t) w_r(\\mathbf{x}) \\right) u(\\mathbf{x}, t) d\\mathbf{x} dt $$\n    因此，$(B_{\\mathrm{avg}}^\\dagger \\mathbf{y})(\\mathbf{x}, t) = \\sum_{r=1}^N y_r(t) w_r(\\mathbf{x})$。通过设置 $y_r(t) = W_r((B_{\\mathrm{avg}}u)_r(t) - d_r(t))$ 来得到伴随源。\n    $$ r_{\\mathrm{avg}}(\\mathbf{x}, t) = \\sum_{r=1}^N W_r \\left[ \\int_{\\Gamma_r} w_r(\\mathbf{y}) u(\\mathbf{y}, t) d\\mathbf{y} - d_r(t) \\right] w_r(\\mathbf{x}) $$\n\n### 任务2：分辨率分析\n\n梯度 $\\nabla J(\\mathbf{x})$ 的空间特性由正演场 $u$ 和伴随场 $\\lambda$ 的相互作用决定。伴随场 $\\lambda$ 是一个以 $r_\\lambda(\\mathbf{x},t)$ 为源、在时间上反向传播的波方程的解。伴随源的空间结构直接影响最终梯度的空间分辨率。\n\n-   对于**点采样 ($B_{\\mathrm{pt}}$)**，伴随源 $r_{\\mathrm{pt}}$ 是一系列位于接收点位置 $\\{\\mathbf{x}_r\\}$ 的空间 Dirac delta 函数。因此，伴随场 $\\lambda$ 起源于这些点。$\\lambda$ 的空间频率内容很宽，主要受限于数据残差的时间频率内容和波传播效应（衍射、散射）。\n\n-   对于**空间平均 ($B_{\\mathrm{avg}}$)**，伴随源 $r_{\\mathrm{avg}}$ 是空间分布的。对于每个接收器分量 $r$，源的形状是权重函数 $w_r(\\mathbf{x})$，其特征宽度为 $a$。这等效于将点源响应与函数 $w_r(\\mathbf{x})$ 进行卷积。在空间频域（波数域）中，此卷积对应于与 $w_r(\\mathbf{x})$ 的傅里叶变换相乘。一个空间支撑集尺寸为 $a$ 的函数，其变换充当一个低通滤波器，其截止尺度与 $1/a$ 相关。因此，伴随场 $\\lambda$ 内在地比点采样情况下更平滑，因为高空间频率在源处被抑制了。\n\n**数值评估**：\n问题提供：\n- 盆地中的特征波长：$\\lambda_{\\mathrm{basin}} \\approx c_{\\mathrm{basin}}/f_0 = (2\\,\\mathrm{km/s}) / (5\\,\\mathrm{Hz}) = 0.4\\,\\mathrm{km}$。\n- 接收区域宽度：$a \\approx 0.2\\,\\mathrm{km}$。\n\n片元宽度 $a$ 是特征波长的一半（$a = 0.5 \\lambda_{\\mathrm{basin}}$）。空间平均在 $a$ 的尺度上引入了平滑效应。这对梯度起到了低通滤波的作用，降低了其解析小于 $a$ 的特征的能力。由于点采样没有这种内在的平滑作用，它允许潜在的更高分辨率，受限于 $\\lambda_{\\mathrm{basin}}$ 和采集几何。因此，与点采样相比，空间平均算子降低了解析尺寸可比于或小于 $a$ 的特征的能力。\n\n### 选项评估\n\n**A. 对于点采样，伴随源是在接收点位置处由残差加权的空间 Dirac 分布之和，即 $r_{\\mathrm{pt}}(\\mathbf{x}, t) = \\sum_{r=1}^N W_r\\,[u(\\mathbf{x}_r, t) - d_r(t)]\\,\\delta(\\mathbf{x} - \\mathbf{x}_r)$。对于使用权重 $w_r(\\mathbf{x})$ 在片元上进行空间平均，伴随源是 $r_{\\mathrm{avg}}(\\mathbf{x}, t) = \\sum_{r=1}^N W_r\\left[\\int_{\\Gamma_r} w_r(\\mathbf{y})\\,u(\\mathbf{y}, t)\\, d\\mathbf{y} - d_r(t)\\right] w_r(\\mathbf{x})$。在两种情况下，梯度均为 $\\nabla J(\\mathbf{x}) = -\\int_0^T \\nabla u(\\mathbf{x}, t)\\cdot \\nabla \\lambda(\\mathbf{x}, t)\\, dt$。空间平均展宽了伴随场，因此在近似平均窗口尺度 $a$ 上对梯度进行了低通滤波，所以在盆地内部，与点采样相比，尺寸小于 $a$ 的特征更难被解析，其中 $\\lambda_{\\mathrm{basin}} \\approx 0.4\\,\\mathrm{km}$ 且 $a \\approx 0.2\\,\\mathrm{km}$。**\n- 两种伴随源 $r_{\\mathrm{pt}}$ 和 $r_{\\mathrm{avg}}$ 的表达式根据我们的推导是正确的。\n- 梯度 $\\nabla J(\\mathbf{x})$ 的表达式对于物理上标准的波方程是正确的。\n- 分辨率分析是正确的：空间平均在尺度 $a$ 上充当低通滤波器，降低了对小于 $a$ 的特征的分辨率。\n- 数值计算 $\\lambda_{\\mathrm{basin}} \\approx 0.4\\,\\mathrm{km}$ 是正确的。\n- 结论：**正确**。\n\n**B. 测量算子不影响伴随源，伴随源总是在 $\\Omega$ 上均匀分布的 $r(\\mathbf{x}, t) = \\sum_{r=1}^N W_r[u(\\mathbf{x}, t) - d_r(t)]$，因此点采样和空间平均下 $\\nabla J(\\mathbf{x})$ 的分辨率是相同的。**\n- 声称测量算子不影响伴随源是根本错误的。伴随源明确由 $B^\\dagger(\\dots)$ 给出。\n- 提供的源的公式是荒谬且错误的。\n- 结论：**错误**。\n\n**C. 空间平均在伴随源中引入了一个额外的拉普拉斯算子，$r_{\\mathrm{avg}}(\\mathbf{x}, t) = \\nabla^2\\left(\\sum_{r=1}^N W_r[(B_{\\mathrm{avg}} u)_r(t) - d_r(t)]\\right)$，这增加了 $\\nabla J(\\mathbf{x})$ 中的高频成分，并增强了盆地内的分辨率。**\n- 推导出的空间平均伴随源不包含拉普拉斯算子。这个说法是错误的。拉普拉斯算子会增强高频，这与平均效应相反。\n- 结论：**错误**。\n\n**D. 对于点采样，梯度简化为 $\\nabla J(\\mathbf{x}) = -\\int_0^T u(\\mathbf{x}, t)\\,\\lambda(\\mathbf{x}, t)\\, dt$，而对于空间平均，它保持为 $\\nabla J(\\mathbf{x}) = -\\int_0^T \\nabla u(\\mathbf{x}, t)\\cdot \\nabla \\lambda(\\mathbf{x}, t)\\, dt$，这意味着空间平均能产生更尖锐的灵敏度局部化。**\n- 梯度核的形式取决于被反演的参数（$m$）和偏微分方程的形式，而不是测量算子 $B$。声称梯度公式在不同算子之间会改变是错误的。\n- 形式 $-\\int u \\lambda dt$ 是针对不同类型参数（例如势项）的梯度，而不是拉普拉斯项的系数。\n- 结论：**错误**。\n\n**E. 由于终端条件，两种测量算子产生的伴随源都仅在 $t=T$ 时非零，因此任何分辨率差异仅取决于源的带宽，而与 $B$ 的空间支撑集无关。**\n- 这将伴随源与伴随场的终端条件混淆了。伴随场 $\\lambda$ 在 $t=T$ 时为零，但只要数据残差非零，其源 $r_\\lambda$ 在 $t \\in [0,T]$ 期间就是活跃的。该陈述根本上是错误的。\n- 结论：**错误**。", "answer": "$$\\boxed{A}$$", "id": "3574116"}, {"introduction": "真实的地球物理反演问题在计算上是极其庞大的，需要高性能计算（HPC）资源。最后的这项实践 [@problem_id:3574197] 将焦点从核心算法转移到其实际的大规模实现上。它要求你设计一个并行的工作流，该工作流结合了炮点级并行、带有异步I/O的检查点技术以及高效的通信策略，这些都是在生产级全波形反演代码中最小化求解时间的关键。", "problem": "考虑在具有吸收边界的有界域上，由变系数声波方程控制时域全波形反演。对于每个震源索引 $s \\in \\{1,\\dots,N_s\\}$，正演场 $u_s(\\mathbf{x},t)$ 满足以下形式的线性偏微分方程\n$$\n\\mathcal{L}(m)\\,u_s(\\mathbf{x},t)=f_s(\\mathbf{x},t), \\quad u_s(\\mathbf{x},0)=0, \\quad \\partial_t u_s(\\mathbf{x},0)=0,\n$$\n其中 $m(\\mathbf{x})$ 是模型参数（例如，平方慢度），$\\mathcal{L}(m)$ 是一个对 $u_s$ 线性且平滑依赖于 $m$ 的微分算子，而 $f_s$ 是一个已知的震源项。对于每个 $s$，在 $N_r$ 个接收点上观测到的数据为 $d_s^{\\mathrm{obs}}(t)$。一个标准的最小二乘残差为\n$$\nJ(m)=\\frac{1}{2}\\sum_{s=1}^{N_s}\\sum_{r=1}^{N_r}\\int_{0}^{T}\\left(u_s(\\mathbf{x}_r,t;m)-d_{s,r}^{\\mathrm{obs}}(t)\\right)^2\\,\\mathrm{d}t,\n$$\n其中 $\\mathbf{x}_r$ 为接收点位置。假设伴随状态法适用，并且 $J$ 的梯度可以表示为一个正演场与一个对数据残差呈线性的伴随场之间的时空双线性相互作用。该计算任务必须在一个分布式内存的高性能计算（HPC）系统上执行，该系统具有以下规格和约束：\n\n- 全程可使用 $P=64$ 个相同的计算节点（处理器）。\n- 每个节点拥有 $128\\,\\mathrm{GB}$ 内存和一个节点本地固态硬盘，其持续读写带宽为 $2\\,\\mathrm{GB/s}$。\n- 在分配给一个节点的子域上，单个正演或伴随时间步的计算耗时为 $t_{\\mathrm{step}}=0.012\\,\\mathrm{s}$。总时间步数为 $T_{\\mathrm{steps}}=8000$。\n- 为了通过伴随状态法计算梯度而无需完全重新计算正演场，使用了检查点技术：每个震源每 $k=100$ 个时间步存储一次正演状态的快照。每个节点上存储的每个检查点大小为 $1\\,\\mathrm{GB}$。\n- 检查点被写入和读取于节点本地存储。输入/输出（I/O）可以同步（阻塞）或异步（非阻塞）发起，并且在不受带宽限制的情况下可以与计算重叠。\n- 梯度是一个分布在所有节点上的空间场。每个节点上的本地部分大小为 $2\\,\\mathrm{GB}$。需要一个跨所有节点的全局求和来组合成完整的梯度。互连支持基于树的 all-reduce 操作，有效带宽为 $10\\,\\mathrm{GB/s}$，延迟与批量传输相比可以忽略不计。\n\n请您在以下选项中选择一个工作流，该工作流需同时满足以下两个条件：(i) 通过伴随状态法为给定的残差和正演模型生成数学上正确的梯度，以及 (ii) 通过利用震源并行、批处理、异步检查点I/O和高效的部分梯度归约，在约束条件下最小化墙上时钟时间。您可以假定以下额外细节用于时间估算：\n\n- 使用大小为 $G$ 个节点的子通信域，可以作为一个批次并发模拟 $K=\\lfloor P/G \\rfloor$ 个震源。对于固定的全局网格大小，计算时间与 $G$ 成反比（在此限制内为理想的强扩展性）。\n- 在两个检查点之间，每个节点的计算时间为 $t_{\\mathrm{comp,int}}=k \\, t_{\\mathrm{step}}=1.2\\,\\mathrm{s}$。\n- 每个节点写入或读取单个检查点需要 $t_{\\mathrm{io,cp}}=0.5\\,\\mathrm{s}$，如果与持续时间至少为 $t_{\\mathrm{io,cp}}$ 的计算重叠，则可以完全隐藏该开销。\n\n选项：\n\nA. 顺序地为每个震源使用所有 $P$ 个节点。对于每个震源，运行正演模拟，将检查点同步写入并行文件系统，使得模拟在每个检查点处阻塞 $t_{\\mathrm{io,cp}}$ 的时间。然后运行伴随模拟，使用同步读取，在每个检查点处阻塞 $t_{\\mathrm{io,cp}}$ 的时间。在每个震源的伴随模拟完成后，对 $2\\,\\mathrm{GB}$ 的本地梯度在所有 $P$ 个节点上执行一次阻塞的 all-reduce 操作，以累加到全局梯度中。逐个震源处理，直到处理完 $N_s$ 个震源。\n\nB. 将 $P$ 个节点划分为 $K=P/G$ 个子通信域，每个子通信域大小为 $G=8$ 个节点，以批处理方式并发处理 $K=8$ 个震源。对于每个批次，在每个子通信域上并为每个分配的震源：运行正演模拟，并在每 $k$ 步时向节点本地存储发起异步、非阻塞的检查点写入，将 I/O 与检查点之间的 $t_{\\mathrm{comp,int}}$ 计算重叠。在该批次的正演运行结束后，对于其子通信域上的每个震源，逆时运行伴随模拟，在关联当前窗口以累积该震源的本地梯度时，异步预取下一个所需的检查点。在每个子通信域内将 $K$ 个单源本地梯度相加，得到一个子通信域本地的部分梯度。在批次结束时，启动一个非阻塞的基于树的 all-reduce 操作，将 $K$ 个子通信域本地的部分梯度在所有 $P$ 个节点上求和，得到全局梯度，同时立即开始下一个批次的正演运行，以将归约操作与计算重叠。对所有 $\\lceil N_s/K \\rceil$ 个批次重复此过程。\n\nC. 对于所有震源，使用全部 $P$ 个节点运行一次正演模拟，但不是进行检查点操作，而是将每个震源所有时间步的完整正演场时间历史流式写入磁盘。在所有正演模拟完成后，通过对所有震源和接收点的残差求和，形成一个单一的复合伴随震源，并运行一次单一的伴随模拟。将该单一伴随场与一个由平均化的“复合”震源计算出的单一正演场相关联，以一次性生成梯度。在最后执行一次 all-reduce 操作。\n\nD. 将 $P$ 个节点划分为大小为 $G=8$ 的子通信域，并以批处理方式并发处理 $K=8$ 个震源。像选项B一样，对检查点使用异步I/O。在伴随反向传播期间，为了降低归约成本，在每个子通信域内，对于每个网格点，保留 $K$ 个震源的本地梯度贡献中的最大值（绝对值），而不是它们的和。在每个批次结束时，对这些每个子通信域的最大值执行一次阻塞的 all-reduce 操作以形成全局梯度，然后进行下一个批次。\n\n哪个选项同时满足数学正确性和所述的性能目标？\n\n选择：\n- A. 顺序、同步I/O的工作流，带有每震源阻塞归约。\n- B. 批处理、子通信域的工作流，带有完全重叠的异步检查点I/O和与计算重叠的每批次单次非阻塞all-reduce。\n- C. 写入完整时间历史，使用单一复合伴随源和单次正演相关。\n- D. 批处理、异步工作流，在全局归约前用逐点最大值替换逐源求和。", "solution": "用户要求评估用于计算全波形反演（FWI）问题中梯度的四种不同计算工作流。评估标准是 (i) 数学正确性 和 (ii) 在给定的高性能计算（HPC）系统上最小化墙上时钟时间。\n\n### 问题验证\n\n首先，我将验证问题陈述。\n\n**步骤 1：提取已知条件**\n-   控制物理：变系数声波方程的时域FWI。\n-   正演问题：对于 $s \\in \\{1,\\dots,N_s\\}$，$\\mathcal{L}(m)\\,u_s(\\mathbf{x},t)=f_s(\\mathbf{x},t)$，其中 $u_s(\\mathbf{x},0)=0$ 且 $\\partial_t u_s(\\mathbf{x},0)=0$。\n-   残差泛函：$J(m)=\\frac{1}{2}\\sum_{s=1}^{N_s}\\sum_{r=1}^{N_r}\\int_{0}^{T}\\left(u_s(\\mathbf{x}_r,t;m)-d_{s,r}^{\\mathrm{obs}}(t)\\right)^2\\,\\mathrm{d}t$。\n-   梯度方法：伴随状态法，梯度表示为时空双线性相互作用。\n-   HPC系统：$P=64$ 个节点，每个节点 $128\\,\\mathrm{GB}$ 内存，节点本地 I/O 带宽 $2\\,\\mathrm{GB/s}$。\n-   模拟参数：$t_{\\mathrm{step}}=0.012\\,\\mathrm{s}$ （每个节点的时间步成本），$T_{\\mathrm{steps}}=8000$ （总时间步数）。\n-   检查点技术：每 $k=100$ 步一次，每个节点大小为 $1\\,\\mathrm{GB}$，存放在节点本地存储。\n-   梯度数据：每个节点的本地部分为 $2\\,\\mathrm{GB}$，通过 all-reduce 进行全局求和，有效带宽为 $10\\,\\mathrm{GB/s}$。\n-   性能模型：强扩展性（对于 $G$ 个节点，时间 $\\propto 1/G$）。$t_{\\mathrm{comp,int}}=k \\, t_{\\mathrm{step}}=1.2\\,\\mathrm{s}$ （检查点之间的计算时间）。$t_{\\mathrm{io,cp}}=0.5\\,\\mathrm{s}$ （一个检查点的I/O时间）。\n\n**步骤 2：使用提取的已知条件进行验证**\n-   **科学基础**：该问题在计算地震学和科学计算领域有坚实的基础。它描述了标准的L2范数FWI问题，使用伴随状态法求解，这是一种基础且广泛使用的技术。在时间可逆的伴随计算中使用检查点来管理内存-计算权衡也是一种标准且正确的做法。HPC概念（领域分解、震源级并行、异步I/O、集体通信）得到了准确的表述。\n-   **适定性**：目标清晰：确定既数学正确又计算最快的工作流。所提供的参数虽然简化，但足以比较所提出工作流的相对性能。\n-   **客观性**：问题以精确、客观的语言陈述。\n\n**步骤 3：结论和行动**\n问题陈述在科学上是合理的，适定的，并且内部一致。它提出了计算科学中的一个有效情景。我将继续进行求解。\n\n### 推导与选项分析\n\n数学正确性检查的核心在于总梯度 $\\nabla J(m)$ 是如何计算的。给定残差泛函 $J(m) = \\sum_{s=1}^{N_s} J_s(m)$，微分算子线性的一个直接结果是，总梯度必须是各单源梯度的总和：\n$$\n\\nabla J(m) = \\frac{\\delta J}{\\delta m} = \\sum_{s=1}^{N_s} \\frac{\\delta J_s}{\\delta m} = \\sum_{s=1}^{N_s} \\nabla J_s(m)\n$$\n每个单源梯度 $\\nabla J_s(m)$ 都是通过伴随状态法计算的，该方法涉及为震源 $s$ 运行一次正演模拟以生成 $u_s$，然后为伴随场 $\\lambda_s$（由震源 $s$ 的数据残差驱动）运行一次伴随模拟，最后通过这两个场的时间积分相关来形成梯度。任何不计算这个总和的工作流在数学上都是不正确的。\n\n性能分析的核心是确定一个能够最大化并行性，并重叠计算、I/O和通信，以最小化总墙上时钟时间的工作流。\n\n**选项 A：顺序、同步I/O的工作流，带有每震源阻塞归约。**\n\n-   **数学正确性**：此工作流顺序计算每个震源 $s$ 的梯度，并将结果添加到一个运行总和中。这等同于计算 $\\nabla J(m) = \\sum_{s=1}^{N_s} \\nabla J_s(m)$。该方法在数学上是**正确的**。\n-   **性能分析**：这种方法效率极低。\n    1.  **无震源并行**：它顺序处理 $N_s$ 个震源，未能利用最明显和最大粒度的可用并行性。\n    2.  **同步I/O**：模拟在 $N_{cp} = T_{\\text{steps}}/k = 8000/100 = 80$ 个检查点间隔中的每一个处都会阻塞。正演运行的时间大约为 $N_{cp} \\times (t_{\\mathrm{comp,int}} + t_{\\mathrm{io,cp}}) = 80 \\times (1.2\\,\\mathrm{s} + 0.5\\,\\mathrm{s}) = 136\\,\\mathrm{s}$。伴随运行也是如此。这为每个震源引入了 $80 \\times 0.5\\,\\mathrm{s} \\times 2 = 80\\,\\mathrm{s}$ 的空闲时间。\n    3.  **阻塞通信**：在每个震源之后执行一次阻塞的 all-reduce 操作，这意味着整个系统在开始下一个震源之前都要等待通信完成。\n-   **结论**：**不正确**。虽然在数学上是合理的，但由于其顺序性和使用阻塞操作，它违反了最小化墙上时钟时间的标准。\n\n**选项 B：批处理、子通信域的工作流，带有完全重叠的异步检查点I/O和与计算重叠的每批次单次非阻塞all-reduce。**\n\n-   **数学正确性**：该工作流通过将 $P=64$ 个节点分成 $K=8$ 组，每组 $G=8$ 个节点，来实现震源间的计算并行化。每组为一个震源计算梯度 $\\nabla J_s(m)$。在一批 $K$ 个震源结束时，它们的梯度通过全局 all-reduce 求和。总梯度逐批次累积。这正确地计算了 $\\sum_{s} \\nabla J_s(m)$。该方法在数学上是**正确的**。\n-   **性能分析**：这种方法代表了一种先进的、高度优化的工作流。\n    1.  **震源并行**：它并发处理 $K=8$ 个震源，从而实现高吞吐量。\n    2.  **重叠I/O**：它使用异步I/O。由于检查点之间的计算时间（$t_{\\mathrm{comp,int}}=1.2\\,\\mathrm{s}$）大于每个检查点的I/O时间（$t_{\\mathrm{io,cp}}=0.5\\,\\mathrm{s}$），I/O成本可以被计算完全隐藏。正演和伴随运行的墙上时钟时间仅由计算决定，即 $2 \\times N_{cp} \\times t_{\\mathrm{comp,int}}$。扩展性规则意味着，对于 $G=8$ 的 $t_{\\mathrm{comp,int}}$ 会比 $G=64$ 的要长，但由于I/O隐藏和减少的通信开销，每个震源的摊销时间明显优于选项A。对于一批 $K=8$ 个震源，墙上时钟时间主要由在 $G=8$ 个节点上处理一个震源的计算时间决定。\n    3.  **重叠通信**：一个批次的梯度归约使用非阻塞的 all-reduce 执行，并与下一个批次的正演模拟重叠。这隐藏了通信延迟。\n-   **结论**：**正确**。此选项既数学正确，又描述了最优的性能策略，符合所有既定目标。\n\n**选项 C：写入完整时间历史，使用单一复合伴随源和单次正演相关。**\n\n-   **数学正确性**：该工作流建议通过将一个单一的“复合”伴随场 $\\lambda_{\\text{total}} = \\sum_s \\lambda_s$ 与一个单一的“复合”正演场 $u_{\\text{composite}}$ 相关联来计算梯度。真实的梯度是 $\\sum_s \\int \\lambda_s \\cdot (\\partial_m \\mathcal{L}) u_s \\, dt$。而建议的计算是 $\\int (\\sum_s \\lambda_s) \\cdot (\\partial_m \\mathcal{L}) u_{\\text{composite}} \\, dt$。这两个表达式不相等。此过程错误地混合了来自不同震源和接收器的贡献，导致了数学上不正确的梯度。该方法在数学上是**不正确的**。\n-   **性能分析**：对于实际问题，将完整的四维波场流式传输到磁盘在计算上是不可行的。每个震源所需的存储将是 $T_{\\text{steps}} \\times P \\times (\\text{checkpoint size}) = 8000 \\times 64 \\times 1\\,\\mathrm{GB} = 512\\,\\mathrm{TB}$。写入然后读取这些数据的I/O时间将是巨大的，远远超过基于检查点和重计算的方法所需的时间。检查点技术的发明就是为了克服这种高昂的成本。\n-   **结论**：**不正确**。此选项在数学和性能两方面都存在缺陷。\n\n**选项 D：批处理、异步工作流，在全局归约前用逐点最大值替换逐源求和。**\n\n-   **数学正确性**：该工作流建议通过在每个网格点上取最大绝对值来组合批次内的单源梯度，而不是将它们相加。也就是说，它计算的是与 $\\max_{s \\in \\text{batch}} |\\nabla J_s(\\mathbf{x})|$ 成比例的值，而不是正确的 $\\sum_{s \\in \\text{batch}} \\nabla J_s(\\mathbf{x})$。这从根本上偏离了函数和的梯度的定义。产生的方向将不是残差 $J(m)$ 的下降方向，整个优化过程将失效。该方法在数学上是**不正确的**。\n-   **性能分析**：其声称的动机是“降低归约成本”。然而，执行最大值归约与求和归约具有相同的通信量和模式。计算成本的差异也可以忽略不计。因此，这种修改在破坏梯度数学完整性的同时，并没有带来任何性能上的好处。\n-   **结论**：**不正确**。此选项在数学上是不合理的，其性能理由也毫无根据。\n\n### 总结\n\n只有选项B提出了一个既数学正确（计算了FWI残差泛函的真实梯度）又计算最优的工作流，它正确地利用了震源并行、异步I/O来隐藏数据移动成本，以及非阻塞集体操作来将通信与计算重叠。选项A是正确的但效率低下。选项C和D在数学上是不正确的。", "answer": "$$\\boxed{B}$$", "id": "3574197"}]}