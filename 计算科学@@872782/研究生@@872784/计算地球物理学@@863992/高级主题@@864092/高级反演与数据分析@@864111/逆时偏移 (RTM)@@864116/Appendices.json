{"hands_on_practices": [{"introduction": "本练习是理解逆时偏移方法的基石。通过从零开始为一个简单模型实现一个频率域RTM，您将直接接触其核心理论组成部分：用于描述波传播的亥姆霍兹方程（Helmholtz equation），用于描述散射的玻恩近似（Born approximation），以及用于成像的伴随状态法（adjoint-state method）。这项动手实践清晰地阐释了这些数学概念如何转化为具体的成像算法 [@problem_id:3613775]。", "problem": "针对二维常密度声学介质，使用单频亥姆霍兹方程，实现一个频域逆时偏移（RTM）成像实验。从常密度声学波动方程出发，推导一个适用于构建单散射体 Born 近似的频域公式。利用此公式定义背景波场的正演模拟算子，由平方慢度局部扰动引起的散射场的二次源，以及用于相关型成像条件的伴随（反向传播）算子成像。\n\n您的程序必须构建一个计算网格，组装带有齐次 Dirichlet 边界条件和用于模拟弱吸收的微小复数位移的离散亥姆霍兹算子，求解正演和伴随场，计算单个频率的图像，然后执行多频叠加，以近似时域图像的带宽和分辨率。每个测试用例的最终输出是一个标量度量，用于量化已知散射体位置处的峰旁比。\n\n基本原理和定义：\n- 物理空间中的常密度声学波动方程由下式给出\n$$\n\\frac{\\partial^2 p(\\mathbf{x},t)}{\\partial t^2} - v(\\mathbf{x})^2 \\nabla^2 p(\\mathbf{x},t) = s(\\mathbf{x},t),\n$$\n其中 $p$ 是压力，$v$ 是波速（单位为 $\\mathrm{m/s}$），$\\nabla^2$ 是拉普拉斯算子，$s$ 是源项。\n- 在单频时谐假设 $p(\\mathbf{x},t) = \\Re\\{u(\\mathbf{x},\\omega) e^{-i \\omega t}\\}$ 下，角频率为 $\\omega$（单位为 $\\mathrm{rad/s}$），场 $u(\\mathbf{x},\\omega)$ 满足非齐次亥姆霍兹方程\n$$\n\\left(\\nabla^2 + \\omega^2 m(\\mathbf{x})\\right) u(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega),\n$$\n其中 $m(\\mathbf{x}) = v(\\mathbf{x})^{-2}$ 是平方慢度（单位为 $\\mathrm{s^2/m^2}$），$q$ 是频域源。\n- 对于相对于已知背景 $m_0(\\mathbf{x})$ 的平方慢度小扰动 $\\delta m(\\mathbf{x})$，一阶 Born 近似给出的散射场 $u_s$ 满足\n$$\n\\left(\\nabla^2 + \\omega^2 m_0(\\mathbf{x})\\right) u_s(\\mathbf{x},\\omega) = - \\omega^2 \\delta m(\\mathbf{x}) u_0(\\mathbf{x},\\omega),\n$$\n其中背景场 $u_0$ 满足\n$$\n\\left(\\nabla^2 + \\omega^2 m_0(\\mathbf{x})\\right) u_0(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega).\n$$\n\n离散化和数值设置：\n- 在一个大小为 $N_x \\times N_z = 50 \\times 50$ 的均匀笛卡尔网格上进行计算，网格间距为 $\\Delta x = \\Delta z = 10\\,\\mathrm{m}$。计算域具有齐次 Dirichlet 边界条件（边界上压力为零）。为模拟弱吸收并减少人为反射，在质量项中使用复数位移，使离散算子为\n$$\n\\mathbf{A}(\\omega) = \\mathbf{L} + \\omega^2 m_0 (1 - i \\eta)\\mathbf{I},\n$$\n其中 $\\mathbf{L}$ 是标准的带 Dirichlet 边界处理的五点离散拉普拉斯算子，$\\mathbf{I}$ 是单位矩阵，$\\eta = 0.05$ 是一个无量纲阻尼参数。\n- 使用均匀背景速度 $v_0 = 2000\\,\\mathrm{m/s}$，因此 $m_0 = v_0^{-2}$（单位为 $\\mathrm{s^2/m^2}$）。\n- 在水平中心、地表下方一个网格单元处放置一个单点源。在使用基于零的编码索引时，其索引为 $(i_x,i_z) = (N_x/2, 1)$。将源建模为右侧项 $q$ 中的单位振幅克罗内克 δ 函数。\n- 沿着地表下方一个网格单元的水平线上，在除边界外的每个网格列处放置接收器。即，对于 $i_z = 1$ 处的 $i_x \\in \\{1,2,\\dots,N_x-2\\}$。\n- 在域中心索引为 $(i_x,i_z) = (N_x/2, N_z/2)$ 处放置一个单一的局部平方慢度扰动，其振幅为\n$$\n\\delta m(\\mathbf{x}_\\star) = \\alpha m_0,\\quad \\alpha = 0.02,\n$$\n其他地方为零。这定义了一个单散射体 Born 模型。\n\n正演模拟与成像：\n- 对于给定的频率 $f$（单位为 $\\mathrm{Hz}$），计算 $\\omega = 2\\pi f$。通过 $\\mathbf{A}(\\omega)\\mathbf{u}_0 = \\mathbf{q}$ 求解背景场 $\\mathbf{u}_0$。\n- 形成二次源向量 $\\mathbf{s}_\\mathrm{sc} = -\\omega^2\\,\\delta \\mathbf{m} \\odot \\mathbf{u}_0$，其中 $\\odot$ 表示逐点相乘，$\\delta \\mathbf{m}$ 是离散化的扰动场。通过 $\\mathbf{A}(\\omega)\\mathbf{u}_s = \\mathbf{s}_\\mathrm{sc}$ 求解散射场 $\\mathbf{u}_s$。\n- 从 $\\mathbf{u}_s$ 中提取接收器索引处的记录数据向量 $\\mathbf{d}$。\n- 通过求解 $\\mathbf{A}(\\omega)\\boldsymbol{\\lambda} = \\mathbf{r}$ 来反向传播数据，其中 $\\mathbf{r}$ 是一个零向量，但在接收器位置处的条目等于记录的数据（建模为点注入）。\n- 通过相关型成像条件形成单频图像\n$$\n\\mathbf{I}_f = \\Re\\left\\{\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}\\right\\}.\n$$\n\n多频叠加：\n- 对于一个频率列表 $\\{f_k\\}$，为每个 $k$ 计算 $\\mathbf{I}_{f_k}$，并通过简单求和进行叠加\n$$\n\\mathbf{I}_\\mathrm{stack} = \\sum_k \\mathbf{I}_{f_k}.\n$$\n\n可测试输出的度量标准：\n- 令 $\\mathbf{x}_\\star$ 表示真实的散射体网格索引。将在频率 $f$ 处的峰旁比定义为\n$$\nR(f) = \\frac{\\left|\\mathbf{I}_f(\\mathbf{x}_\\star)\\right|}{\\max_{\\mathbf{x} \\in \\Omega \\setminus \\mathcal{N}} \\left|\\mathbf{I}_f(\\mathbf{x})\\right| + \\varepsilon},\n$$\n其中 $\\Omega$ 是所有网格点的集合，$\\mathcal{N}$ 是围绕 $\\mathbf{x}_\\star$ 的一个排除邻域，其半径在 $\\ell_\\infty$ 范数意义下为 $r_\\mathrm{exc} = 3$ 个网格单元，$\\varepsilon = 10^{-12}$ 是一个微小稳定项。对于多频叠加，通过将 $\\mathbf{I}_f$ 替换为 $\\mathbf{I}_\\mathrm{stack}$ 来类似地定义 $R_\\mathrm{stack}$。\n\n单位和数值精度：\n- 所有物理输入使用上述单位。度量 $R$ 是无量纲的，必须报告为一个浮点数，四舍五入到小数点后六位。\n\n测试套件：\n- 使用以下四个测试用例，每个用例产生一个标量结果：\n    - 用例 1（单频）：$f = 25\\,\\mathrm{Hz}$。\n    - 用例 2（单频）：$f = 35\\,\\mathrm{Hz}$。\n    - 用例 3（多频叠加）：$f \\in \\{20\\,\\mathrm{Hz}, 25\\,\\mathrm{Hz}, 30\\,\\mathrm{Hz}, 35\\,\\mathrm{Hz}\\}$。\n    - 用例 4（边缘情况，低频）：$f = 10\\,\\mathrm{Hz}$。\n\n要求的最终输出格式：\n- 您的程序应产生单行输出，包含四个用例的结果，形式为逗号分隔的列表，并用方括号括起来，例如\n$[\\;r_1,r_2,r_3,r_4\\;]$，\n其中 $r_j$ 是按上述规定四舍五入的四个浮点度量值，不打印任何附加文本。", "solution": "我们从常密度声学波动方程开始\n$$\n\\frac{\\partial^2 p(\\mathbf{x},t)}{\\partial t^2} - v(\\mathbf{x})^2 \\nabla^2 p(\\mathbf{x},t) = s(\\mathbf{x},t).\n$$\n对于角频率为 $\\omega$ 的时谐场，其假设为 $p(\\mathbf{x},t) = \\Re\\{u(\\mathbf{x},\\omega) e^{-i \\omega t}\\}$，代入可得\n$$\n(-\\omega^2) u(\\mathbf{x},\\omega) - v(\\mathbf{x})^2 \\nabla^2 u(\\mathbf{x},\\omega) = s_\\omega(\\mathbf{x}),\n$$\n或等价地\n$$\n\\left(\\nabla^2 + \\omega^2 m(\\mathbf{x})\\right) u(\\mathbf{x},\\omega) = q(\\mathbf{x},\\omega),\n$$\n其中 $m(\\mathbf{x}) = v(\\mathbf{x})^{-2}$ 且 $q(\\mathbf{x},\\omega) = v(\\mathbf{x})^{-2} s_\\omega(\\mathbf{x})$。在表示为背景加上小扰动的介质中，$m(\\mathbf{x}) = m_0(\\mathbf{x}) + \\delta m(\\mathbf{x})$ 且 $\\|\\delta m\\| \\ll \\|m_0\\|$，背景场 $u_0$ 和散射场 $u_s$ 满足方程对\n$$\n\\left(\\nabla^2 + \\omega^2 m_0\\right) u_0 = q,\\qquad\n\\left(\\nabla^2 + \\omega^2 m_0\\right) u_s = -\\omega^2 \\delta m\\, u_0,\n$$\n这就是一阶 Born 近似。散射方程的右侧项充当了由扰动与背景场相互作用产生的等效源。\n\n对于逆时偏移（RTM），使用正演模拟算子的伴随算子将记录数据反向传播到成像空间。在频域中，对于实数背景 $m_0$ 和齐次边界条件，亥姆霍兹算子除了边界辐射条件外是自伴的。在数值上，为了减轻来自截断计算域的伪反射，我们添加一个小的复数位移来模拟吸收，形成一个算子\n$$\n\\mathbf{A}(\\omega) = \\mathbf{L} + \\omega^2 m_0 (1 - i \\eta)\\mathbf{I},\n$$\n其中 $\\mathbf{L}$ 是五点离散拉普拉斯算子，$\\mathbf{I}$ 是单位矩阵，$\\eta > 0$ 是一个小数。这在离散设置中保持了一致的伴随作用。我们在具有间距 $\\Delta x$ 和 $\\Delta z$ 的规则 $N_x \\times N_z$ 网格上进行离散化，并通过将对应于边界节点的行替换为单位矩阵的行来强制执行齐次 Dirichlet 边界条件，从而将边界场设置为零。\n\n给定地表下方一个网格单元处的单个源和沿浅层水平线布置的接收器，对于给定的频率 $f$（其中 $\\omega = 2\\pi f$），我们按以下步骤进行：\n1. 从 $\\mathbf{L}$ 和复数位移质量项 $\\omega^2 m_0 (1 - i \\eta)$ 组装 $\\mathbf{A}(\\omega)$。带 Dirichlet 边界的五点拉普拉斯算子使用以下模板\n$$\n\\left(\\mathbf{L} u\\right)_{i,j} = \\frac{u_{i+1,j} - 2 u_{i,j} + u_{i-1,j}}{\\Delta x^2} + \\frac{u_{i,j+1} - 2 u_{i,j} + u_{i,j-1}}{\\Delta z^2},\n$$\n仅应用于内部节点；边界值通过单位矩阵行设置为零。\n2. 求解背景场 $\\mathbf{A}(\\omega)\\mathbf{u}_0 = \\mathbf{q}$，其中 $\\mathbf{q}$ 是在源网格索引处的单位振幅离散 δ 函数。\n3. 构建离散 Born 源 $\\mathbf{s}_\\mathrm{sc} = -\\omega^2 \\delta \\mathbf{m} \\odot \\mathbf{u}_0$ 并求解 $\\mathbf{A}(\\omega)\\mathbf{u}_s = \\mathbf{s}_\\mathrm{sc}$。\n4. 通过在接收器位置采样 $\\mathbf{u}_s$ 来提取数据向量 $\\mathbf{d}$。\n5. 通过在接收器位置注入记录数据进行反向传播：形成 $\\mathbf{r}$，该向量处处为零，但在接收器索引处等于 $\\mathbf{d}$，然后求解 $\\mathbf{A}(\\omega)\\boldsymbol{\\lambda} = \\mathbf{r}$。\n6. 应用相关型成像条件\n$$\n\\mathbf{I}_f = \\Re\\{\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}\\}.\n$$\n\n为了近似时域成像的宽带特性，对一组频率 $\\{f_k\\}$ 进行多频叠加，方法是求和单频图像，\n$$\n\\mathbf{I}_\\mathrm{stack} = \\sum_k \\mathbf{I}_{f_k}.\n$$\n这种叠加减少了与频率相关的旁瓣，并通过在真实散射体位置的相长干涉和在其他地方的部分抵消来提高分辨率。\n\n为了进行定量评估，我们计算峰旁比\n$$\nR(f) = \\frac{\\left|\\mathbf{I}_f(\\mathbf{x}_\\star)\\right|}{\\max_{\\mathbf{x}\\in \\Omega \\setminus \\mathcal{N}} \\left|\\mathbf{I}_f(\\mathbf{x})\\right| + \\varepsilon},\n$$\n其中排除邻域 $\\mathcal{N}$ 的半径为 $r_\\mathrm{exc} = 3$ 个网格单元（围绕真实位置 $\\mathbf{x}_\\star$），稳定项 $\\varepsilon = 10^{-12}$。当 $\\mathbf{I}_f$ 被 $\\mathbf{I}_\\mathrm{stack}$ 替换时，同样的公式定义了 $R_\\mathrm{stack}$。\n\n算法设计选择和数值考量：\n- 齐次 Dirichlet 边界条件和复数位移 $\\eta = 0.05$ 减少了非物理边界反射，同时保持求解器简单而稳健。网格间距 $\\Delta x = \\Delta z = 10\\,\\mathrm{m}$ 和高达 $f = 35\\,\\mathrm{Hz}$ 的频率，对于 $v_0 = 2000\\,\\mathrm{m/s}$，确保每个波长至少有几个网格点，从而保证了亥姆霍兹算子的合理离散化。\n- Born 扰动振幅 $\\alpha = 0.02$ 足够小，与线性化假设一致，同时能产生可测量的散射信号。\n- 反向传播的右侧项 $\\mathbf{r}$ 直接在接收器位置插入记录的压力；因为算子是复对称的且有微小吸收，这模拟了 RTM 所需的伴随作用。\n- 图像取为相关 $\\overline{\\mathbf{u}_0} \\odot \\boldsymbol{\\lambda}$ 的实部，以消除相位模糊，这与常规的单频成像条件一致。\n\n测试套件解释：\n- 用例 1（$f = 25\\,\\mathrm{Hz}$）提供一个中频段的单频图像，具有中等的分辨率和对比度。\n- 用例 2（$f = 35\\,\\mathrm{Hz}$）提高了分辨率；由于波长更短、聚焦效果更好，我们预期峰旁比会增加。\n- 用例 3（在 $f \\in \\{20,25,30,35\\}\\,\\mathrm{Hz}$ 上叠加）近似了更宽的带宽；我们预期在真实位置处会出现相长叠加，同时旁瓣会部分抵消，从而相对于大多数单频情况改善了峰旁比。\n- 用例 4（$f = 10\\,\\mathrm{Hz}$）代表一个低频、长波长的区域；我们预期分辨率会较差，因此峰旁比会较低。\n\n最终程序将组装算子，为指定用例计算波场和图像，评估度量 $R$，将每个结果四舍五入到小数点后六位，并以所要求的列表格式打印单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_helmholtz_operator(nx, nz, dx, dz, m0, omega, eta):\n    \"\"\"\n    Build 2D Helmholtz operator with homogeneous Dirichlet boundary conditions\n    and a small complex shift (1 - i*eta) on the mass term.\n    \"\"\"\n    n = nx * nz\n    rows = []\n    cols = []\n    data = []\n    k2 = (omega ** 2) * m0 * (1.0 - 1j * eta)\n\n    inv_dx2 = 1.0 / (dx * dx)\n    inv_dz2 = 1.0 / (dz * dz)\n\n    def idx(ix, iz):\n        return iz * nx + ix\n\n    for iz in range(nz):\n        for ix in range(nx):\n            p = idx(ix, iz)\n            # Boundary nodes: enforce u = 0 by identity row\n            if ix == 0 or ix == nx - 1 or iz == 0 or iz == nz - 1:\n                rows.append(p); cols.append(p); data.append(1.0 + 0j)\n            else:\n                # Center\n                diag = -2.0 * inv_dx2 - 2.0 * inv_dz2 + k2\n                rows.append(p); cols.append(p); data.append(diag)\n                # Left neighbor\n                rows.append(p); cols.append(idx(ix - 1, iz)); data.append(inv_dx2)\n                # Right neighbor\n                rows.append(p); cols.append(idx(ix + 1, iz)); data.append(inv_dx2)\n                # Up neighbor\n                rows.append(p); cols.append(idx(ix, iz - 1)); data.append(inv_dz2)\n                # Down neighbor\n                rows.append(p); cols.append(idx(ix, iz + 1)); data.append(inv_dz2)\n\n    A = csr_matrix((np.array(data, dtype=np.complex128),\n                    (np.array(rows, dtype=np.int32), np.array(cols, dtype=np.int32))),\n                   shape=(n, n))\n    return A\n\ndef solve_field(A, rhs):\n    return spsolve(A, rhs)\n\ndef rtm_single_frequency(f_hz, nx, nz, dx, dz, v0, eta, alpha, src_ix, src_iz, rec_iz, scat_ix, scat_iz):\n    \"\"\"\n    Compute single-frequency RTM image and return the peak-to-sidelobe ratio at the true scatterer.\n    \"\"\"\n    omega = 2.0 * np.pi * f_hz\n    m0 = 1.0 / (v0 * v0)\n\n    # Build operator\n    A = build_helmholtz_operator(nx, nz, dx, dz, m0, omega, eta)\n\n    n = nx * nz\n    def lin(ix, iz):\n        return iz * nx + ix\n\n    # Source RHS\n    q = np.zeros(n, dtype=np.complex128)\n    q[lin(src_ix, src_iz)] = 1.0 + 0j\n\n    # Background field\n    u0 = solve_field(A, q)\n\n    # Born perturbation\n    dm = np.zeros(n, dtype=np.complex128)\n    dm[lin(scat_ix, scat_iz)] = alpha * m0\n\n    # Scattered field RHS\n    s_sc = - (omega ** 2) * dm * u0\n    us = solve_field(A, s_sc)\n\n    # Receivers along a horizontal line rec_iz at all interior ix\n    rec_ixs = list(range(1, nx - 1))\n    rec_ids = [lin(ix, rec_iz) for ix in rec_ixs]\n    d = us[rec_ids].copy()\n\n    # Back-propagation RHS: inject recorded data at receivers\n    r = np.zeros(n, dtype=np.complex128)\n    r[rec_ids] = d\n\n    lamb = solve_field(A, r)\n\n    # Imaging condition\n    I = np.real(np.conj(u0) * lamb)\n\n    # Peak-to-sidelobe ratio at true scatterer\n    I2d = I.reshape(nz, nx)\n    peak_val = abs(I2d[scat_iz, scat_ix])\n\n    # Exclude a neighborhood around the true location\n    r_exc = 3\n    mask = np.ones((nz, nx), dtype=bool)\n    i0 = max(0, scat_iz - r_exc)\n    i1 = min(nz, scat_iz + r_exc + 1)\n    j0 = max(0, scat_ix - r_exc)\n    j1 = min(nx, scat_ix + r_exc + 1)\n    mask[i0:i1, j0:j1] = False\n\n    side_max = np.max(np.abs(I2d[mask])) if np.any(mask) else 0.0\n    eps = 1e-12\n    ratio = peak_val / (side_max + eps)\n    return ratio, I2d\n\ndef rtm_stack_frequencies(f_list, nx, nz, dx, dz, v0, eta, alpha, src_ix, src_iz, rec_iz, scat_ix, scat_iz):\n    \"\"\"\n    Compute multi-frequency stacked RTM image and return the peak-to-sidelobe ratio at the true scatterer.\n    \"\"\"\n    I_stack = np.zeros((nz, nx), dtype=np.float64)\n    for f in f_list:\n        ratio, I2d = rtm_single_frequency(f, nx, nz, dx, dz, v0, eta, alpha,\n                                          src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n        I_stack += I2d\n\n    peak_val = abs(I_stack[scat_iz, scat_ix])\n    r_exc = 3\n    mask = np.ones_like(I_stack, dtype=bool)\n    i0 = max(0, scat_iz - r_exc)\n    i1 = min(nz, scat_iz + r_exc + 1)\n    j0 = max(0, scat_ix - r_exc)\n    j1 = min(nx, scat_ix + r_exc + 1)\n    mask[i0:i1, j0:j1] = False\n\n    side_max = np.max(np.abs(I_stack[mask])) if np.any(mask) else 0.0\n    eps = 1e-12\n    ratio = peak_val / (side_max + eps)\n    return ratio\n\ndef solve():\n    # Grid and physical parameters\n    nx, nz = 50, 50\n    dx = dz = 10.0  # meters\n    v0 = 2000.0     # m/s\n    eta = 0.05      # dimensionless damping\n    alpha = 0.02    # relative perturbation in m0\n\n    # Geometry\n    src_ix = nx // 2\n    src_iz = 1\n    rec_iz = 1\n    scat_ix = nx // 2\n    scat_iz = nz // 2\n\n    # Test cases:\n    # 1: single frequency 25 Hz\n    # 2: single frequency 35 Hz\n    # 3: stack frequencies [20, 25, 30, 35] Hz\n    # 4: single frequency 10 Hz (low-frequency edge case)\n    test_cases = [\n        (\"single\", 25.0),\n        (\"single\", 35.0),\n        (\"stack\", [20.0, 25.0, 30.0, 35.0]),\n        (\"single\", 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        mode, val = case\n        if mode == \"single\":\n            ratio, _ = rtm_single_frequency(val, nx, nz, dx, dz, v0, eta, alpha,\n                                            src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n            results.append(f\"{ratio:.6f}\")\n        elif mode == \"stack\":\n            ratio = rtm_stack_frequencies(val, nx, nz, dx, dz, v0, eta, alpha,\n                                          src_ix, src_iz, rec_iz, scat_ix, scat_iz)\n            results.append(f\"{ratio:.6f}\")\n        else:\n            # Should not occur\n            results.append(f\"{0.0:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3613775"}, {"introduction": "除了生成基本的地下构造图像，地震偏移的一个关键任务是为速度模型验证和振幅分析提供数据支持。本练习专注于通过估算源波场和接收点波场的局部传播方向，来构建角度域共成像点道集（Angle-Domain Common Image Gathers, ADCIGs）。掌握这项技术至关重要，因为ADCIGs为评估偏移速度模型的准确性提供了宝贵的诊断信息 [@problem_id:3613787]。", "problem": "考虑从局部平面波估计构建的逆时偏移 (RTM) 角度域共成像道集。假设一个具有坐标 $x$ 和 $z$ 的二维空间网格，以及源波场 $u_s(x,z)$ 和接收波场 $u_r(x,z)$ 的复数时间谐波快照。目标是计算局部波数向量并构建角度域能量道集，然后针对已知的入射配置验证其聚焦情况。\n\n使用的基本原理：\n- 声波传播由声波方程描述，在时间谐波体制下，该方程简化为亥姆霍兹方程。它允许平面波解，其空间相位梯度等于局部波数向量。\n- 逆时偏移 (RTM) 中的零延迟互相关成像条件将反射率与源波场和接收波场的互相关联系起来。\n- 角度域共成像道集 (ADCIG) 是通过将局部波数对映射到散射角来构建的，散射角量化了源和接收器局部传播方向之间的夹角。\n\n任务：\n1. 给定在均匀网格上定义的复数场 $u_s(x,z)$ 和 $u_r(x,z)$，沿 $x$ 轴有 $N_x$ 个样本，沿 $z$ 轴有 $N_z$ 个样本，间距分别为 $\\Delta x$ 和 $\\Delta z$（单位：米），使用将 $\\nabla u / u$ 的虚部与相位梯度关联的相位梯度原理，估计局部波数向量 $\\mathbf{k}_s(x,z)$ 和 $\\mathbf{k}_r(x,z)$。使用中心有限差分法以步长 $\\Delta x$ 和 $\\Delta z$ 近似空间梯度。\n2. 对于每个网格位置，若 $\\|\\mathbf{k}_s(x,z)\\|$ 和 $\\|\\mathbf{k}_r(x,z)\\|$ 均超过一个小的阈值（以避免除以接近零的值），则将该对向量 $\\big(\\mathbf{k}_s(x,z), \\mathbf{k}_r(x,z)\\big)$ 映射到散射角 $\\theta(x,z)$，该角度以弧度为单位，范围在 $[0,\\pi]$ 内，定义为两个局部波数向量之间的夹角。通过在相应的角度区间中累加一个非负权重 $w(x,z)$ 来构建一个角度域能量直方图 $E(\\theta)$。使用 $w(x,z) = |u_s(x,z)|\\,|u_r(x,z)|$ 作为权重。直方图必须有 $N_\\theta$ 个均匀分布在 $[0,\\pi]$ 范围内的区间。\n3. 对于每个指定的测试用例，计算一个聚焦度量 $F$，其定义为包含已知真实散射角 $\\theta_{\\text{true}}$ 的区间中的能量与所有区间总能量之比。如果没有有效样本对直方图有贡献，则定义 $F$ 为 $0.0$。所有计算中 $\\theta$ 均以弧度表示。最终输出为无量纲的浮点数。\n4. 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。\n\n网格和单位：\n- 使用具有 $N_x$ 和 $N_z$ 个样本的笛卡尔网格，间距 $\\Delta x$ 和 $\\Delta z$ 的单位为米。\n- 角度在内部必须以弧度处理和报告。\n\n测试套件：\n对于每个测试用例，将 $u_s(x,z)$ 和 $u_r(x,z)$ 构建为具有已知波数方向的复平面波，除非另有说明。设 $k_0$ 为波数向量的共同模长，单位为弧度/米。定义相对于 $x$ 轴的角度 $\\alpha_s$ 和 $\\alpha_r$（以弧度为单位）用于 $\\mathbf{k}_s$ 和 $\\mathbf{k}_r$，使得 $\\mathbf{k}_s = k_0[\\cos(\\alpha_s),\\sin(\\alpha_s)]$ 和 $\\mathbf{k}_r = k_0[\\cos(\\alpha_r),\\sin(\\alpha_r)]$。将波场构建为 $u_s(x,z) = \\exp\\big(i(\\mathbf{k}_s \\cdot \\mathbf{x})\\big)$ 和 $u_r(x,z) = \\exp\\big(i(\\mathbf{k}_r \\cdot \\mathbf{x})\\big)$，其中 $\\mathbf{x} = [x,z]$。对于边缘情况，将 $u_r(x,z)$ 设置为空间常数场，其相位变化为零，这使得 $\\mathbf{k}_r = \\mathbf{0}$ 处处成立。\n\n- 测试用例 1 (正常路径)：$N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.2\\,\\text{rad/m}$, $\\alpha_s = 0.0\\,\\text{rad}$, $\\alpha_r = 0.0\\,\\text{rad}$, $N_\\theta = 180$。真实角度为 $\\theta_{\\text{true}} = 0.0\\,\\text{rad}$。\n- 测试用例 2 (斜向，一般情况)：$N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.4\\,\\text{rad/m}$, $\\alpha_s = 0.3\\,\\text{rad}$, $\\alpha_r = 1.1\\,\\text{rad}$, $N_\\theta = 180$。真实角度为 $\\theta_{\\text{true}} = |\\alpha_r - \\alpha_s|\\,\\text{rad}$。\n- 测试用例 3 (近乎相反方向)：$N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.5\\,\\text{rad/m}$, $\\alpha_s = 0.0\\,\\text{rad}$, $\\alpha_r = \\pi\\,\\text{rad}$, $N_\\theta = 180$。真实角度为 $\\theta_{\\text{true}} = \\pi\\,\\text{rad}$。\n- 测试用例 4 (接收器波数无效的边缘情况)：$N_x = 64$, $N_z = 64$, $\\Delta x = 10\\,\\text{m}$, $\\Delta z = 10\\,\\text{m}$, $k_0 = 0.3\\,\\text{rad/m}$, $\\alpha_s = 0.7\\,\\text{rad}$，且 $u_r(x,z)$ 为空间常数，无相位变化 (因此 $\\mathbf{k}_r = \\mathbf{0}$)。使用 $N_\\theta = 180$。预期的聚焦度量为 $F = 0.0$，因为无法形成有效角度。\n\n算法细节：\n- 使用中心差分计算 $\\partial u/\\partial x$ 和 $\\partial u/\\partial z$。\n- 通过分量方式应用 $\\mathbf{k}(x,z) \\approx \\operatorname{Im}\\left(\\frac{\\nabla u(x,z)}{u(x,z)}\\right)$ 来估计局部波数。\n- 定义一个小的阈值 $\\varepsilon = 10^{-8}$（单位：弧度/米），并排除任何满足 $\\|\\mathbf{k}_s(x,z)\\| < \\varepsilon$ 或 $\\|\\mathbf{k}_r(x,z)\\| < \\varepsilon$ 的网格点。\n- 直方图权重必须为 $w(x,z) = |u_s(x,z)|\\,|u_r(x,z)|$。\n- 最终输出必须是形如“[F1,F2,F3,F4]”的单行文本，其中每个 $Fj$ 是一个浮点数。\n\n您的程序应实现以上内容，并按指定格式将聚焦度量输出为单行中用方括号括起来的逗号分隔列表。", "solution": "### 1. 局部波数向量的估计\n\n对于由复函数 $u(\\mathbf{x}) = A(\\mathbf{x}) e^{i\\phi(\\mathbf{x})}$ 描述的单色声波场，其中 $A(\\mathbf{x})$ 是振幅，$\\phi(\\mathbf{x})$ 是位置 $\\mathbf{x} = [x, z]$ 处的相位，局部波数向量 $\\mathbf{k}(\\mathbf{x})$ 定义为相位的梯度：\n$$\n\\mathbf{k}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x})\n$$\n复数场的梯度为 $\\nabla u = (\\nabla A) e^{i\\phi} + A (i\\nabla\\phi) e^{i\\phi}$。除以 $u$ 得到：\n$$\n\\frac{\\nabla u}{u} = \\frac{\\nabla A}{A} + i \\nabla \\phi = \\frac{\\nabla A}{A} + i\\mathbf{k}\n$$\n通过取此表达式的虚部，我们可以分离出局部波数向量：\n$$\n\\mathbf{k}(\\mathbf{x}) = \\operatorname{Im}\\left(\\frac{\\nabla u(\\mathbf{x})}{u(\\mathbf{x})}\\right)\n$$\n此原理应用于源波场 $u_s(x,z)$ 和接收波场 $u_r(x,z)$，以获得它们各自的局部波数向量场 $\\mathbf{k}_s(x,z)$ 和 $\\mathbf{k}_r(x,z)$。\n\n在数值上，空间网格是离散的，间距为 $\\Delta x$ 和 $\\Delta z$。梯度 $\\nabla u = [\\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial z}]$ 使用二阶精度的中心有限差分格式进行近似。对于一个内部网格点 $(x_i, z_j)$，其导数为：\n$$\n\\frac{\\partial u}{\\partial x}(x_i, z_j) \\approx \\frac{u(x_{i+1}, z_j) - u(x_{i-1}, z_j)}{2\\Delta x}\n$$\n$$\n\\frac{\\partial u}{\\partial z}(x_i, z_j) \\approx \\frac{u(x_i, z_{j+1}) - u(x_i, z_{j-1})}{2\\Delta z}\n$$\n这个计算对 $u_s$ 和 $u_r$ 在整个网格上执行。\n\n### 2. 将波数映射到散射角\n\n在每个网格点 $(x,z)$，局部波数向量对 $(\\mathbf{k}_s, \\mathbf{k}_r)$ 代表了源波场和接收波场的局部传播方向。散射角 $\\theta(x,z)$ 是这两个向量之间的夹角。它使用点积公式计算：\n$$\n\\theta(x,z) = \\arccos\\left(\\frac{\\mathbf{k}_s(x,z) \\cdot \\mathbf{k}_r(x,z)}{\\|\\mathbf{k}_s(x,z)\\| \\|\\mathbf{k}_r(x,z)\\|}\\right)\n$$\n$\\arccos$ 函数的结果自然落在所需的 $[0, \\pi]$ 范围内。此计算仅在被视为有效的网格位置上执行，即两个波数向量的模都超过一个小的阈值 $\\varepsilon = 10^{-8}$ 的位置。此条件可防止因除以零而导致的数值不稳定性，这种情况会发生在波数为空的零相位或恒定相位区域。\n\n### 3. 直方图构建和聚焦度量\n\n角度域共成像道集 (ADCIG) 被构建为一个直方图 $E(\\theta)$，它将能量作为散射角的函数进行累积。范围 $[0, \\pi]$ 被划分为 $N_\\theta$ 个均匀的区间。对于每个有效的网格点 $(x,z)$，计算出的散射角 $\\theta(x,z)$ 决定了其所在的区间，一个权重 $w(x,z)$ 被加到该区间的累加器中。问题指定的权重为：\n$$\nw(x,z) = |u_s(x,z)|\\,|u_r(x,z)|\n$$\n处理完所有有效网格点后，直方图中的总能量为 $E_{\\text{total}} = \\sum_{j=1}^{N_\\theta} E(\\theta_j)$。\n\n聚焦度量 $F$ 量化了能量在理论上已知的真实散射角 $\\theta_{\\text{true}}$ 处的集中程度。它被定义为包含 $\\theta_{\\text{true}}$ 的特定区间中的能量与直方图中总能量的比值：\n$$\nF = \\frac{E(\\text{bin containing } \\theta_{\\text{true}})}{E_{\\text{total}}}\n$$\n如果因为没有找到有效网格点（如测试用例4中）而导致直方图为空，则分子和分母均为零，此时定义 $F$ 为 $0.0$。\n\n对于在网格间距违反奈奎斯特采样定理（即 $k_{\\text{max}} > \\pi/\\Delta$）的网格上涉及平面波的测试用例，梯度的有限差分近似会引入数值频散。估计的波数 $k_{\\text{est}} = \\frac{\\sin(k_{\\text{true}}\\Delta x)}{\\Delta x}$ 将不同于真实的波数 $k_{\\text{true}}$。这导致估计的散射角偏离 $\\theta_{\\text{true}}$，从而产生较低的聚焦度量 $F$，正确反映了算法在这种条件下的性能下降。实现必须严格遵循指定的算法，包括这些数值效应。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_focusing_metric(\n    Nx, Nz, dx, dz, us_func, ur_func, N_theta, theta_true, k_thresh\n):\n    \"\"\"\n    Computes the focusing metric for angle-domain common image gathers.\n    \n    Args:\n        Nx (int): Number of grid points in x.\n        Nz (int): Number of grid points in z.\n        dx (float): Grid spacing in x (meters).\n        dz (float): Grid spacing in z (meters).\n        us_func (callable): Function to generate source wavefield u_s(x, z).\n        ur_func (callable): Function to generate receiver wavefield u_r(x, z).\n        N_theta (int): Number of angle bins for the histogram.\n        theta_true (float): True scattering angle (radians).\n        k_thresh (float): Threshold for wavenumber magnitude.\n\n    Returns:\n        float: The focusing metric F.\n    \"\"\"\n    # 1. Create grid and wavefields\n    x = np.arange(Nx) * dx\n    z = np.arange(Nz) * dz\n    xx, zz = np.meshgrid(x, z)\n\n    u_s = us_func(xx, zz)\n    u_r = ur_func(xx, zz)\n\n    # 2. Estimate local wavenumbers using phase-gradient\n    # np.gradient returns gradients along each axis. For a 2D array (Nz, Nx),\n    # it returns (grad_z, grad_x). The spacings must be provided in the same order (dz, dx).\n    grad_s_z, grad_s_x = np.gradient(u_s, dz, dx, edge_order=2)\n    grad_r_z, grad_r_x = np.gradient(u_r, dz, dx, edge_order=2)\n    \n    # Add a small epsilon to the denominator to avoid division by zero\n    # in case u_s or u_r is zero somewhere, although not for the given test cases.\n    denom_s = u_s + 1e-12\n    denom_r = u_r + 1e-12\n\n    k_s_x = np.imag(grad_s_x / denom_s)\n    k_s_z = np.imag(grad_s_z / denom_s)\n    \n    k_r_x = np.imag(grad_r_x / denom_r)\n    k_r_z = np.imag(grad_r_z / denom_r)\n\n    # 3. Filter points based on wavenumber magnitude\n    k_s_norm = np.sqrt(k_s_x**2 + k_s_z**2)\n    k_r_norm = np.sqrt(k_r_x**2 + k_r_z**2)\n    \n    valid_mask = (k_s_norm >= k_thresh)  (k_r_norm = k_thresh)\n    \n    if not np.any(valid_mask):\n        return 0.0\n\n    # 4. Map valid wavenumbers to scattering angles\n    k_s_x_valid = k_s_x[valid_mask]\n    k_s_z_valid = k_s_z[valid_mask]\n    k_r_x_valid = k_r_x[valid_mask]\n    k_r_z_valid = k_r_z[valid_mask]\n\n    k_s_norm_valid = k_s_norm[valid_mask]\n    k_r_norm_valid = k_r_norm[valid_mask]\n    \n    dot_product = k_s_x_valid * k_r_x_valid + k_s_z_valid * k_r_z_valid\n    \n    # Clip argument to arccos to handle potential floating point inaccuracies\n    cos_theta = np.clip(dot_product / (k_s_norm_valid * k_r_norm_valid), -1.0, 1.0)\n    angles = np.arccos(cos_theta)\n    \n    # 5. Construct angle-domain energy histogram\n    weights = np.abs(u_s[valid_mask]) * np.abs(u_r[valid_mask])\n    \n    bin_edges = np.linspace(0, np.pi, N_theta + 1)\n    hist_E, _ = np.histogram(angles, bins=bin_edges, weights=weights)\n\n    total_E = np.sum(hist_E)\n    \n    if total_E == 0:\n        return 0.0\n\n    # 6. Compute focusing metric F\n    bin_width = np.pi / N_theta\n    # Calculate the index of the bin containing the true angle\n    # Handle the edge case where theta_true = pi\n    true_bin_index = int(theta_true / bin_width)\n    if true_bin_index = N_theta:\n        true_bin_index = N_theta - 1\n        \n    E_true = hist_E[true_bin_index]\n    \n    F = E_true / total_E\n    \n    return F\n\ndef solve():\n    \"\"\"\n    Main solver function that runs all test cases and prints the results.\n    \"\"\"\n    def make_plane_wave(k0, alpha):\n        kx = k0 * np.cos(alpha)\n        kz = k0 * np.sin(alpha)\n        return lambda x, z: np.exp(1j * (kx * x + kz * z))\n\n    def make_constant_field():\n        return lambda x, z: np.ones_like(x, dtype=np.complex128)\n\n    test_cases = [\n        # Case 1: Happy path\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.2, 'alpha_s': 0.0, 'alpha_r': 0.0, 'N_theta': 180},\n        # Case 2: Oblique, general\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.4, 'alpha_s': 0.3, 'alpha_r': 1.1, 'N_theta': 180},\n        # Case 3: Near-opposite directions\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.5, 'alpha_s': 0.0, 'alpha_r': np.pi, 'N_theta': 180},\n        # Case 4: Edge case with invalid receiver wavenumber\n        {'Nx': 64, 'Nz': 64, 'dx': 10.0, 'dz': 10.0, 'k0': 0.3, 'alpha_s': 0.7, 'N_theta': 180},\n    ]\n\n    results = []\n    k_thresh = 1e-8\n\n    for i, params in enumerate(test_cases):\n        if i == 3: # Test Case 4\n            us_func = make_plane_wave(params['k0'], params['alpha_s'])\n            ur_func = make_constant_field()\n            # As per problem, kr is zero, so no valid angle can be formed. \n            # The manual calculation is not strictly needed as the code handles it.\n            theta_true = 0.0 # dummy value, not used for F=0 case\n        else:\n            us_func = make_plane_wave(params['k0'], params['alpha_s'])\n            ur_func = make_plane_wave(params['k0'], params['alpha_r'])\n            theta_true = np.abs(params['alpha_r'] - params['alpha_s'])\n        \n        F = compute_focusing_metric(\n            params['Nx'], params['Nz'], params['dx'], params['dz'],\n            us_func, ur_func, params['N_theta'], theta_true, k_thresh\n        )\n        results.append(F)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3613787"}, {"introduction": "尽管逆时偏移在概念上非常强大，但它对计算资源（尤其是内存和I/O带宽）的需求也极为苛刻。本练习将重点从波场物理学转移到高性能计算的实际挑战上，要求您为一个混合存储策略建模其I/O需求。理解这些性能权衡对于设计高效的RTM工作流至关重要，从而使其能够应用于大规模的实际地震数据集 [@problem_id:3613773]。", "problem": "要求针对计算地球物理学中的逆时偏移 (RTM) 设计并分析一种边界保存加稀疏检查点的混合方案。考虑在 RTM 中使用的二维声波有限差分时域波传播。使用以下基本原理和建模假设，推导所需的输入/输出模型，并计算避免计算流水线节流所必需的 I/O 带宽。\n\n基本原理和建模假设：\n- 均匀介质中的声波方程由以下二阶线性偏微分方程给出\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = v^2 \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial z^2} \\right),\n$$\n其中 $u$ 是压力场，$v$ 是波速。在有限差分时域离散化中，空间导数使用半宽为 $h$ 个网格点的模板进行近似，这意味着当使用时间二阶格式时，保存厚度为 $h$ 的边界足以在逆时重演期间重新生成内部区域。\n- 设网格大小为 $N_x \\times N_z$ 点，时间步数为 $N_t$。设每个标量场分量占用 $b$ 字节。假设在边界处每个采样点存储 $n_b$ 个分量，在快照中每个采样点存储 $n_s$ 个分量，其中 $n_b, n_s \\in \\{1,2,\\dots\\}$。\n- 设 $f_{\\text{gp}}$ 表示每个时间步每个网格点的浮点运算次数， $P$ 表示以每秒浮点运算次数（FLOP/s）为单位的持续浮点性能。则每个时间步的计算时间为\n$$\nt_c = \\frac{N_x N_z f_{\\text{gp}}}{P}.\n$$\n\n边界保存与稀疏检查点混合设计：\n- 在每个时间步，仅保存模型域周围厚度为 $h$ 的边界区域，以便可以从这些边界条件驱动逆时重建。边界点数为\n$$\nN_{\\text{bnd}} = 2 h N_x + 2 h (N_z - 2 h) = 2 h \\bigl( N_x + N_z - 2 h \\bigr).\n$$\n每个时间步的边界数据量为\n$$\nD_b = N_{\\text{bnd}} \\cdot n_b \\cdot b \\quad \\text{字节}.\n$$\n- 此外，每隔 $k$ 个时间步保存一次全体积的稀疏检查点（快照），其中 $k \\in \\mathbb{N}$，$k \\ge 1$。一次快照的数据量为\n$$\nD_s = N_x N_z \\cdot n_s \\cdot b \\quad \\text{字节}.\n$$\n- 允许特殊情况 $k=0$ 代表纯边界保存方案，即没有快照，因此实际上永远不会产生 $D_s$。\n\n为避免计算节流的带宽定义：\n- 将每步同步带宽需求（无步间分摊）定义为最小 I/O 带宽 $B_{\\text{sync}}$，使得在某个步骤中逻辑上发生的所有 I/O 都能在该步骤的计算时间 $t_c$ 内完成：\n    - 如果 $k=0$，则\n    $$\n    B_{\\text{sync}} = \\frac{D_b}{t_c}.\n    $$\n    - 如果 $k \\ge 1$，则在有快照的步骤中，I/O 数据量为 $D_b + D_s$，在没有快照的步骤中，I/O 数据量为 $D_b$。为避免在每一步都发生节流，\n    $$\n    B_{\\text{sync}} = \\max\\left( \\frac{D_b}{t_c}, \\frac{D_b + D_s}{t_c} \\right) = \\frac{D_b + D_s}{t_c}.\n    $$\n- 将持续带宽需求（深度缓冲流）定义为最小 I/O 带宽 $B_{\\text{sust}}$，使得在 $k$ 个步骤的窗口内平均的 I/O 不超过这些步骤的计算时间。通过足够的缓冲，快照的开销可以分摊到整个窗口：\n    - 如果 $k=0$，则\n    $$\n    B_{\\text{sust}} = \\frac{D_b}{t_c}.\n    $$\n    - 如果 $k \\ge 1$，则在 $k$ 个步骤内，I/O 数据量为 $k D_b + D_s$，计算时间为 $k t_c$，因此平均速率需求为\n    $$\n    \\frac{k D_b + D_s}{k t_c}.\n    $$\n    然而，每一步仍必须维持边界数据的流，因此所需的持续带宽为\n    $$\n    B_{\\text{sust}} = \\max\\left( \\frac{D_b}{t_c}, \\frac{k D_b + D_s}{k t_c} \\right).\n    $$\n\n前向和后向阶段：\n- 在 RTM 中，正演模拟写入边界和快照数据；反向传播读取它们。假设读取和写入阶段在时间上不重叠。那么，峰值带宽需求由前向或后向的每步速率中的较大者决定。在对称假设下，两个阶段每步的 I/O 数据量相同，因此上述带宽表达式无需额外缩放即可满足要求。\n\n您的任务：\n- 实现一个程序，对于给定的参数集，计算以千兆字节/秒 (GB/s) 为单位的 $B_{\\text{sync}}$ 和 $B_{\\text{sust}}$。报告每个测试用例的这两个值。通过除以 $10^9$ 将字节/秒转换为 GB/s。将报告的每个带宽值四舍五入到三位小数。不需要用户输入；程序必须为下面内置的测试套件计算答案。\n\n测试套件：\n- 使用以下四组参数集，它们分别探测试了典型情况、精度变化、大型模型和纯边界等边缘情况。\n    1. 理想路径：\n        - $N_x = 2000$, $N_z = 1000$, $N_t = 4000$, $h = 4$, $b = 4$, $n_b = 1$, $n_s = 1$, $f_{\\text{gp}} = 50$, $P = 1 \\times 10^{11}$, $k = 200$。\n    2. 密集检查点与双精度：\n        - $N_x = 2000$, $N_z = 1000$, $N_t = 4000$, $h = 4$, $b = 8$, $n_b = 1$, $n_s = 1$, $f_{\\text{gp}} = 50$, $P = 1 \\times 10^{11}$, $k = 1$。\n    3. 具有更高性能和不同模板开销的大型模型：\n        - $N_x = 8000$, $N_z = 4000$, $N_t = 4000$, $h = 4$, $b = 4$, $n_b = 1$, $n_s = 1$, $f_{\\text{gp}} = 60$, $P = 2 \\times 10^{11}$, $k = 100$。\n    4. 纯边界方案（无快照）：\n        - $N_x = 1500$, $N_z = 1500$, $N_t = 4000$, $h = 8$, $b = 4$, $n_b = 1$, $n_s = 1$, $f_{\\text{gp}} = 50$, $P = 8 \\times 10^{10}$, $k = 0$。\n\n答案规格：\n- 对于每个测试用例，计算两个浮点数：$B_{\\text{sync}}$ 和 $B_{\\text{sust}}$，均以 GB/s 为单位，并四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个内部列表包含一个测试用例的配对值，格式完全如下\n\"[[Bsync_case1,Bsust_case1],[Bsync_case2,Bsust_case2],[Bsync_case3,Bsust_case3],[Bsync_case4,Bsust_case4]]\"。", "solution": "目标是为 RTM 中的一种边界保存与稀疏检查点混合方案，计算两个关键的 I/O 性能指标：同步带宽 $B_{\\text{sync}}$ 和持续带宽 $B_{\\text{sust}}$。计算基于一组给定的参数和公式。最终结果必须以千兆字节/秒 (GB/s) 报告，并四舍五入到三位小数。\n\n分析过程包括几个步骤，这些步骤源于问题陈述中概述的原理。\n\n首先，我们计算支撑带宽需求的基本量。\n每个时间步的计算时间 $t_c$ 是在不暂停计算的情况下，每一步可用于 I/O 操作的时间。它被定义为网格大小（$N_x$, $N_z$）、每步每个网格点的浮点运算次数（$f_{\\text{gp}}$）以及机器的持续性能（$P$）的函数：\n$$\nt_c = \\frac{N_x N_z f_{\\text{gp}}}{P}\n$$\n边界区域的数据量 $D_b$ 是每个时间步写入的数据量。它取决于模板半宽 $h$、网格维度（$N_x$, $N_z$）、每个边界样本的分量数 $n_b$ 以及每个分量的字节数 $b$。边界点的数量为 $N_{\\text{bnd}} = 2h(N_x + N_z - 2h)$。因此数据量为：\n$$\nD_b = N_{\\text{bnd}} \\cdot n_b \\cdot b = 2h(N_x + N_z - 2h) \\cdot n_b \\cdot b\n$$\n全体积快照的数据量 $D_s$ 是每隔 $k$ 步间歇性写入的数据量。它取决于网格大小、每个快照样本的分量数 $n_s$ 以及每个分量的字节数 $b$：\n$$\nD_s = N_x N_z \\cdot n_s \\cdot b\n$$\n\n其次，我们使用这些量根据其定义计算所需的带宽 $B_{\\text{sync}}$ 和 $B_{\\text{sust}}$，并分别处理 $k=0$ 和 $k \\ge 1$ 的情况。\n\n对于同步带宽 $B_{\\text{sync}}$，系统必须在单个时间步的计算时间 $t_c$ 内处理峰值 I/O 负载。\n如果 $k=0$（仅边界保存），则每步的 I/O 总是 $D_b$。\n$$\nB_{\\text{sync}} = \\frac{D_b}{t_c} \\quad (\\text{当 } k=0)\n$$\n如果 $k \\ge 1$，最坏情况的 I/O 发生在同时保存边界和快照的步骤中，总数据量为 $D_b + D_s$。\n$$\nB_{\\text{sync}} = \\frac{D_b + D_s}{t_c} \\quad (\\text{当 } k \\ge 1)\n$$\n\n对于持续带宽 $B_{\\text{sust}}$，假设有足够深的 I/O 缓冲区，快照的 I/O 可以分摊到它们之间的 $k$ 个时间步上。\n如果 $k=0$，则没有分摊，持续需求与同步需求相同。\n$$\nB_{\\text{sust}} = \\frac{D_b}{t_c} \\quad (\\text{当 } k=0)\n$$\n如果 $k \\ge 1$，在一个 $k$ 步的窗口内写入的总数据为 $k D_b + D_s$，总计算时间为 $k t_c$。因此，平均带宽需求简化为：\n$$\nB_{\\text{sust}} = \\frac{k D_b + D_s}{k t_c} = \\frac{D_b}{t_c} + \\frac{D_s}{k t_c}\n$$\n\n最后，将以字节/秒为单位的结果通过除以 $10^9$ 转换为千兆字节/秒，然后按要求四舍五入到三位小数。\n\n我们为第一个测试用例演示计算过程：\n$N_x = 2000$, $N_z = 1000$, $h = 4$, $b = 4$, $n_b = 1$, $n_s = 1$, $f_{\\text{gp}} = 50$, $P = 1 \\times 10^{11}$, $k = 200$。\n\n1. 计算 $t_c$：\n$$t_c = \\frac{2000 \\cdot 1000 \\cdot 50}{1 \\times 10^{11}} = \\frac{10^8}{10^{11}} = 0.001 \\text{ s}$$\n2. 计算 $D_b$：\n$$N_{\\text{bnd}} = 2 \\cdot 4 \\cdot (2000 + 1000 - 2 \\cdot 4) = 8 \\cdot 2992 = 23936$$\n$$D_b = 23936 \\cdot 1 \\cdot 4 = 95744 \\text{ 字节}$$\n3. 计算 $D_s$：\n$$D_s = 2000 \\cdot 1000 \\cdot 1 \\cdot 4 = 8 \\times 10^6 \\text{ 字节}$$\n4. 计算带宽。由于 $k=200 \\ge 1$：\n$$B_{\\text{sync}} = \\frac{95744 + 8 \\times 10^6}{0.001} = 8,095,744,000 \\text{ 字节/秒} \\approx 8.096 \\text{ GB/s}$$\n$$B_{\\text{sust}} = \\frac{200 \\cdot 95744 + 8 \\times 10^6}{200 \\cdot 0.001} = \\frac{19,148,800 + 8,000,000}{0.2} = \\frac{27,148,800}{0.2} = 135,744,000 \\text{ 字节/秒} \\approx 0.136 \\text{ GB/s}$$\n\n将此过程应用于所有四个测试用例，得到以下结果：\n情况 1：$B_{\\text{sync}} = 8.096$ GB/s, $B_{\\text{sust}} = 0.136$ GB/s。\n情况 2：$B_{\\text{sync}} = 16.191$ GB/s, $B_{\\text{sust}} = 16.191$ GB/s。\n情况 3：$B_{\\text{sync}} = 13.373$ GB/s, $B_{\\text{sust}} = 0.173$ GB/s。\n情况 4：$B_{\\text{sync}} = 0.136$ GB/s, $B_{\\text{sust}} = 0.136$ GB/s。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other special libraries from scipy etc. are needed.\n\ndef solve():\n    \"\"\"\n    Computes synchronous and sustained I/O bandwidth requirements for RTM\n    based on a hybrid checkpointing scheme for a given set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy path:\n        {'Nx': 2000, 'Nz': 1000, 'h': 4, 'b': 4, 'nb': 1, 'ns': 1, 'fgp': 50, 'P': 1e11, 'k': 200},\n        # 2. Dense checkpointing and double precision:\n        {'Nx': 2000, 'Nz': 1000, 'h': 4, 'b': 8, 'nb': 1, 'ns': 1, 'fgp': 50, 'P': 1e11, 'k': 1},\n        # 3. Large model with higher performance and different stencil cost:\n        {'Nx': 8000, 'Nz': 4000, 'h': 4, 'b': 4, 'nb': 1, 'ns': 1, 'fgp': 60, 'P': 2e11, 'k': 100},\n        # 4. Boundary-only scheme (no snapshots):\n        {'Nx': 1500, 'Nz': 1500, 'h': 8, 'b': 4, 'nb': 1, 'ns': 1, 'fgp': 50, 'P': 8e10, 'k': 0},\n    ]\n\n    results = []\n    for params in test_cases:\n        # Unpack parameters for clarity\n        Nx, Nz = params['Nx'], params['Nz']\n        h, b = params['h'], params['b']\n        nb, ns = params['nb'], params['ns']\n        fgp, P, k = params['fgp'], params['P'], params['k']\n\n        # 1. Calculate compute time per time step (tc) in seconds.\n        # tc = (N_x * N_z * f_gp) / P\n        tc = (Nx * Nz * fgp) / P\n\n        # 2. Calculate boundary data volume per time step (Db) in bytes.\n        # N_bnd = 2*h*(N_x + N_z - 2*h)\n        # Db = N_bnd * n_b * b\n        N_bnd = 2 * h * (Nx + Nz - 2 * h)\n        Db = N_bnd * nb * b\n\n        # 3. Calculate full snapshot data volume (Ds) in bytes.\n        # Ds = N_x * N_z * n_s * b\n        Ds = Nx * Nz * ns * b\n\n        # 4. Calculate synchronous (B_sync) and sustained (B_sust) bandwidths\n        # in bytes per second (B/s).\n        B_sync_bps = 0.0\n        B_sust_bps = 0.0\n\n        if k == 0:\n            # Boundary-only scheme\n            # B_sync = Db / tc\n            # B_sust = Db / tc\n            B_sync_bps = Db / tc\n            B_sust_bps = B_sync_bps\n        else:  # k = 1\n            # Hybrid boundary-saving and sparse checkpointing scheme\n            # B_sync = (Db + Ds) / tc\n            B_sync_bps = (Db + Ds) / tc\n            \n            # B_sust = max( Db/tc, (k*Db + Ds)/(k*tc) )\n            # The second term is always greater or equal, so we can simplify.\n            B_sust_bps = (k * Db + Ds) / (k * tc)\n        \n        # 5. Convert from B/s to GB/s (1 GB = 10^9 B) and round to 3 decimal places.\n        GB_CONVERSION_FACTOR = 1e9\n        B_sync_gbs = round(B_sync_bps / GB_CONVERSION_FACTOR, 3)\n        B_sust_gbs = round(B_sust_bps / GB_CONVERSION_FACTOR, 3)\n        \n        results.append([B_sync_gbs, B_sust_gbs])\n\n    # Final print statement in the exact required format.\n    # \"[[Bsync_case1,Bsust_case1],[Bsync_case2,Bsust_case2],...]\"\n    # We construct the string manually to avoid spaces introduced by default list-to-string conversion.\n    inner_lists = [f\"[{res[0]},{res[1]}]\" for res in results]\n    output_string = f\"[{','.join(inner_lists)}]\"\n    print(output_string)\n\nsolve()\n```", "id": "3613773"}]}