{"hands_on_practices": [{"introduction": "离散傅里叶变换 (DFT) 的核心应用之一是高效计算长度为 $L$ 的信号与长度为 $M$ 的滤波器的线性卷积。然而，若使用的DFT点数 $N$ 小于 $L+M-1$，频域相乘的结果将不再是线性卷积，而是会产生时域混叠的循环卷积。这个练习 ([@problem_id:3616396]) 将通过一个具体的数值算例，让您亲手计算出由于DFT长度不足而导致的“环绕”误差，从而深刻理解避免时域混叠的必要条件。", "problem": "在勘探地震学中，记录道通常被建模为带限震源子波与稀疏反射系数序列的线性卷积。频域实现使用离散傅里叶变换 (DFT) 来加速此运算，该变换通过快速傅里叶变换 (FFT) 进行计算。当 DFT 长度相对于总卷积长度不足时，逆 DFT 会产生循环卷积，从而导致破坏早期采样点的时域缠绕伪影。\n\n考虑一个有限震源子波 $w[n]$ 和反射系数序列 $r[n]$，以 $n \\in \\{0,1,2,\\dots\\}$ 为索引，并且在其指定的支撑域之外为零。设 $w[n]$ 的长度为 $L=4$，采样点为\n$$\nw[0]=2,\\quad w[1]=-1,\\quad w[2]=3,\\quad w[3]=1,\n$$\n设 $r[n]$ 的长度为 $M=5$，采样点为\n$$\nr[0]=1,\\quad r[1]=-2,\\quad r[2]=0,\\quad r[3]=1,\\quad r[4]=2.\n$$\n定义线性卷积 $y[n] = \\sum_{m=0}^{L-1} w[m]\\,r[n-m]$，其中 $n=0,1,\\dots,L+M-2$，并约定当 $n<0$ 或 $n>M-1$ 时 $r[n]=0$。假设我们使用一个 $N$ 点离散傅里叶变换 (DFT) (其中 $N=6$) 通过频域相乘来计算卷积（即，将 $w[n]$ 和 $r[n]$ 都补零至长度 $N=6$，在 DFT 域相乘，然后进行逆变换），得到 $N$ 点循环卷积 $y^{(N)}[n]$，其中 $n=0,1,\\dots,5$。\n\n从离散傅里叶变换 (DFT) 及其逆变换的定义以及线性卷积的定义出发，定量地确定 $y^{(N)}[n]$ 的哪些时域采样点被缠绕伪影所污染，并计算它们的值。将受污染的 $y^{(N)}[n]$ 采样值按采样点索引递增的顺序作为一个单独的向量报告。无需四舍五入。全程使用从零开始的索引，并假设序列是实值的。", "solution": "本问题要求识别和计算循环卷积中被缠绕伪影污染的时域采样点。这种情况发生在使用离散傅里叶变换 (DFT) 实现线性卷积时，若变换长度 $N$ 不足以容纳线性卷积的完整结果，就会出现此现象。\n\n首先，我们陈述定义和给定数据。震源子波 $w[n]$ 是一个长度为 $L=4$ 的序列，其值为：\n$$\nw[0]=2, \\quad w[1]=-1, \\quad w[2]=3, \\quad w[3]=1\n$$\n反射系数序列 $r[n]$ 是一个长度为 $M=5$ 的序列，其值为：\n$$\nr[0]=1, \\quad r[1]=-2, \\quad r[2]=0, \\quad r[3]=1, \\quad r[4]=2\n$$\n对于所有其他索引 $n$，这两个序列均为零。\n\n这两个序列的线性卷积 $y[n]$ 定义为：\n$$\ny[n] = (w * r)[n] = \\sum_{m=-\\infty}^{\\infty} w[m] r[n-m]\n$$\n对于有限长度的因果序列，这变为 $y[n] = \\sum_{m=0}^{L-1} w[m] r[n-m]$。所得序列 $y[n]$ 在长度为 $L+M-1$ 的支撑域上非零。在本例中，$y[n]$ 的长度是 $4+5-1 = 8$。非零采样点对应的索引为 $n \\in \\{0, 1, \\dots, 7\\}$。\n\n题目说明卷积是通过一个 $N$ 点 DFT 计算的，其中 $N=6$。这包括将 $w[n]$ 和 $r[n]$ 补零至长度 $N=6$，计算它们各自的 $N$ 点 DFT，将 DFT 结果相乘，并执行一个 $N$ 点逆 DFT。这个过程产生补零序列的 $N$ 点循环卷积，我们将其记为 $y^{(N)}[n]$ 或 $y^{(6)}[n]$。\n\n线性卷积 $y[n]$ 与循环卷积 $y^{(N)}[n]$ 之间的关系由时域混叠公式给出：\n$$\ny^{(N)}[n] = \\sum_{k=-\\infty}^{\\infty} y[n+kN]\n$$\n其中 $n=0, 1, \\dots, N-1$。此处，$N=6$。该公式表明，循环卷积是线性卷积与其移位（混叠）副本的和。\n\n如果一个采样点 $y^{(N)}[n]$ 不等于对应的线性卷积采样点 $y[n]$，则认为该采样点受到缠绕效应的“污染”或影响。这发生在当 $k \\neq 0$ 时，至少有一项 $y[n+kN]$ 非零。对于长度为 $L+M-1=8$ 的线性卷积 $y[n]$ 和 DFT 长度 $N=6$，索引为 $n \\geq N$ 的 $y[n]$ 采样点将会缠绕。在本例中，采样点 $y[6]$ 和 $y[7]$ 将会发生混叠。\n\n采样点 $y[6]$ 对应于求和式中的 $n=0$ 和 $k=1$，因为 $0+1 \\cdot 6 = 6$。因此，$y[6]$ 将被加到 $y[0]$ 上，污染了循环卷积的采样点 $y^{(6)}[0]$。\n采样点 $y[7]$ 对应于求和式中的 $n=1$ 和 $k=1$，因为 $1+1 \\cdot 6 = 7$。因此，$y[7]$ 将被加到 $y[1]$ 上，污染了循环卷积的采样点 $y^{(6)}[1]$。\n对于索引 $n \\in \\{2, 3, 4, 5\\}$，因为 $y[n]$ 对于 $n \\geq 8$ 为零，所以项 $y[n+k \\cdot 6]$ 仅在 $k=0$ 时非零。因此，采样点 $y^{(6)}[2]$ 至 $y^{(6)}[5]$ 未受污染，且等于它们对应的线性卷积值。\n\n受污染的采样点位于索引 $n=0$ 和 $n=1$ 处。为了求出它们的值，我们必须首先计算线性卷积 $y[n]$ 所需的采样点。\n线性卷积序列 $y[n]$ 计算如下：\n$y[0] = w[0]r[0] = (2)(1) = 2$\n$y[1] = w[0]r[1] + w[1]r[0] = (2)(-2) + (-1)(1) = -4 - 1 = -5$\n$y[2] = w[0]r[2] + w[1]r[1] + w[2]r[0] = (2)(0) + (-1)(-2) + (3)(1) = 0 + 2 + 3 = 5$\n$y[3] = w[0]r[3] + w[1]r[2] + w[2]r[1] + w[3]r[0] = (2)(1) + (-1)(0) + (3)(-2) + (1)(1) = 2 - 6 + 1 = -3$\n$y[4] = w[0]r[4] + w[1]r[3] + w[2]r[2] + w[3]r[1] = (2)(2) + (-1)(1) + (3)(0) + (1)(-2) = 4 - 1 - 2 = 1$\n$y[5] = w[1]r[4] + w[2]r[3] + w[3]r[2] = (-1)(2) + (3)(1) + (1)(0) = -2 + 3 = 1$\n$y[6] = w[2]r[4] + w[3]r[3] = (3)(2) + (1)(1) = 6 + 1 = 7$\n$y[7] = w[3]r[4] = (1)(2) = 2$\n\n现在我们可以计算循环卷积 $y^{(6)}[n]$ 中受污染的采样点的值。\n对于 $n=0$：\n$$\ny^{(6)}[0] = \\sum_{k=-\\infty}^{\\infty} y[0+6k] = \\dots + y[-6] + y[0] + y[6] + y[12] + \\dots\n$$\n由于 $y[n]$ 仅在 $n \\in \\{0, \\dots, 7\\}$ 时非零，该和式简化为：\n$$\ny^{(6)}[0] = y[0] + y[6] = 2 + 7 = 9\n$$\n对于 $n=1$：\n$$\ny^{(6)}[1] = \\sum_{k=-\\infty}^{\\infty} y[1+6k] = \\dots + y[-5] + y[1] + y[7] + y[13] + \\dots\n$$\n该和式简化为：\n$$\ny^{(6)}[1] = y[1] + y[7] = -5 + 2 = -3\n$$\n受污染的采样点是 $y^{(6)}[0]=9$ 和 $y^{(6)}[1]=-3$。题目要求将这些值按索引递增的顺序作为一个单独的向量报告。", "answer": "$$\n\\boxed{\\begin{pmatrix} 9 & -3 \\end{pmatrix}}\n$$", "id": "3616396"}, {"introduction": "在进行谱分析时，DFT的一个固有局限性是其频率分辨率有限，这导致了“栅栏效应”。当一个正弦信号的真实频率 $f_0$ 恰好落在两个DFT频率仓之间时，其能量会泄漏到多个频率仓中，并且谱峰的幅值会低于真实幅值。这个练习 ([@problem_id:2443816]) 将引导您从第一性原理出发进行理论推导，并通过编程实践来量化这种扇形损失，帮助您掌握评估DFT谱分析中幅值精度的能力。", "problem": "考虑在矩形时间窗下的离散时间复正弦波及其离散傅里叶变换 (DFT)。使用以下基本依据：(i) 将 DFT 定义为样本的有限和，以及 (ii) 用于复指数求和的几何级数恒等式。定义采样信号为 $x[n] = A \\exp\\left(j \\left(2\\pi \\frac{f_0}{F_s} n + \\varphi\\right)\\right)$，其中整数 $n$ 满足 $0 \\le n \\le N-1$，幅度 $A > 0$，采样频率 $F_s$ 单位为赫兹，相位 $\\varphi$ 单位为弧度。DFT 索引集为 $k \\in \\{0,1,\\dots,N-1\\}$，DFT 谱线中心频率为 $f_k = \\frac{k}{N} F_s$。DFT 定义为 $X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j 2\\pi \\frac{k}{N} n\\right)$。快速傅里叶变换 (FFT) 是一种用更少的算术运算来精确计算此 DFT 的算法。角度必须以弧度为单位。\n\n您的任务是：\n1) 从 DFT 定义和几何级数求和出发，推导当正弦波频率 $f_0$ 未落在 DFT 谱线上时，矩形窗复正弦波的 DFT 幅度 $|X[k]|$ 的表达式。将您的结果特化到 $f_0$ 恰好位于两个相邻谱线中心之间的情况，即对于某个整数 $k_0$，有 $f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$。由此，推导“扇贝比” $\\rho_{\\mathrm{theory}}$ 的闭式表达式，其定义为在此半谱线偏移下最大 DFT 谱线幅度 $|X[k]|$ 与当 $f_0$ 恰好为 $f_{k_0}$ 时会出现的谱线上幅度 $|X[k_0]|$ 之间的比率。将 $\\rho_{\\mathrm{theory}}$ 表示为仅含 $N$ 的函数。\n2) 实现一个程序，对下述每个指定的测试用例，构造 $x[n]$（其中 $f_0$ 恰好在谱线 $k_0$ 和 $k_0+1$ 的中间），使用直接 $O(N^2)$ 求和与快速傅里叶变换两种方法计算 DFT，并评估：\n   a) 测量的扇贝比 $\\rho_{\\mathrm{meas}} = \\frac{\\max_k |X[k]|}{A N}$，\n   b) 绝对误差 $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$，\n   c) 双谱线对称性误差，定义为 $\\left|\\frac{|X[k_0]|}{|X[k_0+1]|} - 1\\right|$，以及\n   d) 直接 DFT 和 FFT 之间的无穷范数差，经 $A N$ 归一化，即 $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$。\n您必须使用两种方法计算 DFT，并报告所要求的标量值。\n\n科学真实性要求：对 $\\rho_{\\mathrm{theory}}$ 的推导必须从 DFT 定义和有限几何级数恒等式开始。不得在未展示其如何从这些基础推导出来的情况下，直接引用任何专门的窗函数变换“结果”。所有角度必须以弧度为单位。输出中不出现其他物理单位。所有输出均为无量纲实数。\n\n测试套件：使用以下四组参数集 $(N, F_s, k_0, A, \\varphi)$：\n- 情况 1：$(N=64,\\, F_s=8000,\\, k_0=10,\\, A=1.0,\\, \\varphi=0.3)$\n- 情况 2：$(N=63,\\, F_s=1000,\\, k_0=7,\\, A=2.0,\\, \\varphi=1.2)$\n- 情况 3：$(N=8,\\, F_s=128,\\, k_0=0,\\, A=0.5,\\, \\varphi=0.0)$\n- 情况 4：$(N=1024,\\, F_s=44100,\\, k_0=123,\\, A=1.0,\\, \\varphi=2.3)$\n\n对每个情况，构造 $f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$，生成 $x[n]$（$0 \\le n \\le N-1$），并通过两种方法计算 $X[k]$。\n\n最终输出格式：您的程序应生成单行输出，其中包含汇总四个案例结果的、由方括号括起来的扁平逗号分隔列表。对于按上述顺序列出的每个案例，按此顺序附加三个标量：绝对扇贝比误差 $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$、双谱线对称性误差 $\\left|\\frac{|X[k_0]|}{|X[k_0+1]|} - 1\\right|$，以及归一化的 DFT 与 FFT 无穷范数差 $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$。因此，程序必须打印一个包含 12 个浮点数的列表。", "solution": "问题陈述经过严格验证，被认为是合理的。它在科学上基于数字信号处理的原理，定义清晰、目标明确，提法得当，并且没有任何歧义或矛盾。因此，我们可以进行形式化的求解。\n\n根据要求，解决方案分两部分呈现：首先，对扇贝比进行理论推导；其次，解释用于验证此理论并计算相关误差指标的数值实现。\n\n**第 1 部分：理论扇贝比 $\\rho_{\\mathrm{theory}}$ 的推导**\n\n推导从离散傅里叶变换 (DFT) 的定义开始。信号是在有限区间上采样的复正弦波，这构成了一个隐式的矩形窗。\n\n离散时间信号定义为 $x[n] = A \\exp\\left(j \\left(2\\pi \\frac{f_0}{F_s} n + \\varphi\\right)\\right)$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。\nDFT $X[k]$ 定义为：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j 2\\pi \\frac{kn}{N}\\right)$$\n代入 $x[n]$ 的表达式：\n$$X[k] = \\sum_{n=0}^{N-1} A e^{j\\varphi} \\exp\\left(j 2\\pi \\frac{f_0}{F_s} n\\right) \\exp\\left(-j 2\\pi \\frac{kn}{N}\\right)$$\n我们可以将常数项 $A e^{j\\varphi}$ 提出，并合并指数项：\n$$X[k] = A e^{j\\varphi} \\sum_{n=0}^{N-1} \\left[\\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)\\right]^n$$\n这是一个形如 $\\sum_{n=0}^{N-1} r^n$ 的有限几何级数，其中公比为 $r = \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)$。使用几何级数求和恒等式 $\\sum_{n=0}^{N-1} r^n = \\frac{1-r^N}{1-r}$（此式在 $r \\neq 1$ 时成立）：\n$$X[k] = A e^{j\\varphi} \\frac{1 - \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right) N\\right)}{1 - \\exp\\left(j 2\\pi \\left(\\frac{f_0}{F_s} - \\frac{k}{N}\\right)\\right)} = A e^{j\\varphi} \\frac{1 - \\exp\\left(j 2\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{1 - \\exp\\left(j \\frac{2\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}$$\n为了求幅度 $|X[k]|$，我们使用恒等式 $|1 - e^{j\\theta}| = |e^{j\\theta/2}(e^{-j\\theta/2} - e^{j\\theta/2})| = |-2j e^{j\\theta/2}\\sin(\\theta/2)| = 2|\\sin(\\theta/2)|$。将此恒等式应用于分子和分母：\n$$|X[k]| = |A e^{j\\varphi}| \\left|\\frac{2\\sin\\left(\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{2\\sin\\left(\\frac{\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}\\right| = A \\left| \\frac{\\sin\\left(\\pi \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)}{\\sin\\left(\\frac{\\pi}{N} \\left(\\frac{Nf_0}{F_s} - k\\right)\\right)} \\right|$$\n这是幅度谱的一般表达式。现在，我们特化到频率 $f_0$ 恰好位于两个相邻 DFT 谱线 $k_0$ 和 $k_0+1$ 中心的情况：$f_0 = \\left(k_0 + \\frac{1}{2}\\right)\\frac{F_s}{N}$。\n项 $\\frac{Nf_0}{F_s} - k$ 变为 $k_0 + \\frac{1}{2} - k$。\n分子中正弦函数的自变量为 $\\pi \\left(k_0 - k + \\frac{1}{2}\\right)$。由于 $k_0-k$ 是整数，令其为 $m$。自变量为 $m\\pi + \\frac{\\pi}{2}$。该角度的正弦值为 $\\sin(m\\pi + \\frac{\\pi}{2}) = \\cos(m\\pi) = (-1)^m$。因此，其幅度始终为 $1$。\n幅度的表达式简化为：\n$$|X[k]| = \\frac{A}{\\left|\\sin\\left(\\frac{\\pi}{N} \\left(k_0 - k + \\frac{1}{2}\\right)\\right)\\right|}$$\n扇贝比 $\\rho_{\\mathrm{theory}}$ 比较的是此半谱线偏移下的最大 DFT 幅度与谱线上幅度。谱线上幅度是指当信号频率恰好落在谱线上（即 $f_0 = f_{k_0} = k_0\\frac{F_s}{N}$）时的 $|X[k_0]|$ 值。在这种谱线上情况下，对于 $k=k_0$，公比 $r$ 变为 $1$，几何级数和为 $N$。DFT 为 $X[k_0] = A e^{j\\varphi} N$，因此参考幅度为 $|X[k_0]|_{\\mathrm{on-bin}} = AN$。\n\n对于半谱线情况，最大幅度 $\\max_k |X[k]|$ 出现在分母 $\\left|\\sin\\left(\\frac{\\pi}{N} \\left(k_0 - k + \\frac{1}{2}\\right)\\right)\\right|$ 最小化时。当自变量最接近 0 时，即会出现此情况。这发生在 $k = k_0$ 和 $k = k_0+1$ 时。\n对于 $k=k_0$，自变量为 $\\frac{\\pi}{2N}$。\n对于 $k=k_0+1$，自变量为 $-\\frac{\\pi}{2N}$。\n在这两种情况下，分母的幅度均为 $\\sin\\left(\\frac{\\pi}{2N}\\right)$（假设 $N \\ge 2$，因此自变量在 $(0, \\pi/2)$ 区间内）。\n因此，最大 DFT 谱线幅度为 $\\max_k |X[k]| = \\frac{A}{\\sin\\left(\\frac{\\pi}{2N}\\right)}$。\n\n最后，理论扇贝比是这两个幅度的比率：\n$$\\rho_{\\mathrm{theory}} = \\frac{\\max_k |X[k]|_{\\mathrm{half-bin}}}{|X[k_0]|_{\\mathrm{on-bin}}} = \\frac{A / \\sin\\left(\\frac{\\pi}{2N}\\right)}{AN} = \\frac{1}{N \\sin\\left(\\frac{\\pi}{2N}\\right)}$$\n这就是所要求的 $\\rho_{\\mathrm{theory}}$ 仅作为 $N$ 的函数的闭式表达式。对于大的 $N$，使用小 $x$ 的近似 $\\sin(x) \\approx x$，我们得到 $\\rho_{\\mathrm{theory}} \\approx \\frac{1}{N(\\pi/2N)} = \\frac{2}{\\pi} \\approx 0.6366$，这是矩形窗的经典扇贝损失数值。\n\n**第 2 部分：数值实现**\n\n所提供的程序为四个测试用例实现了问题陈述中指定的计算。\n对于每个用例 $(N, F_s, k_0, A, \\varphi)$：\n$1$. 信号频率 $f_0$ 设置为 $f_0 = (k_0 + 0.5) \\frac{F_s}{N}$。\n$2$. 生成复值信号 $x[n]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。\n$3$. 使用两种方法计算 DFT：\n    a) 通过矩阵向量乘积实现的复杂度为 $O(N^2)$ 的直接求和：$X_{\\mathrm{direct}} = \\mathbf{W}x$，其中 $\\mathbf{W}$ 是 $N \\times N$ 的 DFT 矩阵，其元素为 $W_{kn} = \\exp(-j2\\pi kn/N)$。\n    b) 快速傅里叶变换 (FFT) 算法，使用 `numpy.fft.fft`，以 $O(N \\log N)$ 的复杂度计算相同的 DFT。\n$4$. 计算以下量：\n    a) 测量的扇贝比 $\\rho_{\\mathrm{meas}} = \\frac{\\max_k |X_{\\mathrm{FFT}}[k]|}{AN}$。我们使用 FFT 结果，因为它是标准的计算工具。\n    b) 绝对误差 $|\\rho_{\\mathrm{meas}} - \\rho_{\\mathrm{theory}}|$，它量化了我们推导的理论与数值计算之间的一致性。该值应接近机器精度。\n    c) 双谱线对称性误差 $\\left|\\frac{|X_{\\mathrm{FFT}}[k_0]|}{|X_{\\mathrm{FFT}}[k_0+1]|} - 1\\right|$。我们的推导表明这两个幅度应该相等，因此该误差衡量了计算出的频谱的数值对称性。\n    d) 归一化的无穷范数差 $\\frac{\\max_k |X_{\\mathrm{direct}}[k] - X_{\\mathrm{FFT}}[k]|}{A N}$。该指标量化了两种 DFT 计算方法之间的数值差异，这种差异源于浮点运算的不同顺序以及由此产生的舍入误差累积。\n\n然后，程序将四个测试用例中每个案例的这三个标量误差指标汇总成一个包含 12 个值的扁平列表作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT scalloping loss problem for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, Fs, k0, A, phi)\n    test_cases = [\n        (64, 8000.0, 10, 1.0, 0.3),\n        (63, 1000.0, 7, 2.0, 1.2),\n        (8, 128.0, 0, 0.5, 0.0),\n        (1024, 44100.0, 123, 1.0, 2.3),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, Fs, k0, A, phi = case\n\n        # 1. Construct signal\n        # Frequency is exactly halfway between bin k0 and k0+1\n        f0 = (k0 + 0.5) * Fs / N\n        n = np.arange(N)\n        # Complex sinusoid signal x[n]\n        x_n = A * np.exp(1j * (2 * np.pi * f0 / Fs * n + phi))\n\n        # 2. Compute DFT via direct O(N^2) summation\n        # Create the DFT matrix W\n        k = np.arange(N)\n        k_n_prod = np.outer(k, n)\n        W_matrix = np.exp(-1j * 2 * np.pi * k_n_prod / N)\n        # Compute DFT as a matrix-vector product\n        X_direct = W_matrix @ x_n\n\n        # 3. Compute DFT via FFT\n        X_fft = np.fft.fft(x_n)\n\n        # 4. Calculate the required metrics\n        \n        # a) Scalloping ratio error\n        # Theoretical scalloping ratio\n        # The argument of sin is small, so guard against N=0 (not in tests)\n        if N > 0:\n            rho_theory = 1.0 / (N * np.sin(np.pi / (2.0 * N)))\n        else:\n            rho_theory = 1.0 # Trivial case\n            \n        # Measured scalloping ratio using FFT results\n        max_mag_X_fft = np.max(np.abs(X_fft))\n        rho_meas = max_mag_X_fft / (A * N)\n        \n        # Absolute scalloping-ratio error\n        scalloping_ratio_error = np.abs(rho_meas - rho_theory)\n\n        # b) Two-bin symmetry error\n        # Magnitudes at bin k0 and k0+1 should be equal\n        mag_X_k0 = np.abs(X_fft[k0])\n        # The DFT is periodic, k0+1 is safe as k0  N-1 in all test cases.\n        mag_X_k0_plus_1 = np.abs(X_fft[k0 + 1])\n        \n        if mag_X_k0_plus_1 == 0:\n            # Avoid division by zero, though not expected here\n            symmetry_error = np.inf if mag_X_k0 != 0 else 0\n        else:\n            symmetry_error = np.abs(mag_X_k0 / mag_X_k0_plus_1 - 1.0)\n            \n        # c) Normalized difference between direct DFT and FFT\n        # Infinity norm of the difference vector\n        norm_inf_diff = np.max(np.abs(X_direct - X_fft)) / (A * N)\n        \n        # Append results for the current case\n        results.extend([scalloping_ratio_error, symmetry_error, norm_inf_diff])\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures standard floating point representation.\n    print(f\"[{','.join(f'{r:.17e}' for r in results)}]\")\n\nsolve()\n```", "id": "2443816"}, {"introduction": "谱泄漏会影响频率估计的准确性，但我们可以通过一些技巧来获得更精确的频率值。一个常见方法是在长度为 $N$ 的时域信号末尾补零，以计算一个例如 $2N$ 点的DFT，这相当于对信号的DTFT进行了更密集的采样。本练习 ([@problem_id:3616424]) 将指导您通过编程实现二次插值算法，并比较补零前后频率估计的精度差异，从而亲身体验补零作为一种频域插值技术在提高谱峰定位精度上的实用价值。", "problem": "考虑一个长度为 $N$、单位幅度和固定相位的离散时间复正弦波 $x[n]$，其归一化数字频率对应于 $m+0.3$ 个离散傅里叶变换 (DFT) 谱线，其中 $m$ 是一个整数。根据定义，第 $k$ 个 DFT 谱线对应的角频率为 $2\\pi k/N$ 弧度/采样点。基本原理是：(i) 离散傅里叶变换 (DFT) 是对离散时间傅里叶变换 (DTFT) 在离散频率网格 $2\\pi k/N$ 上的均匀采样，以及 (ii) 将时域序列补零至长度 $L>N$ 会在更密集的频率网格上计算 DFT 样本，而其底层的 DTFT 保持不变。您需要通过比较同一个有限长度正弦波的 $N$ 点和 $2N$ 点 DFT 峰值估计，来量化补零对内插频谱峰值定位的影响。\n\n任务：\n1. 信号模型与合成。对于每个测试用例 $(N,m)$，合成长度为 $N$ 的复指数\n$$\nx[n] = \\exp\\left(j\\left(2\\pi \\frac{m+0.3}{N} n + \\phi\\right)\\right), \\quad n=0,1,\\ldots,N-1,\n$$\n其固定相位为 $\\phi = \\pi/7$ (弧度)，幅度为单位1。这里 $j$ 表示虚数单位。\n\n2. 谱估计(使用与不使用补零)。计算以下内容：\n- 使用快速傅里叶变换 (FFT) 算法计算 $x[n]$ 的 $N$ 点 DFT，并确定最大幅值谱线的索引 $\\hat{k}$。仅使用索引为 $\\hat{k}-1$、$\\hat{k}$ 和 $\\hat{k}+1$ (采用模 $N$ 循环环绕) 的三个谱线的幅值，通过二次曲线拟合来估计真实最大值相对于 $\\hat{k}$ 的亚谱线偏移 $\\delta \\in [-0.5,0.5]$。得到的内插峰值位置以 $N$ 点谱线为单位表示为 $\\hat{\\kappa}_N = \\hat{k} + \\delta$。报告 $\\hat{\\kappa}_N$ 模 $N$ 的结果，以使 $\\hat{\\kappa}_N \\in [0,N)$。\n- 对同一个 $x[n]$ 进行 $2N$ 点 DFT，方法是在 $x[n]$ 末尾补 $N$ 个零使其长度变为 $2N$。再次确定最大幅值谱线的索引 $\\hat{k}_{2N}$，并使用索引为 $\\hat{k}_{2N}-1$、$\\hat{k}_{2N}$ 和 $\\hat{k}_{2N}+1$ (采用模 $2N$ 循环环绕) 的三个相邻幅值计算二次亚谱线偏移 $\\delta_{2N}$。将得到的内插峰值位置转换回原始的 $N$ 点谱线单位：$\\hat{\\kappa}_{2N} = \\left(\\hat{k}_{2N} + \\delta_{2N}\\right)/2$，并报告 $\\hat{\\kappa}_{2N}$ 模 $N$ 的结果，以使 $\\hat{\\kappa}_{2N} \\in [0,N)$。\n\n3. 误差量化。对于每种方法，计算相对于已知真实谱线位置 $k_{\\text{true}} = m+0.3$ 的绝对误差（以 $N$ 点谱线为单位）：\n$$\ne_N = \\left|\\hat{\\kappa}_N - (m+0.3)\\right|, \\quad e_{2N} = \\left|\\hat{\\kappa}_{2N} - (m+0.3)\\right|.\n$$\n\n4. 数值与算法基础。您必须：\n- 使用离散傅里叶变换 (DFT) 及其快速傅里叶变换 (FFT) 算法进行计算。\n- 通过对幅度谱中离散最大值周围的三个点进行抛物线拟合来实现二次峰值内插。不要使用任何外部的峰值拟合工具。\n\n5. 测试套件。使用以下五个测试用例来检验不同情况：\n- 情况 1: $N=64$, $m=10$ (一般情况)。\n- 情况 2: $N=64$, $m=0$ (接近直流)。\n- 情况 3: $N=64$, $m=31$ (对于偶数 $N$，接近奈奎斯特频率)。\n- 情况 4: $N=257$, $m=100$ (非2的幂次，大 $N$ 值)。\n- 情况 5: $N=15$, $m=7$ (小的奇数 $N$ 值)。\n\n6. 输出规格。对于每个测试用例，您的程序必须返回一个包含四个浮点数的列表：\n$$\n\\left[\\hat{\\kappa}_N, \\hat{\\kappa}_{2N}, e_N, e_{2N}\\right],\n$$\n以 $N$ 点谱线为单位，并四舍五入到 $10^{-6}$。将五个测试用例的列表按上述顺序聚合到一个列表中。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如\n$$\n\\left[\\left[\\cdot,\\cdot,\\cdot,\\cdot\\right],\\left[\\cdot,\\cdot,\\cdot,\\cdot\\right],\\left[\\cdot,\\cdot,\\cdot,\\cdot\\right],\\left[\\cdot,\\cdot,\\cdot,\\cdot\\right],\\left[\\cdot,\\cdot,\\cdot,\\cdot\\right]\\right].\n$$\n\n注意：\n- 本问题不涉及物理单位；所有值均以 $N$ 点谱线为单位报告。\n- 角度以弧度为单位。\n- 在访问相邻谱线时，使用循环环绕索引以确保在频谱边界处的数值鲁棒性。\n- 不要提供或依赖任何正弦频率的闭式估计量；您必须如上所述，使用 DFT 样本和对三个幅值点的二次拟合。", "solution": "该问题要求使用离散傅里叶变换 (DFT) 分析复正弦波的频谱峰值估计精度。我们比较标准 $N$ 点 DFT与通过对信号补零获得的 $2N$ 点 DFT 的性能。估计的核心是对 DFT 幅度谱在其峰值周围进行二次内插。\n\n每个测试用例 $(N, m)$ 的处理流程如下：\n\n1.  **信号合成**：首先，我们构建长度为 $N$ 的离散时间复正弦信号 $x[n]$。该信号由以下方程定义：\n    $$\n    x[n] = \\exp\\left(j\\left(2\\pi \\frac{k_{\\text{true}}}{N} n + \\phi\\right)\\right), \\quad n=0,1,\\ldots,N-1\n    $$\n    其中 $j$ 是虚数单位，相位为 $\\phi = \\pi/7$，真实的归一化频率为 $k_{\\text{true}} = m+0.3$ 个谱线。时间索引向量为 $n = [0, 1, \\ldots, N-1]$。\n\n2.  **$N$ 点 DFT 分析**：\n    -   我们使用快速傅里叶变换 (FFT) 算法计算 $x[n]$ 的 $N$ 点 DFT，记为 $X[k]$。\n    -   我们找到对应于 DFT 谱最大幅值的索引：$\\hat{k} = \\arg\\max_k |X[k]|$。\n    -   为了改进此估计，我们执行二次内插。这涉及到对来自幅度谱的三个点进行抛物线拟合：$(\\hat{k}-1, |X[\\hat{k}-1]|)$、$(\\hat{k}, |X[\\hat{k}]|)$ 和 $(\\hat{k}+1, |X[\\hat{k}+1]|)$。索引采用循环环绕处理，即索引 $i$ 取为 $i \\pmod N$。\n    -   设三个幅值为 $y_{-1} = |X[(\\hat{k}-1) \\pmod N]|$、$y_0 = |X[\\hat{k}]|$ 和 $y_{1} = |X[(\\hat{k}+1) \\pmod N]|$。我们求出通过点 $(-1, y_{-1})$、$(0, y_0)$ 和 $(1, y_{1})$ 的抛物线的顶点。顶点的水平坐标即为亞谱线偏移 $\\delta$。$\\delta$ 的计算公式为：\n    $$\n    \\delta = \\frac{y_{-1} - y_{1}}{2(y_{-1} - 2y_0 + y_{1})}\n    $$\n    由于 $\\hat{k}$ 是最大幅值谱线，该偏移量 $\\delta$ 应在 $[-0.5, 0.5]$ 范围内。\n    -   以 $N$ 点谱线为单位的内插峰值位置为 $\\hat{\\kappa}_N = \\hat{k} + \\delta$。我们应用模 $N$ 操作作为保障，确保结果在 $[0, N)$ 范围内：$\\hat{\\kappa}_N = (\\hat{k} + \\delta) \\pmod N$。\n\n3.  **$2N$ 点 DFT 分析 (带补零)**：\n    -   补零的原理是它提供了对信号底层离散时间傅里叶变换 (DTFT) 更密集的采样，而不改变其形状。我们创建一个长度为 $2N$ 的新信号 $x_{\\text{pad}}[n]$，方法是在原始信号 $x[n]$ 后追加 $N$ 个零。\n    -   我们使用 FFT 计算 $x_{\\text{pad}}[n]$ 的 $2N$ 点 DFT，记为 $X_{2N}[k]$。\n    -   与 $N$ 点情况类似，我们找到峰值幅值谱线的索引 $\\hat{k}_{2N} = \\arg\\max_k |X_{2N}[k]|$。\n    -   我们应用相同的二次内插公式，使用索引为 $(\\hat{k}_{2N}-1) \\pmod{2N}$、$\\hat{k}_{2N}$ 和 $(\\hat{k}_{2N}+1) \\pmod{2N}$ 处的幅值来找到亚谱线偏移 $\\delta_{2N}$。\n    -   以 $2N$ 点谱线为单位的内插峰值位置为 $\\hat{k}_{2N} + \\delta_{2N}$。为了将其与 $N$ 点估计和真实频率进行比较，我们必须通过除以 2 将其转换回原始的 $N$ 点谱线单位系统：\n    $$\n    \\hat{\\kappa}_{2N} = \\frac{\\hat{k}_{2N} + \\delta_{2N}}{2}\n    $$\n    同样，我们通过应用模 $N$ 操作来确保结果在 $[0, N)$ 范围内。\n\n4.  **误差量化**：\n    -   对于这两种估计方法，我们都计算相对于已知真实频率 $k_{\\text{true}} = m+0.3$ 的绝对误差。\n    -   误差由以下公式给出：\n    $$\n    e_N = |\\hat{\\kappa}_N - k_{\\text{true}}|\n    $$\n    $$\n    e_{2N} = |\\hat{\\kappa}_{2N} - k_{\\text{true}}|\n    $$\n    这些计算的结果将表明，补零（即对 DTFT 进行更密集的采样）通常会提高二次内插频率估计器的准确性。\n\n5.  **测试用例的实现**：将整个过程应用于五个 $(N, m)$ 测试用例中的每一个。对于每个用例，收集最终结果 $[\\hat{\\kappa}_N, \\hat{\\kappa}_{2N}, e_N, e_{2N}]$，四舍五入到 $10^{-6}$，并按规定格式化为列表的列表。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating a sinusoid's frequency using DFT\n    with and without zero-padding, and quantifies the estimation error.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement: (N, m)\n    test_cases = [\n        (64, 10),\n        (64, 0),\n        (64, 31),\n        (257, 100),\n        (15, 7),\n    ]\n\n    results = []\n\n    # Fixed phase for the sinusoid\n    phi = np.pi / 7.0\n\n    for N, m in test_cases:\n        # 1. Signal model and synthesis\n        k_true = m + 0.3\n        n = np.arange(N)\n        # Angular frequency in radians per sample\n        omega = 2.0 * np.pi * k_true / N\n        # Synthesize complex exponential signal\n        x_n = np.exp(1j * (omega * n + phi))\n\n        # 2. Spectral estimation without zero-padding (N-point DFT)\n        X_N = np.fft.fft(x_n)\n        X_N_mag = np.abs(X_N)\n        k_hat = int(np.argmax(X_N_mag))\n\n        # Quadratic interpolation for N-point DFT\n        # Get magnitudes of the peak and its immediate neighbors\n        y_m1 = X_N_mag[(k_hat - 1) % N]\n        y_0 = X_N_mag[k_hat]\n        y_p1 = X_N_mag[(k_hat + 1) % N]\n\n        # Parabola vertex formula for sub-bin offset delta\n        denominator_N = 2.0 * (y_m1 - 2.0 * y_0 + y_p1)\n        if np.isclose(denominator_N, 0):\n            delta_N = 0.0\n        else:\n            delta_N = (y_m1 - y_p1) / denominator_N\n        \n        # Interpolated peak location in N-bin units\n        kappa_hat_N = (k_hat + delta_N) % N\n\n        # 3. Spectral estimation with zero-padding (2N-point DFT)\n        # Pad the signal with N zeros to get a length 2N signal\n        x_padded = np.pad(x_n, (0, N), 'constant')\n        \n        X_2N = np.fft.fft(x_padded)\n        X_2N_mag = np.abs(X_2N)\n        k_hat_2N = int(np.argmax(X_2N_mag))\n        \n        # Quadratic interpolation for 2N-point DFT\n        y_m1_2N = X_2N_mag[(k_hat_2N - 1) % (2 * N)]\n        y_0_2N = X_2N_mag[k_hat_2N]\n        y_p1_2N = X_2N_mag[(k_hat_2N + 1) % (2 * N)]\n\n        denominator_2N = 2.0 * (y_m1_2N - 2.0 * y_0_2N + y_p1_2N)\n        if np.isclose(denominator_2N, 0):\n            delta_2N = 0.0\n        else:\n            delta_2N = (y_m1_2N - y_p1_2N) / denominator_2N\n        \n        # Interpolated peak location, converted back to N-bin units\n        kappa_hat_2N = ((k_hat_2N + delta_2N) / 2.0) % N\n\n        # 4. Error quantification\n        e_N = np.abs(kappa_hat_N - k_true)\n        e_2N = np.abs(kappa_hat_2N - k_true)\n\n        # 6. Output specification: round and collect results\n        case_result = [\n            round(kappa_hat_N, 6),\n            round(kappa_hat_2N, 6),\n            round(e_N, 6),\n            round(e_2N, 6)\n        ]\n        results.append(case_result)\n\n    # Format the final output string exactly as required\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3616424"}]}