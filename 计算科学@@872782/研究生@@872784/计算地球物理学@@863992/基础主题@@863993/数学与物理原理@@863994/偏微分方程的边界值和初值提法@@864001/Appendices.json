{"hands_on_practices": [{"introduction": "在使用显式时间步进格式模拟波的传播时，确保数值稳定性是首要问题。如果时间步长 $\\Delta t$ 相对于空间网格间距 $\\Delta x$ 选择得过大，模拟结果可能会变得极不稳定并产生非物理的结果。本练习将引导你推导著名的 Courant–Friedrichs–Lewy (CFL) 条件，这是控制许多双曲型偏微分方程数值方法稳定性的基本原则。[@problem_id:3578541]", "problem": "考虑在占据一个$d$维矩形域 $\\Omega = [0,L]^{d}$ 的均匀各向同性介质中的线性声波传播，其波速 $c$ 为常数。边界条件为齐次Dirichlet边界条件，即对所有 $\\mathbf{x} \\in \\partial \\Omega$ 和 $t \\ge 0$ 有 $u(\\mathbf{x},t) = 0$。初始条件为光滑函数 $u(\\mathbf{x},0) = f(\\mathbf{x})$ 和 $u_{t}(\\mathbf{x},0) = g(\\mathbf{x})$。其控制偏微分方程为二阶双曲型波动方程 $u_{tt}(\\mathbf{x},t) = c^{2} \\nabla^{2} u(\\mathbf{x},t)$。\n\n在一个均匀的笛卡尔网格上，每个坐标方向的网格间距均为 $\\Delta x$。使用标准的二阶中心有限差分拉普拉斯算子对空间进行离散化，并使用标准的二阶中心三层显式更新对时间进行离散化。对于内部网格点索引 $\\mathbf{j} = (j_{1},\\dots,j_{d})$ 和时间层 $t^{n} = n \\Delta t$，该格式为\n$$\nu_{\\mathbf{j}}^{n+1} \\;=\\; 2 u_{\\mathbf{j}}^{n} \\;-\\; u_{\\mathbf{j}}^{n-1} \\;+\\; c^{2} \\Delta t^{2} \\sum_{m=1}^{d} \\frac{u_{\\mathbf{j}+\\mathbf{e}_{m}}^{n} \\;-\\; 2 u_{\\mathbf{j}}^{n} \\;+\\; u_{\\mathbf{j}-\\mathbf{e}_{m}}^{n}}{\\Delta x^{2}},\n$$\n其中 $\\mathbf{e}_{m}$ 是第$m$个坐标方向上的单位索引向量。在所有时间层上施加齐次Dirichlet边界条件：对于离散边界上的 $\\mathbf{j}$，有 $u_{\\mathbf{j}}^{n} = 0$。\n\n从控制方程和这个显式格式出发，通过分析格式放大因子在所有容许的离散波数上的有界性，推导Courant–Friedrichs–Lewy (CFL)稳定性条件，该条件用 $c$、$\\Delta x$ 和 $d$ 来约束时间步长 $\\Delta t$。然后，使用基于算子谱或离散能量的论证，解释为什么齐次Dirichlet边界的存在不允许使用比内部模板所决定的约束更大的 $\\Delta t$。将你的最终结果表示为最大允许时间步长 $\\Delta t$ 关于 $c$、$\\Delta x$ 和 $d$ 的单个闭式解析表达式。在最终的方框表达式中不要包含单位。", "solution": "基本出发点是线性声波方程 $u_{tt} = c^{2} \\nabla^{2} u$，这是一个双曲型方程，允许特征速度为 $c$ 的行波解。一种标准的二阶精度显式有限差分方法结合了时间和空间上的中心差分。在一个各方向网格间距均为 $\\Delta x$ 的均匀笛卡尔网格上，作用于网格函数 $v_{\\mathbf{j}}$ 的离散拉普拉斯算子 $\\Delta_{h}$ 为\n$$\n\\Delta_{h} v_{\\mathbf{j}} \\;=\\; \\sum_{m=1}^{d} \\frac{v_{\\mathbf{j}+\\mathbf{e}_{m}} \\;-\\; 2 v_{\\mathbf{j}} \\;+\\; v_{\\mathbf{j}-\\mathbf{e}_{m}}}{\\Delta x^{2}}.\n$$\n波动方程的显式三层更新格式为\n$$\nu_{\\mathbf{j}}^{n+1} \\;=\\; 2 u_{\\mathbf{j}}^{n} \\;-\\; u_{\\mathbf{j}}^{n-1} \\;+\\; c^{2} \\Delta t^{2} \\,\\Delta_{h} u_{\\mathbf{j}}^{n}.\n$$\n\n为了推导Courant–Friedrichs–Lewy (CFL)稳定性条件，我们进行von Neumann分析。对于线性常系数模板，该分析评估离散平面波的放大因子。尽管物理问题具有齐次Dirichlet边界条件，但显式局部模板的CFL约束源于内部更新；因此，分析局部类似于平面波的模态就足够了。考虑离散傅里叶模态\n$$\nu_{\\mathbf{j}}^{n} \\;=\\; \\rho^{n} \\exp\\!\\Big( i \\sum_{m=1}^{d} j_{m} \\theta_{m} \\Big),\n$$\n其中相位角 $\\theta_{m} \\in [0,\\pi]$ 捕捉了网格可分辨的最高频率。将此试探解代入更新格式，利用线性和可分离性，得到\n$$\n\\rho^{n+1} \\exp\\!\\Big( i \\sum_{m} j_{m} \\theta_{m} \\Big) \\;-\\; 2 \\rho^{n} \\exp\\!\\Big( i \\sum_{m} j_{m} \\theta_{m} \\Big) \\;+\\; \\rho^{n-1} \\exp\\!\\Big( i \\sum_{m} j_{m} \\theta_{m} \\Big)\n$$\n$$\n=\\; c^{2} \\Delta t^{2} \\sum_{m=1}^{d} \\frac{\\exp\\!\\big( i (j_{m}+1) \\theta_{m} \\big) + \\exp\\!\\big( i (j_{m}-1) \\theta_{m} \\big) - 2 \\exp\\!\\big( i j_{m} \\theta_{m} \\big)}{\\Delta x^{2}} \\prod_{k \\neq m} \\exp\\!\\big( i j_{k} \\theta_{k} \\big) \\,\\rho^{n}.\n$$\n消去公因子 $\\exp\\!\\big( i \\sum_{m} j_{m} \\theta_{m} \\big) \\rho^{n}$ 并使用 $\\exp(i \\theta) + \\exp(-i \\theta) - 2 = 2 (\\cos \\theta - 1) = -4 \\sin^{2}(\\theta/2)$，我们得到放大因子 $\\rho$ 的标量递推关系：\n$$\n\\rho^{2} \\;-\\; 2 \\rho \\;+\\; 1 \\;=\\; -\\, 4 \\rho \\, \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big),\n$$\n其中 $\\lambda := \\frac{c \\Delta t}{\\Delta x}$ 是在网格间距均匀时每个坐标的无量纲Courant数。整理得，\n$$\n\\rho^{2} \\;+\\; \\rho \\Big( 4 \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big) \\;-\\; 2 \\Big) \\;+\\; 1 \\;=\\; 0.\n$$\n令 $z := \\rho$ 并两边同除以 $z$ 得到\n$$\nz \\;+\\; \\frac{1}{z} \\;=\\; 2 \\;-\\; 4 \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big).\n$$\n对于守恒型双曲方程的二阶中心格式，为了保证稳定性，放大因子必须是幺模的，即 $|z| = 1$。因此我们可以设 $z = \\exp(i \\Omega \\Delta t)$，其中 $\\Omega$ 为某个实离散频率。于是 $z + z^{-1} = 2 \\cos(\\Omega \\Delta t)$，这意味着\n$$\n2 \\cos(\\Omega \\Delta t) \\;=\\; 2 \\;-\\; 4 \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big).\n$$\n对所有容许的 $\\theta_{m}$，存在实数 $\\Omega$ 的一个充分必要条件是，上式右端项的值落在区间 $[-2,2]$ 内。因此，\n$$\n\\Big| \\, 2 \\;-\\; 4 \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big) \\, \\Big| \\;\\le\\; 2\n\\quad \\Longleftrightarrow \\quad\n0 \\;\\le\\; \\sum_{m=1}^{d} \\lambda^{2} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big) \\;\\le\\; 1.\n$$\n因为 $\\sin^{2}(\\cdot)$ 的上界为 $1$，所以对于所有可分辨的网格波数，最坏情况在每个 $\\sin^{2}(\\theta_{m}/2)$ 趋近于 $1$ 时达到。因此，一个充分且尖锐的界是\n$$\n\\sum_{m=1}^{d} \\lambda^{2} \\;\\le\\; 1.\n$$\n当所有方向的网格间距均匀时，$\\lambda$对每个$m$都相同，从而得到\n$$\nd \\lambda^{2} \\;\\le\\; 1\n\\quad \\Longrightarrow \\quad\n\\lambda \\;\\le\\; \\frac{1}{\\sqrt{d}}\n\\quad \\Longrightarrow \\quad\n\\Delta t \\;\\le\\; \\frac{\\Delta x}{c \\sqrt{d}}.\n$$\n这就是$d$维均匀网格上波动方程的显式二阶精度中心格式的Courant–Friedrichs–Lewy (CFL)稳定性条件。\n\n我们现在解释为什么齐次Dirichlet边界条件不会放宽这个内部时间步长约束。有两个基于第一性原理的互补观点：\n\n1. 谱观点。带有齐次Dirichlet边界条件的离散拉普拉斯算子是一个对称负定矩阵，其特征向量是正弦函数的张量积，其特征值为\n$$\n\\mu_{\\mathbf{k}} \\;=\\; \\frac{2}{\\Delta x^{2}} \\sum_{m=1}^{d} \\big( \\cos(\\theta_{m}) - 1 \\big)\n\\;=\\; -\\, \\frac{4}{\\Delta x^{2}} \\sum_{m=1}^{d} \\sin^{2}\\!\\Big( \\frac{\\theta_{m}}{2} \\Big),\n$$\n其中离散角 $\\theta_{m}$ 由网格和边界决定。谱半径 $|\\mu_{\\max}|$ 的上界为 $\\frac{4}{\\Delta x^{2}} \\sum_{m=1}^{d} 1 = \\frac{4 d}{\\Delta x^{2}}$，与周期性内部模板的界相同。随着网格加密，容许的 $\\sin^{2}$ 的最大值趋近于 $1$，因此Dirichlet谱渐近地饱和到与内部平面波分析相同的界。显式更新将该谱乘以 $c^{2} \\Delta t^{2}$，而上面推导的三层稳定性要求仅取决于 $\\sum_{m} \\sin^{2}(\\theta_{m}/2)$ 的上确界，Dirichlet边界条件无法使其超过 $1$；因此它们不允许使用更大的 $\\Delta t$。\n\n2. 局域能量观点。CFL约束反映了这样一个要求：相对于特征速度 $c$，数值信息在每个时间步内传播的距离不能超过一个网格单元。这种局部性由内部模板的宽度和波速控制，与边界条件无关。齐次Dirichlet边界限制了全局模态的形状，但不会改变内部更新中的局部耦合。因此，限制性最强的局部模態——对应于网格尺度的振荡——仍然决定着稳定性极限，边界的施加不会放宽内部的时间步長约束。\n\n因此，对于$d$维均匀网格上的这种显式二阶精度格式，为保证稳定性，最大允许时间步长为\n$$\n\\Delta t_{\\max} \\;=\\; \\frac{\\Delta x}{c \\sqrt{d}}.\n$$", "answer": "$$\\boxed{\\frac{\\Delta x}{c \\sqrt{d}}}$$", "id": "3578541"}, {"introduction": "尽管完整的波动方程捕捉了波现象的方方面面，但许多地球物理应用（如地震层析成像）主要关心的是第一波至的到达时。本练习深入探讨了波动方程的高频近似，它引出了程函方程 $|\\nabla T| = 1/c(\\mathbf{x})$，并要求你实现快速行进法 (Fast Marching Method, FMM) 来求解它。通过这个实践，你将获得计算走时场和分析焦散区（射线理论失效之处）附近数值行为的实践经验。[@problem_id:3578554]", "problem": "考虑非均匀介质中的声波方程，写作 $c(\\mathbf{x})^{-2}\\,\\partial_{t}^{2} u(\\mathbf{x},t) - \\nabla^{2} u(\\mathbf{x},t) = 0$，其中 $u(\\mathbf{x},t)$ 是压力场，$c(\\mathbf{x})$ 是依赖于位置的波速（单位为 $\\mathrm{m/s}$）。在高频极限下，根据 Wentzel–Kramers–Brillouin (WKB) 拟设，领头阶相位 $T(\\mathbf{x})$ 满足程函方程 $|\\nabla T(\\mathbf{x})| = 1/c(\\mathbf{x})$，其中 $T(\\mathbf{x})$ 是走时（单位为 $\\mathrm{s}$），$\\mathbf{x}\\in\\Omega$ 表示在域 $\\Omega\\subset\\mathbb{R}^{2}$ 中的位置（单位为 $\\mathrm{m}$）。在计算地球物理学中，求解程函方程有两种常见的提法：边值问题和初值问题。\n\n在边值问题提法中，我们在边界 $\\Gamma\\subset\\partial\\Omega$ 上指定狄利克雷数据 $T|_{\\Gamma} = 0$，将 $T(\\mathbf{x})$ 建模为从边界到 $\\mathbf{x}$ 的最小走时。在点源的初值问题提法中，我们在源点位置 $\\mathbf{x}_{s}\\in\\Omega$ 指定 $T(\\mathbf{x}_{s}) = 0$，并将 $T(\\mathbf{x})$ 计算为从 $\\mathbf{x}_{s}$ 到 $\\mathbf{x}$ 的最小走时。两种提法都可能出现几何奇点，即射线相交或存在多条测地线的地方，通常称为焦散。在焦散附近，由于 $T(\\mathbf{x})$ 的不可微性，数值方法的误差可能会增大。\n\n从声波方程和导致程函方程的高频近似这一基本基础出发，推导并实现一个数值求解器，用于求解正方形域 $\\Omega = [0,1]^{2}$（单位为 $\\mathrm{m}\\times\\mathrm{m}$）上的 $|\\nabla T| = 1/c(\\mathbf{x})$ 方程，网格间距为 $h$（单位为 $\\mathrm{m}$），采用迎风离散化结合快速行进法 (FMM)。该实现必须与因果性和比较原理保持一致。定义慢度 $s(\\mathbf{x}) = 1/c(\\mathbf{x})$（单位为 $\\mathrm{s/m}$），并在更新规则中局部使用它。两个坐标方向均使用相同的各向同性局部模板间距 $h$。\n\n对于边值问题提法，在外边界 $\\Gamma = \\partial\\Omega$ 上强制执行狄利克雷条件 $T|_{\\Gamma} = 0$。对于初值问题提法，在最接近 $\\mathbf{x}_{s}$ 的单个网格点上强制执行 $T(\\mathbf{x}_{s}) = 0$。\n\n您必须在指定的测试案例下，量化两种提法在焦散附近的数值误差。当有解析参考解时，请使用它；否则，构建一个高分辨率的数值参考解，并将粗分辨率结果限制在一个近似焦散区域的掩码上进行比较。具体来说，在每边有 $N_{\\text{coarse}}$ 个点的粗网格和每边有 $N_{\\text{fine}}$ 个点的细网格上计算 $T(\\mathbf{x})$，其均匀间距分别为 $h_{\\text{coarse}} = 1/(N_{\\text{coarse}}-1)$ 和 $h_{\\text{fine}} = 1/(N_{\\text{fine}}-1)$（单位为 $\\mathrm{m}$）。对于非解析案例，通过最近邻采样将细网格解降采样到粗网格上。\n\n定义以下具有物理和数值上合理参数的测试套件：\n\n测试案例 A（边值，恒定速度）：\n- 域 $\\Omega = [0,1]^{2}$（单位为 $\\mathrm{m}$）。波速 $c(\\mathbf{x}) = c_{0}$，其中 $c_{0} = 1500$（单位为 $\\mathrm{m/s}$）。粗网格尺寸 $N_{\\text{coarse}} = 101$，细网格尺寸 $N_{\\text{fine}} = 401$。解析解为 $T_{\\text{exact}}(\\mathbf{x}) = \\min\\{x, 1-x, y, 1-y\\}/c_{0}$（单位为 $\\mathrm{s}$），其焦散线（解的不可微点）位于 $x=1/2$ 和 $y=1/2$ 处。在这些线周围定义一个半宽为 $\\delta = 2 h_{\\text{coarse}}$（单位为 $\\mathrm{m}$）的焦散带，并计算粗网格数值解与限制在该带内的 $T_{\\text{exact}}(\\mathbf{x})$ 之间的最大绝对误差（单位为 $\\mathrm{s}$）。\n\n测试案例 B（初值，透镜速度）：\n- 域 $\\Omega = [0,1]^{2}$（单位为 $\\mathrm{m}$）。波速 $c(\\mathbf{x}) = c_{0}\\left(1 - \\alpha \\exp\\left(-\\left(\\frac{(x-0.5)^{2}}{\\sigma_{x}^{2}} + \\frac{(y-0.5)^{2}}{\\sigma_{y}^{2}}\\right)\\right)\\right)$（单位为 $\\mathrm{m/s}$），其中 $c_{0} = 1500$，$\\alpha = 0.4$，$\\sigma_{x} = 0.15$，$\\sigma_{y} = 0.25$，除 $c_{0}$（单位为 $\\mathrm{m/s}$）外均为无量纲；此选择产生一个较慢的中心区域，使射线向内弯曲并产生聚焦。源点位置 $\\mathbf{x}_{s} = (0.2, 0.5)$（单位为 $\\mathrm{m}$）。粗网格尺寸 $N_{\\text{coarse}} = 101$，细网格尺寸 $N_{\\text{fine}} = 401$。在粗网格上构建一个焦散指示掩码，方法是在每个内部网格点 $(i,j)$ 计算量 $a = \\min\\{T_{i-1,j}, T_{i+1,j}\\}$ 和 $b = \\min\\{T_{i,j-1}, T_{i,j+1}\\}$，并选择满足 $|a-b| \\leq \\tau$ 的点，其中 $\\tau = 1.5\\, h_{\\text{coarse}}\\, s_{\\max}$（单位为 $\\mathrm{s}$），$s_{\\max} = \\max_{\\mathbf{x}\\in\\Omega} s(\\mathbf{x})$（单位为 $\\mathrm{s/m}$）。使用降采样到粗网格的细网格解作为参考，并计算此掩码内的最大绝对误差（单位为 $\\mathrm{s}$）。\n\n测试案例 C（边值，透镜速度）：\n- 与测试案例 B 相同的透镜速度和网格尺寸。边界条件为在 $\\Gamma = \\partial\\Omega$ 上 $T|_{\\Gamma} = 0$。根据粗网格解构建与测试案例 B 中相同的焦散指示掩码，并使用降采样的细网格解作为参考，计算此掩码内的最大绝对误差（单位为 $\\mathrm{s}$）。\n\n您的程序必须：\n1. 实现一个与程函方程 $|\\nabla T| = s(\\mathbf{x})$ 一致的、保持因果性的迎风离散化，在每个网格点使用局部二次求解，间距为 $h$（单位为 $\\mathrm{m}$），慢度为 $s(\\mathbf{x})$（单位为 $\\mathrm{s/m}$）。\n2. 使用快速行进法 (FMM) 实现从指定的边界或点源种子的有效波前传播。\n3. 生成三个浮点数输出（单位为 $\\mathrm{s}$），分别对应测试案例 A、B 和 C 在指定焦散掩码内的最大绝对误差。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来的结果（例如，$[r_{A}, r_{B}, r_{C}]$），其中每个 $r_{*}$ 是一个浮点数（单位为 $\\mathrm{s}$）。\n\n角度单位不适用。所有物理量必须采用一致的国际单位制（SI units）处理。程序不得接受任何外部输入，并且必须能够按原样运行。", "solution": "所呈现的问题是计算地球物理学中一个有效且适定的练习。它要求使用快速行进法 (FMM) 对程函方程进行数值求解，并随后在焦散附近的区域进行误差分析。所有参数、方程和方法论都是该领域的标准，并且给出了足够详细和科学严谨的说明。\n\n问题的核心是求解程函方程，它模拟了高频波的走时 $T(\\mathbf{x})$。该方程由下式给出：\n$$\n|\\nabla T(\\mathbf{x})| = s(\\mathbf{x})\n$$\n其中 $\\mathbf{x} = (x,y)$ 是二维域 $\\Omega$ 中的空间位置，$\\nabla T$ 是走时场的梯度，$s(\\mathbf{x}) = 1/c(\\mathbf{x})$ 是介质的慢度，其中 $c(\\mathbf{x})$ 是波速。两边平方得到更常见的非线性偏微分方程 (PDE) 形式：\n$$\n(\\partial_x T)^2 + (\\partial_y T)^2 = s(x,y)^2\n$$\n该方程属于哈密顿-雅可比类型。其解可能会出现奇点（波前的角点和尖点），这对应于走时场 $T(\\mathbf{x})$ 中的不可微点。标准的有限差分格式在这些点会失效。一种稳健的方法是使用迎风离散化，该方法尊重波传播的物理特性，即信息仅从源头向外流动，从走时较小的区域流向走时较大的区域。\n\n我们将域 $\\Omega = [0,1]^2$ 离散化为间距为 $h$ 的均匀网格。令 $T_{i,j}$ 为 $T(ih, jh)$ 的数值近似。一阶迎风、保持因果性的有限差分格式可以写成：\n$$\n\\left( \\max(D_{ix}^{-}T, -D_{ix}^{+}T, 0) \\right)^2 + \\left( \\max(D_{jy}^{-}T, -D_{jy}^{+}T, 0) \\right)^2 = s_{i,j}^2\n$$\n其中，例如，$D_{ix}^{-}T = (T_{i,j} - T_{i-1,j})/h$ 是后向差分算子。这个看起来复杂的公式在根据其邻居求解 $T_{i,j}$ 时会得到简化。假设波前从走时已知且最小的方向传播到点 $(i,j)$，令 $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$ 分别为 $x$ 和 $y$ 方向上邻居中的最小已知走时。那么 $T_{i,j}$ 的更新由以下二次方程决定：\n$$\n\\left( \\frac{T_{i,j} - T_x}{h} \\right)^2 + \\left( \\frac{T_{i,j} - T_y}{h} \\right)^2 = s_{i,j}^2\n$$\n这个方程仅在两项都有贡献时才有效，即 $T_{i,j} > T_x$ 和 $T_{i,j} > T_y$。整理后得到一个关于 $T \\equiv T_{i,j}$ 的二次方程：$aT^2 + bT + c = 0$，其中 $a=2$，$b=-2(T_x+T_y)$，$c=T_x^2+T_y^2 - (hs_{i,j})^2$。我们取较大的根，对应于扩张的波前：\n$$\nT = \\frac{T_x + T_y + \\sqrt{2(hs_{i,j})^2 - (T_x-T_y)^2}}{2}\n$$\n此更新仅在判别式非负且得到的 $T$ 大于 $T_x$ 和 $T_y$ 时有效。如果这些条件不满足，则意味着特征方向与一个轴对齐，更新简化为从走时最小的邻居进行一维传播。假设 $T_x \\le T_y$，更新变为 $T = T_x + hs_{i,j}$。\n\n快速行进法 (FMM) 是一种高效的算法，它以正确的顺序求解离散化的程函方程，模拟波前的物理传播。它使用一个最小优先队列来系统地推进波前。网格点被分为三类：\n1.  **冻结 (或已接受):** 走时 $T$ 已最终确定的点。\n2.  **窄带 (或试验):** 冻结点的邻居，已为其计算出 tentative travel time。\n3.  **远方:** 所有其他点，其 $T = \\infty$。\n\nFMM 算法按以下步骤进行：\n1.  **初始化:** 将所有点的 $T$ 初始化为 $\\infty$，除了源点（在边界 $\\Gamma$ 上或在源位置 $\\mathbf{x}_s$）设置为 $T=0$。所有非无穷大的点都被添加到一个最小优先队列（“窄带”）中。\n2.  **迭代:**\n    a. 从优先队列中提取具有最小走时的点 $(i,j)$。\n    b. 将此点标记为“冻结”。\n    c. 对于 $(i,j)$ 的每个未被“冻结”的邻居 $(ni, nj)$：\n        i. 使用上面描述的二次更新规则，利用“冻结”邻居的值（包括新冻结的点 $(i,j)$）来计算一个新的试验走时。\n        ii. 如果这个新时间小于邻居当前的时间，则更新邻居的时间，并将其添加/更新到优先队列中。\n3.  **终止:** 当优先队列为空时，算法终止。\n\n这个过程确保了点是按照走时递增的顺序处理的，正确地捕捉了程函方程的粘性解。\n\n该解决方案将作为一个单一的 Python 脚本实现。一个核心函数 `fmm_solver` 将实现 FMM 算法。对于每个测试案例，将使用适当的网格尺寸（$N_{\\text{coarse}} = 101$，$N_{\\text{fine}} = 401$）和慢度模型调用此函数。\n\n**测试案例 A（边值，恒定速度）：**\n在粗网格上运行 FMM，其中 $c(\\mathbf{x}) = 1500$ m/s（$s = 1/1500$ s/m），边界条件为 $T|_{\\partial\\Omega}=0$。将得到的数值解 $T_{\\text{num}}$ 与解析解 $T_{\\text{exact}}(\\mathbf{x}) = \\min\\{x, 1-x, y, 1-y\\}/c_{0}$ 进行比较。误差在围绕直线 $x=1/2$ 和 $y=1/2$ 的半宽为 $\\delta = 2 h_{\\text{coarse}}$ 的焦散带内计算。\n\n**测试案例 B（初值，透镜速度）：**\n引入了一个透镜状的速度异常体。在粗网格和细网格上运行 FMM，源点为单个点 $\\mathbf{x}_s=(0.2, 0.5)$。细网格解 $T_{\\text{fine}}$ 被降采样以作为高保真参考解 $T_{\\text{ref}}$。通过识别粗网格上波前从水平和垂直方向几乎同时到达的点，即 $|\\min(T_{i-1,j}, T_{i+1,j}) - \\min(T_{i,j-1}, T_{i,j+1})| \\le \\tau$（其中 $\\tau$ 是一个小的阈值），来算法生成一个焦散掩码。然后在此掩码内计算最大绝对误差 $|T_{\\text{coarse}} - T_{\\text{ref}}|$。\n\n**测试案例 C（边值，透镜速度）：**\n此案例与测试案例 B 类似，但使用边界条件 $T|_{\\partial\\Omega}=0$ 而不是点源。生成粗解和细解、从粗解构建焦散掩码以及计算误差的过程与测试案例 B 相同。\n\n最终输出将是为每个测试案例计算的三个最大绝对误差值的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def fmm_solver(slowness_grid, h, seeds):\n        \"\"\"\n        Solves the eikonal equation using the Fast Marching Method.\n\n        Args:\n            slowness_grid (np.ndarray): 2D array of slowness values s(x,y).\n            h (float): Grid spacing.\n            seeds (list): A list of tuples (i, j, value) for initial points.\n\n        Returns:\n            np.ndarray: 2D array of travel times T(x,y).\n        \"\"\"\n        n = slowness_grid.shape[0]\n        travel_times = np.full((n, n), np.inf, dtype=np.float64)\n        # States: 0=Far, 1=Trial, 2=Accepted\n        states = np.zeros((n, n), dtype=np.int8)\n        pq = []\n\n        for i, j, val in seeds:\n            travel_times[i, j] = val\n            states[i, j] = 1  # Trial\n            heapq.heappush(pq, (val, i, j))\n\n        while pq:\n            t, i, j = heapq.heappop(pq)\n            \n            if states[i, j] == 2:\n                continue\n            \n            states[i, j] = 2  # Accepted\n\n            # Process neighbors\n            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 = ni  n and 0 = nj  n and states[ni, nj] != 2:\n                    \n                    # Find min travel times from accepted neighbors in each direction\n                    tx_min = np.inf\n                    if ni > 0 and states[ni - 1, nj] == 2:\n                        tx_min = min(tx_min, travel_times[ni - 1, nj])\n                    if ni  n - 1 and states[ni + 1, nj] == 2:\n                        tx_min = min(tx_min, travel_times[ni + 1, nj])\n\n                    ty_min = np.inf\n                    if nj > 0 and states[ni, nj - 1] == 2:\n                        ty_min = min(ty_min, travel_times[ni, nj - 1])\n                    if nj  n - 1 and states[ni, nj + 1] == 2:\n                        ty_min = min(ty_min, travel_times[ni, nj + 1])\n                    \n                    # Solve for updated time\n                    s_val = slowness_grid[ni, nj]\n                    t_neighbors = sorted([v for v in [tx_min, ty_min] if v != np.inf])\n\n                    if not t_neighbors:\n                        continue \n                    \n                    t_new = np.inf\n                    if len(t_neighbors) == 1:\n                        t1 = t_neighbors[0]\n                        t_new = t1 + h * s_val\n                    else: # len == 2\n                        t1, t2 = t_neighbors[0], t_neighbors[1]\n                        \n                        # Quadratic solver for 2D update\n                        a = 2.0\n                        b = -2.0 * (t1 + t2)\n                        c = t1**2 + t2**2 - (h * s_val)**2\n                        \n                        discriminant = b**2 - 4 * a * c\n                        \n                        if discriminant >= 0:\n                            t_quad = (-b + np.sqrt(discriminant)) / (2.0 * a)\n                            if t_quad > t2:\n                                t_new = t_quad\n                            else:\n                                # Fallback to 1D update\n                                t_new = t1 + h * s_val\n                        else:\n                            # Fallback to 1D update\n                            t_new = t1 + h * s_val\n\n                    if t_new  travel_times[ni, nj]:\n                        travel_times[ni, nj] = t_new\n                        states[ni, nj] = 1 # Trial\n                        heapq.heappush(pq, (t_new, ni, nj))\n\n        return travel_times\n\n    def run_case_a():\n        N_coarse = 101\n        c0 = 1500.0\n        s0 = 1.0 / c0\n        h_coarse = 1.0 / (N_coarse - 1)\n\n        slowness = np.full((N_coarse, N_coarse), s0, dtype=np.float64)\n        \n        seeds = []\n        for i in range(N_coarse):\n            seeds.append((i, 0, 0.0))\n            seeds.append((i, N_coarse - 1, 0.0))\n        for j in range(1, N_coarse - 1):\n            seeds.append((0, j, 0.0))\n            seeds.append((N_coarse - 1, j, 0.0))\n        \n        t_numerical = fmm_solver(slowness, h_coarse, seeds)\n\n        x = np.linspace(0, 1, N_coarse)\n        y = np.linspace(0, 1, N_coarse)\n        xx, yy = np.meshgrid(x, y)\n        \n        t_exact = np.minimum(np.minimum(xx, 1-xx), np.minimum(yy, 1-yy)) * s0\n        \n        delta = 2 * h_coarse\n        caustic_mask = (np.abs(xx - 0.5) = delta) | (np.abs(yy - 0.5) = delta)\n        \n        error = np.abs(t_numerical.T - t_exact)\n        max_error_in_mask = np.max(error[caustic_mask])\n        \n        return max_error_in_mask\n\n    def run_case_b():\n        N_coarse, N_fine = 101, 401\n        h_coarse, h_fine = 1.0 / (N_coarse - 1), 1.0 / (N_fine - 1)\n\n        c0, alpha, sx, sy = 1500.0, 0.4, 0.15, 0.25\n        source_loc = (0.2, 0.5)\n\n        def speed_func(x, y):\n            return c0 * (1 - alpha * np.exp(-((x - 0.5)**2 / sx**2 + (y - 0.5)**2 / sy**2)))\n\n        # Coarse grid run\n        x_c = np.linspace(0, 1, N_coarse)\n        y_c = np.linspace(0, 1, N_coarse)\n        xx_c, yy_c = np.meshgrid(x_c, y_c, indexing='ij')\n        s_coarse = 1.0 / speed_func(xx_c, yy_c)\n        \n        source_idx_c = (np.abs(x_c - source_loc[0])).argmin(), (np.abs(y_c - source_loc[1])).argmin()\n        t_coarse = fmm_solver(s_coarse, h_coarse, [(source_idx_c[0], source_idx_c[1], 0.0)])\n        \n        # Fine grid run (reference)\n        x_f = np.linspace(0, 1, N_fine)\n        y_f = np.linspace(0, 1, N_fine)\n        xx_f, yy_f = np.meshgrid(x_f, y_f, indexing='ij')\n        s_fine = 1.0 / speed_func(xx_f, yy_f)\n        \n        source_idx_f = (np.abs(x_f - source_loc[0])).argmin(), (np.abs(y_f - source_loc[1])).argmin()\n        t_fine = fmm_solver(s_fine, h_fine, [(source_idx_f[0], source_idx_f[1], 0.0)])\n        \n        # Downsample fine to coarse\n        scale = (N_fine - 1) // (N_coarse - 1)\n        t_ref = np.zeros_like(t_coarse)\n        for i in range(N_coarse):\n            for j in range(N_coarse):\n                t_ref[i, j] = t_fine[i * scale, j * scale]\n\n        # Caustic mask on coarse grid\n        s_max = np.max(s_coarse)\n        tau = 1.5 * h_coarse * s_max\n        caustic_mask = np.zeros((N_coarse, N_coarse), dtype=bool)\n        for i in range(1, N_coarse - 1):\n            for j in range(1, N_coarse - 1):\n                a = min(t_coarse[i - 1, j], t_coarse[i + 1, j])\n                b = min(t_coarse[i, j - 1], t_coarse[i, j + 1])\n                if abs(a - b) = tau:\n                    caustic_mask[i, j] = True\n        \n        error = np.abs(t_coarse - t_ref)\n        if np.any(caustic_mask):\n            max_error_in_mask = np.max(error[caustic_mask])\n        else: # If mask is empty, problem implies there should be a result.\n            max_error_in_mask = 0.0\n\n        return max_error_in_mask\n\n    def run_case_c():\n        N_coarse, N_fine = 101, 401\n        h_coarse, h_fine = 1.0 / (N_coarse - 1), 1.0 / (N_fine - 1)\n\n        c0, alpha, sx, sy = 1500.0, 0.4, 0.15, 0.25\n\n        def speed_func(x, y):\n            return c0 * (1 - alpha * np.exp(-((x - 0.5)**2 / sx**2 + (y - 0.5)**2 / sy**2)))\n\n        # Coarse grid run\n        x_c = np.linspace(0, 1, N_coarse)\n        y_c = np.linspace(0, 1, N_coarse)\n        xx_c, yy_c = np.meshgrid(x_c, y_c, indexing='ij')\n        s_coarse = 1.0 / speed_func(xx_c, yy_c)\n        \n        seeds_c = []\n        for i in range(N_coarse):\n            seeds_c.extend([(i, 0, 0.0), (i, N_coarse - 1, 0.0)])\n        for j in range(1, N_coarse - 1):\n            seeds_c.extend([(0, j, 0.0), (N_coarse - 1, j, 0.0)])\n        t_coarse = fmm_solver(s_coarse, h_coarse, seeds_c)\n        \n        # Fine grid run (reference)\n        x_f = np.linspace(0, 1, N_fine)\n        y_f = np.linspace(0, 1, N_fine)\n        xx_f, yy_f = np.meshgrid(x_f, y_f, indexing='ij')\n        s_fine = 1.0 / speed_func(xx_f, yy_f)\n        \n        seeds_f = []\n        for i in range(N_fine):\n            seeds_f.extend([(i, 0, 0.0), (i, N_fine - 1, 0.0)])\n        for j in range(1, N_fine - 1):\n            seeds_f.extend([(0, j, 0.0), (N_fine - 1, j, 0.0)])\n        t_fine = fmm_solver(s_fine, h_fine, seeds_f)\n        \n        # Downsample fine to coarse\n        scale = (N_fine - 1) // (N_coarse - 1)\n        t_ref = np.zeros_like(t_coarse)\n        for i in range(N_coarse):\n            for j in range(N_coarse):\n                t_ref[i, j] = t_fine[i * scale, j * scale]\n\n        # Caustic mask on coarse grid\n        s_max = np.max(s_coarse)\n        tau = 1.5 * h_coarse * s_max\n        caustic_mask = np.zeros((N_coarse, N_coarse), dtype=bool)\n        for i in range(1, N_coarse - 1):\n            for j in range(1, N_coarse - 1):\n                a = min(t_coarse[i - 1, j], t_coarse[i + 1, j])\n                b = min(t_coarse[i, j - 1], t_coarse[i, j + 1])\n                if abs(a - b) = tau:\n                    caustic_mask[i, j] = True\n        \n        error = np.abs(t_coarse - t_ref)\n        if np.any(caustic_mask):\n            max_error_in_mask = np.max(error[caustic_mask])\n        else:\n            max_error_in_mask = 0.0\n\n        return max_error_in_mask\n\n    result_a = run_case_a()\n    result_b = run_case_b()\n    result_c = run_case_c()\n    \n    results = [result_a, result_b, result_c]\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3578554"}, {"introduction": "在大型、真实的地址模型上求解波动方程是一项计算量巨大的任务，通常需要并行计算。本练习介绍了一种强大的高性能计算技术：重叠型 Schwarz 区域分解法。你将学习如何将一个大问题划分为多个可管理的子问题，并使用基于物理特征的传输条件在人工边界上正确交换信息，从而实现声波方程组的高效并行求解。[@problem_id:3578593]", "problem": "您需要为一维声学初边值问题（IBVP）实现一个双子区域重叠型 Schwarz 方法，并在重叠界面处使用基于特征变量的传输条件。该问题由线性化的质量和动量守恒导出，其控制一阶方程组如下：\n$$\n\\partial_t p(x,t) + \\kappa \\,\\partial_x v(x,t) = 0, \\quad \\partial_t v(x,t) + \\frac{1}{\\rho}\\,\\partial_x p(x,t) = 0,\n$$\n其中 $p(x,t)$ 是声压（单位：$\\mathrm{Pa}$），$v(x,t)$ 是质点速度（单位：$\\mathrm{m/s}$），$\\rho$ 是密度（单位：$\\mathrm{kg/m^3}$），$\\kappa$ 是体积模量（单位：$\\mathrm{Pa}$）。声波以速度 $c=\\sqrt{\\kappa/\\rho}$（单位：$\\mathrm{m/s}$）传播，其声阻抗为 $Z=\\rho c$（单位：$\\mathrm{Pa\\cdot s/m}$）。\n\n该双曲系统的特征变量为\n$$\nw_+(x,t) = p(x,t) + Z\\,v(x,t), \\quad w_-(x,t) = p(x,t) - Z\\,v(x,t),\n$$\n它们满足以下输运方程\n$$\n\\partial_t w_+(x,t) + c\\,\\partial_x w_+(x,t) = 0, \\quad \\partial_t w_-(x,t) - c\\,\\partial_x w_-(x,t) = 0.\n$$\n在物理域边界 $x=0$ 和 $x=L$ 处，使用以入射特征表示的吸收边界条件：\n$$\nw_+(0,t) = 0 \\quad \\text{and} \\quad w_-(L,t) = 0.\n$$\n\n您必须将空间域 $[0,L]$ 分割为两个重叠子区域 $\\Omega_1 = [0, x_m + \\delta]$ 和 $\\Omega_2 = [x_m - \\delta, L]$，其中 $x_m=L/2$，重叠半宽度为 $\\delta>0$。设重叠区域由固定数量的网格点 $o\\in\\mathbb{N}$ 定义，因此 $2\\delta = 2 o\\,\\Delta x$，其中 $\\Delta x$ 是网格间距。在每个时间步，执行内 Schwarz 迭代。在迭代中，每个子区域求解离散化的 IBVP，其传输条件通过将入射特征设置为同一物理位置上相邻区域的出射特征来施加。具体来说，如果 $x_{\\mathrm{LB}}$ 表示 $\\Omega_1$ 的右边界，$x_{\\mathrm{RB}}$ 表示 $\\Omega_2$ 的左边界，则在内迭代第 $m$ 次和时间层 $t_n$ 上施加\n$$\nw_-^{(m+1)}(x_{\\mathrm{LB}}, t_n) = w_-^{(m)}_{\\Omega_2}(x_{\\mathrm{LB}}, t_n), \\quad w_+^{(m+1)}(x_{\\mathrm{RB}}, t_n) = w_+^{(m)}_{\\Omega_1}(x_{\\mathrm{RB}}, t_n).\n$$\n将这些特征等式转换为您的有限差分离散所需的鬼点值。\n\n使用交错显式格式在均匀网格上离散该系统：将 $p$ 存储在整网格点上，$v$ 存储在半网格点上，并使用以下更新格式\n$$\nv^{n+\\frac{1}{2}}_{i+\\frac{1}{2}} = v^{n-\\frac{1}{2}}_{i+\\frac{1}{2}} - \\frac{\\Delta t}{\\rho\\,\\Delta x}\\big(p^n_{i+1} - p^n_i\\big),\n$$\n$$\np^{n+1}_i = p^n_i - \\frac{\\Delta t\\,\\kappa}{\\Delta x}\\big(v^{n+\\frac{1}{2}}_{i+\\frac{1}{2}} - v^{n+\\frac{1}{2}}_{i-\\frac{1}{2}}\\big).\n$$\n使用吸收和传输条件，通过以下方式在子区域边界提供鬼点 $v$ 值\n$$\n\\text{左侧物理边界： } w_+(0,t)=0 \\Rightarrow v_{-\\frac{1}{2}} = -\\frac{p_0}{Z}, \\quad\n\\text{右侧物理边界： } w_-(L,t)=0 \\Rightarrow v_{N-\\frac{1}{2}} = \\frac{p_{N-1}}{Z},\n$$\n以及，在重叠边界处，\n$$\n\\text{对于 }\\Omega_1\\text{ 在 }x_{\\mathrm{LB}}\\text{ 处：} \\quad v_{i_{\\mathrm{LB}}+\\frac{1}{2}} = \\frac{p_{i_{\\mathrm{LB}}} - w_-^{\\mathrm{in}}}{Z}, \\quad\n\\text{对于 }\\Omega_2\\text{ 在 }x_{\\mathrm{RB}}\\text{ 处：} \\quad v_{i_{\\mathrm{RB}}-\\frac{1}{2}} = \\frac{w_+^{\\mathrm{in}} - p_{i_{\\mathrm{RB}}}}{Z}.\n$$\n通过将交错速度平均到压力节点，使用同位值在每个子区域内所需的重叠位置上定义出射特征：\n$$\nv_i^{\\text{node}} \\approx \\frac{1}{2}\\left(v_{i+\\frac{1}{2}} + v_{i-\\frac{1}{2}}\\right), \\quad\nw_+ \\approx p_i + Z\\,v_i^{\\text{node}}, \\quad w_- \\approx p_i - Z\\,v_i^{\\text{node}}.\n$$\n\n使用以下初始条件初始化 IBVP\n$$\np(x,0) = A\\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right), \\quad v(x,0)=0,\n$$\n其中 $A$ 是振幅（单位：$\\mathrm{Pa}$），$x_0$ 是中心位置（单位：$\\mathrm{m}$），$\\sigma$ 是宽度（单位：$\\mathrm{m}$）。在每个时间步的 Schwarz 迭代中，使用限制在各个子区域上的相同初始数据。\n\n您的程序必须：\n- 实现上述格式，在每个时间步执行内 Schwarz 迭代，直到传输特征的变化量低于容差 $\\varepsilon$ 或达到最大内迭代次数。通过连续内迭代之间传输特征的最大绝对变化来量化内迭代的变化。\n- 对于每个指定的重叠宽度 $o$，在固定的时间步数内运行模拟，并报告达到容差所需的每时间步平均内迭代次数，结果四舍五入到三位小数。\n\n物理和数值参数：\n- 区域长度：$L = 1000\\,\\mathrm{m}$。\n- 密度：$\\rho = 2000\\,\\mathrm{kg/m^3}$。\n- 波速：$c = 2000\\,\\mathrm{m/s}$。\n- 体积模量：$\\kappa = \\rho c^2$。\n- 声阻抗：$Z = \\rho c$。\n- 压力网格点数：$N = 201$，因此 $\\Delta x = \\frac{L}{N-1}$。\n- 时间步长：$\\Delta t = 0.4\\,\\frac{\\Delta x}{c}$。\n- 时间步数：$N_t = 80$。\n- 初始条件参数：$A = 1\\,\\mathrm{Pa}$，$x_0 = L/3$，$\\sigma = 0.05\\,L$。\n- 内迭代容差：$\\varepsilon = 10^{-8}$。\n- 每时间步最大内迭代次数：$M_{\\max} = 50$。\n\n测试套件（每个案例对应一个不同的重叠半宽度 $o$，以网格点数为单位）：\n- 案例 1：$o=1$。\n- 案例 2：$o=5$。\n- 案例 3：$o=20$。\n- 案例 4：$o=45$。\n\n对于每个案例，您的程序必须输出所有时间步的平均内迭代次数，格式为浮点数。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”）。输出值中不应包含任何单位。结果必须按照测试套件案例的顺序排列。", "solution": "用户提供的问题陈述已经过评估，被认为是有效的。它具有科学依据，是适定的、客观的，并包含构建唯一解的充分信息。现在开始阐述和实施解决方案。\n\n该问题要求为一维声波方程实现一个重叠型 Schwarz 区域分解法。该方法基于在区域分割产生的人工边界上交换特征变量。总体算法通过对问题进行时间离散化，并在每个时间步中，在推进求解之前迭代求解传输边界条件。\n\n控制方程构成了一个关于声压 $p(x,t)$ 和质点速度 $v(x,t)$ 的一阶双曲系统：\n$$\n\\partial_t p + \\kappa \\,\\partial_x v = 0\n$$\n$$\n\\partial_t v + \\frac{1}{\\rho}\\,\\partial_x p = 0\n$$\n其中 $\\rho$ 是密度，$\\kappa$ 是体积模量， $c = \\sqrt{\\kappa/\\rho}$ 是波速， $Z = \\rho c$ 是声阻抗。该系统使用交错网格有限差分格式（蛙跳格式）进行离散化：\n$$\nv^{n+\\frac{1}{2}}_{i+\\frac{1}{2}} = v^{n-\\frac{1}{2}}_{i+\\frac{1}{2}} - \\frac{\\Delta t}{\\rho\\,\\Delta x}\\left(p^n_{i+1} - p^n_i\\right)\n$$\n$$\np^{n+1}_i = p^n_i - \\frac{\\Delta t\\,\\kappa}{\\Delta x}\\left(v^{n+\\frac{1}{2}}_{i+\\frac{1}{2}} - v^{n+\\frac{1}{2}}_{i-\\frac{1}{2}}\\right)\n$$\n在此，压力 $p_i^n$ 定义在网格点 $x_i = i\\Delta x$ 和时间层 $t_n = n\\Delta t$ 上，而速度 $v_{i+1/2}^{n+1/2}$ 定义在交错网格点 $x_{i+1/2} = (i+1/2)\\Delta x$ 和半整数时间层 $t_{n+1/2} = (n+1/2)\\Delta t$ 上。\n\n空间域 $[0, L]$ 被划分为两个重叠子区域：$\\Omega_1 = [0, x_m + \\delta]$ 和 $\\Omega_2 = [x_m - \\delta, L]$，其中 $x_m = L/2$ 是中点，$\\delta = o\\Delta x$ 是由 $o$ 个网格单元定义的重叠半宽度。在每个时间步 $t_n$，我们在人工边界 $x_{\\mathrm{RB}} = x_m - \\delta$ （$\\Omega_2$ 的左边界）和 $x_{\\mathrm{LB}} = x_m + \\delta$ （$\\Omega_1$ 的右边界）上求解传输条件。这是通过一个内迭代过程（Schwarz 迭代）实现的。\n\n从 $t_n$ 到 $t_{n+1}$ 的单个时间步算法如下：\n\n1.  **初始化 Schwarz 迭代**：在时间步开始时，我们在两个子区域上都拥有场量 $p^n$ 和 $v^{n-1/2}$。我们初始化入射特征变量，即 $\\Omega_2$ 的 $w_{+}^{\\mathrm{in}}$ 和 $\\Omega_1$ 的 $w_{-}^{\\mathrm{in}}$，通常使用它们在前一个时间步的收敛值，或者在第一步时设为零。\n\n2.  **内迭代循环**：我们进行迭代，直到传输特征的变化量低于容差 $\\varepsilon$ 或达到最大迭代次数 $M_{\\max}$。在每次内迭代 $m$ 中：\n    a.  **计算出射特征**：基于时间 $t_n$ 的状态（即使用 $p^n$ 和 $v^{n-1/2}$），每个子区域在相关的通信边界上计算其出射特征。问题指定了一种局部平均交错速度的方法来获得用于此计算的节点速度：\n        $$\n        v_i^{\\text{node}}(t_n) \\approx \\frac{1}{2}\\left(v_{i+\\frac{1}{2}}^{n-\\frac{1}{2}} + v_{i-\\frac{1}{2}}^{n-\\frac{1}{2}}\\right)\n        $$\n        出射特征则为：\n        -   来自 $\\Omega_1$ 在 $x_{\\mathrm{RB}}$ 处： $w_{+, \\text{out}} = p_1^n(x_{\\mathrm{RB}}) + Z v_{1, \\text{node}}^n(x_{\\mathrm{RB}})$\n        -   来自 $\\Omega_2$ 在 $x_{\\mathrm{LB}}$ 处： $w_{-, \\text{out}} = p_2^n(x_{\\mathrm{LB}}) - Z v_{2, \\text{node}}^n(x_{\\mathrm{LB}})$\n    b.  **交换数据 (Jacobi 更新)**：下一次迭代的入射特征用刚刚计算出的出射特征进行更新：\n        $$\n        w_{+, \\text{new}}^{\\mathrm{in}} = w_{+, \\text{out}} \\quad (\\text{对于 } \\Omega_2)\n        $$\n        $$\n        w_{-, \\text{new}}^{\\mathrm{in}} = w_{-, \\text{out}} \\quad (\\text{对于 } \\Omega_1)\n        $$\n    c.  **检查收敛性**：收敛准则应用于入射特征值的变化：\n        $$\n        \\max\\left(\\left|w_{+, \\text{new}}^{\\mathrm{in}} - w_{+, \\text{old}}^{\\mathrm{in}}\\right|, \\left|w_{-, \\text{new}}^{\\mathrm{in}} - w_{-, \\text{old}}^{\\mathrm{in}}\\right|\\right)  \\varepsilon\n        $$\n    d.  更新下一次内迭代的特征值，如果未收敛则继续循环。\n\n3.  **时间步推进**：一旦内迭代收敛（或超时），$w_{+}^{\\mathrm{in}}$ 和 $w_{-}^{\\mathrm{in}}$ 的最终值将被用来计算每个子区域时间步进所需的鬼点速度值。\n    -   对于 $\\Omega_1$，在 $x=0$ 处的物理（吸收）边界条件是 $v_{-1/2}^{n+1/2} = -p_0^n/Z$。在 $x=x_{\\mathrm{LB}}$ 处的传输条件提供了鬼点值： $v_{i_{\\mathrm{LB}}+1/2}^{n+1/2} = (p_{i_{\\mathrm{LB}}}^n - w_{-}^{\\mathrm{in}})/Z$。\n    -   对于 $\\Omega_2$，在 $x=x_{\\mathrm{RB}}$ 处的传输条件提供了鬼点值： $v_{i_{\\mathrm{RB}}-1/2}^{n+1/2} = (w_{+}^{\\mathrm{in}} - p_{i_{\\mathrm{RB}}}^n)/Z$。在 $x=L$ 处的物理边界条件是 $v_{N-1/2}^{n+1/2} = p_{N-1}^n/Z$。\n    -   利用这些边界数据，两个子区域上的场量被并行推进，以获得 $p_1^{n+1}, v_1^{n+1/2}$ 和 $p_2^{n+1}, v_2^{n+1/2}$。\n\n4.  **重复**：对指定的时间步数 $N_t$ 重复此过程。对于每个指定的重叠宽度 $o$，记录每时间步的平均内迭代次数。\n\n初始条件 $v(x,0)=0$ 的处理方式是将初始半时间步（即 $n=0$ 时的 $v^{n-1/2}$）的速度场设置为零，即 $v_{i+1/2}^{-1/2} = 0$。\n\n该实现将使用给定的物理和数值参数集，并对测试套件中每个重叠宽度 $o$ 的值进行模拟。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a two-subdomain overlapping Schwarz method for the 1D acoustic\n    Initial Boundary Value Problem (IBVP) using characteristic-variable-based\n    transmission conditions.\n    \"\"\"\n    \n    # --- Physical and numerical parameters ---\n    L = 1000.0  # Domain length (m)\n    rho = 2000.0  # Density (kg/m^3)\n    c = 2000.0  # Wave speed (m/s)\n    N_p_total = 201  # Number of pressure grid points in total domain\n    N_t = 80  # Number of time steps\n    A = 1.0  # Initial pressure amplitude (Pa)\n    x0 = L / 3.0  # Center of initial Gaussian\n    sigma = 0.05 * L  # Width of initial Gaussian\n    epsilon = 1e-8  # Inner iteration tolerance\n    M_max = 50  # Maximum inner iterations\n\n    # --- Derived parameters ---\n    kappa = rho * c**2\n    Z = rho * c\n    dx = L / (N_p_total - 1)\n    dt = 0.4 * dx / c\n    i_mid = (N_p_total - 1) // 2\n\n    # Test cases for overlap half-width in grid points\n    test_cases = [1, 5, 20, 45]\n    results = []\n\n    for o in test_cases:\n        # --- Subdomain Setup ---\n        # Subdomain 1 (left)\n        N_p1 = i_mid + o + 1\n        x1 = np.linspace(0.0, (i_mid + o) * dx, N_p1)\n        p1 = A * np.exp(-((x1 - x0)**2) / (2 * sigma**2))\n        v1_nmhalf = np.zeros(N_p1 - 1)\n\n        # Subdomain 2 (right)\n        N_p2 = (N_p_total - 1) - (i_mid - o) + 1\n        x2_start_idx = i_mid - o\n        x2 = np.linspace(x2_start_idx * dx, L, N_p2)\n        p2 = A * np.exp(-((x2 - x0)**2) / (2 * sigma**2))\n        v2_nmhalf = np.zeros(N_p2 - 1)\n        \n        # --- Communication Indices Setup ---\n        # For Omega_2 to send w- to Omega_1's right boundary (x_LB)\n        # Global p-index: i_mid + o\n        # Local p-index in Omega_2 grid: (i_mid + o) - (i_mid - o) = 2*o\n        comm_idx_d2 = 2 * o\n        \n        # For Omega_1 to send w+ to Omega_2's left boundary (x_RB)\n        # Global p-index: i_mid - o\n        # Local p-index in Omega_1 grid: i_mid - o\n        comm_idx_d1 = i_mid - o\n\n        # Schwarz iteration variables\n        w_minus_in = 0.0  # Incoming characteristic for Omega_1\n        w_plus_in = 0.0   # Incoming characteristic for Omega_2\n        total_inner_iters = 0\n\n        # --- Time Stepping Loop ---\n        for n in range(N_t):\n            inner_iter_count = 0\n            \n            # --- Inner Schwarz Loop (to converge transmission conditions) ---\n            for m in range(M_max):\n                inner_iter_count += 1\n                w_minus_in_old = w_minus_in\n                w_plus_in_old = w_plus_in\n\n                # Calculate outgoing characteristics (Jacobi-style exchange)\n                # Note: p is at t_n, v is at t_{n-1/2}.\n                # The nodal velocity v_node(t_n) is approximated using v(t_{n-1/2}).\n                \n                # Omega_2 computes its outgoing w- at x_LB\n                # v_node is at local index comm_idx_d2\n                v2_node_comm = 0.5 * (v2_nmhalf[comm_idx_d2] + v2_nmhalf[comm_idx_d2 - 1])\n                w_minus_in = p2[comm_idx_d2] - Z * v2_node_comm\n\n                # Omega_1 computes its outgoing w+ at x_RB\n                # v_node is at local index comm_idx_d1\n                v1_node_comm = 0.5 * (v1_nmhalf[comm_idx_d1] + v1_nmhalf[comm_idx_d1 - 1])\n                w_plus_in = p1[comm_idx_d1] + Z * v1_node_comm\n\n                # Check convergence of the exchanged characteristic values\n                change = max(abs(w_minus_in - w_minus_in_old), abs(w_plus_in - w_plus_in_old))\n                if change  epsilon:\n                    break\n            \n            total_inner_iters += inner_iter_count\n\n            # --- Evolve Subdomains by one time step using converged BCs ---\n            \n            # Subdomain 1\n            v1_nhalf = v1_nmhalf - (dt / (rho * dx)) * (p1[1:] - p1[:-1])\n            p1_new = np.zeros_like(p1)\n            \n            ghost_v_left1 = -p1[0] / Z  # Physical Absorbing BC at x=0\n            ghost_v_right1 = (p1[-1] - w_minus_in) / Z # Transmission Condition\n            \n            p1_new[0] = p1[0] - (dt * kappa / dx) * (v1_nhalf[0] - ghost_v_left1)\n            p1_new[1:-1] = p1[1:-1] - (dt * kappa / dx) * (v1_nhalf[1:] - v1_nhalf[:-1])\n            p1_new[-1] = p1[-1] - (dt * kappa / dx) * (ghost_v_right1 - v1_nhalf[-1])\n            \n            # Subdomain 2\n            v2_nhalf = v2_nmhalf - (dt / (rho * dx)) * (p2[1:] - p2[:-1])\n            p2_new = np.zeros_like(p2)\n            \n            ghost_v_left2 = (w_plus_in - p2[0]) / Z # Transmission Condition\n            ghost_v_right2 = p2[-1] / Z # Physical Absorbing BC at x=L\n\n            p2_new[0] = p2[0] - (dt * kappa / dx) * (v2_nhalf[0] - ghost_v_left2)\n            p2_new[1:-1] = p2[1:-1] - (dt * kappa / dx) * (v2_nhalf[1:] - v2_nhalf[:-1])\n            p2_new[-1] = p2[-1] - (dt * kappa / dx) * (ghost_v_right2 - v2_nhalf[-1])\n\n            # Update fields for the next time step\n            p1, v1_nmhalf = p1_new, v1_nhalf\n            p2, v2_nmhalf = p2_new, v2_nhalf\n\n        # Calculate and store the average number of iterations for this case\n        avg_iters = total_inner_iters / N_t\n        results.append(round(avg_iters, 3))\n    \n    # Print the results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3578593"}]}