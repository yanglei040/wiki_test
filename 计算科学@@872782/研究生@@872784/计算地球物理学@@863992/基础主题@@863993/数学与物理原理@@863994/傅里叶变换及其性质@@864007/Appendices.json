{"hands_on_practices": [{"introduction": "高斯函数在傅里叶分析中占有特殊的地位，因为它的傅里叶变换形式仍然是高斯函数。这个练习旨在通过分析方法，练习二维傅里叶积分的计算，并建立对空间域中的尺度参数（各向异性）如何反映为频率域中尺度反转（协方差）的直观理解。掌握这一基本性质，对于深刻理解空间滤波、分辨率和平滑等概念至关重要。[@problem_id:3598065]", "problem": "在沉积盆地非均质性的空间建模中，一个常见的平滑核是在平面上定义的各向异性高斯函数 $f(x,y) = \\exp(-a x^{2} - b y^{2})$，其中 $a0$ 且 $b0$。考虑计算地球物理学中用于空间波数的连续二维傅里叶变换对：\n$$F(k_{x},k_{y}) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(x,y) \\,\\exp\\!\\big(-\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}x\\,\\mathrm{d}y,$$\n及其逆变换\n$$f(x,y) = \\frac{1}{(2\\pi)^{2}} \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} F(k_{x},k_{y}) \\,\\exp\\!\\big(\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}k_{x}\\,\\mathrm{d}k_{y}.$$\n从这些定义出发，并仅假设高斯积分对于正二次系数收敛这一经过充分检验的事实，完成以下任务：\n1) 推导 $f(x,y)$ 的二维傅里叶变换 $F(k_{x},k_{y})$ 的精确闭式表达式。\n2) 将所得的谱写成标准高斯形式 $\\mathcal{A}\\,\\exp\\!\\big(-\\tfrac{1}{2}\\, \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}\\big)$，其中 $\\boldsymbol{k} = (k_{x},k_{y})^{\\top}$，确定振幅 $\\mathcal{A}$，并用 $a$ 和 $b$ 显式确定谱协方差矩阵 $\\boldsymbol{\\Sigma}_{k}$。给出对应于 $k_{x}$ 和 $k_{y}$ 的两个对角协方差元素。\n将您的最终答案表示为一个组合对象，该对象由变换 $F(k_{x},k_{y})$ 以及协方差矩阵 $\\boldsymbol{\\Sigma}_{k}$ 的两个对角元素组成。无需四舍五入。在最终的方框答案中不要包含单位。", "solution": "用户提供的问题首先经过严格的验证过程。\n\n### 第 1 步：提取已知条件\n- 待变换的函数是一个各向异性高斯核：$f(x,y) = \\exp(-a x^{2} - b y^{2})$。\n- 参数 $a$ 和 $b$ 是正实数：$a0$, $b0$。\n- 二维傅里叶变换的定义如下：$F(k_{x},k_{y}) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} f(x,y) \\,\\exp\\!\\big(-\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}x\\,\\mathrm{d}y$。\n- 相应的逆变换为：$f(x,y) = \\frac{1}{(2\\pi)^{2}} \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} F(k_{x},k_{y}) \\,\\exp\\!\\big(\\mathrm{i}(k_{x} x + k_{y} y)\\big)\\,\\mathrm{d}k_{x}\\,\\mathrm{d}k_{y}$。\n- 一个明确的假设是，对于 $c0$，形式为 $\\int \\exp(-cx^2)dx$ 的高斯积分是收敛的。\n- 任务 1：推导 $F(k_{x},k_{y})$ 的闭式表达式。\n- 任务 2：将结果表示为标准高斯形式 $\\mathcal{A}\\,\\exp\\!\\big(-\\tfrac{1}{2}\\, \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}\\big)$，其中 $\\boldsymbol{k} = (k_{x},k_{y})^{\\top}$，确定振幅 $\\mathcal{A}$，并确定谱协方差矩阵 $\\boldsymbol{\\Sigma}_{k}$ 的对角元素。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学基础**：该问题基于傅里叶变换及其在高斯函数上的应用的成熟数学理论。这些是物理学、工程学和地球物理学中的基本工具。使用各向异性高斯作为平滑核是空间数据分析中的一种标准技术。该问题具有科学合理性。\n- **适定性**：由于 $a0$ 和 $b0$，函数 $f(x,y)$ 是 $L^1(\\mathbb{R}^2)$ 的元素，这保证了其傅里叶变换的存在性和唯一性。任务规定清晰，能够导出一个唯一、稳定且有意义的解。\n- **客观性**：该问题以精确、客观的数学语言陈述，没有任何主观性或模糊性。\n- **完整与一致**：提供了所有必要信息。函数、变换定义以及参数约束都已明确说明。没有矛盾之处。\n- **其他缺陷**：该问题没有表现出任何其他缺陷，例如不切实际、不适定、过于简单或无法验证。这是傅里叶分析中一个标准的、有一定难度的练习。\n\n### 第 3 步：结论与行动\n该问题被判定为**有效**。现在开始求解过程。\n\n### 解题推导\n\n第一个任务是计算 $f(x,y)$ 的二维傅里叶变换。我们从给定的定义开始：\n$$F(k_{x},k_{y}) = \\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{\\infty} \\exp(-a x^{2} - b y^{2}) \\,\\exp(-\\mathrm{i}(k_{x} x + k_{y} y))\\,\\mathrm{d}x\\,\\mathrm{d}y$$\n被积函数和积分域相对于变量 $x$ 和 $y$ 是可分的。我们可以将二重积分重写为两个独立的一维积分的乘积：\n$$F(k_{x},k_{y}) = \\left( \\int_{-\\infty}^{\\infty} \\exp(-a x^{2} - \\mathrm{i}k_{x} x) \\,\\mathrm{d}x \\right) \\left( \\int_{-\\infty}^{\\infty} \\exp(-b y^{2} - \\mathrm{i}k_{y} y) \\,\\mathrm{d}y \\right)$$\n我们来计算第一个积分，记为 $I_x$：\n$$I_x = \\int_{-\\infty}^{\\infty} \\exp(-a x^{2} - \\mathrm{i}k_{x} x) \\,\\mathrm{d}x$$\n为了解这个积分，我们对指数部分进行配方：\n$$-a x^{2} - \\mathrm{i}k_{x} x = -a \\left( x^2 + \\frac{\\mathrm{i}k_{x}}{a}x \\right) = -a \\left( x^2 + 2x\\left(\\frac{\\mathrm{i}k_{x}}{2a}\\right) + \\left(\\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\left(\\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 \\right)$$\n$$-a x^{2} - \\mathrm{i}k_{x} x = -a \\left( \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\frac{\\mathrm{i}^2 k_x^2}{4a^2} \\right) = -a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\frac{k_x^2}{4a}$$\n将此代回 $I_x$ 的积分中：\n$$I_x = \\int_{-\\infty}^{\\infty} \\exp\\left(-a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2 - \\frac{k_x^2}{4a}\\right) \\,\\mathrm{d}x = \\exp\\left(-\\frac{k_x^2}{4a}\\right) \\int_{-\\infty}^{\\infty} \\exp\\left(-a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2\\right) \\,\\mathrm{d}x$$\n该积分是一个标准的高斯积分。通过变量代换 $u = x + \\frac{\\mathrm{i}k_{x}}{2a}$，积分路径被移动到复平面。然而，由于被积函数的解析性质及其在无穷远处的快速衰减，积分的值保持不变。我们使用著名结论：对于 $\\text{Re}(c)0$，有 $\\int_{-\\infty}^{\\infty} \\exp(-c z^2) \\,\\mathrm{d}z = \\sqrt{\\frac{\\pi}{c}}$。在我们的例子中，$c=a  0$。\n$$\\int_{-\\infty}^{\\infty} \\exp\\left(-a \\left(x + \\frac{\\mathrm{i}k_{x}}{2a}\\right)^2\\right) \\,\\mathrm{d}x = \\int_{-\\infty}^{\\infty} \\exp(-a u^2) \\,\\mathrm{d}u = \\sqrt{\\frac{\\pi}{a}}$$\n因此，积分 $I_x$ 为：\n$$I_x = \\sqrt{\\frac{\\pi}{a}} \\exp\\left(-\\frac{k_x^2}{4a}\\right)$$\n通过直接类比，关于 $y$ 的积分（我们记为 $I_y$）可以通过将 $x$ 替换为 $y$，$a$ 替换为 $b$，$k_x$ 替换为 $k_y$ 来得到：\n$$I_y = \\sqrt{\\frac{\\pi}{b}} \\exp\\left(-\\frac{k_y^2}{4b}\\right)$$\n完整的二维傅里叶变换是 $I_x$ 和 $I_y$ 的乘积：\n$$F(k_x, k_y) = I_x I_y = \\left(\\sqrt{\\frac{\\pi}{a}}\\right) \\left(\\sqrt{\\frac{\\pi}{b}}\\right) \\exp\\left(-\\frac{k_x^2}{4a}\\right) \\exp\\left(-\\frac{k_y^2}{4b}\\right)$$\n$$F(k_x, k_y) = \\frac{\\pi}{\\sqrt{ab}} \\exp\\left(-\\frac{k_x^2}{4a} - \\frac{k_y^2}{4b}\\right)$$\n这就是傅里叶变换的闭式表达式，完成了任务 1。\n\n对于任务 2，我们必须将此结果写成标准形式 $\\mathcal{A}\\,\\exp\\!\\big(-\\tfrac{1}{2}\\, \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}\\big)$ 并确定其组成部分。\n通过与我们推导的表达式直接比较，振幅 $\\mathcal{A}$ 为：\n$$\\mathcal{A} = \\frac{\\pi}{\\sqrt{ab}}$$\n指数的参数在两种形式中必须相等：\n$$-\\frac{k_x^2}{4a} - \\frac{k_y^2}{4b} = -\\frac{1}{2} \\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k}$$\n设逆协方差矩阵为 $\\boldsymbol{\\Sigma}_{k}^{-1} = \\begin{pmatrix} C_{11}  C_{12} \\\\ C_{21}  C_{22} \\end{pmatrix}$。二次型为：\n$$\\boldsymbol{k}^{\\top} \\boldsymbol{\\Sigma}_{k}^{-1} \\boldsymbol{k} = \\begin{pmatrix} k_x  k_y \\end{pmatrix} \\begin{pmatrix} C_{11}  C_{12} \\\\ C_{21}  C_{22} \\end{pmatrix} \\begin{pmatrix} k_x \\\\ k_y \\end{pmatrix} = C_{11}k_x^2 + (C_{12}+C_{21})k_x k_y + C_{22}k_y^2$$\n从变换的表达式中，我们看到没有交叉项 $k_x k_y$，这意味着逆协方差矩阵的非对角元素为零：$C_{12} = C_{21} = 0$。\n我们可以令二次项的系数相等：\n$$\\frac{k_x^2}{2a} + \\frac{k_y^2}{2b} = C_{11}k_x^2 + C_{22}k_y^2$$\n这得到 $C_{11} = \\frac{1}{2a}$ 和 $C_{22} = \\frac{1}{2b}$。\n所以，逆谱协方差矩阵是：\n$$\\boldsymbol{\\Sigma}_{k}^{-1} = \\begin{pmatrix} \\frac{1}{2a}  0 \\\\ 0  \\frac{1}{2b} \\end{pmatrix}$$\n谱协方差矩阵 $\\boldsymbol{\\Sigma}_{k}$ 是 $\\boldsymbol{\\Sigma}_{k}^{-1}$ 的逆矩阵。对于对角矩阵，这只是对角元素倒数构成的矩阵：\n$$\\boldsymbol{\\Sigma}_{k} = (\\boldsymbol{\\Sigma}_{k}^{-1})^{-1} = \\begin{pmatrix} 2a  0 \\\\ 0  2b \\end{pmatrix}$$\n问题要求给出对应于 $k_x$ 和 $k_y$ 的两个对角协方差元素。这些是 $\\boldsymbol{\\Sigma}_{k}$ 的对角项。我们将其记为 $(\\boldsymbol{\\Sigma}_{k})_{11}$ 和 $(\\boldsymbol{\\Sigma}_{k})_{22}$。\n$$(\\boldsymbol{\\Sigma}_{k})_{11} = 2a$$\n$$(\\boldsymbol{\\Sigma}_{k})_{22} = 2b$$\n它们分别代表了谱分布在 $k_x$ 和 $k_y$ 方向上的方差。\n\n最终的组合答案由变换 $F(k_{x},k_{y})$ 和 $\\boldsymbol{\\Sigma}_{k}$ 的两个对角元素组成。\n变换是 $F(k_{x},k_{y}) = \\frac{\\pi}{\\sqrt{ab}} \\exp\\left(-\\frac{k_x^2}{4a} - \\frac{k_y^2}{4b}\\right)$。\n对角元素是 $2a$ 和 $2b$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\pi}{\\sqrt{ab}} \\exp\\left(-\\frac{k_x^{2}}{4a} - \\frac{k_y^{2}}{4b}\\right)  2a  2b\n\\end{pmatrix}\n}\n$$", "id": "3598065"}, {"introduction": "在掌握了基本的解析变换后，我们将注意力转向傅里叶变换在计算中最强大的应用之一：卷积定理。该定理将计算成本高昂的卷积运算转换成了对应频率域中简单的乘法运算，从而极大地提高了信号处理和模拟的效率。本练习通过一个模拟地震多次波的实例，要求您推导并实现基于傅里叶变换的卷积算法，并将其与时域直接卷积进行对比，以评估该方法的数值保真度。[@problem_id:3598100]", "problem": "在地震处理中，一个零偏移一维多次波模拟步骤可以被看作是对带限信号的线性时不变运算。令 $r(t)$ 表示反射系数序列，$s(t)$ 表示一个确定性带限震源子波，$(\\cdot \\star \\cdot)$ 表示连续时间卷积。模拟的多次波道定义为 $r(t)$ 与 $s(t)$ 的自卷积的线性卷积，并且所有角频率和角度都必须以弧度为单位解释，时间单位为秒。仅从傅里叶变换和卷积积分的核心定义以及离散傅里叶变换出发，完成以下任务。\n\n使用的基本定义：\n- 连续时间傅里叶变换：对于任何绝对可积的 $x(t)$，\n$$\\mathcal{F}\\{x\\}(\\omega) = \\int_{-\\infty}^{\\infty} x(t)\\, e^{-i \\omega t}\\, dt,$$\n及其逆变换\n$$\\mathcal{F}^{-1}\\{X\\}(t) = \\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty} X(\\omega)\\, e^{i \\omega t}\\, d\\omega.$$\n- 连续时间卷积：对于任何可积的 $f(t), g(t)$，\n$$(f \\star g)(t) = \\int_{-\\infty}^{\\infty} f(\\tau)\\, g(t - \\tau)\\, d\\tau.$$\n- 离散傅里叶变换：对于一个有限长度序列 $\\{x[n]\\}_{n=0}^{N-1}$，\n$$X[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i 2\\pi kn/N},\\quad k=0,\\dots,N-1,$$\n其逆变换为\n$$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k]\\, e^{i 2\\pi kn/N},\\quad n=0,\\dots,N-1.$$\n\n任务 A (推导)：\n- 从上述定义出发，不使用任何其他公式，推导通过将 $r(t)$ 与 $s(t)$ 的自卷积进行卷积所模拟的多次波的频域表示。您的推导必须仅使用给定的定义，逻辑地建立输入信号的傅里叶变换与输出信号的傅里叶变换之间的代数关系。\n\n任务 B (算法设计)：\n- 在离散时间下，采样间隔为 $\\Delta t$ 秒，考虑有限长度序列 $r[n] \\approx r(n \\Delta t)$ 和 $s[n] \\approx s(n \\Delta t)$。令 $c[n]$ 为 $s[n]$ 与自身的线性卷积。令 $y_{\\mathrm{time}}[n]$ 为 $r[n]$ 与 $c[n]$ 的线性卷积。独立地，通过使用离散傅里叶变换的定义和适当的补零来构造 $y_{\\mathrm{freq}}[n]$，使得循环卷积能精确地再现线性卷积。在两种路径中，都生成长度为 $L$ 的线性卷积结果，其中 $L = \\mathrm{len}(r) + \\mathrm{len}(c) - 1$。\n\n任务 C (数值稳定性和舍入评估)：\n- 对下面的每个测试用例，计算：\n  - 最大绝对差 $\\max_n |y_{\\mathrm{time}}[n] - y_{\\mathrm{freq}}[n]|$ (无量纲)。\n  - 相对 $\\ell_2$ 误差 $\\|y_{\\mathrm{time}} - y_{\\mathrm{freq}}\\|_2 / \\|y_{\\mathrm{time}}\\|_2$ (无量纲)，约定如果 $\\|y_{\\mathrm{time}}\\|_2 = 0$，则相对误差为 $0$。\n  - 震源频谱平方的谱动态范围的以 10 为底的对数，计算如下。令 $S[k]$ 为在频域路径中使用的相同变换长度下 $s[n]$ 的离散傅里叶变换，并令 $P[k] = |S[k]|^2$。定义 $P_{\\max} = \\max_k P[k]$ 和 $P_{\\min} = \\min\\{P[k] : P[k] \\geq P_{\\max}\\,\\varepsilon\\}$，其中 $\\varepsilon$ 是双精度浮点数的机器精度。报告 $\\log_{10}\\left(P_{\\max}/P_{\\min}\\right)$ (无量纲)。\n  - 一个布尔值，当且仅当相对 $\\ell_2$ 误差小于或等于容差 $\\tau = 10^{-10}$ 时为真。\n- 所有计算必须以双精度进行。在频域路径和谱动态范围计算中使用相同的离散傅里叶变换长度。时间单位为秒，所有角度单位为弧度。\n\n测试套件 (所有时间量单位为秒)：\n- 情况 $1$ (一般情况)：$\\Delta t = 0.001$，$r[n]$ 是长度为 $2048$ 的稀疏脉冲序列，脉冲概率为 $0.01$，脉冲振幅在 $[-0.8, 0.8]$ 区间内均匀分布 (使用固定的伪随机生成器种子)，$s[n]$ 是长度为 $251$ 的零相位 Ricker 子波，峰值频率 $f_0 = 25$ 赫兹。\n- 情况 $2$ (边界，平凡情况)：$\\Delta t = 0.002$，$r[n] = [1.0]$，$s[n] = [1.0]$。\n- 情况 $3$ (大动态范围，缩放情况)：$\\Delta t = 0.001$，$r[n]$ 是长度为 $512$ 的序列，包含零均值、标准差为 $10^{-3}$ 的独立高斯样本 (使用固定的伪随机生成器种子)，$s[n]$ 是长度为 $401$ 的零相位高斯子波 $s(t) = A \\exp\\left(-\\frac{t^2}{2\\sigma^2}\\right)$，其中 $A = 10^3$ 且 $\\sigma = 0.004$。\n- 情况 $4$ (非 2 的幂次方，相移情况)：$\\Delta t = 0.0015$，$r[n]$ 是长度为 $401$ 的序列，包含在 $[-0.5, 0.5]$ 区间内均匀分布的独立样本 (使用固定的伪随机生成器种子)，$s[n]$ 是长度为 $73$ 的 Hann 窗锥削的正弦波，定义为 $s[n] = w[n]\\sin(2\\pi f_c n \\Delta t)$，其中 $f_c = 60$ 赫兹，$w[n] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right)$，而 $N$ 是 $s[n]$ 的长度。\n\n实现要求：\n- 在时域路径中使用线性卷积。\n- 在频域路径中，选择一个离散傅里叶变换长度 $N_{\\mathrm{fft}}$，该长度应恰好等于所需的线性卷积长度 $L$，以避免循环混叠并使比较有意义。\n- 通过取实部来处理离散傅里叶逆变换输出中可忽略的虚部。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个顶层列表，该列表按测试套件的顺序包含四个用例的结果。每个用例的结果必须是一个包含四个条目的列表，顺序如下：最大绝对差 (浮点数)、相对 $\\ell_2$ 误差 (浮点数)、以 10 为底的谱动态范围 (浮点数) 和通过布尔值。例如，输出必须具有 $[\\,[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],[a_3,b_3,c_3,d_4]\\,]$ 的形式，不得有任何附加文本。", "solution": "问题陈述已经过验证，被确定为信号处理和计算地球物理学领域中一个提法正确、有科学依据的问题。所有提供的定义、参数和任务都是清晰、一致且充分的，足以推导出唯一且可验证的解。\n\n### 任务 A：频域表示的推导\n\n目标是求出由连续时间卷积 $y(t) = r(t) \\star (s(t) \\star s(t))$ 定义的模拟多次波道 $y(t)$ 的傅里叶变换。我们被要求完全从所提供的傅里叶变换和卷积的定义出发。\n\n令 $f(t)$ 和 $g(t)$ 为两个绝对可积函数。它们的卷积由下式给出：\n$$ (f \\star g)(t) = \\int_{-\\infty}^{\\infty} f(\\tau)\\, g(t - \\tau)\\, d\\tau $$\n根据定义，它们卷积的傅里叶变换是：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{-\\infty}^{\\infty} (f \\star g)(t)\\, e^{-i \\omega t}\\, dt $$\n将卷积的定义代入傅里叶变换积分：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{t=-\\infty}^{\\infty} \\left( \\int_{\\tau=-\\infty}^{\\infty} f(\\tau)\\, g(t - \\tau)\\, d\\tau \\right) e^{-i \\omega t}\\, dt $$\n假设函数是良态的，可以交换积分顺序 (根据 Fubini 定理，这对于 $L^1(\\mathbb{R})$ 中的函数是成立的)，我们得到：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{\\tau=-\\infty}^{\\infty} f(\\tau) \\left( \\int_{t=-\\infty}^{\\infty} g(t - \\tau)\\, e^{-i \\omega t}\\, dt \\right) d\\tau $$\n我们关注内部积分。进行变量替换，令 $u = t - \\tau$。这意味着 $t = u + \\tau$ 且 $dt = du$。积分限保持不变。\n$$ \\int_{t=-\\infty}^{\\infty} g(t - \\tau)\\, e^{-i \\omega t}\\, dt = \\int_{u=-\\infty}^{\\infty} g(u)\\, e^{-i \\omega (u + \\tau)}\\, du $$\n使用指数函数的性质 $e^{a+b} = e^a e^b$，我们可以分离各项：\n$$ \\int_{u=-\\infty}^{\\infty} g(u)\\, e^{-i \\omega u} e^{-i \\omega \\tau}\\, du = e^{-i \\omega \\tau} \\int_{u=-\\infty}^{\\infty} g(u)\\, e^{-i \\omega u}\\, du $$\n根据定义，右侧的积分是 $g(u)$ 的傅里叶变换，我们将其表示为 $G(\\omega)$。因此，内部积分简化为 $e^{-i \\omega \\tau} G(\\omega)$。\n\n将此结果代回卷积的傅里叶变换表达式中：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = \\int_{\\tau=-\\infty}^{\\infty} f(\\tau) \\left( e^{-i \\omega \\tau} G(\\omega) \\right) d\\tau $$\n由于 $G(\\omega)$ 不依赖于积分变量 $\\tau$，我们可以将其从积分中提出：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = G(\\omega) \\int_{\\tau=-\\infty}^{\\infty} f(\\tau)\\, e^{-i \\omega \\tau}\\, d\\tau $$\n剩余的积分是 $f(\\tau)$ 的傅里叶变换的定义，即 $F(\\omega)$。因此，我们推导出了卷积定理：\n$$ \\mathcal{F}\\{f \\star g\\}(\\omega) = F(\\omega) G(\\omega) $$\n现在，我们将此定理应用于具体问题。模拟道是 $y(t) = r(t) \\star (s(t) \\star s(t))$。我们定义一个中间函数 $c(t) = s(t) \\star s(t)$。那么 $y(t) = r(t) \\star c(t)$。\n\n令 $R(\\omega) = \\mathcal{F}\\{r(t)\\}$，$S(\\omega) = \\mathcal{F}\\{s(t)\\}$，$C(\\omega) = \\mathcal{F}\\{c(t)\\}$，以及 $Y(\\omega) = \\mathcal{F}\\{y(t)\\}$。\n\n将卷积定理应用于 $c(t) = s(t) \\star s(t)$：\n$$ C(\\omega) = \\mathcal{F}\\{s(t) \\star s(t)\\} = S(\\omega) S(\\omega) = S(\\omega)^2 $$\n接下来，将卷积定理应用于 $y(t) = r(t) \\star c(t)$：\n$$ Y(\\omega) = \\mathcal{F}\\{r(t) \\star c(t)\\} = R(\\omega) C(\\omega) $$\n最后，代入 $C(\\omega)$ 的表达式：\n$$ Y(\\omega) = R(\\omega) S(\\omega)^2 $$\n这就是模拟多次波道的频域表示。时域中的卷积在频域中变成了乘法。具体来说，震源子波的自卷积对应于其频谱的平方，随后与反射系数序列的卷积对应于乘以反射系数频谱。\n\n### 任务 B：算法设计\n\n我们被要求通过两种不同的路径，为离散的有限长度序列 $r[n]$ 和 $s[n]$ 计算最终道 $y[n]$。\n\n令输入序列的长度为 $N_r = \\mathrm{len}(r)$ 和 $N_s = \\mathrm{len}(s)$。\n\n1.  **时域路径 ($y_{\\mathrm{time}}[n]$)**：此路径使用直接线性卷积。\n    a.  首先，计算震源子波的自卷积，$c[n] = s[n] \\star s[n]$。这个中间序列 $c[n]$ 的长度将是 $N_c = N_s + N_s - 1 = 2N_s - 1$。\n    b.  接下来，将反射系数序列 $r[n]$ 与结果 $c[n]$ 进行卷积得到最终道：$y_{\\mathrm{time}}[n] = r[n] \\star c[n]$。这个最终序列的长度 $L$ 将是 $L = N_r + N_c - 1 = N_r + (2N_s - 1) - 1 = N_r + 2N_s - 2$。\n\n2.  **频域路径 ($y_{\\mathrm{freq}}[n]$)**：此路径利用离散傅里叶变换 (DFT) 来执行卷积。如果序列被补零到足够的长度，DFT 的循环卷积性质可以用来计算线性卷积。\n    a.  DFT 所需的长度 $N_{\\mathrm{fft}}$ 必须至少为最终线性卷积输出的长度 $L$。问题指定使用恰好为 $L$ 的长度。因此，我们设置 $N_{\\mathrm{fft}} = L = N_r + 2N_s - 2$。\n    b.  将输入序列 $r[n]$ 和 $s[n]$ 补零至此长度 $N_{\\mathrm{fft}}$。\n    c.  使用给定定义计算补零后序列的 DFT：\n        $$ R[k] = \\mathrm{DFT}\\{r_{\\text{padded}}\\}[k] = \\sum_{n=0}^{N_{\\mathrm{fft}}-1} r_{\\text{padded}}[n]\\, e^{-i 2\\pi kn/N_{\\mathrm{fft}}} $$\n        $$ S[k] = \\mathrm{DFT}\\{s_{\\text{padded}}\\}[k] = \\sum_{n=0}^{N_{\\mathrm{fft}}-1} s_{\\text{padded}}[n]\\, e^{-i 2\\pi kn/N_{\\mathrm{fft}}} $$\n    d.  在离散频域中应用从任务 A 推导出的代数关系：\n        $$ Y[k] = R[k] \\cdot S[k]^2 $$\n        此乘法对每个频率索引 $k=0, \\dots, N_{\\mathrm{fft}}-1$ 逐元素执行。\n    e.  计算 $Y[k]$ 的离散傅里叶逆变换，将结果转换回时域：\n        $$ y_{\\mathrm{freq\\_complex}}[n] = \\mathrm{IDFT}\\{Y\\}[n] = \\frac{1}{N_{\\mathrm{fft}}}\\sum_{k=0}^{N_{\\mathrm{fft}}-1} Y[k]\\, e^{i 2\\pi kn/N_{\\mathrm{fft}}} $$\n    f.  由于原始信号 $r[n]$ 和 $s[n]$ 是实值的，它们的卷积 $y[n]$ 也必须是实值的。由于浮点不精确性，数值结果 $y_{\\mathrm{freq\\_complex}}[n]$ 将具有非零但可忽略的虚部。按照指示，我们通过取其实部来丢弃虚部：\n        $$ y_{\\mathrm{freq}}[n] = \\mathrm{Re}\\{y_{\\mathrm{freq\\_complex}}[n]\\} $$\n    序列 $y_{\\mathrm{time}}[n]$ 和 $y_{\\mathrm{freq}}[n]$ 在机器精度范围内应该是相同的。\n\n### 任务 C：数值稳定性和舍入评估\n\n对于每个测试用例，我们计算四个指标来比较 $y_{\\mathrm{time}}$ 和 $y_{\\mathrm{freq}}$。\n\n1.  **最大绝对差**：此指标量化了两种方法之间最大的逐点差异。\n    $$ \\Delta_{\\max} = \\max_{n} |y_{\\mathrm{time}}[n] - y_{\\mathrm{freq}}[n]| $$\n\n2.  **相对 $\\ell_2$ 误差**：此指标提供了一个归一化的总体差异度量，考虑了信号的能量。向量 $v$ 的 $\\ell_2$ 范数是 $\\|v\\|_2 = \\sqrt{\\sum_n |v[n]|^2}$。\n    $$ E_2 = \\frac{\\|y_{\\mathrm{time}} - y_{\\mathrm{freq}}\\|_2}{\\|y_{\\mathrm{time}}\\|_2} $$\n    如果 $\\|y_{\\mathrm{time}}\\|_2 = 0$，则误差定义为 $0$。\n\n3.  **谱动态范围**：此指标评估了震源频谱的数值条件，这会影响频域运算的准确性。\n    a. 令 $S[k]$ 为长度为 $N_{\\mathrm{fft}}$ 的补零后震源子波 $s[n]$ 的 DFT。\n    b. 计算功率谱 $P[k] = |S[k]|^2$。\n    c. 求最大功率 $P_{\\max} = \\max_k P[k]$。\n    d. 获取双精度浮点数的机器精度 $\\varepsilon$。\n    e. 定义一个噪声基底阈值 $P_{\\mathrm{thresh}} = P_{\\max} \\cdot \\varepsilon$。\n    f. 找到高于此基底的最小功率值：$P_{\\min} = \\min\\{P[k] \\mid P[k] \\geq P_{\\mathrm{thresh}}\\}$。\n    g. 然后动态范围计算如下：\n        $$ D = \\log_{10}\\left(\\frac{P_{\\max}}{P_{\\min}}\\right) $$\n    如果 $P_{\\max} = 0$，这意味着 $s[n]$ 全为零，那么 $P_{\\min}$ 也将为 $0$。在这种情况下，由于没有信号，动态范围可以被认为是 $0$。\n\n4.  **容差检查**：一个布尔标志，指示数值方法是否可接受地接近。\n    $$ \\mathrm{Pass} = (\\mathrm{E_2} \\le \\tau) $$\n    其中容差 $\\tau$ 设定为 $10^{-10}$。\n\n这四个指标对时域和频域卷积算法的等价性和数值稳定性提供了全面的评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    # --- Helper function for wavelet generation ---\n\n    def generate_ricker(n_s, f0, dt):\n        \"\"\"Generates a zero-phase Ricker wavelet.\"\"\"\n        if n_s == 1:\n            return np.array([1.0], dtype=np.float64)\n        t = (np.arange(n_s) - (n_s - 1) / 2) * dt\n        pi_f0_t_sq = (np.pi * f0 * t) ** 2\n        return (1 - 2 * pi_f0_t_sq) * np.exp(-pi_f0_t_sq)\n\n    def generate_gaussian_wavelet(n_s, A, sigma, dt):\n        \"\"\"Generates a zero-phase Gaussian wavelet.\"\"\"\n        if n_s == 1:\n            return np.array([A], dtype=np.float64)\n        t = (np.arange(n_s) - (n_s - 1) / 2) * dt\n        return A * np.exp(-t**2 / (2 * sigma**2))\n\n    def generate_hann_tapered_sine(n_s, fc, dt):\n        \"\"\"Generates a Hann-tapered sine wave.\"\"\"\n        if n_s == 1:\n            return np.array([0.0], dtype=np.float64) # sin(0) = 0\n        n = np.arange(n_s)\n        window = 0.5 * (1 - np.cos(2 * np.pi * n / (n_s - 1)))\n        sine_wave = np.sin(2 * np.pi * fc * n * dt)\n        return window * sine_wave\n\n    def solve_case(case_params):\n        \"\"\"\n        Solves a single test case, returning the four required metrics.\n        \"\"\"\n        case_id = case_params['id']\n        dt = case_params['dt']\n        len_r = case_params['len_r']\n        len_s = case_params['len_s']\n        \n        # --- Generate r[n] and s[n] for the current case ---\n        \n        # Seed for reproducibility\n        rng = np.random.default_rng(seed=case_id)\n\n        if case_id == 1:\n            # Sparse spike train r[n]\n            r = np.zeros(len_r, dtype=np.float64)\n            is_spike = rng.random(len_r)  0.01\n            num_spikes = np.sum(is_spike)\n            r[is_spike] = rng.uniform(-0.8, 0.8, num_spikes)\n            # Ricker wavelet s[n]\n            s = generate_ricker(len_s, f0=25.0, dt=dt)\n\n        elif case_id == 2:\n            # Trivial boundary case\n            r = np.array([1.0], dtype=np.float64)\n            s = np.array([1.0], dtype=np.float64)\n\n        elif case_id == 3:\n            # Gaussian noise r[n]\n            r = rng.normal(loc=0.0, scale=1e-3, size=len_r).astype(np.float64)\n            # Gaussian wavelet s[n]\n            s = generate_gaussian_wavelet(len_s, A=1e3, sigma=0.004, dt=dt)\n\n        elif case_id == 4:\n            # Uniform noise r[n]\n            r = rng.uniform(-0.5, 0.5, size=len_r).astype(np.float64)\n            # Hann-tapered sinusoid s[n]\n            s = generate_hann_tapered_sine(len_s, fc=60.0, dt=dt).astype(np.float64)\n\n        # Ensure double precision\n        r = r.astype(np.float64)\n        s = s.astype(np.float64)\n\n        # --- Task B: Time-Domain and Frequency-Domain Pathways ---\n\n        # 1. Time-Domain Pathway\n        c_time = np.convolve(s, s, mode='full')\n        y_time = np.convolve(r, c_time, mode='full')\n        \n        # 2. Frequency-Domain Pathway\n        N_fft = len(y_time) # Use the exact linear convolution length for FFT\n\n        R_fft = fft(r, n=N_fft)\n        S_fft = fft(s, n=N_fft)\n\n        Y_fft = R_fft * (S_fft**2)\n        y_freq_complex = ifft(Y_fft)\n        y_freq = np.real(y_freq_complex)\n\n        # --- Task C: Numerical Stability and Roundoff Assessment ---\n\n        # 1. Maximum Absolute Difference\n        max_abs_diff = np.max(np.abs(y_time - y_freq))\n\n        # 2. Relative l2 Error\n        norm_diff = np.linalg.norm(y_time - y_freq)\n        norm_y_time = np.linalg.norm(y_time)\n        if norm_y_time == 0.0:\n            rel_l2_err = 0.0\n        else:\n            rel_l2_err = norm_diff / norm_y_time\n\n        # 3. Spectral Dynamic Range\n        P = np.abs(S_fft)**2\n        P_max = np.max(P)\n        \n        if P_max == 0.0:\n            dyn_range_log10 = 0.0\n        else:\n            epsilon = np.finfo(np.float64).eps\n            P_min_set = P[P >= P_max * epsilon]\n            # The set is guaranteed to be non-empty unless P_max is 0\n            P_min = np.min(P_min_set)\n            if P_min == 0.0: # Should not happen with epsilon guard but as a safety\n                dyn_range_log10 = np.inf\n            else:\n                dyn_range_log10 = np.log10(P_max / P_min)\n\n        # 4. Tolerance Check\n        tolerance = 1e-10\n        passed = rel_l2_err = tolerance\n\n        return [max_abs_diff, rel_l2_err, dyn_range_log10, passed]\n    \n    test_cases_params = [\n        {'id': 1, 'dt': 0.001, 'len_r': 2048, 'len_s': 251},\n        {'id': 2, 'dt': 0.002, 'len_r': 1, 'len_s': 1},\n        {'id': 3, 'dt': 0.001, 'len_r': 512, 'len_s': 401},\n        {'id': 4, 'dt': 0.0015, 'len_r': 401, 'len_s': 73},\n    ]\n\n    results = []\n    for params in test_cases_params:\n        case_result = solve_case(params)\n        results.append(case_result)\n\n    # Format the final output string\n    def format_list(lst):\n        items = []\n        for item in lst:\n            if isinstance(item, list):\n                items.append(format_list(item))\n            elif isinstance(item, bool):\n                items.append(str(item).lower())\n            else:\n                items.append(f\"{item:.15e}\") # High precision float format\n        return f\"[{','.join(items)}]\"\n    \n    # Custom formatting to match the required output style precisely\n    final_output_str = \"[\" + \",\".join([\n        f\"[{res[0]:.15e},{res[1]:.15e},{res[2]:.15e},{str(res[3]).lower()}]\" for res in results\n    ]) + \"]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3598100"}, {"introduction": "最后一个练习将傅里叶分析的应用提升到一个新的高度，即不仅用它来处理数据，更用它来分析计算地球物理学中波动方程模拟的核心——数值算法本身。本练习将引导您推导有限差分算子的傅里叶符号（或有效波数），这是量化和比较不同差分格式数值频散和混叠误差的关键工具。通过对比常规网格和交错网格，您将亲身体会到后者在抑制数值频散方面的优越性，这是现代波动方程模拟中的一项核心技术。[@problem_id:3598094]", "problem": "在计算地球物理学中，空间导数的离散表示是模拟地震波传播的基础。一个标准的分析工具是通过线性时不变算子在离散平面波上的作用，在傅里叶域中对其进行表征。考虑一个一维均匀网格，其网格间距为 $\\Delta x$（单位为米），以及一个离散平面波 $f_j = \\exp(i k j \\Delta x)$，其中 $j \\in \\mathbb{Z}$ 是网格节点的索引，$k$ 是空间波数（单位为弧度/米）。离散傅里叶变换（DFT）表明，连续空间导数映射为乘以 $i k$，而离散有限差分近似则映射为乘以 $i \\sigma(k)$，其中 $\\sigma(k)$ 是离散算子的傅里叶符号。有效波数 $k_{\\mathrm{eff}}(k)$ 由 $D f_j = i k_{\\mathrm{eff}}(k) f_j$ 定义，其中 $D$ 是离散导数算子。\n\n您将研究两种格式的混叠抑制和频散特性：\n- 一种作用于位于 $\\Delta x$ 整数倍位置的样本 $f_j$ 的 2 阶同位网格中心有限差分。\n- 一种作用于半网格和整数网格位置之间的 2 阶交错网格中心有限差分，其样本 $g_{j+1/2}$ 位于 $(j+1/2)\\Delta x$ 位置，导数在整数索引上进行评估。\n\n仅从基本定义（导数的傅里叶域属性、线性时不变算子对平面波的 DFT 响应，以及下面的模板定义）出发，推导两种格式的傅里叶符号 $\\sigma(k)$，并由此得到有效波数 $k_{\\mathrm{eff}}(k)$。所有三角函数求值均使用弧度。模板如下：\n- 同位中心差分：$D_{\\mathrm{coll}} f_j = \\dfrac{f_{j+1} - f_{j-1}}{2 \\Delta x}$。\n- 交错中心差分（从半网格映射到整数网格）：$D_{\\mathrm{stag}} g_j = \\dfrac{g_{j+1/2} - g_{j-1/2}}{\\Delta x}$。\n\n将奈奎斯特波数定义为 $k_{\\mathrm{Nyquist}} = \\pi / \\Delta x$（单位为弧度/米）。对于每种格式，通过相对相位误差比 $r(k) = k_{\\mathrm{eff}}(k)/k$ 来量化频散，并通过 $k_{\\mathrm{eff}}$ 在 $k_{\\mathrm{Nyquist}}$ 处的值来量化混叠行为。实现一个程序，对下面列出的每个测试用例执行以下操作：\n- 在 $M$ 个均匀间隔的点上对波数区间 $[0, k_{\\mathrm{Nyquist}}]$ 进行采样。对于涉及除以 $k$ 的比率，从计算中排除 $k=0$，并为了报告目的，将极限 $k \\to 0$ 解释为 $r(0) = 1$。\n- 计算同位网格和交错网格格式的最大相对频散误差 $\\max_{k \\in (0, k_{\\mathrm{Nyquist}}]} |r(k) - 1|$。\n- 确定两个布尔值以指示混叠抑制行为：对于同位网格格式，$k_{\\mathrm{eff}}(k_{\\mathrm{Nyquist}}) = 0$ 是否成立；对于交错网格格式，$k_{\\mathrm{eff}}(k_{\\mathrm{Nyquist}}) = 0$ 是否成立。评估时使用数值上稳健的相等性测试。\n- 报告一个改进布尔值，如果交错网格格式的最大相对频散误差严格小于同位网格格式，则该值为真。\n\n物理单位和角度单位要求：\n- 以米为单位报告 $\\Delta x$。\n- 以弧度/米为单位报告波数 $k$。\n- 对任何三角函数参数均使用弧度。\n\n测试套件：\n- 案例1：$N = 256$ 个网格点，$\\Delta x = 10$ 米，$M = 10001$ 个波数样本。\n- 案例2：$N = 32$ 个网格点，$\\Delta x = 50$ 米，$M = 10001$ 个波数样本。\n- 案例3：$N = 512$ 个网格点，$\\Delta x = 1$ 米，$M = 10001$ 个波数样本。\n- 案例4：$N = 16$ 个网格点，$\\Delta x = 25$ 米，$M = 2049$ 个波数样本。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例对应一个子列表，子列表包含五个条目，顺序如下：[改进布尔值, 同位网格的最大相对误差（浮点数）, 交错网格的最大相对误差（浮点数）, 同位网格在 $k_{\\mathrm{Nyquist}}$ 处的混叠置零布尔值, 交错网格在 $k_{\\mathrm{Nyquist}}$ 处的混叠置零布尔值]。所有浮点数都应报告小数点后 $8$ 位。例如，总体输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，不含空格。", "solution": "在进行求解之前，需要对问题进行验证。\n\n### 步骤1：提取已知条件\n- 网格间距：$\\Delta x$（米）。\n- 网格节点索引：$j \\in \\mathbb{Z}$。\n- 波数：$k$（弧度/米）。\n- 同位网格平面波：$f_j = \\exp(i k j \\Delta x)$。\n- 交错网格平面波：$g_{j+1/2} = \\exp(i k (j+1/2) \\Delta x)$。\n- 有效波数定义：$D \\phi = i k_{\\mathrm{eff}}(k) \\phi$，其中 $\\phi$ 是相应的平面波。\n- 同位网格模板：$D_{\\mathrm{coll}} f_j = \\dfrac{f_{j+1} - f_{j-1}}{2 \\Delta x}$。\n- 交错网格模板：$D_{\\mathrm{stag}} g_j = \\dfrac{g_{j+1/2} - g_{j-1/2}}{\\Delta x}$。\n- 奈奎斯特波数：$k_{\\mathrm{Nyquist}} = \\pi / \\Delta x$。\n- 相对相位误差比：$r(k) = k_{\\mathrm{eff}}(k)/k$。\n- $k=0$ 时比率的极限：$\\lim_{k \\to 0} r(k) = 1$。\n- 波数采样：在 $M$ 个均匀间隔点上对区间 $[0, k_{\\mathrm{Nyquist}}]$ 进行采样。\n- 待计算的指标：\n    1. 同位和交错网格格式的最大相对频散误差 $\\max_{k \\in (0, k_{\\mathrm{Nyquist}}]} |r(k) - 1|$。\n    2. 混叠抑制布尔值：对同位和交错网格格式，判断 $k_{\\mathrm{eff}}(k_{\\mathrm{Nyquist}}) = 0$ 是否成立。\n    3. 改进布尔值：如果交错网格的最大误差严格小于同位网格的最大误差，则为 `True`。\n- 测试用例：\n    - 案例1：$N = 256$，$\\Delta x = 10$ 米，$M = 10001$。\n    - 案例2：$N = 32$，$\\Delta x = 50$ 米，$M = 10001$。\n    - 案例3：$N = 512$，$\\Delta x = 1$ 米，$M = 10001$。\n    - 案例4：$N = 16$，$\\Delta x = 25$ 米，$M = 2049$。\n- 变量 $N$（网格点数）对于无限网格的理论推导是无关的，因此不会在解析公式中使用。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上是合理的、适定的和客观的。它基于傅里叶分析的基本原理，并应用于偏微分方程的数值方法，这是计算地球物理学和应用数学中的一个标准课题。定义精确，目标可量化，并且提供了推导解决方案所需的所有信息。该问题不违反任何无效性标准。\n\n### 步骤3：结论与行动\n问题有效。将提供完整解答。\n\n### 基于原理的解答\n核心任务是确定两种有限差分格式的有效波数 $k_{\\mathrm{eff}}(k)$。这通过将离散差分算子 $D$ 应用于离散平面波，并将输出分解为 $i k_{\\mathrm{eff}}(k)$ 乘以原始平面波的形式来实现。\n\n**1. 同位中心差分格式**\n\n算子由 $D_{\\mathrm{coll}} f_j = \\dfrac{f_{j+1} - f_{j-1}}{2 \\Delta x}$ 给出。我们将此算子应用于平面波 $f_j = \\exp(i k j \\Delta x)$。\n\n$$\n\\begin{aligned}\nD_{\\mathrm{coll}} f_j = \\frac{\\exp(i k (j+1) \\Delta x) - \\exp(i k (j-1) \\Delta x)}{2 \\Delta x} \\\\\n= \\frac{\\exp(i k j \\Delta x) \\exp(i k \\Delta x) - \\exp(i k j \\Delta x) \\exp(-i k \\Delta x)}{2 \\Delta x} \\\\\n= f_j \\cdot \\frac{\\exp(i k \\Delta x) - \\exp(-i k \\Delta x)}{2 \\Delta x}\n\\end{aligned}\n$$\n\n使用欧拉恒等式 $\\sin(\\theta) = \\frac{e^{i\\theta} - e^{-i\\theta}}{2i}$，我们可以写出 $\\exp(i k \\Delta x) - \\exp(-i k \\Delta x) = 2i \\sin(k \\Delta x)$。将其代入方程得到：\n\n$$\nD_{\\mathrm{coll}} f_j = f_j \\cdot \\frac{2i \\sin(k \\Delta x)}{2 \\Delta x} = i \\left( \\frac{\\sin(k \\Delta x)}{\\Delta x} \\right) f_j\n$$\n\n通过将此结果与定义 $D_{\\mathrm{coll}} f_j = i k_{\\mathrm{eff, coll}}(k) f_j$ 进行比较，我们确定同位网格格式的有效波数为：\n\n$$\nk_{\\mathrm{eff, coll}}(k) = \\frac{\\sin(k \\Delta x)}{\\Delta x}\n$$\n\n**2. 交错中心差分格式**\n\n算子为 $D_{\\mathrm{stag}} g_j = \\dfrac{g_{j+1/2} - g_{j-1/2}}{\\Delta x}$。它作用于在半网格上定义的平面波 $g_{j+1/2} = \\exp(i k (j+1/2) \\Delta x)$，并在整数网格上产生结果。\n\n$$\n\\begin{aligned}\nD_{\\mathrm{stag}} g_j = \\frac{\\exp(i k (j+1/2) \\Delta x) - \\exp(i k (j-1/2) \\Delta x)}{\\Delta x} \\\\\n= \\frac{\\exp(i k j \\Delta x) \\exp(i k \\Delta x / 2) - \\exp(i k j \\Delta x) \\exp(-i k \\Delta x / 2)}{\\Delta x} \\\\\n= \\exp(i k j \\Delta x) \\cdot \\frac{\\exp(i k \\Delta x / 2) - \\exp(-i k \\Delta x / 2)}{\\Delta x}\n\\end{aligned}\n$$\n\n再次使用欧拉恒等式，设 $\\theta = k \\Delta x / 2$，我们有 $\\exp(i k \\Delta x / 2) - \\exp(-i k \\Delta x / 2) = 2i \\sin(k \\Delta x / 2)$。代入可得：\n\n$$\nD_{\\mathrm{stag}} g_j = \\exp(i k j \\Delta x) \\cdot \\frac{2i \\sin(k \\Delta x / 2)}{\\Delta x} = i \\left( \\frac{2 \\sin(k \\Delta x / 2)}{\\Delta x} \\right) \\exp(i k j \\Delta x)\n$$\n\n结果与一个整数网格平面波成正比。遵循问题定义的模式，我们将其与 $i k_{\\mathrm{eff, stag}}(k) f_j$ 进行匹配，其中 $f_j = \\exp(i k j \\Delta x)$。这给出了交错网格格式的有效波数：\n\n$$\nk_{\\mathrm{eff, stag}}(k) = \\frac{2 \\sin(k \\Delta x / 2)}{\\Delta x}\n$$\n\n**3. 频散与混叠分析**\n\n相对相位误差比为 $r(k) = k_{\\mathrm{eff}}(k)/k$。理想算子具有 $k_{\\mathrm{eff}}(k) = k$，因此 $r(k)=1$。偏离 $1$ 表示存在频散误差。\n\n对于同位网格格式：\n$$\nr_{\\mathrm{coll}}(k) = \\frac{k_{\\mathrm{eff, coll}}(k)}{k} = \\frac{\\sin(k \\Delta x)}{k \\Delta x}\n$$\n\n对于交错网格格式：\n$$\nr_{\\mathrm{stag}}(k) = \\frac{k_{\\mathrm{eff, stag}}(k)}{k} = \\frac{2 \\sin(k \\Delta x / 2)}{k \\Delta x} = \\frac{\\sin(k \\Delta x / 2)}{k \\Delta x / 2}\n$$\n\n现在，我们评估在奈奎斯特波数 $k_{\\mathrm{Nyquist}} = \\pi / \\Delta x$ 处的行为。\n\n同位网格在奈奎斯特波数处：\n$$\nk_{\\mathrm{eff, coll}}(k_{\\mathrm{Nyquist}}) = \\frac{\\sin(k_{\\mathrm{Nyquist}} \\Delta x)}{\\Delta x} = \\frac{\\sin((\\pi/\\Delta x)\\Delta x)}{\\Delta x} = \\frac{\\sin(\\pi)}{\\Delta x} = 0\n$$\n由于 $k_{\\mathrm{eff, coll}}(k_{\\mathrm{Nyquist}}) = 0$，该格式完全抑制（置零）了奈奎斯特频率处的混叠。相应的布尔值为 `True`。\n\n交错网格在奈奎斯特波数处：\n$$\nk_{\\mathrm{eff, stag}}(k_{\\mathrm{Nyquist}}) = \\frac{2 \\sin(k_{\\mathrm{Nyquist}} \\Delta x / 2)}{\\Delta x} = \\frac{2 \\sin((\\pi/\\Delta x)\\Delta x/2)}{\\Delta x} = \\frac{2 \\sin(\\pi/2)}{\\Delta x} = \\frac{2}{\\Delta x}\n$$\n由于 $k_{\\mathrm{eff, stag}}(k_{\\mathrm{Nyquist}}) \\neq 0$，该格式不抑制奈奎斯特频率处的混叠。布尔值为 `False`。\n\n最后，我们找出在 $k \\in (0, k_{\\mathrm{Nyquist}}]$ 上的最大相对频散误差 $\\max |r(k) - 1|$。\n令 $y = k \\Delta x$。$y$ 的区间变为 $(0, \\pi]$。令 $z = k \\Delta x / 2$。$z$ 的区间变为 $(0, \\pi/2]$。比率为 $r_{\\mathrm{coll}} = \\sin(y)/y$ 和 $r_{\\mathrm{stag}} = \\sin(z)/z$。在各自的区间 $(0, \\pi]$ 和 $(0, \\pi/2]$ 上，$\\sin(x)/x$ 函数都是单调递减的，并且总是小于或等于 $1$。因此，$|r(k) - 1| = 1 - r(k)$。最大误差发生在 $k$ 的最大值处，即 $k_{\\mathrm{Nyquist}}$。\n\n同位网格最大误差：\n$$\n\\max |r_{\\mathrm{coll}}(k) - 1| = 1 - r_{\\mathrm{coll}}(k_{\\mathrm{Nyquist}}) = 1 - \\frac{\\sin(\\pi)}{\\pi} = 1 - 0 = 1\n$$\n\n交错网格最大误差：\n$$\n\\max |r_{\\mathrm{stag}}(k) - 1| = 1 - r_{\\mathrm{stag}}(k_{\\mathrm{Nyquist}}) = 1 - \\frac{\\sin(\\pi/2)}{\\pi/2} = 1 - \\frac{1}{\\pi/2} = 1 - \\frac{2}{\\pi}\n$$\n\n由于 $1 - 2/\\pi \\approx 0.36338  1$，交错网格格式具有严格更小的最大相对频散误差。改进布尔值为 `True`。\n\n这些解析结果与 $\\Delta x$、$N$ 和 $M$ 无关，并将通过程序实现进行数值验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# No other libraries are necessary. The problem can be solved with numpy alone.\n\ndef solve():\n    \"\"\"\n    Derives and computes dispersion and alias characteristics for two\n    finite difference schemes for the first spatial derivative.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, delta_x, M), where N is number of grid points,\n    # delta_x is grid spacing, and M is number of wavenumber samples.\n    # The variable N is extraneous to the theoretical calculations.\n    test_cases = [\n        (256, 10.0, 10001),\n        (32, 50.0, 10001),\n        (512, 1.0, 10001),\n        (16, 25.0, 2049),\n    ]\n\n    all_results_str = []\n    \n    for _, dx, M in test_cases:\n        # Calculate the Nyquist wavenumber\n        k_nyquist = np.pi / dx\n        \n        # Sample the wavenumber interval [0, k_Nyquist] at M points.\n        # k=0 is excluded from ratio calculations as specified.\n        k_vec = np.linspace(0, k_nyquist, M)\n        k_vec_nonzero = k_vec[1:]\n\n        # --- Collocated Scheme Analysis ---\n        \n        # Calculate the relative phase error ratio r(k) = k_eff(k)/k\n        # For collocated scheme, r_coll(k) = sin(k*dx) / (k*dx)\n        arg_coll = k_vec_nonzero * dx\n        r_coll = np.sin(arg_coll) / arg_coll\n        \n        # Compute the maximum relative dispersion error\n        max_err_coll = np.max(np.abs(r_coll - 1.0))\n        \n        # Check alias suppression at k_Nyquist: k_eff(k_Nyquist) == 0?\n        # k_eff_coll(k_Nyquist) = sin(pi)/dx = 0\n        k_eff_coll_nyquist = np.sin(k_nyquist * dx) / dx\n        alias_coll_bool = np.isclose(k_eff_coll_nyquist, 0.0)\n\n        # --- Staggered Scheme Analysis ---\n        \n        # Calculate the relative phase error ratio r(k) = k_eff(k)/k\n        # For staggered scheme, r_stag(k) = sin(k*dx/2) / (k*dx/2)\n        arg_stag = k_vec_nonzero * dx / 2.0\n        r_stag = np.sin(arg_stag) / arg_stag\n        \n        # Compute the maximum relative dispersion error\n        max_err_stag = np.max(np.abs(r_stag - 1.0))\n        \n        # Check alias suppression at k_Nyquist: k_eff(k_Nyquist) == 0?\n        # k_eff_stag(k_Nyquist) = (2/dx) * sin(pi/2) = 2/dx != 0\n        k_eff_stag_nyquist = (2.0 / dx) * np.sin(k_nyquist * dx / 2.0)\n        alias_stag_bool = np.isclose(k_eff_stag_nyquist, 0.0)\n        \n        # --- Comparison and Formatting ---\n\n        # Determine if the staggered scheme has strictly smaller max error\n        improvement_bool = max_err_stag  max_err_coll\n        \n        # Format the results for this case into a string with no spaces,\n        # 8 decimal places for floats, and lowercase booleans.\n        case_result_str = (\n            f\"[\"\n            f\"{str(improvement_bool).lower()},\"\n            f\"{max_err_coll:.8f},\"\n            f\"{max_err_stag:.8f},\"\n            f\"{str(alias_coll_bool).lower()},\"\n            f\"{str(alias_stag_bool).lower()}\"\n            f\"]\"\n        )\n        all_results_str.append(case_result_str)\n        \n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3598094"}]}