{"hands_on_practices": [{"introduction": "在计算地球物理学中，数值方法的稳定性是确保模拟结果物理真实性的先决条件。本练习将引导你运用冯·诺依曼稳定性分析这一基本工具，来探究一个典型抛物型偏微分方程——热传导方程的数值解法。通过推导一个常用显式格式（时间向前欧拉，空间中心差分）的放大因子，你将亲手揭示离散化步长 $\\Delta t$ 和 $\\Delta x$ 之间为维持稳定所需满足的严格数学约束。[@problem_id:3573133]", "problem": "在计算地球物理学中，均匀岩石圈柱中的热扩散可以理想化为周期性域 $x\\in[0,L]$ 上的一维热方程 $u_{t}=\\kappa u_{xx}$，其中 $u(x,t)$ 是温度，$\\kappa>0$ 是热扩散系数。考虑一个空间间距为 $\\Delta x$ 的均匀空间网格和一个离散时间步长 $\\Delta t$。令 $u_{j}^{n}$ 表示在网格点 $x_{j}=j\\,\\Delta x$ 和时间 $t_{n}=n\\,\\Delta t$ 处对 $u(x_{j},t_{n})$ 的数值近似。时间导数 $u_{t}$ 用前向欧拉法近似，二阶空间导数 $u_{xx}$ 用二阶中心差分近似：\n$$\nu_{t}(x_{j},t_{n})\\approx \\frac{u_{j}^{n+1}-u_{j}^{n}}{\\Delta t}, \\qquad\nu_{xx}(x_{j},t_{n})\\approx \\frac{u_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}}{\\Delta x^{2}}.\n$$\n从这些基本近似和控制方程 $u_{t}=\\kappa u_{xx}$ 出发，推导 $u_{j}^{n}$ 的全离散更新关系。然后，使用周期性边界条件和傅里叶模态表示 $u_{j}^{n}=\\hat{u}^{n}\\exp(\\mathrm{i}k x_{j})$（其中 $k$ 为实波数），进行 Von Neumann (傅里叶) 稳定性分析，以获得作为 $k$ 的函数的放大因子。根据所有傅里叶模态的幅值都不能增长的要求，推导出确保前向欧拉和二阶中心差分格式稳定性的最大允许时间步长 $\\Delta t_{\\max}$（用 $\\kappa$ 和 $\\Delta x$ 表示）。\n\n提供两个闭式符号表达式：(i) 作为 $k$、$\\Delta x$、$\\Delta t$ 和 $\\kappa$ 的函数的放大因子，以及 (ii) 用 $\\kappa$ 和 $\\Delta x$ 表示的最大稳定时间步长 $\\Delta t_{\\max}$。不要将稳定性条件表示为不等式。", "solution": "控制方程为带周期性边界条件的一维热方程 $u_{t}=\\kappa u_{xx}$。在空间间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格上，我们使用前向欧拉近似来处理 $u_{t}$，使用二阶中心差分来处理 $u_{xx}$。将这些代入 $u_{t}=\\kappa u_{xx}$，得到全离散更新式：\n$$\n\\frac{u_{j}^{n+1}-u_{j}^{n}}{\\Delta t}=\\kappa\\,\\frac{u_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}}{\\Delta x^{2}}.\n$$\n解出 $u_{j}^{n+1}$ 可得\n$$\nu_{j}^{n+1}=u_{j}^{n}+\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\left(u_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}\\right).\n$$\n为了通过 Von Neumann 方法分析稳定性，我们考虑周期性网格上的单个傅里叶模态：\n$$\nu_{j}^{n}=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right), \\qquad x_{j}=j\\,\\Delta x,\n$$\n其中 $k\\in\\mathbb{R}$ 是波数，$\\hat{u}^{n}$ 是在时间层 $n$ 的模态振幅。将此表示代入更新公式，我们计算各项：\n$$\nu_{j+1}^{n}=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j+1}\\right)=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)\\exp\\!\\left(\\mathrm{i}k\\Delta x\\right),\n$$\n$$\nu_{j-1}^{n}=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j-1}\\right)=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)\\exp\\!\\left(-\\mathrm{i}k\\Delta x\\right),\n$$\n且 $u_{j}^{n}=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)$。因此\n$$\nu_{j+1}^{n}-2u_{j}^{n}+u_{j-1}^{n}=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)\\left[\\exp\\!\\left(\\mathrm{i}k\\Delta x\\right)-2+\\exp\\!\\left(-\\mathrm{i}k\\Delta x\\right)\\right].\n$$\n定义放大因子 $G(k)$ 为 $\\hat{u}^{n+1}=G(k)\\,\\hat{u}^{n}$。将傅里叶模态代入更新式并提出公因子 $\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)$，得到\n$$\n\\hat{u}^{n+1}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)=\\hat{u}^{n}\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)\\left\\{1+\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\left[\\exp\\!\\left(\\mathrm{i}k\\Delta x\\right)-2+\\exp\\!\\left(-\\mathrm{i}k\\Delta x\\right)\\right]\\right\\}.\n$$\n消去 $\\exp\\!\\left(\\mathrm{i}k x_{j}\\right)$ 并除以 $\\hat{u}^{n}$，得到\n$$\nG(k)=1+\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\left[\\exp\\!\\left(\\mathrm{i}k\\Delta x\\right)-2+\\exp\\!\\left(-\\mathrm{i}k\\Delta x\\right)\\right].\n$$\n使用恒等式 $\\exp(\\mathrm{i}\\theta)+\\exp(-\\mathrm{i}\\theta)=2\\cos\\theta$，我们简化得到：\n$$\nG(k)=1+\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\left[2\\cos(k\\Delta x)-2\\right]=1+\\frac{2\\kappa\\,\\Delta t}{\\Delta x^{2}}\\left[\\cos(k\\Delta x)-1\\right].\n$$\n使用三角恒等式 $\\cos\\theta-1=-2\\sin^{2}\\!\\left(\\frac{\\theta}{2}\\right)$，我们得到其标准形式\n$$\nG(k)=1-4\\,\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\,\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right).\n$$\n引入无量纲的扩散 Courant–Friedrichs–Lewy (CFL) 数 $r=\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}$。则\n$$\nG(k)=1-4r\\,\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right),\n$$\n其中对于实数 $k$，有 $\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)\\in[0,1]$。为保证显式格式的稳定性，我们要求所有傅里叶模态的幅值不增长，即对所有 $k$ 都有 $|G(k)|\\leq 1$。$G(k)$ 关于 $k$ 的极值出现在 $\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)=0$ 和 $\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)=1$ 处，给出\n$$\nG_{\\max}=1 \\quad \\text{at} \\quad \\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)=0, \\qquad G_{\\min}=1-4r \\quad \\text{at} \\quad \\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)=1.\n$$\n稳定性条件 $|G(k)|\\leq 1$ 可简化为 $|1-4r|\\leq 1$，这等价于\n$$\n-1\\leq 1-4r\\leq 1 \\quad \\Longrightarrow \\quad 0\\leq r\\leq \\frac{1}{2}.\n$$\n因为 $\\kappa>0$ 且 $\\Delta x>0$，允许的时间步长满足\n$$\n\\Delta t\\leq \\frac{\\Delta x^{2}}{2\\kappa}.\n$$\n因此，最大稳定时间步长是\n$$\n\\Delta t_{\\max}=\\frac{\\Delta x^{2}}{2\\kappa}.\n$$\n汇总所求的表达式：作为 $k$ 的函数的放大因子是 $G(k)=1-4\\,\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\,\\sin^{2}\\!\\left(\\frac{k\\Delta x}{2}\\right)$，确保稳定性的最大允许时间步长是 $\\Delta t_{\\max}=\\frac{\\Delta x^{2}}{2\\kappa}$。", "answer": "$$\\boxed{G(k) = 1-4\\,\\frac{\\kappa\\,\\Delta t}{\\Delta x^{2}}\\,\\sin^{2}\\!\\left(\\frac{k\\,\\Delta x}{2}\\right)}$$\n$$\\boxed{\\Delta t_{\\max} = \\frac{\\Delta x^{2}}{2\\,\\kappa}}$$", "id": "3573133"}, {"introduction": "与扩散过程不同，模拟地球物理流体中的物质输运（如示踪剂平流）等双曲型问题时，常会遇到尖锐界面或激波，这对数值格式提出了更高的要求。本练习将带领你实现并评估总变差递减（TVD）格式，这是一种旨在无伪振荡地捕捉间断的高分辨率方法。你将通过编程实践，比较不同的通量限制器（flux limiter）在处理尖锐锋面和光滑波形时的表现，并量化分析它们如何影响解的精度和收敛阶。[@problem_id:3573134]", "problem": "考虑在周期性域 $x\\in[0,1]$ 上的被动示踪剂浓度 $u(x,t)$ 的保守形式一维线性平流方程 $$\\partial_t u + a\\,\\partial_x u = 0,$$。设平流速度为常数 $a=1$，初始数据表示一个类似温跃层的陡峭锋面或一个光滑波。目标是设计、实现并评估一个二阶、显式、保单调的总变差递减（TVD）格式的精度、稳定性和收敛性。该格式使用通量限制器来防止伪振荡，同时在光滑区域保持高分辨率。您必须量化陡峭锋面附近的精度，并展示当网格间距 $\\Delta x\\to 0$ 时由限制器引起的阶数降低。\n\n使用包含 $N$ 个单元的均匀网格，单元中心位于 $x_i=(i+1/2)\\Delta x$，并采用周期性边界条件。设 $\\Delta x = 1/N$。将解演化至最终时间 $T=0.5$，使用恒定的 Courant-Friedrichs-Lewy (CFL) 数 $\\nu = a\\,\\Delta t/\\Delta x$。在精度研究中选择 $\\nu=0.5$，在单调性压力测试中选择 $\\nu=0.95$。假设 $a>0$，因此迎风方向为从左到右。\n\n您必须使用以下每个经过充分测试的限制器函数 $\\phi(r)$ 来实现一个二阶 TVD 通量限制器方法，其中 $r$ 是连续离散梯度的比率：\n- Minmod 限制器：$$\\phi_{\\mathrm{minmod}}(r)=\\max\\left(0,\\min(1,r)\\right).$$\n- Van Leer 限制器：$$\\phi_{\\mathrm{van\\,Leer}}(r)=\\frac{r+|r|}{1+|r|}.$$\n- Superbee 限制器：$$\\phi_{\\mathrm{superbee}}(r)=\\max\\left(0,\\min(2r,1),\\min(r,2)\\right).$$\n\n为进行精度评估，考虑两种初始条件：\n1. 陡峭锋面（类似温跃层）：$$u(x,0)=\\begin{cases} 1, & x \\in [0.3, 0.7] \\\\ 0, & \\text{otherwise} \\end{cases}$$，在 $x=0$ 和 $x=1$ 处具有周期性。时刻 $T$ 的精确解是初始剖面平移 $aT$ 并模1：$$u_{\\mathrm{exact}}(x,T)=u(x-aT,0)\\ \\text{with periodic wrapping.}$$\n2. 光滑波：$$u(x,0)=\\sin(2\\pi x).$$ 时刻 $T$ 的精确解是 $$u_{\\mathrm{exact}}(x,T)=\\sin\\left(2\\pi(x-aT)\\right).$$\n\n将时刻 $T$ 的离散全局 $\\ell^1$ 误差定义为 $$E_{\\ell^1}^{\\mathrm{global}}=\\sum_i \\left|u_i(T)-u_{\\mathrm{exact}}(x_i,T)\\right|\\,\\Delta x.$$ 对于陡峭锋面情况，额外定义一个局部 $\\ell^1$ 误差，该误差限定在平流后的锋面位置 $x_f^{(1)}=0.3+T\\ (\\mathrm{mod}\\ 1)$ 和 $x_f^{(2)}=0.7+T\\ (\\mathrm{mod}\\ 1)$ 周围两个宽度为 $W=0.05$ 的邻域内：\n$$E_{\\ell^1}^{\\mathrm{front}}=\\sum_{i:\\,d_{\\mathrm{per}}(x_i,x_f^{(1)})\\le W/2\\ \\text{or}\\ d_{\\mathrm{per}}(x_i,x_f^{(2)})\\le W/2}\\left|u_i(T)-u_{\\mathrm{exact}}(x_i,T)\\right|\\,\\Delta x,$$\n其中周期性距离为 $$d_{\\mathrm{per}}(x,y)=\\min\\left(|x-y|,\\,1-|x-y|\\right).$$\n\n为量化收敛率，对于每个限制器和每个初始条件，在网格尺寸 $N\\in\\{50,100,200,400\\}$ 和 $\\nu=0.5$ 的条件下计算 $E_{\\ell^1}$，并通过对 $\\log E_{\\ell^1}$ 与 $\\log \\Delta x$ 进行线性回归来拟合经验收敛阶 $p$，即 $$\\log E_{\\ell^1}\\approx p\\,\\log(\\Delta x)+\\log C.$$ 报告使用 $E_{\\ell^1}^{\\mathrm{front}}$ 计算的陡峭锋面的 $p_{\\mathrm{front}}$ 和使用 $E_{\\ell^1}^{\\mathrm{global}}$ 计算的光滑波的 $p_{\\mathrm{smooth}}$。\n\n为检验稳定性和单调性，使用陡峭鋒面初始条件，在 $N=100$ 的网格上设置 $\\nu=0.95$，检查在时刻 $T$ 的以下性质：相对于初始界限无上冲或下冲，以及总变差非增。具体来说，计算离散总变差 $$\\mathrm{TV}(u)=\\sum_i |u_{i+1}-u_i|,$$ 并验证布尔条件 $$\\left(\\min_i u_i(T)\\ge \\min_x u(x,0)-10^{-12}\\right)\\ \\wedge\\ \\left(\\max_i u_i(T)\\le \\max_x u(x,0)+10^{-12}\\right)\\ \\wedge\\ \\left(\\mathrm{TV}(u(T))\\le \\mathrm{TV}(u(0))+10^{-12}\\right).$$ 为每个限制器返回一个布尔值，指示在压力测试下是否保持此保单调性质。\n\n测试套件和输出规范：\n- 使用网格尺寸 $N\\in\\{50,100,200,400\\}$ 和 $\\nu=0.5$ 来计算陡峭锋面情况下每个限制器的 $p_{\\mathrm{front}}$ 和光滑波情况下每个限制器的 $p_{\\mathrm{smooth}}$。\n- 使用 $N=100$ 和 $\\nu=0.95$ 来计算陡峭锋面情况下每个限制器的单调性布尔值。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，顺序为 $$\\left[p_{\\mathrm{front}}^{\\mathrm{minmod}},p_{\\mathrm{front}}^{\\mathrm{van\\,Leer}},p_{\\mathrm{front}}^{\\mathrm{superbee}},p_{\\mathrm{smooth}}^{\\mathrm{minmod}},p_{\\mathrm{smooth}}^{\\mathrm{van\\,Leer}},p_{\\mathrm{smooth}}^{\\mathrm{superbee}},M_{\\mathrm{minmod}},M_{\\mathrm{van\\,Leer}},M_{\\mathrm{superbee}}\\right],$$ 其中每个 $p$ 是一个实数，每个 $M$ 是一个布尔值。不涉及物理单位；所有量均为无量纲。", "solution": "用户提供了一个计算物理领域中适定且有科学依据的问题。它要求实现和分析用于一维线性平流方程的总变差递减（TVD）格式。该问题是有效的，可以按所述方式解决。\n\n该问题要求设计和分析一个用于保守形式线性平流方程的二阶显式TVD格式：\n$$\n\\partial_t u + \\partial_x (au) = 0\n$$\n由于平流速度 $a$ 是一个常数（$a=1$），方程可简化为 $\\partial_t u + a \\partial_x u = 0$。我们将使用有限体积法，在一个具有 $N$ 个单元的均匀周期性网格上进行计算，单元宽度为 $\\Delta x = 1/N$。单元中心为 $x_i = (i+1/2)\\Delta x$，其中 $i=0, \\dots, N-1$。设 $u_i(t)$ 为在时刻 $t$ 时单元 $i$ 中解的单元平均值。半离散有限体积公式为：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\n其中 $F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面处的数值通量。\n\n针对此问题，我们采用一个高分辨率通量限制器格式。数值通量 $F_{i+1/2}$ 是通过一个受限的高阶项来修正一阶迎风通量而构造的。由于 $a=1>0$，迎风方向为从左到右。通量由下式给出：\n$$\nF_{i+1/2} = F_{i+1/2}^{\\text{low}} + \\Phi_{i+1/2}\n$$\n低阶通量是稳定且单调的一阶迎风通量：\n$$\nF_{i+1/2}^{\\text{low}} = a u_i = u_i\n$$\n修正项 $\\Phi_{i+1/2}$ 基于一个更高阶的通量，例如 Lax-Wendroff 通量。Lax-Wendroff 通量与迎风通量之差可以证明为 $\\frac{a}{2}(1 - \\nu)(u_{i+1} - u_i)$，其中 $\\nu = a \\Delta t / \\Delta x$ 是 Courant 数。为确保 TVD 性质，此修正由一个通量限制器函数 $\\phi(r)$进行调节：\n$$\n\\Phi_{i+1/2} = \\phi(r_i) \\left( F_{i+1/2}^{\\text{high}} - F_{i+1/2}^{\\text{low}} \\right) = \\phi(r_i) \\frac{a}{2}(1 - \\nu)(u_{i+1} - u_i)\n$$\n项 $r_i$ 是在界面 $i+1/2$ 的迎风侧定义的连续解梯度的比率：\n$$\nr_i = \\frac{u_i - u_{i-1}}{u_{i+1} - u_i}\n$$\n选择此定义是因为 $a>0$。因此，通量为：\n$$\nF_{i+1/2} = a u_i + \\frac{a}{2}(1-\\nu) \\phi(r_i) (u_{i+1} - u_i)\n$$\n我们使用显式向前欧拉法进行时间积分：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2}^n - F_{i-1/2}^n \\right)\n$$\n其中通量是使用时间层 $n$ 的单元平均值 $u^n$ 计算的。代入通量表达式并使用 $\\nu = a\\Delta t / \\Delta x$，我们得到更新公式：\n$$\nu_i^{n+1} = u_i^n - \\nu(u_i^n - u_{i-1}^n) - \\frac{\\nu}{2}(1-\\nu) \\left[ \\phi(r_i^n)(u_{i+1}^n - u_i^n) - \\phi(r_{i-1}^n)(u_i^n - u_{i-1}^n) \\right]\n$$\n这个显式更新公式将被实现。更新 $u_i$ 的模板涉及到单元 $i-2, i-1, i, i+1$，因此通过使用虚拟单元来处理周期性边界条件。当 $r_i$ 的分母为零时需要特别处理。如果分子也为零，则解是局部平坦的，我们设置 $r_i=1$，这对应于使用完整的二阶修正。如果分母为零但分子不为零，则存在一个阶跃间断，$r_i$ 实际上是无穷大。在这种情况下，我们用一个大数来近似 $r_i$ 的行为，指定的限制器可以正确处理这种情况。\n\n过程如下：\n1.  **收敛性分析**：对于三种限制器（Minmod、Van Leer、Superbee）和两种初始条件（陡峭锋面、光滑波）中的每一种，我们在网格尺寸 $N \\in \\{50, 100, 200, 400\\}$ 上进行模拟。CFL 数固定为 $\\nu=0.5$。\n    - 对于陡峭锋面，我们计算在平流后的间断点周围一个小窗口内的局部误差 $E_{\\ell^1}^{\\mathrm{front}}$。\n    - 对于光滑波，我们计算全局误差 $E_{\\ell^1}^{\\mathrm{global}}$。\n    - 然后通过对 $\\log(E_{\\ell^1})$ 与 $\\log(\\Delta x)$ 进行线性回归来估计收敛阶 $p$。这条线的斜率即为 $p$。对于TVD格式，我们预期在陡峭锋面情况下 $p \\approx 1$（由于间断点），而在光滑情况下 $p \\approx 2$（因为格式在光滑区域是二阶的）。\n\n2.  **单调性测试**：对于每个限制器，我们使用陡峭锋面初始条件、一个粗糙网格（$N=100$）和一个高 CFL 数（$\\nu=0.95$，接近稳定性极限）来进行“压力测试”。然后我们验证最终时间 $T=0.5$ 的解是否满足三个条件：\n    - 无下冲：$\\min_i u_i(T) \\ge \\min_x u(x,0) - \\epsilon$。\n    - 无上冲：$\\max_i u_i(T) \\le \\max_x u(x,0) + \\epsilon$。\n    - 总变差非增：$\\mathrm{TV}(u(T)) \\le \\mathrm{TV}(u(0)) + \\epsilon$。\n    此处 $\\epsilon=10^{-12}$ 是一个用于浮点运算的小容差。为每个限制器编译一个布尔结果。`True` 值表示所有三个性质都成立，确认该格式在这些条件下是保单调的。\n\n最终输出是一个有序列表，包含九个计算出的量：三个锋面情况的收敛阶，三个光滑情况的收敛阶，以及三个来自单调性测试的布尔值。", "answer": "```python\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation suite and generate the final output.\n    \"\"\"\n\n    # --- Limiter Functions ---\n    def minmod_limiter(r):\n        return np.maximum(0, np.minimum(1, r))\n\n    def van_leer_limiter(r):\n        return (r + np.abs(r)) / (1 + np.abs(r) + 1e-12)\n\n    def superbee_limiter(r):\n        # Implements max(0, min(1, 2r), min(2, r))\n        # max(a, b, c) is implemented via np.amax on a stack of arrays\n        stack = np.array([\n            np.zeros_like(r),\n            np.minimum(1, 2 * r),\n            np.minimum(2, r)\n        ])\n        return np.amax(stack, axis=0)\n\n    limiters = {\n        \"minmod\": minmod_limiter,\n        \"van Leer\": van_leer_limiter,\n        \"superbee\": superbee_limiter,\n    }\n\n    # --- Initial Conditions and Exact Solutions ---\n    def ic_sharp(x):\n        return np.where((x >= 0.3) & (x <= 0.7), 1.0, 0.0)\n\n    def ic_smooth(x):\n        return np.sin(2 * np.pi * x)\n\n    def exact_sharp(x, t, a):\n        x_shifted = (x - a * t) % 1.0\n        return ic_sharp(x_shifted)\n\n    def exact_smooth(x, t, a):\n        x_shifted = x - a * t\n        return np.sin(2 * np.pi * x_shifted)\n\n    # --- Core Simulation ---\n    def run_simulation(N, nu, T, ic_func, limiter_func):\n        a = 1.0\n        dx = 1.0 / N\n        x = (np.arange(N) + 0.5) * dx\n        u = ic_func(x)\n\n        dt = nu * dx / a\n        n_steps = int(np.ceil(T / dt))\n        dt = T / n_steps  # Adjust dt to hit T exactly\n        \n        current_nu = a * dt / dx\n\n        for _ in range(n_steps):\n            # Pad array with 2 ghost cells on each side for periodic BCs\n            u_padded = np.pad(u, 2, 'wrap')\n\n            # Calculate successive gradients for r_i ratio\n            # r_i = (u_i - u_{i-1}) / (u_{i+1} - u_i)\n            # Vectorized calculation for i = 0, ..., N-1\n            up_grad = u_padded[2:N+2] - u_padded[1:N+1]\n            down_grad = u_padded[3:N+3] - u_padded[2:N+2]\n\n            # Calculate r, carefully handling division by zero\n            r = np.zeros(N)\n            denom_nonzero = np.abs(down_grad) > 1e-12\n            r[denom_nonzero] = up_grad[denom_nonzero] / down_grad[denom_nonzero]\n\n            # Case: denominator is zero\n            denom_zero = ~denom_nonzero\n            num_zero = np.abs(up_grad) < 1e-12\n            \n            # If num and den are zero, region is flat, r=1 is appropriate\n            r[denom_zero & num_zero] = 1.0\n            # If den is zero but num is not, it's a step. r is infinite.\n            # Use a large number approximation. Limiters handle large r.\n            r[denom_zero & ~num_zero] = 1.0e6\n\n            # Apply limiter\n            phi_r = limiter_func(r)\n\n            # Update rule using vectorized operations\n            # u_i^{n+1} = u_i^n - nu*(u_i - u_{i-1}) - \n            #   0.5*nu*(1-nu)*[phi(r_i)*(u_{i+1}-u_i) - phi(r_{i-1})*(u_i-u_{i-1})]\n            upwind_term = current_nu * up_grad\n            correction_term = 0.5 * current_nu * (1.0 - current_nu) * \\\n                              (phi_r * down_grad - np.roll(phi_r, 1) * up_grad)\n            u = u - upwind_term - correction_term\n\n        return x, u\n\n    # --- Analysis Functions ---\n    def calculate_convergence_order(limiter_func, ic_func, exact_func, error_type):\n        Ns = [50, 100, 200, 400]\n        nu = 0.5\n        T = 0.5\n        a = 1.0\n        \n        log_dx = []\n        log_err = []\n\n        for N in Ns:\n            dx = 1.0 / N\n            x, u_final = run_simulation(N, nu, T, ic_func, limiter_func)\n            u_ex = exact_func(x, T, a)\n            \n            error = 0\n            if error_type == 'front':\n                W = 0.05\n                xf1, xf2 = (0.3 + T) % 1.0, (0.7 + T) % 1.0\n                dist1 = np.abs(x - xf1)\n                d_per1 = np.minimum(dist1, 1.0 - dist1)\n                dist2 = np.abs(x - xf2)\n                d_per2 = np.minimum(dist2, 1.0 - dist2)\n                mask = (d_per1 <= W / 2) | (d_per2 <= W / 2)\n                error = np.sum(np.abs(u_final - u_ex)[mask]) * dx\n            else: # global\n                error = np.sum(np.abs(u_final - u_ex)) * dx\n\n            if error > 1e-15: # Avoid log(0)\n                log_dx.append(np.log(dx))\n                log_err.append(np.log(error))\n        \n        if len(log_dx) < 2: return np.nan\n        \n        slope, _, _, _, _ = stats.linregress(log_dx, log_err)\n        return slope\n\n    def check_monotonicity(limiter_func):\n        N = 100\n        nu = 0.95\n        T = 0.5\n        tol = 1.e-12\n\n        dx = 1.0/N\n        x = (np.arange(N) + 0.5) * dx\n        u0 = ic_sharp(x)\n        \n        _, u_final = run_simulation(N, nu, T, ic_sharp, limiter_func)\n\n        min_u0, max_u0 = np.min(u0), np.max(u0)\n        tv_u0 = np.sum(np.abs(np.roll(u0, -1) - u0))\n        \n        min_uT, max_uT = np.min(u_final), np.max(u_final)\n        tv_uT = np.sum(np.abs(np.roll(u_final, -1) - u_final))\n        \n        no_undershoot = (min_uT >= min_u0 - tol)\n        no_overshoot = (max_uT <= max_u0 + tol)\n        tv_non_increasing = (tv_uT <= tv_u0 + tol)\n        \n        return no_undershoot and no_overshoot and tv_non_increasing\n\n    # --- Main Execution Logic ---\n    results = []\n\n    # Convergence orders for the sharp front\n    for name in [\"minmod\", \"van Leer\", \"superbee\"]:\n        p_front = calculate_convergence_order(limiters[name], ic_sharp, exact_sharp, 'front')\n        results.append(p_front)\n\n    # Convergence orders for the smooth wave\n    for name in [\"minmod\", \"van Leer\", \"superbee\"]:\n        p_smooth = calculate_convergence_order(limiters[name], ic_smooth, exact_smooth, 'global')\n        results.append(p_smooth)\n\n    # Monotonicity checks\n    for name in [\"minmod\", \"van Leer\", \"superbee\"]:\n        monotonic = check_monotonicity(limiters[name])\n        results.append(monotonic)\n\n    # --- Format and Print Output ---\n    # Convert booleans to lowercase 'true'/'false' as per Python's str()\n    formatted_results = [f\"{r:.6f}\" if isinstance(r, float) else str(r).lower() for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3573134"}]}