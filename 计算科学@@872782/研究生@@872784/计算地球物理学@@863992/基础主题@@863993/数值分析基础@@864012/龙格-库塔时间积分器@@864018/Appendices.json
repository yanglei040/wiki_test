{"hands_on_practices": [{"introduction": "掌握龙格-库塔方法的第一步是理解如何将布彻表 (Butcher tableau) 转化为具体的计算步骤。这个练习 [@problem_id:3613997] 提供了一个基础实践，要求您使用显式中点法，为一个简单的常微分方程手动推导单步更新过程。完成此练习将巩固您对系数矩阵 $A$、权重 $b$ 和节点 $c$ 各自作用的理解。", "problem": "在计算地球物理学中，随时间变化的偏微分方程的半离散格式通常会产生常微分方程（ODE）。考虑一个网格点上的局部模型，该模型由标量ODE $y'(t)=t+y(t)$ 描述，其中 $y(t)$ 表示一个状态变量（例如，一个局部线性化的预报量）。令 $y_n$ 表示在时间 $t_n$ 时对 $y(t_n)$ 的数值近似，并令 $\\Delta t$ 为一个正时间步长，使得 $t_{n+1}=t_n+\\Delta t$。\n\n你需要使用一个由中点法定义的2阶段Runge–Kutta方法将 $y_n$ 推进到 $y_{n+1}$，该方法的Butcher tableau由节点 $c=\\left(0,\\frac{1}{2}\\right)$、严格下三角矩阵\n$$\nA=\\begin{pmatrix}\n0  0 \\\\\n\\frac{1}{2}  0\n\\end{pmatrix},\n$$\n和权重 $b=\\left(0,1\\right)$ 指定。\n\n仅从Butcher tableau为应用于 $y'(t)=f(t,y)$（其中 $f(t,y)=t+y$）的Runge–Kutta积分器定义了阶段横坐标、内部阶段耦合和最终权重的解释出发，推导从 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的单步更新映射，并用 $y_n$、$t_n$ 和 $\\Delta t$ 显式计算 $y_{n+1}$。\n\n请以 $y_n$、$t_n$ 和 $\\Delta t$ 的单一闭式解析表达式的形式给出你的最终结果。最终表达式无需四舍五入，也不应包含任何单位。", "solution": "用户要求使用指定的2阶段Runge-Kutta方法，为一个给定的常微分方程（ODE）推导单步更新映射。\n\n首先对问题进行验证。\n**已知条件：**\n- ODE: $y'(t) = t + y(t)$，它定义了函数 $f(t, y) = t + y$。\n- 时间离散化: $t_{n+1} = t_n + \\Delta t$，时间步长 $\\Delta t > 0$。\n- $y(t_n)$ 的数值近似为 $y_n$。\n- 一个2阶段Runge-Kutta方法由以下Butcher tableau定义：\n  - 横坐标: $c = \\begin{pmatrix} c_1 \\\\ c_2 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ \\frac{1}{2} \\end{pmatrix}$\n  - 矩阵: $A = \\begin{pmatrix} a_{11}  a_{12} \\\\ a_{21}  a_{22} \\end{pmatrix} = \\begin{pmatrix} 0  0 \\\\ \\frac{1}{2}  0 \\end{pmatrix}$\n  - 权重: $b = \\begin{pmatrix} b_1  b_2 \\end{pmatrix} = \\begin{pmatrix} 0  1 \\end{pmatrix}$\n\n**验证：**\n- **科学依据**：该问题是一个成熟的数值方法（Runge-Kutta）在一个简单的一阶线性ODE上的标准应用。所有组成部分在数学上和计算上都是合理的。\n- **适定性**：该问题提供了推导下一个时间步的唯一解析表达式所需的所有必要信息（ODE、数值方法的系数和初始状态）。\n- **客观性**：该问题以精确、正式的语言陈述，没有歧义或主观性。\n\n该问题是有效的，因为它具有科学依据、适定性且客观。没有矛盾、缺失信息或伪科学主张。我们可以继续进行求解。\n\n用于求解ODE $y'(t) = f(t, y(t))$ 的一个s阶段Runge-Kutta方法的通用公式如下：\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^{s} b_i k_i\n$$\n其中阶段导数 $k_i$ 的计算方式如下：\n$$\nk_i = f\\left(t_n + c_i \\Delta t, y_n + \\Delta t \\sum_{j=1}^{s} a_{ij} k_j\\right)\n$$\n对于这个问题，阶段数 $s=2$。我们可以写出阶段 $k_1$ 和 $k_2$ 的方程。\n\n**阶段 1：**\n对于 $i=1$，我们使用 $c_1=0$、$a_{11}=0$ 和 $a_{12}=0$。\n$$\nk_1 = f\\left(t_n + c_1 \\Delta t, y_n + \\Delta t (a_{11} k_1 + a_{12} k_2)\\right)\n$$\n$$\nk_1 = f\\left(t_n + 0 \\cdot \\Delta t, y_n + \\Delta t (0 \\cdot k_1 + 0 \\cdot k_2)\\right)\n$$\n$$\nk_1 = f(t_n, y_n)\n$$\n代入给定的函数 $f(t, y) = t + y$，我们得到：\n$$\nk_1 = t_n + y_n\n$$\n\n**阶段 2：**\n对于 $i=2$，我们使用 $c_2=\\frac{1}{2}$、$a_{21}=\\frac{1}{2}$ 和 $a_{22}=0$。矩阵 $A$ 是严格下三角的，所以该方法是显式的，并且 $k_2$ 的计算仅依赖于 $k_1$。\n$$\nk_2 = f\\left(t_n + c_2 \\Delta t, y_n + \\Delta t (a_{21} k_1 + a_{22} k_2)\\right)\n$$\n$$\nk_2 = f\\left(t_n + \\frac{1}{2} \\Delta t, y_n + \\Delta t \\left(\\frac{1}{2} k_1 + 0 \\cdot k_2\\right)\\right)\n$$\n$$\nk_2 = f\\left(t_n + \\frac{1}{2} \\Delta t, y_n + \\frac{1}{2} \\Delta t \\cdot k_1\\right)\n$$\n现在，我们将 $k_1 = t_n + y_n$ 的表达式代入 $k_2$ 的公式中：\n$$\nk_2 = f\\left(t_n + \\frac{\\Delta t}{2}, y_n + \\frac{\\Delta t}{2}(t_n + y_n)\\right)\n$$\n使用 $f(t,y) = t+y$，我们代入其参数来计算函数值：\n$$\nk_2 = \\left(t_n + \\frac{\\Delta t}{2}\\right) + \\left(y_n + \\frac{\\Delta t}{2}(t_n + y_n)\\right)\n$$\n展开并合并同类项：\n$$\nk_2 = t_n + y_n + \\frac{\\Delta t}{2} + \\frac{\\Delta t}{2}t_n + \\frac{\\Delta t}{2}y_n\n$$\n$$\nk_2 = (t_n + y_n)\\left(1 + \\frac{\\Delta t}{2}\\right) + \\frac{\\Delta t}{2}\n$$\n\n**最终更新：**\n使用权重 $b_1=0$ 和 $b_2=1$ 构建 $y_{n+1}$ 的更新公式：\n$$\ny_{n+1} = y_n + \\Delta t (b_1 k_1 + b_2 k_2)\n$$\n$$\ny_{n+1} = y_n + \\Delta t (0 \\cdot k_1 + 1 \\cdot k_2)\n$$\n$$\ny_{n+1} = y_n + \\Delta t \\cdot k_2\n$$\n代入推导出的 $k_2$ 表达式：\n$$\ny_{n+1} = y_n + \\Delta t \\left[ \\left(t_n + \\frac{\\Delta t}{2}\\right) + \\left(y_n + \\frac{\\Delta t}{2}(t_n + y_n)\\right) \\right]\n$$\n现在，我们展开并简化表达式，以得到用 $y_n$、$t_n$ 和 $\\Delta t$ 表示的 $y_{n+1}$。\n$$\ny_{n+1} = y_n + \\Delta t \\left( t_n + y_n + \\frac{\\Delta t}{2} + \\frac{t_n \\Delta t}{2} + \\frac{y_n \\Delta t}{2} \\right)\n$$\n将外层的 $\\Delta t$ 分配进去：\n$$\ny_{n+1} = y_n + t_n \\Delta t + y_n \\Delta t + \\frac{(\\Delta t)^2}{2} + \\frac{t_n (\\Delta t)^2}{2} + \\frac{y_n (\\Delta t)^2}{2}\n$$\n最后，我们按 $y_n$、$t_n$ 和剩余常数项对各项进行分组，以提供一个单一的闭式表达式。\n$$\ny_{n+1} = y_n \\left(1 + \\Delta t + \\frac{(\\Delta t)^2}{2}\\right) + t_n \\left(\\Delta t + \\frac{(\\Delta t)^2}{2}\\right) + \\frac{(\\Delta t)^2}{2}\n$$\n这个表达式可以被重新整理，以突显其与解的泰勒级数展开的关系。\n$$\ny_{n+1} = y_n + (t_n + y_n)\\Delta t + \\frac{1}{2}(t_n + y_n + 1)(\\Delta t)^2\n$$\n两种形式是等价的。后一种形式更紧凑，并显式地显示了直到 $(\\Delta t)^2$ 阶的项。这就是所要求的 $y_{n+1}$ 的闭式解析表达式。", "answer": "$$\n\\boxed{y_n + (t_n + y_n)\\Delta t + \\frac{1}{2}(t_n + y_n + 1)(\\Delta t)^2}\n$$", "id": "3613997"}, {"introduction": "选择时间积分器的一个关键考量是其稳定性，尤其是在处理地球物理学中常见的刚性系统时。在这个问题中 [@problem_id:3613965]，您将分析和比较一个显式方法 (RK4) 和一个隐式方法（中点法）在求解一个典型刚性方程时的性能。这项实践将揭示稳定性函数对计算效率的深远影响。", "problem": "在计算地球物理学中，当对扩散或粘弹性偏微分方程（PDEs）进行半离散化时，会出现刚性常微分方程（ODEs）。考虑用于刚性检验的标量Dahlquist方程，其形式为 $y' = -\\beta y$，其中 $\\beta \\gg 1$。假设使用两种时间积分器来求解此ODE：经典的显式四阶龙格-库塔（RK4）方法和隐式中点法（即一阶高斯-勒让德龙格-库塔方法）。设时间步长固定为 $\\Delta t = \\beta^{-1}$。\n\n从龙格-库塔方法的定义及其在线性检验方程 $y'=\\lambda y$ 上的应用出发，为每种方法推导其单步放大因子 $R(z)$，其中 $z = \\lambda \\Delta t$。计算在 $z=-1$ 时 $R(z)$ 的模，然后为每种方法确定将解的量值减小 $10^{-k}$ 倍（即达到 $\\lvert y_n \\rvert \\le 10^{-k} \\lvert y_0 \\rvert$）所需的步数 $n$ 的精确解析表达式（忽略整数向上取整）。请将最终答案表示为仅含自然对数的 $k$ 的函数，且不进行任何数值舍入。以数对 $\\big(n_{\\mathrm{RK4}}(k),\\, n_{\\mathrm{IM}}(k)\\big)$ 的形式给出您的最终答案，其中下标分别代表显式RK4方法和隐式中点法。", "solution": "用户提供了一个问题陈述，在进行求解之前需要对其进行验证。\n\n### 第1步：提取已知条件\n- 常微分方程（ODE）是Dahlquist刚性检验方程：$y' = -\\beta y$，条件为 $\\beta \\gg 1$。\n- 这是线性检验方程 $y' = \\lambda y$ 的一个特例，其中系数 $\\lambda = -\\beta$。\n- 积分的时间步长固定为 $\\Delta t = \\beta^{-1}$。\n- 需要分析两种时间积分方法：\n    1. 经典的显式四阶龙格-库塔（RK4）方法。\n    2. 隐式中点法（一阶高斯-勒让德龙格-库塔方法）。\n- 任务是为每种方法推导单步放大因子 $R(z)$，其中 $z = \\lambda \\Delta t$。\n- 然后，根据问题参数给定的 $z$ 的具体值，计算 $R(z)$ 的模。\n- 最后，确定满足条件 $\\lvert y_n \\rvert \\le 10^{-k} \\lvert y_0 \\rvert$ 所需的步数 $n$。这个数 $n$ 应该是一个关于 $k$ 的精确解析表达式，忽略任何整数向上取整函数。\n- 最终答案应为一个数对 $\\big(n_{\\mathrm{RK4}}(k),\\, n_{\\mathrm{IM}}(k)\\big)$。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据：** 该问题是常微分方程数值分析中的一个标准练习。Dahlquist检验方程、龙格-库塔方法、稳定性函数（放大因子）及其在刚性问题中的应用是该领域的基本概念。计算地球物理学的背景是恰当的，因为刚性系统在该领域很常见。该问题在科学上是合理的。\n- **适定性：** 该问题提供了所有必要信息。ODE、时间步长和所用方法都有明确定义。目标是具体且可量化的。$z$ 的值由已知条件明确确定：$z = \\lambda \\Delta t = (-\\beta)(\\beta^{-1}) = -1$。可以推导出唯一且有意义的解。\n- **客观性：** 问题以精确、客观、技术性的语言表述，没有任何主观性或偏见。\n\n### 第3步：结论与行动\n问题是有效的。它具有科学依据，是适定的、客观的且自洽的。可以开始求解过程。\n\n### 求解推导\n\n使用龙格-库塔方法对检验方程 $y' = \\lambda y$ 进行数值求解，经过一个时间步长 $\\Delta t$ 后，解可以表示为 $y_{n+1} = R(z) y_n$，其中 $z = \\lambda \\Delta t$，$R(z)$ 是该方法的稳定性函数或放大因子。经过 $n$ 步后，解由 $y_n = (R(z))^n y_0$ 给出。\n\n问题要求找到将解的量值减小 $10^{-k}$ 倍所需的步数 $n$。这个条件在数学上表述为：\n$$ \\lvert y_n \\rvert \\le 10^{-k} \\lvert y_0 \\rvert $$\n代入 $y_n$ 的表达式：\n$$ \\lvert (R(z))^n y_0 \\rvert \\le 10^{-k} \\lvert y_0 \\rvert $$\n$$ \\lvert R(z) \\rvert^n \\lvert y_0 \\rvert \\le 10^{-k} \\lvert y_0 \\rvert $$\n假设 $y_0 \\ne 0$，我们可以两边同除以 $\\lvert y_0 \\rvert$：\n$$ \\lvert R(z) \\rvert^n \\le 10^{-k} $$\n为了求解 $n$，我们对两边取自然对数：\n$$ n \\ln(\\lvert R(z) \\rvert) \\le \\ln(10^{-k}) $$\n$$ n \\ln(\\lvert R(z) \\rvert) \\le -k \\ln(10) $$\n对于一个衰减（稳定）的解，必须有 $\\lvert R(z) \\rvert  1$，这意味着 $\\ln(\\lvert R(z) \\rvert)$ 是负数。除以这个负数会使不等号反向：\n$$ n \\ge \\frac{-k \\ln(10)}{\\ln(\\lvert R(z) \\rvert)} = \\frac{k \\ln(10)}{-\\ln(\\lvert R(z) \\rvert)} = \\frac{k \\ln(10)}{\\ln(\\lvert R(z) \\rvert^{-1})} = \\frac{k \\ln(10)}{\\ln(1/\\lvert R(z) \\rvert)} $$\n问题要求的是所需的步数，并忽略整数向上取整，因此我们取等号：\n$$ n = \\frac{k \\ln(10)}{\\ln(1/\\lvert R(z) \\rvert)} $$\n根据问题陈述，$\\lambda = -\\beta$ 且 $\\Delta t = \\beta^{-1}$，所以 $z = \\lambda \\Delta t = (-\\beta)(\\beta^{-1}) = -1$。我们将对两种方法都使用 $z=-1$。\n\n**1. 经典的显式四阶龙格-库塔（RK4）方法**\n\n经典RK4方法的稳定性函数是指数函数的四阶泰勒多项式：\n$$ R_{\\mathrm{RK4}}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!} $$\n我们计算该函数在 $z = -1$ 处的值：\n$$ R_{\\mathrm{RK4}}(-1) = 1 + (-1) + \\frac{(-1)^2}{2} + \\frac{(-1)^3}{6} + \\frac{(-1)^4}{24} $$\n$$ R_{\\mathrm{RK4}}(-1) = 1 - 1 + \\frac{1}{2} - \\frac{1}{6} + \\frac{1}{24} $$\n$$ R_{\\mathrm{RK4}}(-1) = \\frac{12}{24} - \\frac{4}{24} + \\frac{1}{24} = \\frac{12 - 4 + 1}{24} = \\frac{9}{24} = \\frac{3}{8} $$\n其模为 $\\lvert R_{\\mathrm{RK4}}(-1) \\rvert = \\frac{3}{8}$。\n现在，我们计算步数 $n_{\\mathrm{RK4}}$：\n$$ n_{\\mathrm{RK4}}(k) = \\frac{k \\ln(10)}{\\ln(1/\\lvert R_{\\mathrm{RK4}}(-1) \\rvert)} = \\frac{k \\ln(10)}{\\ln(1/(3/8))} = \\frac{k \\ln(10)}{\\ln(8/3)} $$\n\n**2. 隐式中点法**\n\n隐式中点法是一种单阶龙格-库塔方法，其Butcher表为 $c_1 = 1/2$，$a_{11} = 1/2$ 和 $b_1 = 1$。单阶隐式龙格-库塔方法的稳定性函数 $R(z)$ 推导如下：\n对于方程 $y'=\\lambda y$，阶值 $k_1$ 为 $k_1 = \\lambda(y_n + \\Delta t a_{11} k_1)$。\n$k_1 = \\lambda y_n + a_{11} (\\lambda \\Delta t) k_1 = \\lambda y_n + a_{11} z k_1$。\n求解 $k_1$：$k_1(1 - a_{11} z) = \\lambda y_n \\implies k_1 = \\frac{\\lambda y_n}{1 - a_{11} z}$。\n解的更新公式为 $y_{n+1} = y_n + \\Delta t b_1 k_1 = y_n + b_1 (\\lambda \\Delta t) \\frac{y_n}{1 - a_{11} z}$。\n因此，放大因子为 $R(z) = \\frac{y_{n+1}}{y_n} = 1 + \\frac{b_1 z}{1 - a_{11} z}$。\n对于隐式中点法，有 $a_{11} = 1/2$ 和 $b_1=1$：\n$$ R_{\\mathrm{IM}}(z) = 1 + \\frac{z}{1 - z/2} = \\frac{(1 - z/2) + z}{1 - z/2} = \\frac{1 + z/2}{1 - z/2} $$\n这是 $\\exp(z)$ 的 $[1,1]$-Padé近似。我们计算该函数在 $z=-1$ 处的值：\n$$ R_{\\mathrm{IM}}(-1) = \\frac{1 + (-1)/2}{1 - (-1)/2} = \\frac{1 - 1/2}{1 + 1/2} = \\frac{1/2}{3/2} = \\frac{1}{3} $$\n其模为 $\\lvert R_{\\mathrm{IM}}(-1) \\rvert = \\frac{1}{3}$。\n现在，我们计算步数 $n_{\\mathrm{IM}}$：\n$$ n_{\\mathrm{IM}}(k) = \\frac{k \\ln(10)}{\\ln(1/\\lvert R_{\\mathrm{IM}}(-1) \\rvert)} = \\frac{k \\ln(10)}{\\ln(1/(1/3))} = \\frac{k \\ln(10)}{\\ln(3)} $$\n\n将两个结果合并为所要求的数对格式 $\\big(n_{\\mathrm{RK4}}(k),\\, n_{\\mathrm{IM}}(k)\\big)$，我们得到最终的表达式。", "answer": "$$ \\boxed{\\left( \\frac{k \\ln(10)}{\\ln(8/3)}, \\frac{k \\ln(10)}{\\ln(3)} \\right)} $$", "id": "3613965"}, {"introduction": "现代科学计算依赖于自适应步长来同时保证精度和效率。这项高级练习 [@problem_id:3613947] 将挑战您实现广泛使用的龙格-库塔5(4)阶方法（Dormand-Prince）的单步计算，该方法是许多专业常微分方程求解器的基石。您将接触到嵌入式误差估计和步长控制等实用概念，从而连接理论与实际应用。", "problem": "您需要实现 Dormand–Prince Runge–Kutta $5(4)$ 方法（下文简称为 Dormand–Prince (DP) 和 Runge–Kutta (RK)）的单个自适应步，用于求解由常微分方程 (ODE) $y^{\\prime}(t) = f(t,y)$ 给出的初值问题，其中 $f(t,y) = -y$，从 $(t_n, y_n)$ 开始。该方法必须使用嵌入对来估计局部截断误差并决定步长的接受或拒绝，并且必须根据标准控制器推荐新的步长。此任务必须从第一性原理出发解决：从 ODE 定义 $y^{\\prime} = f(t,y)$、由内部阶段求值 $k_i$ 定义的单步 Runge–Kutta 方法的概念，以及在步末提供两个不同阶数近似值以估计局部误差的嵌入对的定义开始。\n\n使用以下 Dormand–Prince $5(4)$ Butcher 表数据（这些是定义该特定 RK 方法的经过充分测试的系数）：\n- 节点 $c_i$：\n$$\nc_1 = 0, \\quad c_2 = \\tfrac{1}{5}, \\quad c_3 = \\tfrac{3}{10}, \\quad c_4 = \\tfrac{4}{5}, \\quad c_5 = \\tfrac{8}{9}, \\quad c_6 = 1, \\quad c_7 = 1.\n$$\n- 用于阶段的矩阵 $a_{ij}$：\n$$\na_{21} = \\tfrac{1}{5};\n$$\n$$\na_{31} = \\tfrac{3}{40}, \\quad a_{32} = \\tfrac{9}{40};\n$$\n$$\na_{41} = \\tfrac{44}{45}, \\quad a_{42} = -\\tfrac{56}{15}, \\quad a_{43} = \\tfrac{32}{9};\n$$\n$$\na_{51} = \\tfrac{19372}{6561}, \\quad a_{52} = -\\tfrac{25360}{2187}, \\quad a_{53} = \\tfrac{64448}{6561}, \\quad a_{54} = -\\tfrac{212}{729};\n$$\n$$\na_{61} = \\tfrac{9017}{3168}, \\quad a_{62} = -\\tfrac{355}{33}, \\quad a_{63} = \\tfrac{46732}{5247}, \\quad a_{64} = \\tfrac{49}{176}, \\quad a_{65} = -\\tfrac{5103}{18656};\n$$\n$$\na_{71} = \\tfrac{35}{384}, \\quad a_{72} = 0, \\quad a_{73} = \\tfrac{500}{1113}, \\quad a_{74} = \\tfrac{125}{192}, \\quad a_{75} = -\\tfrac{2187}{6784}, \\quad a_{76} = \\tfrac{11}{84}.\n$$\n- 用于五阶解 $y_{n+1}^{(5)}$ 的权重 $b_i$：\n$$\nb_1 = \\tfrac{35}{384}, \\quad b_2 = 0, \\quad b_3 = \\tfrac{500}{1113}, \\quad b_4 = \\tfrac{125}{192}, \\quad b_5 = -\\tfrac{2187}{6784}, \\quad b_6 = \\tfrac{11}{84}, \\quad b_7 = 0.\n$$\n- 用于嵌入式四阶解 $y_{n+1}^{(4)}$ 的权重 $\\hat{b}_i$：\n$$\n\\hat{b}_1 = \\tfrac{5179}{57600}, \\quad \\hat{b}_2 = 0, \\quad \\hat{b}_3 = \\tfrac{7571}{16695}, \\quad \\hat{b}_4 = \\tfrac{393}{640}, \\quad \\hat{b}_5 = -\\tfrac{92097}{339200}, \\quad \\hat{b}_6 = \\tfrac{187}{2100}, \\quad \\hat{b}_7 = \\tfrac{1}{40}.\n$$\n\n对于给定的试验步长 $h$，根据 RK 构造计算 7 个阶段值 $k_i$\n$$\nk_i = f\\!\\left(t_n + c_i h,\\, y_n + h \\sum_{j=1}^{i-1} a_{ij} k_j\\right),\n$$\n然后计算两个嵌入解\n$$\ny_{n+1}^{(5)} = y_n + h \\sum_{i=1}^{7} b_i k_i, \\qquad y_{n+1}^{(4)} = y_n + h \\sum_{i=1}^{7} \\hat{b}_i k_i.\n$$\n\n将局部误差估计定义为差值 $e = y_{n+1}^{(5)} - y_{n+1}^{(4)}$。使用适合自适应时间步长的缩放误差范数：\n$$\n\\mathrm{err} = \\frac{|e|}{\\mathrm{atol} + \\mathrm{rtol}\\cdot \\max\\!\\left(|y_n|,\\, |y_{n+1}^{(5)}|\\right)}.\n$$\n此处 $\\mathrm{rtol}$ 和 $\\mathrm{atol}$ 分别是相对和绝对容差。对于此问题，您必须设置 $\\mathrm{rtol} = \\mathrm{atol} = \\mathrm{tol}$，其中 $\\mathrm{tol}$是每个测试用例中给定的容差参数。\n\n接受准则：当且仅当 $\\mathrm{err} \\le 1$ 时接受该步。如果接受，则推进到 $t_{n+1} = t_n + h$，解为 $y_{n+1} = y_{n+1}^{(5)}$。如果拒绝，则不推进，即保持 $t_{n+1} = t_n$ 和 $y_{n+1} = y_n$。\n\n使用不含比例-积分滤波的标准控制器推荐新步长 $h_{\\mathrm{new}}$：\n$$\nh_{\\mathrm{new}} = h \\cdot \\mathrm{clip}\\!\\left( s \\cdot \\mathrm{err}^{-1/5},\\, f_{\\min},\\, f_{\\max}\\right),\n$$\n其中 $s$ 是安全因子，裁剪将步长乘法因子限制在区间 $[f_{\\min}, f_{\\max}]$ 内。使用 $s = 0.9$，$f_{\\min} = 0.2$ 和 $f_{\\max} = 5$。在退化情况 $\\mathrm{err} = 0$下，将乘法因子定义为 $f_{\\max}$。指数 $1/5$ 对应于控制五阶方法的局部误差。\n\n实现此单步自适应 RK 过程，并将其应用于 ODE $y^{\\prime} = -y$ 的以下每个测试用例。在所有情况下，均精确使用 $f(t,y) = -y$，不作任何近似。测试套件由元组 $(t_n, y_n, h, \\mathrm{tol})$ 组成：\n- 情况 1： $(0,\\, 1,\\, 0.1,\\, 10^{-6})$。\n- 情况 2： $(0,\\, 1,\\, 2.0,\\, 10^{-6})$。\n- 情况 3： $(5,\\, e^{-5},\\, 0.5,\\, 10^{-12})$。\n- 情况 4： $(0,\\, 1,\\, 10^{-8},\\, 10^{-6})$。\n\n对于每种情况，输出包含四个项目的列表：布尔步长接受标志、推进后的时间 $t_{n+1}$、推进后的解 $y_{n+1}$ 以及推荐的下一步長 $h_{\\mathrm{new}}$。您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表。例如，有效格式为\n$[ [\\mathrm{True},\\, t_1,\\, y_1,\\, h_1],\\, [\\mathrm{False},\\, t_2,\\, y_2,\\, h_2],\\, \\ldots ]$\n其中每个 $t_i$、$y_i$ 和 $h_i$ 均为浮点数。", "solution": "该问题是有效的。它提出了一个在数值分析领域中明确定义的任务：为指定的常微分方程 (ODE) 和一组初始条件，实现 Dormand–Prince 5(4) Runge–Kutta 方法的单个自适应步。所有必要的参数、公式和条件都已提供，并且它们与有关 ODE 数值方法的既定科学文献一致。\n\n任务是为由 ODE $y'(t) = f(t,y)$ 定义的初值问题计算一个自adaptive步，从初始点 $(t_n, y_n)$ 和试验步长 $h$ 开始。要解决的特定 ODE 是 $y'(t) = -y$，因此 $f(t,y) = -y$。\n\n显式 Runge–Kutta 方法是一种用于近似 ODE 解的单步数值过程。它由一组系数定义，这些系数组织在一个 Butcher 表中，该表由一个节点向量 $c = (c_i)$、一个系数矩阵 $A = (a_{ij})$ 和一个权重向量 $b = (b_i)$ 组成。对于一个 $s$ 阶方法，对真实解 $y(t_n+h)$ 的近似值 $y_{n+1}$ 按如下方式计算：\n首先，顺序计算 $s$ 个中间阶段 $k_i$，$i = 1, \\dots, s$：\n$$k_i = f\\left(t_n + c_i h, y_n + h \\sum_{j=1}^{i-1} a_{ij} k_j\\right)$$\n然后，下一步长的解由这些阶段的加权平均形成：\n$$y_{n+1} = y_n + h \\sum_{i=1}^{s} b_i k_i$$\n\n该问题指定了一个嵌入式 Runge–Kutta 对，即 Dormand–Prince $5(4)$ 方法，这是一个 $7$ 阶方法 ($s=7$)。此方法使用同一组阶段值 $k_i$ 计算两个不同阶数的解，一个五阶精确解 $y_{n+1}^{(5)}$ 和一个四阶精确解 $y_{n+1}^{(4)}$。\n五阶解使用权重 $b_i$：\n$$y_{n+1}^{(5)} = y_n + h \\sum_{i=1}^{7} b_i k_i$$\n嵌入式四阶解使用权重 $\\hat{b}_i$：\n$$y_{n+1}^{(4)} = y_n + h \\sum_{i=1}^{7} \\hat{b}_i k_i$$\n\nDormand–Prince $5(4)$ 方法由以下 Butcher 表系数定义：\n节点 $c_i$：\n$$c = \\left[0, \\tfrac{1}{5}, \\tfrac{3}{10}, \\tfrac{4}{5}, \\tfrac{8}{9}, 1, 1\\right]^T$$\n矩阵 $A = (a_{ij})$：\n$$\n\\begin{array}{c|ccccccc}\n0        \\\\\n1/5   1/5       \\\\\n3/10   3/40   9/40      \\\\\n4/5   44/45   -56/15   32/9     \\\\\n8/9   19372/6561   -25360/2187   64448/6561   -212/729    \\\\\n1   9017/3168   -355/33   46732/5247   49/176   -5103/18656   \\\\\n1   35/384   0   500/1113   125/192   -2187/6784   11/84   0\n\\end{array}\n$$\n$y_{n+1}^{(5)}$ 的权重 $b_i$：\n$$b = \\left[\\tfrac{35}{384}, 0, \\tfrac{500}{1113}, \\tfrac{125}{192}, -\\tfrac{2187}{6784}, \\tfrac{11}{84}, 0\\right]$$\n$y_{n+1}^{(4)}$ 的权重 $\\hat{b}_i$：\n$$\\hat{b} = \\left[\\tfrac{5179}{57600}, 0, \\tfrac{7571}{16695}, \\tfrac{393}{640}, -\\tfrac{92097}{339200}, \\tfrac{187}{2100}, \\tfrac{1}{40}\\right]$$\n\n单个自适应步的算法过程如下：\n\n**1. 阶段计算**\n给定 $(t_n, y_n)$ 和步长 $h$，我们计算 7 个阶段 $k_1, \\dots, k_7$。对于特定的 ODE $f(t,y) = -y$，这些阶段与 $t$ 无关，计算如下：\n$k_1 = f(t_n, y_n) = -y_n$\n$k_2 = f(t_n + c_2 h, y_n + h a_{21} k_1) = -(y_n + h a_{21} k_1)$\n$k_3 = f(t_n + c_3 h, y_n + h (a_{31} k_1 + a_{32} k_2)) = -(y_n + h (a_{31} k_1 + a_{32} k_2))$\n...依此类推，直到 $k_7$：\n$$k_i = -\\left(y_n + h \\sum_{j=1}^{i-1} a_{ij} k_j\\right) \\quad \\text{for } i=1,\\dots,7$$\n此处，当 $i=1$ 时，求和为零。\n\n**2. 误差估计**\n两个解之间的差值提供了低阶方法局部截断误差的估计：\n$$e = y_{n+1}^{(5)} - y_{n+1}^{(4)} = h \\sum_{i=1}^{7} (b_i - \\hat{b}_i) k_i$$\n为了判断步长是否足够精确，将此误差与用户定义的容差进行比较。计算一个缩放误差范数 $\\mathrm{err}$：\n$$\\mathrm{err} = \\frac{|e|}{\\mathrm{atol} + \\mathrm{rtol}\\cdot \\max(|y_n|, |y_{n+1}^{(5)}|)}$$\n在此问题中，相对和绝对容差设置相等，$\\mathrm{rtol} = \\mathrm{atol} = \\mathrm{tol}$。因此，误差缩放项为 $\\mathrm{tol} \\cdot (1 + \\max(|y_n|, |y_{n+1}^{(5)}|))$。\n\n**3. 步长接受和状态更新**\n如果缩放误差小于或等于 1，则接受该步：$\\mathrm{err} \\le 1$。\n- 如果步长被接受，则时间和解向前推进。高阶解用于传播（这被称为局部外插）：$t_{n+1} = t_n + h$ 和 $y_{n+1} = y_{n+1}^{(5)}$。\n- 如果步长被拒绝，则时间和解不向前推進：$t_{n+1} = t_n$ 和 $y_{n+1} = y_n$。必须用更小的步长重试该步。\n\n**4. 新步长推荐**\n无论接受或拒绝，都会为下一次尝试提出一个新的、更合适的步长 $h_{\\mathrm{new}}$。使用标准比例控制器：\n$$h_{\\mathrm{new}} = h \\cdot \\mathrm{clip}\\!\\left( s \\cdot \\mathrm{err}^{-\\frac{1}{p+1}},\\, f_{\\min},\\, f_{\\max}\\right)$$\n此处，$p=4$ 是误差估计的阶数，所以指数是 $1/5$。安全因子 $s=0.9$ 确保了保守的选择，而裁剪函数将步长的变化限制在因子 $f_{\\min}=0.2$ 和 $f_{\\max}=5$ 之间。\n在 $\\mathrm{err}$ 为零的情况下（由于浮点运算或解是精确的），乘法因子被设置为其最大值 $f_{\\max}$。\n\n实现将把此过程应用于提供的四个测试用例 $(t_n, y_n, h, \\mathrm{tol})$ 中的每一个，报告步长接受情况、下一个状态 $(t_{n+1}, y_{n+1})$ 以及推荐的下一步長 $h_{\\mathrm{new}}$。\n- 情况 1： $(0,\\, 1,\\, 0.1,\\, 10^{-6})$。\n- 情况 2： $(0,\\, 1,\\, 2.0,\\, 10^{-6})$。\n- 情况 3： $(5,\\, e^{-5},\\, 0.5,\\, 10^{-12})$。\n- 情况 4： $(0,\\, 1,\\, 10^{-8},\\, 10^{-6})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the Dormand-Prince step for all test cases\n    and prints the formatted results.\n    \"\"\"\n\n    def dormand_prince_step(t_n, y_n, h, tol):\n        \"\"\"\n        Performs a single adaptive step of the Dormand-Prince 5(4) method.\n\n        Args:\n            t_n (float): Initial time.\n            y_n (float): Initial solution value.\n            h (float): Trial step size.\n            tol (float): Tolerance for error control (both rtol and atol).\n\n        Returns:\n            tuple: (step_accepted, t_next, y_next, h_new)\n        \"\"\"\n        # Dormand--Prince 5(4) Butcher Tableau coefficients\n        c = np.array([0, 1/5, 3/10, 4/5, 8/9, 1, 1], dtype=np.float64)\n        \n        A = np.array([\n            [0, 0, 0, 0, 0, 0, 0],\n            [1/5, 0, 0, 0, 0, 0, 0],\n            [3/40, 9/40, 0, 0, 0, 0, 0],\n            [44/45, -56/15, 32/9, 0, 0, 0, 0],\n            [19372/6561, -25360/2187, 64448/6561, -212/729, 0, 0, 0],\n            [9017/3168, -355/33, 46732/5247, 49/176, -5103/18656, 0, 0],\n            [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0]\n        ], dtype=np.float64)\n        \n        # Weights for the 5th order solution\n        b = np.array([35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0], dtype=np.float64)\n        \n        # Weights for the 4th order embedded solution\n        b_hat = np.array([5179/57600, 0, 7571/16695, 393/640, -92097/339200, 187/2100, 1/40], dtype=np.float64)\n\n        # ODE function\n        def f(t, y):\n            return -y\n\n        # Step-size controller parameters\n        s = 0.9\n        f_min = 0.2\n        f_max = 5.0\n\n        # --- 1. Stage Calculation ---\n        k = np.zeros(7, dtype=np.float64)\n        for i in range(7):\n            y_stage = y_n + h * np.dot(A[i, :i], k[:i])\n            k[i] = f(t_n + c[i] * h, y_stage)\n\n        # --- 2. Compute 5th and 4th order solutions ---\n        y_n5 = y_n + h * np.dot(b, k)\n        y_n4 = y_n + h * np.dot(b_hat, k)\n\n        # --- 3. Error Estimation ---\n        e = y_n5 - y_n4  # Local error estimate\n        \n        # Scale for error norm\n        atol = tol\n        rtol = tol\n        error_scale = atol + rtol * max(np.abs(y_n), np.abs(y_n5))\n        \n        # Avoid division by zero if tolerances and solution are zero\n        if error_scale == 0.0:\n            err = 0.0\n        else:\n            err = np.abs(e) / error_scale\n\n        # --- 4. Step Acceptance ---\n        accepted = err = 1.0\n\n        if accepted:\n            t_next = t_n + h\n            y_next = y_n5\n        else:\n            t_next = t_n\n            y_next = y_n\n\n        # --- 5. New Step Size Recommendation ---\n        if err == 0.0:\n            factor = f_max\n        else:\n            factor = s * (err ** -0.2)\n        \n        factor_clipped = np.clip(factor, f_min, f_max)\n        h_new = h * factor_clipped\n\n        return [accepted, t_next, y_next, h_new]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 1.0, 0.1, 1e-6),\n        (0.0, 1.0, 2.0, 1e-6),\n        (5.0, np.exp(-5), 0.5, 1e-12),\n        (0.0, 1.0, 1e-8, 1e-6),\n    ]\n\n    results = []\n    for case in test_cases:\n        t_n, y_n, h, tol = case\n        result = dormand_prince_step(t_n, y_n, h, tol)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default str() for a list gives the python list representation,\n    # which includes spaces after commas, matching the visual style of the example.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3613947"}]}