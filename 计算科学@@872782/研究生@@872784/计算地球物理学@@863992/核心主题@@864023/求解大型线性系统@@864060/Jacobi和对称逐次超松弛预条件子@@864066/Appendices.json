{"hands_on_practices": [{"introduction": "掌握预条件子不仅仅是记住公式，更在于从第一性原理出发理解其构造。雅可比（Jacobi）方法是最基础的迭代法之一，其预条件子源于对系统矩阵最简单的分裂。本练习将引导你推导雅可比迭代，并为一个经典的物理问题——一维热传导方程——分析其收敛性，这是理解更复杂方法前必不可少的一步 [@problem_id:3605469]。", "problem": "在对通过均匀岩石圈柱的稳态一维导热过程进行建模时，采用带有 Dirichlet 边界条件的微分算子的标准二阶中心有限差分离散，会得到一个大小为 $n \\times n$ 的线性系统 $A x = b$，其中 $A$ 是对称正定(SPD)矩阵。\n\n考虑一个通用的 SPD 矩阵分裂为 $A = D - L - U$，其中 $D$ 是 $A$ 的对角部分，$L$ 是 $A$ 的严格下三角部分，$U$ 是 $A$ 的严格上三角部分。\n\n(a) 从与矩阵分裂 $A = D - L - U$ 和线性系统 $A x = b$ 相关的定常迭代的定义出发，推导矩阵形式的 Jacobi 迭代，并确定其对应的迭代矩阵。\n\n(b) 使用定常迭代的线性误差传播模型，陈述迭代矩阵保证对任意初始猜测收敛的充要谱条件。您的推理应基于矩阵幂的谱半径特征以及相容和次可乘的范数。\n\n(c) 针对由带 Dirichlet 边界的一维拉普拉斯算子的均匀网格二阶有限差分近似产生的离散算子进行特例分析，即大小为 $n \\times n$ 的 Toeplitz 三对角矩阵 $A = \\operatorname{tridiag}(-1, 2, -1)$。计算 (a) 部分中推导出的 Jacobi 迭代矩阵的谱半径，以 $n$ 的函数形式给出闭式解。请将此谱半径作为您的最终框内答案，以单一闭式解析表达式的形式给出。不需要进行数值舍入。", "solution": "问题陈述已经过验证，被认为是科学上可靠、适定且客观的。它为一个在计算地球物理学中有明确背景的数值线性代数标准问题提供了完整且一致的设定。因此，我们可以进行完整解答。该问题将按所列大纲分三部分进行处理。\n\n(a) Jacobi 迭代及迭代矩阵的推导\n\n求解线性系统 $A x = b$ 的一个定常迭代法由矩阵 $A$ 的一个分裂 $A = M - N$ 定义，其中 $M$ 是非奇异矩阵。迭代过程则由 $M x^{(k+1)} = N x^{(k)} + b$ 给出。\n\n问题指定了分裂 $A = D - L - U$，其中 $D$ 是 $A$ 的对角部分，$-L$ 是 $A$ 的严格下三角部分，$-U$ 是 $A$ 的严格上三角部分。准确地说，给定 $A = (a_{ij})$，这里使用的分裂是：\n$D_{ij} = \\delta_{ij} a_{ij}$\n$L_{ij} = -\\delta_{ij} a_{ij}$\n$U_{ij} = -\\delta_{ij} a_{ij}$\nJacobi迭代通过将对角项 $D x$ 移到左侧，并将所有非对角项 $(L+U)x$ 视为使用上一迭代步的值来构造：\n$$D x^{(k+1)} = (L+U)x^{(k)} + b$$\n这可以重写为：\n$$x^{(k+1)} = D^{-1}(L+U)x^{(k)} + D^{-1}b$$\n因此，Jacobi迭代的迭代矩阵是 $B_J = D^{-1}(L+U)$。", "answer": "$$\\boxed{\\cos\\left(\\frac{\\pi}{n+1}\\right)}$$", "id": "3605469"}, {"introduction": "在雅可比方法的基础上，对称逐次超松弛（Symmetric Successive Over-Relaxation, SSOR）法通过更精巧的构造提供了往往更优的收敛性能。SSOR预条件子由一个前向和一个后向的逐次超松弛（SOR）扫描复合而成，理解其矩阵因式分解形式是掌握其对称性和实现细节的关键。通过这个练习 [@problem_id:3605522]，你将亲手推导出SSOR预条件子的显式表达式，并揭示它与更简单的对称高斯-赛德尔（Symmetric Gauss-Seidel）法之间的联系。", "problem": "考虑一个大型稀疏对称正定线性系统 $A x = b$，该系统源于计算地球物理学中对地下电导率建模所使用的各向异性扩散方程的有限差分法离散化。设矩阵分裂为 $A = D + L + U$，其中 $D$ 是 $A$ 的对角部分，$L$ 是其严格下三角部分，$U$ 是其严格上三角部分。Jacobi 预处理器使用 $M_{\\mathrm{J}} = D$，而 Gauss-Seidel 迭代更新则由对 $D + L$ 或 $D + U$ 的三角求解构成。逐次超松弛 (Successive Over-Relaxation, SOR) 方法在 Gauss-Seidel 更新中引入了一个松弛因子 $\\omega \\in (0,2)$，其对称版本，即对称逐次超松弛 (Symmetric Successive Over-Relaxation, SSOR) 方法，则组合了一个前向和一个后向 SOR 扫描来构造一个对称正定预处理器 $M_{\\mathrm{SSOR}}(\\omega)$，用于预处理共轭梯度法。\n\n从矩阵分裂 $A = D + L + U$、Gauss-Seidel 和逐次超松弛迭代的定义出发，并利用“构造一个预处理器 $M$，使其逆 $M^{-1}$ 对残差 $r$ 的一次应用可通过两次三角求解和一次对角缩放实现”这一原理，推导出 SSOR 预处理器 $M_{\\mathrm{SSOR}}(\\omega)$ 关于 $D$、$L$ 和 $U$ 的显式因式分解。然后，通过特化为 $\\omega = 1$ 的情况，证明 $M_{\\mathrm{SSOR}}(1)$ 简化为对称 Gauss-Seidel 预处理器，并将其显式因子以 $D$、$L$ 和 $U$ 的形式写成一个单一的封闭解析表达式。您的最终答案必须是 $M_{\\mathrm{SSOR}}(1)$ 作为 $D$、$L$ 和 $U$ 的函数的显式乘积表达式，不得包含任何额外的注释或符号。无需四舍五入，也不涉及单位。", "solution": "本题要求推导对称逐次超松弛 (Symmetric Successive Over-Relaxation, SSOR) 预处理器 $M_{\\mathrm{SSOR}}(\\omega)$，以及其在 $\\omega=1$ 时的特定形式，即对称 Gauss-Seidel (Symmetric Gauss-Seidel, SGS) 预处理器。推导过程从 SSOR 迭代法的定义开始。\n\n待求解的线性系统为 $Ax = b$，其中 $A$ 是一个对称正定矩阵。矩阵 $A$ 被分裂为其对角部分 ($D$)、严格下三角部分 ($L$) 和严格上三角部分 ($U$)，使得 $A = D + L + U$。由于 $A$ 是对称的，所以有 $U = L^T$。\n\n迭代法可以用来定义一个预处理器 $M$。将预处理器的逆应用于残差向量 $r$ 的操作，记为计算 $z = M^{-1}r$，其定义为：从初始猜测 $z_{initial}=0$ 开始，对系统 $Az=r$ 执行一次完整的迭代。\n\nSSOR 迭代由一个前向 SOR 扫描和一个后向 SOR 扫描组成。\n\n1.  **前向 SOR 扫描：** 对于系统 $Ax=b$，从迭代值 $x^{(k)}$ 更新到中间迭代值 $x^{(k+1/2)}$ 的更新方程为：\n    $$ (D + \\omega L) x^{(k+1/2)} = ((1-\\omega)D - \\omega U) x^{(k)} + \\omega b $$\n    其中 $\\omega \\in (0,2)$ 是松弛参数。\n\n2.  **后向 SOR 扫描：** 从中间迭代值 $x^{(k+1/2)}$ 更新到新迭代值 $x^{(k+1)}$ 的更新过程是：\n    $$ (D + \\omega U) x^{(k+1)} = ((1-\\omega)D - \\omega L) x^{(k+1/2)} + \\omega b $$\n\n为了找到预处理器逆的作用，$z = M_{\\mathrm{SSOR}}^{-1}(\\omega)r$，我们从零的初始猜测开始，对系统 $Az=r$ 应用一次完整的 SSOR 迭代。设初始猜测为 $z^{(k)}=0$。迭代的结果将是 $z$。\n\n首先，我们用 $b \\to r$ 和 $z^{(k)} \\to 0$ 执行前向扫描。设中间结果为 $z_{inter}$。\n$$ (D + \\omega L) z_{inter} = ((1-\\omega)D - \\omega U)(0) + \\omega r = \\omega r $$\n求解 $z_{inter}$，我们得到：\n$$ z_{inter} = \\omega (D + \\omega L)^{-1} r $$\n\n接下来，我们使用 $z_{inter}$作为输入执行后向扫描，以找到最终结果 $z$。\n$$ (D + \\omega U) z = ((1-\\omega)D - \\omega L) z_{inter} + \\omega r $$\n代入 $z_{inter}$ 的表达式：\n$$ (D + \\omega U) z = ((1-\\omega)D - \\omega L) \\left[ \\omega (D + \\omega L)^{-1} r \\right] + \\omega r $$\n我们可以在右侧提取公因子 $\\omega$ 和 $r$：\n$$ (D + \\omega U) z = \\omega \\left[ ((1-\\omega)D - \\omega L) (D + \\omega L)^{-1} + I \\right] r $$\n这里，$I$ 是单位矩阵。为了简化方括号中的表达式，我们使用一个共同的右分母 $(D + \\omega L)$：\n$$ ((1-\\omega)D - \\omega L) (D + \\omega L)^{-1} + I = \\left[ ((1-\\omega)D - \\omega L) + (D + \\omega L) \\right] (D + \\omega L)^{-1} $$\n合并括号内的项：\n$$ [ (1-\\omega)D + D - \\omega L + \\omega L ] (D + \\omega L)^{-1} = (2-\\omega)D (D + \\omega L)^{-1} $$\n将这个简化后的表达式代回到关于 $z$ 的方程中：\n$$ (D + \\omega U) z = \\omega (2-\\omega)D (D + \\omega L)^{-1} r $$\n求解 $z$ 得到预处理器逆的作用：\n$$ z = \\omega(2-\\omega) (D + \\omega U)^{-1} D (D + \\omega L)^{-1} r $$\n由此，我们确定 SSOR 预处理器的逆：\n$$ M_{\\mathrm{SSOR}}^{-1}(\\omega) = \\omega(2-\\omega) (D + \\omega U)^{-1} D (D + \\omega L)^{-1} $$\n\n为了得到 SSOR 预处理器 $M_{\\mathrm{SSOR}}(\\omega)$，我们对 $M_{\\mathrm{SSOR}}^{-1}(\\omega)$ 取逆。使用性质 $(cXYZ)^{-1} = c^{-1}Z^{-1}Y^{-1}X^{-1}$：\n$$ M_{\\mathrm{SSOR}}(\\omega) = \\left[ \\omega(2-\\omega) (D + \\omega U)^{-1} D (D + \\omega L)^{-1} \\right]^{-1} $$\n$$ M_{\\mathrm{SSOR}}(\\omega) = \\frac{1}{\\omega(2-\\omega)} ((D + \\omega L)^{-1})^{-1} (D)^{-1} ((D + \\omega U)^{-1})^{-1} $$\n$$ M_{\\mathrm{SSOR}}(\\omega) = \\frac{1}{\\omega(2-\\omega)} (D + \\omega L) D^{-1} (D + \\omega U) $$\n该表达式表示了 SSOR 预处理器关于 $D$、$L$ 和 $U$ 的显式因式分解。该预处理器是对称的，因为 $A$ 是对称的 (因此 $U=L^T$) 并且 $D$ 是对角的，使得 $M_{\\mathrm{SSOR}}(\\omega)$ 具有 $C K D^{-1} K^T$ 的形式。\n\n题目接着要求将此结果特化为 $\\omega=1$ 的情况。这对应于对称 Gauss-Seidel (SGS) 预处理器，我们将其表示为 $M_{\\mathrm{SSOR}}(1)$。将 $\\omega = 1$ 代入推导出的公式中：\n$$ M_{\\mathrm{SSOR}}(1) = \\frac{1}{1(2-1)} (D + 1 \\cdot L) D^{-1} (D + 1 \\cdot U) $$\n$$ M_{\\mathrm{SSOR}}(1) = (D + L) D^{-1} (D + U) $$\n这就是对称 Gauss-Seidel 预处理器的显式乘积表达式。", "answer": "$$\\boxed{(D + L) D^{-1} (D + U)}$$", "id": "3605522"}, {"introduction": "理论推导是基础，但真正的挑战在于将方法应用于实际的地球物理问题中。在模拟波动现象的亥姆霍兹（Helmholtz）方程等问题中，系统矩阵可能是非正定的，这会导致为正定系统设计的SSOR等预条件子失去其有效性甚至失效。这个编程实践 [@problem_id:3605479] 将带你直面这一挑战：你将学习如何通过Cholesky分解来检测预条件子的失效，并实现一种稳健的回退策略，这在开发可靠的科学计算软件时至关重要。", "problem": "考虑在一维频域中，带轻微阻尼的波传播问题中的亥姆霍兹算子，该算子在均匀网格上使用狄利克雷边界条件进行离散化。设连续算子定义在区间 $[0,L]$ 上为\n$$\n\\mathcal{H}u(x) = -\\frac{d^2 u}{dx^2}(x) - k(x)^2 u(x) + \\delta u(x),\n$$\n其中 $k(x)$ 是空间变化的波数，$\\delta \\ge 0$ 是一个小的实数阻尼。在 $N$ 个内部网格点上使用标准的二阶中心有限差分法，步长为 $h = L/(N+1)$，得到的离散线性系统为 $A u = f$，其中 $A \\in \\mathbb{R}^{N \\times N}$ 是对称三对角矩阵，其模板系数为\n$$\nA_{i,i} = \\frac{2}{h^2} - k_i^2 + \\delta,\\quad A_{i,i-1} = A_{i,i+1} = -\\frac{1}{h^2},\\quad 1 \\le i \\le N,\n$$\n其中 $k_i = k(x_i)$ 且 $x_i = i h$。矩阵 $A$ 可以是对称正定 (SPD) 的、不定的或病态的，具体取决于 $k(x)$ 和 $\\delta$。\n\n定义 $A$ 的对角部分 $D = \\operatorname{diag}(A)$、严格下三角部分 $L$ 和严格上三角部分 $U$。对于松弛参数 $\\omega$，对称逐次超松弛 (SSOR) 预条件子为\n$$\nM_{\\mathrm{SSOR}}(\\omega) = \\frac{1}{\\omega(2 - \\omega)} \\left( D + \\omega L \\right) D^{-1} \\left( D + \\omega U \\right),\n$$\n前提是 $0  \\omega  2$。对于对称高斯-赛德尔预条件子，设置 $\\omega = 1$。雅可比预条件子是 $M_{\\mathrm{J}} = D$。在预条件共轭梯度法中，$M$ 必须是 SPD 的。对于不定的 $A$，$M_{\\mathrm{SSOR}}(\\omega)$ 可能会失去 SPD 性质，这可以通过 Cholesky 分解的失败来检测。\n\n您的任务是编写一个完整的程序，该程序：\n- 使用上述公式为几个测试用例构建 $A$。\n- 为每个用例构造 $M_{\\mathrm{SSOR}}(\\omega)$。\n- 通过尝试对 $M_{\\mathrm{SSOR}}(\\omega)$ 进行 Cholesky 分解来检测其是否为 SPD。\n- 如果 $M_{\\mathrm{SSOR}}(\\omega)$ 不是 SPD，则将索引集 $\\{1,2,\\dots,N\\}$ 划分为大小相等的连续块 $B$，并对每个块检查其主子矩阵 $A_{\\mathrm{block}}$。如果 $A_{\\mathrm{block}}$ 是 SPD，则为该块推荐对称高斯-赛德尔法；否则推荐雅可比法。报告推荐使用对称高斯-赛德尔法和雅可比法的块数。\n\n使用以下测试套件，该套件通过改变波数和松弛参数来测试 SPD、不定和边界情况。在所有情况下，设置 $L = 1$：\n- 情况 1：$N = 64$，均匀 $k(x) \\equiv 0$，$\\delta = 0$，$\\omega = 1$，块大小 $B = 16$。\n- 情况 2：$N = 64$，均匀 $k(x) \\equiv 5$，$\\delta = 0.1$，$\\omega = 1.2$，块大小 $B = 16$。\n- 情况 3：$N = 64$，分段 $k(x)$，其中 $k(x) \\equiv 2$ 在 $x \\in [0,0.5)$ 上，$k(x) \\equiv 5$ 在 $x \\in [0.5,1]$ 上，$\\delta = 0.05$，$\\omega = 1$，块大小 $B = 8$。\n- 情况 4：$N = 64$，均匀 $k(x) \\equiv 2$，$\\delta = 0$，$\\omega = 1.99$，块大小 $B = 16$。\n- 情况 5：$N = 64，均匀 $k(x) \\equiv 2，$\\delta = 0，$\\omega = 2.1$，块大小 $B = 16$。\n\n对于每种情况，程序必须生成一个列表，其中包含：\n- 一个布尔值，指示 $M_{\\mathrm{SSOR}}(\\omega)$ 是否为 SPD。\n- 推荐使用对称高斯-赛德尔法的块的整数计数。\n- 推荐使用雅可比法的块的整数计数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身也是一个形式为 $[ \\text{布尔值}, \\text{整数}, \\text{整数} ]$ 的列表。例如，两个假设用例的输出看起来像 $[[\\text{True},2,3],[\\text{False},1,4]]$。输出中不得包含任何单位。", "solution": "当前任务是分析离散化的一维亥姆霍兹算子的对称逐次超松弛 (SSOR) 预条件子的对称正定 (SPD) 性质。如果 SSOR 预条件子不是 SPD，则采用基于系统矩阵分块分析的后备策略。\n\n连续亥姆霍兹算子由下式给出：\n$$\n\\mathcal{H}u(x) = -\\frac{d^2 u}{dx^2}(x) - k(x)^2 u(x) + \\delta u(x)\n$$\n在定义域 $x \\in [0,L]$ 上，其中 $k(x)$ 是波数，$\\delta \\ge 0$ 是阻尼项。在具有 $N$ 个内部点的均匀网格上，使用步长为 $h = L/(N+1)$ 的二阶中心有限差分格式，可将其转换为线性系统 $A u = f$。矩阵 $A$ 是一个大小为 $N \\times N$ 的实对称三对角矩阵，其非零元素由以下模板定义：\n$$\nA_{i,i} = \\frac{2}{h^2} - k_i^2 + \\delta, \\quad A_{i,i-1} = A_{i,i+1} = -\\frac{1}{h^2}\n$$\n对于 $1 \\le i \\le N$，其中 $k_i = k(x_i)$ 在网格点 $x_i = i h$ 处。根据 $k_i$ 的值，矩阵 $A$ 可能是 SPD 或不定的。\n\nSSOR 预条件子 $M_{\\mathrm{SSOR}}(\\omega)$ 是使用松弛参数 $\\omega$ 从 $A$ 构建的。我们首先将 $A$ 分解为其对角 ($D$)、严格下三角 ($L$) 和严格上三角 ($U$) 部分，使得 $A = D + L + U$。SSOR 预条件子矩阵随后定义为：\n$$\nM_{\\mathrm{SSOR}}(\\omega) = \\frac{1}{\\omega(2 - \\omega)} \\left( D + \\omega L \\right) D^{-1} \\left( D + \\omega U \\right)\n$$\n该公式对 $\\omega \\in \\mathbb{R} \\setminus \\{0, 2\\}$ 有效。在其加速 SPD 系统迭代方法的常见应用中，$\\omega$ 通常被限制在区间 $0  \\omega  2$ 内，这确保了前置因子 $\\frac{1}{\\omega(2-\\omega)}$ 为正。当 $\\omega=1$ 时，该预条件子被称为对称高斯-赛德尔 (SGS) 预条件子。最简单的预条件子是雅可比预条件子，$M_{\\mathrm{J}} = D$。\n\n将预条件子 $M$ 与预条件共轭梯度 (PCG) 方法一起使用的一个关键要求是 $M$ 必须是 SPD 的。验证对称矩阵是否正定的一个标准且数值稳健的方法是尝试对其进行 Cholesky 分解。一个矩阵 $M$ 是 SPD 的当且仅当它具有 Cholesky 分解 $M = R^T R$，其中 $R$ 是一个对角线元素为正的上三角矩阵。如果矩阵不是 SPD，计算此分解的数值库将会失败并引发错误。\n\n每个测试用例的算法流程如下：\n1.  **构建矩阵 $A$**：给定参数 $N$、$L$、$\\delta$ 和函数 $k(x)$，计算网格间距 $h = L/(N+1)$。确定网格点 $x_i$ 和相应的波数 $k_i$。然后根据其定义构建三对角矩阵 $A$。\n2.  **构建预条件子 $M_{\\mathrm{SSOR}}(\\omega)$**：从 $A$ 中提取矩阵 $D$、$L$ 和 $U$。通过对其对角元素求逆来计算对角矩阵的逆 $D^{-1}$。然后使用 $M_{\\mathrm{SSOR}}(\\omega)$ 的公式将这些分量组合起来。此步骤针对任何指定的 $\\omega \\notin \\{0, 2\\}$ 执行。请注意，如果 $\\omega \\notin (0, 2)$，前置因子 $\\frac{1}{\\omega(2-\\omega)}$ 为负，这通常会使 $M_{\\mathrm{SSOR}}(\\omega)$ 非正定。\n3.  **测试 SPD 性质**：尝试对 $M_{\\mathrm{SSOR}}(\\omega)$ 进行 Cholesky 分解。如果分解成功，$M_{\\mathrm{SSOR}}(\\omega)$ 被确认为 SPD。如果失败，则该矩阵不是 SPD。\n4.  **后备的分块分析**：如果发现 $M_{\\mathrm{SSOR}}(\\omega)$ 不是 SPD，问题指定了一个后备程序。索引集 $\\{1, 2, \\dots, N\\}$ 被划分为给定大小 $B$ 的连续块。对于每个块，提取原始系统矩阵的相应主子矩阵 $A_{\\mathrm{block}}$。然后通过 Cholesky 分解测试每个 $A_{\\mathrm{block}}$ 的 SPD 性质。\n5.  **推荐与报告**：基于分块分析：\n    - 如果子矩阵 $A_{\\mathrm{block}}$ 是 SPD，则建议该块使用对称高斯-赛德尔 (SGS) 预条件子，这对于 SPD 问题是一个很好的选择。\n    - 如果 $A_{\\mathrm{block}}$ 不是 SPD，则推荐使用更安全、更简单的雅可比预条件子 ($M_J=D$)。\n    该情况的最终输出是一个列表，包含一个表示 $M_{\\mathrm{SSOR}}(\\omega)$ SPD 状态的布尔值，以及分别为 SGS 和雅可比预条件子推荐的块数的整数计数。如果 $M_{\\mathrm{SSOR}}(\\omega)$ 是 SPD，则这两个计数都为零，因为后备策略不会被触发。\n\n此过程被系统地应用于每个测试用例，通过改变物理和数值参数来探索问题的不同狀況。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import cholesky, LinAlgError\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def run_case(N, k_func, delta, omega, B):\n        \"\"\"\n        Processes a single test case.\n\n        Args:\n            N (int): Number of interior grid points.\n            k_func (callable): Function defining k(x).\n            delta (float): Damping coefficient.\n            omega (float): SSOR relaxation parameter.\n            B (int): Block size for fallback analysis.\n\n        Returns:\n            list: A list containing [is_M_spd, sgs_count, jacobi_count].\n        \"\"\"\n        L_domain = 1.0\n        h = L_domain / (N + 1)\n        x = np.arange(1, N + 1) * h\n        k = k_func(x)\n\n        # Construct the matrix A\n        diag_A = 2.0 / h**2 - k**2 + delta\n        off_diag_A = -1.0 / h**2\n        \n        A = np.diag(diag_A)\n        if N > 1:\n            A += np.diag([off_diag_A] * (N - 1), k=1)\n            A += np.diag([off_diag_A] * (N - 1), k=-1)\n\n        # Initialize results\n        is_M_spd = False\n        sgs_count = 0\n        jacobi_count = 0\n        \n        # Check for invalid omega that leads to division by zero\n        if omega == 2.0 or omega == 0.0:\n            # The formula for M_ssor is undefined or involves division by zero.\n            is_M_spd = False\n        else:\n            # Construct the SSOR preconditioner M_ssor\n            D = np.diag(np.diag(A))\n            if np.any(np.diag(D) == 0):\n                # D is not invertible, M_ssor cannot be formed correctly. Treat as not SPD.\n                is_M_spd = False\n            else:\n                L_mat = np.tril(A, k=-1)\n                U_mat = np.triu(A, k=1)\n                D_inv = np.diag(1.0 / np.diag(D))\n                \n                prefactor = 1.0 / (omega * (2.0 - omega))\n                \n                # Using @ for matrix multiplication\n                term1 = D + omega * L_mat\n                term2 = D + omega * U_mat\n                M_ssor = prefactor * (term1 @ D_inv @ term2)\n\n                # Test if M_ssor is SPD using Cholesky factorization\n                try:\n                    cholesky(M_ssor, lower=True)\n                    is_M_spd = True\n                except LinAlgError:\n                    is_M_spd = False\n\n        # If M_ssor is not SPD, perform block-wise analysis of A\n        if not is_M_spd:\n            num_blocks = N // B\n            for i in range(num_blocks):\n                start_idx = i * B\n                end_idx = (i + 1) * B\n                A_block = A[start_idx:end_idx, start_idx:end_idx]\n                \n                try:\n                    cholesky(A_block, lower=True)\n                    sgs_count += 1\n                except LinAlgError:\n                    jacobi_count += 1\n                    \n        return [is_M_spd, sgs_count, jacobi_count]\n\n    test_cases = [\n        # Case 1: N=64, k(x)=0, delta=0, omega=1, B=16\n        (64, lambda x: np.zeros_like(x), 0.0, 1.0, 16),\n        # Case 2: N=64, k(x)=5, delta=0.1, omega=1.2, B=16\n        (64, lambda x: np.full_like(x, 5.0), 0.1, 1.2, 16),\n        # Case 3: N=64, piecewise k(x), delta=0.05, omega=1, B=8\n        (64, lambda x: np.where(x  0.5, 2.0, 5.0), 0.05, 1.0, 8),\n        # Case 4: N=64, k(x)=2, delta=0, omega=1.99, B=16\n        (64, lambda x: np.full_like(x, 2.0), 0.0, 1.99, 16),\n        # Case 5: N=64, k(x)=2, delta=0, omega=2.1, B=16\n        (64, lambda x: np.full_like(x, 2.0), 0.0, 2.1, 16),\n    ]\n\n    results = []\n    for case in test_cases:\n        N_val, k_f, delta_val, omega_val, B_val = case\n        result = run_case(N_val, k_f, delta_val, omega_val, B_val)\n        results.append(result)\n\n    # Format the final output string\n    results_str = [f\"[{'True' if res[0] else 'False'},{res[1]},{res[2]}]\" for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\n\nsolve()\n```", "id": "3605479"}]}