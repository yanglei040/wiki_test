{"hands_on_practices": [{"introduction": "并行计算的一个核心目标是最小化通信开销，这对于地球物理模拟等计算密集型应用至关重要。对于基于模板（stencil-based）的显式有限差分方法，通信成本与子区域的表面积成正比。本练习 [@problem_id:3586125] 将引导您通过一个具体的优化问题，推导并应用最小化“表面积-体积比”的原则，从而为给定的处理器数量找到最优的区域分解方案，这是提升并行效率的基础。", "problem": "一个三维显式有限差分地震波传播程序，在一个大小为 $N_{x} \\times N_{y} \\times N_{z}$ 的结构化网格上演化场，其计算模板要求在每个时间步交换最近邻的边界数据。该网格被划分为一个 $p_{x} \\times p_{y} \\times p_{z}$ 的笛卡尔进程网格，映射到 $P$ 个消息传递接口（MPI）秩，且满足 $p_{x} p_{y} p_{z} = P$。每个MPI秩拥有一个大小为 $n_{x} \\times n_{y} \\times n_{z}$ 个单元的矩形子域，并满足 $n_{x} = N_{x} / p_{x}$，$n_{y} = N_{y} / p_{y}$ 和 $n_{z} = N_{z} / p_{z}$。对于晕圈交換，每个秩都通过其六个面进行通信；每个时间步通信的数据量与其子域的面面积成正比。假设所有的 $p_{i}$ 都能整除对应的 $N_{i}$，并且忽略全局域外部边界条件导致的通信量减少，问题要求在乘积约束下，通过选择 $p_{x}$、$p_{y}$、$p_{z}$ 来最小化所有秩的总晕圈表面积。\n\n从长方体的表面积定义和上述笛卡尔分区出发，推导出以 $p_{x}$、$p_{y}$、$p_{z}$为变量的总晕圈表面积的目标函数，并对于 $N_{x} = N_{y} = N_{z} = 1024$ 和 $P = 512$ 的立方体网格，确定使该目标函数最小化的 $p_{x}$、$p_{y}$、$p_{z}$ 的选择。然后计算相应的局部子域大小 $n_{x}$、$n_{y}$、$n_{z}$。\n\n请将最终答案以单行矩阵的形式给出，按顺序包含最优的 $p_{x}$、$p_{y}$、$p_{z}$ 以及由此产生的 $n_{x}$、$n_{y}$、$n_{z}$。最终答案无需四舍五入，也无需单位。", "solution": "问题需经过验证。\n\n### 步骤1：提取已知条件\n- 全局网格尺寸：$N_{x} \\times N_{y} \\times N_{z}$\n- 进程网格：$p_{x} \\times p_{y} \\times p_{z}$\n- MPI秩总数：$P$\n- 约束条件：$p_{x} p_{y} p_{z} = P$\n- 局部子域尺寸：$n_{x} \\times n_{y} \\times n_{z}$\n- 关系式：$n_{x} = N_{x} / p_{x}$，$n_{y} = N_{y} / p_{y}$，$n_{z} = N_{z} / p_{z}$\n- 目标：最小化所有秩的总晕圈表面积。\n- 假设1：所有 $p_{i}$ 都能整除对应的 $N_{i}$。\n- 假设2：忽略全局域外部的边界条件导致的通信减少。\n- 特定数据：$N_{x} = N_{y} = N_{z} = 1024$\n- 特定数据：$P = 512$\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题是并行计算中性能优化的经典示例，特别是针对分布式内存架构上基于模板的数值方法。通信成本与子域表面积（表面积与体积之比）成正比的模型是区域分解中的一个基本原则。这是计算科学与工程中的一个标准问题。\n- **适定性**：该问题是适定的。它提供了一个明确的目标函数（最小化总晕圈表面积）和一个明确的约束条件（$p_{x} p_{y} p_{z} = P$）。变量 $p_{x}$、$p_{y}$、$p_{z}$ 是正整数，且必须是相应 $N_i$ 的因子。这个离散优化问题有通往唯一、稳定且有意义解的清晰路径。\n- **客观性**：该问题使用精确、明确的技术语言陈述。没有主观或基于观点的陈述。\n\n### 步骤3：结论与行动\n该问题是有效的，因为它具有科学依据、适定性且客观。它没有任何致命缺陷。我将继续进行求解。\n\n目标是最小化所有 $P$ 个MPI秩的总晕圈表面积。对于单个MPI秩，其子域是一个尺寸为 $n_{x} \\times n_{y} \\times n_{z}$ 的长方体。该子域的表面积代表了需要与其邻居交换的数据量，由 $S_{\\text{local}} = 2(n_{x}n_{y} + n_{y}n_{z} + n_{z}n_{x})$ 给出。\n\n问题指明我们应忽略边界条件导致的通信减少。这意味着我们建模通信成本时，假设每个秩都通过其所有六个面进行通信。总晕圈表面积 $S$ 是所有 $P$ 个子域的表面积之和。由于所有子域尺寸相同，因此：\n$$S = P \\cdot S_{\\text{local}} = 2P(n_{x}n_{y} + n_{y}n_{z} + n_{z}n_{x})$$\n\n为了进行优化，我们必须将 $S$ 表示为进程网格维度 $p_{x}$、$p_{y}$ 和 $p_{z}$ 的函数，这些是我们可以选择的变量。我们使用给定的关系式 $n_{x} = N_{x}/p_{x}$，$n_{y} = N_{y}/p_{y}$ 和 $n_{z} = N_{z}/p_{z}$：\n$$S(p_{x}, p_{y}, p_{z}) = 2P \\left( \\frac{N_{x}}{p_{x}} \\frac{N_{y}}{p_{y}} + \\frac{N_{y}}{p_{y}} \\frac{N_{z}}{p_{z}} + \\frac{N_{z}}{p_{z}} \\frac{N_{x}}{p_{x}} \\right)$$\n$$S(p_{x}, p_{y}, p_{z}) = 2P \\left( \\frac{N_{x}N_{y}}{p_{x}p_{y}} + \\frac{N_{y}N_{z}}{p_{y}p_{z}} + \\frac{N_{z}N_{x}}{p_{z}p_{x}} \\right)$$\n\n我们可以使用约束条件 $p_{x}p_{y}p_{z} = P$ 来简化这个表达式。由此可得 $p_{x}p_{y} = P/p_{z}$，$p_{y}p_{z} = P/p_{x}$ 和 $p_{z}p_{x} = P/p_{y}$。将这些代入 $S$ 的表达式中：\n$$S(p_{x}, p_{y}, p_{z}) = 2P \\left( \\frac{N_{x}N_{y}}{P/p_{z}} + \\frac{N_{y}N_{z}}{P/p_{x}} + \\frac{N_{z}N_{x}}{P/p_{y}} \\right)$$\n$$S(p_{x}, p_{y}, p_{z}) = 2 (N_{x}N_{y}p_{z} + N_{y}N_{z}p_{x} + N_{z}N_{x}p_{y})$$\n\n我们需要在约束条件 $p_{x}p_{y}p_{z} = P$ 下最小化此函数 $S(p_{x}, p_{y}, p_{z})$。我们通过定义三个正项来分析这个和：$A = N_{y}N_{z}p_{x}$，$B = N_{z}N_{x}p_{y}$ 和 $C = N_{x}N_{y}p_{z}$。\n我们要最小化和 $A+B+C$。让我们考虑它们的乘积：\n$$A \\cdot B \\cdot C = (N_{y}N_{z}p_{x})(N_{z}N_{x}p_{y})(N_{x}N_{y}p_{z})$$\n$$A \\cdot B \\cdot C = (N_{x}N_{y}N_{z})^{2} (p_{x}p_{y}p_{z}) = (N_{x}N_{y}N_{z})^{2}P$$\n由于 $N_{x}$、$N_{y}$、$N_{z}$ 和 $P$ 是常数，乘积 $A \\cdot B \\cdot C$ 也是一个常数。\n\n根据算术平均-几何平均（AM-GM）不等式，对于正数 $A, B, C$，当这些数相等时，即 $A=B=C$ 时，它们的和最小。\n$$\n\\frac{A+B+C}{3} \\ge \\sqrt[3]{ABC}\n$$\n当且仅当 $A=B=C$ 时，等号成立，此时和 $A+B+C$ 达到最小值。\n令 $A=B$：\n$$N_{y}N_{z}p_{x} = N_{z}N_{x}p_{y} \\implies N_{y}p_{x} = N_{x}p_{y} \\implies \\frac{p_{x}}{N_{x}} = \\frac{p_{y}}{N_{y}}$$\n令 $B=C$：\n$$N_{z}N_{x}p_{y} = N_{x}N_{y}p_{z} \\implies N_{z}p_{y} = N_{y}p_{z} \\implies \\frac{p_{y}}{N_{y}} = \\frac{p_{z}}{N_{z}}$$\n因此，最小化总表面积的条件是：\n$$\\frac{p_{x}}{N_{x}} = \\frac{p_{y}}{N_{y}} = \\frac{p_{z}}{N_{z}}$$\n这表明最优的进程网格分解必须与全局数据域具有相同的纵横比。\n\n现在，我们将此结果应用于具体的题目参数：$N_{x} = 1024$，$N_{y} = 1024$，$N_{z} = 1024$ 和 $P = 512$。\n全局域是一个立方体，因此 $N_{x}:N_{y}:N_{z} = 1:1:1$。最优的进程网格也必须是立方的，即 $p_{x}:p_{y}:p_{z} = 1:1:1$，或 $p_{x}=p_{y}=p_{z}$。\n\n我们将此与约束条件 $p_{x}p_{y}p_{z} = P$ 结合使用：\n$$p_{x} \\cdot p_{x} \\cdot p_{x} = 512 \\implies p_{x}^{3} = 512$$\n$$p_{x} = \\sqrt[3]{512} = 8$$\n因此，进程网格维度的最优选择是 $p_{x}=8$，$p_{y}=8$ 和 $p_{z}=8$。\n\n我们必须验证该解是否有效。这些值必须是整数，它们确实是。它们的乘积是 $8 \\times 8 \\times 8 = 512 = P$。最后，每个 $p_{i}$ 必须能整除相应的 $N_{i}$。由于 $N_{x}=N_{y}=N_{z}=1024$，我们检查 $8$ 是否能整除 $1024$。\n$$1024 \\div 8 = 128$$\n除法是精确的，所以条件满足。最优的进程网格是 $p_{x}=8$，$p_{y}=8$，$p_{z}=8$。\n\n最后，我们计算这个最优分解对应的局部子域大小 $n_{x}$、$n_{y}$ 和 $n_{z}$：\n$$n_{x} = \\frac{N_{x}}{p_{x}} = \\frac{1024}{8} = 128$$\n$$n_{y} = \\frac{N_{y}}{p_{y}} = \\frac{1024}{8} = 128$$\n$$n_{z} = \\frac{N_{z}}{p_{z}} = \\frac{1024}{8} = 128$$\n最优分解得到大小为 $128 \\times 128 \\times 128$ 的立方体子域。这是符合预期的，因为在给定体积下，立方体的表面积最小。\n\n最终答案要求按 $p_{x}$、$p_{y}$、$p_{z}$、$n_{x}$、$n_{y}$、$n_{z}$ 的顺序给出这些值。\n这些值为 $8, 8, 8, 128, 128, 128$。", "answer": "$$\\boxed{\\begin{pmatrix} 8 & 8 & 8 & 128 & 128 & 128 \\end{pmatrix}}$$", "id": "3586125"}, {"introduction": "在确定了最优的区域分解策略后，下一步便是高效且正确地实现处理器之间的边界数据交换。这种“光晕”或“鬼影”区域（halo/ghost region）的交换是并行模板计算中的关键环节，但如果实现不当，极易引发程序死锁。此练习 [@problem_id:3586198] 旨在让您掌握如何使用非阻塞MPI（Message Passing Interface）通信来设计一个健壮、无死锁的光晕交换模式，这是每个并行计算开发者都必须具备的核心技能。", "problem": "一个三维有限差分地震波模拟被离散化到一个全局维度为 $N_x \\times N_y \\times N_z$ 的均匀笛卡尔网格上。该代码使用一种笔状区域分解：进程网格为 $P_x \\times P_y \\times 1$，因此每个子域都跨越了完整的 $z$ 轴范围，即每个进程持有一个大小为 $n_x \\times n_y \\times N_z$ 的局部块，其中 $n_x = N_x / P_x$ 且 $n_y = N_y / P_y$。光环厚度为 $h = 1$。假设在 $x$ 和 $y$ 方向上为非周期性物理边界，因此内部进程有 $4$ 个邻居（$\\pm x$, $\\pm y$），在 $z$ 方向没有邻居，因为每个笔状区域都跨越了完整的 $z$ 维度。$x$ 和 $y$ 方向的光环分别是 $yz$ 面和 $xz$ 面。该实现使用消息传递接口（MPI），通过非阻塞点对点调用和派生数据类型将每个面打包成单条消息。\n\n您的任务是为每个时间步设计一个单一的通信阶段，在该阶段中，所有在 $x$ 和 $y$ 方向上所需的交换都使用非阻塞点对点操作并发地提交。该设计必须避免死锁，无论消息大小、内部协议（渴求模式与会合模式）或资源限制如何，且不依赖任何如屏障之类的集体同步操作。为每个方向使用不同的消息标签以确保无歧义的匹配。\n\n在这些约束条件下，哪个选项正确地指明了：\n- 用于非阻塞光环交换的提交和等待的安全顺序，以及\n- 每个邻居所需的点对点消息的最小数量，以及每个时间步所需的点对点消息总数，\n这两项都要求针对 (i) 每个内部进程以及 (ii) 整个 $P_x \\times P_y \\times 1$ 进程网格的全局情况？\n\n选择唯一的最佳选项。\n\nA. 首先提交所有 $x$ 和 $y$ 方向的 `MPI_Isend` 操作，然后提交所有 `MPI_Irecv` 操作，最后用一个单独的 `MPI_Waitall` 来完成；使用派生数据类型，由于双向进展，每个邻居最少需要 $1$ 条消息，因此一个内部进程每步发送/接收 $4$ 条消息；全局总数为每步 $2 P_x P_y$ 条消息。\n\nB. 首先提交所有 $x$ 和 $y$ 方向的 `MPI_Irecv` 操作，然后提交所有 `MPI_Isend` 操作，最后对所有请求使用一个单独的 `MPI_Waitall` 来完成；使用派生数据类型，每个邻居最少需要 $2$ 条消息（每个方向一条），因此一个内部进程每步使用 $8$ 条消息；全局总数为\n$$2\\Big[(P_x - 1) P_y + (P_y - 1) P_x\\Big].$$\n\nC. 为避免死锁，将交换分为 $2$ 个阶段：首先提交并完成所有 $x$ 方向的交换，然后提交并完成所有 $y$ 方向的交换；在每个阶段内，使用 `MPI_Isend` 然后 `MPI_Irecv` 然后 `MPI_Waitall`；使用派生数据类型，每个邻居最少需要 $2$ 条消息，因此一个内部进程每步使用 $8$ 条消息；全局总数为\n$$2\\Big[(P_x - 1) P_y + (P_y - 1) P_x\\Big].$$\n\nD. 使用 `MPI_Barrier` 同步所有进程，然后按邻居交替进行：对于每个邻居，提交 `MPI_Isend` 紧接着提交 `MPI_Irecv`，然后对该配对进行 `MPI_Wait`，再处理下一个邻居；每个邻居最少需要 $1$ 条消息；一个内部进程每步使用 $4$ 条消息；全局总数为每步 $P_x P_y$ 条消息。", "solution": "用户提供了一个关于为使用笔状区域分解的三维有限差分模拟设计无死锁、非阻塞MPI光环交换的问题。\n\n### 步骤1：提取已知条件\n\n- **问题领域：** $3\\text{D}$ 有限差分地震波模拟。\n- **全局网格：** 大小为 $N_x \\times N_y \\times N_z$ 的均匀笛卡尔网格。\n- **区域分解：** 笔状分解，进程网格为 $P_x \\times P_y \\times 1$。\n- **局部网格：** 每个MPI进程持有一个大小为 $n_x \\times n_y \\times N_z$ 的块，其中 $n_x = N_x / P_x$ 且 $n_y = N_y / P_y$。\n- **光环（幽灵）单元：** 光环厚度为 $h=1$。需要在 $x$ 和 $y$ 维度进行光环交换。光环分别是用于 $x$ 方向交换的 $yz$ 面和用于 $y$ 方向交换的 $xz$ 面。\n- **边界条件：** 在 $x$ 和 $y$ 方向为非周期性物理边界。\n- **邻居拓扑：** 内部进程有 $4$ 个邻居（在 $\\pm x$ 和 $\\pm y$ 方向）。在 $z$ 方向没有邻居。\n- **通信协议：** 消息传递接口（MPI），使用非阻塞点对点调用（`MPI_Isend`, `MPI_Irecv`）。\n- **数据打包：** 使用派生数据类型将每个面打包成单条消息。\n- **消息匹配：** 为每个方向使用不同的消息标签。\n- **核心任务要求：** 为所有 $x$ 和 $y$ 的交换设计一个单一的、并发的通信阶段。\n- **约束条件：**\n    1. 无论消息大小、MPI内部协议（渴求模式 vs. 会合模式）或系统资源限制如何，设计都必须无死锁。\n    2. 设计不得使用如 `MPI_Barrier` 之类的集体同步调用。\n\n### 步骤2：使用已知条件进行验证\n\n该问题陈述具有科学依据、定义明确且客观。它描述了高性能科学计算中一个标准的、典型的问题。使用非阻塞MPI调用实现并行光环交换的场景是计算科学与工程领域的基础。所提供的约束（无屏障地避免死锁）是现实的，并精确地定义了问题，要求基于对MPI语义的正确理解来提供一个特定的、健壮的解决方案。所使用的术语（笔状分解、非阻塞、派生数据类型、死锁、会合协议）是标准且明确的。该问题是可形式化和可解决的。确定正确通信策略和计算消息数量所需的所有信息都已给出。因此，该问题是有效的。\n\n### 步骤3：正确解的推导\n\n#### 第1部分：非阻塞操作的安全顺序\n\n首要约束是设计一个能健壮地避免死锁的通信模式，特别是在大消息可能导致MPI从“渴求”协议（发送方缓冲数据）切换到“会合”协议的情况下。在会合协议中，一个发送操作可能会阻塞，直到目标进程提交了相应的接收操作。\n\n考虑两个必须交换光环数据的邻近进程 $P_1$ 和 $P_2$。$P_1$ 向 $P_2$ 发送并从 $P_2$ 接收；同时，$P_2$ 向 $P_1$ 发送并从 $P_1$ 接收。\n\n让我们分析可能的顺序：\n1.  **所有进程先提交 `MPI_Isend`，再提交 `MPI_Irecv`：** `MPI_Isend` 给邻居 $\\rightarrow$ `MPI_Irecv` 从邻居接收 $\\rightarrow$ `MPI_Waitall`。\n    这种模式是**不安全**的。如果所有进程都试图同时发送大消息，`MPI_Isend` 调用可能会阻塞，等待目标进程提交匹配的接收。由于所有进程都在尝试发送，而没有一个进程提交接收，系统可能会进入死锁状态。即使使用非阻塞调用，这也可能导致资源耗尽（例如，填满所有可用的MPI/网络缓冲区），从而导致应用程序挂起，这也是一种形式的死锁。\n\n2.  **所有进程先提交 `MPI_Irecv`，再提交 `MPI_Isend`：** `MPI_Irecv` 从邻居接收 $\\rightarrow$ `MPI_Isend` 给邻居 $\\rightarrow$ `MPI_Waitall`。\n    这种模式是**安全且健壮**的。通过首先提交所有接收，每个进程通知MPI库它已分配好缓冲区空间并准备好接收传入数据。当随后提交 `MPI_Isend` 调用时，MPI实现知道有一个匹配的接收正在等待，从而允许数据传输进行而无需发送调用阻塞。这种模式是实现非阻塞光环交换的标准、推荐做法，并保证不会发生由通信引起的死锁，满足了问题的核心约束。\n\n3.  **其他模式：** 按维度拆分通信（例如，所有 $x$ 方向交换，然后所有 $y$ 方向交换）或按邻居串行化是安全的，但分别引入了不必要的同步点或降低了并行性。它们也违背了在“单一通信阶段”中“并发地”提交“所有所需交换”的要求。使用 `MPI_Barrier` 是被明确禁止的。\n\n最优且最健壮的策略是为所有邻居提交所有非阻塞接收，然后为所有邻居提交所有非阻塞发送，最后对所有发送和接收请求的集合调用一次 `MPI_Waitall` 以确保完成。\n\n#### 第2部分：消息数量的计算\n\n-   **每个邻居的消息数：** 对于任何给定的进程，与一个邻居的通信需要发送一条消息（一个 `MPI_Isend` 调用）和接收一条消息（一个 `MPI_Irecv` 调用）。问题陈述指出，派生数据类型将整个面打包到单条消息中。因此，从该进程的角度来看，与单个邻居的交换包含 $2$ 条点对点消息。\n\n-   **每个内部进程的消息数：** 一个内部进程有 $4$ 个邻居（$\\pm x, \\pm y$）。由于与每个邻居的通信涉及 $2$ 条消息（一次发送，一次接收），一个内部进程每个时间步总共发起 $4 \\times 2 = 8$ 次点对点MPI操作。这对应于 $4$ 个 `MPI_Isend` 调用和 $4$ 个 `MPI_Irecv` 调用。\n\n-   **全局总消息数：** 为了计算整个模拟的总消息数，我们计算通信对的数量，并乘以 $2$（每对之间每个方向一条消息）。\n    - 进程网格为 $P_x \\times P_y$。\n    - 垂直接口的数量（$x$ 方向的邻居对）为 $(P_x - 1) \\times P_y$。\n    - 水平接口的数量（$y$ 方向的邻居对）为 $(P_y - 1) \\times P_x$。\n    - 唯一的邻居对总数为它们的和：$(P_x - 1) P_y + (P_y - 1) P_x$。\n    - 由于每对每个时间步交换两条消息，全局总消息数为：\n    $$ M_{total} = 2 \\Big[ (P_x - 1) P_y + (P_y - 1) P_x \\Big] $$\n\n### 逐项分析选项\n\n**A. 首先提交所有 $x$ 和 $y$ 方向的 `MPI_Isend` 操作，然后提交所有 `MPI_Irecv` 操作，最后用一个单独的 `MPI_Waitall` 来完成；使用派生数据类型，由于双向进展，每个邻居最少需要 $1$ 条消息，因此一个内部进程每步发送/接收 $4$ 条消息；全局总数为每步 $2 P_x P_y$ 条消息。**\n\n-   **顺序：** 先 `Isend` 后 `Irecv`。这是一个容易导致死锁的不安全模式，违反了一个关键的问题约束。\n-   **消息计数：** “每个邻居1条消息”和内部进程“每步4条消息”是错误的。双向交换需要两条消息（1次发送，1次接收）。因此，一个内部进程处理8条消息。全局总数公式 $2 P_x P_y$ 也是错误的。\n-   **结论：** **错误**。\n\n**B. 首先提交所有 $x$ 和 $y$ 方向的 `MPI_Irecv` 操作，然后提交所有 `MPI_Isend` 操作，最后对所有请求使用一个单独的 `MPI_Waitall` 来完成；使用派生数据类型，每个邻居最少需要 $2$ 条消息（每个方向一条），因此一个内部进程每步使用 $8$ 条消息；全局总数为 $2\\Big[(P_x - 1) P_y + (P_y - 1) P_x\\Big]$.**\n\n-   **顺序：** 先 `Irecv` 后 `Isend`。这是非阻塞交换的典型的、无死锁的模式。这是正确的。\n-   **消息计数：** “每个邻居2条消息”，内部进程“每步8条消息”，以及全局总数公式 $2\\Big[(P_x - 1) P_y + (P_y - 1) P_x\\Big]$ 都与我们的推导一致。这是正确的。\n-   **结论：** **正确**。\n\n**C. 为避免死锁，将交换分为 $2$ 个阶段：首先提交并完成所有 $x$ 方向的交换，然后提交并完成所有 $y$ 方向的交换；在每个阶段内，使用 `MPI_Isend` 然后 `MPI_Irecv` 然后 `MPI_Waitall`；使用派生数据类型，每个邻居最少需要 $2$ 条消息，因此一个内部进程每步使用 $8$ 条消息；全局总数为 $2\\Big[(P_x - 1) P_y + (P_y - 1) P_x\\Big]$.**\n\n-   **顺序：** 这个选项提出了两个缺陷。首先，它在每个阶段内使用了不安全的先 `Isend` 的顺序。其次，将交换分成两个带有中间 `Waitall` 的阶段引入了不必要的同步屏障，与单阶段方法相比降低了性能和并发性，并且它违反了对“所有所需交换”使用“单一通信阶段”的要求。\n-   **消息计数：** 消息计数的陈述是正确的。然而，它们与一个有缺陷且非最优的通信策略相关联。\n-   **结论：** **错误**。\n\n**D. 使用 `MPI_Barrier` 同步所有进程，然后按邻居交替进行：对于每个邻居，提交 `MPI_Isend` 紧接着提交 `MPI_Irecv`，然后对该配对进行 `MPI_Wait`，再处理下一个邻居；每个邻居最少需要 $1$ 条消息；一个内部进程每步使用 $4$ 条消息；全局总数为每步 $P_x P_y$ 条消息。**\n\n-   **顺序：** 使用 `MPI_Barrier` 明确违反了问题的一个约束。此外，逐个邻居串行化通信是低效的，并且不构成所有交换的“并发”提交。\n-   **消息计数：** 所陈述的消息计数（“每个邻居1条”，“每个内部进程4条”，“全局$P_x P_y$条”）都是错误的。\n-   **结论：** **错误**。", "answer": "$$\\boxed{B}$$", "id": "3586198"}, {"introduction": "计算任务完成后，我们常常需要将分布在各个并行进程上的数据整合起来，写入一个单一的、连贯的共享文件中。确保每个进程的数据块都能精确地写入文件中的预定位置，既无缝隙（导致数据丢失）也无重叠（导致数据损坏），是并行I/O正确性的基石。本实践 [@problem_id:3586127] 将检验您对如何将三维空间区域分解映射到一维文件布局的理解，通过构建MPI子数组数据类型和文件视图来保证最终输出数据的完整性。", "problem": "给定一个三维全局数组，它表示一个地球物理模型（例如，速度立方体），维度为 $N_x \\times N_y \\times N_z$。数据需要以与 C 语言约定一致的规范行主序写入单个共享文件中，即最后一个索引变化最快。形式上，将一个满足 $0 \\le i  N_x$、$0 \\le j  N_y$ 和 $0 \\le k  N_z$ 的全局索引 $(i,j,k)$ 线性化为单个标量索引 $L(i,j,k)$ 的定义如下：\n$$\nL(i,j,k) = \\big(i \\cdot N_y + j\\big)\\cdot N_z + k,\n$$\n一个大小为 $s$ 字节的元素的字节位移为 $d(i,j,k) = s \\cdot L(i,j,k)$。\n\n在域分解策略中，每个进程拥有一个作为全局数组块的矩形子数组。一个块由其起始索引和范围 $(x_0,y_0,z_0,n_x,n_y,n_z)$ 指定，其中 $0 \\le x_0  N_x$，$0 \\le y_0  N_y$，$0 \\le z_0  N_z$，以及 $1 \\le n_x \\le N_x$，$1 \\le n_y \\le N_y$，$1 \\le n_z \\le N_z$，并满足约束条件 $x_0 + n_x \\le N_x$，$y_0 + n_y \\le N_y$ 和 $z_0 + n_z \\le N_z$。使用消息传递接口 (MPI) 的子数组数据类型和集体并行输入/输出 (I/O) 中与之匹配的文件视图，每个进程写入其本地块，以使所有块的并集能够精确且无重叠地覆盖整个全局数组。\n\n您的任务是实现一个程序，针对每个测试用例，计算在 C 语言行主序下由 MPI 子数组数据类型所隐含的文件段列表，并从以下方面验证分解和文件视图映射的正确性：\n- 正确性要求所有进程拥有的元素的并集等于全局元素的完整集合，没有任何元素被多个进程写入，也没有任何元素被遗漏。\n- 对每个进程而言，文件段必须沿着最快变化的维度是连续的。在 C 语言行主序中，最快变化的维度是 $z$ 维度。因此，对于一个块 $(x_0,y_0,z_0,n_x,n_y,n_z)$，每个由满足 $0 \\le i  n_x$ 和 $0 \\le j  n_y$ 的 $(i,j)$ 索引的行都会产生一个连续的文件段，其起始字节位移为\n$$\nd_{start}(i,j) = s \\cdot \\Big(\\big((x_0 + i)\\cdot N_y + (y_0 + j)\\big)\\cdot N_z + z_0\\Big)\n$$\n段长度（以字节为单位）为\n$$\n\\ell = s \\cdot n_z.\n$$\n\n请从数组线性化和空间分解的基本定义出发。除了这些基本原理外，不要使用任何快捷公式。您的程序需要针对每个测试用例，计算所提供的分解在使用上述线性化方法以及每个 $(i,j)$ 行对应连续 $z$ 段的解释下，是否能实现文件布局的精确覆盖且无重叠。\n\n测试套件包含以下 $4$ 个用例。对于每个用例，$s$ 表示元素大小（以字节为单位），块列表给出了每个进程的 $(x_0,y_0,z_0,n_x,n_y,n_z)$：\n\n- 用例 $1$：全局维度 $N_x=2, N_y=3, N_z=4$，元素大小 $s=8$。块：\n  - 进程 $0$：$(x_0,y_0,z_0,n_x,n_y,n_z) = (0,0,0,1,3,4)$。\n  - 进程 $1$：$(x_0,y_0,z_0,n_x,n_y,n_z) = (1,0,0,1,3,4)$。\n\n- 用例 $2$：全局维度 $N_x=2, N_y=2, N_z=3$，元素大小 $s=4$。块：\n  - 进程 $0$：$(x_0,y_0,z_0,n_x,n_y,n_z) = (0,0,0,2,1,3)$。\n  - 进程 $1$：$(x_0,y_0,z_0,n_x,n_y,n_z) = (1,0,0,1,2,3)$。\n\n- 用例 $3$：全局维度 $N_x=3, N_y=1, N_z=1$，元素大小 $s=2$。块：\n  - 进程 $0$：$(x_0,y_0,z_0,n_x,n_y,n_z) = (0,0,0,1,1,1)$。\n  - 进程 $1$：$(x_0,y_0,z_0,n_x,n_y,n_z) = (1,0,0,1,1,1)$。\n  - 进程 $2$：$(x_0,y_0,z_0,n_x,n_y,n_z) = (2,0,0,1,1,1)$。\n\n- 用例 $4$：全局维度 $N_x=3, N_y=2, N_z=5$，元素大小 $s=4$。块：\n  - 进程 $0$：$(x_0,y_0,z_0,n_x,n_y,n_z) = (0,0,0,3,2,2)$。\n  - 进程 $1$：$(x_0,y_0,z_0,n_x,n_y,n_z) = (0,0,2,3,2,3)$。\n\n您的程序必须对每个用例执行以下操作：\n- 验证每个块的边界。\n- 使用上述公式，推导出每个进程的连续文件段列表（起始位移和长度，以字节为单位）。\n- 验证所有元素的并集恰好是集合 $\\{0,1,\\dots,N_x N_y N_z - 1\\}$，没有重复也没有遗漏。\n\n程序的最终输出必须是单行文本，其中包含所有用例的结果，以逗号分隔的列表形式，并用方括号括起来。每个结果都必须是一个布尔值，指示该分解和隐含的文件视图是否实现了文件的精确、无重叠覆盖。例如，输出应类似于 $[r_1,r_2,r_3,r_4]$，其中每个 $r_c$ 为 $\\text{True}$ 或 $\\text{False}$。任何内部计算中的所有字节量都必须以字节（单位：bytes）表示。不涉及角度。不涉及百分比。", "solution": "该问题要求验证用于并行文件 I/O 的域分解。其基本原理是，当多个进程将全局数据集的本地部分写入单个共享文件时，它们的写入操作必须共同构成最终文件布局的一个完美的、无重叠的划分。任何偏差，例如重叠的写入区域（竞争条件）或间隙（数据丢失），都会损害数据集的完整性。该问题定义了一种特定的文件布局，它对应于三维数组的 C 风格行主序线性化，以及一种从逻辑进程块到文件段的特定映射。我们的任务是验证给定的一组块是否构成了这样一个完美的划分。\n\n从逻辑三维网格到一维文件空间的映射由线性化公式决定。对于一个维度为 $N_x \\times N_y \\times N_z$ 的全局数组，位于全局索引 $(i, j, k)$（其中 $0 \\le i  N_x$，$0 \\le j  N_y$ 且 $0 \\le k  N_z$）的元素，其线性索引 $L(i,j,k)$ 由下式给出：\n$$\nL(i,j,k) = \\big(i \\cdot N_y + j\\big)\\cdot N_z + k\n$$\n该公式表明，索引 $k$（沿 $z$ 轴）变化最快，其次是 $j$（沿 $y$ 轴），最后是 $i$（沿 $x$ 轴）。对于大小为 $s$ 字节的元素，其在文件中的起始字节偏移量为 $d(i,j,k) = s \\cdot L(i,j,k)$。\n\n每个进程被分配一个全局数组的矩形块，由其原点 $(x_0, y_0, z_0)$ 和维度 $(n_x, n_y, n_z)$ 定义。当将此块写入文件时，MPI 子数组数据类型会将该块划分为一系列连续的段。由于 $z$ 维度对应于变化最快的索引 $k$，因此沿该维度的连续元素序列会映射到文件中的一个连续字节段。具体来说，对于本地块在 $x-y$ 平面投影内的每个 $(i, j)$ 对，沿 $z$ 轴的 $n_z$ 个元素构成一个这样的连续文件段。因此，每个块的此类段的数量为 $n_x \\cdot n_y$。每个段的起始位移和长度由以下公式给出：\n$$\nd_{start}(i,j) = s \\cdot \\Big(\\big((x_0 + i)\\cdot N_y + (y_0 + j)\\big)\\cdot N_z + z_0\\Big)\n$$\n$$\n\\ell = s \\cdot n_z\n$$\n其中 $0 \\le i  n_x$ 且 $0 \\le j  n_y$。\n\n为了验证分解，我们将三维空间划分问题转化为一维区间覆盖问题。整个文件代表一个从字节 $0$ 到总大小 $S_{total} = s \\cdot N_x \\cdot N_y \\cdot N_z$ 的一维区间。分解的正确性等同于检查由所有进程块生成的所有段的集合是否构成了该区间的完美平铺。\n\n算法流程如下：\n$1$. 对于每个测试用例，我们首先进行初步检查，以确所有提供的块定义 $(x_0, y_0, z_0, n_x, n_y, n_z)$ 都是有效的，即它们位于全局域 $[0, N_x) \\times [0, N_y) \\times [0, N_z)$ 的边界内。\n$2$. 我们为所有块生成所有文件段的完整列表。对于每个块，我们遍历其本地 $x$ 和 $y$ 维度（$i$ 从 $0$ 到 $n_x-1$，$j$ 从 $0$ 到 $n_y-1$），并计算相应段的起始位移 $d_{start}$ 和长度 $\\ell$。每个段表示为一个对 $(d_{start}, \\ell)$。\n$3$. 然后，将所有段的聚合列表根据起始位移 $d_{start}$ 按升序排序。\n$4$. 接着，我们遍历已排序的段列表以验证平铺属性。我们维护一个初始化为 $0$ 的指针 `current_position`。\n    a. 排序后列表中第一个段的起始位移必须为 $0$。否则，文件开头存在间隙。\n    b. 对于列表中的每个段 $(d_{start}, \\ell)$，我们检查其起始位移 $d_{start}$ 是否等于 `current_position`。如果不相等，则表示存在间隙（如果 $d_{start} > \\text{current\\_position}$）或重叠（如果 $d_{start}  \\text{current\\_position}$）。在一个非零长度段的有序列表中，后一种情况意味着前面存在重叠。\n    c. 如果检查通过，我们通过加上段长度来更新 `current_position`：$\\text{current\\_position} = d_{start} + \\ell$。\n$5$. 遍历所有段后，`current_position` 的最终值必须等于预期的文件总大小 $S_{total}$。如果不相等，则表示数据分区不完整或超出了文件边界。\n\n如果所有这些检查都通过，则该分解被认为是正确的，保证了概念文件中的每个字节都由恰好一个进程写入。否则，该分解是有缺陷的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the domain decomposition validation problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"global_dims\": (2, 3, 4), \"element_size\": 8,\n            \"blocks\": [\n                (0, 0, 0, 1, 3, 4),\n                (1, 0, 0, 1, 3, 4),\n            ]\n        },\n        {\n            \"global_dims\": (2, 2, 3), \"element_size\": 4,\n            \"blocks\": [\n                (0, 0, 0, 2, 1, 3),\n                (1, 0, 0, 1, 2, 3),\n            ]\n        },\n        {\n            \"global_dims\": (3, 1, 1), \"element_size\": 2,\n            \"blocks\": [\n                (0, 0, 0, 1, 1, 1),\n                (1, 0, 0, 1, 1, 1),\n                (2, 0, 0, 1, 1, 1),\n            ]\n        },\n        {\n            \"global_dims\": (3, 2, 5), \"element_size\": 4,\n            \"blocks\": [\n                (0, 0, 0, 3, 2, 2),\n                (0, 0, 2, 3, 2, 3),\n            ]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(validate_decomposition(case))\n    \n    # The expected output is [True, False, True, True]\n    # We format the output as a list of strings and join them.\n    # The boolean values are converted to lowercase 'true' or 'false' by default in Python f-strings,\n    # but the problem asks for True/False.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef validate_decomposition(case_data):\n    \"\"\"\n    Validates a single domain decomposition case.\n\n    Args:\n        case_data (dict): A dictionary containing global dimensions, element size,\n                          and a list of blocks.\n\n    Returns:\n        bool: True if the decomposition is valid, False otherwise.\n    \"\"\"\n    Nx, Ny, Nz = case_data[\"global_dims\"]\n    s = case_data[\"element_size\"]\n    blocks = case_data[\"blocks\"]\n    \n    all_segments = []\n\n    # Step 1  2: Verify block bounds and generate all file segments.\n    for block in blocks:\n        x0, y0, z0, nx, ny, nz = block\n        \n        # Verify block bounds\n        if not (0 = x0 and 0 = y0 and 0 = z0 and\n                1 = nx and 1 = ny and 1 = nz and\n                x0 + nx = Nx and y0 + ny = Ny and z0 + nz = Nz):\n            return False\n\n        # Generate segments for the current block\n        segment_length = s * nz\n        for i in range(nx): # local x-index\n            for j in range(ny): # local y-index\n                global_i = x0 + i\n                global_j = y0 + j\n                \n                # Linearization to find start of the z-run\n                linear_index = (global_i * Ny + global_j) * Nz + z0\n                start_displacement = s * linear_index\n                \n                all_segments.append((start_displacement, segment_length))\n\n    # Step 3: Sort segments by starting displacement\n    all_segments.sort(key=lambda seg: seg[0])\n\n    # Step 4  5: Validate the tiling of the file space\n    total_file_size = s * Nx * Ny * Nz\n    \n    if not all_segments:\n        return total_file_size == 0\n\n    # Check if the first segment starts at 0\n    if all_segments[0][0] != 0:\n        return False\n        \n    current_pos = 0\n    for start, length in all_segments:\n        # Check for gaps or overlaps\n        if start != current_pos:\n            return False\n        # Move to the end of the current segment\n        current_pos = start + length\n        \n    # Check if the full file is covered\n    if current_pos != total_file_size:\n        return False\n        \n    return True\n\nsolve()\n```", "id": "3586127"}]}