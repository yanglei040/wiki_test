{"hands_on_practices": [{"introduction": "在评估多重网格方法的计算效率时，建立一个标准的性能模型是至关重要的。本练习提供了一个具体的情景，您将学习如何通过分析平滑、限制和延拓等各个组件的成本来量化一个V循环的总计算功（以“工作单元”为单位）。通过这种分析，您可以预测求解器达到特定收敛目标所需的总时间，从而掌握评估和比较不同多重网格策略性能的基本技能。[@problem_id:3611397]", "problem": "一个地球物理反演问题主要在于重复求解一个椭圆线性系统，该系统源自一个用于模拟地下电导率的三维扩散模型。该线性系统在非结构化网格上进行离散化，其求解器为代数多重网格（AMG）方法，每次外层迭代使用单个V-循环。目标是估计每个V-循环所需的计算功（以工作单元计）以及将残差范数减小一个指定因子所需的总挂钟时间。\n\n采用以下定义和数据：\n- 单个工作单元（WU）定义为与最细层算子进行一次稀疏矩阵向量乘积（SpMV）的代价。如果某操作等效于在第 $\\ell$ 层上的一次SpMV，其代价（以WU计）将按非零元比率 $\\mathrm{NZ}_{\\ell}/\\mathrm{NZ}_{0}$ 进行缩放，其中 $\\mathrm{NZ}_{\\ell}$ 是第 $\\ell$ 层算子的非零元数量，$\\mathrm{NZ}_{0}$ 是最细层的非零元数量。\n- 多重网格层级有四层，$\\ell=0,1,2,3$，其中最细层为 $\\ell=0$，最粗层为 $\\ell=3$。每层的非零元数量为：$\\mathrm{NZ}_{0}=3.2\\times 10^{8}$，$\\mathrm{NZ}_{1}=7.9\\times 10^{7}$，$\\mathrm{NZ}_{2}=1.9\\times 10^{7}$，$\\mathrm{NZ}_{3}=4.7\\times 10^{6}$。\n- 在每个非最粗层（$\\ell=0,1,2$）上，光滑子是阻尼Jacobi方法，进行 $\\nu_{1}=2$ 次前光滑扫描和 $\\nu_{2}=2$ 次后光滑扫描。在第 $\\ell$ 层上，一次光滑子扫描的代价是 $\\beta\\,(\\mathrm{NZ}_{\\ell}/\\mathrm{NZ}_{0})$ WU，其中 $\\beta=1.1$。\n- 在每个非最粗层上，每次访问会计算一次残差，其代价为 $\\delta\\,(\\mathrm{NZ}_{\\ell}/\\mathrm{NZ}_{0})$ WU，其中 $\\delta=1.0$。\n- 限制和延拓的代价分别为 $\\tau_{R}\\,(\\mathrm{NZ}_{\\ell}/\\mathrm{NZ}_{0})$ WU 和 $\\tau_{P}\\,(\\mathrm{NZ}_{\\ell}/\\mathrm{NZ}_{0})$ WU，其中 $\\tau_{R}=\\tau_{P}=0.25$。\n- 在 $\\ell=3$ 的最粗层求解使用 $m_{c}=30$ 次光滑子扫描，其每次扫描的代价模型与之前相同，为 $\\beta\\,(\\mathrm{NZ}_{3}/\\mathrm{NZ}_{0})$ WU。\n- 一次最细层SpMV的挂钟时间为 $t_{\\mathrm{spmv}}=0.015$ 秒/WU。\n\n假设采用经典的两层网格误差传播解释：粗网格校正理想地消除了低频误差模式，而阻尼Jacobi光滑子则衰减高频误差模式。在最细层上，每次扫描测得的高频光滑因子为 $\\mu_{h}=0.45$。在估计每个V-循环的收敛因子时，将此 $\\mu_{h}$ 视为在各层上都具有代表性。忽略启动瞬态效应，并假设从第一个循环开始即表现为渐进行为。\n\n任务：\n1. 仅使用上述数据和定义，计算一个V-循环的总功（以WU为单位）。\n2. 根据“一个完整的V-循环通过累积的光滑效应将高频误差模式减小一个特定因子”这一解释，预测将残差范数减小 $10^{-8}$ 倍所需的V-循环次数，然后预测求解所需的总挂钟时间。\n\n将每个V-循环的功和预测的总求解时间均四舍五入到四位有效数字。时间以秒为单位表示。", "solution": "问题陈述经过严格验证，确认有效。其科学基础在于数值线性代数和计算科学的原理，特别是关于代数多重网格（AMG）方法的分析。该问题是适定的，为求得唯一解提供了所有必要的数据和定义。语言客观且精确。\n\n按要求，解答分为两部分：计算每个V-循环的功和预测总求解时间。\n\n### 第1部分：每个V-循环的计算功\n\n一个V-循环的总功 $W_V$ 是在多重网格层级每一层上所做功的总和。该层级包含四层，$\\ell=0, 1, 2, 3$，从最细到最粗。一个标准的V-循环按以下步骤进行：\n1.  在每个非最粗层 $\\ell$ 上，从最细到最粗（$\\ell=0, 1, 2$），执行 $\\nu_1$ 次前光滑扫描，计算一次残差，并将残差限制到下一更粗的层 $\\ell+1$。\n2.  在最粗层（$\\ell=3$）上，求解系统（在本例中，通过应用 $m_c$ 次光滑扫描）。\n3.  在每个非最粗层 $\\ell$ 上，从最粗到最细（$\\ell=2, 1, 0$），从下一更粗的层 $\\ell+1$ 延拓校正量，将其加到解上，并执行 $\\nu_2$ 次后光滑扫描。\n\n每个操作的代价以工作单元（WU）给出，并按当前层非零元数量 $\\mathrm{NZ}_{\\ell}$ 与最细层非零元数量 $\\mathrm{NZ}_{0}$ 的比率进行缩放。我们定义这个比率为 $r_{\\ell} = \\frac{\\mathrm{NZ}_{\\ell}}{\\mathrm{NZ}_{0}}$。\n\n在一个非最粗层 $\\ell \\in \\{0, 1, 2\\}$ 上，每个组成部分的功为：\n- 前光滑：$\\nu_{1}$ 次扫描，每次代价为 $\\beta r_{\\ell}$ WU。总计：$\\nu_{1}\\beta r_{\\ell}$。\n- 残差计算：$\\delta r_{\\ell}$ WU。\n- 限制到层 $\\ell+1$：$\\tau_{R} r_{\\ell}$ WU。\n- 从层 $\\ell+1$ 延拓：$\\tau_{P} r_{\\ell}$ WU。\n- 后光滑：$\\nu_{2}$ 次扫描，每次代价为 $\\beta r_{\\ell}$ WU。总计：$\\nu_{2}\\beta r_{\\ell}$。\n\n在最粗层 $\\ell=3$ 上的功是用于求解的：\n- 粗网格求解：$m_c$ 次光滑子扫描，每次代价为 $\\beta r_{3}$ WU。总计：$m_{c}\\beta r_{3}$。\n\n将所有层上的功相加，得到一个V-循环的总功 $W_V$：\n$$W_V = \\sum_{\\ell=0}^{2} (\\nu_{1}\\beta r_{\\ell} + \\delta r_{\\ell} + \\tau_{R} r_{\\ell}) + m_{c}\\beta r_{3} + \\sum_{\\ell=0}^{2} (\\tau_{P} r_{\\ell} + \\nu_{2}\\beta r_{\\ell})$$\n我们可以合并非最粗层的项：\n$$W_V = \\sum_{\\ell=0}^{2} [(\\nu_{1} + \\nu_{2})\\beta + \\delta + \\tau_{R} + \\tau_{P}] r_{\\ell} + m_{c}\\beta r_{3}$$\n\n首先，我们计算非零元比率 $r_{\\ell}$：\n- $r_{0} = \\frac{\\mathrm{NZ}_{0}}{\\mathrm{NZ}_{0}} = \\frac{3.2\\times 10^{8}}{3.2\\times 10^{8}} = 1$\n- $r_{1} = \\frac{\\mathrm{NZ}_{1}}{\\mathrm{NZ}_{0}} = \\frac{7.9\\times 10^{7}}{3.2\\times 10^{8}} = \\frac{7.9}{32} = 0.246875$\n- $r_{2} = \\frac{\\mathrm{NZ}_{2}}{\\mathrm{NZ}_{0}} = \\frac{1.9\\times 10^{7}}{3.2\\times 10^{8}} = \\frac{1.9}{32} = 0.059375$\n- $r_{3} = \\frac{\\mathrm{NZ}_{3}}{\\mathrm{NZ}_{0}} = \\frac{4.7\\times 10^{6}}{3.2\\times 10^{8}} = \\frac{4.7}{320} = 0.0146875$\n\n接下来，我们将给定的常数代入公式：\n- $\\nu_{1}=2$, $\\nu_{2}=2$\n- $\\beta=1.1$\n- $\\delta=1.0$\n- $\\tau_{R}=0.25$, $\\tau_{P}=0.25$\n- $m_{c}=30$\n\n求和项的系数为：\n$$(\\nu_{1} + \\nu_{2})\\beta + \\delta + \\tau_{R} + \\tau_{P} = (2+2)(1.1) + 1.0 + 0.25 + 0.25 = 4(1.1) + 1.5 = 4.4 + 1.5 = 5.9$$\n粗网格项的系数为：\n$$m_{c}\\beta = 30 \\times 1.1 = 33$$\n$W_V$ 的公式变为：\n$$W_V = 5.9 \\sum_{\\ell=0}^{2} r_{\\ell} + 33 r_{3}$$\n现在，我们计算总和：\n$$\\sum_{\\ell=0}^{2} r_{\\ell} = r_{0} + r_{1} + r_{2} = 1 + 0.246875 + 0.059375 = 1.30625$$\n将此代回 $W_V$ 的表达式中：\n$$W_V = 5.9 \\times 1.30625 + 33 \\times 0.0146875$$\n$$W_V = 7.706875 + 0.4846875 = 8.1915625$$\n四舍五入到四位有效数字，每个V-循环的功为 $W_V \\approx 8.192$ WU。\n\n### 第2部分：求解时间\n\n为了预测求解时间，我们首先需要估计V-循环的收敛因子 $\\rho_V$。问题指明，粗网格校正理想地处理了低频误差，因此V-循环的收敛性由光滑子对高频误差的有效性决定。在一个V-循环期间，任何单层上的总光滑扫描次数为 $\\nu_{1} + \\nu_{2}$。每次扫描的高频光滑因子为 $\\mu_{h}=0.45$，则每个V-循环对高频误差的累积衰减因子为：\n$$\\rho_V \\approx (\\mu_{h})^{\\nu_{1}+\\nu_{2}} = (0.45)^{2+2} = (0.45)^{4} = 0.04100625$$\n\n接下来，我们确定将残差范数减小 $10^{-8}$ 倍所需的V-循环次数 $k$。我们在不等式中求解 $k$：\n$$(\\rho_V)^{k} \\le 10^{-8}$$\n对两边取自然对数：\n$$k \\ln(\\rho_V) \\le \\ln(10^{-8}) = -8 \\ln(10)$$\n因为 $\\rho_V  1$，其对数为负。除以 $\\ln(\\rho_V)$ 会使不等号反向：\n$$k \\ge \\frac{-8 \\ln(10)}{\\ln(\\rho_V)}$$\n$$k \\ge \\frac{-8 \\ln(10)}{\\ln(0.04100625)} \\approx \\frac{-8 \\times 2.302585}{-3.194001} \\approx \\frac{-18.42068}{-3.194001} \\approx 5.76727$$\n由于循环次数必须是整数，我们对该值向上取整：\n$$k = \\lceil 5.76727 \\rceil = 6$$\n所以，需要 6 个V-循环。\n\n最后，总挂钟时间 $T_{\\text{total}}$ 是循环次数、每个循环的功以及每个工作单元时间的乘积。\n$$T_{\\text{total}} = k \\times W_V \\times t_{\\mathrm{spmv}}$$\n为保证精度，使用 $W_V$ 的未舍入值，并已知 $t_{\\mathrm{spmv}}=0.015$ 秒/WU：\n$$T_{\\text{total}} = 6 \\times 8.1915625 \\, \\text{WU} \\times 0.015 \\, \\frac{\\text{s}}{\\text{WU}}$$\n$$T_{\\text{total}} = 0.737240625 \\, \\text{s}$$\n四舍五入到四位有效数字，总求解时间为 $T_{\\text{total}} \\approx 0.7372$ 秒。", "answer": "$$\\boxed{\\begin{pmatrix} 8.192  0.7372 \\end{pmatrix}}$$", "id": "3611397"}, {"introduction": "标准几何多重网格方法在处理各向异性问题时常常会表现不佳，而各向异性是地球物理模型中的一个常见特征。局部傅里葉分析（Local Fourier Analysis, LFA）是一种强大的预测工具，可以精确揭示这种失效的原因。本练习将通过实现LFA来量化一个标准两网格方法的收敛因子，从而让您直观地理解为什么针对各向异性问题必须设计鲁棒的平滑器和粗化策略。[@problem_id:3611417]", "problem": "考虑常系数二维各向异性扩散算子，其对称正定扩散张量 $K \\in \\mathbb{R}^{2 \\times 2}$ 由 $K = R(\\theta) \\operatorname{diag}(1,\\epsilon) R(\\theta)^{\\top}$ 给出，其中 $R(\\theta)$ 是旋转矩阵 $R(\\theta) = \\begin{pmatrix}\\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta\\end{pmatrix}$，各向异性比为 $\\epsilon \\in (0,1]$，旋转角为 $\\theta \\in [0,\\pi)$（单位为弧度）。控制偏微分方程为 $-\\nabla \\cdot (K \\nabla u) = f$，求解域为网格间距 $h0$ 的均匀无限晶格。对于常数 $K$，$-\\nabla \\cdot (K \\nabla u)$ 的一个标准 $9$ 点有限差分格式使用中心差分来处理二阶导数和混合导数。对于网格函数 $u_{i,j}$，离散算子 $A$ 的模板权重如下：\n- 轴对齐邻点：$(i \\pm 1,j)$ 权重为 $K_{xx}/h^2$，$(i,j \\pm 1)$ 权重为 $K_{yy}/h^2$，\n- 对角邻点：$(i \\pm 1,j \\pm 1)$ 权重为 $\\pm K_{xy}/(2 h^2)$，符号的选择应使得离散混合导数近似于 $2 K_{xy} \\partial_{xy} u$，\n- 中心点：$(i,j)$ 权重为 $(2 K_{xx} + 2 K_{yy})/h^2$。\n\n令该算子的离散傅里叶符号表示为 $a(\\boldsymbol{\\xi})$，其中 $\\boldsymbol{\\xi} = (\\xi_x,\\xi_y) \\in \\mathbb{R}^2$。按照符号表示正定算子的约定，可以推导出\n$$\na(\\boldsymbol{\\xi}) = \\frac{2}{h^2}\\Big(K_{xx}(1-\\cos\\xi_x) + K_{yy}(1-\\cos\\xi_y)\\Big) + \\frac{K_{xy}}{h^2}\\Big(\\cos(\\xi_x - \\xi_y) - \\cos(\\xi_x + \\xi_y)\\Big).\n$$\n考虑经典的双网格局部傅里叶分析（LFA），其在每个坐标方向上采用因子为 $2$ 的完全粗化，以及标准的双线性插值及其伴随的全加权限制。粗网格频率集索引使用四个混叠频率\n$$\n\\mathcal{T}(\\boldsymbol{\\xi}) = \\left\\{ \\boldsymbol{\\xi}, \\boldsymbol{\\xi} + (\\pi,0), \\boldsymbol{\\xi} + (0,\\pi), \\boldsymbol{\\xi} + (\\pi,\\pi) \\right\\}.\n$$\n对于权重为 $\\omega \\in (0,1)$ 的加权 Jacobi 光滑，逐点光滑符号由下式给出\n$$\ns(\\boldsymbol{\\xi}) = 1 - \\omega \\frac{a(\\boldsymbol{\\xi})}{d},\n$$\n其中 $d = \\frac{2 K_{xx} + 2 K_{yy}}{h^2}$ 是 $A$ 的对角线。双线性插值符号为\n$$\n\\hat{P}(\\boldsymbol{\\xi}) = \\frac{1}{4} \\begin{bmatrix}\n(1 + e^{i \\xi_x})(1 + e^{i \\xi_y}) \\\\\n(1 - e^{i \\xi_x})(1 + e^{i \\xi_y}) \\\\\n(1 + e^{i \\xi_x})(1 - e^{i \\xi_y}) \\\\\n(1 - e^{i \\xi_x})(1 - e^{i \\xi_y})\n\\end{bmatrix},\n$$\n全加权限制是其伴随\n$$\n\\hat{R}(\\boldsymbol{\\xi}) = \\hat{P}(\\boldsymbol{\\xi})^{\\ast \\top}.\n$$\n令 $A_{\\text{diag}}(\\boldsymbol{\\xi}) = \\operatorname{diag}\\big(a(\\boldsymbol{\\eta})\\big)_{\\boldsymbol{\\eta}\\in \\mathcal{T}(\\boldsymbol{\\xi})}$ 为细网格符号在 $4$ 个混叠频率上的对角矩阵，并令粗网格符号为标量\n$$\n\\hat{A}_c(\\boldsymbol{\\xi}) = \\hat{R}(\\boldsymbol{\\xi}) \\, A_{\\text{diag}}(\\boldsymbol{\\xi}) \\, \\hat{P}(\\boldsymbol{\\xi}).\n$$\n作用于 $4$ 维混叠子空间上的粗网格校正符号为\n$$\nC(\\boldsymbol{\\xi}) = I - \\hat{P}(\\boldsymbol{\\xi}) \\, \\hat{A}_c(\\boldsymbol{\\xi})^{-1} \\, \\hat{R}(\\boldsymbol{\\xi}) \\, A_{\\text{diag}}(\\boldsymbol{\\xi}),\n$$\n一次前光滑和一次后光滑可得到双网格误差传播符号\n$$\nE(\\boldsymbol{\\xi}) = S_{\\text{post}}(\\boldsymbol{\\xi}) \\, C(\\boldsymbol{\\xi}) \\, S_{\\text{pre}}(\\boldsymbol{\\xi}),\n$$\n其中 $S_{\\text{pre}}(\\boldsymbol{\\xi}) = \\operatorname{diag}\\big(s(\\boldsymbol{\\eta})\\big)_{\\boldsymbol{\\eta}\\in \\mathcal{T}(\\boldsymbol{\\xi})}$ 且 $S_{\\text{post}}(\\boldsymbol{\\xi}) = \\operatorname{diag}\\big(s(\\boldsymbol{\\eta})\\big)_{\\boldsymbol{\\eta}\\in \\mathcal{T}(\\boldsymbol{\\xi})}$。LFA 预测的双网格收敛因子为\n$$\n\\rho_{\\text{TG}} = \\sup_{\\boldsymbol{\\xi} \\in \\mathcal{B}} \\rho\\big(E(\\boldsymbol{\\xi})\\big),\n$$\n其中 $\\rho(\\cdot)$ 表示谱半径，$\\mathcal{B} = [-\\pi/2,\\pi/2)^2$ 是低频基区。\n\n从控制算子及其离散化出发，执行以下操作：\n- 对于旋转后的张量 $K$，其分量为 $K_{xx}=\\cos^2\\theta + \\epsilon \\sin^2\\theta$、$K_{yy}=\\sin^2\\theta + \\epsilon \\cos^2\\theta$ 和 $K_{xy}=(1-\\epsilon)\\cos\\theta \\sin\\theta$，推导离散符号 $a(\\boldsymbol{\\xi})$。展示双网格 LFA 机制如何为加权 Jacobi 光滑生成 $E(\\boldsymbol{\\xi})$ 和 $\\rho_{\\text{TG}}$。\n- 提出一种光滑子和粗化规则，使其在 $\\epsilon \\to 0$ 时对任意 $\\theta$ 都具有鲁棒性，并基于各向异性的物理和代数性质。从第一性原理证明该选择的合理性。\n\n实现任务：\n- 实现一个程序，对于给定的 $(\\epsilon,\\theta)$，通过在基区 $\\mathcal{B}$ 的均匀网格上采样 $\\boldsymbol{\\xi}$ 来数值计算 $\\rho_{\\text{TG}}$，每个维度使用 $N=64$ 个样本，网格间距 $h=1$，加权 Jacobi 的权重 $\\omega = 2/3$。避免采样精确的端点以防止除以零；在每个子区间中采样中点。\n- 为了数值稳定性，如果 $\\hat{A}_c(\\boldsymbol{\\xi})$ 的量级小于一个小的阈值 $10^{-14}$，则将该 $\\boldsymbol{\\xi}$ 处的粗网格校正视为单位矩阵，即设置 $C(\\boldsymbol{\\xi}) = I$。\n\n测试套件：\n- 情况 1：$(\\epsilon,\\theta) = (1.0,0.0)$。\n- 情况 2：$(\\epsilon,\\theta) = (0.1,0.0)$。\n- 情况 3：$(\\epsilon,\\theta) = (10^{-6},0.0)$。\n- 情况 4：$(\\epsilon,\\theta) = (0.01,\\pi/4)$。\n- 情况 5：$(\\epsilon,\\theta) = (10^{-6},\\pi/3)$。\n\n角度单位是弧度。将最终数值答案表示为四舍五入到 $6$ 位小数的浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$）。", "solution": "该问题需要分两部分回答：首先，推导并解释应用于各向异性扩散问题的双网格方法的局部傅里叶分析（LFA）；其次，为这类问题提出一种鲁棒的多重网格策略。\n\n### 第一部分：双网格局部傅里叶分析\n\n控制偏微分方程（PDE）是各向异性扩散方程 $-\\nabla \\cdot (K \\nabla u) = f$，其中 $K$ 是一个对称正定扩散张量。张量 $K$ 由其各向异性比 $\\epsilon \\in (0,1]$ 和旋转角 $\\theta \\in [0, \\pi)$ 定义：\n$$\nK = R(\\theta) \\begin{pmatrix} 1  0 \\\\ 0  \\epsilon \\end{pmatrix} R(\\theta)^{\\top} = \\begin{pmatrix}\\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta\\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  \\epsilon \\end{pmatrix} \\begin{pmatrix}\\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta\\end{pmatrix}\n$$\n执行矩阵乘法可得到常数张量 $K$ 的分量：\n$$\nK_{xx} = \\cos^2\\theta + \\epsilon \\sin^2\\theta\n$$\n$$\nK_{yy} = \\sin^2\\theta + \\epsilon \\cos^2\\theta\n$$\n$$\nK_{xy} = (1-\\epsilon)\\cos\\theta \\sin\\theta\n$$\n在间距为 $h$ 的均匀网格上的 $9$ 点有限差分离散化可得到一个线性系统 $Au=b$。离散算子 $A$ 有一个傅里叶符号 $a(\\boldsymbol{\\xi})$，其中 $\\boldsymbol{\\xi} = (\\xi_x, \\xi_y)$ 是傅里叶模式的频率向量。如题目所给，该符号为：\n$$\na(\\boldsymbol{\\xi}) = \\frac{2}{h^2}\\Big(K_{xx}(1-\\cos\\xi_x) + K_{yy}(1-\\cos\\xi_y)\\Big) + \\frac{K_{xy}}{h^2}\\Big(\\cos(\\xi_x - \\xi_y) - \\cos(\\xi_x + \\xi_y)\\Big)\n$$\n这个符号表示离散算子 $A$ 在网格尺度傅里叶模式 $e^{i(i\\xi_x + j\\xi_y)}$ 上的作用，即 $A e^{i(i\\xi_x + j\\xi_y)} = a(\\boldsymbol{\\xi}) e^{i(i\\xi_x + j\\xi_y)}$。\n\n双网格 LFA 通过分析多重网格的各个组件（光滑子、限制、插值、粗网格算子）如何作用于这些傅里叶模式来进行。\n分析是针对一个低频模式 $\\boldsymbol{\\xi} \\in \\mathcal{B} = [-\\pi/2, \\pi/2)^2$ 进行的。在细网格上，由于粗化过程引起的混叠效应，该模式与其他三个高频模式耦合。这四个耦合模式的集合由混叠集 $\\mathcal{T}(\\boldsymbol{\\xi}) = \\left\\{ \\boldsymbol{\\xi}, \\boldsymbol{\\xi} + (\\pi,0), \\boldsymbol{\\xi} + (0,\\pi), \\boldsymbol{\\xi} + (\\pi,\\pi) \\right\\}$ 索引。双网格循环则由一个作用于这四种模式振幅的 $4 \\times 4$ 矩阵表示。\n\n构建双网格误差传播符号 $E(\\boldsymbol{\\xi})$ 的步骤如下：\n\n1.  **算子符号矩阵**：细网格算子 $A$ 独立地作用于四个模式中的每一个。它在 $4$ 维混叠子空间中的表示是一个对角矩阵 $A_{\\text{diag}}(\\boldsymbol{\\xi})$，其对角线元素是在四个混叠频率下计算的算子符号：\n    $$\n    A_{\\text{diag}}(\\boldsymbol{\\xi}) = \\operatorname{diag}\\big(a(\\boldsymbol{\\eta})\\big)_{\\boldsymbol{\\eta}\\in \\mathcal{T}(\\boldsymbol{\\xi})}\n    $$\n\n2.  **光滑子符号矩阵**：光滑子是一个加权 Jacobi 迭代 $u \\leftarrow u - \\omega D^{-1}(Au-b)$，其中 $D$ 是 $A$ 的对角线。光滑子的误差传播算子是 $S = I - \\omega D^{-1}A$。$A$ 的对角线是常数 $d=(2K_{xx} + 2K_{yy})/h^2$。光滑符号是 $s(\\boldsymbol{\\xi}) = 1 - \\omega a(\\boldsymbol{\\xi})/d$。与算子一样，光滑子独立作用于每个模式。经过一次前光滑和一次后光滑步骤后，符号矩阵为：\n    $$\n    S_{\\text{pre}}(\\boldsymbol{\\xi}) = S_{\\text{post}}(\\boldsymbol{\\xi}) = \\operatorname{diag}\\big(s(\\boldsymbol{\\eta})\\big)_{\\boldsymbol{\\eta}\\in \\mathcal{T}(\\boldsymbol{\\xi})}\n    $$\n\n3.  **网格间传递符号向量**：使用双线性插值及其伴随算子，即全加权限制。插值算子将单个粗网格模式映射到混叠集中四个细网格模式的线性组合。此映射的系数构成了 $4 \\times 1$ 的插值符号向量 $\\hat{P}(\\boldsymbol{\\xi})$。限制算子将四个细网格模式映射到单个粗网格模式，由 $1 \\times 4$ 的符号向量 $\\hat{R}(\\boldsymbol{\\xi}) = \\hat{P}(\\boldsymbol{\\xi})^{\\ast \\top}$ 表示。\n\n4.  **粗网格校正符号矩阵**：粗网格校正包括限制、在粗网格上求解和插值。其符号是一个 $4 \\times 4$ 矩阵：\n    $$\n    C(\\boldsymbol{\\xi}) = I - \\hat{P}(\\boldsymbol{\\xi}) \\, \\hat{A}_c(\\boldsymbol{\\xi})^{-1} \\, \\hat{R}(\\boldsymbol{\\xi}) \\, A_{\\text{diag}}(\\boldsymbol{\\xi})\n    $$\n    此处，$\\hat{A}_c(\\boldsymbol{\\xi})$ 是标量粗网格算子符号，通过伽辽金原理 $\\hat{A}_c = \\hat{R} A_{\\text{diag}} \\hat{P}$ 形成：\n    $$\n    \\hat{A}_c(\\boldsymbol{\\xi}) = \\hat{R}(\\boldsymbol{\\xi}) \\, A_{\\text{diag}}(\\boldsymbol{\\xi}) \\, \\hat{P}(\\boldsymbol{\\xi})\n    $$\n\n5.  **双网格循环符号矩阵**：带一次前光滑和一次后光滑的 V-循环是这些算子的复合。整个循环的误差传播符号为：\n    $$\n    E(\\boldsymbol{\\xi}) = S_{\\text{post}}(\\boldsymbol{\\xi}) \\, C(\\boldsymbol{\\xi}) \\, S_{\\text{pre}}(\\boldsymbol{\\xi})\n    $$\n\n6.  **双网格收敛因子**：LFA 预测的收敛因子 $\\rho_{\\text{TG}}$ 是误差传播矩阵在所有低频模式上的最坏情况谱半径：\n    $$\n    \\rho_{\\text{TG}} = \\sup_{\\boldsymbol{\\xi} \\in \\mathcal{B}} \\rho\\big(E(\\boldsymbol{\\xi})\\big)\n    $$\n    其中 $\\rho(\\cdot)$ 是谱半径。\n\n### 第二部分：鲁棒多重网格策略的提议\n\n所述的标准多重网格设置（逐点 Jacobi 光滑子、完全粗化、双线性插值）对于强各向异性问题（$\\epsilon \\to 0$）是出了名的低效。\n\n**失效分析**：\n当 $\\epsilon \\to 0$ 时，扩散在 $K$ 的第一个特征向量方向（角度为 $\\theta$）上很强，而在正交方向上很弱。在离散网格上，这表现为沿强各向异性方向耦合点的矩阵项较大，而正交方向耦合点的矩阵项较小。\n1.  **光滑子失效**：逐点光滑子，如加权 Jacobi，其作用是局部的和各向同性的。它们能有效阻尼在所有网格方向上都高度振荡的误差分量。然而，它们无法阻尼“半粗”误差模式，这些模式在强耦合方向上是光滑的（低频），但在弱耦合方向上是振荡的（高频）。对于算子来说，这些模式看起来是光滑的，残差很小，因此光滑子效果甚微。这些模式是导致收敛缓慢的主要原因。\n2.  **粗化/插值失效**：完全粗化（在所有方向上将网格间距加倍）也存在问题。它对各向异性是“盲目”的。细网格上的强连接，特别是当它们不与网格轴对齐时（例如，$\\theta = \\pi/4$），在粗网格上可能没有相应的强连接。因此，粗网格算子无法准确表示细网格算子的各向异性，粗网格校正也无法消除光滑子遗漏的那些有问题的误差模式。\n\n**提议的鲁棒策略**：\n鲁棒的多重网格方法必须设计成其组件能够适应各向异性。基本原则是粗化和光滑应该是互补的：不能被光滑子有效减少的误差分量必须在粗网格上得到很好的近似。\n\n1.  **鲁棒光滑子**：为了阻尼有问题的半粗模式，光滑子必须对强耦合的未知数进行集体操作。典型的选择是**线隐式光滑子**。\n    *   对于轴对齐的各向异性（例如 $\\theta=0$），人们会使用 $x$-线光滑子（例如，线-Jacobi 或线-Gauss-Seidel），它同时求解每个水平网格线上的所有未知数。这涉及到求解一系列三对角系统，在阻尼沿线光滑的误差方面非常高效。\n    *   对于任意的 $\\theta$，强耦合方向不与网格对齐。一个鲁棒的选择是**交替线光滑子**，它在 $x$-线和 $y$-线光滑遍之间交替进行。\n\n2.  **鲁棒粗化**：粗化策略必须确保在粗网格上保留强连接。\n    *   标准的鲁棒选择是**半粗化**。我们*仅*在弱耦合方向上进行粗化，而不是在所有方向上。例如，如果各向异性在水平方向上很强（$\\theta \\approx 0$），我们只在垂直方向上进行粗化。这使得强耦合的水平线在粗网格上保持完整，从而让粗网格校正能够有效处理沿这些线光滑的误差。\n    *   对于任意的 $\\theta$，可以在物理上“耦合较弱”的网格方向上应用半粗化。\n\n**从第一性原理出发的论证**：\n线光滑子和半粗化的组合是鲁棒的，因为它对任务进行了划分。线光滑子（例如，沿 $x$ 线）能有效阻尼所有沿 $x$ 线振荡的误差模式。剩下的误差模式沿 $x$ 线是光滑的。在 $y$ 方向上的半粗化保留了 $x$ 线。因此，剩下的沿这些保留线光滑的误差，可以在粗网格上得到很好的近似，并能被粗网格校正消除。\n\n对于一般的各向异性，这种几何方法变得复杂。**代数多重网格（AMG）**是一种更先进的“黑盒”方法，它自动实现了这一理念。AMG 检查矩阵元素以识别“强连接”，并利用这些信息来选择粗网格点（一种半粗化的形式），并构建对有问题的光滑误差模式精确的插值算子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the LFA for the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.0),          # Case 1: Isotropic\n        (0.1, 0.0),          # Case 2: Moderate axis-aligned anisotropy\n        (1e-6, 0.0),         # Case 3: Strong axis-aligned anisotropy\n        (0.01, np.pi/4),     # Case 4: Strong diagonal anisotropy\n        (1e-6, np.pi/3),     # Case 5: Strong general anisotropy\n    ]\n\n    results = []\n    for epsilon, theta in test_cases:\n        rho_tg = compute_rho_tg(epsilon, theta)\n        results.append(round(rho_tg, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_rho_tg(epsilon, theta, N=64, h=1.0, omega=2/3.0):\n    \"\"\"\n    Computes the two-grid convergence factor rho_TG using Local Fourier Analysis.\n\n    Args:\n        epsilon (float): The anisotropy ratio.\n        theta (float): The rotation angle in radians.\n        N (int): Number of samples per dimension in the Fourier domain.\n        h (float): Grid spacing.\n        omega (float): Weighted Jacobi smoothing parameter.\n\n    Returns:\n        float: The numerically computed two-grid convergence factor.\n    \"\"\"\n    # 1. Define K tensor components\n    c, s = np.cos(theta), np.sin(theta)\n    c2, s2, cs = c*c, s*s, c*s\n    Kxx = c2 + epsilon * s2\n    Kyy = s2 + epsilon * c2\n    Kxy = (1.0 - epsilon) * cs\n    \n    # 2. Define the discrete operator symbol a(xi)\n    h2 = h * h\n    def get_symbol_a(eta_x, eta_y):\n        cos_ex = np.cos(eta_x)\n        cos_ey = np.cos(eta_y)\n        cos_ex_minus_ey = np.cos(eta_x - eta_y)\n        cos_ex_plus_ey = np.cos(eta_x + eta_y)\n        \n        term1 = 2.0 / h2 * (Kxx * (1.0 - cos_ex) + Kyy * (1.0 - cos_ey))\n        term2 = Kxy / h2 * (cos_ex_minus_ey - cos_ex_plus_ey)\n        \n        return term1 + term2\n\n    # 3. Define the smoother symbol s(xi)\n    d = (2.0 * Kxx + 2.0 * Kyy) / h2\n    # Ensure d is not zero, though it shouldn't be for SPD K and epsilon > 0.\n    if abs(d)  1e-15:\n        d = 1.0\n\n    def get_symbol_s(eta_x, eta_y):\n        a_val = get_symbol_a(eta_x, eta_y)\n        return 1.0 - omega * a_val / d\n\n    # 4. Set up the grid for xi in the base region B = [-pi/2, pi/2)^2\n    d_xi = np.pi / N\n    xi_range = -np.pi / 2.0 + d_xi / 2.0 + np.arange(N) * d_xi\n    xi_x_grid, xi_y_grid = np.meshgrid(xi_range, xi_range, indexing='ij')\n    \n    max_rho = 0.0\n    \n    # 5. Loop over all frequencies in the sampled base region\n    I4 = np.identity(4, dtype=np.complex128)\n\n    for i in range(N):\n        for j in range(N):\n            xi_x = xi_x_grid[i, j]\n            xi_y = xi_y_grid[i, j]\n            \n            # Aliases for the current low frequency xi\n            aliases = [\n                (xi_x, xi_y),\n                (xi_x + np.pi, xi_y),\n                (xi_x, xi_y + np.pi),\n                (xi_x + np.pi, xi_y + np.pi)\n            ]\n            \n            # Fine-grid operator symbol matrix A_diag(xi)\n            a_vec = np.array([get_symbol_a(ex, ey) for ex, ey in aliases], dtype=np.complex128)\n            A_diag = np.diag(a_vec)\n            \n            # Smoothing symbol matrices S_pre(xi) and S_post(xi)\n            s_vec = np.array([get_symbol_s(ex, ey) for ex, ey in aliases], dtype=np.complex128)\n            S_pre_post = np.diag(s_vec)\n\n            # Interpolation symbol vector P_hat(xi) and Restriction R_hat(xi)\n            exp_ix = np.exp(1j * xi_x)\n            exp_iy = np.exp(1j * xi_y)\n            \n            # 4x1 vector\n            P_hat = 0.25 * np.array([\n                (1.0 + exp_ix) * (1.0 + exp_iy),\n                (1.0 - exp_ix) * (1.0 + exp_iy),\n                (1.0 + exp_ix) * (1.0 - exp_iy),\n                (1.0 - exp_ix) * (1.0 - exp_iy)\n            ], dtype=np.complex128).reshape(4, 1)\n\n            # 1x4 vector\n            R_hat = P_hat.conj().T\n            \n            # Scalar coarse-grid symbol A_c(xi)\n            A_c_mat = R_hat @ A_diag @ P_hat\n            A_c_scalar = A_c_mat[0, 0]\n            \n            # Coarse-grid correction symbol C(xi)\n            if np.abs(A_c_scalar)  1e-14:\n                # Handle singularity for numerical stability\n                C = I4\n            else:\n                C = I4 - (P_hat @ R_hat @ A_diag) / A_c_scalar\n\n            # Two-grid error-propagation symbol E(xi)\n            E = S_pre_post @ C @ S_pre_post\n            \n            # Spectral radius of E(xi)\n            try:\n                eigvals = np.linalg.eigvals(E)\n                rho = np.max(np.abs(eigvals))\n                if rho  max_rho:\n                    max_rho = rho\n            except np.linalg.LinAlgError:\n                # This is unlikely for a 4x4 matrix but is safe to have.\n                pass\n                \n    return max_rho\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3611417"}, {"introduction": "许多地球物理问题，例如涉及无通量边界的孔隙网络流动模型，会产生奇异线性系统。一个鲁棒的代数多重网格（Algebraic Multigrid, AMG）求解器必须能正确处理相关的零空间，以确保粗网格问题是良态的。本动手编程练习将通过一个简化的孔隙网络模型，验证平滑聚合AMG方法中这一关键的零空间保持特性。[@problem_id:3611418]", "problem": "考虑在一个具有孤立孔隙簇和纯诺伊曼（零通量）边界条件的孔隙网络图上进行离散扩散，这是计算地球物理学中的一个典型场景。离散算子是图拉普拉斯算子，它在每个节点上强制实现通量守恒。在不连通图上应用纯诺伊曼边界条件时，拉普拉斯算子的零空间由每个连通分量上的分段常数向量张成。这导致预期零空间维数等于不连通分量的数量。代数多重网格（AMG）必须保持此零空间，以避免在粗糙层级上引入伪奇异性。\n\n将使用的基本原理和定义：\n- 图的离散守恒定律意味着离开一个节点的通量之和为零，从而产生一个行和为零的图拉普拉斯矩阵 $A \\in \\mathbb{R}^{N \\times N}$：对于每一行 $i$，$\\sum_{j=1}^{N} A_{ij} = 0$。\n- 图拉普拉斯算子定义为 $A = D - W$，其中 $W$ 是邻接（或权重）矩阵，$D$ 是对角度矩阵，其对角元素为 $D_{ii} = \\sum_{j=1}^{N} W_{ij}$。\n- 在此离散设置中，纯诺伊曼边界条件意味着每个连通分量上的常数向量位于 $A$ 的零空间中，因此零空间维数等于连通分量的数量。\n- 通过平滑聚合的代数多重网格（AMG）粗化方法，从近零空间向量和聚合体构建一个延拓算子 $P \\in \\mathbb{R}^{N \\times n_c}$（其中 $n_c$ 为粗糙层级未知数），并形成一个粗糙层级算子 $A_c = P^{\\top} A P$。平滑聚合采用一个雅可比型平滑器 $S = I - \\omega D^{-1} A$ 应用于试探性延拓向量，其中 $I$ 是单位矩阵，$\\omega \\in (0,2)$ 是一个松弛参数，$D^{-1}$ 是对角度矩阵的逆（约定对应于零对角元素的条目被视为零）。\n- 目标是验证精细层级的零空间维数等于连通分量的数量，并且粗糙层级的零空间维数等于聚合体的数量，从而证明AMG能够保持零空间并避免在诺伊曼边界条件所预期的零空间之外产生奇异的粗糙层级算子。\n\n您的任务是编写一个完整的程序，该程序：\n1. 构建具有不连通分量的玩具孔隙网络图。对于每个测试案例，使用单位边权重和纯诺伊曼边界条件（即，不进行修改以强制施加狄利克雷条件）来组装对称图拉普拉斯算子 $A$。\n2. 将聚合体定义为与不连通分量相等。对于每个聚合体，形成一个等于该分量的分段常数近零空间向量的试探性延拓向量，对每个试探性向量应用一个带有固定松弛参数 $\\omega$ 的雅可比平滑器 $S = I - \\omega D^{-1} A$，并将结果列归一化为单位欧几里得范数。通过堆叠这些经过平滑和归一化的列来组装延拓算子 $P$。\n3. 形成粗糙层级算子 $A_c = P^{\\top} A P$。\n4. 使用特征值分析计算 $A$ 和 $A_c$ 的零空间维数，将小于或等于一个小的非负容差 $\\tau$ 的特征值计数为零。在所有测试中使用固定的容差 $\\tau$。\n5. 对于每个测试案例，返回一个布尔值列表 $[\\text{fine\\_ok}, \\text{coarse\\_ok}]$，其中如果 $A$ 的零空间维数等于不连通分量的数量，则 $\\text{fine\\_ok}$ 为真；如果 $A_c$ 的零空间维数等于聚合体的数量（该数量被设置为等于不连通分量的数量），则 $\\text{coarse\\_ok}$ 为真。\n\n使用以下测试套件，其中每个簇由节点数和带单位权重的无向边列表指定：\n- 测试案例 1 (正常路径): 三个不连通的簇。\n  - 簇 1: 4个节点，边为 $(0,1)$, $(1,2)$, $(2,3)$。\n  - 簇 2: 5个节点，边为 $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$。\n  - 簇 3: 3个节点，边为 $(0,1)$, $(1,2)$。\n- 测试案例 2 (边界条件): 一个孤立节点（一个簇，含1个节点，无边）。\n- 测试案例 3 (连通性变化的边缘情况): 两个不连通的簇。\n  - 簇 1: 3个节点，边为 $(0,1)$, $(1,2)$。\n  - 簇 2: 3个节点形成一个三角形，边为 $(0,1)$, $(1,2)$, $(2,0)$。\n\n数值规格：\n- 在 $S = I - \\omega D^{-1} A$ 中，为雅可比平滑器使用 $\\omega = 0.8$。\n- 为基于特征值的零空间检测使用 $\\tau = 10^{-10}$。\n- 所有角度（如果使用的话）必须以弧度为单位。此任务不需要物理单位。\n- 所有数组均为纯数学形式；输出中没有物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表，并用方括号括起来。每个元素对应一个测试案例，并且本身也是一个用方括号括起来的逗号分隔列表。例如，输出应看起来像 $[[\\text{True},\\text{True}],[\\text{True},\\text{False}],\\ldots]$，整行没有任何空格。\n\n您的程序必须是自包含的，为三个指定的测试案例执行上述步骤，并以描述的确切格式输出布尔结果。", "solution": "该问题要求验证代数多重网格（AMG）方法在应用于具有多个零空间向量的问题（例如在具有纯诺伊曼边界条件的不连通域上进行扩散所产生的问题）时的一个基本属性。具体来说，我们必须确认平滑聚合AMG方法能够正确保持离散算子的零空间，从而确保粗糙网格问题是适定的，并且不会引入伪奇异性。验证过程通过构建精细网格算子，应用AMG设置过程的一个步骤以获得粗糙网格算子，然后将两个算子的零空间维数与其理论预期值进行比较来进行。\n\n首先，我们为每个测试案例建模孔隙网络图。一个具有 $N$ 个总节点的图由一个对称权重矩阵 $W \\in \\mathbb{R}^{N \\times N}$ 表示，其中 $W_{ij} = W_{ji}$ 是节点 $i$ 和 $j$ 之间边的权重（这里所有权重均为 $1$），如果不存在边，则 $W_{ij} = 0$。然后，图拉普拉斯算子 $A \\in \\mathbb{R}^{N \\times N}$ 被构建为 $A = D - W$。这里，$D$ 是对角度矩阵，其对角元素为 $D_{ii} = \\sum_{j=1}^{N} W_{ij}$，表示连接到节点 $i$ 的边的权重之和。这种构造确保 $A$ 的行和为零，即对于所有 $i$，$\\sum_{j=1}^{N} A_{ij} = 0$。此属性是在纯诺伊曼（零通量）边界条件下守恒定律（例如质量或能量守恒）的离散模拟。\n\n对于一个具有 $k$ 个连通分量的不连通图，其对应的拉普拉斯算子 $A$ 的零空间维数为 $k$。此零空间的基向量是分段常数向量；即，在一个连通分量上为常数而在其他地方为零的向量。我们的第一个验证步骤，即产生布尔值 $\\text{fine\\_ok}$ 的步骤，是数值计算精细网格算子 $A$ 的零空间维数，并检查它是否等于测试案例中给出的不连通分量的数量。零空间维数通过计算 $A$ 的特征值中为零的数量来确定，这在数值容差 $\\tau = 10^{-10}$ 内进行。我们使用特征值的绝对值进行此检查，即 $|\\lambda| \\le \\tau$。\n\n接下来，我们使用平滑聚合的原理构建粗糙网格算子 $A_c$。AMG的核心思想是在一个更粗糙的网格上表示收敛缓慢（光滑）的误差分量。对于诺伊曼问题，最光滑的分量是零空间向量本身。AMG必须在其粗糙表示中保持这些向量才能有效。\n\n1.  **聚合**：我们将聚合体定义为图的连通分量。因此，聚合体的数量 $n_c$ 等于连通分量的数量 $k$。\n\n2.  **试探性延拓**：对于 $n_c$ 个聚合体中的每一个，我们形成一个试探性延拓向量。此向量是该聚合体的特征向量——对于该聚合体内的所有节点，其值为 $1$，对于所有外部节点，其值为 $0$。这些向量构成了精细网格零空间的基。\n\n3.  **平滑**：然后对每个试探性延拓向量进行平滑。指定的平滑器是雅可比型平滑器，由算子 $S = I - \\omega D^{-1} A$ 定义，其中 $I$ 是单位矩阵，$\\omega = 0.8$ 是松弛参数，$D^{-1}$ 是 $D$ 对角线的逆。对于任何 $D_{ii} = 0$ 的孤立节点 $i$，对应的条目 $(D^{-1})_{ii}$ 被视为 $0$。此平滑器的一个关键属性是它不改变 $A$ 的零空间中的向量。如果 $\\mathbf{v}$ 是一个零空间向量，那么 $A\\mathbf{v} = \\mathbf{0}$。应用平滑器得到 $S\\mathbf{v} = (I - \\omega D^{-1} A)\\mathbf{v} = I\\mathbf{v} - \\omega D^{-1}(A\\mathbf{v}) = \\mathbf{v} - \\mathbf{0} = \\mathbf{v}$。由于我们的试探性延拓算子正是零空间向量，因此平滑步骤不会改变它们。\n\n4.  **延拓算子 $P$**：延拓算子 $P \\in \\mathbb{R}^{N \\times n_c}$ 的列是通过取每个（未改变的）试探性向量并将其归一化为单位欧几里得范数来形成的。\n\n最后，粗糙网格算子 $A_c \\in \\mathbb{R}^{n_c \\times n_c}$ 使用伽辽金投影形成：$A_c = P^{\\top} A P$。由于 $P$ 的列（表示为 $\\mathbf{p}_j$）是精细网格零空间向量的线性组合，我们有 $A\\mathbf{p}_j = \\mathbf{0}$ 对于每个列 $j = 1, \\dots, n_c$。因此，粗糙网格算子的每个条目预期都为零：$(A_c)_{ij} = \\mathbf{p}_i^{\\top} A \\mathbf{p}_j = \\mathbf{p}_i^{\\top} (\\mathbf{0}) = 0$。因此，$A_c$ 应该是大小为 $n_c \\times n_c$ 的零矩阵。零矩阵的零空间是整个空间，所以其维数是 $n_c$。第二个验证步骤，即产生 $\\text{coarse\\_ok}$ 的步骤，是计算 $A_c$ 的零空间维数（通过在容差 $\\tau$ 内计算其零特征值的数量）并检查它是否等于聚合体的数量 $n_c$。\n\n以下程序为三个指定的测试案例实现了这整个过程。它构建矩阵 $A$ 和 $P$，计算 $A_c$，并执行特征值分析以确定用于验证的零空间维数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the AMG nullspace preservation test for all cases.\n    \"\"\"\n\n    # Numerical specifications from the problem statement\n    omega = 0.8\n    tau = 1e-10\n\n    # Test case definitions\n    test_cases = [\n        # Test case 1: three disconnected clusters\n        [\n            {'nodes': 4, 'edges': [(0, 1), (1, 2), (2, 3)]},\n            {'nodes': 5, 'edges': [(0, 1), (1, 2), (2, 3), (3, 4)]},\n            {'nodes': 3, 'edges': [(0, 1), (1, 2)]},\n        ],\n        # Test case 2: a single isolated node\n        [\n            {'nodes': 1, 'edges': []},\n        ],\n        # Test case 3: two disconnected clusters with varied connectivity\n        [\n            {'nodes': 3, 'edges': [(0, 1), (1, 2)]},\n            {'nodes': 3, 'edges': [(0, 1), (1, 2), (2, 0)]},\n        ],\n    ]\n\n    all_results = []\n    for clusters in test_cases:\n        num_clusters = len(clusters)\n        \n        # Determine total number of nodes and build node offset map\n        total_nodes = sum(c['nodes'] for c in clusters)\n        node_offsets = np.cumsum([0] + [c['nodes'] for c in clusters[:-1]])\n        \n        # 1. Construct the symmetric graph Laplacian A\n        W = np.zeros((total_nodes, total_nodes))\n        for i, cluster in enumerate(clusters):\n            offset = node_offsets[i]\n            for u, v in cluster['edges']:\n                # Use unit edge weights\n                W[offset + u, offset + v] = 1.0\n                W[offset + v, offset + u] = 1.0\n        \n        d_diag = np.sum(W, axis=1)\n        D = np.diag(d_diag)\n        A = D - W\n        \n        # 4. Compute the nullspace dimension of A\n        eigvals_A = np.linalg.eigh(A)[0]\n        dim_null_A = np.sum(np.abs(eigvals_A) = tau)\n        \n        fine_ok = (dim_null_A == num_clusters)\n        \n        # 2. Define aggregates and construct prolongation operator P\n        # Aggregates are the disconnected components\n        num_aggregates = num_clusters\n        \n        # Construct the Jacobi smoother S = I - omega * D_inv * A\n        d_inv_diag = np.zeros(total_nodes)\n        non_zero_diag = d_diag  0\n        d_inv_diag[non_zero_diag] = 1.0 / d_diag[non_zero_diag]\n        D_inv = np.diag(d_inv_diag)\n        S = np.identity(total_nodes) - omega * (D_inv @ A)\n        \n        p_cols = []\n        for i in range(num_clusters):\n            # Form tentative prolongation column (piecewise constant vector)\n            p_tentative = np.zeros(total_nodes)\n            offset = node_offsets[i]\n            num_cluster_nodes = clusters[i]['nodes']\n            p_tentative[offset : offset + num_cluster_nodes] = 1.0\n            \n            # Apply smoother\n            p_smoothed = S @ p_tentative\n            \n            # Normalize the resulting column\n            norm = np.linalg.norm(p_smoothed)\n            if norm  1e-15: # Avoid division by zero\n                p_col = p_smoothed / norm\n            else:\n                p_col = p_smoothed\n                \n            p_cols.append(p_col)\n            \n        P = np.column_stack(p_cols)\n        \n        # 3. Form the coarse operator Ac\n        Ac = P.T @ A @ P\n        \n        # 4. Compute the nullspace dimension of Ac\n        eigvals_Ac = np.linalg.eigh(Ac)[0]\n        dim_null_Ac = np.sum(np.abs(eigvals_Ac) = tau)\n        \n        coarse_ok = (dim_null_Ac == num_aggregates)\n        \n        # 5. Store the boolean results for the current test case\n        all_results.append([fine_ok, coarse_ok])\n\n    # Format the final output string as specified: [[...],[...],...]\n    case_strs = [f\"[{'True' if res[0] else 'False'},{'True' if res[1] else 'False'}]\" for res in all_results]\n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "3611418"}]}