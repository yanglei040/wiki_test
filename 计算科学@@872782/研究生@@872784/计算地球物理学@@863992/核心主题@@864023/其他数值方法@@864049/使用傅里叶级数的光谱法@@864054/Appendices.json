{"hands_on_practices": [{"introduction": "谱方法的核心优势之一在于其处理微分运算的优雅与高效。在物理空间中复杂的微分操作，在傅里叶变换后的频率空间中，简化为了简单的代数乘法。本练习 ([@problem_id:3614982]) 将引导你亲手实现这一基本过程，利用快速傅里叶变换 (FFT) 计算周期函数的导数，并量化其数值误差随网格点数的变化。通过这个实践，你将牢固掌握谱微分的原理，并直观感受谱方法特有的高精度特性。", "problem": "在计算地球物理学的背景下，您需要为一个周期函数构建、实现并验证一个谱微分程序。考虑定义在区间 $[0, 2\\pi]$ 上的函数 $f(x) = \\sin(3x) + 0.1\\cos(9x)$，其中 $x$ 的单位为弧度。目标是使用基于傅里叶级数的谱方法计算 $f(x)$ 的数值导数，并使用双精度算术，量化当网格点数 $N$ 变化时的数值误差。\n\n请从 $2\\pi$ 周期函数的傅里叶级数基本定义，以及由该定义推导出的空间微分与其在频域中的对应关系出发。您的实现必须使用与 $[0, 2\\pi]$ 上等距采样一致的离散形式，并且必须依赖通过快速傅里叶变换（FFT, Fast Fourier Transform）计算的离散傅里叶变换（DFT）。您必须确保该程序遵循周期性边界条件，并与周期性网格的傅里叶级数解释相一致。\n\n对于每个选定的 $N$，在 $[0, 2\\pi)$ 上的 $N$ 个等距点上对函数 $f(x)$ 进行采样，应用傅里叶级数框架所隐含的谱微分方法，并将计算出的导数与在同一网格上计算的 $f(x)$ 的精确导数进行比较。精确导数需要从第一性原理进行解析计算。使用归一化 $L^2$ 误差和 $L^\\infty$ 误差在网格点上量化误差。归一化 $L^2$ 误差必须定义为 $\\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} \\left(e_j\\right)^2}$，其中 $e_j$ 是第 $j$ 个网格点上的逐点误差；$L^\\infty$ 误差必须定义为 $\\max_{0 \\leq j \\leq N-1} |e_j|$。两种误差都是无量纲的。\n\n请严格使用双精度进行计算，并相应地处理实数和复数量。整个过程中角度单位必须是弧度。您的程序必须实现该算法，并生成单行输出，总结针对一组固定的 $N$ 值测试集的结果。这些 $N$ 值的选择旨在探究不同的数值区域，包括欠解析情况、处于最高解析频率的边界情况以及良好解析情况。\n\n使用以下 $N$ 的测试集：$N \\in \\{8, 16, 18, 32, 64, 128\\}$。对于该集合中的每个 $N$，计算并报告一个三元组 $[N, E_2, E_\\infty]$，其中 $E_2$ 是归一化 $L^2$ 误差，$E_\\infty$ 是 $L^\\infty$ 误差。您的程序应生成单行输出，其中包含这些三元组的列表，格式为用方括号括起来的逗号分隔列表，例如 $[[8, E_2, E_\\infty], [16, E_2, E_\\infty], \\dots]$，数值采用标准十进制表示法。由于所有量均为无量纲，且角度根据定义使用弧度，因此不涉及物理单位。", "solution": "谱微分的目标是利用周期函数在傅里叶级数下的结构。一个 $2\\pi$ 周期函数 $f(x)$ 具有傅里叶级数表示\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} \\hat{f}_k e^{i k x},\n$$\n其中 $\\hat{f}_k$ 是傅里叶系数。物理空间中的微分在频域中转化为一个简单的代数运算。逐项微分可得\n$$\n\\frac{d f}{d x}(x) = \\sum_{k=-\\infty}^{\\infty} i k \\hat{f}_k e^{i k x}.\n$$\n因此，如果能够计算出 $\\hat{f}_k$，则通过将每个系数乘以 $i k$ 并执行逆变换，即可恢复其导数。\n\n在离散网格上，我们在 $[0, 2\\pi)$ 上的 $N$ 个等距点进行采样，\n$$\nx_j = \\frac{2\\pi j}{N}, \\quad j = 0, 1, \\dots, N-1,\n$$\n并形成样本 $f_j = f(x_j)$。离散傅里叶变换（DFT）将样本与离散谱系数关联起来。使用快速傅里叶变换（FFT）实现的约定，正变换计算\n$$\nF_n = \\sum_{j=0}^{N-1} f_j e^{-2\\pi i j n / N}, \\quad n = 0, 1, \\dots, N-1,\n$$\n而逆变换重构\n$$\nf_j = \\frac{1}{N} \\sum_{n=0}^{N-1} F_n e^{2\\pi i j n / N}.\n$$\n对于在 $x_j = 2\\pi j/N$ 处采样的形式为 $f(x) = \\sum_k \\hat{f}_k e^{i k x}$ 的函数，其离散系数 $F_n$ 与连续级数系数在与上述 DFT 定义一致的归一化下是对齐的。离散波数 $k$ 由整数表示，这些整数通过频率函数返回的数组映射到索引，该数组编码了如下顺序\n$k \\in \\{0, 1, 2, \\dots, \\lfloor\\frac{N}{2}\\rfloor, -\\lceil\\frac{N}{2}\\rceil+1, \\dots, -1\\}$。\n通过此映射，谱微分按以下步骤进行：\n1. 计算采样函数 $f_j$ 的 DFT $F_n$。\n2. 构建与 DFT 顺序匹配的整数波数数组 $k_n$。\n3. 计算谱导数系数 $G_n = i k_n F_n$。\n4. 对 $G_n$ 应用逆 DFT，以获得网格点上的导数样本，\n$$\n\\left(\\frac{d f}{d x}\\right)_j = \\frac{1}{N} \\sum_{n=0}^{N-1} G_n e^{2\\pi i j n / N}.\n$$\n由于精确函数是带限于模 $k=\\pm 3$ 和 $k=\\pm 9$ 的，当这些模式可以在网格上无混叠地表示时，谱微分能够精确地再现导数。对于满足 $N/2 \\geq 9$ 的偶数 $N$，模 $k=\\pm 9$ 被包括在内；然而，在 $N=18$ 时，模 $k=9$ 对应于奈奎斯特频率。在网格 $x_j = 2\\pi j / 18$ 上，项 $-0.9\\sin(9x_j)$ 恒等于零，因为 $\\sin(9 \\cdot 2\\pi j / 18) = \\sin(\\pi j) = 0$，这与离散表示是一致的：在该网格上，来自奈奎斯特余弦模式的导数贡献在物理空间中产生零样本。\n\n精确导数通过基本微分法则进行解析计算，\n$$\n\\frac{d f}{d x}(x) = 3\\cos(3x) - 0.9\\sin(9x).\n$$\n我们通过比较谱导数样本与网格点上的精确样本来量化误差。对于每个 $N$，定义逐点误差 $e_j = \\left(\\frac{d f}{d x}\\right)_{\\text{spectral}}(x_j) - \\left(\\frac{d f}{d x}\\right)_{\\text{exact}}(x_j)$。我们报告两种度量：\n1. 归一化 $L^2$ 误差，\n$$\nE_2 = \\sqrt{\\frac{1}{N}\\sum_{j=0}^{N-1} e_j^2},\n$$\n它是单位区间长度上 $L^2$ 范数的离散近似。\n2. $L^{\\infty}$ 误差，\n$$\nE_{\\infty} = \\max_{0 \\leq j \\leq N-1} |e_j|.\n$$\n这些误差是无量纲的，因为 $f(x)$ 及其导数是无量纲角度变量 $x$（以弧度为单位）的无量纲实值函数。\n\n算法上，步骤如下：\n- 对于测试集 $\\{8, 16, 18, 32, 64, 128\\}$ 中的每个 $N$，以双精度构建网格 $x_j$ 和样本 $f_j$。\n- 使用快速傅里叶变换 (FFT) 计算 $f_j$ 的 DFT。\n- 使用频率生成器创建与 FFT 顺序匹配的整数波数，缩放为整数波数，并将谱系数乘以 $i k$ 以获得谱导数系数。\n- 对变换求逆以获得导数样本，并取实部以消除任何残留的虚部数值噪声。\n- 构建精确导数样本并计算 $E_2$ 和 $E_{\\infty}$。\n- 对于每个 $N$，将结果汇总为指定的输出格式 $[N, E_2, E_\\infty]$。\n\n该方法遵循基本的傅里叶级数框架，并将傅里叶空间中微分的数学性质通过快速傅里叶变换与高效的计算实现直接联系起来。它避免了无关的近似，并且对于足够大的 $N$，其误差接近双精度下的舍入误差水平，从而展示了谱方法对于光滑周期函数的谱精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spectral_derivative_on_grid(N):\n    \"\"\"\n    Compute the spectral derivative of f(x) = sin(3x) + 0.1*cos(9x) on [0, 2*pi)\n    using N equispaced points, and return the normalized L2 and Linfty errors\n    versus the exact derivative at the grid points. All computations are\n    performed in double precision.\n    \"\"\"\n    # Double-precision grids and values\n    x = (2.0 * np.pi) * np.arange(N, dtype=np.float64) / np.float64(N)\n    f = np.sin(3.0 * x, dtype=np.float64) + 0.1 * np.cos(9.0 * x, dtype=np.float64)\n\n    # Exact derivative at grid points\n    exact_df = 3.0 * np.cos(3.0 * x, dtype=np.float64) - 0.9 * np.sin(9.0 * x, dtype=np.float64)\n\n    # Compute FFT of f\n    F = np.fft.fft(f.astype(np.float64))\n\n    # Integer wavenumbers consistent with numpy FFT ordering\n    # fftfreq returns frequencies in cycles per sample; multiplying by N gives integer k.\n    k = np.fft.fftfreq(N, d=1.0) * N  # array of ints in float dtype: [0,1,...,N/2-1,-N/2,...,-1]\n    k = k.astype(np.float64)\n\n    # Spectral derivative coefficients: G = i * k * F\n    G = (1j * k) * F\n\n    # Inverse FFT to get derivative samples in physical space\n    df_spec = np.fft.ifft(G)\n\n    # Due to numerical round-off, df_spec may have tiny imaginary parts; take real part\n    df_spec_real = np.real(df_spec).astype(np.float64)\n\n    # Compute errors\n    err = df_spec_real - exact_df\n    # Normalized L2 error: sqrt(mean(err^2))\n    E2 = float(np.sqrt(np.mean(err * err)))\n    # Linfty error: max absolute error\n    Einf = float(np.max(np.abs(err)))\n\n    return E2, Einf\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [8, 16, 18, 32, 64, 128]\n\n    results = []\n    for N in test_cases:\n        E2, Einf = spectral_derivative_on_grid(N)\n        results.append([int(N), E2, Einf])\n\n    # Final print statement in the exact required format.\n    # Single line output: list of triples [N, E2, Einf] as comma-separated list in brackets.\n    print(f\"[{','.join(str(item) for item in results)}]\")\n\nsolve()\n```", "id": "3614982"}, {"introduction": "在将谱方法应用于非线性问题时，一个关键的挑战是如何处理乘积项，例如 $f(x)g(x)$。在离散网格上直接计算这类乘积，会不可避免地引入“混叠误差”（aliasing error），即高频分量被错误地表示为低频分量，从而污染整个计算结果。这个实践 ([@problem_id:3615024]) 旨在揭示并量化这种由混叠效应引起的偏差，并引导你运用谱空间中的卷积定理来精确计算乘积项的积分，这是实现高精度非线性仿真的核心“去混叠”（dealiasing）技术之一。", "problem": "给定一个周期域和两个由有限傅里叶级数表示的实值函数。您的任务是使用两种不同的方法计算这些函数乘积的积分，并量化由混叠引起的偏差。其基础是周期域上傅里叶级数的定义、谱空间中卷积的定义，以及均匀网格上周期函数的求积。\n\n考虑一个长度为 $2\\pi$ 的一维周期域，其空间坐标 $x \\in [0,2\\pi)$ 以弧度表示。设 $f(x)$ 和 $g(x)$ 为实值函数，其有限傅里叶级数以三角基写为：\n$$\nf(x) = a_0^{(f)} + \\sum_{k=1}^{K_f} \\left(a_k^{(f)}\\cos(kx) + b_k^{(f)}\\sin(kx)\\right), \\quad\ng(x) = a_0^{(g)} + \\sum_{k=1}^{K_g} \\left(a_k^{(g)}\\cos(kx) + b_k^{(g)}\\sin(kx)\\right).\n$$\n目标是计算乘积 $h(x) = f(x)g(x)$ 在 $[0,2\\pi)$ 上的积分，记为\n$$\nI = \\int_{0}^{2\\pi} h(x)\\,dx,\n$$\n使用两种方法：\n\n1. 一种基于傅里叶级数卷积的去混叠谱空间方法。此计算必须从傅里叶级数原理推导得出，并且在傅里叶系数已知且有限的情况下，必须返回无混叠的正确积分。\n\n2. 一种在 $N$ 个点的均匀网格上使用梯形法则的直接求积法（对于在等距网格上采样的周期函数，该法则等于均匀平均值乘以域长度）。当网格无法解析最高频率内容时，此方法会受到混叠的影响。\n\n您应该实现这两种方法，并计算偏差，即直接求积积分与去混叠谱卷积积分之间的差值，\n$$\n\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}.\n$$\n您的程序必须对下面的测试套件中的每个测试用例执行这些计算。角度必须解释为弧度。输出必须是一个浮点数列表，每个测试用例一个，表示该用例的 $\\Delta I$。\n\n测试套件（每个用例指定网格大小 $N$，以及 $f$ 和 $g$ 的系数）：\n\n- 用例 1（良好解析，一般情况）：$N=64$，\n  $f(x) = 0 + 1.0\\cdot\\cos(5x) + 0.4\\cdot\\sin(7x)$,\n  $g(x) = 0 + 1.2\\cdot\\cos(5x) - 0.1\\cdot\\sin(7x)$。\n\n- 用例 2（奈奎斯特边界条件）：$N=32$，\n  $f(x) = 0 + 1.0\\cdot\\cos(16x)$,\n  $g(x) = 0 + 1.0\\cdot\\cos(16x)$。\n\n- 用例 3（由于采样下频率冲突导致的显著混叠偏差）：$N=32$，\n  $f(x) = 0 + 1.0\\cdot\\cos(18x)$,\n  $g(x) = 0 + 1.0\\cdot\\cos(14x)$。\n\n- 用例 4（多模态混叠场景）：$N=24$，\n  $f(x) = 0 + 1.0\\cdot\\cos(17x) + 0.5\\cdot\\sin(5x)$,\n  $g(x) = 0 + 1.3\\cdot\\cos(7x) + 0.5\\cdot\\sin(17x)$。\n\n- 用例 5（良好解析的多模态情况）：$N=48$，\n  $f(x) = 0 + 0.8\\cdot\\cos(20x) - 0.5\\cdot\\sin(22x)$,\n  $g(x) = 0 + 0.8\\cdot\\cos(20x) - 0.5\\cdot\\sin(22x)$。\n\n需要实现的算法细节：\n\n- 对于去混叠谱空间计算，推导 $f(x)$ 和 $g(x)$ 的傅里叶级数卷积的零波数（平均）模态的表达式，并用它来计算 $I_{\\text{dealiased}}$。您必须从基本的傅里叶级数定义和谱空间中的卷积出发，确保当级数有限时，混叠不会影响结果。\n\n- 对于直接求积计算，在 $N$ 个等距点 $x_n = \\frac{2\\pi n}{N}$（其中 $n = 0,1,\\dots,N-1$）上对函数进行采样，并将 $I_{\\text{direct}}$ 计算为乘积平均值乘以 $2\\pi$：\n$$\nI_{\\text{direct}} = \\left(\\frac{1}{N}\\sum_{n=0}^{N-1} f(x_n)g(x_n)\\right) \\cdot 2\\pi.\n$$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4,result5]”）。每个条目必须是相应案例的 $\\Delta I$ 的浮点值。由于域长度是以弧度为单位的 $2\\pi$，并且在此设置中积分为无量纲，因此不需要物理单位。", "solution": "问题要求计算两个函数乘积 $h(x) = f(x)g(x)$ 在周期域 $[0, 2\\pi)$ 上的积分。这个积分记为 $I = \\int_{0}^{2\\pi} h(x)\\,dx$，需要使用两种不同的方法进行计算：一种是去混叠的谱空间方法，另一种是在均匀网格上的直接求积法。需要报告的是这两种方法之间的偏差 $\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}$。\n\n对问题陈述的验证证实了其科学性、适定性和客观性。这是数值分析和谱方法中的一个标准问题，所有必要的数据和定义均已提供。\n\n解决方案首先根据指定的两种方法推导积分表达式。\n\n**方法 1：去混叠谱空间积分 ($I_{\\text{dealiased}}$)**\n\n此方法计算具有有限傅里叶级数的两个函数乘积的精确积分。周期函数在其域上的积分与其平均值成正比，该平均值对应于其傅里叶级数的零波数（$k=0$）系数。\n\n设 $h(x)$ 的傅里叶级数以复数形式表示为 $h(x) = \\sum_{k=-\\infty}^{\\infty} c_k^{(h)} e^{ikx}$。$k=0$ 的系数由 $c_0^{(h)} = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} h(x) e^{-i(0)x} dx = \\frac{1}{2\\pi}I$ 给出。因此，精确积分为 $I = 2\\pi c_0^{(h)}$。\n\n函数 $f(x)$ 和 $g(x)$ 以实三角基给出：\n$$\nf(x) = a_0^{(f)} + \\sum_{k=1}^{K_f} \\left(a_k^{(f)}\\cos(kx) + b_k^{(f)}\\sin(kx)\\right)\n$$\n$g(x)$ 也类似。积分 $I = \\int_{0}^{2\\pi} f(x)g(x) dx$ 可以通过代入这些级数并使用三角函数在区间 $[0, 2\\pi)$ 上的正交关系来计算：\n$$\n\\int_{0}^{2\\pi}\\cos(kx)\\cos(jx)dx = \\pi\\delta_{kj} \\quad (k,j > 0)\n$$\n$$\n\\int_{0}^{2\\pi}\\sin(kx)\\sin(jx)dx = \\pi\\delta_{kj} \\quad (k,j > 0)\n$$\n$$\n\\int_{0}^{2\\pi}\\cos(kx)\\sin(jx)dx = 0\n$$\n$$\n\\int_{0}^{2\\pi}\\cos(kx)dx = 0, \\quad \\int_{0}^{2\\pi}\\sin(kx)dx = 0 \\quad (k > 0)\n$$\n$$\n\\int_{0}^{2\\pi} 1 \\cdot 1 \\, dx = 2\\pi\n$$\n在计算乘积 $f(x)g(x)$ 的积分时，唯一能产生非零结果的项是常数项的乘积以及相同类型和相同波数的三角函数乘积。这导致：\n$$\nI_{\\text{dealiased}} = \\int_{0}^{2\\pi} (a_0^{(f)})(a_0^{(g)}) dx + \\sum_{k=1}^{\\infty} \\int_{0}^{2\\pi} (a_k^{(f)}\\cos(kx))(a_k^{(g)}\\cos(kx)) dx + \\sum_{k=1}^{\\infty} \\int_{0}^{2\\pi} (b_k^{(f)}\\sin(kx))(b_k^{(g)}\\sin(kx)) dx\n$$\n使用正交关系，这可以简化为：\n$$\nI_{\\text{dealiased}} = 2\\pi a_0^{(f)} a_0^{(g)} + \\sum_{k=1}^{\\infty} \\pi(a_k^{(f)} a_k^{(g)} + b_k^{(f)} b_k^{(g)})\n$$\n由于输入的级数是有限的，这个和也是有限的。该公式是精确且无混叠的，因此是“去混叠”的结果。\n\n**方法 2：直接求积积分 ($I_{\\text{direct}}$)**\n\n此方法使用梯形法则在 $N$ 个点的均匀网格 $x_n = \\frac{2\\pi n}{N}$（其中 $n = 0, 1, \\dots, N-1$）上近似积分。对于周期函数，这等效于对网格上的函数值求平均，然后乘以域长度：\n$$\nI_{\\text{direct}} = \\frac{2\\pi}{N} \\sum_{n=0}^{N-1} h(x_n) = \\frac{2\\pi}{N} \\sum_{n=0}^{N-1} f(x_n)g(x_n)\n$$\n这种数值求积方法易受混叠影响。乘积函数 $h(x)$ 包含高达 $K_f + K_g$ 的波数。如果这个最大波数超过网格的奈奎斯特波数 $k_{Nyquist} = N/2$，那么高频分量将被错误地表示为低频分量。\n\n由求积法则计算的离散和精确等于网格所见的混叠函数的积分。混叠关系指出，采样信号 $h(x_n)$ 的离散傅里叶变换系数 $\\hat{h}_k$ 与连续傅里叶级数系数 $c_k^{(h)}$ 通过公式 $\\hat{h}_k = N \\sum_{m=-\\infty}^{\\infty} c_{k+mN}^{(h)}$ 相关联。\n\n直接积分与离散傅里叶变换的 $k=0$ 分量有关：$I_{\\text{direct}} = \\frac{2\\pi}{N} \\hat{h}_0$。代入 $\\hat{h}_0$ 的混叠公式：\n$$\nI_{\\text{direct}} = \\frac{2\\pi}{N} \\left( N \\sum_{m=-\\infty}^{\\infty} c_{mN}^{(h)} \\right) = 2\\pi \\sum_{m=-\\infty}^{\\infty} c_{mN}^{(h)}\n$$\n$$\nI_{\\text{direct}} = 2\\pi (c_0^{(h)} + c_N^{(h)} + c_{-N}^{(h)} + c_{2N}^{(h)} + c_{-2N}^{(h)} + \\dots)\n$$\n\n**混叠引起的偏差 ($\\Delta I$)**\n\n偏差是两个计算积分之间的差值：\n$$\n\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}\n$$\n代入上面推导的表达式：\n$$\n\\Delta I = \\left( 2\\pi \\sum_{m=-\\infty}^{\\infty} c_{mN}^{(h)} \\right) - (2\\pi c_0^{(h)}) = 2\\pi \\sum_{m \\neq 0} c_{mN}^{(h)}\n$$\n由于 $h(x)$ 是实函数，其傅里叶系数满足 $c_{-k}^{(h)} = (c_k^{(h)})^*$，因此偏差可以写为：\n$$\n\\Delta I = 2\\pi \\sum_{m=1}^{\\infty} (c_{mN}^{(h)} + c_{-mN}^{(h)}) = 4\\pi \\sum_{m=1}^{\\infty} \\text{Re}(c_{mN}^{(h)})\n$$\n这表明，当且仅当乘积函数 $h(x)$ 在作为网格大小 $N$ 的非零倍数的波数上具有谱功率时，才会出现非零偏差。这些分量直接混叠到零波数（平均）分量上，从而破坏了积分的估计。如果 $h(x)$ 中的最大波数小于 $N$，则对于所有 $m \\geq 1$，都有 $c_{mN}^{(h)}=0$，导致零偏差。\n\n解决该问题的算法如下：\n1. 对于每个测试用例，定义函数 $f(x)$ 和 $g(x)$ 的傅里叶系数 $(a_k, b_k)$。\n2. 实现一个函数，使用基于系数乘积的推导公式计算 $I_{\\text{dealiased}}$。\n3. 实现一个函数，该函数合成函数 $f(x)$ 和 $g(x)$，在指定的 $N$ 点网格上对其乘积 $h(x)$ 进行采样，并使用梯形法则求和计算 $I_{\\text{direct}}$。\n4. 为每个用例计算差值 $\\Delta I = I_{\\text{direct}} - I_{\\text{dealiased}}$。\n5. 收集并输出结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aliasing-induced bias in the integral of a product of two\n    functions for a suite of test cases.\n    \"\"\"\n\n    # Test suite definition: (N, f_coeffs_spec, g_coeffs_spec)\n    # f_coeffs_spec is a list of tuples (type, k, value)\n    # where type is 'a' for cos coefficient or 'b' for sin coefficient.\n    test_cases = [\n        # Case 1: Well-resolved case\n        (64, [('a', 5, 1.0), ('b', 7, 0.4)], [('a', 5, 1.2), ('b', 7, -0.1)]),\n        # Case 2: Nyquist boundary condition\n        (32, [('a', 16, 1.0)], [('a', 16, 1.0)]),\n        # Case 3: Significant aliasing-induced bias\n        (32, [('a', 18, 1.0)], [('a', 14, 1.0)]),\n        # Case 4: Multi-mode aliasing scenario\n        (24, [('a', 17, 1.0), ('b', 5, 0.5)], [('a', 7, 1.3), ('b', 17, 0.5)]),\n        # Case 5: Well-resolved multi-mode case (with aliasing but no bias)\n        (48, [('a', 20, 0.8), ('b', 22, -0.5)], [('a', 20, 0.8), ('b', 22, -0.5)]),\n    ]\n\n    results = []\n    for N, f_spec, g_spec in test_cases:\n        \n        def parse_spec_to_coeffs(spec):\n            \"\"\"Parses coefficient specifications into a dictionary structure.\"\"\"\n            coeffs = {\"a0\": 0.0, \"ak\": {}, \"bk\": {}}\n            for typ, k, val in spec:\n                if typ == 'a' and k != 0:\n                    coeffs[\"ak\"][k] = val\n                elif typ == 'b' and k != 0:\n                    coeffs[\"bk\"][k] = val\n                elif typ == 'a' and k == 0:\n                    coeffs[\"a0\"] = val\n            return coeffs\n\n        f_coeffs = parse_spec_to_coeffs(f_spec)\n        g_coeffs = parse_spec_to_coeffs(g_spec)\n\n        def build_func_from_coeffs(coeffs):\n            \"\"\"Builds a callable Python function from a coefficient dictionary.\"\"\"\n            a0 = coeffs.get(\"a0\", 0.0)\n            ak_coeffs = coeffs.get(\"ak\", {})\n            bk_coeffs = coeffs.get(\"bk\", {})\n            \n            def func(x):\n                val = a0\n                for k, a_k in ak_coeffs.items():\n                    val += a_k * np.cos(k * x)\n                for k, b_k in bk_coeffs.items():\n                    val += b_k * np.sin(k * x)\n                return val\n            return func\n\n        f_func = build_func_from_coeffs(f_coeffs)\n        g_func = build_func_from_coeffs(g_coeffs)\n\n        # Method 1: Dealiased Spectral-Space Integral\n        def calculate_I_dealiased(f_c, g_c):\n            # I_dealiased = 2*pi*a0_f*a0_g + pi * sum(ak_f*ak_g + bk_f*bk_g)\n            a0_f = f_c.get(\"a0\", 0.0)\n            a0_g = g_c.get(\"a0\", 0.0)\n            \n            integral = 2.0 * np.pi * a0_f * a0_g\n            \n            sum_term = 0.0\n            all_k = set(f_c[\"ak\"].keys()) | set(f_c[\"bk\"].keys()) | \\\n                    set(g_c[\"ak\"].keys()) | set(g_c[\"bk\"].keys())\n            \n            for k in all_k:\n                ak_f = f_c[\"ak\"].get(k, 0.0)\n                bk_f = f_c[\"bk\"].get(k, 0.0)\n                ak_g = g_c[\"ak\"].get(k, 0.0)\n                bk_g = g_c[\"bk\"].get(k, 0.0)\n                sum_term += ak_f * ak_g + bk_f * bk_g\n                \n            integral += np.pi * sum_term\n            return integral\n\n        I_dealiased = calculate_I_dealiased(f_coeffs, g_coeffs)\n        \n        # Method 2: Direct Quadrature Integral\n        def calculate_I_direct(func_f, func_g, num_points):\n            # Grid points: x_n = 2*pi*n/N for n = 0,...,N-1\n            x_grid = np.linspace(0.0, 2.0 * np.pi, num_points, endpoint=False)\n            \n            f_vals = func_f(x_grid)\n            g_vals = func_g(x_grid)\n            h_vals = f_vals * g_vals\n            \n            # Trapezoidal rule for periodic function\n            integral = (2.0 * np.pi / num_points) * np.sum(h_vals)\n            return integral\n\n        I_direct = calculate_I_direct(f_func, g_func, N)\n\n        # Compute the bias\n        delta_I = I_direct - I_dealiased\n        results.append(delta_I)\n\n    # Format the final output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3615024"}, {"introduction": "谱方法的“谱精度”是其最引人注目的特性，这意味着对于光滑函数，其近似误差随网格点数 $N$ 的增加呈指数级或更快的速度下降。为了深入理解这一现象的根源，本练习 ([@problem_id:3615049]) 选取了一个解析函数 $u(x) = \\exp(\\beta \\cos(x))$ 作为基准。你将推导其傅里叶系数与修正贝塞尔函数的关系，并据此计算截断误差 $E_N(\\beta)$。这个过程将清晰地揭示函数的解析性（光滑程度）是如何决定其傅里叶系数的衰减速率，从而从根本上解释谱方法为何能实现如此惊人的收敛速度。", "problem": "考虑 $2\\pi$ 周期函数 $u(x) = \\exp\\!\\big(\\beta \\cos(x)\\big)$，其中实数参数 $\\beta \\ge 0$，所有角度均以弧度为单位。在区间 $[0,2\\pi)$ 上，我们采用复傅里叶级数的约定：复傅里叶系数定义为 $\\,\\hat{u}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} u(x) e^{-ikx} \\, dx\\,$，其中 $k \\in \\mathbb{Z}$ 为任意整数。$N$ 阶傅里叶逼近的 $L^2$ 截断误差平方定义为\n$$\nE_N(\\beta) = \\sum_{|k|>N} \\big|\\hat{u}_k\\big|^2,\n$$\n其中 $L^2$ 范数由内积 $\\langle f,g\\rangle = \\frac{1}{2\\pi}\\int_0^{2\\pi} f(x)\\,\\overline{g(x)}\\,dx$ 导出。从基本定义出发，利用复指数的正交性、复傅里叶系数的定义以及特殊函数的已知性质，推导傅里叶系数 $\\,\\hat{u}_k\\,$ 和总能量 $\\,\\frac{1}{2\\pi}\\int_0^{2\\pi}\\big|u(x)\\big|^2\\,dx\\,$ 的解析闭式表达式。基于这些结果，将 $E_N(\\beta)$ 表示为一个有限和与一个仅依赖于 $\\beta$ 的单项，并为其对 $N$ 的依赖性提供一个有理有据的论证，包括解释在有限 $N$ 下观察到的有效衰减率的意义上，对于大的 $N$，衰减率如何依赖于 $\\beta$。\n\n你的任务是实现一个程序，用以计算下面列出的每个测试用例的 $E_N(\\beta)$。你必须使用实数算术，并且所有角度都必须以弧度处理。最终答案必须是标准数值库产生的全双精度实数（浮点数）；除了确保角度以弧度为单位外，不需要进行其他单位转换。\n\n测试套件：\n- 测试用例 1：$\\beta = 0.0$, $N = 0$。\n- 测试用例 2：$\\beta = 0.5$, $N = 0$。\n- 测试用例 3：$\\beta = 0.5$, $N = 5$。\n- 测试用例 4：$\\beta = 2.0$, $N = 10$。\n- 测试用例 5：$\\beta = 5.0$, $N = 5$。\n- 测试用例 6：$\\beta = 5.0$, $N = 20$。\n\n你的程序应该生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5,result6]”），结果的顺序与上述测试用例一致，每个结果是对应测试用例计算出的 $E_N(\\beta)$ 值。不应打印任何其他文本。", "solution": "问题要求推导和计算函数 $u(x) = \\exp(\\beta \\cos(x))$ 的傅里叶级数的 $L^2$ 截断误差平方。我们首先验证问题陈述。\n\n### 步骤 1：提取已知条件\n- **函数**：$u(x) = \\exp(\\beta \\cos(x))$，一个 $2\\pi$ 周期函数。\n- **参数**：$\\beta \\ge 0$ 是一个实数参数。\n- **定义域**：区间 $[0, 2\\pi)$。\n- **复傅里叶系数**：$\\hat{u}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} u(x) e^{-ikx} \\, dx$，其中 $k \\in \\mathbb{Z}$。\n- **$L^2$ 截断误差平方**：$E_N(\\beta) = \\sum_{|k|>N} |\\hat{u}_k|^2$。\n- **$L^2$ 范数和内积**：$\\langle f,g\\rangle = \\frac{1}{2\\pi}\\int_0^{2\\pi} f(x)\\,\\overline{g(x)}\\,dx$。范数平方为 $\\|f\\|_{L^2}^2 = \\langle f,f \\rangle$。\n- **任务**：推导 $E_N(\\beta)$ 的闭式表达式，并实现一个程序来计算指定测试用例的值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上和数学上都是合理的。它涉及将傅里叶分析的标准概念应用于一个良态（解析、周期）函数。待计算的量是明确定义的。在此背景下，使用特殊函数（修正贝塞尔函数）是一种标准技术。该问题是自洽的、客观的且适定的。不存在矛盾、歧义或违反科学原理之处。\n\n### 步骤 3：结论与行动\n问题是**有效的**。我们继续进行求解。\n\n### 截断误差公式的推导\n\n解法基于 Parseval 定理，该定理将函数的总能量与其傅里叶系数的模平方和联系起来。对于给定的归一化，Parseval 定理表明：\n$$\n\\frac{1}{2\\pi} \\int_{0}^{2\\pi} |u(x)|^2 dx = \\sum_{k=-\\infty}^{\\infty} |\\hat{u}_k|^2\n$$\n右边是分布在傅里叶模式上的总能量。我们可以在截断指数 $N$ 处将此和式拆分：\n$$\n\\sum_{k=-\\infty}^{\\infty} |\\hat{u}_k|^2 = \\sum_{k=-N}^{N} |\\hat{u}_k|^2 + \\sum_{|k|>N} |\\hat{u}_k|^2\n$$\n根据定义，右侧的第二项是 $L^2$ 截断误差的平方，即 $E_N(\\beta)$。因此，我们可以将误差表示为：\n$$\nE_N(\\beta) = \\left( \\frac{1}{2\\pi} \\int_{0}^{2\\pi} |u(x)|^2 dx \\right) - \\left( \\sum_{k=-N}^{N} |\\hat{u}_k|^2 \\right)\n$$\n为了得到 $E_N(\\beta)$ 的可计算表达式，我们必须找到积分（总能量）和傅里叶系数 $\\hat{u}_k$ 的闭式表达式。\n\n**1. 总能量项**\n\n总能量由积分 $\\frac{1}{2\\pi} \\int_{0}^{2\\pi} |u(x)|^2 dx$ 给出。由于 $\\beta$ 是实数，$\\cos(x)$ 是实数，实数的指数函数是实数且为正。因此，$u(x)$ 是一个实值函数。\n$$\n|u(x)|^2 = u(x)^2 = \\left( \\exp(\\beta \\cos(x)) \\right)^2 = \\exp(2\\beta \\cos(x))\n$$\n积分变为：\n$$\n\\text{总能量} = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(2\\beta \\cos(x)) dx\n$$\n这个积分是零阶第一类修正贝塞尔函数 $I_0(z)$ 的标准积分表示，其定义为：\n$$\nI_0(z) = \\frac{1}{\\pi} \\int_{0}^{\\pi} e^{z \\cos(\\theta)} d\\theta\n$$\n由于被积函数 $\\exp(z \\cos(x))$ 是一个偶函数且周期为 $2\\pi$，我们有 $\\int_{0}^{2\\pi} \\dots dx = 2 \\int_{0}^{\\pi} \\dots dx$。因此：\n$$\n\\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(z \\cos(x)) dx = \\frac{1}{2\\pi} \\cdot 2 \\int_{0}^{\\pi} \\exp(z \\cos(x)) dx = \\frac{1}{\\pi} \\int_{0}^{\\pi} \\exp(z \\cos(x)) dx = I_0(z)\n$$\n令 $z = 2\\beta$，我们发现总能量为 $I_0(2\\beta)$。\n\n**2. 傅里叶系数 $\\hat{u}_k$**\n\n傅里叶系数定义为 $\\hat{u}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(\\beta \\cos(x)) e^{-ikx} dx$。\n使用欧拉公式 $e^{-ikx} = \\cos(kx) - i\\sin(kx)$，积分变为：\n$$\n\\hat{u}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(\\beta \\cos(x)) \\cos(kx) dx - \\frac{i}{2\\pi} \\int_{0}^{2\\pi} \\exp(\\beta \\cos(x)) \\sin(kx) dx\n$$\n函数 $\\exp(\\beta \\cos(x))$ 是 $x$ 的偶函数。一个偶函数与一个奇函数（$\\sin(kx)$）的乘积是奇函数。一个奇周期函数在长度为 $2\\pi$ 的对称区间（如 $[-\\pi, \\pi]$，并可推广至 $[0, 2\\pi]$）上的积分为零。因此，$\\hat{u}_k$ 的虚部为零。\n$$\n\\hat{u}_k = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp(\\beta \\cos(x)) \\cos(kx) dx\n$$\n被积函数是一个偶函数，所以我们再次可以写成 $\\int_{0}^{2\\pi} \\dots dx = 2 \\int_{0}^{\\pi} \\dots dx$：\n$$\n\\hat{u}_k = \\frac{1}{\\pi} \\int_{0}^{\\pi} \\exp(\\beta \\cos(x)) \\cos(kx) dx\n$$\n这是 $k$ 阶第一类修正贝塞尔函数 $I_k(\\beta)$ 的积分表示。\n因此，$\\hat{u}_k = I_k(\\beta)$。由于 $u(x)$ 是实偶函数，其傅里叶系数必须是关于指标 $k$ 的实偶函数，这与整数 $k$ 的性质 $I_k(\\beta) = I_{-k}(\\beta)$ 一致。\n\n**3. $E_N(\\beta)$ 的最终表达式**\n\n将这些结果代入我们的截断误差表达式中：\n$$\nE_N(\\beta) = I_0(2\\beta) - \\sum_{k=-N}^{N} |I_k(\\beta)|^2\n$$\n由于 $I_k(\\beta)$ 是实数，所以 $|I_k(\\beta)|^2 = (I_k(\\beta))^2$。我们可以展开这个和式：\n$$\n\\sum_{k=-N}^{N} (I_k(\\beta))^2 = (I_{-N}(\\beta))^2 + \\dots + (I_{-1}(\\beta))^2 + (I_0(\\beta))^2 + (I_1(\\beta))^2 + \\dots + (I_N(\\beta))^2\n$$\n利用对称性 $I_{-k}(\\beta) = I_k(\\beta)$，和式变为：\n$$\n\\sum_{k=-N}^{N} (I_k(\\beta))^2 = (I_0(\\beta))^2 + 2 \\sum_{k=1}^{N} (I_k(\\beta))^2\n$$\n这就得出了适用于计算的截断误差的最终闭式表达式：\n$$\nE_N(\\beta) = I_0(2\\beta) - \\left( (I_0(\\beta))^2 + 2 \\sum_{k=1}^{N} (I_k(\\beta))^2 \\right)\n$$\n\n**4. 关于 N 依赖性和衰减率的论证**\n\n函数 $u(x) = \\exp(\\beta\\cos(x))$ 在整个实轴上是解析的。傅里叶分析的一个基本定理指出，在一个带状区域 $\\{z \\in \\mathbb{C} : |\\text{Im}(z)|  a\\}$ 内解析的函数的傅里叶系数呈指数衰减，即 $|\\hat{u}_k| = O(e^{-a|k|})$。在我们的例子中，$u(z) = \\exp(\\beta\\cos(z))$ 是整函数，意味着它在整个复平面上是解析的，这表示其傅里叶系数的衰减速度快于任何指数函数，这种现象被称为谱衰减。\n\n对于大的阶数 $k$ 和固定的 $\\beta$，修正贝塞尔函数的渐近行为由下式给出：\n$$\nI_k(\\beta) \\sim \\frac{1}{\\sqrt{2\\pi k}} \\left( \\frac{e\\beta}{2k} \\right)^k \\quad \\text{当 } k \\to \\infty\n$$\n截断误差平方 $E_N(\\beta) = \\sum_{|k|>N} |I_k(\\beta)|^2$ 主要由和式外的第一项（即 $|k|=N+1$ 的项）决定。因此，误差的衰减近似为：\n$$\nE_N(\\beta) \\approx 2 |I_{N+1}(\\beta)|^2 \\sim 2 \\left( \\frac{1}{\\sqrt{2\\pi (N+1)}} \\left( \\frac{e\\beta}{2(N+1)} \\right)^{N+1} \\right)^2 = \\frac{1}{\\pi(N+1)} \\left( \\frac{e\\beta}{2(N+1)} \\right)^{2(N+1)}\n$$\n这表明了超几何（或谱）收敛。对于固定的 $\\beta$，随着 $N$ 的增加，$(\\frac{1}{N+1})^{2(N+1)}$ 这一项确保了极快的衰减速度。\n\n参数 $\\beta$ 控制函数 $u(x)$ 的“峰度”。\n- 对于小的 $\\beta$，$u(x) \\approx 1 + \\beta\\cos(x)$，这是一个平滑且变化缓慢的函数。能量集中在低频模式（$I_0, I_1$）中，而对于 $k>1$ 的系数 $I_k(\\beta)$ 会非常迅速地变得很小。即使对于小的 $N$，截断误差也很小。\n- 对于大的 $\\beta$，$u(x)$ 在 $x=0$ 附近变得非常尖锐，而在其他地方则非常小。表示这样一个尖锐的特征需要许多高频模式的显著贡献。在渐近衰减起主导作用之前，系数 $I_k(\\beta)$ 在更宽的 $k$ 值范围内保持不可忽略。因此，对于固定的 $N$，$\\beta$ 越大，截断误差 $E_N(\\beta)$ 就会越大。在有限 $N$ 下观察到的“有效”衰减率对于大的 $\\beta$ 会更慢，因为衰减迅速的渐近区域被推向了更高的 $N$ 值。", "answer": "```python\nimport numpy as np\nfrom scipy.special import i0, iv\n\ndef solve():\n    \"\"\"\n    Computes the L2 truncation error for the Fourier series of exp(beta*cos(x)).\n    \n    The squared L2 truncation error is given by:\n    E_N(beta) = ||u||^2 - sum_{k=-N to N} |u_k|^2\n    \n    Using properties of modified Bessel functions, this can be shown to be:\n    E_N(beta) = I_0(2*beta) - (I_0(beta)^2 + 2 * sum_{k=1 to N} I_k(beta)^2)\n    where I_k is the modified Bessel function of the first kind of order k.\n    \"\"\"\n    \n    # Test cases from the problem statement\n    # Each case is a tuple (beta, N)\n    test_cases = [\n        (0.0, 0),\n        (0.5, 0),\n        (0.5, 5),\n        (2.0, 10),\n        (5.0, 5),\n        (5.0, 20),\n    ]\n\n    results = []\n    for beta, N in test_cases:\n        # Calculate the total energy term: I_0(2*beta)\n        total_energy = i0(2.0 * beta)\n\n        # Calculate the sum of squared coefficients for |k| = N\n        # Start with the k=0 term: I_0(beta)^2\n        sum_sq_coeffs = i0(beta)**2\n\n        # Add the terms for k = 1 to N.\n        # The sum is 2 * sum_{k=1 to N} I_k(beta)^2 due to symmetry I_{-k} = I_k\n        if N > 0:\n            # Generate array of orders k from 1 to N\n            k_values = np.arange(1, N + 1)\n            # Calculate I_k(beta) for all k in k_values\n            bessel_coeffs = iv(k_values, beta)\n            # Sum the squares and multiply by 2\n            sum_sq_coeffs += 2.0 * np.sum(bessel_coeffs**2)\n            \n        # The truncation error is the difference\n        error = total_energy - sum_sq_coeffs\n        results.append(error)\n\n    # Format the final output string as specified\n    # The results are expected to be floating-point numbers.\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\n# Run the solver\nsolve()\n\n```", "id": "3615049"}]}