{"hands_on_practices": [{"introduction": "帕塞瓦尔定理是一个基本原理，它指出一个场的总能量（或功率）无论是在空间域还是在谱域中计算都是相同的。本练习旨在对球谐函数的这一关键恒等式进行具体的数值验证 [@problem_id:3615105]。它加强了场的空间表示与其谱系数之间的联系，同时提供了在球面上进行数值积分的实践经验。", "problem": "您的任务是，在选定的归一化条件下，推导单位球面上的球谐函数的帕塞瓦尔恒等式，并进行数值验证。考虑单位球面上的完全归一化复球谐函数基 $\\{Y_{l}^{m}(\\theta,\\phi)\\}$，其中 $l \\in \\{0,1,2,\\dots\\}$ 且 $m \\in \\{-l,-l+1,\\dots,l\\}$。角度必须以弧度为单位。该完全归一化基满足单位球面上的正交归一性条件：\n$$\n\\int_{0}^{2\\pi}\\int_{0}^{\\pi} Y_{l}^{m}(\\theta,\\phi)\\,Y_{l'}^{m'}(\\theta,\\phi)^{*}\\,\\sin\\theta\\,d\\theta\\,d\\phi = \\delta_{ll'}\\,\\delta_{mm'},\n$$\n在变量替换 $\\mu=\\cos\\theta$ 下，该条件变为：\n$$\n\\int_{0}^{2\\pi}\\int_{-1}^{1} Y_{l}^{m}(\\arccos\\mu,\\phi)\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi)^{*}\\,d\\mu\\,d\\phi = \\delta_{ll'}\\,\\delta_{mm'}.\n$$\n设截断球谐展开定义为：\n$$\nf(\\theta,\\phi) = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} f_{lm}\\,Y_{l}^{m}(\\theta,\\phi),\n$$\n其中 $L$ 是一个非负整数截断阶数，$f_{lm} \\in \\mathbb{C}$ 是展开系数。请在上述归一化条件下，为该展开推导帕塞瓦尔恒等式：\n$$\n\\int_{0}^{2\\pi}\\int_{-1}^{1} \\left| f(\\arccos\\mu,\\phi) \\right|^{2}\\,d\\mu\\,d\\phi = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}.\n$$\n然后，使用单位球面上的求积法进行数值验证。请采用以下计算策略：\n- 在一个张量积网格上构建场 $f(\\theta,\\phi)$，其中 $\\theta$ 节点由 $\\mu=\\cos\\theta$ 中的高斯-勒让德求积法得到，$\\phi$ 节点则在 $[0,2\\pi)$ 上使用均匀梯形法则得到。\n- 通过在网格上求和来数值近似积分 $\\int_{0}^{2\\pi}\\int_{-1}^{1} |f(\\arccos\\mu,\\phi)|^{2}\\,d\\mu\\,d\\phi$，其中对 $d\\mu$ 使用高斯-勒让德权重，对 $d\\phi$ 使用均匀权重，即：\n$$\n\\int_{0}^{2\\pi}\\int_{-1}^{1} |f(\\arccos\\mu,\\phi)|^{2}\\,d\\mu\\,d\\phi \\approx \\sum_{i=1}^{N_{\\theta}} \\sum_{j=1}^{N_{\\phi}} w_{i}\\,\\Delta\\phi\\,\\left|f(\\theta_{i},\\phi_{j})\\right|^{2},\n$$\n其中 $\\{\\mu_{i},w_{i}\\}_{i=1}^{N_{\\theta}}$ 是高斯-勒让德节点和权重，$\\theta_{i}=\\arccos(\\mu_{i})$，$\\phi_{j}=2\\pi j/N_{\\phi}$，且 $\\Delta\\phi=2\\pi/N_{\\phi}$。\n- 将数值结果与解析和 $\\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}$ 进行比较，并报告由下式定义的相对误差：\n$$\n\\varepsilon = \\frac{\\left|\\left(\\sum_{i=1}^{N_{\\theta}}\\sum_{j=1}^{N_{\\phi}} w_{i}\\,\\Delta\\phi\\,|f(\\theta_{i},\\phi_{j})|^{2}\\right) - \\left(\\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}\\right)\\right|}{\\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}}.\n$$\n\n为了验证，请直接从随机选择的系数 $\\{f_{lm}\\}$ 合成场 $f(\\theta,\\phi)$，而不要从 $f(\\theta,\\phi)$ 数值计算 $\\{f_{lm}\\}$。请使用可靠数值库提供的完全归一化球谐函数。对于实值场情况，请确保强制执行共轭对称约束 $f_{l,-m}=(-1)^{m} f_{lm}^{*}$ 和 $f_{l0}\\in\\mathbb{R}$，以使 $f(\\theta,\\phi)\\in\\mathbb{R}$。\n\n角度必须以弧度为单位。除角度单位外，不使用任何物理单位。您的程序必须实现以下测试套件，并为每个测试用例生成相对误差：\n- 测试 1（理想情况，单极子）：$L=0$，$N_{\\theta}=8$，$N_{\\phi}=16$，实值场，随机种子 $42$。\n- 测试 2（中等情况，复数场）：$L=3$，$N_{\\theta}=40$，$N_{\\phi}=80$，复值场，随机种子 $7$。\n- 测试 3（较高L，复数场）：$L=10$，$N_{\\theta}=64$，$N_{\\phi}=128$，复值场，随机种子 $123$。\n- 测试 4（较高L，实数场）：$L=12$，$N_{\\theta}=80$，$N_{\\phi}=160$，实值场，随机种子 $9001$。\n- 测试 5（边界情况，粗糙网格）：$L=20$，$N_{\\theta}=41$，$N_{\\phi}=41$，复值场，随机种子 $2023$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4,result5]\"）。每个结果必须是对应测试用例的相对误差 $\\varepsilon$ 的浮点数。", "solution": "该问题要求推导截断球谐展开的帕塞瓦尔恒等式并对其进行数值验证。该问题具有科学依据，提法明确，并包含了获得唯一解所需的所有信息。\n\n### 第一部分：帕塞瓦尔恒等式的推导\n\n帕塞瓦尔恒等式将函数模平方在其定义域上的积分与其在正交归一基下的展开系数模平方之和联系起来。我们被要求为单位球面上的函数 $f(\\theta,\\phi)$ 推导这个恒等式，该函数由截断球谐展开表示。\n\n设函数 $f(\\theta,\\phi)$ 由其展开至最大阶数 $L$ 定义：\n$$\nf(\\theta,\\phi) = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} f_{lm}\\,Y_{l}^{m}(\\theta,\\phi)\n$$\n其中 $f_{lm} \\in \\mathbb{C}$ 是球谐系数，$\\{Y_{l}^{m}(\\theta,\\phi)\\}$ 是完全归一化复球谐函数的基。分析将使用变量 $\\mu = \\cos\\theta$ 进行，单位球面上的面积元为 $d\\Omega = d\\mu\\,d\\phi = \\sin\\theta\\,d\\theta\\,d\\phi$。\n\n该基的正交归一性条件为：\n$$\n\\int_{0}^{2\\pi}\\int_{-1}^{1} Y_{l}^{m}(\\arccos\\mu,\\phi)\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi)^{*}\\,d\\mu\\,d\\phi = \\delta_{ll'}\\,\\delta_{mm'}\n$$\n其中 $Y_{l'}^{m'}(\\cdot)^{*}$ 是 $Y_{l'}^{m'}(\\cdot)$ 的复共轭，$\\delta_{ij}$ 是克罗内克δ函数。\n\n我们希望计算 $f(\\theta,\\phi)$ 模平方在单位球面上的积分。这个量通常与场的总功率或能量有关，其表达式为：\n$$\nI = \\int_{0}^{2\\pi}\\int_{-1}^{1} \\left| f(\\arccos\\mu,\\phi) \\right|^{2}\\,d\\mu\\,d\\phi\n$$\n我们可以将 $|f|^2$ 写为 $f \\cdot f^*$。代入 $f$ 及其复共轭 $f^*$ 的展开式：\n$$\nf(\\arccos\\mu,\\phi)^{*} = \\left( \\sum_{l'=0}^{L}\\sum_{m'=-l'}^{l'} f_{l'm'}\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi) \\right)^{*} = \\sum_{l'=0}^{L}\\sum_{m'=-l'}^{l'} f_{l'm'}^{*}\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi)^{*}\n$$\n请注意，为了在展开乘积时保持清晰，我们使用了不同的求和指数 $(l', m')$。\n\n现在，将这些展开式代入 $I$ 的积分中：\n$$\nI = \\int_{0}^{2\\pi}\\int_{-1}^{1} \\left( \\sum_{l=0}^{L}\\sum_{m=-l}^{l} f_{lm}\\,Y_{l}^{m}(\\arccos\\mu,\\phi) \\right) \\left( \\sum_{l'=0}^{L}\\sum_{m'=-l'}^{l'} f_{l'm'}^{*}\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi)^{*} \\right) \\,d\\mu\\,d\\phi\n$$\n由于求和是有限的，我们可以交换求和与积分的顺序：\n$$\nI = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} \\sum_{l'=0}^{L}\\sum_{m'=-l'}^{l'} f_{lm}\\,f_{l'm'}^{*} \\left( \\int_{0}^{2\\pi}\\int_{-1}^{1} Y_{l}^{m}(\\arccos\\mu,\\phi)\\,Y_{l'}^{m'}(\\arccos\\mu,\\phi)^{*} \\,d\\mu\\,d\\phi \\right)\n$$\n括号中的项正是正交归一性积分，其值为 $\\delta_{ll'}\\,\\delta_{mm'}$。此性质极大地简化了表达式。克罗内克δ函数仅在 $l=l'$ 和 $m=m'$ 时非零（等于1）。因此，四重求和坍缩为双重求和，因为只有指数匹配的项会保留下来：\n$$\nI = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} \\sum_{l'=0}^{L}\\sum_{m'=-l'}^{l'} f_{lm}\\,f_{l'm'}^{*} \\,\\delta_{ll'}\\,\\delta_{mm'} = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} f_{lm}\\,f_{lm}^{*}\n$$\n由于对任何复数 $c$，都有 $c \\cdot c^{*} = |c|^2$，我们便得到帕塞瓦尔恒等式的最终形式：\n$$\n\\int_{0}^{2\\pi}\\int_{-1}^{1} \\left| f(\\arccos\\mu,\\phi) \\right|^{2}\\,d\\mu\\,d\\phi = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}\n$$\n推导至此完成。\n\n### 第二部分：数值验证策略\n\n数值验证涉及比较帕塞瓦尔恒等式的两边。左边使用数值求积法计算，而右边是给定系数的精确求和。\n\n1.  **系数生成**：对于每个具有给定截断阶数 $L$ 的测试用例，使用带种子的伪随机数生成器生成一组复系数 $\\{f_{lm}\\}$（其中 $l \\in [0, L]$，$m \\in [-l, l]$），以确保可复现性。\n    *   **复数场**：系数 $f_{lm}$ 生成为 $a+ib$，其中 $a$ 和 $b$ 从均匀分布中抽取。\n    *   **实数场**：为确保 $f(\\theta,\\phi)$ 是实值的，系数必须满足对称条件 $f_{l,-m} = (-1)^m f_{lm}^*$。这通过以下方式强制执行：\n        *   对于 $m=0$，$f_{l0}$ 必须是实数。生成一个随机实数。\n        *   对于 $m>0$，为 $f_{lm}$ 生成一个随机复数。然后使用对称关系显式计算系数 $f_{l,-m}$。\n\n2.  **解析和**：帕塞瓦尔恒等式的右边，我们记为 $S_{analytic}$，通过对生成的系数的模平方求和来计算：\n    $$\n    S_{analytic} = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} |f_{lm}|^{2}\n    $$\n\n3.  **网格与求积权重**：为进行数值积分，构建一个 $(\\theta, \\phi)$ 上的张量积网格。\n    *   **纬度网格**：对 $\\mu \\in [-1, 1]$ 上的积分使用高斯-勒让德求积法。对于给定的点数 $N_\\theta$，我们得到一组节点 $\\{\\mu_i\\}$ 和权重 $\\{w_i\\}$。余纬度节点则为 $\\theta_i = \\arccos(\\mu_i)$。\n    *   **经度网格**：对 $\\phi \\in [0, 2\\pi)$ 上的积分使用均匀网格。对于 $N_\\phi$ 个点，节点为 $\\phi_j = 2\\pi j / N_\\phi$，$j \\in \\{0, 1, \\dots, N_\\phi-1\\}$。对于周期性域上的梯形法则，其积分权重是均匀的：$\\Delta\\phi = 2\\pi/N_\\phi$。\n\n4.  **场合成**：通过使用生成的系数对球谐级数求和，在 $(\\theta_i, \\phi_j)$ 网格的每个点上合成函数 $f(\\theta_i, \\phi_j)$：\n    $$\n    f(\\theta_i, \\phi_j) = \\sum_{l=0}^{L}\\sum_{m=-l}^{l} f_{lm}\\,Y_{l}^{m}(\\theta_i, \\phi_j)\n    $$\n    这通过在整个网格上为每个 $(l, m)$ 计算 `scipy.special` 中的 `sph_harm` 函数并执行加权求和来实现。\n\n5.  **数值积分**：帕塞瓦尔恒等式的左边，记为 $S_{numeric}$，通过指定的求积和来近似：\n    $$\n    S_{numeric} = \\sum_{i=0}^{N_{\\theta}-1} \\sum_{j=0}^{N_{\\phi}-1} |f(\\theta_i, \\phi_j)|^2 \\, w_i \\, \\Delta\\phi\n    $$\n    具有 $N_\\theta$ 个点的高斯-勒让德求积法则对于次数最高为 $2N_\\theta-1$ 的多项式是精确的。具有 $N_\\phi$ 个点的梯形法则对于波数最高为 $N_\\phi-1$ 的三角多项式是精确的。函数 $|f|^2$ 的球谐展开最大阶数为 $2L$。为使求积在理论上精确，我们需要 $2N_\\theta - 1 \\ge 2L$ 和 $N_\\phi > 2L$。选择这些测试用例是为了探究在不同采样条件下的精度。\n\n6.  **相对误差**：最后，计算数值积分与解析和之间的相对误差 $\\varepsilon$ 以量化数值验证的准确性：\n    $$\n    \\varepsilon = \\frac{| S_{numeric} - S_{analytic} |}{S_{analytic}}\n    $$\n    一个小的相对误差（接近机器精度）表明验证成功，既证实了帕塞瓦尔恒等式的正确性，也证实了数值实现的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm\nfrom numpy.polynomial.legendre import leggauss\n\ndef calculate_relative_error(L, N_theta, N_phi, is_real, seed):\n    \"\"\"\n    Calculates the relative error for Parseval's identity validation.\n\n    Args:\n        L (int): Maximum spherical harmonic degree.\n        N_theta (int): Number of latitudinal grid points (Gauss-Legendre nodes).\n        N_phi (int): Number of longitudinal grid points (uniform).\n        is_real (bool): True for a real-valued field, False for complex.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: The computed relative error.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # 1. Generate spherical harmonic coefficients\n    flm = {}\n    if is_real:\n        # Enforce f_l,-m = (-1)^m * f_lm* for real fields\n        for l in range(L + 1):\n            # m = 0 case (must be real)\n            flm[(l, 0)] = rng.uniform(-1, 1)\n            # m > 0 cases\n            for m in range(1, l + 1):\n                c = rng.uniform(-1, 1) + 1j * rng.uniform(-1, 1)\n                flm[(l, m)] = c\n                flm[(l, -m)] = ((-1)**m) * np.conj(c)\n    else:\n        # Complex field, no symmetry required\n        for l in range(L + 1):\n            for m in range(-l, l + 1):\n                flm[(l, m)] = rng.uniform(-1, 1) + 1j * rng.uniform(-1, 1)\n\n    # 2. Calculate the analytic sum of squared coefficients\n    analytic_sum = sum(np.abs(c)**2 for c in flm.values())\n    if analytic_sum == 0:\n        return 0.0\n\n    # 3. Set up the spatial grid and quadrature weights\n    # Latitudinal grid (Gauss-Legendre)\n    mu, w = leggauss(N_theta)  # mu are nodes in [-1, 1], w are weights\n    theta = np.arccos(mu)      # theta is in [0, pi]\n\n    # Longitudinal grid (uniform trapezoidal)\n    d_phi = 2 * np.pi / N_phi\n    phi = np.arange(N_phi) * d_phi # phi is in [0, 2pi)\n\n    # Create 2D meshgrids for vectorized calculations\n    phi_grid, theta_grid = np.meshgrid(phi, theta)\n\n    # 4. Synthesize the field f(theta, phi) on the grid\n    f_grid = np.zeros((N_theta, N_phi), dtype=np.complex128)\n    for l in range(L + 1):\n        for m in range(-l, l + 1):\n            # Scipy's sph_harm is Y_l^m(theta, phi) but args are (m, l, phi, theta)\n            Ylm_grid = sph_harm(m, l, phi_grid, theta_grid)\n            f_grid += flm[(l, m)] * Ylm_grid\n\n    # 5. Compute the numerical integral over the sphere\n    integrand = np.abs(f_grid)**2\n    # w needs to be broadcast from (N_theta,) to (N_theta, N_phi)\n    # The integral element is w_i * d_phi\n    numerical_integral = np.sum(integrand * w[:, np.newaxis] * d_phi)\n\n    # 6. Calculate the final relative error\n    relative_error = np.abs(numerical_integral - analytic_sum) / analytic_sum\n    \n    return relative_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (L, N_theta, N_phi, is_real, seed)\n    test_cases = [\n        (0, 8, 16, True, 42),\n        (3, 40, 80, False, 7),\n        (10, 64, 128, False, 123),\n        (12, 80, 160, True, 9001),\n        (20, 41, 41, False, 2023)\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N_theta, N_phi, is_real, seed = case\n        error = calculate_relative_error(L, N_theta, N_phi, is_real, seed)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3615105"}, {"introduction": "在谱表示的基础上，本练习将探索一个经典的地球物理应用：位场（如重力场）的向上延拓。这个实践展示了球谐函数如何简化复杂的物理问题，将空间中的微分方程转换为谱域中的代数缩放 [@problem_id:3615149]。你将推导这个缩放定律，并研究向上延拓如何充当一个天然的低通滤波器，这是地球物理信号处理中的一个核心概念。", "problem": "考虑一个球体上全局定义的外部势场，例如，它代表一个行星体外部的引力势。设参考球体的半径为 $a$（单位：$\\mathrm{m}$）。在球体外部，势 $V$ 在球坐标系下满足拉普拉斯方程 $\\nabla^2 V = 0$。用一个在最大阶数 $L$ 处截断的球谐级数来表示半径为 $r$ 的球面上的势 $V$，其标量系数按阶数 $l$ 和次数 $m$ 索引。假设在 $r=a$ 处的系数被附加的、零均值的、不相关的噪声所污染，该噪声在所有阶数和次数上是各向同性的，具有不依赖于 $l$ 或 $m$ 的共同方差 $\\sigma^2$。\n\n从外部势场满足 $\\nabla^2 V = 0$ 且由球坐标系中变量分离法产生的球谐函数表示这一基本出发点，推导球谐系数在从半径 $r=a$ 向上延拓至半径 $r=a+h$（其中 $h>0$，单位：$\\mathrm{m}$）时的径向尺度变化行为。利用此径向尺度变化关系，定义一个向上延拓算子，该算子将 $r=a$ 处的系数向量映射到 $r=a+h$ 处的系数向量。根据其谱范数分析该算子的稳定性，并解释在何种条件下向上延拓具有噪声抑制作用。\n\n为探究带宽限制 $L$ 如何控制噪声抑制，定义各向同性不相关系数噪声的均方根（RMS）衰减因子 $R(a,h,L)$，其值为向上延拓至 $r=a+h$ 后的系数向量的 RMS 与 $r=a$ 处系数向量的 RMS 之比，两者均在最大阶数 $L$ 处截断。假设噪声在 $(l,m)$ 上是各向同性的，具有共同方差 $\\sigma^2$，请用 $a$、$h$ 和 $L$ 表示 $R(a,h,L)$，并使用每个阶数对应的次数数量来恰当地加权来自每个 $l$ 的贡献。\n\n您的程序必须实现所推导的向上延拓算子，并为每个测试用例计算两个输出：\n- 均方根衰减因子 $R(a,h,L)$，为一个浮点数。\n- 一个布尔标志 $S(a,h)$，用于指示稳定性。如果向上延拓算子的谱范数严格小于 $1$，则定义为 $S(a,h)=\\mathrm{True}$，否则为 $S(a,h)=\\mathrm{False}$。\n\n使用以下测试套件，所有距离单位均为 $\\mathrm{m}$，角度信息非必需（不应用角度单位）：\n1. 情况 A: $a=6.371\\times 10^6$, $h=1.0\\times 10^5$, $L=60$。\n2. 情况 B: $a=6.371\\times 10^6$, $h=0$, $L=60$。\n3. 情况 C: $a=6.371\\times 10^6$, $h=1.0\\times 10^5$, $L=0$。\n4. 情况 D: $a=6.371\\times 10^6$, $h=5.0\\times 10^5$, $L=180$。\n5. 情况 E: $a=6.371\\times 10^6$, $h=1.0\\times 10^5$, $L=180$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。此列表中的每个元素必须对应一个测试用例，并且本身是一个形式为 $[R,S]$ 的双元素列表，其中 $R$ 是一个浮点数，$S$ 是一个布尔值。例如，输出应类似于 $[[R_1,S_1],[R_2,S_2],\\ldots,[R_5,S_5]]$，其中的数值是为指定的测试套件计算得出的。", "solution": "该问题经评估有效，因为它在科学上基于势场理论，在数学上是适定的，并且为获得唯一解提供了所有必要的参数。\n\n主要任务是分析由球谐级数表示的外部势场从半径为 $a$ 的参考球体向上延拓至半径为 $r = a+h$（其中 $h \\ge 0$）的球体的过程。\n\n首先，我们确定球谐系数的径向依赖关系。势场 $V$ 是外部的，并满足拉普拉斯方程 $\\nabla^2 V = 0$。通过变量分离法在球坐标 $(r, \\theta, \\phi)$ 中得到的拉普拉斯方程的通解为：\n$$\nV(r, \\theta, \\phi) = \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} \\left( A_{lm} r^l + B_{lm} r^{-(l+1)} \\right) Y_{lm}(\\theta, \\phi)\n$$\n其中 $Y_{lm}(\\theta, \\phi)$ 是阶为 $l$ 次为 $m$ 的球谐基函数。对于外部势，场必须在无穷远处消失，即当 $r \\to \\infty$ 时，$V \\to 0$。这一物理约束要求项 $r^l$（随 $r$ 增长）的所有系数 $A_{lm}$ 必须为零。因此，解简化为：\n$$\nV(r, \\theta, \\phi) = \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} B_{lm} r^{-(l+1)} Y_{lm}(\\theta, \\phi)\n$$\n势 $V$ 在特定半径 $r$ 处的球谐系数是函数 $C_{lm}(r)$，使得 $V(r, \\theta, \\phi) = \\sum_{l,m} C_{lm}(r) Y_{lm}(\\theta, \\phi)$。将其与解的形式进行比较，我们确定：\n$$\nC_{lm}(r) = B_{lm} r^{-(l+1)}\n$$\n常数 $B_{lm}$ 与半径无关，可以由参考半径 $a$ 处的系数确定：\n$$\nC_{lm}(a) = B_{lm} a^{-(l+1)} \\implies B_{lm} = C_{lm}(a) a^{l+1}\n$$\n将其代回，我们得到半径 $r=a+h$ 处的系数 $C_{lm}(a+h)$：\n$$\nC_{lm}(a+h) = B_{lm} (a+h)^{-(l+1)} = \\left( C_{lm}(a) a^{l+1} \\right) (a+h)^{-(l+1)}\n$$\n这就得出了外部势场系数的基本径向尺度变换定律：\n$$\nC_{lm}(a+h) = C_{lm}(a) \\left(\\frac{a}{a+h}\\right)^{l+1}\n$$\n\n接下来，我们定义向上延拓算子并分析其稳定性。设 $\\mathbf{c}(r)$ 是所有系数 $\\{C_{lm}(r)\\}$（其中 $l \\in [0, L]$ 且 $m \\in [-l, l]$）组成的列向量。从 $r=a$ 到 $r=a+h$ 的向上延拓是一个线性算子 $\\mathcal{U}$，使得 $\\mathbf{c}(a+h) = \\mathcal{U} \\mathbf{c}(a)$。根据尺度变换定律，该算子在球谐基中表现为一个对角矩阵，其中每个系数 $C_{lm}(a)$ 乘以一个仅依赖于阶数 $l$ 的因子：\n$$\n\\lambda_l = \\left(\\frac{a}{a+h}\\right)^{l+1}\n$$\n对角算子的谱范数是其对角元素绝对值的最大值。我们必须在阶数范围 $l \\in [0, L]$ 内找到 $|\\lambda_l|$ 的最大值。\n$$\n\\|\\mathcal{U}\\|_2 = \\max_{l \\in \\{0, 1, \\dots, L\\}} \\left| \\left(\\frac{a}{a+h}\\right)^{l+1} \\right|\n$$\n由于 $a > 0$ 且 $h \\ge 0$，比率 $q = a/(a+h)$ 位于区间 $(0, 1]$ 内。指数 $l+1$ 总是正的。因此，所有 $\\lambda_l$ 都是正的，我们可以去掉绝对值符号。对于 $q \\in (0, 1]$，函数 $f(l) = q^{l+1}$ 是关于 $l$ 的非增函数。因此，最大值在最低阶数 $l=0$ 时达到：\n$$\n\\|\\mathcal{U}\\|_2 = \\left(\\frac{a}{a+h}\\right)^{0+1} = \\frac{a}{a+h}\n$$\n如果此谱范数严格小于 $1$，则稳定性标志 $S(a,h)$ 定义为 $\\mathrm{True}$。\n$$\nS(a,h) \\equiv ( \\|\\mathcal{U}\\|_2  1 ) \\iff \\frac{a}{a+h}  1\n$$\n由于 $a$ 是一个正半径，此不等式成立当且仅当 $a  a+h$，即 $h > 0$。因此，如果 $h > 0$，则 $S(a,h) = \\mathrm{True}$；如果 $h \\le 0$，则为 $\\mathrm{False}$。在同样条件下（$h0$），向上延拓具有噪声抑制作用，因为对于所有阶数 $l$，尺度因子 $\\lambda_l = (a/(a+h))^{l+1} \\le (a/(a+h))  1$。通常由噪声主导的高阶系数比低阶信号分量衰减得更强烈，从而降低了总噪声功率。\n\n最后，我们推导均方根衰减因子 $R(a,h,L)$。问题将 $r=a$ 处系数 $C_{lm}(a)$ 上的噪声定义为附加的、零均值的、不相关的和各向同性的，对所有 $(l,m)$ 都有共同的方差 $\\sigma^2$。在给定半径处、于阶数 $L$ 截断的系数向量的均方根（RMS）是系数平方的平均值的平方根，该平均值按每个阶数的次数数量加权。直到阶数 $L$ 的总系数数量为 $N(L) = \\sum_{l=0}^{L} (2l+1) = (L+1)^2$。\n\n在 $r=a$ 处噪声的均方值为：\n$$\n\\text{MS}_{noise}(a) = \\frac{1}{N(L)} \\sum_{l=0}^{L} \\sum_{m=-l}^{l} E[C_{lm}(a)^2] = \\frac{1}{(L+1)^2} \\sum_{l=0}^{L} (2l+1) \\sigma^2 = \\frac{\\sigma^2}{(L+1)^2} (L+1)^2 = \\sigma^2\n$$\n因此，在 $r=a$ 处的 RMS 为 $\\text{RMS}_{noise}(a) = \\sqrt{\\sigma^2} = \\sigma$。\n\n在半径 $r=a+h$ 处，延拓后的系数为 $C_{lm}(a+h) = \\lambda_l C_{lm}(a)$。方差转换为 $E[C_{lm}(a+h)^2] = \\lambda_l^2 E[C_{lm}(a)^2] = \\lambda_l^2 \\sigma^2$。在 $r=a+h$ 处噪声的均方值为：\n$$\n\\text{MS}_{noise}(a+h) = \\frac{1}{(L+1)^2} \\sum_{l=0}^{L} \\sum_{m=-l}^{l} E[C_{lm}(a+h)^2] = \\frac{\\sigma^2}{(L+1)^2} \\sum_{l=0}^{L} (2l+1) \\lambda_l^2\n$$\n在 $r=a+h$ 处的 RMS 为 $\\text{RMS}_{noise}(a+h) = \\sqrt{\\text{MS}_{noise}(a+h)}$。RMS 衰减因子 $R(a,h,L)$ 是比率：\n$$\nR(a,h,L) = \\frac{\\text{RMS}_{noise}(a+h)}{\\text{RMS}_{noise}(a)} = \\frac{\\frac{\\sigma}{L+1} \\sqrt{\\sum_{l=0}^{L} (2l+1) \\lambda_l^2}}{\\sigma} = \\frac{1}{L+1} \\sqrt{\\sum_{l=0}^{L} (2l+1) \\lambda_l^2}\n$$\n代入 $\\lambda_l = (a/(a+h))^{l+1}$，我们得到用于实现的最终表达式：\n$$\nR(a,h,L) = \\frac{1}{L+1} \\sqrt{ \\sum_{l=0}^{L} (2l+1) \\left( \\frac{a}{a+h} \\right)^{2(l+1)} }\n$$\n该公式计算 RMS 衰减因子，而稳定性标志计算为 $S(a,h) = (h0)$。这两是每个测试用例需要计算的两个量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the geophysical problem of upward continuation noise attenuation.\n\n    This function processes a suite of test cases, each defined by a reference radius 'a',\n    an upward continuation height 'h', and a spherical harmonic truncation degree 'L'.\n    For each case, it calculates:\n    1. R(a, h, L): The Root Mean Square (RMS) attenuation factor for isotropic,\n       uncorrelated noise on spherical harmonic coefficients.\n    2. S(a, h): A boolean stability flag, True if the upward continuation operator\n       is strictly contractive (spectral norm  1), False otherwise.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (a, h, L) with distances in meters.\n    test_cases = [\n        (6.371e6, 1.0e5, 60),   # Case A\n        (6.371e6, 0.0, 60),    # Case B\n        (6.371e6, 1.0e5, 0),    # Case C\n        (6.371e6, 5.0e5, 180),  # Case D\n        (6.371e6, 1.0e5, 180),  # Case E\n    ]\n\n    results = []\n\n    for a, h, L in test_cases:\n        # 1. Calculate the stability flag S(a, h)\n        # The spectral norm of the upward continuation operator is a/(a+h).\n        # The operator is strictly contractive (norm  1) if and only if h > 0.\n        is_stable = h > 0\n\n        # 2. Calculate the RMS attenuation factor R(a, h, L)\n        # R = (1/(L+1)) * sqrt( sum_{l=0 to L} (2l+1) * (a/(a+h))^(2(l+1)) )\n        \n        # Handle the edge case h=0. The ratio a/(a+h) becomes 1.\n        # The sum becomes sum_{l=0 to L} (2l+1) = (L+1)^2.\n        # So R = (1/(L+1)) * sqrt((L+1)^2) = 1.\n        if h == 0:\n            rms_attenuation = 1.0\n        else:\n            # The base of the power term in the sum\n            q = a / (a + h)\n            \n            # The degree range [0, 1, ..., L]\n            l_values = np.arange(L + 1)\n            \n            # Calculate each term in the summation: (2l+1) * q^(2(l+1))\n            # We can write q^(2(l+1)) as (q^2)^(l+1) for numerical stability.\n            q_sq = q * q\n            terms = (2 * l_values + 1) * np.power(q_sq, l_values + 1)\n            \n            # Sum the terms\n            sum_of_terms = np.sum(terms)\n            \n            # Calculate the final RMS attenuation factor\n            rms_attenuation = np.sqrt(sum_of_terms) / (L + 1)\n        \n        results.append([rms_attenuation, is_stable])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is desired.\n    # Example: '[[R1, S1], [R2, S2]]'\n    # We join string representations of the inner lists.\n    # e.g., str([0.123, True]) -> '[0.123, True]'\n    output_str = \",\".join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "3615149"}, {"introduction": "这项高级实践旨在解决旋转球谐函数表示的场的关键任务，这是转换参考系（例如，从地理坐标系到地磁坐标系）等操作所必需的。你将使用维格纳D矩阵（Wigner D-matrices）实现旋转，深入探究群论与球谐函数之间的深刻联系 [@problem_id:3615165]。通过验证阶次功率等关键不变量，你将巩固对这些基本基函数旋转性质的理解。", "problem": "考虑单位球面上的一个实值标量场，该场以球谐函数表示。设正交归一的复球谐函数定义为 $Y_l^m(\\theta,\\phi)$，其中整数阶 $l \\ge 0$，整数级 $-l \\le m \\le l$，采用常规的 Condon-Shortley 相位约定和球面上的正交归一性。一个实值场可以用实基下的系数 $C_{lm}$ 和 $S_{lm}$（其中 $m \\ge 0$）来表示，其展开式可写为实球谐函数 $Y_{lm}^{c}(\\theta,\\phi)$ 和 $Y_{lm}^{s}(\\theta,\\phi)$ 的线性组合，这些实球谐函数由复基构建。与 $Y_l^m(\\theta,\\phi)$ 相关的相应复球谐系数 $a_{lm}$ 满足实数约束 $a_{l,-m} = (-1)^m a_{lm}^\\*$，并遵循以下针对 $m \\ge 0$ 的基关系定义：\n- 对于 $m=0$：$a_{l0} = C_{l0}$。\n- 对于 $m0$：$a_{lm} = \\frac{C_{lm} - i\\,S_{lm}}{\\sqrt{2}}$ 且 $a_{l,-m} = \\frac{(-1)^m\\left(C_{lm} + i\\,S_{lm}\\right)}{\\sqrt{2}}$。\n这些定义明确地固定了实系数相对于正交归一复球谐函数基的归一化方式。\n\n三维空间中的刚体旋转属于三维特殊正交群 (SO(3))。这样一个旋转，在 $z$-$y$-$z$ 约定下由欧拉角 $(\\alpha,\\beta,\\gamma)$（角度以弧度为单位）参数化，通过 Wigner 旋转矩阵 $D^l_{mm'}(\\alpha,\\beta,\\gamma)$ 作用于固定阶 $l$ 的球谐函数子空间，产生旋转后的复系数 $a'_{lm} = \\sum_{m'=-l}^{l} D^l_{mm'}(\\alpha,\\beta,\\gamma)\\,a_{lm'}$。旋转保持每一阶的总功率不变，并且单位元和逆复合性质对系数的这种线性作用成立。\n\n您的任务是实现一个完整的程序，该程序：\n1. 从 SO(3) 的表示论第一性原理出发，为所有阶 $l$ 直到指定的最高阶 $L_{\\mathrm{max}}$ 构建 Wigner 旋转矩阵 $D^l_{mm'}(\\alpha,\\beta,\\gamma)$。使用欧拉角的标准 $z$-$y$-$z$ 约定，以及将 Wigner 小 $d$ 矩阵 $d^l_{mm'}(\\beta)$ 作为 $D^l_{mm'}$ 的实数核心的标准定义。\n2. 将给定的实球谐系数 $(C_{lm}, S_{lm})$ 转换为复系数 $a_{lm}$，通过 $D^l_{mm'}(\\alpha,\\beta,\\gamma)$ 应用旋转，并与相同的归一化方式一致地将结果转换回旋转后的实系数 $(C'_{lm}, S'_{lm})$。\n3. 使用复数和实数两种表示方法，计算旋转前后的阶功率 $P_l$。对于复数表示，使用 $P_l = \\sum_{m=-l}^{l} \\lvert a_{lm} \\rvert^2$。对于实数表示，使用 $P_l = C_{l0}^2 + \\sum_{m=1}^{l} \\left(C_{lm}^2 + S_{lm}^2\\right)$。这两种表达式之间的一致性是在相同归一化选择下的验证的一部分。\n\n您必须为一组指定的测试用例测试以下不变量和性质，所有角度均以弧度为单位：\n- 旋转下的阶功率不变性：对于每一阶 $l$，验证旋转后 $P_l$ 保持不变，误差在您选择并说明理由的数值容差范围内。\n- 单位旋转：使用 $(\\alpha,\\beta,\\gamma)=(0,0,0)$ 进行旋转，所有 $l$ 和 $m$ 的 $(C_{lm},S_{lm})$ 保持不变。\n- 逆旋转：通过 $(\\alpha,\\beta,\\gamma)$ 旋转，然后进行逆旋转，可以恢复所有 $l$ 和 $m$ 的原始系数。在 $z$-$y$-$z$ 约定中，逆旋转对应于 $(-\\gamma,-\\beta,-\\alpha)$。\n\n实现您的程序以运行以下测试套件。对于每个案例，使用指定的最高阶 $L_{\\mathrm{max}}$、系数规格和欧拉角 $(\\alpha,\\beta,\\gamma)$（以弧度为单位）。当系数规格为“随机”时，使用给定的种子从一个可复现的伪随机数生成器生成 $m \\ge 1$ 的 $C_{lm}$ 和 $S_{lm}$，并设置 $S_{l0}=0$；对于 $m=0$，类似地生成 $C_{l0}$。当系数规格为“单一”时，除指定的系数外，将所有其他系数设为零。使用与上述定义一致的正交归一化，并确保您实现的 Wigner 矩阵具有数值稳定性。\n- 案例 1 (常规路径)：$L_{\\mathrm{max}}=5$，随机系数，种子为 $42$，$(\\alpha,\\beta,\\gamma)=(0.7,0.3,1.1)$。\n- 案例 2 (边界情况：无倾斜)：$L_{\\mathrm{max}}=6$，随机系数，种子为 $123$，$(\\alpha,\\beta,\\gamma)=(2.0,0.0,-1.2)$。\n- 案例 3 (边缘情况：仅偶极子)：$L_{\\mathrm{max}}=1$，随机系数，种子为 $7$，$(\\alpha,\\beta,\\gamma)=(1.3,0.9,-0.2)$。\n- 案例 4 (边缘情况：仅单极子)：$L_{\\mathrm{max}}=0$，随机系数，种子为 $0$，$(\\alpha,\\beta,\\gamma)=(0.5,2.7,-2.2)$。\n- 案例 5 (结构化单系数)：$L_{\\mathrm{max}}=3$，只有 $C_{2,1}=1.0$ 非零，所有其他 $C_{lm}$ 和 $S_{lm}$ 等于 $0$，$(\\alpha,\\beta,\\gamma)=(0.3,1.0,0.6)$。\n\n对于每个测试用例，评估三个布尔结果：\n- 在所有阶 $l \\in \\{0,\\dots,L_{\\mathrm{max}}\\}$ 上的功率不变性。\n- 单位旋转保持系数不变。\n- 逆旋转恢复原始系数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容按顺序为案例 1 的三个布尔值，接着是案例 2，...，直到案例 5。例如，输出格式必须完全像 $[b_1,b_2,b_3,b_4,b_5,b_6,b_7,b_8,b_9,b_{10},b_{11},b_{12},b_{13},b_{14},b_{15}]$，其中每个 $b_k$ 是布尔字面量 $\\mathrm{True}$ 或 $\\mathrm{False}$。", "solution": "用户的请求是验证并解决一个关于球面上实值标量场旋转的计算问题，该场由球谐系数表示。\n\n该问题被确定为有效的。它在科学上是合理的，定义明确，并且所有必要的定义、约定和测试用例都得到了完整和一致的说明。该问题植根于旋转群 SO(3) 的标准表示论及其在球谐函数上的应用，这是计算地球物理学和量子力学的基石。所提供的实球谐系数和复球谐系数之间的关系，以及阶功率的定义，都是一致和标准的。\n\n解决方案将按以下步骤进行：\n1.  **Wigner D 矩阵的实现**：SO(3) 中的一个旋转由 $z$-$y$-$z$ 约定下的三个欧拉角 $(\\alpha, \\beta, \\gamma)$ 参数化。它对阶为 $l$ 的球谐系数的作用由 $(2l+1) \\times (2l+1)$ 的 Wigner D 矩阵 $D^l(\\alpha, \\beta, \\gamma)$ 描述。该矩阵可以分解为：\n    $$\n    D^l_{mm'}(\\alpha, \\beta, \\gamma) = e^{-im\\alpha} d^l_{mm'}(\\beta) e^{-im'\\gamma}\n    $$\n    其中，$d^l(\\beta)$ 是 Wigner 小 d 矩阵，代表绕 y 轴的旋转，而 $m, m'$ 是从 $-l$ 到 $l$ 的整数级。\n\n    实现的核心是构建 $d^l(\\beta)$。“第一性原理”要求使用李群（如 SO(3)）与其李代数之间的基本关系。绕 y 轴旋转角度 $\\beta$ 的旋转算子由相应生成元 $\\hat{J}_y$ 的指数给出：\n    $$\n    \\hat{R}_y(\\beta) = e^{-i\\beta \\hat{J}_y}\n    $$\n    Wigner 小 d 矩阵是此算子在球谐函数基 $|l,m\\rangle$ 中的矩阵表示：\n    $$\n    d^l_{m'm}(\\beta) = \\langle l, m' | e^{-i\\beta \\hat{J}_y} | l, m \\rangle = \\left[ \\exp(-i\\beta J_y^{(l)}) \\right]_{m'm}\n    $$\n    其中 $J_y^{(l)}$ 是算子 $\\hat{J}_y$ 在阶 $l$ 下的矩阵表示。该矩阵的元素在量子力学中是已知的：\n    $$\n    [J_y^{(l)}]_{m',m} = \\langle l, m' | \\hat{J}_y | l, m \\rangle = \\frac{1}{2i} \\left( \\sqrt{(l-m)(l+m+1)}\\delta_{m',m+1} - \\sqrt{(l+m)(l-m+1)}\\delta_{m',m-1} \\right)\n    $$\n    我们将为每个阶 $l$ 构建 $(2l+1) \\times (2l+1)$ 的矩阵 $J_y^{(l)}$，然后使用数值稳定的矩阵指数函数 `scipy.linalg.expm` 来计算 $d^l(\\beta)$。矩阵 $-i\\beta J_y^{(l)}$ 是实反对称矩阵，确保了得到的 $d^l(\\beta)$ 是实正交矩阵，符合要求。\n\n2.  **系数的旋转**：复系数向量 $a_l = \\{a_{lm}\\}_{m=-l}^l$ 的旋转通过 $a'_l = D^l a_l$ 完成。为提高计算效率，这分三步实现：\n    a. 绕 z 轴旋转 $\\gamma$：$a^{(1)}_{lm'} = a_{lm'} e^{-im'\\gamma}$。\n    b. 绕 y 轴旋转 $\\beta$：$a^{(2)}_{lm} = \\sum_{m'} d^l_{mm'} a^{(1)}_{lm'}$。\n    c. 绕 z 轴旋转 $\\alpha$：$a'_{lm} = a^{(2)}_{lm} e^{-im\\alpha}$。\n\n3.  **系数基的转换**：问题提供了实系数 $(C_{lm}, S_{lm})$。在旋转前，必须将它们转换为复系数 $a_{lm}$，并在旋转后转换回实基。指定的变换如下：\n    - **实数到复数**：\n      对于 $m=0$：$a_{l0} = C_{l0}$。\n      对于 $m0$：$a_{lm} = \\frac{1}{\\sqrt{2}}(C_{lm} - iS_{lm})$ 和 $a_{l,-m} = \\frac{(-1)^m}{\\sqrt{2}}(C_{lm} + iS_{lm})$。\n    - **复数到实数**：这些关系可以通过对上述关系求逆得到。\n      对于 $m=0$：$C'_{l0} = \\text{Re}(a'_{l0})$。\n      对于 $m0$：$C'_{lm} = \\sqrt{2} \\text{Re}(a'_{lm})$ 和 $S'_{lm} = -\\sqrt{2} \\text{Im}(a'_{lm})$。\n    如果旋转后的复系数满足 $a'_{l,-m} = (-1)^m (a'_{lm})^*$，旋转场的实数性质得以保持。我们的物理旋转保证了这一点。\n\n4.  **不变量的验证**：对于每个测试用例，将验证三个性质。\n    - **功率不变性**：在旋转前后，为每个阶 $l$ 计算阶功率 $P_l = C_{l0}^2 + \\sum_{m=1}^{l} (C_{lm}^2 + S_{lm}^2)$。使用 `numpy.isclose` 对比结果，以考虑浮点不精确性。选择 `rtol=1e-9`, `atol=1e-12` 的容差，这对于期望理论上相等的双精度计算是合适的。\n    - **单位旋转**：用欧拉角 $(\\alpha,\\beta,\\gamma)=(0,0,0)$ 旋转系数。所得系数必须与原始系数相同，使用 `numpy.allclose` 进行检查。\n    - **逆旋转**：系数先由 $(\\alpha,\\beta,\\gamma)$ 旋转，然后结果再由逆旋转角度 $(-\\gamma,-\\beta,-\\alpha)$ 旋转。最终系数必须与原始系数相同，使用 `numpy.allclose` 进行检查。\n\n整个过程将通过一个 Python 脚本实现。该脚本定义了用于生成系数、构建旋转矩阵、应用旋转以及为每个指定测试用例执行不变量检查的函数。这些检查的布尔结果将被收集并以指定格式打印。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for spherical harmonic rotations.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: happy path\n        {'L_max': 5, 'coeffs': {'type': 'random', 'seed': 42}, 'angles': (0.7, 0.3, 1.1)},\n        # Case 2: boundary (no tilt)\n        {'L_max': 6, 'coeffs': {'type': 'random', 'seed': 123}, 'angles': (2.0, 0.0, -1.2)},\n        # Case 3: edge (dipole only)\n        {'L_max': 1, 'coeffs': {'type': 'random', 'seed': 7}, 'angles': (1.3, 0.9, -0.2)},\n        # Case 4: edge (monopole only)\n        {'L_max': 0, 'coeffs': {'type': 'random', 'seed': 0}, 'angles': (0.5, 2.7, -2.2)},\n        # Case 5: structured single-coefficient\n        {'L_max': 3, 'coeffs': {'type': 'single', 'l': 2, 'm': 1, 'kind': 'C', 'val': 1.0}, 'angles': (0.3, 1.0, 0.6)},\n    ]\n\n    # Numerical tolerance for floating-point comparisons.\n    # Justification: These values are standard for double-precision floating-point\n    # arithmetic where theoretical equality is expected, accounting for accumulated\n    # errors from multiple operations including matrix exponentiation.\n    RTOL = 1e-9\n    ATOL = 1e-12\n\n    def generate_coefficients(spec, L_max):\n        \"\"\"Generates spherical harmonic coefficients based on the specification.\"\"\"\n        coeffs = {l: {'C': {0: 0.0}, 'S': {0: 0.0}} for l in range(L_max + 1)}\n        if spec['type'] == 'random':\n            rng = np.random.default_rng(spec['seed'])\n            for l in range(L_max + 1):\n                coeffs[l]['C'][0] = rng.random()\n                for m in range(1, l + 1):\n                    coeffs[l]['C'][m] = rng.random()\n                    coeffs[l]['S'][m] = rng.random()\n        elif spec['type'] == 'single':\n            l, m, kind, val = spec['l'], spec['m'], spec['kind'], spec['val']\n            if l = L_max:\n                if m == 0 and kind == 'S':\n                    # S_l0 is always 0 for real fields\n                    pass\n                else:\n                    coeffs[l][kind][m] = val\n        return coeffs\n\n    def get_d_matrix(l: int, beta: float) - np.ndarray:\n        \"\"\"\n        Computes the Wigner small-d matrix d^l(beta) by exponentiating\n        the generator of rotations J_y.\n        \"\"\"\n        if l == 0:\n            return np.array([[1.0]])\n\n        dim = 2 * l + 1\n        # Index mapping: k = l + m\n        # Matrix element [J_y]_{k_m', k_m}\n        Jy = np.zeros((dim, dim), dtype=complex)\n\n        for k_m in range(dim):\n            m = k_m - l\n            # Element at (m'+1, m) - (k_m+1, k_m)\n            if m  l:\n                k_mp1 = k_m + 1\n                val = np.sqrt((l - m) * (l + m + 1))\n                Jy[k_mp1, k_m] = 0.5j * val\n            # Element at (m'-1, m) - (k_m-1, k_m)\n            if m > -l:\n                k_mm1 = k_m - 1\n                val = np.sqrt((l + m) * (l - m + 1))\n                Jy[k_mm1, k_m] = -0.5j * val\n        \n        # d^l(beta) = exp(-i * beta * J_y). The matrix -i * J_y is real,\n        # so the result of expm is real.\n        d_mat = expm(-1j * beta * Jy)\n        return d_mat.real\n\n    def rotate_coefficients(coeffs, L_max, alpha, beta, gamma):\n        \"\"\"\n        Performs a full z-y-z rotation on a set of SH coefficients.\n        \"\"\"\n        rotated_coeffs = {l: {'C': {}, 'S': {}} for l in range(L_max + 1)}\n\n        for l in range(L_max + 1):\n            dim = 2 * l + 1\n            # 1. Convert real coefficients to complex\n            a = np.zeros(dim, dtype=complex)\n            a[l] = coeffs[l]['C'].get(0, 0.0)\n            for m in range(1, l + 1):\n                C_lm = coeffs[l]['C'].get(m, 0.0)\n                S_lm = coeffs[l]['S'].get(m, 0.0)\n                a[l + m] = (C_lm - 1j * S_lm) / np.sqrt(2)\n                a[l - m] = ((-1)**m * (C_lm + 1j * S_lm)) / np.sqrt(2)\n\n            # 2. Apply rotation\n            d_matrix = get_d_matrix(l, beta)\n            m_array = np.arange(-l, l + 1)\n            \n            # Step 1: z-rotation by gamma\n            a_1 = a * np.exp(-1j * m_array * gamma)\n            # Step 2: y-rotation by beta\n            a_2 = d_matrix @ a_1\n            # Step 3: z-rotation by alpha\n            a_prime = a_2 * np.exp(-1j * m_array * alpha)\n\n            # 3. Convert complex coefficients back to real\n            rotated_coeffs[l]['C'][0] = a_prime[l].real\n            rotated_coeffs[l]['S'][0] = 0.0\n            for m in range(1, l + 1):\n                rotated_coeffs[l]['C'][m] = np.sqrt(2) * a_prime[l + m].real\n                rotated_coeffs[l]['S'][m] = -np.sqrt(2) * a_prime[l + m].imag\n        \n        return rotated_coeffs\n\n    def get_degree_power(coeffs, l):\n        \"\"\"Computes the power at a given degree l.\"\"\"\n        power = coeffs[l]['C'].get(0, 0.0) ** 2\n        for m in range(1, l + 1):\n            power += coeffs[l]['C'].get(m, 0.0) ** 2 + coeffs[l]['S'].get(m, 0.0) ** 2\n        return power\n\n    def are_coeffs_close(coeffs1, coeffs2, L_max):\n        \"\"\"Checks if two sets of coefficients are close.\"\"\"\n        for l in range(L_max + 1):\n            for m in range(l + 1):\n                if not np.isclose(coeffs1[l]['C'].get(m, 0.0), coeffs2[l]['C'].get(m, 0.0), rtol=RTOL, atol=ATOL):\n                    return False\n                if m > 0:\n                    if not np.isclose(coeffs1[l]['S'].get(m, 0.0), coeffs2[l]['S'].get(m, 0.0), rtol=RTOL, atol=ATOL):\n                        return False\n        return True\n\n    results = []\n    for case in test_cases:\n        L_max = case['L_max']\n        initial_coeffs = generate_coefficients(case['coeffs'], L_max)\n        alpha, beta, gamma = case['angles']\n\n        # --- Test 1: Power Invariance ---\n        rotated_coeffs = rotate_coefficients(initial_coeffs, L_max, alpha, beta, gamma)\n        power_ok = True\n        for l in range(L_max + 1):\n            power_before = get_degree_power(initial_coeffs, l)\n            power_after = get_degree_power(rotated_coeffs, l)\n            if not np.isclose(power_before, power_after, rtol=RTOL, atol=ATOL):\n                power_ok = False\n                break\n        results.append(power_ok)\n\n        # --- Test 2: Identity Rotation ---\n        id_coeffs = rotate_coefficients(initial_coeffs, L_max, 0.0, 0.0, 0.0)\n        identity_ok = are_coeffs_close(initial_coeffs, id_coeffs, L_max)\n        results.append(identity_ok)\n\n        # --- Test 3: Inverse Rotation ---\n        # Forward rotation is already computed in rotated_coeffs\n        inv_alpha, inv_beta, inv_gamma = -gamma, -beta, -alpha\n        recovered_coeffs = rotate_coefficients(rotated_coeffs, L_max, inv_alpha, inv_beta, inv_gamma)\n        inverse_ok = are_coeffs_close(initial_coeffs, recovered_coeffs, L_max)\n        results.append(inverse_ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3615165"}]}