{"hands_on_practices": [{"introduction": "有限差分法的核心在于其系数的选择，但我们无需记忆冗长的系数表。一种更基本、更强大的方法是通过泰勒级数展开系统地推导出这些系数。这个练习将指导你编写一个程序，将这一理论转化为一个实用工具，能够为任意阶多项式精确性的要求生成任意几何形状的差分格式。通过这个实践，你将掌握从第一性原理构建和验证二阶导数近似的方法，这对于精确模拟地球物理学中平滑的背景场至关重要。[@problem_id:3594272]", "problem": "构造一个程序，在一维均匀网格（间距为 $h$）上，为二阶导数 $\\partial_{xx} u$ 构建有限差分 (FD) 模板，该模板能精确微分最高为 $p$ 次的多项式。使用泰勒级数作为基本依据，推导模板权重为实现多项式精确性而必须满足的代数条件。您的程序必须：\n\n1. 从一个足够光滑的函数 $u(x)$ 在点 $x_0$ 附近的泰勒级数展开式出发，推导 FD 权重 $\\{\\alpha_i\\}_{i=0}^{p}$ 必须满足的矩条件，以使 FD 近似公式\n$$\n\\partial_{xx} u(x_0) \\approx \\frac{1}{h^2} \\sum_{i=0}^{p} \\alpha_i \\, u\\!\\left(x_0 + s_i h\\right)\n$$\n对所有次数最高为 $p$ 的多项式 $u(x)$ 都是精确的。其中 $\\{s_i\\}$ 是指定相对于 $x_0$ 的模板位置的整数偏移量。请勿使用任何预先制定的公式；从第一性原理出发推导线性系统。\n\n2. 实现一个求解器，对于给定的整数次数 $p \\ge 2$ 和指定的模板几何形状（内部对称或边界单侧），该求解器能构建偏移量 $\\{s_i\\}$ 并求解得到的关于权重 $\\{\\alpha_i\\}$ 的线性系统，以确保对最高 $p$ 次多项式的精确性。使用 $p+1$ 个点：\n   - 内部对称模板：对于偶数 $p$，选择以 $x_0$ 为中心的偏移量 $s_i \\in \\{-\\frac{p}{2}, -\\frac{p}{2}+1, \\dots, \\frac{p}{2}\\}$。\n   - 边界单侧模板：在左边界 $x_0$ 处，选择偏移量 $s_i \\in \\{0,1,2,\\dots,p\\}$。\n\n3. 通过评估复合平滑背景剖面\n$$\nu(x) = 10^{-3} x^3 + \\sin(0.3 x),\n$$\n的近似误差，量化该方法在重力和磁力勘探中为平滑背景场建模所带来的好处。其中正弦函数中的角度以弧度为单位。对于此剖面，报告您的 FD 近似 $\\partial_{xx} u(x)$ 在指定网格点上的最大绝对误差。该复合剖面模拟了一个缓慢变化的重力背景（多项式趋势）与一个平滑的磁场变化（正弦波）的叠加。将所有量视为无量纲量，因此不需要物理单位。\n\n将您的推导基于泰勒级数展开式\n$$\nu(x_0 + s h) = \\sum_{k=0}^{\\infty} \\frac{u^{(k)}(x_0)}{k!} (s h)^k,\n$$\n和二阶导数的定义 $u''(x_0) = \\partial_{xx} u(x_0)$。\n\n您的程序必须通过求解由最高 $p$ 次精确性所蕴含的线性系统来生成 FD 权重，然后计算所要求的误差。不要依赖任何专门的有限差分库或快捷公式。\n\n测试套件：\n- 使用以下网格设置和次数 $p$。\n  - 内部网格上的多项式精确性测试：\n    1. 案例 A：$p=2$，定义域 $x \\in [0,1]$，$N=101$ 个等距点，$h = 1/100$，内部对称模板，在内部点上进行评估，不包括每个边界附近的 1 个网格单元。对于每个多项式 $x^k$, $k=0,1,2$，计算 FD 近似值与精确值 $\\partial_{xx} x^k$ 之间的最大绝对误差，并报告所有三个 $k$ 值中的单个最大值。\n    2. 案例 B：$p=6$，定义域和网格与案例 A 相同，内部对称模板，不包括每个边界附近的 3 个单元，多项式 $x^k$ (其中 $k=0,1,2,3,4,5,6$)，并报告所有 $k$ 值和所有内部点上的最大绝对误差。\n\n  - 左边界上的多项式精确性测试：\n    3. 案例 C：$p=6$，定义域 $x \\in [0,1]$，$N=101$，在 $x_0=0$ 处使用偏移量为 $\\{0,1,2,3,4,5,6\\}$ 的单侧模板。对于多项式 $x^k$, $k=0,1,\\dots,6$，计算在 $x_0=0$ 处 FD 近似的最大绝对误差。\n\n  - 平滑背景复合剖面测试：\n    4. 案例 D：$p=2$，定义域 $x \\in [0,10]$，$N=1001$，内部对称模板，不包括边界附近的 1 个单元；计算在内部点上 FD 近似 $\\partial_{xx} u(x)$ 的最大绝对误差。\n    5. 案例 E：$p=4$，定义域和网格与案例 D 相同，内部对称模板，不包括边界附近的 2 个单元；报告与案例 D 相同的最大绝对误差。\n    6. 案例 F：$p=6$，定义域和网格与案例 D 相同，内部对称模板，不包括边界附近的 3 个单元；报告与案例 D 相同的最大绝对误差。\n    7. 案例 G：$p=6$，定义域和网格与案例 D 相同，在 $x_0=0$ 处使用左边界单侧模板；报告在边界点处的绝对误差。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含按案例 A 到 G 顺序排列的七个结果，格式为用方括号括起来的逗号分隔列表，例如，“[resultA,resultB,resultC,resultD,resultE,resultF,resultG]”。所有七个结果都必须是浮点数。角度必须解释为弧度。由于变量已无量纲化，因此不需要物理单位。", "solution": "该问题要求构建和评估用于二阶导数 $\\partial_{xx} u$ 的有限差分 (FD) 模板，并确保对最高为指定次数 $p$ 的多项式具有精确性。推导必须基于第一性原理，并使用泰勒级数展开。\n\n### 有限差分模板权重的推导\n\n在间距为 $h$ 的均匀网格上，函数 $u(x)$ 在点 $x_0$ 处的二阶导数的有限差分近似的一般形式由下式给出：\n$$\n\\partial_{xx} u(x_0) \\approx \\frac{1}{h^2} \\sum_{i=0}^{p} \\alpha_i u(x_0 + s_i h)\n$$\n此处，$\\{\\alpha_i\\}_{i=0}^{p}$ 是未知的无量纲权重，$\\{s_i\\}_{i=0}^{p}$ 是定义相对于 $x_0$ 的模板几何形状的整数偏移量。我们使用 $p+1$ 个点来构建模板。\n\n为了确定权重 $\\alpha_i$，我们要求此近似对所有次数最高为 $p$ 的多项式都精确。这等价于将右侧的泰勒级数展开式与精确的二阶导数 $u''(x_0)$ 相匹配。\n\n函数 $u(x)$ 在 $x_0$ 附近的泰勒级数展开为：\n$$\nu(x_0 + \\Delta x) = \\sum_{k=0}^{\\infty} \\frac{u^{(k)}(x_0)}{k!} (\\Delta x)^k\n$$\n其中 $u^{(k)}(x_0)$ 是 $u$ 在 $x_0$ 处的 $k$ 阶导数。将 $\\Delta x = s_i h$ 代入 FD 和中的每一项，我们得到：\n$$\nu(x_0 + s_i h) = \\sum_{k=0}^{\\infty} \\frac{u^{(k)}(x_0)}{k!} (s_i h)^k\n$$\n现在，我们将此展开式代入 FD 公式中：\n$$\n\\frac{1}{h^2} \\sum_{i=0}^{p} \\alpha_i \\left( \\sum_{k=0}^{\\infty} \\frac{u^{(k)}(x_0)}{k!} (s_i h)^k \\right)\n$$\n根据线性性质，我们可以交换求和顺序：\n$$\n\\sum_{k=0}^{\\infty} \\frac{u^{(k)}(x_0) h^k}{h^2 k!} \\left( \\sum_{i=0}^{p} \\alpha_i s_i^k \\right)\n$$\n我们希望这个表达式等于 $u''(x_0)$。这意味着 $u^{(2)}(x_0)$ 的系数必须为 $1$，并且对于 $k \\neq 2$（至少对于 $k \\le p$），所有其他导数 $u^{(k)}(x_0)$ 的系数都必须为零。让我们检查每个导数项 $u^{(k)}(x_0)$ 的系数：\n\n对于 $k=0$：系数为 $\\frac{h^0}{h^2 0!} \\sum_{i=0}^{p} \\alpha_i s_i^0 = \\frac{1}{h^2} \\sum_{i=0}^{p} \\alpha_i$。为了使该项为零，我们必须有：\n$$\n\\sum_{i=0}^{p} \\alpha_i s_i^0 = \\sum_{i=0}^{p} \\alpha_i = 0\n$$\n\n对于 $k=1$：系数为 $\\frac{h^1}{h^2 1!} \\sum_{i=0}^{p} \\alpha_i s_i^1 = \\frac{1}{h} \\sum_{i=0}^{p} \\alpha_i s_i$。为了使该项为零：\n$$\n\\sum_{i=0}^{p} \\alpha_i s_i^1 = 0\n$$\n\n对于 $k=2$：系数为 $\\frac{h^2}{h^2 2!} \\sum_{i=0}^{p} \\alpha_i s_i^2 = \\frac{1}{2} \\sum_{i=0}^{p} \\alpha_i s_i^2$。我们要求此项为 $1$：\n$$\n\\frac{1}{2} \\sum_{i=0}^{p} \\alpha_i s_i^2 = 1 \\implies \\sum_{i=0}^{p} \\alpha_i s_i^2 = 2\n$$\n\n对于 $k \\in \\{3, 4, \\dots, p\\}$：系数为 $\\frac{h^k}{h^2 k!} \\sum_{i=0}^{p} \\alpha_i s_i^k$。为了使这些项为零：\n$$\n\\sum_{i=0}^{p} \\alpha_i s_i^k = 0\n$$\n\n这 $p+1$ 个方程构成了关于 $p+1$ 个未知权重 $\\{\\alpha_i\\}$ 的线性方程组。我们可以将此系统表示为矩阵形式 $\\mathbf{M} \\boldsymbol{\\alpha} = \\mathbf{b}$，其中 $\\boldsymbol{\\alpha} = [\\alpha_0, \\alpha_1, \\dots, \\alpha_p]^T$：\n$$\n\\begin{pmatrix}\ns_0^0     & s_1^0     & \\dots   & s_p^0    \\\\\ns_0^1     & s_1^1     & \\dots   & s_p^1    \\\\\ns_0^2     & s_1^2     & \\dots   & s_p^2    \\\\\n\\vdots    & \\vdots    & \\ddots  & \\vdots   \\\\\ns_0^p     & s_1^p     & \\dots   & s_p^p\n\\end{pmatrix}\n\\begin{pmatrix}\n\\alpha_0 \\\\\n\\alpha_1 \\\\\n\\alpha_2 \\\\\n\\vdots \\\\\n\\alpha_p\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\\n0 \\\\\n2 \\\\\n\\vdots \\\\\n0\n\\end{pmatrix}\n$$\n系数矩阵 $\\mathbf{M}$ 是一个范德蒙矩阵 (Vandermonde matrix)，其元素为 $M_{ki} = s_i^k$。只要模板点 $s_i$ 是互不相同的，该矩阵就是可逆的，从而保证了权重 $\\boldsymbol{\\alpha}$ 的唯一解。\n\n### 实现与评估策略\n\n该过程对每个测试案例包括以下步骤：\n1.  **定义模板几何形状**：对于给定的次数 $p$，确定整数偏移量 $\\{s_i\\}$。对于偶数 $p$ 的对称内部模板，$s_i \\in \\{ -p/2, \\dots, p/2 \\}$。对于单侧边界模板，$s_i \\in \\{ 0, \\dots, p \\}$。\n2.  **求解权重**：构造如上推导的范德蒙矩阵 $\\mathbf{M}$ 和右侧向量 $\\mathbf{b}$。求解线性系统 $\\mathbf{M} \\boldsymbol{\\alpha} = \\mathbf{b}$ 以找到权重 $\\boldsymbol{\\alpha}$。\n3.  **应用模板并计算误差**：\n    *   定义网格、测试函数 $u(x)$ 及其精确的二阶导数 $u''(x)$。\n    *   在每个指定的评估点 $x_j$ 处，收集模板所需的函数值 $u(x_j + s_i h)$。\n    *   计算 FD 近似值：$u''_{FD}(x_j) = \\frac{1}{h^2} \\sum_i \\alpha_i u(x_j + s_i h)$。\n    *   计算绝对误差 $|u''_{FD}(x_j) - u''(x_j)|$。\n    *   根据测试案例的要求，报告在指定域上或指定点上的最大误差。\n\n对于多项式精确性测试（案例 A, B, C），理论误差为零，因此计算出的误差应在机器浮点精度的数量级上。对于平滑复合函数（案例 D-G），随着精确度 $p$ 的增加，误差预计会减小，这展示了高阶方法在解析平滑场方面的优势。\n\n对于次数为 $p$（其中 $p$ 为偶数）的对称模板，其精度阶数为 $O(h^p)$，因为与奇数次幂 $u^{(p+1)}$ 相关的误差项由于对称性而抵消。对于单侧模板，其精度阶数通常为 $O(h^{p-1})$。这解释了为什么高阶模板对平滑函数能产生显著更小的误差，这是计算地球物理学中精确捕捉背景场变化的一个关键方面。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_stencil_weights(p, s_offsets):\n    \"\"\"\n    Computes finite difference weights for the second derivative.\n    The stencil must be exact for polynomials up to degree p.\n\n    Args:\n        p (int): The maximum degree of the polynomial for which the stencil is exact.\n        s_offsets (np.ndarray): An array of p+1 integer offsets for the stencil points.\n\n    Returns:\n        np.ndarray: The array of p+1 stencil weights.\n    \"\"\"\n    if len(s_offsets) != p + 1:\n        raise ValueError(\"Number of offsets must be p + 1.\")\n    \n    # Construct the Vandermonde matrix M, where M[k, i] = s_offsets[i]**k\n    # for k in 0..p and i in 0..p\n    M = np.vander(s_offsets, N=p + 1, increasing=True).T\n    \n    # Construct the right-hand side vector b\n    b = np.zeros(p + 1)\n    b[2] = 2.0  # The condition for the second derivative\n    \n    # Solve the linear system M @ alpha = b for the weights alpha\n    weights = np.linalg.solve(M, b)\n    return weights\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    results = []\n\n    # --- Case A: p=2, interior, polynomial exactness ---\n    p_A = 2\n    N_A = 101\n    x_A = np.linspace(0.0, 1.0, N_A)\n    h_A = 1.0 / (N_A - 1)\n    p_half_A = p_A // 2\n    s_offsets_A = np.arange(-p_half_A, p_half_A + 1)\n    weights_A = get_stencil_weights(p_A, s_offsets_A)\n    \n    max_err_A = 0.0\n    for k in range(p_A + 1):\n        u_poly = x_A**k\n        if k  2:\n            u_xx_exact_poly = np.zeros_like(x_A)\n        else:\n            u_xx_exact_poly = k * (k - 1) * x_A**(k - 2)\n\n        for j in range(p_half_A, N_A - p_half_A):\n            u_values = u_poly[j - p_half_A : j + p_half_A + 1]\n            u_xx_fd = np.dot(weights_A, u_values) / h_A**2\n            err = np.abs(u_xx_fd - u_xx_exact_poly[j])\n            if err > max_err_A:\n                max_err_A = err\n    results.append(max_err_A)\n\n    # --- Case B: p=6, interior, polynomial exactness ---\n    p_B = 6\n    N_B = 101\n    x_B = np.linspace(0.0, 1.0, N_B)\n    h_B = 1.0 / (N_B - 1)\n    p_half_B = p_B // 2\n    s_offsets_B = np.arange(-p_half_B, p_half_B + 1)\n    weights_B = get_stencil_weights(p_B, s_offsets_B)\n\n    max_err_B = 0.0\n    for k in range(p_B + 1):\n        u_poly = x_B**k\n        if k  2:\n            u_xx_exact_poly = np.zeros_like(x_B)\n        else:\n            u_xx_exact_poly = k * (k - 1) * x_B**(k - 2)\n            \n        for j in range(p_half_B, N_B - p_half_B):\n            u_values = u_poly[j - p_half_B : j + p_half_B + 1]\n            u_xx_fd = np.dot(weights_B, u_values) / h_B**2\n            err = np.abs(u_xx_fd - u_xx_exact_poly[j])\n            if err > max_err_B:\n                max_err_B = err\n    results.append(max_err_B)\n\n    # --- Case C: p=6, boundary, polynomial exactness ---\n    p_C = 6\n    N_C = 101\n    x_C = np.linspace(0.0, 1.0, N_C)\n    h_C = 1.0 / (N_C - 1)\n    s_offsets_C = np.arange(p_C + 1)\n    weights_C = get_stencil_weights(p_C, s_offsets_C)\n    \n    max_err_C = 0.0\n    for k in range(p_C + 1):\n        u_poly = x_C**k\n        if k  2:\n            u_xx_exact_val = 0.0\n        else:\n            u_xx_exact_val = k * (k - 1) * x_C[0]**(k - 2)\n\n        u_values = u_poly[0 : p_C + 1]\n        u_xx_fd = np.dot(weights_C, u_values) / h_C**2\n        err = np.abs(u_xx_fd - u_xx_exact_val)\n        if err > max_err_C:\n            max_err_C = err\n    results.append(max_err_C)\n\n    # --- Setup for Cases D, E, F, G (Smooth Profile) ---\n    N_smooth = 1001\n    x_smooth = np.linspace(0.0, 10.0, N_smooth)\n    h_smooth = 10.0 / (N_smooth - 1)\n    u_smooth = 1e-3 * x_smooth**3 + np.sin(0.3 * x_smooth)\n    u_xx_exact_smooth = 6e-3 * x_smooth - (0.3**2) * np.sin(0.3 * x_smooth)\n\n    # --- Case D: p=2, interior, smooth profile ---\n    p_D = 2\n    p_half_D = p_D // 2\n    s_offsets_D = np.arange(-p_half_D, p_half_D + 1)\n    weights_D = get_stencil_weights(p_D, s_offsets_D)\n    \n    u_xx_fd_D = np.zeros(N_smooth)\n    eval_indices_D = range(p_half_D, N_smooth - p_half_D)\n    for j in eval_indices_D:\n        u_values = u_smooth[j - p_half_D : j + p_half_D + 1]\n        u_xx_fd_D[j] = np.dot(weights_D, u_values) / h_smooth**2\n    max_err_D = np.max(np.abs(u_xx_fd_D[list(eval_indices_D)] - u_xx_exact_smooth[list(eval_indices_D)]))\n    results.append(max_err_D)\n    \n    # --- Case E: p=4, interior, smooth profile ---\n    p_E = 4\n    p_half_E = p_E // 2\n    s_offsets_E = np.arange(-p_half_E, p_half_E + 1)\n    weights_E = get_stencil_weights(p_E, s_offsets_E)\n\n    u_xx_fd_E = np.zeros(N_smooth)\n    eval_indices_E = range(p_half_E, N_smooth - p_half_E)\n    for j in eval_indices_E:\n        u_values = u_smooth[j - p_half_E : j + p_half_E + 1]\n        u_xx_fd_E[j] = np.dot(weights_E, u_values) / h_smooth**2\n    max_err_E = np.max(np.abs(u_xx_fd_E[list(eval_indices_E)] - u_xx_exact_smooth[list(eval_indices_E)]))\n    results.append(max_err_E)\n\n    # --- Case F: p=6, interior, smooth profile ---\n    p_F = 6\n    p_half_F = p_F // 2\n    s_offsets_F = np.arange(-p_half_F, p_half_F + 1)\n    weights_F = get_stencil_weights(p_F, s_offsets_F)\n    \n    u_xx_fd_F = np.zeros(N_smooth)\n    eval_indices_F = range(p_half_F, N_smooth - p_half_F)\n    for j in eval_indices_F:\n        u_values = u_smooth[j - p_half_F : j + p_half_F + 1]\n        u_xx_fd_F[j] = np.dot(weights_F, u_values) / h_smooth**2\n    max_err_F = np.max(np.abs(u_xx_fd_F[list(eval_indices_F)] - u_xx_exact_smooth[list(eval_indices_F)]))\n    results.append(max_err_F)\n\n    # --- Case G: p=6, boundary, smooth profile ---\n    p_G = 6\n    s_offsets_G = np.arange(p_G + 1)\n    weights_G = get_stencil_weights(p_G, s_offsets_G)\n\n    u_values_G = u_smooth[0 : p_G + 1]\n    u_xx_fd_G = np.dot(weights_G, u_values_G) / h_smooth**2\n    err_G = np.abs(u_xx_fd_G - u_xx_exact_smooth[0])\n    results.append(err_G)\n    \n    # Final print statement\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3594272"}, {"introduction": "构建了差分格式后，下一步是评估其性能，尤其是在波动模拟中的表现。这个练习聚焦于一个标准的四阶精度中心差分格式，要求你不仅要推导其系数，更要通过色散分析来检验其质量。通过计算“修正波数”（modified wavenumber），你将学习如何量化数值格式对不同波长波的传播逼真度，这是评估计算地震学模拟保真度的核心技能。[@problem_id:3594256]", "problem": "在一维空间中，考虑在间距为 $h$ 的均匀网格 $x_{i} = x_{0} + i h$ 上对二阶导数 $f''(x)$ 进行离散化，这在计算地球物理学中对声波或弹性波传播进行建模时会出现。你需要推导一个中心五点差分格式，该格式在逼近 $f''(x_{i})$ 时具有四阶精度。\n\n从一个线性、移位不变的离散算子的假设形式开始\n$$\n\\mathcal{L} f_{i} = \\frac{1}{h^{2}} \\left( A f_{i-2} + B f_{i-1} + C f_{i} + B f_{i+1} + A f_{i+2} \\right),\n$$\n其中 $A$、$B$ 和 $C$ 是未知的实系数。使用 $f(x)$ 在 $x_{i}$ 点的泰勒级数展开，假设 $f(x)$ 足够光滑，并施加必要条件，使得 $\\mathcal{L} f_{i}$ 逼近 $f''(x_{i})$ 的截断误差为 $\\mathcal{O}(h^{4})$ 阶。\n\n然后，通过将 $\\mathcal{L}$ 应用于波数为实数 $k$ 的傅里叶模态 $u_{i} = \\exp(i k x_{i})$ 来进行频散分析。通过以下关系式为二阶导数差分格式定义修正波数 $k^{*}(kh)$\n$$\n\\mathcal{L} u_{i} = -\\left(k^{*}(kh)\\right)^{2} u_{i}.\n$$\n计算 $k^{*}(kh)$ 关于 $h$ 和 $kh$ 的闭式表达式。\n\n将你的最终答案以单行矩阵的形式给出，其前五个条目是按顺序 $m=-2,-1,0,1,2$排列的差分格式系数 $(A, B, C, B, A)$，第六个条目是 $k^{*}(kh)$ 的解析表达式。不需要进行数值舍入。根据需要，用有理数和三角函数精确地表示你的答案。", "solution": "用户要求我推导一个用于二阶导数的四阶精度、五点中心有限差分格式，然后计算其修正波数。\n\n### 第1步：问题验证\n\n首先，我将验证问题陈述。\n\n**提取已知条件：**\n1.  **问题：** 在均匀网格 $x_i = x_0 + i h$ 上对二阶导数 $f''(x)$ 进行离散化。\n2.  **算子形式：** 一个中心五点差分格式，形式为 $\\mathcal{L} f_{i} = \\frac{1}{h^{2}} \\left( A f_{i-2} + B f_{i-1} + C f_{i} + B f_{i+1} + A f_{i+2} \\right)$。\n3.  **精度要求：** 该差分格式必须以 $\\mathcal{O}(h^{4})$ 阶的截断误差逼近 $f''(x_i)$。\n4.  **推导方法：** 使用 $f(x)$ 在 $x_i$ 点的泰勒级数展开。\n5.  **频散分析：** 将算子 $\\mathcal{L}$ 应用于傅里叶模态 $u_i = \\exp(i k x_i)$。\n6.  **修正波数定义：** $\\mathcal{L} u_i = -(k^{*}(kh))^{2} u_i$。\n7.  **任务：**\n    a. 求系数 $A$、$B$ 和 $C$。\n    b. 求修正波数 $k^{*}(kh)$ 的闭式表达式。\n8.  **输出格式：** 一个包含五个差分格式系数 $(A, B, C, B, A)$ 和 $k^{*}(kh)$ 表达式的单行矩阵。\n\n**使用提取的已知条件进行验证：**\n*   **科学依据：** 这个问题是数值分析中的一个标准练习，特别是在求解偏微分方程的有限差分法领域，这是计算地球物理学的核心技术。用于精度分析的泰勒级数和用于波传播特性分析的频散分析都是基本概念。该问题在科学上是合理的。\n*   **适定性：** 这是一个适定问题。它提供了明确的目标和足够的约束条件（算子的形式和所需的精度阶数）来唯一确定未知系数 A、B、C。随后的频散分析是基于所推导算子的直接计算。\n*   **客观性：** 问题以精确、客观的数学语言陈述。\n*   **其他缺陷：** 问题是自洽且一致的。它不包含任何列出的缺陷（例如，科学上不合理、信息缺失、含糊不清）。\n\n**结论：** 问题有效。我现在开始求解。\n\n### 第1部分：差分格式系数的推导\n\n为求系数 $A$、$B$ 和 $C$，我们假设 $f(x)$ 足够光滑，并使用泰勒级数将在算子 $\\mathcal{L}$ 中的每一项 $f_{i+m} = f(x_i + mh)$ 在点 $x_i$ 附近展开。\n\n算子由下式给出：\n$$\n\\mathcal{L} f_{i} = \\frac{1}{h^{2}} \\left( A f_{i-2} + B f_{i-1} + C f_{i} + B f_{i+1} + A f_{i+2} \\right)\n$$\n我们可以将其重写为：\n$$\nh^2 \\mathcal{L} f_{i} = A(f_{i-2} + f_{i+2}) + B(f_{i-1} + f_{i+1}) + C f_i\n$$\n$f(x_i \\pm mh)$ 的泰勒展开式为：\n$$\nf(x_i \\pm mh) = f(x_i) \\pm (mh)f'(x_i) + \\frac{(mh)^2}{2!}f''(x_i) \\pm \\frac{(mh)^3}{3!}f'''(x_i) + \\frac{(mh)^4}{4!}f^{(4)}(x_i) + \\frac{(mh)^5}{5!}f^{(5)}(x_i) + \\frac{(mh)^6}{6!}f^{(6)}(x_i) + \\dots\n$$\n由于差分格式的对称性，当我们对 $f_{i-m} + f_{i+m}$ 求和时，奇数次幂的导数项会相互抵消。\n对于 $m=1$：\n$$\nf_{i-1} + f_{i+1} = 2f_i + \\frac{2 h^2}{2!} f_i'' + \\frac{2 h^4}{4!} f_i^{(4)} + \\frac{2 h^6}{6!} f_i^{(6)} + \\mathcal{O}(h^8) = 2 f_i + h^2 f_i'' + \\frac{1}{12} h^4 f_i^{(4)} + \\frac{1}{360} h^6 f_i^{(6)} + \\mathcal{O}(h^8)\n$$\n对于 $m=2$：\n$$\nf_{i-2} + f_{i+2} = 2f_i + \\frac{2 (2h)^2}{2!} f_i'' + \\frac{2 (2h)^4}{4!} f_i^{(4)} + \\frac{2 (2h)^6}{6!} f_i^{(6)} + \\mathcal{O}(h^8) = 2 f_i + 4 h^2 f_i'' + \\frac{4}{3} h^4 f_i^{(4)} + \\frac{8}{45} h^6 f_i^{(6)} + \\mathcal{O}(h^8)\n$$\n将这些和代回 $h^2 \\mathcal{L} f_i$ 的表达式中：\n$$\nh^2 \\mathcal{L} f_i = A \\left( 2 f_i + 4 h^2 f_i'' + \\frac{4}{3} h^4 f_i^{(4)} + \\dots \\right) + B \\left( 2 f_i + h^2 f_i'' + \\frac{1}{12} h^4 f_i^{(4)} + \\dots \\right) + C f_i\n$$\n我们按 $f$ 在 $x_i$ 处的导数阶数对各项进行分组：\n$$\nh^2 \\mathcal{L} f_i = (2A + 2B + C) f_i + (4A + B) h^2 f_i'' + \\left(\\frac{4}{3}A + \\frac{1}{12}B\\right) h^4 f_i^{(4)} + \\left(\\frac{8}{45}A + \\frac{1}{360}B\\right) h^6 f_i^{(6)} + \\dots\n$$\n除以 $h^2$，我们得到算子 $\\mathcal{L}$ 的展开式：\n$$\n\\mathcal{L} f_i = \\frac{1}{h^2}(2A + 2B + C) f_i + (4A + B) f_i'' + \\left(\\frac{4}{3}A + \\frac{1}{12}B\\right) h^2 f_i^{(4)} + \\mathcal{O}(h^4)\n$$\n我们要求 $\\mathcal{L}f_i$ 逼近 $f_i''$ 的截断误差为 $\\mathcal{O}(h^4)$。这对系数施加了以下条件：\n1.  $f_i$ 的系数必须为零：$2A + 2B + C = 0$。\n2.  $f_i''$ 的系数必须为一：$4A + B = 1$。\n3.  为使截断误差为 $\\mathcal{O}(h^4)$ 阶，$h^2 f_i^{(4)}$ 的系数必须为零：$\\frac{4}{3}A + \\frac{1}{12}B = 0$。\n\n我们现在求解这个关于 $A$、$B$ 和 $C$ 的三元线性方程组。\n由第三个方程得：\n$$\n\\frac{4}{3}A = -\\frac{1}{12}B \\implies 16A = -B \\implies B = -16A\n$$\n将此代入第二个方程：\n$$\n4A + (-16A) = 1 \\implies -12A = 1 \\implies A = -\\frac{1}{12}\n$$\n现在我们求 $B$：\n$$\nB = -16A = -16 \\left(-\\frac{1}{12}\\right) = \\frac{16}{12} = \\frac{4}{3}\n$$\n最后，我们从第一个方程求出 $C$：\n$$\nC = -2A - 2B = -2\\left(-\\frac{1}{12}\\right) - 2\\left(\\frac{4}{3}\\right) = \\frac{1}{6} - \\frac{8}{3} = \\frac{1}{6} - \\frac{16}{6} = -\\frac{15}{6} = -\\frac{5}{2}\n$$\n五点四阶差分格式的系数为 $A = -1/12$，$B = 4/3$ 和 $C = -5/2$。对应于点 $(i-2, i-1, i, i+1, i+2)$ 的全套差分格式系数 $(A, B, C, B, A)$ 为 $(-\\frac{1}{12}, \\frac{4}{3}, -\\frac{5}{2}, \\frac{4}{3}, -\\frac{1}{12})$。\n\n### 第2部分：频散分析与修正波数\n\n接下来，我们通过将离散算子 $\\mathcal{L}$ 应用于傅里叶模态 $u_i = \\exp(i k x_i)$ 来进行频散分析，其中 $k$ 是波数。我们注意到 $u_{i+m} = \\exp(ik(x_i+mh)) = u_i \\exp(ikmh)$。\n$$\n\\mathcal{L} u_i = \\frac{1}{h^2} \\left[ A u_{i-2} + B u_{i-1} + C u_i + B u_{i+1} + A u_{i+2} \\right]\n$$\n$$\n\\mathcal{L} u_i = \\frac{u_i}{h^2} \\left[ A e^{-i2kh} + B e^{-ikh} + C + B e^{ikh} + A e^{i2kh} \\right]\n$$\n使用欧拉恒等式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，我们可以简化表达式：\n$$\n\\mathcal{L} u_i = \\frac{u_i}{h^2} \\left[ C + 2B \\cos(kh) + 2A \\cos(2kh) \\right]\n$$\n修正波数 $k^*(kh)$ 由关系式 $\\mathcal{L} u_i = -(k^*(kh))^2 u_i$ 定义。因此，我们有：\n$$\n-(k^*(kh))^2 = \\frac{1}{h^2} \\left[ C + 2B \\cos(kh) + 2A \\cos(2kh) \\right]\n$$\n现在，代入推导出的 $A, B, C$ 的值：\n$$\n-(k^*)^2 = \\frac{1}{h^2} \\left[ -\\frac{5}{2} + 2\\left(\\frac{4}{3}\\right) \\cos(kh) + 2\\left(-\\frac{1}{12}\\right) \\cos(2kh) \\right]\n$$\n$$\n-(k^*)^2 = \\frac{1}{h^2} \\left[ -\\frac{5}{2} + \\frac{8}{3} \\cos(kh) - \\frac{1}{6} \\cos(2kh) \\right]\n$$\n乘以 $-1$ 得到 $(k^*)^2$ 的表达式：\n$$\n(k^*)^2 = \\frac{1}{h^2} \\left[ \\frac{5}{2} - \\frac{8}{3} \\cos(kh) + \\frac{1}{6} \\cos(2kh) \\right]\n$$\n为简化，我们可以使用恒等式 $C = -(2A+2B) = -2(-1/12) - 2(4/3) = 1/6 - 8/3 = -15/6 = -5/2$。\n另一种方法是认识到系数之和为零。\n$C+2B+2A=0 \\implies C=-2A-2B$。\n$(k^*)^2 = -\\frac{1}{h^2} \\left[ -2A - 2B + 2B \\cos(kh) + 2A \\cos(2kh) \\right]$\n$(k^*)^2 = \\frac{2}{h^2} \\left[ B(1 - \\cos(kh)) + A(1 - \\cos(2kh)) \\right]$\n使用恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n$(k^*)^2 = \\frac{2}{h^2} \\left[ B(2\\sin^2(kh/2)) + A(2\\sin^2(kh)) \\right]$\n使用 $\\sin(kh) = 2\\sin(kh/2)\\cos(kh/2)$：\n$(k^*)^2 = \\frac{4}{h^2} \\left[ B\\sin^2(kh/2) + A(4\\sin^2(kh/2)\\cos^2(kh/2)) \\right]$\n$(k^*)^2 = \\frac{4}{h^2} \\sin^2(kh/2) \\left[ B + 4A\\cos^2(kh/2) \\right]$\n代入 $B=4/3$ 和 $A=-1/12$：\n$(k^*)^2 = \\frac{4}{h^2} \\sin^2(kh/2) \\left[ \\frac{4}{3} + 4\\left(-\\frac{1}{12}\\right)\\cos^2(kh/2) \\right] = \\frac{4}{h^2} \\sin^2(kh/2) \\left[ \\frac{4}{3} - \\frac{1}{3}\\cos^2(kh/2) \\right]$\n$(k^*)^2 = \\frac{4}{3h^2} \\sin^2(kh/2) \\left[ 4 - \\cos^2(kh/2) \\right]$\n使用 $1 - \\cos^2(x) = \\sin^2(x)$，我们可以写出 $4-\\cos^2(kh/2) = 3+\\sin^2(kh/2)$。\n为简单起见，让我们回到使用全角余弦的形式。\n$(k^*)^2 = \\frac{1}{3h^2} (\\cos^2(kh) - 8\\cos(kh) + 7)$\n这可以因式分解为：\n$(k^*)^2 = \\frac{1}{3h^2} (1 - \\cos(kh))(7 - \\cos(kh))$\n取平方根，并注意到对于物理波数 $k \\ge 0$ 和 $h  0$，我们有：\n$$\nk^*(kh) = \\frac{1}{h} \\sqrt{\\frac{(1 - \\cos(kh))(7 - \\cos(kh))}{3}}\n$$\n这就是修正波数的闭式表达式。\n最终答案要求将五个系数 $(A, B, C, B, A)$ 和 $k^*(kh)$ 的表达式放在一个单行矩阵中。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{1}{12}  \\frac{4}{3}  -\\frac{5}{2}  \\frac{4}{3}  -\\frac{1}{12}  \\frac{1}{h} \\sqrt{\\frac{(1-\\cos(kh))(7-\\cos(kh))}{3}}\n\\end{pmatrix}\n}\n$$", "id": "3594256"}, {"introduction": "真实的地球物理模拟远不止空间离散化。这个综合性练习将引导你进入一个更完整的分析框架，比较高级的显式格式和紧致（隐式）格式的优劣。你将为一个完全离散的声波方程格式进行分析，确定其稳定性条件（Courant-Friedrichs-Lewy, CFL条件），并计算最终的性能指标——相速度误差。这项实践模拟了计算地震学家在开发和评估数值模型时的真实工作流程，将空间、时间离散化与稳定性分析融为一体。[@problem_id:3594271]", "problem": "您的任务是构建和分析一维均匀网格上二阶空间导数算子的有限差分格式，然后利用其离散谱特性来量化计算地震学中使用的一维声波方程全离散恒定时间步长格式的相速度频散。您的程序必须实现一种紧凑 Padé 型格式和一种显式高阶格式，推导其离散傅里叶符号，并为一组测试参数评估全离散频散关系。所有角度必须以弧度为单位，任何物理量必须以指定单位表示。\n\n考虑一个间距为 $h$ 的一维均匀网格，网格节点为 $x_i = i h$，以及一个光滑标量场 $u(x)$。令 $u_i \\equiv u(x_i)$。您将为二阶导数 $\\partial_{xx} u$ 构建并分析以下两种空间离散化方法：\n\n- 一种形式如下的紧凑三对角 Padé 型格式\n  $$\n  \\alpha\\, u''_{i-1} + u''_i + \\alpha\\, u''_{i+1}\n  \\;=\\;\n  \\frac{1}{h^2}\\left[\n  a \\left(u_{i-1} - 2 u_i + u_{i+1}\\right)\n  + b \\left(u_{i-2} - 2 u_i + u_{i+2}\\right)\n  \\right],\n  $$\n  其中 $u''_i$ 表示在 $x_i$ 处对 $\\partial_{xx} u$ 的离散近似，常数 $\\alpha$、$a$、$b$ 待定，通过在 $x_i$ 点进行泰勒级数展开并利用对称性来达到目标精度阶。\n\n- 一种用于 $\\partial_{xx} u$ 的 8 阶（八阶）显式中心差分格式，其偏移量最高可达 $\\pm 4$，通用形式为\n  $$\n  u''_i \\;\\approx\\; \\frac{1}{h^2}\\left(c_0 u_i + \\sum_{m=1}^{4} c_m \\left(u_{i+m} + u_{i-m}\\right)\\right),\n  $$\n  其中常数 $\\{c_m\\}$ 的选择旨在通过消除截至并包括 $\\mathcal{O}(h^8)$ 的泰勒级数截断项，以达到 8 阶的格式精度。\n\n对于每种格式，进行离散傅里叶分析：对于傅里叶模式 $u_i = e^{\\mathrm{i} i \\theta}$（其中 $\\theta = k h \\in [0,\\pi]$），该格式的作用等同于乘以其符号（一个标量）。通过以下公式定义无量纲空间符号 $\\mu(\\theta)$\n$$\n\\widehat{D^{(2)}}(\\theta) \\;=\\; -\\frac{\\mu(\\theta)}{h^2},\n$$\n这样，连续拉普拉斯算子的特征值 $-\\frac{\\theta^2}{h^2}$ 就被 $-\\frac{\\mu(\\theta)}{h^2}$ 替代。为每种格式推导 $\\mu(\\theta)$ 的表达式，用 $\\theta$、系数和三角函数表示。\n\n接下来，考虑具有非均匀波速 $c(x)$ 的一维声波方程的全离散格式，\n$$\n\\partial_{tt} u(x,t) \\;=\\; c(x)^2 \\,\\partial_{xx} u(x,t),\n$$\n其中空间由上述离散二阶导数之一进行离散化，时间由具有均匀时间步长 $\\Delta t$ 的标准中心二阶有限差分进行离散化：\n$$\nu_i^{n+1} - 2 u_i^n + u_i^{n-1} \\;=\\; \\left(c_i \\frac{\\Delta t}{h}\\right)^2 \\left(-\\mu(\\theta)\\right) u_i^n,\n$$\n其中 $c_i = c(x_i)$。使用局部傅里叶分析（即将 $c_i$ 视为局部常数），证明对于无量纲波数为 $\\theta$ 的模式，其全离散频散关系为\n$$\n\\sin^2\\!\\left(\\frac{\\omega \\Delta t}{2}\\right) \\;=\\; \\left(\\frac{c \\,\\Delta t}{2 h}\\right)^2 \\mu(\\theta),\n$$\n其中 $\\omega$ 是角频率。定义局部库朗数 $\\nu_{\\text{loc}} \\equiv c \\,\\Delta t / h$ 和离散相速度 $c_{\\text{ph}} \\equiv \\omega/k$（其中 $k=\\theta/h$），并将相速度比 $c_{\\text{ph}}/c$ 表示为 $\\theta$、$\\nu_{\\text{loc}}$ 和 $\\mu(\\theta)$ 的函数。您的程序将使用此关系式计算相速度频散。\n\n稳定性约束：上述格式是稳定的，条件是对于最大的局部库朗数 $\\nu_{\\max}$ 和符号的上确界 $\\mu_{\\max} \\equiv \\max_{\\theta \\in [0,\\pi]} \\mu(\\theta)$，不等式\n$$\n\\left(\\frac{\\nu_{\\max}}{2}\\right)^2 \\mu_{\\max} \\;\\le\\; 1\n$$\n成立，等价于 $\\nu_{\\max} \\le \\dfrac{2}{\\sqrt{\\mu_{\\max}}}$。由于 $c(x)$ 是非均匀的，全局时间步长必须使用 $c_{\\max} \\equiv \\max_x c(x)$ 来选择。\n\n程序实现要求：\n\n- 通过匹配关于 $x_i$ 的泰勒级数来确定紧凑 Padé 系数 $\\alpha$、$a$、$b$，以获得 $\\partial_{xx} u$ 的 6 阶（六阶）格式精度。然后推导并实现其离散符号 $\\mu_{\\text{cp}}(\\theta)$。\n\n- 使用一个标准的 8 阶显式中心差分格式，并通过将余弦项与适当的系数求和来实现其离散符号 $\\mu_{8}(\\theta)$。\n\n- 对于一组无量纲波数 $\\Theta = [\\theta_1,\\dots,\\theta_M]$（其中 $\\theta_m \\in [0,\\pi]$）和一组波速 $\\mathcal{C} = [c_1,\\dots,c_L]$，根据两种格式中最严格的稳定性限制，并使用 0.9 的安全系数来选择一个单一的全局 $\\Delta t$，即\n  $$\n  \\frac{\\Delta t}{h} \\;=\\; 0.9 \\times \\min\\!\\left(\\frac{1}{c_{\\max}}\\frac{2}{\\sqrt{\\mu_{\\text{cp}}^{\\max}}},\\;\\frac{1}{c_{\\max}}\\frac{2}{\\sqrt{\\mu_{8}^{\\max}}}\\right),\n  $$\n  其中 $\\mu_{\\text{cp}}^{\\max} = \\max_{\\theta \\in [0,\\pi]} \\mu_{\\text{cp}}(\\theta)$ 和 $\\mu_{8}^{\\max} = \\max_{\\theta \\in [0,\\pi]} \\mu_{8}(\\theta)$，并且 $c_{\\max} = \\max_j c_j$。\n\n- 对于每种格式 $s \\in \\{\\text{cp},8\\}$、每个 $\\theta \\in \\Theta$ 和每个 $c \\in \\mathcal{C}$，计算离散相速度比\n  $$\n  \\frac{c_{\\text{ph}}}{c} \\;=\\; \\frac{2\\,\\arcsin\\!\\left(\\min\\!\\left\\{1,\\;\\frac{\\nu_{\\text{loc}}}{2}\\sqrt{\\mu_s(\\theta)}\\right\\}\\right)}{\\nu_{\\text{loc}}\\,\\theta},\n  $$\n  其中 $\\nu_{\\text{loc}} = c\\,\\Delta t/h$，然后计算绝对相对误差 $E_s(\\theta,c) \\equiv \\left|\\frac{c_{\\text{ph}}}{c} - 1\\right|$。对于每种格式，返回在 $\\Theta \\times \\mathcal{C}$ 上的最大误差。\n\n测试套件和要求输出：\n\n使用以下两个测试用例，每个用例都有自己的一组波速和一个共同的网格间距：\n\n- 测试用例 A：\n  - 网格间距：$h = 10$ 米。\n  - 波速：$\\mathcal{C}_A = [2000,\\,3500,\\,5000]$ 米/秒。\n  - 无量纲波数：$\\Theta = [0.1,\\,0.5,\\,1.0,\\,1.5,\\,2.0,\\,2.5,\\,3.0]$ 弧度。\n\n- 测试用例 B：\n  - 网格间距：$h = 10$ 米。\n  - 波速：$\\mathcal{C}_B = [1500,\\,6000]$ 米/秒。\n  - 无量纲波数：与测试用例 A 中的 $\\Theta$ 相同。\n\n对于每个测试用例，您的程序必须：\n\n- 使用该用例的 $c_{\\max}$ 和两种格式中最严格的界限，计算全局稳定时间步长 $\\Delta t$（以秒为单位，并包含 0.9 的安全系数）。\n\n- 计算 $E_{\\text{cp}}^{\\max} \\equiv \\max_{\\theta \\in \\Theta,\\,c \\in \\mathcal{C}} E_{\\text{cp}}(\\theta,c)$ 和 $E_{8}^{\\max} \\equiv \\max_{\\theta \\in \\Theta,\\,c \\in \\mathcal{C}} E_{8}(\\theta,c)$。\n\n- 计算比率 $R \\equiv E_{8}^{\\max} / E_{\\text{cp}}^{\\max}$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含八个结果，以逗号分隔并用方括号括起来：\n$$\n\\left[ E_{\\text{cp},A}^{\\max},\\; E_{8,A}^{\\max},\\; \\Delta t_A,\\; R_A,\\; E_{\\text{cp},B}^{\\max},\\; E_{8,B}^{\\max},\\; \\Delta t_B,\\; R_B \\right],\n$$\n其中下标 $A$ 或 $B$ 表示对应的测试用例。时间步长 $\\Delta t_A$ 和 $\\Delta t_B$ 必须以秒为单位表示。所有值都必须打印为浮点数。", "solution": "我们从均匀网格 $x_i = i h$ 和光滑函数 $u(x)$ 开始。目标是为 $\\partial_{xx} u$ 构建有限差分格式，推导其离散傅里叶符号，并将这些符号用于通过中心二阶有限差分进行时间离散化的一维声波方程的全离散频散关系中。\n\n紧凑 Padé 型格式的构建。假设存在一个三对角紧凑关系式\n$$\n\\alpha\\, u''_{i-1} + u''_i + \\alpha\\, u''_{i+1}\n\\;=\\;\n\\frac{1}{h^2}\\left[\na \\left(u_{i-1} - 2 u_i + u_{i+1}\\right)\n+ b \\left(u_{i-2} - 2 u_i + u_{i+2}\\right)\n\\right],\n$$\n其中待定常数 $\\alpha$、$a$、$b$ 有待选择。我们通过在 $x_i$ 点进行泰勒级数展开来强制实现 $\\partial_{xx} u$ 的六阶精度。\n\n泰勒展开。对于 $m \\in \\mathbb{Z}$，\n$$\nu_{i+m} = u + m h u' + \\frac{(m h)^2}{2} u'' + \\frac{(m h)^3}{6} u^{(3)} + \\frac{(m h)^4}{24} u^{(4)} + \\frac{(m h)^5}{120} u^{(5)} + \\frac{(m h)^6}{720} u^{(6)} + \\frac{(m h)^7}{5040} u^{(7)} + \\frac{(m h)^8}{40320} u^{(8)} + \\cdots,\n$$\n其中导数在 $x_i$ 处求值。根据对称性，我们使用的对称组合会消去奇数阶导数。\n\n右侧构建块：\n$$\nS_1 \\equiv u_{i-1} - 2 u_i + u_{i+1} = h^2 u'' + \\frac{h^4}{12} u^{(4)} + \\frac{h^6}{360} u^{(6)} + \\frac{h^8}{20160} u^{(8)} + \\cdots,\n$$\n$$\nS_2 \\equiv u_{i-2} - 2 u_i + u_{i+2} = 4 h^2 u'' + \\frac{16 h^4}{12} u^{(4)} + \\frac{64 h^6}{360} u^{(6)} + \\frac{256 h^8}{20160} u^{(8)} + \\cdots.\n$$\n因此，右侧除以 $h^2$ 后为\n$$\n\\frac{1}{h^2}\\left( a S_1 + b S_2 \\right)\n= \\left(a + 4 b\\right) u'' + \\left(\\frac{a + 16 b}{12}\\right) h^2 u^{(4)} + \\left(\\frac{a + 64 b}{360}\\right) h^4 u^{(6)} + \\left(\\frac{a + 256 b}{20160}\\right) h^6 u^{(8)} + \\cdots.\n$$\n\n左侧展开。展开 $u''_{i\\pm 1}$：\n$$\nu''_{i\\pm 1} = u'' \\pm h u^{(3)} + \\frac{h^2}{2} u^{(4)} \\pm \\frac{h^3}{6} u^{(5)} + \\frac{h^4}{24} u^{(6)} \\pm \\frac{h^5}{120} u^{(7)} + \\frac{h^6}{720} u^{(8)} + \\cdots.\n$$\n因此，\n$$\n\\alpha\\, u''_{i-1} + u''_i + \\alpha\\, u''_{i+1} = (1 + 2 \\alpha) u'' + \\alpha h^2 u^{(4)} + \\frac{\\alpha}{12} h^4 u^{(6)} + \\frac{\\alpha}{360} h^6 u^{(8)} + \\cdots.\n$$\n\n为达到六阶精度，我们匹配系数（即匹配 $u''$、$h^2 u^{(4)}$ 和 $h^4 u^{(6)}$ 的项），得到以下方程组：\n$$\n1 + 2 \\alpha = a + 4 b,\\quad\n\\alpha = \\frac{a + 16 b}{12},\\quad\n\\frac{\\alpha}{12} = \\frac{a + 64 b}{360}.\n$$\n求解可得\n$$\n\\alpha = \\frac{2}{11},\\quad a = \\frac{12}{11},\\quad b = \\frac{3}{44}.\n$$\n这就得到了一个六阶精度的紧凑 Padé 型格式。\n\n紧凑格式的傅里叶符号。对于傅里叶模式 $u_i = e^{\\mathrm{i} i \\theta}$，我们将平移替换为 $e^{\\pm \\mathrm{i} \\theta}$。右侧算子给出\n$$\nu_{i-1} - 2 u_i + u_{i+1} \\mapsto 2 \\cos\\theta - 2,\\quad\nu_{i-2} - 2 u_i + u_{i+2} \\mapsto 2 \\cos(2\\theta) - 2,\n$$\n而左侧变为 $(\\alpha e^{-\\mathrm{i}\\theta} + 1 + \\alpha e^{\\mathrm{i}\\theta}) \\widehat{u''} = (1 + 2 \\alpha \\cos\\theta)\\,\\widehat{u''}$。因此，离散算子的特征值为\n$$\n\\widehat{D^{(2)}}_{\\text{cp}}(\\theta) = \\frac{1}{h^2}\\,\\frac{a\\left(2 \\cos\\theta - 2\\right) + b\\left(2 \\cos 2\\theta - 2\\right)}{1 + 2 \\alpha \\cos\\theta}.\n$$\n根据定义，我们设 $\\widehat{D^{(2)}}(\\theta) = -\\dfrac{\\mu(\\theta)}{h^2}$，因此对于紧凑格式\n$$\n\\mu_{\\text{cp}}(\\theta) = -\\,\\frac{a\\left(2 \\cos\\theta - 2\\right) + b\\left(2 \\cos 2\\theta - 2\\right)}{1 + 2 \\alpha \\cos\\theta}.\n$$\n使用计算出的系数，$\\mu_{\\text{cp}}(\\theta)$ 在 $\\theta \\in [0,\\pi]$ 上是一个正函数。\n\n八阶显式格式及其符号。一种用于 $\\partial_{xx} u$ 的标准八阶显式中心差分近似，其偏移量最高可达 $\\pm 4$，形式如下\n$$\nu''_i \\approx \\frac{1}{h^2}\\left(c_0 u_i + \\sum_{m=1}^{4} c_m (u_{i+m} + u_{i-m})\\right),\n$$\n其中系数 $\\{c_m\\}$ 是对称的。对于傅里叶模式，其符号变为\n$$\n\\widehat{D^{(2)}}_{8}(\\theta) = \\frac{1}{h^2}\\left(c_0 + 2 \\sum_{m=1}^{4} c_m \\cos(m \\theta)\\right),\n$$\n因此\n$$\n\\mu_{8}(\\theta) = -\\left(c_0 + 2 \\sum_{m=1}^{4} c_m \\cos(m \\theta)\\right).\n$$\n一组可产生八阶格式精度的已知系数选择是\n$$\nc_0 = -\\frac{205}{72},\\quad c_1 = \\frac{8}{5},\\quad c_2 = -\\frac{1}{5},\\quad c_3 = \\frac{8}{315},\\quad c_4 = -\\frac{1}{560}.\n$$\n使用这些系数，$\\mu_{8}(\\theta)$ 在 $\\theta \\in [0,\\pi]$ 上为正。\n\n全离散频散关系。对于声波方程 $\\partial_{tt} u = c^2 \\partial_{xx} u$，其时间通过步长为 $\\Delta t$ 的中心二阶时间差分进行离散，空间通过符号为 $-\\mu(\\theta)/h^2$ 的离散二阶导数进行离散，代入平面波 $u_i^n = \\exp\\{\\mathrm{i}(i\\theta - n \\omega \\Delta t)\\}$ 可得\n$$\ne^{-\\mathrm{i}\\omega \\Delta t} - 2 + e^{\\mathrm{i}\\omega \\Delta t} = \\left(\\frac{c \\Delta t}{h}\\right)^2 \\left(-\\mu(\\theta)\\right),\n$$\n利用 $e^{-\\mathrm{i}\\omega \\Delta t} - 2 + e^{\\mathrm{i}\\omega \\Delta t} = -4 \\sin^2\\!\\left(\\frac{\\omega \\Delta t}{2}\\right)$ 将其简化为\n$$\n\\sin^2\\!\\left(\\frac{\\omega \\Delta t}{2}\\right) = \\left(\\frac{c \\Delta t}{2 h}\\right)^2 \\mu(\\theta).\n$$\n定义局部库朗数 $\\nu_{\\text{loc}} \\equiv \\dfrac{c \\Delta t}{h}$。离散相速度为 $c_{\\text{ph}} \\equiv \\omega/k$，其中 $k=\\theta/h$。求解 $\\omega \\Delta t$，\n$$\n\\omega \\Delta t = 2 \\arcsin\\!\\left(\\min\\left\\{1,\\, \\frac{\\nu_{\\text{loc}}}{2}\\sqrt{\\mu(\\theta)}\\right\\}\\right),\n$$\n因此\n$$\n\\frac{c_{\\text{ph}}}{c} = \\frac{\\omega/k}{c} = \\frac{\\omega \\Delta t}{\\nu_{\\text{loc}} \\theta} = \\frac{2 \\arcsin\\!\\left(\\min\\left\\{1,\\, \\frac{\\nu_{\\text{loc}}}{2}\\sqrt{\\mu(\\theta)}\\right\\}\\right)}{\\nu_{\\text{loc}} \\theta}.\n$$\n绝对相对相速度误差为 $E(\\theta,c) \\equiv \\left|\\dfrac{c_{\\text{ph}}}{c} - 1\\right|$。\n\n稳定性与时间步长选择。该格式是稳定的，如果 $\\left(\\dfrac{\\nu_{\\max}}{2}\\right)^2 \\mu_{\\max} \\le 1$，其中 $\\mu_{\\max} \\equiv \\max_{\\theta \\in [0,\\pi]} \\mu(\\theta)$ 且 $\\nu_{\\max} \\equiv \\max_x \\nu_{\\text{loc}} = \\dfrac{c_{\\max}\\, \\Delta t}{h}$。因此，\n$$\n\\Delta t \\le \\frac{2}{\\sqrt{\\mu_{\\max}}}\\,\\frac{h}{c_{\\max}}.\n$$\n在比较两种格式时，我们必须使用一个单一的 $\\Delta t$，该 $\\Delta t$ 满足两者中最严格的界限，并乘以一个安全系数以避免 $\\arcsin$ 中的临界参数。我们选择\n$$\n\\frac{\\Delta t}{h} = 0.9 \\times \\min\\!\\left(\\frac{1}{c_{\\max}}\\frac{2}{\\sqrt{\\mu_{\\text{cp}}^{\\max}}},\\; \\frac{1}{c_{\\max}}\\frac{2}{\\sqrt{\\mu_{8}^{\\max}}}\\right).\n$$\n\n程序算法设计。\n\n- 使用推导出的系数 $\\alpha=\\dfrac{2}{11}$、$a=\\dfrac{12}{11}$、$b=\\dfrac{3}{44}$ 实现 $\\mu_{\\text{cp}}(\\theta)$：\n  $$\n  \\mu_{\\text{cp}}(\\theta) = -\\,\\frac{a(2\\cos\\theta - 2) + b(2\\cos 2\\theta - 2)}{1 + 2 \\alpha \\cos\\theta}.\n  $$\n\n- 使用给定的系数实现 $\\mu_8(\\theta)$：\n  $$\n  \\mu_{8}(\\theta) = -\\left(c_0 + 2 \\sum_{m=1}^{4} c_m \\cos(m \\theta)\\right),\n  $$\n  其中 $c_0 = -\\dfrac{205}{72}$、$c_1 = \\dfrac{8}{5}$、$c_2 = -\\dfrac{1}{5}$、$c_3 = \\dfrac{8}{315}$、$c_4 = -\\dfrac{1}{560}$。\n\n- 通过在 $[0,\\pi]$ 上密集采样（例如，使用均匀网格）并取最大值来计算 $\\mu_{\\text{cp}}^{\\max}$ 和 $\\mu_{8}^{\\max}$。\n\n- 对于每个测试用例，从指定的 $\\mathcal{C}$ 中计算 $c_{\\max}$，然后使用两种格式中最严格的界限和 0.9 的安全系数计算 $\\Delta t/h$，最后计算 $\\Delta t = (\\Delta t/h) \\times h$（以秒为单位）。\n\n- 对于每种格式 $s \\in \\{\\text{cp},8\\}$，计算在所有 $\\theta \\in \\Theta$ 和 $c \\in \\mathcal{C}$ 上的绝对相对误差\n  $$\n  E_s(\\theta,c) = \\left|\\frac{2 \\arcsin\\!\\left(\\min\\left\\{1,\\, \\frac{\\nu_{\\text{loc}}}{2}\\sqrt{\\mu_s(\\theta)}\\right\\}\\right)}{\\nu_{\\text{loc}} \\theta} - 1\\right|,\\quad \\nu_{\\text{loc}} = \\frac{c \\Delta t}{h},\n  $$\n  并记录其最大值。\n\n- 测试用例 A 的输出（$h = 10$ 米，$\\mathcal{C}_A = [2000,\\,3500,\\,5000]$ 米/秒，$\\Theta = [0.1,\\,0.5,\\,1.0,\\,1.5,\\,2.0,\\,2.5,\\,3.0]$ 弧度）：$E_{\\text{cp},A}^{\\max}$、$E_{8,A}^{\\max}$、$\\Delta t_A$（秒）和 $R_A \\equiv E_{8,A}^{\\max}/E_{\\text{p},A}^{\\max}$。\n\n- 测试用例 B 的输出（$h = 10$ 米，$\\mathcal{C}_B = [1500,\\,6000]$ 米/秒，$\\Theta$ 与前者相同）：$E_{\\text{cp},B}^{\\max}$、$E_{8,B}^{\\max}$、$\\Delta t_B$（秒）和 $R_B \\equiv E_{8,B}^{\\max}/E_{\\text{p},B}^{\\max}$。\n\n最终程序以如下格式打印单行输出\n$$\n\\left[ E_{\\text{cp},A}^{\\max},\\; E_{8,A}^{\\max},\\; \\Delta t_A,\\; R_A,\\; E_{\\text{cp},B}^{\\max},\\; E_{8,B}^{\\max},\\; \\Delta t_B,\\; R_B \\right],\n$$\n其中时间以秒为单位，所有量均为浮点数。该设计通过局部傅里叶分析，在一组无量纲波数和非均匀波速上评估谱频散，同时遵循全离散格式所带来的稳定性约束。", "answer": "```python\nimport numpy as np\n\ndef mu_compact(theta):\n    \"\"\"\n    Compute the dimensionless symbol mu(theta) for the sixth-order compact Padé stencil:\n      alpha u''_{i-1} + u''_i + alpha u''_{i+1}\n        = (1/h^2)[ a (u_{i-1} - 2 u_i + u_{i+1}) + b (u_{i-2} - 2 u_i + u_{i+2}) ]\n    with alpha = 2/11, a = 12/11, b = 3/44.\n    Returns mu(theta) such that D2_hat = -mu(theta)/h^2.\n    \"\"\"\n    alpha = 2.0/11.0\n    a = 12.0/11.0\n    b = 3.0/44.0\n    cos1 = np.cos(theta)\n    cos2 = np.cos(2.0*theta)\n    numerator = a*(2.0*cos1 - 2.0) + b*(2.0*cos2 - 2.0)\n    denom = 1.0 + 2.0*alpha*cos1\n    mu = - numerator / denom\n    return mu\n\ndef mu_explicit8(theta):\n    \"\"\"\n    Compute the dimensionless symbol mu(theta) for the explicit 8th-order central stencil:\n      u''_i ≈ (1/h^2) [ c0*u_i + sum_{m=1}^4 c_m (u_{i+m} + u_{i-m}) ]\n    with coefficients:\n      c0 = -205/72,\n      c1 = 8/5, c2 = -1/5, c3 = 8/315, c4 = -1/560.\n    Returns mu(theta) such that D2_hat = -mu(theta)/h^2.\n    \"\"\"\n    c0 = -205.0/72.0\n    c = np.array([0.0, 8.0/5.0, -1.0/5.0, 8.0/315.0, -1.0/560.0])\n    cos_terms = c0 + 2.0*(c[1]*np.cos(theta) + c[2]*np.cos(2.0*theta)\n                          + c[3]*np.cos(3.0*theta) + c[4]*np.cos(4.0*theta))\n    mu = -cos_terms\n    return mu\n\ndef max_mu(mu_func, n_samples=200001):\n    \"\"\"Compute mu_max over theta in [0, pi] by dense sampling.\"\"\"\n    thetas = np.linspace(0.0, np.pi, n_samples)\n    mu_vals = mu_func(thetas)\n    # numerical safety: tiny negatives at theta=0 due to cancellation -> clamp\n    mu_vals = np.maximum(mu_vals, 0.0)\n    return float(np.max(mu_vals))\n\ndef phase_velocity_ratio(mu_val, theta, nu_loc):\n    \"\"\"\n    Compute c_ph/c for given mu(theta), theta, and local Courant number nu_loc.\n    Uses the exact fully discrete dispersion relation:\n      sin^2(omega*dt/2) = (nu_loc^2/4) * mu(theta).\n    Returns ratio = (omega/k)/c = (2*asin(min(1, 0.5*nu_loc*sqrt(mu)))) / (nu_loc * theta)\n    \"\"\"\n    if theta == 0.0:\n        return 1.0  # zero wavenumber: no dispersion\n    arg = 0.5 * nu_loc * np.sqrt(max(mu_val, 0.0))\n    # clamp to slightly below 1 to avoid domain errors\n    arg = min(arg, 1.0)\n    # Small numerical relaxation to avoid asin(1) -> pi/2 exactly causing potential inf sensitivity\n    if arg > 1.0 - 1e-15:\n        arg = 1.0 - 1e-15\n    omega_dt = 2.0 * np.arcsin(arg)\n    ratio = omega_dt / (nu_loc * theta)\n    return float(ratio)\n\ndef compute_case_metrics(h, c_values, theta_values, safety=0.9):\n    \"\"\"\n    For a given h (meters), list of c_values (m/s), and theta_values (radians),\n    compute:\n      - global stable dt using the most restrictive stencil bound with safety factor,\n      - max abs relative phase velocity error for compact and explicit-8 stencils,\n      - ratio of these maxima (explicit/compact).\n    Returns (Ecp_max, E8_max, dt, ratio).\n    \"\"\"\n    # Compute mu_max for both stencils\n    mu_max_cp = max_mu(mu_compact)\n    mu_max_e8 = max_mu(mu_explicit8)\n\n    # Most restrictive nu_max across stencils\n    nu_max_cp = 2.0 / np.sqrt(mu_max_cp) if mu_max_cp > 0 else np.inf\n    nu_max_e8 = 2.0 / np.sqrt(mu_max_e8) if mu_max_e8 > 0 else np.inf\n    nu_max_global = min(nu_max_cp, nu_max_e8)\n\n    c_max = max(c_values)\n    # dt/h with safety factor across both stencils and heterogeneous c\n    dt_over_h = safety * (nu_max_global / c_max)\n    dt = dt_over_h * h  # seconds\n\n    # Evaluate errors\n    Ecp_max = 0.0\n    E8_max = 0.0\n    for c in c_values:\n        nu_loc = c * dt_over_h\n        for theta in theta_values:\n            mu_cp = float(mu_compact(theta))\n            mu_e8 = float(mu_explicit8(theta))\n            # clamp mu to nonnegative\n            mu_cp = max(mu_cp, 0.0)\n            mu_e8 = max(mu_e8, 0.0)\n\n            r_cp = phase_velocity_ratio(mu_cp, theta, nu_loc)\n            r_e8 = phase_velocity_ratio(mu_e8, theta, nu_loc)\n\n            e_cp = abs(r_cp - 1.0)\n            e_e8 = abs(r_e8 - 1.0)\n\n            if e_cp > Ecp_max:\n                Ecp_max = e_cp\n            if e_e8 > E8_max:\n                E8_max = e_e8\n\n    ratio = (E8_max / Ecp_max) if Ecp_max > 0 else np.inf\n    return Ecp_max, E8_max, dt, ratio\n\ndef solve():\n    # Test Case A parameters\n    h_A = 10.0  # meters\n    c_values_A = [2000.0, 3500.0, 5000.0]  # m/s\n    theta_values = [0.1, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]  # radians\n\n    # Test Case B parameters\n    h_B = 10.0  # meters\n    c_values_B = [1500.0, 6000.0]  # m/s\n\n    # Compute metrics for A and B\n    Ecp_A, E8_A, dt_A, R_A = compute_case_metrics(h_A, c_values_A, theta_values, safety=0.9)\n    Ecp_B, E8_B, dt_B, R_B = compute_case_metrics(h_B, c_values_B, theta_values, safety=0.9)\n\n    results = [Ecp_A, E8_A, dt_A, R_A, Ecp_B, E8_B, dt_B, R_B]\n    print(f\"[{','.join(map(lambda x: f'{x}', results))}]\")\n\nsolve()\n```", "id": "3594271"}]}