{"hands_on_practices": [{"introduction": "在我们组装全局系统之前，必须首先正确计算单个单元的贡献。这个练习 [@problem_id:3600322] 将引导你完成从弱形式定义推导单元质量矩阵的基本过程，并使用等参映射和数值积分。通过这个实践，你将巩固对如何将连续积分转化为离散矩阵的理解，这是有限元方法的一块基石。", "problem": "考虑计算地震学中在三维域上使用的标量声波方程，其中采用三线性六面体单元的半离散有限元法会产生一个质量矩阵。设质量双线性形式的弱形式为密度加权内积的逐单元积分，因此一致单元质量矩阵满足 $M_e = \\left[m_{ij}^{(e)}\\right]$，其项为 $m_{ij}^{(e)} = \\int_{\\Omega_e} \\rho(\\boldsymbol{x}) N_i(\\boldsymbol{x}) N_j(\\boldsymbol{x}) \\, \\mathrm{d}V$，其中 $N_i$ 是单元 $\\Omega_e$ 上的三线性形函数。使用从参考立方体 $\\hat{\\Omega} = [-1,1]^3$ 到物理六面体的等参映射 $\\boldsymbol{x}(\\xi,\\eta,\\zeta)$，并将雅可比行列式表示为 $J(\\xi,\\eta,\\zeta) = \\det\\left(\\partial \\boldsymbol{x} / \\partial (\\xi,\\eta,\\zeta)\\right)$。\n\n任务：\n1) 从弱形式定义 $m_{ij}^{(e)} = \\int_{\\Omega_e} \\rho N_i N_j \\, \\mathrm{d}V$ 和等参变换出发，推导 $M_e$ 的显式张量积 $2 \\times 2 \\times 2$ 高斯-勒让德求积公式，并将其写成紧凑的矩阵形式，该形式展示了对 8 个求积点 $(\\xi_a,\\eta_b,\\zeta_c) \\in \\{\\pm 1/\\sqrt{3}\\}^3$ 的求和，其中每个维度上的权重均为 1。您的表达式必须明确包含在求积点处求值的形函数向量、在映射后的求积点处求值的密度以及 $J(\\xi,\\eta,\\zeta)$。\n2) 使用第一性原理，讨论在以下两种意义下对角质量集中是精确的，需要对单元映射和材料密度场施加的精确条件：(i) 通过求积计算的一致单元质量的精确性，以及 (ii) 与一致质量相比，对角集中质量矩阵在再现有限元空间中函数的逐单元加权 $L^2$ 积分时的精确性。您的讨论必须清楚地指明，对于具有正求积权重的标准三线性六面体，哪些“精确性”的概念可以成立，哪些不能成立。\n3) 考虑一个矩形域 $\\Omega = [0, 2L_x] \\times [0, L_y] \\times [0, L_z]$，其密度 $\\rho$ 为常数，并由两个轴对齐、全等的三线性六面体单元 $\\Omega_1 = [0, L_x] \\times [0, L_y] \\times [0, L_z]$ 和 $\\Omega_2 = [L_x, 2L_x] \\times [0, L_y] \\times [0, L_z]$ 离散化。在单元级别上通过标准的行和法执行对角质量集中，并进行全局组装。确定与位于 $\\boldsymbol{x} = (L_x, 0, 0)$ 的共享全局角节点相关联的集中全局质量。将您的最终答案表示为关于 $\\rho$、$L_x$、$L_y$ 和 $L_z$ 的单一闭式解析表达式。不要代入数值。无需四舍五入。最终表达式中不要包含单位；但是，将 $\\rho$ 解释为以 $\\mathrm{kg}\\,\\mathrm{m}^{-3}$ 为单位的质量密度，将 $L_x$、$L_y$、$L_z$ 解释为以 $\\mathrm{m}$ 为单位的长度。", "solution": "该问题提出了一个关于有限元法在计算地震学中应用的质量矩阵的三部分查询。这些任务涉及推导、理论讨论和具体计算。将通过依次解决这三个任务来处理该问题。\n\n### 步骤 1：问题陈述的验证\n给定的条件逐字摘录如下：\n- **方程**：三维域中的标量声波方程。\n- **方法**：半离散有限元法。\n- **单元**：三线性六面体单元 $\\Omega_e$。\n- **质量矩阵弱形式**：$m_{ij}^{(e)} = \\int_{\\Omega_e} \\rho(\\boldsymbol{x}) N_i(\\boldsymbol{x}) N_j(\\boldsymbol{x}) \\, \\mathrm{d}V$，其中 $N_i$ 是三线性形函数。\n- **映射**：从参考立方体 $\\hat{\\Omega} = [-1,1]^3$ 出发的等参映射 $\\boldsymbol{x}(\\xi,\\eta,\\zeta)$。\n- **雅可比行列式**：$J(\\xi,\\eta,\\zeta) = \\det\\left(\\partial \\boldsymbol{x} / \\partial (\\xi,\\eta,\\zeta)\\right)$。\n- **任务 1**：推导单元质量矩阵 $M_e$ 的 $2 \\times 2 \\times 2$ 高斯-勒让德求积公式。求积点为 $(\\xi_a,\\eta_b,\\zeta_c) \\in \\{\\pm 1/\\sqrt{3}\\}^3$，一维权重为 $1$。\n- **任务 2**：讨论在两种指定意义下对角质量集中的精确性条件。\n- **任务 3**：对于一个密度为常数 $\\rho$ 的域 $\\Omega = [0, 2L_x] \\times [0, L_y] \\times [0, L_z]$，该域由两个单元 $\\Omega_1 = [0, L_x] \\times [0, L_y] \\times [0, L_z]$ 和 $\\Omega_2 = [L_x, 2L_x] \\times [0, L_y] \\times [0, L_z]$ 离散化，使用行和法确定共享节点 $\\boldsymbol{x} = (L_x, 0, 0)$ 处的集中全局质量。\n\n问题陈述在科学上基于有限元法的既定理论。它是适定的、客观的且内部一致的。所有术语在计算力学中都是标准的，并且各项任务都是定义明确的数学练习。该问题是可形式化的，并与其所述领域相关。所提供的数据是完整且足以解决所有三个任务的。该问题既非微不足道，也非不适定的。因此，该问题被认为是有效的。\n\n### 任务 1：单元质量矩阵的求积公式\n\n一致单元质量矩阵 $M_e$ 的项 $m_{ij}^{(e)}$ 由物理单元域 $\\Omega_e$ 上的积分给出：\n$$m_{ij}^{(e)} = \\int_{\\Omega_e} \\rho(\\boldsymbol{x}) N_i(\\boldsymbol{x}) N_j(\\boldsymbol{x}) \\, \\mathrm{d}V$$\n使用从参考立方体 $\\hat{\\Omega} = [-1,1]^3$ 到 $\\Omega_e$ 的等参映射 $\\boldsymbol{x} = \\boldsymbol{x}(\\xi, \\eta, \\zeta)$，该积分被变换到参考坐标 $(\\xi, \\eta, \\zeta)$ 中。形函数成为参考单元上的函数，$N_i(\\boldsymbol{x}) = N_i(\\boldsymbol{x}(\\xi, \\eta, \\zeta)) \\equiv \\hat{N}_i(\\xi, \\eta, \\zeta)$，体积元变换为 $\\mathrm{d}V = J(\\xi, \\eta, \\zeta) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta \\, \\mathrm{d}\\zeta$，其中 $J$ 是映射的雅可比行列式。\n积分变为：\n$$m_{ij}^{(e)} = \\int_{-1}^{1} \\int_{-1}^{1} \\int_{-1}^{1} \\rho(\\boldsymbol{x}(\\xi,\\eta,\\zeta)) \\hat{N}_i(\\xi,\\eta,\\zeta) \\hat{N}_j(\\xi,\\eta,\\zeta) J(\\xi,\\eta,\\zeta) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta \\, \\mathrm{d}\\zeta$$\n我们使用 $2 \\times 2 \\times 2$ 张量积高斯-勒让德求积来近似该积分。求积点为 $(\\xi_a, \\eta_b, \\zeta_c)$，其中 $a,b,c \\in \\{1,2\\}$ 且 $\\{\\xi_1, \\xi_2\\} = \\{\\eta_1, \\eta_2\\} = \\{\\zeta_1, \\zeta_2\\} = \\{-1/\\sqrt{3}, 1/\\sqrt{3}\\}$。相应的权重给定为 $w_a = w_b = w_c = 1$。求积点的总数为 8。设一个通用的求积点表示为 $\\boldsymbol{q}_k$，其对应的权重为 $W_k$，其中 $k=1, \\dots, 8$。对于指定的张量积法则，三维权重是一维权重的乘积，因此对于所有的 $k$，$W_k = w_a w_b w_c = 1 \\cdot 1 \\cdot 1 = 1$。\n\n该积分近似为以下和式：\n$$m_{ij}^{(e)} \\approx \\sum_{k=1}^{8} W_k \\left[ \\rho(\\boldsymbol{x}(\\boldsymbol{q}_k)) \\hat{N}_i(\\boldsymbol{q}_k) \\hat{N}_j(\\boldsymbol{q}_k) J(\\boldsymbol{q}_k) \\right]$$\n由于所有 $W_k=1$，并且从现在起省略参考单元上形函数的帽子符号，这可以简化为：\n$$m_{ij}^{(e)} \\approx \\sum_{k=1}^{8} \\rho(\\boldsymbol{x}(\\boldsymbol{q}_k)) J(\\boldsymbol{q}_k) N_i(\\boldsymbol{q}_k) N_j(\\boldsymbol{q}_k)$$\n为了将整个 $8 \\times 8$ 单元质量矩阵 $M_e = [m_{ij}^{(e)}]$ 写成紧凑的矩阵形式，我们定义一个形函数列向量 $\\boldsymbol{N}(\\boldsymbol{q}) = [N_1(\\boldsymbol{q}), N_2(\\boldsymbol{q}), \\dots, N_8(\\boldsymbol{q})]^T$。项 $N_i(\\boldsymbol{q}_k) N_j(\\boldsymbol{q}_k)$ 是外积 $\\boldsymbol{N}(\\boldsymbol{q}_k) \\boldsymbol{N}(\\boldsymbol{q}_k)^T$ 的 $(i,j)$ 项。\n因此，单元质量矩阵是 8 个秩为 1 的矩阵之和，每个矩阵对应一个求积点：\n$$M_e \\approx \\sum_{k=1}^{8} \\rho(\\boldsymbol{x}(\\boldsymbol{q}_k)) J(\\boldsymbol{q}_k) \\boldsymbol{N}(\\boldsymbol{q}_k) \\boldsymbol{N}(\\boldsymbol{q}_k)^T$$\n为了更明确地展示张量积结构，设求积点为 $\\boldsymbol{q}_{abc} = (\\xi_a, \\eta_b, \\zeta_c)$，其中 $a,b,c \\in \\{1,2\\}$ 且权重 $w_a=w_b=w_c=1$。质量矩阵公式为：\n$$M_e \\approx \\sum_{a=1}^2 \\sum_{b=1}^2 \\sum_{c=1}^2 w_a w_b w_c \\rho(\\boldsymbol{x}(\\boldsymbol{q}_{abc})) J(\\boldsymbol{q}_{abc}) \\boldsymbol{N}(\\boldsymbol{q}_{abc}) \\boldsymbol{N}(\\boldsymbol{q}_{abc})^T$$\n鉴于权重为 1，公式为：\n$$M_e \\approx \\sum_{a=1}^2 \\sum_{b=1}^2 \\sum_{c=1}^2 \\rho(\\boldsymbol{x}(\\xi_a,\\eta_b,\\zeta_c)) J(\\xi_a,\\eta_b,\\zeta_c) \\boldsymbol{N}(\\xi_a,\\eta_b,\\zeta_c) \\boldsymbol{N}(\\xi_a,\\eta_b,\\zeta_c)^T$$\n\n### 任务 2：精确质量集中的条件\n\n(i) **通过求积计算的一致单元质量的精确性。**\n$2 \\times 2 \\times 2$ 高斯-勒让德求积法则对于被积函数是每个变量独立地为至多 $2n-1 = 2(2)-1=3$ 次多项式的情况是精确的。在参考坐标中，$m_{ij}^{(e)}$ 的被积函数是 $f(\\xi,\\eta,\\zeta) = \\rho(\\boldsymbol{x}(\\xi,\\eta,\\zeta)) J(\\xi,\\eta,\\zeta) N_i(\\xi,\\eta,\\zeta) N_j(\\xi,\\eta,\\zeta)$。\n三线性形函数 $N_i$ 是每个变量中次数为 1 的多项式（例如，$N_1 = \\frac{1}{8}(1-\\xi)(1-\\eta)(1-\\zeta)$）。因此，乘积 $N_i N_j$ 是每个变量中次数至多为 2 的多项式（例如，对于 $i \\neq j$，$N_1 N_8 = \\frac{1}{64}(1-\\xi^2)(1-\\eta^2)(1-\\zeta^2)$）。由于次数 2  3，被积函数中形函数乘积部分被精确积分。\n映射为 $\\boldsymbol{x}(\\xi,\\eta,\\zeta) = \\sum_k \\boldsymbol{x}_k N_k(\\xi,\\eta,\\zeta)$。雅可比矩阵 $\\partial\\boldsymbol{x}/\\partial(\\xi,\\eta,\\zeta)$ 的项涉及 $N_k$ 的导数，这些导数是双线性的（例如，$\\partial N_k/\\partial\\xi$ 在 $\\eta$ 和 $\\zeta$ 中是线性的）。雅可比行列式 $J$ 是这样一个 $3 \\times 3$ 双线性函数矩阵的行列式，其结果是 $\\xi, \\eta, \\zeta$ 的一个多项式，其在每个变量中的次数最高可达 6。这远高于该求积法则能处理的 3 次。\n因此，该积分通常不是精确的。求积要精确的精确条件是，乘积 $\\rho(\\boldsymbol{x}(\\xi,\\eta,\\zeta)) J(\\xi,\\eta,\\zeta)$ 的形式必须使得总被积函数 $f(\\xi,\\eta,\\zeta)$ 在每个变量中是次数至多为 3 的多项式。一个简单的充分条件是密度 $\\rho$ 和雅可比行列式 $J$ 都是常数。当映射是仿射的时，$J$ 为常数，对于六面体单元，这意味着它是一个平行六面体（矩形砖块是一个特例）。常数 $\\rho$ 是一种材料属性。在这些条件下，被积函数的多项式次数仅由 $N_i N_j$ 决定，它在每个变量中次数至多为 2，此时积分是精确的。\n\n(ii) **对角集中质量矩阵的精确性。**\n标准的行和法集中质量矩阵 $M_L$ 的对角项为 $(M_L)_{ii} = \\sum_j m_{ij}^{(e)}$，非对角项为零。根据形函数的单位分解性质 $\\sum_j N_j(\\boldsymbol{x}) = 1$，对角项等价于节点质量：\n$$(M_L)_{ii} = \\sum_{j=1}^8 \\int_{\\Omega_e} \\rho N_i N_j \\, \\mathrm{d}V = \\int_{\\Omega_e} \\rho N_i \\left( \\sum_{j=1}^8 N_j \\right) \\, \\mathrm{d}V = \\int_{\\Omega_e} \\rho N_i \\, \\mathrm{d}V$$\n问题要求的是在何种条件下，集中法在再现有限元空间中函数 $u_h(\\boldsymbol{x}) = \\sum_i u_i N_i(\\boldsymbol{x})$ 的逐单元加权 $L^2$ 积分方面是精确的。设 $\\boldsymbol{u}$ 是节点值 $u_i$ 的向量。用一致质量矩阵计算的积分是 $\\boldsymbol{u}^T M_e \\boldsymbol{u}$。用集中质量矩阵计算的相同量是 $\\boldsymbol{u}^T M_L \\boldsymbol{u}$。\n精确性要求对于节点值 $\\boldsymbol{u}$ 的任意选择，都有 $\\boldsymbol{u}^T M_e \\boldsymbol{u} = \\boldsymbol{u}^T M_L \\boldsymbol{u}$ 成立。\n$$\\sum_{i,j} u_i m_{ij}^{(e)} u_j = \\sum_i u_i^2 (M_L)_{ii} = \\sum_i u_i^2 \\sum_j m_{ij}^{(e)}$$\n这个等式必须对所有 $\\boldsymbol{u}$ 成立。通过展开和式并比较像 $u_i u_j$（$i \\neq j$）这样的项的系数，我们发现该等式当且仅当所有非对角项 $m_{ij}^{(e)}$（对于 $i \\neq j$）都为零时成立。这意味着一致质量矩阵 $M_e$ 必须是对角的。\n条件 $m_{ij}^{(e)} = \\int_{\\Omega_e} \\rho N_i N_j \\, \\mathrm{d}V = 0$（对于 $i \\neq j$）意味着形函数 $N_i$ 必须是关于以 $\\rho(\\boldsymbol{x})$ 为权重的内积的正交集。标准的拉格朗日型形函数，包括三线性函数，不是正交的；它们的支集显著重叠，导致非对角（在这种情况下是稠密）的一致质量矩阵 $M_e$。按规定使用正求积权重进一步确保了计算出的 $M_e$ 不是对角的。\n因此，对于标准的三线性六面体，不存在能使质量集中在这种意义上精确的关于单元映射或密度场的非平凡条件。集中法本质上是一种改变此二次型的近似，尽管它确实保留了总单元质量（即 $\\boldsymbol{1}^T M_e \\boldsymbol{1} = \\boldsymbol{1}^T M_L \\boldsymbol{1}$）。\n\n### 任务 3：共享节点处集中质量的计算\n\n我们需要计算节点 $P = (L_x, 0, 0)$ 处的全局集中质量。这个节点由两个单元共享，$\\Omega_1 = [0, L_x] \\times [0, L_y] \\times [0, L_z]$ 和 $\\Omega_2 = [L_x, 2L_x] \\times [0, L_y] \\times [0, L_z]$。一个节点上的全局集中质量是所有共享该节点的单元的局部集中质量贡献之和。\n$$M_P^{\\text{global}} = \\sum_{e \\in \\{\\Omega_1, \\Omega_2\\}} (m_{ii}^{(e)})_L$$\n其中 $i$ 是节点 $P$ 在单元 $e$ 中的局部索引。\n单元 $e$ 中节点 $i$ 的局部集中质量由 $(m_{ii}^{(e)})_L = \\int_{\\Omega_e} \\rho N_i^{(e)} \\, \\mathrm{d}V$ 给出。\n\n来自单元 $\\Omega_1$ 的贡献：\n单元 $\\Omega_1$ 是一个尺寸为 $L_x \\times L_y \\times L_z$ 的矩形砖块。密度 $\\rho$ 是常数。来自 $\\Omega_1$ 的节点 $P$ 处的集中质量是 $\\rho \\int_{\\Omega_1} N_P^{(1)} \\, \\mathrm{d}V$，其中 $N_P^{(1)}$ 是在 $\\Omega_1$ 中于 $P$ 点为 1 的局部形函数。\n我们可以通过变换到参考单元 $\\hat{\\Omega}=[-1,1]^3$ 来计算这个积分。从 $\\hat{\\Omega}$ 到 $\\Omega_1$ 的映射是 $x=\\frac{L_x}{2}(1+\\xi)$, $y=\\frac{L_y}{2}(1+\\eta)$, $z=\\frac{L_z}{2}(1+\\zeta)$。雅可比行列式是常数：$J = \\frac{L_x L_y L_z}{8}$。\n节点 $P=(L_x,0,0)$ 对应于参考坐标 $(\\xi,\\eta,\\zeta)=(1,-1,-1)$。这个节点的形函数是 $N_P^{(1)}(\\xi,\\eta,\\zeta) = \\frac{1}{8}(1+\\xi)(1-\\eta)(1-\\zeta)$。\n积分为：\n$$\\int_{\\Omega_1} N_P^{(1)} \\, \\mathrm{d}V = \\int_{-1}^1 \\int_{-1}^1 \\int_{-1}^1 N_P^{(1)}(\\xi,\\eta,\\zeta) J \\, \\mathrm{d}\\xi \\mathrm{d}\\eta \\mathrm{d}\\zeta$$\n$$= J \\int_{-1}^1 \\int_{-1}^1 \\int_{-1}^1 \\frac{1}{8}(1+\\xi)(1-\\eta)(1-\\zeta) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta \\mathrm{d}\\zeta$$\n$$= \\frac{J}{8} \\left( \\int_{-1}^1 (1+\\xi) \\mathrm{d}\\xi \\right) \\left( \\int_{-1}^1 (1-\\eta) \\mathrm{d}\\eta \\right) \\left( \\int_{-1}^1 (1-\\zeta) \\mathrm{d}\\zeta \\right)$$\n每个一维积分的计算结果都为 2。例如，$\\int_{-1}^1 (1+u) \\mathrm{d}u = [u+u^2/2]_{-1}^1 = 2$。\n所以，$\\int_{\\Omega_1} N_P^{(1)} \\, \\mathrm{d}V = \\frac{J}{8} (2)(2)(2) = J = \\frac{L_x L_y L_z}{8}$。\n这是单元体积的 1/8，$\\text{Vol}(\\Omega_1) = L_x L_y L_z$。\n来自 $\\Omega_1$ 的质量贡献是 $(m^{(1)})_L = \\rho \\frac{\\text{Vol}(\\Omega_1)}{8} = \\frac{\\rho L_x L_y L_z}{8}$。\n\n来自单元 $\\Omega_2$ 的贡献：\n单元 $\\Omega_2$ 与 $\\Omega_1$ 全等，具有相同的尺寸 $L_x \\times L_y \\times L_z$ 和相同的常数密度 $\\rho$。节点 $P=(L_x,0,0)$ 也是 $\\Omega_2$ 的一个角节点。通过相同的论证，相应的形函数 $N_P^{(2)}$ 在 $\\Omega_2$ 上的积分是该单元体积的 1/8。\n来自 $\\Omega_2$ 的质量贡献是 $(m^{(2)})_L = \\rho \\frac{\\text{Vol}(\\Omega_2)}{8} = \\frac{\\rho L_x L_y L_z}{8}$。\n\n总全局质量：\n节点 P 处的总集中质量是来自两个单元的贡献之和：\n$$M_P^{\\text{global}} = (m^{(1)})_L + (m^{(2)})_L = \\frac{\\rho L_x L_y L_z}{8} + \\frac{\\rho L_x L_y L_z}{8} = 2 \\frac{\\rho L_x L_y L_z}{8} = \\frac{\\rho L_x L_y L_z}{4}$$\n指定节点处的集中全局质量的最终表达式是 $\\frac{\\rho L_x L_y L_z}{4}$。", "answer": "$$\\boxed{\\frac{\\rho L_x L_y L_z}{4}}$$", "id": "3600322"}, {"introduction": "现实世界中的地球物理问题涉及数百万个自由度，产生巨大但稀疏的全局矩阵。高效地存储这些矩阵对计算性能至关重要。这个练习 [@problem_id:3600273] 要求你设计一种算法，用于预先分配压缩稀疏行（CSR）格式矩阵所需的内存，而无需实际构建矩阵本身。掌握这项技能可以避免代价高昂的动态内存重新分配，是编写高性能有限元代码的关键一步。", "problem": "您的任务是设计一种算法并实现一个可运行的程序，用于为在计算地球物理学中使用的、基于结构化六面体网格的三维（$3$-D）高阶$Q_p$有限元所产生的全局刚度矩阵预分配压缩稀疏行（CSR）存储。目标是在不构造矩阵元素本身的情况下，计算全局矩阵的逐行非零元数量，并基于单元重叠和基函数局部性的基本原理来论证算法的复杂度。\n\n从以下基本概念出发：\n\n- 用于标量二阶椭圆算子（例如，$-\\nabla \\cdot (\\kappa \\nabla u) = f$ 并附带适当的边界条件）的Galerkin有限元方法会产生一个全局稀疏矩阵，其元素通过对单元贡献求和得到。全局自由度$I$和$J$之间的矩阵元素为非零，当且仅当存在至少一个单元，在该单元上它们对应的基函数的支集重叠并产生非零的双线性形式。\n- 三维中的一个节点式$Q_p$单元每个单元有$(p+1)^3$个局部自由度，并且每个基函数的支集被限制在包含其节点的单元内。\n- 在一个沿三个坐标方向分别有$n_x$、$n_y$和$n_z$个单元的结构化网格中，全局节点网格沿相应轴线分别有$N_x = n_x p + 1$、$N_y = n_y p + 1$和$N_z = n_z p + 1$个节点。全局节点索引是三元组$(i,j,k)$，其中$i \\in \\{0,\\dots,N_x-1\\}$，$j \\in \\{0,\\dots,N_y-1\\}$，以及$k \\in \\{0,\\dots,N_z-1\\}$。\n\n仅使用这些基础，推导出一个公式，用于计算与全局节点$(i,j,k)$相关联的全局矩阵每一行中的非零元数量，该公式用每个坐标方向上的关联单元数量来表示。最终得出一个以$p$和每个方向上局部关联单元的重数表示的封闭形式表达式。然后，设计一个算法，通过迭代所有全局节点并应用推导出的公式，来计算CSR行指针数组和非零元的总数，而无需显式构建邻接集。根据$n_x$、$n_y$、$n_z$和$p$的函数，用$\\mathcal{O}$记号论证算法的复杂度。\n\n实现要求：\n\n- 您必须实现一个程序，对每个测试用例计算：\n    - 全局矩阵中的非零元总数$nnz$，\n    - 最大行非零元数量，\n    - 最小行非零元数量，\n    - 一个布尔一致性标志，如果封闭形式的行计数与在一个固定的、确定性的行样本上进行的直接单元并集枚举结果一致，则该标志为真。\n- 您不得构造全局矩阵的元素或完整的列索引数组；仅预分配计数和CSR行指针的长度。\n\n测试套件：\n\n在以下参数集$(n_x,n_y,n_z,p)$上评估您的实现：\n\n- 情况 1: $(n_x,n_y,n_z,p) = (1,1,1,4)$。\n- 情况 2: $(n_x,n_y,n_z,p) = (2,2,2,3)$。\n- 情况 3: $(n_x,n_y,n_z,p) = (10,1,1,1)$。\n- 情况 4: $(n_x,n_y,n_z,p) = (3,2,1,5)$。\n\n输出规范：\n\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，格式为一个由方括号括起来的、逗号分隔的列表的列表。每个内部列表必须为$[nnz,max_row,min_row,consistency]$的形式，其中$nnz$、$max_row$和$min_row$是整数，$consistency$是布尔值。例如，输出格式必须完全像$[[nnz_1,max_1,min_1,consistency_1],[nnz_2,max_2,min_2,consistency_2],[nnz_3,max_3,min_3,consistency_3],[nnz_4,max_4,min_4,consistency_4]]$。\n\n此任务不涉及任何物理单位、角度单位或百分比；所有输出均为无单位的整数或布尔值。您的算法和程序必须具有通用性，并且仅依赖于从基函数局部性和单元重叠进行的原理性推导。特别是，您对复杂度的论证必须基于以下事实：一个全局自由度$(i,j,k)$与包含$(i,j,k)$的所有单元的并集内的所有自由度耦合，并且该并集的大小由每个坐标方向上的重叠重数决定。", "solution": "在有限元方法（FEM）模拟中，为稀疏矩阵预分配存储空间是提高计算效率的关键步骤。我们的任务是确定一个在结构化网格上使用$Q_p$六面体单元离散化的三维问题中，全局刚度矩阵每行的非零元（$nnz$）数量。这使得我们能够在不实际组装矩阵的情况下，构造压缩稀疏行（CSR）的`row_pointer`数组。\n\n### 基本原理\n\n在有限元方法（FEM）的背景下，全局刚度矩阵$\\mathbf{K}$是由单元级刚度矩阵$\\mathbf{k}^e$组装而成的。全局矩阵中对应于全局自由度（DoFs）$I$和$J$的元素$K_{IJ}$为非零，当且仅当与这些自由度相关联的基函数$\\phi_I$和$\\phi_J$的支集重叠，且它们的相互作用积分为非零。对于标准的节点式$Q_p$单元，基函数$\\phi_I$的支集是共享节点$I$的所有单元的并集。源于像拉普拉斯算子这样的二阶椭圆算子的相互作用积分，在节点$I$和$J$属于至少一个共同单元时为非零。因此，与自由度$I$耦合的自由度集合（即第$I$行中的非零元）对应于与节点$I$关联的单元并集内所有唯一自由度的集合。\n\n### 行非零元数量公式的推导\n\n设计算域由一个$n_x \\times n_y \\times n_z$的结构化六面体单元网格离散化。对于$Q_p$单元，其中$p$是多项式阶数，每个单元的每条边上有$p+1$个节点。这导致了一个包含$N = N_x \\times N_y \\times N_z$个节点的全局网格，其中$N_x = n_x p + 1$，$N_y = n_y p + 1$，以及$N_z = n_z p + 1$。每个全局节点对应一个唯一的自由度，由一个三元组$(i, j, k)$索引，其中$i \\in \\{0, \\dots, N_x-1\\}$，$j \\in \\{0, \\dots, N_y-1\\}$，$k \\in \\{0, \\dots, N_z-1\\}$。\n\n与节点$(i,j,k)$对应的行中的非零元数量，记为$R(i,j,k)$，是围绕节点$(i,j,k)$的单元片（patch）中所有唯一节点的总数。这个单元片的大小和形状取决于节点相对于单元边界的位置。\n\n一个关键的洞见是，由于结构化网格和$Q_p$基函数都具有张量积的性质，问题可以按坐标方向解耦。让我们定义$m_x(i)$、$m_y(j)$和$m_z(k)$为节点$(i,j,k)$在每个相应方向上所关联的单元“层”数。\n\n1.  **一个方向上的重数（例如，x方向）：** 一个全局x索引为$i$的节点，如果其索引不是$p$的倍数，则它位于单元块的内部（沿x轴）。如果$i$是$p$的倍数（即$i = q \\cdot p$对于某个整数$q$），并且它不在全局域的边界上（即$0  i  N_x-1$），那么它位于两个相邻单元的交界面上。\n    - 内部单元交界面的x索引为$\\{p, 2p, \\dots, (n_x-1)p\\}$。\n    - 因此，如果$i$是内部交界面索引，则重数$m_x(i)$为$2$，否则为$1$。\n    $$ m_x(i) = \\begin{cases} 2  \\text{若 } i \\in \\{p, 2p, \\dots, (n_x-1)p\\} \\\\ 1  \\text{否则} \\end{cases} $$\n    对于$m_y(j)$和$m_z(k)$，关于$n_y, p$和$n_z, p$也适用类似的定义。\n\n2.  **耦合的节点片：** 一个节点$(i,j,k)$与一个$m_x(i) \\times m_y(j) \\times m_z(k)$大小的单元片相关联。这个单元片形成一个“宏单元”。这个宏单元中的节点总数决定了行非零元数量。\n\n3.  **计算节点片中的节点数：** 在一维中，一个由$m_x(i)$个相邻单元组成的单元片跨越$m_x(i) \\cdot p + 1$个节点。通过张量积结构将其扩展到三维，与节点$(i,j,k)$关联的单元片中唯一节点的总数是在每个方向上所跨越节点数的乘积。\n\n这导出了节点$(i,j,k)$所在行的非零元数量的封闭形式表达式：\n$$ R(i,j,k) = (m_x(i)p + 1) \\cdot (m_y(j)p + 1) \\cdot (m_z(k)p + 1) $$\n\n例如，一个深处于单元内部且不在任何单元边界上的节点，其$(m_x, m_y, m_z) = (1,1,1)$，给出$R=(p+1)^3$个非零元（即该单个单元的所有节点）。一个位于八个内部单元共享顶点上的节点，其$(m_x, m_y, m_z) = (2,2,2)$，给出$R=(2p+1)^3$个非零元。该公式正确地处理了所有情况，包括全局域边界上的节点，其相应的重数始终为$1$。\n\n### 算法设计与复杂度分析\n\n该算法利用推导出的公式来计算所需的度量，而无需构建任何显式的邻接信息。\n\n1.  **初始化：** 给定参数$(n_x, n_y, n_z, p)$，计算全局节点网格维度$N_x, N_y, N_z$。为每个方向预先计算交界面索引集，以实现高效查找。初始化`total_nnz`、`max_row_count`和`min_row_count`。\n\n2.  **迭代：** 遍历从$(0,0,0)$到$(N_x-1, N_y-1, N_z-1)$的每个全局节点$(i,j,k)$。在每次迭代中：\n    a. 通过检查索引$i,j,k$是否属于预计算的交界面集，来确定重数$m_x(i)$, $m_y(j)$, $m_z(k)$。这是一个$\\mathcal{O}(1)$的操作。\n    b. 应用公式计算该行的非零元数量$R(i,j,k)$。\n    c. 将此计数加到`total_nnz`中，并更新`max_row_count`和`min_row_count`。\n\n3.  **一致性检查：** 为了验证公式，对一个固定的、确定性的节点样本使用直接枚举法。对于一个样本节点$(i,j,k)$：\n    a. 识别出关联单元块，其大小为$m_x(i) \\times m_y(j) \\times m_z(k)$。\n    b. 显式生成该单元块内包含的所有唯一节点索引的集合。\n    c. 该集合的大小即为`direct_count`。\n    d. 将`direct_count`与`formula_count`进行比较。如果对于任何样本节点它们不匹配，则将一致性标志设置为`False`。\n\n4.  **复杂度分析：**主要的计算工作在于遍历所有全局节点的三重嵌套循环。节点总数为$N = N_x N_y N_z = (n_x p + 1)(n_y p + 1)(n_z p + 1)$。在循环内部，所有操作都是$\\mathcal{O}(1)$的。因此，算法的时间复杂度与总自由度数呈线性关系：\n    $$ \\mathcal{O}(N) = \\mathcal{O}((n_x p + 1)(n_y p + 1)(n_z p + 1)) $$\n    对于$n_x, n_y, n_z \\gg 1$的大型网格，这可以简化为$\\mathcal{O}(n_x n_y n_z p^3)$。一致性检查是在一个小的、常数数量的样本上执行的，其每个样本的复杂度为$\\mathcal{O}(p^3)$，这不会改变总体的渐进复杂度。\n\n这种方法为预分配全局刚度矩阵组装所需的CSR数据结构提供了一种高效且理论上可靠的方法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main entry point to solve the problem for all specified test cases.\n    \"\"\"\n    test_cases = [\n        (1, 1, 1, 4),\n        (2, 2, 2, 3),\n        (10, 1, 1, 1),\n        (3, 2, 1, 5),\n    ]\n\n    case_results = []\n    for case in test_cases:\n        nnz, max_r, min_r, cons = solve_case(*case)\n        # Format each result as '[nnz,max_r,min_r,Consistency]'\n        case_results.append(f\"[{nnz},{max_r},{min_r},{'True' if cons else 'False'}]\")\n\n    # Final output must be a single line in the specified format.\n    print(f\"[{','.join(case_results)}]\")\n\n\ndef solve_case(nx, ny, nz, p):\n    \"\"\"\n    Computes CSR pre-allocation data for a single set of parameters.\n\n    Args:\n        nx (int): Number of elements along the x-axis.\n        ny (int): Number of elements along the y-axis.\n        nz (int): Number of elements along the z-axis.\n        p (int): Polynomial degree of the Qp elements.\n\n    Returns:\n        tuple: (total_nnz, max_row_count, min_row_count, is_consistent)\n    \"\"\"\n    if p == 0:  # Gracefully handle Q0 elements, though problem implies p>=1\n        # For Q0, each element is typically one DoF. The global matrix would\n        # be diagonal if using a Discontinuous Galerkin method. Assuming\n        # cell-centered DoFs with no coupling for simplicity.\n        num_dof = nx * ny * nz\n        return num_dof, 1, 1, True\n\n    # Calculate global grid dimensions\n    Nx = nx * p + 1\n    Ny = ny * p + 1\n    Nz = nz * p + 1\n\n    # Define sets of interface indices for O(1) average time lookup\n    interfaces_x = {k * p for k in range(1, nx)}\n    interfaces_y = {k * p for k in range(1, ny)}\n    interfaces_z = {k * p for k in range(1, nz)}\n\n    total_nnz = 0\n    max_row_count = 0\n    # Initialize min_row_count to a value guaranteed to be larger than any possible count\n    min_row_count = (2 * p + 1)**3 + 1\n\n    # Main loop to compute metrics by iterating over all global nodes\n    for i in range(Nx):\n        for j in range(Ny):\n            for k in range(Nz):\n                # Determine multiplicities based on node position\n                m_x = 2 if i in interfaces_x else 1\n                m_y = 2 if j in interfaces_y else 1\n                m_z = 2 if k in interfaces_z else 1\n\n                # Calculate row nonzero count using the derived formula\n                row_nnz = (m_x * p + 1) * (m_y * p + 1) * (m_z * p + 1)\n\n                # Update aggregates\n                total_nnz += row_nnz\n                if row_nnz > max_row_count:\n                    max_row_count = row_nnz\n                if row_nnz  min_row_count:\n                    min_row_count = row_nnz\n    \n    # Perform consistency check\n    is_consistent = check_consistency(nx, ny, nz, p, interfaces_x, interfaces_y, interfaces_z)\n\n    return int(total_nnz), max_row_count, min_row_count, is_consistent\n\n\ndef check_consistency(nx, ny, nz, p, interfaces_x, interfaces_y, interfaces_z):\n    \"\"\"\n    Validates the formula against a direct element-union enumeration on a sample of nodes.\n    \"\"\"\n    Nx, Ny, Nz = nx * p + 1, ny * p + 1, nz * p + 1\n    \n    # Define a deterministic, fixed set of sample nodes to test\n    sample_nodes = {(0, 0, 0)}\n    # Add nodes near origin\n    sample_nodes.add((min(1, Nx - 1), 0, 0))\n    sample_nodes.add((0, min(1, Ny - 1), 0))\n    sample_nodes.add((0, 0, min(1, Nz - 1)))\n    # Add nodes on first internal interface\n    if nx > 1: sample_nodes.add((p, min(1, Ny - 1), 0))\n    if ny > 1: sample_nodes.add((min(1, Nx - 1), p, 0))\n    if nz > 1: sample_nodes.add((0, 0, p))\n    # Add nodes on interface intersections\n    if nx > 1 and ny > 1: sample_nodes.add((p, p, 0))\n    if nx > 1 and ny > 1 and nz > 1: sample_nodes.add((p, p, p))\n\n    for i, j, k in sample_nodes:\n        # Ensure sample node is within the grid dimensions\n        if not (i  Nx and j  Ny and k  Nz):\n            continue\n\n        # 1. Calculate count using the formula\n        m_x = 2 if i in interfaces_x else 1\n        m_y = 2 if j in interfaces_y else 1\n        m_z = 2 if k in interfaces_z else 1\n        formula_count = (m_x * p + 1) * (m_y * p + 1) * (m_z * p + 1)\n\n        # 2. Calculate count using direct element-union enumeration\n        # Find the starting element index of the patch of incident elements\n        ex_start = i // p - 1 if m_x == 2 else i // p\n        ey_start = j // p - 1 if m_y == 2 else j // p\n        ez_start = k // p - 1 if m_z == 2 else k // p\n\n        # Define the ranges of incident elements\n        ex_range = range(ex_start, ex_start + m_x)\n        ey_range = range(ey_start, ey_start + m_y)\n        ez_range = range(ez_start, ez_start + m_z)\n\n        # Build the union of all nodes from all incident elements\n        union_of_nodes = set()\n        for ex in ex_range:\n            for ey in ey_range:\n                for ez in ez_range:\n                    for inode in range(ex * p, (ex + 1) * p + 1):\n                        for jnode in range(ey * p, (ey + 1) * p + 1):\n                            for knode in range(ez * p, (ez + 1) * p + 1):\n                                union_of_nodes.add((inode, jnode, knode))\n        \n        direct_count = len(union_of_nodes)\n\n        if formula_count != direct_count:\n            return False\n\n    return True\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3600273"}, {"introduction": "为了解决最大规模的问题，我们必须使用像消息传递接口（Message Passing Interface, MPI）这样的技术，将计算工作分布在多个处理器上。最后一个练习 [@problem_id:3600303] 探讨了并行组装的复杂性，特别是针对非连续伽辽金（Discontinuous Galerkin, DG）方法。你将模拟一个并行环境，以确保无论处理器数量多少，全局矩阵的组装结果都完全相同，这是任何并行数值代码的关键验证步骤。", "problem": "考虑一个代表区域地壳区块热传导的稳态标量扩散模型。温度场 $u$ 的控制定律是椭圆偏微分方程 $-\\nabla \\cdot \\left(\\kappa \\nabla u\\right) = s$，该方程定义在一个被划分为有限数量不重叠矩形单元的矩形域上。目标是使用间断伽辽金（DG）方法，特别是对称内部罚函数伽辽金（SIPG）变体，来组装与间断有限元离散化相关的全局刚度矩阵 $A$。组装方式需确保在单进程上或在通过模拟消息传递接口（MPI）光环交换的多个进程上进行时，结果可被证明是完全相同的。程序必须是自包含的，并产生可验证的输出。\n\n从基本基础开始：扩散方程的弱形式和内部罚函数 DG 方法的设计。对于将域划分为单元 $K$ 的情况，弱形式通过将方程乘以一个测试函数 $v$ 并在每个单元上进行分部积分来导出。在 SIPG 公式中，双线性形式既包含体项，也包含相邻单元之间的面通量项。对于分片常数基函数（记为 DG$_0$），体积梯度项会消失，因为常数场的梯度为零。由此产生的双线性形式简化为对跨单元面的未知量跳跃的惩罚项。令 $\\mathcal{F}_{\\mathrm{int}}$ 为内部面的集合，$\\mathcal{F}_{\\mathrm{bnd}}$ 为边界面的集合。对于由相邻单元 $K^{-}$ 和 $K^{+}$ 共享的内部面 $F$，定义跳跃 $[[u]] = u^- - u^+$ 和一个罚函数缩放。在最简单的均匀设置中，该缩放简化为一个恒定权重 $w_{F}$。对于单元 $K$ 上的边界面 $F$，以罚函数方式施加齐次狄利克雷边界条件，其贡献与迹值成正比。在此设置中，采用均匀单位间距和单位热导率，每个面的贡献产生整数权重。\n\n您必须实现以下内容：\n\n- 构建一个由 $N_x \\times N_y$ 个单元组成的均匀矩形网格，单元尺寸为单位尺寸（$1 \\times 1$）。假设标量热导率 $\\kappa = 1$ 为常数，并使用单位罚函数系数 $\\gamma = 1$。对于 DG$_0$，SIPG 双线性形式简化为仅对面进行组装，其中每个内部面对其耦合的两个相邻单元的局部 $2 \\times 2$ 面矩阵贡献权重 $w = 1$，每个边界面对单个相邻单元贡献对角罚函数权重 $w = 1$。\n- 根据以下规则组装全局刚度矩阵 $A$：对于连接全局单元索引 $i$ 和 $j$ 的每个内部面 $F$，将 $+w$ 加到 $A_{ii}$ 和 $A_{jj}$，并将 $-w$ 加到 $A_{ij}$ 和 $A_{ji}$。对于与单元 $i$ 相邻的每个边界面，将 $+w$ 加到 $A_{ii}$。这将生成一个对称正定矩阵，反映了由带狄利克雷锚定的面耦合所产生的图拉普拉斯结构。\n- 实现两种组装策略：\n  1. 单进程全局组装，该策略迭代所有面并直接将贡献累加到 $A$ 中。\n  2. 在 $p_x \\times p_y$ 个进程上进行模拟并行组装。将 $N_x \\times N_y$ 个单元划分为 $p_x \\times p_y$ 个矩形块，其中 $p_x$ 可整除 $N_x$，$p_y$ 可整除 $N_y$。为面项模拟消息传递接口（MPI）光环交换：对于跨越进程边界的面，确定一个唯一的面所有者，并使用所有者的本地数据组装耦合项，同时构建幽灵元数据，在真实的分布式内存中，这些元数据将被交换以获取远程邻居信息。通过其所有者确保每个面仅被组装一次，以防止重复计算。\n- 验证在多种进程网格配置下，通过模拟并行方法组装的全局刚度矩阵 $A$ 与单进程组装的矩阵是按位相同的。\n\n您的程序必须在 $N_x = 4$ 和 $N_y = 3$ 的网格上为以下测试套件实现上述功能：\n- 测试用例 1：$(p_x, p_y) = (1, 1)$。\n- 测试用例 2：$(p_x, p_y) = (2, 1)$。\n- 测试用例 3：$(p_x, p_y) = (1, 3)$。\n- 测试用例 4：$(p_x, p_y) = (2, 3)$。\n- 测试用例 5：$(p_x, p_y) = (4, 3)$。\n\n对于每个测试用例，输出一个布尔值，指示两种组装策略得到的矩阵是否按位相同。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_k$ 是一个布尔字面量 $True$ 或 $False$。不应打印任何其他文本。\n\n由于在此设置中所有量均为无量纲，因此不需要物理单位。不涉及角度。不涉及百分比。该问题纯粹关注数学组装逻辑及其计算实现，以便在模拟的进程数量下进行验证。首字母缩略词在首次使用时必须定义；请按上文规定使用消息传递接口（MPI）和间断伽辽金（DG）。", "solution": "该问题被评估为有效，因为它在科学上基于计算力学的原理，是适定的、客观的且内部一致的。它提出了一个基于已建立的间断伽辽金（DG）有限元方法的清晰、可验证的任务。\n\n该问题要求在矩形域 $\\Omega$ 上为标量扩散方程 $-\\nabla \\cdot (\\kappa \\nabla u) = s$ 组装全局刚度矩阵 $A$。该域被离散化为 $N_x \\times N_y$ 个矩形单元的网格，记为 $K$。采用了对称内部罚函数伽辽金（SIPG）方法，并使用分片常数基函数（一种 DG$_0$ 近似）。对于 DG$_0$，试探函数 $u$ 和测试函数 $v$ 在每个单元 $K$ 上都是常数。\n\n问题的弱形式导出一个双线性形式 $a(u,v)$，对于具有均匀热导率 $\\kappa=1$ 和单位单元尺寸的 DG$_0$ 方法，该形式可被显著简化。每个单元 $K_i$ 上的体积分项 $\\int_{K_i} \\kappa \\nabla u \\cdot \\nabla v \\, dV$ 会消失，因为常数函数的梯度为零。因此，双线性形式仅包含对网格所有面 $\\mathcal{F}$ 的求和：\n$$\na(u,v) = \\sum_{F \\in \\mathcal{F}_{\\mathrm{int}}} \\int_F \\frac{\\gamma}{|F|} [[u]] [[v]] \\, dS + \\sum_{F \\in \\mathcal{F}_{\\mathrm{bnd}}} \\int_F \\frac{\\gamma}{|F|} u v \\, dS\n$$\n其中 $\\mathcal{F}_{\\mathrm{int}}$ 是内部面的集合，$\\mathcal{F}_{\\mathrm{bnd}}$ 是边界面的集合。在由单元 $K_i$ 和 $K_j$ 共享的内部面 $F$ 上的跳跃算子是 $[[u]] = u_i - u_j$，这里假设法线方向是固定的。问题指定了单位罚函数参数 $\\gamma=1$ 和单位单元尺寸，这意味着面面积 $|F|=1$。这使得面罚函数权重简化为一个常数 $w=1$。\n\n单元 $i$ 和 $j$ 之间的单个内部面 $F$ 对双线性形式的贡献是 $w(u_i - u_j)(v_i - v_j)$。展开此式并将各项与矩阵条目关联，可得到对全局刚度矩阵 $A$ 的贡献：\n- 项 $w u_i v_i$ 将 $w$ 加到 $A_{ii}$。\n- 项 $-w u_i v_j$ 将 $-w$ 加到 $A_{ij}$。\n- 项 $-w u_j v_i$ 将 $-w$ 加到 $A_{ji}$。\n- 项 $w u_j v_j$ 将 $w$ 加到 $A_{jj}$。\n\n对于单元 $i$ 上的一个边界面 $F$，其贡献是 $w u_i v_i$，这将一个罚函数值 $w$ 加到对角线元素 $A_{ii}$ 上。这以罚函数的方式强制施加了齐次狄利克雷边界条件（$u=0$）。\n\n任务是实现两种组装策略并验证它们的等价性。\n\n**1. 单进程全局组装**\n\n此策略涉及直接、顺序地构建全局 $N \\times N$ 矩阵 $A$，其中 $N = N_x \\times N_y$。为确保正确性，网格的每个面都必须被精确处理一次。一种稳健的方法是遍历每个单元 $i$（从 $0$ 到 $N-1$），并为每个单元组装其关联面的贡献。\n- **边界面**：对于每个单元 $i$，确定其全局坐标 $(i_x, i_y)$。如果该单元的一个面位于全局域边界上，则将权重 $w=1$ 加到对角线元素 $A_{ii}$ 上。\n- **内部面**：为避免重复计算，我们采用一个约定：一个单元 $i$ 只组装它与全局索引更大的邻居 $j$（即 $j > i$）共享的面。在行主序排列的网格中，这意味着每个单元处理其“右侧”和“上方”邻居的面。这种方法系统性地覆盖了所有内部面一次。\n\n总刚度矩阵 $A$ 可以表示为网格中每个面 $f$ 的贡献 $C(f)$ 的总和：$A = \\sum_{f \\in \\mathcal{F}} C(f)$，其中 $\\mathcal{F}$ 是所有唯一面的集合。顺序算法通过对各项进行特定排序来实现这个求和。\n\n**2. 模拟并行组装**\n\n此策略使用消息传递接口（MPI）模拟了真实分布式内存并行计算的行为。$N_x \\times N_y$ 个单元的全局域被划分为一个 $p_x \\times p_y$ 的进程网格。每个模拟进程被分配一个矩形单元子域。\n\n核心原则保持不变：总矩阵 $A$ 是所有面贡献的总和。现在，求和被分布到各个进程中。总单元集 $E$ 被划分为不相交的子集 $E_p$，其中 $E_p$ 是进程 $p$ 所拥有的单元。每个进程 $p$ 遍历其本地单元 $i \\in E_p$。对于每个这样的单元，它识别相邻的面及其贡献。\n\n并行组装的一个关键组成部分是**面所有权协议**，它确保跨进程面（位于两个子域之间边界上的面）仅由一个进程精确组装一次，以防止重复计算或遗漏。顺序算法中使用的相同所有权规则在这里是一个自然且有效的选择：单元 $i$ 和 $j$ 之间的面由拥有较小全局索引元素 $\\min(i,j)$ 的进程“拥有”。在模拟中，遍历进程及其本地单元的循环，仅仅是顺序方法中遍历所有全局单元的单一循环的重新排序。由于矩阵加法满足交换律和结合律，分布式求和产生的结果与顺序求和的结果相同：\n$$\nA_{\\text{parallel}} = \\sum_{p=0}^{P-1} \\left( \\sum_{f \\in \\mathcal{F}_p} C(f) \\right) = \\sum_{f \\in \\bigcup_p \\mathcal{F}_p} C(f) = \\sum_{f \\in \\mathcal{F}} C(f) = A_{\\text{sequential}}\n$$\n其中 $\\mathcal{F}_p$ 是进程 $p$ 所拥有的面的集合，而所有权规则保证了 $\\{\\mathcal{F}_p\\}$ 构成了总面集 $\\mathcal{F}$ 的一个划分。\n\n提供的 Python 代码为一个 $4 \\times 3$ 的单元网格实现了这两种策略。`assemble_sequential` 函数执行单进程组装。`assemble_simulated_parallel` 函数接受进程网格维度 $(p_x, p_y)$ 并模拟区域分解，其嵌套循环遍历进程及其本地拥有的单元。两个函数使用相同的底层物理规则和面所有权逻辑，保证了结果矩阵是按位相同的，这一点随后会针对每个测试用例进行验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of assembling and verifying a finite element stiffness matrix\n    using two different assembly strategies: sequential and simulated parallel.\n    \"\"\"\n    # Define problem parameters from the problem statement.\n    Nx, Ny = 4, 3\n    test_cases = [\n        (1, 1),\n        (2, 1),\n        (1, 3),\n        (2, 3),\n        (4, 3),\n    ]\n\n    def assemble_sequential(Nx: int, Ny: int) -> np.ndarray:\n        \"\"\"\n        Assembles the global stiffness matrix using a single-process, element-centric approach.\n        This serves as the reference implementation.\n        \"\"\"\n        N = Nx * Ny\n        A = np.zeros((N, N), dtype=int)\n        w = 1  # Penalty weight as specified\n\n        # Iterate over each element by its global index i\n        for i in range(N):\n            ix = i % Nx\n            iy = i // Nx\n\n            # Boundary face contributions: add 'w' for each face on the domain boundary.\n            if ix == 0: A[i, i] += w\n            if ix == Nx - 1: A[i, i] += w\n            if iy == 0: A[i, i] += w\n            if iy == Ny - 1: A[i, i] += w\n\n            # Interior face contributions.\n            # To avoid double-counting, each element only assembles faces\n            # with its neighbors that have a higher global index (j > i).\n            # For a row-major grid, these are the 'right' and 'top' neighbors.\n\n            # Right neighbor\n            if ix  Nx - 1:\n                j = i + 1\n                A[i, i] += w\n                A[j, j] += w\n                A[i, j] -= w\n                A[j, i] -= w\n            \n            # Top neighbor\n            if iy  Ny - 1:\n                j = i + Nx\n                A[i, i] += w\n                A[j, j] += w\n                A[i, j] -= w\n                A[j, i] -= w\n        return A\n\n    def assemble_simulated_parallel(Nx: int, Ny: int, px: int, py: int) -> np.ndarray:\n        \"\"\"\n        Assembles the global stiffness matrix using a simulated parallel approach.\n        The loop structure mimics domain decomposition but updates a single global matrix,\n        demonstrating the logical equivalence to the sequential method.\n        \"\"\"\n        N = Nx * Ny\n        A = np.zeros((N, N), dtype=int)\n        w = 1 # Penalty weight as specified\n\n        nx_local = Nx // px\n        ny_local = Ny // py\n\n        # Simulate looping over each process rank (pid)\n        for pid in range(px * py):\n            pid_x = pid % px\n            pid_y = pid // px\n\n            # Determine the range of global element coordinates this process 'owns'\n            ix_start = pid_x * nx_local\n            iy_start = pid_y * ny_local\n\n            # Loop over elements 'owned' by the current process\n            for local_iy in range(ny_local):\n                for local_ix in range(nx_local):\n                    # Map local element coordinates to global coordinates\n                    ix = ix_start + local_ix\n                    iy = iy_start + local_iy\n                    \n                    # Get the global 1D index of the current element (row-major)\n                    i = iy * Nx + ix\n\n                    # Face assembly logic is identical to the sequential case.\n                    # This process, owning element 'i', is responsible for assembling\n                    # boundary faces of 'i' and interior faces between 'i' and 'j' where i  j.\n                    # This ownership rule guarantees each face is assembled exactly once.\n\n                    # Boundary face contributions\n                    if ix == 0: A[i, i] += w\n                    if ix == Nx - 1: A[i, i] += w\n                    if iy == 0: A[i, i] += w\n                    if iy == Ny - 1: A[i, i] += w\n\n                    # Interior face contributions (owner is element with smaller index)\n                    # Right neighbor\n                    if ix  Nx - 1:\n                        j = i + 1 # Note: j is guaranteed to be > i\n                        # This process owns element i, and since i  j, it assembles this face.\n                        A[i, i] += w\n                        A[j, j] += w\n                        A[i, j] -= w\n                        A[j, i] -= w\n                    \n                    # Top neighbor\n                    if iy  Ny - 1:\n                        j = i + Nx # Note: j is guaranteed to be > i\n                        # This process owns element i, and since i  j, it assembles this face.\n                        A[i, i] += w\n                        A[j, j] += w\n                        A[i, j] -= w\n                        A[j, i] -= w\n        return A\n\n    results = []\n    # Generate the reference matrix using the sequential assembler\n    A_sequential = assemble_sequential(Nx, Ny)\n\n    for px, py in test_cases:\n        # Generate the matrix using the simulated parallel assembler for the current test case\n        A_parallel = assemble_simulated_parallel(Nx, Ny, px, py)\n        \n        # Verify that the two matrices are bitwise-identical\n        are_identical = np.array_equal(A_sequential, A_parallel)\n        results.append('True' if are_identical else 'False')\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3600303"}]}