{"hands_on_practices": [{"introduction": "选择一个范数来量化数据失配是反演问题的核心。虽然 $L_2$ 范数因其数学上的便利性而无处不在，但它对数据中的离群值异常敏感，这在地球物理数据中很常见。本练习通过比较不同 $L_p$ 范数的表现，特别是 $p$ 接近 1 时的情况，来实践如何构建对离群值稳健的目标函数，这对于从含有噪声和异常的数据中获得可靠的模型至关重要 [@problem_id:3612245]。", "problem": "考虑一个线性化的体波走时层析成像设定，其中观测到的走时向量表示为 $T_{\\text{obs}} \\in \\mathbb{R}^{n}$，模型是一个慢度向量 $m \\in \\mathbb{R}^{p}$，其单位为秒/公里，将慢度映射到走时的线性正演算子为 $G \\in \\mathbb{R}^{n \\times p}$，其条目是以公里为单位的路径长度。预测的走时为 $T(m) = G m$，残差为 $e(m) = T_{\\text{obs}} - T(m) \\in \\mathbb{R}^{n}$。假设数据由一个逆标准差对角矩阵 $W = \\mathrm{diag}(1/\\sigma_1,\\dots,1/\\sigma_n)$ 进行加权，因此 $r(m) = W e(m)$ 是无量纲的。\n\n对于 $p \\in [1,2]$，定义一个 $L_p$ 型失配目标函数，它带有一个平滑的绝对值代理（以确保在原点的可微性），形式如下\n$$\n\\phi_{p,\\epsilon}(m) = \\sum_{i=1}^{n} \\left(r_i(m)^2 + \\epsilon^2\\right)^{\\frac{p}{2}},\n$$\n其中 $\\epsilon > 0$ 是一个固定的平滑常数。目标函数对每个数据残差的敏感度可以通过数据空间梯度分量来分析\n$$\ng_i(r) = \\frac{\\partial \\phi_{p,\\epsilon}}{\\partial r_i} = \\frac{\\partial}{\\partial r_i} \\left(r_i^2+\\epsilon^2\\right)^{\\frac{p}{2}},\n$$\n该分量量化了 $r_i$ 中的一个微小扰动如何影响目标函数。沿着特定射线路径的大的、稀疏的残差（离群值）可以通过比较不同 $i$ 和 $p$ 的 $|g_i(r)|$ 来诊断。\n\n仅从以下基本事实和定义出发：\n- 走时层析成像的线性化正演模型是 $T(m) = G m$。\n- 残差是 $e(m) = T_{\\text{obs}} - T(m)$，加权残差是 $r(m) = W e(m)$。\n- 对于 $a > 0$ 和 $\\alpha \\in \\mathbb{R}$，导数 $\\frac{d}{dx}(x^2 + a^2)^{\\alpha} = 2 \\alpha x (x^2 + a^2)^{\\alpha - 1}$。\n- 导数的链式法则和标准线性代数。\n\n任务：\n1) 仅使用上述定义和基本事实，推导对于一般 $p \\in [1,2]$ 和 $\\epsilon > 0$ 的 $g_i(r)$ 的表达式。然后，使用链式法则，推导模型空间梯度 $\\nabla_m \\phi_{p,\\epsilon}(m)$，用 $G$、$W$ 和 $r(m)$ 表示，且不简化为任何 $p$ 的特殊情况。\n2) 使用你推导的 $g_i(r)$ 表达式，定性解释当 $|r_i| \\gg \\epsilon$ 和 $|r_i| \\ll \\epsilon$ 时，$r_i$ 的大小如何作为 $p$ 的函数影响 $|g_i(r)|$，并将其与失配函数对稀疏大残差的稳健性联系起来。你的解释必须仅使用基于你推导的表达式的渐近推理。\n\n然后，实现一个程序来计算指定测试用例的标量失配值和一个量化对离群值敏感度的无量纲影响比。使用以下数值上指定、物理上一致的设置：\n- 数据数量 $n = 6$，模型参数数量 $p = 4$。\n- 正演算子 $G$（单位：公里）：\n  $$\n  G = \\begin{bmatrix}\n  10  &10  &0  &0 \\\\\n  0  &12  &8  &0 \\\\\n  0  &0  &9  &11 \\\\\n  7  &0  &0  &13 \\\\\n  5  &5  &5  &5 \\\\\n  0  &15  &0  &5\n  \\end{bmatrix}.\n  $$\n- 真实慢度模型 $m_{\\text{true}}$（单位：秒/公里）：\n  $$\n  m_{\\text{true}} = \\begin{bmatrix} 0.5 \\\\ 0.6 \\\\ 0.55 \\\\ 0.52 \\end{bmatrix}.\n  $$\n- 观测数据生成为 $T_{\\text{obs}} = G m_{\\text{true}} + \\delta$，其中 $\\delta$ 是一个确定性的附加走时误差向量（单位：秒），为下述每个场景指定。目标函数的评估点是真实模型 $m = m_{\\text{true}}$，因此建模误差为零，只有数据误差对残差有贡献。\n- 所有数据标准差都相同，等于 $\\sigma_i = 0.01$ 秒，因此 $W = \\mathrm{diag}(100,100,100,100,100,100)$ 使得 $r$ 无量纲。\n- 平滑参数为 $\\epsilon = 10^{-6}$（无量纲）。\n\n定义三个场景（所有条目单位：秒）：\n- 场景 1（具有小背景噪声的单个强离群值）：\n  $$\n  \\delta^{(1)} = \\begin{bmatrix} 0.002 \\\\ -0.001 \\\\ 1.0 \\\\ 0.0005 \\\\ -0.0015 \\\\ 0.0008 \\end{bmatrix}.\n  $$\n- 场景 2（无离群值，小噪声）：\n  $$\n  \\delta^{(2)} = \\begin{bmatrix} 0.002 \\\\ -0.003 \\\\ 0.001 \\\\ -0.0015 \\\\ 0.0 \\\\ 0.0025 \\end{bmatrix}.\n  $$\n- 场景 3（具有微小背景噪声的两个相反符号的离群值）：\n  $$\n  \\delta^{(3)} = \\begin{bmatrix} 0.6 \\\\ 0.0 \\\\ 0.0 \\\\ -0.8 \\\\ 0.0005 \\\\ -0.0005 \\end{bmatrix}.\n  $$\n\n对于每个场景 $s \\in \\{1,2,3\\}$ 和每个范数参数 $p \\in \\{2.0, 1.5, 1.0\\}$，计算：\n- 标量目标值 $\\phi_{p,\\epsilon}(m_{\\text{true}})$，由于使用了 $W$，该值是无量纲的。\n- 影响比 $R_{p}^{(s)}$，定义如下：\n  1. 计算 $r = W\\left(T_{\\text{obs}}^{(s)} - G m_{\\text{true}}\\right)$。\n  2. 根据你的 $g_i(r)$ 表达式逐分量计算 $g(r)$。\n  3. 令 $i^{\\star}$ 为使 $|r_i|$ 最大化的索引。\n  4. 定义 $R_{p}^{(s)} = \\dfrac{|g_{i^{\\star}}(r)|}{\\mathrm{median}\\left(\\{|g_i(r)|\\}_{i=1}^{n}\\right)}$，这是一个无量纲的比率，量化了最大量级残差相对于典型数据点的相对影响。\n\n不涉及角度单位。最终报告的值中不需要物理单位，因为 $\\phi_{p,\\epsilon}$ 和 $R_{p}^{(s)}$ 都是无量纲的。\n\n测试套件和输出规范：\n- 使用上面给出的三个场景 $s \\in \\{1,2,3\\}$ 和三个范数参数 $p \\in \\{2.0, 1.5, 1.0\\}$。\n- 对于每个有序对 $(s,p)$，你必须严格遵循这个顺序（按字典序，其中 $s$ 在每个 $p$ 块内最快增加，或者反之亦然）：对于 $s=1$，列出 $p=2.0$，然后是 $p=1.5$，然后是 $p=1.0$；然后对于 $s=2$，列出 $p=2.0$，然后是 $p=1.5$，然后是 $p=1.0$；然后对于 $s=3$，列出 $p=2.0$，然后是 $p=1.5$，然后是 $p=1.0$。\n- 对于每个 $(s,p)$，按顺序输出两个浮点数 $\\phi_{p,\\epsilon}(m_{\\text{true}})$ 和 $R_{p}^{(s)}$。\n- 你的程序应生成单行输出，其中包含所有结果，形式为单个逗号分隔的 Python 风格浮点数列表，并用方括号括起来，顺序严格如下：\n  $$\n  [\\phi_{2.0}^{(1)}, R_{2.0}^{(1)}, \\phi_{1.5}^{(1)}, R_{1.5}^{(1)}, \\phi_{1.0}^{(1)}, R_{1.0}^{(1)}, \\phi_{2.0}^{(2)}, R_{2.0}^{(2)}, \\phi_{1.5}^{(2)}, R_{1.5}^{(2)}, \\phi_{1.0}^{(2)}, R_{1.0}^{(2)}, \\phi_{2.0}^{(3)}, R_{2.0}^{(3)}, \\phi_{1.5}^{(3)}, R_{1.5}^{(3)}, \\phi_{1.0}^{(3)}, R_{1.0}^{(3)}].\n  $$\n程序不应打印任何其他文本。", "solution": "该问题陈述是计算地球物理学领域内一个适定且科学上合理的练习，特别是在反演理论和优化范畴内。它要求推导一个广义 $L_p$ 目标函数的梯度，对其稳健性属性进行定性分析，并为一个特定场景实现数值计算。所有提供的数据、定义和约束都是自洽、一致且物理上合理的。因此，该问题被认为是有效的。\n\n### 第1部分：推导\n\n第一个任务是推导数据空间梯度分量 $g_i(r)$ 和模型空间梯度 $\\nabla_m \\phi_{p,\\epsilon}(m)$。\n\n失配目标函数定义为：\n$$\n\\phi_{p,\\epsilon}(m) = \\sum_{j=1}^{n} \\left(r_j(m)^2 + \\epsilon^2\\right)^{\\frac{p}{2}}\n$$\n其中 $r(m)$ 是加权残差向量，$p \\in [1,2]$ 是范数参数，$\\epsilon > 0$ 是一个平滑常数。\n\n**数据空间梯度分量 $g_i(r)$ 的推导**\n\n数据空间梯度分量定义为 $g_i(r) = \\frac{\\partial \\phi_{p,\\epsilon}}{\\partial r_i}$。由于目标函数是关于每个数据分量 $r_j$ 的独立项之和，因此对 $r_i$ 的偏导数只影响求和中的 $j=i$ 项。\n$$\ng_i(r) = \\frac{\\partial}{\\partial r_i} \\left( \\left(r_i^2 + \\epsilon^2\\right)^{\\frac{p}{2}} \\right)\n$$\n我们使用提供的基本事实，这是链式法则的直接应用：对于 $a > 0$ 和 $\\alpha \\in \\mathbb{R}$，$\\frac{d}{dx}(x^2 + a^2)^{\\alpha} = 2 \\alpha x (x^2 + a^2)^{\\alpha - 1}$。我们可以进行替换，$x = r_i$, $a = \\epsilon$, $\\alpha = \\frac{p}{2}$。应用此规则得到：\n$$\ng_i(r) = 2 \\left(\\frac{p}{2}\\right) r_i \\left(r_i^2 + \\epsilon^2\\right)^{\\frac{p}{2} - 1}\n$$\n简化表达式，我们得到数据空间梯度分量的一般形式：\n$$\ng_i(r) = p \\, r_i \\left(r_i^2 + \\epsilon^2\\right)^{\\frac{p-2}{2}}\n$$\n\n**模型空间梯度 $\\nabla_m \\phi_{p,\\epsilon}(m)$ 的推导**\n\n模型空间梯度是关于模型参数的偏导数向量，$\\nabla_m \\phi_{p,\\epsilon}(m) = \\left[ \\frac{\\partial \\phi}{\\partial m_1}, \\dots, \\frac{\\partial \\phi}{\\partial m_p} \\right]^T$。我们应用多元链式法则。目标函数 $\\phi$ 通过加权残差 $r_i(m)$ 依赖于模型参数 $m_k$。\n梯度的第 $k$ 个分量是：\n$$\n\\frac{\\partial \\phi}{\\partial m_k} = \\sum_{i=1}^{n} \\frac{\\partial \\phi}{\\partial r_i} \\frac{\\partial r_i}{\\partial m_k}\n$$\n乘积中的第一项就是 $g_i(r(m))$。第二项是第 $i$ 个加权残差对第 $k$ 个模型参数的偏导数。加权残差由 $r(m) = W (T_{\\text{obs}} - G m)$ 给出，其中 $W$ 是一个对角矩阵，其元素为 $W_{ii} = 1/\\sigma_i$。\n第 $i$ 个分量是 $r_i(m) = \\frac{1}{\\sigma_i} \\left( T_{\\text{obs},i} - (Gm)_i \\right)$。\n项 $(Gm)_i$ 是 $G$ 的第 $i$ 行乘以向量 $m$：$(Gm)_i = \\sum_{l=1}^{p} G_{il} m_l$。\n现在我们计算偏导数：\n$$\n\\frac{\\partial r_i}{\\partial m_k} = \\frac{\\partial}{\\partial m_k} \\left( \\frac{1}{\\sigma_i} \\left( T_{\\text{obs},i} - \\sum_{l=1}^{p} G_{il} m_l \\right) \\right) = -\\frac{1}{\\sigma_i} G_{ik}\n$$\n该表达式是矩阵 $-W G$ 的第 $(i, k)$ 个元素。\n将其代回到 $\\frac{\\partial \\phi}{\\partial m_k}$ 的求和中：\n$$\n\\frac{\\partial \\phi}{\\partial m_k} = \\sum_{i=1}^{n} g_i(r(m)) \\left( -\\frac{G_{ik}}{\\sigma_i} \\right) = -\\sum_{i=1}^{n} G_{ik} \\frac{1}{\\sigma_i} g_i(r(m))\n$$\n这个求和可以识别为一个矩阵-向量乘积的第 $k$ 个分量。设 $g(r(m))$ 是分量为 $g_i(r(m))$ 的列向量。考虑表达式 $-G^T W g(r(m))$。这个 $p \\times 1$ 向量的第 $k$ 个元素是：\n$$\n(-G^T W g(r(m)))_k = -\\sum_{i=1}^n (G^T)_{ki} (W g(r(m)))_i = -\\sum_{i=1}^n G_{ik} (W_{ii} g_i(r(m))) = -\\sum_{i=1}^n G_{ik} \\frac{1}{\\sigma_i} g_i(r(m))\n$$\n这与我们为 $\\frac{\\partial \\phi}{\\partial m_k}$ 推导的表达式完全匹配。因此，模型空间梯度的向量形式为：\n$$\n\\nabla_m \\phi_{p,\\epsilon}(m) = -G^T W g(r(m))\n$$\n其中 $g(r(m))$ 是一个 $n \\times 1$ 向量，其第 $i$ 个分量是 $g_i(r(m)) = p \\, r_i(m) \\left(r_i(m)^2 + \\epsilon^2\\right)^{\\frac{p-2}{2}}$。该表达式按要求用 $G$、$W$ 和 $r(m)$ 表示。\n\n### 第2部分：稳健性的定性分析\n\n失配函数对稀疏大残差（离群值）的稳健性可以通过分析数据空间梯度分量的大小 $|g_i(r)| = p |r_i| (r_i^2 + \\epsilon^2)^{\\frac{p-2}{2}}$ 在不同渐近状态下的行为来理解。该项量化了目标函数对第 $i$ 个残差变化的敏感度，因此也量化了其在优化过程中对基于梯度的更新的“影响”。\n\n**情况1：大残差 ($|r_i| \\gg \\epsilon$)**\n在这种状态下，存在一个离群值。项 $(r_i^2 + \\epsilon^2)$ 可以近似为 $r_i^2$。\n$$\n|g_i(r)| \\approx p |r_i| (r_i^2)^{\\frac{p-2}{2}} = p |r_i| |r_i|^{p-2} = p |r_i|^{p-1}\n$$\n我们分析这种行为作为 $p \\in [1, 2]$ 的函数：\n- 对于 $p=2$ (最小二乘)：$|g_i(r)| \\approx 2 |r_i|^{2-1} = 2|r_i|$。残差的影响随其量级线性增长。这使得 $L_2$ 范数对离群值高度敏感；一个大的残差可以对梯度施加巨大的拉力，可能通过以牺牲其他数据为代价来拟合离群值而破坏解。因此它**不稳健**。\n- 对于 $p=1$ (最小绝对偏差)：$|g_i(r)| \\approx 1 |r_i|^{1-1} = |r_i|^0 = 1$。对于大残差，影响饱和到一个常数值。这意味着一旦一个残差被识别为离群值，其对梯度的影响就不会再增加，无论它变得多大。这使得 $L_1$ 范数对离群值是**稳健的**。\n- 对于 $1 < p < 2$：影响 $|g_i(r)| \\approx p|r_i|^{p-1}$ 随着残差量级亚线性增长，因为指数 $p-1$ 在 $0$ 和 $1$ 之间。这提供了一族中间范数，它们比 $L_2$ 更稳健，但不如 $L_1$。当 $p$ 减小到 $1$ 时，稳健性增加。\n\n**情况2：小残差 ($|r_i| \\ll \\epsilon$)**\n在这种状态下，数据拟合良好或包含小噪声。项 $(r_i^2 + \\epsilon^2)$ 可以近似为 $\\epsilon^2$。\n$$\n|g_i(r)| \\approx p |r_i| (\\epsilon^2)^{\\frac{p-2}{2}} = p |r_i| \\epsilon^{p-2} = \\left( \\frac{p}{\\epsilon^{2-p}} \\right) |r_i|\n$$\n由于 $p$ 和 $\\epsilon$ 是常数，影响 $|g_i(r)|$ 与 $|r_i|$ 成正比。对于小残差，所有这些 $L_p$ 型范数的行为都像 $L_2$ 范数。这是一个理想的属性，因为 $L_2$ 范数是平滑的，并且在最小值附近有一个二次吸引盆，从而导致稳定高效的收敛。平滑参数 $\\epsilon$ 定义了残差被认为是“大”或“小”的阈值，控制着从类 $L_2$ 行为到类 $L_p$ 行为的过渡。\n\n总之，将 $p$ 从 $2$ 减小到 $1$ 会系统地减小大残差对目标函数梯度的影响，从而提高估计器的稳健性。\n\n### 数值实现\n\n为了计算所需的值，我们将对每个场景 $s \\in \\{1,2,3\\}$ 和每个范数参数 $p \\in \\{2.0, 1.5, 1.0\\}$ 遵循以下步骤：\n1.  定义问题常数：$G$、$m_{\\text{true}}$、$\\sigma_i$、$W$ 和 $\\epsilon$。\n2.  对于给定的场景 $s$，定义误差向量 $\\delta^{(s)}$。\n3.  计算加权残差向量 $r^{(s)}$。由于评估点在 $m=m_{\\text{true}}$，残差为 $e^{(s)} = T_{\\text{obs}}^{(s)} - G m_{\\text{true}} = (G m_{\\text{true}} + \\delta^{(s)}) - G m_{\\text{true}} = \\delta^{(s)}$。因此，$r^{(s)} = W \\delta^{(s)} = \\delta^{(s)} / \\sigma_i$。\n4.  对于给定的 $p$，计算目标函数值 $\\phi_{p,\\epsilon}(m_{\\text{true}}) = \\sum_{i=1}^{n} ( (r_i^{(s)})^2 + \\epsilon^2 )^{p/2}$。\n5.  计算数据空间梯度向量 $g(r^{(s)})$，其分量为 $g_i(r^{(s)}) = p \\, r_i^{(s)} ( (r_i^{(s)})^2 + \\epsilon^2 )^{\\frac{p-2}{2}}$。\n6.  确定与最大绝对残差相对应的索引 $i^{\\star}$，$i^{\\star} = \\mathrm{argmax}_i |r_i^{(s)}|$。\n7.  计算影响比 $R_p^{(s)} = \\frac{|g_{i^{\\star}}(r^{(s)})|}{\\mathrm{median}\\left(\\{|g_i(r^{(s)})|\\}_{i=1}^{n}\\right)}$。\n8.  按指定的顺序和格式存储结果 $(\\phi_{p,\\epsilon}, R_p^{(s)})$ 以供最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes misfit objectives and influence ratios for different L_p norms in a\n    linearized travel-time tomography problem.\n    \"\"\"\n    # Define the problem setup\n    n = 6\n    p_dim = 4\n\n    # Forward operator G in kilometers\n    G = np.array([\n        [10.0, 10.0, 0.0, 0.0],\n        [0.0, 12.0, 8.0, 0.0],\n        [0.0, 0.0, 9.0, 11.0],\n        [7.0, 0.0, 0.0, 13.0],\n        [5.0, 5.0, 5.0, 5.0],\n        [0.0, 15.0, 0.0, 5.0]\n    ])\n\n    # True slowness model m_true in s/km\n    m_true = np.array([0.5, 0.6, 0.55, 0.52])\n\n    # Data standard deviation sigma_i in seconds\n    sigma = 0.01\n\n    # Weighting matrix W is sigma^-1 * I.\n    # We can apply it by scalar division.\n\n    # Smoothing parameter epsilon\n    epsilon = 1e-6\n\n    # Scenarios for additive travel-time error delta in seconds\n    deltas = [\n        # Scenario 1\n        np.array([0.002, -0.001, 1.0, 0.0005, -0.0015, 0.0008]),\n        # Scenario 2\n        np.array([0.002, -0.003, 0.001, -0.0015, 0.0, 0.0025]),\n        # Scenario 3\n        np.array([0.6, 0.0, 0.0, -0.8, 0.0005, -0.0005])\n    ]\n\n    # Norm parameters p\n    p_values = [2.0, 1.5, 1.0]\n\n    results = []\n\n    # Loop through scenarios and p-values in the specified order\n    for s_idx, delta in enumerate(deltas):\n        \n        # Since we evaluate at m_true, the residual e = T_obs - G*m_true = delta.\n        # The weighted residual r = W * e = delta / sigma.\n        r = delta / sigma\n\n        for p_val in p_values:\n            # 1. Compute the scalar objective value phi\n            phi_terms = (r**2 + epsilon**2)**(p_val / 2.0)\n            phi = np.sum(phi_terms)\n            results.append(phi)\n\n            # 2. Compute the influence ratio R\n            \n            # Compute data-space gradient vector g(r)\n            g = p_val * r * (r**2 + epsilon**2)**((p_val - 2.0) / 2.0)\n            \n            # Find the index of the largest-magnitude residual\n            i_star = np.argmax(np.abs(r))\n            \n            # Get the influence of the largest residual\n            g_i_star_abs = np.abs(g[i_star])\n            \n            # Compute the median of the absolute influences\n            median_g_abs = np.median(np.abs(g))\n            \n            # Compute the influence ratio R\n            # Handle potential division by zero, although not expected here.\n            if median_g_abs > 0:\n                R = g_i_star_abs / median_g_abs\n            else:\n                R = np.inf # Or another representation of an undefined ratio\n            \n            results.append(R)\n\n    # Format the final output as a single-line list of floats\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```", "id": "3612245"}, {"introduction": "除了选择合适的范数，我们还可以在不同域（例如空间域或频率域）中定义数据失配。在理想条件下，帕塞瓦尔定理 (Parseval's theorem) 保证了 $L_2$ 范数在这两个域中的等价性，但在处理有限且离散的数据时，谱泄漏和混叠等信号处理效应会使问题复杂化。通过这个实践，您将亲手实现一个简化的重力反演模型，并探讨空间域和谱域失配之间的差异，从而深刻理解在实际计算中选择不同失配度量域的后果 [@problem_id:3612211]。", "problem": "考虑一个一维重力反演简化模型，其中正演算子通过与一个物理上合理的、深度依赖的格林函数核 $K(x; z_0)$ 进行空间卷积，将空间模型 $m(x)$ 映射到数据 $d(x)$。空间数据失配定义为空间域中二范数的平方，\n$$\n\\phi_s(m) = \\| d - G(m) \\|_2^2,\n$$\n其中 $G(m)$ 表示应用于 $m(x)$ 的正演算子，在离散网格上实现为循环卷积。在谱域中，加权失配定义为\n$$\n\\phi_k(m) = \\| \\widehat{d} - \\widehat{G(m)} \\|_{2,w}^2 = \\sum_{k=0}^{N-1} w_k \\left| \\widehat{d}_k - \\widehat{G(m)}_k \\right|^2,\n$$\n其中 $\\widehat{(\\cdot)}$ 表示酉离散傅里叶变换 (DFT)，$N$ 是采样点数，$w_k \\ge 0$ 是一个指定的谱加权。酉离散傅里叶变换 (DFT) 定义为\n$$\n\\widehat{x}_k = \\frac{1}{\\sqrt{N}} \\sum_{n=0}^{N-1} x_n \\exp\\left(- i \\frac{2\\pi k n}{N}\\right), \\quad k = 0,1,\\dots,N-1,\n$$\n这确保了 Parseval 定理精确成立：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\sum_{k=0}^{N-1} |\\widehat{x}_k|^2.\n$$\n您将研究在不同加权选择 $w_k$ 下，频谱泄漏和混叠如何影响 $\\phi_s(m)$ 和 $\\phi_k(m)$ 之间的一致性。频谱泄漏源于有限窗口采样，当基础信号在观测窗口内不包含整数个周期时，会导致能量扩散到多个频谱仓中。混叠则在采样率不足以分辨高频内容时出现，导致高频能量在抽取后折叠到较低频率。\n\n假设使用以下简化正演模型。设离散空间网格为 $x_n$（$n=0,1,\\dots,N-1$），具有周期性边界条件。正演算子 $G(m)$ 是与以下核函数的循环卷积\n$$\nK_n(z_0) = \\frac{z_0}{x_n^2 + z_0^2}, \\quad \\text{归一化使得 } \\sum_{n=0}^{N-1} K_n(z_0) = 1,\n$$\n该核函数捕捉了重力敏感度随深度 $z_0$ 变化的物理上合理的低通效应。对于给定的 $m(x)$ 和 $z_0$，定义 $d = K(z_0) * m$ 以及预测的 $G(m_{\\text{est}})$，它是使用可能受扰动的深度 $z_0^{\\text{est}}$ 和缩放后的模型 $m_{\\text{est}}(x) = s \\, m(x)$ 计算得出的。\n\n您的程序必须在以下测试套件中计算并报告三个诊断性浮点数。仅使用无量纲量；角度在三角函数定义中是隐式的，不需要单位转换。\n\n推导和算法设计的基本依据：\n- 空间失配 $\\phi_s(m)$ 定义为范数的平方。\n- 谱失配 $\\phi_k(m)$ 定义为使用酉离散傅里叶变换 (DFT) 的加权范数的平方。\n- Parseval 定理，它将酉 DFT 的空间能量与谱能量联系起来。\n- 频谱泄漏（由于有限窗口采样）和混叠（由于采样不足）与采样定理相关的定义。\n\n测试套件：\n1. 理想路径 (Parseval 一致性)：\n   - 网格大小 $N = 512$，长度 $L = 51200$，因此 $x_n = n \\Delta x$，其中 $\\Delta x = L/N$。\n   - 真实深度 $z_0 = 1500$，估计深度 $z_0^{\\text{est}} = 1800$，缩放因子 $s = 0.9$。\n   - 真实模型 $m(x)$ 是周期性的，具有整数周期：$m_n = \\sin\\left( 2\\pi \\cdot 3 \\cdot \\frac{n}{N} \\right) + 0.5 \\cos\\left( 2\\pi \\cdot 7 \\cdot \\frac{n}{N} \\right)$。\n   - 对所有 $k$，权重 $w_k = 1$。\n   - 输出相对差异 $r_1 = \\frac{|\\phi_s - \\phi_k|}{\\phi_s}$。\n\n2. 频谱泄漏情况（非整数周期和带限加权）：\n   - 网格大小 $N = 512$，长度 $L = 51200$，$\\Delta x = L/N$。\n   - 真实深度 $z_0 = 1500$，估计深度 $z_0^{\\text{est}} = 1600$，缩放因子 $s = 0.95$。\n   - 具有非整数周期的真实模型：$m_n = \\sin\\left( 2\\pi \\cdot 3.5 \\cdot \\frac{n}{N} \\right) + 0.4 \\sin\\left( 2\\pi \\cdot 20.25 \\cdot \\frac{n}{N} \\right)$。\n   - 带限权重 $w_k$ 仅在 $k \\in \\{k_0-1, k_0, k_0+1, N-(k_0+1), N-k_0, N-(k_0-1)\\}$ 的频仓中等于 $1$（其中 $k_0 = 4$），其他情况下 $w_k = 0$。\n   - 输出比率 $r_2 = \\frac{\\phi_k}{\\phi_s}$。\n\n3. 混叠情况（对高频内容进行抽取并使用平滑谱加权）：\n   - 高分辨率网格 $N_{\\text{hi}} = 4096$，长度 $L = 51200$，$\\Delta x_{\\text{hi}} = L/N_{\\text{hi}}$。\n   - 真实深度 $z_0 = 1000$，估计深度 $z_0^{\\text{est}} = 1200$，缩放因子 $s = 0.92$。\n   - 包含高频内容的高分辨率真实模型：$m^{\\text{hi}}_n = \\sin\\left( 2\\pi \\cdot 30 \\cdot \\frac{n}{N_{\\text{hi}}} \\right) + 0.3 \\sin\\left( 2\\pi \\cdot 1200 \\cdot \\frac{n}{N_{\\text{hi}}} \\right)$。\n   - 计算 $d^{\\text{hi}} = K(z_0) * m^{\\text{hi}}$ 和 $G(m_{\\text{est}})^{\\text{hi}} = K(z_0^{\\text{est}}) * (s m^{\\text{hi}})$，然后将两者以因子 $r = 8$ 进行抽取，以获得大小为 $N_{\\text{lo}} = 512$ 的 $d^{\\text{lo}}$ 和 $G(m_{\\text{est}})^{\\text{lo}}$。\n   - 在低分辨率网格上定义平滑谱加权\n     $$\n     w_k = \\frac{1}{1 + \\left( \\frac{\\kappa_k}{\\kappa_0} \\right)^4 }, \\quad \\kappa_k = \\min(k, N_{\\text{lo}} - k), \\quad \\kappa_0 = 64,\n     $$\n     该加权降低了较高波数的权重。\n   - 输出在抽取后的数据上计算的比率 $r_3 = \\frac{\\phi_k}{\\phi_s}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来并以逗号分隔的结果列表（例如，“[result1,result2,result3]”）。每个结果都必须是浮点数。输出中不需要物理单位，三角函数中使用的角度根据其构造是无量纲的。", "solution": "该问题要求计算三个诊断量 $r_1$、$r_2$ 和 $r_3$，这些量用于在不同条件下比较空间域数据失配 $\\phi_s$ 与谱域加权失配 $\\phi_k$。问题的核心在于实现一个一维重力正演简化模型，然后在旨在突出离散傅里叶变换 (DFT) 特性（特别是 Parseval 定理、频谱泄漏和混叠）的场景中分析失配。\n\n空间失配定义为残差向量 $r = d - G(m_{\\text{est}})$ 的欧几里得范数的平方：\n$$ \\phi_s(m) = \\| r \\|_2^2 = \\sum_{n=0}^{N-1} |r_n|^2 $$\n谱失配是残差的 DFT $\\widehat{r} = \\widehat{d} - \\widehat{G(m_{\\text{est}})}$ 的加权欧几里得范数的平方：\n$$ \\phi_k(m) = \\| \\widehat{r} \\|_{2,w}^2 = \\sum_{k=0}^{N-1} w_k |\\widehat{r}_k|^2 $$\n问题指定使用酉 DFT，对此 Parseval 定理成立：$\\sum_{n=0}^{N-1} |x_n|^2 = \\sum_{k=0}^{N-1} |\\widehat{x}_k|^2$。这意味着如果对所有 $k$ 权重 $w_k=1$，那么 $\\phi_s$ 和 $\\phi_k$ 必须相同，差异仅在于数值精度。\n\n正演算子 $G(m)$ 应用与核函数 $K(z_0)$ 的循环卷积。根据卷积定理，此操作在频域中执行效率最高。对于酉 DFT，该定理为 $\\widehat{K*m}_k = \\sqrt{N} \\widehat{K}_k \\widehat{m}_k$。\n\n每个测试用例的总体计算流程如下：\n1.  定义空间网格和模型参数。\n2.  构建真实模型向量 $m(x)$ 和估计模型 $m_{\\text{est}}(x) = s \\cdot m(x)$。\n3.  构建卷积核 $K(z_0)$ 和 $K(z_0^{\\text{est}})$。为确保核函数是对称的（这对于重力源是物理上合理的），我们在以 $x=0$ 为中心的网格上定义它，然后使用循环移位（`fftshift`）使其与 DFT 的约定对齐。核函数被归一化，使其元素总和为 $1$。\n4.  使用酉 `ortho` 范数计算模型和核函数的 DFT。\n5.  在频域中计算“真实”数据 $d$ 和预测数据 $d_{\\text{est}} = G(m_{\\text{est}})$：\n    $$ \\widehat{d}_k = \\sqrt{N} \\widehat{K}(z_0)_k \\widehat{m}_k $$\n    $$ \\widehat{d_{\\text{est}}}_k = \\sqrt{N} \\widehat{K}(z_0^{\\text{est}})_k \\widehat{m_{\\text{est}}}_k = \\sqrt{N} \\widehat{K}(z_0^{\\text{est}})_k (s \\widehat{m}_k) $$\n6.  在空间域和谱域中计算残差。谱残差为 $\\widehat{r}_k = \\widehat{d}_k - \\widehat{d_{\\text{est}}}_k$。空间残差 $r_n$ 是通过对 $\\widehat{r}_k$ 应用逆酉 DFT 获得的。\n7.  使用它们的定义和指定的权重向量 $w_k$ 计算 $\\phi_s$ 和 $\\phi_k$。\n8.  计算该测试用例最终所需的比率。\n\n这三个测试用例旨在探测特定现象：\n\n**测试用例 1：理想路径 (Parseval 一致性)**\n此用例使用由具有整数频率的正弦波组成的模型 $m(x)$，该模型不会表现出频谱泄漏。谱加权是均匀的，$w_k = 1$ 对所有 $k$ 成立。根据酉 DFT 的 Parseval 定理，$\\phi_s = \\sum |r_n|^2$ 必须等于 $\\phi_k = \\sum |\\widehat{r}_k|^2$。计算出的相对差异 $r_1 = |\\phi_s - \\phi_k|/\\phi_s$ 预计将接近于零，仅受浮点算術精度的限制。\n\n**测试用例 2：频谱泄漏情况**\n在此，模型 $m(x)$ 由具有非整数频率的正弦波组成（在定义域上有 $3.5$ 和 $20.25$ 个周期）。这会导致频谱泄漏，意味着这些正弦波的能量在 DFT 中会扩散到许多频仓中，而不是集中在单个频仓里。权重 $w_k$ 被设计为高度选择性的，仅在 $k=4$ 附近的少数几个频仓中非零。因此，$\\phi_k$ 将只捕获残差总谱能量的一小部分，而 $\\phi_s$ 则捕获空间域中的全部能量。因此，比率 $r_2 = \\phi_k / \\phi_s$ 预计将显著小于 $1$。\n\n**测试用例 3：混叠情况**\n此用例演示了欠采样导致的混叠效应。首先创建一个高分辨率模型 $m^{\\text{hi}}$，其中包含一个非常高频率的分量（在大小为 $N_{\\text{hi}}=4096$ 的网格上 $k=1200$）。这个频率远高于低分辨率网格的奈奎斯特频率（$k_{\\text{Nyquist, lo}} = N_{\\text{lo}}/2 = 512/2 = 256$）。正演模拟在高分辨率网格上执行。然后，将得到的数据 $d^{\\text{hi}}$ 和预测 $d^{\\text{est, hi}}$ 在没有抗混叠滤波器的情况下以因子 $r=8$进行抽取（子采样）。这种抽取导致高频能量“折叠”到抽取后信号 $d^{\\text{lo}}$ 和 $d^{\\text{est, lo}}$ 频谱的低频部分。然后，在此发生混叠的低分辨率数据上计算失配 $\\phi_s$ 和 $\\phi_k$。谱加权 $w_k$ 是一个平滑滤波器，它降低高波数的权重。最终的比率 $r_3 = \\phi_k / \\phi_s$ 量化了在存在混叠的情况下，空间能量与加权谱能量之间的关系。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef create_kernel(N, L, z0):\n    \"\"\"\n    Creates a normalized, centered gravity kernel for circular convolution.\n\n    Args:\n        N (int): Number of grid points.\n        L (float): Length of the spatial domain.\n        z0 (float): Depth parameter for the kernel.\n\n    Returns:\n        np.ndarray: The kernel vector, ordered for FFT-based convolution.\n    \"\"\"\n    dx = L / N\n    # Create a centered spatial coordinate vector for a symmetric kernel\n    x_centered = np.arange(-N / 2, N / 2) * dx\n    \n    # Calculate the unnormalized kernel values\n    kernel_unnormalized = z0 / (x_centered**2 + z0**2)\n    \n    # Normalize the kernel to have a sum of 1\n    kernel_centered = kernel_unnormalized / np.sum(kernel_unnormalized)\n    \n    # Shift the kernel to be compatible with np.fft's ordering\n    # The zero-frequency component is at index 0\n    kernel = np.fft.fftshift(kernel_centered)\n    \n    return kernel\n\ndef compute_misfits(N, L, z0, z0_est, s, m, w):\n    \"\"\"\n    Computes spatial and spectral misfits for a given model and parameters.\n    \n    Args:\n        N (int): Number of grid points.\n        L (float): Length of the spatial domain.\n        z0 (float): True depth.\n        z0_est (float): Estimated depth.\n        s (float): Estimated model scaling factor.\n        m (np.ndarray): The true model vector.\n        w (np.ndarray): The spectral weighting vector.\n\n    Returns:\n        tuple[float, float]: A tuple containing (phi_s, phi_k).\n    \"\"\"\n    # Create kernels\n    K_true = create_kernel(N, L, z0)\n    K_est = create_kernel(N, L, z0_est)\n\n    # Unitary DFTs of model and kernels\n    m_hat = np.fft.fft(m, norm='ortho')\n    K_true_hat = np.fft.fft(K_true, norm='ortho')\n    K_est_hat = np.fft.fft(K_est, norm='ortho')\n\n    # Compute \"true\" and predicted data in the spectral domain\n    # using the convolution theorem for unitary DFT\n    sqrt_N = np.sqrt(N)\n    d_hat = sqrt_N * K_true_hat * m_hat\n    d_est_hat = sqrt_N * K_est_hat * (s * m_hat)\n\n    # Spectral residual\n    r_hat = d_hat - d_est_hat\n    \n    # Spatial residual (from inverse DFT of spectral residual)\n    r = np.fft.ifft(r_hat, norm='ortho')\n\n    # Compute misfits\n    phi_s = np.sum(np.abs(r)**2)\n    phi_k = np.sum(w * np.abs(r_hat)**2)\n    \n    return phi_s.real, phi_k.real\n\n\ndef solve():\n    \"\"\"\n    Main function to run the three test cases and print the results.\n    \"\"\"\n    # --- Test Case 1: Happy path (Parseval consistency) ---\n    N1 = 512\n    L1 = 51200.0\n    z0_1 = 1500.0\n    z0_est_1 = 1800.0\n    s1 = 0.9\n    \n    n1 = np.arange(N1)\n    m1 = np.sin(2 * np.pi * 3 * n1 / N1) + 0.5 * np.cos(2 * np.pi * 7 * n1 / N1)\n    w1 = np.ones(N1)\n    \n    phi_s1, phi_k1 = compute_misfits(N1, L1, z0_1, z0_est_1, s1, m1, w1)\n    r1 = np.abs(phi_s1 - phi_k1) / phi_s1\n\n    # --- Test Case 2: Spectral leakage case ---\n    N2 = 512\n    L2 = 51200.0\n    z0_2 = 1500.0\n    z0_est_2 = 1600.0\n    s2 = 0.95\n\n    n2 = np.arange(N2)\n    m2 = np.sin(2 * np.pi * 3.5 * n2 / N2) + 0.4 * np.sin(2 * np.pi * 20.25 * n2 / N2)\n    \n    w2 = np.zeros(N2)\n    k0_2 = 4\n    # Positive frequencies\n    w2[k0_2 - 1 : k0_2 + 2] = 1.0\n    # Negative frequencies (mirrored)\n    w2[N2 - (k0_2 + 1) : N2 - (k0_2 - 1) + 1] = 1.0\n\n    phi_s2, phi_k2 = compute_misfits(N2, L2, z0_2, z0_est_2, s2, m2, w2)\n    r2 = phi_k2 / phi_s2\n\n    # --- Test Case 3: Aliasing case ---\n    N_hi = 4096\n    L3 = 51200.0\n    N_lo = 512\n    r_dec = N_hi // N_lo\n    \n    z0_3 = 1000.0\n    z0_est_3 = 1200.0\n    s3 = 0.92\n\n    # High-resolution model\n    n_hi = np.arange(N_hi)\n    m_hi = np.sin(2 * np.pi * 30 * n_hi / N_hi) + 0.3 * np.sin(2 * np.pi * 1200 * n_hi / N_hi)\n\n    # High-resolution kernels\n    K_true_hi = create_kernel(N_hi, L3, z0_3)\n    K_est_hi = create_kernel(N_hi, L3, z0_est_3)\n    \n    # High-resolution forward modeling\n    m_hi_hat = np.fft.fft(m_hi, norm='ortho')\n    K_true_hi_hat = np.fft.fft(K_true_hi, norm='ortho')\n    K_est_hi_hat = np.fft.fft(K_est_hi, norm='ortho')\n    \n    # High-resolution data and prediction in spectral domain\n    sqrt_N_hi = np.sqrt(N_hi)\n    d_hi_hat = sqrt_N_hi * K_true_hi_hat * m_hi_hat\n    d_est_hi_hat = sqrt_N_hi * K_est_hi_hat * (s3 * m_hi_hat)\n\n    # Transform back to spatial domain\n    d_hi = np.fft.ifft(d_hi_hat, norm='ortho')\n    d_est_hi = np.fft.ifft(d_est_hi_hat, norm='ortho')\n    \n    # Decimate (sub-sample) to create low-resolution signals\n    d_lo = d_hi[::r_dec].real\n    d_est_lo = d_est_hi[::r_dec].real\n    \n    # Compute misfits on low-resolution, aliased data\n    r_lo = d_lo - d_est_lo\n    phi_s3 = np.sum(np.abs(r_lo)**2)\n    \n    r_lo_hat = np.fft.fft(r_lo, norm='ortho')\n    \n    # Smooth spectral weighting on low-res grid\n    kappa0_3 = 64.0\n    k_lo = np.arange(N_lo)\n    kappa_k = np.minimum(k_lo, N_lo - k_lo)\n    w3 = 1.0 / (1.0 + (kappa_k / kappa0_3)**4)\n    \n    phi_k3 = np.sum(w3 * np.abs(r_lo_hat)**2)\n    r3 = phi_k3 / phi_s3\n\n    results = [r1, r2, r3]\n    \n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n```", "id": "3612211"}, {"introduction": "在地球物理建模中，我们通常希望解在满足数据拟合的同时，也严格遵守已知的物理定律，例如质量守恒。将这些物理定律作为硬约束条件加入到优化问题中，比仅作为正则化项（软约束）更为有效。本练习将引导您使用增广拉格朗日方法（特别是交替方向乘子法 ADMM）来解决一个线性约束的最小二乘问题，您将通过动手编程，对比其与简单惩罚方法在执行约束方面的差异，从而掌握一种处理复杂约束反演问题的先进技术 [@problem_id:3612288]。", "problem": "考虑一个计算地球物理学中的线性化反演问题，其中预测数据由一个线性正演算子建模。设模型向量为 $m \\in \\mathbb{R}^n$，观测数据为 $d \\in \\mathbb{R}^p$，正演算子由矩阵 $F \\in \\mathbb{R}^{p \\times n}$ 表示，因此预测数据为 $F m$。数据失配目标函数由二范数的平方定义。在许多地球物理应用中，守恒定律施加了形式为 $A m = b$ 的线性等式约束，其中 $A \\in \\mathbb{R}^{k \\times n}$，$b \\in \\mathbb{R}^{k}$。\n\n您的任务是构建一个增广拉格朗日目标函数来强制执行等式约束，并将优化问题分解为可解的子问题。具体来说，构建约束最小二乘问题\n$$\n\\min_{m \\in \\mathbb{R}^n} \\ \\phi(m) = \\| d - F m \\|_2^2 \\quad \\text{subject to} \\quad A m = b,\n$$\n并使用带有缩放对偶变量 $u \\in \\mathbb{R}^k$ 的增广拉格朗日量，\n$$\n\\mathcal{L}_\\rho(m,u) = \\| d - F m \\|_2^2 + \\frac{\\rho}{2} \\left\\| A m - b + u \\right\\|_2^2,\n$$\n其中 $\\rho > 0$ 是一个罚参数。请从第一性原理出发，不使用任何快捷公式，推导在固定 $u$ 的情况下通过最小化增广目标函数关于 $m$ 的更新步骤，以及通过分裂方案强制执行等式约束的 $u$ 的更新步骤。该分裂方案必须基于交替方向乘子法 (ADMM) 和乘子法原理，并且您必须明确使用 Karush–Kuhn–Tucker (KKT) 最优性条件。您的推导必须从最小二乘失配、等式约束优化和增广拉格朗日构造的定义开始。\n\n实现两个求解器：\n- 一个使用交替方向乘子法 (ADMM) 的增广拉格朗日求解器，带有缩放对偶变量 $u$ 和交替最小化 $m$ 与更新 $u$ 以减少约束违反的迭代更新。\n- 一个一次性罚函数法求解器，它最小化罚函数目标 $\\| d - F m \\|_2^2 + \\frac{\\rho}{2} \\| A m - b \\|_2^2$，而无需对偶变量更新。\n\n为 ADMM 求解器定义以下终止测试：\n- 原始可行性容差：当 $\\| A m - b \\|_2 \\le \\varepsilon_{\\text{pri}}$ 时停止。\n- 模型更新容差：当 $\\| m^{(k)} - m^{(k-1)} \\|_2 \\le \\varepsilon_{\\text{mod}}$ 时停止，\n其中 $m^{(k)}$ 表示第 $k$ 次迭代的模型，$\\varepsilon_{\\text{pri}}$ 和 $\\varepsilon_{\\text{mod}}$ 是固定的容差。\n\n对于每次运行，报告以下量：\n- ADMM 满足两个终止测试所需的迭代次数 $N_{\\text{it}}$（如果未满足，则为最大迭代次数）。\n- 在 ADMM 解处评估的最终数据失配值 $\\phi(m)$。\n- 在 ADMM 解处的最终约束违反量 $\\| A m - b \\|_2$。\n- 在罚函数法解 $m_{\\text{pen}}$ 处的约束违反量 $\\| A m_{\\text{pen}} - b \\|_2$。\n\n您的程序必须实现以上内容并评估以下测试套件。所有矩阵和向量均为精确数值形式，必须完全按给定值使用。设 $n=3$, $p=4$, $k=2$。使用初始条件 $m^{(0)} = 0$ 和 $u^{(0)} = 0$。使用容差 $\\varepsilon_{\\text{pri}} = 10^{-10}$ 和 $\\varepsilon_{\\text{mod}} = 10^{-10}$，以及最大迭代次数 $N_{\\max} = 2000$。\n\n测试套件：\n- 情况 1（正常路径，中等惩罚，一致性约束）：\n  $$\n  F = \\begin{bmatrix}\n  1 & 0 & 0 \\\\\n  0 & 1 & 0 \\\\\n  0 & 0 & 1 \\\\\n  1 & 1 & 1\n  \\end{bmatrix}, \\quad\n  A = \\begin{bmatrix}\n  1 & 1 & 0 \\\\\n  0 & 1 & 1\n  \\end{bmatrix}, \\quad\n  d = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 6 \\end{bmatrix}, \\quad\n  b = \\begin{bmatrix} 3 \\\\ 5 \\end{bmatrix}, \\quad\n  \\rho = 1.\n  $$\n- 情况 2（显著边缘案例，数据与约束耦合不一致）：\n  $$\n  F = \\begin{bmatrix}\n  1 & 0 & 0 \\\\\n  0 & 1 & 0 \\\\\n  0 & 0 & 1 \\\\\n  1 & 1 & 1\n  \\end{bmatrix}, \\quad\n  A = \\begin{bmatrix}\n  1 & 1 & 0 \\\\\n  0 & 1 & 1\n  \\end{bmatrix}, \\quad\n  d = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 5 \\end{bmatrix}, \\quad\n  b = \\begin{bmatrix} 3 \\\\ 5 \\end{bmatrix}, \\quad\n  \\rho = 1.\n  $$\n- 情况 3（边界条件，非常小的罚参数）：\n  $$\n  F = \\begin{bmatrix}\n  1 & 0 & 0 \\\\\n  0 & 1 & 0 \\\\\n  0 & 0 & 1 \\\\\n  1 & 1 & 1\n  \\end{bmatrix}, \\quad\n  A = \\begin{bmatrix}\n  1 & 1 & 0 \\\\\n  0 & 1 & 1\n  \\end{bmatrix}, \\quad\n  d = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 6 \\end{bmatrix}, \\quad\n  b = \\begin{bmatrix} 3 \\\\ 5 \\end{bmatrix}, \\quad\n  \\rho = 10^{-2}.\n  $$\n- 情况 4（边界条件，非常大的罚参数）：\n  $$\n  F = \\begin{bmatrix}\n  1 & 0 & 0 \\\\\n  0 & 1 & 0 \\\\\n  0 & 0 & 1 \\\\\n  1 & 1 & 1\n  \\end{bmatrix}, \\quad\n  A = \\begin{bmatrix}\n  1 & 1 & 0 \\\\\n  0 & 1 & 1\n  \\end{bmatrix}, \\quad\n  d = \\begin{bmatrix} 1 \\\\ 2 \\\\ 3 \\\\ 6 \\end{bmatrix}, \\quad\n  b = \\begin{bmatrix} 3 \\\\ 5 \\end{bmatrix}, \\quad\n  \\rho = 5 \\cdot 10^{2}.\n  $$\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例的结果本身是一个包含四个数字的列表，顺序为 $\\left[N_{\\text{it}}, \\phi(m), \\|A m - b\\|_2, \\|A m_{\\text{pen}} - b\\|_2\\right]$。例如，输出格式必须为\n$$\n\\left[ [N_{\\text{it}}^{(1)}, \\phi^{(1)}, r^{(1)}, r_{\\text{pen}}^{(1)}], [N_{\\text{it}}^{(2)}, \\phi^{(2)}, r^{(2)}, r_{\\text{pen}}^{(2)}], [N_{\\text{it}}^{(3)}, \\phi^{(3)}, r^{(3)}, r_{\\text{pen}}^{(3)}], [N_{\\text{it}}^{(4)}, \\phi^{(4)}, r^{(4)}, r_{\\text{pen}}^{(4)}] \\right].\n$$\n\n此问题不涉及物理单位或角度单位。所有输出必须是实数或整数。代码必须是自包含的，可直接运行，且不得读取任何外部输入。", "solution": "该问题旨在寻找一个线性约束最小二乘问题的数值解，这在计算地球物理学和其他反演问题中很常见。该问题的表述是有效的，在优化理论和线性代数方面具有科学依据，并提供了一套完整且一致的测试参数。\n\n核心问题是找到一个模型向量 $m \\in \\mathbb{R}^n$，在满足线性等式约束的条件下，最小化数据失配：\n$$\n\\min_{m \\in \\mathbb{R}^n} \\ \\phi(m) = \\| d - F m \\|_2^2 \\quad \\text{subject to} \\quad A m = b\n$$\n这里，$\\| \\cdot \\|_2$ 表示欧几里得范数（或 $L_2$-范数），$d \\in \\mathbb{R}^p$ 是观测数据向量，$F \\in \\mathbb{R}^{p \\times n}$ 是线性正演算子，$A \\in \\mathbb{R}^{k \\times n}$ 是约束矩阵，$b \\in \\mathbb{R}^k$ 是约束向量。\n\n这是一个凸优化问题，因为目标函数是二次的，约束是线性的。Karush-Kuhn-Tucker (KKT) 条件为最优解提供了必要和充分条件。该问题的拉格朗日函数是：\n$$\n\\mathcal{L}(m, \\lambda) = \\| d - F m \\|_2^2 + \\lambda^T (A m - b)\n$$\n其中 $\\lambda \\in \\mathbb{R}^k$ 是拉格朗日乘子向量。KKT 条件是：\n1.  **平稳性 (Stationarity):** $\\nabla_m \\mathcal{L}(m, \\lambda) = 0$\n2.  **原始可行性 (Primal Feasibility):** $A m - b = 0$\n\n平稳性条件要求将关于 $m$ 的梯度设为零：\n$$\n\\nabla_m \\mathcal{L} = \\nabla_m \\left( (d - F m)^T (d - F m) \\right) + \\nabla_m \\left( \\lambda^T (A m - b) \\right) = 0\n$$\n$$\n-2 F^T (d - F m) + A^T \\lambda = 0 \\implies 2 F^T F m + A^T \\lambda = 2 F^T d\n$$\n结合可行性条件，这给出了 KKT 系统，一个用于最优对 $(m^*, \\lambda^*)$ 的分块矩阵线性系统：\n$$\n\\begin{bmatrix} 2F^TF & A^T \\\\ A & 0 \\end{bmatrix} \\begin{bmatrix} m \\\\ \\lambda \\end{bmatrix} = \\begin{bmatrix} 2F^Td \\\\ b \\end{bmatrix}\n$$\n对于大规模问题，直接求解该系统可能很困难。增广拉格朗日方法提供了一种迭代的替代方案。\n\n### 增广拉格朗日量与 ADMM/乘子法\n\n增广拉格朗日量通过增加一个对约束违反的惩罚项来修改目标函数，从而比简单的罚函数法具有更好的收敛性。问题中指定了其缩放对偶形式的增广拉格朗日量：\n$$\n\\mathcal{L}_\\rho(m,u) = \\| d - F m \\|_2^2 + \\frac{\\rho}{2} \\left\\| A m - b + u \\right\\|_2^2\n$$\n其中 $\\rho > 0$ 是一个罚参数，$u \\in \\mathbb{R}^k$ 是一个缩放的对偶变量，与拉格朗日乘子 $\\lambda$ 的关系为 $u = \\lambda/\\rho$。交替方向乘子法 (ADMM)，或更具体地针对此问题结构的乘子法，是一种寻求 $\\mathcal{L}_\\rho(m, u)$ 鞍点的迭代方案。它在关于 $m$ 最小化 $\\mathcal{L}_\\rho$ 和更新对偶变量 $u$ 之间交替进行。\n\n迭代方案如下，从初始猜测 $m^{(0)}$ 和 $u^{(0)}$ 开始：\n1.  **$m$-最小化步骤：** 找到使当前对偶变量 $u^{(k)}$ 的增广拉格朗日量最小化的模型 $m^{(k+1)}$：\n    $$\n    m^{(k+1)} = \\arg\\min_m \\mathcal{L}_\\rho(m, u^{(k)}) = \\arg\\min_m \\left( \\| d - F m \\|_2^2 + \\frac{\\rho}{2} \\| A m - b + u^{(k)} \\|_2^2 \\right)\n    $$\n2.  **$u$-更新步骤：** 更新对偶变量以强制执行约束：\n    $$\n    u^{(k+1)} = u^{(k)} + (A m^{(k+1)} - b)\n    $$\n\n#### 从第一性原理推导 $m$-更新\n\n$m$-最小化子问题是一个无约束二次优化问题。我们通过将 $\\mathcal{L}_\\rho(m, u^{(k)})$ 关于 $m$ 的梯度设为零来找到最小化子。让我们计算这个梯度：\n$$\n\\nabla_m \\mathcal{L}_\\rho(m, u^{(k)}) = \\nabla_m \\left( \\| d - F m \\|_2^2 \\right) + \\nabla_m \\left( \\frac{\\rho}{2} \\| A m - b + u^{(k)} \\|_2^2 \\right)\n$$\n第一项（数据残差的 $L_2$ 范数平方）的梯度是：\n$$\n\\nabla_m \\left( (d - F m)^T (d - F m) \\right) = -2 F^T (d - F m) = 2(F^T F m - F^T d)\n$$\n第二项（增广惩罚项）的梯度是：\n$$\n\\nabla_m \\left( \\frac{\\rho}{2} (A m - b + u^{(k)})^T (A m - b + u^{(k)}) \\right) = \\frac{\\rho}{2} \\cdot 2 A^T (A m - b + u^{(k)}) = \\rho A^T (A m - b + u^{(k)})\n$$\n将这些梯度的和设为零以找到最优的 $m^{(k+1)}$：\n$$\n2(F^T F m^{(k+1)} - F^T d) + \\rho A^T (A m^{(k+1)} - b + u^{(k)}) = 0\n$$\n重新整理各项以求解 $m^{(k+1)}$：\n$$\n2 F^T F m^{(k+1)} + \\rho A^T A m^{(k+1)} = 2 F^T d + \\rho A^T (b - u^{(k)})\n$$\n$$\n(2 F^T F + \\rho A^T A) m^{(k+1)} = 2 F^T d + \\rho A^T (b - u^{(k)})\n$$\n这是一个形式为 $H m = g$ 的线性系统，其中矩阵 $H = 2 F^T F + \\rho A^T A$ 在整个迭代过程中是常数，而向量 $g^{(k)} = 2 F^T d + \\rho A^T (b - u^{(k)})$ 在每一步都更新。由于 $F$ 具有满列秩，$F^T F$ 是正定的。$A^T A$ 是半正定的。对于 $\\rho > 0$，和 $H$ 是正定的，因此是可逆的，保证了每一步 $m^{(k+1)}$ 的唯一解。为了效率，我们可以预先计算 $H$ 的逆或其分解。\n\n#### $u$-更新的推导\n$u$-更新步骤是一个对偶上升步。它将原始残差 $r_{\\text{pri}} = A m - b$ 驱动至零。在收敛时，$m^{(k+1)} \\approx m^{(k)}$，所以更新规则 $u^{(k+1)} = u^{(k)} + (A m^{(k+1)} - b)$ 意味着 $A m^{(k+1)} - b \\approx 0$。这确保了原始可行性 KKT 条件在极限情况下得到满足。\n\n### 罚函数法求解器\n\n作为比较，简单的罚函数法求解一个单一的无约束优化问题，其中约束作为惩罚项被并入目标函数中。目标函数为：\n$$\n\\min_{m} \\mathcal{J}_{\\text{pen}}(m) = \\| d - F m \\|_2^2 + \\frac{\\rho}{2} \\| A m - b \\|_2^2\n$$\n这对应于 ADMM 算法的第一个 $m$-最小化步骤，初始对偶变量为 $u^{(0)}=0$。解 $m_{\\text{pen}}$ 通过将 $\\mathcal{J}_{\\text{pen}}(m)$ 的梯度设为零来找到：\n$$\n\\nabla_m \\mathcal{J}_{\\text{pen}} = 2(F^T F m - F^T d) + \\rho A^T (A m - b) = 0\n$$\n$$\n(2 F^T F + \\rho A^T A) m = 2 F^T d + \\rho A^T b\n$$\n解 $m_{\\text{pen}}$ 是通过求解这个单一线性系统得到的。与 ADMM 不同，此方法不保证约束 $A m = b$ 被精确满足，但当罚参数 $\\rho$ 增加时，违反量 $\\|A m_{\\text{pen}} - b\\|_2$ 通常会减小。\n\n### 实现逻辑\n\n实现将包括两个主要函数：\n1. `admm_solver`：此函数实现迭代的 ADMM/乘子法方案。它将 $m^{(0)}$ 和 $u^{(0)}$ 初始化为零向量，然后迭代 $m$-更新和 $u$-更新步骤，直到原始可行性容差 $\\| A m^{(k)} - b \\|_2 \\le \\varepsilon_{\\text{pri}}$ 和模型更新容差 $\\| m^{(k)} - m^{(k-1)} \\|_2 \\le \\varepsilon_{\\text{mod}}$ 都满足，或达到最大迭代次数 $N_{\\max}$。\n2. `penalty_solver`：此函数通过构建和求解相应的线性系统来计算一次性罚函数法解。\n\n对于每个测试用例，我们将运行这两个求解器，并计算四个所需的指标：ADMM 迭代次数 $N_{\\text{it}}$，ADMM 解的最终数据失配 $\\phi(m) = \\|d - Fm\\|_2^2$，ADMM 解的最终约束违反量 $\\|Am - b\\|_2$，以及罚函数法解的约束违反量 $\\|A m_{\\text{pen}} - b\\|_2$。", "answer": "```python\nimport numpy as np\n\ndef admm_solver(F, A, d, b, rho, m0, u0, eps_pri, eps_mod, n_max):\n    \"\"\"\n    Solves a constrained least-squares problem using the Alternating Direction\n    Method of Multipliers (ADMM) with a scaled dual variable.\n    \"\"\"\n    m_k = np.copy(m0)\n    u_k = np.copy(u0)\n\n    H = 2 * F.T @ F + rho * A.T @ A\n    \n    # Pre-compute inverse for efficiency in the loop, as H is constant.\n    # For a small 3x3 system, this is fine. For larger systems, a\n    # factorization (e.g., LU or Cholesky) would be more stable and efficient.\n    H_inv = np.linalg.inv(H)\n    \n    FTd_x2 = 2 * F.T @ d\n    rho_AT = rho * A.T\n\n    for k in range(n_max):\n        m_prev = np.copy(m_k)\n        \n        # m-minimization step\n        g_k = FTd_x2 + rho_AT @ (b - u_k)\n        m_k = H_inv @ g_k\n        \n        # u-update step\n        primal_residual_vec = A @ m_k - b\n        u_k = u_k + primal_residual_vec\n        \n        # Check for convergence\n        primal_residual_norm = np.linalg.norm(primal_residual_vec)\n        model_update_norm = np.linalg.norm(m_k - m_prev)\n        \n        if primal_residual_norm <= eps_pri and model_update_norm <= eps_mod:\n            return m_k, k + 1\n            \n    return m_k, n_max\n\ndef penalty_solver(F, A, d, b, rho):\n    \"\"\"\n    Solves the penalized least-squares problem in a single shot.\n    \"\"\"\n    H = 2 * F.T @ F + rho * A.T @ A\n    g = 2 * F.T @ d + rho * A.T @ b\n    \n    # Solve the linear system H * m_pen = g\n    m_pen = np.linalg.solve(H, g)\n    return m_pen\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases\n    test_cases = [\n        { # Case 1\n            \"F\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]]),\n            \"A\": np.array([[1, 1, 0], [0, 1, 1]]),\n            \"d\": np.array([1, 2, 3, 6]),\n            \"b\": np.array([3, 5]),\n            \"rho\": 1.0,\n        },\n        { # Case 2\n            \"F\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]]),\n            \"A\": np.array([[1, 1, 0], [0, 1, 1]]),\n            \"d\": np.array([1, 2, 3, 5]),\n            \"b\": np.array([3, 5]),\n            \"rho\": 1.0,\n        },\n        { # Case 3\n            \"F\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]]),\n            \"A\": np.array([[1, 1, 0], [0, 1, 1]]),\n            \"d\": np.array([1, 2, 3, 6]),\n            \"b\": np.array([3, 5]),\n            \"rho\": 1e-2,\n        },\n        { # Case 4\n            \"F\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]]),\n            \"A\": np.array([[1, 1, 0], [0, 1, 1]]),\n            \"d\": np.array([1, 2, 3, 6]),\n            \"b\": np.array([3, 5]),\n            \"rho\": 5e2,\n        },\n    ]\n\n    # Solver parameters\n    n = 3  # dimension of m\n    k_dim = 2  # number of constraints\n    m0 = np.zeros(n)\n    u0 = np.zeros(k_dim)\n    eps_pri = 1e-10\n    eps_mod = 1e-10\n    n_max = 2000\n\n    all_results = []\n    \n    for case in test_cases:\n        F, A, d, b, rho = case[\"F\"], case[\"A\"], case[\"d\"], case[\"b\"], case[\"rho\"]\n\n        # Run ADMM solver\n        m_admm, n_it = admm_solver(F, A, d, b, rho, m0, u0, eps_pri, eps_mod, n_max)\n\n        # Run penalty method solver\n        m_pen = penalty_solver(F, A, d, b, rho)\n\n        # Calculate final metrics\n        phi_m_admm = np.linalg.norm(d - F @ m_admm)**2\n        res_admm = np.linalg.norm(A @ m_admm - b)\n        res_pen = np.linalg.norm(A @ m_pen - b)\n        \n        # Store results for this case\n        case_results = [n_it, phi_m_admm, res_admm, res_pen]\n        all_results.append(case_results)\n\n    # Format the output string as specified\n    result_strings = []\n    for res in all_results:\n        # Use a consistent, high-precision format for floats\n        formatted_res = [f\"{v}\" if isinstance(v, int) else f\"{v:.12g}\" for v in res]\n        result_strings.append(f\"[{','.join(formatted_res)}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3612288"}]}