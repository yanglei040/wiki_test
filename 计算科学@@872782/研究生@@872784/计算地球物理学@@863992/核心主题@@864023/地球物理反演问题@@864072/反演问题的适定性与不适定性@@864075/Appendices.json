{"hands_on_practices": [{"introduction": "地球物理勘测的几何布局直接决定了我们能够“看到”地下哪些部分。本次实践通过一个简化的层析成像问题，演示了有限的观测孔径如何产生一个由不可见模型特征构成的“零空间”，从而违背了适定性问题中的唯一性准则。通过对一个离散化算符进行线性代数分析，您将亲手计算出这种几何局限性所导致的模型不确定性的维度[@problem_id:3618829]。", "problem": "在一个具有有限源-接收器孔径的矩形区域上，进行了一项二维声波走时层析成像实验。慢度模型是一个定义在均匀网格上的扰动场 $m(x,z)$，该网格具有 $N_x$ 个横向列和 $N_z$ 个深度层。在高频（几何）近似下，对于近垂直射线（小的最大张角），横向位置 $x_i$ 处的一阶走时扰动可以很好地近似为以下形式的垂直积分灵敏度：\n$$\nd_i \\approx \\int_{0}^{Z_{\\max}} w(z)\\, m(x_i,z)\\, dz,\n$$\n其中 $w(z) \\ge 0$ 是一个已知的随深度变化的权重，反映了有限孔径几何结构下的路径长度和灵敏度。经过离散化后，得到如下的线性正演映射：\n$$\nd_i = \\sum_{j=1}^{N_z} w_j\\, m_{i,j}, \\quad i = 1,\\dots,N_x,\n$$\n其中对于所有 $j$ 都有 $w_j > 0$，并且 $m_{i,j}$ 是第 $i$ 列和第 $j$ 层的模型值。设模型向量为按列堆栈的数组 $m \\in \\mathbb{R}^{N_x N_z}$，正演算子 $A \\in \\mathbb{R}^{N_x \\times N_x N_z}$ 满足\n$$\n(A m)_i = \\sum_{j=1}^{N_z} w_j\\, m_{i,j},\n$$\n即，$A$ 有 $N_x$ 个不相交的行块，每个行块都等于行向量 $w^{\\top} \\in \\mathbb{R}^{N_z}$，作用于单列的各层上。\n\n- 仅使用线性代数的核心定义和给定的离散化正演映射，确定在 $N_x = 42$ 和 $N_z = 27$ 的情况下模型零空间 $\\mathcal{N}(A)$ 的维数。\n\n- 提出一种重新参数化的方法，通过选择参数来减小零空间，这些参数只保留在有限孔径几何结构下 $m$ 的可观测分量。然后，计算重新参数化后模型的零空间维数。\n\n将您的最终结果以一个包含两个元素的行矩阵形式报告，其中按顺序包含原始零空间维数和重新参数化后的零空间维数。无需四舍五入。", "solution": "该问题要求计算与一个简化的走时层析成像实验相关的线性正演算子 $A$ 的零空间维数，首先是针对原始参数化，然后是针对重新参数化的模型。\n\n首先，我们验证问题陈述的有效性。\n问题提供了一个离散化的线性正演映射 $d_i = \\sum_{j=1}^{N_z} w_j m_{i,j}$，它模拟了一个简化的二维声波层析成像实验。模型向量 $m \\in \\mathbb{R}^{N_x N_z}$ 表示网格上的慢度扰动，数据向量 $d \\in \\mathbb{R}^{N_x}$ 表示走时扰动。正演算子 $A$ 将模型空间映射到数据空间，$d=Am$。$A$ 的结构被明确定义，同时给出了维度 $N_x = 42$ 和 $N_z = 27$，以及权重 $w_j > 0$ 的条件。所提出的问题是精确的，可以用线性代数原理来回答。其背景是计算地球物理学中一个标准但简化的场景。该问题具有科学依据、内容自洽且适定。结论是该问题有效。\n\n我们分两部分进行求解。\n\n第1部分：原始模型的零空间 $\\mathcal{N}(A)$ 的维数。\n\n线性算子（或矩阵）的零空间维数通过秩-零度定理与其秩和其定义域的维数相关联：\n$$\n\\text{dim}(\\text{domain of } A) = \\text{rank}(A) + \\text{dim}(\\mathcal{N}(A))\n$$\n算子 $A$ 的定义域是所有可能的模型向量 $m$ 构成的空间。模型向量 $m$ 是慢度值 $m_{i,j}$ (其中 $i=1,\\dots,N_x$ 且 $j=1,\\dots,N_z$) 按列堆栈而成的数组。模型中的参数总数为 $N_x N_z$。因此，模型空间为 $\\mathbb{R}^{N_x N_z}$，其维数为：\n$$\n\\text{dim}(\\text{domain of } A) = N_x N_z\n$$\n算子 $A$ 是一个大小为 $N_x \\times (N_x N_z)$ 的矩阵。它对模型向量 $m$ 的作用由 $(A m)_i = \\sum_{j=1}^{N_z} w_j m_{i,j}$ 给出，对每一行 $i=1,\\dots,N_x$ 都成立。我们将模型向量表示为列向量 $m_i \\in \\mathbb{R}^{N_z}$ 的拼接，其中 $m_i = (m_{i,1}, \\dots, m_{i,N_z})^{\\top}$。设 $w = (w_1, \\dots, w_{N_z})^{\\top}$。第 $i$ 个数据点的正演问题是 $d_i = w^{\\top} m_i$。\n\n矩阵 $A$ 可以表示为分块形式。$A$ 的第 $i$ 行仅作用于模型向量的第 $i$ 个分块 $m_i$。第 $i$ 行中对应于 $m_i$ 元素的部分是行向量 $w^{\\top}$。第 $i$ 行中的所有其他元素都为零。因此，矩阵 $A$ 具有以下结构：\n$$\nA = \\begin{pmatrix}\nw^{\\top}  \\mathbf{0}  \\cdots  \\mathbf{0} \\\\\n\\mathbf{0}  w^{\\top}  \\cdots  \\mathbf{0} \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\n\\mathbf{0}  \\mathbf{0}  \\cdots  w^{\\top}\n\\end{pmatrix}\n$$\n其中每个 $w^{\\top}$ 是一个 $1 \\times N_z$ 的行向量，每个 $\\mathbf{0}$ 是一个 $1 \\times N_z$ 的零向量。\n\n$A$ 的秩是其行空间的维数，也就是线性无关行的数量。$A$ 的第 $i$ 行仅在第 $(i-1)N_z + 1$ 列到第 $iN_z$ 列有非零元素。第 $k$ 行（$k \\neq i$）仅在第 $(k-1)N_z + 1$ 列到第 $kN_z$ 列有非零元素。由于不同行的这些列索引集合是不相交的，因此这些行是线性无关的，只要没有行是零向量。\n问题陈述中说明，对于所有 $j=1,\\dots,N_z$ 都有 $w_j > 0$。这意味着向量 $w$ 不是零向量，因此行向量 $w^{\\top}$ 也不是零向量。所以，$A$ 的所有 $N_x$ 行都是非零且线性无关的。\n因此，$A$ 的秩等于其行数：\n$$\n\\text{rank}(A) = N_x\n$$\n现在我们应用秩-零度定理来求零空间 $\\mathcal{N}(A)$ 的维数：\n$$\n\\text{dim}(\\mathcal{N}(A)) = \\text{dim}(\\text{domain of } A) - \\text{rank}(A) = N_x N_z - N_x = N_x (N_z - 1)\n$$\n代入给定值 $N_x = 42$ 和 $N_z = 27$：\n$$\n\\text{dim}(\\mathcal{N}(A)) = 42 \\times (27 - 1) = 42 \\times 26 = 1092\n$$\n零空间由数据不可见的所有模型扰动组成。对于每一列 $i$，任何满足 $w^{\\top} \\delta m_i=0$ 的扰动 $\\delta m_i$ 都属于零空间。对于每一列，这是对 $N_z$ 个变量的一个线性约束，留下一个维数为 $N_z-1$ 的子空间。由于有 $N_x$ 个独立的列，零空间的总维数是 $N_x(N_z-1)$。\n\n第2部分：重新参数化和新的零空间维数。\n\n问题要求进行重新参数化，只保留实验可观测的 $m$ 的分量。对于每一列 $i$，数据 $d_i$ 正是加权平均值 $d_i = \\sum_{j=1}^{N_z} w_j m_{i,j}$。每一列的这个单一值是关于该列慢度剖面唯一可以被反演出来的信息。\n\n一个自然的重新参数化方法是定义一个新的模型向量，我们称之为 $\\tilde{m}$，其分量就是这些可观测的量本身。设新的模型参数为 $\\tilde{m}_i$（$i=1,\\dots,N_x$），定义为：\n$$\n\\tilde{m}_i = \\sum_{j=1}^{N_z} w_j m_{i,j}\n$$\n新的模型向量为 $\\tilde{m} = (\\tilde{m}_1, \\dots, \\tilde{m}_{N_x})^{\\top} \\in \\mathbb{R}^{N_x}$。用这个新模型表示的正演问题变为：\n$$\nd_i = \\tilde{m}_i\n$$\n用矩阵形式表示，即为 $d = \\tilde{A} \\tilde{m}$，其中 $\\tilde{A}$ 是新的正演算子。从方程 $d_i = \\tilde{m}_i$ 可以清楚地看出，$\\tilde{A}$ 是一个大小为 $N_x \\times N_x$ 的单位矩阵：\n$$\n\\tilde{A} = I_{N_x}\n$$\n这个新算子 $\\tilde{A}$ 的零空间 $\\mathcal{N}(\\tilde{A})$ 由所有满足 $\\tilde{A}\\tilde{m} = \\mathbf{0}$ 的向量 $\\tilde{m} \\in \\mathbb{R}^{N_x}$ 组成。\n$$\nI_{N_x} \\tilde{m} = \\mathbf{0} \\implies \\tilde{m} = \\mathbf{0}\n$$\n零空间中唯一的向量是零向量。零空间是平凡空间 $\\{\\mathbf{0}\\}$。\n因此，重新参数化模型的零空间维数为：\n$$\n\\text{dim}(\\mathcal{N}(\\tilde{A})) = 0\n$$\n这种重新参数化通过重新构建问题，只求解数据可以约束的模型部分，从而有效地消除了零空间。对于 $\\tilde{m}$ 的所得反问题将是适定的。\n\n要求的两个值是原始零空间维数 $1092$ 和重新参数化后的零空间维数 $0$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1092  0\n\\end{pmatrix}\n}\n$$", "id": "3618829"}, {"introduction": "在理解了唯一性问题之后，我们转向稳定性。即使理论上存在唯一解，它也可能对微小的数据误差极其敏感，导致解变得毫无意义。本次实践要求您通过一个编程练习，计算层析成像算符的奇异值分解（SVD），并观察奇异值谱的特征，从而揭示微小的奇异值是如何导致噪声被急剧放大，这正是病态问题的典型标志[@problem_id:3618830]。", "problem": "考虑一个宽度为 $L_x$、高度为 $L_y$ 的矩形域中的二维直线射线走时层析成像。设模型为单元格常慢度场 $m \\in \\mathbb{R}^n$，单位为秒/公里 ($\\mathrm{s}/\\mathrm{km}$)，该场在 $N_x \\times N_y$ 的均匀网格上离散化，因此 $n = N_x N_y$。对于固定的、位于域边界上的震源和接收器观测几何，数据 $d \\in \\mathbb{R}^m$ 是在直线射线近似下每个震源-接收器对之间的走时，单位为秒 ($\\mathrm{s}$)。离散射线变换 $R \\in \\mathbb{R}^{m \\times n}$ 通过相交长度的线性叠加将慢度映射到数据，即每个元素 $R_{ij}$ 等于第 $i$ 条射线在第 $j$ 个单元格内的长度，单位为公里。正演模型为\n$$\nd = R m.\n$$\n将奇异值分解 (SVD) 定义为以下分解形式\n$$\nR = U \\Sigma V^\\top,\n$$\n其中 $U \\in \\mathbb{R}^{m \\times r}$ 和 $V \\in \\mathbb{R}^{n \\times r}$ 具有标准正交列，$r = \\min(m,n)$，且 $\\Sigma = \\mathrm{diag}(\\sigma_1, \\sigma_2, \\ldots, \\sigma_r)$ 包含非负奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\cdots \\ge \\sigma_r \\ge 0$，单位为公里 ($\\mathrm{km}$)。Moore–Penrose伪逆为\n$$\nR^\\dagger = V \\Sigma^\\dagger U^\\top,\n$$\n其中 $\\Sigma^\\dagger = \\mathrm{diag}(1/\\sigma_1, \\ldots, 1/\\sigma_r)$ 对非零奇异值取倒数，对精确零值取零。根据Hadamard的适定性定义，稳定性要求 $d$ 中的小扰动在 $m$ 中产生同比例的小变化。在此线性设定下，从数据扰动 $\\delta d$（单位为秒，$\\mathrm{s}$）到模型扰动 $\\delta m$（单位为秒/公里，$\\mathrm{s}/\\mathrm{km}$）的最坏情况放大，通过 $\\delta m = R^\\dagger \\delta d$ 实现，由 $R^\\dagger$ 的算子范数控制，\n$$\n\\|R^\\dagger\\|_2 = \\frac{1}{\\sigma_{\\min}},\n$$\n其单位为逆公里 ($\\mathrm{km}^{-1}$)，其中 $\\sigma_{\\min}$ 表示 $R$ 的最小非零奇异值。当观测几何（射线数量 $m$）固定，而网格被加密（$N_x, N_y$ 增加）时，矩阵 $R$ 通常会产生一个不断增大的数值零空间，$\\sigma_{\\min}$ 趋近于零，$\\|R^\\dagger\\|_2$ 增大，这表明由于不稳定性而导致的不适定性。\n\n您的任务是基于这些基本定义和事实，实现以下内容：\n- 通过计算直线射线与轴对齐网格单元的精确相交长度来构建 $R$。域为 $[0,L_x] \\times [0,L_y]$，其中 $L_x = L_y = 1.0$ 公里，射线是震源点和接收器点之间的直线段。\n- 使用奇异值分解 (SVD) 计算 $R$ 的奇异值谱，并使用阈值\n$$\n\\tau = \\max(m,n)\\,\\epsilon\\,\\sigma_{\\max},\n$$\n来确定数值秩 $\\mathrm{rank}(R)$，其中 $\\epsilon$ 是双精度浮点数的机器精度，$\\sigma_{\\max}$ 是最大奇异值，并估计数值零空间维度 $n - \\mathrm{rank}(R)$。\n- 定义一个与 $\\sigma_{\\min}$ 相关联的左奇异向量对齐的确定性扰动 $\\delta d$，其大小缩放为 $\\|\\delta d\\|_2 = \\varepsilon$，其中 $\\varepsilon = 0.005$ 秒。使用 SVD 因子计算 $\\delta m = R^\\dagger \\delta d$，其中仅对超过阈值 $\\tau$ 的奇异值取倒数，否则取零。报告放大比\n$$\n\\frac{\\|\\delta m\\|_2}{\\|\\delta d\\|_2},\n$$\n单位为逆公里 ($\\mathrm{km}^{-1}$)。\n\n观测几何：\n- 在左边界上均匀放置 $N_s$ 个震源，位置为 $(0, y_i)$，其中 $y_i = \\left(i+\\tfrac{1}{2}\\right)\\tfrac{L_y}{N_s}$，对于 $i=0,\\ldots,N_s-1$；并在右边界上均匀放置 $N_r$ 个接收器，位置为 $(L_x, y_j)$，其中 $y_j = \\left(j+\\tfrac{1}{2}\\right)\\tfrac{L_y}{N_r}$，对于 $j=0,\\ldots,N_r-1$。包括所有从左到右的震源-接收器对。\n- 在下边界上均匀放置 $N_s$ 个震源，位置为 $(x_i, 0)$，其中 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\tfrac{L_x}{N_s}$；并在上边界上均匀放置 $N_r$ 个接收器，位置为 $(x_j, L_y)$。包括所有从下到上的震源-接收器对。\n- 对所有测试用例，使用 $N_s = N_r = 6$。\n\n测试套件：\n- 情况1（理想情况，轻度超定）：$N_x = 8$, $N_y = 8$。\n- 情况2（欠定，中等程度细化）：$N_x = 16$, $N_y = 16$。\n- 情况3（欠定，更精细的细化）：$N_x = 24$, $N_y = 24$。\n- 情况4（欠定，精细细化边界）：$N_x = 32$, $N_y = 32$。\n\n对于每种情况，计算并返回列表\n$$\n\\left[\\sigma_{\\min}, \\ \\|R^\\dagger\\|_2, \\ \\frac{\\|\\delta m\\|_2}{\\|\\delta d\\|_2}, \\ n - \\mathrm{rank}(R)\\right],\n$$\n其中 $\\sigma_{\\min}$ 是高于阈值 $\\tau$ 的最小奇异值（单位为公里），$\\|R^\\dagger\\|_2$ 是伪逆的算子2-范数（单位为逆公里），$\\|\\delta m\\|_2 / \\|\\delta d\\|_2$ 是计算出的放大比（单位为逆公里），$n - \\mathrm{rank}(R)$ 是整数数值零空间维度。将所有浮点数输出四舍五入到六位小数，其中 $\\sigma_{\\min}$ 的单位为公里，最后两个浮点数量的单位为逆公里，整数数量表示为整数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含结果，格式为列表的列表，每个内部列表按指定顺序对应一个测试用例，不含空格，例如：\n`[[0.123456,8.100000,8.100000,12],[...],[...],[...]]`", "solution": "直线射线走时层析成像的正演模型由沿射线路径的慢度积分来描述。对于连接震源点和接收器点的射线 $\\gamma$，其走时为\n$$\nt_\\gamma = \\int_\\gamma s(\\mathbf{x})\\, \\mathrm{d}\\ell,\n$$\n其中 $s(\\mathbf{x})$ 是慢度，单位为秒/公里，$\\mathrm{d}\\ell$ 是无穷小路径长度，单位为公里。将 $s(\\mathbf{x})$ 在一个由轴对齐的矩形单元组成的 $N_x \\times N_y$ 网格上离散化，并假设每个单元内慢度恒定，得到\n$$\nd_i = \\sum_{j=1}^{n} R_{ij} m_j,\n$$\n其中 $d_i$ 是第 $i$ 条射线的走时，$m_j$ 是第 $j$ 个单元格的慢度，$R_{ij}$ 是第 $i$ 条射线在第 $j$ 个单元格内的相交长度，单位为公里。堆叠所有射线方程，得到 $d = R m$，其中 $R \\in \\mathbb{R}^{m \\times n}$。\n\nHadamard适定性要求存在性、唯一性和稳定性。在线性离散设定中，2-范数下的稳定性由奇异值分解 (SVD) $R = U \\Sigma V^\\top$ 决定，其中奇异值为 $\\sigma_k \\ge 0$。Moore–Penrose伪逆 $R^\\dagger = V \\Sigma^\\dagger U^\\top$ 将数据扰动映射到模型扰动。算子2-范数满足\n$$\n\\|R^\\dagger\\|_2 = \\max_{\\|x\\|_2=1} \\|R^\\dagger x\\|_2 = \\frac{1}{\\sigma_{\\min}},\n$$\n其中 $\\sigma_{\\min}$ 是 $R$ 的最小非零奇异值。因此，如果 $\\sigma_{\\min}$ 很小，任何与相应左奇异向量 $u_{\\min}$ 对齐的数据扰动分量，在模型空间中都将被放大约 $1/\\sigma_{\\min}$ 倍。当射线数量 $m$ 保持固定而网格被加密（$N_x, N_y$ 增大）时，未知数数量 $n$ 增加，矩阵 $R$ 变得越来越秩亏。更多的奇异值接近于零，数值零空间维度 $n - \\mathrm{rank}(R)$ 增加。这导致了由不稳定性引起的不适定性，表现为 $\\|R^\\dagger\\|_2$ 的增长。\n\n算法构建：\n1. 几何与射线：定义域为 $[0, L_x] \\times [0, L_y]$，其中 $L_x = L_y = 1.0$ 公里。在左边界 $(0, y_i)$ 处放置 $N_s = 6$ 个震源，其中 $y_i = \\left(i + \\tfrac{1}{2}\\right) \\tfrac{L_y}{N_s}$ 对于 $i = 0, \\ldots, 5$；在右边界 $(L_x, y_j)$ 处放置 $N_r = 6$ 个接收器，其中 $y_j = \\left(j + \\tfrac{1}{2}\\right) \\tfrac{L_y}{N_r}$。包括所有 $N_s N_r$ 条从左到右的射线。类似地，在下边界 $(x_i, 0)$ 处放置 $N_s$ 个震源，其中 $x_i = \\left(i + \\tfrac{1}{2}\\right) \\tfrac{L_x}{N_s}$；在上边界 $(x_j, L_y)$ 处放置 $N_r$ 个接收器，包括所有 $N_s N_r$ 条从下到上的射线。总射线数为 $m = 2 N_s N_r = 72$。\n2. 离散射线变换：对于每条从点 $\\mathbf{p}_0 = (x_0, y_0)$ 到 $\\mathbf{p}_1 = (x_1, y_1)$ 的射线，将线段参数化为 $\\mathbf{p}(t) = \\mathbf{p}_0 + t (\\mathbf{p}_1 - \\mathbf{p}_0)$，其中 $t \\in [0, 1]$。计算射线与垂直和水平网格线 $x = x_k$ 和 $y = y_\\ell$ 相交的所有交点参数 $t$。包含 $t=0$ 和 $t=1$。对 $[0, 1]$ 内唯一的 $t$ 值进行排序，得到子段 $[t_k, t_{k+1}]$。每个子段完全位于单个单元格内。对于每个子段，计算其长度为 $L_\\mathrm{seg} = \\|\\mathbf{p}_1 - \\mathbf{p}_0\\|_2 (t_{k+1} - t_k)$（单位为公里），并将此长度分配给由中点 $\\mathbf{p}(\\tfrac{t_k + t_{k+1}}{2})$ 确定的相应单元格索引。累积射线所有段的长度，以构成其在 $R$ 中的行。\n3. 奇异值分析：计算SVD $R = U \\Sigma V^\\top$，其中 $\\Sigma = \\mathrm{diag}(\\sigma_1, \\ldots, \\sigma_r)$，$r = \\min(m, n)$。令 $\\sigma_{\\max} = \\sigma_1$。定义数值阈值\n$$\n\\tau = \\max(m,n) \\, \\epsilon \\, \\sigma_{\\max},\n$$\n其中 $\\epsilon$ 是双精度浮点数的机器精度（约为 $2.22 \\times 10^{-16}$）。数值秩为 $\\mathrm{rank}(R) = \\#\\{k: \\sigma_k  \\tau \\}$。数值零空间维度为 $n - \\mathrm{rank}(R)$。最小非零奇异值为 $\\sigma_{\\min} = \\min\\{\\sigma_k: \\sigma_k  \\tau\\}$。\n4. 伪逆与放大：通过设置 $(\\Sigma^\\dagger)_{kk} = 1/\\sigma_k$（如果 $\\sigma_k  \\tau$）和 $(\\Sigma^\\dagger)_{kk} = 0$（否则）来构建 $\\Sigma^\\dagger$。伪逆为 $R^\\dagger = V \\Sigma^\\dagger U^\\top$。在数据空间中选择一个与 $\\sigma_{\\min}$ 的左奇异向量对齐的确定性扰动，即 $\\delta d = \\varepsilon \\, u_{\\min}$，其中 $\\|\\delta d\\|_2 = \\varepsilon = 0.005$ 秒。计算模型扰动 $\\delta m = R^\\dagger \\delta d$。放大比为\n$$\n\\frac{\\|\\delta m\\|_2}{\\|\\delta d\\|_2} = \\frac{\\|R^\\dagger \\delta d\\|_2}{\\varepsilon},\n$$\n在理想情况下，该比值等于 $1/\\sigma_{\\min}$，并且在数值上，当 $\\delta d$ 与 $u_{\\min}$ 对齐时，它与 $\\|R^\\dagger\\|_2$ 相匹配。\n\n测试套件的预期行为：\n- 情况1（$N_x = N_y = 8$）有 $n = 64$ 个未知数和 $m = 72$ 条射线；它是轻度超定的，通常条件更好，具有相对较大的 $\\sigma_{\\min}$ 和较小的 $\\|R^\\dagger\\|_2$。\n- 情况2-4（$N_x = N_y$ 分别为 $16$, $24$, $32$）是越来越欠定的，未知数分别为 $n = 256$, $576$, 和 $1024$，但射线数固定为 $m = 72$。数值零空间维度增加，$\\sigma_{\\min}$ 通常减小，$\\|R^\\dagger\\|_2$ 和放大比都随之增长，揭示了在网格加密下由于不稳定性而导致的不适定性。\n\n实现细节：\n- 单位：$R$ 的元素单位为公里 ($\\mathrm{km}$)。奇异值 $\\sigma_k$ 的单位为公里。算子范数 $\\|R^\\dagger\\|_2$ 和放大比 $\\|\\delta m\\|_2/\\|\\delta d\\|_2$ 的单位为逆公里 ($\\mathrm{km}^{-1}$)。\n- 数值阈值处理确保接近零的奇异值（低于 $\\tau$）被视为零，以避免因伪倒数引起的数值爆炸。\n- 输出：对于每种情况，报告 $\\sigma_{\\min}$（公里）、$\\|R^\\dagger\\|_2$ ($\\mathrm{km}^{-1}$)、$\\|\\delta m\\|_2/\\|\\delta d\\|_2$ ($\\mathrm{km}^{-1}$) 和 $n - \\mathrm{rank}(R)$（整数），将浮点数值四舍五入到六位小数。将所有情况的结果聚合成一个列表的列表，打印在单行上，不含空格。\n\n这种有原则的方法将走时积分的核心定义与离散算子联系起来，使用奇异值分解来推断稳定性属性，并通过直接计算 $\\delta d$ 如何通过 $R^\\dagger$ 放大为 $\\delta m$ 来量化网格加密过程中的不适定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_sources_receivers(Lx, Ly, Ns, Nr):\n    # Left-to-right rays\n    ys_src = (np.arange(Ns) + 0.5) * (Ly / Ns)\n    ys_rcv = (np.arange(Nr) + 0.5) * (Ly / Nr)\n    rays_lr = [((0.0, ys), (Lx, yr)) for ys in ys_src for yr in ys_rcv]\n    # Bottom-to-top rays\n    xs_src = (np.arange(Ns) + 0.5) * (Lx / Ns)\n    xs_rcv = (np.arange(Nr) + 0.5) * (Lx / Nr)\n    rays_bt = [((xs, 0.0), (xr, Ly)) for xs in xs_src for xr in xs_rcv]\n    return rays_lr + rays_bt\n\ndef ray_cell_lengths(p0, p1, x_edges, y_edges, nx, ny):\n    x0, y0 = p0\n    x1, y1 = p1\n    dx = x1 - x0\n    dy = y1 - y0\n    # Full ray length\n    L = np.hypot(dx, dy)\n    if L == 0:\n        return {}\n    # Compute intersection parameters t where the ray crosses grid lines\n    t_vals = {0.0, 1.0}\n    if abs(dx) > 1e-9:\n        tx = (x_edges - x0) / dx\n        t_vals.update(t for t in tx if 0.0 = t = 1.0)\n    if abs(dy) > 1e-9:\n        ty = (y_edges - y0) / dy\n        t_vals.update(t for t in ty if 0.0 = t = 1.0)\n    # Sort unique t's\n    t_vals = sorted(list(t_vals))\n    # Accumulate lengths into cells\n    lengths = {}\n    for k in range(len(t_vals) - 1):\n        t_start = t_vals[k]\n        t_end = t_vals[k+1]\n        if t_end - t_start  1e-9:\n            continue\n        tm = 0.5 * (t_start + t_end)\n        xm = x0 + dx * tm\n        ym = y0 + dy * tm\n        # Determine cell indices using edges\n        ix = np.searchsorted(x_edges, xm, side='right') - 1\n        iy = np.searchsorted(y_edges, ym, side='right') - 1\n        if ix  0 or ix >= nx or iy  0 or iy >= ny:\n            continue\n        seg_len = L * (t_end - t_start)\n        idx = ix + iy * nx\n        lengths[idx] = lengths.get(idx, 0.0) + seg_len\n    return lengths\n\ndef build_R_matrix(nx, ny, Lx, Ly, rays):\n    x_edges = np.linspace(0.0, Lx, nx + 1)\n    y_edges = np.linspace(0.0, Ly, ny + 1)\n    num_rays = len(rays)\n    R = np.zeros((num_rays, nx * ny), dtype=float)\n    for i, (p0, p1) in enumerate(rays):\n        lengths = ray_cell_lengths(p0, p1, x_edges, y_edges, nx, ny)\n        if lengths:\n            idxs = np.fromiter(lengths.keys(), dtype=int)\n            vals = np.fromiter(lengths.values(), dtype=float)\n            R[i, idxs] = vals\n    return R\n\ndef svd_metrics(R, eps= np.finfo(float).eps):\n    # Compute SVD\n    U, s, Vt = np.linalg.svd(R, full_matrices=False)\n    m, n = R.shape\n    smax = s[0] if s.size > 0 else 0.0\n    tau = max(m, n) * eps * smax\n    # Numerical rank and nullity\n    above = s > tau\n    rank = int(np.sum(above))\n    nullity = n - rank\n    if rank > 0:\n        smin_nonzero = float(np.min(s[above]))\n        # index of smallest nonzero singular value\n        idx_min = int(np.where(s == smin_nonzero)[0][0])\n    else:\n        smin_nonzero = 0.0\n        idx_min = None\n    # Operator norm of pseudoinverse\n    op_norm_pinv = np.inf if smin_nonzero == 0.0 else (1.0 / smin_nonzero)\n    return U, s, Vt, smin_nonzero, op_norm_pinv, tau, rank, nullity, idx_min\n\ndef apply_pseudoinverse(U, s, Vt, tau, delta_d):\n    # Build filtered reciprocal of singular values\n    inv_s = np.zeros_like(s)\n    mask = s > tau\n    inv_s[mask] = 1.0 / s[mask]\n    # Compute R^dagger * delta_d via SVD factors: V * diag(inv_s) * U^T * delta_d\n    Ut_dd = U.T @ delta_d\n    temp = inv_s * Ut_dd\n    delta_m = Vt.T @ temp\n    return delta_m\n\ndef format_results(results):\n    # Format nested list without spaces, floats rounded to 6 decimals\n    parts = []\n    for sm, opn, ampr, nullity in results:\n        parts.append(f\"[{sm:.6f},{opn:.6f},{ampr:.6f},{int(nullity)}]\")\n    return \"[\" + \",\".join(parts) + \"]\"\n\ndef solve():\n    # Define parameters\n    Lx = 1.0  # kilometers\n    Ly = 1.0  # kilometers\n    Ns = 6\n    Nr = 6\n    rays = generate_sources_receivers(Lx, Ly, Ns, Nr)\n    # Test suite: list of (Nx, Ny)\n    test_cases = [\n        (8, 8),    # Case 1\n        (16, 16),  # Case 2\n        (24, 24),  # Case 3\n        (32, 32),  # Case 4\n    ]\n    epsilon = 0.005  # seconds magnitude for ||delta d||_2\n\n    results = []\n    for Nx, Ny in test_cases:\n        R = build_R_matrix(Nx, Ny, Lx, Ly, rays)\n        U, s, Vt, smin, opnorm, tau, rank, nullity, idx_min = svd_metrics(R)\n        # Define delta d aligned with left singular vector associated with smallest nonzero singular value\n        if idx_min is not None and U.shape[1] > idx_min:\n            u_min = U[:, idx_min]\n            # Scale to have ||delta d||_2 = epsilon seconds\n            delta_d = (epsilon / np.linalg.norm(u_min)) * u_min\n            delta_m = apply_pseudoinverse(U, s, Vt, tau, delta_d)\n            norm_dm = np.linalg.norm(delta_m)\n            norm_dd = np.linalg.norm(delta_d)\n            amp_ratio = norm_dm / norm_dd if norm_dd > 0 else np.inf\n        else:\n            # No nonzero singular values; set amplification to infinity\n            amp_ratio = np.inf\n        results.append((smin, opnorm, amp_ratio, nullity))\n\n    print(format_results(results))\n\nsolve()\n```", "id": "3618830"}, {"introduction": "许多现代地球物理反演问题本质上是非线性的，这为适定性分析带来了新的挑战。对于非线性问题，适定性不仅关乎算子本身，还与目标函数的“形状”或景观密切相关。本练习通过一个简化的一维声学反演场景，让您探索模型参数化的选择（例如，慢度 $s$ 与速度 $v$）如何显著改变问题的局部凸性，进而影响局部优化方法的成败[@problem_id:3618869]。", "problem": "考虑一个简化的一维声学反演场景，该场景捕捉了全波形反演（FWI）在参数化选择方面的基本非线性。假设有两个水平均质层，其属性未知，声波从一个共同的源以直线传播到多个接收器。将第 $k$ 层的速度记为 $v_k$（单位为 $\\mathrm{m/s}$），慢度记为 $s_k$（单位为 $\\mathrm{s/m}$），满足 $s_k = 1 / v_k$。对于接收器索引 $j$，令 $L_{j1}$ 和 $L_{j2}$ 分别表示穿过第 1 层和第 2 层的固定路径长度（单位为 $\\mathrm{m}$）。在接收器 $j$ 处的预测单程走时（单位为 $\\mathrm{s}$）为\n- 在慢度参数化 $s = (s_1, s_2) \\in \\mathbb{R}^2$下：$t_j(s) = L_{j1} s_1 + L_{j2} s_2$，\n- 在速度参数化 $v = (v_1, v_2) \\in \\mathbb{R}^2$下：$t_j(v) = L_{j1} v_1^{-1} + L_{j2} v_2^{-1}$。\n\n给定观测走时 $d_j$（单位为 $\\mathrm{s}$），定义最小二乘目标函数\n$$\nJ(p) = \\frac{1}{2} \\sum_{j=1}^{m} \\left( t_j(p) - d_j \\right)^2,\n$$\n其中 $p$ 代表 $s$ 或 $v$，$m$ 是接收器的数量。根据定义， $J$ 在某一点的局部凸性由该点二阶导数的 Hessian 矩阵的半正定性来表征；严格凸性对应于正定性。Hessian 矩阵的特征值量化了曲率；负特征值表示负曲率方向和局部非凸性。\n\n您的任务是：\n1. 从链式法则和残差平方和的 Hessian 矩阵定义出发，推导在 $s$ 和 $v$ 两种参数化下 $J$ 的精确 Hessian 矩阵表达式，用路径长度 $L_{jk}$、模型参数 $p$ 和残差 $r_j(p) = t_j(p) - d_j$ 表示。不要使用任何预先引用的 FWI 特定公式；直接根据上面给出的定义进行推导。\n2. 实现一个程序，对于下面的每个测试用例，计算在指定评估点两种参数化下的 Hessian 矩阵，计算其特征值，并报告：\n   - 慢度参数化下的最小特征值，\n   - 速度参数化下的最小特征值，\n   - 一个布尔值，说明 Hessian 矩阵是否是半正定的（在数值公差范围内所有特征值 $\\ge 0$），\n   - 一个布尔值，说明 Hessian 矩阵是否是正定的（在数值公差范围内所有特征值 $ 0$）。\n3. 根据整个测试套件中最小特征值的符号，解释参数化的选择如何影响局部凸性，从而影响局部适定性。\n\n测试套件规范：\n- 物理常数和单位：\n  - 路径长度 $L_{jk}$ 的单位是 $\\mathrm{m}$。\n  - 速度 $v_k$ 的单位是 $\\mathrm{m/s}$。\n  - 慢度 $s_k$ 的单位是 $\\mathrm{s/m}$。\n  - 走时 $t_j$ 和 $d_j$ 的单位是 $\\mathrm{s}$。\n- 用于生成数据的真实模型：\n  - $v_1^{\\mathrm{true}} = 2500$ 且 $v_2^{\\mathrm{true}} = 2000$。\n  - $s_k^{\\mathrm{true}} = 1 / v_k^{\\mathrm{true}}$。\n- 接收器和路径长度：\n  - 接收器 1：$(L_{11}, L_{12}) = (1000, 500)$。\n  - 接收器 2：$(L_{21}, L_{22}) = (700, 800)$。\n- 观测数据生成：\n  - 对于任何接收器 $j$，设置 $d_j = L_{j1} s_1^{\\mathrm{true}} + L_{j2} s_2^{\\mathrm{true}}$。\n- 三个评估案例：\n  - 案例 A（理想路径，数据充分，在真实模型处）：\n    - 使用两个接收器 $j \\in \\{1, 2\\}$。\n    - 在 $s = s^{\\mathrm{true}}$ 和 $v = v^{\\mathrm{true}}$ 处评估 Hessian 矩阵。\n  - 案例 B（速度的非线性区域，远离真实模型）：\n    - 使用两个接收器 $j \\in \\{1, 2\\}$。\n    - 在 $v = (100000, 100000)$ 和相应的 $s = (1/100000, 1/100000)$ 处进行评估。\n  - 案例 C（数据不足的边界情况，秩亏几何）：\n    - 仅使用接收器 $j = 1$。\n    - 在 $s = s^{\\mathrm{true}}$ 和 $v = v^{\\mathrm{true}}$ 处评估。\n- 定性检查的数值公差：\n  - 使用公差 $\\tau = 10^{-12}$。如果特征值 $\\lambda \\ge -\\tau$，则视为非负；如果 $\\lambda  \\tau$，则视为严格为正。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个包含三个内部列表的列表，每个案例一个，内容和顺序如下：\n  - 对于案例 A：$[\\lambda_{\\min}^{(s)}, \\lambda_{\\min}^{(v)}, \\mathrm{is\\_psd}^{(s)}, \\mathrm{is\\_psd}^{(v)}, \\mathrm{is\\_pd}^{(s)}, \\mathrm{is\\_pd}^{(v)}]$。\n  - 对于案例 B：结构与案例 A 相同。\n  - 对于案例 C：结构与案例 A 相同。\n- 这里，$\\lambda_{\\min}^{(s)}$ 是慢度参数化下 Hessian 矩阵的最小特征值，$\\lambda_{\\min}^{(v)}$ 是速度参数化下 Hessian 矩阵的最小特征值。布尔标志根据上述公差对应于半正定和正定检验。\n- 程序必须精确输出一行，例如：\n  - `[[0.1,0.05,True,True,True,True],[...],[...]]`。\n\n不应读取任何外部输入；运行程序所需的所有数字均已在上面指定。输出是无单位的浮点数和定义的布尔值。请完全按照规定表达最终输出；无需在输出行中报告物理单位。", "solution": "任务是分析一个简化的一维声学反演问题在两种不同参数化（慢度 $s = (s_1, s_2)$ 和速度 $v = (v_1, v_2)$）下的局部凸性。某一点的局部凸性由该点目标函数的 Hessian 矩阵的性质决定。具体来说，我们将推导 Hessian 矩阵，实现其计算，并对三个不同案例的结果进行解释。\n\n### 步骤 1：Hessian 矩阵的推导\n\n最小二乘目标函数由下式给出：\n$$\nJ(p) = \\frac{1}{2} \\sum_{j=1}^{m} \\left( t_j(p) - d_j \\right)^2 = \\frac{1}{2} \\sum_{j=1}^{m} r_j(p)^2\n$$\n其中 $p$ 是参数矢量（$s$ 或 $v$），$t_j(p)$ 是接收器 $j$ 的预测走时，$d_j$ 是观测走时，$r_j(p) = t_j(p) - d_j$ 是残差。\n\nHessian 矩阵 $H$ 的元素为 $H_{kl} = \\frac{\\partial^2 J}{\\partial p_k \\partial p_l}$。我们首先求梯度分量 $\\frac{\\partial J}{\\partial p_k}$：\n$$\n\\frac{\\partial J}{\\partial p_k} = \\frac{\\partial}{\\partial p_k} \\left( \\frac{1}{2} \\sum_{j=1}^{m} r_j(p)^2 \\right) = \\sum_{j=1}^{m} r_j(p) \\frac{\\partial r_j(p)}{\\partial p_k} = \\sum_{j=1}^{m} r_j(p) \\frac{\\partial t_j(p)}{\\partial p_k}\n$$\n因为 $d_j$ 是常数。现在我们使用乘法法则再次对 $p_l$ 求导：\n$$\nH_{kl}(p) = \\frac{\\partial^2 J}{\\partial p_k \\partial p_l} = \\frac{\\partial}{\\partial p_l} \\left( \\sum_{j=1}^{m} r_j(p) \\frac{\\partial t_j(p)}{\\partial p_k} \\right) = \\sum_{j=1}^{m} \\left( \\frac{\\partial r_j(p)}{\\partial p_l} \\frac{\\partial t_j(p)}{\\partial p_k} + r_j(p) \\frac{\\partial^2 t_j(p)}{\\partial p_k \\partial p_l} \\right)\n$$\n代入 $\\frac{\\partial r_j(p)}{\\partial p_l} = \\frac{\\partial t_j(p)}{\\partial p_l}$，我们得到 Hessian 矩阵的通用表达式：\n$$\nH_{kl}(p) = \\sum_{j=1}^{m} \\left( \\frac{\\partial t_j(p)}{\\partial p_k} \\frac{\\partial t_j(p)}{\\partial p_l} + r_j(p) \\frac{\\partial^2 t_j(p)}{\\partial p_k \\partial p_l} \\right)\n$$\n第一项 $\\sum_j \\frac{\\partial t_j}{\\partial p_k} \\frac{\\partial t_j}{\\partial p_l}$ 对应于 Hessian 矩阵的 Gauss-Newton 近似。第二项涉及正演模型 $t_j(p)$ 的二阶导数，是潜在非凸性的来源。\n\n#### 慢度参数化 $s = (s_1, s_2)$ 的 Hessian 矩阵\n\n正演模型在慢度上是线性的：$t_j(s) = L_{j1}s_1 + L_{j2}s_2$。\n一阶偏导数为：\n$$\n\\frac{\\partial t_j}{\\partial s_1} = L_{j1}, \\quad \\frac{\\partial t_j}{\\partial s_2} = L_{j2}\n$$\n二阶偏导数全为零：\n$$\n\\frac{\\partial^2 t_j(s)}{\\partial s_k \\partial s_l} = 0 \\quad \\text{for } k,l \\in \\{1,2\\}\n$$\n因此，通用 Hessian 表达式中的第二项消失。慢度的 Hessian 矩阵 $H^{(s)}$ 为：\n$$\nH^{(s)}_{kl}(s) = \\sum_{j=1}^{m} \\frac{\\partial t_j(s)}{\\partial s_k} \\frac{\\partial t_j(s)}{\\partial s_l}\n$$\n其分量为：\n$$\nH^{(s)}_{11} = \\sum_{j=1}^{m} L_{j1}^2, \\quad H^{(s)}_{12} = H^{(s)}_{21} = \\sum_{j=1}^{m} L_{j1}L_{j2}, \\quad H^{(s)}_{22} = \\sum_{j=1}^{m} L_{j2}^2\n$$\n这可以写成矩阵形式 $H^{(s)} = L^T L$，其中 $L$ 是一个 $m \\times 2$ 的矩阵，其元素为 $L_{jk}$。该 Hessian 矩阵与模型参数 $s$ 和数据残差 $r_j$ 无关。作为一个 Gram 矩阵，$H^{(s)}$ 总是半正定的。\n\n#### 速度参数化 $v = (v_1, v_2)$ 的 Hessian 矩阵\n\n正演模型在速度上是非线性的：$t_j(v) = L_{j1}v_1^{-1} + L_{j2}v_2^{-1}$。\n一阶偏导数为：\n$$\n\\frac{\\partial t_j}{\\partial v_1} = -L_{j1}v_1^{-2}, \\quad \\frac{\\partial t_j}{\\partial v_2} = -L_{j2}v_2^{-2}\n$$\n二阶偏导数为：\n$$\n\\frac{\\partial^2 t_j}{\\partial v_1^2} = 2L_{j1}v_1^{-3}, \\quad \\frac{\\partial^2 t_j}{\\partial v_2^2} = 2L_{j2}v_2^{-3}, \\quad \\frac{\\partial^2 t_j}{\\partial v_1 \\partial v_2} = 0\n$$\n将这些代入通用的 Hessian 公式，得到 $H^{(v)}(v)$ 的分量：\n$$\nH^{(v)}_{11} = \\sum_{j=1}^{m} \\left( (-L_{j1}v_1^{-2})^2 + r_j(v) (2L_{j1}v_1^{-3}) \\right) = v_1^{-4} \\sum_{j=1}^{m} L_{j1}^2 + 2v_1^{-3} \\sum_{j=1}^{m} r_j(v) L_{j1}\n$$\n$$\nH^{(v)}_{22} = \\sum_{j=1}^{m} \\left( (-L_{j2}v_2^{-2})^2 + r_j(v) (2L_{j2}v_2^{-3}) \\right) = v_2^{-4} \\sum_{j=1}^{m} L_{j2}^2 + 2v_2^{-3} \\sum_{j=1}^{m} r_j(v) L_{j2}\n$$\n$$\nH^{(v)}_{12} = H^{(v)}_{21} = \\sum_{j=1}^{m} \\left( (-L_{j1}v_1^{-2})(-L_{j2}v_2^{-2}) + r_j(v) \\cdot 0 \\right) = v_1^{-2}v_2^{-2} \\sum_{j=1}^{m} L_{j1}L_{j2}\n$$\n其中残差为 $r_j(v) = (L_{j1}v_1^{-1} + L_{j2}v_2^{-1}) - d_j$。最终得到的速度 Hessian 矩阵 $H^{(v)}(v)$ 明确地依赖于评估点 $v$ 和数据残差 $r_j(v)$。\n\n### 步骤 2：结果解释\n\n推导出的 Hessian 矩阵形式揭示了两种参数化之间的根本区别。\n\n- **慢度 ($s$)**：由于正演问题在 $s$ 上是线性的，目标函数 $J(s)$ 是一个二次函数（抛物面）。其 Hessian 矩阵 $H^{(s)}$ 处处恒定，仅取决于采集几何 $L$。只要几何矩阵 $L$ 具有满列秩（即，至少有两个接收器的路径长度不成比例），$H^{(s)}$ 就是正定的。这意味着 $J(s)$ 是严格凸的，并有唯一的全局最小值。这是一个局部和全局都适定的优化问题。案例 A 将证明这一点，其 Hessian 矩阵是正定的。案例 C 只有一个接收器，导致 $L$ 秩亏，使得 $H^{(s)}$ 仅为半正定；该问题存在一个零空间，对应于一个解族。\n\n- **速度 ($v$)**：正演问题在 $v$ 上是非线性的，导致目标函数 $J(v)$ 不是二次函数。Hessian 矩阵 $H^{(v)}$ 包含一个依赖于残差的二阶项。\n  - 在案例 A 中，我们在真实模型处进行评估，此时残差为零（$r_j=0$）。Hessian 矩阵简化为 Gauss-Newton Hessian 矩阵，由于良好的几何形状，它是正定的。这表明在真实解周围是局部凸的。\n  - 在案例 B 中，我们在远离真实模型的地方进行评估。预测时间远小于观测时间，导致较大的负残差。二阶项 $2v_k^{-3} \\sum_j r_j(v) L_{jk}$ 变成一个大的负数，这可能会压倒 $H^{(v)}$ 对角线上的正 Gauss-Newton 项。这可能导致 Hessian 矩阵出现负特征值，表明存在局部非凸性（鞍点或局部最大值）。这就是 FWI 中的“周波跳跃”问题，局部优化方法可能会陷入远离真实解的陷阱。\n  - 在案例 C 中，在真实模型处（$r_j=0$）但几何形状是秩亏的，Gauss-Newton Hessian 矩阵将是奇异的（半正定但非正定），反映了由有限数据引起的内在非唯一性。\n\n总而言之，在慢度中进行参数化使这个走时问题线性化，保证了目标函数的地形简单且是凸的。在速度中进行参数化，这是一个更物理但非线性的选择，会产生一个复杂的地形，其中包含非凸区域，这使得反演过程复杂化，并使其对初始模型敏感。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the acoustic inversion problem by calculating Hessians and their eigenvalues\n    for three specified test cases.\n    \"\"\"\n\n    # --- Problem Definition ---\n\n    # True model parameters\n    v_true = np.array([2500.0, 2000.0])  # m/s\n    s_true = 1.0 / v_true                # s/m\n\n    # Receiver path lengths (m)\n    L_full = np.array([\n        [1000.0, 500.0],  # Receiver 1\n        [700.0, 800.0]    # Receiver 2\n    ])\n\n    # Observed data generation (noise-free)\n    d_obs_full = L_full @ s_true\n\n    # Numerical tolerance for definiteness checks\n    tau = 1.0e-12\n\n    # --- Test Case Specifications ---\n\n    test_cases_spec = [\n        # Case A: Happy path, sufficient data, at the true model\n        {\n            \"name\": \"Case A\",\n            \"receivers_slice\": slice(0, 2),\n            \"v_eval\": v_true,\n            \"s_eval\": s_true,\n        },\n        # Case B: Nonlinear regime for velocity, far from the true model\n        {\n            \"name\": \"Case B\",\n            \"receivers_slice\": slice(0, 2),\n            \"v_eval\": np.array([100000.0, 100000.0]),\n            \"s_eval\": np.array([1.0e-5, 1.0e-5]),\n        },\n        # Case C: Boundary case with insufficient data, rank-deficient geometry\n        {\n            \"name\": \"Case C\",\n            \"receivers_slice\": slice(0, 1),\n            \"v_eval\": v_true,\n            \"s_eval\": s_true,\n        },\n    ]\n\n    all_results = []\n\n    for case_spec in test_cases_spec:\n        # Extract parameters for the current case\n        L = L_full[case_spec[\"receivers_slice\"], :]\n        if L.ndim == 1: L = L.reshape(1, -1) # Ensure L is 2D\n        d_obs = d_obs_full[case_spec[\"receivers_slice\"]]\n        v_eval = case_spec[\"v_eval\"]\n        \n        # --- Hessian for Slowness Parameterization (s) ---\n        # H_s = L' * L, where L is the geometry matrix.\n        H_s = L.T @ L\n        \n        # --- Hessian for Velocity Parameterization (v) ---\n        # H_v = G'G + sum(r_j * H_j), where G is the Jacobian and H_j is the Hessian of t_j.\n        v1, v2 = v_eval[0], v_eval[1]\n        \n        # Calculate residuals r_j(v) = t_j(v) - d_j\n        t_pred = L @ (1.0 / v_eval)\n        residuals = t_pred - d_obs\n        \n        # Summation terms from the derivation\n        sum_L1_sq = np.sum(L[:, 0]**2)\n        sum_L2_sq = np.sum(L[:, 1]**2)\n        sum_L1L2 = np.sum(L[:, 0] * L[:, 1])\n        sum_rL1 = np.sum(residuals * L[:, 0])\n        sum_rL2 = np.sum(residuals * L[:, 1])\n        \n        # Build the Hessian H_v\n        h11_v = v1**(-4.0) * sum_L1_sq + 2.0 * v1**(-3.0) * sum_rL1\n        h22_v = v2**(-4.0) * sum_L2_sq + 2.0 * v2**(-3.0) * sum_rL2\n        h12_v = v1**(-2.0) * v2**(-2.0) * sum_L1L2\n        \n        H_v = np.array([[h11_v, h12_v], [h12_v, h22_v]])\n        \n        # --- Eigenvalue Analysis ---\n        # Use eigvalsh for symmetric matrices\n        evals_s = np.linalg.eigvalsh(H_s)\n        min_eval_s = np.min(evals_s)\n        \n        evals_v = np.linalg.eigvalsh(H_v)\n        min_eval_v = np.min(evals_v)\n        \n        # Definiteness checks using the specified tolerance tau\n        is_psd_s = bool(min_eval_s >= -tau)\n        is_pd_s = bool(min_eval_s > tau)\n        \n        is_psd_v = bool(min_eval_v >= -tau)\n        is_pd_v = bool(min_eval_v > tau)\n        \n        # Collect results for the current case\n        case_results = [\n            min_eval_s, \n            min_eval_v,\n            is_psd_s, \n            is_psd_v, \n            is_pd_s, \n            is_pd_v\n        ]\n        all_results.append(case_results)\n\n    # --- Final Output Formatting ---\n    # The output must be a single line containing a list of lists.\n    output_str = \"[\"\n    for i, case_res in enumerate(all_results):\n        res_str = f\"[{case_res[0]},{case_res[1]},{str(case_res[2])},{str(case_res[3])},{str(case_res[4])},{str(case_res[5])}]\"\n        output_str += res_str\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3618869"}]}