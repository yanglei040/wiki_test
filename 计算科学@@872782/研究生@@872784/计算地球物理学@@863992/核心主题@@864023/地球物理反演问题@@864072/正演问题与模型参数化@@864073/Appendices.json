{"hands_on_practices": [{"introduction": "在投入复杂的数值模拟之前，一个基本的健全性检查是确保我们的数学模型在物理上是一致的。量纲分析是实现这一目标的有力工具。本练习 [@problem_id:3616698] 聚焦于作为频率域波动建模基石的亥姆霍兹方程。通过验证方程中每一项的量纲，您将确认所选模型参数化（$m=c^{-2}$）的有效性，并确保该方程能够正确预测压力场，从而加深对建模中物理与数学之间关键联系的理解。", "problem": "考虑一个无损、无粘性流体中的频域声学正演问题，该流体具有恒定的质量密度 $\\,\\rho\\,$，其中所有场的时间依赖性都呈简谐形式 $\\exp(-\\mathrm{i}\\,\\omega t)$。可测量的数据是在接收点位置 $\\,\\mathbf{x}_r\\,$ 记录的压力振幅 $\\,p(\\mathbf{x};\\omega)\\,$。正演模型是标量亥姆霍兹方程\n$$\n\\nabla^{2} p(\\mathbf{x};\\omega) + \\omega^{2}\\,m(\\mathbf{x})\\,p(\\mathbf{x};\\omega) \\;=\\; f(\\mathbf{x};\\omega),\n$$\n模型参数化为 $\\,m(\\mathbf{x}) = c(\\mathbf{x})^{-2}\\,$，其中 $\\,c(\\mathbf{x})\\,$ 是与位置相关的声波速度。假设基本物理量纲为长度 $\\,L\\,$、时间 $\\,T\\,$ 和质量 $\\,M\\,$，并取压力量纲为 $[p] = M\\,L^{-1}\\,T^{-2}$，角频率量纲为 $[\\omega] = T^{-1}$，波速量纲为 $[c] = L\\,T^{-1}$。\n\n定义以下两个无量纲一致性指数：\n$$\n\\chi \\;:=\\; \\frac{[\\omega^{2}\\,m\\,p]}{[\\nabla^{2} p]}, \n\\qquad\n\\eta \\;:=\\; \\frac{[f]}{[\\nabla^{2} p]}.\n$$\n仅使用基于基本线性声学框架（线性化动量平衡、质量守恒和状态方程）的量纲分析，计算 $\\,\\chi\\,$。并且，在正演算子必须一致地预测压力值数据 $\\,p(\\mathbf{x}_r;\\omega)\\,$ 的要求下，计算 $\\,\\eta\\,$。请使用 LaTeX 的 $\\,\\texttt{pmatrix}\\,$ 格式将最终答案表示为一个行矩阵。无需四舍五入，最终数值表达式中不应包含任何单位。", "solution": "合适的出发点是在均匀、无粘性流体中小扰动的线性化声学方程组：线性化动量平衡、线性化质量守恒和线性状态方程。设 $\\,\\mathbf{u}(\\mathbf{x},t)\\,$ 表示质点速度，$\\,p(\\mathbf{x},t)\\,$ 表示压力，$\\,\\rho\\,$ 表示恒定的背景密度。线性化动量平衡（连续介质形式的牛顿第二定律）为\n$$\n\\rho\\,\\frac{\\partial \\mathbf{u}}{\\partial t} \\;=\\; -\\,\\nabla p,\n$$\n线性化质量守恒（连续性方程）为\n$$\n\\frac{\\partial \\rho'}{\\partial t} + \\rho\\,\\nabla\\cdot \\mathbf{u} \\;=\\; s_\\rho,\n$$\n其中 $\\,\\rho'(\\mathbf{x},t)\\,$ 是密度扰动，$\\,s_\\rho\\,$ 是代表质量注入率密度的源项（对于量纲分析，只需认识到源项带有平衡方程所需的量纲即可）。小扰动的线性状态方程是\n$$\np' \\;=\\; c^{2}\\,\\rho',\n$$\n其中 $\\,p'(\\mathbf{x},t)\\,$ 是压力扰动，$\\,c(\\mathbf{x})\\,$ 是波速，在均匀流体中满足 $\\,c^{2} = K/\\rho\\,$，其中 $\\,K\\,$ 是体积模量。消去 $\\,\\mathbf{u}\\,$ 和 $\\,\\rho'\\,$ 可得到我们熟悉的压力声波方程，\n$$\n\\nabla^{2} p(\\mathbf{x},t) \\;-\\; \\frac{1}{c^{2}}\\,\\frac{\\partial^{2} p(\\mathbf{x},t)}{\\partial t^{2}} \\;=\\; s(\\mathbf{x},t),\n$$\n其中源项 $\\,s(\\mathbf{x},t)\\,$ 的量纲由方程两边必须一致的要求确定。\n\n在简谐时间依赖性 $\\,p(\\mathbf{x},t) = \\Re\\{p(\\mathbf{x};\\omega)\\exp(-\\mathrm{i}\\omega t)\\}\\,$ 下，二阶时间导数贡献一个因子 $\\,(-\\omega^{2})\\,$，从而得到频域亥姆霍兹方程\n$$\n\\nabla^{2} p(\\mathbf{x};\\omega) + \\omega^{2}\\,c^{-2}(\\mathbf{x})\\,p(\\mathbf{x};\\omega) \\;=\\; f(\\mathbf{x};\\omega),\n$$\n我们用模型参数 $\\,m(\\mathbf{x}) = c^{-2}(\\mathbf{x})\\,$ 将其写为\n$$\n\\nabla^{2} p(\\mathbf{x};\\omega) + \\omega^{2}\\,m(\\mathbf{x})\\,p(\\mathbf{x};\\omega) \\;=\\; f(\\mathbf{x};\\omega).\n$$\n我们现在进行量纲分析，以验证 $\\,m=c^{-2}\\,$ 是一致的，并且压力值数据得到一致的预测。\n\n首先，我们列出基本量纲：\n- 压力量纲为 $[p] = M\\,L^{-1}\\,T^{-2}$。\n- 角频率量纲为 $[\\omega] = T^{-1}$。\n- 波速量纲为 $[c] = L\\,T^{-1}$，因此 $[c^{-2}] = T^{2}\\,L^{-2}$。\n- 拉普拉斯算子贡献 $[\\nabla^{2}] = L^{-2}$，所以 $[\\nabla^{2} p] = [p]\\,L^{-2} = M\\,L^{-3}\\,T^{-2}$。\n\n接下来，计算当 $\\,m=c^{-2}\\,$ 时，质量项 $\\,\\omega^{2} m p\\,$ 的量纲：\n$$\n[\\omega^{2} m p] \\;=\\; [\\omega]^{2}\\,[m]\\,[p] \\;=\\; T^{-2} \\cdot T^{2} L^{-2} \\cdot M\\,L^{-1}\\,T^{-2}\n\\;=\\; M\\,L^{-3}\\,T^{-2}.\n$$\n因此，\n$$\n\\chi \\;=\\; \\frac{[\\omega^{2} m p]}{[\\nabla^{2} p]} \n\\;=\\; \\frac{M\\,L^{-3}\\,T^{-2}}{M\\,L^{-3}\\,T^{-2}} \\;=\\; 1,\n$$\n这验证了在亥姆霍兹正演问题中 $\\,m=c^{-2}\\,$ 的一致性。\n\n最后，源项 $\\,f(\\mathbf{x};\\omega)\\,$ 必须与左侧具有相同的量纲，以确保方程平衡，并确保在接收点预测的场 $\\,p(\\mathbf{x};\\omega)\\,$ 在压力单位下具有物理意义。因此\n$$\n[f] \\;=\\; [\\nabla^{2} p] \\;=\\; M\\,L^{-3}\\,T^{-2},\n$$\n从而\n$$\n\\eta \\;=\\; \\frac{[f]}{[\\nabla^{2} p]} \\;=\\; 1.\n$$\n这表明模型参数化 $\\,m=c^{-2}\\,$ 与亥姆霍兹算子在量纲上是一致的，并且只要源项与 $\\,\\nabla^{2} p\\,$ 具有相同的量纲，就能一致地预测压力值数据，这是正演问题中的标准要求。", "answer": "$$\\boxed{\\begin{pmatrix} 1  1 \\end{pmatrix}}$$", "id": "3616698"}, {"introduction": "模型参数化的选择并非随心所欲，它能显著影响正演问题的性态以及后续反演问题的求解难度。在参数与数据之间建立更“线性”的映射关系，通常是反演任务所期望的。本练习 [@problem_id:3616719] 通过比较声学介质的两种常见参数化——体积模量 $K$ 与其倒数（压缩率 $\\kappa$），来深入探讨这一概念。通过解析计算一个衡量非线性的指标，您将从量化角度洞悉为何一种参数化可能优于另一种，并理解深思熟虑的参数选择如何从根本上改变反演问题的求解框架。", "problem": "考虑一维声波在均匀、各向同性的介质中传播，该介质具有恒定的质量密度 $\\rho_0$ 和体积模量 $K_0$。在角频率为 $\\omega$ 的频域中，标量压力场 $p(x;\\theta)$ 满足亥姆霍兹型方程 $p''(x) + k^2(\\theta)\\,p(x) = 0$，其中 $k(\\theta)$ 是用模型参数 $\\theta$ 表示的波数。对于可压缩性参数化，$\\theta=\\kappa$，其中 $\\kappa=1/K$，波数为 $k(\\kappa)=\\omega\\sqrt{\\rho_0\\,\\kappa}$；对于体积模量参数化，$\\theta=K$，波数为 $k(K)=\\omega\\sqrt{\\rho_0/K}$。一个单位振幅的右行平面波在 $x=0$ 处入射，正演数据为在 $x=L0$ 处的复压力，即 $d(\\theta)=p(L;\\theta)=\\exp\\!\\big(i\\,k(\\theta)\\,L\\big)$。\n\n定义在背景值 $\\theta_0$ 处，对于参数化 $\\theta$，在振幅为 $\\varepsilon$ 的相同分数扰动下的“二阶 Born 度量”为\n$$\nM_{\\theta} \\equiv \\left|\\frac{\\frac{1}{2}\\,d''(\\theta_0)\\,\\big(\\delta\\theta\\big)^2}{d'(\\theta_0)\\,\\delta\\theta}\\right|, \\quad \\delta\\theta=\\varepsilon\\,\\theta_0,\\quad 0  \\varepsilon \\ll 1,\n$$\n其中 $d'(\\theta_0)$ 和 $d''(\\theta_0)$ 分别是 $d(\\theta)$ 关于 $\\theta$ 在 $\\theta=\\theta_0$ 处的一阶和二阶导数。该度量用于量化在相同分数扰动下，对于给定参数化，二阶 Born 项相对于一阶 Born 项的相对大小。\n\n使用 $K_0$ 和 $\\kappa_0=1/K_0$ 作为两种参数化的背景值，推导比率\n$$\n\\mathcal{R} \\equiv \\frac{M_{K}}{M_{\\kappa}}\n$$\n的闭式表达式，用 $L$、$\\omega$、$\\rho_0$ 和 $K_0$ 表示。将最终答案表示为单个解析表达式。不需要进行数值计算或四舍五入，最终表达式中不应出现物理单位。", "solution": "我们的目标是计算比率 $\\mathcal{R} = M_K / M_\\kappa$。首先，我们简化二阶Born度量 $M_\\theta$ 的表达式。\n$$\nM_{\\theta} \\equiv \\left|\\frac{\\frac{1}{2}\\,d''(\\theta_0)\\,\\big(\\delta\\theta\\big)^2}{d'(\\theta_0)\\,\\delta\\theta}\\right| = \\left|\\frac{1}{2}\\frac{d''(\\theta_0)}{d'(\\theta_0)}\\delta\\theta\\right|\n$$\n代入 $\\delta\\theta=\\varepsilon\\,\\theta_0$，我们得到：\n$$\nM_{\\theta} = \\frac{\\varepsilon\\,\\theta_0}{2} \\left| \\frac{d''(\\theta_0)}{d'(\\theta_0)} \\right|\n$$\n计算的核心在于数据函数 $d(\\theta) = \\exp(i\\,k(\\theta)\\,L)$ 的二阶导数与一阶导数之比。我们首先一般性地计算这些导数。\n使用链式法则：\n$$\nd'(\\theta) = \\frac{d}{d\\theta}\\exp(i\\,k(\\theta)\\,L) = i\\,L\\,k'(\\theta)\\,\\exp(i\\,k(\\theta)\\,L)\n$$\n使用乘法法则进行二次微分：\n\\begin{align*}\nd''(\\theta) = \\frac{d}{d\\theta} \\left[ i\\,L\\,k'(\\theta)\\,\\exp(i\\,k(\\theta)\\,L) \\right] \\\\\n= i\\,L\\,k''(\\theta)\\,\\exp(i\\,k(\\theta)\\,L) + i\\,L\\,k'(\\theta) \\left[ i\\,L\\,k'(\\theta)\\,\\exp(i\\,k(\\theta)\\,L) \\right] \\\\\n= \\left[ i\\,L\\,k''(\\theta) - L^2(k'(\\theta))^2 \\right] \\exp(i\\,k(\\theta)\\,L)\n\\end{align*}\n导数之比为：\n$$\n\\frac{d''(\\theta)}{d'(\\theta)} = \\frac{\\left[ i\\,L\\,k''(\\theta) - L^2(k'(\\theta))^2 \\right] \\exp(i\\,k(\\theta)\\,L)}{i\\,L\\,k'(\\theta)\\,\\exp(i\\,k(\\theta)\\,L)} = \\frac{k''(\\theta)}{k'(\\theta)} + i\\,L\\,k'(\\theta)\n$$\n这个通用表达式将在背景值处对每种参数化进行求值。设 $k_0 = \\omega\\sqrt{\\rho_0/K_0} = \\omega\\sqrt{\\rho_0\\kappa_0}$ 为背景波数。\n\n**体积模量参数化 ($\\theta = K$)**\n这里，$\\theta_0=K_0$。波数为 $k(K) = \\omega\\sqrt{\\rho_0} K^{-1/2}$。\n关于 $K$ 的导数为：\n$$\nk'(K) = \\omega\\sqrt{\\rho_0} \\left(-\\frac{1}{2}\\right) K^{-3/2} = -\\frac{k(K)}{2K}\n$$\n$$\nk''(K) = \\omega\\sqrt{\\rho_0} \\left(-\\frac{1}{2}\\right) \\left(-\\frac{3}{2}\\right) K^{-5/2} = \\frac{3}{4} \\omega\\sqrt{\\rho_0} K^{-5/2}\n$$\n在背景值 $K_0$ 处：\n$$\n\\frac{k''(K_0)}{k'(K_0)} = \\frac{\\frac{3}{4}\\omega\\sqrt{\\rho_0}K_0^{-5/2}}{-\\frac{1}{2}\\omega\\sqrt{\\rho_0}K_0^{-3/2}} = -\\frac{3}{2K_0}\n$$\n代入数据导数之比的表达式：\n$$\n\\left.\\frac{d''(K)}{d'(K)}\\right|_{K_0} = \\frac{k''(K_0)}{k'(K_0)} + i\\,L\\,k'(K_0) = -\\frac{3}{2K_0} + i\\,L\\left(-\\frac{k_0}{2K_0}\\right) = -\\frac{1}{2K_0}(3 + i\\,L\\,k_0)\n$$\n现在我们计算度量 $M_K$：\n$$\nM_K = \\frac{\\varepsilon\\,K_0}{2} \\left| -\\frac{1}{2K_0}(3 + i\\,L\\,k_0) \\right| = \\frac{\\varepsilon}{4} |3 + i\\,L\\,k_0| = \\frac{\\varepsilon}{4}\\sqrt{9 + (L\\,k_0)^2}\n$$\n\n**可压缩性参数化 ($\\theta = \\kappa$)**\n这里，$\\theta_0 = \\kappa_0 = 1/K_0$。波数为 $k(\\kappa) = \\omega\\sqrt{\\rho_0} \\kappa^{1/2}$。\n关于 $\\kappa$ 的导数为：\n$$\nk'(\\kappa) = \\omega\\sqrt{\\rho_0}\\left(\\frac{1}{2}\\right)\\kappa^{-1/2} = \\frac{k(\\kappa)}{2\\kappa}\n$$\n$$\nk''(\\kappa) = \\omega\\sqrt{\\rho_0}\\left(\\frac{1}{2}\\right)\\left(-\\frac{1}{2}\\right)\\kappa^{-3/2} = -\\frac{1}{4}\\omega\\sqrt{\\rho_0}\\kappa^{-3/2}\n$$\n在背景值 $\\kappa_0$ 处：\n$$\n\\frac{k''(\\kappa_0)}{k'(\\kappa_0)} = \\frac{-\\frac{1}{4}\\omega\\sqrt{\\rho_0}\\kappa_0^{-3/2}}{\\frac{1}{2}\\omega\\sqrt{\\rho_0}\\kappa_0^{-1/2}} = -\\frac{1}{2\\kappa_0}\n$$\n代入数据导数之比的表达式：\n$$\n\\left.\\frac{d''(\\kappa)}{d'(\\kappa)}\\right|_{\\kappa_0} = \\frac{k''(\\kappa_0)}{k'(\\kappa_0)} + i\\,L\\,k'(\\kappa_0) = -\\frac{1}{2\\kappa_0} + i\\,L\\left(\\frac{k_0}{2\\kappa_0}\\right) = \\frac{1}{2\\kappa_0}(-1 + i\\,L\\,k_0)\n$$\n现在我们计算度量 $M_\\kappa$：\n$$\nM_\\kappa = \\frac{\\varepsilon\\,\\kappa_0}{2}\\left|\\frac{1}{2\\kappa_0}(-1 + i\\,L\\,k_0)\\right| = \\frac{\\varepsilon}{4}|-1 + i\\,L\\,k_0| = \\frac{\\varepsilon}{4}\\sqrt{1+(L\\,k_0)^2}\n$$\n\n**最终比率计算**\n最后，我们计算比率 $\\mathcal{R} = M_K/M_\\kappa$：\n$$\n\\mathcal{R} = \\frac{M_K}{M_\\kappa} = \\frac{\\frac{\\varepsilon}{4}\\sqrt{9 + (L\\,k_0)^2}}{\\frac{\\varepsilon}{4}\\sqrt{1 + (L\\,k_0)^2}} = \\sqrt{\\frac{9 + (L\\,k_0)^2}{1 + (L\\,k_0)^2}}\n$$\n问题要求答案用 $L$、$\\omega$、$\\rho_0$ 和 $K_0$ 表示。我们代入背景波数的平方表达式 $(k_0)^2 = \\omega^2 \\rho_0/K_0$。\n$$\n\\mathcal{R} = \\sqrt{\\frac{9 + L^2 \\omega^2 \\frac{\\rho_0}{K_0}}{1 + L^2 \\omega^2 \\frac{\\rho_0}{K_0}}}\n$$\n这就是比率的最终闭式表达式。", "answer": "$$\\boxed{\\sqrt{\\frac{9 + L^2 \\omega^2 \\frac{\\rho_0}{K_0}}{1 + L^2 \\omega^2 \\frac{\\rho_0}{K_0}}}}$$", "id": "3616719"}, {"introduction": "对于大规模反演问题，高效地计算目标函数相对于数百万模型参数的梯度至关重要，而伴随状态法（Adjoint-State Method）正是实现这一目标的核心技术。该方法通过求解一个辅助的“伴随”问题，巧妙地避免了显式构建和存储庞大的雅可比矩阵。这项动手实践 [@problem_id:3616704] 将引导您从第一性原理出发，为二维椭圆型偏微分方程推导并实现伴随状态法。通过将计算结果与伴随算子的定义进行检验，您将掌握现代全波形反演及地球物理学中众多梯度优化算法的底层计算流程。", "problem": "考虑单位正方形域 $\\Omega=[0,1]^2$ 上的标量椭圆偏微分方程 (PDE) $\\,\\nabla\\cdot(\\sigma\\nabla\\phi)=q\\,$，其在边界 $\\partial\\Omega$ 上满足齐次狄利克雷边界条件 $\\,\\phi=0\\,$。未知场为位势 $\\,\\phi(x,y)\\,$，模型参数为电导率 $\\,\\sigma(x,y)0\\,$，$\\,q(x,y)\\,$ 是一个给定的源分布。测量值由一个作用于 $\\,\\phi\\,$ 的线性算子 $\\,P\\,$ 给出，产生 $\\,d=P\\phi\\,$。令 $\\,r\\,$ 表示数据残差向量。正问题和模型参数化用以下术语描述：\n\n- 正算子将 $\\,\\sigma\\,$ 映射到数据 $\\,d=P\\phi\\,$，其中 $\\,\\phi\\,$ 是方程 $\\,\\nabla\\cdot(\\sigma\\nabla\\phi)=q\\,$ 在边界 $\\partial\\Omega$ 上满足 $\\,\\phi=0\\,$ 的解。\n- 雅可比矩阵 $\\,J\\,$ 是数据映射关于参数 $\\,\\sigma\\,$ 的 Fréchet 导数，而 $\\,J^T r\\,$ 表示对数据残差 $\\,r\\,$ 的伴随作用。\n- 你必须使用伴随状态法计算 $\\,J^T r\\,$，且不得使用任何快捷公式。从 PDE 的弱形式以及变分法和线性算子的第一性原理出发，推导出一个算法，用于将作用 $\\,\\delta\\sigma\\mapsto r^T P\\,\\delta\\phi\\,$ 计算为 $\\,J^T r\\,$ 与微扰 $\\,\\delta\\sigma\\,$ 之间的 $\\,L^2(\\Omega)\\,$ 内积。\n\n你将使用一个 $\\,N\\times N\\,$ 点的均匀笛卡尔网格对 $\\,\\Omega\\,$ 进行离散化，两个方向上的间距均为 $\\,h=\\frac{1}{N-1}\\,$，在边界点上强制施加 $\\,\\phi=0\\,$，并使用 $\\,\\sigma\\,$ 的面心算术平均来组装一个对称正定线性系统，该系统表示与 $\\,\\nabla\\cdot(\\sigma\\nabla\\phi)\\,$ 相关的离散算子。你将实现以下计算任务：\n\n1. 求解正问题以获得 $\\,\\phi\\,$。\n2. 根据数据残差 $\\,r\\,$，以与测量算子 $\\,P\\,$ 一致的方式构造伴随源，并求解伴随问题以获得伴随场 $\\,\\lambda\\,$。\n3. 从第一性原理出发，计算场 $\\,J^T r\\,$ 在网格上的离散近似。\n4. 对于给定的微扰 $\\,\\delta\\sigma\\,$，通过比较标量 $\\,r^T P\\,\\delta\\phi\\,$ 和域积分 $\\,\\int_\\Omega (J^T r)\\,\\delta\\sigma\\,\\mathrm{d}x\\,\\mathrm{d}y\\,$，在数值上验证线性化响应恒等式是否成立。其中 $\\,\\delta\\phi\\,$ 是由 $\\,\\delta\\sigma\\,$ 引起的线性化正向方程的解。将绝对失配报告为一个浮点数。\n\n你必须解释对于一般的线性测量算子 $\\,P\\,$ 以及当 $\\,P\\,$ 在网格点上对 $\\,\\phi\\,$ 进行采样这一特殊情况时，如何根据数据残差 $\\,r\\,$ 构造伴随源。\n\n你的程序必须实现以上要求，并生成单行输出，其中包含下述测试套件的绝对失配值，格式为方括号内以逗号分隔的列表。每个失配值都必须是浮点数。\n\n使用以下测试套件。所有量纲均为无量纲。\n\n- 测试用例1（基线，常数电导率，残差与正演数据关联）：\n  - 网格大小：$\\,N=32$。\n  - 电导率：各处均为 $\\,\\sigma(x,y)=1$。\n  - 源：位于中心网格点的单位点源，即设置 $\\,q_{i_0,j_0}=1\\,$，其中 $\\,i_0=j_0=\\lfloor N/2\\rfloor\\,$，其他地方为零。\n  - 测量：$\\,P\\,$ 在索引为 $\\,[(\\lfloor N/4\\rfloor,\\lfloor N/4\\rfloor),(\\lfloor N/2\\rfloor,\\lfloor N/3\\rfloor),(\\lfloor 3N/4\\rfloor,\\lfloor 3N/4\\rfloor)]\\,$ 的三个内部点上对 $\\,\\phi\\,$ 进行采样。\n  - 残差：设置 $\\,d_{\\text{obs}}=0\\,$，则 $\\,r=d_{\\text{obs}}-P\\phi\\,$。\n  - 微扰：$\\,\\delta\\sigma\\,$ 是一个小的零均值随机场，从 $\\,[-0.1,0.1]\\,$ 上的均匀分布中抽取，为保证可复现性，使用固定的随机种子。\n\n- 测试用例2（非均匀电导率，指定残差）：\n  - 网格大小：$\\,N=40$。\n  - 电导率：在网格点上计算 $\\,\\sigma(x,y)=1+0.5\\sin(2\\pi x)\\sin(2\\pi y)$。\n  - 源：位于索引为 $\\,(\\lfloor N/3\\rfloor,\\lfloor N/2\\rfloor)\\,$ 的单位点源。\n  - 测量：$\\,P\\,$ 在索引为 $\\,[(\\lfloor N/5\\rfloor,\\lfloor N/5\\rfloor),(\\lfloor 2N/5\\rfloor,\\lfloor 3N/7\\rfloor),(\\lfloor N/2\\rfloor,\\lfloor 2N/3\\rfloor),(\\lfloor 3N/5\\rfloor,\\lfloor 2N/5\\rfloor),(\\lfloor 4N/5\\rfloor,\\lfloor 4N/5\\rfloor)]\\,$ 的五个内部点上对 $\\,\\phi\\,$ 进行采样。\n  - 残差：$\\,r=[1,-0.5,0.25,-0.25,0.1]^T$。\n  - 微扰：$\\,\\delta\\sigma\\,$ 是一个小的零均值随机场，从 $\\,[-0.05,0.05]\\,$ 上的均匀分布中抽取，为保证可复现性，使用固定的随机种子。\n\n- 测试用例3（边界情况，正演场为零）：\n  - 网格大小：$\\,N=24$。\n  - 电导率：各处均为 $\\,\\sigma(x,y)=1$。\n  - 源：各处均为 $\\,q=0\\,$。\n  - 测量：位于索引为 $\\, (0,\\lfloor N/2\\rfloor)\\,$ 的单个边界点。\n  - 残差：$\\,r=[1]^T$。\n  - 微扰：$\\,\\delta\\sigma\\,$ 是一个小的零均值随机场，从 $\\,[-0.02,0.02]\\,$ 上的均匀分布中抽取，为保证可复现性，使用固定的随机种子。\n\n你的程序应生成单行输出，其中包含三个测试用例的绝对失配值，格式为方括号内以逗号分隔的列表，例如 $\\,[m_1,m_2,m_3]\\,$，其中 $\\,m_k\\,$ 是第 $\\,k\\,$ 个测试用例的失配值。", "solution": "该问题要求推导并实现伴随状态法，以计算量 $J^T r$，该量表示数据敏感度雅可比矩阵的伴随算子对数据残差向量的作用。物理模型由单位正方形域 $\\Omega=[0,1]^2$ 上的标量椭圆偏微分方程 $\\nabla\\cdot(\\sigma\\nabla\\phi)=q$ 控制，边界 $\\partial\\Omega$ 上满足齐次狄利克雷边界条件 $\\phi=0$。我们必须从第一性原理推导该算法，并对其进行数值验证。\n\n该方法的核心是找到场 $G = J^T r$ 的一个显式表达式，该表达式满足伴随算子的定义关系：\n$$\n\\langle r, J \\delta\\sigma \\rangle_{\\text{data}} = \\langle J^T r, \\delta\\sigma \\rangle_{L^2(\\Omega)}\n$$\n其中 $\\delta\\sigma$ 是模型参数（电导率 $\\sigma$）的微扰，而 $J\\delta\\sigma$ 是预测数据的相应变化。预测数据 $d=P\\phi$ 是通过作用于位势场 $\\phi$ 的线性测量算子 $P$ 获得的。因此，数据的变化为 $J\\delta\\sigma = P\\delta\\phi$，其中 $\\delta\\phi$ 是位势的变化。需要验证的恒等式变为 $r^T(P\\delta\\phi) = \\int_\\Omega (J^T r)\\delta\\sigma \\, d\\Omega$。\n\n我们的推导分三步进行：\n1.  **线性化正向方程**：我们从 PDE 的弱形式 $\\int_\\Omega \\sigma \\nabla\\phi \\cdot \\nabla v \\, d\\Omega = -\\int_\\Omega q v \\, d\\Omega$ 出发，该式对所有合适的测试函数 $v$ 均成立。通过对该式关于微扰 $\\delta\\sigma$ 进行线性化，我们得到控制相应位势微扰 $\\delta\\phi$ 的方程：\n    $$\n    \\int_\\Omega \\sigma \\nabla\\delta\\phi \\cdot \\nabla v \\, d\\Omega = -\\int_\\Omega \\delta\\sigma \\nabla\\phi \\cdot \\nabla v \\, d\\Omega\n    $$\n2.  **伴随方程**：我们引入一个伴随场 $\\lambda$，将项 $r^T P\\delta\\phi$ 与线性化方程关联起来。项 $r^T P\\delta\\phi$ 可以写成函数空间中的内积形式，即 $\\langle P^T r, \\delta\\phi \\rangle = \\int_\\Omega (P^T r) \\delta\\phi \\, d\\Omega$。我们将伴随场 $\\lambda$ 定义为伴随 PDE $\\nabla \\cdot (\\sigma \\nabla \\lambda) = P^T r$ 的解，且在 $\\partial\\Omega$ 上 $\\lambda=0$。由于该微分算子是自伴的，此方程与正向 PDE 具有相同的形式。其弱形式为 $\\int_\\Omega \\sigma \\nabla\\lambda \\cdot \\nabla w \\, d\\Omega = -\\int_\\Omega (P^T r) w \\, d\\Omega$。选择测试函数 $w = \\delta\\phi$，我们得到：\n    $$\n    -\\int_\\Omega (P^T r) \\delta\\phi \\, d\\Omega = -r^T P\\delta\\phi = \\int_\\Omega \\sigma \\nabla\\lambda \\cdot \\nabla \\delta\\phi \\, d\\Omega\n    $$\n3.  **$J^T r$ 的确定**：在线性化正向方程中选择测试函数 $v = \\lambda$，我们得到 $\\int_\\Omega \\sigma \\nabla\\delta\\phi \\cdot \\nabla \\lambda \\, d\\Omega = -\\int_\\Omega \\delta\\sigma \\nabla\\phi \\cdot \\nabla \\lambda \\, d\\Omega$。其左侧与上面推导的伴随关系的右侧完全相同。令剩余的项相等，可得：\n    $$\n    -r^T P\\delta\\phi = -\\int_\\Omega (\\nabla\\phi \\cdot \\nabla \\lambda) \\delta\\sigma \\, d\\Omega\n    $$\n    这可以简化为 $r^T P\\delta\\phi = \\int_\\Omega (\\nabla\\phi \\cdot \\nabla \\lambda) \\delta\\sigma \\, d\\Omega$。将此式与伴随作用的定义进行比较，我们便可确定所求场的显式表达式：\n    $$\n    J^T r = \\nabla\\phi \\cdot \\nabla\\lambda\n    $$\n对于点式测量，伴随源 $P^T r$ 成为位于测量点的一系列狄拉克δ分布之和，其权重为相应的残差值。在离散设置中，这意味着将残差值放置在相应的网格节点上。\n\n以下程序实现了这种伴随状态法。它数值求解了 $\\phi$ 的正问题和 $\\lambda$ 的伴随问题，并将 $J^T r$ 计算为其梯度的点积。然后，它显式计算恒等式 $r^T P\\delta\\phi = \\int (J^T r) \\delta\\sigma \\,d\\Omega$ 的两边，并报告它们的绝对差值，以验证推导和实现的正确性。离散化采用网格内部节点上的五点有限差分格式，从而产生一个稀疏、对称、正定的线性系统，该系统可以被高效求解。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def solve_case(N, sigma_func, q_loc, meas_loc_indices, r_val, delta_sigma_dist, seed):\n        \"\"\"\n        Solves a single test case for the adjoint verification problem.\n        \"\"\"\n        h = 1.0 / (N - 1)\n        x = np.linspace(0, 1, N)\n        y = np.linspace(0, 1, N)\n        xx, yy = np.meshgrid(x, y)\n\n        sigma = sigma_func(xx, yy)\n        q_grid = np.zeros((N, N))\n        if q_loc:\n            q_grid[q_loc] = 1.0\n\n        meas_loc_indices = np.array(meas_loc_indices)\n        meas_rows, meas_cols = meas_loc_indices[:, 0], meas_loc_indices[:, 1]\n\n        np.random.seed(seed)\n        delta_sigma = np.random.uniform(delta_sigma_dist[0], delta_sigma_dist[1], size=(N, N))\n        delta_sigma -= np.mean(delta_sigma)\n\n        def build_operator(s_field):\n            \"\"\"Builds the discrete operator B for -div(sigma*grad).\"\"\"\n            n_int = N - 2\n            n_dof = n_int * n_int\n            A = lil_matrix((n_dof, n_dof))\n\n            for i_int in range(n_int):\n                for j_int in range(n_int):\n                    k = i_int * n_int + j_int\n                    i, j = i_int + 1, j_int + 1\n\n                    diag_val = 0.0\n\n                    # East neighbor\n                    s_e = 0.5 * (s_field[i, j] + s_field[i, j + 1])\n                    diag_val += s_e\n                    if j_int  n_int - 1:\n                        A[k, k + 1] = -s_e / h**2\n\n                    # West neighbor\n                    s_w = 0.5 * (s_field[i, j] + s_field[i, j - 1])\n                    diag_val += s_w\n                    if j_int > 0:\n                        A[k, k - 1] = -s_w / h**2\n\n                    # North neighbor\n                    s_n = 0.5 * (s_field[i, j] + s_field[i + 1, j])\n                    diag_val += s_n\n                    if i_int  n_int - 1:\n                        A[k, k + n_int] = -s_n / h**2\n\n                    # South neighbor\n                    s_s = 0.5 * (s_field[i, j] + s_field[i - 1, j])\n                    diag_val += s_s\n                    if i_int > 0:\n                        A[k, k - n_int] = -s_s / h**2\n                        \n                    A[k, k] = diag_val / h**2\n            return csr_matrix(A)\n\n        # 1. Solve forward problem for phi: B*phi = -q\n        B_op = build_operator(sigma)\n        q_interior = q_grid[1:-1, 1:-1].flatten()\n        phi_vec = spsolve(B_op, -q_interior)\n        phi = np.zeros((N, N))\n        phi[1:-1, 1:-1] = phi_vec.reshape((N - 2, N - 2))\n\n        # Define residual r\n        if r_val is None:\n            d_calc = phi[meas_rows, meas_cols]\n            d_obs = 0.0\n            r = d_obs - d_calc\n        else:\n            r = np.array(r_val)\n\n        # 2. Solve adjoint problem for lambda: B*lambda = -q_adj\n        q_adj_grid = np.zeros((N, N))\n        for idx, res_val in zip(meas_loc_indices, r):\n            if 1 = idx[0]  N - 1 and 1 = idx[1]  N - 1:\n                q_adj_grid[tuple(idx)] = res_val\n        \n        q_adj_interior = q_adj_grid[1:-1, 1:-1].flatten()\n        lambda_vec = spsolve(B_op, -q_adj_interior)\n        lam = np.zeros((N, N))\n        if q_adj_interior.any(): # Avoid reshaping empty array if all sources are on boundary\n            lam[1:-1, 1:-1] = lambda_vec.reshape((N - 2, N - 2))\n        \n        # 3. Compute J^T r field\n        grad_phi_y, grad_phi_x = np.gradient(phi, h, edge_order=2)\n        grad_lam_y, grad_lam_x = np.gradient(lam, h, edge_order=2)\n        JTr_field = grad_phi_x * grad_lam_x + grad_phi_y * grad_lam_y\n\n        # 4. Verify identity\n        # LHS: r^T P delta_phi\n        # Solve B*delta_phi = -[B(sigma+delta_sigma) - B(sigma)]*phi\n        B_perturbed = build_operator(sigma + delta_sigma)\n        phi_interior_vec = phi[1:-1, 1:-1].flatten()\n        \n        b_lin_vec = - (B_perturbed - B_op) @ phi_interior_vec\n        delta_phi_vec = spsolve(B_op, b_lin_vec)\n        delta_phi = np.zeros((N, N))\n        delta_phi[1:-1, 1:-1] = delta_phi_vec.reshape((N - 2, N - 2))\n        \n        P_delta_phi = delta_phi[meas_rows, meas_cols]\n        lhs = r @ P_delta_phi\n        \n        # RHS: integral of (J^T r) * delta_sigma\n        rhs = np.sum(JTr_field * delta_sigma) * h**2\n        \n        mismatch = np.abs(lhs - rhs)\n        return mismatch\n\n    # Test Case 1\n    N1 = 32\n    case1_params = {\n        'N': N1,\n        'sigma_func': lambda x, y: 1.0 + 0 * x,\n        'q_loc': (N1 // 2, N1 // 2),\n        'meas_loc_indices': [(N1 // 4, N1 // 4), (N1 // 2, N1 // 3), (3 * N1 // 4, 3 * N1 // 4)],\n        'r_val': None,\n        'delta_sigma_dist': (-0.1, 0.1),\n        'seed': 0\n    }\n\n    # Test Case 2\n    N2 = 40\n    case2_params = {\n        'N': N2,\n        'sigma_func': lambda x, y: 1.0 + 0.5 * np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y),\n        'q_loc': (N2 // 3, N2 // 2),\n        'meas_loc_indices': [(N2 // 5, N2 // 5), (2 * N2 // 5, 3 * N2 // 7), (N2 // 2, 2 * N2 // 3), (3 * N2 // 5, 2 * N2 // 5), (4 * N2 // 5, 4 * N2 // 5)],\n        'r_val': [1.0, -0.5, 0.25, -0.25, 0.1],\n        'delta_sigma_dist': (-0.05, 0.05),\n        'seed': 1\n    }\n\n    # Test Case 3\n    N3 = 24\n    case3_params = {\n        'N': N3,\n        'sigma_func': lambda x, y: 1.0 + 0 * x,\n        'q_loc': None,\n        'meas_loc_indices': [(0, N3 // 2)],\n        'r_val': [1.0],\n        'delta_sigma_dist': (-0.02, 0.02),\n        'seed': 2\n    }\n\n    test_cases = [case1_params, case2_params, case3_params]\n    results = []\n    for params in test_cases:\n        mismatch = solve_case(**params)\n        results.append(mismatch)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3616704"}]}