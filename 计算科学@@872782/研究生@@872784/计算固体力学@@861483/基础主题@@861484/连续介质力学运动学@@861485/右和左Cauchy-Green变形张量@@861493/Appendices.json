{"hands_on_practices": [{"introduction": "本练习旨在巩固您对核心定义的理解，是一项基础性实践。我们将考虑简单剪切的情形，这是一种用于探究材料行为的典型变形模式。通过具体计算左右柯西-格林张量（$C$ 和 $B$）、它们的主不变量以及雅可比行列式 $J$，您将直接体验这些基本量，并观察到它们的一些关键性质，例如等容（体积保持）运动以及 $C$ 和 $B$ 的同谱特性。[@problem_id:3596643]", "problem": "三维空间中连续体的均匀变形由线性映射 $x = F X$ 描述，其中 $F$ 是变形梯度。右柯西-格林(Cauchy-Green)变形张量 $C$ 和左柯西-格林(Cauchy-Green)变形张量 $B$ 分别定义为 $C = F^{\\mathsf{T}} F$ 和 $B = F F^{\\mathsf{T}}$。具有实特征值 $\\lambda_1$、$\\lambda_2$ 和 $\\lambda_3$ 的二阶张量 $T$ 的主不变量由其特征多项式的系数定义，即 $I_1(T) = \\lambda_1 + \\lambda_2 + \\lambda_3$，$I_2(T) = \\lambda_1 \\lambda_2 + \\lambda_2 \\lambda_3 + \\lambda_3 \\lambda_1$ 以及 $I_3(T) = \\lambda_1 \\lambda_2 \\lambda_3 = \\det(T)$。局部体积变化为 $J = \\det(F)$。\n\n考虑简单剪切变形，其变形梯度为\n$$\nF = \\begin{bmatrix}\n1  \\gamma  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{bmatrix},\n$$\n其中 $\\gamma$ 是一个实值剪切参数。仅使用上述基本定义及由其推导出的恒等式，计算以下量，将其显式地表示为 $\\gamma$ 的函数：右柯西-格林变形张量 $C$、左柯西-格林变形张量 $B$、 $C$ 的第一和第二主不变量（记为 $I_1$ 和 $I_2$）以及雅可比行列式 $J$。提供闭式表达式。无需进行数值计算，也无需四舍五入。", "solution": "该问题陈述是有效的，因为它在科学上基于连续介质力学的原理，问题适定、自洽且客观。我们继续以系统的方式计算所要求的量。\n\n简单剪切的变形梯度 $F$ 如下所示：\n$$\nF = \\begin{bmatrix}\n1  \\gamma  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{bmatrix}\n$$\n其中 $\\gamma$ 是剪切参数。\n\n首先，我们计算右柯西-格林变形张量 $C$。根据定义，$C = F^{\\mathsf{T}} F$。$F$ 的转置是：\n$$\nF^{\\mathsf{T}} = \\begin{bmatrix}\n1  0  0 \\\\\n\\gamma  1  0 \\\\\n0  0  1\n\\end{bmatrix}\n$$\n执行矩阵乘法得到：\n$$\nC = F^{\\mathsf{T}} F = \\begin{bmatrix}\n1  0  0 \\\\\n\\gamma  1  0 \\\\\n0  0  1\n\\end{bmatrix}\n\\begin{bmatrix}\n1  \\gamma  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{bmatrix} = \\begin{bmatrix}\n1(1) + 0(0) + 0(0)  & 1(\\gamma) + 0(1) + 0(0)  & 1(0) + 0(0) + 0(1) \\\\\n\\gamma(1) + 1(0) + 0(0)  & \\gamma(\\gamma) + 1(1) + 0(0)  & \\gamma(0) + 1(0) + 0(1) \\\\\n0(1) + 0(0) + 1(0)  & 0(\\gamma) + 0(1) + 1(0)  & 0(0) + 0(0) + 1(1)\n\\end{bmatrix}\n$$\n$$\nC = \\begin{bmatrix}\n1  & \\gamma  & 0 \\\\\n\\gamma  & 1+\\gamma^2  & 0 \\\\\n0  & 0  & 1\n\\end{bmatrix}\n$$\n\n其次，我们计算左柯西-格林变形张量 $B$。根据定义，$B = F F^{\\mathsf{T}}$。\n$$\nB = F F^{\\mathsf{T}} = \\begin{bmatrix}\n1  & \\gamma  & 0 \\\\\n0  & 1  & 0 \\\\\n0  & 0  & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1  & 0  & 0 \\\\\n\\gamma  & 1  & 0 \\\\\n0  & 0  & 1\n\\end{bmatrix} = \\begin{bmatrix}\n1(1) + \\gamma(\\gamma) + 0(0)  & 1(0) + \\gamma(1) + 0(0)  & 1(0) + \\gamma(0) + 0(1) \\\\\n0(1) + 1(\\gamma) + 0(0)  & 0(0) + 1(1) + 0(0)  & 0(0) + 1(0) + 0(1) \\\\\n0(1) + 0(\\gamma) + 1(0)  & 0(0) + 0(1) + 1(0)  & 0(0) + 0(0) + 1(1)\n\\end{bmatrix}\n$$\n$$\nB = \\begin{bmatrix}\n1+\\gamma^2  & \\gamma  & 0 \\\\\n\\gamma  & 1  & 0 \\\\\n0  & 0  & 1\n\\end{bmatrix}\n$$\n\n第三，我们计算 $C$ 的第一主不变量，记为 $I_1$。张量的第一不变量是其迹。\n$$\nI_1 = I_1(C) = \\text{tr}(C) = 1 + (1+\\gamma^2) + 1 = 3+\\gamma^2\n$$\n\n第四，我们计算 $C$ 的第二主不变量，记为 $I_2$。第二不变量可由公式 $I_2(T) = \\frac{1}{2} [(\\text{tr}(T))^2 - \\text{tr}(T^2)]$ 计算。我们已经求得 $\\text{tr}(C) = 3+\\gamma^2$。我们现在计算 $C^2$ 以求其迹。\n$$\nC^2 = \\begin{bmatrix}\n1  & \\gamma  & 0 \\\\\n\\gamma  & 1+\\gamma^2  & 0 \\\\\n0  & 0  & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1  & \\gamma  & 0 \\\\\n\\gamma  & 1+\\gamma^2  & 0 \\\\\n0  & 0  & 1\n\\end{bmatrix} = \\begin{bmatrix}\n1+\\gamma^2  & \\gamma + \\gamma(1+\\gamma^2)  & 0 \\\\\n\\gamma + \\gamma(1+\\gamma^2)   & \\gamma^2 + (1+\\gamma^2)^2  & 0 \\\\\n0  & 0  & 1\n\\end{bmatrix}\n$$\n$C^2$ 的迹是其对角元素之和：\n$$\n\\text{tr}(C^2) = (1+\\gamma^2) + (\\gamma^2 + (1+\\gamma^2)^2) + 1 = 1+\\gamma^2 + \\gamma^2 + (1+2\\gamma^2+\\gamma^4) + 1 = 3 + 4\\gamma^2 + \\gamma^4\n$$\n现在，我们可以计算 $I_2$：\n$$\nI_2 = I_2(C) = \\frac{1}{2} [(\\text{tr}(C))^2 - \\text{tr}(C^2)] = \\frac{1}{2} [(3+\\gamma^2)^2 - (3 + 4\\gamma^2 + \\gamma^4)]\n$$\n$$\nI_2 = \\frac{1}{2} [(9+6\\gamma^2+\\gamma^4) - 3 - 4\\gamma^2 - \\gamma^4] = \\frac{1}{2} [6+2\\gamma^2] = 3+\\gamma^2\n$$\n一个已知的性质是，$C$ 和 $B$ 是同谱的，这意味着它们具有相同的特征值，因此也具有相同的主不变量。确实，我们发现 $I_1(C) = I_1(B) = 3+\\gamma^2$ 和 $I_2(C) = I_2(B) = 3+\\gamma^2$。\n\n最后，我们计算雅可比行列式 $J$，即变形梯度 $F$ 的行列式。由于 $F$ 是一个上三角矩阵，其行列式是其对角元素的乘积。\n$$\nJ = \\det(F) = \\det\\begin{bmatrix}\n1  & \\gamma  & 0 \\\\\n0  & 1  & 0 \\\\\n0  & 0  & 1\n\\end{bmatrix} = 1 \\cdot 1 \\cdot 1 = 1\n$$\n这个结果，$J=1$，证实了简单剪切是等容（体积保持）变形。\n\n所要求的量现在已完全确定为 $\\gamma$ 的函数。", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 1 & \\gamma & 0 \\\\ \\gamma & 1+\\gamma^2 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}, \n\\begin{pmatrix} 1+\\gamma^2 & \\gamma & 0 \\\\ \\gamma & 1 & 0 \\\\ 0 & 0 & 1 \\end{pmatrix}, \n3+\\gamma^2, \n3+\\gamma^2, \n1\n}\n$$", "id": "3596643"}, {"introduction": "从手动计算转向计算实现，本练习将探讨连续介质力学中的一个基石算法：极分解。右柯西-格林张量 $C$ 是将变形梯度 $F$ 分解为纯旋转 $R$ 和纯拉伸 $U$ (即 $F=RU$) 的关键。本练习将指导您构建一个数值程序，使用谱方法来执行此分解，并且至关重要的是，根据几个重要标准来验证您实现的正确性和稳健性。[@problem_id:3596619]", "problem": "给定一系列三维案例的形变梯度矩阵。您的任务是实现一个数值程序，为每个案例构建右柯西-格林形变张量，通过谱分解获得右伸长张量，在右极分解中重构旋转，并验证其正交性。推导必须从连续介质运动学的基本定义出发。具体来说，使用以下基础：\n- 形变梯度表示为 $F \\in \\mathbb{R}^{3 \\times 3}$。\n- 右柯西-格林形变张量为 $C = F^{T} F$。\n- 左柯西-格林形变张量为 $B = F F^{T}$。\n- 右伸长张量 $U$ 是 $C$ 的唯一对称正定 (SPD) 平方根，即 $U = C^{1/2}$，且 $U \\succ 0$ 和 $U^{2} = C$。\n- 左伸长张量 $V$ 是 $B$ 的唯一对称正定 (SPD) 平方根，即 $V = B^{1/2}$，且 $V \\succ 0$ 和 $V^{2} = B$。\n- 右极分解为 $F = R U$，其中 $R$ 是正交的，$U$ 是对称正定的。\n- 左极分解为 $F = V R$，其中 $V$ 是对称正定的，$R$ 是正交的。\n\n对于每个给定的 $F$，您的程序必须在不使用任何外部数据的情况下执行以下操作：\n1. 构建 $C = F^{T} F$ 和 $B = F F^{T}$。\n2. 使用对称矩阵 $C$ 的谱分解计算 $U$ 作为 $C$ 的对称正定平方根：如果 $C = Q \\Lambda Q^{T}$，其中 $Q$ 是正交的，$\\Lambda = \\mathrm{diag}(\\lambda_{1},\\lambda_{2},\\lambda_{3})$ 且 $\\lambda_{i} \\ge 0$，则定义 $U = Q \\,\\mathrm{diag}(\\sqrt{\\lambda_{1}},\\sqrt{\\lambda_{2}},\\sqrt{\\lambda_{3}})\\, Q^{T}$。为保证数值稳健性，如果任何 $\\lambda_{i}$ 因浮点误差而略微为负，则将其视为 $0$。\n3. 使用通过相同特征基构建的 $U$ 的逆矩阵来构成 $R = F U^{-1}$：$U^{-1} = Q \\,\\mathrm{diag}(1/\\sqrt{\\lambda_{1}},1/\\sqrt{\\lambda_{2}},1/\\sqrt{\\lambda_{3}})\\, Q^{T}$，假设 $\\lambda_{i} > 0$（所提供的测试套件确保了可逆性）。\n4. 通过计算弗罗贝尼乌斯范数 $||R^{T} R - I||_{F}$ 并与容差 $\\tau_{\\mathrm{orth}} = 1 \\times 10^{-8}$ 进行比较来验证正交性。\n5. 通过对 $B$ 进行谱分解独立计算左伸长张量 $V = B^{1/2}$，构成 $R_{\\mathrm{alt}} = V^{-1} F$，并通过评估 $||R_{\\mathrm{alt}} - R||_{F} \\le \\tau_{\\mathrm{cons}}$（其中 $\\tau_{\\mathrm{cons}} = 1 \\times 10^{-8}$）来检查与先前旋转的一致性。\n6. 通过检查相对弗罗贝尼乌斯误差 $||F - R U||_{F} / ||F||_{F} \\le \\tau_{\\mathrm{rec}}$（其中 $\\tau_{\\mathrm{rec}} = 1 \\times 10^{-9}$）来验证重构。\n\n对于每个测试用例，当且仅当以下所有三个检查都通过时，输出一个布尔值 `true`，否则输出 `false`：\n- $||R^{T} R - I||_{F} \\le \\tau_{\\mathrm{orth}}$，\n- $||R_{\\mathrm{alt}} - R||_{F} \\le \\tau_{\\mathrm{cons}}$，\n- $||F - R U||_{F} / ||F||_{F} \\le \\tau_{\\mathrm{rec}}$。\n\n在下面构建矩阵时使用的角度单位已经数值化嵌入；您的程序不得计算角度。最终答案不涉及任何物理单位。\n\n测试套件（每个案例是一个 $3 \\times 3$ 矩阵 $F$）：\n- 案例 1（一般伸长和旋转）：\n  $$\n  F_{1} = \\begin{bmatrix}\n  1.4330047336884090  -0.2364161653290717  0.0 \\\\\n  0.4432803099920094  0.7642691913004848  0.0 \\\\\n  0.0  0.0  1.2\n  \\end{bmatrix}.\n  $$\n- 案例 2（绕 $x$ 轴旋转 $- \\pi/3$ 弧度的纯旋转）：\n  $$\n  F_{2} = \\begin{bmatrix}\n  1.0  0.0  0.0 \\\\\n  0.0  0.5  0.8660254037844386 \\\\\n  0.0  -0.8660254037844386  0.5\n  \\end{bmatrix}.\n  $$\n- 案例 3（具有负行列式的不纯正形变）：\n  $$\n  F_{3} = \\begin{bmatrix}\n  -1.1  0.0  0.0 \\\\\n  0.0  0.9  0.0 \\\\\n  0.0  0.0  1.3\n  \\end{bmatrix}.\n  $$\n- 案例 4（病态但可逆）：\n  $$\n  F_{4} = \\begin{bmatrix}\n  0.0008775825618903728  0.0  47.9425538604203 \\\\\n  0.0  1.0  0.0 \\\\\n  -0.000479425538604203  0.0  87.75825618903728\n  \\end{bmatrix}.\n  $$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[true1,true2,true3,true4]\"，但使用 Python 布尔格式 \"True\" 或 \"False\"）。具体来说，输出必须是 \"[$b_{1},b_{2},b_{3},b_{4}$]\" 的形式，其中 $b_{k} \\in \\{\\mathrm{True},\\mathrm{False}\\}$ 是案例 $k$ 的结果。", "solution": "该问题要求实现并验证给定 $3 \\times 3$ 形变梯度张量 $F$ 的极分解。极分解定理指出，任何可逆张量 $F$ 都可以唯一地分解为一个正交张量 $R$ 和一个对称正定 (SPD) 张量 $U$ 或 $V$ 的乘积。具体来说，我们有右极分解 $F=RU$ 和左极分解 $F=VR$。张量 $U$ 和 $V$ 分别称为右伸长张量和左伸长张量，$R$ 是旋转张量。数值程序将根据三个标准进行验证：$R$ 的正交性、左右分解之间的一致性以及重构的准确性。\n\n所提供的运动学定义构成了我们算法的基础。形变梯度为 $F \\in \\mathbb{R}^{3 \\times 3}$。右柯西-格林形变张量 $C$ 和左柯西-格林形变张量 $B$ 定义如下：\n$$\nC = F^{T} F\n$$\n$$\nB = F F^{T}\n$$\n根据构造，$C$ 和 $B$ 都是对称矩阵。它们也是半正定的，因为对于任何向量 $x \\in \\mathbb{R}^{3}$，我们有 $x^{T} C x = x^{T} F^{T} F x = (Fx)^{T}(Fx) = ||Fx||_{2}^{2} \\ge 0$。如果 $F$ 是可逆的（如测试用例中所指定），则 $C$ 和 $B$ 是正定的。\n\n右伸长张量 $U$ 和左伸长张量 $V$ 分别是 $C$ 和 $B$ 的唯一对称正定平方根：\n$$\nU = C^{1/2}, \\quad U^2 = C, \\quad U=U^T, \\quad U \\succ 0\n$$\n$$\nV = B^{1/2}, \\quad V^2 = B, \\quad V=V^T, \\quad V \\succ 0\n$$\n\n数值任务的核心是计算这些张量平方根。这是通过使用对称矩阵 $C$ 和 $B$ 的谱分解（或特征分解）来完成的。对于对称矩阵 $C$，存在一个正交矩阵 $Q$（其列是 $C$ 的标准正交特征向量）和一个对角矩阵 $\\Lambda$（其元素是相应的实特征值 $\\lambda_{i}$）。分解如下：\n$$\nC = Q \\Lambda Q^{T}\n$$\n其中 $\\Lambda = \\mathrm{diag}(\\lambda_{1}, \\lambda_{2}, \\lambda_{3})$。由于 $C$ 是正定的，其所有特征值都严格为正，$\\lambda_i > 0$。然后可以按如下方式计算平方根 $U$：\n$$\nU = C^{1/2} = Q \\Lambda^{1/2} Q^{T}\n$$\n其中 $\\Lambda^{1/2} = \\mathrm{diag}(\\sqrt{\\lambda_{1}}, \\sqrt{\\lambda_{2}}, \\sqrt{\\lambda_{3}})$。作为一种数值稳健性的措施，如果由于浮点不精确性发现任何特征值为小的负数，则在取平方根之前将其钳位到 $0$。\n\n一旦计算出 $U$，就可以通过对 $U$ 求逆来找到右极分解 $F = RU$ 中的旋转张量 $R$：\n$$\nR = F U^{-1}\n$$\n使用相同的特征分解可以高效地计算 $U$ 的逆：\n$$\nU^{-1} = (Q \\Lambda^{1/2} Q^{T})^{-1} = (Q^{T})^{-1} (\\Lambda^{1/2})^{-1} Q^{-1} = Q \\Lambda^{-1/2} Q^{T}\n$$\n其中 $\\Lambda^{-1/2} = \\mathrm{diag}(1/\\sqrt{\\lambda_{1}}, 1/\\sqrt{\\lambda_{2}}, 1/\\sqrt{\\lambda_{3}})$。这是有效的，因为所有 $\\lambda_i > 0$。\n\n对于每个给定的 $F$，算法按以下步骤进行：\n1.  计算 $C = F^{T} F$ 和 $B = F F^{T}$。\n2.  对 $C$ 进行谱分解以获得特征值 $\\lambda_i$ 和特征向量矩阵 $Q$。计算 $U = Q \\, \\mathrm{diag}(\\sqrt{\\lambda_i}) \\, Q^{T}$。\n3.  计算逆矩阵 $U^{-1} = Q \\, \\mathrm{diag}(1/\\sqrt{\\lambda_i}) \\, Q^{T}$，然后计算旋转矩阵 $R = F U^{-1}$。\n4.  执行第一次验证：检查正交性。正交矩阵 $R$ 满足 $R^{T} R = I$，其中 $I$ 是单位矩阵。通过计算残差的弗罗贝尼乌斯范数 $||R^{T} R - I||_{F}$ 并确保其低于容差 $\\tau_{\\mathrm{orth}} = 1 \\times 10^{-8}$ 来执行检查。\n5.  执行第二次验证：检查一致性。旋转矩阵也可以从左分解 $F=VR$ 计算得出，即 $R_{\\mathrm{alt}} = V^{-1}F$。左伸长张量 $V=B^{1/2}$ 及其逆 $V^{-1}$ 通过对 $B$ 进行谱分解来计算。理论保证 $R_{\\mathrm{alt}}$ 必须与 $R$ 相同。通过计算 $||R_{\\mathrm{alt}} - R||_{F}$ 并确保其低于容差 $\\tau_{\\mathrm{cons}} = 1 \\times 10^{-8}$ 来进行检查。\n6.  执行第三次验证：检查重构精度。计算出的分解 $F \\approx RU$ 必须高精度地重构原始矩阵 $F$。通过评估相对弗罗贝尼乌斯误差 $||F - R U||_{F} / ||F||_{F}$ 并确保其低于容差 $\\tau_{\\mathrm{rec}} = 1 \\times 10^{-9}$ 来进行检查。\n\n当且仅当所有三个数值检查都满足时，一个测试用例被认为是成功的（评估为真）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_spd_sqrt_and_inv(A):\n    \"\"\"\n    Computes the symmetric positive-definite square root of a matrix A and its inverse\n    using spectral decomposition.\n    A must be a symmetric positive semi-definite matrix.\n    \"\"\"\n    # Use eigh for symmetric matrices; it's more efficient and numerically stable.\n    eigvals, eigvecs = np.linalg.eigh(A)\n    \n    # Clamp small negative eigenvalues that may arise from floating-point errors.\n    eigvals[eigvals  0] = 0\n    \n    # Compute square root of eigenvalues\n    sqrt_eigvals = np.sqrt(eigvals)\n    \n    # Form the diagonal matrix of square root eigenvalues\n    Lambda_sqrt = np.diag(sqrt_eigvals)\n    \n    # Reconstruct the matrix square root\n    A_sqrt = eigvecs @ Lambda_sqrt @ eigvecs.T\n    \n    # Compute inverse square root of eigenvalues.\n    # Add a small epsilon to avoid division by zero if an eigenvalue is exactly 0,\n    # although the problem statement implies invertible F, so eigenvalues of C and B are > 0.\n    inv_sqrt_eigvals = np.zeros_like(eigvals)\n    # Check for non-zero eigenvalues before division\n    non_zero_mask = eigvals > 1e-12 # A practical tolerance for non-zero\n    inv_sqrt_eigvals[non_zero_mask] = 1.0 / sqrt_eigvals[non_zero_mask]\n\n    Lambda_inv_sqrt = np.diag(inv_sqrt_eigvals)\n    \n    # Reconstruct the inverse of the matrix square root\n    A_inv_sqrt = eigvecs @ Lambda_inv_sqrt @ eigvecs.T\n    \n    return A_sqrt, A_inv_sqrt\n\ndef solve():\n    \"\"\"\n    Performs polar decomposition for a series of deformation gradients F\n    and verifies the results against several criteria.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [1.4330047336884090, -0.2364161653290717, 0.0],\n            [0.4432803099920094, 0.7642691913004848, 0.0],\n            [0.0, 0.0, 1.2]\n        ]),\n        np.array([\n            [1.0, 0.0, 0.0],\n            [0.0, 0.5, 0.8660254037844386],\n            [0.0, -0.8660254037844386, 0.5]\n        ]),\n        np.array([\n            [-1.1, 0.0, 0.0],\n            [0.0, 0.9, 0.0],\n            [0.0, 0.0, 1.3]\n        ]),\n        np.array([\n            [0.0008775825618903728, 0.0, 47.9425538604203],\n            [0.0, 1.0, 0.0],\n            [-0.000479425538604203, 0.0, 87.75825618903728]\n        ])\n    ]\n\n    # Define tolerances\n    tau_orth = 1e-8\n    tau_cons = 1e-8\n    tau_rec = 1e-9\n\n    results = []\n    I = np.identity(3)\n\n    for F in test_cases:\n        # 1. Construct C and B\n        C = F.T @ F\n        B = F @ F.T\n\n        # 2. Compute U from C\n        U, U_inv = compute_spd_sqrt_and_inv(C)\n        \n        # 3. Form R\n        R = F @ U_inv\n\n        # 4. Verify orthogonality of R\n        orth_error = np.linalg.norm(R.T @ R - I, 'fro')\n        check_orth = orth_error = tau_orth\n\n        # 5. Compute R_alt from B and V, and check consistency\n        V, V_inv = compute_spd_sqrt_and_inv(B)\n        R_alt = V_inv @ F\n        cons_error = np.linalg.norm(R_alt - R, 'fro')\n        check_cons = cons_error = tau_cons\n\n        # 6. Verify reconstruction accuracy\n        F_norm = np.linalg.norm(F, 'fro')\n        # Avoid division by zero for a zero matrix F, although not in test cases\n        if F_norm > 1e-12:\n            rec_error_rel = np.linalg.norm(F - R @ U, 'fro') / F_norm\n        else:\n            rec_error_rel = np.linalg.norm(F - R @ U, 'fro')\n        \n        check_rec = rec_error_rel = tau_rec\n\n        # Final result for the case is true if all checks pass\n        results.append(check_orth and check_cons and check_rec)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3596619"}, {"introduction": "最后的这项练习深入探讨了在动态模拟中遇到的一个更高级的数值挑战。前面的练习提供的是静态分解，而现实世界的问题涉及连续的变形路径，其中物理量必须被平滑地追踪。本练习构建了一个具有重合特征值的场景，在这种情况下，对特征向量进行朴素的追踪可能导致不符合物理规律的跳跃或“切换”。您将实现并比较一种简单的排序方法和一种基于分配的复杂策略，从而体会到开发用于追踪主材料方向的稳健代码所需的精妙之处。[@problem_id:3596622]", "problem": "考虑一个三维光滑变形，其特征由变形梯度 $F(t) \\in \\mathbb{R}^{3 \\times 3}$ 描述，其中 $t \\in \\mathbb{R}$ 是一个标量路径参数。右 Cauchy-Green 变形张量为 $C(t) = F(t)^{\\mathsf{T}} F(t)$。右拉伸张量 $U(t)$ 定义为 $C(t)$ 唯一的对称正定平方根，因此 $U(t) = \\sqrt{C(t)}$，且 $F(t)$ 具有极分解 $F(t) = R(t) U(t)$，其中 $R(t) \\in \\mathrm{SO}(3)$ 是一个正常正交张量。您将构建一个变形路径 $t \\mapsto F(t)$，使得 $C(t)$ 在 $t = 0$ 时具有重复的特征值，并且 $C(t)$ 的主方向在 $1$-$2$ 平面内随 $t$ 平滑旋转。然后，您将研究特征向量切换效应，并提出一种数值稳定的特征分解策略，以沿路径追踪 $C(t)$ 的特征向量。最后，您将验证通过谱方法和奇异值分解计算的 $U(t)$ 的一致性。\n\n从以下基本基础开始：\n- 对于任何变形梯度 $F$，定义为 $C = F^{\\mathsf{T}} F$。\n- 对于任何对称正定张量 $C$，存在唯一的对称正定平方根，记为 $U = \\sqrt{C}$，它与极分解 $F = R U$ 中的右拉伸张量一致。\n- 对于任何对称矩阵 $C$，存在一个标准正交特征基，使得 $C = Q \\Lambda Q^{\\mathsf{T}}$，其中 $\\Lambda = \\mathrm{diag}(\\lambda_1,\\lambda_2,\\lambda_3)$ 且 $Q \\in \\mathrm{O}(3)$。当特征值重复时，特征向量在退化的不变子空间内不唯一。\n\n通过下式定义一族变形梯度\n$$\nF(t) = Q(\\alpha(t)) \\, \\mathrm{diag}(s_1(t), s_2(t), s_3) \\, Q(\\alpha(t))^{\\mathsf{T}},\n$$\n其中\n$$\ns_1(t) = a + \\varepsilon t,\\quad s_2(t) = a - \\varepsilon t,\\quad s_3 = b,\\quad \\alpha(t) = \\kappa t,\n$$\n且 $Q(\\alpha)$ 是在 $1$-$2$ 平面内旋转角度 $\\alpha$ 的平面旋转，即\n$$\nQ(\\alpha) = \\begin{bmatrix}\n\\cos \\alpha   -\\sin \\alpha   0\\\\\n\\sin \\alpha   \\phantom{-}\\cos \\alpha   0\\\\\n0   0   1\n\\end{bmatrix}.\n$$\n所有角度均以弧度处理。根据此构造，$F(t)$ 是对称正定的，并且由于 $s_1(0) = s_2(0) = a$，因此 $C(t) = F(t)^{\\mathsf{T}} F(t) = F(t)^2$ 在 $t=0$ 时有两个相等的特征值。对于 $t \\neq 0$，特征值 $s_1(t)^2$ 和 $s_2(t)^2$ 分离，且对应的特征向量通过 $Q(\\alpha(t))$ 在 1-2 平面内旋转。因此，如果通过对特征值排序进行简单追踪，主方向可能会遭受特征向量切换的影响。\n\n实现两种策略，以沿递增的离散 $t$ 值序列追踪 $C(t)$ 的特征向量：\n- 朴素策略：对于每个 $t$，计算 $C(t)$ 的特征分解，按特征值降序对特征对进行排序，并使用此排序顺序作为所有 $t$ 值的标识，不进行任何进一步的对齐。通过计算连续时间步上相应特征向量之间的夹角来量化步间变化。为消除角度计算中的符号模糊性，请使用内积的绝对值。报告测试套件中所有特征向量和所有连续 $t$ 值对的最大夹角，以度为单位。\n- 稳定分配策略：对于 $t_0$，计算并存储按特征值降序排列的特征向量。对于每个后续的 $t_k$，计算 $t_k$ 处的特征向量（初始仍按特征值降序排列），然后：\n  1. 计算绝对重叠矩阵 $S = \\left|\\!V_{\\mathrm{prev}}^{\\mathsf{T}} V_{\\mathrm{curr}}\\!\\right|$，其中 $V_{\\mathrm{prev}}, V_{\\mathrm{curr}} \\in \\mathbb{R}^{3 \\times 3}$ 的列是收集的特征向量。\n  2. 在成本矩阵 $1 - S$ 上使用线性分配算法解决一对一分配问题，以最大化总重叠度，从而确定能使 $V_{\\mathrm{curr}}$ 与 $V_{\\mathrm{prev}}$ 最佳对齐的排列。\n  3. 排列后，翻转每个当前特征向量的符号，使其与匹配的前一个特征向量的内积为非负。\n  4. 如同朴素策略一样，计算连续步骤之间匹配并符号对齐的特征向量之间的夹角。报告所有特征向量和所有连续 $t$ 值对的最大夹角，以度为单位。\n\n此外，对于每个 $t$，用两种方法计算 $U(t)$：\n- 谱平方根：使用特征分解 $C(t) = Q(t) \\Lambda(t) Q(t)^{\\mathsf{T}}$，其中 $\\Lambda(t) = \\mathrm{diag}(\\lambda_i(t))$，设置\n$$\nU_{\\mathrm{eig}}(t) = \\sum_{i=1}^{3} \\sqrt{\\lambda_i(t)} \\, q_i(t) q_i(t)^{\\mathsf{T}}.\n$$\n- 奇异值分解平方根：使用奇异值分解 $F(t) = W(t) \\Sigma(t) V(t)^{\\mathsf{T}}$，设置\n$$\nU_{\\mathrm{svd}}(t) = V(t) \\Sigma(t) V(t)^{\\mathsf{T}}.\n$$\n对于给定的 $F(t)$，在精确算术中，这两种构造 $U(t)$ 的方法是一致的。通过计算测试套件上的最大 Frobenius 范数来量化数值一致性\n$$\n\\max_t \\left\\|U_{\\mathrm{eig}}(t) - U_{\\mathrm{svd}}(t)\\right\\|_{\\mathrm{F}}.\n$$\n\n使用以下参数值和测试套件：\n- $a = 1.0$, $\\varepsilon = 0.4$, $b = 1.5$, $\\kappa = \\pi$。\n- 时间样本 $t \\in \\{ -0.6, -0.2, 0.0, 0.2, 0.6 \\}$。\n\n角度单位要求：所有角度必须以度为单位计算和报告。除隐式角度单位说明外，最终输出无单位。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n\\left[ r_1, r_2, r_3 \\right],\n$$\n其中 $r_1$ 是以度为单位的最大朴素步间特征向量夹角（浮点数），$r_2$ 是以度为单位的最大稳定分配步间特征向量夹角（浮点数），$r_3$ 是测试套件上 $U_{\\mathrm{eig}}(t)$ 和 $U_{\\mathrm{svd}}(t)$ 之间的最大 Frobenius 范数差（浮点数）。将每个值以十进制数形式提供。没有物理单位需要报告。最终输出格式应严格为 $[r_1,r_2,r_3]$，位于单行，无附加文本。", "solution": "用户希望沿着预设的变形路径 $F(t)$，分析右 Cauchy-Green 张量 $C(t)$ 的特征向量追踪的数值行为。该路径被构造成在 $t=0$ 处有一个特征值退化点，这是一个已知的数值困难来源。\n\n### 第一步：问题验证\n\n**已知条件提取：**\n- 变形梯度：$F(t) = Q(\\alpha(t)) \\, \\mathrm{diag}(s_1(t), s_2(t), s_3) \\, Q(\\alpha(t))^{\\mathsf{T}}$\n- 旋转矩阵：$Q(\\alpha) = \\begin{bmatrix} \\cos \\alpha   -\\sin \\alpha   0\\\\ \\sin \\alpha   \\cos \\alpha   0\\\\ 0   0   1 \\end{bmatrix}$\n- 标量函数：$s_1(t) = a + \\varepsilon t$, $s_2(t) = a - \\varepsilon t$, $s_3 = b$, $\\alpha(t) = \\kappa t$。\n- 参数：$a = 1.0$, $\\varepsilon = 0.4$, $b = 1.5$, $\\kappa = \\pi$。\n- 时间样本：$t \\in \\{-0.6, -0.2, 0.0, 0.2, 0.6\\}$。\n- 右 Cauchy-Green 张量：$C(t) = F(t)^{\\mathsf{T}} F(t)$。\n- 任务 1（朴素追踪）：在每个时间步按特征值降序对特征向量排序。按顺序追踪。计算最大步间夹角 ($r_1$)。\n- 任务 2（稳定追踪）：在重叠矩阵 $|V_{\\mathrm{prev}}^{\\mathsf{T}} V_{\\mathrm{curr}}|$ 上使用线性分配问题来匹配步间特征向量。计算对齐后的最大步间夹角 ($r_2$)。\n- 任务 3（一致性）：比较计算右拉伸张量 $U(t) = \\sqrt{C(t)}$ 的两种方法：一种是通过 $C(t)$ 的特征值分解，$U_{\\mathrm{eig}}(t) = Q \\sqrt{\\Lambda} Q^{\\mathsf{T}}$；另一种是通过 $F(t)$ 的 SVD 进行极分解，$U_{\\mathrm{svd}}(t) = V \\Sigma V^{\\mathsf{T}}$。报告它们之间差异的最大 Frobenius 范数 ($r_3$)。\n- 输出：$[r_1, r_2, r_3]$，角度单位为度。\n\n**验证：**\n1.  **科学基础**：该问题基于连续介质力学和数值线性代数的基本原理。物理量 $F, C, U$ 及其谱特性的分析是标准的。$F(t)$ 的构造是研究退化点附近特征向量行为的有效数学公式。$F(t)$ 的行列式是 $s_1(t)s_2(t)s_3 = (a^2 - (\\varepsilon t)^2)b = (1 - 0.16t^2) \\times 1.5$。对于给定的范围 $t \\in [-0.6, 0.6]$，$t^2$ 的最大值为 $0.36$，使得 $\\det(F(t))$ 始终为正。因此，该变形是物理上可接受的。该问题在科学上是合理的。\n2.  **适定性**：该问题是适定的。所有参数、函数和计算过程都已明确定义，从而可以得到唯一的数值结果。\n3.  **客观性**：语言正式且明确。任务是定量的和客观的。\n4.  **完整性**：该问题是自包含的。提供了所有必要的信息。$F(t)$ 的特殊形式简化了分析：由于对于给定参数，$F(t)$ 是对称正定 (SPD) 的，所以 $C(t) = F(t)^2$。$C(t)$ 的特征向量与 $F(t)$ 的特征向量相同，其特征值是 $F(t)$ 特征值的平方。\n\n**结论**：问题有效。\n\n### 第二步：解决方案制定\n\n解决方案将按照问题陈述中描述的任务来实现。\n\n**变形路径与张量：**\n首先，我们为每个时间样本 $t_k$ 生成变形梯度张量 $F(t_k)$ 和右 Cauchy-Green 张量 $C(t_k)$。由于所提供的 $F(t)$ 是对称的，因此 $C(t) = F(t)^{\\mathsf{T}}F(t) = F(t)^2$。\n\n对于每个 $C(t_k)$，我们计算其特征分解 $C(t_k) = Q_k \\Lambda_k Q_k^{\\mathsf{T}}$。特征值将按降序排序，$Q_k$ 的列（特征向量）将相应地排序。这为两种追踪策略提供了原始数据。\n\n**策略 1：朴素特征向量追踪 ($r_1$)**\n此策略假设步骤 $t_k$ 的第 $j$ 个特征向量对应于步骤 $t_{k-1}$ 的第 $j$ 个特征向量，其中索引 $j$ 是通过按降序对特征值排序来确定的。特征向量 $q_{k-1, j}$ 和 $q_{k, j}$ 之间的夹角 $\\theta$ 计算为 $\\theta = \\arccos(|q_{k-1, j} \\cdot q_{k, j}|)$。我们找到所有特征向量 $j$ 和所有连续时间步 $(t_{k-1}, t_k)$ 中的最大夹角。\n\n在 $t=0$ 时，$s_1(0)=s_2(0)=a$，导致 $C(0)$ 出现重复特征值。对于 $t0$，$s_2(t)  s_1(t)$，而对于 $t0$，$s_1(t)  s_2(t)$。这导致最大和第二大特征值（在前两个中）的身份在 $t=0$ 时发生切换。因此，按特征值大小进行的朴素排序将在 $t=0$ 前后追踪不同的物理特征向量，导致“交换”。然而，时间步长 $\\Delta t = 0.4$ 很大，导致特征系统旋转 $\\Delta\\alpha = \\kappa \\Delta t = \\pi \\times 0.4 = 0.4\\pi = 72^\\circ$。在没有特征值交叉的步长之间（例如，从 $t=-0.6$ 到 $t=-0.2$），这种大的旋转将主导此方法的最大角度。\n\n**策略 2：稳定分配追踪 ($r_2$)**\n此策略旨在通过最大化连续步骤之间特征向量的重叠来找到一致的排序。对于从 $t_{k-1}$ 到 $t_k$ 的每一步，我们计算绝对重叠矩阵 $S_{ij} = |q_{k-1, i}^{\\mathsf{T}} q_{k, j}|$，其中 $q_{k-1}$ 是上一步对齐的向量，$q_k$ 是新计算的向量（按特征值排序）。我们在成本矩阵 $C = 1 - S$ 上解决一个线性分配问题，以找到使总重叠 $\\sum_i S_{i, \\pi(i)}$ 最大化的 $q_k$ 的排列。重新排序后，如有必要，翻转新特征向量的符号，以确保与前一个向量的点积为非负。然后计算这些对齐向量之间的最大夹角。\n\n这种方法通常更鲁棒，但可能会被大的时间步长所击败。如果步间旋转超过 $45^\\circ$，一个特征向量可能会与上一步的另一个不同特征向量比与其自身的真正后继者更对齐。对于 $\\Delta\\alpha = 72^\\circ$，预计会发生这种情况，导致“稳定”算法错误地交换特征向量。所得角度将小于真实旋转角度。此策略的最大角度可能出现在旋转小于 $45^\\circ$ 且算法能正确追踪特征向量的较小时间步长处。\n\n**策略 3：拉伸张量一致性 ($r_3$)**\n此任务验证计算 $U(t) = \\sqrt{C(t)}$ 的两种方法的数值等价性。\n1.  **谱方法**：根据特征分解 $C = Q \\Lambda Q^{\\mathsf{T}}$，我们计算 $U_{\\mathrm{eig}} = Q \\sqrt{\\Lambda} Q^{\\mathsf{T}}$。\n2.  **SVD 方法**：根据奇异值分解 $F = W \\Sigma V^{\\mathsf{T}}$，右拉伸张量是 $U_{\\mathrm{svd}} = V \\Sigma V^{\\mathsf{T}}$。\n\n由于 $F(t)$ 是对称正定的，在精确算术中，两种方法都得到 $U(t) = F(t)$。因此，差值 $\\|U_{\\mathrm{eig}}(t) - U_{\\mathrm{svd}}(t)\\|_{\\mathrm{F}}$ 仅因浮点表示和数值库中算法实现的差异而为非零。在 $t=0$ 时，退化的特征值可能会因库例程选择特征空间/奇异向量基的方式而引入轻微变化，但结果张量应仍极为接近。我们在每个时间步计算此范数，并报告找到的最大值。\n\n实现将使用 `numpy`进行线性代数计算，并使用 `scipy.optimize.linear_sum_assignment`解决分配问题。所有角度在报告时都将转换为度。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef solve():\n    \"\"\"\n    Solves the computational solid mechanics problem as specified.\n    \"\"\"\n    # Define parameters from the problem statement.\n    a = 1.0\n    eps = 0.4\n    b = 1.5\n    kappa = np.pi\n    t_samples = np.array([-0.6, -0.2, 0.0, 0.2, 0.6])\n\n    # Helper function to generate the Q matrix\n    def get_Q(alpha):\n        c, s = np.cos(alpha), np.sin(alpha)\n        return np.array([\n            [c, -s, 0],\n            [s,  c, 0],\n            [0,  0, 1]\n        ])\n\n    # Helper function to generate the F tensor\n    def get_F(t, a, eps, b, kappa):\n        s1 = a + eps * t\n        s2 = a - eps * t\n        s3 = b\n        alpha = kappa * t\n        Q = get_Q(alpha)\n        S_diag = np.diag([s1, s2, s3])\n        return Q @ S_diag @ Q.T\n\n    # Pre-compute tensors and raw eigendecompositions\n    F_list = [get_F(t, a, eps, b, kappa) for t in t_samples]\n    C_list = [F.T @ F for F in F_list]\n    \n    raw_eigenvectors_list = []\n    for C in C_list:\n        eigvals, eigvecs = np.linalg.eigh(C)\n        # Sort in descending order\n        sort_indices = np.argsort(eigvals)[::-1]\n        raw_eigenvectors_list.append(eigvecs[:, sort_indices])\n\n    # Task 1: Naive inter-step eigenvector angle\n    max_angle_naive = 0.0\n    for i in range(len(raw_eigenvectors_list) - 1):\n        V_prev = raw_eigenvectors_list[i]\n        V_curr = raw_eigenvectors_list[i+1]\n        for j in range(3):\n            dot_product = np.abs(np.dot(V_prev[:, j], V_curr[:, j]))\n            angle_rad = np.arccos(np.clip(dot_product, -1.0, 1.0))\n            angle_deg = np.rad2deg(angle_rad)\n            if angle_deg > max_angle_naive:\n                max_angle_naive = angle_deg\n    \n    r1 = max_angle_naive\n\n    # Task 2: Stable-assignment inter-step eigenvector angle\n    max_angle_stable = 0.0\n    V_prev_aligned = raw_eigenvectors_list[0]\n    for i in range(len(raw_eigenvectors_list) - 1):\n        V_curr_raw = raw_eigenvectors_list[i+1]\n        overlap_matrix = np.abs(V_prev_aligned.T @ V_curr_raw)\n        cost_matrix = 1.0 - overlap_matrix\n        row_ind, col_ind = linear_sum_assignment(cost_matrix)\n        \n        V_curr_permuted = V_curr_raw[:, col_ind]\n        V_curr_aligned = np.copy(V_curr_permuted)\n        \n        for j in range(3):\n            if np.dot(V_prev_aligned[:, j], V_curr_aligned[:, j])  0:\n                V_curr_aligned[:, j] *= -1\n        \n        for j in range(3):\n            dot_product = np.dot(V_prev_aligned[:, j], V_curr_aligned[:, j])\n            angle_rad = np.arccos(np.clip(dot_product, -1.0, 1.0))\n            angle_deg = np.rad2deg(angle_rad)\n            if angle_deg > max_angle_stable:\n                max_angle_stable = angle_deg\n\n        V_prev_aligned = V_curr_aligned\n\n    r2 = max_angle_stable\n\n    # Task 3: Maximum Frobenius norm difference between U_eig and U_svd\n    max_fro_norm_diff = 0.0\n    for i in range(len(t_samples)):\n        F = F_list[i]\n        C = C_list[i]\n        \n        # Spectral square root\n        eigvals, Q = np.linalg.eigh(C)\n        U_eig = Q @ np.diag(np.sqrt(eigvals)) @ Q.T\n        \n        # SVD square root\n        W, s, Vh = np.linalg.svd(F)\n        V = Vh.T\n        U_svd = V @ np.diag(s) @ V.T\n\n        diff = U_eig - U_svd\n        fro_norm = np.linalg.norm(diff, 'fro')\n        if fro_norm > max_fro_norm_diff:\n            max_fro_norm_diff = fro_norm\n\n    r3 = max_fro_norm_diff\n    \n    print(f\"[{r1},{r2},{r3}]\")\n\nsolve()\n\n```", "id": "3596622"}]}