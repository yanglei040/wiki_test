{"hands_on_practices": [{"introduction": "材料框架无关性原理，即客观性原理，是连续介质力学的基石。它规定了本构关系不应依赖于观察者的运动。此练习 [@problem_id:3609175] 提供了一种具体的、程序化的验证方法，用于检验在叠加刚体旋转下，变形率张量 $D$ 和自旋张量 $W$ 的行为，从而巩固您对它们在客观材料建模中基本作用的理解。", "problem": "在计算固体力学中，构造一个程序化验证，以检验形变率张量在叠加刚性旋转下的不变性。从以下基本概念出发：空间速度场 $\\mathbf{v}(\\mathbf{x},t)$ 及其速度梯度 $\\mathbf{L}(\\mathbf{x},t)$（定义为 $L_{ij}=\\partial v_{i}/\\partial x_{j}$）、对称的形变率张量 $\\mathbf{D}=\\tfrac{1}{2}\\left(\\mathbf{L}+\\mathbf{L}^{\\mathsf{T}}\\right)$ 以及斜对称的自旋张量 $\\mathbf{W}=\\tfrac{1}{2}\\left(\\mathbf{L}-\\mathbf{L}^{\\mathsf{T}}\\right)$。考虑一个角速度矢量为 $\\boldsymbol{\\omega}(t)$ 的叠加刚性旋转，它在速度场上增加了一个刚体贡献 $\\mathbf{v}^{\\mathrm{R}}(\\mathbf{x},t)=\\boldsymbol{\\omega}(t)\\times\\mathbf{x}$。该刚体贡献的梯度是一个斜对称张量 $\\boldsymbol{\\Omega}$，它对任意矢量 $\\mathbf{a}$ 满足 $\\boldsymbol{\\Omega}\\,\\mathbf{a}=\\boldsymbol{\\omega}\\times\\mathbf{a}$，其矩阵表示为\n$$\n\\boldsymbol{\\Omega}=\\begin{bmatrix}\n0  -\\omega_{3}  \\omega_{2} \\\\\n\\omega_{3}  0  -\\omega_{1} \\\\\n-\\omega_{2}  \\omega_{1}  0\n\\end{bmatrix}.\n$$\n在叠加刚性旋转下，修正后的速度梯度为 $\\mathbf{L}^{\\ast}=\\mathbf{L}+\\boldsymbol{\\Omega}$，这意味着 $\\mathbf{D}^{\\ast}=\\tfrac{1}{2}\\left(\\mathbf{L}^{\\ast}+\\mathbf{L}^{\\ast\\mathsf{T}}\\right)$ 和 $\\mathbf{W}^{\\ast}=\\tfrac{1}{2}\\left(\\mathbf{L}^{\\ast}-\\mathbf{L}^{\\ast\\mathsf{T}}\\right)$。需要验证的不变性和变换性质是：$\\mathbf{D}^{\\ast}=\\mathbf{D}$ 和 $\\mathbf{W}^{\\ast}=\\mathbf{W}+\\boldsymbol{\\Omega}$。您的程序必须实现这些定义，计算相关张量，并使用 Frobenius 范数 $\\|\\cdot\\|_{\\mathrm{F}}$ 来数值验证所述性质。\n\n使用以下参数值测试套件，其中每个测试用例提供一个单位为 $\\mathrm{s}^{-1}$ 的恒定基础速度梯度 $\\mathbf{L}$ 和一个单位为弧度每秒 (rad/s) 的角速度矢量 $\\boldsymbol{\\omega}$。所有量均采用国际单位制 (SI) 表示。角度单位是弧度。\n\n测试用例 $\\mathbf{1}$ (一般的非对称 $\\mathbf{L}$，非零 $\\boldsymbol{\\omega}$):\n$$\n\\mathbf{L}_{1}=\\begin{bmatrix}\n0.5  -1.2  0.3 \\\\\n2.1  0.0  -0.7 \\\\\n0.4  -0.9  1.8\n\\end{bmatrix}\\,\\mathrm{s}^{-1},\\quad\n\\boldsymbol{\\omega}_{1}=\\begin{bmatrix}\n0.6\\\\\n-0.2\\\\\n0.4\n\\end{bmatrix}\\,\\mathrm{rad/s}.\n$$\n\n测试用例 $\\mathbf{2}$ (一般的 $\\mathbf{L}$，零 $\\boldsymbol{\\omega}$ 边界情况):\n$$\n\\mathbf{L}_{2}=\\begin{bmatrix}\n-0.3  0.7  -0.5 \\\\\n1.2  0.4  -1.1 \\\\\n0.8  -1.1  0.2\n\\end{bmatrix}\\,\\mathrm{s}^{-1},\\quad\n\\boldsymbol{\\omega}_{2}=\\begin{bmatrix}\n0.0\\\\\n0.0\\\\\n0.0\n\\end{bmatrix}\\,\\mathrm{rad/s}.\n$$\n\n测试用例 $\\mathbf{3}$ (纯对称的 $\\mathbf{L}$，非零 $\\boldsymbol{\\omega}$):\n$$\n\\mathbf{L}_{3}=\\begin{bmatrix}\n1.0  0.2  -0.3 \\\\\n0.2  0.5  0.1 \\\\\n-0.3  0.1  0.8\n\\end{bmatrix}\\,\\mathrm{s}^{-1},\\quad\n\\boldsymbol{\\omega}_{3}=\\begin{bmatrix}\n1.0\\\\\n1.0\\\\\n1.0\n\\end{bmatrix}\\,\\mathrm{rad/s}.\n$$\n\n测试用例 $\\mathbf{4}$ (纯斜对称的 $\\mathbf{L}$，非零 $\\boldsymbol{\\omega}$):\n$$\n\\mathbf{L}_{4}=\\begin{bmatrix}\n0.0  -2.0  3.0 \\\\\n2.0  0.0  -1.0 \\\\\n-3.0  1.0  0.0\n\\end{bmatrix}\\,\\mathrm{s}^{-1},\\quad\n\\boldsymbol{\\omega}_{4}=\\begin{bmatrix}\n-0.5\\\\\n2.0\\\\\n0.0\n\\end{bmatrix}\\,\\mathrm{rad/s}.\n$$\n\n测试用例 $\\mathbf{5}$ (微小量值的边缘情况):\n$$\n\\mathbf{L}_{5}=\\begin{bmatrix}\n10^{-12}  -2\\times 10^{-12}  3\\times 10^{-12} \\\\\n-2\\times 10^{-12}  5\\times 10^{-12}  -4\\times 10^{-12} \\\\\n3\\times 10^{-12}  -4\\times 10^{-12}  -10^{-12}\n\\end{bmatrix}\\,\\mathrm{s}^{-1},\\quad\n\\boldsymbol{\\omega}_{5}=\\begin{bmatrix}\n10^{-12}\\\\\n-10^{-12}\\\\\n2\\times 10^{-12}\n\\end{bmatrix}\\,\\mathrm{rad/s}.\n$$\n\n验证方法和数值容差：对于每个测试用例，计算 $\\mathbf{D}$、$\\mathbf{W}$、$\\boldsymbol{\\Omega}$、$\\mathbf{D}^{\\ast}$ 和 $\\mathbf{W}^{\\ast}$。令 $e_{D}=\\left\\|\\mathbf{D}^{\\ast}-\\mathbf{D}\\right\\|_{\\mathrm{F}}$ 和 $e_{W}=\\left\\|\\mathbf{W}^{\\ast}-\\left(\\mathbf{W}+\\boldsymbol{\\Omega}\\right)\\right\\|_{\\mathrm{F}}$。如果 $e_{D}\\leq \\varepsilon$ 且 $e_{W}\\leq \\varepsilon$，则测试用例通过，其中绝对容差为 $\\varepsilon=10^{-12}$ $\\mathrm{s}^{-1}$。\n\n最终输出规范：您的程序应生成单行输出，其中包含五个测试用例的通过/失败结果，形式为一个用方括号括起来的、由逗号分隔的布尔值列表，例如 $\\left[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True},\\mathrm{True}\\right]$。当且仅当第 $i$ 个测试用例的两个不变性检查在给定容差下均通过时，第 $i$ 个布尔值必须为 $\\mathrm{True}$。", "solution": "问题陈述经评估有效。它在连续介质力学中有科学依据，是适定的、客观的且自洽的。所提供的数据和定义是一致的，并且足以得到唯一解。\n\n任务是验证在叠加刚体旋转下，形变率张量和自旋张量的两个基本性质。这些性质是形变率张量的不变性 $\\mathbf{D}^{\\ast}=\\mathbf{D}$，以及自旋张量的变换规则 $\\mathbf{W}^{\\ast}=\\mathbf{W}+\\boldsymbol{\\Omega}$。我们将首先提供这些性质的解析证明，然后概述数值验证算法。\n\n### 解析验证\n\n分析从问题陈述中给出的定义开始。速度梯度 $\\mathbf{L}$ 被加法分解为一个对称部分（形变率张量 $\\mathbf{D}$）和一个斜对称部分（自旋张量 $\\mathbf{W}$）：\n$$ \\mathbf{L} = \\mathbf{D} + \\mathbf{W} $$\n其中\n$$ \\mathbf{D}=\\frac{1}{2}\\left(\\mathbf{L}+\\mathbf{L}^{\\mathsf{T}}\\right) \\quad \\text{和} \\quad \\mathbf{W}=\\frac{1}{2}\\left(\\mathbf{L}-\\mathbf{L}^{\\mathsf{T}}\\right) $$\n一个角速度矢量为 $\\boldsymbol{\\omega}$ 的叠加刚体旋转增加了一个速度分量 $\\boldsymbol{\\omega} \\times \\mathbf{x}$。该速度场的梯度是一个斜对称张量 $\\boldsymbol{\\Omega}$。这会将总速度梯度修正为 $\\mathbf{L}^{\\ast}$：\n$$ \\mathbf{L}^{\\ast}=\\mathbf{L}+\\boldsymbol{\\Omega} $$\n修正后的形变率张量 $\\mathbf{D}^{\\ast}$ 和自旋张量 $\\mathbf{W}^{\\ast}$ 由 $\\mathbf{L}^{\\ast}$ 定义的方式，与 $\\mathbf{D}$ 和 $\\mathbf{W}$ 由 $\\mathbf{L}$ 定义的方式相同。\n\n**1. $\\mathbf{D}^{\\ast}=\\mathbf{D}$ 的验证**\n\n我们从 $\\mathbf{D}^{\\ast}$ 的定义开始：\n$$ \\mathbf{D}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}^{\\ast}+\\mathbf{L}^{\\ast\\mathsf{T}}\\right) $$\n代入 $\\mathbf{L}^{\\ast}$ 的表达式：\n$$ \\mathbf{D}^{\\ast} = \\frac{1}{2}\\left((\\mathbf{L}+\\boldsymbol{\\Omega}) + (\\mathbf{L}+\\boldsymbol{\\Omega})^{\\mathsf{T}}\\right) $$\n利用转置运算的线性性质，$(\\mathbf{A}+\\mathbf{B})^{\\mathsf{T}} = \\mathbf{A}^{\\mathsf{T}}+\\mathbf{B}^{\\mathsf{T}}$：\n$$ \\mathbf{D}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}+\\boldsymbol{\\Omega} + \\mathbf{L}^{\\mathsf{T}}+\\boldsymbol{\\Omega}^{\\mathsf{T}}\\right) $$\n根据定义，张量 $\\boldsymbol{\\Omega}$ 是斜对称的，这意味着 $\\boldsymbol{\\Omega}^{\\mathsf{T}} = -\\boldsymbol{\\Omega}$。代入此性质可得：\n$$ \\mathbf{D}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}+\\boldsymbol{\\Omega} + \\mathbf{L}^{\\mathsf{T}}-\\boldsymbol{\\Omega}\\right) $$\n项 $\\boldsymbol{\\Omega}$ 和 $-\\boldsymbol{\\Omega}$ 相互抵消：\n$$ \\mathbf{D}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}+\\mathbf{L}^{\\mathsf{T}}\\right) $$\n这恰好是原始形变率张量 $\\mathbf{D}$ 的定义。因此，我们已经解析地证明了：\n$$ \\mathbf{D}^{\\ast}=\\mathbf{D} $$\n这一结果表明，表征材料元拉伸和剪切的形变率是客观的或参考标架不变的；它不受叠加的刚体旋转的影响。\n\n**2. $\\mathbf{W}^{\\ast}=\\mathbf{W}+\\boldsymbol{\\Omega}$ 的验证**\n\n接下来，我们考察修正后的自旋张量 $\\mathbf{W}^{\\ast}$，其定义为：\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}^{\\ast}-\\mathbf{L}^{\\ast\\mathsf{T}}\\right) $$\n再次，我们代入 $\\mathbf{L}^{\\ast}=\\mathbf{L}+\\boldsymbol{\\Omega}$：\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left((\\mathbf{L}+\\boldsymbol{\\Omega}) - (\\mathbf{L}+\\boldsymbol{\\Omega})^{\\mathsf{T}}\\right) $$\n应用转置性质：\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}+\\boldsymbol{\\Omega} - \\mathbf{L}^{\\mathsf{T}}-\\boldsymbol{\\Omega}^{\\mathsf{T}}\\right) $$\n利用斜对称性 $\\boldsymbol{\\Omega}^{\\mathsf{T}} = -\\boldsymbol{\\Omega}$：\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}+\\boldsymbol{\\Omega} - \\mathbf{L}^{\\mathsf{T}}- (-\\boldsymbol{\\Omega})\\right) = \\frac{1}{2}\\left(\\mathbf{L}+\\boldsymbol{\\Omega} - \\mathbf{L}^{\\mathsf{T}}+\\boldsymbol{\\Omega}\\right) $$\n重新排列括号内的项，将 $\\mathbf{W}$ 的分量和 $\\boldsymbol{\\Omega}$ 项组合在一起：\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left((\\mathbf{L}-\\mathbf{L}^{\\mathsf{T}}) + 2\\boldsymbol{\\Omega}\\right) $$\n分配标量因子 $1/2$：\n$$ \\mathbf{W}^{\\ast} = \\frac{1}{2}\\left(\\mathbf{L}-\\mathbf{L}^{\\mathsf{T}}\\right) + \\frac{1}{2}(2\\boldsymbol{\\Omega}) $$\n第一项是原始自旋张量 $\\mathbf{W}$ 的定义。这可以简化为：\n$$ \\mathbf{W}^{\\ast} = \\mathbf{W} + \\boldsymbol{\\Omega} $$\n这证实了自旋张量的变换规则。材料的自旋被叠加的刚性旋转的自旋所增强，这是一个符合预期的物理结果。\n\n### 程序化验证算法\n\n程序将为每个提供的测试用例数值验证这两个恒等式。对于每个测试用例 $(\\mathbf{L}, \\boldsymbol{\\omega})$，算法如下：\n\n1.  **初始化**：给定速度梯度矩阵 $\\mathbf{L}$ 和角速度矢量 $\\boldsymbol{\\omega} = [\\omega_1, \\omega_2, \\omega_3]^{\\mathsf{T}}$。\n2.  **构造 $\\boldsymbol{\\Omega}$**：根据 $\\boldsymbol{\\omega}$ 的分量，使用提供的公式构成 $3 \\times 3$ 的斜对称矩阵 $\\boldsymbol{\\Omega}$：\n    $$\n    \\boldsymbol{\\Omega}=\\begin{bmatrix}\n    0  -\\omega_{3}  \\omega_{2} \\\\\n    \\omega_{3}  0  -\\omega_{1} \\\\\n    -\\omega_{2}  \\omega_{1}  0\n    \\end{bmatrix}\n    $$\n3.  **计算基础张量**：从 $\\mathbf{L}$ 计算原始的形变率张量 $\\mathbf{D}$ 和自旋张量 $\\mathbf{W}$：\n    - $\\mathbf{D} = 0.5 \\times (\\mathbf{L} + \\mathbf{L}^{\\mathsf{T}})$\n    - $\\mathbf{W} = 0.5 \\times (\\mathbf{L} - \\mathbf{L}^{\\mathsf{T}})$\n4.  **计算修正张量**：首先，计算修正后的速度梯度 $\\mathbf{L}^{\\ast} = \\mathbf{L} + \\boldsymbol{\\Omega}$。然后，从 $\\mathbf{L}^{\\ast}$ 计算修正后的张量 $\\mathbf{D}^{\\ast}$ 和 $\\mathbf{W}^{\\ast}$：\n    - $\\mathbf{D}^{\\ast} = 0.5 \\times (\\mathbf{L}^{\\ast} + \\mathbf{L}^{\\ast\\mathsf{T}})$\n    - $\\mathbf{W}^{\\ast} = 0.5 \\times (\\mathbf{L}^{\\ast} - \\mathbf{L}^{\\ast\\mathsf{T}})$\n5.  **计算误差**：使用 Frobenius 范数 $\\|\\cdot\\|_{\\mathrm{F}}$ 计算每个恒等式的误差：\n    - $\\mathbf{D}$ 不变性误差：$e_{D} = \\|\\mathbf{D}^{\\ast} - \\mathbf{D}\\|_{\\mathrm{F}}$\n    - $\\mathbf{W}$ 变换误差：$e_{W} = \\|\\mathbf{W}^{\\ast} - (\\mathbf{W} + \\boldsymbol{\\Omega})\\|_{\\mathrm{F}}$\n6.  **验证**：将计算出的误差与指定的容差 $\\varepsilon = 10^{-12}$ 进行比较。当且仅当同时满足以下两个条件时，测试用例通过：\n    - $e_{D} \\leq \\varepsilon$\n    - $e_{W} \\leq \\varepsilon$\n7.  **存储结果**：测试用例的结果是一个布尔值（通过为 `True`，失败为 `False`）。对所有测试用例重复此过程。\n8.  **输出**：最终输出是按指定格式排列的这些布尔结果的列表。\n\n该算法直接实现了数学定义和验证标准，利用数值库进行矩阵运算和范数计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Verifies the invariance of the rate of deformation tensor (D) and the\n    transformation rule for the spin tensor (W) under a superposed rigid rotation.\n    \"\"\"\n    # Define the absolute tolerance for numerical verification.\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (\n            np.array([[0.5, -1.2, 0.3], [2.1, 0.0, -0.7], [0.4, -0.9, 1.8]]),\n            np.array([0.6, -0.2, 0.4])\n        ),\n        # Test case 2\n        (\n            np.array([[-0.3, 0.7, -0.5], [1.2, 0.4, -1.1], [0.8, -1.1, 0.2]]),\n            np.array([0.0, 0.0, 0.0])\n        ),\n        # Test case 3\n        (\n            np.array([[1.0, 0.2, -0.3], [0.2, 0.5, 0.1], [-0.3, 0.1, 0.8]]),\n            np.array([1.0, 1.0, 1.0])\n        ),\n        # Test case 4\n        (\n            np.array([[0.0, -2.0, 3.0], [2.0, 0.0, -1.0], [-3.0, 1.0, 0.0]]),\n            np.array([-0.5, 2.0, 0.0])\n        ),\n        # Test case 5\n        (\n            np.array([\n                [1e-12, -2e-12, 3e-12],\n                [-2e-12, 5e-12, -4e-12],\n                [3e-12, -4e-12, -1e-12]\n            ]),\n            np.array([1e-12, -1e-12, 2e-12])\n        ),\n    ]\n\n    results = []\n    for L, omega in test_cases:\n        # Construct the skew-symmetric tensor Omega from the angular velocity vector omega.\n        w1, w2, w3 = omega[0], omega[1], omega[2]\n        Omega = np.array([\n            [0, -w3, w2],\n            [w3, 0, -w1],\n            [-w2, w1, 0]\n        ])\n\n        # Calculate the base rate of deformation tensor D and spin tensor W from L.\n        D = 0.5 * (L + L.T)\n        W = 0.5 * (L - L.T)\n\n        # Calculate the modified velocity gradient L_star.\n        L_star = L + Omega\n\n        # Calculate the modified rate of deformation D_star and spin W_star from L_star.\n        D_star = 0.5 * (L_star + L_star.T)\n        W_star = 0.5 * (L_star - L_star.T)\n\n        # Calculate the verification errors using the Frobenius norm.\n        # e_D should be numerically close to zero, as D_star = D analytically.\n        e_D = np.linalg.norm(D_star - D, 'fro')\n        \n        # e_W should be numerically close to zero, as W_star = W + Omega analytically.\n        e_W = np.linalg.norm(W_star - (W + Omega), 'fro')\n\n        # A test case passes if both errors are within the tolerance.\n        passes = (e_D = epsilon) and (e_W = epsilon)\n        results.append(passes)\n\n    # Format the final output as a comma-separated list of booleans.\n    # Python's str(bool) produces 'True'/'False' with capitalization, as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3609175"}, {"introduction": "虽然理论性质至关重要，但它们在计算力学中的价值取决于精确的数值实现。分片检验是一项基本的验证工具，用以确认数值方案是否能精确地（达到机器精度）再现简单的常梯度状态。本实践 [@problem_id:3609181] 将指导您实现一个分片检验，以确保您重构速度梯度 $L$ 及其分量 $D$ 和 $W$ 的方法是正确的。", "problem": "考虑一个在子域（patch）上指定的三维速度场，其中真实场是仿射的：$v(x) = A x + b$，其中 $x \\in \\mathbb{R}^3$，$v \\in \\mathbb{R}^3$，$A \\in \\mathbb{R}^{3 \\times 3}$，$b \\in \\mathbb{R}^3$。速度梯度张量定义为速度场的雅可比矩阵，即一阶偏导数矩阵 $\\nabla v$。形变率张量和自旋张量由二阶张量典范分解为对称和斜对称部分而产生。从这些基本定义以及仿射映射和张量分解的性质出发，目标是制定并实现一个计算片检验（computational patch test），以验证数值重构的形变率张量和自旋张量是否在机器精度范围内与它们的精确对应物一致。\n\n片检验应按以下步骤进行：\n\n1. 在一个片上建立一组采样点 $x^{(p)} \\in \\mathbb{R}^3$。使用以下 $14$ 个点，所有坐标均为无量纲：\n   $$(-1,-1,-1),\\ (1,-1,-1),\\ (-1,1,-1),\\ (1,1,-1),\\ (-1,-1,1),\\ (1,-1,1),\\ (-1,1,1),\\ (1,1,1),$$\n   $$(1,0,0),\\ (-1,0,0),\\ (0,1,0),\\ (0,-1,0),\\ (0,0,1),\\ (0,0,-1).$$\n   使用给定的 $A$ 和 $b$ 计算这些点上各自的速度 $v(x^{(p)})$。\n\n2. 通过将仿射模型 $v(x) = A x + b$ 与采样数据进行拟合来重构速度梯度和平移参数，拟合过程通过对每个速度分量独立进行线性最小二乘求解来完成。从该重构中，提取速度梯度的数值估计 $\\nabla v$ 作为恢复的线性系数矩阵 $A$。\n\n3. 使用速度梯度 $\\nabla v$ 的定义以及二阶张量典范分解为其对称和斜对称部分，推导形变率张量和自旋张量的表达式。实现这些表达式，以从重构的速度梯度中计算形变率张量和自旋张量的数值估计。\n\n4. 对于每个测试用例，将数值计算出的张量与由给定的 $A$ 和 $b$ 所蕴含的精确张量进行比较。定义以下误差度量，所有均为无量纲：\n   - 形变率张量的最大绝对元素误差 $e_{\\infty}^D$，以及自旋张量的最大绝对元素误差 $e_{\\infty}^W$。\n   - 形变率张量的相对弗罗贝尼乌斯范数误差 $r^D$，以及自旋张量的相对弗罗贝尼乌斯范数误差 $r^W$，其中使用弗罗贝尼乌斯范数 $\\|\\cdot\\|_F$，分母为精确张量的 $1 + \\|\\cdot\\|_F$ 以避免除以零。\n   令 $\\epsilon$ 表示双精度机器ε。当且仅当两个张量同时满足以下条件时，测试用例通过：\n   - $e_{\\infty}^D \\le 100\\,\\epsilon\\,(1 + \\|A\\|_F)$ 且 $e_{\\infty}^W \\le 100\\,\\epsilon\\,(1 + \\|A\\|_F)$，\n   - $r^D \\le 100\\,\\epsilon$ 且 $r^W \\le 100\\,\\epsilon$。\n\n所有量都应视为无量纲；不涉及角度单位。\n\n将上述内容实现为一个可运行的程序，评估以下针对 $A$ 和 $b$ 的参数值测试套件：\n\n- 测试用例1（一般仿射场）：\n  $$A = \\begin{bmatrix}\n  2.0  -1.0  0.5 \\\\\n  3.2  4.1  -2.7 \\\\\n  0.0  1.25  -0.75\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} 1.0 \\\\ -2.0 \\\\ 3.0 \\end{bmatrix}.$$\n\n- 测试用例2（纯对称梯度）：\n  $$A = \\begin{bmatrix}\n  4.0  -1.2  0.3 \\\\\n  -1.2  5.5  2.2 \\\\\n  0.3  2.2  -3.3\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} -1.0 \\\\ 0.5 \\\\ 2.0 \\end{bmatrix}.$$\n\n- 测试用例3（纯斜对称梯度）：\n  $$A = \\begin{bmatrix}\n  0.0  -3.0  2.0 \\\\\n  3.0  0.0  -1.5 \\\\\n  -2.0  1.5  0.0\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}.$$\n\n- 测试用例4（零梯度，纯平移）：\n  $$A = \\begin{bmatrix}\n  0.0  0.0  0.0 \\\\\n  0.0  0.0  0.0 \\\\\n  0.0  0.0  0.0\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} 10.0 \\\\ -10.0 \\\\ 5.0 \\end{bmatrix}.$$\n\n- 测试用例5（大数值元素）：\n  $$A = \\begin{bmatrix}\n  1.0\\times 10^8  -5.0\\times 10^7  2.0\\times 10^7 \\\\\n  3.0\\times 10^7  -4.0\\times 10^8  1.0\\times 10^8 \\\\\n  0.0  8.0\\times 10^7  -1.0\\times 10^8\n  \\end{bmatrix},\\quad\n  b = \\begin{bmatrix} -1.0\\times 10^6 \\\\ 2.0\\times 10^6 \\\\ -3.0\\times 10^6 \\end{bmatrix}.$$\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，\"[result_1,result_2,result_3,result_4,result_5]\"）。每个结果都必须是一个布尔值，指示相应的测试用例是否通过指定的机器精度片检验标准。", "solution": "该问题要求实现并执行一个计算片检验（computational patch test），以验证从采样速度数据中数值重构运动学张量的正确性。此过程是计算固体力学中的一种基本验证技术。它用于确保数值方案能够在一个恒定梯度表征的简单解状态下，在机器精度范围内精确地再现该解。在此背景下，所选的状态是一个一般的仿射速度场。\n\n速度场是位置向量 $x \\in \\mathbb{R}^3$ 的一个仿射函数，表示为：\n$$v(x) = Ax + b$$\n其中 $A \\in \\mathbb{R}^{3 \\times 3}$ 是一个表示变换线性部分的常数矩阵，$b \\in \\mathbb{R}^3$ 是一个表示平移部分的常数向量。\n\n速度梯度张量，记为 $L$，定义为速度场相对于空间坐标 $x$ 的雅可比矩阵。其分量由 $L_{ij} = \\frac{\\partial v_i}{\\partial x_j}$ 给出。对于指定的仿射场，速度梯度在整个域中是恒定的，并且与矩阵 $A$ 完全相同：\n$$L = \\nabla v = A$$\n\n任何二阶张量，例如速度梯度 $L$，都可以通过典范加法分解唯一地分解为其对称部分和斜对称部分。对称部分是形变率张量 $D$，斜对称部分是自旋张量 $W$。这些张量在描述连续体的瞬时局部运动（分别对应于拉伸/剪切和刚体旋转）中起着基础性作用。它们的定义如下：\n$$D = \\frac{1}{2}(L + L^T)$$\n$$W = \\frac{1}{2}(L - L^T)$$\n根据构造，$D$ 是对称的（$D = D^T$），$W$ 是斜对称的（$W = -W^T$），它们的和可以恢复原始的速度梯度：$L = D + W$。\n\n片检验的目标是确定数值程序在给定来自精确场的速度采样数据时，是否能够恢复精确的张量 $D$ 和 $W$。该过程包括几个不同的步骤。\n\n首先，在片内建立一组 $N=14$ 个采样点 $\\{x^{(p)}\\}_{p=1}^{N}$。在这些点上，我们评估精确速度场以获得一组相应的速度向量 $\\{v^{(p)}\\}_{p=1}^{N}$，其中 $v^{(p)} = A x^{(p)} + b$。这些采样的速度作为重构的“输入数据”。\n\n其次，我们从采样数据中数值重构仿射模型的参数。对于每个速度分量 $v_i$，其中 $i \\in \\{1, 2, 3\\}$，我们拟合一个线性模型：\n$$v_i(x_1, x_2, x_3) = A_{i1}^{\\text{num}} x_1 + A_{i2}^{\\text{num}} x_2 + A_{i3}^{\\text{num}} x_3 + b_i^{\\text{num}}$$\n这构成了一个线性最小二乘问题。对于每个分量 $i$，我们将这 $4$ 个未知系数组合成一个向量 $\\mathbf{p}_i = [A_{i1}^{\\text{num}}, A_{i2}^{\\text{num}}, A_{i3}^{\\text{num}}, b_i^{\\text{num}}]^T$。给定 $N=14$ 个采样点，我们构建一个 $N \\times 4$ 的设计矩阵 $\\mathbf{M}$，其中第 $p$ 行为 $[x_1^{(p)}, x_2^{(p)}, x_3^{(p)}, 1]$。令 $\\mathbf{v}_i$ 为分量 $i$ 的采样速度 $(v_i(x^{(p)}))$ 组成的 $N \\times 1$ 向量，我们求解系统 $\\mathbf{M} \\mathbf{p}_i \\approx \\mathbf{v}_i$。通过求解正规方程可以找到最小化残差的欧几里得范数 $\\|\\mathbf{M} \\mathbf{p}_i - \\mathbf{v}_i\\|_2$ 的标准最小二乘解：\n$$(\\mathbf{M}^T \\mathbf{M}) \\mathbf{p}_i = \\mathbf{M}^T \\mathbf{v}_i$$\n由于拟合模型（仿射函数）可以精确表示底层的数据生成过程，只要选择的采样点使得 $\\mathbf{M}^T \\mathbf{M}$ 可逆且良态，预计该重构将产生 $A^{\\text{num}} \\approx A$ 和 $b^{\\text{num}} \\approx b$，误差在浮点算术误差范围内。\n\n从重构的系数矩阵 $A^{\\text{num}}$（它代表数值速度梯度 $L^{\\text{num}}$），使用相同的分解公式计算数值形变率张量 $D^{\\text{num}}$ 和自旋张量 $W^{\\text{num}}$：\n$$D^{\\text{num}} = \\frac{1}{2}(A^{\\text{num}} + (A^{\\text{num}})^T)$$\n$$W^{\\text{num}} = \\frac{1}{2}(A^{\\text{num}} - (A^{\\text{num}})^T)$$\n\n最后，如果数值计算出的张量与精确张量的接近程度在可接受范围内（由四个特定的误差度量量化），则宣布测试通过。令 $\\epsilon$ 为双精度浮点数的机器ε。误差定义如下：\n形变率张量的最大绝对逐元素误差：$e_{\\infty}^D = \\max_{i,j} |D^{\\text{num}}_{ij} - D_{ij}|$。\n自旋张量的最大绝对逐元素误差：$e_{\\infty}^W = \\max_{i,j} |W^{\\text{num}}_{ij} - W_{ij}|$。\n形变率张量的相对弗罗贝尼乌斯范数误差：$r^D = \\frac{\\|D^{\\text{num}} - D\\|_F}{1 + \\|D\\|_F}$。\n自旋张量的相对弗罗贝尼乌斯范数误差：$r^W = \\frac{\\|W^{\\text{num}} - W\\|_F}{1 + \\|W\\|_F}$。\n\n当且仅当以下所有四个条件同时满足时，测试用例通过：\n$$e_{\\infty}^D \\le 100 \\epsilon (1 + \\|A\\|_F)$$\n$$e_{\\infty}^W \\le 100 \\epsilon (1 + \\|A\\|_F)$$\n$$r^D \\le 100 \\epsilon$$\n$$r^W \\le 100 \\epsilon$$\n因子 $100$ 和使用 $(1 + \\|A\\|_F)$ 进行的缩放为考虑数值运算（特别是最小二乘求解）期间的浮点误差累积提供了合理的容差。相对误差分母中的 `1` 确保了当精确张量为零张量时的稳定性。将针对每个测试用例按这些步骤进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a computational patch test to verify the numerical reconstruction of\n    rate-of-deformation and spin tensors for an affine velocity field.\n    \"\"\"\n\n    # 1. Establish the set of sample points as specified in the problem.\n    # Coordinates are dimensionless.\n    sample_points = np.array([\n        [-1.0, -1.0, -1.0], [ 1.0, -1.0, -1.0], [-1.0,  1.0, -1.0], [ 1.0,  1.0, -1.0],\n        [-1.0, -1.0,  1.0], [ 1.0, -1.0,  1.0], [-1.0,  1.0,  1.0], [ 1.0,  1.0,  1.0],\n        [ 1.0,  0.0,  0.0], [-1.0,  0.0,  0.0], [ 0.0,  1.0,  0.0], [ 0.0, -1.0,  0.0],\n        [ 0.0,  0.0,  1.0], [ 0.0,  0.0, -1.0]\n    ])\n\n    test_cases = [\n        # Test case 1 (general affine field)\n        (\n            [[2.0, -1.0, 0.5], [3.2, 4.1, -2.7], [0.0, 1.25, -0.75]],\n            [1.0, -2.0, 3.0]\n        ),\n        # Test case 2 (purely symmetric gradient)\n        (\n            [[4.0, -1.2, 0.3], [-1.2, 5.5, 2.2], [0.3, 2.2, -3.3]],\n            [-1.0, 0.5, 2.0]\n        ),\n        # Test case 3 (purely skew-symmetric gradient)\n        (\n            [[0.0, -3.0, 2.0], [3.0, 0.0, -1.5], [-2.0, 1.5, 0.0]],\n            [0.0, 0.0, 0.0]\n        ),\n        # Test case 4 (zero gradient, pure translation)\n        (\n            [[0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]],\n            [10.0, -10.0, 5.0]\n        ),\n        # Test case 5 (large-magnitude entries)\n        (\n            [[1.0e8, -5.0e7, 2.0e7], [3.0e7, -4.0e8, 1.0e8], [0.0, 8.0e7, -1.0e8]],\n            [-1.0e6, 2.0e6, -3.0e6]\n        ),\n    ]\n\n    # Get the double-precision machine epsilon\n    epsilon = np.finfo(float).eps\n    results = []\n\n    # Construct the design matrix M for the least-squares fit.\n    # The model is v_i = A_i1*x1 + A_i2*x2 + A_i3*x3 + b_i\n    # The columns of M correspond to the basis functions [x1, x2, x3, 1].\n    num_points = sample_points.shape[0]\n    M = np.hstack((sample_points, np.ones((num_points, 1))))\n\n    for A_exact_list, b_exact_list in test_cases:\n        A_exact = np.array(A_exact_list, dtype=float)\n        b_exact = np.array(b_exact_list, dtype=float).reshape(3, 1)\n\n        # Evaluate the velocity v(x) = A*x + b at each sample point.\n        # sample_points.T is (3, 14), A_exact @ sample_points.T is (3, 14)\n        # Add b_exact (3, 1) which broadcasts. Result is (3, 14).\n        # Transpose to get (14, 3) matrix of velocity vectors.\n        v_measured = (A_exact @ sample_points.T + b_exact).T\n\n        # 2. Reconstruct the velocity gradient and translation parameters.\n        # Solve M @ P = v_measured, where P is the (4, 3) matrix of coefficients.\n        # Each column of P contains [A_i1, A_i2, A_i3, b_i].\n        # np.linalg.lstsq solves for multiple right-hand sides simultaneously.\n        P, _, _, _ = np.linalg.lstsq(M, v_measured, rcond=None)\n        \n        # Extract the numerical estimate of the velocity gradient A_num.\n        # A_num is the transpose of the first 3 rows of P.\n        A_num = P[:3, :].T\n\n        # 3. Compute exact and numerical rate-of-deformation and spin tensors.\n        # Exact tensors\n        D_exact = 0.5 * (A_exact + A_exact.T)\n        W_exact = 0.5 * (A_exact - A_exact.T)\n\n        # Numerical tensors from reconstructed A_num\n        D_num = 0.5 * (A_num + A_num.T)\n        W_num = 0.5 * (A_num - A_num.T)\n\n        # 4. Compare numerical and exact tensors using specified error metrics.\n        \n        # Maximum absolute-entry errors\n        e_inf_D = np.max(np.abs(D_num - D_exact))\n        e_inf_W = np.max(np.abs(W_num - W_exact))\n\n        # Frobenius norms for relative error calculation\n        norm_A_exact_F = np.linalg.norm(A_exact, 'fro')\n        norm_D_exact_F = np.linalg.norm(D_exact, 'fro')\n        norm_W_exact_F = np.linalg.norm(W_exact, 'fro')\n\n        # Relative Frobenius-norm errors\n        # The denominator (1 + norm) prevents division by zero.\n        r_D = np.linalg.norm(D_num - D_exact, 'fro') / (1.0 + norm_D_exact_F)\n        r_W = np.linalg.norm(W_num - W_exact, 'fro') / (1.0 + norm_W_exact_F)\n        \n        # Define error bounds based on problem specification.\n        err_bound_abs = 100.0 * epsilon * (1.0 + norm_A_exact_F)\n        err_bound_rel = 100.0 * epsilon\n\n        # Check if all four criteria are met.\n        passes_test = all([\n            e_inf_D = err_bound_abs,\n            e_inf_W = err_bound_abs,\n            r_D = err_bound_rel,\n            r_W = err_bound_rel\n        ])\n        results.append(passes_test)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3609181"}, {"introduction": "变形率张量与体积变化之间的运动学联系是深刻的，其中条件 $\\text{tr}(D)=0$ 定义了不可压缩性。此练习 [@problem_id:3609164] 探讨了在数值模拟中随时间维持此约束的实际挑战。您将研究数值误差如何导致体积漂移，并实现一种投影方法来强制执行这一物理定律，这是计算固体和流体动力学中一种常见且至关重要的技术。", "problem": "在连续介质力学中，给定变形梯度的运动学演化。速度梯度张量定义为 $L = \\nabla v$，它通过定义 $D = \\tfrac{1}{2}\\left(L + L^{T}\\right)$ 和 $W = \\tfrac{1}{2}\\left(L - L^{T}\\right)$ 分解为对称的变形率张量 $D$ 和反对称的自旋张量 $W$。变形梯度 $F$ 通过基本运动学关系 $\\dot{F} = L\\,F$ 演化，初始条件为 $F(0)=I$，其中 $I$ 是单位张量。令 $J = \\det F$。对于不可压缩运动，$J$ 必须始终保持为 $1$。\n\n你的任务是：\n- 从基本运动学关系和基础矩阵微积分出发，推导 $J$ 的演化方程，并确定使 $J$ 随时间保持恒定的 $D$ 所需满足的条件。\n- 解释为什么即使满足了 $J$ 恒定的理论条件，数值舍入和时间积分误差仍会导致 $J$ 的值偏离 $1$。\n- 提出并论证一种通过对 $F$ 进行各向同性校正，在每个时间步强制 $J=1$ 的投影方法。该投影必须完全用 $F$ 及其行列式表示，并且应独立于 $L$ 的具体形式。\n\n然后，实现一个程序，该程序：\n- 对由给定的 $D$ 和 $W$ 定义的、不随时间变化的 $L$，积分 $\\dot{F} = L\\,F$。\n- 比较三种离散更新策略：\n    1. 无投影的前向欧拉法：$F_{n+1} = F_n + \\Delta t\\, L F_n$。\n    2. 带每步体积投影的前向欧拉法：计算 $\\widehat{F}_{n+1} = F_n + \\Delta t\\, L F_n$，然后设置 $F_{n+1} = \\alpha\\,\\widehat{F}_{n+1}$，其中 $\\alpha$ 的选择需使 $\\det(F_{n+1}) = 1$。\n    3. 使用矩阵指数在总时间 $T$ 上求解恒定 $L$ 的精确解：$F(T) = \\exp(L\\,T)$。\n- 同时，使用前向欧拉法，以相同的 $\\Delta t$ 和初始值 $J(0)=1$，对你在推导中得到的 $J$ 的标量常微分方程进行积分，以观察标量演化中的舍入效应。\n\n使用以下不随时间变化的测试组。在每种情况下，定义 $D = \\mathrm{diag}(a,-a,0)$，$W$ 为绕 $z$ 轴的平面自旋，角速度为 $\\omega$，由下式给出\n$$\nW = \\begin{bmatrix}\n0  -\\omega  0 \\\\\n\\omega  0  0 \\\\\n0  0  0\n\\end{bmatrix},\n$$\n并设置 $L = D + W$。使用单位矩阵 $I$ 作为初始条件 $F(0)$。\n\n测试组（所有量均为无量纲，因此不需要物理单位）：\n- 情况 A（边界情况，零自旋）：$a = 0.2$，$\\omega = 0.0$，$\\Delta t = 10^{-3}$，$T = 10^{-1}$。\n- 情况 B（理想情况，中等自旋）：$a = 0.2$，$\\omega = 50.0$，$\\Delta t = 10^{-4}$，$T = 5\\times 10^{-2}$。\n- 情况 C（边缘情况，大自旋）：$a = 0.2$，$\\omega = 2000.0$，$\\Delta t = 10^{-6}$，$T = 2\\times 10^{-3}$。\n\n对于每种情况，计算并报告以下四个标量：\n- $e_{\\mathrm{unproj}}^{\\mathrm{final}} = \\left|\\det\\!\\left(F_{\\mathrm{Euler\\;unproj}}(T)\\right) - 1\\right|$。\n- $e_{\\mathrm{unproj}}^{\\mathrm{max}} = \\max_{0 \\le n \\le N} \\left|\\det\\!\\left(F_{\\mathrm{Euler\\;unproj}}(t_n)\\right) - 1\\right|$，其中 $t_n = n\\,\\Delta t$ 且 $N = \\lfloor T/\\Delta t \\rfloor$。\n- $e_{\\mathrm{proj}}^{\\mathrm{final}} = \\left|\\det\\!\\left(F_{\\mathrm{Euler\\;proj}}(T)\\right) - 1\\right|$。\n- $e_{\\mathrm{expm}}^{\\mathrm{final}} = \\left|\\det\\!\\left(F_{\\mathrm{expm}}(T)\\right) - 1\\right|$。\n\n你的程序必须实现这三种积分策略，包括你提出的体积投影方法，并且必须按照指定顺序（情况A，然后情况B，然后情况C）为这三种情况中的每一种计算上述四个标量结果。最终输出必须是单行文本，其中包含这些结果，形式为方括号内用逗号分隔的浮点数列表，顺序如下\n$$\n\\big[e_{\\mathrm{unproj}}^{\\mathrm{final}}(\\mathrm{A}),\\ e_{\\mathrm{unproj}}^{\\mathrm{max}}(\\mathrm{A}),\\ e_{\\mathrm{proj}}^{\\mathrm{final}}(\\mathrm{A}),\\ e_{\\mathrm{expm}}^{\\mathrm{final}}(\\mathrm{A}),\\ e_{\\mathrm{unproj}}^{\\mathrm{final}}(\\mathrm{B}),\\ e_{\\mathrm{unproj}}^{\\mathrm{max}}(\\mathrm{B}),\\ e_{\\mathrm{proj}}^{\\mathrm{final}}(\\mathrm{B}),\\ e_{\\mathrm{expm}}^{\\mathrm{final}}(\\mathrm{B}),\\ e_{\\mathrm{unproj}}^{\\mathrm{final}}(\\mathrm{C}),\\ e_{\\mathrm{unproj}}^{\\mathrm{max}}(\\mathrm{C}),\\ e_{\\mathrm{proj}}^{\\mathrm{final}}(\\mathrm{C}),\\ e_{\\mathrm{expm}}^{\\mathrm{final}}(\\mathrm{C})\\big].\n$$\n\n所有计算都是无量纲的。不直接报告角度。不使用百分比。程序必须是自包含的，并且不得需要任何外部输入或文件。答案是实数（浮点值）。", "solution": "该问题定义明确，在连续介质力学和数值分析方面有坚实的科学基础。我们着手解决该问题，解决方案包括三个部分：理论推导、数值误差解释、投影方法提议，以及随后的实现。\n\n首先，我们推导变形梯度行列式 $J = \\det F$ 的演化方程。一个随时间变化的矩阵 $F(t)$ 的行列式的时间导数由 Jacobi 公式给出：\n$$\n\\dot{J} = \\frac{d}{dt}(\\det F) = (\\det F) \\mathrm{tr}( \\dot{F} F^{-1} ) = J \\, \\mathrm{tr}( \\dot{F} F^{-1} )\n$$\n问题陈述了基本运动学关系 $\\dot{F} = L F$，其中 $L$ 是速度梯度。将此代入 Jacobi 公式可得：\n$$\n\\dot{J} = J \\, \\mathrm{tr}( (L F) F^{-1} ) = J \\, \\mathrm{tr}(L (F F^{-1})) = J \\, \\mathrm{tr}(L)\n$$\n速度梯度 $L$ 可以分解为其对称部分（变形率张量 $D$）和反对称部分（自旋张量 $W$），使得 $L = D + W$。迹是线性算子，因此 $\\mathrm{tr}(L) = \\mathrm{tr}(D + W) = \\mathrm{tr}(D) + \\mathrm{tr}(W)$。任何反对称矩阵的迹都为零，因为其对角线元素必然为零。因此，$\\mathrm{tr}(W) = 0$。这将 $J$ 的演化方程简化为：\n$$\n\\dot{J} = J \\, \\mathrm{tr}(D)\n$$\n为了使 $J$ 随时间保持恒定，其时间导数 $\\dot{J}$ 必须为零。给定初始条件 $F(0) = I$，我们有 $J(0) = \\det(I) = 1$。由于该常微分方程的解为 $J(t) = J(0) \\exp(\\int_0^t \\mathrm{tr}(D(\\tau)) d\\tau)$，$J$ 将始终为正。因此，条件 $\\dot{J} = 0$ 等价于要求 $\\mathrm{tr}(D) = 0$。该条件意味着体积应变率为零，这是等容（体积保持）或不可压缩运动的定义。在所提供的测试用例中，$D = \\mathrm{diag}(a, -a, 0)$，因此 $\\mathrm{tr}(D) = a - a + 0 = 0$。因此，该运动在理论上是不可压缩的，$J$ 应始终保持等于 $1$。\n\n其次，我们解释为什么数值计算会导致 $J$ 的值偏离 $1$。误差有两个主要来源：时间积分（截断）误差和浮点舍入误差。\n前向欧拉法将变形梯度更新为 $F_{n+1} = F_n + \\Delta t L F_n = (I + \\Delta t L) F_n$。对此更新规则应用行列式可得 $J_{n+1} = \\det(F_{n+1}) = \\det(I + \\Delta t L) J_n$。在一个时间步 $\\Delta t$ 内的精确演化应为 $F(t_n + \\Delta t) = \\exp(\\Delta t L) F(t_n)$，其行列式为 $J(t_n + \\Delta t) = \\det(\\exp(\\Delta t L)) J(t_n) = \\exp(\\mathrm{tr}(\\Delta t L)) J(t_n)$。由于 $\\mathrm{tr}(L) = 0$，精确演化给出 $J(t_n + \\Delta t) = \\exp(0) J(t_n) = J(t_n)$，完美地保持了体积。然而，前向欧拉法的传播子 $I + \\Delta t L$ 只是 $\\exp(\\Delta t L)$ 的一阶近似。传播子的行列式为 $\\det(I + \\Delta t L) \\approx 1 + \\Delta t \\mathrm{tr}(L) + \\mathcal{O}(\\Delta t^2)$。当 $\\mathrm{tr}(L)=0$ 时，这变为 $\\det(I + \\Delta t L) = 1 + \\mathcal{O}(\\Delta t^2)$。行列式在每一步中并没有被精确保持。这就是积分方案的**截断误差**。它导致 $J$ 在多个时间步上出现系统性漂移，误差随步数近似线性累积。\n**舍入误差**是另一个问题，源于计算机上浮点数的有限精度。每次算术运算都可能引入微小的误差。这对所有三种方法都有影响。对于前向欧拉法，这种误差通常次于较大的截断误差。对于“精确”解 $F(T) = \\exp(LT)$（它是使用像 Padé 近似这样的数值算法计算的），舍入误差是唯一的偏差来源。因此，$\\det(\\exp(LT))$ 会非常接近 $1$ 但不完全等于 $1$，其差值与机器精度有关。简单的标量积分 $J_{n+1} = J_n + \\Delta t \\cdot 0 \\cdot J_n = J_n$ 且 $J_0=1$ 在理想情况下会永远保持 $J=1$。在这种平凡更新的数值实现中观察到的任何偏差都纯粹是由舍入误差引起的。\n\n第三，我们提出一种在每一步强制 $J=1$ 的投影方法。在一个时间步之后，我们计算一个暂定的变形梯度，记为 $\\widehat{F}_{n+1}$，其行列式 $\\widehat{J}_{n+1} = \\det(\\widehat{F}_{n+1})$ 可能不为 $1$。我们寻求一个与 $\\widehat{F}_{n+1}$ “接近”且满足 $\\det(F_{n+1})=1$ 的校正后变形梯度 $F_{n+1}$。问题建议采用各向同性校正，这可以表述为均匀缩放：\n$$\nF_{n+1} = \\alpha \\widehat{F}_{n+1}\n$$\n其中 $\\alpha$ 是一个标量校正因子。我们通过强制施加不可压缩性约束来找到 $\\alpha$。对于一个 $d=3$ 维问题，对两边取行列式：\n$$\n\\det(F_{n+1}) = \\det(\\alpha \\widehat{F}_{n+1}) = \\alpha^3 \\det(\\widehat{F}_{n+1}) = \\alpha^3 \\widehat{J}_{n+1}\n$$\n令 $\\det(F_{n+1})=1$，我们得到 $1 = \\alpha^3 \\widehat{J}_{n+1}$。求解 $\\alpha$ 可得：\n$$\n\\alpha = \\left( \\frac{1}{\\widehat{J}_{n+1}} \\right)^{1/3} = \\widehat{J}_{n+1}^{-1/3}\n$$\n因此，投影更新为：\n$$\nF_{n+1} = (\\det \\widehat{F}_{n+1})^{-1/3} \\widehat{F}_{n+1}\n$$\n这个投影完全用计算出的状态 $\\widehat{F}_{n+1}$ 及其行列式来表示。它对应于应用一个均匀的体积校正来恢复单位体积，这是计算力学中用于显式时间积分方案强制不可压缩性的一种常用且有效的技术。最终误差 $e_{\\mathrm{proj}}^{\\mathrm{final}}$ 仅由于最后一次投影后计算 $\\det(F_{n+1})$ 时的舍入误差而为非零。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main function to run the simulations and compute the required error metrics.\n    \"\"\"\n    test_cases = [\n        # Case A (boundary, zero spin)\n        {'a': 0.2, 'omega': 0.0, 'dt': 1e-3, 'T': 1e-1},\n        # Case B (happy path, moderate spin)\n        {'a': 0.2, 'omega': 50.0, 'dt': 1e-4, 'T': 5e-2},\n        # Case C (edge, large spin)\n        {'a': 0.2, 'omega': 2000.0, 'dt': 1e-6, 'T': 2e-3},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        a = case['a']\n        omega = case['omega']\n        dt = case['dt']\n        T = case['T']\n\n        # Ensure N is an integer, safe for floating point inaccuracies in T/dt\n        N = int(round(T / dt))\n\n        # Define D, W, and L tensors\n        D = np.array([\n            [a, 0, 0],\n            [0, -a, 0],\n            [0, 0, 0]\n        ])\n        W = np.array([\n            [0, -omega, 0],\n            [omega, 0, 0],\n            [0, 0, 0]\n        ])\n        L = D + W\n\n        # --- Method 1: Forward Euler without projection ---\n        F_unproj = np.eye(3)\n        # Pre-compute the update matrix for efficiency\n        Id_plus_dt_L = np.eye(3) + dt * L\n        \n        dets_unproj = []\n        for _ in range(N):\n            F_unproj = Id_plus_dt_L @ F_unproj\n            det_F = np.linalg.det(F_unproj)\n            dets_unproj.append(abs(det_F - 1.0))\n        \n        e_unproj_final = dets_unproj[-1] if dets_unproj else 0.0\n        e_unproj_max = max(dets_unproj) if dets_unproj else 0.0\n\n        # --- Method 2: Forward Euler with per-step volumetric projection ---\n        F_proj = np.eye(3)\n        # Re-using the same update matrix\n        for _ in range(N):\n            F_hat = Id_plus_dt_L @ F_proj\n            J_hat = np.linalg.det(F_hat)\n            \n            # Avoid division by zero or complex numbers if J_hat is negative\n            if J_hat = 0:\n                # This case is not expected in this problem but is good practice\n                # In a real simulation, this might indicate an instability\n                alpha = 1.0 \n            else:\n                alpha = J_hat**(-1.0/3.0)\n                \n            F_proj = alpha * F_hat\n            \n        det_F_proj_final = np.linalg.det(F_proj)\n        e_proj_final = abs(det_F_proj_final - 1.0)\n        \n        # --- Method 3: Exact constant-L solution using matrix exponential ---\n        F_expm = expm(L * T)\n        det_F_expm = np.linalg.det(F_expm)\n        e_expm_final = abs(det_F_expm - 1.0)\n\n        all_results.extend([e_unproj_final, e_unproj_max, e_proj_final, e_expm_final])\n\n    # Convert results to string with a consistent format\n    # Using 'g' format specifier for clean output\n    formatted_results = [f\"{val:.15g}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3609164"}]}