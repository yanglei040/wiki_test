{"hands_on_practices": [{"introduction": "我们计算力学之旅的起点是其最基本的构建单元：单元刚度矩阵。这个练习将引导您从第一性原理（虚功原理、线弹性）出发，推导二维杆单元的全局刚度矩阵，其中包含从局部坐标到全局坐标的关键变换。除了纯粹的推导，您还将通过编程实现一系列关键的数值检验，以验证您的实现是否满足旋转不变性、能正确处理符号约定错误以及退化几何构型，从而为任何有限元程序代码打下坚实的基础。[@problem_id:3602979]", "problem": "您需要实现一个程序，该程序从第一性原理出发，构建一个二维杆（双节点桁架）单元的全局刚度矩阵，并设计数值检验来验证其在刚体旋转下的不变性并检测常见的符号约定错误。推导过程必须从一维小应变运动学、线性弹性本构关系和虚功原理开始，然后进而获得单元轴向坐标系下的局部单元刚度。接下来，使用由方向余弦构建的正交变换，将局部刚度映射到每个节点具有两个自由度（DOF）的全局（实验室）坐标系。随后，程序必须在一套测试套件上应用此公式，该套件用于探查旋转不变性、对称性和半正定性、一个刻意设计的“病态”方向以及一个退化几何的边界情况。\n\n您应使用的基本原理：\n- 轴向变形杆的小应变运动学：轴向应变 $\\varepsilon = du/dx$。\n- 杆的线性弹性本构关系：轴向应力 $\\sigma = E\\varepsilon$，其中 $E$ 是杨氏模量。\n- 保守线性系统的虚功原理，它能够通过内虚功平衡推导出对称的单元刚度算子。\n- 使用方向余弦进行正交基变换，以在局部单元坐标和全局坐标之间进行映射。\n\n使用以下建模和数值约定：\n- 二维杆单元，节点位于全局坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，杨氏模量为 $E$（单位：帕斯卡），横截面积为 $A$（单位：平方米）。\n- 单元长度为 $\\ell = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}$（单位：米），其单位方向余弦为 $c = (x_2-x_1)/\\ell$ 和 $s = (y_2-y_1)/\\ell$。\n- 局部单元位移向量是二维的，每个节点沿单元轴线有一个平移自由度，而全局位移向量是四维的，每个节点有两个平移自由度。从全局到局部的映射必须通过方向余弦构建的正交变换来构造。\n- 将单元视为线性弹性，并忽略体力。\n\n您的程序必须：\n- 从第一性原理出发，通过构建单元轴向坐标系下的 $2\\times 2$ 局部刚度，然后通过由方向余弦 $c$ 和 $s$ 构建的正交变换将其映射到全局坐标系，从而构造出 $4\\times 4$ 的全局单元刚度矩阵 $K_e$。\n- 计算 $K_e$ 的谱并提取唯一的非零特征值。对于二维空间中的自由双节点杆单元，$K_e$ 必须是对称半正定的，并且恰好有一个严格为正的特征值。所有特征值都应在有数值保护措施的情况下报告；如果一个特征值的量级低于按 $k = EA/\\ell$ 缩放的容差，则视其为“零”。\n- 通过一个将单元翻转 $180^\\circ$ 的“病态”方向来验证旋转不变性，这将同时改变 $c$ 和 $s$ 的符号。如果变换实现正确，全局 $K_e$ 在此翻转下必须保持不变。通过差值的弗罗贝尼乌斯范数（Frobenius norm）来衡量不变性，并与相对容差进行比较。\n- 通过将正确的刚度与一个使用刻意引入符号错误的变换计算出的刚度进行比较，来检测一个常见的符号约定错误。对于非轴对齐的单元，这个错误必须导致一个可检测的差异。报告该差异是否超过指定的容差。\n- 通过标记长度满足 $\\ell  10^{-9}$ 米的单元来检测退化几何，在这种情况下不应构建刚度矩阵。\n\n物理单位：\n- $E$ 使用 $\\mathrm{Pa}$，$A$ 使用 $\\mathrm{m}^2$，所有坐标使用 $\\mathrm{m}$。刚度矩阵项和特征值的单位为 $\\mathrm{N}/\\mathrm{m}$。将所有报告的特征值以浮点数形式表示，单位为 $\\mathrm{N}/\\mathrm{m}$。\n\n角度单位：\n- 任何对角度的引用都由坐标隐含；不需要显式的角度输入。\n\n容差：\n- 使用特征值零点容差 $10^{-9}k$，其中 $k = EA/\\ell$ 的单位是 $\\mathrm{N}/\\mathrm{m}$。\n- 通过弗罗贝尼乌斯范数检查 $180^\\circ$ 翻转下的相等性时，使用相对矩阵不变性容差 $10^{-12}$。\n- 使用退化长度阈值 $10^{-9}$ 米。\n\n测试套件：\n- 对于所有非退化单元，使用 $E = 210\\times 10^{9}$ Pa 和 $A = 10^{-2}$ $\\mathrm{m}^2$。\n- 案例 A（轴对齐，水平）：节点 $1$ 位于 $(0,0)$ 米，节点 $2$ 位于 $(5,0)$ 米。以浮点数形式报告 $K_e$ 的唯一非零特征值（单位 $\\mathrm{N}/\\mathrm{m}$）。\n- 案例 B（轴对齐，垂直）：节点 $1$ 位于 $(0,0)$ 米，节点 $2$ 位于 $(0,5)$ 米。以浮点数形式报告 $K_e$ 的唯一非零特征值（单位 $\\mathrm{N}/\\mathrm{m}$）。\n- 案例 C（非轴对齐的 $3$–$4$–$5$ 三角形几何）：节点 $1$ 位于 $(0,0)$ 米，节点 $2$ 位于 $(3,4)$ 米。以浮点数形式报告 $K_e$ 的唯一非零特征值（单位 $\\mathrm{N}/\\mathrm{m}$）。\n- 病态旋转不变性：比较 $(0,0)\\rightarrow(3,4)$ 和 $(0,0)\\rightarrow(-3,-4)$ 的 $K_e$。如果差值的相对弗罗贝尼乌斯范数低于 $10^{-12}$，则报告一个布尔值 true。\n- 案例 C 的对称性和半正定性检查：如果 $K_e$ 在机器容差内是对称的，并且恰好有一个严格为正的特征值，而所有其他特征值都在上述定义的零点容差内，则报告一个布尔值 true。\n- 非轴对齐单元上的符号约定错误检测：使用节点 $(0,0)$ 和 $(1,1)$。在一个方向余弦项中故意构造一个带错误符号的变换，并将得到的刚度与正确的刚度进行比较。如果差值的弗罗贝尼乌斯范数超过特征值零点容差的标度，则报告一个布尔值 true。\n- 退化几何：节点 $(0,0)$ 和 $(10^{-12},0)$。如果几何形状因 $\\ell  10^{-9}$ 米而被正确标记为无效，则报告一个布尔值 true。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  - 案例 A、B 和 C 中唯一非零特征值的三个浮点数（单位 $\\mathrm{N}/\\mathrm{m}$），\n  - 四个布尔值，分别对应 $180^\\circ$ 不变性检查、对称性和半正定性检查、符号约定错误检测以及退化几何检测。\n- 所需输出结构示例：$[\\text{float},\\text{float},\\text{float},\\text{bool},\\text{bool},\\text{bool},\\text{bool}]$。", "solution": "该问题要求对二维杆（桁架）单元的全局刚度矩阵进行公式化和程序化实现，包括一套数值验证检查。推导和实现将按规定从第一性原理开始。\n\n### 单元刚度矩阵的推导\n\n有限元的节点力和节点位移之间的关系通过其刚度矩阵来表达。我们使用虚功原理（$\\delta W$）来推导这个矩阵，该原理指出，对于处于平衡状态的物体，对于任何运动学上容许的虚位移，由应力所做的内虚功等于由外力所做的外虚功。为了推导刚度矩阵，我们只考虑内虚功 $\\delta W_{int}$。\n\n$\\delta W_{int} = \\int_V \\delta\\varepsilon^T \\sigma \\, dV$\n\n**1. 局部刚度矩阵 ($k_e$)**\n\n首先，我们在与单元轴线（$x'$）对齐的局部坐标系中构建刚度。该单元有两个节点，1 和 2，其属性为杨氏模量 $E$、横截面积 $A$ 和长度 $\\ell$。自由度是每个节点的轴向位移 $d'_{1}$ 和 $d'_{2}$。\n\n沿单元的位移场 $u'(x')$ 是使用线性形函数从节点位移插值得到的，$N_1(x') = 1 - x'/\\ell$ 和 $N_2(x') = x'/\\ell$：\n$$ u'(x') = N_1(x') d'_{1} + N_2(x') d'_{2} = \\begin{bmatrix} N_1(x')  N_2(x') \\end{bmatrix} \\begin{Bmatrix} d'_{1} \\\\ d'_{2} \\end{Bmatrix} = \\mathbf{N} \\mathbf{d}_{local} $$\n\n轴向应变 $\\varepsilon$ 是位移场的空间导数。对于线性形函数，应变沿单元是恒定的：\n$$ \\varepsilon = \\frac{du'}{dx'} = \\frac{d\\mathbf{N}}{dx'} \\mathbf{d}_{local} = \\begin{bmatrix} -\\frac{1}{\\ell}  \\frac{1}{\\ell} \\end{bmatrix} \\mathbf{d}_{local} = \\mathbf{B} \\mathbf{d}_{local} $$\n这里，$\\mathbf{B}$ 是应变-位移矩阵。虚应变为 $\\delta\\varepsilon = \\mathbf{B} \\delta\\mathbf{d}_{local}$。\n\n线性弹性的本构关系（胡克定律）关联了应力 $\\sigma$ 和应变 $\\varepsilon$：\n$$ \\sigma = E \\varepsilon = E \\mathbf{B} \\mathbf{d}_{local} $$\n\n将这些代入内虚功表达式，并注意到对于横截面积恒为 $A$ 的杆，$dV = A \\, dx'$：\n$$ \\delta W_{int} = \\int_0^\\ell (\\delta\\varepsilon)^T \\sigma A \\, dx' = \\int_0^\\ell (\\mathbf{B} \\delta\\mathbf{d}_{local})^T (E \\mathbf{B} \\mathbf{d}_{local}) A \\, dx' $$\n由于 $\\mathbf{d}_{local}$ 及其变分 $\\delta\\mathbf{d}_{local}$ 与 $x'$ 无关，且 $\\mathbf{B}$、$E$ 和 $A$ 是常数，我们可以写出：\n$$ \\delta W_{int} = (\\delta\\mathbf{d}_{local})^T \\left( A E \\int_0^\\ell \\mathbf{B}^T \\mathbf{B} \\, dx' \\right) \\mathbf{d}_{local} $$\n括号中的表达式是 $2 \\times 2$ 的局部刚度矩阵 $k_e$：\n$$ k_e = A E \\ell \\mathbf{B}^T \\mathbf{B} = A E \\ell \\begin{Bmatrix} -1/\\ell \\\\ 1/\\ell \\end{Bmatrix} \\begin{bmatrix} -1/\\ell  1/\\ell \\end{bmatrix} = \\frac{AE}{\\ell^2} \\ell \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n$$ k_e = \\frac{EA}{\\ell} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} $$\n\n**2. 全局刚度矩阵 ($K_e$)**\n\n接下来，我们将局部刚度矩阵转换到全局 $x$-$y$ 坐标系。现在每个节点有两个平移自由度：节点 1 为 $(u_1, v_1)$，节点 2 为 $(u_2, v_2)$。全局位移向量为 $\\mathbf{d}_{global} = [u_1, v_1, u_2, v_2]^T$。\n\n节点上的局部轴向位移 $d'_i$ 是其全局位移向量 $(u_i, v_i)$ 在单元轴线上的投影。该轴线的方向由一个单位向量给出，其分量为 $(c, s)$，其中 $c$ 和 $s$ 是方向余弦：\n$$ c = \\frac{x_2 - x_1}{\\ell}, \\quad s = \\frac{y_2 - y_1}{\\ell} $$\n局部和全局位移之间的关系是：\n$$ d'_{1} = c u_1 + s v_1 $$\n$$ d'_{2} = c u_2 + s v_2 $$\n这可以写成矩阵形式 $\\mathbf{d}_{local} = \\mathbf{T} \\mathbf{d}_{global}$：\n$$ \\begin{Bmatrix} d'_{1} \\\\ d'_{2} \\end{Bmatrix} = \\begin{bmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{bmatrix} \\begin{Bmatrix} u_1 \\\\ v_1 \\\\ u_2 \\\\ v_2 \\end{Bmatrix} $$\n其中 $\\mathbf{T}$ 是 $2 \\times 4$ 的变换矩阵。\n\n根据功等效原理，内功对于坐标系的选择必须是不变的。\n$$ \\delta W_{int} = (\\delta\\mathbf{d}_{local})^T k_e \\mathbf{d}_{local} = (\\delta\\mathbf{d}_{global})^T K_e \\mathbf{d}_{global} $$\n代入 $\\mathbf{d}_{local} = \\mathbf{T} \\mathbf{d}_{global}$ 和 $\\delta\\mathbf{d}_{local} = \\mathbf{T} \\delta\\mathbf{d}_{global}$：\n$$ (\\mathbf{T} \\delta\\mathbf{d}_{global})^T k_e (\\mathbf{T} \\mathbf{d}_{global}) = (\\delta\\mathbf{d}_{global})^T (\\mathbf{T}^T k_e \\mathbf{T}) \\mathbf{d}_{global} $$\n由此，我们确定 $4 \\times 4$ 的全局刚度矩阵 $K_e$：\n$$ K_e = \\mathbf{T}^T k_e \\mathbf{T} $$\n执行矩阵乘法：\n$$ K_e = \\begin{bmatrix} c  0 \\\\ s  0 \\\\ 0  c \\\\ 0  s \\end{bmatrix} \\left( \\frac{EA}{\\ell} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} \\right) \\begin{bmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{bmatrix} $$\n$$ K_e = \\frac{EA}{\\ell} \\begin{bmatrix} c  -c \\\\ s  -s \\\\ -c  c \\\\ -s  s \\end{bmatrix} \\begin{bmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{bmatrix} $$\n这得到了全局刚度矩阵的最终表达式：\n$$ K_e = \\frac{EA}{\\ell} \\begin{bmatrix} c^2  cs  -c^2  -cs \\\\ cs  s^2  -cs  -s^2 \\\\ -c^2  -cs  c^2  cs \\\\ -cs  -s^2  cs  s^2 \\end{bmatrix} $$\n这个矩阵可以紧凑地写为 $K_e = \\frac{EA}{\\ell} \\begin{bmatrix} \\mathbf{M}  -\\mathbf{M} \\\\ -\\mathbf{M}  \\mathbf{M} \\end{bmatrix}$，其中 $\\mathbf{M} = \\begin{bmatrix} c^2  cs \\\\ cs  s^2 \\end{bmatrix}$。\n\n### 属性和验证检查\n\n**1. $K_e$ 的谱**：矩阵 $K_e$ 的大小为 $4 \\times 4$。对于一个自由单元，存在三种刚体模态（二维平面中的两次平移和一次旋转），对应三个零特征值。因此，该矩阵的秩为 1。一个秩为 1 的矩阵只有一个非零特征值，其值等于矩阵的迹。\n$$ \\lambda_{nonzero} = \\text{Tr}(K_e) = \\frac{EA}{\\ell} (c^2 + s^2 + c^2 + s^2) = \\frac{EA}{\\ell} (2(c^2_i+s^2_i)) = 2 \\frac{EA}{\\ell} $$\n这个特征值代表了单元的轴向刚度，并且它对于单元在空间中的方向是不变的。\n\n**2. 旋转不变性**：$K_e$ 的结构取决于 $c^2$、$s^2$ 和 $cs$。如果一个单元旋转 $180^\\circ$，其方向余弦会变号：$(c, s) \\to (-c, -s)$。然而，乘积项 $c^2 \\to (-c)^2 = c^2$，$s^2 \\to (-s)^2 = s^2$ 和 $cs \\to (-c)(-s) = cs$ 保持不变。因此，全局刚度矩阵 $K_e$ 在这种旋转下必须是不变的。\n\n**3. 对称性和半正定性**：矩阵 $K_e$ 是从表达式 $\\mathbf{T}^T k_e \\mathbf{T}$ 推导出来的。由于局部刚度矩阵 $k_e$ 是对称的，所以 $K_e$ 也是对称的。作为一个稳定物理系统的刚度矩阵，它必须是半正定的，这意味着它的所有特征值都必须是非负的（$\\lambda_i \\ge 0$）。\n\n**4. 符号约定错误**：一个常见的错误是为方向余弦使用不一致的符号，例如，使用 $s = (y_1-y_2)/\\ell$ 而不是 $s = (y_2-y_1)/\\ell$。这个缺陷会翻转 $s$ 的符号，进而翻转矩阵 $\\mathbf{M}$ 中 $cs$ 项的符号，导致任何非轴对齐单元的刚度矩阵不正确。\n\n**5. 退化几何**：如果一个单元的两个节点重合或在数值上非常接近，其长度 $\\ell$ 会趋近于零。这会导致刚度计算中出现除以零的情况，表明存在奇异性。这类单元必须被标记并从分析中排除。\n\n以下程序实现了这些原理，并在指定的测试套件上执行所需的验证检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_stiffness_matrix(coords, E, A, sign_error_s=False):\n    \"\"\"\n    Constructs the global stiffness matrix for a 2D bar element.\n\n    Args:\n        coords (tuple): A tuple of (x1, y1, x2, y2) nodal coordinates.\n        E (float): Young's modulus in Pascals.\n        A (float): Cross-sectional area in square meters.\n        sign_error_s (bool): If True, introduces a sign error in the 's' direction cosine.\n\n    Returns:\n        tuple: A tuple containing (K_e, l, k_base) where K_e is the 4x4 stiffness\n               matrix (np.ndarray), l is the element length (float), and k_base\n               is the axial stiffness EA/l (float). Returns (None, l, None) if\n               the element is degenerate.\n    \"\"\"\n    x1, y1, x2, y2 = coords\n    dx = x2 - x1\n    dy = y2 - y1\n    \n    l = np.sqrt(dx**2 + dy**2)\n    \n    # Degenerate geometry check\n    degenerate_length_threshold = 1e-9\n    if l  degenerate_length_threshold:\n        return None, l, None\n\n    c = dx / l\n    s = dy / l\n    \n    # Introduce intentional sign error for the specific test case\n    if sign_error_s:\n        s = -s\n\n    k_base = E * A / l\n    \n    c2 = c * c\n    s2 = s * s\n    cs = c * s\n    \n    # Sub-matrix M\n    M = np.array([\n        [c2, cs],\n        [cs, s2]\n    ])\n    \n    # Assemble the 4x4 global stiffness matrix K_e\n    K_e = k_base * np.block([\n        [ M, -M],\n        [-M,  M]\n    ])\n    \n    return K_e, l, k_base\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and generate the final output.\n    \"\"\"\n    results = []\n    \n    # --- Shared parameters ---\n    E_modulus = 210.0e9  # Pa\n    Area = 1.0e-2       # m^2\n    \n    # --- Test Cases A, B, C: Unique Nonzero Eigenvalue ---\n    cases_abc = [\n        (0.0, 0.0, 5.0, 0.0),  # Case A: Horizontal\n        (0.0, 0.0, 0.0, 5.0),  # Case B: Vertical\n        (0.0, 0.0, 3.0, 4.0),  # Case C: 3-4-5 Triangle\n    ]\n    \n    for coords in cases_abc:\n        K_e, l, k_base = get_stiffness_matrix(coords, E_modulus, Area)\n        \n        # Eigenvalue zero tolerance\n        eigenvalue_zero_tol = 1e-9 * k_base\n        \n        # Use eigh for symmetric matrices; it's faster and more stable\n        eigenvalues = eigh(K_e, eigvals_only=True)\n        \n        # Find the single eigenvalue that is strictly positive\n        # based on the defined tolerance.\n        nonzero_eig = eigenvalues[eigenvalues > eigenvalue_zero_tol]\n        \n        # There should be exactly one such eigenvalue\n        if len(nonzero_eig) == 1:\n            results.append(nonzero_eig[0])\n        else:\n            # Append a sentinel value if the check fails, though it shouldn't\n            results.append(-1.0)\n            \n    # --- Pathological Rotation Invariance Check ---\n    coords1 = (0.0, 0.0, 3.0, 4.0)\n    coords2 = (0.0, 0.0, -3.0, -4.0) # 180-degree rotation\n    \n    K_e1, _, _ = get_stiffness_matrix(coords1, E_modulus, Area)\n    K_e2, _, _ = get_stiffness_matrix(coords2, E_modulus, Area)\n    \n    norm_k1 = np.linalg.norm(K_e1, 'fro')\n    diff_norm = np.linalg.norm(K_e1 - K_e2, 'fro')\n    \n    # Avoid division by zero for a null matrix, though not expected here\n    relative_diff = diff_norm / norm_k1 if norm_k1 > 0 else 0\n    \n    relative_invariance_tol = 1e-12\n    invariance_check = relative_diff  relative_invariance_tol\n    results.append(invariance_check)\n\n    # --- Symmetry and Positive Semidefiniteness (PSD) Check on Case C ---\n    K_e_C, l_C, k_base_C = get_stiffness_matrix(cases_abc[2], E_modulus, Area)\n    \n    # 1. Symmetry Check\n    is_symmetric = np.allclose(K_e_C, K_e_C.T)\n    \n    # 2. PSD Check: 1 strictly positive eigenvalue, others are 'zero'\n    eigenvalues_C = eigh(K_e_C, eigvals_only=True)\n    eigenvalue_zero_tol_C = 1e-9 * k_base_C\n    \n    # All eigenvalues must be non-negative (within tolerance)\n    are_non_negative = np.all(eigenvalues_C >= -eigenvalue_zero_tol_C)\n    \n    # Exactly one eigenvalue must be strictly positive\n    num_positive_eigs = np.sum(eigenvalues_C > eigenvalue_zero_tol_C)\n    has_one_positive_eig = (num_positive_eigs == 1)\n\n    symmetry_psd_check = is_symmetric and are_non_negative and has_one_positive_eig\n    results.append(symmetry_psd_check)\n    \n    # --- Sign-Convention Mistake Detection ---\n    coords_sign_test = (0.0, 0.0, 1.0, 1.0)\n    \n    K_correct, l_sign, k_base_sign = get_stiffness_matrix(coords_sign_test, E_modulus, Area, sign_error_s=False)\n    K_flawed, _, _ = get_stiffness_matrix(coords_sign_test, E_modulus, Area, sign_error_s=True)\n    \n    # The scale for comparison is k = EA/l\n    zero_tolerance_scale = k_base_sign\n    \n    mistake_diff_norm = np.linalg.norm(K_correct - K_flawed, 'fro')\n    \n    sign_mistake_detected = mistake_diff_norm > zero_tolerance_scale\n    results.append(sign_mistake_detected)\n\n    # --- Degenerate Geometry Detection ---\n    coords_degenerate = (0.0, 0.0, 1e-12, 0.0)\n    \n    _, l_degenerate, _ = get_stiffness_matrix(coords_degenerate, E_modulus, Area)\n    \n    degenerate_length_threshold = 1e-9\n    is_degenerate = l_degenerate  degenerate_length_threshold\n    results.append(is_degenerate)\n    \n    # --- Final Output Formatting ---\n    # Convert booleans to Python's capitalization 'True'/'False' for output\n    formatted_results = []\n    for r in results:\n        if isinstance(r, (bool, np.bool_)):\n            formatted_results.append(str(r))\n        else:\n            formatted_results.append(f\"{r:.1f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3602979"}, {"introduction": "一旦我们拥有了正确的单元，下一步就是将它们组装成结构。任何有效的结构力学公式都必须通过一项关键测试：其在刚体运动下的行为。此练习要求您构建一个小型桁架，并验证纯平移和旋转运动不会在结构内部产生内力——这正是所谓的“刚体运动不变性”。通过在坐标变换中有意引入一个常见的编程错误，您将亲眼见证它是如何产生非物理的“伪刚度”，从而深刻理解在有限元分析代码开发中进行严格验证的重要性。[@problem_id:3602998]", "problem": "二维桁架单元是连接两个节点的直杆，每个节点在全局坐标方向上具有两个自由度 (DOF)。在有限元法 (FEM) 中，此类单元的刚度公式必须保持刚体运动的物理不变性，即整个结构的任何均匀平移或均匀旋转都应产生零内力。从以下基本原理出发：(i) 小应变线性弹性，其中 $ \\sigma = E\\varepsilon $；(ii) 小位移梯度下的杆轴向应变 $ \\varepsilon = \\frac{du}{dx} $；以及 (iii) 对于线性系统，在平衡状态下内功与外功相等的虚功原理。基于这些原理，推导单元在局部轴向坐标系下的刚度，然后通过将全局位移投影到单元轴上的正交变换，严格地获得全局刚度。该变换依赖于方向余弦 $ c = \\Delta x / L $ 和 $ s = \\Delta y / L $，其中 $ \\Delta x $ 和 $ \\Delta y $ 是节点坐标的差值，$ L $ 是单元长度。\n\n设计一个最小的、由两个单元组成的桁架，在纯刚体运动下，该桁架应表现出零内力。使用三个节点：节点 $ 0 $ 位于 $(0,0)$，节点 $ 1 $ 位于 $(1,1)$，节点 $ 2 $ 位于 $(1,-1)$，单元为 $(0,1)$ 和 $(0,2)$。考虑两种刚体运动：对每个节点施加一个均匀平移 $(t_x,t_y)$，以及一个绕原点的均匀微小转动，转角为 $ \\varphi $，其中每个位于 $(x_i,y_i)$ 的节点移动 $(u_{x,i},u_{y,i}) = \\varphi(-y_i, x_i)$。对于从全局位移到局部位移的正确变换，在组装全局刚度矩阵并乘以全局位移向量后，这些运动必须产生零内力。\n\n为了探测对变换符号错误的敏感性，定义一个“有错误的”（buggy）变换，该变换错误地反转了第二个节点投影中正弦项的符号。具体来说，这个错误的变换在映射第二个节点的全局位移时，在其正弦贡献中使用 $ s \\mapsto -s $，而余弦贡献保持不变。证明这个单一的符号错误会引入伪刚度，即在纯刚体运动下会产生非零内力。\n\n你必须实现一个完整的程序，该程序：\n- 从第一性原理出发，构建二维桁架结构的全局刚度矩阵，通过将全局自由度投影到局部轴向自由度上，然后再投影回全局坐标，计算并组装单元刚度。同时使用上述正确的变换和有错误的变换。\n- 对于指定的刚体运动，计算内力向量 $ \\mathbf{r} = \\mathbf{K}\\mathbf{u} $ 的欧几里得范数，其中 $ \\mathbf{K} $ 是组装好的全局刚度矩阵，$ \\mathbf{u} $ 是全局位移向量。\n- 对所有单元使用以下物理参数：杨氏模量 $ E = 7.0\\times 10^{10}\\,\\mathrm{Pa} $，横截面积 $ A = 1.0\\times 10^{-4}\\,\\mathrm{m}^2 $。\n- 使用平移 $(t_x,t_y) = (0.123\\,\\mathrm{m},-0.456\\,\\mathrm{m})$ 和转动 $ \\varphi = 0.2\\,\\mathrm{rad} $。\n- 生成以牛顿 ($ \\mathrm{N} $) 为单位的结果，角度以弧度表示。\n\n此外，再设计两种桁架变体作为回归测试：\n1. 轴对齐变体：节点为 $(0,0)$、$(1,0)$、$(-1,0)$，单元为 $(0,1)$ 和 $(0,2)$。由于所有单元的 $ s = 0 $，该变体应对正弦符号错误不敏感。\n2. 近轴对齐变体：节点为 $(0,0)$、$(1,\\varepsilon)$、$(-1,\\varepsilon)$，其中 $ \\varepsilon = 10^{-6}\\,\\mathrm{m} $，单元为 $(0,1)$ 和 $(0,2)$。在有错误的变换下，该变体应表现出非常小但非零的伪刚度。\n\n对于每种桁架变体，计算以下情况下的内力向量的欧几里得范数 $ \\|\\mathbf{K}\\mathbf{u}\\|_2 $：\n- 正确变换下的均匀平移和均匀转动。\n- 有错误的变换下的均匀平移和均匀转动。\n\n按以下方式组织测试：\n- 变体 $ V_1 $ (旋转桁架)：节点 $(0,0)$、$(1,1)$、$(1,-1)$；单元 $(0,1)$ 和 $(0,2)$；平移和转动如上指定。\n- 变体 $ V_2 $ (轴对齐桁架)：节点 $(0,0)$、$(1,0)$、$(-1,0)$；单元 $(0,1)$ 和 $(0,2)$；平移和转动如上指定。\n- 变体 $ V_3 $ (近轴桁架)：节点 $(0,0)$、$(1,\\varepsilon)$、$(-1,\\varepsilon)$，其中 $ \\varepsilon = 10^{-6}\\,\\mathrm{m} $；单元 $(0,1)$ 和 $(0,2)$；平移和转动如上指定。\n\n你的程序必须生成单行输出，其中包含八个用逗号分隔的浮点数，并用方括号括起来，顺序完全如下：\n$ [R_{V_1}^{\\text{corr,trans}}, R_{V_1}^{\\text{corr,rot}}, R_{V_1}^{\\text{bug,trans}}, R_{V_1}^{\\text{bug,rot}}, R_{V_2}^{\\text{bug,trans}}, R_{V_2}^{\\text{bug,rot}}, R_{V_3}^{\\text{bug,trans}}, R_{V_3}^{\\text{bug,rot}}] $，其中每个 $ R $ 是以 $ \\mathrm{N} $ 为单位的欧几里得范数 $ \\|\\mathbf{K}\\mathbf{u}\\|_2 $。在有错误的变换下，轴对齐变体 $ V_2 $ 在两种运动下理想情况都应产生精确的零值，从而揭示该错误检测的一个盲点，而 $ V_3 $ 应产生与 $ \\varepsilon $ 成比例的微小非零值。此输出可作为自动回归测试套件，用于标记此类变换符号错误。\n\n你的实现必须是自包含的，仅使用指定的运行时环境，并且不需要任何输入。最终答案必须是一个完整的、可运行的程序，该程序构建三种桁架变体，使用正确和有错误的变换组装刚度矩阵，应用指定的刚体运动，以 $ \\mathrm{N} $ 为单位计算范数，并按要求的最终输出格式在单行上打印它们。", "solution": "本问题的核心主题是在有限元法 (FEM) 框架内，为二维桁架单元建立单元刚度矩阵。任何有效的力学公式的基石是其对物理不变性原理的遵守，具体而言，刚体运动——未变形体的均匀平移或旋转——绝不能产生内应力或内应变。本问题要求严格推导正确的刚度矩阵，展示其不变性属性，并分析一个特定的、潜在几何变换中的细微错误如何违反此原理，从而导致虚假的、非物理的内力。\n\n### 1. 局部坐标系中的单元刚度\n\n我们从单个桁架单元开始，它是一根一维杆。在其由单元轴 $x'$ 定义的局部坐标系中，该单元连接节点 $1$ 和节点 $2$。每个节点只有一个轴向自由度，$u'_1$ 和 $u'_2$。\n\n在小位移假设下，轴向位移场 $u'(x')$ 可以通过节点位移进行线性插值：\n$$ u'(x') = (1 - \\frac{x'}{L})u'_1 + (\\frac{x'}{L})u'_2 $$\n其中 $L$ 是单元长度。\n\n轴向应变 $\\varepsilon$ 是位移场的空间导数。对于这种线性插值，应变沿单元是恒定的：\n$$ \\varepsilon = \\frac{du'}{dx'} = \\frac{1}{L}(u'_2 - u'_1) $$\n这可以写成矩阵形式 $\\varepsilon = \\mathbf{B}\\mathbf{u'}$，其中 $\\mathbf{u'} = [u'_1, u'_2]^T$ 是局部坐标位移向量，$\\mathbf{B} = \\frac{1}{L}[-1, 1]$ 是应变-位移矩阵。\n\n根据线弹性理论（一维杆的胡克定律），轴向应力 $\\sigma$ 与应变成正比：$\\sigma = E\\varepsilon$，其中 $E$ 是杨氏模量。\n\n节点力 $\\mathbf{f'} = [f'_1, f'_2]^T$ 和节点位移 $\\mathbf{u'}$ 之间的关系由局部单元刚度矩阵 $\\mathbf{k'}$ 给出，即 $\\mathbf{f'} = \\mathbf{k'}\\mathbf{u'}$。利用虚功原理或应变能方法，$\\mathbf{k'}$ 推导如下：\n$$ \\mathbf{k'} = \\int_V \\mathbf{B}^T E \\mathbf{B} \\,dV = A \\int_0^L \\mathbf{B}^T E \\mathbf{B} \\,dx' $$\n其中 $A$ 是横截面积。代入 $\\mathbf{B}$ 可得：\n$$ \\mathbf{k'} = A \\int_0^L \\frac{1}{L^2} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} E \\begin{pmatrix} -1  1 \\end{pmatrix} dx' = \\frac{AE}{L^2} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\int_0^L dx' = \\frac{AE}{L} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\n这是杆单元在其局部坐标系中的标准 $2 \\times 2$ 刚度矩阵。\n\n### 2. 到全局坐标系的变换\n\n在二维分析中，每个节点 $i$ 有两个全局自由度，$(u_{ix}, u_{iy})$。单元的方向由其与全局 x 轴的夹角 $\\theta$ 定义，或等效地由其方向余弦定义：\n$$ c = \\cos\\theta = \\frac{x_j - x_i}{L} \\quad \\text{and} \\quad s = \\sin\\theta = \\frac{y_j - y_i}{L} $$\n其中节点 $i$ 和 $j$ 是单元的端点。\n\n节点的轴向位移是其全局位移向量在单元轴上的投影。因此，局部轴向位移 $u'_i$ 和 $u'_j$ 通过一个变换矩阵 $\\mathbf{T}$ 与全局位移 $\\mathbf{u}_e = [u_{ix}, u_{iy}, u_{jx}, u_{jy}]^T$ 相关联：\n$$ \\mathbf{u'} = \\begin{pmatrix} u'_i \\\\ u'_j \\end{pmatrix} = \\begin{pmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{pmatrix} \\begin{pmatrix} u_{ix} \\\\ u_{iy} \\\\ u_{jx} \\\\ u_{jy} \\end{pmatrix} = \\mathbf{T}\\mathbf{u}_e $$\n功等效原理指出，全局力所做的功必须与局部力所做的功相等，即 $\\mathbf{u'}^T\\mathbf{f'} = \\mathbf{u}_e^T\\mathbf{f}_e$。由此可得力的变换关系：$\\mathbf{f}_e = \\mathbf{T}^T\\mathbf{f'}$。\n\n代入这些关系，我们得到 $\\mathbf{f}_e = \\mathbf{T}^T(\\mathbf{k'}\\mathbf{u'}) = \\mathbf{T}^T\\mathbf{k'}(\\mathbf{T}\\mathbf{u}_e)$。因此，全局坐标系中的单元刚度矩阵 $\\mathbf{k}_e$ 为：\n$$ \\mathbf{k}_e = \\mathbf{T}^T\\mathbf{k'}\\mathbf{T} $$\n执行该矩阵乘法：\n$$ \\mathbf{k}_e = \\frac{AE}{L} \\begin{pmatrix} c  0 \\\\ s  0 \\\\ 0  c \\\\ 0  s \\end{pmatrix} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\begin{pmatrix} c  s  0  0 \\\\ 0  0  c  s \\end{pmatrix} = \\frac{AE}{L} \\begin{pmatrix}\nc^2  cs  -c^2  -cs \\\\\ncs  s^2  -cs  -s^2 \\\\\n-c^2  -cs  c^2  cs \\\\\n-cs  -s^2  cs  s^2\n\\end{pmatrix} $$\n该矩阵是对称的，并正确地关联了单元的四个全局自由度。$\\mathbf{k}_e$ 的一个关键性质是其任意行或列的元素之和为零。这确保了在均匀平移（所有节点具有相同的位移 $(t_x, t_y)$）下，合力为零，即 $\\mathbf{k}_e [t_x, t_y, t_x, t_y]^T = \\mathbf{0}$。该公式对于微小转动也能正确地得到零力，因为单元长度的一阶变化量为零。\n\n### 3. “有错误的”变换与伪刚度\n\n问题引入了一个错误的变换矩阵 $\\mathbf{T}_{bug}$，其中第二个节点（节点 $j$）投影的正弦项符号被反转：\n$$ \\mathbf{T}_{bug} = \\begin{pmatrix} c  s  0  0 \\\\ 0  0  c  -s \\end{pmatrix} $$\n这个看似微小的符号错误对应于一个不一致的几何假设。由此产生的“有错误的”单元刚度矩阵 $\\mathbf{k}_{e,bug}$ 的推导方式类似：\n$$ \\mathbf{k}_{e,bug} = \\mathbf{T}_{bug}^T \\mathbf{k'} \\mathbf{T}_{bug} $$\n我们定义一个向量 $\\mathbf{v}_{bug} = (\\begin{pmatrix}1  -1\\end{pmatrix} \\mathbf{T}_{bug})^T = [c, s, -c, s]^T$。那么，有错误的刚度矩阵就是外积 $\\mathbf{k}_{e,bug} = \\frac{AE}{L} \\mathbf{v}_{bug}\\mathbf{v}_{bug}^T$，其结果是：\n$$ \\mathbf{k}_{e,bug} = \\frac{AE}{L} \\begin{pmatrix}\nc^2  cs  -c^2  cs \\\\\ncs  s^2  -cs  s^2 \\\\\n-c^2  -cs  c^2  -cs \\\\\ncs  s^2  -cs  s^2\n\\end{pmatrix} $$\n虽然这个矩阵仍然是对称的，但它不再具有行和为零的性质。任意行的和都与 $2s$ 成正比。具体来说，第 $i$ 行的和与 $(\\mathbf{v}_{bug})_i \\sum_j (\\mathbf{v}_{bug})_j = (\\mathbf{v}_{bug})_i (c+s-c+s) = 2s(\\mathbf{v}_{bug})_i$ 成正比。如果 $s \\neq 0$，这个和就非零。因此，当施加均匀平移时，$\\mathbf{k}_{e,bug} [t_x, t_y, t_x, t_y]^T \\neq \\mathbf{0}$，从而产生虚假的、非物理的内力。这违反了平移不变性原理。类似的分析也显示其违反了旋转不变性。\n\n### 4. 系统组装与分析\n\n整个结构的全局刚度矩阵 $\\mathbf{K}$ 是通过根据所有单元的节点连接关系，将其单元刚度矩阵 $\\mathbf{k}_e$ 的贡献相加而组装起来的。在给定的全局位移向量 $\\mathbf{u}$ 下，结构的总内力向量为 $\\mathbf{r} = \\mathbf{K}\\mathbf{u}$。\n\n问题要求使用正确和有错误的刚度公式，计算三种桁架变体在平移和旋转两种运动下的内力向量的欧几里得范数 $\\|\\mathbf{r}\\|_2$。\n\n- **V1 (旋转桁架)**：单元具有非零的 $s$ 值，因此该错误将在平移和旋转中都表现出来。\n- **V2 (轴对齐桁架)**：单元与 x 轴对齐，因此所有单元的 $s = 0$。有错误的变换变得与正确的变换相同（$c \\pm s = c \\pm 0$），使得该错误在这种配置下无法被检测到。$\\|\\mathbf{r}\\|_2$ 应为零。\n- **V3 (近轴桁架)**：单元具有一个非常小但非零的 $s = \\varepsilon/L$。有错误的公式将产生微小但非零的伪力，从而证明该错误对方向的敏感性。\n\n对于正确的公式，任何刚体运动 (RBM) 都必须满足 $\\|\\mathbf{K}_{corr}\\mathbf{u}_{RBM}\\|_2$ 为零（在浮点精度范围内）。对于有错误的公式，如果任何单元的 $s \\neq 0$，则 $\\|\\mathbf{K}_{bug}\\mathbf{u}_{RBM}\\|_2$ 将为非零，从而暴露该缺陷。以下程序实现了这一验证过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_element_stiffness(p1, p2, E, A, buggy):\n    \"\"\"\n    Computes the 4x4 element stiffness matrix in global coordinates.\n\n    Args:\n        p1 (tuple): Coordinates of the first node (x1, y1).\n        p2 (tuple): Coordinates of the second node (x2, y2).\n        E (float): Young's modulus.\n        A (float): Cross-sectional area.\n        buggy (bool): If True, use the buggy transformation matrix.\n\n    Returns:\n        numpy.ndarray: The 4x4 element stiffness matrix.\n    \"\"\"\n    dx = p2[0] - p1[0]\n    dy = p2[1] - p1[1]\n    L = np.sqrt(dx**2 + dy**2)\n\n    if np.isclose(L, 0):\n        return np.zeros((4, 4))\n\n    c = dx / L\n    s = dy / L\n\n    # Local 2x2 stiffness matrix\n    k_prime_factor = E * A / L\n    k_prime = k_prime_factor * np.array([[1, -1], [-1, 1]])\n\n    # Transformation matrix from global to local displacements\n    if buggy:\n        # Buggy transformation: flips the sign of 's' for the second node\n        T = np.array([[c, s, 0, 0], [0, 0, c, -s]])\n    else:\n        # Correct transformation\n        T = np.array([[c, s, 0, 0], [0, 0, c, s]])\n        \n    # Element stiffness matrix in global coordinates: k_e = T.T @ k_prime @ T\n    k_e = T.T @ k_prime @ T\n    \n    return k_e\n\ndef assemble_global_stiffness(nodes, elements, E, A, buggy):\n    \"\"\"\n    Assembles the global stiffness matrix for the truss structure.\n\n    Args:\n        nodes (list of tuples): List of nodal coordinates.\n        elements (list of tuples): List of elements defined by node indices.\n        E (float): Young's modulus.\n        A (float): Cross-sectional area.\n        buggy (bool): If True, use the buggy element stiffness formulation.\n\n    Returns:\n        numpy.ndarray: The global stiffness matrix.\n    \"\"\"\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n\n    for n1, n2 in elements:\n        p1 = nodes[n1]\n        p2 = nodes[n2]\n        k_e = get_element_stiffness(p1, p2, E, A, buggy)\n\n        # Map local DOFs to global DOFs\n        dof_map = [2 * n1, 2 * n1 + 1, 2 * n2, 2 * n2 + 1]\n        \n        # Add element stiffness to global matrix\n        for i_local in range(4):\n            for j_local in range(4):\n                i_global = dof_map[i_local]\n                j_global = dof_map[j_local]\n                K[i_global, j_global] += k_e[i_local, j_local]\n    \n    return K\n\ndef get_displacement_vectors(nodes, t_vec, phi):\n    \"\"\"\n    Generates global displacement vectors for rigid-body motions.\n\n    Args:\n        nodes (list of tuples): List of nodal coordinates.\n        t_vec (tuple): Translation vector (tx, ty).\n        phi (float): Infinitesimal rotation angle in radians.\n\n    Returns:\n        tuple: (u_translation, u_rotation) as numpy arrays.\n    \"\"\"\n    num_nodes = len(nodes)\n    num_dofs = 2 * num_nodes\n    u_trans = np.zeros(num_dofs)\n    u_rot = np.zeros(num_dofs)\n\n    tx, ty = t_vec\n    for i, (x, y) in enumerate(nodes):\n        # Uniform translation\n        u_trans[2 * i] = tx\n        u_trans[2 * i + 1] = ty\n        \n        # Infinitesimal rotation about the origin\n        u_rot[2 * i] = -phi * y\n        u_rot[2 * i + 1] = phi * x\n        \n    return u_trans, u_rot\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem's requirements.\n    \"\"\"\n    # Physical and motion parameters\n    E = 7.0e10  # Pa\n    A = 1.0e-4  # m^2\n    translation_vec = (0.123, -0.456)  # m\n    rotation_angle = 0.2  # rad\n    epsilon = 1.0e-6 # m\n\n    # Define truss variants\n    variants = {\n        \"V1\": {\n            \"nodes\": [(0.0, 0.0), (1.0, 1.0), (1.0, -1.0)],\n            \"elements\": [(0, 1), (0, 2)],\n        },\n        \"V2\": {\n            \"nodes\": [(0.0, 0.0), (1.0, 0.0), (-1.0, 0.0)],\n            \"elements\": [(0, 1), (0, 2)],\n        },\n        \"V3\": {\n            \"nodes\": [(0.0, 0.0), (1.0, epsilon), (-1.0, epsilon)],\n            \"elements\": [(0, 1), (0, 2)],\n        },\n    }\n\n    results = []\n\n    # --- Variant V1: Rotated Truss ---\n    v1_spec = variants[\"V1\"]\n    v1_nodes = v1_spec[\"nodes\"]\n    v1_elements = v1_spec[\"elements\"]\n    u_trans_v1, u_rot_v1 = get_displacement_vectors(v1_nodes, translation_vec, rotation_angle)\n\n    # Correct transformation\n    K_corr_v1 = assemble_global_stiffness(v1_nodes, v1_elements, E, A, buggy=False)\n    r_corr_trans_v1 = K_corr_v1 @ u_trans_v1\n    r_corr_rot_v1 = K_corr_v1 @ u_rot_v1\n    results.append(np.linalg.norm(r_corr_trans_v1))\n    results.append(np.linalg.norm(r_corr_rot_v1))\n\n    # Buggy transformation\n    K_bug_v1 = assemble_global_stiffness(v1_nodes, v1_elements, E, A, buggy=True)\n    r_bug_trans_v1 = K_bug_v1 @ u_trans_v1\n    r_bug_rot_v1 = K_bug_v1 @ u_rot_v1\n    results.append(np.linalg.norm(r_bug_trans_v1))\n    results.append(np.linalg.norm(r_bug_rot_v1))\n    \n    # --- Variant V2: Axis-Aligned Truss ---\n    v2_spec = variants[\"V2\"]\n    v2_nodes = v2_spec[\"nodes\"]\n    v2_elements = v2_spec[\"elements\"]\n    u_trans_v2, u_rot_v2 = get_displacement_vectors(v2_nodes, translation_vec, rotation_angle)\n\n    # Buggy transformation (Correct is guaranteed to be 0)\n    K_bug_v2 = assemble_global_stiffness(v2_nodes, v2_elements, E, A, buggy=True)\n    r_bug_trans_v2 = K_bug_v2 @ u_trans_v2\n    r_bug_rot_v2 = K_bug_v2 @ u_rot_v2\n    results.append(np.linalg.norm(r_bug_trans_v2))\n    results.append(np.linalg.norm(r_bug_rot_v2))\n\n    # --- Variant V3: Near-Axis-Aligned Truss ---\n    v3_spec = variants[\"V3\"]\n    v3_nodes = v3_spec[\"nodes\"]\n    v3_elements = v3_spec[\"elements\"]\n    u_trans_v3, u_rot_v3 = get_displacement_vectors(v3_nodes, translation_vec, rotation_angle)\n\n    # Buggy transformation\n    K_bug_v3 = assemble_global_stiffness(v3_nodes, v3_elements, E, A, buggy=True)\n    r_bug_trans_v3 = K_bug_v3 @ u_trans_v3\n    r_bug_rot_v3 = K_bug_v3 @ u_rot_v3\n    results.append(np.linalg.norm(r_bug_trans_v3))\n    results.append(np.linalg.norm(r_bug_rot_v3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3602998"}, {"introduction": "我们如何确信我们的有限元模型能够在一个复杂问题中收敛到正确的解？“分片检验”（Patch Test）为这个问题提供了一个根本性的答案。这项实践要求您对一片单元施加一个均匀的应变场，并验证您的列式能够精确地再现这个简单的应变状态。通过分片检验是有限元方法保证收敛的必要条件。这个动手实践将巩固您对这一关键验证标准的理解，并展示单元列式中的错误如何导致检验失败，从而使可靠的模拟结果变得遥不可及。[@problem_id:3603016]", "problem": "设计并实现一个二维桁架的薄片测试（patch test），该测试用于验证组装后的全局刚度矩阵能够精确再现一个均匀线性位移（恒定应变）场，并诊断因局部坐标与全局坐标间转换错误而导致的失效。您的实现必须遵循以下规范。\n\n从基本的小应变运动学和虚功原理（PVW）出发，并对每个杆件使用一维轴向线弹性模型。考虑一个平面桁架，其中每个单元仅承受轴向力。对于位于位置 $(x,y)$ 的节点，定义一个产生均匀各向同性应变的线性位移场：$u(x,y)=\\epsilon_0 x$ 和 $v(x,y)=\\epsilon_0 y$，其中 $\\epsilon_0$ 是一个给定的标量。在此场下，小应变张量是均匀的，$\\varepsilon_{xx}=\\epsilon_0$，$\\varepsilon_{yy}=\\epsilon_0$，$\\varepsilon_{xy}=0$，因此任何单位方向向量为 $\\mathbf{n}=[c,s]^T$ 的杆件的轴向应变为 $\\epsilon_{\\text{axial}}=\\mathbf{n}^T \\boldsymbol{\\varepsilon} \\, \\mathbf{n} = \\epsilon_0$。您的程序必须验证有限元桁架公式能够精确地再现此结果。\n\n几何与材料：\n- 节点：一个间距为 $L = 1.0$ 米的均匀 $3\\times 3$ 网格，即坐标为 $(i L, j L)$，其中 $i,j \\in \\{0,1,2\\}$。\n- 单元：对于包含对角线的工况，连接每个 $1\\times 1$ 方形单元格中的水平、垂直相邻节点以及两条对角线。对于不含对角线的工况，仅连接水平和垂直相邻节点。\n- 材料：所有单元的杨氏模量 $E = 210 \\times 10^9$ 帕斯卡，横截面积 $A = 1.0\\times 10^{-4}$ 平方米。\n\n边界条件与精确场：\n- 在所有边界节点上施加本质边界条件（Dirichlet 条件），以匹配精确线性场 $u(x,y)=\\epsilon_0 x$，$v(x,y)=\\epsilon_0 y$。保持位于 $(L,L)$ 的单个内部节点为自由节点。\n- 使用从局部轴向坐标到全局 $(u_x,u_y)$ 自由度的正确转换，由单元贡献组装全局刚度矩阵 $K$。\n- 求解自由度并与在这些节点上计算的精确场进行比较。\n\n薄片测试通过的验证标准：\n- 位移再现：计算得到的自由节点位移必须在相对容差 $1.0\\times 10^{-10}$ 内与精确场匹配，当精确范数为零时使用绝对回退容差 $1.0\\times 10^{-12}$。形式上，如果 $\\mathbf{u}_f$ 是计算得到的自由度向量，而 $\\mathbf{u}_{f}^{\\text{exact}}$ 是精确值，则要求 $\\|\\mathbf{u}_f-\\mathbf{u}_{f}^{\\text{exact}}\\|_2 \\le \\max( 1.0\\times 10^{-10}\\|\\mathbf{u}_{f}^{\\text{exact}}\\|_2, 1.0\\times 10^{-12})$。\n- 均匀轴向应变：对于每个单元，根据节点位移计算轴向应变为 $\\epsilon_e = \\dfrac{\\mathbf{n}^T(\\mathbf{u}_j-\\mathbf{u}_i)}{L_e}$，其中 $L_e$ 是单元长度，$\\mathbf{u}_i,\\mathbf{u}_j$ 是节点位移向量。要求对所有单元都满足 $|\\epsilon_e-\\epsilon_0| \\le \\max( 1.0\\times 10^{-10}|\\epsilon_0|, 1.0\\times 10^{-12})$。\n\n通过转换错误进行失效诊断：\n- 为揭示转换矩阵的错误，也应使用一个故意错误的转换来组装 $K$，其中方向余弦被交换，即使用 $c_{\\text{bug}}=\\Delta y/L$ 和 $s_{\\text{bug}}=\\Delta x/L$ 来代替正确的 $c=\\Delta x/L$ 和 $s=\\Delta y/L$。对于一个非平凡的 $\\epsilon_0$，使用此错误时，上述标准中至少有一条必须不满足。\n\n测试套件：\n实现以下四个工况，每个工况产生一个布尔值，指示薄片测试是否通过。\n- 工况 1：包含对角线，正确转换，$\\epsilon_0=1.0\\times 10^{-4}$。\n- 工况 2：包含对角线，错误（交换的）转换，$\\epsilon_0=1.0\\times 10^{-4}$。\n- 工况 3：无对角线，正确转换，$\\epsilon_0=5.0\\times 10^{-5}$。\n- 工况 4：包含对角线，正确转换，$\\epsilon_0=0.0$。\n\n单位与输出：\n- 所有距离单位为米，力为牛顿，应力为帕斯卡，应变为无量纲，位移为米。角度必须通过方向余弦隐式处理；不要显式使用度或弧度。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\text{True},\\text{False},\\text{True}]$），按顺序对应工况 1 到 4。\n\n限制：\n- 最终答案必须是一个完整的、可运行的程序，该程序能够组装桁架刚度矩阵、施加边界条件、求解自由度、计算诊断量，并以所要求的确切格式打印最终结果。", "solution": "该问题要求设计并实现一个二维桁架结构的薄片测试。薄片测试是有限元方法（FEM）中的一个基本验证程序，用于确保单元公式能够精确地再现恒定应变状态。通过薄片测试是有限元收敛的必要条件。本解答详细介绍了该测试的理论推导和算法实现。\n\n基于位移的有限元方法的基础是虚功原理（PVW），该原理指出，如果对于任何运动学上容许的虚位移场，内虚功等于外虚功，则物体处于平衡状态。对于没有体积力的线弹性体，这表示为：\n$$\n\\int_V \\delta\\boldsymbol{\\varepsilon}^T \\boldsymbol{\\sigma} \\, dV = \\delta\\mathbf{u}^T \\mathbf{F}\n$$\n其中 $\\boldsymbol{\\sigma}$ 是应力张量，$\\delta\\boldsymbol{\\varepsilon}$ 是与虚位移 $\\delta\\mathbf{u}$ 对应的虚应变张量，$\\mathbf{F}$ 是外部节点力向量。\n\n对于沿局部坐标轴 $x'$ 定向的一维桁架单元，应力和应变纯粹是轴向的。使用本构关系 $\\sigma' = E \\epsilon'$，其中 $E$ 是杨氏模量，对于长度为 $L_e$、横截面积恒为 $A$ 的单元，虚功原理简化为：\n$$\n\\int_0^{L_e} (A E \\epsilon') \\delta\\epsilon' \\, dx' = \\delta\\mathbf{u}'_{\\text{local}}^T \\mathbf{f}'_{\\text{local}}\n$$\n轴向应变 $\\epsilon'$ 假定沿单元长度是恒定的，由长度变化量除以原始长度给出。对于在其两端具有局部节点位移 $d'_1$ 和 $d'_2$ 的单元，应变为 $\\epsilon' = (d'_2 - d'_1) / L_e$。虚应变为 $\\delta\\epsilon' = (\\delta d'_2 - \\delta d'_1) / L_e$。将这些代入积分并执行积分得到：\n$$\n\\frac{AE}{L_e} (d'_2 - d'_1) (\\delta d'_2 - \\delta d'_1) = f'_1 \\delta d'_1 + f'_2 \\delta d'_2\n$$\n通过匹配独立虚位移 $\\delta d'_1$ 和 $\\delta d'_2$ 的系数，我们得到局部坐标系中的节点力-位移关系：\n$$\n\\begin{pmatrix} f'_1 \\\\ f'_2 \\end{pmatrix} = \\frac{AE}{L_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\begin{pmatrix} d'_1 \\\\ d'_2 \\end{pmatrix}\n$$\n这定义了局部单元刚度矩阵 $\\mathbf{k}'_e = \\frac{AE}{L_e} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n\n为了在二维分析中使用它，我们必须将其转换到全局 $(x, y)$ 坐标系。设单元连接节点 1（位于 $(x_1, y_1)$）和节点 2（位于 $(x_2, y_2)$）。单元的方向由其方向余弦定义：$c = \\cos\\theta = \\frac{\\Delta x}{L_e}$ 和 $s = \\sin\\theta = \\frac{\\Delta y}{L_e}$，其中 $\\Delta x = x_2 - x_1$，$\\Delta y = y_2 - y_1$，且 $L_e = \\sqrt{\\Delta x^2 + \\Delta y^2}$。单元的全局位移向量为 $\\mathbf{d}_e = [u_1, v_1, u_2, v_2]^T$。每个节点的局部轴向位移是全局位移向量在单元轴上的投影：\n$$\nd'_1 = u_1 c + v_1 s \\quad , \\quad d'_2 = u_2 c + v_2 s\n$$\n单元应变能为 $U_e = \\frac{1}{2} \\mathbf{d}'^T \\mathbf{k}'_e \\mathbf{d}' = \\frac{1}{2} \\frac{AE}{L_e} (d'_2 - d'_1)^2$。代入 $d'_1$ 和 $d'_2$ 的表达式：\n$$\nU_e = \\frac{1}{2} \\frac{AE}{L_e} \\left( (u_2 - u_1)c + (v_2 - v_1)s \\right)^2\n$$\n全局单元刚度矩阵 $\\mathbf{k}_e$ 是应变能相对于全局节点位移的 Hessian 矩阵，即 $\\mathbf{k}_e(i,j) = \\frac{\\partial^2 U_e}{\\partial d_i \\partial d_j}$。执行此微分运算得到 $4 \\times 4$ 的全局单元刚度矩阵：\n$$\n\\mathbf{k}_e = \\frac{EA}{L_e}\n\\begin{pmatrix}\nc^2  cs  -c^2  -cs \\\\\ncs  s^2  -cs  -s^2 \\\\\n-c^2  -cs  c^2  cs \\\\\n-cs  -s^2  cs  s^2\n\\end{pmatrix}\n$$\n整个桁架结构的全局刚度矩阵 $\\mathbf{K}$ 是通过将每个单元的 $\\mathbf{k}_e$ 的贡献累加到其单元全局自由度（DOFs）对应的位置来组装的。这得到了全局线性方程组 $\\mathbf{K}\\mathbf{u} = \\mathbf{F}$，其中 $\\mathbf{u}$ 是所有全局节点位移的向量，$\\mathbf{F}$ 是所有外部节点力的向量。\n\n对于薄片测试，需要施加边界条件。我们将自由度（DOFs）划分为一组自由（未知）自由度（下标为 $f$）和一组指定（已知）自由度（下标为 $p$）。全局系统被重写为：\n$$\n\\begin{pmatrix} \\mathbf{K}_{ff}  \\mathbf{K}_{fp} \\\\ \\mathbf{K}_{pf}  \\mathbf{K}_{pp} \\end{pmatrix}\n\\begin{pmatrix} \\mathbf{u}_f \\\\ \\mathbf{u}_p \\end{pmatrix} =\n\\begin{pmatrix} \\mathbf{F}_f \\\\ \\mathbf{F}_p \\end{pmatrix}\n$$\n问题指定了一个间距为 $L=1.0$ 的 $3 \\times 3$ 节点网格。所有 8 个边界节点的位移都被指定以匹配精确线性场 $u(x,y)=\\epsilon_0 x$ 和 $v(x,y)=\\epsilon_0 y$。这使得位于 $(L, L)$ 的单个内部节点成为唯一具有自由自由度的节点。该内部节点上没有施加外力，因此 $\\mathbf{F}_f = \\mathbf{0}$。未知位移 $\\mathbf{u}_f$ 的方程从上部分区中提取：\n$$\n\\mathbf{K}_{ff} \\mathbf{u}_f + \\mathbf{K}_{fp} \\mathbf{u}_p = \\mathbf{F}_f = \\mathbf{0}\n$$\n由此求解 $\\mathbf{u}_f$：\n$$\n\\mathbf{K}_{ff} \\mathbf{u}_f = - \\mathbf{K}_{fp} \\mathbf{u}_p\n$$\n计算出的 $\\mathbf{u}_f$ 随后必须根据两个标准进行验证。首先，它必须在指定的容差内匹配自由节点的精确位移 $\\mathbf{u}_{f}^{\\text{exact}} = [\\epsilon_0 L, \\epsilon_0 L]^T$：$\\|\\mathbf{u}_f - \\mathbf{u}_{f}^{\\text{exact}}\\|_2 \\le \\max(1.0\\times 10^{-10}\\|\\mathbf{u}_{f}^{\\text{exact}}\\|_2, 1.0\\times 10^{-12})$。其次，每个单元中的轴向应变 $\\epsilon_e$，由完整位移场（包括计算的 $\\mathbf{u}_f$ 和指定的 $\\mathbf{u}_p$）计算得出，必须匹配恒定应变 $\\epsilon_0$：\n$$\n\\epsilon_e = \\frac{\\mathbf{n}^T(\\mathbf{u}_j-\\mathbf{u}_i)}{L_e}\n$$\n其中 $\\mathbf{u}_i$ 和 $\\mathbf{u}_j$ 是单元节点的完整位移向量，$\\mathbf{n}$ 是单元的单位方向向量。对于所有单元，必须满足 $|\\epsilon_e-\\epsilon_0| \\le \\max(1.0\\times 10^{-10}|\\epsilon_0|, 1.0\\times 10^{-12})$。只有当位移和应变标准都满足时，一个测试工况才算通过。\n\n为了诊断实现错误，测试中包含了一个工况，其中单元刚度矩阵使用一个故意错误的转换进行组装：方向余弦被交换（$c_{\\text{bug}}=s$, $s_{\\text{bug}}=c$）。对于任何不呈 $45^\\circ$ 角（即 $c \\neq s$）的单元，这会向 $\\mathbf{k}_e$ 引入错误，并因此影响全局矩阵 $\\mathbf{K}$。这种不正确的刚度表示会导致自由节点处的力平衡出错，使得计算出的位移 $\\mathbf{u}_f$ 偏离精确解，从而导致测试失败。这展示了有限元公式对正确坐标转换的敏感性。实现将通过构建所需的节点/单元几何结构，根据工况规范组装 $\\mathbf{K}$，对系统进行分区，求解 $\\mathbf{u}_f$，并进行验证检查来继续。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the truss patch test suite and print results.\n    \"\"\"\n\n    def get_geometry(include_diagonals, L):\n        \"\"\"\n        Generates the nodal coordinates and element connectivity for the 3x3 grid.\n        \n        Args:\n            include_diagonals (bool): If True, adds diagonal elements to the mesh.\n            L (float): The spacing between nodes in the grid.\n        \n        Returns:\n            tuple: A tuple containing:\n                - nodes (np.ndarray): An array of node coordinates (N x 2).\n                - elements (list): A list of tuples, where each tuple contains the \n                                   indices of the two nodes connected by an element.\n        \"\"\"\n        # Node coordinates for a 3x3 grid, numbered 0-8 row by row from bottom-left\n        nodes = np.array([[i * L, j * L] for j in range(3) for i in range(3)])\n\n        # Element connectivity\n        elements = []\n        # Horizontal elements\n        for j in range(3):\n            for i in range(2):\n                elements.append((j * 3 + i, j * 3 + i + 1))\n        # Vertical elements\n        for i in range(3):\n            for j in range(2):\n                elements.append((j * 3 + i, (j + 1) * 3 + i))\n\n        if include_diagonals:\n            # Diagonal elements for each 1x1 cell\n            for j in range(2):\n                for i in range(2):\n                    n_bl = j * 3 + i        # bottom-left node of cell\n                    n_br = j * 3 + i + 1    # bottom-right\n                    n_tl = (j + 1) * 3 + i  # top-left\n                    n_tr = (j + 1) * 3 + i + 1 # top-right\n                    elements.append((n_bl, n_tr)) # up-sloping diagonal\n                    elements.append((n_br, n_tl)) # down-sloping diagonal\n        \n        return nodes, elements\n\n    def run_patch_test(include_diagonals, use_buggy_transform, epsilon_0):\n        \"\"\"\n        Performs a single patch test case.\n        \n        Args:\n            include_diagonals (bool): Flag to include diagonal elements.\n            use_buggy_transform (bool): Flag to use the erroneous transformation matrix.\n            epsilon_0 (float): The magnitude of the uniform isotropic strain.\n            \n        Returns:\n            bool: True if the patch test passes, False otherwise.\n        \"\"\"\n        # Material and geometric properties\n        L = 1.0  # meters\n        E = 210.0e9  # Pascals\n        A = 1.0e-4   # square meters\n\n        nodes, elements = get_geometry(include_diagonals, L)\n        num_nodes = len(nodes)\n        num_dofs = 2 * num_nodes\n        K = np.zeros((num_dofs, num_dofs))\n\n        # Assemble global stiffness matrix K\n        for n1_idx, n2_idx in elements:\n            p1 = nodes[n1_idx]\n            p2 = nodes[n2_idx]\n            \n            delta = p2 - p1\n            length = np.linalg.norm(delta)\n            \n            c = delta[0] / length\n            s = delta[1] / length\n\n            if use_buggy_transform:\n                c_trans, s_trans = s, c # Intentionally swapped cosines\n            else:\n                c_trans, s_trans = c, s\n\n            k_const = E * A / length\n            \n            c2 = c_trans**2\n            s2 = s_trans**2\n            cs = c_trans * s_trans\n\n            k_e_4x4 = k_const * np.array([\n                [ c2,  cs, -c2, -cs],\n                [ cs,  s2, -cs, -s2],\n                [-c2, -cs,  c2,  cs],\n                [-cs, -s2,  cs,  s2]\n            ])\n\n            dof_indices = [2 * n1_idx, 2 * n1_idx + 1, 2 * n2_idx, 2 * n2_idx + 1]\n            K[np.ix_(dof_indices, dof_indices)] += k_e_4x4\n\n        # Apply boundary conditions and partition the system\n        free_node_idx = 4  # The central node at (L, L)\n        free_dofs = [2 * free_node_idx, 2 * free_node_idx + 1]\n        all_dofs = list(range(num_dofs))\n        prescribed_dofs = sorted(list(set(all_dofs) - set(free_dofs)))\n\n        # Construct vector of prescribed displacements u_p\n        u_p = np.zeros(len(prescribed_dofs))\n        for i, dof in enumerate(prescribed_dofs):\n            node_idx = dof // 2\n            dof_type = dof % 2  # 0 for x-dof, 1 for y-dof\n            u_p[i] = epsilon_0 * nodes[node_idx, dof_type]\n        \n        # Extract submatrices for solving the free DOFs\n        K_ff = K[np.ix_(free_dofs, free_dofs)]\n        K_fp = K[np.ix_(free_dofs, prescribed_dofs)]\n        \n        # Solve for free displacements u_f\n        # System: K_ff * u_f = -K_fp * u_p\n        rhs = -K_fp @ u_p\n        \n        # Check if K_ff is singular, although not expected for these structures\n        if np.linalg.cond(K_ff) > 1/np.finfo(K_ff.dtype).eps:\n             return False # Unstable structure case\n        \n        u_f = np.linalg.solve(K_ff, rhs)\n\n        # --- Validation Phase ---\n\n        # 1. Displacement reproduction check\n        node_f_coords = nodes[free_node_idx]\n        u_f_exact = epsilon_0 * node_f_coords\n        \n        disp_err_norm = np.linalg.norm(u_f - u_f_exact)\n        u_f_exact_norm = np.linalg.norm(u_f_exact)\n        disp_tol = max(1.0e-10 * u_f_exact_norm, 1.0e-12)\n        \n        disp_check_passed = disp_err_norm = disp_tol\n\n        # 2. Uniform axial strain check\n        # Reconstruct the full displacement vector u to calculate strains\n        u_full = np.zeros(num_dofs)\n        u_full[free_dofs] = u_f\n        u_full[prescribed_dofs] = u_p\n        \n        strain_check_passed = True\n        for n1_idx, n2_idx in elements:\n            p1 = nodes[n1_idx]\n            p2 = nodes[n2_idx]\n            \n            delta = p2 - p1\n            length = np.linalg.norm(delta)\n            \n            # Strain calculation must always use the correct direction cosines\n            c_correct = delta[0] / length\n            s_correct = delta[1] / length\n            \n            u1_vec = u_full[2 * n1_idx : 2 * n1_idx + 2]\n            u2_vec = u_full[2 * n2_idx : 2 * n2_idx + 2]\n            \n            delta_u = u2_vec - u1_vec\n            n_vec = np.array([c_correct, s_correct])\n            \n            # Strain is projection of relative displacement onto element axis, divided by length\n            epsilon_e = (n_vec @ delta_u) / length\n            \n            strain_err = abs(epsilon_e - epsilon_0)\n            strain_tol = max(1.0e-10 * abs(epsilon_0), 1.0e-12)\n            \n            if strain_err > strain_tol:\n                strain_check_passed = False\n                break  # Fail fast\n                \n        return disp_check_passed and strain_check_passed\n\n    # Define the test suite\n    test_cases = [\n        # Case 1: Diagonals, correct transform, non-zero strain\n        {'include_diagonals': True, 'use_buggy_transform': False, 'epsilon_0': 1.0e-4},\n        # Case 2: Diagonals, erroneous transform, non-zero strain\n        {'include_diagonals': True, 'use_buggy_transform': True, 'epsilon_0': 1.0e-4},\n        # Case 3: No diagonals, correct transform, non-zero strain\n        {'include_diagonals': False, 'use_buggy_transform': False, 'epsilon_0': 5.0e-5},\n        # Case 4: Diagonals, correct transform, zero strain\n        {'include_diagonals': True, 'use_buggy_transform': False, 'epsilon_0': 0.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_patch_test(**params)\n        results.append(result)\n\n    # Format and print the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3603016"}]}