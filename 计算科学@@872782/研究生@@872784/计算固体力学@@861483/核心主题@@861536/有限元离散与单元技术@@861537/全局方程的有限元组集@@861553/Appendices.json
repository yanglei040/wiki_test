{"hands_on_practices": [{"introduction": "在实际的工程模型中，我们常常需要连接具有不匹配网格的多个部件，这使得节点间的直接连接变得不可能。本练习将探讨如何在强制施加此类界面上的运动学连续性的同时，组装全局方程组。您将通过实现并比较两种基本技术——约束消除法和拉格朗日乘子法，来深入理解它们对最终系统矩阵的对称性和条件数等属性产生的影响 [@problem_id:3565247]。", "problem": "您的任务是为一个在一维线性弹性杆上跨界面存在不匹配网格的系统，实现全局方程组的组装，并使用多点约束 (MPC) 在界面上强制施加连续性。您必须实现两种方法：通过线性变量替换的约束消元法，以及通过拉格朗日乘子的强制施加法。您将比较所得系统矩阵的条件数和对称性，并验证约束的满足情况。最终输出必须由一个完整的、可运行的程序生成。\n\n物理设置为一根一维杆，占据区间 $[0,L]$，其中 $L$ 的单位为米。该杆是均匀的，具有杨氏模量 $E$ 和横截面积 $A$（两者均为常数，其中 $E$ 的单位为帕斯卡， $A$ 的单位为 $\\mathrm{m}^2$）。不存在体力。在 $x=L$ 处施加一个末端牵引力 $T$（单位为牛顿）。左端 $x=0$ 处被夹紧，具有本质边界条件 $u(0)=0$，其中 $u(x)$ 表示轴向位移，单位为米。\n\n您将在重叠的子域上构建两个独立的有限元网格，这两个子域在一个单一的界面位置 $x=\\xi$ 处相遇，但在该界面处不共享节点。左子网格跨越 $[0,\\xi]$，节点为 $x_{0}^{L}, x_{1}^{L}, \\dots, x_{n_{L}-1}^{L}$，使得 $x_{0}^{L}=0$ 且 $x_{n_{L}-1}^{L}\\xi$。右子网格跨越 $[\\xi,L]$，节点为 $x_{0}^{R}, x_{1}^{R}, \\dots, x_{n_{R}-1}^{R}$，使得 $x_{0}^{R}=\\xi$ 且 $x_{n_{R}-1}^{R}=L$。使用线性的二节点单元，将左右网格独立地组装成子域刚度矩阵和子域载荷向量。在没有约束的情况下，全局系统是块对角的。界面连续性约束通过将右侧界面自由度（“从自由度”）与包围 $x=\\xi$ 的两个相邻左侧自由度（“主自由度”）的插值联系起来强制施加，具体如下所述。这是一个多点约束，因为从位移等于多个主位移的线性组合。\n\n您必须从第一性原理出发，推导并实现这两种方法：\n\n1. 基本原理：一维线性弹性的总势能为\n$$\n\\Pi(u) = \\int_{0}^{L} \\frac{E A}{2} \\left(\\frac{du}{dx}\\right)^{2} \\, dx - T \\, u(L),\n$$\n具有本质边界条件 $u(0)=0$。弱形式源于最小势能原理：在满足本质边界条件的容许位移中，找到使 $\\Pi(u)$ 最小化的 $u$。对于有限元法 (FEM)，在每个单元上使用线性形函数，并通过对单元贡献求和来组装全局刚度矩阵。长度为 $h$ 的区间的单元刚度为\n$$\nk^{e} = \\frac{E A}{h}\n\\begin{bmatrix}\n1  -1 \\\\\n-1  1\n\\end{bmatrix},\n$$\n唯一的外部载荷是在 $x=L$ 处施加的末端牵引力 $T$，它对右子网格最右侧的自由度有贡献。\n\n2. 多点约束定义：设 $x=\\xi$ 严格位于某个左网格单元内部（其节点位于 $x_{i}^{L}$ 和 $x_{i+1}^{L}$），或与某个左网格节点 $x_{i}^{L}$ 重合，对于某个索引 $i$。右侧界面节点为 $x_{0}^{R}=\\xi$，其未知位移为 $u_{0}^{R}$。定义来自左侧主自由度的插值权重，使得\n$$\nu_{0}^{R} = w_{1}\\, u_{i}^{L} + w_{2}\\, u_{i+1}^{L},\n$$\n其中，对于严格位于内部的情况，\n$$\nw_{1} = \\frac{x_{i+1}^{L}-\\xi}{x_{i+1}^{L}-x_{i}^{L}}, \\quad\nw_{2} = \\frac{\\xi - x_{i}^{L}}{x_{i+1}^{L}-x_{i}^{L}},\n$$\n对于重合情况 $\\xi = x_{i}^{L}$，取 $w_{1}=1$ 和 $w_{2}=0$。该约束可以写为\n$$\n\\mathbf{C}\\, \\mathbf{x} = 0,\n$$\n其中 $\\mathbf{x}$ 是在通过消元法施加 $u(0)=0$ 后，将左、右自由度堆叠而成的向量，而 $\\mathbf{C}$ 具有相应的系数。\n\n3. 通过变量替换的约束消元法：引入一个线性变换 $\\mathbf{x} = \\mathbf{T} \\mathbf{y}$，该变换消除了从变量，以主变量表示，其中 $\\mathbf{y}$ 是简化的独立变量集。推导并组装修正后的简化系统\n$$\n\\mathbf{K}_{\\mathrm{elim}} = \\mathbf{T}^{\\top} \\mathbf{K} \\mathbf{T}, \\quad\n\\mathbf{f}_{\\mathrm{elim}} = \\mathbf{T}^{\\top} \\mathbf{f},\n$$\n然后求解 $\\mathbf{y}$ 并恢复 $\\mathbf{x}$。通过计算残差 $r_{\\mathrm{elim}} = \\lVert \\mathbf{C}\\, \\mathbf{x} \\rVert_{\\infty}$（单位为米）来验证 MPC 是否被满足。\n\n4. 拉格朗日乘子法：组装带有拉格朗日乘子 (LM) 的鞍点系统，\n$$\n\\begin{bmatrix}\n\\mathbf{K}  \\mathbf{C}^{\\top} \\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\\n0\n\\end{bmatrix},\n$$\n并求解 $\\mathbf{x}$ 和 $\\lambda$。验证 MPC 残差 $r_{\\mathrm{LM}} = \\lVert \\mathbf{C}\\, \\mathbf{x} \\rVert_{\\infty}$（单位为米）。\n\n您必须为每种方法计算：\n- 矩阵的 2-范数条件数，针对 $\\mathbf{K}_{\\mathrm{elim}}$ 和增广鞍点矩阵，量化为\n$$\n\\kappa_{2}(\\mathbf{A}) = \\frac{\\sigma_{\\max}(\\mathbf{A})}{\\sigma_{\\min}(\\mathbf{A})},\n$$\n其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 是 $\\mathbf{A}$ 的最大和最小奇异值。\n- 一个布尔值，指示每个矩阵是否对称，通过检查 $\\mathbf{A}-\\mathbf{A}^{\\top}$ 的最大绝对值项是否小于一个容差（使用数值容差 $10^{-12}$）。\n\n单位：\n- 位移 $u$ 和残差 $r_{\\mathrm{elim}}$、 $r_{\\mathrm{LM}}$ 必须以米为单位。\n- 材料参数 $E$ 的单位为帕斯卡， $A$ 的单位为 $\\mathrm{m}^{2}$，牵引力 $T$ 的单位为牛顿，长度单位为米。\n- 条件数是无量纲的。\n\n为以下测试套件实现上述内容，每个套件由 $(E,A,T,L,\\xi,\\text{左侧节点},\\text{右侧节点})$ 定义：\n- 测试用例 1（理想情况，不匹配网格，内部插值）：\n  - $E = 2.10 \\times 10^{11}$, $A = 1.0 \\times 10^{-4}$, $T = 1.0 \\times 10^{3}$, $L = 1.0$, $\\xi = 0.45$,\n  - 左侧节点: $[0.0, 0.3, 0.6]$,\n  - 右侧节点: $[0.45, 0.75, 1.0]$.\n- 测试用例 2（边界插值，$\\xi$ 与一个左侧节点重合）：\n  - $E = 1.90 \\times 10^{11}$, $A = 1.2 \\times 10^{-4}$, $T = 5.0 \\times 10^{2}$, $L = 1.0$, $\\xi = 0.5$,\n  - 左侧节点: $[0.0, 0.5, 0.8]$,\n  - 右侧节点: $[0.5, 0.9, 1.0]$.\n- 测试用例 3（通过在界面附近使用一个非常小的左侧单元来制造病态条件）：\n  - $E = 2.00 \\times 10^{11}$, $A = 0.8 \\times 10^{-4}$, $T = 8.0 \\times 10^{2}$, $L = 1.0$, $\\xi = 0.55$,\n  - 左侧节点: $[0.0, 0.49, 0.49001, 0.7]$,\n  - 右侧节点: $[0.55, 0.8, 1.0]$.\n\n算法要求：\n- 使用线性的二节点单元刚度公式和源自弱形式的标准有限元组装方法来组装子域刚度矩阵，除了上面给出的单元形式外，不使用任何快捷公式。\n- 在施加 MPC 之前，在全局组装层面通过消元法强制施加 $u(0)=0$。\n- 对于约束消元法，构建显式变换矩阵 $\\mathbf{T}$，实现关系 $u_{0}^{R} = w_{1}\\, u_{i}^{L} + w_{2}\\, u_{i+1}^{L}$，并对自由度到简化变量进行适当的映射。\n- 对于拉格朗日乘子法，按规定组装增广鞍点系统。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出一个包含六个条目的列表：\n$[\\kappa_{2}(\\mathbf{K}_{\\mathrm{elim}}), \\kappa_{2}(\\mathbf{K}_{\\mathrm{aug}}), \\text{is\\_sym\\_elim}, \\text{is\\_sym\\_aug}, r_{\\mathrm{elim}}, r_{\\mathrm{LM}}]$,\n其中 $\\text{is\\_sym\\_elim}$ 和 $\\text{is\\_sym\\_aug}$ 是布尔值。条件数使用保留六位小数的浮点数，残差使用保留十二位小数的浮点数。因此，最终输出是一个包含三个列表的列表，每个测试用例一个，例如 $[[\\dots],[\\dots],[\\dots]]$。", "solution": "本任务旨在实现并分析两种用于在两个一维有限元网格之间的非协调界面上强制施加连续性的方法：约束消元法和拉格朗日乘子法。分析过程涉及为每种方法组装系统矩阵，求解得到的线性系统，并评估矩阵属性（条件数、对称性）和约束满足情况。\n\n物理系统是一根长度为 $L$、杨氏模量为 $E$、横截面积为 $A$ 的一维线性弹性杆。它在 $x=0$ 处固定（$u(0)=0$），并在 $x=L$ 处受到一个点牵引力 $T$。总势能泛函由下式给出\n$$\n\\Pi(u) = \\int_{0}^{L} \\frac{E A}{2} \\left(\\frac{du}{dx}\\right)^{2} \\, dx - T \\, u(L)\n$$\n有限元法 (FEM) 将此问题离散化。我们使用二节点线性单元。长度为 $h$ 的单元的刚度矩阵为\n$$\nk^{e} = \\frac{E A}{h}\n\\begin{bmatrix}\n1  -1 \\\\\n-1  1\n\\end{bmatrix}\n$$\n该域被离散为两个子网格，它们在一个不共享节点的界面 $x=\\xi$ 处相遇。一个左网格覆盖从 $x=0$ 到并越过 $\\xi$ 的区域，一个右网格从 $x=\\xi$ 开始延伸到 $x=L$。这导致一个块对角的无约束方程组，形式为 $\\mathbf{K}\\mathbf{x} = \\mathbf{f}$，其中 $\\mathbf{K} = \\text{diag}(\\mathbf{K}^L, \\mathbf{K}^R)$，这是在通过移除相应自由度 (DOF) 来强制施加本质边界条件 $u(0)=0$ 之后得到的。\n\n通过多点约束 (MPC) 在界面 $x=\\xi$ 处强制施加连续性。右网格第一个节点在 $x_0^R = \\xi$ 处的位移 $u_0^R$ 被约束为包围 $\\xi$ 的左网格两个节点 $u_i^L$ 和 $u_{i+1}^L$ 位移的插值。约束方程为\n$$\nu_0^R = w_1 u_i^L + w_2 u_{i+1}^L\n$$\n其中 $w_1 = \\frac{x_{i+1}^{L}-\\xi}{x_{i+1}^{L}-x_{i}^{L}}$ 和 $w_2 = \\frac{\\xi - x_{i}^{L}}{x_{i+1}^{L}-x_{i}^{L}}$ 是线性插值权重。在 $\\xi$ 与左网格节点 $x_i^L$ 重合的情况下，权重为 $w_1=1$ 和 $w_2=0$，这实际上是将从自由度绑定到单个主自由度。此 MPC 可以用矩阵形式表示为 $\\mathbf{C}\\mathbf{x} = \\mathbf{0}$，其中 $\\mathbf{C}$ 是一个单行矩阵，$\\mathbf{x}$ 是所有活动自由度的向量。\n\n我们现在将详细介绍整合此约束的两种方法。\n\n**1. 通过变量替换的约束消元法**\n\n此方法从方程组中消除从属（从）自由度，从而得到一个仅用独立自由度表示的、更小的、稠密的系统。我们定义一个线性变换 $\\mathbf{x} = \\mathbf{T}\\mathbf{y}$，其中 $\\mathbf{y}$ 是简化的独立自由度向量，$\\mathbf{T}$ 是一个变换矩阵。$\\mathbf{y}$ 的维度比 $\\mathbf{x}$ 的维度小一。\n\n向量 $\\mathbf{y}$ 可以选择为从向量 $\\mathbf{x}$ 中移除从自由度后得到的向量。设从自由度为 $x_s = u_0^R$，主自由度为 $x_{m1} = u_i^L$ 和 $x_{m2} = u_{i+1}^L$。约束为 $x_s = w_1 x_{m1} + w_2 x_{m2}$。大小为 $N \\times (N-1)$ 的变换矩阵 $\\mathbf{T}$（其中 $N$ 是 $\\mathbf{x}$ 的大小）构造如下：\n- $\\mathbf{T}$ 的列将 $\\mathbf{y}$ 中的独立自由度映射回 $\\mathbf{x}$ 中的完整自由度集。\n- 对于一个与原始自由度 $x_k$（其中 $k$ 不是从自由度索引）对应的独立自由度 $y_j$，$\\mathbf{T}$ 的第 $j$ 列将是一个在位置 $k$ 处为 1 的基本向量。\n- $\\mathbf{T}$ 中对应于从自由度 $x_s$ 的行是根据约束方程构造的。由于主自由度 $x_{m1}$ 和 $x_{m2}$ 本身是存在于 $\\mathbf{y}$ 中的独立自由度（在某个位置 $j_{m1}$ 和 $j_{m2}$），$\\mathbf{T}$ 的从自由度行将在列 $j_{m1}$ 和 $j_{m2}$ 处分别包含条目 $w_1$ 和 $w_2$。\n\n将 $\\mathbf{x} = \\mathbf{T}\\mathbf{y}$ 代入势能泛函 $\\Pi(\\mathbf{x}) = \\frac{1}{2}\\mathbf{x}^\\top\\mathbf{K}\\mathbf{x} - \\mathbf{x}^\\top\\mathbf{f}$ 得到 $\\Pi(\\mathbf{y}) = \\frac{1}{2}(\\mathbf{T}\\mathbf{y})^\\top\\mathbf{K}(\\mathbf{T}\\mathbf{y}) - (\\mathbf{T}\\mathbf{y})^\\top\\mathbf{f}$。关于 $\\mathbf{y}$ 进行最小化，得到简化系统：\n$$\n\\mathbf{K}_{\\mathrm{elim}}\\mathbf{y} = \\mathbf{f}_{\\mathrm{elim}}, \\quad \\text{其中} \\quad \\mathbf{K}_{\\mathrm{elim}} = \\mathbf{T}^\\top\\mathbf{K}\\mathbf{T} \\quad \\text{和} \\quad \\mathbf{f}_{\\mathrm{elim}} = \\mathbf{T}^\\top\\mathbf{f}\n$$\n原始刚度矩阵 $\\mathbf{K}$ 是对称且正定的（因为刚体模态已被移除）。变换后的矩阵 $\\mathbf{K}_{\\mathrm{elim}}$ 也将是对称且正定的。在求解出 $\\mathbf{y}$ 后，通过 $\\mathbf{x} = \\mathbf{T}\\mathbf{y}$ 恢复完整的位移向量。\n\n**2. 拉格朗日乘子法**\n\n此方法通过引入一个新变量，即拉格朗日乘子 $\\lambda$，来增广方程组，该乘子代表强制施加 MPC 所需的约束力。寻求增广拉格朗日泛函 $\\mathcal{L}(\\mathbf{x}, \\lambda) = \\Pi(\\mathbf{x}) + \\lambda^\\top(\\mathbf{C}\\mathbf{x})$ 的驻点。将关于 $\\mathbf{x}$ 和 $\\lambda$ 的变分设为零，得到鞍点系统：\n$$\n\\begin{bmatrix}\n\\mathbf{K}  \\mathbf{C}^{\\top} \\\\\n\\mathbf{C}  \\mathbf{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{x} \\\\\n\\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f} \\\\\n0\n\\end{bmatrix}\n$$\n这个增广系统比原始的无约束系统更大。增广矩阵 $\\mathbf{K}_{\\mathrm{aug}}$ 在构造上是对称的。然而，由于对角线上的零块，它不是正定的，这可能导致其条件数高于原始的定矩阵 $\\mathbf{K}$ 或简化矩阵 $\\mathbf{K}_{\\mathrm{elim}}$。该方法的优点是不需要显式构造变换矩阵 $\\mathbf{T}$，并且它直接计算约束力（即拉格朗日乘子 $\\lambda$）。\n\n**实现步骤**\n对于每个测试用例，执行以下过程：\n1.  子域组装：对于左、右网格，组装单元刚度矩阵 $k^e$ 并将其贡献加总到子域矩阵 $\\mathbf{K}^L_{\\text{full}}$ 和 $\\mathbf{K}^R_{\\text{full}}$ 中。\n2.  全局组装：形成块对角无约束全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{f}$。通过移除 $\\mathbf{K}^L_{\\text{full}}$ 的第一行和第一列来施加本质边界条件 $u(0)=0$。将牵引载荷 $T$ 施加到全局力向量 $\\mathbf{f}$ 的最后一个条目上。\n3.  MPC 定义：识别左网格上的主自由度和右网格上的从自由度。计算插值权重 $w_1, w_2$ 并构建约束矩阵 $\\mathbf{C}$。\n4.  求解（消元法）：构造变换矩阵 $\\mathbf{T}$。形成并求解简化系统 $\\mathbf{K}_{\\mathrm{elim}}\\mathbf{y} = \\mathbf{f}_{\\mathrm{elim}}$。恢复完整解 $\\mathbf{x}_{\\mathrm{elim}}$。\n5.  求解（拉格朗日乘子法）：形成并求解增广系统，得到包含 $\\mathbf{x}_{\\mathrm{LM}}$ 和 $\\lambda$ 的解向量。\n6.  分析：对于两种方法，使用其奇异值计算系统矩阵的 2-范数条件数 $\\kappa_2$（$\\kappa_2(\\mathbf{A}) = \\sigma_{\\max}/\\sigma_{\\min}$），检查对称性，并计算约束满足情况的残差 $r = \\lVert \\mathbf{C}\\mathbf{x} \\rVert_{\\infty}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_subsystem(nodes, E, A):\n    \"\"\"\n    Assembles the stiffness matrix for a 1D submesh using linear elements.\n    \"\"\"\n    n_nodes = len(nodes)\n    K_sub = np.zeros((n_nodes, n_nodes))\n    \n    for i in range(n_nodes - 1):\n        h = nodes[i+1] - nodes[i]\n        if h == 0:\n            raise ValueError(\"Element length must be positive.\")\n        k_e_val = E * A / h\n        k_e = k_e_val * np.array([[1, -1], [-1, 1]])\n        \n        # Assembly (scatter-add)\n        K_sub[i:i+2, i:i+2] += k_e\n        \n    return K_sub\n\ndef solve_one_case(E, A, T, L, xi, left_nodes, right_nodes):\n    \"\"\"\n    Solves a single test case for the 1D bar problem with non-matching meshes.\n    \"\"\"\n    left_nodes = np.array(left_nodes, dtype=float)\n    right_nodes = np.array(right_nodes, dtype=float)\n\n    # 1. Assemble subdomain systems\n    K_L_full = assemble_subsystem(left_nodes, E, A)\n    K_R_full = assemble_subsystem(right_nodes, E, A)\n\n    # 2. Apply u(0)=0 and assemble global unconstrained system\n    # Eliminate the first DOF of the left mesh\n    K_L = K_L_full[1:, 1:]\n    n_L_active = K_L.shape[0]\n    n_R_active = K_R_full.shape[0]\n    N = n_L_active + n_R_active\n\n    K = np.zeros((N, N))\n    f = np.zeros(N)\n\n    K[:n_L_active, :n_L_active] = K_L\n    K[n_L_active:, n_L_active:] = K_R_full\n    \n    # Apply traction T at x=L (last DOF of the right mesh)\n    f[-1] = T\n\n    # 3. Define the Multipoint Constraint (MPC)\n    # Find master nodes bracketing xi on the left mesh\n    master_idx_i = -1\n    for i in range(len(left_nodes) - 1):\n        if left_nodes[i] = xi = left_nodes[i+1]:\n            master_idx_i = i\n            break\n    if master_idx_i == -1:\n        raise ValueError(\"xi is not within any left mesh element.\")\n\n    # Calculate interpolation weights\n    if np.isclose(xi, left_nodes[master_idx_i]):\n        w1, w2 = 1.0, 0.0\n    else:\n        h_master = left_nodes[master_idx_i+1] - left_nodes[master_idx_i]\n        w1 = (left_nodes[master_idx_i+1] - xi) / h_master\n        w2 = (xi - left_nodes[master_idx_i]) / h_master\n\n    # Identify global indices of slave and master DOFs\n    # Slave: u_0^R, which is the first DOF of the right system\n    idx_slave = n_L_active\n    \n    # Masters: u_i^L and u_{i+1}^L\n    # Remember u(0)=0 is eliminated, so global index for u_k^L is k-1\n    idx_m1 = master_idx_i - 1 if master_idx_i > 0 else -1\n    idx_m2 = master_idx_i # Corresponds to u_{i+1}^L\n\n    # Constraint matrix C for C*x = 0\n    C = np.zeros((1, N))\n    C[0, idx_slave] = 1.0\n    if idx_m1 != -1: # Master u_i^L is an active DOF\n        C[0, idx_m1] -= w1\n    # Master u_{i+1}^L is always an active DOF in our setup\n    C[0, idx_m2] -= w2\n\n    # 4. Method 1: Constraint Elimination\n    T_mat = np.zeros((N, N - 1))\n    \n    # Identity mapping for DOFs before slave\n    T_mat[:idx_slave, :idx_slave] = np.eye(idx_slave)\n    # Identity mapping for DOFs after slave\n    T_mat[idx_slave + 1:, idx_slave:] = np.eye(N - 1 - idx_slave)\n    \n    # Slave row of T\n    # y_j maps to x_j for j  idx_slave\n    # So we can use master indices directly for y\n    if idx_m1 != -1:\n        T_mat[idx_slave, idx_m1] = w1\n    T_mat[idx_slave, idx_m2] = w2\n    \n    K_elim = T_mat.T @ K @ T_mat\n    f_elim = T_mat.T @ f\n    \n    y = np.linalg.solve(K_elim, f_elim)\n    x_elim = T_mat @ y\n    \n    svd_elim = np.linalg.svd(K_elim, compute_uv=False)\n    # Handle potential singularity for ill-conditioned cases\n    kappa_elim = svd_elim[0] / svd_elim[-1] if svd_elim[-1] > 1e-15 else np.inf\n    \n    is_sym_elim = np.max(np.abs(K_elim - K_elim.T))  1e-12\n    r_elim = np.linalg.norm(C @ x_elim, ord=np.inf)\n\n    # 5. Method 2: Lagrange Multipliers\n    K_aug = np.zeros((N + 1, N + 1))\n    K_aug[:N, :N] = K\n    K_aug[:N, N] = C.T.flatten()\n    K_aug[N, :N] = C.flatten()\n\n    f_aug = np.zeros(N + 1)\n    f_aug[:N] = f\n    \n    sol_aug = np.linalg.solve(K_aug, f_aug)\n    x_lm = sol_aug[:N]\n\n    svd_aug = np.linalg.svd(K_aug, compute_uv=False)\n    kappa_aug = svd_aug[0] / svd_aug[-1] if svd_aug[-1] > 1e-15 else np.inf\n\n    is_sym_aug = np.max(np.abs(K_aug - K_aug.T))  1e-12\n    r_lm = np.linalg.norm(C @ x_lm, ord=np.inf)\n\n    return [kappa_elim, kappa_aug, is_sym_elim, is_sym_aug, r_elim, r_lm]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2.10e11, 1.0e-4, 1.0e3, 1.0, 0.45, [0.0, 0.3, 0.6], [0.45, 0.75, 1.0]),\n        (1.90e11, 1.2e-4, 5.0e2, 1.0, 0.5, [0.0, 0.5, 0.8], [0.5, 0.9, 1.0]),\n        (2.00e11, 0.8e-4, 8.0e2, 1.0, 0.55, [0.0, 0.49, 0.49001, 0.7], [0.55, 0.8, 1.0])\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_one_case(*case)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_cases = []\n    for case_res in all_results:\n        k_elim, k_aug, s_elim, s_aug, r_elim, r_lm = case_res\n        formatted_case_str = (\n            f\"[{k_elim:.6f},\"\n            f\"{k_aug:.6f},\"\n            f\"{str(s_elim).lower()},\"\n            f\"{str(s_aug).lower()},\"\n            f\"{r_elim:.12f},\"\n            f\"{r_lm:.12f}]\"\n        )\n        formatted_cases.append(formatted_case_str)\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```", "id": "3565247"}, {"introduction": "从静态分析转向动态分析会引入惯性效应，这要求我们在组装刚度矩阵的同时，也要组装质量矩阵。本实践聚焦于瞬态动力学全局方程的组装，并探讨时间积分算法的选择如何影响基本守恒定律。通过实施和比较一种能量-动量守恒格式与标准的 Newmark 方法，您将深入了解在组装层面的算法选择是如何确保动态模拟的物理保真度和长期稳定性的 [@problem_id:3565225]。", "problem": "考虑一根一维线性弹性杆，在无外力作用下进行自由振动。该杆具有均匀的长度 $L$、横截面积 $A$、密度 $\\rho$ 和杨氏模量 $E$。使用有限元方法将该杆离散化，采用 $n_{\\mathrm{el}}$ 个双节点线性单元和 $n_{\\mathrm{n}} = n_{\\mathrm{el}} + 1$ 个节点。设全局节点位移向量为 $u \\in \\mathbb{R}^{n_{\\mathrm{n}}}$，全局节点速度向量为 $v \\in \\mathbb{R}^{n_{\\mathrm{n}}}$，全局节点动量向量为 $p = M v \\in \\mathbb{R}^{n_{\\mathrm{n}}}$，其中 $M \\in \\mathbb{R}^{n_{\\mathrm{n}} \\times n_{\\mathrm{n}}}$ 是由单元贡献组装的一致质量矩阵，$K \\in \\mathbb{R}^{n_{\\mathrm{n}} \\times n_{\\mathrm{n}}}$ 是由单元贡献组装的刚度矩阵。内力由二次应变能势导出，得到半离散运动方程\n$$\nM \\, \\dot{v}(t) + K \\, u(t) = 0, \\quad \\dot{u}(t) = v(t),\n$$\n这些方程遵循 Hamilton 原理，其拉格朗日量为 $L = T - V$，其中 $T = \\tfrac{1}{2} v^{\\top} M v$ 且 $V = \\tfrac{1}{2} u^{\\top} K u$。杆的两端都是自由的，因此平移不变性成立，刚度矩阵满足 $K \\, \\mathbf{1} = 0$，其中 $\\mathbf{1}$ 是全一向量，这反映了刚体模态。\n\n从这些基本原理（Hamilton 原理和线性弹性杆的有限元组装）出发，设计两种隐式时间积分方法，在一个大小为 $\\Delta t$ 的时间步长内，从 $(u_n, v_n)$推进到 $(u_{n+1}, v_{n+1})$：\n\n1. 一种能量-动量守恒方法，通过将隐式中点法则应用于一阶 Hamilton 系统 $(\\dot{u}, \\dot{p})$ 获得，其中 $p = M v$，Hamiltonian 量是二次能量 $H(u, v) = \\tfrac{1}{2} v^{\\top} M v + \\tfrac{1}{2} u^{\\top} K u$。该方法必须在离散意义上保持与 Noether 定理相关的不变量，即时间平移（总能量）和空间平移（总线性动量 $P = \\mathbf{1}^{\\top} p$）对应的不变量。在全局层面组装相应的算法切线，用于在每个时间步中求解 $u_{n+1}$。\n\n2. 标准的 Newmark 族方法，专用于平均加速度参数 $\\beta = \\tfrac{1}{4}$ 和 $\\gamma = \\tfrac{1}{2}$，阻尼为零，应用于二阶形式 $M a + K u = 0$，其中 $a = \\dot{v}$。组装相应的全局算法切线，用于在每个时间步中求解 $u_{n+1}$。\n\n您必须：\n- 从第一性原理出发，推导两种方法的离散更新方程，以及在离散方程的 Newton 解法中出现的全局算法切线。第1项中的离散方法必须体现离散 Noether 性质：精确守恒线性 Hamilton 系统的二次不变量。\n- 使用长度为 $h = L / n_{\\mathrm{el}}$ 的双节点线性单元实现 $M$ 和 $K$ 的有限元组装，单元一致质量矩阵为 $M_e = \\rho A h \\, \\tfrac{1}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}$，单元刚度矩阵为 $K_e = \\dfrac{E A}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$，并通过标准连接关系组装成全局矩阵。\n- 对于每种方法，从指定的初始条件 $(u_0, v_0)$ 开始，对系统进行给定时间步数的积分，并在每个步骤计算总能量 $H(u, v)$（单位：焦耳）和总线性动量 $P = \\mathbf{1}^{\\top} M v$（单位：千克·米/秒）。报告在整个模拟过程中，能量和动量相对于其初始值的最大绝对漂移。\n\n定义以下参数集测试套件，全部采用国际单位制（SI）。对于每种情况，使用均匀时间步长 $\\Delta t$ 模拟系统 $N$ 步，并计算所要求的量：\n\n- 情况1（一般自由振动，理想路径）：\n  - $L = 1.0$ 米, $A = 0.01$ 平方米, $\\rho = 7800.0$ 千克/立方米, $E = 210 \\times 10^{9}$ 帕斯卡, $n_{\\mathrm{el}} = 6$, $\\Delta t = 7.5 \\times 10^{-6}$ 秒, $N = 1000$。\n  - 初始条件：$u_0 = 0$，在节点位置 $x_i$ 处定义的 $v_0$ 为 $v_0(x_i) = 0.01 \\, \\sin\\!\\left(\\pi x_i / L\\right)$ 米/秒。\n\n- 情况2（刚体运动，用于探测动量守恒）：\n  - $L = 2.0$ 米, $A = 0.015$ 平方米, $\\rho = 8050.0$ 千克/立方米, $E = 200 \\times 10^{9}$ 帕斯卡, $n_{\\mathrm{el}} = 8$, $\\Delta t = 1.0 \\times 10^{-4}$ 秒, $N = 500$。\n  - 初始条件：$u_0 = 0$，$v_0(x_i) = 0.05$ 米/秒，在所有节点上均匀分布。\n\n- 情况3（边缘情况，使用粗糙时间步来考察能量行为）：\n  - $L = 0.5$ 米, $A = 0.008$ 平方米, $\\rho = 8800.0$ 千克/立方米, $E = 190 \\times 10^{9}$ 帕斯卡, $n_{\\mathrm{el}} = 2$, $\\Delta t = 1.0 \\times 10^{-3}$ 秒, $N = 200$。\n  - 初始条件：$u_0(x_i) = 1.0 \\times 10^{-4} \\, \\sin\\!\\left(2 \\pi x_i / L\\right)$ 米，$v_0 = 0$。\n\n对于每种情况，您必须计算并返回两种方法的以下值：\n- 能量-动量中点法的 $N$ 步内最大绝对能量漂移（单位：焦耳）。\n- Newmark 平均加速度法的 $N$ 步内最大绝对能量漂移（单位：焦耳）。\n- 能量-动量中点法的 $N$ 步内最大绝对动量漂移（单位：千克·米/秒）。\n- Newmark 平均加速度法的 $N$ 步内最大绝对动量漂移（单位：千克·米/秒）。\n- 一个布尔值，断言能量-动量中点法的算法切线是否为对称正定。\n- 一个布尔值，断言 Newmark 平均加速度法的算法切线是否为对称正定。\n\n所有浮点数必须按规定以 SI 单位表示，并四舍五入到六位小数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个条目对应一个测试用例，并且本身是按确切顺序排列的列表\n$$\n[\\mathrm{energy\\_drift\\_EM}, \\mathrm{energy\\_drift\\_NM}, \\mathrm{momentum\\_drift\\_EM}, \\mathrm{momentum\\_drift\\_NM}, \\mathrm{SPD\\_EM}, \\mathrm{SPD\\_NM}],\n$$\n总体输出为\n$$\n\\big[\\,[\\cdot], [\\cdot], [\\cdot]\\,\\big].\n$$\n例如，如果有三种情况，输出格式必须为\n$$\n[[a_1,b_1,c_1,d_1,e_1,f_1],[a_2,b_2,c_2,d_2,e_2,f_2],[a_3,b_3,c_3,d_3,e_3,f_3]]\n$$\n的形式。", "solution": "## 问题验证\n\n所提供的问题陈述经过了仔细验证，并被确定为 **有效**。它在计算弹性动力学的既定框架内具有科学依据，所有必要的数据和条件都明确指定，问题表述良好，语言客观。该任务要求对一维线性弹性系统推导、实现和比较两种标准的隐式时间积分方案——能量-动量守恒中点法则和 Newmark 平均加速度法。从第一性原理出发的推导以及随后发现这两种方法对于此特定线性问题在代数上是相同的，这构成了该任务的一个关键教学见解，而非缺陷。该问题并非微不足道，它对理论理解和实现技巧都提供了严格的考验。\n\n## 理论推导与实现策略\n\n该问题要求为一维线性弹性杆的半离散运动方程设计和分析两种隐式时间积分方案：\n$$\nM \\ddot{u}(t) + K u(t) = 0\n$$\n其中 $M$ 和 $K$ 分别是全局一致质量矩阵和刚度矩阵，$u(t)$ 是节点位移向量。\n\n### 有限元组装\n\n全局矩阵 $M$ 和 $K$ 由单元级贡献组装而成。对于具有 $n_{\\mathrm{el}}$ 个长度为 $h = L/n_{\\mathrm{el}}$ 的单元的均匀离散化，每个单元 $e$ 连接两个节点。单元质量矩阵 $M_e$ 和单元刚度矩阵 $K_e$ 由下式给出：\n$$\nM_e = \\frac{\\rho A h}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}, \\quad K_e = \\frac{E A}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n这些单元矩阵根据单元连接关系被系统地添加到全局矩阵 $M \\in \\mathbb{R}^{n_{\\mathrm{n}} \\times n_{\\mathrm{n}}}$ 和 $K \\in \\mathbb{R}^{n_{\\mathrm{n}} \\times n_{\\mathrm{n}}}$ 中。最终的全局质量矩阵 $M$ 是对称正定（SPD）的。由于自由-自由边界条件引入了刚体平移模态，全局刚度矩阵 $K$ 是对称半正定（SPSD）的。该模态对应于 $K$ 的零空间，由全一向量 $\\mathbf{1}$ 张成，满足 $K\\mathbf{1}=0$。\n\n### 方法1：能量-动量（EM）守恒中点法则\n\n该方法通过将隐式中点法则应用于运动方程的一阶 Hamilton 表述来推导。状态变量是广义坐标 $u$ 及其共轭动量 $p = Mv$。代表总能量的 Hamiltonian 量 $H(u,p)$ 为：\n$$\nH(u,p) = \\frac{1}{2} p^{\\top} M^{-1} p + \\frac{1}{2} u^{\\top} K u\n$$\n一阶运动方程是 Hamilton 方程：\n$$\n\\dot{u} = \\frac{\\partial H}{\\partial p} = M^{-1}p = v, \\quad \\dot{p} = -\\frac{\\partial H}{\\partial u} = -Ku\n$$\n在从 $t_n$ 到 $t_{n+1}$ 的时间步长 $\\Delta t$ 上应用隐式中点法则：\n$$\nu_{n+1} - u_n = \\Delta t \\, \\dot{u}_{n+1/2} = \\Delta t \\, v_{n+1/2}\n$$\n$$\np_{n+1} - p_n = \\Delta t \\, \\dot{p}_{n+1/2} = -\\Delta t \\, K u_{n+1/2}\n$$\n其中中点值定义为平均值：$u_{n+1/2} = \\frac{u_n+u_{n+1}}{2}$ 和 $v_{n+1/2} = \\frac{v_n+v_{n+1}}{2}$。代入这些平均值和关系式 $p=Mv$ 可得：\n$$\nu_{n+1} - u_n = \\frac{\\Delta t}{2} (v_n + v_{n+1}) \\quad (1)\n$$\n$$\nMv_{n+1} - Mv_n = -\\frac{\\Delta t}{2} K (u_n + u_{n+1}) \\quad (2)\n$$\n从(1)式中，我们可以用未知位移 $u_{n+1}$ 表示未知速度 $v_{n+1}$：\n$$\nv_{n+1} = \\frac{2}{\\Delta t}(u_{n+1} - u_n) - v_n\n$$\n将此式代入(2)式并重新整理各项以分离出 $u_{n+1}$，得到最终的线性系统：\n$$\n\\left(M + \\frac{\\Delta t^2}{4} K\\right) u_{n+1} = \\left(M - \\frac{\\Delta t^2}{4} K\\right) u_n + \\Delta t M v_n\n$$\n矩阵 $A_{\\mathrm{EM}} = M + \\frac{\\Delta t^2}{4} K$ 是**算法切线**。由于 $M$ 是对称正定（SPD），而 $K$ 是对称半正定（SPSD），它们的正加权和 $A_{\\mathrm{EM}}$ 是对称正定的。该方法作为应用于二次 Hamiltonian 量的辛积分器，能够精确保持系统的任何二次不变量。对于此线性问题，总能量 $H(u,v) = \\frac{1}{2}v^{\\top}Mv + \\frac{1}{2}u^{\\top}Ku$ 是二次的，因此是守恒的。总线性动量 $P = \\mathbf{1}^{\\top}p = \\mathbf{1}^{\\top}Mv$ 也是守恒的。这是因为其时间导数为 $\\dot{P} = \\mathbf{1}^{\\top}\\dot{p} = -\\mathbf{1}^{\\top}Ku$，对于自由-自由杆，$\\mathbf{1}^{\\top}K = (K\\mathbf{1})^{\\top} = 0^{\\top} = 0$。动量的离散更新规则 $P_{n+1} - P_n = -\\Delta t \\mathbf{1}^{\\top} K u_{n+1/2} = 0$ 证实了精确的离散动量守恒。\n\n### 方法2：Newmark 平均加速度法\n\n该方法应用于二阶方程 $M\\ddot{u} + Ku = 0$。对于平均加速度法，Newmark 参数为 $\\gamma = 1/2$ 和 $\\beta=1/4$。位移和速度的更新规则是：\n$$\nu_{n+1} = u_n + \\Delta t \\, v_n + \\frac{\\Delta t^2}{4} (a_n + a_{n+1}) \\quad (3)\n$$\n$$\nv_{n+1} = v_n + \\frac{\\Delta t}{2}(a_n + a_{n+1}) \\quad (4)\n$$\n其中 $a_n$ 和 $a_{n+1}$ 是在 $t_n$ 和 $t_{n+1}$ 时刻的加速度。运动方程必须在 $t_{n+1}$ 时刻成立：\n$$\nM a_{n+1} + K u_{n+1} = 0\n$$\n从(3)式中，我们用未知位移 $u_{n+1}$ 表示未知加速度 $a_{n+1}$：\n$$\na_{n+1} = \\frac{4}{\\Delta t^2}\\left(u_{n+1} - u_n - \\Delta t \\, v_n\\right) - a_n\n$$\n将此式代入 $t_{n+1}$ 时刻的运动方程并重新整理，得到关于 $u_{n+1}$ 的系统：\n$$\n\\left(\\frac{4}{\\Delta t^2}M + K\\right)u_{n+1} = M\\left(\\frac{4}{\\Delta t^2}u_n + \\frac{4}{\\Delta t}v_n + a_n\\right)\n$$\n矩阵 $A_{\\mathrm{NM}} = \\frac{4}{\\Delta t^2}M + K$ 是**算法切线**。与 $A_{\\mathrm{EM}}$ 一样，该矩阵也是对称正定的。\n\n### 线性系统下两种方法的等价性\n\n直接比较表明，对于这个线性问题，所推导的两种方法在代数上是完全相同的。将 $Ma_n = -Ku_n$ 代入 Newmark 系统的右侧可得：\n$$\n\\left(\\frac{4}{\\Delta t^2}M + K\\right)u_{n+1} = \\frac{4}{\\Delta t^2}M u_n + \\frac{4}{\\Delta t}M v_n - K u_n\n$$\n将整个方程乘以 $\\frac{\\Delta t^2}{4}$，可以恢复与能量-动量方法完全相同的系统：\n$$\n\\left(M + \\frac{\\Delta t^2}{4}K\\right)u_{n+1} = M u_n + \\Delta t M v_n - \\frac{\\Delta t^2}{4} K u_n = \\left(M - \\frac{\\Delta t^2}{4}K\\right) u_n + \\Delta t M v_n\n$$\n速度更新规则也可以被证明是相同的。因此，对于这个线性系统，两种方法会产生相同的 $(u, v)$ 数值轨迹，并将表现出相同（理论上为零）的能量和动量漂移，任何观察到的非零漂移仅可归因于浮点运算。\n\n### 实现与分析\n\n每个测试用例的实现遵循以下步骤：\n1. **组装**：从单元矩阵组装全局矩阵 $M$ 和 $K$。\n2. **初始化**：设置初始条件 $u_0$ 和 $v_0$。计算初始能量 $H_0$ 和动量 $P_0$。\n3. **时间步进**：一个循环将系统推进 $N$ 步。在每个步骤中，构建算法切线矩阵和右侧向量，求解关于 $u_{n+1}$ 的线性系统，并更新速度 $v_{n+1}$。计算并存储能量 $H_{n+1}$ 和动量 $P_{n+1}$。\n4. **分析**：最大绝对能量漂移为 $\\max_{n=1..N} |H_n - H_0|$，最大绝对动量漂移为 $\\max_{n=1..N} |P_n - P_0|$。算法切线的对称正定（SPD）属性通过数值方法进行验证。对称性通过 `np.allclose(A, A.T)` 检查，正定性通过确保所有特征值（通过 `np.linalg.eigvalsh` 计算）均为正来确认。由于两个切线矩阵互为正标量倍数，它们的对称正定属性是相同的。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve\n\ndef assemble_matrices(L, A, rho, E, n_el):\n    \"\"\"\n    Assembles the global consistent mass and stiffness matrices for a 1D bar.\n    \"\"\"\n    n_n = n_el + 1\n    h = L / n_el\n    M = np.zeros((n_n, n_n))\n    K = np.zeros((n_n, n_n))\n\n    m_e_factor = rho * A * h / 6.0\n    M_e = m_e_factor * np.array([[2, 1], [1, 2]])\n\n    k_e_factor = E * A / h\n    K_e = k_e_factor * np.array([[1, -1], [-1, 1]])\n\n    for i in range(n_el):\n        nodes = [i, i + 1]\n        M[np.ix_(nodes, nodes)] += M_e\n        K[np.ix_(nodes, nodes)] += K_e\n\n    return M, K\n\ndef is_spd(matrix):\n    \"\"\"\n    Checks if a matrix is symmetric positive definite (SPD).\n    \"\"\"\n    if not np.allclose(matrix, matrix.T):\n        return False\n    try:\n        eigenvalues = np.linalg.eigvalsh(matrix)\n        # Check if all eigenvalues are strictly positive, using a small tolerance for robustness.\n        return np.all(eigenvalues > 1e-12)\n    except np.linalg.LinAlgError:\n        return False\n\ndef run_simulation(u0, v0, M, K, dt, N, method_name):\n    \"\"\"\n    Runs the time integration for a given method and returns simulation results.\n    The two methods requested are algebraically identical for this linear problem.\n    This function implements their common update rule.\n    \"\"\"\n    n_n = M.shape[0]\n    u, v = np.copy(u0), np.copy(v0)\n    \n    # Algorithmic tangent for the Energy-Momentum (EM) method\n    tangent_em = M + (dt**2 / 4) * K\n    tangent_is_spd_em = is_spd(tangent_em)\n\n    # Algorithmic tangent for the Newmark method\n    tangent_nm = (4 / dt**2) * M + K\n    tangent_is_spd_nm = is_spd(tangent_nm)\n    \n    # We use the EM tangent formulation for the linear solve. As shown in the\n    # derivation, this is equivalent to using the Newmark tangent formulation.\n    A_solve = tangent_em\n\n    energy_history = np.zeros(N + 1)\n    momentum_history = np.zeros(N + 1)\n    ones = np.ones(n_n)\n\n    # Calculate initial state\n    energy_history[0] = 0.5 * v.T @ M @ v + 0.5 * u.T @ K @ u\n    momentum_history[0] = ones.T @ M @ v\n\n    for i in range(N):\n        # Form RHS vector based on the EM formulation\n        rhs = (M - (dt**2 / 4) * K) @ u + dt * M @ v\n        \n        # Solve for the new displacement u_{n+1}\n        # 'assume_a=pos' indicates that A_solve is positive definite, enabling a faster solver.\n        u_new = solve(A_solve, rhs, assume_a='pos')\n\n        # Update velocity using the common update rule\n        v_new = (2 / dt) * (u_new - u) - v\n        \n        u, v = u_new, v_new\n\n        # Calculate and store energy and momentum for the new state\n        energy_history[i + 1] = 0.5 * v.T @ M @ v + 0.5 * u.T @ K @ u\n        momentum_history[i + 1] = ones.T @ M @ v\n    \n    max_energy_drift = np.max(np.abs(energy_history - energy_history[0]))\n    max_momentum_drift = np.max(np.abs(momentum_history - momentum_history[0]))\n    \n    if method_name == 'EM':\n      return max_energy_drift, max_momentum_drift, tangent_is_spd_em\n    else: # Newmark\n      return max_energy_drift, max_momentum_drift, tangent_is_spd_nm\n\ndef solve_all_cases():\n    \"\"\"\n    Defines test cases, runs simulations for each, and formats the output.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": 1.0, \"A\": 0.01, \"rho\": 7800.0, \"E\": 210e9, \n            \"n_el\": 6, \"dt\": 7.5e-6, \"N\": 1000,\n            \"u0_func\": lambda x, L: 0.0,\n            \"v0_func\": lambda x, L: 0.01 * np.sin(np.pi * x / L)\n        },\n        {\n            \"L\": 2.0, \"A\": 0.015, \"rho\": 8050.0, \"E\": 200e9, \n            \"n_el\": 8, \"dt\": 1.0e-4, \"N\": 500,\n            \"u0_func\": lambda x, L: 0.0,\n            \"v0_func\": lambda x, L: 0.05\n        },\n        {\n            \"L\": 0.5, \"A\": 0.008, \"rho\": 8800.0, \"E\": 190e9, \n            \"n_el\": 2, \"dt\": 1.0e-3, \"N\": 200,\n            \"u0_func\": lambda x, L: 1.0e-4 * np.sin(2 * np.pi * x / L),\n            \"v0_func\": lambda x, L: 0.0\n        }\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        L, A, rho, E = case[\"L\"], case[\"A\"], case[\"rho\"], case[\"E\"]\n        n_el, dt, N = case[\"n_el\"], case[\"dt\"], case[\"N\"]\n        n_n = n_el + 1\n        \n        M, K = assemble_matrices(L, A, rho, E, n_el)\n        \n        x_nodes = np.linspace(0, L, n_n)\n        u0 = np.array([case[\"u0_func\"](x, L) for x in x_nodes])\n        v0 = np.array([case[\"v0_func\"](x, L) if callable(case[\"v0_func\"]) else case[\"v0_func\"] for x in x_nodes])\n\n        # Since the methods are algebraically identical for this linear problem,\n        # their numerical results for drift will be identical.\n        # We run the simulation once and report the results for both.\n        \n        # Energy-Momentum Method anaylsis\n        energy_drift_em, momentum_drift_em, spd_em = run_simulation(u0, v0, M, K, dt, N, 'EM')\n        \n        # Newmark Method analysis\n        energy_drift_nm, momentum_drift_nm, spd_nm = run_simulation(u0, v0, M, K, dt, N, 'Newmark')\n\n        case_results = [\n            f\"{energy_drift_em:.6f}\",\n            f\"{energy_drift_nm:.6f}\",\n            f\"{momentum_drift_em:.6f}\",\n            f\"{momentum_drift_nm:.6f}\",\n            str(spd_em).lower(),\n            str(spd_nm).lower()\n        ]\n        all_results_str.append(f\"[{','.join(case_results)}]\")\n\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve_all_cases()\n```", "id": "3565225"}, {"introduction": "对弹塑性等非线性材料的分析是计算固体力学的基石，它通常依赖于牛顿-拉弗森法等迭代求解方案。实现二次收敛速度的关键在于正确地实现和组装“一致切线矩阵”。本练习提供了一个动手实践的工作流程，通过将组装的全局切线矩阵的作用与全局残差向量的数值扰动进行比较，来验证您所实现的材料模型及其切线矩阵的正确性，这是开发稳健的非线性有限元程序的关键技能 [@problem_id:3560905]。", "problem": "设计并实现一个验证工作流，用于一维小应变杆中算法弹塑性一致切线算子，使用有限元法（FEM）。其目标是通过比较全局残差的方向有限差分与由组装的切线矩阵得出的线性预测，来验证全局切线矩阵的组装。所有量均为无量纲。\n\n考虑一根长度为 $L$、均匀横截面积为 $A$ 的一维杆，由 $n_{e}$ 个线性两节点单元组成，节点坐标为 $x \\in [0,L]$。令 $u$ 表示全局节点位移向量。在左端施加狄利克雷边界条件 $u(0)=0$，并在右端施加指定的牵引力 $T$，使得最后一个节点上的总节点力为 $F = T A$。对于每个单元 $e$，其内力贡献为\n$$\nf^{\\text{int}}_{e}(u) \\;=\\; \\int_{\\Omega_e} B^{\\mathsf{T}}(x)\\, \\sigma(\\varepsilon(x))\\, A \\, \\mathrm{d}x,\n$$\n单元切线矩阵为\n$$\nK^{\\text{tan}}_{e}(u) \\;=\\; \\int_{\\Omega_e} B^{\\mathsf{T}}(x)\\, \\mathbb{C}^{\\text{alg}}(\\varepsilon(x))\\, B(x)\\, A \\, \\mathrm{d}x,\n$$\n其中 $B$ 是线性杆的应变-位移矩阵，$\\varepsilon(x)$ 是轴向应变，$\\sigma$ 是小应变下的柯西应力，$\\mathbb{C}^{\\text{alg}}$ 是由本构更新提供的一维算法一致切线模量。对于长度为 $L_e$ 的线性两节点单元，$B$ 是常数，$B=[-1/L_{e}, \\, 1/L_{e}]$，因此上述积分可简化为使用单个积分点的单元级封闭形式：\n$$\nf^{\\text{int}}_{e}(u) \\;=\\; B^{\\mathsf{T}} \\, \\sigma(\\varepsilon_e) \\, A \\, L_e, \n\\qquad\nK^{\\text{tan}}_{e}(u) \\;=\\; B^{\\mathsf{T}} \\, \\mathbb{C}^{\\text{alg}}(\\varepsilon_e) \\, B \\, A \\, L_e,\n$$\n其中 $\\varepsilon_e = B u_e$，$u_e$ 是单元节点向量。\n\n使用具有线性各向同性硬化的单轴弹塑性材料。令 $E$ 为杨氏模量，$H$ 为塑性模量，$\\sigma_{y0}$ 为初始屈服应力，$\\varepsilon^{p}$ 为塑性应变，$\\alpha$ 为累积塑性应变。屈服函数为\n$$\n\\phi(\\sigma,\\alpha) \\;=\\; |\\sigma| - \\big(\\sigma_{y0} + H \\alpha\\big) \\;\\le\\; 0.\n$$\n流动法则是关联的，在一维情况下，塑性应变率为 $\\dot{\\varepsilon}^{p} = \\dot{\\gamma}\\, \\mathrm{sign}(\\sigma)$，各向同性硬化为 $\\dot{\\alpha} = \\dot{\\gamma}$，其中 $\\dot{\\gamma}\\ge 0$ 是塑性乘子率。使用小应变运动学和加性应变分解 $\\varepsilon = \\varepsilon^{e} + \\varepsilon^{p}$，其中 $\\sigma = E \\varepsilon^{e}$。假设从零状态 $\\varepsilon^{p}_n=0, \\alpha_n=0$ 到当前状态只有一个加载增量。实现一个返回映射更新，对于给定的应变 $\\varepsilon$，该更新返回更新后的应力 $\\sigma$ 和算法一致切线模量 $\\mathbb{C}^{\\text{alg}} = \\partial \\sigma / \\partial \\varepsilon$。\n\n将全局残差定义为\n$$\nR(u) \\;=\\; f^{\\text{int}}(u) - f^{\\text{ext}},\n$$\n其中 $f^{\\text{ext}}$ 仅包含施加在右端的节点力 $F$，其余位置为零。令 $K(u)$ 为组装后的全局切线矩阵。为验证 $K(u)$，计算在自由度给定方向 $p$ 上残差方向变化的中心有限差分近似：\n$$\n\\Delta R_{\\text{FD}} \\;=\\; R\\big(u + \\epsilon\\, p\\big) - R\\big(u - \\epsilon\\, p\\big),\n$$\n并与线性预测进行比较\n$$\n\\Delta R_{\\text{lin}} \\;=\\; K(u)\\, (2 \\epsilon\\, p),\n$$\n其中 $\\epsilon$ 是一个小的扰动幅度。使用相对误差\n$$\ne \\;=\\; \\frac{\\left\\|\\Delta R_{\\text{FD}} - \\Delta R_{\\text{lin}}\\right\\|_{2}}{\\max\\!\\big(\\left\\|\\Delta R_{\\text{lin}}\\right\\|_{2}, \\tau\\big)},\n$$\n其中 $\\tau$ 是一个微小的正则化项，以避免除以零。\n\n对于下方的每个测试用例，构建一个平衡位移场 $u$，该位移场产生均匀的轴向应力 $\\sigma = F/A$，同时满足 $u(0)=0$。对于均质杆，这对应于均匀应变；对于具有单元级 $\\sigma_{y0}$ 的非均质杆，单元应变可能不同，但均匀应力得以保持。在所有情况下，每个单元使用单个高斯点进行积分。使用以下测试套件，所有用例中 $n_{e} = 2$，$A = 1$，$L = 1$，并且当材料非均质时，单元级 $\\sigma_{y0}$ 以列表形式指定：\n\n- 用例 1 (均质弹性): $E = 2\\times 10^{5}$，$H = 10^{3}$，$\\sigma_{y0} = 250$，$F = 100$。\n- 用例 2 (均质塑性): $E = 2\\times 10^{5}$，$H = 10^{3}$，$\\sigma_{y0} = 250$，$F = 500$。\n- 用例 3 (弱塑性，接近屈服): $E = 2\\times 10^{5}$，$H = 10^{3}$，$\\sigma_{y0} = 250$，$F = 255$。\n- 用例 4 (非均质混合响应): $E = 2\\times 10^{5}$，$H = 10^{3}$，$\\sigma_{y0} = [250,\\, 1000]$，$F = 500$。\n\n实现要求：\n\n- 从上述基本定义开始。为本构模型实现一个一维返回映射更新，对于给定的 $\\varepsilon$ 返回 $\\sigma$ 和 $\\mathbb{C}^{\\text{alg}}$。\n- 通过消除 $x=0$ 处的固定位移，为自由度组装 $R(u)$ 和 $K(u)$。\n- 对于每个用例，构建一个具有均匀应力 $\\sigma = F/A$ 的平衡位移场 $u$。对于均质杆，使用 $u(x) = \\varepsilon\\, x$，其中 $\\varepsilon$ 由本构关系确定。对于非均质杆，强制所有单元的 $\\sigma$ 均匀；对于单元 $e$，通过本构关系计算与均匀应力一致的单元应变 $\\varepsilon_e$，并对这些应变进行积分，从左到右构建连续的节点位移，同时满足 $u(0)=0$。\n- 对于每个用例，在自由度空间中使用固定的扰动幅度 $\\epsilon = 10^{-8}$ 和一个确定性的随机方向 $p$，每个用例使用固定的种子以确保结果可复现。使用 $\\tau = 10^{-14}$。\n- 角度单位不适用。没有物理单位；所有量均为无量纲。\n\n您的程序应生成单行输出，其中包含四个相对误差的结果，按用例顺序以逗号分隔的列表形式，并用方括号括起来，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_i$ 是一个浮点数。", "solution": "用户要求在一维有限元法（FEM）框架内，设计并实现一个针对弹塑性算法一致切线算子的验证流程。该验证基于比较全局残差向量变化的有限差分近似值与由组装的切线刚度矩阵得出的预测值。\n\n解决方案的结构如下：\n1.  **本构模型实现**：实现一个针对具有线性各向同性硬化的弹塑性模型的一维返回映射算法。该函数在给定总应变 $\\varepsilon$ 的情况下，返回更新后的应力 $\\sigma$ 和算法一致切线模量 $\\mathbb{C}^{\\text{alg}} = \\partial\\sigma/\\partial\\varepsilon$。\n2.  **平衡状态构建**：为每个测试用例构建一个平衡节点位移场 $u$。该场旨在在整个杆中产生均匀的轴向应力 $\\sigma = F/A$，并满足狄利克雷边界条件 $u(0)=0$。\n3.  **有限元组装**：创建函数以计算对全局内力向量和切线刚度矩阵的单元级贡献，并将它们组装成全局系统量。消除 $x=0$ 处的固定自由度，以处理自由度系统。\n4.  **验证工作流**：实现核心验证逻辑。这包括扰动平衡位移场，计算残差的有限差分，并将其与一致切线矩阵的线性预测进行比较。\n\n### 步骤 1：本构模型（一维返回映射）\n材料模型是具有线性各向同性硬化的单轴弹塑性。我们从一个无应力状态（$\\varepsilon^{p}_n=0, \\alpha_n=0$）开始。对于步骤 $n+1$ 的给定总应变 $\\varepsilon$：\n\n1.  **试探状态**：假设一个弹性试探步。试探应力为 $\\sigma^{\\text{trial}} = E \\varepsilon$。使用上一步的屈服应力来评估屈服面，由于 $\\alpha_n=0$，该屈服应力就是初始屈服应力 $\\sigma_{y0}$。试探屈服函数为 $\\phi^{\\text{trial}} = |\\sigma^{\\text{trial}}| - \\sigma_{y0}$。\n\n2.  **屈服检查**：\n    - 如果 $\\phi^{\\text{trial}} \\le 0$，则该步为弹性。应力为 $\\sigma = \\sigma^{\\text{trial}}$，切线模量为弹性模量 $\\mathbb{C}^{\\text{alg}} = E$。\n    - 如果 $\\phi^{\\text{trial}}  0$，则发生塑性流动。需要进行返回映射，将应力状态拉回到更新后的屈服面上。\n\n3.  **塑性修正**：对于此一维模型，塑性乘子增量 $\\Delta\\gamma$ 可由一致性条件 $\\phi_{n+1}=0$ 求得。这给出：\n    $$\n    \\Delta\\gamma = \\frac{\\phi^{\\text{trial}}}{E+H} = \\frac{|\\sigma^{\\text{trial}}| - \\sigma_{y0}}{E+H}\n    $$\n    然后，更新后的应力计算如下：\n    $$\n    \\sigma = \\sigma^{\\text{trial}} - E\\,\\Delta\\gamma\\,\\mathrm{sign}(\\sigma^{\\text{trial}})\n    $$\n    算法一致切线模量，即更新后的应力相对于总应变的确切导数，是：\n    $$\n    \\mathbb{C}^{\\text{alg}} = \\frac{\\partial\\sigma}{\\partial\\varepsilon} = \\frac{EH}{E+H}\n    $$\n该函数构成了模拟的本构核心。\n\n### 步骤 2：平衡位移场的构建\n为了进行验证，我们在一个已知的平衡状态 $u$ 周围分析系统。该状态被构建为在所有单元上产生均匀应力 $\\sigma = F/A$。产生此应力所需的每个单元的应变 $\\varepsilon_e$ 从逆本构关系中计算得出：\n- 如果 $|\\sigma| \\le \\sigma_{y0,e}$ (弹性): $\\varepsilon_e = \\sigma/E$。\n- 如果 $|\\sigma|  \\sigma_{y0,e}$ (塑性): 总应变是弹性和塑性部分之和，$\\varepsilon_e = \\varepsilon^e + \\varepsilon^p$。弹性应变为 $\\varepsilon^e = \\sigma/E$。塑性应变的大小由硬化定律导出，即 $|\\varepsilon^p| = \\alpha = (|\\sigma| - \\sigma_{y0,e})/H$。将这些结合起来得到：\n  $$\n  \\varepsilon_e = \\mathrm{sign}(\\sigma) \\left( \\frac{|\\sigma|}{E} + \\frac{|\\sigma| - \\sigma_{y0,e}}{H} \\right)\n  $$\n在确定了单元应变 $\\{\\varepsilon_e\\}$ 后，通过从固定端 $u(0)=0$ 开始对应变进行积分来求得节点位移：\n$$\nu_0 = 0, \\quad u_{i+1} = u_i + \\varepsilon_i L_i\n$$\n其中 $L_i$ 是单元 $i$ 的长度。\n\n### 步骤 3：有限元组装和系统简化\n分析在一个离散化的杆上进行，该杆有 $n_e=2$ 个线性两节点单元。节点总数为 $n_n = 3$。\n\n- **单元级矩阵**：对于每个长度为 $L_e$、面积为 $A$ 的单元 $e$，应变-位移矩阵为 $B = [-1/L_e, 1/L_e]$。在单个积分点上，使用应变 $\\varepsilon_e = B u_e$ 计算单元内力向量和切线刚度矩阵：\n  $$\n  f^{\\text{int}}_{e} = B^{\\mathsf{T}} \\sigma(\\varepsilon_e) A L_e, \\qquad K^{\\text{tan}}_{e} = B^{\\mathsf{T}} \\mathbb{C}^{\\text{alg}}(\\varepsilon_e) B A L_e = \\frac{\\mathbb{C}^{\\text{alg}}_e A}{L_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n  $$\n- **全局组装**：将单元贡献组装成大小分别为 $3$ 和 $3 \\times 3$ 的全局矩阵 $f^{\\text{int}}(u)$ 和 $K(u)$。\n- **系统定义**：全局残差为 $R(u) = f^{\\text{int}}(u) - f^{\\text{ext}}$，其中 $f^{\\text{ext}} = [0, 0, F]^{\\mathsf{T}}$。通过从全局系统中消除第一行和第一列来施加狄利克雷边界条件 $u(0)=0$，从而得到一个针对自由度（节点 1 和 2）的简化系统。令这些为 $R_{\\text{free}}(u)$ 和 $K_{\\text{free}}(u)$。\n\n### 步骤 4：验证程序\n验证确认 $K_{\\text{free}}(u)$ 是 $R_{\\text{free}}(u)$ 的正确切线。使用中心有限差分来近似 $R_{\\text{free}}$ 沿着自由度（DOFs）空间中一个随机方向 $p$ 的方向导数。\n\n1.  **线性预测**：使用组装的切线矩阵来预测残差的变化：\n    $$\n    \\Delta R_{\\text{lin}} = K_{\\text{free}}(u) \\, (2 \\epsilon p)\n    $$\n2.  **有限差分近似**：在扰动后的位移状态 $u^+ = u + \\epsilon p$ 和 $u^- = u - \\epsilon p$ 下评估残差。将自由度的扰动向量 $p$ 嵌入到全局位移向量中（固定自由度对应位置为零）。\n    $$\n    \\Delta R_{\\text{FD}} = R_{\\text{free}}(u^+) - R_{\\text{free}}(u^-)\n    $$\n3.  **相对误差**：切线的准确性通过预测值和近似值之间的相对误差来量化：\n    $$\n    e = \\frac{\\left\\|\\Delta R_{\\text{FD}} - \\Delta R_{\\text{lin}}\\right\\|_{2}}{\\max(\\left\\|\\Delta R_{\\text{lin}}\\right\\|_{2}, \\tau)}\n    $$\n一个小的误差 $e$（接近机器精度）验证了所实现的切线模量 $\\mathbb{C}^{\\text{alg}}$ 确实与数值应力更新规则一致，并且全局组装是正确的。测试用例涵盖了弹性、塑性、近屈服和混合弹塑性响应，以确保其鲁棒性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that designs, implements, and runs the verification \n    workflow for the elasto-plastic consistent tangent operator.\n    \"\"\"\n    \n    # Global constants from the problem statement\n    L_TOTAL = 1.0\n    A_CROSS_SECTION = 1.0\n    N_ELEMENTS = 2\n    EPSILON = 1e-8\n    TAU = 1e-14\n\n    def update_material(strain, E, H, sigma_y0):\n        \"\"\"\n        Implements the 1D return mapping algorithm for linear isotropic hardening.\n\n        Args:\n            strain (float): Current total strain.\n            E (float): Young's modulus.\n            H (float): Plastic modulus.\n            sigma_y0 (float): Initial yield stress.\n\n        Returns:\n            tuple: (stress, algorithmic_tangent_modulus).\n        \"\"\"\n        if np.abs(strain)  1e-16: # Handle zero strain case to avoid division by zero\n            return 0.0, E\n\n        sigma_trial = E * strain\n        \n        # Previous state has alpha_n = 0, so current yield stress is sigma_y0\n        phi_trial = np.abs(sigma_trial) - sigma_y0\n\n        if phi_trial = 0:\n            # Elastic step\n            return sigma_trial, E\n        else:\n            # Plastic step\n            delta_gamma = phi_trial / (E + H)\n            stress = sigma_trial - E * delta_gamma * np.sign(sigma_trial)\n            C_alg = (E * H) / (E + H)\n            return stress, C_alg\n\n    def get_equilibrium_displacement(F, E, H, sigma_y0_list, L, A, n_e):\n        \"\"\"\n        Constructs the nodal displacement vector 'u' that corresponds to a\n        state of uniform axial stress sigma = F/A.\n        \"\"\"\n        sigma_target = F / A\n        element_strains = []\n\n        for e in range(n_e):\n            sigma_y0_e = sigma_y0_list[e]\n            \n            if np.abs(sigma_target) = sigma_y0_e:\n                strain_e = sigma_target / E\n            else:\n                strain_e = np.sign(sigma_target) * (\n                    np.abs(sigma_target) / E + (np.abs(sigma_target) - sigma_y0_e) / H\n                )\n            element_strains.append(strain_e)\n\n        n_nodes = n_e + 1\n        u_global = np.zeros(n_nodes)\n        node_coords = np.linspace(0, L, n_nodes)\n        \n        for e in range(n_e):\n            L_e = node_coords[e + 1] - node_coords[e]\n            u_global[e + 1] = u_global[e] + element_strains[e] * L_e\n            \n        return u_global\n\n    def compute_residual_and_tangent(u_global, E, H, sigma_y0_list, L, A, n_e, F):\n        \"\"\"\n        Assembles the global internal force and tangent matrix and returns the\n        components corresponding to the free degrees of freedom.\n        \"\"\"\n        n_nodes = n_e + 1\n        node_coords = np.linspace(0, L, n_nodes)\n\n        f_int_global = np.zeros(n_nodes)\n        K_tan_global = np.zeros((n_nodes, n_nodes))\n\n        for e in range(n_e):\n            i, j = e, e + 1\n            L_e = node_coords[j] - node_coords[i]\n            B = np.array([-1.0 / L_e, 1.0 / L_e])\n            u_e = u_global[[i, j]]\n            strain_e = B @ u_e\n            \n            sigma_e, C_alg_e = update_material(strain_e, E, H, sigma_y0_list[e])\n            \n            f_int_elem = B.T * sigma_e * A * L_e\n            K_tan_elem = C_alg_e * A / L_e * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n            f_int_global[i:j+1] += f_int_elem\n            K_tan_global[np.ix_([i, j], [i, j])] += K_tan_elem\n\n        f_ext_global = np.zeros(n_nodes)\n        f_ext_global[-1] = F\n        R_global = f_int_global - f_ext_global\n\n        free_dofs = slice(1, None)\n        R_free = R_global[free_dofs]\n        K_free = K_tan_global[free_dofs, free_dofs]\n        \n        return R_free, K_free\n\n    def run_verification(case_params):\n        \"\"\"\n        Runs the verification procedure for a single test case.\n        \"\"\"\n        E, H, sigma_y0_val, F, seed = case_params\n        \n        if isinstance(sigma_y0_val, list):\n            sigma_y0_list = sigma_y0_val\n        else:\n            sigma_y0_list = [sigma_y0_val] * N_ELEMENTS\n\n        u_eq = get_equilibrium_displacement(F, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS)\n        \n        n_free_dofs = N_ELEMENTS\n        rng = np.random.default_rng(seed)\n        p_free = rng.random(size=n_free_dofs)\n\n        _, K_free_eq = compute_residual_and_tangent(\n            u_eq, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS, F\n        )\n        delta_R_lin = K_free_eq @ (2 * EPSILON * p_free)\n\n        p_global = np.zeros(N_ELEMENTS + 1)\n        p_global[1:] = p_free\n        \n        u_plus = u_eq + EPSILON * p_global\n        u_minus = u_eq - EPSILON * p_global\n        \n        R_free_plus, _ = compute_residual_and_tangent(\n            u_plus, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS, F\n        )\n        R_free_minus, _ = compute_residual_and_tangent(\n            u_minus, E, H, sigma_y0_list, L_TOTAL, A_CROSS_SECTION, N_ELEMENTS, F\n        )\n        \n        delta_R_fd = R_free_plus - R_free_minus\n\n        norm_diff = np.linalg.norm(delta_R_fd - delta_R_lin)\n        norm_lin = np.linalg.norm(delta_R_lin)\n        \n        error = norm_diff / max(norm_lin, TAU)\n        \n        return error\n\n    test_cases = [\n        # (E, H, sigma_y0, F, seed)\n        (2e5, 1e3, 250.0, 100.0, 1), # Case 1: Homogeneous elastic\n        (2e5, 1e3, 250.0, 500.0, 2), # Case 2: Homogeneous plastic\n        (2e5, 1e3, 250.0, 255.0, 3), # Case 3: Weakly plastic, near yield\n        (2e5, 1e3, [250.0, 1000.0], 500.0, 4), # Case 4: Heterogeneous mixed\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_verification(case)\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3560905"}]}