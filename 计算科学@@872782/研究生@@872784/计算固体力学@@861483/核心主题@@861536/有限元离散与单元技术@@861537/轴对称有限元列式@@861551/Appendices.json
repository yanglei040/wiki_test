{"hands_on_practices": [{"introduction": "在理论上理解了环向应变在对称轴上的行为之后，我们接下来将探讨其在实际计算中的影响。在刚度矩阵的积分中，大数值项（来自应变-位移矩阵中的 $1/r$）与小数值项（来自积分权重中的 $r$）的乘积，会给靠近对称轴的单元带来数值不稳定的风险，导致刚度矩阵呈现病态。通过本练习 [@problem_id:3545417]，您将通过量化不同网格拓扑结构下的矩阵条件数，亲手诊断这一问题，并探索避免数值精度损失的实用策略。", "problem": "要求您在计算固体力学背景下，实现并比较两种邻近对称轴的轴对称子午面网格拓扑，并量化当最小半径接近轴时，组装后刚度矩阵的数值条件。推导必须从第一性原理开始，并对四节点双线性等参四边形单元使用一致的轴对称公式。比较应考虑楔形网格（节点位于轴上）和矩形网格（以一个严格为正的最小半径进行偏移）。您还必须实施一种映射策略，以避免在半径非常小时环向应变项中的塌陷。\n\n必须使用的基本理论基础包括以下内容，不提供任何简化公式：\n- 连续介质的牛顿运动定律以及关联内虚功与外虚功的虚功原理。\n- 轴对称中的小应变运动学，其中位移是子午面坐标的函数，且与周向坐标无关，环向应变根据轴对称性进行一致性定义。\n- 专用于轴对称条件的三维各向同性线性弹性（胡克定律），从杨氏模量和泊松比引入拉梅参数。\n- 四边形单元的等参映射、母坐标与物理坐标之间的雅可比变换，以及用于数值积分的高斯积分。\n\n您的程序必须：\n1. 在 $r$-$z$ 平面中构建具有相同轴向范围的两种双单元子午面网格。每个单元都是一个四节点双线性四边形。一个网格是邻近轴的楔形网格，其左侧节点列的 $r=0$。另一个是矩形网格，并从轴偏移，使其左侧节点列的 $r=r_{\\min}>0$。\n2. 使用一致的双线性等参单元公式组装全局轴对称刚度矩阵。应变-位移矩阵必须包括径向、轴向、环向和剪切分量；本构关系必须是轴对称条件下的各向同性三维线性弹性；积分权重必须按轴对称要求包含半径。积分必须在母坐标中使用 $2\\times 2$ 高斯积分。\n3. 施加本质边界条件以消除刚体模态并强制执行轴正则性。对于楔形网格，在轴上 $r=0$ 的节点处强制 $u_r=0$，并固定一个轴向位移以锚定解。对于矩形网格，在一个角节点处固定两个位移分量以消除刚体平移。\n4. 计算每种测试情况下缩减刚度矩阵（通过消除约束自由度施加边界条件后）的条件数，使用 $2$-范数定义，并以无单位浮点数形式返回结果。\n5. 实现两种映射策略来评估环向应变和轴对称积分权重中的半径：一种是标准的等参半径计算，另一种是带保护的半径下限映射，其中在这些项中使用的有效半径为 $r_{\\text{eff}}=\\max(r,r_{\\text{floor}})$，并指定 $r_{\\text{floor}}>0$。\n\n材料和几何数据（使用这些值）：\n- 杨氏模量 $E$（帕斯卡）为 $E=210\\times 10^{9}$。\n- 泊松比 $\\nu$ 为 $\\nu=0.3$。\n- 径向单元宽度 $h_r$（米）为 $h_r=1.0$。\n- 轴向单元高度 $h_z$（米）为 $h_z=1.0$。\n这些量用于构建有限元模型，但最终报告的条件数是无单位的。确保任何中间量都得到一致处理，并注意条件数与 $E$ 的整体缩放无关。\n\n为两种拓扑定义子午面网格如下：\n- 网格有两个沿轴向堆叠的单元，共享中间一排节点。节点形成一个 $2$ 列 $3$ 行的网格。对于楔形网格，左列半径为 $r=0$，右列半径为 $r=h_r$。对于矩形网格，左列半径为 $r=r_{\\min}$，右列半径为 $r=r_{\\min}+h_r$。各行的轴向坐标为 $z=0$、 $z=h_z$、 $z=2h_z$。\n- 单元由逆时针顺序的节点索引定义：左下、右下、右上、左上。\n\n边界条件：\n- 楔形网格：在每个 $r=0$ 的节点上强制 $u_r=0$，并在左下角节点处固定 $u_z=0$。\n- 矩形网格：在左下角节点处同时固定 $u_r=0$ 和 $u_z=0$。\n这些条件足以消除本次比较中获得良态刚度矩阵所需的刚体模态，并在楔形情况下强制轴正则性。\n\n测试套件：\n- 情况 1：矩形网格， $r_{\\min}=10^{-6}\\ \\text{m}$，标准映射，$r_{\\text{floor}}=0$。\n- 情况 2：矩形网格， $r_{\\min}=10^{-3}\\ \\text{m}$，标准映射，$r_{\\text{floor}}=0$。\n- 情况 3：矩形网格， $r_{\\min}=10^{-1}\\ \\text{m}$，标准映射，$r_{\\text{floor}}=0$。\n- 情况 4：楔形网格，几何 $r_{\\min}=0\\ \\text{m}$，标准映射，$r_{\\text{floor}}=0$。\n- 情况 5：矩形网格， $r_{\\min}=10^{-6}\\ \\text{m}$，下限映射，$r_{\\text{floor}}=10^{-3}\\ \\text{m}$。\n- 情况 6：楔形网格，几何 $r_{\\min}=0\\ \\text{m}$，下限映射，$r_{\\text{floor}}=10^{-3}\\ \\text{m}$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[result_1,result_2,result_3]$）。每个 $result_i$ 必须是对应测试用例的缩减刚度矩阵的浮点条件数。不应打印任何其他文本。这些值为无单位浮点数。\n\n该问题要求科学真实性和从第一性原理进行推导。您必须确保您的实现与轴对称公式一致，并且它解决了轴附近的数值行为。除了计算测试套件的条件数外，您的解决方案还应提出映射策略以避免塌陷，并根据上述基本定律和定义论证其物理和数值意义。", "solution": "该问题被验证为具有科学依据、良态且客观。它代表了计算固体力学中关于轴对称有限元分析中数值条件的一个标准研究。所有必要的数据和条件都已提供，没有矛盾或歧义。\n\n解决方案源于虚功原理，该原理指出，对于处于平衡状态的物体，对于任何运动学上容许的虚位移，内应力所做的虚功等于外力所做的虚功。对于连续介质，这表示为：\n$$\n\\delta W_{\\text{int}} = \\int_V \\delta\\boldsymbol{\\epsilon}^T \\boldsymbol{\\sigma} \\, dV = \\delta W_{\\text{ext}}\n$$\n在轴对称设置中，体积元为 $dV = 2\\pi r \\, dA$，其中 $A$ 是 $r$-$z$ 子午面中的面积。位移场纯粹是子午面坐标 $(r, z)$ 的函数，即 $\\mathbf{u}(r, z) = [u_r(r, z), u_z(r, z)]^T$。\n\n在小应变假设下，应变分量由向量 $\\boldsymbol{\\epsilon} = [\\epsilon_r, \\epsilon_z, \\epsilon_\\theta, \\gamma_{rz}]^T$ 给出，其中：\n$$\n\\epsilon_r = \\frac{\\partial u_r}{\\partial r}, \\quad \\epsilon_z = \\frac{\\partial u_z}{\\partial z}, \\quad \\epsilon_\\theta = \\frac{u_r}{r}, \\quad \\gamma_{rz} = \\frac{\\partial u_r}{\\partial z} + \\frac{\\partial u_z}{\\partial r}\n$$\n环向应变 $\\epsilon_\\theta$ 是轴对称的一个独特特征，当半径 $r$ 趋近于零时，它会成为数值困难的来源。\n\n材料被假定为各向同性和线性弹性，遵循胡克定律 $\\boldsymbol{\\sigma} = \\mathbf{C} \\boldsymbol{\\epsilon}$，其中 $\\boldsymbol{\\sigma} = [\\sigma_r, \\sigma_z, \\sigma_\\theta, \\tau_{rz}]^T$ 是应力向量。对于轴对称条件下的各向同性材料，本构矩阵 $\\mathbf{C}$ 为：\n$$\n\\mathbf{C} = \\frac{E}{(1+\\nu)(1-2\\nu)}\n\\begin{pmatrix}\n1-\\nu  & \\nu  & \\nu  & 0 \\\\\n\\nu  & 1-\\nu  & \\nu  & 0 \\\\\n\\nu  & \\nu  & 1-\\nu  & 0 \\\\\n0  & 0  & 0  & \\frac{1-2\\nu}{2}\n\\end{pmatrix}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。\n\n我们采用四节点双线性等参四边形单元。单元内的几何和位移场通过母坐标系 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 中的形函数 $N_i(\\xi, \\eta)$ 从节点值进行插值：\n$$\nr(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) r_i, \\quad z(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) z_i\n$$\n$$\nu_r(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{ri}, \\quad u_z(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) u_{zi}\n$$\n令 $\\mathbf{d}^e$ 为单元的 $8$ 个节点位移向量，我们可以将位移场写为 $\\mathbf{u} = \\mathbf{N}\\mathbf{d}^e$，应变场写为 $\\boldsymbol{\\epsilon} = \\mathbf{B}\\mathbf{d}^e$。应变-位移矩阵 $\\mathbf{B}$ 是根据应变定义和等参插值得出的。对于节点 $i$，其对 $\\mathbf{B}$ 的贡献是一个 $4 \\times 2$ 的子矩阵 $\\mathbf{B}_i$：\n$$\n\\mathbf{B}_i(\\xi, \\eta) = \\begin{pmatrix}\n\\frac{\\partial N_i}{\\partial r}  & 0 \\\\\n0  & \\frac{\\partial N_i}{\\partial z} \\\\\n\\frac{N_i}{r}  & 0 \\\\\n\\frac{\\partial N_i}{\\partial z}  & \\frac{\\partial N_i}{\\partial r}\n\\end{pmatrix}\n$$\n形函数的空间导数通过坐标变换的雅可比矩阵 $\\mathbf{J}$ 求得，其中 $\\left[\\frac{\\partial N_i}{\\partial r}, \\frac{\\partial N_i}{\\partial z}\\right]^T = \\mathbf{J}^{-T} \\left[\\frac{\\partial N_i}{\\partial \\xi}, \\frac{\\partial N_i}{\\partial \\eta}\\right]^T$。\n\n将有限元近似代入虚功原理，得到离散系统 $\\mathbf{K}\\mathbf{d} = \\mathbf{F}_{\\text{ext}}$，其中全局刚度矩阵 $\\mathbf{K}$ 由单元刚度矩阵 $\\mathbf{k}^e$ 组装而成：\n$$\n\\mathbf{k}^e = \\int_{A_e} \\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\, (2\\pi r) \\, dA = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}^T(\\xi, \\eta) \\mathbf{C} \\mathbf{B}(\\xi, \\eta) \\, (2\\pi r(\\xi, \\eta)) \\, \\det(\\mathbf{J}) \\, d\\xi \\, d\\eta\n$$\n该积分使用 $2 \\times 2$ 高斯积分进行数值计算。\n\n数值挑战来自于 $\\mathbf{B}$ 矩阵的环向应变分量中的 $1/r$ 项。当一个单元接近对称轴（$r \\to 0$）时，此项可能变得非常大。在 $\\mathbf{k}^e$ 的积分中，这个大项乘以积分权重因子 $r$，而后者变得非常小。一个非常大的项与一个非常小的项的乘积，即 $\\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\cdot r$，可能导致刚度矩阵的系数范围很宽。这会导致高的条件数，表明存在数值敏感性，并可能在解中产生大的误差。\n\n为研究此问题，实现了两种评估高斯点半径 $r$ 的策略：\n1.  **标准等参映射**：直接使用在高斯点处评估的半径 $r_g = r(\\xi_g, \\eta_g)$。对于靠近轴的情况，$r_g$ 可能非常小，导致上述的病态条件。这相当于设置半径下限 $r_{\\text{floor}} = 0$。\n2.  **带保护的下限映射**：引入一个最小有效半径 $r_{\\text{floor}} > 0$。在环向应变项（$1/r$）和积分权重（$2\\pi r$）中使用的有效半径为 $r_{\\text{eff}} = \\max(r_g, r_{\\text{floor}})$。此策略防止 $1/r$ 项变得奇异，并确保单元对刚度矩阵贡献一个最小的“体积”，从而对矩阵进行正则化并改善其条件数。在物理上，它模拟了一个薄壁管状单元而不是一个零半径线，这可能是一种更稳定的理想化。\n\n全局刚度矩阵由两个单元组装而成。然后通过消除与约束自由度相对应的行和列来施加本质边界条件。对于楔形网格，轴对称条件要求轴上（$r=0$）所有节点的 $u_r = 0$。对于矩形网格，它模拟一个具有小内半径的厚壁圆柱体，通过固定单个节点来消除刚体运动。然后使用 $2$-范数计算所得缩减刚度矩阵的条件数。对每个测试用例重复此过程，以量化网格拓扑和半径映射对数值稳定性的影响。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_constitutive_matrix(E, nu):\n    \"\"\"\n    Computes the axisymmetric constitutive matrix for an isotropic material.\n    \"\"\"\n    C = np.zeros((4, 4))\n    factor = E / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    \n    C[0, 0] = factor * (1.0 - nu)\n    C[0, 1] = factor * nu\n    C[0, 2] = factor * nu\n    \n    C[1, 0] = factor * nu\n    C[1, 1] = factor * (1.0 - nu)\n    C[1, 2] = factor * nu\n    \n    C[2, 0] = factor * nu\n    C[2, 1] = factor * nu\n    C[2, 2] = factor * (1.0 - nu)\n    \n    C[3, 3] = factor * (1.0 - 2.0 * nu) / 2.0\n    \n    return C\n\ndef get_shape_functions(xi, eta):\n    \"\"\"\n    Computes shape functions and their derivatives for a 4-node quad element.\n    \"\"\"\n    N = 0.25 * np.array([\n        (1.0 - xi) * (1.0 - eta),\n        (1.0 + xi) * (1.0 - eta),\n        (1.0 + xi) * (1.0 + eta),\n        (1.0 - xi) * (1.0 + eta)\n    ])\n    \n    dN_dxi = 0.25 * np.array([\n        -(1.0 - eta),\n        (1.0 - eta),\n        (1.0 + eta),\n        -(1.0 + eta)\n    ])\n    \n    dN_deta = 0.25 * np.array([\n        -(1.0 - xi),\n        -(1.0 + xi),\n        (1.0 + xi),\n        (1.0 - xi)\n    ])\n    \n    return N, dN_dxi, dN_deta\n\ndef get_element_stiffness(node_coords, C, r_floor):\n    \"\"\"\n    Computes the stiffness matrix for a single 4-node axisymmetric element.\n    \"\"\"\n    k_e = np.zeros((8, 8))\n    gauss_points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gauss_weights = [1.0, 1.0]\n\n    for i, xi in enumerate(gauss_points):\n        for j, eta in enumerate(gauss_weights):\n            N, dN_dxi, dN_deta = get_shape_functions(xi, eta)\n            \n            # Jacobian matrix\n            J = np.zeros((2, 2))\n            J[0, 0] = np.dot(dN_dxi, node_coords[:, 0])  # dr/dxi\n            J[0, 1] = np.dot(dN_dxi, node_coords[:, 1])  # dz/dxi\n            J[1, 0] = np.dot(dN_deta, node_coords[:, 0]) # dr/deta\n            J[1, 1] = np.dot(dN_deta, node_coords[:, 1]) # dz/deta\n            \n            det_J = np.linalg.det(J)\n            inv_J = np.linalg.inv(J)\n            \n            # Derivatives of shape functions w.r.t. physical coordinates (r, z)\n            dN_d_phys = inv_J @ np.array([dN_dxi, dN_deta])\n            dN_dr = dN_d_phys[0, :]\n            dN_dz = dN_d_phys[1, :]\n            \n            # Radius at the Gauss point\n            r_gp = np.dot(N, node_coords[:, 0])\n            \n            # Apply safeguarded radius floor mapping\n            r_eff = max(r_gp, r_floor)\n            \n            # Strain-displacement matrix B\n            B = np.zeros((4, 8))\n            for k in range(4):\n                B[0, 2*k]     = dN_dr[k]\n                B[1, 2*k+1]   = dN_dz[k]\n                if r_eff > 1e-15:  # Avoid division by zero\n                    B[2, 2*k] = N[k] / r_eff\n                B[3, 2*k]     = dN_dz[k]\n                B[3, 2*k+1]   = dN_dr[k]\n            \n            # Integrate to get stiffness matrix contribution\n            weight = gauss_weights[i] * gauss_weights[j]\n            k_e += (B.T @ C @ B) * (2.0 * np.pi * r_eff) * det_J * weight\n            \n    return k_e\n\ndef run_analysis(mesh_type, r_min, r_floor):\n    \"\"\"\n    Performs the full analysis for one test case.\n    \"\"\"\n    # 1. Define material and geometric properties\n    E = 210e9\n    nu = 0.3\n    h_r = 1.0\n    h_z = 1.0\n    C = get_constitutive_matrix(E, nu)\n\n    # 2. Define node coordinates based on mesh type\n    r_geom = 0.0 if mesh_type == 'wedge' else r_min\n    \n    nodes = np.array([\n        [r_geom, 0.0],\n        [r_geom + h_r, 0.0],\n        [r_geom, h_z],\n        [r_geom + h_r, h_z],\n        [r_geom, 2.0 * h_z],\n        [r_geom + h_r, 2.0 * h_z]\n    ])\n    num_nodes = 6\n    num_dofs = 2 * num_nodes\n\n    # 3. Define elements and DOF maps for assembly\n    # Connectivity [bottom-left, bottom-right, top-right, top-left]\n    elements = [[0, 1, 3, 2], [2, 3, 5, 4]]\n    # Maps local element DOFs to global DOFs\n    dof_maps = [\n        np.array([0, 1, 2, 3, 6, 7, 4, 5]),\n        np.array([4, 5, 6, 7, 10, 11, 8, 9])\n    ]\n\n    # 4. Assemble global stiffness matrix K\n    K = np.zeros((num_dofs, num_dofs))\n    for i, elem_node_indices in enumerate(elements):\n        elem_coords = nodes[elem_node_indices]\n        k_e = get_element_stiffness(elem_coords, C, r_floor)\n        \n        ix_map = dof_maps[i]\n        K[np.ix_(ix_map, ix_map)] += k_e\n\n    # 5. Apply Boundary Conditions by elimination\n    if mesh_type == 'wedge':\n        # ur=0 at r=0 (nodes 0, 2, 4 -> DOFs 0, 4, 8)\n        # uz=0 at node 0 (DOF 1) to remove rigid body motion\n        constrained_dofs = [0, 1, 4, 8]\n    else: # rectangular\n        # ur=0, uz=0 at node 0 (DOFs 0, 1) to remove rigid body motion\n        constrained_dofs = [0, 1]\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs)\n    K_reduced = K[np.ix_(free_dofs, free_dofs)]\n    \n    # 6. Compute and return the 2-norm condition number\n    condition_number = np.linalg.cond(K_reduced, p=2)\n    return condition_number\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'type': 'rectangular', 'r_min': 1e-6, 'r_floor': 0.0},\n        {'type': 'rectangular', 'r_min': 1e-3, 'r_floor': 0.0},\n        {'type': 'rectangular', 'r_min': 1e-1, 'r_floor': 0.0},\n        {'type': 'wedge', 'r_min': 0.0, 'r_floor': 0.0},\n        {'type': 'rectangular', 'r_min': 1e-6, 'r_floor': 1e-3},\n        {'type': 'wedge', 'r_min': 0.0, 'r_floor': 1e-3},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_analysis(\n            mesh_type=case['type'],\n            r_min=case['r_min'],\n            r_floor=case['r_floor']\n        )\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.7e}' for r in results)}]\")\n\nsolve()\n```", "id": "3545417"}, {"introduction": "在有限元分析中，为了提高计算效率和单元在弯曲问题中的性能，常常采用减缩积分技术。然而，这种方法可能引入无物理意义的零能“沙漏”模式，导致单元过于柔性而失去精度。本高级练习 [@problem_id:3545395] 旨在探讨在轴对称问题中，如何设计一种既能抑制沙漏变形，又能保持能量守恒的稳定化方案。您将通过该练习，深入理解单元技术中的关键权衡，并学习如何基于虚功原理来构造一个在物理上和数值上都可靠的单元。", "problem": "在有限元法 (FEM) 中，考虑一个单一的双线性四节点轴对称四边形有限元。该单元的节点位于物理坐标 $(r_i,z_i)$（$i=1,2,3,4$），并在自然坐标 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$上采用标准双线性形函数 $N_i(\\xi,\\eta)$。该单元代表一个环形扇区，其周向厚度通过轴对称加权隐式地考虑。其基本原理是轴对称虚功原理：对于任何运动学容许的虚位移，内虚功等于外虚功，在轴对称形式下使用 $2\\pi r$ 的周向加权。具体来说，某一点的内虚功密度由应力-应变积给出，总内虚功为\n$$\n\\delta W_{\\mathrm{int}}=2\\pi\\int_{\\Omega} r\\,\\boldsymbol{\\sigma}:\\delta \\boldsymbol{\\varepsilon}\\, \\mathrm{d}\\Omega,\n$$\n其中 $\\Omega$ 是子午截面，$r$ 是当前半径坐标，$\\boldsymbol{\\sigma}$ 是 Cauchy 应力张量，$\\boldsymbol{\\varepsilon}$ 是小应变张量。您将考虑一个线性弹性、各向同性、轴对称实体，其杨氏模量为 $E$（单位为 $\\mathrm{Pa}$），泊松比为 $\\nu$。\n\n您的任务是研究在弯曲主导的轴对称问题中，由减缩（单点）积分引起的环向应力 $\\sigma_{\\theta\\theta}$ 的误差，并设计一个抗沙漏控制项，以在给定\n位移场下保持 $2\\pi r$ 加权的虚功平衡。请按以下第一性原理进行操作：\n\n1. 为四节点四边形定义双线性形函数 $N_i(\\xi,\\eta)$ 及其自然导数 $\\partial N_i/\\partial \\xi$、$\\partial N_i/\\partial \\eta$。使用 $r(\\xi,\\eta)=\\sum_i N_i(\\xi,\\eta)\\,r_i$ 和 $z(\\xi,\\eta)=\\sum_i N_i(\\xi,\\eta)\\,z_i$ 映射到物理坐标。通过链式法则计算雅可比矩阵 $\\mathbf{J}$ 及其行列式 $\\det \\mathbf{J}$，以及梯度 $\\partial N_i/\\partial r$ 和 $\\partial N_i/\\partial z$。\n\n2. 构建与小应变和轴对称性一致的轴对称应变-位移矩阵 $\\mathbf{B}(\\xi,\\eta)$。使用应变向量排序 $\\boldsymbol{\\varepsilon}=[\\varepsilon_{rr},\\,\\varepsilon_{zz},\\,\\varepsilon_{\\theta\\theta},\\,\\gamma_{rz}]^\\mathsf{T}$ 和节点位移向量 $\\mathbf{u}=[u_{r1},u_{z1},u_{r2},u_{z2},u_{r3},u_{z3},u_{r4},u_{z4}]^\\mathsf{T}$。环向应变必须插值为 $\\varepsilon_{\\theta\\theta}(\\xi,\\eta)=\\sum_i N_i(\\xi,\\eta)\\,u_{ri}/r(\\xi,\\eta)$。\n\n3. 使用 Lamé 参数 $\\lambda=E\\nu/((1+\\nu)(1-2\\nu))$ 和 $\\mu=E/(2(1+\\nu))$ 推导各向同性三维实体在轴对称条件下的本构矩阵 $\\mathbf{D}$。在所选的排序中，正应力分量通过 $\\lambda$ 和 $\\mu$ 耦合，剪切应力为 $\\tau_{rz}=\\mu\\,\\gamma_{rz}$。\n\n4. 使用 $\\boldsymbol{\\sigma}=\\mathbf{D}\\,\\boldsymbol{\\varepsilon}$ 计算 Gauss 点处的环向应力 $\\sigma_{\\theta\\theta}$。实现全积分（$2 \\times 2$ Gauss 点，标准位置为 $\\xi,\\eta=\\pm 1/\\sqrt{3}$，单位权重）和减缩积分（在 $\\xi=\\eta=0$ 处的单点 Gauss 积分）。将全积分下单元上的 $2\\pi r$ 加权平均环向应力定义为\n$$\n\\overline{\\sigma_{\\theta\\theta}}=\\frac{\\sum_{g} \\left(2\\pi\\, r_g\\, \\sigma_{\\theta\\theta,g}\\, \\det \\mathbf{J}_g\\, w_g\\right)}{\\sum_{g} \\left(2\\pi\\, r_g\\, \\det \\mathbf{J}_g\\, w_g\\right)},\n$$\n其中，求和遍历所有 Gauss 点，$w_g$ 是 Gauss 权重，$r_g$ 是 Gauss 点处的半径，$\\det \\mathbf{J}_g$ 是 Gauss 点处的雅可比行列式。\n\n5. 通过相对差值量化减缩积分环向应力误差\n$$\ne_{\\mathrm{RI}}=\\frac{\\left|\\sigma_{\\theta\\theta,\\mathrm{RI}}-\\overline{\\sigma_{\\theta\\theta}}\\right|}{\\left|\\overline{\\sigma_{\\theta\\theta}}\\right|},\n$$\n其中 $\\sigma_{\\theta\\theta,\\mathrm{RI}}$ 是在减缩积分下于单元中心计算的环向应力。将 $e_{\\mathrm{RI}}$ 表示为小数。\n\n6. 使用 $2\\pi r$ 加权计算全积分的总内应变能：\n$$\nW_{\\mathrm{FI}}=\\sum_{g}\\left(2\\pi\\, r_g\\, \\tfrac{1}{2}\\,\\boldsymbol{\\varepsilon}_g^\\mathsf{T}\\mathbf{D}\\,\\boldsymbol{\\varepsilon}_g\\, \\det \\mathbf{J}_g\\, w_g\\right),\n$$\n以及中心点减缩积分的总内应变能：\n$$\nW_{\\mathrm{RI}}=2\\pi\\, r_c\\, \\tfrac{1}{2}\\,\\boldsymbol{\\varepsilon}_c^\\mathsf{T}\\mathbf{D}\\,\\boldsymbol{\\varepsilon}_c\\, \\det \\mathbf{J}_c,\n$$\n其中下标 $c$ 表示中心 Gauss 点 $(\\xi,\\eta)=(0,0)$。\n\n7. 设计一个抗沙漏控制项 $W_{\\mathrm{HG}}$，通过惩罚径向位移中的轴对称沙漏模式，来保持给定 位移场下的 $2\\pi r$ 加权虚功平衡。为径向自由度定义三个线性无关的沙漏向量为\n$$\n\\mathbf{h}_1=[1,-1,1,-1]^\\mathsf{T},\\quad \\mathbf{h}_2=[1,1,-1,-1]^\\mathsf{T},\\quad \\mathbf{h}_3=[1,-1,-1,1]^\\mathsf{T},\n$$\n以及相应的振幅 $q_m=\\mathbf{h}_m^\\mathsf{T}\\,\\mathbf{u}_r$，其中 $\\mathbf{u}_r=[u_{r1},u_{r2},u_{r3},u_{r4}]^\\mathsf{T}$。令稳定化能为\n$$\nW_{\\mathrm{HG}}=\\alpha\\,\\sum_{m=1}^{3} q_m^2,\n$$\n其中标量系数 $\\alpha$ 的选择需满足\n$$\nW_{\\mathrm{RI}}+W_{\\mathrm{HG}}=W_{\\mathrm{FI}}.\n$$\n您必须根据第一性原理，使用上述等式和计算出的 $q_m$，为每个测试用例计算 $\\alpha$，从而精确保持 $2\\pi r$ 加权的虚功平衡。如果 $\\sum q_m^2=0$，则设 $\\alpha=0$，并将平衡视为自然满足。\n\n8. 为了进行数值验证，定义以下三个具有物理上合理的参数和位移场的测试用例。所有用例均使用 $E=200\\times 10^{9}$ $\\mathrm{Pa}$ 和 $\\nu=0.30$。节点排序为 $(\\xi,\\eta)=(-1,-1)\\rightarrow i=1$、$(+1,-1)\\rightarrow i=2$、$(+1,+1)\\rightarrow i=3$、$(-1,+1)\\rightarrow i=4$。单元节点在 $(r,z)$ 坐标系中形成一个矩形，其坐标为 $(r_1,z_1)=(r_{\\mathrm{in}},0)$、$(r_2,z_2)=(r_{\\mathrm{out}},0)$、$(r_3,z_3)=(r_{\\mathrm{out}},h)$、$(r_4,z_4)=(r_{\\mathrm{in}},h)$。\n   - 用例 A（一般类弯曲场）：$(r_{\\mathrm{in}},r_{\\mathrm{out}},h)=(1.0,2.0,0.5)$ $\\mathrm{m}$，位移为 $u_r(r,z)=\\kappa\\,z$，$u_z(r,z)=0$，其中 $\\kappa=1.0\\times 10^{-3}$（单位 $\\mathrm{m}/\\mathrm{m}$）。通过在节点坐标处计算这些场来分配节点位移。\n   - 用例 B（径向位移中的纯沙漏模式）：$(r_{\\mathrm{in}},r_{\\mathrm{out}},h)=(1.0,2.0,0.5)$ $\\mathrm{m}$，径向节点位移为 $[u_{r1},u_{r2},u_{r3},u_{r4}]=[a,-a,a,-a]$ 且 $u_{z i}=0$，其中 $a=1.0\\times 10^{-3}$ $\\mathrm{m}$。\n   - 用例 C（具有混合场的细长单元）：$(r_{\\mathrm{in}},r_{\\mathrm{out}},h)=(0.5,0.55,0.5)$ $\\mathrm{m}$，位移为 $u_r(r,z)=\\kappa\\,z + a\\,s(\\xi,\\eta)$，$u_z(r,z)=0$，其中 $\\kappa=2.0\\times 10^{-3}$，$a=5.0\\times 10^{-4}$ $\\mathrm{m}$，且 $s(\\xi,\\eta)$ 引起的沙漏模式对应于 $\\mathbf{h}_1$，因此节点径向位移为 $[u_{r1},u_{r2},u_{r3},u_{r4}]=[\\kappa z_1+a,\\kappa z_2-a,\\kappa z_3+\\,a,\\kappa z_4-\\,a]$。\n\n9. 对于每个测试用例，计算并报告：\n   - 减缩积分环向应力相对误差 $e_{\\mathrm{RI}}$，以小数形式表示（无单位）。\n   - 一个布尔值，指示 $2\\pi r$ 加权的虚功平衡 $W_{\\mathrm{RI}}+W_{\\mathrm{HG}}=W_{\\mathrm{FI}}$ 是否在 $10^{-9}$ 的相对容差内成立。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一个形式为 $[e_{\\mathrm{RI}},\\mathrm{balance\\_ok}]$ 的列表。例如，输出格式必须类似于 $[[0.12345,True],[0.00001,False],[0.10,True]]$。所有几何输入单位为 $\\mathrm{m}$，材料模量单位为 $\\mathrm{Pa}$，不涉及角度。所要求的误差必须是小数，而不是百分比。内部计算的环向应力和能量应遵循轴对称 $2\\pi r$ 加权，并保持科学上的一致性。", "solution": "用户提供的问题是计算固体力学领域的一项综合性练习，重点是单个双线性四节点轴对称有限元的公式化和分析。该任务要求推导和实现有限元法 (FEM) 的几个关键组成部分，包括形函数、通过雅可比矩阵的几何映射、应变-位移矩阵 ($\\mathbf{B}$) 和本构矩阵 ($\\mathbf{D}$)。问题的核心在于比较全积分（$2 \\times 2$ Gauss）和减缩积分（单点）方案，量化环向应力的误差，并设计一种能够保持总内能守恒的沙漏控制机制。\n\n该问题具有科学依据、是适定的，并且内部一致。所有必要的参数、定义和公式都已明确给出。所选的测试用例经过精心设计，用以探究单元的不同变形模式，包括类弯曲剪切、纯沙漏和混合模式。问题是有效的，可以根据其说明构建一个分步解决方案。\n\n解决方案按以下步骤进行：\n\n1.  **基本公式**：为有限元法公式化建立必要的数学对象。\n    *   **形函数**：在自然坐标 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 中，四节点四边形单元的标准等参双线性形函数 $N_i(\\xi, \\eta)$ 定义如下：\n        $$\n        \\begin{align*}\n        N_1(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1-\\eta) \\\\\n        N_2(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1-\\eta) \\\\\n        N_3(\\xi, \\eta) = \\frac{1}{4}(1+\\xi)(1+\\eta) \\\\\n        N_4(\\xi, \\eta) = \\frac{1}{4}(1-\\xi)(1+\\eta)\n        \\end{align*}\n        $$\n        节点排序对应于在自然坐标系中从 $(\\xi, \\eta) = (-1, -1)$ 开始对单元进行的逆时针遍历。\n    *   **几何映射和雅可比矩阵**：物理坐标 $(r, z)$ 通过形函数从节点坐标 $(r_i, z_i)$ 插值得到：$r(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) r_i$ 和 $z(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) z_i$。雅可比矩阵 $\\mathbf{J}$ 关联了物理坐标系和自然坐标系中的导数：\n        $$\n        \\mathbf{J} = \\begin{bmatrix} \\frac{\\partial r}{\\partial \\xi}  \\frac{\\partial z}{\\partial \\xi} \\\\ \\frac{\\partial r}{\\partial \\eta}  \\frac{\\partial z}{\\partial \\eta} \\end{bmatrix}\n        $$\n        然后，使用雅可比矩阵的逆来求得形函数相对于物理坐标的导数：$\\left\\{\\frac{\\partial N_i}{\\partial r}, \\frac{\\partial N_i}{\\partial z}\\right\\}^\\mathsf{T} = \\mathbf{J}^{-1} \\left\\{\\frac{\\partial N_i}{\\partial \\xi}, \\frac{\\partial N_i}{\\partial \\eta}\\right\\}^\\mathsf{T}$。\n\n2.  **运动学和本构法则**：\n    *   **应变-位移矩阵 ($\\mathbf{B}$)**：对于轴对称问题，小应变张量分量与径向 ($u_r$) 和轴向 ($u_z$) 位移相关。当位移场插值为 $u_r = \\sum N_i u_{ri}$ 和 $u_z = \\sum N_i u_{zi}$ 时，应变为：\n        $$\n        \\varepsilon_{rr} = \\frac{\\partial u_r}{\\partial r} = \\sum_i \\frac{\\partial N_i}{\\partial r} u_{ri} \\quad;\\quad\n        \\varepsilon_{zz} = \\frac{\\partial u_z}{\\partial z} = \\sum_i \\frac{\\partial N_i}{\\partial z} u_{zi}\n        $$\n        $$\n        \\varepsilon_{\\theta\\theta} = \\frac{u_r}{r} = \\frac{1}{r} \\sum_i N_i u_{ri} \\quad;\\quad\n        \\gamma_{rz} = \\frac{\\partial u_r}{\\partial z} + \\frac{\\partial u_z}{\\partial r} = \\sum_i \\left( \\frac{\\partial N_i}{\\partial z} u_{ri} + \\frac{\\partial N_i}{\\partial r} u_{zi} \\right)\n        $$\n        这些关系被组织成矩阵方程 $\\boldsymbol{\\varepsilon} = \\mathbf{B}(\\xi, \\eta) \\mathbf{u}$，其中 $\\mathbf{u}$ 是节点位移向量，$\\mathbf{B}$ 是 $4 \\times 8$ 的应变-位移矩阵。\n    *   **本构矩阵 ($\\mathbf{D}$)**：对于轴对称条件下的线性弹性各向同性材料，应力-应变关系 $\\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon}$ 由以下本构矩阵给出：\n        $$\n        \\mathbf{D} = \\begin{bmatrix}\n        \\lambda+2\\mu  & \\lambda  & \\lambda  & 0 \\\\\n        \\lambda  & \\lambda+2\\mu  & \\lambda  & 0 \\\\\n        \\lambda  & \\lambda  & \\lambda+2\\mu  & 0 \\\\\n        0  & 0  & 0  & \\mu\n        \\end{bmatrix}\n        $$\n        其中 $\\lambda$ 和 $\\mu$ 是 Lamé 参数，由杨氏模量 $E$ 和泊松比 $\\nu$ 导出。\n\n3.  **数值积分与误差分析**：\n    *   **全积分 (FI)**：单元属性使用 $2 \\times 2$ Gauss 求积方案进行评估。通过对四个 Gauss 点的贡献求和，计算出 $2\\pi r$ 加权的内应变能 $W_{\\mathrm{FI}}$ 和加权平均环向应力 $\\overline{\\sigma_{\\theta\\theta}}$，每个点的权重为 $w_g=1$。\n    *   **减缩积分 (RI)**：使用单元中心 $(\\xi, \\eta) = (0, 0)$ 的单个 Gauss 点计算相同的属性。这简化了计算，但可能导致伪“沙漏”模式，这些非物理变形在单元中心产生零应变。\n    *   **误差量化**：根据规定，计算减缩积分得到的环向应力 $\\sigma_{\\theta\\theta,\\mathrm{RI}}$ 与全积分得到的平均值 $\\overline{\\sigma_{\\theta\\theta}}$ 之间的相对误差 $e_{\\mathrm{RI}}$。\n\n4.  **沙漏控制**：\n    *   减缩积分会低估单元的刚度，尤其是在弯曲情况下。能量差 $W_{\\mathrm{FI}} - W_{\\mathrm{RI}}$ 代表了与变形模式相关的能量，这些模式能被全积分“看到”，但不能被减缩积分“看到”（即沙漏模式）。\n    *   为补偿此不足，构建了一个抗沙漏稳定化能项 $W_{\\mathrm{HG}}$。从径向节点位移计算出三个独立沙漏模式的振幅 $q_m$。稳定化能定义为 $W_{\\mathrm{HG}} = \\alpha \\sum_m q_m^2$。\n    *   通过对给定位移场强制执行能量守恒来确定稳定化参数 $\\alpha$：$W_{\\mathrm{RI}} + W_{\\mathrm{HG}} = W_{\\mathrm{FI}}$。这导出了表达式 $\\alpha = (W_{\\mathrm{FI}} - W_{\\mathrm{RI}}) / \\sum_m q_m^2$，前提是沙漏模式是活动的（$\\sum_m q_m^2 \\neq 0$）。$\\alpha$ 的这种选择确保了虚功平衡得到精确维持。\n\n5.  **测试用例的实现**：上述步骤在一个 Python 程序中实现。为每个测试用例定义几何形状、材料属性和节点位移。然后程序计算 $W_{\\mathrm{FI}}$、$W_{\\mathrm{RI}}$、$\\overline{\\sigma_{\\theta\\theta}}$ 和 $\\sigma_{\\theta\\theta,\\mathrm{RI}}$。基于这些值，它计算误差 $e_{\\mathrm{RI}}$ 和稳定化参数 $\\alpha$。最后，它验证能量平衡 $W_{\\mathrm{RI}} + W_{\\mathrm{HG}} = W_{\\mathrm{FI}}$ 在指定的数值容差内是否成立。每个用例的结果，包括误差和平衡检查，都按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants from the problem\nE_MOD = 200e9  # Pa\nNU = 0.30\n\ndef get_shape_functions(xi, eta):\n    \"\"\"\n    Returns shape functions N and their derivatives dN/d_xi, dN/d_eta for a 4-node quad.\n    Nodal ordering corresponds to xi,eta: (-1,-1), (1,-1), (1,1), (-1,1).\n    \"\"\"\n    N = 0.25 * np.array([\n        (1 - xi) * (1 - eta),\n        (1 + xi) * (1 - eta),\n        (1 + xi) * (1 + eta),\n        (1 - xi) * (1 + eta)\n    ])\n    dN_dxi = 0.25 * np.array([\n        -(1 - eta),\n        (1 - eta),\n        (1 + eta),\n        -(1 + eta)\n    ])\n    dN_deta = 0.25 * np.array([\n        -(1 - xi),\n        -(1 + xi),\n        (1 + xi),\n        (1 - xi)\n    ])\n    return N, dN_dxi, dN_deta\n\ndef evaluate_at_point(xi, eta, node_coords, nodal_displacements, D_matrix):\n    \"\"\"\n    Evaluates kinematic and kinetic quantities at a single integration point (xi, eta).\n    Returns stress vector, strain energy density, radius, and Jacobian determinant.\n    \"\"\"\n    N, dN_dxi, dN_deta = get_shape_functions(xi, eta)\n\n    # Jacobian matrix J = [[dr/dxi, dz/dxi], [dr/deta, dz/deta]]\n    J_matrix = np.array([\n        [np.dot(dN_dxi, node_coords[:, 0]), np.dot(dN_dxi, node_coords[:, 1])],\n        [np.dot(dN_deta, node_coords[:, 0]), np.dot(dN_deta, node_coords[:, 1])]\n    ])\n    \n    detJ = np.linalg.det(J_matrix)\n    invJ = np.linalg.inv(J_matrix)\n\n    # Derivatives of shape functions w.r.t. physical coordinates (r, z)\n    dN_drz = invJ @ np.vstack((dN_dxi, dN_deta))\n    dN_dr = dN_drz[0, :]\n    dN_dz = dN_drz[1, :]\n\n    # Radius at the evaluation point\n    r_point = np.dot(N, node_coords[:, 0])\n\n    # Strain-displacement matrix B (4x8)\n    B_matrix = np.zeros((4, 8))\n    for i in range(4):\n        B_matrix[0, 2 * i] = dN_dr[i]\n        B_matrix[1, 2 * i + 1] = dN_dz[i]\n        B_matrix[2, 2 * i] = N[i] / r_point\n        B_matrix[3, 2 * i] = dN_dz[i]\n        B_matrix[3, 2 * i + 1] = dN_dr[i]\n\n    # Calculate strain, stress, and strain energy density\n    strain_vector = B_matrix @ nodal_displacements\n    stress_vector = D_matrix @ strain_vector\n    strain_energy_density = 0.5 * np.dot(strain_vector, stress_vector)\n\n    return stress_vector, strain_energy_density, r_point, detJ\n\ndef solve_case(case_params):\n    \"\"\"\n    Solves a single test case for the axisymmetric element as per the problem description.\n    \"\"\"\n    (r_in, r_out, h), u_r_values, u_z_values = case_params\n\n    # 1. Nodal coordinates and assemble global displacement vector\n    node_coords = np.array([\n        [r_in, 0],   # Node 1\n        [r_out, 0],  # Node 2\n        [r_out, h],  # Node 3\n        [r_in, h]    # Node 4\n    ])\n    \n    nodal_displacements = np.zeros(8)\n    nodal_displacements[0::2] = u_r_values\n    nodal_displacements[1::2] = u_z_values\n\n    # 2. Define constitutive matrix D\n    lame_lambda = E_MOD * NU / ((1 + NU) * (1 - 2 * NU))\n    lame_mu = E_MOD / (2 * (1 + NU))\n    D_matrix = np.array([\n        [lame_lambda + 2 * lame_mu, lame_lambda, lame_lambda, 0],\n        [lame_lambda, lame_lambda + 2 * lame_mu, lame_lambda, 0],\n        [lame_lambda, lame_lambda, lame_lambda + 2 * lame_mu, 0],\n        [0, 0, 0, lame_mu]\n    ])\n\n    # 3. Full Integration (2x2 Gauss Quadrature)\n    gp_loc = 1.0 / np.sqrt(3.0)\n    gauss_points = [(-gp_loc, -gp_loc), (gp_loc, -gp_loc), (gp_loc, gp_loc), (-gp_loc, gp_loc)]\n    gauss_weights = [1.0, 1.0, 1.0, 1.0]\n\n    W_FI = 0.0\n    hoop_stress_numerator = 0.0\n    volume_weighted_denominator = 0.0\n    \n    for i, (xi, eta) in enumerate(gauss_points):\n        w_g = gauss_weights[i]\n        stress_g, U_g, r_g, detJ_g = evaluate_at_point(xi, eta, node_coords, nodal_displacements, D_matrix)\n        \n        W_FI += (2 * np.pi * r_g * U_g * detJ_g * w_g)\n        \n        hoop_stress_g = stress_g[2]\n        hoop_stress_numerator += (2 * np.pi * r_g * hoop_stress_g * detJ_g * w_g)\n        volume_weighted_denominator += (2 * np.pi * r_g * detJ_g * w_g)\n    \n    avg_hoop_stress = hoop_stress_numerator / volume_weighted_denominator if volume_weighted_denominator != 0 else 0.0\n    \n    # 4. Reduced Integration (1-point at center)\n    stress_c, U_c, r_c, detJ_c = evaluate_at_point(0.0, 0.0, node_coords, nodal_displacements, D_matrix)\n    hoop_stress_RI = stress_c[2]\n    W_RI = 2 * np.pi * r_c * U_c * detJ_c\n\n    # 5. Calculate reduced integration hoop stress error\n    if np.abs(avg_hoop_stress) > 1e-15:\n        e_RI = np.abs(hoop_stress_RI - avg_hoop_stress) / np.abs(avg_hoop_stress)\n    else:\n        e_RI = 0.0 if np.abs(hoop_stress_RI) < 1e-15 else np.inf\n\n    # 6. Design and apply hourglass control\n    h_vectors = [np.array([1, -1, 1, -1]), np.array([1, 1, -1, -1]), np.array([1, -1, -1, 1])]\n    sum_q_sq = sum(np.dot(h, u_r_values)**2 for h in h_vectors)\n    \n    alpha = (W_FI - W_RI) / sum_q_sq if sum_q_sq > 1e-25 else 0.0\n    W_HG = alpha * sum_q_sq\n\n    # 7. Verify the energy balance\n    abs_diff = np.abs((W_RI + W_HG) - W_FI)\n    balance_ok = (abs_diff <= 1e-12) if np.abs(W_FI) <= 1e-12 else (abs_diff / np.abs(W_FI) <= 1e-9)\n\n    return [e_RI, balance_ok]\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases, then prints the results in the specified format.\n    \"\"\"\n    # Case A: Bending-like field\n    r_in_A, r_out_A, h_A = 1.0, 2.0, 0.5\n    kappa_A = 1.0e-3\n    u_r_A = np.array([0, 0, kappa_A * h_A, kappa_A * h_A])\n    u_z_A = np.zeros(4)\n    case_A = ((r_in_A, r_out_A, h_A), u_r_A, u_z_A)\n    \n    # Case B: Pure hourglass mode\n    r_in_B, r_out_B, h_B = 1.0, 2.0, 0.5\n    a_B = 1.0e-3\n    u_r_B = np.array([a_B, -a_B, a_B, -a_B])\n    u_z_B = np.zeros(4)\n    case_B = ((r_in_B, r_out_B, h_B), u_r_B, u_z_B)\n\n    # Case C: Slender element with mixed field\n    r_in_C, r_out_C, h_C = 0.5, 0.55, 0.5\n    kappa_C = 2.0e-3\n    a_C = 5.0e-4\n    u_r_C = np.array([a_C, -a_C, kappa_C * h_C + a_C, kappa_C * h_C - a_C])\n    u_z_C = np.zeros(4)\n    case_C = ((r_in_C, r_out_C, h_C), u_r_C, u_z_C)\n\n    test_cases = [case_A, case_B, case_C]\n    \n    results = [solve_case(case) for case in test_cases]\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{res[0]},{res[1]}]\" for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "3545395"}]}