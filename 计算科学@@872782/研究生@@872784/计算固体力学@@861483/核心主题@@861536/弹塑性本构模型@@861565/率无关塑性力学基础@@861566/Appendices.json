{"hands_on_practices": [{"introduction": "实现返回映射算法是计算塑性力学中的一项基本技能。本实践将指导您为广泛使用的、包含线性各向同性硬化的 $J_2$ 塑性模型构建并验证一个返回映射算法。通过将您的代码应用于标准基准加载路径，您将获得从理论推导到数值验证的完整工作流程的实践经验，从而确保您的实现是稳健和正确的。 [@problem_id:3593035]", "problem": "考虑一个由偏应力第二不变量（通常称为 $J_2$ 塑性）和线性各向同性硬化控制的小应变、率无关、各向同性弹塑性材料。其弹性响应由各向同性线性弹性张量定义，其中拉梅参数 $ \\lambda $ 和 $ \\mu $ 与杨氏模量 $ E $ 和泊松比 $ \\nu $ 的关系为 $ \\mu = \\dfrac{E}{2(1+\\nu)} $ 和 $ \\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2 \\nu)} $。材料行为通过应变加和分解 $ \\varepsilon = \\varepsilon^e + \\varepsilon^p $ 表示，其中 $ \\varepsilon $ 是总小应变张量，$ \\varepsilon^e $ 是弹性应变张量，$ \\varepsilon^p $ 是塑性应变张量。柯西应力张量为 $ \\sigma = 2 \\mu \\, \\varepsilon^e + \\lambda \\, \\mathrm{tr}(\\varepsilon^e) I $，其中 $ I $ 是二阶单位张量。\n\n塑性屈服由 von Mises 屈服函数 $ f(\\sigma, \\alpha) = \\sigma_{\\mathrm{eq}}(\\sigma) - \\sigma_y(\\alpha) $ 决定，其中 $ \\sigma_{\\mathrm{eq}}(\\sigma) = \\sqrt{\\dfrac{3}{2}} \\, \\| s \\| $，$ s = \\sigma - \\dfrac{1}{3} \\mathrm{tr}(\\sigma) I $ 是偏应力，$ \\| s \\| $ 是 $ s $ 的弗罗贝尼乌斯范数，$ \\sigma_y(\\alpha) = \\sigma_{y0} + H \\alpha $ 是通过累积等效塑性应变 $ \\alpha $ 表示的当前屈服应力，其中初始屈服应力为 $ \\sigma_{y0} $，硬化模量为 $ H $。塑性流动是关联的，塑性应变率 $ \\dot{\\varepsilon}^p $ 与屈服函数对应力的梯度方向一致，累积等效塑性应变率 $ \\dot{\\alpha} $ 定义为 $ \\dot{\\alpha} = \\sqrt{\\dfrac{2}{3}} \\, \\| \\dot{\\varepsilon}^p \\| $。演化必须满足率无关塑性的经典 Kuhn–Tucker 条件：$ f \\le 0 $，$ \\dot{\\lambda} \\ge 0 $，$ \\dot{\\lambda} f = 0 $，以及发生屈服时的一致性条件。这里的 $ \\dot{\\lambda} $ 是塑性乘子。\n\n您的任务是，从这些基本原理出发，推导一个用于三维空间中单个恒定应变增量的后向欧拉返回映射更新算法，并实现它以通过指定的加载路径推进状态。该更新必须确保在发生塑性流动时塑性不可压缩性 $ \\mathrm{tr}(\\Delta \\varepsilon^p) = 0 $ 成立，并且每个增量步都必须满足力学耗散不等式 $ \\Delta D = \\sigma : \\Delta \\varepsilon^p \\ge 0 $。您还必须实现检查，以验证每个路径最终状态下的屈服一致性。\n\n材料参数给定为 $ E = 210000 $（单位：兆帕，MPa），$ \\nu = 0.3 $（无量纲），$ \\sigma_{y0} = 250 $（单位：MPa），以及 $ H = 1000 $（单位：MPa）。应变为无量纲。应力必须以兆帕（MPa）为单位进行计算。如果内部检查需要角度，则必须以弧度处理。\n\n实现该算法并模拟以下三个基准加载路径，每个路径都指定为应用于应变张量 $ \\varepsilon $ 的一系列恒定应变增量：\n\n- 单轴拉伸路径：施加 $ 20 $ 个增量，每个增量为 $ \\Delta \\varepsilon = \\mathrm{diag}(10^{-4}, 0, 0) $。\n- 纯剪切路径：施加 $ 20 $ 个增量，每个增量 $ \\Delta \\varepsilon $ 的分量为 $ \\Delta \\varepsilon_{12} = \\Delta \\varepsilon_{21} = 10^{-4} $，所有其他分量为零。\n- 非比例双轴路径：首先施加 $ 15 $ 个 $ \\Delta \\varepsilon = \\mathrm{diag}(10^{-4}, 0, 0) $ 的增量，然后施加 $ 5 $ 个 $ \\Delta \\varepsilon = \\mathrm{diag}(0, 10^{-4}, 0) $ 的增量。\n\n对于每个路径，在完成所有增量步后，计算并报告三个布尔值检查：\n\n1. 塑性不可压缩性检查：$ |\\mathrm{tr}(\\varepsilon^p_{\\mathrm{final}})| \\le 10^{-10} $。\n2. 非负耗散检查：总累积塑性耗散 $ \\sum \\sigma_{n+1} : \\Delta \\varepsilon^p \\ge -10^{-12} $。\n3. 最终状态的屈服一致性检查：如果最终累积等效塑性应变 $ \\alpha_{\\mathrm{final}}  10^{-12} $，则 $ | f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) | \\le 10^{-10} $；否则（纯弹性最终状态），$ f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) \\le 10^{-10} $。\n\n您的程序应生成一行输出，其中包含按上述顺序排列的三个路径的九个布尔结果，聚合为一个逗号分隔的列表并用方括号括起来，例如 $[\\mathrm{result}_1, \\mathrm{result}_2, \\mathrm{result}_3, \\ldots, \\mathrm{result}_9]$。不应产生任何其他输出。所有应力计算必须以兆帕（MPa）为单位进行。布尔值为无量纲。", "solution": "该问题要求推导并实现一个数值算法，以模拟小应变、率无关、各向同性弹塑性材料的行为。该模型基于偏应力的第二不变量 $J_2$，并包含了线性各向同性硬化。该算法将用于模拟材料在指定加载路径下的响应。解决方案的核心在于实现一个后向欧拉返回映射方案，以对离散应变增量上的本构方程进行积分。\n\n材料在离散时间步 $n$ 的状态由总应变张量 $\\varepsilon_n$、塑性应变张量 $\\varepsilon^p_n$ 和标量累积等效塑性应变 $\\alpha_n$ 定义。给定此状态和指定的总应变增量 $\\Delta\\varepsilon$，任务是计算时间步 $n+1$ 的状态。增量结束时的总应变为 $\\varepsilon_{n+1} = \\varepsilon_n + \\Delta\\varepsilon$。该算法包括一个弹性预测步，如果检测到屈服，则随后进行一个塑性修正步。\n\n第一步是弹性预测。我们假设整个应变增量是纯弹性的，这意味着塑性状态变量不发生改变：$\\Delta\\varepsilon^p = 0$ 和 $\\Delta\\alpha=0$。该步结束时的弹性应变，称为试探弹性应变 $\\varepsilon^{e, \\text{trial}}_{n+1}$，计算如下：\n$$ \\varepsilon^{e, \\text{trial}}_{n+1} = \\varepsilon_{n+1} - \\varepsilon^p_n = (\\varepsilon_n + \\Delta\\varepsilon) - \\varepsilon^p_n = \\varepsilon^e_n + \\Delta\\varepsilon $$\n然后使用各向同性线性弹性本构律计算试探应力 $\\sigma^{\\text{trial}}_{n+1}$：\n$$ \\sigma^{\\text{trial}}_{n+1} = 2\\mu \\varepsilon^{e, \\text{trial}}_{n+1} + \\lambda \\mathrm{tr}(\\varepsilon^{e, \\text{trial}}_{n+1}) I $$\n其中 $\\mu = \\frac{E}{2(1+\\nu)}$ 和 $\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2 \\nu)}$ 是拉梅参数，$I$ 是二阶单位张量。累积塑性应变的试探值与上一步保持不变，$\\alpha^{\\text{trial}}_{n+1} = \\alpha_n$。\n\n第二步是屈服条件检查。我们在试探状态下评估 von Mises 屈服函数 $f(\\sigma, \\alpha) = \\sigma_{\\mathrm{eq}}(\\sigma) - \\sigma_y(\\alpha)$：\n$$ f^{\\text{trial}} = f(\\sigma^{\\text{trial}}_{n+1}, \\alpha_n) = \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) - \\sigma_y(\\alpha_n) $$\n此处，等效应力为 $\\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) = \\sqrt{\\frac{3}{2}} \\| s^{\\text{trial}}_{n+1} \\|$，其中 $s^{\\text{trial}}_{n+1} = \\sigma^{\\text{trial}}_{n+1} - \\frac{1}{3} \\mathrm{tr}(\\sigma^{\\text{trial}}_{n+1}) I$ 是试探应力的偏量部分。屈服应力由线性硬化律 $\\sigma_y(\\alpha_n) = \\sigma_{y0} + H\\alpha_n$ 给出。如果 $f^{\\text{trial}} \\le 0$，则弹性假设有效。试探状态成为该增量的最终状态：$\\sigma_{n+1} = \\sigma^{\\text{trial}}_{n+1}$，$\\varepsilon^p_{n+1} = \\varepsilon^p_n$，$\\alpha_{n+1} = \\alpha_n$。\n\n如果 $f^{\\text{trial}}  0$，则材料已屈服，需要进行塑性修正。这就是返回映射阶段。塑性流动由关联流动法则控制，当使用后向欧拉格式离散化时，塑性应变增量 $\\Delta\\varepsilon^p = \\varepsilon^p_{n+1} - \\varepsilon^p_n$ 表示为：\n$$ \\Delta\\varepsilon^p = \\Delta\\gamma \\frac{\\partial f}{\\partial\\sigma}\\bigg|_{\\sigma_{n+1}} = \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{s_{n+1}}{\\|s_{n+1}\\|} $$\n其中 $\\Delta\\gamma \\ge 0$ 是塑性乘子增量。累积塑性应变的演化由 $\\Delta\\alpha = \\sqrt{\\frac{2}{3}} \\| \\Delta\\varepsilon^p \\|$ 给出。$J_2$ 塑性流动法则的一个关键推论是 $\\Delta\\alpha = \\Delta\\gamma$。这是因为梯度 $\\frac{\\partial f}{\\partial\\sigma}$ 的范数为1。另一个推论是塑性不可压缩性，$\\mathrm{tr}(\\Delta\\varepsilon^p)=0$，因为梯度是纯偏量的。\n\n时间步 $n+1$ 的应力与试探应力相关，关系为 $\\sigma_{n+1} = \\sigma^{\\text{trial}}_{n+1} - 2\\mu\\Delta\\varepsilon^p$。由于 $\\mathrm{tr}(\\Delta\\varepsilon^p)=0$，静水应力不受塑性修正的影响，即 $\\mathrm{tr}(\\sigma_{n+1}) = \\mathrm{tr}(\\sigma^{\\text{trial}}_{n+1})$。修正仅适用于偏量部分：$s_{n+1} = s^{\\text{trial}}_{n+1} - 2\\mu\\Delta\\varepsilon^p$。将 $\\Delta\\varepsilon^p$ 的流动法则代入：\n$$ s_{n+1} = s^{\\text{trial}}_{n+1} - 2\\mu \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{s_{n+1}}{\\|s_{n+1}\\|} $$\n此方程表明 $s_{n+1}$ 与 $s^{\\text{trial}}_{n+1}$ 共线。通过重新排列并对两边取范数，我们得到以下关系：\n$$ \\|s_{n+1}\\| + 2\\mu \\Delta\\gamma \\sqrt{\\frac{3}{2}} = \\|s^{\\text{trial}}_{n+1}\\| $$\n两边乘以 $\\sqrt{3/2}$ 并代入等效应力的定义，得到：\n$$ \\sigma_{\\mathrm{eq}}(\\sigma_{n+1}) + 3\\mu\\Delta\\gamma = \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) $$\n最终状态必须满足一致性条件 $f(\\sigma_{n+1}, \\alpha_{n+1})=0$，这要求 $\\sigma_{\\mathrm{eq}}(\\sigma_{n+1}) = \\sigma_y(\\alpha_{n+1}) = \\sigma_y(\\alpha_n) + H\\Delta\\alpha$。利用 $\\Delta\\alpha = \\Delta\\gamma$，我们得到 $\\sigma_{\\mathrm{eq}}(\\sigma_{n+1}) = \\sigma_y(\\alpha_n) + H\\Delta\\gamma$。将此代入前一个方程，即可求解 $\\Delta\\gamma$：\n$$ (\\sigma_y(\\alpha_n) + H\\Delta\\gamma) + 3\\mu\\Delta\\gamma = \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) $$\n$$ \\sigma_{\\mathrm{eq}}(\\sigma^{\\text{trial}}_{n+1}) - \\sigma_y(\\alpha_n) = (3\\mu + H)\\Delta\\gamma $$\n左侧即为 $f^{\\text{trial}}$。因此，塑性乘子以闭合形式求得：\n$$ \\Delta\\gamma = \\frac{f^{\\text{trial}}}{3\\mu + H} $$\n确定 $\\Delta\\gamma$ 后，更新状态变量。\n1. 更新内部硬化变量：$\\alpha_{n+1} = \\alpha_n + \\Delta\\gamma$。\n2. 计算塑性应变增量。由于 $s_{n+1}$ 和 $s^{\\text{trial}}_{n+1}$ 共线，我们可以使用 $s^{\\text{trial}}_{n+1}$ 的方向：\n   $$ \\Delta\\varepsilon^p = \\Delta\\gamma \\sqrt{\\frac{3}{2}} \\frac{s^{\\text{trial}}_{n+1}}{\\|s^{\\text{trial}}_{n+1}\\|} $$\n3. 更新总塑性应变：$\\varepsilon^p_{n+1} = \\varepsilon^p_n + \\Delta\\varepsilon^p$。\n4. 更新应力张量：$\\sigma_{n+1} = \\sigma^{\\text{trial}}_{n+1} - 2\\mu\\Delta\\varepsilon^p$。\n\n该算法针对给定的加载路径进行实现。在完成一个路径的所有增量后，对最终状态进行三个检查：塑性不可压缩性 $|\\mathrm{tr}(\\varepsilon^p_{\\mathrm{final}})| \\le 10^{-10}$，非负总耗散 $\\sum \\sigma_{n+1} : \\Delta \\varepsilon^p \\ge -10^{-12}$，以及屈服一致性 $| f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) | \\le 10^{-10}$（如果发生塑性流动，即 $\\alpha_{\\mathrm{final}}  10^{-12}$），或 $f(\\sigma_{\\mathrm{final}}, \\alpha_{\\mathrm{final}}) \\le 10^{-10}$（其他情况）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the elasto-plastic problem for three loading paths and reports on the validation checks.\n    \"\"\"\n    \n    # Material parameters (stress in MPa)\n    E = 210000.0\n    nu = 0.3\n    sig_y0 = 250.0\n    H = 1000.0\n\n    # Derived elastic parameters\n    mu = E / (2.0 * (1.0 + nu))\n    lmbda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    \n    # Identity tensor\n    I = np.identity(3)\n\n    # Define loading paths\n    # Path 1: Uniaxial tension\n    uniaxial_path = [\n        (np.diag([1e-4, 0.0, 0.0]), 20)\n    ]\n    \n    # Path 2: Pure shear\n    shear_increment = np.zeros((3, 3))\n    shear_increment[0, 1] = 1e-4\n    shear_increment[1, 0] = 1e-4\n    pure_shear_path = [\n        (shear_increment, 20)\n    ]\n    \n    # Path 3: Nonproportional biaxial path\n    nonproportional_path = [\n        (np.diag([1e-4, 0.0, 0.0]), 15),\n        (np.diag([0.0, 1e-4, 0.0]), 5)\n    ]\n    \n    paths = [uniaxial_path, pure_shear_path, nonproportional_path]\n    \n    final_results = []\n\n    for path in paths:\n        # Initialize state variables\n        eps_n = np.zeros((3, 3))\n        eps_p_n = np.zeros((3, 3))\n        alpha_n = 0.0\n        \n        # Initialize check accumulators\n        total_dissipation = 0.0\n\n        for segment in path:\n            delta_eps_template, num_increments = segment\n            for _ in range(num_increments):\n                # Current state is (eps_n, eps_p_n, alpha_n)\n                # Apply strain increment\n                eps_n1 = eps_n + delta_eps_template\n                \n                # --- Elasto-plastic update algorithm (return mapping) ---\n                \n                # 1. Elastic predictor\n                eps_e_trial = eps_n1 - eps_p_n\n                tr_eps_e_trial = np.trace(eps_e_trial)\n                sig_trial = lmbda * tr_eps_e_trial * I + 2.0 * mu * eps_e_trial\n                \n                s_trial = sig_trial - (np.trace(sig_trial) / 3.0) * I\n                norm_s_trial = np.linalg.norm(s_trial)\n                \n                # Handle case where s_trial is zero to avoid division by zero\n                if norm_s_trial  1e-12:\n                     sig_eq_trial = 0.0\n                else:\n                    sig_eq_trial = np.sqrt(3.0 / 2.0) * norm_s_trial\n\n                # 2. Yield check\n                sig_y_n = sig_y0 + H * alpha_n\n                f_trial = sig_eq_trial - sig_y_n\n\n                delta_eps_p = np.zeros((3, 3))\n                if f_trial = 1e-12:  # Elastic step (with tolerance)\n                    eps_p_n1 = eps_p_n\n                    alpha_n1 = alpha_n\n                    sig_n1 = sig_trial\n                else:  # 3. Plastic corrector\n                    delta_gamma = f_trial / (3.0 * mu + H)\n                    \n                    alpha_n1 = alpha_n + delta_gamma\n                    \n                    # Normal to the yield surface at trial state\n                    N_trial = np.sqrt(3.0 / 2.0) * s_trial / norm_s_trial\n                    \n                    delta_eps_p = delta_gamma * N_trial\n                    eps_p_n1 = eps_p_n + delta_eps_p\n                    \n                    # Update stress (radial return)\n                    sig_n1 = sig_trial - 2.0 * mu * delta_eps_p\n\n                # Accumulate dissipation for the current increment\n                dissipation_inc = np.sum(sig_n1 * delta_eps_p)\n                total_dissipation += dissipation_inc\n\n                # Update state for the next increment\n                eps_n = eps_n1\n                eps_p_n = eps_p_n1\n                alpha_n = alpha_n1\n\n        # --- Post-simulation checks for the completed path ---\n        eps_p_final = eps_p_n\n        alpha_final = alpha_n\n        \n        # Recalculate final stress from final strains for consistency\n        eps_e_final = eps_n - eps_p_final\n        sig_final = lmbda * np.trace(eps_e_final) * I + 2.0 * mu * eps_e_final\n\n        # Check 1: Plastic incompressibility\n        check1 = abs(np.trace(eps_p_final)) = 1e-10\n        final_results.append(check1)\n        \n        # Check 2: Nonnegative dissipation\n        check2 = total_dissipation >= -1e-12\n        final_results.append(check2)\n\n        # Check 3: Yield consistency\n        s_final = sig_final - (np.trace(sig_final) / 3.0) * I\n        norm_s_final = np.linalg.norm(s_final)\n        sig_eq_final = np.sqrt(3.0 / 2.0) * norm_s_final if norm_s_final > 1e-12 else 0.0\n\n        sig_y_final = sig_y0 + H * alpha_final\n        f_final = sig_eq_final - sig_y_final\n        \n        if alpha_final > 1e-12: # Plastic state\n            check3 = abs(f_final) = 1e-10\n        else: # Elastic state\n            check3 = f_final = 1e-10\n        final_results.append(check3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3593035"}, {"introduction": "各向同性硬化描述了屈服面的均匀扩张，而随动硬化则模拟其平移，这对于循环加载现象至关重要。本练习在一个简化的一维环境中，聚焦于实现随动硬化时的细微差别。您将探索完全一致的隐式更新与简化的“滞后”更新在处理背应力时的关键区别，从而能够直接量化常见算法简化所引入的误差。 [@problem_id:3593012]", "problem": "考虑具有线性随动硬化的小应变、单轴、率无关塑性。您将推导、实现并测试一个双子步应变控制更新算法，该算法使用弹性预测/塑性修正的返回映射格式。重点是揭示非零背应力如何在第二子步中改變容许性，并量化当背应力以滞后方式处理时产生的修正误差。\n\n从以下基本基础出发：\n- 运动学：总应变被加法分解为弹性和塑性两部分，$\\,\\varepsilon = \\varepsilon^{\\mathrm{e}} + \\varepsilon^{\\mathrm{p}}\\,.$\n- 自由能：假设一个二次 Helmholtz 自由能密度 $\\,\\psi(\\varepsilon, \\varepsilon^{\\mathrm{p}}, \\alpha) = \\tfrac{1}{2} E \\left(\\varepsilon - \\varepsilon^{\\mathrm{p}}\\right)^{2} + \\tfrac{1}{2H}\\,\\alpha^{2}\\,,$ 其中 $\\,E\\,$ 是杨氏模量，$\\,H\\,$ 是线性随动硬化模量。假设为小应变。\n- 本构力共轭：应力 $\\,\\sigma\\,$ 与总应变 $\\,\\varepsilon\\,$ 功共轭，塑性应变 $\\,\\varepsilon^{\\mathrm{p}}\\,$ 是耗散的，并有关联的塑性乘子 $\\,\\dot{\\gamma}\\ge 0\\,$，背应力 $\\,\\alpha\\,$ 与其自身的运动学内变量功共轭。使用 Clausius–Duhem 不等式确保非负耗散，并对率无关塑性采用标准的关联正交性。\n- 屈服函数：使用一维平移 von Mises 型准则 $\\,f(\\sigma,\\alpha) = \\lvert \\sigma - \\alpha \\rvert - \\sigma_{y}\\le 0\\,$，其中 $\\,\\sigma_{y}\\,$ 是初始屈服应力。施加 Karush–Kuhn–Tucker 互补条件 $\\,\\dot{\\gamma}\\ge 0\\,$, $\\,f\\le 0\\,$ 和 $\\,\\dot{\\gamma}\\,f = 0\\,$，以及一致性条件 $\\,\\dot{\\gamma}0 \\Rightarrow \\dot{f}=0\\,$。采用一维关联流动，因此塑性流动方向为 $\\,\\mathrm{sign}(\\sigma-\\alpha)\\,$。对于一维线性随动硬化，取 $\\,\\dot{\\alpha} = H\\,\\dot{\\varepsilon}^{\\mathrm{p}}\\,.$\n\n您的任务：\n1) 基于上述基础，推导从时间 $\\,t_{n}\\,$到 $\\,t_{n+1}\\,$ 的應變控制子步更新的一维返回映射方程。用标量塑性乘子增量 $\\,\\Delta\\gamma\\,$ 表示弹性预测（试探状态）和塑性修正。确保在塑性加载 $\\,\\Delta\\gamma0\\,$ 時，更新后的状态精确满足 $\\,f(\\sigma_{n+1},\\alpha_{n+1})=0\\,$。不要假设任何快捷公式；从所述原理进行推导。\n2) 定义一个“滞后背应力”格式，其中在塑性修正过程中，背应力在屈服和一致性方程中保持其子步初始值不变，同时仍然通过弹性模量更新应力。以此滞后方式求解塑性乘子后，使用获得的塑性应变增量在子步结束时更新背应力。通过使用更新后的（非冻结的）背应力评估屈服残差 $\\,r = \\lvert \\sigma_{n+1}^{\\mathrm{lag}} - \\alpha_{n+1}^{\\mathrm{lag}} \\rvert - \\sigma_{y}\\,$ 来量化此滞后格式的不一致性，并将最终应力与一致解进行比较。\n3) 在单个步内实现两子步加载。第一子步必须是弹性的。在第二子步中，由于存在非零背应力，试探状态必须违反容许性，从而触发塑性修正。\n\n物理和数值细节：\n- 应力单位使用兆帕 (MPa)，应变为无量纲。任何类应力输出以 MPa 表示，任何类应变输出表示为纯数。报告相对误差时，以小数（而非百分比）形式报告。\n- 此处不适用角度单位。\n\n对每个测试用例，精确定义两子步更新如下：\n- 初始已知：$\\,E\\,$ (MPa), $\\,\\sigma_{y}\\,$ (MPa), $\\,H\\,$ (MPa), $\\,\\varepsilon_{0}\\,$, $\\,\\varepsilon^{\\mathrm{p}}_{0}\\,$ 和 $\\,\\alpha_{0}\\,$.\n- 子步 $\\,1\\,$：施加 $\\,\\Delta\\varepsilon_{1}\\,$，计算弹性预测 $\\,\\sigma^{\\mathrm{tr}}_{1} = \\sigma_{0} + E\\,\\Delta\\varepsilon_{1}\\,$，其中 $\\,\\sigma_{0} = E(\\varepsilon_{0} - \\varepsilon^{\\mathrm{p}}_{0})\\,$，检查容许性，并更新状态。对于所有测试用例，此子步必须保持弹性。\n- 子步 $\\,2\\,$：对子步 $\\,1\\,$ 更新后的状态施加 $\\,\\Delta\\varepsilon_{2}\\,$。计算试探状态并检测屈服。如果发生塑性，计算：\n  - 使用推导出的返回映射得到的一致解 $\\,(\\Delta\\gamma^{\\mathrm{cons}}, \\sigma_{2}^{\\mathrm{cons}}, \\alpha_{2}^{\\mathrm{cons}})\\,$，该映射强制满足 $\\,f(\\sigma_{2}^{\\mathrm{cons}},\\alpha_{2}^{\\mathrm{cons}})=0\\,.$\n  - 滞后背应力解 $\\,(\\Delta\\gamma^{\\mathrm{lag}}, \\sigma_{2}^{\\mathrm{lag}}, \\alpha_{2}^{\\mathrm{lag}})\\,$，在修正器中使用冻结背应力评估，并在求解出 $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$ 后才更新 $\\,\\alpha\\,.$\n  - 滞后更新的屈服残差 $\\,r = \\lvert \\sigma_{2}^{\\mathrm{lag}} - \\alpha_{2}^{\\mathrm{lag}} \\rvert - \\sigma_{y}\\,$ (单位 MPa)，以及相对应力误差 $\\,e_{\\sigma} = (\\sigma_{2}^{\\mathrm{lag}} - \\sigma_{2}^{\\mathrm{cons}})/\\sigma_{2}^{\\mathrm{cons}}\\,$ (以小数形式表示)。\n\n测试套件：\n提供一个程序，为下面的每组数据计算每个测试用例的四个标量：$\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$, $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$, $\\,r\\,$ 和 $\\,e_{\\sigma}\\,$。请使用这些精确值。\n\n- 情况 $\\,\\mathrm{A}\\,$（理想路径，拉伸加载伴随负背应力，因此由于运动学平移，在子步 $\\,2\\,$ 中容许性失效）：\n  - $\\,E = 210000\\,$ MPa, $\\,\\sigma_{y} = 250\\,$ MPa, $\\,H = 5000\\,$ MPa\n  - $\\,\\alpha_{0} = -80\\,$ MPa, $\\,\\varepsilon^{\\mathrm{p}}_{0} = -0.016\\,$, $\\,\\varepsilon_{0} = -0.015285714285714\\,$\n  - $\\,\\Delta\\varepsilon_{1} = 0.00002\\,$, $\\,\\Delta\\varepsilon_{2} = 0.00043238\\,$\n\n- 情况 $\\,\\mathrm{B}\\,$（反向加载边界类情况，在没有背应力时压缩试探是容许的，但由于正背应力而失效）：\n  - $\\,E = 70000\\,$ MPa, $\\,\\sigma_{y} = 150\\,$ MPa, $\\,H = 700\\,$ MPa\n  - $\\,\\alpha_{0} = 120\\,$ MPa, $\\,\\varepsilon^{\\mathrm{p}}_{0} = 0.171428571428571\\,$, $\\,\\varepsilon_{0} = 0.171428571428571\\,$\n  - $\\,\\Delta\\varepsilon_{1} = -0.000285714285714\\,$, $\\,\\Delta\\varepsilon_{2} = -0.001714285714286\\,$\n\n- 情况 $\\,\\mathrm{C}\\,$（随动硬化模量相对于弹性模量较大，导致一致修正较小且滞后误差可观）：\n  - $\\,E = 100000\\,$ MPa, $\\,\\sigma_{y} = 300\\,$ MPa, $\\,H = 200000\\,$ MPa\n  - $\\,\\alpha_{0} = -50\\,$ MPa, $\\,\\varepsilon^{\\mathrm{p}}_{0} = -0.00025\\,$, $\\,\\varepsilon_{0} = 0.00215\\,$\n  - $\\,\\Delta\\varepsilon_{1} = 0.00005\\,$, $\\,\\Delta\\varepsilon_{2} = 0.0002\\,$\n\n答案规格：\n- 对每种情况，输出列表 $[\\Delta\\gamma^{\\mathrm{cons}}, \\Delta\\gamma^{\\mathrm{lag}}, r, e_{\\sigma}]$，其中 $\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$ 和 $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$ 是无量纲的，$\\,r\\,$ 的单位是 MPa，$\\,e_{\\sigma}\\,$ 是一个小数（无量纲）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该行必须是包含三个情况结果列表的 Python 风格列表，例如 $[\\,[\\cdots], [\\cdots], [\\cdots]\\,]$。将每个打印的浮点数四舍五入到合理的小数位数，以便微小差异可见（例如，$10^{-12}$ 的精度是可以接受的）。", "solution": "该问题要求推导和实现一个针对具有线性随动硬化的一维率无关塑性的返回映射算法。分析将比较一个完全一致的隐式更新与一个简化的“滞后背应力”显式更新。\n\n### 1. 本构框架\n\n该模型的基础是一个热力学一致框架。材料的状态由总应变 $\\,\\varepsilon\\,$ 和两个内变量描述：塑性应变 $\\,\\varepsilon^{\\mathrm{p}}\\,$ 和一个标量随动硬化变量，对于线性硬化，该变量与背应力 $\\,\\alpha\\,$呈线性关系。\n\n**自由能和状态变量：**\n指定的 Helmholtz 自由能密度为：\n$$ \\psi(\\varepsilon, \\varepsilon^{\\mathrm{p}}, \\alpha) = \\frac{1}{2} E \\left(\\varepsilon - \\varepsilon^{\\mathrm{p}}\\right)^{2} + \\frac{1}{2H}\\,\\alpha^{2} $$\n其中 $\\,E\\,$ 是杨氏模量，$\\,H\\,$ 是随动硬化模量。项 $\\,\\varepsilon^{\\mathrm{e}} = \\varepsilon - \\varepsilon^{\\mathrm{p}}\\,$ 是弹性应变。\n\n**热力学力：**\n应力 $\\,\\sigma\\,$ 和热力学力的本构关系是通过对自由能关于其共轭状态变量求导得出的。\n应力 $\\,\\sigma\\,$ 与总应变 $\\,\\varepsilon\\,$ 共轭：\n$$ \\sigma = \\frac{\\partial \\psi}{\\partial \\varepsilon} = E (\\varepsilon - \\varepsilon^{\\mathrm{p}}) = E \\varepsilon^{\\mathrm{e}} $$\n这就是胡克定律。源自 Clausius-Duhem 不等式的耗散不等式规定了内变量的演化。耗散率 $\\,\\mathcal{D}\\,$ 必须为非负：\n$$ \\mathcal{D} = \\sigma \\dot{\\varepsilon}^{\\mathrm{p}} - \\frac{\\partial \\psi}{\\partial \\alpha}\\dot{\\alpha} \\ge 0 $$\n问题将硬化定律定义为 $\\,\\dot{\\alpha} = H \\dot{\\varepsilon}^{\\mathrm{p}}\\,$。将此式以及 $\\,\\frac{\\partial \\psi}{\\partial \\alpha} = \\frac{\\alpha}{H}\\,$ 代入耗散不等式，得到：\n$$ \\mathcal{D} = \\sigma \\dot{\\varepsilon}^{\\mathrm{p}} - \\left(\\frac{\\alpha}{H}\\right) (H \\dot{\\varepsilon}^{\\mathrm{p}}) = (\\sigma - \\alpha) \\dot{\\varepsilon}^{\\mathrm{p}} \\ge 0 $$\n项 $\\,\\xi = \\sigma - \\alpha\\,$ 是有效应力，是塑性流动的热力学驱动力。\n\n**塑性流动与屈服条件：**\n对于率无关塑性，只有当满足屈服准则时才会发生流动。屈服函数给出如下：\n$$ f(\\sigma, \\alpha) = \\lvert \\sigma - \\alpha \\rvert - \\sigma_{y} = \\lvert \\xi \\rvert - \\sigma_{y} \\le 0 $$\n其中 $\\,\\sigma_{y}\\,$ 是初始屈服应力。塑性流动由 Karush-Kuhn-Tucker (KKT) 条件控制：\n$$ \\dot{\\gamma} \\ge 0, \\quad f(\\sigma, \\alpha) \\le 0, \\quad \\dot{\\gamma} f(\\sigma, \\alpha) = 0 $$\n其中 $\\,\\dot{\\gamma}\\,$ 是塑性乘子率。采用关联流动法则，将塑性应变率与屈服函数联系起来：\n$$ \\dot{\\varepsilon}^{\\mathrm{p}} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\sigma} = \\dot{\\gamma} \\, \\mathrm{sign}(\\sigma - \\alpha) $$\n一致性条件要求在塑性流动期间（$\\,\\dot{\\gamma}  0\\,$），状态必须保持在屈服面上（$\\,f=0\\,$），这意味着 $\\,\\dot{f}=0\\,$。\n\n### 2. 离散化更新算法：返回映射\n\n我们采用后向欧拉积分格式来处理从 $\\,t_{n}\\,$ 到 $\\,t_{n+1}\\,$ 的一个应变控制时间步。时间 $\\,t_n\\,$ 时的状态（$\\,\\varepsilon_n, \\varepsilon^{\\mathrm{p}}_n, \\alpha_n\\,$）是已知的，而时间 $\\,t_{n+1} = t_n + \\Delta t\\,$ 的总应变是给定的。\n\n**步骤 1：弹性预测（试探状态）**\n首先，我们假设整个应变增量 $\\,\\Delta\\varepsilon = \\varepsilon_{n+1} - \\varepsilon_n\\,$ 都由弹性承担。\n- 塑性应变和背应力被冻结：$\\,\\varepsilon^{\\mathrm{p}}_{n+1, \\mathrm{tr}} = \\varepsilon^{\\mathrm{p}}_n\\,$ 和 $\\,\\alpha_{n+1, \\mathrm{tr}} = \\alpha_n\\,.$\n- 计算试探应力：\n  $$ \\sigma_{n+1}^{\\mathrm{tr}} = E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_{n+1, \\mathrm{tr}}) = E(\\varepsilon_{n+1} - \\varepsilon^{\\mathrm{p}}_n) = E(\\varepsilon_n + \\Delta\\varepsilon - \\varepsilon^{\\mathrm{p}}_n) = E(\\varepsilon_n - \\varepsilon^{\\mathrm{p}}_n) + E\\Delta\\varepsilon = \\sigma_n + E\\Delta\\varepsilon $$\n- 试探有效应力为 $\\,\\xi_{n+1}^{\\mathrm{tr}} = \\sigma_{n+1}^{\\mathrm{tr}} - \\alpha_n\\,.$\n\n**步骤 2：检查屈服**\n我们在试探状态下评估屈服函数：\n$$ f_{n+1}^{\\mathrm{tr}} = f(\\sigma_{n+1}^{\\mathrm{tr}}, \\alpha_{n+1, \\mathrm{tr}}) = \\lvert \\sigma_{n+1}^{\\mathrm{tr}} - \\alpha_n \\rvert - \\sigma_y = \\lvert \\xi_{n+1}^{\\mathrm{tr}} \\rvert - \\sigma_y $$\n- 如果 $\\,f_{n+1}^{\\mathrm{tr}} \\le 0\\,$，则试探状态是容许的。该步为弹性步。更新后的状态即为试探状态：\n  $$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{tr}}, \\quad \\varepsilon^{\\mathrm{p}}_{n+1} = \\varepsilon^{\\mathrm{p}}_n, \\quad \\alpha_{n+1} = \\alpha_n $$\n- 如果 $\\,f_{n+1}^{\\mathrm{tr}}  0\\,$，则试探状态是不容许的。发生塑性流动，需要进行塑性修正步。\n\n**步骤 3：塑性修正**\n目标是找到塑性应变增量 $\\,\\Delta\\varepsilon^{\\mathrm{p}}\\,$，使得最终状态 $(\\sigma_{n+1}, \\alpha_{n+1})$ 满足屈服条件 $\\,f(\\sigma_{n+1}, \\alpha_{n+1}) = 0$。内变量的离散增量为：\n- 塑性应变增量：$\\,\\Delta\\varepsilon^{\\mathrm{p}} = \\varepsilon^{\\mathrm{p}}_{n+1} - \\varepsilon^{\\mathrm{p}}_n = \\Delta\\gamma \\, \\mathrm{sign}(\\xi_{n+1})\\,$，其中 $\\,\\Delta\\gamma = \\int_{t_n}^{t_{n+1}} \\dot{\\gamma} dt \\ge 0\\,.$\n- 背应力增量：$\\,\\Delta\\alpha = \\alpha_{n+1} - \\alpha_n = H \\Delta\\varepsilon^{\\mathrm{p}} = H \\Delta\\gamma \\, \\mathrm{sign}(\\xi_{n+1})\\,.$\n\n对于径向返回，流动方向是恒定的，由试探有效应力决定：$\\,N = \\mathrm{sign}(\\xi_{n+1}) = \\mathrm{sign}(\\xi_{n+1}^{\\mathrm{tr}})\\,.$\n更新后的状态变量用试探状态和未知的塑性乘子增量 $\\,\\Delta\\gamma\\,$ 表示：\n$$ \\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\varepsilon^{\\mathrm{p}} = \\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma N $$\n$$ \\alpha_{n+1} = \\alpha_n + \\Delta\\alpha = \\alpha_n + H \\Delta\\gamma N $$\n最终有效应力为：\n$$ \\xi_{n+1} = \\sigma_{n+1} - \\alpha_{n+1} = (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma N) - (\\alpha_n + H \\Delta\\gamma N) = (\\sigma_{n+1}^{\\mathrm{tr}} - \\alpha_n) - (E+H)\\Delta\\gamma N = \\xi_{n+1}^{\\mathrm{tr}} - (E+H)\\Delta\\gamma N $$\n\n### 3. 一致格式和滞后格式的推导\n\n**3.1. 一致返回映射**\n最终状态必须位于屈服面上：$\\,\\lvert \\xi_{n+1} \\rvert = \\sigma_y\\,$。由于 $\\,\\mathrm{sign}(\\xi_{n+1}) = N\\,$，这意味着 $\\,\\xi_{n+1} = \\sigma_y N\\,$。将此代入有效应力更新方程：\n$$ \\sigma_y N = \\xi_{n+1}^{\\mathrm{tr}} - (E+H)\\Delta\\gamma^{\\mathrm{cons}} N $$\n两边乘以 $\\,N\\,$（因为 $\\,N^2 = 1\\,$）并注意 $\\,\\xi_{n+1}^{\\mathrm{tr}} N = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert\\,$：\n$$ \\sigma_y = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (E+H)\\Delta\\gamma^{\\mathrm{cons}} $$\n求解一致塑性乘子增量 $\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$：\n$$ \\Delta\\gamma^{\\mathrm{cons}} = \\frac{\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y}{E+H} = \\frac{f_{n+1}^{\\mathrm{tr}}}{E+H} $$\n由于我们处于塑性情况（$\\,f_{n+1}^{\\mathrm{tr}}  0\\,$），因此 $\\,\\Delta\\gamma^{\\mathrm{cons}}  0\\,$。在 $\\,\\Delta\\gamma^{\\mathrm{cons}}\\,$ 已知的情况下，$\\,t_{n+1}\\,$ 时的所有状态变量都可以唯一确定。\n\n**3.2. 滯後背應力格式**\n在此格式中，在强制施加屈服条件时，背应力被“冻结”在其步初始值 $\\,\\alpha_n\\,$。该条件变为 $\\,f(\\sigma_{n+1}, \\alpha_n) = 0\\,$，或 $\\,\\lvert \\sigma_{n+1} - \\alpha_n \\rvert = \\sigma_y\\,.$\n应力更新式 $\\,\\sigma_{n+1} = \\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma N\\,$ 仍然被使用。我们将其代入滞后屈服条件：\n$$ \\lvert (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N) - \\alpha_n \\rvert = \\sigma_y $$\n$$ \\lvert \\xi_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N \\rvert = \\sigma_y $$\n再次假设径向返回，我们得到：\n$$ \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - E \\Delta\\gamma^{\\mathrm{lag}} = \\sigma_y $$\n求解滞后塑性乘子增量 $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$：\n$$ \\Delta\\gamma^{\\mathrm{lag}} = \\frac{\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y}{E} = \\frac{f_{n+1}^{\\mathrm{tr}}}{E} $$\n在计算出 $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$ 后，更新所有状态变量。注意，由于 $\\,H  0\\,$，显然有 $\\,\\Delta\\gamma^{\\mathrm{lag}}  \\Delta\\gamma^{\\mathrm{cons}}\\,.$\n\n**3.3. 量化滞后格式的不一致性**\n滞后格式是不一致的，因为最终状态 $(\\sigma_{n+1}^{\\mathrm{lag}}, \\alpha_{n+1}^{\\mathrm{lag}})$ 不满足真实的屈服条件。我们用屈服残差 $\\,r\\,$ 来量化这一点。\n最终的有效应力是 $\\,\\xi_{n+1}^{\\mathrm{lag}} = \\sigma_{n+1}^{\\mathrm{lag}} - \\alpha_{n+1}^{\\mathrm{lag}}\\,$。其大小为：\n$$ \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert = \\lvert \\xi_{n+1}^{\\mathrm{tr}} - (E+H)\\Delta\\gamma^{\\mathrm{lag}} N \\rvert = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (E+H)\\Delta\\gamma^{\\mathrm{lag}} $$\n代入 $\\,\\Delta\\gamma^{\\mathrm{lag}}\\,$ 的表达式：\n$$ \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (E+H)\\frac{\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y}{E} = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\left(1 + \\frac{H}{E}\\right)(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) $$\n$$ \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert = \\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - (\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) - \\frac{H}{E}(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) = \\sigma_y - \\frac{H}{E}(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) $$\n因此，屈服残差为：\n$$ r = \\lvert \\xi_{n+1}^{\\mathrm{lag}} \\rvert - \\sigma_y = -\\frac{H}{E}(\\lvert\\xi_{n+1}^{\\mathrm{tr}}\\rvert - \\sigma_y) = -\\frac{H}{E} f_{n+1}^{\\mathrm{tr}} $$\n由于 $\\,H, E, f_{n+1}^{\\mathrm{tr}}  0\\,$，残差 $\\,r\\,$ 是负的，这表明滞后格式过度修正，并将状态带到了真实屈服面的内部。\n\n相对应力误差 $\\,e_{\\sigma}\\,$ 定义为 $\\,e_{\\sigma} = (\\sigma_{n+1}^{\\mathrm{lag}} - \\sigma_{n+1}^{\\mathrm{cons}})/\\sigma_{n+1}^{\\mathrm{cons}}\\,$。\n应力差为：\n$$ \\sigma_{n+1}^{\\mathrm{lag}} - \\sigma_{n+1}^{\\mathrm{cons}} = (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N) - (\\sigma_{n+1}^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{cons}} N) = -E(\\Delta\\gamma^{\\mathrm{lag}} - \\Delta\\gamma^{\\mathrm{cons}})N $$\n乘子的差异为：\n$$ \\Delta\\gamma^{\\mathrm{lag}} - \\Delta\\gamma^{\\mathrm{cons}} = \\frac{f_{n+1}^{\\mathrm{tr}}}{E} - \\frac{f_{n+1}^{\\mathrm{tr}}}{E+H} = f_{n+1}^{\\mathrm{tr}} \\left(\\frac{E+H-E}{E(E+H)}\\right) = f_{n+1}^{\\mathrm{tr}} \\frac{H}{E(E+H)} $$\n所以，$\\,\\sigma_{n+1}^{\\mathrm{lag}} - \\sigma_{n+1}^{\\mathrm{cons}} = -E \\left( f_{n+1}^{\\mathrm{tr}} \\frac{H}{E(E+H)} \\right) N = -f_{n+1}^{\\mathrm{tr}} \\frac{H}{E+H} N\\,$。这个差异将针对每种情况进行数值评估。\n\n### 4. 两子步实现的总结\n\n对于每个具有参数 $\\,E, \\sigma_y, H\\,$、初始状态 $\\,\\varepsilon_0, \\varepsilon^{\\mathrm{p}}_0, \\alpha_0\\,$ 以及应变增量 $\\,\\Delta\\varepsilon_1, \\Delta\\varepsilon_2\\,$ 的测试用例：\n\n1.  **初始化**：计算 $\\,\\sigma_0 = E(\\varepsilon_0 - \\varepsilon^{\\mathrm{p}}_0)\\,.$\n2.  **子步 1 (弹性)**：\n    -   计算试探应力 $\\,\\sigma_1^{\\mathrm{tr}} = \\sigma_0 + E\\Delta\\varepsilon_1\\,.$\n    -   确认 $\\,\\lvert \\sigma_1^{\\mathrm{tr}} - \\alpha_0 \\rvert - \\sigma_y \\le 0\\,.$\n    -   更新状态：$\\,\\sigma_1 = \\sigma_1^{\\mathrm{tr}}$, $\\,\\varepsilon^{\\mathrm{p}}_1 = \\varepsilon^{\\mathrm{p}}_0$, $\\,\\alpha_1 = \\alpha_0\\,.$\n3.  **子步 2 (塑性)**：\n    -   计算试探应力 $\\,\\sigma_2^{\\mathrm{tr}} = \\sigma_1 + E\\Delta\\varepsilon_2\\,.$\n    -   计算试探有效应力 $\\,\\xi_2^{\\mathrm{tr}} = \\sigma_2^{\\mathrm{tr}} - \\alpha_1\\,$ 和屈服函数值 $\\,f_2^{\\mathrm{tr}} = \\lvert \\xi_2^{\\mathrm{tr}} \\rvert - \\sigma_y\\,.$\n    -   确认 $\\,f_2^{\\mathrm{tr}}  0\\,.$\n    -   设置流动方向 $\\,N = \\mathrm{sign}(\\xi_2^{\\mathrm{tr}})\\,.$\n4.  **计算一致解**：\n    -   $\\Delta\\gamma^{\\mathrm{cons}} = f_2^{\\mathrm{tr}} / (E+H)\\,.$\n    -   $\\sigma_2^{\\mathrm{cons}} = \\sigma_2^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{cons}} N\\,.$\n5.  **计算滞后解**：\n    -   $\\Delta\\gamma^{\\mathrm{lag}} = f_2^{\\mathrm{tr}} / E\\,.$\n    -   $\\sigma_2^{\\mathrm{lag}} = \\sigma_2^{\\mathrm{tr}} - E \\Delta\\gamma^{\\mathrm{lag}} N = \\alpha_1 + \\sigma_y N\\,.$\n    -   $\\alpha_2^{\\mathrm{lag}} = \\alpha_1 + H \\Delta\\gamma^{\\mathrm{lag}} N\\,.$\n6.  **计算误差**：\n    -   $r = \\lvert \\sigma_2^{\\mathrm{lag}} - \\alpha_2^{\\mathrm{lag}} \\rvert - \\sigma_y\\,.$\n    -   $e_{\\sigma} = (\\sigma_2^{\\mathrm{lag}} - \\sigma_2^{\\mathrm{cons}}) / \\sigma_2^{\\mathrm{cons}}\\,.$\n7.  **存储结果**：四个值 $\\,\\Delta\\gamma^{\\mathrm{cons}}, \\Delta\\gamma^{\\mathrm{lag}}, r, e_{\\sigma}\\,$ 是单个情况的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(E, sigma_y, H, eps0, eps_p0, alpha0, delta_eps1, delta_eps2):\n    \"\"\"\n    Solves a single test case for the two-substep plasticity problem.\n\n    Args:\n        E (float): Young's modulus (MPa)\n        sigma_y (float): Initial yield stress (MPa)\n        H (float): Linear kinematic hardening modulus (MPa)\n        eps0 (float): Initial total strain\n        eps_p0 (float): Initial plastic strain\n        alpha0 (float): Initial backstress (MPa)\n        delta_eps1 (float): Strain increment for substep 1\n        delta_eps2 (float): Strain increment for substep 2\n\n    Returns:\n        tuple: (delta_gamma_cons, delta_gamma_lag, r, e_sigma)\n    \"\"\"\n\n    # --- Initial State (n=0) ---\n    sigma0 = E * (eps0 - eps_p0)\n    \n    # Verify initial state admissibility\n    f0 = np.abs(sigma0 - alpha0) - sigma_y\n    if f0 > 1e-9: # Use a small tolerance for floating point comparisons\n        raise ValueError(f\"Initial state is not admissible (f0 = {f0} > 0)\")\n\n    # --- Substep 1 (Elastic) ---\n    sigma1_tr = sigma0 + E * delta_eps1\n    alpha1_tr = alpha0\n    \n    f1_tr = np.abs(sigma1_tr - alpha1_tr) - sigma_y\n    if f1_tr > 1e-9:\n        raise ValueError(f\"Substep 1 is not elastic as required (f1_tr = {f1_tr} > 0)\")\n    \n    # Update state after elastic substep 1\n    sigma1 = sigma1_tr\n    eps_p1 = eps_p0\n    alpha1 = alpha0\n    \n    # --- Substep 2 (Plastic) ---\n    # Predictor\n    sigma2_tr = sigma1 + E * delta_eps2\n    alpha2_tr = alpha1 # Backstress at start of substep\n    \n    # Check yield\n    xi2_tr = sigma2_tr - alpha2_tr\n    f2_tr = np.abs(xi2_tr) - sigma_y\n    \n    if f2_tr = 1e-9:\n        raise ValueError(f\"Substep 2 is not plastic as required (f2_tr = {f2_tr} = 0)\")\n        \n    N = np.sign(xi2_tr)\n    \n    # --- Consistent Solution ---\n    delta_gamma_cons = f2_tr / (E + H)\n    sigma2_cons = sigma2_tr - E * delta_gamma_cons * N\n    # alpha2_cons = alpha1 + H * delta_gamma_cons * N\n    # Verification:\n    # xi2_cons = sigma2_cons - alpha2_cons\n    # assert np.isclose(np.abs(xi2_cons), sigma_y), \"Consistent solution failed yield check\"\n    \n    # --- Lagged Backstress Solution ---\n    delta_gamma_lag = f2_tr / E\n    \n    # Update variables for the lagged scheme\n    sigma2_lag = sigma2_tr - E * delta_gamma_lag * N\n    alpha2_lag = alpha1 + H * delta_gamma_lag * N\n    \n    # --- Error Quantification ---\n    # 1. Yield residual of the lagged solution\n    r = np.abs(sigma2_lag - alpha2_lag) - sigma_y\n    \n    # 2. Relative stress error\n    if np.abs(sigma2_cons)  1e-12:\n        e_sigma = 0.0 if np.isclose(sigma2_lag, sigma2_cons) else np.inf\n    else:\n        e_sigma = (sigma2_lag - sigma2_cons) / sigma2_cons\n        \n    return delta_gamma_cons, delta_gamma_lag, r, e_sigma\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A\n        {'E': 210000.0, 'sigma_y': 250.0, 'H': 5000.0,\n         'alpha0': -80.0, 'eps_p0': -0.016, 'eps0': -0.015285714285714,\n         'delta_eps1': 0.00002, 'delta_eps2': 0.00043238},\n        # Case B\n        {'E': 70000.0, 'sigma_y': 150.0, 'H': 700.0,\n         'alpha0': 120.0, 'eps_p0': 0.171428571428571, 'eps0': 0.171428571428571,\n         'delta_eps1': -0.000285714285714, 'delta_eps2': -0.001714285714286},\n        # Case C\n        {'E': 100000.0, 'sigma_y': 300.0, 'H': 200000.0,\n         'alpha0': -50.0, 'eps_p0': -0.00025, 'eps0': 0.00215,\n         'delta_eps1': 0.00005, 'delta_eps2': 0.0002}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(**case)\n        results.append(list(result))\n\n    # Format output as specified\n    output_str = \"[\"\n    for i, res_tuple in enumerate(results):\n        formatted_tuple = [f\"{v:.12f}\" for v in res_tuple]\n        output_str += f\"[{','.join(formatted_tuple)}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3593012"}, {"introduction": "大多数入门模型都假设屈服面是光滑的，例如 von Mises 准则，但许多高级材料模型涉及带有“角点”的非光滑屈服面。本实践旨在探索这种非光滑性在几何和能量方面的后果。通过比较光滑圆形 ($\\ell_2$) 屈服面和非光滑方形 ($\\ell_\\infty$) 屈服面的塑性耗散，您将对屈服面几何如何决定塑性流动建立更深刻的直觉，尤其是在流动方向不唯一的角点处。 [@problem_id:3593014]", "problem": "考虑一个二维偏应力空间中的小应变、率无关、相关联弹塑性材料。设弹性模量为正常数 $E$ (单位为 $\\mathrm{Pa}$)，屈服强度为正常数 $\\sigma_y$ (单位为 $\\mathrm{Pa}$)。用 $\\boldsymbol{s}^{\\mathrm{trial}} = E\\,\\boldsymbol{\\varepsilon}$ 表示试探应力，其中 $\\boldsymbol{\\varepsilon}\\in\\mathbb{R}^2$ 是施加的应变向量（无量纲）。率无关相关联流动法则是 $d\\boldsymbol{\\varepsilon}^p = d\\lambda\\,\\boldsymbol{n}$，其中 $d\\lambda \\ge 0$，$\\boldsymbol{n}$ 是屈服面的一个法向量。更新后的应力满足 $\\boldsymbol{s} = \\boldsymbol{s}^{\\mathrm{trial}} - E\\,\\Delta\\boldsymbol{\\varepsilon}^p$，其中 $\\Delta\\boldsymbol{\\varepsilon}^p$ 是塑性应变增量，其选择应使 $\\boldsymbol{s}$ 位于屈服面上。\n\n考虑两种屈服面：\n\n- 一个由 $\\ell_2$ 范数定义的光滑屈服面：$f_2(\\boldsymbol{s}) = \\|\\boldsymbol{s}\\|_2 - \\sigma_y$，它在 $\\boldsymbol{s}\\neq \\boldsymbol{0}$ 的任何地方都是可微的，并且在屈服时有唯一的法线方向。\n\n- 一个由 $\\ell_\\infty$ 范数定义的非光滑屈服面：$f_\\infty(\\boldsymbol{s}) = \\|\\boldsymbol{s}\\|_\\infty - \\sigma_y$，它在多个分量同时达到最大幅值处存在角点（不可微点），因此在这些点上拥有非唯一的次梯度集合。\n\n每个增量步的塑性耗散是目标泛函 $J = \\boldsymbol{s}\\cdot\\Delta\\boldsymbol{\\varepsilon}^p$ (单位为 $\\mathrm{Pa}$)。对于具有相关联流动的率无关理想塑性， $J$ 等于增量步中塑性流动消耗的应力功率，并且是到屈服面的返回映射的函数。您的任务是利用从光滑 $\\ell_2$ 屈服面导出的信息，为非光滑 $\\ell_\\infty$ 屈服面构建并比较一个塑性耗散的目标导向估计，并量化在不应用任何平滑处理的情况下，非光滑曲面中的角点激活如何降低估计器的可靠性。\n\n仅从上述基本定义和线性弹性关系 $\\boldsymbol{s}^{\\mathrm{trial}} = E\\,\\boldsymbol{\\varepsilon}$ 出发，完成以下任务：\n\n1. 通过强制满足屈服一致性条件和相关联流动法则，推导光滑 $\\ell_2$ 屈服面单个增量步的塑性耗散 $J$。用 $E$、$\\sigma_y$ 和 $\\boldsymbol{s}^{\\mathrm{trial}}$ 明确表示 $J$。\n\n2. 通过强制满足屈服一致性条件和相关联流动法则，推导非光滑 $\\ell_\\infty$ 屈服面单个增量步的塑性耗散 $J$，并仔细处理一个面或多个面的激活情况。用 $E$、$\\sigma_y$ 和 $\\boldsymbol{s}^{\\mathrm{trial}}$ 明确表示 $J$。\n\n3. 构建非光滑耗散 $J$ 的一个目标导向估计，该估计使用光滑 $\\ell_2$ 耗散作为其代理，不进行任何角点平滑。从第一性原理（例如，通过目标泛函的线性化或通过使用基于 $\\ell_2$ 几何形状的光滑伴随权重）证明此选择的合理性。定义一个可靠性度量 $\\rho$，用于衡量估计相对于精确非光滑耗散的准确性。当 $J_{\\infty}  0$ 时，使用无量纲定义，如 $\\rho = 1 - |J_{\\mathrm{est}} - J_{\\infty}| / J_{\\infty}$，并在 $J_{\\infty} = 0$ 时给出一个有原则的定义。\n\n4. 实现一个程序，对于下面的每个测试用例，计算：\n   - 光滑 $\\ell_2$ 耗散（用作目标导向估计），\n   - 精确的非光滑 $\\ell_\\infty$ 耗散，\n   - 估计的可靠性 $\\rho$。\n\n所有耗散值必须以 $\\mathrm{Pa}$ 表示，所有可靠性值必须以十进制数表示。\n\n测试套件（每个用例由 $(E,\\sigma_y,\\boldsymbol{\\varepsilon})$ 给出）：\n- 用例 $1$（理想路径，单面激活）：$E = 2.00\\times 10^{11}\\,\\mathrm{Pa}$，$\\sigma_y = 3.00\\times 10^{8}\\,\\mathrm{Pa}$，$\\boldsymbol{\\varepsilon} = [2.0\\times 10^{-3},\\,5.0\\times 10^{-4}]$。\n- 用例 $2$（角点激活，等值最大值）：$E = 2.00\\times 10^{11}\\,\\mathrm{Pa}$，$\\sigma_y = 3.00\\times 10^{8}\\,\\mathrm{Pa}$，$\\boldsymbol{\\varepsilon} = [2.0\\times 10^{-3},\\,2.0\\times 10^{-3}]$。\n- 用例 $3$（边界情况，在 $\\ell_\\infty$ 屈服阈值上但不在 $\\ell_2$ 阈值上）：$E = 2.00\\times 10^{11}\\,\\mathrm{Pa}$，$\\sigma_y = 3.00\\times 10^{8}\\,\\mathrm{Pa}$，$\\boldsymbol{\\varepsilon} = [1.5\\times 10^{-3},\\,1.5\\times 10^{-3}]$。\n- 用例 $4$（混合激活，两个面具有不相等的超量）：$E = 2.00\\times 10^{11}\\,\\mathrm{Pa}$，$\\sigma_y = 3.00\\times 10^{8}\\,\\mathrm{Pa}$，$\\boldsymbol{\\varepsilon} = [1.8\\times 10^{-3},\\,2.2\\times 10^{-3}]$。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含用例 1 到 4 的可靠性值 $\\rho$，格式为方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4]$），每个 $r_i$ 表示为十进制数。", "solution": "该问题要求在二维偏应力空间中，针对两种不同的屈服准则推导并比较塑性耗散，然后通过编程实现来量化使用光滑准则估计非光滑准则结果的可靠性。该问题是有效的，因为它在科学上基于计算塑性力学的原理，是适定的，并提供了所有必要的数据。\n\n率无关弹塑性力学的通用框架涉及一个试探应力 $\\boldsymbol{s}^{\\mathrm{trial}}$（假设为纯弹性增量计算得出），以及一个返回映射算法，用于在试探状态超出屈服面定义的弹性域时，求解最终应力 $\\boldsymbol{s}$。关键的本构关系如下：\n- 线性弹性：$\\boldsymbol{s}^{\\mathrm{trial}} = E\\,\\boldsymbol{\\varepsilon}$\n- 应力更新（后向欧拉法）：$\\boldsymbol{s} = \\boldsymbol{s}^{\\mathrm{trial}} - E\\,\\Delta\\boldsymbol{\\varepsilon}^p$\n- 相关联流动法则：$\\Delta\\boldsymbol{\\varepsilon}^p = \\Delta\\lambda\\,\\boldsymbol{n}$，其中 $\\boldsymbol{n}$ 是在 $\\boldsymbol{s}$ 处屈服面的外法向，$\\Delta\\lambda \\ge 0$ 是塑性一致性参数。\n- 屈服条件：$f(\\boldsymbol{s}) \\le 0$\n- 加载/卸载条件：$\\Delta\\lambda \\ge 0$, $f(\\boldsymbol{s}) \\le 0$, $\\Delta\\lambda f(\\boldsymbol{s}) = 0$。\n\n如果 $f(\\boldsymbol{s}^{\\mathrm{trial}}) \\le 0$，则该步为弹性步，$\\Delta\\lambda = 0$, $\\Delta\\boldsymbol{\\varepsilon}^p = \\boldsymbol{0}$, $\\boldsymbol{s} = \\boldsymbol{s}^{\\mathrm{trial}}$，塑性耗散 $J = \\boldsymbol{s} \\cdot \\Delta\\boldsymbol{\\varepsilon}^p = 0$。如果 $f(\\boldsymbol{s}^{\\mathrm{trial}})  0$，则该步为塑性步，需要进行返回映射。\n\n**1. 光滑 $\\ell_2$ 屈服面的推导**\n\n光滑屈服面由 $f_2(\\boldsymbol{s}) = \\|\\boldsymbol{s}\\|_2 - \\sigma_y = 0$ 定义，在二维应力空间中表示一个半径为 $\\sigma_y$ 的圆。对于塑性步，其中 $\\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_2  \\sigma_y$，最终应力 $\\boldsymbol{s}$ 必须满足 $\\|\\boldsymbol{s}\\|_2 = \\sigma_y$。\n\n在 $\\boldsymbol{s}$ 处屈服面的法向量为 $\\nabla f_2(\\boldsymbol{s}) = \\boldsymbol{s}/\\|\\boldsymbol{s}\\|_2$。单位法向量为 $\\boldsymbol{n} = \\boldsymbol{s}/\\|\\boldsymbol{s}\\|_2$。将流动法则代入应力更新公式，得到：\n$$ \\boldsymbol{s} = \\boldsymbol{s}^{\\mathrm{trial}} - E\\,\\Delta\\lambda\\,\\frac{\\boldsymbol{s}}{\\|\\boldsymbol{s}\\|_2} $$\n由于对于塑性状态有 $\\|\\boldsymbol{s}\\|_2 = \\sigma_y$，该式变为：\n$$ \\boldsymbol{s} = \\boldsymbol{s}^{\\mathrm{trial}} - \\frac{E\\,\\Delta\\lambda}{\\sigma_y}\\boldsymbol{s} \\implies \\boldsymbol{s}\\left(1 + \\frac{E\\,\\Delta\\lambda}{\\sigma_y}\\right) = \\boldsymbol{s}^{\\mathrm{trial}} $$\n此方程表明最终应力 $\\boldsymbol{s}$ 与试探应力 $\\boldsymbol{s}^{\\mathrm{trial}}$ 共线。这是该屈服准则特有的“径向返回”特性。因此，单位法向量 $\\boldsymbol{n}$ 也与 $\\boldsymbol{s}^{\\mathrm{trial}}$ 共线：\n$$ \\boldsymbol{n} = \\frac{\\boldsymbol{s}^{\\mathrm{trial}}}{\\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_2} $$\n为了求得一致性参数 $\\Delta\\lambda$，我们对 $\\boldsymbol{s}$ 强制施加屈服条件：\n$$ \\|\\boldsymbol{s}\\|_2 = \\left\\| \\frac{\\boldsymbol{s}^{\\mathrm{trial}}}{1 + E\\,\\Delta\\lambda/\\sigma_y} \\right\\|_2 = \\frac{\\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_2}{1 + E\\,\\Delta\\lambda/\\sigma_y} = \\sigma_y $$\n求解 $\\Delta\\lambda$：\n$$ 1 + \\frac{E\\,\\Delta\\lambda}{\\sigma_y} = \\frac{\\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_2}{\\sigma_y} \\implies \\Delta\\lambda = \\frac{\\sigma_y}{E}\\left(\\frac{\\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_2}{\\sigma_y} - 1\\right) = \\frac{1}{E}(\\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_2 - \\sigma_y) $$\n每个增量步的塑性耗散 $J_2$ 定义为 $J = \\boldsymbol{s}\\cdot\\Delta\\boldsymbol{\\varepsilon}^p$。\n$$ J_2 = \\boldsymbol{s} \\cdot (\\Delta\\lambda\\,\\boldsymbol{n}) = \\Delta\\lambda (\\boldsymbol{s}\\cdot\\boldsymbol{n}) $$\n由于 $\\boldsymbol{s}$ 位于屈服面上，$\\boldsymbol{n}$ 是 $\\boldsymbol{s}$ 处的单位法向量，点积 $\\boldsymbol{s}\\cdot\\boldsymbol{n} = (\\sigma_y\\boldsymbol{n}) \\cdot \\boldsymbol{n} = \\sigma_y\\|\\boldsymbol{n}\\|_2^2 = \\sigma_y$。\n因此，耗散为：\n$$ J_2 = \\sigma_y\\,\\Delta\\lambda = \\frac{\\sigma_y}{E}(\\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_2 - \\sigma_y) $$\n$\\ell_2$ 耗散的完整表达式为：\n$$ J_2 = \\begin{cases} \\frac{\\sigma_y}{E} (\\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_2 - \\sigma_y)  \\text{if } \\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_2  \\sigma_y \\\\ 0  \\text{if } \\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_2 \\le \\sigma_y \\end{cases} $$\n\n**2. 非光滑 $\\ell_\\infty$ 屈服面的推导**\n\n非光滑屈服面由 $f_\\infty(\\boldsymbol{s}) = \\|\\boldsymbol{s}\\|_\\infty - \\sigma_y = \\max(|s_1|, |s_2|) - \\sigma_y = 0$ 定义。这在二维应力空间中表示一个顶点位于 $(\\pm\\sigma_y, \\pm\\sigma_y)$ 的正方形。该准则的返回映射算法对应于到凸集 $\\|\\boldsymbol{s}\\|_\\infty \\le \\sigma_y$ 的投影，该凸集即为正方形 $[-\\sigma_y, \\sigma_y] \\times [-\\sigma_y, \\sigma_y]$。在由弹性张量诱导的能量范数下，该投影是逐分量计算的：\n$$ s_i = \\mathrm{sgn}(s_i^{\\mathrm{trial}}) \\min(|s_i^{\\mathrm{trial}}|, \\sigma_y) \\quad \\text{for } i=1,2 $$\n如果 $\\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_\\infty \\le \\sigma_y$，则两个分量都满足 $|s_i^{\\mathrm{trial}}| \\le \\sigma_y$，因此 $\\boldsymbol{s} = \\boldsymbol{s}^{\\mathrm{trial}}$, $\\Delta\\boldsymbol{\\varepsilon}^p = \\boldsymbol{0}$，且耗散 $J_\\infty = 0$。\n如果 $\\|\\boldsymbol{s}^{\\mathrm{trial}}\\|_\\infty  \\sigma_y$，则为塑性步。塑性应变增量可从应力更新法则中求得：\n$$ \\Delta\\boldsymbol{\\varepsilon}^p = \\frac{1}{E}(\\boldsymbol{s}^{\\mathrm{trial}} - \\boldsymbol{s}) $$\n塑性应变的分量为：\n$$ \\Delta\\varepsilon_{p,i} = \\frac{1}{E}(s_i^{\\mathrm{trial}} - \\mathrm{sgn}(s_i^{\\mathrm{trial}}) \\min(|s_i^{\\mathrm{trial}}|, \\sigma_y)) = \\frac{1}{E}\\mathrm{sgn}(s_i^{\\mathrm{trial}})\\max(0, |s_i^{\\mathrm{trial}}| - \\sigma_y) $$\n塑性耗散为 $J_\\infty = \\boldsymbol{s}\\cdot\\Delta\\boldsymbol{\\varepsilon}^p = \\sum_{i=1}^2 s_i \\Delta\\varepsilon_{p,i}$。对于每个分量 $i$：\n- 如果 $|s_i^{\\mathrm{trial}}| \\le \\sigma_y$，则 $s_i = s_i^{\\mathrm{trial}}$ 且 $\\Delta\\varepsilon_{p,i} = 0$，所以其贡献为 $0$。\n- 如果 $|s_i^{\\mathrm{trial}}|  \\sigma_y$，则 $s_i = \\mathrm{sgn}(s_i^{\\mathrm{trial}})\\sigma_y$。对耗散的贡献为：\n$$ s_i \\Delta\\varepsilon_{p,i} = \\left(\\mathrm{sgn}(s_i^{\\mathrm{trial}})\\sigma_y\\right) \\left(\\frac{1}{E}\\mathrm{sgn}(s_i^{\\mathrm{trial}})\\max(0, |s_i^{\\mathrm{trial}}| - \\sigma_y)\\right) = \\frac{\\sigma_y}{E}(|s_i^{\\mathrm{trial}}| - \\sigma_y) $$\n总耗散是这些贡献之和：\n$$ J_\\infty = \\sum_{i=1}^2 \\frac{\\sigma_y}{E} \\max(0, |s_i^{\\mathrm{trial}}| - \\sigma_y) $$\n此表达式正确地捕捉了单面激活（如果只有一个 $\\boldsymbol{s}^{\\mathrm{trial}}$ 的分量在量级上超过 $\\sigma_y$）或角点激活（如果两个分量都超过）的情况。\n\n**3. 目标导向估计与可靠性度量**\n\n任务是使用光滑耗散 $J_2$ 作为代理来构建非光滑耗散 $J_\\infty$ 的估计。我们将估计器定义为：\n$$ J_{\\mathrm{est}} = J_2 $$\n这一选择代表了一种实用的工程方法，即使用一个更简单、解析上更光滑的模型（$\\ell_2$ 或 von Mises 准则）来近似一个更复杂、非光滑模型（$\\ell_\\infty$ 或类 Tresca 准则）的行为。其理由源于两种屈服面的几何相似性；然而，当加载方向指向两种几何形状差异最显著的区域（例如 $\\ell_\\infty$ 正方形的角点）时，这种近似的准确性预计会很差。\n\n为了量化该估计器的性能，我们定义一个可靠性度量 $\\rho$。根据规定，对于非零耗散 $J_\\infty  0$：\n$$ \\rho = 1 - \\frac{|J_{\\mathrm{est}} - J_{\\infty}|}{J_{\\infty}} $$\n对于 $J_\\infty = 0$ 的情况，需要一个有原则的定义。\n- 如果 $J_{\\infty} = 0$ 且 $J_{\\mathrm{est}} = 0$，估计器正确预测了弹性步。误差为零，因此可靠性是完美的。我们定义 $\\rho=1$。\n- 如果 $J_{\\infty} = 0$ 但 $J_{\\mathrm{est}}  0$，估计器错误地预测了塑性流动。这是模型的定性失效。相对误差为无穷大，表明可靠性为零。我们定义 $\\rho=0$。\n综合这些情况，给出 $\\rho$ 的完整定义：\n$$ \\rho = \\begin{cases} 1 - \\frac{|J_2 - J_{\\infty}|}{J_{\\infty}}  \\text{if } J_{\\infty}  0 \\\\ 1  \\text{if } J_{\\infty} = 0 \\text{ and } J_2 = 0 \\\\ 0  \\text{if } J_{\\infty} = 0 \\text{ and } J_2  0 \\end{cases} $$\n\n算法设计是为每个给定的测试用例实现推导出的 $J_2$, $J_\\infty$ 和 $\\rho$ 的公式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes plastic dissipation for smooth and nonsmooth yield surfaces\n    and the reliability of using the smooth model as an estimator for the nonsmooth one.\n    \"\"\"\n    \n    test_cases = [\n        (2.00e11, 3.00e8, np.array([2.0e-3, 5.0e-4])),  # Case 1\n        (2.00e11, 3.00e8, np.array([2.0e-3, 2.0e-3])),  # Case 2\n        (2.00e11, 3.00e8, np.array([1.5e-3, 1.5e-3])),  # Case 3\n        (2.00e11, 3.00e8, np.array([1.8e-3, 2.2e-3])),  # Case 4\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        E, sigma_y, epsilon = case\n        \n        # Calculate the trial stress\n        s_trial = E * epsilon\n        \n        # --- Part 1: Smooth l_2 Dissipation (J_est) ---\n        s_trial_norm2 = np.linalg.norm(s_trial, 2)\n        \n        if s_trial_norm2 > sigma_y:\n            J_2 = (sigma_y / E) * (s_trial_norm2 - sigma_y)\n        else:\n            J_2 = 0.0\n            \n        J_est = J_2\n\n        # --- Part 2: Nonsmooth l_inf Dissipation (J_inf) ---\n        # Component-wise excess stress beyond the yield strength\n        excess_stress = np.maximum(0, np.abs(s_trial) - sigma_y)\n        J_inf = (sigma_y / E) * np.sum(excess_stress)\n\n        # --- Part 3: Reliability Metric rho ---\n        rho = 0.0\n        # Use a small tolerance for floating point comparisons with zero\n        tol = 1e-12\n        if J_inf > tol:\n            rho = 1.0 - abs(J_est - J_inf) / J_inf\n        else:  # J_inf is effectively zero\n            if abs(J_est)  tol: # J_est is also zero\n                rho = 1.0\n            else: # J_inf is zero, but J_est is positive\n                rho = 0.0\n        \n        results.append(rho)\n\n    # Format output according to the problem specification\n    # Example format: [r1,r2,r3,r4]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3593014"}]}