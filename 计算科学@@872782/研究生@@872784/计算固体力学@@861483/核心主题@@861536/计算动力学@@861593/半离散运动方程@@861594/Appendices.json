{"hands_on_practices": [{"introduction": "显式时间积分方法，如中心差分法，因其简单性和易于实现而备受青睐，尤其是在处理高速动态和波传播问题时。然而，它的一个主要缺点是条件稳定性：时间步长必须小于一个由系统最高固有频率决定的临界值，否则数值解将发散。在本实践中[@problem_id:3599566]，您将从第一性原理出发，推导显式中心差分法的稳定性条件，并设计一个自适应时间步长算法，以确保在系统刚度随时间变化时（例如在材料损伤或接触模拟中）数值积分过程的稳定性。", "problem": "考虑通过有限元空间离散化得到的线性弹性系统的半离散运动方程，其形式为 $ \\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K}(t)\\, \\mathbf{u}(t) = \\mathbf{f}(t) $，其中 $ \\mathbf{M} \\in \\mathbb{R}^{n \\times n} $ 是对称正定质量矩阵，$ \\mathbf{K}(t) \\in \\mathbb{R}^{n \\times n} $ 是对称正定刚度矩阵，可能随时间变化，$ \\mathbf{f}(t) $ 是外力向量。假设进行稳定性分析时为自由振动，即 $ \\mathbf{f}(t) = \\mathbf{0} $。显式中心差分时间积分格式通过对 $ \\ddot{\\mathbf{u}}(t) $ 进行离散化并代入半离散运动方程所得到的递推关系，在具有均匀时间步长 $ \\Delta t $ 的离散时间层上推进 $ \\mathbf{u}(t) $。\n\n严格从 Newton 第二定律和有限元半离散化出发，从第一性原理推导应用于 $ \\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K}(t)\\, \\mathbf{u}(t) = \\mathbf{0} $ 的显式中心差分法的谱稳定性条件。证明稳定性要求 $ \\Delta t \\leq \\Delta t_{\\mathrm{crit}} $，其中 $ \\Delta t_{\\mathrm{crit}} = \\dfrac{2}{\\omega_{\\max}} $，$ \\omega_{\\max} = \\sqrt{\\lambda_{\\max}} $，而 $ \\lambda_{\\max} $ 是对称广义特征问题 $ \\mathbf{K}\\, \\boldsymbol{\\phi} = \\lambda\\, \\mathbf{M}\\, \\boldsymbol{\\phi} $ 的最大广义特征值。等效地，证明 $ \\lambda_{\\max} $ 等于相似变换矩阵 $ \\mathbf{M}^{-1/2}\\mathbf{K}\\mathbf{M}^{-1/2} $ 的谱半径，该矩阵与 $ \\mathbf{M}^{-1}\\mathbf{K} $ 具有相同的特征值。\n\n接下来，为 $ \\mathbf{K}(t) $ 随时间变化的场景设计一个安全的自适应时间步长规则，确保显式中心差分格式保持稳定。该规则必须满足以下约束：\n\n- 它必须使用一个安全系数 $ s \\in (0,1) $，应用于瞬时稳定性极限，即 $ \\Delta t_{\\mathrm{raw}}(t) = s \\dfrac{2}{\\sqrt{\\lambda_{\\max}(t)}} $。\n- 它必须限制时间步长的变化率。设 $ r_{\\mathrm{up}} > 1 $ 为每步允许的最大乘性增加率，$ r_{\\mathrm{down}} > 1 $ 为每步允许的最大乘性减少率。在时间 $ t_n $ 和 $ t_{n+1} $，从 $ \\Delta t_n $ 到 $ \\Delta t_{n+1} $ 的更新必须满足\n  $$ \\Delta t_{n+1} \\leq \\min\\!\\big( \\Delta t_{\\mathrm{raw}}(t_{n+1}),\\, r_{\\mathrm{up}}\\, \\Delta t_n \\big), $$\n  并且当 $ \\Delta t_{\\mathrm{raw}}(t_{n+1}) $ 允许时，避免减少速度快于以下界限\n  $$ \\Delta t_{n+1} \\geq \\frac{\\Delta t_n}{r_{\\mathrm{down}}}. $$\n  如果稳定性要求强制更剧烈的下降，则必须将 $ \\Delta t_{n+1} $ 设置为 $ \\Delta t_{\\mathrm{raw}}(t_{n+1}) $ 以确保稳定性。\n- 对于所有时间层 $ n $，它必须强制 $ \\Delta t_{\\min} \\leq \\Delta t_n \\leq \\Delta t_{\\max} $，其中 $ \\Delta t_{\\min} $ 和 $ \\Delta t_{\\max} $ 是预设的界限。\n\n为以下测试套件实现此规则。对于每种情况，计算所需的量并返回指定的输出。所有时间步长值必须以秒为单位表示。所有浮点输出必须四舍五入到八位小数。\n\n- 情况1（恒定刚度，验证 $ \\Delta t_{\\mathrm{crit}} $ 和自适应下的恒定性）：\n  - $ n = 2 $，$ \\mathbf{M} = \\mathrm{diag}(2.0,\\, 1.0)\\, \\mathrm{kg} $，\n  - 连接到墙壁和质量块之间的弹簧通过 $ k_1 = 1200\\, \\mathrm{N/m} $，$ k_2 = 700\\, \\mathrm{N/m} $，$ k_3 = 900\\, \\mathrm{N/m} $ 定义 $ \\mathbf{K} $，其中\n    $$ \\mathbf{K} = \\begin{bmatrix} k_1 + k_2  -k_2 \\\\ -k_2  k_2 + k_3 \\end{bmatrix}. $$\n  - 使用 $ s = 0.95 $，$ r_{\\mathrm{up}} = 1.2 $，$ r_{\\mathrm{down}} = 1.5 $，$ \\Delta t_{\\min} = 10^{-6}\\, \\mathrm{s} $，$ \\Delta t_{\\max} = 10^{-2}\\, \\mathrm{s} $。在 $ [0,\\, 1]\\, \\mathrm{s} $ 内均匀采样21个时间点（尽管 $ \\mathbf{K} $ 是恒定的）。\n  - 输出一个列表 $ [\\Delta t_{\\mathrm{crit}},\\, \\Delta t_{\\mathrm{start}},\\, \\Delta t_{\\mathrm{end}}] $，单位为秒，其中 $ \\Delta t_{\\mathrm{crit}} = \\dfrac{2}{\\sqrt{\\lambda_{\\max}}} $，$ \\Delta t_{\\mathrm{start}} $ 是第一个自适应时间步长，$ \\Delta t_{\\mathrm{end}} $ 是最后一个自适应时间步长。\n\n- 情况2（逐渐变刚的系统，覆盖平滑变化下的自适应）：\n  - $ n = 3 $，$ \\mathbf{M} = \\mathrm{diag}(1.0,\\, 1.5,\\, 2.0)\\, \\mathrm{kg} $，\n  - 基础刚度来自一个三质量链，其弹簧连接到墙壁和相邻质量块：\n    $$ k_{\\mathrm{w}1} = 1000\\, \\mathrm{N/m},\\quad k_{12} = 1500\\, \\mathrm{N/m},\\quad k_{23} = 1200\\, \\mathrm{N/m},\\quad k_{\\mathrm{w}3} = 800\\, \\mathrm{N/m}, $$\n    $$ \\mathbf{K}_0 = \\begin{bmatrix} k_{\\mathrm{w}1} + k_{12}  -k_{12}  0 \\\\ -k_{12}  k_{12} + k_{23}  -k_{23} \\\\ 0  -k_{23}  k_{23} + k_{\\mathrm{w}3} \\end{bmatrix}. $$\n  - 附加刚度矩阵 $ \\mathbf{K}_1 = \\mathrm{diag}(500,\\, 400,\\, 300)\\, \\mathrm{N/m} $ 且 $ \\mathbf{K}(t) = \\mathbf{K}_0 + 0.5\\, t\\, \\mathbf{K}_1 $ 对于 $ t \\in [0,\\, 1]\\, \\mathrm{s} $。\n  - 使用 $ s = 0.85 $，$ r_{\\mathrm{up}} = 1.15 $，$ r_{\\mathrm{down}} = 2.0 $，$ \\Delta t_{\\min} = 10^{-5}\\, \\mathrm{s} $，$ \\Delta t_{\\max} = 5 \\times 10^{-3}\\, \\mathrm{s} $。在 $ [0,\\, 1]\\, \\mathrm{s} $ 内均匀采样51个时间点。\n  - 输出一个列表 $ [\\Delta t_{\\min\\mathrm{series}},\\, \\Delta t_{\\max\\mathrm{series}},\\, \\mathrm{stable}] $，其中 $ \\Delta t_{\\min\\mathrm{series}} $ 和 $ \\Delta t_{\\max\\mathrm{series}} $ 分别是整个序列中的最小和最大自适应时间步长（单位：秒），$ \\mathrm{stable} $ 是一个布尔值，当且仅当对于所有采样时间 $ \\Delta t_n \\le s \\dfrac{2}{\\sqrt{\\lambda_{\\max}(t_n)}} $ 成立时，其值为 $ \\mathrm{True} $。\n\n- 情况3（刚度突变，测试速率限制的边缘情况）：\n  - $ n = 3 $，$ \\mathbf{M} = \\mathrm{diag}(1.0,\\, 2.0,\\, 1.5)\\, \\mathrm{kg} $，\n  - 基础刚度 $ \\mathbf{K}_{\\mathrm{b}} $ 来自一个带弹簧的三质量链：\n    $$ k_{\\mathrm{w}1} = 900\\, \\mathrm{N/m},\\quad k_{12} = 1100\\, \\mathrm{N/m},\\quad k_{23} = 1000\\, \\mathrm{N/m},\\quad k_{\\mathrm{w}3} = 700\\, \\mathrm{N/m}, $$\n    $$ \\mathbf{K}_{\\mathrm{b}} = \\begin{bmatrix} k_{\\mathrm{w}1} + k_{12}  -k_{12}  0 \\\\ -k_{12}  k_{12} + k_{23}  -k_{23} \\\\ 0  -k_{23}  k_{23} + k_{\\mathrm{w}3} \\end{bmatrix}. $$\n  - 定义一个分段刚度 $ \\mathbf{K}(t) = \\mathbf{K}_{\\mathrm{b}} $ 当 $ t  0.6\\, \\mathrm{s} $ 且 $ \\mathbf{K}(t) = 3\\, \\mathbf{K}_{\\mathrm{b}} $ 当 $ t \\ge 0.6\\, \\mathrm{s} $。\n  - 使用 $ s = 0.90 $，$ r_{\\mathrm{up}} = 1.10 $，$ r_{\\mathrm{down}} = 1.30 $，$ \\Delta t_{\\min} = 10^{-5}\\, \\mathrm{s} $，$ \\Delta t_{\\max} = 5 \\times 10^{-3}\\, \\mathrm{s} $。在 $ [0,\\, 1]\\, \\mathrm{s} $ 内均匀采样101个时间点。\n  - 输出一个列表 $ [R_{\\mathrm{inc}},\\, R_{\\mathrm{dec}},\\, \\mathrm{stable}] $，其中 $ R_{\\mathrm{inc}} = \\max\\limits_{n} \\dfrac{\\Delta t_{n+1}}{\\Delta t_n} $ 和 $ R_{\\mathrm{dec}} = \\min\\limits_{n} \\dfrac{\\Delta t_{n+1}}{\\Delta t_n} $ 是整个序列中的比值，而 $ \\mathrm{stable} $ 是如上定义的布尔值。\n\n您的程序应生成一行输出，其中包含所有三种情况的结果，形式为一个以逗号分隔的列表，并用方括号括起来（例如，$ [\\mathrm{case1}, \\mathrm{case2}, \\mathrm{case3}] $），其中每个 $ \\mathrm{case} $ 本身也是一个遵循上述规范的列表。所有浮点值必须以秒为单位，并四舍五入到八位小数，布尔值必须以标准的 Python 大小写形式 $ \\mathrm{True} $ 或 $ \\mathrm{False} $ 打印。", "solution": "该问题被评估为有效。它基于计算固体力学的原理，是适定的，并包含推导稳定性条件和实现指定的自适应时间步长算法所需的所有必要信息。\n\n### 第1部分：谱稳定性条件的推导\n\n分析始于线性弹性系统在自由振动下的半离散运动方程：\n$$ \\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K}(t)\\, \\mathbf{u}(t) = \\mathbf{0} $$\n此处，$ \\mathbf{M} $ 是对称正定质量矩阵，$ \\mathbf{K}(t) $ 是对称正定刚度矩阵。\n\n显式中心差分法使用一个二阶精度的有限差分公式来近似离散时间 $ t_n $ 处的加速度：\n$$ \\ddot{\\mathbf{u}}_n \\approx \\frac{\\mathbf{u}_{n+1} - 2\\mathbf{u}_n + \\mathbf{u}_{n-1}}{(\\Delta t)^2} $$\n其中 $ \\mathbf{u}_n = \\mathbf{u}(t_n) $，$ \\Delta t $ 是时间步长。\n\n将此近似代入时间 $ t_n $ 的运动方程，假设刚度矩阵是局部恒定的 $ \\mathbf{K}_n = \\mathbf{K}(t_n) $，我们有：\n$$ \\mathbf{M} \\left( \\frac{\\mathbf{u}_{n+1} - 2\\mathbf{u}_n + \\mathbf{u}_{n-1}}{(\\Delta t)^2} \\right) + \\mathbf{K}_n \\mathbf{u}_n = \\mathbf{0} $$\n整理以求解下一个时间步的位移 $ \\mathbf{u}_{n+1} $，得到中心差分格式的递推关系：\n$$ \\mathbf{M} \\mathbf{u}_{n+1} = 2\\mathbf{M}\\mathbf{u}_n - \\mathbf{M}\\mathbf{u}_{n-1} - (\\Delta t)^2 \\mathbf{K}_n \\mathbf{u}_n $$\n由于 $ \\mathbf{M} $ 是可逆的，我们可以写出：\n$$ \\mathbf{u}_{n+1} = \\left( 2\\mathbf{I} - (\\Delta t)^2 \\mathbf{M}^{-1} \\mathbf{K}_n \\right) \\mathbf{u}_n - \\mathbf{u}_{n-1} $$\n\n对于 von Neumann 稳定性分析，我们分析系统单个模态的行为。我们将解投影到广义特征向量 $ \\boldsymbol{\\phi}_i $ 的基上，这些向量是广义特征问题 $ \\mathbf{K} \\boldsymbol{\\phi}_i = \\lambda_i \\mathbf{M} \\boldsymbol{\\phi}_i $ 的解。特征值 $ \\lambda_i = \\omega_i^2 $ 是系统自有频率的平方。位移向量可以表示为这些模态的叠加：$ \\mathbf{u}(t) = \\sum_i q_i(t) \\boldsymbol{\\phi}_i $，其中 $q_i(t)$ 是模态坐标。这将系统解耦为一组单自由度（SDOF）振子：\n$$ \\ddot{q}_i(t) + \\omega_i^2 q_i(t) = 0 $$\n多自由度积分格式的稳定性由应用于最高频率 $ \\omega_{\\max} $ 模态的单自由度积分器的稳定性决定。\n\n将中心差分格式应用于频率为 $ \\omega $ 的模态的单自由度方程：\n$$ \\frac{q_{n+1} - 2q_n + q_{n-1}}{(\\Delta t)^2} + \\omega^2 q_n = 0 $$\n$$ q_{n+1} = (2 - (\\omega \\Delta t)^2) q_n - q_{n-1} $$\n为分析此递推的稳定性，我们将其表述为一阶系统。设状态向量为 $ \\mathbf{z}_n = \\{ q_n, q_{n-1} \\}^T $。则更新为 $ \\mathbf{z}_{n+1} = \\mathbf{A} \\mathbf{z}_n $，其中 $ \\mathbf{A} $ 是放大矩阵：\n$$ \\mathbf{A} = \\begin{bmatrix} 2 - (\\omega \\Delta t)^2  -1 \\\\ 1  0 \\end{bmatrix} $$\n如果放大矩阵的谱半径 $ \\rho(\\mathbf{A}) $ 小于或等于 $ 1 $，则该格式是稳定的。$ \\mathbf{A} $ 的特征值 $ \\gamma $ 由特征方程 $ \\det(\\mathbf{A} - \\gamma \\mathbf{I}) = 0 $ 给出：\n$$ \\gamma^2 - (2 - (\\omega \\Delta t)^2)\\gamma + 1 = 0 $$\n其根为：\n$$ \\gamma_{1,2} = \\frac{2 - (\\omega \\Delta t)^2 \\pm \\sqrt{(2 - (\\omega \\Delta t)^2)^2 - 4}}{2} $$\n对于稳定的非耗散响应，特征值 $ \\gamma $ 必须是单位圆上的复共轭对，这要求判别式为非正：\n$$ (2 - (\\omega \\Delta t)^2)^2 - 4 \\leq 0 $$\n$$ (2 - (\\omega \\Delta t)^2)^2 \\leq 4 $$\n$$ -2 \\leq 2 - (\\omega \\Delta t)^2 \\leq 2 $$\n这简化为 $ (\\omega \\Delta t)^2 \\leq 4 $，或 $ \\omega \\Delta t \\leq 2 $。在极限 $ \\omega \\Delta t = 2 $ 时，特征值在 $ \\gamma = -1 $ 处合并。这会导致弱不稳定性（共振），因为在这种情况下放大矩阵是不可对角化的。超过此极限，一个特征值的模大于1，导致数值误差指数增长。\n\n因此，为了保证稳定性，条件 $ \\omega \\Delta t \\leq 2 $ 必须对系统中的所有频率都成立。最严格的约束由最高频率 $ \\omega_{\\max} $ 施加：\n$$ \\omega_{\\max} \\Delta t \\leq 2 \\implies \\Delta t \\leq \\frac{2}{\\omega_{\\max}} $$\n这定义了稳定性的临界时间步长，$ \\Delta t_{\\mathrm{crit}} = \\frac{2}{\\omega_{\\max}} $。\n最高频率通过 $ \\omega_{\\max} = \\sqrt{\\lambda_{\\max}} $ 与广义特征问题 $ \\mathbf{K} \\boldsymbol{\\phi} = \\lambda \\mathbf{M} \\boldsymbol{\\phi} $ 的最大广义特征值 $ \\lambda_{\\max} $ 相关。因此，稳定性条件是：\n$$ \\Delta t \\leq \\frac{2}{\\sqrt{\\lambda_{\\max}}} $$\n\n为了证明广义特征问题与标准特征问题之间的关系，我们可以对广义问题进行变换。由于 $ \\mathbf{M} $ 是对称正定的，它的 Cholesky 因子或谱分解存在，这允许我们定义一个可逆矩阵 $ \\mathbf{M}^{-1/2} $。用 $ \\mathbf{M}^{-1/2} $ 左乘广义特征问题得到：\n$$ \\mathbf{M}^{-1/2} \\mathbf{K} \\boldsymbol{\\phi} = \\lambda \\mathbf{M}^{1/2} \\boldsymbol{\\phi} $$\n通过插入 $ \\mathbf{I} = \\mathbf{M}^{-1/2} \\mathbf{M}^{1/2} $ 并定义一个新向量 $ \\boldsymbol{\\psi} = \\mathbf{M}^{1/2} \\boldsymbol{\\phi} $，我们得到：\n$$ (\\mathbf{M}^{-1/2} \\mathbf{K} \\mathbf{M}^{-1/2}) \\boldsymbol{\\psi} = \\lambda \\boldsymbol{\\psi} $$\n这是一个关于矩阵 $ \\tilde{\\mathbf{K}} = \\mathbf{M}^{-1/2} \\mathbf{K} \\mathbf{M}^{-1/2} $ 的标准特征值问题。由于 $ \\mathbf{M} $ 和 $ \\mathbf{K} $ 是对称的，$ \\tilde{\\mathbf{K}} $ 也是对称的。它的特征值 $ \\lambda $ 与矩阵对 $ (\\mathbf{K}, \\mathbf{M}) $ 的广义特征值相同。\n此外，矩阵 $ \\mathbf{M}^{-1}\\mathbf{K} $ 与 $ \\tilde{\\mathbf{K}} $ 相似（因为 $ \\mathbf{B}\\mathbf{A} $ 与 $ \\mathbf{A}\\mathbf{B} $ 相似），所以它们有相同的特征值。因此，$ \\lambda_{\\max} $ 等效地是对称矩阵 $ \\mathbf{M}^{-1/2}\\mathbf{K}\\mathbf{M}^{-1/2} $ 或非对称矩阵 $ \\mathbf{M}^{-1}\\mathbf{K} $ 的最大特征值（谱半径）。对称形式在数值计算中更受青睐。\n\n### 第2部分：自适应时间步长算法的实现\n\n自适应时间步长规则根据问题陈述中指定的逻辑实现。对于每种情况，我们计算一系列时间步长。\n设 $ \\Delta t_n $ 为第 $ n $ 步的时间步长，设 $ t_{n+1} $ 为评估下一步 $ n+1 $ 的刚度矩阵的时间。\n\n1.  计算瞬时最大角频率 $ \\omega_{\\max}(t_{n+1}) = \\sqrt{\\lambda_{\\max}(\\mathbf{K}(t_{n+1}), \\mathbf{M})} $。\n2.  计算原始的稳定性限制时间步长：$ \\Delta t_{\\mathrm{raw}}(t_{n+1}) = s \\frac{2}{\\omega_{\\max}(t_{n+1})} $。\n3.  从 $ \\Delta t_n $ 更新到 $ \\Delta t_{n+1} $ 的逻辑如下：\n    a. 根据最大减少率定义下限：$ \\Delta t_{\\mathrm{dec\\_lim}} = \\Delta t_n / r_{\\mathrm{down}} $。\n    b. 如果 $ \\Delta t_{\\mathrm{raw}}(t_{n+1})  \\Delta t_{\\mathrm{dec\\_lim}} $，为保证稳定性需要急剧减小步长。规则指定将新时间步长设置为原始极限值：$ \\Delta t_{\\mathrm{cand}} = \\Delta t_{\\mathrm{raw}}(t_{n+1}) $。\n    c. 否则，新步长受最大增加率和原始稳定性极限的限制：$ \\Delta t_{\\mathrm{inc\\_lim}} = r_{\\mathrm{up}} \\Delta t_n $，且 $ \\Delta t_{\\mathrm{cand}} = \\min(\\Delta t_{\\mathrm{raw}}(t_{n+1}), \\Delta t_{\\mathrm{inc\\_lim}}) $。\n4.  最后，此候选步长被全局最小和最大界限所限制：$ \\Delta t_{n+1} = \\min(\\Delta t_{\\max}, \\max(\\Delta t_{\\min}, \\Delta t_{\\mathrm{cand}})) $。\n5.  序列的第一个时间步长根据 $ t_0 $ 处的原始稳定性极限进行初始化，并被 $ \\Delta t_{\\min} $ 和 $ \\Delta t_{\\max} $ 所限制。\n6.  `stable` 布尔标志是通过检查是否对所有步长 $n$ 都有 $ \\Delta t_n \\le \\Delta t_{\\mathrm{raw}}(t_n) / s $ 来确定的。注意，规则是 $ \\Delta t \\le 2/\\omega_{\\max} $，所以我们应对照 $\\Delta t_{\\mathrm{raw}}/s$进行检查。然而，问题将检查表述为 $ \\Delta t_n \\le s \\dfrac{2}{\\sqrt{\\lambda_{\\max}(t_n)}} $，即 $ \\Delta t_n \\le \\Delta t_{\\mathrm{raw}}(t_n) $。这是所实现的检查。\n\n以下代码实现了此逻辑并计算了三个测试用例所需的输出。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef adaptive_time_stepping(times, M, K_func, s, r_up, r_down, dt_min, dt_max):\n    \"\"\"\n    Implements the adaptive time stepping algorithm.\n    \n    Returns:\n        dt_series: List of adaptive time steps.\n        dt_raw_series: List of raw stability-limited time steps.\n        is_stable: Boolean indicating if all steps were stable.\n    \"\"\"\n    num_samples = len(times)\n    dt_series = []\n    dt_raw_series = []\n    \n    # Initial step\n    t0 = times[0]\n    K0 = K_func(t0)\n    try:\n        eigvals = eigh(K0, M, eigvals_only=True)\n        lambda_max_0 = eigvals[-1]\n        w_max_0 = np.sqrt(lambda_max_0)\n        dt_raw_0 = s * 2.0 / w_max_0\n    except np.linalg.LinAlgError:\n        # Handle singular matrix cases if they were to occur, not expected here\n        dt_raw_0 = dt_min\n        \n    dt_raw_series.append(dt_raw_0)\n    \n    dt_current = min(dt_max, max(dt_min, dt_raw_0))\n    dt_series.append(dt_current)\n    \n    is_stable = (dt_current = dt_raw_0)\n\n    # Subsequent steps\n    for i in range(1, num_samples):\n        dt_prev = dt_series[-1]\n        t_i = times[i]\n        K_i = K_func(t_i)\n        \n        try:\n            eigvals = eigh(K_i, M, eigvals_only=True)\n            lambda_max_i = eigvals[-1]\n            if lambda_max_i = 0: # Physically unexpected but for robustness\n                 w_max_i = np.inf\n                 dt_raw_i = dt_min\n            else:\n                 w_max_i = np.sqrt(lambda_max_i)\n                 dt_raw_i = s * 2.0 / w_max_i\n        except np.linalg.LinAlgError:\n            dt_raw_i = dt_min\n            \n        dt_raw_series.append(dt_raw_i)\n        \n        # Adaptive rule\n        dt_decrease_limit = dt_prev / r_down\n        \n        if dt_raw_i  dt_decrease_limit:\n            dt_cand = dt_raw_i\n        else:\n            dt_increase_limit = dt_prev * r_up\n            dt_cand = min(dt_raw_i, dt_increase_limit)\n            \n        # Global bounds\n        dt_next = min(dt_max, max(dt_min, dt_cand))\n        dt_series.append(dt_next)\n        \n        if not (dt_next = dt_raw_i):\n            is_stable = False\n            \n    return dt_series, dt_raw_series, is_stable\n\ndef solve():\n    \"\"\"\n    Solves the three test cases and prints the results.\n    \"\"\"\n    all_results = []\n    ROUND_DIGITS = 8\n\n    # --- Case 1 ---\n    M1 = np.diag([2.0, 1.0])\n    k1, k2, k3 = 1200.0, 700.0, 900.0\n    K1_const = np.array([[k1 + k2, -k2], [-k2, k2 + k3]])\n    \n    def K_func1(t):\n        return K1_const\n        \n    params1 = {\n        's': 0.95, 'r_up': 1.2, 'r_down': 1.5,\n        'dt_min': 1e-6, 'dt_max': 1e-2\n    }\n    times1 = np.linspace(0, 1, 21)\n    \n    lambda_max_1 = eigh(K1_const, M1, eigvals_only=True)[-1]\n    dt_crit_1 = 2.0 / np.sqrt(lambda_max_1)\n    \n    dt_series1, _, _ = adaptive_time_stepping(times1, M1, K_func1, **params1)\n    dt_start_1 = dt_series1[0]\n    dt_end_1 = dt_series1[-1]\n    \n    all_results.append([\n        round(dt_crit_1, ROUND_DIGITS),\n        round(dt_start_1, ROUND_DIGITS),\n        round(dt_end_1, ROUND_DIGITS)\n    ])\n\n    # --- Case 2 ---\n    M2 = np.diag([1.0, 1.5, 2.0])\n    k_w1, k_12, k_23, k_w3 = 1000.0, 1500.0, 1200.0, 800.0\n    K0_2 = np.array([\n        [k_w1 + k_12, -k_12, 0],\n        [-k_12, k_12 + k_23, -k_23],\n        [0, -k_23, k_23 + k_w3]\n    ])\n    K1_2 = np.diag([500.0, 400.0, 300.0])\n    \n    def K_func2(t):\n        return K0_2 + 0.5 * t * K1_2\n\n    params2 = {\n        's': 0.85, 'r_up': 1.15, 'r_down': 2.0,\n        'dt_min': 1e-5, 'dt_max': 5e-3\n    }\n    times2 = np.linspace(0, 1, 51)\n    \n    dt_series2, _, is_stable2 = adaptive_time_stepping(times2, M2, K_func2, **params2)\n    dt_min_series2 = min(dt_series2)\n    dt_max_series2 = max(dt_series2)\n    \n    all_results.append([\n        round(dt_min_series2, ROUND_DIGITS),\n        round(dt_max_series2, ROUND_DIGITS),\n        is_stable2\n    ])\n    \n    # --- Case 3 ---\n    M3 = np.diag([1.0, 2.0, 1.5])\n    k_w1_3, k_12_3, k_23_3, k_w3_3 = 900.0, 1100.0, 1000.0, 700.0\n    Kb_3 = np.array([\n        [k_w1_3 + k_12_3, -k_12_3, 0],\n        [-k_12_3, k_12_3 + k_23_3, -k_23_3],\n        [0, -k_23_3, k_23_3 + k_w3_3]\n    ])\n    \n    def K_func3(t):\n        if t  0.6:\n            return Kb_3\n        else:\n            return 3.0 * Kb_3\n            \n    params3 = {\n        's': 0.90, 'r_up': 1.10, 'r_down': 1.30,\n        'dt_min': 1e-5, 'dt_max': 5e-3\n    }\n    times3 = np.linspace(0, 1, 101)\n    \n    dt_series3, _, is_stable3 = adaptive_time_stepping(times3, M3, K_func3, **params3)\n    \n    ratios = [dt_series3[i+1] / dt_series3[i] for i in range(len(dt_series3) - 1)]\n    R_inc = max(ratios)\n    R_dec = min(ratios)\n    \n    all_results.append([\n        round(R_inc, ROUND_DIGITS),\n        round(R_dec, ROUND_DIGITS),\n        is_stable3\n    ])\n\n    # --- Format and Print Output ---\n    def format_item(item):\n        if isinstance(item, float):\n            return f\"{item:.{ROUND_DIGITS}f}\"\n        return repr(item)\n\n    results_str_parts = []\n    for res_list in all_results:\n        res_list_str = [format_item(item) for item in res_list]\n        results_str_parts.append(f\"[{','.join(res_list_str)}]\")\n    \n    print(f\"[{','.join(results_str_parts)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3599566"}, {"introduction": "在确保了时间积分的稳定性之后，我们必须关注空间离散化带来的精度问题。有限元网格本身会引入数值误差，这会影响不同波长的波在介质中的传播速度，这种现象被称为数值频散。在本实践中[@problem_id:3599584]，您将通过Bloch-Floquet分析，对二维标量波动模型的有限元离散化进行严格的频散分析，量化不同阶次单元以及一致质量矩阵与集中质量矩阵（一种常用于显式积分的近似）对相速度误差的影响。", "problem": "您需要为一个通过张量积四边形有限元离散化的二维标量波模型，推导、实现并评估其半离散运动方程的数值色散分析。推导必须从基本线性动量平衡和弱形式的定义开始，并由此导出半离散系统。随后，您必须量化二次单元中由质量集中引入的相速度误差，并将其与一致质量公式的结果进行比较。您的实现必须是一个可运行的程序，该程序能够构建所需的矩阵，施加布洛赫周期性边界条件，并数值计算色散关系。\n\n基本原理如下。从连续介质中的牛顿第二定律开始：对于一个标量位移场 $u(\\boldsymbol{x},t)$，其控制方程为 $ \\rho \\, \\ddot{u} - \\nabla \\cdot (\\mathbb{C} \\nabla u) = 0 $，其中 $\\rho$ 是质量密度，$\\mathbb{C}$ 是一个对称正常数，通过 $ c = \\sqrt{\\mathbb{C} / \\rho} $ 设定波速，上方的点号表示对时间的求导。在边长为 $h$ 的均匀正方形单元上，通过Galerkin有限元方法得到相应的半离散运动方程为\n$$\n\\boldsymbol{M} \\, \\ddot{\\boldsymbol{u}}(t) + \\boldsymbol{K} \\, \\boldsymbol{u}(t) = \\boldsymbol{0},\n$$\n其中 $ \\boldsymbol{M} $ 和 $ \\boldsymbol{K} $ 是由弱形式导出的单元贡献组装而成的一致质量矩阵和刚度矩阵。质量集中通过对单元级质量矩阵进行行求和得到的对角近似，来代替一致质量矩阵。\n\n为了量化色散，考虑在一个由相同正方形单元铺砌而成的无限晶格中的布洛赫周期波。设晶格矢量为 $h \\boldsymbol{e}_x$ 和 $h \\boldsymbol{e}_y$。对于一个给定的实波数矢量 $\\boldsymbol{k} = (k_x,k_y)$，其大小为 $ |\\boldsymbol{k}| = \\sqrt{k_x^2 + k_y^2} $，单位为 $\\mathrm{rad/m}$，布洛赫边界条件要求\n$$\nu(\\boldsymbol{x} + h \\, \\boldsymbol{e}_x, t) = u(\\boldsymbol{x}, t) \\, e^{\\mathrm{i} k_x h}, \\quad\nu(\\boldsymbol{x} + h \\, \\boldsymbol{e}_y, t) = u(\\boldsymbol{x}, t) \\, e^{\\mathrm{i} k_y h}.\n$$\n当将这些关系应用于单个正方形参考单元上的半离散系统时，它们会导出一个厄米（Hermitian）的、简化的广义特征值问题\n$$\n\\left( \\boldsymbol{K}_{\\mathrm{red}}(\\boldsymbol{k}) - \\omega^2 \\, \\boldsymbol{M}_{\\mathrm{red}}(\\boldsymbol{k}) \\right) \\boldsymbol{\\varphi} = \\boldsymbol{0},\n$$\n其最小正特征值 $ \\omega^2 $ 给出了对应于该 $\\boldsymbol{k}$ 的数值预测角频率 $ \\omega $。于是，数值相速度为 $ v_p^{\\mathrm{num}} = \\omega / |\\boldsymbol{k}| $，精确相速度为 $ v_p^{\\mathrm{ex}} = c $。相对相速度误差为\n$$\n\\varepsilon(\\boldsymbol{k}; h, p) = \\frac{v_p^{\\mathrm{num}}(\\boldsymbol{k}; h, p)}{c} - 1,\n$$\n其中 $ p $ 是单元基在每个参数方向上的多项式阶数。您必须计算一致质量和集中质量两种情况下的 $ |\\varepsilon| $。\n\n您必须遵循的实现细节：\n- 在边长为 $h$ 的单个正方形单元上使用多项式阶数 $p \\in \\{1,2\\}$ 的张量积四边形单元作为周期性晶胞。对于 $p=1$，使用定义在参考正方形 $[-1,1]^2$ 上且节点位于角点的双线性形函数；对于 $p=2$，使用双二次拉格朗日形函数，其在每个参数方向上的一维节点位于 $\\{-1,0,1\\}$。\n- 通过对相应次数的多项式精确的数值积分来构建单元矩阵。对于 $p=1$，使用 $2 \\times 2$ 高斯点；对于 $p=2$，使用 $3 \\times 3$ 高斯点。单元刚度为\n$$\nK_{ij}^{(e)} = \\mathbb{C} \\int_{\\Omega_e} \\nabla N_i \\cdot \\nabla N_j \\, \\mathrm{d}\\Omega,\n$$\n单元质量为\n$$\nM_{ij}^{(e)} = \\rho \\int_{\\Omega_e} N_i \\, N_j \\, \\mathrm{d}\\Omega.\n$$\n- 对于质量集中，在组装到晶胞的全局质量矩阵之前，将每个单元质量矩阵 $ \\boldsymbol{M}^{(e)} $ 替换为其行和对角阵。组装单晶胞的全局矩阵，并通过使用复相位约束消除从属自由度来施加布洛赫周期性。这将得到简化的厄米对 $ (\\boldsymbol{K}_{\\mathrm{red}}(\\boldsymbol{k}), \\boldsymbol{M}_{\\mathrm{red}}(\\boldsymbol{k})) $。\n- 对于每个 $\\boldsymbol{k}$，求解简化的广义特征值问题的最小正特征值，并计算 $ |\\varepsilon| $。\n\n物理和数值单位：\n- 使用 $ \\rho = 1.0 \\, \\mathrm{kg/m^3} $，$ \\mathbb{C} = 1.0 \\, \\mathrm{Pa} $，因此 $ c = \\sqrt{\\mathbb{C}/\\rho} = 1.0 \\, \\mathrm{m/s} $。\n- 所有长度 $h$ 的单位必须是 $ \\mathrm{m} $，所有波数 $k_x, k_y$ 的单位必须是 $ \\mathrm{rad/m} $，所有角频率 $ \\omega $ 的单位必须是 $ \\mathrm{rad/s} $。\n- 将相速度误差报告为无量纲浮点数（无单位）。\n\n测试套件和要求的输出：\n- 使用以下三个测试用例，每个用例由单元尺寸 $h$（单位为 $ \\mathrm{m} $）和多项式阶数 $p$ 指定：\n  1. 用例 $1$：$h = 1.0$, $p = 1$。\n  2. 用例 $2$：$h = 1.0$, $p = 2$。\n  3. 用例 $3$：$h = 0.5$, $p = 2$。\n- 对于每个用例，在一组波数对（单位为 $ \\mathrm{rad/m} $）上评估色散：\n$$\n\\mathcal{K} = \\left\\{ (k,0), (0,k), \\left( \\frac{k}{\\sqrt{2}}, \\frac{k}{\\sqrt{2}} \\right) \\, : \\, k \\in \\{ 0.5, 1.0, 1.5, 2.0 \\} \\right\\}.\n$$\n- 对于每个用例，计算：\n  - 使用一致质量计算 $E_{\\mathrm{cons}}^{\\max} = \\max_{(k_x,k_y) \\in \\mathcal{K}} \\left| \\varepsilon_{\\mathrm{cons}}( (k_x,k_y); h, p ) \\right|$。\n  - 使用集中质量计算 $E_{\\mathrm{lump}}^{\\max} = \\max_{(k_x,k_y) \\in \\mathcal{K}} \\left| \\varepsilon_{\\mathrm{lump}}( (k_x,k_y); h, p ) \\right|$。\n  - $\\Delta E^{\\max} = E_{\\mathrm{lump}}^{\\max} - E_{\\mathrm{cons}}^{\\max}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个包含三个条目的列表 $[E_{\\mathrm{cons}}^{\\max}, E_{\\mathrm{lump}}^{\\max}, \\Delta E^{\\max}]$，顺序与上文相同。例如，输出格式必须为：\n\"[ [E1_cons,E1_lump,E1_delta], [E2_cons,E2_lump,E2_delta], [E3_cons,E3_lump,E3_delta] ]\"\n使用普通十进制浮点数。\n\n数值算法必须是通用的，不得硬编码任何解析色散公式。它必须通过积分计算单元矩阵，通过复数值约束施加布洛赫周期性边界条件，并求解简化的厄米广义特征值问题以提取数值角频率。所有结果必须在程序内针对指定的测试套件进行计算，并且不允许用户输入。", "solution": "用户提供了一个在计算固体力学领域定义明确的问题，该问题涉及二维标量波方程的有限元离散化的数值色散分析。问题要求对线性和二次四边形单元，比较一致质量与集中质量两种公式下的相速度误差。\n\n### 第1步：提取已知条件\n- **控制方程**：标量波方程为 $ \\rho \\, \\ddot{u} - \\nabla \\cdot (\\mathbb{C} \\nabla u) = 0 $。\n- **波速**：精确的连续介质相速度为 $ c = \\sqrt{\\mathbb{C} / \\rho} $。\n- **半离散系统**：在边长为 $h$ 的均匀正方形单元网格上进行有限元离散化，得到 $ \\boldsymbol{M} \\, \\ddot{\\boldsymbol{u}}(t) + \\boldsymbol{K} \\, \\boldsymbol{u}(t) = \\boldsymbol{0} $。\n- **Bloch-Floquet分析**：对于波数矢量为 $\\boldsymbol{k} = (k_x, k_y)$ 的波，应用周期性条件 $u(\\boldsymbol{x} + h \\, \\boldsymbol{e}_x, t) = u(\\boldsymbol{x}, t) \\, e^{\\mathrm{i} k_x h}$ 和 $u(\\boldsymbol{x} + h \\, \\boldsymbol{e}_y, t) = u(\\boldsymbol{x}, t) \\, e^{\\mathrm{i} k_y h}$。\n- **简化的特征值问题**：这导出了在单个晶胞上的广义特征值问题：$ \\left( \\boldsymbol{K}_{\\mathrm{red}}(\\boldsymbol{k}) - \\omega^2 \\, \\boldsymbol{M}_{\\mathrm{red}}(\\boldsymbol{k}) \\right) \\boldsymbol{\\varphi} = \\boldsymbol{0} $。\n- **数值色散**：最小正特征值 $\\omega^2$ 给出数值频率 $\\omega$。数值相速度为 $ v_p^{\\mathrm{num}} = \\omega / |\\boldsymbol{k}| $。\n- **误差度量**：相对相速度误差为 $ \\varepsilon(\\boldsymbol{k}; h, p) = (v_p^{\\mathrm{num}}/c) - 1 $。任务是计算给定波数集合上的最大绝对误差。\n- **有限元**：多项式阶数 $p=1$（双线性，4节点）和 $p=2$（双二次，9节点）的张量积四边形单元。\n- **单元矩阵**：\n  - 刚度：$K_{ij}^{(e)} = \\mathbb{C} \\int_{\\Omega_e} \\nabla N_i \\cdot \\nabla N_j \\, \\mathrm{d}\\Omega$。\n  - 质量：$M_{ij}^{(e)} = \\rho \\int_{\\Omega_e} N_i \\, N_j \\, \\mathrm{d}\\Omega$。\n- **数值积分**：对 $p=1$ 使用 $2 \\times 2$ 高斯积分，对 $p=2$ 使用 $3 \\times 3$ 高斯积分。\n- **质量集中**：集中质量矩阵是通过对一致单元质量矩阵的行求和得到的对角矩阵。\n- **物理参数**：$ \\rho = 1.0 \\, \\mathrm{kg/m^3} $，$ \\mathbb{C} = 1.0 \\, \\mathrm{Pa} $，这意味着 $ c = 1.0 \\, \\mathrm{m/s} $。\n- **测试用例**：\n  1. $h = 1.0 \\, \\mathrm{m}$，$p = 1$。\n  2. $h = 1.0 \\, \\mathrm{m}$，$p = 2$。\n  3. $h = 0.5 \\, \\mathrm{m}$，$p = 2$。\n- **波数集合**：$\\mathcal{K} = \\left\\{ (k,0), (0,k), \\left( \\frac{k}{\\sqrt{2}}, \\frac{k}{\\sqrt{2}} \\right) \\, : \\, k \\in \\{ 0.5, 1.0, 1.5, 2.0 \\} \\right\\} \\, \\mathrm{rad/m}$。\n- **要求的输出**：对于每个测试用例，计算一个包含 $[E_{\\mathrm{cons}}^{\\max}, E_{\\mathrm{lump}}^{\\max}, \\Delta E^{\\max}]$ 的列表，其中 $E^{\\max} = \\max_{\\boldsymbol{k} \\in \\mathcal{K}} |\\varepsilon|$ 分别对应一致质量和集中质量，$\\Delta E^{\\max} = E_{\\mathrm{lump}}^{\\max} - E_{\\mathrm{cons}}^{\\max}$。最终输出必须是表示这些列表的列表的单个字符串。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学依据、是适定且客观的。它为计算波传播领域的标准数值实验提供了一套完整且一致的指令。物理参数为方便起见进行了简化，但在物理上是一致的。从连续介质方程到最终的简化特征值问题的数学框架是标准且合理的。计算任务被清晰地指定并且是可行的。未发现任何缺陷。\n\n### 第3步：结论与行动\n问题有效。将提供一个完整的解决方案。\n\n### 基于原理的解决方案设计\n解决方案的核心在于为标量波方程实现有限元方法（FEM），然后应用Bloch-Floquet理论来分析由此产生的半离散系统的色散特性。\n\n**1. 有限元公式化：**\n该过程从控制方程的弱形式开始，通过应用带有形函数 $N_i$ 的Galerkin方法，导出单元级质量矩阵 $\\boldsymbol{M}^{(e)}$ 和刚度矩阵 $\\boldsymbol{K}^{(e)}$。这些矩阵在一个单一的方形参考单元 $[-1,1]^2$ 上计算，然后缩放到物理单元尺寸 $h$。\n- **形函数**：对于一个多项式阶数为 $p$ 的单元，我们使用 $p$ 次一维拉格朗日多项式的张量积。对于 $p=1$，这得到4个双线性函数。对于 $p=2$，这得到9个双二次函数。\n- **数值积分**：$\\boldsymbol{M}^{(e)}$ 和 $\\boldsymbol{K}^{(e)}$ 的积分使用高斯-勒让德（Gauss-Legendre）积分法进行数值计算。该规则的阶数必须足以精确积分多项式乘积；一个 $(p+1) \\times (p+1)$ 点的规则是足够的。\n- **映射**：一个标准的等参映射将导数从参考空间 $(\\xi, \\eta)$ 变换到物理空间 $(x, y)$，这涉及到变换的雅可比矩阵。对于方形单元，这种缩放是均匀的。\n\n**2. 质量集中：**\n质量集中是一种近似方法，通过对角化质量矩阵来简化半离散方程的时间积分。这避免了在每个时间步求解一个线性系统。此处采用最常见的集中方案，即行和集中。集中质量矩阵的每个对角项是相应一致质量矩阵行的所有项之和。此操作在任何组装之前在单元级别执行。\n\n**3. 用于色散分析的Bloch-Floquet边界条件：**\n为了分析在无限周期性单元晶格中的波传播，我们将单个单元视为重复的晶胞。Bloch-Floquet定理指出，对于一个波数为 $\\boldsymbol{k}$ 的波，相邻晶胞中对应点处的解通过一个复相位因子相关联。这使我们能将问题从无限数量的自由度（DOF）简化为仅与一个晶胞相关的自由度。\n- **主从自由度**：单个晶胞内的自由度被划分。位于晶胞内部及其“主”边界（例如，底部和左侧）上的自由度被指定为“主”自由度。相对的“次”边界（顶部和右侧）上的自由度是“从属”的，因为它们的值受Bloch相位关系约束于主自由度。对于一个 $p$ 阶单元，有 $p^2$ 个主自由度。\n- **系统简化**：构建一个变换矩阵 $\\boldsymbol{L}(\\boldsymbol{k})$，用以仅通过主自由度来表达单元中的所有自由度：$\\boldsymbol{u} = \\boldsymbol{L}(\\boldsymbol{k}) \\boldsymbol{u}_{\\mathrm{master}}$。将此代入全晶胞的能量表达式 $\\frac{1}{2}\\boldsymbol{u}^H \\boldsymbol{K} \\boldsymbol{u}$ 和 $\\frac{1}{2}\\boldsymbol{u}^H \\boldsymbol{M} \\boldsymbol{u}$，得到简化的矩阵 $\\boldsymbol{K}_{\\mathrm{red}} = \\boldsymbol{L}^H \\boldsymbol{K} \\boldsymbol{L}$ 和 $\\boldsymbol{M}_{\\mathrm{red}} = \\boldsymbol{L}^H \\boldsymbol{M} \\boldsymbol{L}$。这些矩阵是厄米矩阵，维度为 $p^2 \\times p^2$。\n\n**4. 特征值问题和误差计算：**\n假设一个时谐解 $\\boldsymbol{u}(t) = \\boldsymbol{\\varphi} e^{-\\mathrm{i}\\omega t}$，半离散方程变成一个广义特征值问题：$\\boldsymbol{K}_{\\mathrm{red}}\\boldsymbol{\\varphi} = \\omega^2 \\boldsymbol{M}_{\\mathrm{red}}\\boldsymbol{\\varphi}$。\n- **求解**：我们对每个波数 $\\boldsymbol{k}$ 求解此问题，以找到相应的数值频率 $\\omega$。由于 $\\boldsymbol{K}_{\\mathrm{red}}$ 和 $\\boldsymbol{M}_{\\mathrm{red}}$ 是厄米矩阵且是正（半）定的，特征值 $\\omega^2$ 是实数且非负。我们寻找最小的正特征值，它对应于最低频率的声波模式。\n- **误差量化**：数值相速度计算为 $v_p^{\\mathrm{num}} = \\omega / |\\boldsymbol{k}|$。将其与精确的连续介质相速度 $c=1.0$ 进行比较，以求得相对误差 $\\varepsilon$。最终报告的值是针对给定测试用例，在所有指定波数上绝对误差 $|\\varepsilon|$ 的最大值。\n该代码实现了从生成单元矩阵到求解最终特征值问题并整理结果的整个流程。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Derives, implements, and evaluates a numerical dispersion analysis for a 2D scalar wave model\n    discretized by quadrilateral finite elements, as specified in the problem description.\n    \"\"\"\n\n    def get_lagrange_1d(p, xi_eval):\n        \"\"\"\n        Computes 1D Lagrange polynomials and their derivatives at a point xi_eval.\n        Args:\n            p (int): Polynomial order (1 or 2).\n            xi_eval (float): Evaluation point in [-1, 1].\n        Returns:\n            tuple: (N, dN) where N are shape function values and dN are their derivatives.\n        \"\"\"\n        if p == 1:\n            N = np.array([0.5 * (1 - xi_eval), 0.5 * (1 + xi_eval)])\n            dN = np.array([-0.5, 0.5])\n        elif p == 2:\n            N = np.array([\n                0.5 * xi_eval * (xi_eval - 1.0),\n                1.0 - xi_eval**2,\n                0.5 * xi_eval * (xi_eval + 1.0)\n            ])\n            dN = np.array([\n                xi_eval - 0.5,\n                -2.0 * xi_eval,\n                xi_eval + 0.5\n            ])\n        else:\n            raise ValueError(\"Polynomial order p must be 1 or 2.\")\n        return N, dN\n\n    def get_element_matrices(h, p, C_const, rho):\n        \"\"\"\n        Constructs the element stiffness (K_e) and mass (M_e) matrices.\n        Args:\n            h (float): Element side length.\n            p (int): Polynomial order.\n            C_const (float): Stiffness-like material constant.\n            rho (float): Mass density.\n        Returns:\n            tuple: (K_e, M_e) numpy arrays.\n        \"\"\"\n        n_nodes_1d = p + 1\n        n_nodes_total = n_nodes_1d**2\n        \n        K_e = np.zeros((n_nodes_total, n_nodes_total))\n        M_e = np.zeros((n_nodes_total, n_nodes_total))\n\n        n_quad_pts = p + 1\n        xi_quad, w_quad = np.polynomial.legendre.leggauss(n_quad_pts)\n\n        detJ = (h / 2.0)**2\n        \n        for iq, xi in enumerate(xi_quad):\n            for jq, eta in enumerate(xi_quad):\n                wq = w_quad[iq]\n                wj = w_quad[jq]\n\n                N_vals = np.zeros(n_nodes_total)\n                grad_N_vals_ref = np.zeros((n_nodes_total, 2))\n                \n                N_1d_xi, dN_1d_xi = get_lagrange_1d(p, xi)\n                N_1d_eta, dN_1d_eta = get_lagrange_1d(p, eta)\n\n                for i in range(n_nodes_total):\n                    ix = i % n_nodes_1d\n                    iy = i // n_nodes_1d\n                    N_vals[i] = N_1d_xi[ix] * N_1d_eta[iy]\n                    grad_N_vals_ref[i, 0] = dN_1d_xi[ix] * N_1d_eta[iy]\n                    grad_N_vals_ref[i, 1] = N_1d_xi[ix] * dN_1d_eta[iy]\n\n                grad_N_vals_phys = grad_N_vals_ref * (2.0 / h)\n\n                weight = wq * wj * detJ\n                N_outer = np.outer(N_vals, N_vals)\n                grad_outer = grad_N_vals_phys @ grad_N_vals_phys.T\n                \n                M_e += rho * N_outer * weight\n                K_e += C_const * grad_outer * weight\n                        \n        return K_e, M_e\n\n    def build_L_matrix(p, h, kx, ky):\n        \"\"\"\n        Builds the transformation matrix L(k) for Bloch periodicity.\n        This matrix maps the master DOFs to all DOFs in the unit cell.\n        Args:\n            p (int): Polynomial order.\n            h (float): Element side length.\n            kx (float): Wavenumber in x-direction.\n            ky (float): Wavenumber in y-direction.\n        Returns:\n            numpy.ndarray: The complex-valued L matrix.\n        \"\"\"\n        n_nodes_1d = p + 1\n        n_nodes_total = n_nodes_1d**2\n        n_master_nodes = p**2\n        \n        L = np.zeros((n_nodes_total, n_master_nodes), dtype=np.complex128)\n        \n        master_map = {}\n        master_idx_counter = 0\n        for i in range(n_nodes_total):\n            ix = i % n_nodes_1d\n            iy = i // n_nodes_1d\n            if ix  p and iy  p:\n                master_map[i] = master_idx_counter\n                master_idx_counter += 1\n\n        for i in range(n_nodes_total):\n            ix = i % n_nodes_1d\n            iy = i // n_nodes_1d\n            \n            master_ix = ix % p\n            master_iy = iy % p\n            master_node_idx_full = master_ix + master_iy * n_nodes_1d\n            master_node_idx_reduced = master_map[master_node_idx_full]\n            \n            nx = ix // p\n            ny = iy // p\n            phase = np.exp(1j * (nx * kx * h + ny * ky * h))\n            \n            L[i, master_node_idx_reduced] = phase\n            \n        return L\n    \n    def calculate_phase_error(h, p, kx, ky, rho, C_const, c_exact, mass_lumping):\n        \"\"\"\n        Computes the relative phase velocity error for a given configuration.\n        \"\"\"\n        K_e, M_e = get_element_matrices(h, p, C_const, rho)\n        \n        if mass_lumping:\n            M_e = np.diag(np.sum(M_e, axis=1))\n            \n        L = build_L_matrix(p, h, kx, ky)\n        \n        K_red = L.conj().T @ K_e @ L\n        M_red = L.conj().T @ M_e @ L\n        \n        # Solve generalized eigenvalue problem: K_red * v = omega^2 * M_red * v\n        eigvals = eigh(K_red, M_red, eigvals_only=True)\n        \n        # Eigenvalues omega^2 are real and sorted. Smallest positive one is for the acoustic mode.\n        # For k != 0, the smallest eigenvalue should be positive.\n        omega_sq = eigvals[0]\n        if omega_sq  0: omega_sq = 0.0\n\n        omega_num = np.sqrt(omega_sq)\n        k_mag = np.sqrt(kx**2 + ky**2)\n        \n        if k_mag  1e-12:\n            return 0.0\n            \n        v_num = omega_num / k_mag\n        error = (v_num / c_exact) - 1.0\n        \n        return error\n\n    # Main execution logic starts here\n    test_cases = [\n        (1.0, 1),\n        (1.0, 2),\n        (0.5, 2)\n    ]\n    \n    k_magnitudes = [0.5, 1.0, 1.5, 2.0]\n    k_vectors = []\n    for k in k_magnitudes:\n        k_vectors.append((k, 0.0))\n        k_vectors.append((0.0, k))\n        k_vectors.append((k / np.sqrt(2.0), k / np.sqrt(2.0)))\n\n    rho = 1.0\n    C_const = 1.0\n    c_exact = np.sqrt(C_const / rho)\n\n    all_results = []\n    for h, p in test_cases:\n        max_err_cons = 0.0\n        max_err_lump = 0.0\n\n        for kx, ky in k_vectors:\n            err_cons = calculate_phase_error(h, p, kx, ky, rho, C_const, c_exact, mass_lumping=False)\n            max_err_cons = max(max_err_cons, abs(err_cons))\n\n            err_lump = calculate_phase_error(h, p, kx, ky, rho, C_const, c_exact, mass_lumping=True)\n            max_err_lump = max(max_err_lump, abs(err_lump))\n        \n        delta_max_err = max_err_lump - max_err_cons\n        all_results.append([max_err_cons, max_err_lump, delta_max_err])\n\n    # Format output string exactly as required\n    result_strings = []\n    for res_triplet in all_results:\n        result_strings.append(f\"[{res_triplet[0]},{res_triplet[1]},{res_triplet[2]}]\")\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3599584"}, {"introduction": "许多工程问题涉及非线性和约束，例如结构间的接触，这为求解半离散运动方程带来了巨大挑战。这些约束通常以变分不等式的形式出现，无法直接通过求解线性方程组来处理。在本实践中[@problem_id:3599599]，您将探索一种用于求解约束动力学问题的现代且强大的方法——交替方向乘子法（ADMM）。您需要将一个单自由度的接触问题构建为一个凸二次规划问题，并利用ADMM算法进行求解，从而深入了解如何将先进的优化技术应用于计算力学中。", "problem": "设计并实现一个求解器，该求解器使用交替方向乘子法 (ADMM) 或等效的交替最小二乘 (ALS) 分裂法，在受零位移处刚性顶棚约束的单自由度线性弹性振子的半离散运动方程中施加单边接触约束。单个隐式后向欧拉时间步的半离散方程由牛顿第二定律和胡克定律推导得出，其形式如下：求解下一步的位移 $u_{n+1}$ 和接触乘子 $\\lambda$，使得\n$$\nM \\ddot{u}_{n+1} + K u_{n+1} + B^{\\mathsf{T}} \\lambda = f_{n+1},\n$$\n其中运动学更新为 $u_{n+1} = u_n + h v_{n+1}$，其中 $M$ 为质量，$K$ 为线性刚度，$f_{n+1}$ 为时间 $t_{n+1}$ 时的外部载荷，$h$ 为时间步长，$B$ 为线性化接触算子。对于由 $g(u) = u$ 定义的标量接触间隙函数，该函数施加了一个位于 $u \\le 0$ 的刚性顶棚约束，单边约束为 $g(u_{n+1}) \\le 0$。使用后向欧拉法消去加速度和速度，以获得一个关于 $u_{n+1}$ 的线性-二次目标函数和一个单一的线性不等式约束 $g(u_{n+1}) \\le 0$，且不引入任何阻尼。具体来说，推导出有效系统\n$$\nH u_{n+1} + B^{\\mathsf{T}} \\lambda = r,\n$$\n其中 $H$ 和 $r$ 是 $M$、$K$、$h$、$u_n$、$v_n$ 和 $f_{n+1}$ 的函数，且对于 $g(u) = u$，$B = 1$。\n\n你的任务是：\n- 仅从牛顿第二定律和后向欧拉时间离散化出发，推导关于 $u_{n+1}$ 的凸二次规划问题，该问题包含单边不等式 $g(u_{n+1}) \\le 0$。\n- 构建缩放形式的 ADMM 更新式，以一致性形式求解该问题，其中使用一个辅助变量 $z$ 通过投影来施加约束集 $\\mathcal{C} = (-\\infty, 0]$。使用带有惩罚参数 $\\rho  0$ 的标准缩放形式。更新结构必须在 $u$ 的最小二乘步骤和 $z$ 的投影步骤之间交替进行。\n- 实现 ADMM 迭代并监控：\n  1. 原始残差 $r_p^k = \\lVert g(u^k) - z^k \\rVert_2$。\n  2. 增广目标序列\n     $$\n     \\Phi_\\rho^k = \\tfrac{1}{2} u^{k\\mathsf{T}} H u^k - r^{\\mathsf{T}} u^k + I_{\\mathcal{C}}(z^k) + \\tfrac{\\rho}{2} \\lVert B u^k - z^k \\rVert_2^2,\n     $$\n     其中，如果 $z \\in \\mathcal{C}$，$I_{\\mathcal{C}}(z)$ 为 $0$，否则为 $+\\infty$。由于 $z$ 的更新是到 $\\mathcal{C}$ 上的精确投影，因此在迭代过程中 $I_{\\mathcal{C}}(z^k) = 0$。\n- 当原始残差和对偶残差均低于一个容差时，或当达到最大迭代次数时，停止迭代。在此设置下，缩放 ADMM 的对偶残差为 $s^k = \\rho \\lVert z^k - z^{k-1} \\rVert_2$。\n\n物理和数值单位及约定：\n- 将 $u$、$v$ 和 $h$ 的单位视为米和秒，$M$ 的单位视为千克，$K$ 的单位视为牛顿/米，$f$ 和 $\\lambda$ 的单位视为牛顿。虽然 ADMM 残差和增广目标函数使用的是算法单位，但要确保所有物理输入都遵守这些单位。\n- 不使用角度；无需指定角度单位。\n\n测试套件和要求的输出：\n- 使用以下三个测试用例，每个用例使用相同的 ADMM 参数。对于所有用例，设置缩放 ADMM 惩罚参数为 $\\rho = 1000$，最大迭代次数为 $N_{\\max} = 200$，原始残差的绝对容差为 $\\varepsilon_p = 10^{-10}$，对偶残差的绝对容差为 $\\varepsilon_d = 10^{-10}$。\n- 对于每个用例，使用后向欧拉法根据给定数据构建 $H$ 和 $r$，然后从无约束解 $u^{0} = H^{-1} r$ 和 $z^{0} = \\min(0, u^{0})$，$y^{0} = 0$ 开始运行 ADMM。\n- 测试用例 (所有量必须严格按照所列值使用)：\n  1. 正常路径主动接触：$M = 1$，$K = 1000$，$h = 0.05$，$u_n = -0.01$，$v_n = 0$，$f_{n+1} = 30$。\n  2. 严格非激活接触：$M = 1$，$K = 1000$，$h = 0.05$，$u_n = -0.01$，$v_n = 0$，$f_{n+1} = 0$。\n  3. 边界 (刚好激活) 接触：$M = 1$，$K = 1000$，$h = 0.05$，$u_n = -0.01$，$v_n = 0$，$f_{n+1} = 4$。\n- 对于每个测试用例，你的程序必须计算并返回：\n  1. 最终的原始残差 $r_p$，作为一个浮点数，四舍五入到六位小数。\n  2. 一个布尔标志，指示增广目标序列 $\\{\\Phi_\\rho^k\\}_{k=0}^{k_{\\text{final}}}$ 是否非递增，即对于所有 $k$，$\\Phi_\\rho^{k+1} \\le \\Phi_\\rho^{k} + \\delta$，其中 $\\delta = 10^{-12}$ 是一个数值松弛量。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含三个测试用例的结果，形式为一个包含三个项目的逗号分隔列表，每个项目都是一个双元素列表 $[r_p, \\text{flag}]$。例如，输出必须看起来像 $[[0.0,True],[0.0,True],[0.0,True]]$，但要使用上述测试套件的实际计算值和布尔值。", "solution": "该问题是有效的，因为它在科学上基于计算固体力学的原理，在数学上是适定的，并且使用了客观、明确的语言和充足的数据进行了说明。我们开始进行求解。\n\n任务是求解带单边接触约束的单自由度线性弹性振子的半离散运动方程。解决方案将通过首先推导单个时间步的有效系统，将问题表述为凸二次规划，然后构建并实现交替方向乘子法 (ADMM) 算法来制定。\n\n### 1. 有效系统的推导\n\n时间 $t_{n+1}$ 时的运动方程由牛顿第二定律给出，包括刚度力和接触力：\n$$\nM \\ddot{u}_{n+1} + K u_{n+1} + B^{\\mathsf{T}} \\lambda = f_{n+1}\n$$\n其中 $M$ 是质量，$K$ 是刚度，$u_{n+1}$ 是位移，$\\ddot{u}_{n+1}$ 是加速度，$f_{n+1}$ 是外力，$\\lambda$ 是接触力乘子，$B^{\\mathsf{T}}$ 是线性化接触算子的转置。\n\n我们使用隐式后向欧拉法来离散化时间导数。速度 $v_{n+1}$ 和加速度 $\\ddot{u}_{n+1}$ 近似为：\n$$\nv_{n+1} = \\frac{u_{n+1} - u_n}{h}\n$$\n$$\n\\ddot{u}_{n+1} = \\frac{v_{n+1} - v_n}{h} = \\frac{1}{h} \\left( \\frac{u_{n+1} - u_n}{h} - v_n \\right) = \\frac{1}{h^2} (u_{n+1} - u_n - h v_n)\n$$\n其中 $u_n$ 和 $v_n$ 是前一时间步 $t_n$ 的位移和速度，$h$ 是时间步长。\n\n将 $\\ddot{u}_{n+1}$ 的表达式代入运动方程，得到：\n$$\nM \\left( \\frac{u_{n+1} - u_n - h v_n}{h^2} \\right) + K u_{n+1} + B^{\\mathsf{T}} \\lambda = f_{n+1}\n$$\n为了得到有效系统，我们重新排列各项，将包含未知位移 $u_{n+1}$ 的项分组到左侧，将所有已知量分组到右侧：\n$$\n\\frac{M}{h^2} u_{n+1} + K u_{n+1} + B^{\\mathsf{T}} \\lambda = f_{n+1} + \\frac{M}{h^2} (u_n + h v_n)\n$$\n提取出 $u_{n+1}$，我们得到指定的形式 $H u_{n+1} + B^{\\mathsf{T}} \\lambda = r$：\n$$\n\\left( \\frac{M}{h^2} + K \\right) u_{n+1} + B^{\\mathsf{T}} \\lambda = f_{n+1} + \\frac{M}{h^2} (u_n + h v_n)\n$$\n由此，我们确定了有效刚度矩阵（在本例中为标量）$H$ 和有效力向量（标量）$r$：\n$$\nH = \\frac{M}{h^2} + K\n$$\n$$\nr = f_{n+1} + \\frac{M}{h^2} (u_n + h v_n)\n$$\n接触间隙函数为 $g(u) = u$，这意味着线性化算子 $B = \\frac{\\partial g}{\\partial u} = 1$。\n\n### 2. 二次规划表述\n\n方程 $H u_{n+1} - r = -B^{\\mathsf{T}}\\lambda$ 是受约束的能量泛函的平稳性条件。该问题可以表述为一个约束优化问题。无约束动力学对应于最小化二次目标函数 $\\mathcal{E}(u) = \\frac{1}{2} u H u - r u$。单边接触约束强制要求 $g(u_{n+1}) \\le 0$，对于 $g(u)=u$ 来说，这简化为 $u_{n+1} \\le 0$。\n\n因此，问题就是找到位移 $u_{n+1}$，以求解以下凸二次规划 (QP) 问题：\n$$\n\\begin{aligned}\n \\underset{u_{n+1}}{\\text{minimize}}\n  \\frac{1}{2} u_{n+1} H u_{n+1} - r u_{n+1} \\\\\n \\text{subject to}\n  u_{n+1} \\le 0\n\\end{aligned}\n$$\n\n### 3. ADMM 表述与更新\n\n为了使用 ADMM 求解此 QP，我们引入一个辅助变量 $z$ 并将问题转换为一致性形式。约束 $u_{n+1} \\le 0$ 通过要求 $z \\in \\mathcal{C} = (-\\infty, 0]$ 并设置 $u_{n+1} = z$ 来强制执行。\n优化问题变为：\n$$\n\\begin{aligned}\n \\underset{u, z}{\\text{minimize}}\n  \\left(\\frac{1}{2} u H u - r u\\right) + I_{\\mathcal{C}}(z) \\\\\n \\text{subject to}\n  u - z = 0\n\\end{aligned}\n$$\n其中 $u$ 是我们的未知量 $u_{n+1}$，$I_{\\mathcal{C}}(z)$ 是集合 $\\mathcal{C}$ 的指示函数，如果 $z \\in \\mathcal{C}$，则为 $0$，否则为 $+\\infty$。\n\n此问题的缩放增广拉格朗日函数为：\n$$\n\\mathcal{L}_{\\rho}(u, z, y) = \\frac{1}{2} u H u - r u + I_{\\mathcal{C}}(z) + \\frac{\\rho}{2} \\lVert u - z + y \\rVert_2^2 - \\frac{\\rho}{2}\\lVert y \\rVert_2^2\n$$\n其中 $y$ 是缩放对偶变量，$\\rho > 0$ 是惩罚参数。ADMM 算法迭代地对 $\\mathcal{L}_{\\rho}$ 关于 $u$ 和 $z$ 进行最小化，然后更新对偶变量 $y$。对于第 $k$ 次迭代，更新如下：\n\n1.  **$u$-最小化：** 我们通过最小化 $\\mathcal{L}_{\\rho}(u, z^k, y^k)$ 关于 $u$ 来更新 $u^{k+1}$。这涉及到求解 $\\nabla_u \\mathcal{L}_{\\rho} = 0$：\n    $$\n    H u - r + \\rho (u - z^k + y^k) = 0 \\implies (H + \\rho) u = r + \\rho(z^k - y^k)\n    $$\n    由于 $H$ 是一个标量， $u$ 的更新式为：\n    $$\n    u^{k+1} = \\frac{r + \\rho(z^k - y^k)}{H + \\rho}\n    $$\n\n2.  **$z$-最小化：** 我们通过最小化 $\\mathcal{L}_{\\rho}(u^{k+1}, z, y^k)$ 关于 $z$ 来更新 $z^{k+1}$：\n    $$\n    z^{k+1} = \\underset{z}{\\arg\\min} \\left( I_{\\mathcal{C}}(z) + \\frac{\\rho}{2} \\lVert u^{k+1} - z + y^k \\rVert_2^2 \\right)\n    $$\n    这是一个投影问题。解是将点 $(u^{k+1} + y^k)$ 投影到集合 $\\mathcal{C} = (-\\infty, 0]$ 上。\n    $$\n    z^{k+1} = \\Pi_{\\mathcal{C}}(u^{k+1} + y^k) = \\min(0, u^{k+1} + y^k)\n    $$\n\n3.  **对偶变量更新：** 缩放对偶变量 $y$ 更新如下：\n    $$\n    y^{k+1} = y^k + u^{k+1} - z^{k+1}\n    $$\n算法初始化为 $u^0 = H^{-1}r$，$z^0 = \\min(0, u^0)$ 和 $y^0 = 0$。\n\n### 4. 监控与停止准则\n\n算法的收敛性通过原始残差和对偶残差进行监控。\n-   **原始残差：** $r_p^{k+1} = \\lVert u^{k+1} - z^{k+1} \\rVert_2 = |u^{k+1} - z^{k+1}|$。这衡量了一致性约束 $u=z$ 的违反程度。\n-   **对偶残差：** $s_d^{k+1} = \\rho \\lVert z^{k+1} - z^k \\rVert_2 = \\rho |z^{k+1} - z^k|$。这衡量了辅助变量的变化，与平稳性条件相关。\n\n当两个残差都低于它们各自的容差 $\\varepsilon_p$ 和 $\\varepsilon_d$ 时，或者当达到最大迭代次数 $N_{\\max}$ 时，迭代终止。\n\n此外，我们监控增广目标序列 $\\Phi_\\rho^k$：\n$$\n\\Phi_\\rho^k = \\frac{1}{2} (u^k)^2 H - r u^k + \\frac{\\rho}{2} (u^k - z^k)^2\n$$\n问题要求检查此序列是否非递增，即 $\\Phi_\\rho^{k+1} \\le \\Phi_\\rho^k + \\delta$，其中 $\\delta$ 是一个小的数值松弛量。这个性质对于检查算法的正确实现和收敛行为是一个有用的诊断工具。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_admm_case(case_data, admm_params):\n    \"\"\"\n    Runs the ADMM solver for a single test case.\n\n    Args:\n        case_data (tuple): Contains physical parameters (M, K, h, u_n, v_n, f_np1).\n        admm_params (dict): Contains ADMM parameters (rho, N_max, eps_p, eps_d, delta).\n\n    Returns:\n        list: A list containing the final primal residual (rounded) and a boolean\n              indicating if the objective function was non-increasing.\n    \"\"\"\n    M, K, h, u_n, v_n, f_np1 = case_data\n    rho = admm_params['rho']\n    N_max = admm_params['N_max']\n    eps_p = admm_params['eps_p']\n    eps_d = admm_params['eps_d']\n    delta = admm_params['delta']\n\n    # 1. Construct the effective system: H u + B^T lambda = r\n    # For this scalar problem, B = 1.\n    H = M / h**2 + K\n    r = f_np1 + (M / h**2) * (u_n + h * v_n)\n\n    # 2. ADMM Initialization, as per problem statement\n    # u^0 = H^{-1} r\n    u_k = r / H\n    # z^0 = min(0, u^0)\n    z_k = min(0.0, u_k)\n    # y^0 = 0\n    y_k = 0.0\n\n    obj_values = []\n    \n    # Calculate initial augmented objective Phi^0\n    # The term I_C(z^k) = 0 because z^k is always projected onto C.\n    # Phi_rho^k = 0.5 * u^k H u^k - r u^k + 0.5 * rho * ||u^k - z^k||^2\n    obj_k = 0.5 * H * u_k**2 - r * u_k + 0.5 * rho * (u_k - z_k)**2\n    obj_values.append(obj_k)\n    \n    final_rp = np.abs(u_k - z_k)\n    \n    # 3. ADMM Iteration Loop\n    for _ in range(N_max):\n        z_prev = z_k\n\n        # u-update (solve u-minimization problem)\n        u_k = (r + rho * (z_k - y_k)) / (H + rho)\n\n        # z-update (projection onto C = (-inf, 0])\n        z_k = min(0.0, u_k + y_k)\n\n        # y-update (dual variable update)\n        y_k = y_k + u_k - z_k\n\n        # Calculate current augmented objective Phi^{k+1}\n        obj_k = 0.5 * H * u_k**2 - r * u_k + 0.5 * rho * (u_k - z_k)**2\n        obj_values.append(obj_k)\n\n        # Calculate residuals for stopping criteria\n        # Primal residual r_p = ||u^k - z^k||_2\n        # Dual residual s_d = rho * ||z^k - z^{k-1}||_2\n        r_p = np.abs(u_k - z_k)\n        s_d = rho * np.abs(z_k - z_prev)\n\n        final_rp = r_p\n        \n        # Check for convergence\n        if r_p  eps_p and s_d  eps_d:\n            break\n\n    # 4. Check if the augmented objective sequence is non-increasing\n    is_non_increasing = True\n    for i in range(len(obj_values) - 1):\n        if obj_values[i+1] > obj_values[i] + delta:\n            is_non_increasing = False\n            break\n            \n    # 5. Return the required results\n    return [round(final_rp, 6), is_non_increasing]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver, and print results.\n    \"\"\"\n    # Define common ADMM parameters for all test cases\n    ADMM_PARAMS = {\n        'rho': 1000.0,\n        'N_max': 200,\n        'eps_p': 1e-10,\n        'eps_d': 1e-10,\n        'delta': 1e-12, # Slack for non-increasing objective check\n    }\n\n    # Define the test cases from the problem statement\n    # Each tuple is (M, K, h, u_n, v_n, f_{n+1})\n    test_cases = [\n        # 1. Happy-path active contact\n        (1.0, 1000.0, 0.05, -0.01, 0.0, 30.0),\n        # 2. Strictly inactive contact\n        (1.0, 1000.0, 0.05, -0.01, 0.0, 0.0),\n        # 3. Boundary (just active) contact\n        (1.0, 1000.0, 0.05, -0.01, 0.0, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_admm_case(case, ADMM_PARAMS)\n        results.append(result)\n\n    # Format the final output string exactly as required\n    results_str = [f\"[{r[0]},{r[1]}]\" for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3599599"}]}