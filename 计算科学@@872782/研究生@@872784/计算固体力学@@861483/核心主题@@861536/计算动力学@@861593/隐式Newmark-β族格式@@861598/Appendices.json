{"hands_on_practices": [{"introduction": "本次实践是理解隐式 Newmark-β 方法的基石。我们将聚焦于一个简单的单自由度（SDOF）线性振子，并推导构成隐式求解过程核心的“有效系统”。通过从零开始实现该过程 [@problem_id:3573229]，您将具体地理解算法系数是如何产生的，如何执行时间步更新，并学会通过计算放大矩阵的谱半径来评估格式的稳定性。", "problem": "你需要设计并实现一个程序，用于计算计算固体力学中隐式 Newmark-beta 族时间积分格式的有效系统和算法系数，并利用这些系数对单自由度 (SDOF) 线性振子执行单步更新，并通过放大矩阵评估其线性稳定性。\n\n从牛顿第二运动定律推导出的 SDOF 系统基本运动控制方程开始：\n$$\nm \\, \\ddot{u}(t) + c \\, \\dot{u}(t) + k \\, u(t) = f(t),\n$$\n其中 $m$ 是质量，$c$ 是粘性阻尼系数，$k$ 是线性刚度，$u(t)$ 是位移，$\\dot{u}(t)$ 是速度，$\\ddot{u}(t)$ 是加速度，$f(t)$ 是外力。必须统一使用单位：$m$ 的单位是 $\\mathrm{kg}$，$c$ 的单位是 $\\mathrm{N \\cdot s/m}$，$k$ 的单位是 $\\mathrm{N/m}$，$t$ 的单位是 $\\mathrm{s}$，$u$ 的单位是 $\\mathrm{m}$，$\\dot{u}$ 的单位是 $\\mathrm{m/s}$，$\\ddot{u}$ 的单位是 $\\mathrm{m/s^2}$，$f$ 的单位是 $\\mathrm{N}$。\n\n隐式 Newmark-beta 族格式使用两个参数 $ \\beta $ 和 $ \\gamma $，将时刻 $t_{n+1}=t_n+\\Delta t$ 的 $u_{n+1}$、$v_{n+1}$ 和 $a_{n+1}$ 与时刻 $t_n$ 的已知状态 $(u_n, v_n, a_n)$ 联系起来，时间步长 $\\Delta t > 0$ 为固定值。基于上述内容，推导隐式求解 $u_{n+1}$ 所需的一致有效系统，以及在 SDOF 情况下出现在有效刚度和有效荷载中的相关算法系数。然后，使用相同的原理和 Newmark-beta 方法的离散更新关系，推导从 $u_{n+1}$ 和已知的先前状态恢复 $a_{n+1}$ 和 $v_{n+1}$ 的公式。最后，为齐次问题（$f \\equiv 0$）定义将状态向量 $[u_n, v_n, a_n]^T$ 映射到 $[u_{n+1}, v_{n+1}, a_{n+1}]^T$ 的线性放大映射，并通过直接构造该映射来确定给定参数下的谱半径。\n\n你的程序必须实现这些步骤，并为下面的每个测试用例计算：\n- 隐式 Newmark-beta 格式的有效系统和荷载组装中出现的六个算法系数（量纲一致）。\n- 在 $t_{n+1}$ 进行隐式求解时，SDOF 系统的有效标量刚度 $k_{\\mathrm{eff}}$。\n- 使用给定的 $f_{n+1}$ 和先前状态 $(u_n, v_n, a_n)$，从有效系统计算出的单步更新位移 $u_{n+1}$。\n- 与给定 $(m,c,k,\\Delta t,\\beta,\\gamma)$ 的齐次（$f \\equiv 0$）离散更新映射相关的放大矩阵的谱半径 $\\rho$。\n\n使用一致的国际单位制。将谱半径 $\\rho$ 报告为无量纲实数。将 $k_{\\mathrm{eff}}$ 报告为 $\\mathrm{N/m}$，将 $u_{n+1}$ 报告为 $\\mathrm{m}$。不要进行四舍五入；使用标准双精度浮点运算进行计算。\n\n测试套件（每个用例定义了 $t_n$ 时的参数和先前状态，以及 $t_{n+1}$ 时的外力）：\n1. 用例 A（正常路径，轻阻尼）：\n   - $m = 2.0 \\, \\mathrm{kg}$，$c = 0.5 \\, \\mathrm{N \\cdot s/m}$，$k = 50.0 \\, \\mathrm{N/m}$，$\\Delta t = 0.1 \\, \\mathrm{s}$，$\\beta = 0.25$，$\\gamma = 0.5$。\n   - 先前状态：$u_n = 0.02 \\, \\mathrm{m}$，$v_n = 0.0 \\, \\mathrm{m/s}$，$a_n = 0.0 \\, \\mathrm{m/s^2}$。\n   - 下一步的外力：$f_{n+1} = 1.0 \\, \\mathrm{N}$。\n2. 用例 B（无阻尼，刚性，小时间步长）：\n   - $m = 1.0 \\, \\mathrm{kg}$，$c = 0.0 \\, \\mathrm{N \\cdot s/m}$，$k = 1000.0 \\, \\mathrm{N/m}$，$\\Delta t = 0.01 \\, \\mathrm{s}$，$\\beta = 0.3025$，$\\gamma = 0.6$。\n   - 先前状态：$u_n = 0.0 \\, \\mathrm{m}$，$v_n = 1.0 \\, \\mathrm{m/s}$，$a_n = 0.0 \\, \\mathrm{m/s^2}$。\n   - 下一步的外力：$f_{n+1} = 0.0 \\, \\mathrm{N}$。\n3. 用例 C（重阻尼，大时间步长）：\n   - $m = 1.0 \\, \\mathrm{kg}$，$c = 5.0 \\, \\mathrm{N \\cdot s/m}$，$k = 20.0 \\, \\mathrm{N/m}$，$\\Delta t = 0.2 \\, \\mathrm{s}$，$\\beta = 0.25$，$\\gamma = 0.6$。\n   - 先前状态：$u_n = -0.1 \\, \\mathrm{m}$，$v_n = 0.5 \\, \\mathrm{m/s}$，$a_n = 0.0 \\, \\mathrm{m/s^2}$。\n   - 下一步的外力：$f_{n+1} = 0.0 \\, \\mathrm{N}$。\n\n你的程序必须：\n- 推导并使用一致的隐式 Newmark-beta 有效系统和算法系数。\n- 针对给定的 $f_{n+1}$ 和先前状态，组装并求解标量有效系统以获得 $u_{n+1}$。\n- 使用 Newmark-beta 更新关系，从 $u_{n+1}$ 和先前状态恢复 $a_{n+1}$ 和 $v_{n+1}$。\n- 通过将单步映射应用于齐次问题的三个规范基初始状态，构建 $3 \\times 3$ 放大矩阵，并计算其谱半径 $\\rho$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个包含三个结果的列表，每个测试用例一个结果，其中每个测试用例结果本身是按以下顺序排列的九个浮点数的列表：\n  $[k_{\\mathrm{eff}}, a_0, a_1, a_2, a_3, a_4, a_5, \\rho, u_{n+1}]$。\n- 该行必须完全是一个 Python 风格的列表字面量，不带任何额外文本，例如：\n  $[[\\dots\\text{用例 A 的九个值}\\dots],[\\dots\\text{用例 B 的九个值}\\dots],[\\dots\\text{用例 C 的九个值}\\dots]]$。", "solution": "该问题要求设计并实现一个程序，使用隐式 Newmark-beta 族时间积分格式来分析单自由度 (SDOF) 线性振子。这包括推导和计算有效系统系数，执行单步时间更新，以及通过其放大矩阵评估格式的线性稳定性。\n\n分析从 SDOF 系统的控制微分方程开始：\n$$\nm \\, \\ddot{u}(t) + c \\, \\dot{u}(t) + k \\, u(t) = f(t)\n$$\n其中 $m$、$c$ 和 $k$ 分别是质量、阻尼和刚度系数。$u(t)$、$\\dot{u}(t)$ 和 $\\ddot{u}(t)$ 分别是位移、速度和加速度。我们将时刻 $t_n$ 的离散近似值表示为 $u_n$、$v_n = \\dot{u}(t_n)$ 和 $a_n = \\ddot{u}(t_n)$。\n\nNewmark-beta 方法为时刻 $t_{n+1} = t_n + \\Delta t$ 的位移和速度提供了更新规则：\n$$\nu_{n+1} = u_n + \\Delta t \\, v_n + \\Delta t^2 \\left[ \\left(\\frac{1}{2} - \\beta\\right) a_n + \\beta a_{n+1} \\right] \\quad (1)\n$$\n$$\nv_{n+1} = v_n + \\Delta t \\left[ (1-\\gamma) a_n + \\gamma a_{n+1} \\right] \\quad (2)\n$$\n其中 $\\beta$ 和 $\\gamma$ 是该格式的无量纲参数。\n\n### 有效系统的推导\n\n对于隐式格式，运动方程在时间步的末端 $t_{n+1}$ 处强制满足：\n$$\nm a_{n+1} + c v_{n+1} + k u_{n+1} = f_{n+1} \\quad (3)\n$$\n主要未知量是位移 $u_{n+1}$。为了求解它，我们必须用 $u_{n+1}$ 和时刻 $t_n$ 的已知状态来表示 $a_{n+1}$ 和 $v_{n+1}$。\n\n从方程 (1) 中，我们可以重新整理，将 $a_{n+1}$ 表示为 $u_{n+1}$ 的函数：\n$$\na_{n+1} = \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} v_n - \\left(\\frac{1}{2\\beta} - 1\\right) a_n \\quad (A)\n$$\n现在，将这个 $a_{n+1}$ 的表达式代入方程 (2) 中，以用 $u_{n+1}$ 来表示 $v_{n+1}$：\n$$\nv_{n+1} = v_n + (1-\\gamma)\\Delta t a_n + \\gamma \\Delta t \\left[ \\frac{1}{\\beta \\Delta t^2} (u_{n+1} - u_n) - \\frac{1}{\\beta \\Delta t} v_n - \\left(\\frac{1}{2\\beta} - 1\\right) a_n \\right]\n$$\n按状态变量分组各项可得：\n$$\nv_{n+1} = \\frac{\\gamma}{\\beta \\Delta t} (u_{n+1} - u_n) + \\left(1 - \\frac{\\gamma}{\\beta}\\right)v_n + \\Delta t \\left(1 - \\frac{\\gamma}{2\\beta}\\right)a_n \\quad (B)\n$$\n\n接下来，我们将表达式 (A) 和 (B) 代入运动方程 (3)。为了使公式适用于通用求解器，我们将其重排为线性系统 $k_{\\mathrm{eff}} u_{n+1} = f_{\\mathrm{eff}}$ 的形式。我们将所有包含未知数 $u_{n+1}$ 的项分组到左侧 (LHS)，并将所有已知量分组到右侧 (RHS)。\n\n$$\nm a_{n+1} + c v_{n+1} + k u_{n+1} = f_{n+1}\n$$\n$$\nm\\left(\\dots\\right) + c\\left(\\dots\\right) + k u_{n+1} = f_{n+1}\n$$\n代入 (A) 和 (B) 并重新整理：\n$$\n\\left( \\frac{1}{\\beta \\Delta t^2}m + \\frac{\\gamma}{\\beta \\Delta t}c + k \\right) u_{n+1} = f_{n+1} + m\\left(\\frac{u_n}{\\beta \\Delta t^2} + \\frac{v_n}{\\beta \\Delta t} + \\left(\\frac{1}{2\\beta}-1\\right)a_n\\right) + c\\left(\\frac{\\gamma u_n}{\\beta \\Delta t} + \\left(\\frac{\\gamma}{\\beta} - 1 \\right)v_n + \\Delta t\\left(\\frac{\\gamma}{2\\beta} - 1\\right)a_n\\right)\n$$\n\n从这个方程中，我们可以识别出有效刚度 $k_{\\mathrm{eff}}$ 和有效荷载 $f_{\\mathrm{eff}}$。\n\n**有效刚度：**\n$$\nk_{\\mathrm{eff}} = k + \\frac{\\gamma}{\\beta \\Delta t} c + \\frac{1}{\\beta \\Delta t^2} m\n$$\n\n**算法系数：** 问题要求在有效系统组装中出现的六个算法系数。基于推导的有效系统方程，一组一致且有意义的六个系数是：\n- $a_0 = \\frac{1}{\\beta \\Delta t^2}$：在 $k_{\\mathrm{eff}}$ 中乘以 $m$ 以及在 RHS 上乘以 $m u_n$ 的系数。\n- $a_1 = \\frac{\\gamma}{\\beta \\Delta t}$：在 $k_{\\mathrm{eff}}$ 中乘以 $c$ 以及在 RHS 上乘以 $c u_n$ 的系数。\n- $a_2 = \\frac{1}{\\beta \\Delta t}$：RHS 上质量项对 $v_n$ 贡献的系数。\n- $a_3 = \\frac{1}{2\\beta} - 1$：RHS 上质量项对 $a_n$ 贡献的系数。\n- $a_4 = \\frac{\\gamma}{\\beta} - 1$：RHS 上阻尼项对 $v_n$ 贡献的系数。\n- $a_5 = \\Delta t \\left( \\frac{\\gamma}{2\\beta} - 1 \\right)$：RHS 上阻尼项对 $a_n$ 贡献的系数。\n\n使用这些系数，有效系统为：\n$$\nk_{\\mathrm{eff}} = k + a_1 c + a_0 m\n$$\n$$\nf_{\\mathrm{eff}} = f_{n+1} + m(a_0 u_n + a_2 v_n + a_3 a_n) + c(a_1 u_n + a_4 v_n + a_5 a_n)\n$$\n更新过程为求解 $u_{n+1} = f_{\\mathrm{eff}} / k_{\\mathrm{eff}}$，然后分别使用方程 (A) 和 (2) 恢复 $a_{n+1}$ 和 $v_{n+1}$。\n\n### 通过放大矩阵进行稳定性分析\n\n为了分析数值格式的稳定性，我们考虑齐次问题（$f(t) \\equiv 0$）。单步更新可以写成从时刻 $t_n$ 的状态向量 $\\mathbf{d}_n = [u_n, v_n, a_n]^T$ 到时刻 $t_{n+1}$ 的状态向量 $\\mathbf{d}_{n+1} = [u_{n+1}, v_{n+1}, a_{n+1}]^T$ 的线性映射：\n$$\n\\mathbf{d}_{n+1} = \\mathbf{A} \\, \\mathbf{d}_n\n$$\n其中 $\\mathbf{A}$ 是 $3 \\times 3$ 的放大矩阵。如果谱半径 $\\rho(\\mathbf{A}) = \\max_i |\\lambda_i|$ 小于或等于 $1$，则该格式是稳定的，其中 $\\lambda_i$ 是 $\\mathbf{A}$ 的特征值。\n\n为了推导 $\\mathbf{A}$，我们首先用 $t_n$ 时刻的状态表示 $a_{n+1}$。对于齐次问题，离散运动方程为 $m a_{n+1} + c v_{n+1} + k u_{n+1} = 0$。将 Newmark 更新方程 (1) 和 (2) 代入此式可得：\n$$\nm a_{n+1} + c(v_n + \\Delta t(1-\\gamma) a_n + \\gamma \\Delta t a_{n+1}) + k(u_n + \\Delta t v_n + \\Delta t^2(\\tfrac{1}{2}-\\beta) a_n + \\beta \\Delta t^2 a_{n+1}) = 0\n$$\n求解 $a_{n+1}$：\n$$\n(m + c \\gamma \\Delta t + k \\beta \\Delta t^2) a_{n+1} = -k u_n - (c+k\\Delta t)v_n - (c\\Delta t(1-\\gamma)+k\\Delta t^2(\\tfrac{1}{2}-\\beta)) a_n\n$$\n令 $D = m + c \\gamma \\Delta t + k \\beta \\Delta t^2$。那么 $a_{n+1}$ 是 $u_n, v_n, a_n$ 的线性组合，这定义了 $\\mathbf{A}$ 的第三行：\n$$\na_{n+1} = A_{31} u_n + A_{32} v_n + A_{33} a_n\n$$\n其中\n$A_{31} = -k/D$\n$A_{32} = -(c + k\\Delta t)/D$\n$A_{33} = -(c\\Delta t(1-\\gamma) + k\\Delta t^2(\\tfrac{1}{2}-\\beta))/D$\n\n通过将此 $a_{n+1}$ 的表达式代回更新方程 (1) 和 (2)，可以找到 $\\mathbf{A}$ 的第一行和第二行。\n对于 $u_{n+1}$：\n$$\nu_{n+1} = u_n + \\Delta t v_n + \\Delta t^2(\\tfrac{1}{2}-\\beta)a_n + \\beta\\Delta t^2(A_{31}u_n+A_{32}v_n+A_{33}a_n)\n$$\n$$\nA_{11} = 1 + \\beta \\Delta t^2 A_{31}, \\quad A_{12} = \\Delta t + \\beta \\Delta t^2 A_{32}, \\quad A_{13} = \\Delta t^2(\\tfrac{1}{2}-\\beta) + \\beta \\Delta t^2 A_{33}\n$$\n对于 $v_{n+1}$：\n$$\nv_{n+1} = v_n + \\Delta t(1-\\gamma) a_n + \\gamma\\Delta t(A_{31}u_n+A_{32}v_n+A_{33}a_n)\n$$\n$$\nA_{21} = \\gamma\\Delta t A_{31}, \\quad A_{22} = 1 + \\gamma\\Delta t A_{32}, \\quad A_{23} = \\Delta t(1-\\gamma) + \\gamma\\Delta t A_{33}\n$$\n构建矩阵 $\\mathbf{A}$ 后，可以数值计算其特征值以找到谱半径 $\\rho(\\mathbf{A})$。\n\n该程序将实现这些推导，以计算每个测试用例所需的量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes effective system coefficients, one-step update, and spectral radius\n    for the implicit Newmark-beta scheme for an SDOF linear oscillator.\n    \"\"\"\n    # Test cases: (m, c, k, dt, beta, gamma, u_n, v_n, a_n, f_n1)\n    test_cases = [\n        # Case A (happy path, lightly damped)\n        (2.0, 0.5, 50.0, 0.1, 0.25, 0.5, 0.02, 0.0, 0.0, 1.0),\n        # Case B (undamped, stiff, small time step)\n        (1.0, 0.0, 1000.0, 0.01, 0.3025, 0.6, 0.0, 1.0, 0.0, 0.0),\n        # Case C (heavily damped, larger time step)\n        (1.0, 5.0, 20.0, 0.2, 0.25, 0.6, -0.1, 0.5, 0.0, 0.0),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        m, c, k, dt, beta, gamma, u_n, v_n, a_n, f_n1 = case\n\n        # Part 1: Compute the six algorithmic coefficients\n        # These coefficients are derived from the effective system formulation.\n        # k_eff = k + a_1*c + a_0*m\n        # f_eff = f_n+1 + m*(a_0*u_n + a_2*v_n + a_3*a_n) + c*(a_1*u_n + a_4*v_n + a_5*a_n)\n        \n        # Check for beta = 0 case, which leads to division by zero\n        if beta == 0:\n            # The displacement-based formulation used here is not valid for beta=0.\n            # An acceleration-based formulation would be needed. This is an edge case\n            # not relevant to the test suite, but good practice to consider.\n            # For this problem, we assume beta > 0.\n            pass\n\n        a0 = 1.0 / (beta * dt**2)\n        a1 = gamma / (beta * dt)\n        a2 = 1.0 / (beta * dt)\n        a3 = 1.0 / (2.0 * beta) - 1.0\n        a4 = gamma / beta - 1.0\n        a5 = dt * (gamma / (2.0 * beta) - 1.0)\n\n        # Part 2: Compute effective stiffness and solve for u_{n+1}\n        k_eff = k + a1 * c + a0 * m\n        \n        f_eff_mass = m * (a0 * u_n + a2 * v_n + a3 * a_n)\n        f_eff_damp = c * (a1 * u_n + a4 * v_n + a5 * a_n)\n        f_eff = f_n1 + f_eff_mass + f_eff_damp\n        \n        u_n1 = f_eff / k_eff\n\n        # Part 3: Compute the spectral radius of the amplification matrix\n        # Amplification matrix A maps d_n = [u_n, v_n, a_n]^T to d_{n+1}\n        \n        # Denominator for the amplification matrix elements\n        D = m + c * gamma * dt + k * beta * dt**2\n        \n        # Third row of A (expression for a_{n+1})\n        A31 = -k / D\n        A32 = -(c + k * dt) / D\n        A33 = -(c * dt * (1.0 - gamma) + k * dt**2 * (0.5 - beta)) / D\n        \n        # First row of A (expression for u_{n+1})\n        A11 = 1.0 + beta * dt**2 * A31\n        A12 = dt + beta * dt**2 * A32\n        A13 = dt**2 * (0.5 - beta) + beta * dt**2 * A33\n        \n        # Second row of A (expression for v_{n+1})\n        A21 = gamma * dt * A31\n        A22 = 1.0 + gamma * dt * A32\n        A23 = dt * (1.0 - gamma) + gamma * dt * A33\n        \n        # Construct the amplification matrix\n        A_matrix = np.array([\n            [A11, A12, A13],\n            [A21, A22, A23],\n            [A31, A32, A33]\n        ])\n        \n        # Compute eigenvalues and spectral radius\n        eigenvalues = np.linalg.eigvals(A_matrix)\n        rho = np.max(np.abs(eigenvalues))\n\n        # Assemble results for the current case in the specified order\n        case_results = [k_eff, a0, a1, a2, a3, a4, a5, rho, u_n1]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format\n    # Printing a list of lists requires careful formatting.\n    # We use repr() on each inner list to get its string representation\n    # and then join them.\n    print(f\"[{','.join(repr(res) for res in all_results)}]\")\n\nsolve()\n```", "id": "3573229"}, {"introduction": "在掌握线性系统的基础上，本练习将探讨 Newmark-β 格式如何应用于具有材料非线性的系统，例如塑性或损伤。您将研究一种复合积分器，其中内部材料状态被独立更新（算子分裂），从而引出“一致算法切线刚度”的概念。这次实践 [@problem_id:3573276] 展示了 Newmark 方法的鲁棒性，证明了只要使用正确的切线刚度，即使刚度发生变化，其无条件稳定性依然成立。", "problem": "您需要构建、分析和测试一个用于含内变量的小应变动力学问题的复合时间积分算法。力学平衡由隐式 Newmark-$\\beta$ 族积分，而内变量则通过算子分裂进行局部更新来推进。您的任务是从第一性原理推导该格式，在适当的参数选择和切线耦合条件下证明其无条件稳定性，并实现一个测试函数，通过计算一组代表性算例中放大矩阵的谱半径来评估其稳定性。\n\n从基本原理出发：针对小应变线性化系统的牛顿第二运动定律，\n$$\n\\mathbf{M}\\,\\mathbf{a}(t) + \\mathbf{C}\\,\\mathbf{v}(t) + \\mathbf{K}(\\boldsymbol{\\alpha}(t))\\,\\mathbf{u}(t) = \\mathbf{f}(t),\n$$\n其中 $\\mathbf{u}$ 是位移，$\\mathbf{v} = \\dot{\\mathbf{u}}$ 是速度，$\\mathbf{a} = \\ddot{\\mathbf{u}}$ 是加速度，$\\mathbf{M}$ 是对称正定质量矩阵，$\\mathbf{C}$ 是对称半正定阻尼矩阵，$\\mathbf{K}(\\boldsymbol{\\alpha})$ 是与内变量 $\\boldsymbol{\\alpha}$ 相关的（可能与状态相关的）对称切线刚度，$\\mathbf{f}$ 是外荷载。考虑从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的一个时间步，时间步长 $\\Delta t > 0$ 为常数，使用参数为 $\\beta$ 和 $\\gamma$ 的隐式 Newmark-$\\beta$ 族，并假设算子分裂在 $t_{n+1}$ 时刻局部更新 $\\boldsymbol{\\alpha}$，从而提供在 $t_{n+1}$ 时刻计算的一致算法切线刚度 $\\mathbf{K}_{\\text{alg}} := \\partial \\mathbf{R}_{\\text{int}}/\\partial \\mathbf{u}$，其中 $\\mathbf{R}_{\\text{int}}$ 是内力向量。为进行稳定性分析，假设外荷载为零，即 $\\mathbf{f}(t) \\equiv \\mathbf{0}$。\n\n要求：\n- 推导复合积分器，该积分器结合了：由参数为 $\\beta$ 和 $\\gamma$ 的隐式 Newmark-$\\beta$ 推进的力学平衡，以及用于计算在 $t_{n+1}$ 时刻全局力学求解中使用的一致算法切线刚度 $\\mathbf{K}_{\\text{alg}}$ 的内变量算子分裂更新。不要使用任何预先给出的 Newmark 更新公式；相反，从 Newmark-$\\beta$ 运动学定义和牛顿第二定律出发，以获得在 $t_{n+1}$ 时刻未知量的线性系统。\n- 证明如果一致算法切线刚度 $\\mathbf{K}_{\\text{alg}}$ 是对称半正定的，并且阻尼矩阵 $\\mathbf{C}$ 是对称半正定的，那么对于参数选择 $\\beta \\ge \\frac{1}{4}$ 和 $\\gamma \\ge \\frac{1}{2}$，该格式在能量有界意义下对齐次系统（零荷载）是关于时间步长 $\\Delta t$ 无条件稳定的。您的证明必须从牛顿第二定律、Newmark-$\\beta$ 运动学定义和一个能量或范数论证出发，并且必须阐明一致切线耦合的作用。\n- 实现一个函数，对于具有标量质量 $m$、阻尼 $c$ 和一致算法切线刚度 $k_{\\text{alg}}$ 的单自由度（Single Degree Of Freedom, SDOF）系统，构建一个线性放大矩阵，该矩阵在隐式 Newmark-$\\beta$ 格式和零荷载下将状态向量 $[\\;u_n,\\;v_n,\\;a_n\\;]^T$ 映射到 $[\\;u_{n+1},\\;v_{n+1},\\;a_{n+1}\\;]^T$。使用该矩阵计算谱半径（特征值的最大模）作为 $(m,c,k_{\\text{alg}},\\Delta t,\\beta,\\gamma)$ 的函数。该构建过程必须直接遵循您推导的 Newmark 关系和牛顿第二定律，不得依赖任何外部公式。\n\n本问题中的所有量均为无量纲；不需要物理单位。\n\n测试套件：\n使用以下四个单自由度情况，每种情况在三个时间步长 $\\Delta t \\in \\{\\,10^{-3},\\,1,\\,10^{3}\\,\\}$ 下进行评估，参数为 $\\beta = \\frac{1}{4}$ 和 $\\gamma = \\frac{1}{2}$：\n\n- 弹性参考情况：$m = 1$, $c = 0$, $k_{\\text{alg}} = 1000$。\n- 屈服后一致切线状态下的线性各向同性硬化弹塑性：取 $m = 1$, $c = 0$，弹性模量替代值 $k_{\\mathrm{e}} = 1000$，硬化模量替代值 $h = 500$，并使用著名的一维一致切线刚度 $k_{\\text{alg}} = \\dfrac{k_{\\mathrm{e}}\\,h}{k_{\\mathrm{e}} + h}$。这将产生一个减小但为正的 $k_{\\text{alg}}$，适合稳定性测试。\n- 完全塑性状态下的理想塑性：$m = 1$, $c = 0$, $k_{\\text{alg}} = 0$。\n- 带粘性阻尼的损伤折减刚度：$m = 1$, $c = 5$，初始刚度 $k_0 = 1000$，标量损伤 $d = 0.7$，因此 $k_{\\text{alg}} = (1 - d)\\,k_0$。\n\n对于每种情况，计算三个 $\\Delta t$ 值下的最大谱半径。您的程序的最终输出必须是包含四个浮点数的单行列表，顺序与四个测试情况相对应。格式必须严格为逗号分隔的 Python 风格列表，例如\n$[\\,\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\,]$，\n不得包含任何附加文本。无需对结果进行四舍五入。\n\n本问题不适用角度单位。适用时，百分比必须表示为小数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$）。", "solution": "本问题旨在解决非线性固体动力学中一个复合时间积分格式的构建和稳定性分析，其中力学平衡通过隐式 Newmark-$\\beta$ 方法积分，内变量通过算子分裂进行更新。解决方案分为三部分：首先，推导每个时间步需求解的离散线性系统；其次，证明在指定条件下的无条件稳定性；第三，为单自由度（SDOF）系统的谱稳定性分析构建放大矩阵。\n\n**1. 复合积分器的推导**\n\n分析始于 $t_{n+1}$ 时刻经历小应变系统的半离散化运动方程：\n$$\n\\mathbf{M}\\,\\mathbf{a}_{n+1} + \\mathbf{C}\\,\\mathbf{v}_{n+1} + \\mathbf{R}_{\\text{int}}(\\mathbf{u}_{n+1}, \\boldsymbol{\\alpha}_{n+1}) = \\mathbf{f}_{n+1}\n$$\n其中 $\\mathbf{M}$ 是质量矩阵，$\\mathbf{C}$ 是阻尼矩阵，$\\mathbf{R}_{\\text{int}}$ 是内力向量，它是位移 $\\mathbf{u}_{n+1}$ 和内变量 $\\boldsymbol{\\alpha}_{n+1}$ 的函数。外力向量为 $\\mathbf{f}_{n+1}$。变量 $\\mathbf{a}_{n+1}$ 和 $\\mathbf{v}_{n+1}$ 分别是 $t_{n+1}$ 时刻的加速度和速度向量。算子分裂意味着对于给定的位移 $\\mathbf{u}_{n+1}$，内变量 $\\boldsymbol{\\alpha}_{n+1}$（以及因此的 $\\mathbf{R}_{\\text{int}}$）由局部本构更新确定。\n\n隐式 Newmark-$\\beta$ 方法提供了位移、速度和加速度之间的运动学关系。从 $t_n$ 时刻的状态 $(\\mathbf{u}_n, \\mathbf{v}_n, \\mathbf{a}_n)$ 出发，在 $t_{n+1} = t_n + \\Delta t$ 时刻的状态由下式给出：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\, \\mathbf{v}_n + \\Delta t^2 \\left( \\left(\\frac{1}{2}-\\beta\\right)\\mathbf{a}_n + \\beta \\mathbf{a}_{n+1} \\right) \\quad (1)\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t \\left( (1-\\gamma)\\mathbf{a}_n + \\gamma \\mathbf{a}_{n+1} \\right) \\quad (2)\n$$\n其中 $\\beta$ 和 $\\gamma$ 是 Newmark 参数。为求解 $t_{n+1}$ 时刻的状态，我们必须同时求解运动方程和这些运动学更新。这通常会得到一个关于未知位移 $\\mathbf{u}_{n+1}$ 的非线性代数系统，该系统使用诸如 Newton-Raphson 方法的迭代过程求解。本问题要求在此背景下推导线性系统。\n\n我们首先将加速度 $\\mathbf{a}_{n+1}$ 和速度 $\\mathbf{v}_{n+1}$ 表示为未知位移 $\\mathbf{u}_{n+1}$ 和第 $n$ 步已知量的函数。从方程 $(1)$：\n$$\n\\beta \\Delta t^2 \\mathbf{a}_{n+1} = \\mathbf{u}_{n+1} - \\left[ \\mathbf{u}_n + \\Delta t \\, \\mathbf{v}_n + \\Delta t^2 \\left(\\frac{1}{2}-\\beta\\right)\\mathbf{a}_n \\right]\n$$\n这给出了加速度的更新公式：\n$$\n\\mathbf{a}_{n+1} = \\frac{1}{\\beta \\Delta t^2} (\\mathbf{u}_{n+1} - \\mathbf{u}_n) - \\frac{1}{\\beta \\Delta t} \\mathbf{v}_n - \\left(\\frac{1}{2\\beta}-1\\right) \\mathbf{a}_n \\quad (3)\n$$\n将方程 $(3)$ 代入方程 $(2)$ 得到速度的更新公式：\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t(1-\\gamma)\\mathbf{a}_n + \\gamma\\Delta t \\left[ \\frac{1}{\\beta \\Delta t^2} (\\mathbf{u}_{n+1} - \\mathbf{u}_n) - \\frac{1}{\\beta \\Delta t} \\mathbf{v}_n - \\left(\\frac{1}{2\\beta}-1\\right) \\mathbf{a}_n \\right]\n$$\n$$\n\\mathbf{v}_{n+1} = \\frac{\\gamma}{\\beta\\Delta t}(\\mathbf{u}_{n+1} - \\mathbf{u}_n) + (1-\\frac{\\gamma}{\\beta})\\mathbf{v}_n + \\Delta t\\left(1-\\gamma - \\frac{\\gamma}{2\\beta} + \\gamma\\right)\\mathbf{a}_n = \\frac{\\gamma}{\\beta\\Delta t}(\\mathbf{u}_{n+1} - \\mathbf{u}_n) + (1-\\frac{\\gamma}{\\beta})\\mathbf{v}_n + \\Delta t(1 - \\frac{\\gamma}{2\\beta})\\mathbf{a}_n \\quad (4)\n$$\n在 Newton-Raphson 格式中，我们求解对当前位移猜测 $\\mathbf{u}_{n+1}^{(i)}$ 的修正量 $\\Delta\\mathbf{u}$。线性化系统为 $\\mathbf{K}_{\\text{eff}} \\Delta\\mathbf{u} = -\\mathbf{R}^{(i)}$，其中 $\\mathbf{R}^{(i)}$ 是第 $i$ 次迭代的残差，$\\mathbf{K}_{\\text{eff}}$ 是有效切线刚度矩阵。残差为 $\\mathbf{R} = \\mathbf{M}\\mathbf{a}_{n+1} + \\mathbf{C}\\mathbf{v}_{n+1} + \\mathbf{R}_{\\text{int}}(\\mathbf{u}_{n+1}) - \\mathbf{f}_{n+1}$。\n有效刚度是残差关于 $\\mathbf{u}_{n+1}$ 的雅可比矩阵：\n$$\n\\mathbf{K}_{\\text{eff}} = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}_{n+1}} = \\mathbf{M}\\frac{\\partial \\mathbf{a}_{n+1}}{\\partial \\mathbf{u}_{n+1}} + \\mathbf{C}\\frac{\\partial \\mathbf{v}_{n+1}}{\\partial \\mathbf{u}_{n+1}} + \\frac{\\partial \\mathbf{R}_{\\text{int}}}{\\partial \\mathbf{u}_{n+1}}\n$$\n从方程 $(3)$ 和 $(4)$，我们找到导数：\n$$\n\\frac{\\partial \\mathbf{a}_{n+1}}{\\partial \\mathbf{u}_{n+1}} = \\frac{1}{\\beta \\Delta t^2} \\mathbf{I} \\quad \\text{和} \\quad \\frac{\\partial \\mathbf{v}_{n+1}}{\\partial \\mathbf{u}_{n+1}} = \\frac{\\gamma}{\\beta \\Delta t} \\mathbf{I}\n$$\n项 $\\frac{\\partial \\mathbf{R}_{\\text{int}}}{\\partial \\mathbf{u}_{n+1}}$ 正是一致算法切线刚度 $\\mathbf{K}_{\\text{alg}}$ 的定义。因此，在每个时间步（或每个 Newton 迭代）中为位移 $\\mathbf{u}_{n+1}$（或其增量）求解的线性系统由有效刚度矩阵控制：\n$$\n\\mathbf{K}_{\\text{eff}} = \\frac{1}{\\beta \\Delta t^2}\\mathbf{M} + \\frac{\\gamma}{\\beta \\Delta t}\\mathbf{C} + \\mathbf{K}_{\\text{alg}}\n$$\n完整的系统是 $\\mathbf{K}_{\\text{eff}} \\mathbf{u}_{n+1} = \\mathbf{f}_{\\text{eff}}$，其中 $\\mathbf{f}_{\\text{eff}}$ 包含外力 $\\mathbf{f}_{n+1}$ 和所有依赖于 $t_n$ 时刻状态的项。\n\n**2. 无条件稳定性证明**\n\n无条件稳定性意味着对于任何时间步长 $\\Delta t > 0$，齐次系统（$\\mathbf{f}(t) \\equiv \\mathbf{0}$）的离散系统总能量保持有界。该证明依赖于证明一个离散的类功能量函数是非增的。此证明的条件是 $\\gamma \\ge 1/2$，$\\beta \\ge 1/4$，并且阻尼矩阵 $\\mathbf{C}$ 和一致算法切线刚度 $\\mathbf{K}_{\\text{alg}}$ 是对称半正定的。后者意味着内力可由一个凸势能函数 $\\Pi(\\mathbf{u})$ 导出，即 $\\mathbf{R}_{\\text{int}} = \\partial \\Pi/\\partial \\mathbf{u}$ 且 $\\mathbf{K}_{\\text{alg}} = \\partial^2\\Pi/\\partial\\mathbf{u}^2 \\ge \\mathbf{0}$。\n\n证明策略是在单个时间步上建立能量平衡。力系统所做的功必须平衡能量的变化。$t_{n+1}$ 时刻齐次系统的离散运动方程为：\n$$\n\\mathbf{M}\\mathbf{a}_{n+1} + \\mathbf{C}\\mathbf{v}_{n+1} + \\mathbf{R}_{\\text{int}, n+1} = \\mathbf{0}\n$$\n与速度增量 $\\mathbf{v}_{n+1} - \\mathbf{v}_n$ 做点积并进行逐项分析（此过程涉及大量但标准的 Newmark 关系代数操作），可以得到一个离散能量平衡，形式如下：\n$$\n(E_{k,n+1}+\\Pi_{n+1}) - (E_{k,n}+\\Pi_{n}) = -\\mathcal{D}_{\\text{phys}} - \\mathcal{D}_{\\text{alg}}\n$$\n其中 $E_{k,n} = \\frac{1}{2}\\mathbf{v}_n^T \\mathbf{M} \\mathbf{v}_n$ 是 $t_n$ 时刻的动能，$\\Pi_n$ 是储存的势能。$\\mathcal{D}_{\\text{phys}}$ 项代表由阻尼矩阵 $\\mathbf{C}$ 引起的物理能量耗散，而 $\\mathcal{D}_{\\text{alg}}$ 是由算法引起的数值耗散。为使格式稳定，两个耗散项都必须非负。\n\n物理耗散项，在该步长上近似，可以表示为 $\\mathcal{D}_{\\text{phys}} \\approx \\Delta t \\mathbf{v}_{n+1/2}^T \\mathbf{C} \\mathbf{v}_{n+1/2}$ 的形式，由于 $\\mathbf{C}$ 是半正定的，该项非负。\n\n关键部分是数值耗散，经过上述代数操作后，可以表示为：\n$$\n\\mathcal{D}_{\\text{alg}} = (\\gamma - 1/2) \\Delta t (\\mathbf{a}_{n+1} - \\mathbf{a}_n)^T \\mathbf{M} (\\mathbf{a}_{n+1} - \\mathbf{a}_n) + \\text{其他项} \n$$\n一个更优雅的表述（归功于 Simo 和 Tarnow）定义了一个修正的、算法上一致的能量泛函。该泛函的变化被证明是由在给定条件下明显非负的项耗散的。一个关键的耗散项与 $(\\gamma - 1/2)$ 成正比。为使该项非负（因为 $\\mathbf{M}$ 是正定的），我们必须有 $\\gamma \\ge 1/2$。选择 $\\beta \\ge 1/4$（特别是 $\\beta \\ge \\gamma/2$）确保了高频模式的相互作用不会产生伪能量，从而防止不稳定性。\n\n$\\mathbf{K}_{\\text{alg}}$ 是对称半正定的假设至关重要。它保证了内力场是保守的（或至少在势能意义上是非耗散的），允许使用势能 $\\Pi$ 并满足不等式 $(\\mathbf{u}_{n+1}-\\mathbf{u}_n)^T \\mathbf{R}_{\\text{int},n+1} \\ge \\Pi_{n+1}-\\Pi_n$，这是凸函数的性质。这确保了内力所做的功对应于非负的储能（或有界的变化），防止了从材料模型的算法表示中人为地产生能量。\n\n总之，条件 $\\gamma \\ge 1/2$ 和 $\\beta \\ge 1/4$，结合对称半正定的 $\\mathbf{C}$ 和 $\\mathbf{K}_{\\text{alg}}$，保证了系统的总离散能量不增加，从而证明了无条件稳定性。\n\n**3. 单自由度系统的谱分析**\n\n对于具有质量 $m$、阻尼 $c$ 和算法刚度 $k_{\\text{alg}}$ 的单自由度（SDOF）系统，其状态可以由向量 $\\mathbf{z}_n = [\\,u_n, v_n, a_n\\,]^T$ 表示。积分器推进状态，使得 $\\mathbf{z}_{n+1} = \\mathbf{A}\\,\\mathbf{z}_n$，其中 $\\mathbf{A}$ 是放大矩阵。稳定性要求该矩阵的谱半径 $\\rho(\\mathbf{A}) = \\max_i |\\lambda_i(\\mathbf{A})|$ 小于或等于 $1$。\n\n控制方程为：\n$$\nm a_{n+1} + c v_{n+1} + k_{\\text{alg}} u_{n+1} = 0 \\quad (5)\n$$\n$$\nu_{n+1} = u_n + \\Delta t v_n + \\Delta t^2 ( (1/2-\\beta)a_n + \\beta a_{n+1} ) \\quad (6)\n$$\n$$\nv_{n+1} = v_n + \\Delta t ( (1-\\gamma)a_n + \\gamma a_{n+1} ) \\quad (7)\n$$\n为了构建 $\\mathbf{A}$，我们将 $u_{n+1}$、$v_{n+1}$ 和 $a_{n+1}$ 表示为 $u_n$、$v_n$ 和 $a_n$ 的线性组合。我们首先求解 $a_{n+1}$。将方程 $(6)$ 和 $(7)$ 代入 $(5)$：\n$$\nm a_{n+1} + c(v_n + \\Delta t (1-\\gamma)a_n + \\gamma\\Delta t a_{n+1}) + k_{\\text{alg}}(u_n + \\Delta t v_n + \\Delta t^2((1/2-\\beta)a_n + \\beta a_{n+1})) = 0\n$$\n将包含 $a_{n+1}$ 的项分组到左侧：\n$$\n(m + c\\gamma\\Delta t + k_{\\text{alg}}\\beta\\Delta t^2) a_{n+1} = -k_{\\text{alg}} u_n - (c + k_{\\text{alg}}\\Delta t)v_n - (c\\Delta t(1-\\gamma) + k_{\\text{alg}}\\Delta t^2(1/2-\\beta))a_n\n$$\n令 $D = m + c\\gamma\\Delta t + k_{\\text{alg}}\\beta\\Delta t^2$。由于 $m>0$ 且所有其他参数均为非负，所以 $D>0$。\n$$\na_{n+1} = \\frac{-k_{\\text{alg}}}{D} u_n - \\frac{c + k_{\\text{alg}}\\Delta t}{D} v_n - \\frac{c\\Delta t(1-\\gamma) + k_{\\text{alg}}\\Delta t^2(1/2-\\beta)}{D} a_n\n$$\n此表达式提供了放大矩阵 $\\mathbf{A}$ 的第三行。现在可以通过将这个 $a_{n+1}$ 的表达式分别代回方程 $(7)$ 和 $(6)$ 来找到另外两个状态变量 $v_{n+1}$ 和 $u_{n+1}$。这将得到 $\\mathbf{A}$ 的其余行：\n$$\n\\mathbf{A} = \n\\begin{pmatrix}\n1 + \\beta\\Delta t^2 A_{31} & \\Delta t + \\beta\\Delta t^2 A_{32} & \\Delta t^2(1/2-\\beta) + \\beta\\Delta t^2 A_{33} \\\\\n\\gamma\\Delta t A_{31} & 1 + \\gamma\\Delta t A_{32} & \\Delta t(1-\\gamma) + \\gamma\\Delta t A_{33} \\\\\nA_{31} & A_{32} & A_{33}\n\\end{pmatrix}\n$$\n其中 $A_{3j}$ 是 $a_{n+1}$ 表达式中 $u_n, v_n, a_n$ 的系数。具体来说：\n$A_{31} = -k_{\\text{alg}}/D$\n$A_{32} = -(c + k_{\\text{alg}}\\Delta t)/D$\n$A_{33} = -(c\\Delta t(1-\\gamma) + k_{\\text{alg}}\\Delta t^2(1/2-\\beta))/D$\n\n通过为给定参数构建此矩阵并计算其特征值，我们可以确定谱半径，从而对指定测试用例的格式稳定性进行数值验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum spectral radius for four SDOF test cases using the\n    implicit Newmark-beta method.\n    \"\"\"\n\n    def calculate_max_spectral_radius(m, c, k_alg, beta, gamma, time_steps):\n        \"\"\"\n        Calculates the maximum spectral radius of the amplification matrix over a\n        range of time steps.\n        \n        Args:\n            m (float): Mass.\n            c (float): Damping.\n            k_alg (float): Algorithmic tangent stiffness.\n            beta (float): Newmark parameter.\n            gamma (float): Newmark parameter.\n            time_steps (list of float): Time steps to evaluate.\n        \n        Returns:\n            float: The maximum spectral radius found.\n        \"\"\"\n        max_rho = 0.0\n\n        for dt in time_steps:\n            # Denominator of the expression for a_{n+1}\n            # This is always positive for m > 0, c, k_alg, beta, gamma >= 0, dt > 0.\n            D = m + c * gamma * dt + k_alg * beta * dt**2\n\n            # Initialize the 3x3 amplification matrix A that maps\n            # [u_n, v_n, a_n]^T to [u_{n+1}, v_{n+1}, a_{n+1}]^T.\n            # Use complex numbers to handle eigenvalues correctly.\n            A = np.zeros((3, 3), dtype=np.complex128)\n\n            # Coefficients for the third row of A (expression for a_{n+1})\n            # a_{n+1} = A[2,0]*u_n + A[2,1]*v_n + A[2,2]*a_n\n            A[2, 0] = -k_alg / D\n            A[2, 1] = -(c + k_alg * dt) / D\n            A[2, 2] = -(c * dt * (1 - gamma) + k_alg * dt**2 * (0.5 - beta)) / D\n\n            # Coefficients for the second row of A (expression for v_{n+1})\n            # v_{n+1} = v_n + dt*(1-gamma)*a_n + dt*gamma*a_{n+1}\n            A[1, 0] = gamma * dt * A[2, 0]\n            A[1, 1] = 1.0 + gamma * dt * A[2, 1]\n            A[1, 2] = dt * (1.0 - gamma) + gamma * dt * A[2, 2]\n\n            # Coefficients for the first row of A (expression for u_{n+1})\n            # u_{n+1} = u_n + dt*v_n + dt^2*(0.5-beta)*a_n + dt^2*beta*a_{n+1}\n            A[0, 0] = 1.0 + beta * dt**2 * A[2, 0]\n            A[0, 1] = dt + beta * dt**2 * A[2, 1]\n            A[0, 2] = dt**2 * (0.5 - beta) + beta * dt**2 * A[2, 2]\n\n            # Compute the spectral radius (maximum absolute eigenvalue)\n            eigenvalues = np.linalg.eigvals(A)\n            rho = np.max(np.abs(eigenvalues))\n            \n            # Update the maximum spectral radius found so far\n            if rho > max_rho:\n                max_rho = rho\n        \n        return max_rho\n\n    # Define common parameters for the test suite\n    beta_val = 0.25\n    gamma_val = 0.5\n    time_steps_eval = [1e-3, 1.0, 1e3]\n    \n    # Define the four SDOF test cases\n    # Case 1: Elastic reference\n    case1 = (1.0, 0.0, 1000.0)\n\n    # Case 2: Elastoplastic with linear hardening\n    k_e = 1000.0\n    h = 500.0\n    k_alg_2 = (k_e * h) / (k_e + h)\n    case2 = (1.0, 0.0, k_alg_2)\n\n    # Case 3: Perfect plasticity\n    case3 = (1.0, 0.0, 0.0)\n\n    # Case 4: Damage-reduced stiffness with damping\n    k0 = 1000.0\n    d = 0.7\n    k_alg_4 = (1.0 - d) * k0\n    case4 = (1.0, 5.0, k_alg_4)\n    \n    test_cases = [case1, case2, case3, case4]\n\n    results = []\n    for m_val, c_val, k_val in test_cases:\n        max_rho = calculate_max_spectral_radius(m_val, c_val, k_val, beta_val, gamma_val, time_steps_eval)\n        results.append(max_rho)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3573276"}, {"introduction": "我们最后的实践将解决一个在计算力学中常见且具有挑战性的问题：摩擦接触。在这里，我们将使用 Newmark-β 格式来模拟粘滑动力学，并研究“数值颤振”——一种高频振荡伪影。本练习 [@problem_id:3573269] 实际展示了由 Newmark 参数 $\\gamma$ 控制的“算法阻尼”在稳定模拟和获得物理上有意义的结果方面所扮演的关键角色。", "problem": "您需要设计并实现一个完整的、可运行的程序，用于研究隐式 Newmark-$\\beta$ 族格式中的算法阻尼如何影响摩擦接触中的粘滑动力学，目标是识别出能够在抑制数值颤振的同时，不过度阻尼物理相关振荡模式的参数区域 $\\left(\\beta,\\gamma\\right)$。此项研究必须纯粹以数学和逻辑术语提出，使用一个与计算固体力学一致的单自由度系统。\n\n从控制定律和定义出发。使用牛顿第二定律和标准本构关系。考虑一个由谐波外力驱动的单自由度质量-弹簧-阻尼系统，其标量位移为 $x(t)$、速度为 $v(t)$、加速度为 $a(t)$。运动方程为\n$$\nm\\,a(t) + c\\,v(t) + k\\,x(t) = f_{\\mathrm{ext}}(t) + f_{\\mathrm{fr}}(t),\n$$\n其中 $m$ 是质量，$c$ 是粘性阻尼系数，$k$ 是刚度，$f_{\\mathrm{ext}}(t)$ 是外力，$f_{\\mathrm{fr}}(t)$ 是切向库仑摩擦接触力。外力规定为\n$$\nf_{\\mathrm{ext}}(t) = A \\sin(\\omega t),\n$$\n其中 $A$ 是振幅，$\\omega$ 是角频率。假设一个刚性表面，其切向速度恒为 $v_b$，法向载荷恒为 $N$。库仑摩擦定律为\n$$\nf_{\\mathrm{fr}}(t) = \n\\begin{cases}\n\\lambda(t), & \\text{如果粘滞}, \\\\\n-\\mu N\\,\\mathrm{sign}\\big(v(t)-v_b\\big), & \\text{如果滑动},\n\\end{cases}\n$$\n其中静态粘滞容许条件为 $\\lvert \\lambda(t) \\rvert \\le \\mu N$，摩擦系数为 $\\mu$，法向载荷为 $N$。粘滞约束为 $v(t) = v_b$，而滑动则施加处于库仑极限的摩擦力 $f_{\\mathrm{fr}}(t)$，其方向与相对切向速度相反。\n\n使用均匀时间步长 $\\Delta t$ 以及由参数 $\\beta$ 和 $\\gamma$ 表征的隐式 Newmark-$\\beta$ 族对时间进行离散。离散的运动学更新关系必须从第一性原理推导（不得直接假设），并且必须能够在存在摩擦接触的情况下，通过求解新时间步的未知加速度来隐式地施加动态平衡。在每个时间步中，基于粘滞约束和库仑极限，实现一个一致的粘滑判定程序，以确保摩擦状态和摩擦力满足容许条件。\n\n目的是量化由 $\\left(\\beta,\\gamma\\right)$ 控制的算法（数值）阻尼所引起的数值颤振的发生和普遍程度，并识别出那些既能消除粘滑振荡又不过度阻尼物理模式的区域。为此，您必须：\n\n- 实现一个模拟器，该模拟器在离散隐式平衡和 Newmark-$\\beta$ 运动学下，将 $\\left(x,v,a\\right)$ 从 $t_n$ 推进到 $t_{n+1}$，同时根据库仑摩擦定律和粘滞容许性，一致地判定粘滞与滑动状态。\n- 定义一个颤振度量如下：当相对速度大小 $\\lvert v(t)-v_b\\rvert$ 低于一个小阈值 $\\varepsilon_r$ 时，计算连续时间步中状态切换（粘滞 $\\leftrightarrow$ 滑动，或滑动方向翻转）的次数。将此计数除以总时间步数，得到一个无量纲的颤振分数 $C \\in [0,1]$。\n- 通过计算周期性受力下的稳态位移振幅，并将其与使用 $\\beta = 1/4$ 和 $\\gamma = 1/2$（无算法数值阻尼）的基准模拟进行比较，来定义一个物理模式保持度量。令 $R$ 为振幅比（测试振幅除以基准振幅），该比值在模拟区间的后半部分计算，以避免暂态效应。\n\n如果一个参数区域 $\\left(\\beta,\\gamma\\right)$ 同时满足 $C \\le C_{\\max}$ 和 $R \\ge R_{\\min}$，则将其分类为“良好”（good），其中 $C_{\\max}$ 和 $R_{\\min}$ 是您选择的固定阈值，以确保在不过度衰减物理振荡的情况下实现合理的颤振抑制。您的程序必须为每个测试案例计算一个布尔值，以指示该区域是否良好。\n\n使用以下符合科学实际的参数和单位：\n\n- 质量 $m = 1$ （单位：kg）。\n- 刚度 $k = 1000$ （单位：N/m）。\n- 粘性阻尼 $c = 1$ （单位：N·s/m）。\n- 摩擦系数 $\\mu = 0.3$ (无量纲)。\n- 法向载荷 $N = 10$ （单位：N）。\n- 带速 $v_b = 0$ （单位：m/s）。\n- 外力振幅 $A = 50$ （单位：N）。\n- 角频率 $\\omega = \\sqrt{k/m}$ （单位：rad/s）。\n- 总模拟时间 $T = 5$ （单位：s）。\n- 相对速度颤振阈值 $\\varepsilon_r = 10^{-3}$ （单位：m/s）。\n\n构建并评估以下由 $\\left(\\beta,\\gamma,\\Delta t\\right)$ 定义的测试套件：\n\n- 案例 1：$\\beta = 1/4$，$\\gamma = 1/2$，$\\Delta t = 5 \\times 10^{-3}$ （单位：s）。\n- 案例 2：$\\beta = 0.30$，$\\gamma = 0.60$，$\\Delta t = 5 \\times 10^{-3}$ （单位：s）。\n- 案例 3：$\\beta = 0.40$，$\\gamma = 0.80$，$\\Delta t = 5 \\times 10^{-3}$ （单位：s）。\n- 案例 4：$\\beta = 0.28$，$\\gamma = 0.62$，$\\Delta t = 2 \\times 10^{-3}$ （单位：s）。\n\n对于每个案例，计算其颤振分数 $C$ 和振幅比 $R$（相对于使用 $\\beta = 1/4$、$\\gamma = 1/2$ 和相同 $\\Delta t$ 的基准）。然后，使用阈值 $C_{\\max} = 2 \\times 10^{-2}$ 和 $R_{\\min} = 7 \\times 10^{-1}$，输出一个布尔值，指示是否满足 $\\left(C \\le C_{\\max}\\right)$ 和 $\\left(R \\ge R_{\\min}\\right)$。\n\n您的程序应生成单行输出，其中包含测试套件的四个布尔值，格式为方括号内以逗号分隔的列表，例如 $[True,False,True,True]$。不应打印任何额外文本。所有内部计算必须遵守所述单位。角度必须以弧度为单位。不得使用百分比；任何分数量必须保留为十进制数。", "solution": "本问题的核心是实现一个能够处理库仑摩擦接触的隐式Newmark-β时间积分器。这需要将标准的Newmark-β更新与一个判断和施加摩擦力的“返回映射”算法相结合。以下是推导和实现的关键步骤。\n\n### 1. Newmark-β运动学与离散动力学方程\n\n首先，我们回顾隐式Newmark-β格式的更新规则。在一个时间步 $\\Delta t$ 内，从时间 $t_n$ 到 $t_{n+1}$，位移 $x$ 和速度 $v$ 的更新依赖于未知的加速度 $a_{n+1}$：\n$$\nx_{n+1} = x_n + v_n \\Delta t + \\left[ \\left(\\frac{1}{2}-\\beta\\right)a_n + \\beta a_{n+1} \\right] \\Delta t^2\n$$\n$$\nv_{n+1} = v_n + \\left[ (1-\\gamma)a_n + \\gamma a_{n+1} \\right] \\Delta t\n$$\n为了求解方便，我们可以将上式重写为“预测-修正”形式。首先计算不依赖于 $a_{n+1}$ 的预测值：\n$$\n\\tilde{x}_{n+1} = x_n + v_n \\Delta t + \\left(\\frac{1}{2}-\\beta\\right)a_n \\Delta t^2\n$$\n$$\n\\tilde{v}_{n+1} = v_n + (1-\\gamma)a_n \\Delta t\n$$\n然后，最终的位移和速度是：\n$$\nx_{n+1} = \\tilde{x}_{n+1} + \\beta \\Delta t^2 a_{n+1}\n$$\n$$\nv_{n+1} = \\tilde{v}_{n+1} + \\gamma \\Delta t a_{n+1}\n$$\n接下来，我们将这两个关系代入 $t_{n+1}$ 时刻的动力学平衡方程：\n$$\nm\\,a_{n+1} + c\\,v_{n+1} + k\\,x_{n+1} = f_{\\mathrm{ext}, n+1} + f_{\\mathrm{fr}, n+1}\n$$\n代入后，我们将所有包含未知量 $a_{n+1}$ 的项移到左边，得到一个关于 $a_{n+1}$ 和摩擦力 $f_{\\mathrm{fr}, n+1}$ 的方程：\n$$\n(m + c\\gamma\\Delta t + k\\beta\\Delta t^2) a_{n+1} = (f_{\\mathrm{ext}, n+1} - c\\tilde{v}_{n+1} - k\\tilde{x}_{n+1}) + f_{\\mathrm{fr}, n+1}\n$$\n我们可以定义“有效质量” $m^* = m + c\\gamma\\Delta t + k\\beta\\Delta t^2$ 和“残余驱动力” $f_{\\mathrm{res}, n+1} = f_{\\mathrm{ext}, n+1} - c\\tilde{v}_{n+1} - k\\tilde{x}_{n+1}$。这样，方程简化为：\n$$\nm^* a_{n+1} = f_{\\mathrm{res}, n+1} + f_{\\mathrm{fr}, n+1}\n$$\n这个方程有两个未知数：$a_{n+1}$ 和 $f_{\\mathrm{fr}, n+1}$。我们需要一个额外的本构关系来求解它们，这就是摩擦定律。\n\n### 2. 摩擦接触的返回映射算法\n\n在每个时间步，我们使用一个试探-检验（或称返回映射）的算法来确定摩擦状态（粘滞或滑动）和相应的摩擦力。\n\n**步骤 A: 试探粘滞 (Stick Trial)**\n我们首先假设在 $t_{n+1}$ 时刻，系统处于粘滞状态。这个假设施加了一个运动学约束：$v_{n+1} = v_b$。利用Newmark速度更新公式，我们可以求解出维持此粘滞状态所必需的加速度 $a_{n+1}^{\\text{stick}}$：\n$$\nv_b = \\tilde{v}_{n+1} + \\gamma \\Delta t \\, a_{n+1}^{\\text{stick}} \\implies a_{n+1}^{\\text{stick}} = \\frac{v_b - \\tilde{v}_{n+1}}{\\gamma \\Delta t}\n$$\n将这个加速度代入简化后的动力学方程，我们可以计算出维持粘滞所需的静摩擦力，记为 $\\lambda_{n+1}$：\n$$\n\\lambda_{n+1} = m^* a_{n+1}^{\\text{stick}} - f_{\\mathrm{res}, n+1}\n$$\n\n**步骤 B: 检查粘滞条件 (Check Stick Condition)**\n库仑摩擦定律规定，静摩擦力的大小不能超过最大静摩擦力 $f_{\\text{max}} = \\mu N$。因此，我们检查试探得到的 $\\lambda_{n+1}$ 是否满足这个条件：\n$$\n|\\lambda_{n+1}| \\le \\mu N\n$$\n\n**步骤 C: 判定与修正 (Decision and Correction)**\n1.  **如果 $|\\lambda_{n+1}| \\le \\mu N$**：粘滞假设成立。系统确实处于粘滞状态。最终的加速度就是 $a_{n+1} = a_{n+1}^{\\text{stick}}$，摩擦力就是 $f_{\\mathrm{fr}, n+1} = \\lambda_{n+1}$。\n2.  **如果 $|\\lambda_{n+1}| > \\mu N$**：粘滞假设不成立。系统必须滑动。摩擦力的大小达到其极限值 $\\mu N$，方向与即将发生的相对运动方向相反。这个方向由试探静摩擦力 $\\lambda_{n+1}$ 的符号给出。因此，动摩擦力为：\n    $$\n    f_{\\mathrm{fr}, n+1} = -\\mu N \\cdot \\mathrm{sign}(\\lambda_{n+1})\n    $$\n    现在摩擦力已知，我们可以回到简化的动力学方程，求解滑动状态下的加速度 $a_{n+1}^{\\text{slip}}$：\n    $$\n    a_{n+1}^{\\text{slip}} = \\frac{f_{\\mathrm{res}, n+1} + f_{\\mathrm{fr}, n+1}}{m^*}\n    $$\n    最终的加速度是 $a_{n+1} = a_{n+1}^{\\text{slip}}$。\n\n一旦确定了正确的 $a_{n+1}$，就可以使用Newmark运动学公式最终更新 $x_{n+1}$ 和 $v_{n+1}$。\n\n### 3. 度量指标的计算\n\n- **颤振分数 $C$**：在整个仿真过程中，跟踪每个时间步的摩擦状态（例如，用-1表示负向滑动，0表示粘滞，1表示正向滑动）。遍历时间历史记录，如果`状态(n) != 状态(n-1)` 并且相对速度 `|v_n - v_b|` 小于给定的阈值 $\\varepsilon_r$，则颤振计数器加一。最终将总计数除以总步数得到分数 $C$。\n- **振幅比 $R$**：对于每个测试案例，首先需要运行一个基准模拟（使用无耗散的平均加速度法，即 $\\beta=1/4, \\gamma=1/2$）。然后，通过取模拟后半段（以忽略初始暂态）位移的最大值和最小值的差的一半，来计算测试模拟和基准模拟的稳态振幅。$R$ 是测试振幅与基准振幅的比值。\n\n通过这套逻辑，程序可以模拟粘滑动力学，并根据定义的标准评估不同Newmark参数集的性能。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(m, k, c, mu, N, vb, A, omega, T, dt, beta, gamma):\n    \"\"\"\n    Simulates a single-degree-of-freedom system with Coulomb friction\n    using the implicit Newmark-beta method.\n    \"\"\"\n    num_steps = int(T / dt)\n    t_hist = np.linspace(0, T, num_steps + 1)\n    \n    x_hist = np.zeros(num_steps + 1)\n    v_hist = np.zeros(num_steps + 1)\n    a_hist = np.zeros(num_steps + 1)\n    # Friction state: 0=stick, 1=slip(v>vb), -1=slip(v<vb)\n    state_hist = np.zeros(num_steps + 1, dtype=int)\n    \n    # Initial conditions\n    x_n, v_n, a_n = 0.0, 0.0, 0.0\n    f_ext_n = A * np.sin(omega * t_hist[0])\n    # Initial acceleration from equilibrium (ignoring friction initially)\n    a_n = (f_ext_n - c * v_n - k * x_n) / m\n    a_hist[0] = a_n\n\n    f_friction_max = mu * N\n    m_star = m + c * gamma * dt + k * beta * dt**2\n\n    for n in range(num_steps):\n        t_n1 = t_hist[n+1]\n        \n        # Predictor step\n        x_tilde = x_n + v_n * dt + (0.5 - beta) * a_n * dt**2\n        v_tilde = v_n + (1 - gamma) * a_n * dt\n        \n        # Forces at t_{n+1}\n        f_ext_n1 = A * np.sin(omega * t_n1)\n        f_res = f_ext_n1 - c * v_tilde - k * x_tilde\n        \n        # Stick trial\n        if gamma == 0 or dt == 0:\n             # Avoid division by zero, though not expected in tests\n            a_stick = 0 \n        else:\n            a_stick = (vb - v_tilde) / (gamma * dt)\n        \n        lambda_n1 = m_star * a_stick - f_res\n\n        # Check stick condition\n        if np.abs(lambda_n1) <= f_friction_max:\n            # Stick is valid\n            a_n1 = a_stick\n            state_hist[n+1] = 0\n        else:\n            # Slip occurs\n            f_fr_n1 = -f_friction_max * np.sign(lambda_n1)\n            a_n1 = (f_res + f_fr_n1) / m_star\n            state_hist[n+1] = np.sign(lambda_n1)\n        \n        # Corrector step\n        x_n1 = x_tilde + beta * dt**2 * a_n1\n        v_n1 = v_tilde + gamma * dt * a_n1\n\n        # Store history\n        x_hist[n+1], v_hist[n+1], a_hist[n+1] = x_n1, v_n1, a_n1\n        \n        # Update for next step\n        x_n, v_n, a_n = x_n1, v_n1, a_n1\n        \n    return x_hist, v_hist, state_hist, num_steps\n\ndef get_steady_state_amplitude(x_hist, num_steps):\n    # Analyze second half of simulation for steady state\n    start_idx = num_steps // 2\n    x_steady = x_hist[start_idx:]\n    if len(x_steady) < 2:\n        return 0.0\n    return (np.max(x_steady) - np.min(x_steady)) / 2.0\n\ndef solve():\n    # Parameters\n    m = 1.0\n    k = 1000.0\n    c = 1.0\n    mu = 0.3\n    N = 10.0\n    vb = 0.0\n    A = 50.0\n    omega = np.sqrt(k / m)\n    T = 5.0\n    epsilon_r = 1e-3\n    C_max = 2e-2\n    R_min = 7e-1\n    \n    # Test Suite\n    test_cases = [\n        (0.25, 0.5, 5e-3),\n        (0.30, 0.60, 5e-3),\n        (0.40, 0.80, 5e-3),\n        (0.28, 0.62, 2e-3),\n    ]\n    \n    final_results = []\n    \n    # Cache for reference amplitudes\n    ref_amplitudes = {}\n\n    for beta_test, gamma_test, dt_test in test_cases:\n        # Get reference amplitude for this dt if not already computed\n        if dt_test not in ref_amplitudes:\n            x_ref, _, _, n_steps_ref = run_simulation(m, k, c, mu, N, vb, A, omega, T, dt_test, 0.25, 0.5)\n            ref_amplitudes[dt_test] = get_steady_state_amplitude(x_ref, n_steps_ref)\n        \n        ref_amp = ref_amplitudes[dt_test]\n\n        # Run the test case simulation\n        x_test, v_test, state_test, n_steps_test = run_simulation(m, k, c, mu, N, vb, A, omega, T, dt_test, beta_test, gamma_test)\n        \n        # Calculate Chatter Score C\n        chatter_count = 0\n        for i in range(1, n_steps_test + 1):\n            if state_test[i] != state_test[i-1] and np.abs(v_test[i] - vb) < epsilon_r:\n                chatter_count += 1\n        C = chatter_count / n_steps_test if n_steps_test > 0 else 0\n        \n        # Calculate Amplitude Ratio R\n        test_amp = get_steady_state_amplitude(x_test, n_steps_test)\n        R = test_amp / ref_amp if ref_amp > 0 else 0\n        \n        # Check if the region is \"good\"\n        is_good = (C <= C_max) and (R >= R_min)\n        final_results.append(is_good)\n        \n    print(str(final_results))\n\nsolve()\n```", "id": "3573269"}]}