{"hands_on_practices": [{"introduction": "复杂的非线性模型在小应变极限下必须能够回归到我们所熟知的线性行为，这一点至关重要。本练习将引导你为两种常见的体积应变能函数推导其等效体积模量和泊松比。通过这个练习[@problem_id:3585996]，你将在抽象的超弹性势能与经典的弹性常数之间建立起一座关键的桥梁。", "problem": "考虑一个可压缩各向同性超弹性固体，其模型采用 Ogden 型的解耦自由能，单位参考体积的总 Helmholtz 自由能写作 $W(\\mathbf{F}) = W_{\\text{iso}}(\\bar{\\mathbf{F}}) + U(J)$。其中，$\\mathbf{F}$ 是变形梯度，$J = \\det \\mathbf{F}$ 是雅可比行列式，而 $\\bar{\\mathbf{F}} = J^{-1/3} \\mathbf{F}$ 是变形梯度的等容部分。等容能 $W_{\\text{iso}}(\\bar{\\mathbf{F}})$ 经过标定，使其小应变极限能够再现一个目标剪切模量 $\\mu > 0$，而体积罚 $U(J)$ 决定了材料对体积膨胀的抵抗能力。在小应变情况下，这种解耦确保了等容部分仅对偏应力有贡献，而体积部分则主导球应力。\n\n从第一 Piola–Kirchhoff 应力的超弹性定义 $\\mathbf{P} = \\partial W / \\partial \\mathbf{F}$、恒等式 $\\partial J / \\partial \\mathbf{F} = J \\mathbf{F}^{-T}$ 以及在参考构型附近的线性化（其中无穷小应变张量 $\\boldsymbol{\\epsilon}$ 满足 $J = 1 + \\operatorname{tr}(\\boldsymbol{\\epsilon}) + \\mathcal{O}(|\\boldsymbol{\\epsilon}|^{2})$）出发，推导由以下每种体积势所蕴含的小应变静水响应：\n- 情况 A (Hencky 型体积能)：$U(J) = (\\kappa/2)(\\ln J)^{2}$，其中 $\\kappa > 0$。\n- 情况 B (广义多项式体积能)：$U(J) = (1/D)(J - 1)^{2}$，其中 $D > 0$。\n\n利用这些推导来：\n1. 计算每种情况下在参考状态 $J = 1$ 时的小应变体积模量。\n2. 利用解耦小应变极限 $\\boldsymbol{\\sigma} \\approx 2 \\mu \\operatorname{dev}(\\boldsymbol{\\epsilon}) + K \\operatorname{tr}(\\boldsymbol{\\epsilon}) \\mathbf{I}$，其中 $\\boldsymbol{\\sigma}$ 是 Cauchy 应力，$\\operatorname{dev}(\\boldsymbol{\\epsilon}) = \\boldsymbol{\\epsilon} - \\tfrac{1}{3} \\operatorname{tr}(\\boldsymbol{\\epsilon}) \\mathbf{I}$，且 $K$ 是在第 1 项中得到的体积模量，对每种情况推导相应的泊松比 $\\nu$（用 $\\mu$ 和 $K$ 表示）。\n\n将你的最终答案表示为一个单一的闭式解析表达式，按顺序 $\\{K_{\\text{A}}, \\nu_{\\text{A}}, K_{\\text{B}}, \\nu_{\\text{B}}\\}$ 包含这四个量，其中下标 A 和 B 分别指代上述两种体积势。不需要进行数值计算，并且你必须以无单位的形式表示最终答案。如果引入任何来自各向同性线弹性理论的辅助关系，需从本问题给出的定义出发进行推导，而不是直接引用它们。因为答案是符号形式，所以不适用四舍五入。", "solution": "我们从一般的超弹性框架开始。单位参考体积的总自由能为 $W(\\mathbf{F}) = W_{\\text{iso}}(\\bar{\\mathbf{F}}) + U(J)$，其中 $J = \\det \\mathbf{F}$ 且 $\\bar{\\mathbf{F}} = J^{-1/3} \\mathbf{F}$。第一 Piola–Kirchhoff 应力为\n$$\n\\mathbf{P} = \\frac{\\partial W}{\\partial \\mathbf{F}} = \\frac{\\partial W_{\\text{iso}}}{\\partial \\mathbf{F}} + \\frac{\\partial U}{\\partial J} \\frac{\\partial J}{\\partial \\mathbf{F}}.\n$$\n利用恒等式 $\\frac{\\partial J}{\\partial \\mathbf{F}} = J \\mathbf{F}^{-T}$，$\\mathbf{P}$ 的体积贡献为\n$$\n\\mathbf{P}_{\\text{vol}} = U'(J) \\, J \\, \\mathbf{F}^{-T},\n$$\n其中 $U'(J) = \\frac{d U}{d J}$。Cauchy 应力 $\\boldsymbol{\\sigma}$ 由 $\\boldsymbol{\\sigma} = \\frac{1}{J} \\mathbf{P} \\mathbf{F}^{T}$ 给出。因此，Cauchy 应力的体积部分是\n$$\n\\boldsymbol{\\sigma}_{\\text{vol}} = \\frac{1}{J} \\mathbf{P}_{\\text{vol}} \\mathbf{F}^{T} = \\frac{1}{J} \\left( U'(J) \\, J \\, \\mathbf{F}^{-T} \\right) \\mathbf{F}^{T} = U'(J) \\, \\mathbf{I}.\n$$\n因此，对 Cauchy 应力的体积贡献是纯球形的，其大小为 $U'(J)$。\n\n接下来，我们考虑小应变极限。令 $\\boldsymbol{\\epsilon}$ 为无穷小应变张量，并在参考构型附近展开 $J$：\n$$\nJ = 1 + \\operatorname{tr}(\\boldsymbol{\\epsilon}) + \\mathcal{O}(|\\boldsymbol{\\epsilon}|^{2}).\n$$\n我们也在 $J = 1$ 附近展开 $U'(J)$：\n$$\nU'(J) = U'(1) + U''(1) (J - 1) + \\mathcal{O}((J - 1)^{2}).\n$$\n对于无应力参考构型，我们要求 $U'(1) = 0$，给出的两种体积形式都满足此条件。保留应变的一阶项，\n$$\n\\boldsymbol{\\sigma}_{\\text{vol}} \\approx U''(1) (J - 1) \\mathbf{I} \\approx U''(1) \\, \\operatorname{tr}(\\boldsymbol{\\epsilon}) \\, \\mathbf{I}.\n$$\n由于使用了 $\\bar{\\mathbf{F}} = J^{-1/3} \\mathbf{F}$ 实现了等容-体积解耦，等容能 $W_{\\text{iso}}(\\bar{\\mathbf{F}})$ 在小应变下仅对偏应力有贡献，并被标定以产生目标剪切模量 $\\mu$。因此，完整的小应变 Cauchy 应力具有以下形式\n$$\n\\boldsymbol{\\sigma} \\approx 2 \\mu \\, \\operatorname{dev}(\\boldsymbol{\\epsilon}) + K \\, \\operatorname{tr}(\\boldsymbol{\\epsilon}) \\, \\mathbf{I},\n$$\n其中\n$$\nK = U''(1).\n$$\n\n我们现在为每种体积势计算 $U''(1)$。\n\n情况 A：$U(J) = \\frac{\\kappa}{2} (\\ln J)^{2}$。\n计算一阶导数：\n$$\nU'(J) = \\kappa \\, \\frac{\\ln J}{J}.\n$$\n计算二阶导数：\n$$\nU''(J) = \\kappa \\, \\frac{d}{dJ} \\left( \\frac{\\ln J}{J} \\right) = \\kappa \\, \\frac{1 - \\ln J}{J^{2}}.\n$$\n在 $J = 1$ 处求值：\n$$\nU''(1) = \\kappa \\, \\frac{1 - \\ln 1}{1^{2}} = \\kappa.\n$$\n因此，情况 A 的体积模量为\n$$\nK_{\\text{A}} = \\kappa.\n$$\n\n情况 B：$U(J) = \\frac{1}{D} (J - 1)^{2}$。\n计算一阶导数：\n$$\nU'(J) = \\frac{2}{D} (J - 1).\n$$\n计算二阶导数：\n$$\nU''(J) = \\frac{2}{D}.\n$$\n在 $J = 1$ 处求值：\n$$\nU''(1) = \\frac{2}{D}.\n$$\n因此，情况 B 的体积模量为\n$$\nK_{\\text{B}} = \\frac{2}{D}.\n$$\n\n为了得到泊松比，我们将小应变表示与各向同性线弹性中以拉梅参数表示的标准双参数描述联系起来。在一个解耦超弹性模型中，其小应变形式为 $\\boldsymbol{\\sigma} = 2 \\mu \\, \\operatorname{dev}(\\boldsymbol{\\epsilon}) + K \\, \\operatorname{tr}(\\boldsymbol{\\epsilon}) \\, \\mathbf{I}$，有效的拉梅参数为\n$$\n\\lambda = K - \\frac{2}{3} \\mu, \\quad \\mu = \\mu.\n$$\n对于各向同性线弹性材料，用 $\\lambda$ 和 $\\mu$ 表示的泊松比 $\\nu$ 为\n$$\n\\nu = \\frac{\\lambda}{2 (\\lambda + \\mu)}.\n$$\n代入 $\\lambda = K - \\frac{2}{3} \\mu$，\n\\begin{align*}\n\\nu = \\frac{K - \\frac{2}{3} \\mu}{2 \\left( K - \\frac{2}{3} \\mu + \\mu \\right)}\n= \\frac{K - \\frac{2}{3} \\mu}{2 \\left( K + \\frac{1}{3} \\mu \\right)}\n= \\frac{3 K - 2 \\mu}{2 (3 K + \\mu)}.\n\\end{align*}\n因此，对于每种情况，\n- 情况 A：$K_{\\text{A}} = \\kappa$ 且\n$$\n\\nu_{\\text{A}} = \\frac{3 \\kappa - 2 \\mu}{2 (3 \\kappa + \\mu)}.\n$$\n- 情况 B：$K_{\\text{B}} = \\frac{2}{D}$ 且\n$$\n\\nu_{\\text{B}} = \\frac{3 \\left( \\frac{2}{D} \\right) - 2 \\mu}{2 \\left( 3 \\left( \\frac{2}{D} \\right) + \\mu \\right)} = \\frac{\\frac{6}{D} - 2 \\mu}{2 \\left( \\frac{6}{D} + \\mu \\right)}.\n$$\n\n这些表达式完成了在参考状态下体积模量的推导，以及对于指定的体积能，用目标剪切模量 $\\mu$ 表示的相应泊松比的推导。", "answer": "$$\\boxed{\\begin{pmatrix} \\kappa & \\dfrac{3 \\kappa - 2 \\mu}{2 (3 \\kappa + \\mu)} & \\dfrac{2}{D} & \\dfrac{\\tfrac{6}{D} - 2 \\mu}{2 \\left( \\tfrac{6}{D} + \\mu \\right)} \\end{pmatrix}}$$", "id": "3585996"}, {"introduction": "在构建了本构模型之后，下一步是确保其物理真实性。本练习将介绍一个基本的材料稳定性判据——贝克-埃里克森（Baker-Ericksen）不等式，它要求更大的拉伸产生更大的应力。你将通过分析奥格登（Ogden）模型[@problem_id:3586040]，推导出其材料参数必须满足的条件，以确保这种符合物理直觉的行为，从而理解数学上的一致性必须与物理上的合理性相结合。", "problem": "一个不可压缩、各向同性的超弹性固体由一个应变能密度 $W(\\lambda_1,\\lambda_2,\\lambda_3)$ 定义，该函数对于主伸长 $\\lambda_i$ 是对称的，并受到约束条件 $\\lambda_1 \\lambda_2 \\lambda_3 = 1$ 的限制。Baker–Ericksen (BE) 不等式要求，对于任意两个不同的主伸长 $\\lambda_i \\ne \\lambda_j$，相应的主柯西应力满足 $(\\sigma_i - \\sigma_j)(\\lambda_i - \\lambda_j) > 0$，等号仅在 $\\lambda_i = \\lambda_j$ 时成立。柯西应力由超弹性本构律和强制不可压缩性的拉格朗日乘子得到。\n\n考虑具有以下应变能密度的 $N$ 项不可压缩 Ogden 模型\n$$\nW(\\lambda_1,\\lambda_2,\\lambda_3) = \\sum_{p=1}^N \\frac{\\mu_p}{\\alpha_p} \\left(\\lambda_1^{\\alpha_p} + \\lambda_2^{\\alpha_p} + \\lambda_3^{\\alpha_p} - 3\\right),\n$$\n其中 $\\alpha_p \\in \\mathbb{R}\\setminus\\{0\\}$ 和 $\\mu_p \\in \\mathbb{R}$ 是材料参数，因子 $-3$ 确保在参考状态 $\\lambda_1=\\lambda_2=\\lambda_3=1$ 时能量为零。\n\n从不可压缩材料的超弹性响应的定义出发，推导主柯西应力，然后获得一个关于 $\\{\\mu_p,\\alpha_p\\}$ 的条件，该条件能保证 Baker–Ericksen 不等式对于所有主伸长有序 ($\\lambda_i > \\lambda_j$) 的等容状态都成立。根据您的推导，以下关于参数的陈述中，哪一个是保证 Baker–Ericksen 不等式对所有 $\\lambda_i \\ne \\lambda_j$ 都严格成立的充分必要条件？\n\nA. 对所有 $p$，$\\mu_p > 0$ 且 $\\alpha_p > 0$。\n\nB. 对所有 $\\alpha_p \\ne 0$ 的 $p$，$\\mu_p \\alpha_p > 0$。\n\nC. $\\sum_{p=1}^N \\mu_p > 0$，其中 $\\alpha_p \\ne 0$ 是任意的。\n\nD. 对所有 $p$，$\\mu_p \\ge 0$，其中 $\\alpha_p \\in \\mathbb{R}$ 是任意的。\n\nE. $\\mu_p$ 是任意的，且所有 $\\alpha_p$ 都是正奇整数。", "solution": "## 问题验证\n\n### 第 1 步：提取已知条件\n-   材料是不可压缩、各向同性的超弹性固体。\n-   应变能密度为 $W(\\lambda_1,\\lambda_2,\\lambda_3)$，它在主伸长 $\\lambda_i$ 上是对称的。\n-   不可压缩性约束为 $\\lambda_1 \\lambda_2 \\lambda_3 = 1$。\n-   Baker–Ericksen (BE) 不等式为 $(\\sigma_i - \\sigma_j)(\\lambda_i - \\lambda_j) > 0$，适用于任意两个不同的主伸长 $\\lambda_i \\ne \\lambda_j$，其中 $\\sigma_i$ 是主柯西应力。\n-   $N$ 项不可压缩 Ogden 模型的应变能密度由下式给出：\n    $$ W(\\lambda_1,\\lambda_2,\\lambda_3) = \\sum_{p=1}^N \\frac{\\mu_p}{\\alpha_p} \\left(\\lambda_1^{\\alpha_p} + \\lambda_2^{\\alpha_p} + \\lambda_3^{\\alpha_p} - 3\\right) $$\n-   材料参数为 $\\alpha_p \\in \\mathbb{R}\\setminus\\{0\\}$ 和 $\\mu_p \\in \\mathbb{R}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题基于成熟的非线性弹性和超弹性理论。Ogden 模型、不可压缩性约束和 Baker–Ericksen 不等式是连续介质力学中的标准概念。\n2.  **适定性：** 问题要求为模型参数找到一个满足特定物理稳定性准则的充分必要条件。可以推导出一个唯一的条件。\n3.  **客观性：** 问题以精确的数学和物理术语陈述，没有主观性。\n4.  **无其他缺陷**（不完整、矛盾、不切实际、不适定等）存在。问题陈述是自洽且逻辑清晰的。\n\n### 第 3 步：结论与行动\n该问题是 **有效的**。现在开始求解过程。\n\n## 推导与分析\n\n对于不可压缩、各向同性的超弹性材料，主柯西应力 $\\sigma_i$ 通过以下公式与应变能密度函数 $W(\\lambda_1, \\lambda_2, \\lambda_3)$ 相关：\n$$ \\sigma_i = -p + \\lambda_i \\frac{\\partial W}{\\partial \\lambda_i} $$\n其中 $p$ 是一个任意的静水压力（强制不可压缩性约束的拉格朗日乘子）。$p$ 的具体值取决于边界条件，但在考虑应力差时它会被抵消。\n\n我们来计算两个主应力 $\\sigma_i$ 和 $\\sigma_j$ 之间的差值：\n$$ \\sigma_i - \\sigma_j = \\left(-p + \\lambda_i \\frac{\\partial W}{\\partial \\lambda_i}\\right) - \\left(-p + \\lambda_j \\frac{\\partial W}{\\partial \\lambda_j}\\right) = \\lambda_i \\frac{\\partial W}{\\partial \\lambda_i} - \\lambda_j \\frac{\\partial W}{\\partial \\lambda_j} $$\n现在，我们代入给定的 Ogden 模型应变能密度函数：\n$$ W = \\sum_{p=1}^N \\frac{\\mu_p}{\\alpha_p} \\left(\\lambda_1^{\\alpha_p} + \\lambda_2^{\\alpha_p} + \\lambda_3^{\\alpha_p} - 3\\right) $$\n$W$ 对主伸长 $\\lambda_k$ 的偏导数为：\n$$ \\frac{\\partial W}{\\partial \\lambda_k} = \\sum_{p=1}^N \\frac{\\mu_p}{\\alpha_p} \\left( \\alpha_p \\lambda_k^{\\alpha_p - 1} \\right) = \\sum_{p=1}^N \\mu_p \\lambda_k^{\\alpha_p - 1} $$\n乘以 $\\lambda_k$ 得到：\n$$ \\lambda_k \\frac{\\partial W}{\\partial \\lambda_k} = \\lambda_k \\sum_{p=1}^N \\mu_p \\lambda_k^{\\alpha_p - 1} = \\sum_{p=1}^N \\mu_p \\lambda_k^{\\alpha_p} $$\n因此，主应力差为：\n$$ \\sigma_i - \\sigma_j = \\sum_{p=1}^N \\mu_p \\lambda_i^{\\alpha_p} - \\sum_{p=1}^N \\mu_p \\lambda_j^{\\alpha_p} = \\sum_{p=1}^N \\mu_p \\left( \\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p} \\right) $$\nBaker–Ericksen (BE) 不等式为 $(\\sigma_i - \\sigma_j)(\\lambda_i - \\lambda_j) > 0$（对于 $\\lambda_i \\ne \\lambda_j$）。代入我们的应力差表达式，得到：\n$$ (\\lambda_i - \\lambda_j) \\sum_{p=1}^N \\mu_p \\left( \\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p} \\right) > 0 $$\n由于 $\\lambda_i \\ne \\lambda_j$，则 $(\\lambda_i - \\lambda_j)^2 > 0$。我们可以用这个正量除以不等式两边，而不会改变其方向：\n$$ \\sum_{p=1}^N \\mu_p \\frac{\\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p}}{\\lambda_i - \\lambda_j} > 0 $$\n我们来分析 $S_p = \\frac{\\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p}}{\\lambda_i - \\lambda_j}$ 这一项。这是函数 $f(t) = t^{\\alpha_p}$ 在 $\\lambda_j$ 和 $\\lambda_i$ 之间的区间上的割线斜率。根据中值定理，在 $\\lambda_j$ 和 $\\lambda_i$ 之间存在一个值 $c_p$，使得 $S_p = f'(c_p) = \\alpha_p c_p^{\\alpha_p - 1}$。由于主伸长是正的，即 $\\lambda_i, \\lambda_j > 0$，这意味着 $c_p > 0$。因此，对于任何实数指数 $\\alpha_p$，$c_p^{\\alpha_p-1} > 0$。所以，$S_p$ 的符号完全由 $\\alpha_p$ 的符号决定：\n$$ \\text{sign}\\left(\\frac{\\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p}}{\\lambda_i - \\lambda_j}\\right) = \\text{sign}(\\alpha_p) $$\nBE 不等式可以表示为：\n$$ \\sum_{p=1}^N \\mu_p \\cdot S_p > 0 $$\n我们把 $S_p$ 写成 $S_p = \\alpha_p K_p$，其中 $K_p = c_p^{\\alpha_p - 1} = \\frac{1}{\\alpha_p} \\frac{\\lambda_i^{\\alpha_p} - \\lambda_j^{\\alpha_p}}{\\lambda_i - \\lambda_j}$。由于 $\\alpha_p$ 和 $S_p$ 符号相同，所以 $K_p$ 总是正的。不等式变为：\n$$ \\sum_{p=1}^N (\\mu_p \\alpha_p) K_p(\\lambda_i, \\lambda_j, \\alpha_p) > 0 $$\n这个不等式是一个系数 $(\\mu_p \\alpha_p)$ 与正权重函数 $K_p$ 乘积之和，它必须对所有可能的等容状态（即对所有允许的 $\\lambda_i, \\lambda_j > 0$ 选择）都成立。\n\n**充分性：** 如果我们强制要求对所有 $p=1, ..., N$，都有 $\\mu_p \\alpha_p > 0$，那么和式中的每一项 $(\\mu_p \\alpha_p) K_p$ 都是两个正数的乘积，因此是正的。严格正数项的和是严格正的。因此，条件 $\\mu_p \\alpha_p > 0$ 对所有 $p$ 成立是保证 BE 不等式成立的充分条件。\n\n**必要性：** 我们必须证明，如果不满足该条件，则至少存在一种变形状态，使得 BE 不等式被违反。假设“对所有 $p$ 都有 $\\mu_p \\alpha_p > 0$”这一条件不成立。鉴于问题陈述 $\\alpha_p \\ne 0$，这意味着至少存在一个索引 $k$，使得 $\\mu_k \\alpha_k < 0$。（$\\mu_k \\alpha_k=0$ 的情况将在下面讨论）。\n将索引集合划分为 $P_+ = \\{p | \\mu_p \\alpha_p > 0 \\}$ 和 $P_- = \\{p | \\mu_p \\alpha_p < 0 \\}$。根据假设，$P_-$ 是非空的。条件是：\n$$ \\sum_{p \\in P_+} |\\mu_p \\alpha_p| K_p - \\sum_{k \\in P_-} |\\mu_k \\alpha_k| K_k > 0 $$\n权重函数 $K_p = \\frac{1}{\\lambda_i - \\lambda_j} \\int_{\\lambda_j}^{\\lambda_i} t^{\\alpha_p - 1} dt$ 的大小强烈依赖于指数 $\\alpha_p$ 和变形范围 $[\\lambda_j, \\lambda_i]$。\n-   对于大拉伸（$\\lambda_i \\to \\infty$，$\\lambda_j$ 固定），$K_p$ 对最大的 $\\alpha_p$ 值增长最快。\n-   对于大压缩（$\\lambda_j \\to 0$，$\\lambda_i$ 固定），$K_p$ 对最小的（最负的）$\\alpha_p$ 值增长最快。\n\n如果存在一个项 $k \\in P_-$，使得其 $\\alpha_k$ 大于所有 $p \\in P_+$ 的 $\\alpha_p$，那么通过选择一个大拉伸状态（大的 $\\lambda_i$），负项 $|\\mu_k \\alpha_k| K_k$ 将在和式中占主导地位，导致不等式被违反。\n类似地，如果存在一个项 $k \\in P_-$，其 $\\alpha_k$ 小于所有 $p \\in P_+$ 的 $\\alpha_p$，那么在一个大压缩状态（小的 $\\lambda_j$）下，其对应的项 $K_k$ 将占主导地位，同样违反不等式。\n对于任何指数集合，总可以找到一个变形状态 $(\\lambda_i, \\lambda_j)$，它能足够大地放大 $\\mu_k \\alpha_k < 0$ 项的权重 $K_k$（相对于 $\\mu_p \\alpha_p > 0$ 的项的权重），从而违反 BE 条件。\n因此，为了让不等式对 *所有* 等容状态都成立，不能有 $\\mu_p \\alpha_p < 0$ 的项。这意味着 $\\mu_p \\alpha_p \\ge 0$ 是一个必要条件。\n\n对于严格不等式，我们需要和为严格正数，这意味着至少有一项必须非零。短语“N 项 Ogden 模型”意味着有 N 个非零项，所以对所有 $p=1,...,N$ 都有 $\\mu_p \\ne 0$。在这种标准解释下，条件 $\\mu_p \\alpha_p \\ge 0$ 变为 $\\mu_p \\alpha_p > 0$，因为 $\\mu_p$ 和 $\\alpha_p$ 都不能为零。因此，对所有 $p$ 都有 $\\mu_p \\alpha_p > 0$ 的条件是充分且必要的。\n\n## 逐项分析\n\nA. **对所有 $p$，$\\mu_p > 0$ 且 $\\alpha_p > 0$。**\n这个条件意味着对所有 $p$ 都有 $\\mu_p \\alpha_p > 0$。如上所示，这是一个充分条件。但它不是必要的。例如，一个具有 $\\mu_p < 0$ 和 $\\alpha_p < 0$ 的项同样可以得到 $\\mu_p \\alpha_p > 0$，并对满足 BE 不等式做出正向贡献。因此，这个选项限制性太强，不是必要条件。\n**结论：不正确。**\n\nB. **对所有 $\\alpha_p \\ne 0$ 的 $p$，$\\mu_p \\alpha_p > 0$。**\n问题陈述已经指明对所有 $p$ 都有 $\\alpha_p \\ne 0$。因此，该条件等价于对所有 $p$ 都有 $\\mu_p \\alpha_p > 0$。如上推导，该条件既是必要的（在所有 N 项都非平凡的标准解释下）也是充分的，以保证 BE 不等式对所有变形都严格成立。\n**结论：正确。**\n\nC. **$\\sum_{p=1}^N \\mu_p > 0$，其中 $\\alpha_p \\ne 0$ 是任意的。**\n这个条件不充分。考虑一个双项模型，其中 $\\mu_1 = 10, \\alpha_1=2$ 和 $\\mu_2=-1, \\alpha_2=4$。这里 $\\sum \\mu_p = 9 > 0$。BE 条件要求 $10\\frac{\\lambda_i^2 - \\lambda_j^2}{\\lambda_i - \\lambda_j} - 1\\frac{\\lambda_i^4 - \\lambda_j^4}{\\lambda_i - \\lambda_j} > 0$。这可以简化为 $10(\\lambda_i+\\lambda_j) - (\\lambda_i+\\lambda_j)(\\lambda_i^2+\\lambda_j^2) > 0$，或 $10 - (\\lambda_i^2+\\lambda_j^2) > 0$。这个不等式显然不适用于所有伸长，例如，当 $\\lambda_i=4$ 时就不成立。\n**结论：不正确。**\n\nD. **对所有 $p$，$\\mu_p \\ge 0$，其中 $\\alpha_p \\in \\mathbb{R}$ 是任意的。**\n这个条件允许某些 $p$ 存在 $\\mu_p > 0$ 和 $\\alpha_p < 0$ 的情况。在这种情况下，$\\mu_p \\alpha_p < 0$，我们已经证明这违反了必要性。例如，设 $N=1, \\mu_1=1>0, \\alpha_1=-2$。BE 不等式变为 $1 \\cdot (\\lambda_i^{-2} - \\lambda_j^{-2})(\\lambda_i - \\lambda_j) > 0$。如果我们取 $\\lambda_i > \\lambda_j$，则 $\\lambda_i^{-2} < \\lambda_j^{-2}$，使得第一项为负，而第二项为正。它们的乘积为负，违反了不等式。\n**结论：不正确。**\n\nE. **$\\mu_p$ 是任意的，且所有 $\\alpha_p$ 都是正奇整数。**\n这不充分。如果我们选择 $\\mu_p < 0$ 且 $\\alpha_p$ 为一个正整数（无论奇偶），那么 $\\mu_p \\alpha_p < 0$，这就违反了必要条件。例如，设 $N=1, \\mu_1=-1, \\alpha_1=3$。BE 不等式变为 $-1 \\cdot (\\lambda_i^3 - \\lambda_j^3)(\\lambda_i - \\lambda_j) > 0$。对于 $\\lambda_i \\ne \\lambda_j$，左边的两个因子符号相同，使其乘积为正。乘以 $-1$ 后整个表达式变为负数，违反了不等式。\n**结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "3586040"}, {"introduction": "最后一个也是最全面的练习，将理论模型与实验现实联系起来。这个编程练习[@problem_id:3586046]模拟了材料科学家工作的完整流程：生成带有噪声的模拟实验数据，使用非线性最小二乘法拟合奥格登（Ogden）模型参数，并从统计学上评估所拟合参数的可靠性和唯一性。这个实践项目将帮助你掌握模型校准的关键技能，并亲身体验参数可辨识性在实际应用中的挑战。", "problem": "构建一个完整的程序，对在单轴拉伸作用下、由 Ogden 应变能函数建模的不可压缩各向同性超弹性固体进行参数辨识和可辨识性评估。从超弹性的第一性原理出发：根据主伸长定义应变能密度函数，通过变形梯度行列式等于1的约束施加不可压缩性，通过能量共轭获得主柯西应力，并针对横向应力为零的单轴拉伸情况进行特化，以推导单轴柯西应力作为伸长的函数。使用此本构关系生成带有指定标准差的附加零均值高斯噪声的合成数据（所有应力均以兆帕（MPa）表示）。构建一个带边界约束的非线性最小二乘估计问题，以从含噪声数据中恢复 Ogden 参数。通过残差映射的局部线性化来量化鲁棒性和可辨识性：根据最优点处的雅可比矩阵计算近似的参数协方差矩阵，并推导出 $95\\%$ 置信区间宽度。统计结论必须使用残差的数值、多次初始猜测下的参数变化以及置信区间进行论证。\n\n您的程序必须实现以下内容，并严格遵守规范：\n\n- 待使用的基本原理：\n    - 不可压缩各向同性材料的超弹性：应变能密度函数 $W$ 取决于主伸长，柯西应力通过 $W$ 的功共轭导数与一个强制不可压缩性的拉格朗日乘子相结合得出，在单轴试验中通过适当选择拉格朗日乘子来强制横向应力为零。\n    - 非线性最小二乘估计：估计器通过最小化模型预测应力与观测应力数据之间的残差平方和来工作。\n    - 局部统计线性化：从解处的残差雅可比矩阵近似计算费雪信息矩阵（FIM）、参数估计的协方差以及 $95\\%$ 置信区间。\n\n- 建模与数据生成：\n    1. 使用两项（$N=2$）或三项（$N=3$）Ogden 模型。Ogden 应变能密度参数为对偶 $(\\mu_i,\\alpha_i)$，其中 $i=1,\\dots,N$，$\\mu_i$ 的单位为兆帕（MPa），$\\alpha_i$ 为无量纲。对于单轴拉伸，主伸长满足不可压缩性，且横向柯西应力消失。\n    2. 通过在指定伸长下评估推导出的柯西应力表达式，并添加具有指定标准差的高斯噪声，来生成合成的单轴拉伸数据。所有应力必须以 MPa 为单位。\n\n- 估计与可辨识性评估：\n    1. 通过使用带边界约束的非线性最小二乘法，最小化含噪数据与模型预测之间的残差平方和，来拟合 Ogden 参数 $(\\mu_i,\\alpha_i)$。使用在指定边界内采样的不同初始猜测值执行多次拟合。\n    2. 对于每次拟合，计算最优点处残差关于参数的雅可比矩阵。根据雅可比矩阵 $J$ 和残差 $\\mathbf{r}$，计算残差方差 $\\hat{\\sigma}^2$（即残差平方和除以自由度），近似协方差矩阵 $\\Sigma \\approx \\hat{\\sigma}^2 (J^\\top J)^{-1}$（若 $J^\\top J$ 是病态的，则使用伪逆），以及每个参数 $i$ 的 $95\\%$ 置信区间宽度 $w_i \\approx 2 \\cdot 1.96 \\cdot \\sqrt{\\Sigma_{ii}}$。\n    3. 综合所有初始猜测的结果，计算：\n        - 参数间的最大相对绝对误差，定义为 $\\max_i \\left| \\hat{\\theta}_i - \\theta_i^\\star \\right| / \\left| \\theta_i^\\star \\right|$，其中 $\\hat{\\theta}_i$ 表示多次运行的平均估计值，$\\theta_i^\\star$ 表示真实参数。\n        - 参数间的最大相对标准差，定义为 $\\max_i \\operatorname{std}(\\hat{\\theta}_i^{(k)}) / \\left| \\hat{\\theta}_i \\right|$，其中 $\\hat{\\theta}_i^{(k)}$ 是来自不同初始猜测的估计值，$\\hat{\\theta}_i$ 是它们的平均值。\n        - 参数间的最大平均相对 $95\\%$ 置信区间宽度，定义为 $\\max_i \\overline{w_i} / \\left| \\hat{\\theta}_i \\right|$，其中 $\\overline{w_i}$ 是多次运行的平均区间宽度。\n\n- 鲁棒性判定规则：\n    - 对于每个约束方案，如果以下所有条件同时满足，则宣布拟合是鲁棒的：\n        1. 最大相对绝对误差小于或等于 $0.25$。\n        2. 最大相对标准差小于或等于 $0.30$。\n        3. 最大平均相对置信区间宽度小于或等于 $0.50$。\n    - 对于每个测试案例，只有在下述两种约束方案下都保持鲁棒性时，才宣布整体鲁棒性为真。\n\n- 约束方案与初始猜测：\n    - 宽边界：对于每个 $i$，使用 $\\mu_i \\in [0.01, 5.0]$ MPa 和 $\\alpha_i \\in [0.5, 8.0]$。\n    - 窄边界：对于每个 $i$，使用 $\\mu_i \\in [0.01, 2.0]$ MPa 和 $\\alpha_i \\in [0.5, 6.0]$。\n    - 对于每个方案，从在指定边界内均匀采样的初始猜测开始，执行 $6$ 次独立的拟合。\n\n- 测试套件（所有应力以 MPa 表示；不出现角度；百分比必须作为小数处理）：\n    1. 案例 A（理想情况，两项 Ogden，中等噪声，宽拉伸范围）：\n        - 真实参数：$(\\mu_1,\\alpha_1) = (0.8, 1.3)$，$(\\mu_2,\\alpha_2) = (0.2, 5.0)$。\n        - 拉伸范围：在 $[1.0, 1.6]$ 内均匀分布的 $25$ 个点。\n        - 噪声标准差：$0.02$。\n        - 模型：$N=2$ 项。\n    2. 案例 B（由于指数相近而接近不可辨识）：\n        - 真实参数：$(\\mu_1,\\alpha_1) = (0.5, 2.0)$，$(\\mu_2,\\alpha_2) = (0.5, 2.2)$。\n        - 拉伸范围：在 $[1.0, 1.6]$ 内均匀分布的 $25$ 个点。\n        - 噪声标准差：$0.02$。\n        - 模型：$N=2$ 项。\n    3. 案例 C（高噪声）：\n        - 真实参数：$(\\mu_1,\\alpha_1) = (0.6, 1.2)$，$(\\mu_2,\\alpha_2) = (0.4, 4.0)$。\n        - 拉伸范围：在 $[1.0, 1.6]$ 内均匀分布的 $25$ 个点。\n        - 噪声标准差：$0.20$。\n        - 模型：$N=2$ 项。\n    4. 案例 D（窄拉伸范围内的激励有限，三项 Ogden）：\n        - 真实参数：$(\\mu_1,\\alpha_1) = (0.3, 1.0)$，$(\\mu_2,\\alpha_2) = (0.4, 2.0)$，$(\\mu_3,\\alpha_3) = (0.3, 6.0)$。\n        - 拉伸范围：在 $[1.0, 1.1]$ 内均匀分布的 $25$ 个点。\n        - 噪声标准差：$0.02$。\n        - 模型：$N=3$ 项。\n\n- 最终输出格式：\n    - 您的程序应生成一行输出，其中包含案例 A、B、C 和 D 的鲁棒性判定结果，形式为方括号内以逗号分隔的布尔值列表（例如，`[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]`）。\n\n必须遵守的假设：\n- 所有应力必须以兆帕（MPa）表示。\n- 不出现角度；不需要角度单位。\n- 百分比必须按照上述定义的鲁棒性阈值表示为小数。\n\n程序必须是完全自包含的，不接受任何输入，并严格遵循指定的输出格式。", "solution": "我们从不可压缩各向同性材料的超弹性原理开始。设主伸长为 $\\lambda_1$、$\\lambda_2$ 和 $\\lambda_3$，通过约束 $\\lambda_1 \\lambda_2 \\lambda_3 = 1$ 来强制不可压缩性。具有 $N$ 项的 Ogden 应变能函数定义为\n$$\nW(\\lambda_1,\\lambda_2,\\lambda_3) = \\sum_{i=1}^N \\frac{\\mu_i}{\\alpha_i}\\left(\\lambda_1^{\\alpha_i} + \\lambda_2^{\\alpha_i} + \\lambda_3^{\\alpha_i} - 3\\right),\n$$\n其中 $\\mu_i$ 是类剪切模量（单位为兆帕，MPa），$\\alpha_i$ 是无量纲指数。\n\n在超弹性理论中，主柯西应力分量 $\\sigma_k$ 通过以下方式与伸长功共轭：\n$$\n\\sigma_k = \\lambda_k \\frac{\\partial W}{\\partial \\lambda_k} - p,\n$$\n其中 $p$ 是与强制不可压缩性 $\\lambda_1 \\lambda_2 \\lambda_3 = 1$ 相关的拉格朗日乘子。将 $W$ 对 $\\lambda_k$ 求导得到\n$$\n\\frac{\\partial W}{\\partial \\lambda_k} = \\sum_{i=1}^N \\mu_i \\lambda_k^{\\alpha_i - 1}.\n$$\n因此，\n$$\n\\sigma_k = \\lambda_k \\sum_{i=1}^N \\mu_i \\lambda_k^{\\alpha_i - 1} - p = \\sum_{i=1}^N \\mu_i \\lambda_k^{\\alpha_i} - p.\n$$\n\n对于沿方向 1 的单轴拉伸，伸长满足 $\\lambda_1 = \\lambda$，不可压缩性意味着 $\\lambda_2 = \\lambda_3 = \\lambda^{-1/2}$。施加零横向应力，即 $\\sigma_2 = 0$ 和 $\\sigma_3 = 0$，来确定拉格朗日乘子：\n$$\n0 = \\sigma_2 = \\sum_{i=1}^N \\mu_i \\lambda_2^{\\alpha_i} - p \\quad \\Rightarrow \\quad p = \\sum_{i=1}^N \\mu_i \\lambda^{- \\alpha_i / 2}.\n$$\n因此，单轴柯西应力为\n$$\n\\sigma(\\lambda; \\{\\mu_i,\\alpha_i\\}_{i=1}^N) = \\sum_{i=1}^N \\mu_i \\left( \\lambda^{\\alpha_i} - \\lambda^{-\\alpha_i / 2} \\right),\n$$\n单位为兆帕（MPa）。这是用于生成合成数据和拟合参数的本构关系。\n\n我们通过选择一组伸长 $\\{\\lambda_j\\}_{j=1}^M$ 并根据真实参数计算无噪声应力 $\\sigma(\\lambda_j)$ 来生成合成数据；然后添加零均值高斯噪声 $\\varepsilon_j \\sim \\mathcal{N}(0,\\sigma_{\\rm noise}^2)$ 以获得观测值\n$$\n\\sigma_j^{\\rm obs} = \\sigma(\\lambda_j) + \\varepsilon_j.\n$$\n\n参数辨识被构建为一个非线性最小二乘问题。给定观测数据 $(\\lambda_j, \\sigma_j^{\\rm obs})$，我们寻找参数 $\\theta = (\\mu_1,\\alpha_1,\\dots,\\mu_N,\\alpha_N)$ 以最小化\n$$\n\\min_{\\theta \\in \\mathcal{B}} \\sum_{j=1}^M \\left[\\sigma(\\lambda_j; \\theta) - \\sigma_j^{\\rm obs}\\right]^2,\n$$\n其中 $\\mathcal{B}$ 表示参数的边界约束。我们考虑两种约束方案：\n- 宽边界：对所有 $i$，$\\mu_i \\in [0.01, 5.0]$ 和 $\\alpha_i \\in [0.5, 8.0]$。\n- 窄边界：对所有 $i$，$\\mu_i \\in [0.01, 2.0]$ 和 $\\alpha_i \\in [0.5, 6.0]$。\n\n为了评估在不同初始猜测下的鲁棒性，我们使用在指定边界内均匀采样的初始参数执行多次拟合（每个方案 $6$ 次）。\n\n统计论证通过最优点的残差映射的局部线性化获得。设 $\\mathbf{r}(\\theta^\\star)$表示在拟合参数 $\\theta^\\star$ 处的残差向量，设 $J$ 是 $\\mathbf{r}$ 关于 $\\theta$ 的雅可比矩阵（元素 $J_{j,k} = \\partial r_j / \\partial \\theta_k$）。在线性化最小二乘的标准假设下，残差方差的近似估计为\n$$\n\\hat{\\sigma}^2 = \\frac{\\|\\mathbf{r}(\\theta^\\star)\\|_2^2}{M - P},\n$$\n其中 $M$ 是数据点数量，$P$ 是参数数量。参数估计的近似协方差矩阵是\n$$\n\\Sigma \\approx \\hat{\\sigma}^2 \\left(J^\\top J\\right)^{-1},\n$$\n如果 $J^\\top J$ 是病态的，则将 $\\left(J^\\top J\\right)^{-1}$ 解释为伪逆。每个参数 $\\theta_i$ 的近似 $95\\%$ 置信区间宽度为\n$$\nw_i \\approx 2 \\cdot 1.96 \\cdot \\sqrt{\\Sigma_{ii}}.\n$$\n\n为了综合不同初始猜测的鲁棒性指标，对于每个方案，我们计算：\n- 最大相对绝对误差：\n$$\nE_{\\max} = \\max_i \\frac{\\left|\\overline{\\hat{\\theta}}_i - \\theta_i^{\\rm true}\\right|}{\\left|\\theta_i^{\\rm true}\\right|},\n$$\n其中 $\\overline{\\hat{\\theta}}_i$ 是多次拟合的平均估计值，$\\theta_i^{\\rm true}$ 是真实参数。\n- 最大相对标准差：\n$$\nV_{\\max} = \\max_i \\frac{\\operatorname{std}\\left(\\hat{\\theta}_i^{(k)}\\right)}{\\left|\\overline{\\hat{\\theta}}_i\\right|},\n$$\n其中标准差是针对由 $k$ 索引的多次拟合计算的。\n- 最大平均相对置信区间宽度：\n$$\nC_{\\max} = \\max_i \\frac{\\overline{w_i}}{\\left|\\overline{\\hat{\\theta}}_i\\right|},\n$$\n其中 $\\overline{w_i}$ 是多次拟合中 $w_i$ 的平均值。\n\n如果在给定方案下 $E_{\\max} \\le 0.25$，$V_{\\max} \\le 0.30$ 且 $C_{\\max} \\le 0.50$，则宣布拟合是鲁棒的。只有当两种方案都满足鲁棒性标准时，测试案例才被认为是整体鲁棒的。\n\n测试套件规范：\n- 案例 A：$N=2$，$(\\mu_1,\\alpha_1) = (0.8, 1.3)$，$(\\mu_2,\\alpha_2) = (0.2, 5.0)$，$M=25$ 个伸长在 $[1.0, 1.6]$ 内，$\\sigma_{\\rm noise} = 0.02$ MPa。\n- 案例 B：$N=2$，$(\\mu_1,\\alpha_1) = (0.5, 2.0)$，$(\\mu_2,\\alpha_2) = (0.5, 2.2)$，$M=25$ 个伸长在 $[1.0, 1.6]$ 内，$\\sigma_{\\rm noise} = 0.02$ MPa。\n- 案例 C：$N=2$，$(\\mu_1,\\alpha_1) = (0.6, 1.2)$，$(\\mu_2,\\alpha_2) = (0.4, 4.0)$，$M=25$ 个伸长在 $[1.0, 1.6]$ 内，$\\sigma_{\\rm noise} = 0.20$ MPa。\n- 案例 D：$N=3$，$(\\mu_1,\\alpha_1) = (0.3, 1.0)$，$(\\mu_2,\\alpha_2) = (0.4, 2.0)$，$(\\mu_3,\\alpha_3) = (0.3, 6.0)$，$M=25$ 个伸长在 $[1.0, 1.1]$ 内，$\\sigma_{\\rm noise} = 0.02$ MPa。\n\n算法设计：\n1. 实现如上推导的 Ogden 单轴应力函数 $\\sigma(\\lambda; \\theta)$。\n2. 对于每个测试案例，生成 $\\lambda_j$ 并计算带有附加高斯噪声的 $\\sigma_j^{\\rm obs}$ (MPa)。\n3. 对于每个方案（宽边界和窄边界），创建 $6$ 个边界内的随机初始猜测，并使用信赖域反射方法求解有界非线性最小二乘问题。\n4. 对于每次拟合，记录 $\\hat{\\theta}$、残差和雅可比矩阵。通过 $(J^\\top J)^{-1}$ 或伪逆计算 $\\hat{\\sigma}^2$、$\\Sigma$ 和 $w_i$。\n5. 综合多次拟合的结果，为每个方案计算 $E_{\\max}$、$V_{\\max}$ 和 $C_{\\max}$。应用鲁棒性判定规则。\n6. 为案例 A-D 生成最终输出行，形式为 $[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]$ 风格的布尔值。\n\n统计论证：\n- 当指数充分分开且拉伸范围足够宽时（案例 A），$J$ 中编码的灵敏度是良态的，导致小的 $\\Sigma$ 和窄的置信区间；估计值在不同初始猜测下表现出低方差和相对于真实值的小偏差，满足阈值要求。\n- 接近不可辨识时（案例 B），相近的指数会引起 $J$ 列之间的共線性，使 $J^\\top J$ 成为病态矩阵；伪逆运算产生大的方差和宽的置信区间，且拟合结果依赖于初始猜测，违反了鲁棒性阈值。\n- 高噪声（案例 C）会增大 $\\hat{\\sigma}^2$，从而放大 $\\Sigma$ 并加宽置信区间；即使有足够的激励，由于置信区间宽度和多次运行间的可变性，鲁棒性也可能失败。\n- 窄拉伸范围（案例 D）提供有限的激励，降低了对某些指数和模量的灵敏度；随着 $J$ 在与高阶响应相关的方向上失去秩，可辨识性下降，导致大的置信区间和可变性。\n\n这种方法尊重底层的力学原理，并使用标准的统计线性化方法来从数值和逻辑上论证鲁棒性结论。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import least_squares\n\n# Set a fixed random seed for reproducibility\nnp.random.seed(42)\n\ndef ogden_uniaxial_sigma(lambdas, params):\n    \"\"\"\n    Compute the uniaxial Cauchy stress for the incompressible Ogden model.\n    params: [mu1, alpha1, mu2, alpha2, ..., muN, alphaN]\n    lambdas: array of stretches\n    Returns stress in MPa.\n    \"\"\"\n    lambdas = np.asarray(lambdas)\n    N = len(params) // 2\n    mu = np.array(params[0::2])\n    alpha = np.array(params[1::2])\n    # sigma = sum_i mu_i (lambda^{alpha_i} - lambda^{-alpha_i/2})\n    # Vectorized computation\n    # Shape broadcasting: (n_lambdas, N)\n    lam_pow = lambdas[:, None] ** alpha[None, :]\n    lam_neg = lambdas[:, None] ** (-alpha[None, :] / 2.0)\n    sigma = (mu[None, :] * (lam_pow - lam_neg)).sum(axis=1)\n    return sigma\n\ndef generate_synthetic(lambdas, true_params, noise_std):\n    \"\"\"\n    Generate synthetic stress data with Gaussian noise.\n    \"\"\"\n    sigma_true = ogden_uniaxial_sigma(lambdas, true_params)\n    noise = np.random.normal(0.0, noise_std, size=lambdas.shape[0])\n    return sigma_true + noise\n\ndef fit_params(lambdas, sigma_obs, N, bounds, init_guess):\n    \"\"\"\n    Fit Ogden parameters using bounded nonlinear least squares.\n    Returns result object, parameter estimate, residuals, jacobian.\n    \"\"\"\n    def residuals(p):\n        return ogden_uniaxial_sigma(lambdas, p) - sigma_obs\n\n    res = least_squares(\n        residuals,\n        x0=init_guess,\n        bounds=bounds,\n        method='trf',\n        jac='2-point',\n        max_nfev=10000,\n        xtol=1e-12,\n        ftol=1e-12,\n        gtol=1e-12,\n        verbose=0\n    )\n    # SciPy returns res.jac (M x P) approximate Jacobian at solution\n    r = res.fun\n    J = res.jac\n    return res, res.x, r, J\n\ndef covariance_from_jacobian(residuals, jacobian):\n    \"\"\"\n    Compute approximate covariance matrix using linearized least squares.\n    Use pseudo-inverse for (J^T J) to handle ill-conditioning.\n    \"\"\"\n    M, P = jacobian.shape\n    dof = max(M - P, 1)  # guard against non-positive dof\n    rss = float(np.dot(residuals, residuals))\n    sigma2 = rss / dof\n    JTJ = jacobian.T @ jacobian\n    # Pseudo-inverse for stability\n    JTJ_pinv = np.linalg.pinv(JTJ, rcond=1e-12)\n    cov = sigma2 * JTJ_pinv\n    return cov, sigma2\n\ndef assess_regime(lambdas, sigma_obs, true_params, N, bounds, n_runs=6):\n    \"\"\"\n    Assess robustness metrics for a constraint regime.\n    Returns: robust_flag, E_max, V_max, C_max\n    \"\"\"\n    P = 2 * N\n    # Sample initial guesses uniformly within bounds\n    lower = np.array(bounds[0])\n    upper = np.array(bounds[1])\n    inits = []\n    for _ in range(n_runs):\n        u = np.random.rand(P)\n        init = lower + u * (upper - lower)\n        inits.append(init)\n\n    estimates = []\n    ci_widths_runs = []\n    for init in inits:\n        res, est, r, J = fit_params(lambdas, sigma_obs, N, bounds, init)\n        estimates.append(est)\n        # Covariance and CI widths\n        cov, sigma2 = covariance_from_jacobian(r, J)\n        se = np.sqrt(np.clip(np.diag(cov), 0.0, np.inf))\n        ci_widths = 2.0 * 1.96 * se  # 95% CI width\n        ci_widths_runs.append(ci_widths)\n\n    estimates = np.array(estimates)  # shape (n_runs, P)\n    mean_est = estimates.mean(axis=0)\n    std_est = estimates.std(axis=0, ddof=1)\n\n    # Compute metrics\n    true = np.array(true_params)\n    # Avoid division by zero: parameters are positive by construction\n    rel_abs_err = np.abs(mean_est - true) / np.abs(true)\n    E_max = float(np.max(rel_abs_err))\n\n    # Relative std deviation using mean estimate magnitude\n    denom = np.maximum(np.abs(mean_est), 1e-12)\n    rel_std = std_est / denom\n    V_max = float(np.max(rel_std))\n\n    # Average CI widths across runs\n    ci_widths_runs = np.array(ci_widths_runs)  # (n_runs, P)\n    avg_ci_widths = ci_widths_runs.mean(axis=0)\n    rel_ci_widths = avg_ci_widths / denom\n    C_max = float(np.max(rel_ci_widths))\n\n    robust_flag = (E_max = 0.25) and (V_max = 0.30) and (C_max = 0.50)\n    return robust_flag, E_max, V_max, C_max\n\ndef run_case(lambdas, true_params, noise_std, N):\n    \"\"\"\n    Run both wide and tight constraint regimes and compute overall robustness.\n    \"\"\"\n    sigma_obs = generate_synthetic(lambdas, true_params, noise_std)\n\n    # Define bounds\n    # Wide bounds: mu in [0.01, 5.0], alpha in [0.5, 8.0]\n    wide_lower = []\n    wide_upper = []\n    for _ in range(N):\n        wide_lower += [0.01, 0.5]\n        wide_upper += [5.0, 8.0]\n    wide_bounds = (np.array(wide_lower), np.array(wide_upper))\n\n    # Tight bounds: mu in [0.01, 2.0], alpha in [0.5, 6.0]\n    tight_lower = []\n    tight_upper = []\n    for _ in range(N):\n        tight_lower += [0.01, 0.5]\n        tight_upper += [2.0, 6.0]\n    tight_bounds = (np.array(tight_lower), np.array(tight_upper))\n\n    robust_wide, Ew, Vw, Cw = assess_regime(lambdas, sigma_obs, true_params, N, wide_bounds, n_runs=6)\n    robust_tight, Et, Vt, Ct = assess_regime(lambdas, sigma_obs, true_params, N, tight_bounds, n_runs=6)\n\n    overall_robust = robust_wide and robust_tight\n    # We return only the boolean per requirements, but could be extended to include metrics.\n    return overall_robust\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A\n    lambdas_A = np.linspace(1.0, 1.6, 25)\n    true_params_A = [0.8, 1.3, 0.2, 5.0]  # N=2\n    noise_std_A = 0.02\n    N_A = 2\n\n    # Case B\n    lambdas_B = np.linspace(1.0, 1.6, 25)\n    true_params_B = [0.5, 2.0, 0.5, 2.2]  # N=2\n    noise_std_B = 0.02\n    N_B = 2\n\n    # Case C\n    lambdas_C = np.linspace(1.0, 1.6, 25)\n    true_params_C = [0.6, 1.2, 0.4, 4.0]  # N=2\n    noise_std_C = 0.20\n    N_C = 2\n\n    # Case D\n    lambdas_D = np.linspace(1.0, 1.1, 25)\n    true_params_D = [0.3, 1.0, 0.4, 2.0, 0.3, 6.0]  # N=3\n    noise_std_D = 0.02\n    N_D = 3\n\n    test_cases = [\n        (lambdas_A, true_params_A, noise_std_A, N_A),\n        (lambdas_B, true_params_B, noise_std_B, N_B),\n        (lambdas_C, true_params_C, noise_std_C, N_C),\n        (lambdas_D, true_params_D, noise_std_D, N_D),\n    ]\n\n    results = []\n    for lambdas, true_params, noise_std, N in test_cases:\n        robust = run_case(lambdas, true_params, noise_std, N)\n        results.append(robust)\n\n    # Final print statement in the exact required format.\n    # Output booleans as True/False in a single bracketed, comma-separated list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3586046"}]}