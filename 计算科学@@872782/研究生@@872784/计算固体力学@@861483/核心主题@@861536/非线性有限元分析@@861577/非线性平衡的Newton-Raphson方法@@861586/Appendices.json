{"hands_on_practices": [{"introduction": "在求解非线性问题时，首要任务是将连续体的平衡方程转化为一组离散的代数方程。本练习将指导您完成这一关键步骤，即从虚功原理出发，为一个具有非线性材料本构的一维杆推导并计算节点残差向量。理解残差向量的物理意义——它量化了在给定变形状态下节点的力不平衡——是掌握牛顿-拉夫逊方法精髓的基础，因为该方法的核心目标就是将此残差向量驱动至零。[@problem_id:3583531]", "problem": "考虑一根准静态一维杆，其长度 $L = 2\\,\\mathrm{m}$，均匀横截面积 $A = 1\\,\\mathrm{m^2}$，并具有非线性材料本构关系 $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^{3}$，其中 $\\sigma$ 是 Cauchy 应力，$\\varepsilon$ 是小应变。该杆承受分布载荷 $q(x) = q_{0}\\,x$，其中 $q_{0} = 1.0 \\times 10^{5}\\,\\mathrm{N/m^2}$，并在 $x=0$ 和 $x=L$ 处具有无牵引力边界条件。\n\n使用有限元法 (FEM) 和牛顿-拉夫逊法 (NR) 求解非线性平衡问题，从平衡的强形式出发，并通过虚功原理 (PVW) 推导其弱形式。对于一个位于区间 $[x_{i}, x_{j}]$ 上、使用标准线性形函数的线性两节点单元，推导节点残差向量 $r^{e}(u)$ 的单元级表达式（用内力和外力贡献表示）。然后，在一个覆盖区间 $[0,2]$、节点分别位于 $x_{0}=0$、$x_{1}=1$ 和 $x_{2}=2$ 的包含2个等长线性单元的网格上，组集全局残差向量 $r(u)$。\n\n对于由节点值 $u_{0} = 0\\,\\mathrm{m}$、$u_{1} = 0.10\\,\\mathrm{m}$ 和 $u_{2} = 0.25\\,\\mathrm{m}$ 定义的离散位移场 $u_{h}(x)$，以及材料参数 $E = 10^{6}\\,\\mathrm{Pa}$ 和 $\\alpha = 10^{7}\\,\\mathrm{Pa}$，计算残差向量。在可能的情况下使用精确算术。以牛顿 (N) 为单位表示最终的节点残差向量。最终答案必须是一个包含三个节点残差的单行矩阵。不需要四舍五入；提供精确值。", "solution": "该问题陈述已经过验证，是有效的。其科学基础是连续介质力学和有限元法的原理，问题是适定的、客观的，并为得到唯一解提供了所有必要的数据。对于 $q_0$ 的单位为 N/m$^2$ 的分布载荷 $q(x)$ 的解释，可通过量纲分析解决：$q(x)=q_0 x$ 项表示单位长度上的力，单位为 $(N/m^2) \\cdot m = N/m$，这与一维杆问题是一致的。\n\n求解过程如下：首先建立强形式和弱形式的控制方程，然后推导有限元残差表达式，最后对指定的网格和位移场计算这些表达式的值。\n\n**1. 控制方程**\n\n一维杆的平衡方程的强形式为：\n$$\n\\frac{d(N)}{dx} + f(x) = 0 \\quad \\text{for } x \\in (0, L)\n$$\n其中 $N$ 是轴向力， $f(x)$ 是单位长度上的分布轴向载荷。轴向力为 $N = A\\sigma$，其中 $A$ 是横截面积，$\\sigma$ 是 Cauchy 应力。分布载荷由 $q(x) = q_0 x$ 给出，因此我们认定 $f(x) = q(x)$。在横截面积 $A$ 恒定的情况下，平衡方程变为：\n$$\nA\\frac{d\\sigma}{dx} + q_0 x = 0\n$$\n材料本构关系是非线性的：$\\sigma(\\varepsilon) = E\\varepsilon + \\alpha\\varepsilon^3$。应变-位移关系为 $\\varepsilon = \\frac{du}{dx}$。问题指定了无牵引力边界条件，这意味着轴向力 $N$ 在 $x=0$ 和 $x=L$ 处为零。\n\n为了推导弱形式，我们采用虚功原理 (PVW)。我们将平衡方程乘以一个虚位移 $\\delta u$，并在定义域 $[0,L]$ 上积分：\n$$\n\\int_{0}^{L} \\delta u \\left( A\\frac{d\\sigma}{dx} + q(x) \\right) dx = 0\n$$\n对第一项进行分部积分得到：\n$$\n\\left[ \\delta u (A\\sigma) \\right]_0^L - \\int_0^L (A\\sigma) \\frac{d(\\delta u)}{dx} dx + \\int_0^L \\delta u q(x) dx = 0\n$$\n边界项 $\\left[ \\delta u (A\\sigma) \\right]_0^L$ 代表了边界上外部点力所做的功。由于边界是无牵引力的，$A\\sigma(0)=0$ 且 $A\\sigma(L)=0$，所以该项消失。虚位移的导数是虚应变，$\\delta\\varepsilon = d(\\delta u)/dx$。因此弱形式为：\n$$\n\\int_0^L \\sigma(\\varepsilon) \\delta\\varepsilon A \\,dx - \\int_0^L q(x) \\delta u \\,dx = 0\n$$\n对于牛顿-拉夫逊法，我们定义残差，它表示在给定离散位移场 $u(x)$ 下内力和外力之间的不平衡。残差泛函 $R(u, \\delta u)$ 是：\n$$\nR(u, \\delta u) = \\int_0^L A\\sigma(\\varepsilon) \\delta\\varepsilon \\,dx - \\int_0^L q(x) \\delta u \\,dx\n$$\n当对于所有容许的虚位移 $\\delta u$ 都有 $R(u, \\delta u) = 0$ 时，达到平衡。\n\n**2. 有限元列式**\n\n我们将定义域离散为有限元。对于区间 $[x_i, x_j]$ 上的一个通用的两节点线性单元，位移 $u(x)$ 由节点位移 $u_i$ 和 $u_j$ 插值得到：\n$$\nu(x) = N_i(x)u_i + N_j(x)u_j = \\boldsymbol{N}(x) \\boldsymbol{u}^e\n$$\n其中 $\\boldsymbol{u}^e = \\begin{pmatrix} u_i  u_j \\end{pmatrix}^T$ 且 $\\boldsymbol{N} = \\begin{pmatrix} N_i(x)  N_j(x) \\end{pmatrix}$。线性形函数为：\n$$\nN_i(x) = \\frac{x_j-x}{L_e}, \\quad N_j(x) = \\frac{x-x_i}{L_e}\n$$\n单元长度为 $L_e = x_j - x_i$。单元内的应变 $\\varepsilon$ 是恒定的：\n$$\n\\varepsilon_e = \\frac{du}{dx} = \\frac{d\\boldsymbol{N}}{dx}\\boldsymbol{u}^e = \\begin{pmatrix} -\\frac{1}{L_e}  \\frac{1}{L_e} \\end{pmatrix} \\begin{pmatrix} u_i \\\\ u_j \\end{pmatrix} = \\frac{u_j - u_i}{L_e}\n$$\n应变-位移矩阵为 $\\boldsymbol{B} = \\frac{1}{L_e} \\begin{pmatrix} -1  1 \\end{pmatrix}$。虚位移和虚应变也类似地插值：$\\delta u = \\boldsymbol{N} \\boldsymbol{\\delta u}^e$ 和 $\\delta\\varepsilon = \\boldsymbol{B} \\boldsymbol{\\delta u}^e$。\n\n将这些代入残差泛函并对所有单元求和，得到：\n$$\n(\\boldsymbol{\\delta u})^T \\boldsymbol{r} = \\sum_e (\\boldsymbol{\\delta u}^e)^T \\left( \\int_{x_i}^{x_j} A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T dx - \\int_{x_i}^{x_j} q(x) \\boldsymbol{N}^T dx \\right)\n$$\n其中 $\\boldsymbol{r}$ 是全局节点残差向量。我们可以确定单元残差向量 $\\boldsymbol{r}^e$：\n$$\n\\boldsymbol{r}^e = \\boldsymbol{f}_{int}^e - \\boldsymbol{f}_{ext}^e\n$$\n其中 $\\boldsymbol{f}_{int}^e$ 是单元内力向量，$\\boldsymbol{f}_{ext}^e$ 是单元外力向量。\n\n**单元内力向量 $\\boldsymbol{f}_{int}^e$ 的推导：**\n$$\n\\boldsymbol{f}_{int}^e = \\int_{x_i}^{x_j} A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T dx = A \\sigma(\\varepsilon_e) \\boldsymbol{B}^T \\int_{x_i}^{x_j} dx = A L_e \\sigma(\\varepsilon_e) \\boldsymbol{B}^T\n$$\n$$\n\\boldsymbol{f}_{int}^e = A L_e \\left( E\\varepsilon_e + \\alpha\\varepsilon_e^3 \\right) \\frac{1}{L_e} \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = A \\left( E\\varepsilon_e + \\alpha\\varepsilon_e^3 \\right) \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix}\n$$\n\n**单元外力向量 $\\boldsymbol{f}_{ext}^e$ 的推导：**\n$$\n\\boldsymbol{f}_{ext}^e = \\int_{x_i}^{x_j} q(x) \\boldsymbol{N}^T dx = \\int_{x_i}^{x_j} q_0 x \\begin{pmatrix} (x_j-x)/L_e \\\\ (x-x_i)/L_e \\end{pmatrix} dx\n$$\n该积分的计算得出了线性载荷作用于线性单元上的标准结果：\n$$\n\\boldsymbol{f}_{ext}^e = \\frac{q_0 L_e}{6} \\begin{pmatrix} 2x_i + x_j \\\\ x_i + 2x_j \\end{pmatrix}\n$$\n\n**3. 数值计算**\n\n杆被离散为2个等长的单元。\n- 总长度 $L=2\\,\\mathrm{m}$，所以每个单元的长度为 $L_e=1\\,\\mathrm{m}$。\n- 节点位于 $x_0=0$，$x_1=1$ 和 $x_2=2$。\n- 材料参数：$A=1\\,\\mathrm{m^2}$，$E=10^6\\,\\mathrm{Pa}$，$\\alpha=10^7\\,\\mathrm{Pa}$。\n- 载荷参数：$q_0=10^5\\,\\mathrm{N/m^2}$。\n- 节点位移：$u_0=0\\,\\mathrm{m}$，$u_1=0.1\\,\\mathrm{m}$，$u_2=0.25\\,\\mathrm{m}$。\n\n**单元 1 (节点 0, 1):**\n$x_i=0$, $x_j=1$, $L_e=1$。节点位移 $u_0=0, u_1=0.1$。\n- 应变: $\\varepsilon^{(1)} = (u_1 - u_0)/L_e = (0.1 - 0)/1 = 0.1$。\n- 应力: $\\sigma^{(1)} = E\\varepsilon^{(1)} + \\alpha(\\varepsilon^{(1)})^3 = 10^6(0.1) + 10^7(0.1)^3 = 10^5 + 10^4 = 1.1 \\times 10^5\\,\\mathrm{Pa}$。\n- 内力向量: $\\boldsymbol{f}_{int}^{(1)} = A\\sigma^{(1)}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = 1 \\cdot (1.1 \\times 10^5) \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -110000 \\\\ 110000 \\end{pmatrix}\\,\\mathrm{N}$。\n- 外力向量: $\\boldsymbol{f}_{ext}^{(1)} = \\frac{10^5 \\cdot 1}{6}\\begin{pmatrix} 2(0)+1 \\\\ 0+2(1) \\end{pmatrix} = \\frac{10^5}{6}\\begin{pmatrix} 1 \\\\ 2 \\end{pmatrix} = \\begin{pmatrix} 50000/3 \\\\ 100000/3 \\end{pmatrix}\\,\\mathrm{N}$。\n- 残差向量: $\\boldsymbol{r}^{(1)} = \\boldsymbol{f}_{int}^{(1)} - \\boldsymbol{f}_{ext}^{(1)} = \\begin{pmatrix} -110000 - 50000/3 \\\\ 110000 - 100000/3 \\end{pmatrix} = \\begin{pmatrix} -380000/3 \\\\ 230000/3 \\end{pmatrix}\\,\\mathrm{N}$。\n\n**单元 2 (节点 1, 2):**\n$x_i=1$, $x_j=2$, $L_e=1$。节点位移 $u_1=0.1, u_2=0.25$。\n- 应变: $\\varepsilon^{(2)} = (u_2 - u_1)/L_e = (0.25 - 0.1)/1 = 0.15$。\n- 应力: $\\sigma^{(2)} = E\\varepsilon^{(2)} + \\alpha(\\varepsilon^{(2)})^3 = 10^6(0.15) + 10^7(0.15)^3 = 150000 + 10^7(0.003375) = 150000 + 33750 = 183750\\,\\mathrm{Pa}$。\n- 内力向量: $\\boldsymbol{f}_{int}^{(2)} = A\\sigma^{(2)}\\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = 1 \\cdot 183750 \\begin{pmatrix} -1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} -183750 \\\\ 183750 \\end{pmatrix}\\,\\mathrm{N}$。\n- 外力向量: $\\boldsymbol{f}_{ext}^{(2)} = \\frac{10^5 \\cdot 1}{6}\\begin{pmatrix} 2(1)+2 \\\\ 1+2(2) \\end{pmatrix} = \\frac{10^5}{6}\\begin{pmatrix} 4 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} 200000/3 \\\\ 250000/3 \\end{pmatrix}\\,\\mathrm{N}$。\n- 残差向量: $\\boldsymbol{r}^{(2)} = \\boldsymbol{f}_{int}^{(2)} - \\boldsymbol{f}_{ext}^{(2)} = \\begin{pmatrix} -183750 - 200000/3 \\\\ 183750 - 250000/3 \\end{pmatrix} = \\begin{pmatrix} (-551250-200000)/3 \\\\ (551250-250000)/3 \\end{pmatrix} = \\begin{pmatrix} -751250/3 \\\\ 301250/3 \\end{pmatrix}\\,\\mathrm{N}$。\n\n**全局残差向量 $\\boldsymbol{r}$ 的组集**\n全局残差向量 $\\boldsymbol{r} = \\begin{pmatrix} r_0  r_1  r_2 \\end{pmatrix}^T$ 由单元贡献组集而成：\n$$\nr_0 = r^{(1)}_0 = -\\frac{380000}{3}\n$$\n$$\nr_1 = r^{(1)}_1 + r^{(2)}_0 = \\frac{230000}{3} - \\frac{751250}{3} = \\frac{230000 - 751250}{3} = \\frac{-521250}{3} = -173750\n$$\n$$\nr_2 = r^{(2)}_1 = \\frac{301250}{3}\n$$\n最终的全局残差向量，其分量以牛顿表示，为：\n$$\n\\boldsymbol{r} = \\begin{pmatrix} -380000/3 \\\\ -173750 \\\\ 301250/3 \\end{pmatrix}\n$$", "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{380000}{3}  -173750  \\frac{301250}{3} \\end{pmatrix}}\n$$", "id": "3583531"}, {"introduction": "一旦我们建立了残差方程 $\\mathbf{r}(\\mathbf{u}) = \\mathbf{0}$，下一步就是应用迭代方法求解。这个编程练习将让您亲手实践非线性固体力学中的主力算法——牛顿-拉夫逊法。通过实现并比较“全量牛顿法”与“修正牛顿法”，您将对收敛速度和单次迭代计算成本之间的权衡获得直观且深刻的理解。[@problem_id:3583538]", "problem": "实现一个完整、可运行的程序，比较两种牛顿-拉夫逊（Newton-Raphson）策略，用于求解源于一维有限元离散化的非线性平衡问题。物理模型是一根一端固定、另一端承受单调递增轴向载荷的杆。该杆具有均匀的横截面积，并被离散化为单个线性二节点单元，因此在施加的末端位移下，轴向应变是均匀的。内部轴向应力遵循非线性本构关系。目标是建立平衡残差的公式，推导牛顿迭代所需的切线，然后实现并比较全牛顿法和修正牛顿法（在多次迭代中冻结切线刚度）。您必须计算迭代次数和观测到的收敛速率，并将它们呈现在一个单一的聚合输出行中。\n\n基础理论：\n- 有限元法 (FEM) 中的全局平衡：离散平衡条件为 $r(u) = 0$，其中 $r(u)$ 是残差力向量（此处为标量），$u$ 是离散节点位移，$r(u) = f_{\\text{ext}} - f_{\\text{int}}(u)$，$f_{\\text{ext}}$ 是外部节点力向量（此处为标量）。\n- 运动学：对于长度为 $L$、具有线性形函数且一端自由位移为 $u$ 的单个均匀杆单元，轴向应变为 $\\varepsilon = u / L$。\n- 非线性本构关系：轴向应力由 $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$ 给出，其中 $E  0$ 是杨氏模量，$\\beta \\ge 0$ 控制三次非线性；假设使用无量纲单位，因此本问题陈述中所有量均为无量纲。\n- 内力：对于横截面积为 $A$ 且应变恒定的均匀杆，自由节点处的内力简化为 $f_{\\text{int}}(u) = A \\sigma(\\varepsilon)$。\n\n对于给定的端部载荷 $P$ 和节点位移 $u$，将平衡残差定义为 $r(u) = P - f_{\\text{int}}(u) = P - A \\left( E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right)$。牛顿-拉夫逊 (NR) 法所需的一致切线为 $K_{\\text{T}}(u) = \\frac{dr}{du}$。在第 $k$ 次迭代时，全牛顿法使用当前的 $K_{\\text{T}}(u_k)$，而修正牛顿法则在每个载荷增量开始时冻结 $K_{\\text{T}}$，并在该增量内的所有迭代中重复使用它。\n\n编程任务：\n1. 从平衡残差定义 $r(u) = P - f_{\\text{int}}(u)$ 和本构关系 $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$ 出发，用 $u$、$E$、$\\beta$、$A$、$L$ 和 $P$ 明确推导 $r(u)$ 和 $K_{\\text{T}}(u)$ 的表达式。\n2. 在一系列载荷增量上实现两个非线性求解器：\n   - 全牛顿法：在载荷增量内的每次迭代中更新 $K_{\\text{T}}(u_k)$。\n   - 修正牛顿法：在每个载荷增量开始时冻结 $K_{\\text{T}}$（使用在增量第一次迭代时，即上一个增量收敛位移处，计算的切线）。\n   每个载荷增量将 $P$ 增加 $\\Delta P = P_{\\text{total}}/N_{\\text{inc}}$，并寻求一个收敛的 $u$，使得 $|r(u)| \\le \\text{tol}$。\n3. 使用上一个增量的收敛位移作为下一个增量的初始猜测值。对于每个增量，记录残差范数 $||r(u_k)||$ 的序列，直至收敛。\n4. 对于修正牛顿法，计算在所有发生至少两次迭代的迭代和增量上平均的观测线性收敛因子：$\\lambda_k = \\frac{||r_{k+1}||}{||r_k||}$，并报告所有此类 $\\lambda_k$ 的算术平均值。对于全牛顿法，类似地计算平均的观测二次收敛因子：$q_k = \\frac{||r_{k+1}||}{||r_k||^2}$，报告所有发生至少两次迭代的 $q_k$ 的算术平均值。\n5. 对于每个测试用例，计算全牛顿法和修正牛顿法在所有增量上累积的总迭代次数。收敛容差适用于残差范数 $||r||$，在此标量情况下为 $|r|$。\n\n测试套件：\n所有测试用例均使用无量纲参数 $A = 1$、$L = 1$、$E = 1$。每个增量的最大迭代次数设为 $\\text{max\\_iter} = 50$，残差容差设为 $\\text{tol} = 10^{-10}$。测试套件包含四个用例：\n- 用例 1：$\\beta = 0.1$，$P_{\\text{total}} = 0.5$，$N_{\\text{inc}} = 5$。\n- 用例 2：$\\beta = 1.0$，$P_{\\text{total}} = 0.8$，$N_{\\text{inc}} = 8$。\n- 用例 3：$\\beta = 5.0$，$P_{\\text{total}} = 0.8$，$N_{\\text{inc}} = 8$。\n- 用例 4（近线性边界）：$\\beta = 0.0$，$P_{\\text{total}} = 0.5$，$N_{\\text{inc}} = 5$。\n\n输出规范：\n- 对于每个测试用例，生成一个列表 $[N_{\\text{full}}, N_{\\text{mod}}, R_{\\text{full}}, R_{\\text{mod}}]$，其中 $N_{\\text{full}}$ 是全牛顿法的总迭代次数，$N_{\\text{mod}}$ 是修正牛顿法的总迭代次数，$R_{\\text{full}}$ 是全牛顿法的平均二次收敛因子，$R_{\\text{mod}}$ 是修正牛顿法的平均线性收敛因子。所有四个值都必须是数值；如果在所有增量中迭代次数少于两次（对于因子定义），则对应速率报告为 $0.0$。\n- 您的程序应生成单行输出，其中包含按顺序排列的每个测试用例的结果，形式为逗号分隔的子列表，并用方括号括起：用例 1、用例 2、用例 3、用例 4。例如，确切格式必须类似于 $[[N_{\\text{full}},N_{\\text{mod}},R_{\\text{full}},R_{\\text{mod}}],\\ldots]$。由于所有输出都是计数或比率，因此输出中不需要物理单位。\n\n科学真实性约束：\n- 问题是无量纲化的，因此所有参数都是无量纲的，确保了单位一致性。\n- 本构非线性 $\\beta \\ge 0$ 保证了正切线模量 $E_{\\text{t}} = E + 3 \\beta \\varepsilon^2$，从而避免了椭圆性损失，并确保了所选载荷下的稳健收敛。\n- 使用确定性算法，无随机化，固定容差 $\\text{tol} = 10^{-10}$，以及最大迭代上限 $\\text{max\\_iter} = 50$，以确保可复现性。\n\n您的实现必须是一个完整、可运行的程序。除了要求的单行输出外，不要读取任何输入或写入任何其他输出。实现语言必须是 Python，并遵循稍后指定的约束。结果必须由程序使用上述从第一性原理推导的算法进行数值计算。", "solution": "我们从有限元法 (FEM) 中的离散平衡出发：$r(u) = f_{\\text{ext}} - f_{\\text{int}}(u)$。对于长度为 $L$、横截面积为 $A$ 且应变均匀的一维杆，轴向应变为 $\\varepsilon = u/L$。本构关系为 $\\sigma(\\varepsilon) = E \\varepsilon + \\beta \\varepsilon^3$，其中 $E  0$ 且 $\\beta \\ge 0$。自由端的内部节点轴向力等于横截面积乘以轴向应力，即 $f_{\\text{int}}(u) = A \\sigma(\\varepsilon) = A \\left( E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right)$。外部节点力为 $f_{\\text{ext}} = P$。因此，标量残差为\n$$\nr(u) = P - A\\left(E \\frac{u}{L} + \\beta \\left(\\frac{u}{L}\\right)^3 \\right).\n$$\n牛顿-拉夫逊 (NR) 法所需的一致切线是 $r(u)$ 对 $u$ 的导数：\n$$\nK_{\\text{T}}(u) = \\frac{dr}{du} = -A\\left(\\frac{E}{L} + 3\\beta \\frac{u^2}{L^3}\\right).\n$$\n负号不成问题，因为 NR 更新求解的是 $K_{\\text{T}}(u_k) \\Delta u_k = -r(u_k)$ 并更新 $u_{k+1} = u_k + \\Delta u_k$。由于当 $E  0$、$\\beta \\ge 0$、$A0$ 和 $L0$ 时，$K_{\\text{T}}(u)$ 对所有 $u$ 都是严格为负的，因此迭代是适定的；在单调加载下，当 $r(u_k)  0$ 时，它会导致正的 $\\Delta u_k$。\n\n我们考虑两种算法：\n- 全牛顿法：在给定载荷增量的第 $k$ 次迭代中，根据当前迭代值组装 $K_{\\text{T}}(u_k)$。求解 $K_{\\text{T}}(u_k)\\Delta u_k = -r(u_k)$ 并更新 $u_{k+1} = u_{k} + \\Delta u_k$。重复此过程，直到 $|r(u_{k+1})| \\le \\text{tol}$ 或 $k$ 达到 $\\text{max\\_iter}$。\n- 修正牛顿法：在每个载荷增量开始时，通过在上一个增量的收敛位移 $u^{(i-1)}$（作为第 $i$ 个增量的初始猜测值 $u_0^{(i)}$）处计算 $K_{\\text{T}}$ 来冻结它。然后，在该增量中使用这个固定的 $K_{\\text{T}}$ 进行所有牛顿更新，直到收敛或达到 $\\text{max\\_iter}$。\n\n加载与初始化：\n我们采用一个具有 $N_{\\text{inc}}$ 个均匀步骤的载荷增量方案。总载荷为 $P_{\\text{total}}$，每个增量使载荷增加 $\\Delta P = P_{\\text{total}} / N_{\\text{inc}}$。在增量 $i$（$i = 1, \\ldots, N_{\\text{inc}}$）时，目标载荷为 $P_i = i \\Delta P$。增量 $i$ 中 $u$ 的初始猜测值是增量 $i-1$ 的收敛位移，第一个增量的初始位移为 $u^{(0)} = 0$。对于每个增量和每种方法，我们记录每次 NR 迭代 $k$ 时的残差范数 $|r(u_k)|$。\n\n收敛速率度量：\n- 对于在增量内使用冻结切线的修正牛顿法，解附近的预期局部行为是线性的：$|r_{k+1}| \\approx \\lambda |r_k|$，其中在收敛区域内 $0  \\lambda  1$。我们通过 $\\lambda_k = \\frac{|r_{k+1}|}{|r_k|}$ 估计每一步的线性因子，并计算所有增量和所有存在至少两个残差的迭代指标 $k$（即，如果该增量记录了 $n$ 个残差，则 $k$ 的范围从 $0$ 到 $n-2$）的算术平均值。\n- 对于使用一致切线的全牛顿法，解附近的局部行为是二次的：对于小的 $|r_k|$，$|r_{k+1}| \\approx q |r_k|^2$。我们通过 $q_k = \\frac{|r_{k+1}|}{|r_k|^2}$ 估计每一步的二次因子，并计算所有增量和合格迭代指标的算术平均值。在迭代次数少于两次即收敛的增量中，无法估计该因子；这些增量将从平均值计算中排除。如果在某个测试用例的所有增量中没有合格的步骤，我们为相应的平均速率返回 $0.0$。\n\n测试用例与预期：\n我们使用无量纲参数 $A = 1$、$L = 1$、$E = 1$，这意味着对于此选择，$f_{\\text{int}}(u) = E u + \\beta u^3$ 和 $K_{\\text{T}}(u) = -\\left(E + 3\\beta u^2\\right)$。我们设置 $\\text{tol} = 10^{-10}$ 和 $\\text{max\\_iter} = 50$。模拟四个用例：\n- 用例 1：$\\beta = 0.1$，$P_{\\text{total}} = 0.5$，$N_{\\text{inc}} = 5$。预期为中等非线性；全牛顿法应表现出接近二次的收敛性，平均 $q$ 值较小，而修正牛顿法应表现出线性收敛，其因子 $\\lambda$ 有界且不为零。\n- 用例 2：$\\beta = 1.0$，$P_{\\text{total}} = 0.8$，$N_{\\text{inc}} = 8$。非线性增强；全牛顿法仍然高效；修正牛顿法可能需要更多迭代，$\\lambda$ 值更大。\n- 用例 3：$\\beta = 5.0$，$P_{\\text{total}} = 0.8$，$N_{\\text{inc}} = 8$。强非线性；切线随 $u$ 显著增长。全牛顿法仍应稳健收敛，并具有近二次行为；修正牛顿法的收敛速率可能较慢，迭代次数较高，因为冻结的切线在远离初始猜测值时代表性较差。\n- 用例 4：$\\beta = 0.0$，$P_{\\text{total}} = 0.5$，$N_{\\text{inc}} = 5$。纯线性；两种方法都简化为求解线性方程。从每个增量的任意初始猜测值（前一个收敛值）开始，牛顿法在每个增量中只需一次迭代即可收敛。平均速率无法有意义地计算，因为每个增量最多只有一次迭代；因此，在这种情况下，两种方法的速率输出都应为 $0.0$。\n\n输出格式：\n对于每个测试用例，返回列表 $[N_{\\text{full}}, N_{\\text{mod}}, R_{\\text{full}}, R_{\\text{mod}}]$，并将所有四个用例聚合到一个顶级列表中，打印为一行，例如 $[[N_{\\text{full}},N_{\\text{mod}},R_{\\text{full}},R_{\\text{mod}}], [\\cdots], [\\cdots], [\\cdots]]$。$N_{\\text{full}}$、$N_{\\text{mod}}$ 的值为整数，$R_{\\text{full}}$、$R_{\\text{mod}}$ 的值为浮点数。因为这些是计数和无量纲比率，输出中不需要物理单位。\n\n算法稳健性：\n我们设置了严格的残差容差 $\\text{tol} = 10^{-10}$ 以捕捉速率估计中的渐近行为。正切线模量 $E_{\\text{t}} = E + 3 \\beta \\varepsilon^2$ 确保了指定载荷下的唯一解。最大迭代上限 $\\text{max\\_iter} = 50$ 可防止病态情况。载荷步进策略维持 $P$ 的单调增加，初始猜测值的选择有助于快速收敛。\n\n程序将精确实现这些步骤，并以指定格式打印所需的单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef residual(u, P, E, beta, A, L):\n    # r(u) = P - A*(E*u/L + beta*(u/L)^3)\n    return P - A * (E * (u / L) + beta * (u / L) ** 3)\n\ndef tangent(u, E, beta, A, L):\n    # K_T(u) = dr/du = -A*(E/L + 3*beta*u^2/L^3)\n    return -A * (E / L + 3.0 * beta * (u ** 2) / (L ** 3))\n\ndef newton_solve(P_total, N_inc, E, beta, A, L, tol=1e-10, max_iter=50, mode=\"full\"):\n    \"\"\"\n    Solve the nonlinear equilibrium over load increments using either full Newton or modified Newton.\n    Returns:\n        total_iterations: int\n        avg_rate: float (quadratic factor for 'full', linear factor for 'modified')\n    \"\"\"\n    u = 0.0  # initial displacement for first increment\n    deltaP = P_total / N_inc\n    total_iterations = 0\n    rate_values = []  # stores lambda_k for 'modified' or q_k for 'full'\n\n    for i in range(1, N_inc + 1):\n        P_i = i * deltaP\n        # Initial guess is previous increment's converged displacement\n        u_i = u\n        residuals = []\n\n        # Freeze tangent for modified Newton at start of increment\n        if mode == \"modified\":\n            K_freeze = tangent(u_i, E, beta, A, L)\n\n        for k in range(max_iter):\n            r_k = residual(u_i, P_i, E, beta, A, L)\n            residuals.append(abs(r_k))\n            if abs(r_k) = tol:\n                # Converged at iteration k\n                total_iterations += k  # we count completed iterations before reaching tolerance\n                break\n            # Choose tangent according to method\n            if mode == \"full\":\n                K_t = tangent(u_i, E, beta, A, L)\n            else:\n                K_t = K_freeze\n\n            # Guard against zero tangent (should not occur with chosen parameters)\n            if K_t == 0.0:\n                # Fail-safe: break to avoid division by zero\n                total_iterations += k + 1\n                break\n\n            # Newton update: K_t * delta = -r_k  => delta = -r_k / K_t\n            delta = -r_k / K_t\n            u_i = u_i + delta\n\n            # If we reached the last allowed iteration without satisfying tol, count it\n            if k == max_iter - 1:\n                total_iterations += max_iter\n\n        # Post-processing for rate estimates within this increment\n        # We use the recorded residuals sequence residuals[0..n-1] to compute step-wise rates\n        n_res = len(residuals)\n        if n_res >= 2:\n            for idx in range(n_res - 1):\n                r_k = residuals[idx]\n                r_k1 = residuals[idx + 1]\n                if mode == \"modified\":\n                    # Linear factor lambda = r_{k+1} / r_k\n                    if r_k > 0.0:\n                        rate_values.append(r_k1 / r_k)\n                else:\n                    # Quadratic factor q = r_{k+1} / r_k^2\n                    if r_k > 0.0:\n                        rate_values.append(r_k1 / (r_k ** 2))\n\n        # Update global u for next increment initial guess\n        u = u_i\n\n    # Average the collected rates; if none, return 0.0\n    if len(rate_values) > 0:\n        avg_rate = float(np.mean(rate_values))\n    else:\n        avg_rate = 0.0\n\n    return total_iterations, avg_rate\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Using nondimensional parameters: A=1, L=1, E=1 for all cases.\n    test_cases = [\n        # (beta, P_total, N_inc, E, A, L)\n        (0.1, 0.5, 5, 1.0, 1.0, 1.0),  # Case 1\n        (1.0, 0.8, 8, 1.0, 1.0, 1.0),  # Case 2\n        (5.0, 0.8, 8, 1.0, 1.0, 1.0),  # Case 3\n        (0.0, 0.5, 5, 1.0, 1.0, 1.0),  # Case 4 (linear)\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, P_total, N_inc, E, A, L = case\n\n        # Full Newton\n        N_full, R_full = newton_solve(\n            P_total=P_total, N_inc=N_inc, E=E, beta=beta, A=A, L=L,\n            tol=1e-10, max_iter=50, mode=\"full\"\n        )\n        # Modified Newton (freeze tangent per increment)\n        N_mod, R_mod = newton_solve(\n            P_total=P_total, N_inc=N_inc, E=E, beta=beta, A=A, L=L,\n            tol=1e-10, max_iter=50, mode=\"modified\"\n        )\n\n        results.append([N_full, N_mod, R_full, R_mod])\n\n    # Final print statement in the exact required format.\n    # Single line: list of sublists per test case.\n    print(str(results))\n\nsolve()\n```", "id": "3583538"}, {"introduction": "标准的牛顿-拉夫逊法在处理结构失稳现象（如屈曲或突弹）时会遇到困难，因为在极限点或分岔点处，切线刚度矩阵是奇异的。这项高级练习将引导您实现弧长法，这是一种功能强大的路径跟踪技术，通过增广方程组来追踪复杂的平衡路径。通过实践，您将学会如何克服基本求解器的局限性，从而分析更具挑战性的非线性行为。[@problem_id:3583526]", "problem": "实现一种增广系统牛顿-拉夫逊法，用以求解一个由带弧长约束的增广系统定义的受约束非线性平衡问题。考虑一个双自由度未知向量 $\\mathbf{u} \\in \\mathbb{R}^2$ 和一个标量载荷参数 $\\lambda \\in \\mathbb{R}$。设势能为\n$$\n\\Pi(\\mathbf{u},\\lambda) = \\frac{1}{4}\\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)^2,\n$$\n平衡方程由 $\\Pi$ 的驻值条件给出，即\n$$\n\\mathbf{R}(\\mathbf{u},\\lambda) = \\nabla_{\\mathbf{u}} \\Pi(\\mathbf{u},\\lambda) = \\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)\\mathbf{u} = \\mathbf{0}.\n$$\n相关的切线刚度（关于 $\\mathbf{u}$ 的雅可比矩阵）和关于 $\\lambda$ 的导数分别为\n$$\n\\mathbf{K}(\\mathbf{u},\\lambda) = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}} = \\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)\\mathbf{I} + 2\\mathbf{u}\\mathbf{u}^\\mathsf{T}, \\qquad \\mathbf{q}(\\mathbf{u}) = \\frac{\\partial \\mathbf{R}}{\\partial \\lambda} = -\\mathbf{u}.\n$$\n为追踪解路径，使用一个弧长约束 $g(\\mathbf{u},\\lambda) = 0$ 来增广 $\\mathbf{R}(\\mathbf{u},\\lambda) = \\mathbf{0}$。该约束是基于相对于上一个收敛平衡点 $(\\mathbf{u}_k, \\lambda_k)$ 的增量 $\\Delta \\mathbf{u} = \\mathbf{u} - \\mathbf{u}_k$ 和 $\\Delta \\lambda = \\lambda - \\lambda_k$ 定义的。实现并比较以下两种 $g$ 的选择：\n- 位移范数弧长：\n$$\ng_{\\text{disp}}(\\mathbf{u},\\lambda) = \\Delta \\mathbf{u}^\\mathsf{T}\\Delta \\mathbf{u} + \\psi\\,\\Delta \\lambda^2 - \\Delta s^2.\n$$\n- 带正则化的能量范数弧长：\n$$\ng_{\\text{energy}}(\\mathbf{u},\\lambda) = \\Delta \\mathbf{u}^\\mathsf{T}\\left(\\mathbf{K}(\\mathbf{u}_k,\\lambda_k) + \\epsilon\\,\\mathbf{I}\\right)\\Delta \\mathbf{u} + \\psi\\,\\Delta \\lambda^2 - \\Delta s^2,\n$$\n其中 $\\psi  0$ 是一个平衡载荷和位移分量的缩放因子，$\\Delta s  0$ 是指定的弧长，$\\epsilon  0$ 是一个小的正则化项，用以避免在分岔点出现退化。\n\n在每个延拓步中，求解增广系统\n$$\n\\begin{bmatrix}\n\\mathbf{R}(\\mathbf{u},\\lambda) \\\\\ng(\\mathbf{u},\\lambda)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{0} \\\\\n0\n\\end{bmatrix}\n$$\n对该增广系统使用牛顿-拉夫逊法。围绕当前迭代点 $(\\mathbf{u}^{(i)},\\lambda^{(i)})$ 进行线性化，以 $(\\delta \\mathbf{u}, \\delta \\lambda)$ 进行更新，其中增广系统的雅可比矩阵为\n$$\n\\mathbf{J}_{\\text{ext}} =\n\\begin{bmatrix}\n\\mathbf{K}(\\mathbf{u}^{(i)},\\lambda^{(i)})  \\mathbf{q}(\\mathbf{u}^{(i)}) \\\\\n\\frac{\\partial g}{\\partial \\mathbf{u}}(\\mathbf{u}^{(i)},\\lambda^{(i)})^\\mathsf{T}  \\frac{\\partial g}{\\partial \\lambda}(\\mathbf{u}^{(i)},\\lambda^{(i)})\n\\end{bmatrix},\n$$\n其中\n$$\n\\frac{\\partial g_{\\text{disp}}}{\\partial \\mathbf{u}} = 2\\Delta \\mathbf{u}, \\quad \\frac{\\partial g_{\\text{disp}}}{\\partial \\lambda} = 2\\psi\\,\\Delta \\lambda,\n$$\n和\n$$\n\\frac{\\partial g_{\\text{energy}}}{\\partial \\mathbf{u}} = 2\\left(\\mathbf{K}(\\mathbf{u}_k,\\lambda_k)+\\epsilon\\,\\mathbf{I}\\right)\\Delta \\mathbf{u}, \\quad \\frac{\\partial g_{\\text{energy}}}{\\partial \\lambda} = 2\\psi\\,\\Delta \\lambda.\n$$\n使用一个基于线性化相容性条件的预测子\n$$\n\\mathbf{K}(\\mathbf{u}_k,\\lambda_k)\\,\\mathbf{d}_u + \\mathbf{q}(\\mathbf{u}_k)\\,d_\\lambda = \\mathbf{0},\n$$\n其参数化形式为\n$$\n\\mathbf{d}_u = \\alpha\\,\\mathbf{u}_k + \\beta\\,\\mathbf{t}_k, \\quad d_\\lambda = 2\\alpha\\,\\mathbf{u}_k^\\mathsf{T}\\mathbf{u}_k,\n$$\n其中 $\\mathbf{t}_k$ 是与 $\\mathbf{u}_k$ 正交的任意单位切向量。对于给定的 $\\beta$ 和符号约定 $d_\\lambda0$，选择 $\\alpha$ 以满足所选的弧长归一化条件 $g(\\mathbf{u}_k+\\mathbf{d}_u,\\lambda_k+d_\\lambda)=0$。然后使用带增广雅可比矩阵的牛顿-拉夫逊法进行迭代校正，直到残差范数和约束违反量低于容差。\n\n你的程序必须实现 $g_{\\text{disp}}$ 和 $g_{\\text{energy}}$ 两种约束，并执行多步延拓。使用以下测试套件，其设计旨在探查不同的行为，包括由对称性引起的分支效应、度量影响和近奇异条件：\n- 测试用例1（位移范数，破除对称性的预测子）：$(\\mathbf{u}_0,\\lambda_0) = ([0.5,\\,0.0],\\,0.25)$，弧长 $\\Delta s = 0.05$，缩放 $\\psi = 0.5$，正则化 $\\epsilon$ 忽略，切线偏移 $\\beta = 0.02$，步数 $N = 8$，收敛容差 $\\mathrm{tol} = 10^{-10}$，每步最大牛顿迭代次数 $50$。报告最终的方位角 $\\theta = \\mathrm{atan2}(u_2,u_1)$（以弧度为单位）。\n- 测试用例2（能量范数，相同的预测子和步长）：$(\\mathbf{u}_0,\\lambda_0) = ([0.5,\\,0.0],\\,0.25)$，弧长 $\\Delta s = 0.05$，缩放 $\\psi = 0.5$，正则化 $\\epsilon = 10^{-4}$，切线偏移 $\\beta = 0.02$，步数 $N = 8$，容差 $\\mathrm{tol} = 10^{-10}$，每步最大牛顿迭代次数 $50$。报告最终的 $\\theta$（以弧度为单位）。\n- 测试用例3（能量范数，近分岔点鲁棒性）：$(\\mathbf{u}_0,\\lambda_0) = ([0.2,\\,0.0],\\,0.04)$，弧长 $\\Delta s = 0.02$，缩放 $\\psi = 0.5$，正则化 $\\epsilon = 10^{-4}$，切线偏移 $\\beta = 0$，步数 $N = 5$，容差 $\\mathrm{tol} = 10^{-12}$，每步最大牛顿迭代次数 $80$。如果所有步都收敛到指定容差，则报告 $1$，否则报告 $0$。\n\n角度单位说明：所有角度均以弧度表示。你的程序的最终输出必须是单行文本，包含一个用方括号括起来的逗号分隔列表，其中按顺序列出测试用例1、2和3的结果，即 $[\\theta_{\\text{disp}},\\theta_{\\text{energy}},\\mathrm{conv3}]$。每个 $\\theta$ 必须表示为浮点数，而 $\\mathrm{conv3}$ 必须是整数 $0$ 或 $1$。", "solution": "用户提供了一个计算固体力学领域中科学合理且适定的问题。任务是实现并应用弧长延拓法来追踪一个非线性双自由度系统的平衡路径。该问题是有效的，因为它是自洽的，基于非线性有限元分析的既定原则，并且没有任何事实或逻辑上的不一致。\n\n解决方案首先详细阐述了增广系统弧长法的理论框架，然后在一个Python程序中实现该框架，以解决所提供的具体测试用例。\n\n### 基于原理的求解方法设计\n\n问题的核心在于求解代表力学平衡的非线性代数方程组。这类系统通常由一个载荷因子 $\\lambda$ 参数化。\n\n**1. 非线性平衡与切线刚度**\n\n系统的平衡状态由势能 $\\Pi(\\mathbf{u}, \\lambda)$ 的驻值条件定义，这导出了残差方程 $\\mathbf{R}(\\mathbf{u}, \\lambda) = \\mathbf{0}$。对于给定的势能 $\\Pi(\\mathbf{u},\\lambda) = \\frac{1}{4}\\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)^2$，残差为：\n$$\n\\mathbf{R}(\\mathbf{u},\\lambda) = \\nabla_{\\mathbf{u}} \\Pi = \\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)\\mathbf{u} = \\mathbf{0}\n$$\n这些方程对于未知位移向量 $\\mathbf{u}$ 是非线性的。我们使用牛顿-拉夫逊法求解它们，这需要将 $\\mathbf{R}$ 在一个构型 $(\\mathbf{u}^{(i)}, \\lambda^{(i)})$ 周围进行线性化。此线性化涉及切线刚度矩阵 $\\mathbf{K}$（$\\mathbf{R}$ 关于 $\\mathbf{u}$ 的雅可比矩阵）和关于载荷参数的导数 $\\mathbf{q}$：\n$$\n\\mathbf{K}(\\mathbf{u},\\lambda) = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{u}} = \\left(\\mathbf{u}^\\mathsf{T}\\mathbf{u} - \\lambda\\right)\\mathbf{I} + 2\\mathbf{u}\\mathbf{u}^\\mathsf{T}\n$$\n$$\n\\mathbf{q}(\\mathbf{u}) = \\frac{\\partial \\mathbf{R}}{\\partial \\lambda} = -\\mathbf{u}\n$$\n\n**2. 路径追踪与弧长约束**\n\n标准的牛顿-拉夫逊法在极限点（如载荷-位移曲线上的转折点）或分岔点处会失效，因为在这些点上切线刚度矩阵 $\\mathbf{K}$ 变为奇异。为克服此问题，采用了弧长延拓法。该方法将载荷参数 $\\lambda$ 视为一个额外的未知量，并引入一个约束方程 $g(\\mathbf{u}, \\lambda) = 0$，用以控制在状态空间 $(\\mathbf{u}, \\lambda)$ 中沿解路径的推进。这将问题转化为求解一个包含 $n+1$ 个方程和 $n+1$ 个未知数（$\\mathbf{u}$ 和 $\\lambda$）的增广系统：\n$$\n\\begin{bmatrix}\n\\mathbf{R}(\\mathbf{u},\\lambda) \\\\\ng(\\mathbf{u},\\lambda)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{0} \\\\\n0\n\\end{bmatrix}\n$$\n弧长约束 $g(\\mathbf{u}, \\lambda) = 0$ 在先前收敛的平衡点 $(\\mathbf{u}_k, \\lambda_k)$ 周围定义了一个半径为 $\\Delta s$ 的曲面（例如，一个超球面），下一个解就在该曲面与平衡路径的交点上。问题指定了此约束的两种形式，均基于增量 $\\Delta \\mathbf{u} = \\mathbf{u} - \\mathbf{u}_k$ 和 $\\Delta \\lambda = \\lambda - \\lambda_k$：\n- **位移范数：** $g_{\\text{disp}}(\\mathbf{u},\\lambda) = \\Delta \\mathbf{u}^\\mathsf{T}\\Delta \\mathbf{u} + \\psi\\,\\Delta \\lambda^2 - \\Delta s^2 = 0$。这定义了一个圆柱形或椭球形约束曲面，其中 $\\psi$ 用于缩放载荷参数的贡献。\n- **能量范数：** $g_{\\text{energy}}(\\mathbf{u},\\lambda) = \\Delta \\mathbf{u}^\\mathsf{T}\\left(\\mathbf{K}_k + \\epsilon\\,\\mathbf{I}\\right)\\Delta \\mathbf{u} + \\psi\\,\\Delta \\lambda^2 - \\Delta s^2 = 0$，其中 $\\mathbf{K}_k = \\mathbf{K}(\\mathbf{u}_k, \\lambda_k)$。该度量是受增量力所做功的启发。正则化项 $\\epsilon\\mathbf{I}$ 确保矩阵 $\\mathbf{K}_k + \\epsilon\\mathbf{I}$ 是正定的，即使 $\\mathbf{K}_k$ 是奇异的，这提高了在临界点附近的鲁棒性。\n\n**3. 增广系统的牛顿-拉夫逊法**\n\n该增广系统通过迭代求解。给定一个迭代点 $(\\mathbf{u}^{(i)}, \\lambda^{(i)})$，通过求解以下线性化系统来找到修正量 $(\\delta \\mathbf{u}, \\delta \\lambda)$：\n$$\n\\mathbf{J}_{\\text{ext}}^{(i)}\n\\begin{Bmatrix}\n\\delta \\mathbf{u} \\\\\n\\delta \\lambda\n\\end{Bmatrix}\n=\n-\n\\begin{Bmatrix}\n\\mathbf{R}(\\mathbf{u}^{(i)},\\lambda^{(i)}) \\\\\ng(\\mathbf{u}^{(i)},\\lambda^{(i)})\n\\end{Bmatrix}\n$$\n增广雅可比矩阵 $\\mathbf{J}_{\\text{ext}}$ 为：\n$$\n\\mathbf{J}_{\\text{ext}} =\n\\begin{bmatrix}\n\\mathbf{K}(\\mathbf{u}^{(i)},\\lambda^{(i)})  \\mathbf{q}(\\mathbf{u}^{(i)}) \\\\\n\\frac{\\partial g}{\\partial \\mathbf{u}}(\\mathbf{u}^{(i)},\\lambda^{(i)})^\\mathsf{T}  \\frac{\\partial g}{\\partial \\lambda}(\\mathbf{u}^{(i)},\\lambda^{(i)})\n\\end{bmatrix}\n$$\n约束函数所需的导数为：\n- 对于 $g_{\\text{disp}}$：$\\frac{\\partial g_{\\text{disp}}}{\\partial \\mathbf{u}} = 2\\Delta \\mathbf{u}$ 和 $\\frac{\\partial g_{\\text{disp}}}{\\partial \\lambda} = 2\\psi\\Delta \\lambda$。\n- 对于 $g_{\\text{energy}}$：$\\frac{\\partial g_{\\text{energy}}}{\\partial \\mathbf{u}} = 2(\\mathbf{K}_k+\\epsilon\\mathbf{I})\\Delta \\mathbf{u}$ 和 $\\frac{\\partial g_{\\text{energy}}}{\\partial \\lambda} = 2\\psi\\Delta \\lambda$。\n\n**4. 预测-校正算法**\n\n延拓法的每一步都包括两个阶段：\n1.  **预测阶段：** 计算下一个平衡点的初始猜测值。该猜测值是沿着上一个收敛点 $(\\mathbf{u}_k, \\lambda_k)$ 处解路径的切线方向前进一个长度为 $\\Delta s$ 的步长。切线方向 $(\\mathbf{d}_u, d_\\lambda)$ 由问题陈述指定，这确保了它在奇异的起始点满足线性化平衡条件。计算缩放参数 $\\alpha$ 以满足此预测步的弧长约束，即 $g(\\mathbf{u}_k + \\mathbf{d}_u, \\lambda_k + d_\\lambda) = 0$。选择 $\\alpha$ 的符号以使 $d_\\lambda > 0$，从而确保载荷参数在初始时向前推进。第一个迭代点为 $(\\mathbf{u}^{(0)}, \\lambda^{(0)}) = (\\mathbf{u}_k + \\mathbf{d}_u, \\lambda_k + d_\\lambda)$。\n2.  **校正阶段：** 从预测点开始，迭代应用增广牛顿-拉夫逊格式，以收敛到约束曲面上的真实平衡点。迭代持续进行，直到增广残差向量的范数低于指定的容差 $\\mathrm{tol}$。\n\n整个过程包括从一个已知的平衡点 $(\\mathbf{u}_0, \\lambda_0)$ 开始，并顺序计算一系列点 $(\\mathbf{u}_1, \\lambda_1), (\\mathbf{u}_2, \\lambda_2), \\dots$，从而描绘出解路径。这种方法使得算法能够绕过极限点并追踪复杂的分岔后路径，而这正是测试用例旨在探查的内容。预测子中的参数 $\\beta$ 充当一种“缺陷”，将解从主路径推向一个次级的、对称性破缺的分支。", "answer": "```python\nimport numpy as np\n\ndef run_continuation(\n    u0, lambda0, constraint_type, ds, psi, beta, epsilon, N, tol, max_iter\n):\n    \"\"\"\n    Performs arc-length continuation to solve a nonlinear system.\n\n    Args:\n        u0 (np.ndarray): Initial displacement vector.\n        lambda0 (float): Initial load parameter.\n        constraint_type (str): 'disp' or 'energy'.\n        ds (float): Arc-length for each step.\n        psi (float): Load-displacement scaling factor.\n        beta (float): Predictor tangent bias.\n        epsilon (float): Regularization for energy norm.\n        N (int): Number of continuation steps.\n        tol (float): Convergence tolerance.\n        max_iter (int): Maximum Newton iterations per step.\n\n    Returns:\n        tuple: (final u vector, boolean for all steps converged).\n    \"\"\"\n    u_current = np.array(u0, dtype=float)\n    lambda_current = float(lambda0)\n    \n    all_steps_converged = True\n\n    for _ in range(N):\n        u_k = u_current\n        lambda_k = lambda_current\n\n        # --- Predictor Step ---\n        norm_u_k_sq = u_k @ u_k\n        if norm_u_k_sq  1e-16: # Avoid division by zero, though problem setup avoids this.\n            t_k = np.array([1.0, 0.0]) \n        else:\n            t_k = np.array([-u_k[1], u_k[0]]) / np.sqrt(norm_u_k_sq)\n        \n        # Calculate alpha for the predictor\n        d_lambda_over_alpha = 2 * norm_u_k_sq\n        \n        if constraint_type == 'disp':\n            # Denominator of alpha^2: du^T du + psi * dlambda^2\n            # du = alpha*u_k + beta*t_k\n            # (alpha*u_k + beta*t_k)^T(alpha*u_k + beta*t_k) = alpha^2*norm_u_k^2 + beta^2\n            # because u_k and t_k are orthogonal.\n            numerator = ds**2 - beta**2\n            denominator = norm_u_k_sq + psi * (d_lambda_over_alpha**2)\n            if numerator  0:\n                 all_steps_converged = False\n                 break\n            alpha = np.sqrt(numerator / denominator)\n        \n        elif constraint_type == 'energy':\n            # The matrix for the energy norm metric is M = K_k + eps*I\n            # At given starting points, u_k^T u_k - lambda_k = 0, so K_k = 2*u_k*u_k^T\n            K_k = 2 * np.outer(u_k, u_k)\n            M_mat = K_k + epsilon * np.eye(2)\n            \n            # Predictor du = alpha*u_k + beta*t_k\n            # du^T M du = (alpha*u_k + beta*t_k)^T M (alpha*u_k + beta*t_k)\n            # This expands to: alpha^2 * u_k^T M u_k + beta^2 * t_k^T M t_k \n            # (cross terms are zero as u_k and t_k are eigenvectors of M)\n            numerator = ds**2 - beta**2 * (t_k @ M_mat @ t_k)\n            denominator = (u_k @ M_mat @ u_k) + psi * (d_lambda_over_alpha**2)\n            if numerator  0:\n                 all_steps_converged = False\n                 break\n            alpha = np.sqrt(numerator / denominator)\n\n        d_lambda = alpha * d_lambda_over_alpha\n        d_u = alpha * u_k + beta * t_k\n\n        u_c = u_k + d_u\n        lambda_c = lambda_k + d_lambda\n\n        # --- Corrector Step (Newton-Raphson) ---\n        step_converged = False\n        for _ in range(max_iter):\n            # Calculate increments from start of step\n            delta_u = u_c - u_k\n            delta_lambda = lambda_c - lambda_k\n            \n            # Evaluate extended residual\n            R = (u_c @ u_c - lambda_c) * u_c\n            \n            if constraint_type == 'disp':\n                g = delta_u @ delta_u + psi * delta_lambda**2 - ds**2\n            else: # energy norm\n                # K_k is constant within the step\n                K_k = 2 * np.outer(u_k, u_k)\n                M_mat = K_k + epsilon * np.eye(2)\n                g = delta_u @ M_mat @ delta_u + psi * delta_lambda**2 - ds**2\n\n            extended_residual = np.array([R[0], R[1], g])\n            \n            if np.linalg.norm(extended_residual)  tol:\n                step_converged = True\n                break\n                \n            # Evaluate extended Jacobian\n            K_c = (u_c @ u_c - lambda_c) * np.eye(2) + 2 * np.outer(u_c, u_c)\n            q_c = -u_c\n            \n            if constraint_type == 'disp':\n                dg_du = 2 * delta_u\n                dg_dlambda = 2 * psi * delta_lambda\n            else: # energy norm\n                # K_k is constant within the step\n                K_k = 2 * np.outer(u_k, u_k)\n                M_mat = K_k + epsilon * np.eye(2)\n                dg_du = 2 * M_mat @ delta_u\n                dg_dlambda = 2 * psi * delta_lambda\n\n            J_ext = np.zeros((3, 3))\n            J_ext[0:2, 0:2] = K_c\n            J_ext[0:2, 2] = q_c\n            J_ext[2, 0:2] = dg_du\n            J_ext[2, 2] = dg_dlambda\n            \n            # Solve for update and apply\n            try:\n                update = np.linalg.solve(J_ext, -extended_residual)\n            except np.linalg.LinAlgError:\n                all_steps_converged = False\n                break\n                \n            u_c += update[0:2]\n            lambda_c += update[2]\n        \n        if not step_converged:\n            all_steps_converged = False\n            # For Test Case 3, we must check if *all* steps converge,\n            # so we only set the flag and break the inner loop. The outer\n            # loop should technically stop if a step fails, but the requirement\n            # is just to report if *all* N steps succeeded. So we can break.\n            break\n\n        u_current = u_c\n        lambda_current = lambda_c\n\n    return u_current, all_steps_converged\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases specified in the problem statement.\n    \"\"\"\n    test_cases = [\n        # Case 1: displacement-norm, symmetry-breaking\n        dict(u0=[0.5, 0.0], lambda0=0.25, constraint_type='disp', ds=0.05, \n             psi=0.5, beta=0.02, epsilon=0.0, N=8, tol=1e-10, max_iter=50),\n        # Case 2: energy-norm, symmetry-breaking\n        dict(u0=[0.5, 0.0], lambda0=0.25, constraint_type='energy', ds=0.05, \n             psi=0.5, beta=0.02, epsilon=1e-4, N=8, tol=1e-10, max_iter=50),\n        # Case 3: energy-norm, robustness test\n        dict(u0=[0.2, 0.0], lambda0=0.04, constraint_type='energy', ds=0.02, \n             psi=0.5, beta=0.0, epsilon=1e-4, N=5, tol=1e-12, max_iter=80),\n    ]\n\n    results = []\n\n    # Test Case 1\n    u_final_1, _ = run_continuation(**test_cases[0])\n    theta_1 = np.arctan2(u_final_1[1], u_final_1[0])\n    results.append(theta_1)\n\n    # Test Case 2\n    u_final_2, _ = run_continuation(**test_cases[1])\n    theta_2 = np.arctan2(u_final_2[1], u_final_2[0])\n    results.append(theta_2)\n\n    # Test Case 3\n    _, conv_3 = run_continuation(**test_cases[2])\n    results.append(int(conv_3))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3583526"}]}