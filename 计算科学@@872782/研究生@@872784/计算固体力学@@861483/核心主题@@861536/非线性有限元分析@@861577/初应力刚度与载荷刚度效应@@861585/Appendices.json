{"hands_on_practices": [{"introduction": "本章的实践练习旨在将理论付诸实践。我们首先从一个基本问题入手：几何刚度矩阵是如何从基本原理中推导出来的？这个练习将引导你为最简单的结构构件——杆单元——推导其几何刚度矩阵 ([@problem_id:3574666])。通过在共旋坐标系下从虚功原理出发，你将亲手揭示初始应力（如拉力或压力）如何改变结构的切线刚度，这是理解应力刚化和屈曲现象的第一步。", "problem": "一个直的、等截面的、双节点桁架单元，其未变形长度为 $L$，恒定的参考横截面积为 $A$，经历了大的刚体转动但轴向应变很小。该单元在协同旋转坐标系法中建模，因此在协同旋转局部坐标系中，唯一的非零运动学自由度是沿单元轴线的标量轴向节点位移 $u_{1}$ 和 $u_{2}$。设轴向合力为 $N$，它代表单元当前承受的内部轴向力，并假设沿单元长度是均匀的。在全拉格朗日描述下，使用虚功原理（PVW），Green–Lagrange 应变和第二 Piola–Kirchhoff 应力，以及对轴向位移场的线性形函数插值，推导在局部轴向子空间中的初始应力（几何）刚度贡献。具体来说，从第一性原理出发，在协同旋转坐标系中对当前构形下的内虚功进行线性化，以获得与局部轴向节点自由度 $u_{1}$ 和 $u_{2}$ 相关的 $2 \\times 2$ 几何刚度子矩阵。\n\n你的推导必须清楚地指明初始应力贡献在线性化过程中的来源，并且必须陈述最终表达式有效的假设条件。将你的最终结果表示为以 $N$ 和 $L$ 表示的闭式解析 $2 \\times 2$ 矩阵。无需进行数值舍入。最终表达式中不要包含物理单位。", "solution": "合适的起点是在全拉格朗日描述下，针对一维桁架的虚功原理（PVW），用 Green–Lagrange 应变和第二 Piola–Kirchhoff 应力来表述。对于一个参考横截面积为 $A$、参考坐标为 $X \\in [0,L]$ 的等截面桁架，其内虚功为\n$$\n\\delta W_{\\text{int}} \\;=\\; \\int_{0}^{L} A\\, S\\, \\delta E \\, \\mathrm{d}X,\n$$\n其中 $S$ 是第二 Piola–Kirchhoff 应力，$E$ 是 Green–Lagrange 应变。在协同旋转局部坐标系中，轴向位移场通过线性形函数插值得到：\n$$\nu(X) \\;=\\; N_{1}(X)\\,u_{1} \\;+\\; N_{2}(X)\\,u_{2}, \\quad N_{1}(X) \\;=\\; 1 - \\frac{X}{L}, \\quad N_{2}(X) \\;=\\; \\frac{X}{L}.\n$$\n定义常数轴向位移梯度\n$$\n\\alpha \\;=\\; \\frac{\\mathrm{d}u}{\\mathrm{d}X} \\;=\\; \\frac{u_{2} - u_{1}}{L}.\n$$\n对于一维轴向变形，变形梯度为 $F = 1 + \\alpha$，Green–Lagrange 应变为\n$$\nE \\;=\\; \\frac{1}{2}\\big(F^{2} - 1\\big) \\;=\\; \\alpha \\;+\\; \\frac{1}{2}\\,\\alpha^{2}.\n$$\n其变分为\n$$\n\\delta E \\;=\\; \\frac{\\partial E}{\\partial \\alpha}\\,\\delta \\alpha \\;=\\; (1+\\alpha)\\,\\delta \\alpha, \\quad \\delta \\alpha \\;=\\; \\frac{\\mathrm{d}}{\\mathrm{d}X}(\\delta u) \\;=\\; \\frac{-\\,\\delta u_{1} + \\delta u_{2}}{L}.\n$$\n代入内虚功表达式，并利用在线性插值下 $\\delta \\alpha$ 在 $[0,L]$ 上为常数这一事实，可得\n$$\n\\delta W_{\\text{int}} \\;=\\; \\int_{0}^{L} A\\,S\\,(1+\\alpha)\\,\\delta \\alpha \\,\\mathrm{d}X \\;=\\; A\\,S\\,(1+\\alpha)\\,L\\,\\delta \\alpha \\;=\\; A\\,S\\,(1+\\alpha)\\,\\big(-\\,\\delta u_{1} + \\delta u_{2}\\big).\n$$\n通过 $\\delta W_{\\text{int}} = \\delta u_{1}\\,f_{\\text{int},1} + \\delta u_{2}\\,f_{\\text{int},2}$ 确定内节点力向量 $f_{\\text{int}}$，可得\n$$\nf_{\\text{int}} \\;=\\; A\\,S\\,(1+\\alpha)\\,\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}.\n$$\n为了获得一致切线刚度，我们对 $f_{\\text{int}}$ 关于节点位移 $(u_{1},u_{2})$进行线性化。该线性化过程自然地分为一个材料部分（通过来自本构律的 $\\partial S/\\partial u_{i}$）和一个几何或初始应力部分（通过乘以形函数梯度的运动学因子 $(1+\\alpha)$）。初始应力刚度是通过冻结当前应力 $S$（即，在方向导数中忽略 $\\partial S/\\partial u_{i}$）并且只对运动学因子 $(1+\\alpha)$ 求导来获得的：\n$$\nK_{\\sigma} \\;=\\; \\frac{\\partial}{\\partial \\mathbf{u}}\\Big(A\\,S\\,(1+\\alpha)\\,\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\\Big)\\Big|_{S=\\text{const}} \\;=\\; A\\,S\\,\\frac{\\partial (1+\\alpha)}{\\partial \\mathbf{u}}\\,\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}.\n$$\n已知 $\\alpha = (u_{2}-u_{1})/L$，$(1+\\alpha)$ 的导数为\n$$\n\\frac{\\partial (1+\\alpha)}{\\partial u_{1}} \\;=\\; -\\,\\frac{1}{L}, \\quad \\frac{\\partial (1+\\alpha)}{\\partial u_{2}} \\;=\\; \\frac{1}{L}.\n$$\n因此，\n$$\nK_{\\sigma} \\;=\\; A\\,S\\,\\frac{1}{L}\\,\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n为了用轴向合力 $N$ 来表示这个表达式，我们注意到内节点力向量具有 $f_{\\text{int}} = \\begin{bmatrix} -N \\\\ N \\end{bmatrix}$ 的结构。与 $f_{\\text{int}} = A\\,S\\,(1+\\alpha)\\,\\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}$ 比较可知\n$$\nN \\;=\\; A\\,S\\,(1+\\alpha).\n$$\n在协同旋转设定中的小轴向应变假设下，有 $(1+\\alpha) \\approx 1$，因此 $N \\approx A\\,S$，几何刚度可以紧凑地写为\n$$\nK_{\\sigma} \\;=\\; \\frac{N}{L}\\,\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n这个 $2 \\times 2$ 子矩阵作用于局部轴向节点自由度 $(u_{1},u_{2})$。\n\n此表达式成立的条件如下：\n- 协同旋转坐标系消除了刚体转动，因此轴向运动学由沿单元轴线的标量位移 $u_{1}$ 和 $u_{2}$ 描述，同时允许任意大的转动但轴向应变很小，即 $|\\alpha| \\ll 1$，从而 $(1+\\alpha) \\approx 1$。\n- 轴力 $N$ 沿单元是均匀的，并被解释为当前的内部轴向合力；在小轴向应变下，$N \\approx A\\,S$。\n- 单元是直的、等截面的，具有恒定的参考面积 $A$，并使用线性形函数，因此轴向位移梯度是常数。\n- 在局部轴向子空间中没有随动荷载效应；与外部随动荷载相关的载荷刚度不包括在此处。推导出的矩阵是由内部预应力 $N$ 引起的初始应力（几何）刚度。\n- 结果是局部的轴向 $2 \\times 2$ 矩阵块；当在全局坐标系中组集包含横向自由度的完整单元切线刚度时，标准的旋转变换可以恢复所有平动分量上熟悉的几何刚度分布。", "answer": "$$\\boxed{\\frac{N}{L}\\begin{bmatrix}1  -1 \\\\ -1  1\\end{bmatrix}}$$", "id": "3574666"}, {"introduction": "在推导了单元级的初始应力刚度 ($K_G$) 和载荷刚度 ($K_L$) 之后，最后一个练习将视角提升到结构系统层面，旨在回答一个核心问题：这些刚度项在非线性分析中究竟扮演了什么角色？通过一个精简的数值实验，你将有机会主动“开启”或“关闭”切线刚度矩阵中的$K_G$和$K_L$项，并直接观察它们对牛顿法收敛性和结构稳定性的独特影响 ([@problem_id:3574659])。这个练习将具体展示$K_G$如何与屈曲等对称失稳相关联，而反对称的$K_L$又如何导致非保守系统的动态失稳（颤振），从而深刻理解在非线性计算中精确构建切线刚度的重要性。", "problem": "实现一个小型、自洽的数值实验，以在一个简化的无量纲结构模型中，分离和比较材料刚度、初始应力（几何）刚度和载荷刚度在非线性求解过程中的作用。请使用无量纲变量，这样就不需要进行物理单位换算。您的程序必须是一个完整、可运行的程序，它使用牛顿法装配并求解增量载荷步，并带有用户可控的开关，这些开关可以在求解器使用的切线矩阵中包含或排除初始应力刚度和载荷刚度（同时保持“真实”残差不变）。目标是根据经验分离切线矩阵三个部分对收敛性和稳定性的影响。\n\n从以下基于原理的对象开始，这些对象在问题中直接给出，但需要在您的解答中证明其合理性：\n\n- 该模型有一个降阶状态向量 $u \\in \\mathbb{R}^2$。\n- 在参考构型邻域内的内力线性化可分解为材料刚度、由轴向预应力参数 $N \\ge 0$ 缩放的初始应力（几何）刚度，以及由随动载荷参数 $P \\ge 0$ 缩放的载荷刚度的和。因此，对于每个载荷步，“真实”切线矩阵为\n$$\nK_{\\mathrm{true}}(N,P) \\;=\\; K_M \\;+\\; N\\,K_G \\;+\\; P\\,K_L.\n$$\n- 在给定步骤中，相应的残差为\n$$\nR(u;N,P) \\;=\\; K_{\\mathrm{true}}(N,P)\\,u \\;-\\; P\\,f_0,\n$$\n其中 $f_0 \\in \\mathbb{R}^2$ 是一个固定的无量纲载荷方向向量，代表随动载荷的固定部分。\n- 材料刚度 $K_M$ 是对称正定的；初始应力刚度 $K_G$ 是对称的，在受压时是负定的（因此增加 $N$ 可能导致失去正定性）；载荷刚度 $K_L$ 是反对称的（因此它会引起非保守效应）。使用以下具体的无量纲形式的矩阵和向量：\n$$\nK_M \\;=\\; \\begin{bmatrix} 4.0  0.5 \\\\ 0.5  1.5 \\end{bmatrix},\\quad\nK_G \\;=\\; -\\,\\begin{bmatrix} 1.6  0.2 \\\\ 0.2  0.9 \\end{bmatrix},\\quad\nK_L \\;=\\; \\begin{bmatrix} 0.0  1.0 \\\\ -1.0  0.0 \\end{bmatrix},\\quad\nf_0 \\;=\\; \\begin{bmatrix} 1.0 \\\\ 0.2 \\end{bmatrix}.\n$$\n- 在每个载荷步，牛顿法使用近似切线矩阵求解 $R(u;N,P)=0$\n$$\nA(N,P;\\,\\sigma_G,\\sigma_L) \\;=\\; K_M \\;+\\; \\sigma_G\\,N\\,K_G \\;+\\; \\sigma_L\\,P\\,K_L,\n$$\n其中开关 $\\sigma_G \\in \\{0,1\\}$ 决定是否在求解器切线矩阵中包含几何刚度，开关 $\\sigma_L \\in \\{0,1\\}$ 决定是否在求解器切线矩阵中包含载荷刚度。请注意，$R$ 总是使用 $K_{\\mathrm{true}}(N,P)$（从不切换），而求解器的切线矩阵 $A$ 可以通过开关而不同。在第 $k$ 次迭代时的牛顿更新为\n$$\nu^{k+1} \\;=\\; u^k \\;-\\; A(N,P;\\,\\sigma_G,\\sigma_L)^{-1}\\,R(u^k;N,P).\n$$\n\n数值步骤：\n\n- 在每种情况的第一个步骤中，初始化 $u=\\mathbf{0}$，然后在同一情况下，使用已收敛的解作为下一步的初始猜测值。\n- 每个步骤最多使用 $200$ 次牛顿迭代，收敛准则为\n$$\n\\frac{\\lVert R(u;N,P)\\rVert_2}{\\lVert P\\,f_0\\rVert_2 + 10^{-16}} \\;\\le\\; 10^{-8}.\n$$\n- 如果使用 $A$ 的线性求解失败（数值奇异或条件数超过 $10^{12}$），或者在最大迭代次数内未达到收敛准则，则宣布当前载荷步未收敛，并停止当前情况的后续步骤。\n\n您的任务：\n\n- 实现上述带有开关 $\\sigma_G$ 和 $\\sigma_L$ 的牛顿过程。\n- 对于每个指定的情况（下面的测试套件），计算收敛的载荷步数并返回该计数。\n\n测试套件：\n\n为以下四种情况提供结果，这四种情况旨在分别探讨 $K_M$、$K_G$ 和 $K_L$ 的作用：\n\n- 情况 1（不带载荷相关切线矩阵的基准拟牛顿法）：$\\sigma_G = 0$，$\\sigma_L = 0$，载荷序列为三个步骤\n  - 步骤 1：$(N,P)=(0.0,\\,0.05)$\n  - 步骤 2：$(N,P)=(0.3,\\,0.05)$\n  - 步骤 3：$(N,P)=(0.6,\\,0.05)$\n- 情况 2（仅在切线矩阵中包含几何刚度）：$\\sigma_G = 1$，$\\sigma_L = 0$，载荷序列为四个步骤\n  - 步骤 1：$(N,P)=(0.0,\\,0.20)$\n  - 步骤 2：$(N,P)=(0.8,\\,0.40)$\n  - 步骤 3：$(N,P)=(0.8,\\,0.80)$\n  - 步骤 4：$(N,P)=(0.8,\\,1.60)$\n- 情况 3（仅在切线矩阵中包含载荷刚度）：$\\sigma_G = 0$，$\\sigma_L = 1$，载荷序列为四个步骤\n  - 步骤 1：$(N,P)=(0.0,\\,0.0)$\n  - 步骤 2：$(N,P)=(0.6,\\,0.0)$\n  - 步骤 3：$(N,P)=(0.9,\\,0.0)$\n  - 步骤 4：$(N,P)=(1.2,\\,0.0)$\n- 情况 4（包含两种载荷相关切线矩阵的精确牛顿法）：$\\sigma_G = 1$，$\\sigma_L = 1$，载荷序列为四个步骤\n  - 步骤 1：$(N,P)=(0.0,\\,0.0)$\n  - 步骤 2：$(N,P)=(0.8,\\,0.2)$\n  - 步骤 3：$(N,P)=(1.0,\\,0.2)$\n  - 步骤 4：$(N,P)=(1.2,\\,0.2)$\n\n最终输出规范：\n\n- 您的程序应生成单行输出，其中包含一个包含四个整数的列表，第 $i$ 个整数是情况 $i$ 中收敛的步数，格式严格如下\n$$\n[\\text{r1},\\text{r2},\\text{r3},\\text{r4}],\n$$\n列表中没有空格，也没有其他附加文本。例如，一个有效的输出将是 $[3,2,4,4]$（实际数字取决于您的实现以及指定的矩阵和载荷序列）。", "solution": "用户要求实现一个数值实验，以研究在一个简化的结构力学模型中，材料刚度、初始应力刚度和载荷刚度的作用。验证和求解过程如下。\n\n### **问题验证**\n\n**第一步：提取已知条件**\n\n-   **状态向量**：$u \\in \\mathbb{R}^2$。\n-   **真实切线刚度**：$K_{\\mathrm{true}}(N,P) = K_M + N\\,K_G + P\\,K_L$，其中 $N \\ge 0$ 是预应力参数，$P \\ge 0$ 是随动载荷参数。\n-   **残差向量**：$R(u;N,P) = K_{\\mathrm{true}}(N,P)\\,u - P\\,f_0$。\n-   **分量矩阵和向量**：\n    $$\n    K_M = \\begin{bmatrix} 4.0  0.5 \\\\ 0.5  1.5 \\end{bmatrix} \\quad (\\text{对称正定})\n    $$\n    $$\n    K_G = -\\begin{bmatrix} 1.6  0.2 \\\\ 0.2  0.9 \\end{bmatrix} \\quad (\\text{对称负定})\n    $$\n    $$\n    K_L = \\begin{bmatrix} 0.0  1.0 \\\\ -1.0  0.0 \\end{bmatrix} \\quad (\\text{反对称})\n    $$\n    $$\n    f_0 = \\begin{bmatrix} 1.0 \\\\ 0.2 \\end{bmatrix}\n    $$\n-   **近似求解器切线矩阵**：$A(N,P;\\,\\sigma_G,\\sigma_L) = K_M + \\sigma_G\\,N\\,K_G + \\sigma_L\\,P\\,K_L$，其中开关 $\\sigma_G, \\sigma_L \\in \\{0,1\\}$。\n-   **牛顿更新**：$u^{k+1} = u^k - A^{-1}\\,R(u^k)$。\n-   **数值步骤**：\n    -   在一种情况的第一个步骤中，初始化 $u=\\mathbf{0}$；后续步骤使用前一步收敛的解。\n    -   每步最大迭代次数：$200$。\n    -   收敛准则：$\\frac{\\lVert R(u;N,P)\\rVert_2}{\\lVert P\\,f_0\\rVert_2 + 10^{-16}} \\le 10^{-8}$。\n    -   失效条件：使用 $A$ 的线性求解失败（奇异或条件数 > $10^{12}$）或在最大迭代次数内未收敛。\n-   **任务**：对于四种指定情况，计算成功收敛的载荷步数。\n\n**第二步：使用提取的已知条件进行验证**\n\n1.  **科学上成立**：该问题是一个非线性结构分析问题的合理抽象，在有限元方法中很常见。将切线刚度分解为材料（$K_M$）、几何（$K_G$）和载荷相关（$K_L$）部分是经典做法。给定矩阵的性质与其物理解释一致：$K_M$ 是对称正定的（特征值约为 $4.15, 1.35$），$K_G$ 是对称负定的（其正部特征值约为 $1.7, 0.8$，因此 $K_G$ 的特征值为负），$K_L$ 是反对称的（$K_L = -K_L^T$）。使用近似切线矩阵 $A$ 来求解由真实刚度 $K_{\\mathrm{true}}$ 控制的系统的拟牛顿法设置，是标准技术，也是数值实验的有效基础。\n2.  **适定的**：所有必要的数据、矩阵、参数和算法都已明确提供。目标——计算收敛的步数——是清晰的，并能产生唯一、确定性的结果。\n3.  **客观的**：问题以精确的数学语言陈述，没有主观性。\n4.  **不完整或矛盾的设置**：问题是自洽的，没有矛盾。对于固定的 $N$ 和 $P$，系统是线性的 $K_{\\mathrm{true}}u = Pf_0$。在此系统上使用牛顿法是一个有效的实验设计，用于探讨当求解器的雅可比矩阵（$A$）与系统的真实雅可比矩阵（$K_{\\mathrm{true}}$）不匹配时，拟牛顿法的收敛性。\n5.  **不切实际或不可行**：问题是无量纲的，所要求的计算是标准的线性代数运算，都是可行的。\n6.  **不适定或琐碎**：问题不是不适定的。尽管某些测试用例（例如情况3）可能看起来很简单，但它们的行为是问题物理性质的直接且有启发性的结果（$P=0$ 意味着没有外力，导致一个平凡解）。这探讨了一个有效的边界情况。整个实验并非琐碎，它阐明了计算力学中的重要概念。\n\n**第三步：结论与行动**\n\n问题被判定为**有效**。这是一个健全、自洽且适定的数值问题，其基础是计算固体力学的原理。将提供一个解答。\n\n### **基于原理的求解设计**\n\n任务的核心是实现一个拟牛顿迭代求解器。牛顿法的基本原理是通过在当前迭代点用其切线来近似函数，从而迭代地找到一个函数（这里是残差 $R(u)$）的根。\n\n1.  **控制方程和残差**：物理系统由方程 $K_{\\mathrm{true}}(N,P)\\,u = P\\,f_0$ 建模。求解器的目标是找到满足此方程的位移向量 $u$。残差 $R(u) = K_{\\mathrm{true}}(N,P)\\,u - P\\,f_0$ 量化了给定 $u$ 的误差。当 $R(u) = \\mathbf{0}$ 时，就找到了一个解。\n\n2.  **拟牛顿迭代**：标准的牛顿-拉夫逊方法在每一步都对残差进行线性化。更新量 $\\Delta u$ 通过求解 $J \\Delta u = -R(u^k)$ 得到，其中 $J = \\frac{\\partial R}{\\partial u}$ 是雅可比矩阵。对于我们的线性残差，精确的雅可比矩阵是 $J = K_{\\mathrm{true}}$。本问题通过用一个近似值 $A(N,P;\\,\\sigma_G,\\sigma_L)$ 替换精确的雅可比矩阵 $J$ 来引入一个拟牛顿方案。因此，迭代更新为：\n    $$\n    u^{k+1} = u^k + \\Delta u^k \\quad \\text{其中} \\quad A \\Delta u^k = -R(u^k)\n    $$\n    $A$ 的选择决定了求解器的行为：\n    -   当 $A=K_{\\mathrm{true}}$（情况4）时，我们得到精确的牛顿法，对于这个线性残差，它会在一次迭代中收敛。\n    -   当 $A \\neq K_{\\mathrm{true}}$（情况1、2、3）时，我们得到一个拟牛顿法。其收敛性取决于 $A$ 对 $K_{\\mathrm{true}}$ 的近似程度。一个糟糕的近似可能导致收敛缓慢或发散。\n\n3.  **刚度分量的物理解释**：\n    -   $K_M$：材料的固有刚度。它是切线矩阵的基准、对称正定部分。\n    -   $N K_G$：初始应力或几何刚度。一个压缩性预应力（$N>0$）通常会降低整体刚度。如果 $N$ 足够大，$K_M + N K_G$ 可能会变得奇异，对应于弹性屈曲。\n    -   $P K_L$：载荷刚度，由非保守的“随动”力引起。其反对称性可导致非对称的切线矩阵，可能引起颤振失稳。\n\n4.  **算法实现**：通过编写一个程序来构建解决方案，该程序遍历四个指定的测试用例。对于每个用例，它按顺序处理一系列载荷步。在每个步骤中，它执行拟牛顿循环，检查收敛或失败。\n    -   **状态初始化**：在每个用例开始时，位移 $u$ 被重置为 $\\mathbf{0}$，并在用例内从一个收敛的步骤传递到下一个步骤。这模拟了一个增量加载历史。\n    -   **矩阵组装**：对于每一步，根据当前的载荷参数 $(N, P)$ 和用例的开关 $(\\sigma_G, \\sigma_L)$ 来组装 $K_{\\mathrm{true}}$ 和 $A$。\n    -   **失效处理**：在迭代之前，检查求解器矩阵 $A$ 的条件数与阈值（$10^{12}$）的对比，以预先检测病态条件。在迭代期间，监视线性求解 $A \\Delta u = -R$ 是否出现数值失败。如果达到最大迭代次数（$200$）而残差仍不满足容差（$\\lVert R \\rVert_2 / (\\lVert P f_0 \\rVert_2 + \\epsilon) \\le 10^{-8}$），则该步骤被标记为未收敛。\n    -   **计数和报告**：每个用例的计数器跟踪成功步骤的数量。在第一个失败的步骤处，该用例的处理过程将停止。报告所有四种情况的最终计数。\n\n这种系统化的方法正确地模拟了指定的数值实验，允许直接比较在求解器的切线矩阵中包含或排除几何和载荷刚度项如何影响其稳定性和收敛性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a quasi-Newton solver to test the effects of stiffness matrix components.\n    \"\"\"\n    # Define the nondimensional matrices and load vector from the problem statement.\n    K_M = np.array([[4.0, 0.5],\n                    [0.5, 1.5]])\n\n    K_G = -np.array([[1.6, 0.2],\n                     [0.2, 0.9]])\n\n    K_L = np.array([[0.0, 1.0],\n                    [-1.0, 0.0]])\n\n    f_0 = np.array([1.0, 0.2])\n\n    # Define numerical procedure parameters.\n    MAX_ITER = 200\n    TOL = 1e-8\n    COND_LIMIT = 1e12\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sigma_G, sigma_L, list_of_load_steps)\n    test_cases = [\n        # Case 1: Baseline quasi-Newton without load-dependent tangents\n        (0, 0, [(0.0, 0.05), (0.3, 0.05), (0.6, 0.05)]),\n        # Case 2: Include geometric stiffness only\n        (1, 0, [(0.0, 0.20), (0.8, 0.40), (0.8, 0.80), (0.8, 1.60)]),\n        # Case 3: Include load stiffness only\n        (0, 1, [(0.0, 0.0), (0.6, 0.0), (0.9, 0.0), (1.2, 0.0)]),\n        # Case 4: Exact Newton with both load-dependent tangents\n        (1, 1, [(0.0, 0.0), (0.8, 0.2), (1.0, 0.2), (1.2, 0.2)])\n    ]\n\n    results = []\n    \n    # Iterate through each test case.\n    for case in test_cases:\n        sigma_G, sigma_L, load_steps = case\n        \n        # Initialize displacement vector and converged step counter for the case.\n        u = np.zeros(2)\n        converged_steps_count = 0\n        \n        # Iterate through the load steps for the current case.\n        for N, P in load_steps:\n            # The initial guess for this step is the converged solution from the previous step.\n            u_k = np.copy(u)\n            \n            # Assemble the \"true\" and \"approximate\" tangent matrices.\n            K_true = K_M + N * K_G + P * K_L\n            A = K_M + sigma_G * N * K_G + sigma_L * P * K_L\n            \n            step_converged = False\n\n            # Pre-check for ill-conditioning of the solver's tangent matrix.\n            try:\n                if np.linalg.cond(A) > COND_LIMIT:\n                    break # Step fails, so break from the load_steps loop for this case.\n            except np.linalg.LinAlgError:\n                break # Matrix is singular.\n\n            # Calculate the external force vector and the denominator for the convergence criterion.\n            F_ext = P * f_0\n            conv_denom = np.linalg.norm(F_ext) + 1e-16\n\n            # Perform Newton-Raphson iteration.\n            for _ in range(MAX_ITER):\n                # Calculate the residual vector.\n                R_k = K_true @ u_k - F_ext\n                \n                # Check for convergence.\n                if np.linalg.norm(R_k) / conv_denom = TOL:\n                    step_converged = True\n                    u = u_k  # Store the converged solution for the next step.\n                    break\n\n                # Solve for the displacement update: A * delta_u = -R_k.\n                try:\n                    delta_u = np.linalg.solve(A, -R_k)\n                except np.linalg.LinAlgError:\n                    # Linear solve failed, iteration cannot continue.\n                    step_converged = False\n                    break \n                \n                # Update the displacement vector.\n                u_k += delta_u\n            \n            # If the step converged, increment the counter.\n            if step_converged:\n                converged_steps_count += 1\n            else:\n                # If a step fails, stop processing this case.\n                break\n\n        results.append(converged_steps_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3574659"}]}