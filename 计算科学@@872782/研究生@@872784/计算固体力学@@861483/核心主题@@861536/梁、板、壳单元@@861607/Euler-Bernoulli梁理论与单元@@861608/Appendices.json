{"hands_on_practices": [{"introduction": "补丁测试（Patch Test）是验证有限元单元正确性的一个基本标准，它确保了单元能够通过收敛性测试。本练习将指导你实现一个针对欧拉-伯努利梁单元的补丁测试 [@problem_id:3563483]，以验证其能否在任意不规则的网格上精确地再现一个常曲率状态。通过此实践，你将深刻理解单元的插值函数能力与其收敛性之间的内在联系，这是保证有限元分析结果可靠性的必要条件。", "problem": "实现一维欧拉-伯努利梁的有限元分片检验，以验证对常曲率状态的精确再现。其目标是证明，对于由双节点赫米特（Hermite）欧拉-伯努利梁单元构成的任意网格，当通过节点自由度施加一个常曲率场时，离散的内部应变能与等效节点荷载所做的外力功在数值精度范围内相等，且此结果与网格划分无关。该检验必须仅利用欧拉-伯努利梁的运动学和线性弹性理论，并遵循严谨的推导过程，不得依赖任何简便公式。\n\n从以下基本原理出发：\n- 欧拉-伯努利假定下的运动学：横向位移场为 $w(x)$，横截面转角为 $\\theta(x) = \\dfrac{dw}{dx}$。曲率为 $\\kappa(x) = \\dfrac{d\\theta}{dx} = \\dfrac{d^2 w}{dx^2}$。\n- 弯曲本构关系：弯矩为 $M(x) = E I \\, \\kappa(x)$，其中 $E$ 是杨氏模量，$I$ 是截面二次矩。\n- 内部应变能：$U = \\dfrac{1}{2}\\int_{0}^{L} E I \\, \\kappa(x)^2 \\, dx$。\n- 虚功原理（无轴向效应，小变形）：其弱形式为 $\\int_{0}^{L} E I \\, \\kappa \\, \\delta \\kappa \\, dx = \\delta W_{\\text{ext}}$，其中 $W_{\\text{ext}}$ 是外荷载所做的功。\n\n使用标准的双节点赫米特（Hermite）欧拉-伯努利梁单元对长度为 $L$ 的梁进行离散化，每个节点具有 $w$（横向位移）和 $\\theta$（转角）两个节点自由度。对 $w$ 使用三次赫米特插值，以确保 $w$ 和 $\\theta = dw/dx$ 在节点处得到精确插值。通过弱形式和曲率定义推导单元贡献，并组集得到总体刚度矩阵（在您的实现设计中，您必须进行推导，不能假设任何简便表达式，但在您的解答中论证之后，您可以在代码中实现已有的成熟结果）。\n\n通过指定与以下公式一致的节点值来构建一个常曲率目标场：\n- $w(x) = \\dfrac{\\kappa_0}{2} x^2 + a x + b$，\n- $\\theta(x) = \\dfrac{dw}{dx} = \\kappa_0 x + a$，\n其中 $\\kappa_0$ 是一个常曲率，$a$ 和 $b$ 是任意常数，$\\theta$ 以弧度为单位。为便于数值验证，选择 $a = 0$ 和 $b = 0$ 以避免在演示中出现刚体位移，但您的公式的正确性不能依赖于此特殊选择。\n\n为任意组集好的网格和材料参数定义以下验证量：\n- 包含所有节点 $(w_i,\\theta_i)$ 的离散广义位移向量 $\\mathbf{u}$。\n- 组集好的总体刚度矩阵 $\\mathbf{K}$。\n- 离散内部应变能 $U_h = \\dfrac{1}{2} \\mathbf{u}^T \\mathbf{K} \\mathbf{u}$。\n- 等效节点荷载向量 $\\mathbf{f}_{\\text{eq}} = \\mathbf{K}\\mathbf{u}$，表示在线性系统中能再现相同内力状态的边界节点力和力矩。\n- 荷载线性加载下的外力功 $W_h = \\dfrac{1}{2} \\mathbf{u}^T \\mathbf{f}_{\\text{eq}}$。\n- 常曲率下的连续介质精确能量 $U_{\\text{exact}} = \\dfrac{1}{2} E I \\kappa_0^2 L$。\n\n您的程序必须：\n1. 为任意将 $[0,L]$ 划分为总长为 $L$ 的单元的网格组集 $\\mathbf{K}$。\n2. 使用 $\\kappa_0$ 从常曲率场构建节点向量 $\\mathbf{u}$，其中 $\\theta$ 以弧度为单位，$w$ 以米为单位。\n3. 计算 $U_h$、$W_h$ 和 $U_{\\text{exact}}$。\n4. 对于每个测试案例，返回一个布尔值，当且仅当 $|U_h - W_h|$ 和 $|U_h - U_{\\text{exact}}|$ 均小于或等于容差 $10^{-10} \\max(1, U_{\\text{exact}})$ 时，该值为真。\n\n实现并运行以下测试套件。对于每个案例，使用给定的参数和网格，并确保所有物理量均在国际单位制（SI units：米、帕斯卡等）下进行解释。转角必须以弧度为单位。不需要用户输入。\n\n测试案例：\n- 案例1 (均匀网格): $L = 1.0$, $E = 2.10 \\times 10^{11}$, $I = 1.0 \\times 10^{-6}$, $\\kappa_0 = 2.0 \\times 10^{-2}$, 网格单元长度 $[0.25, 0.25, 0.25, 0.25]$。\n- 案例2 (非均匀网格): $L = 2.0$, $E = 7.0 \\times 10^{10}$, $I = 5.0 \\times 10^{-5}$, $\\kappa_0 = 3.0 \\times 10^{-3}$, 网格单元长度 $[0.1, 0.4, 0.7, 0.5, 0.3]$。\n- 案例3 (零曲率边界情况): $L = 1.0$, $E = 1.0 \\times 10^{9}$, $I = 1.0 \\times 10^{-4}$, $\\kappa_0 = 0.0$, 网格单元长度 $[1/3, 1/3, 1/3]$。\n- 案例4 (高曲率，精细非均匀网格): $L = 0.5$, $E = 2.0 \\times 10^{11}$, $I = 1.0 \\times 10^{-8}$, $\\kappa_0 = 50.0$, 网格单元长度 $[0.05, 0.10, 0.20, 0.15]$。\n- 案例5 (单一单元): $L = 1.5$, $E = 1.0 \\times 10^{11}$, $I = 2.0 \\times 10^{-6}$, $\\kappa_0 = 0.1$, 网格单元长度 $[1.5]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的布尔值列表（例如，\"[True,False,True,True,False]\"）。该列表的顺序必须与上述测试案例的顺序相同。", "solution": "该问题要求实现并验证欧拉-伯努利梁的有限元分片检验。分片检验是有限元方法中的一个基本验证程序，它测试给定的有限元列式是否能在任意网格上精确再现恒定应变（在本例中为恒定曲率）的状态。通过分片检验是有限元列式收敛的必要条件。\n\n本解答从基本原理出发，始于梁控制方程的弱形式，该弱形式由虚功原理推导得出。对于无轴向效应且经历小变形的欧拉-伯努利梁，其弱形式为：\n$$\n\\int_{0}^{L} \\delta\\kappa \\, M \\, dx = \\delta W_{\\text{ext}}\n$$\n其中 $L$ 是梁的长度，$M$ 是弯矩，$\\kappa$ 是曲率，$\\delta W_{\\text{ext}}$ 是外力所做的虚功。符号 $\\delta$ 表示虚变分。使用线性弹性本构关系 $M(x) = E I \\, \\kappa(x)$，其中 $E$ 是杨氏模量，$I$ 是截面二次矩（均假设为常数），弱形式变为：\n$$\n\\int_{0}^{L} E I \\, \\delta\\kappa \\, \\kappa \\, dx = \\delta W_{\\text{ext}}\n$$\n该问题使用双节点欧拉-伯努利梁单元组成的网格进行离散化。每个单元连接两个节点，每个节点拥有两个自由度（DOFs）：一个横向位移 $w$ 和一个转角 $\\theta$。对于长度为 $l_e$、局部坐标为 $\\xi \\in [0, l_e]$ 的单元 $e$，其节点自由度集合在向量 $\\mathbf{u}_e = [w_1, \\theta_1, w_2, \\theta_2]^T$ 中。\n\n单元内的横向位移场 $w(\\xi)$ 是通过使用三次赫米特形函数 $\\mathbf{N}(\\xi)$ 从节点自由度插值得到的：\n$$\nw(\\xi) = \\mathbf{N}(\\xi) \\mathbf{u}_e = N_1(\\xi) w_1 + N_2(\\xi) \\theta_1 + N_3(\\xi) w_2 + N_4(\\xi) \\theta_2\n$$\n在归一化坐标系 $\\eta = \\xi/l_e \\in [0, 1]$ 中，形函数由以下公式给出：\n\\begin{align*}\nN_1(\\eta) = 1 - 3\\eta^2 + 2\\eta^3 \\\\\nN_2(\\eta) = l_e (\\eta - 2\\eta^2 + \\eta^3) \\\\\nN_3(\\eta) = 3\\eta^2 - 2\\eta^3 \\\\\nN_4(\\eta) = l_e (-\\eta^2 + \\eta^3)\n\\end{align*}\n这种列式确保了位移 $w$ 和转角 $\\theta = dw/dx$ 在节点处是连续的。\n\n根据欧拉-伯努利假定，曲率定义为 $\\kappa(x) = d^2w/dx^2$。将此应用于插值位移场，我们得到单元内任意点的曲率与节点自由度之间的关系：\n$$\n\\kappa(\\xi) = \\frac{d^2w}{d\\xi^2} = \\frac{d^2\\mathbf{N}(\\xi)}{d\\xi^2} \\mathbf{u}_e = \\mathbf{B}(\\xi) \\mathbf{u}_e\n$$\n行向量 $\\mathbf{B}(\\xi)$ 是梁单元的应变-位移矩阵。其分量是形函数关于空间坐标 $\\xi$ 的二阶导数。利用链式法则 $\\frac{d^2}{d\\xi^2} = \\frac{1}{l_e^2} \\frac{d^2}{d\\eta^2}$，以归一化坐标 $\\eta$ 表示的 $\\mathbf{B}$ 矩阵为：\n$$\n\\mathbf{B}(\\eta) = \\frac{1}{l_e^2} \\left[ (12\\eta - 6), \\ l_e(6\\eta - 4), \\ (6 - 12\\eta), \\ l_e(6\\eta - 2) \\right]\n$$\n单个单元的内部应变能 $U_e$ 由下式给出：\n$$\nU_e = \\frac{1}{2} \\int_{0}^{l_e} E I \\, \\kappa(\\xi)^2 \\, d\\xi = \\frac{1}{2} \\int_{0}^{l_e} E I \\, (\\mathbf{B}(\\xi)\\mathbf{u}_e)^T (\\mathbf{B}(\\xi)\\mathbf{u}_e) \\, d\\xi\n$$\n将常数节点自由度 $\\mathbf{u}_e$ 从积分中提出，得到能量的标准二次型：\n$$\nU_e = \\frac{1}{2} \\mathbf{u}_e^T \\left( E I \\int_{0}^{l_e} \\mathbf{B}(\\xi)^T \\mathbf{B}(\\xi) \\, d\\xi \\right) \\mathbf{u}_e = \\frac{1}{2} \\mathbf{u}_e^T \\mathbf{K}_e \\mathbf{u}_e\n$$\n此处，$\\mathbf{K}_e$ 是单元刚度矩阵。通过代入 $\\mathbf{B}(\\eta)$ 的表达式并将积分变量更改为 $\\eta$（其中 $d\\xi = l_e d\\eta$）来计算该积分，可以得到公认的欧拉-伯努利梁单元的单元刚度矩阵：\n$$\n\\mathbf{K}_e = E I \\int_{0}^{1} \\mathbf{B}(\\eta)^T \\mathbf{B}(\\eta) l_e \\, d\\eta = \\frac{E I}{l_e^3} \\begin{pmatrix} 12 & 6l_e & -12 & 6l_e \\\\ 6l_e & 4l_e^2 & -6l_e & 2l_e^2 \\\\ -12 & -6l_e & 12 & -6l_e \\\\ 6l_e & 2l_e^2 & -6l_e & 4l_e^2 \\end{pmatrix}\n$$\n整个梁的总体刚度矩阵 $\\mathbf{K}$ 是通过将每个单元的刚度矩阵 $\\mathbf{K}_e$ 的贡献累加到相应的总体自由度位置来组集的。\n\n分片检验按以下步骤进行：\n$1$. 定义一个网格，将总长为 $L$ 的梁划分为若干单元。建立节点坐标 $x_i$。\n$2$. 施加一个常曲率状态 $\\kappa_0$。这对应于精确的位移场 $w(x) = \\frac{\\kappa_0}{2} x^2 + ax + b$ 和转角场 $\\theta(x) = \\kappa_0 x + a$。为简化起见，我们选择 $a=0$ 和 $b=0$。每个位于位置 $x_i$ 的节点 $i$ 的节点自由度被设置为与此场匹配：$w_i = \\frac{\\kappa_0}{2} x_i^2$ 和 $\\theta_i = \\kappa_0 x_i$。这些值填充了总体节点位移向量 $\\mathbf{u}$。\n$3$. 为指定的网格和材料属性（$E, I$）组集总体刚度矩阵 $\\mathbf{K}$。\n$4$. 计算三个关键量：\n    a. 恒定曲率下的精确连续介质应变能：$U_{\\text{exact}} = \\frac{1}{2} \\int_{0}^{L} E I \\kappa_0^2 \\, dx = \\frac{1}{2} E I \\kappa_0^2 L$。\n    b. 来自有限元模型的离散内部应变能：$U_h = \\frac{1}{2} \\mathbf{u}^T \\mathbf{K} \\mathbf{u}$。\n    c. 通过等效节点荷载 $\\mathbf{f}_{\\text{eq}} = \\mathbf{K}\\mathbf{u}$ 定义的离散外力功：$W_h = \\frac{1}{2} \\mathbf{u}^T \\mathbf{f}_{\\text{eq}}$。\n\n该检验涉及两项比较。首先，根据定义，$W_h = \\frac{1}{2} \\mathbf{u}^T (\\mathbf{K}\\mathbf{u}) = U_h$。验证 $|U_h - W_h|$ 接近于零可作为一项数值自洽性检验。\n第二项，也是更关键的比较，是在离散能量 $U_h$ 和精确能量 $U_{\\text{exact}}$ 之间进行的。三次赫米特形函数可以精确表示最高为3次的多项式。目标位移场 $w(x) = \\frac{\\kappa_0}{2} x^2$ 是一个二次多项式。因此，由于 $\\mathbf{u}_e$ 中的节点值是从该二次场中采样的，每个单元内的有限元插值 $w_h(x) = \\mathbf{N}(x)\\mathbf{u}_e$ 将精确地再现该二次场。因此，由插值计算出的曲率 $\\kappa_h(x) = d^2w_h/dx^2$ 必须在网格内的任何地方都恒等于常数 $\\kappa_0$。\n这意味着离散能量的计算变为：\n$$\nU_h = \\sum_e U_e = \\sum_e \\frac{1}{2} \\int_{l_e} E I \\kappa_h(x)^2 \\, dx = \\sum_e \\frac{1}{2} \\int_{l_e} E I \\kappa_0^2 \\, dx = \\frac{1}{2} E I \\kappa_0^2 \\sum_e l_e = \\frac{1}{2} E I \\kappa_0^2 L = U_{\\text{exact}}\n$$\n因此，对于一个正确的实现，离散能量必须在数值精度范围内等于精确能量，而无论区域 $[0,L]$ 如何划分。如果 $|U_h - U_{\\text{exact}}|$ 低于指定的容差，则检验通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a finite element patch test for the Euler-Bernoulli beam\n    to verify exact reproduction of a constant curvature state.\n    \"\"\"\n    \n    # Test cases defined in the problem statement.\n    # Format: (L, E, I, kappa_0, mesh_element_lengths)\n    test_cases = [\n        (1.0, 2.10e11, 1.0e-6, 2.0e-2, [0.25, 0.25, 0.25, 0.25]),\n        (2.0, 7.0e10, 5.0e-5, 3.0e-3, [0.1, 0.4, 0.7, 0.5, 0.3]),\n        (1.0, 1.0e9, 1.0e-4, 0.0, [1/3, 1/3, 1/3]),\n        (0.5, 2.0e11, 1.0e-8, 50.0, [0.05, 0.10, 0.20, 0.15]),\n        (1.5, 1.0e11, 2.0e-6, 0.1, [1.5])\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L, E, I, kappa_0, mesh_lengths = case\n        \n        # 1. Generate node coordinates from element lengths\n        node_coords = np.zeros(len(mesh_lengths) + 1)\n        node_coords[1:] = np.cumsum(mesh_lengths)\n        \n        num_nodes = len(node_coords)\n        num_dofs = 2 * num_nodes\n\n        # 2. Construct global nodal displacement vector 'u'\n        # The target displacement field is w(x) = (kappa_0 / 2) * x^2\n        # The target rotation field is theta(x) = kappa_0 * x\n        u = np.zeros(num_dofs)\n        for i in range(num_nodes):\n            x_i = node_coords[i]\n            w_i = 0.5 * kappa_0 * x_i**2\n            theta_i = kappa_0 * x_i\n            u[2*i] = w_i\n            u[2*i + 1] = theta_i\n\n        # 3. Assemble the global stiffness matrix 'K'\n        K = np.zeros((num_dofs, num_dofs))\n        \n        for e, l_e in enumerate(mesh_lengths):\n            # Calculate element stiffness matrix Ke\n            c = E * I / l_e**3\n            Ke = c * np.array([\n                [12, 6*l_e,    -12, 6*l_e],\n                [6*l_e, 4*l_e**2, -6*l_e, 2*l_e**2],\n                [-12, -6*l_e,   12, -6*l_e],\n                [6*l_e, 2*l_e**2, -6*l_e, 4*l_e**2]\n            ])\n            \n            # Assemble Ke into K\n            dof_indices = np.array([2*e, 2*e + 1, 2*(e+1), 2*(e+1) + 1])\n            K[np.ix_(dof_indices, dof_indices)] += Ke\n            \n        # 4. Compute verification quantities\n        U_exact = 0.5 * E * I * kappa_0**2 * L\n        \n        Uh = 0.5 * u.T @ K @ u\n        \n        f_eq = K @ u\n        Wh = 0.5 * u.T @ f_eq\n\n        # 5. Perform the check against the specified tolerance\n        tolerance = 1e-10 * max(1.0, np.abs(U_exact))\n        \n        # Check 1: Numerical self-consistency (Uh vs Wh)\n        check1 = np.abs(Uh - Wh) = tolerance\n        \n        # Check 2: Patch test verification (Uh vs U_exact)\n        check2 = np.abs(Uh - U_exact) = tolerance\n        \n        # The patch test passes if both checks are true\n        results.append(check1 and check2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [str(r) for r in results]))}]\")\n\nsolve()\n```", "id": "3563483"}, {"introduction": "任何物理模型都是对现实世界的近似，因此理解其适用范围至关重要。欧拉-伯努利梁理论的核心假设是忽略了剪切变形，这使得它在分析短粗梁（即梁的长度与高度之比不大）时会产生显著误差。本练习 [@problem_id:3563594] 旨在通过一个精心设计的数值实验，将欧拉-伯努利单元的计算结果与考虑了剪切变形的季莫申科（Timoshenko）梁理论的精确解进行对比，从而清晰地揭示其模型局限性。", "problem": "要求您设计并实现一个独立的数值实验，该实验揭示当 Euler–Bernoulli 梁单元用于剪切变形占主导地位的问题时出现的伪刚度。您的程序必须计算 Euler–Bernoulli 模型预测的有限元挠度，并将其与从第一性原理推导的 Timoshenko 梁模型的参考挠度进行比较，然后量化并总结挠度场中的定性误差模式。\n\n物理场景为一根矩形截面的等截面悬臂梁，宽度为 $b$，高度为 $h$，由杨氏模量为 $E$、泊松比为 $\\nu$ 的均匀各向同性线弹性材料制成，在 $x=0$ 处固定，并在其自由端 $x=L$ 处承受垂直集中力 $P$。您必须使用标准的双节点三次 Hermite 插值对横向挠度 $w(x)$ 和截面转角 $\\theta(x)$ 进行 Euler–Bernoulli 有限元离散化建模，并施加固支边界条件 $w(0)=0$ 和 $\\theta(0)=0$（单位为弧度）。对于矩形截面，剪切修正系数必须取为 $k=5/6$。剪切模量为 $G=E/\\left(2(1+\\nu)\\right)$，截面面积为 $A=b h$，截面二次矩为 $I=b h^3 / 12$。所有物理输入必须采用以下单位：$E$ 的单位为帕斯卡 (Pa)，$P$ 的单位为牛顿 (N)，$b$、$h$ 和 $L$ 的单位为米 (m)，计算出的挠度单位必须为米 (m)；任何转角单位均为弧度。\n\n从 Euler–Bernoulli 和 Timoshenko 梁理论的控制关系以及带顶点载荷的悬臂梁的平衡出发，推导 Timoshenko 模型中的精确挠度 $w_{\\mathrm{T}}(x)$ 和相应的 Euler–Bernoulli 挠度 $w_{\\mathrm{EB}}(x)$ 的表达式。您的 Euler–Bernoulli 有限元模型必须使用基于三次 Hermite 插值的标准一致刚度矩阵，并在 $[0,L]$ 上为 $n_e$ 个等长单元进行组装，其中端部载荷 $P$ 施加在全局顶点横向挠度自由度上。您必须在一组点上对挠度场进行采样，该点集需排除固支端附近的平凡边界层，以避免相对误差中出现除零伪影：在归一化区间 $x \\in [0.1L,\\,L]$ 上进行评估。\n\n定义以下误差度量：\n- 顶点挠度低估比 $r = w_{\\mathrm{EB}}(L) / w_{\\mathrm{T}}(L)$，无量纲。\n- 在 $x \\in [0.1L,\\,L]$ 上的最大逐点相对挠度误差，由 $e_{\\max} = \\max_{x \\in [0.1L,L]} \\left( \\left( w_{\\mathrm{T}}(x) - w_{\\mathrm{EB}}(x) \\right) / w_{\\mathrm{T}}(x) \\right )$ 给出，无量纲。\n- 一个布尔标志 $m$，如果采样相对误差 $e(x)$ 在 $[0.1L,L]$ 上随 $x$ 单调递减，则为 true，否则为 false。\n\n您的程序必须应用以下测试套件，该套件通过改变长细比和网格来揭示伪刚度及其定性模式：\n1. 情况 A（理想情况，细长梁）：$E=210 \\times 10^9$, $\\nu=0.3$, $b=0.02$, $h=0.01$, $L=0.20$, $P=1000$, $n_e=1$。\n2. 情况 B（中等厚度）：$E=210 \\times 10^9$, $\\nu=0.3$, $b=0.02$, $h=0.01$, $L=0.05$, $P=1000$, $n_e=1$。\n3. 情况 C（厚梁，网格细化）：$E=210 \\times 10^9$, $\\nu=0.3$, $b=0.02$, $h=0.01$, $L=0.02$, $P=1000$, $n_e=4$。\n4. 情况 D（边缘情况，极短梁）：$E=210 \\times 10^9$, $\\nu=0.3$, $b=0.02$, $h=0.01$, $L=0.01$, $P=1000$, $n_e=8$。\n\n对于每种情况，使用指定的单位和采样间隔计算 $r$、$e_{\\max}$ 和 $m$。您的程序应生成单行输出，其中包含按测试用例顺序排列的逗号分隔的结果列表的列表，每个内部列表包含 $[r, e_{\\max}, m]$。例如，输出必须具有 $[[r_A,e_{\\max,A},m_A],[r_B,e_{\\max,B},m_B],[r_C,e_{\\max,C},m_C],[r_D,e_{\\max,D},m_D]]$ 的形式，所有实数均为十进制形式。\n\n推导必须从基本关系和定义开始，除了这些推导之外，您不得使用任何快捷公式。确保所有参数的科学真实性和自洽性。最终程序必须是完整且可运行的，没有任何外部输入，并且必须遵守指定的输出格式。", "solution": "用户要求进行一个数值实验，以展示 Euler-Bernoulli 梁模型在剪切主导场景下的伪刚度。这需要推导 Timoshenko 和 Euler-Bernoulli 梁理论的解析解，实现一个基于 Euler-Bernoulli 理论的有限元 (FE) 模型，并计算指定的误差度量，将有限元解与更精确的 Timoshenko 解进行比较。\n\n### 第 1 步：解析推导\n\n我们考虑一根长度为 $L$ 的悬臂梁，它在 $x=0$ 处固支，并在自由端 $x=L$ 处承受一个向下的垂直点载荷 $P$。我们建立一个坐标系，$x$ 轴沿梁的中性轴，而 $w(x)$ 表示向下的横向挠度。\n\n关键物理参数为：\n- 杨氏模量: $E$\n- 泊松比: $\\nu$\n- 截面宽度: $b$\n- 截面高度: $h$\n- 剪切修正系数: $k = 5/6$ （对于矩形截面）\n\n由此，我们推导出：\n- 截面面积: $A = bh$\n- 截面二次矩: $I = bh^3/12$\n- 剪切模量: $G = E / (2(1+\\nu))$\n\n对于带有顶点载荷 $P$ 的悬臂梁，在 $x \\in [0, L]$ 范围内的任何截面上的内剪力 $V(x)$ 和弯矩 $M(x)$ 由静力平衡给出：\n$$ V(x) = P $$\n$$ M(x) = P(L-x) $$\n这个符号约定假设 $w$ 向下为正，而 $M$ 在上部纤维引起拉伸时为正（这里情况并非如此，但在选定方向上，对于能量和挠度而言，重要的是其大小）。基于势能或使用边界条件进行直接积分的一致推导，可以得到以下结果。\n\n#### 1.1. Euler-Bernoulli (EB) 梁理论\n该理论忽略剪切变形。其控制关系为 $EI \\frac{d^2w}{dx^2} = M(x)$。\n$$ EI \\frac{d^2w_{\\mathrm{EB}}}{dx^2} = P(L-x) $$\n对 $x$ 积分：\n$$ EI \\frac{dw_{\\mathrm{EB}}}{dx} = P(Lx - \\frac{x^2}{2}) + C_1 $$\n在 $x=0$ 处的固支边界条件要求转角为零，即 $\\frac{dw_{\\mathrm{EB}}}{dx}(0) = 0$，这意味着 $C_1=0$。\n再次积分：\n$$ EI w_{\\mathrm{EB}}(x) = P(\\frac{Lx^2}{2} - \\frac{x^3}{6}) + C_2 $$\n在 $x=0$ 处的固支边界条件要求挠度为零，即 $w_{\\mathrm{EB}}(0)=0$，这意味着 $C_2=0$。\n因此，Euler-Bernoulli 模型的精确挠度为：\n$$ w_{\\mathrm{EB}}(x) = \\frac{P}{EI} \\left( \\frac{Lx^2}{2} - \\frac{x^3}{6} \\right) = \\frac{Px^2}{6EI}(3L-x) $$\n\n#### 1.2. Timoshenko 梁理论\n该理论同时考虑了弯曲变形和剪切变形。总挠度 $w_{\\mathrm{T}}(x)$ 是弯曲引起的挠度 $w_b(x)$ 和剪切引起的挠度 $w_s(x)$ 的总和。弯曲分量的形式与 Euler-Bernoulli 解相同。\n剪切变形由关系 $V = kAG \\gamma_s$ 控制，其中剪切应变 $\\gamma_s = dw_s/dx$。\n$$ \\frac{dw_s}{dx} = \\gamma_s = \\frac{V(x)}{kAG} = \\frac{P}{kAG} $$\n对 $x$ 积分并应用边界条件 $w_s(0)=0$：\n$$ w_s(x) = \\int_0^x \\frac{P}{kAG} d\\xi = \\frac{Px}{kAG} $$\nTimoshenko 理论下的总挠度是弯曲效应和剪切效应的叠加：\n$$ w_{\\mathrm{T}}(x) = w_b(x) + w_s(x) = \\frac{Px^2}{6EI}(3L-x) + \\frac{Px}{kAG} $$\n该表达式作为参考（“真实”）解，用于与 Euler-Bernoulli 有限元模型进行比较。\n\n### 第 2 步：Euler-Bernoulli 有限元公式\n\n梁被离散为 $n_e$ 个长度相等的单元，每个单元长度为 $l_e = L/n_e$。每个单元有两个节点，每个节点有两个自由度 (DOF)：一个横向位移 $w_i$ 和一个转角 $\\theta_i$。单元位移向量为 $\\mathbf{d}^e = [w_1, \\theta_1, w_2, \\theta_2]^T$。基于三次 Hermite 形函数推导出的 Euler-Bernoulli 梁单元的单元刚度矩阵 $\\mathbf{k}^e$ 为：\n$$ \\mathbf{k}^e = \\frac{EI}{l_e^3} \\begin{bmatrix} 12  6l_e  -12  6l_e \\\\ 6l_e  4l_e^2  -6l_e  2l_e^2 \\\\ -12  -6l_e  12  -6l_e \\\\ 6l_e  2l_e^2  -6l_e  4l_e^2 \\end{bmatrix} $$\n全局刚度矩阵 $\\mathbf{K}$ 和全局力向量 $\\mathbf{F}$ 由单元级贡献组装而成。系统共有 $N_{DOF} = 2(n_e+1)$ 个自由度。\n通过在第一个节点（$x=0$）处强制 $w_0=0$ 和 $\\theta_0=0$ 来施加边界条件。这通常通过移除 $\\mathbf{K}$ 的前两行和前两列以及位移和力向量中的相应项来完成。\n顶点载荷 $P$ 施加到最后一个节点（位于 $x=L$ 的节点 $n_e$）的横向位移自由度上。全局力向量 $\\mathbf{F}$ 除了对应于此自由度的项被设为 $P$ 外，其余均为零。\n求解简化的线性方程组 $\\mathbf{K}_{red}\\mathbf{d}_{red} = \\mathbf{F}_{red}$，得到未知节点位移向量 $\\mathbf{d}_{red}$。\n\n求解后，重构完整的节点位移向量 $\\mathbf{d}$。为了在单元 $e$（从 $x_e$ 到 $x_e+l_e$）内的任意点 $x$ 处找到挠度 $w_{FE}(x)$，我们使用 Hermite 形函数插值：\n$$ w_{FE}(x(\\xi)) = N_1(\\xi)w_1 + N_2(\\xi)\\theta_1 + N_3(\\xi)w_2 + N_4(\\xi)\\theta_2 $$\n其中 $\\xi = (x - x_e) / l_e$ 是局部坐标，$[w_1, \\theta_1, w_2, \\theta_2]$ 是该单元求解出的节点自由度。形函数为：\n$$ N_1(\\xi) = 1 - 3\\xi^2 + 2\\xi^3 \\quad , \\quad N_2(\\xi) = l_e(\\xi - 2\\xi^2 + \\xi^3) $$\n$$ N_3(\\xi) = 3\\xi^2 - 2\\xi^3 \\quad \\quad, \\quad N_4(\\xi) = l_e(-\\xi^2 + \\xi^3) $$\n对于这个特定问题——一个仅在节点上加载并使用三次 Hermite 单元的梁——无论单元数量 $n_e$ 是多少，有限元解 $w_{FE}(x)$ 将与 Euler-Bernoulli 解析解 $w_{\\mathrm{EB}}(x)$ 完全匹配。尽管如此，实现有限元求解器是问题陈述的要求。\n\n### 第 3 步：误差度量计算\n\n问题要求为每个测试用例计算三个度量。根据问题陈述，度量定义中的符号 $w_{\\mathrm{EB}}$ 指的是计算出的有限元挠度，我们记为 $w_{FE}$。\n\n1.  **顶点挠度低估比 ($r$)**: 该度量衡量 EB 模型低估总顶点挠度的程度。\n    $$ r = \\frac{w_{FE}(L)}{w_{\\mathrm{T}}(L)} $$\n    其中 $w_{FE}(L)$ 是计算出的顶点节点的横向位移，而 $w_{\\mathrm{T}}(L) = \\frac{PL^3}{3EI} + \\frac{PL}{kAG}$。\n\n2.  **最大逐点相对挠度误差 ($e_{\\max}$)**: 该度量量化了在指定域上挠度分布的最大误差。\n    $$ e_{\\max} = \\max_{x \\in [0.1L, L]} \\left( \\frac{w_{\\mathrm{T}}(x) - w_{FE}(x)}{w_{\\mathrm{T}}(x)} \\right) $$\n    这通过在区间 $[0.1L, L]$ 上以高分辨率对误差函数进行采样并找到最大值来确定。\n\n3.  **单调性标志 ($m$)**: 这个布尔标志指示相对误差函数 $e(x) = (w_{\\mathrm{T}}(x) - w_{FE}(x)) / w_{\\mathrm{T}}(x)$ 在采样区间 $[0.1L, L]$ 上是否单调递减。从解析上看，我们有：\n    $$ e(x) = \\frac{w_s(x)}{w_b(x) + w_s(x)} = \\frac{Px/kAG}{\\frac{Px^2}{6EI}(3L-x) + Px/kAG} = \\frac{1}{\\frac{kAG}{6EI}x(3L-x) + 1} $$\n    函数 $f(x) = x(3L-x)$ 在 $x=1.5L$ 处有最大值。在区间 $[0.1L, L]$ 上，$f(x)$ 是严格递增的。因此，$e(x)$ 的分母是严格递增的，这意味着 $e(x)$ 必须是严格递减的。对于所有情况，标志 $m$ 都应为 `True`。数值实现将验证这一点。\n\n程序将对提供的四个测试用例执行这整个工作流程，这些用例旨在展示 Euler-Bernoulli 模型的“伪刚度”如何随着梁的长细比 ($L/h$) 减小而变得更加显著。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the beam problem for all test cases and prints the formatted result.\n    \"\"\"\n\n    test_cases = [\n        # Case A (slender)\n        {\"E\": 210e9, \"nu\": 0.3, \"b\": 0.02, \"h\": 0.01, \"L\": 0.20, \"P\": 1000, \"ne\": 1},\n        # Case B (moderately thick)\n        {\"E\": 210e9, \"nu\": 0.3, \"b\": 0.02, \"h\": 0.01, \"L\": 0.05, \"P\": 1000, \"ne\": 1},\n        # Case C (thick with mesh refinement)\n        {\"E\": 210e9, \"nu\": 0.3, \"b\": 0.02, \"h\": 0.01, \"L\": 0.02, \"P\": 1000, \"ne\": 4},\n        # Case D (very short beam)\n        {\"E\": 210e9, \"nu\": 0.3, \"b\": 0.02, \"h\": 0.01, \"L\": 0.01, \"P\": 1000, \"ne\": 8},\n    ]\n\n    results = []\n    for case in test_cases:\n        res = compute_metrics(**case)\n        # Format boolean as required for output string\n        results.append(f\"[{res[0]},{res[1]},{str(res[2]).lower()}]\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef compute_metrics(E, nu, b, h, L, P, ne):\n    \"\"\"\n    Computes the error metrics for a single beam problem case.\n    \n    Args:\n        E (float): Young's modulus (Pa)\n        nu (float): Poisson's ratio\n        b (float): Cross-section width (m)\n        h (float): Cross-section height (m)\n        L (float): Beam length (m)\n        P (float): Tip load (N)\n        ne (int): Number of finite elements\n\n    Returns:\n        tuple: A tuple containing (r, e_max, m).\n    \"\"\"\n\n    # 1. Calculate derived physical properties\n    I = (b * h**3) / 12           # Second moment of area\n    A = b * h                     # Cross-sectional area\n    G = E / (2 * (1 + nu))        # Shear modulus\n    k = 5.0 / 6.0                 # Shear correction factor for rectangular section\n    EI = E * I\n    kAG = k * A * G\n\n    # 2. Compute Finite Element solution based on Euler-Bernoulli theory\n    le = L / ne\n    num_nodes = ne + 1\n    num_dofs = 2 * num_nodes\n\n    # Element stiffness matrix\n    ke = (EI / le**3) * np.array([\n        [12, 6 * le, -12, 6 * le],\n        [6 * le, 4 * le**2, -6 * le, 2 * le**2],\n        [-12, -6 * le, 12, -6 * le],\n        [6 * le, 2 * le**2, -6 * le, 4 * le**2]\n    ])\n\n    # Assembly\n    K_global = np.zeros((num_dofs, num_dofs))\n    for i in range(ne):\n        # Connectivity: element i connects node i and i+1\n        # DOFs: (2*i, 2*i+1) and (2*(i+1), 2*(i+1)+1)\n        dof_indices = np.array([2 * i, 2 * i + 1, 2 * (i + 1), 2 * (i + 1) + 1])\n        for r_local, r_global in enumerate(dof_indices):\n            for c_local, c_global in enumerate(dof_indices):\n                K_global[r_global, c_global] += ke[r_local, c_local]\n\n    # Force vector\n    F_global = np.zeros(num_dofs)\n    F_global[-2] = P  # Force P on transverse DOF of the last node\n\n    # Apply boundary conditions (clamped at x=0)\n    # DOFs 0 and 1 (w_0, theta_0) are fixed to zero.\n    dofs_to_keep = np.arange(2, num_dofs)\n    K_reduced = K_global[np.ix_(dofs_to_keep, dofs_to_keep)]\n    F_reduced = F_global[dofs_to_keep]\n\n    # Solve for unknown displacements\n    d_reduced = np.linalg.solve(K_reduced, F_reduced)\n    \n    # Reconstruct full displacement vector\n    d_full = np.zeros(num_dofs)\n    d_full[2:] = d_reduced\n    \n    # 3. Define analytical and FE deflection functions\n    \n    def w_timoshenko(x):\n        term_bending = (P * x**2) / (6 * EI) * (3 * L - x)\n        term_shear = (P * x) / kAG\n        return term_bending + term_shear\n\n    def w_fem_eb(x_coords):\n        x_coords = np.atleast_1d(x_coords)\n        w_vals = np.zeros_like(x_coords, dtype=float)\n        \n        for i, x in enumerate(x_coords):\n            if x == L:\n                elem_idx = ne - 1\n            else:\n                elem_idx = int(x // le)\n            \n            x_e = elem_idx * le\n            xi = (x - x_e) / le\n            \n            w1_idx, th1_idx = 2 * elem_idx, 2 * elem_idx + 1\n            w2_idx, th2_idx = 2 * (elem_idx + 1), 2 * (elem_idx + 1) + 1\n            \n            d_elem = np.array([d_full[w1_idx], d_full[th1_idx], d_full[w2_idx], d_full[th2_idx]])\n\n            N1 = 1 - 3 * xi**2 + 2 * xi**3\n            N2 = le * (xi - 2 * xi**2 + xi**3)\n            N3 = 3 * xi**2 - 2 * xi**3\n            N4 = le * (-xi**2 + xi**3)\n            \n            shape_funcs = np.array([N1, N2, N3, N4])\n            w_vals[i] = np.dot(shape_funcs, d_elem)\n            \n        return w_vals if len(w_vals) > 1 else w_vals[0]\n\n    # 4. Calculate metrics\n    \n    # tip-deflection underprediction ratio (r)\n    w_fe_tip = d_full[-2]\n    w_t_tip = w_timoshenko(L)\n    r = w_fe_tip / w_t_tip\n    \n    # maximum pointwise relative deflection error (e_max)\n    # and monotonicity flag (m)\n    sample_points = np.linspace(0.1 * L, L, 1000)\n    w_t_samples = w_timoshenko(sample_points)\n    w_fe_samples = w_fem_eb(sample_points)\n    \n    # Avoid division by zero if w_t is zero anywhere, though not expected here\n    w_t_samples[w_t_samples == 0] = 1e-30 \n    \n    relative_errors = (w_t_samples - w_fe_samples) / w_t_samples\n    e_max = np.max(relative_errors)\n    \n    # Check for monotonicity: error should decrease with x\n    # np.diff(a)[i] = a[i+1] - a[i]. For a decreasing sequence, all diffs must be = 0.\n    # Allowing for small float inaccuracies by using a small tolerance epsilon.\n    m = np.all(np.diff(relative_errors) = 1e-9)\n\n    return r, e_max, m\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3563594"}, {"introduction": "将有限元方法从静态分析扩展到动态分析，需要引入质量矩阵并将空间离散与时间积分方案相结合。对于无阻尼、无外力的保守系统，能量守恒是其基本物理特性，一个优秀的数值算法应当能在离散层面上保持这一特性。本练习 [@problem_id:3563579] 将探讨梁的振动行为，并验证常用于结构动力学分析的Newmark平均加速度法在理论上的能量守恒特性。你将通过编程实现并观察到，在理想情况下，系统的总能量除了微小的浮点舍入误差外应保持恒定。", "problem": "考虑一根直棱柱欧拉-伯努利梁的无阻尼、无外力横向振动。使用欧拉-伯努利运动学和虚功原理，在通过标准有限元离散化（每个单元内使用三次 Hermite 插值）后，推导空间上的半离散运动方程。基本出发点是动量平衡的弱形式和线弹性弯曲：弯矩-曲率关系为 $M(x,t) = E I \\kappa(x,t)$，其中 $E$ 是杨氏模量，$I$ 是截面二次矩；单位长度的惯性力为 $\\rho A \\, \\ddot{w}(x,t)$，其中 $\\rho$ 是质量密度，$A$ 是横截面积，$w(x,t)$ 是横向位移。证明该半离散模型具有以下形式\n$$\n\\mathbf{M} \\, \\ddot{\\mathbf{u}}(t) + \\mathbf{K} \\, \\mathbf{u}(t) = \\mathbf{0},\n$$\n其中 $\\mathbf{u}(t)$ 包含了节点的横向位移和转角，$\\mathbf{M}$ 是协调的对称正定质量矩阵，$\\mathbf{K}$ 是对称半正定刚度矩阵。边界条件使得 $\\mathbf{K}$ 在自由度上是正定的。机械能为\n$$\n\\mathcal{E}(t) = \\tfrac{1}{2} \\, \\dot{\\mathbf{u}}(t)^{\\mathsf{T}} \\mathbf{M} \\, \\dot{\\mathbf{u}}(t) + \\tfrac{1}{2} \\, \\mathbf{u}(t)^{\\mathsf{T}} \\mathbf{K} \\, \\mathbf{u}(t).\n$$\n您将验证平均加速度 Newmark 方法的离散能量守恒性，并量化由浮点舍入误差引起的偏差。\n\n任务：\n- 从半离散方程出发，仅利用 $\\mathbf{M}$ 和 $\\mathbf{K}$ 是对称的性质，以及 Newmark 平均加速度格式使用时间平均的加速度和速度（参数 $\\beta = 1/4$ 和 $\\gamma = 1/2$）这一事实，推导在精确计算下，该方法对无阻尼、无外力的线性系统能精确保持离散机械能，即对于所有时间步，$\\mathcal{E}_{n+1} = \\mathcal{E}_n$。\n- 实现应用于组装后的带有一致质量的半离散梁方程的平均加速度 Newmark 格式。使用标准的具有4个局部自由度（两端各一个横向位移和转角）的2节点欧拉-伯努利梁有限元，并为均匀网格组装全局 $\\mathbf{M}$ 和 $\\mathbf{K}$。通过消除受约束的自由度来施加本质边界条件。以零位移和一个在自由横向位移自由度上规定的节点速度分布进行初始化，同时节点转动速度为零。在每个时间步计算离散机械能，并报告整个模拟过程中与初始能量的最大相对偏差。\n- 使用国际单位制（SI）：$E$ 的单位为 $\\mathrm{Pa}$，$I$ 的单位为 $\\mathrm{m}^4$，$\\rho$ 的单位为 $\\mathrm{kg/m^3}$，$A$ 的单位为 $\\mathrm{m}^2$，长度单位为 $\\mathrm{m}$，时间单位为 $\\mathrm{s}$，角度单位为弧度。报告的能量偏差是无量纲的。角度必须以弧度为单位。\n\n测试组：\n对于每种情况，构建梁，组装 $\\mathbf{M}$ 和 $\\mathbf{K}$，施加边界条件，并使用 Newmark 平均加速度方法进行时间积分。对于所有情况，使用相同的材料和几何属性，以及一个初始速度幅值 $a_{\\mathrm{vel}} = 0.1$，该速度按如下指定的正弦位置模式应用于自由横向位移自由度，初始位移为零。这三种情况是：\n- 情况1（粗网格，两端固支）：$L = 2.0$，$E = 210 \\times 10^9$，$I = 8.333 \\times 10^{-6}$，$\\rho = 7850$，$A = 0.01$，单元数量 $N_e = 2$，边界条件为两端固支（两端的横向位移和转角均被固定），时间步长 $\\Delta t = 1.0 \\times 10^{-5}$，总时间 $T = 0.5$。\n- 情况2（中等网格，简支）：相同的 $L$、$E$、$I$、$\\rho$、$A$；$N_e = 10$，边界条件为简支（两端横向位移被固定，转角自由），$\\Delta t = 2.0 \\times 10^{-5}$，$T = 0.2$。\n- 情况3（细化网格，简支）：相同的 $L$、$E$、$I$、$\\rho$、$A$；$N_e = 20$，边界条件为简支，$\\Delta t = 1.0 \\times 10^{-5}$，$T = 0.1$。\n\n初始速度规定：对于每个节点位置 $x_i = i \\, L / N_e$（$i = 0,\\dots,N_e$），将节点 $i$ 处与横向位移自由度相关的初始速度（如果它是一个自由度）设置为 $a_{\\mathrm{vel}} \\, \\sin(\\pi x_i/L)$，并将所有转动初始速度设置为零。初始位移为零。从离散方程计算初始加速度。\n\n您的程序必须生成单行输出，其中包含每种情况的最大相对能量偏差，格式为一个用方括号括起来的逗号分隔列表，每个浮点数四舍五入到10位有效数字，例如 $[1.23e-10,4.56e-12,7.89e-11]$。三个输出分别对应情况1、2和3。\n\n不允许提供提示。不要在问题陈述中提供快捷公式。专注于第一性原理和核心定义。最终的数值答案必须由您的程序计算得出，无需外部输入或文件。", "solution": "该问题要求对线性无阻尼系统的 Newmark 平均加速度方法的能量守恒特性进行理论推导，然后通过数值实现来验证该特性对振动的欧拉-伯努利梁的适用性。数值部分涉及量化由浮点运算产生的微小能量偏差。\n\n首先，我们进行理论推导。无阻尼、无外力线性系统的半离散运动方程如下：\n$$\n\\mathbf{M} \\ddot{\\mathbf{u}}(t) + \\mathbf{K} \\mathbf{u}(t) = \\mathbf{0}\n$$\n其中 $\\mathbf{M}$ 是对称正定质量矩阵，$\\mathbf{K}$ 是对称刚度矩阵，$\\mathbf{u}(t)$ 是广义位移向量。系统的离散机械能是动能和势能之和：\n$$\n\\mathcal{E}(t) = \\mathcal{T}(t) + \\mathcal{V}(t) = \\frac{1}{2} \\dot{\\mathbf{u}}(t)^{\\mathsf{T}} \\mathbf{M} \\dot{\\mathbf{u}}(t) + \\frac{1}{2} \\mathbf{u}(t)^{\\mathsf{T}} \\mathbf{K} \\mathbf{u}(t)\n$$\nNewmark 方法提供了从时间步 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的位移 $\\mathbf{u}$ 和速度 $\\dot{\\mathbf{u}}$ 的更新规则。对于平均加速度方法，Newmark 参数为 $\\gamma = 1/2$ 和 $\\beta = 1/4$。更新规则为：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\dot{\\mathbf{u}}_n + \\Delta t^2 \\left[ \\left(\\frac{1}{2} - \\beta\\right) \\ddot{\\mathbf{u}}_n + \\beta \\ddot{\\mathbf{u}}_{n+1} \\right] \\\\\n\\dot{\\mathbf{u}}_{n+1} = \\dot{\\mathbf{u}}_n + \\Delta t \\left[ (1 - \\gamma) \\ddot{\\mathbf{u}}_n + \\gamma \\ddot{\\mathbf{u}}_{n+1} \\right]\n$$\n代入 $\\gamma = 1/2$ 和 $\\beta = 1/4$：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\dot{\\mathbf{u}}_n + \\frac{\\Delta t^2}{4} (\\ddot{\\mathbf{u}}_n + \\ddot{\\mathbf{u}}_{n+1}) \\\\\n\\dot{\\mathbf{u}}_{n+1} = \\dot{\\mathbf{u}}_n + \\frac{\\Delta t}{2} (\\ddot{\\mathbf{u}}_n + \\ddot{\\mathbf{u}}_{n+1})\n$$\n这两个方程可以重新排列，以表明该方法等效于梯形法则。速度更新直接给出了平均加速度关系：\n$$\n\\frac{\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n}{\\Delta t} = \\frac{\\ddot{\\mathbf{u}}_n + \\ddot{\\mathbf{u}}_{n+1}}{2}\n$$\n由此，我们可以写出 $\\ddot{\\mathbf{u}}_n + \\ddot{\\mathbf{u}}_{n+1} = \\frac{2}{\\Delta t}(\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)$。将此式代入位移更新规则：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\dot{\\mathbf{u}}_n + \\frac{\\Delta t^2}{4} \\frac{2}{\\Delta t}(\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n) = \\mathbf{u}_n + \\Delta t \\dot{\\mathbf{u}}_n + \\frac{\\Delta t}{2}(\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)\n$$\n重新整理这个式子可以得到平均速度关系：\n$$\n\\frac{\\mathbf{u}_{n+1} - \\mathbf{u}_n}{\\Delta t} = \\frac{\\dot{\\mathbf{u}}_n + \\dot{\\mathbf{u}}_{n+1}}{2}\n$$\n运动方程必须在离散时间点 $t_n$ 和 $t_{n+1}$ 处得到满足。梯形法则在时间步上平均地强制满足运动方程：\n$$\n\\frac{1}{2}(\\mathbf{M} \\ddot{\\mathbf{u}}_n + \\mathbf{K} \\mathbf{u}_n) + \\frac{1}{2}(\\mathbf{M} \\ddot{\\mathbf{u}}_{n+1} + \\mathbf{K} \\mathbf{u}_{n+1}) = \\mathbf{0}\n$$\n$$\n\\mathbf{M} \\left( \\frac{\\ddot{\\mathbf{u}}_n + \\ddot{\\mathbf{u}}_{n+1}}{2} \\right) + \\mathbf{K} \\left( \\frac{\\mathbf{u}_n + \\mathbf{u}_{n+1}}{2} \\right) = \\mathbf{0}\n$$\n代入平均速度和加速度规则：\n$$\n\\mathbf{M} \\left( \\frac{\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n}{\\Delta t} \\right) + \\mathbf{K} \\left( \\frac{\\mathbf{u}_n + \\mathbf{u}_{n+1}}{2} \\right) = \\mathbf{0}\n$$\n为了证明能量守恒，我们考察离散能量的变化量 $\\Delta \\mathcal{E} = \\mathcal{E}_{n+1} - \\mathcal{E}_n$：\n$$\n\\Delta \\mathcal{E} = \\left(\\frac{1}{2} \\dot{\\mathbf{u}}_{n+1}^{\\mathsf{T}} \\mathbf{M} \\dot{\\mathbf{u}}_{n+1} - \\frac{1}{2} \\dot{\\mathbf{u}}_n^{\\mathsf{T}} \\mathbf{M} \\dot{\\mathbf{u}}_n\\right) + \\left(\\frac{1}{2} \\mathbf{u}_{n+1}^{\\mathsf{T}} \\mathbf{K} \\mathbf{u}_{n+1} - \\frac{1}{2} \\mathbf{u}_n^{\\mathsf{T}} \\mathbf{K} \\mathbf{u}_n\\right)\n$$\n利用恒等式 $b^2 - a^2 = (b-a)(b+a)$ 以及 $\\mathbf{M}$ 和 $\\mathbf{K}$ 的对称性：\n$$\n\\Delta \\mathcal{E} = \\frac{1}{2} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)^{\\mathsf{T}} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) + \\frac{1}{2} (\\mathbf{u}_{n+1} - \\mathbf{u}_n)^{\\mathsf{T}} \\mathbf{K} (\\mathbf{u}_{n+1} + \\mathbf{u}_n)\n$$\n现在，将平均速度规则代入第二项：\n$$\n\\Delta \\mathcal{E} = \\frac{1}{2} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)^{\\mathsf{T}} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) + \\frac{1}{2} \\left[ \\frac{\\Delta t}{2}(\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) \\right]^{\\mathsf{T}} \\mathbf{K} (\\mathbf{u}_{n+1} + \\mathbf{u}_n)\n$$\n根据平均后的运动方程，我们有 $\\mathbf{K} (\\mathbf{u}_{n+1} + \\mathbf{u}_n) = -\\frac{2}{\\Delta t} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)$。代入此式：\n$$\n\\Delta \\mathcal{E} = \\frac{1}{2} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)^{\\mathsf{T}} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) + \\frac{1}{2} \\left[ \\frac{\\Delta t}{2}(\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) \\right]^{\\mathsf{T}} \\left[ -\\frac{2}{\\Delta t} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n) \\right]\n$$\n$$\n\\Delta \\mathcal{E} = \\frac{1}{2} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)^{\\mathsf{T}} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n) - \\frac{1}{2} (\\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n)^{\\mathsf{T}} \\mathbf{M} (\\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n)\n$$\n令 $\\mathbf{a} = \\dot{\\mathbf{u}}_{n+1} - \\dot{\\mathbf{u}}_n$ 且 $\\mathbf{b} = \\dot{\\mathbf{u}}_{n+1} + \\dot{\\mathbf{u}}_n$。表达式变为 $\\Delta\\mathcal{E} = \\frac{1}{2} \\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b} - \\frac{1}{2} \\mathbf{b}^{\\mathsf{T}}\\mathbf{M}\\mathbf{a}$。由于 $\\mathbf{M}$ 是对称的，标量 $\\mathbf{b}^{\\mathsf{T}}\\mathbf{M}\\mathbf{a} = (\\mathbf{a}^{\\mathsf{T}}\\mathbf{M}^{\\mathsf{T}}\\mathbf{b})^{\\mathsf{T}} = (\\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b})^{\\mathsf{T}} = \\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b}$。因此：\n$$\n\\Delta \\mathcal{E} = \\frac{1}{2} \\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b} - \\frac{1}{2} \\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b} = 0\n$$\n这证明了在精确计算下 $\\mathcal{E}_{n+1} = \\mathcal{E}_n$。\n\n对于数值实现，我们使用欧拉-伯努利梁的有限元离散化。使用一个2节点单元，并对横向位移 $w(x,t)$ 进行三次 Hermite 插值。长度为 $L_e$ 的单元的节点自由度（DOFs）为 $\\mathbf{u}^e = [w_1, \\theta_1, w_2, \\theta_2]^{\\mathsf{T}}$。相应的单元刚度矩阵 $\\mathbf{k}^e$ 和协调质量矩阵 $\\mathbf{m}^e$ 为：\n$$\n\\mathbf{k}^e = \\frac{EI}{L_e^3} \\begin{pmatrix} 12  6L_e  -12  6L_e \\\\ 6L_e  4L_e^2  -6L_e  2L_e^2 \\\\ -12  -6L_e  12  -6L_e \\\\ 6L_e  2L_e^2  -6L_e  4L_e^2 \\end{pmatrix}\n$$\n$$\n\\mathbf{m}^e = \\frac{\\rho A L_e}{420} \\begin{pmatrix} 156  22L_e  54  -13L_e \\\\ 22L_e  4L_e^2  13L_e  -3L_e^2 \\\\ 54  13L_e  156  -22L_e \\\\ -13L_e  -3L_e^2  -22L_e  4L_e^2 \\end{pmatrix}\n$$\n通过将所有单元的贡献相加来组装全局矩阵 $\\mathbf{M}$ 和 $\\mathbf{K}$。通过消除与受约束自由度对应的行和列来施加本质边界条件（固支或简支），从而得到控制自由自由度的简化矩阵 $\\mathbf{M}_{\\text{free}}$ 和 $\\mathbf{K}_{\\text{free}}$。\n\nNewmark 积分按以下方式执行。在每个时间步，我们求解下一步的加速度 $\\ddot{\\mathbf{u}}_{n+1}$：\n$$\n(\\mathbf{M}_{\\text{free}} + \\beta \\Delta t^2 \\mathbf{K}_{\\text{free}}) \\ddot{\\mathbf{u}}_{n+1} = -\\mathbf{K}_{\\text{free}} (\\mathbf{u}_n + \\Delta t \\dot{\\mathbf{u}}_n + (\\frac{1}{2}-\\beta)\\Delta t^2 \\ddot{\\mathbf{u}}_n)\n$$\n左侧的矩阵，或称为有效刚度矩阵 $\\hat{\\mathbf{K}}$，是恒定的，可以进行一次分解。在求解这个线性系统得到 $\\ddot{\\mathbf{u}}_{n+1}$ 后，更新速度 $\\dot{\\mathbf{u}}_{n+1}$ 和位移 $\\mathbf{u}_{n+1}$。在每个步骤计算离散能量，并跟踪与初始能量 $\\mathcal{E}_0$ 的最大相对偏差。初始位移为零，因此 $\\mathcal{E}_0$ 仅包含由规定的初始速度分布产生的动能。由于 $\\mathbf{u}_0=\\mathbf{0}$，初始加速度也为 $\\ddot{\\mathbf{u}}_0 = -\\mathbf{M}_{\\text{free}}^{-1}\\mathbf{K}_{\\text{free}}\\mathbf{u}_0 = \\mathbf{0}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        { # Case 1\n            \"L\": 2.0, \"E\": 210e9, \"I\": 8.333e-6, \"rho\": 7850, \"A\": 0.01,\n            \"Ne\": 2, \"bc_type\": \"clamped-clamped\", \"dt\": 1.0e-5, \"T\": 0.5,\n            \"a_vel\": 0.1\n        },\n        { # Case 2\n            \"L\": 2.0, \"E\": 210e9, \"I\": 8.333e-6, \"rho\": 7850, \"A\": 0.01,\n            \"Ne\": 10, \"bc_type\": \"simply-supported\", \"dt\": 2.0e-5, \"T\": 0.2,\n            \"a_vel\": 0.1\n        },\n        { # Case 3\n            \"L\": 2.0, \"E\": 210e9, \"I\": 8.333e-6, \"rho\": 7850, \"A\": 0.01,\n            \"Ne\": 20, \"bc_type\": \"simply-supported\", \"dt\": 1.0e-5, \"T\": 0.1,\n            \"a_vel\": 0.1\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        max_rel_dev = run_simulation(case)\n        results.append(f\"{max_rel_dev:.9e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(params):\n    \"\"\"\n    Executes a single beam vibration simulation based on the provided parameters.\n    \"\"\"\n    # Unpack parameters\n    L, E, I, rho, A = params[\"L\"], params[\"E\"], params[\"I\"], params[\"rho\"], params[\"A\"]\n    Ne, bc_type, dt, T, a_vel = params[\"Ne\"], params[\"bc_type\"], params[\"dt\"], params[\"T\"], params[\"a_vel\"]\n\n    # Element properties\n    Le = L / Ne\n    EI = E * I\n    rhoA = rho * A\n\n    # Element stiffness matrix (k_e)\n    k_e = (EI / Le**3) * np.array([\n        [12, 6*Le, -12, 6*Le],\n        [6*Le, 4*Le**2, -6*Le, 2*Le**2],\n        [-12, -6*Le, 12, -6*Le],\n        [6*Le, 2*Le**2, -6*Le, 4*Le**2]\n    ])\n\n    # Element consistent mass matrix (m_e)\n    m_e = (rhoA * Le / 420) * np.array([\n        [156, 22*Le, 54, -13*Le],\n        [22*Le, 4*Le**2, 13*Le, -3*Le**2],\n        [54, 13*Le, 156, -22*Le],\n        [-13*Le, -3*Le**2, -22*Le, 4*Le**2]\n    ])\n\n    # Assembly of global matrices\n    num_nodes = Ne + 1\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n    M = np.zeros((num_dofs, num_dofs))\n\n    for e in range(Ne):\n        # Global DOFs for element e are: w_e, th_e, w_{e+1}, th_{e+1}\n        # which correspond to indices 2*e, 2*e+1, 2*e+2, 2*e+3\n        dofs = np.arange(2*e, 2*e+4)\n        K[np.ix_(dofs, dofs)] += k_e\n        M[np.ix_(dofs, dofs)] += m_e\n\n    # Apply boundary conditions by identifying constrained DOFs\n    if bc_type == 'clamped-clamped':\n        constrained_dofs = [0, 1, 2*Ne, 2*Ne+1]\n    elif bc_type == 'simply-supported':\n        constrained_dofs = [0, 2*Ne]\n    else: # free-free\n        constrained_dofs = []\n\n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs, assume_unique=True)\n\n    # Reduce matrices to free DOFs\n    K_free = K[np.ix_(free_dofs, free_dofs)]\n    M_free = M[np.ix_(free_dofs, free_dofs)]\n\n    # Initial conditions\n    u0_full = np.zeros(num_dofs)\n    udot0_full = np.zeros(num_dofs)\n    for i in range(num_nodes):\n        x_i = i * Le\n        # Set velocity for transverse displacement DOFs\n        udot0_full[2*i] = a_vel * np.sin(np.pi * x_i / L)\n    \n    # Reduce initial condition vectors to free DOFs\n    u0 = u0_full[free_dofs]\n    udot0 = udot0_full[free_dofs]\n\n    # Initial acceleration is zero since initial displacement is zero\n    uddot0 = np.zeros_like(u0)\n\n    # Newmark time integration (average-acceleration method)\n    gamma = 0.5\n    beta = 0.25\n    u, udot, uddot = u0.copy(), udot0.copy(), uddot0.copy()\n\n    # Pre-calculate effective stiffness matrix\n    K_eff = M_free + beta * dt**2 * K_free\n\n    # Calculate initial energy\n    E0 = 0.5 * udot.T @ M_free @ udot + 0.5 * u.T @ K_free @ u\n    if np.isclose(E0, 0): # Avoid division by zero if initial energy is zero\n        return 0.0\n\n    max_rel_dev = 0.0\n    num_steps = int(T / dt)\n\n    for _ in range(num_steps):\n        # Calculate effective force vector\n        F_eff = -K_free @ (u + dt * udot + (0.5 - beta) * dt**2 * uddot)\n        \n        # Solve for new acceleration\n        uddot_new = linalg.solve(K_eff, F_eff, assume_a='sym')\n        \n        # Update velocity and displacement\n        udot_new = udot + dt * ((1 - gamma) * uddot + gamma * uddot_new)\n        u_new = u + dt * udot + dt**2 * ((0.5 - beta) * uddot + beta * uddot_new)\n        \n        # Update state variables\n        u, udot, uddot = u_new, udot_new, uddot_new\n        \n        # Calculate energy at current step\n        En = 0.5 * udot.T @ M_free @ udot + 0.5 * u.T @ K_free @ u\n        \n        # Track maximum relative energy deviation\n        rel_dev = abs(En - E0) / abs(E0)\n        if rel_dev > max_rel_dev:\n            max_rel_dev = rel_dev\n\n    return max_rel_dev\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3563579"}]}