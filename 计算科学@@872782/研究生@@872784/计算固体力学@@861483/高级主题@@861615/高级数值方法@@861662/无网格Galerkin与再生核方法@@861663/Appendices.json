{"hands_on_practices": [{"introduction": "“补丁测试”（Patch Test）是验证任何无网格方法实现正确性的基本标准。本练习将指导你实现一个二维移动最小二乘（MLS）近似，并验证其在刚体运动和均匀应变场下的再现性。成功通过补丁测试[@problem_id:3581266]，可以确保你的形函数构造能够精确地再现多项式场，这是保证方法收敛性的一个关键前提。", "problem": "考虑一个通过移动最小二乘法 (MLS) 在再生核 (RK) 近似框架内构建的二维无网格伽辽金法 (EFG) 片检验。目标是验证方形粒子云在刚体运动和均匀应变下的再生性质，并量化支承尺寸和基函数阶次对数值再生误差的影响。\n\n您需要在一个方形域 $[0,1] \\times [0,1]$ 内的一组均匀节点上实现一个基于 MLS 的形函数构造。节点坐标由一个大小为 $N_x \\times N_y$ 的规则网格给出，其中 $N_x = N_y = 11$。网格间距为 $h = 1/(N_x - 1)$。使用一个紧支集正权函数，定义如下：\n$$\nw(q) = \\begin{cases}\n1 - 6 q^2 + 8 q^3 - 3 q^4, & 0 \\le q \\le 1, \\\\\n0, & q > 1,\n\\end{cases}\n$$\n其中 $q = r/d$，$r$ 是评估点到节点的欧几里得距离，$d$ 是节点支承半径。MLS 基函数必须是 $0$ 阶（常数基 $p(\\mathbf{x}) = [1]$）或 $1$ 阶（线性基 $p(\\mathbf{x}) = [1, x, y]$）。MLS 近似必须直接从第一性原理构建：从最小化局部邻域内加权最小二乘误差的 MLS 系数的变分定义出发，推导出数值计算形函数和近似场所需的代数表达式。\n\n在平面中定义三个位移场：\n- 刚性平移：$\\mathbf{u}(\\mathbf{x}) = \\mathbf{c}$，其中 $\\mathbf{c} \\in \\mathbb{R}^2$。\n- 绕原点按角度 $\\theta$ （以弧度为单位）的无穷小刚性转动：$\\mathbf{u}(\\mathbf{x}) = \\theta\\,[-y,\\,x]^T$。\n- 均匀应变：$\\mathbf{u}(\\mathbf{x}) = \\mathbf{E}\\,\\mathbf{x}$，其中 $\\mathbf{E} \\in \\mathbb{R}^{2 \\times 2}$ 为常数。\n\n再生检验要求，只要场属于所选基函数张成的多项式空间且矩量矩阵可逆，MLS 近似 $\\mathbf{u}^h(\\mathbf{x})$ 对于所有 $\\mathbf{x}$ 都必须精确匹配目标场 $\\mathbf{u}(\\mathbf{x})$。特别地，使用 $0$ 阶基时，常数场是可再生的；使用 $1$ 阶基时，所有线性向量场，包括刚体转动和均匀应变，都是可再生的。\n\n通过在网格节点 $\\{\\mathbf{x}_i\\}$ 处从节点样本 $\\{\\mathbf{u}_i\\}$ 构建 MLS 近似值 $\\mathbf{u}^h(\\mathbf{x})$，并在一个评估点集 $\\mathcal{S}$ 上评估最大绝对误差，来数值验证这些再生性质：\n$$\n\\varepsilon_{\\max} = \\max_{\\mathbf{x} \\in \\mathcal{S}} \\|\\mathbf{u}^h(\\mathbf{x}) - \\mathbf{u}(\\mathbf{x})\\|_{\\infty},\n$$\n使用在 $\\mathbb{R}^2$ 上定义的无穷范数 $\\|[a,b]^T\\|_{\\infty} = \\max\\{|a|,|b|\\}$。\n\n角度必须以弧度为单位。输出不涉及物理单位。您的程序必须实现 MLS 形函数，并为下面的每个测试用例计算 $\\varepsilon_{\\max}$。最终输出必须是包含每个测试用例浮点误差列表的单行文本，按指定顺序排列。\n\n测试套件：\n- 测试 $\\mathbf{T1}$ (常规路径，常数再生)：基函数阶次 $0$；支承因子 $s = 2.5$，因此 $d = s\\,h$；刚性平移，$\\mathbf{c} = [0.3,-0.2]^T$；评估集 $\\mathcal{S}$ 是坐标 $\\{0.1,0.3,0.5,0.7,0.9\\} \\times \\{0.1,0.3,0.5,0.7,0.9\\}$ 的笛卡尔积，共 $25$ 个点。\n- 测试 $\\mathbf{T2}$ (常数基不可再生)：基函数阶次 $0$；支承因子 $s = 2.5$；刚性转动，$\\theta = 0.1$；评估集 $\\mathcal{S}$ 与 $\\mathbf{T1}$ 中相同。\n- 测试 $\\mathbf{T3}$ (刚性转动再生)：基函数阶次 $1$；支承因子 $s = 2.5$；刚性转动，$\\theta = 0.1$；评估集 $\\mathcal{S}$ 与 $\\mathbf{T1}$ 中相同。\n- 测试 $\\mathbf{T4}$ (均匀应变再生)：基函数阶次 $1$；支承因子 $s = 2.5$；均匀应变，其中\n$$\n\\mathbf{E} = \\begin{bmatrix} 0.01 & 0.02 \\\\ 0.00 & -0.005 \\end{bmatrix};\n$$\n评估集 $\\mathcal{S}$ 与 $\\mathbf{T1}$ 中相同。\n- 测试 $\\mathbf{T5}$ (小支承下近边界的边缘情况)：基函数阶次 $1$；支承因子 $s = 1.05$；均匀应变，$\\mathbf{E}$ 与 $\\mathbf{T4}$ 中相同；评估集 $\\mathcal{S}$ 包含单个点 $\\mathbf{x} = [0.02, 0.02]^T$。\n\n对于每个测试，计算并返回 $\\varepsilon_{\\max}$ 的值（浮点数）。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[$r_1,r_2,r_3,r_4,r_5$]\"），$r_k$ 是上述顺序中测试 $\\mathbf{Tk}$ 的结果。角度必须以弧度解释，输出没有物理单位。\n\n您的推导和实现必须从 MLS 近似和再生核方法中再生概念的基本定义开始，不假设超出这些定义的专用公式。", "solution": "该问题要求对移动最小二乘法 (MLS) 近似的再生性质进行数值验证，这是像无网格伽辽金法 (EFG) 这类无网格方法的基石。我们将首先从基本原理推导 MLS 形函数，然后概述进行片检验的数值流程。\n\n### 1. 移动最小二乘法 (MLS) 近似\n\nMLS 方法从一组离散的节点值构建一个场的连续近似。设 $u(\\mathbf{x})$ 是定义在域 $\\Omega \\subset \\mathbb{R}^2$ 上的一个标量场。给定一组 $N$ 个节点 $\\{\\mathbf{x}_i\\}_{i=1}^N$ 及其对应的节点值 $\\{u_i = u(\\mathbf{x}_i)\\}_{i=1}^N$，在评估点 $\\mathbf{x}$ 处的 MLS 近似 $u^h(\\mathbf{x})$ 被定义为一个特定阶次的多项式，其系数是局部确定的。\n\n设 $\\mathbf{p}(\\mathbf{x}) = [p_1(\\mathbf{x}), p_2(\\mathbf{x}), \\dots, p_m(\\mathbf{x})]^T$ 是一个由 $m$ 个多项式函数组成的基。对于二维线性近似，一个合适的基是 $\\mathbf{p}(\\mathbf{x}) = [1, x, y]^T$，对应于基函数阶次为 $1$ 且 $m=3$。对于常数近似，基是 $\\mathbf{p}(\\mathbf{x}) = [1]$，阶次为 $0$ 且 $m=1$。\n\n在点 $\\mathbf{x}$ 的近似由下式给出：\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{a}(\\mathbf{x})\n$$\n其中 $\\mathbf{a}(\\mathbf{x}) \\in \\mathbb{R}^m$ 是一个依赖于位置 $\\mathbf{x}$ 的系数向量。这些系数是通过最小化在 $\\mathbf{x}$ 的局部邻域内关于节点值的加权离散最小二乘误差泛函 $J(\\mathbf{a})$ 来确定的：\n$$\nJ(\\mathbf{a}) = \\sum_{i=1}^{N} w(\\mathbf{x} - \\mathbf{x}_i) \\left[ \\mathbf{p}^T(\\mathbf{x}_i) \\mathbf{a}(\\mathbf{x}) - u_i \\right]^2\n$$\n函数 $w(\\mathbf{x} - \\mathbf{x}_i)$ 是一个具有紧支集的权函数，仅当节点 $\\mathbf{x}_i$ 与 $\\mathbf{x}$ “相近”时才非零。问题指定的权函数为：\n$$\nw(q) = \\begin{cases}\n1 - 6 q^2 + 8 q^3 - 3 q^4, & 0 \\le q \\le 1, \\\\\n0, & q > 1,\n\\end{cases}\n$$\n其中 $q = \\|\\mathbf{x} - \\mathbf{x}_i\\|_2 / d$，$d$ 是支承域的半径。为简洁起见，我们记作 $w_i(\\mathbf{x}) = w(\\mathbf{x} - \\mathbf{x}_i)$。\n\n为了找到最小化 $J$ 的系数 $\\mathbf{a}(\\mathbf{x})$，我们将 $J$ 对 $\\mathbf{a}$ 求导并令其为零：\n$$\n\\frac{\\partial J}{\\partial \\mathbf{a}} = 2 \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) \\left[ \\mathbf{p}^T(\\mathbf{x}_i) \\mathbf{a}(\\mathbf{x}) - u_i \\right] = \\mathbf{0}\n$$\n这导出了关于 $\\mathbf{a}(\\mathbf{x})$ 的以下线性方程组：\n$$\n\\left( \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) \\mathbf{p}^T(\\mathbf{x}_i) \\right) \\mathbf{a}(\\mathbf{x}) = \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i\n$$\n我们定义矩量矩阵 $\\mathbf{M}(\\mathbf{x})$，这是一个 $m \\times m$ 的矩阵：\n$$\n\\mathbf{M}(\\mathbf{x}) = \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) \\mathbf{p}^T(\\mathbf{x}_i)\n$$\n现在该系统可以写成 $\\mathbf{M}(\\mathbf{x}) \\mathbf{a}(\\mathbf{x}) = \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i$。\n假设 $\\mathbf{M}(\\mathbf{x})$ 可逆，这要求在 $\\mathbf{x}$ 的支承域内有足够数量且不处于退化构型的节点，我们可以解出 $\\mathbf{a}(\\mathbf{x})$：\n$$\n\\mathbf{a}(\\mathbf{x}) = \\mathbf{M}^{-1}(\\mathbf{x}) \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i\n$$\n\n### 2. MLS 形函数的推导\n\n将 $\\mathbf{a}(\\mathbf{x})$ 的表达式代回 $u^h(\\mathbf{x})$ 的定义中，我们得到：\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) u_i\n$$\n通过重新整理表达式以匹配标准有限元形式 $u^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) u_i$，我们可以识别出与节点 $i$ 相关的 MLS 形函数 $\\phi_i(\\mathbf{x})$：\n$$\n\\phi_i(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) w_i(\\mathbf{x})\n$$\n注意，如果节点 $\\mathbf{x}_i$ 在 $\\mathbf{x}$ 的支承域之外，则 $\\phi_i(\\mathbf{x}) = 0$，因为 $w_i(\\mathbf{x})=0$。\n\n对于向量场，例如位移场 $\\mathbf{u}(\\mathbf{x}) \\in \\mathbb{R}^2$，MLS 近似被独立地应用于每个分量，使用相同的标量形函数：\n$$\n\\mathbf{u}^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) \\mathbf{u}_i\n$$\n其中 $\\mathbf{u}_i = \\mathbf{u}(\\mathbf{x}_i)$ 是节点位移向量。\n\n### 3. 再生性质\n\nMLS 近似拥有“再生核”性质。如果基函数 $\\mathbf{p}(\\mathbf{x})$ 包含直至 $k$ 阶的所有多项式项，则 MLS 近似可以精确再生任何阶次不高于 $k$ 的多项式场。\n设待近似的场 $u(\\mathbf{x})$ 是一个来自基函数张成空间的多项式，即 $u(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x})\\mathbf{c}$，其中 $\\mathbf{c}$ 是某个常系数向量。节点值为 $u_i = u(\\mathbf{x}_i) = \\mathbf{p}^T(\\mathbf{x}_i)\\mathbf{c}$。\n将这些节点值代入 $u^h(\\mathbf{x})$ 的表达式中：\n$$\nu^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) u_i = \\sum_{i=1}^{N} \\phi_i(\\mathbf{x}) (\\mathbf{p}^T(\\mathbf{x}_i)\\mathbf{c})\n$$\n代入 $\\phi_i(\\mathbf{x})$ 的公式：\n$$\nu^h(\\mathbf{x}) = \\sum_{i=1}^{N} \\left[ \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) w_i(\\mathbf{x}) \\right] (\\mathbf{p}^T(\\mathbf{x}_i)\\mathbf{c})\n$$\n由于 $\\mathbf{c}$ 是常数，我们可以将其从求和中提出：\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\left( \\sum_{i=1}^{N} w_i(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i)\\mathbf{p}^T(\\mathbf{x}_i) \\right) \\mathbf{c}\n$$\n括号中的项正是矩量矩阵 $\\mathbf{M}(\\mathbf{x})$ 的定义。因此：\n$$\nu^h(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{M}(\\mathbf{x}) \\mathbf{c} = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{c} = u(\\mathbf{x})\n$$\n这证明了对于任何使 $\\mathbf{M}(\\mathbf{x})$ 可逆的点 $\\mathbf{x}$，只要 $u(\\mathbf{x})$ 在由基函数 $\\mathbf{p}(\\mathbf{x})$ 张成的空间内，就有 $u^h(\\mathbf{x}) = u(\\mathbf{x})$。\n\n### 4. 片检验的数值实现\n\n为每个测试用例执行数值验证的算法如下：\n1.  **节点生成**：在域 $[0,1] \\times [0,1]$ 中生成一个 $N_x \\times N_y = 11 \\times 11$ 的网格节点。网格间距为 $h = 1 / (N_x - 1) = 1/10 = 0.1$。\n2.  **测试用例设置**：对于每个测试用例（$\\mathbf{T1}$ 到 $\\mathbf{T5}$），设置基函数阶次、支承因子 $s$、解析位移场 $\\mathbf{u}(\\mathbf{x})$ 以及评估点集 $\\mathcal{S}$。支承半径为 $d = s \\cdot h$。\n3.  **节点位移**：在每个节点 $\\mathbf{x}_i$ 处计算解析位移场 $\\mathbf{u}(\\mathbf{x})$ 以获得节点值 $\\mathbf{u}_i$。\n4.  **误差计算**：\n    a. 初始化最大误差 $\\varepsilon_{\\max} = 0$。\n    b. 对于每个评估点 $\\mathbf{x} \\in \\mathcal{S}$：\n        i.   识别出支承域内的所有节点 $\\{\\mathbf{x}_i\\}$，即满足 $\\|\\mathbf{x} - \\mathbf{x}_i\\|_2 \\le d$ 的节点。\n        ii.  使用支承域内节点的基多项式 $\\mathbf{p}(\\mathbf{x}_i)$ 和权函数 $w_i(\\mathbf{x})$ 构建矩量矩阵 $\\mathbf{M}(\\mathbf{x})$。\n        iii. 如果 $\\mathbf{M}(\\mathbf{x})$ 可逆，计算其逆矩阵 $\\mathbf{M}^{-1}(\\mathbf{x})$。\n        iv.  初始化近似位移 $\\mathbf{u}^h(\\mathbf{x}) = [0, 0]^T$。\n        v.   对于支承域内的每个节点 $\\mathbf{x}_i$，计算其形函数值 $\\phi_i(\\mathbf{x}) = \\mathbf{p}^T(\\mathbf{x}) \\mathbf{M}^{-1}(\\mathbf{x}) \\mathbf{p}(\\mathbf{x}_i) w_i(\\mathbf{x})$。\n        vi.  累加近似值：$\\mathbf{u}^h(\\mathbf{x}) += \\phi_i(\\mathbf{x}) \\mathbf{u}_i$。\n        vii. 在评估点计算解析位移 $\\mathbf{u}(\\mathbf{x})$。\n        viii.计算误差 $\\varepsilon = \\|\\mathbf{u}^h(\\mathbf{x}) - \\mathbf{u}(\\mathbf{x})\\|_{\\infty} = \\max(|u_x^h - u_x|, |u_y^h - u_y|)$。\n        ix.  更新 $\\varepsilon_{\\max} = \\max(\\varepsilon_{\\max}, \\varepsilon)$。\n5.  **返回结果**：最终的 $\\varepsilon_{\\max}$ 即为该测试用例的结果。\n\n测试用例旨在验证再生性质：\n-   **T1**：在常数场上使用 $0$ 阶基。预期 $\\varepsilon_{\\max} \\approx 0$。\n-   **T2**：在线性场上使用 $0$ 阶基。不可再生。预期 $\\varepsilon_{\\max} > 0$。\n-   **T3**：在线性场（转动）上使用 $1$ 阶基。预期 $\\varepsilon_{\\max} \\approx 0$。\n-   **T4**：在线性场（应变）上使用 $1$ 阶基。预期 $\\varepsilon_{\\max} \\approx 0$。\n-   **T5**：在线性场上使用 $1$ 阶基，在边界附近采用最小支承。这测试了方法的稳健性。预期 $\\varepsilon_{\\max} \\approx 0$，可能由于 $\\mathbf{M}(\\mathbf{x})$ 的条件数较差而比 T3/T4 略大。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs the Element-Free Galerkin (EFG) patch tests \n    using Moving Least Squares (MLS) approximation.\n    \"\"\"\n\n    # --- Problem Setup ---\n    Nx = 11\n    Ny = 11\n    h = 1.0 / (Nx - 1)\n    \n    # Generate node coordinates\n    x_coords = np.linspace(0.0, 1.0, Nx)\n    y_coords = np.linspace(0.0, 1.0, Ny)\n    nodes = np.array(np.meshgrid(x_coords, y_coords)).T.reshape(-1, 2)\n\n    # --- Weight Function ---\n    def weight_function(q):\n        \"\"\"\n        C1 continuous quartic spline weight function.\n        w(q) = 1 - 6q^2 + 8q^3 - 3q^4 for 0 = q = 1.\n        \"\"\"\n        if 0.0 = q = 1.0:\n            return 1.0 - 6.0*q**2 + 8.0*q**3 - 3.0*q**4\n        return 0.0\n\n    # --- MLS Core Logic ---\n    def compute_mls_error(nodes, basis_degree, support_factor, u_field_func, eval_points):\n        \"\"\"\n        Computes the maximum error of the MLS approximation for a given setup.\n        \"\"\"\n        s = support_factor\n        d = s * h\n        \n        # Get nodal values from the analytical field\n        u_nodal = np.array([u_field_func(node) for node in nodes])\n        \n        max_error = 0.0\n        \n        for x_eval in eval_points:\n            # Find nodes within the support domain of x_eval\n            support_nodes_indices = []\n            distances = []\n            for i, node in enumerate(nodes):\n                dist = np.linalg.norm(x_eval - node)\n                if dist = d:\n                    support_nodes_indices.append(i)\n                    distances.append(dist)\n\n            if not support_nodes_indices:\n                # Should not happen with the given parameters\n                # If it does, the approximation is zero, error is the field value\n                u_true = u_field_func(x_eval)\n                error = np.max(np.abs(u_true))\n                max_error = max(max_error, error)\n                continue\n\n            # Basis setup\n            if basis_degree == 0:\n                m = 1\n                get_p = lambda x: np.array([1.0])\n            elif basis_degree == 1:\n                m = 3\n                get_p = lambda x: np.array([1.0, x[0], x[1]])\n            else:\n                raise ValueError(\"Unsupported basis degree\")\n\n            if len(support_nodes_indices)  m:\n                # Insufficient nodes for a stable approximation\n                # This indicates a potential issue, e.g., in T5\n                u_true = u_field_func(x_eval)\n                # Approximation is ill-defined, cannot compute error robustly.\n                # A robust implementation might switch to a lower order basis.\n                # Here we assume the error is large or skip. Let's compute best effort.\n                u_h = np.zeros(2) # Fallback\n                error = np.max(np.abs(u_h - u_true))\n                max_error = max(max_error, error)\n                continue\n\n            # Construct Moment Matrix M(x)\n            M = np.zeros((m, m))\n            support_nodes = nodes[support_nodes_indices]\n            \n            w_vals = [weight_function(dist / d) for dist in distances]\n\n            for i in range(len(support_nodes)):\n                node = support_nodes[i]\n                p_i = get_p(node)\n                w_i = w_vals[i]\n                M += w_i * np.outer(p_i, p_i)\n\n            # Invert Moment Matrix\n            try:\n                M_inv = np.linalg.inv(M)\n            except np.linalg.LinAlgError:\n                # Singular matrix, approximation fails\n                u_true = u_field_func(x_eval)\n                u_h = np.zeros(2) # Fallback\n                error = np.max(np.abs(u_h - u_true))\n                max_error = max(max_error, error)\n                continue\n\n            # Calculate shape functions and approximated field u_h(x)\n            p_eval = get_p(x_eval)\n            u_h = np.zeros(2)\n            \n            for i in range(len(support_nodes)):\n                node_idx = support_nodes_indices[i]\n                node = support_nodes[i]\n                p_i = get_p(node)\n                w_i = w_vals[i]\n                \n                # Shape function value phi_i(x_eval)\n                phi_i = p_eval.T @ M_inv @ p_i * w_i\n                \n                u_h += phi_i * u_nodal[node_idx]\n\n            # Calculate error at the evaluation point\n            u_true = u_field_func(x_eval)\n            error = np.max(np.abs(u_h - u_true))\n            max_error = max(max_error, error)\n            \n        return max_error\n\n    # --- Test Cases Definition ---\n    eval_grid_coords = [0.1, 0.3, 0.5, 0.7, 0.9]\n    eval_set_T1_T4 = np.array(np.meshgrid(eval_grid_coords, eval_grid_coords)).T.reshape(-1, 2)\n    \n    # T1: Rigid Translation\n    c = np.array([0.3, -0.2])\n    u_trans = lambda x: c\n\n    # T2/T3: Rigid Rotation\n    theta = 0.1\n    u_rot = lambda x: theta * np.array([-x[1], x[0]])\n\n    # T4/T5: Uniform Strain\n    E = np.array([[0.01, 0.02], [0.00, -0.005]])\n    u_strain = lambda x: E @ x\n\n    test_cases = [\n        {'name': 'T1', 'basis_degree': 0, 'support_factor': 2.5, 'u_field_func': u_trans, 'eval_points': eval_set_T1_T4},\n        {'name': 'T2', 'basis_degree': 0, 'support_factor': 2.5, 'u_field_func': u_rot, 'eval_points': eval_set_T1_T4},\n        {'name': 'T3', 'basis_degree': 1, 'support_factor': 2.5, 'u_field_func': u_rot, 'eval_points': eval_set_T1_T4},\n        {'name': 'T4', 'basis_degree': 1, 'support_factor': 2.5, 'u_field_func': u_strain, 'eval_points': eval_set_T1_T4},\n        {'name': 'T5', 'basis_degree': 1, 'support_factor': 1.05, 'u_field_func': u_strain, 'eval_points': np.array([[0.02, 0.02]])},\n    ]\n\n    results = []\n    for case in test_cases:\n        error = compute_mls_error(nodes, case['basis_degree'], case['support_factor'], case['u_field_func'], case['eval_points'])\n        results.append(error)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3581266"}, {"introduction": "在验证了形函数的基本性质之后，下一步是构建一个完整的无网格伽辽金求解器并评估其精度。本练习[@problem_id:3581216]采用“精确解制造法”（Method of Manufactured Solutions）来求解一个二维边界值问题。通过计算数值解的收敛速度，并与理论预测值进行比较，你可以系统地验证从刚度矩阵组装、边界条件施加到误差计算等整个实现过程的正确性。", "problem": "考虑计算固体力学中的一个反平面剪切模型问题，其定义在单位正方形域 $\\Omega = [0,1]^2$ 上。设平面外位移场为 $u(x,y)$，由静态平衡导出的线性椭圆问题的弱形式控制，其中剪切模量为常数 $\\mu = 1$：求解 $u \\in H^1(\\Omega)$，使得对于所有检验函数 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f \\, v \\, d\\Omega,\n$$\n满足在 $\\partial \\Omega$ 上的本质边界条件 $u = u_{\\text{exact}}$。使用“制造解方法”(Method of Manufactured Solutions)，其中\n$$\nu_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(\\pi y), \\quad f(x,y) = -\\Delta u_{\\text{exact}}(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y).\n$$\n使用无网格伽辽金法 (meshfree Galerkin method) 对此问题进行离散化，该方法采用可实现线性多项式再生的再生核粒子法 (RKPM) 形函数。使用一个具有支撑半径 $h_s$ 的径向对称紧支集权函数 $w(q)$，其中 $q = r/h_s$，对于位于 $\\boldsymbol{x}_i$ 的粒子，$r = \\|\\boldsymbol{x} - \\boldsymbol{x}_i\\|$。设权函数为 $C^2$ 四次样条函数\n$$\nw(q) = \\begin{cases}\n(1-q)^4(1+4q),  0 \\le q  1,\\\\\n0,  q \\ge 1,\n\\end{cases}\n$$\n其导数为\n$$\n\\frac{dw}{dq} = -20\\,q\\,(1-q)^3 \\quad \\text{for } 0 \\le q  1.\n$$\n使用线性多项式基 $p(\\boldsymbol{x}) = [1, x, y]^T$ 构造 RKPM 形函数。在任意求积点 $\\boldsymbol{x}$，定义矩量矩阵\n$$\nM(\\boldsymbol{x}) = \\sum_{i} w\\left(\\frac{\\|\\boldsymbol{x} - \\boldsymbol{x}_i\\|}{h_s}\\right) \\, p(\\boldsymbol{x}_i)\\, p(\\boldsymbol{x}_i)^T,\n$$\n以及修正后的形函数\n$$\nN_i(\\boldsymbol{x}) = p(\\boldsymbol{x})^T\\, M(\\boldsymbol{x})^{-1}\\, p(\\boldsymbol{x}_i)\\, w\\left(\\frac{\\|\\boldsymbol{x} - \\boldsymbol{x}_i\\|}{h_s}\\right),\n$$\n及其空间梯度 $\\nabla N_i(\\boldsymbol{x})$，通过对上述表达式求导计算得出，包括矩量矩阵 $M(\\boldsymbol{x})$ 的导数。\n\n在覆盖 $\\Omega$ 的双线性单元结构化背景网格上，使用背景高斯求积法 (background Gaussian quadrature) 组装对称正定刚度矩阵和载荷向量。通过直接修改线性系统（将行和列替换为单位行，并将载荷设置为精确边界值）来强施加本质边界条件。求解离散系统以获得未知数的节点向量，并使用背景单元上的数值求积来评估以下误差度量：\n$$\n\\|e\\|_{L^2(\\Omega)} = \\left( \\int_{\\Omega} \\left(u_h - u_{\\text{exact}}\\right)^2 \\, d\\Omega \\right)^{1/2}, \\qquad\n|e|_{H^1(\\Omega)} = \\left( \\int_{\\Omega} \\|\\nabla u_h - \\nabla u_{\\text{exact}}\\|^2 \\, d\\Omega \\right)^{1/2}.\n$$\n\n使用准均匀分布的粒子，这些粒子放置在包含边界的笛卡尔晶格上。令背景积分网格与粒子网格单元重合。对于每个坐标方向有 $n$ 个粒子的粒子间距 $h = 1/(n-1)$，将支撑半径设置为 $h_s = \\alpha h$，其中 $\\alpha = 2.5$。每个单元使用张量积高斯求积，每单元 $2 \\times 2$ 个点。对于邻域查询，使用高效的搜索算法以包含支撑半径内的所有粒子。\n\n对于此椭圆问题，具有线性多项式再生的 RKPM 的理论预期是，在满足足够光滑度和稳定积分的条件下，$L^2$ 范数误差的阶数为 $O(h^2)$，$H^1$ 半范数误差的阶数为 $O(h)$。\n\n您的任务是实现上述方法并进行数值验证研究。使用以下粒子分辨率测试套件：\n- Case A: $n = 9$,\n- Case B: $n = 17$,\n- Case C: $n = 33$.\n\n对于每个连续对 $(A,B)$ 和 $(B,C)$，计算观测到的收敛率\n$$\nr_{L^2} = \\frac{\\log\\left(\\|e\\|_{L^2,h_1} / \\|e\\|_{L^2,h_2}\\right)}{\\log\\left(h_1/h_2\\right)}, \\qquad\nr_{H^1} = \\frac{\\log\\left(|e|_{H^1,h_1} / |e|_{H^1,h_2}\\right)}{\\log\\left(h_1/h_2\\right)},\n$$\n其中 $h_1$ 和 $h_2$ 分别是粗分辨率和细分辨率的粒子间距。报告 $(A,B)$ 和 $(B,C)$ 的四个收敛率。此外，报告两个布尔指标，说明观测到的两个 $L^2$ 收敛率是否都至少为 $1.7$，以及观测到的两个 $H^1$ 收敛率是否都至少为 $0.85$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其结果按以下顺序排列：\n- $r_{L^2}^{A\\to B}$,\n- $r_{H^1}^{A\\to B}$,\n- $r_{L^2}^{B\\to C}$,\n- $r_{H^1}^{B\\to C}$,\n- $L^2$ 验证的布尔值,\n- $H^1$ 验证的布尔值。\n\n最终输出中的所有浮点结果必须四舍五入到三位小数。无需用户输入；所有常量和参数均按上文所述固定。输出必须是严格的一行，格式如：$[1.950,0.990,1.980,1.010,True,True]$。", "solution": "用户提供的问题是针对无网格伽辽金法的一个适定的验证任务。它具有科学依据，内容自洽，且算法细节详尽。因此，该问题被视为有效。我们继续进行求解。\n\n该问题要求对一个反平面剪切问题进行数值求解，该问题模拟了单位正方形域 $\\Omega = [0,1]^2$ 上的平面外位移 $u(x,y)$。其控制物理场由一个线性椭圆偏微分方程描述，具体来说是一个带有给定源项的泊松方程。问题以其弱形式呈现，这是有限元法和无网格伽辽金法的标准出发点。\n\n弱形式表述为：求解满足本质边界条件的 $u \\in H^1(\\Omega)$，使得对于所有检验函数 $v \\in H_0^1(\\Omega)$：\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\Omega = \\int_{\\Omega} f \\, v \\, d\\Omega\n$$\n在此，剪切模量为 $\\mu=1$，源项 $f(x,y)$ 是使用“制造解方法”(Method of Manufactured Solutions) 从一个选定的精确解 $u_{\\text{exact}}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ 导出的。这种方法确保了已知解的存在，从而可以精确地量化数值误差。源项为 $f = -\\Delta u_{\\text{exact}} = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$。通过在边界 $\\partial \\Omega$ 上设置 $u = u_{\\text{exact}}$ 来强施加本质边界条件。\n\n求解域被一组粒子（节点）离散化，位移场 $u(x,y)$ 由函数 $u_h(x,y)$ 近似：\n$$\nu(\\boldsymbol{x}) \\approx u_h(\\boldsymbol{x}) = \\sum_{i=1}^{N} d_i N_i(\\boldsymbol{x})\n$$\n其中 $N$ 是粒子总数，$d_i$ 是未知的节点位移系数，$N_i(\\boldsymbol{x})$ 是与粒子 $i$ 关联的无网格形函数。问题指定使用再生核粒子法 (RKPM) 来构造这些形函数。\n\n为确保线性多项式再生，即基函数能够精确表示任何线性函数的能力，使用了线性多项式基 $\\boldsymbol{p}(\\boldsymbol{x}) = [1, x, y]^T$。在点 $\\boldsymbol{x}$ 处，粒子 $i$ 的 RKPM 形函数由下式给出：\n$$\nN_i(\\boldsymbol{x}) = C(\\boldsymbol{x};\\boldsymbol{x}-\\boldsymbol{x}_i) w\\left(\\frac{\\|\\boldsymbol{x} - \\boldsymbol{x}_i\\|}{h_s}\\right) = \\boldsymbol{p}(\\boldsymbol{x})^T \\boldsymbol{M}(\\boldsymbol{x})^{-1} \\boldsymbol{p}(\\boldsymbol{x}_i) w_i(\\boldsymbol{x})\n$$\n其中 $w_i(\\boldsymbol{x}) = w(\\|\\boldsymbol{x} - \\boldsymbol{x}_i\\|/h_s)$ 是指定的具有紧支集半径 $h_s$ 的 $C^2$ 四次样条权函数。矩阵 $\\boldsymbol{M}(\\boldsymbol{x})$ 是矩量矩阵，定义为：\n$$\n\\boldsymbol{M}(\\boldsymbol{x}) = \\sum_{j=1}^{N} w_j(\\boldsymbol{x}) \\boldsymbol{p}(\\boldsymbol{x}_j) \\boldsymbol{p}(\\boldsymbol{x}_j)^T\n$$\n求和遍及所有其支撑域包含点 $\\boldsymbol{x}$ 的粒子 $j$。\n\n将近似解 $u_h$ 代入弱形式，并选择形函数本身作为检验函数 ($v = N_i$)，我们得到离散线性方程组 $\\boldsymbol{K}\\boldsymbol{d} = \\boldsymbol{F}$，其中：\n- 刚度矩阵 $\\boldsymbol{K}$ 的元素为 $K_{ij} = \\int_{\\Omega} \\nabla N_i(\\boldsymbol{x}) \\cdot \\nabla N_j(\\boldsymbol{x}) \\, d\\Omega$。\n- 力向量 $\\boldsymbol{F}$ 的元素为 $F_i = \\int_{\\Omega} f(\\boldsymbol{x}) N_i(\\boldsymbol{x}) \\, d\\Omega$。\n- 向量 $\\boldsymbol{d}$ 包含未知的节点系数 $d_i$。\n\n刚度矩阵需要形函数的空间梯度 $\\nabla N_i(\\boldsymbol{x})$。它们是通过对 $N_i(\\boldsymbol{x})$ 的表达式应用乘法法则推导出来的。对空间坐标 $x_k$ 求导可得：\n$$\n\\frac{\\partial N_i}{\\partial x_k} = \\left(\\frac{\\partial \\boldsymbol{p}^T}{\\partial x_k}\\right) \\boldsymbol{M}^{-1} \\boldsymbol{p}_i w_i + \\boldsymbol{p}^T \\left(\\frac{\\partial \\boldsymbol{M}^{-1}}{\\partial x_k}\\right) \\boldsymbol{p}_i w_i + \\boldsymbol{p}^T \\boldsymbol{M}^{-1} \\boldsymbol{p}_i \\left(\\frac{\\partial w_i}{\\partial x_k}\\right)\n$$\n该表达式涉及矩量矩阵逆的导数，$\\partial \\boldsymbol{M}^{-1}/\\partial x_k = -\\boldsymbol{M}^{-1} (\\partial \\boldsymbol{M}/\\partial x_k) \\boldsymbol{M}^{-1}$，而这又需要矩量矩阵的导数 $\\partial \\boldsymbol{M}/\\partial x_k$。这依赖于链式法则和所提供的权函数导数 $dw/dq$。\n\n$\\boldsymbol{K}$ 和 $\\boldsymbol{F}$ 的积分是使用双线性单元的背景网格进行数值计算的，该网格与粒子网格形成的单元重合。每个单元内使用 $2 \\times 2$ 的高斯求积方案。\n\n在 $\\partial\\Omega$ 上的本质边界条件 $u=u_{\\text{exact}}$ 被强施加。问题陈述了“直接修改线性系统（将行和列替换为单位行，并将载荷设置为精确边界值）”。采用了该方法的一种稳健且标准的实现，即“提升”(lifting) 法。对于每个边界节点 $I$，其已知值 $u_I = u_{\\text{exact}}(\\boldsymbol{x}_I)$ 被用来修改所有内部节点 $J$ 的力向量：$F_J \\leftarrow F_J - K_{JI} u_I$。随后，将 $\\boldsymbol{K}$ 中对应于边界节点的行和列清零，对角线元素设为 $1$，并将 $\\boldsymbol{F}$ 中相应的元素设为已知的边界值 $u_I$。此过程在保持系统可解的同时正确地施加了边界条件。\n\n在求解系统 $\\boldsymbol{K}\\boldsymbol{d} = \\boldsymbol{F}$ 得到系数向量 $\\boldsymbol{d}$ 后，数值解 $u_h$ 就已知了。通过在求解域上对数值解与精确解及其梯度之间的差的平方进行数值积分来量化误差，从而得到 $L^2$ 范数误差 $\\|e\\|_{L^2}$ 和 $H^1$ 半范数误差 $|e|_{H^1}$。\n\n使用粒子分辨率 $n=9, 17, 33$ 进行收敛性研究。相应的粒子间距为 $h_1=1/8$, $h_2=1/16$, 和 $h_3=1/32$。连续间距的比率为 $h_k/h_{k+1}=2$。对于一个误差度量 $E$，观测到的收敛率计算为 $r = \\log(E_1 / E_2) / \\log(h_1 / h_2)$。在我们的情况下，这简化为 $r = \\log_2(E_1/E_2)$。线性再生的理论收敛率对于 $L^2$ 误差是 $O(h^2)$，对于 $H^1$ 误差是 $O(h)$。数值研究验证了该实现是否达到了接近这些理论值的收敛率，并以指定的阈值 $1.7$ 和 $0.85$ 为准。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Implements the RKPM meshfree method for a 2D anti-plane shear problem\n    and performs a numerical verification study.\n    \"\"\"\n    \n    # Test cases defined in the problem statement\n    test_cases = [9, 17, 33]\n\n    # --------------- Helper Functions ---------------\n\n    pi = np.pi\n\n    def u_exact(x, y):\n        return np.sin(pi * x) * np.sin(pi * y)\n\n    def grad_u_exact(x, y):\n        return np.array([\n            pi * np.cos(pi * x) * np.sin(pi * y),\n            pi * np.sin(pi * x) * np.cos(pi * y)\n        ])\n\n    def f_source(x, y):\n        return 2.0 * pi**2 * np.sin(pi * x) * np.sin(pi * y)\n\n    def weight_func(q):\n        val = np.zeros_like(q)\n        mask = (q >= 0)  (q  1)\n        q_masked = q[mask]\n        val[mask] = (1.0 - q_masked)**4 * (1.0 + 4.0 * q_masked)\n        return val\n\n    def d_weight_func_dq(q):\n        val = np.zeros_like(q)\n        mask = (q >= 0)  (q  1)\n        q_masked = q[mask]\n        val[mask] = -20.0 * q_masked * (1.0 - q_masked)**3\n        return val\n\n    # --------------- Main Calculation Loop ---------------\n    \n    errors_all_cases = []\n    \n    for n in test_cases:\n        # --- Setup for the current resolution ---\n        h = 1.0 / (n - 1)\n        alpha = 2.5\n        hs = alpha * h\n        num_nodes = n * n\n        \n        # Particle generation (row-major order)\n        x_coords = np.linspace(0.0, 1.0, n)\n        y_coords = np.linspace(0.0, 1.0, n)\n        X, Y = np.meshgrid(x_coords, y_coords, indexing='ij')\n        particles = np.stack([X.ravel(), Y.ravel()], axis=-1)\n\n        # Integration setup (2x2 Gauss quadrature)\n        gp_loc = 1.0 / np.sqrt(3.0)\n        gauss_points_parent = [(-gp_loc, -gp_loc), (gp_loc, -gp_loc), (-gp_loc, gp_loc), (gp_loc, gp_loc)]\n        gauss_weights_parent = [1.0, 1.0, 1.0, 1.0]\n        \n        # Initialize sparse stiffness matrix and load vector\n        K = lil_matrix((num_nodes, num_nodes))\n        F = np.zeros(num_nodes)\n\n        # --- Assembly Loop ---\n        num_cells_per_dim = n - 1\n        cell_size = h\n        \n        for i_cell in range(num_cells_per_dim):\n            for j_cell in range(num_cells_per_dim):\n                x0 = i_cell * cell_size\n                y0 = j_cell * cell_size\n                \n                for gp_idx, (gp_xi, gp_eta) in enumerate(gauss_points_parent):\n                    xq = np.array([\n                        x0 + (gp_xi + 1.0) * cell_size / 2.0,\n                        y0 + (gp_eta + 1.0) * cell_size / 2.0\n                    ])\n                    w_q = gauss_weights_parent[gp_idx] * (cell_size / 2.0)**2\n\n                    # --- RKPM Shape Function Evaluation at Quadrature Point xq ---\n                    dists_vec = xq - particles\n                    dists = np.linalg.norm(dists_vec, axis=1)\n                    neighbor_indices = np.where(dists  hs)[0]\n\n                    if len(neighbor_indices)  3:\n                        continue\n                        \n                    q_vals = dists[neighbor_indices] / hs\n                    w_vals = weight_func(q_vals)\n                    dw_dq_vals = d_weight_func_dq(q_vals)\n                    \n                    p_xq = np.array([1.0, xq[0], xq[1]])\n                    \n                    M = np.zeros((3, 3))\n                    dM_dx = np.zeros((3, 3))\n                    dM_dy = np.zeros((3, 3))\n                    \n                    for k_idx, node_idx in enumerate(neighbor_indices):\n                        p_i = np.array([1.0, particles[node_idx, 0], particles[node_idx, 1]])\n                        p_i_outer = np.outer(p_i, p_i)\n                        M += w_vals[k_idx] * p_i_outer\n                        \n                        r_i = dists[node_idx]\n                        if r_i > 1e-12:\n                            grad_term = dw_dq_vals[k_idx] / (hs * r_i)\n                            dw_dx_i = grad_term * dists_vec[node_idx, 0]\n                            dw_dy_i = grad_term * dists_vec[node_idx, 1]\n                        else:\n                            dw_dx_i = dw_dy_i = 0.0\n                        \n                        dM_dx += dw_dx_i * p_i_outer\n                        dM_dy += dw_dy_i * p_i_outer\n\n                    try:\n                        M_inv = np.linalg.inv(M)\n                    except np.linalg.LinAlgError:\n                        continue\n                    \n                    dM_inv_dx = -M_inv @ dM_dx @ M_inv\n                    dM_inv_dy = -M_inv @ dM_dy @ M_inv\n                    \n                    dp_dx = np.array([0.0, 1.0, 0.0])\n                    dp_dy = np.array([0.0, 0.0, 1.0])\n                    \n                    shape_funcs = []\n                    shape_func_grads = []\n                    \n                    for k_idx, node_idx in enumerate(neighbor_indices):\n                        p_i = np.array([1.0, particles[node_idx, 0], particles[node_idx, 1]])\n                        w_i_val = w_vals[k_idx]\n                        \n                        r_i = dists[node_idx]\n                        if r_i > 1e-12:\n                            grad_term = dw_dq_vals[k_idx] / (hs * r_i)\n                            dw_dx_i = grad_term * dists_vec[node_idx, 0]\n                            dw_dy_i = grad_term * dists_vec[node_idx, 1]\n                        else:\n                            dw_dx_i = dw_dy_i = 0.0\n                        \n                        c_vec = M_inv @ p_i\n                        \n                        N_val = (p_xq.T @ c_vec) * w_i_val\n                        \n                        dN_dx = (dp_dx.T @ c_vec) * w_i_val \\\n                                + (p_xq.T @ (dM_inv_dx @ p_i)) * w_i_val \\\n                                + (p_xq.T @ c_vec) * dw_dx_i\n                                \n                        dN_dy = (dp_dy.T @ c_vec) * w_i_val \\\n                                + (p_xq.T @ (dM_inv_dy @ p_i)) * w_i_val \\\n                                + (p_xq.T @ c_vec) * dw_dy_i\n                        \n                        shape_funcs.append(N_val)\n                        shape_func_grads.append(np.array([dN_dx, dN_dy]))\n\n                    # --- Add contributions to K and F ---\n                    f_val = f_source(xq[0], xq[1])\n                    for k_outer, idx_outer in enumerate(neighbor_indices):\n                        F[idx_outer] += shape_funcs[k_outer] * f_val * w_q\n                        for k_inner, idx_inner in enumerate(neighbor_indices):\n                            grad_dot = np.dot(shape_func_grads[k_outer], shape_func_grads[k_inner])\n                            K[idx_outer, idx_inner] += grad_dot * w_q\n\n        # --- Boundary Conditions (Lifting Method) ---\n        boundary_nodes = [i for i in range(num_nodes) if np.isclose(particles[i,0], 0.0) or np.isclose(particles[i,0], 1.0) or np.isclose(particles[i,1], 0.0) or np.isclose(particles[i,1], 1.0)]\n        interior_nodes = list(set(range(num_nodes)) - set(boundary_nodes))\n        \n        K_csr = K.tocsr()\n        for i in interior_nodes:\n            for j in boundary_nodes:\n                u_bc = u_exact(particles[j, 0], particles[j, 1])\n                F[i] -= K_csr[i, j] * u_bc\n\n        for i in boundary_nodes:\n            K[i, :] = 0\n            K[:, i] = 0\n            K[i, i] = 1.0\n            F[i] = u_exact(particles[i, 0], particles[i, 1])\n\n        # --- Solve Linear System ---\n        d = spsolve(K.tocsr(), F)\n        \n        # --- Error Calculation ---\n        l2_error_sq = 0.0\n        h1_error_sq = 0.0\n        # Re-use integration loop for error calculation\n        for i_cell in range(num_cells_per_dim):\n             for j_cell in range(num_cells_per_dim):\n                x0, y0 = i_cell * cell_size, j_cell * cell_size\n                for gp_idx, (gp_xi, gp_eta) in enumerate(gauss_points_parent):\n                    xq = np.array([x0 + (gp_xi + 1.0) * cell_size / 2.0, y0 + (gp_eta + 1.0) * cell_size / 2.0])\n                    w_q = gauss_weights_parent[gp_idx] * (cell_size / 2.0)**2\n\n                    # Minimal recalculation just for the needed values\n                    dists_vec = xq - particles\n                    dists = np.linalg.norm(dists_vec, axis=1)\n                    neighbor_indices = np.where(dists  hs)[0]\n                    if len(neighbor_indices)  3: continue\n                    \n                    # This section is a repeat of the shape function logic from assembly\n                    u_h = 0.0\n                    grad_u_h = np.zeros(2)\n                    \n                    q_vals = dists[neighbor_indices] / hs\n                    w_vals = weight_func(q_vals)\n                    dw_dq_vals = d_weight_func_dq(q_vals)\n                    p_xq = np.array([1.0, xq[0], xq[1]])\n                    M = np.zeros((3, 3)); dM_dx = np.zeros((3, 3)); dM_dy = np.zeros((3, 3))\n                    for k_idx, node_idx in enumerate(neighbor_indices):\n                        p_i = np.array([1.0, particles[node_idx, 0], particles[node_idx, 1]])\n                        M += w_vals[k_idx] * np.outer(p_i, p_i)\n                        r_i = dists[node_idx]\n                        if r_i > 1e-12:\n                            grad_term = dw_dq_vals[k_idx] / (hs * r_i)\n                            dM_dx += (grad_term * dists_vec[node_idx, 0]) * np.outer(p_i, p_i)\n                            dM_dy += (grad_term * dists_vec[node_idx, 1]) * np.outer(p_i, p_i)\n                    try: M_inv = np.linalg.inv(M)\n                    except np.linalg.LinAlgError: continue\n                    dM_inv_dx = -M_inv @ dM_dx @ M_inv; dM_inv_dy = -M_inv @ dM_dy @ M_inv\n                    dp_dx = np.array([0., 1., 0.]); dp_dy = np.array([0., 0., 1.])\n                    \n                    for k_idx, node_idx in enumerate(neighbor_indices):\n                      p_i = np.array([1.0, particles[node_idx, 0], particles[node_idx, 1]])\n                      w_i_val = w_vals[k_idx]\n                      r_i = dists[node_idx]\n                      if r_i > 1e-12:\n                          grad_term = dw_dq_vals[k_idx] / (hs * r_i); dw_dx_i = grad_term * dists_vec[node_idx, 0]; dw_dy_i = grad_term * dists_vec[node_idx, 1]\n                      else: dw_dx_i = dw_dy_i = 0.0\n                      c_vec = M_inv @ p_i\n                      N_val = (p_xq.T @ c_vec) * w_i_val\n                      dN_dx = (dp_dx.T @ c_vec) * w_i_val + (p_xq.T @ (dM_inv_dx @ p_i)) * w_i_val + (p_xq.T @ c_vec) * dw_dx_i\n                      dN_dy = (dp_dy.T @ c_vec) * w_i_val + (p_xq.T @ (dM_inv_dy @ p_i)) * w_i_val + (p_xq.T @ c_vec) * dw_dy_i\n                      u_h += d[node_idx] * N_val\n                      grad_u_h += d[node_idx] * np.array([dN_dx, dN_dy])\n\n                    # Add squared error contributions\n                    l2_error_sq += (u_h - u_exact(xq[0], xq[1]))**2 * w_q\n                    h1_error_sq += np.sum((grad_u_h - grad_u_exact(xq[0], xq[1]))**2) * w_q\n        \n        errors_all_cases.append((np.sqrt(l2_error_sq), np.sqrt(h1_error_sq)))\n\n    # --- Post-processing: Convergence Rates  Verification ---\n    e_L2_A, e_H1_A = errors_all_cases[0]\n    e_L2_B, e_H1_B = errors_all_cases[1]\n    e_L2_C, e_H1_C = errors_all_cases[2]\n\n    h_A = 1.0 / (test_cases[0] - 1)\n    h_B = 1.0 / (test_cases[1] - 1)\n    h_C = 1.0 / (test_cases[2] - 1)\n\n    r_L2_AB = np.log(e_L2_A / e_L2_B) / np.log(h_A / h_B)\n    r_H1_AB = np.log(e_H1_A / e_H1_B) / np.log(h_A / h_B)\n\n    r_L2_BC = np.log(e_L2_B / e_L2_C) / np.log(h_B / h_C)\n    r_H1_BC = np.log(e_H1_B / e_H1_C) / np.log(h_B / h_C)\n    \n    bool_L2 = r_L2_AB >= 1.7 and r_L2_BC >= 1.7\n    bool_H1 = r_H1_AB >= 0.85 and r_H1_BC >= 0.85\n    \n    # --- Final Output Formatting ---\n    results_str = [\n        f\"{r_L2_AB:.3f}\",\n        f\"{r_H1_AB:.3f}\",\n        f\"{r_L2_BC:.3f}\",\n        f\"{r_H1_BC:.3f}\",\n        str(bool_L2),\n        str(bool_H1)\n    ]\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3581216"}, {"introduction": "无网格方法在处理复杂几何时可能面临挑战，例如带有凹角的非凸域。本练习探讨了在这种情况下，单位分解（partition of unity）和线性再现等基本性质如何被破坏，并引入了可见性约束（visibility constraint）作为一种补救措施。通过诊断这些失效模式[@problem_id:3581244]，你将能培养对方法鲁棒性的批判性思维，并了解如何处理几何奇异性问题。", "problem": "考虑一个二维L形域，由点集 $\\mathcal{D} = \\{(x,y) \\in \\mathbb{R}^2 \\mid -1 \\le x \\le 1, -1 \\le y \\le 1, x \\le 0 \\text{ or } y \\le 0\\}$ 定义，该域在 $(0,0)$ 处有一个凹角。节点被放置在 $[-1,1] \\times [-1,1]$ 上的间距为 $h$ 的均匀笛卡尔网格上，并被限制在 $\\mathcal{D}$ 内。对于给定的评估点 $\\mathbf{x} \\in \\mathcal{D}$，使用线性多项式基 $p(\\mathbf{X}) = [1, X, Y]^T$ 定义移动最小二乘 (MLS) 近似。设紧支承权函数为 $w(r) = (1 - r)^4(4r + 1)$（对于 $0 \\le r \\le 1$）且在其他情况下 $w(r) = 0$，其中 $r = \\|\\mathbf{x} - \\mathbf{X}_I\\|/R$ 是归一化距离，其支承半径为 $R$，$\\mathbf{X}_I$ 表示节点 $I$ 的坐标。MLS矩量矩阵定义为\n$$\n\\mathbf{A}(\\mathbf{x}) = \\sum_{I} w_I(\\mathbf{x})\\, p(\\mathbf{X}_I)\\, p(\\mathbf{X}_I)^T,\n$$\n以及相应的MLS形函数为\n$$\n\\phi_I(\\mathbf{x}) = p(\\mathbf{x})^T \\mathbf{A}(\\mathbf{x})^{-1} w_I(\\mathbf{x}) p(\\mathbf{X}_I).\n$$\n当施加可见性约束时，如果连接 $\\mathbf{x}$ 和 $\\mathbf{X}_I$ 的直线段完全位于 $\\mathcal{D}$ 内，则节点 $I$ 被认为是从 $\\mathbf{x}$ 可见的；否则，对该节点 $I$ 设置 $w_I(\\mathbf{x}) = 0$。假设 $p(\\mathbf{x}) = [1, x, y]^T$，其中 $(x,y)$ 是 $\\mathbf{x}$ 的坐标。\n\n您的任务是实现一个程序，对于每个提供的测试用例，在指定的支承和可见性条件下构造MLS形函数 $\\phi_I(\\mathbf{x})$，然后评估：\n\n1. 单位分解误差\n$$\ne_{\\mathrm{PU}}(\\mathbf{x}) = \\left| \\sum_I \\phi_I(\\mathbf{x}) - 1 \\right|.\n$$\n\n2. 线性再生误差\n$$\ne_{\\mathrm{LIN}}(\\mathbf{x}) = \\left\\| \\sum_I \\phi_I(\\mathbf{x})\\, \\mathbf{X}_I - \\mathbf{x} \\right\\|_2.\n$$\n\n使用以下诊断逻辑对故障模式进行分类：\n- 返回一个由以下方式定义的诊断整数 $d$：\n  - $d = 0$，如果两项测试均在指定容差内通过。\n  - $d = 1$，如果支承不足，定义为贡献节点（施加可见性后 $w_I(\\mathbf{x})  0$ 的节点）少于3个。\n  - $d = 2$，如果MLS矩量矩阵 $\\mathbf{A}(\\mathbf{x})$ 是奇异或病态的（使用 $10^{12}$ 的条件数阈值）。\n  - $d = 3$，如果在支承充足且矩量矩阵良态的情况下测试失败，表明失败归因于可见性约束或几何分布。\n\n对于数值容差，对 $e_{\\mathrm{PU}}$ 和 $e_{\\mathrm{LIN}}$ 均使用 $10^{-8}$。不涉及物理单位；将所有量视为无量纲。\n\n实现以下测试套件，其中每个案例以 $(\\mathbf{x}, R, h, \\mathrm{visibility})$ 的形式给出：\n- 测试用例 1: $\\mathbf{x} = (-0.5,-0.5)$, $R = 0.45$, $h = 0.2$, $\\mathrm{visibility} = \\text{False}$。\n- 测试用例 2: $\\mathbf{x} = (-0.05,-0.05)$, $R = 0.15$, $h = 0.2$, $\\mathrm{visibility} = \\text{False}$。\n- 测试用例 3: $\\mathbf{x} = (-0.05,-0.05)$, $R = 0.35$, $h = 0.2$, $\\mathrm{visibility} = \\text{True}$。\n- 测试用例 4: $\\mathbf{x} = (0.2,-0.2)$, $R = 0.3$, $h = 0.2$, $\\mathrm{visibility} = \\text{True}$。\n- 测试用例 5: $\\mathbf{x} = (-0.05,-0.05)$, $R = 0.25$, $h = 0.2$, $\\mathrm{visibility} = \\text{True}$。\n\n对于每个测试用例，计算布尔指标\n$$\nb_{\\mathrm{PU}} = \\left( e_{\\mathrm{PU}} \\le 10^{-8} \\right), \\quad b_{\\mathrm{LIN}} = \\left( e_{\\mathrm{LIN}} \\le 10^{-8} \\right),\n$$\n以及上文定义的诊断整数 $d$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，形式为 $[b_{\\mathrm{PU}}, b_{\\mathrm{LIN}}, d]$。例如：\n$$\n[ [\\text{True}, \\text{True}, 0], [\\text{False}, \\text{False}, 1], \\ldots ].\n$$", "solution": "该问题提出了一个计算力学中定义明确的练习，特别关注非凸域中移动最小二乘(MLS)形函数的性质。所有给出的定义，包括L形域 $\\mathcal{D}$、多项式基 $p(\\mathbf{X})$、权函数 $w(r)$、矩量矩阵 $\\mathbf{A}(\\mathbf{x})$、形函数 $\\phi_I(\\mathbf{x})$ 以及误差度量 $e_{\\mathrm{PU}}$ 和 $e_{\\mathrm{LIN}}$，在无网格方法的理论中都是标准的。该问题具有科学依据、客观性，并包含为每个测试用例提供唯一计算解所需的所有必要信息。包含了对节点支承不足、矩阵条件和可见性效应等故障模式的诊断标准，使该问题成为对MLS原理理解的全面测试。因此，该问题被视为**有效**。\n\n解决方案通过为每个指定的测试用例实施MLS近似方案来进行。核心步骤如下：\n\n1.  **节点离散化**：对于给定的网格间距 $h$，在方形域 $[-1, 1] \\times [-1, 1]$ 上生成一个均匀的笛卡尔网格节点。然后对这些节点进行筛选，只保留位于指定的L形域 $\\mathcal{D}$ 内的节点。如果坐标为 $(X_I, Y_I)$ 的节点满足条件 $X_I \\le 0$ 或 $Y_I \\le 0$，则该节点被保留。在实践中，使用一个小的数值容差来精确处理边界上的浮点运算（例如，$X_I \\le 10^{-9}$）。\n\n2.  **支承域和权函数计算**：对于给定的评估点 $\\mathbf{x}$ 和支承半径 $R$，我们识别出圆形支承域内的所有节点 $\\mathbf{X}_I$，即欧几里得距离 $\\|\\mathbf{x} - \\mathbf{X}_I\\|$ 小于或等于 $R$ 的节点。对于每个这样的节点，计算归一化距离 $r_I = \\|\\mathbf{x} - \\mathbf{X}_I\\| / R$。然后使用给定的四次样条函数 $w(r_I) = (1 - r_I)^4(4r_I + 1)$ 来评估相应的权函数 $w_I(\\mathbf{x})$。\n\n3.  **可见性约束**：如果可见性约束是活动的，则对支承半径内的每个节点 $\\mathbf{X}_I$ 执行附加检查。如果连接节点与评估点 $\\mathbf{x}$ 的直线段与域的空区域相交，则该节点被视为“不可见”，该空区域是开放的第一象限 $\\{(u,v) \\in \\mathbb{R}^2 \\mid u  0, v  0\\}$。这种几何条件当且仅当一个点（$\\mathbf{x}$ 或 $\\mathbf{X}_I$）位于开放的第二象限（$\\{ u  0, v  0 \\}$）而另一个点位于开放的第四象限（$\\{ u  0, v  0 \\}$）时发生。如果一个节点不可见，其权重被设置为零，$w_I(\\mathbf{x})=0$，从而有效地将其从近似中移除。\n\n4.  **支承充足性诊断检查**：使用线性基 $p(\\mathbf{x}) = [1, x, y]^T$ 的MLS近似需要至少3个节点才能确保矩量矩阵是非奇异的。计算贡献节点的数量（在应用距离和可见性标准后 $w_I(\\mathbf{x})  0$ 的节点）。如果此数量小于3，则支承不足。诊断代码设置为 $d=1$，并且不对此案例进行进一步计算。\n\n5.  **矩量矩阵的构造与条件**：如果支承充足，则组装 $3 \\times 3$ 的矩量矩阵 $\\mathbf{A}(\\mathbf{x})$：\n    $$\n    \\mathbf{A}(\\mathbf{x}) = \\sum_{I} w_I(\\mathbf{x})\\, p(\\mathbf{X}_I)\\, p(\\mathbf{X}_I)^T\n    $$\n    其中求和遍及所有贡献节点。节点 $I$ 的基向量是 $p(\\mathbf{X}_I) = [1, X_I, Y_I]^T$。然后计算 $\\mathbf{A}(\\mathbf{x})$ 的条件数。如果超过阈值 $10^{12}$，则矩阵被认为是病态的，诊断代码设置为 $d=2$。\n\n6.  **形函数评估与性质验证**：如果矩量矩阵是良态的，则使用其逆矩阵 $\\mathbf{A}(\\mathbf{x})^{-1}$ 来确定形函数。为了计算效率，我们首先计算向量 $\\mathbf{b}(\\mathbf{x})^T = p(\\mathbf{x})^T \\mathbf{A}(\\mathbf{x})^{-1}$。然后每个贡献节点 $I$ 的形函数是 $\\phi_I(\\mathbf{x}) = \\mathbf{b}(\\mathbf{x})^T w_I(\\mathbf{x}) p(\\mathbf{X}_I)$。\n    在计算出形函数后，我们验证单位分解和线性再生性质：\n    - 单位分解 (PU)：我们计算和 $\\sum_I \\phi_I(\\mathbf{x})$ 及其与1的绝对偏差，得到 $e_{\\mathrm{PU}}$。\n    - 线性再生 (LIN)：我们计算向量和 $\\sum_I \\phi_I(\\mathbf{x})\\, \\mathbf{X}_I$ 及其与评估点 $\\mathbf{x}$ 的欧几里得距离，得到 $e_{\\mathrm{LIN}}$。\n\n7.  **最终诊断**：根据误差计算，确定布尔指标 $b_{\\mathrm{PU}} = (e_{\\mathrm{PU}} \\le 10^{-8})$ 和 $b_{\\mathrm{LIN}} = (e_{\\mathrm{LIN}} \\le 10^{-8})$。最终诊断代码 $d$ 被分配为：\n    - 如果 $b_{\\mathrm{PU}}$ 和 $b_{\\mathrm{LIN}}$ 都为真，则 $d=0$（成功）。\n    - 否则（如果在支承充足且矩阵良态的情况下任一测试失败），$d=3$（再生失败）。\n\n此过程被系统地应用于每个测试用例，以生成所需的输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Moving Least Squares problem for a set of test cases.\n    \"\"\"\n    test_cases = [\n        # (x_eval, R, h, visibility_flag)\n        ((-0.5, -0.5), 0.45, 0.2, False),\n        ((-0.05, -0.05), 0.15, 0.2, False),\n        ((-0.05, -0.05), 0.35, 0.2, True),\n        ((0.2, -0.2), 0.3, 0.2, True),\n        ((-0.05, -0.05), 0.25, 0.2, True),\n    ]\n\n    results = []\n    \n    TOL = 1e-8\n    COND_THRESH = 1e12\n\n    def weight_function(r):\n        if 0 = r = 1:\n            return (1 - r)**4 * (4 * r + 1)\n        return 0.0\n\n    def is_visible(p1, p2):\n        x1, y1 = p1\n        x2, y2 = p2\n        eps = 1e-9\n        \n        # Obstructed if one point is in the open 2nd quadrant and the other in the open 4th.\n        # Q2: x  0, y > 0\n        # Q4: x > 0, y  0\n        case1 = (x1  -eps and y1 > eps) and (x2 > eps and y2  -eps)\n        case2 = (x1 > eps and y1  -eps) and (x2  -eps and y2 > eps)\n        \n        return not (case1 or case2)\n\n    for x_eval, R, h, visibility_flag in test_cases:\n        # Step 1: Nodal Discretization\n        n_points = int(round(2.0 / h)) + 1\n        coords = np.linspace(-1.0, 1.0, n_points)\n        all_nodes = []\n        for x_node in coords:\n            for y_node in coords:\n                # Domain D: x = 0 or y = 0\n                if x_node = TOL or y_node = TOL:\n                    all_nodes.append(np.array([x_node, y_node]))\n        \n        x_eval = np.array(x_eval)\n        \n        # Step 2  3: Find contributing nodes (support + visibility)\n        contributing_nodes = []\n        for X_I in all_nodes:\n            dist = np.linalg.norm(x_eval - X_I)\n            if dist = R:\n                if visibility_flag and not is_visible(x_eval, X_I):\n                    continue\n                \n                r = dist / R\n                w_I = weight_function(r)\n                if w_I > 0:\n                    contributing_nodes.append({'pos': X_I, 'w': w_I})\n                    \n        # Step 4: Diagnostic Check for Sufficient Support\n        if len(contributing_nodes)  3:\n            results.append([False, False, 1])\n            continue\n\n        # Step 5: Moment Matrix Construction and Conditioning\n        A = np.zeros((3, 3))\n        for node in contributing_nodes:\n            p_I = np.array([1.0, node['pos'][0], node['pos'][1]])\n            A += node['w'] * np.outer(p_I, p_I)\n        \n        if np.linalg.cond(A) > COND_THRESH:\n            results.append([False, False, 2])\n            continue\n            \n        # Step 6: Shape Function and Property Verification\n        p_eval = np.array([1.0, x_eval[0], x_eval[1]])\n        try:\n            A_inv = np.linalg.inv(A)\n            b = A_inv @ p_eval\n        except np.linalg.LinAlgError:\n            results.append([False, False, 2]) # Should be caught by cond, but as a safeguard\n            continue\n\n        phi_sum = 0.0\n        phi_X_sum = np.zeros(2)\n\n        for node in contributing_nodes:\n            p_I = np.array([1.0, node['pos'][0], node['pos'][1]])\n            phi_I = np.dot(b, p_I) * node['w']\n            phi_sum += phi_I\n            phi_X_sum += phi_I * node['pos']\n            \n        e_PU = abs(phi_sum - 1.0)\n        e_LIN = np.linalg.norm(phi_X_sum - x_eval)\n        \n        b_PU = e_PU = TOL\n        b_LIN = e_LIN = TOL\n\n        # Step 7: Final Diagnostics\n        if b_PU and b_LIN:\n            d = 0\n        else:\n            d = 3\n        \n        results.append([b_PU, b_LIN, d])\n\n    # Format the final output string\n    # E.g., [[True, True, 0], [False, False, 1]]\n    output_str = \"[\" + \",\".join([str(res).replace(\" \", \"\") for res in results]) + \"]\"\n    print(output_str.replace(\"'\", \"\")) # Remove quotes from strings for exact format\n\nsolve()\n```", "id": "3581244"}]}