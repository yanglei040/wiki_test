{"hands_on_practices": [{"introduction": "共轭梯度（CG）方法的收敛速度与系统矩阵的条件数密切相关。本练习通过一个一维线弹性杆的有限元模型，探讨了质量正则化技术如何影响刚度矩阵的谱特性，从而改变CG方法的收敛行为。通过这个实践[@problem_id:3576538]，您将亲手验证在准静态分析中添加一个小的质量项如何能够显著改善条件数，并加速求解过程。", "problem": "请使用有限元法 (FEM) 和线性形函数，为一根杆构建一个准静态一维线性弹性模型。设杆的无量纲参数为：杨氏模量 $E=1$，横截面积 $A=1$，质量密度 $\\rho=1$，长度 $L=1$。将杆离散化为 $n_e$ 个长度为 $h=L/n_e$ 的等长线性单元，节点索引从 $0$ 到 $n_e$。在节点 $0$ 处施加狄利克雷边界条件，使得位移 $u(0)=0$。通过组装其一致节点荷载贡献，沿杆施加一个均匀的无量纲体力 $q=1$。\n\n其基本依据是小应变条件下的一维准静态线性动量平衡，其强形式由以下平衡方程给出：\n$$\n\\frac{d}{dx}\\left( E A \\frac{du}{dx} \\right) + q = 0.\n$$\n在使用线性形函数的标准 Galerkin 有限元离散化中，单元刚度矩阵和单元一致质量矩阵分别为：\n$$\n\\mathbf{k}_e = \\frac{E A}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}, \\quad\n\\mathbf{m}_e = \\frac{\\rho A h}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix},\n$$\n在均匀体力 $q$ 作用下，单元一致节点荷载向量为：\n$$\n\\mathbf{f}_e = \\frac{q A h}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}.\n$$\n在组装并施加节点 $0$ 处的狄利克雷边界条件后，对于自由度，全局刚度矩阵 $\\mathbf{K}$ 和全局质量矩阵 $\\mathbf{M}$ 是对称正定 (SPD) 的。考虑用一个无量纲质量正则化项 $\\alpha \\mathbf{M}$ 来增广准静态算子，并定义\n$$\n\\mathbf{K}_\\alpha = \\mathbf{K} + \\alpha \\mathbf{M},\n$$\n其中 $\\alpha \\ge 0$ 是一个标量参数。您必须证明在所述条件下，对于所有 $\\alpha \\ge 0$，$\\mathbf{K}_\\alpha \\succ 0$（即 $\\mathbf{K}_\\alpha$ 是对称正定的）。\n\n然后，对于线性系统\n$$\n\\mathbf{K}_\\alpha \\mathbf{u} = \\mathbf{b},\n$$\n通过测量达到指定相对残差容差所需的迭代次数，比较在改变 $\\alpha$ 时共轭梯度法 (CG) 的收敛行为。使用相对残差的标准定义\n$$\n\\frac{\\|\\mathbf{b} - \\mathbf{K}_\\alpha \\mathbf{u}_k\\|_2}{\\|\\mathbf{b}\\|_2},\n$$\n其中 $\\mathbf{u}_k$ 是第 $k$ 次迭代的 CG 迭代解。\n\n在一个完整、可运行的程序中实现以下内容：\n1. 使用上述无量纲参数，为所描述的杆组装全局矩阵 $\\mathbf{K}$、$\\mathbf{M}$ 和全局荷载向量 $\\mathbf{b}$。\n2. 通过移除 $\\mathbf{K}$ 和 $\\mathbf{M}$ 中对应的行和列以及 $\\mathbf{b}$ 中的对应项，在节点 0 处施加狄利克雷边界条件。\n3. 对于每个指定的 $\\alpha$，构建 $\\mathbf{K}_\\alpha$，计算其最小特征值以数值方式确认其对称正定性，并使用从头实现的共轭梯度法求解 $\\mathbf{K}_\\alpha \\mathbf{u}=\\mathbf{b}$。记录从零初始猜测开始达到 $10^{-10}$ 相对残差容差所需的迭代次数。\n4. 使用 $n_e=64$ 个单元。\n\n测试套件：\n- 使用 $\\alpha$ 值 $\\{0.0, 10^{-6}, 10^{-3}, 10^{-1}, 1.0, 10.0\\}$ 来涵盖基准、小增广、中等增广和大增广的情况。\n\n答案规格：\n- 对于列表中按顺序列出的每个 $\\alpha$，产生两个输出：整数形式的 CG 迭代次数和浮点数形式的 $\\mathbf{K}_\\alpha$ 最小特征值。由于模型是无量纲的，这些输出是无单位的数值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按确切顺序包含与 $\\alpha$ 值 $\\{0.0, 10^{-6}, 10^{-3}, 10^{-1}, 1.0, 10.0\\}$ 对应的数值：$\\left[\\text{iters}_{\\alpha_1}, \\lambda_{\\min}(\\mathbf{K}_{\\alpha_1}), \\text{iters}_{\\alpha_2}, \\lambda_{\\min}(\\mathbf{K}_{\\alpha_2}), \\ldots \\right]$。", "solution": "该问题要求使用有限元法 (FEM) 构建和分析一个杆的一维准静态线性弹性模型。该模型通过一个质量正则化项进行增广，并且需要研究共轭梯度 (CG) 迭代求解器作为正则化参数 $\\alpha$ 函数的收敛行为。\n\n第一步是对问题的核心前提进行理论验证：即在给定的边界条件下，对于所有 $\\alpha \\ge 0$，矩阵 $\\mathbf{K}_\\alpha = \\mathbf{K} + \\alpha \\mathbf{M}$ 是对称正定 (SPD) 的。\n\n一个矩阵 $\\mathbf{A}$ 是对称正定的，如果它是对称的 ($\\mathbf{A} = \\mathbf{A}^T$) 并且对于任何非零向量 $\\mathbf{x}$，二次型 $\\mathbf{x}^T \\mathbf{A} \\mathbf{x} > 0$。全局刚度矩阵 $\\mathbf{K}$ 和质量矩阵 $\\mathbf{M}$ 是由它们对称的单元级对应部分 ($\\mathbf{k}_e$, $\\mathbf{m}_e$) 组装而成的，因此它们也是对称的。所以，$\\mathbf{K}_\\alpha$ 是对称的。\n\n为了确定正定性，我们考虑二次型的物理诠释。\n项 $\\frac{1}{2}\\mathbf{u}^T \\mathbf{K} \\mathbf{u}$ 表示对于给定的节点位移向量 $\\mathbf{u}$，存储在离散化杆中的弹性应变能。为使系统稳定，对于任何可能的变形，该能量必须为正。在没有任何边界条件的情况下，杆的刚体平移（对于常数 $c \\ne 0$，$\\mathbf{u} = c[1, 1, \\dots, 1]^T$）导致零应变和零应变能，这意味着 $\\mathbf{K}$ 仅是半正定的。问题指定了一个狄利克雷边界条件 $u(0)=0$，通过移除全局矩阵的第一行和第一列来施加。这个约束消除了刚体模态。对于剩余自由度上的任何非零位移向量 $\\mathbf{u}$，必须存在非零应变，因此应变能 $\\frac{1}{2}\\mathbf{u}^T \\mathbf{K} \\mathbf{u} > 0$。因此，简化后的刚度矩阵 $\\mathbf{K}$ 是对称正定的。\n\n项 $\\frac{1}{2}\\mathbf{u}^T \\mathbf{M} \\mathbf{u}$ 对应于系统的动能（如果 $\\mathbf{u}$ 是一个速度向量）。单元质量矩阵 $\\mathbf{m}_e$ 是对称正定的，组装后的全局质量矩阵 $\\mathbf{M}$（在施加边界条件前后）也是对称正定的，因为质量是一个内在的正量。对于任何非零位移（或速度）场，动能必须为正。因此，对于自由度上的任何非零向量 $\\mathbf{u}$，$\\mathbf{u}^T \\mathbf{M} \\mathbf{u} > 0$。\n\n现在，考虑 $\\mathbf{K}_\\alpha$ 对任意适当维度的非零向量 $\\mathbf{u}$ 的二次型：\n$$\n\\mathbf{u}^T \\mathbf{K}_\\alpha \\mathbf{u} = \\mathbf{u}^T (\\mathbf{K} + \\alpha \\mathbf{M}) \\mathbf{u} = \\mathbf{u}^T \\mathbf{K} \\mathbf{u} + \\alpha (\\mathbf{u}^T \\mathbf{M} \\mathbf{u})\n$$\n由于 $\\mathbf{K}$ 和 $\\mathbf{M}$ 是对称正定的，我们有 $\\mathbf{u}^T \\mathbf{K} \\mathbf{u} > 0$ 和 $\\mathbf{u}^T \\mathbf{M} \\mathbf{u} > 0$。对于 $\\alpha \\ge 0$，项 $\\alpha (\\mathbf{u}^T \\mathbf{M} \\mathbf{u})$ 是非负的。一个严格为正的数与一个非负数的和是严格为正的。因此，对于所有 $\\alpha \\ge 0$，$\\mathbf{u}^T \\mathbf{K}_\\alpha \\mathbf{u} > 0$，这证实了 $\\mathbf{K}_\\alpha$ 是对称正定的。这是成功应用共轭梯度法的关键先决条件。\n\n数值实现过程如下。\n首先，我们定义无量纲的物理参数和离散化参数：$E=1$、$A=1$、$\\rho=1$、$L=1$、$q=1$ 和 $n_e=64$。这得到单元长度 $h = L/n_e = 1/64$。\n计算单元刚度矩阵 $\\mathbf{k}_e$、质量矩阵 $\\mathbf{m}_e$ 和力向量 $\\mathbf{f}_e$：\n$$\n\\mathbf{k}_e = \\frac{1 \\cdot 1}{1/64} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} = 64 \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}\n$$\n$$\n\\mathbf{m}_e = \\frac{1 \\cdot 1 \\cdot (1/64)}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix} = \\frac{1}{384} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}\n$$\n$$\n\\mathbf{f}_e = \\frac{1 \\cdot 1 \\cdot (1/64)}{2} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} = \\frac{1}{128} \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\n$$\n全局矩阵 $\\mathbf{K}$、$\\mathbf{M}$（大小为 $(n_e+1) \\times (n_e+1)$）和向量 $\\mathbf{b}$（大小为 $n_e+1$）被初始化为零。然后我们遍历 $n_e$ 个单元中的每一个。对于单元 $i$（连接节点 $i$ 和 $i+1$），$\\mathbf{k}_e$、$\\mathbf{m}_e$ 和 $\\mathbf{f}_e$ 的项被加到全局系统中的相应位置。这个标准组装过程会产生带状全局矩阵。\n\n通过移除 $\\mathbf{K}$ 和 $\\mathbf{M}$ 中对应于节点 $0$ 的行和列，以及从 $\\mathbf{b}$ 中移除对应于节点 $0$ 的项，来施加狄利克雷边界条件 $u(0)=0$。这将系统的大小从 $(n_e+1) \\times (n_e+1)$ 减小到 $n_e \\times n_e$。将简化后的系统记为 $\\mathbf{K}_{red}$、$\\mathbf{M}_{red}$ 和 $\\mathbf{b}_{red}$。\n\n对于测试套件中的每个 $\\alpha$ 值，形成增广矩阵 $\\mathbf{K}_\\alpha = \\mathbf{K}_{red} + \\alpha \\mathbf{M}_{red}$。计算其最小特征值 $\\lambda_{\\min}(\\mathbf{K}_\\alpha)$，以数值验证其对称正定性（对于对称矩阵，一个正的最小特征值证实了这一点）。\n\n然后使用一个从头实现的共轭梯度算法求解线性系统 $\\mathbf{K}_\\alpha \\mathbf{u} = \\mathbf{b}_{red}$。该算法使用零向量猜测值 $\\mathbf{u}_0 = \\mathbf{0}$ 进行初始化。迭代过程如下：\n1.  初始化：$\\mathbf{u}_0 = \\mathbf{0}$，残差 $\\mathbf{r}_0 = \\mathbf{b}_{red}$，搜索方向 $\\mathbf{p}_0 = \\mathbf{r}_0$。\n2.  对于 $k=0, 1, 2, \\dots$：\n    a. 计算步长：$\\gamma_k = (\\mathbf{r}_k^T \\mathbf{r}_k) / (\\mathbf{p}_k^T \\mathbf{K}_\\alpha \\mathbf{p}_k)$。\n    b. 更新解：$\\mathbf{u}_{k+1} = \\mathbf{u}_k + \\gamma_k \\mathbf{p}_k$。\n    c. 更新残差：$\\mathbf{r}_{k+1} = \\mathbf{r}_k - \\gamma_k \\mathbf{K}_\\alpha \\mathbf{p}_k$。\n    d. 检查收敛性：如果 $\\|\\mathbf{r}_{k+1}\\|_2 / \\|\\mathbf{b}_{red}\\|_2 \\le 10^{-10}$，则停止。迭代次数为 $k+1$。\n    e. 更新搜索方向：$\\beta_k = (\\mathbf{r}_{k+1}^T \\mathbf{r}_{k+1}) / (\\mathbf{r}_k^T \\mathbf{r}_k)$，然后 $\\mathbf{p}_{k+1} = \\mathbf{r}_{k+1} + \\beta_k \\mathbf{p}_k$。\n\nCG 方法的性能内在地与系统矩阵的条件数 $\\kappa(\\mathbf{K}_\\alpha) = \\lambda_{\\max}(\\mathbf{K}_\\alpha) / \\lambda_{\\min}(\\mathbf{K}_\\alpha)$ 相关。对于 $\\alpha=0$，已知刚度矩阵 $\\mathbf{K}_{red}$ 在细密网格下是病态的，其条件数 $\\kappa(\\mathbf{K}_{red}) \\propto n_e^2$。添加质量矩阵项 ($\\alpha > 0$) 会增加所有特征值，但它对较小特征值的影响相对更显著，因此通常会减小条件数。预计随着 $\\alpha$ 从零开始增加，收敛所需的 CG 迭代次数会减少。对于大的 $\\alpha$，$\\mathbf{K}_\\alpha \\approx \\alpha \\mathbf{M}_{red}$，条件数将趋近于质量矩阵的条件数 $\\kappa(\\mathbf{M}_{red})$，这是一个与 $n_e$ 无关的较小常数。因此，对于大的 $\\alpha$，迭代次数应该会稳定下来。下面的程序实现了这一过程，并为指定的 $\\alpha$ 值集合测量了迭代次数和最小特征值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and solves a 1D linear elasticity problem using FEM,\n    analyzing the convergence of the Conjugate Gradient method with\n    mass regularization.\n    \"\"\"\n\n    # 1. Define problem parameters and test suite\n    E = 1.0\n    A = 1.0\n    rho = 1.0\n    L = 1.0\n    q = 1.0\n    n_e = 64\n    h = L / n_e\n    \n    alpha_values = [0.0, 1e-6, 1e-3, 1e-1, 1.0, 10.0]\n    tolerance = 1e-10\n\n    # 2. Assemble global matrices and vector\n    n_nodes = n_e + 1\n    K_global = np.zeros((n_nodes, n_nodes))\n    M_global = np.zeros((n_nodes, n_nodes))\n    b_global = np.zeros(n_nodes)\n\n    # Element matrices and vector\n    k_e = (E * A / h) * np.array([[1, -1], [-1, 1]])\n    m_e = (rho * A * h / 6) * np.array([[2, 1], [1, 2]])\n    f_e = (q * A * h / 2) * np.array([1, 1])\n\n    # Assembly loop\n    for i in range(n_e):\n        # Global DOFs for element i are i and i+1\n        dofs = np.array([i, i + 1])\n        ix_ = np.ix_(dofs, dofs)\n        K_global[ix_] += k_e\n        M_global[ix_] += m_e\n        b_global[dofs] += f_e\n\n    # 3. Apply Dirichlet boundary condition (u(0) = 0)\n    # This involves removing the first row and column (DOF 0)\n    free_dofs = np.arange(1, n_nodes)\n    K_reduced = K_global[np.ix_(free_dofs, free_dofs)]\n    M_reduced = M_global[np.ix_(free_dofs, free_dofs)]\n    b_reduced = b_global[free_dofs]\n\n    def conjugate_gradient(A_mat, b_vec, tol):\n        \"\"\"\n        Solves Ax=b using the Conjugate Gradient method from first principles.\n        \"\"\"\n        n = len(b_vec)\n        x = np.zeros(n)\n        r = b_vec - A_mat @ x\n        p = r.copy()\n        rs_old = r @ r\n        \n        b_norm = np.linalg.norm(b_vec)\n        if b_norm == 0:\n            return 0 # Trivial solution\n\n        # The problem asks for a maximum number of iterations, but for a \n        # well-posed problem, setting it to the system size is sufficient\n        # as CG is guaranteed to converge in at most n steps (in exact arithmetic).\n        for i in range(n):\n            Ap = A_mat @ p\n            alpha_cg = rs_old / (p @ Ap)\n            \n            x += alpha_cg * p\n            r -= alpha_cg * Ap\n            \n            # Check for convergence\n            residual_norm = np.linalg.norm(r)\n            if residual_norm / b_norm = tol:\n                return i + 1\n            \n            rs_new = r @ r\n            p = r + (rs_new / rs_old) * p\n            rs_old = rs_new\n            \n        return n # Return max iterations if tolerance not met\n\n    results = []\n    for alpha in alpha_values:\n        # 4. Form augmented matrix and solve\n        K_alpha = K_reduced + alpha * M_reduced\n\n        # 5. Compute smallest eigenvalue to confirm SPD\n        # eigvalsh is efficient for symmetric matrices and returns sorted eigenvalues\n        min_eigenvalue = np.linalg.eigvalsh(K_alpha)[0]\n\n        # 6. Solve system with CG and record iteration count\n        iterations = conjugate_gradient(K_alpha, b_reduced, tolerance)\n\n        results.extend([iterations, min_eigenvalue])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3576538"}, {"introduction": "预处理是加速迭代求解器收敛的关键技术，而对角缩放（或平衡）是最简单有效的预处理方法之一。本练习将引导您通过解析推导，来分析对角平衡对非均匀网格（一种自适应网格加密的常见结果）下刚度矩阵条件数的影响。完成这个练习[@problem_id:3576563]，您将深刻理解预处理如何通过改变矩阵的谱分布来改善其性质，并确定该技术最有效的条件。", "problem": "考虑一根长度为 $L$、轴向刚度 $E A$ 恒定的一维线性弹性杆，其两端固定（狄利克雷边界条件）。使用标准分段线性有限元法对该杆进行离散化，使用三个单元，其长度遵循几何加密模式 $h_{1} = h$、$h_{2} = r h$ 和 $h_{3} = r^{2} h$，其中 $h  0$ 且 $r  0$ 是模拟自适应网格加密的加密比。两个内部节点的位移是未知量，得到的全局刚度矩阵 $K$ 是对称正定（SPD）的。在预处理共轭梯度法（PCG）中，考虑通过 $H = D^{1/2} K D^{1/2}$ 进行对角平衡，其中 $D = \\mathrm{diag}(d_{1}, d_{2})$ 的选择应使 $H$ 的对角线元素为 $1$，即 $d_{i} = 1/K_{ii}$。\n\n从一维杆的标准有限元组装规则出发（对于内部节点 $i$，该规则得出 $K_{ii} = E A \\left( \\frac{1}{h_{i}} + \\frac{1}{h_{i+1}} \\right)$ 和 $K_{i,i+1} = K_{i+1,i} = - \\frac{E A}{h_{i+1}}$），推导谱条件数 $\\kappa(K)$ 和 $\\kappa(H)$ 作为 $r$ 的函数的闭式表达式，并用它们来确定加密比 $r_{\\mathrm{crit}}$，在该比率下，对角平衡既不改善也不恶化条件数，即满足 $\\kappa(H) = \\kappa(K)$ 的唯一正数 $r$。\n\n请提供最终的 $r_{\\mathrm{crit}}$ 的精确值。无需四舍五入。最终答案不带单位。", "solution": "首先，我们根据有限元组装规则为两个内部自由度（节点1和节点2）构造 $2 \\times 2$ 的全局刚度矩阵 $K$。单元长度为 $h_1 = h$, $h_2 = rh$, $h_3 = r^2h$。矩阵的各项为：\n$$ K_{11} = EA \\left( \\frac{1}{h_1} + \\frac{1}{h_2} \\right) = \\frac{EA(r+1)}{rh} $$\n$$ K_{22} = EA \\left( \\frac{1}{h_2} + \\frac{1}{h_3} \\right) = \\frac{EA(r+1)}{r^2h} $$\n$$ K_{12} = K_{21} = -\\frac{EA}{h_2} = -\\frac{EA}{rh} $$\n因此，刚度矩阵 $K$ 可以写作：\n$$ K = \\frac{EA}{r^2h} \\begin{pmatrix} r(r+1)  -r \\\\ -r  r+1 \\end{pmatrix} $$\n$K$ 的谱条件数 $\\kappa(K)$ 等于其无量纲部分 $A = \\begin{pmatrix} r(r+1)  -r \\\\ -r  r+1 \\end{pmatrix}$ 的条件数。$A$ 的特征值为 $\\lambda_{\\max}(A) = r^2+r+1$ 和 $\\lambda_{\\min}(A) = r$。因此，$K$ 的条件数为：\n$$ \\kappa(K) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)} = \\frac{r^2+r+1}{r} $$\n接下来，我们构造对角平衡后的矩阵 $H$。其元素为 $H_{ij} = K_{ij} / \\sqrt{K_{ii}K_{jj}}$。对角线元素 $H_{11} = H_{22} = 1$，非对角线元素为 $H_{12} = H_{21} = -\\frac{\\sqrt{r}}{r+1}$。$H$ 的特征值为 $\\lambda = 1 \\mp \\frac{\\sqrt{r}}{r+1}$，其条件数为：\n$$ \\kappa(H) = \\frac{1 + \\frac{\\sqrt{r}}{r+1}}{1 - \\frac{\\sqrt{r}}{r+1}} = \\frac{r+\\sqrt{r}+1}{r-\\sqrt{r}+1} $$\n最后，我们求解使 $\\kappa(K) = \\kappa(H)$ 成立的临界比 $r_{\\mathrm{crit}}$：\n$$ \\frac{r^2+r+1}{r} = \\frac{r+\\sqrt{r}+1}{r-\\sqrt{r}+1} $$\n利用代数恒等式 $r^2+r+1 = (r-\\sqrt{r}+1)(r+\\sqrt{r}+1)$，方程简化为 $(r-\\sqrt{r}+1)^2 = r$。取平方根后，唯一有效的正解是 $r=1$。因此，$r_{\\text{crit}}=1$。", "answer": "$$\\boxed{1}$$", "id": "3576563"}, {"introduction": "在掌握了预处理的基本原理后，现在是时候将这些知识应用于更复杂的二维问题了。本练习要求您为一个二维泊松问题（常用于模拟热传导或弹性膜）从零开始实现预处理共轭梯度（PCG）算法。您将使用一种广泛应用的预处理器——零填充不完全Cholesky分解（IC(0)），并在一系列不同的载荷工况下测试其性能。通过这个实践[@problem_id:3576531]，您将获得构建和应用高级迭代求解器的宝贵编码经验。", "problem": "考虑一个线性系统，它来自计算固体力学中二维网格上具有齐次 Dirichlet 边界条件的离散泊松算子。该离散问题是对称正定的，因为它是由在有限维子空间上最小化二次势能得到的。令 $n$ 表示每个坐标方向上的内部点数，令 $N = n^2$ 表示总自由度数。使用 $n = 4$，因此 $N = 16$。采用字典序（行主序）排序：对于网格索引 $(i,j)$，$i \\in \\{0,1,2,3\\}$ 且 $j \\in \\{0,1,2,3\\}$，映射到向量索引 $k = j \\cdot n + i$。组装与负拉普拉斯算子的 $5$ 点模板对应的 $N \\times N$ 刚度矩阵 $A$，不进行网格尺寸缩放。也就是说，对于每个内部节点，离散算子为该节点值的 $4$ 倍减去其在 $\\pm x$ 和 $\\pm y$ 方向上直接相邻节点的值（如果这些相邻节点存在）。具体来说，对所有 $k$，设置 $A_{k,k} = 4$，对网格图中的每一对相邻节点，将相应的非对角线元素设置为 $-1$；所有其他元素均为 $0$。这个矩阵 $A$ 是对称正定的。\n\n定义零填充不完全 Cholesky 预条件子，记为 $\\mathrm{IC}(0)$，按自然顺序计算，如下所示。寻找一个下三角矩阵 $L$，使得 $L L^\\top \\approx A$，并满足约束条件：对每个 $i  j$，当且仅当 $A_{i,j} \\neq 0$ 时，元素 $L_{i,j}$ 非零，并且对所有 $i$，$L_{i,i}  0$。因子 $L$ 通过从精确 Cholesky 分解得到的递推公式计算，同时丢弃所有不存在于 $A$ 的下三角稀疏模式中的填充元素：\n- 对 $i = 0,1,\\dots,N-1$ 以及每个满足 $A_{i,j} \\neq 0$ 的 $j  i$，\n$$\nL_{i,j} = \\frac{1}{L_{j,j}} \\left(A_{i,j} - \\sum_{k=0}^{j-1} \\mathbf{1}_{A_{i,k} \\neq 0} \\, \\mathbf{1}_{A_{j,k} \\neq 0} \\, L_{i,k} L_{j,k}\\right),\n$$\n对角线元素为\n$$\nL_{i,i} = \\sqrt{A_{i,i} - \\sum_{k=0}^{i-1} \\mathbf{1}_{A_{i,k} \\neq 0} \\, L_{i,k}^2}.\n$$\n此处 $\\mathbf{1}_{\\cdot}$ 表示指示函数。\n\n考虑将预处理共轭梯度（PCG）方法应用于 $A \\mathbf{x} = \\mathbf{b}$，其中预条件子为 $M = L L^\\top$，初始猜测为 $\\mathbf{x}_0 = \\mathbf{0}$。PCG 的一步定义如下：\n- 残差：$\\mathbf{r}_0 = \\mathbf{b} - A \\mathbf{x}_0 = \\mathbf{b}$。\n- 预处理残差：求解 $M \\mathbf{z}_0 = \\mathbf{r}_0$ 得到 $\\mathbf{z}_0$，使用 $L$ 进行前向替换，然后使用 $L^\\top$ 进行后向替换。\n- 搜索方向：$\\mathbf{p}_0 = \\mathbf{z}_0$。\n- 步长：\n$$\n\\alpha_0 = \\frac{\\mathbf{r}_0^\\top \\mathbf{z}_0}{\\mathbf{p}_0^\\top A \\mathbf{p}_0}.\n$$\n- 更新迭代解：$\\mathbf{x}_1 = \\mathbf{x}_0 + \\alpha_0 \\mathbf{p}_0$。\n- 更新残差：$\\mathbf{r}_1 = \\mathbf{r}_0 - \\alpha_0 A \\mathbf{p}_0$。\n- 更新预处理残差：求解 $M \\mathbf{z}_1 = \\mathbf{r}_1$ 得到 $\\mathbf{z}_1$。\n\n你的任务是计算一次 PCG 迭代后预处理残差范数的比值，即 $||\\mathbf{z}_1||_2 / ||\\mathbf{z}_0||_2$，针对以下测试套件中的每个右端向量 $\\mathbf{b}$。在所有情况下，使用上述的 $A$ 和 $\\mathrm{IC}(0)$ 以及初始猜测 $\\mathbf{x}_0 = \\mathbf{0}$。无需物理单位。三角函数定义中出现的所有角度均以弧度为单位。\n\n测试套件（$n = 4$，$N = 16$ 且索引映射为 $k = j \\cdot n + i$）：\n- 情况 A（一般行为）：$\\mathbf{b}^{(A)}$ 是 $\\mathbb{R}^{16}$ 中全为 1 的向量，即对所有 $k \\in \\{0,1,\\dots,15\\}$，$b^{(A)}_k = 1$。\n- 情况 B（局部载荷）：$\\mathbf{b}^{(B)}$ 是对应于 $(i,j) = (1,1)$ 的索引处的单位向量，即如果 $k = 5$ 则 $b^{(B)}_k = 1$，否则 $b^{(B)}_k = 0$。\n- 情况 C（谐波载荷）：$\\mathbf{b}^{(C)}$ 按点定义为\n$$\nb^{(C)}_{j \\cdot n + i} = \\sin\\!\\left(\\pi \\frac{i+1}{n+1}\\right)\\, \\sin\\!\\left(2\\pi \\frac{j+1}{n+1}\\right),\n$$\n对 $i,j \\in \\{0,1,2,3\\}$。\n- 情况 D（确定性振荡序列）：$\\mathbf{b}^{(D)}$ 的元素为\n$$\nb^{(D)}_{k} = \\sin\\!\\left(\\frac{k+1}{3}\\right) + \\frac{1}{2}\\cos\\!\\left(\\frac{k+1}{5}\\right),\n$$\n对 $k \\in \\{0,1,2,\\dots,15\\}$。\n\n你的程序必须：\n- 完全按照规定构造 $A$（对角线为 $4$，最近邻非对角线为 $-1$，无 $1/h^2$ 缩放）。\n- 使用给定的公式按自然顺序计算 $\\mathrm{IC}(0)$ 预条件子 $L$。\n- 对每种情况，从 $\\mathbf{x}_0 = \\mathbf{0}$ 开始执行恰好一次 PCG 迭代，并计算比值 $||\\mathbf{z}_1||_2 / ||\\mathbf{z}_0||_2$。\n- 将每个比值四舍五入到小数点后 $12$ 位。\n\n最终输出格式：\n- 生成单行输出，其中包含情况 A、B、C 和 D 的四个四舍五入后的比值，按此顺序排列，形式为用方括号括起来的逗号分隔列表，例如 $\\texttt{[r\\_A,r\\_B,r\\_C,r\\_D]}$，其中每个 $r_{\\cdot}$ 是一个小数点后恰好有 $12$ 位数字的十进制数。", "solution": "该问题的解决步骤遵循问题陈述中的算法定义。\n首先，根据 5 点模板规则和字典序索引，构造 $N=16$ 的 $N \\times N$ 刚度矩阵 $A$。该矩阵对角线元素为 $4$，若两个节点在网格中相邻，则对应非对角线元素为 $-1$，其余为 $0$。\n\n其次，计算零填充不完全 Cholesky (IC(0)) 分解的下三角因子 $L$。根据问题中给出的公式，对于 $i  j$ 且 $A_{i,j} \\neq 0$，非对角线元素 $L_{i,j}$ 的计算公式中的求和项 $\\sum_{k=0}^{j-1} \\mathbf{1}_{A_{i,k} \\neq 0} \\, \\mathbf{1}_{A_{j,k} \\neq 0} \\, L_{i,k} L_{j,k}$ 为零。这是因为在 5 点模板对应的图中，相邻的两个节点 $i$ 和 $j$ 不会共享一个公共的邻居节点 $k$。因此，公式简化为 $L_{i,j} = A_{i,j} / L_{j,j}$。对角线元素则根据公式 $L_{i,i} = \\sqrt{A_{i,i} - \\sum_{k=0, A_{i,k} \\neq 0}^{i-1} L_{i,k}^2}$ 计算。整个矩阵 $L$ 可通过从 $i=0$到 $N-1$ 逐行迭代计算得到。\n\n然后，对于测试套件中的每个右端向量 $\\mathbf{b}$，执行一步预处理共轭梯度 (PCG) 迭代。从 $\\mathbf{x}_0 = \\mathbf{0}$ 开始，初始残差 $\\mathbf{r}_0 = \\mathbf{b}$。通过求解 $LL^\\top \\mathbf{z}_0 = \\mathbf{r}_0$（即一次前向替换和一次后向替换）得到预处理残差 $\\mathbf{z}_0$。初始搜索方向 $\\mathbf{p}_0 = \\mathbf{z}_0$。计算步长 $\\alpha_0 = (\\mathbf{r}_0^\\top \\mathbf{z}_0) / (\\mathbf{p}_0^\\top A \\mathbf{p}_0)$，并更新残差 $\\mathbf{r}_1 = \\mathbf{r}_0 - \\alpha_0 A \\mathbf{p}_0$。\n\n最后，通过求解 $LL^\\top \\mathbf{z}_1 = \\mathbf{r}_1$ 得到新的预处理残差 $\\mathbf{z}_1$，并计算目标比值 $||\\mathbf{z}_1||_2 / ||\\mathbf{z}_0||_2$。下面的 Python 代码实现了上述所有步骤，并为测试套件中的四种情况生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef create_A_matrix(n, N):\n    \"\"\"\n    Assembles the stiffness matrix A for the 2D Poisson problem.\n    \"\"\"\n    A = np.zeros((N, N), dtype=float)\n    for k in range(N):\n        A[k, k] = 4.0\n        i, j = k % n, k // n\n        # Neighbor to the left\n        if i > 0:\n            A[k, k - 1] = -1.0\n        # Neighbor to the right\n        if i  n - 1:\n            A[k, k + 1] = -1.0\n        # Neighbor above\n        if j > 0:\n            A[k, k - n] = -1.0\n        # Neighbor below\n        if j  n - 1:\n            A[k, k + n] = -1.0\n    return A\n\ndef compute_ic0_factor(A, N):\n    \"\"\"\n    Computes the Incomplete Cholesky factorization with zero fill-in (IC(0)).\n    \"\"\"\n    L = np.zeros((N, N), dtype=float)\n    for i in range(N):\n        # Calculate off-diagonal values in row i first\n        for j in range(i):\n            if A[i, j] != 0:\n                # The summation term in the problem's formula for L_ij is zero\n                # for a 5-point stencil grid graph, as adjacent nodes (where A_ij != 0)\n                # do not share a common neighbor.\n                sum_term = 0.0\n                L[i, j] = (A[i, j] - sum_term) / L[j, j]\n        \n        # Calculate diagonal value for row i\n        sum_diag_sq = 0.0\n        for k in range(i):\n            if L[i,k] != 0: # This is equivalent to A[i,k] != 0 for IC(0)\n                sum_diag_sq += L[i,k]**2\n        \n        val_under_sqrt = A[i, i] - sum_diag_sq\n        L[i, i] = np.sqrt(val_under_sqrt)\n    return L\n\ndef solve_forward_sub(L, b):\n    \"\"\"\n    Solves the lower triangular system Lx = b using forward substitution.\n    \"\"\"\n    n_sys = L.shape[0]\n    x = np.zeros(n_sys)\n    for i in range(n_sys):\n        s = np.dot(L[i, :i], x[:i])\n        x[i] = (b[i] - s) / L[i, i]\n    return x\n\ndef solve_backward_sub(Lt, b):\n    \"\"\"\n    Solves the upper triangular system L^T x = b using backward substitution.\n    \"\"\"\n    n_sys = Lt.shape[0]\n    x = np.zeros(n_sys)\n    for i in range(n_sys - 1, -1, -1):\n        s = np.dot(Lt[i, i + 1:], x[i + 1:])\n        x[i] = (b[i] - s) / Lt[i, i]\n    return x\n\ndef solve_preconditioner(L, r):\n    \"\"\"\n    Solves the preconditioner system Mz = r, where M = LL^T.\n    \"\"\"\n    # Step 1: Solve Ly = r for y (forward substitution)\n    y = solve_forward_sub(L, r)\n    # Step 2: Solve L^T z = y for z (backward substitution)\n    z = solve_backward_sub(L.T, y)\n    return z\n\ndef run_pcg_one_step_and_get_ratio(A, L, b):\n    \"\"\"\n    Performs one PCG iteration and computes the ratio of preconditioned residual norms.\n    \"\"\"\n    N = A.shape[0]\n    \n    # Initial guess x_0 = 0\n    x0 = np.zeros(N)\n    \n    # r_0 = b - A x_0 = b\n    r0 = b\n    \n    # Solve M z_0 = r_0\n    z0 = solve_preconditioner(L, r0)\n    \n    # p_0 = z_0\n    p0 = z0\n    \n    # alpha_0 = (r_0^T z_0) / (p_0^T A p_0)\n    Ap0 = A @ p0\n    alpha0 = np.dot(r0, z0) / np.dot(p0, Ap0)\n    \n    # r_1 = r_0 - alpha_0 A p_0\n    r1 = r0 - alpha0 * Ap0\n    \n    # Solve M z_1 = r_1\n    z1 = solve_preconditioner(L, r1)\n    \n    # Compute the ratio ||z_1||_2 / ||z_0||_2\n    norm_z0 = np.linalg.norm(z0)\n    norm_z1 = np.linalg.norm(z1)\n    \n    if norm_z0 == 0:\n        return 0.0\n\n    return norm_z1 / norm_z0\n\ndef solve():\n    # Define problem parameters\n    n = 4\n    N = n**2\n\n    # Assemble the stiffness matrix A\n    A = create_A_matrix(n, N)\n    \n    # Compute the IC(0) preconditioner factor L\n    L = compute_ic0_factor(A, N)\n\n    # Define the test cases (right-hand side vectors b)\n    # Case A: All-ones vector\n    b_A = np.ones(N)\n    \n    # Case B: Localized load at (i=1, j=1) -> k = 1*4+1 = 5\n    b_B = np.zeros(N)\n    b_B[n * 1 + 1] = 1.0\n    \n    # Case C: Harmonic load\n    b_C = np.zeros(N)\n    for j in range(n):\n        for i in range(n):\n            k = j * n + i\n            b_C[k] = np.sin(np.pi * (i + 1) / (n + 1)) * \\\n                     np.sin(2 * np.pi * (j + 1) / (n + 1))\n                     \n    # Case D: Deterministic oscillatory sequence\n    k_vals = np.arange(N)\n    b_D = np.sin((k_vals + 1) / 3.0) + 0.5 * np.cos((k_vals + 1) / 5.0)\n    \n    test_cases = [b_A, b_B, b_C, b_D]\n\n    # Calculate the ratio for each test case\n    results = []\n    for b in test_cases:\n        ratio = run_pcg_one_step_and_get_ratio(A, L, b)\n        results.append(ratio)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3576531"}]}