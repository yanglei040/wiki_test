{"hands_on_practices": [{"introduction": "超收敛节点恢复 (SPR) 的核心在于其数学过程：利用最小二乘法将离散的、通常不连续的单元应力值拟合到一个连续的多项式场中。这项练习将引导您完成这一基本计算，通过一个具体的二维算例，您将亲手操作如何从一组给定的高斯点应力数据，通过求解正规方程来确定最佳拟合线性应力场的系数，从而计算出节点上的恢复应力 [@problem_id:3603832]。", "problem": "考虑一个有限元法 (FEM) 中的应力恢复任务，其中节点应力是通过对一个单元片上的高斯点应力采用线性场的最小二乘拟合进行平滑来获得的。在超收敛单元片恢复 (Superconvergent Patch Recovery, SPR) 方法中，通过一个局部单元片上的多项式来近似单个应力分量，并通过最小化残差平方和来确定其系数，这与 $L^{2}$ 投影的观点是一致的。假设我们感兴趣的应力分量是 $x$ 方向的正应力，记为 $\\sigma_{xx}$，它在单元片上通过以下线性场进行建模\n$$\n\\sigma_{xx}(x,y) = a_{0} + a_{1} x + a_{2} y,\n$$\n其中 $x$ 和 $y$ 是全局笛卡尔坐标（单位为 $\\mathrm{mm}$），系数 $a_{0}$、$a_{1}$ 和 $a_{2}$ 待定。\n\n给定一个位于 $(x,y) = (0\\,\\mathrm{mm}, 0\\,\\mathrm{mm})$ 的节点周围单元片的高斯点数据。高斯点坐标 $(x_{i},y_{i})$ 及其对应的 $\\sigma_{xx}$ 计算值（单位为 $\\mathrm{MPa}$）如下：\n- $(x_1, y_1) = (1.0\\,\\mathrm{mm}, 0.0\\,\\mathrm{mm})$, 其中 $\\sigma_{xx,1} = 122\\,\\mathrm{MPa}$，\n- $(x_2, y_2) = (-1.0\\,\\mathrm{mm}, 0.0\\,\\mathrm{mm})$, 其中 $\\sigma_{xx,2} = 79\\,\\mathrm{MPa}$，\n- $(x_3, y_3) = (0.0\\,\\mathrm{mm}, 1.0\\,\\mathrm{mm})$, 其中 $\\sigma_{xx,3} = 91\\,\\mathrm{MPa}$，\n- $(x_4, y_4) = (0.0\\,\\mathrm{mm}, -1.0\\,\\mathrm{mm})$, 其中 $\\sigma_{xx,4} = 107\\,\\mathrm{MPa}$，\n- $(x_5, y_5) = (1.0\\,\\mathrm{mm}, 1.0\\,\\mathrm{mm})$, 其中 $\\sigma_{xx,5} = 110\\,\\mathrm{MPa}$，\n- $(x_6, y_6) = (-1.0\\,\\mathrm{mm}, -1.0\\,\\mathrm{mm})$, 其中 $\\sigma_{xx,6} = 92\\,\\mathrm{MPa}$。\n\n使用上述数据的无权最小二乘准则，确定最佳拟合线性场 $\\sigma_{xx}(x,y)$ 的系数 $a_{0}$、$a_{1}$ 和 $a_{2}$。然后，计算节点 $(x,y) = (0.0\\,\\mathrm{mm}, 0.0\\,\\mathrm{mm})$ 处的恢复节点应力。以 $\\mathrm{MPa}$ 为单位表示最终的恢复节点应力，并将您的答案四舍五入到四位有效数字。", "solution": "用户希望通过对给定数据进行线性应力场的无权最小二乘拟合，来求得位于高斯点单元片中心的恢复节点应力。\n\n### 第1步：问题验证\n\n已知条件如下：\n- 应力场模型：$\\sigma_{xx}(x,y) = a_{0} + a_{1} x + a_{2} y$。\n- 进行应力恢复的节点位置：$(x,y) = (0\\,\\mathrm{mm}, 0\\,\\mathrm{mm})$。\n- $6$ 组高斯点数据 $(x_i, y_i, \\sigma_{xx,i})$：\n  1. $(1.0, 0.0)$，$\\sigma_{xx,1} = 122$\n  2. $(-1.0, 0.0)$，$\\sigma_{xx,2} = 79$\n  3. $(0.0, 1.0)$，$\\sigma_{xx,3} = 91$\n  4. $(0.0, -1.0)$，$\\sigma_{xx,4} = 107$\n  5. $(1.0, 1.0)$，$\\sigma_{xx,5} = 110$\n  6. $(-1.0, -1.0)$，$\\sigma_{xx,6} = 92$\n  所有坐标单位为 $\\mathrm{mm}$，所有应力单位为 $\\mathrm{MPa}$。\n- 方法：无权最小二乘准则。\n- 最终输出要求：位于 $(0,0)$ 的恢复节点应力，四舍五入至四位有效数字。\n\n该问题具有科学依据，因为它描述了超收敛单元片恢复 (Superconvergent Patch Recovery, SPR) 方法，这是计算固体力学中一种标准且成熟的后处理技术。该问题是适定的、客观的、自洽的，并且没有任何矛盾或歧义。所提供的数据可以得到唯一解。因此，该问题被认为是有效的。\n\n### 第2步：构建求解方案\n\n目标是找到系数 $a_{0}$、$a_{1}$ 和 $a_{2}$，以最小化线性模型与给定高斯点应力之间的平方误差和 $S$。需要最小化的目标函数是：\n$$\nS(a_{0}, a_{1}, a_{2}) = \\sum_{i=1}^{6} \\left[ \\sigma_{xx}(x_i, y_i) - \\sigma_{xx,i} \\right]^2 = \\sum_{i=1}^{6} \\left[ (a_{0} + a_{1} x_i + a_{2} y_i) - \\sigma_{xx,i} \\right]^2\n$$\n这是一个标准的线性最小二乘问题。我们可以将问题表示为矩阵形式。设 $\\mathbf{a}$ 为未知系数向量，$\\boldsymbol{\\sigma}$ 为已知应力值向量，$\\mathbf{A}$ 为设计矩阵：\n$$\n\\mathbf{a} = \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix}, \\quad \\boldsymbol{\\sigma} = \\begin{pmatrix} \\sigma_{xx,1} \\\\ \\sigma_{xx,2} \\\\ \\sigma_{xx,3} \\\\ \\sigma_{xx,4} \\\\ \\sigma_{xx,5} \\\\ \\sigma_{xx,6} \\end{pmatrix}, \\quad \\mathbf{A} = \\begin{pmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\\\ 1 & x_4 & y_4 \\\\ 1 & x_5 & y_5 \\\\ 1 & x_6 & y_6 \\end{pmatrix}\n$$\n$S = \\|\\mathbf{A}\\mathbf{a} - \\boldsymbol{\\sigma}\\|^2$ 的最小化可导出正规方程组：\n$$\n(\\mathbf{A}^T \\mathbf{A}) \\mathbf{a} = \\mathbf{A}^T \\boldsymbol{\\sigma}\n$$\n让我们使用给定数据构建矩阵。所有坐标 $(x_i, y_i)$ 的单位为 $\\mathrm{mm}$，应力 $\\sigma_{xx,i}$ 的单位为 $\\mathrm{MPa}$。\n$$\n\\mathbf{A} = \\begin{pmatrix} 1 & 1.0 & 0.0 \\\\ 1 & -1.0 & 0.0 \\\\ 1 & 0.0 & 1.0 \\\\ 1 & 0.0 & -1.0 \\\\ 1 & 1.0 & 1.0 \\\\ 1 & -1.0 & -1.0 \\end{pmatrix}, \\quad \\boldsymbol{\\sigma} = \\begin{pmatrix} 122 \\\\ 79 \\\\ 91 \\\\ 107 \\\\ 110 \\\\ 92 \\end{pmatrix}\n$$\n现在，我们计算矩阵 $\\mathbf{A}^T \\mathbf{A}$ 和向量 $\\mathbf{A}^T \\boldsymbol{\\sigma}$。$\\mathbf{A}^T \\mathbf{A}$ 的分量涉及坐标的幂和与乘积和：\n$$\n\\mathbf{A}^T \\mathbf{A} = \\begin{pmatrix} \\sum 1 & \\sum x_i & \\sum y_i \\\\ \\sum x_i & \\sum x_i^2 & \\sum x_i y_i \\\\ \\sum y_i & \\sum x_i y_i & \\sum y_i^2 \\end{pmatrix}\n$$\n我们来计算这 $N=6$ 个数据点的各项总和：\n$\\sum 1 = 6$\n$\\sum x_i = 1.0 - 1.0 + 0.0 + 0.0 + 1.0 - 1.0 = 0$\n$\\sum y_i = 0.0 + 0.0 + 1.0 - 1.0 + 1.0 - 1.0 = 0$\n$\\sum x_i^2 = (1.0)^2 + (-1.0)^2 + (0.0)^2 + (0.0)^2 + (1.0)^2 + (-1.0)^2 = 1.0 + 1.0 + 0.0 + 0.0 + 1.0 + 1.0 = 4.0$\n$\\sum y_i^2 = (0.0)^2 + (0.0)^2 + (1.0)^2 + (-1.0)^2 + (1.0)^2 + (-1.0)^2 = 0.0 + 0.0 + 1.0 + 1.0 + 1.0 + 1.0 = 4.0$\n$\\sum x_i y_i = (1.0)(0.0) + (-1.0)(0.0) + (0.0)(1.0) + (0.0)(-1.0) + (1.0)(1.0) + (-1.0)(-1.0) = 0.0 + 0.0 + 0.0 + 0.0 + 1.0 + 1.0 = 2.0$\n\n因此，矩阵 $\\mathbf{A}^T \\mathbf{A}$ 为：\n$$\n\\mathbf{A}^T \\mathbf{A} = \\begin{pmatrix} 6 & 0 & 0 \\\\ 0 & 4 & 2 \\\\ 0 & 2 & 4 \\end{pmatrix}\n$$\n接下来，我们计算向量 $\\mathbf{A}^T \\boldsymbol{\\sigma}$：\n$$\n\\mathbf{A}^T \\boldsymbol{\\sigma} = \\begin{pmatrix} \\sum \\sigma_{xx,i} \\\\ \\sum x_i \\sigma_{xx,i} \\\\ \\sum y_i \\sigma_{xx,i} \\end{pmatrix}\n$$\n我们来计算这些和：\n$\\sum \\sigma_{xx,i} = 122 + 79 + 91 + 107 + 110 + 92 = 601$\n$\\sum x_i \\sigma_{xx,i} = (1.0)(122) + (-1.0)(79) + (0.0)(91) + (0.0)(107) + (1.0)(110) + (-1.0)(92) = 122 - 79 + 110 - 92 = 43 + 18 = 61$\n$\\sum y_i \\sigma_{xx,i} = (0.0)(122) + (0.0)(79) + (1.0)(91) + (-1.0)(107) + (1.0)(110) + (-1.0)(92) = 91 - 107 + 110 - 92 = -16 + 18 = 2$\n\n所以，向量 $\\mathbf{A}^T \\boldsymbol{\\sigma}$ 为：\n$$\n\\mathbf{A}^T \\boldsymbol{\\sigma} = \\begin{pmatrix} 601 \\\\ 61 \\\\ 2 \\end{pmatrix}\n$$\n正规方程组为：\n$$\n\\begin{pmatrix} 6 & 0 & 0 \\\\ 0 & 4 & 2 \\\\ 0 & 2 & 4 \\end{pmatrix} \\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} 601 \\\\ 61 \\\\ 2 \\end{pmatrix}\n$$\n这给了我们一个由三个线性方程组成的方程组：\n1. $6 a_0 = 601$\n2. $4 a_1 + 2 a_2 = 61$\n3. $2 a_1 + 4 a_2 = 2$\n\n由方程(1)，我们立即求得 $a_0$：\n$$\na_0 = \\frac{601}{6}\n$$\n方程(2)和(3)构成一个关于 $a_1$ 和 $a_2$ 的 $2 \\times 2$ 方程组。我们可以解这个方程组。将方程(3)乘以 $2$：\n$$\n4 a_1 + 8 a_2 = 4\n$$\n用这个新方程减去方程(2)：\n$$\n(4 a_1 + 8 a_2) - (4 a_1 + 2 a_2) = 4 - 61\n$$\n$$\n6 a_2 = -57 \\implies a_2 = -\\frac{57}{6} = -\\frac{19}{2} = -9.5\n$$\n将 $a_2$ 代回方程(3)：\n$$\n2 a_1 + 4 (-9.5) = 2 \\implies 2 a_1 - 38 = 2 \\implies 2 a_1 = 40 \\implies a_1 = 20\n$$\n最佳拟合线性场的系数为：\n$$\na_0 = \\frac{601}{6}, \\quad a_1 = 20, \\quad a_2 = -9.5\n$$\n平滑后的应力场为：\n$$\n\\sigma_{xx}(x,y) = \\frac{601}{6} + 20 x - 9.5 y\n$$\n题目要求在节点 $(x,y) = (0,0)$ 处的恢复节点应力。我们计算拟合场在该点的值：\n$$\n\\sigma_{xx}(0,0) = a_0 + a_1(0) + a_2(0) = a_0 = \\frac{601}{6}\n$$\n现在，我们计算其数值并四舍五入到四位有效数字。\n$$\n\\sigma_{xx}(0,0) = \\frac{601}{6} \\approx 100.1666... \\, \\mathrm{MPa}\n$$\n四舍五入到四位有效数字，我们观察第五位有效数字。前四位是 $1, 0, 0, 1$。第五位是 $6$，大于或等于 $5$，因此我们将第四位数字向上取整。\n$$\n\\sigma_{xx}(0,0) \\approx 100.2 \\, \\mathrm{MPa}\n$$", "answer": "$$\n\\boxed{100.2}\n$$", "id": "3603832"}, {"introduction": "获得一个更精确的恢复应力场本身不是最终目的，其关键应用之一是进行后验误差估计，从而指导自适应网格划分。本练习将带您从恢复技术走向实际应用，演示如何计算著名的 Zienkiewicz-Zhu (ZZ) 误差指示子 [@problem_id:3604343]。您将通过比较恢复应力场 $\\sigma^{\\ast}$ 与原始有限元应力场 $\\sigma_{h}$ 之间的差异，并计算其在能量范数下的误差，来量化有限元解的局部误差。", "problem": "考虑一根长度为 $2$ 米的直、等截面一维弹性杆，使用两个相等的线性有限元进行建模，节点位于 $x=0$、$x=1$ 和 $x=2$。该杆具有恒定的横截面积 $A = 1.0 \\times 10^{-2}\\,\\text{m}^2$ 和杨氏模量 $E = 1.0 \\times 10^{7}\\,\\text{Pa}$。计算出的有限元节点位移为 $u(0)=0$、$u(1)=1.0 \\times 10^{-3}\\,\\text{m}$ 和 $u(2)=1.5 \\times 10^{-3}\\,\\text{m}$。\n\n您需要在线性弹性和小应变假设下，使用超收敛片恢复 (Superconvergent Patch Recovery, SPR) 方法构建一个 Zienkiewicz–Zhu (ZZ) 误差指示器。从基本定义 $\\varepsilon(x) = \\mathrm{d}u/\\mathrm{d}x$ 和 $\\sigma(x) = E \\, \\varepsilon(x)$ 出发，并将能量范数误差密度定义为本构逆与应力误差的乘积。\n\n执行以下步骤：\n\n1. 对于一个线性两节点单元，从 $\\varepsilon(x) = \\mathrm{d}u/\\mathrm{d}x$ 和 $\\sigma(x) = E \\, \\varepsilon(x)$ 出发，根据给定的节点位移计算每个单元上的分段常数有限元应力场 $\\sigma_{h}$。\n\n2. 使用位于单元中心 $x=0.5$ 和 $x=1.5$ 的两个超收敛采样点，通过限制在线性拟设 $\\sigma^{\\ast}(x) = c_{0} + c_{1} x$ 的基于片的最小二乘拟合，构建整个杆上的恢复应力场 $\\sigma^{\\ast}(x)$；将这些点上的目标值取为相应的单元有限元应力 $\\sigma_{h}$。\n\n3. 将此杆的 ZZ 能量范数误差指示器的平方定义为\n$$\n\\eta^{2} \\;=\\; \\sum_{e=1}^{2} \\int_{x_{e}}^{x_{e+1}} \\left(\\sigma^{\\ast}(x) - \\sigma_{h,e}\\right)^{2} \\,\\frac{A}{E}\\,\\mathrm{d}x,\n$$\n其中 $\\sigma_{h,e}$ 是单元 $e$ 上的常数有限元应力。使用在父区间 $[-1,1]$ 上的两点高斯-勒让德求积法，通过精确映射来计算每个单元积分，并说明为何该求积法对于此被积函数是精确的。\n\n将 $\\eta^{2}$ 明确计算为一个实数。以焦耳为单位表示最终的指示器能量，并将您的答案四舍五入到四位有效数字。", "solution": "问题陈述经评估有效。它内容自洽，科学上基于计算固体力学和有限元法 (FEM) 的原理，并且是适定的，提供了所有必要的数据和获得唯一解的清晰、客观的程序。\n\n该问题要求计算一个用两个线性有限元建模的一维弹性杆的 Zienkiewicz–Zhu (ZZ) 能量范数误差指示器的平方 $\\eta^2$。解答过程遵循问题中概述的三个步骤。\n\n给定的常数是：\n杨氏模量，$E = 1.0 \\times 10^{7}\\,\\text{Pa}$。\n横截面积，$A = 1.0 \\times 10^{-2}\\,\\text{m}^2$。\n比值 $A/E$ 是 $A/E = (1.0 \\times 10^{-2}) / (1.0 \\times 10^7) = 1.0 \\times 10^{-9}\\,\\text{m}^2/\\text{Pa}$。\n\n节点坐标为 $x_1 = 0\\,\\text{m}$、$x_2 = 1\\,\\text{m}$ 和 $x_3 = 2\\,\\text{m}$。\n节点位移为 $u_1 = u(0) = 0\\,\\text{m}$、$u_2 = u(1) = 1.0 \\times 10^{-3}\\,\\text{m}$ 和 $u_3 = u(2) = 1.5 \\times 10^{-3}\\,\\text{m}$。\n\n**1. 计算有限元应力场 $\\sigma_h$**\n\n对于一个从坐标 $x_a$ 延伸到 $x_b$，节点位移为 $u_a$ 和 $u_b$ 的一维两节点线性有限元，其位移场 $u(x)$ 通过线性插值给出：\n$$\nu(x) = u_a \\frac{x_b - x}{x_b - x_a} + u_b \\frac{x - x_a}{x_b - x_a}\n$$\n单元内的应变 $\\varepsilon(x) = \\mathrm{d}u/\\mathrm{d}x$ 是恒定的：\n$$\n\\varepsilon_h = \\frac{\\mathrm{d}u}{\\mathrm{d}x} = \\frac{u_b - u_a}{x_b - x_a}\n$$\n应力 $\\sigma(x) = E \\varepsilon(x)$ 也是恒定的，$\\sigma_h = E \\varepsilon_h$。\n\n对于单元 $1$（从 $x=0$ 到 $x=1$）：\n节点位移为 $u_1 = u(0) = 0$ 和 $u_2 = u(1) = 1.0 \\times 10^{-3}$。\n单元长度为 $L_1 = 1 - 0 = 1\\,\\text{m}$。\n应变为：\n$$\n\\varepsilon_{h,1} = \\frac{u(1) - u(0)}{1 - 0} = \\frac{1.0 \\times 10^{-3} - 0}{1} = 1.0 \\times 10^{-3}\n$$\n单元 1 中的应力为：\n$$\n\\sigma_{h,1} = E \\varepsilon_{h,1} = (1.0 \\times 10^{7} \\, \\text{Pa}) \\times (1.0 \\times 10^{-3}) = 1.0 \\times 10^{4} \\, \\text{Pa}\n$$\n\n对于单元 $2$（从 $x=1$ 到 $x=2$）：\n节点位移为 $u_2 = u(1) = 1.0 \\times 10^{-3}$ 和 $u_3 = u(2) = 1.5 \\times 10^{-3}$。\n单元长度为 $L_2 = 2 - 1 = 1\\,\\text{m}$。\n应变为：\n$$\n\\varepsilon_{h,2} = \\frac{u(2) - u(1)}{2 - 1} = \\frac{1.5 \\times 10^{-3} - 1.0 \\times 10^{-3}}{1} = 0.5 \\times 10^{-3} = 5.0 \\times 10^{-4}\n$$\n单元 2 中的应力为：\n$$\n\\sigma_{h,2} = E \\varepsilon_{h,2} = (1.0 \\times 10^{7} \\, \\text{Pa}) \\times (5.0 \\times 10^{-4}) = 5.0 \\times 10^{3} \\, \\text{Pa}\n$$\n\n**2. 构建恢复应力场 $\\sigma^{\\ast}(x)$**\n\n恢复应力场假定为位置的线性函数，$\\sigma^{\\ast}(x) = c_0 + c_1 x$。系数 $c_0$ 和 $c_1$ 通过使用超收敛点处的有限元应力进行最小二乘拟合来确定。对于线性单元，每个单元的中心是应力的超收敛点。\n采样点是单元的中心：单元 1 为 $x_{s1} = 0.5$，单元 2 为 $x_{s2} = 1.5$。\n拟合的目标值是每个单元内的常数有限元应力：$\\sigma_h(0.5) = \\sigma_{h,1}$ 和 $\\sigma_h(1.5) = \\sigma_{h,2}$。\n\n由于有两个参数（$c_0, c_1$）和两个采样点，最小二乘拟合变为精确插值。我们求解以下线性方程组：\n$$\n\\sigma^{\\ast}(0.5) = c_0 + c_1(0.5) = \\sigma_{h,1} = 1.0 \\times 10^4 \\\\\n\\sigma^{\\ast}(1.5) = c_0 + c_1(1.5) = \\sigma_{h,2} = 5.0 \\times 10^3\n$$\n用第二个方程减去第一个方程，得到：\n$$\n(c_0 + 1.5 c_1) - (c_0 + 0.5 c_1) = 5.0 \\times 10^3 - 1.0 \\times 10^4 \\\\\nc_1 = -5.0 \\times 10^3\n$$\n将 $c_1$ 代回第一个方程：\n$$\nc_0 + 0.5(-5.0 \\times 10^3) = 1.0 \\times 10^4 \\\\\nc_0 - 2.5 \\times 10^3 = 1.0 \\times 10^4 \\\\\nc_0 = 1.25 \\times 10^4\n$$\n因此，恢复应力场为：\n$$\n\\sigma^{\\ast}(x) = 1.25 \\times 10^4 - (5.0 \\times 10^3) x \\quad (\\text{单位 Pa})\n$$\n\n**3. 计算误差指示器的平方 $\\eta^2$**\n\nZZ 能量范数误差指示器的平方由下式给出：\n$$\n\\eta^{2} = \\sum_{e=1}^{2} \\int_{x_{e}}^{x_{e+1}} (\\sigma^{\\ast}(x) - \\sigma_{h,e})^{2} \\frac{A}{E} \\mathrm{d}x = \\frac{A}{E} \\left[ \\int_{0}^{1} (\\sigma^{\\ast}(x) - \\sigma_{h,1})^{2} \\mathrm{d}x + \\int_{1}^{2} (\\sigma^{\\ast}(x) - \\sigma_{h,2})^{2} \\mathrm{d}x \\right]\n$$\n每个单元的被积函数为：\n对于单元 1：$(\\sigma^{\\ast}(x) - \\sigma_{h,1})^2 = (1.25 \\times 10^4 - 5.0 \\times 10^3 x - 1.0 \\times 10^4)^2 = (2.5 \\times 10^3 - 5.0 \\times 10^3 x)^2$。\n对于单元 2：$(\\sigma^{\\ast}(x) - \\sigma_{h,2})^2 = (1.25 \\times 10^4 - 5.0 \\times 10^3 x - 5.0 \\times 10^3)^2 = (7.5 \\times 10^3 - 5.0 \\times 10^3 x)^2$。\n\n问题要求使用两点高斯-勒让德求积进行计算。该求积法则能精确地对最高为 $2n-1 = 2(2)-1 = 3$ 次的多项式进行积分。此处的被积函数都是二次多项式（次数为 2），因此两点法则将得出精确结果。\n\n设 $I_1 = \\int_{0}^{1} (2.5 \\times 10^3 - 5.0 \\times 10^3 x)^2 \\mathrm{d}x$ 且 $I_2 = \\int_{1}^{2} (7.5 \\times 10^3 - 5.0 \\times 10^3 x)^2 \\mathrm{d}x$。\n\n对于在 $[0,1]$ 上的积分 $I_1$：\n使用 $x = \\frac{1}{2}(\\xi+1)$ 将 $x \\in [0,1]$ 映射到 $\\xi \\in [-1,1]$，因此 $\\mathrm{d}x = \\frac{1}{2}\\mathrm{d}\\xi$。\n被积函数变为：$(2.5 \\times 10^3 - 5.0 \\times 10^3 \\frac{\\xi+1}{2})^2 = (2.5 \\times 10^3 - 2.5 \\times 10^3 (\\xi+1))^2 = (-2.5 \\times 10^3 \\xi)^2 = (6.25 \\times 10^6) \\xi^2$。\n所以，$I_1 = \\int_{-1}^{1} (6.25 \\times 10^6) \\xi^2 \\frac{1}{2} \\mathrm{d}\\xi = (3.125 \\times 10^6) \\int_{-1}^{1} \\xi^2 \\mathrm{d}\\xi$。\n两点高斯法则的求积点为 $\\xi = \\pm 1/\\sqrt{3}$，权重为 $w=1$。\n设 $f(\\xi) = (3.125 \\times 10^6) \\xi^2$。\n$I_1 = f(-1/\\sqrt{3}) \\cdot 1 + f(1/\\sqrt{3}) \\cdot 1 = (3.125 \\times 10^6) (-\\frac{1}{\\sqrt{3}})^2 + (3.125 \\times 10^6) (\\frac{1}{\\sqrt{3}})^2 = 2 \\times (3.125 \\times 10^6) (\\frac{1}{3}) = \\frac{6.25 \\times 10^6}{3}$。\n\n对于在 $[1,2]$ 上的积分 $I_2$：\n使用 $x = \\frac{1}{2}(\\xi+3)$ 将 $x \\in [1,2]$ 映射到 $\\xi \\in [-1,1]$，因此 $\\mathrm{d}x = \\frac{1}{2}\\mathrm{d}\\xi$。\n被积函数变为：$(7.5 \\times 10^3 - 5.0 \\times 10^3 \\frac{\\xi+3}{2})^2 = (7.5 \\times 10^3 - 2.5 \\times 10^3 (\\xi+3))^2 = (7.5 \\times 10^3 - 2.5 \\times 10^3 \\xi - 7.5 \\times 10^3)^2 = (-2.5 \\times 10^3 \\xi)^2 = (6.25 \\times 10^6) \\xi^2$。\n在父坐标系中，积分 $I_2$ 与 $I_1$ 相同：\n$I_2 = \\int_{-1}^{1} (6.25 \\times 10^6) \\xi^2 \\frac{1}{2} \\mathrm{d}\\xi = \\frac{6.25 \\times 10^6}{3}$。\n\n总平方误差：\n$$\n\\eta^2 = \\frac{A}{E} (I_1 + I_2) = (1.0 \\times 10^{-9}) \\left( \\frac{6.25 \\times 10^6}{3} + \\frac{6.25 \\times 10^6}{3} \\right)\n$$\n$$\n\\eta^2 = (1.0 \\times 10^{-9}) \\left( 2 \\times \\frac{6.25 \\times 10^6}{3} \\right) = (1.0 \\times 10^{-9}) \\left( \\frac{12.5 \\times 10^6}{3} \\right)\n$$\n$$\n\\eta^2 = \\frac{12.5}{3} \\times 10^{-3} \\approx 4.1666... \\times 10^{-3}\n$$\n$\\eta^2$ 的单位是 $(\\text{m}^2/\\text{Pa}) \\times (\\text{Pa}^2 \\cdot \\text{m}) = \\text{N} \\cdot \\text{m} = \\text{J}$。\n将结果四舍五入到四位有效数字，得到：\n$$\n\\eta^2 = 4.167 \\times 10^{-3} \\, \\text{J}\n$$", "answer": "$$\n\\boxed{4.167 \\times 10^{-3}}\n$$", "id": "3604343"}, {"introduction": "将理论知识转化为实际的计算工具是掌握任何数值方法的关键一步。这项综合性编程练习旨在让您从头开始实现一个完整的超收敛节点恢复方案 [@problem_id:3272888]。您将需要处理网格数据结构、计算单元梯度、组建节点邻域、执行最小二乘拟合并最终评估恢复效果，通过这个过程全面巩固您对 SPR 算法所有环节的理解。", "problem": "您需要在一个使用分片线性三角形单元形函数的有限元法（FEM）背景下，实现一个超收敛片修复（Superconvergent Patch Recovery）方案。目标是通过对从周围单元计算出的梯度进行最小二乘拟合，来计算每个网格节点上更精确的梯度。这项工作必须基于数值方法和科学计算的基本原理。\n\n起点和核心定义：\n- 考虑一个在二维域上定义的标量场 $u(x,y)$，该场使用三角形单元通过分片线性有限元函数进行近似。每个单元使用与其顶点相关联的线性拉格朗日形函数。在每个三角形内部，近似解可以表示为一个仿射函数 $u_h(x,y) = a + b x + c y$，其中 $a$、$b$ 和 $c$ 是由节点值决定的系数。单元梯度 $\\nabla u_h$ 在一个三角形内是常数。\n- 单元梯度是通过使用形函数的定义和仿射函数的梯度在单元内为常数的性质，从节点值计算得出的。题目陈述中未提供快捷公式；请从仿射插值的定义和基本线性代数推导。\n- 超收敛片修复旨在通过对共享该节点的所有单元的单元梯度集进行最小二乘拟合，来恢复节点 $(x_i,y_i)$ 处的节点梯度 $\\nabla u^*(x_i,y_i)$。对每个梯度分量使用一个仿射模型：在片（patch）内的单元采样点上，使用仿射形式独立地拟合 $g_x(x,y)$ 和 $g_y(x,y)$。\n\n任务要求：\n1. 构建三角形网格并使用分片线性形函数来计算离散场 $u_h(x,y)$ 的单元梯度。为完成此任务，将解析目标场定义为 $u(x,y) = \\sin(\\pi x)\\cos(\\pi y)$，其中 $\\pi$ 表示圆周常数。角度必须以弧度处理。精确的解析梯度为 $\\nabla u(x,y) = \\left(\\pi \\cos(\\pi x)\\cos(\\pi y),\\,-\\pi \\sin(\\pi x)\\sin(\\pi y)\\right)$。\n2. 对于每个节点 $(x_i,y_i)$，形成其包含该节点的所有单元组成的片（patch）。对于片中的每个单元，计算其单元梯度 $\\nabla u_h$，并与该单元的一个代表性采样位置 $(x_e,y_e)$（取单元形心）一同记录。\n3. 对于每个节点，使用仿射模型通过最小二乘法将其片中收集到的单元梯度数据拟合为 $g_x(x,y)$ 和 $g_y(x,y)$。如果片是欠定或病态的（例如，少于 $3$ 个采样点或数值上奇异），则回退到等于片中单元梯度平均值的常数模型，以确保数值鲁棒性。\n4. 通过在 $(x_i,y_i)$ 处评估拟合模型，计算节点坐标处的修复后梯度，以获得 $\\nabla u^*(x_i,y_i)$。\n5. 将原始节点梯度近似定义为节点片上单元梯度的平均值。将修复后的节点梯度定义为通过最小二乘拟合得到的 $\\nabla u^*(x_i,y_i)$。计算所有节点上原始梯度和修复后梯度的平均节点误差，该误差为每个节点上近似梯度与精确解析梯度之差的欧几里得范数的平均值。\n6. 对于每个测试用例，计算改善率，定义为平均原始梯度误差除以平均修复后梯度误差。大于 $1$ 的值表示有所改善。\n7. 在计算三角函数时，所有角度必须以弧度解释。\n\n测试套件：\n在以下网格配置上实现并评估算法：\n- 案例 1：单位正方形 $[0,1]\\times[0,1]$ 上的均匀矩形网格，有 $n_x = 8$, $n_y = 8$ 个矩形单元，每个单元沿交替的对角线方向分裂成两个三角形以避免偏差。\n- 案例 2：单位正方形 $[0,1]\\times[0,1]$ 上的较粗糙的矩形网格，有 $n_x = 3$, $n_y = 3$ 个矩形单元，按上述方式分裂。\n- 案例 3：单位正方形 $[0,1]\\times[0,1]$ 上的各向异性矩形网格，有 $n_x = 12$, $n_y = 4$ 个矩形单元，按上述方式分裂。\n- 案例 4：顶点为 $(0,0)$、$(1,0)$ 和 $(0,1)$ 的单个三角形域。\n\n输出规范：\n- 对于 4 个案例中的每一个，计算第 6 项中定义的改善率。\n- 您的程序应生成一行输出，其中包含 4 个改善率，格式为逗号分隔的列表并用方括号括起，每个比率四舍五入到 6 位小数（例如，$[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个四舍五入到 6 位小数的浮点数）。", "solution": "用户的请求是实现并评估一个超收敛片修复（Superconvergent Patch Recovery, SPR）方案，用于计算使用分片线性三角形有限元近似的标量场的梯度。该问题具有科学依据，是适定且客观的。它概述了一种标准且可验证的数值方法，提供了所有必要的定义、测试用例和评估指标。因此，该问题被认为是有效的。\n\n解决方案是基于有限元法（FEM）和数值线性代数的基本原理开发的。我们将首先建立单元梯度计算和SPR技术的理论框架，然后描述算法实现和误差分析。\n\n**1. 有限元近似和单元梯度**\n\n我们考虑一个标量场 $u(x,y)$，它在一个被划分为三角形单元的域上进行近似。在每个单元内，离散场 $u_h(x,y)$ 是节点值 $u_i$ 与线性拉格朗日形函数 $N_i(x,y)$ 的线性组合：\n$$u_h(x,y) = \\sum_{i=1}^{3} N_i(x,y) u_i$$\n其中求和遍及三角形的三个顶点。由于形函数是关于位置 $(x,y)$ 的线性函数，单元内的近似 $u_h(x,y)$ 是一个仿射函数，形式为：\n$$u_h(x,y) = a + b x + c y$$\n该函数的梯度 $\\nabla u_h$ 在整个单元内是恒定的：\n$$\\nabla u_h = \\begin{pmatrix} \\frac{\\partial u_h}{\\partial x} \\\\ \\frac{\\partial u_h}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} b \\\\ c \\end{pmatrix}$$\n系数 $(a, b, c)$ 通过要求函数在单元顶点 $(x_1, y_1)$、$(x_2, y_2)$ 和 $(x_3, y_3)$ 处与节点值 $(u_1, u_2, u_3)$ 相匹配来确定。这产生一个线性方程组：\n$$\n\\begin{pmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ 1 & x_3 & y_3 \\end{pmatrix}\n\\begin{pmatrix} a \\\\ b \\\\ c \\end{pmatrix} =\n\\begin{pmatrix} u_1 \\\\ u_2 \\\\ u_3 \\end{pmatrix}\n$$\n求解该系统以获得梯度分量 $(b,c)$，可得：\n$$\nb = \\frac{\\partial u_h}{\\partial x} = \\frac{1}{2A} \\left[ (y_2 - y_3)u_1 + (y_3 - y_1)u_2 + (y_1 - y_2)u_3 \\right]\n$$\n$$\nc = \\frac{\\partial u_h}{\\partial y} = \\frac{1}{2A} \\left[ (x_3 - x_2)u_1 + (x_1 - x_3)u_2 + (x_2 - x_1)u_3 \\right]\n$$\n其中 $A$ 是三角形单元的面积，计算公式为：\n$$A = \\frac{1}{2} \\det \\begin{pmatrix} x_1 & y_1 & 1 \\\\ x_2 & y_2 & 1 \\\\ x_3 & y_3 & 1 \\end{pmatrix} = \\frac{1}{2} \\left[ x_1(y_2 - y_3) + x_2(y_3 - y_1) + x_3(y_1 - y_2) \\right]$$\n众所周知，这种单元梯度在单元域内的精度低于在单元内某些特定点（称为超收敛点）的精度。\n\n**2. 超收敛片修复 (SPR)**\n\nSPR是一种后处理技术，用于获得在网格节点上定义的、更精确的连续梯度场。对于给定节点 $(x_i, y_i)$ 的处理流程如下：\n\n- **片(Patch)的定义：** 形成一个“片”，由共享节点 $(x_i, y_i)$ 的所有单元组成。\n- **数据收集：** 对于片中的每个单元 $k$，我们有一对数据：常数单元梯度 $(\\nabla u_h)_k$ 和一个代表性采样位置 $(x_e, y_e)_k$，这里取为单元的形心。\n- **最小二乘拟合：** 将一个连续的低阶多项式模型拟合到来自片的离散梯度数据。我们对每个梯度分量独立使用一个仿射模型：\n  $$g_x(x,y) = c_{0x} + c_{1x}x + c_{2x}y$$\n  $$g_y(x,y) = c_{0y} + c_{1y}x + c_{2y}y$$\n  设片由 $M$ 个单元组成，在形心 $\\{ (x_k, y_k) \\}_{k=1}^M$ 处产生梯度数据 $\\{ (\\nabla u_h)_k = (g_{xk}, g_{yk}) \\}_{k=1}^M$。为求得 $g_x$ 的系数，我们在最小二乘意义下求解超定系统 $\\mathbf{A}\\mathbf{c}_x = \\mathbf{g}_x$：\n  $$\n  \\underbrace{\\begin{pmatrix} 1 & x_1 & y_1 \\\\ 1 & x_2 & y_2 \\\\ \\vdots & \\vdots & \\vdots \\\\ 1 & x_M & y_M \\end{pmatrix}}_{\\mathbf{A}}\n  \\underbrace{\\begin{pmatrix} c_{0x} \\\\ c_{1x} \\\\ c_{2x} \\end{pmatrix}}_{\\mathbf{c}_x} =\n  \\underbrace{\\begin{pmatrix} g_{x1} \\\\ g_{x2} \\\\ \\vdots \\\\ g_{xM} \\end{pmatrix}}_{\\mathbf{g}_x}\n  $$\n  最小二乘解通过正规方程 $\\mathbf{A}^T\\mathbf{A}\\mathbf{c}_x = \\mathbf{A}^T\\mathbf{g}_x$ 求得。对 $y$ 分量重复此过程以求得 $\\mathbf{c}_y$。\n- **鲁棒性：** 为了唯一的仿射拟合，需要至少 $3$ 个非共线的采样点（形心）。如果单元数 $M  3$，或者矩阵 $\\mathbf{A}$ 秩亏（即形心共线），则系统是病态的。在这种情况下，我们回退到常数模型，其中修复后的梯度就是片中单元梯度的简单平均值。\n- **修复后的梯度：** 修复后的节点梯度 $\\nabla u^*(x_i, y_i)$ 是通过在节点自身坐标 $(x_i, y_i)$ 处评估拟合的仿射模型得到的：\n  $$\\nabla u^*(x_i, y_i) = \\begin{pmatrix} g_x(x_i, y_i) \\\\ g_y(x_i, y_i) \\end{pmatrix}$$\n\n**3. 误差评估与改善率**\n\n为了量化SPR的有效性，我们将“修复后”的梯度与“原始”近似梯度以及精确的解析梯度进行比较。\n- **解析场：** 问题指定场为 $u(x,y) = \\sin(\\pi x)\\cos(\\pi y)$。\n- **精确梯度：** 精确梯度为 $\\nabla u(x,y) = \\left(\\pi \\cos(\\pi x)\\cos(\\pi y),\\,-\\pi \\sin(\\pi x)\\sin(\\pi y)\\right)$。\n- **原始节点梯度：** 对每个节点，这被定义为其片中所有单元的常数梯度的简单平均值。\n- **平均节点误差：** 在每个节点 $i$ 处，误差计算为近似梯度 ($\\nabla u_{approx}$) 与精确梯度 ($\\nabla u$) 之差的欧几里得范数：$E_i = \\|\\nabla u_{approx}(x_i, y_i) - \\nabla u(x_i, y_i)\\|_2$。平均节点误差是这些误差在网格中所有节点上的平均值。\n- **改善率：** 最终的度量标准是平均原始梯度误差与平均修复后梯度误差之比：\n  $$\\text{改善率} = \\frac{\\text{平均原始梯度误差}}{\\text{平均修复后梯度误差}}$$\n  大于 $1$ 的比率表明SPR提高了梯度精度。\n\n**4. 算法步骤**\n\n对于每个测试用例，算法按以下步骤进行：\n1.  **网格生成：** 为指定的网格配置构建节点坐标数组和单元连接数组。对于矩形域，创建一个 $n_x \\times n_y$ 单元的网格，每个单元使用交替对角线分裂成两个三角形。\n2.  **节点值计算：** 在每个节点处评估解析函数 $u(x,y)$ 以获得节点值 $u_i$。\n3.  **单元计算：** 对每个单元，使用其节点值和坐标计算其常数梯度 $\\nabla u_h$，并计算其形心。\n4.  **片(Patch)的组装：** 创建一个从每个节点索引到其片所属单元索引列表的映射。\n5.  **节点梯度修复和误差计算：** 遍历网格中的每个节点：\n    a. 识别片中的单元，并收集它们预先计算好的梯度和形心。\n    b. 通过平均片梯度来计算原始节点梯度。\n    c. 判断片是否适合进行仿射拟合（$M \\ge 3$ 且形心不共线）。\n    d. 如果条件良好，执行最小二乘拟合，求出 $g_x$ 和 $g_y$ 的系数。在节点坐标处评估这些模型以获得修复后的梯度 $\\nabla u^*$。\n    e. 如果条件病态，将修复后的梯度设置为等于原始梯度。\n    f. 在节点坐标处计算精确梯度。\n    g. 计算并累加原始梯度和修复后梯度的节点误差。\n6.  **最终度量：** 处理完所有节点后，计算平均原始误差和平均修复后误差。计算它们的比率以获得最终的改善率。对所有四个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef u_analytic(x, y):\n    \"\"\"Computes the analytic scalar field u(x,y).\"\"\"\n    return np.sin(np.pi * x) * np.cos(np.pi * y)\n\ndef grad_u_analytic(x, y):\n    \"\"\"Computes the analytic gradient of the scalar field u(x,y).\"\"\"\n    grad_x = np.pi * np.cos(np.pi * x) * np.cos(np.pi * y)\n    grad_y = -np.pi * np.sin(np.pi * x) * np.sin(np.pi * y)\n    return np.array([grad_x, grad_y])\n\ndef generate_rect_mesh(nx, ny):\n    \"\"\"Generates a triangular mesh on the unit square.\"\"\"\n    x_coords = np.linspace(0.0, 1.0, nx + 1)\n    y_coords = np.linspace(0.0, 1.0, ny + 1)\n    nodes = np.array([[x, y] for y in y_coords for x in x_coords])\n    \n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            # Node indices for the rectangular cell (i,j)\n            n1 = j * (nx + 1) + i          # bottom-left\n            n2 = j * (nx + 1) + (i + 1)    # bottom-right\n            n3 = (j + 1) * (nx + 1) + i    # top-left\n            n4 = (j + 1) * (nx + 1) + (i + 1) # top-right\n            \n            # Alternating diagonal split to avoid mesh bias\n            if (i + j) % 2 == 0:\n                # Diagonal from bottom-left to top-right\n                elements.append([n1, n2, n4])\n                elements.append([n1, n4, n3])\n            else:\n                # Diagonal from bottom-right to top-left\n                elements.append([n1, n2, n3])\n                elements.append([n2, n4, n3])\n                \n    return nodes, np.array(elements, dtype=int)\n\ndef generate_single_tri_mesh():\n    \"\"\"Generates a mesh with a single triangle.\"\"\"\n    nodes = np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]])\n    elements = np.array([[0, 1, 2]], dtype=int)\n    return nodes, elements\n\ndef compute_element_gradient(node_coords, u_elem_nodes):\n    \"\"\"Computes the constant gradient for a single linear triangular element.\"\"\"\n    (x1, y1), (x2, y2), (x3, y3) = node_coords\n    u1, u2, u3 = u_elem_nodes\n    \n    # Using the formulation based on shape function derivatives\n    area2 = x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)\n    if abs(area2)  1e-15:\n        return np.zeros(2) # Degenerate triangle\n        \n    grad_x = ((y2 - y3) * u1 + (y3 - y1) * u2 + (y1 - y2) * u3) / area2\n    grad_y = ((x3 - x2) * u1 + (x1 - x3) * u2 + (x2 - x1) * u3) / area2\n    \n    return np.array([grad_x, grad_y])\n\ndef solve():\n    \"\"\"Main function to run the SPR analysis for all test cases.\"\"\"\n    test_cases = [\n        {'type': 'rect', 'nx': 8, 'ny': 8},\n        {'type': 'rect', 'nx': 3, 'ny': 3},\n        {'type': 'rect', 'nx': 12, 'ny': 4},\n        {'type': 'single_tri'},\n    ]\n\n    results = []\n    for case in test_cases:\n        # 1. Generate mesh (nodes, elements)\n        if case['type'] == 'rect':\n            nodes, elements = generate_rect_mesh(case['nx'], case['ny'])\n        else:\n            nodes, elements = generate_single_tri_mesh()\n        \n        num_nodes = len(nodes)\n        num_elements = len(elements)\n\n        # 2. Compute nodal values from analytic function\n        u_nodal = u_analytic(nodes[:, 0], nodes[:, 1])\n\n        # 3. Compute element-wise gradients and centroids\n        elem_gradients = np.zeros((num_elements, 2))\n        elem_centroids = np.zeros((num_elements, 2))\n        for i, elem_node_indices in enumerate(elements):\n            node_coords = nodes[elem_node_indices]\n            u_vals = u_nodal[elem_node_indices]\n            elem_gradients[i] = compute_element_gradient(node_coords, u_vals)\n            elem_centroids[i] = np.mean(node_coords, axis=0)\n\n        # 4. Build node-to-element mapping (patches)\n        node_to_elements = [[] for _ in range(num_nodes)]\n        for i, elem_node_indices in enumerate(elements):\n            for node_idx in elem_node_indices:\n                node_to_elements[node_idx].append(i)\n\n        # 5. Loop through nodes to compute errors\n        total_raw_error = 0.0\n        total_recovered_error = 0.0\n\n        for i in range(num_nodes):\n            node_coord = nodes[i]\n            patch_elem_indices = node_to_elements[i]\n            \n            if not patch_elem_indices:\n                continue\n\n            patch_gradients = elem_gradients[patch_elem_indices]\n            patch_centroids = elem_centroids[patch_elem_indices]\n\n            # Raw gradient: simple average of gradients in the patch\n            raw_gradient = np.mean(patch_gradients, axis=0)\n\n            # Recovered gradient: via least-squares fit\n            recovered_gradient = None\n            M = len(patch_elem_indices)\n\n            # Build the matrix A for the least-squares system\n            A = np.ones((M, 3))\n            A[:, 1:] = patch_centroids\n            \n            # Fallback condition: not enough points or centroids are collinear\n            if M  3 or np.linalg.matrix_rank(A)  3:\n                recovered_gradient = raw_gradient\n            else:\n                # Solve for coefficients for gx and gy using lstsq for robustness\n                gx_coeffs, _, _, _ = np.linalg.lstsq(A, patch_gradients[:, 0], rcond=None)\n                gy_coeffs, _, _, _ = np.linalg.lstsq(A, patch_gradients[:, 1], rcond=None)\n\n                # Evaluate the fitted affine models at the node's coordinate\n                node_vec = np.array([1, node_coord[0], node_coord[1]])\n                rec_grad_x = node_vec @ gx_coeffs\n                rec_grad_y = node_vec @ gy_coeffs\n                recovered_gradient = np.array([rec_grad_x, rec_grad_y])\n\n            # Compute exact gradient\n            exact_grad = grad_u_analytic(node_coord[0], node_coord[1])\n            \n            # Calculate and accumulate L2 norm of the error vector\n            raw_error = np.linalg.norm(raw_gradient - exact_grad)\n            recovered_error = np.linalg.norm(recovered_gradient - exact_grad)\n            \n            total_raw_error += raw_error\n            total_recovered_error += recovered_error\n\n        # 6. Calculate mean errors and the improvement ratio\n        mean_raw_error = total_raw_error / num_nodes if num_nodes > 0 else 0.0\n        mean_recovered_error = total_recovered_error / num_nodes if num_nodes > 0 else 0.0\n\n        if mean_recovered_error > 1e-15:\n            ratio = mean_raw_error / mean_recovered_error\n        else: # If both errors are zero or tiny, there's no improvement\n            ratio = 1.0\n\n        results.append(ratio)\n\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n\n```", "id": "3272888"}]}