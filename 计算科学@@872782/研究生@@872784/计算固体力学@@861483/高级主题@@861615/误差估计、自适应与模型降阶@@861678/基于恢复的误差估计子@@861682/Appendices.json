{"hands_on_practices": [{"introduction": "基于恢复的误差估计的核心在于，我们通过将一个光滑的多项式拟合到离散的有限元应力采样点，来构造一个更精确的连续应力场。这个过程通常采用加权最小二乘法来确定多项式的系数。本练习旨在揭示这一过程背后的数学机制，通过推导并构建一个线性多项式拟合的法方程组，使你能够深入理解超收敛恢复 (SPR) 方法的内在工作原理。", "problem": "考虑在节点周围的局部片元上，二维线弹性问题中单个面内应力分量的超收敛片元恢复（Superconvergent Patch Recovery, SPR）。设恢复的应力场由一个多项式拟设来近似，其系数收集在向量 $\\mathbf{a} \\in \\mathbb{R}^{3}$ 中，使用由 $\\phi_{1}(x,y)=1$、$\\phi_{2}(x,y)=x$ 和 $\\phi_{3}(x,y)=y$ 定义的基 $\\{\\phi_{1},\\phi_{2},\\phi_{3}\\}$。假设有 $N$ 个采样点，索引为 $m=1,\\dots,N$，其无量纲局部坐标为 $(x_{m},y_{m})$，权重为 $w_{m} \\ge 0$，有限元样本应力为 $s_{m}$。\n\n定义加权最小二乘泛函\n$$\nJ(\\mathbf{a})=\\sum_{m=1}^{N} w_{m}\\,\\bigg(\\sum_{i=1}^{3} a_{i}\\,\\phi_{i}(x_{m},y_{m}) - s_{m}\\bigg)^{2}.\n$$\n从该泛函和有限维优化的变分法出发，推导其最小化子的正规方程组，并证明它们可以写成一个线性系统的形式，该系统由一个对称矩阵乘以 $\\mathbf{a}$ 和一个由加权数据构成的右端向量组成。然后，对于下面的具体数据，显式地构造该系统的矩阵和向量，并计算该矩阵的行列式。\n\n使用以下包含 $N=4$ 个点的采样集：\n- 点 $m=1$：$(x_{1},y_{1})=(0,0)$，$w_{1}=1$，$s_{1}=2$。\n- 点 $m=2$：$(x_{2},y_{2})=(1,0)$，$w_{2}=2$，$s_{2}=3$。\n- 点 $m=3$：$(x_{3},y_{3})=(0,1)$，$w_{3}=1$，$s_{3}=4$。\n- 点 $m=4$：$(x_{4},y_{4})=(1,1)$，$w_{4}=3$，$s_{4}=6$。\n\n在构建系统之后，讨论在一般情况下，对于基 $\\{1,x,y\\}$ 和非负权重，正规方程组中的矩阵是可逆的条件。你最终报告的答案必须是上述给定数据下矩阵的行列式，表示为一个没有单位的精确整数。不需要四舍五入。所有坐标都是无量纲的，因此所有量都没有单位。", "solution": "### 步骤 1：推导正规方程组\n待最小化的加权最小二乘泛函由下式给出\n$$\nJ(\\mathbf{a})=\\sum_{m=1}^{N} w_{m}\\,\\bigg(\\sum_{i=1}^{3} a_{i}\\,\\phi_{i}(x_{m},y_{m}) - s_{m}\\bigg)^{2}.\n$$\n代入给定的基函数 $\\phi_{1}(x,y)=1$、$\\phi_{2}(x,y)=x$ 和 $\\phi_{3}(x,y)=y$，泛函变为\n$$\nJ(\\mathbf{a})=\\sum_{m=1}^{N} w_{m}\\,\\left(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}\\right)^{2}.\n$$\n为了找到最小化该泛函的系数 $\\mathbf{a}=[a_1, a_2, a_3]^T$，我们必须将 $J(\\mathbf{a})$ 对每个系数 $a_{k}$ 的偏导数设为零。这是凸泛函 $J$ 取得最小值的必要条件。对于 $k=1, 2, 3$：\n$$\n\\frac{\\partial J}{\\partial a_{k}} = 0.\n$$\n我们来计算这些偏导数。\n对于 $k=1$：\n$$\n\\frac{\\partial J}{\\partial a_{1}} = \\sum_{m=1}^{N} 2w_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) \\frac{\\partial}{\\partial a_1}(a_{1} + a_{2}x_{m} + a_{3}y_{m}) = \\sum_{m=1}^{N} 2w_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) = 0.\n$$\n对于 $k=2$：\n$$\n\\frac{\\partial J}{\\partial a_{2}} = \\sum_{m=1}^{N} 2w_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) \\frac{\\partial}{\\partial a_2}(a_{1} + a_{2}x_{m} + a_{3}y_{m}) = \\sum_{m=1}^{N} 2w_{m}x_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) = 0.\n$$\n对于 $k=3$：\n$$\n\\frac{\\partial J}{\\partial a_{3}} = \\sum_{m=1}^{N} 2w_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) \\frac{\\partial}{\\partial a_3}(a_{1} + a_{2}x_{m} + a_{3}y_{m}) = \\sum_{m=1}^{N} 2w_{m}y_{m}\\,(a_{1} + a_{2}x_{m} + a_{3}y_{m} - s_{m}) = 0.\n$$\n我们可以将每个方程除以 $2$ 并重新整理各项，以将未知系数 $a_i$ 与已知数据 $s_m$ 分开。\n由 $\\frac{\\partial J}{\\partial a_{1}} = 0$ 得：\n$$\na_{1}\\left(\\sum_{m=1}^{N} w_{m}\\right) + a_{2}\\left(\\sum_{m=1}^{N} w_{m}x_{m}\\right) + a_{3}\\left(\\sum_{m=1}^{N} w_{m}y_{m}\\right) = \\sum_{m=1}^{N} w_{m}s_{m}.\n$$\n由 $\\frac{\\partial J}{\\partial a_{2}} = 0$ 得：\n$$\na_{1}\\left(\\sum_{m=1}^{N} w_{m}x_{m}\\right) + a_{2}\\left(\\sum_{m=1}^{N} w_{m}x_{m}^2\\right) + a_{3}\\left(\\sum_{m=1}^{N} w_{m}x_{m}y_{m}\\right) = \\sum_{m=1}^{N} w_{m}x_{m}s_{m}.\n$$\n由 $\\frac{\\partial J}{\\partial a_{3}} = 0$ 得：\n$$\na_{1}\\left(\\sum_{m=1}^{N} w_{m}y_{m}\\right) + a_{2}\\left(\\sum_{m=1}^{N} w_{m}x_{m}y_{m}\\right) + a_{3}\\left(\\sum_{m=1}^{N} w_{m}y_{m}^2\\right) = \\sum_{m=1}^{N} w_{m}y_{m}s_{m}.\n$$\n这个包含三个未知数 $a_1, a_2, a_3$ 的三个线性方程组构成了正规方程组。它可以写成矩阵形式 $\\mathbf{M}\\mathbf{a} = \\mathbf{b}$，其中：\n$$\n\\mathbf{M} = \\begin{pmatrix}\n\\sum w_m & \\sum w_m x_m & \\sum w_m y_m \\\\\n\\sum w_m x_m & \\sum w_m x_m^2 & \\sum w_m x_m y_m \\\\\n\\sum w_m y_m & \\sum w_m x_m y_m & \\sum w_m y_m^2\n\\end{pmatrix},\n\\quad \\mathbf{a} = \\begin{pmatrix} a_1 \\\\ a_2 \\\\ a_3 \\end{pmatrix},\n\\quad \\mathbf{b} = \\begin{pmatrix}\n\\sum w_m s_m \\\\\n\\sum w_m x_m s_m \\\\\n\\sum w_m y_m s_m\n\\end{pmatrix}.\n$$\n矩阵 $\\mathbf{M}$ 是对称的，因为 $M_{ij} = M_{ji}$。例如，$M_{12} = \\sum w_m x_m = M_{21}$，$M_{13} = \\sum w_m y_m = M_{31}$，以及 $M_{23} = \\sum w_m x_m y_m = M_{32}$。\n\n### 步骤 2：使用具体数据构造系统并计算行列式\n接下来，我们使用所提供的 $N=4$ 个点的数据来构造 $\\mathbf{M}$ 和 $\\mathbf{b}$。\n数据如下：\n$(x_1, y_1)=(0,0), w_1=1, s_1=2$\n$(x_2, y_2)=(1,0), w_2=2, s_2=3$\n$(x_3, y_3)=(0,1), w_3=1, s_3=4$\n$(x_4, y_4)=(1,1), w_4=3, s_4=6$\n\n我们计算矩阵 $\\mathbf{M}$ 所需的各项和：\n$M_{11} = \\sum w_m = 1+2+1+3 = 7$。\n$M_{12} = M_{21} = \\sum w_m x_m = 1(0) + 2(1) + 1(0) + 3(1) = 0+2+0+3 = 5$。\n$M_{13} = M_{31} = \\sum w_m y_m = 1(0) + 2(0) + 1(1) + 3(1) = 0+0+1+3 = 4$。\n$M_{22} = \\sum w_m x_m^2 = 1(0^2) + 2(1^2) + 1(0^2) + 3(1^2) = 0+2+0+3 = 5$。\n$M_{23} = M_{32} = \\sum w_m x_m y_m = 1(0)(0) + 2(1)(0) + 1(0)(1) + 3(1)(1) = 0+0+0+3 = 3$。\n$M_{33} = \\sum w_m y_m^2 = 1(0^2) + 2(0^2) + 1(1^2) + 3(1^2) = 0+0+1+3 = 4$。\n\n因此，矩阵 $\\mathbf{M}$ 是：\n$$\n\\mathbf{M} = \\begin{pmatrix}\n7 & 5 & 4 \\\\\n5 & 5 & 3 \\\\\n4 & 3 & 4\n\\end{pmatrix}.\n$$\n(我们不需要为本问题计算 $\\mathbf{b}$，但作为完整性展示，其计算过程如下)\n$b_1 = \\sum w_m s_m = 1(2)+2(3)+1(4)+3(6) = 2+6+4+18 = 30$。\n$b_2 = \\sum w_m x_m s_m = 1(0)(2)+2(1)(3)+1(0)(4)+3(1)(6) = 0+6+0+18 = 24$。\n$b_3 = \\sum w_m y_m s_m = 1(0)(2)+2(0)(3)+1(1)(4)+3(1)(6) = 0+0+4+18 = 22$。\n\n问题要求计算矩阵 $\\mathbf{M}$ 的行列式。\n$$\n\\det(\\mathbf{M}) = \\det\\begin{pmatrix}\n7 & 5 & 4 \\\\\n5 & 5 & 3 \\\\\n4 & 3 & 4\n\\end{pmatrix}\n$$\n沿第一行使用余子式展开：\n$$\n\\det(\\mathbf{M}) = 7\\begin{vmatrix} 5 & 3 \\\\ 3 & 4 \\end{vmatrix} - 5\\begin{vmatrix} 5 & 3 \\\\ 4 & 4 \\end{vmatrix} + 4\\begin{vmatrix} 5 & 5 \\\\ 4 & 3 \\end{vmatrix}\n$$\n$$\n\\det(\\mathbf{M}) = 7(5 \\cdot 4 - 3 \\cdot 3) - 5(5 \\cdot 4 - 3 \\cdot 4) + 4(5 \\cdot 3 - 5 \\cdot 4)\n$$\n$$\n\\det(\\mathbf{M}) = 7(20 - 9) - 5(20 - 12) + 4(15 - 20)\n$$\n$$\n\\det(\\mathbf{M}) = 7(11) - 5(8) + 4(-5)\n$$\n$$\n\\det(\\mathbf{M}) = 77 - 40 - 20 = 17.\n$$\n矩阵的行列式是 $17$。\n\n### 步骤 3：讨论可逆性条件\n矩阵 $\\mathbf{M}$ 可逆当且仅当其行列式不为零。$\\mathbf{M}$ 是一个格拉姆矩阵（Gram matrix）。它奇异当且仅当构成它的基向量（在加权内积的意义下）是线性相关的。对于基 $\\{1,x,y\\}$，这意味着存在一个非零向量 $\\mathbf{c} = [c_1, c_2, c_3]^T$ 使得 $c_1 \\cdot 1 + c_2 \\cdot x_m + c_3 \\cdot y_m = 0$ 对于所有权重 $w_m > 0$ 的点 $(x_m, y_m)$ 都成立。这是 $(x,y)$ 平面中的一条直线方程。\n因此，矩阵 $\\mathbf{M}$ 奇异当且仅当所有权重 $w_m > 0$ 的采样点 $(x_m, y_m)$ 共线（位于同一条直线上）。要使 $\\mathbf{M}$ 可逆，我们至少需要3个具有正权重的采样点（因为我们要拟合3个参数），并且这些点不能共线。在给定的问题中，四个点 $(0,0), (1,0), (0,1), (1,1)$ 都具有正权重并且显然不共线。因此，矩阵 $\\mathbf{M}$ 是可逆的，这与其非零的行列式值 $17$ 相符。", "answer": "$$\n\\boxed{17}\n$$", "id": "3593897"}, {"introduction": "一旦我们获得了恢复的应变场 $\\boldsymbol{\\varepsilon}^*$，下一步就是量化误差。在固体力学中，标准方法是计算恢复场与原始有限元 (FE) 场 $\\boldsymbol{\\varepsilon}_h$ 之间差异的能量。本练习提供了一个计算单个单元能量范数误差平方指标 $\\eta_K^2$ 的具体算例，它将抽象的公式与实际数值联系起来，要求你运用材料的本构关系和数值积分，从而加深对误差指标物理意义和数学定义的理解。", "problem": "考虑一个小应变、线性、各向同性的平面应变固体中的单个二维有限元 $K$。该材料的杨氏模量为 $E = 210 \\times 10^{9}$，泊松比为 $\\nu = 0.3$。该单元的面积为 $A = 0.25$，恒定厚度为 $t = 0.02$，因此其体积为 $V = A\\,t$。局部能量范数误差平方指标 $\\eta_{K}^{2}$ 定义为应变误差的能量密度的单元积分，即在单元 $K$ 上对 $\\left(\\boldsymbol{\\varepsilon}^{*} - \\boldsymbol{\\varepsilon}_{h}\\right) : \\mathbb{C} \\left(\\boldsymbol{\\varepsilon}^{*} - \\boldsymbol{\\varepsilon}_{h}\\right)$ 的积分，其中 $\\mathbb{C}$ 是平面应变的四阶弹性张量，$\\boldsymbol{\\varepsilon}^{*}$ 是恢复应变（例如，通过使用 Zienkiewicz–Zhu 方法的超收敛片恢复法得到），而 $\\boldsymbol{\\varepsilon}_{h}$ 是有限元应变。在三角形上使用三点对称求积，在求积点 $q = 1,2,3$ 处的权重相等，为 $w_{q} = V/3$。\n\n使用以下在求积点处的采样应变计算 $\\eta_{K}^{2}$（所有应变均为平面内对称小应变张量的分量，以 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{xy})$ 的形式报告，其中 $\\varepsilon_{xy}$ 是张量分量）：\n- 在点 $q=1$ 处：$\\boldsymbol{\\varepsilon}^{*}(x_{1}) = \\left(1.2 \\times 10^{-3},\\, 0.8 \\times 10^{-3},\\, 0.5 \\times 10^{-3}\\right)$ 和 $\\boldsymbol{\\varepsilon}_{h}(x_{1}) = \\left(1.0 \\times 10^{-3},\\, 0.9 \\times 10^{-3},\\, 0.4 \\times 10^{-3}\\right)$。\n- 在点 $q=2$ 处：$\\boldsymbol{\\varepsilon}^{*}(x_{2}) = \\left(1.1 \\times 10^{-3},\\, 0.85 \\times 10^{-3},\\, 0.6 \\times 10^{-3}\\right)$ 和 $\\boldsymbol{\\varepsilon}_{h}(x_{2}) = \\left(1.05 \\times 10^{-3},\\, 0.90 \\times 10^{-3},\\, 0.55 \\times 10^{-3}\\right)$。\n- 在点 $q=3$ 处：$\\boldsymbol{\\varepsilon}^{*}(x_{3}) = \\left(1.3 \\times 10^{-3},\\, 0.75 \\times 10^{-3},\\, 0.45 \\times 10^{-3}\\right)$ 和 $\\boldsymbol{\\varepsilon}_{h}(x_{3}) = \\left(1.15 \\times 10^{-3},\\, 0.80 \\times 10^{-3},\\, 0.50 \\times 10^{-3}\\right)$。\n\n假设为平面应变，其拉梅参数为 $\\lambda$ 和 $\\mu$，并使用精确的小应变线性弹性关系式来表示 $\\mathbb{C}$。以焦耳为单位表示 $\\eta_{K}^{2}$ 的最终值。将您的答案四舍五入到四位有效数字。", "solution": "### 步骤 1：建立计算框架\n目标是计算单个有限元 $K$ 的能量范数误差平方指标 $\\eta_{K}^{2}$。其定义如下：\n$$\n\\eta_{K}^{2} = \\int_{K} \\left(\\boldsymbol{\\varepsilon}^{*} - \\boldsymbol{\\varepsilon}_{h}\\right) : \\mathbb{C} \\left(\\boldsymbol{\\varepsilon}^{*} - \\boldsymbol{\\varepsilon}_{h}\\right) dV\n$$\n其中 $\\boldsymbol{\\varepsilon}^{*}$ 是恢复应变，$\\boldsymbol{\\varepsilon}_{h}$ 是有限元应变，$\\mathbb{C}$ 是线性、各向同性材料在平面应变条件下的四阶弹性张量。令误差应变为 $\\boldsymbol{\\varepsilon}_{e} = \\boldsymbol{\\varepsilon}^{*} - \\boldsymbol{\\varepsilon}_{h}$。积分变为：\n$$\n\\eta_{K}^{2} = \\int_{K} \\boldsymbol{\\varepsilon}_{e} : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e} \\, dV\n$$\n该积分使用三点数值求积法则进行计算，对于每个求积点 $q \\in \\{1,2,3\\}$，权重相等，为 $w_{q} = V/3$。\n单元体积 $V = A \\cdot t = 0.25 \\, \\text{m}^2 \\times 0.02 \\, \\text{m} = 0.005 \\, \\text{m}^3$。\n求积权重为 $w_1=w_2=w_3 = V/3 = 0.005/3$ m$^3$。\n积分可近似为一个和式：\n$$\n\\eta_{K}^{2} \\approx \\sum_{q=1}^{3} w_{q} \\left[ \\boldsymbol{\\varepsilon}_{e}(x_{q}) : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e}(x_{q}) \\right] = \\frac{V}{3} \\sum_{q=1}^{3} \\left[ \\boldsymbol{\\varepsilon}_{e,q} : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e,q} \\right]\n$$\n项 $\\boldsymbol{\\varepsilon}_{e} : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e}$ 表示误差应变场的应变能密度乘以因子 $2$。对于线性各向同性材料，在平面应变条件下，该式展开为：\n$$\n\\boldsymbol{\\varepsilon}_{e} : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e} = \\lambda \\left(\\varepsilon_{e,xx} + \\varepsilon_{e,yy}\\right)^2 + 2\\mu \\left(\\varepsilon_{e,xx}^2 + \\varepsilon_{e,yy}^2 + 2\\varepsilon_{e,xy}^2\\right)\n$$\n其中 $\\lambda$ 和 $\\mu$ 是拉梅参数。\n\n### 步骤 2：计算材料参数\n拉梅参数由给定的杨氏模量 $E = 210 \\times 10^{9}$ Pa 和泊松比 $\\nu = 0.3$ 计算得出：\n$$\n\\mu = G = \\frac{E}{2(1+\\nu)} = \\frac{210 \\times 10^9}{2(1+0.3)} = \\frac{210 \\times 10^9}{2.6} \\approx 80.769 \\times 10^9 \\, \\text{Pa}\n$$\n$$\n\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)} = \\frac{(210 \\times 10^9)(0.3)}{(1+0.3)(1-2(0.3))} = \\frac{63 \\times 10^9}{1.3 \\times 0.4} = \\frac{63 \\times 10^9}{0.52} \\approx 121.154 \\times 10^9 \\, \\text{Pa}\n$$\n\n### 步骤 3：计算各点的误差应变和能量密度\n我们计算每个求积点 $q$ 处的误差应变张量 $\\boldsymbol{\\varepsilon}_{e,q} = \\boldsymbol{\\varepsilon}^{*}_q - \\boldsymbol{\\varepsilon}_{h,q}$ 和对应的能量密度 $U_q = \\boldsymbol{\\varepsilon}_{e,q} : \\mathbb{C} \\boldsymbol{\\varepsilon}_{e,q}$。\n\n**对于点 q=1:**\n$\\boldsymbol{\\varepsilon}_{e,1} = (1.2 - 1.0, 0.8 - 0.9, 0.5 - 0.4) \\times 10^{-3} = (0.2, -0.1, 0.1) \\times 10^{-3}$\n$\\text{tr}(\\boldsymbol{\\varepsilon}_{e,1}) = (0.2 - 0.1) \\times 10^{-3} = 0.1 \\times 10^{-3}$\n$U_1 = \\lambda (0.1 \\times 10^{-3})^2 + 2\\mu \\left( (0.2^2 + (-0.1)^2 + 2 \\cdot 0.1^2) \\times 10^{-6} \\right)$\n$U_1 = \\left( \\lambda \\cdot 0.01 + 2\\mu \\cdot (0.04 + 0.01 + 0.02) \\right) \\times 10^{-6} = (0.01\\lambda + 0.14\\mu) \\times 10^{-6}$\n$U_1 = (0.01 \\cdot 121.154 \\times 10^9 + 0.14 \\cdot 80.769 \\times 10^9) \\times 10^{-6} = (1.21154 + 11.30769) \\times 10^3 = 12519.23 \\, \\text{J/m}^3$\n\n**对于点 q=2:**\n$\\boldsymbol{\\varepsilon}_{e,2} = (1.1 - 1.05, 0.85 - 0.90, 0.6 - 0.55) \\times 10^{-3} = (0.05, -0.05, 0.05) \\times 10^{-3}$\n$\\text{tr}(\\boldsymbol{\\varepsilon}_{e,2}) = (0.05 - 0.05) \\times 10^{-3} = 0$\n$U_2 = 2\\mu \\left( (0.05^2 + (-0.05)^2 + 2 \\cdot 0.05^2) \\times 10^{-6} \\right)$\n$U_2 = 2\\mu (0.0025 + 0.0025 + 0.005) \\times 10^{-6} = 0.02\\mu \\times 10^{-6}$\n$U_2 = (0.02 \\cdot 80.769 \\times 10^9) \\times 10^{-6} = 1615.38 \\, \\text{J/m}^3$\n\n**对于点 q=3:**\n$\\boldsymbol{\\varepsilon}_{e,3} = (1.3 - 1.15, 0.75 - 0.80, 0.45 - 0.50) \\times 10^{-3} = (0.15, -0.05, -0.05) \\times 10^{-3}$\n$\\text{tr}(\\boldsymbol{\\varepsilon}_{e,3}) = (0.15 - 0.05) \\times 10^{-3} = 0.1 \\times 10^{-3}$\n$U_3 = \\lambda (0.1 \\times 10^{-3})^2 + 2\\mu \\left( (0.15^2 + (-0.05)^2 + 2 \\cdot (-0.05)^2) \\times 10^{-6} \\right)$\n$U_3 = \\left( \\lambda \\cdot 0.01 + 2\\mu \\cdot (0.0225 + 0.0025 + 0.005) \\right) \\times 10^{-6} = (0.01\\lambda + 0.06\\mu) \\times 10^{-6}$\n$U_3 = (0.01 \\cdot 121.154 \\times 10^9 + 0.06 \\cdot 80.769 \\times 10^9) \\times 10^{-6} = (1.21154 + 4.84614) \\times 10^3 = 6057.68 \\, \\text{J/m}^3$\n\n### 步骤 4：计算最终误差指标\n将各点能量密度代入求和公式：\n$$\n\\eta_{K}^{2} \\approx \\frac{V}{3} \\sum_{q=1}^{3} U_q = \\frac{0.005}{3} (12519.23 + 1615.38 + 6057.68)\n$$\n$$\n\\eta_{K}^{2} \\approx \\frac{0.005}{3} (20192.29) \\approx 0.005 \\times 6730.76 \\approx 33.6538 \\, \\text{J}\n$$\n将结果四舍五入到四位有效数字，得到 $33.65$。", "answer": "$$\n\\boxed{33.65}\n$$", "id": "3593882"}, {"introduction": "计算误差指标本身不是最终目的，其关键用途是指导自适应网格细化 (AMR)。我们通常不会细化所有单元，而是策略性地选择那些对总误差贡献最大的单元。Dörfler 标记策略为此提供了一种严谨且高效的选择方法。本练习模拟了自适应循环中的决策步骤，要求你将 Dörfler 批量标记准则应用于一组给定的单元误差指标，从而巩固局部误差估计与全局求解精度优化策略之间的联系。", "problem": "实现一个完整的程序，在二维线性弹性力学中使用基于恢复的能量范数单元误差指标，执行Dörfler批量标记以进行自适应网格加密。该程序必须根据给定的三角剖分和规定的连续位移场计算基于恢复的单元指标，然后根据Dörfler准则选择一个最小的标记单元集。最后，对提供的测试套件，聚合并打印所选单元的索引。\n\n从平面应力条件下二维线性弹性力学的小应变标准设置开始。设位移场为一个向量函数 $u : \\Omega \\subset \\mathbb{R}^2 \\to \\mathbb{R}^2$。无穷小应变张量为 $\\varepsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^\\top)$，应力为 $\\sigma = \\mathbb{C}\\,\\varepsilon(u)$，其中 $\\mathbb{C}$ 是平面应力条件下的各向同性弹性张量，其杨氏模量为 $E$，泊松比为 $\\nu$。考虑将 $\\Omega$ 三角剖分为三节点线性三角形。在每个单元 $K$ 上，标准的有限元法 (FEM) 应变 $\\varepsilon^h|_K$ 是恒定的，通过单元应变-位移矩阵从单元节点的位移值获得。\n\n使用Zienkiewicz–Zhu (ZZ) 恢复程序在网格上构建一个恢复应变场 $\\varepsilon^\\star$。在此问题中，您必须通过对每个节点贡献的常数单元应变进行面积加权平均来实现节点恢复，并将单元恢复应变 $\\varepsilon^\\star|_K$ 定义为 $K$ 的三个节点处恢复应变的算术平均值。\n\n将每个单元 $K$ 的单元能量范数指标的平方定义为\n$$\n\\eta_K^2 = \\int_{K} (\\varepsilon^\\star - \\varepsilon^h)^\\top \\, \\mathbb{C} \\, (\\varepsilon^\\star - \\varepsilon^h)\\, \\mathrm{d}\\Omega.\n$$\n在此问题中，通过单元面积乘以使用常数 $\\varepsilon^h|_K$ 和单元级 $\\varepsilon^\\star|_K$ 计算的能量密度来近似该积分：\n$$\n\\eta_K^2 \\approx |K|\\, (\\varepsilon^\\star|_K - \\varepsilon^h|_K)^\\top \\mathbb{C} \\, (\\varepsilon^\\star|_K - \\varepsilon^h|_K).\n$$\n\n实现Dörfler批量标记，以选择满足以下条件的最小单元集 $\\mathcal{M}$：\n$$\n\\sum_{K \\in \\mathcal{M}} \\eta_K^2 \\;\\ge\\; \\theta \\sum_{K} \\eta_K^2,\n$$\n其中 $0  \\theta  1$。使用以下确定性最小化规则：按 $\\eta_K^2$ 值降序对单元进行排序，并通过升序的单元索引来打破平局；然后按此顺序包含单元，直到满足不等式。如果 $\\sum_K \\eta_K^2$ 在数值上为零，则使用浮点容差 $\\varepsilon = 10^{-12}$ 将其视为零，并返回空集（无标记单元）。\n\n您必须以国际单位制计算所有相关量。弹性张量 $\\mathbb{C}$ 必须根据 $E$（单位为帕斯卡）和 $\\nu$（无量纲）为平面应力条件构建。面积单位必须是平方米。尽管中间变量有单位，但程序的最终输出是单元索引列表，因此是无量纲的。\n\n测试套件规范：\n- 对于每个测试用例，程序接收一个网格和一个由在节点坐标处求值的解析函数指定的位移场、材料参数以及标记参数 $\\theta$。您的程序必须计算所有单元的 $\\eta_K^2$，然后按规定返回标记的单元集索引。\n\n使用以下三个测试用例：\n1. 零误差的理想情况：\n   - 域：包含两个三角形的单位正方形，\n     - 节点（从 $0$ 开始索引）：$(0,0)$, $(1,0)$, $(1,1)$, $(0,1)$。\n     - 单元：$K_0 = (0,1,2)$ 和 $K_1 = (0,2,3)$（每个三元组是节点索引列表）。\n   - 位移场：$u_x(x,y) = 0.1\\,x + 0.0\\,y$, $u_y(x,y) = 0.0\\,x + 0.05\\,y$。\n   - 材料：$E = 2.10\\times 10^{11}$ Pa, $\\nu = 0.3$。\n   - 标记参数：$\\theta = 0.6$。\n   - 预期行为：精确的线性场产生 $\\eta_K^2 \\approx 0$；根据容差规则，标记集为空列表。\n\n2. 加密网格上的非平凡二次场：\n   - 域：单位正方形，划分为均匀的 $2\\times 2$ 网格，包含三角形，\n     - 节点（从 $0$ 开始索引）：$(0,0)$, $(0.5,0)$, $(1,0)$, $(0,0.5)$, $(0.5,0.5)$, $(1,0.5)$, $(0,1)$, $(0.5,1)$, $(1,1)$。\n     - 单元：左下角单元格由其左下角到右上角的对角线分割，整个网格保持一致。具体来说，三角形为 $K_0=(0,1,4)$, $K_1=(0,4,3)$, $K_2=(1,2,5)$, $K_3=(1,5,4)$, $K_4=(3,4,7)$, $K_5=(3,7,6)$, $K_6=(4,5,8)$, $K_7=(4,8,7)$。\n   - 位移场：$u_x(x,y) = 0.02\\,x^2$, $u_y(x,y) = 0.03\\,y^2$。\n   - 材料：$E = 2.10\\times 10^{11}$ Pa, $\\nu = 0.3$。\n   - 标记参数：$\\theta = 0.5$。\n   - 预期行为：非零指标；Dörfler标记选择一个最小单元集，其捕获了总平方指标和的至少一半。\n\n3. 大批量参数下的边界情况：\n   - 与测试用例2相同的网格和材料。\n   - 位移场：$u_x(x,y) = 0.02\\,x^2$, $u_y(x,y) = 0.03\\,y^2$。\n   - 标记参数：$\\theta = 0.95$。\n   - 预期行为：近乎全部标记；该集合包含大多数单元。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。每个条目对应一个测试用例，其本身是按标记包含顺序排列的标记单元索引列表。例如，输出必须如下所示：\n$[\\,[i_{0,1},i_{0,2},\\dots],\\,[i_{1,1},\\dots],\\,[i_{2,1},\\dots]\\,]$,\n其中 $i_{t,k}$ 是整数。使用从零开始的单元索引。\n\n您还必须在附带的解决方案中解释能量范数指标从线性弹性和应变恢复中的推导、Dörfler标记的算法结构，并为实践中使用的批量参数 $\\theta$ 的典型选择提供原则性论证。", "solution": "该问题要求在二维线性弹性力学中实现一个基于恢复的误差指标和用于自适应网格加密的Dörfler批量标记策略。解决方案分为三部分：误差估计和标记过程的理论阐述、算法步骤描述以及最终的实现细节。\n\n### 基于原理的设计\n\n#### 1. 线性弹性力学中的能量范数误差估计\n\n在线性弹性力学的有限元法（FEM）中，主要目标是找到真实（但未知）位移场 $u$ 的一个近似位移场 $u^h$。近似的质量通常通过误差 $e = u - u^h$ 在能量范数下的度量来衡量。误差的能量范数平方定义为：\n$$\n\\|e\\|_E^2 = \\int_{\\Omega} (\\varepsilon(u) - \\varepsilon(u^h))^\\top \\, \\mathbb{C} \\, (\\varepsilon(u) - \\varepsilon(u^h)) \\, \\mathrm{d}\\Omega\n$$\n其中 $\\varepsilon(u)$ 是从位移场 $u$ 导出的应变张量，$\\mathbb{C}$ 是本构（弹性）张量。该积分代表了误差场的应变能。在实际情况中，精确解 $u$ 是不可用的，这使得直接计算 $\\|e\\|_E^2$ 成为不可能。\n\n后验误差估计旨在仅使用计算出的FEM解 $u^h$ 和问题数据来近似此误差。全局误差表示为网格剖分 $\\mathcal{T}$ 中每个单元 $K$ 的局部贡献之和：\n$$\n\\|e\\|_E^2 = \\sum_{K \\in \\mathcal{T}} \\int_{K} (\\varepsilon(u) - \\varepsilon(u^h))^\\top \\, \\mathbb{C} \\, (\\varepsilon(u) - \\varepsilon(u^h)) \\, \\mathrm{d}\\Omega = \\sum_{K \\in \\mathcal{T}} \\eta_K^2\n$$\n在这里，$\\eta_K$ 是单元 $K$ 的局部误差指标。后验估计的关键是为 $\\eta_K$ 找到一个可计算的近似。\n\n#### 2. Zienkiewicz-Zhu (ZZ) 恢复与误差指标\n\nZienkiewicz-Zhu (ZZ) 恢复方法是一种广泛使用的误差估计技术。它基于这样一个观察：虽然FEM位移解 $u^h$ 在单元边界上是连续的，但其导数，即FEM应变 $\\varepsilon^h$，通常是不连续且精度较低的。其核心思想是通过对不连续场 $\\varepsilon^h$ 进行后处理，来“恢复”一个更精确、连续的应变场，记为 $\\varepsilon^\\star$。\n\nZZ类型估计器的基本假设是，恢复的应变 $\\varepsilon^\\star$ 是对真实应变 $\\varepsilon(u)$ 的一个显著优于原始FEM应变 $\\varepsilon^h$ 的近似。这使我们可以将应变误差近似为：\n$$\n\\varepsilon(u) - \\varepsilon(u^h) \\approx \\varepsilon^\\star - \\varepsilon^h\n$$\n将此近似代入单元误差指标的定义中，得到可计算的ZZ误差指标：\n$$\n\\eta_K^2 = \\int_{K} (\\varepsilon^\\star - \\varepsilon^h)^\\top \\, \\mathbb{C} \\, (\\varepsilon^\\star - \\varepsilon^h) \\, \\mathrm{d}\\Omega\n$$\n问题规定了构建 $\\varepsilon^\\star$ 的特定过程：\n1.  **节点应变恢复**：对于网格中的每个节点，恢复的应变 $\\varepsilon^\\star_{node}$ 计算为共享该节点的所有单元的常数FEM应变 $\\varepsilon^h$ 的面积加权平均值。\n2.  **单元恢复应变**：对于每个单元 $K$，一个常数恢复应变 $\\varepsilon^\\star|_K$ 计算为其三个顶点处恢复应变的算术平均值。\n3.  **指标近似**：$\\eta_K^2$ 的积分通过假设被积函数在单元上是常数来近似，使用单元级的常数应变 $\\varepsilon^h|_K$ 和 $\\varepsilon^\\star|_K$。这导致了代数表达式：\n    $$\n    \\eta_K^2 \\approx |K|\\, (\\varepsilon^\\star|_K - \\varepsilon^h|_K)^\\top \\mathbb{C} \\, (\\varepsilon^\\star|_K - \\varepsilon^h|_K)\n    $$\n    其中 $|K|$ 是单元 $K$ 的面积。\n\n#### 3. Dörfler批量标记\n\n一旦计算出所有单元的误差指标 $\\eta_K^2$，自适应网格加密（AMR）就会仅对那些对总误差贡献最显著的单元进行加密。Dörfler标记提供了一种选择这组单元的稳健策略。\n\n给定一个批量参数 $0  \\theta  1$，Dörfler准则要求选择一个最小的单元集 $\\mathcal{M}$ 进行加密，使得它们的误差指标之和至少占总估计误差的一部分 $\\theta$：\n$$\n\\sum_{K \\in \\mathcal{M}} \\eta_K^2 \\ge \\theta \\sum_{K \\in \\mathcal{T}} \\eta_K^2\n$$\n最小性条件通过以下确定性算法满足：\n1.  为网格 $\\mathcal{T}$ 中的每个单元 $K$ 计算平方指标 $\\eta_K^2$。\n2.  计算总估计平方误差 $\\eta_{total}^2 = \\sum_{K \\in \\mathcal{T}} \\eta_K^2$。\n3.  根据单元的 $\\eta_K^2$ 值按降序对它们进行排序。为确保确定性，任何平局都通过按原始索引升序对单元进行排序来打破。\n4.  遍历排序后的单元列表，将其 $\\eta_K^2$ 值累加到一个运行总和中。将每个单元添加到标记集 $\\mathcal{M}$ 中。\n5.  当累加和首次达到或超过目标值 $\\theta \\cdot \\eta_{total}^2$ 时停止。\n\n最终得到的集合 $\\mathcal{M}$ 包含了估计误差最大的单元，这些单元是进行细分以提高下一次FEM求解整体精度的主要候选者。\n\n参数 $\\theta$ 控制加密的激进程度。一个小的 $\\theta$（例如 $0.2-0.4$）仅针对具有最主要误差的单元，这对于具有尖锐奇异点的问题很有效。一个大的 $\\theta$（例如 $0.7-0.9$）会导致一个更大的标记集，接近于一致加密，这可能适用于误差分布更均匀的情况。在实践中，一个常见且平衡的选择是 $\\theta \\approx 0.5$。\n\n### 算法实现\n\n程序将为每个测试用例执行以下操作序列：\n1.  **初始化**：定义网格（节点坐标和单元连接关系）、材料属性（$E, \\nu$）和标记参数 $\\theta$。使用 $E$ 和 $\\nu$ 构建平面应力弹性矩阵 $\\mathbb{C}$。\n2.  **计算FEM应变 $\\varepsilon^h$**：对每个单元，计算应变-位移矩阵 $B_K$ 和面积 $|K|$。从给定的解析位移函数中，评估节点位移 $d_K$。计算常数单元应变 $\\varepsilon^h_K = B_K d_K$。\n3.  **计算恢复的节点应变 $\\varepsilon^\\star_{node}$**：对于每个节点，将所有相邻单元的应变和面积的乘积 $(\\varepsilon^h_K \\cdot |K|)$ 相加，然后除以它们的面积之和。\n4.  **计算恢复的单元应变 $\\varepsilon^\\star_K$**：对于每个单元，对其三个节点的恢复应变进行平均。\n5.  **计算误差指标**：对于每个单元，计算应变误差差 $\\Delta\\varepsilon_K = \\varepsilon^\\star_K - \\varepsilon^h_K$，然后计算平方指标 $\\eta_K^2 = |K|\\, (\\Delta\\varepsilon_K^\\top \\mathbb{C} \\Delta\\varepsilon_K)$。\n6.  **执行Dörfler标记**：将所有指标相加得到 $\\eta_{total}^2$。如果此和低于容差（$10^{-12}$），则返回一个空集。否则，按降序（带平局打破规则）对指标进行排序，并选择单元，直到它们的累积和达到 $\\theta \\cdot \\eta_{total}^2$。所选单元的索引按其被包含的顺序收集。\n7.  **最终输出**：将所有测试用例的标记索引列表格式化为指定的单个字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    class TestCaseSolver:\n        \"\"\"\n        Encapsulates the logic for solving one test case of Dörfler marking.\n        \"\"\"\n        def __init__(self, nodes, elements, E, nu, theta, u_func):\n            self.nodes = np.array(nodes, dtype=float)\n            self.elements = np.array(elements, dtype=int)\n            self.E = float(E)\n            self.nu = float(nu)\n            self.theta = float(theta)\n            self.u_func = u_func\n            self.num_nodes = self.nodes.shape[0]\n            self.num_elements = self.elements.shape[0]\n\n            # Plane stress elasticity matrix C for [exx, eyy, gxy] where gxy = 2*exy\n            c1 = self.E / (1 - self.nu**2)\n            c2 = self.E * self.nu / (1 - self.nu**2)\n            c3 = self.E / (2 * (1 + self.nu))  # Shear modulus G\n            self.C = np.array([[c1, c2, 0],\n                               [c2, c1, 0],\n                               [0,  0, c3]], dtype=float)\n\n        def _compute_fem_strains(self):\n            \"\"\"\n            Computes the constant FEM strain for each element.\n            \"\"\"\n            self.elem_strains_h = np.zeros((self.num_elements, 3))\n            self.elem_areas = np.zeros(self.num_elements)\n\n            for i, elem_nodes_indices in enumerate(self.elements):\n                node_coords = self.nodes[elem_nodes_indices]\n                \n                # Nodal coordinates\n                x1, y1 = node_coords[0]\n                x2, y2 = node_coords[1]\n                x3, y3 = node_coords[2]\n\n                # Element area\n                area = 0.5 * np.abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n                self.elem_areas[i] = area\n\n                if area  1e-15:  # Degenerate element\n                    continue\n                \n                # B matrix components\n                b1, b2, b3 = y2 - y3, y3 - y1, y1 - y2\n                c1, c2, c3 = x3 - x2, x1 - x3, x2 - x1\n\n                # Strain-displacement matrix B for [exx, eyy, gxy]\n                B = (1 / (2 * area)) * np.array([\n                    [b1, 0,  b2, 0,  b3, 0 ],\n                    [0,  c1, 0,  c2, 0,  c3],\n                    [c1, b1, c2, b2, c3, b3]\n                ])\n\n                # Nodal displacement vector d\n                d = np.zeros(6)\n                for j, node_idx in enumerate(elem_nodes_indices):\n                    pos = self.nodes[node_idx]\n                    ux, uy = self.u_func(pos[0], pos[1])\n                    d[2*j] = ux\n                    d[2*j + 1] = uy\n                \n                # Element strain epsilon_h = B * d\n                self.elem_strains_h[i] = B @ d\n\n        def _compute_recovered_strains(self):\n            \"\"\"\n            Computes the recovered strain field epsilon_star.\n            \"\"\"\n            # 1. Nodal recovery by area-weighted averaging\n            nodal_strains_star_num = np.zeros((self.num_nodes, 3))\n            nodal_areas_sum = np.zeros(self.num_nodes)\n\n            for i, elem_nodes_indices in enumerate(self.elements):\n                area = self.elem_areas[i]\n                strain_h = self.elem_strains_h[i]\n                for node_idx in elem_nodes_indices:\n                    nodal_strains_star_num[node_idx] += strain_h * area\n                    nodal_areas_sum[node_idx] += area\n\n            # Avoid division by zero for nodes not in any element\n            valid_nodes = nodal_areas_sum > 1e-15\n            self.nodal_strains_star = np.zeros((self.num_nodes, 3))\n            self.nodal_strains_star[valid_nodes] = \\\n                nodal_strains_star_num[valid_nodes] / nodal_areas_sum[valid_nodes, np.newaxis]\n\n            # 2. Element-wise recovered strain by averaging nodal values\n            self.elem_strains_star = np.zeros((self.num_elements, 3))\n            for i, elem_nodes_indices in enumerate(self.elements):\n                self.elem_strains_star[i] = np.mean(self.nodal_strains_star[elem_nodes_indices], axis=0)\n        \n        def _compute_indicators(self):\n            \"\"\"\n            Computes the squared energy-norm indicator for each element.\n            \"\"\"\n            self.indicators_sq = np.zeros(self.num_elements)\n            strain_diff = self.elem_strains_star - self.elem_strains_h\n            \n            for i in range(self.num_elements):\n                delta_eps = strain_diff[i]\n                # indicator^2 = area * (delta_eps^T * C * delta_eps)\n                energy_density = delta_eps.T @ self.C @ delta_eps\n                self.indicators_sq[i] = self.elem_areas[i] * energy_density\n\n        def _perform_doerfler_marking(self):\n            \"\"\"\n            Performs Dörfler bulk marking to select elements for refinement.\n            \"\"\"\n            total_indicator_sq_sum = np.sum(self.indicators_sq)\n\n            # Handle zero-error case\n            if total_indicator_sq_sum  1e-12:\n                return []\n\n            target_sum = self.theta * total_indicator_sq_sum\n\n            # Create tuples of (-indicator, index) for sorting\n            # Sort by descending indicator, then ascending index for tie-breaking\n            indexed_indicators = [(-self.indicators_sq[i], i) for i in range(self.num_elements)]\n            indexed_indicators.sort()\n\n            marked_indices = []\n            current_sum = 0.0\n            for neg_indicator, index in indexed_indicators:\n                if current_sum >= target_sum:\n                    break\n                current_sum += -neg_indicator\n                marked_indices.append(index)\n            \n            return marked_indices\n\n        def run(self):\n            \"\"\"\n            Runs the full analysis for the test case.\n            \"\"\"\n            self._compute_fem_strains()\n            self._compute_recovered_strains()\n            self._compute_indicators()\n            marked_set = self._perform_doerfler_marking()\n            return marked_set\n\n    # Test Suite Specification\n    test_cases = [\n        # Case 1: Happy path with zero error\n        {\n            \"nodes\": [(0,0), (1,0), (1,1), (0,1)],\n            \"elements\": [(0,1,2), (0,2,3)],\n            \"E\": 2.10e11, \"nu\": 0.3, \"theta\": 0.6,\n            \"u_func\": lambda x, y: (0.1*x, 0.05*y)\n        },\n        # Case 2: Nontrivial quadratic field on a refined mesh\n        {\n            \"nodes\": [(0,0), (0.5,0), (1,0), (0,0.5), (0.5,0.5), (1,0.5), (0,1), (0.5,1), (1,1)],\n            \"elements\": [(0,1,4), (0,4,3), (1,2,5), (1,5,4), (3,4,7), (3,7,6), (4,5,8), (4,8,7)],\n            \"E\": 2.10e11, \"nu\": 0.3, \"theta\": 0.5,\n            \"u_func\": lambda x, y: (0.02*x**2, 0.03*y**2)\n        },\n        # Case 3: Boundary regime with large bulk parameter\n        {\n            \"nodes\": [(0,0), (0.5,0), (1,0), (0,0.5), (0.5,0.5), (1,0.5), (0,1), (0.5,1), (1,1)],\n            \"elements\": [(0,1,4), (0,4,3), (1,2,5), (1,5,4), (3,4,7), (3,7,6), (4,5,8), (4,8,7)],\n            \"E\": 2.10e11, \"nu\": 0.3, \"theta\": 0.95,\n            \"u_func\": lambda x, y: (0.02*x**2, 0.03*y**2)\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        solver = TestCaseSolver(\n            nodes=case[\"nodes\"],\n            elements=case[\"elements\"],\n            E=case[\"E\"],\n            nu=case[\"nu\"],\n            theta=case[\"theta\"],\n            u_func=case[\"u_func\"]\n        )\n        result = solver.run()\n        all_results.append(result)\n\n    # Final print statement in the specified format without spaces.\n    inner_results = []\n    for res_list in all_results:\n        inner_str = f\"[{','.join(map(str, res_list))}]\"\n        inner_results.append(inner_str)\n    \n    # Per problem spec, the output is a single line, comma-separated list of lists.\n    # Example: [[i_0,1,...],[i_1,1,...],...]\n    print(f\"[{','.join(inner_results)}]\")\n\nsolve()\n```", "id": "3593863"}]}