{"hands_on_practices": [{"introduction": "在深入研究复杂的有限元代码之前，我们可以通过一个简化的解析模型来精确量化体积锁定导致的过度刚化效应。这个练习旨在引导你推导一个简单压缩问题的精确不可压缩解，并将其与一个被“锁定”的低阶有限元近似解进行对比 [@problem_id:3609974]。通过计算反作用力的比值，你将得出一个明确的量化指标，它直观地揭示了问题的严重性，并为理解为何需要高级单元技术奠定了基础。", "problem": "考虑单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 上的小应变、平面应变、线弹性问题，其位移矢量场为 $u = (u_x,u_y)$，柯西(Cauchy)应力张量为 $\\sigma$。该材料为各向同性材料，剪切模量为 $\\mu>0$，拉梅(Lamé)参数为 $\\lambda>0$；不可压缩极限对应于通过拉格朗日乘子压力 $p$ 施加运动学约束 $\\nabla\\cdot u = 0$，并将本构关系写为 $\\sigma = -p I + 2\\mu\\,\\epsilon(u)$，其中 $\\epsilon(u) = \\frac{1}{2}\\left(\\nabla u + \\nabla u^{\\top}\\right)$ 是小应变张量，$I$ 是单位张量。在标准的纯位移格式中，本构关系写为 $\\sigma = \\lambda\\,\\operatorname{tr}(\\epsilon(u))\\,I + 2\\mu\\,\\epsilon(u)$。\n\n通过运动学边界条件 $u_y(x,1) = -\\delta$ 和 $u_y(x,0) = 0$（对于给定的 $\\delta>0$）施加一个竖向均匀压缩。侧边预期为无面力边界；即在 $x=0$ 和 $x=1$ 上，施加 $\\sigma\\,n = 0$，其中 $n$ 是单位外法向量。\n\n第一部分（精确不可压缩基准）：使用基于压力的不可压缩格式（其中约束 $\\nabla\\cdot u = 0$ 由 $p$ 强制施加），推导满足平衡方程、上述运动学边界条件和侧边无面力条件的精确解 $(u,p)$。根据此精确解，计算顶边 $y=1$ 上的均匀竖向反作用力 $\\bar{t}_y^{\\text{exact}}$（即 $\\sigma_{yy}$ 沿 $y=1$ 的恒定值）。\n\n第二部分（四节点四边形单元锁定场景）：考虑在具有相同竖向运动学边界条件的单单元网格上，使用纯位移四节点四边形（$Q1$）有限元法（FEM）。为了模拟在近不可压缩条件下，粗糙的纯位移网格上侧向膨胀被虚假抑制的常见锁定效应，在侧边 $x=0$ 和 $x=1$ 上施加 $u_x=0$。使用纯位移本构关系 $\\sigma = \\lambda\\,\\operatorname{tr}(\\epsilon(u))\\,I + 2\\mu\\,\\epsilon(u)$，计算顶边上产生的均匀竖向反作用力 $\\bar{t}_y^{\\text{Q1}}$。\n\n第三部分（定量比较）：构造由下式定义的比率 $R(\\lambda,\\mu)$\n$$\nR(\\lambda,\\mu) \\;=\\; \\frac{|\\bar{t}_y^{\\text{Q1}}|}{|\\bar{t}_y^{\\text{exact}}|},\n$$\n并将其简化为仅含 $\\lambda$ 和 $\\mu$ 的封闭形式表达式。这个无量纲比率量化了当接近不可压缩极限时体积锁定所特有的过度刚化现象。请提供 $R(\\lambda,\\mu)$ 的简化解析表达式作为最终答案。无需四舍五入，最终表达式中不應包含任何单位。", "solution": "该问题要求对一个不可压缩弹性问题的精确解与一个表现出体积锁定的相应有限元解进行定量比较。分析分为三个部分。\n\n### 第一部分：精确不可压缩基准解\n\n小应变、平面应变、不可压缩弹性材料的控制方程是平衡方程和不可压缩性约束：\n$$\n\\nabla \\cdot \\sigma = 0\n$$\n$$\n\\nabla \\cdot u = 0\n$$\n将柯西(Cauchy)应力张量 $\\sigma$ 与位移场 $u = (u_x, u_y)$ 联系起来的本构关系涉及一个拉格朗日乘子压力 $p$：\n$$\n\\sigma = -p I + 2\\mu\\,\\epsilon(u)\n$$\n其中 $\\mu > 0$ 是剪切模量，$I$ 是单位张量，$\\epsilon(u) = \\frac{1}{2}(\\nabla u + \\nabla u^{\\top})$ 是小应变张量。\n\n边界条件为：\n1.  底边 ($y=0$)：$u_y(x,0) = 0$。\n2.  顶边 ($y=1$)：$u_y(x,1) = -\\delta$，对于某个 $\\delta > 0$。\n3.  侧边 ($x=0, 1$)：无面力，即 $\\sigma n = 0$，其中 $n$ 是外法向量。\n\n考虑到均匀的竖向压缩，我们寻求一个竖向位移 $u_y$ 仅是 $y$ 的函数的解。边界条件暗示了一个线性分布：\n$$\nu_y(x,y) = -\\delta y\n$$\n这个选择满足 $u_y(x,0)=0$ 和 $u_y(x,1)=-\\delta$。\n\n现在，我们使用不可压缩性约束 $\\nabla \\cdot u = 0$：\n$$\n\\frac{\\partial u_x}{\\partial x} + \\frac{\\partial u_y}{\\partial y} = 0 \\implies \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial}{\\partial y}(-\\delta y) = 0 \\implies \\frac{\\partial u_x}{\\partial x} = \\delta\n$$\n对 $x$ 积分得到：\n$$\nu_x(x,y) = \\delta x + C(y)\n$$\n其中 $C(y)$ 是 $y$ 的任意函数。\n\n接下来，我们计算应变张量 $\\epsilon(u)$ 的分量：\n$$\n\\epsilon_{xx} = \\frac{\\partial u_x}{\\partial x} = \\delta\n$$\n$$\n\\epsilon_{yy} = \\frac{\\partial u_y}{\\partial y} = -\\delta\n$$\n$$\n\\epsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}\\right) = \\frac{1}{2}\\left(C'(y) + 0\\right) = \\frac{1}{2}C'(y)\n$$\n\n平衡方程 $\\nabla \\cdot \\sigma = 0$ 可以通过代入本构关系写成斯托克斯(Stokes)流方程的形式：$-\\nabla p + \\mu \\nabla^2 u = 0$。用分量形式表示为：\n$x$-分量：\n$$\n-\\frac{\\partial p}{\\partial x} + \\mu \\left(\\frac{\\partial^2 u_x}{\\partial x^2} + \\frac{\\partial^2 u_x}{\\partial y^2}\\right) = 0 \\implies -\\frac{\\partial p}{\\partial x} + \\mu \\left(0 + C''(y)\\right) = 0 \\implies \\frac{\\partial p}{\\partial x} = \\mu C''(y)\n$$\n$y$-分量：\n$$\n-\\frac{\\partial p}{\\partial y} + \\mu \\left(\\frac{\\partial^2 u_y}{\\partial x^2} + \\frac{\\partial^2 u_y}{\\partial y^2}\\right) = 0 \\implies - \\frac{\\partial p}{\\partial y} + \\mu(0+0) = 0 \\implies \\frac{\\partial p}{\\partial y} = 0\n$$\n$y$-分量意味着压力 $p$ 仅是 $x$ 的函数，$p=p(x)$。将此代入 $x$-分量的方程，我们得到 $\\frac{dp}{dx} = \\mu C''(y)$。由于左侧仅依赖于 $x$，右侧仅依赖于 $y$，所以两者必须等于一个常数，记为 $K$。\n$$\n\\frac{dp}{dx} = K \\implies p(x) = Kx + P_0\n$$\n$$\n\\mu C''(y) = K \\implies C'(y) = \\frac{K}{\\mu} y + A_1\n$$\n其中 $P_0$ 和 $A_1$ 是积分常数。\n\n现在我们应用侧边的无面力边界条件。在 $x=0$ 处，$n=(-1,0)$；在 $x=1$ 处，$n=(1,0)$。条件是 $\\sigma_{xx}(0,y)=0$, $\\sigma_{xy}(0,y)=0$ 以及 $\\sigma_{xx}(1,y)=0$, $\\sigma_{xy}(1,y)=0$。\n\n应力分量为：\n$$\n\\sigma_{xx} = -p + 2\\mu\\epsilon_{xx} = -(Kx+P_0) + 2\\mu\\delta\n$$\n$$\n\\sigma_{xy} = 2\\mu\\epsilon_{xy} = \\mu C'(y) = \\mu\\left(\\frac{K}{\\mu}y + A_1\\right) = Ky + \\mu A_1\n$$\n应用 $\\sigma_{xx}(0,y)=0$：\n$$\n-P_0 + 2\\mu\\delta = 0 \\implies P_0 = 2\\mu\\delta\n$$\n应用 $\\sigma_{xx}(1,y)=0$：\n$$\n-(K+P_0) + 2\\mu\\delta = 0 \\implies -K - (2\\mu\\delta) + 2\\mu\\delta = 0 \\implies K=0\n$$\n当 $K=0$ 时，压力是恒定的：$p(x) = P_0 = 2\\mu\\delta$。\n现在，应用 $\\sigma_{xy}(0,y)=0$：\n$$\nKy + \\mu A_1 = 0 \\implies (0)y + \\mu A_1 = 0 \\implies A_1 = 0\n$$\n$x=1$ 上的条件自动满足。因此，所有常数都已确定。位移分量 $u_x$ 是 $u_x(x,y) = \\delta x + A_2$，其中 $A_2$ 是对应于刚体运动的常数，不影响应力。我们可以设置 $A_2=-\\delta/2$ 以使得 $\\int_0^1 u_x(x,0)dx=0$，但这对于求解应力并非必要。\n\n整个域内的应力状态是均匀的：\n$$\n\\sigma_{xx} = -(2\\mu\\delta) + 2\\mu\\delta = 0\n$$\n$$\n\\sigma_{yy} = -p + 2\\mu\\epsilon_{yy} = -(2\\mu\\delta) + 2\\mu(-\\delta) = -4\\mu\\delta\n$$\n$$\n\\sigma_{xy} = (0)y + \\mu(0) = 0\n$$\n顶边 $y=1$ 上的竖向反作用力是该边上 $\\sigma_{yy}$ 的值。\n$$\n\\bar{t}_y^{\\text{exact}} = \\sigma_{yy}|_{y=1} = -4\\mu\\delta\n$$\n\n### 第二部分：四节点四边形单元锁定场景\n\n对于这一部分，我们考虑一个占据域 $\\Omega$ 的单个四节点双线性四边形（$Q1$）有限元。位移场 $(u_x, u_y)$ 是从节点位移插值得到的。边界条件现在应用于节点。\n-   $u_y(x,0)=0 \\implies u_{y1}=0, u_{y2}=0$\n-   $u_y(x,1)=-\\delta \\implies u_{y3}=-\\delta, u_{y4}=-\\delta$\n-   侧边（$x=0,1$）上 $u_x=0 \\implies u_{x1}=u_{x4}=0$ 且 $u_{x2}=u_{x3}=0$。\n所有四个节点的x向位移均为零：$u_{x1}=u_{x2}=u_{x3}=u_{x4}=0$。\n\n单位正方形上的一个 $Q1$ 单元的位移场由下式给出：\n$$\nu(x,y) = \\sum_{i=1}^4 N_i(x,y) u_i\n$$\n其中 $u_i = (u_{xi}, u_{yi})$ 是节点位移，形函数为：\n$N_1=(1-x)(1-y)$, $N_2=x(1-y)$, $N_3=xy$, $N_4=(1-x)y$。\n\n使用指定的节点位移：\n$$\nu_x(x,y) = \\sum N_i(x,y) u_{xi} = 0\n$$\n$$\nu_y(x,y) = N_1(0) + N_2(0) + N_3(-\\delta) + N_4(-\\delta) = -xy\\delta - (1-x)y\\delta = -y\\delta(x + 1 - x) = -y\\delta\n$$\n单元内的位移场为 $u = (0, -\\delta y)$。\n\n现在，我们根据该位移场计算应变分量：\n$$\n\\epsilon_{xx} = \\frac{\\partial u_x}{\\partial x} = 0\n$$\n$$\n\\epsilon_{yy} = \\frac{\\partial u_y}{\\partial y} = -\\delta\n$$\n$$\n\\epsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}\\right) = 0\n$$\n体积应变为 $\\operatorname{tr}(\\epsilon) = \\epsilon_{xx} + \\epsilon_{yy} = 0 - \\delta = -\\delta$。\n\n对于这一部分，我们使用纯位移本构关系：\n$$\n\\sigma = \\lambda\\,\\operatorname{tr}(\\epsilon)\\,I + 2\\mu\\,\\epsilon\n$$\n其中 $\\lambda > 0$ 是另一个拉梅(Lamé)参数。\n应力分量为：\n$$\n\\sigma_{xx} = \\lambda(-\\delta) + 2\\mu(0) = -\\lambda\\delta\n$$\n$$\n\\sigma_{yy} = \\lambda(-\\delta) + 2\\mu(-\\delta) = -(\\lambda+2\\mu)\\delta\n$$\n$$\n\\sigma_{xy} = 2\\mu(0) = 0\n$$\n应力场是均匀的。顶边 $y=1$ 上的竖向反作用力为：\n$$\n\\bar{t}_y^{\\text{Q1}} = \\sigma_{yy}|_{y=1} = -(\\lambda+2\\mu)\\delta\n$$\n\n### 第三部分：定量比较\n\n我们构建比率 $R(\\lambda,\\mu) = \\frac{|\\bar{t}_y^{\\text{Q1}}|}{|\\bar{t}_y^{\\text{exact}}|}$。\n我们有 $|\\bar{t}_y^{\\text{exact}}| = |-4\\mu\\delta| = 4\\mu\\delta$，因为 $\\mu, \\delta > 0$。\n我们有 $|\\bar{t}_y^{\\text{Q1}}| = |-(\\lambda+2\\mu)\\delta| = (\\lambda+2\\mu)\\delta$，因为 $\\lambda, \\mu, \\delta > 0$。\n\n该比率为：\n$$\nR(\\lambda,\\mu) = \\frac{(\\lambda+2\\mu)\\delta}{4\\mu\\delta}\n$$\n因子 $\\delta$ 被消去：\n$$\nR(\\lambda,\\mu) = \\frac{\\lambda+2\\mu}{4\\mu} = \\frac{\\lambda}{4\\mu} + \\frac{2\\mu}{4\\mu} = \\frac{\\lambda}{4\\mu} + \\frac{1}{2}\n$$\n这个比率量化了被锁定的有限元模型对刚度的过高估计。当材料接近不可压缩极限（$\\lambda \\to \\infty$）时，该比率 $R(\\lambda,\\mu)$ 趋于无穷大，这是体积锁定的标志。", "answer": "$$\\boxed{\\frac{\\lambda}{4\\mu} + \\frac{1}{2}}$$", "id": "3609974"}, {"introduction": "从解析模型过渡到实际的数值实现，我们将探讨一种最经典且直接的体积锁定缓解策略：选择性减缩积分 (Selective Reduced Integration, SRI)。本练习将指导你为一个经典的悬臂梁弯曲问题编写有限元程序，该问题在完全积分下会表现出严重的锁定现象 [@problem_id:3609948]。通过对比完全积分和选择性减缩积分的结果与梁理论的解析解，你将亲眼见证 SRI 如何显著提高位移预测的精度，并理解其作为一种高效计算工具的价值所在。", "problem": "考虑一个平面应变条件下的二维小应变线性弹性悬臂梁模型，该模型使用四节点双线性四边形有限元进行离散。梁的长度为 $L$ 米，高度为 $H$ 米，平面外厚度为 $b$ 米。左端（$x=0$）被完全固定，一个大小为 $P$ 牛顿的竖直向下点荷载施加在自由端（$x=L$）最接近中线高度（$y=H/2$）的节点上。目标是通过比较体积刚度的完全积分与选择性减缩积分，来量化近不可压缩情况下的体积锁定效应，并计算尖端挠度的相对误差，结果以小数表示。\n\n基本原理：\n- 小应变运动学：无穷小应变张量定义为 $ \\varepsilon = \\tfrac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^T)$，其中 $\\mathbf{u}$ 是位移场。在二维平面应变设置中，工程应变向量为 $[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$，其中 $\\gamma_{xy} = 2 \\varepsilon_{xy}$。\n- 各向同性线性弹性（拉梅参数）：柯西应力为 $ \\sigma = 2 \\mu \\, \\varepsilon + \\lambda \\, \\text{tr}(\\varepsilon) \\, I$。体积模量 $K$ 和剪切模量 $\\mu$ 通过 $ \\lambda = K - \\tfrac{2}{3} \\mu$ 与拉梅参数 $\\lambda$ 相关联。在使用工程应变向量的二维平面应变公式中，作用于 $[\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy}]^T$ 的本构矩阵 $C_{\\text{full}}$ 为\n$$\nC_{\\text{full}} = \\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}.\n$$\n- 选择性减缩积分：将 $C_{\\text{full}}$ 分解为 $C_{\\text{full}} = C_{\\text{dev}} + C_{\\text{vol}}$，其中\n$$\nC_{\\text{dev}} = \\begin{bmatrix}\n2\\mu  0  0 \\\\\n0  2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}, \\quad\nC_{\\text{vol}} = \\begin{bmatrix}\n\\lambda  \\lambda  0 \\\\\n\\lambda  \\lambda  0 \\\\\n0  0  0\n\\end{bmatrix}.\n$$\n使用完全 $2\\times 2$ 高斯求积对 $C_{\\text{dev}}$ 进行积分，使用单元中心的单个高斯点（单点求积）对 $C_{\\text{vol}}$ 进行积分，以减少体积锁定，同时避免畸变模式的沙漏现象。\n\n梁参考尖端挠度：\n- 在尖端荷载 $P$ 作用下，细长悬臂梁中线高度处的竖向尖端挠度的解析参考值由 Euler–Bernoulli 表达式给出\n$$\n\\delta_{\\text{ref}} = \\frac{P L^3}{3 E I},\n$$\n其中杨氏模量 $E$ 和泊松比 $\\nu$ 可由 $K$ 和 $\\mu$ 通过 $ E = \\frac{9 K \\mu}{3 K + \\mu}$ 和 $ \\nu = \\frac{3 K - 2 \\mu}{2(3 K + \\mu)}$ 得出，截面二次矩为 $ I = \\frac{b H^3}{12}$。请以米为单位表示 $\\delta_{\\text{ref}}$。\n\n有限元近似细节：\n- 在平面应变条件下使用四节点双线性四边形 (Q4) 等参单元。通过等参映射的雅可比矩阵，利用形函数对物理坐标的导数来构建应变-位移矩阵 $B$。单元刚度为\n$$\nK_e = \\int_{\\Omega_e} B^T C B \\, b \\, d\\Omega,\n$$\n其中 $b$ 是平面外厚度，对于完全积分情况，$C$ 为 $C_{\\text{full}}$；对于选择性减缩积分情况，$C$ 为如上所述积分的分离矩阵 $C_{\\text{dev}}$ 和 $C_{\\text{vol}}$。组装全局刚度矩阵，对左端（$x=0$）的 $u_x$ 和 $u_y$ 施加零位移的本质边界条件，在自由端中线高度节点沿 y 轴负方向施加点荷载 $P$，然后求解得到的线性系统以获得节点位移。\n\n关注量与误差度量：\n- 设 $\\delta_{\\text{FE,full}}$ 为使用完全积分计算出的自由端中线高度节点的竖向位移大小，$\\delta_{\\text{FE,sel}}$ 为使用选择性减缩积分计算出的相应大小。通过以下公式计算相对误差（以小数表示）：\n$$\ne_{\\text{full}} = \\frac{\\delta_{\\text{FE,full}} - \\delta_{\\text{ref}}}{\\delta_{\\text{ref}}}, \\quad\ne_{\\text{sel}} = \\frac{\\delta_{\\text{FE,sel}} - \\delta_{\\text{ref}}}{\\delta_{\\text{ref}}}.\n$$\n不允许使用百分号。\n\n测试组：\n- 使用以下参数集，所有物理量均采用国际单位制（SI）：\n    - 案例1：$L=1.0$, $H=0.2$, $b=0.1$, $P=1000.0$, $N_x=4$, $N_y=4$, $\\mu=1.0\\times 10^9$, $K/\\mu = 10$。\n    - 案例2：$L=1.0$, $H=0.2$, $b=0.1$, $P=1000.0$, $N_x=4$, $N_y=4$, $\\mu=1.0\\times 10^9$, $K/\\mu = 1000$。\n    - 案例3：$L=1.0$, $H=0.2$, $b=0.1$, $P=1000.0$, $N_x=8$, $N_y=8$, $\\mu=1.0\\times 10^9$, $K/\\mu = 1000$。\n    - 案例4：$L=1.0$, $H=0.2$, $b=0.1$, $P=1000.0$, $N_x=2$, $N_y=2$, $\\mu=1.0\\times 10^9$, $K/\\mu = 100$。\n\n您的程序必须为每个案例计算如上定义的 $e_{\\text{full}}$ 和 $e_{\\text{sel}}$。最终输出格式必须是单行，包含一个列表的列表，形式为 $[[e_{\\text{full,1}},e_{\\text{sel,1}}],[e_{\\text{full,2}},e_{\\text{sel,2}}],[e_{\\text{full,3}},e_{\\text{sel,3}}],[e_{\\text{full,4}},e_{\\text{sel,4}}]]$. 输出中不允许有任何额外文本。所有角度（若有）必须以弧度为单位。所有挠度必须以米为单位计算，所有力以牛顿为单位。相对误差必须是小数（浮点数）。", "solution": "在尝试任何解答之前，需对问题进行验证。\n\n### 第1步：提取已知条件\n- **模型**：二维小应变线性弹性，平面应变。\n- **几何**：悬臂梁，长度 $L$，高度 $H$，平面外厚度 $b$。\n- **边界条件**：左端（$x=0$）完全固定（$u_x=0, u_y=0$）。\n- **荷载**：在自由端（$x=L$）最接近中线高度（$y \\approx H/2$）的节点处施加大小为 $P$ 的竖直向下点荷载。\n- **运动学**：无穷小应变张量 $\\varepsilon = \\tfrac{1}{2}(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^T)$。工程应变向量为 $[\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^T$，其中 $\\gamma_{xy} = 2 \\varepsilon_{xy}$。\n- **本构律**：各向同性线性弹性, $\\sigma = 2 \\mu \\, \\varepsilon + \\lambda \\, \\text{tr}(\\varepsilon) \\, I$。\n- **本构矩阵（平面应变）**：\n$$\nC_{\\text{full}} = \\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}\n$$\n- **选择性减缩积分（SRI）分解**：$C_{\\text{full}} = C_{\\text{dev}} + C_{\\text{vol}}$，其中\n$$\nC_{\\text{dev}} = \\begin{bmatrix}\n2\\mu  0  0 \\\\\n0  2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}, \\quad\nC_{\\text{vol}} = \\begin{bmatrix}\n\\lambda  \\lambda  0 \\\\\n\\lambda  \\lambda  0 \\\\\n0  0  0\n\\end{bmatrix}\n$$\n- **积分方案**：对于 SRI，$C_{\\text{dev}}$ 使用完全 $2 \\times 2$ 高斯求积进行积分，$C_{\\text{vol}}$ 使用单元中心的单点求积进行积分。对于完全积分，$C_{\\text{full}}$ 使用 $2 \\times 2$ 高斯求积进行积分。\n- **参考挠度**：Euler–Bernoulli 理论给出 $\\delta_{\\text{ref}} = \\frac{P L^3}{3 E I}$，其中 $I = \\frac{b H^3}{12}$。\n- **材料参数关系**：$E = \\frac{9 K \\mu}{3 K + \\mu}$, $\\nu = \\frac{3 K - 2 \\mu}{2(3 K + \\mu)}$，以及 $\\lambda = K - \\tfrac{2}{3} \\mu$。\n- **有限元离散化**：四节点双线性四边形 (Q4) 等参单元，沿长度方向有 $N_x$ 个单元，沿高度方向有 $N_y$ 个单元。\n- **单元刚度**：$K_e = \\int_{\\Omega_e} B^T C B \\, b \\, d\\Omega$。\n- **关注量**：$\\delta_{\\text{FE,full}}$（完全积分挠度），$\\delta_{\\text{FE,sel}}$（SRI 挠度）。\n- **误差度量**：$e_{\\text{full}} = \\frac{\\delta_{\\text{FE,full}} - \\delta_{\\text{ref}}}{\\delta_{\\text{ref}}}$, $e_{\\text{sel}} = \\frac{\\delta_{\\text{FE,sel}} - \\delta_{\\text{ref}}}{\\delta_{\\text{ref}}}$。\n- **测试组**：\n    - 案例1：$L=1.0, H=0.2, b=0.1, P=1000.0, N_x=4, N_y=4, \\mu=10^9, K/\\mu=10$。\n    - 案例2：$L=1.0, H=0.2, b=0.1, P=1000.0, N_x=4, N_y=4, \\mu=10^9, K/\\mu=1000$。\n    - 案例3：$L=1.0, H=0.2, b=0.1, P=1000.0, N_x=8, N_y=8, \\mu=10^9, K/\\mu=1000$。\n    - 案例4：$L=1.0, H=0.2, b=0.1, P=1000.0, N_x=2, N_y=2, \\mu=10^9, K/\\mu=100$。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学依据、是良态的且客观的。\n1.  **科学合理性**：该问题是有限元法（FEM）在线性弹性（固体力学的一项基本理论）中的一个标准应用。近不可压缩材料中的体积锁定现象是一个有据可查的数值假象，而选择性减缩积分是缓解此问题的一种经典技术。所提供的材料属性、运动学和单元公式的方程在计算力学中是标准的。本构矩阵的分解，尽管是几种可能性中的一个特定选择，但是是实现像 SRI 这样的 B-bar 型方法的有效且常被讨论的方法。\n2.  **良态性**：该问题是良态的。具有指定边界条件和荷载的悬臂梁设置在线性弹性理论中存在唯一解。参数和目标都已明确定义，从而可以计算出一组唯一的误差值。\n3.  **完整性与一致性**：问题陈述是自洽的，提供了完整实现所需的所有必要物理参数、几何数据、材料定律、数值程序和定义。测试案例已完全指定。不存在矛盾之处。\n\n### 第3步：结论与行动\n该问题是有效的。将制定一个合理的解决方案。\n\n### 解决方案\n该问题要求实现一个二维有限元代码，以分析平面应变条件下的悬臂梁，并量化体积锁定的影响。我们将比较标准完全积分方案和选择性减缩积分方案的结果。\n\n#### 基于原理的设计\n该解决方案基于以下计算固体力学原理构建：\n\n1.  **等参有限元公式**：我们使用四节点四边形 (Q4) 单元。每个单元的几何形状使用与插值位移场相同的双线性形函数，从一个标准方形父域 $(\\xi, \\eta) \\in [-1, 1] \\times [-1, 1]$ 映射到物理域 $(x, y)$。这就是等参概念的精髓。对于 $i=1, 2, 3, 4$，形函数 $N_i(\\xi, \\eta)$ 为：\n    $$\n    N_1 = \\frac{1}{4}(1-\\xi)(1-\\eta), \\quad N_2 = \\frac{1}{4}(1+\\xi)(1-\\eta), \\quad N_3 = \\frac{1}{4}(1+\\xi)(1+\\eta), \\quad N_4 = \\frac{1}{4}(1-\\xi)(1+\\eta)\n    $$\n2.  **应变-位移矩阵 ($B$)**：应变场通过应变-位移矩阵 $B$ 与节点位移相关联。对于一个具有8个自由度（DOFs）的 Q4 单元，$B$ 是一个 $3 \\times 8$ 的矩阵。其分量源自形函数的空间导数。由于形函数定义在自然坐标系中，因此使用链式法则，其中涉及坐标映射的雅可比矩阵 $J$ 的逆：\n    $$\n    \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{bmatrix} = J^{-1} \\begin{bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{bmatrix}\n    $$\n    矩阵 $B$ 随后被组装为 $B = [B_1, B_2, B_3, B_4]$，其中每个节点 $i$ 的子矩阵 $B_i$ 为：\n    $$\n    B_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}\n    $$\n3.  **数值积分**：单元刚度矩阵 $K_e$ 通过在单元体积上积分计算得出。该积分使用高斯求积进行数值计算。\n    $$\n    K_e = \\int_{\\Omega_e} B^T C B \\, b \\, d\\Omega = b \\int_{-1}^{1}\\int_{-1}^{1} B(\\xi, \\eta)^T C B(\\xi, \\eta) \\det(J(\\xi, \\eta)) \\, d\\xi \\, d\\eta\n    $$\n    该积分通过在特定高斯点处求值的被积函数的加权和来近似。对于 $2 \\times 2$ 求积法则，有四个点位于 $(\\xi_j, \\eta_j) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，权重为 $w_j = 1$。\n\n4.  **体积锁定与选择性减缩积分 (SRI)**：对于近不可压缩材料（$\\nu \\to 0.5$，或等效地 $K/\\mu \\gg 1$），体积模量 $K$ 和拉梅参数 $\\lambda$ 变得非常大。不可压缩条件 $\\text{tr}(\\varepsilon) = \\varepsilon_{xx} + \\varepsilon_{yy} \\approx 0$ 必须得到满足。在标准的 Q4 单元中，应变场不是恒定的。完全积分（$2 \\times 2$ 求积）在四个点上强制施加不可压缩约束，这对于单元的运动自由度来说过于严格。这种“过度约束”使得单元人为地变刚，这种现象被称为体积锁定。\n\n    SRI 通过“放宽”不可压缩约束来缓解此问题。刚度矩阵被分为一个完全积分的偏量部分（$K_{e, \\text{dev}}$）和一个欠积分的体积部分（$K_{e, \\text{vol}}$）。\n    -   $K_{e, \\text{dev}} = b \\int_{\\Omega_e} B^T C_{\\text{dev}} B \\, d\\Omega$ 使用完全 $2 \\times 2$ 高斯求积法则进行计算。这保留了单元精确表示剪切和其他畸变的能力，并防止了伪零能模式（沙漏）。\n    -   $K_{e, \\text{vol}} = b \\int_{\\Omega_e} B^T C_{\\text{vol}} B \\, d\\Omega$ 使用单元中心 $(\\xi, \\eta) = (0, 0)$ 的单个高斯点（权重 $w = 4$）进行计算。这仅在单元的平均意义上强制施加不可压缩约束，使其能够更自由地弯曲而没有大的能量惩罚。\n\n5.  **组装与求解**：单元刚度矩阵被组装成一个全局刚度矩阵 $K$。通过修改 $K$ 和全局力向量 $F$ 来施加边界条件。$x=0$ 处的固定条件意味着将此边上节点的自由度设置为零。点荷载 $P$ 被加到 $F$ 中相应的项上。求解得到的线性系统 $K U = F$ 以获得节点位移向量 $U$。\n\n#### 计算步骤\n对于每个测试案例：\n1.  **预处理**：给定 $L, H, b, P, N_x, N_y, \\mu, K/\\mu$:\n    -   计算 $K = \\mu \\cdot (K/\\mu)$。\n    -   计算杨氏模量 $E = \\frac{9 K \\mu}{3 K + \\mu}$ 和泊松比 $\\nu = \\frac{3 K - 2 \\mu}{2(3 K + \\mu)}$。\n    -   计算拉梅参数 $\\lambda = K - \\frac{2}{3} \\mu$。\n    -   计算截面二次矩 $I = \\frac{b H^3}{12}$。\n    -   计算参考尖端挠度 $\\delta_{\\text{ref}} = \\frac{P L^3}{3 E I}$。\n    -   构建材料矩阵 $C_{\\text{full}}$, $C_{\\text{dev}}$ 和 $C_{\\text{vol}}$。\n    -   为 $N_x \\times N_y$ 网格生成结构化节点网格和单元连接列表。\n\n2.  **有限元求解器（运行两次：分别用于完全积分和 SRI）**：\n    -   初始化全局刚度矩阵 $K$ 和力向量 $F$ 为零。\n    -   遍历网格中的所有单元。对于每个单元：\n        -   计算单元刚度矩阵 $K_e$。\n            -   对于完全积分：对 $B^T C_{\\text{full}} B$ 项使用 $2 \\times 2$ 高斯求积。\n            -   对于选择性减缩积分：将使用 $2 \\times 2$ 求积积分的偏量部分（$B^T C_{\\text{dev}} B$）和使用单点求积积分的体积部分（$B^T C_{\\text{vol}} B$）相加。\n        -   根据单元的节点连接性将 $K_e$ 组装到全局矩阵 $K$ 中。\n    -   施加点荷载：找到位于 $(x, y) = (L, H/2)$ 的节点，确定其竖向自由度索引，并将 $F$ 中的相应项设置为 $-P$。\n    -   施加边界条件：识别固定边（$x=0$）上的所有自由度，并修改 $K$ 和 $F$ 以强制零位移（例如，通过将 $K$ 的对角线元素设为 1，相应的行/列设为 0，并强制右侧项为 0）。\n    -   求解线性系统 $K U = F$ 以获得位移向量 $U$。\n    -   提取加载节点的竖向位移 $u_y$。其大小为 $\\delta_{\\text{FE}} = |u_y| = -u_y$。\n\n3.  **后处理**：\n    -   使用计算出的挠度 $\\delta_{\\text{FE,full}}$ 和 $\\delta_{\\text{FE,sel}}$，计算相对于 $\\delta_{\\text{ref}}$ 的相对误差 $e_{\\text{full}}$ 和 $e_{\\text{sel}}$。\n    -   为每个测试案例收集数对 $[e_{\\text{full}}, e_{\\text{sel}}]$。\n\n对问题陈述中提供的四个测试案例中的每一个都执行此程序，并将结果汇总成要求的输出格式。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve as linsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the finite element problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # L, H, b, P, Nx, Ny, mu, K_mu_ratio\n        (1.0, 0.2, 0.1, 1000.0, 4, 4, 1.0e9, 10.0),\n        (1.0, 0.2, 0.1, 1000.0, 4, 4, 1.0e9, 1000.0),\n        (1.0, 0.2, 0.1, 1000.0, 8, 8, 1.0e9, 1000.0),\n        (1.0, 0.2, 0.1, 1000.0, 2, 2, 1.0e9, 100.0),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        L, H, b, P, Nx, Ny, mu, K_mu_ratio = case\n        \n        # --- Preprocessing: Material and Reference Calculation ---\n        K = mu * K_mu_ratio\n        E = (9 * K * mu) / (3 * K + mu)\n        # nu = (3 * K - 2 * mu) / (2 * (3 * K + mu)) # Not directly needed for C-matrix\n        lmbda = K - (2.0 / 3.0) * mu\n        \n        I = (b * H**3) / 12.0\n        delta_ref = (P * L**3) / (3.0 * E * I)\n        \n        # --- Solve for Full Integration ---\n        delta_fe_full = run_fem_analysis(L, H, b, P, Nx, Ny, mu, lmbda, 'full')\n        e_full = (delta_fe_full - delta_ref) / delta_ref\n        \n        # --- Solve for Selective Reduced Integration ---\n        delta_fe_sel = run_fem_analysis(L, H, b, P, Nx, Ny, mu, lmbda, 'selective')\n        e_sel = (delta_fe_sel - delta_ref) / delta_ref\n        \n        all_results.append([e_full, e_sel])\n        \n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef run_fem_analysis(L, H, b, P, Nx, Ny, mu, lmbda, integration_type):\n    \"\"\"\n    Performs a single Finite Element Analysis for given parameters.\n    \"\"\"\n    # --- Mesh Generation ---\n    num_nodes_x = Nx + 1\n    num_nodes_y = Ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_elements = Nx * Ny\n    num_dofs = 2 * num_nodes\n\n    x_coords = np.linspace(0, L, num_nodes_x)\n    y_coords = np.linspace(0, H, num_nodes_y)\n    node_coords = np.array([[x, y] for y in y_coords for x in x_coords])\n\n    elements = []\n    for i in range(Nx):\n        for j in range(Ny):\n            n1 = i * num_nodes_y + j\n            n2 = (i + 1) * num_nodes_y + j\n            n3 = (i + 1) * num_nodes_y + (j + 1)\n            n4 = i * num_nodes_y + (j + 1)\n            elements.append([n1, n2, n3, n4])\n    \n    elements = np.array(elements)\n    \n    # --- Constitutive Matrices ---\n    C_full = np.array([[lmbda + 2*mu, lmbda, 0],\n                       [lmbda, lmbda + 2*mu, 0],\n                       [0, 0, mu]])\n    \n    C_dev = np.array([[2*mu, 0, 0],\n                      [0, 2*mu, 0],\n                      [0, 0, mu]])\n\n    C_vol = np.array([[lmbda, lmbda, 0],\n                      [lmbda, lmbda, 0],\n                      [0, 0, 0]])\n\n    # --- Assembly ---\n    K_global = np.zeros((num_dofs, num_dofs))\n    F_global = np.zeros(num_dofs)\n\n    # Gauss quadrature points and weights\n    gp_pos = 1.0 / np.sqrt(3.0)\n    gauss_points_2x2 = [(-gp_pos, -gp_pos, 1.0), (gp_pos, -gp_pos, 1.0),\n                        (gp_pos, gp_pos, 1.0), (-gp_pos, gp_pos, 1.0)]\n    \n    for el_nodes in elements:\n        el_coords = node_coords[el_nodes]\n        Ke = np.zeros((8, 8))\n\n        if integration_type == 'full':\n            for xi, eta, w in gauss_points_2x2:\n                B, detJ = get_B_matrix_and_detJ(xi, eta, el_coords)\n                Ke += B.T @ C_full @ B * detJ * w * b\n        \n        elif integration_type == 'selective':\n            # Deviatoric part (2x2 integration)\n            for xi, eta, w in gauss_points_2x2:\n                B, detJ = get_B_matrix_and_detJ(xi, eta, el_coords)\n                Ke += B.T @ C_dev @ B * detJ * w * b\n            \n            # Volumetric part (1-point integration)\n            B_center, detJ_center = get_B_matrix_and_detJ(0.0, 0.0, el_coords)\n            w_center = 4.0 # For 1x1 rule, the area of parent element is 4\n            Ke += B_center.T @ C_vol @ B_center * detJ_center * w_center / 4.0 * b # Correction for w_center\n\n        # Assemble Ke into K_global\n        dof_indices = np.array([[2 * n, 2 * n + 1] for n in el_nodes]).flatten()\n        K_global[np.ix_(dof_indices, dof_indices)] += Ke\n\n    # --- Boundary Conditions and Loads ---\n    # Apply point load P\n    load_node_y_idx = Ny // 2\n    load_node_idx = Nx * num_nodes_y + load_node_y_idx\n    load_dof = 2 * load_node_idx + 1\n    F_global[load_dof] = -P\n\n    # Apply clamped boundary condition at x=0\n    clamped_nodes = np.arange(num_nodes_y)\n    clamped_dofs = []\n    for node_idx in clamped_nodes:\n        clamped_dofs.append(2 * node_idx)\n        clamped_dofs.append(2 * node_idx + 1)\n\n    for dof in clamped_dofs:\n        K_global[dof, :] = 0\n        K_global[:, dof] = 0\n        K_global[dof, dof] = 1.0\n        F_global[dof] = 0.0\n\n    # --- Solve ---\n    U = linsolve(K_global, F_global)\n\n    # --- Extract Result ---\n    tip_deflection_val = U[load_dof]\n    return -tip_deflection_val # Return magnitude\n\ndef get_B_matrix_and_detJ(xi, eta, el_coords):\n    \"\"\"\n    Computes the B-matrix and the determinant of the Jacobian for a Q4 element.\n    \"\"\"\n    # Derivatives of shape functions w.r.t. natural coordinates\n    dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    \n    # Jacobian matrix\n    J = np.zeros((2, 2))\n    J[0, 0] = np.dot(dN_dxi, el_coords[:, 0]) # dx/dxi\n    J[0, 1] = np.dot(dN_dxi, el_coords[:, 1]) # dy/dxi\n    J[1, 0] = np.dot(dN_deta, el_coords[:, 0]) # dx/deta\n    J[1, 1] = np.dot(dN_deta, el_coords[:, 1]) # dy/deta\n    \n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n    \n    # Derivatives of shape functions w.r.t. physical coordinates\n    dN_cart = invJ @ np.vstack((dN_dxi, dN_deta))\n    dN_dx = dN_cart[0, :]\n    dN_dy = dN_cart[1, :]\n    \n    # B-matrix\n    B = np.zeros((3, 8))\n    for i in range(4):\n        B[0, 2*i] = dN_dx[i]\n        B[1, 2*i+1] = dN_dy[i]\n        B[2, 2*i] = dN_dy[i]\n        B[2, 2*i+1] = dN_dx[i]\n        \n    return B, detJ\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3609948"}, {"introduction": "虽然选择性减缩积分非常有效，但它并非没有缺点，例如可能引发沙漏模式等数值不稳定性。为了追求更稳健的解决方案，我们引入了增强应变格式 (enhanced strain formulations)，例如 $\\bar{\\mathbf{B}}$ 方法，它从理论上更优雅地解决了锁定问题。在这个高级实践中，你将为一个处于剪切状态的近不可压缩材料块实现这种先进的单元技术 [@problem_id:3609991]。通过将结果与标准单元进行比较，你将体会到增强应变法如何在粗糙网格和极端材料参数下依然能提供卓越的性能，从而掌握一种更强大、更可靠的计算力学工具。", "problem": "考虑一个在平面应变条件下承受简剪切的二维、小应变、线性弹性块体。其本构关系由 $ \\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon} $ 给出，其中 $ \\boldsymbol{\\sigma} $ 是应力矢量，$ \\boldsymbol{\\varepsilon} $ 是应变矢量，$ \\mathbf{D} $ 是各向同性材料的平面应变弹性矩阵。对于杨氏模量 $ E $ 和泊松比 $ \\nu $，拉梅参数为 $ \\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)} $ 和 $ \\mu = \\dfrac{E}{2(1+\\nu)} $，平面应变弹性矩阵为\n$$\n\\mathbf{D} = \\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}.\n$$\n应变-位移关系为 $ \\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u} $，其中 $ \\mathbf{B} $ 是标准双线性四边形单元矩阵，$ \\mathbf{u} $ 是位移矢量。该块体的尺寸为 $ L_x \\times L_y $（单位：米），厚度为单位长度（单位：米）。底边 $ y=0 $ 被固定，即 $ u_x = 0 $ 且 $ u_y = 0 $。顶边 $ y = L_y $ 通过指定位移 $ u_x = \\gamma L_y $ 和 $ u_y = 0 $ 来施加简剪切，所有其他边界均为无面力边界。假设体力为零。\n\n在线性弹性理论中，对于一个纯简剪切位移场，其精确的均匀剪应力为 $ \\tau_{xy} = G \\gamma $，其中 $ G = \\mu $ 是剪切模量，$ \\gamma $ 是工程剪应变。由此产生的沿顶边的精确水平反作用力为 $ F_{\\text{th}} = \\tau_{xy} L_x = G \\gamma L_x $（每单位厚度），这在不可压缩极限下与体积模量无关。\n\n您必须使用平面应变条件下的四节点双线性四边形单元来实现两种有限元离散化方案：\n- 一种基准的纯位移格式，在 Gauss 积分点使用标准的 $ \\mathbf{B} $ 矩阵，并采用完全的 $ 2 \\times 2 $ Gauss 积分。\n- 一种增强应变（非协调模式）修正方法，通过 $\\bar{\\mathbf{B}}$ 修正来消除体积自锁，其中应变的体积部分被投影到单元平均值上。令 $ \\mathbf{m} = [1,\\,1,\\,0]^\\top $。对每个 Gauss 积分点，定义 $ \\mathbf{B}_m = \\mathbf{m}^\\top \\mathbf{B} $ 及其单元平均值 $ \\bar{\\mathbf{B}}_m = \\dfrac{\\int_{\\Omega_e} \\mathbf{B}_m \\, \\mathrm{d}\\Omega }{\\int_{\\Omega_e} 1 \\, \\mathrm{d}\\Omega } $，并构造修正的应变-位移矩阵\n$$\n\\mathbf{B}^\\star = \\mathbf{B} - \\beta \\, \\mathbf{m} \\otimes \\left( \\mathbf{B}_m - \\bar{\\mathbf{B}}_m \\right),\n$$\n其中 $ \\beta = \\dfrac{1}{\\mathbf{m}^\\top \\mathbf{m}} = \\dfrac{1}{2} $，从而使得 $ \\mathbf{m}^\\top \\mathbf{B}^\\star = \\bar{\\mathbf{B}}_m $，这强制了所有 Gauss 积分点上的体积应变为常数。在标准的 $ 2 \\times 2 $ Gauss 积分点上，使用 $ \\mathbf{D} $ 和 $ \\mathbf{B}^\\star $ 集成单元刚度。\n\n通过将在指定的顶边水平自由度上的反作用力作为内力 $ \\mathbf{r} = \\mathbf{K} \\mathbf{u} $（因为外力为零）进行组合，并对与这些指定位移相对应的分量求和，来计算顶边水平方向上的全局反作用力。令 $ F_{\\text{FE}} $ 表示这个和（取其代数和，其符号将与施加的位移相反；您可以报告其量值）。\n\n定义无量纲刚度指标 $ R = \\dfrac{|F_{\\text{FE}}|}{F_{\\text{th}}} $。在没有体积自锁的情况下，当 $ \\nu \\to 0.5 $ 时，$ R $ 的值应接近 $ 1 $ 并且近似网格无关。\n\n您的程序必须：\n- 使用不同网格密度的 $ Q_1 $（双线性）单元结构化网格对块体进行离散化。\n- 对基准格式和增强应变格式，集成并求解线性系统。\n- 计算每种情况下的 $ R $ 值。\n\n使用以下材料、几何和加载参数：\n- $ E = 10^6 \\, \\text{Pa} $，$ \\nu = 0.4999 $（平面应变），$ L_x = 1 \\, \\text{m} $，$ L_y = 1 \\, \\text{m} $，$ \\gamma = 0.01 $。\n\n测试套件：\n- 网格：$ (N_x, N_y) \\in \\{ (1,1),\\, (2,2),\\, (4,4) \\} $，其中 $ N_x $ 和 $ N_y $ 分别是沿 $ x $ 和 $ y $ 方向的单元数量。\n- 对于每种网格，计算两个结果：基准格式得到的 $ R_{\\text{std}} $ 和增强应变格式得到的 $ R_{\\bar{B}} $。\n\n您的程序应生成单行输出，其中包含六个结果，格式为方括号括起来的逗号分隔列表，顺序为 $ [R_{\\text{std}}(1,1), R_{\\bar{B}}(1,1), R_{\\text{std}}(2,2), R_{\\bar{B}}(2,2), R_{\\text{std}}(4,4), R_{\\bar{B}}(4,4)] $。将每个结果表示为十进制浮点数。由于 $ R $ 是无量纲的，因此不需要单位。\n\n评估必须严格遵守指定的值。确保所有内部计算都与所述的小应变、平面应变假设以及增强应变修正方法一致。输出应严格为指定格式的单行文本。不应打印任何额外文本。", "solution": "所提出的问题是计算固体力学中一个有效且经典的基准问题，旨在演示近不可压缩材料中的体积自锁现象，并评估增强应变格式（$\\bar{\\mathbf{B}}$ 方法）在减轻这种数值赝品方面的有效性。该问题在科学上是合理的、适定的，并且所有必要的参数和步骤都已明确定义。因此，我们可以着手求解。\n\n问题的核心在于对平面应变条件下的线性弹性固体进行有限元分析，其中泊松比 $ \\nu $ 趋近于 $0.5$。在此极限情况下，材料变得近乎不可压缩，意味着其在变形下的体积变化趋近于零。在数学上，这对应于约束 $ \\nabla \\cdot \\mathbf{u} = \\varepsilon_x + \\varepsilon_y = 0 $，其中 $ \\mathbf{u} $ 是位移场，$ \\varepsilon_x, \\varepsilon_y $ 是正应变分量。\n\n### 有限元格式\n\n我们将域 $ \\Omega $ 离散化为由四节点双线性四边形（$Q_1$）单元组成的结构化网格。在每个单元 $ \\Omega_e $ 内，位移场 $ \\mathbf{u} $ 被近似为 $ \\mathbf{u}(\\mathbf{x}) = \\sum_{i=1}^{4} N_i(\\mathbf{x}) \\mathbf{u}_i $，其中 $ N_i $ 是双线性形函数，$ \\mathbf{u}_i $ 是节点位移。应变场由此通过应变-位移矩阵 $ \\mathbf{B} $ 导出，即 $ \\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{u}_e $，其中 $ \\mathbf{u}_e $ 是单元节点位移的矢量。\n\n单元刚度矩阵 $ \\mathbf{K}_e $ 源自虚功原理，由单元体积（或对于单位厚度，为面积）上的积分给出：\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega\n$$\n该积分使用 $2 \\times 2$ Gauss 求积进行数值计算。矩阵 $ \\mathbf{D} $ 是平面应变弹性矩阵，其取决于拉梅参数 $ \\lambda $ 和 $ \\mu $。当 $ \\nu \\to 0.5 $ 时，参数 $ \\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)} $ 趋于无穷大，起到一个施加不可压缩约束的罚参数的作用。\n\n### 基准格式中的体积自锁\n\n基准格式使用标准的应变-位移矩阵 $ \\mathbf{B} $。对于 $Q_1$ 单元， $ \\mathbf{B} $ 的分量是坐标的线性函数。因此，体积应变 $ \\varepsilon_{\\text{vol}} = \\varepsilon_x + \\varepsilon_y = \\mathbf{m}^\\top \\boldsymbol{\\varepsilon} $（其中 $ \\mathbf{m} = [1, 1, 0]^\\top $）在单元内也呈线性变化。为使数值解避免由巨大的 $ \\lambda $ 项引起的无限能量罚，体积应变在所有 Gauss 积分点上都必须接近于零。这对单元的少数自由度施加了多个约束。对于双线性单元，这些约束过于严格，会“锁死”单元，阻止其变形为物理上正确的模式（如纯剪切）。这导致了一种人为的过刚响应，计算出的反作用力 $ F_{\\text{FE}} $ 远大于理论力 $ F_{\\text{th}} $，从而导致刚度指标 $ R \\gg 1 $。\n\n### 增强应变（$\\bar{\\mathbf{B}}$）修正方法\n\n为规避自锁，$\\bar{\\mathbf{B}}$ 方法修改了应变-位移矩阵。它不是在每个 Gauss 积分点上强制体积应变接近于零，而是在整个单元上仅以平均意义强制此约束。这是通过将应变-位移矩阵的体积部分投影到单元内的常数函数空间上来实现的。\n\n修正后的应变-位移矩阵 $ \\mathbf{B}^\\star $ 构造如下：\n$$\n\\mathbf{B}^\\star = \\mathbf{B} - \\beta \\, \\mathbf{m} \\otimes \\left( \\mathbf{m}^\\top \\mathbf{B} - \\overline{\\mathbf{m}^\\top \\mathbf{B}} \\right)\n$$\n其中 $ \\overline{(\\cdot)} $ 表示在单元 $ \\Omega_e $ 上的体积平均值。项 $ \\mathbf{m}^\\top \\mathbf{B} $ 计算体积应变。该修正将每个 Gauss 积分点处的局部体积应变运动学替换为单元的平均体积应变运动学 $ \\overline{\\mathbf{m}^\\top \\mathbf{B}} $。这种构造确保了用 $ \\mathbf{B}^\\star $ 计算的体积应变在整个单元内是恒定的：$ \\mathbf{m}^\\top \\mathbf{B}^\\star = \\overline{\\mathbf{m}^\\top \\mathbf{B}} $。\n\n对不可压缩性约束的这种松弛，使得单元能够准确地表示剪切变形模式，而不会产生虚假的能量罚，从而消除了体积自锁。然后使用 $ \\mathbf{B}^\\star $ 计算单元刚度矩阵：\n$$\n\\mathbf{K}_e = \\int_{\\Omega_e} (\\mathbf{B}^\\star)^\\top \\mathbf{D} \\mathbf{B}^\\star \\, \\mathrm{d}\\Omega\n$$\n对于这种格式，计算出的刚度应该是物理上真实的，得到的刚度指标 $ R_{\\bar{B}} \\approx 1 $，并且很大程度上与网格密度无关。\n\n### 系统集成、求解和后处理\n\n对于这两种格式，全局刚度矩阵 $ \\mathbf{K} $ 由各单元刚度矩阵集成而来。通过将方程组 $ \\mathbf{K} \\mathbf{U} = \\mathbf{F} $ 划分为已知（指定）自由度和未知自由度，并求解未知位移来施加边界条件。\n\n反作用力是与指定自由度相对应的内力。它们由完整解向量 $ \\mathbf{U} $ 计算得出，即 $ \\mathbf{r} = \\mathbf{K} \\mathbf{U} $。顶边上的总水平反作用力 $ F_{\\text{FE}} $ 是 $ \\mathbf{r} $ 在顶部节点水平自由度上各分量的总和。最后，计算无量纲刚度指标 $ R = |F_{\\text{FE}}| / F_{\\text{th}} $，其中 $ F_{\\text{th}} = \\mu \\gamma L_x $ 是理论反作用力。对每个指定的网格和两种格式都重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_fem_analysis(Nx, Ny, E, nu, Lx, Ly, gamma, formulation_type):\n    \"\"\"\n    Performs a 2D plane strain finite element analysis for a block in simple shear.\n\n    Args:\n        Nx (int): Number of elements in the x-direction.\n        Ny (int): Number of elements in the y-direction.\n        E (float): Young's modulus.\n        nu (float): Poisson's ratio.\n        Lx (float): Block width.\n        Ly (float): Block height.\n        gamma (float): Applied shear strain.\n        formulation_type (str): 'standard' or 'B_bar'.\n\n    Returns:\n        float: The nondimensional stiffness indicator R.\n    \"\"\"\n    \n    # 1. Material and Constitutive Matrix\n    mu = E / (2 * (1 + nu))\n    lambda_ = E * nu / ((1 + nu) * (1 - 2 * nu))\n    D = np.array([\n        [lambda_ + 2 * mu, lambda_, 0],\n        [lambda_, lambda_ + 2 * mu, 0],\n        [0, 0, mu]\n    ])\n    m = np.array([1.0, 1.0, 0.0])\n    beta = 1.0 / (m.T @ m)\n\n    # 2. Mesh Generation\n    num_nodes = (Nx + 1) * (Ny + 1)\n    num_elements = Nx * Ny\n    \n    node_coords = np.zeros((num_nodes, 2))\n    for j in range(Ny + 1):\n        for i in range(Nx + 1):\n            node_idx = j * (Nx + 1) + i\n            node_coords[node_idx] = [i * Lx / Nx, j * Ly / Ny]\n\n    element_nodes = np.zeros((num_elements, 4), dtype=int)\n    for j in range(Ny):\n        for i in range(Nx):\n            el_idx = j * Nx + i\n            n1 = j * (Nx + 1) + i\n            n2 = j * (Nx + 1) + (i + 1)\n            n3 = (j + 1) * (Nx + 1) + (i + 1)\n            n4 = (j + 1) * (Nx + 1) + i\n            element_nodes[el_idx] = [n1, n2, n3, n4]\n\n    # 3. Global Stiffness Matrix Assembly\n    K = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    gauss_points = [-1 / np.sqrt(3), 1 / np.sqrt(3)]\n\n    for el_idx in range(num_elements):\n        node_indices = element_nodes[el_idx]\n        el_coords = node_coords[node_indices]\n        \n        k_e = np.zeros((8, 8))\n\n        B_m_bar = None\n        if formulation_type == 'B_bar':\n            B_m_sum = np.zeros(8)\n            area = 0.0\n            for xi in gauss_points:\n                for eta in gauss_points:\n                    dN_dxi_eta = 0.25 * np.array([\n                        [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],\n                        [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]\n                    ])\n                    J = el_coords.T @ dN_dxi_eta.T\n                    detJ = np.linalg.det(J)\n                    \n                    if detJ == 0: continue\n                    invJ = np.linalg.inv(J)\n                    dN_dxy = invJ @ dN_dxi_eta\n                    \n                    B = np.zeros((3, 8))\n                    for i in range(4):\n                        B[0, 2*i], B[1, 2*i+1] = dN_dxy[0, i], dN_dxy[1, i]\n                        B[2, 2*i], B[2, 2*i+1] = dN_dxy[1, i], dN_dxy[0, i]\n                        \n                    B_m = m @ B\n                    B_m_sum += B_m * detJ\n                    area += detJ\n            B_m_bar = B_m_sum / area if area > 0 else np.zeros(8)\n        \n        for xi in gauss_points:\n            for eta in gauss_points:\n                dN_dxi_eta = 0.25 * np.array([\n                    [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],\n                    [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]\n                ])\n                J = el_coords.T @ dN_dxi_eta.T\n                detJ = np.linalg.det(J)\n                \n                if detJ == 0: continue\n                invJ = np.linalg.inv(J)\n                dN_dxy = invJ @ dN_dxi_eta\n                \n                B = np.zeros((3, 8))\n                for i in range(4):\n                    B[0, 2*i], B[1, 2*i+1] = dN_dxy[0, i], dN_dxy[1, i]\n                    B[2, 2*i], B[2, 2*i+1] = dN_dxy[1, i], dN_dxy[0, i]\n\n                B_eff = B\n                if formulation_type == 'B_bar':\n                    B_m = m @ B\n                    B_star_correction = beta * np.outer(m, (B_m - B_m_bar))\n                    B_eff = B - B_star_correction\n                \n                k_e += B_eff.T @ D @ B_eff * detJ\n        \n        dof_map = np.array([[2*n, 2*n+1] for n in node_indices]).flatten()\n        K[np.ix_(dof_map, dof_map)] += k_e\n\n    # 4. Boundary Conditions and Solution\n    prescribed_dofs, prescribed_vals, top_horiz_dofs = [], [], []\n    for i in range(num_nodes):\n        if np.isclose(node_coords[i, 1], 0.0):\n            prescribed_dofs.extend([2*i, 2*i+1])\n            prescribed_vals.extend([0.0, 0.0])\n        elif np.isclose(node_coords[i, 1], Ly):\n            prescribed_dofs.extend([2*i, 2*i+1])\n            prescribed_vals.extend([gamma * Ly, 0.0])\n            top_horiz_dofs.append(2*i)\n\n    all_dofs = np.arange(2 * num_nodes)\n    free_dofs = np.setdiff1d(all_dofs, prescribed_dofs)\n    \n    U_p = np.array(prescribed_vals)\n    U = np.zeros(2 * num_nodes)\n    U[prescribed_dofs] = U_p\n    \n    if len(free_dofs) > 0:\n        K_ff = K[np.ix_(free_dofs, free_dofs)]\n        K_fp = K[np.ix_(free_dofs, prescribed_dofs)]\n        F_f = -K_fp @ U_p\n        try:\n            U_f = np.linalg.solve(K_ff, F_f)\n            U[free_dofs] = U_f\n        except np.linalg.LinAlgError:\n            return np.nan \n\n    # 5. Reaction Force Calculation\n    F_total = K @ U\n    F_FE = np.sum(F_total[top_horiz_dofs])\n\n    # 6. Nondimensional Stiffness Indicator\n    F_th = mu * gamma * Lx\n    R = np.abs(F_FE) / F_th if F_th != 0 else 0\n    \n    return R\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the FEM analysis for the specified test suite\n    and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 1),\n        (2, 2),\n        (4, 4),\n    ]\n    # Define problem parameters.\n    params = dict(E=1e6, nu=0.4999, Lx=1.0, Ly=1.0, gamma=0.01)\n\n    results = []\n    for Nx, Ny in test_cases:\n        # Baseline formulation\n        R_std = run_fem_analysis(Nx, Ny, **params, formulation_type='standard')\n        results.append(R_std)\n\n        # Enhanced-strain (B-bar) formulation\n        R_bbar = run_fem_analysis(Nx, Ny, **params, formulation_type='B_bar')\n        results.append(R_bbar)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3609991"}]}