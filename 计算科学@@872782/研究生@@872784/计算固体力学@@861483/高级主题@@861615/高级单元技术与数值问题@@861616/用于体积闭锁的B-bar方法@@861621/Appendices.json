{"hands_on_practices": [{"introduction": "在实施复杂的数值方案之前，理解其数学基础至关重要。本练习深入探讨了 $\\bar{B}$ 方法的核心组成部分：将节点位移映射到单元平均体积应变的算子。通过从第一性原理出发，为一个简单的方形单元推导该算子，我们将对体积平均的数学构造获得具体的理解 [@problem_id:3545792]。", "problem": "考虑一个占据物理坐标 $(x,y)$ 中单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 的单个等参双线性四边形 ($Q_4$) 有限元 (FE)。设节点坐标按逆时针顺序排列，节点 $1$ 位于 $(0,0)$，节点 $2$ 位于 $(1,0)$，节点 $3$ 位于 $(1,1)$，节点 $4$ 位于 $(0,1)$。设位移自由度 (degrees of freedom, DOF) 集合在单元向量中\n$$\n\\mathbf{d}_e = \\begin{pmatrix} u_1  v_1  u_2  v_2  u_3  v_3  u_4  v_4 \\end{pmatrix}^{\\mathsf{T}},\n$$\n其中 $u_i$ 和 $v_i$ 分别是节点 $i$ 沿 $x$ 和 $y$ 方向的位移分量。假设在平面应变条件下采用小应变运动学，因此体积应变 (膨胀) 定义为\n$$\n\\epsilon_v(x,y) = \\nabla \\cdot \\mathbf{u}(x,y) = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}.\n$$\n有限元位移场使用单位正方形上的标准双线性形函数进行近似，\n$$\nN_1(x,y) = (1-x)(1-y), \\quad N_2(x,y) = x(1-y), \\quad N_3(x,y) = xy, \\quad N_4(x,y) = (1-x)y,\n$$\n从而有\n$$\nu(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,u_i, \\qquad v(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,v_i.\n$$\n定义单元平均体积应变\n$$\n\\bar{\\epsilon}_v = \\frac{1}{A}\\int_{\\Omega} \\epsilon_v(x,y)\\,\\mathrm{d}A,\n$$\n单元面积 $A=1$。在用于解决体积锁定的 $\\bar{B}$方法 (B-bar 方法) 的背景下，体积平均算子 $\\mathbf{P}_v$ 是满足以下条件的唯一 $1\\times 8$ 行矩阵\n$$\n\\bar{\\epsilon}_v = \\mathbf{P}_v\\,\\mathbf{d}_e.\n$$\n仅从前面的定义和小应变运动学出发，通过在 $\\Omega$ 上的精确积分，显式推导 $\\mathbf{P}_v$。将最终算子表示为一个 $1\\times 8$ 的行矩阵，其顺序为 $\\left[u_1, v_1, u_2, v_2, u_3, v_3, u_4, v_4\\right]$。无需进行数值舍入，结果必须以精确有理数形式给出。", "solution": "我们从二维体积应变 (膨胀) 的小应变定义开始：\n$$\n\\epsilon_v(x,y) = \\nabla \\cdot \\mathbf{u}(x,y) = \\frac{\\partial u}{\\partial x} + \\frac{\\partial v}{\\partial y}.\n$$\n使用有限元 (FE) 近似\n$$\nu(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,u_i, \n\\qquad \nv(x,y) = \\sum_{i=1}^{4} N_i(x,y)\\,v_i,\n$$\n我们得到\n$$\n\\frac{\\partial u}{\\partial x} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial x}(x,y)\\,u_i,\n\\qquad\n\\frac{\\partial v}{\\partial y} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial y}(x,y)\\,v_i,\n$$\n从而\n$$\n\\epsilon_v(x,y) = \\sum_{i=1}^{4} \\left(\\frac{\\partial N_i}{\\partial x}(x,y)\\,u_i + \\frac{\\partial N_i}{\\partial y}(x,y)\\,v_i\\right).\n$$\n在面积 $A=1$ 的单位正方形 $\\Omega = [0,1]\\times[0,1]$ 上的单元平均体积应变为\n$$\n\\bar{\\epsilon}_v = \\int_{\\Omega} \\epsilon_v(x,y)\\,\\mathrm{d}A \n= \\sum_{i=1}^{4} \\left( u_i \\int_{\\Omega} \\frac{\\partial N_i}{\\partial x}\\,\\mathrm{d}A + v_i \\int_{\\Omega} \\frac{\\partial N_i}{\\partial y}\\,\\mathrm{d}A \\right).\n$$\n因此，体积平均算子 $\\mathbf{P}_v$ 由以下精确积分组装而成\n$$\nI_{x,i} := \\int_{\\Omega} \\frac{\\partial N_i}{\\partial x}\\,\\mathrm{d}A, \n\\qquad \nI_{y,i} := \\int_{\\Omega} \\frac{\\partial N_i}{\\partial y}\\,\\mathrm{d}A,\n$$\n如下所示\n$$\n\\bar{\\epsilon}_v = \\begin{pmatrix} I_{x,1}  I_{y,1}  I_{x,2}  I_{y,2}  I_{x,3}  I_{y,3}  I_{x,4}  I_{y,4} \\end{pmatrix}\n\\begin{pmatrix} u_1 \\\\ v_1 \\\\ u_2 \\\\ v_2 \\\\ u_3 \\\\ v_3 \\\\ u_4 \\\\ v_4 \\end{pmatrix}.\n$$\n因此，\n$$\n\\mathbf{P}_v = \\begin{pmatrix} I_{x,1}  I_{y,1}  I_{x,2}  I_{y,2}  I_{x,3}  I_{y,3}  I_{x,4}  I_{y,4} \\end{pmatrix}.\n$$\n\n我们计算单位正方形上双线性形函数的所需导数：\n\n$$\n\\begin{aligned}\nN_1(x,y) = (1-x)(1-y),  \\quad \\frac{\\partial N_1}{\\partial x} = -(1-y),  \\quad \\frac{\\partial N_1}{\\partial y} = -(1-x),\\\\\nN_2(x,y) = x(1-y),       \\quad \\frac{\\partial N_2}{\\partial x} = (1-y),   \\quad \\frac{\\partial N_2}{\\partial y} = -x,\\\\\nN_3(x,y) = xy,           \\quad \\frac{\\partial N_3}{\\partial x} = y,        \\quad \\frac{\\partial N_3}{\\partial y} = x,\\\\\nN_4(x,y) = (1-x)y,       \\quad \\frac{\\partial N_4}{\\partial x} = -y,       \\quad \\frac{\\partial N_4}{\\partial y} = (1-x).\n\\end{aligned}\n$$\n\n我们在 $\\Omega = [0,1]\\times[0,1]$ 上进行精确积分：\n\n$$\n\\begin{aligned}\nI_{x,1} = \\int_{0}^{1}\\int_{0}^{1} \\left( -(1-y) \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} \\left( -(1-y) \\int_{0}^{1} \\mathrm{d}x \\right)\\mathrm{d}y \n= \\int_{0}^{1} \\left( -(1-y) \\cdot 1 \\right)\\mathrm{d}y \n= -\\int_{0}^{1} (1-y)\\,\\mathrm{d}y \n= -\\left[ y - \\frac{y^{2}}{2} \\right]_{0}^{1} \n= -\\left(1 - \\frac{1}{2}\\right) \n= -\\frac{1}{2},\\\\[6pt]\nI_{x,2} = \\int_{0}^{1}\\int_{0}^{1} (1-y)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} (1-y)\\,\\mathrm{d}y \n= \\frac{1}{2},\\\\[6pt]\nI_{x,3} = \\int_{0}^{1}\\int_{0}^{1} y\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} y \\left(\\int_{0}^{1} \\mathrm{d}x\\right)\\mathrm{d}y \n= \\int_{0}^{1} y\\,\\mathrm{d}y \n= \\frac{1}{2},\\\\[6pt]\nI_{x,4} = \\int_{0}^{1}\\int_{0}^{1} \\left( -y \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= -\\int_{0}^{1} y\\,\\mathrm{d}y \n= -\\frac{1}{2}.\n\\end{aligned}\n$$\n\n类似地，对于 $y$ 的导数：\n\n$$\n\\begin{aligned}\nI_{y,1} = \\int_{0}^{1}\\int_{0}^{1} \\left( -(1-x) \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= -\\int_{0}^{1} (1-x)\\,\\mathrm{d}x \n= -\\left[ x - \\frac{x^{2}}{2} \\right]_{0}^{1} \n= -\\left(1 - \\frac{1}{2}\\right) \n= -\\frac{1}{2},\\\\[6pt]\nI_{y,2} = \\int_{0}^{1}\\int_{0}^{1} \\left( -x \\right)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= -\\int_{0}^{1} x\\,\\mathrm{d}x \n= -\\frac{1}{2},\\\\[6pt]\nI_{y,3} = \\int_{0}^{1}\\int_{0}^{1} x\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} x\\,\\mathrm{d}x \n= \\frac{1}{2},\\\\[6pt]\nI_{y,4} = \\int_{0}^{1}\\int_{0}^{1} (1-x)\\,\\mathrm{d}x\\,\\mathrm{d}y \n= \\int_{0}^{1} (1-x)\\,\\mathrm{d}x \n= \\frac{1}{2}.\n\\end{aligned}\n$$\n\n将这些结果收集到算子中，并注意到 $A=1$，我们得到\n$$\n\\mathbf{P}_v = \\begin{pmatrix}\n-\\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}  \\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}\n\\end{pmatrix}.\n$$\n作为一致性检验，与 $u$-自由度 和 $v$-自由度 相关的系数之和分别为零，\n$$\n\\left(-\\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2} - \\frac{1}{2}\\right) = 0,\n\\qquad\n\\left(-\\frac{1}{2} - \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2}\\right) = 0,\n$$\n这与单位分解以及常数位移场具有零体积应变的事实相一致。这就完成了在单位正方形 $Q_4$ 单元上用于 $\\bar{B}$方法的体积平均算子的推导。", "answer": "$$\\boxed{\\begin{pmatrix}-\\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}  \\frac{1}{2}  -\\frac{1}{2}  \\frac{1}{2}\\end{pmatrix}}$$", "id": "3545792"}, {"introduction": "在推导出算子之后，下一步是在一个完整的有限元程序中验证其有效性。静水压斑块测试是计算力学中的一个基本基准，专门用于评估单元在均匀压力下的性能。本练习 [@problem_id:3545830] 将指导您实施并比较一个标准单元（它将表现出严重的锁定）和一个经过 $\\bar{B}$ 校正的单元（它应该能再现精确的解析解），从而验证该方法的有效性。", "problem": "在平面应变条件下，为二维线性弹性设计一个方形域静水压力分片检验，以分离恒定压力模式，并比较标准双线性四边形单元与$\\bar B$-修正单元。目标是验证$\\bar B$单元在均匀边界压力荷载下能再现精确的恒定平面静水应力，而当泊松比接近不可压缩性时，标准单元会表现出体积锁定。\n\n使用以下基本依据和假设：\n- 小变形、准静态、无体力的线性动量平衡。\n- 平面应变条件下的线性各向同性弹性，杨氏模量为$E$，泊松比为$\\nu$，拉梅参数为$\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$和$\\mu = \\dfrac{E}{2(1+\\nu)}$。在工程应变基$\\{\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\}$下，本构矩阵为\n$$\n\\mathbf{D} = \\begin{bmatrix}\n\\lambda + 2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda + 2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}.\n$$\n- 双线性四边形（$Q4$）单元，其刚度采用$2\\times 2$阶完全高斯积分，每个边界边上的一致性牵引荷载采用2阶积分。\n- $\\bar B$修正将每个高斯点的体积应变替换为单元平均体积应变，同时精确保持偏应变部分。\n\n几何、荷载和边界条件：\n- 计算域为单位正方形$[0,1]\\times[0,1]$，划分为$n_x \\times n_y$个双线性单元的结构化网格。边长取$L=1$。\n- 在所有四个边界边上施加均匀压缩压力$p_0$，其牵引力为$\\mathbf{t} = -p_0 \\,\\mathbf{n}$，其中$\\mathbf{n}$是外单位法向量。\n- 为消除刚体模式且不干扰均匀静水收缩模式，施加以下本质边界条件：\n  - 在角点$(x,y)=(0,0)$，强制$u=0$和$v=0$。\n  - 在角点$(x,y)=(1,0)$，强制$v=0$。\n  - 在角点$(x,y)=(0,1)$，强制$u=0$。\n这些条件与均匀收缩场$u = e\\,x$, $v = e\\,y$相容。\n\n用于验证的静水精确解：\n- 在精确平面静水应力（$\\sigma_{xx}=\\sigma_{yy}=-p_0$为常数且无剪切）下，一个相容的精确常数应变场为$\\varepsilon_{xx}=\\varepsilon_{yy}=e$和$\\gamma_{xy}=0$，其中\n$$\ne = -\\frac{p_0}{2\\lambda + 2\\mu}.\n$$\n因此，在整个域上的精确位移场为$u(x,y)=e\\,x$和$v(x,y)=e\\,y$。精确的平面静水压力（平面平均应力的负值）满足$p_{\\text{planar}} = -\\dfrac{\\sigma_{xx}+\\sigma_{yy}}{2} = p_0$。\n\n需要实现的有限元列式：\n- 标准$Q4$：在每个高斯点$g$，计算应变$\\boldsymbol\\varepsilon_g = \\mathbf{B}_g \\,\\mathbf{u}_e$和刚度贡献$\\mathbf{K}_e^{\\text{std}} \\mathrel{+}= \\mathbf{B}_g^\\top \\mathbf{D}\\,\\mathbf{B}_g \\, w_g \\,\\det\\mathbf{J}_g$。\n- $\\bar B$-修正的$Q4$：令$\\mathbf{m}^\\top = [\\,1 \\;\\; 1 \\;\\; 0\\,]$（用于提取平面膨胀），且$\\mathbf{q} = [\\,1 \\;\\; 1 \\;\\; 0\\,]^\\top$。对于一个具有高斯点$g$的单元，定义单元面积\n$$\nA_e = \\sum_g w_g \\,\\det\\mathbf{J}_g\n$$\n和单元平均体积应变行向量\n$$\n\\boldsymbol{\\Theta} = \\frac{1}{A_e}\\sum_g w_g \\,\\det\\mathbf{J}_g \\,\\mathbf{m}^\\top \\mathbf{B}_g,\n$$\n因此平均膨胀为$\\theta_{\\text{bar}} = \\boldsymbol{\\Theta}\\,\\mathbf{u}_e$。在高斯点$g$处的$\\bar B$应变-位移算子为\n$$\n\\bar{\\mathbf{B}}_g = \\left(\\mathbf{I}_{3\\times 3} - \\frac{1}{2}\\,\\mathbf{q}\\,\\mathbf{m}^\\top\\right)\\mathbf{B}_g + \\frac{1}{2}\\,\\mathbf{q}\\,\\boldsymbol{\\Theta},\n$$\n该算子精确地保持偏应变，并仅将其体积部分替换为单元平均值。单元刚度为\n$$\n\\mathbf{K}_e^{\\bar B} \\mathrel{+}= \\bar{\\mathbf{B}}_g^\\top \\mathbf{D}\\,\\bar{\\mathbf{B}}_g \\, w_g \\,\\det\\mathbf{J}_g.\n$$\n\n验证指标：\n- 计算相对均方根（RMS）位移误差\n$$\n\\eta_u = \\sqrt{ \\frac{\\sum_i \\left\\|\\mathbf{u}_i - \\mathbf{u}_{\\text{exact}}(x_i,y_i)\\right\\|^2}{\\sum_i \\left\\|\\mathbf{u}_{\\text{exact}}(x_i,y_i)\\right\\|^2} },\n$$\n其中求和遍历所有节点$i$，且$\\mathbf{u}=(u,v)$。\n- 使用单元高斯点应力计算平面压力误差。对每种方法，计算平均平面压力\n$$\n\\bar p = -\\frac{1}{2 A}\\sum_{e}\\sum_{g} \\left(\\sigma_{xx}^g + \\sigma_{yy}^g\\right)\\, w_g \\,\\det\\mathbf{J}_g,\n$$\n其中$A=1$是总面积，并定义相对压力误差\n$$\n\\eta_p = \\frac{|\\bar p - p_0|}{p_0}.\n$$\n\n测试组：\n- 所有情况均使用$E=1$和$p_0=1$，并取$L=1$。\n- 情况1：$(n_x,n_y,\\nu) = (2,2,0.3)$。\n- 情况2：$(n_x,n_y,\\nu) = (2,2,0.4999)$。\n- 情况3：$(n_x,n_y,\\nu) = (4,4,0.4999)$。\n\n程序要求：\n- 按照上述方法实现标准单元和$\\bar B$单元列式，组集全局系统，施加指定的本质边界条件，并对每个边界上的压力使用一致性牵引荷载，沿每个边界边进行2点高斯积分。\n- 对每个测试情况，计算数组对$(\\eta_u^{\\text{std}}, \\eta_u^{\\bar B})$和$(\\eta_p^{\\text{std}}, \\eta_p^{\\bar B})$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含12个浮点数：\n  - 情况1：$\\eta_u^{\\text{std}}$, $\\eta_u^{\\bar B}$, $\\eta_p^{\\text{std}}$, $\\eta_p^{\\bar B}$,\n  - 情况2：$\\eta_u^{\\text{std}}$, $\\eta_u^{\\bar B}$, $\\eta_p^{\\text{std}}$, $\\eta_p^{\\bar B}$,\n  - 情况3：$\\eta_u^{\\text{std}}$, $\\eta_u^{\\bar B}$, $\\eta_p^{\\text{std}}$, $\\eta_p^{\\bar B}$。\n所有输出均为无量纲浮点数。最终输出不需要单位，因为报告的量是相对误差。不使用角度。百分比必须表示为小数（不带百分号）。", "solution": "该问题要求设计并实现一个针对二维线性弹性单元的静水压力分片检验。此检验的目的是展示标准双线性四边形（$Q4$）单元在近不可压缩条件下的体积锁定现象，并验证$\\bar B$方法的修正效果。\n\n我们将模拟一个单位方形域的响应，该域通过$Q4$单元的结构化网格进行离散化，并承受均匀的外部压力$p_0$。材料是各向同性线弹性的，处于平面应变状态。分析将针对两种单元列式进行：标准$Q4$单元和使用$\\bar B$技术修正的$Q4$单元。\n\n有限元法（FEM）的基础是虚功原理，对于无体力的准静态线弹性问题，该原理导出矩阵系统$\\mathbf{K}\\mathbf{U} = \\mathbf{F}$。此处，$\\mathbf{K}$是全局刚度矩阵，$\\mathbf{U}$是节点位移向量，$\\mathbf{F}$是从施加的牵引力导出的全局节点力向量。\n\n单个单元的单元刚度矩阵$\\mathbf{K}_e$通过在单元体积（在二维中为面积$A_e$）上积分计算得出：\n$$\n\\mathbf{K}_e = \\int_{A_e} \\mathbf{B}^\\top \\mathbf{D} \\mathbf{B} \\,dA\n$$\n其中$\\mathbf{D}$是材料本构矩阵，$\\mathbf{B}$是应变-位移矩阵，它将节点位移$\\mathbf{u}_e$与应变场$\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{u}_e$联系起来。对于$Q4$单元，$\\mathbf{B}$由双线性形函数的导数推导而来。该积分使用$2 \\times 2$高斯求积进行数值计算。\n\n由单元边界$\\Gamma_e$上的牵引力$\\mathbf{t}$引起的力向量$\\mathbf{F}_e$由下式给出：\n$$\n\\mathbf{F}_e = \\int_{\\Gamma_e} \\mathbf{N}^\\top \\mathbf{t} \\,d\\Gamma\n$$\n其中$\\mathbf{N}$是形函数矩阵。对于指定的均匀压力$p_0$，牵引力为$\\mathbf{t}=-p_0\\mathbf{n}$，其中$\\mathbf{n}$是外法线。该积分沿每个边界边使用2点高斯求积进行计算。\n\n**体积锁定与$\\bar B$方法**\n\n体积锁定是一种数值赝象，当使用低阶有限元（如标准$Q4$单元）模拟近不可压缩材料（即泊松比$\\nu \\to 0.5$）时会发生。对于平面应变，拉梅参数$\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}$趋于无穷大，导致单元对体积变形的响应过度刚化。单元错误地预测出接近零的体积应变，即发生“锁定”。\n\n$\\bar B$方法通过解耦应变场计算中的偏应变部分和体积应变部分来修正此问题。在每个高斯点，偏应变像标准列式一样进行局部计算。然而，体积应变（膨胀）被替换为单一的单元平均值$\\theta_{\\text{bar}}$。\n\n此修正是通过构造一个修正的应变-位移矩阵$\\bar{\\mathbf{B}}$来实现的。高斯点$g$处的应变计算为$\\boldsymbol{\\varepsilon}_g = \\bar{\\mathbf{B}}_g \\mathbf{u}_e$。问题给出了$\\bar{\\mathbf{B}}_g$的直接构造方法：\n$$\n\\bar{\\mathbf{B}}_g = \\left(\\mathbf{I}_{3\\times 3} - \\frac{1}{2}\\,\\mathbf{q}\\,\\mathbf{m}^\\top\\right)\\mathbf{B}_g + \\frac{1}{2}\\,\\mathbf{q}\\,\\boldsymbol{\\Theta}\n$$\n其中$\\mathbf{m}^\\top=[1,1,0]$提取平面膨胀$\\theta = \\varepsilon_{xx}+\\varepsilon_{yy}$，$\\mathbf{q}=\\mathbf{m}^\\top$，而$\\boldsymbol{\\Theta}$是一个行向量，它根据单元节点位移计算单元平均膨胀$\\theta_{\\text{bar}} = \\boldsymbol{\\Theta}\\mathbf{u}_e$。具体来说，$\\boldsymbol{\\Theta}$通过在单元面积上对$\\mathbf{m}^\\top\\mathbf{B}_g$进行平均来计算：\n$$\n\\boldsymbol{\\Theta} = \\frac{1}{A_e}\\sum_g w_g \\det(\\mathbf{J}_g) (\\mathbf{m}^\\top \\mathbf{B}_g)\n$$\n项$(\\mathbf{I} - \\frac{1}{2}\\mathbf{q}\\mathbf{m}^\\top)$是一个投影算子，它从标准计算$\\mathbf{B}_g\\mathbf{u}_e$中提取应变的偏量部分。然后，项$\\frac{1}{2}\\mathbf{q}\\boldsymbol{\\Theta}$使用单一的平均值加回体积部分。$\\bar B$单元的单元刚度则为：\n$$\n\\mathbf{K}_e^{\\bar B} = \\int_{A_e} \\bar{\\mathbf{B}}^\\top \\mathbf{D} \\bar{\\mathbf{B}} \\,dA\n$$\n\n**分片检验验证**\n\n问题描述了一个静水压力分片检验，其精确解对应于均匀静水应力和应变的状态。解析位移场为$u(x,y)=e\\,x$, $v(x,y)=e\\,y$，其中$e = -p_0/(2\\lambda + 2\\mu)$。一个有效的有限元列式应能再现此精确解。\n\n我们在三个角点施加本质边界条件以消除刚体运动，而不约束精确的变形模式。根据均匀边界压力一致性地施加节点力。然后，我们对标准列式和$\\bar B$列式求解全局系统$\\mathbf{K}\\mathbf{U}=\\mathbf{F}$。\n\n结果通过两个误差指标进行量化：\n1. 相对均方根位移误差$\\eta_u$，它测量计算出的节点位移与精确场之间的偏差。\n2. 相对压力误差$\\eta_p$，它测量计算出的平均平面压力与解析值$p_0$之间的偏差。\n\n对于$\\nu \\to 0.5$的情况，我们预期标准$Q4$单元会产生较大的误差（$\\eta_u \\to 1$和较大的$\\eta_p$），这表明发生了锁定。相比之下，$\\bar B$单元被设计为能通过此分片检验，因此对于所有的$\\nu$值，其误差应保持在机器精度附近。所提供的$\\nu=0.3$和$\\nu=0.4999$的测试情况将突显这种差异。在此检验中，网格细化（情况3）不会缓解标准单元的锁定问题。", "answer": "```python\nimport numpy as np\n\ndef solve_fem_system(nx, ny, E, nu, p0, L, use_b_bar):\n    \"\"\"\n    Solves a 2D linear elasticity problem on a square domain using Q4 elements.\n    \"\"\"\n    # 1. Material and Mesh Setup\n    if abs(1 - 2 * nu)  1e-9: # Avoid singularity at nu=0.5\n        return np.nan, np.nan\n    lame_lambda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    lame_mu = E / (2 * (1 + nu))\n    D = np.array([\n        [lame_lambda + 2 * lame_mu, lame_lambda, 0],\n        [lame_lambda, lame_lambda + 2 * lame_mu, 0],\n        [0, 0, lame_mu]\n    ])\n\n    num_nodes_x = nx + 1\n    num_nodes_y = ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_dofs = 2 * num_nodes\n    \n    node_coords = np.zeros((num_nodes, 2))\n    for j in range(num_nodes_y):\n        for i in range(num_nodes_x):\n            node_idx = i + j * num_nodes_x\n            node_coords[node_idx, 0] = i * L / nx\n            node_coords[node_idx, 1] = j * L / ny\n\n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            n1 = i + j * num_nodes_x\n            n2 = (i + 1) + j * num_nodes_x\n            n3 = (i + 1) + (j + 1) * num_nodes_x\n            n4 = i + (j + 1) * num_nodes_x\n            elements.append(np.array([n1, n2, n3, n4]))\n\n    K = np.zeros((num_dofs, num_dofs))\n    \n    # 2. Element Assembly Loop\n    gauss_points = [-1 / np.sqrt(3), 1 / np.sqrt(3)]\n    gauss_weights = [1.0, 1.0]\n\n    def get_shape_functions_and_derivs(xi, eta):\n        N = 0.25 * np.array([(1 - xi) * (1 - eta), (1 + xi) * (1 - eta),\n                               (1 + xi) * (1 + eta), (1 - xi) * (1 + eta)])\n        dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        return N, dN_dxi, dN_deta\n\n    m_T = np.array([1.0, 1.0, 0.0])\n    q = m_T.reshape(3, 1)\n    P_dev = np.eye(3) - 0.5 * q @ q.T\n\n    for el_nodes in elements:\n        el_coords = node_coords[el_nodes]\n        Ke = np.zeros((8, 8))\n        \n        # B-bar: First pass to compute element-averaged strain vector Theta\n        if use_b_bar:\n            el_area = 0.0\n            Theta_num = np.zeros(8)\n            for xi in gauss_points:\n                for eta in gauss_points:\n                    _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                    J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                    detJ = np.linalg.det(J)\n                    \n                    B_gauss = np.zeros((3, 8))\n                    for i in range(4):\n                        dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                        B_gauss[0, 2 * i] = dN_d_xy[0]\n                        B_gauss[1, 2 * i + 1] = dN_d_xy[1]\n                        B_gauss[2, 2 * i] = dN_d_xy[1]\n                        B_gauss[2, 2 * i + 1] = dN_d_xy[0]\n                    \n                    el_area += detJ  # All weights are 1.0\n                    Theta_num += detJ * (m_T @ B_gauss)\n            Theta = Theta_num / el_area if el_area != 0 else np.zeros(8)\n\n        # Second pass to compute stiffness matrix\n        for xi_idx, xi in enumerate(gauss_points):\n            for eta_idx, eta in enumerate(gauss_points):\n                w = gauss_weights[xi_idx] * gauss_weights[eta_idx]\n                _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                detJ = np.linalg.det(J)\n\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                    B[0, 2 * i] = dN_d_xy[0]\n                    B[1, 2 * i + 1] = dN_d_xy[1]\n                    B[2, 2 * i] = dN_d_xy[1]\n                    B[2, 2 * i + 1] = dN_d_xy[0]\n\n                if use_b_bar:\n                    B_bar = P_dev @ B + 0.5 * q @ Theta.reshape(1, 8)\n                    Ke += B_bar.T @ D @ B_bar * w * detJ\n                else:\n                    Ke += B.T @ D @ B * w * detJ\n\n        dof_indices = np.c_[2 * el_nodes, 2 * el_nodes + 1].flatten()\n        K[np.ix_(dof_indices, dof_indices)] += Ke\n\n    # 3. Apply Boundary Conditions and Loads\n    F = np.zeros(num_dofs)\n    hx, hy = L / nx, L / ny\n    for i in range(nx): # Bottom edge y=0, n=(0,-1), t=(0,p0)\n        n1, n2 = i, i+1; F[2*n1+1]+=p0*hx/2; F[2*n2+1]+=p0*hx/2\n    for i in range(nx): # Top edge y=L, n=(0,1), t=(0,-p0)\n        n1, n2 = i+ny*num_nodes_x, i+1+ny*num_nodes_x; F[2*n1+1]-=p0*hx/2; F[2*n2+1]-=p0*hx/2\n    for j in range(ny): # Left edge x=0, n=(-1,0), t=(p0,0)\n        n1, n2 = j*num_nodes_x, (j+1)*num_nodes_x; F[2*n1]+=p0*hy/2; F[2*n2]+=p0*hy/2\n    for j in range(ny): # Right edge x=L, n=(1,0), t=(-p0,0)\n        n1, n2 = nx+j*num_nodes_x, nx+(j+1)*num_nodes_x; F[2*n1]-=p0*hy/2; F[2*n2]-=p0*hy/2\n\n    bc_dofs = []\n    bc_dofs.extend([0, 1])  # (0,0): u=0, v=0\n    bc_dofs.append(2 * nx + 1)  # (L,0): v=0\n    bc_dofs.append(2 * (ny * num_nodes_x)) # (0,L): u=0\n    \n    free_dofs = np.setdiff1d(np.arange(num_dofs), bc_dofs)\n    \n    U = np.zeros(num_dofs)\n    U[free_dofs] = np.linalg.solve(K[np.ix_(free_dofs, free_dofs)], F[free_dofs])\n\n    # 4. Post-processing and Error Calculation\n    e = -p0 / (2 * lame_lambda + 2 * lame_mu)\n    U_exact = np.array([e * c[0] if i % 2 == 0 else e * c[1] for i, c in enumerate(np.repeat(node_coords, 2, axis=0))])\n    \n    sum_u_exact_sq = np.sum(U_exact**2)\n    sum_u_err_sq = np.sum((U - U_exact)**2)\n    eta_u = np.sqrt(sum_u_err_sq / sum_u_exact_sq) if sum_u_exact_sq  0 else 0\n\n    pressure_integral = 0\n    for el_nodes in elements:\n        el_coords = node_coords[el_nodes]\n        dof_indices = np.c_[2 * el_nodes, 2 * el_nodes + 1].flatten()\n        u_e = U[dof_indices]\n\n        if use_b_bar: # Recompute Theta needed for stress calculation\n            el_area = (L/nx)*(L/ny)\n            Theta_num = np.zeros(8)\n            for xi in gauss_points:\n                for eta in gauss_points:\n                    _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                    J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                    detJ = np.linalg.det(J)\n                    B_gauss = np.zeros((3, 8))\n                    for i in range(4):\n                        dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                        B_gauss[0,2*i]=dN_d_xy[0]; B_gauss[1,2*i+1]=dN_d_xy[1]; B_gauss[2,2*i]=dN_d_xy[1]; B_gauss[2,2*i+1]=dN_d_xy[0]\n                    Theta_num += detJ * (m_T @ B_gauss)\n            Theta = Theta_num / el_area if el_area != 0 else np.zeros(8)\n            theta_bar_val = Theta @ u_e\n\n        for xi_idx, xi in enumerate(gauss_points):\n            for eta_idx, eta in enumerate(gauss_points):\n                w = gauss_weights[xi_idx] * gauss_weights[eta_idx]\n                _, dN_dxi, dN_deta = get_shape_functions_and_derivs(xi, eta)\n                J = np.vstack((dN_dxi, dN_deta)) @ el_coords\n                detJ = np.linalg.det(J)\n                \n                B = np.zeros((3, 8))\n                for i in range(4):\n                    dN_d_xy = np.linalg.solve(J.T, [dN_dxi[i], dN_deta[i]])\n                    B[0,2*i]=dN_d_xy[0]; B[1,2*i+1]=dN_d_xy[1]; B[2,2*i]=dN_d_xy[1]; B[2,2*i+1]=dN_d_xy[0]\n\n                if use_b_bar:\n                    strain = (P_dev @ B @ u_e) + (0.5 * q.flatten() * theta_bar_val)\n                else:\n                    strain = B @ u_e\n                \n                stress = D @ strain\n                pressure_integral += (stress[0] + stress[1]) * w * detJ\n                \n    avg_p = -0.5 * pressure_integral / (L*L)\n    eta_p = abs(avg_p - p0) / p0 if p0 != 0 else 0\n\n    return eta_u, eta_p\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (2, 2, 0.3),\n        (2, 2, 0.4999),\n        (4, 4, 0.4999),\n    ]\n    E = 1.0\n    p0 = 1.0\n    L = 1.0\n    results = []\n\n    for nx, ny, nu in test_cases:\n        # Standard Q4 element\n        eta_u_std, eta_p_std = solve_fem_system(nx, ny, E, nu, p0, L, use_b_bar=False)\n        # B-bar modified Q4 element\n        eta_u_bbar, eta_p_bbar = solve_fem_system(nx, ny, E, nu, p0, L, use_b_bar=True)\n        \n        results.extend([eta_u_std, eta_u_bbar, eta_p_std, eta_p_bbar])\n\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "3545830"}, {"introduction": "从理想化的测试转向实际的工程场景，本练习将研究悬臂梁的弯曲问题——在这个问题中，体积锁定表现为不符合物理规律的过刚响应。您将实施并比较 $\\bar{B}$ 方法与另一种替代方法——$\\bar{J}$ 方法（选择性减缩积分），并使用定量指标来诊断锁定。这项练习 [@problem_id:3545765] 不仅巩固了实施方法，还教会您如何在真实世界的模拟中评估单元性能，并在不同的抗锁定技术之间做出明智的选择。", "problem": "考虑在各向同性线弹性框架下，平面应变运动学中二维悬臂梁的准静态、小应变弯曲问题。设梁占据矩形区域 $\\Omega = [0,L] \\times [0,H]$，厚度为 $1$。左端边界 $x=0$ 为完全固定，满足 $u_x = 0$ 和 $u_y = 0$。在右端边界 $x=L$ 上施加均匀的竖向面力 $t_y = -q$（向下）。忽略体力。使用标准的等参映射的四节点双线性四边形单元（记为 $\\mathrm{Q4}$）。\n\n基本理论包括：\n- 无惯性力和体力时的线性动量平衡：$\\nabla \\cdot \\boldsymbol{\\sigma} = \\boldsymbol{0}$。\n- 小应变运动学：$\\boldsymbol{\\varepsilon} = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^\\top)$，其中 $\\boldsymbol{u} = (u_x,u_y)$。\n- 基于 Lamé 参数 $\\lambda$ 和 $\\mu$ 的各向同性线弹性，其平面应变本构关系为：$\\boldsymbol{\\sigma} = \\lambda \\,\\mathrm{tr}(\\boldsymbol{\\varepsilon})\\boldsymbol{I} + 2\\mu\\,\\boldsymbol{\\varepsilon}$，其中 $\\lambda = \\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$ 且 $\\mu = \\dfrac{E}{2(1+\\nu)}$。体积模量为 $\\kappa = \\lambda + \\dfrac{2}{3}\\mu$。\n- 采用双线性形函数的标准 $\\mathrm{Q4}$ 有限元方法，并对单元矩阵使用完全积分（$2\\times 2$ 高斯积分）。\n\n当材料接近不可压缩时，即泊松比 $\\nu$ 趋近于 $0.5$ 时，会导致 $\\kappa \\gg \\mu$，此时可能发生体积闭锁。本问题关注使用 $B$-bar 和 $J$-bar 方法的补救措施，以及如何通过可量化的指标来评估闭锁。\n\n您必须实现两种补救方法：\n1. $B$-bar 方法：将高斯点处的体积应变 $\\varepsilon_{\\mathrm{vol}} = \\mathrm{tr}(\\boldsymbol{\\varepsilon})$ 替换为单元平均值 $\\overline{\\varepsilon}_{\\mathrm{vol}}$，从而得到修正后的单元体积刚度，形式如下\n$$\n\\mathbf{K}_{\\mathrm{vol}}^{(e)} = \\kappa \\, \\Omega_e \\, \\mathbf{B}_{\\mathrm{vol,mean}}^\\top \\mathbf{B}_{\\mathrm{vol,mean}},\n$$\n其中 $\\Omega_e$ 是单元面积，$\\mathbf{B}_{\\mathrm{vol,mean}}$ 将节点位移映射到单元平均体积应变，定义为\n$$\n\\mathbf{B}_{\\mathrm{vol,mean}} = \\frac{1}{\\Omega_e} \\int_{\\Omega_e} \\mathbf{B}_{\\mathrm{vol}} \\, \\mathrm{d}\\Omega,\n\\quad\n\\mathbf{B}_{\\mathrm{vol}} \\boldsymbol{u}_e = \\varepsilon_{\\mathrm{vol}}.\n$$\n\n2. $J$-bar 方法（小应变模拟）：在单元中心使用单点积分计算体积刚度，同时对偏量项保留完全积分，即，\n$$\n\\mathbf{K}_{\\mathrm{vol}}^{(e)} = \\kappa \\, w_c \\, J_c \\, \\mathbf{B}_{\\mathrm{vol,c}}^\\top \\mathbf{B}_{\\mathrm{vol,c}},\n$$\n其中 $\\mathbf{B}_{\\mathrm{vol,c}}$ 是单元中心的体积应变-位移行向量，$J_c$ 是中心的雅可比行列式，$w_c=4$ 是双单位正方形映射的 $1\\times 1$ 高斯权重。\n\n将本构刚度分解为偏量和体积部分，以隔离体积闭锁机理。在平面应变条件下，使用 Voigt 记法，其中 $\\boldsymbol{\\varepsilon}_v=[\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy}]^\\top$，使用偏量矩阵\n$$\n\\mathbf{C}_{\\mathrm{dev}} =\n\\begin{bmatrix}\n\\dfrac{4\\mu}{3}  -\\dfrac{2\\mu}{3}  0 \\\\\n-\\dfrac{2\\mu}{3}  \\dfrac{4\\mu}{3}  0 \\\\\n0  0  \\mu\n\\end{bmatrix},\n$$\n以及体积能量密度 $\\kappa \\, \\varepsilon_{\\mathrm{vol}}^2$，其中 $\\varepsilon_{\\mathrm{vol}} = \\varepsilon_{xx} + \\varepsilon_{yy}$。将全局刚度组装为\n$$\n\\mathbf{K} = \\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol}},\n\\quad\n\\mathbf{K}_{\\mathrm{dev}} = \\int_{\\Omega} \\mathbf{B}^\\top \\mathbf{C}_{\\mathrm{dev}} \\mathbf{B} \\,\\mathrm{d}\\Omega,\n$$\n其中 $\\mathbf{K}_{\\mathrm{dev}}$ 使用 $2\\times 2$ 高斯积分，而 $\\mathbf{K}_{\\mathrm{vol}}$ 根据所选方法（$B$-bar 或 $J$-bar）计算。\n\n使用以下显式闭锁评估指标：\n- 指标 M1（边界挠度）：加载边界 $x=L$ 处的平均竖向位移，定义为\n$$\n\\overline{v}_{\\mathrm{edge}} = \\frac{1}{N_R}\\sum_{i\\in \\Gamma_R} v_i,\n$$\n其中 $\\Gamma_R$ 是 $x=L$ 上的节点集合，$N_R$ 是其基数，$v_i$ 是节点 $i$ 的节点位移 $u_y$。以米为单位报告此值，四舍五入到六位小数。\n\n- 指标 M2（体积能量分数）：体积应变能与总应变能之比，\n$$\n\\eta_{\\mathrm{vol}} = \\frac{U_{\\mathrm{vol}}}{U_{\\mathrm{tot}}},\n\\quad\nU_{\\mathrm{tot}} = \\tfrac{1}{2} \\boldsymbol{u}^\\top \\mathbf{K} \\boldsymbol{u},\n$$\n且 $U_{\\mathrm{vol}}$ 根据所选方法一致地组装，即每个单元为\n$$\nU_{\\mathrm{vol}}^{(e)} =\n\\begin{cases}\n\\tfrac{1}{2}\\kappa \\,\\Omega_e \\left(\\mathbf{B}_{\\mathrm{vol,mean}}\\boldsymbol{u}_e\\right)^2,  \\text{$B$-bar},\\\\[6pt]\n\\tfrac{1}{2}\\kappa \\, w_c J_c \\left(\\mathbf{B}_{\\mathrm{vol,c}}\\boldsymbol{u}_e\\right)^2,  \\text{$J$-bar}.\n\\end{cases}\n$$\n将 $\\eta_{\\mathrm{vol}}$ 报告为无单位小数，四舍五入到六位小数。\n\n- 指标 M3（体积应变振荡）：体积应变与其单元平均值偏差的均方根，\n$$\nr_{\\mathrm{vol}} = \\sqrt{\\frac{\\sum_{e}\\sum_{g} w_g J_g \\left(\\varepsilon_{\\mathrm{vol},g}^{(e)} - \\overline{\\varepsilon}_{\\mathrm{vol}}^{(e)}\\right)^2}{\\sum_e \\Omega_e}},\n\\quad\n\\overline{\\varepsilon}_{\\mathrm{vol}}^{(e)} = \\frac{1}{\\Omega_e}\\sum_{g} w_g J_g \\varepsilon_{\\mathrm{vol},g}^{(e)},\n$$\n其中 $g$ 索引单元 $e$ 中的 $2\\times 2$ 高斯点。将 $r_{\\mathrm{vol}}$ 报告为无单位小数，四舍五入到六位小数。\n\n实现有限元组装、边界条件和两种补救方法，然后计算 $B$-bar 和 $J$-bar 方法下的三个指标。\n\n测试套件：\n使用以下参数集来运行求解器，涵盖一个典型的近不可压缩弯曲情况、一个严重的闭锁情况以及一个基准可压缩情况。所有量均采用国际单位制（SI）。\n\n- 情况 1（典型的近不可压缩弯曲）：$L=4\\,\\mathrm{m}$，$H=1\\,\\mathrm{m}$，$E=1.0\\times 10^{6}\\,\\mathrm{Pa}$，$\\nu=0.499$，$q=1.0\\times 10^{3}\\,\\mathrm{N/m}$，网格 $n_x=8, n_y=4$。\n\n- 情况 2（严重闭锁趋势，粗网格）：$L=4\\,\\mathrm{m}$，$H=1\\,\\mathrm{m}$，$E=1.0\\times 10^{6}\\,\\mathrm{Pa}$，$\\nu=0.4999$，$q=1.0\\times 10^{3}\\,\\mathrm{N/m}$，网格 $n_x=2, n_y=1$。\n\n- 情况 3（基准中度可压缩）：$L=4\\,\\mathrm{m}$，$H=1\\,\\mathrm{m}$，$E=1.0\\times 10^{6}\\,\\mathrm{Pa}$，$\\nu=0.3$，$q=1.0\\times 10^{3}\\,\\mathrm{N/m}$，网格 $n_x=2, n_y=1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按以下顺序输出一个包含六个项目的列表：$[\\overline{v}_{\\mathrm{edge},B\\text{-}\\mathrm{bar}},\\overline{v}_{\\mathrm{edge},J\\text{-}\\mathrm{bar}},\\eta_{\\mathrm{vol},B\\text{-}\\mathrm{bar}},\\eta_{\\mathrm{vol},J\\text{-}\\mathrm{bar}},r_{\\mathrm{vol},B\\text{-}\\mathrm{bar}},r_{\\mathrm{vol},J\\text{-}\\mathrm{bar}}]$。\n所有六个值都必须是四舍五入到六位小数的浮点数。将三个测试用例的列表聚合成一个列表，不含空格，例如：\"[[vB1,vJ1,etaB1,etaJ1,rB1,rJ1],[vB2,...],[vB3,...]]\"。", "solution": "该问题是有效的，因为它提出了一个计算固体力学领域中适定的、有科学依据的任务。问题本身是自洽的，提供了为实现平面应变悬臂梁问题的有限元解所需的所有数据、方程和定义。问题的核心——评估体积闭锁及其补救措施（$B$-bar 和 $J$-bar 方法）——是该领域的标准且重要的课题。所提供的方程、边界条件和评估指标是一致的，能够得出一个唯一的、可验证的解。\n\n在此，将详细介绍有限元实现的具体方法。\n\n### 1. 有限元离散化\n问题域 $\\Omega = [0,L] \\times [0,H]$ 被离散化为一个由 $n_x \\times n_y$ 个四节点双线性四边形（$\\mathrm{Q4}$）单元组成的结构化网格。每个单元 $\\Omega_e$ 内的位移场 $\\boldsymbol{u}(x,y)$ 通过等参形函数 $N_i(\\xi, \\eta)$ 进行近似：\n$$\n\\boldsymbol{u}(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\boldsymbol{u}_i, \\quad \\boldsymbol{x}(\\xi, \\eta) = \\sum_{i=1}^{4} N_i(\\xi, \\eta) \\boldsymbol{x}_i\n$$\n其中 $\\boldsymbol{u}_i$ 和 $\\boldsymbol{x}_i$ 分别是节点位移和节点坐标，$(\\xi, \\eta)$ 是双单位正方形 $[-1,1]^2$ 中的母单元坐标。形函数由 $N_1=\\tfrac{1}{4}(1-\\xi)(1-\\eta)$, $N_2=\\tfrac{1}{4}(1+\\xi)(1-\\eta)$, $N_3=\\tfrac{1}{4}(1+\\xi)(1+\\eta)$ 和 $N_4=\\tfrac{1}{4}(1-\\xi)(1+\\eta)$ 给出。\n\n小应变张量 $\\boldsymbol{\\varepsilon}$ 通过应变-位移矩阵 $\\mathbf{B}$ 与节点位移 $\\boldsymbol{d}_e$ 相关联：\n$$\n\\boldsymbol{\\varepsilon}_v = \\mathbf{B} \\boldsymbol{d}_e, \\quad \\text{where} \\quad \\boldsymbol{\\varepsilon}_v = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^\\top\n$$\n矩阵 $\\mathbf{B}$ 源自形函数的空间导数。形函数对物理坐标 $(x,y)$ 的导数通过链式法则和雅可比矩阵 $\\mathbf{J}$ 的逆求得：\n$$\n\\begin{Bmatrix} \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y} \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_i}{\\partial \\xi} \\\\ \\frac{\\partial N_i}{\\partial \\eta} \\end{Bmatrix}, \\quad \\mathbf{J} = \\begin{bmatrix} \\partial x / \\partial \\xi  \\partial y / \\partial \\xi \\\\ \\partial x / \\partial \\eta  \\partial y / \\partial \\eta \\end{bmatrix}\n$$\n因此，一个 $\\mathrm{Q4}$ 单元的 $3 \\times 8$ 矩阵 $\\mathbf{B}$ 构造如下：\n$$\n\\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x} \\end{bmatrix}, \\quad \\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\mathbf{B}_3, \\mathbf{B}_4]\n$$\n\n### 2. 刚度矩阵的分解与组装\n虚功原理导出线性方程组 $\\mathbf{K}\\boldsymbol{u}=\\mathbf{F}$，其中 $\\mathbf{K}$ 是全局刚度矩阵，$\\boldsymbol{u}$ 是全局节点位移向量，$\\mathbf{F}$ 是全局力向量。刚度矩阵被加性分解为偏量和体积部分：$\\mathbf{K} = \\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol}}$。\n\n单位厚度的单元刚度矩阵为 $\\mathbf{K}^{(e)} = \\int_{\\Omega_e} \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B} \\, \\mathrm{d}\\Omega$，其中 $\\mathbf{C}$ 是平面应变的本构矩阵。将 $\\mathbf{C}$ 分解为 $\\mathbf{C}_{\\mathrm{dev}}$ 和 $\\mathbf{C}_{\\mathrm{vol}}$ 使得刚度矩阵的各部分可以分开组装。积分通过在母单元上使用高斯求积法进行数值计算：\n$$\n\\mathbf{K}^{(e)} = \\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B} \\, \\det(\\mathbf{J}) \\, \\mathrm{d}\\xi \\mathrm{d}\\eta \\approx \\sum_{g} w_g \\, \\mathbf{B}_g^\\top \\mathbf{C}_g \\mathbf{B}_g \\det(\\mathbf{J}_g)\n$$\n其中 $g$ 索引高斯点，$w_g$ 是求积权重。\n\n#### 偏量刚度 $\\mathbf{K}_{\\mathrm{dev}}$\n偏量刚度按规定使用完全 $2 \\times 2$ 高斯求积法计算：\n$$\n\\mathbf{K}_{\\mathrm{dev}}^{(e)} = \\sum_{g=1}^{4} w_g \\, \\mathbf{B}_g^\\top \\mathbf{C}_{\\mathrm{dev}} \\mathbf{B}_g \\det(\\mathbf{J}_g)\n$$\n使用所提供的偏量本构矩阵 $\\mathbf{C}_{\\mathrm{dev}}$。\n\n#### 体积刚度 $\\mathbf{K}_{\\mathrm{vol}}$\n为计算体积刚度，实现了两种方法，两者都旨在缓解闭锁。本构响应的体积部分与能量密度 $\\tfrac{1}{2}\\kappa \\varepsilon_{\\mathrm{vol}}^2$ 相关，其中 $\\varepsilon_{\\mathrm{vol}} = \\varepsilon_{xx} + \\varepsilon_{yy}$。应变 $\\varepsilon_{\\mathrm{vol}}$ 通过行向量 $\\mathbf{B}_{\\mathrm{vol}} = [1, 1, 0]\\mathbf{B}$ 与节点位移相关。\n\n1.  **$J$-bar 方法（选择性减缩积分）：** 体积刚度通过在单元中心 $(\\xi, \\eta)=(0,0)$ 使用单个高斯点进行积分。双单位正方形对应的权重是 $w_c=4$。\n    $$\n    \\mathbf{K}_{\\mathrm{vol}, J}^{(e)} = \\kappa \\left( \\mathbf{B}_{\\mathrm{vol,c}}^\\top \\mathbf{B}_{\\mathrm{vol,c}} \\right) w_c \\det(\\mathbf{J}_c)\n    $$\n    其中下标 $c$ 表示在单元中心进行评估。\n\n2.  **$B$-bar 方法：** 此方法将局部体积应变-位移算子 $\\mathbf{B}_{\\mathrm{vol}}$ 替换为其单元平均值 $\\mathbf{B}_{\\mathrm{vol,mean}}$。\n    $$\n    \\mathbf{B}_{\\mathrm{vol,mean}} = \\frac{1}{\\Omega_e} \\int_{\\Omega_e} \\mathbf{B}_{\\mathrm{vol}} \\, \\mathrm{d}\\Omega = \\frac{\\sum_{g=1}^{4} w_g \\mathbf{B}_{\\mathrm{vol},g} \\det(\\mathbf{J}_g)}{\\sum_{g=1}^{4} w_g \\det(\\mathbf{J}_g)}\n    $$\n    然后单元体积刚度构造为：\n    $$\n    \\mathbf{K}_{\\mathrm{vol}, B}^{(e)} = \\kappa \\, \\Omega_e \\, \\mathbf{B}_{\\mathrm{vol,mean}}^\\top \\mathbf{B}_{\\mathrm{vol,mean}}\n    $$\n    其中 $\\Omega_e = \\sum_{g=1}^{4} w_g \\det(\\mathbf{J}_g)$ 是用完全积分计算的单元面积。\n\n### 3. 力向量和边界条件\n在右侧边界（$x=L$）上施加均匀面力 $t_y = -q$。一致节点力向量 $\\mathbf{F}$ 通过在此边界上沿每个单元边对面力与形函数进行积分来组装。对于矩形单元上长度为 $h_e$ 的竖直边，总竖向力 $-q h_e$ 被均等地分配到该边上的两个节点，每个节点贡献 $-q h_e / 2$。\n\n在 $x=0$ 处的固定边界条件（$u_x = 0, u_y = 0$）通过施加罚函数法来强制执行。将一个大数加到全局刚度矩阵中对应于约束自由度的对角线元素上。\n\n### 4. 闭锁评估指标\n求解位移向量 $\\boldsymbol{u}_B$ 和 $\\boldsymbol{u}_J$ 的方程组 $(\\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol},B})\\boldsymbol{u}_B = \\mathbf{F}$ 和 $(\\mathbf{K}_{\\mathrm{dev}} + \\mathbf{K}_{\\mathrm{vol},J})\\boldsymbol{u}_J = \\mathbf{F}$ 后，为每个解计算以下指标：\n\n-   **M1（边界挠度）：** 加载边界 $x=L$ 上节点的平均竖向位移 $\\overline{v}_{\\mathrm{edge}}$。该指标直接显示了闭锁的人为刚化效应；一个闭锁的单元结构挠度会更小。\n\n-   **M2（体积能量分数）：** 比率 $\\eta_{\\mathrm{vol}} = U_{\\mathrm{vol}}/U_{\\mathrm{tot}}$。总应变能为 $U_{\\mathrm{tot}} = \\tfrac{1}{2}\\boldsymbol{u}^\\top\\mathbf{F}$。体积应变能 $U_{\\mathrm{vol}}$ 是对所有单元求和得到的，其公式与所用方法（B-bar 或 J-bar）一致。在易于发生闭锁的情况下，由于单元过度抵抗体积变化，该比率会变得异常高。\n\n-   **M3（体积应变振荡）：** 指标 $r_{\\mathrm{vol}}$ 量化了体积应变场中非物理的、单元级别的振荡，这是闭锁的典型症状。它是点态体积应变（在 $2 \\times 2$ 高斯点处）与单元平均体积应变偏差的均方根。高值表示单元内存在显著的、非物理的应变变化。\n$$\nr_{\\mathrm{vol}} = \\sqrt{\\frac{\\sum_{e}\\sum_{g} w_g \\det(\\mathbf{J}_g) \\left(\\varepsilon_{\\mathrm{vol},g}^{(e)} - \\overline{\\varepsilon}_{\\mathrm{vol}}^{(e)}\\right)^2}{\\sum_e \\Omega_e}}\n$$\n其中 $\\varepsilon_{\\mathrm{vol},g}^{(e)}$ 是根据求解出的位移场 $\\boldsymbol{u}$，在每个高斯点 $g$ 处使用标准 $\\mathbf{B}_{\\mathrm{vol}, g}$ 计算得到的。\n\n这三个指标为体积闭锁以及所实施补救措施的有效性提供了全面的定量评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1 (typical nearly incompressible bending)\n        {'L': 4.0, 'H': 1.0, 'E': 1.0e6, 'nu': 0.499, 'q': 1.0e3, 'nx': 8, 'ny': 4},\n        # Case 2 (severe locking tendency, coarse mesh)\n        {'L': 4.0, 'H': 1.0, 'E': 1.0e6, 'nu': 0.4999, 'q': 1.0e3, 'nx': 2, 'ny': 1},\n        # Case 3 (baseline moderately compressible)\n        {'L': 4.0, 'H': 1.0, 'E': 1.0e6, 'nu': 0.3, 'q': 1.0e3, 'nx': 2, 'ny': 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = solve_case(**case)\n        results.append(case_results)\n\n    # Format output string to match requirements\n    # '[[vB1,vJ1,etaB1,etaJ1,rB1,rJ1],[vB2,...],[vB3,...]]'\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\ndef solve_case(L, H, E, nu, q, nx, ny):\n    \"\"\"\n    Solves the FEM problem for a single set of parameters.\n    \"\"\"\n    # 1. Material properties and mesh generation\n    mu = E / (2 * (1 + nu))\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    kappa = lmbda + 2/3 * mu\n    \n    C_dev = np.array([\n        [4/3 * mu, -2/3 * mu, 0],\n        [-2/3 * mu, 4/3 * mu, 0],\n        [0, 0, mu]\n    ])\n\n    num_nodes = (nx + 1) * (ny + 1)\n    num_elems = nx * ny\n    \n    node_coords = np.zeros((num_nodes, 2))\n    dx, dy = L / nx, H / ny\n    for j in range(ny + 1):\n        for i in range(nx + 1):\n            node_idx = j * (nx + 1) + i\n            node_coords[node_idx] = [i * dx, j * dy]\n\n    elem_conn = np.zeros((num_elems, 4), dtype=int)\n    for j in range(ny):\n        for i in range(nx):\n            elem_idx = j * nx + i\n            n1 = j * (nx + 1) + i\n            n2 = n1 + 1\n            n3 = n2 + nx + 1\n            n4 = n1 + nx + 1\n            elem_conn[elem_idx] = [n1, n2, n3, n4]\n            \n    # 2. FEM Preliminaries\n    # Gauss points and weights for 2x2 quadrature\n    gp = 1 / np.sqrt(3)\n    gauss_points_2x2 = np.array([[-gp, -gp], [gp, -gp], [gp, gp], [-gp, gp]])\n    gauss_weights_2x2 = np.array([1, 1, 1, 1])\n\n    def shape_functions(xi, eta):\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        return N\n\n    def shape_derivatives(xi, eta):\n        dNd_xi = 0.25 * np.array([\n            -(1 - eta), (1 - eta), (1 + eta), -(1 + eta)\n        ])\n        dNd_eta = 0.25 * np.array([\n            -(1 - xi), -(1 + xi), (1 + xi), (1 - xi)\n        ])\n        return dNd_xi, dNd_eta\n\n    # 3. Assembly\n    num_dofs = 2 * num_nodes\n    K_dev = np.zeros((num_dofs, num_dofs))\n    K_vol_B = np.zeros((num_dofs, num_dofs))\n    K_vol_J = np.zeros((num_dofs, num_dofs))\n    F = np.zeros(num_dofs)\n    \n    dofs_map = np.zeros((4, 2), dtype=int)\n\n    m_vec = np.array([1, 1, 0])\n\n    for el in range(num_elems):\n        node_indices = elem_conn[el]\n        el_coords = node_coords[node_indices]\n        \n        dofs_map[:, 0] = 2 * node_indices\n        dofs_map[:, 1] = 2 * node_indices + 1\n        dofs = dofs_map.flatten()\n\n        # Deviatoric stiffness (full 2x2 integration)\n        Ke_dev = np.zeros((8, 8))\n        \n        # For B-bar method\n        B_vol_int = np.zeros(8)\n        Omega_e = 0.0\n\n        for i in range(len(gauss_points_2x2)):\n            xi, eta = gauss_points_2x2[i]\n            w = gauss_weights_2x2[i]\n            \n            dNd_xi, dNd_eta = shape_derivatives(xi, eta)\n            \n            J_mat = np.zeros((2, 2))\n            J_mat[0, :] = dNd_xi @ el_coords\n            J_mat[1, :] = dNd_eta @ el_coords\n            detJ = np.linalg.det(J_mat)\n            invJ = np.linalg.inv(J_mat)\n            \n            B = np.zeros((3, 8))\n            for k in range(4):\n                dNd_xy = invJ @ np.array([dNd_xi[k], dNd_eta[k]])\n                B[0, 2*k] = dNd_xy[0]\n                B[1, 2*k+1] = dNd_xy[1]\n                B[2, 2*k] = dNd_xy[1]\n                B[2, 2*k+1] = dNd_xy[0]\n\n            Ke_dev += B.T @ C_dev @ B * detJ * w\n            \n            # Accumulate for B-bar\n            B_vol = m_vec @ B\n            B_vol_int += B_vol * detJ * w\n            Omega_e += detJ * w\n\n        K_dev[np.ix_(dofs, dofs)] += Ke_dev\n\n        # B-bar volumetric stiffness\n        B_vol_mean = B_vol_int / Omega_e\n        Ke_vol_B = kappa * Omega_e * np.outer(B_vol_mean, B_vol_mean)\n        K_vol_B[np.ix_(dofs, dofs)] += Ke_vol_B\n\n        # J-bar volumetric stiffness (1-point integration)\n        xi_c, eta_c = 0.0, 0.0\n        dNd_xi_c, dNd_eta_c = shape_derivatives(xi_c, eta_c)\n        J_mat_c = np.zeros((2, 2))\n        J_mat_c[0, :] = dNd_xi_c @ el_coords\n        J_mat_c[1, :] = dNd_eta_c @ el_coords\n        detJ_c = np.linalg.det(J_mat_c)\n        invJ_c = np.linalg.inv(J_mat_c)\n        \n        B_c = np.zeros((3, 8))\n        for k in range(4):\n            dNd_xy_c = invJ_c @ np.array([dNd_xi_c[k], dNd_eta_c[k]])\n            B_c[0, 2 * k] = dNd_xy_c[0]\n            B_c[1, 2 * k + 1] = dNd_xy_c[1]\n            B_c[2, 2 * k] = dNd_xy_c[1]\n            B_c[2, 2 * k + 1] = dNd_xy_c[0]\n        \n        B_vol_c = m_vec @ B_c\n        w_c = 4.0 # For bi-unit square\n        Ke_vol_J = kappa * w_c * detJ_c * np.outer(B_vol_c, B_vol_c)\n        K_vol_J[np.ix_(dofs, dofs)] += Ke_vol_J\n    \n    # Force vector\n    for j in range(ny):\n        elem_idx = (j + 1) * nx - 1\n        nodes = elem_conn[elem_idx]\n        dof_y1 = 2 * nodes[1] + 1\n        dof_y2 = 2 * nodes[2] + 1\n        force_per_node = -q * dy / 2.0\n        F[dof_y1] += force_per_node\n        F[dof_y2] += force_per_node\n\n    # 4. Boundary Conditions\n    K_B = K_dev + K_vol_B\n    K_J = K_dev + K_vol_J\n    \n    penalty = 1e10 * np.max(np.abs(K_B.diagonal())) \n    clamped_nodes = np.where(node_coords[:, 0] == 0)[0]\n    for node_idx in clamped_nodes:\n        dof1 = 2 * node_idx\n        dof2 = 2 * node_idx + 1\n        K_B[dof1, dof1] += penalty\n        K_B[dof2, dof2] += penalty\n        K_J[dof1, dof1] += penalty\n        K_J[dof2, dof2] += penalty\n\n    # 5. Solve\n    u_B = np.linalg.solve(K_B, F)\n    u_J = np.linalg.solve(K_J, F)\n\n    # 6. Post-processing - Metrics\n    def calculate_metrics(u_sol, K_vol_method):\n        # M1: Edge deflection\n        right_edge_nodes = np.where(node_coords[:, 0] == L)[0]\n        right_edge_dofs_y = 2 * right_edge_nodes + 1\n        v_edge = np.mean(u_sol[right_edge_dofs_y])\n        \n        # M2: Volumetric energy fraction\n        U_tot = 0.5 * u_sol @ F\n        U_vol = 0.5 * u_sol @ (K_vol_method @ u_sol)\n        eta_vol = U_vol / U_tot if U_tot != 0 else 0\n\n        # M3: Volumetric strain oscillation\n        total_volume = 0\n        osc_numerator = 0\n        for el in range(num_elems):\n            node_indices = elem_conn[el]\n            el_coords = node_coords[node_indices]\n            dofs_map[:, 0] = 2 * node_indices\n            dofs_map[:, 1] = 2 * node_indices + 1\n            dofs = dofs_map.flatten()\n            u_e = u_sol[dofs]\n\n            # Calculate mean vol strain with 2x2 Gauss\n            vol_strain_sum = 0\n            Omega_e = 0\n            strains_at_gp = []\n            \n            for i in range(len(gauss_points_2x2)):\n                xi, eta = gauss_points_2x2[i]\n                w = gauss_weights_2x2[i]\n                \n                dNd_xi, dNd_eta = shape_derivatives(xi, eta)\n                J_mat = np.zeros((2, 2))\n                J_mat[0, :] = dNd_xi @ el_coords\n                J_mat[1, :] = dNd_eta @ el_coords\n                detJ = np.linalg.det(J_mat)\n                invJ = np.linalg.inv(J_mat)\n                \n                B = np.zeros((3, 8))\n                for k in range(4):\n                    dNd_xy = invJ @ np.array([dNd_xi[k], dNd_eta[k]])\n                    B[0, 2*k] = dNd_xy[0]\n                    B[1, 2*k+1] = dNd_xy[1]\n                    B[2, 2*k] = dNd_xy[1]\n                    B[2, 2*k+1] = dNd_xy[0]\n\n                eps_vol_g = (m_vec @ B) @ u_e\n                strains_at_gp.append((eps_vol_g, w, detJ))\n                vol_strain_sum += eps_vol_g * detJ * w\n                Omega_e += detJ * w\n            \n            eps_vol_mean = vol_strain_sum / Omega_e if Omega_e != 0 else 0\n            total_volume += Omega_e\n            \n            # Sum for numerator\n            for eps_vol_g, w, detJ in strains_at_gp:\n                osc_numerator += w * detJ * (eps_vol_g - eps_vol_mean)**2\n        \n        r_vol = np.sqrt(osc_numerator / total_volume) if total_volume != 0 else 0\n        \n        return round(v_edge, 6), round(eta_vol, 6), round(r_vol, 6)\n\n    v_B, eta_B, r_B = calculate_metrics(u_B, K_vol_B)\n    v_J, eta_J, r_J = calculate_metrics(u_J, K_vol_J)\n    \n    return [v_B, v_J, eta_B, eta_J, r_B, r_J]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3545765"}]}