{"hands_on_practices": [{"introduction": "对伴随法的扎实掌握始于其数学推导。本练习 ([@problem_id:2594547]) 将引导你使用拉格朗日乘子法，为一般化的线性系统推导伴随方程。这是理解伴随法为何有效，以及它如何巧妙避免计算成本高昂的状态敏感度的关键一步，从而为离散伴随法奠定坚实的理论基础。", "problem": "考虑一个线性的、参数化的有限元方法 (FEM) 模型，其离散状态向量 $u(p) \\in \\mathbb{R}^{n}$ 由以下平衡方程控制\n$$\nK(p)\\,u(p) \\;=\\; f(p),\n$$\n其中 $K(p) \\in \\mathbb{R}^{n \\times n}$ 是一个依赖于参数的刚度矩阵，对于所关心的参数值，该矩阵是非奇异的；$f(p) \\in \\mathbb{R}^{n}$ 是依赖于参数的载荷向量。设输出泛函为\n$$\nJ(u,p) \\;=\\; \\tfrac{1}{2}\\,u^{T}\\,Q(p)\\,u,\n$$\n其中 $Q(p) \\in \\mathbb{R}^{n \\times n}$ 是对称的，并且对于标量参数 $p \\in \\mathbb{R}$ 是充分光滑的。假设所有函数都按需可微。\n\n仅使用第一性原理（链式法则、状态方程的线性化和拉格朗日乘子），完成以下任务：\n\n1) 计算偏导数 $\\partial J/\\partial u$。\n\n2) 引入一个伴随向量 $\\lambda(p) \\in \\mathbb{R}^{n}$，以从全导数 $\\mathrm{d}J/\\mathrm{d}p$ 中消除对状态灵敏度 $\\mathrm{d}u/\\mathrm{d}p$ 的依赖。从残差 $R(u,p) = K(p)\\,u - f(p) = 0$ 出发，推导：\n- 一个定义 $\\lambda(p)$ 的伴随方程，以及\n- 一个完全用 $K$、$Q$、$u$ 以及关于 $p$ 的参数导数表示的 $\\mathrm{d}J/\\mathrm{d}p$ 的显式表达式。\n\n不要假设 $K(p)$ 是对称的。您可以使用标准的欧几里得内积来构成对偶对。\n\n3) 简要解释为什么您的最终梯度表达式不需要求解 $\\mathrm{d}u/\\mathrm{d}p$。\n\n请提供一个关于 $\\mathrm{d}J/\\mathrm{d}p$ 的单一闭式解析表达式作为最终答案，该表达式用 $K$、$Q$、$u$、$\\tfrac{\\partial K}{\\partial p}$、$\\tfrac{\\partial f}{\\partial p}$、$\\tfrac{\\partial Q}{\\partial p}$ 和满足您的伴随方程的伴随向量 $\\lambda$ 表示。不需要进行数值代入。您的最终答案必须是单一的符号表达式，且不得包含任何单位。", "solution": "在尝试求解之前，对所述问题进行验证。\n\n首先，逐字提取已知条件。\n- 状态方程：$K(p)\\,u(p) \\;=\\; f(p)$，其中 $K(p) \\in \\mathbb{R}^{n \\times n}$ 是非奇异的，$u(p) \\in \\mathbb{R}^{n}$，$f(p) \\in \\mathbb{R}^{n}$。\n- 输出泛函：$J(u,p) \\;=\\; \\tfrac{1}{2}\\,u^{T}\\,Q(p)\\,u$，其中 $Q(p) \\in \\mathbb{R}^{n \\times n}$ 是对称且光滑的。\n- 参数：$p \\in \\mathbb{R}$ 是一个标量。\n- 假设：所有函数都按需可微。矩阵 $K(p)$ 不假设为对称。\n- 任务：1) 计算 $\\partial J/\\partial u$。2) 推导伴随方程和一个消除了对 $\\mathrm{d}u/\\mathrm{d}p$ 依赖的 $\\mathrm{d}J/\\mathrm{d}p$ 表达式。3) 解释为何消除了 $\\mathrm{d}u/\\mathrm{d}p$ 项。\n\n其次，根据所需标准对问题进行验证。\n- **科学依据**：该问题是使用伴随方法进行灵敏度分析的标准练习，这是优化、最优控制和计算工程中的一项基本技术。它牢固地建立在向量微积分和线性代数的既定原理之上。\n- **适定性**：问题是适定的。$K(p)$ 非奇异的先验假设确保了状态向量 $u(p)$ 是唯一确定的。在给定的光滑性假设下，所需的泛函导数和伴随系统是唯一可确定的。\n- **目标明确性**：问题以精确、无歧义的数学语言陈述。\n- **完整性与一致性**：问题提供了所有必要的定义和约束。没有内部矛盾。\n- **可行性与结构**：问题是一个理论推导，完全可行。其结构逻辑清晰，引导从第一性原理进行逐步推导。\n\n由于问题满足所有标准，因此被视为有效。现在将构建解答。\n\n**1) 计算 $\\partial J/\\partial u$**\n\n输出泛函由 $J(u,p) = \\frac{1}{2} u^T Q(p) u$ 给出。为了计算标量 $J$ 关于向量 $u$ 的偏导数，我们考虑在固定参数 $p$ 下，对于一个扰动 $\\mathrm{d}u$ 的微分 $\\mathrm{d}J$。\n$$\n\\mathrm{d}J = \\frac{1}{2} (\\mathrm{d}u)^T Q u + \\frac{1}{2} u^T Q (\\mathrm{d}u)\n$$\n因为 $(\\mathrm{d}u)^T Q u$ 是一个标量，它等于其自身的转置：$(\\mathrm{d}u)^T Q u = (u^T Q^T (\\mathrm{d}u))^T = u^T Q^T (\\mathrm{d}u)$。将此代入第一项中：\n$$\n\\mathrm{d}J = \\frac{1}{2} u^T Q^T (\\mathrm{d}u) + \\frac{1}{2} u^T Q (\\mathrm{d}u) = \\frac{1}{2} u^T (Q^T + Q) \\mathrm{d}u\n$$\n问题陈述了矩阵 $Q(p)$ 是对称的，所以 $Q^T = Q$。表达式简化为：\n$$\n\\mathrm{d}J = \\frac{1}{2} u^T (2Q) \\mathrm{d}u = u^T Q \\mathrm{d}u\n$$\n根据定义，微分 $\\mathrm{d}J$ 通过 $\\mathrm{d}J = \\frac{\\partial J}{\\partial u} \\mathrm{d}u$ 与偏导数（一个行向量，或余向量）相关联。通过比较，我们确定 $J$ 关于 $u$ 的偏导数为：\n$$\n\\frac{\\partial J}{\\partial u} = u^T Q(p)\n$$\n$J$ 关于 $u$ 的梯度，记为 $\\nabla_u J$，是该行向量的转置，即列向量 $Q(p)u$。\n\n**2) 伴随方程和灵敏度表达式的推导**\n\n目标是求全导数 $\\mathrm{d}J/\\mathrm{d}p$。泛函 $J$ 对 $p$ 的依赖既有通过 $Q(p)$ 的显式依赖，也有通过状态向量 $u(p)$ 的隐式依赖。应用多元链式法则：\n$$\n\\frac{\\mathrm{d}J}{\\mathrm{d}p} = \\frac{\\partial J}{\\partial p} + \\frac{\\partial J}{\\partial u} \\frac{\\mathrm{d}u}{\\mathrm{d}p}\n$$\n第一项，即显式导数，是通过在保持 $u$ 不变的情况下对 $J$ 关于 $p$ 求导来计算的：\n$$\n\\frac{\\partial J}{\\partial p} = \\frac{\\partial}{\\partial p} \\left( \\frac{1}{2} u^T Q(p) u \\right) = \\frac{1}{2} u^T \\frac{\\partial Q}{\\partial p} u\n$$\n将此结果及第1部分的结果代入，得到全导数的表达式，这被称为直接灵敏度公式：\n$$\n\\frac{\\mathrm{d}J}{\\mathrm{d}p} = \\frac{1}{2} u^T \\frac{\\partial Q}{\\partial p} u + u^T Q \\frac{\\mathrm{d}u}{\\mathrm{d}p}\n$$\n该表达式依赖于状态灵敏度 $\\mathrm{d}u/\\mathrm{d}p$，其计算成本很高，因为它需要为每个参数求解一个线性系统。伴随方法可以规避这个问题。\n\n我们使用拉格朗日乘子法。约束是状态方程，写成残差形式 $R(u,p) = K(p)u - f(p) = 0$。我们使用一个拉格朗日乘子向量 $\\lambda \\in \\mathbb{R}^n$（我们称之为伴随向量），将约束附加到原始泛函 $J$ 上，从而构成增广泛函 $\\mathcal{L}$。\n$$\n\\mathcal{L}(u, p, \\lambda) = J(u, p) + \\lambda^T R(u, p) = \\frac{1}{2} u^T Q u + \\lambda^T (Ku - f)\n$$\n由于状态方程总是满足的（$R(u(p), p) = 0$），因此对于任何 $\\lambda$ 的选择，我们都有 $\\mathcal{L} = J$。因此，它们关于 $p$ 的全导数相等：$\\mathrm{d}J/\\mathrm{d}p = \\mathrm{d}\\mathcal{L}/\\mathrm{d}p$。我们将 $\\mathcal{L}$ 视为 $u$、$p$ 和 $\\lambda$ 的函数，并对其应用链式法则来计算 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}p$：\n$$\n\\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}p} = \\frac{\\partial \\mathcal{L}}{\\partial p} + \\frac{\\partial \\mathcal{L}}{\\partial u} \\frac{\\mathrm{d}u}{\\mathrm{d}p} + \\frac{\\partial \\mathcal{L}}{\\partial \\lambda} \\frac{\\mathrm{d}\\lambda}{\\mathrm{d}p}\n$$\n伴随方法的核心是选择 $\\lambda$ 来消除包含状态灵敏度 $\\mathrm{d}u/\\mathrm{d}p$ 的项。这通过将其系数设为零来实现：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial u} = 0\n$$\n我们来计算这个偏导数：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial u} = \\frac{\\partial}{\\partial u} \\left( \\frac{1}{2} u^T Q u + \\lambda^T K u - \\lambda^T f \\right) = u^T Q + \\lambda^T K\n$$\n将其设为零得到条件 $u^T Q + \\lambda^T K = 0$。转置该方程，得到**伴随方程**的标准形式：\n$$\n(u^T Q + \\lambda^T K)^T = 0^T \\implies Q^T u + K^T \\lambda = 0\n$$\n由于 $Q$ 是对称的（$Q^T = Q$），我们有：\n$$\nK^T \\lambda = -Q u\n$$\n这是一个定义了伴随向量 $\\lambda(p)$ 的线性方程组。注意它涉及刚度矩阵的转置 $K^T$，并且其求解需要状态向量 $u$。\n\n通过对 $\\lambda$ 的这种特定选择，$\\mathrm{d}\\mathcal{L}/\\mathrm{d}p$ 表达式中的项 $\\frac{\\partial \\mathcal{L}}{\\partial u} \\frac{\\mathrm{d}u}{\\mathrm{d}p}$ 变为零。此外，项 $\\frac{\\partial \\mathcal{L}}{\\partial \\lambda}$ 就是 $R^T$。由于状态方程 $R=0$ 必须成立，该项也为零，因此无论 $\\mathrm{d}\\lambda/\\mathrm{d}p$ 是什么，$\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} \\frac{\\mathrm{d}\\lambda}{\\mathrm{d}p} = 0$。\n\n因此，泛函的全导数简化为：\n$$\n\\frac{\\mathrm{d}J}{\\mathrm{d}p} = \\frac{\\mathrm{d}\\mathcal{L}}{\\mathrm{d}p} = \\frac{\\partial \\mathcal{L}}{\\partial p}\n$$\n我们现在计算 $\\mathcal{L}$ 关于 $p$ 的偏导数：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial p} = \\frac{\\partial}{\\partial p} \\left( \\frac{1}{2} u^T Q(p) u + \\lambda^T (K(p)u - f(p)) \\right) = \\frac{1}{2} u^T \\frac{\\partial Q}{\\partial p} u + \\lambda^T \\left( \\frac{\\partial K}{\\partial p} u - \\frac{\\partial f}{\\partial p} \\right)\n$$\n这就给出了最终的灵敏度表达式：\n$$\n\\frac{\\mathrm{d}J}{\\mathrm{d}p} = \\frac{1}{2} u^T \\frac{\\partial Q}{\\partial p} u + \\lambda^T \\left( \\frac{\\partial K}{\\partial p} u - \\frac{\\partial f}{\\partial p} \\right)\n$$\n\n**3) 关于消除 $\\mathrm{d}u/\\mathrm{d}p$ 的解释**\n\n梯度 $\\mathrm{d}J/\\mathrm{d}p$ 的最终表达式不需要求解状态灵敏度向量 $\\mathrm{d}u/\\mathrm{d}p$，这是因为伴随问题的特定构造。通过引入拉格朗日乘子（伴随）向量 $\\lambda$ 并构造增广泛函 $\\mathcal{L}$，我们获得了一个额外的自由度。这个自由度被用来施加伴随方程 $K^T\\lambda = -Qu$。这个方程被专门设计成一个条件，使得在 $\\mathrm{d}\\mathcal{L}/\\mathrm{d}p$ 的链式法则展开式中，$\\mathrm{d}u/\\mathrm{d}p$ 项的系数为零。通过满足这个伴随方程，全导数 $\\mathrm{d}J/\\mathrm{d}p$ 对状态灵敏度 $\\mathrm{d}u/\\mathrm{d}p$ 的依赖性在代数上被消除了，只剩下依赖于状态 $u$、伴随状态 $\\lambda$ 以及问题数据（$K$、$f$、$Q$）关于参数 $p$ 的直接偏导数的项。这构成了伴随方法在涉及大量参数的灵敏度分析中的主要优势，因为只需要求解一个状态系统和一个伴随系统，而不需要为每个参数的灵敏度求解一个新的系统。", "answer": "$$\n\\boxed{\\frac{1}{2} u^T \\frac{\\partial Q}{\\partial p} u + \\lambda^T \\left( \\frac{\\partial K}{\\partial p} u - \\frac{\\partial f}{\\partial p} \\right)}\n$$", "id": "2594547"}, {"introduction": "在推导出抽象的方程之后，下一步是将其应用于具体的工程问题。本练习 ([@problem_id:3543020]) 以一维弹性杆为例，要求你从零开始实现伴随敏感度分析的计算过程。此练习特别强调了在实际有限元程序中至关重要的高效、逐单元的组装方法，并揭示了自伴随问题中的一个特例。", "problem": "考虑一个一维小应变线性弹性杆，其长度为$L$，横截面积为$A$，杨氏模量场为$E(x,\\theta)=E_0+\\theta\\,\\psi(x)$，其中$\\theta$是一个标量设计参数，$\\psi(x)$是在一个包含$N$个等长度两节点线性单元的有限元法(FEM)网格上预设的单元内恒定场。该杆左端固定，右端承受一个外部施加的节点力$F$。设离散位移向量为$u\\in\\mathbb{R}^{N+1}$，并定义离散残差向量$R(u,\\theta)\\in\\mathbb{R}^{N+1}$来表示由控制偏微分方程(PDE)的有限元离散化所产生的内力和外力的代数平衡。假设小应变线弹性和胡克定律，带有节点$i$和$j$的单元$e$的单元刚度矩阵由标准的与$E A/h$成比例的两节点轴向形式给出，其中$h=L/N$是单元长度，全局刚度矩阵$K(\\theta)$通过对单元贡献求和来组装。\n\n定义标量目标泛函\n$$\nJ(u,\\theta)=f^\\top u+\\alpha\\,\\theta\\int_0^L \\psi(x)\\,A\\,dx,\n$$\n其中$f\\in\\mathbb{R}^{N+1}$是全局外力向量（$f$仅在最右侧节点处非零），$\\alpha$是一个给定的无量纲常数。泛函$J$包括柔度项$f^\\top u$和一个关于$\\theta$线性的显式正则化项。\n\n您的任务是：\n\n1. 从一维线性动量基本平衡和适用于小应变线性弹性的胡克定律出发，推导离散残差$R(u,\\theta)=K(\\theta)u-f$以及表达$J$相对于标量参数$\\theta$的总灵敏度所需的伴随方程，而无需构建任何稠密的灵敏度矩阵。清晰地用原始量表示此对称线性问题的伴随向量。\n\n2. 从第一性原理出发，推导如何使用单元级量和基于伴随的缩并来计算标量灵敏度$\\frac{dJ}{d\\theta}$。展示如何：\n   - 使用单元循环组装显式导数项$\\partial_\\theta J$。\n   - 使用单元循环以及仅利用局部的二乘二单元矩阵和$u$与$\\Lambda$的局部分片，来组装涉及伴随向量和残差关于$\\theta$的导数的缩并项$(\\partial_\\theta R)^\\top \\Lambda$。\n\n3. 实现一个独立完整的程序，该程序：\n   - 通过循环遍历单元并将$2\\times 2$的单元贡献放入全局矩阵中来组装$K(\\theta)$。\n   - 通过消除相应的自由度，在左端施加狄利克雷边界条件$u(0)=0$，并求解未知位移。\n   - 通过求解适当的线性系统来组装伴随向量。\n   - 通过对单元贡献$\\alpha\\,\\psi_e\\,A\\,h$求和来计算$\\partial_\\theta J$，其中$\\psi_e$是$\\psi(x)$在单元$e$上的单元内恒定值。\n   - 使用单元级缩并$\\lambda_e^\\top (k'_e\\,u_e)$来计算$(\\partial_\\theta R)^\\top \\Lambda$，其中$k'_e$是刚度矩阵关于$\\theta$的单元导数，而$(u_e,\\lambda_e)$是单元$e$的局部位移和伴随子向量。\n   - 对每个测试用例，使用在第2部分推导的基于伴随的表达式返回$\\frac{dJ}{d\\theta}$，而不形成任何稠密的全局灵敏度矩阵。\n\n物理单位：取$L$单位为m，$A$单位为$\\text{m}^2$，$E_0$和$\\psi$单位为Pa，$F$单位为N，位移单位为m。灵敏度$\\frac{dJ}{d\\theta}$必须以N·m表示。不涉及角度。将杆离散为等长度单元，单元长度为$h=L/N$。\n\n测试套件。您的程序必须为以下四个参数集计算$\\frac{dJ}{d\\theta}$：\n\n- 情况1（一般情况）：$N=5$，$L=1.0$ m，$A=0.01$ $\\text{m}^2$，$E_0=200\\times 10^9$ Pa，$\\theta=0.2$，$F=1000$ N，$\\alpha=1.0$，且$\\psi_e$在单元上线性增加，从$e=0$处的$10\\times 10^9$ Pa到$e=4$处的$50\\times 10^9$ Pa。\n\n- 情况2（基准参数）：与情况1相同，但$\\theta=0.0$。\n\n- 情况3（零载荷边界情况）：$N=3$，$L=2.0$ m，$A=0.02$ $\\text{m}^2$，$E_0=70\\times 10^9$ Pa，$\\theta=0.5$，$F=0$ N，$\\alpha=0.5$，且对所有单元$\\psi_e=5\\times 10^9$ Pa。\n\n- 情况4（含负参数的单单元边界情况）：$N=1$，$L=1.0$ m，$A=0.01$ $\\text{m}^2$，$E_0=200\\times 10^9$ Pa，$\\theta=-0.1$，$F=500$ N，$\\alpha=2.0$，且对单个单元$\\psi_e=30\\times 10^9$ Pa。\n\n最终输出格式：您的程序应生成单行输出，包含一个方括号内逗号分隔的列表。每个条目应为一个小数点后六位的科学记数法浮点数，单位为N·m，按顺序列出上述情况的$\\frac{dJ}{d\\theta}$。例如，格式必须与$[x_1,x_2,x_3,x_4]$完全一样，其中每个$x_i$的形式为$a.bbbbbbe\\pm cc$。", "solution": "该问题要求对一维线性弹性杆进行基于伴随的灵敏度分析的推导和实现。目标是计算标量目标泛函$J$关于设计参数$\\theta$的总灵敏度，而无需计算任何稠密的灵敏度矩阵。\n\n### 任务1：离散残差和伴随方程的推导\n\n该力学系统由一维线性动量平衡控制，对于静态平衡且无体力的情况，其强形式为：\n$$\n-\\frac{d}{dx}\\left(\\sigma(x) A\\right) = 0 \\quad \\text{for } x \\in (0, L)\n$$\n其中$\\sigma(x)$是轴向应力，$A$是横截面积。本构关系是小应变线性弹性的胡克定律，$\\sigma(x) = E(x, \\theta) \\epsilon(x)$，其中$\\epsilon(x) = \\frac{du}{dx}$是轴向应变，$u(x)$是位移场。杨氏模量依赖于设计参数$\\theta$，为$E(x,\\theta)=E_0+\\theta\\,\\psi(x)$。因此，控制方程为：\n$$\n-\\frac{d}{dx}\\left(A (E_0+\\theta\\,\\psi(x)) \\frac{du}{dx}\\right) = 0\n$$\n边界条件为左端的本质（狄利克雷）条件$u(0)=0$，以及右端的自然（诺伊曼）条件$A E(L, \\theta) \\frac{du}{dx}|_{x=L} = F$。\n\n为了推导有限元法(FEM)公式，我们从弱形式开始。将PDE乘以一个检验函数$w(x)$（其中$w(0)=0$）并在域$[0,L]$上积分，得到：\n$$\n\\int_0^L -\\frac{d}{dx}\\left(A E \\frac{du}{dx}\\right) w(x) \\,dx = 0\n$$\n进行分部积分，我们得到：\n$$\n\\int_0^L \\left(A E \\frac{du}{dx}\\right)\\frac{dw}{dx} \\,dx - \\left[A E \\frac{du}{dx} w(x)\\right]_0^L = 0\n$$\n应用边界条件$w(0)=0$和$A E(L, \\theta)\\frac{du}{dx}|_{x=L}=F$，这简化为：\n$$\n\\int_0^L \\frac{dw}{dx} A E(x,\\theta) \\frac{du}{dx} \\,dx = w(L)F\n$$\n我们将域离散为$N$个等长度$h=L/N$的线性两节点单元。位移场近似为$u(x) \\approx \\sum_{i=0}^{N} u_i N_i(x)$，其中$u_i$是节点位移，$N_i(x)$是分段线性形函数。将此近似同时代入试探函数$u$和检验函数$w$，得到离散的线性代数方程组：\n$$\nK(\\theta)u = f\n$$\n这里，$u \\in \\mathbb{R}^{N+1}$是节点位移向量，$f \\in \\mathbb{R}^{N+1}$是全局外力向量，其在最后一个节点处有唯一的非零项$F$，$K(\\theta) \\in \\mathbb{R}^{(N+1)\\times(N+1)}$是从单元刚度矩阵$k_e$组装而来的全局刚度矩阵。对于一个跨越节点$i$和$j$，模量为常数$E_e=E_0+\\theta\\psi_e$的单元$e$，其刚度矩阵为：\n$$\nk_e(\\theta) = \\frac{E_e A}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} = \\frac{(E_0+\\theta\\psi_e)A}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n代表每个节点力平衡的离散残差向量定义为：\n$$\nR(u, \\theta) = K(\\theta)u - f\n$$\n在平衡状态下，$R(u(\\theta), \\theta) = 0$。\n\n目标泛函为$J(u, \\theta) = f^\\top u + \\alpha\\,\\theta\\int_0^L \\psi(x)\\,A\\,dx$。我们求其关于$\\theta$的全导数：\n$$\n\\frac{dJ}{d\\theta} = \\frac{\\partial J}{\\partial u} \\frac{du}{d\\theta} + \\frac{\\partial J}{\\partial \\theta}\n$$\n为避免计算灵敏度矩阵$\\frac{du}{d\\theta}$，我们使用伴随法。我们将平衡方程$R(u(\\theta), \\theta) = 0$对$\\theta$求导：\n$$\n\\frac{dR}{d\\theta} = \\frac{\\partial R}{\\partial u} \\frac{du}{d\\theta} + \\frac{\\partial R}{\\partial \\theta} = 0 \\implies \\frac{du}{d\\theta} = - \\left(\\frac{\\partial R}{\\partial u}\\right)^{-1} \\frac{\\partial R}{\\partial \\theta}\n$$\n将此代入$\\frac{dJ}{d\\theta}$的表达式：\n$$\n\\frac{dJ}{d\\theta} = \\frac{\\partial J}{\\partial \\theta} - \\frac{\\partial J}{\\partial u} \\left(\\frac{\\partial R}{\\partial u}\\right)^{-1} \\frac{\\partial R}{\\partial \\theta}\n$$\n我们定义伴随向量$\\Lambda$以消除矩阵求逆。伴随方程是：\n$$\n\\left(\\frac{\\partial R}{\\partial u}\\right)^\\top \\Lambda = \\left(\\frac{\\partial J}{\\partial u}\\right)^\\top\n$$\n有了这个定义，项$\\frac{\\partial J}{\\partial u} (\\frac{\\partial R}{\\partial u})^{-1}$可以重写为$\\Lambda^\\top$。让我们计算这些偏导数：\n- $\\frac{\\partial R}{\\partial u} = K(\\theta)$\n- $\\frac{\\partial J}{\\partial u} = f^\\top$\n\n伴随方程变为$K(\\theta)^\\top \\Lambda = f$。由于单元刚度矩阵$k_e$是对称的，组装的全局刚度矩阵$K(\\theta)$也是对称的，所以$K(\\theta)^\\top = K(\\theta)$。因此，伴随方程是：\n$$\nK(\\theta)\\Lambda = f\n$$\n这与原始平衡方程$K(\\theta)u = f$相同。由于$K(\\theta)$（在施加边界条件后）是可逆的，解是唯一的。因此，对于这个特定问题，伴随向量等于原始位移向量：\n$$\n\\Lambda = u\n$$\n总灵敏度现在表示为：\n$$\n\\frac{dJ}{d\\theta} = \\frac{\\partial J}{\\partial \\theta} - \\Lambda^\\top \\frac{\\partial R}{\\partial \\theta}\n$$\n\n### 任务2：灵敏度的单元级计算\n\n我们现在使用单元级量来构建$\\frac{dJ}{d\\theta}$的计算。总灵敏度包括两部分：显式导数项$\\frac{\\partial J}{\\partial \\theta}$和缩并项$\\Lambda^\\top \\frac{\\partial R}{\\partial \\theta}$。\n\n显式导数项通过对$J$关于$\\theta$求导（同时保持$u$恒定）得到：\n$$\n\\frac{\\partial J}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} \\left( f^\\top u + \\alpha\\,\\theta\\int_0^L \\psi(x)\\,A\\,dx \\right) = \\alpha\\int_0^L \\psi(x)\\,A\\,dx\n$$\n由于$\\psi(x)$被定义为单元内恒定场$\\psi_e$，积分变为对$N$个单元的求和：\n$$\n\\frac{\\partial J}{\\partial \\theta} = \\alpha \\sum_{e=0}^{N-1} \\int_{x_e}^{x_{e+1}} \\psi_e A \\,dx = \\sum_{e=0}^{N-1} \\alpha\\,\\psi_e\\,A\\,h\n$$\n该项可以通过遍历单元轻松组装。\n\n第二项涉及残差关于$\\theta$的偏导数：\n$$\n\\frac{\\partial R}{\\partial \\theta} = \\frac{\\partial}{\\partial \\theta} (K(\\theta)u - f) = \\frac{\\partial K(\\theta)}{\\partial \\theta} u = K'(\\theta)u\n$$\n因此，缩并项为$(\\partial_\\theta R)^\\top \\Lambda = (K'(\\theta)u)^\\top \\Lambda = u^\\top K'(\\theta)^\\top \\Lambda$。由于$K'(\\theta)$也是对称的，这等于$u^\\top K'(\\theta) \\Lambda$。这个全局缩并可以通过对单元级贡献求和来计算：\n$$\nu^\\top K'(\\theta) \\Lambda = \\left(\\sum_{e=0}^{N-1} u_e^\\top k'_e(\\theta) \\lambda_e\\right)\n$$\n其中$u_e$和$\\lambda_e$是单元$e$的局部位移和伴随向量，$k'_e(\\theta)$是单元刚度矩阵关于$\\theta$的导数：\n$$\nk'_{e}(\\theta) = \\frac{\\partial}{\\partial \\theta} \\left( \\frac{(E_0+\\theta\\psi_e)A}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\right) = \\frac{\\psi_e A}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n总灵敏度的完整表达式为：\n$$\n\\frac{dJ}{d\\theta} = \\sum_{e=0}^{N-1} \\alpha\\,\\psi_e\\,A\\,h - \\sum_{e=0}^{N-1} \\lambda_e^\\top k'_e u_e\n$$\n因为我们发现$\\Lambda = u$，所以对于所有单元都有$\\lambda_e=u_e$。用于实现的最终表达式是：\n$$\n\\frac{dJ}{d\\theta} = \\sum_{e=0}^{N-1} \\left( \\alpha\\,\\psi_e\\,A\\,h - u_e^\\top k'_e u_e \\right)\n$$\n这个简洁的结果允许通过先求解原始问题得到$u$，然后执行单个单元循环来累加显式导数和缩并贡献，从而计算总灵敏度，完全避免了构建任何大型灵敏度矩阵。\n\n### 任务3：实现策略\n\n实现将对每个测试用例遵循以下步骤：\n1.  定义问题参数：$N, L, A, E_0, \\theta, F, \\alpha, \\psi_e$。单元长度为$h=L/N$。\n2.  通过遍历单元$e=0, \\dots, N-1$来组装大小为$(N+1)\\times(N+1)$的全局刚度矩阵$K(\\theta)$。对每个单元，计算$k_e(\\theta)$并将其条目加到相应的全局自由度上。\n3.  构建全局力向量$f$，该向量除$f_N = F$外处处为零。\n4.  通过消除K矩阵的第一行和第一列以及力向量的第一个条目来施加狄利克雷边界条件$u_0=0$。\n5.  求解简化的线性系统$K_{reduced} u_{reduced} = f_{reduced}$以获得未知位移。重构完整的位移向量$u$。\n6.  认识到伴随向量$\\Lambda$与原始位移向量$u$相同，因此设$\\Lambda=u$。\n7.  将总灵敏度$\\frac{dJ}{d\\theta}$初始化为零。\n8.  循环遍历单元$e=0, \\dots, N-1$：\n    a. 计算单元的显式灵敏度贡献：$s_e^{exp} = \\alpha\\,\\psi_e\\,A\\,h$。\n    b. 构建单元刚度导数矩阵$k'_e$。\n    c. 提取局部位移/伴随向量$u_e = \\lambda_e = [u_i, u_{i+1}]$。\n    d. 计算单元缩并项：$s_e^{contr} = \\lambda_e^\\top k'_e u_e$。\n    e. 更新总灵敏度：$\\frac{dJ}{d\\theta} \\leftarrow \\frac{dJ}{d\\theta} + s_e^{exp} - s_e^{contr}$。\n9.  返回计算出的总灵敏度$\\frac{dJ}{d\\theta}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_sensitivity(N, L, A, E0, theta, F, alpha, psi_values):\n    \"\"\"\n    Computes the adjoint-based sensitivity dJ/dtheta for a 1D elastic bar.\n\n    Args:\n        N (int): Number of elements.\n        L (float): Length of the bar (m).\n        A (float): Cross-sectional area (m^2).\n        E0 (float): Base Young's modulus (Pa).\n        theta (float): Scalar design parameter (dimensionless).\n        F (float): Applied force at the right end (N).\n        alpha (float): Regularization constant (dimensionless).\n        psi_values (np.ndarray): Array of element-wise psi values (Pa).\n\n    Returns:\n        float: The computed sensitivity dJ/dtheta (N*m).\n    \"\"\"\n    num_nodes = N + 1\n    h = L / N\n\n    # 1. Assemble global stiffness matrix K(theta)\n    K = np.zeros((num_nodes, num_nodes))\n    for e in range(N):\n        # Element properties\n        psi_e = psi_values[e]\n        E_e = E0 + theta * psi_e\n        \n        # Element stiffness matrix\n        k_e_scalar = E_e * A / h\n        k_e = k_e_scalar * np.array([[1, -1], [-1, 1]])\n\n        # Assembly into global matrix\n        i, j = e, e + 1\n        K[i:i+2, i:i+2] += k_e\n\n    # 2. Define global force vector f\n    f = np.zeros(num_nodes)\n    f[-1] = F\n\n    # 3. Apply Dirichlet BC u(0) = 0 and solve for primal displacements u\n    # We solve K_reduced * u_reduced = f_reduced\n    K_reduced = K[1:, 1:]\n    f_reduced = f[1:]\n    \n    # Primal solve\n    try:\n        u_reduced = np.linalg.solve(K_reduced, f_reduced)\n    except np.linalg.LinAlgError:\n        # This may happen if K is singular, e.g., if F=0 and the body is unconstrained.\n        # But with one fixed BC, K_reduced should be invertible.\n        # If F=0, u_reduced will be all zeros.\n        u_reduced = np.zeros(N)\n\n    # Reconstruct full displacement vector\n    u = np.zeros(num_nodes)\n    u[1:] = u_reduced\n\n    # 4. Solve for adjoint vector Lambda\n    # For this self-adjoint problem, Lambda = u\n    Lambda = u\n\n    # 5. Compute dJ/dtheta using element-wise contributions\n    dJ_dtheta = 0.0\n    \n    # Element-wise loop for sensitivity calculation\n    for e in range(N):\n        # Nodes of the current element\n        i, j = e, e + 1\n        \n        # a) Explicit derivative of J w.r.t. theta\n        psi_e = psi_values[e]\n        dJ_dtheta_explicit_e = alpha * psi_e * A * h\n        \n        # b) Contraction term: lambda_e^T * k'_e * u_e\n        \n        # Element stiffness derivative matrix k'_e\n        k_prime_e_scalar = psi_e * A / h\n        k_prime_e = k_prime_e_scalar * np.array([[1, -1], [-1, 1]])\n        \n        # Local displacement and adjoint vectors\n        u_e = u[i:i+2]\n        lambda_e = Lambda[i:i+2]\n        \n        # Element contraction\n        contraction_e = lambda_e.T @ k_prime_e @ u_e\n        \n        # c) Accumulate total sensitivity\n        dJ_dtheta += (dJ_dtheta_explicit_e - contraction_e)\n        \n    return dJ_dtheta\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General case\n        {'N': 5, 'L': 1.0, 'A': 0.01, 'E0': 200e9, 'theta': 0.2, 'F': 1000, \n         'alpha': 1.0, 'psi_values': np.linspace(10e9, 50e9, 5)},\n        \n        # Case 2: Base parameter (theta=0)\n        {'N': 5, 'L': 1.0, 'A': 0.01, 'E0': 200e9, 'theta': 0.0, 'F': 1000, \n         'alpha': 1.0, 'psi_values': np.linspace(10e9, 50e9, 5)},\n        \n        # Case 3: Zero load edge case\n        {'N': 3, 'L': 2.0, 'A': 0.02, 'E0': 70e9, 'theta': 0.5, 'F': 0, \n         'alpha': 0.5, 'psi_values': np.full(3, 5e9)},\n\n        # Case 4: Single-element boundary case with negative parameter\n        {'N': 1, 'L': 1.0, 'A': 0.01, 'E0': 200e9, 'theta': -0.1, 'F': 500, \n         'alpha': 2.0, 'psi_values': np.full(1, 30e9)}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_sensitivity(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3543020"}, {"introduction": "在非线性分析的背景下，伴随法的威力更加强大，但其应用也更为精妙。本练习 ([@problem_id:3543074]) 探讨了一个关键概念：当在牛顿-拉弗森求解器中使用近似切线矩阵时，可能引发的梯度不一致性。通过一个简单的非线性模型，你将深入理解为何伴随系统必须与收敛残差的精确线性化保持一致，这是在非线性力学中进行稳健实现的关键一课。", "problem": "考虑一个计算固体力学中的非线性静态平衡问题，其离散平衡表示为求根问题 $R(u,p)=0$，其中 $u\\in\\mathbb{R}^n$ 是状态（节点位移），$p\\in\\mathbb{R}^m$ 是参数向量。假设正向问题通过牛顿-拉夫逊（NR）迭代求解，该迭代在第 $k$ 次迭代时，围绕当前迭代点 $u^{(k)}$ 对残差进行线性化，并从一个线性系统中计算出更新量 $\\Delta u^{(k)}$。精确且一致的线性化使用切线 $K(u,p)=\\partial R/\\partial u(u,p)$，但在实践中，迭代过程可能会使用近似切线 $K^\\mathrm{approx}(u,p)\\neq\\partial R/\\partial u(u,p)$。设在状态和参数上定义了一个标量目标函数 $J(u,p)$，需要求解其关于 $p$ 的灵敏度。\n\n您的任务如下。\n\n- 仅使用非线性代数系统求解的基本定义和链式法则，当线性化精确时，构建与 $R(u,p)=0$ 的收敛NR解 $u^\\star(p)$ 相关的离散伴随系统。由此推导出依赖于伴随解的梯度 $\\nabla_p J(u^\\star(p),p)$ 的表达式。\n\n- 现在假设，在正向NR迭代中，线性求解使用了一个近似切线 $K^\\mathrm{approx}(u,p)\\neq\\partial R/\\partial u(u,p)$。如果在收敛状态下的伴随线性求解中重复使用相同的近似切线，请构建相应的伴随系统。将其与精确离散伴随系统进行比较，并找出梯度不一致性的数学根源。\n\n- 为了量化其影响，采用一个代表具有非线性本构响应的双节点杆的人工构造的无量纲单自由度非线性弹性模型。设残差为\n$$\nR(u,p) \\;=\\; p\\,u \\;+\\; \\beta\\,u^3 \\;-\\; F,\n$$\n其中 $u\\in\\mathbb{R}$ 是自由节点处的单个位移未知数，$p\\in\\mathbb{R}$ 是一个类材料刚度参数，$\\beta\\in\\mathbb{R}_{\\ge 0}$ 是一个非线性参数，$F\\in\\mathbb{R}$ 是施加的荷载。取标量目标函数为\n$$\nJ(u,p) \\;=\\; \\tfrac{1}{2}\\,u^2,\n$$\n这是一个标准的类能量。该人工构造的结构是无量纲的；所有数值输出均以无量纲单位表示。\n\n- 在正向求解中，使用阻尼NR迭代进行更新\n$$\nu^{(k+1)} \\;=\\; u^{(k)} \\;-\\; \\alpha^{(k)}\\left(K^\\mathrm{approx}(u^{(k)},p)\\right)^{-1} R(u^{(k)},p),\n$$\n其中回溯线搜索因子 $\\alpha^{(k)}\\in(0,1]$ 的选择旨在减小残差范数。对于近似切线，使用参数族\n$$\nK^\\mathrm{approx}(u,p) \\;=\\; p \\;+\\; c\\,\\beta\\,u^2,\n$$\n其中 $c\\in\\mathbb{R}$ 是一个用户指定的系数。精确切线为 $\\partial R/\\partial u(u,p)=p+3\\beta u^2$。\n\n- 在收敛到 $u^\\star(p)$ 后，计算在该状态下关于 $p$ 的两个梯度：通过使用精确切线求解伴随系统得到的精确离散伴随梯度，以及通过使用近似切线求解伴随系统得到的近似梯度。然后报告这两个梯度之间的绝对误差和相对误差度量。\n\n设计一个单一程序，对于以下每个测试用例 $(p,\\beta,F,c)$，执行正向求解以获得 $u^\\star$，计算关于 $p$ 的精确和近似伴随梯度，然后报告 $u^\\star$、精确梯度、近似梯度、绝对误差和相对误差。使用以下测试套件，其选择旨在检验一个典型情况、一个线性情况、一个强非线性情况、一个过刚近似切线情况以及一个零荷载边界情况：\n\n- 测试 1：$(p,\\beta,F,c)=(2.0,1.0,1.0,0.0)$。\n- 测试 2：$(p,\\beta,F,c)=(1.0,0.0,1.2,0.0)$。\n- 测试 3：$(p,\\beta,F,c)=(0.5,5.0,0.2,1.0)$。\n- 测试 4：$(p,\\beta,F,c)=(0.2,1.0,0.01,6.0)$。\n- 测试 5：$(p,\\beta,F,c)=(3.0,2.0,0.0,0.0)$。\n\n所有量均为无量纲；所有输出均以无量纲浮点数表示。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的Python风格列表的列表，每个内部列表对应给定顺序的一个测试用例，并按顺序包含五个浮点数 $[u^\\star,\\;\\text{grad\\_exact},\\;\\text{grad\\_approx},\\;\\text{abs\\_error},\\;\\text{rel\\_error}]$。例如，输出格式必须与\n$[\\,[u_1,g^\\text{exact}_1,g^\\text{approx}_1,e^\\text{abs}_1,e^\\text{rel}_1],\\,[u_2,\\dots],\\dots\\,]$ 完全一样。", "solution": "该问题要求首先推导一般非线性系统的精确和不一致离散伴随灵敏度表达式，然后对一个特定的单自由度模型进行数值研究。\n\n一般性问题是，找到一个标量目标函数 $J(u,p)$ 关于参数向量 $p \\in \\mathbb{R}^m$ 的灵敏度，其中状态向量 $u \\in \\mathbb{R}^n$ 是由非线性代数方程组 $R(u,p)=0$ 的解定义的 $p$ 的隐函数。解 $u^\\star(p)$ 是在牛顿-拉夫逊（NR）迭代的收敛极限下找到的。\n\n首先，我们推导精确离散伴随梯度的表达式。$J$ 关于参数 $p_i$ 的全导数由链式法则给出：\n$$\n\\frac{dJ}{dp_i} = \\frac{\\partial J}{\\partial p_i} + \\frac{\\partial J}{\\partial u} \\frac{du}{dp_i}\n$$\n状态关于参数的灵敏度 $\\frac{du}{dp_i}$ 是未知的。它可以通过对控制平衡方程 $R(u(p), p) = 0$ 关于 $p_i$ 求导来找到：\n$$\n\\frac{dR}{dp_i} = \\frac{\\partial R}{\\partial p_i} + \\frac{\\partial R}{\\partial u} \\frac{du}{dp_i} = 0\n$$\n令 $K = \\frac{\\partial R}{\\partial u}$ 为精确切线刚度矩阵。上述方程可以重排以求解状态灵敏度：\n$$\nK \\frac{du}{dp_i} = - \\frac{\\partial R}{\\partial p_i} \\implies \\frac{du}{dp_i} = -K^{-1} \\frac{\\partial R}{\\partial p_i}\n$$\n将此代入 $J$ 的全导数表达式，得到梯度的直接微分公式：\n$$\n\\frac{dJ}{dp_i} = \\frac{\\partial J}{\\partial p_i} - \\frac{\\partial J}{\\partial u} K^{-1} \\frac{\\partial R}{\\partial p_i}\n$$\n伴随方法为此提供了一种高效的替代方案，特别是当参数数量 $m$ 很大时。我们引入一个伴随变量向量 $\\lambda \\in \\mathbb{R}^n$，定义为线性伴随系统的解：\n$$\nK^T \\lambda = \\left(\\frac{\\partial J}{\\partial u}\\right)^T\n$$\n通过求解 $\\lambda$ 并取转置，我们得到 $\\lambda^T = \\frac{\\partial J}{\\partial u} K^{-1}$。将此代入直接微分公式，我们得到梯度的伴随表达式：\n$$\n\\frac{dJ}{dp_i} = \\frac{\\partial J}{\\partial p_i} - \\lambda^T \\frac{\\partial R}{\\partial p_i}\n$$\n这就是精确离散伴随灵敏度。无论参数数量如何，它都只需要求解一个关于 $\\lambda$ 的线性系统，因此在计算上具有优势。所有偏导数和切线 $K$ 都在收敛状态 $(u^\\star, p)$ 处求值。\n\n接下来，我们考虑正向NR迭代使用近似切线 $K^\\mathrm{approx}(u,p) \\neq K(u,p)$ 的情况。在实践中，为了节省计算成本，人们可能会重用来自正向求解的 $K^\\mathrm{approx}$ 来构建一个“近似”伴随系统。该系统定义为：\n$$\n(K^\\mathrm{approx})^T \\lambda^\\mathrm{approx} = \\left(\\frac{\\partial J}{\\partial u}\\right)^T\n$$\n其中 $K^\\mathrm{approx}$ 在收敛状态 $u^\\star$ 处求值。然后使用这个 $\\lambda^\\mathrm{approx}$ 计算得到的“近似”梯度为：\n$$\n\\left(\\frac{dJ}{dp_i}\\right)_\\mathrm{approx} = \\frac{\\partial J}{\\partial p_i} - (\\lambda^\\mathrm{approx})^T \\frac{\\partial R}{\\partial p_i}\n$$\n代入 $\\lambda^\\mathrm{approx}$ 的定义，揭示了其底层表达式：\n$$\n\\left(\\frac{dJ}{dp_i}\\right)_\\mathrm{approx} = \\frac{\\partial J}{\\partial p_i} - \\frac{\\partial J}{\\partial u} (K^\\mathrm{approx})^{-1} \\frac{\\partial R}{\\partial p_i}\n$$\n梯度不一致性的数学根源现在显而易见了。比较精确梯度 $\\frac{dJ}{dp_i}$ 和近似梯度，我们看到项 $K^{-1}$ 被替换为 $(K^\\mathrm{approx})^{-1}$。伴随方法是一个形式上的数学恒等式，它依赖于伴随方程中的算子 $K^T$ 是线性化状态方程中算子 $K = \\frac{\\partial R}{\\partial u}$ 的精确转置。当使用近似切线 $K^\\mathrm{approx} \\neq \\frac{\\partial R}{\\partial u}$ 时，这种对应关系被打破。得到的灵敏度 $(\\frac{dJ}{dp_i})_\\mathrm{approx}$ 不再是 $J$ 关于 $p_i$ 的真实全导数。梯度中的误差由下式给出：\n$$\n\\text{Error} = \\left(\\frac{dJ}{dp_i}\\right)_\\mathrm{approx} - \\frac{dJ}{dp_i} = \\frac{\\partial J}{\\partial u} \\left( K^{-1} - (K^\\mathrm{approx})^{-1} \\right) \\frac{\\partial R}{\\partial p_i}\n$$\n仅当 $K^\\mathrm{approx} = K$，或者 $\\frac{\\partial J}{\\partial u}$ 或 $\\frac{\\partial R}{\\partial p_i}$ 为零时，此误差才为零。\n\n现在我们将此框架应用于指定的单自由度模型。变量 $u$ 和 $p$ 是标量。\n残差为 $R(u,p) = p\\,u + \\beta\\,u^3 - F$。\n目标函数为 $J(u,p) = \\frac{1}{2}\\,u^2$。\n\n在收敛状态 $u^\\star$ 处求值的必要偏导数为：\n- $\\frac{\\partial J}{\\partial u}(u^\\star) = u^\\star$\n- $\\frac{\\partial J}{\\partial p}(u^\\star) = 0$\n- $\\frac{\\partial R}{\\partial p}(u^\\star) = u^\\star$\n\n精确和近似切线（在此一维情况下为标量）为：\n- 精确切线：$K(u^\\star, p) = \\frac{\\partial R}{\\partial u}(u^\\star, p) = p + 3\\beta (u^\\star)^2$\n- 近似切线：$K^\\mathrm{approx}(u^\\star, p) = p + c\\,\\beta\\,(u^\\star)^2$\n\n对于精确梯度，标量伴随变量 $\\lambda$ 从 $K \\lambda = \\frac{\\partial J}{\\partial u}$ 中求得，即 $\\lambda = \\frac{u^\\star}{p + 3\\beta (u^\\star)^2}$。关于 $p$ 的精确梯度为：\n$$\n\\left(\\frac{dJ}{dp}\\right)_{\\text{exact}} = \\frac{\\partial J}{\\partial p} - \\lambda \\frac{\\partial R}{\\partial p} = 0 - \\left(\\frac{u^\\star}{p + 3\\beta (u^\\star)^2}\\right) u^\\star = -\\frac{(u^\\star)^2}{p + 3\\beta (u^\\star)^2}\n$$\n对于近似梯度，近似伴随变量 $\\lambda^\\mathrm{approx}$ 从 $K^\\mathrm{approx} \\lambda^\\mathrm{approx} = \\frac{\\partial J}{\\partial u}$ 中求得，即 $\\lambda^\\mathrm{approx} = \\frac{u^\\star}{p + c\\beta (u^\\star)^2}$。近似梯度为：\n$$\n\\left(\\frac{dJ}{dp}\\right)_{\\text{approx}} = \\frac{\\partial J}{\\partial p} - \\lambda^\\mathrm{approx} \\frac{\\partial R}{\\partial p} = 0 - \\left(\\frac{u^\\star}{p + c\\beta (u^\\star)^2}\\right) u^\\star = -\\frac{(u^\\star)^2}{p + c\\beta (u^\\star)^2}\n$$\n数值实现将首先使用带有切线 $K^\\mathrm{approx}(u^{(k)}, p)$ 的阻尼牛顿-拉夫逊方案求解 $R(u,p)=0$ 以得到 $u^\\star$。收敛后，将 $u^\\star$ 用于上述两个公式计算梯度。绝对误差为 $|\\text{grad\\_approx} - \\text{grad\\_exact}|$，相对误差为此绝对误差除以 $|\\text{grad\\_exact}|$，同时要小心处理精确梯度为零的情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It computes the converged state, exact and approximate adjoint gradients,\n    and the associated errors for a 1D nonlinear model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (p, beta, F, c)\n        (2.0, 1.0, 1.0, 0.0),\n        (1.0, 0.0, 1.2, 0.0),\n        (0.5, 5.0, 0.2, 1.0),\n        (0.2, 1.0, 0.01, 6.0),\n        (3.0, 2.0, 0.0, 0.0),\n    ]\n\n    results = []\n    \n    # --- Newton-Raphson Solver Parameters ---\n    TOL = 1e-12  # Convergence tolerance for residual\n    MAX_ITER = 100 # Maximum number of iterations\n    MAX_LS_STEPS = 10 # Maximum backtracking steps in line search\n\n    for case in test_cases:\n        p, beta, F, c = case\n\n        # Define model-specific functions\n        def get_residual(u, p_val, beta_val, F_val):\n            return p_val * u + beta_val * u**3 - F_val\n\n        def get_approx_tangent(u, p_val, beta_val, c_val):\n            return p_val + c_val * beta_val * u**2\n\n        # --- Forward Solve: Damped Newton-Raphson ---\n        u_k = 0.0\n        for _ in range(MAX_ITER):\n            res = get_residual(u_k, p, beta, F)\n\n            if abs(res)  TOL:\n                break\n\n            k_approx = get_approx_tangent(u_k, p, beta, c)\n            \n            # Prevent division by zero, although not expected for these cases\n            if abs(k_approx)  1e-15:\n                # If tangent is zero and residual is not, we can't proceed.\n                # This could happen if p=0, beta>0, c>0, u=0.\n                u_k = np.nan # Indicate solver failure\n                break\n\n            delta_u = -res / k_approx\n\n            # --- Backtracking Line Search ---\n            alpha = 1.0\n            for _ in range(MAX_LS_STEPS):\n                u_new = u_k + alpha * delta_u\n                res_new = get_residual(u_new, p, beta, F)\n                if abs(res_new)  abs(res):\n                    break\n                alpha /= 2.0\n            \n            u_k = u_new\n        \n        u_star = u_k\n\n        # --- Adjoint-based Gradient Computations at u_star ---\n        \n        # Exact gradient\n        k_exact = p + 3.0 * beta * u_star**2\n        if abs(k_exact)  1e-15:\n            # This occurs if denominator is zero.\n            grad_exact = np.inf if u_star**2 > 0 else 0.0\n        else:\n            grad_exact = -(u_star**2) / k_exact\n            \n        # Approximate gradient\n        k_approx_conv = p + c * beta * u_star**2\n        if abs(k_approx_conv)  1e-15:\n            grad_approx = np.inf if u_star**2 > 0 else 0.0\n        else:\n            grad_approx = -(u_star**2) / k_approx_conv\n            \n        # --- Error Computations ---\n        abs_error = abs(grad_approx - grad_exact)\n        \n        # Define relative error. If exact gradient is zero, the error is only\n        # non-zero if the approximate gradient is non-zero (infinite relative error).\n        # However, for this problem, if grad_exact is zero (because u_star=0),\n        # grad_approx is also zero. So, if grad_exact is zero, relative error is zero.\n        if abs(grad_exact)  1e-15:\n            rel_error = 0.0 if abs_error  1e-15 else np.inf\n        else:\n            rel_error = abs_error / abs(grad_exact)\n\n        results.append([u_star, grad_exact, grad_approx, abs_error, rel_error])\n\n    # Final print statement in the exact required format.\n    # Format: [[u_1,g_e_1,g_a_1,e_a_1,e_r_1],[u_2,...],...]\n    output_str = \"[\" + \",\".join(\n        f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]}]\" for res in results\n    ) + \"]\"\n    print(output_str)\n\n\nsolve()\n\n```", "id": "3543074"}]}