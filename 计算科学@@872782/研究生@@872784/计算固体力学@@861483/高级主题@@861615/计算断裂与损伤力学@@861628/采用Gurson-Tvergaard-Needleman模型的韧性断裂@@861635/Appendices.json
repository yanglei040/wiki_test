{"hands_on_practices": [{"introduction": "这项首要练习旨在奠定坚实的基础。我们将从连续介质力学的基本原理出发，例如基体材料的质量守恒，来推导控制现有孔隙在塑性变形下如何增长的基本方程。通过这个练习，你将能清晰地理解宏观塑性体积应变率 $\\text{tr}(\\dot{\\boldsymbol{\\varepsilon}}^p)$ 与内部损伤变量（即孔隙度 $f$）演化之间的直接联系。[@problem_id:3559564]", "problem": "考虑在延性断裂的 Gurson–Tvergaard–Needleman (GTN) 框架内建模的多孔金属。设一个代表性体积元的总体积为 $V(t)$，由体积为 $V_{v}(t)$ 的孔洞相和体积为 $V_{m}(t)$ 的基体（固相）相组成，其孔洞体积分数为 $f(t) = V_{v}(t)/V(t)$。假设为小应变设定，且基体是塑性不可压缩的，因此塑性膨胀仅由孔洞长大引起。宏观塑性体积应变率定义为 $\\mathrm{tr}(\\dot{\\boldsymbol{\\varepsilon}}^{p}) = \\dot{V}^{p}/V$，其中 $\\dot{V}^{p}$ 是总体积变化率的塑性部分。不存在孔洞形核，因此 $f$ 的唯一变化来自现有孔洞的长大。给定一个恒定的塑性体积应变率 $\\mathrm{tr}(\\dot{\\boldsymbol{\\varepsilon}}^{p}) = c$（其中 $c > 0$）和一个初始条件 $f(0) = f_0$（其中 $0  f_0  1$）。\n\n从上述基本定义和假设出发，推导 $f(t)$ 的控制常微分方程，并对其进行解析求解，以获得 $f(t)$ 关于 $t$、$c$ 和 $f_0$ 的闭式表达式。将最终答案表示为单个闭式解析表达式。由于 $f$ 是无量纲的，因此不需要指定单位。不要四舍五入，请提供精确表达式。", "solution": "该问题要求在恒定宏观塑性体积应变率下，推导并求解控制孔洞体积分数 $f(t)$ 演化的常微分方程。\n\n### 步骤 1：提取已知条件\n-   代表性体积元 (RVE) 的总体积为 $V(t)$。\n-   孔洞相的体积为 $V_v(t)$。\n-   基体相的体积为 $V_m(t)$。\n-   孔洞体积分数为 $f(t) = V_v(t)/V(t)$。\n-   基体材料是塑性不可压缩的。\n-   RVE 的塑性膨胀仅由孔洞长大引起。\n-   宏观塑性体积应变率定义为 $\\mathrm{tr}(\\dot{\\boldsymbol{\\varepsilon}}^{p}) = \\dot{V}^{p}/V$，其中 $\\dot{V}^{p}$ 是总体积变化率的塑性部分。\n-   不存在孔洞形核。\n-   宏观塑性体积应变率是一个正常数：$\\mathrm{tr}(\\dot{\\boldsymbol{\\varepsilon}}^{p}) = c$，其中 $c > 0$。\n-   初始条件为 $f(0) = f_0$，其中 $0  f_0  1$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上基于连续介质损伤力学的原理，特别是多孔金属塑性理论。孔洞体积分数和塑性体积应变率的定义是标准的。诸如塑性不可压缩基体和恒定应变率等假设，是用于在此框架内推导基本关系的常见理想化方法。该问题是适定的，具有明确的目标、充分的初始条件和清晰的定义。它是客观的，不含非科学性主张。因此，该问题被认为是有效的。\n\n### 步骤 3：控制微分方程的推导\n孔洞体积分数 $f(t)$ 的演化可通过对其进行时间求导得到。孔洞体积分数定义为：\n$$\nf(t) = \\frac{V_v(t)}{V(t)}\n$$\n使用关于时间 $t$ 的商法则求导，我们得到：\n$$\n\\dot{f} = \\frac{d}{dt}\\left(\\frac{V_v}{V}\\right) = \\frac{\\dot{V}_v V - V_v \\dot{V}}{V^2} = \\frac{\\dot{V}_v}{V} - \\frac{V_v}{V} \\frac{\\dot{V}}{V} = \\frac{\\dot{V}_v}{V} - f \\frac{\\dot{V}}{V}\n$$\n孔洞体积分数的总变化率 $\\dot{f}$ 是由孔洞形核引起的速率 $\\dot{f}_{\\text{nucl}}$ 和由孔洞长大引起的速率 $\\dot{f}_{\\text{growth}}$ 之和。问题陈述不存在孔洞形核，因此 $\\dot{f}_{\\text{nucl}} = 0$，这意味着 $\\dot{f} = \\dot{f}_{\\text{growth}}$。\n\n孔洞长大的方程源于塑性变形过程中基体体积的守恒。基体体积为 $V_m = V - V_v = V(1 - f)$。基体体积的变化率为：\n$$\n\\dot{V}_m = \\frac{d}{dt}[V(1-f)] = \\dot{V}(1-f) - V\\dot{f}\n$$\n问题陈述基体是塑性不可压缩的。这意味着基体材料的塑性体积变化为零。其体积只能弹性地改变。在延性断裂模型中，塑性应变通常远大于弹性应变，因此一个常见且有效的简化是假设材料为刚塑性，即忽略弹性应变。在此假设下，基体材料的总体积被认为是恒定的，因此 $\\dot{V}_m = 0$。\n在上述方程中令 $\\dot{V}_m = 0$ 可得：\n$$\n0 = \\dot{V}(1-f) - V\\dot{f}\n$$\n对 $\\dot{f}$ 进行整理，得到孔洞分数演化与 RVE 总体积应变率之间的关系：\n$$\n\\dot{f} = (1-f) \\frac{\\dot{V}}{V}\n$$\n项 $\\dot{V}/V$ 是总体积应变率 $\\mathrm{tr}(\\dot{\\boldsymbol{\\varepsilon}})$。我们需要将其与给定的塑性体积应变率 $\\mathrm{tr}(\\dot{\\boldsymbol{\\varepsilon}}^p)$ 联系起来。\n\nRVE 的总塑性体积变化率 $\\dot{V}^p$ 是已知的。因为基体是塑性不可压缩的，所有塑性体积变化必须来自孔洞体积的变化。即 $\\dot{V}^p = \\dot{V}_v$。\n在刚塑性假设下，弹性应变被忽略，因此总应变率等于塑性应变率：$\\dot{\\boldsymbol{\\varepsilon}} \\approx \\dot{\\boldsymbol{\\varepsilon}}^p$。这意味着总体积应变率等于塑性体积应变率：$\\dot{V}/V \\approx \\dot{V}^p/V$。\n将此代入我们关于 $\\dot{f}$ 的表达式中：\n$$\n\\dot{f} = (1-f) \\frac{\\dot{V}^p}{V}\n$$\n使用问题中的定义 $\\mathrm{tr}(\\dot{\\boldsymbol{\\varepsilon}}^p) = \\dot{V}^p/V$。因此，我们得到了孔洞长大的标准方程：\n$$\n\\dot{f} = (1-f) \\mathrm{tr}(\\dot{\\boldsymbol{\\varepsilon}}^p)\n$$\n这就是 $f(t)$ 的控制常微分方程 (ODE)。\n\n### 步骤 4：常微分方程的求解\n我们已知 $\\mathrm{tr}(\\dot{\\boldsymbol{\\varepsilon}}^p) = c$，其中 $c$ 是一个正常数。将此代入 ODE 中得到：\n$$\n\\frac{df}{dt} = c(1-f)\n$$\n这是一个一阶、线性、可分离的微分方程。我们可以分离变量 $f$ 和 $t$：\n$$\n\\frac{df}{1-f} = c \\, dt\n$$\n为了求特解，我们对两边从初始状态 $(t=0, f=f_0)$ 到一般状态 $(t, f(t))$ 进行积分：\n$$\n\\int_{f_0}^{f(t)} \\frac{1}{1-\\tilde{f}} \\, d\\tilde{f} = \\int_{0}^{t} c \\, d\\tau\n$$\n其中 $\\tilde{f}$ 和 $\\tau$ 是虚积分变量。\n\n计算积分：\n$$\n[-\\ln(1-\\tilde{f})]_{f_0}^{f(t)} = [c\\tau]_{0}^{t}\n$$\n请注意，由于 $0  f_0  1$ 且 $f(t)$ 代表一个必须小于 1 的物理体积分数，因此对数的参数 $1-\\tilde{f}$ 始终为正。\n$$\n-\\ln(1-f(t)) - (-\\ln(1-f_0)) = c(t-0)\n$$\n$$\n\\ln(1-f_0) - \\ln(1-f(t)) = ct\n$$\n使用对数的性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$：\n$$\n\\ln\\left(\\frac{1-f_0}{1-f(t)}\\right) = ct\n$$\n为了求解 $f(t)$，我们对两边取指数：\n$$\n\\frac{1-f_0}{1-f(t)} = \\exp(ct)\n$$\n现在，我们用代数方法分离出 $f(t)$：\n$$\n1-f(t) = \\frac{1-f_0}{\\exp(ct)} = (1-f_0)\\exp(-ct)\n$$\n$$\nf(t) = 1 - (1-f_0)\\exp(-ct)\n$$\n这就是孔洞体积分数随时间变化的闭式解析表达式。", "answer": "$$\n\\boxed{1 - (1 - f_0) \\exp(-ct)}\n$$", "id": "3559564"}, {"introduction": "在计算固体力学中，将理论与稳健的计算实践相结合是一项核心技能。这最后一个练习将处理在有限变形下实施孔隙演化定律时遇到的一个关键问题：材料坐标系无关性，也称为客观性。通过一项编程任务，你将探索如何使用诸如塑性变形梯度增量 $\\boldsymbol{F}_p^{\\text{inc}}$ 的行列式等坐标系无关的度量，来确保你的数值模型预测是物理上一致且独立于刚体转动的。[@problem_id:3559591]", "problem": "考虑一个使用 Gurson-Tvergaard-Needleman 型框架建模的韧性固体，其中孔隙度 $f$ 因塑性体积变形而演化。在包含有限转动的算法环境中，必须实现一个客观的孔隙度演化律，该演化律仅依赖于塑性膨胀的标架不变度量。您的任务是设计并实现一个程序，该程序使用两种等效的塑性体积变化客观度量来更新一个增量步内的孔隙度 $f$，并通过数值方法验证在叠加刚体转动下的标架不变性。\n\n从适用于计算固体力学的基本运动学和连续介质力学原理出发。利用变形的乘法分解和材料标架无关性（客观性）要求，构建一个在叠加刚体转动下保持不变的演化更新方法。待使用的两种客观度量是：\n- 从增量塑性变形梯度中提取的无转动体积度量，具体是基于塑性增量雅可比的对数体积应变。\n- 相对于当前塑性体积 $V^p$ 的增量塑性体积变化 $\\Delta V^p$，其表达方式在任意有限转动下保持客观性。\n\n您必须在程序中实现两个函数：\n- 一个函数，它接受初始孔隙度 $f_n$ 和增量塑性变形梯度 $\\boldsymbol{F}_p^{\\text{inc}}$ 作为输入，并基于塑性膨胀的对数体积度量返回更新后的孔隙度 $f_{n+1}$。该实现必须是客观的，即如果 $\\boldsymbol{F}_p^{\\text{inc}}$ 被任意正常正交转动 $\\boldsymbol{R}$ 左乘，返回的 $f_{n+1}$ 必须保持不变。\n- 一个函数，它接受初始孔隙度 $f_n$、当前塑性体积 $V_n^p$ 和增量塑性体积变化 $\\Delta V^p$ 作为输入，并以符合客观性的方式仅使用比率 $\\Delta V^p / V_n^p$ 返回更新后的孔隙度 $f_{n+1}$。\n\n我们将为您提供一套参数值的测试套件。对于旋转矩阵，请使用以弧度为单位指定的角度。孔隙度是无量纲的。体积 $V_n^p$ 和 $\\Delta V^p$ 可以使用一致的任意单位处理；所有输出均为无量纲。程序必须计算每个测试用例的更新孔隙度，并返回布尔值，指示在数值容差内是否满足旋转不变性。\n\n待使用的测试套件是：\n- 测试用例 1 (对数体积法，无转动)：$f_n = 0.02$，$\\boldsymbol{F}_p^{\\text{inc}} = \\mathrm{diag}(1.02,\\,1.01,\\,0.98)$。\n- 测试用例 2 (对数体积法，旋转不变性)：与测试用例 1 相同的 $f_n$ 和 $\\boldsymbol{F}_p^{\\text{inc}}$，但叠加了一个绕 $z$ 轴的刚体转动，转角 $\\theta = 0.75$ 弧度。如果旋转下的更新孔隙度与未旋转结果在容差 $\\tau = 10^{-12}$ 内相等，则返回布尔值 $true$，否则返回 $false$。\n- 测试用例 3 (对数体积法，等体积塑性增量)：$f_n = 0.05$，$\\boldsymbol{F}_p^{\\text{inc}} = \\mathrm{diag}(1.1,\\,0.9,\\,1/(1.1\\cdot 0.9))$。\n- 测试用例 4 (增量体积法，塑性膨胀)：$f_n = 0.01$，$V_n^p = 1.00$，$\\Delta V^p = 0.05$。\n- 测试用例 5 (增量体积法，塑性压缩)：$f_n = 0.03$，$V_n^p = 1.00$，$\\Delta V^p = -0.02$。\n- 测试用例 6 (对数体积法，第二次旋转不变性)：$f_n = 0.025$，$\\boldsymbol{F}_p^{\\text{inc}} = \\mathrm{diag}(1.05,\\,1.00,\\,0.97)$；比较未旋转更新与叠加绕 $z$ 轴转动 $\\theta = \\pi/3$ 弧度的刚体转动下的更新，如果不变性在容差 $\\tau = 10^{-12}$ 内成立，则返回布尔值 $true$，否则返回 $false$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按 $[r_1, r_2, r_3, r_4, r_5, r_6]$ 的顺序排列，其中 $r_1$、$r_3$、$r_4$ 和 $r_5$ 分别是测试用例 1、3、4 和 5 的更新孔隙度的浮点数值，$r_2$ 和 $r_6$ 是对应于测试用例 2 和 6 的旋转不变性检查的布尔值。", "solution": "用户要求编写一个程序来计算韧性材料中孔隙度的演化，并验证所选算法更新的标架无关性。该模型基于 Gurson-Tvergaard-Needleman (GTN) 框架，其中孔隙度演化与塑性变形耦合。该问题提法明确且科学上合理，其基础是连续介质力学和有限变形计算塑性力学的原理。\n\n### 理论基础：孔隙度演化\n\n韧性材料中空洞体积分数（即孔隙度 $f$）的演化主要由塑性变形的体积部分驱动。孔隙度的变化率通常表示为：\n$$\n\\dot{f} = \\dot{f}_{\\text{growth}} + \\dot{f}_{\\text{nucleation}}\n$$\n本问题关注增长部分，其由标准关系式给出：\n$$\n\\dot{f}_{\\text{growth}} = (1-f) \\text{tr}(\\boldsymbol{D}_p)\n$$\n其中 $\\boldsymbol{D}_p$ 是塑性变形率张量，$\\text{tr}(\\boldsymbol{D}_p)$ 表示单位当前体积的塑性体积变化率。$(1-f)$ 项说明体积变化仅发生在未损伤的基体材料中。\n\n### 增量更新公式\n\n对于数值实现，必须将速率方程在一个有限时间增量（从时间 $t_n$ 到 $t_{n+1}$）上进行积分。\n$$\n\\frac{df}{dt} = (1-f) \\text{tr}(\\boldsymbol{D}_p)\n$$\n分离变量并积分，得到：\n$$\n\\int_{f_n}^{f_{n+1}} \\frac{df}{1-f} = \\int_{t_n}^{t_{n+1}} \\text{tr}(\\boldsymbol{D}_p) dt\n$$\n右侧的积分表示在该增量上累积的总塑性体积应变，记为 $\\Delta \\epsilon_p^v$。\n$$\n[-\\ln(1-f)]_{f_n}^{f_{n+1}} = \\Delta \\epsilon_p^v\n$$\n$$\n\\ln(1-f_n) - \\ln(1-f_{n+1}) = \\Delta \\epsilon_p^v\n$$\n求解更新后的孔隙度 $f_{n+1}$：\n$$\n\\ln(1-f_{n+1}) = \\ln(1-f_n) - \\Delta \\epsilon_p^v\n$$\n$$\n1-f_{n+1} = \\exp(\\ln(1-f_n) - \\Delta \\epsilon_p^v) = (1-f_n)\\exp(-\\Delta \\epsilon_p^v)\n$$\n这导出了最终的更新公式：\n$$\nf_{n+1} = 1 - (1-f_n)\\exp(-\\Delta \\epsilon_p^v)\n$$\n问题的核心在于以一种客观（标架无关）的方式定义增量塑性体积应变 $\\Delta \\epsilon_p^v$。\n\n### 增量塑性体积应变的客观度量\n\n材料标架无关性原理要求本构律独立于观察者的参考系。这意味着叠加的刚体运动不应影响材料的本构响应，包括孔隙度等内部状态变量的演化。\n\n该问题要求实现两种等效的 $\\Delta \\epsilon_p^v$ 客观度量。\n\n**1. 从增量塑性变形梯度 $\\boldsymbol{F}_p^{\\text{inc}}$ 得到的对数应变**\n\n在有限变形运动学中，变形梯度 $\\boldsymbol{F}$ 是乘法更新的。塑性部分遵循 $\\boldsymbol{F}_{p, n+1} = \\boldsymbol{F}_p^{\\text{inc}} \\boldsymbol{F}_{p, n}$。塑性体积的增量变化由增量塑性变形梯度的行列式 $J_p^{\\text{inc}} = \\det(\\boldsymbol{F}_p^{\\text{inc}})$ 捕获。一种鲁棒且客观的体积应变度量是对数应变：\n$$\n\\Delta \\epsilon_p^v = \\ln(J_p^{\\text{inc}}) = \\ln(\\det(\\boldsymbol{F}_p^{\\text{inc}}))\n$$\n该度量本质上是客观的。叠加一个刚体转动 $\\boldsymbol{R}$ 会将变形梯度变换为 $\\boldsymbol{R}\\boldsymbol{F}_p^{\\text{inc}}$。由于 $\\boldsymbol{R}$ 是正常正交张量，其行列式为 $\\det(\\boldsymbol{R}) = 1$。新的雅可比为：\n$$\n\\det(\\boldsymbol{R}\\boldsymbol{F}_p^{\\text{inc}}) = \\det(\\boldsymbol{R})\\det(\\boldsymbol{F}_p^{\\text{inc}}) = 1 \\cdot J_p^{\\text{inc}} = J_p^{\\text{inc}}\n$$\n雅可比，以及因此的 $\\Delta \\epsilon_p^v$ 和最终的 $f_{n+1}$，在这种变换下是不变的。这证实了该公式的客观性。\n\n对于等体积（体积保持）塑性增量，$\\det(\\boldsymbol{F}_p^{\\text{inc}}) = 1$，这使得 $\\Delta \\epsilon_p^v = \\ln(1) = 0$。因此，$f_{n+1} = 1 - (1-f_n)\\exp(0) = f_n$，正确地显示孔隙度没有变化。\n\n**2. 从增量体积变化率得到的应变**\n\n该方法从物理上直观的标量量出发：当前塑性体积 $V_n^p$ 和增量塑性体积变化 $\\Delta V^p$。变形梯度与体积变化之间的关系是 $V_{n+1}^p = \\det(\\boldsymbol{F}_p^{\\text{inc}}) V_n^p = J_p^{\\text{inc}} V_n^p$。\n增量变化定义为 $\\Delta V^p = V_{n+1}^p - V_n^p$。因此：\n$$\n\\frac{\\Delta V^p}{V_n^p} = \\frac{V_{n+1}^p - V_n^p}{V_n^p} = \\frac{V_{n+1}^p}{V_n^p} - 1 = J_p^{\\text{inc}} - 1\n$$\n这给出 $J_p^{\\text{inc}} = 1 + \\Delta V^p / V_n^p$。\n将此代入对数应变定义：\n$$\n\\Delta \\epsilon_p^v = \\ln(J_p^{\\text{inc}}) = \\ln\\left(1 + \\frac{\\Delta V^p}{V_n^p}\\right)\n$$\n由于体积是标量，它本质上是标架无关的。因此，此公式也是客观的，并且与第一种方法完全一致。\n\n### 算法实现\n\n解决方案将使用 Python 和 `numpy` 库进行线性代数运算来实现。\n将按规定创建两个函数：\n- `update_porosity_log_strain(f_n, F_p_inc)`：此函数计算 $\\det(\\boldsymbol{F}_p^{\\text{inc}})$，然后计算 $\\Delta \\epsilon_p^v = \\ln(\\det(\\boldsymbol{F}_p^{\\text{inc}}))$，并使用推导出的公式 $f_{n+1} = 1 - (1-f_n)\\exp(-\\Delta \\epsilon_p^v)$ 返回更新后的孔隙度。\n- `update_porosity_vol_ratio(f_n, V_n_p, delta_V_p)`：此函数计算 $\\Delta \\epsilon_p^v = \\ln(1 + \\Delta V^p / V_n^p)$ 并使用相同的公式返回更新后的孔隙度。\n\n对于不变性检查，将构建一个绕 z 轴旋转角度 $\\theta$ 的旋转矩阵 $\\boldsymbol{R}$：\n$$\n\\boldsymbol{R}_z(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta  0 \\\\ \\sin\\theta  \\cos\\theta  0 \\\\ 0  0  1 \\end{pmatrix}\n$$\n将对未旋转的变形梯度 $\\boldsymbol{F}_p^{\\text{inc}}$ 和旋转后的变形梯度 $\\boldsymbol{R}_z(\\theta)\\boldsymbol{F}_p^{\\text{inc}}$ 计算孔隙度更新。结果将被比较，以在指定的数值容差 $\\tau = 10^{-12}$ 内证明不变性。\n将使用这些函数系统地评估所提供的测试用例，以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef update_porosity_log_strain(f_n: float, F_p_inc: np.ndarray) - float:\n    \"\"\"\n    Updates porosity based on a logarithmic volumetric measure from the\n    incremental plastic deformation gradient.\n    \n    Args:\n        f_n: Initial porosity at step n.\n        F_p_inc: Incremental plastic deformation gradient (3x3 numpy array).\n    \n    Returns:\n        Updated porosity f_{n+1}.\n    \"\"\"\n    # The Jacobian of the incremental plastic deformation gradient\n    J_p_inc = np.linalg.det(F_p_inc)\n    \n    # The incremental plastic volumetric strain is the natural logarithm of the Jacobian.\n    # This is an objective (frame-invariant) scalar measure.\n    delta_epsilon_p_v = np.log(J_p_inc)\n    \n    # Integrate the porosity evolution equation: df/dt = (1-f) * tr(D_p)\n    # This leads to the update formula: f_{n+1} = 1 - (1-f_n)*exp(-delta_epsilon_p_v)\n    f_np1 = 1.0 - (1.0 - f_n) * np.exp(-delta_epsilon_p_v)\n    \n    return f_np1\n\ndef update_porosity_vol_ratio(f_n: float, V_n_p: float, delta_V_p: float) - float:\n    \"\"\"\n    Updates porosity based on the ratio of incremental plastic volume change\n    to the current plastic volume.\n    \n    Args:\n        f_n: Initial porosity at step n.\n        V_n_p: Current plastic volume.\n        delta_V_p: Incremental change in plastic volume.\n    \n    Returns:\n        Updated porosity f_{n+1}.\n    \"\"\"\n    if V_n_p = 0:\n        raise ValueError(\"Current plastic volume V_n_p must be positive.\")\n    if V_n_p + delta_V_p = 0:\n        raise ValueError(\"Resulting plastic volume must be positive.\")\n        \n    # The Jacobian is equivalent to the ratio of new volume to old volume.\n    # J_p_inc = V_{n+1}^p / V_n^p = (V_n^p + delta_V_p) / V_n_p = 1 + delta_V_p / V_n_p\n    # Volumes are scalars and inherently objective.\n    J_p_inc = 1.0 + delta_V_p / V_n_p\n    \n    # The incremental plastic volumetric strain\n    delta_epsilon_p_v = np.log(J_p_inc)\n    \n    # Same update formula as the other method\n    f_np1 = 1.0 - (1.0 - f_n) * np.exp(-delta_epsilon_p_v)\n    \n    return f_np1\n\ndef solve():\n    \"\"\"\n    Runs the test suite for porosity updates and frame invariance checks.\n    \"\"\"\n    results = []\n    \n    # --- Test Case 1 ---\n    # Logarithmic-volumetric method, no rotation\n    f_n1 = 0.02\n    F_p_inc1 = np.diag([1.02, 1.01, 0.98])\n    r1 = update_porosity_log_strain(f_n1, F_p_inc1)\n    results.append(r1)\n    \n    # --- Test Case 2 ---\n    # Logarithmic-volumetric method, rotation invariance check\n    theta2 = 0.75  # radians\n    c, s = np.cos(theta2), np.sin(theta2)\n    R2 = np.array([[c, -s, 0.0], [s, c, 0.0], [0.0, 0.0, 1.0]])\n    F_p_inc2_rot = R2 @ F_p_inc1\n    f_np1_rot2 = update_porosity_log_strain(f_n1, F_p_inc2_rot)\n    \n    tolerance = 1e-12\n    r2 = np.abs(f_np1_rot2 - r1) = tolerance\n    results.append(str(r2).lower())\n\n    # --- Test Case 3 ---\n    # Logarithmic-volumetric method, isochoric plastic increment\n    f_n3 = 0.05\n    val = 1.0 / (1.1 * 0.9)\n    F_p_inc3 = np.diag([1.1, 0.9, val])\n    r3 = update_porosity_log_strain(f_n3, F_p_inc3)\n    results.append(r3)\n\n    # --- Test Case 4 ---\n    # Incremental volume method, plastic dilatation\n    f_n4 = 0.01\n    V_n_p4 = 1.00\n    delta_V_p4 = 0.05\n    r4 = update_porosity_vol_ratio(f_n4, V_n_p4, delta_V_p4)\n    results.append(r4)\n\n    # --- Test Case 5 ---\n    # Incremental volume method, plastic compaction\n    f_n5 = 0.03\n    V_n_p5 = 1.00\n    delta_V_p5 = -0.02\n    r5 = update_porosity_vol_ratio(f_n5, V_n_p5, delta_V_p5)\n    results.append(r5)\n\n    # --- Test Case 6 ---\n    # Logarithmic-volumetric method, second rotation invariance check\n    f_n6 = 0.025\n    F_p_inc6 = np.diag([1.05, 1.00, 0.97])\n    \n    f_np1_unrot6 = update_porosity_log_strain(f_n6, F_p_inc6)\n    \n    theta6 = np.pi / 3.0  # radians\n    c, s = np.cos(theta6), np.sin(theta6)\n    R6 = np.array([[c, -s, 0.0], [s, c, 0.0], [0.0, 0.0, 1.0]])\n    F_p_inc6_rot = R6 @ F_p_inc6\n    f_np1_rot6 = update_porosity_log_strain(f_n6, F_p_inc6_rot)\n    \n    r6 = np.abs(f_np1_rot6 - f_np1_unrot6) = tolerance\n    results.append(str(r6).lower())\n\n    # Final print statement in the exact required format.\n    # str(bool) gives 'True'/'False', which is acceptable for boolean representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3559591"}]}