{"hands_on_practices": [{"introduction": "在PIC方法中，首要步骤是将离散的粒子信息“分配”到网格上。本练习旨在通过比较最近邻网格点(NGP)和云中单元(CIC)这两种电荷分配方案，来探索这一过程的数值特性。通过计算离散高斯定律的残差，您将亲手量化不同方案在维持物理守恒律方面的精度差异，这是理解和评估PIC算法保真度的关键一步。[@problem_id:3310354]", "problem": "给定一个均匀的三维笛卡尔网格和一个点电荷。本题的目标是比较粒子模拟（PIC）方法中使用的两种电荷分配方案——最近单元分配法和单元云分配法——并评估两种方案在网格上产生的离散高斯定律误差，以 $L^2$ 范数和最大范数进行评估。评估必须通过以下方式执行：首先，使用点电荷的连续库仑电场计算通过每个单元闭合表面的近似电通量；然后，将该基于通量的闭合电荷与每种方案下每个单元的分配电荷进行比较。使用归一化单位，其中真空介电常数设为1，即 $\\varepsilon_0 = 1$，单位电荷 $q = 1$，因此所有输出都是无物理单位的无量纲浮点数。\n\n基本原理：静电学形式的麦克斯韦方程组要求电场的散度等于电荷密度除以真空介电常数，即微分形式的高斯定律 $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$。其积分形式断言，通过任何闭合曲面的电通量等于该曲面内包含的总电荷除以真空介电常数，即 $\\oint_{\\partial V} \\mathbf{E} \\cdot \\mathrm{d}\\mathbf{A} = Q_{\\mathrm{enc}} / \\varepsilon_0$。在自由空间中，点电荷的静电场为 $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi \\varepsilon_0) \\right) q \\, (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$。\n\n离散设置与近似：\n- 网格：设计算域为矩形盒子 $[0, L_x] \\times [0, L_y] \\times [0, L_z]$，被划分为 $N_x \\times N_y \\times N_z$ 个均匀单元，间距为 $h_x = L_x/N_x$，$h_y = L_y/N_y$，$h_z = L_z/N_z$。单元索引为 $(i,j,k)$，其中 $i \\in \\{0,\\dots,N_x-1\\}$，$j \\in \\{0,\\dots,N_y-1\\}$，$k \\in \\{0,\\dots,N_z-1\\}$。单元 $(i,j,k)$ 的中心坐标为 $(x_i, y_j, z_k) = \\left((i + 0.5) h_x, (j + 0.5) h_y, (k + 0.5) h_z\\right)$。\n- 电通量近似：对于每个单元 $(i,j,k)$，使用面上的中点法则来近似通过其闭合表面的净电通量。六个面的中心分别是：\n  - 左面中心位于 $\\left(i h_x, (j+0.5) h_y, (k+0.5) h_z\\right)$，外法线为 $\\mathbf{n}_x^- = (-1,0,0)$，面积为 $A_x = h_y h_z$，\n  - 右面中心位于 $\\left((i+1) h_x, (j+0.5) h_y, (k+0.5) h_z\\right)$，外法线为 $\\mathbf{n}_x^+ = (1,0,0)$，面积为 $A_x = h_y h_z$，\n  - 底面中心位于 $\\left((i+0.5) h_x, j h_y, (k+0.5) h_z\\right)$，外法线为 $\\mathbf{n}_y^- = (0,-1,0)$，面积为 $A_y = h_x h_z$，\n  - 顶面中心位于 $\\left((i+0.5) h_x, (j+1) h_y, (k+0.5) h_z\\right)$，外法线为 $\\mathbf{n}_y^+ = (0,1,0)$，面积为 $A_y = h_x h_z$，\n  - 后面中心位于 $\\left((i+0.5) h_x, (j+0.5) h_y, k h_z\\right)$，外法线为 $\\mathbf{n}_z^- = (0,0,-1)$，面积为 $A_z = h_x h_y$，\n  - 前面中心位于 $\\left((i+0.5) h_x, (j+0.5) h_y, (k+1) h_z\\right)$，外法线为 $\\mathbf{n}_z^+ = (0,0,1)$，面积为 $A_z = h_x h_y$。\n  使用点电荷的连续库仑场，记 $\\mathbf{E}_{\\mathrm{face}}$ 为在相应面中心处计算的场。近似的净通量则为\n  $$\\Phi_{i,j,k} \\approx A_x \\left(\\mathbf{E}_{\\mathrm{right}} \\cdot \\mathbf{n}_x^+\\right) + A_x \\left(\\mathbf{E}_{\\mathrm{left}} \\cdot \\mathbf{n}_x^-\\right) + A_y \\left(\\mathbf{E}_{\\mathrm{top}} \\cdot \\mathbf{n}_y^+\\right) + A_y \\left(\\mathbf{E}_{\\mathrm{bottom}} \\cdot \\mathbf{n}_y^-\\right) + A_z \\left(\\mathbf{E}_{\\mathrm{front}} \\cdot \\mathbf{n}_z^+\\right) + A_z \\left(\\mathbf{E}_{\\mathrm{back}} \\cdot \\mathbf{n}_z^-\\right)。$$\n- 最近单元分配法 (NGP)：将全部电荷 $q$ 分配到包含点电荷坐标 $\\mathbf{r}_0 = (x_0,y_0,z_0)$ 的单个单元中。也就是说，如果 $i^\\ast = \\lfloor x_0/h_x \\rfloor$，$j^\\ast = \\lfloor y_0/h_y \\rfloor$，$k^\\ast = \\lfloor z_0/h_z \\rfloor$，那么单元 $(i,j,k)$ 的分配电荷为\n  $$Q^{\\mathrm{NGP}}_{i,j,k} = \\begin{cases} q,  \\text{若 } (i,j,k) = (i^\\ast,j^\\ast,k^\\ast), \\\\ 0,  \\text{其他情况。} \\end{cases}$$\n- 单元云分配法 (CIC)：通过三线性权重，将电荷 $q$ 分配到沿各轴紧邻点位置 $\\mathbf{r}_0$ 的 $2 \\times 2 \\times 2$ 单元块中。设 $i_0 = \\left\\lfloor x_0/h_x - 0.5 \\right\\rfloor$，$j_0 = \\left\\lfloor y_0/h_y - 0.5 \\right\\rfloor$，$k_0 = \\left\\lfloor z_0/h_z - 0.5 \\right\\rfloor$，并进行钳位以使 $i_0 \\in \\{0,\\dots,N_x-2\\}$，$j_0 \\in \\{0,\\dots,N_y-2\\}$，$k_0 \\in \\{0,\\dots,N_z-2\\}$。在包围的单元中心段内定义局部小数坐标为 $s_x = x_0/h_x - (i_0 + 0.5)$，$s_y = y_0/h_y - (j_0 + 0.5)$，$s_z = z_0/h_z - (k_0 + 0.5)$，每个坐标都在 $[0,1)$ 区间内。对于 $a,b,c \\in \\{0,1\\}$ 的八个单元 $(i_0 + a, j_0 + b, k_0 + c)$ 的权重为 $w_{a,b,c} = \\left(a s_x + (1-a)(1 - s_x)\\right) \\left(b s_y + (1-b)(1 - s_y)\\right) \\left(c s_z + (1-c)(1 - s_z)\\right)$，归一化后使得 $\\sum_{a,b,c} w_{a,b,c} = 1$。分配的电荷为 $Q^{\\mathrm{CIC}}_{i_0+a,j_0+b,k_0+c} = q \\, w_{a,b,c}$，其他单元为零。\n\n每个单元的离散高斯定律误差：对于每种分配方案 $\\mathcal{D} \\in \\{\\mathrm{NGP}, \\mathrm{CIC}\\}$，将每个单元的误差定义为近似的基于通量的闭合电荷与分配电荷之差，\n$$\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}/\\varepsilon_0.$$\n在归一化单位下，$\\varepsilon_0 = 1$ 且 $q = 1$，这简化为 $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}$。对每种分配方案，计算所有单元上误差的全局 $L^2$ 范数和最大范数：\n$$\\|\\mathcal{E}^{\\mathcal{D}}\\|_{2} = \\sqrt{\\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\sum_{k=0}^{N_z-1} \\left(\\mathcal{E}^{\\mathcal{D}}_{i,j,k}\\right)^2}, \\quad \\|\\mathcal{E}^{\\mathcal{D}}\\|_{\\infty} = \\max_{i,j,k} \\left| \\mathcal{E}^{\\mathcal{D}}_{i,j,k} \\right|.$$\n\n实现细节：\n- 使用连续库仑场 $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi \\varepsilon_0)\\right) q (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$，其中 $\\varepsilon_0 = 1$ 且 $q = 1$，因此 $\\mathbf{E}(\\mathbf{r}) = \\left(1/(4 \\pi)\\right) (\\mathbf{r} - \\mathbf{r}_0)/\\|\\mathbf{r} - \\mathbf{r}_0\\|^3$。\n- 如上所述，在每个面中心使用中点法则来近似通量。\n- 确保点电荷位置不与任何面中心精确重合，以防止奇异值计算。在所有给定的测试用例中，位置都已相应选择。\n\n测试套件：\n为以下每个测试用例，计算最近单元分配法和单元云分配法的 $(L^2, \\text{max})$ 误差范数。所有位置和长度单位均为米，但请记住 $\\varepsilon_0 = 1$ 且 $q = 1$，因此输出是无量纲的浮点数。\n1.  案例1：$N_x = 24$, $N_y = 22$, $N_z = 20$, $L_x = 1.2$, $L_y = 1.2$, $L_z = 1.2$，点电荷位于 $(x_0, y_0, z_0) = (0.53, 0.47, 0.41)$。\n2.  案例2：$N_x = 12$, $N_y = 10$, $N_z = 8$, $L_x = 1.0$, $L_y = 1.0$, $L_z = 1.0$，点电荷位于 $(x_0, y_0, z_0) = (0.05, 0.92, 0.13)$。\n3.  案例3：$N_x = 18$, $N_y = 18$, $N_z = 18$, $L_x = 0.9$, $L_y = 0.9$, $L_z = 0.9$，点电荷位于 $(x_0, y_0, z_0) = (0.275, 0.225, 0.275)$。\n4.  案例4：$N_x = 6$, $N_y = 6$, $N_z = 6$, $L_x = 1.0$, $L_y = 1.0$, $L_z = 1.0$，点电荷位于 $(x_0, y_0, z_0) = (0.37, 0.58, 0.41)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个案例，按以下顺序附加四个值：最近单元分配法的 $L^2$ 误差，最近单元分配法的最大误差，单元云分配法的 $L^2$ 误差，单元云分配法的最大误差。将这四个案例的四元组连接起来，形成一个扁平列表。例如，输出格式必须完全是\n$$[\\text{case1\\_L2\\_NGP},\\text{case1\\_Max\\_NGP},\\text{case1\\_L2\\_CIC},\\text{case1\\_Max\\_CIC},\\text{case2\\_L2\\_NGP},\\dots,\\text{case4\\_Max\\_CIC}].$$", "solution": "该问题要求对计算电磁学中两种常见的电荷分配方案，即最近单元分配法（也称为最近格点法，NGP）和单元云分配法（CIC），通过评估离散形式高斯定律的误差来进行定量比较。\n\n此分析的基础是积分形式的高斯定律，该定律指出通过闭合曲面 $\\partial V$ 的净电通量 $\\Phi$ 与该曲面所包围的体积 $V$ 内的总电荷 $Q_{\\mathrm{enc}}$ 成正比：\n$$ \\oint_{\\partial V} \\mathbf{E} \\cdot \\mathrm{d}\\mathbf{A} = \\frac{Q_{\\mathrm{enc}}}{\\varepsilon_0} $$\n对于此问题，我们在真空中给定一个位于位置 $\\mathbf{r}_0$ 的点电荷 $q$。电场由库仑定律给出：\n$$ \\mathbf{E}(\\mathbf{r}) = \\frac{q}{4 \\pi \\varepsilon_0} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\|\\mathbf{r} - \\mathbf{r}_0\\|^3} $$\n根据指定的归一化条件 $q=1$ 和 $\\varepsilon_0=1$，该式简化为：\n$$ \\mathbf{E}(\\mathbf{r}) = \\frac{1}{4 \\pi} \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\|\\mathbf{r} - \\mathbf{r}_0\\|^3} $$\n核心思想是，对于笛卡尔网格中的每个单元，计算两个不同版本的闭合电荷：\n1.  一个“基于通量”的电荷，$Q_{\\mathrm{flux}}$，通过数值近似计算单元边界上的通量积分 $\\Phi_{i,j,k}$ 并利用高斯定律得出：$Q_{\\mathrm{flux}, i,j,k} = \\varepsilon_0 \\Phi_{i,j,k}$。\n2.  一个“分配”的电荷，$Q^{\\mathcal{D}}_{i,j,k}$，通过应用电荷分配方案 $\\mathcal{D} \\in \\{\\mathrm{NGP}, \\mathrm{CIC}\\}$ 获得。\n\n这两个量之间的差异 $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}/\\varepsilon_0$ 代表了满足高斯定律的局部误差。根据我们的归一化，这简化为 $\\mathcal{E}^{\\mathcal{D}}_{i,j,k} = \\Phi_{i,j,k} - Q^{\\mathcal{D}}_{i,j,k}$。然后我们使用 $L^2$ 范数和最大范数量化全局误差。\n\n对于每个测试用例，算法流程如下：\n\n1.  **网格和参数初始化**：对于给定尺寸为 $L_x \\times L_y \\times L_z$ 的域和 $N_x \\times N_y \\times N_z$ 个单元的网格，我们计算单元间距 $h_x = L_x/N_x$，$h_y = L_y/N_y$ 和 $h_z = L_z/N_z$。点电荷 $q=1$ 位于 $\\mathbf{r}_0 = (x_0, y_0, z_0)$。\n\n2.  **电荷分配**：我们计算两种方案下分配到每个单元 $(i,j,k)$ 的电荷。\n    *   **NGP 方案**：我们找到包含 $\\mathbf{r}_0$ 的单元索引 $(i^\\ast, j^\\ast, k^\\ast)$，其中 $i^\\ast = \\lfloor x_0/h_x \\rfloor$，$j^\\ast = \\lfloor y_0/h_y \\rfloor$，$k^\\ast = \\lfloor z_0/h_z \\rfloor$。全部电荷 $q=1$ 都分配给这个单元。所有其他单元接收的电荷为零。这样创建了一个 $N_x \\times N_y \\times N_z$ 的数组 $Q^{\\mathrm{NGP}}$。\n    *   **CIC 方案**：该方案将电荷分布到其中心包围粒子位置的 8 个单元中。我们首先找到这个 $2 \\times 2 \\times 2$ 单元块的基准索引：$i_0 = \\lfloor x_0/h_x - 0.5 \\rfloor$，$j_0 = \\lfloor y_0/h_y - 0.5 \\rfloor$，$k_0 = \\lfloor z_0/h_z - 0.5 \\rfloor$，确保这些索引被钳位以使该块保持在网格边界内。然后，我们计算粒子相对于基准单元中心的小数距离：$s_x = x_0/h_x - (i_0 + 0.5)$，$s_y = y_0/h_y - (j_0 + 0.5)$ 和 $s_z = z_0/h_z - (k_0 + 0.5)$。使用三线性插值权重，将电荷分配给 $a,b,c \\in \\{0,1\\}$ 的 8 个单元 $(i_0+a, j_0+b, k_0+c)$。这样创建了一个电荷数组 $Q^{\\mathrm{CIC}}$。\n\n3.  **数值通量计算**：我们计算通过每个单元边界的电通量。问题指定了中点法则近似。对于每个单元 $(i,j,k)$，净通量 $\\Phi_{i,j,k}$ 是通过其六个面的通量之和。\n    $$ \\Phi_{i,j,k} \\approx \\sum_{\\text{faces } f} \\mathbf{E}(\\mathbf{r}_f) \\cdot \\mathbf{n}_f A_f $$\n    其中 $\\mathbf{r}_f$ 是面的中心，$\\mathbf{n}_f$ 是其向外的法向量，$A_f$ 是其面积。例如，对于“右”面（$x$ 恒定，最大值），$\\mathbf{r}_f = ((i+1)h_x, (j+0.5)h_y, (k+0.5)h_z)$，$\\mathbf{n}_f = (1,0,0)$，$A_f = h_y h_z$。\n    为了高效实现这一点，我们利用向量化。我们生成代表所有单元索引 $(i,j,k)$ 坐标的三维数组。从这些数组中，我们计算所有六种面类型（例如，所有“左”面，所有“右”面等）中心点的坐标数组。然后，我们在这六个面中心网格上计算电场矢量的分量。与各自的法向量进行点积并乘以面面积，得到六个部分通量的三维数组。将这六个数组相加，得到最终的三维数组 $\\Phi$，其中 $\\Phi_{i,j,k}$ 是流出单元 $(i,j,k)$ 的总近似通量。\n\n4.  **误差计算和范数**：有了通量数组 $\\Phi$ 和电荷数组 $Q^{\\mathrm{NGP}}$、$Q^{\\mathrm{CIC}}$，我们为每种方案计算误差数组：\n    $$ \\mathcal{E}^{\\mathrm{NGP}} = \\Phi - Q^{\\mathrm{NGP}} $$\n    $$ \\mathcal{E}^{\\mathrm{CIC}} = \\Phi - Q^{\\mathrm{CIC}} $$\n    最后，我们为每个误差数组计算 $L^2$ 范数和最大（$L^\\infty$）范数：\n    $$ \\|\\mathcal{E}^{\\mathcal{D}}\\|_{2} = \\sqrt{\\sum_{i,j,k} (\\mathcal{E}^{\\mathcal{D}}_{i,j,k})^2} $$\n    $$ \\|\\mathcal{E}^{\\mathcal{D}}\\|_{\\infty} = \\max_{i,j,k} |\\mathcal{E}^{\\mathcal{D}}_{i,j,k}| $$\n    为每个测试用例计算这四个标量值（两种方案的两种范数），并附加到最终结果列表中。对问题陈述中提供的所有案例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the results.\n    \"\"\"\n\n    test_cases = [\n        # (Nx, Ny, Nz, Lx, Ly, Lz, (x0, y0, z0))\n        (24, 22, 20, 1.2, 1.2, 1.2, (0.53, 0.47, 0.41)),\n        (12, 10, 8, 1.0, 1.0, 1.0, (0.05, 0.92, 0.13)),\n        (18, 18, 18, 0.9, 0.9, 0.9, (0.275, 0.225, 0.275)),\n        (6, 6, 6, 1.0, 1.0, 1.0, (0.37, 0.58, 0.41)),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = calculate_errors_for_case(case)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_errors_for_case(case_params):\n    \"\"\"\n    Calculates the L2 and max errors for NGP and CIC schemes for a single test case.\n    \"\"\"\n    Nx, Ny, Nz, Lx, Ly, Lz, r0 = case_params\n    r0 = np.array(r0)\n    q = 1.0\n    eps0 = 1.0\n\n    hx, hy, hz = Lx / Nx, Ly / Ny, Lz / Nz\n    h = np.array([hx, hy, hz])\n    Ax, Ay, Az = hy * hz, hx * hz, hx * hy\n\n    # --- Charge Deposition ---\n\n    # NGP (Nearest-Cell Deposition)\n    Q_ngp = np.zeros((Nx, Ny, Nz))\n    i_star = int(np.floor(r0[0] / hx))\n    j_star = int(np.floor(r0[1] / hy))\n    k_star = int(np.floor(r0[2] / hz))\n    if 0 = i_star  Nx and 0 = j_star  Ny and 0 = k_star  Nz:\n        Q_ngp[i_star, j_star, k_star] = q\n\n    # CIC (Cloud-in-Cell)\n    Q_cic = np.zeros((Nx, Ny, Nz))\n    # Base cell index for the 2x2x2 cloud\n    i0 = int(np.floor(r0[0] / hx - 0.5))\n    j0 = int(np.floor(r0[1] / hy - 0.5))\n    k0 = int(np.floor(r0[2] / hz - 0.5))\n\n    # Clamp indices to ensure the 2x2x2 stencil is within the grid\n    i0 = np.clip(i0, 0, Nx - 2)\n    j0 = np.clip(j0, 0, Ny - 2)\n    k0 = np.clip(k0, 0, Nz - 2)\n\n    # Fractional coordinates relative to the base cell center\n    sx = r0[0] / hx - (i0 + 0.5)\n    sy = r0[1] / hy - (j0 + 0.5)\n    sz = r0[2] / hz - (k0 + 0.5)\n\n    # Trilinear weights\n    wx = [1 - sx, sx]\n    wy = [1 - sy, sy]\n    wz = [1 - sz, sz]\n\n    for a in range(2):\n        for b in range(2):\n            for c in range(2):\n                weight = wx[a] * wy[b] * wz[c]\n                Q_cic[i0 + a, j0 + b, k0 + c] = q * weight\n    \n    # --- Electric Field and Flux Calculation ---\n    \n    i_idx, j_idx, k_idx = np.indices((Nx, Ny, Nz))\n\n    def get_E_field(pos_x, pos_y, pos_z):\n        \"\"\"Vectorized E-field calculation.\"\"\"\n        rx = pos_x - r0[0]\n        ry = pos_y - r0[1]\n        rz = pos_z - r0[2]\n        dist_sq = rx**2 + ry**2 + rz**2\n        # Add a small epsilon to avoid division by zero if r coincides with r0.\n        # Problem statement guarantees no coincidence with face centers.\n        dist_cubed = dist_sq * np.sqrt(dist_sq) \n        factor = (q / (4 * np.pi * eps0)) / dist_cubed\n        return factor * rx, factor * ry, factor * rz\n\n    flux_total = np.zeros((Nx, Ny, Nz))\n\n    # Faces at x = constant\n    x_left = i_idx * hx\n    x_right = (i_idx + 1) * hx\n    y_x_face = (j_idx + 0.5) * hy\n    z_x_face = (k_idx + 0.5) * hz\n    Ex_left, _, _ = get_E_field(x_left, y_x_face, z_x_face)\n    Ex_right, _, _ = get_E_field(x_right, y_x_face, z_x_face)\n    flux_total += (Ex_right * 1.0 + Ex_left * -1.0) * Ax\n\n    # Faces at y = constant\n    y_bottom = j_idx * hy\n    y_top = (j_idx + 1) * hy\n    x_y_face = (i_idx + 0.5) * hx\n    z_y_face = (k_idx + 0.5) * hz\n    _, Ey_bottom, _ = get_E_field(x_y_face, y_bottom, z_y_face)\n    _, Ey_top, _ = get_E_field(x_y_face, y_top, z_y_face)\n    flux_total += (Ey_top * 1.0 + Ey_bottom * -1.0) * Ay\n\n    # Faces at z = constant\n    z_back = k_idx * hz\n    z_front = (k_idx + 1) * hz\n    x_z_face = (i_idx + 0.5) * hx\n    y_z_face = (j_idx + 0.5) * hy\n    _, _, Ez_back = get_E_field(x_z_face, y_z_face, z_back)\n    _, _, Ez_front = get_E_field(x_z_face, y_z_face, z_front)\n    flux_total += (Ez_front * 1.0 + Ez_back * -1.0) * Az\n\n    # --- Error Calculation ---\n    \n    # Error = Flux - Q_enclosed (with eps0=1)\n    error_ngp = flux_total - Q_ngp\n    error_cic = flux_total - Q_cic\n\n    # L2 and Max Norms\n    l2_ngp = np.sqrt(np.sum(error_ngp**2))\n    max_ngp = np.max(np.abs(error_ngp))\n    l2_cic = np.sqrt(np.sum(error_cic**2))\n    max_cic = np.max(np.abs(error_cic))\n    \n    return [l2_ngp, max_ngp, l2_cic, max_cic]\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3310354"}, {"introduction": "从网格场到粒子的力计算是PIC循环的核心环节，但此过程可能引入非物理的“虚假自作用力”。本练习通过一个思想实验，即一个静止粒子在它自身产生的场中的受力情况，来揭示这一问题。您将对比交错网格(Yee)和同位网格(Collocated)两种布局，亲眼见证合理的算法设计（如Yee格式）如何通过内在的对称性巧妙地消除这种虚假力。[@problem_id:3338067]", "problem": "考虑一个均匀网格上的一维周期性静电粒子云中网格（PIC）模型。目标是通过量化一个静止在网格单元中心处的单个粒子所受的伪自作用力，来比较交错网格存储（Yee 排列）与同位网格存储电场的方式。此比较必须通过计算纯粹由粒子自身沉积的电荷、数值场求解和力收集过程产生的净自作用力 $\\mathbf{F}_{\\text{self}}$（单位为牛顿）来完成，并基于科学上一致的离散假设。\n\n基础理论与离散模型。从微分形式的高斯定律 $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$ 和静电势定义 $\\mathbf{E} = -\\nabla \\phi$ 出发，其中 $\\varepsilon_0$ 为真空介电常数。在一维空间中，对于域长度为 $L$ 的周期性边界条件，假设电荷密度 $\\rho(x)$ 的空间平均值为零，从而使离散泊松方程可解。使用一个包含 $N$ 个单元的均匀网格，单元尺寸为 $\\Delta x = L/N$，单元中心位于 $x_i = (i + \\tfrac{1}{2}) \\Delta x$，其中整数 $i \\in \\{0,1,\\dots,N-1\\}$。静电势 $\\phi$ 存储在单元中心。引入一个电荷量为 $q$ 的静止单个粒子，其精确位置在索引为 $i_0$ 的单元中心，并通过密度为 $-q/L$ 的均匀背景电荷来中和其净电荷，因此离散电荷密度为\n$$\n\\rho_i = \\frac{q}{\\Delta x} \\delta_{i,i_0} - \\frac{q}{L},\n$$\n其中 $\\delta_{i,i_0}$ 是克罗内克 δ。使用云中网格（CIC）的电荷分配和力收集方法，在这种特殊配置下，对于定义在单元中心的操作，其权重在 $i_0$ 处为 1，在其他地方为 0；对于定义在单元面上的操作，其权重对相邻的两个面各为 1/2。\n\n定义并比较两种场存储和离散算子配置：\n\n1. 交错网格（Yee 排列）：将电场分量 $E_x$ 存储在位置为 $x_{i+\\tfrac{1}{2}} = (i+1)\\Delta x$ 的单元面上，而将 $\\rho$ 和 $\\phi$ 存储在单元中心 $x_i$。通过在傅里叶空间中求解周期性离散泊松方程来计算中心的 $\\phi$：\n$$\n-\\Delta_d \\phi_i = \\frac{\\rho_i}{\\varepsilon_0},\n$$\n其中离散拉普拉斯算子的特征值为 $\\lambda_m = \\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right)$，对应模态指数 $m$。零模态设为零，即 $\\phi_{k=0} = 0$，以确保势的平均值为零。通过离散梯度 $E_{x,i+\\tfrac{1}{2}} = -(\\phi_{i+1} - \\phi_i)/\\Delta x$ 计算以面为中心的电场，并通过对相邻面进行对称 CIC 平均来将力收集到位于 $i_0$ 单元中心的粒子上：\n$$\nE_{p}^{\\text{Yee}} = \\frac{1}{2}\\left(E_{x,i_0-\\tfrac{1}{2}} + E_{x,i_0+\\tfrac{1}{2}}\\right).\n$$\n\n2. 同位网格：将 $E_x$ 与 $\\rho$ 和 $\\phi$ 一同存储在单元中心。通过与上述相同的离散泊松方程计算中心的 $\\phi$。然后使用前向差分离散梯度 $E_{x,i} = -(\\phi_{i+1} - \\phi_i)/\\Delta x$ 计算以单元为中心的 $E_x$。使用中心的 CIC 权重将力收集到粒子上，这简化为在粒子所在单元中心进行求值：\n$$\nE_{p}^{\\text{Coll}} = E_{x,i_0}.\n$$\n\n在两种配置中，计算自作用力\n$$\n\\mathbf{F}_{\\text{self}} = q\\, E_{p} \\,\\hat{\\mathbf{x}},\n$$\n并报告标量值 $F_{\\text{self}} = q E_p$，单位为牛顿。粒子处于静止状态，因此没有磁力贡献。\n\n您的任务。实现一个完整、可运行的程序，该程序：\n- 根据指定参数构建离散电荷密度 $\\rho_i$。\n- 使用上面给出的离散拉普拉斯特征值，在傅里叶空间中求解周期性一维离散泊松方程以获得 $\\phi_i$，并设 $\\phi_{k=0}=0$。\n- 按照定义计算交错网格和同位网格配置下的 $E_x$，使用 CIC 规则将各自的场收集到粒子位置，并计算每种配置的 $F_{\\text{self}}$。\n- 为指定的测试套件生成数值结果。\n\n单位和输出。所有力均以牛顿表示。角度不适用。最终程序输出必须是单行，包含一个逗号分隔的列表，其中每个结果是该测试用例的 $[F_{\\text{self}}^{\\text{Yee}}, F_{\\text{self}}^{\\text{Coll}}]$ 对。例如：“[val1,val2,val3]”，其中每个“valk”本身就是一个写为“[F_Yee,F_Coll]”的列表。\n\n测试套件。使用以下测试用例，每个用例由 $(N, L, q, \\varepsilon_0)$ 指定：\n- 用例 A（正常情况）：$N = 64$, $L = 1.0$ m, $q = 1.0 \\times 10^{-9}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m。\n- 用例 B（粗分辨率边界）：$N = 8$, $L = 1.0$ m, $q = 1.0 \\times 10^{-9}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m。\n- 用例 C（符号边界情况）：$N = 64$, $L = 1.0$ m, $q = -1.0 \\times 10^{-9}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m。\n- 用例 D（更大域，更精细网格）：$N = 256$, $L = 2.0$ m, $q = 5.0 \\times 10^{-10}$ C, $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}$ F/m。\n\n实现约束。程序必须是独立完整的，不需任何输入，并严格使用最终答案中指定的运行时环境。您的程序应生成单行输出，包含一个方括号括起来的逗号分隔列表形式的结果，其中每个用例的结果本身是一个双元素列表：“[[F_A_Yee,F_A_Coll],[F_B_Yee,F_B_Coll],[F_C_Yee,F_C_Coll],[F_D_Yee,F_D_Coll]]”。", "solution": "问题陈述经过严格验证，确认有效。它在科学上是合理的、独立完整的、适定的，并描述了计算等离子体物理学中用于分析质点网格法（PIC）中伪自作用力的一个标准数值实验。所有必需的参数、方程和离散算子都得到了明确的定义。\n\n解决方案通过执行指定的数值算法来进行。我们将计算一个静止在网格单元中心的单个粒子在两种不同数值方案下所受的伪自作用力：一种是交错网格（Yee）方案，另一种是同位网格方案。\n\n**1. 模型离散化与设置**\n\n对于每个测试用例，我们都给定了网格单元数 $N$、域长度 $L$、粒子电荷 $q$ 和真空介电常数 $\\varepsilon_0$。\n网格单元尺寸为 $\\Delta x = L/N$。计算域包含 $N$ 个单元，其中心位于 $x_i = (i + \\tfrac{1}{2})\\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。\n\n一个电荷为 $q$ 的单个粒子被放置在单元 $i_0$ 的中心。由于域的周期性， $i_0$ 的选择是任意的；为方便起见，我们选择 $i_0 = N/2$。对于位于单元中心的粒子，云中网格（CIC）电荷分配方案简化为将全部电荷分配到该单元。为确保周期性泊松方程的可解性，加入了电荷密度为 $-q/L$ 的中和背景电荷。因此，每个单元中心 $i$ 的离散电荷密度为：\n$$\n\\rho_i = \\frac{q}{\\Delta x} \\delta_{i,i_0} - \\frac{q}{L}\n$$\n其中 $\\delta_{i,i_0}$ 是克罗内克 δ。该公式正确地确保了域中的总电荷为零：$\\sum_{i=0}^{N-1} \\rho_i \\Delta x = 0$。\n\n**2. 求解离散泊松方程**\n\n静电势 $\\phi$ 存储在单元中心 $x_i$ 处，并通过离散泊松方程与电荷密度 $\\rho_i$ 相关联：\n$$\n-\\Delta_d \\phi_i = \\frac{\\rho_i}{\\varepsilon_0}\n$$\n其中 $-\\Delta_d$ 是离散负拉普拉斯算子。我们按照指定，在傅里叶空间中求解此方程。设 $\\tilde{\\phi}_m$ 和 $\\tilde{\\rho}_m$ 分别是 $\\phi_i$ 和 $\\rho_i$ 的离散傅里叶变换（DFT）。方程变换为：\n$$\n\\lambda_m \\tilde{\\phi}_m = \\frac{\\tilde{\\rho}_m}{\\varepsilon_0}\n$$\n其中 $\\lambda_m$ 是 $-\\Delta_d$ 算子的特征值，由下式给出：\n$$\n\\lambda_m = \\frac{4}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi m}{N}\\right) \\quad \\text{对于模态指数 } m \\in \\{0, 1, \\dots, N-1\\}\n$$\n对于直流分量 $m=0$，我们有 $\\lambda_0 = 0$。零平均电荷密度确保了 $\\tilde{\\rho}_0 = \\sum_i \\rho_i = 0$，使得 $m=0$ 的方程为 $0 \\cdot \\tilde{\\phi}_0 = 0$。问题指定将平均势设为零，这转化为 $\\tilde{\\phi}_0 = 0$。对于所有其他模态（$m  0$），我们可以解出 $\\tilde{\\phi}_m$：\n$$\n\\tilde{\\phi}_m = \\frac{\\tilde{\\rho}_m}{\\varepsilon_0 \\lambda_m}\n$$\n求解势 $\\phi_i$ 的算法如下：\n1. 构建实空间电荷密度数组 $\\rho_i$。\n2. 使用快速傅里叶变换（FFT）算法计算其 DFT $\\tilde{\\rho}_m$。\n3. 计算特征值 $\\lambda_m$。\n4. 使用上述公式构建傅里叶空间中的势 $\\tilde{\\phi}_m$，并设置 $\\tilde{\\phi}_0 = 0$。\n5. 计算 $\\tilde{\\phi}_m$ 的逆 DFT 以获得 $\\phi_i$。由于初始的 $\\rho_i$ 是实数且表现出对称性，得到的 $\\phi_i$ 也将是实数（在数值精度误差范围内）。\n\n**3. 自作用力计算：交错网格（Yee）方案**\n\n在 Yee 方案中，电场 $E_x$ 相对于势 $\\phi$ 是交错的，存储在位置为 $x_{i+\\tfrac{1}{2}} = (i+1)\\Delta x$ 的单元面上。离散梯度是一个中心差分：\n$$\nE_{x,i+\\tfrac{1}{2}} = -\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\n$$\n粒子位于 $x_{i_0}$。粒子位置处的电场 $E_{p}^{\\text{Yee}}$ 使用 CIC 权重进行收集。对于位于单元中心的粒子，这意味着对两个相邻面上的场进行平均：\n$$\nE_{p}^{\\text{Yee}} = \\frac{1}{2}\\left(E_{x,i_0-\\tfrac{1}{2}} + E_{x,i_0+\\tfrac{1}{2}}\\right) = \\frac{1}{2}\\left( -\\frac{\\phi_{i_0} - \\phi_{i_0-1}}{\\Delta x} - \\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x} \\right) = -\\frac{\\phi_{i_0+1} - \\phi_{i_0-1}}{2\\Delta x}\n$$\n由于问题设置的对称性（周期域中的单个点电荷），得到的势 $\\phi_i$ 必须关于粒子位置 $i_0$ 对称。也就是说，对于任何整数 $k$，都有 $\\phi_{i_0+k} = \\phi_{i_0-k}$。特别地，$\\phi_{i_0+1} = \\phi_{i_0-1}$。因此，收集到的电场 $E_{p}^{\\text{Yee}}$ 在解析上为零。\n自作用力为 $F_{\\text{self}}^{\\text{Yee}} = q E_{p}^{\\text{Yee}} = 0$。任何非零结果都将归因于浮点表示误差，并且应该可以忽略不计。\n\n**4. 自作用力计算：同位网格方案**\n\n在同位方案中，电场 $E_x$ 与 $\\phi$ 和 $\\rho$ 一样，存储在相同的单元中心位置 $x_i$。势 $\\phi_i$ 的计算方式与之前相同。离散梯度被指定为前向差分：\n$$\nE_{x,i} = -\\frac{\\phi_{i+1} - \\phi_i}{\\Delta x}\n$$\n场在粒子位置 $i_0$ 处进行收集。对于位于单元中心的粒子，CIC 收集简化为直接求值：\n$$\nE_{p}^{\\text{Coll}} = E_{x,i_0} = -\\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x}\n$$\n如前所述，势 $\\phi_i$ 在 $i_0$ 处有一个对称的极值（对于 $q0$ 是峰值，对于 $q0$ 是谷值）。因此，$\\phi_{i_0+1} \\neq \\phi_{i_0}$，并且场 $E_{p}^{\\text{Coll}}$ 将不为零。这个非零场是由前向差分算子的不对称性造成的。由此产生的自作用力是：\n$$\nF_{\\text{self}}^{\\text{Coll}} = q E_{p}^{\\text{Coll}} = -q\\frac{\\phi_{i_0+1} - \\phi_{i_0}}{\\Delta x}\n$$\n解析计算表明，此力的计算结果为 $F_{\\text{self}}^{\\text{Coll}} = \\frac{q^2(N-1)}{2NL\\varepsilon_0}$。该力始终为正（沿 $+\\hat{\\mathbf{x}}$ 方向），并且当 $N \\to \\infty$ 时，其值趋于一个常数 $q^2/(2L\\varepsilon_0)$。这证实了带有前向差分梯度的同位网格方案会产生一个显著且系统性的伪自作用力。\n\n下面的程序为所提供的测试套件实现了这些计算。", "answer": "```python\nimport numpy as np\n\ndef calculate_forces(N, L, q, epsilon_0):\n    \"\"\"\n    Calculates the spurious self-force for staggered and collocated schemes.\n\n    Args:\n        N (int): Number of grid cells.\n        L (float): Length of the 1D periodic domain.\n        q (float): Charge of the particle.\n        epsilon_0 (float): Vacuum permittivity.\n\n    Returns:\n        list: A two-element list containing [F_self_Yee, F_self_Coll].\n    \"\"\"\n    # 1. Setup Grid and Charge Density\n    dx = L / N\n    # Place particle at the center of cell i0 for symmetry\n    i0 = N // 2\n    \n    # Create the discrete charge density array rho_i\n    # rho_i = (q / dx) * delta_{i,i0} - q / L\n    rho = np.full(N, -q / L)\n    rho[i0] += q / dx\n\n    # 2. Solve Poisson's Equation for phi\n    # FFT of the charge density\n    rho_tilde = np.fft.fft(rho)\n\n    # Eigenvalues of the discrete negative Laplacian\n    m = np.arange(N)\n    # The m=0 eigenvalue is 0. Avoid division by zero.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        lambda_m = (4.0 / dx**2) * np.sin(np.pi * m / N)**2\n\n    # Solve for phi_tilde in Fourier space: phi_tilde = rho_tilde / (epsilon_0 * lambda)\n    phi_tilde = np.zeros(N, dtype=complex)\n    # For m > 0 (lambda_m != 0)\n    phi_tilde[1:] = rho_tilde[1:] / (epsilon_0 * lambda_m[1:])\n    # For m = 0, phi_tilde[0] is 0 as specified (zero mean potential).\n\n    # Inverse FFT to get phi in real space\n    phi = np.fft.ifft(phi_tilde)\n    phi = np.real(phi) # Potential should be real, discard negligible imag part\n\n    # 3. Calculate Staggered-Grid (Yee) Force\n    # E_p^Yee = - (phi_{i0+1} - phi_{i0-1}) / (2 * dx)\n    # Handle periodic boundary conditions for indices\n    i_prev = (i0 - 1 + N) % N\n    i_next = (i0 + 1) % N\n    \n    phi_prev = phi[i_prev]\n    phi_next = phi[i_next]\n\n    E_p_Yee = - (phi_next - phi_prev) / (2.0 * dx)\n    F_self_Yee = q * E_p_Yee\n\n    # 4. Calculate Collocated-Grid Force\n    # E_p^Coll = - (phi_{i0+1} - phi_{i0}) / (dx)\n    phi_i0 = phi[i0]\n    \n    E_p_Coll = - (phi_next - phi_i0) / dx\n    F_self_Coll = q * E_p_Coll\n\n    return [F_self_Yee, F_self_Coll]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Test suite: (N, L, q, epsilon_0)\n    test_cases = [\n        # Case A: happy path\n        (64, 1.0, 1.0e-9, 8.8541878128e-12),\n        # Case B: coarse resolution boundary\n        (8, 1.0, 1.0e-9, 8.8541878128e-12),\n        # Case C: sign edge case\n        (64, 1.0, -1.0e-9, 8.8541878128e-12),\n        # Case D: larger domain, finer grid\n        (256, 2.0, 5.0e-10, 8.8541878128e-12),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, q, epsilon_0 = case\n        forces = calculate_forces(N, L, q, epsilon_0)\n        results.append(forces)\n\n    # Format the output string exactly as required, removing spaces\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3338067"}, {"introduction": "当粒子运动时，它们构成电流，这必须与电荷密度的变化自洽地联系起来，此关系由电荷守恒的连续性方程所描述。简单的电荷和电流分配方案可能在离散层面破坏这一守恒律，导致模拟结果失真。本练习将指导您实现一种精确满足离散连续性方程的电流分配方案，从而深入理解在PIC模拟中保证电荷守恒的精妙之处及其对模拟稳定性的重要意义。[@problem_id:3338044]", "problem": "考虑一个二维粒子模拟 (PIC) 方案，该方案建立在一个均匀、周期性的笛卡尔网格上，其中 $x$ 方向有 $N_x$ 个单元格，$y$ 方向有 $N_y$ 个单元格。设单元格中心由整数 $i \\in \\{0,\\dots,N_x-1\\}$ 和 $j \\in \\{0,\\dots,N_y-1\\}$ 索引，位置以无量纲的网格单位表示，因此一个单元格间距等于 $1$。一个电荷为 $q$ 的单个粒子，在电场 $\\mathbf{E}$ 和磁场 $\\mathbf{B}$ 的作用下，通过跨场漂移以恒定速度运动，即 $\\mathbf{v} = \\mathbf{E} \\times \\mathbf{B} / \\|\\mathbf{B}\\|^2$。假设在一个持续时间为 $\\Delta t$ 的时间步内，$\\mathbf{B} = (0,0,B_z)$ 和 $\\mathbf{E} = (E_x,E_y,0)$ 在空间和时间上是均匀且恒定的，因此漂移速度为 $\\mathbf{v} = (E_y/B_z, -E_x/B_z, 0)$。\n\n您的任务是针对单个粒子和单个时间步，以纯数学术语实现以下操作：\n- 使用 Cloud-In-Cell 双线性形函数（一阶 B 样条）将时间步 $n$ 和 $n+1$ 的电荷密度 $\\rho$ 存积到单元格中心。对于粒子位置 $(x,y)$，四个相邻单元格中心的权重分别为 $(1-f_x)(1-f_y)$、$f_x(1-f_y)$、$(1-f_x)f_y$ 和 $f_x f_y$，其中 $f_x = x - \\lfloor x \\rfloor$ 且 $f_y = y - \\lfloor y \\rfloor$，索引根据周期性对 $N_x$ 和 $N_y$ 取模。\n- 在半时间步，使用沿运动方向为零阶（最近面）和沿横向为一阶（线性）的形函数，存积面心电流 $\\mathbf{J}^{n+1/2}$。具体来说，将 $J_x$ 存积到 $x = i + 1$ 处的面（即单元格 $i$ 和 $i+1$ 之间），将 $J_y$ 存积到 $y = j + 1$ 处的面（即单元格 $j$ 和 $j+1$ 之间）。对于 $J_x$，如果 $\\Delta x \\ge 0$，选择唯一的面索引 $k_x = i_0 + 1$；如果 $\\Delta x  0$，则选择 $k_x = i_0$，其中 $i_0 = \\lfloor x^n \\rfloor$ 且 $\\Delta x = x^{n+1} - x^n$。对于 $J_y$，如果 $\\Delta y \\ge 0$，选择 $k_y = j_0 + 1$；如果 $\\Delta y  0$，则选择 $k_y = j_0$，其中 $j_0 = \\lfloor y^n \\rfloor$ 且 $\\Delta y = y^{n+1} - y^n$。在时间区间 $[t^n, t^{n+1}]$ 内，将横向坐标中可能穿越整数边界的点作为分割点，对各时间段上的横向线性权重进行精确积分，以获得半时间步的时间平均电流。对索引使用周期性边界条件。\n\n交错网格上的离散连续性方程为\n$$\n\\frac{\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}}{\\Delta t} + \\left[ J_x^{n+1/2}(i+1,j) - J_x^{n+1/2}(i,j) \\right] + \\left[ J_y^{n+1/2}(i,j+1) - J_y^{n+1/2}(i,j) \\right] = 0,\n$$\n对于所有 $i,j$ 成立，其中 $J_x^{n+1/2}(k,j)$ 是面索引为 $k \\in \\{0,\\dots,N_x-1\\}$、行为 $j$ 的 $x$ 面电流，$J_y^{n+1/2}(i,k)$ 是列为 $i$、面索引为 $k \\in \\{0,\\dots,N_y-1\\}$ 的 $y$ 面电流。为了周期性，面索引对 $N_x$ 和 $N_y$ 取模。您必须计算最大绝对残差\n$$\n\\varepsilon = \\max_{i,j} \\left| \\frac{\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}}{\\Delta t} + \\left[ J_x^{n+1/2}(i+1,j) - J_x^{n+1/2}(i,j) \\right] + \\left[ J_y^{n+1/2}(i,j+1) - J_y^{n+1/2}(i,j) \\right] \\right|,\n$$\n在此数学表述中，这是一个无量纲数。\n\n请实现一个程序，针对以下测试套件，通过 $\\mathbf{v} = \\mathbf{E} \\times \\mathbf{B}/\\|\\mathbf{B}\\|^2$ 计算粒子位置更新，通过对在边界交叉处分割的横向线性权重进行精确时间积分来存积 $\\rho^n$、$\\rho^{n+1}$ 和面心电流 $\\mathbf{J}^{n+1/2}$，计算离散连续性残差，并报告每种情况下的最大绝对残差 $\\varepsilon$。所有量均为无量纲，所有索引均为周期性。所有情况均使用 $N_x = 8$、$N_y = 8$、$q = 1$ 和 $\\Delta t = 1$。\n\n测试套件参数集 $(E_x,E_y,B_z,x^n,y^n)$:\n- 情况 1: $(1.0, 0.0, 2.0, 3.2, 4.4)$。\n- 情况 2: $(0.0, 1.0, 2.0, 3.7, 1.1)$。\n- 情况 3: $(1.0, 1.0, 2.0, 2.7, 5.3)$。\n- 情况 4: $(0.0, 0.0, 2.0, 6.5, 3.0)$。\n- 情况 5: $(1.0, 1.0, 10.0, 2.0, 4.0)$。\n\n您的程序应生成单行输出，其中包含按上述案例顺序排列的结果，格式为方括号内以逗号分隔的列表，例如 $[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5]$。", "solution": "用户提供了一个计算物理学中有效的、适定的问题，具体涉及在粒子模拟 (PIC) 框架内实现和验证一种粒子到网格的存积方案。任务是为一个指定的混合电流存积方案计算离散连续性方程的最大绝对残差。该问题有科学依据，形式上明确，并需要一个详细且不简单的实现。\n\n解决方案的流程是为五个测试案例中的每一个实现所述算法。每个案例的核心步骤包括：\n1.  计算一个时间步后粒子的最终位置。\n2.  在初始和最终时刻将粒子电荷存积到网格上。\n3.  在该时间步内将粒子电流存积到网格面上。\n4.  计算每个网格单元处离散连续性方程的残差，并找出其最大绝对值。\n\n如问题所述，所有量均为无量纲，网格间距等于 $1$，粒子电荷 $q=1$，时间步 $\\Delta t=1$。网格是一个周期性的 $8 \\times 8$ 区域。\n\n**1. 粒子位置更新**\n\n粒子以由 $\\mathbf{E} \\times \\mathbf{B}$ 漂移决定的恒定速度 $\\mathbf{v}$ 运动，其中 $\\mathbf{E} = (E_x, E_y, 0)$ 和 $\\mathbf{B} = (0, 0, B_z)$ 是均匀且恒定的。速度由下式给出：\n$$\n\\mathbf{v} = \\frac{\\mathbf{E} \\times \\mathbf{B}}{\\|\\mathbf{B}\\|^2} = \\left( \\frac{E_y B_z}{B_z^2}, \\frac{-E_x B_z}{B_z^2}, 0 \\right) = \\left( \\frac{E_y}{B_z}, -\\frac{E_x}{B_z}, 0 \\right)\n$$\n给定初始位置 $\\mathbf{r}^n = (x^n, y^n)$，下一个时间步的位置 $\\mathbf{r}^{n+1} = (x^{n+1}, y^{n+1})$ 通过简单的前向欧拉积分计算，对于恒定速度而言，该方法是精确的：\n$$\n\\mathbf{r}^{n+1} = \\mathbf{r}^n + \\mathbf{v} \\Delta t\n$$\n由于 $\\Delta t=1$，这简化为 $x^{n+1} = x^n + v_x$ 和 $y^{n+1} = y^n + v_y$。\n\n**2. 电荷存积**\n\n电荷密度 $\\rho$ 使用 Cloud-In-Cell (CIC) 或双线性插值方案存积到单元格中心。对于位于位置 $(x, y)$ 的粒子，电荷 $q$ 被分配到最近的四个单元格中心。单元格索引为 $(i_0, j_0)$、$(i_0+1, j_0)$、$(i_0, j_0+1)$ 和 $(i_0+1, j_0+1)$，其中 $i_0 = \\lfloor x \\rfloor$ 且 $j_0 = \\lfloor y \\rfloor$。小数部分位置为 $f_x = x - i_0$ 和 $f_y = y - j_0$。权重为：\n-   单元格 $(i_0, j_0)$: $W_{i_0,j_0} = (1-f_x)(1-f_y)$\n-   单元格 $(i_0+1, j_0)$: $W_{i_0+1,j_0} = f_x(1-f_y)$\n-   单元格 $(i_0, j_0+1)$: $W_{i_0,j_0+1} = (1-f_x)f_y$\n-   单元格 $(i_0+1, j_0+1)$: $W_{i_0+1,j_0} = f_x f_y$\n\n存积到单元格 $(i, j)$ 的电荷为 $\\rho_{i,j} = q \\cdot W_{i,j}$。此计算针对 $\\rho^n$（使用 $\\mathbf{r}^n$）和 $\\rho^{n+1}$（使用 $\\mathbf{r}^{n+1}$）进行。所有网格索引都根据周期性对 $N_x=8$ 和 $N_y=8$ 取模处理。\n\n**3. 电流存积**\n\n这是问题中最复杂的部分。电流 $\\mathbf{J}^{n+1/2}$ 使用混合方案进行存积：在运动方向上为零阶（最近面），在横向上为一阶（线性）。横向的线性权重在整个时间步内进行精确积分。\n\n对于电流的 $x$分量 $J_x$：\n-   运动被投影到沿 $x$ 轴的单个面上。面索引 $k_x$ 由初始单元格索引 $i_0 = \\lfloor x^n \\rfloor$ 和速度 $v_x$ 的符号决定。如果 $v_x \\ge 0$，粒子穿过 $i_0+1$ 处的面，因此 $k_x = i_0+1$。如果 $v_x  0$，它穿过 $i_0$ 处的面，因此 $k_x = i_0$。\n-   $x$ 方向的总电流 $q v_x$ 在横向（$y$）方向上分布。存积到横向行 $j$ 的面 $k_x$ 上的时间平均电流由下式给出：\n    $$\n    J_x(k_x, j) = \\frac{1}{\\Delta t} \\int_{0}^{\\Delta t} q v_x S_j(y(\\tau)) d\\tau\n    $$\n    其中 $y(\\tau) = y^n + v_y \\tau$ 是粒子在时间 $\\tau \\in [0, \\Delta t]$ 时的 $y$ 坐标，$S_j(y)$ 是 CIC 的线性形函数（以网格节点 $j$ 为中心的三角形函数）。\n-   积分 $\\int_0^{\\Delta t} S_j(y(\\tau)) d\\tau$ 的计算方法是：在每个粒子横向坐标 $y(\\tau_c)$ 穿越整数网格线的时间点 $\\tau_c$ 处，分割积分区间 $[0, \\Delta t]$。在每个子区间内，$\\lfloor y(\\tau) \\rfloor$ 是常数，被积函数是关于 $\\tau$ 的线性函数，可以精确积分（例如，使用对于线性函数是精确的梯形法则）。\n\n电流 $y$ 分量 $J_y$ 的过程是对称的。面索引 $k_y$ 由 $y^n$ 和 $v_y$ 决定，横向积分在 $x$ 坐标上执行，即 $x(\\tau)=x^n+v_x \\tau$。\n\n**4. 残差计算**\n\n最后，计算残差 $\\varepsilon$。对于每个单元格 $(i, j)$，离散连续性方程被求值：\n$$\nR_{i,j} = \\frac{\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}}{\\Delta t} + \\left[ J_x^{n+1/2}((i+1)\\%N_x,j) - J_x^{n+1/2}(i,j) \\right] + \\left[ J_y^{n+1/2}(i,(j+1)\\%N_y) - J_y^{n+1/2}(i,j) \\right]\n$$\n当 $\\Delta t=1$ 时，第一项就是 $\\rho^{n+1}_{i,j} - \\rho^{n}_{i,j}$。最大绝对残差则为 $\\varepsilon = \\max_{i,j} |R_{i,j}|$。这个值量化了所实现的存积方案未能局部守恒电荷的程度。\n\n整个过程在一个 Python 程序中实现，该程序遍历提供的测试案例并为每个案例计算 $\\varepsilon$。", "answer": "```python\nimport numpy as np\n\ndef _deposit_charge(pos, q, Nx, Ny):\n    \"\"\"\n    Deposits charge using the Cloud-In-Cell (bilinear) scheme.\n    \n    Args:\n        pos (tuple): Particle (x, y) position.\n        q (float): Particle charge.\n        Nx (int): Number of grid cells in x.\n        Ny (int): Number of grid cells in y.\n        \n    Returns:\n        numpy.ndarray: A 2D array representing charge density rho.\n    \"\"\"\n    rho = np.zeros((Nx, Ny))\n    x, y = pos\n    i0 = int(np.floor(x))\n    j0 = int(np.floor(y))\n    fx = x - i0\n    fy = y - j0\n    \n    # Indices with periodic boundary conditions\n    i0m = i0 % Nx\n    i1m = (i0 + 1) % Nx\n    j0m = j0 % Ny\n    j1m = (j0 + 1) % Ny\n    \n    rho[i0m, j0m] = q * (1 - fx) * (1 - fy)\n    rho[i1m, j0m] = q * fx * (1 - fy)\n    rho[i0m, j1m] = q * (1 - fx) * fy\n    rho[i1m, j1m] = q * fx * fy\n    return rho\n\ndef _integrate_shape_weights(p_start, v, dt, N_cells):\n    \"\"\"\n    Exactly integrates the linear CIC shape function weights over time,\n    accounting for grid-line crossings in the path.\n    \n    Args:\n        p_start (float): Initial position in the transverse dimension.\n        v (float): Velocity in the transverse dimension.\n        dt (float): Time step duration.\n        N_cells (int): Number of grid cells in the transverse dimension.\n        \n    Returns:\n        numpy.ndarray: A 1D array of time-integrated weights for each node.\n    \"\"\"\n    integrated_weights = np.zeros(N_cells)\n    \n    # If there is no displacement, the calculation is simple.\n    if abs(v * dt)  1e-14:\n        i0 = int(np.floor(p_start))\n        fp = p_start - i0\n        integrated_weights[i0 % N_cells] += (1 - fp) * dt\n        integrated_weights[(i0 + 1) % N_cells] += fp * dt\n        return integrated_weights\n\n    # Find all times within (0, dt) where the particle crosses an integer grid line.\n    crossing_times = {0.0, dt}\n    p_end = p_start + v * dt\n    p_min = min(p_start, p_end)\n    p_max = max(p_start, p_end)\n\n    k_min = int(np.ceil(p_min))\n    k_max = int(np.floor(p_max))\n    \n    # If the particle path ends on an integer line, that is not an intermediate crossing.\n    if abs(p_max - k_max)  1e-12:\n        k_max -= 1\n        \n    for k in range(k_min, k_max + 1):\n        t_cross = (k - p_start) / v\n        # Add only crossings strictly within the time interval.\n        if 1e-12  t_cross  dt - 1e-12:\n            crossing_times.add(t_cross)\n\n    sorted_times = sorted(list(crossing_times))\n    \n    # Integrate over each segment between crossings.\n    for idx in range(len(sorted_times) - 1):\n        t1, t2 = sorted_times[idx], sorted_times[idx+1]\n        \n        p1 = p_start + v * t1\n        p2 = p_start + v * t2\n        \n        # The integer part of the position is constant within the segment.\n        p_mid = (p1 + p2) / 2.0\n        i0 = int(np.floor(p_mid))\n        \n        # The integral of a linear function f(t) over [t1, t2] is (t2-t1)*(f(t1)+f(t2))/2.\n        # Here we integrate the shape functions S_i0 and S_{i0+1}.\n        # S_{i0+1}(p(t)) = p(t) - i0\n        integral_f = (t2 - t1) * ((p1 - i0) + (p2 - i0)) / 2.0\n        # S_{i0}(p(t)) = 1 - (p(t) - i0)\n        integral_1_minus_f = (t2 - t1) - integral_f\n        \n        integrated_weights[i0 % N_cells] += integral_1_minus_f\n        integrated_weights[(i0 + 1) % N_cells] += integral_f\n        \n    return integrated_weights\n\ndef _solve_case(params):\n    \"\"\"Solves a single test case and returns the max residual.\"\"\"\n    Nx, Ny = 8, 8\n    q, dt = 1.0, 1.0\n    Ex, Ey, Bz, xn, yn = params\n    \n    # 1. Update particle position\n    if abs(Bz)  1e-15:\n        vx, vy = 0.0, 0.0\n    else:\n        vx = Ey / Bz\n        vy = -Ex / Bz\n    \n    x_next = xn + vx * dt\n    y_next = yn + vy * dt\n    \n    # 2. Deposit charge densities rho^n and rho^{n+1}\n    rho_n = _deposit_charge((xn, yn), q, Nx, Ny)\n    rho_next = _deposit_charge((x_next, y_next), q, Nx, Ny)\n    \n    # 3. Deposit face-centered currents J\n    Jx = np.zeros((Nx, Ny))\n    Jy = np.zeros((Nx, Ny))\n    \n    # Jx component\n    if abs(vx * dt) > 1e-14:\n        i0 = int(np.floor(xn))\n        kx = ((i0 + 1) if vx >= 0 else i0) % Nx\n        integrated_weights_y = _integrate_shape_weights(yn, vy, dt, Ny)\n        current_val = q * vx / dt\n        for j in range(Ny):\n            Jx[kx, j] += current_val * integrated_weights_y[j]\n\n    # Jy component\n    if abs(vy * dt) > 1e-14:\n        j0 = int(np.floor(yn))\n        ky = ((j0 + 1) if vy >= 0 else j0) % Ny\n        integrated_weights_x = _integrate_shape_weights(xn, vx, dt, Nx)\n        current_val = q * vy / dt\n        for i in range(Nx):\n            Jy[i, ky] += current_val * integrated_weights_x[i]\n\n    # 4. Calculate the residual of the discrete continuity equation\n    residuals = np.zeros((Nx, Ny))\n    for i in range(Nx):\n        for j in range(Ny):\n            delta_rho_over_dt = (rho_next[i, j] - rho_n[i, j]) / dt\n            div_Jx = Jx[(i + 1) % Nx, j] - Jx[i, j]\n            div_Jy = Jy[i, (j + 1) % Ny] - Jy[i, j]\n            residuals[i, j] = delta_rho_over_dt + div_Jx + div_Jy\n            \n    return np.max(np.abs(residuals))\n\ndef solve():\n    \"\"\"Main function to run the test suite and print results.\"\"\"\n    test_cases = [\n        (1.0, 0.0, 2.0, 3.2, 4.4),   # Case 1\n        (0.0, 1.0, 2.0, 3.7, 1.1),   # Case 2\n        (1.0, 1.0, 2.0, 2.7, 5.3),   # Case 3\n        (0.0, 0.0, 2.0, 6.5, 3.0),   # Case 4\n        (1.0, 1.0, 10.0, 2.0, 4.0),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_case(case)\n        results.append(result)\n\n    # Format the output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3338044"}]}