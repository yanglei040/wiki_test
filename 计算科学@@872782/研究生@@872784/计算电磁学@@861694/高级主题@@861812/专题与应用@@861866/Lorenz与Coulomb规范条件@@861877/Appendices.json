{"hands_on_practices": [{"introduction": "在时域仿真中，规范的选择会对计算效率产生巨大影响。本练习将洛伦兹规范的完全双曲特性与库仑规范的混合双曲-椭圆特性进行对比。通过为一个特定场景量化计算成本差异，您将具体理解为何在显式时间步进格式（如FDTD）中通常首选洛伦兹规范 [@problem_id:3325847]。", "problem": "考虑真空 Maxwell 方程组，其中电荷密度为 $\\rho(\\mathbf{r},t)$，电流密度为 $\\mathbf{J}(\\mathbf{r},t)$，材料参数为介电常数 $\\epsilon_0$ 和磁导率 $\\mu_0$，电磁场为 $\\mathbf{E}(\\mathbf{r},t)$ 和 $\\mathbf{B}(\\mathbf{r},t)$。通过 $\\mathbf{B} = \\nabla \\times \\mathbf{A}$ 和 $\\mathbf{E} = -\\nabla \\phi - \\partial_t \\mathbf{A}$ 引入电磁势。两种不同的规范条件被普遍使用：Lorenz 规范，$\\nabla \\cdot \\mathbf{A} + \\mu_0 \\epsilon_0 \\partial_t \\phi = 0$，和 Coulomb 规范，$\\nabla \\cdot \\mathbf{A} = 0$。\n\n构建一个由连续性方程耦合的、具有非平凡电荷密度和电流密度的显式源，然后在一个时域有限差分离散化中，比较强制执行 Lorenz 规范与 Coulomb 规范所产生的计算结构。具体而言，令\n$$\n\\psi(\\mathbf{r}) = \\exp\\!\\left(-\\frac{|\\mathbf{r}|^2}{2\\sigma^2}\\right), \\quad g(t) = \\sin(\\omega_0 t)\\,\\exp(-\\alpha t),\n$$\n并定义\n$$\n\\rho(\\mathbf{r},t) = q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,g(t), \\quad \\mathbf{J}(\\mathbf{r},t) = -q_0\\,\\nabla \\psi(\\mathbf{r})\\,\\partial_t g(t),\n$$\n其中 $q_0$、$\\sigma$、$\\omega_0$ 和 $\\alpha$ 是有限正常数。验证这些源满足连续性方程 $\\nabla \\cdot \\mathbf{J} + \\partial_t \\rho = 0$。\n\n从 Maxwell 方程组和上述势的定义出发，推导在 Lorenz 规范和 Coulomb 规范下势的控制方程。解释为什么对于所构建的源，强制执行 Lorenz 规范会消除非局域约束，并为 $\\phi$ 和 $\\mathbf{A}$ 产生统一的波算符，而 Coulomb 规范则对 $\\phi$ 施加一个非局域椭圆约束，并对 $\\mathbf{A}$ 施加一个引入耦合的无散条件。\n\n假设一个均匀的立方空间网格，每个标量场有 $N$ 个自由度，并对类波方程使用标准的显式二阶时域有限差分 (FDTD) 更新。将每个时间步的浮点运算次数建模如下：\n\n- 对于使用 7 点拉普拉斯算子的标量或矢量分量的任何显式波更新，每个自由度的成本为 $c_s = 11$ 次运算。\n- 对于任何 Poisson 求解（椭圆问题），一个几何多重网格 V 循环的成本为每个循环每个自由度 $c_m = 50$ 次运算，并且每次 Poisson 求解在每个时间步使用 $n_v = 2$ 个循环以达到所需的残差容差。\n- 计算矢量场 $\\mathbf{A}$ 的离散散度需要每个自由度 $c_d = 5$ 次运算。\n- 计算标量场 $\\psi$ 的梯度并从 $\\mathbf{A}$ 中减去它（Helmholtz 投影步骤 $\\mathbf{A} \\leftarrow \\mathbf{A} - \\nabla \\psi$）需要每个自由度 $c_g = 6$ 次运算。\n\n在 Lorenz 规范下，势 $\\phi$ 和 $\\mathbf{A}$ 仅通过显式波更新即可推进。在 Coulomb 规范下，在每个时间步，通过从 $\\rho$ 进行 Poisson 求解来计算 $\\phi$，通过显式波更新来推进 $\\mathbf{A}$，然后通过一个 Helmholtz 投影来强制执行 $\\nabla \\cdot \\mathbf{A} = 0$，该投影包括计算 $d = \\nabla \\cdot \\mathbf{A}$，求解 Poisson 方程 $\\nabla^2 \\psi = d$，以及更新 $\\mathbf{A} \\leftarrow \\mathbf{A} - \\nabla \\psi$。\n\n使用上述成本模型，推导每个时间步 Coulomb 规范成本与 Lorenz 规范成本之比 $R$ 的闭式表达式，并对 $R$ 进行数值计算。将您的最终数值答案四舍五入到三位有效数字。将您的答案表示为一个无量纲数。", "solution": "问题陈述具有科学依据、适定、客观且完整。它在计算电磁学的背景下，对 Lorenz 规范和 Coulomb 规范进行了标准比较，提供了所有必要的定义、常数和清晰的计算成本模型。因此，该问题被认为是有效的，下面提供了完整的解答。\n\n首先，我们验证给定的源项，\n$$\n\\rho(\\mathbf{r},t) = q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,g(t)\n$$\n$$\n\\mathbf{J}(\\mathbf{r},t) = -q_0\\,\\nabla \\psi(\\mathbf{r})\\,\\partial_t g(t)\n$$\n满足连续性方程 $\\nabla \\cdot \\mathbf{J} + \\partial_t \\rho = 0$。\n\n对电荷密度 $\\rho$ 求时间导数，我们得到：\n$$\n\\partial_t \\rho = \\partial_t \\left[ q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,g(t) \\right] = q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,\\partial_t g(t)\n$$\n因为 $\\psi(\\mathbf{r})$ 与时间 $t$ 无关。\n\n接下来，对电流密度 $\\mathbf{J}$ 求散度：\n$$\n\\nabla \\cdot \\mathbf{J} = \\nabla \\cdot \\left[ -q_0\\,\\nabla \\psi(\\mathbf{r})\\,\\partial_t g(t) \\right]\n$$\n由于 $\\partial_t g(t)$ 只是时间的标量函数，不依赖于位置 $\\mathbf{r}$，我们可以将其从空间散度算子中提出：\n$$\n\\nabla \\cdot \\mathbf{J} = -q_0\\,\\partial_t g(t)\\,\\nabla \\cdot (\\nabla \\psi(\\mathbf{r})) = -q_0\\,\\partial_t g(t)\\,\\nabla^2 \\psi(\\mathbf{r})\n$$\n将两个结果相加：\n$$\n\\nabla \\cdot \\mathbf{J} + \\partial_t \\rho = -q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,\\partial_t g(t) + q_0\\,\\nabla^2 \\psi(\\mathbf{r})\\,\\partial_t g(t) = 0\n$$\n连续性方程得到满足。\n\n接下来，我们从非齐次 Maxwell 方程组和势的定义 $\\mathbf{B} = \\nabla \\times \\mathbf{A}$ 和 $\\mathbf{E} = -\\nabla \\phi - \\partial_t \\mathbf{A}$ 出发，推导势 $\\phi$ 和 $\\mathbf{A}$ 的控制方程。相关的 Maxwell 方程是 Gauss 定律和 Ampere-Maxwell 定律：\n$$\n\\nabla \\cdot \\mathbf{E} = \\frac{\\rho}{\\epsilon_0}\n$$\n$$\n\\nabla \\times \\mathbf{B} = \\mu_0 \\mathbf{J} + \\mu_0 \\epsilon_0 \\partial_t \\mathbf{E}\n$$\n将势的定义代入 Gauss 定律：\n$$\n\\nabla \\cdot (-\\nabla \\phi - \\partial_t \\mathbf{A}) = \\frac{\\rho}{\\epsilon_0} \\implies \\nabla^2 \\phi + \\partial_t(\\nabla \\cdot \\mathbf{A}) = -\\frac{\\rho}{\\epsilon_0}\n$$\n（方程1）\n\n将势的定义代入 Ampere-Maxwell 定律，并使用矢量恒等式 $\\nabla \\times (\\nabla \\times \\mathbf{A}) = \\nabla(\\nabla \\cdot \\mathbf{A}) - \\nabla^2 \\mathbf{A}$：\n$$\n\\nabla \\times (\\nabla \\times \\mathbf{A}) = \\mu_0 \\mathbf{J} + \\mu_0 \\epsilon_0 \\partial_t(-\\nabla \\phi - \\partial_t \\mathbf{A})\n$$\n$$\n\\nabla(\\nabla \\cdot \\mathbf{A}) - \\nabla^2 \\mathbf{A} = \\mu_0 \\mathbf{J} - \\mu_0 \\epsilon_0 \\nabla(\\partial_t \\phi) - \\mu_0 \\epsilon_0 \\partial_t^2 \\mathbf{A}\n$$\n重新整理并定义 d'Alembert 算子 $\\Box = \\nabla^2 - \\mu_0 \\epsilon_0 \\partial_t^2$：\n$$\n\\Box \\mathbf{A} - \\nabla(\\nabla \\cdot \\mathbf{A} + \\mu_0 \\epsilon_0 \\partial_t \\phi) = -\\mu_0 \\mathbf{J}\n$$\n（方程2）\n\n现在我们应用这两个规范条件。\n\n情况1：Lorenz 规范\nLorenz 规范条件是 $\\nabla \\cdot \\mathbf{A} + \\mu_0 \\epsilon_0 \\partial_t \\phi = 0$。\n将此应用于方程2，左边的第二项消失：\n$$\n\\Box \\mathbf{A} = -\\mu_0 \\mathbf{J} \\implies (\\nabla^2 - \\mu_0 \\epsilon_0 \\partial_t^2) \\mathbf{A} = -\\mu_0 \\mathbf{J}\n$$\n这是一组关于 $\\mathbf{A}$ 各分量的三个非耦合波动方程。\n接下来，我们使用 Lorenz 条件来简化方程1。我们有 $\\partial_t(\\nabla \\cdot \\mathbf{A}) = \\partial_t(-\\mu_0 \\epsilon_0 \\partial_t \\phi) = -\\mu_0 \\epsilon_0 \\partial_t^2 \\phi$。将其代入方程1：\n$$\n\\nabla^2 \\phi - \\mu_0 \\epsilon_0 \\partial_t^2 \\phi = -\\frac{\\rho}{\\epsilon_0} \\implies \\Box \\phi = -\\frac{\\rho}{\\epsilon_0}\n$$\n这是一个关于 $\\phi$ 的波动方程。\n在 Lorenz 规范中，标量势 $\\phi$ 和矢量势 $\\mathbf{A}$ 都由相同的双曲型波算符 $\\Box$ 控制。这些方程分别由局域源 $\\rho$ 和 $\\mathbf{J}$ 驱动。在计算上，这对于像 FDTD 这样的时域方法非常有利。一个显式更新格式可以仅根据 $\\phi$ 和 $\\mathbf{A}$ 在局域空间邻域内先前时间步的值来在时间上推进它们。这种局域性消除了在每个时间步求解大型耦合方程组的需要。\n\n情况2：Coulomb 规范\nCoulomb 规范条件是 $\\nabla \\cdot \\mathbf{A} = 0$。\n将此应用于方程1，左边的第二项消失：\n$$\n\\nabla^2 \\phi = -\\frac{\\rho}{\\epsilon_0}\n$$\n这是 Poisson 方程。与波动方程不同，它没有时间导数项。这意味着在任何给定时刻 $t$，整个空间中的势 $\\phi(\\mathbf{r}, t)$ 由全局电荷分布 $\\rho(\\mathbf{r}', t)$ 瞬时确定。这是一个椭圆型偏微分方程，它施加了一个非局域约束。在数值上，它需要在每个时间步求解一个大型线性系统，这在计算上是昂贵的。\n将 Coulomb 条件应用于方程2，我们得到：\n$$\n(\\nabla^2 - \\mu_0 \\epsilon_0 \\partial_t^2)\\mathbf{A} - \\nabla(\\mu_0 \\epsilon_0 \\partial_t \\phi) = -\\mu_0 \\mathbf{J}\n$$\n$$\n(\\nabla^2 - \\mu_0 \\epsilon_0 \\partial_t^2)\\mathbf{A} = -\\mu_0 \\mathbf{J} + \\mu_0 \\epsilon_0 \\nabla(\\partial_t \\phi)\n$$\n这是一个关于 $\\mathbf{A}$ 的波动方程，但其源项现在依赖于标量势时间导数的梯度 $\\nabla(\\partial_t \\phi)$。这将 $\\mathbf{A}$ 的方程与 $\\phi$ 耦合起来。此外，即使在时间 $t$ 满足 $\\nabla \\cdot \\mathbf{A} = 0$，对 $\\mathbf{A}$ 进行到时间 $t+\\Delta t$ 的数值波更新通常也会引入数值误差，导致 $\\nabla \\cdot \\mathbf{A} \\neq 0$。为了在每一步严格执行规范条件，需要一个校正或投影步骤。这涉及到求解另一个 Poisson 方程，以将 $\\mathbf{A}$ 投影回无散场的空间。这个额外的椭圆求解进一步增加了计算成本。\n\n总之，Lorenz 规范导致一组四个非耦合的局域波动方程，非常适合高效的显式时间步进格式。Coulomb 规范导致一个关于 $\\phi$ 的非局域椭圆方程和一个需要额外非局域投影步骤的耦合波动方程，这使其每个时间步的计算密集得多。\n\n最后，我们使用提供的成本模型计算每个时间步 Coulomb 规范与 Lorenz 规范的计算成本之比 $R$。设 $N$ 是一个标量场的自由度（网格点）数量。一个矢量场有 $3N$ 个自由度。\n\nLorenz 规范的成本 ($C_L$):\n该算法涉及一个标量场 ($\\phi$) 和一个矢量场 ($\\mathbf{A}$) 的显式波更新。\n- 更新 $\\phi$ ($N$ 个自由度) 的成本：$N \\times c_s$。\n- 更新 $\\mathbf{A}$ ($3N$ 个自由度) 的成本：$3N \\times c_s$。\n- 总成本：$C_L = N c_s + 3N c_s = 4N c_s$。\n\nCoulomb 规范的成本 ($C_C$):\n该算法在每个时间步按以下步骤序列进行：\n1.  从 $\\rho$ 求解 $\\phi$ 的 Poisson 方程。这是一个标量场的椭圆求解。\n    成本：$N \\times c_m \\times n_v$。\n2.  用显式波更新推进 $\\mathbf{A}$。这是一个矢量场的更新。\n    成本：$3N \\times c_s$。\n3.  通过 Helmholtz 投影强制执行 $\\nabla \\cdot \\mathbf{A} = 0$。\n    a. 计算 $d = \\nabla \\cdot \\mathbf{A}$。成本按每个自由度/网格点 $c_d$ 给出。\n       成本：$N \\times c_d$。\n    b. 求解 Poisson 方程 $\\nabla^2 \\psi = d$。这是一个标量场的椭圆求解。\n       成本：$N \\times c_m \\times n_v$。\n    c. 更新 $\\mathbf{A} \\leftarrow \\mathbf{A} - \\nabla \\psi$。成本按每个自由度/网格点 $c_g$ 给出。\n       成本：$N \\times c_g$。\n- 总成本：$C_C = (N c_m n_v) + (3N c_s) + (N c_d + N c_m n_v + N c_g)$。\n- $C_C = N (2 c_m n_v + 3 c_s + c_d + c_g)$。\n\n比率 $R$ 为：\n$$\nR = \\frac{C_C}{C_L} = \\frac{N (2 c_m n_v + 3 c_s + c_d + c_g)}{4N c_s} = \\frac{2 c_m n_v + 3 c_s + c_d + c_g}{4 c_s}\n$$\n现在，代入给定的数值：$c_s = 11$, $c_m = 50$, $n_v = 2$, $c_d = 5$, $c_g = 6$。\n$$\nR = \\frac{2(50)(2) + 3(11) + 5 + 6}{4(11)} = \\frac{200 + 33 + 5 + 6}{44} = \\frac{244}{44} = \\frac{61}{11}\n$$\n数值上，结果是：\n$$\nR = \\frac{61}{11} \\approx 5.545454...\n$$\n四舍五入到三位有效数字，我们得到 $R = 5.55$。", "answer": "$$\n\\boxed{5.55}\n$$", "id": "3325847"}, {"introduction": "当物理问题本身要求使用库仑规范时（例如在静磁学或某些隐式时域格式中），我们需要稳健的方法来施加 $\\nabla \\cdot \\mathbf{A} = 0$ 约束。本实践深入研究有限元方法，在这种方法中，约束通常是弱式施加的。您将通过编程实现并比较两种常用的技术——罚函数法和拉格朗日乘子法——来强制实现无散条件，从而获得处理混合公式实际挑战的动手经验 [@problem_id:3325811]。", "problem": "您需要推导、离散化并实现一个用于静磁学中矢量势的混合有限元法 (FEM) 公式，该公式使用适当的 $H(\\mathrm{curl})$ 和 $H(\\mathrm{div})$ 相容离散空间来强制执行库仑规范，并通过罚方法和拉格朗日乘子两种方式来施加约束。从静磁学中带有矢量势和库仑规范的麦克斯韦方程组的基本基础出发，推导出一个一致的弱形式，然后在一个结构化网格上构建一个计算上可实现的离散系统。实现这两种约束施加策略，并通过报告计算出的矢量势的离散散度来数值比较它们的有效性。所有量均为无量纲。\n\n从单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上的静磁矢量势公式开始，该公式具有恒定的磁导率和一个线性稳定项：\n求一个矢量势 $\\mathbf{A}$，使得\n$$\n\\nabla \\times (\\nabla \\times \\mathbf{A}) + \\alpha \\mathbf{A} = \\mathbf{J} \\quad \\text{in } \\Omega\n$$\n同时满足库仑规范\n$$\n\\nabla \\cdot \\mathbf{A} = 0 \\quad \\text{in } \\Omega,\n$$\n其中 $\\alpha > 0$ 是一个正常数，$\\mathbf{J}$ 是一个给定的源场。假设自由切向边界条件足以构成一个适定的弱形式。\n\n通过选择适当的索博列夫空间，并通过罚方法或标量拉格朗日乘子为静磁方程增加一个约束，来推导出一个混合弱形式。使用以下符合上下文的基本基础：\n- 麦克斯韦静磁方程组和矢量势的定义。\n- 库仑规范条件。\n- 标准的 $H(\\mathrm{curl})$ 和 $H(\\mathrm{div})$ 空间定义以及德拉姆复形关系。\n- 旋度和散度的分部积分恒等式。\n\n在您的推导中，您必须：\n- 为 $\\mathbf{A}$ 和乘子选择试探空间和检验空间，以使离散空间遵循网格上的 $H(\\mathrm{curl})$ 和 $H(\\mathrm{div})$ 相容性以及拓扑恒等式。\n- 从连续方程出发，清晰地写出罚公式和拉格朗日乘子公式的弱形式。\n\n然后，为了计算实现，使用一个结构化矩形网格，其在 $x$ 方向有 $N_x$ 个单元，在 $y$ 方向有 $N_y$ 个单元，其中 $N_x,N_y \\in \\mathbb{N}$。在此网格上构建以下模拟 $H(\\mathrm{curl})$ 和 $H(\\mathrm{div})$ 相容空间的离散算子：\n- 基于边的 $\\mathbf{A}$ 未知数代表一个离散的 $H(\\mathrm{curl})$ 空间，其中水平边的方向设为 $+x$，垂直边的方向设为 $+y$。设边质量矩阵为一个对角矩阵 $M_e$，其对角元等于边长（水平边为 $\\Delta x$，垂直边为 $\\Delta y$）。\n- 从节点到边的关联矩阵 $G$ 近似离散梯度，对于每条边，其在尾节点的项为 $-1$，在头节点的项为 $+1$。\n- 从边到面的关联矩阵 $C$ 近似离散旋度，对于每个面，其底、右、顶、左四条边的系数分别为 $(+1,+1,-1,-1)$，与逆时针方向一致。设面质量矩阵为一个对角矩阵 $M_f$，其对角元等于单元面积 $\\Delta x \\Delta y$。\n\n使用这些算子，定义进入线性系统的离散算子：\n- 作用于边未知数上的离散旋度-旋度算子 $K = C^\\top M_f C + \\alpha M_e$。\n- 边场的离散散度为 $D \\mathbf{a} = G^\\top M_e \\mathbf{a}$，作用于节点上，与弱形式 $(\\nabla \\cdot \\mathbf{A}, \\eta) = -(\\mathbf{A}, \\nabla \\eta)$ 一致。\n\n通过在边的中点采样一个光滑的无散度场 $\\mathbf{J}(x,y)$，并将其投影到边的切线上，再按边长缩放，来近似源项。使用无散度场\n$$\n\\mathbf{J}(x,y) = \\begin{bmatrix}\n\\sin(\\pi x)\\cos(\\pi y) \\\\\n-\\cos(\\pi x)\\sin(\\pi y)\n\\end{bmatrix}.\n$$\n\n实现两种约束施加策略：\n- 罚方法：使用以下系统求解边系数 $\\mathbf{a}$\n$$\n\\left(K + \\beta\\, M_e G G^\\top M_e\\right)\\mathbf{a} = \\mathbf{j},\n$$\n其中 $\\beta > 0$ 是罚参数，$\\mathbf{j}$ 是通过将 $\\mathbf{J}$ 投影到边切线得到的边载荷向量。\n- 拉格朗日乘子法：求解关于 $(\\mathbf{a}, \\boldsymbol{\\lambda})$ 的鞍点系统\n$$\n\\begin{bmatrix}\nK  -M_e G \\\\\nG^\\top M_e  -\\tau I\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{a} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{j} \\\\\n\\mathbf{0}\n\\end{bmatrix},\n$$\n其中 $\\tau > 0$ 是一个小的稳定参数，通过消除常数零空间来确保乘子的唯一性。约束 $G^\\top M_e \\mathbf{a} = \\mathbf{0}$ 在离散意义上强制执行库仑规范。\n\n您必须通过报告在节点上计算的离散散度的欧几里得范数，为每个测试用例提供库仑规范被强制执行的数值证据，其计算公式为\n$$\n\\|D\\mathbf{a}\\|_2 = \\sqrt{(D\\mathbf{a})^\\top (D\\mathbf{a})},\n$$\n。\n\n您的程序应仅使用 Python 标准库、NumPy 和 SciPy 来实现网格构建、算子组装、源投影和线性求解。所有量均为无量纲，不需要物理单位。如果涉及角度，必须使用弧度，但此处不涉及。\n\n测试套件：\n提供以下五个测试用例的结果，这些用例共同探究了一般行为和边界情况：\n- 用例 1：$N_x = 4$，$N_y = 4$，$\\alpha = 1$，使用罚方法强制执行，$\\beta = 0$（无规范惩罚）。\n- 用例 2：$N_x = 4$，$N_y = 4$，$\\alpha = 1$，使用罚方法强制执行，$\\beta = 1$（中等惩罚）。\n- 用例 3：$N_x = 4$，$N_y = 4$，$\\alpha = 1$，使用罚方法强制执行，$\\beta = 10^6$（非常强的惩罚）。\n- 用例 4：$N_x = 4$，$N_y = 4$，$\\alpha = 1$，使用拉格朗日乘子法强制执行，$\\tau = 10^{-8}$。\n- 用例 5：边界情况，$N_x = 1$，$N_y = 1$，$\\alpha = 1$，使用拉格朗日乘子法强制执行，$\\tau = 10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个案例的离散散度的欧几里得范数，形式为用方括号括起来的逗号分隔列表，例如：\n$$\n[\\rho_1,\\rho_2,\\rho_3,\\rho_4,\\rho_5],\n$$\n其中每个 $\\rho_k$ 是一个浮点数。输出不得包含任何空格。", "solution": "该问题要求推导和实现一个用于静磁矢量势公式的混合有限元法，其中库仑规范通过两种不同的方法强制执行：罚方法和拉格朗日乘子法。解决方案将首先从控制偏微分方程建立连续弱形式，然后在本弱形式的背景下描述问题陈述中提供的离散系统，最后详细说明数值实现。\n\n我们从域 $\\Omega = [0,1]^2$ 上的控制偏微分方程开始：\n$$\n\\nabla \\times (\\nabla \\times \\mathbf{A}) + \\alpha \\mathbf{A} = \\mathbf{J} \\quad \\text{in } \\Omega\n$$\n$$\n\\nabla \\cdot \\mathbf{A} = 0 \\quad \\text{in } \\Omega\n$$\n在这里，$\\mathbf{A}$ 是磁矢量势，$\\mathbf{J}$ 是给定的电流密度，$\\alpha > 0$ 是一个标量常数。第一个方程是安培定律结合本构关系和一个类质量稳定项的陈述，而第二个方程是库仑规范条件。\n\n为了推导弱形式，我们为试探函数 $\\mathbf{A}$ 和检验函数选择适当的函数空间。对于旋度是平方可积的矢量场，其自然空间是 $H(\\mathrm{curl}; \\Omega)$，定义为 $\\mathbf{V} = \\{\\mathbf{u} \\in (L^2(\\Omega))^2 \\mid \\nabla \\times \\mathbf{u} \\in L^2(\\Omega)\\}$。我们将主偏微分方程乘以一个任意的检验函数 $\\mathbf{v} \\in \\mathbf{V}$，并在域 $\\Omega$ 上积分：\n$$\n\\int_{\\Omega} (\\nabla \\times (\\nabla \\times \\mathbf{A})) \\cdot \\mathbf{v} \\, d\\Omega + \\int_{\\Omega} \\alpha \\mathbf{A} \\cdot \\mathbf{v} \\, d\\Omega = \\int_{\\Omega} \\mathbf{J} \\cdot \\mathbf{v} \\, d\\Omega\n$$\n使用分部积分的矢量微积分恒等式 $\\int_{\\Omega} (\\nabla \\times \\mathbf{F}) \\cdot \\mathbf{G} \\, d\\Omega = \\int_{\\Omega} \\mathbf{F} \\cdot (\\nabla \\times \\mathbf{G}) \\, d\\Omega - \\oint_{\\partial\\Omega} (\\mathbf{n} \\times \\mathbf{F}) \\cdot \\mathbf{G} \\, dS$，我们可以重写第一项：\n$$\n\\int_{\\Omega} (\\nabla \\times (\\nabla \\times \\mathbf{A})) \\cdot \\mathbf{v} \\, d\\Omega = \\int_{\\Omega} (\\nabla \\times \\mathbf{A}) \\cdot (\\nabla \\times \\mathbf{v}) \\, d\\Omega - \\oint_{\\partial\\Omega} (\\mathbf{n} \\times (\\nabla \\times \\mathbf{A})) \\cdot \\mathbf{v} \\, dS\n$$\n问题指定了“自由切向边界条件”，这属于自然边界条件。这意味着边界积分项为零。这导出了未施加规范问题的弱形式：求 $\\mathbf{A} \\in \\mathbf{V}$，使得对于所有 $\\mathbf{v} \\in \\mathbf{V}$，\n$$\n(\\nabla \\times \\mathbf{A}, \\nabla \\times \\mathbf{v})_{L^2} + \\alpha (\\mathbf{A}, \\mathbf{v})_{L^2} = (\\mathbf{J}, \\mathbf{v})_{L^2}\n$$\n其中 $(\\cdot, \\cdot)_{L^2}$ 表示在 $\\Omega$ 上的 $L^2$ 内积。\n\n现在，我们引入库仑规范约束 $\\nabla \\cdot \\mathbf{A} = 0$。\n\n**1. 罚方法**\n罚方法通过一个惩罚偏离约束的项来增强弱形式。问题指定了一种特定的离散罚形式。待求解的离散系统为：\n$$\n(K + \\beta M_e G G^\\top M_e)\\mathbf{a} = \\mathbf{j}\n$$\n在这里，$\\mathbf{a}$ 和 $\\mathbf{j}$ 分别是离散势和源的系数向量。矩阵 $K = C^\\top M_f C + \\alpha M_e$ 代表了未施加规范的弱形式左侧的离散化。项 $G^\\top M_e$ 是离散散度算子 $D$，而 $M_e G G^\\top M_e$ 是罚的矩阵表示。相应的离散弱形式为：\n$$\n\\mathbf{v}^\\top K \\mathbf{a} + \\beta (G^\\top M_e \\mathbf{v})^\\top (G^\\top M_e \\mathbf{a}) = \\mathbf{v}^\\top \\mathbf{j}\n$$\n这种形式惩罚了离散散度向量 $D\\mathbf{a} = G^\\top M_e \\mathbf{a}$ 的欧几里得范数的平方，其中 $\\beta > 0$ 是罚参数。当 $\\beta \\to \\infty$ 时，解 $\\mathbf{a}$ 被驱动以满足 $D\\mathbf{a} = 0$。\n\n**2. 拉格朗日乘子法**\n该方法引入一个拉格朗日乘子场 $p$ 来精确地强制执行约束。此乘子的自然函数空间是 $Q = H^1(\\Omega)$。我们寻求一个拉格朗日泛函的鞍点 $(\\mathbf{A}, p) \\in \\mathbf{V} \\times Q$。这导出了一个混合弱形式。问题指定了一个离散系统：\n$$\n\\begin{bmatrix}\nK  -M_e G \\\\\nG^\\top M_e  -\\tau I\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mathbf{a} \\\\\n\\boldsymbol{\\lambda}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{j} \\\\\n\\mathbf{0}\n\\end{bmatrix}\n$$\n这个系统是以下混合弱形式的离散表示：求 $(\\mathbf{A}, p) \\in \\mathbf{V} \\times Q$，使得对于所有检验函数 $(\\mathbf{v}, q) \\in \\mathbf{V} \\times Q$：\n$$\n(\\nabla \\times \\mathbf{A}, \\nabla \\times \\mathbf{v}) + \\alpha(\\mathbf{A}, \\mathbf{v}) - (\\mathbf{v}, \\nabla p) = (\\mathbf{J}, \\mathbf{v})\n$$\n$$\n(\\nabla \\cdot \\mathbf{A}, q) - \\tau(p, q) = 0\n$$\n耦合项 $(\\mathbf{v}, \\nabla p)$ 的符号选择是一种约定；这里给出的负号导致系统矩阵中出现 $-M_e G$ 块。如果乘子变量是 $\\boldsymbol{\\lambda}$，该项离散化为 $\\mathbf{v}^\\top M_e G \\boldsymbol{\\lambda}$。第二个方程弱形式地强制执行库仑规范，因为 $(\\nabla \\cdot \\mathbf{A}, q) = -(\\mathbf{A}, \\nabla q)$，它离散化为 $\\boldsymbol{q}^\\top G^\\top M_e \\mathbf{a}$。小参数 $\\tau > 0$ 引入了一个稳定项 $-\\tau (p,q)$，它通过消除乘子 $p$ 的常数零空间来确保整个系统矩阵是可逆的。\n\n**在结构化网格上的离散化**\n问题规定了一种基于结构化矩形网格和有限元外微分概念的离散化方法。矢量势 $\\mathbf{A}$ 使用 Nédélec 边元进行近似，其中自由度是 $\\mathbf{A}$ 沿着网格每条边的切向分量。拉格朗日乘子 $p$ 使用标准的节点元进行近似。\n- 矩阵 $G$ 是离散梯度算子，将节点值映射到边值。\n- 矩阵 $C$ 是离散旋度算子，将边值映射到面值。\n- $M_e$ 和 $M_f$ 是质量矩阵，它们考虑了边和面的几何尺寸，将求和转化为离散积分近似。\n复合算子 $C^\\top M_f C$ 是矢量拉普拉斯算子 $\\nabla \\times \\nabla \\times$ 的离散表示。算子 $G^\\top M_e$ 是离散散度。这个框架确保了像 $\\nabla \\times (\\nabla \\phi) = 0$ 这样的基本恒等式在离散层面作为 $C G = 0$ 精确成立。实现过程将构建这些离散算子，并为每个测试用例求解指定的线性系统，最终报告离散散度向量 $D\\mathbf{a} = G^\\top M_e \\mathbf{a}$ 的欧几里得范数，作为规范强制执行程度的度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef source_field_J(x, y):\n    \"\"\"Computes the source vector field J at a given point (x, y).\"\"\"\n    Jx = np.sin(np.pi * x) * np.cos(np.pi * y)\n    Jy = -np.cos(np.pi * x) * np.sin(np.pi * y)\n    return np.array([Jx, Jy])\n\ndef build_operators(Nx, Ny):\n    \"\"\"\n    Constructs the discrete operators G, C and mass matrices Me, Mf\n    for a structured rectangular mesh of size Nx by Ny.\n    \"\"\"\n    dx, dy = 1.0 / Nx, 1.0 / Ny\n    \n    # --- Indexing ---\n    num_nodes = (Nx + 1) * (Ny + 1)\n    num_h_edges = Nx * (Ny + 1)\n    num_v_edges = (Nx + 1) * Ny\n    num_edges = num_h_edges + num_v_edges\n    num_faces = Nx * Ny\n    \n    # Helper functions for indexing\n    def node_idx(i, j): return j * (Nx + 1) + i\n    def h_edge_idx(i, j): return j * Nx + i\n    def v_edge_idx(i, j): return num_h_edges + i * Ny + j\n    def face_idx(i, j): return j * Nx + i\n\n    # --- Gradient Operator G (nodes to edges) ---\n    G = sparse.lil_matrix((num_edges, num_nodes), dtype=np.float64)\n    # Horizontal edges\n    for j in range(Ny + 1):\n        for i in range(Nx):\n            edge = h_edge_idx(i, j)\n            node_tail = node_idx(i, j)\n            node_head = node_idx(i + 1, j)\n            G[edge, node_tail] = -1\n            G[edge, node_head] = 1\n    # Vertical edges\n    for i in range(Nx + 1):\n        for j in range(Ny):\n            edge = v_edge_idx(i, j)\n            node_tail = node_idx(i, j)\n            node_head = node_idx(i, j + 1)\n            G[edge, node_tail] = -1\n            G[edge, node_head] = 1\n\n    # --- Curl Operator C (edges to faces) ---\n    C = sparse.lil_matrix((num_faces, num_edges), dtype=np.float64)\n    for j in range(Ny):\n        for i in range(Nx):\n            face = face_idx(i, j)\n            # Bottom, Right, Top, Left edges\n            edge_b = h_edge_idx(i, j)\n            edge_r = v_edge_idx(i + 1, j)\n            edge_t = h_edge_idx(i, j + 1)\n            edge_l = v_edge_idx(i, j)\n            # CCW orientation: +1, +1, -1, -1\n            C[face, edge_b] = 1\n            C[face, edge_r] = 1\n            C[face, edge_t] = -1\n            C[face, edge_l] = -1\n\n    # --- Mass Matrices ---\n    # Edge mass matrix Me\n    me_diag = np.concatenate([np.full(num_h_edges, dx), np.full(num_v_edges, dy)])\n    Me = sparse.diags(me_diag, format='csr')\n    # Face mass matrix Mf\n    mf_diag = np.full(num_faces, dx * dy)\n    Mf = sparse.diags(mf_diag, format='csr')\n    \n    return G.tocsr(), C.tocsr(), Me, Mf\n\ndef assemble_source_vector(Nx, Ny):\n    \"\"\"Assembles the source vector j by projecting J onto edge tangents.\"\"\"\n    dx, dy = 1.0 / Nx, 1.0 / Ny\n    num_h_edges = Nx * (Ny + 1)\n    num_v_edges = (Nx + 1) * Ny\n    num_edges = num_h_edges + num_v_edges\n\n    j_vec = np.zeros(num_edges)\n\n    # Horizontal edges\n    for j_idx in range(Ny + 1):\n        for i_idx in range(Nx):\n            mid_x = (i_idx + 0.5) * dx\n            mid_y = j_idx * dy\n            Jx, _ = source_field_J(mid_x, mid_y)\n            edge_idx = j_idx * Nx + i_idx\n            j_vec[edge_idx] = Jx * dx\n\n    # Vertical edges\n    for i_idx in range(Nx + 1):\n        for j_idx in range(Ny):\n            mid_x = i_idx * dx\n            mid_y = (j_idx + 0.5) * dy\n            _, Jy = source_field_J(mid_x, mid_y)\n            edge_idx = num_h_edges + i_idx * Ny + j_idx\n            j_vec[edge_idx] = Jy * dy\n            \n    return j_vec\n\ndef solve():\n    \"\"\"\n    Solves the magnetostatic problem for the specified test cases and\n    prints the norms of the discrete divergence.\n    \"\"\"\n    test_cases = [\n        {'Nx': 4, 'Ny': 4, 'alpha': 1.0, 'method': 'penalty', 'param': 0.0},\n        {'Nx': 4, 'Ny': 4, 'alpha': 1.0, 'method': 'penalty', 'param': 1.0},\n        {'Nx': 4, 'Ny': 4, 'alpha': 1.0, 'method': 'penalty', 'param': 1e6},\n        {'Nx': 4, 'Ny': 4, 'alpha': 1.0, 'method': 'lagrange', 'param': 1e-8},\n        {'Nx': 1, 'Ny': 1, 'alpha': 1.0, 'method': 'lagrange', 'param': 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, Ny = case['Nx'], case['Ny']\n        alpha = case['alpha']\n        method = case['method']\n        param = case['param']\n\n        G, C, Me, Mf = build_operators(Nx, Ny)\n        j = assemble_source_vector(Nx, Ny)\n\n        K = C.transpose() @ Mf @ C + alpha * Me\n\n        if method == 'penalty':\n            beta = param\n            # System: (K + beta * Me @ G @ G.T @ Me) a = j\n            A_pen = K + beta * (Me @ G @ G.transpose() @ Me)\n            a = spsolve(A_pen, j)\n        \n        elif method == 'lagrange':\n            tau = param\n            num_edges = K.shape[0]\n            num_nodes = G.shape[1]\n            \n            # System matrix A_lag\n            A_lag = sparse.bmat([\n                [K, -Me @ G],\n                [G.transpose() @ Me, sparse.diags([-tau] * num_nodes, format='csr')]\n            ], format='csc')\n            \n            # RHS vector b_lag\n            b_lag = np.concatenate([j, np.zeros(num_nodes)])\n            \n            sol = spsolve(A_lag, b_lag)\n            a = sol[:num_edges]\n            \n        # Compute discrete divergence and its norm\n        div_a = G.transpose() @ Me @ a\n        norm_div_a = np.linalg.norm(div_a)\n        results.append(norm_div_a)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3325811"}, {"introduction": "对于周期性边界条件问题，谱方法能提供极高的精度，并为施加规范条件提供了独特的视角。本练习聚焦于傅里叶空间中的亥姆霍兹分解，该方法能将矢量场清晰地分离为其纵向分量和横向（无散）分量。您将实现横向投影算子，这是库仑规范下谱方法求解器的基石，并研究因处理 $\\mathbf{k}=\\mathbf{0}$ 处奇异点所需的正则化而引入的数值误差 [@problem_id:3325815]。", "problem": "考虑一个边长为 $L$ 的三维周期性域，该域被均匀离散化为 $N \\times N \\times N$ 个网格点。设 $\\mathbf{J}(\\mathbf{x})$ 是一个矢量场，表示在该网格上采样的电流密度。在计算电磁学中，强制执行库仑规范条件（对于矢量势 $\\mathbf{A}$，$\\nabla \\cdot \\mathbf{A} = 0$）并将 $\\mathbf{J}$ 分离为纵向和横向分量的算法依赖于谱（傅里叶空间）亥姆霍兹分解。连续性方程 $\\nabla \\cdot \\mathbf{J} + \\partial_t \\rho = 0$ 和麦克斯韦方程组促使将 $\\mathbf{J}$ 分离为一个无散度（横向）部分和一个无旋（纵向）部分。在谱求解器中，这是通过在波矢空间中应用一个投影算子来分离出横向分量来实现的。然而，在数值上实现此投影需要谨慎处理 $\\mathbf{k} = \\mathbf{0}$ 模式和小的 $|\\mathbf{k}|$ 值，因为在这些情况下算子会变得病态。\n\n你的任务是：\n- 根据亥姆霍兹分解的傅里叶空间表述以及散度和旋度的性质，推导将任意 $\\mathbf{J}$ 映射到波矢空间中无散度分量的横向投影算子的形式。\n- 在谱求解器中实现此投影，并量化在 $\\mathbf{k} = \\mathbf{0}$ 附近对算子进行正则化所引入的数值误差。在你的实现中，使用一个由参数 $\\varepsilon > 0$ 控制的正则化分母。\n- 构建一个合成的 $\\mathbf{J}(\\mathbf{x})$，使其包含纵向和横向分量，以及一个非零的空间均匀（直流）分量，从而可以检验投影的所有相关行为。使用基波数为 $k_1 = 2\\pi/L$ 的平滑三角函数场进行构建。\n\n出发的基础理论：\n- 微分形式的麦克斯韦方程组和连续性方程 $\\nabla \\cdot \\mathbf{J} + \\partial_t \\rho = 0$。\n- 亥姆霍兹分解：周期性域上每个足够平滑的矢量场都可以唯一地分解为一个无散度分量和一个无旋分量。\n- 空间导数的傅里叶变换性质：对于函数 $f(\\mathbf{x})$ 及其傅里叶变换 $\\hat{f}(\\mathbf{k})$，$\\nabla f \\leftrightarrow i\\mathbf{k}\\hat{f}$；对于矢量场 $\\mathbf{v}$，$\\nabla \\cdot \\mathbf{v} \\leftrightarrow i\\mathbf{k} \\cdot \\hat{\\mathbf{v}}$。\n\n实现细节：\n- 使用一个周期性立方域，其中 $L = 64\\pi$ 且 $N = 32$。令 $k_1 = 2\\pi / L$。定义标量势 $\\phi(\\mathbf{x}) = a \\cos(k_1 x) + b \\cos(k_1 y) + c \\cos(k_1 z)$，其中常数 $a=1.1$，$b=0.9$，$c=1.3$。定义矢量势 $\\mathbf{W}(\\mathbf{x}) = \\big(A \\sin(k_1 y) + A_2 \\sin(2k_1 y),\\; B \\sin(k_1 z),\\; C \\sin(k_1 x)\\big)$，其中常数 $A=0.7$，$A_2=0.2$，$B=0.5$，$C=0.8$。将电流场构建为\n$$\n\\mathbf{J}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x}) + \\nabla \\times \\mathbf{W}(\\mathbf{x}) + \\mathbf{d},\n$$\n其中 $\\mathbf{d} = (0.05, -0.03, 0.02)$ 是一个常矢量。在网格点上解析地计算 $\\nabla \\phi$ 和 $\\nabla \\times \\mathbf{W}$。\n- 通过将 $\\mathbf{J}$ 变换到傅里叶空间，应用参数为 $\\varepsilon$ 的正则化横向投影，然后变换回来，以实现谱投影。为了获得精确参考，请实现非正则化的投影，并根据周期性亥姆霍兹分解，对 $\\mathbf{k}=\\mathbf{0}$ 进行精确处理。\n- 完全在傅里叶空间中，使用帕塞瓦尔定理量化以下误差（无需物理单位）：\n    1. 投影场的归一化散度残差，\n    $$\n    D(\\varepsilon) = \\frac{\\left\\|\\mathbf{k} \\cdot \\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}}\\right\\|_2}{\\left\\|\\widehat{\\mathbf{J}}\\right\\|_2},\n    $$\n    其中 $\\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}}$ 是正则化投影场的傅里叶变换，$\\|\\cdot\\|_2$ 表示在所有离散波矢上的欧几里得范数。\n    2. 与精确横向投影的相对差异，\n    $$\n    E(\\varepsilon) = \\frac{\\left\\|\\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}} - \\widehat{\\mathbf{J}_\\perp^{\\text{exact}}}\\right\\|_2}{\\left\\|\\widehat{\\mathbf{J}_\\perp^{\\text{exact}}}\\right\\|_2},\n    $$\n    其中 $\\widehat{\\mathbf{J}_\\perp^{\\text{exact}}}$ 是对 $\\mathbf{k}=\\mathbf{0}$ 进行了适当处理的精确（非正则化）横向投影的傅里叶变换。\n    3. 正则化投影的幂等误差（即应用两次投影与应用一次投影的偏差），\n    $$\n    I(\\varepsilon) = \\frac{\\left\\|\\widehat{P_\\varepsilon\\left(P_\\varepsilon \\mathbf{J}\\right)} - \\widehat{P_\\varepsilon \\mathbf{J}}\\right\\|_2}{\\left\\|\\widehat{P_\\varepsilon \\mathbf{J}}\\right\\|_2},\n    $$\n    其中 $\\widehat{P_\\varepsilon \\mathbf{J}}$ 表示傅里叶空间中的正则化投影场。\n\n测试套件：\n- 使用正则化参数 $\\varepsilon$ 的三个值来探测相对于最小非零波数 $k_{\\min} = 2\\pi/L$ 的不同区域：\n    1. $\\varepsilon_1 = 10^{-18} k_{\\min}$ (可忽略的正则化)。\n    2. $\\varepsilon_2 = k_{\\min}$ (与最小非零波数相当的正则化)。\n    3. $\\varepsilon_3 = 5 k_{\\min}$ (强正则化)。\n- 对于测试套件中的每个 $\\varepsilon$，计算并报告三元组 $\\big(D(\\varepsilon), E(\\varepsilon), I(\\varepsilon)\\big)$ 作为浮点数值。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身也是一个用方括号括起来的、包含三个浮点数的逗号分隔列表。例如，输出应具有以下形式\n$$\n[ [D(\\varepsilon_1),E(\\varepsilon_1),I(\\varepsilon_1)], [D(\\varepsilon_2),E(\\varepsilon_2),I(\\varepsilon_2)], [D(\\varepsilon_3),E(\\varepsilon_3),I(\\varepsilon_3)] ].\n$$\n不使用角度，也没有物理单位；所有量均为无量纲。", "solution": "该问题是有效的，因为它在科学上基于麦克斯韦理论和矢量微积分，问题设定良好并提供了所有必要的数据，且以客观、正式的语言陈述。我们将着手提供一个解决方案。\n\n问题的核心是将周期性域上的矢量场 $\\mathbf{J}$ 进行亥姆霍兹-霍奇分解，分解为一个无旋（纵向）分量 $\\mathbf{J}_L$ 和一个无散（横向）分量 $\\mathbf{J}_T$：\n$$\n\\mathbf{J} = \\mathbf{J}_L + \\mathbf{J}_T\n$$\n其中 $\\nabla \\times \\mathbf{J}_L = \\mathbf{0}$ 且 $\\nabla \\cdot \\mathbf{J}_T = \\mathbf{0}$。该分解还包括一个谐波分量，对于周期性域，这只是一个常矢量。问题陈述中的构造式 $\\mathbf{J}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x}) + \\nabla \\times \\mathbf{W}(\\mathbf{x}) + \\mathbf{d}$ 将场明确地分离为其纵向部分 $\\mathbf{J}_L = \\nabla \\phi$、其横向部分 $\\mathbf{J}_T' = \\nabla \\times \\mathbf{W}$ 和一个常数（直流）分量 $\\mathbf{d}$。一个常矢量既是无旋的也是无散的。根据周期性系统中的惯例，要求纵向场的空间平均值为零。这意味着常数部分 $\\mathbf{d}$ 被归入横向分量，使得完整的横向场为 $\\mathbf{J}_T = \\nabla \\times \\mathbf{W} + \\mathbf{d}$。\n\n在傅里叶空间中进行分离最为方便。设 $\\hat{\\mathbf{J}}(\\mathbf{k})$ 是 $\\mathbf{J}(\\mathbf{x})$ 的傅里叶变换。散度和旋度的微分算子在傅里叶空间中变成代数运算：\n$$\n\\nabla \\cdot \\mathbf{J} \\quad \\xrightarrow{\\mathcal{F}} \\quad i\\mathbf{k} \\cdot \\hat{\\mathbf{J}}(\\mathbf{k})\n$$\n$$\n\\nabla \\times \\mathbf{J} \\quad \\xrightarrow{\\mathcal{F}} \\quad i\\mathbf{k} \\times \\hat{\\mathbf{J}}(\\mathbf{k})\n$$\n傅里叶空间中对纵向和横向分量的条件是：\n$$\n\\mathbf{k} \\times \\hat{\\mathbf{J}}_L(\\mathbf{k}) = \\mathbf{0}\n$$\n$$\n\\mathbf{k} \\cdot \\hat{\\mathbf{J}}_T(\\mathbf{k}) = \\mathbf{0}\n$$\n对于任意非零波矢 $\\mathbf{k}$，条件 $\\mathbf{k} \\times \\hat{\\mathbf{J}}_L = \\mathbf{0}$ 意味着 $\\hat{\\mathbf{J}}_L$ 必须与 $\\mathbf{k}$ 平行。条件 $\\mathbf{k} \\cdot \\hat{\\mathbf{J}}_T = \\mathbf{0}$ 意味着 $\\hat{\\mathbf{J}}_T$ 必须与 $\\mathbf{k}$ 垂直。\n\n为了找到纵向分量 $\\hat{\\mathbf{J}}_L$，我们将总场 $\\hat{\\mathbf{J}}$ 投影到波矢 $\\mathbf{k}$ 的方向上。矢量 $\\mathbf{A}$ 到矢量 $\\mathbf{B}$ 上的投影由 $\\frac{\\mathbf{A} \\cdot \\mathbf{B}}{|\\mathbf{B}|^2}\\mathbf{B}$ 给出。因此，对于 $\\mathbf{k} \\neq \\mathbf{0}$：\n$$\n\\hat{\\mathbf{J}}_L(\\mathbf{k}) = \\frac{\\hat{\\mathbf{J}}(\\mathbf{k}) \\cdot \\mathbf{k}}{|\\mathbf{k}|^2}\\mathbf{k}\n$$\n这可以用一个投影算子来表示。在并矢符号中，纵向投影算子是 $\\hat{P}_L(\\mathbf{k}) = \\frac{\\mathbf{k} \\otimes \\mathbf{k}}{|\\mathbf{k}|^2}$。在笛卡尔索引表示法中，这是 $(\\hat{P}_L)_{ij} = \\frac{k_i k_j}{|\\mathbf{k}|^2}$。\n\n然后通过从总场中减去纵向分量来找到横向分量：\n$$\n\\hat{\\mathbf{J}}_T(\\mathbf{k}) = \\hat{\\mathbf{J}}(\\mathbf{k}) - \\hat{\\mathbf{J}}_L(\\mathbf{k}) = \\hat{\\mathbf{J}}(\\mathbf{k}) - \\frac{(\\hat{\\mathbf{J}}(\\mathbf{k}) \\cdot \\mathbf{k})}{|\\mathbf{k}|^2}\\mathbf{k}\n$$\n因此，横向投影算子 $\\hat{P}_T$ 是 $\\hat{P}_T = I - \\hat{P}_L$，其中 $I$ 是单位算子。其显式形式为：\n$$\n(\\hat{P}_T)_{ij} = \\delta_{ij} - \\frac{k_i k_j}}{|\\mathbf{k}|^2}\n$$\n其中 $\\delta_{ij}$ 是克罗内克 δ。\n\n在 $\\mathbf{k} = \\mathbf{0}$ 处会出现一个关键问题，此时分母 $|\\mathbf{k}|^2$ 为零，使算子奇异。$\\mathbf{k} = \\mathbf{0}$ 模式代表场的空间均匀（直流）分量，即空间平均值。如前所述，常矢量既是无散的也是无旋的。周期性域上的唯一定义要求纵向分量的平均值为零，即 $\\hat{\\mathbf{J}}_L(\\mathbf{k}=\\mathbf{0}) = \\mathbf{0}$。因此，$\\mathbf{J}$ 的整个直流分量必须归于横向部分：\n$$\n\\hat{\\mathbf{J}}_T(\\mathbf{k}=\\mathbf{0}) = \\hat{\\mathbf{J}}(\\mathbf{k}=\\mathbf{0})\n$$\n这就从数值上定义了“精确”投影：一个用于 $\\mathbf{k} \\neq \\mathbf{0}$ 的公式和一个用于 $\\mathbf{k} = \\mathbf{0}$ 的特例。\n\n处理这种奇异性的一种常见数值技术是正则化。分母 $|\\mathbf{k}|^2$ 被替换为一个正则化版本 $|\\mathbf{k}|^2 + \\varepsilon^2$，其中 $\\varepsilon$ 是一个小的正参数。$\\hat{\\mathbf{J}}$ 的正则化横向投影为：\n$$\n\\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}}(\\mathbf{k}) = \\hat{\\mathbf{J}}(\\mathbf{k}) - \\frac{(\\hat{\\mathbf{J}}(\\mathbf{k}) \\cdot \\mathbf{k})}{|\\mathbf{k}|^2 + \\varepsilon^2}\\mathbf{k}\n$$\n这种表述的优点在于对所有 $\\mathbf{k}$ 都是非奇异的。在 $\\mathbf{k}=\\mathbf{0}$ 处，分子 $(\\hat{\\mathbf{J}} \\cdot \\mathbf{k})\\mathbf{k}$ 为 $\\mathbf{0}$，分母为 $\\varepsilon^2 \\neq 0$。因此，相减项消失，我们正确地得到 $\\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}}(\\mathbf{k}=\\mathbf{0}) = \\hat{\\mathbf{J}}(\\mathbf{k}=\\mathbf{0})$，这与精确处理方法一致。然而，对于 $\\mathbf{k} \\neq \\mathbf{0}$，该算子只是真实横向投影的一个近似。参数 $\\varepsilon$ 控制着权衡：较小的 $\\varepsilon$ 对大的 $|\\mathbf{k}|$ 给出更好的近似，但对于非常小的非零 $|\\mathbf{k}|$ 可能导致浮点问题。本练习的目的是量化这种近似误差。\n\n要实现的算法如下：\n1.  定义计算域，其中每维 $L=64\\pi$ 且有 $N=32$ 个点。\n2.  使用 `fftfreq` 构建空间网格和相应的波矢网格。最小非零波数的大小为 $k_{\\min} = 2\\pi/L$。\n3.  在空间网格上解析计算电流密度 $\\mathbf{J}(\\mathbf{x}) = \\nabla \\phi(\\mathbf{x}) + \\nabla \\times \\mathbf{W}(\\mathbf{x}) + \\mathbf{d}$ 的分量。\n4.  计算 $\\mathbf{J}$ 的每个分量的三维离散傅里叶变换，以获得 $\\hat{J}_x, \\hat{J}_y, \\hat{J}_z$。\n5.  计算 $\\hat{\\mathbf{J}}$ 的范数 $\\left\\|\\widehat{\\mathbf{J}}\\right\\|_2$，用于归一化。\n6.  通过应用投影算子并按前述方式对 $\\mathbf{k}=\\mathbf{0}$ 模式进行特定检查，来实现精确投影 $\\widehat{\\mathbf{J}_\\perp^{\\text{exact}}}$。\n7.  对于给定的每个正则化参数 $\\varepsilon$ 值，实现正则化投影 $\\widehat{\\mathbf{J}_\\perp^{(\\varepsilon)}}$。\n8.  通过完全在傅里叶空间中计算所需的点积和范数来计算误差度量 $D(\\varepsilon)$、$E(\\varepsilon)$ 和 $I(\\varepsilon)$。对于幂等误差 $I(\\varepsilon)$，将正则化投影算子第二次应用于已经投影过的场。所有范数都是k空间中复值网格函数的标准欧几里得范数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational electromagnetics problem of spectral projection.\n    \"\"\"\n    # 1. Define parameters and construct grids\n    L = 64.0 * np.pi\n    N = 32\n    a, b, c = 1.1, 0.9, 1.3\n    A, A2, B, C = 0.7, 0.2, 0.5, 0.8\n    d = np.array([0.05, -0.03, 0.02])\n    \n    k1 = 2.0 * np.pi / L\n    k_min = k1\n\n    # Spatial grid\n    grid_1d = np.linspace(0, L, N, endpoint=False)\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # 2. Construct the synthetic current density J(x)\n    # J_L = grad(phi)\n    J_L_x = -a * k1 * np.sin(k1 * x)\n    J_L_y = -b * k1 * np.sin(k1 * y)\n    J_L_z = -c * k1 * np.sin(k1 * z)\n    \n    # J_T' = curl(W)\n    J_T_prime_x = -B * k1 * np.cos(k1 * z)\n    J_T_prime_y = -C * k1 * np.cos(k1 * x)\n    J_T_prime_z = -(A * k1 * np.cos(k1 * y) + 2.0 * A2 * k1 * np.cos(2.0 * k1 * y))\n    \n    # Total J = J_L + J_T' + d\n    Jx = J_L_x + J_T_prime_x + d[0]\n    Jy = J_L_y + J_T_prime_y + d[1]\n    Jz = J_L_z + J_T_prime_z + d[2]\n\n    # 3. Transform to Fourier space\n    J_hat_x = np.fft.fftn(Jx)\n    J_hat_y = np.fft.fftn(Jy)\n    J_hat_z = np.fft.fftn(Jz)\n\n    # 4. Construct wavevector grid\n    k_vec = 2.0 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_vec, k_vec, k_vec, indexing='ij')\n\n    k_sq = kx**2 + ky**2 + kz**2\n\n    # 5. Compute total norm of J_hat\n    norm_J_hat = np.sqrt(np.sum(np.abs(J_hat_x)**2 + np.abs(J_hat_y)**2 + np.abs(J_hat_z)**2))\n\n    # Dot product J_hat . k\n    J_hat_dot_k = J_hat_x * kx + J_hat_y * ky + J_hat_z * kz\n\n    # 6. Implement exact transverse projection\n    k_sq_safe = np.copy(k_sq)\n    k_sq_safe[0, 0, 0] = 1.0  # Avoid division by zero, will be corrected\n    \n    J_L_factor = J_hat_dot_k / k_sq_safe\n    J_L_hat_x = J_L_factor * kx\n    J_L_hat_y = J_L_factor * ky\n    J_L_hat_z = J_L_factor * kz\n    \n    # Enforce zero mean for longitudinal part\n    J_L_hat_x[0, 0, 0] = 0.0\n    J_L_hat_y[0, 0, 0] = 0.0\n    J_L_hat_z[0, 0, 0] = 0.0\n    \n    J_T_exact_hat_x = J_hat_x - J_L_hat_x\n    J_T_exact_hat_y = J_hat_y - J_L_hat_y\n    J_T_exact_hat_z = J_hat_z - J_L_hat_z\n    \n    norm_J_T_exact_hat = np.sqrt(np.sum(np.abs(J_T_exact_hat_x)**2 + np.abs(J_T_exact_hat_y)**2 + np.abs(J_T_exact_hat_z)**2))\n\n    # 7. Test suite\n    eps_values = [1e-18 * k_min, k_min, 5.0 * k_min]\n    results = []\n    \n    for eps in eps_values:\n        # a. Regularized projection\n        k_sq_reg = k_sq + eps**2\n        J_L_reg_factor = J_hat_dot_k / k_sq_reg\n        \n        J_L_reg_hat_x = J_L_reg_factor * kx\n        J_L_reg_hat_y = J_L_reg_factor * ky\n        J_L_reg_hat_z = J_L_reg_factor * kz\n\n        J_T_reg_hat_x = J_hat_x - J_L_reg_hat_x\n        J_T_reg_hat_y = J_hat_y - J_L_reg_hat_y\n        J_T_reg_hat_z = J_hat_z - J_L_reg_hat_z\n        \n        # b. Calculate divergence residual D(eps)\n        div_J_T_reg = kx * J_T_reg_hat_x + ky * J_T_reg_hat_y + kz * J_T_reg_hat_z\n        norm_div_J_T_reg = np.sqrt(np.sum(np.abs(div_J_T_reg)**2))\n        D_eps = norm_div_J_T_reg / norm_J_hat\n\n        # c. Calculate relative difference E(eps)\n        diff_E_x = J_T_reg_hat_x - J_T_exact_hat_x\n        diff_E_y = J_T_reg_hat_y - J_T_exact_hat_y\n        diff_E_z = J_T_reg_hat_z - J_T_exact_hat_z\n        norm_diff_E = np.sqrt(np.sum(np.abs(diff_E_x)**2 + np.abs(diff_E_y)**2 + np.abs(diff_E_z)**2))\n        E_eps = norm_diff_E / norm_J_T_exact_hat\n\n        # d. Calculate idempotence error I(eps)\n        # Project J_T_reg again\n        J_T_reg_hat_dot_k = J_T_reg_hat_x * kx + J_T_reg_hat_y * ky + J_T_reg_hat_z * kz\n        J_L_of_J_T_reg_factor = J_T_reg_hat_dot_k / k_sq_reg\n        \n        J_L_of_J_T_reg_x = J_L_of_J_T_reg_factor * kx\n        J_L_of_J_T_reg_y = J_L_of_J_T_reg_factor * ky\n        J_L_of_J_T_reg_z = J_L_of_J_T_reg_factor * kz\n\n        # P_eps(P_eps(J)) = P_eps(J) - P_L_eps(P_eps(J))\n        # The difference P_eps(P_eps(J)) - P_eps(J) is simply -P_L_eps(P_eps(J))\n        diff_I_x = -J_L_of_J_T_reg_x\n        diff_I_y = -J_L_of_J_T_reg_y\n        diff_I_z = -J_L_of_J_T_reg_z\n\n        norm_diff_I = np.sqrt(np.sum(np.abs(diff_I_x)**2 + np.abs(diff_I_y)**2 + np.abs(diff_I_z)**2))\n        norm_J_T_reg_hat = np.sqrt(np.sum(np.abs(J_T_reg_hat_x)**2 + np.abs(J_T_reg_hat_y)**2 + np.abs(J_T_reg_hat_z)**2))\n        I_eps = norm_diff_I / norm_J_T_reg_hat\n        \n        results.append([D_eps, E_eps, I_eps])\n\n    # 8. Format and print the final result\n    # Convert the list of lists to the specified string format\n    result_str = \"[\" + \", \".join([f\"[{d}, {e}, {i}]\" for d, e, i in results]) + \"]\"\n    print(result_str.replace(\" \", \"\"))\n\nsolve()\n```", "id": "3325815"}]}