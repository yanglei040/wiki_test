{"hands_on_practices": [{"introduction": "要有效利用环路-星形分解，第一步是能够从给定的网格中构建这些基函数。本练习将引导你完成一个基于图论的基本算法，利用网格的生成树（或生成森林）直接从网格的连接关系中生成一套完整的无旋（星形/树）和无散（环路）基向量[@problem_id:3325520]。掌握这种从零开始的构建方法，是实现高级积分方程算法的一项基本技能。", "problem": "给定一个平面三角网格族。对于每个网格，你需要在边集上构建离散环路基和星形基，在边上链的对称正定内积下计算它们的格拉姆矩阵，并执行基于 Cholesky分解的正交规范化。你的程序必须为每个网格的环路基和星形基输出一个定量的正交规范性误差。\n\n使用以下基础基底和建模选择。\n\n1.  网格、边与关联。一个网格由一组在平面内具有坐标的顶点和一组三角面片组成，每个面片由一个有序的顶点索引三元组给出。假设有 $V$ 个顶点和 $E$ 条边。\n    -   将无向边集构建为出现在任何三角形中的唯一无序顶点对的集合。将每条边表示为排序后的顶点对 $(i,j)$，其中 $i  j$。\n    -   将每条边的方向固定为从较小编号的索引指向较大编号的索引。构建顶点-边关联矩阵 $A \\in \\mathbb{R}^{V \\times E}$，其元素定义为：如果顶点 $i$ 是边 $e$ 的尾部，则 $A_{i,e} = -1$；如果顶点 $i$ 是边 $e$ 的头部，则 $A_{i,e} = +1$；否则 $A_{i,e} = 0$。\n\n2.  边空间上的内积。通过一个对角对称正定矩阵 $M \\in \\mathbb{R}^{E \\times E}$ 在边上链上定义一个内积，其对角线元素由边的欧几里得长度给出。也就是说，如果边 $e$ 连接坐标为 $(x_i,y_i)$ 和 $(x_j,y_j)$ 的顶点，则\n    $$ M_{e,e} = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}. $$\n    对于任意两个边向量 $u,v \\in \\mathbb{R}^E$，其内积为\n    $$ \\langle u, v \\rangle_M = u^\\top M v. $$\n\n3.  星形基（树基）。星形空间（也称为割空间）是 $A^\\top$ 的值域，即 $\\mathrm{range}(A^\\top) \\subset \\mathbb{R}^E$。对于具有 $C$ 个连通分量的网格，该空间的维数为 $V - C$。要构建一个显式基，首先计算图的生成森林，该图的顶点是网格顶点，无向边是网格边。该森林每个连通分量有一个根节点。对于每个非根节点的顶点 $i$，定义一个势向量 $p^{(i)} \\in \\mathbb{R}^V$，其中 $p^{(i)}_i = 1$，$p^{(i)}_r = -1$（$r$ 是包含 $i$ 的连通分量的根节点），而对于所有其他顶点 $k$，$p^{(i)}_k = 0$。然后定义一个星形基向量\n    $$ s^{(i)} = A^\\top p^{(i)} \\in \\mathbb{R}^E. $$\n    将这 $V-C$ 个向量收集为星形基矩阵 $S \\in \\mathbb{R}^{E \\times (V-C)}$ 的列。\n\n4.  环路基。环路空间（也称为循环空间）是 $A$ 的核，即 $\\ker(A) \\subset \\mathbb{R}^E$。对于有 $C$ 个连通分量的情况，其维数为 $E - V + C$。使用相同的生成森林，对于每条非树边 $e = (u,v)$，通过将 $e$ 插入森林中形成唯一的基本环路：它由该非树边加上连接 $u$ 和 $v$ 的森林中的唯一路径组成。设环路向量 $c^{(e)} \\in \\mathbb{R}^E$ 在该环路的边上具有 $\\pm 1$ 的值，在其他地方为 $0$，符号选择如下：\n    -   对于从 $u$ 到 $v$ 的路径上的每条树边，如果路径方向与固定的边方向（从较低的顶点索引到较高的顶点索引）匹配，则赋值 $+1$，否则为 $-1$。\n    -   对于非树边 $(u,v)$，如果从 $u$ 到 $v$ 的路径方向与固定的边方向匹配，则赋值 $-1$，否则赋值 $+1$。\n    这会得到 $A c^{(e)} = 0$。将这些环路向量收集为环路基矩阵 $L \\in \\mathbb{R}^{E \\times (E - V + C)}$ 的列。\n\n5.  格拉姆矩阵和基于 Cholesky 的正交规范化。对于一个基矩阵 $B \\in \\mathbb{R}^{E \\times K}$（$B=L$ 或 $B=S$），定义 $M$-格拉姆矩阵\n    $$ G = B^\\top M B \\in \\mathbb{R}^{K \\times K}. $$\n    由于 $M$ 是对称正定的，并且基的列向量是线性无关的，所以 $G$ 也是对称正定的。计算 Cholesky 分解\n    $$ G = \\mathcal{L} \\mathcal{L}^\\top, $$\n    其中 $\\mathcal{L}$ 是对角线元素为正的下三角矩阵。定义正交规范化基\n    $$ \\widetilde{B} = B \\left(\\mathcal{L}^\\top\\right)^{-1}. $$\n    那么，在精确算术中，\n    $$ \\widetilde{B}^\\top M \\widetilde{B} = I_{K}. $$\n\n6.  误差度量。对于每个基，计算与单位矩阵的 Frobenius 范数偏差\n    $$ \\varepsilon = \\left\\| \\widetilde{B}^\\top M \\widetilde{B} - I_K \\right\\|_F. $$\n\n测试套件和要求输出。为以下三个网格实现上述过程。对于每个网格，构建 $A$、$M$、$L$、$S$，并计算相应的 $\\varepsilon_L$ 和 $\\varepsilon_S$。你的程序应生成单行输出，其中包含一个逗号分隔的六个浮点数列表，按 $[\\varepsilon_L^{(1)}, \\varepsilon_S^{(1)}, \\varepsilon_L^{(2)}, \\varepsilon_S^{(2)}, \\varepsilon_L^{(3)}, \\varepsilon_S^{(3)}]$ 的顺序排列，每个数字采用包含 $12$ 位有效数字的科学记数法。\n\n网格 1（单个三角形）：\n- 顶点（$V = 3$）：$(0,0)$、$(1,0)$、$(0,1)$。\n- 三角形：$[0,1,2]$。\n\n网格 2（分割成两个三角形的单位正方形）：\n- 顶点（$V = 4$）：$(0,0)$、$(1,0)$、$(1,1)$、$(0,1)$。\n- 三角形：$[0,1,2]$、$[0,2,3]$。\n\n网格 3（两个不相连的直角三角形）：\n- 顶点（$V = 6$）：$(0,0)$、$(1,0)$、$(0,1)$、$(2,0)$、$(3,0)$、$(2,1)$。\n- 三角形：$[0,1,2]$、$[3,4,5]$。\n\n注意：\n- 不涉及角度单位。\n- 最终答案不需要物理单位。\n- 最终输出格式必须是单行，形式如下\n  $$ [x_1,x_2,x_3,x_4,x_5,x_6], $$\n  其中每个 $x_i$ 以包含 $12$ 位有效数字的科学记数法打印（例如，$1.234567890123\\mathrm{e}{-04}$），且列表以逗号分隔，无空格。", "solution": "用户提供了一个在三角网格上进行离散外微分领域的计算问题，这是计算电磁学和几何建模中的一个核心课题。任务是构建并正交规范化两组基本的基向量集——环路基和星形基，并量化正交规范化过程的数值误差。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n\n-   **网格数据**：一个平面三角网格由一组具有二维坐标的顶点 $V$ 和一组三角面片定义，每个面片由一个有序的顶点索引三元组指定。\n-   **边定义**：边是来自三角形的唯一无序顶点对。它们被规范地表示和定向为排序后的顶点对 $(i,j)$，其中 $i  j$。\n-   **顶点-边关联矩阵 $A$**：定义一个关联矩阵 $A \\in \\mathbb{R}^{V \\times E}$，其元素 $A_{i,e} = -1$ 如果顶点 $i$ 是定向边 $e$ 的尾部，$A_{i,e} = +1$ 如果 $i$ 是头部，否则为 $0$。\n-   **边上链的内积**：内积由一个对角、对称正定矩阵 $M \\in \\mathbb{R}^{E \\times E}$ 定义。对角元素 $M_{e,e}$ 是边 $e$ 的欧几里得长度。内积为 $\\langle u, v \\rangle_M = u^\\top M v$。\n-   **星形（树）基 $S$**：星形空间是 $\\mathrm{range}(A^\\top)$，维数为 $V-C$，其中 $C$ 是连通分量的数量。通过网格图的生成森林构建基。对于每个非根顶点 $i$，定义一个势向量 $p^{(i)} \\in \\mathbb{R}^V$，其中 $p^{(i)}_i = 1$，$p^{(i)}_r = -1$（$r$ 是包含 $i$ 的分量的根），所有其他元素为零。星形基向量为 $s^{(i)} = A^\\top p^{(i)}$。这些向量构成基矩阵 $S$ 的列。\n-   **环路（循环）基 $L$**：环路空间是 $\\ker(A)$，维数为 $E - V + C$。基由对应于生成森林的非树边的基本环路构建。对于每个非树边 $e=(u,v)$，构建基向量 $c^{(e)}$。\n    -   它的非零项对应于基本环路的边（非树边 $e$ 加上 $u$ 和 $v$ 之间唯一的树路径）。\n    -   根据路径遍历方向与固定边方向的比较来分配符号。对于从 $u$ 到 $v$ 的树路径，如果路径方向与边方向匹配，则树边的系数为 $+1$，否则为 $-1$。对于非树边，如果“从 $u$ 到 $v$ 的路径方向”（解释为参考方向 $u \\to v$）与固定方向匹配，则系数为 $-1$，否则为 $+1$。\n-   **格拉姆矩阵与正交规范化**：对于一个基矩阵 $B$（$L$ 或 $S$），格拉姆矩阵为 $G = B^\\top M B$。执行 Cholesky 分解 $G = \\mathcal{L} \\mathcal{L}^\\top$。正交规范化基为 $\\widetilde{B} = B (\\mathcal{L}^\\top)^{-1}$。\n-   **误差度量**：正交规范性误差是与单位矩阵偏差的 Frobenius 范数：$\\varepsilon = \\left\\| \\widetilde{B}^\\top M \\widetilde{B} - I_K \\right\\|_F$。\n-   **测试套件**：提供了三个特定的网格。\n    1.  网格 1：一个单独的三角形。\n    2.  网格 2：一个被两个三角形细分的单位正方形。\n    3.  网格 3：两个不相连的三角形。\n-   **输出格式**：一个单行，包含一个逗号分隔的六个计算误差（三个网格各自的 $\\varepsilon_L, \\varepsilon_S$）的列表，使用包含12位有效数字的科学记数法。\n\n**1.2. 使用提取的已知条件进行验证**\n\n-   **科学依据充分**：该问题深深植根于代数拓扑、离散微分几何和计算电磁学的成熟理论。环路空间和星形空间分别是旋度和散度算子核的离散模拟，它们构成了边场空间的霍奇分解。所规定的关联矩阵、基和内积的构造方法在该领域（例如，在有限元方法或有限积分技术中）是标准的。该问题在科学上是合理的。\n-   **适定性**：该问题提供了一个完整、明确的算法。给定一个网格，边、矩阵 $A$ 和 $M$ 的构造，以及生成森林（可以使用 BFS 或 DFS 等标准算法）的计算，都会导出一个用于构造基 $L$ 和 $S$ 的确定性过程。随后的正交规范化和误差计算是标准的数值线性代数任务。该问题在计算上是适定的。\n-   **客观性**：语言完全是数学和算法性的。没有主观或基于意见的陈述。\n-   **完整性**：提供了所有必要的数据（顶点坐标、三角形连接性）和定义。没有缺失的参数或模糊的约束。环路基的符号约定虽然表述略显不寻常，但可以以一种标准的、自洽的方式来解释。\n-   **其他缺陷**：该问题不违反任何其他验证标准。它不是微不足道的，不是循环论证的，并且与指定领域直接相关。\n\n**1.3. 结论与行动**\n\n该问题是**有效的**。它是一个定义明确、科学上合理的计算任务。我将继续提供完整的解决方案。\n\n### 步骤 2：求解\n\n解决方案将作为一个 Python 程序实现。对于每个网格，我们将系统地遵循问题陈述中详述的步骤。\n\n1.  **网格表示**：从输入的顶点和三角形，我们首先导出唯一的、规范定向的边集。每条边是两个顶点索引的元组 `(i, j)`，其中 `i  j`。这定义了总边数 $E$，并提供了从每条边到从 $0$ 到 $E-1$ 的唯一索引的映射。我们还构建了网格图的邻接表表示，用于遍历算法。\n\n2.  **矩阵构造**：\n    -   构造尺寸为 $V \\times E$ 的顶点-边关联矩阵 $A$。对于每条边 $e_k = (i, j)$，我们设置 $A_{i,k} = -1$ 和 $A_{j,k} = 1$。\n    -   构造尺寸为 $E \\times E$ 的质量矩阵 $M$ 作为对角矩阵。对角元素 $M_{k,k}$ 是边 $e_k$ 的欧几里得长度。\n\n3.  **生成森林**：我们执行图遍历（例如，广度优先搜索），从一个任意未访问的顶点开始。重复此过程，直到所有顶点都被访问。这将顶点划分为 $C$ 个连通分量，并为每个分量生成一个生成树。我们存储每个非根顶点的父节点、根节点集合以及树边集合。\n\n4.  **星形基构造**：星形空间的维数为 $K_S = V - C$。基向量由 $V-C$ 个非根顶点索引。对于每个根为 $r$ 的非根顶点 $i$，我们定义一个势向量 $p$，其中 $p_i = 1$，$p_r = -1$，所有其他项为零。相应的星形基向量为 $s^{(i)} = A^\\top p$。这相当于为每条边计算 $p_{\\text{head}} - p_{\\text{tail}}$。这些 $K_S$ 个向量被组装成矩阵 $S \\in \\mathbb{R}^{E \\times K_S}$ 的列。\n\n5.  **环路基构造**：环路空间的维数为 $K_L = E - V + C$。基向量由非树边索引。对于每个非树边 $e_{nt} = (u,v)$，我们在生成森林中找到 $u$ 和 $v$ 之间的唯一路径。该路径与 $e_{nt}$ 结合，形成一个基本环路。构造一个环路向量 $c^{(e_{nt})}$：\n    -   我们从 $u$ 到 $v$ 遍历树路径。对于此路径上的每个树边，我们在 $c$ 的相应条目中分配 $\\pm 1$ 的系数。如果我们的遍历方向与边的规范方向（$i \\to j$，其中 $i  j$）匹配，则系数为 $+1$，否则为 $-1$。\n    -   对于非树边 $e_{nt}$，我们在其相应条目中分配一个符号，以确保所得向量 $c^{(e_{nt})}$ 的离散散度为零（即 $A c^{(e_{nt})} = 0$）。这通常通过分配 $-1$（或 $+1$，取决于边的方向）来简单实现，以抵消路径遍历的净贡献。根据问题描述，如果 $u  v$，则分配 $-1$。这些 $K_L$ 个向量被组装成矩阵 $L \\in \\mathbb{R}^{E \\times K_L}$ 的列。\n\n6.  **正交规范化与误差计算**：对于每个基矩阵（$L$ 和 $S$），我们计算其格拉姆矩阵 $G = B^\\top M B$。然后我们计算 $G$ 的 Cholesky 分解 $G = \\mathcal{L}\\mathcal{L}^\\top$。正交规范化基为 $\\widetilde{B} = B (\\mathcal{L}^\\top)^{-1}$。最后，我们计算误差 $\\varepsilon = \\| \\widetilde{B}^\\top M \\widetilde{B} - I \\|_F$。\n\n该过程将对三个测试用例中的每一个重复执行，结果将根据指定格式进行格式化和打印。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import cholesky, inv\nfrom collections import deque\n\ndef calculate_orthonormality_error(B, M_mat):\n    \"\"\"\n    Computes the Gram matrix, performs Cholesky-based orthonormalization,\n    and returns the Frobenius norm of the deviation from identity.\n    \"\"\"\n    K = B.shape[1]\n    if K == 0:\n        return 0.0\n\n    # G = B^T M B\n    G = B.T @ M_mat @ B\n\n    try:\n        # G = L_chol @ L_chol.T\n        L_chol = cholesky(G, lower=True)\n    except np.linalg.LinAlgError:\n        # Should not happen for a valid basis.\n        return np.inf\n\n    # B_tilde = B @ (L_chol.T)^-1\n    L_chol_inv_T = inv(L_chol.T)\n    B_tilde = B @ L_chol_inv_T\n\n    # I_check = B_tilde^T M B_tilde\n    I_check = B_tilde.T @ M_mat @ B_tilde\n\n    # Error = ||I_check - I||_F\n    I_K = np.identity(K)\n    error = np.linalg.norm(I_check - I_K, 'fro')\n    \n    return error\n\ndef process_mesh(vertices, triangles):\n    \"\"\"\n    Processes a single mesh to compute loop and star basis orthonormality errors.\n    \"\"\"\n    # 1. Build edge set and graph structure\n    V = len(vertices)\n    edge_set = set()\n    for tri in triangles:\n        edge_set.add(tuple(sorted((tri[0], tri[1]))))\n        edge_set.add(tuple(sorted((tri[1], tri[2]))))\n        edge_set.add(tuple(sorted((tri[2], tri[0]))))\n    \n    edges = sorted(list(edge_set))\n    E = len(edges)\n    edge_to_idx = {edge: i for i, edge in enumerate(edges)}\n    \n    adj = {i: [] for i in range(V)}\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    # 2. Build incidence and mass matrices\n    A = np.zeros((V, E))\n    M_diag = np.zeros(E)\n    for i, edge in enumerate(edges):\n        u, v = edge\n        A[u, i] = -1.0\n        A[v, i] = 1.0\n        p_u = np.array(vertices[u])\n        p_v = np.array(vertices[v])\n        M_diag[i] = np.linalg.norm(p_u - p_v)\n    M = np.diag(M_diag)\n\n    # 3. Build spanning forest\n    visited = [False] * V\n    parent = [-1] * V\n    roots = []\n    tree_edges = set()\n    C = 0\n    component_map = {} # Maps vertex to its component's root\n    for i in range(V):\n        if not visited[i]:\n            C += 1\n            root_node = i\n            roots.append(root_node)\n            q = deque([i])\n            visited[i] = True\n            component_map[i] = root_node\n            \n            while q:\n                u = q.popleft()\n                for v_neighbor in sorted(adj[u]): # sorted for determinism\n                    if not visited[v_neighbor]:\n                        visited[v_neighbor] = True\n                        parent[v_neighbor] = u\n                        component_map[v_neighbor] = root_node\n                        q.append(v_neighbor)\n                        tree_edges.add(tuple(sorted((u, v_neighbor))))\n\n    # 4. Construct Loop Basis L\n    num_loops = E - V + C\n    L = np.zeros((E, num_loops))\n    non_tree_edges = [edge for edge in edges if edge not in tree_edges]\n\n    for i, nt_edge in enumerate(non_tree_edges):\n        u, v = nt_edge\n        \n        # Find path in tree from u to v\n        path_u_to_root = []\n        curr = u\n        while curr != -1: path_u_to_root.append(curr); curr = parent[curr]\n        \n        path_v_to_root = []\n        curr = v\n        while curr != -1: path_v_to_root.append(curr); curr = parent[curr]\n\n        # Find LCA\n        path_u_set = set(path_u_to_root)\n        lca = next(node for node in path_v_to_root if node in path_u_set)\n        \n        # Path from u to lca\n        path_u_to_lca = path_u_to_root[:path_u_to_root.index(lca)+1]\n        # Path from v to lca\n        path_v_to_lca = path_v_to_root[:path_v_to_root.index(lca)]\n        \n        # Full path of vertices in tree from u to v\n        cycle_path_verts = path_u_to_lca + path_v_to_lca[::-1]\n\n        c = np.zeros(E)\n        # Tree edges part of the cycle\n        for j in range(len(cycle_path_verts) - 1):\n            p1, p2 = cycle_path_verts[j], cycle_path_verts[j+1]\n            \n            tree_edge_tuple = tuple(sorted((p1, p2)))\n            edge_idx = edge_to_idx[tree_edge_tuple]\n            \n            # if path traversal direction matches canonical edge orientation\n            if p1  p2: c[edge_idx] = 1.0\n            else: c[edge_idx] = -1.0\n        \n        # Non-tree edge\n        nt_edge_idx = edge_to_idx[nt_edge]\n        # Sign convention from problem description\n        if u  v:\n             c[nt_edge_idx] = -1.0\n        else:\n             c[nt_edge_idx] = 1.0\n\n        L[:, i] = c\n    \n    eps_L = calculate_orthonormality_error(L, M)\n    \n    # 5. Construct Star Basis S\n    num_stars = V - C\n    S = np.zeros((E, num_stars))\n    non_root_vertices = sorted([i for i in range(V) if i not in roots])\n\n    for i, v_idx in enumerate(non_root_vertices):\n        p = np.zeros(V)\n        p[v_idx] = 1.0\n        p[component_map[v_idx]] = -1.0\n        S[:, i] = A.T @ p\n    \n    eps_S = calculate_orthonormality_error(S, M)\n\n    return eps_L, eps_S\n\ndef solve():\n    test_cases = [\n        {\n            \"vertices\": [(0, 0), (1, 0), (0, 1)],\n            \"triangles\": [[0, 1, 2]]\n        },\n        {\n            \"vertices\": [(0, 0), (1, 0), (1, 1), (0, 1)],\n            \"triangles\": [[0, 1, 2], [0, 2, 3]]\n        },\n        {\n            \"vertices\": [(0, 0), (1, 0), (0, 1), (2, 0), (3, 0), (2, 1)],\n            \"triangles\": [[0, 1, 2], [3, 4, 5]]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_L, eps_S = process_mesh(case[\"vertices\"], case[\"triangles\"])\n        results.append(f\"{eps_L:.12e}\")\n        results.append(f\"{eps_S:.12e}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3325520"}, {"introduction": "构建了基函数之后，下一步自然是如何使用它们。本练习聚焦于分解的核心操作：将任意表面电流（由其RWG系数表示）投影到环路和星形子空间中[@problem_id:3325511]。你将学习如何将此分解问题表述为一个涉及图拉普拉斯算子 $L = B B^{\\top}$ 的最小二乘问题，从而提供一种直接而强大的方法，将任何电流分离为其螺线管分量和无旋分量。", "problem": "考虑一个三角化表面网格，其缩减的Rao–Wilton–Glisson (RWG)基系数可通过有向边进行索引。设该网格可抽象为一个有 $n_v$ 个顶点和 $n_e$ 条边的有向图，其顶点-边关联矩阵为 $B \\in \\mathbb{R}^{n_v \\times n_e}$。其中，第 $i$ 条边从其尾顶点 $t$ 指向其头顶点 $h$，关联矩阵的元素在尾部为 $-1$，在头部为 $+1$，其他位置为 $0$。RWG系数向量为 $j \\in \\mathbb{R}^{n_e}$。\n\n定义星形子空间为 $B^{\\top}$ 的列空间，即 $\\mathrm{Range}(B^{\\top}) = \\{ B^{\\top} \\phi : \\phi \\in \\mathbb{R}^{n_v} \\}$；定义环路子空间为 $B$ 的零空间，即 $\\mathrm{Null}(B) = \\{ x \\in \\mathbb{R}^{n_e} : B x = 0 \\}$。图的离散亥姆霍兹分解表明，对于任何具有固定方向的无向图，存在正交直和 $\\mathbb{R}^{n_e} = \\mathrm{Range}(B^{\\top}) \\oplus \\mathrm{Null}(B)$，并且在欧几里得内积下，$\\mathrm{Range}(B^{\\top}) \\perp \\mathrm{Null}(B)$。\n\n从这些定义和表示顶点净散度的离散守恒约束 $B j$ 出发，推导并实现一个算法，该算法使用关联矩阵通过最小二乘法将任意RWG系数向量 $j$ 投影到其星形分量 $j_{\\star} \\in \\mathrm{Range}(B^{\\top})$ 和环路分量 $j_{\\mathrm{loop}} \\in \\mathrm{Null}(B)$ 上。该投影应通过在最小二乘意义下求解星形分量的正规方程\n$$\n(B B^{\\top}) \\, \\phi = B \\, j,\n$$\n来获得，然后设置\n$$\nj_{\\star} = B^{\\top} \\phi, \\quad j_{\\mathrm{loop}} = j - j_{\\star}.\n$$\n当 $B B^{\\top}$ 是奇异矩阵时（例如，对于非连通图），使用Moore–Penrose伪逆来计算 $\\phi$ 的最小范数解。\n\n您必须使用由已知的星形和环路分量生成的合成数据来测试该算法。对于每次测试，根据给定的顶点和边集构造 $B$，生成一个随机势 $\\phi \\in \\mathbb{R}^{n_v}$ 以定义星形分量 $j_{\\star} = B^{\\top} \\phi$，并从 $\\mathrm{Null}(B)$ 的一组基生成一个随机环路分量 $j_{\\mathrm{loop}}$。使用固定的伪随机种子以确保测试的可复现性。可选择添加一个小的噪声向量 $n$ 来测试数值稳健性，设置 $j = j_{\\star} + j_{\\mathrm{loop}} + n$。\n\n对于每次测试，计算相对重构误差\n$$\n\\varepsilon_{\\star} = \\frac{\\lVert \\widehat{j}_{\\star} - j_{\\star} \\rVert_2}{\\max(\\lVert j_{\\star} \\rVert_2, \\epsilon)}, \\quad\n\\varepsilon_{\\mathrm{loop}} = \\frac{\\lVert \\widehat{j}_{\\mathrm{loop}} - j_{\\mathrm{loop}} \\rVert_2}{\\max(\\lVert j_{\\mathrm{loop}} \\rVert_2, \\epsilon)},\n$$\n其中 $\\epsilon = 10^{-12}$，$\\widehat{j}_{\\star}$ 是到 $\\mathrm{Range}(B^{\\top})$ 上的最小二乘投影，且 $\\widehat{j}_{\\mathrm{loop}} = j - \\widehat{j}_{\\star}$。所有范数均为欧几里得 $2$-范数。\n\n根据以下测试套件和数据生成协议实现程序（每条边的方向为 尾部 $\\rightarrow$ 头部）：\n\n- 测试 $1$（含单个环的连通图）：$n_v = 4$，边 $[(0,1),(1,2),(2,3),(3,0)]$，种子 $42$，噪声标准差 $0$。\n- 测试 $2$（树图，无环）：$n_v = 4$，边 $[(0,1),(1,2),(2,3)]$，种子 $43$，噪声标准差 $0$。\n- 测试 $3$（两个不连通的 $3$-环）：$n_v = 6$，边 $[(0,1),(1,2),(2,0),(3,4),(4,5),(5,3)]$，种子 $44$，噪声标准差 $0$。\n- 测试 $4$（含一个环和一个额外叶节点的连通图，带噪声）：$n_v = 5$，边 $[(0,1),(1,2),(2,3),(3,0),(1,4)]$，种子 $45$，噪声标准差 $10^{-6}$。\n\n对于每次测试：\n- 根据指定的 $n_v$ 和边列表构建 $B$。\n- 使用奇异值分解计算 $\\mathrm{Null}(B)$ 的一组基，其中零奇异值的容差为 $10^{-12}$。\n- 使用提供的种子将 $\\phi$ 的元素抽取为独立的标准正态分布。\n- 计算 $j_{\\star} = B^{\\top} \\phi$。\n- 使用相同的种子将环路基的系数抽取为独立的标准正态分布，并通过零空间基向量的线性组合构成 $j_{\\mathrm{loop}}$（如果零空间是平凡的，则设置 $j_{\\mathrm{loop}} = 0$）。\n- 使用给定的噪声标准差和相同的种子抽取独立的标准正态噪声项；设置 $j = j_{\\star} + j_{\\mathrm{loop}} + n$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序如下\n$$\n[\\varepsilon_{\\mathrm{loop}}^{(1)}, \\varepsilon_{\\star}^{(1)}, \\varepsilon_{\\mathrm{loop}}^{(2)}, \\varepsilon_{\\star}^{(2)}, \\varepsilon_{\\mathrm{loop}}^{(3)}, \\varepsilon_{\\star}^{(3)}, \\varepsilon_{\\mathrm{loop}}^{(4)}, \\varepsilon_{\\star}^{(4)}],\n$$\n其中上标 $(k)$ 索引测试 $k$。输出为不带单位的实数。不应打印任何其他文本。", "solution": "用户提供的问题已经过验证，被认为是适定的、科学上合理的和完整的。为得到唯一且有意义的解所需的所有数据、约束和定义均已提供。该问题是图上的线性代数和离散微积分的一个标准应用，具体涉及离散域上向量场的亥姆霍兹-霍奇分解。\n\n核心任务是将一个给定的向量 $j \\in \\mathbb{R}^{n_e}$（表示图的边上的系数）分解为两个正交分量：一个星形分量 $j_{\\star}$ 和一个环路分量 $j_{\\mathrm{loop}}$。这些分量分别位于星形子空间 $\\mathrm{Range}(B^{\\top})$ 和环路子空间 $\\mathrm{Null}(B)$ 中，其中 $B \\in \\mathbb{R}^{n_v \\times n_e}$ 是顶点-边关联矩阵。分解由 $j = j_{\\star} + j_{\\mathrm{loop}}$ 给出。\n\n星形分量 $j_{\\star}$ 是 $j$ 在子空间 $\\mathrm{Range}(B^{\\top})$ 上的正交投影。根据定义，该子空间中的任何向量都可以表示为 $B^{\\top}\\phi$，其中 $\\phi \\in \\mathbb{R}^{n_v}$ 是某个势向量。该投影通过求解一个最小二乘问题来找到，该问题旨在最小化 $j$ 与其在星形子空间中的近似值之间的距离：\n$$\n\\min_{\\phi \\in \\mathbb{R}^{n_v}} \\lVert j - B^{\\top}\\phi \\rVert_2^2\n$$\n为求最小值，我们将平方范数对 $\\phi$ 求导，并令梯度为零。目标函数为：\n$$\nf(\\phi) = (j - B^{\\top}\\phi)^{\\top}(j - B^{\\top}\\phi) = j^{\\top}j - 2\\phi^{\\top}B j + \\phi^{\\top}B B^{\\top}\\phi\n$$\n关于 $\\phi$ 的梯度是 $\\nabla_{\\phi} f(\\phi) = -2 B j + 2 B B^{\\top}\\phi$。令其为零可得到正规方程：\n$$\n(B B^{\\top}) \\phi = B j\n$$\n矩阵 $L = B B^{\\top}$ 是图拉普拉斯算子。如果图不是单个顶点，该矩阵是奇异的。其零空间 $\\mathrm{Null}(L) = \\mathrm{Null}(B^{\\top})$ 的维度等于图的连通分量的数量。然而，该方程组总是相容的，因为右侧项 $B j$ 总是与 $L$ 的零空间正交。我们来证明这一点：对于任何向量 $v \\in \\mathrm{Null}(L) = \\mathrm{Null}(B^{\\top})$，我们有 $B^{\\top}v=0$。其内积为 $(B j)^{\\top}v = j^{\\top}B^{\\top}v = j^{\\top}0 = 0$。这种正交性保证了 $\\phi$ 的解总是存在的。\n\n虽然 $\\phi$ 的解存在，但如果 $L$ 是奇异的，解就不是唯一的。如果 $\\phi_s$ 是一个特解，那么对于任何 $\\phi_0 \\in \\mathrm{Null}(L)$，$\\phi_s + \\phi_0$ 也是一个解。然而，最终得到的星形分量 $j_{\\star} = B^{\\top}\\phi$ 是唯一的。这是因为 $B^{\\top}(\\phi_s + \\phi_0) = B^{\\top}\\phi_s + B^{\\top}\\phi_0 = B^{\\top}\\phi_s + 0 = B^{\\top}\\phi_s$。\n\n为了获得一个特定的、数值上稳定的解，我们使用Moore-Penrose伪逆，用上标 ‘$+$’ 表示。$\\phi$ 的最小范数最小二乘解由下式给出：\n$$\n\\phi_{\\text{sol}} = (B B^{\\top})^{+} (B j)\n$$\n利用这个 $\\phi_{\\text{sol}}$，我们计算得到的估计星形分量（记为 $\\widehat{j}_{\\star}$）为：\n$$\n\\widehat{j}_{\\star} = B^{\\top} \\phi_{\\text{sol}}\n$$\n一旦找到星形分量，就可以利用分解的正交性，通过减法得到环路分量 $\\widehat{j}_{\\mathrm{loop}}$：\n$$\n\\widehat{j}_{\\mathrm{loop}} = j - \\widehat{j}_{\\star}\n$$\n所得向量 $\\widehat{j}_{\\mathrm{loop}}$ 保证位于环路子空间 $\\mathrm{Null}(B)$ 中，因为 $B\\widehat{j}_{\\mathrm{loop}} = B(j - \\widehat{j}_{\\star}) = B j - B(B^{\\top}\\phi_{\\text{sol}}) = B j - (B B^{\\top})\\phi_{\\text{sol}}$。由于 $\\phi_{\\text{sol}}$ 是最小二乘解，$(B B^{\\top})\\phi_{\\text{sol}}$ 是 $B j$ 在 $B B^{\\top}$ 的值域上的正交投影。正如我们证明的相容性，$B j$ 位于 $B B^{\\top}$ 的值域内，因此投影是精确的：$(B B^{\\top})\\phi_{\\text{sol}} = B j$。因此，$B\\widehat{j}_{\\mathrm{loop}} = 0$，这证实了 $\\widehat{j}_{\\mathrm{loop}} \\in \\mathrm{Null}(B)$。\n\n对每个测试用例，实现将遵循以下步骤：\n1.  根据给定的顶点数 $n_v$ 和边列表构造关联矩阵 $B$。\n2.  生成合成的真实数据。为保证可复现性，随机数生成器使用种子进行初始化。\n    a. 使用奇异值分解（SVD）找到 $B$ 的零空间 $\\mathrm{Null}(B)$ 的一组基。基向量是与小于容差 $10^{-12}$ 的奇异值对应的右奇异向量。\n    b. 真实环路分量 $j_{\\mathrm{loop}}$ 由这些零空间基向量的随机线性组合生成。如果零空间是平凡的（例如，对于树图），则 $j_{\\mathrm{loop}}$ 是零向量。\n    c. 真实星形分量 $j_{\\star}$ 由一个随机势向量 $\\phi_{\\text{true}}$ 通过 $j_{\\star} = B^{\\top}\\phi_{\\text{true}}$ 生成。\n    d. 生成一个噪声向量 $n$，并将总向量构造为 $j = j_{\\star} + j_{\\mathrm{loop}} + n$。\n3.  将投影算法应用于 $j$ 以计算估计值 $\\widehat{j}_{\\star}$ 和 $\\widehat{j}_{\\mathrm{loop}}$。\n4.  最后，通过将估计分量与真实分量进行比较，并用真实分量的范数进行归一化（使用一个小的常数 $\\epsilon = 10^{-12}$ 以防止除以零），来计算相对重构误差 $\\varepsilon_{\\star}$ 和 $\\varepsilon_{\\mathrm{loop}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for loop-star decomposition.\n    \"\"\"\n    test_cases = [\n        {'nv': 4, 'edges': [(0, 1), (1, 2), (2, 3), (3, 0)], 'seed': 42, 'noise_std': 0.0},\n        {'nv': 4, 'edges': [(0, 1), (1, 2), (2, 3)], 'seed': 43, 'noise_std': 0.0},\n        {'nv': 6, 'edges': [(0, 1), (1, 2), (2, 0), (3, 4), (4, 5), (5, 3)], 'seed': 44, 'noise_std': 0.0},\n        {'nv': 5, 'edges': [(0, 1), (1, 2), (2, 3), (3, 0), (1, 4)], 'seed': 45, 'noise_std': 1e-6},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        nv = case['nv']\n        edges = case['edges']\n        seed = case['seed']\n        noise_std = case['noise_std']\n        \n        ne = len(edges)\n        rng = np.random.default_rng(seed)\n\n        # 1. Build the incidence matrix B\n        B = np.zeros((nv, ne))\n        for i, (tail, head) in enumerate(edges):\n            B[tail, i] = -1.0\n            B[head, i] = 1.0\n\n        # 2. Generate ground truth data (j_star and j_loop)\n        \n        # 2a. Find a basis for Null(B) using SVD\n        # The rows of Vh corresponding to small singular values form a basis for Null(B)\n        try:\n            _, s, Vh = np.linalg.svd(B)\n        except np.linalg.LinAlgError:\n            # SVD may not converge for some matrices, although not expected here\n            all_results.extend([np.nan, np.nan])\n            continue\n            \n        svd_tol = 1e-12\n        null_space_basis_rows = Vh[s  svd_tol]\n\n        # 2b. Generate j_loop\n        if null_space_basis_rows.shape[0] > 0:\n            # Transpose to get basis vectors as columns\n            null_space_basis = null_space_basis_rows.T\n            # Generate random coefficients for the basis vectors\n            loop_coeffs = rng.standard_normal(null_space_basis.shape[1])\n            j_loop = null_space_basis @ loop_coeffs\n        else:\n            j_loop = np.zeros(ne)\n\n        # 2c. Generate j_star\n        phi_true = rng.standard_normal(nv)\n        j_star = B.T @ phi_true\n        \n        # 2d. Generate noise and construct the total vector j\n        noise = rng.standard_normal(ne) * noise_std\n        j = j_star + j_loop + noise\n\n        # 3. Apply the projection algorithm\n        # Solve (BB^T) * phi = B*j using the pseudoinverse\n        L = B @ B.T\n        rhs = B @ j\n        \n        # phi_sol is the minimum-norm solution for the potential\n        phi_sol = np.linalg.pinv(L) @ rhs\n        \n        # Compute the estimated star and loop components\n        j_star_hat = B.T @ phi_sol\n        j_loop_hat = j - j_star_hat\n\n        # 4. Calculate relative reconstruction errors\n        epsilon = 1e-12\n        \n        # Error for the star component\n        norm_j_star = np.linalg.norm(j_star)\n        err_star = np.linalg.norm(j_star_hat - j_star) / max(norm_j_star, epsilon)\n        \n        # Error for the loop component\n        norm_j_loop = np.linalg.norm(j_loop)\n        err_loop = np.linalg.norm(j_loop_hat - j_loop) / max(norm_j_loop, epsilon)\n        \n        all_results.extend([err_loop, err_star])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "3325511"}, {"introduction": "掌握了分解的构建和执行方法后，最后的这个练习将抽象的数学与具体的物理现象联系起来。本练习将展示星形基函数的物理意义，揭示它们如何直接负责表示电荷的累积[@problem_id:3325476]。通过模拟导体板对入射电场 $\\mathbf{E}_{0}$ 的响应，你将观察到星形分量如何捕捉物体边界上典型的电荷聚集效应，这是准静态分析中的一个关键物理现象。", "problem": "给定一个薄的、理想导电的矩形板，该板被建模为一个带边界的平面三角化曲面域。考虑由均匀入射电场引起的低频、准静态激励。在感应表面电流的环路-星形分解中，星形子空间对应于无旋场，这些场可以在三角剖分上通过以顶点为中心的星形组合，由 Rao-Wilton-Glisson (RWG) 边函数构建。本问题的目的是在一个三角化的矩形上显式构建星形基函数的散度，并通过弱执行高斯定理所蕴含的边界通量，计算由均匀入射场引起的离散电荷累积模式，从而展示边缘效应。\n\n从以下基本基础开始：\n- 平面域上的曲面散度定理指出，对于域 $\\Omega$ 上任意足够光滑的矢量场 $\\mathbf{J}$，其边界为 $\\partial \\Omega$，有 $\\int_{\\Omega} \\nabla_{s} \\cdot \\mathbf{J}\\, dS = \\int_{\\partial \\Omega} \\mathbf{J} \\cdot \\mathbf{n}_{\\partial \\Omega}\\, ds$，其中 $\\mathbf{n}_{\\partial \\Omega}$ 是沿边界曲线的单位外法向矢量。\n- RWG (Rao-Wilton-Glisson) 基函数定义在由两个相邻三角形共享的内部边上，其在两个三角形上的支集是分片线性的，且曲面散度是分片常数。对于与长度为 $l_{e}$、相邻三角形面积为 $A^{+}$ 和 $A^{-}$ 的内部边 $e$ 相关联的 RWG 函数 $f_{e}$，其在一个相邻三角形上的散度为 $\\nabla_{s} \\cdot f_{e} = +\\frac{l_{e}}{A^{+}}$，在另一个上的散度为 $\\nabla_{s} \\cdot f_{e} = -\\frac{l_{e}}{A^{-}}$，符号由一致的定向决定。\n- 顶点 $v$ 处的顶点-星形基函数 $S_{v}$ 被构造为 $v$ 周围 RWG 函数的带符号和，即 $S_{v} = \\sum_{e \\ni v} c(v,e)\\, f_{e}$，其中 $c(v,e) \\in \\{+1,-1\\}$ 编码了顶点 $v$ 是定向边 $e$ 的正端点还是负端点。$S_{v}$ 的散度则是贡献的 RWG 函数散度的相应带符号和。\n\n您的任务是建立一个自洽的数值模型，并仅使用星形子空间计算由均匀入射电场在板上感应的归一化离散电荷累积模式。具体来说：\n\n1. 几何与离散化：\n   - 域是一个矩形 $\\Omega = [0,L_{x}] \\times [0,L_{y}]$，被离散为 $N_{x} \\times N_{y}$ 个矩形单元，每个单元通过从左下到右上单元角的对角线分裂成两个逆时针定向的三角形。\n   - 设节点集为 $\\{(x_{i}, y_{j})\\}$，其中 $i \\in \\{0,\\dots,N_{x}\\}$ 且 $j \\in \\{0,\\dots,N_{y}\\}$，$x_{i} = \\frac{i}{N_{x}} L_{x}$ 且 $y_{j} = \\frac{j}{N_{y}} L_{y}$。\n   - 构建所有具有一致逆时针定向的三角形。构建所有内部边（每条边恰好由两个三角形共享）和边界边（每条边恰好由一个三角形共享）。对于每条内部边，定义一个从较低索引节点到较高索引节点的全局边定向。\n\n2. 环路-星形构造和散度映射：\n   - 在所有顶点 $v$ 上构建顶点-星形基 $\\{S_{v}\\}$，作为与 $v$ 关联的内部边上的 RWG 函数 $f_{e}$ 的和，其符号 $c(v,e) \\in \\{+1,-1\\}$ 的选择方式为：如果 $v$ 是全局定向边 $e$ 的起始节点，则 $c(v,e)=+1$；如果 $v$ 是结束节点，则 $c(v,e)=-1$。\n   - 对于由三角形 $T^{+}$ 和 $T^{-}$ 共享的每条内部边 $e$，通过比较边的定向与每个三角形中边的局部逆时针定向来确定符号 $s(T^{\\pm}, e) \\in \\{+1,-1\\}$。对于三角形 $T$ 和边 $e$，积分散度贡献等于 $s(T,e)\\, l_{e}$。\n   - 组装一个矩阵 $D \\in \\mathbb{R}^{N_{T} \\times N_{V}}$，该矩阵将星形系数 $\\boldsymbol{\\alpha} \\in \\mathbb{R}^{N_{V}}$ 映射到每个三角形的积分散度 $\\mathbf{d} \\in \\mathbb{R}^{N_{T}}$：\n     $$ \\mathbf{d} = D \\, \\boldsymbol{\\alpha}, $$\n     其中 $N_{T}$ 是三角形的数量，$N_{V}$ 是顶点的数量。条目 $D_{t,v}$ 是对所有既与顶点 $v$ 相关联又属于三角形 $t$ 的内部边 $e$ 的 $c(v,e)\\, s(t,e)\\, l_{e}$ 的总和。\n\n3. 均匀场激励和目标边界通量：\n   - 设均匀入射场为 $\\mathbf{E}_{0} = (E_{x}, E_{y})$，与板相切。考虑代理目标场 $\\mathbf{J}_{\\mathrm{target}} = \\mathbf{E}_{0}$，它在整个域上是恒定的，并代表了通过 $\\mathbf{J} = -\\nabla_{s} u$ 从标量势 $u(\\mathbf{r}) = -\\mathbf{E}_{0} \\cdot \\mathbf{r}$ 得到的无旋场。\n   - 对于三角形 $t$ 的每个边界边，其定向切线 $\\hat{\\mathbf{t}}$ 与局部三角形边界定向匹配，单位外法线 $\\hat{\\mathbf{n}}_{\\mathrm{out}}$ 通过将 $\\hat{\\mathbf{t}}$ 旋转-90度获得，形成积分目标通量贡献 $q_{t,e} = (\\mathbf{E}_{0} \\cdot \\hat{\\mathbf{n}}_{\\mathrm{out}})\\, l_{e}$，其中 $l_{e}$ 是边长。定义每个三角形的目标为\n     $$ q_{t} = \\sum_{\\text{boundary edges } e \\subset \\partial t} q_{t,e}. $$\n     对于内部边，没有贡献，因为它们的通量在相邻三角形之间相互抵消。收集 $\\mathbf{q} \\in \\mathbb{R}^{N_{T}}$。\n\n4. 星形系数的确定：\n   - 通过最小化 Tikhonov 正则化的最小二乘目标函数来确定星形系数 $\\boldsymbol{\\alpha}$：\n     $$ \\min_{\\boldsymbol{\\alpha}} \\, \\left\\| D \\boldsymbol{\\alpha} - \\mathbf{q} \\right\\|_{2}^{2} + \\lambda \\left\\| \\boldsymbol{\\alpha} \\right\\|_{2}^{2}, $$\n     其中 $\\lambda > 0$ 是一个小的正则化参数，以确保解的稳定性。求解正规方程组\n     $$ (D^{\\top} D + \\lambda I)\\, \\boldsymbol{\\alpha} = D^{\\top} \\mathbf{q}. $$\n\n5. 归一化与度量：\n   - 设周长为 $P = 2 (L_{x} + L_{y})$，入射场大小为 $\\|\\mathbf{E}_{0}\\| = \\sqrt{E_{x}^{2} + E_{y}^{2}}$。将实现的每个三角形的积分散度 $\\mathbf{d} = D \\boldsymbol{\\alpha}$ 通过尺度 $S = \\|\\mathbf{E}_{0}\\| \\, P$ 进行归一化，即定义 $\\tilde{\\mathbf{d}} = \\mathbf{d}/S$。所有报告的值都必须是无量纲的。\n   - 根据 $\\tilde{\\mathbf{d}}$ 定义以下四个度量：\n     1) 净归一化电荷：$C_{\\mathrm{net}} = \\sum_{t=1}^{N_{T}} \\tilde{d}_{t}$。\n     2) 边缘平衡误差：通过将每个边界三角形的 $|\\tilde{d}_{t}|$ 按 $|q_{t,e}|$ 的比例分配给其边界边，并累加到 $C_{+}$（对于 $(\\mathbf{E}_{0}\\cdot \\hat{\\mathbf{n}}_{\\mathrm{out}}) > 0$ 的边）和 $C_{-}$（对于 $(\\mathbf{E}_{0}\\cdot \\hat{\\mathbf{n}}_{\\mathrm{out}})  0$ 的边）中，来构建相对于入射场的正负侧总和。然后定义 $E_{\\mathrm{bal}} = |\\, |C_{+}| - |C_{-}| \\,|$。\n     3) 最大内部幅值：$M_{\\mathrm{int}} = \\max\\{ |\\tilde{d}_{t}| \\,:\\, t \\text{ has no boundary edges} \\}$。\n     4) 边缘集中分数：$F_{\\mathrm{edge}} = \\left( \\sum_{t \\in \\mathcal{B}} |\\tilde{d}_{t}| \\right) \\big/ \\left( \\sum_{t=1}^{N_{T}} |\\tilde{d}_{t}| \\right)$，其中 $\\mathcal{B}$ 是至少有一条边界边的三角形集合。\n\n6. 要求的输出：\n   - 对于下面的每个测试用例，计算并输出列表 $[C_{\\mathrm{net}}, E_{\\mathrm{bal}}, M_{\\mathrm{int}}, F_{\\mathrm{edge}}]$ 作为浮点数。\n   - 您的程序应生成单行输出，其中包含所有给定测试用例的结果，形式为方括号括起来的逗号分隔列表，每个测试用例的列表本身也用方括号括起来。例如，要求的格式是 $[ [r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}], [r_{2,1}, r_{2,2}, r_{2,3}, r_{2,4}], \\dots ]$。\n\n测试套件：\n- 用例 1：$L_{x} = 1.0$, $L_{y} = 1.0$, $N_{x} = 8$, $N_{y} = 8$, $\\mathbf{E}_{0} = (1.0, 0.0)$。\n- 用例 2：$L_{x} = 2.0$, $L_{y} = 1.0$, $N_{x} = 12$, $N_{y} = 6$, $\\mathbf{E}_{0} = (0.0, 1.0)$。\n- 用例 3：$L_{x} = 1.0$, $L_{y} = 1.0$, $N_{x} = 10$, $N_{y} = 7$, $\\mathbf{E}_{0} = \\left(\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}\\right)$。\n- 用例 4：$L_{x} = 2.0$, $L_{y} = 0.2$, $N_{x} = 40$, $N_{y} = 4$, $\\mathbf{E}_{0} = (1.0, 0.0)$。\n\n所有输出都必须是无量纲的，按规定计算，并以上述确切的最终输出格式呈现。不需要其他单位。角度（如果有的话）必须以弧度为单位，但此处除了矢量的点积外，您不需要任何三角函数。", "solution": "用户提供的问题经评估为 **有效**。这是一个在计算电磁学领域中提法明确、有科学依据的问题，没有矛盾、歧义或未经证实的论断。任务是实现一个基于环路-星形分解和矩量法的数值模型，用以分析均匀电场激励下三角化矩形板上的电荷累积。问题提供了清晰、分步的算法描述，我们将严格遵循该描述。\n\n解决方案涉及以下步骤：\n1.  **几何建模与离散化**：一个矩形域 $\\Omega = [0,L_{x}] \\times [0,L_{y}]$ 被离散化为一个 $N_{x} \\times N_{y}$ 单元的网格。每个单元被细分为两个逆时针定向的三角形。这个过程生成一组顶点（节点）、一个由顶点索引定义的三角形列表，以及内部和边界边的集合。\n2.  **基函数与算子构造**：模型的核心是构造离散散度算子，由矩阵 $D$ 表示。星形基函数 $\\{S_v\\}$ 在每个顶点 $v$ 处定义为关联内部边上的 Rao-Wilton-Glisson (RWG) 基函数 $\\{f_e\\}$ 的带符号和。矩阵 $D \\in \\mathbb{R}^{N_{T} \\times N_{V}}$ 将星形基展开的系数 $\\boldsymbol{\\alpha}$ 映射到每个三角形上的积分曲面散度。一个条目 $D_{t,v}$ 表示星形基函数 $S_v$ 在三角形 $t$ 上的积分散度，由以下公式给出：\n    $$ D_{t,v} = \\sum_{e \\in \\mathcal{E}_t \\cap \\mathcal{E}_v} c(v,e)\\, s(t,e)\\, l_{e} $$\n    其中 $\\mathcal{E}_t$ 和 $\\mathcal{E}_v$ 分别是属于三角形 $t$ 和与顶点 $v$ 相关联的内部边集合。符号 $c(v,e) \\in \\{+1,-1\\}$ 取决于 $v$ 是全局定向边 $e$ 的起始节点还是结束节点。符号 $s(t,e) \\in \\{+1,-1\\}$ 用于比较全局边定向与在三角形 $t$ 内对该边进行局部逆时针遍历时的定向。项 $l_e$ 是边 $e$ 的长度。$D$ 的零空间对应于一个恒定的势（即 $\\boldsymbol{\\alpha}$ 是一个常数向量），这导致了一个秩亏系统。\n\n3.  **激励与边界条件**：施加一个均匀入射电场 $\\mathbf{E}_0$。从曲面散度定理导出的物理边界条件要求域内的总散度等于通过边界的净通量。这通过定义一个目标通量向量 $\\mathbf{q} \\in \\mathbb{R}^{N_{T}}$ 来弱实施。对于每个三角形 $t$，分量 $q_t$ 是 $\\mathbf{E}_0$ 通过其边界边的积分通量之和：\n    $$ q_{t} = \\sum_{\\text{boundary edges } e \\subset \\partial t} (\\mathbf{E}_{0} \\cdot \\hat{\\mathbf{n}}_{\\mathrm{out}})\\, l_{e} $$\n    其中 $\\hat{\\mathbf{n}}_{\\mathrm{out}}$ 是域边界上边的向外法线。\n\n4.  **求解线性系统**：通过求解一个 Tikhonov 正则化的最小二乘问题来找到星形系数 $\\boldsymbol{\\alpha}$，该问题旨在使实现的散度 $D\\boldsymbol{\\alpha}$ 与目标通量 $\\mathbf{q}$ 相匹配。这导出了正规方程组：\n    $$ (D^{\\top} D + \\lambda I)\\, \\boldsymbol{\\alpha} = D^{\\top} \\mathbf{q} $$\n    正则化项 $\\lambda I$，其中 $\\lambda > 0$ 是一个小的正则化参数（此处选择 $\\lambda=10^{-12}$），通过惩罚非物理解并稳定在存在 $D^TD$ 零空间情况下的求逆过程，来确保矩阵是可逆的。\n\n5.  **后处理与度量计算**：一旦找到 $\\boldsymbol{\\alpha}$，实现的每个三角形的积分散度就计算为 $\\mathbf{d} = D\\boldsymbol{\\alpha}$。该向量通过一个因子 $S = \\|\\mathbf{E}_{0}\\| P$ 进行归一化，其中 $P$ 是板的周长，从而得到无量纲量 $\\tilde{\\mathbf{d}}$。最后，从 $\\tilde{\\mathbf{d}}$ 计算四个指定的度量：\n    -   $C_{\\mathrm{net}}$：净归一化电荷，由于散度算子的性质，该值应接近于零。\n    -   $E_{\\mathrm{bal}}$：边界上正负电荷累积之间的平衡误差。\n    -   $M_{\\mathrm{int}}$：内部三角形中的最大电荷幅值，表示从边界的泄漏情况。\n    -   $F_{\\mathrm{edge}}$：集中在边界三角形上的总电荷幅值的分数，量化了预期的边缘效应。\n\n实现将对问题陈述中提供的每个测试用例遵循这些步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that iterates through test cases and prints results\n    in the specified format.\n    \"\"\"\n    test_cases = [\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 8, 'Ny': 8, 'E0': (1.0, 0.0)},\n        {'Lx': 2.0, 'Ly': 1.0, 'Nx': 12, 'Ny': 6, 'E0': (0.0, 1.0)},\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 10, 'Ny': 7, 'E0': (1/np.sqrt(2), 1/np.sqrt(2))},\n        {'Lx': 2.0, 'Ly': 0.2, 'Nx': 40, 'Ny': 4, 'E0': (1.0, 0.0)},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Each test case is solved by a dedicated function\n        res = compute_metrics_for_case(**case)\n        results.append(res)\n\n    # Format the output as a list of lists of floats, e.g., [[r1,r2,...],[r1,r2,...]]\n    # The map(str,...) and join combination achieves this format precisely.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_metrics_for_case(Lx, Ly, Nx, Ny, E0):\n    \"\"\"\n    Computes the four required metrics for a single test case following the\n    problem's methodology.\n    \"\"\"\n    # A small regularization parameter for Tikhonov regularization\n    LAMBDA = 1e-12\n    E0_vec = np.array(E0)\n\n    # 1. Geometry and discretization\n    num_nodes_x = Nx + 1\n    num_nodes_y = Ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_triangles = 2 * Nx * Ny\n\n    # Create nodes with y-index varying fastest to match node_idx function\n    x_coords = np.linspace(0, Lx, num_nodes_x)\n    y_coords = np.linspace(0, Ly, num_nodes_y)\n    node_list = []\n    for i in range(num_nodes_x):\n        for j in range(num_nodes_y):\n            node_list.append([x_coords[i], y_coords[j]])\n    nodes = np.array(node_list)\n\n    def node_idx(i, j):\n        return i * num_nodes_y + j\n\n    # Create triangles with consistent CCW orientation\n    triangles = []\n    for i in range(Nx):\n        for j in range(Ny):\n            v_ll, v_lr, v_ul, v_ur = node_idx(i, j), node_idx(i + 1, j), node_idx(i, j + 1), node_idx(i + 1, j + 1)\n            triangles.append([v_ll, v_lr, v_ur])\n            triangles.append([v_ll, v_ur, v_ul])\n    \n    # Identify interior and boundary edges\n    edge_to_triangles = {}\n    for t_idx, t_verts in enumerate(triangles):\n        for i in range(3):\n            v1, v2 = t_verts[i], t_verts[(i + 1) % 3]\n            edge = tuple(sorted((v1, v2)))\n            edge_to_triangles.setdefault(edge, []).append(t_idx)\n\n    interior_edges = {e for e, t_list in edge_to_triangles.items() if len(t_list) == 2}\n    boundary_edges = {e for e, t_list in edge_to_triangles.items() if len(t_list) == 1}\n\n    # 2. Assemble divergence matrix D\n    D = np.zeros((num_triangles, num_nodes))\n    for t_idx, t_verts in enumerate(triangles):\n        local_edges_verts = [(t_verts[0], t_verts[1]), (t_verts[1], t_verts[2]), (t_verts[2], t_verts[0])]\n        for v_node_idx in t_verts:\n            D_tv_val = 0.0\n            for v_start_local, v_end_local in local_edges_verts:\n                if v_node_idx in (v_start_local, v_end_local):\n                    edge_global = tuple(sorted((v_start_local, v_end_local)))\n                    if edge_global in interior_edges:\n                        edge_len = np.linalg.norm(nodes[v_end_local] - nodes[v_start_local])\n                        c_sign = 1 if v_node_idx == edge_global[0] else -1\n                        s_sign = 1 if (v_start_local  v_end_local) == (edge_global[0]  edge_global[1]) else -1\n                        D_tv_val += c_sign * s_sign * edge_len\n            D[t_idx, v_node_idx] = D_tv_val\n\n    # 3. Assemble target vector q\n    q = np.zeros(num_triangles)\n    for t_idx, t_verts in enumerate(triangles):\n        local_edges_verts = [(t_verts[0], t_verts[1]), (t_verts[1], t_verts[2]), (t_verts[2], t_verts[0])]\n        for v_start, v_end in local_edges_verts:\n            if tuple(sorted((v_start, v_end))) in boundary_edges:\n                t_vec = nodes[v_end] - nodes[v_start]\n                n_vec = np.array([t_vec[1], -t_vec[0]])\n                flux = np.dot(E0_vec, n_vec)\n                q[t_idx] += flux\n\n    # 4. Determine star coefficients alpha\n    DtD = D.T @ D\n    A = DtD + LAMBDA * np.identity(num_nodes)\n    b = D.T @ q\n    alpha = np.linalg.solve(A, b)\n    \n    # 5. Calculate metrics\n    d = D @ alpha\n    perimeter = 2 * (Lx + Ly)\n    E0_mag = np.linalg.norm(E0_vec)\n    if E0_mag  1e-15: return [0.0, 0.0, 0.0, 0.0]\n    scale = E0_mag * perimeter\n    if scale  1e-15: return [0.0, 0.0, 0.0, 0.0]\n    d_tilde = d / scale\n    \n    # Metric 1: C_net\n    C_net = np.sum(d_tilde)\n    \n    # Metric 2: E_bal\n    C_plus, C_minus = 0.0, 0.0\n    boundary_triangle_indices = sorted(list({t_idx for e in boundary_edges for t_idx in edge_to_triangles[e]}))\n    for t_idx in boundary_triangle_indices:\n        t_verts = triangles[t_idx]\n        local_edges_verts = [(t_verts[0], t_verts[1]), (t_verts[1], t_verts[2]), (t_verts[2], t_verts[0])]\n        boundary_edges_info = []\n        total_abs_q_t = 0.0\n        for v_start, v_end in local_edges_verts:\n            if tuple(sorted((v_start, v_end))) in boundary_edges:\n                t_vec = nodes[v_end] - nodes[v_start]\n                n_vec = np.array([t_vec[1], -t_vec[0]])\n                q_te = np.dot(E0_vec, n_vec)\n                boundary_edges_info.append(q_te)\n                total_abs_q_t += abs(q_te)\n        if total_abs_q_t > 1e-15:\n            d_t_tilde_mag = abs(d_tilde[t_idx])\n            for q_te in boundary_edges_info:\n                fraction = abs(q_te) / total_abs_q_t\n                charge_contribution = d_t_tilde_mag * fraction\n                if q_te > 0: C_plus += charge_contribution\n                else: C_minus += charge_contribution\n    E_bal = abs(C_plus - C_minus)\n    \n    # Metric 3: M_int\n    all_triangle_indices = set(range(num_triangles))\n    interior_triangle_indices = list(all_triangle_indices - set(boundary_triangle_indices))\n    M_int = np.max(np.abs(d_tilde[interior_triangle_indices])) if interior_triangle_indices else 0.0\n        \n    # Metric 4: F_edge\n    sum_abs_d_boundary = np.sum(np.abs(d_tilde[list(boundary_triangle_indices)]))\n    sum_abs_d_total = np.sum(np.abs(d_tilde))\n    F_edge = sum_abs_d_boundary / sum_abs_d_total if sum_abs_d_total > 1e-15 else 0.0\n    \n    return [C_net, E_bal, M_int, F_edge]\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3325476"}]}