{"hands_on_practices": [{"introduction": "本练习深入探讨了“优化Schwarz方法”（Optimized Schwarz Methods, OSM）的理论核心。这类方法的收敛速度关键取决于在子域间人工边界上选择的传输条件。本问题将引导你通过第一性原理推导，通过分析波的反射来寻找Robin型传输条件的最优参数，从而将数值算法与介质的物理波阻抗直接联系起来。理解这种联系对于设计高效的区域分解求解器至关重要。", "problem": "考虑在分层各向同性介质中的时谐麦克斯韦方程组，其中场仅在垂直于平面界面的法线方向上变化。设时间依赖性为 $\\exp(-i \\omega t)$，其中角频率 $\\omega > 0$。一个计算域在 $x=0$ 处被一个平面界面 $\\Gamma$ 分割成两个不重叠的子域，左子域的外向单位法线指向 $+x$ 方向。子域问题使用有限元法（FEM）求解，并通过在 $\\Gamma$ 上采用Robin传输条件的优化Schwarz方法（OSM）类型的区域分解法（DDM）进行耦合。\n\n假设在法向入射下为横电（TE）极化，因此非零分量为切向电场 $E_{t}(x)$ 和切向磁场 $H_{t}(x)$。左子域在 $\\Gamma$ 的邻域内是局部均匀的，其介电常数为 $\\epsilon_{-}>0$，磁导率为 $\\mu_{-}>0$。右子域是一个半无限的异质平面层堆栈，位于 $x>0$ 区域，具有分段常数的 $\\epsilon(x)$ 和 $\\mu(x)$，并终止于一个半无限的均匀半空间；用 $Y_{\\mathrm{in}}$ 表示这个半无限堆栈在 $x=0^{+}$ 处被出射波“看到”的精确输入导纳，即在 $\\Gamma$ 上的Dirichlet-to-Neumann（DtN）映射形式为 $n \\times H_{t} - Y_{\\mathrm{in}} E_{t} = 0$。\n\n在左子问题中，OSM Robin传输条件为在 $\\Gamma$ 上 $n \\times H_{t} - \\frac{1}{Z} E_{t} = 0$，其中 $Z>0$ 是一个实数调节参数（“Robin阻抗”）。对于法向入射的平面波，通过波在阻抗终端的反射来模拟界面误差动力学，并将精确DtN $Y_{\\mathrm{in}}$ 与Robin导纳 $1/Z$ 之间的失配视为DDM迭代中界面反射的唯一来源。\n\n仅从频域麦克斯韦方程组及其在均匀介质中蕴含的平面波关系出发，完成以下任务：\n\n- 根据右侧半无限均匀半空间的局部材料参数，推导其输入导纳 $Y_{\\mathrm{in}}$。然后将异质半无限堆栈的 $Y_{\\mathrm{in}}$ 定义为在 $\\Gamma$ 处出射波迹线之比 $H_{t}(0^{+})/E_{t}(0^{+})$。\n\n- 使用参考右侧堆栈精确输入阻抗的波变量，推导由施加 $n \\times H_{t} - \\frac{1}{Z} E_{t} = 0$ 代替精确DtN $n \\times H_{t} - Y_{\\mathrm{in}} E_{t} = 0$ 所引起的界面反射系数 $\\mathcal{R}(Z)$，并将其表示为 $Z$ 和有效输入阻抗 $\\eta_{\\mathrm{in}} = 1/Y_{\\mathrm{in}}$ 的闭合形式函数。\n\n- 在实数正值 $Z$ 上最小化 $|\\mathcal{R}(Z)|$，并获得相应的最优Robin参数 $Z_{\\mathrm{opt}}$。\n\n最后，将问题特化到科学上现实且实践上重要的情形，即界面 $\\Gamma$ 严格位于异质堆栈中具有局部材料参数 $\\mu$ 和 $\\epsilon$ 的单个均匀层内部（因此右子域内部的多重反射已被考虑）。在此假设下，仅用 $\\mu$ 和 $\\epsilon$ 来表示您得到的 $Z_{\\mathrm{opt}}$ 的最终结果。请以单个闭合形式的解析表达式提供您的最终答案。最终答案中不要包含单位。", "solution": "该问题要求推导应用于一维时谐麦克斯韦方程组的区域分解法的最优Robin传输条件参数。该过程涉及分析子域间界面处的波反射。\n\n首先，我们建立控制方程。对于 $\\exp(-i \\omega t)$ 的时间依赖性，在无源、各向同性、均匀介质中，麦克斯韦方程组为：\n$$\n\\nabla \\times \\vec{E} = i \\omega \\mu \\vec{H} \\\\\n\\nabla \\times \\vec{H} = -i \\omega \\epsilon \\vec{E}\n$$\n问题指定了横电（TE）极化，且场仅随 $x$ 方向变化，即 $E_t(x)$ 和 $H_t(x)$。为满足 $\\nabla \\cdot \\vec{E}=0$ 和 $\\nabla \\cdot \\vec{H}=0$ 对于一维场变化的要求，场必须纯粹横向于 $x$ 方向。我们考虑特定的极化方向，其中 $\\vec{E} = E_y(x) \\hat{y}$ 和 $\\vec{H} = H_z(x) \\hat{z}$。因此，切向场为 $E_t(x) = E_y(x)$ 和 $H_t(x) = H_z(x)$。一维麦克斯韦方程组变为：\n$$\n\\frac{d E_t}{dx} = i \\omega \\mu H_t \\\\\n\\frac{d H_t}{dx} = i \\omega \\epsilon E_t\n$$\n联立这些方程可得到关于 $E_t$ 的亥姆霍兹方程：\n$$\n\\frac{d^2 E_t}{dx^2} + k^2 E_t = 0, \\quad \\text{其中 } k = \\omega \\sqrt{\\mu\\epsilon} \\text{ 是波数。}\n$$\n通解是前向（右行）波和后向（左行）波的叠加：\n$$\nE_t(x) = E^+ \\exp(ikx) + E^- \\exp(-ikx)\n$$\n相应的磁场为：\n$$\nH_t(x) = \\frac{1}{i\\omega\\mu} \\frac{dE_t}{dx} = \\frac{k}{\\omega\\mu} \\left( E^+ \\exp(ikx) - E^- \\exp(-ikx) \\right)\n$$\n我们将介质的本征阻抗定义为 $\\eta = \\frac{\\omega\\mu}{k} = \\frac{\\omega\\mu}{\\omega\\sqrt{\\mu\\epsilon}} = \\sqrt{\\frac{\\mu}{\\epsilon}}$。磁场可以写为：\n$$\nH_t(x) = \\frac{1}{\\eta} \\left( E^+ \\exp(ikx) - E^- \\exp(-ikx) \\right)\n$$\n\n现在，我们处理具体任务。\n\n**1. 均匀半空间的输入导纳**\n\n考虑一个位于 $x>0$ 的半无限均匀半空间，其参数为 $\\mu_r, \\epsilon_r$。从 $x=0$ 处界面发出的出射波传播到该区域中。物理上要求在无穷远处没有源，这施加了一个辐射条件，意味着不能有后向传播的波分量。因此，$E^- = 0$。对于 $x>0$，场是纯粹前向传播的：\n$$\nE_t(x) = E^+ \\exp(ik_r x) \\\\\nH_t(x) = \\frac{1}{\\eta_r} E^+ \\exp(ik_r x)\n$$\n其中 $k_r = \\omega\\sqrt{\\mu_r \\epsilon_r}$ 且 $\\eta_r = \\sqrt{\\mu_r / \\epsilon_r}$。问题将输入导纳 $Y_{\\mathrm{in}}$ 定义为此类出射波在 $x=0^{+}$ 处的比值 $H_t(0^+)/E_t(0^+)$。\n$$\nY_{\\mathrm{in}} = \\frac{H_t(0^+)}{E_t(0^+)} = \\frac{(1/\\eta_r) E^+ \\exp(0)}{E^+ \\exp(0)} = \\frac{1}{\\eta_r} = \\sqrt{\\frac{\\epsilon_r}{\\mu_r}}\n$$\n\n**2. 异质堆栈的输入导纳**\n\n对于 $x>0$ 的半无限异质堆栈，问题将输入导纳 $Y_{\\mathrm{in}}$ 定义为界面处出射波的总切向场之比：$Y_{\\mathrm{in}} = H_t(0^+) / E_t(0^+)$。相应的输入阻抗为 $\\eta_{\\mathrm{in}} = 1/Y_{\\mathrm{in}} = E_t(0^+) / H_t(0^+)$。由于堆栈内部的多重反射，即使对于无损耗层，$\\eta_{\\mathrm{in}}$ 通常也是一个复数。\n\n**3. 界面反射系数 $\\mathcal{R}(Z)$**\n\n问题的核心是找到控制优化Schwarz方法收敛性的反射系数。该系数源于精确Dirichlet-to-Neumann（DtN）条件与近似Robin传输条件在界面 $\\Gamma$ 处的失配。物理系统施加了一个阻抗关系 $E_t = \\eta_{\\mathrm{in}} H_t$，而数值方法施加了 $E_t = Z H_t$。\n\n反射系数是通过对这种阻抗失配效应建模来推导的。我们使用参考右侧堆栈精确输入阻抗 $\\eta_{\\mathrm{in}}$ 的波变量框架。界面上的总场 $E_t, H_t$ 相对于特征阻抗 $\\eta_{\\mathrm{in}}$ 分解为入射（$a$）和反射（$b$）分量：\n$$\nE_t = a + b \\\\\nH_t = \\frac{1}{\\eta_{\\mathrm{in}}}(a - b)\n$$\n反射系数定义为 $\\mathcal{R} = b/a$。这些总场必须满足所施加的Robin条件，该条件决定了终端的阻抗：$E_t = Z H_t$。将波变量表达式代入此条件：\n$$\na+b = Z \\left(\\frac{1}{\\eta_{\\mathrm{in}}}(a - b)\\right)\n$$\n$$\n\\eta_{\\mathrm{in}}(a+b) = Z(a-b)\n$$\n为求解 $b/a$，我们重新整理各项：\n$$\na\\eta_{\\mathrm{in}} + b\\eta_{\\mathrm{in}} = aZ - bZ\n$$\n$$\nb\\eta_{\\mathrm{in}} + bZ = aZ - a\\eta_{\\mathrm{in}}\n$$\n$$\nb(Z + \\eta_{\\mathrm{in}}) = a(Z - \\eta_{\\mathrm{in}})\n$$\n因此，反射系数为：\n$$\n\\mathcal{R}(Z) = \\frac{b}{a} = \\frac{Z - \\eta_{\\mathrm{in}}}{Z + \\eta_{\\mathrm{in}}}\n$$\n这个结果是对于具有特征阻抗 $\\eta_{\\mathrm{in}}$ 的波介质，在负载阻抗 $Z$ 处的反射系数的标准表达式。\n\n**4. $|\\mathcal{R}(Z)|$ 的最小化**\n\n为了优化DDM的收敛性，我们必须针对实数正参数 $Z$ 最小化界面反射系数的模 $|\\mathcal{R}(Z)|$。输入阻抗 $\\eta_{\\mathrm{in}}$ 可能是复数，因此设 $\\eta_{\\mathrm{in}} = R + iI$，其中 $R = \\Re(\\eta_{\\mathrm{in}})$，$I = \\Im(\\eta_{\\mathrm{in}})$。\n$$\n|\\mathcal{R}(Z)|^2 = \\left| \\frac{Z - (R+iI)}{Z + (R+iI)} \\right|^2 = \\frac{|(Z-R) - iI|^2}{|(Z+R) + iI|^2} = \\frac{(Z-R)^2 + I^2}{(Z+R)^2 + I^2}\n$$\n为了找到最小值，我们对 $Z$ 求导并令其结果为零。设 $f(Z) = |\\mathcal{R}(Z)|^2$。\n$$\n\\frac{df}{dZ} = \\frac{2(Z-R)((Z+R)^2 + I^2) - ((Z-R)^2 + I^2)2(Z+R)}{((Z+R)^2 + I^2)^2} = 0\n$$\n分子必须为零。对于无源介质，$\\Re(\\eta_{\\mathrm{in}}) = R \\ge 0$。假设 $R \\ne 0$：\n$$\n(Z-R)((Z+R)^2 + I^2) = (Z+R)((Z-R)^2 + I^2)\n$$\n展开并简化：\n$$\n(Z-R)(Z^2+2ZR+R^2+I^2) = (Z+R)(Z^2-2ZR+R^2+I^2)\n$$\n$$\n(Z-R)(Z+R)(Z+R) + I^2(Z-R) = (Z+R)(Z-R)(Z-R) + I^2(Z+R)\n$$\n$$\n(Z^2-R^2)(Z+R) + I^2(Z-R) = (Z^2-R^2)(Z-R) + I^2(Z+R)\n$$\n$$\n(Z^2-R^2)((Z+R)-(Z-R)) = I^2((Z+R)-(Z-R))\n$$\n$$\n(Z^2-R^2)(2R) = I^2(2R)\n$$\n由于 $R \\neq 0$，我们可以除以 $2R$：\n$$\nZ^2 - R^2 = I^2 \\implies Z^2 = R^2 + I^2 = (\\Re(\\eta_{\\mathrm{in}}))^2 + (\\Im(\\eta_{\\mathrm{in}}))^2 = |\\eta_{\\mathrm{in}}|^2\n$$\n由于 $Z$ 必须为正，最优值为 $Z_{\\mathrm{opt}} = |\\eta_{\\mathrm{in}}|$。\n\n**5. 特化与最终答案**\n\n最后一步是将此结果应用于人工界面 $\\Gamma$ 位于具有参数 $\\mu$ 和 $\\epsilon$ 的均匀层内部的情况。在优化Schwarz方法的实际应用和理论中，最优传输条件通常是通过用一个局部算子来近似非局部DtN算子而导出的，该局部算子的参数仅依赖于界面处介质的局部性质。这等效于假设子域是具有这些局部材料属性的半无限均匀区域。\n\n因此，在这个科学上相关的假设下，我们将异质堆栈的完整、复数输入阻抗 $\\eta_{\\mathrm{in}}$ 替换为 $x=0$ 处介质的局部本征阻抗。\n$$\n\\eta_{\\mathrm{in}} \\approx \\eta_{\\mathrm{local}} = \\sqrt{\\frac{\\mu}{\\epsilon}}\n$$\n这个阻抗是一个实数正值。将其代入我们关于最优参数 $Z_{\\mathrm{opt}}$ 的表达式中：\n$$\nZ_{\\mathrm{opt}} = |\\eta_{\\mathrm{in}}| \\approx \\left| \\sqrt{\\frac{\\mu}{\\epsilon}} \\right| = \\sqrt{\\frac{\\mu}{\\epsilon}}\n$$\n这就得出了仅用界面处局部材料参数 $\\mu$ 和 $\\epsilon$ 表示的最优Robin阻抗参数。", "answer": "$$\\boxed{\\sqrt{\\frac{\\mu}{\\epsilon}}}$$", "id": "3302402"}, {"introduction": "从理论走向实践，本练习要求你实现一个完整的一维区域分解求解器。你将为亥姆霍兹方程编写一个有限元方法（FEM）代码，并将其嵌入到一个优化Schwarz迭代框架中。通过亲手实现该算法并使用不同参数（包括基于物理原理推导出的最优参数）进行测试，你将获得有关DDM代码结构的具体实践经验，并观察到传输条件对收敛性的巨大影响。[@problem_id:3302402]", "problem": "考虑在均匀、各向同性、有源介质中的时谐麦克斯韦方程组，其介电常数为 $\\epsilon$，磁导率为 $\\mu$，频域形式写作\n$$\n\\nabla \\times \\mathbf{H} = \\mathbf{J} + i \\omega \\epsilon \\mathbf{E}, \\quad \\nabla \\times \\mathbf{E} = - i \\omega \\mu \\mathbf{H},\n$$\n其中 $\\mathbf{E}$ 和 $\\mathbf{H}$ 分别为电场和磁场，$\\mathbf{J}$ 为给定的电流密度，$\\omega$ 为角频率。在一维均匀介质中，经过横电波 (TE) 或横磁波 (TM) 简化后，相关标量分量的控制方程简化为亥姆霍兹方程\n$$\n- \\frac{d^2 u}{dx^2} - k^2 u = f(x),\n$$\n该方程定义在有限区间 $x \\in [0, L]$ 上，其中 $u(x)$ 表示一个标量场分量，$k = \\omega \\sqrt{\\mu \\epsilon}$ 是波数，$f(x)$ 是从 $\\mathbf{J}$ 推导出的标量源项。在物理边界上，施加了与 Silver-Müller 辐射条件一致的一维一阶吸收边界条件：\n$$\n\\frac{du}{dx}(0) + i k\\, u(0) = 0, \\quad -\\frac{du}{dx}(L) + i k\\, u(L) = 0.\n$$\n我们旨在采用基于优化 Schwarz 方法的双子区域区域分解法来求解此边值问题。设区间 $[0, L]$ 被划分为两个重叠的子区域 $\\Omega_1 = [0, a]$ 和 $\\Omega_2 = [b, L]$，重叠长度为 $\\delta = a - b \\ge 0$。令 $p \\in \\mathbb{C}$ 为 Robin 传输参数。优化 Schwarz 迭代在人工界面上强制执行 Robin 型传输条件：\n$$\n\\frac{du_1}{dx}(a) + p\\, u_1(a) = -\\frac{du_2}{dx}(a) + p\\, u_2(a), \\quad -\\frac{du_2}{dx}(b) + p\\, u_2(b) = \\frac{du_1}{dx}(b) + p\\, u_1(b),\n$$\n其中 $u_1$ 和 $u_2$ 分别是子区域 $\\Omega_1$ 和 $\\Omega_2$ 上的解。在 $x=0$ 和 $x=L$ 处的吸收边界条件保留用于物理边界。该算法在 $\\Omega_1$ 和 $\\Omega_2$ 上交替求解，使用最新的数据来更新 Robin 传输条件。\n\n从具有 Robin 边界条件的一维亥姆霍兹方程的弱形式出发，推导在均匀网格上使用连续分段线性函数的有限元方法。展示 Robin 边界项如何进入物理边界和人工界面处的双线性形式和线性形式。然后，实现一个程序，该程序：\n- 使用 $N$ 个单元对 $[0, L]$ 进行均匀划分，为亥姆霍兹算子组装一维有限元矩阵。\n- 使用系数 $p$ 求解带 Robin 传输的双子区域优化 Schwarz 迭代，其中人工边界上的非齐次 Robin 数据按上述规定在子区域间均衡。\n- 使用源项 $f(x) = e^{i k x}$，并将子区域迭代初始值设为零。\n- 在每次迭代中，使用与各子区域外法线一致的单边导数构建界面数据，并通过计算两个传输失配量的最大范数来检查收敛性：\n$$\nr_1 = \\left(\\frac{du_1}{dx}(a) + p\\, u_1(a)\\right) - \\left(-\\frac{du_2}{dx}(a) + p\\, u_2(a)\\right), \\quad\nr_2 = \\left(-\\frac{du_2}{dx}(b) + p\\, u_2(b)\\right) - \\left(\\frac{du_1}{dx}(b) + p\\, u_1(b)\\right).\n$$\n当 $\\max(|r_1|, |r_2|)$ 小于指定容差时，即宣告收敛。\n\n最终输出必须是对于每个指定的测试用例达到收敛所需的迭代次数（如果在最大迭代次数内未收敛，则为 $-1$）。输出中不需要物理单位，因为结果是无量纲的迭代次数。\n\n为以下测试套件实现您的解决方案：\n1. $L = 1.0$, $k = 20.0$, $p = i k$, 重叠长度 $\\delta = 0.2$, $N = 400$, 容差 $10^{-8}$, 最大迭代次数 $200$。\n2. $L = 1.0$, $k = 20.0$, $p = 1.0$, 重叠长度 $\\delta = 0.2$, $N = 400$, 容差 $10^{-8}$, 最大迭代次数 $200$。\n3. $L = 1.0$, $k = 40.0$, $p = i k$, 重叠长度 $\\delta = 0.0$ (非重叠), $N = 800$, 容差 $10^{-8}$, 最大迭代次数 $200$。\n\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。", "solution": "用户要求使用双子区域优化 Schwarz 区域分解法，通过有限元方法 (FEM) 实现，来求解一个一维亥姆霍兹边值问题。\n\n### 步骤 1：问题验证\n\n问题指定了控制方程，一个源于 TE/TM 假设下麦克斯韦方程组的一维亥姆霍兹方程：\n$$\n- \\frac{d^2 u}{dx^2} - k^2 u = f(x), \\quad x \\in [0, L]\n$$\n在物理边界 $x=0$ 和 $x=L$ 处，具有一阶吸收边界条件：\n$$\n\\frac{du}{dx}(0) + i k\\, u(0) = 0, \\quad -\\frac{du}{dx}(L) + i k\\, u(L) = 0\n$$\n区域 $[0, L]$ 被划分为两个重叠的子区域 $\\Omega_1 = [0, a]$ 和 $\\Omega_2 = [b, L]$。问题的核心是实现在人工界面 $x=a$ 和 $x=b$ 处带有 Robin 传输条件的优化 Schwarz 迭代：\n$$\n\\frac{du_1}{dx}(a) + p\\, u_1(a) = -\\frac{du_2}{dx}(a) + p u_2(a)\n$$\n$$\n-\\frac{du_2}{dx}(b) + p\\, u_2(b) = \\frac{du_1}{dx}(b) + p u_1(b)\n$$\n问题进一步要求使用连续的分段线性有限元离散化，指定了源项 $f(x) = e^{i k x}$、初始化方法，以及基于传输条件失配的收敛准则。\n\n该问题具有科学依据，是适定的、客观的。它提供了所有必要的信息：偏微分方程、边界条件、区域分解框架、数值方法细节（使用线性基函数的有限元法）、源项和收敛容差。测试用例的参数在物理上和计算上都是合理的。该问题是计算科学和偏微分方程数值分析中的一个标准练习。\n\n**结论：**问题有效。\n\n### 步骤 2：理论构建\n\n#### 弱形式\n我们为一个由 $-u'' - k^2 u = f$ 控制的通用子区域 $[x_L, x_R]$ 推导弱形式，该子区域具有通用的 Robin 边界条件。将方程乘以一个测试函数 $v$ 并在 $[x_L, x_R]$ 上分部积分，得到：\n$$\n\\int_{x_L}^{x_R} u'(x)v'(x) \\,dx - [u'(x)v(x)]_{x_L}^{x_R} - k^2 \\int_{x_L}^{x_R} u(x)v(x) \\,dx = \\int_{x_L}^{x_R} f(x)v(x) \\,dx\n$$\n边界项为 $-u'(x_R)v(x_R) + u'(x_L)v(x_L)$。我们将每个子区域问题的特定边界条件代入。\n\n**子问题 1，在 $\\Omega_1 = [0, a]$ 上**：\n边界条件是：\n1.  $x=0$ 处的物理边界条件：$\\frac{du_1}{dx}(0) + i k u_1(0) = 0 \\implies u_1'(0) = -i k u_1(0)$。\n2.  $x=a$ 处的传输边界条件：$\\frac{du_1}{dx}(a) + p u_1(a) = g_1^{(n)}$，其中 $g_1^{(n)} = -\\frac{du_2^{(n)}}{dx}(a) + p u_2^{(n)}(a)$。这意味着 $u_1'(a) = g_1^{(n)} - p u_1(a)$。\n\n将这些代入 $\\Omega_1$ 的边界项中，得到：\n$$\n-u_1'(a)v(a) + u_1'(0)v(0) = -(g_1^{(n)} - p u_1(a))v(a) + (-i k u_1(0))v(0)\n$$\n$\\Omega_1$ 的弱形式是找到 $u_1 \\in H^1(\\Omega_1)$，使得对于所有 $v \\in H^1(\\Omega_1)$：\n$$\n\\int_{0}^{a} (u_1'v' - k^2 u_1v) \\,dx + p u_1(a)v(a) - i k u_1(0)v(0) = \\int_{0}^{a} fv \\,dx + g_1^{(n)} v(a)\n$$\n\n**子问题 2，在 $\\Omega_2 = [b, L]$ 上**：\n边界条件是：\n1.  $x=b$ 处的传输边界条件：$-\\frac{du_2}{dx}(b) + p u_2(b) = g_2^{(n)}$，其中 $g_2^{(n)} = \\frac{du_1^{(n)}}{dx}(b) + p u_1^{(n)}(b)$。这意味着 $u_2'(b) = p u_2(b) - g_2^{(n)}$。\n2.  $x=L$ 处的物理边界条件：$-\\frac{du_2}{dx}(L) + i k u_2(L) = 0 \\implies u_2'(L) = i k u_2(L)$。\n\n将这些代入 $\\Omega_2$ 的边界项中，得到：\n$$\n-u_2'(L)v(L) + u_2'(b)v(b) = -(i k u_2(L))v(L) + (p u_2(b) - g_2^{(n)})v(b)\n$$\n$\\Omega_2$ 的弱形式是找到 $u_2 \\in H^1(\\Omega_2)$，使得对于所有 $v \\in H^1(\\Omega_2)$：\n$$\n\\int_{b}^{L} (u_2'v' - k^2 u_2v) \\,dx - i k u_2(L)v(L) + p u_2(b)v(b) = \\int_{b}^{L} fv \\,dx + g_2^{(n)} v(b)\n$$\n\n#### 有限元离散化\n我们使用尺寸为 $h=L/N$ 的均匀网格上的连续分段线性基函数（“帽子”函数）$\\phi_j(x)$。近似解为 $u_h(x) = \\sum_j U_j \\phi_j(x)$。将此代入弱形式，得到两个线性代数系统，每个子区域一个，形式为 $A \\mathbf{U} = \\mathbf{b}$。\n\n长度为 $h$ 的单元的单元刚度矩阵和质量矩阵是：\n$$\nK^e = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad M^e = \\frac{h}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}\n$$\n算子 $-u''-k^2 u$ 的整个系统矩阵由 $A^e = K^e - k^2 M^e$ 组装而成。\n\nRobin 边界条件为矩阵的对角线元素和右侧向量贡献了项：\n- 对于 $\\Omega_1$：项 $-i k u_1(0)v(0)$ 将 $-i k$ 加到矩阵元素 $A_{1}[0,0]$。项 $p u_1(a)v(a)$ 将 $p$ 加到 $A_{1}[N_1,N_1]$。项 $g_1^{(n)}v(a)$ 将 $g_1^{(n)}$ 加到 RHS 向量 $b_1$ 的索引 $N_1$ 处。\n- 对于 $\\Omega_2$：项 $p u_2(b)v(b)$ 将 $p$ 加到矩阵元素 $A_{2}[0,0]$。项 $-i k u_2(L)v(L)$ 将 $-i k$ 加到 $A_{2}[m,m]$，其中 $m$ 是最后一个索引。项 $g_2^{(n)}v(b)$ 将 $g_2^{(n)}$ 加到 RHS 向量 $b_2$ 的索引 $0$ 处。\n\n源向量分量 $b_j = \\int f(x)\\phi_j(x) \\,dx$ 在每个单元上使用两点高斯求积进行数值计算，以确保精度。\n\n### 步骤 3：算法实现\n\n该解决方案被实现为并行 Schwarz 迭代（Jacobi 型）。\n\n1.  **初始化**：定义网格和子区域参数 ($h, N_1, N_2$)。将子区域解向量 $U_1$ 和 $U_2$ 初始化为零。预先组装每个子区域的有限元矩阵，包括来自物理和传输边界条件的常数贡献。\n2.  **迭代**：对于每次迭代，直至 `max_iter`：\n    a.  **计算传输数据**：根据前一次迭代的解 $U_1$ 和 $U_2$ 计算 Robin 数据 $g_1$ 和 $g_2$。导数使用与几何一致的单边有限差分来近似（例如，$u_1'(b) \\approx (U_{1,N_2+1} - U_{1,N_2})/h$）。\n    b.  **求解子问题**：用 $g_1$ 和 $g_2$ 更新右侧向量 $b_1$ 和 $b_2$。求解线性系统 $A_1 U_1^{\\text{new}} = b_1$ 和 $A_2 U_2^{\\text{new}} = b_2$ 以获得新解。\n    c.  **检查收敛性**：使用新计算的解 $U_1^{\\text{new}}$ 和 $U_2^{\\text{new}}$，计算界面处 Robin 迹的跳跃作为残差 $r_1$ 和 $r_2$。如果 $\\max(|r_1|, |r_2|)$ 低于指定的容差，则达到收敛。\n    d.  **更新**：用新解替换旧解：$U_1 \\leftarrow U_1^{\\text{new}}$, $U_2 \\leftarrow U_2^{\\text{new}}$。\n3.  **终止**：如果达到收敛，返回迭代次数。如果达到 `max_iter` 仍未收敛，则返回 $-1$。\n\n最终的代码为指定的测试套件实现了此算法。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef assemble_1d_helmholtz(nodes, k, h, f_func):\n    \"\"\"\n    Assembles the 1D FEM system matrix A and source vector b for -u'' - k^2 u = f.\n    Boundary condition terms are added separately.\n    \"\"\"\n    num_nodes = len(nodes)\n    \n    # Elemental matrices\n    Ke = (1 / h) * np.array([[1, -1], [-1, 1]])\n    Me = (h / 6) * np.array([[2, 1], [1, 2]])\n    Ae = Ke - k**2 * Me\n\n    # Assembly\n    A = np.zeros((num_nodes, num_nodes), dtype=np.complex128)\n    for i in range(num_nodes - 1):\n        A[i:i+2, i:i+2] += Ae\n\n    # Assemble RHS vector b using 2-point Gaussian Quadrature\n    b = np.zeros(num_nodes, dtype=np.complex128)\n    gq_pts = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])\n    gq_wts = np.array([1, 1])\n    \n    for i in range(num_nodes - 1):\n        x_i, x_ip1 = nodes[i], nodes[i+1]\n        phys_pts = 0.5 * (x_ip1 - x_i) * gq_pts + 0.5 * (x_ip1 + x_i)\n        \n        f_vals = f_func(phys_pts)\n        phi_i_vals = 0.5 * (1 - gq_pts)\n        phi_ip1_vals = 0.5 * (1 + gq_pts)\n        \n        integral_factor = 0.5 * h\n        b[i] += integral_factor * np.sum(gq_wts * f_vals * phi_i_vals)\n        b[i+1] += integral_factor * np.sum(gq_wts * f_vals * phi_ip1_vals)\n\n    return A, b\n\ndef run_schwarz_iteration(L, k, p, delta, N, tol, max_iter):\n    h = L / N\n    x = np.linspace(0, L, N + 1)\n    \n    f_func = lambda x_val: np.exp(1j * k * x_val)\n\n    # Subdomain definitions\n    if delta >= 0:\n        b = (L - delta) / 2\n        a = b + delta\n        N2 = int(round(b / h))\n        N1 = int(round(a / h))\n    \n    nodes1 = x[0:N1+1]\n    nodes2 = x[N2:N+1]\n    \n    u1 = np.zeros(len(nodes1), dtype=np.complex128)\n    u2 = np.zeros(len(nodes2), dtype=np.complex128)\n    \n    # Pre-assemble matrices and source vectors\n    A1_base, b1_base = assemble_1d_helmholtz(nodes1, k, h, f_func)\n    A2_base, b2_base = assemble_1d_helmholtz(nodes2, k, h, f_func)\n    \n    # Add matrix contributions from boundary conditions\n    # Physical BC on Omega1 at x=0: u' + iku = 0 => add -ik to A[0,0]\n    A1_base[0, 0] += -1j * k\n    # Transmission BC on Omega1 at x=a: u' + pu = g1 => add p to A[-1,-1]\n    A1_base[-1, -1] += p\n    \n    # Transmission BC on Omega2 at x=b: -u' + pu = g2 => add p to A[0,0]\n    A2_base[0, 0] += p\n    # Physical BC on Omega2 at x=L: -u' + iku = 0 => add -ik to A[-1,-1]\n    A2_base[-1, -1] += -1j * k\n    \n    A1_sparse = sparse.csr_matrix(A1_base)\n    A2_sparse = sparse.csr_matrix(A2_base)\n\n    for n_iter in range(max_iter):\n        # 1. Compute transmission data g1, g2 from previous step\n        idx_a_in_2 = N1 - N2\n        u2_at_a = u2[idx_a_in_2]\n        du2dx_at_a = (u2[idx_a_in_2] - u2[idx_a_in_2 - 1]) / h if idx_a_in_2 > 0 else 0\n        g1 = -du2dx_at_a + p * u2_at_a\n        \n        idx_b_in_1 = N2\n        u1_at_b = u1[idx_b_in_1]\n        du1dx_at_b = (u1[idx_b_in_1 + 1] - u1[idx_b_in_1]) / h if idx_b_in_1  len(u1) - 1 else 0\n        g2 = du1dx_at_b + p * u1_at_b\n        \n        # 2. Solve on subdomains\n        b1 = b1_base.copy()\n        b1[-1] += g1\n        \n        b2 = b2_base.copy()\n        b2[0] += g2\n        \n        u1_new = spsolve(A1_sparse, b1)\n        u2_new = spsolve(A2_sparse, b2)\n        \n        # 3. Check for convergence using new solutions\n        # Residual at x=a\n        du1new_dx_at_a = (u1_new[-1] - u1_new[-2]) / h\n        term1_r1 = du1new_dx_at_a + p * u1_new[-1]\n        \n        du2new_dx_at_a = (u2_new[idx_a_in_2] - u2_new[idx_a_in_2 - 1]) / h if idx_a_in_2 > 0 else 0\n        term2_r1 = -du2new_dx_at_a + p * u2_new[idx_a_in_2]\n        r1 = term1_r1 - term2_r1\n        \n        # Residual at x=b\n        du2new_dx_at_b = (u2_new[1] - u2_new[0]) / h if len(u2_new) > 1 else 0\n        term1_r2 = -du2new_dx_at_b + p * u2_new[0]\n        \n        du1new_dx_at_b = (u1_new[idx_b_in_1 + 1] - u1_new[idx_b_in_1]) / h if idx_b_in_1  len(u1_new) - 1 else 0\n        term2_r2 = du1new_dx_at_b + p * u1_new[idx_b_in_1]\n        r2 = term1_r2 - term2_r2\n        \n        residual = max(abs(r1), abs(r2))\n        \n        if residual  tol:\n            return n_iter + 1\n        \n        # 4. Update solutions\n        u1, u2 = u1_new, u2_new\n        \n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (L, k, p, delta, N, tol, max_iter)\n        (1.0, 20.0, 1j * 20.0, 0.2, 400, 1e-8, 200),\n        (1.0, 20.0, 1.0, 0.2, 400, 1e-8, 200),\n        (1.0, 40.0, 1j * 40.0, 0.0, 800, 1e-8, 200),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, k, p, delta, N, tol, max_iter = case\n        n_iters = run_schwarz_iteration(L, k, p, delta, N, tol, max_iter)\n        results.append(n_iters)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3302374"}, {"introduction": "真实的模拟任务常常需要自适应网格技术，即在不同区域使用不同的离散化参数，例如可变的插值多项式次数（$p$-自适应）。本练习旨在解决在子域交界面上耦合非协调有限元空间这一高级挑战。你将设计并实现一个投影算子，该算子能在不同多项式次数的迹空间之间正确传递信息，同时保持麦克斯韦方程所要求的关键的 $H(\\mathrm{curl})$-协调性。这是开发灵活且功能强大的DDM求解器的一项核心技能。", "problem": "考虑二维空间中的时谐麦克斯韦边界值问题，其中电场由一个向量场表示，在没有表面电流的情况下，其切向分量在内部界面上必须是连续的。在使用区域分解法（DDM）的有限元法（FEM）进行子结构分析时，计算域被划分为共享一个界面的多个子域。对于 Nédélec 型的基于边的 $H(\\mathrm{curl})$（旋度平方可积的平方可积向量场构成的 Sobolev 空间）有限元，电场沿内部边的切向迹必须在子域之间保持连续。在 $p$ 自适应设置中，不同的子域可以使用不同的多项式阶数，这使得我们必须设计投影算子，以便在不匹配的多项式空间之间传递切向迹，同时保持斯托克斯定理和麦克斯韦界面条件所要求的旋度协调性。\n\n假设两个子域共享一个直线界面 $\\Gamma$，该界面被参数化为区间 $[0,1]$，坐标为 $y \\in [0,1]$。对于多项式阶数 $p \\in \\mathbb{N}_0$，$\\Gamma$ 上的切向迹空间是关于 $y$ 的次数至多为 $p$ 的多项式空间。使用 $[0,1]$ 上的标准正交基 $\\{\\phi_i(y)\\}_{i=0}^{p}$，定义如下：对于每个整数 $i \\ge 0$，令 $P_i(x)$ 为 $[-1,1]$ 上的 $i$ 次勒让德多项式，并进行归一化使得 $P_i(1)=1$。定义\n$$\n\\phi_i(y) \\equiv \\sqrt{2 i + 1}\\, P_i(2y - 1),\n$$\n该定义满足\n$$\n\\int_{0}^{1} \\phi_i(y) \\, \\phi_j(y) \\, dy = \\delta_{ij}\n$$\n对于所有整数 $i,j \\ge 0$。\n\n假设左子域使用多项式阶数 $p_{\\mathrm{L}} \\in \\mathbb{N}_0$，右子域使用多项式阶数 $p_{\\mathrm{R}} \\in \\mathbb{N}_0$。来自左子域在 $\\Gamma$ 上的一个切向迹由其相对于基 $\\{\\phi_i\\}_{i=0}^{p_{\\mathrm{L}}}$ 的系数向量 $\\mathbf{c}_{\\mathrm{L}} \\in \\mathbb{R}^{p_{\\mathrm{L}}+1}$ 表示；类似地，右侧的迹使用相对于基 $\\{\\phi_i\\}_{i=0}^{p_{\\mathrm{R}}}$ 的系数向量 $\\mathbf{c}_{\\mathrm{R}} \\in \\mathbb{R}^{p_{\\mathrm{R}}+1}$。$\\Gamma$ 上单位切向量的方向在两个子域之间可能相反；用一个方向参数 $\\sigma \\in \\{+1,-1\\}$ 来表示，其中 $\\sigma=-1$ 表示右子域的局部切向量与左子域的相反，而 $\\sigma=+1$ 表示方向相同。\n\n您的任务是：\n\n- 从麦克斯韦方程组的弱形式和斯托克斯定理出发，为一个将 $\\mathbf{c}_{\\mathrm{L}} \\mapsto \\mathbf{c}_{\\mathrm{R}}$ 映射的线性投影算子建立一个有原则的、基无关的条件，使得：\n  1. 当 $\\sigma = -1$ 时，在全局组装中，旋度矩的界面贡献相互抵消，即对于右迹空间中的每个测试多项式 $q$，左迹和右迹的带符号矩之和为零。\n  2. 当 $\\sigma = +1$ 时，对于来自公共迹空间的所有测试多项式，两侧的切向矩相匹配。\n  您的公式必须仅依赖于与 $H(\\mathrm{curl})$ 协调性一致的切向矩守恒，并且不得假设任何多项式阶数的先验匹配。\n\n- 将您的公式特化到多项式基 $\\{\\phi_i\\}$，并推导出一个可实现的算法。该算法给定 $(p_{\\mathrm{L}}, p_{\\mathrm{R}}, \\sigma, \\mathbf{c}_{\\mathrm{L}})$，通过高斯-勒让德求积计算在 $[0,1]$ 上的数值组装内积来强制施加矩条件，从而计算 $\\mathbf{c}_{\\mathrm{R}}$。您的算法对于所有非负整数 $p_{\\mathrm{L}}$ 和 $p_{\\mathrm{R}}$ 以及两种方向 $\\sigma \\in \\{+1,-1\\}$ 都必须是鲁棒的。\n\n- 将该算法实现为一个完整的、可在指定环境中运行的程序，该程序：\n  1. 使用勒让德多项式在 $[0,1]$ 上构建标准正交基 $\\{\\phi_i\\}$。\n  2. 通过高斯-勒让德求积组装所需的内积矩阵，使用的求积阶数足以精确积分所有由次数最高为 $\\max(2 p_{\\mathrm{L}}, 2 p_{\\mathrm{R}})$ 的基函数乘积产生的多项式。\n  3. 对于下面的每个测试用例，根据 $\\mathbf{c}_{\\mathrm{L}}$ 计算投影 $\\mathbf{c}_{\\mathrm{R}}$。\n  4. 通过检查矩的抵消或匹配情况，验证界面处的旋度协调性：\n     - 对于 $\\sigma=-1$，检查对于每个索引 $j \\in \\{0,1,\\dots,p_{\\mathrm{R}}\\}$，\n       $$\n       \\left| \\int_0^1 \\left(\\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\, \\phi_i(y)\\right) \\, \\phi_j(y) \\, dy \\;+\\; \\int_0^1 \\left(\\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\, \\phi_k(y)\\right) \\, \\phi_j(y) \\, dy \\right| \\le \\varepsilon,\n       $$\n       容差为 $\\varepsilon = 10^{-10}$。\n     - 对于 $\\sigma=+1$，检查对于每个索引 $j \\in \\{0,1,\\dots,\\min(p_{\\mathrm{L}},p_{\\mathrm{R}})\\}$,\n       $$\n       \\left| \\int_0^1 \\left(\\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\, \\phi_i(y)\\right) \\, \\phi_j(y) \\, dy \\;-\\; \\int_0^1 \\left(\\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\, \\phi_k(y)\\right) \\, \\phi_j(y) \\, dy \\right| \\le \\varepsilon,\n       $$\n       容差同样为 $\\varepsilon = 10^{-10}$。\n\n测试套件：\n\n- 情况 1（正常路径，从高阶到低阶，方向相反）：$p_{\\mathrm{L}}=4$, $p_{\\mathrm{R}}=2$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.5,\\,-0.3,\\,0.2,\\,-0.4,\\,0.1\\,]^{\\top}$。\n- 情况 2（边界情况，均为最低阶，方向相反）：$p_{\\mathrm{L}}=0$, $p_{\\mathrm{R}}=0$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.123456789\\,]^{\\top}$。\n- 情况 3（阶数相等，方向相反）：$p_{\\mathrm{L}}=3$, $p_{\\mathrm{R}}=3$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.1,\\,0.2,\\,-0.1,\\,0.05\\,]^{\\top}$。\n- 情况 4（从低阶到高阶，方向相同）：$p_{\\mathrm{L}}=2$, $p_{\\mathrm{R}}=5$, $\\sigma=+1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.7,\\,-0.25,\\,0.33\\,]^{\\top}$。\n- 情况 5（压力情况，强不协调，方向相反）：$p_{\\mathrm{L}}=5$, $p_{\\mathrm{R}}=1$, $\\sigma=-1$, $\\mathbf{c}_{\\mathrm{L}} = [\\,0.0,\\,1.0,\\,0.0,\\,-0.2,\\,0.3,\\,-0.1\\,]^{\\top}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[True,False,True]`），其中每个条目是一个布尔值，表示相应的案例是否在给定容差内满足各自的旋度协调性矩条件。不需要物理单位。不涉及角度。不涉及百分比。", "solution": "该问题要求为在共享界面上不匹配的多项式空间之间的向量场切向迹制定并实现一个投影算子，这是麦克斯韦方程组有限元分析中 $p$ 自适应区域分解法的一项常见任务。\n\n### 步骤 1：投影算子的构建\n\n设计算域 $\\Omega$ 被划分为多个子域，包括一个左子域 $\\Omega_{\\mathrm{L}}$ 和一个右子域 $\\Omega_{\\mathrm{R}}$，它们共享一个公共界面 $\\Gamma$。对于 $H(\\mathrm{curl})$ 协调有限元，必须在 $\\Gamma$ 上强制电场 $\\mathbf{E}$ 的切向分量 $\\mathbf{E}_{\\tau}$ 的连续性。\n\n设 $\\mathbf{t}_{\\mathrm{L}}$ 和 $\\mathbf{t}_{\\mathrm{R}}$ 分别为定义左、右子域在 $\\Gamma$ 上局部参数化的单位切向量。方向参数 $\\sigma \\in \\{+1, -1\\}$ 通过 $\\mathbf{t}_{\\mathrm{R}} = \\sigma \\mathbf{t}_{\\mathrm{L}}$ 将它们关联起来。切向电场是向量，由 $\\mathbf{E}_{\\tau, \\mathrm{L}} = u_{\\mathrm{L}} \\mathbf{t}_{\\mathrm{L}}$ 和 $\\mathbf{E}_{\\tau, \\mathrm{R}} = u_{\\mathrm{R}} \\mathbf{t}_{\\mathrm{R}}$ 给出，其中 $u_{\\mathrm{L}}$ 和 $u_{\\mathrm{R}}$ 是标量切向迹函数。\n\n切向连续性的物理条件是 $\\mathbf{E}_{\\tau, \\mathrm{L}} = \\mathbf{E}_{\\tau, \\mathrm{R}}$。代入局部表示法可得：\n$$\nu_{\\mathrm{L}}(y) \\mathbf{t}_{\\mathrm{L}} = u_{\\mathrm{R}}(y) \\mathbf{t}_{\\mathrm{R}} = u_{\\mathrm{R}}(y) (\\sigma \\mathbf{t}_{\\mathrm{L}})\n$$\n这导出了关于标量迹的强逐点条件：$u_{\\mathrm{L}}(y) = \\sigma u_{\\mathrm{R}}(y)$。\n\n在弱形式中，此条件通过要求其在与一个合适的函数空间进行积分测试时成立来强制执行。一个有原则的选择是，从左迹空间 $V_{\\mathrm{L}} = \\mathrm{span}\\{\\phi_i\\}_{i=0}^{p_{\\mathrm{L}}}$ 到右迹空间 $V_{\\mathrm{R}} = \\mathrm{span}\\{\\phi_k\\}_{k=0}^{p_{\\mathrm{R}}}$ 定义一个投影，即要求该条件对目标空间 $V_{\\mathrm{R}}$ 的所有基函数都成立。这是一种 $L^2$ 投影的形式。\n\n基无关的条件是，对于给定的 $u_{\\mathrm{L}} \\in V_{\\mathrm{L}}$，寻找一个 $u_{\\mathrm{R}} \\in V_{\\mathrm{R}}$ 使得：\n$$\n\\int_{\\Gamma} \\left( u_{\\mathrm{L}}(y) - \\sigma u_{\\mathrm{R}}(y) \\right) q(y) \\, dy = 0, \\quad \\forall q(y) \\in V_{\\mathrm{R}}\n$$\n这等价于 $\\int_{\\Gamma} u_{\\mathrm{L}}(y) q(y) \\, dy = \\sigma \\int_{\\Gamma} u_{\\mathrm{R}}(y) q(y) \\, dy$。此公式与问题对 $\\sigma=-1$（矩抵消）和 $\\sigma=+1$（矩匹配）的要求一致。\n\n### 步骤 2：算法推导\n\n我们将上述公式特化到给定的标准正交基 $\\{\\phi_i(y)\\}$。设 $u_{\\mathrm{L}}(y) = \\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\phi_i(y)$ 和 $u_{\\mathrm{R}}(y) = \\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\phi_k(y)$。测试函数为 $q(y) = \\phi_j(y)$，其中 $j \\in \\{0, 1, \\dots, p_{\\mathrm{R}}\\}$。\n\n代入弱条件中：\n$$\n\\int_{0}^{1} \\left( \\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\phi_i(y) \\right) \\phi_j(y) \\, dy = \\sigma \\int_{0}^{1} \\left( \\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\phi_k(y) \\right) \\phi_j(y) \\, dy\n$$\n由于基 $\\{\\phi_k(y)\\}_{k=0}^{p_{\\mathrm{R}}}$ 的标准正交性，右侧得以简化。因为 $j \\le p_{\\mathrm{R}}$，我们有 $\\int_{0}^{1} \\phi_k(y) \\phi_j(y) \\, dy = \\delta_{kj}$：\n$$\n\\sigma \\sum_{k=0}^{p_{\\mathrm{R}}} \\mathbf{c}_{\\mathrm{R}}[k] \\delta_{kj} = \\sigma \\mathbf{c}_{\\mathrm{R}}[j]\n$$\n左侧是 $u_{\\mathrm{L}}$ 在基函数 $\\phi_j$ 上的投影：\n$$\n\\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\int_{0}^{1} \\phi_i(y) \\phi_j(y) \\, dy\n$$\n结合以上两部分，我们得到计算 $\\mathbf{c}_{\\mathrm{R}}$ 每个系数的显式公式：\n$$\n\\mathbf{c}_{\\mathrm{R}}[j] = \\frac{1}{\\sigma} \\sum_{i=0}^{p_{\\mathrm{L}}} \\mathbf{c}_{\\mathrm{L}}[i] \\int_{0}^{1} \\phi_i(y) \\phi_j(y) \\, dy\n$$\n由于 $\\sigma^2=1$，我们有 $1/\\sigma = \\sigma$。我们定义一个 $(p_{\\mathrm{R}}+1) \\times (p_{\\mathrm{L}}+1)$ 的质量矩阵 $M$，其元素为 $M_{ji} = \\int_{0}^{1} \\phi_i(y) \\phi_j(y) \\, dy$。整个投影可以写成一个矩阵向量乘积：\n$$\n\\mathbf{c}_{\\mathrm{R}} = \\sigma M \\mathbf{c}_{\\mathrm{L}}\n$$\n### 步骤 3：实现细节\n\n该算法对每个测试用例 $(p_{\\mathrm{L}}, p_{\\mathrm{R}}, \\sigma, \\mathbf{c}_{\\mathrm{L}})$ 包含以下步骤：\n1.  **基函数**：实现函数 $\\phi_i(y) = \\sqrt{2 i + 1}\\, P_i(2y - 1)$，其中 $P_i$ 是 `scipy.special` 中可用的标准勒让德多项式。\n2.  **求积**：在 $[0,1]$ 上建立一个足够高阶的高斯-勒让德求积法则，以精确计算矩阵元素。被积函数 $\\phi_i(y)\\phi_j(y)$ 是一个次数为 $i+j$ 的多项式。验证步骤中遇到的最高次数为 $\\max(p_{\\mathrm{L}}, p_{\\mathrm{R}}) + p_{\\mathrm{R}}$。问题指定了求积阶数 $N_q$ 足以处理最高为 $\\max(2p_{\\mathrm{L}}, 2p_{\\mathrm{R}})$ 次的多项式。这意味着选择 $N_q = \\max(p_{\\mathrm{L}}, p_{\\mathrm{R}}) + 1$ 就绰绰有余了。\n3.  **矩阵组装**：通过求积法则数值计算每个积分 $M_{ji}$ 来计算矩阵 $M$：$M_{ji} \\approx \\sum_{k=1}^{N_q} w'_k \\phi_i(y_k) \\phi_j(y_k)$，其中 $(y_k, w'_k)$ 是 $[0,1]$ 上的求积点和权重。\n4.  **投影**：使用矩阵向量乘积 $\\mathbf{c}_{\\mathrm{R}} = \\sigma M \\mathbf{c}_{\\mathrm{L}}$ 计算投影后的系数向量 $\\mathbf{c}_{\\mathrm{R}}$。\n5.  **验证**：对每个测试用例，使用相同的数值求积方案验证相应的矩条件。\n    -   对于 $\\sigma = -1$，检查是否对所有 $j \\in \\{0, \\dots, p_{\\mathrm{R}}\\}$，都有 $|\\int_0^1 (u_{\\mathrm{L}} + u_{\\mathrm{R}}) \\phi_j(y) \\, dy| \\le \\varepsilon$。\n    -   对于 $\\sigma = +1$，检查是否对所有 $j \\in \\{0, \\dots, \\min(p_{\\mathrm{L}}, p_{\\mathrm{R}})\\}$, 都有 $|\\int_0^1 (u_{\\mathrm{L}} - u_{\\mathrm{R}}) \\phi_j(y) \\, dy| \\le \\varepsilon$。\n    积分以求积点上的和进行数值计算。此检查的布尔结果是该案例的输出。根据构造，这些检查应该在浮点算术的精度范围内通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef run_case(p_L, p_R, sigma, c_L):\n    \"\"\"\n    Computes the projection and verifies the moment conditions for a single test case.\n\n    Args:\n        p_L (int): Polynomial order for the left subdomain.\n        p_R (int): Polynomial order for the right subdomain.\n        sigma (int): Orientation parameter, either +1 or -1.\n        c_L (np.ndarray): Coefficient vector for the left trace.\n\n    Returns:\n        bool: True if the moment conditions are satisfied within tolerance, False otherwise.\n    \"\"\"\n    epsilon = 1e-10\n\n    # 1. Define basis functions using Legendre polynomials\n    # The basis is phi_i(y) = sqrt(2i+1) * P_i(2y-1) for y in [0,1].\n    # scipy.special.legendre P_i are normalized with P_i(1)=1.\n    p_max_basis = max(p_L, p_R)\n    legendre_polys = {i: legendre(i) for i in range(p_max_basis + 1)}\n    \n    def phi(i, y):\n        # y can be a scalar or a numpy array\n        return np.sqrt(2 * i + 1) * legendre_polys[i](2 * y - 1)\n\n    # 2. Set up Gauss-Legendre quadrature on [0, 1]\n    # Quadrature order sufficient to integrate polynomials of degree up to max(2*p_L, 2*p_R)\n    # The highest degree polynomial we need to integrate is for verification, u_L * phi_j, which has degree p_L + p_R.\n    # A quadrature rule with N_q points is exact for polynomials of degree 2*N_q - 1.\n    # We need 2*N_q - 1 >= p_L + p_R. So N_q >= (p_L + p_R + 1) / 2.\n    quad_deg_needed = p_L + p_R\n    N_q = (quad_deg_needed // 2) + 1\n    \n    # Get nodes and weights for [-1, 1] and scale to [0, 1]\n    x_q, w_q = np.polynomial.legendre.leggauss(N_q)\n    y_q = (x_q + 1) / 2.0\n    w_q_scaled = w_q / 2.0\n\n    # 3. Assemble the (p_R+1) x (p_L+1) mass matrix M_ji = integral(phi_i * phi_j dy)\n    phi_vals_L = np.array([phi(i, y_q) for i in range(p_L + 1)]) # Shape (p_L+1, N_q)\n    phi_vals_R = np.array([phi(j, y_q) for j in range(p_R + 1)]) # Shape (p_R+1, N_q)\n    \n    M = phi_vals_R @ (phi_vals_L.T * w_q_scaled[:, np.newaxis])\n    \n    # 4. Compute projected coefficients c_R = sigma * M @ c_L\n    c_R = sigma * (M @ c_L)\n    \n    # 5. Verify curl-conformity moment conditions using numerical quadrature\n    u_L_at_yq = c_L @ phi_vals_L\n    u_R_at_yq = c_R @ phi_vals_R\n    \n    all_checks_passed = True\n    if sigma == -1:\n        # Check condition for j in {0, ..., p_R}\n        for j in range(p_R + 1):\n            phi_j_at_yq = phi_vals_R[j, :]\n            \n            moment_L = np.sum(w_q_scaled * u_L_at_yq * phi_j_at_yq)\n            moment_R = np.sum(w_q_scaled * u_R_at_yq * phi_j_at_yq)\n            \n            error = np.abs(moment_L + moment_R)\n            if error > epsilon:\n                all_checks_passed = False\n                break\n    elif sigma == 1:\n        # Check condition for j in {0, ..., min(p_L, p_R)}\n        p_min = min(p_L, p_R)\n        # Test functions phi_j must be in the common space. Here we can test against V_R's basis up to p_min.\n        for j in range(p_min + 1):\n            phi_j_at_yq = phi_vals_R[j, :]\n            \n            moment_L = np.sum(w_q_scaled * u_L_at_yq * phi_j_at_yq)\n            moment_R = np.sum(w_q_scaled * u_R_at_yq * phi_j_at_yq)\n            \n            error = np.abs(moment_L - moment_R)\n            if error > epsilon:\n                all_checks_passed = False\n                break\n                \n    return all_checks_passed\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 2, -1, [0.5, -0.3, 0.2, -0.4, 0.1]),\n        (0, 0, -1, [0.123456789]),\n        (3, 3, -1, [0.1, 0.2, -0.1, 0.05]),\n        (2, 5, 1,  [0.7, -0.25, 0.33]),\n        (5, 1, -1, [0.0, 1.0, 0.0, -0.2, 0.3, -0.1]),\n    ]\n\n    results = []\n    for p_L, p_R, sigma, c_L in test_cases:\n        is_valid = run_case(p_L, p_R, sigma, np.array(c_L))\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    # Convert booleans to lowercase 'true'/'false' as per standard JSON/Python practice\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3302373"}]}