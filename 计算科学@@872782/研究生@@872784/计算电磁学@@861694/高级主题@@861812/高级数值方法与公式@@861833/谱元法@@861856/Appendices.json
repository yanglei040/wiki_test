{"hands_on_practices": [{"introduction": "掌握谱元法的第一步是深刻理解其所依赖的有限元空间的数学结构。本练习是一个基础性的推导，旨在引导你计算三维六面体上Nédélec类型旋度协调元的自由度数量[@problem_id:3350019]。通过将计算结果与离散de Rham序列的性质进行验证，你将能更深入地领会这套精巧的数学框架，正是它保证了谱元法在电磁学计算中的稳定性和准确性。", "problem": "设 $K$ 为三维空间中的参考六面体，并设 $\\mathcal{Q}_{a,b,c}$ 表示 $K$ 上的张量积多项式空间，由在第一、第二和第三个坐标上的次数分别至多为 $a$、$b$ 和 $c$ 的多项式组成。考虑 $K$ 上多项式阶数为 $p \\geq 1$ 的第一类 Nédélec $H(\\mathrm{curl})$协调谱元空间，它由张量积多项式构建，其分量形式定义为\n$$\n\\mathcal{N}_{p}(K) \\equiv \\left[\\mathcal{Q}_{p-1,p,p}\\right] \\times \\left[\\mathcal{Q}_{p,p-1,p}\\right] \\times \\left[\\mathcal{Q}_{p,p,p-1}\\right].\n$$\n从张量积定义 $\\dim \\mathcal{Q}_{a,b,c} = (a+1)(b+1)(c+1)$ 和 $K$ 上的离散 de Rham 序列出发\n$$\n\\mathcal{Q}_{p,p,p} \\xrightarrow{\\ \\nabla\\ } \\mathcal{N}_{p}(K) \\xrightarrow{\\ \\nabla \\times\\ } \\mathcal{R}\\mathcal{T}_{p}(K) \\xrightarrow{\\ \\nabla \\cdot\\ } \\mathcal{Q}_{p-1,p-1,p-1},\n$$\n其中 Raviart–Thomas $H(\\mathrm{div})$ 空间由下式给出\n$$\n\\mathcal{R}\\mathcal{T}_{p}(K) \\equiv \\left[\\mathcal{Q}_{p,p-1,p-1}\\right] \\times \\left[\\mathcal{Q}_{p-1,p,p-1}\\right] \\times \\left[\\mathcal{Q}_{p-1,p-1,p}\\right],\n$$\n推导 $\\dim \\mathcal{N}_{p}(K)$ 作为 $p$ 的函数的闭式表达式，并通过维数计算来验证它与上述离散序列的正合性是一致的（即，由正合性所蕴含的交错和恒等式成立）。请以 $p$ 的单一解析表达式的形式给出最终答案。无需四舍五入，也不应包含单位。", "solution": "该问题要求完成两项主要任务：首先，推导 Nédélec 空间 $\\mathcal{N}_{p}(K)$ 的维数；其次，通过检查该维数与所给离散 de Rham 序列的一致性来验证结果。\n\n在参考六面体 $K$ 上，多项式阶数为 $p \\geq 1$ 的第一类 Nédélec $H(\\mathrm{curl})$协调空间被分量式地定义为张量积多项式空间的笛卡尔积：\n$$\n\\mathcal{N}_{p}(K) \\equiv \\left[\\mathcal{Q}_{p-1,p,p}\\right] \\times \\left[\\mathcal{Q}_{p,p-1,p}\\right] \\times \\left[\\mathcal{Q}_{p,p,p-1}\\right].\n$$\n定义为其他向量空间的笛卡尔积的向量空间的维数是其组成空间维数的和。因此，$\\mathcal{N}_{p}(K)$ 的维数由下式给出：\n$$\n\\dim \\mathcal{N}_{p}(K) = \\dim \\mathcal{Q}_{p-1,p,p} + \\dim \\mathcal{Q}_{p,p-1,p} + \\dim \\mathcal{Q}_{p,p,p-1}.\n$$\n我们已知张量积多项式空间 $\\mathcal{Q}_{a,b,c}$ 的维数公式：\n$$\n\\dim \\mathcal{Q}_{a,b,c} = (a+1)(b+1)(c+1).\n$$\n将此公式应用于 $\\mathcal{N}_{p}(K)$ 的每个分量空间：\n\\begin{itemize}\n    \\item $\\dim \\mathcal{Q}_{p-1,p,p} = ((p-1)+1)(p+1)(p+1) = p(p+1)^{2}$\n    \\item $\\dim \\mathcal{Q}_{p,p-1,p} = (p+1)((p-1)+1)(p+1) = (p+1)p(p+1) = p(p+1)^{2}$\n    \\item $\\dim \\mathcal{Q}_{p,p,p-1} = (p+1)(p+1)((p-1)+1) = (p+1)^{2}p = p(p+1)^{2}$\n\\end{itemize}\n将这些维数相加，得到 $\\mathcal{N}_{p}(K)$ 的总维数：\n$$\n\\dim \\mathcal{N}_{p}(K) = p(p+1)^{2} + p(p+1)^{2} + p(p+1)^{2} = 3p(p+1)^{2}.\n$$\n展开这个多项式可得 $3p(p^{2}+2p+1) = 3p^{3}+6p^{2}+3p$。\n\n接下来，我们利用所给离散 de Rham 序列的正合性来验证这一结果。完整的序列，包括标准的初始和末尾空间，是：\n$$\n0 \\rightarrow \\mathbb{R} \\xrightarrow{\\ i\\ } \\mathcal{Q}_{p,p,p} \\xrightarrow{\\ \\nabla\\ } \\mathcal{N}_{p}(K) \\xrightarrow{\\ \\nabla \\times\\ } \\mathcal{R}\\mathcal{T}_{p}(K) \\xrightarrow{\\ \\nabla \\cdot\\ } \\mathcal{Q}_{p-1,p-1,p-1} \\rightarrow 0\n$$\n其中 $i$ 是常数函数的包含映射。对于一个有限维向量空间序列，若要其为正合序列，则各空间维数的交错和必须为零。设这些空间为 $W_0 = \\mathbb{R}$，$W_1 = \\mathcal{Q}_{p,p,p}$，$W_2 = \\mathcal{N}_{p}(K)$，$W_3 = \\mathcal{R}\\mathcal{T}_{p}(K)$ 和 $W_4 = \\mathcal{Q}_{p-1,p-1,p-1}$。正合性条件意味着：\n$$\n\\dim W_0 - \\dim W_1 + \\dim W_2 - \\dim W_3 + \\dim W_4 = 0.\n$$\n我们必须计算序列中每个空间的维数：\n\\begin{itemize}\n    \\item $\\dim W_0 = \\dim \\mathbb{R} = 1$。\n    \\item $\\dim W_1 = \\dim \\mathcal{Q}_{p,p,p} = (p+1)(p+1)(p+1) = (p+1)^{3}$。\n    \\item $\\dim W_2 = \\dim \\mathcal{N}_{p}(K) = 3p(p+1)^{2}$，如上所推导。\n    \\item $\\dim W_3 = \\dim \\mathcal{R}\\mathcal{T}_{p}(K)$。Raviart-Thomas 空间定义为 $\\mathcal{R}\\mathcal{T}_{p}(K) \\equiv \\left[\\mathcal{Q}_{p,p-1,p-1}\\right] \\times \\left[\\mathcal{Q}_{p-1,p,p-1}\\right] \\times \\left[\\mathcal{Q}_{p-1,p-1,p}\\right]$。其维数是其分量维数的和：\n    $$\n    \\dim \\mathcal{R}\\mathcal{T}_{p}(K) = \\dim \\mathcal{Q}_{p,p-1,p-1} + \\dim \\mathcal{Q}_{p-1,p,p-1} + \\dim \\mathcal{Q}_{p-1,p-1,p}.\n    $$\n    每个分量的维数为 $(p+1)((p-1)+1)((p-1)+1) = (p+1)p^{2}$。因此，\n    $$\n    \\dim \\mathcal{R}\\mathcal{T}_{p}(K) = 3p^{2}(p+1).\n    $$\n    \\item $\\dim W_4 = \\dim \\mathcal{Q}_{p-1,p-1,p-1} = ((p-1)+1)((p-1)+1)((p-1)+1) = p^{3}$。\n\\end{itemize}\n将这些维数代入交错和方程：\n$$\n1 - (p+1)^{3} + 3p(p+1)^{2} - 3p^{2}(p+1) + p^{3}.\n$$\n为了验证此和为零，我们展开各项：\n\\begin{itemize}\n    \\item $(p+1)^{3} = p^{3} + 3p^{2} + 3p + 1$\n    \\item $3p(p+1)^{2} = 3p(p^{2} + 2p + 1) = 3p^{3} + 6p^{2} + 3p$\n    \\item $3p^{2}(p+1) = 3p^{3} + 3p^{2}$\n\\end{itemize}\n和变为：\n$$\n1 - (p^{3} + 3p^{2} + 3p + 1) + (3p^{3} + 6p^{2} + 3p) - (3p^{3} + 3p^{2}) + p^{3}.\n$$\n按 $p$ 的幂次合并同类项：\n\\begin{itemize}\n    \\item $p^{3}$: $-1 + 3 - 3 + 1 = 0$\n    \\item $p^{2}$: $-3 + 6 - 3 = 0$\n    \\item $p$: $-3 + 3 = 0$\n    \\item 常数项: $1 - 1 = 0$\n\\end{itemize}\n对于任何 $p$，该和都恒为零。或者，可以将该表达式（去掉首项的 $1$）看作一个二项式展开。设 $A=p$ 和 $B=p+1$。该和可以写成：\n$$\n1 - B^{3} + 3(B-1)B^{2} - 3(B-1)^{2}B + (B-1)^{3} = 1 + \\left( -B^{3} + 3B^{2}(B-1) - 3B(B-1)^{2} + (B-1)^{3} \\right).\n$$\n这是 $1 + ((B-1) - B)^{3} = 1 + (-1)^{3} = 1 - 1 = 0$。\n维数计算与序列的正合性一致，从而验证了我们为 $\\mathcal{N}_{p}(K)$ 推导出的维数。最终答案即为该维数的闭式表达式。", "answer": "$$\n\\boxed{3p(p+1)^{2}}\n$$", "id": "3350019"}, {"introduction": "在理解了谱元法的理论基础之后，我们转向如何高效地实现它。高阶方法的朴素实现可能会导致计算成本过高，从而不切实际。本练习将介绍“和因子分解”（sum-factorization）这一关键技术，它是谱元法中高效算子求值的基石[@problem_id:3349976]。通过分析其计算复杂度，你将明白这种无矩阵方法如何将算子应用的成本从 $O(p^6)$ 显著降低到 $O(p^4)$，从而使大规模、高精度的模拟成为可能。", "problem": "考虑一个均匀、各向同性的介质，其介电常数和磁导率均为常数。在此介质中，频域 Maxwell 方程组中电场 $\\mathbf{E}$ 满足矢量 Helmholtz 形式 $\\nabla \\times \\nabla \\times \\mathbf{E} - k^{2} \\mathbf{E} = \\mathbf{J}$。我们关注在谱元法 (SEM) 中，在单个仿射六面体单元上，旋度-旋度算子 $\\nabla \\times \\nabla \\times \\mathbf{E}$ 的单元局部应用。在每个一维坐标上，使用 $p$ 次的张量积 Lagrange 基，并采用 Gauss–Lobatto–Legendre (GLL) 节点，因此每个坐标方向有 $N = p+1$ 个节点，每个单元有 $N^{3}$ 个节点。假设从参考单元到物理单元的映射是仿射的，具有恒定的几何因子和雅可比矩阵，因此度量项是常数，在计算主阶运算量时可以忽略。\n\n在带有 GLL 节点的参考区间上，定义一维节点基函数 $\\ell_{i}(\\xi)$，其中 $i = 0,\\dots,p$。令一维导数矩阵 $D$ 为一个稠密的 $(N \\times N)$ 矩阵，其元素为 $D_{\\alpha\\beta} = \\frac{\\mathrm{d}\\ell_{\\beta}}{\\mathrm{d}\\xi}$ 在节点 $\\xi_{\\alpha}$ 处的值。在参考单元 $[-1,1]^{3}$ 上的三维张量积基为 $\\ell_{i}(\\xi)\\,\\ell_{j}(\\eta)\\,\\ell_{k}(\\zeta)$。离散矢量场 $\\mathbf{E}$ 有三个分量，每个分量都在相同的张量积网格上表示。考虑一种无矩阵的单元局部算子应用，其中所有微分和缩并都通过求和分解法执行，即通过沿张量积网格中具有固定索引的线应用一维变换，而不是构造稠密的三维矩阵。\n\n从旋度-旋度算子的弱形式和张量积基的定义出发，推导一个求和分解方案，用于在 $N^{3}$ 个网格点上计算旋度 $\\nabla \\times \\mathbf{E}$，然后将弱形式的贡献累加回节点系数。在你的推导中，将一个一维 $(N \\times N)$ 导数矩阵应用于一条长度为 $N$ 的线上的每次操作，视为耗费 $N^{2}$ 次标量浮点乘加 (FMA) 运算。在首次出现时定义浮点乘加 (FMA)。只计算主阶运算项，忽略所有 $O(N^{3})$ 阶的成本，例如逐点线性组合、常数度量缩放和对角质量矩阵运算。\n\n然后，解析地比较一种朴素稠密方法的的主阶运算量（该方法将一个完全组装的大小为 $(3N^{3} \\times 3N^{3})$ 的单元局部矩阵应用于一个向量）与求和分解法的主阶运算量。最后，给出使用求和分解法应用旋度-旋度算子时，每个单元所需的主阶 FMA 运算次数的闭式表达式（用 $p$ 表示）。\n\n请将您的最终答案表示为关于 $p$ 的单个闭式表达式。不需要单位。不需要四舍五入。", "solution": "本问题要求在谱元法 (SEM) 框架内，分析应用单元局部旋度-旋度算子 $\\nabla \\times \\nabla \\times (\\cdot)$ 的计算成本。我们需要推导无矩阵求和分解法的运算量，并将其与朴素的稠密矩阵-向量乘积进行比较，最后以多项式次数 $p$ 的形式给出最终成本。\n\n首先，我们确定计算工作的单位。一次浮点乘加 (Floating-point Multiply-Add, FMA) 运算是一种计算 $d = a \\times b + c$ 的融合运算，计为一次操作。\n\n问题的核心在于评估来自单个六面体单元 $\\Omega_e$ 的弱形式贡献。对于一个矢量测试函数 $\\mathbf{v}$ 和电场 $\\mathbf{E}$，该贡献由以下积分给出：\n$$\n\\int_{\\Omega_e} (\\nabla \\times \\mathbf{v}) \\cdot (\\nabla \\times \\mathbf{E}) \\, dV\n$$\n为了分析计算成本，我们将此积分映射到参考单元 $\\hat{\\Omega} = [-1,1]^3$。设仿射映射为 $\\mathbf{x}(\\boldsymbol{\\xi}) = F \\boldsymbol{\\xi} + \\mathbf{c}$，其中 $\\mathbf{x} = (x,y,z)$ 是物理坐标，$\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$ 是参考坐标。该变换的雅可比矩阵 $J = \\frac{\\partial \\mathbf{x}}{\\partial \\boldsymbol{\\xi}}$ 是一个常数矩阵。微分体积元变换为 $dV = |J| d\\hat{V}$，其中 $|J|$ 是雅可比矩阵的常数行列式。\n\n旋度算子根据关系式 $\\nabla \\times = (J^{-T} \\nabla_{\\boldsymbol{\\xi}}) \\times$ 进行变换，其中 $\\nabla_{\\boldsymbol{\\xi}}$ 是参考坐标系中的 del 算子。由于 $J^{-T}$ 是一个常数矩阵，将此应用于矢量场 $\\mathbf{A}$，我们得到 $\\nabla \\times \\mathbf{A} = J^{-T} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{A})$。参考单元上的弱形式变为：\n$$\n\\int_{\\hat{\\Omega}} \\left( J^{-T} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{v}) \\right) \\cdot \\left( J^{-T} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E}) \\right) |J| \\, d\\hat{V}\n$$\n使用矩阵表示法表示点积，这可以重写为：\n$$\n|J| \\int_{\\hat{\\Omega}} (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{v})^T (J^{-1} J^{-T}) (\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E}) \\, d\\hat{V}\n$$\n矩阵 $G = J^{-1} J^{-T}$ 包含恒定的度量张量分量。使用 Gauss-Lobatto-Legendre (GLL) 求积法对该积分进行数值计算的过程是：在 $N^3$ 个 GLL 节点上计算被积函数的值，然后将结果与相应的求积权重相加。整个算子应用可以分解为一系列步骤。设 $\\mathbf{E}$ 的离散节点表示由系数向量 $\\underline{\\mathbf{E}}$ 表示。\n\n求和分解方案如下：\n1.  在所有 $N^3$ 个 GLL 节点上计算参考旋度 $\\mathbf{c}_E = \\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E}$。\n2.  逐点应用度量张量和求积权重：在每个节点 $(i,j,k)$ 处，计算 $\\tilde{\\mathbf{c}}_E = |J| w_{ijk} G (\\mathbf{c}_E)_{ijk}$。\n3.  将参考旋度算子的转置 $(\\nabla_{\\boldsymbol{\\xi}} \\times)^T$ 应用于加权值场 $\\tilde{\\mathbf{c}}_E$，以累加得到最终的节点系数 $\\underline{\\mathbf{F}}$。\n\n问题说明我们只应计算主阶项，并忽略 $O(N^3)$ 阶的成本，如逐点线性组合和缩放。步骤 2 仅涉及在 $N^3$ 个节点上的逐点操作，因此其成本为 $O(N^3)$，我们将其忽略。主要成本在于步骤 1 和 3。\n\n**步骤 1：计算参考旋度 $(\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E})$ 的成本**\n\n参考旋度由下式给出：\n$$\n\\nabla_{\\boldsymbol{\\xi}} \\times \\mathbf{E} = \\left(\\frac{\\partial E_z}{\\partial \\eta} - \\frac{\\partial E_y}{\\partial \\zeta}\\right)\\hat{\\xi} + \\left(\\frac{\\partial E_x}{\\partial \\zeta} - \\frac{\\partial E_z}{\\partial \\xi}\\right)\\hat{\\eta} + \\left(\\frac{\\partial E_y}{\\partial \\xi} - \\frac{\\partial E_x}{\\partial \\eta}\\right)\\hat{\\zeta}\n$$\n为了在 $N^3$ 个节点上计算该值，我们需要计算六个偏导数的节点值：$\\frac{\\partial E_y}{\\partial \\xi}$、$\\frac{\\partial E_z}{\\partial \\xi}$、$\\frac{\\partial E_x}{\\partial \\eta}$、$\\frac{\\partial E_z}{\\partial \\eta}$、$\\frac{\\partial E_x}{\\partial \\zeta}$ 和 $\\frac{\\partial E_y}{\\partial \\zeta}$。\n\n让我们分析计算其中一个（例如 $\\frac{\\partial E_x}{\\partial \\eta}$）的成本。场分量 $E_x$ 在一个 $N \\times N \\times N$ 的张量积网格节点值上表示。使用求和分解法，关于 $\\eta$ 的导数是通过将一维 $(N \\times N)$ 导数矩阵 $D$ 应用于沿 $\\eta$ 方向的 $N^2$ 条线上的数据来计算的。\n- 这样的线的数量为 $N^2$（每个 $(\\xi_i, \\zeta_k)$ 索引对一条）。\n- 将稠密的 $N \\times N$ 矩阵 $D$ 应用于长度为 $N$ 的向量的成本是 $N^2$ 次 FMA 运算。\n- 因此，在整个 3D 网格上计算一个标量场（如 $E_x$）关于一个方向（如 $\\eta$）的导数的总成本为 $N^2 \\text{ 条线} \\times N^2 \\text{ FMA/线} = N^4$ 次 FMA。\n\n由于我们需要计算 $6$ 个这样的偏导数，步骤 1 的总成本为：\n$$\n\\text{Cost}_{\\text{Step 1}} = 6 \\times N^4 \\text{ FMA}\n$$\n之后用于形成 $\\mathbf{c}_E$ 分量的逐点减法是 $O(N^3)$ 阶的运算，根据题目要求可以忽略。\n\n**步骤 3：应用转置参考旋度 $(\\nabla_{\\boldsymbol{\\xi}} \\times)^T$ 的成本**\n\n此步骤涉及应用步骤 1 中算子的离散转置。该操作包括应用偏导数算子的转置。例如，对 $E_x$ 最终节点系数的贡献来自 $\\tilde{\\mathbf{c}}_E$ 中在步骤 1 涉及 $E_x$ 导数的那些分量。此过程需要沿相应的网格线应用一维导数矩阵的转置 $D^T$。将一个 $N \\times N$ 矩阵 $D^T$ 应用于一个长度为 $N$ 的向量的成本也是 $N^2$ 次 FMA。就导数应用的数量而言，算子 $(\\nabla_{\\boldsymbol{\\xi}} \\times)^T$ 的结构与 $\\nabla_{\\boldsymbol{\\xi}} \\times$ 相同。它也需要计算 6 个类偏导数运算。\n因此，步骤 3 的成本也是：\n$$\n\\text{Cost}_{\\text{Step 3}} = 6 \\times N^4 \\text{ FMA}\n$$\n\n**求和分解法总成本**\n\n求和分解旋度-旋度算子应用的主阶总成本是步骤 1 和步骤 3 成本的总和：\n$$\n\\text{Cost}_{\\text{SF}} = 6 N^4 + 6 N^4 = 12 N^4 \\text{ FMA}\n$$\n\n**与朴素稠密方法的比较**\n\n在朴素方法中，我们会显式地构造单元局部刚度矩阵 $K_e^{curlcurl}$。\n- 单元上矢量场 $\\mathbf{E}$ 的自由度 (DoF) 数量为 每个节点 $3$ 个分量 $\\times$ $N^3$ 个节点 = $3N^3$。\n- 稠密刚度矩阵 $K_e^{curlcurl}$ 的维度将是 $(3N^3) \\times (3N^3)$。\n- 应用此算子对应于一次矩阵-向量乘积。将一个 $(3N^3 \\times 3N^3)$ 的稠密矩阵与一个长度为 $3N^3$ 的向量相乘的成本约为 $(3N^3)^2$ 次 FMA 运算。\n$$\n\\text{Cost}_{\\text{Dense}} = (3N^3)^2 = 9 N^6 \\text{ FMA}\n$$\n求和分解法的成本为 $12N^4$，而稠密方法的成本为 $9N^6$。成本之比为 $\\text{Cost}_{\\text{Dense}} / \\text{Cost}_{\\text{SF}} = \\frac{9N^6}{12N^4} = \\frac{3}{4}N^2$。对于任何 $p \\ge 1$（即 $N \\ge 2$），求和分解法都高效得多，其优势随每个维度上的节点数 $N$ 呈二次方增长。\n\n**求和分解法成本的最终表达式**\n\n问题要求以多项式次数 $p$ 表示的主阶 FMA 运算次数的闭式表达式。由于 $N = p+1$，总成本为：\n$$\n\\text{Cost}_{\\text{SF}} = 12 N^4 = 12 (p+1)^4\n$$", "answer": "$$\\boxed{12(p+1)^4}$$", "id": "3349976"}, {"introduction": "最后，我们将理论与效率付诸实践，完成一个编程练习。本练习要求你实现一个一维谱元法求解器，用以解决电磁学中的两个典型问题：特征值问题和散射问题[@problem_id:3350051]。通过这个过程，你将研究不精确数值积分（即“变分犯罪”）等实际操作对计算结果的具体影响，从而能够通过数值实验直观地观察到计算效率与求解精度之间的权衡。", "problem": "考虑在单位区间 $[0,1]$ 上的无损、非磁性介质中，线性偏振场的麦克斯韦方程组的一维时谐简化形式。在变量分离并假设介电常数分段光滑的条件下，电场分量 $u(x)$ 满足标量亥姆霍兹型模型。我们关注两种情况：\n\n1. 本征频率问题（具有理想导电边界的闭合腔体）：求角频率 $\\omega$ 和非平凡解 $u(x)$，使得\n$$\n-\\frac{d^2 u}{dx^2} = \\omega^2 \\mu_0 \\epsilon_0 \\epsilon_r(x) u \\quad \\text{在 } (0,1) \\text{ 内}, \\quad u(0)=0, \\; u(1)=0,\n$$\n其中 $\\epsilon_r(x)$ 是相对介电常数，$\\epsilon_0$ 是真空介电常数，$\\mu_0$ 是真空磁导率。使用无量纲单位，使得 $\\mu_0 \\epsilon_0 = 1$，这意味着当 $\\epsilon_r(x) \\equiv 1$ 为常数时，连续精确的基频本征频率为 $\\omega_1 = \\pi$。\n\n2. 在 $(0,1)$ 上的驱动散射问题：对于给定的实波数 $k > 0$ 和常数 $\\epsilon_r(x) \\equiv 1$，求满足以下条件的 $u(x)$\n$$\n-\\frac{d^2 u}{dx^2} - k^2 u = 0 \\quad \\text{在 } (0,1) \\text{ 内},\n$$\n在 $x=1$ 处采用一阶吸收边界条件，并在 $x=0$ 处施加单位振幅的入射平面波。一致地，使用 Robin 型条件\n$$\n\\frac{du}{dx}(1) - i k u(1) = 0, \\quad \\frac{du}{dx}(0) + i k u(0) = 2 i k,\n$$\n从而使得在 $x=0$ 处的精确连续反射振幅为零。反射系数的离散估计取为\n$$\nR = \\frac{i k u(0) - u'(0)}{i k u(0) + u'(0)},\n$$\n我们测量 $|R|$。\n\n使用高阶谱元法 (SEM) 对这两个问题进行离散化，该方法在 $[0,1]$ 上的 $N_e$ 个均匀单元组成的网格上进行，基函数为在参考区间 $[-1,1]$ 上的 Gauss-Lobatto-Legendre (GLL) 节点 $\\{\\xi_j\\}_{j=0}^{p}$ 上构建的 $p$ 次拉格朗日多项式基函数 $\\{\\ell_j(\\xi)\\}_{j=0}^{p}$。设单元仿射映射为 $x(\\xi) = x_e^L + \\frac{h_e}{2}(\\xi+1)$，其雅可比行列式为 $J_e = \\frac{h_e}{2}$。标准的 $H^1$ 协调谱元法导出单元刚度矩阵和质量矩阵\n$$\nK_e = \\frac{1}{J_e} \\int_{-1}^{1} \\ell_i'(\\xi) \\ell_j'(\\xi) \\, d\\xi, \\quad\nM_e = J_e \\int_{-1}^{1} \\epsilon_r(x(\\xi)) \\ell_i(\\xi) \\ell_j(\\xi) \\, d\\xi,\n$$\n并以常规方式进行全局组装。刚度积分是一个次数至多为 $2p-2$ 的多项式，可以通过 $p+1$ 阶 GLL 求积精确积分。而质量积分涉及两个 $p$ 次多项式与一个可能非多项式的系数的乘积，是“变分犯罪”的来源。\n\n通过对比两种质量矩阵组装策略，研究质量矩阵中非精确求积对离散本征频率和散射振幅的影响：\n\n- 非精确 GLL 质量矩阵（变分犯罪）：使用插值节点 $\\{\\xi_j\\}$ 处的 GLL 求积和权重 $\\{w_j^{\\mathrm{GLL}}\\}$ 来近似 $M_e$：\n$$\nM_e^{\\mathrm{GLL}} \\approx J_e \\sum_{q=0}^{p} w_q^{\\mathrm{GLL}} \\epsilon_r(x(\\xi_q)) \\ell_i(\\xi_q) \\ell_j(\\xi_q),\n$$\n对于常数 $\\epsilon_r$，这会简化为一个对角单元质量矩阵，但对于 $2p$ 次多项式而言是不精确的。\n\n- 过积分质量矩阵：使用具有 $q = p+1$ 个点 $\\{\\hat{\\xi}_m, \\hat{w}_m\\}_{m=1}^{q}$ 的 Gauss-Legendre (GL) 求积来近似 $M_e$，\n$$\nM_e^{\\mathrm{OI}} \\approx J_e \\sum_{m=1}^{q} \\hat{w}_m \\epsilon_r(x(\\hat{\\xi}_m)) \\ell_i(\\hat{\\xi}_m) \\ell_j(\\hat{\\xi}_m),\n$$\n对于常数 $\\epsilon_r$（次数最高为 $2p$），这种方法可以精确积分质量双线性形式，并减少可变 $\\epsilon_r(x)$ 引起的混叠效应。\n\n在所有情况下，对刚度矩阵使用精确的 GLL 求积：\n$$\nK_e = \\frac{1}{J_e} \\sum_{q=0}^{p} w_q^{\\mathrm{GLL}} \\ell_i'(\\xi_q) \\ell_j'(\\xi_q).\n$$\n\n从第一性原理出发，推导散射问题的弱形式、组装公式和边界贡献，然后实现一个程序，该程序能够：\n\n- 为两种求积策略组装全局矩阵。\n- 求解带有本质边界条件的广义本征问题 $K u = \\omega^2 M u$，以得到第一个本征对。\n- 求解带有上述 Robin 边界条件的驱动散射问题的线性系统，并计算离散反射振幅。\n\n提供一套参数集作为测试套件，用以检验不同方面和边界情况。使用无量纲单位并报告无量纲结果。具体来说，计算并输出以下五个标量，作为单一的最终结果：\n\n1. 对于 $[0,1]$ 上的常数 $\\epsilon_r(x) \\equiv 1$，$N_e = 2$ 个单元且次数 $p=3$，使用非精确 GLL 质量矩阵计算最小本征频率的相对误差 $\\left|\\omega_{1}^{\\mathrm{GLL}} - \\pi\\right|/\\pi$。\n\n2. 对于与第 1 项相同的设置，使用具有 $q=p+1$ 个 Gauss-Legendre 点的过积分质量矩阵，计算相对误差 $\\left|\\omega_{1}^{\\mathrm{OI}} - \\pi\\right|/\\pi$。\n\n3. 对于可变介电常数 $\\epsilon_r(x) = 1 + 0.3 \\cos(10 \\pi x)$，$N_e = 8$ 且 $p=5$，计算使用非精确质量矩阵和过积分质量矩阵得到的第一个本征频率之间的相对差异：$\\left|\\omega_{1}^{\\mathrm{GLL}} - \\omega_{1}^{\\mathrm{OI}}\\right| / \\left|\\omega_{1}^{\\mathrm{OI}}\\right|$。\n\n4. 对于散射问题，其中常数 $\\epsilon_r \\equiv 1$，$N_e = 16$，$p=5$，波数 $k = 12 \\pi$，使用非精确质量矩阵计算反射系数的模 $\\left|R^{\\mathrm{GLL}}\\right|$。\n\n5. 对于与第 4 项相同的散射设置，使用过积分质量矩阵计算 $\\left|R^{\\mathrm{OI}}\\right|$。\n\n角度量以弧度为单位。所有五个输出都是无量纲实数。您的程序应生成单行输出，其中包含按上述顺序排列、用逗号分隔并用方括号括起来的结果（例如，“[r1,r2,r3,r4,r5]”）。无需输入；所有参数均按测试套件中给定的值固定。", "solution": "本问题的求解分为三个主要步骤：首先，推导本征问题和散射问题的弱形式；其次，详细说明谱元法 (SEM) 的离散化过程，包括两种质量矩阵的组装策略；最后，实现一个 Python 程序来执行计算并生成所需结果。\n\n#### 1. 弱形式推导\n\n**本征问题**:\n控制方程为 $-\\frac{d^2 u}{dx^2} = \\omega^2 \\epsilon_r(x) u$，边界条件为 $u(0)=u(1)=0$。我们将方程乘以一个测试函数 $v \\in H_0^1(0,1)$（即在边界上为零的 $H^1$ 函数），并在区间 $[0,1]$ 上积分。通过分部积分，可得：\n$$\n\\int_0^1 u'(x) v'(x) dx - [u'(x)v(x)]_0^1 = \\omega^2 \\int_0^1 \\epsilon_r(x) u(x) v(x) dx\n$$\n由于 $v(0)=v(1)=0$，边界项为零。这导出了弱形式：求 $(\\omega^2, u) \\in (\\mathbb{R}, H_0^1(0,1))$ 使得\n$$\n\\int_0^1 u' v' dx = \\omega^2 \\int_0^1 \\epsilon_r(x) u v dx, \\quad \\forall v \\in H_0^1(0,1)\n$$\n这对应于一个广义本征值问题 $K \\mathbf{u} = \\omega^2 M \\mathbf{u}$。\n\n**散射问题**:\n控制方程为 $-\\frac{d^2 u}{dx^2} - k^2 u = 0$。我们将方程乘以测试函数 $v \\in H^1(0,1)$ 的复共轭 $\\bar{v}$，并在 $[0,1]$ 上积分：\n$$\n\\int_0^1 u' \\bar{v}' dx - [u'\\bar{v}]_0^1 - k^2 \\int_0^1 u \\bar{v} dx = 0\n$$\n代入 Robin 边界条件 $u'(1) = i k u(1)$ 和 $u'(0) = -i k u(0) + 2ik$，边界项变为：\n$$\n[u'\\bar{v}]_0^1 = u'(1)\\bar{v}(1) - u'(0)\\bar{v}(0) = (ik u(1))\\bar{v}(1) - (-ik u(0) + 2ik)\\bar{v}(0)\n$$\n代入弱形式，得到：求 $u \\in H^1(0,1)$ 使得\n$$\n\\int_0^1 u' \\bar{v}' dx - k^2 \\int_0^1 u \\bar{v} dx - ik u(1)\\bar{v}(1) - ik u(0)\\bar{v}(0) = -2ik\\bar{v}(0), \\quad \\forall v \\in H^1(0,1)\n$$\n这对应于一个复数线性系统 $A \\mathbf{u} = \\mathbf{b}$。\n\n#### 2. 谱元离散化\n\n我们使用 $N_e$ 个单元和 $p$ 次拉格朗日多项式。总自由度为 $N_e p + 1$。\n\n**单元矩阵**: 对于每个单元，我们计算刚度矩阵 $K_e$ 和质量矩阵 $M_e$。\n- **刚度矩阵 $K_e$**:\n  $$\n  (K_e)_{ij} = \\frac{1}{J_e} \\int_{-1}^{1} \\ell_i'(\\xi) \\ell_j'(\\xi) d\\xi\n  $$\n  被积函数是 $2p-2$ 次多项式，使用 $p+1$ 个点的 GLL 求积可以精确计算。\n- **质量矩阵 $M_e$**:\n  $$\n  (M_e)_{ij} = J_e \\int_{-1}^{1} \\epsilon_r(x(\\xi)) \\ell_i(\\xi) \\ell_j(\\xi) d\\xi\n  $$\n  我们实现两种策略：\n  1.  **非精确 GLL 质量矩阵 ($M_e^{\\mathrm{GLL}}$)**: 使用 GLL 求积。当 $\\epsilon_r$ 为常数时，这等效于质量集中，得到对角矩阵。\n      $$\n      (M_e^{\\mathrm{GLL}})_{ij} \\approx J_e \\sum_{q=0}^{p} w_q^{\\mathrm{GLL}} \\epsilon_r(x(\\xi_q)) \\delta_{iq} \\delta_{jq} = J_e w_i^{\\mathrm{GLL}} \\epsilon_r(x(\\xi_i)) \\delta_{ij}\n      $$\n  2.  **过积分质量矩阵 ($M_e^{\\mathrm{OI}}$)**: 使用 $q=p+1$ 个点的 Gauss-Legendre (GL) 求积。被积函数 $\\ell_i \\ell_j$ 是 $2p$ 次多项式，GL 求积能精确到 $2q-1=2p+1$ 次，因此对于常数 $\\epsilon_r$，积分是精确的。\n\n**组装**: 将所有单元矩阵相加，得到全局矩阵 $K$ 和 $M$。对于散射问题，根据弱形式在全局矩阵 $A = K - k^2 M$ 的对角线首尾项上减去 $ik$，并构造右端项向量 $\\mathbf{b}$。\n\n#### 3. 实现与求解\n\n以下 Python 代码实现了上述逻辑。它使用 `numpy` 和 `scipy` 来处理节点计算、矩阵运算和求解。程序会依次执行五个测试用例并输出结果。\n```python\nimport numpy as np\nimport scipy.special\nimport scipy.linalg\nfrom numpy.polynomial.legendre import leggauss\n\nclass _SpectralBasis:\n    \"\"\"\n    A helper class to manage properties of 1D Lagrange polynomial basis \n    functions defined on Gauss-Lobatto-Legendre (GLL) nodes.\n    \"\"\"\n    def __init__(self, p):\n        self.p = p\n        \n        if p == 0:\n            self.nodes = np.array([-1.0])\n            self.weights = np.array([2.0])\n        else:\n            # GLL nodes are the endpoints [-1, 1] and the roots of the \n            # derivative of the degree-p Legendre polynomial, L_p'.\n            coeffs = scipy.special.legendre(p)\n            deriv_coeffs = coeffs.deriv()\n            interior_nodes = np.roots(deriv_coeffs)\n            self.nodes = np.unique(np.sort(np.concatenate(([-1.0], interior_nodes, [1.0]))))\n            \n            # GLL weights are calculated from the values of L_p at the nodes.\n            lp_vals = scipy.special.eval_legendre(p, self.nodes)\n            self.weights = 2.0 / (p * (p + 1) * lp_vals**2)\n\n        # The differentiation matrix D_ij = l_j'(xi_i) is pre-computed.\n        self.diff_matrix = self._compute_diff_matrix()\n        \n    def _compute_diff_matrix(self):\n        p, nodes = self.p, self.nodes\n        D = np.zeros((p + 1, p + 1))\n        lp_vals = scipy.special.eval_legendre(p, nodes)\n        \n        for i in range(p + 1):\n            for j in range(p + 1):\n                if i != j:\n                    D[i, j] = lp_vals[i] / (lp_vals[j] * (nodes[i] - nodes[j]))\n        \n        if p > 0:\n            D[0, 0] = -p * (p + 1) / 4.0\n            D[p, p] = p * (p + 1) / 4.0\n        return D\n\n    def lagrange_basis_at_points(self, eval_points):\n        \"\"\"Evaluates all p+1 Lagrange basis functions at a set of points.\"\"\"\n        p, nodes = self.p, self.nodes\n        L = np.ones((len(eval_points), p + 1))\n        for j in range(p + 1):\n            for i in range(len(eval_points)):\n                val = 1.0\n                for m in range(p + 1):\n                    if m != j:\n                        val *= (eval_points[i] - nodes[m]) / (nodes[j] - nodes[m])\n                L[i, j] = val\n        return L\n\ndef _run_calculation(params):\n    \"\"\"\n    Performs a single SEM calculation for a given set of parameters.\n    This function handles both eigenproblems and scattering problems.\n    \"\"\"\n    Ne, p, eps_r_func, mass_type, k = params\n    \n    basis = _SpectralBasis(p)\n    dof = Ne * p + 1\n    h = 1.0 / Ne\n    \n    K_global = np.zeros((dof, dof))\n    M_global = np.zeros((dof, dof))\n\n    # Reference element stiffness matrix (integrated exactly with GLL quadrature)\n    K_ref = basis.diff_matrix.T @ np.diag(basis.weights) @ basis.diff_matrix\n\n    # Assembly loop over elements\n    for e in range(Ne):\n        J = h / 2.0  # Jacobian of the affine map\n        x_left = e * h\n        \n        # Scale reference stiffness matrix\n        K_elem = (1.0 / J) * K_ref\n        \n        # Compute element mass matrix based on the specified strategy\n        if mass_type == 'GLL':\n            elem_nodes_x = x_left + J * (basis.nodes + 1)\n            eps_vals = eps_r_func(elem_nodes_x)\n            M_elem = J * np.diag(basis.weights * eps_vals)\n        elif mass_type == 'OI':\n            q = p + 1 # Number of quadrature points for over-integration\n            gl_nodes, gl_weights = leggauss(q)\n            \n            L_at_gl = basis.lagrange_basis_at_points(gl_nodes)\n            gl_nodes_x = x_left + J * (gl_nodes + 1)\n            eps_vals_at_gl = eps_r_func(gl_nodes_x)\n            \n            W_eps = np.diag(gl_weights * eps_vals_at_gl)\n            M_elem_ref = L_at_gl.T @ W_eps @ L_at_gl\n            M_elem = J * M_elem_ref\n        \n        # Add element contributions to global matrices\n        for i in range(p + 1):\n            for j in range(p + 1):\n                g_i, g_j = e * p + i, e * p + j\n                K_global[g_i, g_j] += K_elem[i, j]\n                M_global[g_i, g_j] += M_elem[i, j]\n    \n    # EIGENPROBLEM SOLVER\n    if k is None:\n        # Enforce u(0)=u(1)=0 by using only interior degrees of freedom\n        interior_dofs = slice(1, dof - 1)\n        K_int = K_global[interior_dofs, interior_dofs]\n        M_int = M_global[interior_dofs, interior_dofs]\n        \n        # Solve the generalized eigenvalue problem K*u = lambda*M*u\n        eigenvalues, _ = scipy.linalg.eigh(K_int, M_int)\n        omega_sq = eigenvalues[0] # Smallest eigenvalue\n        return np.sqrt(omega_sq)\n        \n    # SCATTERING PROBLEM SOLVER\n    else:\n        # Form complex system matrix A = K - k^2*M - C_boundary\n        A = (K_global - k**2 * M_global).astype(np.complex128)\n        A[0, 0] -= 1j * k\n        A[dof-1, dof-1] -= 1j * k\n        \n        # Form right-hand side vector from boundary condition\n        b = np.zeros(dof, dtype=np.complex128)\n        b[0] = -2j * k\n        \n        # Solve the linear system\n        u_sol = np.linalg.solve(A, b)\n        \n        # Calculate reflection coefficient R from the numerical solution\n        u0 = u_sol[0]\n        J0 = h / 2.0\n        D_first_row = basis.diff_matrix[0, :]\n        u_prime_0 = (1.0 / J0) * np.dot(u_sol[:p + 1], D_first_row)\n        \n        numerator = 1j * k * u0 - u_prime_0\n        denominator = 1j * k * u0 + u_prime_0\n        \n        R = numerator / denominator if np.abs(denominator) > 1e-15 else 0.\n        return np.abs(R)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the permittivity functions for the test cases\n    eps_r_const = lambda x: np.ones_like(x, dtype=float)\n    eps_r_variable = lambda x: 1.0 + 0.3 * np.cos(10 * np.pi * x)\n\n    # Define the parameter sets for the five required calculations\n    # Format: (Ne, p, eps_r_func, mass_type, k)\n    # k=None indicates an eigenproblem.\n    test_cases = [\n        # 1. Eigenproblem, GLL mass, constant eps_r\n        (2, 3, eps_r_const, 'GLL', None),\n        # 2. Eigenproblem, OI mass, constant eps_r\n        (2, 3, eps_r_const, 'OI', None),\n        # 3. Eigenproblem, variable eps_r, comparison\n        {'Ne': 8, 'p': 5, 'eps_r': eps_r_variable},\n        # 4. Scattering, GLL mass\n        (16, 5, eps_r_const, 'GLL', 12 * np.pi),\n        # 5. Scattering, OI mass\n        (16, 5, eps_r_const, 'OI', 12 * np.pi),\n    ]\n\n    results = []\n\n    # Case 1\n    omega1_gll = _run_calculation(test_cases[0])\n    results.append(np.abs(omega1_gll - np.pi) / np.pi)\n\n    # Case 2\n    omega1_oi = _run_calculation(test_cases[1])\n    results.append(np.abs(omega1_oi - np.pi) / np.pi)\n\n    # Case 3\n    params_gll = (test_cases[2]['Ne'], test_cases[2]['p'], test_cases[2]['eps_r'], 'GLL', None)\n    params_oi = (test_cases[2]['Ne'], test_cases[2]['p'], test_cases[2]['eps_r'], 'OI', None)\n    omega1_var_gll = _run_calculation(params_gll)\n    omega1_var_oi = _run_calculation(params_oi)\n    results.append(np.abs(omega1_var_gll - omega1_var_oi) / np.abs(omega1_var_oi))\n    \n    # Case 4\n    results.append(_run_calculation(test_cases[3]))\n\n    # Case 5\n    results.append(_run_calculation(test_cases[4]))\n    \n    return f\"[{','.join(map(str, results))}]\"\n\n# The final answer is generated by calling solve()\n# print(solve())\n```", "answer": "[0.0007328905325244588,5.438515549887719e-05,0.0003058863489812423,0.0011508207914751433,3.905999335445722e-13]", "id": "3350051"}]}