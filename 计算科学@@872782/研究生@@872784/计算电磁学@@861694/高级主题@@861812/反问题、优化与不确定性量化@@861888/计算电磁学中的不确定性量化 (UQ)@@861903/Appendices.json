{"hands_on_practices": [{"introduction": "相控阵在现代通信、雷达和遥感系统中无处不在。然而，它们的性能，特别是波束方向图的旁瓣电平，对制造公差和电子元件（如移相器）的变化非常敏感。这项动手实践旨在通过蒙特卡洛模拟，对这些不确定性进行量化。通过模拟大量随机相位误差的场景，您将学习如何估计关键性能指标，例如旁瓣电平超过临界阈值的概率，这对于评估系统在实际操作中的可靠性至关重要 [@problem_id:3358419]。", "problem": "考虑一个在远场中根据 Huygens–Fresnel 原理和 Maxwell 方程组的线性特性建模的均匀线性天线阵列，其中由多个辐射源叠加产生的电场是各个场贡献的总和。假设有 $N$ 个各向同性单元沿 $x$ 轴排列，均匀间距为 $d$。对于波长为 $\\lambda$、波数为 $k = 2\\pi/\\lambda$ 的单色源，通过施加能够补偿几何路径差的波束控制相位，可以获得指向所需波束指向角 $\\theta_0$ 的理想确定性阵列因子，从而在各单元之间产生一个依赖于 $\\sin\\theta$ 的远场相位级数。\n\n现在，在每个单元上引入源相位不确定性。将相位扰动建模为一个随机向量 $\\boldsymbol{\\delta\\phi}(\\xi) = [\\delta\\phi_0(\\xi), \\delta\\phi_1(\\xi), \\dots, \\delta\\phi_{N-1}(\\xi)]^\\top$，该向量服从零均值的联合高斯分布，其协方差矩阵 $\\boldsymbol{\\Sigma}$ 的元素为\n$$\n\\Sigma_{mn} = \\sigma^2 \\exp\\!\\left(-\\frac{|m-n|}{L_c}\\right), \\quad m,n \\in \\{0,1,\\dots,N-1\\},\n$$\n其中 $\\sigma$ 为指定的标准差（单位为弧度），$L_c  0$ 为无量纲相关长度。对于 $L_c = 0$ 的特殊情况，假设各元素独立，因此 $\\boldsymbol{\\Sigma} = \\sigma^2 \\mathbf{I}$。波束控制律使用相移 $w_n = -k d n \\sin\\theta_0$，使得标称波束指向 $\\theta_0$。在观测角 $\\theta$ 和随机结果 $\\xi$ 下，不确定波束方向图幅度（阵列因子幅度）定义为\n$$\nB(\\theta,\\xi) = \\frac{1}{N}\\left|\\sum_{n=0}^{N-1} \\exp\\!\\Big(j\\big(k d n (\\sin\\theta - \\sin\\theta_0) + \\delta\\phi_n(\\xi)\\big)\\Big)\\right|.\n$$\n将 $B(\\theta,\\xi)$ 视为由随机相位引起的、关于角度的随机场。对于给定的实现，将主瓣峰值幅度定义为在一个角度网格 $\\Theta$ 上的 $B_{\\max}(\\xi) = \\max_{\\theta \\in \\Theta} B(\\theta,\\xi)$，并将旁瓣区域定义为满足 $|\\theta - \\theta_0| \\ge \\Delta\\theta_{\\text{main}}$ 的角度集合，其中 $\\Delta\\theta_{\\text{main}}$ 是以度为单位指定的主瓣排除半宽度。设最大旁瓣电平为\n$$\n\\text{SLL}(\\xi) = \\max_{\\,\\theta \\in \\Theta:\\,|\\theta - \\theta_0| \\ge \\Delta\\theta_{\\text{main}}}\\, \\left(20\\log_{10}\\frac{B(\\theta,\\xi)}{B_{\\max}(\\xi)}\\right),\n$$\n单位为分贝，相对于同一次实现的主瓣峰值。给定一个以分贝为单位的阈值 $T_{\\text{dB}}$，超限事件为 $\\{\\text{SLL}(\\xi)  T_{\\text{dB}}\\}$，超限概率是在 $\\boldsymbol{\\delta\\phi}(\\xi)$ 的联合高斯模型下该事件发生的概率。\n\n从所述的基本电磁叠加原理和不确定波束方向图的定义出发，设计一个算法，通过从具有指定协方差的多元正态分布中进行蒙特卡洛采样来估计超限概率。实现该算法以完成以下任务：\n- 构建阵列波束控制相位律和确定性几何相位模板，\n- 对相关的相位扰动进行采样，\n- 在有限角度网格上计算 $B(\\theta,\\xi)$，\n- 对每次实现，使用指定的旁瓣区域确定 $B_{\\max}(\\xi)$ 和 $\\text{SLL}(\\xi)$，\n- 将 $\\text{SLL}(\\xi)  T_{\\text{dB}}$ 的实现所占的比例作为超限概率的估计值。\n\n在算法中一致地使用以下物理和数值规格：\n- 波长 $\\lambda = 1$ 米（因此 $k = 2\\pi$ 弧度/米），\n- 单元间距 $d = \\lambda/2$ 米，\n- 角度网格 $\\Theta$ 范围从 $-90$ 度到 $+90$ 度（含边界），步长为 $0.2$ 度，\n- 角度在输入时必须以度为单位处理和指定，并在内部转换为弧度以进行三角函数计算。\n\n你的程序必须为以下参数集测试套件实现估计，并产生超限概率。每个参数元组为 $(N, \\sigma, L_c, \\theta_0, T_{\\text{dB}}, \\Delta\\theta_{\\text{main}}, M)$，其中 $M$ 是蒙特卡洛样本的数量：\n\n- 测试 1：$(16, 0.1, 2.0, 0.0, -18.0, 6.0, 2000)$，\n- 测试 2：$(16, 0.2, 0.0, 30.0, -15.0, 8.0, 2000)$，\n- 测试 3：$(32, 0.05, 8.0, -10.0, -22.0, 3.0, 1500)$，\n- 边界测试 4：$(16, 0.0, 1.0, 0.0, -18.0, 6.0, 500)$。\n\n在所有测试中，按规定以度表示角度。超限概率必须表示为 $[0,1]$ 范围内的十进制数。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[p_1,p_2,p_3,p_4]$），$p_i$ 是上述顺序中测试 $i$ 的超限概率。使用固定的随机种子以使蒙特卡洛结果在不同运行中可复现。不允许用户输入；所有数值均按给定值固定。", "solution": "推导始于远场中的电磁叠加。在 Maxwell 方程组下，于时谐场中，观测点处的总场是每个源单元贡献的总和。在 Fraunhofer（远场）近似中，沿一条直线均匀间隔分布的单元 $n$ 所产生场的相位由其相对于一个参考点的路径差决定。对于一个沿 $x$ 轴分布、由 $d$ 间隔的 $N$ 个各向同性单元组成的均匀线性阵列，在仰角 $\\theta$ 处观测时，由几何结构附加的相位是 $k d n \\sin\\theta$，其中 $k = 2\\pi/\\lambda$ 是波数，$n \\in \\{0,\\dots,N-1\\}$ 是相对于参考点的单元位置索引。\n\n通过施加确定性相移 $w_n = -k d n \\sin\\theta_0$ 来实现对所需角度 $\\theta_0$ 的波束控制。这补偿了在 $\\theta_0$ 处的几何相位，使各贡献同相，从而产生一个以 $\\theta_0$ 为中心的主瓣。使用此控制律，单元 $n$ 在角度 $\\theta$ 处的净确定性相位贡献变为 $k d n (\\sin\\theta - \\sin\\theta_0)$。\n\n在每个单元上引入随机相位扰动，由 $\\delta\\phi_n(\\xi)$ 建模，其中 $\\xi$ 表示一个随机结果。向量 $\\boldsymbol{\\delta\\phi}(\\xi) = [\\delta\\phi_0(\\xi), \\dots, \\delta\\phi_{N-1}(\\xi)]^\\top$ 被建模为零均值多元高斯分布，其协方差元素为\n$$\n\\Sigma_{mn} = \\sigma^2 \\exp\\!\\left(-\\frac{|m-n|}{L_c}\\right),\n$$\n其中 $L_c  0$ 定义了以单元数为单位的相关长度。对于 $L_c = 0$，模型简化为具有协方差 $\\sigma^2 \\mathbf{I}$ 的独立相位扰动。对于 $L_c \\ge 0$，该协方差是半正定的，并产生物理上合理的关联：间距近的单元比间距远的单元具有更高的相关性。\n\n阵列因子（贡献的复数和）可以写为\n$$\nA(\\theta,\\xi) = \\sum_{n=0}^{N-1} \\exp\\!\\Big(j\\big(k d n (\\sin\\theta - \\sin\\theta_0) + \\delta\\phi_n(\\xi)\\big)\\Big),\n$$\n波束方向图幅度定义为归一化的模\n$$\nB(\\theta,\\xi) = \\frac{1}{N}\\left|A(\\theta,\\xi)\\right|.\n$$\n通过 $N$ 进行归一化使得对于任何实现都有 $B(\\theta_0,\\xi) \\le 1$，等号仅在没有随机相位误差和完美波束控制的情况下成立。\n\n波束方向图 $B(\\theta,\\xi)$ 是高斯向量的非线性变换（由于复指数和取模运算），因此通常难以对其完整分布进行解析表征。然而，可以使用蒙特卡洛采样来计算感兴趣的统计量：从指定的多维正态分布中生成 $\\boldsymbol{\\delta\\phi}(\\xi)$ 的多个样本，为每个样本在离散角度网格上计算 $B(\\theta,\\xi)$，然后计算主瓣峰值幅度和最大旁瓣电平等派生量。\n\n对于每次实现，将主瓣峰值定义为\n$$\nB_{\\max}(\\xi) = \\max_{\\theta \\in \\Theta} B(\\theta,\\xi),\n$$\n其中 $\\Theta$ 是具有指定边界和分辨率的有限角度网格。旁瓣区域排除了波束指向角 $\\theta_0$ 周围半宽为 $\\Delta\\theta_{\\text{main}}$ 内的角度。相对于主瓣的最大旁瓣电平（以分贝计）为\n$$\n\\text{SLL}(\\xi) = \\max_{\\,\\theta \\in \\Theta:\\,|\\theta - \\theta_0| \\ge \\Delta\\theta_{\\text{main}}}\\, \\left(20\\log_{10}\\frac{B(\\theta,\\xi)}{B_{\\max}(\\xi)}\\right).\n$$\n对于阈值 $T_{\\text{dB}}$ 的超限概率是\n$$\np = \\mathbb{P}\\left(\\text{SLL}(\\xi)  T_{\\text{dB}}\\right).\n$$\n\n综合上述原理的算法设计如下：\n1. 固定物理设置：选择 $\\lambda = 1$ 米，因此 $k = 2\\pi$ 弧度/米，以及 $d = \\lambda/2$ 米。这些参数定义了几何相位级数。\n2. 构建角度网格 $\\Theta$，从 $-90$ 度到 $+90$ 度，均匀步长为 $0.2$ 度。在内部将度数转换为弧度以计算正弦值：如果 $\\theta$ 的单位是度，则 $\\sin\\theta = \\sin(\\theta \\pi/180)$。\n3. 为所有角度和单元预先计算确定性几何控制相位模板：\n   - 对于单元索引 $n = 0, 1, \\dots, N-1$，定义 $\\phi_{n}^\\text{geom}(\\theta) = k d n (\\sin\\theta - \\sin\\theta_0)$。\n   - 预计算 $E(\\theta,n) = \\exp(j \\phi_{n}^\\text{geom}(\\theta))$，其为一个形状为 $(|\\Theta|, N)$ 的矩阵，其中 $|\\Theta|$ 是角度样本的数量。\n4. 构建相位协方差矩阵 $\\boldsymbol{\\Sigma}$：\n   - 如果 $L_c  0$，则设置 $\\Sigma_{mn} = \\sigma^2 \\exp(-|m-n|/L_c)$。\n   - 如果 $L_c = 0$，则设置 $\\boldsymbol{\\Sigma} = \\sigma^2 \\mathbf{I}$。\n5. 对随机相位向量进行 $M$ 次实现采样：\n   - 如果 $\\sigma = 0$，将所有样本设为零向量以表示没有不确定性。\n   - 否则，对 $i = 1, \\dots, M$ 采样 $\\boldsymbol{\\delta\\phi}^{(i)} \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma})$。使用固定的随机种子以保证可复现性。\n6. 对每次实现，在角度网格上计算波束方向图：\n   - 为每个样本 $i$ 计算单元随机相位因子 $\\exp(j\\,\\boldsymbol{\\delta\\phi}^{(i)})$。\n   - 将预计算的模板 $E(\\theta,n)$ 与这些随机相位因子相乘，然后对 $n$ 求和，得到 $A^{(i)}(\\theta) = \\sum_{n} E(\\theta,n)\\exp(j\\,\\delta\\phi^{(i)}_n)$。\n   - 归一化得到 $B^{(i)}(\\theta) = |A^{(i)}(\\theta)|/N$。\n7. 对每次实现，确定主瓣峰值 $B_{\\max}^{(i)} = \\max_{\\theta \\in \\Theta} B^{(i)}(\\theta)$，然后在满足 $|\\theta - \\theta_0| \\ge \\Delta\\theta_{\\text{main}}$ 的角度上计算最大旁瓣电平：\n   - 计算 $r^{(i)}(\\theta) = B^{(i)}(\\theta)/B_{\\max}^{(i)}$ 并通过 $20\\log_{10} r^{(i)}(\\theta)$ 转换为分贝。\n   - 设置 $\\text{SLL}^{(i)} = \\max_{\\theta \\in \\Theta, |\\theta - \\theta_0| \\ge \\Delta\\theta_{\\text{main}}} 20\\log_{10} r^{(i)}(\\theta)$。\n8. 通过计算 $\\text{SLL}^{(i)}  T_{\\text{dB}}$ 的实现所占的比例来估计超限概率：\n   $$\n   \\hat{p} = \\frac{1}{M}\\sum_{i=1}^{M} \\mathbf{1}\\{\\text{SLL}^{(i)}  T_{\\text{dB}}\\}.\n   $$\n\n数值稳定性考虑：\n- 通过 $B_{\\max}^{(i)}$ 进行归一化可确保 $r^{(i)}(\\theta) \\in [0,1]$；为防止因相消干涉导致 $B_{\\max}^{(i)}$ 变得极小，可在分母中使用一个小的正下界 $\\varepsilon$ 来避免对零取对数。\n- 复指数和求和以双精度计算；使用向量化通过 $(|\\Theta| \\times N)$ 乘以 $(N \\times M)$ 的矩阵乘法高效地聚合多个样本，从而在一次操作中得到所有实现的 $(|\\Theta| \\times M)$ 波束方向图。\n\n程序为指定的测试套件实现了此算法：\n- 测试 1：$(N=16, \\sigma=0.1, L_c=2.0, \\theta_0=0.0^\\circ, T_{\\text{dB}}=-18.0\\,\\text{dB}, \\Delta\\theta_{\\text{main}}=6.0^\\circ, M=2000)$，\n- 测试 2：$(N=16, \\sigma=0.2, L_c=0.0, \\theta_0=30.0^\\circ, T_{\\text{dB}}=-15.0\\,\\text{dB}, \\Delta\\theta_{\\text{main}}=8.0^\\circ, M=2000)$，\n- 测试 3：$(N=32, \\sigma=0.05, L_c=8.0, \\theta_0=-10.0^\\circ, T_{\\text{dB}}=-22.0\\,\\text{dB}, \\Delta\\theta_{\\text{main}}=3.0^\\circ, M=1500)$，\n- 边界测试 4：$(N=16, \\sigma=0.0, L_c=1.0, \\theta_0=0.0^\\circ, T_{\\text{dB}}=-18.0\\,\\text{dB}, \\Delta\\theta_{\\text{main}}=6.0^\\circ, M=500)$。\n\n对于每个测试，输出是超限概率 $\\hat{p}$，为一个在 $[0,1]$ 范围内的十进制数，最终输出格式为单行打印的 $[p_1,p_2,p_3,p_4]$。固定的随机种子保证了蒙特卡洛估计的可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef covariance_matrix_sigma_lc(N: int, sigma: float, Lc: float) - np.ndarray:\n    \"\"\"\n    Construct the covariance matrix Sigma for correlated Gaussian phases.\n    Sigma_{mn} = sigma^2 * exp(-|m-n|/Lc) for Lc  0.\n    For Lc == 0, return sigma^2 * I (independent phases).\n    \"\"\"\n    if sigma == 0.0:\n        # Zero variance; covariance can be zero matrix\n        return np.zeros((N, N), dtype=float)\n    if Lc == 0.0:\n        return (sigma ** 2) * np.eye(N, dtype=float)\n    # Toeplitz structure with exponential decay in element index distance\n    idx = np.arange(N, dtype=float)\n    # Use broadcasting to form |m - n|\n    diff = np.abs(idx[:, None] - idx[None, :])\n    Sigma = (sigma ** 2) * np.exp(-diff / Lc)\n    return Sigma\n\ndef estimate_exceedance_probability(N: int, sigma: float, Lc: float,\n                                    theta0_deg: float, T_dB: float,\n                                    delta_theta_main_deg: float, M: int,\n                                    rng: np.random.Generator) - float:\n    \"\"\"\n    Estimate the exceedance probability that the maximum sidelobe level exceeds T_dB\n    given the random phase model with parameters (N, sigma, Lc).\n    \"\"\"\n    # Physical constants\n    lam = 1.0  # wavelength in meters\n    k = 2.0 * np.pi / lam  # wavenumber in rad/m\n    d = lam / 2.0  # inter-element spacing in meters\n\n    # Angle grid in degrees\n    theta_deg = np.arange(-90.0, 90.0 + 0.2, 0.2)  # inclusive range with step 0.2\n    theta_rad = np.deg2rad(theta_deg)\n    theta0_rad = np.deg2rad(theta0_deg)\n\n    # Precompute deterministic geometric phase template E(theta, n)\n    n_idx = np.arange(N, dtype=float)  # element indices 0..N-1\n    # Compute sin(theta) - sin(theta0) vector\n    sin_theta_diff = np.sin(theta_rad) - np.sin(theta0_rad)  # shape (T,)\n    # Phase for each (theta, n): k*d*n*(sin(theta) - sin(theta0))\n    # Use outer product n_idx (N,) with sin_theta_diff (T,)\n    # We want matrix of shape (T, N): E[t, n] = exp(j * k*d*n_idx[n] * sin_theta_diff[t])\n    phase_template = (k * d) * (sin_theta_diff[:, None] * n_idx[None, :])\n    E = np.exp(1j * phase_template)  # complex matrix (T, N)\n\n    # Build sidelobe mask excluding mainlobe region around theta0\n    sidelobe_mask = np.abs(theta_deg - theta0_deg) >= delta_theta_main_deg\n\n    # Construct covariance and sample random phases\n    Sigma = covariance_matrix_sigma_lc(N, sigma, Lc)\n    # Sample M phase vectors\n    if sigma == 0.0:\n        delta_phi = np.zeros((M, N), dtype=float)\n    else:\n        # Multivariate normal sampling with fixed seed\n        # Ensure numerical stability: if Sigma is near-singular, np.random will still work\n        delta_phi = rng.multivariate_normal(mean=np.zeros(N, dtype=float), cov=Sigma, size=M)\n\n    # Compute complex random phase factors for all samples: shape (M, N)\n    rand_phase_factors = np.exp(1j * delta_phi)\n    # Compute array factor across theta for all samples via matrix multiplication: (T, N) @ (N, M) - (T, M)\n    A = E @ rand_phase_factors.T\n    # Normalize beampattern magnitude by N\n    B = np.abs(A) / N  # shape (T, M)\n\n    # Compute mainlobe peak per sample\n    # Max across theta for each column (sample)\n    B_max = B.max(axis=0)  # shape (M,)\n    # Avoid division by zero or log of zero\n    eps = 1e-12\n    B_max_safe = np.maximum(B_max, eps)\n\n    # Compute normalized magnitudes in dB across sidelobe angles\n    # Select sidelobe rows\n    B_sidelobe = B[sidelobe_mask, :]  # shape (T_sidelobe, M)\n    # Compute ratio to mainlobe peak\n    ratio = B_sidelobe / B_max_safe[None, :]  # shape (T_sidelobe, M)\n    # Clip ratio for numerical safety to avoid log of zeros slightly negative due to roundoff\n    ratio = np.clip(ratio, eps, 1.0)\n    # Convert to dB\n    ratio_dB = 20.0 * np.log10(ratio)  # shape (T_sidelobe, M)\n\n    # Maximum sidelobe level per sample\n    SLL = ratio_dB.max(axis=0)  # shape (M,)\n\n    # Exceedance probability: fraction where SLL  T_dB\n    exceed = SLL  T_dB\n    p_hat = float(np.mean(exceed))\n    return p_hat\n\ndef solve():\n    # Define a fixed random seed for reproducibility\n    rng = np.random.default_rng(123456)\n\n    # Define the test cases from the problem statement.\n    # (N, sigma, Lc, theta0_deg, T_dB, delta_theta_main_deg, M)\n    test_cases = [\n        (16, 0.1, 2.0, 0.0, -18.0, 6.0, 2000),\n        (16, 0.2, 0.0, 30.0, -15.0, 8.0, 2000),\n        (32, 0.05, 8.0, -10.0, -22.0, 3.0, 1500),\n        (16, 0.0, 1.0, 0.0, -18.0, 6.0, 500),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, sigma, Lc, theta0_deg, T_dB, delta_theta_main_deg, M = case\n        p = estimate_exceedance_probability(N, sigma, Lc, theta0_deg, T_dB,\n                                            delta_theta_main_deg, M, rng)\n        # Round to a reasonable number of decimals for stable output\n        results.append(f\"{p:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3358419"}, {"introduction": "虽然蒙特卡洛方法直观且稳健，但其计算成本可能非常高，尤其对于复杂的电磁模型。多项式混沌展开（Polynomial Chaos Expansions, PCE）通过构建系统响应的代理模型，提供了一种更高效的不确定性量化方法。本练习将深入探讨PCE在一个典型电磁谐振腔模型中的实际应用。更重要的是，它揭示了全局PCE方法在面对尖锐、局部化的物理现象（如激励频率与系统谐振频率交叉）时的局限性，并指导您实现一种更高级的自适应多单元PCE（multi-element PCE）方法来克服这一挑战 [@problem_id:3358464]。", "problem": "考虑一个由麦克斯韦方程组描述的、在时谐状态下工作的单个驱动电磁腔。在孤立谐振点附近，固定空间观测点的场可以由单极点模态展开进行一阶近似建模。在存在微小但非零阻尼的情况下，局部响应可以很好地由一个在复频率平面上具有简单极点形式的标量传递函数来近似。设激励角频率固定为 $\\,\\omega_{0}\\,$。设材料参数的可变性由单个标准化随机变量 $\\,\\xi\\sim\\mathcal{U}([-1,1])\\,$ 描述。谐振频率通过一个光滑的仿射映射 $\\,\\omega_{r}(\\xi)=\\omega_{c}\\,(1+\\alpha\\,\\xi)\\,$ 依赖于 $\\,\\xi\\,$，其中 $\\,\\omega_{c}0\\,$ 和 $\\,\\alpha\\in\\mathbb{R}\\,$ 是已知常数。有效阻尼由一个常数 $\\,\\gamma0\\,$ 建模。将关注的标量定义为在固定激励下求值的传递函数的实部，即\n$$\nE(\\xi)\\equiv \\operatorname{Re}\\left\\{\\frac{1}{\\omega_{0}-\\omega_{r}(\\xi)+\\mathrm{i}\\,\\gamma}\\right\\}=\\frac{\\omega_{0}-\\omega_{r}(\\xi)}{\\left(\\omega_{0}-\\omega_{r}(\\xi)\\right)^{2}+\\gamma^{2}}.\n$$\n将所有量视为无量纲。最终输出不使用角度。\n\n本问题研究使用多项式混沌展开（PCE）对 $\\,E(\\xi)\\,$ 进行不确定性量化，并探讨当谐振频率 $\\,\\omega_{r}(\\xi)\\,$ 在 $\\,\\xi\\,$ 的支撑集内穿过激励频率 $\\,\\omega_{0}\\,$ 时，单个全局PCE的精度损失问题。您必须实现两种代理模型：\n\n- 一个全局多项式混沌展开，总阶数为 $\\,p_{\\mathrm{G}}\\,$，在 $\\,[-1,1]\\,$ 上使用适应于 $\\,\\xi\\,$ 均匀分布的勒让德多项式基。系数通过关于 $\\,[-1,1]\\,$ 上均匀测度的正交投影计算，并由在 $\\,[-1,1]\\,$ 上足够高阶的高斯求积近似。\n\n- 一个多单元多项式混沌展开，在 $\\,\\xi\\,$ 中使用自适应域划分。从完整区间 $\\,[-1,1]\\,$ 开始，并递归地划分区间。在每个单元 $\\,[a,b]\\subset[-1,1]\\,$ 上，定义局部仿射映射 $\\,s=\\frac{2\\xi-(a+b)}{b-a}\\in[-1,1]\\,$，并通过相对于限制在 $\\,[a,b]\\,$ 上的均匀测度的正交投影（等效地，通过在 $\\,s\\in[-1,1]\\,$ 上的求积），构建一个总阶数为 $\\,p_{\\mathrm{L}}\\,$ 的局部勒让德PCE。使用一个基于单元上最后几个模态系数的相对尾部能量的自适应指示器；如果归一化的尾部能量超过规定的容差，则分裂该单元。分裂时，如果失谐 $\\,\\Delta(\\xi)\\equiv \\omega_{0}-\\omega_{r}(\\xi)\\,$ 在单元上改变符号，则在 $\\,\\Delta(\\xi)\\,$ 位于单元内的零点处分裂；否则在其中点分裂。继续此过程，直到指示器低于容差或达到最大细化深度，或单元变得小于最小长度。\n\n对于这两种代理模型，通过在 $\\,\\xi\\in[-1,1]\\,$ 上相对于均匀分布的均方根 $\\,L^{2}\\,$ 误差来量化精度，该误差通过均匀采样来近似。具体地，如果 $\\,\\{\\xi_{j}\\}_{j=1}^{N}\\,$ 是在 $\\,[-1,1]\\,$ 中的均匀间隔点，定义\n$$\n\\varepsilon \\equiv \\sqrt{\\frac{1}{N}\\sum_{j=1}^{N}\\left(E(\\xi_{j})-\\widehat{E}(\\xi_{j})\\right)^{2}},\n$$\n其中 $\\,\\widehat{E}\\,$ 表示全局PCE或多单元PCE近似。将 $\\,\\varepsilon\\,$ 表示为科学记数法浮点数。\n\n您必须实现一个单一程序，对于下面每个参数集，构建两种代理模型并输出它们的误差。对代理模型和误差评估使用以下固定的数值设置：\n\n- 全局PCE总阶数 $\\,p_{\\mathrm{G}}=8\\,$。\n- 局部PCE总阶数 $\\,p_{\\mathrm{L}}=6\\,$。\n- 局域自适应尾部指示器容差 $\\,\\tau=10^{-4}\\,$，其中尾部指示器是最后 $\\,3\\,$ 个局部系数的平方和与所有局部系数的平方和之比（在分母中使用一个小的正数下限以避免除以零）。\n- 最大细化深度 $\\,d_{\\max}=12\\,$。\n- 最小单元长度 $\\,\\ell_{\\min}=10^{-3}\\,$。\n- 对于任何单元上的所有系数投影，使用阶数为 $\\,N_{q}=200\\,$ 的高斯求积。\n- 对于误差评估，在 $\\,[-1,1]\\,$ 上使用 $\\,N=10001\\,$ 个均匀间隔的采样点。\n\n测试套件（每个案例都是使用相同数值设置的独立运行）：\n\n- 案例 $\\,1\\,$ （平滑，无穿越）：$\\,\\omega_{0}=1.0\\,$, $\\,\\omega_{c}=0.2\\,$, $\\,\\alpha=0.1\\,$, $\\,\\gamma=0.5\\,$。\n- 案例 $\\,2\\,$ （内部穿越，小阻尼）：$\\,\\omega_{0}=1.0\\,$, $\\,\\omega_{c}=1.0\\,$, $\\,\\alpha=0.8\\,$, $\\,\\gamma=0.01\\,$。\n- 案例 $\\,3\\,$ （边界附近穿越）：选择 $\\,\\omega_{c}=1.0\\,$, $\\,\\alpha=0.6\\,$，并设置 $\\,\\omega_{0}=1.57\\,$，其中 $\\,\\gamma=0.01\\,$。\n- 案例 $\\,4\\,$ （内部穿越，极小阻尼）：$\\,\\omega_{0}=1.0\\,$, $\\,\\omega_{c}=1.0\\,$, $\\,\\alpha=0.9\\,$, $\\,\\gamma=10^{-4}\\,$。\n\n您的程序必须生成单行输出，其中包含一个列表，内含八个科学记数法浮点数，顺序如下\n$$\n[\\varepsilon_{\\mathrm{G}}^{(1)},\\varepsilon_{\\mathrm{ME}}^{(1)},\\varepsilon_{\\mathrm{G}}^{(2)},\\varepsilon_{\\mathrm{ME}}^{(2)},\\varepsilon_{\\mathrm{G}}^{(3)},\\varepsilon_{\\mathrm{ME}}^{(3)},\\varepsilon_{\\mathrm{G}}^{(4)},\\varepsilon_{\\mathrm{ME}}^{(4)}],\n$$\n其中 $\\,\\varepsilon_{\\mathrm{G}}^{(k)}\\,$ 是案例 $\\,k\\,$ 的全局PCE误差，$\\,\\varepsilon_{\\mathrm{ME}}^{(k)}\\,$ 是案例 $\\,k\\,$ 的多单元PCE误差。该行必须严格按照方括号括起来的逗号分隔列表的形式打印，例如 $\\,\\bigl[\\texttt{1.234000e-03},\\texttt{5.670000e-05},\\dots\\bigr]\\,$。\n\n本问题中的所有量都是无量纲的。程序必须是自包含的，不需要任何输入，并且必须遵守指定的数值设置，不得修改。", "solution": "该问题要求为一个电磁腔谐振模型实现并比较两种代理建模技术：全局多项式混沌展开（GPCE）和多单元多项式混沌展开（ME-PCE）。目标是量化由材料参数变化引起的系统响应的不确定性。\n\n关注量（QoI）是谐振传递函数的实部，由下式给出：\n$$\nE(\\xi) = \\operatorname{Re}\\left\\{\\frac{1}{\\omega_{0}-\\omega_{r}(\\xi)+\\mathrm{i}\\,\\gamma}\\right\\} = \\frac{\\omega_{0}-\\omega_{r}(\\xi)}{\\left(\\omega_{0}-\\omega_{r}(\\xi)\\right)^{2}+\\gamma^{2}}\n$$\n谐振频率 $\\omega_{r}(\\xi)$ 仿射地依赖于一个随机变量 $\\xi \\sim \\mathcal{U}([-1,1])$：\n$$\n\\omega_{r}(\\xi) = \\omega_{c}\\,(1+\\alpha\\,\\xi)\n$$\n其中 $\\omega_0$ 是固定激励频率，$\\omega_c$ 和 $\\alpha$ 是定义谐振行为的常数，$\\gamma  0$ 是阻尼因子。\n\n当失谐 $\\Delta(\\xi) = \\omega_{0}-\\omega_{r}(\\xi)$ 在其支撑集 $[-1,1]$ 内的某个 $\\xi$ 值处变为零时，函数 $E(\\xi)$ 表现出洛伦兹线型特有的尖锐峰值。该峰值的锐度与阻尼 $\\gamma$ 成反比。这种尖锐的、局部化的特征对全局多项式近似方法构成了重大挑战，因为这些方法更适合于平滑函数。本问题旨在展示这种局限性以及自适应域分解方法的有效性。\n\n每个代理模型 $\\widehat{E}(\\xi)$ 的精度通过在 $[-1,1]$ 内均匀分布的 $N=10001$ 个细网格点 $\\{\\xi_j\\}$ 上的均方根（$L^2$）误差来衡量：\n$$\n\\varepsilon \\equiv \\sqrt{\\frac{1}{N}\\sum_{j=1}^{N}\\left(E(\\xi_{j})-\\widehat{E}(\\xi_{j})\\right)^{2}}\n$$\n\n**1. 全局多项式混沌展开 (GPCE)**\n\nGPCE方法将关注量 $E(\\xi)$ 近似为一组正交多项式的有限级数。由于 $\\xi$ 是均匀分布的，合适的正交基是勒让德多项式 $\\{P_k(\\xi)\\}$。总阶数为 $p_{\\mathrm{G}}$ 的GPCE为：\n$$\n\\widehat{E}_{\\mathrm{G}}(\\xi) = \\sum_{k=0}^{p_{\\mathrm{G}}} c_k P_k(\\xi)\n$$\n系数 $c_k$ 通过正交投影确定，这能最小化均方误差。系数的计算公式为：\n$$\nc_k = \\frac{\\langle E(\\xi), P_k(\\xi) \\rangle}{\\langle P_k(\\xi), P_k(\\xi) \\rangle} = \\frac{\\int_{-1}^{1} E(\\xi) P_k(\\xi) d\\xi}{\\int_{-1}^{1} P_k^2(\\xi) d\\xi} = \\frac{2k+1}{2} \\int_{-1}^{1} E(\\xi) P_k(\\xi) d\\xi\n$$\n该积分使用具有 $N_q=200$ 个点和权重的高斯-勒让德求积进行数值计算，记为 $(\\zeta_i, w_i)$：\n$$\nc_k \\approx \\frac{2k+1}{2} \\sum_{i=1}^{N_q} E(\\zeta_i) P_k(\\zeta_i) w_i\n$$\n问题指定了固定阶数 $p_{\\mathrm{G}}=8$。在 $E(\\xi)$ 具有尖峰的情况下，这种低阶全局多项式将难以捕捉该特征，从而导致较大的误差和伪振荡（吉布斯现象）。\n\n**2. 多单元多项式混沌展开 (ME-PCE)**\n\nME-PCE方法通过将 $\\xi$ 的域划分为更小的单元，并在每个单元上构建独立的局部PCE，从而缓解了GPCE的局限性。这使得模型能够适应函数的局部特征。该算法是递归的：\n\n1.  **初始化**：从覆盖整个域 $[-1,1]$ 的单个单元开始，并指定最大细化深度 $d_{\\max}=12$。\n\n2.  **迭代**：对于当前细化深度的每个活动单元 $[a, b]$：\n    a.  **局部PCE构建**：构建一个阶数为 $p_{\\mathrm{L}}=6$ 的局部PCE。这需要通过仿射变换 $s = \\frac{2\\xi-(a+b)}{b-a}$ 将单元 $[a, b]$ 映射到参考单元 $s \\in [-1,1]$。局部展开为 $\\widehat{E}_{\\text{local}}(s) = \\sum_{j=0}^{p_{\\mathrm{L}}} c_j^{\\text{local}} P_j(s)$。系数 $c_j^{\\text{local}}$ 通过在参考单元上的求积计算，类似于全局情况。\n    b.  **自适应指示器**：为了决定单元是否需要进一步细化，我们计算一个尾部能量指示器。它衡量局部展开中最高阶模态所包含的相对能量。\n    $$\n    \\eta = \\frac{\\sum_{j=p_{\\mathrm{L}}-2}^{p_{\\mathrm{L}}} (c_j^{\\text{local}})^2}{\\varepsilon_{\\text{floor}} + \\sum_{j=0}^{p_{\\mathrm{L}}} (c_j^{\\text{local}})^2}\n    $$\n    其中，问题指定使用最后 $3$ 个系数，$\\varepsilon_{\\text{floor}}$ 是一个小的正数以防止除以零。\n    c.  **细化决策**：如果单元 $[a, b]$ 的长度大于 $\\ell_{\\min}=10^{-3}$ 且其指示器 $\\eta$ 大于容差 $\\tau=10^{-4}$，则标记该单元进行细化。\n    d.  **分裂策略**：如果需要细化，则智能地选择分裂点。我们找到失谐为零的值 $\\xi_z$：$\\Delta(\\xi_z) = \\omega_0 - \\omega_r(\\xi_z) = 0$。这给出 $\\xi_z = (\\frac{\\omega_0}{\\omega_c} - 1)/\\alpha$。如果该点 $\\xi_z$ 严格位于单元 $(a, b)$ 内部，则将单元分裂为 $[a, \\xi_z]$ 和 $[\\xi_z, b]$。这将细化集中在尖峰周围。否则，在其中点 $m=(a+b)/2$ 处分裂单元。\n\n3.  **终止**：当给定分支的自适应指示器低于容差、单元尺寸小于最小值或达到最大深度时，递归停止。\n\n最终的ME-PCE代理模型是一个分段多项式函数，其中每一段都是域划分中最终单元上的局部PCE。这种自适应细化策略预计将在 $E(\\xi)$ 的尖峰周围（如果存在）放置许多小单元，并在函数平滑处使用较大的单元，从而实现高精度和高效的近似。\n\n对于给定的测试案例：\n*   **案例1**：$E(\\xi)$ 是平滑的。GPCE和ME-PCE都应该表现良好，ME-PCE很可能不会对域进行太多细化（如果细化的话）。\n*   **案例2、3、4**：在 $[-1,1]$ 内发生谐振穿越，且阻尼 $\\gamma$ 很小。$E(\\xi)$ 具有尖峰。预计GPCE将产生较大误差。ME-PCE将围绕峰值进行自适应细化，从而导致误差显著降低。随着 $\\gamma$ 减小（案例4与案例2相比），峰值变得更尖锐，GPCE的误差将更大。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\nfrom numpy.polynomial.legendre import legval, legvander\n\ndef solve():\n    \"\"\"\n    Solves the uncertainty quantification problem for an electromagnetic cavity model\n    using Global and Multi-Element Polynomial Chaos Expansions.\n    \"\"\"\n    \n    # --- Fixed Numerical Settings ---\n    p_G = 8          # Global PCE total degree\n    p_L = 6          # Local PCE total degree\n    tau = 1e-4       # Local adaptivity tail-indicator tolerance\n    d_max = 12       # Maximum refinement depth\n    l_min = 1e-3     # Minimum element length\n    N_q = 200        # Gaussian quadrature order\n    N = 10001        # Number of points for error evaluation\n    TAIL_COEFFS = 3  # Number of tail coefficients for indicator\n    \n    # --- Test Cases ---\n    test_cases = [\n        # (w0, wc, alpha, gamma)\n        (1.0, 0.2, 0.1, 0.5),    # Case 1: Smooth, no crossing\n        (1.0, 1.0, 0.8, 0.01),   # Case 2: Interior crossing, small damping\n        (1.57, 1.0, 0.6, 0.01),  # Case 3: Crossing near boundary\n        (1.0, 1.0, 0.9, 1e-4),   # Case 4: Interior crossing, very small damping\n    ]\n\n    # --- Precompute shared resources ---\n    xi_eval = np.linspace(-1.0, 1.0, N)\n    quad_nodes_ref, quad_weights_ref = roots_legendre(N_q)\n    \n    results = []\n    for w0, wc, alpha, gamma in test_cases:\n        \n        # --- Define the true model function (Quantity of Interest) ---\n        def E_func(xi):\n            wr = wc * (1 + alpha * xi)\n            detuning = w0 - wr\n            return detuning / (detuning**2 + gamma**2)\n\n        true_vals = E_func(xi_eval)\n\n        # -----------------------------------------------------------\n        # 1. Global Polynomial Chaos Expansion (GPCE)\n        # -----------------------------------------------------------\n        def build_gpce():\n            xi_q = quad_nodes_ref\n            E_q = E_func(xi_q)\n            \n            coeffs = np.zeros(p_G + 1)\n            for k in range(p_G + 1):\n                Pk_at_nodes = legval(xi_q, [1.0 if i == k else 0.0 for i in range(k + 1)])\n                # Integral of E(xi) * P_k(xi) dxi over [-1, 1]\n                integral = np.sum(E_q * Pk_at_nodes * quad_weights_ref)\n                # Projection formula for Legendre coeffs\n                coeffs[k] = (2 * k + 1) / 2.0 * integral\n            return coeffs\n\n        gpce_coeffs = build_gpce()\n        gpce_vals = legval(xi_eval, gpce_coeffs)\n        error_gpce = np.sqrt(np.mean((true_vals - gpce_vals)**2))\n        \n        # -----------------------------------------------------------\n        # 2. Multi-Element Polynomial Chaos Expansion (ME-PCE)\n        # -----------------------------------------------------------\n        def compute_local_coeffs(a, b):\n            # Map reference quadrature nodes to element [a, b]\n            xi_q = 0.5 * ((b - a) * quad_nodes_ref + (a + b))\n            E_q = E_func(xi_q)\n            \n            coeffs = np.zeros(p_L + 1)\n            for k in range(p_L + 1):\n                Pk_at_nodes = legval(quad_nodes_ref, [1.0 if i == k else 0.0 for i in range(k + 1)])\n                # Integral of E_local(s) * P_k(s) ds over [-1, 1]\n                integral = np.sum(E_q * Pk_at_nodes * quad_weights_ref)\n                # Projection formula for Legendre coeffs on a general interval\n                # The jacobian term (b-a)/2 from mapping d_xi combines with the integral over [-1,1]\n                # c_k = ((2k+1)/2) * Integral[f(map(s)) P_k(s) ds]\n                coeffs[k] = (2 * k + 1) / 2.0 * integral\n            return coeffs\n\n        def build_mepce():\n            elements_to_process = [(-1.0, 1.0)]\n            final_elements = []\n\n            for _ in range(d_max):\n                if not elements_to_process:\n                    break\n                \n                next_elements_to_process = []\n                for a, b in elements_to_process:\n                    coeffs = compute_local_coeffs(a, b)\n                    \n                    coeff_sq = coeffs**2\n                    tail_energy = np.sum(coeff_sq[-TAIL_COEFFS:])\n                    total_energy = np.sum(coeff_sq)\n                    eta = tail_energy / (total_energy + 1e-30)\n\n                    # Stop if indicator is small or element is small\n                    if eta = tau or (b - a) = l_min:\n                        final_elements.append((a, b, coeffs))\n                    else: # Refine\n                        if alpha != 0:\n                            xi_z = (w0 / wc - 1.0) / alpha\n                        else:\n                            xi_z = np.inf\n\n                        if a  xi_z  b:\n                            split_point = xi_z\n                        else:\n                            split_point = 0.5 * (a + b)\n                        \n                        next_elements_to_process.append((a, split_point))\n                        next_elements_to_process.append((split_point, b))\n\n                elements_to_process = next_elements_to_process\n\n            # Add any remaining elements at max depth\n            for a, b in elements_to_process:\n                coeffs = compute_local_coeffs(a, b)\n                final_elements.append((a, b, coeffs))\n\n            final_elements.sort(key=lambda x: x[0])\n            return final_elements\n        \n        mepce_structure = build_mepce()\n\n        def eval_mepce(xi_pts, structure):\n            y_eval = np.zeros_like(xi_pts)\n            bins = np.array([el[0] for el in structure] + [structure[-1][1]])\n            \n            # Find which element each xi_pts belongs to\n            indices = np.digitize(xi_pts, bins, right=False) - 1\n            # Handle the rightmost point specifically\n            indices[xi_pts == bins[-1]] = len(structure) - 1\n\n            for i, (a, b, coeffs) in enumerate(structure):\n                mask = (indices == i)\n                if np.any(mask):\n                    xi_local = xi_pts[mask]\n                    # Map to reference element [-1, 1]\n                    s_local = (2 * xi_local - (a + b)) / (b - a)\n                    y_eval[mask] = legval(s_local, coeffs)\n            return y_eval\n\n        mepce_vals = eval_mepce(xi_eval, mepce_structure)\n        error_mepce = np.sqrt(np.mean((true_vals - mepce_vals)**2))\n        \n        results.extend([error_gpce, error_mepce])\n\n    print(f\"[{','.join([f'{r:.6e}' for r in results])}]\")\n\nsolve()\n```", "id": "3358464"}, {"introduction": "理解不确定性是第一步，而最终目标是设计出能够在不确定性影响下依然表现出色的鲁棒系统。这项实践将我们的焦点从不确定性分析转向不确定性下的设计优化。您将为一个微波吸波体设计其层厚，使其性能对材料参数的制造变化不敏感。在本练习中，您将实现并比较两种主流的设计哲学：最小化最坏情况下的性能（即鲁棒优化），以及使用风险价值（Conditional Value-at-Risk, CVaR）来控制极端不良性能的风险 [@problem_id:3358413]。", "problem": "考虑一个一维平面波法向入射电磁吸收体，其由一个均匀各向同性平板构成，平板后方为一个完美电导体板。环境介质为自由空间。该吸收体由复介电常数和复磁导率表征，两者均通过相对于自由空间值的相对部分来定义。制造可变性导致平板材料参数存在不确定性。设计目标是选择一个平板厚度，以实现对这些不确定性的鲁棒性。\n\n从频域中的麦克斯韦方程组、均匀介质中的平面波解以及材料界面处的标准边界条件出发。利用这些原理，推导当背衬为完美电导体时，平板前界面的功率反射率。设角频率为 $\\,\\omega\\,$，自由空间介电常数为 $\\,\\varepsilon_0\\,$，自由空间磁导率为 $\\,\\mu_0\\,$。将环境介质（自由空间）的波阻抗表示为 $\\,Z_1 = \\sqrt{\\mu_0/\\varepsilon_0}\\,$。将平板的复介电常数和复磁导率表示为 $\\,\\varepsilon = \\varepsilon_0(\\varepsilon_r' - j\\,\\varepsilon_r'')\\,$ 和 $\\,\\mu = \\mu_0(\\mu_r' - j\\,\\mu_r'')\\,$，其中 $\\,\\varepsilon_r'\\,$ 和 $\\,\\mu_r'\\,$ 是相对实部，而 $\\,\\varepsilon_r''\\,$ 和 $\\,\\mu_r''\\,$ 是损耗项。设平板厚度为 $\\,d\\,$，单位为米。\n\n将最坏情况（鲁棒）设计目标定义为在参数空间 $\\,\\xi = (\\varepsilon_r', \\varepsilon_r'', \\mu_r', \\mu_r'')\\,$ 中的一个已知不确定性集合 $\\,\\mathcal{U}\\,$（一个多胞体，此处为超矩形）上，反射率上确界的最小化：\n$$\n\\min_{d \\in [d_{\\min}, d_{\\max}]} \\ \\sup_{\\xi \\in \\mathcal{U}} \\ R(\\omega, \\xi, d),\n$$\n其中 $\\,R(\\omega,\\xi,d)\\,$ 是功率反射率，一个无量纲的量。此外，使用条件风险价值（CVaR）定义一个概率性风险目标，其水平为 $\\,\\alpha \\in (0,1)\\,$，针对 $\\,\\mathcal{U}\\,$ 上 $\\,\\xi\\,$ 的一个指定概率分布。对于给定的厚度 $\\,d\\,$ 和在 $\\,\\mathcal{U}\\,$ 上有分布的随机参数 $\\,\\xi\\,$，令 $\\,\\mathrm{CVaR}_\\alpha(d)\\,$ 为 $\\,R(\\omega,\\xi,d)\\,$ 处于最差的 $\\,\\alpha\\,$ 尾部时的条件期望反射率。概率性设计目标为：\n$$\n\\min_{d \\in [d_{\\min}, d_{\\max}]} \\ \\mathrm{CVaR}_\\alpha(d).\n$$\n\n您的任务是实现一个完整的程序，该程序：\n- 基于上述基本原理，计算由完美电导体背衬的平板在平面波法向入射下的功率反射率 $\\,R(\\omega,\\xi,d)\\,$，并用平板的输入阻抗和环境阻抗来表示。\n- 通过在超矩形 $\\,\\mathcal{U}\\,$ 上的均匀网格上评估 $\\,R\\,$ 并取最大值，来近似 $\\,\\sup_{\\xi \\in \\mathcal{U}} R(\\omega,\\xi,d)\\,$。\n- 通过对相同的均匀网格进行采样，计算所有反射率值，对其进行排序，并对最大的 $\\,\\lceil \\alpha M \\rceil\\,$ 个值求平均，来近似 $\\,\\mathrm{CVaR}_\\alpha(d)\\,$，其中 $\\,M\\,$ 是网格点总数。\n- 在厚度 $\\,d \\in [d_{\\min}, d_{\\max}]\\,$ 上执行网格搜索，以找到使最坏情况反射率最小化的厚度，以及使 CVaR 目标最小化的厚度，对 $\\,d\\,$ 使用相同的均匀网格。\n\n物理常数和单位：\n- 使用 $\\,\\varepsilon_0 = 8.854187817 \\times 10^{-12}\\,\\mathrm{F/m}\\,$ 和 $\\,\\mu_0 = 4\\pi \\times 10^{-7}\\,\\mathrm{H/m}\\,$。\n- 环境阻抗为 $\\,Z_1 = \\sqrt{\\mu_0/\\varepsilon_0}\\,$，单位为 $\\,\\Omega\\,$。\n- 频率必须以 $\\,\\mathrm{Hz}\\,$ 指定，并通过 $\\,\\omega = 2\\pi f\\,$ 转换为角频率。\n- 厚度单位必须为 $\\,\\mathrm{m}\\,$。\n- 反射率为无量纲。\n\n测试套件：\n对于以下每个案例，在每个不确定参数维度上使用具有指定点数（包括端点）的均匀网格，以形成超矩形多胞体 $\\,\\mathcal{U}\\,$。在指定区间上，对厚度值 $\\,d\\,$ 使用具有给定点数（包括端点）的均匀网格。对于 CVaR 计算，在 $\\,\\mathcal{U}\\,$ 的网格点上使用均匀分布。\n\n- 案例 $\\,1\\,$（一般可变性，中等损耗）：\n    - 频率 $\\,f = 10 \\times 10^9\\,\\mathrm{Hz}\\,$。\n    - 厚度区间 $\\,d \\in [5 \\times 10^{-4},\\, 1 \\times 10^{-2}]\\,\\mathrm{m}\\,$，含 $\\,81\\,$ 个点。\n    - 不确定性集合 $\\,\\mathcal{U}\\,$：\n        - $\\,\\varepsilon_r' \\in [2.0,\\, 2.5]\\,$，含 $\\,9\\,$ 个点。\n        - $\\,\\varepsilon_r'' \\in [0.05,\\, 0.15]\\,$，含 $\\,9\\,$ 个点。\n        - $\\,\\mu_r' \\in [1.0,\\, 1.0]\\,$，含 $\\,1\\,$ 个点。\n        - $\\,\\mu_r'' \\in [0.0,\\, 0.05]\\,$，含 $\\,7\\,$ 个点。\n    - CVaR 水平 $\\,\\alpha = 0.1\\,$。\n\n- 案例 $\\,2\\,$（强损耗可变性，弱磁性可变性）：\n    - 频率 $\\,f = 2 \\times 10^9\\,\\mathrm{Hz}\\,$。\n    - 厚度区间 $\\,d \\in [1 \\times 10^{-3},\\, 5 \\times 10^{-2}]\\,\\mathrm{m}\\,$，含 $\\,81\\,$ 个点。\n    - 不确定性集合 $\\,\\mathcal{U}\\,$：\n        - $\\,\\varepsilon_r' \\in [1.5,\\, 1.6]\\,$，含 $\\,7\\,$ 个点。\n        - $\\,\\varepsilon_r'' \\in [0.5,\\, 0.8]\\,$，含 $\\,7\\,$ 个点。\n        - $\\,\\mu_r' \\in [1.0,\\, 1.05]\\,$，含 $\\,5\\,$ 个点。\n        - $\\,\\mu_r'' \\in [0.0,\\, 0.2]\\,$，含 $\\,7\\,$ 个点。\n    - CVaR 水平 $\\,\\alpha = 0.2\\,$。\n\n- 案例 $\\,3\\,$（近自由空间材料，弱损耗）：\n    - 频率 $\\,f = 6 \\times 10^9\\,\\mathrm{Hz}\\,$。\n    - 厚度区间 $\\,d \\in [1 \\times 10^{-4},\\, 5 \\times 10^{-3}]\\,\\mathrm{m}\\,$，含 $\\,101\\,$ 个点。\n    - 不确定性集合 $\\,\\mathcal{U}\\,$：\n        - $\\,\\varepsilon_r' \\in [0.95,\\, 1.05]\\,$，含 $\\,11\\,$ 个点。\n        - $\\,\\varepsilon_r'' \\in [0.0,\\, 0.02]\\,$，含 $\\,5\\,$ 个点。\n        - $\\,\\mu_r' \\in [0.95,\\, 1.05]\\,$，含 $\\,11\\,$ 个点。\n        - $\\,\\mu_r'' \\in [0.0,\\, 0.02]\\,$，含 $\\,5\\,$ 个点。\n    - CVaR 水平 $\\,\\alpha = 0.1\\,$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个案例，按顺序报告四个值：\n- 鲁棒设计厚度 $\\,d_{\\mathrm{robust}}\\,$，单位为 $\\,\\mathrm{m}\\,$，\n- 该厚度下的最坏情况反射率 $\\,R_{\\mathrm{worst}}\\,$（无量纲），\n- CVaR 设计厚度 $\\,d_{\\mathrm{CVaR}}\\,$，单位为 $\\,\\mathrm{m}\\,$，\n- 该厚度下的 CVaR 值 $\\,\\mathrm{CVaR}\\,$（无量纲）。\n\n因此，对于三个案例，输出必须是一个包含 $\\,12\\,$ 个浮点数的列表：\n$$\n[ d_{\\mathrm{robust},1}, R_{\\mathrm{worst},1}, d_{\\mathrm{CVaR},1}, \\mathrm{CVaR}_1,\\ d_{\\mathrm{robust},2}, R_{\\mathrm{worst},2}, d_{\\mathrm{CVaR},2}, \\mathrm{CVaR}_2,\\ d_{\\mathrm{robust},3}, R_{\\mathrm{worst},3}, d_{\\mathrm{CVaR},3}, \\mathrm{CVaR}_3 ].\n$$\n所有厚度值的单位均为 $\\,\\mathrm{m}\\,$，所有反射率值均为无量纲。不应打印任何额外文本。", "solution": "该问题要求推导由完美电导体（PEC）背衬的单层电磁吸收体的功率反射率，并随后在参数不确定性下对层厚度进行数值优化。我们首先回归到基本原理，即麦克斯韦方程组，以推导必要的解析表达式。\n\n定义坐标系，使得环境介质（自由空间）位于区域 $z0$，吸收平板位于区域 $0 \\le z \\le d$，PEC 位于平面 $z=d$。假设一个平面波从自由空间法向入射，并沿 $+z$ 方向传播。\n\n在一个无源、均匀、各向同性的介质中，角频率为 $\\omega$ 的时谐麦克斯韦旋度方程组为：\n$$\n\\nabla \\times \\mathbf{E} = -j\\omega\\mu \\mathbf{H}\n$$\n$$\n\\nabla \\times \\mathbf{H} = j\\omega\\varepsilon \\mathbf{E}\n$$\n其中 $\\mathbf{E}$ 和 $\\mathbf{H}$ 是电场和磁场的复相量，$\\varepsilon$ 是复介电常数，$\\mu$ 是复磁导率。对于电场沿 $\\hat{\\mathbf{x}}$ 方向极化的平面波，这些方程的解具有以下形式：\n$$\n\\mathbf{E}(z) = E_x(z) \\hat{\\mathbf{x}} \\quad , \\quad \\mathbf{H}(z) = H_y(z) \\hat{\\mathbf{y}}\n$$\n横向电场和磁场振幅之比定义了介质的本征阻抗，$Z = \\sqrt{\\mu/\\varepsilon}$。波的传播由传播常数 $\\gamma = j\\omega\\sqrt{\\mu\\varepsilon}$ 描述。介质中电场的一般解是前向传播波（$e^{-\\gamma z}$）和后向传播波（$e^{+\\gamma z}$）的叠加。\n\n该问题可以使用传输线类比进行分析。\n环境介质（区域 $1$，$z0$）是自由空间，其介电常数为 $\\varepsilon_0$，磁导率为 $\\mu_0$。其本征阻抗为 $Z_1 = \\sqrt{\\mu_0 / \\varepsilon_0}$。\n吸收平板（区域 $2$，$0 \\le z \\le d$）具有复介电常数 $\\varepsilon = \\varepsilon_0(\\varepsilon_r' - j\\varepsilon_r'')$ 和复磁导率 $\\mu = \\mu_0(\\mu_r' - j\\mu_r'')$。其本征阻抗为 $Z_2 = \\sqrt{\\mu/\\varepsilon}$，传播常数为 $\\gamma_2 = j\\omega\\sqrt{\\mu\\varepsilon}$。\n\n在边界 $z=d$ 处，平板由一个 PEC 终端。PEC 的边界条件是电场的切向分量必须为零。在传输线类比中，这相当于一个短路负载，其负载阻抗为 $Z_L = 0$。\n\n在平板前端（$z=0$）看到的输入阻抗 $Z_{in}$ 由长度为 $d$、特征阻抗为 $Z_2$、负载阻抗为 $Z_L$ 的传输线的阻抗变换公式给出：\n$$\nZ_{in} = Z_2 \\frac{Z_L + Z_2 \\tanh(\\gamma_2 d)}{Z_2 + Z_L \\tanh(\\gamma_2 d)}\n$$\n将 PEC 背衬的 $Z_L=0$ 代入可得：\n$$\nZ_{in} = Z_2 \\tanh(\\gamma_2 d)\n$$\n这就是 PEC 背衬平板的输入阻抗。\n\n在界面 $z=0$ 处，入射波遇到一个有效阻抗 $Z_{in}$。此界面处的反射系数 $\\Gamma$ 由环境介质（$Z_1$）和平板（$Z_{in}$）之间的阻抗失配决定：\n$$\n\\Gamma = \\frac{Z_{in} - Z_1}{Z_{in} + Z_1}\n$$\n功率反射率 $R$ 是反射系数 $\\Gamma$ 的模的平方：\n$$\nR(\\omega, \\xi, d) = |\\Gamma|^2 = \\left| \\frac{Z_{in} - Z_1}{Z_{in} + Z_1} \\right|^2\n$$\n代入 $Z_{in}$ 的表达式，我们得到功率反射率的最终公式：\n$$\nR(\\omega, \\xi, d) = \\left| \\frac{Z_2 \\tanh(\\gamma_2 d) - Z_1}{Z_2 \\tanh(\\gamma_2 d) + Z_1} \\right|^2\n$$\n参数 $Z_2$ 和 $\\gamma_2$ 取决于不确定的材料属性 $\\xi = (\\varepsilon_r', \\varepsilon_r'', \\mu_r', \\mu_r'')$：\n$$\nZ_2(\\xi) = \\sqrt{\\frac{\\mu_0(\\mu_r' - j\\mu_r'')}{\\varepsilon_0(\\varepsilon_r' - j\\varepsilon_r'')}} = Z_1 \\sqrt{\\frac{\\mu_r' - j\\mu_r''}{\\varepsilon_r' - j\\varepsilon_r''}}\n$$\n$$\n\\gamma_2(\\omega, \\xi) = j\\omega\\sqrt{\\mu_0\\varepsilon_0 (\\mu_r' - j\\mu_r'')(\\varepsilon_r' - j\\varepsilon_r'')}\n$$\n该公式可以直接用于计算实现。\n\n设计目标涉及处理 $\\xi \\in \\mathcal{U}$ 中的不确定性。我们的任务是通过在厚度 $d \\in [d_{\\min}, d_{\\max}]$ 上进行网格搜索来解决两个优化问题。\n对于每个候选厚度 $d$，不确定性通过反射率函数 $R(\\omega, \\xi, d)$ 进行传播。这是通过将超矩形不确定性集合 $\\mathcal{U}$ 离散化为一个包含 $M$ 个点的均匀网格 $\\{\\xi_i\\}_{i=1}^M$ 来实现的。对于每个 $d$，我们计算一组 $M$ 个反射率值 $\\{R_i(d) = R(\\omega, \\xi_i, d)\\}_{i=1}^M$。\n\n第一个目标是鲁棒或最坏情况设计，旨在最小化不确定性集合上可能的最大反射率：\n$$\n\\min_{d} \\sup_{\\xi \\in \\mathcal{U}} R(\\omega, \\xi, d)\n$$\n在数值上，对于每个 $d$，这被近似为 $\\max_{i} R_i(d)$。然后我们找到使该最大值最小化的厚度 $d_{\\mathrm{robust}}$。\n\n第二个目标使用基于风险的度量，即条件风险价值（CVaR）。对于给定的置信水平 $\\alpha$，$\\mathrm{CVaR}_\\alpha$ 是最差的 $\\alpha \\times 100\\%$ 结果的期望值。目标是：\n$$\n\\min_{d} \\mathrm{CVaR}_\\alpha(d)\n$$\n在数值上，对于每个 $d$，将 $M$ 个反射率值 $\\{R_i(d)\\}$ 按升序排序。设 $k = \\lceil \\alpha M \\rceil$ 为尾部的样本数。$\\mathrm{CVaR}_\\alpha(d)$ 通过 $k$ 个最大反射率值的平均值来近似：\n$$\n\\mathrm{CVaR}_\\alpha(d) \\approx \\frac{1}{k} \\sum_{j=M-k+1}^{M} R_{(j)}(d)\n$$\n其中 $R_{(j)}(d)$ 是排序后的反射率值。然后我们找到使该 CVaR 值最小化的厚度 $d_{\\mathrm{CVaR}}$。\n\n该实现将在指定的 $d$ 值范围内执行网格搜索。对于每个 $d$，它将评估整个不确定参数 $\\xi$ 网格上的反射率，然后计算相应的最坏情况和 CVaR 目标。通过在 $d$ 的网格上寻找最小值，来确定最优厚度及其对应的目标函数值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the robust and CVaR-based design optimization problem for a microwave absorber.\n    \"\"\"\n    \n    # Physical Constants\n    EPS0 = 8.854187817e-12  # F/m\n    MU0 = 4 * np.pi * 1e-7   # H/m\n    Z1 = np.sqrt(MU0 / EPS0) # Impedance of free space in Ohm\n\n    test_cases = [\n        {\n            \"f\": 10e9,\n            \"d_range\": [5e-4, 1e-2], \"d_pts\": 81,\n            \"eps_r_p_range\": [2.0, 2.5], \"eps_r_p_pts\": 9,\n            \"eps_r_pp_range\": [0.05, 0.15], \"eps_r_pp_pts\": 9,\n            \"mu_r_p_range\": [1.0, 1.0], \"mu_r_p_pts\": 1,\n            \"mu_r_pp_range\": [0.0, 0.05], \"mu_r_pp_pts\": 7,\n            \"alpha\": 0.1\n        },\n        {\n            \"f\": 2e9,\n            \"d_range\": [1e-3, 5e-2], \"d_pts\": 81,\n            \"eps_r_p_range\": [1.5, 1.6], \"eps_r_p_pts\": 7,\n            \"eps_r_pp_range\": [0.5, 0.8], \"eps_r_pp_pts\": 7,\n            \"mu_r_p_range\": [1.0, 1.05], \"mu_r_p_pts\": 5,\n            \"mu_r_pp_range\": [0.0, 0.2], \"mu_r_pp_pts\": 7,\n            \"alpha\": 0.2\n        },\n        {\n            \"f\": 6e9,\n            \"d_range\": [1e-4, 5e-3], \"d_pts\": 101,\n            \"eps_r_p_range\": [0.95, 1.05], \"eps_r_p_pts\": 11,\n            \"eps_r_pp_range\": [0.0, 0.02], \"eps_r_pp_pts\": 5,\n            \"mu_r_p_range\": [0.95, 1.05], \"mu_r_p_pts\": 11,\n            \"mu_r_pp_range\": [0.0, 0.02], \"mu_r_pp_pts\": 5,\n            \"alpha\": 0.1\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Unpack case parameters\n        f = case[\"f\"]\n        d_min, d_max = case[\"d_range\"]\n        d_pts = case[\"d_pts\"]\n        \n        eps_r_p_min, eps_r_p_max = case[\"eps_r_p_range\"]\n        eps_r_p_pts = case[\"eps_r_p_pts\"]\n        eps_r_pp_min, eps_r_pp_max = case[\"eps_r_pp_range\"]\n        eps_r_pp_pts = case[\"eps_r_pp_pts\"]\n        mu_r_p_min, mu_r_p_max = case[\"mu_r_p_range\"]\n        mu_r_p_pts = case[\"mu_r_p_pts\"]\n        mu_r_pp_min, mu_r_pp_max = case[\"mu_r_pp_range\"]\n        mu_r_pp_pts = case[\"mu_r_pp_pts\"]\n        \n        alpha = case[\"alpha\"]\n        omega = 2 * np.pi * f\n\n        # Create parameter grids\n        d_values = np.linspace(d_min, d_max, d_pts)\n        \n        eps_r_p_grid = np.linspace(eps_r_p_min, eps_r_p_max, eps_r_p_pts)\n        eps_r_pp_grid = np.linspace(eps_r_pp_min, eps_r_pp_max, eps_r_pp_pts)\n        mu_r_p_grid = np.linspace(mu_r_p_min, mu_r_p_max, mu_r_p_pts)\n        mu_r_pp_grid = np.linspace(mu_r_pp_min, mu_r_pp_max, mu_r_pp_pts)\n\n        # Create mesh grid of uncertain parameters xi = (eps_r', eps_r'', mu_r', mu_r'')\n        xi_mesh = np.meshgrid(eps_r_p_grid, eps_r_pp_grid, mu_r_p_grid, mu_r_pp_grid, indexing='ij')\n        \n        # Flatten and stack to get a list of M parameter vectors\n        xi_params = np.stack([grid.ravel() for grid in xi_mesh], axis=-1)\n        eps_r_p_vec, eps_r_pp_vec, mu_r_p_vec, mu_r_pp_vec = xi_params.T\n\n        # Get total number of uncertainty points\n        M = xi_params.shape[0]\n\n        # Calculate complex relative material properties for all xi points\n        eps_r_complex = eps_r_p_vec - 1j * eps_r_pp_vec\n        mu_r_complex = mu_r_p_vec - 1j * mu_r_pp_vec\n\n        # Calculate slab intrinsic properties for all xi points\n        Z2 = Z1 * np.sqrt(mu_r_complex / eps_r_complex)\n        gamma2 = 1j * omega * np.sqrt(MU0 * EPS0 * mu_r_complex * eps_r_complex)\n\n        robust_objectives = []\n        cvar_objectives = []\n\n        # Grid search over thickness d\n        for d in d_values:\n            # Calculate input impedance for current d, vectorized over all xi\n            Z_in = Z2 * np.tanh(gamma2 * d)\n            \n            # Calculate reflection coefficient and power reflectance\n            Gamma = (Z_in - Z1) / (Z_in + Z1)\n            R_values = np.abs(Gamma)**2\n            \n            # 1. Robust (worst-case) objective\n            sup_R = np.max(R_values)\n            robust_objectives.append(sup_R)\n            \n            # 2. CVaR objective\n            k = int(np.ceil(alpha * M))\n            if k > 0:\n                # Sort reflectance values and average the k largest ones\n                R_sorted = np.sort(R_values)\n                cvar_val = np.mean(R_sorted[-k:])\n            else: # Handle k=0 case, although alpha in (0,1) prevents this\n                R_sorted = np.sort(R_values)\n                cvar_val = R_sorted[-1]\n            cvar_objectives.append(cvar_val)\n\n        # Find optimal thickness for robust design\n        min_robust_idx = np.argmin(robust_objectives)\n        d_robust = d_values[min_robust_idx]\n        R_worst = robust_objectives[min_robust_idx]\n\n        # Find optimal thickness for CVaR design\n        min_cvar_idx = np.argmin(cvar_objectives)\n        d_cvar = d_values[min_cvar_idx]\n        CVaR_val = cvar_objectives[min_cvar_idx]\n        \n        results.extend([d_robust, R_worst, d_cvar, CVaR_val])\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3358413"}]}