{"hands_on_practices": [{"introduction": "本练习将聚焦于体积分方程的核心计算挑战：离散化后产生的稠密矩阵。我们将探索在均匀网格上，如何利用积分算子 $\\mathcal{T}$ 的卷积结构，通过快速傅里叶变换（FFT）实现计算的巨大加速。这项练习是开发大规模散射问题高效求解器的基础。[@problem_id:3295446]", "problem": "给定均匀背景中的时谐场的标量对比源积分方程，它可以写成如下的 Lippmann–Schwinger 形式。令 $E(\\mathbf{r})$ 表示电场的一个标量化分量，$E_{\\text{inc}}(\\mathbf{r})$ 表示入射场，$\\chi(\\mathbf{r})$ 表示对比度，$G_k(\\mathbf{r})$ 表示波数为 $k$ 的标量 Helmholtz 算子的自由空间格林函数。定义对比源 $w(\\mathbf{r}) = \\chi(\\mathbf{r}) E(\\mathbf{r})$。总场满足 $E(\\mathbf{r}) = E_{\\text{inc}}(\\mathbf{r}) + \\mathcal{T}[w](\\mathbf{r})$，其中体积积分算子为\n$$\n\\mathcal{T}[w](\\mathbf{r}) = \\int_{\\mathbb{R}^3} G_k(\\mathbf{r} - \\mathbf{r}')\\,w(\\mathbf{r}')\\,\\mathrm{d}\\mathbf{r}'.\n$$\n考虑在一个具有 $N_x \\times N_y \\times N_z$ 个体素的有限矩形网格上进行均匀的基于体素的离散化，体素边长为 $a$（所有量均为无量纲），采样点位于体素中心。将 $w(\\mathbf{r})$ 近似为每个体素内的分段常数。出于数值计算的目的，采用一个正则化的离散核，其中对于非零偏移向量 $\\mathbf{d} = (d_x,d_y,d_z)$ 且 $d_\\ell \\in \\mathbb{Z}$，离散核为\n$$\nh[\\mathbf{d}] = a^3 \\, G_k\\!\\left(a\\sqrt{d_x^2 + d_y^2 + d_z^2}\\right),\n$$\n而对于 $\\mathbf{d} = \\mathbf{0}$，使用一个有限的正则化值\n$$\nh[\\mathbf{0}] = a^3 \\, G_k(r_c),\n$$\n其中正则化半径为固定的 $r_c = \\alpha a$，标量 $\\alpha = 0.5$。使用三维标量自由空间 Helmholtz 格林函数，\n$$\nG_k(r) = \\frac{e^{\\mathrm{i} k r}}{4\\pi r} \\quad \\text{for} \\quad r  0,\n$$\n并在 $r=0$ 处使用上述正则化值。用 $\\Omega = \\{0,\\dots,N_x-1\\}\\times\\{0,\\dots,N_y-1\\}\\times\\{0,\\dots,N_z-1\\}$ 表示体素的索引集。在该网格上，对应于 $\\mathcal{T}$ 且在域外进行齐次零扩展的离散算子为\n$$\n(\\mathbf{T}\\mathbf{w})[\\mathbf{i}] = \\sum_{\\mathbf{j}\\in\\Omega} h[\\mathbf{i}-\\mathbf{j}]\\,\\mathbf{w}[\\mathbf{j}], \\quad \\mathbf{i}\\in\\Omega,\n$$\n这是一个限制在有限域上的多维线性卷积。\n\n任务部分 A（推导要求）：从上述定义出发，推导对于均匀体素且离散核 $h$ 仅依赖于索引差的情况，算子 $\\mathbf{T}$ 是一个在有限域上的三维线性卷积。解释零填充和周期性嵌入如何将线性卷积转换为可通过快速傅里叶变换 (FFT) 计算而无混叠的循环卷积。特别地，证明如果 $h$ 的支撑集大小为 $(2N_x-1)\\times(2N_y-1)\\times(2N_z-1)$，那么选择填充大小\n$$\nL_x = 3N_x - 2,\\quad L_y = 3N_y - 2,\\quad L_z = 3N_z - 2,\n$$\n并通过模索引映射将 $h$ 嵌入到 $L_x\\times L_y\\times L_z$ 网格上的循环核 $\\tilde{h}$ 中，\n$$\n\\tilde{h}[p,q,r] = h\\big[\\big((p \\bmod L_x)- (N_x-1),\\, (q \\bmod L_y)- (N_y-1),\\, (r \\bmod L_z)- (N_z-1)\\big)\\big],\n$$\n将导致\n$$\n\\mathcal{F}^{-1}\\Big(\\mathcal{F}(\\tilde{h}) \\odot \\mathcal{F}(\\tilde{w})\\Big)\n$$\n成为一个循环卷积，其中心子块恢复了在 $\\Omega$ 上的线性卷积 $\\mathbf{T}\\mathbf{w}$。其中 $\\odot$ 表示逐元素乘法，$\\mathcal{F}$ 是在填充网格上的离散傅里叶变换，$\\tilde{w}$ 是将 $w$ 零填充至相同大小的结果。明确指出必须提取哪个中心子块的索引才能获得 $(\\mathbf{T}\\mathbf{w})[\\mathbf{i}]$。\n\n任务部分 B（算法设计）：为矩阵-向量积 $\\mathbf{y}=\\mathbf{T}\\mathbf{w}$ 实现两个例程：\n- 一种直接法，通过对每个 $\\mathbf{i}\\in\\Omega$ 使用核 $h[\\mathbf{i}-\\mathbf{j}]$ 对 $\\mathbf{j}\\in\\Omega$ 进行字面上的三重求和来计算线性卷积。\n- 一种 FFT 加速方法，该方法：\n  1. 在其差分索引支撑集上构建离散核 $h$，\n  2. 通过模索引映射将其嵌入到上述定义的填充网格大小 $(L_x,L_y,L_z)$ 上的循环核 $\\tilde{h}$ 中，\n  3. 将 $\\mathbf{w}$ 零填充至大小 $(L_x,L_y,L_z)$，\n  4. 使用三维 FFT 计算循环卷积，以及\n  5. 提取正确的中心子块以恢复在 $\\Omega$ 上的 $\\mathbf{y}=\\mathbf{T}\\mathbf{w}$。\n\n任务部分 C（迭代 CSIE 上下文）：考虑与对比源积分方程更新相关的不动点迭代\n$$\n\\mathbf{w}^{(n+1)} = \\boldsymbol{\\chi}\\,\\odot\\Big(\\mathbf{E}_{\\text{inc}} + \\mathbf{T}\\mathbf{w}^{(n)}\\Big),\n$$\n其中 $\\boldsymbol{\\chi}$ 和 $\\mathbf{E}_{\\text{inc}}$ 是在 $\\Omega$ 上的数组，$\\odot$ 表示逐元素乘法。使用直接法和 FFT 加速法两种矩阵-向量积方法计算 $\\mathbf{T}$，从 $\\mathbf{w}^{(0)}=\\mathbf{0}$ 开始运行固定次数 $J$ 的迭代，并比较结果。\n\n测试套件与要求输出：使用以下三个测试用例。所有量均为无量纲。对于每个测试用例：\n- 使用上述的体素大小 $a$ 和波数 $k$，以及 $\\alpha=0.5$ 来构建核。\n- 为了进行单次矩阵-向量积测试，使用固定的随机种子 $s$ 生成复数值的 $\\mathbf{w}$ 以保证可复现性；生成实数值的 $\\boldsymbol{\\chi}$；生成复数值的 $\\mathbf{E}_{\\text{inc}}$。每个测试用例使用相同的种子 $s$ 来确定性地生成这些数组。\n- 计算两个标量：\n  1. 直接法与 FFT 加速法所得 $\\mathbf{T}\\mathbf{w}$ 结果之间的最大逐项绝对差，即 $\\max_{\\mathbf{i}\\in\\Omega} \\left| (\\mathbf{T}\\mathbf{w})_{\\text{direct}}[\\mathbf{i}] - (\\mathbf{T}\\mathbf{w})_{\\text{FFT}}[\\mathbf{i}] \\right|$。\n  2. 经过 $J$ 次不动点迭代后，直接法与 FFT 加速法所得结果之间的最大逐项绝对差，即 $\\max_{\\mathbf{i}\\in\\Omega} \\left| \\mathbf{w}^{(J)}_{\\text{direct}}[\\mathbf{i}] - \\mathbf{w}^{(J)}_{\\text{FFT}}[\\mathbf{i}] \\right|$。\n\n测试用例：\n- 用例 1：$(N_x,N_y,N_z)=(1,1,1)$，$a=1.0$，$k=1.0$，$J=5$，种子 $s=123$。\n- 用例 2：$(N_x,N_y,N_z)=(3,3,3)$，$a=0.5$，$k=2.0$，$J=5$，种子 $s=456$。\n- 用例 3：$(N_x,N_y,N_z)=(4,3,2)$，$a=0.4$，$k=1.3$，$J=7$，种子 $s=789$。\n\n最终输出格式：你的程序应生成包含一个结果列表的单行输出，每个结果对应一个测试用例，其中每个结果是一个双元素列表 $[\\varepsilon_{\\text{mv}},\\varepsilon_{\\text{it}}]$，包含上述定义的两个标量，格式严格如下所示的 Python 列表字面量格式：\n$$\n[\\,[\\varepsilon_{\\text{mv},1},\\varepsilon_{\\text{it},1}],\\,[\\varepsilon_{\\text{mv},2},\\varepsilon_{\\text{it},2}],\\,[\\varepsilon_{\\text{mv},3},\\varepsilon_{\\text{it},3}]\\,].\n$$\n无需单位，所有角度（如有）均理解为弧度。必须按规定将输出打印在单行上。", "solution": "该问题要求对计算电磁学中有关对比源积分方程 (CSIE) 的一个数值任务进行验证并随后求解。该任务涉及推导离散线性卷积与其快速傅里叶变换 (FFT) 加速对应方法之间的关系，实现这两种方法，并在一个不动点迭代方案中比较它们的结果。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- **控制方程**：标量 Lippmann-Schwinger 方程为 $E(\\mathbf{r}) = E_{\\text{inc}}(\\mathbf{r}) + \\mathcal{T}[w](\\mathbf{r})$，其中对比源为 $w(\\mathbf{r}) = \\chi(\\mathbf{r}) E(\\mathbf{r})$。\n- **积分算子**：$\\mathcal{T}[w](\\mathbf{r}) = \\int_{\\mathbb{R}^3} G_k(\\mathbf{r} - \\mathbf{r}')\\,w(\\mathbf{r}')\\,\\mathrm{d}\\mathbf{r}'$。\n- **格林函数**：对于 $r  0$，有 $G_k(r) = \\frac{e^{\\mathrm{i} k r}}{4\\pi r}$。\n- **离散化**：一个大小为 $N_x \\times N_y \\times N_z$ 的均匀体素网格，边长为 $a$。\n- **离散核**：对于非零整数索引偏移 $\\mathbf{d}=(d_x,d_y,d_z)$，$h[\\mathbf{d}] = a^3 \\, G_k\\!\\left(a\\sqrt{d_x^2 + d_y^2 + d_z^2}\\right)$。\n- **正则化自项**：对于 $\\mathbf{d}=\\mathbf{0}$，$h[\\mathbf{0}] = a^3 \\, G_k(r_c)$，其中正则化半径 $r_c = \\alpha a$ 且 $\\alpha = 0.5$。\n- **离散卷积算子**：$(\\mathbf{T}\\mathbf{w})[\\mathbf{i}] = \\sum_{\\mathbf{j}\\in\\Omega} h[\\mathbf{i}-\\mathbf{j}]\\,\\mathbf{w}[\\mathbf{j}]$，其中 $\\Omega = \\{0,\\dots,N_x-1\\}\\times\\{0,\\dots,N_y-1\\}\\times\\{0,\\dots,N_z-1\\}$。\n- **FFT 填充网格大小**：对于 $\\ell \\in \\{x,y,z\\}$，$L_\\ell = 3N_\\ell - 2$。\n- **循环核嵌入**：$\\tilde{h}[p,q,r] = h\\big[\\big((p \\bmod L_x)- (N_x-1),\\, (q \\bmod L_y)- (N_y-1),\\, (r \\bmod L_z)- (N_z-1)\\big)\\big]$。\n- **不动点迭代**：$\\mathbf{w}^{(n+1)} = \\boldsymbol{\\chi}\\,\\odot\\Big(\\mathbf{E}_{\\text{inc}} + \\mathbf{T}\\mathbf{w}^{(n)}\\Big)$，从 $\\mathbf{w}^{(0)}=\\mathbf{0}$ 开始，进行 $J$ 次迭代。\n- **测试用例**：\n    - 用例 1：$(N_x,N_y,N_z)=(1,1,1)$，$a=1.0$，$k=1.0$，$J=5$，种子 $s=123$。\n    - 用例 2：$(N_x,N_y,N_z)=(3,3,3)$，$a=0.5$，$k=2.0$，$J=5$，种子 $s=456$。\n    - 用例 3：$(N_x,N_y,N_z)=(4,3,2)$，$a=0.4$，$k=1.3$，$J=7$，种子 $s=789$。\n- **输出**：对每个用例，计算 $\\varepsilon_{\\text{mv}} = \\max_{\\mathbf{i}\\in\\Omega} | (\\mathbf{T}\\mathbf{w})_{\\text{direct}}[\\mathbf{i}] - (\\mathbf{T}\\mathbf{w})_{\\text{FFT}}[\\mathbf{i}] |$ 和 $\\varepsilon_{\\text{it}} = \\max_{\\mathbf{i}\\in\\Omega} | \\mathbf{w}^{(J)}_{\\text{direct}}[\\mathbf{i}] - \\mathbf{w}^{(J)}_{\\text{FFT}}[\\mathbf{i}] |$。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题在科学上基于波散射原理和积分方程数值方法，这在计算物理和工程领域是标准内容。该问题的表述是适定的，为获得唯一的数值解提供了所有必要的定义和参数。语言客观精确。该问题是可形式化的，并与其所述主题直接相关。问题设定是自洽且一致的；所选的填充大小对于避免基于 FFT 的卷积中的混叠是正确的。对于给定的参数，数值任务是可行的。结构是逻辑的，从理论推导引导到实现和比较。在验证清单中未发现任何缺陷。\n\n**第 3 步：结论与行动**\n该问题是有效的。将提供一个完整的解决方案。\n\n### 解决方案\n\n解决方案按规定分为三部分：推导、算法设计和迭代上下文描述。\n\n**部分 A：基于 FFT 卷积的推导**\n\n离散算子 $\\mathbf{T}$ 定义为 $(\\mathbf{T}\\mathbf{w})[\\mathbf{i}] = \\sum_{\\mathbf{j}\\in\\Omega} h[\\mathbf{i}-\\mathbf{j}]\\,\\mathbf{w}[\\mathbf{j}]$，其中 $\\mathbf{i} \\in \\Omega$。这是核 $h$ 与离散源 $\\mathbf{w}$ 的三维线性卷积的定义，其输出被限制在输出域 $\\Omega$ 上。核 $h[\\mathbf{d}]$ 仅依赖于索引的差值 $\\mathbf{d} = \\mathbf{i} - \\mathbf{j}$。当 $\\mathbf{i}$ 和 $\\mathbf{j}$ 在 $\\Omega=\\{0,\\dots,N_x-1\\}\\times\\dots$ 上取值时，差分向量 $\\mathbf{d}$ 的分量范围对于第一维是 $-(N_x-1)$ 到 $N_x-1$，其他维度类似。因此，核 $h$ 的支撑集大小为 $(2N_x-1) \\times (2N_y-1) \\times (2N_z-1)$。\n\n卷积定理指出，循环卷积可以在傅里叶域中通过逐元素乘法高效计算。要使用 FFT 计算线性卷积，我们必须将问题嵌入一个更大的周期域中，使得在该域中线性和循环卷积等价。这需要对信号和核都进行零填充，填充后的大小要足以防止回卷误差（混叠）。一个大小为 $N_x$ 的信号与一个大小为 $M_x = 2N_x-1$ 的核的完整线性卷积，其输出大小为 $N_x+M_x-1 = N_x+(2N_x-1)-1 = 3N_x-2$。问题正确地指定了每个维度的填充大小为 $L_\\ell = 3N_\\ell - 2$。\n\n我们来分析指定的将核 $h$ 嵌入到大小为 $L_x \\times L_y \\times L_z$ 的填充网格上的循环核 $\\tilde{h}$ 的方式。为清晰起见，我们考虑一维情况。$\\tilde{h}$ 的索引 $p$ 的范围是 $0$ 到 $L_x-1$。在此范围内，$p \\bmod L_x = p$。公式变为 $\\tilde{h}[p] = h[p - (N_x-1)]$。$h$ 的自变量，我们称之为 $d_x = p - (N_x-1)$，其范围从 $-(N_x-1)$ 到 $L_x-1-(N_x-1) = (3N_x-2)-1-(N_x-1) = 2N_x-2$。然而，核 $h[d_x]$ 仅在 $d_x \\in [-(N_x-1), N_x-1]$ 时非零。这对应于 $p \\in [0, 2N_x-2]$。\n基于 FFT 的计算产生循环卷积 $C[\\mathbf{i}] = (\\tilde{h} \\circledast \\tilde{w})[\\mathbf{i}]$，其中 $\\tilde{w}$ 是源数组 $\\mathbf{w}$ 零填充到大小 $L_x \\times L_y \\times L_z$ 的结果。我们来分析一维情况下的结果：\n$$ C[i] = \\sum_{j=0}^{L_x-1} \\tilde{h}[(i-j)\\pmod{L_x}] \\tilde{w}[j] $$\n因为 $\\tilde{w}[j]$ 仅在 $j \\in [0, N_x-1]$ 时非零，所以求和简化为：\n$$ C[i] = \\sum_{j=0}^{N_x-1} \\tilde{h}[(i-j)\\pmod{L_x}] w[j] $$\n代入 $\\tilde{h}$ 的定义：\n$$ C[i] = \\sum_{j=0}^{N_x-1} h\\left[\\left((i-j)\\pmod{L_x}\\right) - (N_x-1)\\right] w[j] $$\n我们希望恢复线性卷积 $(\\mathbf{T}\\mathbf{w})[k] = \\sum_{j=0}^{N_x-1} h[k-j]w[j]$，对于 $k \\in [0, N_x-1]$。\n我们选择输出索引 $i$ 在范围 $[N_x-1, 2N_x-2]$。对于这样的 $i$ 和 $j \\in [0, N_x-1]$，有 $i-j \\in [0, 2N_x-2]$。因此 $(i-j)\\pmod{L_x} = i-j$。\n则 $C[i] = \\sum_{j=0}^{N_x-1} h[i-j-(N_x-1)] w[j]$。\n令 $k = i-(N_x-1)$。当 $i$ 在 $[N_x-1, 2N_x-2]$ 中时，$k$ 在 $[0, N_x-1]$ 中。\n这样 $C[k+(N_x-1)] = \\sum_{j=0}^{N_x-1} h[k-j] w[j] = (\\mathbf{T}\\mathbf{w})[k]$。\n这意味着所需的线性卷积结果 $(\\mathbf{T}\\mathbf{w})[\\mathbf{k}]$ 对于 $\\mathbf{k} \\in \\Omega$，位于循环卷积输出的索引为 $\\mathbf{i} = \\mathbf{k} + (N_x-1, N_y-1, N_z-1)$ 的位置。\n因此，要获得对于 $\\mathbf{i} \\in \\Omega$ 的 $(\\mathbf{T}\\mathbf{w})[\\mathbf{i}]$，必须从 IFFT 结果中提取从索引 $(N_x-1, N_y-1, N_z-1)$ 到 $(2N_x-2, 2N_y-2, 2N_z-2)$（包含边界）的子数组。\n\n**部分 B：算法设计**\n\n为矩阵-向量积 $\\mathbf{y}=\\mathbf{T}\\mathbf{w}$ 设计了两种算法。\n\n1.  **直接法**：此方法字面上实现离散卷积和。对于域 $\\Omega$ 中的每个输出点 $\\mathbf{i}=(i_x, i_y, i_z)$，通过对域 $\\Omega$ 中所有源点 $\\mathbf{j}=(j_x, j_y, j_z)$ 的贡献求和来计算值 $\\mathbf{y}[\\mathbf{i}]$。\n    $$ \\mathbf{y}[i_x, i_y, i_z] = \\sum_{j_x=0}^{N_x-1} \\sum_{j_y=0}^{N_y-1} \\sum_{j_z=0}^{N_z-1} h[i_x-j_x, i_y-j_y, i_z-j_z]\\, \\mathbf{w}[j_x, j_y, j_z] $$\n    核值 $h[\\mathbf{d}]$ 可以即时计算，也可以为所有可能的差分向量 $\\mathbf{d}$ 预先计算。这涉及到一个六重嵌套循环，导致计算复杂度为 $O((N_x N_y N_z)^2)$，对于大网格而言是不可行的。\n\n2.  **FFT 加速方法**：此方法利用卷积定理，包含五个步骤：\n    1.  **构建离散核**：为所有差分索引 $d_\\ell \\in [-(N_\\ell-1), N_\\ell-1]$ 预先计算核值 $h[\\mathbf{d}]$。这些值可以存储在一个大小为 $(2N_x-1) \\times (2N_y-1) \\times (2N_z-1)$ 的 3D 数组中，以便高效查找。\n    2.  **嵌入到循环核中**：创建一个大小为 $(L_x, L_y, L_z)$ 的复数值数组 $\\tilde{\\mathbf{h}}$。根据规则 $\\tilde{h}[p,q,r] = h[p-(N_x-1), q-(N_y-1), r-(N_z-1)]$ 填充该数组，其中 $(p,q,r)$ 使得其参数在 $h$ 的支撑集内；否则 $\\tilde{h}[p,q,r] = 0$。\n    3.  **对源进行零填充**：创建一个大小为 $(L_x, L_y, L_z)$ 的复数值数组 $\\tilde{\\mathbf{w}}$。将源数组 $\\mathbf{w}$ 复制到对应于索引 $[0, N_x-1]\\times[0, N_y-1]\\times[0, N_z-1]$ 的子块中，并将 $\\tilde{\\mathbf{w}}$ 的其余元素设置为零。\n    4.  **通过 FFT 计算循环卷积**：执行以下傅里叶域操作：\n        -   使用 3D FFT 计算 $\\tilde{\\mathbf{H}} = \\mathcal{F}(\\tilde{\\mathbf{h}})$。\n        -   使用 3D FFT 计算 $\\tilde{\\mathbf{W}} = \\mathcal{F}(\\tilde{\\mathbf{w}})$。\n        -   $\\tilde{\\mathbf{Y}} = \\tilde{\\mathbf{H}} \\odot \\tilde{\\mathbf{W}}$（逐元素乘积）。\n        -   使用 3D 逆 FFT 计算 $\\tilde{\\mathbf{y}} = \\mathcal{F}^{-1}(\\tilde{\\mathbf{Y}})$。\n    5.  **提取结果**：通过提取 $\\tilde{\\mathbf{y}}$ 中对应于索引范围 $[N_x-1:2N_x-1]$、$[N_y-1:2N_y-1]$ 和 $[N_z-1:2N_z-1]$ 的子数组，获得最终结果 $\\mathbf{y} = \\mathbf{T}\\mathbf{w}$。复杂度主要由 FFT 决定，为 $O(L_x L_y L_z \\log(L_x L_y L_z))$。\n\n**部分 C：迭代 CSIE 上下文**\n\n不动点迭代根据以下规则更新对比源 $\\mathbf{w}$：\n$$ \\mathbf{w}^{(n+1)} = \\boldsymbol{\\chi}\\,\\odot\\Big(\\mathbf{E}_{\\text{inc}} + \\mathbf{T}\\mathbf{w}^{(n)}\\Big) $$\n从初始猜测 $\\mathbf{w}^{(0)} = \\mathbf{0}$ 开始，此更新规则应用 $J$ 次。每次迭代的核心是矩阵-向量积 $\\mathbf{T}\\mathbf{w}^{(n)}$。我们实现这个迭代求解器的两个版本：一个使用直接卷积计算 $\\mathbf{T}$，另一个使用 FFT 加速方法。经过 $J$ 次迭代后，比较最终的数组 $\\mathbf{w}^{(J)}_{\\text{direct}}$ 和 $\\mathbf{w}^{(J)}_{\\text{FFT}}$。由有限精度算术引起的直接法和 FFT 法矩阵-向量积之间的任何差异，都可能在迭代过程中被放大或减小，这取决于算子的性质。对最终迭代结果的比较可以洞察在这个迭代上下文中使用基于 FFT 的求解器的数值稳定性。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import fftn, ifftn\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # ((Nx, Ny, Nz), a, k, J, seed)\n        ((1, 1, 1), 1.0, 1.0, 5, 123),\n        ((3, 3, 3), 0.5, 2.0, 5, 456),\n        ((4, 3, 2), 0.4, 1.3, 7, 789),\n    ]\n\n    results = []\n    for case in test_cases:\n        dims, a, k, J, seed = case\n        Nx, Ny, Nz = dims\n\n        # Generate problem data using the specified seed\n        rng = np.random.default_rng(seed)\n        shape = (Nx, Ny, Nz)\n        w_test = rng.random(shape, dtype=np.float64) + 1j * rng.random(shape, dtype=np.float64)\n        chi = rng.random(shape, dtype=np.float64)\n        E_inc = rng.random(shape, dtype=np.float64) + 1j * rng.random(shape, dtype=np.float64)\n\n        # 1. Compare direct and FFT-based matrix-vector products\n        h_kernel = build_h_kernel(Nx, Ny, Nz, a, k, alpha=0.5)\n        \n        y_direct = matvec_direct(w_test, h_kernel, Nx, Ny, Nz)\n        y_fft = matvec_fft(w_test, h_kernel, Nx, Ny, Nz)\n        \n        eps_mv = np.max(np.abs(y_direct - y_fft))\n\n        # 2. Compare direct and FFT-based iterative solvers\n        def matvec_direct_func(w_in):\n            return matvec_direct(w_in, h_kernel, Nx, Ny, Nz)\n        \n        def matvec_fft_func(w_in):\n            return matvec_fft(w_in, h_kernel, Nx, Ny, Nz)\n\n        w_final_direct = csie_iterate(E_inc, chi, J, matvec_direct_func)\n        w_final_fft = csie_iterate(E_inc, chi, J, matvec_fft_func)\n\n        eps_it = np.max(np.abs(w_final_direct - w_final_fft))\n        \n        results.append([eps_mv, eps_it])\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef green_function(r, k):\n    \"\"\"Computes the 3D scalar Helmholtz Green's function.\"\"\"\n    if r == 0:\n        # This case should be handled by the regularized self-term, but as a fallback.\n        return np.inf\n    return np.exp(1j * k * r) / (4 * np.pi * r)\n\ndef build_h_kernel(Nx, Ny, Nz, a, k, alpha=0.5):\n    \"\"\"\n    Pre-computes and stores the discrete convolution kernel h[d].\n    Returns a dictionary mapping index difference (dx,dy,dz) to kernel value.\n    \"\"\"\n    h = {}\n    rc = alpha * a\n    \n    for dx in range(-(Nx - 1), Nx):\n        for dy in range(-(Ny - 1), Ny):\n            for dz in range(-(Nz - 1), Nz):\n                d = (dx, dy, dz)\n                if d == (0, 0, 0):\n                    # Regularized self-term\n                    val = a**3 * green_function(rc, k)\n                else:\n                    dist = a * np.sqrt(dx**2 + dy**2 + dz**2)\n                    val = a**3 * green_function(dist, k)\n                h[d] = val\n    return h\n\ndef matvec_direct(w, h_kernel, Nx, Ny, Nz):\n    \"\"\"Computes y = T*w using direct summation.\"\"\"\n    y = np.zeros((Nx, Ny, Nz), dtype=np.complex128)\n    for ix in range(Nx):\n        for iy in range(Ny):\n            for iz in range(Nz):\n                acc = 0.0j\n                for jx in range(Nx):\n                    for jy in range(Ny):\n                        for jz in range(Nz):\n                            dx, dy, dz = ix - jx, iy - jy, iz - jz\n                            acc += h_kernel[(dx, dy, dz)] * w[jx, jy, jz]\n                y[ix, iy, iz] = acc\n    return y\n\ndef matvec_fft(w, h_kernel, Nx, Ny, Nz):\n    \"\"\"Computes y = T*w using FFT-based convolution.\"\"\"\n    Lx, Ly, Lz = 3 * Nx - 2, 3 * Ny - 2, 3 * Nz - 2\n    padded_shape = (Lx, Ly, Lz)\n\n    # Embed kernel h into the circulant kernel h_tilde on the padded grid\n    h_tilde = np.zeros(padded_shape, dtype=np.complex128)\n    for p in range(Lx):\n        for q in range(Ly):\n            for r in range(Lz):\n                # Calculate difference indices according to the problem's formula\n                dx = p - (Nx - 1)\n                dy = q - (Ny - 1)\n                dz = r - (Nz - 1)\n                \n                # Check if the difference index is in the pre-computed kernel's support\n                if (dx, dy, dz) in h_kernel:\n                    h_tilde[p, q, r] = h_kernel[(dx, dy, dz)]\n\n    # Zero-pad the source array w\n    w_tilde = np.zeros(padded_shape, dtype=np.complex128)\n    w_tilde[0:Nx, 0:Ny, 0:Nz] = w\n\n    # Compute convolution in the Fourier domain\n    H_tilde = fftn(h_tilde)\n    W_tilde = fftn(w_tilde)\n    Y_tilde = H_tilde * W_tilde\n    y_tilde = ifftn(Y_tilde)\n\n    # Extract the correct central sub-block\n    y = y_tilde[Nx-1 : 2*Nx-1, Ny-1 : 2*Ny-1, Nz-1 : 2*Nz-1]\n\n    return y\n\ndef csie_iterate(E_inc, chi, J, matvec_func):\n    \"\"\"Performs J fixed-point iterations for the CSIE.\"\"\"\n    shape = E_inc.shape\n    w = np.zeros(shape, dtype=np.complex128)\n    for _ in range(J):\n        T_w = matvec_func(w)\n        w = chi * (E_inc + T_w)\n    return w\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3295446"}, {"introduction": "迭代法是处理对比源积分方程（CSIE）产生的大型线性系统的关键，但其收敛速度可能很慢。本练习将引入预处理技术以加速收敛。通过构建一个基于算子自作用项的简单对角预条件子，您将定量分析其对系统谱特性的影响，并深入理解如何提升求解器的性能。[@problem_id:3295386]", "problem": "考虑一个有限区间上的一维标量亥姆霍兹散射问题，其中总场 $u(x)$ 满足 Lippmann–Schwinger 体积分方程\n$$\nu(x) = u^{\\mathrm{inc}}(x) + \\int_{D} G_k\\!\\left(\\lvert x - x' \\rvert\\right) \\, w(x') \\, \\mathrm{d}x',\n$$\n对于 $x \\in D$，其中衬度源 $w(x) = \\chi(x) u(x)$，一维亥姆霍兹算子的自由空间格林函数由下式给出\n$$\nG_k(r) = \\frac{i}{2k} e^{ik r},\n$$\n其中 $k$ 是波数。衬度 $\\chi(x)$ 假定在 $D$ 上是分段常数。\n\n定义衬度源积分方程算子 $\\mathcal{T}$ 为\n$$\n(\\mathcal{T} w)(x) = \\int_{D} G_k\\!\\left(\\lvert x - x' \\rvert\\right) \\, w(x') \\, \\mathrm{d}x'.\n$$\n在点集 $\\{x_j\\}_{j=0}^{N-1}$ 和求积权重 $\\{w_j\\}_{j=0}^{N-1}$ 的配置离散化下，算子 $\\mathcal{T}$ 由矩阵 $T \\in \\mathbb{C}^{N \\times N}$ 近似，其元素为\n$$\nT_{ij} = G_k\\!\\left(\\lvert x_i - x_j \\rvert\\right) \\, w_j.\n$$\n关于 $w$ 的离散衬度源方程可以写成如下形式\n$$\nA \\, \\mathbf{w} = \\mathbf{b}, \\quad \\text{其中} \\quad A = I - \\chi \\, T,\n$$\n其中 $I$ 是单位矩阵，$\\chi$ 是常数衬度，$\\mathbf{b}$ 由入射场导出。$T$ 的对角线（自相互作用项）为 $T_{ii} = G_k(0)\\, w_i$。\n\n任务：\n1. 从 $T$ 的自相互作用项（对角线）构造一个对角左预条件子 $M$，并形成左预处理算子 $M^{-1} A$。\n2. 通过计算两个定量指标：谱半径和 2-范数条件数，来分析该预条件子对离散化算子谱的影响。具体来说，计算以下比率\n$$\n\\rho_{\\mathrm{ratio}} = \\frac{\\rho(M^{-1} A)}{\\rho(A)}, \\qquad \\kappa_{\\mathrm{ratio}} = \\frac{\\kappa_2(M^{-1} A)}{\\kappa_2(A)},\n$$\n其中 $\\rho(\\cdot)$ 表示谱半径，$\\kappa_2(\\cdot)$ 表示 2-范数条件数。这些比率是无量纲的实值浮点数。\n\n离散化细节：\n- 设区域为 $D = [0, L]$，其长度 $L$ 以米为单位。\n- 使用由 $x_j = L \\, s_j^p$（对于 $j = 0, 1, \\dots, N-1$）定义的非均匀配置网格，其中 $s_j = j/(N-1)$，$p \\ge 1$ 是一个网格分级参数。较大的 $p$ 会增加非均匀性。\n- 求积权重定义如下\n$$\nw_0 = \\frac{1}{2}(x_1 - x_0), \\quad w_{N-1} = \\frac{1}{2}(x_{N-1} - x_{N-2}), \\quad w_j = \\frac{1}{2}(x_{j+1} - x_{j-1}) \\text{ for } j = 1, \\dots, N-2.\n$$\n\n预条件子：\n- 构造对角矩阵 $M \\in \\mathbb{C}^{N \\times N}$，其元素为 $M_{ii} = T_{ii} = G_k(0)\\, w_i$，并形成 $M^{-1} A$。\n\n你的程序必须：\n- 实现上述离散化和算子构造。\n- 计算特征值以获得谱半径，并使用奇异值分解来获得 2-范数条件数。\n- 对于每个测试用例，输出一对浮点数 $(\\kappa_{\\mathrm{ratio}}, \\rho_{\\mathrm{ratio}})$。\n\n单位和输出：\n- $L$ 的单位是米，$k$ 的单位是弧度/米。输出 $(\\kappa_{\\mathrm{ratio}}, \\rho_{\\mathrm{ratio}})$ 是无量纲的，必须打印为浮点数。\n- 任何三角量的角度单位均为弧度。\n\n测试套件：\n为以下四个测试用例 $(N, L, k, \\chi, p)$ 提供计算：\n1. $(64, 1.0, 20.0, 0.5, 1.0)$: 均匀网格基准。\n2. $(64, 1.0, 20.0, 0.5, 2.5)$: 具有相同波数和衬度的强非均匀网格。\n3. $(32, 1.0, 5.0, 2.0, 3.0)$: 在中等非均匀网格上的中等波数和较高衬度。\n4. $(16, 1.0, 0.5, 0.2, 4.0)$: 低波数、低衬度、小型强分级网格。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按测试用例的顺序展平，每个测试用例贡献恰好两个浮点数 $(\\kappa_{\\mathrm{ratio}}, \\rho_{\\mathrm{ratio}})$。例如，输出应如下所示\n$$\n[\\kappa_{\\mathrm{ratio},1}, \\rho_{\\mathrm{ratio},1}, \\kappa_{\\mathrm{ratio},2}, \\rho_{\\mathrm{ratio},2}, \\kappa_{\\mathrm{ratio},3}, \\rho_{\\mathrm{ratio},3}, \\kappa_{\\mathrm{ratio},4}, \\rho_{\\mathrm{ratio},4}].\n$$", "solution": "该问题要求对源于一维标量亥姆霍兹散射问题的离散化衬度源积分方程，分析一个特定的对角预条件子。分析过程涉及计算系统矩阵在预处理前后的谱半径和 2-范数条件数，然后求出它们的比率。\n\n对于每个测试用例 $(N, L, k, \\chi, p)$，解题过程按以下步骤进行：\n\n1.  **区域离散化和求积法则**\n    区域 $D = [0, L]$ 使用一组 $N$ 个配置点 $\\{x_j\\}_{j=0}^{N-1}$ 进行离散化。这些点根据非均匀网格公式 $x_j = L s_j^p$ 生成，其中 $s_j = j/(N-1)$（对于 $j \\in \\{0, 1, \\dots, N-1\\}$），$p \\ge 1$ 是网格分级参数。$p=1$ 对应于均匀网格。\n\n    Lippmann-Schwinger 方程中的积分使用带有权重 $\\{w_j\\}_{j=0}^{N-1}$ 的数值求积法则来近似。权重是基于通用网格的一种类似梯形的法则来定义的：\n    $$\n    w_0 = \\frac{1}{2}(x_1 - x_0)\n    $$\n    $$\n    w_j = \\frac{1}{2}(x_{j+1} - x_{j-1}) \\quad \\text{for } j \\in \\{1, \\dots, N-2\\}\n    $$\n    $$\n    w_{N-1} = \\frac{1}{2}(x_{N-1} - x_{N-2})\n    $$\n    这些权重代表了与每个配置点 $x_j$ 相关联的区间的有效长度。\n\n2.  **系统矩阵 $A$ 的构造**\n    连续积分算子 $\\mathcal{T}$ 被离散化为一个矩阵 $T \\in \\mathbb{C}^{N \\times N}$。$T$ 的元素由 $T_{ij} = G_k(\\lvert x_i - x_j \\rvert) w_j$ 给出，其中 $x_i$ 是观测点，$x_j$ 是源点。亥姆霍兹方程的一维自由空间格林函数为 $G_k(r) = \\frac{i}{2k} e^{ikr}$。\n    \n    离散衬度源方程为 $A \\mathbf{w} = \\mathbf{b}$，其中 $\\mathbf{w}$ 是在配置点上的未知衬度源值 $w(x_j)$ 的向量。系统矩阵 $A \\in \\mathbb{C}^{N \\times N}$ 定义为：\n    $$\n    A = I - \\chi T\n    $$\n    其中 $I$ 是 $N \\times N$ 的单位矩阵，$\\chi$ 是常数衬度。\n\n3.  **预条件子 $M$ 和预处理系统的构造**\n    问题指定了一个从算子 $T$ 的“自相互作用项”构造的对角左预条件子 $M$。自相互作用项对应于矩阵 $T$ 的对角元素。矩阵 $M$ 是一个对角矩阵，其对角元素与 $T$ 的对角元素相同：\n    $$\n    M_{ii} = T_{ii} = G_k(\\lvert x_i - x_i \\rvert) w_i = G_k(0) w_i = \\left(\\frac{i}{2k}\\right) w_i\n    $$\n    并且当 $i \\neq j$ 时 $M_{ij} = 0$。由于 $k0$ 且对于指定的网格所有 $w_i  0$，所有对角元素 $M_{ii}$ 都是非零的。因此，逆矩阵 $M^{-1}$ 存在，并且是一个对角矩阵，其元素为 $(M^{-1})_{ii} = 1/M_{ii}$。\n\n    然后通过在左侧用 $M^{-1}$ 乘以 $A$ 来形成左预处理系统矩阵：\n    $$\n    A_{\\mathrm{prec}} = M^{-1} A = M^{-1}(I - \\chi T)\n    $$\n\n4.  **谱度量和比率的计算**\n    为了分析预条件子的效果，我们为原始矩阵 $A$ 和预处理后的矩阵 $A_{\\mathrm{prec}}$ 计算两个定量指标：\n\n    a.  **谱半径 $\\rho(\\cdot)$**：矩阵的谱半径是其特征值绝对值的最大值。我们计算矩阵的特征值 $\\lambda_j$，并找到 $\\rho = \\max_j |\\lambda_j|$。\n    b.  **2-范数条件数 $\\kappa_2(\\cdot)$**：矩阵的 2-范数条件数是其最大奇异值与最小奇异值之比，即 $\\kappa_2 = \\sigma_{\\max} / \\sigma_{\\min}$。奇异值通过奇异值分解 (SVD) 计算。\n\n    最后，计算这些指标的比率以量化预条件子的有效性：\n    $$\n    \\rho_{\\mathrm{ratio}} = \\frac{\\rho(M^{-1} A)}{\\rho(A)}\n    $$\n    $$\n    \\kappa_{\\mathrm{ratio}} = \\frac{\\kappa_2(M^{-1} A)}{\\kappa_2(A)}\n    $$\n    $\\kappa_{\\mathrm{ratio}}  1$ 的值表示预条件子改善了线性系统的条件，这对于迭代求解器通常是理想的。\n\n实现将对提供的每个测试用例执行这些步骤，使用数值库来执行矩阵构造以及特征值和奇异值分解。最终输出是每个测试用例的 $(\\kappa_{\\mathrm{ratio}}, \\rho_{\\mathrm{ratio}})$ 对的展平列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_ratios(params):\n    \"\"\"\n    Computes spectral radius and condition number ratios for a given parameter set.\n    \"\"\"\n    N, L, k, chi, p = params\n    \n    # 1. Discretization: Grid points and quadrature weights\n    s = np.linspace(0.0, 1.0, N)\n    x = L * s**p\n    \n    w = np.zeros(N, dtype=float)\n    if N > 1:\n        # First point weight\n        w[0] = 0.5 * (x[1] - x[0])\n        # Last point weight\n        w[-1] = 0.5 * (x[-1] - x[-2])\n        # Interior point weights\n        if N > 2:\n            w[1:-1] = 0.5 * (x[2:] - x[:-2])\n    elif N == 1:\n        w[0] = L # A reasonable choice for a single point\n\n    # 2. Green's function\n    def Gk(r):\n        return (1j / (2.0 * k)) * np.exp(1j * k * r)\n\n    # 3. Construct the operator matrix T\n    # Create a matrix of distances |x_i - x_j|\n    x_col = x.reshape(-1, 1)\n    dist_matrix = np.abs(x_col - x)\n    \n    # Evaluate Green's function for all distances\n    Gk_matrix = Gk(dist_matrix)\n    \n    # Construct T by scaling columns by quadrature weights\n    # w is broadcasted to each row of Gk_matrix\n    T = Gk_matrix * w\n\n    # 4. Construct the system matrix A\n    I = np.eye(N, dtype=np.complex128)\n    A = I - chi * T\n\n    # 5. Construct the preconditioner M and preconditioned matrix A_prec\n    # M is a diagonal matrix with M_ii = T_ii\n    T_diag_entries = np.diag(T)\n    # The inverse M_inv is a diagonal matrix with 1/T_ii on its diagonal.\n    # Since k>0 and w_i>0, T_diag_entries are non-zero.\n    M_inv = np.diag(1.0 / T_diag_entries)\n    A_prec = M_inv @ A\n\n    # 6. Compute spectral metrics for A\n    eigvals_A = np.linalg.eigvals(A)\n    rho_A = np.max(np.abs(eigvals_A))\n    s_A = np.linalg.svd(A, compute_uv=False)\n    # Handle potentially singular matrices, though not expected here\n    kappa_A = np.max(s_A) / np.min(s_A) if np.min(s_A) > 1e-15 else np.inf\n\n    # 7. Compute spectral metrics for A_prec\n    eigvals_A_prec = np.linalg.eigvals(A_prec)\n    rho_A_prec = np.max(np.abs(eigvals_A_prec))\n    s_A_prec = np.linalg.svd(A_prec, compute_uv=False)\n    kappa_A_prec = np.max(s_A_prec) / np.min(s_A_prec) if np.min(s_A_prec) > 1e-15 else np.inf\n\n    # 8. Compute the final ratios\n    rho_ratio = rho_A_prec / rho_A if rho_A > 1e-15 else 0.0\n    kappa_ratio = kappa_A_prec / kappa_A if kappa_A > 1e-15 else 0.0\n    \n    return kappa_ratio, rho_ratio\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, k, chi, p)\n        (64, 1.0, 20.0, 0.5, 1.0),\n        (64, 1.0, 20.0, 0.5, 2.5),\n        (32, 1.0, 5.0, 2.0, 3.0),\n        (16, 1.0, 0.5, 0.2, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the result for one case.\n        kappa_ratio, rho_ratio = compute_ratios(case)\n        results.extend([kappa_ratio, rho_ratio])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3295386"}, {"introduction": "对比源公式的真正威力在于其在反演问题中的应用。这项高级练习将指导您实现对比源反演（CSI）算法的单步迭代，这是一种从散射场数据重建物体属性的强大方法。您将推导并实现一个交替最小化方案的正则方程，该方案包含了诸如吉洪诺夫（Tikhonov）正则化和总变差（Total Variation）惩罚等关键技术。[@problem_id:3295387]", "problem": "考虑一个由标量亥姆霍兹方程控制的一维时谐散射问题。设一维自由空间格林函数为 $G(x,x') = -\\mathrm{i}/(2k_0)\\exp(\\mathrm{i}k_0|x-x'|)$，其中角波数为 $k_0$。未知衬度源 $\\mathbf{w}$ 和电纳衬度 $\\chi_e$ 通过总场 $\\mathbf{E} = \\mathbf{E}^{\\mathrm{inc}} + \\mathcal{G}\\mathbf{w}$ 相关联，其中 $\\mathbf{E}^{\\mathrm{inc}}$ 是入射场，$\\mathcal{G}$ 是由格林函数定义的体积积分算子。衬度源反演 (CSI) 方法交替地对 $\\mathbf{w}$ 和 $\\chi_e$ 进行最小化。其复合目标函数由数据失配项和状态一致性项组成，并增加了正则化项。在均匀网格上的离散形式中，使用前向差分计算空间梯度，并对 $\\chi_e$ 使用平滑总变差 (TV) 惩罚项。\n\n从标量亥姆霍兹模型和场的积分表示出发，推导在每个交替步骤中分别针对 $\\mathbf{w}$ 和 $\\chi_e$ 求解的正规方程，此时目标泛函是数据失配的平方和与状态一致性失配的平方和之和，并增加了对 $\\mathbf{w}$ 的 Tikhonov 惩罚项和对 $\\chi_e$ 的平滑总变差惩罚项。然后，实现一个 CSI 迭代，该迭代使用这些正规方程执行一次 $\\mathbf{w}$ 更新，然后执行一次 $\\chi_e$ 更新。\n\n在长度为 $L$ 的线段上使用一个包含 $N$ 个点的均匀网格，单元中心位于 $x_j = -L/2 + (j+1/2)\\Delta x$，$j = 0,1,\\dots,N-1$，且 $\\Delta x = L/N$。通过中点法则离散化积分算子，使得矩阵 $\\mathbf{G}\\in\\mathbb{C}^{N\\times N}$ 的元素为 $G_{ij} = G(x_i,x_j)\\Delta x$。通过选择网格点索引的一个子集来建模测量，这由一个投影 $\\mathbf{P}\\in\\mathbb{R}^{M\\times N}$ 表示，它选取单位矩阵的 $M$ 行。预测的测量值为 $\\mathbf{P}(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w})$。\n\n定义以下离散目标泛函，并针对 $\\mathbf{w}\\in\\mathbb{C}^N$ 和 $\\chi_e\\in\\mathbb{R}^N$ 交替最小化：\n$$\nJ(\\mathbf{w},\\chi_e) = \\left\\|\\mathbf{P}\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right) - \\mathbf{d}\\right\\|_2^2 + \\eta \\left\\|\\mathbf{w} - \\operatorname{diag}(\\chi_e)\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right)\\right\\|_2^2 + \\lambda_w \\left\\|\\mathbf{w}\\right\\|_2^2 + \\lambda_{\\mathrm{TV}} \\sum_{j=0}^{N-2} \\sqrt{\\left((D\\chi_e)_j\\right)^2 + \\epsilon_{\\mathrm{TV}}^2},\n$$\n其中 $D\\in\\mathbb{R}^{(N-1)\\times N}$ 是前向差分矩阵，满足 $(D\\chi_e)_j = \\chi_{e,j+1} - \\chi_{e,j}$，且 $\\eta0$、$\\lambda_w\\ge 0$、$\\lambda_{\\mathrm{TV}}\\ge 0$、$\\epsilon_{\\mathrm{TV}}0$ 是给定的权重。\n\n程序必须：\n- 使用一维格林函数和中点法则构建 $\\mathbf{G}$。\n- 对于每个测试案例，通过求解 $(\\mathbf{I} - \\operatorname{diag}(\\chi_e^{\\mathrm{true}})\\mathbf{G})\\mathbf{w}^{\\mathrm{true}} = \\operatorname{diag}(\\chi_e^{\\mathrm{true}})\\mathbf{E}^{\\mathrm{inc}}$，从已知的真实衬度 $\\chi_e^{\\mathrm{true}}$ 生成合成测量值 $\\mathbf{d}$，然后设置 $\\mathbf{d} = \\mathbf{P}(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{\\mathrm{true}})$，除非被明确覆盖。\n- 从 $\\mathbf{w}^{(0)} = \\mathbf{0}$ 和 $\\chi_e^{(0)} = \\mathbf{0}$ 开始，执行一次交替最小化迭代：\n  1. 通过求解最小化 $J(\\mathbf{w},\\chi_e^{(0)})$（相对于 $\\mathbf{w}$）所产生的正规方程来更新 $\\mathbf{w}^{(1)}$。\n  2. 通过求解最小化 $J(\\mathbf{w}^{(1)},\\chi_e)$（相对于 $\\chi_e$）所产生的正规方程（使用单个迭代重加权最小二乘步骤，其权重由 $\\chi_e^{(0)}$ 计算）来更新 $\\chi_e^{(1)}$。\n- 为每个测试案例计算两个标量：数据失配范数 $r_{\\mathrm{data}} = \\left\\|\\mathbf{P}\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}\\right) - \\mathbf{d}\\right\\|_2$ 和状态一致性失配范数 $r_{\\mathrm{state}} = \\left\\|\\mathbf{w}^{(1)} - \\operatorname{diag}(\\chi_e^{(1)})\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}\\right)\\right\\|_2$。\n\n使用以下参数值测试套件，它们共同涵盖了典型、边界和边缘情况：\n- 测试案例 1（一般情况）：$N=32$，$L=1.0$，$k_0=40.0$，$\\eta=1.0$，$\\lambda_w=10^{-4}$，$\\lambda_{\\mathrm{TV}}=10^{-2}$，$\\epsilon_{\\mathrm{TV}}=10^{-6}$。入射场为 $\\mathbf{E}^{\\mathrm{inc}}$，其元素为 $E^{\\mathrm{inc}}_j = \\exp(\\mathrm{i}k_0 x_j)$。测量投影 $\\mathbf{P}$ 选择偶数索引的网格点（$j=0,2,4,\\dots$）。真实衬度是中心对称的矩形函数：$|x_j|\\le 0.15$ 时 $\\chi_{e,j}^{\\mathrm{true}} = 0.5$，否则 $\\chi_{e,j}^{\\mathrm{true}} = 0.0$。\n- 测试案例 2（边界正则化情况）：$N=16$，$L=1.0$，$k_0=20.0$，$\\eta=1.0$，$\\lambda_w=10^{-4}$，$\\lambda_{\\mathrm{TV}}=0.0$，$\\epsilon_{\\mathrm{TV}}=10^{-6}$。$\\mathbf{P}$ 选择偶数索引的网格点。真实衬度是线性斜坡：$\\chi_{e,j}^{\\mathrm{true}} = 0.4\\left(1 + x_j/L\\right)$。\n- 测试案例 3（零数据边缘情况）：$N=16$，$L=1.0$，$k_0=20.0$，$\\eta=1.0$，$\\lambda_w=10^{-4}$，$\\lambda_{\\mathrm{TV}}=10^{-2}$，$\\epsilon_{\\mathrm{TV}}=10^{-6}$。$\\mathbf{P}$ 选择偶数索引的网格点。无论真实衬度如何，都将测量值覆盖为 $\\mathbf{d} = \\mathbf{0}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表。该列表必须按顺序包含三个测试案例的 $r_{\\mathrm{data}}$ 和 $r_{\\mathrm{state}}$，均为十进制数。例如，输出格式必须是 $[r_{\\mathrm{data},1},r_{\\mathrm{state},1},r_{\\mathrm{data},2},r_{\\mathrm{state},2},r_{\\mathrm{data},3},r_{\\mathrm{state},3}]$。输出中不需要物理单位。", "solution": "用户希望为一维标量亥姆霍兹散射问题实现衬度源反演 (CSI) 方法的单次迭代。这需要为交替最小化步骤推导正规方程，然后实现它们。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n\n- **控制方程**：标量亥姆霍兹方程。\n- **格林函数**：$G(x,x') = -\\mathrm{i}/(2k_0)\\exp(\\mathrm{i}k_0|x-x'|)$。\n- **场关系**：$\\mathbf{E} = \\mathbf{E}^{\\mathrm{inc}} + \\mathcal{G}\\mathbf{w}$。\n- **离散化**：在长度为 $L$ 的区间上使用包含 $N$ 个点的均匀网格。单元中心 $x_j = -L/2 + (j+1/2)\\Delta x$，其中 $j = 0,\\dots,N-1$，$\\Delta x = L/N$。\n- **积分算子离散化**：矩阵 $\\mathbf{G}\\in\\mathbb{C}^{N\\times N}$，其元素为 $G_{ij} = G(x_i,x_j)\\Delta x$。\n- **测量算子**：投影 $\\mathbf{P}\\in\\mathbb{R}^{M\\times N}$，选择 $M$ 个网格点。\n- **目标泛函**：\n$$\nJ(\\mathbf{w},\\chi_e) = \\left\\|\\mathbf{P}\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right) - \\mathbf{d}\\right\\|_2^2 + \\eta \\left\\|\\mathbf{w} - \\operatorname{diag}(\\chi_e)\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right)\\right\\|_2^2 + \\lambda_w \\left\\|\\mathbf{w}\\right\\|_2^2 + \\lambda_{\\mathrm{TV}} \\sum_{j=0}^{N-2} \\sqrt{\\left((D\\chi_e)_j\\right)^2 + \\epsilon_{\\mathrm{TV}}^2}\n$$\n- **前向差分算子**：$D\\in\\mathbb{R}^{(N-1)\\times N}$，满足 $(D\\chi_e)_j = \\chi_{e,j+1} - \\chi_{e,j}$。\n- **参数**：$\\eta0$, $\\lambda_w\\ge 0$, $\\lambda_{\\mathrm{TV}}\\ge 0$, $\\epsilon_{\\mathrm{TV}}0$。\n- **初始条件**：$\\mathbf{w}^{(0)} = \\mathbf{0}$, $\\chi_e^{(0)} = \\mathbf{0}$。\n- **合成数据生成**：求解 $(\\mathbf{I} - \\operatorname{diag}(\\chi_e^{\\mathrm{true}})\\mathbf{G})\\mathbf{w}^{\\mathrm{true}} = \\operatorname{diag}(\\chi_e^{\\mathrm{true}})\\mathbf{E}^{\\mathrm{inc}}$ 得到 $\\mathbf{w}^{\\mathrm{true}}$，然后设置 $\\mathbf{d} = \\mathbf{P}(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{\\mathrm{true}})$。\n- **迭代步骤**：一次 $\\mathbf{w}$ 更新，一次 $\\chi_e$ 更新（使用单个 IRLS 步骤）。\n- **输出**：数据失配 $r_{\\mathrm{data}} = \\left\\|\\mathbf{P}\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}\\right) - \\mathbf{d}\\right\\|_2$ 和状态一致性失配 $r_{\\mathrm{state}} = \\left\\|\\mathbf{w}^{(1)} - \\operatorname{diag}(\\chi_e^{(1)})\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}\\right)\\right\\|_2$。\n- **测试案例**：提供了三组参数。\n\n**第 2 步：使用提取的已知信息进行验证**\n\n- **科学性**：该问题是衬度源反演的标准表述，这是计算逆散射理论中一个成熟的方法。其 underlying 物理学由标量亥姆霍兹方程控制，而优化数学（交替最小化、Tikhonov 正则化、总变差正则化）是合理的。\n- **适定性**：问题是适定的。目标泛函已定义，最小化过程已指定（一次迭代的交替最小化），并且正则化项（$\\lambda_w$、$\\lambda_{\\mathrm{TV}}$）的使用确保了子问题是可解且稳定的。\n- **客观性**：问题使用精确的数学和算法语言陈述，没有歧义或主观性陈述。\n\n**第 3 步：结论与行动**\n\n问题是有效的。它是一个在计算物理学中定义明确的任务，科学上合理且内部一致。我将继续进行推导和求解。\n\n### 正规方程的推导\n\n任务的核心是推导在交替最小化的每个步骤中求解的线性方程组（正规方程）。我们从初始估计 $\\mathbf{w}^{(0)} = \\mathbf{0}$ 和 $\\chi_e^{(0)} = \\mathbf{0}$ 开始。\n\n**1. 衬度源 $\\mathbf{w}^{(1)}$ 的更新**\n\n我们固定 $\\chi_e = \\chi_e^{(0)} = \\mathbf{0}$，并通过最小化 $J(\\mathbf{w}, \\mathbf{0})$（相对于复向量 $\\mathbf{w}$）来找到 $\\mathbf{w}^{(1)}$。此步骤的目标泛函 $J_{\\mathbf{w}}(\\mathbf{w})$ 大大简化。总变差 (TV) 项与 $\\mathbf{w}$ 无关，状态一致性项变得更简单：\n$$\nJ_{\\mathbf{w}}(\\mathbf{w}) = \\left\\|\\mathbf{P}\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right) - \\mathbf{d}\\right\\|_2^2 + \\eta \\left\\|\\mathbf{w} - \\operatorname{diag}(\\mathbf{0})\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}\\right)\\right\\|_2^2 + \\lambda_w \\left\\|\\mathbf{w}\\right\\|_2^2\n$$\n$$\nJ_{\\mathbf{w}}(\\mathbf{w}) = \\left\\|\\mathbf{P}\\mathbf{G}\\mathbf{w} - (\\mathbf{d} - \\mathbf{P}\\mathbf{E}^{\\mathrm{inc}})\\right\\|_2^2 + \\eta \\left\\|\\mathbf{w}\\right\\|_2^2 + \\lambda_w \\left\\|\\mathbf{w}\\right\\|_2^2 = \\left\\|\\mathbf{P}\\mathbf{G}\\mathbf{w} - (\\mathbf{d} - \\mathbf{P}\\mathbf{E}^{\\mathrm{inc}})\\right\\|_2^2 + (\\eta + \\lambda_w)\\left\\|\\mathbf{w}\\right\\|_2^2\n$$\n这是一个 Tikhonov 正则化的线性最小二乘问题。最小化器 $\\mathbf{w}^{(1)}$ 是正规方程 $(\\mathbf{A}^H\\mathbf{A} + \\alpha^2\\mathbf{I})\\mathbf{x} = \\mathbf{A}^H\\mathbf{b}$ 的解，其中 $\\mathbf{A} = \\mathbf{P}\\mathbf{G}$，$\\mathbf{x} = \\mathbf{w}$，$\\mathbf{b} = \\mathbf{d} - \\mathbf{P}\\mathbf{E}^{\\mathrm{inc}}$，正则化参数为 $\\alpha^2 = \\eta + \\lambda_w$。由此得到的 $\\mathbf{w}^{(1)}$ 的线性系统为：\n$$\n\\left((\\mathbf{P}\\mathbf{G})^H (\\mathbf{P}\\mathbf{G}) + (\\eta + \\lambda_w)\\mathbf{I}\\right) \\mathbf{w}^{(1)} = (\\mathbf{P}\\mathbf{G})^H (\\mathbf{d} - \\mathbf{P}\\mathbf{E}^{\\mathrm{inc}})\n$$\n使用 $(\\mathbf{AB})^H = \\mathbf{B}^H\\mathbf{A}^H$，其中 $H$ 表示厄米转置，我们得到最终形式：\n$$\n\\left(\\mathbf{G}^H \\mathbf{P}^T \\mathbf{P} \\mathbf{G} + (\\eta + \\lambda_w)\\mathbf{I}\\right) \\mathbf{w}^{(1)} = \\mathbf{G}^H \\mathbf{P}^T (\\mathbf{d} - \\mathbf{P}\\mathbf{E}^{\\mathrm{inc}})\n$$\n注意到 $\\mathbf{P}$ 是一个只包含 0 和 1 的实数选择矩阵，因此 $\\mathbf{P}^H = \\mathbf{P}^T$。$\\mathbf{P}^T\\mathbf{P}$ 是一个对角矩阵，其对角线元素在测量点位置为 1，其他位置为 0。\n\n**2. 电纳衬度 $\\chi_e^{(1)}$ 的更新**\n\n接下来，我们固定 $\\mathbf{w} = \\mathbf{w}^{(1)}$，并最小化 $J(\\mathbf{w}^{(1)}, \\chi_e)$ 以求解实向量 $\\chi_e$。此步骤的目标泛函 $J_{\\chi_e}(\\chi_e)$ 为：\n$$\nJ_{\\chi_e}(\\chi_e) = \\eta \\left\\|\\mathbf{w}^{(1)} - \\operatorname{diag}(\\chi_e)\\left(\\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}\\right)\\right\\|_2^2 + \\lambda_{\\mathrm{TV}} \\sum_{j=0}^{N-2} \\sqrt{\\left((D\\chi_e)_j\\right)^2 + \\epsilon_{\\mathrm{TV}}^2}\n$$\n令总场为 $\\mathbf{E}_{\\text{tot}}^{(1)} = \\mathbf{E}^{\\mathrm{inc}} + \\mathbf{G}\\mathbf{w}^{(1)}$。令 $\\mathbf{E}_{\\text{diag}}^{(1)} = \\operatorname{diag}(\\mathbf{E}_{\\text{tot}}^{(1)})$。目标可以重写为：\n$$\nJ_{\\chi_e}(\\chi_e) = \\eta \\left\\| \\mathbf{E}_{\\text{diag}}^{(1)} \\chi_e - \\mathbf{w}^{(1)} \\right\\|_2^2 + \\lambda_{\\mathrm{TV}} \\sum_{j=0}^{N-2} \\sqrt{\\left((D\\chi_e)_j\\right)^2 + \\epsilon_{\\mathrm{TV}}^2}\n$$\n问题指定使用单次迭代重加权最小二乘 (IRLS) 步骤。这通过将其近似为一个二次型来线性化 TV 惩罚项，其中权重由前一个迭代值 $\\chi_e^{(0)} = \\mathbf{0}$ 计算得出。TV 项的梯度是非线性的。在 IRLS 框架中，我们将 TV 项近似为 $\\frac{1}{2} \\lambda_{\\mathrm{TV}} \\chi_e^T \\mathbf{R} \\chi_e$，其中 $\\mathbf{R} = D^T \\mathbf{W} D$，$\\mathbf{W}$ 是一个对角权重矩阵。权重为 $(\\mathbf{W})_{jj} = 1/\\sqrt{((D\\chi_e)_j)^2 + \\epsilon_{\\mathrm{TV}}^2}$。\n对于从 $\\chi_e^{(0)} = \\mathbf{0}$ 开始的单个 IRLS 步骤，我们有 $D\\chi_e^{(0)} = \\mathbf{0}$，因此权重变为常数：$(\\mathbf{W})_{jj} = 1/\\epsilon_{\\mathrm{TV}}$。因此，$\\mathbf{W} = (1/\\epsilon_{\\mathrm{TV}})\\mathbf{I}$。\n得到的目标函数是关于 $\\chi_e$ 的二次函数。将其关于 $\\chi_e$ 的梯度设为零，即可得到正规方程。第一项关于实数 $\\chi_e$ 的梯度是 $2\\eta \\operatorname{Re}((\\mathbf{E}_{\\text{diag}}^{(1)})^H(\\mathbf{E}_{\\text{diag}}^{(1)} \\chi_e - \\mathbf{w}^{(1)}))$。二次 TV 近似项的梯度是 $\\lambda_{\\mathrm{TV}} (1/\\epsilon_{\\mathrm{TV}}) D^T D \\chi_e$。\n将总梯度设为零，得到：\n$$\n2\\eta \\left( \\operatorname{Re}\\left( (\\mathbf{E}_{\\text{diag}}^{(1)})^H \\mathbf{E}_{\\text{diag}}^{(1)} \\right) \\chi_e - \\operatorname{Re}\\left( (\\mathbf{E}_{\\text{diag}}^{(1)})^H \\mathbf{w}^{(1)} \\right) \\right) + 2 \\frac{\\lambda_{\\mathrm{TV}}}{\\epsilon_{\\mathrm{TV}}} D^T D \\chi_e = \\mathbf{0}\n$$\n重新整理以求解 $\\chi_e^{(1)}$：\n$$\n\\left( \\eta \\operatorname{Re}\\left( (\\mathbf{E}_{\\text{diag}}^{(1)})^H \\mathbf{E}_{\\text{diag}}^{(1)} \\right) + \\frac{\\lambda_{\\mathrm{TV}}}{\\epsilon_{\\mathrm{TV}}} D^T D \\right) \\chi_e^{(1)} = \\eta \\operatorname{Re}\\left( (\\mathbf{E}_{\\text{diag}}^{(1)})^H \\mathbf{w}^{(1)} \\right)\n$$\n由于 $\\mathbf{E}_{\\text{diag}}^{(1)}$ 是对角矩阵，$(\\mathbf{E}_{\\text{diag}}^{(1)})^H \\mathbf{E}_{\\text{diag}}^{(1)}$ 是一个实的对角矩阵，其元素为 $|\\mathbf{E}_{\\text{tot}, j}^{(1)}|^2$。最终的线性系统是：\n$$\n\\left( \\eta \\operatorname{diag}\\left(|\\mathbf{E}_{\\text{tot}, j}^{(1)}|^2\\right) + \\frac{\\lambda_{\\mathrm{TV}}}{\\epsilon_{\\mathrm{TV}}} D^T D \\right) \\chi_e^{(1)} = \\eta \\operatorname{Re}\\left( \\overline{\\mathbf{E}_{\\text{tot}}^{(1)}} \\odot \\mathbf{w}^{(1)} \\right)\n$$\n其中 $\\odot$ 表示逐元素乘法。求解此系统得到实向量 $\\chi_e^{(1)}$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs one iteration of Contrast Source Inversion for a 1D scalar Helmholtz problem,\n    evaluating three test cases and printing the resulting data and state misfits.\n    \"\"\"\n    test_cases = [\n        # Test case 1: General case with all regularizers active.\n        {\n            \"N\": 32, \"L\": 1.0, \"k0\": 40.0, \"eta\": 1.0, \"lambda_w\": 1e-4,\n            \"lambda_TV\": 1e-2, \"epsilon_TV\": 1e-6,\n            \"chi_true_func\": lambda x: 0.5 * (np.abs(x) = 0.15),\n            \"E_inc_func\": lambda x, k0: np.exp(1j * k0 * x),\n            \"P_func\": lambda N: np.arange(0, N, 2),\n            \"d_override\": None\n        },\n        # Test case 2: Boundary case with no TV regularization.\n        {\n            \"N\": 16, \"L\": 1.0, \"k0\": 20.0, \"eta\": 1.0, \"lambda_w\": 1e-4,\n            \"lambda_TV\": 0.0, \"epsilon_TV\": 1e-6,\n            \"chi_true_func\": lambda x: 0.4 * (1 + x / 1.0),\n            \"E_inc_func\": lambda x, k0: np.exp(1j * k0 * x),\n            \"P_func\": lambda N: np.arange(0, N, 2),\n            \"d_override\": None\n        },\n        # Test case 3: Edge case with zero measurement data.\n        {\n            \"N\": 16, \"L\": 1.0, \"k0\": 20.0, \"eta\": 1.0, \"lambda_w\": 1e-4,\n            \"lambda_TV\": 1e-2, \"epsilon_TV\": 1e-6,\n            \"chi_true_func\": lambda x: np.zeros_like(x), # Not used since d is overridden\n            \"E_inc_func\": lambda x, k0: np.exp(1j * k0 * x),\n            \"P_func\": lambda N: np.arange(0, N, 2),\n            \"d_override\": lambda M: np.zeros(M, dtype=np.complex128)\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        L = case[\"L\"]\n        k0 = case[\"k0\"]\n        eta = case[\"eta\"]\n        lambda_w = case[\"lambda_w\"]\n        lambda_TV = case[\"lambda_TV\"]\n        epsilon_TV = case[\"epsilon_TV\"]\n\n        # 1. Setup grid and operators\n        dx = L / N\n        x = -L / 2 + (np.arange(N) + 0.5) * dx\n        \n        # Green's function matrix G (discretized integral operator)\n        x_i, x_j = np.meshgrid(x, x, indexing='ij')\n        G = (-1j / (2 * k0)) * np.exp(1j * k0 * np.abs(x_i - x_j)) * dx\n        \n        # Forward difference matrix D\n        D = np.zeros((N - 1, N))\n        D[np.arange(N - 1), np.arange(N - 1)] = -1.0\n        D[np.arange(N - 1), np.arange(N - 1) + 1] = 1.0\n\n        # Incident field\n        E_inc = case[\"E_inc_func\"](x, k0)\n        \n        # Measurement projector indices and data size\n        P_idx = case[\"P_func\"](N)\n        M = len(P_idx)\n        \n        # Projection matrix P (sparse representation)\n        P = np.zeros((M, N))\n        P[np.arange(M), P_idx] = 1.0\n\n        # 2. Generate synthetic measurement data d\n        if case[\"d_override\"] is not None:\n            d = case[\"d_override\"](M)\n        else:\n            chi_e_true = case[\"chi_true_func\"](x)\n            D_chi_true = np.diag(chi_e_true)\n            \n            A_w_true = np.eye(N) - D_chi_true @ G\n            b_w_true = D_chi_true @ E_inc\n            w_true = np.linalg.solve(A_w_true, b_w_true)\n            \n            E_tot_true = E_inc + G @ w_true\n            d = E_tot_true[P_idx]\n\n        # 3. Perform one CSI iteration\n        # w_0 and chi_e_0 are zero.\n\n        # 3.1. w-update: solve for w^(1)\n        G_meas = P @ G\n        G_H_meas = G_meas.conj().T\n\n        A_w1_sys = G_H_meas @ G_meas + (eta + lambda_w) * np.eye(N)\n        b_w1 = G_H_meas @ (d - P @ E_inc)\n        \n        w_1 = np.linalg.solve(A_w1_sys, b_w1)\n\n        # 3.2. chi_e-update: solve for chi_e^(1)\n        E_tot_1 = E_inc + G @ w_1\n        \n        A_chi1_term1 = np.diag(eta * np.abs(E_tot_1)**2)\n        A_chi1_term2 = (lambda_TV / epsilon_TV) * (D.T @ D)\n        A_chi1_sys = A_chi1_term1 + A_chi1_term2\n        \n        b_chi1_rhs = eta * np.real(np.conj(E_tot_1) * w_1)\n        \n        chi_e_1 = np.linalg.solve(A_chi1_sys, b_chi1_rhs)\n\n        # 4. Compute output quantities\n        r_data_vec = P @ (E_inc + G @ w_1) - d\n        r_data = np.linalg.norm(r_data_vec)\n        \n        r_state_vec = w_1 - np.diag(chi_e_1) @ (E_inc + G @ w_1)\n        r_state = np.linalg.norm(r_state_vec)\n        \n        results.extend([r_data, r_state])\n\n    # 5. Format and print the final output\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3295387"}]}