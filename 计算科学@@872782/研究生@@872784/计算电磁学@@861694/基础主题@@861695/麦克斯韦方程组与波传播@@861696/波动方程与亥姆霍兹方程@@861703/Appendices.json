{"hands_on_practices": [{"introduction": "时域有限差分 (FDTD) 方法是直接求解麦克斯韦方程（即波动方程）的强大工具。然而，将连续空间和时间离散化会引入数值误差，其中最主要的是数值色散，它导致波的相速度依赖于其频率、传播方向以及网格的离散情况。本练习将引导您推导二维Yee网格中的数值色散关系，并量化其导致的相速度误差，这是评估FDTD仿真精度的核心技能 [@problem_id:3354598]。", "problem": "考虑一个由介电常数 $\\epsilon$ 和磁导率 $\\mu$ 表征的二维均匀、各向同性、无源介质。从麦克斯韦方程组和本构关系出发，可以得到电磁场的波动方程。在均匀的笛卡尔网格中，标准的Yee格式在Courant-Friedrichs-Lewy (CFL)稳定性极限下，使用交错的空间采样，网格步长为 $\\Delta x$ 和 $\\Delta y$，以及交错的时间步长 $\\Delta t$。对于在 $x$-$y$ 平面内以斜角传播的平面波，Yee格式的数值色散关系将角频率 $\\omega$ 与波数分量 $k_x$ 和 $k_y$ 联系起来。\n\n您的任务是：\n- 从第一性原理出发，通过将平面波拟设（ansatz）应用于均匀介质的离散更新方程，推导Yee格式的数值色散关系。然后，对于给定的传播角度，根据波数大小 $k$ 和角度定义 $k_x$ 和 $k_y$，并使用色散关系计算 $\\omega$。\n- 使用色散关系计算数值相速度 $v_{\\mathrm{p,num}}=\\omega/k$，其中 $k=\\sqrt{k_x^2+k_y^2}$，并将其与同一介质中连续平面波的精确相速度 $c=1/\\sqrt{\\mu\\epsilon}$进行比较。以 $\\mathrm{m/s}$ 为单位，报告绝对相速度误差 $e=v_{\\mathrm{p,num}}-c$，结果表示为十进制数（而非百分比）。\n- 实现一个程序，对于下面的每个测试用例，使用从二维Yee数值色散关系获得的 $\\omega$ 来计算绝对相速度误差 $e$。角度使用度为单位。\n\n使用以下测试套件。每个案例由 $(\\Delta x,\\Delta y,\\Delta t,\\phi,\\lambda,\\mu,\\epsilon)$ 指定，单位为 $(\\mathrm{m},\\mathrm{m},\\mathrm{s},\\text{度},\\mathrm{m},\\mathrm{H/m},\\mathrm{F/m})$:\n1. $\\Delta x=1\\times 10^{-3}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.98\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=30^\\circ$, $\\lambda=1\\times 10^{-2}$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$，其中 $\\mu_0=4\\pi\\times 10^{-7}$ and $\\epsilon_0=8.854187817\\times 10^{-12}$，以及 $c_0=1/\\sqrt{\\mu_0\\epsilon_0}$。\n2. $\\Delta x=5\\times 10^{-4}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.85\\cdot \\dfrac{1}{c_0\\sqrt{\\frac{1}{\\Delta x^2}+\\frac{1}{\\Delta y^2}}}$, $\\phi=60^\\circ$, $\\lambda=5\\times 10^{-3}$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$。\n3. $\\Delta x=1\\times 10^{-3}$, $\\Delta y=1\\times 10^{-3}$, $\\Delta t=0.5\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=0^\\circ$, $\\lambda=2.5\\times \\Delta x$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$。\n4. $\\Delta x=2\\times 10^{-3}$, $\\Delta y=2\\times 10^{-3}$, $\\Delta t=0.5\\cdot \\dfrac{\\Delta x}{\\sqrt{2}c_0}$, $\\phi=45^\\circ$, $\\lambda=4\\times \\Delta x$, $\\mu=\\mu_0$, $\\epsilon=\\epsilon_0$。\n5. $\\Delta x=1.5\\times 10^{-3}$, $\\Delta y=7.5\\times 10^{-4}$, $\\Delta t=0.9\\cdot \\dfrac{1}{c^\\star\\sqrt{\\frac{1}{\\Delta x^2}+\\frac{1}{\\Delta y^2}}}$, $\\phi=20^\\circ$, $\\lambda=6\\times 10^{-3}$, $\\mu=\\mu_0$, $\\epsilon=4\\epsilon_0$，以及对于此介质 $c^\\star=1/\\sqrt{\\mu\\epsilon}$。\n\n对于每个案例：\n- 计算精确相速度 $c=1/\\sqrt{\\mu\\epsilon}$。\n- 计算波数大小 $k=2\\pi/\\lambda$ 和分量 $k_x=k\\cos(\\phi)$ 和 $k_y=k\\sin(\\phi)$，其中 $\\phi$ 以度为单位。\n- 求解二维Yee数值色散关系以得到 $\\omega$，并计算 $v_{\\mathrm{p,num}}=\\omega/k$。\n- 以 $\\mathrm{m/s}$ 为单位报告绝对相速度误差 $e=v_{\\mathrm{p,num}}-c$。\n\n您的程序应生成单行输出，其中包含五个测试用例的结果，格式为方括号内逗号分隔的列表，例如，$\\left[\\text{结果}_1,\\text{结果}_2,\\text{结果}_3,\\text{结果}_4,\\text{结果}_5\\right]$，其中每个 $\\text{结果}_i$ 是第 $i$ 个案例计算出的误差 $e$，单位为 $\\mathrm{m/s}$。", "solution": "该问题要求推导二维Yee时域有限差分 (FDTD) 格式的数值色散关系，并应用该关系计算几个测试用例的数值相速度误差。\n\n让我们从第一性原理开始。在均匀、各向同性、无源介质中，电磁波的传播由麦克斯韦旋度方程决定：\n$$ \\nabla \\times \\mathbf{E} = -\\frac{\\partial \\mathbf{B}}{\\partial t} $$\n$$ \\nabla \\times \\mathbf{H} = \\frac{\\partial \\mathbf{D}}{\\partial t} $$\n利用线性本构关系 $\\mathbf{D} = \\epsilon \\mathbf{E}$ 和 $\\mathbf{B} = \\mu \\mathbf{H}$，其中 $\\epsilon$ 是介质的介电常数，$\\mu$ 是介质的磁导率，方程变为：\n$$ \\nabla \\times \\mathbf{E} = -\\mu \\frac{\\partial \\mathbf{H}}{\\partial t} \\quad (1) $$\n$$ \\nabla \\times \\mathbf{H} = \\epsilon \\frac{\\partial \\mathbf{E}}{\\partial t} \\quad (2) $$\n对于 $x$-$y$ 平面中的二维问题，我们可以考虑横磁 ($TM_z$) 模式，其唯一的非零场分量是 $E_z$、$H_x$ 和 $H_y$。矢量方程 $(1)$ 和 $(2)$分解为三个标量方程组：\n$$ \\frac{\\partial E_z}{\\partial y} = -\\mu \\frac{\\partial H_x}{\\partial t} \\quad (3) $$\n$$ \\frac{\\partial E_z}{\\partial x} = \\mu \\frac{\\partial H_y}{\\partial t} \\quad (4) $$\n$$ \\frac{\\partial H_y}{\\partial x} - \\frac{\\partial H_x}{\\partial y} = \\epsilon \\frac{\\partial E_z}{\\partial t} \\quad (5) $$\n\nYee FDTD 格式在交错网格上离散化这些方程。场分量 $F(x,y,t)$ 表示为 $F^n(i,j) = F(i\\Delta x, j\\Delta y, n\\Delta t)$。$TM_z$ 分量的空间和时间交错如下：\n- $E_z$ 在网格点 $(i\\Delta x, j\\Delta y)$ 和时间步长 $n\\Delta t$ 处计算。\n- $H_x$ 在 $(i\\Delta x, (j+1/2)\\Delta y)$ 和时间步长 $(n+1/2)\\Delta t$ 处计算。\n- $H_y$ 在 $((i+1/2)\\Delta x, j\\Delta y)$ 和时间步长 $(n+1/2)\\Delta t$ 处计算。\n\n将中心有限差分应用于方程 $(3)-(5)$，得到Yee更新方程：\n$$ \\frac{E_z^n(i, j+1) - E_z^n(i, j)}{\\Delta y} = -\\mu \\frac{H_x^{n+1/2}(i, j+1/2) - H_x^{n-1/2}(i, j+1/2)}{\\Delta t} \\quad (6) $$\n$$ \\frac{E_z^n(i+1, j) - E_z^n(i, j)}{\\Delta x} = \\mu \\frac{H_y^{n+1/2}(i+1/2, j) - H_y^{n-1/2}(i+1/2, j)}{\\Delta t} \\quad (7) $$\n$$ \\frac{H_y^{n+1/2}(i+1/2, j) - H_y^{n+1/2}(i-1/2, j)}{\\Delta x} - \\frac{H_x^{n+1/2}(i, j+1/2) - H_x^{n+1/2}(i, j-1/2)}{\\Delta y} = \\epsilon \\frac{E_z^{n+1}(i, j) - E_z^n(i, j)}{\\Delta t} \\quad (8) $$\n\n为了找到数值色散关系，我们在离散网格上假设一个平面波解（拟设）。对于角频率为 $\\omega$、波矢量分量为 $k_x$ 和 $k_y$ 的波，其场为：\n$$ E_z^n(i,j) = E_{z0} e^{\\mathrm{j}(k_x i\\Delta x + k_y j\\Delta y - \\omega n\\Delta t)} $$\n$$ H_x^{n+1/2}(i,j+1/2) = H_{x0} e^{\\mathrm{j}(k_x i\\Delta x + k_y (j+1/2)\\Delta y - \\omega (n+1/2)\\Delta t)} $$\n$$ H_y^{n+1/2}(i+1/2,j) = H_{y0} e^{\\mathrm{j}(k_x (i+1/2)\\Delta x + k_y j\\Delta y - \\omega (n+1/2)\\Delta t)} $$\n其中 $E_{z0}$、$H_{x0}$ 和 $H_{y0}$ 是复振幅。将这些代入更新方程，可以求解 $\\omega$、$k_x$ 和 $k_y$ 之间的关系。\n\n根据方程 $(6)$：\n$$ E_{z0} \\frac{e^{\\mathrm{j}k_y\\Delta y} - 1}{\\Delta y} = -\\mu H_{x0} e^{\\mathrm{j}k_y\\Delta y/2} \\frac{e^{-\\mathrm{j}\\omega\\Delta t/2} - e^{\\mathrm{j}\\omega\\Delta t/2}}{\\Delta t} $$\n使用恒等式 $e^{\\mathrm{j}\\theta}-1=e^{\\mathrm{j}\\theta/2}(2\\mathrm{j}\\sin(\\theta/2))$，方程简化为：\n$$ \\frac{E_{z0}}{\\Delta y} e^{\\mathrm{j}k_y\\Delta y/2} (2\\mathrm{j}\\sin(k_y\\Delta y/2)) = \\mu \\frac{H_{x0}}{\\Delta t} e^{\\mathrm{j}k_y\\Delta y/2} (2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\n$$ H_{x0} = \\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta y} \\frac{\\sin(k_y\\Delta y/2)}{\\sin(\\omega\\Delta t/2)} \\quad (9) $$\n\n根据方程 $(7)$：\n$$ E_{z0} \\frac{e^{\\mathrm{j}k_x\\Delta x} - 1}{\\Delta x} = \\mu H_{y0} e^{\\mathrm{j}k_x\\Delta x/2} \\frac{e^{-\\mathrm{j}\\omega\\Delta t/2} - e^{\\mathrm{j}\\omega\\Delta t/2}}{\\Delta t} $$\n$$ \\frac{E_{z0}}{\\Delta x} e^{\\mathrm{j}k_x\\Delta x/2} (2\\mathrm{j}\\sin(k_x\\Delta x/2)) = -\\mu \\frac{H_{y0}}{\\Delta t} e^{\\mathrm{j}k_x\\Delta x/2} (2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\n$$ H_{y0} = -\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta x} \\frac{\\sin(k_x\\Delta x/2)}{\\sin(\\omega\\Delta t/2)} \\quad (10) $$\n\n最后，将拟设代入方程 $(8)$：\n$$ \\frac{H_{y0}}{\\Delta x} (2\\mathrm{j}\\sin(k_x\\Delta x/2)) - \\frac{H_{x0}}{\\Delta y} (2\\mathrm{j}\\sin(k_y\\Delta y/2)) = \\epsilon \\frac{E_{z0}}{\\Delta t} (-2\\mathrm{j}\\sin(\\omega\\Delta t/2)) $$\n现在，代入 $(9)$ 和 $(10)$ 中 $H_{x0}$ 和 $H_{y0}$ 的表达式：\n$$ \\frac{1}{\\Delta x} \\left(-\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta x} \\frac{\\sin(k_x\\Delta x/2)}{\\sin(\\omega\\Delta t/2)}\\right)\\sin(k_x\\Delta x/2) - \\frac{1}{\\Delta y}\\left(\\frac{E_{z0}}{\\mu} \\frac{\\Delta t}{\\Delta y} \\frac{\\sin(k_y\\Delta y/2)}{\\sin(\\omega\\Delta t/2)}\\right)\\sin(k_y\\Delta y/2) = -\\frac{\\epsilon E_{z0}}{\\Delta t}\\sin(\\omega\\Delta t/2) $$\n两边除以 $-E_{z0}$ 并重新整理：\n$$ \\frac{\\Delta t}{\\mu \\sin(\\omega\\Delta t/2)}\\left(\\frac{\\sin^2(k_x\\Delta x/2)}{\\Delta x^2} + \\frac{\\sin^2(k_y\\Delta y/2)}{\\Delta y^2}\\right) = \\frac{\\epsilon}{\\Delta t}\\sin(\\omega\\Delta t/2) $$\n整理各项并使用介质中光速的关系式 $c=1/\\sqrt{\\mu\\epsilon}$，我们得到了二维Yee格式的数值色散关系：\n$$ \\left(\\frac{1}{\\Delta x}\\sin\\left(\\frac{k_x\\Delta x}{2}\\right)\\right)^2 + \\left(\\frac{1}{\\Delta y}\\sin\\left(\\frac{k_y\\Delta y}{2}\\right)\\right)^2 = \\left(\\frac{1}{c\\Delta t}\\sin\\left(\\frac{\\omega\\Delta t}{2}\\right)\\right)^2 $$\n\n为了计算数值相速度，我们首先求解数值角频率 $\\omega$：\n$$ \\sin\\left(\\frac{\\omega\\Delta t}{2}\\right) = c\\Delta t \\sqrt{\\left(\\frac{\\sin(k_x\\Delta x/2)}{\\Delta x}\\right)^2 + \\left(\\frac{\\sin(k_y\\Delta y/2)}{\\Delta y}\\right)^2} $$\n$$ \\omega = \\frac{2}{\\Delta t}\\arcsin\\left(c\\Delta t \\sqrt{\\left(\\frac{\\sin(k_x\\Delta x/2)}{\\Delta x}\\right)^2 + \\left(\\frac{\\sin(k_y\\Delta y/2)}{\\Delta y}\\right)^2}\\right) $$\n数值相速度 $v_{\\mathrm{p,num}}$ 定义为此数值角频率 $\\omega$ 与连续空间波数大小 $k=\\sqrt{k_x^2+k_y^2}$ 的比值：\n$$ v_{\\mathrm{p,num}} = \\frac{\\omega}{k} $$\n绝对相速度误差 $e$ 是数值相速度与连续介质中精确相速度 $c$ 之间的差值：\n$$ e = v_{\\mathrm{p,num}} - c $$\n\n对于每个测试用例，执行以下步骤：\n1.  定义常数 $\\mu_0=4\\pi\\times 10^{-7} \\, \\mathrm{H/m}$ 和 $\\epsilon_0=8.854187817\\times 10^{-12} \\, \\mathrm{F/m}$。\n2.  对于给定的测试用例 $(\\Delta x, \\Delta y, \\Delta t, \\phi, \\lambda, \\mu, \\epsilon)$：\n    a. 计算精确相速度 $c=1/\\sqrt{\\mu\\epsilon}$。\n    b. 计算波数大小 $k = 2\\pi/\\lambda$。\n    c. 将传播角度 $\\phi$ 从度转换为弧度。\n    d. 计算波数分量 $k_x=k\\cos(\\phi)$ 和 $k_y=k\\sin(\\phi)$。\n    e. 将所有值代入推导出的 $\\omega$ 方程。\n    f. 计算数值相速度 $v_{\\mathrm{p,num}}=\\omega/k$。\n    g. 计算绝对误差 $e = v_{\\mathrm{p,num}} - c$。\n对所有五个提供的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical phase velocity error for the 2D Yee FDTD scheme\n    for a set of test cases.\n    \"\"\"\n    \n    # Define physical constants from the problem statement\n    mu_0 = 4 * np.pi * 1e-7  # H/m\n    epsilon_0 = 8.854187817e-12  # F/m\n    c_0 = 1 / np.sqrt(mu_0 * epsilon_0)\n\n    # Test cases: (dx, dy, dt_spec, phi_deg, lam_spec, mu_r, eps_r)\n    # dt_spec = (factor, type, c_ref_str)\n    #   type: 'iso' for dx=dy, 'aniso' for dx!=dy\n    #   c_ref_str: 'c0' for vacuum speed, 'c_medium' for material speed\n    # lam_spec = (type, value) where type can be 'abs' or 'rel' to dx\n    test_cases = [\n        (1e-3, 1e-3, (0.98, 'iso', 'c0'), 30, ('abs', 1e-2), 1.0, 1.0),\n        (5e-4, 1e-3, (0.85, 'aniso', 'c0'), 60, ('abs', 5e-3), 1.0, 1.0),\n        (1e-3, 1e-3, (0.5, 'iso', 'c0'), 0, ('rel', 2.5), 1.0, 1.0),\n        (2e-3, 2e-3, (0.5, 'iso', 'c0'), 45, ('rel', 4.0), 1.0, 1.0),\n        (1.5e-3, 7.5e-4, (0.9, 'aniso', 'c_medium'), 20, ('abs', 6e-3), 1.0, 4.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        dx, dy, dt_spec, phi_deg, lam_spec, mu_r, eps_r = case\n        \n        # Unpack specifications\n        dt_factor, dt_type, c_ref_str = dt_spec\n        lam_type, lam_val = lam_spec\n\n        # 1. Calculate medium properties and exact phase velocity\n        mu = mu_r * mu_0\n        epsilon = eps_r * epsilon_0\n        c = 1 / np.sqrt(mu * epsilon)\n        \n        # 2. Calculate time step dt\n        if c_ref_str == 'c0':\n            c_ref_for_dt = c_0\n        else: # 'c_medium'\n            c_ref_for_dt = c\n\n        if dt_type == 'iso':\n            dt = dt_factor * dx / (np.sqrt(2) * c_ref_for_dt)\n        else: # 'aniso'\n            dt = dt_factor / (c_ref_for_dt * np.sqrt(1/dx**2 + 1/dy**2))\n\n        # 3. Calculate wavelength and wavenumber\n        if lam_type == 'rel':\n            lam = lam_val * dx\n        else: # 'abs'\n            lam = lam_val\n\n        k = 2 * np.pi / lam\n        phi_rad = np.deg2rad(phi_deg)\n        kx = k * np.cos(phi_rad)\n        ky = k * np.sin(phi_rad)\n\n        # 4. Solve numerical dispersion relation for omega\n        term_x = (np.sin(kx * dx / 2) / dx)**2\n        term_y = (np.sin(ky * dy / 2) / dy)**2\n        \n        arcsin_arg = c * dt * np.sqrt(term_x + term_y)\n        \n        # The argument must be = 1 for a stable scheme\n        if arcsin_arg  1.0 and not np.isclose(arcsin_arg, 1.0):\n             # This should not happen for the given stable test cases\n             raise ValueError(f\"FDTD scheme is unstable. arcsin argument  1: {arcsin_arg}\")\n        if arcsin_arg  1.0: # Clamp for floating point inaccuracies\n             arcsin_arg = 1.0\n        \n        omega = (2 / dt) * np.arcsin(arcsin_arg)\n\n        # 5. Compute numerical phase velocity and error\n        v_p_num = omega / k\n        error = v_p_num - c\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3354598"}, {"introduction": "在处理谐波电磁散射问题时，我们通常转向频域，求解亥姆霍兹方程。边界积分方程 (BIE) 方法是一种高效的求解策略，它将三维体问题转化为物体表面的二维积分问题，但由此产生了多种积分方程形式，如电场积分方程 (EFIE) 和磁场积分方程 (MFIE)。本练习旨在揭示这些经典公式的一个关键缺陷：在特定频率（即所谓的“内部谐振”频率）下，它们会变得病态，而组合场积分方程 (CFIE) 则能有效规避此问题 [@problem_id:3354579]。", "problem": "考虑三维空间中时谐场的齐次亥姆霍兹方程，对于复值标量场，该方程写作 $$\\nabla^2 u(\\mathbf{x}) + k^2 u(\\mathbf{x}) = 0,$$ 其中 $k$ 是波数。自由空间亥姆霍兹格林函数是 $$G(\\mathbf{x},\\mathbf{y}) = \\frac{e^{ik|\\mathbf{x}-\\mathbf{y}|}}{4\\pi |\\mathbf{x}-\\mathbf{y}|}.$$ 在光滑闭合曲面 $\\Gamma$ 上，经典的边界积分算子为单层算子 $$\\mathcal{S}[\\rho](\\mathbf{x}) = \\int_{\\Gamma} G(\\mathbf{x},\\mathbf{y}) \\rho(\\mathbf{y}) \\,\\mathrm{d}S_{\\mathbf{y}},$$ 和双层算子 $$\\mathcal{K}[\\rho](\\mathbf{x}) = \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x},\\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\rho(\\mathbf{y}) \\,\\mathrm{d}S_{\\mathbf{y}},$$ 其中 $\\partial/\\partial n_{\\mathbf{y}}$ 表示在 $\\mathbf{y} \\in \\Gamma$ 点处关于外法线的导数。双层位在 $\\Gamma$ 上的外极限表现出跳跃关系，通常写作 $\\left(-\\frac{1}{2}\\mathcal{I} + \\mathcal{K}\\right)[\\rho]$，其中 $\\mathcal{I}$ 表示恒等算子。在处理理想电导体散射体的计算电磁学中，电场积分方程 (EFIE)、磁场积分方程 (MFIE) 和组合场积分方程 (CFIE) 被用来施加边界条件。在适用于条件数分析的标量亥姆霍兹模拟问题中，EFIE 对应于单层方程，MFIE 对应于第二类双层方程，CFIE 对应于两者的线性组合。\n\n设 $\\Gamma$ 是以原点为中心、半径为 $a$ 的球面。使用球谐函数，算子 $\\mathcal{S}$ 和 $\\mathcal{K}$ 被球面上的球谐函数 $Y_{\\ell m}(\\hat{\\mathbf{x}})$ 对角化，其中 $\\ell \\in \\mathbb{N}_0$ 且 $-\\ell \\le m \\le \\ell$。令 $x = ka$ 为无量纲尺寸参数。定义第一类球贝塞尔函数 $j_{\\ell}(x)$ 和第一类球汉克尔函数 $h_{\\ell}^{(1)}(x) = j_{\\ell}(x) + i y_{\\ell}(x)$，其中 $y_{\\ell}(x)$ 是第二类球贝塞尔函数。用 $h_{\\ell}^{(1)\\prime}(x)$ 表示 $h_{\\ell}^{(1)}(x)$ 关于其自变量 $x$ 的导数。\n\n当密度为球谐函数 $Y_{\\ell m}$ 时，单层算子的作用为 $$\\mathcal{S}[Y_{\\ell m}] = \\lambda_{\\ell}^{\\mathcal{S}} \\, Y_{\\ell m}, \\quad \\lambda_{\\ell}^{\\mathcal{S}} = \\frac{a x}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x).$$ 主值双层算子的贡献为 $$\\mathcal{K}[Y_{\\ell m}] = \\lambda_{\\ell}^{\\mathcal{K}} \\, Y_{\\ell m}, \\quad \\lambda_{\\ell}^{\\mathcal{K}} = \\frac{x^2}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)\\prime}(x),$$ MFIE 算子的特征值为 $$\\mu_{\\ell}^{\\text{MFIE}} = -\\frac{1}{2} + \\lambda_{\\ell}^{\\mathcal{K}}.$$ 可以构造一个无量纲的 CFIE 算子 $$\\nu_{\\ell}^{\\text{CFIE}} = \\alpha \\, \\mu_{\\ell}^{\\text{MFIE}} + \\eta \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x),$$ 其中 $\\alpha \\in (0,1)$ 和 $\\eta > 0$ 是耦合参数。对于截断至阶数 $\\ell_{\\max}$ 的球谐函数展开，将每个算子的条件数定义为 $$\\kappa(\\mathcal{O}) = \\frac{\\max_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|}{\\min_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|},$$ 其中 $\\lambda_{\\ell}(\\mathcal{O})$ 是算子 $\\mathcal{O}$ 作用于 $Y_{\\ell m}$ 时的特征值，最小值是在严格为正的模值中取得的，以避免在任何特征值数值上为零时出现除以零的情况。这个 $\\kappa$ 值为截断离散系统的条件数提供了一个近似。\n\n任务。实现一个程序，该程序：\n- 对于给定的球半径 $a$ 和尺寸参数 $x = k a$，计算 $\\ell = 0,1,\\dots,\\ell_{\\max}$ 时的特征值 $\\lambda_{\\ell}^{\\mathcal{S}}$、$\\mu_{\\ell}^{\\text{MFIE}}$ 和 $\\nu_{\\ell}^{\\text{CFIE}}$，其中 $\\ell_{\\max} = \\lceil x \\rceil + 8$。\n- 通过取 $\\ell = 0,\\dots,\\ell_{\\max}$ 中最大与最小非零绝对特征值之比，计算条件数 $\\kappa(\\mathcal{S})$、$\\kappa(\\text{MFIE})$ 和 $\\kappa(\\text{CFIE})$。\n- 使用以下参数集测试套件，这些参数集涵盖了小 $x$、中等 $x$、近共振 $x$ 和大 $x$ 的情况：\n    1. $a = 1$ 米, $x = 0.1$, $\\alpha = 0.5$, $\\eta = 0.7$。\n    2. $a = 1$ 米, $x = 1.0$, $\\alpha = 0.5$, $\\eta = 0.7$。\n    3. $a = 1$ 米, $x = 3.1415926535$, $\\alpha = 0.5$, $\\eta = 0.7$。\n    4. $a = 1$ 米, $x = 6.0$, $\\alpha = 0.5$, $\\eta = 0.7$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是按 $[\\kappa(\\mathcal{S}), \\kappa(\\text{MFIE}), \\kappa(\\text{CFIE})]$ 顺序排列的三个浮点数列表。因此，最终输出格式必须是单行，形式如：[[kS1,kM1,kC1],[kS2,kM2,kC2],[kS3,kM3,kC3],[kS4,kM4,kC4]]。输出中不需要物理单位；所有条件数都是无量纲的。", "solution": "该问题经评估有效。它在科学上是合理的、适定的，并为得到唯一解提供了完整且一致的定义和数据。问题陈述基于计算电磁学和亥姆霍兹方程边界积分方程理论的既定原理。任务是对象棋上三种常见积分方程公式的条件数进行数值分析，这是该领域一项标准且富有洞察力的练习。\n\n这个问题的核心是分析与球面上亥姆霍兹方程相关的边界积分算子的谱特性。这些算子被球谐函数 $Y_{\\ell m}$ 对角化，从而将分析算子的问题简化为分析其特征值 $\\lambda_{\\ell}$。条件数定义为最大与最小非零特征值模之比，可作为基于这些算子的离散化系统数值稳定性的一个近似。大的条件数表明相应的线性系统是病态的，对小扰动敏感，可能导致数值解出现较大误差。\n\n对于每个给定的测试用例 $(a, x, \\alpha, \\eta)$，解决该问题的总体步骤如下：\n\n1.  **确定截断阶数**：球谐函数展开必须在足够高的阶数处截断，以捕捉解的振荡特性。问题给出了经验法则 $\\ell_{\\max} = \\lceil x \\rceil + 8$，其中 $x = ka$ 是无量纲尺寸参数。计算将对从 $0$ 到 $\\ell_{\\max}$ 的整数阶 $\\ell$ 进行。\n\n2.  **评估特殊函数**：特征值表达式依赖于第一类球贝塞尔函数 $j_{\\ell}(x)$、第一类球汉克尔函数 $h_{\\ell}^{(1)}(x)$ 以及汉克尔函数的导数 $h_{\\ell}^{(1)\\prime}(x)$。汉克尔函数定义为 $h_{\\ell}^{(1)}(x) = j_{\\ell}(x) + i y_{\\ell}(x)$，其中 $y_{\\ell}(x)$ 是第二类球贝塞尔函数，$i$ 是虚数单位。这些函数是针对给定的 $x$ 和每个所需的阶数 $\\ell \\in \\{0, 1, \\dots, \\ell_{\\max}\\}$ 计算的。诸如 $h_{\\ell}^{(1)\\prime}(x)$ 之类的导数是关于其自变量 $x$ 求的。使用标准的科学计算库（例如 Python 中的 `scipy.special`）可以高效、准确地执行这些计算，该库为这些函数及其导数提供了例程。\n\n3.  **计算特征值**：在评估了特殊函数之后，为每个算子计算每个 $\\ell \\in \\{0, 1, \\dots, \\ell_{\\max}\\}$ 的特征值。\n    -   **单层（EFIE 模拟）**：特征值由公式 $\\lambda_{\\ell}^{\\mathcal{S}} = \\frac{a x}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x) = -i a x \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x)$ 给出。已知当 $x$ 接近任何 $j_{\\ell}(x)$ 的零点时，该算子的条件数会很差，这对应于球体的内部狄利克雷共振。\n    -   **MFIE 模拟**：第二类双层算子的特征值为 $\\mu_{\\ell}^{\\text{MFIE}} = -\\frac{1}{2} + \\lambda_{\\ell}^{\\mathcal{K}}$，其中 $\\lambda_{\\ell}^{\\mathcal{K}} = \\frac{x^2}{i} \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)\\prime}(x) = -i x^2 \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)\\prime}(x)$。该公式也存在病态条件问题，尽管是在一组不同的共振频率下（对应于内部诺伊曼共振）。当 $j_{\\ell}(x) = 0$ 时，特征值 $\\mu_{\\ell}^{\\text{MFIE}}$ 恰好变为 $-1/2$ 而不消失，这是相比于 EFIE 的一个优点。\n    -   **CFIE 模拟**：组合场公式的特征值由 $\\nu_{\\ell}^{\\text{CFIE}} = \\alpha \\, \\mu_{\\ell}^{\\text{MFIE}} + \\eta \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x)$ 给出。构造此线性组合是为了规避共振问题。当共振导致一个算子中的项出现问题时（例如，$j_{\\ell}(x) \\approx 0$），组合中的另一项仍然保持良态，从而确保所得的特征值 $\\nu_{\\ell}^{\\text{CFIE}}$ 不会消失。例如，如果 $j_{\\ell}(x) = 0$，则 $\\mu_{\\ell}^{\\text{MFIE}} = -1/2$，而项 $\\eta \\, j_{\\ell}(x) \\, h_{\\ell}^{(1)}(x)$ 消失，导致 $\\nu_{\\ell}^{\\text{CFIE}} = -\\alpha/2$。由于 $\\alpha \\in (0,1)$，该特征值非零，证明了该公式对这种特定共振的鲁棒性。\n\n4.  **计算条件数**：对于三个算子 $\\mathcal{O} \\in \\{\\mathcal{S}, \\text{MFIE}, \\text{CFIE}\\}$ 中的每一个，都获得了一组特征值 $\\{\\lambda_0(\\mathcal{O}), \\dots, \\lambda_{\\ell_{\\max}}(\\mathcal{O})\\}$。然后根据以下公式计算条件数：\n    $$ \\kappa(\\mathcal{O}) = \\frac{\\max_{0 \\le \\ell \\le \\ell_{\\max}} |\\lambda_{\\ell}(\\mathcal{O})|}{\\min_{0 \\le \\ell \\le \\ell_{\\max}, |\\lambda_{\\ell}(\\mathcal{O})|>0} |\\lambda_{\\ell}(\\mathcal{O})|} $$\n    这涉及到取所有计算出的特征值的绝对值，滤除任何为零的项，然后找出剩余正模值的最大值与最小值之比。\n\n对四个指定的测试用例中的每一个都实施并重复这整个过程。结果将定量地展示 CFIE 公式相比于 EFIE 和 MFIE 的更优条件数，特别是在 $x \\approx \\pi$ 的测试用例中，该值接近 $j_1(x)$ 的一个零点，这是球体的一个已知共振。按规定使用参数 $a=1$，尽管对于无量纲算子，最终的条件数与此选择无关。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import spherical_jn, spherical_yn\n\ndef solve():\n    \"\"\"\n    Computes and compares the condition numbers of scalar EFIE, MFIE, and CFIE\n    analogs for scattering from a sphere.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, x, alpha, eta)\n        (1.0, 0.1, 0.5, 0.7),\n        (1.0, 1.0, 0.5, 0.7),\n        (1.0, 3.1415926535, 0.5, 0.7),\n        (1.0, 6.0, 0.5, 0.7),\n    ]\n\n    results = []\n    for a, x, alpha, eta in test_cases:\n        # Step 1: Determine the truncation degree l_max\n        l_max = int(np.ceil(x)) + 8\n        l_range = np.arange(0, l_max + 1)\n\n        # Step 2: Evaluate special functions j_l(x), y_l(x), and their derivatives\n        # h_l^(1)(x) = j_l(x) + i * y_l(x)\n        # scipy.special functions are vectorized, so they compute for all l in l_range at once.\n        jl_x = spherical_jn(l_range, x)\n        yl_x = spherical_yn(l_range, x)\n        \n        # Derivatives with respect to the argument x\n        jl_x_prime = spherical_jn(l_range, x, derivative=True)\n        yl_x_prime = spherical_yn(l_range, x, derivative=True)\n\n        h1l_x = jl_x + 1j * yl_x\n        h1l_x_prime = jl_x_prime + 1j * yl_x_prime\n\n        # Step 3: Compute eigenvalues for each operator\n        \n        # Eigenvalues for single-layer operator (S)\n        # lambda_l^S = (a*x/i) * j_l(x) * h_l^(1)(x) = -i*a*x*j_l*h_l\n        lambda_S = -1j * a * x * jl_x * h1l_x\n        \n        # Eigenvalues for double-layer operator (K)\n        # lambda_l^K = (x^2/i) * j_l(x) * h_l^(1)'(x) = -i*x^2*j_l*h_l'\n        lambda_K = -1j * x**2 * jl_x * h1l_x_prime\n        \n        # Eigenvalues for MFIE operator\n        # mu_l^MFIE = -1/2 + lambda_l^K\n        mu_MFIE = -0.5 + lambda_K\n        \n        # Eigenvalues for CFIE operator\n        # nu_l^CFIE = alpha * mu_l^MFIE + eta * j_l(x) * h_l^(1)(x)\n        nu_CFIE = alpha * mu_MFIE + eta * jl_x * h1l_x\n\n        # Step 4: Calculate condition numbers\n        \n        def calculate_condition_number(eigenvalues):\n            \"\"\"\n            Computes condition number as max(|lambda|)/min(|lambda| > 0).\n            \"\"\"\n            abs_vals = np.abs(eigenvalues)\n            # Filter out any zero or near-zero magnitudes to avoid division by zero\n            # and adhere to the problem's \"strictly positive magnitudes\" rule.\n            non_zero_abs_vals = abs_vals[abs_vals > 0]\n            \n            if non_zero_abs_vals.size == 0:\n                # This case implies all eigenvalues are zero, condition number is ill-defined.\n                # Could be 1.0 (for a zero operator) or inf.\n                # Assuming it does not occur for the given test cases.\n                return 1.0 \n                \n            max_abs = np.max(non_zero_abs_vals)\n            min_abs = np.min(non_zero_abs_vals)\n            \n            return max_abs / min_abs\n\n        kappa_S = calculate_condition_number(lambda_S)\n        kappa_MFIE = calculate_condition_number(mu_MFIE)\n        kappa_CFIE = calculate_condition_number(nu_CFIE)\n        \n        results.append([kappa_S, kappa_MFIE, kappa_CFIE])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list is '[item1, item2, ...]'\n    # Joining these with commas and enclosing in brackets gives the desired output.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3354579"}, {"introduction": "边界积分方程方法虽然强大，但其主要缺点是会产生密集矩阵，这使得处理大规模问题时的计算和存储成本非常高。为了克服这一瓶颈，现代计算电磁学引入了分层矩阵 (Hierarchical Matrices, $\\mathcal{H}$-matrices) 和低秩近似等快速算法。本练习将通过自适应交叉近似 (ACA) 算法，让您亲手实践对远场交互矩阵块的压缩，从而具体地理解快速算法背后的低秩物理，并探究其数值秩如何依赖于问题的物理和几何参数 [@problem_id:3354552]。", "problem": "您需要设计并实现一个程序，用于研究计算电磁学中常见的三维外部标量亥姆霍兹核的远场交互块的低秩结构。目标是使用自适应交叉近似（ACA）来压缩块并控制近似误差，从而检验容许远场块的数值秩如何依赖于波数和可调压缩阈值。\n\n从单频相量假设下的无源时谐麦克斯韦方程组开始，其中场以 $\\mathrm{e}^{- \\mathrm{i} \\omega t}$ 的形式变化。在一个均匀、各向同性、无源的区域中，这导出电场的矢量亥姆霍兹方程 $\\nabla \\times \\nabla \\times \\mathbf{E} - k^{2}\\mathbf{E} = \\mathbf{0}$，其中波数为 $k = \\omega \\sqrt{\\mu \\epsilon}$。为了研究独立于矢量复杂性的低秩结构，我们简化为有界散射体外的标量亥姆霍兹方程 $\\nabla^{2} u + k^{2} u = 0$，并考虑自由空间基本解 $G(\\mathbf{x}, \\mathbf{y}) = \\dfrac{\\mathrm{e}^{\\mathrm{i} k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$。\n\n将半径为 $a = 1\\,\\mathrm{m}$ 的球体边界离散化为一组在球面上准均匀分布的 $N$ 个点 $\\{\\mathbf{x}_{i}\\}_{i=1}^{N}$。定义稠密矩阵 $K \\in \\mathbb{C}^{N \\times N}$，其元素为 $K_{ij} = G(\\mathbf{x}_{i}, \\mathbf{x}_{j})$（当 $i \\neq j$ 时），并令 $K_{ii} = 0$ 以避免奇异的自作用项。通过递归地分割最长空间维度来构建点集的二元空间聚类（一个 $k$-d 树），直到每个叶簇最多包含 $s$ 个点。对于两个叶簇 $I$ 和 $J$，其中心为 $\\mathbf{c}_{I}$、$\\mathbf{c}_{J}$，半径为 $r_{I}$、$r_{J}$（簇的包围盒对角线长度的一半），定义簇间距离为 $d(I,J) = \\max\\left(0, \\lVert \\mathbf{c}_{I} - \\mathbf{c}_{J} \\rVert - (r_{I} + r_{J})\\right)$。对于一个固定的容许性参数 $\\eta \\in (0,1)$，如果满足 $\\max(r_{I}, r_{J}) \\le \\eta \\, d(I,J)$，则一对簇 $(I,J)$ 是容许的（一个远场块）。对于每个容许对 $(I,J)$，考虑由 $I$ 中的行和 $J$ 中的列组成的子矩阵 $K_{IJ}$。\n\n实现自适应交叉近似（ACA），以构建一个秩-$r$ 分解 $K_{IJ} \\approx U V^{\\top}$，使得相对弗罗贝尼乌斯范数误差 $\\lVert K_{IJ} - U V^{\\top} \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F} \\le \\varepsilon$，其中 $\\varepsilon$ 是用户指定的阈值。您的 ACA 必须能自适应地选择主元，并在达到目标相对块误差或秩达到 $\\min(|I|,|J|)$ 时终止。对于每个容许块，报告其达到的秩 $r$ 和与完整 $K_{IJ}$ 计算得到的精确相对弗罗贝尼乌斯范数误差。为保证数值稳健性，您可以将范数 $\\lVert K_{IJ} \\rVert_{F} = 0$ 的块视为秩为 $0$、误差为 $0$。\n\n为保证可复现性，请使用以下固定的几何和算法参数：\n- 球体半径 $a = 1\\,\\mathrm{m}$。\n- 点数 $N = 192$，通过斐波那契晶格放置在球面上。\n- 叶大小 $s = 24$。\n- 容许性参数 $\\eta = 0.5$。\n- 距离单位为米，波数单位为弧度/米。格林函数使用相同单位，但所有要求的输出均为无量纲。\n\n对于下述每个测试用例，构建一次几何结构和聚类，枚举所有满足 $I \\ne J$ 的容许远场块 $(I,J)$，并对每个块应用具有给定阈值 $\\varepsilon$ 的 ACA。然后，按如下方式汇总远场块的统计数据：\n- 计算所有容许块的平均数值秩 $\\bar{r}$，并将其四舍五入到最近的整数。\n- 计算所有容许块中的最大相对弗罗贝尼乌斯范数误差 $E_{\\max}$。\n\n设计一个程序，使其生成单行输出。该行包含一个扁平列表，其中按顺序列出每个测试用例的四舍五入后的平均秩和最大误差。具体来说，如果有 $M$ 个测试用例，输出必须是一个包含 $2M$ 个条目的列表，形式为 $[r_{1},E_{1},r_{2},E_{2},\\dots,r_{M},E_{M}]$，其中每个 $r_{m}$ 是一个整数，每个 $E_{m}$ 是一个小数（浮点数）。该列表必须打印在单行上，以逗号分隔，并用方括号括起来，不含任何额外文本。\n\n测试套件：\n- 用例 1：$k = 2\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-2}$。\n- 用例 2：$k = 2\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$。\n- 用例 3：$k = 8\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-2}$。\n- 用例 4：$k = 8\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$。\n- 用例 5：$k = 16\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-2}$。\n- 用例 6：$k = 16\\,\\mathrm{rad/m}$, $\\varepsilon = 10^{-4}$。\n\n所有输出均为无量纲。若有角度，则单位为弧度。\n\n您的程序必须是完整且可运行的，并且不得需要用户输入。它必须实现所述的 ACA 压缩和基于容许性的块选择，并且必须为指定的测试套件计算所需的汇总指标。最终的打印语句必须仅生成上述格式所要求的单行输出。", "solution": "已对用户提供的问题进行了分析和验证。\n\n### 步骤 1：提取给定条件\n- **控制方程**：标量亥姆霍兹方程，$\\nabla^{2} u + k^{2} u = 0$。\n- **基本解**：$G(\\mathbf{x}, \\mathbf{y}) = \\dfrac{\\mathrm{e}^{\\mathrm{i} k \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}}{4 \\pi \\lVert \\mathbf{x} - \\mathbf{y} \\rVert}$。\n- **矩阵定义**：$K_{ij} = G(\\mathbf{x}_{i}, \\mathbf{x}_{j})$（当 $i \\neq j$ 时），且 $K_{ii} = 0$。\n- **几何结构**：半径为 $a = 1\\,\\mathrm{m}$ 的球体。\n- **离散化**：通过斐波那契晶格在球面上分布 $N = 192$ 个点。\n- **聚类**：$k$-d 树，递归分割最长空间维度。\n- **叶大小**：每个叶簇最多 $s = 24$ 个点。\n- **簇几何**：中心 $\\mathbf{c}_{I}$，半径 $r_{I}$（包围盒对角线的一半）。\n- **簇间距离**：$d(I,J) = \\max\\left(0, \\lVert \\mathbf{c}_{I} - \\mathbf{c}_{J} \\rVert - (r_{I} + r_{J})\\right)$。\n- **容许性**：如果 $\\max(r_{I}, r_{J}) \\le \\eta \\, d(I,J)$，则一对簇 $(I,J)$ 是容许的，其中 $\\eta = 0.5$。\n- **压缩**：通过自适应交叉近似（ACA）寻找 $K_{IJ} \\approx U V^{\\top}$。\n- **ACA 终止条件**：相对弗罗贝尼乌斯范数误差 $\\lVert K_{IJ} - U V^{\\top} \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F} \\le \\varepsilon$ 或秩达到最大可能值。\n- **稳健性**：如果 $\\lVert K_{IJ} \\rVert_{F} = 0$，则秩为 $0$，误差为 $0$。\n- **指标**：对于每个测试用例，计算所有容许块 $(I,J)$（其中 $I \\ne J$）的平均秩 $\\bar{r}$（四舍五入到最近的整数）和最大相对弗罗贝尼乌斯范数误差 $E_{\\max}$。\n- **测试用例 ($k$, $\\varepsilon$):**\n    1. ($2\\,\\mathrm{rad/m}$, $10^{-2}$)\n    2. ($2\\,\\mathrm{rad/m}$, $10^{-4}$)\n    3. ($8\\,\\mathrm{rad/m}$, $10^{-2}$)\n    4. ($8\\,\\mathrm{rad/m}$, $10^{-4}$)\n    5. ($16\\,\\mathrm{rad/m}$, $10^{-2}$)\n    6. ($16\\,\\mathrm{rad/m}$, $10^{-4}$)\n\n### 步骤 2：使用提取的给定条件进行验证\n- **科学依据**：该问题在计算电磁学和数值分析领域有充分的科学依据。亥姆霍兹方程、格林函数、分层数据结构（$k$-d 树）、容许性条件以及像 ACA 这样的低秩近似方法是快速边界元法和 H-矩阵理论中的标准工具。\n- **适定性**：该问题是适定的。所有必需的参数（$a, N, s, \\eta$）、算法（斐波那契晶格、$k$-d 树分割规则）和目标函数（平均秩、最大误差）都已指定，确保了解决方案的唯一性和可计算性。\n- **客观性**：问题以精确、客观和定量的术语陈述，没有主观或含糊的语言。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。它在一个成熟的科学领域内提出了一个标准的、尽管规模较小的数值实验。所有组成部分都定义清晰、科学正确且计算上可行。可以进行求解过程。\n\n### 基于原理的设计\n该解决方案是对边界元方法中快速分级求解器所用方法的系统性实现。其核心思想是，对于两个分离良好的点簇，其交互矩阵块是数值低秩的。利用此属性可以压缩矩阵，从而降低内存和计算成本。\n\n**1. 几何离散化**\n首先，将散射体（半径为 $a=1\\,\\mathrm{m}$ 的球体）的表面离散化为一组 $N=192$ 个点。为确保准均匀分布，采用斐波那契晶格。对于点索引 $i \\in [0, N-1]$，单位球面上的坐标 $(x_i, y_i, z_i)$ 使用黄金比例 $\\phi = (1 + \\sqrt{5})/2$ 生成。最终坐标按半径 $a$ 进行缩放。\n\n**2. 分级空间聚类**\n为了有效识别分离良好的点簇，使用 $k$-d 树对 $N$ 个点集进行分级划分。构造过程是递归的：\n- 点簇由树中的一个节点表示，该节点包含其点的索引。\n- 如果簇中的点数超过叶大小 $s=24$，则将该簇分裂为两个子簇。\n- 沿簇的轴对齐包围盒的最长维度进行分割。通过沿此维度对点进行排序并将其分为相等的两半来进行划分。\n- 当簇的点数小于或等于 $s$ 时，递归终止，此时该节点成为叶节点。\n- 对于每个叶节点，我们计算并存储其包围盒、中心 $\\mathbf{c}$ 和半径 $r$（包围盒对角线的一半）。\n\n**3. 容许性条件与远场块识别**\n低秩属性适用于“远场”交互。容许性条件将这种分离形式化。对于任意两个叶簇 $I$ 和 $J$，我们计算它们的包围盒半径 $r_I, r_J$ 以及它们包围盒之间的距离 $d(I,J) = \\max\\left(0, \\lVert \\mathbf{c}_{I} - \\mathbf{c}_{J} \\rVert - (r_{I} + r_{J})\\right)$。如果较大簇的尺寸与它们之间的距离相比很小，即 $\\max(r_I, r_J) \\le \\eta \\cdot d(I,J)$，则一对簇 $(I,J)$ 被视为容许的（在远场中）。这里，容许性参数 $\\eta=0.5$。我们枚举所有满足 $I \\neq J$ 的不同叶簇对 $(I,J)$，并收集满足此条件的簇对。\n\n**4. 通过自适应交叉近似（ACA）进行低秩压缩**\n对于每个容许块 $K_{IJ}$，我们必须找到一个低秩近似 $K_{IJ} \\approx U V^T$。问题要求当精确的相对弗罗贝尼乌斯范数误差 $\\varepsilon_{rel} = \\lVert K_{IJ} - U V^{\\top} \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F}$ 低于阈值 $\\varepsilon$ 时，该过程终止。\n\n鉴于最大块尺寸很小（$s \\times s = 24 \\times 24$），一个显式的、完全主元选择的交叉近似版本既稳健又计算上可行。此方法直接实现了指定的误差控制。对于给定的块 $K_{IJ}$，算法流程如下：\n\n1.  显式构建矩阵块 $K_{IJ}$，其中 $(K_{IJ})_{pq} = G(\\mathbf{x}_p, \\mathbf{x}_q)$，对于 $p \\in I, q \\in J$。\n2.  计算其弗罗贝尼乌斯范数 $\\lVert K_{IJ} \\rVert_{F}$。如果此范数为零，则秩为 $0$，过程终止。\n3.  初始化一个空近似（$U$ 和 $V$ 为空）和一个残差矩阵 $R = K_{IJ}$。\n4.  迭代构建秩-$r$ 近似：\n    a. 在第 $r$ 次迭代中（从 $r=1$ 开始），在当前残差矩阵 $R$ 中找到绝对值最大的元素 $(i_r, j_r)$。此即为主元。\n    b. 如果主元值在数值上为零，则残差实际上为零，过程停止。\n    c. 将 $U$ 的新列定义为 $R$ 的第 $j_r$ 列，将 $V^T$ 的新行定义为 $R$ 的第 $i_r$ 行除以主元值。\n    d. 通过减去秩-1 外积来更新残差：$R \\leftarrow R - u_r v_r^T$。\n    e. 构建当前的秩-$r$ 近似 $A_r = U V^T$。\n    f. 计算精确的相对误差 $\\lVert K_{IJ} - A_r \\rVert_{F} / \\lVert K_{IJ} \\rVert_{F}$。\n    g. 如果此误差小于或等于阈值 $\\varepsilon$，算法终止。\n5.  最终的秩是执行的迭代次数 $r$。最终的误差是最后一步计算出的误差。\n\n**5. 结果汇总**\n该过程针对由波数 $k$ 和压缩阈值 $\\varepsilon$ 定义的每个测试用例执行。对于给定的用例，我们遍历所有先前识别的容许块。对每个块运行 ACA 压缩以确定其数值秩和最终近似误差。收集所有块的秩和误差。最后，我们计算所有秩的平均值（四舍五入到最近的整数）和所有误差的最大值。这两个值构成一个测试用例的结果。所有测试用例的结果汇总到一个列表中作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and produce the final output.\n    \"\"\"\n\n    class Node:\n        \"\"\"A node in the k-d tree.\"\"\"\n        def __init__(self, indices, points):\n            self.indices = np.array(indices, dtype=int)\n            self.children = []\n            self.is_leaf = False\n            \n            if not self.indices.size:\n                self.bbox = np.array([0,0,0,0,0,0])\n                self.center = np.zeros(3)\n                self.radius = 0.0\n                return\n\n            node_points = points[self.indices]\n            mins = np.min(node_points, axis=0)\n            maxs = np.max(node_points, axis=0)\n            self.bbox = np.array([mins[0], maxs[0], mins[1], maxs[1], mins[2], maxs[2]])\n            self.center = (mins + maxs) / 2.0\n            \n            diag_vec = maxs - mins\n            self.radius = 0.5 * np.linalg.norm(diag_vec)\n\n    def build_kdtree(points, indices, leaf_size_s):\n        \"\"\"Recursively builds the k-d tree.\"\"\"\n        node = Node(indices, points)\n\n        if len(indices) = leaf_size_s:\n            node.is_leaf = True\n            return node\n\n        dims = node.bbox[1::2] - node.bbox[0::2]\n        split_dim = np.argmax(dims)\n        \n        node_points = points[indices]\n        sorted_indices_map = np.argsort(node_points[:, split_dim])\n        sorted_indices = indices[sorted_indices_map]\n        \n        mid = len(indices) // 2\n        \n        child1_indices = sorted_indices[:mid]\n        child2_indices = sorted_indices[mid:]\n        \n        node.children.append(build_kdtree(points, child1_indices, leaf_size_s))\n        node.children.append(build_kdtree(points, child2_indices, leaf_size_s))\n        \n        return node\n    \n    def get_leaves(node):\n        \"\"\"Traverses the tree to collect all leaf nodes.\"\"\"\n        if node.is_leaf:\n            return [node]\n        leaves = []\n        for child in node.children:\n            leaves.extend(get_leaves(child))\n        return leaves\n\n    def generate_fibonacci_sphere(n_points, radius):\n        \"\"\"Generates points on a sphere using the Fibonacci lattice.\"\"\"\n        points = np.zeros((n_points, 3))\n        phi = (1 + np.sqrt(5)) / 2.  # Golden ratio\n        \n        for i in range(n_points):\n            y = 1 - (2 * i + 1) / n_points\n            r_at_y = np.sqrt(1 - y * y)\n            theta = 2 * np.pi * i / phi\n            \n            x = np.cos(theta) * r_at_y\n            z = np.sin(theta) * r_at_y\n            \n            points[i] = [x, y, z]\n            \n        return points * radius\n\n    def green_function(x, y, k):\n        \"\"\"Computes the scalar Helmholtz Green's function.\"\"\"\n        dist = np.linalg.norm(x - y)\n        if dist  1e-12: # Avoid division by zero, though not expected for i != j\n            return 0.0j\n        return np.exp(1j * k * dist) / (4 * np.pi * dist)\n\n    def aca_compress_and_get_stats(row_indices, col_indices, points, k, epsilon):\n        \"\"\"\n        Performs ACA with full pivoting on an explicit matrix to find rank \n        and computes the exact relative Frobenius error.\n        \"\"\"\n        m, n = len(row_indices), len(col_indices)\n        \n        K_block = np.zeros((m, n), dtype=np.complex128)\n        for i, r_idx in enumerate(row_indices):\n            for j, c_idx in enumerate(col_indices):\n                K_block[i, j] = green_function(points[r_idx], points[c_idx], k)\n\n        norm_K_fro = np.linalg.norm(K_block, 'fro')\n        \n        if norm_K_fro == 0:\n            return 0, 0.0\n\n        R = K_block.copy()\n        U_list, V_list = [], []\n        \n        max_rank = min(m, n)\n        for r in range(max_rank):\n            # Full pivoting: find max element in residual\n            i_p, j_p = np.unravel_index(np.argmax(np.abs(R)), R.shape)\n            pivot = R[i_p, j_p]\n            \n            if abs(pivot)  1e-16 * norm_K_fro:\n                break\n            \n            u_r = R[:, j_p]\n            v_r = R[i_p, :] / pivot\n\n            U_list.append(u_r)\n            V_list.append(v_r)\n            \n            R -= np.outer(u_r, v_r)\n            \n            # Form approximation and check error\n            A_r = np.array(U_list).T @ np.array(V_list)\n            current_error = np.linalg.norm(K_block - A_r, 'fro') / norm_K_fro\n\n            if current_error = epsilon:\n                return r + 1, current_error\n        \n        # If loop finished, calculate final error\n        if U_list:\n            A_final = np.array(U_list).T @ np.array(V_list)\n            final_error = np.linalg.norm(K_block - A_final, 'fro') / norm_K_fro\n            return len(U_list), final_error\n        else:\n            return 0, 1.0\n\n\n    # Fixed geometric and algorithmic parameters\n    a = 1.0  # Sphere radius in meters\n    N = 192  # Number of points\n    s = 24   # Leaf size\n    eta = 0.5 # Admissibility parameter\n    \n    # Test suite\n    test_cases = [\n        (2.0, 1e-2),\n        (2.0, 1e-4),\n        (8.0, 1e-2),\n        (8.0, 1e-4),\n        (16.0, 1e-2),\n        (16.0, 1e-4),\n    ]\n\n    # --- Step 1: Geometry and Clustering (done once) ---\n    points = generate_fibonacci_sphere(N, a)\n    root = build_kdtree(points, np.arange(N), s)\n    leaves = get_leaves(root)\n    \n    # --- Step 2: Enumerate Admissible Blocks (done once) ---\n    admissible_pairs = []\n    for i in range(len(leaves)):\n        for j in range(len(leaves)):\n            if i == j:\n                continue\n            \n            node_I, node_J = leaves[i], leaves[j]\n            \n            dist_centers = np.linalg.norm(node_I.center - node_J.center)\n            dist_boxes = max(0, dist_centers - (node_I.radius + node_J.radius))\n            \n            if max(node_I.radius, node_J.radius) = eta * dist_boxes:\n                admissible_pairs.append((node_I.indices, node_J.indices))\n\n    # --- Step 3: Run test suite ---\n    final_results = []\n    for k, epsilon in test_cases:\n        ranks = []\n        errors = []\n        \n        if not admissible_pairs: # Should not happen for these params\n             final_results.extend([0, 0.0])\n             continue\n\n        for row_indices, col_indices in admissible_pairs:\n            rank, error = aca_compress_and_get_stats(row_indices, col_indices, points, k, epsilon)\n            ranks.append(rank)\n            errors.append(error)\n        \n        avg_rank = np.mean(ranks) if ranks else 0\n        max_error = np.max(errors) if errors else 0.0\n        \n        # Round average rank to the nearest integer\n        rounded_avg_rank = int(round(avg_rank))\n        \n        final_results.extend([rounded_avg_rank, max_error])\n        \n    # --- Final Print ---\n    # Formatting the output to match the required single-line list format.\n    formatted_results = []\n    for i, res in enumerate(final_results):\n        if i % 2 == 0:  # Rank is an integer\n            formatted_results.append(str(res))\n        else:  # Error is a float\n            formatted_results.append(f\"{res:.15g}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3354552"}]}