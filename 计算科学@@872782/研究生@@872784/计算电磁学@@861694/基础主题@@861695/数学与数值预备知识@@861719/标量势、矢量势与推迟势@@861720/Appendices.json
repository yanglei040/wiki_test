{"hands_on_practices": [{"introduction": "此练习为数值求解电磁积分方程奠定了基础。我们将探讨如何使用Rao-Wilton-Glisson (RWG)基函数来表示表面电流，以及至关重要的一点，即如何通过离散形式的连续性方程确保我们的离散模型遵循电荷守恒这一定律。这是构建稳定且物理精确的数值求解器的第一步。[@problem_id:3346293]", "problem": "考虑自由空间中角频率为 $\\omega$ 的时谐电磁场。从时谐场的麦克斯韦方程组微分形式开始，其复相量为 $e^{j \\omega t}$：$$\\nabla \\times \\mathbf{H} = \\mathbf{J} + j \\omega \\mathbf{D}, \\quad \\nabla \\times \\mathbf{E} = - j \\omega \\mathbf{B}, \\quad \\nabla \\cdot \\mathbf{D} = \\rho, \\quad \\nabla \\cdot \\mathbf{B} = 0$$ 本构关系为 $\\mathbf{D} = \\varepsilon \\mathbf{E}$ 和 $\\mathbf{B} = \\mu \\mathbf{H}$，其中 $\\varepsilon$ 是介电常数，$\\mu$ 是磁导率，$\\mathbf{J}$ 是电流密度，$\\rho$ 是电荷密度。基本守恒定律是连续性方程：$$\\nabla \\cdot \\mathbf{J} + j \\omega \\rho = 0$$\n\n通过自由空间中源的推迟势定义磁矢量势 $\\mathbf{A}$ 和电标量势 $\\phi$：$$\\mathbf{A}(\\mathbf{x}) = \\mu \\int_S \\mathbf{J}(\\mathbf{y}) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{y}\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{y}\\|} \\, \\mathrm{d}S_{\\mathbf{y}}, \\quad \\phi(\\mathbf{x}) = \\frac{1}{\\varepsilon} \\int_S \\rho(\\mathbf{y}) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{y}\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{y}\\|} \\, \\mathrm{d}S_{\\mathbf{y}},$$ 其中 $k = \\omega \\sqrt{\\mu \\varepsilon}$ 是自由空间波数，积分在源表面 $S$ 上进行。在计算电磁学中，必须以一种强制执行连续性方程离散模拟的方式对 $\\mathbf{J}$ 和 $\\rho$ 进行离散化。在三角化曲面上，一个标准的选择是 Rao-Wilton-Glisson (RWG) 基函数，该基函数是散度协调的，并确保离散散度能够一致地映射到分片常数电荷密度上。\n\n在三角化的平面上，与两个三角形 $T^+$ 和 $T^-$（面积分别为 $A^+$ 和 $A^-$，相对顶点分别为 $\\mathbf{r}_\\text{op}^+$ 和 $\\mathbf{r}_\\text{op}^-$）共享的长度为 $\\ell_e$ 的内部边相关的最低阶 RWG 基函数定义为：$$\\mathbf{f}_e(\\mathbf{r}) = \\begin{cases} \\dfrac{\\ell_e}{2 A^+} \\left(\\mathbf{r} - \\mathbf{r}_\\text{op}^+\\right), & \\mathbf{r} \\in T^+, \\\\ \\dfrac{\\ell_e}{2 A^-} \\left(\\mathbf{r}_\\text{op}^- - \\mathbf{r}\\right), & \\mathbf{r} \\in T^-, \\\\ 0, & \\text{其他情况}, \\end{cases}$$ 其曲面散度是分片常数：$$\\nabla_s \\cdot \\mathbf{f}_e = \\begin{cases} + \\dfrac{\\ell_e}{A^+}, & \\mathbf{r} \\in T^+, \\\\ - \\dfrac{\\ell_e}{A^-}, & \\mathbf{r} \\in T^-. \\end{cases}$$ 如果电流密度被离散化为 $\\mathbf{J}_h = i_e \\mathbf{f}_e$，其中 $i_e$ 是某个复振幅（单位为安培），那么将边系数 $i_e$ 映射到 $T^+$ 和 $T^-$ 上的分片常数电荷的相容离散散度算子 $D$ 为：$$D \\, i_e = \\begin{bmatrix} \\dfrac{\\ell_e}{A^+} \\\\ - \\dfrac{\\ell_e}{A^-} \\end{bmatrix} i_e$$ 离散连续性方程则为：$$D \\, i_e + j \\omega \\boldsymbol{\\rho}_h = \\mathbf{0},$$ 其中 $\\boldsymbol{\\rho}_h \\in \\mathbb{C}^2$ 是 $T^+$ 和 $T^-$ 上的分片常数表面电荷密度。求解 $\\boldsymbol{\\rho}_h$ 可得：$$\\boldsymbol{\\rho}_h = - \\dfrac{1}{j \\omega} D \\, i_e$$\n\n任务：在简单的三角形对上构造散度协调的 RWG 基函数，构建离散散度算子 $D$，通过离散连续性方程计算电荷密度 $\\boldsymbol{\\rho}_h$，并数值验证残差 $\\|D \\, i_e + j \\omega \\boldsymbol{\\rho}_h\\|_2$ 低于规定的容差。此外，使用基于质心的求积法计算给定观察点处的推迟磁矢量势 $\\mathbf{A}(\\mathbf{x})$ 和标量势 $\\phi(\\mathbf{x})$，以展示一个完整的基于势的离散化方法，尽管验证标准仅为离散连续性残差。\n\n使用自由空间参数 $\\mu = \\mu_0 = 4 \\pi \\times 10^{-7} \\ \\mathrm{H/m}$ 和 $\\varepsilon = \\varepsilon_0 = 8.854187817 \\times 10^{-12} \\ \\mathrm{F/m}$。所有几何长度单位为米，电流单位为安培，电荷单位为库仑/平方米，$\\mathbf{A}$ 的势单位为韦伯/米，$\\phi$ 的势单位为伏特。角度（如有）单位为弧度。实现以下测试套件：\n\n- 测试用例1（正常路径）：由 $(1,0)$ 和 $(0,1)$ 之间的内部边分割的三角化单位正方形，形成三角形 $T^+ = \\{(0,0),(1,0),(0,1)\\}$ 和 $T^- = \\{(1,1),(0,1),(1,0)\\}$，其中 $i_e = 1.0 \\ \\mathrm{A}$ 且 $\\omega = 2 \\pi \\cdot 100 \\times 10^{6} \\ \\mathrm{rad/s}$。使用观察点 $\\mathbf{x}_1 = (0.50, 0.50, 0.25)$、$\\mathbf{x}_2 = (0.25, 0.25, 0.25)$ 和 $\\mathbf{x}_3 = (0.75, 0.25, 0.25)$（单位为米）通过质心求积法计算 $\\mathbf{A}$ 和 $\\phi$。\n- 测试用例2（低频边界情况）：几何形状和观察点与用例1相同，但 $i_e = 0.5 \\ \\mathrm{A}$ 且 $\\omega = 2 \\pi \\cdot 1 \\times 10^{3} \\ \\mathrm{rad/s}$。\n- 测试用例3（几何变体）：矩形 $\\{(0,0),(2,0),(0,1),(2,1)\\}$ 由 $(2,0)$ 和 $(0,1)$ 之间的内部边分割，形成三角形 $T^+ = \\{(0,0),(2,0),(0,1)\\}$ 和 $T^- = \\{(2,1),(0,1),(2,0)\\}$，其中 $i_e = 2.0 \\ \\mathrm{A}$ 且 $\\omega = 2 \\pi \\cdot 1 \\times 10^{6} \\ \\mathrm{rad/s}$。使用观察点 $\\mathbf{x}_1 = (1.00, 0.50, 0.25)$、$\\mathbf{x}_2 = (0.50, 0.25, 0.25)$ 和 $\\mathbf{x}_3 = (1.50, 0.25, 0.25)$（单位为米）。\n\n对于每个测试用例，计算离散残差：$$r = \\left\\| D \\, i_e + j \\omega \\boldsymbol{\\rho}_h \\right\\|_2,$$ 并报告一个布尔值，指示 $r < 10^{-12}$ 是否成立（应用于复残差向量 2-范数的无单位阈值）。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$\\texttt{[result1,result2,result3]}$）。", "solution": "这是一个计算电磁学问题，要求验证 Rao-Wilton-Glisson (RWG) 基函数的离散连续性方程，并随后计算推迟电磁势。该问题需要针对三个不同的测试用例进行求解。\n\n### 问题分析\n\n**第1步：提取给定条件**\n\n问题提供了以下信息：\n- **控制方程**：时谐麦克斯韦方程组和连续性方程。\n$$\n\\begin{align*}\n\\nabla \\times \\mathbf{H} &= \\mathbf{J} + j \\omega \\mathbf{D} \\\\\n\\nabla \\times \\mathbf{E} &= - j \\omega \\mathbf{B} \\\\\n\\nabla \\cdot \\mathbf{D} &= \\rho \\\\\n\\nabla \\cdot \\mathbf{B} &= 0 \\\\\n\\nabla \\cdot \\mathbf{J} + j \\omega \\rho &= 0\n\\end{align*}\n$$\n- **本构关系**：$\\mathbf{D} = \\varepsilon \\mathbf{E}$, $\\mathbf{B} = \\mu \\mathbf{H}$。\n- **常数**：自由空间磁导率 $\\mu = \\mu_0 = 4 \\pi \\times 10^{-7} \\ \\mathrm{H/m}$，自由空间介电常数 $\\varepsilon = \\varepsilon_0 = 8.854187817 \\times 10^{-12} \\ \\mathrm{F/m}$。\n- **推迟势**：\n$$\n\\mathbf{A}(\\mathbf{x}) = \\mu \\int_S \\mathbf{J}(\\mathbf{y}) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{y}\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{y}\\|} \\, \\mathrm{d}S_{\\mathbf{y}}\n$$\n$$\n\\phi(\\mathbf{x}) = \\frac{1}{\\varepsilon} \\int_S \\rho(\\mathbf{y}) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{y}\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{y}\\|} \\, \\mathrm{d}S_{\\mathbf{y}}\n$$\n其中 $k = \\omega \\sqrt{\\mu \\varepsilon}$。\n- **RWG 基函数**：对于三角形 $T^+$ 和 $T^-$ 之间的长度为 $\\ell_e$ 的内部边，其面积分别为 $A^+$、$A^-$，相对顶点为 $\\mathbf{r}_\\text{op}^+$、$\\mathbf{r}_\\text{op}^-$。\n$$\n\\mathbf{f}_e(\\mathbf{r}) = \\begin{cases} \\dfrac{\\ell_e}{2 A^+} \\left(\\mathbf{r} - \\mathbf{r}_\\text{op}^+\\right), & \\mathbf{r} \\in T^+, \\\\ \\dfrac{\\ell_e}{2 A^-} \\left(\\mathbf{r}_\\text{op}^- - \\mathbf{r}\\right), & \\mathbf{r} \\in T^-, \\\\ 0, & \\text{其他情况}。 \\end{cases}\n$$\n- **RWG 曲面散度**：\n$$\n\\nabla_s \\cdot \\mathbf{f}_e = \\begin{cases} + \\dfrac{\\ell_e}{A^+}, & \\mathbf{r} \\in T^+, \\\\ - \\dfrac{\\ell_e}{A^-}, & \\mathbf{r} \\in T^-. \\end{cases}\n$$\n- **离散散度算子**：$D \\, i_e = \\begin{bmatrix} \\ell_e / A^+ \\\\ -\\ell_e / A^- \\end{bmatrix} i_e$。\n- **离散连续性方程**：$D \\, i_e + j \\omega \\boldsymbol{\\rho}_h = \\mathbf{0}$，其中 $\\boldsymbol{\\rho}_h$ 是 $T^+$ 和 $T^-$ 上的分片常数表面电荷密度向量。\n- **电荷密度解**：$\\boldsymbol{\\rho}_h = - \\dfrac{1}{j \\omega} D \\, i_e$。\n- **验证任务**：计算残差 $r = \\| D \\, i_e + j \\omega \\boldsymbol{\\rho}_h \\|_2$ 并检查是否 $r < 10^{-12}$。\n- **电势计算任务**：使用基于质心的求积法计算 $\\mathbf{A}(\\mathbf{x})$ 和 $\\phi(\\mathbf{x})$。\n- **测试用例**：问题中详细定义了三个测试用例的几何形状、物理参数和观察点。\n\n**第2步：问题验证与策略**\n\n该问题在科学上是合理的，它基于计算电磁学中矩量法和 RWG 基函数的标准应用。所有方程和定义都是正确的。主要任务是验证一个代数恒等式：通过定义 $\\boldsymbol{\\rho}_h = - \\frac{1}{j \\omega} D i_e$，残差 $D i_e + j \\omega \\boldsymbol{\\rho}_h$ 解析上恒为零。数值任务是实现这一过程，并证明残差在机器精度范围内为零。这是一个适定的验证任务。\n\n### 算法解法\n\n每个测试用例的求解过程包括以下步骤：\n1.  **几何分析**：根据定义两个三角形 $T^+$ 和 $T^-$ 的顶点，识别出共享边和两个相对顶点 $\\mathbf{r}_{\\text{op}}^+$ 和 $\\mathbf{r}_{\\text{op}}^-$。然后计算共享边的长度 $\\ell_e$ 和两个三角形的面积 $A^+$ 和 $A^-$。由顶点 $\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3$ 定义的三角形面积由 $A = \\frac{1}{2} \\| (\\mathbf{v}_2 - \\mathbf{v}_1) \\times (\\mathbf{v}_3 - \\mathbf{v}_1) \\|$ 给出。\n\n2.  **离散算子构建**：离散散度算子 $D$ 将共享边上的电流系数 $i_e$ 映射到三角形上产生的电荷，它是一个 $2 \\times 1$ 的矩阵（或一个2元列向量）：\n    $$\n    D = \\begin{bmatrix} \\ell_e / A^+ \\\\ -\\ell_e / A^- \\end{bmatrix}\n    $$\n\n3.  **电荷密度计算**：给定电流系数 $i_e$ 和角频率 $\\omega$，分片常数电荷密度向量 $\\boldsymbol{\\rho}_h = [\\rho^+, \\rho^-]^T$ 从离散连续性方程 $D i_e + j \\omega \\boldsymbol{\\rho}_h = \\mathbf{0}$ 计算得出。这得到：\n    $$\n    \\boldsymbol{\\rho}_h = -\\frac{1}{j\\omega} D i_e = \\frac{j}{\\omega} D i_e = \\frac{j i_e}{\\omega} \\begin{bmatrix} \\ell_e / A^+ \\\\ -\\ell_e / A^- \\end{bmatrix}\n    $$\n    这里，$j = \\sqrt{-1}$ 是虚数单位。\n\n4.  **残差验证**：计算残差向量 $\\mathbf{res} = D i_e + j \\omega \\boldsymbol{\\rho}_h$。代入上一步得到的 $\\boldsymbol{\\rho}_h$ 表达式，我们预期该向量在数值上接近零向量。计算其欧几里得范数（2-范数） $r = \\| \\mathbf{res} \\|_2$，并验证其是否低于指定的容差 $10^{-12}$。\n\n5.  **电势计算**（用于演示）：在指定的观察点 $\\mathbf{x}$ 计算磁矢量势 $\\mathbf{A}(\\mathbf{x})$ 和电标量势 $\\phi(\\mathbf{x})$。问题规定使用基于质心的求积法。\n    -   确定三角形的质心：$\\mathbf{r}_c^+ = \\frac{1}{3}\\sum_{i=1}^3 \\mathbf{v}_i^+$ 和 $\\mathbf{r}_c^- = \\frac{1}{3}\\sum_{i=1}^3 \\mathbf{v}_i^-$。\n    -   磁矢量势 $\\mathbf{A}(\\mathbf{x})$ 近似为：\n        $$\n        \\mathbf{A}(\\mathbf{x}) \\approx \\frac{\\mu_0 i_e \\ell_e}{8 \\pi} \\left[ (\\mathbf{r}_c^+ - \\mathbf{r}_\\text{op}^+) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{r}_c^+\\|}}{\\|\\mathbf{x}-\\mathbf{r}_c^+\\|} + (\\mathbf{r}_\\text{op}^- - \\mathbf{r}_c^-) \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{r}_c^-\\|}}{\\|\\mathbf{x}-\\mathbf{r}_c^-\\|} \\right]\n        $$\n    -   电标量势 $\\phi(\\mathbf{x})$ 近似为：\n        $$\n        \\phi(\\mathbf{x}) \\approx \\frac{1}{\\varepsilon_0} \\left[ \\rho^+ A^+ \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{r}_c^+\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{r}_c^+\\|} + \\rho^- A^- \\frac{e^{-j k \\|\\mathbf{x}-\\mathbf{r}_c^-\\|}}{4 \\pi \\|\\mathbf{x}-\\mathbf{r}_c^-\\|} \\right]\n        $$\n\n此过程将应用于提供的三个测试用例。最终输出是一个布尔值列表，指示每个用例的残差检查是否通过。鉴于检查的解析性质，只要实现是数值上稳健的，预计所有用例的结果都将为 `True`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the computational electromagnetics problem.\n    It processes three test cases, calculates geometric properties of triangle pairs,\n    verifies the discrete continuity equation for RWG basis functions, and\n    computes the retarded potentials as a demonstration.\n    \"\"\"\n    \n    # Constants\n    MU_0 = 4 * np.pi * 1e-7 # H/m\n    EPSILON_0 = 8.854187817e-12 # F/m\n    \n    test_cases = [\n        {\n            \"tri_plus_verts\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]),\n            \"tri_minus_verts\": np.array([[1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]),\n            \"i_e\": 1.0 + 0.0j,\n            \"omega\": 2 * np.pi * 100e6,\n            \"obs_points\": np.array([[0.50, 0.50, 0.25], [0.25, 0.25, 0.25], [0.75, 0.25, 0.25]])\n        },\n        {\n            \"tri_plus_verts\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0]]),\n            \"tri_minus_verts\": np.array([[1.0, 1.0, 0.0], [0.0, 1.0, 0.0], [1.0, 0.0, 0.0]]),\n            \"i_e\": 0.5 + 0.0j,\n            \"omega\": 2 * np.pi * 1e3,\n            \"obs_points\": np.array([[0.50, 0.50, 0.25], [0.25, 0.25, 0.25], [0.75, 0.25, 0.25]])\n        },\n        {\n            \"tri_plus_verts\": np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 1.0, 0.0]]),\n            \"tri_minus_verts\": np.array([[2.0, 1.0, 0.0], [0.0, 1.0, 0.0], [2.0, 0.0, 0.0]]),\n            \"i_e\": 2.0 + 0.0j,\n            \"omega\": 2 * np.pi * 1e6,\n            \"obs_points\": np.array([[1.00, 0.50, 0.25], [0.50, 0.25, 0.25], [1.50, 0.25, 0.25]])\n        }\n    ]\n    \n    results = []\n\n    def get_triangle_properties(verts_plus, verts_minus):\n        \"\"\"Identifies shared edge, opposite vertices, and calculates areas.\"\"\"\n        set_plus = {tuple(v) for v in verts_plus}\n        set_minus = {tuple(v) for v in verts_minus}\n        \n        shared_verts_tuples = set_plus.intersection(set_minus)\n        shared_verts = [np.array(v) for v in shared_verts_tuples]\n        \n        v_op_plus_tuple = set_plus.difference(set_minus).pop()\n        v_op_plus = np.array(v_op_plus_tuple)\n        \n        v_op_minus_tuple = set_minus.difference(set_plus).pop()\n        v_op_minus = np.array(v_op_minus_tuple)\n\n        edge_vec = shared_verts[0] - shared_verts[1]\n        ell_e = np.linalg.norm(edge_vec)\n\n        area_plus = 0.5 * np.linalg.norm(np.cross(shared_verts[0] - v_op_plus, shared_verts[1] - v_op_plus))\n        area_minus = 0.5 * np.linalg.norm(np.cross(shared_verts[0] - v_op_minus, shared_verts[1] - v_op_minus))\n        \n        return v_op_plus, v_op_minus, ell_e, area_plus, area_minus\n\n    for case in test_cases:\n        # Step 1: Geometric Analysis\n        v_op_plus, v_op_minus, ell_e, A_plus, A_minus = get_triangle_properties(\n            case[\"tri_plus_verts\"], case[\"tri_minus_verts\"]\n        )\n\n        # Step 2: Discrete Operator Assembly\n        D_op = np.array([ell_e / A_plus, -ell_e / A_minus])\n\n        # Step 3: Charge Density Calculation\n        i_e = case[\"i_e\"]\n        omega = case[\"omega\"]\n        j = 1j\n        \n        rho_h = -(1 / (j * omega)) * D_op * i_e\n\n        # Step 4: Residual Verification\n        residual_vec = D_op * i_e + j * omega * rho_h\n        residual_norm = np.linalg.norm(residual_vec)\n        results.append(residual_norm  1e-12)\n\n        # Step 5: Potential Calculation (for demonstration)\n        # This part is computed as requested but not part of the final output.\n        k = omega * np.sqrt(MU_0 * EPSILON_0)\n        \n        r_c_plus = np.mean(case[\"tri_plus_verts\"], axis=0)\n        r_c_minus = np.mean(case[\"tri_minus_verts\"], axis=0)\n        \n        rho_plus, rho_minus = rho_h\n        \n        A_values = []\n        phi_values = []\n        \n        for x in case[\"obs_points\"]:\n            # Distances from observation point to centroids\n            dist_plus = np.linalg.norm(x - r_c_plus)\n            dist_minus = np.linalg.norm(x - r_c_minus)\n\n            # Green's function, handling division by zero if x is on a centroid\n            G_plus = np.exp(-j * k * dist_plus) / (4 * np.pi * dist_plus) if dist_plus > 1e-9 else 0\n            G_minus = np.exp(-j * k * dist_minus) / (4 * np.pi * dist_minus) if dist_minus > 1e-9 else 0\n            \n            # Scalar potential\n            phi = (1 / EPSILON_0) * (rho_plus * A_plus * G_plus + rho_minus * A_minus * G_minus)\n            phi_values.append(phi)\n            \n            # Vector potential\n            A = (MU_0 * i_e * ell_e / (8 * np.pi)) * (\n                (r_c_plus - v_op_plus) * np.exp(-j * k * dist_plus) / dist_plus +\n                (v_op_minus - r_c_minus) * np.exp(-j * k * dist_minus) / dist_minus\n            )\n            A_values.append(A)\n\n    # Final print statement must be in this exact format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3346293"}, {"introduction": "有了有效的源表示后，接下来的挑战是通过积分计算势，而这涉及到奇异核函数的处理。本练习演示了一种强大的技术——坐标变换，它能使被积函数正则化——从而在观察点位于源单元自身上时精确计算这些弱奇异积分。掌握此方法对于精确实现边界元法和矩量法求解器至关重要。[@problem_id:3346287]", "problem": "您的任务是设计、论证并实现一个数值积分方案，以精确计算在计算电磁学中计算矢量势时出现的、具有 $1/R$ 形式核函数的弱奇异积分。考虑一个由曲面参数片上的面电流密度 $\\mathbf{J}(\\mathbf{r}')$ 产生的静磁矢量势 $\\mathbf{A}(\\mathbf{r})$。该问题可简化为可靠地计算以下形式的曲面积分：\n$$\nI(\\mathbf{r}_\\mathrm{p}) = \\iint_{S_e} \\frac{1}{\\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_\\mathrm{p}\\|} \\, \\left\\| \\frac{\\partial \\mathbf{r}}{\\partial \\xi}(\\xi,\\eta) \\times \\frac{\\partial \\mathbf{r}}{\\partial \\eta}(\\xi,\\eta) \\right\\| \\, d\\xi \\, d\\eta,\n$$\n其中 $S_e$ 是一个弯曲的等参三角形单元，其局部坐标 $(\\xi,\\eta)$ 位于参考三角形 $T = \\{(\\xi,\\eta)\\,|\\,\\xi \\ge 0, \\eta \\ge 0, \\xi+\\eta \\le 1\\}$ 内，$\\mathbf{r}(\\xi,\\eta)$ 是到 $\\mathbb{R}^3$ 的等参映射，而 $\\mathbf{r}_\\mathrm{p}=\\mathbf{r}(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ 是位于同一单元上的源点或场点。该核函数是弱奇异的，因为当 $(\\xi,\\eta)\\to(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ 时，欧几里得距离 $R=\\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_\\mathrm{p}\\|$ 趋于零，被积函数的行为类似于 $1/R$ 乘以曲面度量因子。\n\n出发点与约束条件：\n- 从静磁矢量势 $\\mathbf{A}(\\mathbf{r})$ 由面上的面电流密度定义的公式出发，并结合等参二次三角形单元的几何定义。不得先验地假设任何专门的奇异积分公式；数值积分方案必须从第一性原理出发，通过坐标变换和雅可比式推导得出。\n- 等参二次三角形单元由六个节点和二次拉格朗日形函数定义，使用重心坐标 $L_1=1-\\xi-\\eta$、$L_2=\\xi$ 和 $L_3=\\eta$。这 6 个形函数是 $N_1=L_1(2L_1-1)$、$N_2=L_2(2L_2-1)$、$N_3=L_3(2L_3-1)$、$N_4=4L_1L_2$、$N_5=4L_2L_3$ 和 $N_6=4L_3L_1$。映射关系为 $\\mathbf{r}(\\xi,\\eta) = \\sum_{i=1}^6 N_i(\\xi,\\eta)\\,\\mathbf{x}_i$，其中 $\\mathbf{x}_i \\in \\mathbb{R}^3$ 是节点坐标。\n- 单元的几何形状是通过在一个由 $z = \\epsilon (x^2 + y^2)$ 隐式给出的曲面上采样得到的。采样点为三角形的六个节点位置，其平面 $(x,y)$ 坐标为：三个顶点位于 $(0,0)$、$(1,0)$、$(0,1)$，三个边中节点位于 $(\\tfrac{1}{2},0)$、$(\\tfrac{1}{2},\\tfrac{1}{2})$、$(0,\\tfrac{1}{2})$。$z$ 坐标由给定的曲面公式确定。\n\n您的任务：\n1) 当 $(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ 严格位于参考三角形 $T$ 内部时，推导一个有理论依据的数值积分方案来精确计算 $I(\\mathbf{r}_\\mathrm{p})$。您的推导必须从上述积分定义和基本的几何变换出发。解释为什么该奇异性是可积的，以及您选择的变量替换如何使被积函数正则化。\n2) 将该方案实现为一个程序，该程序根据指定的节点构造曲面单元，并为给定的 $(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ 计算 $I(\\mathbf{r}_\\mathrm{p})$。您的算法必须适用于单元上的一般点 $(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$。\n3) 为了验证，使用相同的方法但采用显著更高阶的多项式积分来实现一个高精度参考解，并报告您提出的实用阶数积分方案相对于高精度参考解的绝对误差。\n\n假设几何尺寸采用任意一致的单位；所有输出均为无单位的纯数。\n\n测试套件：\n您必须对以下四种情况计算积分，每种情况由曲率参数 $\\epsilon$ 和单元上的参数点 $(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ 定义：\n- 情况1：$\\epsilon = 0.2$, $(\\xi_\\mathrm{p},\\eta_\\mathrm{p}) = (0.3, 0.4)$。\n- 情况2：$\\epsilon = 0.2$, $(\\xi_\\mathrm{p},\\eta_\\mathrm{p}) = (10^{-6}, 10^{-6})$。\n- 情况3：$\\epsilon = 10^{-3}$, $(\\xi_\\mathrm{p},\\eta_\\mathrm{p}) = (0.3, 0.4)$。\n- 情况4：$\\epsilon = 0.5$, $(\\xi_\\mathrm{p},\\eta_\\mathrm{p}) = (0.2, 0.2)$。\n\n数值规格：\n- 对于实用方案，在您的变换引入的两个标量变量的每个维度上，使用 $q$ 阶高斯积分；对于高精度参考解，使用 $q_\\mathrm{ref}$ 阶。对于本问题，请使用 $q=12$ 和 $q_\\mathrm{ref}=50$。\n- 对于每种情况，计算绝对误差 $|I_q - I_{q_\\mathrm{ref}}|$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个绝对误差的结果，以逗号分隔列表的形式呈现，并用方括号括起来，顺序为情况1到情况4（例如，“[e1,e2,e3,e4]”）。", "solution": "该问题要求设计、论证并实现一个数值积分方案，用于计算在计算电磁学中出现的弱奇异积分。该积分代表了由曲面单元上的电流密度产生的静磁矢量势的一个简化标量版本。\n\n需要计算的积分为：\n$$\nI(\\mathbf{r}_\\mathrm{p}) = \\iint_{T} \\frac{1}{\\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_\\mathrm{p}\\|} \\, \\left\\| \\frac{\\partial \\mathbf{r}}{\\partial \\xi}(\\xi,\\eta) \\times \\frac{\\partial \\mathbf{r}}{\\partial \\eta}(\\xi,\\eta) \\right\\| \\, d\\xi \\, d\\eta\n$$\n其中 $T = \\{(\\xi,\\eta)\\,|\\,\\xi \\ge 0, \\eta \\ge 0, \\xi+\\eta \\le 1\\}$ 是标准参考三角形。映射 $\\mathbf{r}(\\xi,\\eta)$ 描述了一个弯曲的二次等参三角形单元，$\\mathbf{r}_\\mathrm{p}=\\mathbf{r}(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ 是该单元上的一个点，它也是奇异性的来源。项 $R = \\|\\mathbf{r}(\\xi,\\eta)-\\mathbf{r}_\\mathrm{p}\\|$ 是场点 $\\mathbf{r}(\\xi,\\eta)$ 和源点 $\\mathbf{r}_\\mathrm{p}$ 之间的欧几里得距离。当 $(\\xi,\\eta) \\to (\\xi_\\mathrm{p}, \\eta_\\mathrm{p})$ 时，$R \\to 0$，被积函数变为奇异。\n\n我们将曲面元雅可比式定义为 $J_S(\\xi,\\eta) = \\left\\| \\frac{\\partial \\mathbf{r}}{\\partial \\xi} \\times \\frac{\\partial \\mathbf{r}}{\\partial \\eta} \\right\\|$。因此，积分为：\n$$\nI(\\mathbf{r}_\\mathrm{p}) = \\iint_{T} \\frac{J_S(\\xi,\\eta)}{R(\\xi,\\eta)} \\, d\\xi \\, d\\eta\n$$\n\n该奇异性被称为“弱”奇异，因为在奇异点 $(\\xi_\\mathrm{p}, \\eta_\\mathrm{p})$ 附近，距离 $R$ 的行为与参数平面中的距离呈线性关系。令 $\\tilde{\\xi} = \\xi - \\xi_\\mathrm{p}$ 和 $\\tilde{\\eta} = \\eta - \\eta_\\mathrm{p}$。将 $\\mathbf{r}(\\xi,\\eta)$ 在 $(\\xi_\\mathrm{p},\\eta_\\mathrm{p})$ 周围进行一阶泰勒展开，可得：\n$$\n\\mathbf{r}(\\xi,\\eta) \\approx \\mathbf{r}(\\xi_\\mathrm{p},\\eta_\\mathrm{p}) + \\frac{\\partial \\mathbf{r}}{\\partial \\xi}\\bigg|_{p} \\tilde{\\xi} + \\frac{\\partial \\mathbf{r}}{\\partial \\eta}\\bigg|_{p} \\tilde{\\eta}\n$$\n因此，$R = \\|\\mathbf{r}(\\xi,\\eta) - \\mathbf{r}_\\mathrm{p}\\| \\approx \\|\\mathbf{r}_\\xi \\tilde{\\xi} + \\mathbf{r}_\\eta \\tilde{\\eta}\\|$。由于对于非退化的曲面片，$\\mathbf{r}_\\xi$ 和 $\\mathbf{r}_\\eta$ 是线性无关的向量，因此 $R$ 与参数平面中的径向距离 $\\rho = \\sqrt{\\tilde{\\xi}^2+\\tilde{\\eta}^2}$ 成正比。在局部，该积分在极坐标下的行为类似于 $\\int \\frac{1}{\\rho} \\rho \\, d\\rho \\, d\\theta$，这是正则的。这证实了该奇异性是可积的。然而，由于被积函数存在巨大且急剧的变化，标准的数值积分方法无法提供准确的结果。\n\n问题陈述要求不能假设使用专门的积分公式，而必须从第一性原理出发，通过坐标变换推导。合适的技术是应用一个能够使被积函数正则化的变换。这可以通过引入一个以奇异点 $(\\xi_\\mathrm{p}, \\eta_\\mathrm{p})$ 为中心的新坐标系来实现，该坐标系能有效地将奇异性转换为可被变换的雅可比式抵消的形式。\n\n具体步骤如下：\n1.  **区域分解**：将顶点为 $V_1=(0,0)$、$V_2=(1,0)$ 和 $V_3=(0,1)$ 的参考三角形 $T$ 细分为三个较小的三角形，并将奇异点 $P=(\\xi_\\mathrm{p}, \\eta_\\mathrm{p})$ 作为它们的公共顶点。这三个子三角形分别为 $T_1 = \\triangle V_1V_2P$、$T_2 = \\triangle V_2V_3P$ 和 $T_3 = \\triangle V_3V_1P$。总积分是这三个子三角形上积分之和：$I = I_1 + I_2 + I_3$。\n\n2.  **坐标变换**：对于每个子三角形（例如，顶点为 $A$、$B$ 和 $P$ 的 $T_k$），我们引入一个从单位正方形 $(u,v) \\in [0,1]\\times[0,1]$ 到三角形 $T_k$ 的变换。$T_k$ 中的任意点 $(\\xi,\\eta)$ 均可参数化为：\n    $$\n    (\\xi(u,v), \\eta(u,v)) = P + u \\cdot ((1-v)A + vB - P)\n    $$\n    在这里，$u$ 作为从奇异顶点 $P$ 出发的径向缩放因子（$u=0$ 对应于 $P$），而 $v$ 则参数化由 $A$、$B$ 和 $P$ 构成的三角形的底边。\n\n3.  **变换的雅可比式**：微分面积元变换为 $d\\xi d\\eta = |J_{uv}| du dv$。该映射的雅可比行列式为：\n    $$\n    J_{uv} = \\det\\left(\\frac{\\partial(\\xi,\\eta)}{\\partial(u,v)}\\right) = \\det \\begin{pmatrix} \\partial\\xi/\\partial u  \\partial\\xi/\\partial v \\\\ \\partial\\eta/\\partial u  \\partial\\eta/\\partial v \\end{pmatrix}\n    $$\n    计算偏导数：\n    $$\n    \\frac{\\partial}{\\partial u}(\\xi, \\eta) = (1-v)A + vB - P\n    $$\n    $$\n    \\frac{\\partial}{\\partial v}(\\xi, \\eta) = u(B-A)\n    $$\n    则行列式为：\n    $$\n    J_{uv} = \\det\\begin{pmatrix} (1-v)A_x+vB_x-P_x  u(B_x-A_x) \\\\ (1-v)A_y+vB_y-P_y  u(B_y-A_y) \\end{pmatrix} = u \\cdot \\det(A-P, B-P)\n    $$\n    项 $\\det(A-P, B-P)$ 是三角形 $\\triangle ABP$ 有向面积的两倍。因此， $|J_{uv}| = u \\cdot 2 \\cdot \\text{Area}(\\triangle ABP)$。该雅可比式的关键特征是线性因子 $u$。\n\n4.  **正则化**：将其代入子三角形 $T_k$ 上的积分：\n    $$\n    I_k = \\iint_{T_k} \\frac{J_S(\\xi,\\eta)}{R(\\xi,\\eta)} \\, d\\xi d\\eta = \\int_0^1 \\int_0^1 \\frac{J_S(\\xi(u,v), \\eta(u,v))}{R(\\xi(u,v), \\eta(u,v))} |J_{uv}| \\, du dv\n    $$\n    当 $u \\to 0$ 时，我们有 $(\\xi,\\eta) \\to P$，且对于某个函数 $c(v)  0$，$R \\approx c(v) \\cdot u$。被积函数变为：\n    $$\n    \\frac{J_S(\\dots)}{c(v) \\cdot u} \\cdot (u \\cdot 2\\cdot \\text{Area}(\\triangle ABP)) = \\frac{J_S(\\dots) \\cdot 2\\cdot \\text{Area}(\\triangle ABP)}{c(v)}\n    $$\n    来自变换雅可比式的因子 $u$ 恰好抵消了 $1/R \\sim 1/u$ 的奇异性。最终的被积函数在单位正方形 $[0,1]^2$ 上是正则的。\n\n5.  **数值积分**：现在可以使用标准的张量积高斯积分法则精确计算单位正方形上的正则化积分。对于每个维度上的 $q$ 阶法则，积分可近似为：\n    $$\n    I_k \\approx \\sum_{i=1}^q \\sum_{j=1}^q w_i w_j F_k(u_i, v_j)\n    $$\n    其中 $(u_i, w_i)$ 和 $(v_j, w_j)$ 是一维Gauss-Legendre积分点和权重，它们被缩放到区间 $[0,1]$ 上，而 $F_k(u,v)$ 是变换后的正则被积函数。\n\n总积分 $I$ 是三个子三角形积分结果的总和。这个推导出的方案对于严格位于参考三角形内部的任何奇异点 $(\\xi_\\mathrm{p}, \\eta_\\mathrm{p})$ 都是稳健的。实现过程将构建单元几何形状，对每个子三角形执行所述的变换，并使用高阶高斯积分计算积分。通过将实用阶数积分 ($q=12$) 的结果与高精度参考解 ($q_{\\mathrm{ref}}=50$) 进行比较来完成验证。", "answer": "```python\nimport numpy as np\n\n# This program implements a singular quadrature scheme based on coordinate\n# transformation to evaluate weakly singular 1/R integrals over a curved\n# quadratic triangular element. The scheme is validated by comparing its\n# results against a high-accuracy reference computation.\n\ndef create_nodes(epsilon):\n    \"\"\"\n    Creates the 6 nodal coordinates of the curved quadratic triangle.\n    The geometry is defined by projecting points from a planar triangle\n    onto the surface z = epsilon * (x^2 + y^2).\n    \"\"\"\n    xy_coords = np.array([\n        [0.0, 0.0], [1.0, 0.0], [0.0, 1.0],  # Vertices (Nodes 1, 2, 3)\n        [0.5, 0.0], [0.5, 0.5], [0.0, 0.5]   # Midside nodes (Nodes 4, 5, 6)\n    ], dtype=np.float64)\n    z_coords = epsilon * (xy_coords[:, 0]**2 + xy_coords[:, 1]**2)\n    nodes = np.hstack([xy_coords, z_coords[:, np.newaxis]])\n    return nodes\n\nclass IsoparametricQuadraticTriangle:\n    \"\"\"\n    Handles geometric mappings and derivatives for a 6-node quadratic triangle.\n    \"\"\"\n    def __init__(self, nodes):\n        self.nodes = nodes\n\n    def shape_functions(self, xi, eta):\n        L = np.empty((3,) + xi.shape, dtype=np.float64)\n        L[0] = 1.0 - xi - eta\n        L[1] = xi\n        L[2] = eta\n        \n        N = np.empty((6,) + xi.shape, dtype=np.float64)\n        N[0] = L[0] * (2 * L[0] - 1)\n        N[1] = L[1] * (2 * L[1] - 1)\n        N[2] = L[2] * (2 * L[2] - 1)\n        N[3] = 4 * L[0] * L[1]\n        N[4] = 4 * L[1] * L[2]\n        N[5] = 4 * L[2] * L[0]\n        return N\n\n    def shape_function_derivatives(self, xi, eta):\n        L = np.empty((3,) + xi.shape, dtype=np.float64)\n        L[0] = 1.0 - xi - eta\n        L[1] = xi\n        L[2] = eta\n\n        dN_dxi = np.empty((6,) + xi.shape, dtype=np.float64)\n        dN_deta = np.empty((6,) + xi.shape, dtype=np.float64)\n        \n        dN_dxi[0] = -1.0 * (4 * L[0] - 1)\n        dN_dxi[1] = (4 * L[1] - 1)\n        dN_dxi[2] = 0.0\n        dN_dxi[3] = 4 * (L[0] - L[1])\n        dN_dxi[4] = 4 * L[2]\n        dN_dxi[5] = -4 * L[2]\n\n        dN_deta[0] = -1.0 * (4 * L[0] - 1)\n        dN_deta[1] = 0.0\n        dN_deta[2] = (4 * L[2] - 1)\n        dN_deta[3] = -4 * L[1]\n        dN_deta[4] = 4 * L[1]\n        dN_deta[5] = 4 * (L[0] - L[2])\n        \n        # Stack into a (2, 6, ...) array for dN/dxi, dN/deta\n        return np.stack([dN_dxi, dN_deta], axis=0)\n\n    def map_to_surface(self, xi, eta):\n        N = self.shape_functions(xi, eta)\n        return np.tensordot(N, self.nodes, axes=([0], [0]))\n\n    def surface_derivatives(self, xi, eta):\n        dN_d_param = self.shape_function_derivatives(xi, eta)\n        r_derivs = np.tensordot(dN_d_param, self.nodes, axes=([1], [0]))\n        r_xi = r_derivs[0]\n        r_eta = r_derivs[1]\n        return r_xi, r_eta\n\ndef compute_singular_integral(element, xi_p, eta_p, q_order):\n    \"\"\"\n    Computes the singular integral using the derived transformation method.\n    \"\"\"\n    gp, gw = np.polynomial.legendre.leggauss(q_order)\n    # Scale points and weights to [0, 1]\n    u_pts = 0.5 * (gp + 1)\n    v_pts = 0.5 * (gp + 1)\n    u_wts = 0.5 * gw\n    v_wts = 0.5 * gw\n\n    U, V = np.meshgrid(u_pts, v_pts)\n    W_U, W_V = np.meshgrid(u_wts, v_wts)\n    Weights = W_U * W_V\n\n    r_p = element.map_to_surface(np.array(xi_p), np.array(eta_p))\n\n    V1 = np.array([0.0, 0.0])\n    V2 = np.array([1.0, 0.0])\n    V3 = np.array([0.0, 1.0])\n    P = np.array([xi_p, eta_p])\n\n    sub_triangles = [(V1, V2, P), (V2, V3, P), (V3, V1, P)]\n    total_integral = 0.0\n\n    r_p_xi, r_p_eta = element.surface_derivatives(np.array(xi_p), np.array(eta_p))\n    \n    for A, B, P_vert in sub_triangles:\n        # Jacobian of the (u,v) -> (xi,eta) transformation\n        J_uv_factor = np.linalg.det(np.array([A - P_vert, B - P_vert]))\n\n        # Parametric mapping from (U,V) to (xi, eta)\n        d_vec = (B - A)[:, np.newaxis, np.newaxis] \\\n                * V[np.newaxis, :, :] + (A - P_vert)[:, np.newaxis, np.newaxis]\n        \n        xi = P_vert[0] + U * d_vec[0]\n        eta = P_vert[1] + U * d_vec[1]\n        \n        r = element.map_to_surface(xi, eta)\n        r_xi, r_eta = element.surface_derivatives(xi, eta)\n\n        dist_R = np.linalg.norm(r - r_p, axis=-1)\n        surface_jacobian = np.linalg.norm(np.cross(r_xi, r_eta, axis=-1), axis=-1)\n        \n        u_over_R = np.zeros_like(U)\n\n        # Analytical limit of u/R as u -> 0\n        d_vec_v = (B - A)[:, np.newaxis] * v_pts[np.newaxis, :] + (A-P_vert)[:, np.newaxis]\n        limit_denom = np.linalg.norm(r_p_xi[np.newaxis,:] * d_vec_v[0,:,np.newaxis] + \\\n                                     r_p_eta[np.newaxis,:] * d_vec_v[1,:,np.newaxis], axis=-1)\n        limit_val = 1.0 / limit_denom\n        limit_val = np.tile(limit_val, (q_order, 1))\n\n        # Use analytical limit where u is very small, otherwise direct computation.\n        mask_small_u = U  1e-12\n        u_over_R[mask_small_u] = limit_val[mask_small_u]\n        u_over_R[~mask_small_u] = U[~mask_small_u] / dist_R[~mask_small_u]\n\n        transformed_integrand = surface_jacobian * u_over_R * abs(J_uv_factor)\n        \n        sub_integral = np.sum(transformed_integrand * Weights)\n        total_integral += sub_integral\n\n    return total_integral\n\n\ndef solve():\n    test_cases = [\n        {'epsilon': 0.2, 'xi_p': 0.3, 'eta_p': 0.4},\n        {'epsilon': 0.2, 'xi_p': 1e-6, 'eta_p': 1e-6},\n        {'epsilon': 1e-3, 'xi_p': 0.3, 'eta_p': 0.4},\n        {'epsilon': 0.5, 'xi_p': 0.2, 'eta_p': 0.2},\n    ]\n\n    q_practical = 12\n    q_ref = 50\n    abs_errors = []\n\n    for case in test_cases:\n        epsilon = case['epsilon']\n        xi_p = case['xi_p']\n        eta_p = case['eta_p']\n        \n        nodes = create_nodes(epsilon)\n        element = IsoparametricQuadraticTriangle(nodes)\n\n        I_practical = compute_singular_integral(element, xi_p, eta_p, q_practical)\n        I_ref = compute_singular_integral(element, xi_p, eta_p, q_ref)\n        \n        abs_errors.append(abs(I_practical - I_ref))\n    \n    # Format output as specified\n    print(f\"[{','.join(f'{err:.10e}' for err in abs_errors)}]\")\n\nsolve()\n```", "id": "3346287"}, {"introduction": "从频域转向时域会引入一种与波传播因果律相关的不同类型的奇异性。这个实践问题旨在解决时域推迟格林函数的积分挑战，其奇异性位于扩展的“光锥”上。我们将使用一个平滑化函数来近似狄拉克$\\delta$函数，这是在时域边界元法中处理这种困难积分的一种实用方法。[@problem_id:3346348]", "problem": "考虑洛伦兹规范下的标量势 $\\phi(\\mathbf{r},t)$，该标量势满足由面源驱动的自由空间中的非齐次波动方程。边界元法 (BEM) 利用三维波动方程的推迟格林函数，将场评估简化为在剖分边界上的面积分。在时域BEM中，核函数在光锥上引入了一个奇异集中：位于位置 $\\mathbf{r}'$ 的面元的贡献在由光速 (c) 传播决定的时间 $t$ 到达观测点 $\\mathbf{r}$。这在对曲面元进行积分时带来了采样难题，因为狄拉克δ函数将贡献局域化在面板上满足 $|\\mathbf{r}-\\mathbf{r}'| = c\\,t$ 的一个细环上。\n\n从标量势的波动方程和自由空间中推迟格林函数的定义出发，实现一个时域BEM求积方法，用于近似计算由一个在时间 $t=0$ 时均匀分布在半径为 $a$ 的球面上的脉冲单位面源所产生的标量势 $\\phi(\\mathbf{r},t)$。使用球面元表示，其中极角 $\\theta\\in[0,\\pi]$ 和方位角 $\\phi\\in[0,2\\pi)$ 均以弧度为单位。假设观测点位于z轴上，与原点的距离为 $r_0$，即 $\\mathbf{r}=(0,0,r_0)$。该球面的参数化形式为 $\\mathbf{r}'(\\theta,\\phi) = a[\\sin\\theta\\cos\\phi,\\,\\sin\\theta\\sin\\phi,\\,\\cos\\theta]$，其面元为 $\\mathrm{d}A = a^2\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$。需要进行数值计算的标量势积分（单位源密度）为\n$$\n\\Phi(r_0,t) \\equiv \\iint_{S} \\frac{\\delta\\!\\left(t-\\frac{|\\mathbf{r}-\\mathbf{r}'|}{c}\\right)}{4\\pi\\,|\\mathbf{r}-\\mathbf{r}'|}\\,\\mathrm{d}A,\n$$\n其中 $\\delta(\\cdot)$ 表示狄拉克δ函数。为了能够在曲面元（球面）上进行数值求积，使用宽度为 $\\sigma_t0$ 的归一化高斯磨光函数来近似狄拉克δ函数：\n$$\n\\delta_{\\sigma_t}(x) \\equiv \\frac{1}{\\sqrt{2\\pi}\\,\\sigma_t}\\exp\\!\\left(-\\frac{x^2}{2\\sigma_t^2}\\right).\n$$\n您的程序必须：\n- 通过均匀角度采样将球面离散化，极角方向有 $N_\\theta$ 个样本，方位角方向有 $N_\\phi$ 个样本，两个角度均使用中点求积法；曲面权重为 $a^2\\sin\\theta\\,\\Delta\\theta\\,\\Delta\\phi$，其中 $\\Delta\\theta=\\pi/N_\\theta$ 且 $\\Delta\\phi=2\\pi/N_\\phi$。\n- 通过上述磨光δ函数实现推迟格林函数核，计算 $R(\\theta)\\equiv|\\mathbf{r}-\\mathbf{r}'|=\\sqrt{r_0^2+a^2-2ar_0\\cos\\theta}$ 并计算\n$$\n\\Phi_{\\mathrm{num}}(r_0,t;N_\\theta,N_\\phi,\\sigma_t) \\equiv \\sum_{i=1}^{N_\\theta}\\sum_{j=1}^{N_\\phi} \\frac{\\delta_{\\sigma_t}\\!\\left(t-\\frac{R(\\theta_i)}{c}\\right)}{4\\pi\\,R(\\theta_i)}\\,a^2\\sin\\theta_i\\,\\Delta\\theta\\,\\Delta\\phi.\n$$\n- 使用 $c=299792458\\,\\mathrm{m/s}$ 和 $a=1\\,\\mathrm{m}$。\n\n对于此几何结构，存在一个依赖于观测距离 $r_0$ 和时间窗 $t\\in\\left[\\frac{|r_0-a|}{c},\\,\\frac{r_0+a}{c}\\right]$ 的积分的解析参考解。在您的分析和代码中，推导并使用此参考解来计算数值求积的误差。\n\n设计一个测试套件，用于探究曲面球上光锥奇异求积的不同方面：\n- 改变 $r_0$ 以测试 $r_0  a$（观察者在球内）和 $r_0 > a$（观察者在球外）的情况。\n- 在每个 $r_0$ 情况下，在解析时间窗的中心、边界附近和窗外对势进行求值。\n- 通过使用更高分辨率的离散化和更窄的高斯磨光函数来测试数值收敛性。\n\n测试用例：\n1.  `r0=0.5`（在球内），时间在解析窗的中心，使用 `N_theta=48` 和 `sigma_t=1e-10`。\n2.  `r0=0.5`，时间在解析窗的下边界附近 (`t_min + 1e-11`)，使用 `N_theta=48` 和 `sigma_t=1e-11`。\n3.  `r0=0.5`，时间在解析窗的上边界附近 (`t_max - 1e-11`)，使用 `N_theta=192` 和 `sigma_t=5e-12`（更高精度）。\n4.  `r0=0.5`，时间在解析窗外 (`t_max + 3e-11`)，使用 `N_theta=192` 和 `sigma_t=1e-11`。\n5.  `r0=1.5`（在球外），时间在解析窗的中心，使用 `N_theta=48` 和 `sigma_t=1e-10`。\n6.  `r0=1.5`，时间在解析窗的下边界附近 (`t_min + 1e-11`)，使用 `N_theta=48` 和 `sigma_t=1e-11`。\n7.  `r0=1.5`，时间在解析窗的上边界附近 (`t_max - 1e-11`)，使用 `N_theta=192` 和 `sigma_t=5e-12`（更高精度）。\n8.  `r0=1.5`，时间在解析窗外 (`t_max + 3e-11`)，使用 `N_theta=192` 和 `sigma_t=1e-11`。\n\n对于每个在解析时间窗内的测试用例，报告数值解与解析解之间的相对误差。对于窗外的测试用例，报告数值解的绝对值，以量化由磨光函数引起的数值泄漏。您的程序应生成一行输出，其中包含用方括号括起来的八个逗号分隔的结果列表。", "solution": "首先，验证问题以确保其科学上合理、良定且客观。该问题描述了计算电磁学中的一个标准场景：使用时域边界元法(BEM)计算由脉冲面源产生的推迟标量势。其中，使用波动方程的推迟格林函数，将其表示为包含狄拉克δ函数的积分，以及随后为进行数值求积而使用高斯磨光函数近似δ函数，这些都是成熟的技术。问题提供了所有必要的物理参数（$c=299792458\\,\\mathrm{m/s}$，$a=1\\,\\mathrm{m}$）、数值参数（$N_\\theta, N_\\phi, \\sigma_t$）以及清晰的几何设置（半径为 a 的球面和位于z轴上 z=r0 处的观察者）。该任务要求推导此特定配置的解析解，作为数值结果的基准。这种比较是验证数值代码的标准做法。问题本身是自洽的、无歧义的，并且没有科学缺陷。因此，该问题被认定为有效，我们着手进行求解。\n\n解决方案分为两部分：首先，推导解析参考解；其次，设计数值算法以计算近似解及其误差。\n\n**1. 解析参考解**\n\n在观测点 $\\mathbf{r}=(0,0,r_0)$ 处，由半径为 $a$ 的球面 $S$ 上的脉冲单位面源产生的标量势 $\\Phi(r_0,t)$ 由以下积分给出：\n$$\n\\Phi(r_0,t) = \\iint_{S} \\frac{\\delta\\!\\left(t-\\frac{|\\mathbf{r}-\\mathbf{r}'|}{c}\\right)}{4\\pi\\,|\\mathbf{r}-\\mathbf{r}'|}\\,\\mathrm{d}A\n$$\n球面上的源点参数化为 $\\mathbf{r}'(\\theta,\\phi) = a(\\sin\\theta\\cos\\phi, \\sin\\theta\\sin\\phi, \\cos\\theta)$，面元为 $\\mathrm{d}A = a^2\\sin\\theta\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi$。观测点与源点之间的距离 $R = |\\mathbf{r}-\\mathbf{r}'|$ 计算如下：\n$$\nR(\\theta) = \\sqrt{(0 - a\\sin\\theta\\cos\\phi)^2 + (0 - a\\sin\\theta\\sin\\phi)^2 + (r_0 - a\\cos\\theta)^2} = \\sqrt{r_0^2+a^2-2ar_0\\cos\\theta}\n$$\n由于围绕z轴的旋转对称性，$R$ 仅是 $\\theta$ 的函数。因此，被积函数与方位角 $\\phi$ 无关。可以立即对 $\\phi$ 从 $0$ 到 $2\\pi$ 进行积分，得到一个因子 $2\\pi$：\n$$\n\\Phi(r_0,t) = \\int_{0}^{\\pi} \\frac{\\delta(t - R(\\theta)/c)}{4\\pi R(\\theta)} a^2\\sin\\theta (2\\pi) \\mathrm{d}\\theta = \\frac{a^2}{2} \\int_{0}^{\\pi} \\frac{\\delta(t - R(\\theta)/c)}{R(\\theta)} \\sin\\theta \\mathrm{d}\\theta\n$$\n为计算含有狄拉克δ函数的剩余积分，我们进行积分换元，从 $\\theta$ 换为 $R$。根据 $R(\\theta)$ 的表达式，我们有 $R^2 = r_0^2+a^2-2ar_0\\cos\\theta$。对 $\\theta$ 求导可得：\n$$\n2R\\,\\frac{\\mathrm{d}R}{\\mathrm{d}\\theta} = 2ar_0\\sin\\theta \\implies \\sin\\theta\\,\\mathrm{d}\\theta = \\frac{R}{ar_0}\\,\\mathrm{d}R\n$$\n新变量 $R$ 的积分限由 $\\theta$ 在其端点处的值确定：\n当 $\\theta=0$ 时，$R(0) = \\sqrt{(r_0-a)^2} = |r_0-a|$。\n当 $\\theta=\\pi$ 时，$R(\\pi) = \\sqrt{(r_0+a)^2} = r_0+a$。\n\n将换元代入 $\\Phi(r_0,t)$ 的积分中：\n$$\n\\Phi(r_0,t) = \\frac{a^2}{2} \\int_{|r_0-a|}^{r_0+a} \\frac{\\delta(t - R/c)}{R} \\left(\\frac{R}{ar_0}\\,\\mathrm{d}R\\right) = \\frac{a}{2r_0} \\int_{|r_0-a|}^{r_0+a} \\delta(t-R/c)\\,\\mathrm{d}R\n$$\n现在，令 $u = R/c$，这意味着 $\\mathrm{d}R = c\\,\\mathrm{d}u$。$u$ 的积分限变为 $\\frac{|r_0-a|}{c}$ 和 $\\frac{r_0+a}{c}$：\n$$\n\\Phi(r_0,t) = \\frac{a}{2r_0} \\int_{\\frac{|r_0-a|}{c}}^{\\frac{r_0+a}{c}} \\delta(t-u) (c\\,\\mathrm{d}u) = \\frac{ac}{2r_0} \\int_{\\frac{|r_0-a|}{c}}^{\\frac{r_0+a}{c}} \\delta(u-t)\\,\\mathrm{d}u\n$$\n狄拉克δ函数的筛选性质表明，如果 $x_0 \\in (A,B)$，则 $\\int_A^B \\delta(x-x_0)\\,\\mathrm{d}x = 1$；如果 $x_0 \\notin [A,B]$，则为 $0$。这导出了参考解 $\\Phi_{\\mathrm{ref}}$：\n$$\n\\Phi_{\\mathrm{ref}}(r_0,t) = \n\\begin{cases} \n\\frac{ac}{2r_0}  \\text{for } t \\in \\left[\\frac{|r_0-a|}{c}, \\frac{r_0+a}{c}\\right] \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n此解在 $r_0  0$ 时有效。它表明，在从观测点看去光波扫过球面的相应时间间隔内，势是恒定的。\n\n**2. 数值求积算法**\n\n数值近似解 $\\Phi_{\\mathrm{num}}$ 由以下离散和给出：\n$$\n\\Phi_{\\mathrm{num}}(r_0,t;N_\\theta,N_\\phi,\\sigma_t) \\equiv \\sum_{i=1}^{N_\\theta}\\sum_{j=1}^{N_\\phi} \\frac{\\delta_{\\sigma_t}\\!\\left(t-\\frac{R(\\theta_i)}{c}\\right)}{4\\pi\\,R(\\theta_i)}\\,a^2\\sin\\theta_i\\,\\Delta\\theta\\,\\Delta\\phi\n$$\n其中 $\\delta_{\\sigma_t}(x)$ 是高斯磨光函数 $\\frac{1}{\\sqrt{2\\pi}\\,\\sigma_t}\\exp(-\\frac{x^2}{2\\sigma_t^2})$。离散化采用中点法则，$\\theta_i = (i-0.5)\\Delta\\theta$ for $i=1, \\dots, N_\\theta$，其中 $\\Delta\\theta = \\pi/N_\\theta$。\n\n由于被加项与方位角 $\\phi$ 无关，对索引 $j$ 的求和可以简化。方位角方向上的面元权重之和为 $\\sum_{j=1}^{N_\\phi} \\Delta\\phi = N_\\phi \\times (2\\pi/N_\\phi) = 2\\pi$。这将双重求和简化为对 $\\theta$ 的单个求和：\n$$\n\\Phi_{\\mathrm{num}} = \\sum_{i=1}^{N_\\theta} \\frac{\\delta_{\\sigma_t}\\!\\left(t-\\frac{R(\\theta_i)}{c}\\right)}{4\\pi\\,R(\\theta_i)} a^2\\sin\\theta_i\\,\\Delta\\theta (2\\pi) = \\frac{a^2 \\Delta\\theta}{2} \\sum_{i=1}^{N_\\theta} \\frac{\\sin\\theta_i}{R(\\theta_i)} \\delta_{\\sigma_t}\\!\\left(t - \\frac{R(\\theta_i)}{c}\\right)\n$$\n实现遵循以下步骤：\n1. 对每个具有参数 $(r_0, t, N_\\theta, N_\\phi, \\sigma_t)$ 的测试用例，开始计算。\n2. 极角步长为 $\\Delta\\theta = \\pi/N_\\theta$。生成一个中点角度 $\\theta_i$ 的数组。\n3. 以矢量化方式为所有 $\\theta_i$ 值计算相应的距离 $R_i = R(\\theta_i)$ 和推迟时间参数 $x_i = t - R_i/c$。\n4. 为每个 $x_i$ 计算高斯磨光函数 $\\delta_{\\sigma_t}(x_i)$。\n5. 根据上述简化的数值公式计算对 $i$ 的求和，以获得 $\\Phi_{\\mathrm{num}}$。\n6. 确定解析时间窗 $[t_{\\min}, t_{\\max}] = [\\frac{|r_0-a|}{c}, \\frac{r_0+a}{c}]$。\n7. 如果评估时间 $t$ 落在此时间窗内，则参考解为 $\\Phi_{\\mathrm{ref}} = \\frac{ac}{2r_0}$，并计算相对误差 $\\varepsilon = (\\Phi_{\\mathrm{num}}-\\Phi_{\\mathrm{ref}})/\\Phi_{\\mathrm{ref}}$。\n8. 如果 $t$ 在时间窗外，则参考解为 $0$。根据规定，报告数值势的绝对值 $\\Phi_{\\mathrm{num}}$。该值量化了由磨光函数引起的数值泄漏。\n9. 收集所有测试用例的结果，并按指定格式输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the BEM quadrature test suite and produce the final output.\n    \"\"\"\n    # Define physical constants as per the problem statement\n    C = 299792458.0  # Speed of Light (c) in m/s\n    A = 1.0          # Sphere radius (a) in m\n\n    def gaussian_mollifier(x, sigma_t):\n        \"\"\"\n        Computes the normalized Gaussian mollifier to approximate the Dirac delta function.\n        \"\"\"\n        if sigma_t == 0:\n            return np.zeros_like(x)\n        \n        # Calculate the argument of the exponential function\n        arg = -0.5 * (x / sigma_t)**2\n        \n        # Using a mask to avoid computing exp for very small arguments, ensuring numerical stability\n        val = np.zeros_like(arg, dtype=float)\n        mask = arg > -700 # Below this, exp(arg) is effectively zero\n        val[mask] = np.exp(arg[mask])\n\n        return (1.0 / (np.sqrt(2.0 * np.pi) * sigma_t)) * val\n\n    def calculate_phi_num(r0, t, N_theta, sigma_t):\n        \"\"\"\n        Computes the numerical approximation of the scalar potential using midpoint quadrature.\n        The formula is simplified by analytically integrating over the azimuthal angle.\n        \"\"\"\n        delta_theta = np.pi / N_theta\n        \n        # Midpoint quadrature points for the polar angle theta\n        theta_i = (np.arange(1, N_theta + 1) - 0.5) * delta_theta\n\n        # Distance R(theta) from observation point to points on the sphere surface\n        R_i = np.sqrt(r0**2 + A**2 - 2 * A * r0 * np.cos(theta_i))\n        \n        # Argument for the mollified delta function (retarded time difference)\n        retarded_time_diff = t - R_i / C\n        \n        # Evaluate the mollifier at each quadrature point\n        delta_vals = gaussian_mollifier(retarded_time_diff, sigma_t)\n        \n        # Compute the summand for each theta panel\n        summand = (np.sin(theta_i) / R_i) * delta_vals\n        \n        # Final numerical potential from the sum over theta\n        # The pre-factor a^2 * delta_theta / 2 comes from simplifying the original double sum\n        phi_num = (A**2 * delta_theta / 2.0) * np.sum(summand)\n        \n        return phi_num\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Test 1: r0=0.5, mid-window\n        {'r0': 0.5, 't_expr': lambda t_min, t_max: (t_min + t_max) / 2.0, \n         'N_theta': 48, 'N_phi': 96, 'sigma_t': 1e-10},\n        # Test 2: r0=0.5, near-lower-boundary\n        {'r0': 0.5, 't_expr': lambda t_min, t_max: t_min + 1e-11, \n         'N_theta': 48, 'N_phi': 96, 'sigma_t': 1e-11},\n        # Test 3: r0=0.5, near-upper-boundary\n        {'r0': 0.5, 't_expr': lambda t_min, t_max: t_max - 1e-11, \n         'N_theta': 192, 'N_phi': 384, 'sigma_t': 5e-12},\n        # Test 4: r0=0.5, outside-window\n        {'r0': 0.5, 't_expr': lambda t_min, t_max: t_max + 3e-11, \n         'N_theta': 192, 'N_phi': 384, 'sigma_t': 1e-11},\n        # Test 5: r0=1.5, mid-window\n        {'r0': 1.5, 't_expr': lambda t_min, t_max: (t_min + t_max) / 2.0, \n         'N_theta': 48, 'N_phi': 96, 'sigma_t': 1e-10},\n        # Test 6: r0=1.5, near-lower-boundary\n        {'r0': 1.5, 't_expr': lambda t_min, t_max: t_min + 1e-11, \n         'N_theta': 48, 'N_phi': 96, 'sigma_t': 1e-11},\n        # Test 7: r0=1.5, near-upper-boundary\n        {'r0': 1.5, 't_expr': lambda t_min, t_max: t_max - 1e-11, \n         'N_theta': 192, 'N_phi': 384, 'sigma_t': 5e-12},\n        # Test 8: r0=1.5, outside-window\n        {'r0': 1.5, 't_expr': lambda t_min, t_max: t_max + 3e-11, \n         'N_theta': 192, 'N_phi': 384, 'sigma_t': 1e-11},\n    ]\n\n    results = []\n    for case in test_cases:\n        r0 = case['r0']\n        N_theta = case['N_theta']\n        sigma_t = case['sigma_t']\n        \n        # Calculate the analytical time window boundaries\n        t_min = np.abs(r0 - A) / C\n        t_max = (r0 + A) / C\n        \n        # Determine the evaluation time t based on the test case expression\n        t = case['t_expr'](t_min, t_max)\n        \n        # Compute the numerical solution (N_phi is not needed due to simplification)\n        phi_num = calculate_phi_num(r0, t, N_theta, sigma_t)\n        \n        # Determine whether to report relative error or absolute value\n        if t_min = t = t_max:\n            # Time is inside the window, calculate relative error\n            phi_ref = A * C / (2 * r0)\n            relative_error = (phi_num - phi_ref) / phi_ref\n            results.append(relative_error)\n        else:\n            # Time is outside the window, report absolute numerical leakage\n            results.append(phi_num)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3346348"}]}