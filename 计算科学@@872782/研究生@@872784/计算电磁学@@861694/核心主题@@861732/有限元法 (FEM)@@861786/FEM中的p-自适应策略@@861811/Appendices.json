{"hands_on_practices": [{"introduction": "`$p$-refinement`策略的核心吸引力在于其对光滑问题所能达到的指数收敛率。本练习旨在通过分析一个具有解析解的简化一维波动问题，来揭示这一关键理论。通过应用经典的解析函数逼近理论，您将亲自推导出形如 $C \\exp(-\\alpha p)$ 的误差上界，从而巩固对为何`$p$-refinement`策略在处理光滑解问题时表现卓越的理解。[@problem_id:3314615]", "problem": "考虑均匀无损介质中的时谐电磁场的一维代理模型，其精确的复电场分量由闭区间 $\\Omega = [-1,1]$ 上的解析函数 $u(x) = \\exp(\\mathrm{i}\\kappa x)$ 给出，其中实波数 $\\kappa > 0$。该场将通过在 $\\Omega$ 上使用单单元 `$hp$-有限元法`（Finite Element Method (FEM)）进行近似，其试验空间为定义在参考单元上次数至多为 $p$ 的多项式空间，即采用固定 $h$ 和可变 $p$ 的加密策略（`$hp$-加密`的一种极限情况）。假设误差在一致范数 $\\|\\cdot\\|_{L^{\\infty}(\\Omega)}$ 下度量。\n\n使用 $u$ 的解析性以及关于区间 $[-1,1]$ 上解析函数通过多项式空间逼近的标准逼近理论和 Bernstein 椭圆技术作为基本事实。特别地，回想对于一个在参数为 $\\rho > 1$ 的 Bernstein 椭圆 $\\mathcal{E}_{\\rho}$ 内部及边界上解析的函数（该椭圆是圆 $|w|=\\rho$ 在 Joukowski 映射 $z=\\frac{1}{2}(w+w^{-1})$下的像），其最大模为 $M_{\\rho} = \\max_{z\\in \\mathcal{E}_{\\rho}}|u(z)|$，在 $[-1,1]$ 上的最佳 $p$ 次多项式逼近误差在 $L^{\\infty}$ 范数下有上界 $\\frac{2M_{\\rho}}{\\rho - 1}\\rho^{-p}$。\n\n对于给定的解析场 $u(x) = \\exp(\\mathrm{i}\\kappa x)$ 和单单元离散化（这是一个长度为 2 的单单元的平凡网格剖分方案），将 Bernstein 椭圆参数设置为显式值 $\\rho = 2$。将离散解 $u_{hp}$ 视为多项式试验空间中的最佳逼近（由于在解析性条件下与 $L^{\\infty}$ 等价的范数中的准最优性，这为任何 Galerkin 解提供了一个严格上界）。\n\n计算显式常数 $C$ 和 $\\alpha$，使得对于所有多项式次数 $p \\in \\mathbb{N}$，以下界成立：\n$$\n\\|u - u_{hp}\\|_{L^{\\infty}(\\Omega)} \\le C \\exp(-\\alpha p).\n$$\n将最终答案表示为仅含 $\\kappa$ 的闭式解析表达式。不需要进行数值舍入，也不需要报告物理单位。角度单位是弧度。", "solution": "用户要求我解决一个问题。作为一名教授，我将首先验证该问题的陈述。\n\n### 步骤 1：提取已知条件\n-   **精确解：** 复电场分量由定义域 $\\Omega = [-1,1]$ 上的函数 $u(x) = \\exp(\\mathrm{i}\\kappa x)$ 给出，其中 $\\kappa > 0$ 是实波数。函数 $u(x)$ 是解析的。\n-   **近似方法：** 使用单单元 `$hp$-有限元法`（FEM），对应于在 $\\Omega$ 上使用次数至多为 $p$ 的多项式进行逼近。\n-   **误差范数：** 误差在一致范数 $\\| \\cdot \\|_{L^{\\infty}(\\Omega)}$ 下度量。\n-   **逼近理论界：** 对于在参数为 $\\rho > 1$ 的 Bernstein 椭圆 $\\mathcal{E}_{\\rho}$ 内部及边界上解析的函数 $u(z)$，最佳 $p$ 次多项式逼近误差有界：\n    $$ \\|u - u_p\\|_{L^{\\infty}([-1,1])} \\le \\frac{2M_{\\rho}}{\\rho - 1}\\rho^{-p} $$\n    其中 $M_{\\rho} = \\max_{z\\in \\mathcal{E}_{\\rho}}|u(z)|$。\n-   **特定参数：** Bernstein 椭圆参数设置为 $\\rho = 2$。\n-   **假设：** 有限元离散解 $u_{hp}$ 被视为最佳多项式逼近 $u_p$。\n-   **任务：** 找出关于 $\\kappa$ 的显式常数 $C$ 和 $\\alpha$，使得对于所有 $p \\in \\mathbb{N}$，以下界成立：\n    $$ \\|u - u_{hp}\\|_{L^{\\infty}(\\Omega)} \\le C \\exp(-\\alpha p) $$\n\n### 步骤 2：使用提取的已知条件进行验证\n根据指定标准对问题进行验证。\n\n-   **科学或事实不健全性：** 该问题在科学上是合理的。它是波传播数值方法理论中的一个标准模型问题，特别关注于亥姆霍兹方程的 `$p$`型和 `$hp$`型有限元法的收敛性分析。使用 Bernstein 椭圆和解析函数的逼近理论是此分析的基石。\n-   **非形式化或不相关：** 该问题与计算电磁学中的 `$hp$-加密`主题直接相关，并以形式化、数学化的方式陈述。\n-   **不完整或矛盾的设置：** 该问题是自洽的。它提供了精确解、逼近框架、要使用的显式误差界公式以及所有必要的参数（如 $\\rho=2$）。将有限元解视为最佳逼近的假设是此类分析中的标准简化步骤，使问题成为良定义的。\n-   **不切实际或不可行：** 在数值分析的理论背景下，所有条件都是标准的。\n-   **不适定或结构不良：** 该问题是适定的。在指定的框架内，预期常数 $C$ 和 $\\alpha$ 有唯一解。\n-   **伪深刻、平凡或同义反复：** 该问题是非平凡的，需要在给定的理论框架内，将复分析（Joukowski 映射，解析函数的性质）应用于特定函数。\n-   **超出科学可验证性范围：** 结果在数学上是可推导和可验证的。\n\n### 步骤 3：结论与行动\n该问题有效。将提供完整解答。\n\n### 解题推导\n\n目标是确定误差界 $\\|u - u_{hp}\\|_{L^{\\infty}(\\Omega)} \\le C \\exp(-\\alpha p)$ 中的常数 $C$ 和 $\\alpha$。问题陈述离散解 $u_{hp}$ 可以被视为 $p$ 次最佳多项式逼近，记为 $u_p$。我们已知最佳逼近误差的理论界：\n$$ \\|u - u_p\\|_{L^{\\infty}([-1,1])} \\le \\frac{2M_{\\rho}}{\\rho - 1}\\rho^{-p} $$\n已知 $\\rho = 2$。将此值代入该界可得：\n$$ \\|u - u_p\\|_{L^{\\infty}([-1,1])} \\le \\frac{2M_{2}}{2 - 1}2^{-p} = 2 M_2 2^{-p} $$\n下一步是计算 $M_2$，即 $u(x)$ 在 Bernstein 椭圆 $\\mathcal{E}_2$ 上的解析延拓的最大模。函数为 $u(x) = \\exp(\\mathrm{i}\\kappa x)$。其到复平面的解析延拓为 $u(z) = \\exp(\\mathrm{i}\\kappa z)$，其中 $z \\in \\mathbb{C}$。\n\n我们需要计算 $M_2 = \\max_{z \\in \\mathcal{E}_2} |u(z)|$。令 $z = x + \\mathrm{i}y$。$u(z)$ 的模为：\n$$ |u(z)| = |\\exp(\\mathrm{i}\\kappa(x + \\mathrm{i}y))| = |\\exp(\\mathrm{i}\\kappa x - \\kappa y)| = |\\exp(\\mathrm{i}\\kappa x)| \\cdot |\\exp(-\\kappa y)| = 1 \\cdot \\exp(-\\kappa y) = \\exp(-\\kappa y) $$\n因为波数 $\\kappa$ 给定为正 ($\\kappa > 0$)，所以函数 $\\exp(-\\kappa y)$ 是 $y$ 的严格递减函数。因此，它在椭圆 $\\mathcal{E}_2$ 上的最大值将出现在虚部 $y$ 取最小值的点。\n\nBernstein 椭圆 $\\mathcal{E}_{\\rho}$ 由 Joukowski 映射 $z = \\frac{1}{2}(w + w^{-1})$ 应用于复 $w$-平面中的圆 $|w| = \\rho$ 定义。令 $w = \\rho \\exp(\\mathrm{i}\\theta)$，其中 $\\theta \\in [0, 2\\pi)$。那么 $z$ 由下式给出：\n$$ z(\\theta) = \\frac{1}{2} \\left(\\rho \\exp(\\mathrm{i}\\theta) + \\frac{1}{\\rho} \\exp(-\\mathrm{i}\\theta) \\right) $$\n展开复指数：\n$$ z(\\theta) = \\frac{1}{2} \\left( \\rho(\\cos\\theta + \\mathrm{i}\\sin\\theta) + \\frac{1}{\\rho}(\\cos\\theta - \\mathrm{i}\\sin\\theta) \\right) $$\n$$ z(\\theta) = \\frac{1}{2} \\left(\\rho + \\frac{1}{\\rho}\\right)\\cos\\theta + \\mathrm{i} \\frac{1}{2}\\left(\\rho - \\frac{1}{\\rho}\\right)\\sin\\theta $$\n$z$ 的虚部是 $y(\\theta) = \\frac{1}{2}(\\rho - \\frac{1}{\\rho})\\sin\\theta$。因为 $\\rho > 1$，所以项 $(\\rho - \\frac{1}{\\rho})$ 是正的。$y(\\theta)$ 的最小值在 $\\sin\\theta = -1$ 时取得，这给出：\n$$ y_{\\min} = -\\frac{1}{2}\\left(\\rho - \\frac{1}{\\rho}\\right) $$\n现在我们可以计算 $M_{\\rho}$：\n$$ M_{\\rho} = \\max_{z \\in \\mathcal{E}_{\\rho}} \\exp(-\\kappa y) = \\exp(-\\kappa y_{\\min}) = \\exp\\left(\\kappa \\frac{1}{2}\\left(\\rho - \\frac{1}{\\rho}\\right)\\right) $$\n对于 $\\rho = 2$ 的特定情况，$y$ 的最小值为：\n$$ y_{\\min} = -\\frac{1}{2}\\left(2 - \\frac{1}{2}\\right) = -\\frac{1}{2}\\left(\\frac{3}{2}\\right) = -\\frac{3}{4} $$\n最大模 $M_2$ 为：\n$$ M_2 = \\exp(-\\kappa y_{\\min}) = \\exp\\left(-\\kappa \\left(-\\frac{3}{4}\\right)\\right) = \\exp\\left(\\frac{3\\kappa}{4}\\right) $$\n将 $M_2$ 的这个表达式代入我们的误差界：\n$$ \\|u - u_p\\|_{L^{\\infty}([-1,1])} \\le 2 \\exp\\left(\\frac{3\\kappa}{4}\\right) 2^{-p} $$\n为了匹配目标形式 $C \\exp(-\\alpha p)$，我们使用自然指数函数重写项 $2^{-p}$：\n$$ 2^{-p} = (e^{\\ln 2})^{-p} = \\exp(-p \\ln 2) $$\n因此误差界变为：\n$$ \\|u - u_p\\|_{L^{\\infty}([-1,1])} \\le 2 \\exp\\left(\\frac{3\\kappa}{4}\\right) \\exp(-(\\ln 2)p) $$\n将此与形式 $C \\exp(-\\alpha p)$ 进行比较，我们可以识别出常数 $C$ 和 $\\alpha$：\n$$ C = 2 \\exp\\left(\\frac{3\\kappa}{4}\\right) $$\n$$ \\alpha = \\ln 2 $$\n这些常数按要求用 $\\kappa$ 表示。", "answer": "$$\n\\boxed{\n\\begin{pmatrix} C \\\\ \\alpha \\end{pmatrix} = \\begin{pmatrix} 2 \\exp(\\frac{3\\kappa}{4}) \\\\ \\ln 2 \\end{pmatrix}\n}\n$$", "id": "3314615"}, {"introduction": "在掌握了理论基础后，我们需要将目光转向更复杂的实际应用。真实的工程问题很少是全局光滑的，常常在几何尖角等位置伴有场奇异性，同时我们还必须确保数值分辨率足以抑制色散误差。本练习将实现一个多项式次数选择算法，该算法旨在平衡这些相互竞争的需求：在奇异点附近（高阶多项式效率低下）使用较低的 `$p$`值，在光滑区域（以利用其解析性）使用较高的 `$p$`值，并强制一个由波数和单元尺寸决定的最小 `$p$`值以控制波的传播误差。这项实践让您亲身体验一个实用的 `$hp$`自适应策略是如何构建的，从理想化的理论过渡到具体的算法设计。[@problem_id:3314596]", "problem": "您的任务是为二维时谐计算电磁学 (CEM) 实现一个有原则的多项式次数选择算法，该算法使用有限元法 (FEM) 和混合网格尺寸与多项式次数加密 (`$hp$-refinement`)。目标是为一个包含光滑区域和导致场奇异性的凹角的域，在给定网格上确定每个单元的多项式次数。\n\n基础理论。对于单个极化分量，二维时谐麦克斯韦方程组可简化为关于场分量的旋度-旋度亥姆霍兹型方程，其波数为 $k$。一个经过充分检验的事实是，在多边形域中，内角 $\\theta$ 大于 $\\pi$ 的凹角会引起一个局部奇异性，其形式为角点奇异指数 $\\lambda = \\pi/\\theta$，这意味着在此类角点附近的正则性会降低。相反，在远离凹角和材料不连续性的区域，场是光滑的，并且通常是解析的，这使得通过多项式增阶可以获得优越的收敛性。此外，为了控制有限元法中的波色散误差，一个常用的解析度准则是无量纲比 `$k h / p$` 应受限于一个预设常数，其中 $h$ 是单元尺寸，$p$ 是单元上的多项式次数。\n\n决策问题。您必须实现一个决策算法，该算法在给定单元尺寸、相对于指定凹角的位置、波数 $k$ 以及目标单元容差的情况下，将单元分类为受角点奇异性局部影响或光滑。然后，它必须通过结合以下几点来为每个单元选择多项式次数 $p$：\n- 奇异邻域中考虑正则性的上限，\n- 光滑区域中为满足目标容差而由解析性驱动的选择，\n- 以及控制色散的波解析度约束。\n\n为进行本练习，请采用以下具体且保守的数值常数和建模基元，这些基元仅为使任务适定且可测试而标准化：\n- 如果角 $\\theta > \\pi$，则该角被视为凹角，因此是奇异的。对于位于位置 $(x_c,y_c)$、角度为 $\\theta$ 的此类角，定义其奇异指数为 $\\lambda = \\pi/\\theta$。\n- 对于形心为 $(x_e,y_e)$、尺寸为 $h_e$ 的单元，将其到任意凹角的最小欧几里得距离定义为 $d_e$，如果 $d_e \\le \\alpha h_e$（其中 $\\alpha = 1.5$），则声明该单元位于奇异邻域内。如果没有凹角，则所有单元均被视为光滑。\n- 在奇异邻域中，设置一个基于正则性的上限 `$p_{\\text{cap}} = \\lfloor \\lambda + 0.5 \\rfloor$`，然后定义奇异邻域的基础选择 `$p_{\\text{sing}} = \\max(p_{\\min}, \\min(p_{\\text{cap}}, p_{\\text{max,sing}}))$`，其中 `$p_{\\min} = 1$` 且 `$p_{\\text{max,sing}} = 3$`。\n- 在光滑区域中，使用一个解析误差模型，其单元误差随 $p$ 呈指数衰减，形式为 `$\\text{error} \\approx A_e \\exp(-b p)$`，并选择 $p$ 为满足目标容差 $\\tau$ 的最小整数。在本练习中，使用 `$A_e = (k h_e)^{1}$`，`$b = 0.6$`，以及每个测试用例给定的 $\\tau$。也就是说，选择 `$p_{\\text{smooth}}$` 作为满足 `$A_e \\exp(-b p) \\le \\tau$` 的最小整数。\n- 通过强制 `$p \\ge p_{\\text{disp}} = \\lceil k h_e / \\chi \\rceil$` 来施加波解析度约束 `$k h_e / p \\le \\chi$`，其中 `$\\chi = 0.5$`。\n- 最后，强制施加全局界限 `$p_{\\min} \\le p \\le p_{\\max}$`（其中 `$p_{\\max} = 8$`），并设置\n$$\np_e = \\min\\left(p_{\\max}, \\max\\left(p_{\\text{disp}}, \\begin{cases}\np_{\\text{sing}}  \\text{if in singular neighborhood},\\\\\np_{\\text{smooth}}  \\text{otherwise.}\n\\end{cases}\\right)\\right).\n$$\n\n输入规范嵌入在下方的测试套件中。所有几何坐标都在一个统一的笛卡尔坐标系中，距离单位与 $h_e$ 相同，波数 $k$ 的单位是长度的倒数。最终答案是每个单元的无单位整数。\n\n测试套件。请对以下五个案例实现该算法。在每个案例中，您会得到：\n- 一个单元列表，每个单元包含其形心 $(x_e,y_e)$ 和尺寸 $h_e$，\n- 一个波数 $k$，\n- 一组由 $(x_c,y_c,\\theta)$ 指定的凹角，其中 $\\theta$ 以弧度为单位，\n- 以及一个要在光滑区域强制执行的目标容差 $\\tau$。\n\n请完全按照上面指定的方式使用常数 `$\\alpha = 1.5$`，`$p_{\\min} = 1$`，`$p_{\\max} = 8$`，`$p_{\\text{max,sing}} = 3$`，`$\\chi = 0.5$`，`$A_e = (k h_e)^{1}$` 和 `$b = 0.6$`。\n\n- 案例 1 (光滑单位正方形替代模型):\n    - 单元: $[(0.25, 0.25, h=0.5), (0.75, 0.25, h=0.5), (0.25, 0.75, h=0.5), (0.75, 0.75, h=0.5)]$。\n    - 凹角: $[]$ (无)。\n    - 波数: $k = 5$。\n    - 容差: $\\tau = 10^{-3}$。\n\n- 案例 2 (单个凹角，混合邻近度):\n    - 单元: $[(0.05, 0.05, h=0.08), (0.20, 0.05, h=0.08), (0.40, 0.40, h=0.20), (0.80, 0.80, h=0.30)]$。\n    - 凹角: $[(0.0, 0.0, \\theta = 3\\pi/2)]$。\n    - 波数: $k = 5$。\n    - 容差: $\\tau = 10^{-3}$。\n\n- 案例 3 (两个凹角，混合光滑度):\n    - 单元: $[(0.10, 0.10, h=0.10), (0.90, 0.50, h=0.08), (0.50, 0.50, h=0.20), (0.50, 0.10, h=0.15)]$。\n    - 凹角: $[(0.0, 0.0, \\theta = 3\\pi/2), (1.0, 0.5, \\theta = 3\\pi/2)]$。\n    - 波数: $k = 1$。\n    - 容差: $\\tau = 10^{-4}$。\n\n- 案例 4 (高频光滑域):\n    - 单元: $[(0.10, 0.10, h=0.10), (0.30, 0.20, h=0.08), (0.60, 0.40, h=0.05), (0.80, 0.70, h=0.20), (0.50, 0.90, h=0.12)]$。\n    - 凹角: $[]$。\n    - 波数: $k = 80$。\n    - 容差: $\\tau = 10^{-2}$。\n\n- 案例 5 (奇异邻域边界附近的阈值分类):\n    - 单元: $[(0.65, 0.50, h=0.10)]$。\n    - 凹角: $[(0.50, 0.50, \\theta = 3\\pi/2)]$。\n    - 波数: $k = 10$。\n    - 容差: $\\tau = 10^{-3}$。\n\n所需输出。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个案例的结果本身是一个整数列表（按所列顺序排列的每个单元所选的多项式次数）。例如，输出必须采用 $[ [p_{1,1}, p_{1,2}, \\dots], [p_{2,1}, \\dots], \\dots ]$ 的形式，不得包含任何额外文本。最终答案是没有任何单位的纯整数。", "solution": "问题陈述经评估有效。它在科学上基于计算电磁学和有限元法的原理，内部一致，并为一个确定性算法提供了完整、适定的规范。所有必要的常数、公式和测试数据均已提供，从而可以推导出唯一且可验证的解。\n\n任务是为时谐电磁波的二维`$hp$-FEM`（混合网格尺寸和多项式次数加密）模拟实现一个多项式次数选择算法。该算法必须根据局部场的特性、目标精度和数值稳定性准则，智能地为有限元网格的每个单元分配一个多项式次数 $p_e$。`$hp$-FEM` 的核心思想是自适应地结合使用网格加密（`$h$-加密`，减小单元尺寸 $h_e$）和多项式增阶（`$p$-加密`，增加基函数次数 $p_e$），以实现最优收敛。本问题仅关注给定网格的 `$p$-选择`部分。\n\n该算法综合了现代有限元法解决波动问题的三个基本考虑因素：\n\n1.  **解的局部正则性：** 电磁场的平滑度决定了高阶多项式逼近的有效性。\n    -   在解是光滑（解析）的区域，逼近误差随多项式次数 $p$ 呈指数下降。所提供的误差模型 $\\text{error} \\approx (k h_e) \\exp(-b p)$ 反映了这一点，通过反解该模型来找到满足容差 $\\tau$ 的最小 $p$ 是 `$p$-加密`的一种高效策略。\n    -   在几何奇异点附近，例如域边界上的凹角，解是不光滑的。对于角度 $\\theta > \\pi$ 的角点，场表现出幂律奇异性，形式为 $r^{\\lambda}$，其中 $r$ 是到角点的距离，$\\lambda = \\pi/\\theta$ 是奇异指数。解的正则性被限制在索博列夫空间 $H^{\\lambda+1-\\epsilon}$（对于任意 $\\epsilon > 0$）。有限元法的逼近理论表明，关于 $p$ 的收敛速度受限于 $\\lambda$。因此，在这些区域使用非常高的多项式次数会产生递减的回报。该算法审慎地在此类奇异邻域中将多项式次数限制在 `$p_{\\text{cap}} = \\lfloor \\lambda + 0.5 \\rfloor$`，从而将计算资源集中在最有效的地方。\n\n2.  **色散误差控制：** 包括有限元法在内的波动方程数值格式，可能会为传播波引入一种非物理的、依赖于频率的相速度。这种“数值色散”会导致相位误差随距离累积。为了控制这一点，数值解析度必须足以表示波。一个标准的经验法则是每个波长保持一定数量的自由度。这通过波解析度约束 `$k h_e / p_e \\le \\chi$` 来体现，其中 `$k=2\\pi/\\text{波长}$` 是波数。该约束为给定的单元尺寸 $h_e$ 和波数 $k$ 设定了确保模拟保真度所需的最小多项式次数 `$p_{\\text{disp}}$`。\n\n3.  **算法综合：** 单元的最终多项式次数 $p_e$ 由这些准则的清晰层次结构决定。选择基于单元是位于“奇异”区域还是“光滑”区域，但这个基础选择随后需要满足色散约束和全局界限。最终的公式，\n    $$\n    p_e = \\min\\left(p_{\\max}, \\max\\left(p_{\\text{disp}}, \\begin{cases}\n    p_{\\text{sing}}  \\text{if in singular neighborhood},\\\\\n    p_{\\text{smooth}}  \\text{otherwise.}\n    \\end{cases}\\right)\\right)\n    $$\n    封装了这一逻辑。它采用适当的基础选择（`$p_{\\text{sing}}$` 或 `$p_{\\text{smooth}}$`），通过与 `$p_{\\text{disp}}$` 取最大值来确保其至少足够高以控制色散，最后通过全局最大值 `$p_{\\max}$` 对其进行封顶以限制计算成本。\n\n现在，我们将此算法应用于一个代表性的测试案例，即案例 2，该案例同时涉及奇异区域和光滑区域。\n\n**案例 2：详细演算**\n-   **给定条件：** 波数 $k=5$，容差 $\\tau = 10^{-3}$。\n-   **凹角：** 一个位于 $(0.0, 0.0)$ 的角点，角度为 $\\theta = 3\\pi/2$。由于 $\\theta > \\pi$，它是凹角。奇异指数为 $\\lambda = \\pi / (3\\pi/2) = 2/3$。\n-   **常数：** $\\alpha = 1.5, p_{\\min} = 1, p_{\\max} = 8, p_{\\text{max,sing}} = 3, \\chi = 0.5, b = 0.6$。\n\n**单元 1：** 形心 $(0.05, 0.05)$，尺寸 $h_e=0.08$。\n1.  **区域分类：**\n    -   到角点的距离：$d_e = \\sqrt{(0.05-0)^2 + (0.05-0)^2} = \\sqrt{0.005} \\approx 0.0707$。\n    -   邻域阈值：$\\alpha h_e = 1.5 \\times 0.08 = 0.12$。\n    -   由于 $d_e \\approx 0.0707 \\le 0.12$，该单元位于**奇异邻域**内。\n2.  **基础多项式次数 ($p_{\\text{sing}}$)：**\n    -   `$p_{\\text{cap}} = \\lfloor \\lambda + 0.5 \\rfloor = \\lfloor 2/3 + 0.5 \\rfloor = \\lfloor 1.166... \\rfloor = 1$`。\n    -   `$p_{\\text{sing}} = \\max(p_{\\min}, \\min(p_{\\text{cap}}, p_{\\text{max,sing}})) = \\max(1, \\min(1, 3)) = 1$`。因此，$p_{\\text{base}} = 1$。\n3.  **色散约束 ($p_{\\text{disp}}$)：**\n    -   `$p_{\\text{disp}} = \\lceil k h_e / \\chi \\rceil = \\lceil (5 \\times 0.08) / 0.5 \\rceil = \\lceil 0.4 / 0.5 \\rceil = \\lceil 0.8 \\rceil = 1$`。\n4.  **最终次数 ($p_e$):**\n    -   `$p_e = \\min(p_{\\max}, \\max(p_{\\text{disp}}, p_{\\text{base}})) = \\min(8, \\max(1, 1)) = 1$`。\n\n**单元 2：** 形心 $(0.20, 0.05)$，尺寸 $h_e=0.08$。\n1.  **区域分类：**\n    -   到角点的距离：$d_e = \\sqrt{(0.20-0)^2 + (0.05-0)^2} = \\sqrt{0.0425} \\approx 0.2062$。\n    -   邻域阈值：$\\alpha h_e = 1.5 \\times 0.08 = 0.12$。\n    -   由于 $d_e \\approx 0.2062 > 0.12$，该单元位于**光滑区域**。\n2.  **基础多项式次数 ($p_{\\text{smooth}}$)：**\n    -   我们需要 $(k h_e) \\exp(-b p) \\le \\tau$。这得到 $p \\ge \\ln(k h_e / \\tau)/b$。\n    -   $k h_e = 5 \\times 0.08 = 0.4$。\n    -   `$p_{\\text{smooth}} = \\lceil \\frac{\\ln(0.4 / 10^{-3})}{0.6} \\rceil = \\lceil \\frac{\\ln(400)}{0.6} \\rceil \\approx \\lceil 5.991 / 0.6 \\rceil = \\lceil 9.985 \\rceil = 10$`。因此，$p_{\\text{base}} = 10$。\n3.  **色散约束 ($p_{\\text{disp}}$)：**\n    -   `$p_{\\text{disp}} = \\lceil (5 \\times 0.08) / 0.5 \\rceil = \\lceil 0.8 \\rceil = 1$`。\n4.  **最终次数 ($p_e$):**\n    -   `$p_e = \\min(p_{\\max}, \\max(p_{\\text{disp}}, p_{\\text{base}})) = \\min(8, \\max(1, 10)) = \\min(8, 10) = 8$`。\n\n案例 2 中的其余单元也位于光滑区域，并得出 $p_e=8$。这演示了该算法如何为受奇异性影响的单元分配一个低次数（$p_e=1$），并为高阶逼近有效的光滑区域中的单元分配一个高次数（$p_e=8$，受 `$p_{\\max}$` 限制）。\n\n将此过程应用于所有测试案例，得出以下结果：\n\n-   **案例 1：** 所有单元都是光滑的，需要高次数来满足容差。色散约束不占主导地位。最终次数都受 `$p_{\\max}$` 限制。\n    -   结果：$[8, 8, 8, 8]$\n-   **案例 2：** 第一个单元靠近一个角点，被分配了 $p_e=1$。其他单元是光滑的，被分配了 $p_e=8$。\n    -   结果：$[1, 8, 8, 8]$\n-   **案例 3：** 两个单元靠近角点，被分配了低次数（$p_e=1$）。另外两个位于光滑区域，被分配了高次数（$p_e=8$）。\n    -   结果：$[1, 1, 8, 8]$\n-   **案例 4：** 一个高频案例（$k=80$），其中所有单元都是光滑的。色散约束（`$p_{\\text{disp}}$`）成为主导因素，需要非常高的次数，但最终都被 `$p_{\\max}=8$` 封顶。\n    -   结果：$[8, 8, 8, 8, 8]$\n-   **案例 5：** 一个单元恰好位于奇异邻域的边界上（$d_e = \\alpha h_e$）。它被分类为奇异。色散约束（`$p_{\\text{disp}}=2$`）比基于奇异性的选择（`$p_{\\text{sing}}=1$`）要求更高，因此最终次数为 $p_e=2$。\n    -   结果：$[2]$\n\n完整的结果集是：$[[8, 8, 8, 8], [1, 8, 8, 8], [1, 1, 8, 8], [8, 8, 8, 8, 8], [2]]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the hp-refinement polynomial degree selection algorithm\n    and runs it on the specified test cases.\n    \"\"\"\n\n    # --- Fixed constants for the algorithm ---\n    ALPHA = 1.5\n    P_MIN = 1\n    P_MAX = 8\n    P_MAX_SING = 3\n    CHI = 0.5\n    B_COEFF = 0.6\n\n    # --- Test suite definition ---\n    test_cases = [\n        # Case 1 (smooth unit square surrogate)\n        {\n            \"elements\": [(0.25, 0.25, 0.5), (0.75, 0.25, 0.5), (0.25, 0.75, 0.5), (0.75, 0.75, 0.5)],\n            \"corners\": [],\n            \"k\": 5.0,\n            \"tau\": 1e-3\n        },\n        # Case 2 (single re-entrant corner, mixed proximity)\n        {\n            \"elements\": [(0.05, 0.05, 0.08), (0.20, 0.05, 0.08), (0.40, 0.40, 0.20), (0.80, 0.80, 0.30)],\n            \"corners\": [(0.0, 0.0, 3 * np.pi / 2)],\n            \"k\": 5.0,\n            \"tau\": 1e-3\n        },\n        # Case 3 (two re-entrant corners, mixed smoothness)\n        {\n            \"elements\": [(0.10, 0.10, 0.10), (0.90, 0.50, 0.08), (0.50, 0.50, 0.20), (0.50, 0.10, 0.15)],\n            \"corners\": [(0.0, 0.0, 3 * np.pi / 2), (1.0, 0.5, 3 * np.pi / 2)],\n            \"k\": 1.0,\n            \"tau\": 1e-4\n        },\n        # Case 4 (high-frequency smooth domain)\n        {\n            \"elements\": [(0.10, 0.10, 0.10), (0.30, 0.20, 0.08), (0.60, 0.40, 0.05), (0.80, 0.70, 0.20), (0.50, 0.90, 0.12)],\n            \"corners\": [],\n            \"k\": 80.0,\n            \"tau\": 1e-2\n        },\n        # Case 5 (threshold classification near singular neighborhood boundary)\n        {\n            \"elements\": [(0.65, 0.50, 0.10)],\n            \"corners\": [(0.50, 0.50, 3 * np.pi / 2)],\n            \"k\": 10.0,\n            \"tau\": 1e-3\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        case_results = []\n        elements = case[\"elements\"]\n        corners = case[\"corners\"]\n        k = case[\"k\"]\n        tau = case[\"tau\"]\n\n        re_entrant_corners = [(xc, yc, theta) for xc, yc, theta in corners if theta > np.pi]\n\n        for xe, ye, he in elements:\n            # Step 1: Calculate minimum distance to a re-entrant corner\n            min_dist = float('inf')\n            closest_corner_theta = None\n            if re_entrant_corners:\n                for xc, yc, theta in re_entrant_corners:\n                    dist = np.sqrt((xe - xc)**2 + (ye - yc)**2)\n                    if dist  min_dist:\n                        min_dist = dist\n                        closest_corner_theta = theta\n            \n            # Step 2: Classify element and calculate base p\n            is_singular = (min_dist = ALPHA * he) if re_entrant_corners else False\n            \n            if is_singular:\n                # In singular neighborhood\n                lambda_exp = np.pi / closest_corner_theta\n                p_cap = int(np.floor(lambda_exp + 0.5))\n                p_sing = max(P_MIN, min(p_cap, P_MAX_SING))\n                p_base = p_sing\n            else:\n                # In smooth region\n                kh = k * he\n                # Ae * exp(-b*p) = tau  =>  p >= ln(Ae/tau)/b\n                # Ae = (kh)^1\n                if kh = 0 or tau = 0 or kh/tau = 1:\n                    # To avoid math domain error with log, though problem inputs prevent this.\n                    # Or if tolerance is already met with p=0.\n                    p_smooth_raw = 0\n                else:\n                    p_smooth_raw = np.log(kh / tau) / B_COEFF\n                \n                p_smooth = int(np.ceil(p_smooth_raw))\n                # The final formula implicitly handles p_min through max(p_disp, ...),\n                # where p_disp >= 1 and p_smooth for reasonable inputs will be >=1.\n                p_base = max(P_MIN, p_smooth)\n\n            # Step 3: Calculate dispersion-constrained p\n            p_disp = int(np.ceil((k * he) / CHI))\n            \n            # Step 4: Combine and finalize p_e\n            p_intermediate = max(p_disp, p_base)\n            p_element = min(P_MAX, p_intermediate)\n            \n            case_results.append(p_element)\n            \n        all_results.append(case_results)\n\n    # Final print statement must be a list of lists with no spaces, as per instruction.\n    sub_strings = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output = f\"[{','.join(sub_strings)}]\"\n    print(final_output)\n\nsolve()\n\n```", "id": "3314596"}, {"introduction": "现在，让我们聚焦于高频计算电磁学中的一个核心挑战：污染效应（pollution effect），即随着频率的增加，即使网格分辨率足以解析波长，数值相速与物理相速的差异也会不断累积，导致全局相位误差。本练习旨在探究`$p$-refinement`如何有效抑制这种污染效应。您将实现一个一维亥姆霍兹方程的有限元求解器，并通过数值实验比较两种不同的 `$p$`值选取策略（例如，$p \\sim \\log(k)$ 与 $p \\sim kh$）在不同频率下的表现。这个练习清晰地展示了`$p$-refinement`在高频仿真中的实际优势，并揭示了为何需要根据波数 `$k$`合理地提升多项式次数 `$p$`，以在长距离波传播问题中保持计算精度。[@problem_id:3336597]", "problem": "考虑一个代表时谐电磁波传播的一维模型问题：在区间 $\\left[0,L\\right]$ 上的标量亥姆霍兹方程 (scalar Helmholtz equation)，\n$$\nu''(x) + k^2 u(x) = 0 \\quad \\text{for } x \\in (0,L),\n$$\n其左端为狄利克雷 (Dirichlet) 边界条件，右端为辐射（阻抗）边界条件，\n$$\nu(0) = 1, \\qquad u'(L) - i k u(L) = 0,\n$$\n其中 $k0$ 是波数（单位：$\\mathrm{m}^{-1}$），$L0$ 是域长度（单位：$\\mathrm{m}$），以及 $i=\\sqrt{-1}$。其精确解是右行平面波 $u_{\\mathrm{exact}}(x) = e^{i k x}$，具有单位振幅和相位 $k x$。\n\n您将使用连续伽辽金 (Galerkin) 有限元方法和 `$p$`加密来近似求解此问题。使用包含 $N$ 个单元的均匀网格，每个单元的长度为 $h = L/N$，并且在每个单元上使用 `$p$`次多项式。在每个参考单元 $\\xi \\in [-1,1]$ 上，使用由两个顶点函数和 `$(p-1)$`个气泡函数组成的分层基：\n- 顶点基函数：\n$$\n\\phi_0(\\xi) = \\frac{1-\\xi}{2}, \\qquad \\phi_1(\\xi) = \\frac{1+\\xi}{2}.\n$$\n- 对于 $m \\in \\{2,3,\\dots,p\\}$ 的内部层次化气泡基函数：\n$$\n\\phi_m(\\xi) = P_m(\\xi) - P_{m-2}(\\xi),\n$$\n其中 $P_n(\\xi)$ 表示 $n$ 次勒让德 (Legendre) 多项式。注意，对于所有 $m\\ge 2$，都有 $\\phi_m(\\pm 1) = 0$。通过仿射映射 $x(\\xi) = x_e + \\frac{h}{2}(1+\\xi)$ 来映射导数，使得 $\\frac{d}{dx} = \\frac{2}{h}\\frac{d}{d\\xi}$。使用足够阶数的高斯求积 (Gaussian quadrature) 对体双线性形式进行精确积分（您可以选择任何对于最高达到所需次数的多项式是精确的求积方法）。\n\n从第一性原理推导弱形式：将微分方程乘以一个测试函数，进行分部积分，并利用边界条件得到离散代数系统。组装全局系统，将辐射边界条件作为 $x=L$ 处的边界项并入，并通过消元法在 $x=0$ 处强施加狄利克雷 (Dirichlet) 条件。\n\n定义 $x=L$ 处的数值相位为 $\\theta_h = \\arg\\left(u_h(L)\\right)$，精确相位为 $\\theta_{\\mathrm{exact}} = k L$。将相位误差定义为主值差，\n$$\n\\varepsilon_\\theta = \\left| \\operatorname{atan2}\\left(\\sin(\\theta_h - \\theta_{\\mathrm{exact}}), \\cos(\\theta_h - \\theta_{\\mathrm{exact}})\\right) \\right|,\n$$\n以弧度表示。\n\n随着波数 $k$ 的增加，通过比较两种 `$p$`加密缩放策略，研究高频亥姆霍兹污染效应：\n- 对数缩放：$p = \\left\\lceil \\alpha \\log(k) \\right\\rceil$，\n- `$kh$`线性缩放：$p = \\left\\lceil \\beta \\, k h \\right\\rceil$，\n其中固定的 $\\alpha0$ 和 $\\beta0$。为了在不同 $k$ 值之间进行公平比较，选择单元数以使每波长单元数保持固定：\n$$\nN = \\left\\lceil \\frac{m_e \\, L \\, k}{2\\pi} \\right\\rceil, \\qquad h = \\frac{L}{N},\n$$\n其中 $m_e$ 是每个波长规定的单元数。此选择固定了 $k h \\approx \\frac{2\\pi}{m_e}$。\n\n您的程序必须：\n1. 对于下面指定的测试用例，组装并求解有限元近似解 $u_h$ 的复值线性系统。\n2. 对两种缩放策略中的每一种计算相位误差 $\\varepsilon_\\theta$。\n3. 对于每个测试用例，报告一个包含三个条目的列表：对数缩放的相位误差（四舍五入到六位小数），`$kh$`线性缩放的相位误差（四舍五入到六位小数），以及一个整数指示符，如果对数缩放产生的相位误差严格小于`$kh$`线性缩放的相位误差，则该指示符等于 $1$，否则等于 $0$。\n\n使用以下参数值（单位：$k$ 为 $\\mathrm{m}^{-1}$，$L$ 为 $\\mathrm{m}$，角度为弧度）：\n- 测试用例 #1：$k = 50$, $L = 1.0$, $m_e = 8$, $\\alpha = 2.0$, $\\beta = 6.0$。\n- 测试用例 #2：$k = 100$, $L = 1.0$, $m_e = 8$, $\\alpha = 2.0$, $\\beta = 6.0$。\n- 测试用例 #3：$k = 200$, $L = 1.0$, $m_e = 8$, $\\alpha = 2.0$, $\\beta = 6.0$。\n- 测试用例 #4：$k = 100$, $L = 1.0$, $m_e = 4$, $\\alpha = 2.0$, $\\beta = 6.0$。\n\n角度单位要求：所有相位和相位误差必须以弧度计算和报告。数值输出要求：您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，每个内部列表的形式为 $[\\varepsilon_{\\theta,\\log}, \\varepsilon_{\\theta,kh}, I]$，其中两个相位误差四舍五入到六位小数，且 $I \\in \\{0,1\\}$。例如，一个有效的输出格式是\n$$\n[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4]],\n$$\n没有空格，也没有额外的文本。\n\n测试套件覆盖范围的基本原理：\n- 在 $m_e = 8$ 的情况下，$k \\in \\{50,100,200\\}$ 的用例探测高频区域，同时保持固定的每波长单元数以隔离污染效应。\n- 在 $m_e = 4$ 的情况下，$k=100$ 的用例探测一个更粗分辨率的边缘情况（更大的 $k h$），以测试在更强色散下的鲁棒性。\n- 在固定的 $k h$ 条件下，比较 $p \\sim \\log k$ 与 $p \\sim k h$ 突出了 `$p$`加密策略在控制相位误差方面的不同渐进行为。\n\n最终程序必须是完整且可运行的，不需要用户输入，并遵守上面指定的精确输出格式。", "solution": "该问题被评估为有效。它在计算电磁学理论，特别是亥姆霍兹方程的有限元分析方面，具有坚实的科学基础。它是一个适定的 (well-posed) 问题，具有明确定义的微分方程、边界条件，以及一个用于比较的、具有物理意义的唯一精确解。所有参数和方法都得到了明确的规定，从而允许进行可复现的数值实验。\n\n目标是使用连续伽辽金 (Galerkin) 有限元方法（FEM）和 `$p$`加密来求解域 $[0, L]$ 上的一维标量亥姆霍兹方程。控制方程为\n$$\nu''(x) + k^2 u(x) = 0, \\quad x \\in (0,L)\n$$\n受限于 $x=0$ 处的狄利克雷 (Dirichlet) 边界条件和 $x=L$ 处的一阶吸收（辐射）边界条件：\n$$\nu(0) = 1, \\qquad u'(L) - i k u(L) = 0.\n$$\n这里，$k  0$ 是波数。这个边值问题模拟了一个右行平面波，其精确解为 $u_{\\mathrm{exact}}(x) = e^{ikx}$。\n\n**1. 弱形式 (Weak Formulation)**\n\n有限元方法的基础是将微分方程的强形式转化为等效的积分弱形式。我们将亥姆霍兹方程乘以一个来自合适函数空间的任意测试函数 $v(x)$，并在域 $[0,L]$ 上积分：\n$$\n\\int_0^L v(x) \\left( u''(x) + k^2 u(x) \\right) dx = 0.\n$$\n为了降低最高阶导数的阶数并自然地引入边界条件，我们对二阶导数项应用分部积分：\n$$\n\\int_0^L v(x) u''(x) dx = \\left[ v(x) u'(x) \\right]_0^L - \\int_0^L v'(x) u'(x) dx.\n$$\n将此代回积分方程中，得到：\n$$\n\\left[ v(x) u'(x) \\right]_0^L - \\int_0^L v'(x) u'(x) dx + k^2 \\int_0^L v(x) u(x) dx = 0.\n$$\n边界项为 $\\left[ v u' \\right]_0^L = v(L)u'(L) - v(0)u'(0)$。我们将辐射条件 $u'(L) = i k u(L)$ 代入此项。狄利克雷 (Dirichlet) 条件 $u(0)=1$ 是强施加的，这意味着对于所有与未知自由度相关的测试函数 $v(x)$，我们必须有 $v(0)=0$。这消除了 $x=0$ 处的项。于是弱形式为：寻找一个解 $u(x)$，使得对于所有有效的测试函数 $v(x)$，\n$$\n- \\int_0^L u'(x) v'(x) dx + k^2 \\int_0^L u(x) v(x) dx + i k u(L) v(L) = 0.\n$$\n整理成典则双线性形式 $a(u,v) = f(v)$，我们有：\n$$\n\\int_0^L u'(x) v'(x) dx - k^2 \\int_0^L u(x) v(x) dx - i k u(L) v(L) = 0.\n$$\n\n**2. 有限元离散化 (Finite Element Discretization)**\n\n我们将域 $[0,L]$ 离散化为 $N$ 个长度为 $h=L/N$ 的均匀单元。在每个单元内，解 $u_h(x)$ 被近似为一个 `$p$`次多项式。该近似写为基函数 $\\phi_j(\\xi)$ 的线性组合：\n$$\nu_h(x)|_{I_e} = \\sum_{j=0}^{p} U_j^e \\phi_j(\\xi(x)),\n$$\n其中 $U_j^e$ 是单元 $e$ 的局部自由度 (DoFs)，$\\xi(x) = 2(x-x_e)/h - 1$ 是从物理单元 $I_e=[x_e, x_{e+1}]$ 到参考单元 $\\xi \\in [-1,1]$ 的仿射映射。\n\n指定的基函数是一组最高到 $p$ 次的多项式的分层集合：\n- 两个线性顶点函数：$\\phi_0(\\xi) = \\frac{1-\\xi}{2}$，$\\phi_1(\\xi) = \\frac{1+\\xi}{2}$。\n- $(p-1)$ 个高阶气泡函数：对于 $m=2, \\dots, p$，$\\phi_m(\\xi) = P_m(\\xi) - P_{m-2}(\\xi)$，其中 $P_n(\\xi)$ 是 $n$ 次勒让德 (Legendre) 多项式。这些函数在单元端点 $\\xi = \\pm 1$ 处为零。\n\n问题的离散形式是通过将 $u_h$ 的近似代入弱形式，并从同一空间中选择测试函数 $v_h$（伽辽金方法）来获得的。这会产生一个线性代数系统 $A \\mathbf{U} = \\mathbf{F}$。系统矩阵 $A$ 和向量 $\\mathbf{F}$ 由单元级的贡献组装而成。在每个单元上，我们计算一个单元系统矩阵 $K_{\\text{sys}}^e$：\n$$\n(K_{\\text{sys}}^e)_{ij} = \\int_{I_e} \\left( (\\phi_j^e)' (\\phi_i^e)' - k^2 \\phi_j^e \\phi_i^e \\right) dx.\n$$\n使用仿射映射，导数和积分测度变换为 $\\frac{d}{dx} = \\frac{2}{h}\\frac{d}{d\\xi}$ 和 $dx = \\frac{h}{2} d\\xi$。单元矩阵变为：\n$$\n(K_{\\text{sys}}^e)_{ij} = \\frac{2}{h} \\int_{-1}^1 \\phi_j'(\\xi) \\phi_i'(\\xi)d\\xi - k^2\\frac{h}{2} \\int_{-1}^1 \\phi_j(\\xi) \\phi_i(\\xi)d\\xi.\n$$\n参考单元上的积分使用具有 $p+1$ 个点的高斯求积 (Gaussian quadrature) 进行数值计算，这足以精确地积分多项式乘积。\n\n**3. 系统组装与求解 (System Assembly and Solution)**\n\n全局系统矩阵通过根据局部到全局的自由度 (DoF) 映射，对每个单元矩阵的贡献求和来组装。全局自由度的编号如下：索引 $0, \\dots, N$ 对应于 $N+1$ 个顶点节点，索引 $N+1, \\dots, Np$ 对应于 $N(p-1)$ 个内部气泡函数系数。这种结构产生一个稀疏的全局矩阵。\n\n辐射边界条件贡献了项 $-i k u(L) v(L)$。在离散系统中，此项仅影响最终节点 $x=L$（全局索引 $N$）的自由度方程。它导致从全局矩阵的对角元素 $A_{NN}$ 中减去 $ik$。\n\n狄利克雷 (Dirichlet) 条件 $u(0)=1$ 是强施加的。对应于 $x=0$ 处节点（全局索引 $0$）的自由度被设置为 $1$。然后对系统进行分块，以求解剩余的未知自由度。如果完整系统是 $A\\mathbf{U}=\\mathbf{F}$，我们将其划分为已知 ($U_0=1$) 和未知 ($U_R$) 部分。未知数的方程变为 $A_{RR} U_R = F_R - A_{R0} U_0$。由于在施加边界条件之前右侧向量 $\\mathbf{F}$ 为零，这简化为求解 $A_{RR} U_R = -A_{R0}$。得到的稀疏复值线性系统被求解，以获得未知自由度的向量 $U_R$。\n\n**4. 误差分析与p加密策略 (Error Analysis and p-Refinement Strategies)**\n\n求解系数向量 $\\mathbf{U}$ 后，端点处的数值解 $u_h(L)$ 就是节点 $N$ 处自由度的值，即 $u_h(L) = U_N$。我们将相位误差 $\\varepsilon_\\theta$ 计算为数值相位 $\\theta_h = \\arg(u_h(L))$ 与精确相位 $\\theta_{\\mathrm{exact}} = kL$ 之差的绝对主值：\n$$\n\\varepsilon_\\theta = \\left| \\operatorname{atan2}\\left(\\sin(\\theta_h - \\theta_{\\mathrm{exact}}), \\cos(\\theta_h - \\theta_{\\mathrm{exact}})\\right) \\right|.\n$$\n该数值实验比较了随着波数 $k$ 增加，同时保持每波长单元数 ($m_e$) 固定时选择多项式次数 `$p$`的两种策略。这种设置隔离了高频污染效应，即即使每波长的网格分辨率恒定，误差也会随 $k$ 的增加而增加。这些策略是：\n- 对数缩放：$p = \\lceil \\alpha \\log(k) \\rceil$。\n- `$kh$`线性缩放：$p = \\lceil \\beta \\, k h \\rceil$。由于 $kh \\approx 2\\pi/m_e$ 是固定的，此策略对应于一个固定的多项式次数。\n\n提供的 Python 代码实现了这整个过程，构建了一个稀疏系统矩阵，求解节点值，并为指定的测试用例和缩放策略计算相位误差。", "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\nimport math\n\ndef solve_fem(k, L, N, p):\n    \"\"\"\n    Solves the 1D Helmholtz equation using a p-version finite element method.\n\n    Args:\n        k (float): Wavenumber.\n        L (float): Domain length.\n        N (int): Number of elements.\n        p (int): Polynomial degree.\n\n    Returns:\n        complex: The numerical solution at x=L.\n    \"\"\"\n    h = L / N\n    # Total number of degrees of freedom: N+1 vertices + N*(p-1) bubbles\n    num_dofs = N * p + 1 if p > 0 else N + 1\n\n    # Local element matrices calculations\n    local_dim = p + 1\n    \n    # Gaussian quadrature exact for polynomials of degree up to 2p\n    # A rule with p+1 points is exact for degree 2(p+1)-1 = 2p+1.\n    n_quad = p + 1\n    xi_q, w_q = np.polynomial.legendre.leggauss(n_quad)\n\n    # Evaluate basis functions and their derivatives at quadrature points\n    # phi_vals[j, q] = phi_j(xi_q)\n    # dphi_vals[j, q] = phi'_j(xi_q)\n    phi_vals = np.zeros((local_dim, n_quad))\n    dphi_vals = np.zeros((local_dim, n_quad))\n\n    # Vertex functions (j=0, 1)\n    phi_vals[0, :] = (1 - xi_q) / 2\n    dphi_vals[0, :] = -0.5\n    if p > 0:\n        phi_vals[1, :] = (1 + xi_q) / 2\n        dphi_vals[1, :] = 0.5\n    \n    # Bubble functions (j=2...p)\n    if p > 1:\n        for j in range(2, local_dim):\n            # phi_j = P_j - P_{j-2}\n            phi_vals[j, :] = eval_legendre(j, xi_q) - eval_legendre(j - 2, xi_q)\n            # phi'_j = (2j-1) * P_{j-1}\n            dphi_vals[j, :] = (2 * j - 1) * eval_legendre(j - 1, xi_q)\n\n    # Compute local stiffness and mass matrices on reference element [-1, 1]\n    # K_ref_ij = integral(phi'_i * phi'_j dxi)\n    # S_ref_ij = integral(phi_i * phi_j dxi)\n    K_ref = dphi_vals @ np.diag(w_q) @ dphi_vals.T\n    S_ref = phi_vals @ np.diag(w_q) @ phi_vals.T\n\n    # Element system matrix\n    K_sys_elem = (2 / h) * K_ref - (k**2 * h / 2) * S_ref\n\n    # Assemble global matrix using a sparse format for efficiency\n    A_glob = sparse.lil_matrix((num_dofs, num_dofs), dtype=np.complex128)\n    \n    num_bubbles_per_elem = p - 1 if p > 1 else 0\n\n    for e in range(N):\n        dof_map = np.zeros(local_dim, dtype=int)\n        dof_map[0] = e\n        dof_map[1] = e + 1\n        if p > 1:\n            bubble_start_idx = N + 1 + e * num_bubbles_per_elem\n            dof_map[2:] = bubble_start_idx + np.arange(num_bubbles_per_elem)\n        \n        for i in range(local_dim):\n            for j in range(local_dim):\n                I, J = dof_map[i], dof_map[j]\n                A_glob[I, J] += K_sys_elem[i, j]\n\n    # Apply radiation boundary condition u'(L) - iku(L) = 0\n    # Affects the diagonal entry for the last vertex node (node N).\n    A_glob[N, N] -= 1j * k\n\n    # Apply Dirichlet boundary condition u(0) = 1 by elimination\n    A_glob_csc = A_glob.tocsc()\n    A_RR = A_glob_csc[1:, 1:]\n    F_R = -A_glob_csc[1:, 0].toarray().flatten()\n\n    # Solve for unknown DOFs\n    U_R = spsolve(A_RR, F_R)\n\n    # Reconstruct the full solution vector\n    U = np.concatenate(([1.0 + 0.0j], U_R))\n\n    # The value at x=L corresponds to the DOF at node N\n    u_h_L = U[N]\n    return u_h_L\n\ndef calculate_phase_error(u_h_L, k, L):\n    \"\"\"\n    Calculates the phase error at x=L.\n    \"\"\"\n    theta_h = np.angle(u_h_L)\n    theta_exact = k * L\n    delta_theta = theta_h - theta_exact\n    # Use atan2 for a robust principal value of the angle difference\n    phase_error = np.abs(np.arctan2(np.sin(delta_theta), np.cos(delta_theta)))\n    return phase_error\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (50.0, 1.0, 8, 2.0, 6.0),\n        (100.0, 1.0, 8, 2.0, 6.0),\n        (200.0, 1.0, 8, 2.0, 6.0),\n        (100.0, 1.0, 4, 2.0, 6.0),\n    ]\n\n    results = []\n    for k, L, m_e, alpha, beta in test_cases:\n        # Determine mesh size to fix elements-per-wavelength\n        N = math.ceil(m_e * L * k / (2 * np.pi))\n        h = L / N\n        kh = k * h\n\n        # Logarithmic scaling for p\n        p_log = math.ceil(alpha * np.log(k))\n        u_L_log = solve_fem(k, L, N, int(p_log))\n        err_log = calculate_phase_error(u_L_log, k, L)\n        \n        # Linear-in-kh scaling for p\n        p_kh = math.ceil(beta * kh)\n        u_L_kh = solve_fem(k, L, N, int(p_kh))\n        err_kh = calculate_phase_error(u_L_kh, k, L)\n        \n        indicator = 1 if err_log  err_kh else 0\n        \n        results.append([\n            round(err_log, 6),\n            round(err_kh, 6),\n            indicator\n        ])\n\n    sub_strings = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    final_output = f\"[{','.join(sub_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3336597"}]}