{"hands_on_practices": [{"introduction": "在边界元方法中，直接对奇异核函数进行数值积分是不可靠的。本练习将引导您运用矢量微积分的基本原理，将一个具有 $O(1/R^2)$ 奇异性的双层势积分解析地转化为一个几何项（立体角）和几个一维边界积分之和。这种解析正则化技术是精确高效处理奇异性的基石。[@problem_id:3357681]", "problem": "考虑拉普拉斯方程在三维自由空间中的静电极限格林函数，定义为 $G(\\mathbf{r},\\mathbf{r}_0)=\\frac{1}{4\\pi |\\mathbf{r}-\\mathbf{r}_0|}$，其中 $\\mathbf{r}\\in\\mathbb{R}^{3}$ 是源点，$\\mathbf{r}_0\\in\\mathbb{R}^{3}$ 是场点。在边界积分表述中，双层算子涉及在一个面片上对核函数 $\\nabla_{\\mathbf{r}_0}G(\\mathbf{r},\\mathbf{r}_0)$ 进行积分。设 $T$ 是一个平面三角形，其顶点为 $\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3\\in\\mathbb{R}^{3}$，其单位法向量 $\\mathbf{n}$ 的选择使得当沿着 $\\mathbf{n}$ 方向看时，$\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3$ 是按逆时针顺序排列的。通过有序对 $(\\mathbf{r}_1,\\mathbf{r}_2)$、$(\\mathbf{r}_2,\\mathbf{r}_3)$ 和 $(\\mathbf{r}_3,\\mathbf{r}_1)$ 定义三条有向边。对每条边 $e\\in\\{1,2,3\\}$，设 $\\mathbf{t}_e$ 为从其第一个顶点指向第二个顶点的单位切向量，并定义平面内向外的单位法向量为 $\\mathbf{m}_e=\\mathbf{n}\\times \\mathbf{t}_e$。\n\n设 $\\mathbf{a}\\in\\mathbb{R}^{3}$ 是一个常向量。记 $R=|\\mathbf{r}-\\mathbf{r}_0|$，并写出 $\\mathbf{R}_i=\\mathbf{r}_i-\\mathbf{r}_0$ 和 $R_i=|\\mathbf{R}_i|$，对于 $i\\in\\{1,2,3\\}$。对于每条端点为 $\\mathbf{r}_{e,1}$ 和 $\\mathbf{r}_{e,2}$ 的边 $e$，设 $\\mathbf{p}_e$ 是包含该边的无限直线上距离 $\\mathbf{r}_0$ 最近的点，定义带符号的沿边坐标为 $s_{e,i}=(\\mathbf{r}_{e,i}-\\mathbf{p}_e)\\cdot \\mathbf{t}_e$，对于 $i\\in\\{1,2\\}$，并设 $\\rho_e=|\\mathbf{r}_0-\\mathbf{p}_e|$，即 $\\mathbf{r}_0$ 到该直线的垂直距离。\n\n仅使用位势论和向量微积分的基本定律和核心定义，推导积分\n$$\nI(\\mathbf{a})=\\int_{T}\\frac{(\\mathbf{r}-\\mathbf{r}_0)\\cdot \\mathbf{a}}{R^{3}}\\,\\mathrm{d}S\n$$\n的解析闭式表达式，用几何数据 $\\{\\mathbf{r}_i\\}$、$\\mathbf{n}$、$\\{\\mathbf{t}_e\\}$、$\\{\\mathbf{m}_e\\}$、$\\{s_{e,i}\\}$ 和 $\\{\\rho_e\\}$ 表示。\n\n你的最终表达式必须是单一的解析闭式表达式。不需要进行数值计算。此外，请解释你的结果与静电学边界积分方程中双层项处理的相关性，包括法向分量如何恢复立体角，以及切向分量如何简化为不含奇异场点行为的边积分。最终答案应以无单位表达式的形式呈现，且不需要四舍五入。", "solution": "问题要求推导积分\n$$\nI(\\mathbf{a})=\\int_{T}\\frac{(\\mathbf{r}-\\mathbf{r}_0)\\cdot \\mathbf{a}}{R^{3}}\\,\\mathrm{d}S\n$$\n的解析闭式表达式，其中 $T$ 是一个平面三角形，$\\mathbf{r}_0$ 是一个场点，$\\mathbf{a}$ 是一个常向量，且 $R=|\\mathbf{r}-\\mathbf{r}_0|$。被积函数与拉普拉斯方程的自由空间格林函数 $G(\\mathbf{r},\\mathbf{r}_0) = \\frac{1}{4\\pi R}$ 的梯度有关。具体来说，$\\nabla_{\\mathbf{r}}G = -\\frac{\\mathbf{r}-\\mathbf{r}_0}{4\\pi R^3}$。因此，被积函数与 $\\mathbf{a} \\cdot \\nabla_{\\mathbf{r}} (1/R)$ 成正比。\n\n我们通过将常向量 $\\mathbf{a}$ 分解为其垂直于三角形 $T$ 平面的法向分量和位于该平面内的切向分量来继续。设 $\\mathbf{n}$ 为 $T$ 平面的单位法向量。我们可以写出\n$$\n\\mathbf{a} = (\\mathbf{a}\\cdot\\mathbf{n})\\mathbf{n} + (\\mathbf{a} - (\\mathbf{a}\\cdot\\mathbf{n})\\mathbf{n}) = \\mathbf{a}_n + \\mathbf{a}_t,\n$$\n其中 $\\mathbf{a}_n = (\\mathbf{a}\\cdot\\mathbf{n})\\mathbf{n}$ 是法向分量，$\\mathbf{a}_t$ 是切向分量，它位于 $T$ 平面内。\n将此分解代入积分，得到两部分：\n$$\nI(\\mathbf{a}) = \\int_{T}\\frac{(\\mathbf{r}-\\mathbf{r}_0)\\cdot \\mathbf{a}_n}{R^{3}}\\,\\mathrm{d}S + \\int_{T}\\frac{(\\mathbf{r}-\\mathbf{r}_0)\\cdot \\mathbf{a}_t}{R^{3}}\\,\\mathrm{d}S = I_n + I_t.\n$$\n\n首先，我们计算法向分量积分 $I_n$：\n$$\nI_n = \\int_{T}\\frac{(\\mathbf{r}-\\mathbf{r}_0)\\cdot ((\\mathbf{a}\\cdot\\mathbf{n})\\mathbf{n})}{R^{3}}\\,\\mathrm{d}S = (\\mathbf{a}\\cdot\\mathbf{n}) \\int_{T}\\frac{(\\mathbf{r}-\\mathbf{r}_0)\\cdot \\mathbf{n}}{R^{3}}\\,\\mathrm{d}S.\n$$\n根据定义，该积分项是三角形 $T$ 在场点 $\\mathbf{r}_0$ 处所张的立体角 $\\Omega(T)$ 的负值。\n$$\n\\Omega(T) \\equiv -\\int_{T}\\frac{(\\mathbf{r}-\\mathbf{r}_0)\\cdot \\mathbf{n}}{R^{3}}\\,\\mathrm{d}S.\n$$\n因此，来自 $\\mathbf{a}$ 的法向分量的贡献是\n$$\nI_n = -(\\mathbf{a}\\cdot\\mathbf{n})\\Omega(T).\n$$\n立体角 $\\Omega(T)$ 是一个标准的几何量，它取决于三角形的顶点 $\\{\\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3\\}$ 和场点 $\\mathbf{r}_0$。\n\n接下来，我们计算切向分量积分 $I_t$：\n$$\nI_t = \\int_{T}\\frac{(\\mathbf{r}-\\mathbf{r}_0)\\cdot \\mathbf{a}_t}{R^{3}}\\,\\mathrm{d}S.\n$$\n我们注意到 $\\frac{\\mathbf{r}-\\mathbf{r}_0}{R^3} = -\\nabla_{\\mathbf{r}}\\left(\\frac{1}{R}\\right)$。由于 $\\mathbf{a}_t$ 位于三角形平面内，与梯度的点积可以用曲面梯度算子 $\\nabla_S$ 表示：\n$$\n(\\mathbf{r}-\\mathbf{r}_0)\\cdot \\mathbf{a}_t / R^3 = -\\left(\\nabla_{\\mathbf{r}}\\frac{1}{R}\\right)\\cdot\\mathbf{a}_t = -\\left(\\nabla_S\\frac{1}{R}\\right)\\cdot\\mathbf{a}_t.\n$$\n我们使用曲面散度的向量恒等式：$\\nabla_S \\cdot (\\phi \\mathbf{V}) = (\\nabla_S \\phi) \\cdot \\mathbf{V} + \\phi (\\nabla_S \\cdot \\mathbf{V})$。令 $\\phi = 1/R$ 和 $\\mathbf{V} = \\mathbf{a}_t$。由于 $\\mathbf{a}_t$ 是一个常向量，其曲面散度为零，即 $\\nabla_S \\cdot \\mathbf{a}_t = 0$。因此，\n$$\n\\nabla_S \\cdot \\left(\\frac{\\mathbf{a}_t}{R}\\right) = \\left(\\nabla_S \\frac{1}{R}\\right) \\cdot \\mathbf{a}_t.\n$$\n因此，$I_t$ 的被积函数是 $-\\nabla_S \\cdot \\left(\\frac{\\mathbf{a}_t}{R}\\right)$。我们现在可以将二维散度定理（格林定理的一种变体）应用于平面 $T$：\n$$\n\\int_T (\\nabla_S \\cdot \\mathbf{W}) \\,\\mathrm{d}S = \\oint_{\\partial T} \\mathbf{W} \\cdot \\mathbf{m} \\,\\mathrm{d}l,\n$$\n其中 $\\partial T$ 是三角形的边界（由其三条边组成），$\\mathbf{m}$ 是指向边界边外侧的平面内单位法向量。问题将此向量定义为每条边 $e$ 的 $\\mathbf{m}_e$。\n将此定理应用于 $I_t$：\n$$\nI_t = - \\int_T \\nabla_S \\cdot \\left(\\frac{\\mathbf{a}_t}{R}\\right) \\,\\mathrm{d}S = - \\oint_{\\partial T} \\frac{\\mathbf{a}_t}{R} \\cdot \\mathbf{m} \\,\\mathrm{d}l.\n$$\n边界积分由三角形三条边上的积分之和构成，我们将其标记为 $e \\in \\{1,2,3\\}$：\n$$\nI_t = - \\sum_{e=1}^3 \\int_{e} \\frac{\\mathbf{a}_t \\cdot \\mathbf{m}_e}{R} \\,\\mathrm{d}l.\n$$\n对于给定的边 $e$，向量 $\\mathbf{a}_t$ 和 $\\mathbf{m}_e$ 是常数。我们可以将它们从积分中提出来：\n$$\nI_t = - \\sum_{e=1}^3 (\\mathbf{a}_t \\cdot \\mathbf{m}_e) \\int_{e} \\frac{\\mathrm{d}l}{R}.\n$$\n项 $\\mathbf{a}_t \\cdot \\mathbf{m}_e = (\\mathbf{a} - (\\mathbf{a}\\cdot\\mathbf{n})\\mathbf{n}) \\cdot \\mathbf{m}_e$。由于 $\\mathbf{m}_e = \\mathbf{n} \\times \\mathbf{t}_e$，$\\mathbf{m}_e$ 与 $\\mathbf{n}$ 正交。因此，$\\mathbf{n} \\cdot \\mathbf{m}_e = 0$，表达式简化为 $\\mathbf{a}_t \\cdot \\mathbf{m}_e = \\mathbf{a} \\cdot \\mathbf{m}_e$。\n\n现在，我们必须计算每条边的线积分 $\\int_e \\frac{\\mathrm{d}l}{R}$。对于一条边 $e$，设包含它的直线由坐标 $s$ 参数化，表示从点 $\\mathbf{p}_e$（直线上离 $\\mathbf{r}_0$ 最近的点）沿单位切向量 $\\mathbf{t}_e$ 的带符号距离。从 $\\mathbf{r}_0$ 到该直线上一点 $\\mathbf{r}$ 的距离 $R$ 为 $R = \\sqrt{s^2 + \\rho_e^2}$，其中 $\\rho_e = |\\mathbf{r}_0 - \\mathbf{p}_e|$ 是从 $\\mathbf{r}_0$ 到该直线的恒定垂直距离。设边的起点对应坐标 $s_{e,1}$，终点对应 $s_{e,2}$。线积分变为：\n$$\n\\int_e \\frac{\\mathrm{d}l}{R} = \\int_{s_{e,1}}^{s_{e,2}} \\frac{\\mathrm{d}s}{\\sqrt{s^2 + \\rho_e^2}}.\n$$\n这是一个标准积分，其原函数是 $\\ln(s + \\sqrt{s^2 + \\rho_e^2})$。在积分上下限处求值得：\n$$\n\\int_e \\frac{\\mathrm{d}l}{R} = \\left[ \\ln(s + \\sqrt{s^2 + \\rho_e^2}) \\right]_{s_{e,1}}^{s_{e,2}} = \\ln(s_{e,2} + \\sqrt{s_{e,2}^2 + \\rho_e^2}) - \\ln(s_{e,1} + \\sqrt{s_{e,1}^2 + \\rho_e^2}).\n$$\n这可以紧凑地写成单个对数形式：\n$$\n\\int_e \\frac{\\mathrm{d}l}{R} = \\ln \\left( \\frac{s_{e,2} + \\sqrt{s_{e,2}^2+\\rho_e^2}}{s_{e,1} + \\sqrt{s_{e,1}^2+\\rho_e^2}} \\right).\n$$\n将此代回 $I_t$ 的表达式中：\n$$\nI_t = - \\sum_{e=1}^3 (\\mathbf{a} \\cdot \\mathbf{m}_e) \\ln \\left( \\frac{s_{e,2} + \\sqrt{s_{e,2}^2+\\rho_e^2}}{s_{e,1} + \\sqrt{s_{e,1}^2+\\rho_e^2}} \\right).\n$$\n结合法向和切向部分，我们得到积分 $I(\\mathbf{a})$ 的最终表达式：\n$$\nI(\\mathbf{a}) = -(\\mathbf{a} \\cdot \\mathbf{n})\\Omega(T) - \\sum_{e=1}^3 (\\mathbf{a} \\cdot \\mathbf{m}_e) \\ln \\left( \\frac{s_{e,2} + \\sqrt{s_{e,2}^2+\\rho_e^2}}{s_{e,1} + \\sqrt{s_{e,1}^2+\\rho_e^2}} \\right).\n$$\n\n这个结果与使用边界元法（BEM）数值求解静电学中的边界积分方程（BIE）高度相关。\n1.  **双层项与立体角：** 双层势算子核为 $\\frac{\\partial G}{\\partial n} = -\\frac{1}{4\\pi}\\frac{(\\mathbf{r}-\\mathbf{r}_0)\\cdot\\mathbf{n}}{R^3}$。在离散化边界积分方程时，必须计算该核函数在三角形面板上的积分。我们对于 $\\mathbf{a}=\\mathbf{n}$ 的结果表明 $\\int_T \\frac{(\\mathbf{r}-\\mathbf{r}_0)\\cdot\\mathbf{n}}{R^3} \\mathrm{d}S = -(\\mathbf{n}\\cdot\\mathbf{n})\\Omega(T) - \\sum (\\mathbf{n}\\cdot\\mathbf{m}_e)\\ln(\\dots) = -\\Omega(T)$，因为 $\\mathbf{n}\\cdot\\mathbf{n}=1$ 且 $\\mathbf{n}\\cdot\\mathbf{m}_e = 0$。这解析地证实了双层核在平面面板上的积分恰好是该面板在场点处所张立体角的负值。这对于计算BEM矩阵的对角元至关重要，因为在对角元处奇异性最为尖锐。\n\n2.  **奇异性正则化：** 原始积分的被积函数量级为 $O(1/R^2)$。当场点 $\\mathbf{r}_0$ 非常接近三角形 $T$ 时，该被积函数变化迅速，使得数值积分变得困难且不准确。我们推导出的公式将这个具有挑战性的二维积分转换为一个立体角项和三个涉及对数的一维边贡献项之和。这是一种正则化形式。“奇异行为”被解析地捕捉和分离出来。得到的表达式是良态的，即使场点靠近源三角形，也能准确高效地计算（只要 $\\mathbf{r}_0$ 不直接位于边上，此时对数项的参数需要小心处理）。这种解析处理对于BEM实现的稳定性和准确性至关重要。积分的切向部分（可能出现在更复杂的物理问题中，例如矢量势表述）被简化为简单的边项之和，完全避免了对奇异核的二维积分。", "answer": "$$\n\\boxed{-(\\mathbf{a} \\cdot \\mathbf{n})\\Omega(T) - \\sum_{e=1}^3 (\\mathbf{a} \\cdot \\mathbf{m}_e) \\ln \\left( \\frac{s_{e,2} + \\sqrt{s_{e,2}^{2}+\\rho_e^{2}}}{s_{e,1} + \\sqrt{s_{e,1}^{2}+\\rho_e^{2}}} \\right)}\n$$", "id": "3357681"}, {"introduction": "精确计算奇异积分固然重要，但了解计算不准确会带来何种后果同样关键。本练习要求您构建一个简化的矩量法 (MoM) 矩阵，并有意地在对角线（自作用）项中引入误差，模拟对源点奇异性处理不当的情形。通过诊断矩阵的对称性、条件数和谱半径等关键指标，您将亲身体会到这些误差如何破坏系统的物理互易性和数值稳定性。[@problem_id:3357690]", "problem": "您的任务是设计并实现一个数值诊断工具，用以评估奇异自相互作用评估中的不准确性如何改变由电场积分方程 (EFIE) 产生的矩阵的谱特性和条件数，并提出基于对称性和互易性的测试来检测此类问题。您的实现必须是一个完整、可运行的程序。设定是一个简化的、但在科学上一致的一维离散化模型，该模型描述了一根细直的完美电导体 (PEC) 导线，并采用矩量法 (MoM) 进行分析，其中使用脉冲 (分段常数) 基函数，并在分段中点进行配置。\n\n从以下基本原理开始：\n\n- 频域中的麦克斯韦方程组表明，由表面电流产生的散射场可以用一个包含自由空间格林函数的积分来表示。对于完美电导体 (PEC)，电场积分方程 (EFie) 强制要求散射体表面上的总切向电场为零，这导出了一个其核函数为自由空间格林函数的积分算子。\n- 三维亥姆霍兹方程的自由空间格林函数为 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{e^{\\mathrm{i} k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}}{4\\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$，其中 $k$ 是波数，单位为米⁻¹ ($\\mathrm{m}^{-1}$)。由 $G$ 构建的积分算子在 $\\mathbf{r} = \\mathbf{r}'$ 处表现出源点奇异性，并在源-观测点近乎重合时表现出场点奇异性；在离散化过程中必须谨慎处理这些问题，以保持物理互易性和理想的数值条件。\n\n您的任务是：\n\n1. 为一根与 $x$ 轴对齐、长度为 $L$ 的细直导线，在数学上构建一个离散的 EFIE 系统。该导线被划分为 $N$ 个长度为 $\\Delta = L/N$ 的相等线段。设线段中点为 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。使用脉冲基函数/测试函数（在中点进行配置）。通过自由空间格林函数的二重积分的中点近似来定义矩阵元素 $A_{ij}$：\n   - 对于 $i \\neq j$，定义 $A_{ij} = \\Delta^2 \\, \\dfrac{e^{\\mathrm{i} k \\lvert x_i - x_j \\rvert}}{4\\pi \\lvert x_i - x_j \\rvert}$。\n   - 对于 $i = j$，用与有限导线半径 $a$（单位：米）一致的细线正则化方法替换奇异项，使用一个物理上合理的有效自作用项 $A_{ii}^{\\text{true}} = \\Delta^2 \\, \\dfrac{1}{4\\pi a}$。然后引入一个不准确的自作用项模型 $A_{ii}^{\\text{inacc}} = A_{ii}^{\\text{true}} \\, (1 + \\varepsilon)$，其中 $\\varepsilon$ 是一个无量纲相对误差参数。这模拟了在处理对角线上的源点奇异性时产生的误差。\n   - 为了模拟可能破坏互易性的近奇异场相互作用中的不准确性（同时保持相同的测试和基函数），允许对紧邻相互作用施加可选的非对称扰动：对于 $\\lvert i - j \\rvert = 1$ 且 $i  j$，仅向 $A_{ij}$ 添加一个偏斜项 $\\delta_{ij} = \\eta \\, \\operatorname{Re}(A_{ij})$（不要将其添加到 $A_{ji}$），其中 $\\eta$ 是一个无量纲偏斜参数。这模拟了对弱奇异性或非对称求积的不一致处理。\n\n2. 提出并实现基于对称性和互易性的诊断方法：\n   - 对称性残差：$s = \\dfrac{\\lVert A - A^{\\mathsf{T}} \\rVert_{\\mathrm{F}}}{\\lVert A \\rVert_{\\mathrm{F}}}$，其中 $\\lVert \\cdot \\rVert_{\\mathrm{F}}$ 表示 Frobenius 范数，$(\\cdot)^{\\mathsf{T}}$ 表示转置。在具有对称核的互易 Galerkin 离散化中，矩阵应为复对称矩阵（$A = A^{\\mathsf{T}}$），因此 $s$ 用于诊断破坏互易性的非对称性。\n   - 互易性最大相对差异：$r = \\max_{i  j} \\dfrac{\\lvert A_{ij} - A_{ji} \\rvert}{\\max(\\lvert A_{ij} \\rvert, \\lvert A_{ji} \\rvert, \\tau)}$，其中 $\\tau$ 是一个为避免除以零而设置的小正阈值。该指标通过关注差异最大的元素对，使对称性残差的诊断更具针对性。\n   - 谱特性与条件数：计算 $A$ 的奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_N \\ge 0$，并定义条件数 $\\kappa = \\dfrac{\\sigma_{\\max}}{\\sigma_{\\min}^{+}}$，其中 $\\sigma_{\\max} = \\sigma_1$，$\\sigma_{\\min}^{+}$ 是超过数值阈值 $\\tau_\\sigma$ 的最小奇异值。同时计算谱半径 $\\rho = \\max_j \\lvert \\lambda_j \\rvert$，其中 $\\lambda_j$ 是 $A$ 的特征值。这些指标量化了不准确的自作用项评估如何影响矩阵的谱和条件数。\n\n3. 将上述内容作为一个独立的程序在代码中实现，该程序能根据给定的参数 $(N, L, a, k, \\varepsilon, \\eta)$ 构建矩阵 $A$，计算 $(s, r, \\kappa, \\rho)$ 并输出它们。所有输出都应为无量纲数。使用以下测试套件来覆盖不同方面：\n   - 案例1（理想情况，准确，互易）：$N = 16$，$L = 1.0\\,\\mathrm{m}$，$a = 1.0 \\times 10^{-3}\\,\\mathrm{m}$，$k = 10.0\\,\\mathrm{m}^{-1}$，$\\varepsilon = 0.0$，$\\eta = 0.0$。\n   - 案例2（中等对角线误差，仍互易）：$N = 16$，$L = 1.0\\,\\mathrm{m}$，$a = 1.0 \\times 10^{-3}\\,\\mathrm{m}$，$k = 10.0\\,\\mathrm{m}^{-1}$，$\\varepsilon = 0.1$，$\\eta = 0.0$。\n   - 案例3（对角线低估，近对角线处互易性被破坏）：$N = 16$，$L = 1.0\\,\\mathrm{m}$，$a = 1.0 \\times 10^{-3}\\,\\mathrm{m}$，$k = 10.0\\,\\mathrm{m}^{-1}$，$\\varepsilon = -0.1$，$\\eta = 0.05$。\n   - 案例4（低频边界，强对角线误差）：$N = 32$，$L = 1.0\\,\\mathrm{m}$，$a = 1.0 \\times 10^{-3}\\,\\mathrm{m}$，$k = 1.0 \\times 10^{-3}\\,\\mathrm{m}^{-1}$，$\\varepsilon = 0.5$，$\\eta = 0.0$。\n\n您的程序应生成单行输出，其中包含结果，格式为一个由方括号括起来的逗号分隔列表，每个测试案例对应一个子列表，并按给定顺序排列。每个子列表的形式为 $[s, r, \\kappa, \\rho]$。例如，输出格式必须与 $[[s_1,r_1,\\kappa_1,\\rho_1],[s_2,r_2,\\kappa_2,\\rho_2],[s_3,r_3,\\kappa_3,\\rho_3],[s_4,r_4,\\kappa_4,\\rho_4]]$ 完全一致。不应打印任何其他文本。", "solution": "本任务旨在设计并实现一个数值诊断工具，用以评估在对细导线应用电场积分方程 (EFIE) 的矩量法 (MoM) 离散化过程中，不准确性所带来的影响。该诊断将重点关注奇异和近奇异相互作用评估中的误差如何影响最终得到的 MoM 矩阵的对称性、互易性、谱特性以及条件数。\n\n### 1. MoM 矩阵的数学公式\n\n我们考虑一根位于 $x$ 轴中心、长度为 $L$、半径为 $a$ 的细直完美电导体 (PEC) 导线。该导线被离散为 $N$ 个长度为 $\\Delta = L/N$ 的相等线段。导线上的电流使用分段常数（脉冲）基函数来近似，每个线段对应一个基函数。EFIE 在每个线段的中点被强制满足（配置法或点匹配法）。此过程产生一个形如 $A \\mathbf{I} = \\mathbf{V}$ 的线性方程组，其中 $A$ 是 $N \\times N$ 的 MoM 矩阵（通常称为阻抗矩阵），$\\mathbf{I}$ 是基函数的未知系数向量（电流幅值），$\\mathbf{V}$ 是由入射电场导出的激励向量。\n\n矩阵的元素 $A_{ij}$ 表示由第 $j$ 个分段（源分段，中心为 $x_j$）上的单位幅值电流基函数在第 $i$ 个分段中心（观测点，$x_i$）产生的切向电场。中点位置为 $x_m = (m + 1/2)\\Delta$，其中 $m \\in \\{0, 1, \\dots, N-1\\}$。\n\n问题通过对相互作用积分采用中点近似来定义矩阵元素，该近似基于亥姆霍兹方程的自由空间格林函数 $G(\\mathbf{r}, \\mathbf{r}') = \\frac{e^{\\mathrm{i}k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}}{4\\pi \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert}$，其中 $k$ 是波数。问题陈述省略了会使 $A$ 具有阻抗单位的物理常数（例如 $\\mathrm{i}\\omega\\mu_0$）；按照定义，$A$ 的元素单位为长度。对于一个主要关注对称性、条件数以及谱半径相对变化等属性的数值诊断而言，这是可以接受的。\n\n**非对角线元素 ($i \\neq j$):**\n对于不同的源和观测分段，相互作用通过计算分段中点之间的格林函数，并乘以分段长度的乘积 $\\Delta^2$ 来近似。中点之间的距離为 $\\lvert x_i - x_j \\rvert = \\lvert i - j \\rvert \\Delta$。\n$$\nA_{ij} = \\Delta^2 \\, \\frac{e^{\\mathrm{i} k \\lvert x_i - x_j \\rvert}}{4\\pi \\lvert x_i - x_j \\rvert} = \\Delta \\, \\frac{e^{\\mathrm{i} k \\lvert i - j \\rvert \\Delta}}{4\\pi \\lvert i - j \\rvert} \\quad \\text{for } i \\neq j\n$$\n\n**对角线元素 ($i = j$):**\n当源点和观测点重合（$i=j$）时，格林函数是奇异的，需要进行正则化处理。一个标准的细线近似法用一个依赖于导线半径 $a$ 的正则化值来代替奇异核。\n问题指定了一个‘真实’的、物理上合理的自作用项：\n$$\nA_{ii}^{\\text{true}} = \\Delta^2 \\, \\frac{1}{4\\pi a}\n$$\n为了模拟对此自相互作用评估中的不准确性，引入了一个相对误差参数 $\\varepsilon$：\n$$\nA_{ii} = A_{ii}^{\\text{inacc}} = A_{ii}^{\\text{true}} (1 + \\varepsilon) = \\frac{\\Delta^2}{4\\pi a} (1 + \\varepsilon)\n$$\n\n**非对称扰动:**\n数值求积误差或对近奇异相互作用的不一致建模可能违反互易性原理，这表现为一个非对称矩阵（$A \\neq A^{\\mathsf{T}}$）。这通过向近对角线元素添加一个偏斜项来建模。对于 $|i - j| = 1$ 且 $i  j$ 的相邻分段（即，在上第一副对角线上），添加一个扰动：\n$$\nA_{ij} \\to A_{ij} + \\delta_{ij} \\quad \\text{for } j = i+1\n$$\n其中 $\\delta_{ij} = \\eta \\, \\operatorname{Re}(A_{ij})$，而 $\\eta$ 是一个无量纲偏斜参数。相应的下副对角线元素 $A_{ji}$ 不被修改，从而破坏了矩阵的对称性。\n\n### 2. 用于矩阵分析的诊断指标\n\n为量化这些不准确性的影响，我们采用四个诊断指标：\n\n**对称性残差 ($s$):**\n电磁学中的互易性意味着，如果使用相同的基函数和测试函数（即 Galerkin 方案）并且几何结构和介质是互易的，那么 MoM 矩阵应该是对称的（$A_{ij} = A_{ji}$）。在我们的配置方案中，由于格林函数 $G(\\mathbf{r}, \\mathbf{r}') = G(\\mathbf{r}', \\mathbf{r})$ 的对称性，矩阵仍然预期是对称的（$A=A^{\\mathsf{T}}$）。对称性残差在 Frobenius 范数下度量了对这一性质的偏离：\n$$\ns = \\frac{\\lVert A - A^{\\mathsf{T}} \\rVert_{\\mathrm{F}}}{\\lVert A \\rVert_{\\mathrm{F}}}\n$$\n一个接近于零的 $s$ 值表示系统在数值上是互易的。\n\n**互易性最大相对差异 ($r$):**\n该指标提供了一种非对称性的最坏情况度量，指出了违反互易性最严重的元素对。\n$$\nr = \\max_{i  j} \\frac{\\lvert A_{ij} - A_{ji} \\rvert}{\\max(\\lvert A_{ij} \\rvert, \\lvert A_{ji} \\rvert, \\tau)}\n$$\n这里，$\\tau$ 是一个防止被小数除的小阈值。与 $s$ 相比，该指标对局部误差更为敏感。\n\n**条件数 ($\\kappa$):**\n矩阵的条件数衡量了线性系统 $A\\mathbf{I}=\\mathbf{V}$ 的解对 $A$ 或 $\\mathbf{V}$ 中扰动的敏感度。大的条件数表示一个病态系统，其中小的数值误差可能导致计算出的电流 $\\mathbf{I}$ 出现大的误差。它使用 $A$ 的奇异值 ($\\sigma_j$) 定义：\n$$\n\\kappa = \\frac{\\sigma_{\\max}}{\\sigma_{\\min}^{+}}\n$$\n其中 $\\sigma_{\\max}$ 是最大的奇异值，$\\sigma_{\\min}^{+}$ 是大于机器精度阈值 $\\tau_\\sigma$ 的最小奇异值。自作用项中的误差（$\\varepsilon \\neq 0$）会显著改变奇异值谱，从而影响条件数。\n\n**谱半径 ($\\rho$):**\n谱半径是矩阵特征值 ($\\lambda_j$) 的最大模：\n$$\n\\rho = \\max_j \\lvert \\lambda_j \\rvert\n$$\n它是一个基本量，决定了像 GMRES 或 BiCGSTAB 等迭代求解器的收敛速度，这些求解器常用于大规模 MoM 问题。由数值误差引起的 $\\rho$ 的变化会影响求解器的性能和稳定性。\n\n### 3. 实现与分析\n\n实现过程包括根据上述规则为每组参数 $(N, L, a, k, \\varepsilon, \\eta)$ 构建矩阵 $A$。一旦 $A$ 组装完成，就使用标准的数值线性代数程序计算这四个诊断指标。\n\n对于每个测试案例，算法流程如下：\n1.  计算离散化长度 $\\Delta = L/N$。\n2.  初始化一个 $N \\times N$ 的复数矩阵 $A$。\n3.  使用格林函数公式填充 $i \\neq j$ 的非对角线元素 $A_{ij}$。\n4.  使用正则化且受扰动的自作用项公式填充对角线元素 $A_{ii}$。\n5.  如果 $\\eta \\neq 0$，将非对称扰动 $\\delta_{i,i+1}$ 添加到元素 $A_{i,i+1}$ 上，其中 $i \\in \\{0, \\dots, N-2\\}$。\n6.  根据 $A$ 及其转置 $A^{\\mathsf{T}}$ 计算对称性残差 $s$。\n7.  通过遍历 $A$ 的上三角部分计算最大相对互易性误差 $r$。\n8.  计算 $A$ 的奇异值以求得条件数 $\\kappa$。\n9.  计算 $A$ 的特征值以求得谱半径 $\\rho$。\n10. 存储结果元组 $(s, r, \\kappa, \\rho)$。\n\n此过程允许系统地研究特定的、建模的数值误差是如何破坏矩量法矩阵的理想属性的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_and_analyze(N, L, a, k, eps, eta):\n    \"\"\"\n    Builds the MoM matrix for a 1D wire and computes diagnostic metrics.\n\n    Args:\n        N (int): Number of segments.\n        L (float): Length of the wire in meters.\n        a (float): Radius of the wire in meters.\n        k (float): Wavenumber in 1/meters.\n        eps (float): Relative error on diagonal terms.\n        eta (float): Skew parameter for near-diagonal asymmetry.\n\n    Returns:\n        tuple: A tuple containing (s, r, kappa, rho).\n    \"\"\"\n    \n    # Define numerical thresholds\n    tau = 1e-16  # Threshold for reciprocity discrepancy denominator\n    tau_sigma = 1e-16 # Threshold for singular values\n\n    # 1. Discretization and Matrix Construction\n    delta = L / N\n    A = np.zeros((N, N), dtype=np.complex128)\n\n    # Generate indices for vectorized computation\n    i_coords = np.arange(N).reshape(N, 1)\n    j_coords = np.arange(N).reshape(1, N)\n    \n    # Off-diagonal entries\n    dist_ij = np.abs(i_coords - j_coords)\n    off_diag_mask = (dist_ij != 0)\n    \n    R = dist_ij[off_diag_mask] * delta\n    \n    # Pre-factor for off-diagonal terms\n    # A_ij = Delta^2 * G(xi, xj) where G is the Green's function\n    # A_ij = Delta^2 * exp(i*k*R) / (4*pi*R)\n    c_off_diag = delta**2 / (4.0 * np.pi)\n    A[off_diag_mask] = c_off_diag * np.exp(1j * k * R) / R\n\n    # Diagonal entries\n    # A_ii = Delta^2 / (4*pi*a) * (1 + eps)\n    A_ii_true = (delta**2) / (4.0 * np.pi * a)\n    A_ii_inacc = A_ii_true * (1.0 + eps)\n    np.fill_diagonal(A, A_ii_inacc)\n\n    # Asymmetric perturbations\n    if eta != 0.0:\n        for i in range(N - 1):\n            j = i + 1\n            # For i  j and |i-j|=1, add skew term\n            A[i, j] += eta * np.real(A[i, j])\n\n    # 2. Compute Diagnostic Metrics\n    \n    # Symmetry residual (s)\n    norm_A = np.linalg.norm(A, 'fro')\n    if norm_A == 0:\n        s = 0.0\n    else:\n        norm_A_minus_AT = np.linalg.norm(A - A.T, 'fro')\n        s = norm_A_minus_AT / norm_A\n\n    # Reciprocity maximum relative discrepancy (r)\n    max_rel_disc = 0.0\n    # Iterate through upper triangle\n    for i in range(N):\n        for j in range(i + 1, N):\n            num = np.abs(A[i, j] - A[j, i])\n            den = np.max([np.abs(A[i, j]), np.abs(A[j, i]), tau])\n            rel_disc = num / den\n            if rel_disc > max_rel_disc:\n                max_rel_disc = rel_disc\n    r = max_rel_disc\n    \n    # Condition number (kappa)\n    singular_values = np.linalg.svd(A, compute_uv=False)\n    sigma_max = singular_values[0] if len(singular_values) > 0 else 0.0\n    \n    positive_sv = singular_values[singular_values > tau_sigma]\n    if len(positive_sv) == 0:\n        kappa = np.inf\n    else:\n        sigma_min_plus = np.min(positive_sv)\n        if sigma_min_plus == 0:\n             kappa = np.inf\n        else:\n             kappa = sigma_max / sigma_min_plus\n\n    # Spectral radius (rho)\n    if N > 0:\n        eigenvalues = np.linalg.eigvals(A)\n        rho = np.max(np.abs(eigenvalues))\n    else:\n        rho = 0.0\n\n    return s, r, kappa, rho\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # (N, L, a, k, eps, eta)\n    test_cases = [\n        (16, 1.0, 1.0e-3, 10.0, 0.0, 0.0),      # Case 1\n        (16, 1.0, 1.0e-3, 10.0, 0.1, 0.0),      # Case 2\n        (16, 1.0, 1.0e-3, 10.0, -0.1, 0.05),    # Case 3\n        (32, 1.0, 1.0e-3, 1.0e-3, 0.5, 0.0),      # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, a, k, eps, eta = case\n        s, r, kappa, rho = build_and_analyze(N, L, a, k, eps, eta)\n        results.append([s, r, kappa, rho])\n    \n    # Format the final output string exactly as required\n    # e.g., [[s1,r1,k1,rho1],[s2,r2,k2,rho2],...]\n    output_str = \"[\" + \",\".join(\n        \"[\" + \",\".join(map(str, sublist)) + \"]\" for sublist in results\n    ) + \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3357690"}, {"introduction": "对于大规模问题，在矩阵填充过程中为每个元素对重复计算奇异积分会造成巨大的计算开销。本练习将指导您设计一种先进的加速策略，即在参考单元上预先计算一系列奇异和近奇异积分值，并将其存储在查找表中。在实际的矩阵组装时，通过快速插值即可获得所需积分值，从而极大地提高计算效率。[@problem_id:3357761]", "problem": "考虑标量亥姆霍兹方程的边界元法 (BEM) 中出现的弱奇异和近奇异表面积分的求值与数值处理。设自由空间格林函数由 $G(\\mathbf{r},\\mathbf{r}') = \\dfrac{e^{\\mathrm{i} k \\|\\mathbf{r} - \\mathbf{r}'\\|}}{4 \\pi \\|\\mathbf{r} - \\mathbf{r}'\\|}$ 给出，其中 $k$ 是波数，单位为弧度/米。对于一个由顶点 $\\mathbf{r}_1$、$\\mathbf{r}_2$ 和 $\\mathbf{r}_3$ 定义的平面三角形表面单元 $\\Delta$，以及与该单元关联的配置场点 $\\mathbf{r}_0$，我们关注以下积分\n$$\nI = \\int_{\\Delta} G(\\mathbf{r}, \\mathbf{r}_0) \\, \\mathrm{d}S(\\mathbf{r}).\n$$\n当 $\\mathbf{r}_0$ 位于单元平面内且在 $\\Delta$ 中时（自洽情况），被积函数是弱奇异的。当 $\\mathbf{r}_0$ 靠近单元，但沿单元法线方向有一小段偏移距离时（近自洽情况），被积函数是近奇异的。\n\n从第一性原理出发：\n- 使用上文指定的亥姆霍兹方程的基本解 $G$。\n- 使用一个平面参考三角形单元，其顶点为 $\\mathbf{r}_1 = (0,0,0)$ 米、$\\mathbf{r}_2 = (h,0,0)$ 米和 $\\mathbf{r}_3 = (0,h,0)$ 米，其中单元尺寸为 $h$ 米。\n- 通过重心坐标参数化配置点，约束在直线 $\\xi = \\eta = s$ 上，其中 $s \\in [0,1]$ 且 $\\xi + \\eta \\le 1$，使得 $\\mathbf{r}_0$ 的平面内坐标为 $(s h, s h)$ 米。沿单位法线 $\\hat{\\mathbf{n}} = (0,0,1)$ 引入一个法向偏移距离 $d$ 米，使得 $\\mathbf{r}_0 = (s h, s h, d)$ 米。自洽情况对应 $d = 0$ 米，近自洽情况对应 $d  0$ 米。\n- 定义无量纲配置向量 $\\mathbf{q} = (s, \\hat{d}, \\hat{k})$，其中 $\\hat{d} = d / h$ 且 $\\hat{k} = k h$。\n\n目标是在参考单元上为 $I(\\mathbf{q})$ 设计并验证一种预计算-插值策略，以减少矩阵组装过程中的即时奇异积分计算：\n1. 对于自洽情况（$d = 0$ 米），通过将 $\\Delta$ 划分为三个以 $\\mathbf{r}_0$ 为顶点的子三角形，并将每个子三角形映射到单位正方形 $(\\alpha,\\beta) \\in [0,1]^2$，推导一个基于 Duffy 变换的求积方法。证明雅可比行列式消除了点奇异性，并产生一个适合标准高斯求积的被积函数。你的推导必须为每个子三角形明确提供映射关系以及由此得到的作为 $\\alpha$ 和 $\\beta$ 函数的非奇异被积函数。\n2. 对于近自洽情况（$d  0$ 米），使用参考三角形的标准参数化，通过 Duffy 变换从单位正方形 $(\\alpha,\\beta) \\in [0,1]^2$ 映射到三角形坐标 $(u,v)$，其中 $u = \\alpha (1 - \\beta)$ 且 $v = \\alpha \\beta$。在该映射下，推导雅可比行列式和距离 $\\|\\mathbf{r} - \\mathbf{r}_0\\|$ 的表达式，并用 $\\alpha$、$\\beta$、$h$、$s$ 和 $d$ 明确表示被积函数。\n\n你必须实现以下算法规范：\n- 将单元尺寸固定为 $h = 0.5$ 米。\n- 基于推导出的映射，为自洽和近自洽情况在 $[0,1]^2$ 上实现一个高阶高斯求积。\n- 在 $\\mathbf{q}$ 空间的一个均匀三维网格上预计算 $I(\\mathbf{q})$ 的表格，其坐标轴为：\n  - $s \\in \\{0.2, 0.25, 0.3, 0.35\\}$,\n  - $\\hat{d} \\in \\{0.0, 0.05, 0.1\\}$,\n  - $\\hat{k} \\in \\{0.0, 0.5, 1.0\\}$。\n  对于预计算，在每个单位区间维度上使用 $N_{\\text{pre}}$ 阶的高斯求积。\n- 在预计算的网格上实现三线性插值，以近似网格点凸包内任意 $\\mathbf{q}$ 处的 $I(\\mathbf{q})$。\n- 通过与使用更高阶（$N_{\\text{truth}}$ 阶）高斯求积在每个单位区间维度上进行的“真值”评估进行比较，来验证该插值策略。\n\n单位和输出：\n- 所有长度必须以米为单位处理，波数以弧度/米为单位。\n- 积分 $I$ 的单位是米。比较必须以相对误差的形式报告，对每个测试用例定义为 $\\left|I_{\\text{interp}} - I_{\\text{truth}}\\right| / \\left|I_{\\text{truth}}\\right|$，该值是无量纲的，并且必须表示为小数。\n- 角度（如有）必须以弧度为单位。\n\n测试套件：\n评估 $(s, \\hat{d}, \\hat{k})$ 的五个测试用例：\n- 用例 1：$(s, \\hat{d}, \\hat{k}) = (0.33, 0.0, 0.0)$。\n- 用例 2：$(s, \\hat{d}, \\hat{k}) = (0.27, 0.05, 0.5)$。\n- 用例 3：$(s, \\hat{d}, \\hat{k}) = (0.22, 0.1, 1.0)$。\n- 用例 4：$(s, \\hat{d}, \\hat{k}) = (0.35, 0.0, 1.0)$。\n- 用例 5：$(s, \\hat{d}, \\hat{k}) = (0.3, 0.05, 0.0)$。\n\n算法参数：\n- 预计算使用 $N_{\\text{pre}} = 40$。\n- 真值评估使用 $N_{\\text{truth}} = 80$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是相应测试用例的相对误差，表示为小数。", "solution": "该问题要求推导并实现一种数值策略，用于计算标量亥姆霍兹方程的边界元法 (BEM) 中出现的弱奇异和近奇异积分。该策略基于预先计算一个积分值表格并使用三线性插值，然后通过与更高精度的直接计算进行比较来验证其有效性。\n\n### **1. 问题构建**\n\n需要计算的积分是：\n$$\nI = \\int_{\\Delta} G(\\mathbf{r}, \\mathbf{r}_0) \\, \\mathrm{d}S(\\mathbf{r})\n$$\n其中 $\\Delta$ 是一个平面三角形表面单元，而 $G(\\mathbf{r},\\mathbf{r}')$ 是亥姆霍兹方程的自由空间格林函数：\n$$\nG(\\mathbf{r},\\mathbf{r}') = \\frac{e^{\\mathrm{i} k \\|\\mathbf{r} - \\mathbf{r}'\\|}}{4 \\pi \\|\\mathbf{r} - \\mathbf{r}'\\|}\n$$\n这里，$k$ 是波数。该问题定义在一个参考等腰直角三角形上，其顶点为 $\\mathbf{r}_1 = (0,0,0)$、$\\mathbf{r}_2 = (h,0,0)$ 和 $\\mathbf{r}_3 = (0,h,0)$。该三角形上的一个点 $\\mathbf{r}$ 可以写成 $\\mathbf{r} = (x,y,0)$，其中 $x \\ge 0$、$y \\ge 0$ 且 $x+y \\le h$。面元为 $\\mathrm{d}S(\\mathbf{r}) = \\mathrm{d}x\\mathrm{d}y$。\n\n配置点 $\\mathbf{r}_0$ 参数化为：\n$$\n\\mathbf{r}_0 = (sh, sh, d)\n$$\n其中 $s$ 控制平面内位置，$d$ 是法向偏移。为了使该点位于三角形内部，需满足 $sh+sh \\le h$，这意味着 $2s \\le 1$ 或 $s \\in [0, 0.5]$。该问题考虑了两种情况：\n- **自洽情况**：$\\mathbf{r}_0$ 位于三角形上，因此 $d=0$。被积函数 $G$ 具有 $1/\\|\\mathbf{r} - \\mathbf{r}_0\\|$ 阶的弱奇异性。\n- **近自洽情况**：$\\mathbf{r}_0$ 靠近三角形，因此 $d  0$ 是一个小数。被积函数是正则的但有尖峰，这在数值上具有挑战性。\n\n积分 $I$ 是无量纲配置向量 $\\mathbf{q} = (s, \\hat{d}, \\hat{k})$ 的函数，其中 $\\hat{d} = d/h$ 且 $\\hat{k} = kh$。\n\n### **2. 自洽情况 ($d=0$) 的推导**\n\n当 $d=0$ 时，配置点 $\\mathbf{p}_0 = (sh, sh, 0)$ 位于三角形 $\\Delta$ 内部。被积函数在该点是奇异的。为了对积分进行正则化，我们采用一种 Duffy 风格的变换。首先，将三角形 $\\Delta$ 划分为三个不重叠的子三角形 $\\Delta_1$、$\\Delta_2$ 和 $\\Delta_3$，它们共用顶点 $\\mathbf{p}_0$。其他顶点取自原始三角形的顶点 $\\mathbf{v}_1=(0,0,0)$、$\\mathbf{v}_2=(h,0,0)$ 和 $\\mathbf{v}_3=(0,h,0)$。这些子三角形是：\n-   $\\Delta_1$：顶点 $(\\mathbf{p}_0, \\mathbf{v}_1, \\mathbf{v}_2)$\n-   $\\Delta_2$：顶点 $(\\mathbf{p}_0, \\mathbf{v}_2, \\mathbf{v}_3)$\n-   $\\Delta_3$：顶点 $(\\mathbf{p}_0, \\mathbf{v}_3, \\mathbf{v}_1)$\n\n总积分是这些子三角形上积分的总和：$I = I_1 + I_2 + I_3$。\n\n对于每个子三角形，我们使用一个坐标变换，将单位正方形 $(\\alpha, \\beta) \\in [0,1]^2$ 映射到该子三角形，并将奇异点映射到参数空间的原点。对于一个具有顶点 $(\\mathbf{A}, \\mathbf{B}, \\mathbf{C})$ 且奇异点在 $\\mathbf{A}$ 的通用子三角形，一个合适的映射是：\n$$\n\\mathbf{r}(\\alpha, \\beta) = \\mathbf{A} + \\alpha(\\mathbf{B} - \\mathbf{A}) + \\alpha\\beta(\\mathbf{C} - \\mathbf{B})\n$$\n与奇异点的距离是 $\\|\\mathbf{r} - \\mathbf{A}\\| = \\alpha \\|(\\mathbf{B} - \\mathbf{A}) + \\beta(\\mathbf{C} - \\mathbf{B})\\|$。此变换的雅可比行列式给出了微分面元：\n$$\n\\mathrm{d}S = \\left\\| \\frac{\\partial \\mathbf{r}}{\\partial \\alpha} \\times \\frac{\\partial \\mathbf{r}}{\\partial \\beta} \\right\\| \\mathrm{d}\\alpha \\mathrm{d}\\beta = \\alpha |\\det((\\mathbf{B} - \\mathbf{A}), (\\mathbf{C} - \\mathbf{A}))| \\mathrm{d}\\alpha \\mathrm{d}\\beta\n$$\n被积函数的奇异部分变换为：\n$$\n\\frac{\\mathrm{d}S}{\\|\\mathbf{r}-\\mathbf{A}\\|} = \\frac{\\alpha |\\det((\\mathbf{B} - \\mathbf{A}), (\\mathbf{C} - \\mathbf{A}))| \\mathrm{d}\\alpha \\mathrm{d}\\beta}{\\alpha \\|(\\mathbf{B} - \\mathbf{A}) + \\beta(\\mathbf{C} - \\mathbf{B})\\|} = \\frac{|\\det((\\mathbf{B} - \\mathbf{A}), (\\mathbf{C} - \\mathbf{A}))|}{\\|(\\mathbf{B} - \\mathbf{A}) + \\beta(\\mathbf{C} - \\mathbf{B})\\|} \\mathrm{d}\\alpha \\mathrm{d}\\beta\n$$\n来自雅可比行列式的因子 $\\alpha$ 与来自分母距离项的因子 $\\alpha$ 相抵消，从而得到一个正则的被积函数，该函数可以使用单位正方形 $[0,1]^2$ 上的标准高斯求积进行精确计算。\n\n将此方法应用于我们的特定子三角形（在 $xy$ 平面上操作）：\n1.  **对于 $\\Delta_1$ （顶点 $\\mathbf{p}_0, \\mathbf{v}_1, \\mathbf{v}_2$）：** $\\mathbf{A}=\\mathbf{p}_0=(sh,sh)$, $\\mathbf{B}=\\mathbf{v}_1=(0,0)$, $\\mathbf{C}=\\mathbf{v}_2=(h,0)$。\n    在 $(\\alpha, \\beta) \\in [0,1]^2$ 上积分的正则化被积函数是：\n    $$\n    F_1(\\alpha, \\beta) = \\frac{sh}{4\\pi} \\frac{\\exp(i \\hat{k} \\alpha \\sqrt{(\\beta-s)^2+s^2})}{\\sqrt{(\\beta-s)^2+s^2}}\n    $$\n2.  **对于 $\\Delta_2$ （顶点 $\\mathbf{p}_0, \\mathbf{v}_2, \\mathbf{v}_3$）：** $\\mathbf{A}=\\mathbf{p}_0=(sh,sh)$, $\\mathbf{B}=\\mathbf{v}_2=(h,0)$, $\\mathbf{C}=\\mathbf{v}_3=(0,h)$。\n    正则化被积函数是：\n    $$\n    F_2(\\alpha, \\beta) = \\frac{h(1-2s)}{4\\pi} \\frac{\\exp(i \\hat{k} \\alpha \\sqrt{(1-s-\\beta)^2+(\\beta-s)^2})}{\\sqrt{(1-s-\\beta)^2+(\\beta-s)^2}}\n    $$\n3.  **对于 $\\Delta_3$ （顶点 $\\mathbf{p}_0, \\mathbf{v}_3, \\mathbf{v}_1$）：** $\\mathbf{A}=\\mathbf{p}_0=(sh,sh)$, $\\mathbf{B}=\\mathbf{v}_3=(0,h)$, $\\mathbf{C}=\\mathbf{v}_1=(0,0)$。\n    正则化被积函数是：\n    $$\n    F_3(\\alpha, \\beta) = \\frac{sh}{4\\pi} \\frac{\\exp(i \\hat{k} \\alpha \\sqrt{s^2+(1-s-\\beta)^2})}{\\sqrt{s^2+(1-s-\\beta)^2}}\n    $$\n总积分是 $I = \\int_0^1\\int_0^1 (F_1+F_2+F_3) \\mathrm{d}\\alpha \\mathrm{d}\\beta$。\n\n### **3. 近自洽情况 ($d0$) 的推导**\n\n当 $d0$ 时，被积函数在 $\\Delta$ 上处处正则。该问题通过将单位正方形 $(\\alpha, \\beta) \\in [0,1]^2$ 映射到标准参考三角形 $(u, v)$（其中 $u,v \\ge 0, u+v \\le 1$），为整个三角形 $\\Delta$ 指定了一个标准参数化。映射关系为 $u = \\alpha(1-\\beta)$ 和 $v = \\alpha\\beta$。那么我们物理三角形 $\\Delta$ 上的坐标是 $(x,y) = (uh, vh)$。\n三角形上的一个点是 $\\mathbf{r}(\\alpha, \\beta) = (h\\alpha(1-\\beta), h\\alpha\\beta, 0)$。从 $(\\alpha, \\beta)$ 到 $(u,v)$ 的变换的雅可比行列式是 $\\alpha$。微分面元是 $\\mathrm{d}S = h^2 \\mathrm{d}u\\mathrm{d}v = h^2\\alpha\\,\\mathrm{d}\\alpha\\mathrm{d}\\beta$。\n配置点是 $\\mathbf{r}_0 = (sh, sh, d)$。距离 $\\|\\mathbf{r}-\\mathbf{r}_0\\|$ 是：\n$$\nR(\\alpha, \\beta) = \\|\\mathbf{r} - \\mathbf{r}_0\\| = \\sqrt{(h\\alpha(1-\\beta) - sh)^2 + (h\\alpha\\beta - sh)^2 + d^2}\n$$\n在 $\\Delta$ 上的积分变成了在单位正方形上的积分：\n$$\nI = \\int_0^1 \\int_0^1 \\frac{e^{\\mathrm{i}k R(\\alpha,\\beta)}}{4\\pi R(\\alpha,\\beta)} (h^2\\alpha) \\, \\mathrm{d}\\alpha \\mathrm{d}\\beta\n$$\n被积函数是：\n$$\nF_{\\text{near}}(\\alpha, \\beta) = \\frac{\\alpha h^2}{4\\pi} \\frac{\\exp\\left(\\mathrm{i} \\frac{\\hat{k}}{h} \\sqrt{h^2 ((\\alpha(1-\\beta)-s)^2 + (\\alpha\\beta-s)^2) + (\\hat{d}h)^2}\\right)}{\\sqrt{h^2 ((\\alpha(1-\\beta)-s)^2 + (\\alpha\\beta-s)^2) + (\\hat{d}h)^2}}\n$$\n由于 $d0$，该被积函数对于所有 $(\\alpha, \\beta) \\in [0,1]^2$ 都是正则的，并且可以使用标准的二维高斯求积进行计算。\n\n### **4. 数值实现**\n\n推导出的被积函数在单位正方形 $[0,1]^2$ 上是正则的，适用于高阶数值求积。使用了一种二维乘积型高斯-勒让德求积法则。\n\n总体策略包括：\n1.  **预计算**：在一个由点 $\\mathbf{q}_i = (s_i, \\hat{d}_i, \\hat{k}_i)$ 构成的均匀网格上，预计算一个三维积分值表格 $I(\\mathbf{q})$。每个积分值都使用 $N_{\\text{pre}}$ 阶的高斯求积计算得出。\n2.  **插值**：对于网格凸包内的任意查询点 $\\mathbf{q}_{\\text{test}}$，积分值 $I(\\mathbf{q}_{\\text{test}})$ 通过对包含 $\\mathbf{q}_{\\text{test}}$ 的网格单元的 8 个角点值进行三线性插值来近似得到。由于积分值是复数，插值分别对实部和虚部进行。\n3.  **验证**：通过将插值结果 $I_{\\text{interp}}$ 与“真值” $I_{\\text{truth}}$ 进行比较，来验证此预计算-插值方案的准确性。“真值”是使用阶数高得多的高斯求积 ($N_{\\text{truth}}  N_{\\text{pre}}$) 直接计算得到的。相对误差 $|I_{\\text{interp}} - I_{\\text{truth}}|/|I_{\\text{truth}}|$ 量化了由低阶预计算和插值本身共同造成的误差。对于位于网格上的测试点，插值误差为零，相对误差衡量的是求积方案在 $N_{\\text{pre}}$ 阶和 $N_{\\text{truth}}$ 阶之间的收敛性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import interpn\n\ndef solve():\n    \"\"\"\n    Solves the BEM integral problem by precomputing a table and using\n    trilinear interpolation, then validates against a high-accuracy calculation.\n    \"\"\"\n    \n    # Global parameters from the problem statement\n    H = 0.5  # meter\n    N_pre = 40\n    N_truth = 80\n\n    # Test cases for the configuration vector q = (s, d_hat, k_hat)\n    test_cases = [\n        (0.33, 0.0, 0.0),\n        (0.27, 0.05, 0.5),\n        (0.22, 0.1, 1.0),\n        (0.35, 0.0, 1.0),\n        (0.3, 0.05, 0.0),\n    ]\n\n    # Precomputation grid definition\n    s_grid = np.array([0.2, 0.25, 0.3, 0.35])\n    d_hat_grid = np.array([0.0, 0.05, 0.1])\n    k_hat_grid = np.array([0.0, 0.5, 1.0])\n\n    def get_gauss_quad(N):\n        \"\"\"Returns Gaussian quadrature points and weights mapped to [0, 1].\"\"\"\n        points, weights = np.polynomial.legendre.leggauss(N)\n        points = 0.5 * (points + 1.0)\n        weights = 0.5 * weights\n        return points, weights\n\n    def compute_integral(s, d_hat, k_hat, N):\n        \"\"\"\n        Computes the integral I(q) using 2D Gaussian quadrature of order N.\n        It dispatches between self-case (d=0) and near-self-case (d>0) logic.\n        \"\"\"\n        h = H\n        d = d_hat * h\n        k = k_hat / h if h != 0.0 else 0.0\n\n        points, weights = get_gauss_quad(N)\n        alpha, beta = np.meshgrid(points, points)\n        w_alpha, w_beta = np.meshgrid(weights, weights)\n        \n        total_integral = 0.0 + 0.0j\n\n        if np.isclose(d, 0.0):  # Self-case with Duffy transformation\n            # Contribution from sub-triangle 1\n            denom1 = np.sqrt((beta - s)**2 + s**2)\n            arg1 = k * alpha * h * denom1\n            integrand1 = (s * h / (4 * np.pi)) * np.exp(1j * arg1) / denom1\n            total_integral += np.sum(integrand1 * w_alpha * w_beta)\n\n            # Contribution from sub-triangle 2\n            if not np.isclose(1.0 - 2.0 * s, 0.0):\n                denom2 = np.sqrt((1.0 - s - beta)**2 + (beta - s)**2)\n                arg2 = k * alpha * h * denom2\n                integrand2 = (h * (1.0 - 2.0 * s) / (4.0 * np.pi)) * np.exp(1j * arg2) / denom2\n                total_integral += np.sum(integrand2 * w_alpha * w_beta)\n\n            # Contribution from sub-triangle 3\n            denom3 = np.sqrt(s**2 + (1.0 - s - beta)**2)\n            arg3 = k * alpha * h * denom3\n            integrand3 = (s * h / (4.0 * np.pi)) * np.exp(1j * arg3) / denom3\n            total_integral += np.sum(integrand3 * w_alpha * w_beta)\n        \n        else:  # Near-self case\n            term1 = alpha * (1.0 - beta) - s\n            term2 = alpha * beta - s\n            R = np.sqrt(h**2 * (term1**2 + term2**2) + d**2)\n            \n            arg = k * R\n            integrand_near = (alpha * h**2 / (4.0 * np.pi)) * np.exp(1j * arg) / R\n            total_integral = np.sum(integrand_near * w_alpha * w_beta)\n\n        return total_integral\n\n    # --- Precomputation Phase ---\n    precomputed_table = np.zeros(\n        (len(s_grid), len(d_hat_grid), len(k_hat_grid)),\n        dtype=np.complex128\n    )\n\n    for i, s_val in enumerate(s_grid):\n        for j, d_hat_val in enumerate(d_hat_grid):\n            for l, k_hat_val in enumerate(k_hat_grid):\n                precomputed_table[i, j, l] = compute_integral(\n                    s_val, d_hat_val, k_hat_val, N_pre\n                )\n\n    # --- Validation Phase ---\n    results = []\n    grids = (s_grid, d_hat_grid, k_hat_grid)\n    for q_test in test_cases:\n        s_test, d_hat_test, k_hat_test = q_test\n        point_to_interp = np.array([s_test, d_hat_test, k_hat_test])\n        \n        # 1. \"Truth\" evaluation with high-order quadrature\n        I_truth = compute_integral(s_test, d_hat_test, k_hat_test, N_truth)\n        \n        # 2. Interpolation from precomputed table\n        # scipy.interpolate.interpn handles interpolation on structured grids.\n        # It's applied separately to real and imaginary parts.\n        I_interp_real = interpn(grids, precomputed_table.real, point_to_interp,\n                                method='linear', bounds_error=False, fill_value=None)[0]\n        I_interp_imag = interpn(grids, precomputed_table.imag, point_to_interp,\n                                method='linear', bounds_error=False, fill_value=None)[0]\n        I_interp = I_interp_real + 1j * I_interp_imag\n\n        # 3. Calculate relative error\n        abs_I_truth = np.abs(I_truth)\n        if np.isclose(abs_I_truth, 0.0):\n            # If truth value is zero, relative error is not well-defined.\n            # Use absolute error instead. Should not occur for these integrals.\n            relative_error = np.abs(I_interp)\n        else:\n            relative_error = np.abs(I_interp - I_truth) / abs_I_truth\n        \n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10e}' for r in results)}]\")\n\nsolve()\n```", "id": "3357761"}]}