{"hands_on_practices": [{"introduction": "对于球体这样的标准几何形状，其内部谐振频率可以通过解析方法精确计算。本练习旨在建立理论概念与实际计算之间的桥梁，将电场积分方程 (EFIE) 和磁场积分方程 (MFIE) 的失效模式与球谐贝塞尔函数的零点直接关联起来。通过完成此练习，您将构建一个基础诊断工具，用于预测积分方程求解器在何种频率下可能遇到不稳定性 [@problem_id:3319829]。", "problem": "您被要求编写一个完整且可运行的程序，该程序通过使用从变量分离法导出的解析内部本征值信息，来诊断理想电导体球体的电场积分方程 (EFIE) 和磁场积分方程 (MFIE) 的内部谐振。对于半径为 $a$、波数为 $k$（单位为 $\\mathrm{m}^{-1}$）的球体，导致 EFIE 病态的内部谐振发生在标量亥姆霍兹方程的内部狄利克雷(Dirichlet)本征值处，而导致 MFIE 病态的内部谐振则发生在内部诺伊曼(Neumann)本征值处。对于球形几何，变量分离法会引出 $\\ell$ 阶球贝塞尔函数 $j_{\\ell}(x)$，其本征值通过无量纲量 $x = ka$ 来表征：\n- 狄利克雷（内部）本征值：$j_{\\ell}(ka) = 0$，\n- 诺伊曼（内部）本征值：$j_{\\ell}'(ka) = 0$，\n其中撇号表示对自变量求导。\n\n从频域中的矢量麦克斯韦(Maxwell)方程组出发，当在矢量球谐函数中展开时，理想电导体球体的散射场边界积分方程可简化为独立的标量径向条件。对于横磁波类型（其污染 EFIE），这些条件的根与 $j_{\\ell}(x)$ 的零点重合；对于横电波类型（其污染 MFIE），这些条件的根与 $j_{\\ell}'(x)$ 的零点重合。因此，当 $ka$ 接近这些零点之一时，相应的积分算子会产生一个近零空间，其条件数会变得很大。在本问题中，您将：\n- 对于阶数 $\\ell \\in \\{0,1,\\dots,L\\}$，计算 $j_{\\ell}(x)$ 的前 $N$ 个零点集合 $\\{x_{\\ell,n}^{(D)}\\}_{n=1}^{N}$（狄利克雷集），以及对于相同 $\\ell$ 范围，计算 $j_{\\ell}'(x)$ 的前 $N$ 个零点集合 $\\{x_{\\ell,n}^{(N)}\\}_{n=1}^{N}$（诺伊曼集），\n- 对于测试波数 $k$ 和半径 $a$，在 $x$ 域中评估最小距离 $\\delta_E = \\min_{\\ell \\le L, n \\le N} \\lvert ka - x_{\\ell,n}^{(D)} \\rvert$ 和 $\\delta_M = \\min_{\\ell \\le L, n \\le N} \\lvert ka - x_{\\ell,n}^{(N)} \\rvert$，\n- 定义 EFIE 和 MFIE 的代理条件度量为 $C_E = 1/\\max(\\delta_E,\\varepsilon)$ 和 $C_M = 1/\\max(\\delta_M,\\varepsilon)$，其中 $\\varepsilon$ 是一个很小的下限值，以避免除以零。这些无量纲代理值随着 $k a$ 接近谐振而增大，反映了积分方程的病态性。\n\n您的程序必须仅使用基本的数学和物理原理来实现以下内容：\n- 使用时谐麦克斯韦方程组和理想电导体球体上的边界条件，来论证 EFIE 内部谐振与内部狄利克雷本征值重合，MFIE 内部谐振与内部诺伊曼本征值重合，并且这些谐振可由上述球贝塞尔函数零点条件所捕捉。\n- 对于每个 $\\ell \\in \\{0,\\dots,L\\}$，在 $x \\in (0,\\infty)$ 上，通过稳健的一维求根区间限定和类二分法，数值计算 $j_{\\ell}(x)$ 和 $j_{\\ell}'(x)$ 的前 $N$ 个正零点，仅依赖于目标函数明确的符号变化。您可以假设 $j_{\\ell}(x)$ 在 $x \\ge 0$ 上是连续的，在经过一个有限的起始段后是严格振荡的，并且其零点是简单的，并与其导数的零点交错分布。\n- 对于每个测试用例，聚合指定范围 $\\ell$ 和索引 $n$ 的所有零点，并计算最小间距 $\\delta_E$ 和 $\\delta_M$。\n\n物理单位和输出规格：\n- 球体半径必须以米（$\\mathrm{m}$）为单位指定。\n- 波数必须以米分之一（$\\mathrm{m}^{-1}$）为单位指定。\n- 无量纲参数为 $x = ka$。\n- 您的代理条件度量 $C_E$ 和 $C_M$ 是无量纲的，并且必须以浮点数形式生成。\n\n测试套件和答案规格：\n- 使用以下测试套件，其中每个测试用例是一个元组 $(a, L, N, k)$：\n    1. $(a=\\;0.5\\;\\mathrm{m},\\;L=\\;6,\\;N=\\;4,\\;k=\\;6.2\\;\\mathrm{m}^{-1})$，\n    2. $(a=\\;0.5\\;\\mathrm{m},\\;L=\\;6,\\;N=\\;4,\\;k=\\;8.99\\;\\mathrm{m}^{-1})$，\n    3. $(a=\\;0.5\\;\\mathrm{m},\\;L=\\;6,\\;N=\\;4,\\;k=\\;2.0\\;\\mathrm{m}^{-1})$，\n    4. $(a=\\;1.0\\;\\mathrm{m},\\;L=\\;8,\\;N=\\;3,\\;k=\\;4.50\\;\\mathrm{m}^{-1})$，\n    5. $(a=\\;0.2\\;\\mathrm{m},\\;L=\\;4,\\;N=\\;5,\\;k=\\;20.0\\;\\mathrm{m}^{-1})$。\n- 在 $C_E$ 和 $C_M$ 的定义中使用距离下限值 $\\varepsilon = 10^{-6}$。\n- 对于每个测试用例，计算并返回序对 $[C_E, C_M]$，形式为一个包含两个浮点数的列表，在打印输出中四舍五入到至少 $6$ 位有效数字。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试套件的结果，格式为方括号括起来的逗号分隔列表，其中每个元素本身是 $[C_E, C_M]$ 的一个双元素列表。例如，最终打印的行必须具有以下形式：\n- $[\\,[C_{E,1},C_{M,1}],\\,[C_{E,2},C_{M,2}],\\,\\dots\\,]$。", "solution": "本问题的主题是诊断用于理想电导体 (PEC) 球体电磁散射的频域边界积分方程中的内部谐振。电场积分方程 (EFIE) 和磁场积分方程 (MFIE) 是解决此类问题的标准公式。然而，它们存在一个关键缺陷：在与散射体内部形成的空腔的谐振模式相对应的频率下，它们的离散表示会变得病态。此分析证实了所提供的问题陈述，并为数值求解奠定了基础。\n\n首先，我们建立积分方程与内部本征值之间的理论联系。分析始于时谐麦克斯韦(Maxwell)方程组，假设时间依赖关系为 $e^{i\\omega t}$，其中 $\\omega=kc$ 是角频率，$k$ 是波数，$c$ 是介质中的光速。\n$$\n\\nabla \\times \\vec{E} = -i \\omega \\mu \\vec{H} \\\\\n\\nabla \\times \\vec{H} = i \\omega \\epsilon \\vec{E} + \\vec{J}\n$$\n对于一个涉及占据体积 $V$、由表面 $S$ 界定的理想电导体物体的散射问题，我们必须找到由入射场 $(\\vec{E}^{inc}, \\vec{H}^{inc})$ 感应出的表面电流 $\\vec{J}_s$。总场是入射场和散射场的和，例如 $\\vec{E} = \\vec{E}^{inc} + \\vec{E}^{scat}$。\n\nEFIE 源于理想电导体的边界条件，即总电场的切向分量在表面 $S$ 上必须为零：\n$$\n\\hat{n} \\times \\vec{E}|_S = \\hat{n} \\times (\\vec{E}^{inc} + \\vec{E}^{scat})|_S = 0\n$$\n散射电场 $\\vec{E}^{scat}$ 由表面电流 $\\vec{J}_s$ 产生，并可通过作用于 $\\vec{J}_s$ 的积分算子 $\\mathcal{E}$ 来表示，即 $\\vec{E}^{scat} = \\mathcal{E}(\\vec{J}_s)$。这导出了算子方程 $\\mathcal{L}_{EFIE}(\\vec{J}_s) \\equiv (\\hat{n} \\times \\mathcal{E}(\\vec{J}_s))|_S = -(\\hat{n} \\times \\vec{E}^{inc})|_S$。如果存在一个非平凡电流 $\\vec{J}_s$ 使得 $\\mathcal{L}_{EFIE}(\\vec{J}_s)=0$，则算子 $\\mathcal{L}_{EFIE}$ 是不可逆的。这种情况恰好发生在这样的波数 $k$ 处：其对应的齐次内部问题有解，即在体积 $V$ 内寻找一个非平凡场 $\\vec{E}_{int}$，满足 $\\nabla \\times \\nabla \\times \\vec{E}_{int} - k^2\\vec{E}_{int} = 0$ 以及边界条件 $\\hat{n} \\times \\vec{E}_{int}|_S = 0$。这些波数是理想电导体空腔的谐振频率，对应于矢量亥姆霍兹(Helmholtz)算子的内部狄利克雷(Dirichlet)本征值。\n\nMFIE 源于跨越表面 $S$ 的磁场切向分量的连续性条件。$S$ 外部紧邻处的总切向磁场通过 $\\hat{n} \\times \\vec{H}|_S = \\vec{J}_s$ 与表面电流相关。这导出了算子方程 $\\mathcal{L}_{MFIE}(\\vec{J}_s) \\equiv \\vec{J}_s - \\hat{n} \\times \\mathcal{H}(\\vec{J}_s)|_S = \\hat{n} \\times \\vec{H}^{inc}|_S$，其中 $\\mathcal{H}$ 是产生散射磁场的算子。算子 $\\mathcal{L}_{MFIE}$ 在与对偶内部问题谐振相对应的波数 $k$ 处失效，该问题与场上的齐次诺伊曼(Neumann)边界条件相关。这些即是内部诺伊曼本征值。\n\n对于半径为 $a$ 的球体，这些矢量边值问题可以通过变量分离法和矢量球谐函数展开来简化。球体内部的解在原点处必须是正则的。这些解的径向依赖关系由第一类球贝塞尔函数 $j_{\\ell}(kr)$ 给出。\n对矢量球谐函数的分析表明，场解可以分为两种类型：相对于径向方向 $\\hat{r}$ 的横磁波 (TM) 和横电波 (TE)。", "answer": "```python\nimport numpy as np\nfrom scipy.special import spherical_jn\nfrom scipy.optimize import brentq\nimport json\n\ndef solve():\n    \"\"\"\n    Computes EFIE and MFIE conditioning proxies for PEC spheres by analyzing distances\n    to interior resonance wavenumbers.\n    \"\"\"\n    test_cases = [\n        # (a, L, N, k)\n        (0.5, 6, 4, 6.2),\n        (0.5, 6, 4, 8.99),\n        (0.5, 6, 4, 2.0),\n        (1.0, 8, 3, 4.50),\n        (0.2, 4, 5, 20.0),\n    ]\n\n    epsilon = 1e-6\n\n    def find_zeros(l, N, derivative):\n        \"\"\"\n        Finds the first N positive zeros of j_l(x) or j_l'(x) for a given order l.\n        Uses scanning to find brackets, then brentq to find roots.\n        \"\"\"\n        zeros = []\n        f = lambda x: spherical_jn(l, x, derivative=derivative)\n        \n        # Start scanning for roots from a small positive number to avoid x=0.\n        x_current = 0.1\n        scan_step = 0.1\n\n        # For l>0, j_l(0)=0 and j'_l(0)=0 (for l>1).\n        # We seek positive roots, so starting at x_current > 0 is correct.\n        \n        y_current = f(x_current)\n        \n        while len(zeros)  N:\n            # Move along the x-axis to find a sign change.\n            x_next = x_current + scan_step\n            y_next = f(x_next)\n            \n            # If a sign change is detected, there is a root in [x_current, x_next].\n            if np.sign(y_current) != np.sign(y_next):\n                try:\n                    root = brentq(f, x_current, x_next)\n                    # Add if it's a new root (to guard against re-finding)\n                    if not any(np.isclose(root, z) for z in zeros):\n                        zeros.append(root)\n                    # Advance the ancher to continue searching past the found root.\n                    x_current = root + scan_step\n                    y_current = f(x_current)\n\n                except ValueError: # Should not happen with a sign change\n                    x_current = x_next\n                    y_current = y_next\n            else:\n                x_current = x_next\n                y_current = y_next\n        \n        return zeros\n\n    # Determine maximum L and N from test cases to pre-compute all needed zeros.\n    L_max = max(tc[1] for tc in test_cases)\n    N_max = max(tc[2] for tc in test_cases)\n\n    # Pre-compute zeros to avoid redundant calculations.\n    # precomputed_dirichlet_zeros[l] will be a list of the first N_max zeros of j_l(x)\n    precomputed_dirichlet_zeros = [find_zeros(l, N_max, derivative=False) for l in range(L_max + 1)]\n    # precomputed_neumann_zeros[l] will be a list of the first N_max zeros of j_l'(x)\n    precomputed_neumann_zeros = [find_zeros(l, N_max, derivative=True) for l in range(L_max + 1)]\n\n    final_results = []\n    \n    for a, L, N, k in test_cases:\n        # Assemble the sets of active roots for the current test case.\n        active_dirichlet_roots = []\n        for l in range(L + 1):\n            active_dirichlet_roots.extend(precomputed_dirichlet_zeros[l][:N])\n\n        active_neumann_roots = []\n        for l in range(L + 1):\n            active_neumann_roots.extend(precomputed_neumann_zeros[l][:N])\n            \n        x_test = k * a\n\n        # Compute minimum distances to the resonance sets.\n        delta_E = np.min(np.abs(np.array(active_dirichlet_roots) - x_test))\n        delta_M = np.min(np.abs(np.array(active_neumann_roots) - x_test))\n\n        # Compute conditioning proxies.\n        C_E = 1.0 / max(delta_E, epsilon)\n        C_M = 1.0 / max(delta_M, epsilon)\n\n        final_results.append([C_E, C_M])\n\n    # Format the output string exactly as required.\n    # Using json.dumps provides a compact, space-free representation of a list of lists.\n    # The default float precision is sufficient.\n    class CustomEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, np.floating):\n                return float(obj)\n            return json.JSONEncoder.default(self, obj)\n\n    print(json.dumps(final_results, separators=(',', ':'), cls=CustomEncoder))\n\nsolve()\n```", "id": "3319829"}, {"introduction": "在能够预测谐振频率之后, 下一步是量化其对数值系统的具体影响。本练习聚焦于二维圆形散射体, 在这种特殊几何下, EFIE 算子可以在傅里叶基中对角化。您将通过计算发现, 当波数 $k$ 趋近于已知的内部谐振频率时, 离散化后系统矩阵的条件数会急剧增大, 从而直观地展示数值不稳定性的程度 [@problem_id:3319757]。", "problem": "考虑二维横电极化下的时谐电磁散射，其中电场的唯一非零分量是平面外标量场 $E_z(\\mathbf{r})$，它在一个具有光滑边界 $\\Gamma$ 的完美电导体障碍物的外部满足标量 Helmholtz 方程 $\\nabla^2 E_z + k^2 E_z = 0$。针对 Dirichlet 边界条件 $E_z|_{\\Gamma} = 0$ 的电场积分方程 (EFIE) 可以用单层积分算子表示\n$$\n(S_k \\varphi)(\\mathbf{r}) = \\int_{\\Gamma} G_k(\\mathbf{r}, \\mathbf{r}') \\, \\varphi(\\mathbf{r}') \\, \\mathrm{d}s(\\mathbf{r}'),\n$$\n其中 $G_k(\\mathbf{r}, \\mathbf{r}') = \\frac{i}{4} H_0^{(1)}(k \\lVert \\mathbf{r} - \\mathbf{r}' \\rVert)$ 是 Helmholtz 方程的二维自由空间格林函数，$H_0^{(1)}$ 是零阶第一类 Hankel 函数，$k$ 是波数（在此数学表述中为无量纲）。当算子 $S_k$ 因内部 Dirichlet 问题存在非平凡解而变得不可逆时，EFIE 的内部谐振就会出现。这些非平凡解对应于那些使得内部问题 $\\nabla^2 u + k^2 u = 0$ 在边界条件 $u|_{\\Gamma} = 0$ 下存在非零解的 $k$ 值。\n\n在一个半径为 $a$、由 $\\mathbf{r}(\\theta) = a(\\cos\\theta, \\sin\\theta)$（$0 \\le \\theta  2\\pi$）参数化的圆上，算子 $S_k$ 在角变量上表现为卷积，并在傅里叶基 $\\{e^{i m \\theta}\\}_{m \\in \\mathbb{Z}}$ 中对角化。使用 Bessel 函数和 Hankel 函数的 Graf 加法定理，算子 $S_k$ 对傅里叶模式 $e^{i m \\theta}$ 的作用等效于乘以一个标量\n$$\ns_m(k) = a \\frac{i\\pi}{2} H_m^{(1)}(k a) J_m(k a),\n$$\n其中 $J_m$ 是 m 阶第一类 Bessel 函数，$H_m^{(1)}$ 是 m 阶第一类 Hankel 函数。对于圆形区域，内部 Dirichlet 特征值（谐振）出现在满足 $J_m(k a) = 0$（对于某个整数 $m$）的 $k$ 值处，这导致 $s_m(k)$ 变为零，EFIE 变得奇异。\n\n通过将傅里葉基截断为模式 $m = -M, \\ldots, M$，对半径为 $a$ 的圆上的 EFIE进行离散化，从而得到一个 $(2M+1) \\times (2M+1)$ 的对角方阵，其对角元为 $\\{s_m(k)\\}_{m=-M}^{M}$。对于给定的 $k$，将此离散化 EFIE 矩阵的条件数定义为\n$$\n\\kappa(k; a, M) = \\frac{\\max_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}{\\min_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}.\n$$\n在与模式 $m$ 相关的内部谐振点附近，由于 $J_m(k a) \\to 0$，$\\lvert s_m(k) \\rvert$ 的值会变小，条件数也相应地增大。\n\n任务：编写一个完整、可运行的程序，实现以下功能：\n- 使用上述圆上的傅里叶-Galerkin 离散化方法，为指定的 $k$ 值计算条件数 $\\kappa(k; a, M)$。\n- 使用 $a = 1$ 和 $M = 20$。\n- 确定模式 $m = 0$ 的第一个内部 Dirichlet 谐振点 $k_0$，即 $J_0(k a)$ (其中 $a=1$) 的最小正根。\n- 针对以下波数测试集，评估条件数：\n  1. $k = 1.0$ (远离谐振点),\n  2. $k = k_0 - 0.2$ (在谐振点下方中等距离处),\n  3. $k = k_0 - 0.05$ (在谐振点下方附近),\n  4. $k = k_0 - 0.005$ (在谐振点下方非常近的位置),\n  5. $k = k_0 + 0.05$ (在谐振点上方附近),\n  6. $k = 3.0$ (在第一个谐振点之上，下一个谐振点之下).\n- 生成最终输出，格式为单行文本，包含上述测试集的六个条件数，形式为逗号分隔并用方括号括起来的 Python 列表，例如 $[c_1,c_2,c_3,c_4,c_5,c_6]$，其中每个 $c_j$ 都是一个浮点数。\n\n注：\n- 此问题中的所有量均为无量纲；无需物理单位。\n- 您的实现必须使用指定的傅里叶符号 $s_m(k)$，并且条件数必须计算为最大奇异值与最小奇异值的比值。对于对角矩阵，奇异值即为其对角元绝对值。\n- 通过使用可靠的 $J_m$ 和 $H_m^{(1)}$ 特殊函数求值方法来确保数值稳定性。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4,result5,result6]”）。", "solution": "该问题被评估为有效。它在科学上基于计算电磁学原理，特别是针对散射问题的积分方程方法。其表述是适定的，提供了计算出唯一、有意义的数值结果所需的所有必要参数、方程和定义。语言客观且数学上精确。\n\n该问题要求计算圆形散射体的离散化电场积分方程 (EFIE) 算子的条件数。这用于演示内部谐振现象，即算子变得病态或奇异的情况。\n\n物理背景是二维时谐电磁波从一个完美电导 (PEC) 圆柱体上的散射。对于横电 (TE) 极化，问题简化为求解电场平面外分量 $E_z(\\mathbf{r})$ 的标量 Helmholtz 方程：\n$$\n(\\nabla^2 + k^2) E_z(\\mathbf{r}) = 0\n$$\n该方程在散射体外部的区域成立。这里，$k$ 是波数。对于 PEC 散射体，边界 $\\Gamma$ 上的总切向电场必须为零，这对标量场 $E_z$ 意味着 Dirichlet 边界条件 $E_z|_{\\Gamma} = 0$。\n\nEFIE 源于将散射场表示为单层势。这导出了一个关于未知表面电流密度 $\\varphi(\\mathbf{r}')$ 的积分方程。所涉及的算子是单层算子 $S_k$：\n$$\n(S_k \\varphi)(\\mathbf{r}) = \\int_{\\Gamma} G_k(\\mathbf{r}, \\mathbf{r}') \\, \\varphi(\\mathbf{r}') \\, \\mathrm{d}s(\\mathbf{r}')\n$$\n其中 $G_k(\\mathbf{r}, \\mathbf{r}')$ 是二维自由空间格林函数，$H_0^{(1)}$ 是零阶第一类 Hankel 函数。\n\nEFIE 的一个关键问题是内部谐振的存在。这些谐振发生在特定的波数 $k$ 处，对于这些波数，相应的内部 Dirichlet 问题（即散射体内部的 Helmholtz 方程加上零边界条件）具有非平凡解。在这些谐振波数处，外部 EFIE 算子 $S_k$ 变得不可逆，数值解也变得不稳定。\n\n对于半径为 $a$ 的圆形散射体，由于对称性，问题大大简化。算子 $S_k$ 在角变量上表现为卷积，并可被傅里叶基函数 $\\{e^{i m \\theta}\\}_{m \\in \\mathbb{Z}}$ 对角化。$S_k$ 对 $e^{i m \\theta}$ 的作用简化为乘以一个标量，即符号 $s_m(k)$：\n$$\ns_m(k) = a \\frac{i\\pi}{2} H_m^{(1)}(k a) J_m(k a)\n$$\n此处，$J_m$ 和 $H_m^{(1)}$ 分别是 $m$ 阶 Bessel 函数和 Hankel 函数。对于圆形区域，内部谐振对应于使 $ka$ 成为某个 Bessel 函数 $J_m$ 的零点的波数 $k$。在这样的 $k$ 值处，符号 $s_m(k)$ 变为零，表明 $S_k$ 的不可逆性。\n\n问题要求我们通过将傅里叶级数截断为有限数量的模式 $m \\in \\{-M, \\ldots, M\\}$ 来离散化算子。在此基下，该算子由一个 $(2M+1) \\times (2M+1)$ 的对角矩阵 $S_{k,M}$ 表示，其对角线上是符号 $\\{s_m(k)\\}_{m=-M}^{M}$。\n\n该矩阵的条件数 $\\kappa(S_{k,M})$ 衡量其对扰动的敏感度以及接近奇异的程度。对于对角矩阵，奇异值是其对角元的绝对值。因此，条件数由最大奇异值与最小奇异值的比值给出：\n$$\n\\kappa(k; a, M) = \\frac{\\max_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}{\\min_{-M \\le m \\le M} \\lvert s_m(k) \\rvert}\n$$\n在谐振点附近（例如，对于模式 $m_0$，其中 $ka$ 接近于 $J_{m_0}$ 的一个零点），$\\lvert s_{m_0}(k) \\rvert$ 的值会变得非常小。这个小值出现在条件数公式的分母中，导致 $\\kappa$ 变得非常大，标志着数值问题的病态性。\n\n计算过程如下：\n1.  设置固定参数：半径 $a=1$ 和傅里叶截断极限 $M=20$。所考虑的模式为 $m \\in \\{-20, -19, \\ldots, 19, 20\\}$。\n2.  确定模式 $m=0$ 的第一个内部 Dirichlet 谐振点 $k_0$。这是使 $J_0(k a) = J_0(k) = 0$ 成立的最小正数 $k$。该值是一个著名的数学常数，即 $J_0(x)$ 的第一个零点，约等于 $2.4048$。我们通过数值方法找到这个高精度的值。\n3.  基于计算出的 $k_0$ 值，构建波数 $k$ 的测试集。\n4.  对于测试集中的每个测试波数 $k$：\n    a. 生成模式数 $m$ 的数组，范围从 $-M$ 到 $M$。\n    b. 使用公式 $s_m(k) = a \\frac{i\\pi}{2} H_m^{(1)}(ka) J_m(ka)$ 计算符号集 $\\{s_m(k)\\}_{m=-M}^{M}$。注意，由于 $J_{-m}(z) = (-1)^m J_m(z)$ 和 $H_{-m}^{(1)}(z) = (-1)^m H_m^{(1)}(z)$，因此可推导出 $s_{-m}(k) = s_m(k)$。我们的计算将直接处理从 $-M$ 到 $M$ 的所有 $m$。\n    c. 计算所有符号的绝对值，$\\{\\lvert s_m(k) \\rvert\\}_{m=-M}^{M}$。\n    d. 找到这些绝对值的最大值和最小值。\n    e. 将最大值与最小值的比值作为条件数 $\\kappa$ 进行计算。\n5.  收集六个计算出的条件数，并以指定格式呈现。必要的特殊函数（$J_m, H_m^{(1)}$）和用于 $J_0$ 的寻根程序可在 `scipy.special` 库中找到。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, hankel1, jn_zeros\n\ndef solve():\n    \"\"\"\n    Computes the condition number of a discretized EFIE operator on a circle\n    to demonstrate the effect of internal resonances.\n    \"\"\"\n    \n    # Define the problem parameters as specified.\n    a = 1.0\n    M = 20\n\n    # Step 1: Find the first interior Dirichlet resonance k_0 for m=0.\n    # This is the smallest positive root of J_0(k*a) = 0, which is the first\n    # zero of the Bessel function J_0(x) divided by a.\n    # jn_zeros(0, 1) returns an array containing the first positive zero of J_0.\n    # Since a=1, k_0 is simply the first zero.\n    k0 = jn_zeros(0, 1)[0]\n\n    # Step 2: Define the test suite of wavenumbers.\n    test_k_values = [\n        1.0,           # k = 1.0 (far from resonance)\n        k0 - 0.2,      # k moderately below resonance\n        k0 - 0.05,     # k near below resonance\n        k0 - 0.005,    # k very close below resonance\n        k0 + 0.05,     # k near above resonance\n        3.0,           # k above the first resonance, below the next\n    ]\n\n    results = []\n    \n    # Step 3: Loop through each test wavenumber and compute the condition number.\n    for k in test_k_values:\n        # Define the range of Fourier modes m = -M, ..., M.\n        modes = np.arange(-M, M + 1)\n        \n        # Argument for the Bessel and Hankel functions.\n        x = k * a\n        \n        # Calculate the symbols s_m(k) for all modes.\n        # The formula is s_m(k) = a * (i*pi/2) * H_m^(1)(k*a) * J_m(k*a)\n        # SciPy's jv and hankel1 functions are vectorized, so we can compute\n        # for all modes at once.\n        Jm_values = jv(modes, x)\n        H1m_values = hankel1(modes, x)\n        \n        sm_values = a * (1j * np.pi / 2.0) * H1m_values * Jm_values\n        \n        # The singular values of the diagonal matrix are the absolute values\n        # of its diagonal entries.\n        singular_values = np.abs(sm_values)\n        \n        # The condition number is the ratio of the largest to smallest singular value.\n        max_sv = np.max(singular_values)\n        min_sv = np.min(singular_values)\n        \n        # A check for singularity. For the chosen k, min_sv should not be zero.\n        if min_sv == 0:\n            condition_number = np.inf\n        else:\n            condition_number = max_sv / min_sv\n            \n        results.append(condition_number)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3319757"}, {"introduction": "对于无法获得解析解的一般几何形状, 我们需要更普适的分析方法。本练习将介绍一种高级且实用的验证技术, 即结合边界元法 (BEM) 和有限元法 (FEM) 来识别真实的物理谐振。通过将 BEM 计算出的 EFIE 算子奇异值与 FEM 计算出的内部腔体本征模进行对比, 您可以有效地区分算子的近奇异性是由真实的内部谐振引起, 还是仅仅是离散化带来的伪影 [@problem_id:3319762]。", "problem": "考虑均匀介质中理想电导体（PEC）闭合边界上的电场积分方程（EFIE）算子。从时谐 Maxwell 方程组出发，在适当的极化条件下，场的切向分量满足一个标量 Helmholtz 方程。在二维空间中，使用单层势的边界积分表示可得到 EFIE 算子\n$$\nT(k)\\phi(x) \\equiv \\int_{\\Gamma} G_k\\!\\left(\\lVert x - y \\rVert\\right)\\,\\phi(y)\\,\\mathrm{d}s(y),\n$$\n其中 $k$ 是波数，$\\Gamma$ 是光滑闭合边界，而 $G_k(r)$ 是二维 Helmholtz 基本解\n$$\nG_k(r) = \\frac{i}{4} H_0^{(1)}(k r),\n$$\n其中 $H_0^{(1)}$ 是零阶第一类 Hankel 函数。已知该算子存在内部谐振问题：当波数 $k$ 与闭合域内 Dirichlet 问题的内部腔体特征波数重合时，边界算子会失去唯一性，因为此时存在非平凡的密度函数 $\\phi$ 会产生零边界迹。\n\n您的任务是推导、离散化并实现一个计算过程，该过程能够：\n1. 针对闭合边界 $\\Gamma$ 上的 EFIE 算子 $T(k)$，通过考虑其正规算子 $T(k)^\\ast T(k)$，构建一个离散特征问题，并计算其最小特征对（等效于計算 $T(k)$ 的最小奇异值及相应的奇异向量）。\n2. 为单位圆盘内的标量 Helmholtz 方程的内部 Dirichlet 腔体问题构建一个有限元方法（FEM）模型，\n$$\n-\\nabla^2 u = \\lambda u \\quad \\text{in } \\Omega,\\qquad u=0 \\quad \\text{on } \\partial\\Omega,\n$$\n并计算其最小的几个特征对，从而得到内部腔体特征波数 $k_{\\text{int}} = \\sqrt{\\lambda}$ 和相应的特征函数 $u(x)$。\n3. 通过在相同的波数 $k$ 下，将 $\\Gamma$ 上的 EFIE 奇异向量与从 FEM 得到的内部腔体边界法向导数模式 $\\partial u / \\partial n$进行比较，来识别哪些 EFIE 离散特征对是物理的（与内部腔体模式相关），哪些是伪的（由离散化引起或与内部谐振无关）。\n\n使用的基本原理：\n- 时谐 Maxwell 方程组在适当的极化条件下可简化为标量 Helmholtz 方程。\n- 光滑边界上 Helmholtz 方程通过单层势的边界积分表示。\n- Dirichlet 内部特征问题的变分形式及其使用线性三角形单元的有限元离散化。\n- 当 $k$ 等于内部 Dirichlet 特征波数时，会发生内部谐振；此时 EFIE 算子的近零空间由与内部特征函数相关的边界数据（特别是其边界法向导数）张成。\n\n离散化要求：\n- 令 $\\Omega$ 为半径 $R=1$ 米的单位圆盘，其边界 $\\Gamma = \\partial\\Omega$ 为单位圆。使用 $N_r$ 个同心环和 $N_\\theta$ 个角向划分，通过极坐标三角形网格对 $\\Omega$ 进行离散化；使用线性三角形单元。在边界节点（$r=R$）上施加 Dirichlet 条件 $u=0$，组装刚度矩阵 $K$ 和质量矩阵 $M$，并求解广义特征问题 $K \\mathbf{u} = \\lambda M \\mathbf{u}$ 以获得最小的内部特征值 $\\lambda$ 和特征函数 $\\mathbf{u}$。\n- 使用沿圆周均匀分布的 $N_b$ 个边界配置点对 $\\Gamma$ 上的 EFIE 算子 $T(k)$ 进行离散化，并用周期梯形法则近似该积分。使用核函数 $G_k(r)=\\frac{i}{4}H_0^{(1)}(kr)$ 和局部弧长权重构建一个稠密矩阵 $T(k) \\in \\mathbb{C}^{N_b \\times N_b}$。通过将 $r=0$替换为一个与边界离散化分辨率一致的局部小弦长来处理对角线上的奇异性。\n- 计算 $T(k)$ 的奇异值分解，并提取其最小奇异值 $\\sigma_{\\min}(k)$ 和相应的右奇异向量 $\\mathbf{v}_{\\min}(k)$。\n\n识别准则：\n- 对于测试集中的每个 $k$，计算 FEM 内部特征对及其在相同边界节点上采样的边界法向导数 $\\partial u / \\partial n$。如果存在至少一个 FEM 内部特征波数 $k_{\\text{int}}$ 满足 $\\lvert k - k_{\\text{int}} \\rvert \\leq \\Delta k$，并且归一化相关性\n$$\n\\rho = \\frac{\\left\\lvert \\mathbf{v}_{\\min}(k)^\\ast \\cdot \\mathbf{d} \\right\\rvert}{\\lVert \\mathbf{v}_{\\min}(k) \\rVert_2 \\,\\lVert \\mathbf{d} \\rVert_2}\n$$\n超过阈值 $\\rho_{\\text{thr}}$，其中 $\\mathbf{d}$ 是边界法向导数向量，则将该 EFIE 最小奇异向量特征对分类为物理的；否则分类为伪的。\n\n物理和数值单位：\n- 波数 $k$ 的单位必须是逆米（1/m）。几何长度的单位是米。输出的布尔值是无量纲的。\n\n测试集和参数：\n- 使用 $R=1$ 米， $N_r=10$， $N_\\theta=40$ 以及 $N_b=N_\\theta$ 个边界节点。\n- 为上述网格计算 FEM 内部特征对，并用它们进行比较。\n- 在三个波数（单位为逆米）下测试 EFIE 算子：$k_1 = 2.405$，$k_2 = 3.832$ 和 $k_3 = 1.000$。\n- 使用匹配容差 $\\Delta k = 0.200$ 和相关性阈值 $\\rho_{\\text{thr}} = 0.600$。\n\n答案规格和最终输出格式：\n- 对于每个测试波数，根据上述准则返回一个布尔值，指示 EFIE 最小奇异向量特征对是物理的（true）还是伪的（false）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[true,false,true]\"）。使用 Python 布尔字面量，最终产生的行应类似于 \"[True,False,True]\"。\n\n您的实现必须是一个完整、可运行的 Python 程序，该程序构建 FEM 模型和 EFIE 离散化，执行比较，并为给定的测试波数生成包含三个布爾值的最终列表。", "solution": "用户提供了一个在计算电磁学领域科学有效且适定的问题。任务是通过比较 EFIE 的边界元方法（BEM）离散化结果与相应内部 Helmholtz 特征值问题的有限元方法（FEM）解，来识别电场积分方程（EFIE）的内部谐振。\n\n解决方案分为三个主要阶段：\n1.  **FEM 特征值分析**：我们使用有限元方法对散射体内部——一个单位圆盘 $\\Omega$——进行建模，以找到其谐振模式。这些模式是带有齐次 Dirichlet 边界条件的标量 Helmholtz 特征值问题的解。\n2.  **EFIE 的 BEM 分析**：我们使用配置（Nyström）方法在边界 $\\Gamma = \\partial\\Omega$ 上离散化 EFIE 算子。通过分析在不同波数 $k$ 下所得矩阵算子 $T(k)$ 的奇异值谱，我们可以检测到近零性（near-nullities），这是谐振的标志。\n3.  **物理谐振的识别**：当波数 $k$ 与内部特征波数 $k_{\\text{int}}$ 匹配时，会发生物理谐振。在这样的 $k$ 值下，EFIE 算子 $T(k)$ 的近零空间由相应内部特征函数在边界上的法向导数张成。我们将这种物理联系实现为一个具体的识别准则：对于给定的 $k$，我们检查它是否接近于某个计算出的 $k_{\\text{int}}$，以及 EFIE 算子的最小奇异向量是否与相应 FEM 特征函数的法向导数高度相关。\n\n### 1. 内部 Dirichlet 问题的 FEM\n\n内部腔体谐振由势 $u$ 的标量 Helmholtz 方程决定：\n$$\n-\\nabla^2 u = \\lambda u \\quad \\text{in } \\Omega, \\qquad u=0 \\quad \\text{on } \\Gamma = \\partial\\Omega\n$$\n特征值 $\\lambda$ 通过 $k_{\\text{int}} = \\sqrt{\\lambda}$ 与谐振波数相关。我们使用有限元方法解决此问题。\n\n**变分形式**：问题的弱形式是找到 $(\\lambda, u) \\in \\mathbb{R} \\times H_0^1(\\Omega)$，使得对于所有测试函数 $v \\in H_0^1(\\Omega)$：\n$$\n\\int_\\Omega \\nabla u \\cdot \\nabla v \\, \\mathrm{d}A = \\lambda \\int_\\Omega u v \\, \\mathrm{d}A\n$$\n**离散化**：我们使用 $N_r$ 个径向划分和 $N_\\theta$ 个角向划分的极坐标网格对单位圆盘 $\\Omega$进行离散化，形成线性三角形单元。解 $u$ 被近似为分段线性基函数 $\\phi_i$ 的和，$u_h = \\sum_j u_j \\phi_j$，其中 $u_j$ 是节点值。将此代入弱形式，得到矩阵广义特征值问题：\n$$\nK \\mathbf{u} = \\lambda M \\mathbf{u}\n$$\n其中 $K$ 是刚度矩阵，$M$ 是质量矩阵，其元素为：\n$$\nK_{ij} = \\int_\\Omega \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, \\mathrm{d}A \\qquad M_{ij} = \\int_\\Omega \\phi_i \\phi_j \\, \\mathrm{d}A\n$$\n我们通过对网格中每个三角形的单元贡献求和来组装这些矩阵。通过将问题限制在仅与内部节点相关的基函数上，来施加 $\\Gamma$ 上的 Dirichlet 条件 $u=0$。我们求解所得系统，以获得最小的特征值 $\\lambda_m$ 和特征向量 $\\mathbf{u}_m$。\n\n**法向导数计算**：对于每个特征函数 $u_m$，我们必须计算其在边界 $\\Gamma$ 上的法向导数 $\\partial u_m / \\partial n$。对于单位圆盘，外法向向量 $\\mathbf{n}$ 沿径向 $\\mathbf{\\hat{r}}$。我们可以使用沿径向线的相邻内部节点，通过一阶有限差分来近似边界节点处的导数：\n$$\n\\frac{\\partial u}{\\partial n}\\bigg|_{\\mathbf{x}_j} = \\frac{\\partial u}{\\partial r}\\bigg|_{\\mathbf{x}_j} \\approx \\frac{u(\\mathbf{x}_j) - u(\\mathbf{x}_j - \\Delta r\\,\\mathbf{\\hat{r}})}{-\\Delta r}\n$$\n由于在边界上 $u(\\mathbf{x}_j) = 0$，这简化为：\n$$\n\\frac{\\partial u}{\\partial n}\\bigg|_{\\mathbf{x}_j} \\approx \\frac{u(\\mathbf{x}_j - \\Delta r\\,\\mathbf{\\hat{r}})}{\\Delta r}\n$$\n其中 $\\mathbf{x}_j$ 是一个边界节点，$\\Delta r = R/N_r$ 是径向步长，$u(\\mathbf{x}_j - \\Delta r\\,\\mathbf{\\hat{r}})$ 是在相邻内部节点处 FEM 特征函数的值。这样就为每个模式 $m$ 提供了法向导数采样向量 $\\mathbf{d}_m$。\n\n### 2. EFIE 算子的 BEM\n\nEFIE 算子由下式给出：\n$$\nT(k)\\phi(x) = \\int_{\\Gamma} G_k(\\lVert x - y \\rVert)\\,\\phi(y)\\,\\mathrm{d}s(y) \\quad \\text{with} \\quad G_k(r) = \\frac{i}{4} H_0^{(1)}(k r)\n$$\n我们使用配置法，在圆形边界 $\\Gamma$ 上的 $N_b$ 个均匀间隔的节点 $\\{x_j\\}$ 上对其进行离散化。积分使用周期梯形法则进行近似。这将积分算子转换为一个稠密的复数矩阵 $T(k) \\in \\mathbb{C}^{N_b \\times N_b}$：\n$$\nT_{ij}(k) = w_j G_k(\\lVert x_i - x_j \\rVert) = \\frac{2\\pi R}{N_b} \\frac{i}{4} H_0^{(1)}(k \\lVert x_i - x_j \\rVert)\n$$\n其中 $w_j = 2\\pi R/N_b$ 是边界段的弧长。\n\n**奇异性处理**：对于对角元素 $T_{ii}$，核函数的参数为 $r=0$。Hankel 函数 $H_0^{(1)}(z)$ 在 $z \\to 0$ 时具有对数奇异性。一种简单且常见的正则化方法，正如问题所建议的，是用一个与离散化尺寸同量级的小有效半径 $r_{\\text{eff}}$ 来代替距离 $r=0$。我们选择 $r_{\\text{eff}} = w_i/2 = \\pi R/N_b$。\n\n矩阵 $T(k)$ 的最小奇异值 $\\sigma_{\\min}(k)$ 及其相应的右奇异向量 $\\mathbf{v}_{\\min}(k)$ 通过奇异值分解（SVD）计算。一个接近零的 $\\sigma_{\\min}(k)$ 表示存在谐振。\n\n### 3. 识别准则\n\n对于每个测试波数 $k$，我们执行以下步骤：\n1.  计算离散化 EFIE 算子 $T(k)$ 的最小奇异值 $\\sigma_{\\min}(k)$ 和向量 $\\mathbf{v}_{\\min}(k)$。\n2.  遍历预先计算的内部特征波数 $k_{\\text{int}, m}$。\n3.  如果找到匹配项，即 $|k - k_{\\text{int},m}| \\leq \\Delta k$，我们计算 EFIE 奇异向量与相应 FEM 特征函数的法向导数之间的归一化相关性 $\\rho$：\n    $$\n    \\rho = \\frac{\\left\\lvert \\mathbf{v}_{\\min}(k)^\\ast \\cdot \\mathbf{d}_m \\right\\rvert}{\\lVert \\mathbf{v}_{\\min}(k) \\rVert_2 \\,\\lVert \\mathbf{d}_m \\rVert_2}\n    $$\n4.  如果 $\\rho$ 超过阈值 $\\rho_{\\text{thr}}$，该特征对被分类为“物理的”。如果对于给定的 $k$ 没有找到这样的内部模式，该特征对被分类为“伪的”。此过程应用于所有测试波数。", "answer": "```python\nimport numpy as np\nfrom scipy.special import hankel1\nfrom scipy.linalg import eigh, svd\n\ndef solve():\n    \"\"\"\n    Solves the problem of identifying physical vs. spurious resonances of the\n    EFIE operator on a unit disk.\n    \"\"\"\n    # --------------------------------------------------------------------------\n    # 0. Parameters\n    # --------------------------------------------------------------------------\n    R = 1.0         # Disk radius\n    Nr = 10         # Number of radial divisions for FEM mesh\n    Ntheta = 40     # Number of angular divisions for FEM mesh\n    Nb = Ntheta     # Number of boundary nodes for BIE discretization\n    test_ks = [2.405, 3.832, 1.000] # Wavenumbers to test\n    delta_k = 0.200 # Tolerance for matching wavenumbers\n    rho_thr = 0.600 # Threshold for correlation\n\n    # --------------------------------------------------------------------------\n    # 1. FEM for Interior Dirichlet Eigenproblem\n    # --------------------------------------------------------------------------\n\n    # 1.1. Generate Mesh (Nodes and Triangles)\n    num_nodes = 1 + Nr * Ntheta\n    nodes = np.zeros((num_nodes, 2))\n    \n    # Node indexing: idx(0,j)=0, idx(i>0,j) = 1 + (i-1)*Ntheta + j\n    idx = lambda i, j: 0 if i == 0 else 1 + (i - 1) * Ntheta + (j % Ntheta)\n    \n    # Create node coordinates\n    nodes[0, :] = [0.0, 0.0]\n    for i in range(1, Nr + 1):\n        radius = i * R / Nr\n        for j in range(Ntheta):\n            angle = j * 2 * np.pi / Ntheta\n            node_idx = idx(i, j)\n            nodes[node_idx, 0] = radius * np.cos(angle)\n            nodes[node_idx, 1] = radius * np.sin(angle)\n\n    # Create triangles\n    triangles = []\n    # Triangles connected to center node\n    for j in range(Ntheta):\n        triangles.append([idx(0, j), idx(1, j), idx(1, j + 1)])\n    # Triangles in annular regions\n    for i in range(2, Nr + 1):\n        for j in range(Ntheta):\n            # Quad vertices: v1, v2, v3, v4\n            v1, v2 = idx(i - 1, j), idx(i - 1, j + 1)\n            v3, v4 = idx(i, j), idx(i, j + 1)\n            # Triangles from quad\n            triangles.append([v1, v3, v2])\n            triangles.append([v2, v3, v4])\n    triangles = np.array(triangles)\n\n    # 1.2. Assemble Stiffness (K) and Mass (M) Matrices\n    K = np.zeros((num_nodes, num_nodes))\n    M = np.zeros((num_nodes, num_nodes))\n\n    for tri_nodes in triangles:\n        p1, p2, p3 = nodes[tri_nodes[0]], nodes[tri_nodes[1]], nodes[tri_nodes[2]]\n        \n        # Element matrix for linear triangle\n        C = np.array([[p1[0] - p3[0], p1[1] - p3[1]],\n                      [p2[0] - p3[0], p2[1] - p3[1]]])\n        area = 0.5 * np.abs(np.linalg.det(C))\n        \n        # Gradients of basis functions\n        inv_C_T = np.linalg.inv(C).T\n        grads = np.array([[-inv_C_T[0,0] - inv_C_T[0,1], -inv_C_T[1,0] - inv_C_T[1,1]],\n                          [inv_C_T[0,0], inv_C_T[1,0]],\n                          [inv_C_T[0,1], inv_C_T[1,1]]])\n        \n        # Add to global K\n        for i in range(3):\n            for j in range(3):\n                K[tri_nodes[i], tri_nodes[j]] += area * np.dot(grads[i], grads[j])\n        \n        # Add to global M\n        M_element = (area / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n        for i in range(3):\n            for j in range(3):\n                M[tri_nodes[i], tri_nodes[j]] += M_element[i, j]\n\n    # 1.3. Apply Boundary Conditions and Solve Eigenproblem\n    boundary_indices = np.array([idx(Nr, j) for j in range(Ntheta)])\n    is_interior = np.ones(num_nodes, dtype=bool)\n    is_interior[boundary_indices] = False\n    interior_indices = np.where(is_interior)[0]\n\n    K_int = K[np.ix_(interior_indices, interior_indices)]\n    M_int = M[np.ix_(interior_indices, interior_indices)]\n\n    # We need a few of the smallest eigenvalues\n    num_eigs_to_check = 15\n    lambdas, evecs_int = eigh(K_int, M_int, subset_by_index=[0, num_eigs_to_check - 1])\n    fem_k_ints = np.sqrt(lambdas)\n\n    # 1.4. Compute Normal Derivatives for each Eigenmode\n    fem_ders = []\n    dr = R / Nr\n    for i in range(num_eigs_to_check):\n        u_full = np.zeros(num_nodes)\n        u_full[interior_indices] = evecs_int[:, i]\n        \n        d = np.zeros(Nb)\n        for j in range(Ntheta):\n            # Interior node radially inward from boundary node j\n            interior_neighbor_idx = idx(Nr - 1, j)\n            d[j] = u_full[interior_neighbor_idx] / dr\n        fem_ders.append(d)\n\n    # --------------------------------------------------------------------------\n    # 2. BIE Discretization and Identification\n    # --------------------------------------------------------------------------\n    bie_nodes = nodes[boundary_indices]\n    results = []\n\n    for k in test_ks:\n        # 2.1 Assemble BIE Matrix T(k)\n        T = np.zeros((Nb, Nb), dtype=complex)\n        arc_length = 2 * np.pi * R / Nb\n        r_eff = np.pi * R / Nb  # Effective radius for diagonal singularity\n\n        for i in range(Nb):\n            for j in range(Nb):\n                if i == j:\n                    r = r_eff\n                else:\n                    r = np.linalg.norm(bie_nodes[i] - bie_nodes[j])\n                # Kernel: G_k(r) = (i/4) * H_0^(1)(k*r)\n                T[i, j] = (1j / 4.0) * hankel1(0, k * r)\n        \n        T *= arc_length\n\n        # 2.2 SVD to find smallest singular vector\n        _U, _s, Vh = svd(T)\n        vmin = Vh[-1].conj()  # v_min is the last row of Vh, conjugated\n\n        # 2.3 Identification criterion\n        is_physical = False\n        for i, k_int in enumerate(fem_k_ints):\n            if np.abs(k - k_int) = delta_k:\n                d = fem_ders[i]\n                \n                d_norm = np.linalg.norm(d)\n                vmin_norm = np.linalg.norm(vmin)\n\n                # Avoid division by zero for null derivatives (e.g. from numerical noise)\n                if d_norm > 1e-9 and vmin_norm > 1e-9:\n                    rho = np.abs(np.vdot(vmin, d)) / (vmin_norm * d_norm)\n                    if rho > rho_thr:\n                        is_physical = True\n                        break # Found a physical match\n        \n        if is_physical:\n             # This inner loop break only exits the search over FEM modes.\n             # Now check if a physical mode was found and append result.\n             pass\n\n        results.append(is_physical)\n\n    # --------------------------------------------------------------------------\n    # 3. Final Output\n    # --------------------------------------------------------------------------\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3319762"}]}