{"hands_on_practices": [{"introduction": "掌握数值方法的第一步是为一个简单、可控的问题构建并验证一个求解器。本练习侧重于一个一维积分方程，它使您能够专注于点匹配方法的核心机制，而无需处理多维几何的额外复杂性 [@problem_id:3341400]。通过使用“人造解法”(Method of Manufactured Solutions, MMS)，您将验证您实现的准确性和收敛阶，这是计算代码开发中的一项基本技能。", "problem": "考虑在区间 $[0,1]$ 上的一维第二类 Fredholm 积分方程，其形式如下\n$$\nu(x) - \\lambda \\int_{0}^{1} e^{-|x - x'|}\\,u(x')\\,dx' = f(x), \\quad x \\in [0,1].\n$$\n使用人工解方法，令精确解为解析函数 $u(x) = e^{x}$。你的第一个任务是通过将 $u(x)$ 代入该积分方程，并用 $x$ 和 $\\lambda$ 精确计算出积分，从而构造出相应的右端项 $f(x)$。你的第二个任务是在一个均匀网格上实现一个使用分段线性基函数的点匹配（配置）法来近似 $u(x)$，并通过均匀网格加密来经验性地量化观测到的收敛率。\n\n从以下基本基础开始：\n- 第二类 Fredholm 积分方程的定义，即 $u - \\lambda \\mathcal{K}u = f$，其中 $(\\mathcal{K}u)(x) = \\int_{0}^{1} K(x,x') u(x')\\,dx'$。\n- 点匹配（配置）过程：用一个在基 $\\{\\phi_j(x)\\}$ 中表示的有限维函数 $u_h(x)$ 来近似 $u(x)$，并在选定的点上强制满足该方程，以形成一个方阵线性系统。\n\n使用以下设置：\n- 令核函数为 $K(x,x') = e^{-|x-x'|}$。\n- 使用 $[0,1]$ 的一个均匀划分，该划分有 $N$ 个子区间和节点 $x_j = j h$，其中 $h = 1/N$ 且 $j \\in \\{0,1,\\dots,N\\}$。\n- 使用与均匀节点相关联的连续分段线性帽函数 $\\{\\phi_j(x)\\}_{j=0}^{N}$。\n- 令配置点为所有 $i \\in \\{0,1,\\dots,N\\}$ 的网格节点 $x_i$。\n- 通过在每个单元上使用精确的数值积分来近似离散系统中出现的积分项；确保积分误差与离散化误差相比可以忽略不计，从而使观测到的收敛率反映的是该方法的精度，而不是数值积分的精度。\n\n离散化公式要求：\n- 将 $u_h(x)$ 表示为 $u_h(x) = \\sum_{j=0}^{N} a_j \\phi_j(x)$。\n- 在每个节点 $x_i$ 上强制满足该方程，以获得关于系数 $\\{a_j\\}$ 的线性系统：\n$$\n\\sum_{j=0}^{N} a_j \\phi_j(x_i) - \\lambda \\sum_{j=0}^{N} a_j \\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x')\\,dx' = f(x_i).\n$$\n- 注意 $\\phi_j(x_i) = \\delta_{ij}$，因此系统简化为\n$$\na_i - \\lambda \\sum_{j=0}^{N} a_j \\left(\\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x')\\,dx'\\right) = f(x_i), \\quad i \\in \\{0,\\dots,N\\}.\n$$\n- 组装并求解该系统以得到 $\\{a_j\\}$。\n\n误差与收敛率：\n- 将 $L^2$ 误差定义为\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_{0}^{1} \\left(u(x) - u_h(x)\\right)^2 dx \\right)^{1/2}.\n$$\n- 使用每个单元上足够高阶的数值积分来估算 $L^2$ 误差的积分，以避免积分误差的污染。\n- 对于每个加密级别 $N \\in \\{8,16,32,64\\}$，计算 $L^2$ 误差，记为 $e_N$。\n- 计算连续加密之间的观测收敛率如下\n$$\n\\rho_{N \\to 2N} = \\frac{\\log\\left(e_{N} / e_{2N}\\right)}{\\log(2)}.\n$$\n\n测试套件：\n- 使用参数 $\\lambda$ 的三个值：$\\lambda \\in \\{0.0, 0.5, 0.9\\}$。\n- 对于测试套件中的每个 $\\lambda$，计算 $N \\in \\{8,16,32,64\\}$ 的观测收敛率，生成列表 $[\\rho_{8 \\to 16}, \\rho_{16 \\to 32}, \\rho_{32 \\to 64}]$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个条目按 $\\lambda = 0.0$、$\\lambda = 0.5$、$\\lambda = 0.9$ 的顺序对应一个 $\\lambda$ 值。\n- 每个条目本身应该是一个包含三个浮点数 $[\\rho_{8 \\to 16}, \\rho_{16 \\to 32}, \\rho_{32 \\to 64}]$ 的列表，四舍五入到 $6$ 位小数。\n- 例如，输出格式必须类似于 $[[r_{1,1},r_{1,2},r_{1,3}],[r_{2,1},r_{2,2},r_{2,3}],[r_{3,1},r_{3,2},r_{3,3}]]$，不含空格。\n\n角度单位不适用。没有物理单位；所有量均为无量纲。", "solution": "用户提供的问题已经过分析和验证。\n- **科学依据**：该问题基于 Fredholm 积分方程理论和数值分析，特别是人工解方法和点匹配有限元法。这些都是标准且成熟的数学和计算课题。\n- **问题提法**：该问题是适定的。与核函数 $K(x,x') = e^{-|x-x'|}$ 对应的积分算子是 $L^2([0,1])$ 上的一个紧自伴算子。对于任何满足 $\\lambda^{-1}$ 不是 $\\mathcal{K}$ 的特征值的 $\\lambda$，方程 $u - \\lambda \\mathcal{K}u = f$ 的唯一解都保证存在。最大特征值（谱半径）$\\rho(\\mathcal{K})$ 约为 $0.787$。对于所有测试值 $\\lambda \\in \\{0.0, 0.5, 0.9\\}$，条件 $|\\lambda|\\rho(\\mathcal{K})  1$ 均满足，确保了方程是适定的。\n- **客观性与完整性**：问题陈述客观、精确，并提供了所有必要信息，包括方程、人工解、数值方法规范、误差度量和测试参数。\n\n该问题被认为是有效的，完整的解答如下。\n\n### 第 1 部分：构造右端项 $f(x)$\n\n人工解方法要求将选定的精确解 $u(x)$ 代入积分方程，以确定相应的右端项（或源项）$f(x)$。给定的积分方程为：\n$$\nu(x) - \\lambda \\int_{0}^{1} e^{-|x - x'|}\\,u(x')\\,dx' = f(x), \\quad x \\in [0,1]\n$$\n对于人工解 $u(x) = e^x$，我们首先计算积分项，记为 $I(x)$：\n$$\nI(x) = \\int_{0}^{1} e^{-|x - x'|} e^{x'} \\,dx'\n$$\n为计算此积分，我们必须在 $x' = x$ 处拆分积分域，以处理绝对值项 $|x - x'|$：\n$$\nI(x) = \\int_{0}^{x} e^{-(x - x')} e^{x'} \\,dx' + \\int_{x}^{1} e^{-(x' - x)} e^{x'} \\,dx'\n$$\n我们分别计算每个部分。对于第一个积分：\n$$\n\\int_{0}^{x} e^{-x} e^{x'} e^{x'} \\,dx' = e^{-x} \\int_{0}^{x} e^{2x'} \\,dx' = e^{-x} \\left[ \\frac{1}{2} e^{2x'} \\right]_{0}^{x} = e^{-x} \\left( \\frac{1}{2}e^{2x} - \\frac{1}{2} \\right) = \\frac{1}{2}e^x - \\frac{1}{2}e^{-x} = \\sinh(x)\n$$\n对于第二个积分：\n$$\n\\int_{x}^{1} e^{-x'} e^{x} e^{x'} \\,dx' = e^{x} \\int_{x}^{1} 1 \\,dx' = e^{x} [x']_{x}^{1} = e^x(1 - x)\n$$\n将两部分结合起来，得到 $I(x)$ 的完整表达式：\n$$\nI(x) = \\left( \\frac{1}{2}e^x - \\frac{1}{2}e^{-x} \\right) + (e^x - x e^x) = \\left(\\frac{3}{2} - x\\right)e^x - \\frac{1}{2}e^{-x}\n$$\n最后，我们将此结果代回原方程，求得 $f(x)$：\n$$\nf(x) = u(x) - \\lambda I(x) = e^x - \\lambda \\left[ \\left(\\frac{3}{2} - x\\right)e^x - \\frac{1}{2}e^{-x} \\right]\n$$\n$$\nf(x) = \\left(1 - \\lambda\\left(\\frac{3}{2} - x\\right)\\right)e^x + \\frac{\\lambda}{2}e^{-x} = \\left(1 - \\frac{3\\lambda}{2} + \\lambda x\\right)e^x + \\frac{\\lambda}{2}e^{-x}\n$$\n这是用于测试数值格式的右端项函数 $f(x)$ 的解析表达式。\n\n### 第 2 部分：使用点匹配法进行离散化\n\n我们使用基函数的线性组合来近似解 $u(x)$。将域 $[0,1]$ 划分为 $N$ 个宽度为 $h=1/N$ 的均匀子区间，节点位于 $x_j = j h$，$j \\in \\{0, 1, \\dots, N\\}$。基函数 $\\{\\phi_j(x)\\}_{j=0}^N$ 是连续的分段线性“帽”函数，其中 $\\phi_j(x)$ 在节点 $x_j$ 处的值为 1，在所有其他节点 $x_k$（$k \\ne j$）处的值为 0。\n近似解 $u_h(x)$ 写为：\n$$\nu_h(x) = \\sum_{j=0}^{N} a_j \\phi_j(x)\n$$\n其中 $\\{a_j\\}$ 是待定的未知系数。在此基下，系数 $a_j$ 代表近似解在节点 $x_j$ 处的值，即 $a_j = u_h(x_j)$。\n\n点匹配（或配置）法在一些离散点上强制满足积分方程。我们使用网格节点 $\\{x_i\\}_{i=0}^N$ 作为配置点。将 $u_h(x)$ 代入积分方程并在每个 $x_i$ 处求值，得到以下系统：\n$$\nu_h(x_i) - \\lambda \\int_{0}^{1} e^{-|x_i - x'|} u_h(x') \\,dx' = f(x_i), \\quad i \\in \\{0, \\dots, N\\}\n$$\n代入 $u_h(x)$ 的展开式得到：\n$$\n\\sum_{j=0}^{N} a_j \\phi_j(x_i) - \\lambda \\sum_{j=0}^{N} a_j \\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x') \\,dx' = f(x_i)\n$$\n由于性质 $\\phi_j(x_i) = \\delta_{ij}$（克罗内克 δ），第一项简化为 $a_i$。这导出了关于系数 $\\mathbf{a} = [a_0, \\dots, a_N]^T$ 的 $(N+1) \\times (N+1)$ 线性方程组：\n$$\na_i - \\lambda \\sum_{j=0}^{N} a_j M_{ij} = f(x_i), \\quad i \\in \\{0, \\dots, N\\}\n$$\n以矩阵形式表示，即 $(I - \\lambda M)\\mathbf{a} = \\mathbf{f}$，其中 $I$ 是单位矩阵，$\\mathbf{f}$ 是分量为 $f_i = f(x_i)$ 的向量，而 $M$ 是元素为下式的矩阵：\n$$\nM_{ij} = \\int_{0}^{1} e^{-|x_i - x'|} \\phi_j(x') \\,dx'\n$$\n基函数 $\\phi_j(x')$ 的支集限于区间 $[x_{j-1}, x_{j+1}]$（对于 $j=0$ 和 $j=N$ 有端点修正）。$M_{ij}$ 的积分涉及一个指数函数和一个分段线性函数的乘积。虽然存在解析解，但过程很繁琐。为确保所要求的高精度，我们对 $\\phi_j(x')$ 的每个线性段使用高阶高斯积分来计算这些积分，从而使得数值积分误差与方法的内在离散化误差相比可以忽略不计。\n\n### 第 3 部分：误差分析与收敛率\n\n在求解线性系统得到系数 $\\mathbf{a}$ 后，我们便得到了近似解 $u_h(x)$。近似误差在 $L^2$ 范数下进行量化：\n$$\n\\|u - u_h\\|_{L^2} = \\left( \\int_{0}^{1} (u(x) - u_h(x))^2 \\,dx \\right)^{1/2}\n$$\n该积分通过对每个单元 $[x_k, x_{k+1}]$ 的贡献求和来进行数值计算：\n$$\n\\|u - u_h\\|_{L^2}^2 = \\sum_{k=0}^{N-1} \\int_{x_k}^{x_{k+1}} \\left(e^x - \\left(a_k \\frac{x_{k+1}-x}{h} + a_{k+1} \\frac{x-x_k}{h}\\right)\\right)^2 \\,dx\n$$\n与矩阵组装类似，在每个单元上采用高阶高斯积分来精确计算误差积分。\n\n对于光滑解，该方法的理论收敛率为 $O(h^2)$，这意味着误差 $e_N = \\|u - u_h\\|_{L^2}$ 应与 $(1/N)^2$ 成正比。我们通过计算从 $N$ 到 $2N$ 个区间的两次连续网格加密之间的观测收敛率 $\\rho$ 来经验性地验证这一点：\n$$\n\\rho_{N \\to 2N} = \\frac{\\log(e_N / e_{2N})}{\\log(2)}\n$$\n$\\rho \\approx 2$ 的收敛率将证实该方法预期的二阶精度。当 $\\lambda=0$ 时，问题简化为对 $u(x)=e^x$ 的分段线性插值，其 $L^2$ 误差已知为 $O(h^2)$，这为该实现提供了一个强有力的基准测试。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Fredholm integral equation using point-matching and computes\n    convergence rates for different values of lambda.\n    \"\"\"\n    LAMBDAS = [0.0, 0.5, 0.9]\n    N_VALS = [8, 16, 32, 64]\n    QUAD_ORDER = 16  # High order for negligible quadrature error\n\n    all_lambda_rates = []\n\n    # Get Gauss-Legendre quadrature points and weights on [-1, 1]\n    quad_points, quad_weights = np.polynomial.legendre.leggauss(QUAD_ORDER)\n\n    for lambda_val in LAMBDAS:\n        errors = []\n        for N in N_VALS:\n            h = 1.0 / N\n            x_nodes = np.linspace(0.0, 1.0, N + 1)\n\n            # Define exact solution and manufactured right-hand side\n            u_exact = lambda x: np.exp(x)\n            f_rhs = lambda x: (1.0 - 1.5 * lambda_val + lambda_val * x) * np.exp(x) + (lambda_val / 2.0) * np.exp(-x)\n\n            # The coefficients a_j are the approximations to u(x_j)\n            if lambda_val == 0.0:\n                # For lambda=0, u(x) = f(x). The collocation system is a_i = f(x_i).\n                # The manufactured f(x) for lambda=0 is e^x.\n                # So a_i = exp(x_i). This is equivalent to interpolating the exact solution.\n                a_coeffs = u_exact(x_nodes)\n            else:\n                # Assemble the system matrix M\n                M = np.zeros((N + 1, N + 1))\n                for i in range(N + 1):\n                    xi = x_nodes[i]\n                    for j in range(N + 1):\n                        # M_ij = integral of exp(-|xi - x'|) * phi_j(x') dx' from 0 to 1.\n                        # phi_j(x') is non-zero only on [x_{j-1}, x_{j+1}].\n                        \n                        integral_val = 0.0\n                        \n                        # Left part of hat function, on [x_{j-1}, x_j] for j > 0\n                        if j > 0:\n                            x_start, x_end = x_nodes[j-1], x_nodes[j]\n                            xp = 0.5 * (x_end - x_start) * quad_points + 0.5 * (x_start + x_end)\n                            phi_j_vals = (xp - x_start) / h\n                            kernel_vals = np.exp(-np.abs(xi - xp))\n                            integral_val += 0.5 * (x_end - x_start) * np.sum(quad_weights * kernel_vals * phi_j_vals)\n                        \n                        # Right part of hat function, on [x_j, x_{j+1}] for j  N\n                        if j  N:\n                            x_start, x_end = x_nodes[j], x_nodes[j+1]\n                            xp = 0.5 * (x_end - x_start) * quad_points + 0.5 * (x_start + x_end)\n                            phi_j_vals = (x_end - xp) / h\n                            kernel_vals = np.exp(-np.abs(xi - xp))\n                            integral_val += 0.5 * (x_end - x_start) * np.sum(quad_weights * kernel_vals * phi_j_vals)\n                        \n                        M[i, j] = integral_val\n                \n                # Form and solve the linear system (I - lambda * M) a = f\n                A_matrix = np.eye(N + 1) - lambda_val * M\n                f_vector = f_rhs(x_nodes)\n                a_coeffs = np.linalg.solve(A_matrix, f_vector)\n            \n            # Compute the L2 error ||u - u_h||\n            l2_error_sq = 0.0\n            for k in range(N):\n                # Integrate over element [x_k, x_{k+1}]\n                x_start, x_end = x_nodes[k], x_nodes[k+1]\n                \n                # Map quadrature points to the current element\n                xp = 0.5 * (x_end - x_start) * quad_points + 0.5 * (x_start + x_end)\n                \n                # Evaluate numerical solution u_h(x) at quadrature points\n                # On [x_k, x_k+1], u_h is a linear combination of phi_k and phi_{k+1}\n                phi_k_vals = (x_end - xp) / h\n                phi_k1_vals = (xp - x_start) / h\n                u_h_vals = a_coeffs[k] * phi_k_vals + a_coeffs[k+1] * phi_k1_vals\n                \n                # Evaluate exact solution u(x) at quadrature points\n                u_exact_vals = u_exact(xp)\n                \n                # Add element's contribution to the squared L2 error integral\n                integrand_vals = (u_exact_vals - u_h_vals)**2\n                l2_error_sq += 0.5 * (x_end - x_start) * np.sum(quad_weights * integrand_vals)\n            \n            errors.append(np.sqrt(l2_error_sq))\n\n        # Compute observed convergence rates for the current lambda\n        rates = []\n        for i in range(len(N_VALS) - 1):\n            # rate = log2(error_N / error_2N)\n            rate = np.log(errors[i] / errors[i+1]) / np.log(2.0)\n            rates.append(rate)\n        \n        all_lambda_rates.append(rates)\n\n    # Format the final output string as specified: [[r1,r2,r3],[r4,r5,r6],[r7,r8,r9]]\n    formatted_rates_str = []\n    for rates_list in all_lambda_rates:\n        formatted_list = [f\"{rate:.6f}\" for rate in rates_list]\n        formatted_rates_str.append(f\"[{','.join(formatted_list)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_rates_str)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3341400"}, {"introduction": "在掌握了基本原理之后，我们现在将点匹配技术应用于计算电磁学中的一个经典问题：二维导电圆柱体的散射 [@problem_id:3341417]。与前面抽象的练习不同，这个问题存在已知的解析解，为验证提供了一个“黄金标准”。这个练习将挑战您将数值方法与物理可观测量（如远场散射模式）联系起来，并根据真实解来量化您仿真的准确性。", "problem": "考虑一个半径为 $a$ 的理想电导体圆柱在横磁 ($\\mathrm{TM}_z$) 极化下的二维时谐电磁散射，因此唯一非零的电场分量是 $E_z(x,y)$，其时间依赖性为 $e^{i \\omega t}$。根据频域中的 Maxwell 方程组和在柱坐标系中使用分离变量法，标量总场 $u(x,y) = E_z(x,y)$ 在 $\\mathbb{R}^2 \\setminus \\{r \\le a\\}$ 中满足齐次 Helmholtz 方程，\n$$\n\\nabla^2 u + k^2 u = 0,\n$$\n并在导体表面上满足 Dirichlet 边界条件，\n$$\nu(a,\\theta) = 0.\n$$\n设入射场为以下形式的平面波\n$$\nu^{\\mathrm{inc}}(r,\\theta) = e^{i k r \\cos(\\theta - \\theta_{\\mathrm{inc}})},\n$$\n其中 $k = \\omega \\sqrt{\\mu \\epsilon}$ 是自由空间波数，$r$ 是径向坐标，$\\theta$ 是角坐标，$\\theta_{\\mathrm{inc}}$ 是从 x 轴测量的入射角。散射场 $u^{\\mathrm{scat}}$ 满足 Sommerfeld 辐射条件。散射场的远场方向图通过大 $r$ 渐近式定义（角度以弧度为单位）：\n$$\nu^{\\mathrm{scat}}(r,\\phi) \\sim \\sqrt{\\frac{2}{\\pi k r}} e^{i \\left( k r - \\frac{\\pi}{4} \\right)} F(\\phi), \\quad r \\to \\infty,\n$$\n其中 $\\phi$ 是以弧度为单位的观测角，$F(\\phi)$ 是无量纲的远场振幅。\n\n任务 A（推导）。从所述的 Helmholtz 模型和边界条件出发，并使用出射柱谐波作为散射场的基，\n$$\nu^{\\mathrm{scat}}(r,\\theta) \\approx \\sum_{n=-N}^{N} c_n H_n^{(1)}(k r) e^{i n \\theta},\n$$\n推导在圆形边界 $r = a$ 上的点匹配（边界配置）离散化。选择 $M$ 个等间距边界角 $\\theta_m = 2\\pi m / M$（其中 $m=0,1,\\ldots,M-1$，$M \\ge 2N+1$ 为整数），并在这些角度上施加 Dirichlet 边界条件。明确写出确定截断系数向量 $\\{c_n\\}_{n=-N}^{N}$ 的离散线性系统，并解释为什么当 $M  2N+1$ 时，最小二乘解是合适的。\n\n任务 B（远场）。使用截断系数向量 $\\{c_n\\}_{n=-N}^{N}$，仅利用基的正交性和出射柱面波的大宗量渐近式，表达离散远场振幅 $F_N(\\phi)$。其单位相对于 $F(\\phi)$ 是无量纲的。所有角度均使用弧度，并将 $F_N(\\phi)$ 表示为 $\\phi$ 的复值函数。\n\n任务 C（解析参考）。不借助任何数值方法，使用分离变量法和圆上的边界条件，得到在 $\\mathrm{TM}_z$ 照明下理想电导体圆柱的精确模态系数公式，用 Bessel 函数和 Hankel 函数表示。根据这些精确系数，将参考远场振幅 $F_{\\mathrm{ref}}(\\phi)$ 定义为一个快速收敛的截断级数，并解释如何选择截断指数以控制截断误差。\n\n任务 D（误差量化）。对于均匀的观测角网格 $\\phi_j = 2\\pi j / Q$, $j = 0, 1, \\ldots, Q-1$，定义数值远场振幅和参考远场振幅之间的以下相对误差度量：\n- 相对离散 $L^2$ 误差，\n$$\n\\mathcal{E}_2 = \\frac{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }}{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }},\n$$\n- 相对离散 $L^\\infty$ 误差，\n$$\n\\mathcal{E}_\\infty = \\frac{\\max_{0 \\le j \\le Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|}{\\max_{0 \\le j \\le Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|}.\n$$\n\n编程要求和测试套件。实现一个完整的程序，该程序：\n- 使用 $a = 1\\,\\mathrm{m}$ 和 $\\theta_{\\mathrm{inc}} = 0$（弧度），因此 $ka$ 是无量纲的，且等于测试套件中列出的参数 $ka$。\n- 应用任务 A 中的点匹配离散化，其中 $M = s \\cdot (2N+1)$，$s$ 是由测试套件提供的过采样因子（整数）。\n- 在大小为 $Q=720$ 的均匀观测网格上计算任务 B 中的 $F_N(\\phi)$（角度以弧度为单位）。\n- 使用足够大的截断指数 $N_{\\mathrm{ref}}$ 构建任务 C 中的 $F_{\\mathrm{ref}}(\\phi)$，以确保截断误差相对于离散化误差可以忽略不计；你必须在解答中证明你的选择是合理的，并在代码中实现它。\n- 计算任务 D 中的 $\\mathcal{E}_2$ 和 $\\mathcal{E}_\\infty$。\n\n测试套件。针对以下三个参数集运行你的程序，每个参数集产生两个浮点数 $\\mathcal{E}_2$ 和 $\\mathcal{E}_\\infty$：\n- 情况 1：$k a = 3.0$, $N = 3$, $s = 1$。\n- 情况 2：$k a = 3.0$, $N = 10$, $s = 2$。\n- 情况 3：$k a = 10.0$, $N = 20$, $s = 2$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素都是一个针对一个测试用例的双元素列表 $[\\mathcal{E}_2, \\mathcal{E}_\\infty]$，顺序与测试套件中的顺序一致。角度必须以弧度为单位，所有量均为无量纲。例如，输出格式必须如下所示\n[[e2_case1,einf_case1],[e2_case2,einf_case2],[e2_case3,einf_case3]]。", "solution": "该问题在科学和数学上是合理的、适定的，并包含了获得唯一解所需的所有信息。我们继续进行推导和实现。该问题涉及确定在横磁 ($\\mathrm{TM}_z$) 照明下，来自理想电导体 (PEC) 圆柱的散射电磁场。\n\n任务 A：点匹配离散化\n\n总场 $u(r,\\theta)$ 是入射场 $u^{\\mathrm{inc}}(r,\\theta)$ 和散射场 $u^{\\mathrm{scat}}(r,\\theta)$ 的和，即 $u = u^{\\mathrm{inc}} + u^{\\mathrm{scat}}$。在半径为 $a$ 的 PEC 圆柱表面上的 Dirichlet 边界条件要求总切向电场为零。对于此 $\\mathrm{TM}_z$ 情况，这意味着 $u(a,\\theta) = E_z(a,\\theta) = 0$。这个条件意味着散射场必须在边界上抵消入射场：\n$$\nu^{\\mathrm{scat}}(a,\\theta) = -u^{\\mathrm{inc}}(a,\\theta)\n$$\n入射场是 $u^{\\mathrm{inc}}(r,\\theta) = e^{i k r \\cos(\\theta - \\theta_{\\mathrm{inc}})}$ 给出的平面波。对于指定的入射角 $\\theta_{\\mathrm{inc}}=0$ 的情况，这简化为 $u^{\\mathrm{inc}}(r,\\theta) = e^{i k r \\cos\\theta}$。\n\n散射场由一个截断的出射柱面波（柱谐波）级数近似，该级数内在地满足 Sommerfeld 辐射条件：\n$$\nu^{\\mathrm{scat}}(r,\\theta) \\approx u_N^{\\mathrm{scat}}(r,\\theta) = \\sum_{n=-N}^{N} c_n H_n^{(1)}(k r) e^{i n \\theta}\n$$\n此处，$c_n$ 是未知的复系数，$H_n^{(1)}$ 是 $n$ 阶第一类 Hankel 函数，级数被截断为 $2N+1$ 个模式。\n\n点匹配法，或称边界配置法，是在一组离散点上施加边界条件。我们在圆柱边界上选择 $M$ 个等间距的点，其角位置为 $\\theta_m = 2\\pi m / M$，其中 $m=0, 1, \\ldots, M-1$。在每一个点上，我们施加边界条件：\n$$\nu_N^{\\mathrm{scat}}(a,\\theta_m) = -u^{\\mathrm{inc}}(a,\\theta_m)\n$$\n代入场的表达式，我们得到一个关于 $2N+1$ 个未知系数 $\\{c_n\\}_{n=-N}^{N}$ 的 $M$ 个线性方程组：\n$$\n\\sum_{n=-N}^{N} c_n H_n^{(1)}(ka) e^{i n \\theta_m} = -e^{i k a \\cos \\theta_m}, \\quad m=0, 1, \\ldots, M-1\n$$\n该系统可以写成矩阵形式 $\\mathbf{A}\\mathbf{c} = \\mathbf{b}$，其中：\n-   $\\mathbf{c}$ 是 $(2N+1) \\times 1$ 的未知系数列向量，$[c_{-N}, c_{-N+1}, \\ldots, c_N]^T$。\n-   $\\mathbf{b}$ 是 $M \\times 1$ 的列向量，代表在配置点采样的入射场的负值，其各项为 $b_m = -e^{i k a \\cos \\theta_m}$。\n-   $\\mathbf{A}$ 是 $M \\times (2N+1)$ 的系统矩阵，其元素由基函数在配置点的值给出。第 $m$ 行和对应于索引 $n$ 的列的元素是 $A_{m,n} = H_n^{(1)}(ka) e^{i n \\theta_m}$。\n\n问题陈述 $M \\ge 2N+1$。\n-   如果 $M = 2N+1$，矩阵 $\\mathbf{A}$ 是方阵。对于圆形边界，该矩阵是可逆的，可以通过直接求逆找到 $\\mathbf{c}$ 的唯一解，$\\mathbf{c} = \\mathbf{A}^{-1}\\mathbf{b}$。\n-   如果 $M  2N+1$，该系统是超定的，意味着方程数量多于未知数数量。由于级数的截断（一种模型误差），可能不存在同时满足所有 $M$ 个方程的精确解。在这种情况下，最小二乘解是合适的。我们寻求最小化残差的欧几里得范数 $\\|\\mathbf{A}\\mathbf{c} - \\mathbf{b}\\|_2$ 的向量 $\\mathbf{c}$。该最小化问题的解由正规方程组给出：\n    $$\n    (\\mathbf{A}^H \\mathbf{A})\\mathbf{c} = \\mathbf{A}^H \\mathbf{b}\n    $$\n    其中 $\\mathbf{A}^H$ 是 $\\mathbf{A}$ 的共轭转置 (Hermitian)。如果 $\\mathbf{A}$ 具有满列秩，则矩阵 $\\mathbf{A}^H \\mathbf{A}$ 是可逆的，最小二乘解是唯一的：$\\mathbf{c} = (\\mathbf{A}^H \\mathbf{A})^{-1}\\mathbf{A}^H\\mathbf{b}$。在数值上，这通常使用更稳定的方法（如 QR 或 SVD 分解）来求解。\n\n任务 B：离散远场振幅\n\n远场方向图 $F(\\phi)$ 由大 $r$ 时散射场的渐近行为定义。第一类 Hankel 函数对于大宗量 $z$ 的渐近形式为：\n$$\nH_n^{(1)}(z) \\sim \\sqrt{\\frac{2}{\\pi z}} e^{i(z - n\\pi/2 - \\pi/4)} \\quad \\text{as } z \\to \\infty\n$$\n将此代入散射场 $u_N^{\\mathrm{scat}}$ 的截断级数，我们令 $z=kr$ 并将观测角 $\\phi$ 等同于坐标 $\\theta$：\n$$\nu_N^{\\mathrm{scat}}(r,\\phi) \\approx \\sum_{n=-N}^{N} c_n \\left( \\sqrt{\\frac{2}{\\pi k r}} e^{i(k r - n\\pi/2 - \\pi/4)} \\right) e^{i n \\phi}\n$$\n提出不依赖于求和指数 $n$ 的项：\n$$\nu_N^{\\mathrm{scat}}(r,\\phi) \\approx \\sqrt{\\frac{2}{\\pi k r}} e^{i(k r - \\pi/4)} \\sum_{n=-N}^{N} c_n e^{-i n\\pi/2} e^{i n \\phi}\n$$\n将此与定义 $u^{\\mathrm{scat}}(r,\\phi) \\sim \\sqrt{\\frac{2}{\\pi k r}} e^{i(k r - \\pi/4)} F(\\phi)$ 进行比较，我们将离散远场振幅 $F_N(\\phi)$ 确定为：\n$$\nF_N(\\phi) = \\sum_{n=-N}^{N} c_n e^{-i n\\pi/2} e^{i n \\phi} = \\sum_{n=-N}^{N} c_n (-i)^n e^{i n \\phi}\n$$\n该表达式提供了作为观测角 $\\phi$ 的复值函数的远场方向图，由离散系数 $c_n$ 计算得出。\n\n任务 C：解析参考解\n\n为获得解析解，我们不截断级数展开。使用 Jacobi-Anger 恒等式（其中 $\\theta_{\\mathrm{inc}}=0$），入射平面波被展开为柱谐波：\n$$\nu^{\\mathrm{inc}}(r,\\theta) = \\sum_{n=-\\infty}^{\\infty} i^n J_n(kr) e^{i n \\theta}\n$$\n其中 $J_n$ 是第一类 Bessel 函数。散射场被展开为出射波，因为它们必须满足 Sommerfeld 辐射条件：\n$$\nu^{\\mathrm{scat}}(r,\\theta) = \\sum_{n=-\\infty}^{\\infty} c_n^{\\mathrm{exact}} H_n^{(1)}(kr) e^{i n \\theta}\n$$\n总场 $u = u^{\\mathrm{inc}} + u^{\\mathrm{scat}}$ 必须对所有 $\\theta \\in [0, 2\\pi)$ 满足边界条件 $u(a,\\theta)=0$。\n$$\n\\sum_{n=-\\infty}^{\\infty} i^n J_n(ka) e^{i n \\theta} + \\sum_{n=-\\infty}^{\\infty} c_n^{\\mathrm{exact}} H_n^{(1)}(ka) e^{i n \\theta} = 0\n$$\n$$\n\\sum_{n=-\\infty}^{\\infty} \\left[ i^n J_n(ka) + c_n^{\\mathrm{exact}} H_n^{(1)}(ka) \\right] e^{i n \\theta} = 0\n$$\n由于复指数 $\\{e^{i n \\theta}\\}$ 在区间 $[0, 2\\pi)$ 上的正交性，为了使方程对所有 $\\theta$ 成立，和中的每一项都必须为零。\n$$\ni^n J_n(ka) + c_n^{\\mathrm{exact}} H_n^{(1)}(ka) = 0\n$$\n求解精确模态系数 $c_n^{\\mathrm{exact}}$ 得：\n$$\nc_n^{\\mathrm{exact}} = -i^n \\frac{J_n(ka)}{H_n^{(1)}(ka)}\n$$\n精确远场振幅 $F(\\phi)$ 是通过在远场求和公式中使用这些系数得到的：\n$$\nF(\\phi) = \\sum_{n=-\\infty}^{\\infty} c_n^{\\mathrm{exact}} (-i)^n e^{i n \\phi} = \\sum_{n=-\\infty}^{\\infty} \\left( -i^n \\frac{J_n(ka)}{H_n^{(1)}(ka)} \\right) (-i)^n e^{i n \\phi} = -\\sum_{n=-\\infty}^{\\infty} \\frac{J_n(ka)}{H_n^{(1)}(ka)} e^{i n \\phi}\n$$\n对于数值参考，这个无穷级数必须被截断。我们通过在索引 $N_{\\mathrm{ref}}$ 处截断来定义参考远场振幅 $F_{\\mathrm{ref}}(\\phi)$：\n$$\nF_{\\mathrm{ref}}(\\phi) = -\\sum_{n=-N_{\\mathrm{ref}}}^{N_{\\mathrm{ref}}} \\frac{J_n(ka)}{H_n^{(1)}(ka)} e^{i n \\phi}\n$$\n截断指数 $N_{\\mathrm{ref}}$ 必须选择得足够大，以使该参考级数的截断误差与被测试的点匹配解的离散化误差相比可以忽略不计。当 $|n|  ka$ 时，项 $|J_n(ka)/H_n^{(1)}(ka)|$ 的量值会极快地衰减。一个稳健的规则是选择 $N_{\\mathrm{ref}}$ 显著大于数值截断指数 $N$ 和电尺寸 $ka$。我们将使用 $N_{\\mathrm{ref}} = \\max(2N, \\lfloor ka \\rfloor + 20)$，这确保了在指定的测试用例中参考解具有高精度。\n\n任务 D：误差量化\n\n数值远场振幅 $F_N(\\phi)$ 和参考远场振幅 $F_{\\mathrm{ref}}(\\phi)$ 之间的相对误差使用两种离散范数量化。两者都在一个包含 $Q$ 个观测角的均匀网格上进行评估，$\\phi_j = 2\\pi j / Q$，其中 $j=0, 1, \\ldots, Q-1$。\n\n相对离散 $L^2$ 误差 $\\mathcal{E}_2$ 衡量的是均方根差：\n$$\n\\mathcal{E}_2 = \\frac{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }}{\\sqrt{\\frac{1}{Q} \\sum_{j=0}^{Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|^2 }}\n$$\n相对离散 $L^\\infty$ 误差 $\\mathcal{E}_\\infty$ 衡量的是最大相对差：\n$$\n\\mathcal{E}_\\infty = \\frac{\\max_{0 \\le j \\le Q-1} \\left| F_N(\\phi_j) - F_{\\mathrm{ref}}(\\phi_j) \\right|}{\\max_{0 \\le j \\le Q-1} \\left| F_{\\mathrm{ref}}(\\phi_j) \\right|}\n$$\n这些度量提供了数值点匹配解准确性的归一化度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import jv, hankel1\n\ndef solve():\n    \"\"\"\n    Solves for the scattering from a PEC circular cylinder using point matching and\n    computes the error against an analytic reference solution for given test cases.\n    \"\"\"\n    # Test suite parameters: (ka, N, s)\n    # ka: dimensionless electrical size\n    # N: truncation index for the scattered field series\n    # s: oversampling factor for point-matching\n    test_cases = [\n        (3.0, 3, 1),\n        (3.0, 10, 2),\n        (10.0, 20, 2),\n    ]\n\n    # Number of observation points for far-field evaluation\n    Q = 720\n    # Observation angles from 0 to 2*pi (exclusive)\n    phi_obs = np.linspace(0, 2 * np.pi, Q, endpoint=False)\n    \n    results = []\n    for ka, N, s in test_cases:\n        # Determine the number of collocation points\n        M = s * (2 * N + 1)\n        # Collocation angles on the cylinder boundary\n        thetas_col = np.linspace(0, 2 * np.pi, M, endpoint=False)\n        \n        # --- Task A: Point-Matching Discretization and Solution ---\n        # Mode indices for the truncated series from -N to N\n        n_modes = np.arange(-N, N + 1)\n        \n        # Build the system matrix A, where A_mn = H_n^(1)(ka) * exp(i*n*theta_m)\n        # We use broadcasting for an efficient construction.\n        # h1_vals has shape (2N+1,)\n        h1_vals = hankel1(n_modes, ka)\n        # exp_vals has shape (M, 2N+1)\n        exp_vals = np.exp(1j * np.outer(thetas_col, n_modes))\n        # Broadcast h1_vals to (1, 2N+1) and element-wise multiply with exp_vals\n        A = h1_vals[np.newaxis, :] * exp_vals\n        \n        # Build the right-hand side vector b, where b_m = -exp(i*ka*cos(theta_m))\n        b = -np.exp(1j * ka * np.cos(thetas_col))\n        \n        # Solve the linear system Ac = b for the coefficients c.\n        # np.linalg.lstsq is used as it handles both square (M=2N+1) and\n        # overdetermined (M > 2N+1) systems robustly.\n        c_numerical, _, _, _ = np.linalg.lstsq(A, b, rcond=None)\n        \n        # --- Task B: Compute Numerical Far-Field Amplitude F_N ---\n        # F_N(phi) = sum_{n=-N to N} c_n * (-i)^n * exp(i*n*phi)\n        far_field_phase = (-1j)**n_modes\n        exp_obs = np.exp(1j * np.outer(phi_obs, n_modes))\n        # The '@' operator performs matrix-vector multiplication\n        F_N = exp_obs @ (c_numerical * far_field_phase)\n\n        # --- Task C: Compute Analytic Reference Far-Field F_ref ---\n        # Choose a sufficiently large truncation index for the reference series\n        # to ensure its truncation error is negligible.\n        N_ref = int(max(2 * N, np.floor(ka) + 20))\n        n_ref_modes = np.arange(-N_ref, N_ref + 1)\n\n        # Compute coefficients for the reference far-field series: d_n = -J_n(ka)/H_n^(1)(ka)\n        d_n_ref = -jv(n_ref_modes, ka) / hankel1(n_ref_modes, ka)\n        \n        # F_ref(phi) = sum_{n=-N_ref to N_ref} d_n * exp(i*n*phi)\n        exp_ref = np.exp(1j * np.outer(phi_obs, n_ref_modes))\n        F_ref = exp_ref @ d_n_ref\n        \n        # --- Task D: Error Quantification ---\n        diff = F_N - F_ref\n        \n        # Relative L2 error\n        E2_num = np.sqrt(np.mean(np.abs(diff)**2))\n        E2_den = np.sqrt(np.mean(np.abs(F_ref)**2))\n        E2 = E2_num / E2_den\n        \n        # Relative L-infinity error\n        Einf_num = np.max(np.abs(diff))\n        Einf_den = np.max(np.abs(F_ref))\n        Einf = Einf_num / Einf_den\n        \n        results.append([E2, Einf])\n        \n    # The final print statement must match the specified format.\n    # The `str` of a list includes the brackets, so we join these strings.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3341417"}, {"introduction": "对于复杂的三维问题，解析解通常是不可用的。这个高级练习为此类情景引入了一种强大的验证策略，将“人造解法”应用于完整的三维电场积分方程 (EFIE) [@problem_id:3341444]。您将在球体上设计一个已知的表面电流，并计算出维持该电流所需的入射场，从而为核心积分算子的正确性创建一个自定义的验证测试。这种实践模拟了验证复杂计算电磁学代码的真实场景，并加深了您对矢量积分方程的理解。", "problem": "要求您在自由空间中的球体上设计一个制造的表面电流密度 $\\mathbf{J}$，并计算验证电场积分方程 (EFIE) 配点实现所需的相应入射场。您的制造解必须采用点匹配测试程序：构造入射场，使其在选定的一组匹配（配点）点上满足 EFIE 边界条件，而验证误差度量则在表面外侧的一个球体上的一组不同的非匹配点上进行评估。目标是推导出一个有原则且可测试的 EFIE 算子计算方法，并生成一个数值误差度量，以反映当积分算子使用粗糙求积进行离散化时点匹配程序的质量。\n\n从均匀自由空间中的时谐麦克斯韦方程组开始，采用 $\\mathrm{e}^{\\mathrm{i}\\omega t}$ 的时间约定。总电场 $\\mathbf{E}$ 在理想电导体 (PEC) 表面上满足电场积分方程，\n$$\n\\hat{\\mathbf{n}}(\\mathbf{r}_s) \\times \\left(\\mathbf{E}^{\\text{inc}}(\\mathbf{r}_s) + \\mathbf{E}^{\\text{scat}}(\\mathbf{r}_s)\\right) = \\mathbf{0},\n$$\n其中 $\\hat{\\mathbf{n}}$ 是表面点 $\\mathbf{r}_s$ 处的外向单位法向量，$\\mathbf{E}^{\\text{inc}}$ 是入射场，$\\mathbf{E}^{\\text{scat}}$ 是由感应表面电流密度 $\\mathbf{J}(\\mathbf{r}_s)$ 散射的场。对于一般的表面电流 $\\mathbf{J}$，其散射场由经典的 EFIE 算子给出，\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega \\mu_0 \\int_S G(\\mathbf{r},\\mathbf{r}') \\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S' + \\frac{1}{\\mathrm{i}\\omega \\varepsilon_0} \\nabla \\int_S G(\\mathbf{r},\\mathbf{r}') \\nabla'_s\\cdot\\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S',\n$$\n其中 $G(\\mathbf{r},\\mathbf{r}') = \\frac{\\mathrm{e}^{\\mathrm{i}k\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|}$ 是自由空间格林函数，$k=\\omega\\sqrt{\\mu_0\\varepsilon_0}$ 是自由空间波数，$\\nabla'_s\\cdot$ 是在 $\\mathbf{r}'$ 处的表面散度。如果制造的 $\\mathbf{J}$ 被选为表面无散的，那么标量势项将消失，只有矢量势项有贡献。\n\n您将使用环形矢量球谐函数 $\\mathbf{X}_{\\ell m}$，在半径为 $a$ 的球体上制造一个光滑、无散的切向表面电流密度：\n$$\n\\mathbf{J}(\\theta,\\phi) = J_0\\,\\mathbf{X}_{\\ell m}(\\theta,\\phi),\n$$\n其中 $(\\theta,\\phi)$ 是球面上的极角和方位角，$\\ell\\ge 1$ 且 $|m|\\le \\ell$，$J_0$ 的单位是 $\\mathrm{A}/\\mathrm{m}$，并且\n$$\n\\mathbf{X}_{\\ell m}(\\theta,\\phi) = \\frac{1}{\\sqrt{\\ell(\\ell+1)}}\\left(\\hat{\\boldsymbol{\\phi}}\\;\\frac{\\partial Y_{\\ell m}}{\\partial \\theta} - \\hat{\\boldsymbol{\\theta}}\\;\\frac{1}{\\sin\\theta}\\frac{\\partial Y_{\\ell m}}{\\partial \\phi}\\right),\n$$\n其中 $Y_{\\ell m}$ 是复球谐函数，$\\hat{\\boldsymbol{\\theta}}$、$\\hat{\\boldsymbol{\\phi}}$ 是标准正交切向基。此电流严格切向，并在球面上满足 $\\nabla_s\\cdot\\mathbf{J}=0$。\n\n为避免在表面上精确处理奇异积分，我们在半径为 $a+\\delta$ 的球面上计算场，其中 $\\delta0$ 且与波长 $\\lambda=2\\pi/k$ 相比很小。在该偏移球面上的任何观测点 $(\\theta_0,\\phi_0)$ 处，强制执行 PEC EFIE 边界条件的所需入射场构造如下\n$$\n\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\theta_0,\\phi_0) = -\\,\\mathbf{E}^{\\text{scat}}_{\\parallel}(\\theta_0,\\phi_0),\n$$\n其中符号 $\\parallel$ 表示到与径向单位矢量正交的局部切平面上的切向投影。右侧出现的散射场必须通过数值精确的求积（使用中点法则的精细球面积分乘积网格）来计算，以作为制造的参考入射场。为模拟使用粗糙离散化 EFIE 算子的配点代码，再次使用更粗糙的球面积分乘积网格和中点法则计算 $\\mathbf{E}^{\\text{scat}}_{\\parallel}$，并在非匹配点上定义逐点残差\n$$\n\\mathcal{R}(\\theta_0,\\phi_0) = \\left\\|\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\theta_0,\\phi_0) + \\mathbf{E}^{\\text{scat}}_{\\parallel,\\text{coarse}}(\\theta_0,\\phi_0)\\right\\|_2.\n$$\n报告在一组指定的非匹配点 $\\{(\\theta_i,\\phi_i)\\}_{i=1}^M$ 上的相对均方根 (RMS) 误差，\n$$\n\\epsilon_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\left(\\frac{\\mathcal{R}(\\theta_i,\\phi_i)}{\\left\\|\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\theta_i,\\phi_i)\\right\\|_2}\\right)^2 }.\n$$\n\n程序实现细节：\n- 使用自由空间常数 $\\mu_0 = 4\\pi\\times 10^{-7}\\,\\mathrm{H/m}$ 和 $\\varepsilon_0 \\approx 8.8541878176\\times 10^{-12}\\,\\mathrm{F/m}$，其中 $\\omega = 2\\pi f$ 且 $k = \\omega\\sqrt{\\mu_0\\varepsilon_0}$。\n- 电流密度 $\\mathbf{J}$ 以 $\\mathrm{A}/\\mathrm{m}$ 为单位，电场 $\\mathbf{E}$ 以 $\\mathrm{V}/\\mathrm{m}$ 为单位。角度 $\\theta$ 和 $\\phi$ 必须以弧度为单位。\n- 在具有 $(N_\\theta,N_\\phi)$ 个点的球面积分乘积网格上使用中点法则：中心点位于 $(\\theta_i,\\phi_j)$，其中 $\\theta_i = (i+\\tfrac{1}{2})\\Delta\\theta$，$\\phi_j = (j+\\tfrac{1}{2})\\Delta\\phi$，$\\Delta\\theta = \\pi/N_\\theta$，$\\Delta\\phi = 2\\pi/N_\\phi$，面积元为 $a^2 \\sin\\theta\\,\\Delta\\theta\\,\\Delta\\phi$。\n- 散射场贡献简化为矢量势项，\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega\\mu_0 \\int_S \\frac{\\mathrm{e}^{\\mathrm{i}k\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|} \\mathbf{J}(\\mathbf{r}')\\,\\mathrm{d}S',\n$$\n且切向分量通过减去径向投影得到：$\\mathbf{E}_{\\parallel} = \\mathbf{E} - (\\mathbf{E}\\cdot \\hat{\\mathbf{r}})\\hat{\\mathbf{r}}$。\n- 为保证数值稳定性，选择的非匹配测试点的 $\\theta$ 值应避开极点。\n\n测试套件：\n对于所有测试用例，使用相同的非匹配点集 $\\{(\\theta_i,\\phi_i)\\}_{i=1}^9$\n$$\n\\begin{aligned}\n(\\theta_1,\\phi_1) = (0.3\\pi,\\,0.1\\pi),\\quad (\\theta_2,\\phi_2) = (0.45\\pi,\\,0.35\\pi),\\quad (\\theta_3,\\phi_3) = (0.6\\pi,\\,1.2\\pi),\\\\\n(\\theta_4,\\phi_4) = (0.2\\pi,\\,2.0\\pi),\\quad (\\theta_5,\\phi_5) = (0.75\\pi,\\,2.4\\pi),\\quad (\\theta_6,\\phi_6) = (0.5\\pi,\\,3.1\\pi),\\\\\n(\\theta_7,\\phi_7) = (0.65\\pi,\\,1.7\\pi),\\quad (\\theta_8,\\phi_8) = (0.4\\pi,\\,2.8\\pi),\\quad (\\theta_9,\\phi_9) = (0.85\\pi,\\,0.9\\pi).\n\\end{aligned}\n$$\n将四个测试用例定义为参数元组 $(a, f, \\ell, m, J_0, \\alpha, N_\\theta^{\\text{coarse}}, N_\\phi^{\\text{coarse}}, N_\\theta^{\\text{fine}}, N_\\phi^{\\text{fine}})$，其中 $\\delta = \\alpha \\lambda$ 且 $\\lambda = 2\\pi/k$：\n- 用例 1 (理想路径)：$(a, f, \\ell, m, J_0, \\alpha, N_\\theta^{\\text{coarse}}, N_\\phi^{\\text{coarse}}, N_\\theta^{\\text{fine}}, N_\\phi^{\\text{fine}}) = (0.37\\,\\mathrm{m}, 500\\,\\mathrm{MHz}, 3, 1, 1.0\\,\\mathrm{A/m}, 0.05, 24, 48, 40, 80)$。\n- 用例 2 (粗糙求积边界情况)：$(0.37\\,\\mathrm{m}, 500\\,\\mathrm{MHz}, 3, 1, 1.0\\,\\mathrm{A/m}, 0.05, 8, 16, 40, 80)$。\n- 用例 3 (高频)：$(0.50\\,\\mathrm{m}, 1200\\,\\mathrm{MHz}, 4, 2, 1.0\\,\\mathrm{A/m}, 0.02, 20, 40, 40, 80)$。\n- 用例 4 (低频)：$(0.50\\,\\mathrm{m}, 50\\,\\mathrm{MHz}, 2, 1, 1.0\\,\\mathrm{A/m}, 0.05, 24, 48, 40, 80)$。\n\n您的程序必须：\n- 如上所述，从 $\\mathbf{X}_{\\ell m}$ 构造 $\\mathbf{J}$。\n- 使用精细网格计算 $\\mathbf{E}^{\\text{inc}}_{\\parallel}$，并将其设置为在半径 $a+\\delta$ 处计算的 $-\\mathbf{E}^{\\text{scat}}_{\\parallel}$。\n- 在相同的非匹配点上计算粗糙网格的散射切向场 $\\mathbf{E}^{\\text{scat}}_{\\parallel,\\text{coarse}}$。\n- 对每个测试用例，聚合九个非匹配点上的相对 RMS 误差 $\\epsilon_{\\text{RMS}}$。\n\n最终输出：\n您的程序应生成单行输出，其中包含按上述测试用例顺序排列的四个 $\\epsilon_{\\text{RMS}}$ 值，格式为方括号括起来的逗号分隔列表（例如，$[\\epsilon_1,\\epsilon_2,\\epsilon_3,\\epsilon_4]$）。不应打印任何其他文本。所有角度必须以弧度解释，所有长度以米为单位，电流密度以 $\\mathrm{A}/\\mathrm{m}$ 为单位，电场以 $\\mathrm{V}/\\mathrm{m}$ 为单位。打印的数值是无量纲的相对误差，必须是标准的浮点数。", "solution": "该问题要求设计并实现一个基于电场积分方程 (EFIE) 的计算电磁学代码的验证测试。这是通过使用制造解方法 (MMS) 来完成的，即为表面电流密度设定一个已知的非平凡解，并从中推导出维持该解所需的相应入射场。然后，通过将其输出与已知解进行比较，可以评估数值 EFIE 算子的准确性。\n\n让我们首先将问题的各个组成部分形式化。几何结构是自由空间中一个半径为 $a$ 的球体。时谐约定为 $\\mathrm{e}^{\\mathrm{i}\\omega t}$。\n\n基本方程是理想电导体 (PEC) 的 EFIE，它指出总电场的切向分量必须在表面 $S$ 上消失：\n$$\n\\hat{\\mathbf{n}}(\\mathbf{r}_s) \\times \\left(\\mathbf{E}^{\\text{inc}}(\\mathbf{r}_s) + \\mathbf{E}^{\\text{scat}}(\\mathbf{r}_s)\\right) = \\mathbf{0} \\quad \\text{for } \\mathbf{r}_s \\in S\n$$\n这等价于陈述散射场的切向分量必须是入射场切向分量的负值：$\\mathbf{E}^{\\text{scat}}_{\\parallel}(\\mathbf{r}_s) = -\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}_s)$。\n\n在观测点 $\\mathbf{r}$ 处的散射场 $\\mathbf{E}^{\\text{scat}}$ 是由表面电流密度 $\\mathbf{J}$ 通过积分算子生成的：\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega \\mu_0 \\int_S G(\\mathbf{r},\\mathbf{r}') \\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S' + \\frac{1}{\\mathrm{i}\\omega \\varepsilon_0} \\nabla \\int_S G(\\mathbf{r},\\mathbf{r}') \\nabla'_s\\cdot\\mathbf{J}(\\mathbf{r}') \\,\\mathrm{d}S'\n$$\n其中 $G(\\mathbf{r},\\mathbf{r}') = \\frac{\\mathrm{e}^{\\mathrm{i}k\\|\\mathbf{r}-\\mathbf{r}'\\|}}{4\\pi\\|\\mathbf{r}-\\mathbf{r}'\\|}$ 是标量自由空间格林函数，$k=\\omega\\sqrt{\\mu_0\\varepsilon_0}$ 是波数，$\\mu_0, \\varepsilon_0$ 分别是自由空间的磁导率和介电常数。\n\n电流密度的制造解被选为单个环形矢量球谐函数，这确保了它与球面相切且表面无散 ($\\nabla_s\\cdot\\mathbf{J}=0$)：\n$$\n\\mathbf{J}(\\theta',\\phi') = J_0\\,\\mathbf{X}_{\\ell m}(\\theta',\\phi')\n$$\n这里，$(\\theta', \\phi')$ 是源球面上的球坐标角度，$J_0$ 是一个常数振幅，并且\n$$\n\\mathbf{X}_{\\ell m}(\\theta',\\phi') = \\frac{1}{\\sqrt{\\ell(\\ell+1)}}\\left(\\hat{\\boldsymbol{\\phi}}'\\;\\frac{\\partial Y_{\\ell m}}{\\partial \\theta'} - \\hat{\\boldsymbol{\\theta}}'\\;\\frac{1}{\\sin\\theta'}\\frac{\\partial Y_{\\ell m}}{\\partial \\phi'}\\right)\n$$\n其中 $Y_{\\ell m}$ 是标准的复球谐函数。$\\nabla_s\\cdot\\mathbf{J}=0$ 的性质通过消除标量势项（第二个积分）简化了散射场表达式，仅留下矢量势项：\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) = \\mathrm{i}\\omega\\mu_0 \\int_S G(\\mathbf{r},\\mathbf{r}') \\mathbf{J}(\\mathbf{r}')\\,\\mathrm{d}S'\n$$\n\n为了进行数值计算，我们将此积分离散化。观测点 $\\mathbf{r}$ 位于半径为 $a+\\delta$ 的球面上（其中 $\\delta  0$），源点 $\\mathbf{r}'$ 位于半径为 $a$ 的球面上。这个偏移量 $\\delta$ 避免了当 $\\mathbf{r}=\\mathbf{r}'$ 时格林函数中的奇异性。我们在 $(\\theta', \\phi')$ 的规则网格上使用中点法则。积分变为求和：\n$$\n\\mathbf{E}^{\\text{scat}}(\\mathbf{r}) \\approx \\mathrm{i}\\omega\\mu_0 \\sum_{j=0}^{N_\\theta-1} \\sum_{k=0}^{N_\\phi-1} G(\\mathbf{r},\\mathbf{r}'_{jk}) \\mathbf{J}(\\mathbf{r}'_{jk}) a^2 \\sin(\\theta'_j) \\Delta\\theta \\Delta\\phi\n$$\n其中 $\\Delta\\theta = \\pi/N_\\theta$，$\\Delta\\phi = 2\\pi/N_\\phi$，网格中心为 $\\theta'_j = (j+0.5)\\Delta\\theta$，$\\phi'_k = (k+0.5)\\Delta\\phi$。\n\n电流密度矢量 $\\mathbf{J}$ 和场 $\\mathbf{E}^{\\text{scat}}$ 必须在共同的全局坐标系，即笛卡尔坐标系 $(\\hat{\\mathbf{x}},\\hat{\\mathbf{y}},\\hat{\\mathbf{z}})$ 中表示，以便执行矢量加法。每个源点 $(\\theta', \\phi')$ 处的球坐标基矢量 $(\\hat{\\mathbf{r}}', \\hat{\\boldsymbol{\\theta}}', \\hat{\\boldsymbol{\\phi}}')$ 被转换为笛卡尔坐标：\n\\begin{align*} \\hat{\\mathbf{r}}' = \\sin\\theta'\\cos\\phi'\\,\\hat{\\mathbf{x}} + \\sin\\theta'\\sin\\phi'\\,\\hat{\\mathbf{y}} + \\cos\\theta'\\,\\hat{\\mathbf{z}} \\\\ \\hat{\\boldsymbol{\\theta}}' = \\cos\\theta'\\cos\\phi'\\,\\hat{\\mathbf{x}} + \\cos\\theta'\\sin\\phi'\\,\\hat{\\mathbf{y}} - \\sin\\theta'\\,\\hat{\\mathbf{z}} \\\\ \\hat{\\boldsymbol{\\phi}}' = -\\sin\\phi'\\,\\hat{\\mathbf{x}} + \\cos\\phi'\\,\\hat{\\mathbf{y}} \\end{align*}\n计算 $\\mathbf{J}(\\theta', \\phi') = J_{\\theta'}\\hat{\\boldsymbol{\\theta}}' + J_{\\phi'}\\hat{\\boldsymbol{\\phi}}'$ 的分量。关于 $\\phi'$ 的导数很简单：$\\frac{\\partial Y_{\\ell m}}{\\partial \\phi'} = \\mathrm{i}m Y_{\\ell m}$。关于 $\\theta'$ 的导数可以使用涉及其他球谐函数的递推关系来稳定地计算：\n$$\n\\frac{\\partial Y_{\\ell m}}{\\partial \\theta'} = \\frac{1}{2} \\left[ \\sqrt{(\\ell-m)(\\ell+m+1)} e^{-\\mathrm{i}\\phi'} Y_{\\ell,m+1} - \\sqrt{(\\ell+m)(\\ell-m+1)} e^{\\mathrm{i}\\phi'} Y_{\\ell,m-1} \\right]\n$$\n这个关系对于 `scipy.special.sph_harm` 使用的 Condon-Shortley 相位约定是有效的。\n\n制造的入射场 $\\mathbf{E}^{\\text{inc}}_{\\parallel}$ 被定义为在观测点上完全抵消切向散射场的场。参考散射场使用精细求积网格 ($N_\\theta^{\\text{fine}}, N_\\phi^{\\text{fine}}$) 计算：\n$$\n\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}) = - \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r})\n$$\n切向投影通过减去径向分量来执行：$\\mathbf{E}_{\\parallel} = \\mathbf{E} - (\\mathbf{E}\\cdot\\hat{\\mathbf{r}})\\hat{\\mathbf{r}}$，其中 $\\hat{\\mathbf{r}} = \\mathbf{r}/\\|\\mathbf{r}\\|$。\n\n为了测试一个不太精确的算子，我们再次计算散射场，这次使用粗糙求积网格 ($N_\\theta^{\\text{coarse}}, N_\\phi^{\\text{coarse}}$)，以获得 $\\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}$。在观测点 $\\mathbf{r}_i$ 的逐点残差是与预期边界条件的偏差：\n$$\n\\mathcal{R}(\\mathbf{r}_i) = \\left\\| \\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}_i) + \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}(\\mathbf{r}_i) \\right\\|_2 = \\left\\| \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}(\\mathbf{r}_i) - \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r}_i) \\right\\|_2\n$$\n最终的误差度量是在 $M=9$ 个非匹配观测点上平均的相对均方根 (RMS) 误差：\n$$\n\\epsilon_{\\text{RMS}} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\left( \\frac{\\mathcal{R}(\\mathbf{r}_i)}{\\|\\mathbf{E}^{\\text{inc}}_{\\parallel}(\\mathbf{r}_i)\\|_2} \\right)^2} = \\sqrt{\\frac{1}{M}\\sum_{i=1}^M \\left( \\frac{\\|\\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{coarse}}(\\mathbf{r}_i) - \\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r}_i)\\|_2}{\\|\\mathbf{E}^{\\text{scat}}_{\\parallel, \\text{fine}}(\\mathbf{r}_i)\\|_2} \\right)^2}\n$$\n该度量量化了由 EFIE 算子的粗糙离散化引入的误差，该误差相对于真实解场的幅度。对指定的四个测试用例中的每一个重复此过程。", "answer": "```python\nimport numpy as np\nfrom scipy.special import sph_harm\nfrom scipy.constants import mu_0, epsilon_0, c\n\ndef solve():\n    \"\"\"\n    Main orchestrator for solving the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # (a, f, l, m, J0, alpha, N_theta_coarse, N_phi_coarse, N_theta_fine, N_phi_fine)\n        (0.37, 500e6, 3, 1, 1.0, 0.05, 24, 48, 40, 80),\n        (0.37, 500e6, 3, 1, 1.0, 0.05, 8, 16, 40, 80),\n        (0.50, 1200e6, 4, 2, 1.0, 0.02, 20, 40, 40, 80),\n        (0.50, 50e6, 2, 1, 1.0, 0.05, 24, 48, 40, 80),\n    ]\n\n    # Non-matched test points (theta, phi) in radians\n    non_matched_points_sph = np.array([\n        (0.3 * np.pi, 0.1 * np.pi), (0.45 * np.pi, 0.35 * np.pi),\n        (0.6 * np.pi, 1.2 * np.pi), (0.2 * np.pi, 2.0 * np.pi),\n        (0.75 * np.pi, 2.4 * np.pi), (0.5 * np.pi, 3.1 * np.pi),\n        (0.65 * np.pi, 1.7 * np.pi), (0.4 * np.pi, 2.8 * np.pi),\n        (0.85 * np.pi, 0.9 * np.pi)\n    ])\n\n    results = []\n    for case in test_cases:\n        a, f, l, m, J0, alpha, N_theta_coarse, N_phi_coarse, N_theta_fine, N_phi_fine = case\n\n        omega = 2 * np.pi * f\n        k = omega / c # k = omega * sqrt(mu_0 * epsilon_0)\n        wavelength = 2 * np.pi / k\n        delta = alpha * wavelength\n        \n        r_obs_mag = a + delta\n        obs_points_cart = np.array([\n            r_obs_mag * np.array([\n                np.sin(th) * np.cos(ph),\n                np.sin(th) * np.sin(ph),\n                np.cos(th)\n            ]) for th, ph in non_matched_points_sph\n        ])\n\n        E_scat_fine_tangential = compute_scattered_field(\n            obs_points_cart, a, k, omega, J0, l, m, N_theta_fine, N_phi_fine\n        )\n        \n        E_scat_coarse_tangential = compute_scattered_field(\n            obs_points_cart, a, k, omega, J0, l, m, N_theta_coarse, N_phi_coarse\n        )\n\n        E_inc_tangential = -E_scat_fine_tangential\n\n        # E_inc is a numpy array of shape (M, 3)\n        # E_scat_coarse is also a numpy array of shape (M, 3)\n        residual_vectors = E_inc_tangential + E_scat_coarse_tangential\n        \n        # Norms are computed along the last axis (axis=1)\n        residual_norms = np.linalg.norm(residual_vectors, axis=1)\n        inc_field_norms = np.linalg.norm(E_inc_tangential, axis=1)\n\n        # To avoid division by zero, though unlikely for these test points\n        inc_field_norms[inc_field_norms == 0] = 1e-16\n\n        relative_errors = residual_norms / inc_field_norms\n        rms_error = np.sqrt(np.mean(relative_errors**2))\n        results.append(rms_error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_dYlm_dtheta(m, l, theta, phi):\n    \"\"\"\n    Computes the derivative of the spherical harmonic Y_lm with respect to theta.\n    Uses the stable recurrence relation involving Y_l,m-1 and Y_l,m+1.\n    \"\"\"\n    if l == 0:\n        return np.zeros_like(theta, dtype=complex)\n\n    # Term 1: involving Y_l,m+1\n    # This term is zero if m = l\n    if m == l:\n        c1 = 0\n    else:\n        c1 = np.sqrt((l - m) * (l + m + 1))\n    \n    Y_lm_plus_1 = sph_harm(m + 1, l, phi, theta)\n    term1 = 0.5 * c1 * np.exp(-1j * phi) * Y_lm_plus_1\n\n    # Term 2: involving Y_l,m-1\n    # This term is zero if m = -l\n    if m == -l:\n        c2 = 0\n    else:\n        c2 = np.sqrt((l + m) * (l - m + 1))\n        \n    Y_lm_minus_1 = sph_harm(m - 1, l, phi, theta)\n    term2 = -0.5 * c2 * np.exp(1j * phi) * Y_lm_minus_1\n\n    return term1 + term2\n\ndef compute_scattered_field(obs_points_cart, a, k, omega, J0, l, m, N_theta, N_phi):\n    \"\"\"\n    Computes the scattered electric field by numerically integrating over the sphere.\n    \"\"\"\n    # Create the source grid for integration\n    d_theta = np.pi / N_theta\n    d_phi = 2 * np.pi / N_phi\n    \n    theta_s = (np.arange(N_theta) + 0.5) * d_theta\n    phi_s = (np.arange(N_phi) + 0.5) * d_phi\n    \n    theta_s_grid, phi_s_grid = np.meshgrid(theta_s, phi_s, indexing='ij')\n\n    # Compute current density J at all source points\n    # 1. Spherical harmonics and their derivatives\n    Y_lm = sph_harm(m, l, phi_s_grid, theta_s_grid)\n    dYlm_dphi = 1j * m * Y_lm\n    dYlm_dtheta_vals = compute_dYlm_dtheta(m, l, theta_s_grid, phi_s_grid)\n    \n    # Avoid division by zero at poles (though midpoint rule already does)\n    sin_theta_s = np.sin(theta_s_grid)\n    sin_theta_s[sin_theta_s == 0] = 1e-16\n    \n    # 2. Components of X_lm in spherical coordinates\n    X_theta = - (1 / np.sqrt(l * (l + 1))) * (1 / sin_theta_s) * dYlm_dphi\n    X_phi = (1 / np.sqrt(l * (l + 1))) * dYlm_dtheta_vals\n\n    # 3. Current density vector J in local spherical coordinates\n    J_theta = J0 * X_theta\n    J_phi = J0 * X_phi\n    \n    # 4. Convert J to Cartesian coordinates for integration\n    # Cartesian components of spherical basis vectors\n    e_theta_x = np.cos(theta_s_grid) * np.cos(phi_s_grid)\n    e_theta_y = np.cos(theta_s_grid) * np.sin(phi_s_grid)\n    e_theta_z = -np.sin(theta_s_grid)\n    e_phi_x = -np.sin(phi_s_grid)\n    e_phi_y = np.cos(phi_s_grid)\n    # e_phi_z is always 0\n    \n    J_x = J_theta * e_theta_x + J_phi * e_phi_x\n    J_y = J_theta * e_theta_y + J_phi * e_phi_y\n    J_z = J_theta * e_theta_z # J_phi has no z-component\n    \n    J_cartesian = np.stack((J_x, J_y, J_z), axis=-1) # Shape: (N_theta, N_phi, 3)\n\n    # Source point positions in Cartesian coordinates\n    r_prime_x = a * np.sin(theta_s_grid) * np.cos(phi_s_grid)\n    r_prime_y = a * np.sin(theta_s_grid) * np.sin(phi_s_grid)\n    r_prime_z = a * np.cos(theta_s_grid)\n    r_prime = np.stack((r_prime_x, r_prime_y, r_prime_z), axis=-1)\n\n    # Integration area element\n    dS = a**2 * np.sin(theta_s_grid) * d_theta * d_phi\n\n    E_scat_tangential = []\n    \n    # Loop over each observation point\n    for r_obs in obs_points_cart:\n        # Vector from source to observation point\n        dr = r_obs - r_prime  # Shape: (N_theta, N_phi, 3)\n        dist = np.linalg.norm(dr, axis=-1) # Shape: (N_theta, N_phi)\n\n        # Green's function\n        G = np.exp(1j * k * dist) / (4 * np.pi * dist)\n\n        # Integrand (vector)\n        integrand = G[..., np.newaxis] * J_cartesian * dS[..., np.newaxis]\n        \n        # Sum over grid points to get E_scat (vector)\n        E_scat_vec = np.sum(integrand, axis=(0, 1)) * 1j * omega * mu_0\n\n        # Project to tangential component at observation point\n        r_obs_hat = r_obs / np.linalg.norm(r_obs)\n        E_scat_radial_comp = np.dot(E_scat_vec, r_obs_hat) * r_obs_hat\n        E_scat_tangential_vec = E_scat_vec - E_scat_radial_comp\n        \n        E_scat_tangential.append(E_scat_tangential_vec)\n\n    return np.array(E_scat_tangential)\n\nsolve()\n```", "id": "3341444"}]}