{"hands_on_practices": [{"introduction": "在时域仿真中定义端口的第一个基本步骤是确保其能量守恒。本练习从第一性原理出发，通过设计一个数值验证实验，确认一个归一化的时域端口在向匹配负载发射功率脉冲时，其传递的总能量与理论值精确吻合[@problem_id:3342260]。这个实践旨在夯实对端口功率定义和行波分解之间基本关系的理解。", "problem": "为计算电磁学中的时域端口设计一个验证实验，通过发射具有指定入射功率的脉冲并测量传递到匹配负载的积分能量，来确认功率归一化。完全在一维横向电磁波（TEM）传输线抽象模型中进行，并使用以下基本原理：麦克斯韦方程组、坡印廷定理以及传输线分解为前向（入射）和后向（反射）行波。\n\n您必须从第一性原理出发。考虑一个无损、无色散、均匀的TEM传输线，其特征为实数特性阻抗 $Z_0$ 和波速 $c$。在时域端口模型中，端口处的总电压 $v(t)$ 和总电流 $i(t)$ 可以通过以下关系分解为入射行波分量 $v^{+}(t)$ 和反射行波分量 $v^{-}(t)$：\n$$\nv(t) = v^{+}(t) + v^{-}(t), \\quad i(t) = \\frac{1}{Z_0}\\left(v^{+}(t) - v^{-}(t)\\right).\n$$\n端口处的匹配负载是指其阻抗等于特性阻抗 $Z_0$ 的负载，这意味着对于任何入射波形，反射 $v^{-}(t) = 0$ 均为零。\n\n根据坡印廷定理以及横截面坡印廷通量与乘积 $v(t)i(t)$ 之间的传输线对应关系，传递到负载的瞬时功率为\n$$\np(t) = v(t)i(t).\n$$\n在匹配终端条件下，$v(t) = v^{+}(t)$ 且 $i(t) = \\frac{v^{+}(t)}{Z_0}$，因此\n$$\np(t) = \\frac{\\left(v^{+}(t)\\right)^2}{Z_0}.\n$$\n\n您的任务是在离散时间内验证一个为发射具有预定瞬时功率的入射脉冲而归一化的端口，确实能将相应的能量传递到匹配负载中。具体来说，发射一个在持续时间 $T$ 内具有恒定入射功率 $P_0 = 1$ W，在其他时间为零的矩形顶脉冲。设离散时间步长为 $\\Delta t$，脉冲样本数为 $N$，因此 $T = N\\,\\Delta t$。使用左黎曼和将离散时间功率样本解释为区间平均值来计算传递的能量：\n$$\nE_{\\text{deliv}} \\approx \\sum_{n=0}^{N-1} p[n]\\,\\Delta t.\n$$\n对于匹配负载和理想的端口归一化，理论能量为\n$$\nE_{\\text{theory}} = \\int_{0}^{T} P_0\\,dt = P_0 T = P_0 N \\Delta t.\n$$\n为了在时域端口中实现入射功率 $P_0$，选择匹配线路上的入射电压波形为\n$$\nv^{+}[n] = \\sqrt{Z_0 P_0}\\,u_{\\text{rect}}[n],\n$$\n其中 $u_{\\text{rect}}[n]$ 在脉冲的 $N$ 个样本上等于 $1$，在其他地方等于 $0$。在匹配负载下，总端口场满足 $v[n] = v^{+}[n]$ 和 $i[n] = \\frac{v[n]}{Z_0}$。\n\n实现一个程序，为每个测试用例构建如上的 $v[n]$ 和 $i[n]$，使用左黎曼和计算 $E_{\\text{deliv}}$，并返回绝对误差\n$$\n\\varepsilon = \\left|E_{\\text{deliv}} - E_{\\text{theory}}\\right|\n$$\n单位为焦耳。所有物理答案必须以焦耳表示。本问题不涉及角度。不要以百分比形式表示任何值。\n\n测试套件和所需单位：\n- 在所有情况下使用 $P_0 = 1$ W，并以焦耳表示能量。\n- 每个测试用例由 $(Z_0,\\ \\Delta t,\\ N)$ 指定，$Z_0$ 单位为欧姆，$\\Delta t$ 单位为秒，$N$ 无量纲。\n- 测试用例：\n    - 用例 1（正常路径）：$Z_0 = 50$ $\\Omega$，$\\Delta t = 1\\times 10^{-12}$ s，$N = 1000$。\n    - 用例 2（覆盖性：不同的 $Z_0$ 和步长）：$Z_0 = 377$ $\\Omega$，$\\Delta t = 2\\times 10^{-12}$ s，$N = 500$。\n    - 用例 3（覆盖性：更长的脉冲和不同的 $Z_0$）：$Z_0 = 75$ $\\Omega$，$\\Delta t = 5\\times 10^{-12}$ s，$N = 1000$。\n    - 用例 4（边界情况：非常短的脉冲）：$Z_0 = 200$ $\\Omega$，$\\Delta t = 1\\times 10^{-11}$ s，$N = 3$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，结果按测试用例的顺序排列。第 $k$ 个条目必须是用例 $k$ 的绝对能量误差 $\\varepsilon$（单位为焦耳）。例如，一个有效的输出字符串形式为“[result_case1,result_case2,result_case3,result_case4]”。", "solution": "该问题要求设计并实现一个用于计算电磁学中时域端口模型的数值验证实验。该实验旨在确认端口能将发射的脉冲正确地归一化到指定的入射功率。这是通过计算传递到匹配负载的总能量并将其与理论值进行比较来实现的。此问题的框架是一维、无损、无色散的横向电磁波（TEM）传输线模型，这是一个从麦克斯韦方程组推导出的基本抽象模型。\n\n此验证的核心原理在于传输线上的行波分解。在任意点（如端口）的总电压 $v(t)$ 和总电流 $i(t)$ 可以表示为前向传播（入射）波和后向传播（反射）波的叠加。其关系由以下公式给出：\n$$\nv(t) = v^{+}(t) + v^{-}(t)\n$$\n$$\ni(t) = \\frac{1}{Z_0}\\left(v^{+}(t) - v^{-}(t)\\right)\n$$\n这里，$v^{+}(t)$ 和 $v^{-}(t)$ 分别代表入射和反射电压波，$Z_0$ 是传输线的特性阻抗。\n\n流入连接在端口处的负载的瞬时功率 $p(t)$ 由总电压和总电流的乘积给出，$p(t) = v(t)i(t)$，这是横截面上积分坡印廷通量的传输线等效形式。\n\n问题指定了匹配负载，这是一个关键条件。匹配负载的阻抗等于传输线的特性阻抗 $Z_0$。根据负载处的欧姆定律，$v(t) = Z_0 i(t)$。将波分解代入此条件可得：\n$$\nv^{+}(t) + v^{-}(t) = Z_0 \\left( \\frac{1}{Z_0}\\left(v^{+}(t) - v^{-}(t)\\right) \\right) = v^{+}(t) - v^{-}(t)\n$$\n这简化为 $2v^{-}(t) = 0$，即 $v^{-}(t) = 0$。匹配负载完全吸收了入射波，不产生反射。因此，端口处的总电压和电流简化为 $v(t) = v^{+}(t)$ 和 $i(t) = v^{+}(t)/Z_0$。传递到匹配负载的功率则为：\n$$\np(t) = v(t)i(t) = v^{+}(t) \\cdot \\frac{v^{+}(t)}{Z_0} = \\frac{\\left(v^{+}(t)\\right)^2}{Z_0}\n$$\n\n该验证实验是围绕一个特定的入射脉冲设计的：一个在持续时间 $T$ 内具有恒定瞬时功率 $P_0$ 的脉冲。为实现这一点，我们必须构建相应的入射电压波形 $v^{+}(t)$。根据功率关系，我们需要：\n$$\nP_0 = \\frac{\\left(v^{+}(t)\\right)^2}{Z_0} \\quad \\text{for } t \\in [0, T]\n$$\n解出 $v^{+}(t)$，得到入射电压脉冲所需的幅度：\n$$\nv^{+}(t) = \\sqrt{Z_0 P_0} \\quad \\text{for } t \\in [0, T]\n$$\n在其他时间 $v^{+}(t) = 0$。\n\n此脉冲传递的总理论能量 $E_{\\text{theory}}$ 是恒定功率 $P_0$ 在持续时间 $T$ 上的时间积分：\n$$\nE_{\\text{theory}} = \\int_{0}^{T} P_0\\,dt = P_0 T\n$$\n在用于数值模拟的离散时间域中，时间持续 $T$ 由 $N$ 个大小为 $\\Delta t$ 的时间步表示，因此 $T = N \\Delta t$。于是，理论能量为：\n$$\nE_{\\text{theory}} = P_0 N \\Delta t\n$$\n数值模拟通过对离散功率样本求和来计算传递的能量 $E_{\\text{deliv}}$。使用指定的左黎曼和解释：\n$$\nE_{\\text{deliv}} = \\sum_{n=0}^{N-1} p[n]\\,\\Delta t\n$$\n其中 $p[n]$ 是在时间步 $n$ 的瞬时功率。根据模型，我们首先构建离散入射电压 $v^{+}[n] = \\sqrt{Z_0 P_0}$，其中 $n=0, 1, \\dots, N-1$。由于负载是匹配的，总场为 $v[n] = v^{+}[n]$ 和 $i[n] = v[n]/Z_0$。离散瞬时功率为：\n$$\np[n] = v[n]i[n] = \\frac{(v[n])^2}{Z_0} = \\frac{(\\sqrt{Z_0 P_0})^2}{Z_0} = \\frac{Z_0 P_0}{Z_0} = P_0\n$$\n这在脉冲活动期间的每个时间步 $n$ 都成立。将此恒定功率代入 $E_{\\text{deliv}}$ 的求和中，得到：\n$$\nE_{\\text{deliv}} = \\sum_{n=0}^{N-1} P_0\\,\\Delta t = P_0 \\Delta t \\sum_{n=0}^{N-1} 1 = P_0 \\Delta t \\cdot N\n$$\n从解析上看，我们发现 $E_{\\text{deliv}} = E_{\\text{theory}}$。这是一个“零值测试”或“空测试”：其目的是验证这些公式的数值实现能够正确地再现这一解析恒等式。此验证的度量标准是绝对误差 $\\varepsilon = |E_{\\text{deliv}} - E_{\\text{theory}}|$。根据我们的推导，此误差预期为零，或一个由于浮点运算的性质而在机器精度量级的非常小的值。\n\n对于每个测试用例 $(Z_0, \\Delta t, N)$，当 $P_0 = 1$ W 时，算法如下：\n1.  计算理论能量：$E_{\\text{theory}} = P_0 N \\Delta t$。\n2.  根据问题的物理模型，根据定义，从为入射功率 $P_0$ 归一化的端口传递到匹配负载的瞬时功率 $p[n]$ 为 $p[n]=P_0$。\n3.  通过对这些功率贡献求和来数值计算传递的能量：$E_{\\text{deliv}} = \\sum_{n=0}^{N-1} P_0 \\Delta t = P_0 N \\Delta t$。\n4.  计算绝对误差 $\\varepsilon = |E_{\\text{deliv}} - E_{\\text{theory}}|$。鉴于直接计算，误差基本上将为零，仅受浮点表示精度的限制。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a verification experiment for a time-domain port model\n    in computational electromagnetics.\n\n    The experiment verifies that a port normalized to launch an incident pulse\n    of prescribed power (P_0) delivers the correct total energy into a\n    matched load. The absolute error between the numerically computed\n    delivered energy and the theoretical energy is calculated.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (Z_0 in ohms, Delta_t in seconds, N dimensionless)\n    test_cases = [\n        (50.0, 1e-12, 1000),  # Case 1\n        (377.0, 2e-12, 500),   # Case 2\n        (75.0, 5e-12, 1000),   # Case 3\n        (200.0, 1e-11, 3),     # Case 4\n    ]\n\n    # Incident power is constant for all test cases.\n    P_0 = 1.0  # W\n\n    results = []\n    for case in test_cases:\n        Z_0, delta_t, N = case\n\n        # 1. Calculate the theoretical total energy delivered.\n        # E_theory = integral(P_0 dt) from 0 to T, where T = N * delta_t.\n        # For a constant P_0, this is simply P_0 * T.\n        E_theory = P_0 * N * delta_t\n\n        # 2. Simulate the physical process in discrete time.\n        # A port normalized for incident power P_0 is defined such that it would\n        # deliver P_0 to a matched load at every instant the source is active.\n        # For a rectangular pulse of duration T, the instantaneous power p[n]\n        # delivered to the matched load is P_0 for n = 0, ..., N-1.\n        \n        # We can explicitly follow the steps laid out in the problem to demonstrate this:\n        # a. Define the incident voltage waveform to produce power P_0.\n        # p_inc(t) = (v+(t))^2 / Z_0 = v+(t) = sqrt(Z_0 * p_inc(t))\n        # For p_inc(t) = P_0, the voltage amplitude is constant.\n        v_plus_amplitude = np.sqrt(Z_0 * P_0)\n        \n        # b. For a matched load, v(t) = v+(t) and i(t) = v+(t) / Z_0.\n        v_total_amplitude = v_plus_amplitude\n        i_total_amplitude = v_total_amplitude / Z_0\n        \n        # c. Calculate the instantaneous power p[n] = v[n] * i[n] for each step.\n        # Since v and i amplitudes are constant, the power is constant.\n        p_n = v_total_amplitude * i_total_amplitude\n        # Analytically, p_n = sqrt(Z_0*P_0) * (sqrt(Z_0*P_0)/Z_0) = (Z_0*P_0)/Z_0 = P_0.\n        # The numerical calculation should yield a value extremely close to P_0.\n\n        # 3. Calculate the total delivered energy using a left Riemann sum.\n        # E_deliv = sum(p[n] * delta_t for n=0 to N-1)\n        # Since p[n] is constant over the pulse duration:\n        E_deliv = N * p_n * delta_t\n        \n        # 4. Compute the absolute error between delivered and theoretical energy.\n        # This is a \"null test\" where the error should be zero or at the level\n        # of machine floating-point precision.\n        error = abs(E_deliv - E_theory)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    # The output should be a list of zeros, reflecting the analytic identity.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3342260"}, {"introduction": "端口的定义方式直接影响仿真结果的物理诠释，尤其是在处理复杂的几何结构时。本练习通过对比集总端口和分布式模式端口在微带弯角不连续性分析中的表现，揭示了端口的场采样区域如何对提取的寄生电容产生系统性偏差[@problem_id:3342286]。这有助于培养对仿真设置中物理抽象与实际场分布之间差异的批判性思维。", "problem": "考虑一个在准静态、准横向电磁场设定下建模的直角微带弯头。使用两种不同的端口定义在时域中激励和测量线路：一种是具有有限横向范围、基于局部电压/电流的集总端口，另一种是执行全横截面模式提取的分布式模式波端口。您将比较在使用时域反射计阶跃响应提取器时，每个端口的场采样区域如何对感知到的并联不连续电容产生偏置。\n\n推导过程基于以下公认的基础：\n- 微分形式的Maxwell方程组、本构关系和电荷连续性。\n- 在两条特性阻抗为 $Z_0$ 的相同无损传输线之间插入一个并联导纳的小信号散射：如果归一化并联导纳为 $y = Y Z_0$，则反射系数为 $S_{11} = -\\dfrac{y}{2 + y}$，对于 $|y| \\ll 1$ 的情况，该式简化为 $S_{11} \\approx - \\dfrac{y}{2}$。\n- 对于对称嵌入在两条相同的、匹配的、无损线路之间的并联电容 $C_{\\mathrm{d}}$ 的时域反射计关系：对于单位幅度的前向阶跃信号 $v^{+}(t)$，小信号反射波为 $v^{-}(t) = - \\dfrac{Z_0 C_{\\mathrm{d}}}{2} \\dfrac{d v_{\\mathrm{disc}}(t)}{d t}$，因此归一化到单位阶跃的反射核下方的面积等于 $- \\dfrac{Z_0 C_{\\mathrm{d}}}{2}$。\n\n您将建模说明端口的有限场采样区域如何改变不连续点的局部电压与端口报告的电压之间的测量关系。设微带宽度为 $w$，并引入横向坐标 $x \\in [0,w]$，其中 $x=0$ 位于弯头内缘。设沿宽度的无量纲准静态场集中分布剖面为\n$$\ng(x;\\sigma) \\triangleq \\frac{K}{1+\\left(\\dfrac{x}{\\sigma}\\right)^2}, \\quad \\text{其中} \\quad K \\ \\text{的选择满足} \\ \\frac{1}{w} \\int_{0}^{w} g(x;\\sigma) \\, dx = 1.\n$$\n这种归一化强制要求 $g$ 的横截面平均值为1，因此，定义为横截面平均电位差的分布式模式波端口的线电压等于不连续点上的有效电压。对于一个通过对从 $x_0$ 开始、宽度为 $w_{\\mathrm{s}}$ 的有限横向采样区间（即采样区域为 $[x_0, x_0 + w_{\\mathrm{s}}] \\subset [0,w]$）内的电场进行空间平均来测量电压的集总端口，测得的电压与 $g$ 在该区间上的局部平均值成正比。定义\n$$\nG_{\\mathrm{local}}(x_0,w_{\\mathrm{s}};\\sigma,w) \\triangleq \\frac{1}{w_{\\mathrm{s}}} \\int_{x_0}^{x_0+w_{\\mathrm{s}}} g(x;\\sigma) \\, dx, \\qquad G_{\\mathrm{avg}}(\\sigma,w) \\triangleq \\frac{1}{w} \\int_{0}^{w} g(x;\\sigma) \\, dx = 1.\n$$\n\n使用小信号时域关系 $v^{-}(t) = - \\dfrac{Z_0 C_{\\mathrm{d}}}{2} \\dfrac{d v_{\\mathrm{disc}}(t)}{d t}$，其中 $v_{\\mathrm{disc}}(t)$ 是有效不连续电压，证明：\n- 对于分布式模式波端口，根据其构造有 $v_{\\mathrm{disc}}(t) = v_{\\mathrm{wave}}(t)$，因此脉冲下方面积法得出 $C_{\\mathrm{est,\\,wave}} = C_{\\mathrm{d}}$。\n- 对于集总端口，有 $v_{\\mathrm{disc}}(t) = \\dfrac{G_{\\mathrm{avg}}}{G_{\\mathrm{local}}} v_{\\mathrm{lump}}(t) = \\dfrac{1}{G_{\\mathrm{local}}} v_{\\mathrm{lump}}(t)$，因此同样的使用 $Z_0$ 进行除法的脉冲下方面积提取器返回\n$$\nC_{\\mathrm{est,\\,lump}} = \\frac{G_{\\mathrm{avg}}}{G_{\\mathrm{local}}} \\, C_{\\mathrm{d}} = \\frac{C_{\\mathrm{d}}}{G_{\\mathrm{local}}}.\n$$\n\n任务：\n1. 仅从上述基础出发，推导 $K$、$G_{\\mathrm{local}}$ 以及偏置公式 $C_{\\mathrm{est,\\,wave}}$ 和 $C_{\\mathrm{est,\\,lump}}$ 关于 $(w,\\sigma,w_{\\mathrm{s}},x_0,C_{\\mathrm{d}})$ 的表达式。\n2. 实现一个程序，对于下面指定的每个测试用例，使用推导出的公式计算 $C_{\\mathrm{est,\\,wave}}$ 和 $C_{\\mathrm{est,\\,lump}}$。使用 $g(x;\\sigma)$ 的闭式反导数来精确计算 $G_{\\mathrm{local}}$（不要使用数值积分）。所有电容以法拉 (farad) 为单位表示。\n\n使用以下测试套件（所有长度必须解释为毫米，电容为法拉，特性阻抗为欧姆；任何内部反正切计算中的角度都以弧度为单位）：\n- 测试1（正常路径，中等场集中度，中心采样）：$w = 1.0$ mm，$\\sigma = 0.05$ mm， $w_{\\mathrm{s}} = 0.2$ mm， $x_0 = 0.4$ mm， $Z_0 = 50$， $C_{\\mathrm{d}} = 1.0 \\times 10^{-13}$ F。\n- 测试2（内弯头边缘采样，局部场更强，预计会低估）：$w = 1.0$ mm，$\\sigma = 0.05$ mm， $w_{\\mathrm{s}} = 0.1$ mm， $x_0 = 0.0$ mm， $Z_0 = 50$， $C_{\\mathrm{d}} = 1.0 \\times 10^{-13}$ F。\n- 测试3（采样跨越全宽，无偏置）：$w = 1.0$ mm，$\\sigma = 0.05$ mm， $w_{\\mathrm{s}} = 1.0$ mm， $x_0 = 0.0$ mm， $Z_0 = 50$， $C_{\\mathrm{d}} = 1.0 \\times 10^{-13}$ F。\n- 测试4（极端场集中和非常窄的边缘采样，严重低估）：$w = 1.0$ mm，$\\sigma = 0.01$ mm， $w_{\\mathrm{s}} = 0.02$ mm， $x_0 = 0.0$ mm， $Z_0 = 50$， $C_{\\mathrm{d}} = 1.0 \\times 10^{-13}$ F。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表。该列表必须按顺序包含每个测试的 $C_{\\mathrm{est,\\,wave}}$ 和 $C_{\\mathrm{est,\\,lump}}$，单位均为法拉。对于上述四个测试，输出必须是一个包含八个浮点数值（单位为法拉）的扁平列表：$[C_{\\mathrm{est,\\,wave}}^{(1)},C_{\\mathrm{est,\\,lump}}^{(1)},C_{\\mathrm{est,\\,wave}}^{(2)},C_{\\mathrm{est,\\,lump}}^{(2)},C_{\\mathrm{est,\\,wave}}^{(3)},C_{\\mathrm{est,\\,lump}}^{(3)},C_{\\mathrm{est,\\,wave}}^{(4)},C_{\\mathrm{est,\\,lump}}^{(4)}]$。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于电磁学和传输线理论的既定原则，提法明确，目标清晰，数据充分，并且没有主观或矛盾的陈述。该任务是基于所提供的物理模型进行形式化推导和后续计算。\n\n推导和求解过程如下，遵循问题中概述的原则和任务。\n\n### 1. 归一化常数 $K$ 的推导\n\n无量纲的准静态场集中分布剖面由下式给出：\n$$\ng(x;\\sigma) \\triangleq \\frac{K}{1+\\left(\\dfrac{x}{\\sigma}\\right)^2}\n$$\n常数 $K$ 由归一化条件确定，即 $g(x;\\sigma)$ 在微带宽度 $w$ 上的横截面平均值为1。这表示为：\n$$\nG_{\\mathrm{avg}}(\\sigma,w) = \\frac{1}{w} \\int_{0}^{w} g(x;\\sigma) \\, dx = 1\n$$\n代入 $g(x;\\sigma)$ 的表达式：\n$$\n\\frac{1}{w} \\int_{0}^{w} \\frac{K}{1+\\left(\\dfrac{x}{\\sigma}\\right)^2} \\, dx = 1\n$$\n为了求解 $K$，我们首先计算积分。被积函数的反导数是已知的：\n$$\n\\int \\frac{1}{1+\\left(\\dfrac{x}{\\sigma}\\right)^2} \\, dx = \\sigma \\arctan\\left(\\frac{x}{\\sigma}\\right)\n$$\n应用从 $0$ 到 $w$ 的积分限：\n$$\n\\int_{0}^{w} \\frac{1}{1+\\left(\\dfrac{x}{\\sigma}\\right)^2} \\, dx = \\left[ \\sigma \\arctan\\left(\\frac{x}{\\sigma}\\right) \\right]_{0}^{w} = \\sigma \\arctan\\left(\\frac{w}{\\sigma}\\right) - \\sigma \\arctan(0) = \\sigma \\arctan\\left(\\frac{w}{\\sigma}\\right)\n$$\n将此结果代回归一化方程：\n$$\n\\frac{K}{w} \\left( \\sigma \\arctan\\left(\\frac{w}{\\sigma}\\right) \\right) = 1\n$$\n求解 $K$ 得到归一化常数的最终表达式：\n$$\nK = \\frac{w}{\\sigma \\arctan\\left(\\dfrac{w}{\\sigma}\\right)}\n$$\n\n### 2. 局部平均函数 $G_{\\mathrm{local}}$ 的推导\n\n函数 $G_{\\mathrm{local}}$ 表示场剖面 $g(x;\\sigma)$ 在有限采样区间 $[x_0, x_0 + w_{\\mathrm{s}}]$ 上的平均值。其定义为：\n$$\nG_{\\mathrm{local}}(x_0,w_{\\mathrm{s}};\\sigma,w) \\triangleq \\frac{1}{w_{\\mathrm{s}}} \\int_{x_0}^{x_0+w_{\\mathrm{s}}} g(x;\\sigma) \\, dx\n$$\n代入 $g(x;\\sigma)$ 的表达式：\n$$\nG_{\\mathrm{local}} = \\frac{1}{w_{\\mathrm{s}}} \\int_{x_0}^{x_0+w_{\\mathrm{s}}} \\frac{K}{1+\\left(\\dfrac{x}{\\sigma}\\right)^2} \\, dx = \\frac{K}{w_{\\mathrm{s}}} \\int_{x_0}^{x_0+w_{\\mathrm{s}}} \\frac{1}{1+\\left(\\dfrac{x}{\\sigma}\\right)^2} \\, dx\n$$\n使用与之前相同的反导数，并应用新的积分限：\n$$\n\\int_{x_0}^{x_0+w_{\\mathrm{s}}} \\frac{1}{1+\\left(\\dfrac{x}{\\sigma}\\right)^2} \\, dx = \\left[ \\sigma \\arctan\\left(\\frac{x}{\\sigma}\\right) \\right]_{x_0}^{x_0+w_{\\mathrm{s}}} = \\sigma \\left( \\arctan\\left(\\frac{x_0+w_{\\mathrm{s}}}{\\sigma}\\right) - \\arctan\\left(\\frac{x_0}{\\sigma}\\right) \\right)\n$$\n将此积分结果代入 $G_{\\mathrm{local}}$ 的表达式：\n$$\nG_{\\mathrm{local}} = \\frac{K \\sigma}{w_{\\mathrm{s}}} \\left( \\arctan\\left(\\frac{x_0+w_{\\mathrm{s}}}{\\sigma}\\right) - \\arctan\\left(\\frac{x_0}{\\sigma}\\right) \\right)\n$$\n最后，代入推导出的 $K$ 的表达式：\n$$\nG_{\\mathrm{local}} = \\frac{1}{w_{\\mathrm{s}}} \\left( \\frac{w}{\\sigma \\arctan\\left(\\frac{w}{\\sigma}\\right)} \\right) \\sigma \\left( \\arctan\\left(\\frac{x_0+w_{\\mathrm{s}}}{\\sigma}\\right) - \\arctan\\left(\\frac{x_0}{\\sigma}\\right) \\right)\n$$\n简化此表达式可得到 $G_{\\mathrm{local}}$ 的闭式形式：\n$$\nG_{\\mathrm{local}}(x_0,w_{\\mathrm{s}};\\sigma,w) = \\frac{w}{w_{\\mathrm{s}} \\arctan\\left(\\frac{w}{\\sigma}\\right)} \\left( \\arctan\\left(\\frac{x_0+w_{\\mathrm{s}}}{\\sigma}\\right) - \\arctan\\left(\\frac{x_0}{\\sigma}\\right) \\right)\n$$\n\n### 3. 估算电容公式的推导\n\n分析从一个小时并联电容 $C_{\\mathrm{d}}$ 的时域反射计 (TDR) 关系开始：反射电压波 $v^-(t)$ 与不连续点两端的电压 $v_{\\mathrm{disc}}(t)$ 的时间导数成正比。\n$$\nv^{-}(t) = - \\frac{Z_0 C_{\\mathrm{d}}}{2} \\frac{d v_{\\mathrm{disc}}(t)}{d t}\n$$\nTDR测量算法通过对反射脉冲进行积分，并用假定的入射阶跃幅度和特性阻抗 $Z_0$ 进行归一化来估算电容。假设一个单位幅度的阶跃激励，反射脉冲 $v^-(t)$ 下的面积为：\n$$\n\\int_{0}^{\\infty} v^{-}(t) \\, dt = \\int_{0}^{\\infty} \\left( - \\frac{Z_0 C_{\\mathrm{d}}}{2} \\frac{d v_{\\mathrm{disc}}(t)}{d t} \\right) dt = - \\frac{Z_0 C_{\\mathrm{d}}}{2} [v_{\\mathrm{disc}}(t)]_{0}^{\\infty} = - \\frac{Z_0 C_{\\mathrm{d}}}{2} \\Delta v_{\\mathrm{disc}}\n$$\n其中 $\\Delta v_{\\mathrm{disc}}$ 是不连续点两端的电压阶跃幅度。该算法使用在端口测量的阶跃电压幅度 $\\Delta v_{\\mathrm{port}}$ 作为参考来计算估算电容 $C_{\\mathrm{est}}$：\n$$\nC_{\\mathrm{est}} = - \\frac{2}{Z_0 \\Delta v_{\\mathrm{port}}} \\int_{0}^{\\infty} v^{-}(t) \\, dt = - \\frac{2}{Z_0 \\Delta v_{\\mathrm{port}}} \\left( - \\frac{Z_0 C_{\\mathrm{d}}}{2} \\Delta v_{\\mathrm{disc}} \\right) = C_{\\mathrm{d}} \\frac{\\Delta v_{\\mathrm{disc}}}{\\Delta v_{\\mathrm{port}}}\n$$\n估算电容中的偏置源于真实不连续电压阶跃 $\\Delta v_{\\mathrm{disc}}$ 与端口测量的电压阶跃 $\\Delta v_{\\mathrm{port}}$ 之间的差异。根据构造，真实不连续电压与由 $G_{\\mathrm{avg}}=1$ 缩放的全横截面平均场成正比。端口电压与由 $G_{\\mathrm{local}}$ 缩放的其采样区域上的场平均值成正比。因此，它们的比率为：\n$$\n\\frac{v_{\\mathrm{port}}(t)}{v_{\\mathrm{disc}}(t)} = \\frac{G_{\\mathrm{local}}}{G_{\\mathrm{avg}}} = G_{\\mathrm{local}} \\quad \\implies \\quad \\frac{\\Delta v_{\\mathrm{port}}}{\\Delta v_{\\mathrm{disc}}} = G_{\\mathrm{local}}\n$$\n\n**情况 A：分布式模式波端口**\n分布式模式波端口的定义旨在提取传输线基模的电压，该电压对应于横截面平均电位。因此，根据其定义：\n$$\nv_{\\mathrm{wave}}(t) = v_{\\mathrm{disc}}(t) \\quad \\implies \\quad \\Delta v_{\\mathrm{wave}} = \\Delta v_{\\mathrm{disc}}\n$$\n将此代入 $C_{\\mathrm{est}}$ 的通用公式：\n$$\nC_{\\mathrm{est,\\,wave}} = C_{\\mathrm{d}} \\frac{\\Delta v_{\\mathrm{disc}}}{\\Delta v_{\\mathrm{wave}}} = C_{\\mathrm{d}} \\cdot 1 = C_{\\mathrm{d}}\n$$\n估算的电容是无偏的，等于真实的不连续电容。\n\n**情况 B：集总端口**\n集总端口通过对有限子区域 $[x_0, x_0+w_s]$ 上的场进行平均来测量电压。因此，测量的电压通过局部平均因子与真实不连续电压相关联：\n$$\nv_{\\mathrm{lump}}(t) = G_{\\mathrm{local}} \\cdot v_{\\mathrm{disc}}(t) \\quad \\implies \\quad \\Delta v_{\\mathrm{lump}} = G_{\\mathrm{local}} \\cdot \\Delta v_{\\mathrm{disc}}\n$$\n将此代入 $C_{\\mathrm{est}}$ 的通用公式：\n$$\nC_{\\mathrm{est,\\,lump}} = C_{\\mathrm{d}} \\frac{\\Delta v_{\\mathrm{disc}}}{\\Delta v_{\\mathrm{lump}}} = C_{\\mathrm{d}} \\frac{\\Delta v_{\\mathrm{disc}}}{G_{\\mathrm{local}} \\cdot \\Delta v_{\\mathrm{disc}}} = \\frac{C_{\\mathrm{d}}}{G_{\\mathrm{local}}}\n$$\n由于 $G_{\\mathrm{avg}} = 1$，这与所要求的形式 $C_{\\mathrm{est,\\,lump}} = \\frac{G_{\\mathrm{avg}}}{G_{\\mathrm{local}}} C_{\\mathrm{d}}$ 相同。这表明估算的电容受局部场平均因子的倒数偏置。如果端口采样的区域场强于平均场（$G_{\\mathrm{local}}  1$），则电容被低估。如果采样的区域场弱于平均场（$G_{\\mathrm{local}}  1$），则电容被高估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the estimated waveport and lumped-port discontinuity capacitances for a series of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: (w, sigma, w_s, x_0, Z_0, C_d)\n    # Units: mm for lengths, Ohms for impedance, Farads for capacitance.\n    test_cases = [\n        # Test 1: happy path, moderate field concentration, central sampling\n        (1.0, 0.05, 0.2, 0.4, 50, 1.0e-13),\n        # Test 2: edge sampling near inner bend, stronger local field, underestimation expected\n        (1.0, 0.05, 0.1, 0.0, 50, 1.0e-13),\n        # Test 3: sampling spans full width, unbiased\n        (1.0, 0.05, 1.0, 0.0, 50, 1.0e-13),\n        # Test 4: extreme field concentration and very narrow edge sampling, strong underestimation\n        (1.0, 0.01, 0.02, 0.0, 50, 1.0e-13),\n    ]\n\n    results = []\n    for case in test_cases:\n        w, sigma, w_s, x_0, _, C_d = case\n\n        # The estimated capacitance for a distributed modal waveport is always unbiased.\n        # C_est,wave = C_d\n        c_est_wave = C_d\n\n        # Calculate G_local, the local field averaging factor.\n        # The formulas are derived from the integrals provided in the problem statement.\n        # Since w, sigma, w_s, and x_0 are all in mm, the units cancel out\n        # in the calculation of the dimensionless factor G_local.\n\n        # Special case: if sampling width w_s is zero, the integral is zero.\n        # To avoid division by zero, we handle this, although it's not in the test suite.\n        if w_s == 0:\n            # The value of g at a single point x_0.\n            # This requires computing K first.\n            if sigma == 0: # Avoid division by zero in arctan\n                g_local = 0.0 # Or some other defined behavior for this singularity\n            else:\n                K = w / (sigma * np.arctan(w / sigma))\n                g_local = K / (1 + (x_0 / sigma)**2)\n\n        elif sigma == 0: # Avoid division by zero in arctan\n            g_local = 0.0 # Or some other defined behavior\n\n        else:\n            # Full formula for G_local for w_s  0\n            # G_local = (w / (w_s * arctan(w/sigma))) * (arctan((x_0+w_s)/sigma) - arctan(x_0/sigma))\n            \n            # Use np.arctan for arctangent calculation (angles are in radians)\n            term_w_over_sigma = w / sigma\n            arctan_w_over_sigma = np.arctan(term_w_over_sigma)\n\n            term_x0_plus_ws_over_sigma = (x_0 + w_s) / sigma\n            arctan_x0_plus_ws_over_sigma = np.arctan(term_x0_plus_ws_over_sigma)\n\n            term_x0_over_sigma = x_0 / sigma\n            arctan_x0_over_sigma = np.arctan(term_x0_over_sigma)\n            \n            # Check for denominator becoming zero\n            if arctan_w_over_sigma == 0:\n                 # This would happen if w/sigma is 0, which implies w=0.\n                 # This case is physically not a microstrip.\n                 g_local = 1.0 # Or handle as an error\n            else:\n                factor1 = w / (w_s * arctan_w_over_sigma)\n                factor2 = arctan_x0_plus_ws_over_sigma - arctan_x0_over_sigma\n                g_local = factor1 * factor2\n\n        # The estimated capacitance for the lumped port is biased by 1/G_local.\n        # C_est,lump = C_d / G_local\n        # If G_local is zero, it implies sampling in a null, leading to infinite C_est.\n        if g_local == 0:\n            c_est_lump = float('inf')\n        else:\n            c_est_lump = C_d / g_local\n\n        results.append(c_est_wave)\n        results.append(c_est_lump)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3342286"}, {"introduction": "从时域仿真中获得的端口数据通常需要被转换成稳定且可用于系统级分析的宏模型。本练习探讨了一个高级主题：如何通过对有理函数拟合的参数进行微扰，来强制执行模型的无源性，这是确保模型物理真实性和稳定性的关键步骤[@problem_id:3342298]。通过解决一个带约束的最小二乘问题，您将学习到一种在保持时域拟合精度的同时，保证宏模型无源性的实用技术。", "problem": "在计算电磁学中，给定一个单端口，其端口电压 $v(t)$ 和电流 $i(t)$ 是针对一个底层线性时不变（LTI）网络在时间上采样的。端口阻抗由拉普拉斯域的比率 $Z(s) = \\mathcal{L}\\{v(t)\\}/\\mathcal{L}\\{i(t)\\}$ 定义，建模目标是拟合一个有理宏模型 $\\hat{Z}(s)$，该模型是正实（PR）的，即其在虚轴上的实部为非负。当模型稳定时，正实性是无源性的一个充分条件。对于一个使用矢量拟合（VF）得到的具有实数负极点和实数留数的严格真有理实数拟合的单端口，考虑以下形式\n$$\n\\hat{Z}(s) = d + \\sum_{k=1}^{K} \\frac{r_k}{s - p_k},\n$$\n其中 $p_k \\in \\mathbb{R}$ 且 $p_k  0$，而 $r_k, d \\in \\mathbb{R}$。为了在虚轴上评估无源性，定义 $s = j\\omega$，正实性的条件为对于所有实数 $\\omega$，$\\Re\\{\\hat{Z}(j\\omega)\\} \\ge 0$。时域端口关系通过卷积计算，\n$$\nv(t) = d\\,i(t) + \\sum_{k=1}^{K} r_k \\,(e^{p_k t} u(t)) * i(t),\n$$\n其中 $u(t)$ 是单位阶跃函数，* 表示卷积。\n\n从在时间点 $t_n = n\\,\\Delta t$（其中 $n\\in\\{0,\\dots,N-1\\}$）采样的激励 $i_m(t_n)$（其中 $m\\in\\{1,\\dots,M\\}$）开始，您需要设计并实现一个无源性强制环路，该环路仅扰动留数和直流项 $(\\{r_k\\}, d)$，同时保持极点 $\\{p_k\\}$ 固定，并将时域拟合维持在指定容差内。该环路必须基于以下物理和数学基础：\n\n- 具有实数负极点 $p_k$ 的实有理LTI系统的因果性和稳定性。\n- 连接时域响应和拉普拉斯域有理项的卷积关系。\n- 正实性定义，以及当 $p_k  0$ 和 $r_k \\ge 0$ 时，贡献项 $\\Re\\{\\frac{r_k}{j\\omega - p_k}\\}$ 对所有 $\\omega$ 均为非负的事实。\n- 带不等式约束的最小二乘拟合，作为一种数值上可靠的机制，既可以强制留数的非负性，又可以保持与测量数据的时域匹配。\n\n您的程序必须为每个测试用例实现以下步骤：\n\n1. 为给定的极点 $\\{p_k\\}$、采样步长 $\\Delta t$ 和激励 $\\{i_m(t_n)\\}_{m=1}^M$ 构建离散时间卷积矩阵，使得模型预测的堆叠电压向量对于未知数 $\\mathbf{x} = [r_1,\\dots,r_K,d]^T$ 是线性的。具体来说，第 $k$ 列对应于 $i_m(t_n)$ 与 $e^{p_k t} u(t)$ 的离散卷积乘以 $\\Delta t$，截断为 $N$ 个样本，最后一列对应于与 $i_m(t_n)$ 相乘的直流项。将所有 $M$ 个激励垂直堆叠，形成一个全局矩阵 $\\mathbf{A}\\in\\mathbb{R}^{(MN)\\times(K+1)}$。\n\n2. 使用提供的“真实”无源参数 $\\mathbf{x}_\\text{true}$ 和相同的 $\\mathbf{A}$ 生成测量的堆叠电压向量 $\\mathbf{v}_\\text{meas}$。\n\n3. 给定一个初始（可能非无源）拟合 $\\mathbf{x}_0$，通过求解正则化约束最小二乘问题来强制无源性\n$$\n\\min_{\\mathbf{x}\\ge \\mathbf{0}} \\left\\|\\mathbf{A}\\mathbf{x} - \\mathbf{v}_\\text{meas}\\right\\|_2^2 \\;+\\; \\alpha \\left\\|\\mathbf{x} - \\mathbf{x}_0\\right\\|_2^2,\n$$\n其中 $\\alpha>0$ 是一个正则化权重，它使解偏向于对初始拟合的小扰动，同时匹配测量的时域数据。对 $\\mathbf{x}$ 的分量施加非负约束以确保 $r_k\\ge 0$ 和 $d\\ge 0$，这在 $p_k0$ 的情况下足以保证正实性。\n\n4. 通过计算最小实部，在频率网格 $\\omega_\\ell \\in [0,\\omega_{\\max}]$ 上检查无源性\n$$\n\\min_{\\ell}\\,\\Re\\{\\hat{Z}(j\\omega_\\ell)\\}, \\quad \\text{其中} \\quad \\Re\\left\\{\\frac{r_k}{j\\omega - p_k}\\right\\} = \\frac{r_k(-p_k)}{\\omega^2 + p_k^2}.\n$$\n\n5. 计算每个激励的归一化均方根（RMS）时域电压误差，\n$$\n\\epsilon_m = \\frac{\\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}\\left(v_m^\\text{enf}(t_n)-v_m^\\text{meas}(t_n)\\right)^2}}{\\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}\\left(v_m^\\text{meas}(t_n)\\right)^2}},\n$$\n并报告最坏情况的 $\\max_m \\epsilon_m$。\n\n6. 对于每个测试用例，按顺序输出两个浮点数：最小实部（以欧姆为单位）和最坏情况归一化均方根误差（无量纲）。\n\n测试套件。为以下三种情况实现上述过程。所有时域数组必须以国际单位制（SI单位）计算，时间单位为秒，电流单位为安培，阻抗单位为欧姆。使用每个案例指定的统一时间步长 $\\Delta t$ 和总采样点数 $N$；所有频域检查必须在 $[0,\\omega_{\\max}]$ 上使用一个具有 $N_\\omega$ 个点的均匀网格，其中 $N_\\omega$ 和 $\\omega_{\\max}$ 由每个案例指定。所有激励和参数都是确定性的。\n\n- 情况1（理想情况）：\n  - 极点：$K=3$，其中 $p_1=-2\\times 10^{6}\\,\\mathrm{s}^{-1}$，$p_2=-2\\times 10^{5}\\,\\mathrm{s}^{-1}$，$p_3=-2\\times 10^{4}\\,\\mathrm{s}^{-1}$。\n  - 真实参数：$r_1=0.4$，$r_2=0.2$，$r_3=0.1$，$d=0.5$（欧姆）。\n  - 初始拟合：$r_1^{(0)}=0.38$，$r_2^{(0)}=-0.06$，$r_3^{(0)}=0.12$，$d^{(0)}=0.48$。\n  - 采样：$\\Delta t=10^{-6}\\,\\mathrm{s}$，$N=4096$。\n  - 激励（$M=2$）：\n    - $i_1(t)=\\exp\\!\\left(-\\frac{(t-10^{-3})^2}{2\\cdot (2\\times 10^{-4})^2}\\right)$。\n    - $i_2(t)=0.6\\sin(2\\pi\\cdot 10^{3} t)+0.4\\sin(2\\pi\\cdot 5\\times 10^{3} t)+0.2\\sin(2\\pi\\cdot 3\\times 10^{4} t)$。\n  - 正则化：$\\alpha=10^{-4}$。\n  - 频率网格：$N_\\omega=2000$，$\\omega_{\\max}=10\\cdot \\max_k(-p_k)$。\n  - 时域容差目标：$\\varepsilon_{\\text{tol}}=10^{-3}$（无量纲），仅用于您的评估逻辑；它不改变优化过程，但应在强制执行后进行检查。\n\n- 情况2（已为无源）：\n  - 极点：同情况1。\n  - 真实参数：$r_1=0.35$，$r_2=0.15$，$r_3=0.05$，$d=0.3$。\n  - 初始拟合：$r_1^{(0)}=0.36$，$r_2^{(0)}=0.14$，$r_3^{(0)}=0.06$，$d^{(0)}=0.31$。\n  - 采样：$\\Delta t=10^{-6}\\,\\mathrm{s}$，$N=4096$。\n  - 激励：同情况1。\n  - 正则化：$\\alpha=10^{-4}$。\n  - 频率网格：$N_\\omega=2000$，$\\omega_{\\max}=10\\cdot \\max_k(-p_k)$。\n  - 时域容差目标：$\\varepsilon_{\\text{tol}}=10^{-3}$（无量纲）。\n\n- 情况3（边缘情况，粗采样下的快极点）：\n  - 极点：$K=2$，其中 $p_1=-10^{7}\\,\\mathrm{s}^{-1}$，$p_2=-10^{5}\\,\\mathrm{s}^{-1}$。\n  - 真实参数：$r_1=0.02$，$r_2=0.25$，$d=0.1$。\n  - 初始拟合：$r_1^{(0)}=-0.01$，$r_2^{(0)}=0.27$，$d^{(0)}=0.09$。\n  - 采样：$\\Delta t=10^{-6}\\,\\mathrm{s}$，$N=2048$。\n  - 激励（$M=2$）：\n    - $i_1(t)=\\exp\\!\\left(-\\frac{(t-5\\times 10^{-4})^2}{2\\cdot (1\\times 10^{-4})^2}\\right)$。\n    - $i_2(t)=0.7\\sin(2\\pi\\cdot 8\\times 10^{4} t)+0.3\\sin(2\\pi\\cdot 1.5\\times 10^{5} t)$。\n  - 正则化：$\\alpha=10^{-3}$。\n  - 频率网格：$N_\\omega=2000$，$\\omega_{\\max}=10\\cdot \\max_k(-p_k)$。\n  - 时域容差目标：$\\varepsilon_{\\text{tol}}=5\\times 10^{-3}$（无量纲）。\n\n最终输出格式。您的程序应产生单行输出，包含一个方括号内用逗号分隔的列表。该列表必须按顺序包含情况1、情况2和情况3的结果，即$\\hat{Z}(j\\omega)$的最小实部（单位为欧姆，四舍五入到六位小数）和最坏情况归一化均方根误差（四舍五入到六位小数）。也就是说，输出必须是\n“[minRe1,err1,minRe2,err2,minRe3,err3]”，每个数字格式化为小数点后六位，无空格。所有阻抗值单位为欧姆，所有误差为无量纲小数。", "solution": "该问题被评估为有效。其科学基础在于线性时不变（LTI）系统理论和计算电磁学的原理，特别是关于多端口网络的宏模型建立和无源性强制。该问题是适定的，提供了一个清晰的目标函数和约束，定义了一个可解的凸优化问题（一个正则化非负最小二乘问题）。所有必要的参数、函数和评估指标都得到了明确和客观的定义，构成了一个自成体系且逻辑一致的任务。\n\n问题的核心是通过扰动其参数来强制有理阻抗模型 $\\hat{Z}(s)$ 的无源性，同时保持对时域数据的良好拟合。该模型由下式给出\n$$\n\\hat{Z}(s) = d + \\sum_{k=1}^{K} \\frac{r_k}{s - p_k}\n$$\n其中极点 $\\{p_k\\}$ 是固定的、实数的且为负 ($p_k  0$)。无源性通过确保模型是正实（PR）的来强制，其充分条件是阻抗的实部在虚轴上非负，即对于所有实数 $\\omega$，$\\Re\\{\\hat{Z}(j\\omega)\\} \\ge 0$。当 $s=j\\omega$ 时，实部为\n$$\n\\Re\\{\\hat{Z}(j\\omega)\\} = \\Re\\{d\\} + \\sum_{k=1}^{K} \\Re\\left\\{\\frac{r_k}{j\\omega - p_k}\\right\\}\n$$\n由于参数 $r_k$ 和 $d$ 是实数，这变为\n$$\n\\Re\\{\\hat{Z}(j\\omega)\\} = d + \\sum_{k=1}^{K} \\frac{r_k(-p_k)}{p_k^2 + \\omega^2}\n$$\n由于 $p_k  0$，项 $-p_k$ 是正的。因此，强制模型参数的非负性，$r_k \\ge 0$ 对所有 $k$ 和 $d \\ge 0$，是保证对于所有 $\\omega$，$\\Re\\{\\hat{Z}(j\\omega)\\} \\ge 0$ 的充分条件。\n\n电压 $v(t)$ 和电流 $i(t)$ 之间的时域关系由 $\\hat{Z}(s) \\mathcal{L}\\{i(t)\\}$ 的拉普拉斯逆变换所蕴含的卷积积分给出。这导致：\n$$\nv(t) = d \\cdot i(t) + \\sum_{k=1}^{K} r_k \\int_0^t e^{p_k (t-\\tau)} i(\\tau) d\\tau\n$$\n当以时间步长 $\\Delta t$ 离散化时，其中 $t_n = n \\Delta t$，在时间 $t_n$ 的电压可以使用离散卷积（例如，通过对积分使用前向欧拉法）来近似：\n$$\nv(t_n) \\approx d \\cdot i(t_n) + \\sum_{k=1}^{K} r_k \\left( \\Delta t \\sum_{j=0}^{n} e^{p_k (t_n - t_j)} i(t_j) \\right)\n$$\n这种关系相对于未知参数 $\\mathbf{x} = [r_1, \\dots, r_K, d]^T$ 是线性的。对于单个激励电流信号 $\\mathbf{i} = [i(t_0), \\dots, i(t_{N-1})]^T$，相应的电压向量 $\\mathbf{v} = [v(t_0), \\dots, v(t_{N-1})]^T$ 可以表示为矩阵向量积 $\\mathbf{v} = \\mathbf{A_m} \\mathbf{x}$。$\\mathbf{A_m}$ 的列由离散化的卷积项和直流项构成。具体来说，对于 $k=1, \\dots, K$，第 $k$ 列是表示 $\\Delta t \\cdot (\\mathbf{h}_k * \\mathbf{i}_m)$ 的向量，其中 $\\mathbf{h}_k$ 是离散脉冲响应 $[e^{p_k \\cdot 0 \\cdot \\Delta t}, e^{p_k \\cdot 1 \\cdot \\Delta t}, \\dots]^T$，* 表示离散卷积。第 $(K+1)$ 列就是电流向量 $\\mathbf{i}_m$。\n\n对于 $M$ 个不同的激励，系统矩阵和电压向量被垂直堆叠以形成一个更大的线性系统：\n$$\n\\begin{pmatrix} \\mathbf{v}_1 \\\\ \\vdots \\\\ \\mathbf{v}_M \\end{pmatrix} = \\begin{pmatrix} \\mathbf{A}_1 \\\\ \\vdots \\\\ \\mathbf{A}_M \\end{pmatrix} \\mathbf{x} \\quad \\implies \\quad \\mathbf{v}_\\text{stacked} = \\mathbf{A} \\mathbf{x}\n$$\n其中 $\\mathbf{A} \\in \\mathbb{R}^{(MN)\\times(K+1)}$。“测量”数据 $\\mathbf{v}_\\text{meas}$ 是使用这个方程和提供的“真实”参数 $\\mathbf{x}_\\text{true}$ 合成的。\n\n目标是找到一个无源参数集 $\\mathbf{x}$，它接近一个初始的（可能非无源的）拟合 $\\mathbf{x}_0$，并且也拟合测量数据 $\\mathbf{v}_\\text{meas}$。这被表述为一个正则化约束最小二乘问题：\n$$\n\\min_{\\mathbf{x}\\ge \\mathbf{0}} \\left\\|\\mathbf{A}\\mathbf{x} - \\mathbf{v}_\\text{meas}\\right\\|_2^2 \\;+\\; \\alpha \\left\\|\\mathbf{x} - \\mathbf{x}_0\\right\\|_2^2\n$$\n项 $\\alpha \\left\\|\\mathbf{x} - \\mathbf{x}_0\\right\\|_2^2$ 是一个吉洪诺夫（Tikhonov）正则化项，它惩罚与初始拟合 $\\mathbf{x}_0$ 的大偏差。约束 $\\mathbf{x} \\ge \\mathbf{0}$ 确保 $r_k \\ge 0$ 和 $d \\ge 0$，从而保证无源性。这个问题可以通过增广系统矩阵和向量，转化为一个标准的非负最小二乘（NNLS）问题：\n$$\n\\min_{\\mathbf{x} \\ge \\mathbf{0}} \\left\\| \\begin{pmatrix} \\mathbf{A} \\\\ \\sqrt{\\alpha} \\mathbf{I} \\end{pmatrix} \\mathbf{x} - \\begin{pmatrix} \\mathbf{v}_\\text{meas} \\\\ \\sqrt{\\alpha} \\mathbf{x}_0 \\end{pmatrix} \\right\\|_2^2\n$$\n其中 $\\mathbf{I}$ 是尺寸为 $(K+1)\\times(K+1)$ 的单位矩阵。这种形式很容易使用数值库（如 `scipy.optimize.lsq_linear`）来求解。\n\n在求解强制参数 $\\mathbf{x}_\\text{enf}$ 后，执行两个验证步骤：\n1.  **无源性检查**：在指定的频率网格 $\\omega_\\ell \\in [0, \\omega_\\text{max}]$ 上计算阻抗实部的最小值 $\\min_{\\ell}\\,\\Re\\{\\hat{Z}(j\\omega_\\ell)\\}$。由于 $\\Re\\{\\hat{Z}(j\\omega)\\}$ 中求和的每一项都是 $|\\omega|$ 的单调递减函数，因此在网格 $[0, \\omega_\\text{max}]$ 上的最小值将出现在 $\\omega_\\text{max}$ 处。\n2.  **误差计算**：为每个激励计算归一化均方根（RMS）误差，以量化无源性强制模型的时域响应与“测量”数据的偏差。报告最坏情况误差 $\\max_m \\epsilon_m$。公式为：\n    $$\n    \\epsilon_m = \\frac{\\text{RMS}(v_m^\\text{enf} - v_m^\\text{meas})}{\\text{RMS}(v_m^\\text{meas})} = \\frac{\\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}\\left(v_m^\\text{enf}(t_n)-v_m^\\text{meas}(t_n)\\right)^2}}{\\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}\\left(v_m^\\text{meas}(t_n)\\right)^2}} = \\frac{\\left\\| \\mathbf{v}_m^\\text{enf} - \\mathbf{v}_m^\\text{meas} \\right\\|_2}{\\left\\| \\mathbf{v}_m^\\text{meas} \\right\\|_2}\n    $$\n接下来的实现遵循了为每个给定测试用例设定的这些步骤。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import lsq_linear\n\ndef setup_system(poles, excitations, dt, N):\n    \"\"\"\n    Constructs the system matrix A for the given model and excitations.\n    \"\"\"\n    K = len(poles)\n    M = len(excitations)\n    \n    A = np.zeros((M * N, K + 1))\n    t = np.arange(N) * dt\n    \n    for k, p_k in enumerate(poles):\n        h_k = np.exp(p_k * t)\n        for m, i_m in enumerate(excitations):\n            # Discrete convolution: v(t) = integral(h(t-tau)i(tau)d(tau))\n            # Approximated by sum: v[n] = sum(h[n-j]i[j]) * dt\n            # np.convolve implements the sum part.\n            conv_res = np.convolve(i_m, h_k, mode='full')[:N] * dt\n            A[m * N:(m + 1) * N, k] = conv_res\n\n    # Direct term column\n    for m, i_m in enumerate(excitations):\n        A[m * N:(m + 1) * N, K] = i_m\n        \n    return A\n\ndef solve_case(case_params):\n    \"\"\"\n    Solves a single test case for passivity enforcement.\n    \"\"\"\n    poles = np.array(case_params['poles'])\n    x_true = np.array(case_params['true_params'])\n    x0 = np.array(case_params['initial_fit'])\n    dt = case_params['dt']\n    N = case_params['N']\n    alpha = case_params['alpha']\n    N_omega = case_params['N_omega']\n    omega_max = case_params['omega_max']\n    \n    K = len(poles)\n    \n    # Generate time vector and excitations\n    t = np.arange(N) * dt\n    excitations = []\n    if 'excitations_def' in case_params:\n        for i_def in case_params['excitations_def']:\n            excitations.append(i_def(t))\n    \n    # 1. Construct the discrete-time convolution matrix A\n    A = setup_system(poles, excitations, dt, N)\n    \n    # 2. Generate the measured stacked voltage vector v_meas\n    v_meas = A @ x_true\n    \n    # 3. Solve the regularized constrained least-squares problem\n    A_aug = np.vstack([A, np.sqrt(alpha) * np.eye(K + 1)])\n    b_aug = np.hstack([v_meas, np.sqrt(alpha) * x0])\n    \n    # Bounds for x = 0\n    bounds = (0, np.inf)\n    res = lsq_linear(A_aug, b_aug, bounds=bounds)\n    x_enf = res.x\n    \n    v_enf = A @ x_enf\n    \n    r_enf = x_enf[:-1]\n    d_enf = x_enf[-1]\n    \n    # 4. Check passivity on a frequency grid\n    omega_grid = np.linspace(0, omega_max, N_omega)\n    \n    # The minimum real part over omega = 0 occurs at the largest omega.\n    omega_val = omega_max\n    real_parts = d_enf + np.sum(r_enf[:, np.newaxis] * (-poles[:, np.newaxis]) / (omega_val**2 + poles[:, np.newaxis]**2), axis=0)\n    min_re_z = float(real_parts)\n    \n    # 5. Compute the worst-case normalized RMS time-domain voltage error\n    max_err = 0.0\n    M = len(excitations)\n    \n    v_meas_reshaped = v_meas.reshape(M, N)\n    v_enf_reshaped = v_enf.reshape(M, N)\n    \n    for m in range(M):\n        v_m_meas = v_meas_reshaped[m, :]\n        v_m_enf = v_enf_reshaped[m, :]\n        \n        norm_v_meas = np.linalg.norm(v_m_meas)\n        if norm_v_meas == 0:\n            # Avoid division by zero if a signal is identically zero\n            err_m = np.linalg.norm(v_m_enf - v_m_meas)\n        else:\n            err_m = np.linalg.norm(v_m_enf - v_m_meas) / norm_v_meas\n            \n        if err_m  max_err:\n            max_err = err_m\n            \n    return min_re_z, max_err\n\ndef solve():\n    test_cases = [\n        {\n            \"name\": \"Case 1 (happy path)\",\n            \"poles\": [-2e6, -2e5, -2e4],\n            \"true_params\": [0.4, 0.2, 0.1, 0.5],\n            \"initial_fit\": [0.38, -0.06, 0.12, 0.48],\n            \"dt\": 1e-6, \"N\": 4096,\n            \"excitations_def\": [\n                lambda t: np.exp(-(t - 1e-3)**2 / (2 * (2e-4)**2)),\n                lambda t: 0.6 * np.sin(2 * np.pi * 1e3 * t) + 0.4 * np.sin(2 * np.pi * 5e3 * t) + 0.2 * np.sin(2 * np.pi * 3e4 * t)\n            ],\n            \"alpha\": 1e-4,\n            \"N_omega\": 2000, \"omega_max\": 10 * 2e6,\n        },\n        {\n            \"name\": \"Case 2 (already passive)\",\n            \"poles\": [-2e6, -2e5, -2e4],\n            \"true_params\": [0.35, 0.15, 0.05, 0.3],\n            \"initial_fit\": [0.36, 0.14, 0.06, 0.31],\n            \"dt\": 1e-6, \"N\": 4096,\n            \"excitations_def\": [\n                lambda t: np.exp(-(t - 1e-3)**2 / (2 * (2e-4)**2)),\n                lambda t: 0.6 * np.sin(2 * np.pi * 1e3 * t) + 0.4 * np.sin(2 * np.pi * 5e3 * t) + 0.2 * np.sin(2 * np.pi * 3e4 * t)\n            ],\n            \"alpha\": 1e-4,\n            \"N_omega\": 2000, \"omega_max\": 10 * 2e6,\n        },\n        {\n            \"name\": \"Case 3 (edge, fast pole under coarse sampling)\",\n            \"poles\": [-1e7, -1e5],\n            \"true_params\": [0.02, 0.25, 0.1],\n            \"initial_fit\": [-0.01, 0.27, 0.09],\n            \"dt\": 1e-6, \"N\": 2048,\n            \"excitations_def\": [\n                lambda t: np.exp(-(t - 5e-4)**2 / (2 * (1e-4)**2)),\n                lambda t: 0.7 * np.sin(2 * np.pi * 8e4 * t) + 0.3 * np.sin(2 * np.pi * 1.5e5 * t)\n            ],\n            \"alpha\": 1e-3,\n            \"N_omega\": 2000, \"omega_max\": 10 * 1e7,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        min_re, max_err = solve_case(case)\n        results.append(f\"{min_re:.6f}\")\n        results.append(f\"{max_err:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3342298"}]}