{"hands_on_practices": [{"introduction": "本练习将引导你亲手推导一阶Mur吸收边界条件（ABC），这是一种在FDTD仿真中截断计算区域的经典方法。通过从一维波动方程出发，并分析其对斜入射波的反射系数，你将对局部吸收边界条件的工作原理及其内在局限性 [@problem_id:3353919] 建立起基本的理解。这一分析对于领会为何需要更复杂的边界处理技术（如完美匹配层）至关重要。", "problem": "在 Yee 网格上使用三维时域有限差分 (FDTD) 方法模拟自由空间中以光速 $c$ 传播的电磁波。计算域的一个平面由一个吸收边界界定，该边界旨在最小化反射。考虑一个平面边界上的单个切向电场分量 $E_{t}(x,y,z,t)$，该边界的外法线方向沿着 $+x$ 方向。空间步长为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$，时间步长为 $\\Delta t$，其选择满足 Courant-Friedrichs-Lewy (CFL) 稳定性条件。\n\n(a) 从自由空间中该边界附近 $E_{t}(x,t)$ 的一维无损波动方程出发，将其分解为单向波动方程，并仅保留对应于穿过边界离开计算域的出射波分量，推导出一阶局部吸收边界条件 (ABC)，该条件表示为边界上 $E_t$ 的时间导数和法向空间导数之间的一阶关系。然后，在法线方向上使用与 Yee 交错网格一致的一阶精度单边有限差分和向前时间步进，推导关联邻近边界平面的前两个网格点上采样值的显式边界更新。用 Courant 数 $S_{x} = c \\Delta t / \\Delta x$ 表示你的结果。\n\n(b) 通过对边界平面上的每一对切向索引 $(j,k)$ 逐点应用相同的一维更新，将在 (a) 部分得到的结果推广到完整的三维边界表面。在法线方向上使用单边差分，并为切向电场分量保留 Yee 交错网格结构。\n\n(c) 现在考虑一个角频率为 $\\omega$ 的时谐平面波，在自由空间中从计算域内部以相对于边界法线（$x$ 轴）的极角 $\\theta$ 和任意方位角入射到边界平面上。在连续平面近似下，场局部具有形式 $\\exp\\!\\big(i(k_{x} x + k_{y} y + k_{z} z - \\omega t)\\big)$，其中 $k = \\omega/c$。将 (a) 部分推导的一阶 ABC 应用于边界上入射波和反射波的叠加。求解作为 $\\theta$ 函数的复反射系数。\n\n请以单个闭式解析表达式的形式提供反射系数的模作为入射极角 $\\theta$ (以弧度为单位) 的函数，该表达式不含其他变量或参数。不要进行任何数值四舍五入。", "solution": "该问题被评估为有效，因为它在计算电磁学方面具有科学依据，提法恰当且客观。它提出了一个关于时域有限差分方法吸收边界条件推导和分析的标准多部分练习。该问题是自洽的，并为得出唯一解提供了清晰的路径。\n\n(a) 一阶吸收边界条件及其离散化的推导\n\n我们从自由空间中传播的切向电场分量 $E_t(x,t)$ 的一维无损波动方程开始：\n$$ \\frac{\\partial^2 E_t}{\\partial x^2} - \\frac{1}{c^2} \\frac{\\partial^2 E_t}{\\partial t^2} = 0 $$\n其中 $c$ 是光速。该微分算子可以分解为：\n$$ \\left( \\frac{\\partial}{\\partial x} - \\frac{1}{c} \\frac{\\partial}{\\partial t} \\right) \\left( \\frac{\\partial}{\\partial x} + \\frac{1}{c} \\frac{\\partial}{\\partial t} \\right) E_t = 0 $$\n这种分解将波动方程分为两个一阶单向波动方程。项 $\\left( \\frac{\\partial}{\\partial x} + \\frac{1}{c} \\frac{\\partial}{\\partial t} \\right) E_t = 0$ 对应于形式为 $f(x-ct)$ 的波，其在 $+x$ 方向传播。项 $\\left( \\frac{\\partial}{\\partial x} - \\frac{1}{c} \\frac{\\partial}{\\partial t} \\right) E_t = 0$ 对应于形式为 $g(x+ct)$ 的波，其在 $-x$ 方向传播。\n\n计算域由一个外法线在 $+x$ 方向的边界平面终止。为了吸收离开计算域的波，我们必须防止反射。理想的吸收边界条件 (ABC) 应对出射波是透明的。出射波是在 $+x$ 方向传播的波。因此，我们强制要求边界上的场必须满足纯出射波的单向波动方程：\n$$ \\frac{\\partial E_t}{\\partial x} + \\frac{1}{c} \\frac{\\partial E_t}{\\partial t} = 0 $$\n这就是一阶局部吸收边界条件。\n\n为了推导显式更新规则，我们在 FDTD 网格上离散化该方程。设 $x$ 方向的网格点用 $i$ 索引，使得 $x = i \\Delta x$。设离散时间步用 $n$ 索引，使得 $t = n \\Delta t$。切向场分量记为 $E_t(i\\Delta x, n\\Delta t) \\equiv E_t^n[i]$。设边界位于网格索引 $i=I_{max}$ 处。我们需要找到该边界点在下一个时间步的值 $E_t^{n+1}[I_{max}]$。\n\n我们按照规定，使用一阶精度的有限差分来近似导数。我们对时间导数使用向前差分，对空间导数使用单边向后差分，两者都在边界位置 $(x=I_{max}\\Delta x, t=n\\Delta t)$ 处进行计算：\n$$ \\frac{\\partial E_t}{\\partial t} \\approx \\frac{E_t^{n+1}[I_{max}] - E_t^n[I_{max}]}{\\Delta t} $$\n$$ \\frac{\\partial E_t}{\\partial x} \\approx \\frac{E_t^n[I_{max}] - E_t^n[I_{max}-1]}{\\Delta x} $$\n将这些近似值代入 ABC，得到：\n$$ \\frac{E_t^n[I_{max}] - E_t^n[I_{max}-1]}{\\Delta x} + \\frac{1}{c} \\left( \\frac{E_t^{n+1}[I_{max}] - E_t^n[I_{max}]}{\\Delta t} \\right) = 0 $$\n该格式是显式的，因为空间导数是在时间步 $n$ 处计算的，此时所有场值都是已知的。求解 $E_t^{n+1}[I_{max}]$：\n$$ \\frac{E_t^{n+1}[I_{max}] - E_t^n[I_{max}]}{\\Delta t} = -c \\frac{E_t^n[I_{max}] - E_t^n[I_{max}-1]}{\\Delta x} $$\n$$ E_t^{n+1}[I_{max}] = E_t^n[I_{max}] - \\frac{c \\Delta t}{\\Delta x} \\left( E_t^n[I_{max}] - E_t^n[I_{max}-1] \\right) $$\n使用 $x$ 方向的 Courant 数定义 $S_x = c \\Delta t / \\Delta x$，更新方程变为：\n$$ E_t^{n+1}[I_{max}] = E_t^n[I_{max}] - S_x \\left( E_t^n[I_{max}] - E_t^n[I_{max}-1] \\right) $$\n这可以重写为：\n$$ E_t^{n+1}[I_{max}] = (1 - S_x) E_t^n[I_{max}] + S_x E_t^n[I_{max}-1] $$\n这个显式更新规则使用当前时间步 $n$ 在边界点 $I_{max}$ 和相邻的内部点 $I_{max}-1$ 处的场值，来计算未来时间步 $n+1$ 在边界网格点 $I_{max}$ 处的场值。\n\n(b) 推广到三维\n\n将这个一维 ABC 推广到三维边界表面，是通过在边界平面上的每个点独立应用相同的更新规则来实现的。诸如 $E_y$ 和 $E_z$ 等切向电场分量位于由 $x = I_{max}\\Delta x$ 定义的 $y$-$z$ 平面上的离散点 $(j,k)$ 处。该更新规则对每个切向位置逐点应用。\n设离散切向场记为 $E_t^n[i, j, k]$。对于 $i=I_{max}$ 处的边界，更新规则是：\n$$ E_t^{n+1}[I_{max}, j, k] = (1 - S_x) E_t^n[I_{max}, j, k] + S_x E_t^n[I_{max}-1, j, k] $$\n该方程应用于边界平面上所有相关的索引 $j$ 和 $k$，并应用于该平面上定义的每个切向场分量（$E_y$ 和 $E_z$），同时遵循 Yee 网格的空间交错结构。\n\n(c) 反射系数分析\n\n为分析边界条件的性能，我们将 (a) 部分的 ABC 连续形式应用于时谐平面波。为便于分析，设边界位于平面 $x=0$，计算域在区域 $x0$ 内。ABC 为：\n$$ \\left. \\left( \\frac{\\partial E_t}{\\partial x} + \\frac{1}{c} \\frac{\\partial E_t}{\\partial t} \\right) \\right|_{x=0} = 0 $$\n一个角频率为 $\\omega$ 的平面波从域内 ($x0$) 入射到边界上。波矢量 $\\mathbf{k}$ 的模为 $k = \\omega/c$。入射极角 $\\theta$ 是 $\\mathbf{k}$ 与边界法线（$x$ 轴）之间的夹角。波矢量的分量为 $k_x = k \\cos\\theta$，$k_y = k \\sin\\theta \\cos\\phi$ 和 $k_z = k \\sin\\theta \\sin\\phi$，其中 $\\phi$ 是方位角。分析与 $\\phi$ 无关。朝向正 $x$ 方向传播的入射波为：\n$$ E_{inc} = E_0 \\exp\\big(i(k_x x + k_y y + k_z z - \\omega t)\\big) $$\n该波在边界处被部分反射。反射波传播回域内（负 $x$ 方向）。根据边界处的相位匹配条件，反射波具有相同的频率 $\\omega$ 和切向波矢量分量 $k_y, k_z$。其法向波矢量分量必须是 $k'_x = -k_x = -k\\cos\\theta$。设 $R$ 为复反射系数。反射波为：\n$$ E_{refl} = R E_0 \\exp\\big(i(-k_x x + k_y y + k_z z - \\omega t)\\big) $$\n总场 $E_t$ 是入射场和反射场的叠加：\n$$ E_t(x,y,z,t) = E_0 \\left( \\exp(ik_x x) + R \\exp(-ik_x x) \\right) \\exp\\big(i(k_y y + k_z z - \\omega t)\\big) $$\n我们现在计算 ABC 所需的导数。\n$$ \\frac{\\partial E_t}{\\partial x} = E_0 \\left( ik_x \\exp(ik_x x) - ik_x R \\exp(-ik_x x) \\right) \\exp\\big(i(k_y y + k_z z - \\omega t)\\big) $$\n$$ \\frac{\\partial E_t}{\\partial t} = E_0 \\left( \\exp(ik_x x) + R \\exp(-ik_x x) \\right) (-i\\omega) \\exp\\big(i(k_y y + k_z z - \\omega t)\\big) $$\n在边界 $x=0$ 处计算这些导数并代入 ABC：\n$$ ik_x E_0 (1-R) + \\frac{1}{c} \\left( -i\\omega E_0 (1+R) \\right) = 0 $$\n假设 $E_0 \\neq 0$ 且 $\\omega \\neq 0$，我们可以消去公因子 $iE_0$：\n$$ k_x (1-R) - \\frac{\\omega}{c} (1+R) = 0 $$\n代入 $k_x = k \\cos\\theta$ 和 $k = \\omega/c$：\n$$ k \\cos\\theta (1-R) - k (1+R) = 0 $$\n$$ \\cos\\theta (1-R) - (1+R) = 0 $$\n现在，我们求解反射系数 $R$：\n$$ \\cos\\theta - R \\cos\\theta - 1 - R = 0 $$\n$$ \\cos\\theta - 1 = R(1 + \\cos\\theta) $$\n$$ R(\\theta) = \\frac{\\cos\\theta - 1}{\\cos\\theta + 1} $$\n问题要求反射系数的模 $|R|$。由于入射角 $\\theta$ 在范围 $[0, \\pi/2)$ 内，$\\cos\\theta$ 是一个实数，满足 $0  \\cos\\theta \\le 1$。因此，$R$ 是实数。分子 $\\cos\\theta - 1$ 是非正的，分母 $\\cos\\theta + 1$ 是正的。所以，模为：\n$$ |R(\\theta)| = \\left| \\frac{\\cos\\theta - 1}{\\cos\\theta + 1} \\right| = \\frac{-(\\cos\\theta - 1)}{\\cos\\theta + 1} = \\frac{1 - \\cos\\theta}{1 + \\cos\\theta} $$\n使用三角半角恒等式 $1 - \\cos\\theta = 2 \\sin^2(\\theta/2)$ 和 $1 + \\cos\\theta = 2 \\cos^2(\\theta/2)$，这可以简化为：\n$$ |R(\\theta)| = \\frac{2\\sin^2(\\theta/2)}{2\\cos^2(\\theta/2)} = \\tan^2\\left(\\frac{\\theta}{2}\\right) $$\n此表达式给出了反射系数的模，纯粹作为入射角 $\\theta$ 的函数。", "answer": "$$\\boxed{\\frac{1 - \\cos\\theta}{1 + \\cos\\theta}}$$", "id": "3353919"}, {"introduction": "在了解了简单局部吸收边界条件的局限性之后，本实践将探索当前最先进的解决方案：卷积完美匹配层（CPML）。这个练习的重点从简单的分析转向了实际的设计与优化。你将研究如何配置CPML——通过其复坐标拉伸因子和渐变电导率剖面——以实现最小的反射，即使在掠入射等具有挑战性的情况下也能如此 [@problem_id:3353921]。掌握这一点是建立高保真度FDTD仿真的关键。", "problem": "考虑一个角频率为 $\\omega$ 的二维平面波，在介电常数为 $\\epsilon = \\epsilon_0 \\epsilon_r$、磁导率为 $\\mu = \\mu_0$ 的均匀、各向同性、无损耗介质中传播。该波入射到一个占据半空间 $x \\ge 0$ 的单轴复数拉伸吸收层（卷积完美匹配层 (CPML)）。位于 $x = 0$ 的界面是匹配的，CPML 延伸至位于 $x = d$ 的理想电导体 (PEC) 终端。波矢量与外法线 $\\hat{\\mathbf{x}}$ 成 $\\theta$ 角，其中 $\\theta \\in [0^\\circ, 90^\\circ)$，我们关注掠入射状态，即 $\\theta \\to 90^\\circ$。\n\n在 CPML 内部，沿 $x$ 方向实现一个复坐标拉伸，由标量拉伸因子给出\n$$\ns_x(x,\\omega) = 1 + \\frac{\\tilde{\\sigma}(x)}{\\alpha + j \\omega},\n$$\n其中 $j^2 = -1$，$\\tilde{\\sigma}(x)$ 是一个多项式分级的、非负的、归一化的电导率分布（单位为 $\\mathrm{s}^{-1}$），$\\alpha \\ge 0$ 是复频移参数（单位为 $\\mathrm{s}^{-1}$）。假设分级为\n$$\n\\tilde{\\sigma}(x) = \\tilde{\\sigma}_{\\max} \\left(\\frac{x}{d}\\right)^m,\\quad x \\in [0,d],\\quad m \\in \\{1,2,3,\\dots\\},\n$$\n且对于 $x  0$，$\\tilde{\\sigma}(x) = 0$。其他方向的拉伸和 $\\kappa$ 参数取为 $1$（即无 $\\kappa$ 分级），切向场分量在 $x=0$ 处是连续的。\n\n从无源频域麦克斯韦旋度方程和完美匹配层的复坐标拉伸解释出发，完成以下任务：\n\n1) 在绝热变化的拉伸和 $x=0$ 处理想匹配的假设下，推导仅由有限 CPML 厚度和 $x=d$ 处的 PEC 终端引起的 $x=0$ 处反射系数模的领头阶表达式。证明对于以角度 $\\theta$ 入射的平面波，其模满足指数形式\n$$\n|R| \\approx \\exp\\left(-2 k_n \\int_0^d \\left[-\\operatorname{Im}\\{s_x(x,\\omega)\\}\\right] \\, dx\\right),\n$$\n其中 $k_n = k \\cos\\theta$ 且 $k = \\omega \\sqrt{\\mu_0 \\epsilon_0 \\epsilon_r}$。\n\n2) 使用给定的 $s_x(x,\\omega)$ 和 $\\tilde{\\sigma}(x)$ 的多项式分布，显式计算积分，以获得 $|R|$ 关于 $\\omega$、$\\epsilon_r$、$\\alpha$、$\\tilde{\\sigma}_{\\max}$、$d$、$\\theta$ 和 $m$ 的闭式表达式。然后，在固定的 $\\tilde{\\sigma}_{\\max}$、$d$ 和 $\\theta \\to 90^\\circ$ 条件下，提取 $|R|$ 相对于多项式阶数 $m$ 的渐近标度关系。\n\n3) 设 CPML 厚度在间距为 $\\Delta$ 的均匀 Yee 网格上离散化，使得 $d = N \\Delta$，其中 $N \\ge 1$ 为整数单元数。对最大归一化电导率施加一个实际实现约束 $\\tilde{\\sigma}_{\\max} = \\lambda \\,\\omega$，其中 $\\lambda > 0$ 是一个给定的无量纲界限，并允许整数阶数 $m \\in \\{1,2,3,4,5,6\\}$。对于下面的每个测试用例，选择整数 $(m,N)$（其中 $1 \\le m \\le 6$ 且 $1 \\le N \\le N_{\\max}$）以最小化所推导的 $|R|$。\n\n4) 角度 $\\theta$ 以度为单位指定。所有其他物理量必须用国际单位制（SI units）表示。程序的输出必须是无单位的实数。\n\n测试套件。使用以下独立的参数集；在每种情况下，在所述约束下最小化 $|R|$ 的闭式表达式，并将最小化的 $|R|$ 报告为浮点数：\n\n- 情况 A（掠入射，中等复频移）：$\\{ f = 3.0\\times 10^9\\ \\mathrm{Hz},\\ \\epsilon_r = 1.0,\\ \\theta = 89.9^\\circ,\\ \\alpha = 0.05\\,\\omega,\\ \\lambda = 5.0,\\ \\Delta = 1.0\\times 10^{-3}\\ \\mathrm{m},\\ N_{\\max} = 20 \\}$。\n\n- 情况 B（掠入射，无复频移，较高折射率）：$\\{ f = 1.0\\times 10^{10}\\ \\mathrm{Hz},\\ \\epsilon_r = 2.25,\\ \\theta = 89.0^\\circ,\\ \\alpha = 0.0,\\ \\lambda = 3.0,\\ \\Delta = 5.0\\times 10^{-4}\\ \\mathrm{m},\\ N_{\\max} = 30 \\}$。\n\n- 情况 C（垂直入射基准）：$\\{ f = 3.0\\times 10^9\\ \\mathrm{Hz},\\ \\epsilon_r = 1.0,\\ \\theta = 0.0^\\circ,\\ \\alpha = 0.10\\,\\omega,\\ \\lambda = 5.0,\\ \\Delta = 1.0\\times 10^{-3}\\ \\mathrm{m},\\ N_{\\max} = 20 \\}$。\n\n这里 $\\omega = 2\\pi f$。磁常数是 $\\mu_0 = 4\\pi \\times 10^{-7}\\ \\mathrm{H/m}$，电常数是 $\\epsilon_0 \\approx 8.854187817\\times 10^{-12}\\ \\mathrm{F/m}$。\n\n输出规范。您的程序应生成单行输出，其中包含三个情况的最小化反射模值，形式为用方括号括起来的逗号分隔列表（例如，“[rA,rB,rC]”）。每个条目必须是浮点数。\n\n注：\n\n- 您必须使用任务 2 中推导出的闭式表达式，而不是数值场求解器。\n- 确保在输入规范中角度 $\\theta$ 被解释为度，并在内部转换为弧度。\n- 最终的数值答案是无量纲的浮点数。", "solution": "我们从均匀、各向同性介质的无源频域麦克斯韦旋度方程开始：\n$$\n\\nabla \\times \\mathbf{E} = -j \\omega \\mu \\mathbf{H}, \\quad \\nabla \\times \\mathbf{H} = j \\omega \\epsilon \\mathbf{E}.\n$$\n完美匹配层 (PML) 可以通过复坐标拉伸来建模，该拉伸将空间导数变换为\n$$\n\\frac{\\partial}{\\partial x} \\to \\frac{1}{s_x(x,\\omega)} \\frac{\\partial}{\\partial x},\n$$\n其中\n$$\ns_x(x,\\omega) = 1 + \\frac{\\tilde{\\sigma}(x)}{\\alpha + j \\omega},\n$$\n其中 $\\tilde{\\sigma}(x)$ 是一个非负归一化电导率分布（单位 $\\mathrm{s}^{-1}$），$\\alpha \\ge 0$ 是一个复频移（单位 $\\mathrm{s}^{-1}$）。我们考虑 $s_y = s_z = 1$ 和 $\\kappa = 1$ 以分离出 $x$ 方向的拉伸。对于波数为 $k = \\omega \\sqrt{\\mu_0 \\epsilon_0 \\epsilon_r}$、与外法线 $\\hat{\\mathbf{x}}$ 成 $\\theta$ 角的平面波，波矢量的法向分量为 $k_n = k \\cos\\theta$。\n\n在绝热近似下，其中 $s_x$ 相对于波长变化缓慢，并且 $x=0$ 处的界面是匹配的（通过 $s_x(0,\\omega) = 1$ 以确保 $\\tilde{\\sigma}(0) = 0$），PML 内部沿 $x$ 的场分量依赖关系可近似为拉伸坐标的指数：\n$$\n\\exp\\left(-j \\int_0^x k_n s_x(\\xi,\\omega)\\, d\\xi \\right).\n$$\n因此，振幅随着 $s_x$ 负虚部的积分而衰减：\n$$\n\\left| \\exp\\left(-j \\int_0^x k_n s_x(\\xi,\\omega)\\, d\\xi \\right) \\right| = \\exp\\left( - k_n \\int_0^x \\left[ - \\operatorname{Im}\\{s_x(\\xi,\\omega)\\} \\right] d\\xi \\right).\n$$\n因为 CPML 在 $x=d$ 处由理想电导体 (PEC) 边界终止，波在 $x=d$ 处以单位幅度反射并传播回 $x=0$，在返回过程中产生相同的振幅衰减因子。因此，由于有限厚度，在 $x=0$ 处的反射模值为\n$$\n|R| \\approx \\exp\\left( - 2 k_n \\int_0^d \\left[ - \\operatorname{Im}\\{s_x(x,\\omega)\\} \\right] dx \\right).\n$$\n这就完成了任务 1。\n\n现在我们计算这个积分。根据定义\n$$\ns_x(x,\\omega) = 1 + \\frac{\\tilde{\\sigma}(x)}{\\alpha + j \\omega} = 1 + \\tilde{\\sigma}(x)\\, \\frac{\\alpha - j \\omega}{\\alpha^2 + \\omega^2},\n$$\n所以\n$$\n\\operatorname{Im}\\{s_x(x,\\omega)\\} = - \\tilde{\\sigma}(x)\\, \\frac{\\omega}{\\alpha^2 + \\omega^2},\n$$\n因此\n$$\n- \\operatorname{Im}\\{s_x(x,\\omega)\\} = \\tilde{\\sigma}(x)\\, \\frac{\\omega}{\\alpha^2 + \\omega^2}.\n$$\n采用多项式分级\n$$\n\\tilde{\\sigma}(x) = \\tilde{\\sigma}_{\\max} \\left( \\frac{x}{d} \\right)^m, \\quad x \\in [0,d], \\quad m \\in \\{1,2,3,\\dots\\},\n$$\n积分计算结果为\n$$\n\\int_0^d \\left[ - \\operatorname{Im}\\{s_x(x,\\omega)\\} \\right] dx = \\frac{\\omega}{\\alpha^2 + \\omega^2} \\int_0^d \\tilde{\\sigma}_{\\max} \\left(\\frac{x}{d}\\right)^m dx = \\frac{\\omega}{\\alpha^2 + \\omega^2} \\cdot \\tilde{\\sigma}_{\\max} \\cdot \\frac{d}{m+1}.\n$$\n代入反射模值表达式，得到闭式形式\n$$\n|R| \\approx \\exp\\left( - 2 k \\cos\\theta \\cdot \\frac{\\omega}{\\alpha^2 + \\omega^2} \\cdot \\tilde{\\sigma}_{\\max} \\cdot \\frac{d}{m+1} \\right),\n$$\n其中 $k = \\omega \\sqrt{\\mu_0 \\epsilon_0 \\epsilon_r}$。这就完成了任务 2。因此，在固定的 $\\tilde{\\sigma}_{\\max}$ 和 $d$ 下，关于 $m$ 的渐近标度关系为\n$$\n|R(m)| \\asymp \\exp\\left( - \\frac{C}{m+1} \\right), \\quad C = 2 k \\cos\\theta \\cdot \\frac{\\omega}{\\alpha^2 + \\omega^2} \\cdot \\tilde{\\sigma}_{\\max} d,\n$$\n因此，特别地，对于掠入射 $\\theta \\to 90^\\circ$ 且 $\\cos\\theta \\ll 1$，我们有\n$$\n|R(m)| \\approx \\exp\\left( - \\frac{C_0 \\cos\\theta}{m+1} \\right), \\quad C_0 = 2 k \\cdot \\frac{\\omega}{\\alpha^2 + \\omega^2} \\cdot \\tilde{\\sigma}_{\\max} d.\n$$\n对小的 $\\cos\\theta$ 进行展开，得到\n$$\n|R(m)| \\approx 1 - \\frac{C_0 \\cos\\theta}{m+1} + \\mathcal{O}\\!\\left( \\frac{\\cos^2\\theta}{(m+1)^2} \\right),\n$$\n这显示了在掠入射下，渐近地与 $m+1$ 成反比关系。\n\n对于任务 3，将 CPML 厚度离散化为 $d = N \\Delta$，其中整数 $N \\ge 1$。施加实现约束 $\\tilde{\\sigma}_{\\max} = \\lambda \\omega$，其中 $\\lambda > 0$ 是给定的。那么反射模值变为函数\n$$\n|R|(m,N) = \\exp\\left( - 2 \\left[ \\omega \\sqrt{\\mu_0 \\epsilon_0 \\epsilon_r} \\right] \\cos\\theta \\cdot \\frac{\\omega}{\\alpha^2 + \\omega^2} \\cdot \\left[ \\lambda \\omega \\right] \\cdot \\frac{N \\Delta}{m+1} \\right).\n$$\n对于给定的参数 $(\\omega,\\epsilon_r,\\theta,\\alpha,\\lambda,\\Delta)$，在 $m \\in \\{1,2,3,4,5,6\\}$ 和 $N \\in \\{1,2,\\dots,N_{\\max}\\}$ 的约束下，函数 $|R|(m,N)$ 对 $N$ 是严格递减的，对 $m$ 是严格递增的（因为指数与 $N/(m+1)$ 成正比，且所有其他因子都是非负的）。因此，在 $N = N_{\\max}$ 和最小允许阶数 $m=1$ 时获得最小值。这种单调性以闭式形式确立了优化结果，而数值程序将执行显式的离散搜索以确保完整性。\n\n数值计算细节：\n\n- 将给定的频率 $f$ 转换为角频率 $\\omega = 2\\pi f$。\n- 计算 $k = \\omega \\sqrt{\\mu_0 \\epsilon_0 \\epsilon_r}$ 和 $k_n = k \\cos\\theta$，其中 $\\theta$ 从度转换为弧度。\n- 当 $\\alpha$ 被指定为 $\\omega$ 的一个分数时，通过关系 $\\alpha = \\alpha_{\\mathrm{ratio}} \\, \\omega$ 构成 $\\alpha$；当 $\\alpha = 0$ 时，这个选择是直接的。\n- 设置 $\\tilde{\\sigma}_{\\max} = \\lambda \\omega$ 和 $d = N \\Delta$。\n- 使用上述闭式表达式计算 $|R|(m,N)$，并在允许的整数范围内选择最小值。\n\n将此程序应用于三个测试用例，会产生三个浮点输出，分别对应每种情况下最小化的 $|R|$。最终程序按规定格式，将这三个值打印在单个用方括号括起的逗号分隔列表中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants (SI units)\nMU0 = 4.0e-7 * np.pi          # H/m\nEPS0 = 8.854187817e-12        # F/m\n\ndef reflection_magnitude(f_hz, eps_r, theta_deg, alpha_ratio, lam, delta, n_max):\n    \"\"\"\n    Compute the minimized reflection magnitude |R| for a CPML with:\n    - frequency f_hz (Hz)\n    - relative permittivity eps_r (dimensionless)\n    - incidence angle theta_deg (degrees)\n    - alpha = alpha_ratio * omega\n    - normalized sigma_max = lam * omega (dimensionless lam)\n    - grid spacing delta (m)\n    - maximum number of cells n_max (integer)\n    The minimization is over m in {1,...,6} and N in {1,...,n_max}.\n\n    Returns the minimal |R|.\n    \"\"\"\n    # Angular frequency and wavenumber\n    omega = 2.0 * np.pi * f_hz\n    k = omega * np.sqrt(MU0 * EPS0 * eps_r)\n\n    # Angle conversion\n    theta_rad = np.deg2rad(theta_deg)\n    cos_theta = np.cos(theta_rad)\n    # Numerical safety: clip cos_theta to nonnegative to avoid tiny negative due to rounding\n    if cos_theta  0.0:\n        cos_theta = 0.0\n\n    # CPML parameters\n    alpha = alpha_ratio * omega  # s^-1\n    sigma_tilde_max = lam * omega  # s^-1 (normalized conductivity)\n\n    # Precompute factor independent of m and N\n    # exponent_base multiplies N/(m+1)\n    denom = alpha * alpha + omega * omega\n    # If denom is zero (omega=alpha=0), reflection is 1 trivially; but omega>0 in our cases.\n    exponent_base = 2.0 * k * cos_theta * (omega / denom) * sigma_tilde_max * delta\n\n    best_R = 1.0\n    # Search over admissible m and N\n    for m in range(1, 7):\n        for N in range(1, n_max + 1):\n            exponent = exponent_base * (N / (m + 1.0))\n            # Reflection magnitude\n            R = float(np.exp(-exponent))\n            if R  best_R:\n                best_R = R\n    return best_R\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (f_hz, eps_r, theta_deg, alpha_ratio, lam, delta, n_max)\n    test_cases = [\n        (3.0e9, 1.0, 89.9, 0.05, 5.0, 1.0e-3, 20),   # Case A\n        (1.0e10, 2.25, 89.0, 0.0, 3.0, 5.0e-4, 30),  # Case B\n        (3.0e9, 1.0, 0.0, 0.10, 5.0, 1.0e-3, 20),    # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        f_hz, eps_r, theta_deg, alpha_ratio, lam, delta, n_max = case\n        rmin = reflection_magnitude(f_hz, eps_r, theta_deg, alpha_ratio, lam, delta, n_max)\n        # Format with scientific notation for consistency\n        results.append(\"{:.8e}\".format(rmin))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3353921"}, {"introduction": "一个精确的算法只是故事的一部分；高效的实现才是使大规模仿真成为可能的关键。本实践将深入探讨FDTD方法的高性能计算（HPC）方面，将算法的理论性质与现代硬件的实际情况联系起来 [@problem_id:3353975]。你将分析数值色散、浮点精度和GPU上的内存访问模式之间的权衡关系，从而对决定科学计算代码准确性和速度的各种因素建立起一个整体的认识。", "problem": "您需要设计、分析并实现一个计算实验，该实验将图形处理单元（GPU）在 Yee 有限差分时域（FDTD）内核中的合并内存访问与数值色散和浮点精度联系起来。您的任务是从基本电磁定律出发，在简化但科学上一致的模型下，对相位误差和内存效率做出具体的、可测试的预测。\n\n首先，从一维空间中线性、各向同性、均匀介质的无源宏观麦克斯韦方程组开始，其相对介电常数和相对磁导率均为1，使用无量纲单位，使得光速 $c = 1$：\n- $\\nabla \\times \\mathbf{E} = -\\dfrac{\\partial \\mathbf{H}}{\\partial t}$，\n- $\\nabla \\times \\mathbf{H} = \\dfrac{\\partial \\mathbf{E}}{\\partial t}$，\n- $\\nabla \\cdot \\mathbf{E} = 0$，\n- $\\nabla \\cdot \\mathbf{H} = 0$。\n\n使用一维空间中的 Yee 有限差分时域（FDTD）方案（Yee 方案），该方案采用交错网格，网格间距为 $\\Delta x$，时间步长为 $\\Delta t$，库朗数为 $S = c \\,\\Delta t / \\Delta x$。在无量纲化中，固定 $c = 1$ 和 $\\Delta x = 1$，因此 $S = \\Delta t$。推导 Yee 方案的离散色散关系，并按如下方式定义相位误差度量。对于波数为 $k$（无量纲化的 $k$）的平面波，定义连续角频率为 $\\omega_{\\mathrm{exact}}(k) = k$。从 Yee 更新中推导数值角频率 $\\omega_{\\mathrm{num}}(k, S)$。在传播时间 $T_{\\mathrm{prop}} = N_{\\mathrm{steps}} \\,\\Delta t$ 内，将色散引起的相位误差定义为 $\\phi_{\\mathrm{disp}}(k; S, N_{\\mathrm{steps}}) = \\left|\\left(\\omega_{\\mathrm{num}}(k, S) - \\omega_{\\mathrm{exact}}(k)\\right) T_{\\mathrm{prop}}\\right|$。对于波数带 $k \\in [k_{\\min}, k_{\\max}]$，将最坏情况下的色散误差定义为 $\\max_{k \\in [k_{\\min}, k_{\\max}]} \\phi_{\\mathrm{disp}}(k; S, N_{\\mathrm{steps}})$。\n\n接下来，为 Yee 更新构建一个浮点舍入误差预算。假设使用二进制浮点数，32位单精度的单位舍入为 $u_{32} = 2^{-24}$，64位双精度的单位舍入为 $u_{64} = 2^{-53}$。考虑两种计算模式：\n- 单精度：所有算术和存储均使用32位单精度。假设一个典型的一维 Yee 更新在每个时间步的每个空间位置引入 $r_{\\mathrm{single}} = 6$ 个单位舍入贡献，这些贡献在最坏情况下可以相干累加到相位误差中。\n- 混合精度：算术运算在64位双精度下进行，而存储在32位单精度下进行，因此只有存储操作会舍入到单精度。假设这在每个时间步的每个空间位置引入 $r_{\\mathrm{mixed}} = 2$ 个单位舍入贡献，这些贡献在最坏情况下可以相干累加到相位误差中。\n\n在最坏情况下的相干累积模型下，将 $N_{\\mathrm{steps}}$ 次 Yee 更新后的舍入引起的相位误差界定为 $\\phi_{\\mathrm{round}} \\le N_{\\mathrm{steps}} \\, r \\, u$，其中 $r$ 和 $u$ 根据计算模式选择。通过将色散和舍入界限相加，定义一个波数带上的总的最坏情况相位误差：$\\phi_{\\mathrm{total,wc}}([k_{\\min}, k_{\\max}]; S, N_{\\mathrm{steps}}, r, u) = \\max_{k \\in [k_{\\min}, k_{\\max}]} \\phi_{\\mathrm{disp}}(k; S, N_{\\mathrm{steps}}) + N_{\\mathrm{steps}} \\, r \\, u$。所有相位和相位误差必须以弧度表示。\n\n最后，分析一个每次读取单个场分量的 Yee 内核的 GPU 内存合并情况。考虑一个由 $W = 32$ 个并发线程组成的线程束（warp），每个线程从全局内存中加载一个元素。假设硬件内存事务段大小为 $128$ 字节。按如下方式对合并效率进行建模。一个线程束发出 $m$ 个内存事务，等于 $W$ 个加载操作所触及的不同 $128$ 字节段的数量。将合并效率定义为 $\\eta = 1/m$。假设基地址是 $128$ 字节对齐的。考虑两种内存布局：\n- 数组结构（SoA）：六个独立的数组，分别用于 $E_x, E_y, E_z, H_x, H_y, H_z$。在固定的 $y, z$ 坐标下沿 $x$ 方向读取 $E_x$ 时，连续的线程读取连续的 $E_x$ 元素。\n- 结构数组（AoS）：每个单元一个结构数组，按 $(E_x, E_y, E_z, H_x, H_y, H_z)$ 的顺序交错存储分量。\n\n假设元素是 $32$ 位（$4$ 字节）或 $64$ 位（$8$ 字节）。线程束中的线程编号为 $t = 0, 1, \\dots, 31$，读取地址为 $a_t = a_0 + t \\cdot s \\cdot b$，其中 $b$ 是元素大小（以字节为单位），$s$ 是步幅（以元素为单位）。对于 SoA 布局，当沿 $x$ 方向读取单个场分量时，取 $s = 1$。对于 AoS 布局，由于分量是交错的，当读取单个场分量时，取 $s = 6$。\n\n您的程序必须：\n- 推导并实现 Yee 方案的色散关系，并通过在 $k \\in [k_{\\min}, k_{\\max}]$ 上进行足够密集的均匀采样进行数值评估，计算波数带上的 $\\phi_{\\mathrm{disp}}$。\n- 实现舍入误差界限，并计算单精度和混合精度下的 $\\phi_{\\mathrm{total,wc}}$。\n- 实现合并效率模型，根据给定的 $(b, s)$ 以及固定的线程束和段参数计算 $\\eta$。\n\n角度单位必须是弧度。除上述无量纲定义外，不使用其他物理单位。\n\n测试套件和要求输出：\n实现以下十个测试用例，并将输出汇总为单行逗号分隔的 Python 列表字面量。\n\n内存合并测试（输出为浮点数 $\\eta$）：\n- T$1$: AoS 布局，单精度元素大小 $b = 4$ 字节，步幅 $s = 6$。\n- T$2$: SoA 布局，单精度元素大小 $b = 4$ 字节，步幅 $s = 1$。\n- T$3$: SoA 布局，双精度元素大小 $b = 8$ 字节，步幅 $s = 1$。\n- T$4$: 假设的未对齐步幅读取，单精度元素大小 $b = 4$ 字节，步幅 $s = 17$。\n\n相位误差预算测试（输出为布尔值，指示最坏情况下的总相位误差是否小于或等于阈值）：\n- T$5$: 在 $k \\in [0.1\\pi, 0.5\\pi]$ 上的单精度，库朗数 $S = 0.9$，步数 $N_{\\mathrm{steps}} = 50$，阈值 $\\phi_{\\mathrm{thr}} = 1.5$ 弧度。\n- T$6$: 针对与 T$5$ 相同的波数带和参数的混合精度。\n- T$7$: 在 $k \\in [0.1\\pi, 0.3\\pi]$ 上的单精度，库朗数 $S = 1.0$，步数 $N_{\\mathrm{steps}} = 2000$，阈值 $\\phi_{\\mathrm{thr}} = 3 \\times 10^{-4}$ 弧度。\n- T$8$: 针对与 T$7$ 相同的波数带和参数的混合精度。\n- T$9$: 在 $k \\in [0.8\\pi, 0.95\\pi]$ 上的单精度，库朗数 $S = 0.9$，步数 $N_{\\mathrm{steps}} = 50$，阈值 $\\phi_{\\mathrm{thr}} = 5.0$ 弧度。\n- T$10$: 针对与 T$9$ 相同的波数带和参数的混合精度。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,...]”）。", "solution": "该问题要求在时域有限差分（FDTD）方法的背景下，对数值色散、浮点误差和 GPU 内存访问模式之间的联系进行分析。我将首先推导必要的理论模型，然后将它们应用于指定的测试用例。\n\n首先，我们推导 FDTD 更新方程和数值色散关系。问题从线性、各向同性、均匀介质中的无源麦克斯韦方程组开始，采用无量纲单位，其中光速 $c=1$，介电常数 $\\epsilon=1$，磁导率 $\\mu=1$。对于一维问题，假设场 $E_y(x,t)$ 和 $H_z(x,t)$ 沿 x 轴传播，则旋度方程简化为：\n$$\n\\frac{\\partial E_y}{\\partial x} = -\\frac{\\partial H_z}{\\partial t}\n$$\n$$\n\\frac{\\partial H_z}{\\partial x} = -\\frac{\\partial E_y}{\\partial t}\n$$\nYee 方案在交错网格上离散化这些方程。设 $E_y$ 在空间位置 $i \\Delta x$ 和时间步长 $n \\Delta t$ 处求值，记为 $E_y^n[i]$。设 $H_z$ 在空间位置 $(i+1/2) \\Delta x$ 和时间步长 $(n+1/2) \\Delta t$ 处求值，记为 $H_z^{n+1/2}[i+1/2]$。使用中心差分，更新方程为：\n$$\n\\frac{H_z^{n+1/2}[i+1/2] - H_z^{n-1/2}[i-1/2]}{\\Delta x} = -\\frac{E_y^n[i+1] - E_y^n[i]}{\\Delta t}\n$$\n$$\n\\frac{E_y^{n+1}[i] - E_y^n[i-1]}{\\Delta x} = -\\frac{H_z^{n+1/2}[i+1/2] - H_z^{n+1/2}[i-1/2]}{\\Delta t}\n$$\n我们假设一个平面波解，其形式为 $E_y^n[i] = E_0 e^{j(k i \\Delta x - \\omega_{\\mathrm{num}} n \\Delta t)}$ 和 $H_z^{n+1/2}[i+1/2] = H_0 e^{j(k (i+1/2) \\Delta x - \\omega_{\\mathrm{num}} (n+1/2) \\Delta t)}$，其中 $k$ 是波数，$\\omega_{\\mathrm{num}}$ 是数值角频率。将这些代入两个更新方程，得到一个包含两个代数方程的系统。将它们组合起来以消去振幅 $E_0$ 和 $H_0$，得到数值色散关系：\n$$\n\\sin\\left(\\frac{\\omega_{\\mathrm{num}} \\Delta t}{2}\\right) = \\frac{c \\Delta t}{\\Delta x} \\sin\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n使用问题的无量纲化（$c=1$, $\\Delta x=1$）和库朗数 $S = c \\Delta t / \\Delta x = \\Delta t$ 的定义，该关系简化为：\n$$\n\\sin\\left(\\frac{\\omega_{\\mathrm{num}} S}{2}\\right) = S \\sin\\left(\\frac{k}{2}\\right)\n$$\n解出 $\\omega_{\\mathrm{num}}$ 得：\n$$\n\\omega_{\\mathrm{num}}(k, S) = \\frac{2}{S} \\arcsin\\left( S \\sin\\left(\\frac{k}{2}\\right) \\right)\n$$\n此关系在 Courant-Friedrichs-Lewy (CFL) 稳定性条件 $S \\le 1$ 下有效，这确保了反正弦函数的参数的绝对值不超过 $1$。精确的连续谱色散关系是 $\\omega_{\\mathrm{exact}}(k) = ck = k$。在传播时间 $T_{\\mathrm{prop}} = N_{\\mathrm{steps}} \\Delta t = N_{\\mathrm{steps}} S$ 内，由色散引起的相位误差为：\n$$\n\\phi_{\\mathrm{disp}}(k; S, N_{\\mathrm{steps}}) = |\\left(\\omega_{\\mathrm{num}}(k, S) - k\\right) T_{\\mathrm{prop}}| = |\\left(\\frac{2}{S} \\arcsin\\left( S \\sin\\left(\\frac{k}{2}\\right) \\right) - k\\right) N_{\\mathrm{steps}} S|\n$$\n为了找到波数带 $[k_{\\min}, k_{\\max}]$ 上的最坏情况误差，我们必须最大化此函数。误差函数 $E(k) = k - \\omega_{\\mathrm{num}}(k, S)$ 对于 $S  1$ 是随 $k$ 单调递增的。其导数 $E'(k) = 1 - (\\cos(k/2)) / \\sqrt{1 - S^2 \\sin^2(k/2)}$ 在 $S1$ 且 $k \\in (0, \\pi]$ 时为正。因此，最大误差出现在 $k = k_{\\max}$ 处。对于 $S=1$ 的特殊情况，当 $|k| \\le \\pi$ 时，$\\omega_{\\mathrm{num}}(k, 1) = 2 \\arcsin(\\sin(k/2)) = k$，意味着色散误差为零。\n\n接下来，我们构建总相位误差预算。由舍入引起的相位误差的界限为 $\\phi_{\\mathrm{round}} = N_{\\mathrm{steps}} \\, r \\, u$。根据问题，对于单精度，我们使用 $r = r_{\\mathrm{single}} = 6$；对于混合精度，使用 $r = r_{\\mathrm{mixed}} = 2$。在这两种情况下，误差源都与32位表示有关（无论是通过算术运算还是存储），因此相关的单位舍入是单精度的 $u = u_{32} = 2^{-24}$。\n总的最坏情况相位误差是最大色散误差和舍入误差界限之和：\n$$\n\\phi_{\\mathrm{total,wc}} = \\phi_{\\mathrm{disp}}(k_{\\max}; S, N_{\\mathrm{steps}}) + N_{\\mathrm{steps}} \\, r \\, u\n$$\n\n最后，我们对 GPU 内存合并效率进行建模。一个包含 $W=32$ 个线程的线程束（warp）执行同步内存访问。硬件使用 128 字节的内存事务来处理这些请求。效率 $\\eta$ 是事务数量 $m$ 的倒数。线程 $t \\in [0, 31]$ 访问地址 $a_t = a_0 + t \\cdot s \\cdot b$，其中 $a_0$ 是基地址（假设是 128 字节对齐的），$s$ 是步幅（以元素为单位），$b$ 是元素大小（以字节为单位）。事务数量 $m$ 是该线程束所触及的不同的 128 字节内存段的数量。线程 $t$ 的段索引为 $\\lfloor a_t / 128 \\rfloor$。由于 $a_0$ 是 128 的倍数，这可以简化为 $q + \\lfloor (t \\cdot s \\cdot b) / 128 \\rfloor$，其中 $q$ 是某个整数。我们需要找出 $\\lfloor (t \\cdot s \\cdot b) / 128 \\rfloor$ 对于 $t$ 取值于 $[0, 31]$ 时生成的唯一整数值的数量。这可以通过生成这些索引的集合并计算其基数来计算。\n$$\nm = \\left| \\left\\{ \\left\\lfloor \\frac{t \\cdot s \\cdot b}{128} \\right\\rfloor \\mid t = 0, 1, \\dots, 31 \\right\\} \\right|\n$$\n效率则为 $\\eta = 1/m$。\n\n这些模型被实现以解决十个测试用例。对于测试 T1-T4，我们计算 $\\eta$。对于测试 T5-T10，我们计算 $\\phi_{\\mathrm{total,wc}}$ 并将其与给定的阈值 $\\phi_{\\mathrm{thr}}$ 进行比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a multi-part problem involving GPU memory coalescing, FDTD numerical dispersion,\n    and floating-point error analysis.\n    \"\"\"\n\n    # Constants from the problem statement.\n    W = 32  # Warp size\n    SEGMENT_SIZE = 128  # Bytes\n    U_32 = 2**-24  # Unit roundoff for 32-bit single precision\n    R_SINGLE = 6\n    R_MIXED = 2\n\n    def compute_coalescing_efficiency(b, s):\n        \"\"\"\n        Computes the memory coalescing efficiency.\n\n        Args:\n            b (int): Element size in bytes.\n            s (int): Stride in elements.\n\n        Returns:\n            float: The coalescing efficiency eta.\n        \"\"\"\n        stride_in_bytes = s * b\n        segment_indices = set()\n        for t in range(W):\n            offset = t * stride_in_bytes\n            segment_index = offset // SEGMENT_SIZE\n            segment_indices.add(segment_index)\n        \n        m = len(segment_indices)\n        return 1.0 / m\n\n    def compute_total_phase_error(k_min, k_max, S, N_steps, r, u):\n        \"\"\"\n        Computes the total worst-case phase error.\n\n        Args:\n            k_min (float): Minimum wavenumber of the band.\n            k_max (float): Maximum wavenumber of the band.\n            S (float): Courant number.\n            N_steps (int): Number of time steps.\n            r (int): Number of unit roundoff contributions per step.\n            u (float): Unit roundoff value.\n\n        Returns:\n            float: The total worst-case phase error.\n        \"\"\"\n        # Dispersion error is monotonic with k, so the max is at k_max.\n        # Handle the special case S=1 (magic time step) where dispersion is zero\n        # for k in the principal Brillouin zone.\n        if S == 1.0 and k_max = np.pi:\n            max_phi_disp = 0.0\n        else:\n            # Argument for arcsin\n            arg = S * np.sin(k_max / 2.0)\n            if abs(arg) > 1.0:\n                # This would violate the CFL condition.\n                # The problem statement's cases are stable.\n                # Return infinity for unstable cases.\n                return float('inf')\n\n            omega_num = (2.0 / S) * np.arcsin(arg)\n            T_prop = N_steps * S\n            max_phi_disp = np.abs(omega_num - k_max) * T_prop\n\n        phi_round = N_steps * r * u\n        phi_total_wc = max_phi_disp + phi_round\n        \n        return phi_total_wc\n\n    test_cases = [\n        # T1: AoS, single precision\n        {'type': 'coalescing', 'b': 4, 's': 6},\n        # T2: SoA, single precision\n        {'type': 'coalescing', 'b': 4, 's': 1},\n        # T3: SoA, double precision\n        {'type': 'coalescing', 'b': 8, 's': 1},\n        # T4: Hypothetical misaligned stride\n        {'type': 'coalescing', 'b': 4, 's': 17},\n        # T5: Single precision, S=0.9\n        {'type': 'phase_error', 'k_min': 0.1 * np.pi, 'k_max': 0.5 * np.pi,\n         'S': 0.9, 'N_steps': 50, 'r': R_SINGLE, 'u': U_32, 'thr': 1.5},\n        # T6: Mixed precision, S=0.9\n        {'type': 'phase_error', 'k_min': 0.1 * np.pi, 'k_max': 0.5 * np.pi,\n         'S': 0.9, 'N_steps': 50, 'r': R_MIXED, 'u': U_32, 'thr': 1.5},\n        # T7: Single precision, S=1.0\n        {'type': 'phase_error', 'k_min': 0.1 * np.pi, 'k_max': 0.3 * np.pi,\n         'S': 1.0, 'N_steps': 2000, 'r': R_SINGLE, 'u': U_32, 'thr': 3e-4},\n        # T8: Mixed precision, S=1.0\n        {'type': 'phase_error', 'k_min': 0.1 * np.pi, 'k_max': 0.3 * np.pi,\n         'S': 1.0, 'N_steps': 2000, 'r': R_MIXED, 'u': U_32, 'thr': 3e-4},\n        # T9: Single precision, high-k\n        {'type': 'phase_error', 'k_min': 0.8 * np.pi, 'k_max': 0.95 * np.pi,\n         'S': 0.9, 'N_steps': 50, 'r': R_SINGLE, 'u': U_32, 'thr': 5.0},\n        # T10: Mixed precision, high-k\n        {'type': 'phase_error', 'k_min': 0.8 * np.pi, 'k_max': 0.95 * np.pi,\n         'S': 0.9, 'N_steps': 50, 'r': R_MIXED, 'u': U_32, 'thr': 5.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'coalescing':\n            result = compute_coalescing_efficiency(case['b'], case['s'])\n        elif case['type'] == 'phase_error':\n            total_error = compute_total_phase_error(\n                case['k_min'], case['k_max'], case['S'],\n                case['N_steps'], case['r'], case['u']\n            )\n            result = total_error = case['thr']\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3353975"}]}