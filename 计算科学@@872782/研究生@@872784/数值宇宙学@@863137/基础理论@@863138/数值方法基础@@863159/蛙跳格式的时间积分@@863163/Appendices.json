{"hands_on_practices": [{"introduction": "像蛙跳格式这样的辛积分器并不能精确地守恒系统的原始哈密顿量，但它能完美地守恒一个与之接近的“影子”哈密顿量。本练习将以简谐振子为试验台，通过推导由该影子哈密顿量产生的修正振荡频率，来探讨这一基本概念。这项解析练习能让我们深刻理解该积分格式的长期精度和相位保持特性。[@problem_id:3501415]", "problem": "在宇宙学 $N$ 体计算中，诸如“踢-漂移-踢”（KDK）蛙跳法等辛分裂积分方法被用于在不依赖于时间的力作用下推进轨道。作为一个与引力势能极小值附近的小振荡相关的线性测试平台，考虑一个一维谐振子，其哈密顿量为 $H(x,p)=\\frac{1}{2}\\left(p^{2}+\\omega^{2}x^{2}\\right)$，其中质量已归一化为 $m=1$，$x$ 是共动坐标，$p$ 是正则动量，$\\omega>0$ 是精确角频率。运动方程为 $\\ddot{x}+\\omega^{2}x=0$，由 $H$ 生成的连续时间流是一个角度为 $\\omega t$ 的相空间旋转。\n\n设时间步长为 $h>0$。KDK蛙跳法包含一个由势的梯度驱动的半步长动量“踢”，一个由动能项驱动的整步长位置“漂移”，以及最后一次由势的梯度驱动的半步长动量“踢”。从定义 $H$ 的基本定律、正则方程和 KDK 组合出发，推导单步线性更新映射 $(x_{n},p_{n})\\mapsto(x_{n+1},p_{n+1})$，并分析其特征值以推断相应相空间旋转的角度。该离散映射精确地保持一个修正的（影子）哈密顿量，该哈密顿量是二次的，并以一个依赖于 $h$ 和 $\\omega$ 的修正角频率 $\\tilde{\\omega}$ 产生谐波旋转。\n\n计算 KDK 蛙跳法的修正哈密顿量所蕴含的修正角频率 $\\tilde{\\omega}$ 的闭式解析表达式，该表达式纯粹用 $h$ 和 $\\omega$ 表示。在您的推导过程中，简要地在小 $h$ 极限下将 $\\tilde{\\omega}$ 与精确值 $\\omega$ 进行比较，但最终答案只提供 $\\tilde{\\omega}$ 的解析表达式。无需进行数值取整，且最终答案中不应包含任何单位。", "solution": "问题陈述经过严格验证，确认有效。它在科学上基于哈密顿力学和数值积分理论，是适定的、客观的且内部一致的。因此，我们可以进行推导。\n\n该系统是一个质量 $m=1$ 的一维谐振子，由哈密顿量 $H(x,p) = T(p) + V(x)$ 描述，其中动能为 $T(p) = \\frac{1}{2}p^2$，势能为 $V(x) = \\frac{1}{2}\\omega^2 x^2$。哈密顿正则运动方程为：\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial p} = p\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial x} = -\\omega^2 x\n$$\n\n“踢-漂移-踢”（KDK）蛙跳法积分器是一种二阶辛分裂方法，它通过动能部分和势能部分的算符组合来近似精确的时间演化算符 $\\exp(h\\mathcal{L}_H)$，其中 $\\mathcal{L}_H = \\{ \\cdot, H \\}$ 是泊松括号算符。对于一个时间步长 $h$，KDK 格式由以下组合给出：\n$$\n\\Phi_h = \\Phi_V^{h/2} \\circ \\Phi_T^{h} \\circ \\Phi_V^{h/2}\n$$\n这里，$\\Phi_V^{\\Delta t}$ 表示系统仅在势能部分 $V(x)$ 的作用下演化时间 $\\Delta t$，而 $\\Phi_T^{\\Delta t}$ 表示系统仅在动能部分 $T(p)$ 的作用下演化时间 $\\Delta t$。\n\n让我们推导每个分量的映射。\n1.  **踢步 ($\\Phi_V^{\\Delta t}$)**：在 $V(x)$ 作用下的演化遵循方程 $\\dot{x}=0$ 和 $\\dot{p}=-\\frac{\\partial V}{\\partial x} = -\\omega^2 x$。由于在这一步中 $x$ 是常数，从 $(x, p)$ 到 $(x', p')$ 在时间间隔 $\\Delta t$ 内的更新为：\n    $$\n    x' = x\n    $$\n    $$\n    p' = p - (\\omega^2 x) \\Delta t\n    $$\n\n2.  **漂移步 ($\\Phi_T^{\\Delta t}$)**：在 $T(p)$ 作用下的演化遵循方程 $\\dot{x}=\\frac{\\partial T}{\\partial p} = p$ 和 $\\dot{p}=0$。由于在这一步中 $p$ 是常数，从 $(x, p)$ 到 $(x', p')$ 在时间间隔 $\\Delta t$ 内的更新为：\n    $$\n    x' = x + p \\Delta t\n    $$\n    $$\n    p' = p\n    $$\n\n现在，我们组合这些步骤来构建从 $(x_n, p_n)$ 到 $(x_{n+1}, p_{n+1})$ 在一个时间步长 $h$ 内的完整 KDK 积分器映射。\n\n**第一次踢（半步, $\\Delta t = h/2$）**：\n设中间状态为 $(x_\\text{mid1}, p_\\text{mid1})$。\n$$\nx_\\text{mid1} = x_n\n$$\n$$\np_\\text{mid1} = p_n - \\frac{h}{2}\\omega^2 x_n\n$$\n\n**漂移（整步, $\\Delta t = h$）**：\n设下一个中间状态为 $(x_\\text{mid2}, p_\\text{mid2})$。我们将漂移应用于 $(x_\\text{mid1}, p_\\text{mid1})$。\n$$\nx_\\text{mid2} = x_\\text{mid1} + h \\cdot p_\\text{mid1} = x_n + h\\left(p_n - \\frac{h}{2}\\omega^2 x_n\\right) = \\left(1 - \\frac{h^2\\omega^2}{2}\\right)x_n + h p_n\n$$\n$$\np_\\text{mid2} = p_\\text{mid1} = p_n - \\frac{h}{2}\\omega^2 x_n\n$$\n\n**第二次踢（半步, $\\Delta t = h/2$）**：\n通过对 $(x_\\text{mid2}, p_\\text{mid2})$ 应用踢步，得到最终状态 $(x_{n+1}, p_{n+1})$。\n$$\nx_{n+1} = x_\\text{mid2} = \\left(1 - \\frac{h^2\\omega^2}{2}\\right)x_n + h p_n\n$$\n$$\np_{n+1} = p_\\text{mid2} - \\frac{h}{2}\\omega^2 x_\\text{mid2} = \\left(p_n - \\frac{h}{2}\\omega^2 x_n\\right) - \\frac{h}{2}\\omega^2 \\left[ \\left(1 - \\frac{h^2\\omega^2}{2}\\right)x_n + h p_n \\right]\n$$\n展开 $p_{n+1}$ 的表达式：\n$$\np_{n+1} = p_n - \\frac{h\\omega^2}{2}x_n - \\frac{h\\omega^2}{2}\\left(1 - \\frac{h^2\\omega^2}{2}\\right)x_n - \\frac{h^2\\omega^2}{2}p_n\n$$\n$$\np_{n+1} = \\left(1 - \\frac{h^2\\omega^2}{2}\\right)p_n - \\left[\\frac{h\\omega^2}{2} + \\frac{h\\omega^2}{2} - \\frac{h^3\\omega^4}{4}\\right]x_n\n$$\n$$\np_{n+1} = \\left(1 - \\frac{h^2\\omega^2}{2}\\right)p_n - \\left(h\\omega^2 - \\frac{h^3\\omega^4}{4}\\right)x_n\n$$\n$$\np_{n+1} = -\\omega^2 h\\left(1 - \\frac{h^2\\omega^2}{4}\\right)x_n + \\left(1 - \\frac{h^2\\omega^2}{2}\\right)p_n\n$$\n\n单步线性更新可以写成矩阵形式 $\\begin{pmatrix} x_{n+1} \\\\ p_{n+1} \\end{pmatrix} = M \\begin{pmatrix} x_n \\\\ p_n \\end{pmatrix}$，其中转移矩阵 $M$ 为：\n$$\nM = \\begin{pmatrix}\n1 - \\frac{h^2\\omega^2}{2} & h \\\\\n-\\omega^2 h\\left(1 - \\frac{h^2\\omega^2}{4}\\right) & 1 - \\frac{h^2\\omega^2}{2}\n\\end{pmatrix}\n$$\n这个离散映射对应于相空间中一个角度为 $\\theta = \\tilde{\\omega}h$ 的旋转，其中 $\\tilde{\\omega}$ 是我们寻求的修正角频率。一个 $2 \\times 2$ 旋转矩阵的特征值为 $e^{\\pm i\\theta}$。这种矩阵的迹为 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$。因此，我们可以通过计算转移矩阵 $M$ 的迹来求得该角度。\n$$\n\\text{Tr}(M) = \\left(1 - \\frac{h^2\\omega^2}{2}\\right) + \\left(1 - \\frac{h^2\\omega^2}{2}\\right) = 2 - h^2\\omega^2\n$$\n将其与旋转矩阵的迹相等，得到：\n$$\n2\\cos(\\tilde{\\omega}h) = 2 - h^2\\omega^2\n$$\n$$\n\\cos(\\tilde{\\omega}h) = 1 - \\frac{h^2\\omega^2}{2}\n$$\n问题现在是求解 $\\tilde{\\omega}$。\n$$\n\\tilde{\\omega}h = \\arccos\\left(1 - \\frac{h^2\\omega^2}{2}\\right)\n$$\n这个表达式可以使用三角恒等式 $\\cos(2\\alpha) = 1 - 2\\sin^2(\\alpha)$ 来简化。令 $\\tilde{\\omega}h = 2\\alpha$。那么 $\\cos(2\\alpha) = 1 - \\frac{h^2\\omega^2}{2}$。将其与恒等式比较可得：\n$$\n2\\sin^2(\\alpha) = \\frac{h^2\\omega^2}{2} \\implies \\sin^2(\\alpha) = \\frac{h^2\\omega^2}{4}\n$$\n对于稳定积分（$h\\omega < 2$），我们可以取主根：\n$$\n\\sin(\\alpha) = \\frac{h\\omega}{2} \\implies \\alpha = \\arcsin\\left(\\frac{h\\omega}{2}\\right)\n$$\n将 $\\alpha = \\frac{\\tilde{\\omega}h}{2}$ 代回：\n$$\n\\frac{\\tilde{\\omega}h}{2} = \\arcsin\\left(\\frac{h\\omega}{2}\\right)\n$$\n求解 $\\tilde{\\omega}$：\n$$\n\\tilde{\\omega} = \\frac{2}{h}\\arcsin\\left(\\frac{h\\omega}{2}\\right)\n$$\n这就是修正角频率的闭式解析表达式。\n\n为了在小 $h$ 极限下比较 $\\tilde{\\omega}$ 和 $\\omega$，我们使用 $\\arcsin(z) = z + \\frac{z^3}{6} + O(z^5)$ 的泰勒级数展开，其中 $z = \\frac{h\\omega}{2}$：\n$$\n\\tilde{\\omega} = \\frac{2}{h}\\left[ \\left(\\frac{h\\omega}{2}\\right) + \\frac{1}{6}\\left(\\frac{h\\omega}{2}\\right)^3 + O(h^5) \\right]\n$$\n$$\n\\tilde{\\omega} = \\frac{2}{h}\\left[ \\frac{h\\omega}{2} + \\frac{h^3\\omega^3}{48} + O(h^5) \\right]\n$$\n$$\n\\tilde{\\omega} = \\omega + \\frac{h^2\\omega^3}{24} + O(h^4) = \\omega\\left(1 + \\frac{h^2\\omega^2}{24} + O(h^4)\\right)\n$$\n当 $h \\to 0$ 时，修正频率 $\\tilde{\\omega}$ 收敛于真实频率 $\\omega$。领阶误差项 $\\frac{h^2\\omega^3}{24}$ 是正的，这表明数值振荡器的频率略高（周期缩短），这是蛙跳法积分器的一个已知特性。误差与 $h^2$ 成比例，这与该方法是二阶精度相符。", "answer": "$$\\boxed{\\frac{2}{h}\\arcsin\\left(\\frac{h\\omega}{2}\\right)}$$", "id": "3501415"}, {"introduction": "当我们从简单系统转向宇宙学模拟时，运动方程中的“力”项通常会依赖于积分变量（例如宇宙标度因子 $a$）。这个编程练习将展示一个关键的实现细节：踢步（kick）操作的时间中心化。通过比较一个朴素的实现与一个恰当的时间中心化实现，你将量化一个可预测的systemic偏差，从而突显出尊重KDK蛙跳格式的对称结构以保持其精度的重要性。[@problem_id:3501452]", "problem": "考虑一个 Einstein–de Sitter 宇宙（仅含物质，宇宙学常数为零），采用共动坐标系，并使用标度因子 $a$ 作为自变量。哈勃参数按 $H(a) = H_0 a^{-3/2}$ 变化，其中 $H_0$ 是一个常数。考虑单个平面波密度扰动的线性区域，其密度衬度为 $\\delta(\\boldsymbol{x},a) = \\delta_0 D(a) \\cos(k x)$，其中 $D(a)$ 是线性增长因子，$k$ 是波数。在这样的宇宙中，线性理论的增长因子为 $D(a) = a$，共动引力势 $\\Phi$ 满足 Poisson 方程 $\\nabla^2 \\Phi = 4 \\pi G a^2 \\bar{\\rho}(a) \\delta(\\boldsymbol{x},a)$。在梯度大小达到最大的固定空间相位处，共动引力加速度的大小按 $|\\nabla \\Phi|(a) \\propto a^2 D(a) = a^3$ 变化。\n\n在标准的宇宙学 $N$ 体表述中，可以采用由关于标度因子 $a$ 的一阶系统所支配的正则动量 $p$ 和共动位置 $x$：\n$$\\frac{dx}{da} = \\frac{p}{a^3 H(a)}, \\qquad \\frac{dp}{da} = -\\frac{|\\nabla \\Phi|(a)}{a H(a)}.$$\n根据 Einstein–de Sitter 模型的标度关系 $H(a) = H_0 a^{-3/2}$ 和 $|\\nabla \\Phi|(a) \\propto a^3$，踢动权重函数的大小为\n$$W(a) \\equiv \\frac{|\\nabla \\Phi|(a)}{a H(a)} \\propto \\frac{a^3}{a \\cdot a^{-3/2}} = a^{7/2}.$$\n为了本问题的目的，我们将所有常数（$H_0$、振幅和比例因子）归一化为 1，使得 $W(a) = a^{7/2}$ 和 $H(a) = a^{-3/2}$。这种归一化使得所有量都无量纲；您的程序应报告无量纲的浮点数。\n\n我们研究在有限区间 $[a_0,a_f]$ 上的蛙跳格式，其形式为“踢-漂移-踢”（KDK）。该区间被划分为 $N$ 个大小为 $\\Delta a = (a_f - a_0)/N$ 的均匀步长。将步长的端点表示为 $a_n = a_0 + n \\Delta a$，中点表示为 $a_{n+1/2} = (a_n + a_{n+1})/2$。对于每一步，正则动量通过两次踢动更新，位置通过一次漂移更新：\n- 踢动–1：将 $p$ 推进 $\\frac{\\Delta a}{2} W(a_{\\mathrm{eval},1})$，\n- 漂移：将 $x$ 推进 $\\mathcal{F}_{\\mathrm{drift}}(a_n,a_{n+1}) \\, p_{\\text{half}}$，其中\n$$\\mathcal{F}_{\\mathrm{drift}}(a_n,a_{n+1}) = \\int_{a_n}^{a_{n+1}} \\frac{da}{a^3 H(a)} = \\int_{a_n}^{a_{n+1}} a^{-3/2} \\, da = 2\\left(a_n^{-1/2} - a_{n+1}^{-1/2}\\right),$$\n- 踢动–2：将 $p$ 推进 $\\frac{\\Delta a}{2} W(a_{\\mathrm{eval},2})$。\n\n我们比较两种 KDK 变体：\n1. 初始时刻力（朴素）方法：两次踢动都在步长的开始处计算力，即 $a_{\\mathrm{eval},1} = a_n$ 和 $a_{\\mathrm{eval},2} = a_n$。\n2. 时间中心（对称）方法：两次踢动分别在步长的开始和结束处计算力，即 $a_{\\mathrm{eval},1} = a_n$ 和 $a_{\\mathrm{eval},2} = a_{n+1}$。\n\n我们构造一个反例初始条件，在该条件下，初始时刻力（朴素）KDK 方法会以一个可预测的因子低估线性增长。在势梯度大小最大的空间位置上初始化单个粒子，其条件为\n$$x(a_0) = 0, \\quad p\\left(a_0 - \\frac{\\Delta a}{2}\\right) = 0.$$\n在这些条件下，$x$ 在 $[a_0,a_f]$ 上的全部增长都源于累积的踢动和随后的漂移。由于 $W(a) = a^{7/2}$ 随 $a$ 单调递增，与时间中心方案相比，初始时刻力（朴素）KDK 方法低估了每一步的平均踢动。每步的动量增量比为\n$$R_n = \\frac{\\Delta a \\, W(a_n)}{\\frac{\\Delta a}{2}\\left[W(a_n) + W(a_{n+1})\\right]} = \\frac{2}{1 + \\left(\\frac{a_{n+1}}{a_n}\\right)^{7/2}},$$\n且累积动量的总低估因子为 $\\prod_{n=0}^{N-1} R_n$。因为两种方案中的漂移都使用完全相同的漂移积分，且 $x$ 与半步长动量呈线性关系，最终位置 $x(a_f)$ 基本上继承了相同的乘法偏差，使得该比率\n$$\\mathcal{B}(a_0,a_f,N) \\equiv \\frac{x_{\\text{naive}}(a_f)}{x_{\\text{centered}}(a_f)} \\approx \\prod_{n=0}^{N-1} \\frac{2}{1 + \\left(\\frac{a_{n+1}}{a_n}\\right)^{7/2}}.$$\n您的任务：\n- 为具有 $W(a) = a^{7/2}$ 和 $H(a) = a^{-3/2}$ 的归一化模型实现上述两种 KDK 变体，使用精确的漂移积分 $\\mathcal{F}_{\\mathrm{drift}}(a_n,a_{n+1})$ 以及每步包含 $\\frac{\\Delta a}{2}$ 因子的两次踢动规则。\n- 使用指定的初始条件 $x(a_0) = 0$ 和 $p\\left(a_0 - \\frac{\\Delta a}{2}\\right) = 0$。\n- 对于每个测试用例，计算并返回无量纲浮点数 $\\mathcal{B}(a_0,a_f,N) = x_{\\text{naive}}(a_f) / x_{\\text{centered}}(a_f)$。\n\n测试套件：\n- 案例 1 (正常路径): $a_0 = 0.1$, $a_f = 1.0$, $N = 10$。\n- 案例 2 (单大步边界): $a_0 = 0.1$, $a_f = 1.0$, $N = 1$。\n- 案例 3 (多小步边缘): $a_0 = 0.1$, $a_f = 1.0$, $N = 1000$。\n- 案例 4 (短最终区间): $a_0 = 0.9$, $a_f = 1.0$, $N = 10$。\n- 案例 5 (小区间): $a_0 = 0.1$, $a_f = 0.2$, $N = 10$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按测试用例顺序排列的结果，形式为方括号括起来的逗号分隔列表：$[\\mathcal{B}_1,\\mathcal{B}_2,\\mathcal{B}_3,\\mathcal{B}_4,\\mathcal{B}_5]$。每个条目必须是无量纲的浮点数。", "solution": "该问题是有效的。它基于物理宇宙学中一个简化但标准的模型，提出了一个明确定义的数值任务。控制方程、数值方案和初始条件都得到了完整且一致的指定，从而可以得出一个唯一的解。关于动量微分方程 $\\frac{dp}{da} = -\\frac{|\\nabla \\Phi|(a)}{a H(a)}$ 中符号的细微模糊性，通过明确无误的算法规则“将 $p$ 推进”一个正量来解决，该规则将此问题的动力学定义为 $\\frac{dp}{da} = W(a)$。\n\n该问题要求实现并比较两种用于膨胀宇宙中粒子的“踢-漂移-踢”（KDK）蛙跳积分方案的变体。粒子的动力学由关于标度因子 $a$ 的一阶常微分方程组描述：\n$$\n\\frac{dx}{da} = \\frac{p}{a^3 H(a)}\n$$\n$$\n\\frac{dp}{da} = W(a)\n$$\n根据指定的哈勃参数 $H(a)$ 和踢动权重函数 $W(a)$ 的归一化，这些方程变为：\n$$\n\\frac{dx}{da} = \\frac{p}{a^3 a^{-3/2}} = \\frac{p}{a^{3/2}}\n$$\n$$\n\\frac{dp}{da} = a^{7/2}\n$$\nKDK 蛙跳算法是一种二阶精确的辛积分器，适用于哈密顿系统。它在交错的时间网格上运行，其中位置 $x$ 在整数步长 $a_n$ 处已知，而正则动量 $p$ 在半整数步长 $a_{n \\pm 1/2}$ 处已知。区间 $[a_0, a_f]$ 被划分为 $N$ 个大小为 $\\Delta a = (a_f - a_0) / N$ 的步长。从 $a_n$到 $a_{n+1}$ 的单个积分步骤将状态 $(x_n, p_{n-1/2})$ 更新为 $(x_{n+1}, p_{n+1/2})$，过程如下：\n\n$1$. **第一次踢动（半步）：** 动量从时间 $a_{n-1/2} = a_n - \\Delta a / 2$ 推进到整数步长时间 $a_n$。这对应于将 $\\frac{dp}{da}$ 在半个步长上积分。更新规则为：\n$$p_n = p_{n-1/2} + \\frac{\\Delta a}{2} W(a_{\\text{eval},1})$$\n其中 $p_n$ 是时间 $a_n$ 处的动量。\n\n$2$. **漂移（整步）：** 位置从 $a_n$ 推进到 $a_{n+1}$。这涉及在整个步长上积分 $\\frac{dx}{da}$，使用时间区间中点处的动量 $p_n$。问题为漂移方程中依赖时间的部分提供了精确积分：\n$$\n\\mathcal{F}_{\\text{drift}}(a_n, a_{n+1}) = \\int_{a_n}^{a_{n+1}} \\frac{da}{a^3 H(a)} = \\int_{a_n}^{a_{n+1}} a^{-3/2} \\, da = 2\\left(a_n^{-1/2} - a_{n+1}^{-1/2}\\right)\n$$\n位置更新则为：\n$$x_{n+1} = x_n + p_n \\mathcal{F}_{\\text{drift}}(a_n, a_{n+1})$$\n\n$3$. **第二次踢动（半步）：** 动量从 $a_n$ 推进到下一个半步长 $a_{n+1/2}$。这完成了动量从 $a_{n-1/2}$ 到 $a_{n+1/2}$ 整个步长的更新：\n$$p_{n+1/2} = p_n + \\frac{\\Delta a}{2} W(a_{\\text{eval},2})$$\n\nKDK 方案的两种变体通过其对踢动函数 $W(a)$ 的求值点的选择来区分：\n- **初始时刻力（朴素）方法：** 此方案在步长的开始处为两次踢动计算踢动权重函数 $W(a)$：$a_{\\text{eval},1} = a_n$ 和 $a_{\\text{eval},2} = a_n$。这使得该步长上的总动量更新为 $\\Delta p_n = p_{n+1/2} - p_{n-1/2} = \\Delta a \\cdot W(a_n)$。\n- **时间中心（对称）方法：** 此方案分别在步长区间的开始和结束处计算踢动权重函数：$a_{\\text{eval},1} = a_n$ 和 $a_{\\text{eval},2} = a_{n+1}$。总动量更新为 $\\Delta p_n = \\frac{\\Delta a}{2} [W(a_n) + W(a_{n+1})]$。这是对踢动的梯形法则积分，并保持二阶精度。\n\n初始条件给出为 $x(a_0) = 0$ 和 $p(a_0 - \\Delta a / 2) = 0$。在我们的离散形式中，这对应于 $x_0 = 0$ 和 $p_{-1/2} = 0$。\n\n计算比率 $\\mathcal{B}(a_0, a_f, N) = x_{\\text{naive}}(a_f) / x_{\\text{centered}}(a_f)$ 的算法如下：\n对于每个测试用例 $(a_0, a_f, N)$:\n1. 实现一个执行 KDK 积分的函数。该函数以 $a_0, a_f, N$ 和方案类型（'naive' 或 'centered'）作为输入。\n2. 在函数内部，初始化 $x = 0$ 和半步长动量 $p_{\\text{half}} = 0$。\n3. 对 $n$ 从 $0$ 到 $N-1$ 进行循环：\n    a. 计算当前和下一个标度因子，$a_n = a_0 + n \\Delta a$ 和 $a_{n+1} = a_n + \\Delta a$。\n    b. 根据方案设置求值点 $a_{\\text{eval},1}$ 和 $a_{\\text{eval},2}$。\n    c. 执行第一次踢动以获得 $p_n$。\n    d. 执行整步漂移以将 $x$ 更新为 $x_{n+1}$。\n    e. 执行第二次踢动以将 $p_{\\text{half}}$ 更新为 $p_{n+1/2}$。\n4. 循环结束后，$x$ 的最终值就是该方案的结果 $x(a_f)$。\n5. 对 'naive' 方案调用一次此函数以获得 $x_{\\text{naive}}(a_f)$，再对 'centered' 方案调用一次以获得 $x_{\\text{centered}}(a_f)$。\n6. 计算并存储比率 $\\mathcal{B} = x_{\\text{naive}}(a_f) / x_{\\text{centered}}(a_f)$。\n7. 收集所有测试用例的比率，并按指定格式输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing two variants of the KDK leapfrog scheme\n    and computing the ratio of their final positions for a set of test cases.\n    \"\"\"\n\n    def W(a):\n        \"\"\"\n        The normalized kick weight function W(a) = a^(7/2).\n        \"\"\"\n        return a**3.5\n\n    def F_drift(a_n, a_np1):\n        \"\"\"\n        The exact drift factor integral from a_n to a_{n+1}.\n        \"\"\"\n        return 2.0 * (a_n**-0.5 - a_np1**-0.5)\n\n    def kdk_integrator(a0, af, N, scheme):\n        \"\"\"\n        Performs the KDK integration for a given scheme.\n\n        Args:\n            a0 (float): The initial scale factor.\n            af (float): The final scale factor.\n            N (int): The number of integration steps.\n            scheme (str): The integration scheme, either 'naive' or 'centered'.\n\n        Returns:\n            float: The final position x(af).\n        \"\"\"\n        delta_a = (af - a0) / N\n\n        # Initial conditions: x(a0) = 0, p(a0 - delta_a/2) = 0\n        x = 0.0\n        p_half_step = 0.0\n\n        for n in range(N):\n            a_n = a0 + n * delta_a\n            a_np1 = a_n + delta_a\n\n            # Determine evaluation points for the kick function W(a)\n            if scheme == 'naive':\n                a_eval1 = a_n\n                a_eval2 = a_n\n            elif scheme == 'centered':\n                a_eval1 = a_n\n                a_eval2 = a_np1\n            else:\n                raise ValueError(\"Unknown scheme specified.\")\n\n            # 1. First Kick (advances p from a_{n-1/2} to a_n)\n            p_full_step = p_half_step + (delta_a / 2.0) * W(a_eval1)\n\n            # 2. Drift (advances x from a_n to a_{n+1} using p at a_n)\n            x = x + F_drift(a_n, a_np1) * p_full_step\n\n            # 3. Second Kick (advances p from a_n to a_{n+1/2})\n            p_half_step = p_full_step + (delta_a / 2.0) * W(a_eval2)\n\n        return x\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a0, af, N)\n        (0.1, 1.0, 10),     # Case 1\n        (0.1, 1.0, 1),      # Case 2\n        (0.1, 1.0, 1000),   # Case 3\n        (0.9, 1.0, 10),     # Case 4\n        (0.1, 0.2, 10),     # Case 5\n    ]\n\n    results = []\n    for a0, af, N in test_cases:\n        x_naive = kdk_integrator(a0, af, N, 'naive')\n        x_centered = kdk_integrator(a0, af, N, 'centered')\n\n        # The problem setup ensures x_centered is non-zero.\n        ratio = x_naive / x_centered\n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3501452"}, {"introduction": "在精确算术下，蛙跳积分器的一个关键理论优势是其时间可逆性。这个动手实践将通过一个 $N$ 体系统的数值实验来检验这一特性。你将把系统在时间上向前演化，然后再向后演化回到起点，并测量由有限精度浮点运算引起的差异。这将让你对计算中的舍入误差如何破坏算法的理想对称性有一个切实的理解。[@problem_id:3501446]", "problem": "您需要实现一个数值实验，以探究在三维空间中，$N$体系统使用 kick-drift-kick 次序的时间中心蛙跳法的时间可逆性。该实验采用数值宇宙学的语言进行构建，其中自变量为尺度因子 $a$，时间步以增量 $\\Delta a$ 进行。为了本次测试的目的，您将在共动坐标系中演化一个自引力 $N$体系统，使用代码单位制（其中 $G=1$ 且所有粒子质量相等），但力定律中不显式依赖于 $a$，因此单位质量所受的力仅取决于共动位置。目标是分离出浮点舍入对蛙跳映射时间可逆性的影响。\n\n从牛顿第二定律的基本原理和速度定义为位置对自变量的导数出发，您必须：\n\n- 在一个基准初始尺度因子 $a_0$ 处，用位置 $\\boldsymbol{x}_i \\in \\mathbb{R}^3$ 和速度 $\\boldsymbol{v}_i = d\\boldsymbol{x}_i/da$（其中 $i = 1,\\dots,N$）来表示 $N$ 个粒子。\n- 使用从 Plummer 软化的牛顿势导出的成对相加力，软化长度为 $\\varepsilon$，粒子质量相等 $m_i = 1/N$，引力常数 $G=1$。作用在粒子 $i$ 上的力是所有 $j \\ne i$ 的贡献之和：\n$$\n\\boldsymbol{a}_{ij} = - G m_j \\frac{\\boldsymbol{x}_i - \\boldsymbol{x}_j}{\\left(\\lVert \\boldsymbol{x}_i - \\boldsymbol{x}_j\\rVert^2 + \\varepsilon^2\\right)^{3/2}},\n$$\n因此粒子 $i$ 的加速度为 $\\boldsymbol{a}_i = \\sum_{j \\ne i} \\boldsymbol{a}_{ij}$。\n- 使用 kick-drift-kick (KDK) 次序的标准时间中心蛙跳积分器，以固定步长 $\\Delta a$ 来推进系统。您必须使用步长 $+\\Delta a$ 将系统从 $(\\{\\boldsymbol{x}_i^{(0)}\\}, \\{\\boldsymbol{v}_i^{(0)}\\})$ 向前演化 $N_{\\text{step}}$ 步到 $(\\{\\boldsymbol{x}_i^{(f)}\\}, \\{\\boldsymbol{v}_i^{(f)}\\})$，然后从 $(\\{\\boldsymbol{x}_i^{(f)}\\}, \\{\\boldsymbol{v}_i^{(f)}\\})$ 开始，使用步长 $-\\Delta a$ 向后演化相同的步数，得到 $(\\{\\boldsymbol{x}_i^{(b)}\\}, \\{\\boldsymbol{v}_i^{(b)}\\})$。\n- 测量相空间失配，该失配由一个标量给出，即均方根范数：\n$$\nE = \\sqrt{\\frac{1}{3N}\\sum_{i=1}^N \\left( \\lVert \\boldsymbol{x}_i^{(b)} - \\boldsymbol{x}_i^{(0)} \\rVert^2 + \\lVert \\boldsymbol{v}_i^{(b)} - \\boldsymbol{v}_i^{(0)} \\rVert^2 \\right)}.\n$$\n将 $E$ 报告为一个无量纲十进制数。\n\n您必须在两种不同的浮点精度下重复该实验：\n- Binary 64 (双精度)。\n- Binary 128 (四精度)。如果您的平台不提供真正的四精度，请使用您的语言和运行时支持的最宽扩展精度作为 binary 128 的替代。\n\n使用带有固定种子的随机化初始快照，以确保实验是可复现的。通过从 $[-1/2, 1/2]$ 的均匀分布中抽取每个分量来初始化位置 $\\boldsymbol{x}_i$，并通过从 $[-v_0, v_0]$ 的均匀分布中抽取每个分量来初始化速度 $\\boldsymbol{v}_i$，然后减去质心速度，以使 $\\sum_i \\boldsymbol{v}_i = \\boldsymbol{0}$。使用足够小的 $v_0$ 以避免单步内产生过大的位移。使用 Plummer 软化（$\\varepsilon > 0$）以防止数值奇点。所有量都是无量纲的。\n\n测试套件：\n- 固定粒子数为 $N = 12$，软化长度为 $\\varepsilon = 10^{-3}$，速度尺度为 $v_0 = 5 \\times 10^{-2}$。\n- 对于以下每个 $(N_{\\text{step}}, \\Delta a)$ 对，在两种精度下执行前向-后向演化实验并计算失配 $E$：\n    - $(N_{\\text{step}}, \\Delta a) = (1, 10^{-3})$。\n    - $(N_{\\text{step}}, \\Delta a) = (50, 2 \\times 10^{-3})$。\n    - $(N_{\\text{step}}, \\Delta a) = (200, 5 \\times 10^{-4})$。\n    - $(N_{\\text{step}}, \\Delta a) = (500, 2 \\times 10^{-4})$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个测试用例一个内部列表，每个内部列表包含四个数字，顺序为 $[N_{\\text{step}}, \\Delta a, E_{\\text{double}}, E_{\\text{extended}}]$，所有数字均为十进制数。例如，包含两个测试用例的输出应类似于 $[[n_1,\\Delta a_1,e_{1,d},e_{1,x}],[n_2,\\Delta a_2,e_{2,d},e_{2,x}]]$。要求的输出必须只有一行，没有附加文本。\n\n所有答案都表示为无量纲十进制数。不使用角度。在给定指定种子的情况下，输出必须是确定性的，并且必须遵守上述格式。", "solution": "我们从牛顿第二定律出发，对于粒子 $i$，其形式为 $d^2 \\boldsymbol{x}_i / dt^2 = \\boldsymbol{a}_i(\\{\\boldsymbol{x}\\})$，其中 $\\boldsymbol{a}_i$ 由成对引力之和确定。在我们的实验中，自变量是尺度因子 $a$，我们将速度定义为相对于 $a$ 的速度，即 $\\boldsymbol{v}_i = d\\boldsymbol{x}_i/da$。将 $a$ 视为演化参数并使力独立于 $a$，这样可以分离出离散时间步进和浮点运算对时间可逆性的影响。对于质量相等 $m_j = 1/N$ 且 $G=1$ 的粒子，成对软化力为\n$$\n\\boldsymbol{a}_{ij} = - \\frac{1}{N} \\frac{\\boldsymbol{x}_i - \\boldsymbol{x}_j}{\\left(\\lVert \\boldsymbol{x}_i - \\boldsymbol{x}_j\\rVert^2 + \\varepsilon^2\\right)^{3/2}},\n$$\n因此 $\\boldsymbol{a}_i = \\sum_{j \\ne i} \\boldsymbol{a}_{ij}$。Plummer 软化长度 $\\varepsilon$ 通过将 $r^{-3}$ 替换为 $(r^2 + \\varepsilon^2)^{-3/2}$ 来防止在小距离下的奇异力，这是 $N$体计算中常用且经过充分检验的正则化方法。\n\n我们使用 kick-drift-kick (KDK) 次序的时间中心蛙跳格式对尺度因子 $a$ 的演化进行离散化。设 $\\Delta a$ 为固定步长。该格式通过以下步骤更新一个完整步长内的位置和速度：首先使用当前位置的加速度对速度施加半步 kick，然后使用更新后的速度在整个步长上漂移 (drift) 位置，最后使用新位置的加速度施加第二次半步 kick。用 $(\\{\\boldsymbol{x}_i^{(n)}\\}, \\{\\boldsymbol{v}_i^{(n)}\\})$ 表示第 $n$ 步的状态。尽管存在速度交错半步的等效表述，但 KDK 组合可以写成一个在精确算术下精确时间可逆的对称映射：将步长为 $+\\Delta a$ 的映射与步长为 $-\\Delta a$ 的映射复合，得到恒等映射，\n$$\n\\mathcal{M}_{-\\Delta a} \\circ \\mathcal{M}_{+\\Delta a} = \\mathcal{I},\n$$\n因为子步骤序列（半步 kick、drift、半步 kick）被对称地撤销（符号相反的半步 kick、符号相反的 drift、符号相反的半步 kick）。这种对称性源于哈密顿量可以分离为动能和势能部分，并构成了蛙跳法辛性和可逆性的基础。\n\n然而，在浮点计算机上，算术运算会被舍入到有限的尾数。在 IEEE $754$ binary 64 (双精度) 中，单位舍入误差大约为 $u_{64} \\approx 2^{-53} \\approx 1.11 \\times 10^{-16}$，而在 binary 128 (四精度) 中，单位舍入误差大约为 $u_{128} \\approx 2^{-113} \\approx 9.63 \\times 10^{-35}$。在精确算术中，每次浮点加法和乘法都会引入一个与单位舍入误差同量级的相对误差。经过 $N_{\\text{step}}$ 步后，当误差不相关时，舍入误差的累积近似表现为随机游走，导致误差随舍入事件数量的平方根 $\\sqrt{N_{\\text{step}}}$ 呈均方根增长。此外，算术操作数的大小（例如，乘积 $\\Delta a \\, \\boldsymbol{a}_i$）设定了绝对舍入误差的尺度。因此，我们预期在一次前向-后向演化后测得的相空间失配 $E$ 大致按以下方式缩放\n$$\nE \\sim C \\, \\sqrt{N_{\\text{step}}} \\, u \\, S(\\Delta a, \\{\\boldsymbol{x}\\}, \\{\\boldsymbol{v}\\}),\n$$\n其中 $C$ 是一个捕捉每步平均舍入操作数的常数，而 $S$ 是从状态和步长导出的一个尺度因子。重要的是，$E$ 仅反映了映射的浮点不可逆性，而不是蛙跳积分器的截断误差，因为后向运行使用负步长 $-\\Delta a$ 和完全相同的离散映射，这在精确算术中会完美地反演。\n\n实验的算法设计：\n1.  用固定种子初始化一个可复现的随机快照。从 $[-1/2, 1/2]$ 的均匀分布中抽取初始位置 $\\boldsymbol{x}_i^{(0)}$ 的每个分量，从 $[-v_0, v_0]$ 的均匀分布中抽取初始速度 $\\boldsymbol{v}_i^{(0)}$ 的每个分量，然后减去平均速度，使 $\\sum_i \\boldsymbol{v}_i^{(0)} = \\boldsymbol{0}$。在无量纲代码单位中，采用 $v_0 = 5 \\times 10^{-2}$ 和软化长度 $\\varepsilon = 10^{-3}$。\n2.  使用软化力定律实现加速度 $\\boldsymbol{a}_i$ 的 $O(N^2)$ 矢量化计算。对于每一对 $(i,j)$ 且 $i \\ne j$，累加 $-(1/N) \\, \\boldsymbol{r}_{ij} / (r_{ij}^2 + \\varepsilon^2)^{3/2}$，其中 $\\boldsymbol{r}_{ij} = \\boldsymbol{x}_i - \\boldsymbol{x}_j$。\n3.  以固定步长 $\\Delta a$ 实现 KDK 积分器，作为半步 kick、drift 和半步 kick 的组合，在适当的位置重新评估加速度。为确保离散层面的精确组合对称性，通过从前向演化后的状态开始，使用步长 $-\\Delta a$ 调用相同的 KDK 例程来实现后向演化。\n4.  对于每个测试用例 $(N_{\\text{step}}, \\Delta a)$，在两种精度（binary 64 和 binary 128，如果可用，或最宽的扩展精度）下运行前向-后向演化，并计算由下式定义的相空间失配 $E$\n$$\nE = \\sqrt{\\frac{1}{3N}\\sum_{i=1}^N \\left( \\lVert \\boldsymbol{x}_i^{(b)} - \\boldsymbol{x}_i^{(0)} \\rVert^2 + \\lVert \\boldsymbol{v}_i^{(b)} - \\boldsymbol{v}_i^{(0)} \\rVert^2 \\right)}.\n$$\n5. 将所有测试用例的结果汇总成要求的单行输出格式：一个列表的列表，每个内部列表包含 $[N_{\\text{step}}, \\Delta a, E_{\\text{double}}, E_{\\text{extended}}]$。\n\n预期的定性行为：\n- 当总算术操作数增加时，$E_{\\text{double}}$ 应随 $N_{\\text{step}}$ 增加，近似于 $\\sqrt{N_{\\text{step}}}$，比例系数取决于 $\\Delta a$ 和快照的动力学尺度。\n- 如果更宽的精度具有更小的单位舍入误差，$E_{\\text{extended}}$ 应显著小于 $E_{\\text{double}}$。但在某些平台上，扩展精度可能等于双精度；在这种情况下 $E_{\\text{extended}} \\approx E_{\\text{double}}$。\n- 对于总演化跨度 $N_{\\text{step}} \\Delta a$ 相似但 $N_{\\text{step}}$ 和 $\\Delta a$ 不同的测试用例，前向-后向失配主要由舍入误差决定，而非截断误差，因此在固定的 $N_{\\text{step}} \\Delta a$ 下增加 $N_{\\text{step}}$ 应会增加 $E$。\n\n所有报告的量均为无量纲十进制数，不使用角度单位。程序的输出由指定的种子和参数完全确定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_accelerations(x, mass, eps, dtype):\n    \"\"\"\n    Compute Plummer-softened gravitational accelerations for N particles in 3D.\n    x: (N,3) positions, dtype\n    mass: (N,) masses, dtype\n    eps: scalar softening, dtype\n    dtype: numpy dtype to use for computation\n    Returns: (N,3) accelerations, dtype\n    \"\"\"\n    # Ensure dtype\n    x = x.astype(dtype, copy=False)\n    mass = mass.astype(dtype, copy=False)\n    N = x.shape[0]\n    # Pairwise displacement r_ij = x_i - x_j\n    rij = x[:, None, :] - x[None, :, :]  # (N,N,3)\n    # Squared distances with softening\n    r2 = np.sum(rij * rij, axis=2) + dtype(eps) * dtype(eps)  # (N,N)\n    # Avoid self-interaction by setting diagonal to infinity so inv_r3 -> 0\n    # Work on a copy to not modify original distances elsewhere\n    r2 = r2.copy()\n    # Set diagonal to infinity for safe invert\n    inf = np.array(np.inf, dtype=dtype)\n    idx = np.arange(N)\n    r2[idx, idx] = inf\n    # Compute inverse r^3: 1 / (r2 * sqrt(r2))\n    # Use dtype-aware operations\n    inv_r = 1.0 / np.sqrt(r2)\n    inv_r3 = inv_r * inv_r * inv_r  # (N,N)\n    # Weight by source masses m_j\n    w = inv_r3 * mass[None, :]  # (N,N)\n    # Acceleration: a_i = - sum_j w_ij * rij_ij\n    a = -np.sum(rij * w[:, :, None], axis=1)\n    return a\n\ndef leapfrog_kdk(x0, v0, mass, eps, nsteps, da, dtype):\n    \"\"\"\n    Kick-Drift-Kick leapfrog integrator for step da, nsteps steps.\n    This implementation uses the velocity Verlet form which is equivalent to KDK.\n    x0, v0: (N,3) arrays, dtype\n    mass: (N,) array, dtype\n    eps: scalar softening, dtype\n    da: scalar step, dtype\n    dtype: numpy dtype\n    Returns: (xf, vf) after nsteps\n    \"\"\"\n    x = x0.astype(dtype, copy=True)\n    v = v0.astype(dtype, copy=True)\n    da = dtype(da)\n    half = dtype(0.5)\n\n    a = compute_accelerations(x, mass, eps, dtype)\n    for i in range(nsteps):\n        # First half-kick\n        v += half * da * a\n        # Full drift\n        x += da * v\n        # Compute new accelerations at new positions\n        a = compute_accelerations(x, mass, eps, dtype)\n        # Second half-kick\n        v += half * da * a\n    return x, v\n\ndef forward_backward_mismatch(x0_f64, v0_f64, masses_f64, eps, nsteps, da, dtype):\n    \"\"\"\n    Perform forward-backward integration and compute phase-space mismatch E.\n    Inputs in float64 for reproducibility of initial state; cast to dtype internally.\n    dtype: np.float64 or np.longdouble\n    Returns: mismatch E as Python float\n    \"\"\"\n    # Cast initial conditions to target dtype\n    x0 = x0_f64.astype(dtype, copy=True)\n    v0 = v0_f64.astype(dtype, copy=True)\n    masses = masses_f64.astype(dtype, copy=True)\n    # Forward integrate\n    xf, vf = leapfrog_kdk(x0, v0, masses, eps, nsteps, da, dtype)\n    # Backward integrate from forward state with negative step\n    xb, vb = leapfrog_kdk(xf, vf, masses, eps, nsteps, -da, dtype)\n    # Compute RMS phase-space mismatch\n    dx = xb - x0\n    dv = vb - v0\n    # Sum of squared differences over all components\n    num = np.sum(dx * dx) + np.sum(dv * dv)\n    denom = x0.size  # number of position components = 3N\n    E = np.sqrt(num / (denom))\n    # Convert to Python float for printing\n    return float(E)\n\ndef solve():\n    # Fixed random seed for reproducibility\n    rng = np.random.default_rng(seed=42)\n    # Problem parameters\n    N = 12\n    eps = 1e-3\n    v0_param = 5e-2\n    # Initial positions and velocities in float64\n    x0_init = rng.uniform(-0.5, 0.5, size=(N, 3)).astype(np.float64)\n    v0_init = rng.uniform(-v0_param, v0_param, size=(N, 3)).astype(np.float64)\n    # Zero center-of-mass velocity\n    v0_init -= np.mean(v0_init, axis=0, keepdims=True)\n    masses_init = np.full(N, 1.0 / N, dtype=np.float64)\n    # Test suite: list of (N_steps, da)\n    test_cases = [\n        (1, 1e-3),\n        (50, 2e-3),\n        (200, 5e-4),\n        (500, 2e-4),\n    ]\n    results = []\n    for nsteps, da in test_cases:\n        # Double precision\n        E_double = forward_backward_mismatch(x0_init, v0_init, masses_init, eps, nsteps, da, np.float64)\n        # Extended precision (longdouble)\n        E_ext = forward_backward_mismatch(x0_init, v0_init, masses_init, eps, nsteps, da, np.longdouble)\n        results.append([float(nsteps), float(da), E_double, E_ext])\n    # Print in the exact required format: single line, list of lists\n    # Using json is a robust way to get this format without spaces.\n    import json\n    # Custom encoder to handle numpy types if they sneak in, and format floats correctly\n    class NpEncoder(json.JSONEncoder):\n        def default(self, obj):\n            if isinstance(obj, np.integer):\n                return int(obj)\n            if isinstance(obj, np.floating):\n                return float(obj)\n            if isinstance(obj, np.ndarray):\n                return obj.tolist()\n            return super(NpEncoder, self).default(obj)\n    \n    # The required format is [[...],[...]], not a json string, but creating a list and printing it is the goal\n    print(str(results).replace(\" \", \"\"))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3501446"}]}