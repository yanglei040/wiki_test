{"hands_on_practices": [{"introduction": "虽然标准的龙格-库塔方法功能强大，但有时问题的特定数学结构允许我们设计出精度极高甚至完全精确的数值方案。本练习将引导你为在德西特时空中运动的粒子实现标准龙格-库塔方法，并将其与一个利用问题结构设计的定制方法进行比较。通过这个实践，你将亲身体会到分析洞察力在数值工作中带来的巨大优势，并理解如何构建能够精确保持解析解的积分器 [@problem_id:3484668]。", "problem": "考虑一个空间平坦的 Friedmann–Lemaître–Robertson–Walker 时空，在共形坐标下其线元写作 $ds^2 = a(\\eta)^2 \\left(-d\\eta^2 + d\\mathbf{x}^2\\right)$，其中 $\\eta$ 是共形时间，$a(\\eta)$ 是标度因子。在 de Sitter 时空中，共形时间下的标度因子为 $a(\\eta) = -\\dfrac{1}{H \\eta}$，其中哈勃参数 $H0$ 为常数，且 $\\eta  0$。在几何单位制下进行计算，其中光速设为 $c=1$，因此代码中所有量均为无量纲量；不要打印任何单位。\n\n一个静止质量为 $m \\ge 0$ 的自由传播相对论性粒子，在一维空间中运动，其共动位置为 $x(\\eta)$，拥有一个守恒的共动量 $q$，满足 $q = a(\\eta) p_{\\mathrm{phys}}(\\eta)$，其中 $p_{\\mathrm{phys}}(\\eta)$ 是物理动量。利用相对论能量-动量关系，共形时间下的运动方程可以表示为以下一阶常微分方程组\n$$\n\\frac{dx}{d\\eta} = \\frac{q}{\\sqrt{m^2 a(\\eta)^2 + q^2}}, \\qquad \\frac{dq}{d\\eta} = 0,\n$$\n其初始数据为 $x(\\eta_0) = x_0$ 和 $q(\\eta_0) = q_0 \\ne 0$，其中 $\\eta_0  0$。\n\n您的任务是为此系统构建三种龙格-库塔积分方案，并通过适当的阶段设计，严格测试针对 $a(\\eta) = -\\dfrac{1}{H\\eta}$ 这种特定情况所产生的精确解保持性质：\n\n- 方案 A (显式中点法，二阶)：对 $(x,q)$ 系统应用经典的显式中点龙格-库塔法（也称为二阶龙格-库塔法），步长为 $h  0$，并将 $q$ 视为由 $\\dfrac{dq}{d\\eta} = 0$ 控制的动力学变量。\n\n- 方案 B (经典的四阶显式龙格-库塔法)：对 $(x,q)$ 系统应用标准的四阶段法，其 Butcher 权重为 $b = \\left[\\dfrac{1}{6}, \\dfrac{1}{3}, \\dfrac{1}{3}, \\dfrac{1}{6}\\right]$，横坐标为 $c = [0, \\tfrac{1}{2}, \\tfrac{1}{2}, 1]$，步长为 $h$。\n\n- 方案 C (通过辅助变量进行阶段设计的精确解保持龙格-库塔法)：引入辅助变量 $y(\\eta) := q^2 \\eta^2 + \\mu^2$，其中 $\\mu := \\dfrac{m}{H}$。观察到 $y(\\eta)$ 满足一个仅依赖于时间的标量一阶常微分方程，即 $\\dfrac{dy}{d\\eta} = 2 q^2 \\eta$。构建一个三阶段显式龙格-库塔法，其权重与辛普森求积法则一致，即阶段横坐标 $c = [0, \\tfrac{1}{2}, 1]$ 和权重 $b = \\left[\\dfrac{1}{6}, \\dfrac{2}{3}, \\dfrac{1}{6}\\right]$，并将其应用于 $\\dfrac{dy}{d\\eta} = 2 q^2 \\eta$，使得 $y$ 在一步内的更新成为对 $y'$ 的精确求积，因为 $y'$ 是关于 $\\eta$ 的一次多项式。然后，将此与以下精确的代数关系相结合\n$$\nx(\\eta) = x(\\eta_n) - \\frac{1}{q}\\left(\\sqrt{y(\\eta)} - \\sqrt{y(\\eta_n)}\\right)\n$$\n在从 $\\eta_n$ 到 $\\eta_{n+1} = \\eta_n + h$ 的每一步上，使得该方法按如下方式推进 $x$\n$$\nx_{n+1} = x_n - \\frac{1}{q}\\left(\\sqrt{y_{n+1}} - \\sqrt{y_n}\\right),\n$$\n由于 $\\dfrac{dq}{d\\eta}=0$，在所有三种方案下 $q$ 均为常数。此阶段设计应在任意步长 $h$ 下（在浮点舍入误差范围内）保持 $x(\\eta)$ 的精确解，这特定于 de Sitter 标度因子 $a(\\eta)=-\\dfrac{1}{H\\eta}$。\n\n从度规定义和在均匀各向同性背景下共动量守恒这两个基本点出发，可以推导出 de Sitter 时空中 $x(\\eta)$ 的闭式精确解。使用该精确解计算每个方案在最终时间的绝对误差。\n\n实现一个单一的程序，对于以下测试套件，将解从 $\\eta=\\eta_0$ 推进到 $\\eta=\\eta_1$（其中 $\\eta_0  \\eta_1  0$；使用正的 $h$ 并调整最后一步以精确到达 $\\eta_1$），并为每个测试案例报告一个包含三个浮点数的列表，这三个数分别是方案 A、方案 B 和方案 C 产生的 $x(\\eta_1)$ 的绝对误差。共动量 $q(\\eta)$ 必须在每个龙格-库塔方法内部作为动力学变量通过 $\\dfrac{dq}{d\\eta}=0$ 进行更新（这应能精确地保持其值）。所有计算都将在无量纲的几何单位制中进行；不要打印任何单位。\n\n测试套件参数，须严格按此使用：\n\n- 案例 1 (正常路径相对论性)：$H = 1.0$, $m = 1.0$, $q_0 = 2.0$, $x_0 = 0.3$, $\\eta_0 = -1.0$, $\\eta_1 = -0.1$, $h = 0.05$。\n\n- 案例 2 (超相对论性且接近 $\\eta \\to 0^-$)：$H = 1.0$, $m = 10^{-4}$, $q_0 = 1.0$, $x_0 = -0.2$, $\\eta_0 = -1.0$, $\\eta_1 = -10^{-2}$, $h = 0.01$。\n\n- 案例 3 (非相对论性重粒子)：$H = 0.5$, $m = 10.0$, $q_0 = 0.2$, $x_0 = 1.0$, $\\eta_0 = -2.0$, $\\eta_1 = -0.5$, $h = 0.1$。\n\n- 案例 4 (无质量且动量为负)：$H = 1.0$, $m = 0.0$, $q_0 = -3.0$, $x_0 = 0.0$, $\\eta_0 = -1.5$, $\\eta_1 = -0.5$, $h = 0.1$。\n\n最终输出格式要求：您的程序应生成单行输出，包含一个由列表组成的列表，格式为 $[[e_{1A},e_{1B},e_{1C}],[e_{2A},e_{2B},e_{2C}],\\dots]$。每个内部列表包含一个测试案例的三个误差。每个 $e_{ij}$ 都必须是一个浮点数。", "solution": "该问题要求构建并验证三种不同的龙格-库塔积分方案，用于求解 de Sitter 宇宙中相对论性粒子的运动方程。任务的核心是通过将其结果与已知的精确解析解进行比较来分析其准确性，特别关注一个定制设计的方案（方案 C），该方案预计在机器精度范围内是精确的。\n\n首先，必须确立模型的物理和数学有效性。时空是一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 模型，其线元为 $ds^2 = a(\\eta)^2(-d\\eta^2 + d\\mathbf{x}^2)$。对于 de Sitter 宇宙，标度因子被指定为 $a(\\eta) = -1/(H\\eta)$，其中 $H  0$ 是常数哈勃参数，$\\eta  0$ 是共形时间。一个静止质量为 $m$ 的粒子的运动方程被给定为其共动位置 $x(\\eta)$ 和守恒的共动量 $q(\\eta)$ 的一阶系统：\n$$\n\\frac{dx}{d\\eta} = \\frac{q}{\\sqrt{m^2 a(\\eta)^2 + q^2}}, \\qquad \\frac{dq}{d\\eta} = 0\n$$\n这些方程在宇宙学中是标准的。第一个方程源于共动速度 $d\\mathbf{x}/d\\eta$ 与物理动量与物理能量之比 $\\mathbf{p}_{\\text{phys}}/E_{\\text{phys}}$ 之间的关系，结合了相对论能量-动量关系 $E_{\\text{phys}}^2 = p_{\\text{phys}}^2 + m^2$（其中 $c=1$）以及动量的红移 $p_{\\text{phys}} = q/a$。第二个方程 $dq/d\\eta=0$ 表示了自由粒子在均匀各向同性背景下共动量的守恒。该系统是一个适定的初值问题。\n\n为量化数值方案的误差，我们必须首先推导 $x(\\eta)$ 的精确解析解。由于 $q$ 是常数，我们可以直接对 $x$ 的方程进行积分。将 de Sitter 标度因子 $a(\\eta) = -1/(H\\eta)$ 代入 $x$ 的常微分方程中，得到：\n$$\n\\frac{dx}{d\\eta} = \\frac{q}{\\sqrt{q^2 + m^2 / (H^2 \\eta^2)}} = \\frac{q}{\\sqrt{(q^2 \\eta^2 + m^2/H^2)/\\eta^2}}\n$$\n鉴于 $\\eta  0$，我们有 $\\sqrt{\\eta^2} = -\\eta$。该表达式简化为：\n$$\n\\frac{dx}{d\\eta} = \\frac{-q\\eta}{\\sqrt{q^2 \\eta^2 + (m/H)^2}}\n$$\n将此方程从初始时间 $\\eta_0$（位置为 $x_0 = x(\\eta_0)$）积分到稍后的时间 $\\eta$，得到位置的变化：\n$$\nx(\\eta) - x(\\eta_0) = \\int_{\\eta_0}^{\\eta} \\frac{-q\\eta'}{\\sqrt{q^2 (\\eta')^2 + (m/H)^2}} d\\eta'\n$$\n这个积分可以精确求解，例如，通过换元 $u = q^2 (\\eta')^2 + (m/H)^2$，得到 $du = 2q^2 \\eta' d\\eta'$。定积分的结果是：\n$$\nx(\\eta) - x(\\eta_0) = \\left[ -\\frac{1}{q} \\sqrt{q^2 (\\eta')^2 + (m/H)^2} \\right]_{\\eta_0}^{\\eta}\n$$\n这为任意时间 $\\eta$ 的共动位置提供了精确解：\n$$\nx(\\eta) = x(\\eta_0) - \\frac{1}{q} \\left( \\sqrt{q^2 \\eta^2 + (m/H)^2} - \\sqrt{q^2 \\eta_0^2 + (m/H)^2} \\right)\n$$\n此公式将用作基准真相，以计算每个方案在最终时间 $\\eta_1$ 的绝对误差 $|x_{\\text{numerical}}(\\eta_1) - x_{\\text{exact}}(\\eta_1)|$。\n\n数值积分从 $\\eta_0$ 推进到 $\\eta_1  \\eta_0$，基本步长为 $h  0$。为了精确到达 $\\eta_1$，最后一步的步长被调整为 $h_{\\text{final}} = \\eta_1 - \\eta_{\\text{current}}$。我们将状态向量定义为 $\\mathbf{S} = [x, q]^T$，常微分方程组的右侧项为 $\\mathbf{F}(\\mathbf{S}, \\eta)$。由于 $dq/d\\eta = 0$，对于任何有效的数值积分器，$\\mathbf{S}$ 的 $q$ 分量将保持不变。\n\n方案 A 是显式中点法，一个二阶龙格-库塔方案。从 $\\eta_n$ 到 $\\eta_{n+1} = \\eta_n + h$ 的单步计算如下：\n$$\n\\mathbf{k}_1 = \\mathbf{F}(\\mathbf{S}_n, \\eta_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(\\mathbf{S}_n + \\frac{h}{2}\\mathbf{k}_1, \\eta_n + \\frac{h}{2}) \\\\\n\\mathbf{S}_{n+1} = \\mathbf{S}_n + h \\mathbf{k}_2\n$$\n\n方案 B 是经典的四阶显式龙格-库塔法。其单步更新规则是：\n$$\n\\mathbf{k}_1 = \\mathbf{F}(\\mathbf{S}_n, \\eta_n) \\\\\n\\mathbf{k}_2 = \\mathbf{F}(\\mathbf{S}_n + \\frac{h}{2}\\mathbf{k}_1, \\eta_n + \\frac{h}{2}) \\\\\n\\mathbf{k}_3 = \\mathbf{F}(\\mathbf{S}_n + \\frac{h}{2}\\mathbf{k}_2, \\eta_n + \\frac{h}{2}) \\\\\n\\mathbf{k}_4 = \\mathbf{F}(\\mathbf{S}_n + h\\mathbf{k}_3, \\eta_n + h) \\\\\n\\mathbf{S}_{n+1} = \\mathbf{S}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n\n方案 C 是一种利用该问题结构的专门方法。它引入了一个辅助变量 $y(\\eta) := q^2 \\eta^2 + \\mu^2$，其中 $\\mu := m/H$。对 $y(\\eta)$ 关于 $\\eta$ 求导，得到一个只依赖于时间的更简单的常微分方程：\n$$\n\\frac{dy}{d\\eta} = 2q^2\\eta\n$$\n该方案使用一个 3 阶段显式龙格-库塔法来积分此方程，其 Butcher 权重 $b = [1/6, 2/3, 1/6]$ 和横坐标 $c = [0, 1/2, 1]$ 对应于辛普森求积法则。对于形式为 $y' = f(\\eta)$ 的常微分方程，一个龙格-库塔步等价于一个求积评估：$y_{n+1} = y_n + h \\sum_i b_i f(\\eta_n + c_i h)$。已知辛普森法则对于最高三次的多项式是精确的。由于右侧项 $2q^2\\eta$ 是关于 $\\eta$ 的一次多项式，此数值求积是精确的。因此，该方案计算出的值 $y_{n+1}$ 精确等于 $y(\\eta_{n+1})$，误差仅为浮点误差。然后使用从解析解中推导出的精确代数关系来更新 $x$：\n$$\nx_{n+1} = x_n - \\frac{1}{q}\\left(\\sqrt{y_{n+1}} - \\sqrt{y_n}\\right)\n$$\n由于 $y(\\eta)$ 的更新和随后的 $x(\\eta)$ 计算都是精确的，方案 C 预计能在任何步长 $h$ 下保持精确解，误差仅源于浮点运算。\n\n最终的实现计算了每个方案在给定测试套件下的绝对误差，并将输出格式化为列表的列表。", "answer": "```python\nimport numpy as np\n\ndef get_ode_rhs_func(H, m):\n    \"\"\"\n    Returns the function F(state, eta) for the ODE system d(x,q)/d(eta).\n    \"\"\"\n    def F(state, eta):\n        _x, q = state\n        # The problem statement ensures eta  0, so eta != 0.\n        a_sq = 1.0 / (H**2 * eta**2)\n        denominator = np.sqrt(m**2 * a_sq + q**2)\n        \n        # Handle the case where the denominator might be zero if q=0 and m=0.\n        # Problem statement says q0 != 0, so q is never 0.\n        dxdeta = q / denominator\n        dqdeta = 0.0\n        \n        return np.array([dxdeta, dqdeta])\n    return F\n\ndef solve_scheme_A(params):\n    \"\"\"\n    Solves the ODE system using Scheme A (Explicit Midpoint / RK2).\n    \"\"\"\n    H, m, q0, x0, eta0, eta1, h = params\n    \n    F = get_ode_rhs_func(H, m)\n    \n    state = np.array([x0, q0], dtype=np.float64)\n    eta = eta0\n    \n    while not np.isclose(eta, eta1):\n        h_step = min(h, eta1 - eta)\n        if h_step  1e-15:  # Avoid negligible steps due to floating point arithmetic\n            break\n\n        k1 = F(state, eta)\n        mid_state = state + 0.5 * h_step * k1\n        mid_eta = eta + 0.5 * h_step\n        \n        k2 = F(mid_state, mid_eta)\n        \n        state = state + h_step * k2\n        eta += h_step\n        \n    return state[0]\n\ndef solve_scheme_B(params):\n    \"\"\"\n    Solves the ODE system using Scheme B (Classical RK4).\n    \"\"\"\n    H, m, q0, x0, eta0, eta1, h = params\n\n    F = get_ode_rhs_func(H, m)\n    \n    state = np.array([x0, q0], dtype=np.float64)\n    eta = eta0\n    \n    while not np.isclose(eta, eta1):\n        h_step = min(h, eta1 - eta)\n        if h_step  1e-15:\n            break\n            \n        k1 = F(state, eta)\n        k2 = F(state + 0.5 * h_step * k1, eta + 0.5 * h_step)\n        k3 = F(state + 0.5 * h_step * k2, eta + 0.5 * h_step)\n        k4 = F(state + h_step * k3, eta + h_step)\n        \n        state = state + (h_step / 6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n        eta += h_step\n        \n    return state[0]\n\ndef solve_scheme_C(params):\n    \"\"\"\n    Solves the ODE system using Scheme C (Exact-preserving method).\n    \"\"\"\n    H, m, q0, x0, eta0, eta1, h = params\n    \n    q = q0\n    mu_sq = (m / H)**2\n    \n    # State is (x, y) where y = q^2*eta^2 + mu^2\n    y = mu_sq + q**2 * eta0**2\n    x = x0\n    eta = eta0\n\n    def F_y(eta_val, q_val):\n        return 2.0 * q_val**2 * eta_val\n\n    while not np.isclose(eta, eta1):\n        h_step = min(h, eta1 - eta)\n        if h_step  1e-15:\n            break\n        \n        # Simpson's rule RK method for y(eta)\n        k1_y = F_y(eta, q)\n        k2_y = F_y(eta + 0.5 * h_step, q)\n        k3_y = F_y(eta + h_step, q)\n        \n        # Weights are b = [1/6, 2/3, 1/6]. Note 2/3 = 4/6.\n        y_next = y + (h_step / 6.0) * (k1_y + 4.0 * k2_y + k3_y)\n        \n        # Exact algebraic update for x\n        x_next = x - (1.0 / q) * (np.sqrt(y_next) - np.sqrt(y))\n        \n        x = x_next\n        y = y_next\n        eta += h_step\n        \n    return x\n\ndef get_exact_x(params, final_eta):\n    \"\"\"\n    Calculates the exact solution for x at a given final time.\n    \"\"\"\n    H, m, q0, x0, eta0, _, _ = params\n    \n    mu_sq = (m / H)**2\n    \n    y_final = mu_sq + q0**2 * final_eta**2\n    y_initial = mu_sq + q0**2 * eta0**2\n    \n    delta_x = - (1.0 / q0) * (np.sqrt(y_final) - np.sqrt(y_initial))\n    \n    return x0 + delta_x\n\ndef solve():\n    test_cases = [\n        # (H,     m,    q0,   x0,   eta0,  eta1,     h)\n        (1.0,   1.0,   2.0,  0.3, -1.0, -0.1,    0.05),\n        (1.0, 1e-4,  1.0, -0.2, -1.0, -1e-2,   0.01),\n        (0.5,  10.0,  0.2,  1.0, -2.0, -0.5,    0.1),\n        (1.0,   0.0,  -3.0,  0.0, -1.5, -0.5,    0.1),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        _, _, _, _, _, eta1, _ = case\n        \n        x_exact_final = get_exact_x(case, eta1)\n        \n        x_final_A = solve_scheme_A(case)\n        x_final_B = solve_scheme_B(case)\n        x_final_C = solve_scheme_C(case)\n        \n        error_A = abs(x_final_A - x_exact_final)\n        error_B = abs(x_final_B - x_exact_final)\n        error_C = abs(x_final_C - x_exact_final)\n        \n        all_results.append([error_A, error_B, error_C])\n        \n    inner_formatted_results = []\n    for res_list in all_results:\n        inner_str = f\"[{','.join(str(err) for err in res_list)}]\"\n        inner_formatted_results.append(inner_str)\n    \n    final_output_string = f\"[{','.join(inner_formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3484668"}, {"introduction": "许多物理系统，包括由弗里德曼方程描述的膨胀宇宙，都受到必须始终满足的代数约束。标准的数值方法在长时间积分后会逐渐偏离这些约束，导致非物理的结果。本练习将聚焦于实现并比较几种旨在强制执行弗里德曼约束的技术，包括步后投影法和级约束法，这是构建稳健的宇宙学演化代码的一项关键技能 [@problem_id:3484652]。", "problem": "考虑一个在广义相对论 (GR) 下演化的空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙学模型，其中包含一种状态方程参数为常数 $w$ 的理想流体，其压力 $p$ 和能量密度 $\\rho$ 之间的关系由 $p = w \\rho$ 定义。哈勃参数 $H$ 定义为 $H = \\dot{a}/a$，其中 $a$ 是宇宙学标度因子。在此背景下，动力学演化由两个从爱因斯坦场方程（特定于 FLRW 对称性）和应力-能量守恒中导出的常微分方程所支配：\n- Raychaudhuri 方程：$\\dot{H} = -4 \\pi G \\left( \\rho + p \\right)$。\n- 连续性方程：$\\dot{\\rho} = -3 H \\left( \\rho + p \\right)$。\n对于一个恒定的状态方程参数 $w$，这些方程简化为：\n$\\dot{H} = -4 \\pi G (1+w) \\rho$ 和 $\\dot{\\rho} = -3 (1+w) H \\rho$。\n这些方程蕴含了空间平坦且宇宙学常数为零的 Friedmann 约束：\n$$\nH^2 = \\dfrac{8\\pi G}{3} \\rho，\n$$\n我们将其表示为完整约束 $g(H,\\rho) = H^2 - \\alpha \\rho = 0$，其中 $\\alpha := \\dfrac{8\\pi G}{3}$。\n\n数值任务是设计显式 Runge–Kutta (RK) 时间积分方案，旨在从满足约束的初始数据开始，在从 $t=0$ 到最终时间 $t=T$ 的步进过程中，在数值上保持该约束。应实现并比较两种方法：\n- 一种阶段约束 RK 方案，通过与 RK 阶段耦合的离散拉格朗日乘子来增强系统的一个分量，以强制每个阶段在阶段性约束导数为零的意义上满足约束。\n- 一种步后投影方案，该方案执行一个标准的 RK 步骤，然后在每一步结束时将结果投影回约束流形 $g(H,\\rho)=0$ 上。\n\n从上面陈述的 Raychaudhuri 和连续性方程这两个基本方程，以及 Friedmann 约束 $H^2 = \\dfrac{8\\pi G}{3} \\rho$ 出发，依据第一性原理推导一种适用于显式 Runge–Kutta 方法的离散拉格朗日乘子强制策略。你的设计必须确保，在每个 RK 阶段，通过仅用一个特定于阶段的离散拉格朗日乘子修改 $\\dot{\\rho}$ 分量，使得从阶段值计算出的瞬时约束漂移 $d g / dt$ 恒为零。使用经典的 4 阶段 4 阶 Runge–Kutta 方法实现阶段约束方案和步后投影方案，并比较它们在保持约束方面的有效性。\n\n在所有计算中，使用的单位制应满足光速 $c=1$。引力常数 $G$ 应被视为一个正常数，并按测试套件中的规定进行数值设置。需要报告的诊断量是所有步末端的最大相对约束残差，\n$$\nr = \\max_{n} \\dfrac{\\left| H_n^2 - \\alpha \\rho_n \\right|}{\\left| H_n^2 \\right| + \\left| \\alpha \\rho_n \\right|}\n$$\n该值是无量纲的，因此最终答案中不需要物理单位。此处，$H_n$ 和 $\\rho_n$ 是第 $n$ 步结束时的数值，$\\alpha = \\dfrac{8\\pi G}{3}$。\n\n你的程序必须实现这两种方案，并为每个测试案例报告一个包含三个浮点数的列表，分别对应于：\n$[$阶段约束 RK 的最大相对约束残差$, $步后投影 RK 的最大相对约束残差$, $无约束的普通 RK 的最大相对约束残差$]$。\n\n测试套件：\n- 案例 A（理想情况，尘埃流体）：$w=0$，$G=1$，$H_0=1$，$T=1$，$N=50$ 步。\n- 案例 B（辐射，更粗的步长）：$w=\\dfrac{1}{3}$，$G=1$，$H_0=1$，$T=1$，$N=20$ 步。\n- 案例 C（大初始膨胀率）：$w=0$，$G=1$，$H_0=10$，$T=0.1$，$N=100$ 步。\n- 案例 D（接近边界的小膨胀率）：$w=0$，$G=1$，$H_0=10^{-3}$，$T=1$，$N=100$ 步。\n\n在所有案例中，使用 $\\rho_0 = \\dfrac{H_0^2}{\\alpha}$ 从约束中初始化 $\\rho_0$，并使用指定的步数向前积分。你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试案例一个子列表，按 A、B、C、D 的顺序排列。例如，输出格式应如下所示：$[[x_A,y_A,z_A],[x_B,y_B,z_B],[x_C,y_C,z_C],[x_D,y_D,z_D]]$，其中每个 $x,y,z$ 都是一个浮点数。", "solution": "该问题是有效的。它在科学上是合理的、自洽的且适定的，描述了计算宇宙学中的一个标准数值练习。我们将继续推导和实现指定的数值方案。\n\n所考虑的动力学系统描述了一个包含理想流体的平坦 FLRW 宇宙的演化。系统的状态由向量 $y(t) = [H(t), \\rho(t)]^T$ 给出，其中 $H$ 是哈勃参数，$\\rho$ 是能量密度。演化由以下常微分方程 (ODE) 系统支配：\n$$\n\\dot{H} = -4 \\pi G (1+w) \\rho =: f_H(H, \\rho)\n$$\n$$\n\\dot{\\rho} = -3 (1+w) H \\rho =: f_\\rho(H, \\rho)\n$$\n其中 $w$ 是恒定的状态方程参数，$G$ 是引力常数。\n\n这个 ODE 系统拥有一个完整约束，这是一个在所有时间都必须被状态变量满足的代数关系。这就是平坦宇宙的 Friedmann 方程：\n$$\ng(H, \\rho) = H^2 - \\alpha \\rho = 0\n$$\n其中 $\\alpha := \\dfrac{8\\pi G}{3}$。从满足 $g(H_0, \\rho_0) = 0$ 的初始状态 $(H_0, \\rho_0)$ 开始的 ODE 的解析解，将在所有后续时间 $t  0$ 满足 $g(H(t), \\rho(t)) = 0$。这可以通过计算约束的时间导数来验证：\n$$\n\\frac{dg}{dt} = \\frac{\\partial g}{\\partial H}\\dot{H} + \\frac{\\partial g}{\\partial \\rho}\\dot{\\rho} = (2H)f_H + (-\\alpha)f_\\rho\n$$\n代入 $f_H$、$f_\\rho$ 和 $\\alpha$ 的表达式：\n$$\n\\frac{dg}{dt} = 2H(-4 \\pi G (1+w) \\rho) - \\left(\\frac{8\\pi G}{3}\\right)(-3 (1+w) H \\rho) = -8\\pi G (1+w) H \\rho + 8\\pi G (1+w) H \\rho = 0\n$$\n这证实了约束流形 $g=0$ 是流的一个不变流形。然而，像 Runge-Kutta 方法这样的标准数值积分器在每一步都会引入离散化误差，导致数值解偏离这个流形。任务是实现并比较三种方案在管理这种约束违背方面的能力。所有方案的基础积分器都是经典的 4 阶段 4 阶 Runge-Kutta (RK4) 方法。\n\n设 $y_n = [H_n, \\rho_n]^T$ 为时间 $t_n$ 时的数值解，并假定其满足约束，即 $g(y_n)=0$。单个步骤计算时间 $t_{n+1} = t_n + \\Delta t$ 时的解 $y_{n+1}$。\n\n**1. 普通 RK4 方案（基准）**\n这是对 ODE 系统 $\\dot{y} = f(y)$ 应用标准的、未经校正的 RK4 算法。\n$$\nk_1 = f(y_n) \\\\\nk_2 = f(y_n + \\frac{\\Delta t}{2} k_1) \\\\\nk_3 = f(y_n + \\frac{\\Delta t}{2} k_2) \\\\\nk_4 = f(y_n + \\Delta t k_3) \\\\\ny_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n$$\n得到的状态 $y_{n+1}$ 通常不会满足约束，即 $g(y_{n+1}) \\neq 0$。该方案用作衡量约束违背增长的基准。\n\n**2. 步后投影 RK4 方案**\n该方法包括两个部分：一个演化步骤和一个投影步骤。\n首先，使用上述的普通 RK4 步骤计算一个临时状态 $\\tilde{y}_{n+1}$。\n$$\n\\tilde{y}_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)\n$$\n这个临时状态 $[\\tilde{H}_{n+1}, \\tilde{\\rho}_{n+1}]^T$ 不会位于约束流形上。其次，将此状态投影回流形 $g=0$ 以获得最终状态 $y_{n+1}$。我们采用一个简单直接的投影：保留计算出的哈勃参数值 $\\tilde{H}_{n+1}$，并校正密度 $\\rho$ 以满足约束。\n$$\nH_{n+1} = \\tilde{H}_{n+1} \\\\\n\\rho_{n+1} = \\frac{H_{n+1}^2}{\\alpha}\n$$\n通过构造，这确保了 $g(y_{n+1}) = H_{n+1}^2 - \\alpha\\rho_{n+1} = 0$，直至机器浮点精度。\n\n**3. 阶段约束 RK4 方案**\n该方案在 RK 阶段内修改动力学，以主动抑制约束违背。问题指定仅修改右端向量场 $f=[f_H, f_\\rho]^T$ 的 $\\dot{\\rho}$ 分量，以确保阶段性约束导数为零。\n\n在每个 RK 阶段 $i$，我们计算一个状态值 $Y_i = [H^{(i)}, \\rho^{(i)}]^T$。目标是定义一个修改后的右端项 $\\tilde{f}^{(i)}$，使得使用此修改后的右端项在阶段值处计算的约束导数消失：\n$$\n\\left.\\frac{dg}{dt}\\right|_{\\text{stage }i} = \\nabla g(Y_i) \\cdot \\tilde{f}^{(i)}(Y_i) = 0\n$$\n通过仅向 $\\rho$ 分量添加一个特定于阶段的拉格朗日乘子 $\\lambda_i$ 来修改右端项：\n$$\n\\tilde{f}^{(i)}(Y_i) = [f_H(Y_i), f_\\rho(Y_i) + \\lambda_i]^T\n$$\n条件变为：\n$$\n\\frac{\\partial g}{\\partial H}(Y_i) \\cdot f_H(Y_i) + \\frac{\\partial g}{\\partial \\rho}(Y_i) \\cdot (f_\\rho(Y_i) + \\lambda_i) = 0\n$$\n代入 $\\frac{\\partial g}{\\partial H} = 2H$ 和 $\\frac{\\partial g}{\\partial \\rho} = -\\alpha$，我们得到：\n$$\n2H^{(i)} f_H(Y_i) - \\alpha (f_\\rho(Y_i) + \\lambda_i) = 0\n$$\n解出拉格朗日乘子 $\\lambda_i$：\n$$\n\\lambda_i = \\frac{2H^{(i)} f_H(Y_i) - \\alpha f_\\rho(Y_i)}{\\alpha}\n$$\n分子恰好是未校正的约束漂移率 $\\nabla g(Y_i) \\cdot f(Y_i)$。因此，$\\rho$ 分量的修改后右端项为 $\\tilde{f}_\\rho(Y_i) = f_\\rho(Y_i) + \\lambda_i = \\frac{2H^{(i)}}{\\alpha} f_H(Y_i)$。\n\nRK4 算法随后修改如下：\n设 $y_n = [H_n, \\rho_n]^T$ 为 $t_n$ 时的状态。\n\n- **阶段 1**：阶段值为 $Y_1 = y_n$。由于 $y_n$ 满足约束，未校正的漂移 $\\nabla g(y_n) \\cdot f(y_n) = 0$。因此，$\\lambda_1 = 0$。第一个斜率使用原始右端项计算：\n$k_1 = f(y_n)$。\n\n- **阶段 2**：阶段值为 $Y_2 = y_n + \\frac{\\Delta t}{2} k_1$。通常，$g(Y_2) \\neq 0$。我们计算修改后的斜率 $k_2$：\n$H^{(2)}, \\rho^{(2)} = Y_2$\n$f_H(Y_2) = -4\\pi G(1+w)\\rho^{(2)}$\n$f_\\rho(Y_2) = -3(1+w)H^{(2)}\\rho^{(2)}$\n$\\lambda_2 = (2H^{(2)}f_H(Y_2) - \\alpha f_\\rho(Y_2)) / \\alpha$\n$k_2 = [f_H(Y_2), f_\\rho(Y_2) + \\lambda_2]^T$。\n\n- **阶段 3**：阶段值为 $Y_3 = y_n + \\frac{\\Delta t}{2} k_2$。我们使用相同的程序计算修改后的斜率 $k_3$：\n$Y_3 = [H^{(3)}, \\rho^{(3)}]^T$\n$\\lambda_3 = (2H^{(3)}f_H(Y_3) - \\alpha f_\\rho(Y_3)) / \\alpha$\n$k_3 = [f_H(Y_3), f_\\rho(Y_3) + \\lambda_3]^T$。\n\n- **阶段 4**：阶段值为 $Y_4 = y_n + \\Delta t k_3$。我们计算修改后的斜率 $k_4$：\n$Y_4 = [H^{(4)}, \\rho^{(4)}]^T$\n$\\lambda_4 = (2H^{(4)}f_H(Y_4) - \\alpha f_\\rho(Y_4)) / \\alpha$\n$k_4 = [f_H(Y_4), f_\\rho(Y_4) + \\lambda_4]^T$。\n\n- **最终更新**：新状态由计算出的斜率组合而成：\n$y_{n+1} = y_n + \\frac{\\Delta t}{6} (k_1 + 2k_2 + 2k_3 + k_4)$。\n\n该方案不保证 $g(y_{n+1}) = 0$ 完全成立，但其构造旨在与普通 RK4 方法相比减少约束违背的增长。对于给定的测试案例，通过计算整个积分周期内的最大相对约束残差来评估所有三种方案的性能。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path, dust fluid)\n        {'w': 0.0, 'G': 1.0, 'H0': 1.0, 'T': 1.0, 'N': 50},\n        # Case B (radiation, coarser step)\n        {'w': 1.0/3.0, 'G': 1.0, 'H0': 1.0, 'T': 1.0, 'N': 20},\n        # Case C (large initial expansion rate)\n        {'w': 0.0, 'G': 1.0, 'H0': 10.0, 'T': 0.1, 'N': 100},\n        # Case D (near-boundary small expansion rate)\n        {'w': 0.0, 'G': 1.0, 'H0': 1e-3, 'T': 1.0, 'N': 100},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = run_case(params)\n        all_results.append(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef run_case(params):\n    \"\"\"\n    Runs the simulation for a single test case using all three schemes.\n    \n    Args:\n        params (dict): A dictionary containing the parameters for the case.\n        \n    Returns:\n        list: A list of three floats corresponding to the max relative constraint\n              residuals for stage-constrained, projection, and plain RK schemes.\n    \"\"\"\n    w = params['w']\n    G = params['G']\n    H0 = params['H0']\n    T = params['T']\n    N = params['N']\n\n    alpha = 8.0 * np.pi * G / 3.0\n    rho0 = H0**2 / alpha\n    dt = T / N\n\n    y_plain = np.array([H0, rho0], dtype=np.float64)\n    y_proj = np.array([H0, rho0], dtype=np.float64)\n    y_stage = np.array([H0, rho0], dtype=np.float64)\n\n    max_res_plain = 0.0\n    max_res_proj = 0.0\n    max_res_stage = 0.0\n\n    # RHS of the ODE system\n    def rhs(y, w_val, G_val):\n        H, rho = y\n        H_dot = -4.0 * np.pi * G_val * (1.0 + w_val) * rho\n        rho_dot = -3.0 * (1.0 + w_val) * H * rho\n        return np.array([H_dot, rho_dot], dtype=np.float64)\n\n    # Plain RK4 step\n    def rk4_step_plain(y_n, w_val, G_val, dt_val):\n        k1 = rhs(y_n, w_val, G_val)\n        k2 = rhs(y_n + dt_val / 2.0 * k1, w_val, G_val)\n        k3 = rhs(y_n + dt_val / 2.0 * k2, w_val, G_val)\n        k4 = rhs(y_n + dt_val * k3, w_val, G_val)\n        return y_n + dt_val / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    # Post-step projection RK4 step\n    def rk4_step_projection(y_n, w_val, G_val, dt_val, alpha_val):\n        y_tilde = rk4_step_plain(y_n, w_val, G_val, dt_val)\n        H_next = y_tilde[0]\n        rho_next = H_next**2 / alpha_val\n        return np.array([H_next, rho_next], dtype=np.float64)\n\n    # Stage-constrained RK4 step\n    def rk4_step_stage_constrained(y_n, w_val, G_val, dt_val, alpha_val):\n        \n        def modified_rhs_at_stage(y_stage, w_v, G_v, a_v):\n            H, rho = y_stage\n            fH = -4.0 * np.pi * G_v * (1.0 + w_v) * rho\n            frho = -3.0 * (1.0 + w_v) * H * rho\n            # Constraint derivative with unmodified RHS\n            dgdt_unmod = 2.0 * H * fH - a_v * frho\n            # Lagrange multiplier correction\n            lambda_correction = dgdt_unmod / a_v\n            return np.array([fH, frho + lambda_correction], dtype=np.float64)\n\n        # Stage 1: Correction is zero as y_n is on the constraint manifold\n        k1 = rhs(y_n, w_val, G_val)\n        \n        # Stage 2\n        y2 = y_n + dt_val / 2.0 * k1\n        k2 = modified_rhs_at_stage(y2, w_val, G_val, alpha_val)\n\n        # Stage 3\n        y3 = y_n + dt_val / 2.0 * k2\n        k3 = modified_rhs_at_stage(y3, w_val, G_val, alpha_val)\n\n        # Stage 4\n        y4 = y_n + dt_val * k3\n        k4 = modified_rhs_at_stage(y4, w_val, G_val, alpha_val)\n        \n        return y_n + dt_val / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    for _ in range(N):\n        y_plain = rk4_step_plain(y_plain, w, G, dt)\n        y_proj = rk4_step_projection(y_proj, w, G, dt, alpha)\n        y_stage = rk4_step_stage_constrained(y_stage, w, G, dt, alpha)\n\n        for scheme_idx, y_current in enumerate([y_stage, y_proj, y_plain]):\n            H_n, rho_n = y_current\n            numerator = abs(H_n**2 - alpha * rho_n)\n            denominator = abs(H_n**2) + abs(alpha * rho_n)\n            \n            if denominator == 0.0:\n                residual = 0.0\n            else:\n                residual = numerator / denominator\n\n            if scheme_idx == 0:\n                max_res_stage = max(max_res_stage, residual)\n            elif scheme_idx == 1:\n                max_res_proj = max(max_res_proj, residual)\n            else:\n                max_res_plain = max(max_res_plain, residual)\n\n    return [max_res_stage, max_res_proj, max_res_plain]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3484652"}, {"introduction": "在将早期宇宙物理与晚期宇宙的可观测结果联系起来时，我们经常会遇到边值问题，而不仅仅是初值问题。本练习将一个自适应步长的龙格-库塔积分器与“打靶法”相结合，以求解宇宙暴胀期间的微扰演化。这个实践不仅展示了如何组合多种数值技术来解决宇宙学前沿研究中的实际问题，还通过利用系统的线性特性，揭示了简化复杂数值任务的巧妙途径 [@problem_id:3484682]。", "problem": "您的任务是构建一个完整的独立程序，该程序为暴胀期间的宇宙学微扰实现一种龙格-库塔打靶法，并使用嵌入式误差控制器来调整数值积分，以及评估边界匹配对初始相位选择的灵敏度。工作应在张量（引力波）模的精确 de Sitter 膨胀背景下进行，专注于单个傅里叶模，并使用共形时间。您的实现必须基于第一性原理和经过充分检验的公式。\n\n考虑具有精确 de Sitter 膨胀的空间平坦 Friedmann–Lemaître–Robertson–Walker (FLRW) 背景，其中，共形时间 $\\eta$ 下的标度因子满足 $a(\\eta) = -\\dfrac{1}{H \\eta}$，其中哈勃率 $H  0$ 为常数。对于每个极化的张量微扰，其正则变量 $\\mu_k(\\eta)$ 满足以下二阶常微分方程\n$$\n\\mu_k''(\\eta) + \\left(k^2 - \\frac{a''(\\eta)}{a(\\eta)}\\right) \\mu_k(\\eta) = 0,\n$$\n其中 $k  0$ 是共动波数，撇号表示对 $\\eta$ 的导数。在精确 de Sitter 空间中，$\\dfrac{a''(\\eta)}{a(\\eta)} = \\dfrac{2}{\\eta^2}$。引入无量纲时间 $x = k \\eta$ 是有利的，这样模方程就变为\n$$\n\\frac{d^2 \\mu}{dx^2} + \\left(1 - \\frac{2}{x^2}\\right)\\mu = 0,\n$$\n其中 $\\mu = \\mu_k$ 现在被视为 $x$ 的函数。在视界深处（$|x| \\gg 1$），正频 Bunch–Davies 初始条件对应于一个平面波。通过一个振幅缩放因子 $s  0$ 和一个相位 $\\phi \\in \\mathbb{R}$（角度以弧度为单位）来参数化在 $x = x_i  0$ 处的初始条件，使得\n$$\n\\mu(x_i) = \\frac{s e^{i\\phi}}{\\sqrt{2k}}, \\quad \\frac{d\\mu}{dx}(x_i) = -i \\mu(x_i).\n$$\n在晚期时间的超视界机制中（$|x| \\ll 1$），每个极化的可观测应变振幅由 $h = \\mu/a$ 得到。对于 $a(\\eta) = -1/(H\\eta)$，用 $x$ 表示为 $a(x) = -k/(H x)$，因此\n$$\n|h(x)| = \\frac{|x|}{k} |\\mu(x)|.\n$$\n\n算法目标：\n- 将二阶复数方程转换为关于实部和虚部的一阶系统，以适用于显式龙格-库塔积分。\n- 实现一种带有自适应步长的嵌入式龙格-库塔方案（例如 Dormand–Prince 型方法或 Runge–Kutta–Fehlberg 方法），该方案使用局部误差估计来控制步长，并启用密集输出，以在边界 $x = x_f$ 处精确评估解。\n- 构建一种打靶法，通过调整初始振幅缩放因子 $s$ 以在 $x=x_f$ 处匹配一个指定的目标晚期振幅 $A_{\\mathrm{target}}$，其方法是在标量目标\n$$\nF(s; k, x_i, x_f, \\phi) = \\frac{|x_f|}{k} |\\mu(x_f; s, \\phi)| - A_{\\mathrm{target}},\n$$\n中求解 $s$，并使用重复的龙格-库塔积分和区间割线法或类似的求根策略，以达到规定的匹配容差。确保在 $x = x_f$ 处的边界评估利用了积分器带有嵌入式误差控制的密集输出多项式。\n\n灵敏度分析：\n- 通过计算给定 $\\Delta\\phi$ 下的绝对差，来量化匹配的缩放因子对初始相位的灵敏度\n$$\n\\Delta s = \\left| s^\\star(\\phi) - s^\\star(\\phi + \\Delta\\phi) \\right|,\n$$\n其中 $s^\\star$ 是通过打靶法获得的缩放因子。\n\n单位和角度规定：\n- 在本问题中，将 $H$ 视为一个常数，在无量纲单位中设为 $H=1$。所有报告的振幅和缩放因子都是无量纲实数。\n- 所有角度必须以弧度提供和解释。\n\n测试套件：\n实现您的程序以评估以下四个测试用例。在每个用例中，定义 $x_i = -N_i$ 和 $x_f = -p_f$，其中 $N_i$ 和 $p_f$ 在下面给出。对于每个测试用例，通过以下公式定义相对于相位 $\\phi=0$ 处的 Bunch–Davies 参考振幅的目标振幅\n$$\nA_{\\mathrm{target}} = r \\times \\left( \\frac{|x_f|}{k} |\\mu(x_f; s=1, \\phi=0)| \\right).\n$$\n对每个用例，计算两个量：使用您的打靶法得到的匹配缩放因子 $s^\\star(\\phi_0)$，以及相位灵敏度 $\\Delta s = |s^\\star(\\phi_0) - s^\\star(\\phi_0 + \\Delta \\phi)|$。\n\n- 用例 1：$k = 1.0$, $N_i = 300$, $p_f = 0.01$, $\\phi_0 = 0.0$, $\\Delta\\phi = \\pi/3$, $r = 0.8$, 匹配容差 $10^{-8}$。\n- 用例 2：$k = 0.05$, $N_i = 500$, $p_f = 0.005$, $\\phi_0 = 0.2$, $\\Delta\\phi = \\pi/2$, $r = 1.1$, 匹配容差 $10^{-8}$。\n- 用例 3：$k = 20.0$, $N_i = 100$, $p_f = 0.02$, $\\phi_0 = 1.0$, $\\Delta\\phi = \\pi/4$, $r = 0.5$, 匹配容差 $10^{-8}$。\n- 用例 4：$k = 1.0$, $N_i = 1000$, $p_f = 0.005$, $\\phi_0 = 2.0$, $\\Delta\\phi = \\pi/3$, $r = 1.0$, 匹配容差 $10^{-8}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的八个结果，按顺序排列，形式为用方括号括起来的逗号分隔列表。顺序必须是\n$$\n\\left[ s^\\star_1, \\Delta s_1, s^\\star_2, \\Delta s_2, s^\\star_3, \\Delta s_3, s^\\star_4, \\Delta s_4 \\right],\n$$\n其中 $s^\\star_j$ 是用例 $j$ 的匹配缩放因子，$\\Delta s_j$ 是其相位灵敏度。每个数字必须表示为浮点数。无需打印物理单位，因为所有值都是无量纲的。整个过程中角度均以弧度为单位。", "solution": "用户的问题是为一项数值宇宙学任务开发一个独立程序，该任务涉及暴胀期间张量微扰的演化。这要求实现一个带有打靶法的龙格-库塔积分方案，以匹配边界条件并分析对初始条件的灵敏度。该问题在科学上是有效的、适定的，并且所有必要的参数都已提供。\n\n解决方案由四个主要步骤构成：\n1.  将控制性的二阶复数常微分方程（ODE）表述为适合数值积分的一阶实数 ODE 系统。\n2.  基于问题的物理（Bunch-Davies）规定，推导该实数系统的初始条件。\n3.  设计数值算法，包括一个自适应龙格-库塔积分器和一个利用底层 ODE 线性特性进行优化的打靶法。\n4.  按照测试用例的要求，详细说明灵敏度分析的步骤。\n\n**1. 转换为一阶实数系统**\n\n复正则变量 $\\mu(x)$ 的控制方程是：\n$$\n\\frac{d^2 \\mu}{dx^2} + \\left(1 - \\frac{2}{x^2}\\right)\\mu = 0\n$$\n为了数值求解此方程，我们首先将 $\\mu(x)$ 分解为其实部和虚部，$\\mu(x) = u(x) + i v(x)$，其中 $u(x)$ 和 $v(x)$ 是实值函数。将此代入 ODE 并分离实部和虚部，得到两个解耦的二阶实数 ODE：\n$$\n\\frac{d^2 u}{dx^2} + \\left(1 - \\frac{2}{x^2}\\right)u = 0\n$$\n$$\n\\frac{d^2 v}{dx^2} + \\left(1 - \\frac{2}{x^2}\\right)v = 0\n$$\n标准的显式龙格-库塔方法是为一阶系统设计的。我们通过定义一个状态向量 $\\mathbf{y}(x) \\in \\mathbb{R}^4$，将这对二阶方程转换为一个包含四个一阶方程的系统：\n$$\n\\mathbf{y}(x) = \\begin{pmatrix} y_1(x) \\\\ y_2(x) \\\\ y_3(x) \\\\ y_4(x) \\end{pmatrix} = \\begin{pmatrix} u(x) \\\\ u'(x) \\\\ v(x) \\\\ v'(x) \\end{pmatrix}\n$$\n其中撇号表示对 $x$ 的微分。那么一阶系统就是 $\\frac{d\\mathbf{y}}{dx} = \\mathbf{f}(x, \\mathbf{y})$，其中向量函数 $\\mathbf{f}$ 为：\n$$\n\\mathbf{f}(x, \\mathbf{y}) = \\begin{pmatrix} y_2 \\\\ -\\left(1 - \\frac{2}{x^2}\\right)y_1 \\\\ y_4 \\\\ -\\left(1 - \\frac{2}{x^2}\\right)y_3 \\end{pmatrix}\n$$\n该系统现在是数值 ODE 求解器所需的标准形式。\n\n**2. 初始条件**\n\n问题指定了在初始“时间” $x = x_i  0$ 时 $\\mu(x)$ 及其导数的初始条件：\n$$\n\\mu(x_i) = \\frac{s e^{i\\phi}}{\\sqrt{2k}} = \\frac{s}{\\sqrt{2k}}(\\cos\\phi + i\\sin\\phi)\n$$\n$$\n\\frac{d\\mu}{dx}(x_i) = -i \\mu(x_i) = -i \\frac{s}{\\sqrt{2k}}(\\cos\\phi + i\\sin\\phi) = \\frac{s}{\\sqrt{2k}}(\\sin\\phi - i\\cos\\phi)\n$$\n通过将这些表达式的实部和虚部与我们的状态向量 $\\mathbf{y}(x_i)$ 的分量相匹配，我们得到一阶系统的初始条件：\n- $y_1(x_i) = u(x_i) = \\mathrm{Re}[\\mu(x_i)] = \\frac{s \\cos\\phi}{\\sqrt{2k}}$\n- $y_3(x_i) = v(x_i) = \\mathrm{Im}[\\mu(x_i)] = \\frac{s \\sin\\phi}{\\sqrt{2k}}$\n- $y_2(x_i) = u'(x_i) = \\mathrm{Re}[\\mu'(x_i)] = \\frac{s \\sin\\phi}{\\sqrt{2k}}$\n- $y_4(x_i) = v'(x_i) = \\mathrm{Im}[\\mu'(x_i)] = -\\frac{s \\cos\\phi}{\\sqrt{2k}}$\n这完全定义了开始积分所需的初始状态向量 $\\mathbf{y}(x_i)$。\n\n**3. 数值积分与打靶法**\n\n任务的核心是找到一个缩放因子 $s$，使其满足在最终时间 $x_f$ 的边界条件：\n$$\nF(s) = \\frac{|x_f|}{k} |\\mu(x_f; s, \\phi)| - A_{\\mathrm{target}} = 0\n$$\n虽然问题建议使用迭代求根方法（例如，割线法），但存在一种更高效、更精确的解法。该控制 ODE 是线性的且齐次的。因此，其解与初始振幅成正比。如果 $\\mu_{\\mathrm{ref}}(x)$ 是使用参考缩放因子 $s=1$ 得到的解，那么对于任何其他缩放因子 $s$，其解就是 $s \\cdot \\mu_{\\mathrm{ref}}(x)$。\n\n这个线性性质使我们能够代数求解正确的缩放因子 $s^\\star$，从而避免了迭代“打靶”循环的需要。\n设 $|\\mu_{\\mathrm{ref}}(x_f; \\phi)|$ 是在 $x_f$ 处的解的模，该解是通过从 $x_i$ 开始积分，初始条件设置为 $s=1$ 和相位 $\\phi$ 得到的。那么对于一个通用的 $s$，其模为 $|\\mu(x_f; s, \\phi)| = s \\cdot |\\mu_{\\mathrm{ref}}(x_f; \\phi)|$。\n将此代入目标函数 $F(s^\\star)=0$ 中得到：\n$$\n\\frac{|x_f|}{k} \\left(s^\\star \\cdot |\\mu_{\\mathrm{ref}}(x_f; \\phi)|\\right) - A_{\\mathrm{target}} = 0\n$$\n求解 $s^\\star$ 得到一个直接的解析表达式：\n$$\ns^\\star(\\phi) = \\frac{A_{\\mathrm{target}} \\cdot k}{|x_f| \\cdot |\\mu_{\\mathrm{ref}}(x_f; \\phi)|}\n$$\n这大大简化了算法。我们不再需要多次积分来收敛到一个根，而是对每个不同的相位 $\\phi$ 只需进行一次积分（使用 $s=1$）即可找到所需的 $s^\\star$。\n\n积分本身将使用高质量的嵌入式龙格-库塔方法执行，具体是 `scipy.integrate.solve_ivp` 中提供的 8(5,3) 阶 Dormand-Prince 方法 `DOP853`。该方法同时提供自适应步长控制和密集输出，从而确保解在指定的终点 $x_f$ 被精确评估。 $10^{-8}$ 的“匹配容差”被解释为 ODE 求解器所需的相对容差（`rtol`），因为最终解 $|\\mu(x_f)|$ 的精度决定了匹配 $s^\\star$ 的精度。\n\n**4. 单个测试用例的算法**\n\n对于每个由参数 $(k, N_i, p_f, \\phi_0, \\Delta\\phi, r, \\text{tol})$ 定义的测试用例，流程如下：\n1.  定义积分区间 $[x_i, x_f] = [-N_i, -p_f]$。\n2.  **确定目标振幅 $A_{\\mathrm{target}}$**：\n    -   使用 $s=1$ 和参考相位 $\\phi=0$ 的初始条件，对 ODE 系统从 $x_i$ 到 $x_f$ 进行积分。\n    -   根据结果计算模 $|\\mu(x_f; s=1, \\phi=0)|$。\n    -   计算参考振幅 $A_{\\mathrm{ref}} = \\frac{|x_f|}{k} |\\mu(x_f; s=1, \\phi=0)|$。\n    -   将目标振幅设为 $A_{\\mathrm{target}} = r \\cdot A_{\\mathrm{ref}}$。\n3.  **计算匹配的缩放因子 $s^\\star(\\phi_0)$**：\n    -   使用 $s=1$ 和指定相位 $\\phi_0$ 的初始条件，对 ODE 系统从 $x_i$ 到 $x_f$ 进行积分。\n    -   获得模 $|\\mu(x_f; s=1, \\phi_0)|$。\n    -   使用直接公式计算 $s^\\star(\\phi_0)$：$s^\\star(\\phi_0) = \\frac{A_{\\mathrm{target}} \\cdot k}{|x_f| \\cdot |\\mu(x_f; s=1, \\phi_0)|}$。\n4.  **计算匹配的缩放因子 $s^\\star(\\phi_0 + \\Delta\\phi)$**：\n    -   对 $s=1$ 和相位 $\\phi = \\phi_0 + \\Delta\\phi$ 重复积分过程。\n    -   获得模 $|\\mu(x_f; s=1, \\phi_0+\\Delta\\phi)|$。\n    -   使用直接公式计算 $s^\\star(\\phi_0 + \\Delta\\phi)$。\n5.  **计算相位灵敏度 $\\Delta s$**：\n    -   计算绝对差 $\\Delta s = |s^\\star(\\phi_0) - s^\\star(\\phi_0 + \\Delta\\phi)|$。\n6.  将数对 $(s^\\star(\\phi_0), \\Delta s)$ 存储为该测试用例的结果。\n\n将为四个指定的测试用例中的每一个实现此完整算法，以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve_case(k, Ni, pf, phi0, d_phi, r, tol):\n    \"\"\"\n    Solves a single test case for the cosmological perturbation problem.\n\n    This function calculates the matched scaling factor s_star(phi0) and the\n    phase sensitivity ds by performing numerical integrations of the mode equation.\n    \"\"\"\n    xi = -float(Ni)\n    xf = -float(pf)\n\n    def odesys(x, y):\n        \"\"\"\n        Defines the first-order system for the complex ODE.\n        y = [u, u', v, v']\n        \"\"\"\n        y1, y2, y3, y4 = y\n        # The potential term is (1 - 2/x^2).\n        potential_factor = -(1.0 - 2.0 / (x * x))\n        return [y2, potential_factor * y1, y4, potential_factor * y3]\n\n    def get_mu_final_norm(phase):\n        \"\"\"\n        Integrates the ODE system for s=1 and a given phase, returning |mu(xf)|.\n        \"\"\"\n        # Set initial conditions based on phase for s=1\n        norm_factor = 1.0 / np.sqrt(2.0 * k)\n        cos_p = np.cos(phase)\n        sin_p = np.sin(phase)\n        \n        y0 = np.array([\n            norm_factor * cos_p,  # u(xi)\n            norm_factor * sin_p,  # u'(xi)\n            norm_factor * sin_p,  # v(xi)\n            -norm_factor * cos_p  # v'(xi)\n        ])\n\n        # Perform the numerical integration using a high-order adaptive method.\n        # solve_ivp's t_eval uses the dense output to get the solution exactly at xf.\n        sol = solve_ivp(\n            odesys,\n            (xi, xf),\n            y0,\n            method='DOP853',\n            t_eval=[xf],\n            rtol=tol,\n            atol=tol * 1e-4 # Set atol smaller than rtol\n        )\n        \n        # Extract the final state vector [u, u', v, v'] at xf\n        yf = sol.y[:, -1]\n        uf_ref = yf[0]\n        vf_ref = yf[2]\n        \n        # Return the magnitude |mu(xf)|\n        return np.sqrt(uf_ref**2 + vf_ref**2)\n\n    # 1. Calculate the target amplitude, A_target.\n    # This is based on a reference integration with s=1 and phi=0.\n    mu_ref_0_norm = get_mu_final_norm(phase=0.0)\n    A_ref = (abs(xf) / k) * mu_ref_0_norm\n    A_target = r * A_ref\n\n    # 2. Find s_star for the primary phase phi0.\n    # This involves one integration for s=1 and phi=phi0.\n    mu_ref_phi0_norm = get_mu_final_norm(phase=phi0)\n    # The linearity of the ODE allows for a direct algebraic solution for s_star.\n    s_star_phi0 = (A_target * k) / (abs(xf) * mu_ref_phi0_norm)\n\n    # 3. Find s_star for the shifted phase phi0 + d_phi.\n    # This involves a second integration for s=1 and phi=phi0+d_phi.\n    mu_ref_phi_delta_norm = get_mu_final_norm(phase=phi0 + d_phi)\n    s_star_phi_delta = (A_target * k) / (abs(xf) * mu_ref_phi_delta_norm)\n\n    # 4. Calculate the phase sensitivity delta_s.\n    delta_s = abs(s_star_phi0 - s_star_phi_delta)\n\n    return s_star_phi0, delta_s\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (k, Ni, pf, phi0, d_phi, r, matching_tolerance)\n    test_cases = [\n        (1.0, 300, 0.01, 0.0, np.pi/3, 0.8, 1e-8),\n        (0.05, 500, 0.005, 0.2, np.pi/2, 1.1, 1e-8),\n        (20.0, 100, 0.02, 1.0, np.pi/4, 0.5, 1e-8),\n        (1.0, 1000, 0.005, 2.0, np.pi/3, 1.0, 1e-8)\n    ]\n\n    results = []\n    for case in test_cases:\n        s_star, ds = solve_case(*case)\n        results.append(s_star)\n        results.append(ds)\n\n    # Final print statement in the exact required format.\n    # Using a format specifier to ensure consistent floating point representation.\n    print(f\"[{','.join(f'{val:.12f}' for val in results)}]\")\n\nsolve()\n```", "id": "3484682"}]}