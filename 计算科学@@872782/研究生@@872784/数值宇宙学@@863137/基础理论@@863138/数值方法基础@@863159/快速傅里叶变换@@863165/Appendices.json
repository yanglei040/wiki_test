{"hands_on_practices": [{"introduction": "为了在宇宙学中有效应用快速傅里叶变换，我们首先必须掌握其实际实现。本练习聚焦于一个针对实值场（例如宇宙密度场）的关键优化：管理由厄米对称性产生的紧凑存储布局。通过实现正确的索引映射[@problem_id:3495399]，您将亲身体验在高性能数值代码中作为标准配置的、内存高效的实数到复数FFT。", "problem": "您正在为一个周期性宇宙学体积中的实标量场实现三维离散傅里叶变换。设该实标量场在一个大小为 $N_x \\times N_y \\times N_z$ 的均匀笛卡尔网格上采样，每个维度都具有周期性边界条件。考虑将实空间样本 $f[n_x, n_y, n_z]$ 映射到复傅里叶系数 $F[k_x, k_y, k_z]$ 的离散傅里叶变换。此任务的基本依据如下：(i) 在有限周期性网格上离散傅里叶变换的标准定义，(ii) 实值场的傅里叶变换满足厄米对称性，即 $F(-\\boldsymbol{k}) = F(\\boldsymbol{k})^\\ast$，以及 (iii) 由周期性引起的标准索引回绕，其中离散波矢索引沿维度 $d \\in \\{x,y,z\\}$ 定义为模 $N_d$。\n\n您的任务是为一个实数到复数的三维快速傅里叶变换 (Fast Fourier Transform (FFT)) 指定存储布局和索引映射，该变换在排除冗余负频率的同时保留厄米对称性，并使用从上述基本原理派生的以下精确要求：\n\n- 存储布局：沿 $z$ 轴使用紧凑半谱，仅存储非负 $z$ 频率。存储的复数数组形状必须为 $(N_x, N_y, \\lfloor N_z/2 \\rfloor + 1)$，其中索引 $(i,j,k)$ 对应于由下式定义的回绕离散波矢索引 $(\\tilde{k}_x, \\tilde{k}_y, \\tilde{k}_z)$：\n  $$\\tilde{k}_x(i) = \\begin{cases}\n  i, & 0 \\le i \\le \\lfloor N_x/2 \\rfloor \\\\\n  i - N_x, & \\lfloor N_x/2 \\rfloor < i \\le N_x - 1\n  \\end{cases},\\quad\n  \\tilde{k}_y(j) = \\begin{cases}\n  j, & 0 \\le j \\le \\lfloor N_y/2 \\rfloor \\\\\n  j - N_y, & \\lfloor N_y/2 \\rfloor < j \\le N_y - 1\n  \\end{cases},\\quad\n  \\tilde{k}_z(k) = k,$$\n  其中 $i \\in \\{0,\\dots,N_x-1\\}$，$j \\in \\{0,\\dots,N_y-1\\}$，$k \\in \\{0,\\dots,\\lfloor N_z/2 \\rfloor\\}$。被排除的系数对应于负 $z$ 频率 $k_z \\in \\{-\\lfloor N_z/2 \\rfloor,\\dots,-1\\}$，根据厄米对称性，这些系数是冗余的。\n\n- 索引映射：您必须实现存储索引 $(i,j,k)$ 和如上所述的回绕波矢索引 $(\\tilde{k}_x,\\tilde{k}_y,\\tilde{k}_z)$ 之间的双向映射，以及由厄米对称性所蕴含的共轭伴侣关系。具体来说，给定一个代表模式 $(\\tilde{k}_x,\\tilde{k}_y,\\tilde{k}_z)$ 的存储索引 $(i,j,k)$，其厄米共轭伴侣对应于模式 $(-\\tilde{k}_x,-\\tilde{k}_y,-\\tilde{k}_z)$，该模式将映射到存储索引\n  $$(i',j',k') = \\left(({-\\tilde{k}_x}) \\bmod N_x,\\ ({-\\tilde{k}_y}) \\bmod N_y,\\ ({-\\tilde{k}_z}) \\bmod N_z\\right).$$\n  当且仅当 $k' \\in \\{0,\\dots,\\lfloor N_z/2 \\rfloor\\}$ 时，该共轭伴侣才被存储在紧凑布局中。对于 $k \\in \\{0\\}$ 的模式，以及当 $N_z$ 为偶数时对于 $k \\in \\{N_z/2\\}$ 的模式，其共轭伴侣位于存储集内；对于其他的 $k$，其共轭伴侣不被存储。如果一个模式的存储索引与其共轭伴侣的存储索引相等，则该模式是自共轭的；这种情况精确地发生在每个分量等于其自身关于其大小的负模数时，即当 $i \\in \\{0\\}$ 以及当 $N_x$ 为偶数时可能 $i \\in \\{N_x/2\\}$；对于 $j$ 也是如此；对于 $k \\in \\{0\\}$ 以及当 $N_z$ 为偶数时可能 $k \\in \\{N_z/2\\}$。\n\n- 内存布局：使用连续的行主序，其中 $k$ 是变化最快的索引，其次是 $j$，然后是 $i$。存储的系数 $(i,j,k)$ 的平坦内存索引必须是\n  $$\\mathrm{flat}(i,j,k) = i \\cdot \\left(N_y \\cdot \\left(\\left\\lfloor \\frac{N_z}{2} \\right\\rfloor + 1\\right)\\right) + j \\cdot \\left(\\left\\lfloor \\frac{N_z}{2} \\right\\rfloor + 1\\right) + k.$$\n\n实现一个程序，定义上述存储布局和映射，然后为一组给定的测试用例计算每个用例的以下五个量：\n\n- 存储模式的总数，必须等于 $N_x \\cdot N_y \\cdot \\left(\\left\\lfloor N_z/2 \\right\\rfloor + 1\\right)$。\n- 由厄米条件和存储集决定的自共轭存储模式的数量。\n- 一个指定的样本回绕波矢索引 $(\\hat{k}_x,\\hat{k}_y,\\hat{k}_z)$ 的平坦内存索引，如果它可以在存储集中表示；如果不能表示，则返回整数 $-1$。\n- 其厄米共轭伴侣也位于存储集内的存储模式的数量。\n- 一个布尔值，指示对于每个存储索引 $(i,j,k)$，映射到 $(\\tilde{k}_x,\\tilde{k}_y,\\tilde{k}_z)$ 再映射回来是否返回原始的 $(i,j,k)$。\n\n您的程序必须使用以下测试套件：\n\n- 测试用例 1：$N_x=4$, $N_y=3$, $N_z=6$，样本回绕波矢索引为 $(\\hat{k}_x,\\hat{k}_y,\\hat{k}_z)=(-1,1,2)$。\n- 测试用例 2：$N_x=5$, $N_y=5$, $N_z=5$，样本回绕波矢索引为 $(\\hat{k}_x,\\hat{k}_y,\\hat{k}_z)=(2,-2,1)$。\n- 测试用例 3：$N_x=2$, $N_y=2$, $N_z=2$，样本回绕波矢索引为 $(\\hat{k}_x,\\hat{k}_y,\\hat{k}_z)=(1,1,1)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。结果必须按测试用例的顺序发出，并且对于每个测试用例，必须按上述确切顺序发出五个量。例如，总输出形式必须为\n$[\\dots]$\n共包含 $5 \\times 3$ 个条目。不涉及单位，所有可能出现的角度都必须理解为弧度。所有数值答案必须在打印的列表中作为普通整数或布尔值发出。", "solution": "问题陈述已经过验证，被认为是合理的。它具有科学依据，问题明确，客观，并包含推导出唯一解所需的所有必要信息。该问题要求为数值宇宙学中使用的三维实数到复数快速傅里叶变换 (FFT) 实现特定的存储和索引方案，然后为一组给定的参数计算五个特定的量。\n\n解决方案通过系统地推导计算五个所需量中每一个量的方法来进行。网格维度由 $N_x$、$N_y$ 和 $N_z$ 表示。紧凑存储数组沿 $z$ 轴使用一个简化的维度 $N_z' = \\lfloor N_z/2 \\rfloor + 1$。其形状为 $(N_x, N_y, N_z')$。\n\n**1. 存储模式的总数**\n\n存储的复傅里叶系数的总数就是紧凑存储数组中元素的数量。这是其维度的乘积：\n$$ \\text{Total Modes} = N_x \\cdot N_y \\cdot \\left(\\left\\lfloor \\frac{N_z}{2} \\right\\rfloor + 1\\right) $$\n这个数量代表了傅里叶空间场的内存占用，通过利用厄米对称性进行了优化。\n\n**2. 自共轭存储模式的数量**\n\n一个波矢为 $\\boldsymbol{\\tilde{k}} = (\\tilde{k}_x, \\tilde{k}_y, \\tilde{k}_z)$ 的模式是自共轭的，如果它是自身的厄米共轭伴侣，即在周期性回绕下 $\\boldsymbol{\\tilde{k}} = -\\boldsymbol{\\tilde{k}}$。这等价于存储索引 $(i,j,k)$ 与其伴侣模式的存储索引 $(i',j',k')$ 相同。这个条件 $(i,j,k) = (i',j',k')$ 必须对每个维度独立成立。\n\n对于大小为 $N_d$ 的维度 $d \\in \\{x,y,z\\}$，回绕的波矢 $\\tilde{k}_d$ 必须满足 $\\tilde{k}_d = -\\tilde{k}_d \\pmod{N_d}$，这可以简化为 $2\\tilde{k}_d \\equiv 0 \\pmod{N_d}$。沿维度 $d$ 的存储索引的解是：\n- 索引 $0$，对应于 $\\tilde{k}_d=0$。\n- 如果 $N_d$ 是偶数，索引 $N_d/2$，对应于奈奎斯特频率 $\\tilde{k}_d=N_d/2$。\n\n每个维度 $d$ 的自共轭索引数量为：如果 $N_d$ 是偶数，则 $S_d = 2$；如果 $N_d$ 是奇数，则 $S_d = 1$。这可以写成 $S_d = 1 + (1 - N_d \\pmod{2})$。\n\n对于 $z$ 轴，存储的索引 $k$ 被限制在 $\\{0, \\dots, \\lfloor N_z/2 \\rfloor\\}$。自共轭解 $k=0$ 和（如果 $N_z$ 是偶数）$k=N_z/2$ 都落在这个存储范围内。\n自共轭模式的总数是每个维度计数的乘积：\n$$ \\text{Self-Conjugate Modes} = S_x \\cdot S_y \\cdot S_z = \\left(1 + (1 - N_x \\pmod{2})\\right) \\cdot \\left(1 + (1 - N_y \\pmod{2})\\right) \\cdot \\left(1 + (1 - N_z \\pmod{2})\\right) $$\n\n**3. 样本模式的平坦内存索引**\n\n给定一个样本回绕波矢索引 $(\\hat{k}_x, \\hat{k}_y, \\hat{k}_z)$，我们必须首先确定它是否在紧凑存储数组中表示。该存储方案明确只包括非负 $z$ 频率。因此，一个模式被存储当且仅当其 $z$ 波矢 $\\hat{k}_z$ 在范围 $[0, \\lfloor N_z/2 \\rfloor]$ 内。如果 $\\hat{k}_z$ 在此范围之外，则该模式不被存储，并且要返回的值是 $-1$。\n\n如果该模式可能被存储，我们必须将波矢 $(\\hat{k}_x, \\hat{k}_y, \\hat{k}_z)$ 映射回存储索引 $(i,j,k)$。\n从波矢 $\\tilde{k}_d$到存储索引 $i_d$ 的映射由模运算给出：$i_d = \\tilde{k}_d \\pmod{N_d}$。\n因此，存储索引计算如下：\n$$ i = \\hat{k}_x \\pmod{N_x} $$\n$$ j = \\hat{k}_y \\pmod{N_y} $$\n$$ k = \\hat{k}_z $$\n确定索引 $(i,j,k)$ 后，使用提供的行主序公式计算平坦内存索引，其中 $k$ 是变化最快的索引：\n$$ \\mathrm{flat}(i,j,k) = i \\cdot \\left(N_y \\cdot \\left(\\left\\lfloor \\frac{N_z}{2} \\right\\rfloor + 1\\right)\\right) + j \\cdot \\left(\\left\\lfloor \\frac{N_z}{2} \\right\\rfloor + 1\\right) + k $$\n\n**4. 其共轭伴侣也被存储的存储模式计数**\n\n对于一个索引为 $(i,j,k)$ 的存储模式，我们确定其厄米共轭伴侣的索引 $(i',j',k')$。\n伴侣模式的波矢为 $(-\\tilde{k}_x, -\\tilde{k}_y, -\\tilde{k}_z)$。相应的存储索引是 $k' = (-\\tilde{k}_z) \\pmod{N_z} = (-k) \\pmod{N_z}$，因为 $\\tilde{k}_z = k$。如果其 $z$ 索引 $k'$ 落在存储范围内：$0 \\le k' \\le \\lfloor N_z/2 \\rfloor$，则该伴侣被存储在紧凑数组中。\n\n我们分析在 $k \\in \\{0, \\dots, \\lfloor N_z/2 \\rfloor\\}$ 上的这个条件：\n- 如果 $k=0$：$k' = (-0) \\pmod{N_z} = 0$。因为 $0$ 始终在存储范围内，所以所有 $k=0$ 的模式其伴侣都被存储。有 $N_x \\cdot N_y$ 个这样的模式。\n- 如果 $k>0$：$k' = N_z - k$。条件变为 $N_z - k \\le \\lfloor N_z/2 \\rfloor$，这意味着 $k \\ge N_z - \\lfloor N_z/2 \\rfloor$。\n    - 如果 $N_z$ 是偶数，设 $N_z=2m$。$k$ 的存储范围是 $[0, m]$。条件是 $k \\ge 2m - m = m$。在存储范围内，$k>0$ 的唯一解是 $k=m=N_z/2$。因此，所有 $k=N_z/2$ 的模式其伴侣也被存储。有 $N_x \\cdot N_y$ 个这样的模式。\n    - 如果 $N_z$ 是奇数，设 $N_z=2m+1$。$k$ 的存储范围是 $[0, m]$。条件是 $k \\ge (2m+1) - m = m+1$。在存储范围内没有满足此条件的 $k$。\n\n总之，只有 $k=0$ 平面上的模式，以及当 $N_z$ 为偶数时 $k=N_z/2$ 平面上的模式，其伴侣才被存储。总计数为：\n$$ \\text{Count} = \\begin{cases} N_x \\cdot N_y & \\text{if } N_z \\text{ is odd} \\\\ 2 \\cdot N_x \\cdot N_y & \\text{if } N_z \\text{ is even} \\end{cases} $$\n这可以写成 $(1 + (1 - N_z \\pmod 2)) \\cdot N_x \\cdot N_y$。\n\n**5. 双向索引映射验证**\n\n此任务要求验证从存储索引 $(i,j,k)$ 到其波矢 $(\\tilde{k}_x, \\tilde{k}_y, \\tilde{k}_z)$ 再回到存储索引 $(i',j',k')$ 的映射是一个恒等变换，即 $(i,j,k) = (i',j',k')$。\n正向映射由问题对 $\\tilde{k}_d(i_d)$ 的定义给出。反向映射是 $i_d' = \\tilde{k}_d \\pmod{N_d}$。\n对于任何维度 $d$ 和索引 $i \\in \\{0, \\dots, N_d-1\\}$：\n- 如果 $0 \\le i \\le \\lfloor N_d/2 \\rfloor$，则 $\\tilde{k}_d(i) = i$，并且 $i \\pmod{N_d} = i$。\n- 如果 $\\lfloor N_d/2 \\rfloor  i \\le N_d-1$，则 $\\tilde{k}_d(i) = i - N_d$，并且 $(i - N_d) \\pmod{N_d} = i$。\n在这两种情况下，索引都映射回自身。这对维度 $x$ 和 $y$ 均成立。对于 $z$ 维度，由于 $\\tilde{k}_z=k$，映射是平凡的。因此，对于任何有效的索引和网格大小，双向映射始终是恒等映射。此检查的结果对于所有测试用例都将是 `True`。实现将以算法方式执行此检查以确保严谨性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        (4, 3, 6, (-1, 1, 2)),\n        (5, 5, 5, (2, -2, 1)),\n        (2, 2, 2, (1, 1, 1)),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        Nx, Ny, Nz, sample_k_vec = case\n        results = calculate_metrics(Nx, Ny, Nz, sample_k_vec)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef calculate_metrics(Nx, Ny, Nz, sample_k_vec):\n    \"\"\"\n    Computes the five required quantities for a given test case.\n    \n    Args:\n        Nx (int): Grid size in x-dimension.\n        Ny (int): Grid size in y-dimension.\n        Nz (int): Grid size in z-dimension.\n        sample_k_vec (tuple): A sample wrapped wave index (kx, ky, kz).\n\n    Returns:\n        tuple: A tuple containing the five computed quantities in order.\n    \"\"\"\n    Nz_prime = Nz // 2 + 1\n\n    # 1. Total number of stored modes\n    total_modes = Nx * Ny * Nz_prime\n\n    # 2. Number of self-conjugate stored modes\n    # A mode is self-conjugate if its wave number k_d satisfies k_d = -k_d mod N_d.\n    # This is true for k_d=0 and, if N_d is even, k_d=N_d/2.\n    sx = 2 if Nx % 2 == 0 else 1\n    sy = 2 if Ny % 2 == 0 else 1\n    sz = 2 if Nz % 2 == 0 else 1\n    self_conjugate_modes = sx * sy * sz\n\n    # 3. Flat memory index of a specified sample wrapped wave index\n    k_hat_x, k_hat_y, k_hat_z = sample_k_vec\n    flat_index = -1\n    # Check if the z-frequency is in the stored half-spectrum\n    if 0 = k_hat_z  Nz_prime:\n        i = k_hat_x % Nx\n        j = k_hat_y % Ny\n        k = k_hat_z\n        \n        # This check confirms that the given sample_k_vec corresponds to the\n        # canonical wave vectors generated from our storage indices.\n        if (k_tilde(i, Nx) == k_hat_x and k_tilde(j, Ny) == k_hat_y and k == k_hat_z):\n            flat_index = i * (Ny * Nz_prime) + j * Nz_prime + k\n\n    # 4. Count of stored modes whose Hermitian-conjugate partner also lies within the stored set\n    # Partner is stored if its k' index is in [0, Nz_prime-1].\n    # This only happens for modes with k=0 and, if Nz is even, k=Nz/2.\n    num_planes_with_stored_partners = 2 if Nz % 2 == 0 else 1\n    modes_with_stored_partner = num_planes_with_stored_partners * Nx * Ny\n\n    # 5. Boolean indicating if the index mapping is bijective\n    is_bijective = True\n    # This loop programmatically verifies the identity, though it's true by construction.\n    for i_loop in range(Nx):\n        for j_loop in range(Ny):\n            # The z-axis mapping is a trivial identity and does not need a loop.\n            kx_tilde_val = k_tilde(i_loop, Nx)\n            ky_tilde_val = k_tilde(j_loop, Ny)\n            \n            i_back = kx_tilde_val % Nx\n            j_back = ky_tilde_val % Ny\n            \n            if i_loop != i_back or j_loop != j_back:\n                is_bijective = False\n                break\n        if not is_bijective:\n            break\n            \n    return total_modes, self_conjugate_modes, int(flat_index), modes_with_stored_partner, is_bijective\n\ndef k_tilde(idx, N):\n    \"\"\"\n    Maps a storage index `idx` to its corresponding wrapped wave number for a dimension of size `N`.\n    \"\"\"\n    if idx = N // 2:\n        return idx\n    else:\n        return idx - N\n\nsolve()\n```", "id": "3495399"}, {"introduction": "掌握了实现细节之后，我们现在转向一个关键的数值挑战：混叠（aliasing）。这种现象会给我们的分析带来虚假信号，尤其是在存在非线性的情况下。本练习[@problem_id:3495462]提供了一个受控的数值实验，您将在此故意生成混叠，并测试诸如交错（interlacing）等常见的缓解策略，从而在视觉和定量上理解离散傅里叶分析的这一基本限制。", "problem": "您的任务是使用快速傅里叶变换（FFT）构建和分析周期性立方体域中的合成三维密度场。目标是演示和量化在有意激发高于奈奎斯特波数的傅里叶模式时产生的混叠效应，并测量交错采样和三分之二去混叠规则对恢复的功率谱和双谱的影响。\n\n从以下基础概念开始：\n- 采样与混叠：一个边长为 $L$ 的周期性立方体域，在一个大小为 $N \\times N \\times N$ 的均匀立方体网格上采样，其网格间距为 $\\Delta x = L/N$，奈奎斯特波数为 $k_{\\mathrm{Ny}} = \\pi / \\Delta x$。当一个连续场包含波数大小 $|\\mathbf{k}|  k_{\\mathrm{Ny}}$ 的傅里叶分量时，均匀采样会产生混叠，这些分量会折叠回离散谱中，成为波数较低的分量。\n- 离散傅里叶变换：离散傅里叶变换将采样场 $\\delta(\\mathbf{x})$ 转换为在离散波矢量 $\\mathbf{k} = (2\\pi/L) \\mathbf{n}$ 处的复数系数 $\\tilde{\\delta}(\\mathbf{k})$，其中 $\\mathbf{n}$ 是一个有符号整数的三元组。在实践中，通过体素体积 $(\\Delta x)^3$ 进行统一缩放，可以得到在不同分辨率下具有一致物理尺度的系数。\n- 统计谱定义：功率谱 $P(\\mathbf{k})$ 定义为 $|\\tilde{\\delta}(\\mathbf{k})|^2$ 的二次平均值，而双谱 $B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)$ 则量化了满足 $\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3=\\mathbf{0}$ 的三元组的三阶模式耦合。\n\n您的程序必须根据以下说明构建、处理和分析场：\n1. 几何与采样：\n   - 使用一个边长为 $L$ 的周期性立方体和一个大小为 $N \\times N \\times N$ 的均匀网格。所有量均为无量纲（无物理单位）。\n   - 定义一个连续基础场 $f(\\mathbf{x})$ 作为两个平面波之和，其整数索引向量为 $(n_x,n_y,n_z)$，使得每个波中至少有一个分量满足 $|n_i|  N/2$，以确保 $|\\mathbf{k}|  k_{\\mathrm{Ny}}$。\n   - 定义合成密度场为 $\\delta(\\mathbf{x}) = f(\\mathbf{x}) + \\beta f(\\mathbf{x})^2$，其中 $\\beta$ 是给定的无量纲非线性参数。\n2. 处理方法：\n   - 直接采样：在网格上对 $\\delta(\\mathbf{x})$ 进行采样，不进行额外处理，并计算其 FFT 以获得 $\\tilde{\\delta}(\\mathbf{k})$。\n   - 交错采样：在两个网格上计算 $\\delta(\\mathbf{x})$ 的样本，其中一个网格在每个轴上偏移半个单元，即在 $\\mathbf{x}$ 和 $\\mathbf{x} + (\\Delta x/2,\\Delta x/2,\\Delta x/2)$ 处，在实空间中平均这两个采样场，然后计算平均场的 FFT。\n   - 三分之二去混叠规则：在计算直接采样场的 FFT 后，将任何整数索引分量在任一轴上满足 $|n_i|  N/3$ 的模式设置为零，其余模式保持不变。\n3. 谱测量：\n   - 令 $\\mathbf{k} = (2\\pi/L)\\mathbf{n}$ 表示对应于整数索引三元组 $\\mathbf{n} = (n_x,n_y,n_z)$ 的离散波矢量。\n   - 对于每个指定的测试案例，评估并报告以下量：\n     - 在指定的单个目标模式向量 $\\mathbf{k}_{\\mathrm{v}}$（该向量是一个被激发的高波数模式的混叠低波数图像）处恢复的离散功率值 $P(\\mathbf{k}_{\\mathrm{v}}) = |\\tilde{\\delta}(\\mathbf{k}_{\\mathrm{v}})|^2$。\n     - 对于指定的单个闭合三元组 $(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)$（满足 $\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3=\\mathbf{0}$），恢复的双谱幅值 $|B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)| = |\\tilde{\\delta}(\\mathbf{k}_1)\\tilde{\\delta}(\\mathbf{k}_2)\\tilde{\\delta}(\\mathbf{k}_3)|$，该三元组被选择用于探测混叠驱动的模式耦合。\n   - 在形成任何乘积之前，通过将计算出的复数 FFT 乘以 $(\\Delta x)^3 = (L/N)^3$，在所有方法中使用相同且一致的 FFT 归一化。\n4. 测试套件：\n   - 案例 1：$N=32$，$L=1$，两个被激发的模式，整数索引向量为 $(20,0,0)$ 和 $(0,22,0)$，在 $f(\\mathbf{x})$ 中具有相等的振幅，非线性参数 $\\beta=0.3$。测量：\n     - $\\mathbf{n}_{\\mathrm{v}}=(12,0,0)$ 处的功率。\n     - 双谱三元组 $(\\mathbf{n}_1,\\mathbf{n}_2,\\mathbf{n}_3) = (12,0,0)$, $(0,10,0)$, $(-12,-10,0)$。\n   - 案例 2：$N=24$，$L=1$，模式 $(14,0,0)$ 和 $(0,14,0)$，$\\beta=0.5$。测量：\n     - $\\mathbf{n}_{\\mathrm{v}}=(10,0,0)$ 处的功率。\n     - 双谱三元组 $(10,0,0)$, $(0,10,0)$, $(-10,-10,0)$。\n   - 案例 3：$N=16$，$L=1$，模式 $(13,0,0)$ 和 $(0,9,0)$，$\\beta=0.4$。测量：\n     - $\\mathbf{n}_{\\mathrm{v}}=(3,0,0)$ 处的功率。\n     - 双谱三元组 $(3,0,0)$, $(0,7,0)$, $(-3,-7,0)$。\n5. 输出规范：\n   - 对于每个案例，按以下顺序计算并返回六个值：使用直接采样的 $P(\\mathbf{k}_{\\mathrm{v}})$，使用交错采样的 $P(\\mathbf{k}_{\\mathrm{v}})$，使用三分之二去混叠规则的 $P(\\mathbf{k}_{\\mathrm{v}})$，使用直接采样的 $|B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)|$，使用交错采样的 $|B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)|$，以及使用三分之二去混叠规则的 $|B(\\mathbf{k}_1,\\mathbf{k}_2,\\mathbf{k}_3)|$。\n   - 所有报告的量必须是无量纲浮点数。\n   - 您的程序应生成单行输出，其中包含结果，格式为逗号分隔的三个列表（每个测试案例一个列表）并用方括号括起来，例如 $[\\,[r_1,r_2,r_3,r_4,r_5,r_6],\\,[\\dots],\\,[\\dots]\\,]$。\n\n确保您实现的科学真实性和内部一致性。程序必须是自包含的，并且不需要任何用户输入。实现必须遵守指定的环境和库约束。最终的数值答案必须从提供的测试套件中确定性地计算得出。", "solution": "用户提供了一个科学基础扎实、定义明确、客观且内部一致的问题。它描述了宇宙学和物理学中一个关于傅里叶分析中混叠效应的标准数值实验。所有参数和程序都已指定，从而可以得到一个确定性且可验证的解。因此，该问题被认为是有效的。\n\n这个问题的核心是在离散网格上非线性场演化的背景下研究数值混叠，这是计算科学中普遍存在的问题，尤其是在模拟宇宙大尺度结构的数值宇宙学中。给定一个边长为 $L$ 的三维周期性盒子中的连续一维密度场 $\\delta(\\mathbf{x})$，然后在大小为 $N \\times N \\times N$ 的均匀立方体网格上对其进行采样。\n\n基本要素定义如下：\n- 网格间距为 $\\Delta x = L/N$。\n- 网格点坐标为 $\\mathbf{x}_{\\mathbf{j}} = (j_x, j_y, j_z)\\Delta x$，其中 $j_x, j_y, j_z \\in \\{0, 1, \\dots, N-1\\}$。\n- 在傅里叶空间中，对应的离散波矢量为 $\\mathbf{k}_{\\mathbf{n}} = (2\\pi/L)(n_x, n_y, n_z)$，其中 $n_x, n_y, n_z$ 是整数。\n- 奈奎斯特波数定义了在网格上可以无混叠表示的最高频率，其值为 $k_{\\mathrm{Ny}} = \\pi/\\Delta x$。就整数索引 $\\mathbf{n}$ 而言，这对应于每个分量 $i \\in \\{x,y,z\\}$ 满足 $|n_i| \\le N/2$ 的条件。\n\n合成场由一个包含两个平面波的基础场 $f(\\mathbf{x})$ 构建。为确保场是实值的，我们使用余弦函数。假设在未另外指定时振幅为单位1，基础场为：\n$$f(\\mathbf{x}) = \\cos(\\mathbf{k}_a \\cdot \\mathbf{x}) + \\cos(\\mathbf{k}_b \\cdot \\mathbf{x})$$\n这里，$\\mathbf{k}_a = (2\\pi/L)\\mathbf{n}_a$ 和 $\\mathbf{k}_b = (2\\pi/L)\\mathbf{n}_b$ 是两个初始模式的波矢量，其整数向量 $\\mathbf{n}_a$ 和 $\\mathbf{n}_b$ 被选择以使至少一个分量 $|n_i|  N/2$。这有意引入了高于奈奎斯特极限的频率。\n\n通过一个二次项引入非线性分量，得到完整的密度场：\n$$\\delta(\\mathbf{x}) = f(\\mathbf{x}) + \\beta f(\\mathbf{x})^2$$\n其中 $\\beta$ 是一个非线性参数。二次项 $f(\\mathbf{x})^2$ 会生成新的傅里叶模式，这些模式对应于初始波矢量的谐波和组合，例如 $2\\mathbf{k}_a$、$2\\mathbf{k}_b$、$\\mathbf{k}_a+\\mathbf{k}_b$ 和 $\\mathbf{k}_a-\\mathbf{k}_b$。\n\n当这个连续场 $\\delta(\\mathbf{x})$ 在离散网格上采样时，任何傅里叶模式 $\\mathbf{k}_{\\mathbf{n}}$ 若其任一分量 $i$ 满足 $|n_i|  N/2$，就会发生混叠。它会被错误地表示为主要范围 $|n'_i| \\le N/2$ 内的一个波数较低的模式 $\\mathbf{k}_{\\mathbf{n}'}$。混叠后的索引 $n'_i$ 与真实索引 $n_i$ 的关系为 $n'_i = n_i - N \\cdot \\text{round}(n_i/N)$。对于本问题中的模式，其中 $N/2  |n_i| \\le N$，这简化为 $n'_i = n_i - N \\cdot \\text{sign}(n_i)$。\n\n计算采样场 $\\delta(\\mathbf{x}_{\\mathbf{j}})$ 的离散傅里叶变换（DFT）并进行归一化，以近似连续傅里叶变换：\n$$\\tilde{\\delta}(\\mathbf{k}_{\\mathbf{n}}) = (\\Delta x)^3 \\sum_{\\mathbf{j}} \\delta(\\mathbf{x}_{\\mathbf{j}}) e^{-i \\mathbf{k}_{\\mathbf{n}} \\cdot \\mathbf{x}_{\\mathbf{j}}}$$\n因子 $(\\Delta x)^3 = (L/N)^3$ 确保得到的傅里叶系数 $\\tilde{\\delta}(\\mathbf{k})$ 具有一致的物理维度（在此无量纲设置中为体积），而不管网格分辨率 $N$ 如何。\n\n我们评估三种处理方法来处理或观察混叠：\n1.  **直接采样**：在网格点 $\\mathbf{x}_{\\mathbf{j}}$ 处对场 $\\delta(\\mathbf{x})$ 进行采样并直接计算其 DFT。预计此方法将显示最严重的混叠效应。\n2.  **交错采样**：这是一种简单的抗混叠技术。生成两个场：一个在主网格上采样 $\\delta(\\mathbf{x}_{\\mathbf{j}})$，另一个在偏移半个单元的网格上采样 $\\delta(\\mathbf{x}_{\\mathbf{j}} + \\frac{1}{2}\\boldsymbol{\\Delta x})$。这两个采样场在实空间中进行平均，然后进行 DFT 计算。平均过程充当一个低通滤波器，应能抑制高频模式，从而减少混叠。\n3.  **三分之二去混叠规则**：此方法在傅里叶空间中应用一个锐利滤波器。在计算直接采样场的 DFT 后，如果任何傅里叶系数 $\\tilde{\\delta}(\\mathbf{k}_{\\mathbf{n}})$ 的整数索引向量 $\\mathbf{n}=(n_x,n_y,n_z)$ 的任一分量超过阈值，即如果 $|n_x|  N/3$ 或 $|n_y|  N/3$ 或 $|n_z|  N/3$，则将其设置为零。此过程旨在移除源于二次相互作用的混叠功率，但在此处的应用方式是，它在一个已经混叠的谱上充当一个后处理滤波器。\n\n最后，我们测量两个关键的统计量来量化混叠的影响：\n- 在特定混叠波矢量 $\\mathbf{k}_{\\mathrm{v}}$ 处恢复的功率谱：$P(\\mathbf{k}_{\\mathrm{v}}) = |\\tilde{\\delta}(\\mathbf{k}_{\\mathrm{v}})|^2$。这测量了由于高波数模式的混叠而在低波数处出现的虚假功率。\n- 特定闭合三元组 $(\\mathbf{k}_1, \\mathbf{k}_2, \\mathbf{k}_3)$（其中 $\\mathbf{k}_1+\\mathbf{k}_2+\\mathbf{k}_3 = \\mathbf{0}$）恢复的双谱幅值：$|B(\\mathbf{k}_1, \\mathbf{k}_2, \\mathbf{k}_3)| = |\\tilde{\\delta}(\\mathbf{k}_1)\\tilde{\\delta}(\\mathbf{k}_2)\\tilde{\\delta}(\\mathbf{k}_3)|$。这探测了由基本模式和耦合模式的混叠产生的虚假三点相关性。\n\n实现过程是构建这些场并为每个指定的测试案例计算谱，将整数模式索引 $\\mathbf{n}$ 映射到 DFT 输出的适当数组索引，然后报告每个案例所需的六个量。对于实值场 $\\delta(\\mathbf{x})$，其 DFT 满足厄米对称性 $\\tilde{\\delta}(\\mathbf{k}_{\\mathbf{n}}) = \\tilde{\\delta}^{*}(-\\mathbf{k}_{\\mathbf{n}})$，这意味着 $P(\\mathbf{k}_{\\mathbf{n}}) = P(-\\mathbf{k}_{\\mathbf{n}})$。这一点很重要，因为混叠模式可能出现在负索引处，而测量要求在正索引处进行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes synthetic 3D density fields to demonstrate and quantify\n    aliasing effects using the Fast Fourier Transform (FFT).\n    \"\"\"\n\n    test_cases = [\n        # Case 1: N=32, L=1, modes (20,0,0), (0,22,0), beta=0.3\n        # Power at (12,0,0), Bispectrum at ((12,0,0), (0,10,0), (-12,-10,0))\n        {\n            \"N\": 32, \"L\": 1.0, \"n_a\": (20, 0, 0), \"n_b\": (0, 22, 0), \"beta\": 0.3,\n            \"n_v\": (12, 0, 0),\n            \"n_b_triad\": ((12, 0, 0), (0, 10, 0), (-12, -10, 0))\n        },\n        # Case 2: N=24, L=1, modes (14,0,0), (0,14,0), beta=0.5\n        # Power at (10,0,0), Bispectrum at ((10,0,0), (0,10,0), (-10,-10,0))\n        {\n            \"N\": 24, \"L\": 1.0, \"n_a\": (14, 0, 0), \"n_b\": (0, 14, 0), \"beta\": 0.5,\n            \"n_v\": (10, 0, 0),\n            \"n_b_triad\": ((10, 0, 0), (0, 10, 0), (-10, -10, 0))\n        },\n        # Case 3: N=16, L=1, modes (13,0,0), (0,9,0), beta=0.4\n        # Power at (3,0,0), Bispectrum at ((3,0,0), (0,7,0), (-3,-7,0))\n        {\n            \"N\": 16, \"L\": 1.0, \"n_a\": (13, 0, 0), \"n_b\": (0, 9, 0), \"beta\": 0.4,\n            \"n_v\": (3, 0, 0),\n            \"n_b_triad\": ((3, 0, 0), (0, 7, 0), (-3, -7, 0))\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        N = case[\"N\"]\n        L = case[\"L\"]\n        n_a = np.array(case[\"n_a\"])\n        n_b = np.array(case[\"n_b\"])\n        beta = case[\"beta\"]\n        n_v = case[\"n_v\"]\n        n_b_triad = [np.array(n) for n in case[\"n_b_triad\"]]\n\n        delta_x = L / N\n        voxel_volume = delta_x**3\n\n        # 1. Geometry and Field Definition\n        j = np.arange(N)\n        # Primary grid\n        x = j * delta_x\n        xx, yy, zz = np.meshgrid(x, x, x, indexing='ij')\n\n        # Shifted grid for interlacing\n        x_shifted = (j + 0.5) * delta_x\n        xx_s, yy_s, zz_s = np.meshgrid(x_shifted, x_shifted, x_shifted, indexing='ij')\n\n        k_a = (2 * np.pi / L) * n_a\n        k_b = (2 * np.pi / L) * n_b\n\n        def calculate_field(c_xx, c_yy, c_zz):\n            f_x = (np.cos(k_a[0]*c_xx + k_a[1]*c_yy + k_a[2]*c_zz) +\n                   np.cos(k_b[0]*c_xx + k_b[1]*c_yy + k_b[2]*c_zz))\n            return f_x + beta * f_x**2\n\n        # 2. Processing Methods\n        # Plain sampling\n        delta_plain = calculate_field(xx, yy, zz)\n        fft_plain = np.fft.fftn(delta_plain) * voxel_volume\n        \n        # Interlacing\n        delta_shifted = calculate_field(xx_s, yy_s, zz_s)\n        delta_interlaced = 0.5 * (delta_plain + delta_shifted)\n        fft_interlaced = np.fft.fftn(delta_interlaced) * voxel_volume\n\n        # Two-thirds de-aliasing rule\n        fft_2_3 = fft_plain.copy()\n        freq_indices = np.fft.fftfreq(N, d=1.0) * N\n        nx, ny, nz = np.meshgrid(freq_indices, freq_indices, freq_indices, indexing='ij')\n        \n        k_max_2_3 = N / 3.0\n        mask = (np.abs(nx)  k_max_2_3) | \\\n               (np.abs(ny)  k_max_2_3) | \\\n               (np.abs(nz)  k_max_2_3)\n        fft_2_3[mask] = 0.0\n\n        # Helper to get value at a specific mode vector n\n        def get_val(fft_grid, n_vec):\n            indices = tuple(int(i % N) for i in n_vec)\n            return fft_grid[indices]\n\n        # 3. Spectral Measurements\n        case_results = []\n        fft_methods = [fft_plain, fft_interlaced, fft_2_3]\n        \n        # Power spectrum values\n        for fft in fft_methods:\n            power = np.abs(get_val(fft, n_v))**2\n            case_results.append(power)\n        \n        # Bispectrum values\n        n1, n2, n3 = n_b_triad\n        for fft in fft_methods:\n            bispectrum = np.abs(get_val(fft, n1) * get_val(fft, n2) * get_val(fft, n3))\n            case_results.append(bispectrum)\n        \n        all_results.append(case_results)\n\n    # 5. Output Specification\n    # Convert lists to strings in the required format\n    inner_lists = [f\"[{','.join(f'{v:.10e}' for v in res)}]\" for res in all_results]\n    print(f\"[{','.join(inner_lists)}]\")\n\nsolve()\n```", "id": "3495462"}, {"introduction": "最后，我们将对FFT机理及其潜在陷阱的理解应用于一个实际的宇宙学数据分析问题。本练习[@problem_id:3495391]模拟了对星系巡天的分析，其中观测选择效应（巡天掩模）和最优信噪比加权（FKP权重）会改变观测到的成团性。通过使用FFT高效地计算巡天窗口函数的卷积，您将直接衡量这些效应对测量的功率谱产生的影响，这是现代宇宙学数据分析中的一项核心任务。", "problem": "给定一个在规则网格上离散化的无量纲周期性立方域。目标是开发一种基于快速傅里叶变换（FFT）的方法，用于计算巡天掩模与 Feldman-Kaiser-Peacock (FKP) 权重的傅里叶空间卷积，并定量测试这种最佳加权如何改变波数空间中的有效窗函数。本问题中所有量均为无量纲，不涉及物理单位。角度未出现，也无需指定。\n\n从离散傅里叶变换和卷积定理的基本原理出发，推导一种算法，该算法能够针对给定的实空间巡天掩模和空间相关的平均数密度，在应用 FKP 加权时构建波数空间中的有效窗函数。您唯一可以假设的事实是周期域上离散傅里叶变换的公认定义以及离散循环卷积的卷积定理。\n\n设域为一个边长为 $L$ 的周期性立方体，在 $N \\times N \\times N$ 网格上采样，其中 $L$ 和 $N$ 均为无量纲。设巡天掩模 $M(\\mathbf{x})$ 是一个二元场，$M(\\mathbf{x}) \\in \\{0,1\\}$，平均数密度 $\\bar{n}(\\mathbf{x})$ 是非负且空间变化的。Feldman-Kaiser-Peacock (FKP) 权重的定义相差一个比例常数，为了算法的明确性，您必须设置\n$$\nw(\\mathbf{x}) = \\frac{1}{1 + \\bar{n}(\\mathbf{x}) P_0},\n$$\n其中 $P_0$ 是一个固定的、非负的无量纲常数。\n\n您的任务是：\n- 仅使用离散傅里叶变换和离散循环卷积的定义，推导连接实空间乘积的傅里叶变换与傅里叶空间卷积之间的关系，并论证使用 FFT 计算波数空间中有效窗函数的合理性。\n- 实现一个算法，为未加权的巡天掩模和 FKP 加权的巡天掩模构建波数空间中的有效窗函数。将“有效窗函数”定义为相应实空间场的离散傅里叶变换。\n- 通过在波数壳层上对窗函数功率进行球对称平均，来量化最佳加权引起的改变。对于每种情况，计算两个标量诊断量：\n  1. 一个“低 $k$”比率 $R_{\\mathrm{low}}$，等于在低 $k$ 壳层上加权窗函数功率的总和除以未加权窗函数功率的相应总和。\n  2. 一个“高 $k$”比率 $R_{\\mathrm{high}}$，在相应的高 $k$ 壳层上类似定义。\n\n域和数值规格：\n- 使用 $N = 32$ 和 $L = 1$。\n- 构建巡天掩模 $M(\\mathbf{x})$ 为一个球体，半径 $r_0 = 0.25 L$，中心位于 $\\mathbf{c} = (0.3 L, 0.4 L, 0.6 L)$；在球体内设置 $M(\\mathbf{x}) = 1$，球体外设置 $M(\\mathbf{x}) = 0$。\n- 对于波数，使用与边长为 $L$ 的周期域上的离散傅里叶变换一致的标准离散波数网格。设奈奎斯特波数为 $k_{\\mathrm{Ny}}$，并将低 $k$ 壳层定义为 $0 \\le k \\le 0.2\\,k_{\\mathrm{Ny}}$，高 $k$ 壳层定义为 $0.6\\,k_{\\mathrm{Ny}} \\le k \\le 0.8\\,k_{\\mathrm{Ny}}$。\n\n测试套件：\n为以下每个参数集计算 $(R_{\\mathrm{low}}, R_{\\mathrm{high}})$ 对，这些参数集共同测试了一般情况、空间变化和边界条件：\n- 情况 1：$\\bar{n}(\\mathbf{x}) = n_0$，其中 $n_0 = 1$，$P_0 = 100$。\n- 情况 2：$\\bar{n}(\\mathbf{x}) = n_0 \\left[1 + \\alpha \\left(\\frac{x}{L} - \\frac{1}{2}\\right)\\right]$，其中 $n_0 = 1$，$\\alpha = 0.8$，下限截断为 0.1 以确保非负性；$P_0 = 100$。\n- 情况 3：$\\bar{n}(\\mathbf{x}) = n_0$，其中 $n_0 = 1$，$P_0 = 0$。\n- 情况 4：$\\bar{n}(\\mathbf{x}) = n_0 \\left[1 + \\alpha \\left(\\frac{x}{L} - \\frac{1}{2}\\right)\\right]$，其中 $n_0 = 1$，$\\alpha = 0.8$，下限截断为 0.1；$P_0 = 10^5$。\n\n答案规格：\n- 对于每种情况，按上述定义计算 $R_{\\mathrm{low}}$ 和 $R_{\\mathrm{high}}$。这些是无量纲浮点数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[R_{\\mathrm{low}}^{(1)}, R_{\\mathrm{high}}^{(1)}, R_{\\mathrm{low}}^{(2)}, R_{\\mathrm{high}}^{(2)}, R_{\\mathrm{low}}^{(3)}, R_{\\mathrm{high}}^{(3)}, R_{\\mathrm{low}}^{(4)}, R_{\\mathrm{high}}^{(4)}]$，其中上标表示情况索引。", "solution": "该问题要求开发并实现一种算法，以量化 Feldman-Kaiser-Peacock (FKP) 加权对傅里叶空间中巡天窗函数的影响。这包括从第一性原理推导相关的数学关系，然后为一组测试用例计算特定的诊断量。\n\n### 步骤 1：理论基础 - 离散卷积定理\n\n此分析的基础是实空间中的乘法与傅里叶空间中的卷积之间的关系。我们首先为在边长为 $L$、包含 $N \\times N \\times N$ 个点的周期性立方网格上采样的函数 $f(\\mathbf{x})$ 定义三维离散傅里叶变换 (DFT) 及其逆变换。网格点用 $\\mathbf{x}_j$ 表示，相应的离散波矢量用 $\\mathbf{k}_m$ 表示。\n\n正向 DFT 将实空间函数 $f(\\mathbf{x})$ 变换为其傅里叶空间表示 $\\tilde{f}(\\mathbf{k})$，定义如下：\n$$\n\\tilde{f}(\\mathbf{k}_m) = \\sum_{j=0}^{N^3-1} f(\\mathbf{x}_j) e^{-i \\mathbf{k}_m \\cdot \\mathbf{x}_j}\n$$\n逆向 DFT 将傅里叶空间变换回实空间，定义如下：\n$$\nf(\\mathbf{x}_j) = \\frac{1}{N^3} \\sum_{m=0}^{N^3-1} \\tilde{f}(\\mathbf{k}_m) e^{i \\mathbf{k}_m \\cdot \\mathbf{x}_j}\n$$\n这种归一化约定与典型的数值实现（例如 `numpy` 库）一致，在这些实现中，因子 $1/N^3$ 在逆变换期间应用。\n\n问题涉及两个函数乘积的傅里叶变换。让我们考虑两个实空间场 $f(\\mathbf{x})$ 和 $g(\\mathbf{x})$，以及它们的乘积 $h(\\mathbf{x}) = f(\\mathbf{x}) g(\\mathbf{x})$。$h(\\mathbf{x})$ 的傅里叶变换根据定义为：\n$$\n\\tilde{h}(\\mathbf{k}) = \\sum_{\\mathbf{x}} h(\\mathbf{x}) e^{-i \\mathbf{k} \\cdot \\mathbf{x}} = \\sum_{\\mathbf{x}} f(\\mathbf{x}) g(\\mathbf{x}) e^{-i \\mathbf{k} \\cdot \\mathbf{x}}\n$$\n其中求和遍及所有 $N^3$ 个网格点 $\\mathbf{x}_j$。为了继续推导，我们代入 $f(\\mathbf{x})$ 的逆 DFT 表达式：\n$$\n\\tilde{h}(\\mathbf{k}) = \\sum_{\\mathbf{x}} \\left( \\frac{1}{N^3} \\sum_{\\mathbf{k'}} \\tilde{f}(\\mathbf{k'}) e^{i \\mathbf{k'} \\cdot \\mathbf{x}} \\right) g(\\mathbf{x}) e^{-i \\mathbf{k} \\cdot \\mathbf{x}}\n$$\n通过重新排列求和顺序，我们可以对各项进行分组：\n$$\n\\tilde{h}(\\mathbf{k}) = \\frac{1}{N^3} \\sum_{\\mathbf{k'}} \\tilde{f}(\\mathbf{k'}) \\left( \\sum_{\\mathbf{x}} g(\\mathbf{x}) e^{-i (\\mathbf{k} - \\mathbf{k'}) \\cdot \\mathbf{x}} \\right)\n$$\n括号中的项恰好是在波矢量 $\\mathbf{k} - \\mathbf{k'}$ 处求值的 $g(\\mathbf{x})$ 的 DFT 定义，即 $\\tilde{g}(\\mathbf{k} - \\mathbf{k'})$。此代换得出离散卷积定理：\n$$\n\\tilde{h}(\\mathbf{k}) \\equiv \\mathcal{F}[f \\cdot g](\\mathbf{k}) = \\frac{1}{N^3} \\sum_{\\mathbf{k'}} \\tilde{f}(\\mathbf{k'}) \\tilde{g}(\\mathbf{k} - \\mathbf{k'}) = \\frac{1}{N^3} (\\tilde{f} * \\tilde{g})(\\mathbf{k})\n$$\n该定理表明，两个函数乘积的傅里叶变换与它们各自傅里叶变换的离散循环卷积成正比。\n\n### 步骤 2：算法策略与论证\n\n问题将“有效窗函数”定义为相应实空间场的傅里叶变换。\n对于未加权的情况，场是巡天掩模 $M(\\mathbf{x})$，因此有效窗函数是 $\\tilde{M}(\\mathbf{k}) = \\mathcal{F}[M(\\mathbf{x})]$。\n对于 FKP 加权的情况，实空间场是掩模 $M(\\mathbf{x})$ 和 FKP 权重 $w(\\mathbf{x})$ 的乘积，我们将其表示为 $W_{FKP}(\\mathbf{x}) = M(\\mathbf{x})w(\\mathbf{x})$。有效窗函数是它的傅里叶变换，即 $\\tilde{W}_{FKP}(\\mathbf{k}) = \\mathcal{F}[W_{FKP}(\\mathbf{x})]$。\n\n根据卷积定理，$\\tilde{W}_{FKP}(\\mathbf{k})$ 与卷积 $(\\tilde{M} * \\tilde{w})(\\mathbf{k})$ 成正比。在傅里叶空间中直接计算此卷积和将涉及对所有模式的嵌套循环，其计算复杂度为 $O((N^3)^2) = O(N^6)$，对于典型的网格尺寸而言，这在计算上是不可行的。\n\n一个效率高得多的策略是在操作更简单的域中执行运算。乘积 $W_{FKP}(\\mathbf{x}) = M(\\mathbf{x})w(\\mathbf{x})$ 在实空间中是一个简单的逐元素乘法，复杂度为 $O(N^3)$。之后，我们可以使用快速傅里叶变换 (FFT) 算法计算傅里叶变换 $\\mathcal{F}[W_{FKP}(\\mathbf{x})]$。FFT 以低得多的复杂度 $O(N^3 \\log N)$ 计算 DFT。这个两步过程——实空间中的乘法后跟 FFT——是计算乘积傅里叶变换的标准且最有效的方法，其应用是采用基于 FFT 方法的核心理由。\n\n### 步骤 3：实现细节\n\n算法流程如下：\n\n1.  **网格生成**：在边长为 $L=1$ 的周期域上定义一个大小为 $N \\times N \\times N$（其中 $N=32$）的立方网格。每个网格点 $(i, j, k)$ 的实空间坐标为 $\\mathbf{x} = (i L/N, j L/N, k L/N)$，其中 $i,j,k \\in \\{0, ..., N-1\\}$。相应的波矢网格使用离散变换的标准定义构建。对于每个维度，波数由 $k_u = 2\\pi m_u / L$ 给出，其中 $m_u$ 是跨越 $[ -N/2, N/2 - 1 ]$ 的整数。使用 `numpy.fft.fftfreq` 可以方便地生成这些值。\n\n2.  **实空间场构建**：\n    *   **巡天掩模 $M(\\mathbf{x})$**：创建一个三维数组。如果其坐标 $\\mathbf{x}$ 满足 $|\\mathbf{x} - \\mathbf{c}| \\le r_0$，其中 $\\mathbf{c} = (0.3L, 0.4L, 0.6L)$ 且 $r_0=0.25L$，则每个元素设置为 $1$。否则，元素设置为 $0$。\n    *   **平均密度 $\\bar{n}(\\mathbf{x})$ 和 FKP 权重 $w(\\mathbf{x})$**：对于每个测试用例，根据指定的公式在网格上构建平均数密度 $\\bar{n}(\\mathbf{x})$ 和 FKP 权重 $w(\\mathbf{x}) = (1 + \\bar{n}(\\mathbf{x}) P_0)^{-1}$ 的场。\n    *   **窗函数**：未加权的窗函数就是 $M(\\mathbf{x})$，而 FKP 加权的窗函数是乘积 $W_{FKP}(\\mathbf{x}) = M(\\mathbf{x}) w(\\mathbf{x})$。\n\n3.  **傅里叶变换与功率**：应用 FFT 算法 (`numpy.fft.fftn`) 来获得傅里叶空间表示 $\\tilde{M}(\\mathbf{k})$ 和 $\\tilde{W}_{FKP}(\\mathbf{k})$。相应的窗函数功率场计算为这些复数场的模的平方：$P_M(\\mathbf{k}) = |\\tilde{M}(\\mathbf{k})|^2$ 和 $P_W(\\mathbf{k}) = |\\tilde{W}_{FKP}(\\mathbf{k})|^2$。\n\n4.  **诊断量计算**：\n    *   **波数壳层**：对傅里叶网格上的所有点计算每个波矢的模 $k = |\\mathbf{k}| = \\sqrt{k_x^2 + k_y^2 + k_z^2}$。奈奎斯特波数为 $k_{\\mathrm{Ny}} = \\pi N / L$。壳层定义如下：\n        *   低 $k$：$0 \\le k \\le 0.2\\,k_{\\mathrm{Ny}}$\n        *   高 $k$：$0.6\\,k_{\\mathrm{Ny}} \\le k \\le 0.8\\,k_{\\mathrm{Ny}}$\n    *   **功率求和**：在每个壳层内，对所有属于该壳层的网格点 $\\mathbf{k}$，将未加权和加权窗函数的总功率进行求和。\n        *   $S_{\\mathrm{low}, M} = \\sum_{k \\in \\text{low-k}} P_M(\\mathbf{k})$ 和 $S_{\\mathrm{low}, W} = \\sum_{k \\in \\text{low-k}} P_W(\\mathbf{k})$\n        *   $S_{\\mathrm{high}, M} = \\sum_{k \\in \\text{high-k}} P_M(\\mathbf{k})$ 和 $S_{\\mathrm{high}, W} = \\sum_{k \\in \\text{high-k}} P_W(\\mathbf{k})$\n    *   **比率**：最终的诊断比率计算如下：\n        *   $R_{\\mathrm{low}} = S_{\\mathrm{low}, W} / S_{\\mathrm{low}, M}$\n        *   $R_{\\mathrm{high}} = S_{\\mathrm{high}, W} / S_{\\mathrm{high}, M}$\n\n对四个指定的测试用例中的每一个重复此过程，以产生最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the modification of a survey window function by FKP weighting.\n\n    The algorithm proceeds as follows:\n    1.  Sets up the 3D real-space and Fourier-space grids.\n    2.  Constructs the unweighted survey mask M(x), a sphere.\n    3.  Computes the Fourier power spectrum of M(x), denoted P_M(k).\n    4.  Defines the k-space shells (low-k and high-k) and sums P_M(k) within them.\n    5.  Iterates through four test cases, each with different FKP parameters.\n        a.  Constructs the FKP weight w(x) for the current case.\n        b.  Creates the weighted window W_fkp(x) = M(x) * w(x).\n        c.  Computes the Fourier power spectrum of W_fkp(x), denoted P_W(k).\n        d.  Sums P_W(k) within the k-space shells.\n        e.  Calculates the ratios R_low and R_high as specified.\n    6.  Formats and prints the collected results.\n    \"\"\"\n    # Domain and numerical specifications\n    N = 32\n    L = 1.0\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: Constant n_bar, P0 = 100\n        {'n0': 1.0, 'alpha': 0.0, 'P0': 100.0},\n        # Case 2: Spatially varying n_bar, P0 = 100\n        {'n0': 1.0, 'alpha': 0.8, 'P0': 100.0},\n        # Case 3: Constant n_bar, P0 = 0 (no weighting)\n        {'n0': 1.0, 'alpha': 0.0, 'P0': 0.0},\n        # Case 4: Spatially varying n_bar, large P0\n        {'n0': 1.0, 'alpha': 0.8, 'P0': 100000.0},\n    ]\n\n    # Step 1: Grid Setup\n    grid_coords_1d = np.arange(N, dtype=float) * (L / N)\n    x, y, z = np.meshgrid(grid_coords_1d, grid_coords_1d, grid_coords_1d, indexing='ij')\n\n    # Step 2: Construct Survey Mask M(x)\n    r0 = 0.25 * L\n    center = np.array([0.3 * L, 0.4 * L, 0.6 * L])\n    dist_sq = (x - center[0])**2 + (y - center[1])**2 + (z - center[2])**2\n    M = (dist_sq = r0**2).astype(float)\n    \n    # Step 3: Compute unweighted window power\n    M_k = np.fft.fftn(M)\n    P_M_k = np.abs(M_k)**2\n\n    # Step 4: Define k-space grid and shells for analysis\n    k_vals_1d = 2.0 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_vals_1d, k_vals_1d, k_vals_1d, indexing='ij')\n    k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n    \n    k_nyquist = np.pi * N / L\n    \n    low_k_mask = (k_mag = 0.0)  (k_mag = 0.2 * k_nyquist)\n    high_k_mask = (k_mag = 0.6 * k_nyquist)  (k_mag = 0.8 * k_nyquist)\n\n    # Sum of unweighted power in shells\n    S_low_M = np.sum(P_M_k[low_k_mask])\n    S_high_M = np.sum(P_M_k[high_k_mask])\n    \n    results = []\n    \n    # Step 5: Iterate through test cases\n    for case in test_cases:\n        n0 = case['n0']\n        alpha = case['alpha']\n        P0 = case['P0']\n        \n        # Step 5a: Construct FKP weight w(x)\n        if alpha == 0.0:\n            n_bar = np.full((N, N, N), n0, dtype=float)\n        else:\n            # The calculation depends on the x-coordinate grid\n            n_bar_val = n0 * (1.0 + alpha * (x / L - 0.5))\n            n_bar = np.maximum(0.1, n_bar_val)\n        \n        w = 1.0 / (1.0 + n_bar * P0)\n        \n        # Step 5b: Create weighted mask W_fkp(x)\n        W_fkp = M * w\n        \n        # Step 5c: Compute FKP-weighted window power\n        W_fkp_k = np.fft.fftn(W_fkp)\n        P_W_k = np.abs(W_fkp_k)**2\n        \n        # Step 5d: Sum of weighted power in shells\n        S_low_W = np.sum(P_W_k[low_k_mask])\n        S_high_W = np.sum(P_W_k[high_k_mask])\n        \n        # Step 5e: Calculate ratios. Denominators are non-zero for a spherical mask.\n        R_low = S_low_W / S_low_M\n        R_high = S_high_W / S_high_M\n        \n        results.extend([R_low, R_high])\n\n    # Step 6: Format and print results\n    print(f\"[{','.join(f'{r:.6g}' for r in results)}]\")\n\nsolve()\n```", "id": "3495391"}]}