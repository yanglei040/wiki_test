{"hands_on_practices": [{"introduction": "构建任何数值求解器的第一步，是使用一个已知的解析解来测试它，从而建立对其正确性的信心。本练习将重点分析一个球对称高斯密度分布，这是一个常见且基础的测试案例。通过将数值结果与精确的解析解进行比较，您可以验证实现的正确性并量化其精度。[@problem_id:3489960]", "problem": "考虑在数值宇宙学中使用的亚视界、非相对论极限下的牛顿引力势。在共动坐标系中，该势满足一个泊松方程。从基本定律和核心定义出发：牛顿泊松方程、具有明确约定和球对称性的三维傅里叶变换对。具体来说，使用以下被认为是经过充分检验的公式和事实的基本陈述：\n- 共动引力势的泊松方程为 $\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G a^2 \\bar{\\rho}\\, \\delta(\\mathbf{x})$，其中 $G$ 是引力常数，$a$ 是尺度因子，$\\bar{\\rho}$ 是平均物质密度，$\\delta(\\mathbf{x})$ 是无量纲的超密度场。\n- 三维傅里叶变换的约定是 $\\tilde{f}(\\mathbf{k}) = \\int d^3x\\, f(\\mathbf{x})\\, e^{-i \\mathbf{k}\\cdot\\mathbf{x}}$，其逆变换为 $f(\\mathbf{x}) = \\frac{1}{(2\\pi)^3} \\int d^3k\\, \\tilde{f}(\\mathbf{k})\\, e^{i \\mathbf{k}\\cdot\\mathbf{x}}$。\n- 球对称性意味着对于任何球对称函数 $f(\\mathbf{x}) = f(r)$（其中 $r = \\|\\mathbf{x}\\|$），其傅里叶变换仅依赖于 $k = \\|\\mathbf{k}\\|$。\n\n给定一个球对称的高斯超密度 $\\delta(\\mathbf{x}) = \\delta_0 \\exp\\!\\left(-\\frac{r^2}{2\\sigma^2}\\right)$，其中 $\\delta_0$ 是一个常数振幅，$\\sigma$ 是一个常数宽度。您的任务是：\n- 使用指定的傅里叶变换约定和泊松方程，从第一性原理推导傅里叶空间势 $\\tilde{\\phi}(\\mathbf{k})$ 的解析表达式。除了上面列出的基本陈述外，不要使用任何快捷公式。\n- 使用球对称性和球坐标系中的泊松方程，推导由 $F_r(r) = -\\frac{d\\phi}{dr}$ 解析预测的给定高斯超密度的实空间径向力分布 $F_r(r)$，并用初等函数和误差函数表示。推导必须从泊松方程的球坐标形式开始，并进行适当的积分。不要提供中间的快捷结果；请给出完整的推导过程。\n- 实现一个数值 Particle-Mesh (PM) 傅里叶空间求解器，使用快速傅里叶变换 (FFT) 在周期性立方体域上求解泊松方程，并以谱方法计算力场。快速傅里叶变换 (FFT) 定义为将空间样本映射到离散波数的傅里叶变换的离散对应物。Particle-Mesh (PM) 指的是在周期性边界条件下通过谱方法在网格上求解场。使用与上述连续变换一致的约定：离散波数为 $\\mathbf{k} = (k_x,k_y,k_z)$，其中 $k_i = 2\\pi n_i/L$，$n_i$ 是由离散 FFT 频率网格确定的整数，$L$ 是盒子的大小。\n\n所有量必须采用代码单位：设置 $G=1$，$a=1$ 和 $\\bar{\\rho}=1$，长度以任意单位度量，使得 $L$ 和 $\\sigma$ 的单位相同，$\\delta_0$ 是无量纲的。在这些单位中，泊松方程变为 $\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi\\, \\delta(\\mathbf{x})$。\n\n数值求解器的算法要求：\n- 将边长为 $L$ 的立方体域离散化到 $N\\times N\\times N$ 个点的均匀网格上，网格间距为 $dx = L/N$。\n- 在以原点为中心的网格点上对 $\\delta(\\mathbf{x})$ 进行采样，即坐标为 $x_j = \\left(j - \\frac{N}{2}\\right) dx$，$y_j = \\left(j - \\frac{N}{2}\\right) dx$，$z_j = \\left(j - \\frac{N}{2}\\right) dx$，其中 $j$ 为整数索引。\n- 使用三维 FFT 计算 $\\tilde{\\delta}(\\mathbf{k})$。\n- 通过将 $\\tilde{\\delta}(\\mathbf{k})$ 乘以与泊松方程和指定变换约定一致的傅里叶空间格林函数来求解 $\\tilde{\\phi}(\\mathbf{k})$。通过设置 $\\tilde{\\phi}(\\mathbf{0})=0$ 来小心处理 $\\mathbf{k}=\\mathbf{0}$ 模式以避免除以零，这固定了任意的势偏移，且不影响力的计算。\n- 通过 $\\tilde{F}_i(\\mathbf{k}) = -i k_i \\tilde{\\phi}(\\mathbf{k})$ 计算谱力分量，并对每个分量进行逆 FFT 以获得 $F_x(\\mathbf{x})$，$F_y(\\mathbf{x})$ 和 $F_z(\\mathbf{x})$。\n- 将力投影到径向方向以获得 $F_r(\\mathbf{x}) = \\frac{\\mathbf{F}(\\mathbf{x}) \\cdot \\mathbf{x}}{\\|\\mathbf{x}\\|}$（对于 $\\|\\mathbf{x}\\|>0$），并定义 $F_r(\\mathbf{0})=0$。\n\n精度比较协议：\n- 将数值 PM 力 $F_r^{\\text{PM}}(\\mathbf{x})$ 与前面推导的解析径向力 $F_r(r)$ 进行比较。\n- 将比较限制在 $r \\le L/4$ 的网格点上，以最小化周期性镜像污染，并在相对误差计算中排除 $r=0$ 的点。\n- 将每个比较点的相对误差定义为 $\\epsilon(\\mathbf{x}) = \\frac{|F_r^{\\text{PM}}(\\mathbf{x}) - F_r^{\\text{analytic}}(r)|}{\\max(|F_r^{\\text{analytic}}(r)|, \\varepsilon)}$，其中 $\\varepsilon$ 是一个小的正阈值，按最大解析力的大小进行缩放，以防止除以接近零的数；在内部选择 $\\varepsilon$ 作为比较区域内最大 $|F_r^{\\text{analytic}}|$ 的固定分数。\n\n测试套件和要求的输出：\n- 使用以下参数集来检验不同情况，包括一般情况、符号反转（低密度区）、宽剖面和接近网格分辨率的宽度。每个测试用例是一个元组 $(N, L, \\sigma, \\delta_0)$：\n  1. $(N=64, L=1.0, \\sigma=0.05, \\delta_0=0.01)$。\n  2. $(N=64, L=1.0, \\sigma=0.05, \\delta_0=-0.01)$。\n  3. $(N=128, L=1.0, \\sigma=0.15, \\delta_0=0.02)$。\n  4. $(N=64, L=1.0, \\sigma=L/N, \\delta_0=0.01)$。\n- 对于每个测试用例，计算一个等于指定比较区域内最大相对误差的单个浮点数。以不带任何单位的小数形式表示此浮点数。\n- 你的程序应该产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与测试用例相同（例如，$[r_1,r_2,r_3,r_4]$）。\n\n确保科学真实性：您的推导必须从所述的基本定义和定律开始，并且您的数值实现必须在周期性边界条件下一致地应用傅里叶空间方法。在问题陈述中，不允许使用超出那些基本陈述的中间快捷公式。", "solution": "该问题要求推导给定质量分布的引力势和力的解析解，实现一个数值傅里叶空间 Particle-Mesh (PM) 求解器来计算相同的量，并比较结果以验证数值方法的有效性。分析在共动坐标系和代码单位（$G=1$，$a=1$，$\\bar{\\rho}=1$）下进行，此时奇特引力势 $\\phi$ 的泊松方程为 $\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi \\delta(\\mathbf{x})$。\n\n### 第 1 部分：傅里叶空间势 $\\tilde{\\phi}(\\mathbf{k})$ 的解析推导\n\n我们从指定单位下的泊松方程开始：\n$$ \\nabla^2 \\phi(\\mathbf{x}) = 4\\pi \\delta(\\mathbf{x}) $$\n为了在傅里叶空间中求解此方程，我们对其两边应用三维傅里叶变换，定义为 $\\tilde{f}(\\mathbf{k}) = \\int d^3x\\, f(\\mathbf{x})\\, e^{-i \\mathbf{k}\\cdot\\mathbf{x}}$。\n\n拉普拉斯算子 $\\nabla^2$ 的傅里叶变换可以通过考虑其对平面波 $e^{i\\mathbf{k}\\cdot\\mathbf{x}}$ 的作用来找到。\n$$ \\nabla^2 e^{i\\mathbf{k}\\cdot\\mathbf{x}} = \\nabla \\cdot (i\\mathbf{k} e^{i\\mathbf{k}\\cdot\\mathbf{x}}) = i\\mathbf{k} \\cdot i\\mathbf{k} e^{i\\mathbf{k}\\cdot\\mathbf{x}} = -\\|\\mathbf{k}\\|^2 e^{i\\mathbf{k}\\cdot\\mathbf{x}} = -k^2 e^{i\\mathbf{k}\\cdot\\mathbf{x}} $$\n根据卷积定理，或更直接地使用傅里叶变换的微分性质，函数 $\\phi(\\mathbf{x})$ 的拉普拉斯的变换为：\n$$ \\mathcal{F}[\\nabla^2 \\phi(\\mathbf{x})] = -k^2 \\tilde{\\phi}(\\mathbf{k}) $$\n将傅里叶变换应用于整个泊松方程得到：\n$$ -k^2 \\tilde{\\phi}(\\mathbf{k}) = 4\\pi \\tilde{\\delta}(\\mathbf{k}) $$\n对于 $k \\neq 0$，求解傅里叶空间势 $\\tilde{\\phi}(\\mathbf{k})$ 可得：\n$$ \\tilde{\\phi}(\\mathbf{k}) = -\\frac{4\\pi}{k^2} \\tilde{\\delta}(\\mathbf{k}) $$\n接下来，我们必须求出给定的球对称高斯超密度 $\\delta(\\mathbf{x}) = \\delta_0 \\exp(-r^2 / (2\\sigma^2))$ 的傅里叶变换，其中 $r^2 = x^2+y^2+z^2$。\n$$ \\tilde{\\delta}(\\mathbf{k}) = \\int d^3x\\, \\delta_0 e^{-r^2/(2\\sigma^2)} e^{-i \\mathbf{k}\\cdot\\mathbf{x}} $$\n由于高斯函数和指数项在笛卡尔坐标系中的可分离性，这个三维积分变成三个一维积分的乘积：\n$$ \\tilde{\\delta}(\\mathbf{k}) = \\delta_0 \\left( \\int_{-\\infty}^{\\infty} dx\\, e^{-x^2/(2\\sigma^2)} e^{-ik_x x} \\right) \\left( \\int_{-\\infty}^{\\infty} dy\\, e^{-y^2/(2\\sigma^2)} e^{-ik_y y} \\right) \\left( \\int_{-\\infty}^{\\infty} dz\\, e^{-z^2/(2\\sigma^2)} e^{-ik_z z} \\right) $$\n每个积分都是高斯函数的标准傅里叶变换。对于一般的一维高斯函数 $e^{-ax^2}$，其变换为 $\\int_{-\\infty}^{\\infty} dx\\, e^{-ax^2} e^{-ikx} = \\sqrt{\\pi/a} e^{-k^2/(4a)}$。\n在我们的例子中，$a = 1/(2\\sigma^2)$，所以关于 $x$ 的积分为：\n$$ \\int_{-\\infty}^{\\infty} dx\\, e^{-x^2/(2\\sigma^2)} e^{-ik_x x} = \\sqrt{2\\pi\\sigma^2} e^{-k_x^2 \\sigma^2/2} $$\n将三个维度（$x$, $y$, $z$）的结果相乘得到：\n$$ \\tilde{\\delta}(\\mathbf{k}) = \\delta_0 (2\\pi\\sigma^2)^{3/2} e^{-(k_x^2+k_y^2+k_z^2)\\sigma^2/2} = \\delta_0 (2\\pi\\sigma^2)^{3/2} e^{-k^2\\sigma^2/2} $$\n将此结果代入 $\\tilde{\\phi}(\\mathbf{k})$ 的表达式中，得到傅里叶空间势的最终解析表达式：\n$$ \\tilde{\\phi}(\\mathbf{k}) = -\\frac{4\\pi}{k^2} \\delta_0 (2\\pi\\sigma^2)^{3/2} e^{-k^2\\sigma^2/2} $$\n\n### 第 2 部分：实空间径向力 $F_r(r)$ 的解析推导\n\n对于一个球对称系统，泊松方程 $\\nabla^2\\phi = 4\\pi\\delta$ 得以简化。在球坐标中，仅依赖于半径 $r$ 的函数 $\\phi(r)$ 的拉普拉斯算子为 $\\nabla^2 \\phi(r) = \\frac{1}{r^2} \\frac{d}{dr}\\left(r^2 \\frac{d\\phi}{dr}\\right)$。方程变为：\n$$ \\frac{1}{r^2} \\frac{d}{dr}\\left(r^2 \\frac{d\\phi}{dr}\\right) = 4\\pi \\delta(r) = 4\\pi \\delta_0 e^{-r^2/(2\\sigma^2)} $$\n我们可以对这个方程进行积分以求出力。首先，两边乘以 $r^2$ 并从 $0$ 积分到半径 $r$：\n$$ \\int_0^r \\frac{d}{dr'}\\left(r'^2 \\frac{d\\phi}{dr'}\\right) dr' = \\int_0^r 4\\pi \\delta_0 r'^2 e^{-r'^2/(2\\sigma^2)} dr' $$\n左侧的计算结果为 $r^2 \\frac{d\\phi}{dr}$（假设引力场 $-\\frac{d\\phi}{dr}$ 在 $r=0$ 处是有限的）。\n径向力定义为 $F_r(r) = -\\frac{d\\phi}{dr}$。因此，我们可以写出：\n$$ -r^2 F_r(r) = 4\\pi \\delta_0 \\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' $$\n$$ F_r(r) = -\\frac{4\\pi \\delta_0}{r^2} \\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' $$\n剩下的任务是计算这个积分。这可以通过分部积分法 $\\int u dv = uv - \\int v du$ 来完成。\n令 $u=r'$ 且 $dv = r' e^{-r'^2/(2\\sigma^2)} dr'$。那么 $du=dr'$ 且 $v = -\\sigma^2 e^{-r'^2/(2\\sigma^2)}$。\n\\begin{align*}\n\\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' = \\left[ -r' \\sigma^2 e^{-r'^2/(2\\sigma^2)} \\right]_0^r - \\int_0^r (-\\sigma^2 e^{-r'^2/(2\\sigma^2)}) dr' \\\\\n= -r \\sigma^2 e^{-r^2/(2\\sigma^2)} + \\sigma^2 \\int_0^r e^{-r'^2/(2\\sigma^2)} dr'\n\\end{align*}\n积分 $\\int_0^r e^{-r'^2/(2\\sigma^2)} dr'$ 与误差函数 $\\text{erf}(z) = \\frac{2}{\\sqrt{\\pi}}\\int_0^z e^{-t^2} dt$ 有关。\n令 $t = r'/(\\sqrt{2}\\sigma)$，则 $r' = \\sqrt{2}\\sigma t$ 且 $dr' = \\sqrt{2}\\sigma dt$。积分上限变为 $r/(\\sqrt{2}\\sigma)$。\n$$ \\int_0^r e^{-r'^2/(2\\sigma^2)} dr' = \\int_0^{r/(\\sqrt{2}\\sigma)} e^{-t^2} (\\sqrt{2}\\sigma dt) = \\sqrt{2}\\sigma \\frac{\\sqrt{\\pi}}{2} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) = \\sigma \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) $$\n将此代回，完整的积分为：\n$$ \\int_0^r r'^2 e^{-r'^2/(2\\sigma^2)} dr' = \\sigma^3 \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) - r \\sigma^2 e^{-r^2/(2\\sigma^2)} $$\n最后，将此代入 $F_r(r)$ 的表达式中：\n$$ F_r(r) = -\\frac{4\\pi \\delta_0}{r^2} \\left[ \\sigma^3 \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) - r \\sigma^2 e^{-r^2/(2\\sigma^2)} \\right] $$\n$$ F_r(r) = -4\\pi \\delta_0 \\left[ \\frac{\\sigma^3}{r^2} \\sqrt{\\frac{\\pi}{2}} \\text{erf}\\left(\\frac{r}{\\sqrt{2}\\sigma}\\right) - \\frac{\\sigma^2}{r} e^{-r^2/(2\\sigma^2)} \\right] $$\n这是径向力的解析表达式。注意当 $r \\to 0$ 时，$F_r(r) \\to -\\frac{4\\pi\\delta_0}{3}r \\to 0$。\n\n### 第 3 部分：数值方法 (Particle-Mesh 求解器)\n\n数值解是通过在周期性立方体网格上使用谱 Particle-Mesh (PM) 方法找到的。算法流程如下：\n\n1.  **网格离散化**：边长为 $L$ 的域被离散化为一个 $N \\times N \\times N$ 的网格。网格间距为 $dx=L/N$。我们定义一个中心化的坐标网格 $(x_i, y_j, z_k)$，其中 $x_i = (i - N/2)dx$，$i \\in \\{0, \\dots, N-1\\}$，对于 $y$ 和 $z$ 也类似。\n\n2.  **密度场**：在每个网格点上对连续高斯超密度 $\\delta(\\mathbf{x})$ 进行采样，以创建离散密度场 $\\delta_{ijk} = \\delta(x_i, y_j, z_k)$。\n\n3.  **正向傅里叶变换**：使用快速傅里叶变换 (FFT) 将离散密度场变换到傅里叶空间：$\\tilde{\\delta}_{\\mathbf{k}} = \\mathcal{F}[\\delta_{ijk}]$。\n\n4.  **在傅里叶空间中求解**：使用泊松方程在傅里叶空间中的代数形式。离散波数由 $k_i = 2\\pi n_i/L$ 给出，其中 $n_i$ 是 FFT 算法提供的整频率。我们构建一个波数向量 $\\mathbf{k}$ 及其平方大小 $k^2 = k_x^2+k_y^2+k_z^2$ 的网格。然后计算傅里叶空间势：\n    $$ \\tilde{\\phi}_{\\mathbf{k}} = -\\frac{4\\pi}{k^2} \\tilde{\\delta}_{\\mathbf{k}} $$\n    模式 $\\mathbf{k}=\\mathbf{0}$ ($k^2=0$) 对应于平均势。通过手动设置 $\\tilde{\\phi}(\\mathbf{0}) = 0$ 来避免除以零。这会将平均势设置为零，不影响力的计算，因为力取决于势的梯度。\n\n5.  **谱力计算**：使用谱微分性质 $\\mathcal{F}[-\\nabla\\phi] = -i\\mathbf{k}\\tilde{\\phi}(\\mathbf{k})$ 在傅里叶空间中计算力分量 $\\mathbf{F} = -\\nabla\\phi$：\n    $$ \\tilde{F}_{x,\\mathbf{k}} = -i k_x \\tilde{\\phi}_{\\mathbf{k}}, \\quad \\tilde{F}_{y,\\mathbf{k}} = -i k_y \\tilde{\\phi}_{\\mathbf{k}}, \\quad \\tilde{F}_{z,\\mathbf{k}} = -i k_z \\tilde{\\phi}_{\\mathbf{k}} $$\n\n6.  **逆傅里叶变换**：通过对其傅里叶空间对应物应用逆 FFT 来恢复实空间中的力分量 $F_x, F_y, F_z$。对于实数输入场，得到的力场必须是实数；任何小的虚部都是由数值浮点误差引起的，应被舍弃。\n\n7.  **径向力投影**：通过将矢量力场 $\\mathbf{F}(\\mathbf{x})$ 投影到径向方向向量 $\\mathbf{x}$ 上，计算每个网格点 $(\\mathbf{x})$ 处的最终数值径向力：\n    $$ F_r^{\\text{PM}}(\\mathbf{x}) = \\frac{\\mathbf{F}(\\mathbf{x}) \\cdot \\mathbf{x}}{\\|\\mathbf{x}\\|} \\quad \\text{for } \\|\\mathbf{x}\\|>0, \\quad \\text{and } F_r^{\\text{PM}}(\\mathbf{0})=0 $$\n\n### 第 4 部分：比较和误差度量\n\n数值 PM 求解器的准确性通过将其输出 $F_r^{\\text{PM}}(\\mathbf{x})$ 与在相同网格点上求值的推导出的解析解 $F_r^{\\text{analytic}}(r)$ 进行比较来评估。比较被限制在盒子的内部区域 $r \\le L/4$，以最小化基于 FFT 方法固有的周期性镜像污染。点 $r=0$ 被排除在外。每个点上的相对误差 $\\epsilon(\\mathbf{x})$ 计算如下：\n$$ \\epsilon(\\mathbf{x}) = \\frac{|F_r^{\\text{PM}}(\\mathbf{x}) - F_r^{\\text{analytic}}(r)|}{\\max(|F_r^{\\text{analytic}}(r)|, \\varepsilon)} $$\n其中 $\\varepsilon$ 是一个小的正则化常数，选择为最大解析力大小的一部分，以防止在解析力接近零时除以小数。每个测试用例的最终报告指标是在比较区域内找到的最大相对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    def solve_poisson_pm(N, L, sigma, delta_0):\n        \"\"\"\n        Solves the Poisson equation for a Gaussian density profile using a PM method\n        and compares the resulting force field to the analytical solution.\n    \n        Args:\n            N (int): Number of grid points per dimension.\n            L (float): Side length of the cubic domain.\n            sigma (float): Width of the Gaussian overdensity.\n            delta_0 (float): Amplitude of the Gaussian overdensity.\n    \n        Returns:\n            float: The maximum relative error between numerical and analytical force.\n        \"\"\"\n        # 1. Grid and Coordinate Setup\n        dx = L / N\n        # Create coordinates centered at the origin, as specified in the problem.\n        coords = (np.arange(N) - N / 2) * dx\n        xx, yy, zz = np.meshgrid(coords, coords, coords, indexing='ij')\n        r = np.sqrt(xx**2 + yy**2 + zz**2)\n    \n        # 2. Sample Density Field\n        delta_grid = delta_0 * np.exp(-r**2 / (2 * sigma**2))\n    \n        # 3. Fourier-space solution\n        # 3a. Wavenumbers (k-vectors)\n        k_vals = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n        kx, ky, kz = np.meshgrid(k_vals, k_vals, k_vals, indexing='ij')\n        k_squared = kx**2 + ky**2 + kz**2\n    \n        # Avoid division by zero for the k=0 mode.\n        # The value is arbitrary as phi_k[0,0,0] will be set to 0 later.\n        if N > 0:\n            k_squared[0, 0, 0] = 1.0\n    \n        # 3b. FFT of density\n        delta_k = np.fft.fftn(delta_grid)\n    \n        # 3c. Solve for potential in k-space: phi_k = -4 * pi * delta_k / k^2\n        phi_k = -4 * np.pi * delta_k / k_squared\n        \n        # 3d. Set DC mode of potential to zero (fixes arbitrary offset)\n        if N > 0:\n            phi_k[0, 0, 0] = 0.0\n    \n        # 4. Compute Force Field\n        # 4a. Force components in k-space: F_i = -i * k_i * phi\n        Fx_k = -1j * kx * phi_k\n        Fy_k = -1j * ky * phi_k\n        Fz_k = -1j * kz * phi_k\n    \n        # 4b. Inverse FFT to get real-space force components\n        # The result of ifftn should be real; take the real part to discard\n        # machine-precision imaginary noise.\n        Fx = np.fft.ifftn(Fx_k).real\n        Fy = np.fft.ifftn(Fy_k).real\n        Fz = np.fft.ifftn(Fz_k).real\n    \n        # 5. Compute Numerical Radial Force\n        # F_r = (F . r) / |r|. Use np.divide to handle r=0 safely.\n        Fr_pm = np.divide(Fx * xx + Fy * yy + Fz * zz, r, out=np.zeros_like(r), where=(r != 0))\n    \n        # 6. Compute Analytical Radial Force\n        # The limit of F_r(r) as r->0 is 0. Handle r=0 separately.\n        Fr_analytic = np.zeros_like(r)\n        non_zero_r_mask = r > 0\n        r_nz = r[non_zero_r_mask]\n    \n        term1 = (sigma**3 / r_nz**2) * np.sqrt(np.pi / 2.0) * erf(r_nz / (np.sqrt(2.0) * sigma))\n        term2 = (sigma**2 / r_nz) * np.exp(-r_nz**2 / (2.0 * sigma**2))\n        \n        Fr_analytic[non_zero_r_mask] = -4.0 * np.pi * delta_0 * (term1 - term2)\n    \n        # 7. Compare and Compute Maximum Relative Error\n        # Define comparison region: r = L/4 and r > 0\n        mask = (r = L/4)  (r > 0)\n        \n        if not np.any(mask):\n            return 0.0  # No points in comparison region\n    \n        # Calculate the small threshold epsilon to regularize division\n        analytic_force_in_mask = np.abs(Fr_analytic[mask])\n        if analytic_force_in_mask.size == 0:\n             return 0.0\n        \n        max_abs_analytic_force = np.max(analytic_force_in_mask)\n\n        # Handle case where force is zero everywhere (e.g. delta_0 = 0)\n        if max_abs_analytic_force == 0:\n            # If PM force is also zero, error is 0. Otherwise it's infinite.\n            # We expect PM force to be near zero.\n            return np.max(np.abs(Fr_pm[mask]))\n\n        epsilon_threshold = max_abs_analytic_force * 1e-9\n    \n        # Compute relative error\n        numerator = np.abs(Fr_pm[mask] - Fr_analytic[mask])\n        denominator = np.maximum(analytic_force_in_mask, epsilon_threshold)\n        \n        relative_error = numerator / denominator\n        max_relative_error = np.max(relative_error)\n        \n        return max_relative_error\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, sigma, delta_0)\n        (64, 1.0, 0.05, 0.01),      # General case\n        (64, 1.0, 0.05, -0.01),     # Underdensity\n        (128, 1.0, 0.15, 0.02),     # Broad profile\n        (64, 1.0, 1.0 / 64, 0.01),  # Near-grid-resolution width\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, sigma, delta_0 = case\n        error = solve_poisson_pm(N, L, sigma, delta_0)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3489960"}, {"introduction": "在求得引力势 $\\Phi$ 后，下一步通常是计算引力场 $\\mathbf{g} = -\\nabla\\Phi$。本练习将比较两种计算梯度的方法：一种是在傅里叶空间中计算梯度的“纯谱方法”，另一种是将势变换回实空间后使用有限差分近似的“混合方法”。这种比较对于理解数值模拟中不同误差来源至关重要，特别是谱方法精度与有限差分近似引入的离散化误差之间的区别。[@problem_id:3490043]", "problem": "您需要在一个周期性立方网格上，评估在共动、无量纲单位下的牛顿泊松方程中，从密度对比场 $\\,\\delta(\\mathbf{x})\\,$ 计算引力加速度场 $\\,\\mathbf{g}(\\mathbf{x})\\,$ 的两种数值上不同但解析上等价的途径之间的一致性。控制方程是在边长为 $\\,L\\,$ 的周期性区域上的泊松方程\n$$\n\\nabla^2 \\Phi(\\mathbf{x}) \\;=\\; \\delta(\\mathbf{x}),\n$$\n其中 $\\,\\Phi(\\mathbf{x})\\,$ 是引力势，$\\,\\mathbf{g}(\\mathbf{x}) = -\\nabla \\Phi(\\mathbf{x})\\,$ 是引力加速度。假设 $\\,\\int \\delta(\\mathbf{x})\\,d^3x = 0\\,$，因此势的零模被设为零。所有量都是无量纲和无单位的。角度以弧度为单位测量。\n\n您将在一个具有 $\\,N \\times N \\times N\\,$ 个节点和周期性边界条件的均匀网格上实现这两种途径：\n\n- 途径 A (谱梯度)：使用离散傅里叶变换 (DFT) 在傅里叶空间中求解泊松方程。如果 $\\,\\tilde{f}(\\mathbf{k})\\,$ 表示 $\\,f(\\mathbf{x})\\,$ 的 DFT，并且 $\\,\\mathbf{k}=(k_x,k_y,k_z)\\,$ 是与 DFT 频率指数相关联的角波矢量，那么非零模的解是\n$$\n\\tilde{\\Phi}(\\mathbf{k}) \\;=\\; -\\,\\frac{\\tilde{\\delta}(\\mathbf{k})}{k_x^2 + k_y^2 + k_z^2}.\n$$\n设 $\\,\\tilde{\\Phi}(\\mathbf{0})=0\\,$。然后通过谱梯度的逆 DFT 计算引力加速度：\n$$\n\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\;=\\; \\mathcal{F}^{-1}\\!\\left[ -\\,i\\,\\mathbf{k}\\,\\tilde{\\Phi}(\\mathbf{k}) \\right].\n$$\n\n- 途径 B (有限差分梯度)：使用与上面相同的 $\\,\\tilde{\\Phi}(\\mathbf{k})\\,$，通过逆 DFT 计算 $\\,\\Phi(\\mathbf{x})\\,$，然后使用带周期性边界的二阶精确中心有限差分来近似梯度。设网格间距为 $\\,\\Delta x = L/N\\,$，单位矢量为 $\\,\\hat{e}_j\\,$，则分量 $\\,j \\in \\{x,y,z\\}\\,$ 为\n$$\ng_{\\mathrm{fd},j}(\\mathbf{x}) \\;=\\; -\\,\\frac{ \\Phi(\\mathbf{x}+\\Delta x\\,\\hat{e}_j) \\;-\\; \\Phi(\\mathbf{x}-\\Delta x\\,\\hat{e}_j) }{ 2\\,\\Delta x }.\n$$\n\n通过相对均方根范数来量化这两种途径之间的差异\n$$\n\\varepsilon \\;=\\; \\frac{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) - \\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} }{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} },\n$$\n其中 $\\,\\langle \\cdot \\rangle\\,$ 表示对所有网格点的平均，$\\,\\|\\cdot\\|\\,$ 是分量空间中的欧几里得范数。\n\n使用与幺正逆 DFT 归一化相一致的标准 DFT 频率到波数的映射。如果 $\\,\\nu\\,$ 表示循环频率（单位为每单位长度的周期数），那么角波数为 $\\,k = 2\\pi \\nu\\,$。在 DFT 网格上构建 $\\,\\mathbf{k}\\,$ 时，请精确使用此映射，并在零模处小心处理。\n\n您的程序必须实现以下测试套件，为每种情况构建 $\\,\\delta(\\mathbf{x})\\,$，计算 $\\,\\varepsilon\\,$，并报告结果。所有场都位于位置为 $\\,x_j = j\\,\\Delta x\\,$, $\\,y_j = j\\,\\Delta x\\,$, $\\,z_j = j\\,\\Delta x\\,$（其中 $\\,j \\in \\{0,\\dots,N-1\\}\\,$）的网格节点上。\n\n测试套件：\n\n- 情况1 (单个低频平面波)：$\\,N=32\\,$, $\\,L=1\\,$, $\\,\\delta(\\mathbf{x}) = \\cos\\big(2\\pi\\,(1\\,x + 2\\,y + 3\\,z)\\big)\\,$。\n\n- 情况2 (带相位的各向异性模式之和)：$\\,N=48\\,$, $\\,L=1\\,$, \n$$\n\\delta(\\mathbf{x}) \\;=\\; \\sum_{m=1}^{4} A_m \\cos\\!\\Big(2\\pi\\,(\\mathbf{n}_m \\cdot \\mathbf{x}) + \\varphi_m\\Big),\n$$\n其中振幅 $\\,A_1=0.5\\,$, $\\,A_2=0.7\\,$, $\\,A_3=0.9\\,$, $\\,A_4=0.4\\,$，整数矢量 $\\,\\mathbf{n}_1=(3,0,0)\\,$, $\\,\\mathbf{n}_2=(0,5,0)\\,$, $\\,\\mathbf{n}_3=(0,0,7)\\,$, $\\,\\mathbf{n}_4=(2,3,1)\\,$，以及相位 $\\,\\varphi_1=0.1\\,$, $\\,\\varphi_2=-0.3\\,$, $\\,\\varphi_3=0.5\\,$, $\\,\\varphi_4=1.1\\,$。\n\n- 情况3 (沿一个轴接近奈奎斯特频率)：$\\,N=32\\,$, $\\,L=1\\,$, $\\,\\delta(\\mathbf{x}) = \\cos\\big(2\\pi\\,(15\\,x)\\big)\\,$。\n\n- 情况4 (离轴高度各向异性)：$\\,N=64\\,$, $\\,L=1\\,$, $\\,\\delta(\\mathbf{x}) = \\cos\\big(2\\pi\\,(30\\,y + 1\\,z)\\big)\\,$。\n\n实现约束和输出规范：\n\n- 使用与快速傅里叶变换 (FFT) 对一致的离散傅里叶变换，其逆变换被 $\\,1/N^3\\,$ 归一化，以便帕塞瓦尔定理以标准数值因子成立。使用 $\\,k=2\\pi \\nu\\,$ 从 DFT 频率构建 $\\,\\mathbf{k}\\,$。\n\n- 对于每种情况，计算如上定义的 $\\,\\varepsilon\\,$。您的程序应生成一行输出，其中包含四个结果，格式为方括号括起来的逗号分隔列表，每个浮点数四舍五入到8位小数，并以十进制表示法（而非科学记数法）表示，顺序为情况1到情况4。例如：$\\,\\big[0.00001234,0.05670000,0.12340000,0.98765000\\big]\\,$。\n\n- 无需用户输入。程序必须是确定性的。\n\n- 所有量都是无量纲的，因此无需报告物理单位。", "solution": "我们从边长为 $\\,L\\,$ 的周期性区域上的无量纲化单位下的牛顿泊松方程开始：\n$$\n\\nabla^2 \\Phi(\\mathbf{x}) \\;=\\; \\delta(\\mathbf{x}),\n$$\n并将引力加速度定义为 $\\,\\mathbf{g}(\\mathbf{x}) = -\\nabla \\Phi(\\mathbf{x})\\,$。在周期性区域上，在傅里叶空间中工作很方便。用 $\\,\\mathcal{F}\\,$ 表示离散傅里叶变换 (DFT)，用 $\\,\\mathcal{F}^{-1}\\,$ 表示其逆变换。设 $\\,\\tilde{f}(\\mathbf{k})\\,$ 是 $\\,f(\\mathbf{x})\\,$ 的 DFT，其中傅里叶空间网格标签 $\\,\\mathbf{k}=(k_x,k_y,k_z)\\,$ 是通过 $\\,k=2\\pi \\nu\\,$ 从 DFT 循环频率 $\\,\\nu\\,$ 构建的。DFT 的微分性质与连续情况下的性质相似：$\\,\\mathcal{F}\\!\\left[\\partial_j f\\right]= i k_j \\tilde{f}\\,$ 和 $\\,\\mathcal{F}\\!\\left[\\nabla^2 f\\right]= - (k_x^2+k_y^2+k_z^2)\\,\\tilde{f}\\,$. 因此，对于所有非零波矢量，\n$$\n\\tilde{\\Phi}(\\mathbf{k}) \\;=\\; -\\frac{\\tilde{\\delta}(\\mathbf{k})}{k_x^2 + k_y^2 + k_z^2}, \\quad \\tilde{\\Phi}(\\mathbf{0}) = 0,\n$$\n谱梯度加速度为\n$$\n\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\;=\\; \\mathcal{F}^{-1}\\!\\left[ -\\,i\\,\\mathbf{k}\\,\\tilde{\\Phi}(\\mathbf{k}) \\right].\n$$\n对于网格上表示的模式，该途径在谱方法上是精确的，误差仅为浮点舍入误差。\n\n另一种方法是，我们通过 $\\,\\Phi(\\mathbf{x})=\\mathcal{F}^{-1}[\\tilde{\\Phi}(\\mathbf{k})]\\,$ 在实空间中计算势，并用带周期性边界条件的中心有限差分算子来近似梯度，\n$$\n\\left(\\nabla \\Phi\\right)_j(\\mathbf{x}) \\;\\approx\\; \\frac{\\Phi(\\mathbf{x}+\\Delta x\\,\\hat{e}_j) - \\Phi(\\mathbf{x}-\\Delta x\\,\\hat{e}_j)}{2\\,\\Delta x}, \\qquad \\Delta x = \\frac{L}{N}.\n$$\n因此，\n$$\n\\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x}) \\;=\\; -\\,\\left( D_x \\Phi(\\mathbf{x}),\\, D_y \\Phi(\\mathbf{x}),\\, D_z \\Phi(\\mathbf{x}) \\right),\n$$\n每个分量都由中心差分格式计算。中心有限差分是导数的二阶精确近似，因此对于足够光滑的场，局部截断误差的标度为 $\\,\\mathcal{O}(\\Delta x^2)\\,$。然而，有限差分导数的离散色散与谱导数的不同，这引入了一个依赖于波数的确定性差异。\n\n为量化该差异，我们使用相对均方根 (RMS) 范数\n$$\n\\varepsilon \\;=\\; \\frac{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) - \\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} }{ \\left\\langle \\| \\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\|^2 \\right\\rangle^{1/2} }.\n$$\n这个无量纲度量在 $\\,\\delta(\\mathbf{x})\\,$ 的均匀重标度下保持不变，并直接比较这两种途径。\n\n为了获得解析上的理解，考虑一个单一平面波密度场 $\\,\\delta(\\mathbf{x})=\\cos(\\mathbf{k}_0\\cdot\\mathbf{x})\\,$，其中 $\\,\\mathbf{k}_0=(k_{0x},k_{0y},k_{0z})\\,$ 等于一个网格可分辨的角波矢量。势为 $\\,\\Phi(\\mathbf{x})=-\\cos(\\mathbf{k}_0\\cdot\\mathbf{x})/\\|\\mathbf{k}_0\\|^2\\,$。谱梯度为\n$$\n\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x}) \\;=\\; -\\,\\nabla \\Phi(\\mathbf{x}) \\;=\\; -\\,\\frac{\\mathbf{k}_0}{\\|\\mathbf{k}_0\\|^2}\\,\\sin(\\mathbf{k}_0\\cdot\\mathbf{x}).\n$$\n应用于平面波的沿分量 $\\,j\\,$ 的中心有限差分导数引入了符号 $\\,\\frac{\\sin(k_{0j}\\Delta x)}{\\Delta x}\\,$ 来代替谱因子 $\\,k_{0j}\\,$. 因此，\n$$\ng_{\\mathrm{fd},j}(\\mathbf{x}) \\;=\\; -\\,\\frac{\\sin(k_{0j}\\Delta x)}{\\Delta x\\,\\|\\mathbf{k}_0\\|^2}\\,\\sin(\\mathbf{k}_0\\cdot\\mathbf{x})\n\\;=\\; \\left(\\frac{\\sin(k_{0j}\\Delta x)}{k_{0j}\\Delta x}\\right)\\,g_{\\mathrm{spec},j}(\\mathbf{x}),\n$$\n约定如果 $\\,k_{0j}=0\\,$ 该因子等于 $\\,1\\,$. 因此，对于每个分量，\n$$\n\\frac{g_{\\mathrm{fd},j}}{g_{\\mathrm{spec},j}} \\;=\\; \\operatorname{sinc}\\!\\left(\\frac{k_{0j}\\Delta x}{\\pi}\\right) \\;=\\; \\frac{\\sin(k_{0j}\\Delta x)}{k_{0j}\\Delta x},\n$$\n并且 RMS 中的矢量差异通过这些分量因子依赖于 $\\,\\mathbf{k}_0\\,$ 的方向。对于小的 $\\,\\|\\mathbf{k}_0\\|\\Delta x\\,$，泰勒级数 $\\,\\sin(\\xi)/\\xi = 1 - \\xi^2/6 + \\mathcal{O}(\\xi^4)\\,$ 表明相对误差的标度为 $\\,\\mathcal{O}(\\Delta x^2)\\,$。在奈奎斯特波数附近，$\\,k\\Delta x \\to \\pi\\,$，该比率趋近于 $\\,0\\,$，差异趋近于单位量级。\n\n每个测试用例的算法设计：\n\n- 构建一个 $\\,N \\times N \\times N\\,$ 网格，其网格间距为 $\\,\\Delta x = L/N\\,$，节点坐标为 $\\,x_j=j\\Delta x\\,$, $\\,y_j=j\\Delta x\\,$, $\\,z_j=j\\Delta x\\,$，其中 $\\,j\\in\\{0,\\dots,N-1\\}\\,$。\n\n- 根据情况定义构建 $\\,\\delta(\\mathbf{x})\\,$。对于整数模式矢量 $\\,\\mathbf{n}\\,$，角波数为 $\\,\\mathbf{k}_0 = 2\\pi\\,\\mathbf{n}/L\\,$，因此 $\\,\\delta(\\mathbf{x})=\\cos(\\mathbf{k}_0\\cdot\\mathbf{x}+\\varphi)\\,$。\n\n- 通过 DFT 计算 $\\,\\tilde{\\delta}(\\mathbf{k})\\,$。从通过 $\\,k=2\\pi\\nu\\,$ 映射的 DFT 循环频率 $\\,\\nu\\,$ 构建数组 $\\,k_x\\,$, $\\,k_y\\,$, $\\,k_z\\,$，并将它们广播到三维傅里叶网格。\n\n- 对所有非零波矢量计算 $\\,\\tilde{\\Phi}(\\mathbf{k}) = -\\tilde{\\delta}(\\mathbf{k})/(k_x^2+k_y^2+k_z^2)\\,$，并将零模设为零。在实践中，将零索引处的分母设为 $+\\infty$，这样除法结果为零。\n\n- 途径 A: 通过对 $\\, -i\\,k_j\\,\\tilde{\\Phi}(\\mathbf{k})\\,$ 的每个分量进行逆变换来计算 $\\,\\mathbf{g}_{\\mathrm{spec}}(\\mathbf{x})\\,$。\n\n- 途径 B: 通过对 $\\,\\tilde{\\Phi}(\\mathbf{k})\\,$ 进行逆 DFT 计算 $\\,\\Phi(\\mathbf{x})\\,$，然后用周期性位移计算中心有限差分，以获得 $\\,\\mathbf{g}_{\\mathrm{fd}}(\\mathbf{x})=-\\nabla \\Phi(\\mathbf{x})\\,$。\n\n- 计算 $\\,\\varepsilon\\,$ 作为上面定义的 RMS 范数之比。分子是差分矢量 $\\,\\mathbf{g}_{\\mathrm{spec}}-\\mathbf{g}_{\\mathrm{fd}}\\,$ 的欧几里得范数平方在所有网格节点上的平均值的平方根，分母是 $\\,\\mathbf{g}_{\\mathrm{spec}}\\,$ 的 RMS 范数。\n\n该测试套件测试了几个不同范围：一个低频各向异性模式，其中 $\\,\\varepsilon\\,$ 应该很小且标度为 $\\,\\mathcal{O}(\\Delta x^2)\\,$；一个带相位的模式之和，用以测试线性叠加和各向异性；一个接近奈奎斯特频率的模式，其中中心有限差分导数相对于谱导数被强烈阻尼，导致较大的 $\\,\\varepsilon\\,$；以及一个离轴高度各向异性情况，其中不同分量经历不同的离散符号。程序实现了这个流程，并按要求的顺序将四个 $\\,\\varepsilon\\,$ 值打印出来，每个值四舍五入到8位小数，作为一个用方括号括起来的、逗号分隔的列表。", "answer": "```python\nimport numpy as np\n\ndef construct_k_arrays(N, L):\n    # Construct angular wavenumbers k = 2*pi*nu for each axis using DFT frequencies.\n    dx = L / N\n    # np.fft.fftfreq returns frequencies in cycles per unit length; d=dx ensures correct scaling.\n    freq = np.fft.fftfreq(N, d=dx)  # cycles per unit length\n    k1d = 2.0 * np.pi * freq        # angular wavenumbers\n    kx = k1d[:, None, None]\n    ky = k1d[None, :, None]\n    kz = k1d[None, None, :]\n    return kx, ky, kz\n\ndef spectral_poisson_phi(delta, L):\n    N = delta.shape[0]\n    # Forward FFT to Fourier space\n    delta_k = np.fft.fftn(delta)\n    # Construct k arrays\n    kx, ky, kz = construct_k_arrays(N, L)\n    k2 = kx**2 + ky**2 + kz**2\n    # Avoid division by zero at the zero mode by setting denominator to inf there\n    k2_safe = k2.copy()\n    k2_safe[0, 0, 0] = np.inf\n    phi_k = - delta_k / k2_safe\n    return phi_k, (kx, ky, kz)\n\ndef spectral_gradient_from_phi_k(phi_k, k_arrays):\n    kx, ky, kz = k_arrays\n    # Compute spectral gradient components and inverse FFT to real space\n    gx = np.fft.ifftn(-1j * kx * phi_k).real\n    gy = np.fft.ifftn(-1j * ky * phi_k).real\n    gz = np.fft.ifftn(-1j * kz * phi_k).real\n    return gx, gy, gz\n\ndef finite_difference_gradient_from_phi(phi, L):\n    N = phi.shape[0]\n    dx = L / N\n    # Centered differences with periodic boundaries\n    dphidx = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2.0 * dx)\n    dphidy = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2.0 * dx)\n    dphidz = (np.roll(phi, -1, axis=2) - np.roll(phi, 1, axis=2)) / (2.0 * dx)\n    # Acceleration g = -grad Phi\n    gx = -dphidx\n    gy = -dphidy\n    gz = -dphidz\n    return gx, gy, gz\n\ndef relative_rms_error(g_spec, g_fd):\n    gx_s, gy_s, gz_s = g_spec\n    gx_f, gy_f, gz_f = g_fd\n    # Compute RMS norms\n    diff_sq = (gx_s - gx_f)**2 + (gy_s - gy_f)**2 + (gz_s - gz_f)**2\n    spec_sq = gx_s**2 + gy_s**2 + gz_s**2\n    # Avoid division by zero in pathological cases by adding tiny epsilon, though spec_sq should be >0 for nontrivial fields\n    num = np.sqrt(np.mean(diff_sq))\n    den = np.sqrt(np.mean(spec_sq))\n    # If den is zero (shouldn't happen with our test cases), define error as 0.0 to keep determinism\n    if den == 0.0:\n        return 0.0\n    return float(num / den)\n\ndef build_delta_case(case_id):\n    # Returns N, L, delta(x)\n    if case_id == 1:\n        N, L = 32, 1.0\n        # delta = cos(2*pi*(1*x + 2*y + 3*z))\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.cos(2.0 * np.pi * (1.0 * X + 2.0 * Y + 3.0 * Z))\n        return N, L, delta\n    elif case_id == 2:\n        N, L = 48, 1.0\n        # Sum of modes with amplitudes and phases\n        amps = [0.5, 0.7, 0.9, 0.4]\n        ns = [(3, 0, 0), (0, 5, 0), (0, 0, 7), (2, 3, 1)]\n        phases = [0.1, -0.3, 0.5, 1.1]  # radians\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.zeros((N, N, N), dtype=np.float64)\n        for A, (nx, ny, nz), phi in zip(amps, ns, phases):\n            arg = 2.0 * np.pi * (nx * X + ny * Y + nz * Z) + phi\n            delta += A * np.cos(arg)\n        return N, L, delta\n    elif case_id == 3:\n        N, L = 32, 1.0\n        # Near-Nyquist along x: delta = cos(2*pi*(15*x))\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.cos(2.0 * np.pi * (15.0 * X))\n        return N, L, delta\n    elif case_id == 4:\n        N, L = 64, 1.0\n        # Off-axis high anisotropy: delta = cos(2*pi*(30*y + 1*z))\n        x = np.arange(N) * (L / N)\n        X, Y, Z = np.meshgrid(x, x, x, indexing='ij')\n        delta = np.cos(2.0 * np.pi * (30.0 * Y + 1.0 * Z))\n        return N, L, delta\n    else:\n        raise ValueError(\"Unknown case id\")\n\ndef compute_case_error(case_id):\n    N, L, delta = build_delta_case(case_id)\n    # Solve Poisson in Fourier space\n    phi_k, k_arrays = spectral_poisson_phi(delta, L)\n    # Route A: spectral gradient\n    g_spec = spectral_gradient_from_phi_k(phi_k, k_arrays)\n    # Route B: finite difference gradient\n    phi = np.fft.ifftn(phi_k).real\n    g_fd = finite_difference_gradient_from_phi(phi, L)\n    # Relative RMS error\n    err = relative_rms_error(g_spec, g_fd)\n    return err\n\ndef format_float_list(values, decimals=8):\n    # Format list of floats to fixed decimal places without scientific notation\n    fmt = f\"{{:.{decimals}f}}\"\n    return \"[\" + \",\".join(fmt.format(v) for v in values) + \"]\"\n\ndef solve():\n    test_cases = [1, 2, 3, 4]\n    results = []\n    for cid in test_cases:\n        err = compute_case_error(cid)\n        results.append(err)\n    print(format_float_list(results, decimals=8))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3490043"}, {"introduction": "在实际的宇宙学模拟中，平均密度 $\\bar{\\rho}$ 可能无法完美得知，或者在代码的不同部分有不同的定义。本练习旨在探讨使用一个与真实值略有偏差的估计平均密度所带来的数值后果。通过这个受控实验，您可以了解处理 $\\bar{\\rho}$ 不一致性如何引入误差，特别是如何影响密度场的零模（$\\mathbf{k}=\\mathbf{0}$），从而突显数值鲁棒性和一致性在模拟流程中的重要性。[@problem_id:3490042]", "problem": "考虑一个边长为 $L$ 的三维周期性立方体区域，其上有一个 $N \\times N \\times N$ 个点的均匀网格。设物质密度场为 $\\rho(\\mathbf{x}) = \\bar{\\rho}\\left(1 + \\delta_{\\text{true}}(\\mathbf{x})\\right)$，其中 $\\bar{\\rho}$ 是真实的全局平均密度，$\\delta_{\\text{true}}(\\mathbf{x})$ 是一个由两个余弦模定义的人工合成的超密度场。在数值宇宙学中，共动坐标下的牛顿势 $\\Phi(\\mathbf{x})$ 由泊松方程确定\n$$\n\\nabla^2 \\Phi(\\mathbf{x}) = 4 \\pi G a^2 \\bar{\\rho}\\, \\delta(\\mathbf{x}),\n$$\n其中 $G$ 是引力常数，$a$ 是标度因子，$\\delta(\\mathbf{x})$ 是无量纲超密度，定义为 $\\delta(\\mathbf{x}) = \\left(\\rho(\\mathbf{x}) - \\bar{\\rho}\\right)/\\bar{\\rho}$。在本问题中，使用代码单位进行计算，其中 $4 \\pi G a^2 = 1$ 且 $\\bar{\\rho}$ 是无量纲的。傅里叶空间（快速傅里叶变换(FFT)）解强制施加周期性边界条件，并源于泊松方程的空间傅里叶变换：\n$$\n-k^2 \\,\\hat{\\Phi}(\\mathbf{k}) = \\bar{\\rho}\\, \\hat{\\delta}(\\mathbf{k}),\n$$\n对于所有非零波矢 $\\mathbf{k}$，其中帽子符号表示傅里叶变换，且 $k = \\|\\mathbf{k}\\|$。零模 $k=0$ 没有唯一解，对应于 $\\Phi(\\mathbf{x})$ 的一个常数偏移，这对于从梯度导出的力在物理上是无关紧要的。在实践中，数值求解器设置 $\\hat{\\Phi}(\\mathbf{0}) = 0$。\n\n一个鲁棒的实现必须通过 $\\delta(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho}_{\\text{used}})/\\bar{\\rho}_{\\text{used}}$ 来计算 $\\delta(\\mathbf{x})$，其中 $\\bar{\\rho}_{\\text{used}}$ 是求解器使用的平均密度值。假设求解器可能使用一个带有微小分数误差 $\\epsilon$ 的估计平均值 $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho} (1 + \\epsilon)$，而不是真实的平均值 $\\bar{\\rho}$。考虑两种算法处理方式：\n1. 一致性处理：在计算 $\\delta(\\mathbf{x})$ 和在傅里叶空间中缩放泊松方程的源项时，都使用相同的 $\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}_{\\text{est}}$。\n2. 非一致性处理：在傅里叶空间中缩放源项时使用 $\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}$，但在计算 $\\delta(\\mathbf{x})$ 时使用 $\\bar{\\rho}_{\\text{est}}$。\n\n从上述基本定义出发，推导一个周期性网格上泊松方程的傅里叶空间求解器。然后，数值上演示 $\\bar{\\rho}_{\\text{used}}$ 的选择以及构建 $\\delta(\\mathbf{x})$ 和缩放源项之间的一致性如何影响解。特别地，为每个测试案例量化以下三个诊断量：\n- 实空间势的相对 $\\ell_2$ 误差，定义为\n$$\n\\text{err}_{\\Phi} \\equiv \\frac{\\|\\Phi_{\\text{case}} - \\Phi_{\\text{baseline}}\\|_2}{\\|\\Phi_{\\text{baseline}}\\|_2},\n$$\n其中基准案例使用 $\\epsilon=0$ 和一致性处理。\n- 傅里叶空间源项 $\\hat{S}(\\mathbf{k}) = \\bar{\\rho}_{\\text{used}}\\, \\hat{\\delta}(\\mathbf{k})$ 的零模量级与基准源中存在的最强非零模量级之比，\n$$\nr_{0} \\equiv \\frac{\\left|\\hat{S}_{\\text{case}}(\\mathbf{0})\\right|}{\\max_{\\mathbf{k}\\neq \\mathbf{0}} \\left|\\hat{S}_{\\text{baseline}}(\\mathbf{k})\\right|}.\n$$\n- 实空间势平均值的差异，\n$$\n\\Delta \\bar{\\Phi} \\equiv \\langle \\Phi_{\\text{case}} \\rangle - \\langle \\Phi_{\\text{baseline}} \\rangle,\n$$\n其中尖括号表示空间平均。\n\n使用以下人工合成的超密度、网格和区域规范来构建 $\\delta_{\\text{true}}(\\mathbf{x})$ 和 $\\rho(\\mathbf{x})$：\n- 区域大小：$L = 1$ (无量纲)。\n- 网格分辨率：每个维度 $N = 32$ 个点。\n- 真实平均密度：$\\bar{\\rho} = 1$ (无量纲)。\n- 超密度场：\n$$\n\\delta_{\\text{true}}(\\mathbf{x}) = A_1 \\cos\\left(2\\pi n_1 \\frac{x}{L}\\right) + A_2 \\cos\\left(2\\pi \\left(n_2 \\frac{y}{L} + n_3 \\frac{z}{L}\\right)\\right),\n$$\n振幅为 $A_1 = 0.2$、$A_2 = 0.1$，整数模指数为 $(n_1, n_2, n_3) = (2, 3, 2)$。\n\n通过对所有 $\\mathbf{k}\\neq \\mathbf{0}$ 计算 $\\hat{\\Phi}(\\mathbf{k}) = -\\hat{S}(\\mathbf{k})/k^2$ 并设置 $\\hat{\\Phi}(\\mathbf{0}) = 0$ 来实现傅里叶空间泊松求解器。然后变换回实空间以获得 $\\Phi(\\mathbf{x})$。\n\n测试套件：\n对以下五个由 $(\\epsilon, \\text{consistent})$ 指定的测试案例，评估三个诊断量 $\\left[\\text{err}_{\\Phi}, r_{0}, \\Delta \\bar{\\Phi}\\right]$：\n1. $(0.0,\\ \\text{True})$。\n2. $(10^{-3},\\ \\text{True})$。\n3. $(10^{-3},\\ \\text{False})$。\n4. $(-0.05,\\ \\text{False})$。\n5. $(0.1,\\ \\text{False})$。\n\n在所选的代码单位中，所有量都是无量纲的。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试案例的结果本身也是一个用方括号括起来的逗号分隔列表。例如，输出格式必须为\n$$\n[\\,[r_{1,1},r_{1,2},r_{1,3}],\\,[r_{2,1},r_{2,2},r_{2,3}],\\,\\dots\\,],\n$$\n该行中任何地方都不能有空格。每个 $r_{i,j}$ 都必须是浮点数。", "solution": "该问题是有效的。它在科学上基于牛顿引力原理和求解偏微分方程（特别是在宇宙学背景下的泊松方程）的数值方法。问题陈述清晰，所有必要的参数、定义和边界条件都已明确说明。语言客观且无歧义。该问题是计算物理学中一个标准的、尽管经过简化的练习。\n\n以下是求解的推导和步骤。\n\n### 1. 理论框架\n\n**a. 泊松方程及其傅里叶解：**\n问题始于共动坐标下的牛顿势 $\\Phi(\\mathbf{x})$ 的泊松方程：\n$$ \\nabla^2 \\Phi(\\mathbf{x}) = 4 \\pi G a^2 \\bar{\\rho}\\, \\delta(\\mathbf{x}) $$\n我们被要求在代码单位中工作，其中常数前置因子 $4 \\pi G a^2 = 1$。真实的超密度为 $\\delta_{\\text{true}}(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho})/\\bar{\\rho}$，其中 $\\rho(\\mathbf{x})$ 是真实的物质密度场，$\\bar{\\rho}$ 是其真实平均值。方程简化为：\n$$ \\nabla^2 \\Phi(\\mathbf{x}) = \\bar{\\rho}\\, \\delta(\\mathbf{x}) $$\n对于周期性区域，使用傅里叶变换是求解此方程最有效的方法。函数 $f(\\mathbf{x})$ 的傅里叶变换记为 $\\hat{f}(\\mathbf{k})$。拉普拉斯算子 $\\nabla^2$ 在傅里叶空间中变为乘以 $-k^2$，其中 $k = \\|\\mathbf{k}\\|$ 是波矢 $\\mathbf{k}$ 的大小。对泊松方程应用傅里叶变换得到：\n$$ -k^2 \\hat{\\Phi}(\\mathbf{k}) = \\widehat{(\\bar{\\rho}\\,\\delta)}(\\mathbf{k}) $$\n假设 $\\bar{\\rho}$ 是一个常数，我们在傅里叶空间中定义源项为 $\\hat{S}(\\mathbf{k}) = \\bar{\\rho} \\, \\hat{\\delta}(\\mathbf{k})$。方程变为：\n$$ -k^2 \\hat{\\Phi}(\\mathbf{k}) = \\hat{S}(\\mathbf{k}) $$\n对于任何非零波矢 $\\mathbf{k} \\neq \\mathbf{0}$，我们可以解出傅里叶空间中的势：\n$$ \\hat{\\Phi}(\\mathbf{k}) = - \\frac{\\hat{S}(\\mathbf{k})}{k^2} $$\n$\\mathbf{k}=\\mathbf{0}$ 的情况对应于直流分量或空间平均值。对于 $k=0$，方程变为 $0 = \\hat{S}(\\mathbf{0})$。如果源项的平均值 $\\hat{S}(\\mathbf{0})$ 非零，则方程不自洽。如果 $\\hat{S}(\\mathbf{0})=0$，则 $\\hat{\\Phi}(\\mathbf{0})$ 是不确定的。这种模糊性对应于在势 $\\Phi(\\mathbf{x})$ 上可以加上一个任意常数的自由度，这不影响从其梯度 $\\mathbf{g} = -\\nabla\\Phi$ 导出的物理力。按照规定，标准的数值实践是通过设置 $\\hat{\\Phi}(\\mathbf{0}) = 0$ 来解决这种模糊性。\n\n**b. 网格与离散化：**\n我们在一个边长为 $L$ 的立方体内的 $N \\times N \\times N$ 离散网格点上操作。\n- 实空间坐标：$\\mathbf{x}_{ijk} = (i \\frac{L}{N}, j \\frac{L}{N}, k \\frac{L}{N})$，其中 $i,j,k \\in \\{0, ..., N-1\\}$。\n- 傅里叶空间波矢：对应的波矢由 $\\mathbf{k}_{lmn} = (2\\pi \\frac{l}{L}, 2\\pi \\frac{m}{L}, 2\\pi \\frac{n}{L})$ 给出，其中 $l,m,n$ 是由 `numpy.fft.fftfreq` 提供的整数频率。\n\n**c. 超密度计算与算法处理：**\n真实密度场由 $\\rho(\\mathbf{x}) = \\bar{\\rho}(1 + \\delta_{\\text{true}}(\\mathbf{x}))$ 给出。数值求解器可能使用一个估计的平均密度 $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho}(1+\\epsilon)$。于是，求解器计算的超密度场为：\n$$ \\delta_{\\text{case}}(\\mathbf{x}) = \\frac{\\rho(\\mathbf{x}) - \\bar{\\rho}_{\\text{est}}}{\\bar{\\rho}_{\\text{est}}} = \\frac{\\bar{\\rho}(1+\\delta_{\\text{true}}(\\mathbf{x})) - \\bar{\\rho}(1+\\epsilon)}{\\bar{\\rho}(1+\\epsilon)} = \\frac{\\delta_{\\text{true}}(\\mathbf{x}) - \\epsilon}{1+\\epsilon} $$\n进行傅里叶变换，并注意到常数 $C$ 的变换是 $C N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}$（其中 $\\delta_{\\mathbf{k}, \\mathbf{0}}$ 是克罗内克δ函数）：\n$$ \\hat{\\delta}_{\\text{case}}(\\mathbf{k}) = \\frac{\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}}{1+\\epsilon} $$\n问题为源项 $\\hat{S}(\\mathbf{k})$ 定义了两种处理方式：\n1.  **一致性处理**：$\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}_{\\text{est}}$。源项为 $\\hat{S}_{\\text{cons}}(\\mathbf{k}) = \\bar{\\rho}_{\\text{est}} \\hat{\\delta}_{\\text{case}}(\\mathbf{k}) = \\bar{\\rho}(1+\\epsilon) \\frac{\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}}{1+\\epsilon} = \\bar{\\rho}(\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}})$。\n2.  **非一致性处理**：$\\bar{\\rho}_{\\text{used}} = \\bar{\\rho}$。源项为 $\\hat{S}_{\\text{incons}}(\\mathbf{k}) = \\bar{\\rho} \\hat{\\delta}_{\\text{case}}(\\mathbf{k}) = \\bar{\\rho} \\frac{\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) - \\epsilon N^3 \\delta_{\\mathbf{k}, \\mathbf{0}}}{1+\\epsilon}$。\n\n**d. 诊断量分析：**\n基准案例对应于 $\\epsilon=0$，此时 $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho}$ 且处理方式是一致的。在这种情况下，$\\delta_{\\text{case}}=\\delta_{\\text{true}}$ 且 $\\hat{S}_{\\text{baseline}}(\\mathbf{k}) = \\bar{\\rho}\\hat{\\delta}_{\\text{true}}(\\mathbf{k})$。由于 $\\delta_{\\text{true}}$ 是余弦函数的和，其空间平均为零，所以 $\\hat{\\delta}_{\\text{true}}(\\mathbf{0})=0$，因此 $\\hat{S}_{\\text{baseline}}(\\mathbf{0})=0$。\n\n-   **平均势差 $\\Delta \\bar{\\Phi}$**：离散网格上任何场 $\\Phi(\\mathbf{x})$ 的空间平均值为 $\\langle\\Phi\\rangle = \\frac{1}{N^3}\\sum_\\mathbf{x} \\Phi(\\mathbf{x})$。根据离散傅里叶变换的性质，$\\sum_\\mathbf{x} \\Phi(\\mathbf{x}) = \\hat{\\Phi}(\\mathbf{0})$。因此，$\\langle\\Phi\\rangle = \\hat{\\Phi}(\\mathbf{0})/N^3$。由于问题明确要求对所有情况（基准和其他情况）都设置 $\\hat{\\Phi}(\\mathbf{0}) = 0$，所以每种情况下的平均势都将为零。因此，对于所有测试案例，$\\Delta \\bar{\\Phi} \\equiv \\langle \\Phi_{\\text{case}} \\rangle - \\langle \\Phi_{\\text{baseline}} \\rangle = 0 - 0 = 0$。\n\n-   **相对误差 $\\text{err}_{\\Phi}$**：\n    -   **一致性处理**：对于 $\\mathbf{k} \\neq \\mathbf{0}$，$\\hat{S}_{\\text{cons}}(\\mathbf{k}) = \\bar{\\rho}\\hat{\\delta}_{\\text{true}}(\\mathbf{k}) = \\hat{S}_{\\text{baseline}}(\\mathbf{k})$。对于 $\\mathbf{k}=\\mathbf{0}$，$\\hat{S}_{\\text{cons}}(\\mathbf{0}) = -\\bar{\\rho}\\epsilon N^3 \\neq 0$。势 $\\hat{\\Phi}$ 是通过对 $\\mathbf{k} \\neq \\mathbf{0}$ 除以 $-k^2$ 并将 $\\mathbf{k}=\\mathbf{0}$ 分量设为零得到的。由于所有 $\\mathbf{k} \\neq \\mathbf{0}$ 的源项都匹配，并且 $\\hat{\\Phi}_{\\text{cons}}(\\mathbf{0})$ 和 $\\hat{\\Phi}_{\\text{baseline}}(\\mathbf{0})$ 都被设为零，我们有对所有 $\\mathbf{k}$ 都有 $\\hat{\\Phi}_{\\text{cons}}(\\mathbf{k}) = \\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$。因此，$\\Phi_{\\text{cons}}(\\mathbf{x}) = \\Phi_{\\text{baseline}}(\\mathbf{x})$，误差 $\\text{err}_{\\Phi}$ 精确为 $0$。\n    -   **非一致性处理**：对于 $\\mathbf{k} \\neq \\mathbf{0}$，$\\hat{S}_{\\text{incons}}(\\mathbf{k}) = \\frac{\\bar{\\rho}}{1+\\epsilon} \\hat{\\delta}_{\\text{true}}(\\mathbf{k}) = \\frac{1}{1+\\epsilon} \\hat{S}_{\\text{baseline}}(\\mathbf{k})$。这导致对于 $\\mathbf{k} \\neq \\mathbf{0}$，$\\hat{\\Phi}_{\\text{incons}}(\\mathbf{k}) = \\frac{1}{1+\\epsilon} \\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$。由于两个直流分量都为零，我们有对所有 $\\mathbf{k}$ 都有 $\\hat{\\Phi}_{\\text{incons}}(\\mathbf{k}) = \\frac{1}{1+\\epsilon} \\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$。根据逆傅里叶变换的线性性质，$\\Phi_{\\text{incons}}(\\mathbf{x}) = \\frac{1}{1+\\epsilon} \\Phi_{\\text{baseline}}(\\mathbf{x})$。那么误差为：\n        $$ \\text{err}_{\\Phi} = \\frac{\\|\\Phi_{\\text{incons}} - \\Phi_{\\text{baseline}}\\|_2}{\\|\\Phi_{\\text{baseline}}\\|_2} = \\frac{\\|\\left(\\frac{1}{1+\\epsilon} - 1\\right)\\Phi_{\\text{baseline}}\\|_2}{\\|\\Phi_{\\text{baseline}}\\|_2} = \\left|\\frac{-\\epsilon}{1+\\epsilon}\\right| = \\frac{|\\epsilon|}{|1+\\epsilon|} $$\n\n-   **源项零模比 $r_0$**：分母是 $\\max_{\\mathbf{k}\\neq \\mathbf{0}} |\\hat{S}_{\\text{baseline}}(\\mathbf{k})|$。基准源是 $\\bar{\\rho}\\hat{\\delta}_{\\text{true}}(\\mathbf{k})$。场 $\\delta_{\\text{true}}$ 由两个振幅分别为 $A_1=0.2$ 和 $A_2=0.1$ 的余弦模组成。在大小为 $N^3$ 的网格上，$A_i \\cos(\\dots)$ 的离散傅里叶变换具有量级为 $A_i N^3 / 2$ 的峰值。最大量级将来自较大的振幅 $A_1$。因此，$\\max_{\\mathbf{k}\\neq \\mathbf{0}} |\\hat{S}_{\\text{baseline}}(\\mathbf{k})| = \\bar{\\rho} A_1 N^3 / 2$。\n    -   **一致性处理**：分子是 $|\\hat{S}_{\\text{cons}}(\\mathbf{0})| = |-\\bar{\\rho}\\epsilon N^3| = \\bar{\\rho}|\\epsilon|N^3$。比率为 $r_0 = \\frac{\\bar{\\rho}|\\epsilon|N^3}{\\bar{\\rho} A_1 N^3/2} = \\frac{2|\\epsilon|}{A_1}$。\n    -   **非一致性处理**：分子是 $|\\hat{S}_{\\text{incons}}(\\mathbf{0})| = |\\frac{-\\bar{\\rho}\\epsilon N^3}{1+\\epsilon}|$。比率为 $r_0 = \\frac{|\\frac{-\\bar{\\rho}\\epsilon N^3}{1+\\epsilon}|}{\\bar{\\rho} A_1 N^3/2} = \\frac{2|\\epsilon|}{|1+\\epsilon|A_1}$。\n\n### 2. 实现策略\n\n数值实现将按以下步骤进行：\n1.  **设置**：定义物理和网格参数（$L, N, \\bar{\\rho}$ 等），并创建实空间网格坐标 $(x,y,z)$ 和傅里叶空间波矢网格 $(k_x, k_y, k_z)$。计算所有模的波数平方 $k^2 = k_x^2+k_y^2+k_z^2$。\n2.  **真实场**：在实空间网格上构建真实密度场 $\\rho(\\mathbf{x}) = \\bar{\\rho}(1+\\delta_{\\text{true}}(\\mathbf{x}))$。\n3.  **基准计算**：计算基准案例（$\\epsilon=0$，一致性处理）的解。这包括：\n    a. 计算 $\\delta_{\\text{baseline}}(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho})/\\bar{\\rho}$。\n    b. 对其进行快速傅里叶变换得到 $\\hat{\\delta}_{\\text{baseline}}(\\mathbf{k})$。\n    c. 构建源项 $\\hat{S}_{\\text{baseline}}(\\mathbf{k}) = \\bar{\\rho}\\hat{\\delta}_{\\text{baseline}}(\\mathbf{k})$。\n    d. 通过除以 $-k^2$（避免 $k=0$）求解 $\\hat{\\Phi}_{\\text{baseline}}(\\mathbf{k})$，并设置 $\\hat{\\Phi}_{\\text{baseline}}(0,0,0) = 0$。\n    e. 逆变换回实空间得到 $\\Phi_{\\text{baseline}}(\\mathbf{x})$。\n    f. 存储 $\\|\\Phi_{\\text{baseline}}\\|_2$ 和 $\\max_{\\mathbf{k}\\neq 0} |\\hat{S}_{\\text{baseline}}(\\mathbf{k})|$ 以供后续诊断使用。\n4.  **测试案例循环**：遍历五个测试案例。对每个案例：\n    a. 定义 $\\epsilon$ 和一致性标志。\n    b. 计算 $\\bar{\\rho}_{\\text{est}} = \\bar{\\rho}(1+\\epsilon)$。\n    c. 计算 $\\delta_{\\text{case}}(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho}_{\\text{est}})/\\bar{\\rho}_{\\text{est}}$。\n    d. 计算其快速傅里叶变换 $\\hat{\\delta}_{\\text{case}}(\\mathbf{k})$。\n    e. 使用适当的平均密度（一致性处理用 $\\bar{\\rho}_{\\text{est}}$，非一致性处理用 $\\bar{\\rho}$）构建源项 $\\hat{S}_{\\text{case}}(\\mathbf{k})$。\n    f. 使用与基准案例相同的方法求解 $\\hat{\\Phi}_{\\text{case}}(\\mathbf{k})$ 并逆变换得到 $\\Phi_{\\text{case}}(\\mathbf{x})$。\n    g. 使用存储的基准量计算三个诊断量 $\\text{err}_{\\Phi}$、$r_0$ 和 $\\Delta\\bar{\\Phi}$。\n5.  **输出**：将收集到的结果格式化为指定的字符串格式。\n\n这个结构化的过程确保了每一步都正确执行，并且平均密度估计与求解器逻辑之间的相互作用都按照问题陈述被精确地建模。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves Poisson's equation in Fourier space for a synthetic density field\n    and analyzes the effect of mean density estimation errors.\n    \"\"\"\n\n    # 1. Problem Definition\n    # Domain and Grid\n    L = 1.0  # Domain side length\n    N = 32   # Grid points per dimension\n\n    # Physics Parameters (in code units)\n    rho_bar_true = 1.0  # True mean density\n    # 4 * pi * G * a^2 is set to 1\n\n    # Synthetic Overdensity Field Parameters\n    A1 = 0.2\n    A2 = 0.1\n    n1, n2, n3 = 2, 3, 2\n    \n    # Test Suite\n    test_cases = [\n        (0.0, True),      # 1. Baseline\n        (1e-3, True),     # 2. Consistent\n        (1e-3, False),    # 3. Inconsistent\n        (-0.05, False),   # 4. Inconsistent\n        (0.1, False)      # 5. Inconsistent\n    ]\n\n    # 2. Grid and Field Setup\n    # Real-space grid coordinates\n    grid_1d = np.linspace(0.0, L, N, endpoint=False)\n    x, y, z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # True overdensity field\n    delta_true = A1 * np.cos(2 * np.pi * n1 * x / L) + \\\n                 A2 * np.cos(2 * np.pi * (n2 * y / L + n3 * z / L))\n\n    # True density field\n    rho = rho_bar_true * (1.0 + delta_true)\n\n    # Fourier-space wavenumbers\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_1d, k_1d, k_1d, indexing='ij')\n    k_squared = kx**2 + ky**2 + kz**2\n    \n    # We will need to set k=0 element to a non-zero value to avoid division by zero.\n    # The result at this k-vector is set to 0 manually anyway.\n    # A more robust way is to use a `where` clause in the division.\n    k_squared[0, 0, 0] = 1.0 \n    \n    # 3. Poisson Solver Function\n    def poisson_solve(density_field, rho_bar_for_delta, rho_bar_for_source):\n        \"\"\"\n        Solves Poisson's equation for a given density field and mean density choices.\n        \n        Returns:\n            Phi (np.ndarray): Real-space potential.\n            S_hat (np.ndarray): Fourier-space source term.\n        \"\"\"\n        # Compute overdensity delta\n        delta = (density_field - rho_bar_for_delta) / rho_bar_for_delta\n        \n        # FFT of overdensity\n        delta_hat = np.fft.fftn(delta)\n        \n        # Construct Fourier-space source term S_hat\n        S_hat = rho_bar_for_source * delta_hat\n        \n        # Solve for potential in Fourier space\n        Phi_hat = -S_hat / k_squared\n        \n        # Set the k=0 mode (mean potential) to zero\n        Phi_hat[0, 0, 0] = 0.0\n        \n        # Inverse FFT to get potential in real space\n        Phi = np.fft.ifftn(Phi_hat).real\n        \n        return Phi, S_hat\n\n    # 4. Baseline Calculation (Case 1)\n    phi_baseline, s_hat_baseline = poisson_solve(rho, rho_bar_true, rho_bar_true)\n    norm_phi_baseline = np.linalg.norm(phi_baseline)\n    \n    # Find max of |S_hat_baseline(k)| for k != 0\n    s_hat_baseline_mag = np.abs(s_hat_baseline)\n    s_hat_baseline_mag_k0 = s_hat_baseline_mag[0, 0, 0]\n    s_hat_baseline_mag[0, 0, 0] = 0.0 # Temporarily zero out the k=0 mode\n    max_s_baseline_nonzero = np.max(s_hat_baseline_mag)\n    s_hat_baseline_mag[0, 0, 0] = s_hat_baseline_mag_k0 # Restore original value\n    \n    # Handle the case where the baseline field is zero (all modes are zero)\n    if max_s_baseline_nonzero == 0:\n        max_s_baseline_nonzero = 1.0 # Avoid division by zero for r0\n\n    # 5. Loop Through Test Cases and Compute Diagnostics\n    results = []\n    for epsilon, is_consistent in test_cases:\n        rho_bar_est = rho_bar_true * (1.0 + epsilon)\n        \n        if is_consistent:\n            rho_bar_for_delta = rho_bar_est\n            rho_bar_for_source = rho_bar_est\n        else: # Inconsistent\n            rho_bar_for_delta = rho_bar_est\n            rho_bar_for_source = rho_bar_true\n        \n        # Solve for the current test case\n        phi_case, s_hat_case = poisson_solve(rho, rho_bar_for_delta, rho_bar_for_source)\n        \n        # Calculate diagnostics\n        \n        # err_Phi: Relative l2 error in the potential\n        if norm_phi_baseline > 0:\n            err_phi = np.linalg.norm(phi_case - phi_baseline) / norm_phi_baseline\n        else:\n            err_phi = np.linalg.norm(phi_case) # If baseline is zero, use absolute norm\n\n        # r0: Ratio of the k=0 source mode to the max non-zero baseline mode\n        r0 = np.abs(s_hat_case[0, 0, 0]) / max_s_baseline_nonzero\n        \n        # Delta_Phi_bar: Difference in the mean potential\n        delta_phi_bar = np.mean(phi_case) - np.mean(phi_baseline)\n        \n        results.append([err_phi, r0, delta_phi_bar])\n\n    # 6. Format and Print Output\n    # Format: [[r1,r2,r3],[r4,r5,r6],...] with no spaces\n    output_str = \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "3490042"}]}