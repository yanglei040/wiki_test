{"hands_on_practices": [{"introduction": "在数值宇宙学中，首要任务是精确地模拟宇宙各主要能量组分的演化。本练习将指导您建立并求解描述物质、辐射和暗能量密度的基本微分方程组，这是理解宇宙膨胀历史的基石。此过程将引入作为独立变量的 e-fold 数 $N = \\ln a$，并突出一个关键的实际挑战——数值刚性 (numerical stiffness)，通过比较显式和隐式求解器的性能，您将学会如何在从早期宇宙积分至今时应对这一问题 [@problem_id:3470916]。", "problem": "要求您构建一个完整、可运行的程序，在一个空间平坦的弗里德曼-勒梅特-罗伯逊-沃克 (FLRW) 宇宙中，使用 e-折叠变量 $N=\\ln a$ 作为自变量，数值演化非相对论物质、辐射和暗能量的能量密度。目标有两方面：一是使用以 $N$ 为自变量的数值常微分方程求解器来实现演化，二是通过比较一个非刚性求解器和一个刚性求解器，来量化在辐射占主导地位的极小尺度因子 $a\\sim 10^{-8}$ 附近的数值刚性。\n\n基本原理：\n- 对于能量密度为 $\\rho$、压强为 $p$ 的均匀流体，其连续性方程为 $d\\rho/dt + 3H(\\rho + p)=0$，其中 $H$ 是哈勃参数，$t$ 是宇宙时。\n- 定义状态方程参数 $w(a) = p/\\rho$，连续性方程可推导出 $d\\ln \\rho/d\\ln a = -3(1+w(a))$。\n- 选择 $N=\\ln a$ 作为自变量。则 $d\\rho/dN = -3(1+w(a))\\rho$。\n\n模型假设：\n- 三个无相互作用的组分根据各自的状态方程独立演化：物质的 $w_m = 0$，辐射的 $w_r = 1/3$，以及暗能量，其状态方程随时间变化，由 Chevallier–Polarski–Linder (CPL) 参数化描述为 $w(a) = w_0 + w_a (1-a)$，其中 $w_0$ 和 $w_a$ 是常数。\n- 所有密度都归一化到当今的临界密度，因此它们是无量纲的。将 $a=1$ 时的当今值表示为 $\\Omega_{m0}$、$\\Omega_{r0}$ 和 $\\Omega_{DE0}$，其中 $\\Omega_{DE0} = 1 - (\\Omega_{m0} + \\Omega_{r0})$。\n\n在自变量 $N=\\ln a$ 下的演化方程：\n- 物质：$d\\rho_m/dN = -3 \\rho_m$。\n- 辐射：$d\\rho_r/dN = -4 \\rho_r$。\n- 暗能量：$d\\rho_{DE}/dN = -3\\bigl(1 + w(a)\\bigr)\\rho_{DE}$，其中 $w(a)=w_0+w_a(1-a)$ 且 $a = e^N$。\n\n量化刚性：\n- 令 $J(N)$ 为右端项关于状态向量 $(\\rho_m,\\rho_r,\\rho_{DE})$ 的雅可比矩阵。对于这个自治状态线性系统，$J(N)$ 是一个对角矩阵，其特征值为\n$$\n\\lambda_m(N) = -3,\\quad \\lambda_r(N) = -4,\\quad \\lambda_{DE}(N) = -3\\bigl(1 + w(a)\\bigr)\n$$\n- 定义在给定 $N$ 处的瞬时刚性指标为\n$$\nS(N) = \\frac{\\max\\{|\\lambda_m(N)|,|\\lambda_r(N)|,|\\lambda_{DE}(N)|\\}}{\\max\\left(\\min\\{|\\lambda_m(N)|,|\\lambda_r(N)|,|\\lambda_{DE}(N)|\\}, \\varepsilon\\right)},\n$$\n其中 $\\varepsilon$ 是一个小的正数，用于避免在 $|\\lambda_{DE}(N)|$ 为零的情况下（例如当 $w(a)=-1$ 时）出现除以零的错误。使用 $\\varepsilon = 10^{-12}$。\n- 通过比较一个非刚性显式求解器与一个刚性隐式求解器在从 $N=0$ 积分到 $N=\\ln(10^{-8})$ 过程中所使用的右端项求值次数，来定义一个经验数值刚性分数。具体来说，使用相同的容差，分别用 5(4) 阶龙格-库塔方法（“RK45”）和后向差分公式（“BDF”）进行一次积分，并计算\n$$\nR = \\frac{\\text{右端项求值次数 (RK45)}}{\\text{右端项求值次数 (BDF)}}.\n$$\n若 $R1$，则表明刚性求解器用更少的右端项求值次数达到了相同的精度，这在刚性区域是典型情况。\n\n数值设置：\n- 自变量域：$N \\in [\\ln(10^{-8}), 0]$。实现从 $N=0$ 向下积分到 $N=\\ln(10^{-8})$。\n- 在 $N=0$ (即 $a=1$) 时的初始条件：$\\rho_m(0)=\\Omega_{m0}$，$\\rho_r(0)=\\Omega_{r0}$，$\\rho_{DE}(0)=\\Omega_{DE0}$，其中 $\\Omega_{DE0} = 1 - (\\Omega_{m0}+\\Omega_{r0})$。\n- 对两个求解器使用相同的绝对和相对容差：相对容差 $\\mathrm{rtol} = 10^{-10}$，绝对容差 $\\mathrm{atol} = 10^{-12}$。对两个求解器使用相同的右端项及其雅可比矩阵。\n\n每个测试案例需要计算的输出：\n- 令 $N_{\\min}=\\ln(10^{-8})$ 且 $a_{\\min}=10^{-8}$。对于下面的每个参数集，计算：\n  1. 比率 $\\rho_r(N_{\\min})/\\rho_m(N_{\\min})$，作为浮点数。\n  2. 瞬时刚性指标 $S(N_{\\min})$，作为浮点数。\n  3. 经验数值刚性分数 $R$，作为浮点数。\n\n所有三个输出都是无量纲的，并且必须以四舍五入到六位有效数字的浮点数形式报告。\n\n测试套件（四个测试案例）：\n- 案例 1 (基准 Lambda 冷暗物质模型)：$\\Omega_{m0}=0.315$, $\\Omega_{r0}=9.2\\times 10^{-5}$, $w_0=-1.0$, $w_a=0.0$。\n- 案例 2 (暗能量温和演化，现今为魅影能量)：$\\Omega_{m0}=0.30$, $\\Omega_{r0}=9.2\\times 10^{-5}$, $w_0=-0.95$, $w_a=-0.10$。\n- 案例 3 (早期与宇宙学常数有强烈偏离)：$\\Omega_{m0}=0.30$, $\\Omega_{r0}=9.2\\times 10^{-5}$, $w_0=-1.0$, $w_a=0.50$。\n- 案例 4 (边缘案例，现今辐射可忽略)：$\\Omega_{m0}=0.30$, $\\Omega_{r0}=1.0\\times 10^{-10}$, $w_0=-1.0$, $w_a=0.0$。\n\n实现要求：\n- 使用一个标准的数值 ODE 接口，该接口需同时支持显式的 5(4) 阶龙格-库塔方法和使用用户提供的雅可比矩阵的隐式后向差分公式方法。对于每种方法，从 $N=0$ 积分到 $N_{\\min}$，并统计右端项的求值次数以计算 $R$。\n- 使用在 $a=a_{\\min}$ 处的解析特征值和 $\\varepsilon=10^{-12}$ 来计算 $S(N_{\\min})$。\n- 从 $N_{\\min}$ 处的数值解计算 $\\rho_r(N_{\\min})/\\rho_m(N_{\\min})$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表包含四个内部列表（每个测试案例一个），列表之间没有空格，且严格按照测试套件的顺序排列。每个内部列表必须按上述顺序包含三个浮点数，并四舍五入到六位有效数字。例如：\n\"[[x11,x12,x13],[x21,x22,x23],[x31,x32,x33],[x41,x42,x43]]\"", "solution": "所提出的问题是数值宇宙学中一个有效且定义明确的练习，其基础是标准宇宙学模型。它要求对一个描述物质、辐射和暗能量的能量密度演化的常微分方程组（ODE）进行数值积分。该问题在科学上是合理的，所有参数和方程都是该领域的标准。它在计算上是可行的，并且为获得唯一解提供了所有必要信息。\n\n理论框架是空间平坦的弗里德曼-勒梅特-罗伯逊-沃克（FLRW）宇宙模型。一个压强为 $p$ 的理想流体组分，其能量密度 $\\rho$ 的演化由连续性方程 $d\\rho/dt + 3H(\\rho+p) = 0$ 控制。通过引入状态方程参数 $w=p/\\rho$，并将自变量从宇宙时 $t$ 更改为 e-折叠数 $N = \\ln a$（其中 $a$ 是宇宙尺度因子），连续性方程对每个组分都转换为一个一阶常微分方程：\n$$\n\\frac{d\\rho}{dN} = -3(1+w)\\rho\n$$\n宇宙被建模为三种无相互作用组分的混合物：\n1.  **非相对论物质**（冷暗物质和重子），其压强可忽略不计，因此 $w_m = 0$。\n2.  **辐射**（光子和相对论性中微子），其状态方程为 $w_r = 1/3$。\n3.  **暗能量**，一个具有负压强、导致宇宙加速膨胀的组分。其状态方程由 Chevallier–Polarski–Linder (CPL) 参数化描述，$w(a) = w_0 + w_a(1-a)$，其中 $w_0$ 和 $w_a$ 是常数。当 $a=e^N$ 时，其形式为 $w(N) = w_0 + w_a(1-e^N)$。\n\n能量密度 $\\rho_m$、$\\rho_r$ 和 $\\rho_{DE}$ 被归一化到当今（$N=0$，$a=1$）的临界密度，因此它们的初始值是当今的密度参数 $\\Omega_{m0}$、$\\Omega_{r0}$ 和 $\\Omega_{DE0}$。空间平坦的假设施加了约束条件 $\\Omega_{m0} + \\Omega_{r0} + \\Omega_{DE0} = 1$。\n\n这导致了以下关于状态向量 $\\vec{\\rho}(N) = [\\rho_m(N), \\rho_r(N), \\rho_{DE}(N)]^T$ 的耦合一阶常微分方程组：\n$$\n\\frac{d\\rho_m}{dN} = -3(1+w_m)\\rho_m = -3\\rho_m\n$$\n$$\n\\frac{d\\rho_r}{dN} = -3(1+w_r)\\rho_r = -3(1+1/3)\\rho_r = -4\\rho_r\n$$\n$$\n\\frac{d\\rho_{DE}}{dN} = -3(1+w(e^N))\\rho_{DE} = -3\\left(1 + w_0 + w_a(1-e^N)\\right)\\rho_{DE}\n$$\n这些方程需要在域 $N \\in [\\ln(10^{-8}), 0]$ 上进行数值求解，从 $N=0$ 处的初始条件 $\\rho_m(0) = \\Omega_{m0}$，$\\rho_r(0) = \\Omega_{r0}$ 和 $\\rho_{DE}(0) = \\Omega_{DE0}$ 开始向后积分。\n\n该问题的一个关键方面是研究该系统的数值刚性。当一个常微分方程系统中存在两个或更多个差异巨大的自变量尺度，而因变量在这些尺度上发生变化时，就会出现刚性。它由系统右端项函数的雅可比矩阵 $J_{ij} = \\partial f_i / \\partial \\rho_j$ 的特征值来表征。对于给定的系统，雅可比矩阵是对角的：\n$$\nJ(N) = \\begin{pmatrix} -3  0  0 \\\\ 0  -4  0 \\\\ 0  0  -3(1+w(e^N)) \\end{pmatrix}\n$$\n特征值就是对角线上的元素：$\\lambda_m = -3$，$\\lambda_r = -4$ 和 $\\lambda_{DE}(N) = -3(1+w(e^N))$。系统的刚性与这些特征值绝对值的最大值与最小值之比有关。我们用瞬时刚性指标来量化这一点：\n$$\nS(N) = \\frac{\\max\\{|\\lambda_m|, |\\lambda_r|, |\\lambda_{DE}(N)|\\}}{\\max(\\min\\{|\\lambda_m|, |\\lambda_r|, |\\lambda_{DE}(N)|\\}, \\varepsilon)}\n$$\n其中 $\\varepsilon = 10^{-12}$ 用于防止除以零，这对于标准的 $\\Lambda$CDM 模型尤其重要，在该模型中 $w_0=-1$ 且 $w_a=0$，导致对所有 $N$ 都有 $\\lambda_{DE}(N) = 0$。\n\n算法方法对每个测试案例包括以下步骤：\n1.  初始化参数（$\\Omega_{m0}$、$\\Omega_{r0}$、$w_0$、$w_a$）、在 $N=0$ 处 $\\vec{\\rho}$ 的初始条件，以及积分区间 $N \\in [\\ln(10^{-8}), 0]$。\n2.  定义常微分方程组的右端项 (RHS) 函数及其解析雅可比矩阵。\n3.  使用 `scipy.integrate.solve_ivp` 中的两个不同求解器，将系统从 $N=0$ 数值积分到 $N_{\\min} = \\ln(10^{-8})$： a. 一个显式的 5(4) 阶龙格-库塔方法 (`RK45`)，它对非刚性问题效率很高。 b. 一个基于后向差分公式 (`BDF`) 的隐式方法，它专为刚性问题设计，并可以利用提供的雅可比矩阵来提高性能。\n4.  对于两次积分，都使用相同的高精度容差（$\\mathrm{rtol} = 10^{-10}$，$\\mathrm{atol} = 10^{-12}$）以确保解的准确性。\n5.  记录每次求解器运行的右端项求值次数（`nfev`）。\n6.  根据在 $N_{\\min}$ 处的计算解，计算辐射与物质的能量密度之比 $\\rho_r(N_{\\min})/\\rho_m(N_{\\min})$。\n7.  使用在 $a_{\\min}=e^{N_{\\min}}=10^{-8}$ 处特征值的解析公式计算瞬时刚性指标 $S(N_{\\min})$。\n8.  计算经验数值刚性分数 $R$，即 `RK45` 的 `nfev` 与 `BDF` 的 `nfev` 之比。一个大的 $R  1$ 值表明 `BDF` 求解器效率显著更高，从而证实了系统的刚性。\n9.  然后将三个计算出的浮点值四舍五入到六位有效数字作为最终输出。对所有四个提供的测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Numerically evolves energy densities in an FLRW universe and quantifies\n    numerical stiffness for different cosmological models.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (baseline Lambda Cold Dark Matter)\n        (0.315, 9.2e-5, -1.0, 0.0),\n        # Case 2 (mildly evolving dark energy with phantom today)\n        (0.30, 9.2e-5, -0.95, -0.10),\n        # Case 3 (strong early-time deviation from cosmological constant)\n        (0.30, 9.2e-5, -1.0, 0.50),\n        # Case 4 (edge case with negligible radiation today)\n        (0.30, 1.0e-10, -1.0, 0.0),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        Omega_m0, Omega_r0, w0, wa = case\n        Omega_DE0 = 1.0 - (Omega_m0 + Omega_r0)\n\n        # Numerical setup\n        N_min = np.log(1e-8)\n        N_span = [0, N_min]\n        rho0 = np.array([Omega_m0, Omega_r0, Omega_DE0])\n        rtol = 1e-10\n        atol = 1e-12\n\n        def rhs(N, rho, w0_val, wa_val):\n            \"\"\"Right-hand side of the ODE system d(rho)/dN.\"\"\"\n            rho_m, rho_r, rho_de = rho\n            a = np.exp(N)\n            w_de = w0_val + wa_val * (1 - a)\n            \n            drho_m_dN = -3.0 * rho_m\n            drho_r_dN = -4.0 * rho_r\n            drho_de_dN = -3.0 * (1.0 + w_de) * rho_de\n            \n            return np.array([drho_m_dN, drho_r_dN, drho_de_dN])\n\n        def jac(N, rho, w0_val, wa_val):\n            \"\"\"Jacobian of the RHS function.\"\"\"\n            a = np.exp(N)\n            w_de = w0_val + wa_val * (1.0 - a)\n            \n            J = np.zeros((3, 3))\n            J[0, 0] = -3.0\n            J[1, 1] = -4.0\n            J[2, 2] = -3.0 * (1.0 + w_de)\n            return J\n\n        # --- Integration with non-stiff solver (RK45) ---\n        sol_rk45 = solve_ivp(\n            fun=rhs,\n            t_span=N_span,\n            y0=rho0,\n            method='RK45',\n            rtol=rtol,\n            atol=atol,\n            args=(w0, wa)\n        )\n        nfev_rk45 = sol_rk45.nfev\n        rho_final = sol_rk45.y[:, -1]\n\n        # --- Integration with stiff solver (BDF) ---\n        sol_bdf = solve_ivp(\n            fun=rhs,\n            t_span=N_span,\n            y0=rho0,\n            method='BDF',\n            jac=jac,\n            rtol=rtol,\n            atol=atol,\n            args=(w0, wa)\n        )\n        nfev_bdf = sol_bdf.nfev\n\n        # --- Compute the three required outputs ---\n\n        # 1. Ratio rho_r / rho_m at N_min\n        rho_m_final, rho_r_final, _ = rho_final\n        ratio_rho = rho_r_final / rho_m_final if rho_m_final != 0 else np.inf\n\n        # 2. Instantaneous stiffness indicator S(N_min)\n        a_min = 1e-8\n        epsilon = 1e-12\n        w_de_min = w0 + wa * (1.0 - a_min)\n        \n        lambda_m_abs = 3.0\n        lambda_r_abs = 4.0\n        lambda_de_abs = np.abs(-3.0 * (1.0 + w_de_min))\n        \n        abs_lambdas = np.array([lambda_m_abs, lambda_r_abs, lambda_de_abs])\n        max_lambda = np.max(abs_lambdas)\n        min_lambda = np.min(abs_lambdas)\n        \n        stiffness_indicator = max_lambda / max(min_lambda, epsilon)\n\n        # 3. Empirical numerical stiffness score R\n        stiffness_score = nfev_rk45 / nfev_bdf if nfev_bdf != 0 else np.inf\n\n        # Format results to six significant figures\n        def format_six_sf(value):\n            return float(f'{value:.6g}')\n\n        case_results = [\n            format_six_sf(ratio_rho),\n            format_six_sf(stiffness_indicator),\n            format_six_sf(stiffness_score)\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    inner_strings = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```", "id": "3470916"}, {"introduction": "在我们成功地演化了单个能量组分的密度之后，一个常见的任务是将它们组合起来计算可观测量，例如哈勃膨胀率 $H(a)$。这个看似简单的求和操作，在跨越多个数量级的尺度上使用有限精度算法时，实际上充满了数值陷阱，可能导致灾难性的精度损失。本练习将提供诊断和缓解这些浮点数舍入与抵消误差的实践经验，通过对比朴素求和与补偿求和策略，加深您对构建稳健数值模型的理解 [@problem_id:3470934]。", "problem": "您的任务是研究在使用有限精度算术计算宇宙尺度因子的函数——哈勃膨胀率时的数值稳定性，并实现一个稳健的补偿求和策略，以在对数量级差异巨大的项求和时减轻浮点抵消效应。研究对象为一个空间均匀且各向同性的宇宙，其膨胀由包含理想流体组分的弗里德曼方程所描述。无量纲膨胀率定义为 $E(a) \\equiv H(a)/H_{0}$，其中 $a$ 是宇宙学尺度因子（归一化为今天的 $a=1$），$H(a)$ 是哈勃参数，$H_{0}$ 是其当前值。假设以下组分对总能量收支有贡献：密度参数为 $\\Omega_{r}$ 的辐射，密度参数为 $\\Omega_{m}$ 的非相对论物质，密度参数为 $\\Omega_{k}$ 的空间曲率，以及由常数状态方程参数 $w$ 和密度参数 $\\Omega_{\\mathrm{de}}$ 参数化的暗能量。$a=1$ 时的总能量收支满足 $\\Omega_{r} + \\Omega_{m} + \\Omega_{k} + \\Omega_{\\mathrm{de}} = 1$。对于常数 $w$，根据膨胀宇宙中的标准理想流体连续性方程，能量密度随 $a$ 的幂次进行标度变化。\n\n从广义相对论的弗里德曼方程和理想流体连续性方程出发，可以将无量纲膨胀率表示为\n$$\nE(a)^{2} = \\Omega_{r}\\, a^{-4} + \\Omega_{m}\\, a^{-3} + \\Omega_{k}\\, a^{-2} + \\Omega_{\\mathrm{de}}\\, a^{-3(1+w)}.\n$$\n在实际的数值宇宙学计算中，$\\Omega_{k}$ 通常不是直接指定的，而是通过残差闭合计算得出\n$$\n\\Omega_{k} = 1 - \\left(\\Omega_{r} + \\Omega_{m} + \\Omega_{\\mathrm{de}}\\right).\n$$\n在计算极端 $a$ 值下的 $E(a)$ 时，各个项的量级可能相差巨大，有限精度下的朴素浮点求和会遭受严重的舍入和抵消误差。您的任务是在单精度下量化此效应，并实现一种补偿求和策略，在不改变物理模型的前提下减少误差。\n\n您必须实现一个程序，该程序：\n- 以双精度计算高精度参考值 $E_{\\mathrm{ref}}(a)$，通过使用由双精度残差得到的 $\\Omega_{k}$ 来计算上述给出的 $E(a)$，并以双精度按任意合理顺序对各组分求和。\n- 计算一个朴素单精度估计值 $E_{\\mathrm{naive}}(a)$，方法如下：\n  - 将所有输入参数和 $a$ 转换为单精度，由单精度残差计算 $\\Omega_{k}$，以单精度构建四个贡献项，并以固定的从左到右的顺序求和得到单精度的 $E(a)^{2}$，然后取平方根。如果仅因有限精度导致中间的单精度贡献项之和为负，则在取平方根之前将其设为零。\n- 计算一个改进的单精度估计值 $E_{\\mathrm{comp}}(a)$，其与朴素方法的唯一区别在于如何汇总四个贡献项：使用一种补偿求和策略来最小化抵消，例如，通过单次补偿求和（如 Kahan 式补偿）按量级递增的顺序对贡献项求和，所有计算均在单精度下进行，然后取平方根。同上，如果仅因舍入导致补偿和为负，则在取平方根之前将其设为零。\n\n对于下述每个测试用例，评估在从 $a_{\\min}$ 到 $a_{\\max}$（含两端）的对数间隔网格上的 $a$ 值，并报告朴素和补偿单精度方法在整个网格上的最大相对误差，其中给定 $a$ 处的相对误差为\n$$\n\\varepsilon(a) = \\frac{\\left|E_{\\mathrm{method}}(a) - E_{\\mathrm{ref}}(a)\\right|}{E_{\\mathrm{ref}}(a)}.\n$$\n本问题中的所有量都是无量纲的；因此，答案中不需要物理单位。\n\n测试套件规范：\n- 对每个测试用例，使用在 $a \\in \\left[10^{-8}, 10^{4}\\right]$ 范围内的 $N=200$ 个对数间隔点组成的网格。\n- 对每个测试用例，程序必须输出两个浮点数：朴素单精度求和的最大相对误差和补偿单精度求和的最大相对误差，按此顺序排列。\n\n测试用例：\n1. 标准晚期宇宙组分，包含少量辐射和一个宇宙学常数：\n   - $\\Omega_{r} = 8.24\\times 10^{-5}$，$\\Omega_{m} = 0.315$，$\\Omega_{\\mathrm{de}} = 0.6849176$，$w = -1$，$a_{\\min} = 10^{-8}$，$a_{\\max} = 10^{4}$。\n2. 高度倾斜的能量收支，暗能量占主导，物质和辐射极少：\n   - $\\Omega_{r} = 1\\times 10^{-12}$，$\\Omega_{m} = 1\\times 10^{-6}$，$\\Omega_{\\mathrm{de}} = 0.999999$，$w = -1$，$a_{\\min} = 10^{-8}$，$a_{\\max} = 10^{4}$。\n3. $w-1$ 的魅影暗能量，辐射可忽略不计：\n   - $\\Omega_{r} = 1\\times 10^{-10}$，$\\Omega_{m} = 0.05$，$\\Omega_{\\mathrm{de}} = 0.95$，$w = -1.1$，$a_{\\min} = 10^{-8}$，$a_{\\max} = 10^{4}$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，包含六个结果，形式为逗号分隔的列表，并用方括号括起来，顺序如下：\n  - $[\\varepsilon_{\\max}^{\\mathrm{naive}}(\\mathrm{case}\\,1), \\varepsilon_{\\max}^{\\mathrm{comp}}(\\mathrm{case}\\,1), \\varepsilon_{\\max}^{\\mathrm{naive}}(\\mathrm{case}\\,2), \\varepsilon_{\\max}^{\\mathrm{comp}}(\\mathrm{case}\\,2), \\varepsilon_{\\max}^{\\mathrm{naive}}(\\mathrm{case}\\,3), \\varepsilon_{\\max}^{\\mathrm{comp}}(\\mathrm{case}\\,3)]$。\n- 每个条目都必须是浮点数。程序不得打印任何其他文本。", "solution": "用户请求一个数值宇宙学问题的解决方案，该问题涉及哈勃膨胀率的计算，并侧重于减轻浮点误差。\n\n### **问题陈述验证**\n\n**1. 提取已知条件：**\n- **模型**：空间均匀且各向同性的宇宙。\n- **控制方程**：弗里德曼方程。\n- **定义**：无量纲膨胀率 $E(a) \\equiv H(a)/H_{0}$。\n- **组分**：辐射（$\\Omega_{r}$）、物质（$\\Omega_{m}$）、曲率（$\\Omega_{k}$）以及暗能量（$\\Omega_{\\mathrm{de}}$，具有常数状态方程参数 $w$）。\n- **约束条件**：$\\Omega_{r} + \\Omega_{m} + \\Omega_{k} + \\Omega_{\\mathrm{de}} = 1$。\n- **$E(a)^{2}$ 公式**：$E(a)^{2} = \\Omega_{r}\\, a^{-4} + \\Omega_{m}\\, a^{-3} + \\Omega_{k}\\, a^{-2} + \\Omega_{\\mathrm{de}}\\, a^{-3(1+w)}$。\n- **$\\Omega_{k}$ 计算**：$\\Omega_{k} = 1 - \\left(\\Omega_{r} + \\Omega_{m} + \\Omega_{\\mathrm{de}}\\right)$。\n- **数值任务**：\n    1. **$E_{\\mathrm{ref}}(a)$**：以双精度计算。\n    2. **$E_{\\mathrm{naive}}(a)$**：将输入转换为单精度，计算各项，从左到右求和。将负和钳制为 $0$。\n    3. **$E_{\\mathrm{comp}}(a)$**：与朴素法相同，但使用补偿策略（按量级排序，然后进行 Kahan 求和）对各项求和。将负和钳制为 $0$。\n- **误差度量**：最大相对误差 $\\varepsilon_{\\max} = \\max_a \\left|E_{\\mathrm{method}}(a) - E_{\\mathrm{ref}}(a)\\right|/E_{\\mathrm{ref}}(a)$。\n- **网格**：在 $a \\in \\left[10^{-8}, 10^{4}\\right]$ 范围内的 $N=200$ 个对数间隔点。\n- **测试用例**：\n    1. $\\Omega_{r} = 8.24\\times 10^{-5}$, $\\Omega_{m} = 0.315$, $\\Omega_{\\mathrm{de}} = 0.6849176$, $w = -1$。\n    2. $\\Omega_{r} = 1\\times 10^{-12}$, $\\Omega_{m} = 1\\times 10^{-6}$, $\\Omega_{\\mathrm{de}} = 0.999999$, $w = -1$。\n    3. $\\Omega_{r} = 1\\times 10^{-10}$, $\\Omega_{m} = 0.05$, $\\Omega_{\\mathrm{de}} = 0.95$, $w = -1.1$。\n- **输出**：一个包含六个逗号分隔浮点数的单行 `[...]`。\n\n**2. 使用提取的已知条件进行验证：**\n- **科学基础**：该问题基于标准宇宙学模型，特别是弗里德曼方程。辐射（$\\rho_r \\propto a^{-4}$）、物质（$\\rho_m \\propto a^{-3}$）、曲率（$\\rho_k \\propto a^{-2}$）和具有常数 $w$ 的暗能量（$\\rho_{\\mathrm{de}} \\propto a^{-3(1+w)}$）的能量密度标度关系是正确的。所提供的 $E(a)^2$ 方程是这些原理直接且正确的推论。\n- **适定性**：该问题定义明确。输入已指定，计算方法描述清晰，期望输出精确。存在唯一、稳定的数值解。\n- **客观性**：语言精确，无主观性。给定的测试用例参数是现代宇宙学中使用的物理上合理的数值。\n- **完整性与一致性**：该问题提供了所有必要的数据和方程。测试用例适用于平坦宇宙（在精确算术中 $\\Omega_k = 0$），这与当前的宇宙学观测一致。使用残差计算 $\\Omega_k$ 是标准做法，并引入了问题旨在研究的那种浮点计算的微妙之处。\n- **可行性**：所要求的计算是标准的，在指定的环境中是可行的。尺度因子 $a$ 的范围很大，这正是使数值稳定性问题突出且使问题有趣的所在。\n\n**3. 结论与行动：**\n该问题是**有效的**。这是一个将数值分析应用于物理宇宙学基本计算的、适定且科学上合理的练习。任务是量化一种稳健的求和算法相对于朴素方法在处理有限精度算术时的改进效果。我现在将着手解决。\n\n### **基于原理的设计与求解**\n\n该问题要求我们计算无量纲哈勃膨胀率 $E(a)$，它描述了宇宙的膨胀。其演化由各组分的能量密度决定，如弗里德曼方程所示。\n\n**1. 物理模型与控制方程**\n均匀且各向同性宇宙的膨胀历史由弗里德曼方程描述。用无量纲密度参数 $\\Omega_i$（组分 $i$ 在今天的能量密度分数）表示，无量纲膨胀率 $E(a) = H(a)/H_0$ 由下式给出：\n$$\nE(a)^{2} = \\Omega_{r}\\, a^{-4} + \\Omega_{m}\\, a^{-3} + \\Omega_{k}\\, a^{-2} + \\Omega_{\\mathrm{de}}\\, a^{-3(1+w)}\n$$\n其中 $a$ 是尺度因子，下标 $r$、$m$、$k$ 和 $\\mathrm{de}$ 分别指辐射、非相对论物质、空间曲率和暗能量。密度参数定义在 $a=1$ 时，并且必须总和为一，即 $\\Omega_{r} + \\Omega_{m} + \\Omega_{k} + \\Omega_{\\mathrm{de}} = 1$。问题指定 $\\Omega_k$ 由此闭合关系确定。尺度因子 $a$ 上的指数反映了每种组分的能量密度如何因宇宙膨胀而被稀释。\n\n**2. 数值挑战：有效数字损失**\n问题的核心在于 $E(a)^2$ 求和的数值计算。尺度因子 $a$ 横跨十二个数量级，从 $10^{-8}$（早期、炽热、致密的宇宙）到 $10^{4}$（遥远的未来）。这导致求和中的四项具有截然不同的量级。\n\n例如，在早期宇宙（$a \\ll 1$），辐射项 $\\Omega_{r}a^{-4}$ 占主导地位。在 $a=10^{-8}$ 时，此项的量级约为 $\\sim 10^{-5} \\times (10^{-8})^{-4} = 10^{27}$，而暗能量项（对于 $w=-1$）约为 $\\sim 0.7$。当使用有限精度算术，如单精度（`float32`）时，将一个非常小的数加到一个非常大的数上，会导致较小的数被有效丢弃。这种现象被称为“淹没”或“有效数字损失”，会导致精度损失。朴素求和 `A + B + C + D` 极易受此误差影响。\n\n**3. 算法实现策略**\n为了量化和减轻这种误差，我们实现了三种不同的计算方法：\n\n- **参考解 ($E_{\\mathrm{ref}}$)**：这是我们的“基准真相”。所有计算都使用双精度算术（`numpy.float64`）进行，它提供大约 $15-17$ 位的十进制精度。这种高精度最大限度地减少了舍入误差，为比较单精度方法提供了一个可靠的基准。由于可用精度很高，求和顺序并不关键。\n\n- **朴素单精度解 ($E_{\\mathrm{naive}}$)**：在这里，所有参数和中间计算都被转换为单精度（`numpy.float32`），它只有大约 $7$ 位的十进制精度。构成 $E(a)^2$ 的四个项按固定的从左到右的顺序求和。预计该方法会因淹没而遭受显著的精度损失，尤其是在尺度因子范围的极端情况下。按照规定，如果舍入误差导致和为负，则在取平方根之前将其钳制为 $0$，这是为了物理真实性而必需的步骤。\n\n- **补偿单精度解 ($E_{\\mathrm{comp}}$)**：该方法也使用单精度，但采用更复杂的求和策略来减少误差。该策略结合了两种启发式方法：\n    1.  **排序**：首先按绝对值大小的升序对四个项进行排序。从小到大求和是减少舍入误差的一种通用技术，因为它倾向于使运行总和与下一个要相加的项在量级上更接近。\n    2.  **Kahan 求和**：然后将一种单次补偿求和算法，特别是 Kahan 求和算法，应用于排序后的项。该算法维护一个额外的浮点变量，即*补偿值*（`c`），它累积每次加法产生的舍入误差。这个捕获的误差在下一步被重新引入求和中。Kahan 算法对于运行总和 `s` 和新项 `x` 的核心逻辑是：\n        - `y = x - c` （用先前的误差修正该项）\n        - `t = s + y` （将修正后的项加到和上；此处可能发生误差）\n        - `c = (t - s) - y` （计算新的误差）\n        - `s = t` （更新和）\n    这个过程有效地追踪了“丢失”的低位比特，并显著提高了最终和的准确性。如果由于残余舍入误差导致最终和为负，同样在取平方根前将其钳制为 $0$。\n\n最后，针对双精度参考解，计算朴素和补偿方法在 $a$ 值网格上的最大相对误差。这量化了每种单精度策略的性能。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical cosmology problem by computing and comparing Hubble expansion rates.\n\n    This function iterates through a set of predefined cosmological test cases. For each case,\n    it calculates the dimensionless Hubble expansion rate E(a) over a logarithmic grid of\n    scale factors 'a' using three distinct methods:\n    1. A high-precision reference method using double-precision floating-point numbers.\n    2. A naive method using single-precision numbers and a standard left-to-right summation.\n    3. An improved method using single-precision numbers but with a compensated summation\n       (sorting terms by magnitude and applying Kahan's algorithm).\n\n    It then calculates the maximum relative error of the naive and compensated methods against\n    the reference result and stores these errors. Finally, it prints all collected errors\n    in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # (Omega_r, Omega_m, Omega_de, w, a_min, a_max)\n        (8.24e-5, 0.315, 0.6849176, -1.0, 1e-8, 1e4),\n        (1e-12, 1e-6, 0.999999, -1.0, 1e-8, 1e4),\n        (1e-10, 0.05, 0.95, -1.1, 1e-8, 1e4)\n    ]\n    N = 200\n    results = []\n\n    for case in test_cases:\n        Omega_r_in, Omega_m_in, Omega_de_in, w_in, a_min, a_max = case\n        a_grid = np.logspace(np.log10(a_min), np.log10(a_max), N)\n\n        # 1. High-precision reference calculation (double precision)\n        E_ref = np.zeros_like(a_grid, dtype=np.float64)\n        Or, Om, Ode, w = np.float64(Omega_r_in), np.float64(Omega_m_in), np.float64(Omega_de_in), np.float64(w_in)\n        Ok = np.float64(1.0) - (Or + Om + Ode)\n        w_exp = np.float64(-3.0) * (np.float64(1.0) + w)\n        for i, a_val in enumerate(a_grid):\n            a = np.float64(a_val)\n            term_r = Or * np.power(a, -4.0)\n            term_m = Om * np.power(a, -3.0)\n            term_k = Ok * np.power(a, -2.0)\n            term_de = Ode * np.power(a, w_exp)\n            E_sq = term_r + term_m + term_k + term_de\n            E_ref[i] = np.sqrt(E_sq if E_sq > 0 else 0.0)\n\n        # 2. Naive single-precision calculation\n        E_naive = np.zeros_like(a_grid, dtype=np.float32)\n        Or_32, Om_32, Ode_32, w_32 = np.float32(Omega_r_in), np.float32(Omega_m_in), np.float32(Omega_de_in), np.float32(w_in)\n        Ok_32 = np.float32(1.0) - (Or_32 + Om_32 + Ode_32)\n        w_exp_32 = np.float32(-3.0) * (np.float32(1.0) + w_32)\n        for i, a_val in enumerate(a_grid):\n            a_32 = np.float32(a_val)\n            term_r = Or_32 * np.power(a_32, np.float32(-4.0))\n            term_m = Om_32 * np.power(a_32, np.float32(-3.0))\n            term_k = Ok_32 * np.power(a_32, np.float32(-2.0))\n            term_de = Ode_32 * np.power(a_32, w_exp_32)\n            # Naive left-to-right summation\n            E_sq_32 = term_r + term_m + term_k + term_de\n            E_naive[i] = np.sqrt(E_sq_32 if E_sq_32 > 0 else np.float32(0.0))\n\n        # 3. Compensated single-precision calculation\n        E_comp = np.zeros_like(a_grid, dtype=np.float32)\n        for i, a_val in enumerate(a_grid):\n            a_32 = np.float32(a_val)\n            term_r = Or_32 * np.power(a_32, np.float32(-4.0))\n            term_m = Om_32 * np.power(a_32, np.float32(-3.0))\n            term_k = Ok_32 * np.power(a_32, np.float32(-2.0))\n            term_de = Ode_32 * np.power(a_32, w_exp_32)\n            \n            terms = [term_r, term_m, term_k, term_de]\n            \n            # Sort terms by increasing absolute magnitude\n            sorted_terms = sorted(terms, key=abs)\n            \n            # Kahan compensated summation\n            s = np.float32(0.0)\n            c = np.float32(0.0)\n            for x in sorted_terms:\n                y = x - c\n                t = s + y\n                c = (t - s) - y\n                s = t\n            E_sq_32 = s\n            E_comp[i] = np.sqrt(E_sq_32 if E_sq_32 > 0 else np.float32(0.0))\n\n        # Calculate maximum relative errors, avoiding division by zero if E_ref is zero\n        \n        # Naive error\n        err_naive = np.zeros_like(E_ref)\n        # E_ref should not be zero for these cosmological parameters\n        non_zero_mask = E_ref != 0\n        err_naive[non_zero_mask] = np.abs(E_naive[non_zero_mask] - E_ref[non_zero_mask]) / E_ref[non_zero_mask]\n        max_err_naive = np.max(err_naive)\n        \n        # Compensated error\n        err_comp = np.zeros_like(E_ref)\n        err_comp[non_zero_mask] = np.abs(E_comp[non_zero_mask] - E_ref[non_zero_mask]) / E_ref[non_zero_mask]\n        max_err_comp = np.max(err_comp)\n\n        results.extend([max_err_naive, max_err_comp])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3470934"}, {"introduction": "物理定律通常表现为动力学系统必须始终满足的代数约束，例如弗里德曼方程。尽管我们的微分方程源于这些定律，但数值积分过程本身并不能自动保证这些约束在每一步都得到精确保持。这个高级实践将探讨如何监控和强制执行弗里德曼方程这一代数约束，以确保宇宙演化模拟的长期稳定性和物理一致性，这对于任何旨在精确追踪宇宙历史的模拟都至关重要 [@problem_id:3470905]。", "problem": "您需要构建一个完整的数值实验，该实验积分一个包含物质、辐射和暗能量的均匀且各向同性的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙学的背景演化，并在每个积分步骤中定量地检验闭合关系。实验的基础起点必须是以下经过充分检验的事实和定义：\n\n- 具有空间曲率的 FLRW 宇宙学的 Friedmann 方程为\n$$\nH^2(a) \\equiv \\left(\\frac{\\dot{a}}{a}\\right)^2 = \\frac{8\\pi G}{3}\\sum_i \\rho_i(a) - \\frac{k c^2}{a^2},\n$$\n其中 $H(a)$ 是哈勃参数，$a$ 是尺度因子，$G$ 是牛顿常数，$c$ 是光速，$k$ 是空间曲率符号，$\\rho_i(a)$ 是组分 $i$ 的能量密度。\n- 每个非相互作用组分的能量-动量守恒方程为\n$$\n\\frac{d\\rho_i}{dt} + 3 H(a) \\left(1 + w_i(a)\\right)\\rho_i(a) = 0,\n$$\n其中 $w_i(a)$ 是组分 $i$ 的状态方程参数。\n- 在当前宇宙时期 $a = 1$ 时，临界密度为 $\\rho_{\\mathrm{c},0} = 3 H_0^2 / (8\\pi G)$，其中 $H_0 \\equiv H(a=1)$。当今的密度参数为 $\\Omega_{i,0} \\equiv \\rho_{i,0}/\\rho_{\\mathrm{c},0}$ 和 $\\Omega_{k,0} \\equiv -k c^2/(a_0^2 H_0^2)$，其中 $a_0 \\equiv 1$。\n\n您必须使用无量纲自变量 $N \\equiv \\ln a$ 和以下无量纲因变量来重构该系统：\n- $X_i(N) \\equiv \\rho_i(a)/\\rho_{i,0}$，\n- $E^2(N) \\equiv H^2(a)/H_0^2$。\n\n从上述基本定律出发，为辐射、物质、暗能量以及无量纲哈勃率，分别推导出一个关于 $X_r(N)$、$X_m(N)$、$X_{\\mathrm{de}}(N)$ 和 $E^2(N)$ 的关于 $N$ 的封闭常微分方程组。使用瞬时密度参数的定义，\n$$\n\\Omega_i(a) \\equiv \\frac{\\rho_i(a)}{\\rho_{\\mathrm{c}}(a)} = \\frac{\\Omega_{i,0}\\,X_i(N)}{E^2(N)}, \\qquad \\Omega_k(a) \\equiv \\frac{\\Omega_{k,0}\\,e^{-2N}}{E^2(N)},\n$$\n其中 $\\rho_{\\mathrm{c}}(a) \\equiv 3 H^2(a) /(8\\pi G)$，将您的系统写成封闭形式。使用当前宇宙时期 $N=0$ 时的初始条件，\n$$\nX_r(0) = 1,\\quad X_m(0) = 1,\\quad X_{\\mathrm{de}}(0) = 1,\\quad E^2(0) = 1.\n$$\n\n您必须在自变量 $N$ 上，使用一个固定步长、显式的四阶 Runge–Kutta 积分器实现两种积分模式：\n\n- 自由模式（不强制）：使用您推导的微分方程，对 $X_r$、$X_m$、$X_{\\mathrm{de}}$ 和 $E^2$ 的完整耦合系统进行积分。每步之后，保持积分器得到的 $E^2$ 不变。\n\n- 强制闭合模式：使用相同的积分器和步长，仅积分 $X_i$ 系统，并在完成 $N_{n+1}$ 处的每一步后，将哈勃变量投影到由 Friedmann 和式构建的代数定义上，\n$$\nE^2_{\\mathrm{alg}}(N) \\equiv \\Omega_{r,0} X_r(N) + \\Omega_{m,0} X_m(N) + \\Omega_{\\mathrm{de},0} X_{\\mathrm{de}}(N) + \\Omega_{k,0} e^{-2N},\n$$\n通过精确设置 $E^2(N_{n+1}) \\leftarrow E^2_{\\mathrm{alg}}(N_{n+1})$。这将在每个数值步骤中强制执行闭合关系 $\\sum_i \\Omega_i(a) + \\Omega_k(a) = 1$。\n\n对于两种模式，您都必须评估步进闭合残差，\n$$\n\\mathcal{C}(N) \\equiv \\left[\\sum_i \\Omega_i(a) + \\Omega_k(a)\\right] - 1,\n$$\n使用积分器所携带的瞬时 $E^2(N)$ 来归一化 $\\Omega$。报告在积分域上的最大绝对偏差，\n$$\n\\mathcal{C}_{\\max} \\equiv \\max_{N \\in [N_{\\min},0]} |\\mathcal{C}(N)|.\n$$\n\n您的程序必须实现以下暗能量的状态方程模型：\n- 宇宙学常数：$w_{\\mathrm{de}}(a) = -1$。\n- Chevallier–Polarski–Linder (CPL)：$w_{\\mathrm{de}}(a) = w_0 + w_a (1 - a)$。\n\n使用以下参数集测试套件，使用 $N = \\ln a$ 从 $a = 1$ 积分到 $a_{\\min}$，固定步数为 $n_{\\mathrm{steps}}$，步长为 $h \\equiv \\left(\\ln a_{\\min} - 0\\right)/n_{\\mathrm{steps}}$（注意 $h  0$）：\n\n- 案例 1（平直 $\\Lambda$ 冷暗物质）：$\\Omega_{m,0} = 0.3$，$\\Omega_{r,0} = 9\\times 10^{-5}$，$\\Omega_{k,0} = 0.0$，$\\Omega_{\\mathrm{de},0} = 1 - \\Omega_{m,0} - \\Omega_{r,0} - \\Omega_{k,0}$，$w_{\\mathrm{de}}(a) = -1$，$a_{\\min} = 10^{-4}$，$n_{\\mathrm{steps}} = 40$。\n\n- 案例 2（微曲 $\\Lambda$ 冷暗物质）：$\\Omega_{m,0} = 0.3$，$\\Omega_{r,0} = 9\\times 10^{-5}$，$\\Omega_{k,0} = 0.02$，$\\Omega_{\\mathrm{de},0} = 1 - \\Omega_{m,0} - \\Omega_{r,0} - \\Omega_{k,0}$，$w_{\\mathrm{de}}(a) = -1$，$a_{\\min} = 10^{-4}$，$n_{\\mathrm{steps}} = 40$。\n\n- 案例 3（平直 CPL）：$\\Omega_{m,0} = 0.3$，$\\Omega_{r,0} = 9\\times 10^{-5}$，$\\Omega_{k,0} = 0.0$，$\\Omega_{\\mathrm{de},0} = 1 - \\Omega_{m,0} - \\Omega_{r,0} - \\Omega_{k,0}$，$w_{\\mathrm{de}}(a) = w_0 + w_a (1 - a)$，其中 $w_0 = -0.9$，$w_a = -0.3$，$a_{\\min} = 10^{-4}$，$n_{\\mathrm{steps}} = 40$。\n\n- 案例 4（弯曲 CPL，更深入辐射时期）：$\\Omega_{m,0} = 0.3$，$\\Omega_{r,0} = 9\\times 10^{-5}$，$\\Omega_{k,0} = 0.02$，$\\Omega_{\\mathrm{de},0} = 1 - \\Omega_{m,0} - \\Omega_{r,0} - \\Omega_{k,0}$，$w_{\\mathrm{de}}(a) = w_0 + w_a (1 - a)$，其中 $w_0 = -0.9$，$w_a = -0.3$，$a_{\\min} = 10^{-6}$，$n_{\\mathrm{steps}} = 60$。\n\n对于每个案例，计算并返回两个浮点诊断值：\n- 自由模式下的最大绝对闭合残差 $\\mathcal{C}_{\\max}$。\n- 强制闭合模式下的最大绝对闭合残差 $\\mathcal{C}_{\\max}$。\n\n此任务中的所有量均为无量纲；不应报告任何物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，排序如下\n$$\n[\\mathcal{C}_{\\max}^{(1,\\mathrm{free})}, \\mathcal{C}_{\\max}^{(1,\\mathrm{enf})}, \\mathcal{C}_{\\max}^{(2,\\mathrm{free})}, \\mathcal{C}_{\\max}^{(2,\\mathrm{enf})}, \\mathcal{C}_{\\max}^{(3,\\mathrm{free})}, \\mathcal{C}_{\\max}^{(3,\\mathrm{enf})}, \\mathcal{C}_{\\max}^{(4,\\mathrm{free})}, \\mathcal{C}_{\\max}^{(4,\\mathrm{enf})}],\n$$\n其中上标表示案例索引和模式（“free”或“enf”）。输出必须严格按照指定的顺序和格式包含这 $8$ 个浮点值。", "solution": "用户希望我构建一个完整的数值实验，该实验积分一个包含物质、辐射和暗能量的均匀且各向同性的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙学的背景演化，并在每个积分步骤中定量地检验闭合关系。实验的基础起点必须是以下经过充分检验的事实和定义：\n\n- 具有空间曲率的 FLRW 宇宙学的 Friedmann 方程为\n$$\nH^2(a) \\equiv \\left(\\frac{\\dot{a}}{a}\\right)^2 = \\frac{8\\pi G}{3}\\sum_i \\rho_i(a) - \\frac{k c^2}{a^2},\n$$\n其中 $H(a)$ 是哈勃参数，$a$ 是尺度因子，$G$ 是牛顿常数，$c$ 是光速，$k$ 是空间曲率符号，$\\rho_i(a)$ 是组分 $i$ 的能量密度。\n- 每个非相互作用组分的能量-动量守恒方程为\n$$\n\\frac{d\\rho_i}{dt} + 3 H(a) \\left(1 + w_i(a)\\right)\\rho_i(a) = 0,\n$$\n其中 $w_i(a)$ 是组分 $i$ 的状态方程参数。\n- 在当前宇宙时期 $a = 1$ 时，临界密度为 $\\rho_{\\mathrm{c},0} = 3 H_0^2 / (8\\pi G)$，其中 $H_0 \\equiv H(a=1)$。当今的密度参数为 $\\Omega_{i,0} \\equiv \\rho_{i,0}/\\rho_{\\mathrm{c},0}$ 和 $\\Omega_{k,0} \\equiv -k c^2/(a_0^2 H_0^2)$，其中 $a_0 \\equiv 1$。\n\n您必须使用无量纲自变量 $N \\equiv \\ln a$ 和以下无量纲因变量来重构该系统：\n- $X_i(N) \\equiv \\rho_i(a)/\\rho_{i,0}$，\n- $E^2(N) \\equiv H^2(a)/H_0^2$。\n\n从上述基本定律出发，为辐射、物质、暗能量以及无量纲哈勃参数，分别推导出一个关于 $X_r(N)$、$X_m(N)$、$X_{\\mathrm{de}}(N)$ 和 $E^2(N)$ 的关于 $N$ 的封闭常微分方程组。使用瞬时密度参数的定义，\n$$\n\\Omega_i(a) \\equiv \\frac{\\rho_i(a)}{\\rho_{\\mathrm{c}}(a)} = \\frac{\\Omega_{i,0}\\,X_i(N)}{E^2(N)}, \\qquad \\Omega_k(a) \\equiv \\frac{\\Omega_{k,0}\\,e^{-2N}}{E^2(N)},\n$$\n其中 $\\rho_{\\mathrm{c}}(a) \\equiv 3 H^2(a) /(8\\pi G)$，将您的系统写成封闭形式。使用当前宇宙时期 $N=0$ 时的初始条件，\n$$\nX_r(0) = 1,\\quad X_m(0) = 1,\\quad X_{\\mathrm{de}}(0) = 1,\\quad E^2(0) = 1.\n$$\n\n您必须在自变量 $N$ 上，使用一个固定步长、显式的四阶 Runge–Kutta 积分器实现两种积分模式：\n\n- 自由模式（不强制）：使用您推导的微分方程，对 $X_r$、$X_m$、$X_{\\mathrm{de}}$ 和 $E^2$ 的完整耦合系统进行积分。每步之后，保持积分器得到的 $E^2$ 不变。\n\n- 强制闭合模式：使用相同的积分器和步长，仅积分 $X_i$ 系统，并在完成 $N_{n+1}$ 处的每一步后，将哈勃变量投影到由 Friedmann 和式构建的代数定义上，\n$$\nE^2_{\\mathrm{alg}}(N) \\equiv \\Omega_{r,0} X_r(N) + \\Omega_{m,0} X_m(N) + \\Omega_{\\mathrm{de},0} X_{\\mathrm{de}}(N) + \\Omega_{k,0} e^{-2N},\n$$\n通过精确设置 $E^2(N_{n+1}) \\leftarrow E^2_{\\mathrm{alg}}(N_{n+1})$。这将在每个数值步骤中强制执行闭合关系 $\\sum_i \\Omega_i(a) + \\Omega_k(a) = 1$。\n\n对于两种模式，您都必须评估步进闭合残差，\n$$\n\\mathcal{C}(N) \\equiv \\left[\\sum_i \\Omega_i(a) + \\Omega_k(a)\\right] - 1,\n$$\n使用积分器所携带的瞬时 $E^2(N)$ 来归一化 $\\Omega$。报告在积分域上的最大绝对偏差，\n$$\n\\mathcal{C}_{\\max} \\equiv \\max_{N \\in [N_{\\min},0]} |\\mathcal{C}(N)|.\n$$\n\n您的程序必须实现以下暗能量的状态方程模型：\n- 宇宙学常数：$w_{\\mathrm{de}}(a) = -1$。\n- Chevallier–Polarski–Linder (CPL)：$w_{\\mathrm{de}}(a) = w_0 + w_a (1 - a)$。\n\n使用以下参数集测试套件，使用 $N = \\ln a$ 从 $a = 1$ 积分到 $a_{\\min}$，固定步数为 $n_{\\mathrm{steps}}$，步长为 $h \\equiv \\left(\\ln a_{\\min} - 0\\right)/n_{\\mathrm{steps}}$（注意 $h  0$）：\n\n- 案例 1（平直 $\\Lambda$ 冷暗物质）：$\\Omega_{m,0} = 0.3$，$\\Omega_{r,0} = 9\\times 10^{-5}$，$\\Omega_{k,0} = 0.0$，$\\Omega_{\\mathrm{de},0} = 1 - \\Omega_{m,0} - \\Omega_{r,0} - \\Omega_{k,0}$，$w_{\\mathrm{de}}(a) = -1$，$a_{\\min} = 10^{-4}$，$n_{\\mathrm{steps}} = 40$。\n\n- 案例 2（微曲 $\\Lambda$ 冷暗物质）：$\\Omega_{m,0} = 0.3$，$\\Omega_{r,0} = 9\\times 10^{-5}$，$\\Omega_{k,0} = 0.02$，$\\Omega_{\\mathrm{de},0} = 1 - \\Omega_{m,0} - \\Omega_{r,0} - \\Omega_{k,0}$，$w_{\\mathrm{de}}(a) = -1$，$a_{\\min} = 10^{-4}$，$n_{\\mathrm{steps}} = 40$。\n\n- 案例 3（平直 CPL）：$\\Omega_{m,0} = 0.3$，$\\Omega_{r,0} = 9\\times 10^{-5}$，$\\Omega_{k,0} = 0.0$，$\\Omega_{\\mathrm{de},0} = 1 - \\Omega_{m,0} - \\Omega_{r,0} - \\Omega_{k,0}$，$w_{\\mathrm{de}}(a) = w_0 + w_a (1 - a)$，其中 $w_0 = -0.9$，$w_a = -0.3$，$a_{\\min} = 10^{-4}$，$n_{\\mathrm{steps}} = 40$。\n\n- 案例 4（弯曲 CPL，更深入辐射时期）：$\\Omega_{m,0} = 0.3$，$\\Omega_{r,0} = 9\\times 10^{-5}$，$\\Omega_{k,0} = 0.02$，$\\Omega_{\\mathrm{de},0} = 1 - \\Omega_{m,0} - \\Omega_{r,0} - \\Omega_{k,0}$，$w_{\\mathrm{de}}(a) = w_0 + w_a (1 - a)$，其中 $w_0 = -0.9$，$w_a = -0.3$，$a_{\\min} = 10^{-6}$，$n_{\\mathrm{steps}} = 60$。\n\n对于每个案例，计算并返回两个浮点诊断值：\n- 自由模式下的最大绝对闭合残差 $\\mathcal{C}_{\\max}$。\n- 强制闭合模式下的最大绝对闭合残差 $\\mathcal{C}_{\\max}$。\n\n此任务中的所有量均为无量纲；不应报告任何物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，排序如下\n$$\n[\\mathcal{C}_{\\max}^{(1,\\mathrm{free})}, \\mathcal{C}_{\\max}^{(1,\\mathrm{enf})}, \\mathcal{C}_{\\max}^{(2,\\mathrm{free})}, \\mathcal{C}_{\\max}^{(2,\\mathrm{enf})}, \\mathcal{C}_{\\max}^{(3,\\mathrm{free})}, \\mathcal{C}_{\\max}^{(3,\\mathrm{enf})}, \\mathcal{C}_{\\max}^{(4,\\mathrm{free})}, \\mathcal{C}_{\\max}^{(4,\\mathrm{enf})}],\n$$\n其中上标表示案例索引和模式（“free”或“enf”）。输出必须严格按照指定的顺序和格式包含这 $8$ 个浮点值。\n\n### 步骤 1：问题陈述的验证\n对问题陈述的科学有效性、自洽性和适定性进行严格审查。\n\n#### 提取的已知条件\n- **基本方程**:\n  1. Friedmann 方程： $H^2(a) = \\frac{8\\pi G}{3}\\sum_i \\rho_i(a) - \\frac{k c^2}{a^2}$\n  2. 守恒方程： $\\frac{d\\rho_i}{dt} + 3 H(a) (1 + w_i(a))\\rho_i(a) = 0$\n- **定义**:\n  1. 自变量： $N \\equiv \\ln a$\n  2. 因变量： $X_i(N) \\equiv \\rho_i(a)/\\rho_{i,0}$, $E^2(N) \\equiv H^2(a)/H_0^2$\n  3. 密度参数： $\\rho_{\\mathrm{c},0} = 3 H_0^2 / (8\\pi G)$, $\\Omega_{i,0} \\equiv \\rho_{i,0}/\\rho_{\\mathrm{c},0}$, $\\Omega_{k,0} \\equiv -k c^2/(a_0^2 H_0^2)$ 其中 $a_0 \\equiv 1$\n  4. 瞬时密度参数： $\\Omega_i(a) = \\frac{\\Omega_{i,0}\\,X_i(N)}{E^2(N)}$, $\\Omega_k(a) = \\frac{\\Omega_{k,0}\\,e^{-2N}}{E^2(N)}$\n- **初始条件 (在 $N=0$ 时)**: $X_r(0) = 1$, $X_m(0) = 1$, $X_{\\mathrm{de}}(0) = 1$, $E^2(0) = 1$。\n- **数值方法**: 四阶 Runge-Kutta (RK4)，固定步长 $h = (\\ln a_{\\min})/n_{\\mathrm{steps}}$。\n- **积分模式**: “自由模式”（全系统积分）和“强制闭合模式”（$X_i$ 积分并对 $E^2$ 进行代数投影）。\n- **诊断指标**: 闭合残差 $\\mathcal{C}(N) \\equiv [\\sum_i \\Omega_i(a) + \\Omega_k(a)] - 1$ 及其最大绝对值 $\\mathcal{C}_{\\max}$。\n- **组分模型**: 辐射 ($w_r = 1/3$)、物质 ($w_m = 0$)、暗能量 ($w_{\\mathrm{de}}=-1$ 或 CPL $w_{\\mathrm{de}}(a) = w_0 + w_a(1-a)$)。\n- **测试案例**: 四组特定的宇宙学参数、积分范围和步数。\n- **输出**: 一个单行列表，包含 8 个浮点数值，代表每种情况和模式下的 $\\mathcal{C}_{\\max}$。\n\n#### 使用提取的已知条件进行验证\n1.  **科学依据**：该问题基于标准的 $\\Lambda$CDM 宇宙学模型及其扩展，由成熟的 Friedmann 方程描述。所有定义和原理都是现代宇宙学的基础。该问题具有科学合理性。\n2.  **适定性**：该任务可转化为求解具有指定初始条件的一阶常微分方程组 (ODE)。这构成了一个适定的初值问题。数值要求具体且可实现。\n3.  **客观性**：所有参数都是定量的，目标由数学表达式定义，没有主观解释的余地。\n4.  **完整且一致**：所有必要的参数、方程和初始条件都已提供。定义内部一致。初始条件 $\\sum\\Omega_{i,0}+\\Omega_{k,0}=1$ 通过 $\\Omega_{\\mathrm{de},0}$ 的定义得到明确保证，确保 Friedmann 方程在 $N=0$ 时成立。使用负步长 $h$ 的指令对应于从 $N=0$ 向后积分到 $N_{\\min}$（时间回溯），这是一种标准做法。\n5.  **非平凡性**：该问题需要推导正确的 ODE 系统，正确实现 RK4 积分器，并管理两种不同的积分方案。 “自由”模式和“强制”模式之间的比较突出了保持动力学系统第一积分（代数约束）这一重要的数值概念。\n\n#### 结论与行动\n问题陈述是有效的、适定的、有科学依据的且内部一致的。我将继续进行推导和求解。\n\n### 步骤 2：常微分方程组的推导\n必须用自变量 $N = \\ln a$ 来构建常微分方程组。导数算子变换如下 $\\frac{d}{dt} = \\frac{da}{dt} \\frac{d}{da} = \\dot{a} \\frac{d}{da} = a H \\frac{d}{da}$。由于 $dN = da/a$，我们有 $a \\frac{d}{da} = \\frac{d}{dN}$。\n\n**无量纲密度 $X_i(N)$ 的常微分方程**：\n组分 $i$ 的守恒方程为 $\\frac{d\\rho_i}{dt} + 3H(1+w_i)\\rho_i = 0$。\n使用时间导数变换：$H \\frac{d\\rho_i}{dN} + 3H(1+w_i)\\rho_i = 0$。\n对于 $H \\neq 0$，这简化为 $\\frac{d\\rho_i}{dN} = -3(1+w_i)\\rho_i$。\n代入无量纲变量 $X_i = \\rho_i/\\rho_{i,0}$：$\\rho_{i,0}\\frac{dX_i}{dN} = -3(1+w_i)\\rho_{i,0}X_i$。\n这得到了 $X_i(N)$ 的通用常微分方程：\n$$\n\\frac{dX_i}{dN} = -3(1+w_i(N))X_i(N).\n$$\n将其应用于辐射（$w_r = 1/3$）、物质（$w_m = 0$）和暗能量（$w_{\\mathrm{de}}(N)$）：\n1.  **辐射**：$\\frac{dX_r}{dN} = -3(1+1/3)X_r = -4X_r$。\n2.  **物质**：$\\frac{dX_m}{dN} = -3(1+0)X_m = -3X_m$。\n3.  **暗能量**：$\\frac{dX_{\\mathrm{de}}}{dN} = -3(1+w_{\\mathrm{de}}(N))X_{\\mathrm{de}}$。对于 CPL 模型，$w_{\\mathrm{de}}(N) = w_0 + w_a(1-e^N)$。对于宇宙学常数，$w_{\\mathrm{de}}=-1$，所以 $\\frac{dX_{\\mathrm{de}}}{dN} = 0$。\n\n**无量纲哈勃参数 $E^2(N)$ 的常微分方程**：\nFriedmann 方程可以使用给定的定义写成无量纲形式：\n$$\n\\frac{H^2}{H_0^2} = \\frac{8\\pi G}{3 H_0^2} \\sum_i \\rho_i - \\frac{k c^2}{a^2 H_0^2}\n$$\n$$\nE^2 = \\sum_i \\frac{\\rho_i}{\\rho_{c,0}} + \\Omega_{k,0} e^{-2N} = \\sum_i \\frac{\\Omega_{i,0} \\rho_{c,0} X_i}{\\rho_{c,0}} + \\Omega_{k,0} e^{-2N}\n$$\n这给出了系统的代数约束（第一积分）：\n$$\nE^2(N) = \\sum_i \\Omega_{i,0} X_i(N) + \\Omega_{k,0} e^{-2N}.\n$$\n对该表达式关于 $N$ 求导，得到 $E^2$ 的常微分方程：\n$$\n\\frac{dE^2}{dN} = \\sum_i \\Omega_{i,0} \\frac{dX_i}{dN} - 2\\Omega_{k,0} e^{-2N}.\n$$\n代入 $X_i$ 的常微分方程：\n$$\n\\frac{dE^2}{dN} = \\sum_i \\Omega_{i,0} [-3(1+w_i)X_i] - 2\\Omega_{k,0} e^{-2N}\n$$\n$$\n\\frac{dE^2}{dN} = -3\\sum_i (1+w_i)\\Omega_{i,0}X_i - 2\\Omega_{k,0} e^{-2N}.\n$$\n这是 $E^2$ 所需的常微分方程。从解析上讲，将 $X_i$ 常微分方程的任何解代入 $E^2$ 的代数表达式，也将满足这个 $E^2$ 的微分方程。“自由模式”积分测试了数值方法在这种一致性保持上的表现。\n\n### 步骤 3：算法设计\n实现一个标准的四阶 Runge-Kutta 积分器。积分从 $N=0$ 的初始条件开始，使用负步长 $h$ 向后积分到 $N_{\\min} = \\ln(a_{\\min})$。\n\n**状态向量**：系统的状态由一个 NumPy 数组 $Y = [X_r, X_m, X_{\\mathrm{de}}, E^2]$ 表示。\n\n**自由模式**：\n1.  初始化 $Y(0)=[1,1,1,1]$ 和 $N=0$。\n2.  为 ODE 系统 $\\frac{dY}{dN} = F(N, Y)$ 定义一个函数，该函数计算如上推导的四个导数。\n3.  循环 $n_{\\mathrm{steps}}$ 次：\n    a. 计算并存储闭合残差 $\\mathcal{C}(N) = (\\sum_i \\Omega_{i,0} X_i + \\Omega_{k,0} e^{-2N}) / E^2 - 1$。\n    b. 使用一个 RK4 步骤将状态向量从 $Y_n$ 更新到 $Y_{n+1}$：$Y_{n+1} = \\text{RK4}(F, N_n, Y_n, h)$。\n    c. 更新 $N \\leftarrow N+h$。\n4.  在 $N_{\\min}$ 处计算并存储最终残差。\n5.  结果是轨迹上的 $\\mathcal{C}_{\\max} = \\max(|\\mathcal{C}(N)|)$。\n\n**强制闭合模式**：\n1.  初始化 $Y(0)=[1,1,1,1]$ 和 $N=0$。\n2.  为简化的 ODE 系统 $\\frac{dY_X}{dN} = F_X(N, Y_X)$ 定义一个函数，其中 $Y_X = [X_r, X_m, X_{\\mathrm{de}}]$。该函数仅计算前三个导数。\n3.  循环 $n_{\\mathrm{steps}}$ 次：\n    a. 计算并存储闭合残差 $\\mathcal{C}(N)$。根据构造，在每一步开始时，该值将为 0（或机器精度）。\n    b. 仅演化密度分量：$Y_{X, n+1} = \\text{RK4}(F_X, N_n, Y_{X,n}, h)$。\n    c. 更新 $N \\leftarrow N+h$。\n    d. 更新状态向量：$Y_{1:3, n+1} \\leftarrow Y_{X,n+1}$。\n    e. 投影哈勃参数：$E^2_{n+1} \\leftarrow \\sum_i \\Omega_{i,0} X_{i,n+1} + \\Omega_{k,0} e^{-2N_{n+1}}$。\n4.  计算并存储最终残差。\n5.  结果是 $\\mathcal{C}_{\\max} = \\max(|\\mathcal{C}(N)|)$。由于强制执行步骤，该值预计在数值上与零无法区分。\n\n该实现允许直接比较两种方法的数值稳定性和约束保持能力。自由模式下的非零残差量化了积分器未能保持第一积分（Friedmann 约束）的程度，而强制模式则展示了缓解此问题的标准技术。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FLRW background evolution problem for the given test cases.\n    \"\"\"\n\n    def rk4_step(f, t, y, h, params):\n        \"\"\"A single step of the fourth-order Runge-Kutta method.\"\"\"\n        k1 = h * f(t, y, params)\n        k2 = h * f(t + 0.5 * h, y + 0.5 * k1, params)\n        k3 = h * f(t + 0.5 * h, y + 0.5 * k2, params)\n        k4 = h * f(t + h, y + k3, params)\n        return y + (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n\n    def get_w_de_func(p):\n        \"\"\"Returns the dark energy equation of state function w_de(N).\"\"\"\n        if p['w_model'] == 'lambda':\n            return lambda N: -1.0\n        elif p['w_model'] == 'cpl':\n            w0, wa = p['w_de_params']\n            return lambda N: w0 + wa * (1.0 - np.exp(N))\n        else:\n            raise ValueError(\"Unknown w_de model\")\n\n    def F_free(N, Y, p):\n        \"\"\"ODE system for the free mode (4 variables).\"\"\"\n        Xr, Xm, Xde, _ = Y\n        w_de = p['w_de_func'](N)\n        \n        dX_r_dN = -4.0 * Xr\n        dX_m_dN = -3.0 * Xm\n        dX_de_dN = -3.0 * (1.0 + w_de) * Xde\n        \n        dE2_dN = (-4.0 * p['Or0'] * Xr -\n                  3.0 * p['Om0'] * Xm -\n                  3.0 * (1.0 + w_de) * p['Ode0'] * Xde -\n                  2.0 * p['Ok0'] * np.exp(-2.0 * N))\n                  \n        return np.array([dX_r_dN, dX_m_dN, dX_de_dN, dE2_dN])\n\n    def F_enforced(N, Y_X, p):\n        \"\"\"ODE system for the enforced mode (3 variables).\"\"\"\n        Xr, Xm, Xde = Y_X\n        w_de = p['w_de_func'](N)\n        \n        dX_r_dN = -4.0 * Xr\n        dX_m_dN = -3.0 * Xm\n        dX_de_dN = -3.0 * (1.0 + w_de) * Xde\n        \n        return np.array([dX_r_dN, dX_m_dN, dX_de_dN])\n\n    def algebraic_E2(N, Y_X, p):\n        \"\"\"Calculates E^2 from the algebraic Friedmann constraint.\"\"\"\n        Xr, Xm, Xde = Y_X\n        return (p['Or0'] * Xr +\n                p['Om0'] * Xm +\n                p['Ode0'] * Xde +\n                p['Ok0'] * np.exp(-2.0 * N))\n\n    def closure_residual(N, Y, p):\n        \"\"\"Calculates the closure residual C(N).\"\"\"\n        _, _, _, E2 = Y\n        Y_X = Y[:3]\n        E2_alg = algebraic_E2(N, Y_X, p)\n        if E2 == 0:\n            return np.inf\n        return E2_alg / E2 - 1.0\n\n    def run_simulation(params):\n        \"\"\"Runs the simulation for a single parameter case.\"\"\"\n        params['w_de_func'] = get_w_de_func(params)\n        N_min = np.log(params['a_min'])\n        h = N_min / params['n_steps']\n\n        # Free Mode\n        N_free = 0.0\n        Y_free = np.array([1.0, 1.0, 1.0, 1.0])\n        residuals_free = [closure_residual(N_free, Y_free, params)]\n        \n        for _ in range(params['n_steps']):\n            Y_free = rk4_step(F_free, N_free, Y_free, h, params)\n            N_free += h\n            residuals_free.append(closure_residual(N_free, Y_free, params))\n        C_max_free = np.max(np.abs(residuals_free))\n\n        # Enforced-closure Mode\n        N_enf = 0.0\n        Y_enf = np.array([1.0, 1.0, 1.0, 1.0])\n        residuals_enf = [closure_residual(N_enf, Y_enf, params)]\n\n        for _ in range(params['n_steps']):\n            Y_X_current = Y_enf[:3]\n            Y_X_next = rk4_step(F_enforced, N_enf, Y_X_current, h, params)\n            N_enf += h\n            Y_enf[:3] = Y_X_next\n            Y_enf[3] = algebraic_E2(N_enf, Y_enf[:3], params)\n            residuals_enf.append(closure_residual(N_enf, Y_enf, params))\n        C_max_enf = np.max(np.abs(residuals_enf)) if residuals_enf else 0.0\n\n        return C_max_free, C_max_enf\n\n    test_cases = [\n        {\n            'Om0': 0.3, 'Or0': 9e-5, 'Ok0': 0.0,\n            'w_model': 'lambda', 'w_de_params': None,\n            'a_min': 1e-4, 'n_steps': 40\n        },\n        {\n            'Om0': 0.3, 'Or0': 9e-5, 'Ok0': 0.02,\n            'w_model': 'lambda', 'w_de_params': None,\n            'a_min': 1e-4, 'n_steps': 40\n        },\n        {\n            'Om0': 0.3, 'Or0': 9e-5, 'Ok0': 0.0,\n            'w_model': 'cpl', 'w_de_params': (-0.9, -0.3),\n            'a_min': 1e-4, 'n_steps': 40\n        },\n        {\n            'Om0': 0.3, 'Or0': 9e-5, 'Ok0': 0.02,\n            'w_model': 'cpl', 'w_de_params': (-0.9, -0.3),\n            'a_min': 1e-6, 'n_steps': 60\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        case['Ode0'] = 1.0 - case['Om0'] - case['Or0'] - case['Ok0']\n        c_free, c_enf = run_simulation(case)\n        all_results.extend([c_free, c_enf])\n    \n    # Format output as specified\n    print(f\"[{','.join(f'{r:.10e}' for r in all_results)}]\")\n\nsolve()\n```", "id": "3470905"}]}