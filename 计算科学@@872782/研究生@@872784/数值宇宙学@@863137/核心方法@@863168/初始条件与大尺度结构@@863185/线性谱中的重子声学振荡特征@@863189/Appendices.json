{"hands_on_practices": [{"introduction": "在深入研究完整的BAO能谱之前，理解其背后的基本物理是至关重要的。本练习将引导你分离出其中最重要的一个效应：重子在光子-重子流体中扮演的“惯性质量”角色。通过一个简化的解析计算，我们将精确地推导出重子负载如何减慢声波的传播速度，并由此引起一个可计算的相位延迟[@problem_id:3465623]。", "problem": "考虑在重子拖拽时期之前，紧耦合光子-重子流体中一个共动波数为 $k$ 的傅里叶模式。在紧耦合极限下，忽略各向异性应力、光子扩散（丝阻尼）以及引力势的任何时间变化，组合的光子-重子流体遵循一个声波方程，其有效声速 $c_{s}$ 取决于重子负载参数 $R$，其中 $R \\equiv 3 \\rho_{b}/(4 \\rho_{\\gamma})$，$\\rho_{b}$ 和 $\\rho_{\\gamma}$ 分别表示重子和光子的能量密度。在光速 $c=1$ 的单位制中，声速满足 $c_{s}^{2} = 1/\\big(3(1+R)\\big)$。\n\n假设以下科学上真实的情景：\n- 对于共形时间 $\\eta  \\eta_{1}$，重子负载可以忽略不计，因此 $R \\approx 0$ 且 $c_{s} = 1/\\sqrt{3}$。\n- 对于共形时间 $\\eta \\in [\\eta_{1}, \\eta_{d}]$，重子负载 $R$ 可被视为一个非零常数 ($R>0$)，因此在此区间内 $c_{s} = 1/\\sqrt{3(1+R)}$。\n- 该模式的声学相位可以很好地由 Wentzel–Kramers–Brillouin (WKB) 形式描述，其相位累积由瞬时频率 $k c_{s}$ 对共形时间的积分给出。\n\n将声学相位 $\\varphi(k,\\eta)$ 定义为振荡解的相位，并考虑区间末端 $\\eta=\\eta_{d}$ 处的相位。令 $\\Delta \\varphi(k)$ 表示在有重子负载的模型中累积的声学相位与在同一区间 $[\\eta_{1}, \\eta_{d}]$ 上计算的无重子参考模型中累积的声学相位之间的差值：\n$$\\Delta \\varphi(k) \\equiv \\big[\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1})\\big] - \\big[\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1})\\big].$$\n\n从紧耦合声学动力学和上面给出的 $c_{s}$ 的定义出发，在所述假设下，推导 $\\Delta \\varphi(k)$ 的闭式解析表达式。将您的最终答案以弧度为单位，表示为 $k$、$R$ 和共形时间间隔 $\\Delta \\eta \\equiv \\eta_{d} - \\eta_{1}$ 的函数。最终答案必须是单个解析表达式，而不是不等式或需要求解的方程。", "solution": "该问题陈述在所述假设下具有科学依据、提法恰当且内部一致。它呈现了重子声学振荡研究中的一个标准（尽管经过简化）的情景。所有必需的定义和条件都已提供，从而可以直接且无歧义地进行推导。因此，该问题是有效的。\n\n核心任务是计算共动波数为 $k$ 的傅里叶模式的相位差 $\\Delta \\varphi(k)$。问题将 $\\Delta \\varphi(k)$ 定义为在共形时间区间 $[\\eta_{1}, \\eta_{d}]$ 内，有重子负载的宇宙和无重子的宇宙中累积的声学相位之差：\n$$\n\\Delta \\varphi(k) \\equiv \\big[\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1})\\big] - \\big[\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1})\\big]\n$$\n\n根据指定的 Wentzel–Kramers–Brillouin (WKB) 近似，声学相位 $\\varphi(k, \\eta)$ 随着共形时间累积，其值为瞬时频率 $k c_{s}(\\eta)$ 的积分。因此，在区间 $[\\eta_{1}, \\eta_{d}]$ 上累积的相位由以下积分给出：\n$$\n\\varphi(k, \\eta_{d}) - \\varphi(k, \\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k c_{s}(\\eta') \\, d\\eta'\n$$\n\n我们必须针对所述的两种情景计算这个积分：一种是有重子负载 ($R>0$) 的情景，另一种是无重子负载 ($R=0$) 的参考情景。\n\n首先，考虑有重子负载的情况 ($R>0$)。问题陈述，对于 $\\eta \\in [\\eta_{1}, \\eta_{d}]$，重子负载参数 $R$ 是一个非零常数。因此，有效声速 $c_{s}$ 在此区间内也是一个常数，由下式给出：\n$$\nc_{s, R>0} = \\frac{1}{\\sqrt{3(1+R)}}\n$$\n在这种情况下累积的相位，也就是 $\\Delta \\varphi(k)$ 定义中的第一项，是：\n$$\n\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k \\, c_{s, R>0} \\, d\\eta'\n$$\n由于 $k$ 和 $c_{s, R>0}$ 相对于积分变量 $\\eta'$ 是常数，我们可以将它们提到积分号外面：\n$$\n\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1}) = k \\, c_{s, R>0} \\int_{\\eta_{1}}^{\\eta_{d}} d\\eta' = k \\frac{1}{\\sqrt{3(1+R)}} (\\eta_{d} - \\eta_{1})\n$$\n使用定义 $\\Delta \\eta \\equiv \\eta_{d} - \\eta_{1}$，上式变为：\n$$\n\\varphi_{R>0}(k,\\eta_{d}) - \\varphi_{R>0}(k,\\eta_{1}) = \\frac{k \\Delta \\eta}{\\sqrt{3(1+R)}}\n$$\n\n接下来，我们考虑无重子的参考情况 ($R=0$)。这对应于纯光子流体。通过在通用公式中设置 $R=0$ 可以求得声速：\n$$\nc_{s, R=0} = \\frac{1}{\\sqrt{3(1+0)}} = \\frac{1}{\\sqrt{3}}\n$$\n这个声速也是常数。在这种参考情况下累积的相位，也就是 $\\Delta \\varphi(k)$ 定义中的第二项，是：\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = \\int_{\\eta_{1}}^{\\eta_{d}} k \\, c_{s, R=0} \\, d\\eta'\n$$\n类似地，我们将常数提到积分号外面：\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = k \\, c_{s, R=0} \\int_{\\eta_{1}}^{\\eta_{d}} d\\eta' = k \\frac{1}{\\sqrt{3}} (\\eta_{d} - \\eta_{1})\n$$\n用 $\\Delta \\eta$ 表示，即为：\n$$\n\\varphi_{R=0}(k,\\eta_{d}) - \\varphi_{R=0}(k,\\eta_{1}) = \\frac{k \\Delta \\eta}{\\sqrt{3}}\n$$\n\n最后，我们将这两个结果代入 $\\Delta \\varphi(k)$ 的定义表达式中：\n$$\n\\Delta \\varphi(k) = \\left( \\frac{k \\Delta \\eta}{\\sqrt{3(1+R)}} \\right) - \\left( \\frac{k \\Delta \\eta}{\\sqrt{3}} \\right)\n$$\n我们可以提取公因子 $k$、$\\Delta \\eta$ 和 $1/\\sqrt{3}$，得到最终的闭式表达式：\n$$\n\\Delta \\varphi(k) = \\frac{k \\Delta \\eta}{\\sqrt{3}} \\left( \\frac{1}{\\sqrt{1+R}} - 1 \\right)\n$$\n该表达式代表相移，正如预期的那样，它是一个负值，因为重子负载降低了声速，从而延迟了声波的相位累积。它是 $k$、$R$ 和 $\\Delta \\eta$ 的函数，符合要求。", "answer": "$$\n\\boxed{\\frac{k \\Delta \\eta}{\\sqrt{3}} \\left( \\frac{1}{\\sqrt{1+R}} - 1 \\right)}\n$$", "id": "3465623"}, {"introduction": "线性理论能谱是一个理论构造。在现实中，我们观测的是像星系这样的结构，它们描绘了一个经过非线性演化、呈现非高斯分布的密度场。这最后一个练习将模拟这一过程，从理论BAO能谱出发生成一个高斯随机场，然后对其应用一个简单的非线性（对数正态）变换。通过测量变换前后两点相关函数中的BAO峰位，我们可以检验这迈向真实主义的第一步是否会对我们的“标准尺”造成系统性偏差[@problem_id:3465676]。", "problem": "要求您设计并实现一个完整的、可复现的数值实验，以研究对具有线性理论重子声学振荡（BAO）结构的高斯随机场应用纯局域非高斯映射，是否会对此后从两点相关函数中测得的BAO尺度产生偏差。[@problem_id:42] 这项工作必须以纯数学术语进行阐述，并以一个可运行的程序来表达。该程序需输出一个单行列表，汇总来自指定测试套件的结果。所有距离都必须以 $h^{-1}\\,\\mathrm{Mpc}$ 为共动单位，所有波数都以 $h\\,\\mathrm{Mpc}^{-1}$ 为单位。最终的数值答案必须是以 $h^{-1}\\,\\mathrm{Mpc}$ 为单位的浮点数，并四舍五入到三位小数。\n\n您的程序必须实现以下基于核心定义和经过充分检验的公式的处理流程：\n\n- 一个在边长为 $L$ 的立方周期性体积中、在大小为 $N$ 的规则笛卡尔网格上采样的统计均匀且各向同性的高斯随机场 $\\delta_{\\mathrm{G}}(\\mathbf{x})$，完全由其功率谱 $P(k)$ 所指定，其中 $k \\equiv \\lvert \\mathbf{k} \\rvert$。该场的两点相关函数 $\\xi(r)$ 是 $P(k)$ 的三维傅里叶变换，其中 $r \\equiv \\lvert \\mathbf{r} \\rvert$。对于周期性网格上的一个平稳场，其自相关的离散估计量可以通过卷积定理构建：如果 $\\tilde{\\delta}(\\mathbf{k})$ 是网格上 $\\delta(\\mathbf{x})$ 的离散傅里叶变换，且 $\\mathcal{F}^{-1}$ 表示归一化因子为 $1/N^{3}$ 的离散傅里叶逆变换，那么在减去场的平均值后，网格上的位形空间自相关由 $\\xi_{\\mathrm{grid}}(\\mathbf{r}) = \\mathcal{F}^{-1}\\left[\\lvert \\tilde{\\delta}(\\mathbf{k}) \\rvert^{2}\\right] / N^{3}$ 给出。各向同性的 $\\xi(r)$ 是通过在半径为 $r$ 的球壳中对 $\\xi_{\\mathrm{grid}}(\\mathbf{r})$ 进行分箱求得的。\n\n- 对数正态映射通过对高斯场 $\\delta_{\\mathrm{G}}(\\mathbf{x})$ 的纯局域变换来定义一个非高斯场 $\\delta_{\\mathrm{LN}}(\\mathbf{x})$：$\\delta_{\\mathrm{LN}}(\\mathbf{x}) = \\exp\\left(\\delta_{\\mathrm{G}}(\\mathbf{x}) - \\sigma_{\\mathrm{G}}^{2}/2\\right) - 1$，其中 $\\sigma_{\\mathrm{G}}^{2}$ 是 $\\delta_{\\mathrm{G}}$ 在网格上的方差。对于严格的高斯输入，此选择可确保 $\\langle \\delta_{\\mathrm{LN}} \\rangle = 0$。在 $\\delta_{\\mathrm{G}}$ 为高斯场的假设下，对数正态场的两点函数与高斯场的两点函数关系为 $\\xi_{\\mathrm{LN}}(r) = \\exp\\left(\\xi_{\\mathrm{G}}(r)\\right) - 1$，当 $\\lvert \\xi_{\\mathrm{G}}(r) \\rvert \\ll 1$ 时，此关系可简化为 $\\xi_{\\mathrm{LN}}(r) \\approx \\xi_{\\mathrm{G}}(r)$。这表明，在弱非线性区域，BAO峰值位置应大致被该映射所保持，但这需要直接的数值检验。\n\n- 为在线性功率谱中印上BAO特征，构建一个具有物理动机的各向同性模型，该模型由一个光滑无摆动基线乘以一个阻尼振荡调制项组成。令\n$$\nP(k) = P_{\\mathrm{nw}}(k) \\left[ 1 + \\alpha \\, \\exp\\left( - (k \\,\\Sigma)^{2} \\right) \\frac{\\sin(k\\,r_{\\mathrm{s}})}{k\\,r_{\\mathrm{s}}} \\right],\n$$\n其中\n$$\nP_{\\mathrm{nw}}(k) = A \\left( \\frac{k}{k_{0}} \\right)^{n_{\\mathrm{s}}} \\exp\\left( - \\left(\\frac{k}{k_{c}}\\right)^{2} \\right).\n$$\n此处，$P_{\\mathrm{nw}}(k)$ 捕捉了一个谱倾斜和一个用于数值稳定的大 $k$ 高斯截断，而调制项则编码了特征尺度为 $r_{\\mathrm{s}}$ 的BAO振荡。带有宽度参数 $\\Sigma$ 的阻尼因子模拟了声学特征在傅里叶空间中的扩散。对周期性网格上的 $k$ 使用连续极限约定：$k_{i} = 2\\pi m_{i} / L$，其中 $(m_{x}, m_{y}, m_{z})$ 为整数三元组。通过连续性将 $x=0$ 处的 $\\sin(x)/x$ 定义为 $1$，以避免除以零。\n\n- 通过在傅里叶空间中用目标功率谱的平方根对单位方差白噪声进行“着色”来生成 $\\delta_{\\mathrm{G}}$：如果 $w(\\mathbf{x})$ 是一个满足 $\\langle w(\\mathbf{x}) \\rangle = 0$ 和 $\\langle w(\\mathbf{x})^{2} \\rangle = 1$ 的实数白噪声场，则令 $\\delta_{\\mathrm{G}}(\\mathbf{x}) = \\mathcal{F}^{-1}\\left[\\sqrt{P(k)} \\, \\tilde{w}(\\mathbf{k})\\right]$，其中 $\\tilde{w}(\\mathbf{k})$ 是 $w(\\mathbf{x})$ 的离散傅里叶变换。生成后，将 $\\delta_{\\mathrm{G}}$ 重新缩放到一个指定的目标标准差 $\\sigma_{\\mathrm{target}}$，以控制下游的非高斯性强度，即 $\\delta_{\\mathrm{G}} \\leftarrow \\delta_{\\mathrm{G}} \\cdot \\sigma_{\\mathrm{target}} / \\hat{\\sigma}$，其中 $\\hat{\\sigma}$ 是该实现的经验标准差。\n\n- 分别从 $\\delta_{\\mathrm{G}}$ 和 $\\delta_{\\mathrm{LN}}$ 测量各向同性两点相关函数 $\\xi_{\\mathrm{G}}(r)$ 和 $\\xi_{\\mathrm{LN}}(r)$，方法是如上所述使用基于FFT的卷积，然后在周期性盒子内进行球壳平均。将BAO尺度 $r_{\\mathrm{BAO}}$ 定位为在预期声学尺度周围的搜索窗口内 $\\xi(r)$ 的全局最大值位置。为减少实现噪声，可选择在寻峰前对分箱后的 $\\xi(r)$ 轮廓应用温和的、球对称的一维平滑。当最大值所在的箱及其两个邻近箱可用时，通过二次插值来精化峰值位置。\n\n- 对每个测试用例，报告BAO位移 $\\Delta r \\equiv r_{\\mathrm{BAO}}^{(\\mathrm{mapped})} - r_{\\mathrm{BAO}}^{(\\mathrm{Gaussian})}$，单位为 $h^{-1}\\,\\mathrm{Mpc}$，以四舍五入到三位小数的浮点数形式表示。\n\n为强制实现科学真实性和可复现性而设定的规格和约束：\n\n- 使用边长为 $L = 1000\\,h^{-1}\\,\\mathrm{Mpc}$ 的立方周期性盒子，在每边 $N = 128$ 个点的网格上采样。使用等于网格间距 $\\Delta r = L/N$ 的单个固定各向同性箱宽来计算径向 $\\xi(r)$，直至 $r_{\\max} = L/2$。\n\n- 使用 $k_{0} = 0.2\\,h\\,\\mathrm{Mpc}^{-1}$，$n_{\\mathrm{s}} = 0.96$，$k_{c} = 0.45\\,h\\,\\mathrm{Mpc}^{-1}$，$\\alpha = 0.05$，$\\Sigma = 8\\,h^{-1}\\,\\mathrm{Mpc}$，以及 $r_{\\mathrm{s}} = 105\\,h^{-1}\\,\\mathrm{Mpc}$。设置 $A = 1$（总振幅后续会由 $\\sigma_{\\mathrm{target}}$ 重新缩放）。将 $x=0$ 处的 $\\sin(x)/x$ 按其极限值 $1$ 处理。\n\n- 将BAO寻峰范围限制在窗口 $r \\in [70, 140]\\,h^{-1}\\,\\mathrm{Mpc}$ 内。如果检测到的峰值落在边界箱内，仍使用可用的邻近箱报告精化后的估计值；如果二次精化是病态的（分母为零），则报告箱中心的位置。\n\n- 每个测试用例使用固定的伪随机数生成器种子以确保可复现性。\n\n- 单位：距离 $r$ 和 $L$ 必须以 $h^{-1}\\,\\mathrm{Mpc}$ 为单位处理，波数 $k$ 以 $h\\,\\mathrm{Mpc}^{-1}$ 为单位处理。您的输出必须以 $h^{-1}\\,\\mathrm{Mpc}$ 为单位，并四舍五入到三位小数。\n\n需要实现和评估的测试套件，涵盖理想路径、增强的非高斯性、小方差边缘情况，以及一个恒等映射对照组：\n\n- 案例 $\\#1$：映射类型“identity”（即无非高斯变换），$\\sigma_{\\mathrm{target}} = 0.20$，种子 $= 1$。\n\n- 案例 $\\#2$：映射类型“lognormal”，$\\sigma_{\\mathrm{target}} = 0.20$，种子 $= 2$。\n\n- 案例 $\\#3$：映射类型“lognormal”，$\\sigma_{\\mathrm{target}} = 0.40$，种子 $= 3$。\n\n- 案例 $\\#4$：映射类型“lognormal”，$\\sigma_{\\mathrm{target}} = 0.05$，种子 $= 4$。\n\n对于每个案例，为“Gaussian”基准生成相同的高斯场实现，并通过将指定的映射类型应用于该实现来构建“mapped”场。然后计算BAO峰值位置 $r_{\\mathrm{BAO}}^{(\\mathrm{Gaussian})}$ 和 $r_{\\mathrm{BAO}}^{(\\mathrm{mapped})}$，并报告该案例的位移 $\\Delta r$。\n\n最终输出格式要求：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为测试案例 $\\#1$ 到 $\\#4$，例如 $\\left[ x_{1}, x_{2}, x_{3}, x_{4} \\right]$，其中每个 $x_{i}$ 是以 $h^{-1}\\,\\mathrm{Mpc}$ 为单位且四舍五入到三位小数的 $\\Delta r$ 浮点数值。不应打印任何其他文本。", "solution": "用户提供了一个在数值宇宙学领域中定义明确的问题，该问题要求实现一个数值实验，以测量局域非高斯变换对重子声学振荡（BAO）尺度的潜在偏差效应。该问题具有科学依据、提法恰当且客观。它指定了所有必要的物理参数、数值设置和程序步骤以确保可复现性。因此，我将提供一个完整的解答。\n\n问题的核心是生成一个具有特定功率谱的高斯随机场的实现，对其应用一个变换，然后测量原始场和变换后场的两点相关函数中的BAO峰值位置。这些峰值位置的差异 $\\Delta r$ 就是我们关心的量。\n\n算法流程将按以下方式实现：\n\n1.  **网格与参数初始化**：我们首先定义物理和数值常数。模拟在一个边长为 $L = 1000\\,h^{-1}\\,\\mathrm{Mpc}$ 的周期性立方盒子中进行，该盒子被离散化为一个大小为 $N \\times N \\times N$（其中 $N=128$）的笛卡尔网格。这定义了网格间距，同时也是我们的相关函数箱宽，即 $\\Delta x = L/N \\approx 7.8125\\,h^{-1}\\,\\mathrm{Mpc}$。我们还定义了模型功率谱的参数：参考波数 $k_0 = 0.2\\,h\\,\\mathrm{Mpc}^{-1}$、谱倾斜 $n_{\\mathrm{s}} = 0.96$、大k截断尺度 $k_c = 0.45\\,h\\,\\mathrm{Mpc}^{-1}$、BAO振幅 $\\alpha = 0.05$、BAO阻尼尺度 $\\Sigma = 8\\,h^{-1}\\,\\mathrm{Mpc}$ 以及基本声学尺度 $r_{\\mathrm{s}} = 105\\,h^{-1}\\,\\mathrm{Mpc}$。\n\n2.  **傅里叶空间网格构建**：为了处理傅里叶变换，我们构建波数网格 $\\mathbf{k} = (k_x, k_y, k_z)$。对于边长为 $L$ 的周期性盒子，离散波数由 $k_i = 2\\pi m_i / L$ 给出，其中 $m_i$ 是整数。`numpy.fft.fftfreq` 函数提供了可用于FFT例程的、正确的已排序频率集合。我们生成 $k_x$、$k_y$ 和 $k_z$ 的3D网格，并由此计算出波数大小 $k = \\sqrt{k_x^2 + k_y^2 + k_z^2}$ 的网格。\n\n3.  **理论功率谱**：建立 $k$ 网格后，我们可以在傅里叶空间中的每个点上计算理论线性功率谱 $P(k)$。该模型由以下公式给出：\n    $$\n    P(k) = A \\left( \\frac{k}{k_{0}} \\right)^{n_{\\mathrm{s}}} \\exp\\left( - \\left(\\frac{k}{k_{c}}\\right)^{2} \\right) \\left[ 1 + \\alpha \\, \\exp\\left( - (k \\,\\Sigma)^{2} \\right) \\frac{\\sin(k\\,r_{\\mathrm{s}})}{k\\,r_{\\mathrm{s}}} \\right]\n    $$\n    振幅 $A$ 设置为 $1$，因为场将在稍后被重新缩放。$\\sin(x)/x$ 项在 $x=0$ 处通过其极限值 $1$ 来处理，以避免在 $k=0$ 模式处发生除零错误。`numpy.sinc` 是对此进行数值稳定计算的理想选择。\n\n4.  **高斯随机场生成**：生成一个统计上均匀且各向同性的高斯随机场 $\\delta_{\\mathrm{G}}(\\mathbf{x})$。该过程遵循问题描述：\n    a. 通过为每个网格单元从标准正态分布中抽取一个随机数，创建一个实空间白噪声场 $w(\\mathbf{x})$。每个测试用例使用固定的种子以确保可复现性。\n    b. 对此白噪声场进行傅里叶变换，得到 $\\tilde{w}(\\mathbf{k}) = \\mathcal{F}[w(\\mathbf{x})]$。\n    c. 然后通过将傅里叶空间中的场乘以功率谱的平方根来进行“着色”：$\\tilde{\\delta}_{\\mathrm{G}}(\\mathbf{k}) = \\tilde{w}(\\mathbf{k}) \\sqrt{P(k)}$。由于 $(k/k_0)^{n_s}$ 项的存在，$P(k)$ 的 $k=0$ 模式为零，这确保了最终生成的场均值为零。\n    d. 进行傅里叶逆变换，得到位形空间中的高斯场：$\\delta_{\\mathrm{G}}(\\mathbf{x}) = \\mathcal{F}^{-1}[\\tilde{\\delta}_{\\mathrm{G}}(\\mathbf{k})]$。结果是傅里叶逆变换复数输出的实部。\n    e. 最后，根据测试用例的规定，将场重新缩放至具有特定的目标标准差 $\\sigma_{\\mathrm{target}}$。这是通过计算生成场的经验标准差 $\\hat{\\sigma}$ 并将场乘以比率 $\\sigma_{\\mathrm{target}}/\\hat{\\sigma}$ 来完成的。\n\n5.  **非高斯映射**：从高斯场 $\\delta_{\\mathrm{G}}$ 生成“映射”后的场。\n    - 对于“lognormal”映射，我们应用变换：$\\delta_{\\mathrm{LN}}(\\mathbf{x}) = \\exp\\left(\\delta_{\\mathrm{G}}(\\mathbf{x}) - \\sigma_{\\mathrm{G}}^{2}/2\\right) - 1$，其中 $\\sigma_{\\mathrm{G}}^2 = \\sigma_{\\mathrm{target}}^2$ 是输入高斯场的方差。\n    - 对于“identity”映射（一个对照组），映射后的场只是高斯场的一个副本：$\\delta_{\\text{mapped}}(\\mathbf{x}) = \\delta_{\\mathrm{G}}(\\mathbf{x})$。\n\n6.  **两点相关函数估计**：我们为高斯场和映射后的场计算各向同性两点相关函数 $\\xi(r)$。\n    a. 首先，减去场的均值以确保 $\\langle\\delta\\rangle=0$。这对对数正态场至关重要，因为其样本均值可能不完全为零。\n    b. 使用FFT通过卷积定理高效地计算网格上的相关函数 $\\xi_{\\mathrm{grid}}(\\mathbf{r})$。离散估计量为 $\\xi_{\\mathrm{grid}} = \\mathcal{F}^{-1}[|\\mathcal{F}[\\delta]|^2]$。此处需要仔细的归一化。根据离散傅里叶变换的性质（特别是帕塞瓦尔定理）以及 $\\xi(0)$ 必须等于场方差的定义，使用标准FFT库的正确数值实现是 `real(ifftn(|fftn(field)|^2)) / (N**3)`。问题陈述中的表达式似乎有轻微的歧义，但此实现方式在物理上和统计上都是合理的。\n    c. 为获得各向同性相关函数 $\\xi(r)$，我们在半径为 $r$ 的球壳中对 $\\xi_{\\mathrm{grid}}(\\mathbf{r})$ 进行平均。我们预先计算一个包含周期性边界条件的、从原点出发的距离网格。然后，我们使用基于直方图的方法，根据相应的径向距离对 $\\xi_{\\mathrm{grid}}$ 的值进行分箱。箱宽设置为网格间距 $\\Delta x = L/N$。\n\n7.  **BAO峰值定位**：最后一步是找到BAO峰，即 $\\xi(r)$ 在搜索窗口 $r \\in [70, 140]\\,h^{-1}\\,\\mathrm{Mpc}$ 内的最大值。\n    a. 为减轻单次实现所带来的噪声，使用一个宽度较小（`sigma=1`个箱宽）的一维高斯滤波器对分箱后的 $\\xi(r)$ 轮廓进行平滑处理。这与问题中建议的可选步骤一致。\n    b. 确定搜索窗口内包含平滑后 $\\xi(r)$ 最大值的箱。\n    c. 为了达到子箱精度，使用最大值及其两个直接邻居进行二次插值。拟合抛物线的顶点位置 $r_{\\text{peak}} = r_i - \\frac{(y_{i+1}-y_{i-1})\\Delta x}{2(y_{i+1}+y_{i-1}-2y_i)}$ 给出了精化后的峰值位置。如果分母为零（共线点），则使用箱中心。\n\n8.  **执行与报告**：对四个测试用例中的每一个执行整个流程。对于每个案例，我们计算高斯场（$r_{\\mathrm{BAO}}^{(\\mathrm{Gaussian})}$）和映射场（$r_{\\mathrm{BAO}}^{(\\mathrm{mapped})}$）的峰值位置。最终报告的量是位移 $\\Delta r = r_{\\mathrm{BAO}}^{(\\mathrm{mapped})} - r_{\\mathrm{BAO}}^{(\\mathrm{Gaussian})}$，四舍五入到三位小数。所有案例的结果被汇总到一个列表中并单行打印。对于恒等映射，$\\Delta r$ 预计应精确为零，这可作为对数值流程的可靠验证。", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter1d\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment and print the results.\n    \"\"\"\n\n    # --- Problem Specifications ---\n    L = 1000.0  # Box side length in h^-1 Mpc\n    N = 128     # Grid size per dimension\n    \n    # Power spectrum parameters\n    k0 = 0.2    # h Mpc^-1\n    ns = 0.96\n    kc = 0.45   # h Mpc^-1\n    alpha = 0.05\n    Sigma = 8.0 # h^-1 Mpc\n    rs = 105.0  # h^-1 Mpc\n    A = 1.0\n\n    # Peak finding parameters\n    r_search_min = 70.0  # h^-1 Mpc\n    r_search_max = 140.0 # h^-1 Mpc\n    \n    # Test suite\n    test_cases = [\n        {\"type\": \"identity\", \"sigma_target\": 0.20, \"seed\": 1},\n        {\"type\": \"lognormal\", \"sigma_target\": 0.20, \"seed\": 2},\n        {\"type\": \"lognormal\", \"sigma_target\": 0.40, \"seed\": 3},\n        {\"type\": \"lognormal\", \"sigma_target\": 0.05, \"seed\": 4},\n    ]\n\n    results = []\n    \n    # --- Pre-computation ---\n    # Setup k-space grid\n    k_freq = np.fft.fftfreq(N, d=L / N) * 2 * np.pi\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n    k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n    \n    # Calculate theoretical P(k)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        P_nw = A * (k_mag / k0)**ns * np.exp(-(k_mag / kc)**2)\n        # np.sinc(x) is sin(pi*x)/(pi*x), so we use np.sinc(k*rs/pi) for sin(k*rs)/(k*rs)\n        bao_term = 1 + alpha * np.exp(-(k_mag * Sigma)**2) * np.sinc(k_mag * rs / np.pi)\n        P_k = P_nw * bao_term\n    P_k[k_mag == 0] = 0.0\n    sqrt_Pk = np.sqrt(P_k)\n\n    # Setup r-space grid for binning\n    dx = L / N\n    x = np.arange(N) * dx\n    grid_coords = np.stack(np.meshgrid(x, x, x, indexing='ij'), axis=-1)\n    \n    # Distances from the origin, accounting for periodic boundary conditions\n    min_dist = np.minimum(grid_coords, L - grid_coords)\n    r_grid = np.sqrt(np.sum(min_dist**2, axis=-1))\n\n    # Binning setup\n    r_max = L / 2.0\n    bins = np.arange(0, r_max + dx, dx)\n    bin_centers = (bins[:-1] + bins[1:]) / 2.0\n\n    # --- Main Loop over Test Cases ---\n    for case in test_cases:\n        \n        # --- 1. Generate Gaussian Field ---\n        rng = np.random.default_rng(seed=case[\"seed\"])\n        white_noise = rng.standard_normal(size=(N, N, N))\n        \n        delta_g_k = np.fft.fftn(white_noise) * sqrt_Pk\n        delta_g = np.fft.ifftn(delta_g_k).real\n        \n        # Rescale to target standard deviation\n        current_sigma = np.std(delta_g)\n        delta_g *= (case[\"sigma_target\"] / current_sigma)\n\n        # --- 2. Apply Non-Gaussian Mapping ---\n        if case[\"type\"] == \"identity\":\n            delta_mapped = delta_g\n        elif case[\"type\"] == \"lognormal\":\n            sigma2_g = case[\"sigma_target\"]**2\n            delta_mapped = np.exp(delta_g - sigma2_g / 2.0) - 1.0\n        else:\n            raise ValueError(f\"Unknown mapping type: {case['type']}\")\n\n        # --- 3. Compute Correlation Functions and Find Peaks ---\n        peak_locations = {}\n        fields_to_process = {\"Gaussian\": delta_g, \"mapped\": delta_mapped}\n        \n        for name, field in fields_to_process.items():\n            # Subtract mean\n            field_mean_sub = field - np.mean(field)\n            \n            # Compute correlation function using FFT\n            delta_k = np.fft.fftn(field_mean_sub)\n            # The result of ifftn(|fftn(field)|^2) has xi(0)=sum(field**2)\n            # To get xi(0)=var(field), we need to divide by N**3.\n            xi_grid = np.fft.ifftn(np.abs(delta_k)**2).real / (N**3)\n\n            # Isotropic averaging\n            counts, _ = np.histogram(r_grid.flatten(), bins=bins)\n            sums, _ = np.histogram(r_grid.flatten(), bins=bins, weights=xi_grid.flatten())\n            \n            # Avoid division by zero for empty bins\n            xi_r = np.zeros_like(bin_centers)\n            non_empty_bins = counts > 0\n            xi_r[non_empty_bins] = sums[non_empty_bins] / counts[non_empty_bins]\n            \n            # Smooth the binned correlation function\n            xi_r_smooth = gaussian_filter1d(xi_r, sigma=1.0)\n            \n            # Find peak in search window\n            search_mask = (bin_centers >= r_search_min)  (bin_centers = r_search_max)\n            \n            if not np.any(search_mask):\n                raise ValueError(\"Search window is empty or outside bin range.\")\n\n            masked_bins = bin_centers[search_mask]\n            masked_xi = xi_r_smooth[search_mask]\n            \n            max_idx_local = np.argmax(masked_xi)\n            max_idx_global = np.where(search_mask)[0][max_idx_local]\n            \n            # Quadratic interpolation for sub-bin accuracy\n            if 0  max_idx_global  len(bin_centers) - 1:\n                y_m1 = xi_r_smooth[max_idx_global - 1]\n                y_0 = xi_r_smooth[max_idx_global]\n                y_p1 = xi_r_smooth[max_idx_global + 1]\n                \n                denominator = 2 * (y_p1 + y_m1 - 2 * y_0)\n                if np.abs(denominator) > 1e-9: # Avoid division by zero/ill-conditioning\n                    offset = dx * (y_m1 - y_p1) / denominator\n                    peak_r = bin_centers[max_idx_global] + offset\n                else: # Collinear points\n                    peak_r = bin_centers[max_idx_global]\n            else: # Max is at boundary of computed xi(r) range\n                peak_r = bin_centers[max_idx_global]\n\n            peak_locations[name] = peak_r\n\n        # --- 4. Calculate Shift and Store Result ---\n        delta_r = peak_locations[\"mapped\"] - peak_locations[\"Gaussian\"]\n        results.append(round(delta_r, 3))\n    \n    # Final formatted output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3465676"}]}