{"hands_on_practices": [{"introduction": "在数值模拟中，我们通常在傅里叶空间中生成高斯随机场，然后再将其变换到实空间。这个过程有一个微妙但至关重要的步骤：我们必须确保最终得到的实空间场是纯实数的。这个练习 [@problem_id:3473758] 将引导你深入理解傅里叶系数的厄米共轭对称性（$\\delta_{-\\mathbf{k}} = \\delta_{\\mathbf{k}}^{\\ast}$）是如何保证场真实性的，并教会你如何正确处理那些满足 $\\mathbf{k}=-\\mathbf{k}$ 的特殊模式（零频率和奈奎斯特频率模式），这是任何高斯场生成代码都必须解决的核心问题。", "problem": "您正在为一个统计均匀各向同性的高斯密度对比场 $\\delta(\\mathbf{x})$ 生成初始条件。该场存在于一个边长为 $L$、体积为 $V=L^{3}$ 的周期性立方体盒子中，并在一个大小为 $N\\times N\\times N$ 的偶数尺寸网格上采样，$N$ 为偶数。允许的离散波矢量为 $\\mathbf{k}=\\frac{2\\pi}{L}(n_{x},n_{y},n_{z})$，其中整数索引 $n_{i}\\in\\{0,1,\\dots,N-1\\}$。为了便于处理厄米共轭对称性，这些索引可以映射到对称集 $n_{i}\\in\\{-\\frac{N}{2}+1,\\dots,\\frac{N}{2}\\}$。定义离散傅里叶变换为\n$$\n\\delta(\\mathbf{x})=\\frac{1}{V}\\sum_{\\mathbf{k}}\\delta_{\\mathbf{k}}\\exp(i\\mathbf{k}\\cdot\\mathbf{x}),\\qquad \\delta_{\\mathbf{k}}=\\int_{V}\\delta(\\mathbf{x})\\exp(-i\\mathbf{k}\\cdot\\mathbf{x})\\,d^{3}x.\n$$\n假设以下经过充分检验的统计事实：\n- 场 $\\delta(\\mathbf{x})$ 是实值的，因此它遵循厄米约束 $\\delta_{-\\mathbf{k}}=\\delta_{\\mathbf{k}}^{\\ast}$。\n- 两点统计特性由功率谱 $P(k)$ 描述：\n$$\n\\langle \\delta_{\\mathbf{k}}\\delta_{\\mathbf{k}'}^{\\ast}\\rangle=V\\,P(k)\\,\\delta_{\\mathbf{k},\\mathbf{k}'},\n$$\n其中 $\\delta_{\\mathbf{k},\\mathbf{k}'}$ 是克罗内克δ函数，$k=|\\mathbf{k}|$.\n\n在一个偶数网格上，存在一些特殊的自共轭模式，它们满足 $\\mathbf{k}\\equiv -\\mathbf{k}$ （在网格的倒易矢量意义下），这种情况当且仅当每个分量索引为 $0$ 或 $N/2$ 时发生。这些模式包括零模式 $\\mathbf{k}=\\mathbf{0}$ 以及一个或多个分量处于奈奎斯特索引的奈奎斯特模式。在生成与上述定义一致的高斯随机场时，您必须确保 $\\delta(\\mathbf{x})$ 的实数性质以及傅里叶模式的正确高斯统计特性。\n\n从上面给出的定义和事实出发（不使用任何其他公式），推导为任何非零自共轭模式（即 $\\mathbf{k}\\neq\\mathbf{0}$ 且其每个分量为 $0$ 或奈奎斯特波数）的 $\\delta_{\\mathbf{k}}$ 采样所使用的单个实高斯随机变量赋予的正确方差，以使最终的场保持实数性质并具有目标功率谱。请用 $V$ 和 $P(k)$ 的闭合解析表达式表示您的答案。您还应在推导过程中说明如何处理零模式以保持物理上有意义的密度对比。您的最终答案必须是单个解析表达式。不需要四舍五入，最终表达式中也不应包含单位，因为根据定义 $\\delta$ 是无量纲的。", "solution": "问题陈述已经过仔细验证，并被确定为有效。它在数值宇宙学的原理上具有科学依据，是良定的、客观的且内部一致的。进行严格推导所需的所有信息均已提供。\n\n目标是确定用于对非零自共轭模式 $\\mathbf{k}$ 的傅里叶模式 $\\delta_{\\mathbf{k}}$ 进行采样的实值高斯随机变量的方差。自共轭模式被定义为满足 $\\mathbf{k} \\equiv -\\mathbf{k}$ （在网格的倒易矢量意义下）的模式。在一个大小为 $N\\times N\\times N$ 的偶数尺寸网格上，这些模式是指其整数索引矢量 $(n_x, n_y, n_z)$ 的每个分量为 $0$ 或 $N/2$ 的模式。问题要求的是当 $\\mathbf{k} \\neq \\mathbf{0}$ 时此类模式的方差。\n\n我们从密度对比场 $\\delta(\\mathbf{x})$ 及其傅里叶变换 $\\delta_{\\mathbf{k}}$ 的基本性质开始。\n\n首先，场 $\\delta(\\mathbf{x})$ 是一个实值函数。这对它的傅里叶系数施加了厄米共轭对称性约束：\n$$\n\\delta_{-\\mathbf{k}} = \\delta_{\\mathbf{k}}^{\\ast}\n$$\n其中星号表示复共轭。\n\n其次，高斯随机场的统计特性由功率谱 $P(k)$ 通过傅里叶模式的两点相关函数定义：\n$$\n\\langle \\delta_{\\mathbf{k}}\\delta_{\\mathbf{k}'}^{\\ast}\\rangle = V\\,P(k)\\,\\delta_{\\mathbf{k},\\mathbf{k}'}\n$$\n其中 $V$ 是盒子的体积，$k=|\\mathbf{k}|$，$\\delta_{\\mathbf{k},\\mathbf{k}'}$ 是克罗内克δ函数。尖括号 $\\langle\\dots\\rangle$ 表示系综平均。\n\n现在我们考虑一个非零的自共轭模式 $\\mathbf{k}$。对于这样的模式，波矢量 $\\mathbf{k}$ 是其自身的负值（相差一个倒易格矢，这对网格上的离散模式不产生影响）。因此，厄米共轭对称性约束变为：\n$$\n\\delta_{\\mathbf{k}} = \\delta_{-\\mathbf{k}} = \\delta_{\\mathbf{k}}^{\\ast}\n$$\n一个与其自身共轭相等的复数必定是纯实数。如果我们将 $\\delta_{\\mathbf{k}}$ 写成其实部和虚部的形式，$\\delta_{\\mathbf{k}} = \\text{Re}(\\delta_{\\mathbf{k}}) + i\\,\\text{Im}(\\delta_{\\mathbf{k}})$，那么条件 $\\delta_{\\mathbf{k}} = \\delta_{\\mathbf{k}}^{\\ast}$ 意味着 $\\text{Im}(\\delta_{\\mathbf{k}}) = 0$。因此，对于任何自共轭模式，傅里叶系数 $\\delta_{\\mathbf{k}}$ 都是一个实数。\n\n为了生成该场，我们从一个高斯分布中对 $\\delta_{\\mathbf{k}}$ 进行抽样。由于对于自共轭模式，$\\delta_{\\mathbf{k}}$ 必须是实数，所以它是从一个实高斯分布中抽取的。问题要求的是这个分布的方差。根据定义，一个零均值随机变量 $X$ 的方差是 $\\langle X^2 \\rangle$。一个零均值随机场的傅里叶模式也具有零均值，即 $\\langle \\delta_{\\mathbf{k}} \\rangle = 0$。因此，我们需要计算 $\\langle \\delta_{\\mathbf{k}}^2 \\rangle$。\n\n我们将给定的功率谱定义应用于 $\\mathbf{k}' = \\mathbf{k}$ 的特定情况：\n$$\n\\langle \\delta_{\\mathbf{k}}\\delta_{\\mathbf{k}}^{\\ast}\\rangle = V\\,P(k)\n$$\n因为我们已经确定对于自共轭模式 $\\delta_{\\mathbf{k}}$ 是实数，所以我们有 $\\delta_{\\mathbf{k}}^{\\ast} = \\delta_{\\mathbf{k}}$。将此代入上式得到：\n$$\n\\langle \\delta_{\\mathbf{k}}\\delta_{\\mathbf{k}}\\rangle = \\langle \\delta_{\\mathbf{k}}^2 \\rangle = V\\,P(k)\n$$\n这个结果正是用于对模式 $\\delta_{\\mathbf{k}}$ 进行采样的单个实高斯随机变量的方差。这对于任何非零自共轭模式都成立。\n\n作为对比，对于一个普通的非自共轭模式 $\\mathbf{k}$（其中 $\\mathbf{k} \\neq -\\mathbf{k}$），$\\delta_{\\mathbf{k}}$ 是一个复数，$\\delta_{\\mathbf{k}} = A_{\\mathbf{k}} + iB_{\\mathbf{k}}$，其中 $A_{\\mathbf{k}}$ 和 $B_{\\mathbf{k}}$ 是独立的实高斯随机变量。在这种情况下，$\\langle \\delta_{\\mathbf{k}}\\delta_{\\mathbf{k}}^{\\ast} \\rangle = \\langle (A_{\\mathbf{k}} + iB_{\\mathbf{k}})(A_{\\mathbf{k}} - iB_{\\mathbf{k}}) \\rangle = \\langle A_{\\mathbf{k}}^2 + B_{\\mathbf{k}}^2 \\rangle$。由于统计各向同性，实部和虚部的方差相等，$\\langle A_{\\mathbf{k}}^2 \\rangle = \\langle B_{\\mathbf{k}}^2 \\rangle$。因此，$2\\langle A_{\\mathbf{k}}^2 \\rangle = V P(k)$，这给出 $\\langle A_{\\mathbf{k}}^2 \\rangle = \\langle B_{\\mathbf{k}}^2 \\rangle = \\frac{1}{2}V P(k)$。赋予一般复数模式的实部和虚部的方差是赋予纯实数自共轭模式方差的一半。\n\n最后，问题要求说明零模式 $\\mathbf{k}=\\mathbf{0}$ 的处理方式。零模式是最基本的自共轭模式。它的值由傅里叶变换定义给出：\n$$\n\\delta_{\\mathbf{k}=\\mathbf{0}} = \\int_{V} \\delta(\\mathbf{x}) \\exp(-i\\mathbf{0} \\cdot \\mathbf{x})\\,d^3x = \\int_{V} \\delta(\\mathbf{x})\\,d^3x\n$$\n这是密度对比场在整个体积上的积分。密度对比定义为 $\\delta(\\mathbf{x}) = (\\rho(\\mathbf{x}) - \\bar{\\rho})/\\bar{\\rho}$，其中 $\\bar{\\rho}$ 是宇宙的平均密度。根据定义，$\\delta(\\mathbf{x})$ 在一个公平的、有代表性的体积上的空间平均值必须为零。我们的模拟盒子被假定为这样一个体积。因此，我们必须强制要求：\n$$\n\\frac{1}{V}\\int_{V}\\delta(\\mathbf{x})\\,d^3x = 0 \\implies \\int_{V}\\delta(\\mathbf{x})\\,d^3x = 0\n$$\n这意味着 $\\delta_{\\mathbf{k}=\\mathbf{0}}$ 必须在构造时被设置为 $0$。它不是一个需要从分布中抽取的随机变量；它的值是固定的，以保持与密度对比的定义相一致。这个物理约束正是问题正确地要求*非零*自共轭模式方差的原因。\n\n总之，对于任何非零自共轭模式 $\\mathbf{k}$，其傅里叶系数 $\\delta_{\\mathbf{k}}$ 必须是实数，并且从中抽样的 高斯分布的方差是 $V P(k)$。", "answer": "$$\\boxed{V P(k)}$$", "id": "3473758"}, {"introduction": "宇宙学中的观测效应，例如红移空间畸变（redshift-space distortions），会破坏我们理论模型中的统计各向同性，引入方向依赖性。这个综合性练习 [@problem_id:3490700] 将带你从理论推导到代码实现，模拟一个由各向异性功率谱 $P(k, \\mu)$ 描述的场，并学习如何使用勒让德多极矩 $P_\\ell(k)$ 来量化其统计特性。你还将探讨一个真实巡天中不可避免的问题——巡天窗口效应（survey window effects）如何导致不同多极矩之間的模式混合（mode-mixing），这是精确宇宙学分析的关键一步。", "problem": "您的任务是开发一个完整的、可运行的程序，该程序通过方向性功率谱模拟各向异性高斯随机场中的红移空间畸变，将该场投影到勒让德多极矩上，在高斯假设下推导并评估这些多极矩的协方差，并量化由方向性选择傅里叶模式的各向异性巡天窗口引入的多极矩之间的模式混合。所有计算都必须以纯数学术语和无量纲量进行，并且所有最终的数值输出都应表示为不带物理单位的浮点数。\n\n考虑一个统计均匀的高斯随机场，其傅里叶模式为 $\\delta(\\mathbf{k})$，使得傅里叶空间中的两点函数通过功率谱定义为\n$$\n\\langle \\delta(\\mathbf{k})\\,\\delta^{\\ast}(\\mathbf{k}^{\\prime})\\rangle = (2\\pi)^{3}\\,\\delta_{\\mathrm{D}}^{3}(\\mathbf{k}-\\mathbf{k}^{\\prime})\\,P(k,\\mu),\n$$\n其中 $k=\\lVert \\mathbf{k}\\rVert$ 且 $\\mu=\\cos\\theta$，$\\theta$ 是 $\\mathbf{k}$ 与固定视线轴之间的夹角。假设一个形式如下的各向异性红移空间功率谱\n$$\nP(k,\\mu) = S(k)\\,\\left(1+\\beta\\,\\mu^{2}\\right)^{2},\n$$\n其中 $\\beta$ 是一个常数，$S(k)$ 是一个光滑的非负形状函数。令 $L_{\\ell}(\\mu)$ 表示 $\\ell$ 阶勒让德多项式，$P(k,\\mu)$ 的勒让德多极矩定义为\n$$\nP_{\\ell}(k) = \\frac{2\\ell+1}{2}\\int_{-1}^{1} \\mathrm{d}\\mu\\, P(k,\\mu)\\,L_{\\ell}(\\mu).\n$$\n\n假设一个有限的周期性巡天体积 $V$，在其中，估计量是在以 $k$ 为中心、宽度为 $\\Delta k$ 的球形 $k$-壳层上形成的。定义这样一个壳层中独立傅里叶模式的数量为\n$$\nN_{\\mathrm{m}}(k;\\Delta k,V) \\equiv \\frac{V}{(2\\pi)^{3}}\\int_{k-\\Delta k/2}^{k+\\Delta k/2}\\mathrm{d}k^{\\prime}\\, 4\\pi\\,k^{\\prime 2} \\approx \\frac{V\\,4\\pi\\,k^{2}\\,\\Delta k}{(2\\pi)^{3}} = \\frac{V\\,k^{2}\\,\\Delta k}{2\\pi^{2}}.\n$$\n\nA部分（推导）：从 $\\delta(\\mathbf{k})$ 的高斯性及上述定义出发，推导通过将球壳平均功率谱投影到 $L_{\\ell}(\\mu)$ 上而形成的勒让德多极矩估计量的高斯协方差，\n$$\n\\widehat{P}_{\\ell}(k) \\equiv \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, \\widehat{P}(k,\\mu)\\,L_{\\ell}(\\mu),\n$$\n其中 $\\widehat{P}(k,\\mu)$ 表示在固定 $(k,\\mu)$ 处的球壳平均功率。您的推导必须将 $\\mathrm{Cov}\\!\\left[\\widehat{P}_{\\ell}(k),\\widehat{P}_{\\ell^{\\prime}}(k)\\right]$ 完全用 $N_{\\mathrm{m}}(k;\\Delta k,V)$ 以及涉及 $L_{\\ell}(\\mu)$、$L_{\\ell^{\\prime}}(\\mu)$ 和 $P(k,\\mu)$ 的关于 $\\mu$ 的积分来表示。您的最终表达式应该是一个关于 $\\mu$ 的一维积分，并且必须反映功率谱方差的适当高斯因子 $2$。\n\nB部分（由窗口引起的模式混合）：现在假设巡天窗口通过一个已知的、独立于 $k$ 的非负权重函数 $W(\\mu) \\ge 0$ 在方向上各向异性地选择傅里叶模式。未对此方向性选择进行校正而计算出的伪多极矩估计量为\n$$\n\\widetilde{P}_{\\ell}(k) \\equiv \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, W(\\mu)\\,P(k,\\mu)\\,L_{\\ell}(\\mu).\n$$\n假设 $P(k,\\mu)$ 允许勒让德级数展开 $P(k,\\mu)=\\sum_{\\ell^{\\prime}}P_{\\ell^{\\prime}}(k)\\,L_{\\ell^{\\prime}}(\\mu)$，推导线性混合关系\n$$\n\\widetilde{P}_{\\ell}(k)=\\sum_{\\ell^{\\prime}} M_{\\ell\\ell^{\\prime}}\\,P_{\\ell^{\\prime}}(k),\n$$\n并获得混合矩阵 $M_{\\ell\\ell^{\\prime}}$ 的显式表达式，用一个涉及 $W(\\mu)$ 以及 $L_{\\ell}(\\mu)$ 和 $L_{\\ell^{\\prime}}(\\mu)$ 乘积的关于 $\\mu$ 的积分来表示。证明当 $W(\\mu)=1$ 时，$M_{\\ell\\ell^{\\prime}}$ 简化为单位矩阵。\n\n实现要求：实现一个程序，使用关于 $\\mu$ 的高斯-勒让德求积法数值计算以下量，并为提供的测试套件输出结果。使用 $S(k)=A\\,k^{n}\\,\\exp\\!\\left(-k^{2}/k_{c}^{2}\\right)$，参数在每个测试用例中指定。您必须评估 $\\ell\\in\\{0,2,4\\}$ 的勒让德多项式 $L_{\\ell}(\\mu)$，并以足够的求积分辨率执行所有必要的积分，以确保报告值的收敛精度至少达到 $10^{-8}$ 的绝对误差。\n\n测试套件和要求输出：\n\n- 测试 $1$（单位混合检查）：设置 $W(\\mu)=1$（等效于在窗口参数化 $W(\\mu)=1+\\alpha\\,L_{2}(\\mu)$ 中设置参数 $\\alpha=0$），并计算 $\\ell,\\ell^{\\prime}\\in\\{0,2,4\\}$ 的 $3\\times 3$ 混合矩阵 $M_{\\ell\\ell^{\\prime}}$。报告一个浮点数，等于 $M$ 的最大绝对非对角元素。\n- 测试 $2$（各向异性混合项）：设置 $W(\\mu)=1+\\alpha\\,L_{2}(\\mu)$ 且 $\\alpha=0.5$，并计算 $\\ell,\\ell^{\\prime}\\in\\{0,2,4\\}$ 的 $M_{\\ell\\ell^{\\prime}}$。按此顺序报告三个浮点数 $\\left(M_{0,2},\\,M_{2,2},\\,M_{2,4}\\right)$。\n- 测试 $3$（协方差互相关，各向同性与各向异性红移空间对比）：使用 $k=0.15$，$\\Delta k=0.02$，$V=(1500)^{3}$，$A=1.0$，$n=1.0$，$k_{c}=0.3$，并在两种情况下评估 $\\ell,\\ell^{\\prime}\\in\\{0,2,4\\}$ 的高斯协方差积分：\n  - 情况 $(a)$：$\\beta=0.0$。\n  - 情况 $(b)$：$\\beta=0.5$。\n  对于每种情况，计算单极矩和四极矩估计量之间的皮尔逊相关系数，定义为\n  $$\n  \\rho_{0,2}(k) = \\frac{\\mathrm{Cov}\\!\\left[\\widehat{P}_{0}(k),\\widehat{P}_{2}(k)\\right]}{\\sqrt{\\mathrm{Cov}\\!\\left[\\widehat{P}_{0}(k),\\widehat{P}_{0}(k)\\right]\\;\\mathrm{Cov}\\!\\left[\\widehat{P}_{2}(k),\\widehat{P}_{2}(k)\\right]}}.\n  $$\n  按此顺序报告两个浮点数 $\\left(\\rho_{0,2}^{(\\beta=0.0)},\\,\\rho_{0,2}^{(\\beta=0.5)}\\right)$。\n- 测试 $4$（模式计数）：对于 $k=0.15$，$\\Delta k=0.02$，$V=(1500)^{3}$，使用上面给出的近似计算并报告浮点数 $N_{\\mathrm{m}}(k;\\Delta k,V)$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_{1},r_{2},r_{3},r_{4},r_{5},r_{6},r_{7}]$），按顺序汇总测试 $1$、测试 $2$（三个数）、测试 $3$（两个数）和测试 $4$ 的输出。\n\n重要规则：\n\n- 所有计算必须是完全确定性的和自包含的，无需用户输入。\n- 所有输出必须是完全按照指定顺序和格式收集的数值浮点数。\n- 全程使用无量纲量；不报告任何物理单位。", "solution": "该问题要求推导功率谱多极矩估计量的协方差以及由各向异性巡天窗口引起的模式混合矩阵的解析表达式，然后通过数值实现来为一组给定的测试用例评估这些量。\n\n### A部分：多极矩估计量协方差的推导\n\n起点是傅里叶空间中一个统计均匀且各向同性的复高斯随机场 $\\delta(\\mathbf{k})$。两点相关函数由下式给出\n$$\n\\langle \\delta(\\mathbf{k})\\,\\delta^{\\ast}(\\mathbf{k}^{\\prime})\\rangle = (2\\pi)^{3}\\,\\delta_{\\mathrm{D}}^{3}(\\mathbf{k}-\\mathbf{k}^{\\prime})\\,P(k,\\mu)\n$$\n其中 $P(k,\\mu)$ 是各向异性功率谱，$k = \\lVert\\mathbf{k}\\rVert$，$\\mu = \\hat{\\mathbf{k}}\\cdot\\hat{\\mathbf{z}}$，其中 $\\hat{\\mathbf{z}}$ 是一个固定的视线方向。\n\n功率谱的估计量 $\\widehat{P}(k,\\mu)$ 是通过在傅里叶空间中，于给定的半径 $k$ 和极角 $\\cos^{-1}\\mu$ 处，对一个薄壳层上的 $|\\delta(\\mathbf{k})|^2$进行平均而构造的。对于高斯场，壳层上不同角位置 $(\\mu, \\phi)$ 的功率谱估计量的涨落是统计独立的。来自包含 $N_{\\text{modes}}$ 个独立模式的区域的功率谱估计的方差为 $\\mathrm{Var}[\\widehat{P}] = 2P^2/N_{\\text{modes}}$。因子 $2$ 的出现是因为实空间中的基础密度场是实数，这意味着 $\\delta(-\\mathbf{k}) = \\delta^*(\\mathbf{k})$。\n\n半径为 $k$、宽度为 $\\Delta k$ 的球壳中的独立模式总数由 $N_{\\mathrm{m}}(k) = \\frac{V k^2 \\Delta k}{2\\pi^2}$ 给出。这些模式均匀分布在 $4\\pi$ 的立体角上。在壳层上 $\\mu$ 和 $\\mu+\\mathrm{d}\\mu$ 之间的一个薄环带中的模式数量与该环带的面积成正比，即 $2\\pi \\sin\\theta \\mathrm{d}\\theta = 2\\pi \\mathrm{d}\\mu$。此环带中的立体角占总立体角的分数为 $(2\\pi \\mathrm{d}\\mu)/(4\\pi) = \\mathrm{d}\\mu/2$。因此，此环带中的模式数量为 $\\mathrm{d}N_{\\mathrm{m}} = N_{\\mathrm{m}}(k) \\frac{\\mathrm{d}\\mu}{2}$。\n\n球壳平均估计量 $\\widehat{P}(k,\\mu)$ 和 $\\widehat{P}(k,\\mu')$ 的协方差可以被建模为在 $\\mu$ 上是局域的，这反映了不同环带的统计独立性：\n$$\n\\mathrm{Cov}\\left[\\widehat{P}(k,\\mu), \\widehat{P}(k,\\mu')\\right] = \\frac{2 [P(k,\\mu)]^2}{\\text{单位}\\mu\\text{的模式数}} \\delta_{\\mathrm{D}}(\\mu-\\mu') = \\frac{2 [P(k,\\mu)]^2}{N_{\\mathrm{m}}(k)/2} \\delta_{\\mathrm{D}}(\\mu-\\mu') = \\frac{4 [P(k,\\mu)]^2}{N_{\\mathrm{m}}(k)} \\delta_{\\mathrm{D}}(\\mu-\\mu')\n$$\n勒让德多极矩估计量被定义为 $\\widehat{P}(k,\\mu)$ 的投影：\n$$\n\\widehat{P}_{\\ell}(k) \\equiv \\frac{2\\ell+1}{2}\\int_{-1}^{1} \\mathrm{d}\\mu\\, \\widehat{P}(k,\\mu)\\,L_{\\ell}(\\mu)\n$$\n两个此类估计量 $\\widehat{P}_{\\ell}(k)$ 和 $\\widehat{P}_{\\ell'}(k)$ 之间的协方差是\n$$\n\\mathrm{Cov}\\!\\left[\\widehat{P}_{\\ell}(k),\\widehat{P}_{\\ell^{\\prime}}(k)\\right] = \\left\\langle (\\widehat{P}_{\\ell}(k)-P_{\\ell}(k)) (\\widehat{P}_{\\ell^{\\prime}}(k)-P_{\\ell^{\\prime}}(k)) \\right\\rangle\n$$\n$$\n= \\frac{(2\\ell+1)(2\\ell^{\\prime}+1)}{4} \\int_{-1}^{1}\\mathrm{d}\\mu \\int_{-1}^{1}\\mathrm{d}\\mu' L_{\\ell}(\\mu)L_{\\ell^{\\prime}}(\\mu') \\mathrm{Cov}\\!\\left[\\widehat{P}(k,\\mu),\\widehat{P}(k,\\mu')\\right]\n$$\n代入微分协方差的表达式：\n$$\n= \\frac{(2\\ell+1)(2\\ell^{\\prime}+1)}{4} \\int_{-1}^{1}\\mathrm{d}\\mu \\int_{-1}^{1}\\mathrm{d}\\mu' L_{\\ell}(\\mu)L_{\\ell^{\\prime}}(\\mu') \\frac{4 [P(k,\\mu)]^2}{N_{\\mathrm{m}}(k)} \\delta_{\\mathrm{D}}(\\mu-\\mu')\n$$\n使用狄拉克δ函数 $\\delta_{\\mathrm{D}}(\\mu-\\mu')$ 对 $\\mu'$ 进行积分，得到最终结果：\n$$\n\\mathrm{Cov}\\!\\left[\\widehat{P}_{\\ell}(k),\\widehat{P}_{\\ell^{\\prime}}(k)\\right] = \\frac{(2\\ell+1)(2\\ell^{\\prime}+1)}{N_{\\mathrm{m}}(k)} \\int_{-1}^{1} \\mathrm{d}\\mu\\, [P(k,\\mu)]^2 L_{\\ell}(\\mu) L_{\\ell^{\\prime}}(\\mu)\n$$\n此表达式正确地将协方差与功率谱平方的积分联系起来，该积分由勒让德多项式加权，并且与模式数 $N_{\\mathrm{m}}(k)$ 成反比。对于各向同性功率谱 $P(k,\\mu) = P_0(k)$，单极矩估计量 $\\widehat{P}_0(k)$ 的方差变为 $\\mathrm{Var}[\\widehat{P}_0(k)] = \\frac{1}{N_{\\mathrm{m}}(k)}\\int_{-1}^{1} [P_0(k)]^2 \\mathrm{d}\\mu = \\frac{2 [P_0(k)]^2}{N_{\\mathrm{m}}(k)}$，这是反映了“高斯因子2”的标准结果。\n\n### B部分：模式混合矩阵的推导\n\n各向异性的巡天窗口引入了一个方向性权重 $W(\\mu)$，从而修改了多极矩估计量。由此产生的“伪多极矩”估计量是\n$$\n\\widetilde{P}_{\\ell}(k) \\equiv \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, W(\\mu)\\,P(k,\\mu)\\,L_{\\ell}(\\mu)\n$$\n真实的基础功率谱 $P(k,\\mu)$ 可以展开为勒让德级数，其系数为 $P_{\\ell'}(k)$，即真实的多极矩：\n$$\nP(k,\\mu) = \\sum_{\\ell'=0}^{\\infty} P_{\\ell'}(k)\\,L_{\\ell'}(\\mu)\n$$\n将此展开式代入 $\\widetilde{P}_{\\ell}(k)$ 的定义中：\n$$\n\\widetilde{P}_{\\ell}(k) = \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, W(\\mu)\\, \\left(\\sum_{\\ell'=0}^{\\infty} P_{\\ell'}(k)\\,L_{\\ell'}(\\mu)\\right) L_{\\ell}(\\mu)\n$$\n假设级数一致收敛，我们可以交换求和与积分的顺序：\n$$\n\\widetilde{P}_{\\ell}(k) = \\sum_{\\ell'=0}^{\\infty} \\left( \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, W(\\mu)\\,L_{\\ell}(\\mu)\\,L_{\\ell'}(\\mu) \\right) P_{\\ell'}(k)\n$$\n这是一个形如 $\\widetilde{P}_{\\ell}(k)=\\sum_{\\ell'} M_{\\ell\\ell^{\\prime}}\\,P_{\\ell^{\\prime}}(k)$ 的线性关系，其中混合矩阵 $M_{\\ell\\ell^{\\prime}}$ 被确定为：\n$$\nM_{\\ell\\ell^{\\prime}} = \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\, W(\\mu)\\,L_{\\ell}(\\mu)\\,L_{\\ell^{\\prime}}(\\mu)\n$$\n如果窗口函数是均匀的，$W(\\mu)=1$，则矩阵元素变为：\n$$\nM_{\\ell\\ell^{\\prime}} = \\frac{2\\ell+1}{2}\\int_{-1}^{1}\\mathrm{d}\\mu\\,L_{\\ell}(\\mu)\\,L_{\\ell^{\\prime}}(\\mu)\n$$\n使用勒让德多项的正交关系 $\\int_{-1}^{1}L_{\\ell}(\\mu)L_{\\ell'}(\\mu)\\mathrm{d}\\mu = \\frac{2}{2\\ell+1}\\delta_{\\ell\\ell'}$，我们发现：\n$$\nM_{\\ell\\ell^{\\prime}} = \\frac{2\\ell+1}{2} \\left( \\frac{2}{2\\ell+1}\\delta_{\\ell\\ell'} \\right) = \\delta_{\\ell\\ell'}\n$$\n因此，对于均匀窗口，混合矩阵是单位矩阵，多极矩之间没有混合，正如预期。\n\n### 数值实现\n\n推导出的公式被数值实现以解决测试用例。实现的核心是计算在 $\\mu \\in [-1, 1]$ 上的一维积分。由于所有被积函数都是关于 $\\mu$ 的多项式，高精度的 Gauss-Legendre 求积法是一种精确而高效的方法。选择了 $N_{\\text{quad}}=100$ 的求积阶数，这足以将出现的多项式积分到机器精度。所需的勒让德多项式 $L_0(\\mu)$，$L_2(\\mu)$ 和 $L_4(\\mu)$被实现为显式函数。\n\n- **测试 1**：为 $\\ell, \\ell' \\in \\{0,2,4\\}$ 和均匀窗口 $W(\\mu)=1$ 计算混合矩阵 $M_{\\ell\\ell'}$。每个矩阵元素的积分通过求积法计算。报告最大的绝对非对角元素，该值预期在数值上为零。\n- **测试 2**：为各向异性窗口 $W(\\mu)=1+0.5L_2(\\mu)$ 计算 $M_{\\ell\\ell'}$。所需的元素 $(M_{0,2}, M_{2,2}, M_{2,4})$ 使用相同的求积方法计算。\n- **测试 3**：计算皮尔逊相关系数 $\\rho_{0,2} = \\mathrm{Cov}_{02}/\\sqrt{\\mathrm{Cov}_{00}\\mathrm{Cov}_{22}}$。协方差项与形如 $\\int_{-1}^{1} [P(k,\\mu)]^2 L_{\\ell}(\\mu) L_{\\ell'}(\\mu) \\mathrm{d}\\mu$ 的积分成正比。公共的前置因子 $S(k)^2$ 和 $1/N_{\\mathrm{m}}(k)$ 在比率中被抵消，从而简化了计算。\n  - 对于情况 (a)，$\\beta=0.0$，功率谱 $P(k,\\mu)$ 是各向同性的。$\\mathrm{Cov}_{02}$ 的积分包含 $L_0(\\mu)L_2(\\mu)$，根据正交性，其积分为零。因此，解析上 $\\rho_{0,2}=0$。\n  - 对于情况 (b)，$\\beta=0.5$，被积函数 $[P(k,\\mu)]^2 = S(k)^2(1+0.5\\mu^2)^4$ 是各向异性的。为求得 $\\rho_{0,2}$，数值计算了 $\\mathrm{Cov}_{00}$、$\\mathrm{Cov}_{22}$ 和 $\\mathrm{Cov}_{02}$ 所需的积分。\n- **测试 4**：模式数 $N_{\\mathrm{m}}$ 使用给定的参数值，通过提供的公式 $N_{\\mathrm{m}} = V k^2 \\Delta k / (2\\pi^2)$ 直接计算。\n\n所有测试的结果被汇总到一个列表中用于最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes redshift-space distortion quantities based on the problem statement.\n    \"\"\"\n\n    # --- Problem Setup ---\n    # Number of quadrature points for numerical integration.\n    # The integrands are low-degree polynomials, so this is highly accurate.\n    N_QUAD = 100\n    # Required multipole indices\n    ells = [0, 2, 4]\n\n    # Gauss-Legendre quadrature points and weights over [-1, 1]\n    mu, w = np.polynomial.legendre.leggauss(N_QUAD)\n\n    # --- Helper Functions ---\n    def get_legendre_poly(ell):\n        \"\"\"Returns a function for the Legendre polynomial L_ell(mu).\"\"\"\n        if ell == 0:\n            return np.ones_like\n        elif ell == 2:\n            return lambda x: 0.5 * (3 * x**2 - 1)\n        elif ell == 4:\n            return lambda x: 0.125 * (35 * x**4 - 30 * x**2 + 3)\n        else:\n            raise ValueError(f\"Legendre polynomial for l={ell} not required by the problem.\")\n\n    legendre_funcs = {ell: get_legendre_poly(ell) for ell in ells}\n    \n    # This list will store the final results in order.\n    results = []\n\n    # --- Test 1: Identity mixing check ---\n    alpha_1 = 0.0\n    W_1 = 1.0 + alpha_1 * legendre_funcs[2](mu)\n    \n    M_1 = np.zeros((3, 3))\n    \n    for i, ell in enumerate(ells):\n        for j, ell_prime in enumerate(ells):\n            L_ell = legendre_funcs[ell](mu)\n            L_ell_prime = legendre_funcs[ell_prime](mu)\n            integrand = W_1 * L_ell * L_ell_prime\n            integral = np.sum(integrand * w)\n            M_1[i, j] = (2 * ell + 1) / 2.0 * integral\n    \n    off_diag_M_1 = M_1[~np.eye(3, dtype=bool)]\n    max_abs_off_diag = np.max(np.abs(off_diag_M_1))\n    results.append(max_abs_off_diag)\n\n    # --- Test 2: Anisotropic mixing entries ---\n    alpha_2 = 0.5\n    W_2 = 1.0 + alpha_2 * legendre_funcs[2](mu)\n    \n    M_2 = np.zeros((3, 3))\n    for i, ell in enumerate(ells):\n        for j, ell_prime in enumerate(ells):\n            L_ell = legendre_funcs[ell](mu)\n            L_ell_prime = legendre_funcs[ell_prime](mu)\n            integrand = W_2 * L_ell * L_ell_prime\n            integral = np.sum(integrand * w)\n            M_2[i, j] = (2 * ell + 1) / 2.0 * integral\n            \n    m02 = M_2[0, 1]  # ell=0, ell'=2\n    m22 = M_2[1, 1]  # ell=2, ell'=2\n    m24 = M_2[1, 2]  # ell=2, ell'=4\n    results.extend([m02, m22, m24])\n    \n    # --- Test 3: Covariance cross-correlation ---\n    # Case (a): beta = 0.0\n    # For an isotropic field, Cov(P_0, P_2) = 0, so rho_02 = 0.\n    rho_02_a = 0.0\n    results.append(rho_02_a)\n    \n    # Case (b): beta = 0.5\n    beta_b = 0.5\n    # The integrand part depending on mu is ( (1+beta*mu^2)^2 )^2\n    P_mu_part_sq = (1 + beta_b * mu**2)**4\n    \n    def compute_cov_integral(ell, ell_prime):\n        L_ell = legendre_funcs[ell](mu)\n        L_ell_prime = legendre_funcs[ell_prime](mu)\n        integrand = P_mu_part_sq * L_ell * L_ell_prime\n        return np.sum(integrand * w)\n\n    # The correlation coefficient rho_02 simplifies to I_02 / sqrt(I_00 * I_22)\n    # where I_ll' is the integral part of the covariance formula.\n    I_00 = compute_cov_integral(0, 0)\n    I_22 = compute_cov_integral(2, 2)\n    I_02 = compute_cov_integral(0, 2)\n    \n    # The prefactors (2l+1) cancel in the Pearson correlation coefficient.\n    # rho_02 = [(1*5)*I_02] / sqrt([(1*1)*I_00] * [(5*5)*I_22]) = I_02 / sqrt(I_00*I_22)\n    rho_02_b = I_02 / np.sqrt(I_00 * I_22)\n    results.append(rho_02_b)\n    \n    # --- Test 4: Mode count ---\n    V = 1500.0**3\n    k_4 = 0.15\n    delta_k_4 = 0.02\n    \n    N_m = (V * k_4**2 * delta_k_4) / (2 * np.pi**2)\n    results.append(N_m)\n\n    # --- Final Output ---\n    # The final print statement must produce only the specified single-line format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```", "id": "3490700"}, {"introduction": "生成模拟宇宙是数值宇宙学的重要组成部分，但最终目标是从真实观测数据中推断宇宙学参数。这个练习 [@problem_id:3490786] 将引导你完成从“正向建模”到“逆向问题”的关键转变。你将设计一种基于模拟的“无似然推斷”（Likelihood-Free Inference, LFI）方法，通过精心设计的概要統計量（summary statistics）来估计功率谱参数，并将其与理论上最优的最大似然估计（Maximum Likelihood Estimation, MLE）进行比较。通过这个过程，你将深刻理解在高斯随机场中，哪些信息（例如功率和相位）对于参数推断是至关重要的。", "problem": "考虑一个在傅里叶空间中定义的复值、零均值、统计均匀且各向同性的高斯随机场，该场定义在一个大小为 $N \\times N$ 的周期性二维网格上。设离散角波数为 $k_x$ 和 $k_y$，其模为 $k = \\sqrt{k_x^2 + k_y^2}$。假设对于所有 $k  0$ 的 $\\mathbf{k}$，傅里叶空间系数 $\\delta_{\\mathbf{k}}$ 是独立同分布的循环复高斯变量，其方差等于目标功率谱 $P(k \\, ; \\, \\boldsymbol{\\theta})$，其中参数矢量为 $\\boldsymbol{\\theta} = (A, n)$。具体来说，对于每个独立模式，$\\delta_{\\mathbf{k}}$ 的概率密度函数为\n$$\np(\\delta_{\\mathbf{k}} \\mid \\boldsymbol{\\theta}) = \\frac{1}{\\pi P(k \\, ; \\, \\boldsymbol{\\theta})} \\exp\\left(-\\frac{|\\delta_{\\mathbf{k}}|^2}{P(k \\, ; \\, \\boldsymbol{\\theta})}\\right),\n$$\n其中 $|\\delta_{\\mathbf{k}}|^2$ 表示复傅里叶系数的模的平方。功率谱的参数形式为\n$$\nP(k \\, ; \\, A, n) = A \\, \\left(k^2 + k_0^2\\right)^{n/2},\n$$\n其中固定枢轴点 $k_0 = 1.0$。所有量均为无量纲。\n\n您的任务是设计一个专为高斯场定制的无似然推断 (LFI) 程序，并将其参数恢复能力与基于精确高斯似然的最大似然估计 (MLE) 进行比较。LFI 应依赖于高斯随机场特有的信息性摘要统计量：\n\n- 在各向同性 $k$-bins（傅里叶空间中的环带）内 $|\\delta_{\\mathbf{k}}|^2$ 的直方图。\n- 相位均匀性，通过相位 $\\phi_{\\mathbf{k}} = \\arg(\\delta_{\\mathbf{k}})$ 的平均合矢量长度来衡量，以弧度计算。\n\n从高斯随机场的基本定义和上述 $P(k)$ 的参数形式出发，推导独立傅里叶系数的精确高斯似然，并使用指定的摘要统计量构建 LFI。然后，用数值方法实现这两种方法并比较它们的参数估计。\n\n请使用以下设计与评估协议：\n\n1. 对于每个测试案例，通过对每个 $k  0$ 的 $\\delta_{\\mathbf{k}}$ 进行独立抽样来生成一个合成的“观测”复高斯场，抽样分布为方差是 $P(k \\, ; \\, A_{\\text{true}}, n_{\\text{true}})$ 的复高斯分布，即从 $\\mathcal{N}(0, P(k \\, ; \\, A_{\\text{true}}, n_{\\text{true}})/2)$ 中独立抽取 $\\Re(\\delta_{\\mathbf{k}})$ 和 $\\Im(\\delta_{\\mathbf{k}})$，使得 $\\mathbb{E}[|\\delta_{\\mathbf{k}}|^2] = P(k \\, ; \\, A_{\\text{true}}, n_{\\text{true}})$。为保证可复现性，请使用固定的随机种子。\n\n2. 使用在最小正 $k$ 和最大 $k$ 之间等距的边界，将正 $k$ 模式划分为 $B$ 个各向同性 bins，其中 $B = 6$。对于每个 bin，使用由该 $k$-bin 内观测到的 $|\\delta_{\\mathbf{k}}|^2$ 在分位数水平 $q \\in \\{0.0, 0.25, 0.5, 0.75, 1.0\\}$ 处的经验分位数定义的 bin 边界，构建 $|\\delta_{\\mathbf{k}}|^2$ 的 $H = 4$ 格直方图。使用这些固定的 bin 边界来计算观测场和模拟场的归一化直方图计数（总和为 $1$），以使直方图可以直接比较。将全局相位均匀性摘要计算为平均合矢量长度 $R = \\left|\\frac{1}{M} \\sum_{m=1}^M e^{i \\phi_m}\\right|$，其中求和遍及所有 $M$ 个正 $k$ 模式，角度 $\\phi_m$ 以弧度为单位。\n\n3. 无似然推断 (LFI)：对于一个候选参数网格 $(A, n)$，其中 $A \\in \\{0.5, 0.8, 1.0, 1.2, 1.5\\}$ 且 $n \\in \\{-1.5, -1.0, -0.5, 0.0, 0.5\\}$，为每个候选参数模拟 $S = 16$ 个独立的合成场，并计算这 $S$ 次模拟的平均摘要矢量。将摘要矢量定义为所有 $B$ 个 $k$-bins 的归一化直方图计数的拼接，后跟全局相位平均合矢量长度 $R$。使用观测摘要与候选参数的平均模拟摘要之间的欧氏距离平方，并选择使该距离最小的 $(A, n)$。\n\n4. 精确高斯似然 (MLE)：使用独立复高斯系数的精确似然，在相同的参数网格上评估负对数似然（忽略一个与 $\\boldsymbol{\\theta}$ 无关的加性常数），\n$$\n\\mathcal{L}(A, n) = \\sum_{k  0} \\left( \\frac{|\\delta_{\\mathbf{k}}|^2}{P(k \\, ; \\, A, n)} + \\log P(k \\, ; \\, A, n) \\right),\n$$\n并选择使 $\\mathcal{L}(A, n)$ 最小的 $(A, n)$。\n\n5. 对于每个测试案例，报告两种方法恢复参数的绝对误差：$|A_{\\text{LFI}} - A_{\\text{true}}|$、 $|n_{\\text{LFI}} - n_{\\text{true}}|$、 $|A_{\\text{MLE}} - A_{\\text{true}}|$、 $|n_{\\text{MLE}} - n_{\\text{true}}|$。\n\n角度必须以弧度为单位。所有输出均为无量纲。您的程序必须实现上述过程，并为以下三个案例的测试套件生成结果：\n\n- 案例 1：$N = 32$， $A_{\\text{true}} = 1.0$， $n_{\\text{true}} = -1.0$， 种子 $= 12345$。\n- 案例 2：$N = 16$， $A_{\\text{true}} = 0.8$， $n_{\\text{true}} = 0.0$， 种子 $= 67890$。\n- 案例 3：$N = 24$， $A_{\\text{true}} = 1.2$， $n_{\\text{true}} = -1.5$， 种子 $= 24680$。\n\n对所有案例使用 $k_0 = 1.0$。对于 LFI 模拟步骤中的每个候选参数，使用从案例种子确定性派生的独立种子。由于所有量均为无量纲，因此不需要物理单位，角度必须以弧度为单位。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下\n$$\n[\\ |A_{\\text{LFI}}^{(1)} - A_{\\text{true}}^{(1)}|,\\ |n_{\\text{LFI}}^{(1)} - n_{\\text{true}}^{(1)}|,\\ |A_{\\text{MLE}}^{(1)} - A_{\\text{true}}^{(1)}|,\\ |n_{\\text{MLE}}^{(1)} - n_{\\text{true}}^{(1)}|,\\ |A_{\\text{LFI}}^{(2)} - A_{\\text{true}}^{(2)}|,\\ |n_{\\text{LFI}}^{(2)} - n_{\\text{true}}^{(2)}|,\\ |A_{\\text{MLE}}^{(2)} - A_{\\text{true}}^{(2)}|,\\ |n_{\\text{MLE}}^{(2)} - n_{\\text{true}}^{(2)}|,\\ |A_{\\text{LFI}}^{(3)} - A_{\\text{true}}^{(3)}|,\\ |n_{\\text{LFI}}^{(3)} - n_{\\text{true}}^{(3)}|,\\ |A_{\\text{MLE}}^{(3)} - A_{\\text{true}}^{(3)}|,\\ |n_{\\text{MLE}}^{(3)} - n_{\\text{true}}^{(3)}|\\ ].\n$$\n不应打印其他任何文本。", "solution": "用户问题已通过验证，被确定为一个表述清晰、科学合理且完整的请求。该任务是为一个模拟的二维高斯随机场比较两种参数估计方法——无似然推断 (LFI) 和最大似然估计 (MLE)。\n\n### 基于原理的设计\n\n解决方案将严格按照问题陈述中概述的协议实施。问题的核心围绕着傅里叶空间中复值、各向同性高斯随机场的统计特性。\n\n#### 1. 傅里叶空间表示与功率谱\n在实空间中统计均匀的随机场，在傅里叶空间中会变成一个由不相关随机变量组成的场。对于高斯场，这些傅里叶系数 $\\delta_{\\mathbf{k}}$ 是独立的复高斯随机变量。每个系数的方差由功率谱 $P(k)$ 决定，由于各向同性，功率谱仅依赖于波矢量的大小 $k = |\\mathbf{k}|$。\n\n问题给出了每个 $k  0$ 的独立系数 $\\delta_{\\mathbf{k}}$ 的概率密度：\n$$\np(\\delta_{\\mathbf{k}} \\mid A, n) = \\frac{1}{\\pi P(k \\, ; \\, A, n)} \\exp\\left(-\\frac{|\\delta_{\\mathbf{k}}|^2}{P(k \\, ; \\, A, n)}\\right)\n$$\n这是均值为零、方差为 $P(k)$ 的循环复正态分布的概率密度函数 (PDF)。这样的变量可以通过从实值正态分布 $\\mathcal{N}(0, P(k)/2)$ 中独立抽取其实部和虚部来构造。\n\n功率谱模型被给定为一个参数函数：\n$$\nP(k \\, ; \\, A, n) = A \\, \\left(k^2 + k_0^2\\right)^{n/2}\n$$\n其中 $A$ 是振幅，$n$ 是谱指数，$k_0=1.0$ 是一个固定的枢轴尺度。\n\n定义了一个大小为 $N \\times N$ 的二维网格。相应的离散波数使用 `numpy.fft.fftfreq` 函数计算，该函数提供离散傅里叶变换的频率。对于一个物理尺寸为 $L \\times L$ 的域，波数将是 $k_i = 2\\pi f_i = 2\\pi \\frac{n_i}{L}$，其中 $n_i$ 是整数。通过将名义上的周期性盒子尺寸设为 $N$，波数为 $k_i = 2\\pi \\frac{n_i}{N}$。我们使用 `numpy.fft.fftfreq(N, d=1.0)` 来获取频率 $n_i/N$，并乘以 $2\\pi$ 得到波数。然后计算出模 $k = \\sqrt{k_x^2 + k_y^2}$ 的网格。\n\n#### 2. 合成数据生成\n对于每个测试案例，通过从指定的分布中抽样傅里叶系数 $\\delta_{\\mathbf{k}}$ 来生成一个“观测”数据集，使用真实参数 $(A_{\\text{true}}, n_{\\text{true}})$ 和一个固定的随机种子以保证可复现性。对于每个 $k0$ 的模式，我们从 $\\mathcal{N}(0, P(k; A_{\\text{true}}, n_{\\text{true}})/2)$ 中抽样 $\\Re(\\delta_{\\mathbf{k}})$ 和 $\\Im(\\delta_{\\mathbf{k}})$。$k=0$ 处的模式（场均值）被设为零。\n\n#### 3. 最大似然估计 (MLE)\nMLE 方法利用了数据的精确已知概率分布。由于傅里叶系数是独立的，总对数似然是各个对数似然之和：\n$$\n\\log \\mathcal{L}_{\\text{total}}(A, n) = \\sum_{k0} \\log p(\\delta_{\\mathbf{k}} \\mid A, n) = \\sum_{k0} \\left( -\\log(\\pi) - \\log P(k \\, ; \\, A, n) - \\frac{|\\delta_{\\mathbf{k}}|^2}{P(k \\, ; \\, A, n)} \\right)\n$$\n为了找到最大似然估计，我们最小化负对数似然。忽略常数项 $\\sum \\log(\\pi)$，我们最小化问题陈述中提供的目标函数 $\\mathcal{L}(A, n)$：\n$$\n\\mathcal{L}(A, n) = \\sum_{k  0} \\left( \\frac{|\\delta_{\\mathbf{k}}|^2}{P(k \\, ; \\, A, n)} + \\log P(k \\, ; \\, A, n) \\right)\n$$\n该函数在一组候选参数 $(A, n)$ 网格上进行评估，产生 $\\mathcal{L}$ 最小值的参数对被选为 MLE 估计。由于此方法使用了数据的全部信息内容，预计其准确性会非常高。\n\n#### 4. 无似然推断 (LFI)\n当似然函数难以处理或未知时，可采用 LFI 方法，该方法依赖于比较观测数据与模拟数据的摘要统计量。设计中指定了两种类型的摘要统计量：\n\n- **功率直方图**：将平方模 $|\\delta_{\\mathbf{k}}|^2$ 按波数大小 $k$ 分入 $B=6$ 个等距的环形 bins 中。在每个环形 bin 内，计算 $|\\delta_{\\mathbf{k}}|^2$ 值的 $H=4$ 格直方图。一个关键细节是，给定环形 bin 的直方图 bin 边界是由该环形 bin 内*观测*到的 $|\\delta_{\\mathbf{k}}|^2$ 值的经验分位数 $\\{0, 0.25, 0.5, 0.75, 1.0\\}$ 定义的。然后将这些相同的边界用于所有模拟数据集，以确保可比性。直方图计数被归一化以使其总和为 $1$。该摘要统计量是功率谱的一种分箱和粗粒化的表示，是区分不同高斯模型的主要信息来源。\n- **相位均匀性**：在所有 $M$ 个 $k0$ 的模式上计算平均合矢量长度 $R = \\left|\\frac{1}{M} \\sum e^{i \\phi_{\\mathbf{k}}}\\right|$，其中 $\\phi_{\\mathbf{k}}$ 是 $\\delta_{\\mathbf{k}}$ 的相位。对于纯高斯随机场，相位 $\\phi_{\\mathbf{k}}$ 在 $[0, 2\\pi)$ 上均匀分布。因此，$R$ 的期望值接近于零。这个统计量是探测非高斯性的一个极佳工具，但对于区分不同的高斯模型（即不同的 $A$ 或 $n$）几乎没有区分能力，因为它们都共享相位均匀性这一属性。\n\n完整的摘要矢量是所有归一化直方图计数（$B \\times H = 24$ 个值）和单个相位均匀性值的拼接，形成一个 $25$ 维矢量。\n\nLFI 过程如下：\n1.  为观测数据计算摘要矢量 $S_{\\text{obs}}$。\n2.  对于网格上的每个候选参数对 $(A, n)$：\n    a. 生成 $S=16$ 个独立的模拟场。\n    b. 对于每次模拟，使用从观测数据导出的固定直方图 bin 边界计算其摘要矢量 $S_{\\text{sim}}$。\n    c. 将这 $S$ 个矢量平均，以获得该参数对的摘要的低方差估计 $\\bar{S}_{\\text{sim}}(A, n)$。\n3.  为每个候选参数计算欧氏距离平方 $d^2 = ||S_{\\text{obs}} - \\bar{S}_{\\text{sim}}(A, n)||^2$。\n4.  LFI 估计是使此距离最小化的 $(A, n)$ 对。\n\n#### 5. 比较\n最后，计算 LFI 和 MLE 方法得到的估计参数与已知的真实参数之间的绝对误差，并按规定报告每个测试案例的结果。这允许对数据压缩的 LFI 方法与理论上最优的 MLE 方法的性能进行定量比较。", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Implements the LFI vs MLE comparison for Gaussian random field parameter estimation.\n    \"\"\"\n\n    def power_spectrum(k, A, n, k0):\n        \"\"\"\n        Calculates the parametric power spectrum P(k; A, n).\n        P(k; A, n) = A * (k^2 + k_0^2)^(n/2)\n        \"\"\"\n        # The term k^2 + k0^2 is always positive since k0=1.0.\n        return A * (k**2 + k0**2)**(n / 2.0)\n\n    def generate_field(N, A, n, k0, seed, k_grid):\n        \"\"\"\n        Generates a 2D complex Gaussian random field in Fourier space.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        \n        P_k = power_spectrum(k_grid, A, n, k0)\n        \n        # Variance of real/imaginary parts is P(k)/2.\n        sigma_k = np.sqrt(P_k / 2.0)\n        \n        real_part = rng.normal(loc=0.0, scale=sigma_k)\n        imag_part = rng.normal(loc=0.0, scale=sigma_k)\n        \n        delta_k = real_part + 1j * imag_part\n        \n        # Set the k=0 mode (DC component) to zero as it's not part of the analysis.\n        delta_k[k_grid == 0] = 0.0\n        \n        return delta_k\n\n    def calculate_summaries(delta_k, k_grid, k_bin_edges, B, H, hist_bin_edges_list=None):\n        \"\"\"\n        Calculates the summary vector (histograms + phase uniformity).\n        If hist_bin_edges_list is None, it computes them from the data (for observed data).\n        Otherwise, it uses the provided edges (for simulated data).\n        \"\"\"\n        pos_k_mask = k_grid > 0\n        k_pos = k_grid[pos_k_mask]\n        delta_k_pos = delta_k[pos_k_mask]\n        \n        # 1. Global phase uniformity (mean resultant length)\n        phases = np.angle(delta_k_pos)\n        R = np.abs(np.mean(np.exp(1j * phases)))\n        \n        # 2. Histograms of |delta_k|^2\n        d2_pos = np.abs(delta_k_pos)**2\n        \n        is_obs_data = hist_bin_edges_list is None\n        if is_obs_data:\n            hist_bin_edges_list = []\n        \n        all_hist_counts = []\n        \n        for i in range(B):\n            k_min, k_max = k_bin_edges[i], k_bin_edges[i+1]\n            bin_mask = (k_pos >= k_min)  (k_pos = k_max) if i == B - 1 else (k_pos >= k_min)  (k_pos  k_max)\n            \n            d2_in_bin = d2_pos[bin_mask]\n            \n            if len(d2_in_bin) == 0:\n                all_hist_counts.append(np.zeros(H))\n                if is_obs_data:\n                    hist_bin_edges_list.append(np.linspace(0, 1, H + 1))\n                continue\n\n            current_hist_edges = None\n            if is_obs_data:\n                q_levels = np.linspace(0.0, 1.0, H + 1)\n                current_hist_edges = np.quantile(d2_in_bin, q_levels)\n                # Ensure bin edges are unique for np.histogram\n                if len(np.unique(current_hist_edges))  len(current_hist_edges):\n                    for j in range(1, len(current_hist_edges)):\n                        if current_hist_edges[j] = current_hist_edges[j-1]:\n                            current_hist_edges[j] = current_hist_edges[j-1] + 1e-9 # Add small fuzz\n                hist_bin_edges_list.append(current_hist_edges)\n            else:\n                current_hist_edges = hist_bin_edges_list[i]\n            \n            counts, _ = np.histogram(d2_in_bin, bins=current_hist_edges)\n            total_counts = counts.sum()\n            normalized_counts = counts / total_counts if total_counts > 0 else np.zeros(H)\n            all_hist_counts.append(normalized_counts)\n            \n        summary_vector = np.concatenate(all_hist_counts + [np.array([R])])\n        \n        return (summary_vector, hist_bin_edges_list) if is_obs_data else summary_vector\n\n    # Define test cases from the problem statement\n    test_cases = [\n        {'N': 32, 'A_true': 1.0, 'n_true': -1.0, 'seed': 12345},\n        {'N': 16, 'A_true': 0.8, 'n_true': 0.0, 'seed': 67890},\n        {'N': 24, 'A_true': 1.2, 'n_true': -1.5, 'seed': 24680},\n    ]\n\n    # Global parameters\n    k0 = 1.0\n    B = 6\n    H = 4\n    S = 16\n    A_grid = np.array([0.5, 0.8, 1.0, 1.2, 1.5])\n    n_grid = np.array([-1.5, -1.0, -0.5, 0.0, 0.5])\n    param_grid = list(itertools.product(A_grid, n_grid))\n    \n    results = []\n    \n    for case in test_cases:\n        N, A_true, n_true, seed_main = case['N'], case['A_true'], case['n_true'], case['seed']\n        \n        k_freq = 2 * np.pi * np.fft.fftfreq(N)\n        kx_grid, ky_grid = np.meshgrid(k_freq, k_freq, indexing='ij')\n        k_grid = np.sqrt(kx_grid**2 + ky_grid**2)\n        \n        delta_k_obs = generate_field(N, A_true, n_true, k0, seed_main, k_grid)\n        \n        pos_k_mask = k_grid > 0\n        k_pos = k_grid[pos_k_mask]\n        k_bin_edges = np.linspace(k_pos.min(), k_pos.max(), B + 1)\n        \n        summary_obs, hist_bin_edges_obs = calculate_summaries(delta_k_obs, k_grid, k_bin_edges, B, H)\n        \n        min_dist_sq_lfi = np.inf\n        best_params_lfi = None\n        \n        for i, (A_cand, n_cand) in enumerate(param_grid):\n            sim_summaries = []\n            for s in range(S):\n                sim_seed = seed_main + 1000 * (i + 1) + s\n                delta_k_sim = generate_field(N, A_cand, n_cand, k0, sim_seed, k_grid)\n                summary_sim = calculate_summaries(delta_k_sim, k_grid, k_bin_edges, B, H, hist_bin_edges_list=hist_bin_edges_obs)\n                sim_summaries.append(summary_sim)\n            \n            avg_summary_sim = np.mean(sim_summaries, axis=0)\n            dist_sq = np.sum((summary_obs - avg_summary_sim)**2)\n            \n            if dist_sq  min_dist_sq_lfi:\n                min_dist_sq_lfi = dist_sq\n                best_params_lfi = (A_cand, n_cand)\n                \n        A_lfi, n_lfi = best_params_lfi\n\n        min_neg_log_L_mle = np.inf\n        best_params_mle = None\n        \n        d2_obs_pos = np.abs(delta_k_obs[pos_k_mask])**2\n        \n        for A_cand, n_cand in param_grid:\n            P_k_cand = power_spectrum(k_pos, A_cand, n_cand, k0)\n            if np.any(P_k_cand = 0):\n                neg_log_L = np.inf\n            else:\n                neg_log_L = np.sum(d2_obs_pos / P_k_cand + np.log(P_k_cand))\n            \n            if neg_log_L  min_neg_log_L_mle:\n                min_neg_log_L_mle = neg_log_L\n                best_params_mle = (A_cand, n_cand)\n        \n        A_mle, n_mle = best_params_mle\n        \n        results.extend([\n            abs(A_lfi - A_true),\n            abs(n_lfi - n_true),\n            abs(A_mle - A_true),\n            abs(n_mle - n_true)\n        ])\n\n    print(f\"[{','.join(f'{x:.4f}' for x in results)}]\")\n\nsolve()\n```", "id": "3490786"}]}