{"hands_on_practices": [{"introduction": "引力坍缩和“壳穿越”标志着宇宙结构形成中非线性阶段的开始。本练习旨在通过一个解析问题，对比研究两种情况下的动力学：无压的“尘埃”模型和具有初始速度弥散的“温”模型。这个练习有助于直观理解金斯不稳定性以及热压力如何抵抗引力，这是结构形成中的一个核心概念。通过推导线性增长因子和计算壳穿越时间，您可以亲身体会到速度弥散是如何延迟引力坍缩的 [@problem_id:3500416]。", "problem": "考虑一个在一维 (1D) 静态牛顿背景下的无碰撞自引力介质，其平均质量密度为均匀的 $\\,\\rho_{0}\\,$。其相空间动力学由 Vlasov-Poisson (VP) 方程组控制，分布函数 $\\,f(x,v,t)\\,$ 满足 $\\,\\partial_{t} f + v\\,\\partial_{x} f - \\partial_{x} \\phi\\,\\partial_{v} f = 0\\,$，引力势 $\\,\\phi(x,t)\\,$ 由 $\\,\\partial_{x}^{2}\\phi = 4\\pi G\\left(\\int f\\,\\mathrm{d}v - \\rho_{0}\\right)\\,$ 确定，其中 $\\,G\\,$ 是牛顿引力常数。假设系统在 $\\,t=0\\,$ 时处于一个近冷态，具有标准差为 $\\,\\sigma_{v}\\,$ 的窄麦克斯韦速度弥散，以及一个单模正弦拉格朗日位移\n$$\ns(q) \\equiv -\\frac{A}{k}\\,\\sin(k q),\n$$\n对于拉格朗日坐标 $\\,q\\,$，其振幅 $\\,A \\in (0,1)\\,$ 且波数 $\\,k>0\\,$。欧拉位置映射为 $\\,x(q,t) = q + D(t)\\,s(q)\\,$，其中 $\\,D(t)\\,$ 是该模式的位移增长因子。最早的“壳层穿越”定义为拉格朗日到欧拉的雅可比行列式\n$$\nJ(q,t) \\equiv \\frac{\\partial x}{\\partial q} = 1 + D(t)\\,s'(q)\n$$\n在 $\\,q\\,$ 的某个点首次为零的时间 $\\,t>0\\,$。\n\n您将对两种动力学进行建模和比较：\n\n- 尘埃模型（速度弥散为零），通过采用单动能分布 $\\,f(x,v,t) = \\rho(x,t)\\,\\delta\\!\\left(v-u(x,t)\\right)\\,$ 得到，这会产生无压流体矩系统。围绕 $\\,\\rho=\\rho_{0}\\,$ 和 $\\,u=0\\,$ 对其动力学进行线性化，并在波数为 $\\,k\\,$ 的单个傅里叶模式的位移增长因子 $\\,D(t)\\,$ 的层面上进行研究。施加物理种子初始条件 $\\,D(0)=0\\,$ 和 $\\,\\dot{D}(0)=1\\,$。\n\n- 有限弥散的 Vlasov 估计，通过用等效各向同性压力 $\\,P=\\rho\\,\\sigma_{v}^{2}\\,$（常数 $\\,\\sigma_{v}\\,$）在二阶闭合流体矩得到，并围绕 $\\,\\rho=\\rho_{0}\\,$ 和 $\\,u=0\\,$ 进行线性化。再次在相同的初始条件 $\\,D_{\\sigma}(0)=0\\,$ 和 $\\,\\dot{D}_{\\sigma}(0)=1\\,$ 下，对单模位移增长因子 $\\,D_{\\sigma}(t)\\,$ 进行研究。假设处于亚金斯区 $\\sigma_{v}^{2} k^{2}  4\\pi G \\rho_{0}$，从而发生增长。\n\n仅从 VP 方程组、Poisson 方程和流体矩定义出发，推导 $\\,D(t)\\,$ 和 $\\,D_{\\sigma}(t)\\,$ 的线性演化方程。使用这些方程获得由最早的 $\\,t>0\\,$ 满足 $\\,\\min_{q} J(q,t)=0\\,$ 定义的壳层穿越时间 $\\,t_{\\mathrm{sc}}^{\\mathrm{dust}}\\,$ 和 $\\,t_{\\mathrm{sc}}^{\\sigma}\\,$。然后，给出比率的精确闭式解析表达式\n$$\nR \\equiv \\frac{t_{\\mathrm{sc}}^{\\sigma}}{t_{\\mathrm{sc}}^{\\mathrm{dust}}}\n$$\n用 $\\,G\\,$, $\\,\\rho_{0}\\,$, $\\,\\sigma_{v}\\,$, $\\,k\\,$ 和 $\\,A\\,$ 表示。不代入任何数值。将您的最终答案表示为单个解析表达式；由于 $\\,R\\,$ 是无量纲的，因此不需要单位。", "solution": "首先验证了该问题，发现其是良定的且在科学上是合理的，可以进行完整求解。推导过程首先从 Vlasov-Poisson 方程组建立流体矩方程，然后针对所要求的两种模型（尘埃模型和有限弥散模型）进行特化和线性化。推导出各自的增长因子演化方程并求解，从而得到壳层穿越时间，最后得出它们的比率。\n\n相空间动力学由 Vlasov-Poisson 方程组控制：\n$$\n\\partial_{t} f + v\\,\\partial_{x} f - (\\partial_{x} \\phi)\\,\\partial_{v} f = 0\n$$\n$$\n\\partial_{x}^{2}\\phi = 4\\pi G\\left(\\int f\\,\\mathrm{d}v - \\rho_{0}\\right)\n$$\n我们定义流体矩：质量密度 $\\rho(x,t) = \\int f(x,v,t)\\,\\mathrm{d}v$ 和体速度 $u(x,t) = \\frac{1}{\\rho}\\int v f(x,v,t)\\,\\mathrm{d}v$。\n\n假设当 $|v| \\to \\infty$ 时 $f \\to 0$，对 Vlasov 方程在所有速度 $v$ 上积分，得到连续性方程：\n$$\n\\partial_{t} \\rho + \\partial_{x}(\\rho u) = 0\n$$\n将 Vlasov 方程乘以 $v$ 并积分，得到动量（Euler-Jeans）方程：\n$$\n\\partial_t (\\rho u) + \\partial_x (\\rho \\langle v^2 \\rangle) + \\rho \\partial_x \\phi = 0\n$$\n其中 $\\langle v^2 \\rangle = \\frac{1}{\\rho}\\int v^2 f\\,\\mathrm{d}v$。我们定义速度弥散的平方为 $\\sigma_v^2 = \\langle(v-u)^2\\rangle = \\langle v^2 \\rangle - u^2$。压力定义为 $P = \\rho \\sigma_v^2$。动量方程可以写成：\n$$\n\\rho(\\partial_t u + u \\partial_x u) = -\\partial_x P - \\rho \\partial_x \\phi\n$$\n\n壳层穿越的分析始于拉格朗日到欧拉映射的雅可比行列式，$J(q,t) = \\frac{\\partial x}{\\partial q}$。给定 $x(q,t) = q + D(t)s(q)$ 和 $s(q) = -\\frac{A}{k}\\sin(kq)$，雅可比行列式为：\n$$\nJ(q,t) = 1 + D(t)s'(q) = 1 - A D(t) \\cos(kq)\n$$\n壳层穿越发生在某个 $q$ 使得 $J(q,t)=0$ 的第一个时间 $t > 0$。当第二项为最大负值时，即在 $\\cos(kq) = 1$ 的位置 $q$ 处，该条件首先被满足。因此，壳层穿越的条件是：\n$$\n1 - A D(t_{\\mathrm{sc}}) = 0 \\implies D(t_{\\mathrm{sc}}) = \\frac{1}{A}\n$$\n这个条件对两种模型都是相同的；只有 $D(t)$ 的函数形式会有所不同。\n\n**1. 尘埃模型（$\\sigma_v = 0$）**\n在尘埃模型中，速度弥散为零，因此压力 $P=0$。关于静态背景（$\\rho_0, u=0$）的扰动 $\\delta\\rho = \\rho - \\rho_0$，$u_1=u$ 和 $\\phi_1=\\phi$ 的线性化流体方程为：\n1. 连续性方程：$\\partial_t \\delta\\rho + \\rho_0 \\partial_x u_1 = 0$\n2. 欧拉方程：$\\rho_0 \\partial_t u_1 = -\\rho_0 \\partial_x \\phi_1$\n3. Poisson 方程：$\\partial_x^2 \\phi_1 = 4\\pi G \\delta\\rho$\n\n结合这些方程，我们对 (1) 取时间导数，对 (2) 取空间导数：\n$$\n\\partial_t^2 \\delta\\rho + \\rho_0 \\partial_x \\partial_t u_1 = 0\n$$\n$$\n\\partial_x \\partial_t u_1 = -\\partial_x^2 \\phi_1\n$$\n将 (3) 代入第二个方程得到 $\\partial_x \\partial_t u_1 = -4\\pi G \\delta\\rho$。将此结果代回第一个方程得到：\n$$\n\\partial_t^2 \\delta\\rho_1 - 4\\pi G \\rho_0 \\delta\\rho_1 = 0\n$$\n密度扰动与位移增长因子 $D(t)$ 相关。根据质量守恒，$\\rho_0 \\mathrm{d}q = \\rho(x,t) \\mathrm{d}x$，因此 $\\rho = \\rho_0 J^{-1} = \\rho_0 (1 - A D(t) \\cos(kq))^{-1}$。在一阶线性近似下，$\\delta\\rho = \\rho-\\rho_0 \\approx \\rho_0 A D(t) \\cos(kq)$。由于 $\\delta\\rho$ 与 $D(t)$ 成正比，$D(t)$ 的单个模式也必须满足相同的微分方程。\n设 $\\omega_J^2 = 4\\pi G \\rho_0$。增长因子 $D(t)$ 的演化方程为：\n$$\n\\ddot{D}(t) - \\omega_J^2 D(t) = 0\n$$\n通解为 $D(t) = c_1 \\cosh(\\omega_J t) + c_2 \\sinh(\\omega_J t)$。应用初始条件 $D(0)=0$ 和 $\\dot D(0)=1$：\n$D(0) = c_1 = 0$。\n$\\dot D(t) = c_2 \\omega_J \\cosh(\\omega_J t) \\implies \\dot D(0) = c_2 \\omega_J = 1 \\implies c_2 = 1/\\omega_J$。\n因此，对于尘埃模型，增长因子为：\n$$\nD(t) = \\frac{1}{\\omega_J} \\sinh(\\omega_J t)\n$$\n壳层穿越时间 $t_{\\mathrm{sc}}^{\\mathrm{dust}}$ 可通过求解 $D(t_{\\mathrm{sc}}^{\\mathrm{dust}}) = 1/A$ 找到：\n$$\n\\frac{1}{\\omega_J} \\sinh(\\omega_J t_{\\mathrm{sc}}^{\\mathrm{dust}}) = \\frac{1}{A} \\implies t_{\\mathrm{sc}}^{\\mathrm{dust}} = \\frac{1}{\\omega_J} \\text{arcsinh}\\left(\\frac{\\omega_J}{A}\\right)\n$$\n\n**2. 有限弥散模型（$P = \\rho \\sigma_v^2$）**\n对于此模型，压力项不为零。线性化的压力扰动为 $P_1 = \\delta\\rho \\sigma_v^2$。线性化的欧拉方程变为：\n$$\n\\rho_0 \\partial_t u_1 = -\\partial_x P_1 - \\rho_0\\partial_x \\phi_1 = -\\sigma_v^2 \\partial_x \\delta\\rho - \\rho_0 \\partial_x \\phi_1\n$$\n按照与之前相同的步骤，我们将其与线性化的连续性方程和 Poisson 方程结合：\n$$\n\\partial_t^2 \\delta\\rho + \\rho_0 \\partial_x \\partial_t u_1 = \\partial_t^2 \\delta\\rho + \\partial_x ( -\\sigma_v^2 \\partial_x \\delta\\rho - \\rho_0 \\partial_x \\phi_1) = 0\n$$\n$$\n\\partial_t^2 \\delta\\rho - \\sigma_v^2 \\partial_x^2 \\delta\\rho - \\rho_0 \\partial_x^2 \\phi_1 = 0\n$$\n使用 Poisson 方程 $\\partial_x^2 \\phi_1 = 4\\pi G \\delta\\rho$，我们得到：\n$$\n\\partial_t^2 \\delta\\rho - \\sigma_v^2 \\partial_x^2 \\delta\\rho - 4\\pi G \\rho_0 \\delta\\rho = 0\n$$\n我们考虑一个波数为 $k$ 的单个傅里叶模式，因此 $\\delta\\rho \\propto \\cos(kx)$ 或 $\\exp(ikx)$，对于该模式有 $\\partial_x^2 \\delta\\rho_k = -k^2 \\delta\\rho_k$。模式振幅的方程变为：\n$$\n\\ddot{\\delta\\rho_k} - \\sigma_v^2 (-k^2) \\delta\\rho_k - 4\\pi G \\rho_0 \\delta\\rho_k = 0 \\implies \\ddot{\\delta\\rho_k} - (4\\pi G \\rho_0 - \\sigma_v^2 k^2) \\delta\\rho_k = 0\n$$\n由于 $\\delta\\rho_k$ 与 $D_\\sigma(t)$ 成正比，增长因子 $D_\\sigma(t)$ 服从相同的方程。我们定义 $\\omega_{\\sigma}^2 = 4\\pi G \\rho_0 - \\sigma_v^2 k^2 = \\omega_J^2 - \\sigma_v^2 k^2$。问题假设处于亚金斯区，$\\sigma_v^2 k^2  4\\pi G \\rho_0$，这确保了 $\\omega_{\\sigma}^2 > 0$ 并因此导致引力不稳定性。演化方程为：\n$$\n\\ddot{D}_{\\sigma}(t) - \\omega_{\\sigma}^2 D_{\\sigma}(t) = 0\n$$\n此方程与尘埃模型的方程形式相同，只是将 $\\omega_J$ 替换为 $\\omega_{\\sigma}$。使用相同的初始条件，$D_{\\sigma}(0)=0$ 和 $\\dot{D}_{\\sigma}(0)=1$，解为：\n$$\nD_{\\sigma}(t) = \\frac{1}{\\omega_{\\sigma}} \\sinh(\\omega_{\\sigma} t)\n$$\n壳层穿越时间 $t_{\\mathrm{sc}}^{\\sigma}$ 可通过求解 $D_{\\sigma}(t_{\\mathrm{sc}}^{\\sigma}) = 1/A$ 找到：\n$$\n\\frac{1}{\\omega_{\\sigma}} \\sinh(\\omega_{\\sigma} t_{\\mathrm{sc}}^{\\sigma}) = \\frac{1}{A} \\implies t_{\\mathrm{sc}}^{\\sigma} = \\frac{1}{\\omega_{\\sigma}} \\text{arcsinh}\\left(\\frac{\\omega_{\\sigma}}{A}\\right)\n$$\n\n**3. 壳层穿越时间的比率**\n比率 $R$ 定义为 $R \\equiv t_{\\mathrm{sc}}^{\\sigma} / t_{\\mathrm{sc}}^{\\mathrm{dust}}$。代入我们推导出的表达式：\n$$\nR = \\frac{\\frac{1}{\\omega_{\\sigma}} \\text{arcsinh}\\left(\\frac{\\omega_{\\sigma}}{A}\\right)}{\\frac{1}{\\omega_J} \\text{arcsinh}\\left(\\frac{\\omega_J}{A}\\right)} = \\frac{\\omega_J}{\\omega_{\\sigma}} \\frac{\\text{arcsinh}\\left(\\frac{\\omega_{\\sigma}}{A}\\right)}{\\text{arcsinh}\\left(\\frac{\\omega_J}{A}\\right)}\n$$\n代入定义 $\\omega_J = \\sqrt{4\\pi G \\rho_0}$ 和 $\\omega_{\\sigma} = \\sqrt{4\\pi G \\rho_0 - \\sigma_v^2 k^2}$：\n$$\nR = \\frac{\\sqrt{4\\pi G \\rho_0}}{\\sqrt{4\\pi G \\rho_0 - \\sigma_v^2 k^2}} \\frac{\\text{arcsinh}\\left(\\frac{\\sqrt{4\\pi G \\rho_0 - \\sigma_v^2 k^2}}{A}\\right)}{\\text{arcsinh}\\left(\\frac{\\sqrt{4\\pi G \\rho_0}}{A}\\right)}\n$$\n这是以给定参数表示的比率的最终闭式表达式。速度弥散起到压力的作用，减缓了引力坍缩，从而导致更长的壳层穿越时间（$R>1$）。", "answer": "$$\\boxed{\\frac{\\sqrt{4\\pi G \\rho_{0}}}{\\sqrt{4\\pi G \\rho_{0} - \\sigma_{v}^{2} k^{2}}} \\frac{\\operatorname{arcsinh}\\left(\\frac{\\sqrt{4\\pi G \\rho_{0} - \\sigma_{v}^{2} k^{2}}}{A}\\right)}{\\operatorname{arcsinh}\\left(\\frac{\\sqrt{4\\pi G \\rho_{0}}}{A}\\right)}}$$", "id": "3500416"}, {"introduction": "从解析研究转向数值计算，求解弗拉索夫方程本质上是一个相空间中的平流问题。本练习通过使用一个固定的外部势（谐振子），将弗拉索夫方程的平流部分独立出来进行研究。这是构建自洽的弗拉索夫-泊松数值模拟至关重要的第一步。它介绍了半拉格朗日方法这一常用技术，并通过与精确解比较和测量误差范数，强调了验证代码正确性的重要性 [@problem_id:3500344]。这个“旋转高斯分布”问题是检验弗拉索夫求解器性能的一个标准基准。", "problem": "考虑在数值宇宙学背景下，无碰撞物质在一维固定外加引力势下的 Vlasov 方程。分布函数 $f(x,v,t)$ 根据 Vlasov 方程演化\n$$\n\\partial_t f + v\\,\\partial_x f - \\left(\\partial_x \\phi(x)\\right)\\,\\partial_v f = 0,\n$$\n其中 $x$ 是位置，$v$ 是速度，$t$ 是时间。对于此问题，使用谐波外势\n$$\n\\phi(x) = \\tfrac{1}{2}\\,\\omega^2\\,x^2,\n$$\n其频率 $\\omega$ 为常数。定义域为矩形相空间盒子 $x \\in [-L,L]$ 和 $v \\in [-V,V]$，其中 $L = V = 6.0$ 是无量纲的，所有角度必须以弧度处理和报告。初始条件是一个中心化的、可分解的高斯分布\n$$\nf_0(x,v) = A \\exp\\!\\left(-\\frac{x^2}{2\\sigma_x^2} - \\frac{v^2}{2\\sigma_v^2}\\right),\n$$\n其中 $A = 1$，$\\sigma_x = 0.5$，$\\sigma_v = 0.5$。\n\n任务：\n- 从 Vlasov 方程和给定的势，推导 $(x(t),v(t))$ 的特征系统，并推断出 $(x(t),v(t))$ 关于 $(x(0),v(0))$ 和 $\\omega$ 的精确参数化演化。然后，从第一性原理出发，推导如何在时间 $t$ 的精确解 $f(x,v,t)$ 如何从 $f_0$ 获得。\n- 在 $(x,v)$ 的均匀笛卡尔网格上，使用双线性插值实现一个半拉格朗日平流格式。在每个时间步中，使用单个时间增量上的精确后向特征线，将到达点 $(x,v)$ 映射到出发点 $(x_0,v_0)$，并通过对前一时间层进行双线性插值来获得平流值。将盒子 $[-L,L]\\times[-V,V]$ 之外的值视为零。所有量都是无量纲的。\n- 在指定的最终时间 $t_{\\mathrm{final}}$，在同一网格上计算数值解 $f_{\\mathrm{num}}(x_i,v_j,t_{\\mathrm{final}})$ 和精确解 $f_{\\mathrm{exact}}(x_i,v_j,t_{\\mathrm{final}})$，并评估以下离散误差范数：\n$$\n\\|e\\|_{1} \\equiv \\sum_{i,j} \\left| f_{\\mathrm{num}}(x_i,v_j,t_{\\mathrm{final}}) - f_{\\mathrm{exact}}(x_i,v_j,t_{\\mathrm{final}}) \\right|\\,\\Delta x\\,\\Delta v,\\quad\n\\|e\\|_{2} \\equiv \\left(\\sum_{i,j} \\left| f_{\\mathrm{num}}(x_i,v_j,t_{\\mathrm{final}}) - f_{\\mathrm{exact}}(x_i,v_j,t_{\\mathrm{final}}) \\right|^2\\,\\Delta x\\,\\Delta v\\right)^{1/2},\n$$\n其中 $\\Delta x$ 和 $\\Delta v$ 是均匀的网格间距。报告这些误差，以评估在网格加密下观察到的精度阶。\n\n所有测试使用以下固定参数：\n- $\\omega = 1.0$,\n- $L = 6.0$, $V = 6.0$,\n- $t_{\\mathrm{final}} = 1.234$ (无量纲时间单位，在数值上等于演化的相位角，以弧度计),\n- $A = 1.0$, $\\sigma_x = 0.5$, $\\sigma_v = 0.5$.\n\n测试组：\n- 案例 1：$N_x = 32$, $N_v = 32$, $N_t = 32$。\n- 案例 2：$N_x = 64$, $N_v = 64$, $N_t = 64$。\n- 案例 3：$N_x = 128$, $N_v = 128$, $N_t = 128$。\n- 案例 4 (时间步较大的边缘案例)：$N_x = 64$, $N_v = 64$, $N_t = 8$。\n\n在每个案例中，使用 $N_t$ 个大小为 $\\Delta t = t_{\\mathrm{final}}/N_t$ 的均匀步长，从 $t=0$ 推进到 $t_{\\mathrm{final}}$。对每个案例，计算如上定义的 $\\|e\\|_{1}$ 和 $\\|e\\|_{2}$。\n\n你的程序应产生单行输出，其中包含所有四个案例的结果，形式为一个由方括号括起来的逗号分隔的配对列表，其中每对包含一个案例的两个误差范数 $\\left[\\|e\\|_{1},\\|e\\|_{2}\\right]$，并且每个浮点数必须以六位有效数字的科学记数法打印。例如，输出必须如下所示：\n$$\n\\left[\\left[1.234000\\mathrm{e}{-3},5.678000\\mathrm{e}{-4}\\right],\\left[\\dots,\\dots\\right],\\left[\\dots,\\dots\\right],\\left[\\dots,\\dots\\right]\\right].\n$$", "solution": "该问题要求解在固定外部谐波势下无碰撞系统的一维 Vlasov 方程的数值解，并将此数值解与精确的解析解进行比较。\n\n### 第 1 部分：问题验证\n该问题定义明确、有科学依据且自洽。它为 Vlasov 方程的数值求解器提供了一个标准的测试案例。\n- **给定条件**：Vlasov 方程 $\\partial_t f + v\\,\\partial_x f - \\left(\\partial_x \\phi(x)\\right)\\,\\partial_v f = 0$、势 $\\phi(x) = \\tfrac{1}{2}\\,\\omega^2\\,x^2$、初始条件 $f_0(x,v) = A \\exp\\!\\left(-\\frac{x^2}{2\\sigma_x^2} - \\frac{v^2}{2\\sigma_v^2}\\right)$ 以及所有必要的参数（$L=6.0$、$V=6.0$、$\\omega=1.0$、$t_{\\mathrm{final}}=1.234$、$A=1.0$、$\\sigma_x=0.5$、$\\sigma_v=0.5$）均已指定。数值方法（带双线性插值的半拉格朗日法）和误差度量（$\\|e\\|_1$、$\\|e\\|_2$）被明确定义。测试案例被清晰列出。\n- **结论**：问题有效。未检测到与科学合理性、完整性或清晰度相关的缺陷。\n\n### 第 2 部分：理论推导\n\n#### 特征方程\nVlasov 方程指出，分布函数 $f(x,v,t)$ 沿着相空间中粒子的轨迹是恒定的。这些被称为特征线的轨迹由 Hamilton 运动方程决定：\n$$\n\\frac{dx}{dt} = \\frac{\\partial H}{\\partial p} \\quad \\text{和} \\quad \\frac{dp}{dt} = -\\frac{\\partial H}{\\partial x}\n$$\n对于非相对论性物质，动量为 $p=mv$，哈密顿量为 $H(x,p) = \\frac{p^2}{2m} + m\\phi(x)$。在我们的无量纲单位中，可以设质量 $m=1$，因此 $p=v$ 且 $H(x,v) = \\frac{1}{2}v^2 + \\phi(x)$。特征方程为：\n$$\n\\frac{dx}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = -\\frac{\\partial \\phi}{\\partial x}\n$$\n给定外势 $\\phi(x) = \\frac{1}{2}\\omega^2 x^2$，力项为 $-\\frac{\\partial \\phi}{\\partial x} = -\\omega^2 x$。特征线的常微分方程组 (ODEs) 变为：\n$$\n\\frac{dx}{dt} = v, \\quad \\frac{dv}{dt} = -\\omega^2 x\n$$\n这是我们熟悉的简谐振子系统。\n\n#### 特征线的精确演化\n为求解该系统，我们可以对第一个方程关于时间 $t$ 求导，并代入第二个方程：\n$$\n\\frac{d^2x}{dt^2} = \\frac{dv}{dt} = -\\omega^2 x \\implies \\frac{d^2x}{dt^2} + \\omega^2 x = 0\n$$\n$x(t)$ 的通解为 $x(t) = C_1 \\cos(\\omega t) + C_2 \\sin(\\omega t)$。速度则为 $v(t) = \\frac{dx}{dt} = -\\omega C_1 \\sin(\\omega t) + \\omega C_2 \\cos(\\omega t)$。我们使用 $t=0$ 时的初始条件 $(x(0), v(0)) = (x_0, v_0)$ 来确定常数 $C_1$ 和 $C_2$。\n- $x(0) = C_1 \\cos(0) + C_2 \\sin(0) = C_1 \\implies C_1=x_0$。\n- $v(0) = -\\omega C_1 \\sin(0) + \\omega C_2 \\cos(0) = \\omega C_2 \\implies C_2=v_0/\\omega$。\n\n将这些常数代回，得到相空间点（前向特征线）的参数化演化：\n$$\nx(t) = x_0 \\cos(\\omega t) + \\frac{v_0}{\\omega} \\sin(\\omega t)\n$$\n$$\nv(t) = -\\omega x_0 \\sin(\\omega t) + v_0 \\cos(\\omega t)\n$$\n\n#### 精确解 $f(x,v,t)$\nVlasov 方程所体现的 Liouville 定理指出，$f$ 沿着特征线是守恒的：$f(x(t), v(t), t) = f(x_0, v_0, 0) = f_0(x_0, v_0)$。为了找到在任意点 $(x,v)$ 和时间 $t$ 的解 $f(x,v,t)$，我们必须找到在时间 $t$ 内演化到 $(x,v)$ 的初始相空间坐标 $(x_0, v_0)$。这需要反演演化方程，等价于沿时间向后演化 $t$。我们在前向演化方程中用 $-t$ 替换 $t$：\n$$\nx_0(x,v,t) = x \\cos(-\\omega t) + \\frac{v}{\\omega} \\sin(-\\omega t) = x \\cos(\\omega t) - \\frac{v}{\\omega} \\sin(\\omega t)\n$$\n$$\nv_0(x,v,t) = -\\omega x \\sin(-\\omega t) + v \\cos(-\\omega t) = \\omega x \\sin(\\omega t) + v \\cos(\\omega t)\n$$\n时间 $t$ 的精确解通过将 $(x_0, v_0)$ 的这些表达式代入初始分布 $f_0$ 得到：\n$$\nf_{\\mathrm{exact}}(x, v, t) = f_0(x_0(x,v,t), v_0(x,v,t)) = A \\exp\\left(-\\frac{\\left(x \\cos(\\omega t) - \\frac{v}{\\omega} \\sin(\\omega t)\\right)^2}{2\\sigma_x^2} - \\frac{\\left(\\omega x \\sin(\\omega t) + v \\cos(\\omega t)\\right)^2}{2\\sigma_v^2}\\right)\n$$\n此公式允许在任意点 $(x,v)$ 和时间 $t_{\\mathrm{final}}$ 直接计算精确解。\n\n### 第 3 部分：数值实现\n\n数值方法的核心是半拉格朗日平流格式。其目标是在给定时间 $t_n$ 的值 $f^n$ 的情况下，计算在时间 $t_{n+1} = t_n + \\Delta t$ 均匀网格上的分布函数值 $f^{n+1}$。\n\n1.  **网格设置**：在相空间域 $[-L,L]\\times[-V,V]$ 上定义一个均匀的笛卡尔网格。该网格包含 $N_x \\times N_v$ 个点。网格坐标为 $(x_i, v_j)$，其中 $x_i = -L + i \\cdot \\Delta x$ 对于 $i \\in \\{0, \\dots, N_x-1\\}$，$v_j = -V + j \\cdot \\Delta v$ 对于 $j \\in \\{0, \\dots, N_v-1\\}$。网格间距为 $\\Delta x = \\frac{2L}{N_x-1}$ 和 $\\Delta v = \\frac{2V}{N_v-1}$。\n\n2.  **半拉格朗日平流**：由于 $f$ 沿着特征线是恒定的，时间 $t_{n+1}$ 时网格点 $(x_i, v_j)$（“到达点”）的值等于时间 $t_n$ 时“出发点” $(x_d, v_d)$ 处 $f$ 的值。出发点是通过从 $(x_i, v_j)$ 沿特征线向后追溯一个时间步 $\\Delta t$ 找到的。该映射由先前推导的后向特征方程给出，其中 $t$ 被替换为 $\\Delta t$：\n    $$\n    x_d = x_i \\cos(\\omega \\Delta t) - \\frac{v_j}{\\omega} \\sin(\\omega \\Delta t)\n    $$\n    $$\n    v_d = \\omega x_i \\sin(\\omega \\Delta t) + v_j \\cos(\\omega \\Delta t)\n    $$\n\n3.  **双线性插值**：出发点 $(x_d, v_d)$ 通常不与时间层 $t_n$ 的网格点重合。因此，其值必须从周围的网格点插值得到。我们使用双线性插值。对于一个位于由角点 $(x_{i'}, v_{j'})$、$(x_{i'+1}, v_{j'})$、$(x_{i'}, v_{j'+1})$ 和 $(x_{i'+1}, v_{j'+1})$ 定义的网格单元内的点 $(x_d, v_d)$，插值得到的值 $f^n(x_d, v_d)$ 是四个角点值 $f^n(x_{i'}, v_{j'})$ 等的加权平均。权重由 $(x_d, v_d)$ 与单元边界的分数距离确定。如果 $(x_d, v_d)$ 落在域 $[-L,L]\\times[-V,V]$ 之外，根据问题陈述，其值取为 $0$。这通过将插值器配置为对越界查询返回 $0$ 来处理。\n\n4.  **时间积分**：模拟从在网格上评估的初始条件 $f^0(x_i,v_j) = f_0(x_i, v_j)$ 开始。然后通过重复应用半拉格朗日平流步骤，将解推进 $N_t$ 步，每步大小为 $\\Delta t = t_{\\mathrm{final}}/N_t$，以获得 $f^1, f^2, \\ldots, f^{N_t}$。最终的数值结果是 $f_{\\mathrm{num}}(x_i, v_j, t_{\\mathrm{final}}) = f^{N_t}(x_i, v_j)$。\n\n5.  **误差计算**：在最终时间 $t_{\\mathrm{final}}$，将数值解 $f_{\\mathrm{num}}$ 与在同一网格上评估的精确解 $f_{\\mathrm{exact}}$ 进行比较。离散的 $L_1$ 和 $L_2$ 误差范数按规定计算：\n    $$\n    \\|e\\|_{1} = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_v-1} \\left| f_{\\mathrm{num}}(x_i,v_j) - f_{\\mathrm{exact}}(x_i,v_j) \\right|\\,\\Delta x\\,\\Delta v\n    $$\n    $$\n    \\|e\\|_{2} = \\left(\\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_v-1} \\left| f_{\\mathrm{num}}(x_i,v_j) - f_{\\mathrm{exact}}(x_i,v_j) \\right|^2\\,\\Delta x\\,\\Delta v\\right)^{1/2}\n    $$\n    积分通过对网格单元的简单 Riemann 和来近似，每个单元的面积为 $\\Delta x \\Delta v$。对每个测试案例重复此过程，以评估该格式的精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import RegularGridInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the 1D Vlasov equation for a harmonic potential using a semi-Lagrangian\n    scheme and compares the numerical result to the exact solution.\n    \"\"\"\n    \n    # Fixed parameters\n    omega = 1.0\n    L = 6.0\n    V = 6.0\n    t_final = 1.234\n    A = 1.0\n    sigma_x = 0.5\n    sigma_v = 0.5\n\n    # Test suite\n    test_cases = [\n        (32, 32, 32),   # Case 1\n        (64, 64, 64),   # Case 2\n        (128, 128, 128),# Case 3\n        (64, 64, 8),    # Case 4\n    ]\n\n    def f0(x, v):\n        \"\"\"Initial Gaussian distribution function.\"\"\"\n        return A * np.exp(-x**2 / (2 * sigma_x**2) - v**2 / (2 * sigma_v**2))\n\n    def run_simulation(Nx, Nv, Nt):\n        \"\"\"\n        Runs a single simulation for a given grid resolution and number of time steps.\n        \n        Args:\n            Nx (int): Number of grid points in the x dimension.\n            Nv (int): Number of grid points in the v dimension.\n            Nt (int): Number of time steps.\n            \n        Returns:\n            list: A list containing the L1 and L2 error norms, [e1, e2].\n        \"\"\"\n        # 1. Grid Setup\n        x_coords = np.linspace(-L, L, Nx)\n        v_coords = np.linspace(-V, V, Nv)\n        delta_x = 2 * L / (Nx - 1)\n        delta_v = 2 * V / (Nv - 1)\n        \n        # Use 'ij' indexing for intuitive alignment with array shapes\n        X, V_grid = np.meshgrid(x_coords, v_coords, indexing='ij')\n\n        # 2. Initial Condition\n        f_current = f0(X, V_grid)\n        \n        # 3. Time Integration\n        delta_t = t_final / Nt\n        cos_dt = np.cos(omega * delta_t)\n        sin_dt = np.sin(omega * delta_t)\n\n        for _ in range(Nt):\n            # Create an interpolator for the current distribution function f_current\n            # f_current has shape (Nx, Nv) corresponding to (x_coords, v_coords)\n            interpolator = RegularGridInterpolator(\n                (x_coords, v_coords), \n                f_current, \n                method='linear', \n                bounds_error=False, \n                fill_value=0.0\n            )\n            \n            # Calculate departure points for all grid points\n            # These are the positions at t_n that will arrive at (X, V_grid) at t_{n+1}\n            Xd = X * cos_dt - (V_grid / omega) * sin_dt\n            Vd = omega * X * sin_dt + V_grid * cos_dt\n\n            # Prepare departure points for interpolation\n            # The interpolator expects an array of shape (n_points, n_dims)\n            departure_points = np.stack((Xd, Vd), axis=-1)\n            \n            # Interpolate to find f at the next time step\n            f_current = interpolator(departure_points)\n\n        f_numerical = f_current\n\n        # 4. Calculate Exact Solution at t_final\n        cos_final = np.cos(omega * t_final)\n        sin_final = np.sin(omega * t_final)\n        \n        X0 = X * cos_final - (V_grid / omega) * sin_final\n        V0 = omega * X * sin_final + V_grid * cos_final\n        \n        f_exact = f0(X0, V0)\n        \n        # 5. Calculate Error Norms\n        error_abs = np.abs(f_numerical - f_exact)\n        \n        # Integrate using a simple Riemann sum as specified\n        norm1 = np.sum(error_abs) * delta_x * delta_v\n        norm2 = np.sqrt(np.sum(error_abs**2) * delta_x * delta_v)\n        \n        return [norm1, norm2]\n\n    results = []\n    for case in test_cases:\n        Nx, Nv, Nt = case\n        errors = run_simulation(Nx, Nv, Nt)\n        results.append(errors)\n\n    # Format the output string as per the problem specification\n    results_str = [f\"[{e1:.6e},{e2:.6e}]\" for e1, e2 in results]\n    final_output = f\"[{','.join(results_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3500344"}, {"introduction": "这是一个综合性的顶点练习，它在一个自洽的粒子-网格（Particle-Mesh, PM）模拟中结合了动力学（弗拉索夫方程）和引力（泊松方程）。本练习将引导您实现一个完整的模拟，并在此基础上探索无碰撞系统中的粗粒化和熵等高级概念。这项实践不仅提供了数值宇宙学中核心算法（PM方法）的实践经验，更深刻的是，它让学生能够在一个形式上时间可逆的系统中，数值地研究“时间之矢”。通过分析粗粒化熵的增长和细尺度结构（纤维化）的形成，您可以将微观动力学与宏观不可逆性联系起来 [@problem_id:3500426]。", "problem": "您需要编写一个完整、可运行的程序，从一维空间周期性边界条件下无碰撞物质的 Vlasov-Poisson 系统的第一性原理离散化出发，模拟高斯滤波下的相混合和粗粒化熵增长。您将通过分析熵如何随高斯滤波器宽度的变化而变化，来量化粗粒化 Gibbs 熵，并提取相空间中的特征纤维化尺度。\n\n从以下基本和核心定义开始。\n\n- 相空间分布：设 $f(x,v,t)$ 为单粒子分布函数，归一化使得 $\\int f(x,v,t)\\,dx\\,dv = 1$。在无碰撞极限下，$f$ 满足 Vlasov 方程\n$$\n\\frac{\\partial f}{\\partial t} + v\\frac{\\partial f}{\\partial x} - \\frac{\\partial \\Phi}{\\partial x}\\frac{\\partial f}{\\partial v} = 0,\n$$\n其中 $\\Phi(x,t)$ 是引力势。\n\n- 势 $\\Phi$ 由一维周期性边界条件和零均值密度扰动的 Poisson 方程确定：\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x^2} = 4\\pi G \\left[\\rho(x,t) - \\bar \\rho\\right], \\quad \\rho(x,t)=\\int f(x,v,t)\\,dv,\n$$\n其中 $\\bar\\rho$ 是空间平均密度。使用无量纲单位，域长度 $L=1$，并设置 $4\\pi G=1$，因此 Poisson 方程为\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x^2} = \\rho(x,t) - \\bar \\rho.\n$$\n\n- 粗粒化熵：给定一个在下述适当缩放的无量纲相空间坐标系中应用的各向同性宽度为 $\\epsilon$ 的高斯滤波器，定义粗粒化分布 $\\bar f_\\epsilon$ 和粗粒化 Gibbs 熵\n$$\nS_\\epsilon \\equiv -\\int \\bar f_\\epsilon(\\xi,\\eta,t)\\,\\ln \\bar f_\\epsilon(\\xi,\\eta,t)\\,d\\xi\\,d\\eta.\n$$\n\n您的程序必须实现以下任务集，以保持在不同语言和环境中的通用性和可测试性。\n\n1) 模拟模型和数值方法\n\n- 使用粒子-网格 (Particle-Mesh, PM) 方法，在一维空间 $x\\in [0,1)$ 中演化具有周期性边界条件的系统，以近似无碰撞物质的自洽引力场。通过 $N_p$ 个等质量的模拟粒子来表示无碰撞分布 $f(x,v,t)$，这些粒子具有位置 $x_i(t)$ 和速度 $v_i(t)$。\n\n- 使用云中单元 (Cloud-In-Cell, CIC) 分配方案，在具有 $N_x$ 个单元的均匀网格上计算密度。使用快速傅里叶变换 (Fast Fourier Transform, FFT) 和谱恒等式 $\\widehat{\\partial_x^2 \\Phi}(k) = -(2\\pi k)^2 \\widehat{\\Phi}(k)$ 在傅里叶空间中求解泊松方程，并设置 $\\widehat{\\Phi}(0)=0$。通过 $a(x) = -\\partial_x \\Phi$ 在谱空间计算加速度。使用 CIC 将加速度插值回粒子。使用二阶辛（蛙跳）格式推进粒子。\n\n- 初始条件：在 $[0,1)$ 中均匀采样初始拉格朗日坐标 $q_i$ 并设置\n$$\nx_i(0) = \\left[q_i + \\frac{A}{2\\pi}\\sin(2\\pi q_i)\\right] \\bmod 1,\n$$\n初始速度 $v_i(0)$ 从标准差为 $\\sigma_v$ 的零均值正态分布中抽取。这提供了一个在自引力下坍缩的单模扰动。\n\n- 单位：所有量都是无量纲的，其中 $L=1$，$4\\pi G=1$，总质量归一化为 $1$。时间 $t$ 采用由这些归一化所设定的隐含动力学单位。如果出现任何角度，必须以弧度解释。\n\n2) 粗粒化和熵\n\n- 演化到指定时间 $t=t_{\\mathrm{end}}$ 后，将粒子相空间位置映射到一个缩放的单位正方形 $(\\xi,\\eta)\\in [0,1]\\times [0,1]$，具体如下：设置 $\\xi=x$ 并确定一个对称的速度范围 $[-V_{\\max},V_{\\max}]$，其中 $V_{\\max}$ 选择为速度标准差的倍数，$V_{\\max}=\\alpha \\sqrt{\\langle v^2\\rangle}$，$\\alpha>0$ 是一个固定常数因子。然后映射 $\\eta = (v+V_{\\max})/(2V_{\\max})$ 并将 $\\eta$ 的值裁剪到 $[0,1]$ 范围内。\n\n- 使用二维直方图在具有 $N_\\xi\\times N_\\eta$ 个单元的规则网格上估计连续密度 $f(\\xi,\\eta,t_{\\mathrm{end}})$。通过\n$$\nf_{ij} = \\frac{n_{ij}}{N_p\\,\\Delta \\xi\\,\\Delta \\eta},\n$$\n将计数 $n_{ij}$ 转换为连续密度，其中 $\\Delta \\xi = 1/N_\\xi$ 且 $\\Delta\\eta = 1/N_\\eta$，使得 $\\sum_{ij} f_{ij}\\,\\Delta\\xi\\,\\Delta\\eta \\approx 1$。\n\n- 在 $(\\xi,\\eta)$ 中定义高斯滤波器为\n$$\nG_\\epsilon(\\Delta \\xi,\\Delta \\eta) = \\frac{1}{2\\pi \\epsilon^2}\\exp\\left[-\\frac{\\Delta \\xi^2+\\Delta \\eta^2}{2\\epsilon^2}\\right],\n$$\n并通过卷积计算 $\\bar f_\\epsilon = f \\star G_\\epsilon$。使用 FFT 在傅里叶空间中高效地实现卷积，采用约定 $\\mathcal{F}\\{G_\\epsilon\\}(k_\\xi,k_\\eta) = \\exp\\left[-2\\pi^2\\epsilon^2\\left(k_\\xi^2+k_\\eta^2\\right)\\right]$，其中 $k_\\xi$ 和 $k_\\eta$ 是单位区间内的傅里叶频率（以周期/单位区间为单位）。确保 $\\bar f_\\epsilon$ 的数值非负性，如果需要则重新归一化，以使积分在机器精度下保持为 1。\n\n- 对每个滤波器宽度计算粗粒化熵：\n$$\nS_\\epsilon = -\\sum_{i,j} \\bar f_{\\epsilon,ij}\\,\\ln \\bar f_{\\epsilon,ij}\\,\\Delta\\xi\\,\\Delta\\eta,\n$$\n并约定 $\\bar f_{\\epsilon,ij}=0$ 的项贡献为 $0$。\n\n3) 从熵产生中估计纤维化尺度\n\n- 给定一组跨越小到中等平滑尺度的滤波器宽度 $\\{\\epsilon_\\ell\\}$，计算 $S_{\\epsilon_\\ell}$ 并在 $\\ln \\epsilon$ 网格上使用有限差分格式近似导数 $dS_\\epsilon/d\\ln \\epsilon$。定义一个阈值分数 $\\tau\\in (0,1)$，并将特征纤维化尺度 $\\epsilon_\\star$ 定义为超过 $dS_\\epsilon/d\\ln \\epsilon$ 最大值位置的、满足 $dS_\\epsilon/d\\ln \\epsilon \\le \\tau \\max_\\ell dS_{\\epsilon_\\ell}/d\\ln \\epsilon$ 的最小滤波器宽度。如果集合中不存在这样的宽度，则将 $\\epsilon_\\star$ 取为测试过的最大 $\\epsilon$。\n\n4) 测试套件\n\n您的程序必须运行以下三种情况（每种情况指定 $(A,\\sigma_v,t_{\\mathrm{end}})$），其他数值参数均相同：\n\n- 情况 1 (理想路径): $(A,\\sigma_v,t_{\\mathrm{end}}) = (0.1, 0.02, 1.0)$。\n\n- 情况 2 (更强、更冷的坍缩): $(A,\\sigma_v,t_{\\mathrm{end}}) = (0.2, 0.0, 1.2)$。\n\n- 情况 3 (早期边界): $(A,\\sigma_v,t_{\\mathrm{end}}) = (0.1, 0.01, 0.1)$。\n\n对于所有情况，使用 $N_p=2000$ 个粒子，一个具有 $N_x=256$ 个单元的 PM 网格，以及时间步长为 $\\Delta t = 0.002$ 的蛙跳算法，使得步数为 $t_{\\mathrm{end}}/\\Delta t$ 四舍五入到最近的整数。对于粗粒化，使用 $(N_\\xi,N_\\eta)=(128,128)$，选择 $V_{\\max}=\\alpha \\sqrt{\\langle v^2\\rangle}$ 且 $\\alpha=5$，并在 $\\epsilon \\in [5\\times 10^{-3}, 1.5\\times 10^{-1}]$ 的对数间隔网格上评估 $S_\\epsilon$，该网格至少有 $10$ 个不同的值。使用阈值 $\\tau=0.2$ 来确定 $\\epsilon_\\star$。\n\n5) 最终输出格式\n\n您的程序应生成单行输出，其中包含三个测试用例的三个 $\\epsilon_\\star$ 结果值，格式为逗号分隔的 Python 风格列表，例如：“[result1,result2,result3]”。每个结果必须是浮点数。不得有任何其他打印输出。\n\n在上述公式中，所有量都是无量纲的，并且必须报告为无量纲数。不需要进行物理单位转换。在适用的情况下，角度以弧度为单位。在分析过程中逻辑上考虑的任何百分比，必须在内部表示为小数或分数，而不是以百分号形式打印。", "solution": "我们从相空间分布 $f(x,v,t)$ 的无碰撞玻尔兹曼方程（通常称为 Vlasov 方程）开始，\n$$\n\\frac{\\partial f}{\\partial t} + v\\frac{\\partial f}{\\partial x} - \\frac{\\partial \\Phi}{\\partial x}\\frac{\\partial f}{\\partial v} = 0,\n$$\n以及引力势 $\\Phi(x,t)$ 的泊松方程，\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x^2} = \\rho(x,t) - \\bar \\rho,\\quad \\rho(x,t)=\\int f(x,v,t)\\,dv,\n$$\n单位设定为 $4\\pi G=1$，域长度 $L=1$，并采用周期性边界条件。Vlasov 方程代表了相空间中的哈密顿平流。沿着特征线 $(x(t),v(t))$，$f$ 是守恒的，细粒度 Gibbs 熵\n$$\nS_{\\mathrm{fine}} = -\\int f\\ln f\\,dx\\,dv\n$$\n不随时间变化。然而，相混合导致的精细纤维化形成使得 $f$ 中出现越来越精细的结构，这些结构无法被有限分辨率的测量所解析。通过宽度为 $\\epsilon$ 的平滑核进行粗粒化后，根据函数 $x\\mapsto x\\ln x$ 的严格凸性和应用于线性卷积算子的 Jensen 不等式，粗粒化分布 $\\bar f_\\epsilon$ 满足 $S_\\epsilon \\equiv -\\int \\bar f_\\epsilon \\ln \\bar f_\\epsilon\\,dx\\,dv \\ge S_{\\mathrm{fine}}$。当 $\\epsilon$ 增加到超过相空间中的特征纤维宽度时，$S_\\epsilon$ 增加；增长率 $dS_\\epsilon/d\\ln \\epsilon$ 在滤波器开始合并跨越纤维化尺度的 $f$ 的相反符号梯度处达到最大。因此，$dS_\\epsilon/d\\ln \\epsilon$ 下降到其峰值的一小部分的位置，为纤维化尺度提供了一个稳健的代理指标。\n\n从第一性原理出发的算法设计如下。\n\n1) 粒子-网格 (PM) 演化和蛙跳算法\n\n- 粒子：让 $N_p$ 个等质量粒子承载总单位质量，$m=1/N_p$。为了产生一个会坍缩的动力学不稳定构型，我们在位置\n$$\nx_i(0) = \\left[q_i + \\frac{A}{2\\pi}\\sin(2\\pi q_i)\\right] \\bmod 1,\n$$\n初始化粒子，其中 $q_i$ 在 $[0,1)$ 上均匀采样，初始速度 $v_i(0)$ 从标准差为 $\\sigma_v$ 的高斯分布（零均值）中抽取。这在周期性域上实现了一个单模超密度，并触发了自引力下的坍缩。该映射是一种保留粒子标签的拉格朗日扰动，初始的 $f$ 是在 $v$ 上的一个窄水袋模型 (narrow waterbag)。\n\n- 网格沉积：将空间域离散化为 $N_x$ 个宽度为 $\\Delta x = 1/N_x$ 的均匀单元。通过云中单元 (CIC) 方法将粒子质量沉积到网格上，该方法质量守恒，并产生在单元中心定义的连续密度场 $\\rho_j$。具体来说，对于位于位置 $x$ 的粒子，计算左侧单元索引 $i=\\lfloor x/\\Delta x\\rfloor$ 和权重 $w=(x/\\Delta x - i)$；将 $(1-w)m$ 沉积到单元 $i$，将 $wm$ 沉积到单元 $(i+1)\\bmod N_x$。然后通过除以单元宽度将单元质量转换为密度，$\\rho_j = M_j/\\Delta x$。平均密度为 $\\bar \\rho = 1$。\n\n- 通过 FFT 求解泊松方程：将零均值密度扰动 $\\delta \\rho(x) \\equiv \\rho(x) - \\bar \\rho$ 傅里叶变换为 $\\widehat{\\delta\\rho}(k)$。在 FFT 使用核 $e^{-2\\pi i k x}$ 的约定下，谱泊松方程为 $-(2\\pi k)^2 \\widehat{\\Phi}(k) = \\widehat{\\delta\\rho}(k)$，因此\n$$\n\\widehat{\\Phi}(k) = -\\frac{\\widehat{\\delta\\rho}(k)}{(2\\pi k)^2},\\quad \\widehat{\\Phi}(0)=0.\n$$\n在谱空间中计算加速度为 $\\widehat{a}(k) = - (2\\pi i k)\\,\\widehat{\\Phi}(k)$，然后进行傅里叶逆变换以在网格上获得 $a(x)$。使用相同的 CIC 方案将 $a(x)$ 插值回粒子位置以保持动量。\n\n- 时间积分：使用时间步长为 $\\Delta t$ 的二阶辛蛙跳（踢-漂-踢）格式：\n  - 踢： $v^{n+1/2} = v^n + (\\Delta t/2)\\,a(x^n)$。\n  - 漂： $x^{n+1} = x^n + \\Delta t\\,v^{n+1/2}$，并周期性地包裹到 $[0,1)$。\n  - 重新计算 $a(x^{n+1})$。\n  - 踢： $v^{n+1} = v^{n+1/2} + (\\Delta t/2)\\,a(x^{n+1})$。\n该方法全局上保持相空间结构，并在所选单位下精确捕捉无碰撞动力学。\n\n2) 粗粒化和熵\n\n- 缩放坐标：在时间 $t_{\\mathrm{end}}$，通过 $\\xi=x \\in [0,1)$ 和 $\\eta = (v+V_{\\max})/(2V_{\\max}) \\in [0,1]$ 构建 $(\\xi,\\eta)$，其中 $V_{\\max}=\\alpha \\sqrt{\\langle v^2\\rangle}$ 且 $\\alpha=5$。将 $\\eta$ 裁剪到 $[0,1]$ 范围内，以便所有粒子都映射到单位正方形内。这种无量纲映射允许在 $(\\xi,\\eta)$ 平面上使用各向同性的高斯滤波器。\n\n- 直方图和密度：使用一个 $N_\\xi\\times N_\\eta$ 的直方图在均匀网格上获得计数 $n_{ij}$。通过 $f_{ij} = n_{ij}/(N_p\\,\\Delta \\xi\\,\\Delta \\eta)$ 将其转换为连续密度，其中 $\\Delta \\xi = 1/N_\\xi$ 且 $\\Delta \\eta=1/N_\\eta$，使得 $\\sum_{ij} f_{ij}\\,\\Delta \\xi\\,\\Delta\\eta \\approx 1$。这是对连续 $f(\\xi,\\eta)$ 的黎曼近似。\n\n- 高斯滤波：定义各向同性高斯核\n$$\nG_\\epsilon(\\Delta \\xi,\\Delta \\eta) = \\frac{1}{2\\pi \\epsilon^2}\\exp\\left[-\\frac{\\Delta \\xi^2+\\Delta \\eta^2}{2\\epsilon^2}\\right].\n$$\n在傅里叶空间中使用 FFT 进行卷积，采用 FFT 约定 $e^{-2\\pi i k x}$ 下的变换 $\\mathcal{F}\\{G_\\epsilon\\}(k_\\xi,k_\\eta) = \\exp\\left[-2\\pi^2 \\epsilon^2 (k_\\xi^2 + k_\\eta^2)\\right]$。设 $\\widehat f(k_\\xi,k_\\eta)$ 为 $f$ 的 FFT。然后通过在傅里叶空间中相乘得到平滑场，\n$$\n\\widehat{\\bar f_\\epsilon}(k_\\xi,k_\\eta) = \\widehat f(k_\\xi,k_\\eta)\\,\\exp\\left[-2\\pi^2 \\epsilon^2 (k_\\xi^2+k_\\eta^2)\\right],\n$$\n并进行傅里叶逆变换。由数值伪影产生的微小负值在归一化前被裁剪到一个小的正数下限。如果需要，重新归一化 $\\bar f_\\epsilon$ 以确保 $\\sum \\bar f_\\epsilon\\,\\Delta \\xi\\,\\Delta \\eta = 1$。\n\n- 熵：计算粗粒化 Gibbs 熵\n$$\nS_\\epsilon = -\\sum_{i,j} \\bar f_{\\epsilon,ij}\\,\\ln \\bar f_{\\epsilon,ij}\\,\\Delta\\xi\\,\\Delta\\eta,\n$$\n约定 $0\\ln 0=0$。这个黎曼和近似于连续积分。\n\n3) 从熵产生中确定纤维化尺度\n\n当滤波器宽度 $\\epsilon$ 在对数网格上变化时，计算 $S_\\epsilon$ 并通过有限差分估计 $dS_\\epsilon/d\\ln \\epsilon$。由于凸性和纤维化引起的混合，$S_\\epsilon$ 随 $\\epsilon$ 非递减，而导数 $dS_\\epsilon/d\\ln\\epsilon$ 通常在特征纤维宽度附近出现一个峰值，然后随着滤波器超过最小结构而衰减。我们在操作上将 $\\epsilon_\\star$ 定义为超过 $dS_\\epsilon/d\\ln \\epsilon$ 最大值后，斜率下降到其最大值的一小部分 $\\tau$ 时的最小 $\\epsilon$：\n$$\n\\epsilon_\\star = \\min\\left\\{\\epsilon \\ge \\epsilon_{\\mathrm{peak}}:\\ \\frac{dS_\\epsilon}{d\\ln \\epsilon} \\le \\tau \\max_{\\epsilon'} \\frac{dS_{\\epsilon'}}{d\\ln \\epsilon'}\\right\\},\n$$\n其中 $\\tau=0.2$。如果集合中不包含这样的 $\\epsilon$，则将 $\\epsilon_\\star$ 取为测试过的最大宽度。\n\n4) 数值参数和测试套件\n\n我们使用 $N_p=2000$，$N_x=256$，以及蛙跳时间步长 $\\Delta t=0.002$；因此对于每种情况，步数是 $t_{\\mathrm{end}}/\\Delta t$ 四舍五入到最近的整数。对于粗粒化，$N_\\xi=N_\\eta=128$，速度范围的 $\\alpha=5$，以及在 $[5\\times 10^{-3}, 1.5\\times 10^{-1}]$ 区间内的一组 $10$ 个对数间隔的 $\\epsilon$ 值。三个测试用例如下：\n\n- 情况 1: $(A,\\sigma_v,t_{\\mathrm{end}})=(0.1,0.02,1.0)$。\n\n- 情况 2: $(A,\\sigma_v,t_{\\mathrm{end}})=(0.2,0.0,1.2)$。\n\n- 情况 3: $(A,\\sigma_v,t_{\\mathrm{end}})=(0.1,0.01,0.1)$。\n\n5) 输出\n\n对于每种情况，按定义计算 $\\epsilon_\\star$ 并输出一行，其中包含三个 $\\epsilon_\\star$ 值，格式为 Python 风格的列表，例如：“[0.0123,0.0087,0.0456]”。这些是与缩放的 $(\\xi,\\eta)$ 空间相关的无量纲数，用于量化从粗粒化熵产生中推断出的相空间纤维化尺度。\n\n此设计遵循第一性原理：我们使用 PM 近似的 Vlasov-Poisson 系统来演化自引力作用下的无碰撞物质，通过在无量纲缩放相空间中的各向同性高斯函数来定义粗粒化，并通过 $dS_\\epsilon/d\\ln \\epsilon$ 的行为将熵产生与纤维化尺度联系起来。数值选择是标准的、科学上合理的，并以适度的成本产生了一个稳健、可测试的计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Set a global random seed for reproducibility\nrng = np.random.default_rng(42)\n\ndef cic_deposit_1d(x, mass_per_particle, nx):\n    \"\"\"\n    Cloud-In-Cell deposition of particle masses onto a 1D grid.\n    x: particle positions in [0,1)\n    mass_per_particle: scalar mass for each particle\n    nx: number of grid cells\n    Returns mass per cell (not yet divided by cell width).\n    \"\"\"\n    dx = 1.0 / nx\n    # Compute left cell index and weight\n    gx = x * nx\n    i0 = np.floor(gx).astype(int) % nx\n    fx = gx - i0\n    # Initialize grid mass\n    mass_grid = np.zeros(nx, dtype=np.float64)\n    # Deposit to left and right cells\n    w_left = (1.0 - fx) * mass_per_particle\n    w_right = fx * mass_per_particle\n    # Use np.add.at for scatter add\n    np.add.at(mass_grid, i0, w_left)\n    np.add.at(mass_grid, (i0 + 1) % nx, w_right)\n    return mass_grid\n\ndef cic_interpolate_1d(x, grid_values):\n    \"\"\"\n    Cloud-In-Cell interpolation of grid values to particle positions.\n    x: particle positions in [0,1)\n    grid_values: values on a 1D grid of length nx\n    Returns interpolated values at particle positions.\n    \"\"\"\n    nx = grid_values.shape[0]\n    gx = x * nx\n    i0 = np.floor(gx).astype(int) % nx\n    fx = gx - i0\n    v_left = grid_values[i0]\n    v_right = grid_values[(i0 + 1) % nx]\n    return (1.0 - fx) * v_left + fx * v_right\n\ndef compute_acceleration_pm(x_particles, nx):\n    \"\"\"\n    Compute gravitational acceleration on particles using a 1D PM scheme.\n    Units: L=1, 4pi G = 1 -> Poisson: phi_xx = rho - rho_mean\n    \"\"\"\n    npart = x_particles.shape[0]\n    mass_per_particle = 1.0 / npart\n    # Deposit mass onto grid\n    mass_grid = cic_deposit_1d(x_particles, mass_per_particle, nx)\n    dx = 1.0 / nx\n    # Convert to density\n    rho = mass_grid / dx  # mass per cell / cell width\n    # Subtract mean density (should be ~1.0)\n    rho_mean = np.mean(rho)\n    drho = rho - rho_mean\n    # FFT to solve Poisson\n    rho_k = np.fft.fft(drho)\n    k = np.fft.fftfreq(nx, d=dx)  # cycles per unit length\n    # Avoid division by zero at k=0\n    phi_k = np.zeros_like(rho_k, dtype=np.complex128)\n    # (2πk)^2 factor in denominator\n    nonzero = k != 0.0\n    denom = (2.0 * np.pi * k[nonzero]) ** 2\n    phi_k[nonzero] = -rho_k[nonzero] / denom\n    # Acceleration a = - dphi/dx => in k-space: a_k = -(2π i k) * phi_k\n    a_k = -(2.0j * np.pi * k) * phi_k\n    a_grid = np.fft.ifft(a_k).real\n    # Interpolate acceleration to particle positions\n    a_particles = cic_interpolate_1d(x_particles, a_grid)\n    return a_particles\n\ndef leapfrog_pm(x, v, nx, dt, nsteps):\n    \"\"\"\n    Advance particles using leapfrog with PM accelerations.\n    \"\"\"\n    # Initial half-kick\n    a = compute_acceleration_pm(x, nx)\n    v = v + 0.5 * dt * a\n    for _ in range(nsteps):\n        # Drift\n        x = x + dt * v\n        # Periodic wrap\n        x = np.mod(x, 1.0)\n        # Compute new acceleration\n        a = compute_acceleration_pm(x, nx)\n        # Kick\n        v = v + dt * a\n    # Final half-step correction to ensure end at full step:\n    v = v - 0.5 * dt * a  # undo extra half-kick from the last loop to maintain KDK\n    return x, v\n\ndef histogram_density_phase_space(x, v, nxi, neta, alpha=5.0):\n    \"\"\"\n    Build a 2D histogram-based density f(ξ,η) on [0,1]x[0,1].\n    ξ = x in [0,1)\n    η = (v + Vmax)/(2 Vmax), Vmax = alpha * std(v)\n    Returns:\n      f: 2D density array normalized so sum f dξ dη ~ 1\n      dxi, deta: grid spacings\n    \"\"\"\n    v_std = np.std(v)\n    vmax = alpha * v_std if v_std > 0 else 1.0  # avoid zero\n    # Map to [0,1]\n    xi = np.mod(x, 1.0)\n    eta = (v + vmax) / (2.0 * vmax)\n    eta = np.clip(eta, 0.0, 1.0)\n    # 2D histogram\n    counts, xedges, yedges = np.histogram2d(xi, eta, bins=[nxi, neta], range=[[0.0, 1.0], [0.0, 1.0]])\n    npart = x.shape[0]\n    dxi = 1.0 / nxi\n    deta = 1.0 / neta\n    # Convert counts to density\n    f = counts / (npart * dxi * deta)\n    return f, dxi, deta\n\ndef gaussian_filter_fft_2d(f, sigma):\n    \"\"\"\n    Apply isotropic Gaussian filter with width sigma (in units of the [0,1] scaled coordinates)\n    using FFT-based multiplication by exp(-2 pi^2 sigma^2 (k_x^2 + k_y^2)).\n    \"\"\"\n    ny, nx = f.shape\n    # FFT\n    Fk = np.fft.fft2(f)\n    # Frequencies in cycles per unit interval\n    ky = np.fft.fftfreq(ny, d=1.0/ny)  # but since domain is [0,1], spacing is 1/ny, so d=1/ny gives frequencies in cycles per unit\n    kx = np.fft.fftfreq(nx, d=1.0/nx)\n    ky2 = ky**2\n    kx2 = kx**2\n    # Build separable Gaussian in k-space\n    # Note: for fftfreq with d=1/ny, the frequencies are integers 0..ny/2.. negative; appropriate for domain [0,1].\n    Gk_y = np.exp(-2.0 * (np.pi**2) * (sigma**2) * ky2)\n    Gk_x = np.exp(-2.0 * (np.pi**2) * (sigma**2) * kx2)\n    Gk = np.outer(Gk_y, Gk_x)\n    # Apply filter\n    Fk_s = Fk * Gk\n    f_s = np.fft.ifft2(Fk_s).real\n    # Numerical cleanup: enforce non-negativity and renormalize integral\n    f_s = np.maximum(f_s, 0.0)\n    integral = f_s.sum() / (ny * nx)  # since dξ dη = 1/ny * 1/nx; sum f_s * dξ dη = sum f_s / (ny*nx)\n    if integral > 0:\n        f_s *= 1.0 / integral\n    return f_s\n\ndef coarse_grained_entropy(fbar, dxi, deta):\n    \"\"\"\n    Compute S = -∑ f ln f dξ dη with 0 ln 0 = 0 by convention.\n    \"\"\"\n    # Avoid log(0) by masking zeros\n    mask = fbar > 0.0\n    vals = fbar[mask]\n    S = -np.sum(vals * np.log(vals)) * dxi * deta\n    return S\n\ndef entropy_vs_epsilon(f, dxi, deta, epsilons):\n    \"\"\"\n    Compute S_epsilon for a list of epsilons using Gaussian smoothing in scaled coords.\n    \"\"\"\n    S_list = []\n    for eps in epsilons:\n        fbar = gaussian_filter_fft_2d(f, sigma=eps)\n        S = coarse_grained_entropy(fbar, dxi, deta)\n        S_list.append(S)\n    return np.array(S_list)\n\ndef epsilon_star_from_entropy(epsilons, S_list, tau=0.2):\n    \"\"\"\n    Determine epsilon_star based on derivative threshold criterion.\n    \"\"\"\n    # Use derivative w.r.t. ln epsilon\n    ln_eps = np.log(epsilons)\n    # Central differences on nonuniform grid handled by numpy.gradient\n    dS_dln = np.gradient(S_list, ln_eps)\n    # Find index of max derivative\n    imax = int(np.argmax(dS_dln))\n    max_slope = dS_dln[imax]\n    # Find first index beyond imax where slope = tau * max_slope\n    idx = None\n    for i in range(imax + 1, len(epsilons)):\n        if dS_dln[i] = tau * max_slope:\n            idx = i\n            break\n    if idx is None:\n        return float(epsilons[-1])\n    else:\n        return float(epsilons[idx])\n\ndef run_case(A, sigma_v, t_end, npart=2000, nx=256, dt=0.002, nxi=128, neta=128, alpha=5.0, eps_range=(5e-3, 1.5e-1), n_eps=10, tau=0.2):\n    \"\"\"\n    Run a single test case and return epsilon_star.\n    \"\"\"\n    # Initialize particle positions and velocities\n    q = rng.random(npart)\n    x0 = (q + (A / (2.0 * np.pi)) * np.sin(2.0 * np.pi * q)) % 1.0\n    if sigma_v > 0:\n        v0 = rng.normal(loc=0.0, scale=sigma_v, size=npart)\n    else:\n        v0 = np.zeros(npart, dtype=np.float64)\n    # Determine number of steps\n    nsteps = int(np.round(t_end / dt))\n    # Evolve with PM leapfrog\n    x, v = leapfrog_pm(x0.copy(), v0.copy(), nx, dt, nsteps)\n    # Construct phase-space density on unit square\n    f, dxi, deta = histogram_density_phase_space(x, v, nxi, neta, alpha=alpha)\n    # Epsilon grid\n    epsilons = np.logspace(np.log10(eps_range[0]), np.log10(eps_range[1]), num=n_eps)\n    # Compute entropy vs epsilon\n    S_list = entropy_vs_epsilon(f, dxi, deta, epsilons)\n    # Determine epsilon_star\n    eps_star = epsilon_star_from_entropy(epsilons, S_list, tau=tau)\n    return eps_star\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (A, sigma_v, t_end)\n        (0.1, 0.02, 1.0),  # Case 1\n        (0.2, 0.0, 1.2),   # Case 2\n        (0.1, 0.01, 0.1),  # Case 3\n    ]\n\n    results = []\n    for A, sigma_v, t_end in test_cases:\n        eps_star = run_case(A, sigma_v, t_end,\n                            npart=2000, nx=256, dt=0.002,\n                            nxi=128, neta=128, alpha=5.0,\n                            eps_range=(5e-3, 1.5e-1), n_eps=10, tau=0.2)\n        # Format with a reasonable precision to be concise and reproducible\n        results.append(f\"{eps_star:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3500426"}]}