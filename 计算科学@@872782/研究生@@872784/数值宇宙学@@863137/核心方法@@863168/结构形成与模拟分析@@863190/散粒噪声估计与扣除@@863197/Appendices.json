{"hands_on_practices": [{"introduction": "最简单的散粒噪声估计 $1/\\bar{n}$ 仅适用于均匀密度场。然而，在实际的宇宙学巡天中，由于观测选择效应，星系样本的平均数密度 $\\bar{n}(\\mathbf{x})$ 在空间上是变化的。本练习将直面这一挑战，要求你从第一性原理出发，为具有空间变化密度场的泊松点过程推导并实现一个精确的散粒噪声项。你将使用宇宙学大尺度结构分析中的标准工具——Feldman-Kaiser-Peacock (FKP) 权重方案，从而建立对真实巡天中散粒噪声行为的基础理解。[@problem_id:3486501]", "problem": "实现一个完整的程序，该程序为一个具有空间变化的选区函数的三维周期性巡天构建并验证一个Feldman–Kaiser–Peacock (FKP) 加权功率谱估计器。目标是从非均匀泊松点过程的统计特性出发，推导出功率谱的无偏估计器所需的精确散粒噪声减除项。该推导必须从具有强度的点过程及其两点统计量的第一性原理开始，并且不得预先假设任何专门的快捷公式。然后，在一个离散化的、基于网格的设置中实现该估计器，并使用从已知选区函数生成的随机星表对其进行验证。\n\n给定以下设置，必须在所有部分中一致使用：\n\n- 考虑一个边长为$L$且具有周期性边界条件的立方体盒子。所有位置均以盒子长度为单位，所有待打印的量都是无物理单位的实数。\n- 用一个具有$N^3$个等体积立方单元（$\\Delta V = L^3 / N^3$）的离散网格来表示连续数密度场，单元索引为$i \\in \\{1,\\dots,N^3\\}$。定义单元中心的平均数密度$\\bar n_i \\equiv \\bar n(\\mathbf x_i)$，并令$n_i$表示该单元中数密度的随机实现。对于非均匀泊松过程，单元$i$中的点数服从均值为$\\mu_i = \\bar n_i \\Delta V$的泊松分布，且$n_i = \\text{Poisson}(\\mu_i)/\\Delta V$。\n- 定义一个实的、非负的权重场$w(\\mathbf x)$，其离散形式为$w_i \\equiv w(\\mathbf x_i)$。\n- 将网格上的加权涨落场定义为$F_i = w_i \\left(n_i - \\bar n_i\\right)$。\n- 将网格上$F_i$的离散傅里叶变换定义为连续变换的近似，\n  $$ F(\\mathbf k) \\approx \\Delta V \\sum_{i=1}^{N^3} F_i \\, e^{i \\mathbf k \\cdot \\mathbf x_i}, $$\n  使用周期性网格上的标准离散傅里叶变换约定。所有波矢量$\\mathbf k$均以由网格傅里叶变换决定的基本模式$2\\pi / L$为单位。\n\n你的任务：\n\n1. 从强度为$\\bar n(\\mathbf x)$的非均匀泊松点过程的定义及其两点协方差，以及加权场$F(\\mathbf x) = w(\\mathbf x)\\left[n(\\mathbf x) - \\bar n(\\mathbf x)\\right]$的定义出发，推导出精确的、与$k$无关的散粒噪声项$S$。当估计器通过巡天权重积分$I_1$的平方进行归一化时，必须从$|F(\\mathbf k)|^2$中减去该项，以便在没有成团性的情况下获得功率谱振幅的无偏估计。你的推导必须从以下几点开始：\n   - 泊松点过程的定义属性：对于无穷小体积$d^3x$，其中的计数服从均值为$\\bar n(\\mathbf x) d^3x$的泊松分布，以及\n   - 数密度的协方差：对于一般的两点统计量，$\\langle n(\\mathbf x) n(\\mathbf y) \\rangle = \\bar n(\\mathbf x) \\bar n(\\mathbf y) \\left[1 + \\xi(\\mathbf x,\\mathbf y)\\right] + \\bar n(\\mathbf x) \\delta_{\\rm D}(\\mathbf x - \\mathbf y)$，\n   其中$\\delta_{\\rm D}$是狄拉克δ分布，$\\xi$是两点相关函数。\n   不要预先假设$S$的任何特殊情况或快捷表达式。清晰地说明你使用的归一化积分，并获得一个以$\\bar n(\\mathbf x)$和$w(\\mathbf x)$的空间积分为形式的$S$的闭合表达式。\n\n2. 在三维网格上按如下方式实现离散化的估计器：\n   - 使用近似相应空间积分的离散求和来计算$I_1$和推导出的$S$。\n   - 生成与$\\bar n_i$一致的、每个单元内服从泊松分布的数密度。\n   - 使用$F_i$的离散傅里叶变换乘以$\\Delta V$来计算网格上的傅里叶变换$F(\\mathbf k)$。\n   - 对于每个非零的$\\mathbf k$模式，构建\n     $$ \\hat P(\\mathbf k) = \\frac{|F(\\mathbf k)|^2}{I_1^2} - S, $$\n     并按照下文测试套件中的规定聚合统计数据。\n   - 权重场$w(\\mathbf x)$可以是任意的；对于其中一个测试用例，使用FKP权重$w_{\\rm FKP}(\\mathbf x) = \\left[1 + \\bar n(\\mathbf x) P_0\\right]^{-1}$，其中$P_0$是一个给定的常数。\n\n3. 通过打印所要求的标量值，在三个测试用例中验证散粒噪声减除。所有要求的输出都是无量纲的。\n\n测试套件和要求的输出：\n\n- 测试用例A（均匀基线一致性）：\n  - 参数：$L = 200$， $N = 48$， $\\bar n(\\mathbf x) = n_0$ 其中 $n_0 = 2 \\times 10^{-3}$，以及$w(\\mathbf x) \\equiv 1$。\n  - 使用网格求和，从你的通用公式计算离散散粒项，并将其与从常数$\\bar n$和常数$w$的第一性原理得出的均匀场极限预测进行比较。令$V = L^3$并将均匀场预测表示为$S_{\\rm unif}$。为此测试用例输出绝对差$\\left|S_{\\rm grid} - S_{\\rm unif}\\right|$，作为一个浮点数。\n\n- 测试用例B（通过随机星表验证非均匀选区）：\n  - 参数：$L = 200$, $N = 48$, 空间变化的平均密度\n    $$ \\bar n(\\mathbf x) = n_0 \\left[1 + a \\sin\\left(\\frac{2\\pi x}{L}\\right)\\sin\\left(\\frac{2\\pi y}{L}\\right)\\sin\\left(\\frac{2\\pi z}{L}\\right)\\right], $$\n    其中 $n_0 = 2 \\times 10^{-3}$ 且 $a = 0.4$。使用$w(\\mathbf x) \\equiv 1$。\n  - 在网格上根据你的通用公式计算$S_{\\rm grid}$。\n  - 使用从盒子中与$\\bar n(\\mathbf x)$成正比的概率密度抽取的随机星表，通过蒙特卡洛积分独立地估计相同的量。使用足够大量的蒙特卡洛样本，并基于与$\\bar n(\\mathbf x)$成正比的目标的重要性采样，返回相同表达式的蒙特卡洛估计值$S_{\\rm MC}$。\n  - 为此测试用例输出绝对差$\\left|S_{\\rm grid} - S_{\\rm MC}\\right|$，作为一个浮点数。\n\n- 测试用例C（FKP加权的端到端零检验）：\n  - 参数：$L = 200$, $N = 48$，与测试用例B中相同的$\\bar n(\\mathbf x)$，FKP权重，$P_0 = 5000$。\n  - 根据$\\bar n_i$为每个单元抽取一个泊松实现，并使用你的估计器和推导出的$S$计算所有非零$\\mathbf k$模式的$\\hat P(\\mathbf k)$。\n  - 输出所有非零模式下$\\hat P(\\mathbf k)$均值的绝对值，作为一个浮点数。在没有成团性的情况下，如果散粒噪声减除是正确的，这个量应该接近于零。\n\n最终输出格式：\n\n- 你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例A、B和C的顺序排列：\n  - 对于测试用例A：浮点数$\\left|S_{\\rm grid} - S_{\\rm unif}\\right|$。\n  - 对于测试用例B：浮点数$\\left|S_{\\rm grid} - S_{\\rm MC}\\right|$。\n  - 对于测试用例C：浮点数$\\left|\\langle \\hat P(\\mathbf k) \\rangle_{\\mathbf k \\ne 0}\\right|$。\n- 示例格式（所示数字为占位符）：\"[0.00123,4.56e-06,0.0000789]\"。", "solution": "用户提供的问题陈述已经过验证，被认为是合理、适定且具有科学依据的。我们继续进行解答，其中包括理论推导，随后是数值实现和验证测试的解释。\n\n### 1. 散粒噪声项的推导\n\n目标是为功率谱估计器$\\hat P(\\mathbf k)$推导散粒噪声减除项$S$。推导从非均匀泊松点过程的第一性原理开始。\n\n加权涨落场$F(\\mathbf{x})$定义为：\n$$\nF(\\mathbf{x}) = w(\\mathbf{x}) \\left[ n(\\mathbf{x}) - \\bar{n}(\\mathbf{x}) \\right]\n$$\n其中$n(\\mathbf{x})$是实现的数密度，$\\bar{n}(\\mathbf{x})$是泊松过程的平均数密度（或强度），$w(\\mathbf{x})$是空间权重函数。\n\n该场的傅里叶变换由下式给出：\n$$\nF(\\mathbf{k}) = \\int_V F(\\mathbf{x}) e^{i \\mathbf{k} \\cdot \\mathbf{x}} d^3x\n$$\n问题将模式$\\mathbf{k}$的功率谱估计器定义为：\n$$\n\\hat P(\\mathbf{k}) = \\frac{|F(\\mathbf{k})|^2}{I_1^2} - S\n$$\n为使该估计器在没有物理成团性的情况下是无偏的，其期望值必须为零。因此，散粒噪声项$S$必须等于在无成团性零假设下第一项的期望值。\n$$\nS = \\left\\langle \\frac{|F(\\mathbf{k})|^2}{I_1^2} \\right\\rangle_{\\xi=0}\n$$\n这里，$\\xi$表示两点相关函数。我们计算分子，$\\langle |F(\\mathbf{k})|^2 \\rangle_{\\xi=0}$。\n\n首先，我们展开$|F(\\mathbf{k})|^2 = F(\\mathbf{k}) F^*(\\mathbf{k})$：\n$$\n\\langle|F(\\mathbf{k})|^2\\rangle = \\left\\langle \\left( \\int_V F(\\mathbf{x}) e^{i \\mathbf{k} \\cdot \\mathbf{x}} d^3x \\right) \\left( \\int_V F(\\mathbf{y}) e^{-i \\mathbf{k} \\cdot \\mathbf{y}} d^3y \\right) \\right\\rangle\n$$\n根据期望算子的线性性质，这变为：\n$$\n\\langle|F(\\mathbf{k})|^2\\rangle = \\iint_V \\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle e^{i \\mathbf{k} \\cdot (\\mathbf{x} - \\mathbf{y})} d^3x d^3y\n$$\n接下来，我们计算加权场的两点相关函数$\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle$：\n$$\n\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle = \\langle w(\\mathbf{x})[n(\\mathbf{x}) - \\bar{n}(\\mathbf{x})] w(\\mathbf{y})[n(\\mathbf{y}) - \\bar{n}(\\mathbf{y})] \\rangle = w(\\mathbf{x}) w(\\mathbf{y}) \\left[ \\langle n(\\mathbf{x}) n(\\mathbf{y}) \\rangle - \\bar{n}(\\mathbf{x})\\bar{n}(\\mathbf{y}) \\right]\n$$\n问题给出了一个通用点过程的协方差：\n$$\n\\langle n(\\mathbf{x}) n(\\mathbf{y}) \\rangle = \\bar{n}(\\mathbf{x}) \\bar{n}(\\mathbf{y}) [1 + \\xi(\\mathbf{x}, \\mathbf{y})] + \\bar{n}(\\mathbf{x}) \\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y})\n$$\n其中$\\delta_{\\rm D}$是狄拉克δ分布。将此代入$\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle$的表达式中：\n$$\n\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle = w(\\mathbf{x}) w(\\mathbf{y}) \\left[ \\bar{n}(\\mathbf{x}) \\bar{n}(\\mathbf{y}) \\xi(\\mathbf{x}, \\mathbf{y}) + \\bar{n}(\\mathbf{x}) \\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y}) \\right]\n$$\n我们关心的是散粒噪声贡献，即在没有成团性（$\\xi(\\mathbf{x}, \\mathbf{y}) = 0$）时的值。\n$$\n\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle_{\\xi=0} = w(\\mathbf{x}) w(\\mathbf{y}) \\bar{n}(\\mathbf{x}) \\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y})\n$$\n由于狄拉克δ函数$\\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y})$，该表达式仅在$\\mathbf{x} = \\mathbf{y}$时非零。因此，我们可以用$w(\\mathbf{x})$替换$w(\\mathbf{y})$：\n$$\n\\langle F(\\mathbf{x}) F(\\mathbf{y}) \\rangle_{\\xi=0} = w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) \\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y})\n$$\n现在，我们将其代回到$\\langle |F(\\mathbf{k})|^2 \\rangle$的积分中：\n$$\n\\langle |F(\\mathbf{k})|^2 \\rangle_{\\xi=0} = \\iint_V w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) \\delta_{\\rm D}(\\mathbf{x} - \\mathbf{y}) e^{i \\mathbf{k} \\cdot (\\mathbf{x} - \\mathbf{y})} d^3x d^3y\n$$\n对$\\mathbf{y}$积分会使δ函数坍缩：\n$$\n\\langle |F(\\mathbf{k})|^2 \\rangle_{\\xi=0} = \\int_V w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) e^{i \\mathbf{k} \\cdot (\\mathbf{x} - \\mathbf{x})} d^3x = \\int_V w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) d^3x\n$$\n这个量代表了来自散粒噪声的总功率，并且它与波矢量$\\mathbf{k}$无关。我们将此积分表示为$I_S$：\n$$\nI_S = \\int_V w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) d^3x\n$$\n问题指出，估计器由$I_1^2$归一化，其中$I_1$是“巡天权重积分”。在此背景下，对此积分的一个标准且合乎逻辑的选择是：\n$$\nI_1 = \\int_V w(\\mathbf{x}) \\bar{n}(\\mathbf{x}) d^3x\n$$\n该积分与巡天中天体总数的加权期望成正比。我们将采用这个定义。\n\n根据这些定义，确保$\\langle \\hat P(\\mathbf{k}) \\rangle_{\\xi=0} = 0$的散粒噪声项$S$为：\n$$\nS = \\frac{\\langle |F(\\mathbf{k})|^2 \\rangle_{\\xi=0}}{I_1^2} = \\frac{\\int_V w(\\mathbf{x})^2 \\bar{n}(\\mathbf{x}) d^3x}{\\left( \\int_V w(\\mathbf{x}) \\bar{n}(\\mathbf{x}) d^3x \\right)^2}\n$$\n这就是散粒噪声减除项的最终表达式。\n\n### 2. 离散化实现和验证计划\n\n现在将连续推导转换为一个用于$N^3$个单元（每个体积为$\\Delta V = (L/N)^3$）的立方体网格的离散算法。积分被替换为对网格单元的求和，索引为$i$：\n$$\nI_S \\rightarrow I_{S, \\text{grid}} = \\sum_{i=1}^{N^3} w_i^2 \\bar{n}_i \\Delta V\n$$\n$$\nI_1 \\rightarrow I_{1, \\text{grid}} = \\sum_{i=1}^{N^3} w_i \\bar{n}_i \\Delta V\n$$\n那么，离散的散粒噪声项为：\n$$\nS_{\\text{grid}} = \\frac{I_{S, \\text{grid}}}{I_{1, \\text{grid}}^2}\n$$\n涨落场$F_i = w_i(n_i - \\bar{n}_i)$的离散傅里叶变换由$F(\\mathbf k) \\approx \\Delta V \\sum_i F_i e^{i \\mathbf k \\cdot \\mathbf x_i}$给出。这可以使用快速傅里叶变换（FFT）高效计算。具体来说，如果$\\mathcal{F}$表示`numpy.fft`中的`ifftn`例程（它使用正指数），那么对于波矢量网格的$F(\\mathbf k)$计算为$L^3 \\times \\mathcal{F}[F_i]$。然后其模的平方为$|F(\\mathbf k)|^2$。\n\n验证计划按照指定的三个测试用例进行。\n\n**测试用例A（均匀基线一致性）：**\n这里，$\\bar{n}(\\mathbf{x}) = n_0$ 且 $w(\\mathbf{x}) = 1$。$S_{\\text{grid}}$的离散公式给出：\n$S_{\\text{grid}} = \\frac{\\sum_i 1^2 n_0 \\Delta V}{(\\sum_i 1 \\cdot n_0 \\Delta V)^2} = \\frac{N^3 n_0 \\Delta V}{(N^3 n_0 \\Delta V)^2} = \\frac{n_0 L^3}{(n_0 L^3)^2} = \\frac{1}{n_0 L^3}$。\n从第一性原理推导的均匀场极限预测$S_{\\text{unif}}$得出相同的结果。该测试要求计算绝对差$|S_{\\text{grid}} - S_{\\text{unif}}|$，在浮点精度范围内，该值应为零。\n\n**测试用例B（通过蒙特卡洛验证非均匀选区）：**\n这里，$\\bar{n}(\\mathbf{x})$是空间变化的，且$w(\\mathbf{x}) = 1$。$S_{\\text{grid}}$使用通用的离散公式计算。\n对于蒙特卡洛估计$S_{\\text{MC}}$，我们必须估计量$S = 1 / \\int_V \\bar{n}(\\mathbf{x}) d^3x$。积分$I_{\\text{norm}} = \\int_V \\bar{n}(\\mathbf{x}) d^3x$按规定使用蒙特卡洛积分法进行估计。我们为$\\bar{n}(\\mathbf{x})$定义一个高度为$n_{\\text{max}} = \\max_{\\mathbf x} \\bar{n}(\\mathbf{x})$的边界框。我们在体积$V \\times [0, n_{\\text{max}}]$中生成$N_{\\text{tot}}$个均匀随机点$(\\mathbf{x}_j, u_j)$。接受的点数$N_{\\text{acc}}$是那些满足$u_j  \\bar{n}(\\mathbf{x}_j)$的点。然后积分估计为$\\hat{I}_{\\text{norm}} = (N_{\\text{acc}} / N_{\\text{tot}}) \\times n_{\\text{max}} \\times L^3$。接着，$S_{\\text{MC}} = 1/\\hat{I}_{\\text{norm}}$。该测试计算$|S_{\\text{grid}} - S_{\\text{MC}}|$。\n\n**测试用例C（FKP加权的端到端零检验）：**\n此测试验证整个估计器流程。对于空间变化的$\\bar{n}(\\mathbf{x})$和FKP权重$w_{\\text{FKP}}(\\mathbf{x}) = [1 + \\bar{n}(\\mathbf{x}) P_0]^{-1}$，我们首先使用完整的离散公式计算散粒噪声项$S$。然后，我们生成泊松场的单个实现：对于每个单元$i$，从均值为$\\mu_i = \\bar{n}_i \\Delta V$的泊松分布中抽取天体数$N_i$。这给出了实现的密度$n_i = N_i / \\Delta V$。由此，我们计算涨落场$F_i$、其傅里叶变换$F(\\mathbf{k})$，最后计算所有非零波矢量的估计功率谱$\\hat P(\\mathbf{k}) = |F(\\mathbf{k})|^2/I_{1,\\text{grid}}^2 - S$。由于底层场没有成团性，$\\hat P(\\mathbf{k})$的期望为零。该测试计算所有$\\mathbf{k} \\neq \\mathbf{0}$的模式上$\\hat P(\\mathbf{k})$均值的绝对值。对于单个实现，该值会很小但非零，代表样本方差。对许多模式进行平均会减小此方差，因此结果应接近于零。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates the FKP weighted power spectrum estimator's\n    shot-noise subtraction term.\n    \"\"\"\n\n    def get_shot_noise(n_bar, w, L, N):\n        \"\"\"\n        Computes the shot noise term S from the derived formula on a grid.\n        S = (Integral(w^2 * n_bar) / Integral(w * n_bar)^2)\n        \"\"\"\n        delta_V = (L / N)**3\n        \n        # Numerator integral: I_S = Integral(w^2 * n_bar dV)\n        integrand_S = w**2 * n_bar\n        I_S_grid = np.sum(integrand_S) * delta_V\n        \n        # Denominator integral: I_1 = Integral(w * n_bar dV)\n        integrand_1 = w * n_bar\n        I_1_grid = np.sum(integrand_1) * delta_V\n        \n        S_grid = I_S_grid / (I_1_grid**2)\n        return S_grid, I_1_grid\n\n    # --- Test Case A: Uniform Baseline Consistency ---\n    def test_case_a():\n        L = 200.0\n        N = 48\n        n0 = 2.0e-3\n        \n        # Setup grid\n        n_bar_grid = np.full((N, N, N), n0)\n        w_grid = np.ones((N, N, N))\n        \n        # Compute S_grid from the general formula\n        S_grid, _ = get_shot_noise(n_bar_grid, w_grid, L, N)\n        \n        # Compute S_unif from the analytical prediction for a uniform field\n        V = L**3\n        S_unif = 1.0 / (n0 * V)\n        \n        return np.abs(S_grid - S_unif)\n\n    # --- Test Case B: Nonuniform Selection Validation by MC ---\n    def test_case_b():\n        L = 200.0\n        N = 48\n        n0 = 2.0e-3\n        a = 0.4\n        \n        # Setup grid and fields\n        grid_coords = np.linspace(0, L, N, endpoint=False) + 0.5 * (L/N)\n        X, Y, Z = np.meshgrid(grid_coords, grid_coords, grid_coords, indexing='ij')\n        \n        k_factor = 2.0 * np.pi / L\n        sin_term = np.sin(k_factor * X) * np.sin(k_factor * Y) * np.sin(k_factor * Z)\n        n_bar_grid = n0 * (1.0 + a * sin_term)\n        w_grid = np.ones((N, N, N))\n        \n        # Compute S_grid from the general formula\n        S_grid, _ = get_shot_noise(n_bar_grid, w_grid, L, N)\n        \n        # Compute S_MC by Monte Carlo integration (rejection sampling)\n        N_tot = 2 * 10**7\n        n_max = n0 * (1.0 + a)\n        V = L**3\n        \n        # Using vectorized operations for efficiency\n        rand_pos = np.random.uniform(0, L, (N_tot, 3))\n        rand_u = np.random.uniform(0, n_max, N_tot)\n        \n        n_bar_values = n0 * (1.0 + a * np.prod(np.sin(k_factor * rand_pos), axis=1))\n        \n        N_acc = np.sum(rand_u  n_bar_values)\n        \n        I_norm_mc = (N_acc / N_tot) * n_max * V\n        S_mc = 1.0 / I_norm_mc\n        \n        return np.abs(S_grid - S_mc)\n\n    # --- Test Case C: FKP-Weighted End-to-End Null Test ---\n    def test_case_c():\n        L = 200.0\n        N = 48\n        n0 = 2.0e-3\n        a = 0.4\n        P0 = 5000.0\n        \n        # Setup grid and fields\n        delta_V = (L / N)**3\n        grid_coords = np.linspace(0, L, N, endpoint=False) + 0.5 * (L/N)\n        X, Y, Z = np.meshgrid(grid_coords, grid_coords, grid_coords, indexing='ij')\n        \n        k_factor = 2.0 * np.pi / L\n        sin_term = np.sin(k_factor * X) * np.sin(k_factor * Y) * np.sin(k_factor * Z)\n        n_bar_grid = n0 * (1.0 + a * sin_term)\n        \n        # FKP weights\n        w_grid = 1.0 / (1.0 + n_bar_grid * P0)\n        \n        # Compute shot noise S and normalization I_1\n        S, I_1_grid = get_shot_noise(n_bar_grid, w_grid, L, N)\n        \n        # Generate a Poisson realization\n        mu_grid = n_bar_grid * delta_V\n        np.random.seed(42) # for reproducibility\n        N_grid = np.random.poisson(mu_grid)\n        n_grid = N_grid / delta_V\n        \n        # Compute the fluctuation field\n        F_grid = w_grid * (n_grid - n_bar_grid)\n        \n        # Compute its Fourier transform. F(k) = L^3 * ifftn(F_i)\n        F_k_grid = L**3 * np.fft.ifftn(F_grid)\n        \n        # Compute the unbiased power spectrum estimator P_hat(k)\n        P_hat_k = np.abs(F_k_grid)**2 / I_1_grid**2 - S\n        \n        # Calculate the mean of P_hat(k) over all k != 0 modes\n        # The k=0 mode is at index (0,0,0)\n        num_modes = N**3 - 1\n        mean_P_hat = (np.sum(P_hat_k) - P_hat_k[0, 0, 0]) / num_modes\n        \n        return np.abs(mean_P_hat)\n\n    # Run all test cases and collect results\n    results = [\n        test_case_a(),\n        test_case_b(),\n        test_case_c()\n    ]\n    \n    # Format and print the final output string\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n\n```", "id": "3486501"}, {"introduction": "将连续的物理场离散化到网格上是数值宇宙学中的常规操作，但这会引入数值伪影。将粒子质量分配到网格的不同方案（即质量分配方案）会影响测量的功率谱，特别是由于混叠效应（aliasing）会改变高波数下的散粒噪声。本练习提供了一个系统性的框架，用于基准测试几种流行的质量分配方案（NGP, CIC, TSC, PCS）以及“交错网格”（interlacing）等抑制混叠的技术。通过这项实践，你将能够量化不同方法导致的残余散粒噪声偏差，并学会为特定的分析任务选择最优的数值策略。[@problem_id:3486486]", "problem": "要求您设计并实现一个完整的、可运行的程序，该程序使用第一性原理的混叠求和模型，对周期性立方体体积中，在使用和不使用交错网格法的情况下，不同质量分配方案下的散粒噪声减除进行基准测试。目标是量化在减去基线泊松散粒噪声后，各向同性功率谱中的残余散粒噪声偏差，并确定在固定网格尺寸下哪种质量分配方案能使该偏差最小化。设置、定义和所需输出如下所述。\n\n考虑一个边长为 $L$ 的周期性、立方体、三维（$3$-维）盒子，该盒子在每边有 $N$ 个单元的均匀网格上离散化，单元尺寸为 $\\Delta x = L/N$，并将单个粒子质量分配到网格上。网格的离散傅里叶变换采用离散傅里叶模式的标准约定。设基本波数为 $k_{\\mathrm{f}} = 2\\pi/L$，单轴奈奎斯特波数为 $k_{\\mathrm{N}} = \\pi/\\Delta x = \\pi N/L$。对于平均数密度为 $\\bar{n}$ 的均匀泊松点过程，其系综平均连续功率谱是白噪声，振幅为 $P_{\\mathrm{shot}} = 1/\\bar{n}$，单位为体积（即 $L^{3}$）。质量分配将场与一个核进行卷积，在网格上采样会引起混叠；在傅里叶空间中通过质量分配窗函数进行反卷积后，估计的功率谱 $P_{\\mathrm{est}}(k)$ 与真实的常数 $P_{\\mathrm{shot}}$ 因残余的混叠贡献而不同。交错网格法（使用两个网格的平均值，其中一个网格沿每个轴平移半个单元，并进行适当的傅里叶相位补偿）会抵消所有其整数镜像矢量分量之和为奇数的混叠图像，从而减少混叠功率。\n\n您必须从以下基本原理出发：\n- 周期性体积中泊松点过程的定义，以及其系综平均两点相关函数在非零分离处为零的事实，这意味着功率谱是振幅为 $P_{\\mathrm{shot}}$ 的白噪声。\n- 实空间中的卷积对应于傅里叶空间中乘以一个窗函数，而在网格上的均匀采样会在傅里叶空间中产生连续谱的周期性复制（泊松求和）。\n- 对于阶数 $p \\in \\{0,1,2,3\\}$ 的B样条方案，其一维质量分配窗函数为 $W_{p}^{(1\\mathrm{D})}(k) = \\left[\\mathrm{sinc}\\left(k \\Delta x/2\\right)\\right]^{p+1}$，其中 $\\mathrm{sinc}(x) \\equiv \\sin(x)/x$；在三维空间中为 $W_{p}^{(3\\mathrm{D})}(k_{x},k_{y},k_{z}) = \\prod_{i\\in\\{x,y,z\\}} W_{p}^{(1\\mathrm{D})}(k_{i})$。这些分别对应于最近邻网格点法（NGP, $p=0$）、云中单元法（CIC, $p=1$）、三角形状云法（TSC, $p=2$）和分段三次样条法（PCS, $p=3$）。\n- 通过 $W_{p}^{(3\\mathrm{D})}$ 反卷积后，在波矢量 $\\boldsymbol{k}$ 处，由整数矢量 $\\boldsymbol{m} \\in \\mathbb{Z}^{3}\\setminus\\{\\boldsymbol{0}\\}$（每轴间距为 $2 k_{\\mathrm{N}}$）平移的图像所产生的残余混叠功率由窗函数比率 $\\left|W_{p}^{(3\\mathrm{D})}\\left(\\boldsymbol{k} + 2 k_{\\mathrm{N}} \\boldsymbol{m}\\right)/W_{p}^{(3\\mathrm{D})}(\\boldsymbol{k})\\right|^{2}$ 控制。使用交错网格法时，只有偶宇称（$\\sum_{i} m_{i}$ 为偶数）的图像有贡献；奇宇称的图像被抵消。\n\n使用这些事实推导出一个在离散模式 $\\boldsymbol{k}$ 处的分数残余散粒噪声偏差的可计算表达式，定义为比率\n$$\n\\mathcal{R}_{p}(\\boldsymbol{k}) \\equiv \\frac{P_{\\mathrm{est}}(\\boldsymbol{k}) - P_{\\mathrm{shot}}}{P_{\\mathrm{shot}}} ,\n$$\n该表达式用质量分配窗和离散混叠图像表示。然后，对所有模长 $k$ 在 $0   k \\leq \\alpha \\, k_{\\mathrm{N}}$ 范围内的离散傅里叶模式进行球面平均，以获得每种方案的平均偏差 $\\overline{\\mathcal{R}}_{p}(\\alpha)$。这里 $\\alpha \\in (0,1]$ 是相对于单轴奈奎斯特波数的分数截止值。因为该比率是无量纲的，所以不需要带单位的输出；但您必须在中间推理中保持量纲一致性。对于数值计算，将混叠求和截断为整数镜像矢量的立方体，其中每个轴的 $|m_{i}| \\leq m_{\\max}$ 且 $\\boldsymbol{m} \\neq \\boldsymbol{0}$；使用交错网格法时，只包括 $\\sum_{i} m_{i}$ 为偶数的偶宇称图像。\n\n您的程序必须：\n- 将盒子尺寸固定为 $L = 1$（任意体积单位），网格每边为 $N = 32$，因此所有报告的功率谱值都以 $L^{3} = 1$ 为单位，分数残差是无量纲的。\n- 考虑分别对应于 NGP, CIC, TSC, PCS 的四种方案 $p \\in \\{0,1,2,3\\}$。\n- 对于每个选定的 $\\alpha$，通过对所有满足 $0   k \\leq \\alpha \\, k_{\\mathrm{N}}$ 的离散傅里叶模式上的 $\\mathcal{R}_{p}(\\boldsymbol{k})$ 进行平均，计算平均分数残差 $\\overline{\\mathcal{R}}_{p}(\\alpha)$。\n- 分别在不使用和使用上述定义的交错网格法的情况下执行此操作。\n- 对于每个 $\\alpha$，在非交错和交错情况下，分别确定使 $\\overline{\\mathcal{R}}_{p}(\\alpha)$ 最小化的方案索引 $p$。\n\n测试套件和所需输出：\n- 使用 $m_{\\max} = 3$。\n- 评估三个截止值 $\\alpha \\in \\{0.5, 0.7, 0.95\\}$。\n- 对于每个 $\\alpha$，按顺序输出四个值：不使用交错网格法时使 $\\overline{\\mathcal{R}}_{p}(\\alpha)$ 最小化的整数索引 $p$，使用交错网格法时使 $\\overline{\\mathcal{R}}_{p}(\\alpha)$ 最小化的整数索引 $p$，不使用交错网格法时的相应最小平均残差（浮点数），以及使用交错网格法时的相应最小平均残差（浮点数）。映射关系为 $p = 0 \\rightarrow$ NGP, $p = 1 \\rightarrow$ CIC, $p = 2 \\rightarrow$ TSC, $p = 3 \\rightarrow$ PCS。\n- 您的程序应生成一行输出，其中包含三个 $\\alpha$ 值的全部结果，按 $\\alpha = 0.5$、$\\alpha = 0.7$、$\\alpha = 0.95$ 的顺序连接，形式为用方括号括起来的逗号分隔列表（例如，“[$p_{0.5}^{\\mathrm{no}},p_{0.5}^{\\mathrm{int}},\\overline{\\mathcal{R}}_{0.5}^{\\mathrm{no}},\\overline{\\mathcal{R}}_{0.5}^{\\mathrm{int}},p_{0.7}^{\\mathrm{no}},\\dots$]”）。所有数字必须以其原生数值格式打印（方案索引为整数，残差为浮点数）。", "solution": "该问题要求设计并实现一个程序，用于对数值宇宙学中的散粒噪声减除技术进行基准测试。核心任务是计算不同质量分配方案在有无交错网格法情况下的平均分数残余散粒噪声偏差，并针对给定参数确定最优方案。解决方案必须从第一性原理推导。\n\n### 第1步：理论推导\n\n分析始于一个体积为 $V=L^3$ 的周期性立方体盒子中的均匀泊松粒子分布。这样一个过程的系综平均功率谱是“白”噪声，意味着对于所有波数 $\\boldsymbol{k} \\neq \\boldsymbol{0}$，其值是恒定的。其振幅由 $P_{\\mathrm{shot}} = 1/\\bar{n}$ 给出，其中 $\\bar{n}$ 是粒子的平均数密度。\n\n在数值上估计功率谱时，首先将连续的粒子分布分配到一个离散的网格上。这个过程等效于将连续密度场 $\\rho(\\boldsymbol{x})$ 与一个质量分配核 $W_p^{(3\\mathrm{D}, \\text{real})}(\\boldsymbol{x})$ 进行卷积，然后在 $N^3$ 个单元（间距为 $\\Delta x = L/N$）的网格上对结果进行采样。\n\n根据卷积定理，该操作对应于傅里叶空间中的乘法。网格分配密度的连续傅里叶变换是 $\\tilde{\\rho}_g(\\boldsymbol{k}) = \\tilde{\\rho}(\\boldsymbol{k}) W_p^{(3\\mathrm{D})}(\\boldsymbol{k})$，其中 $\\tilde{\\rho}(\\boldsymbol{k})$ 是粒子密度的傅里叶变换，而 $W_p^{(3\\mathrm{D})}(\\boldsymbol{k})$ 是核的傅里叶变换，称为质量分配窗函数。\n\n随后的网格采样会在傅里叶空间中引起混叠。采样场在离散波矢量 $\\boldsymbol{k}_{\\text{d}}$ 处的离散傅里叶变换（DFT）由泊松求和公式给出，该公式将连续谱在所有模采样频率同余的波矢量上的贡献相加。采样波数为 $k_s = 2\\pi/\\Delta x = 2k_{\\text{N}}$，其中 $k_{\\text{N}} = \\pi/\\Delta x$ 是奈奎斯特波数。因此，DFT 模式 $\\hat{\\rho}_g(\\boldsymbol{k}_{\\text{d}})$ 为：\n$$\n\\hat{\\rho}_g(\\boldsymbol{k}_{\\text{d}}) \\propto \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3} \\tilde{\\rho}_g(\\boldsymbol{k}_{\\text{d}} + 2k_{\\text{N}}\\boldsymbol{m}) = \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3} \\tilde{\\rho}(\\boldsymbol{k}_{\\text{d}} + 2k_{\\text{N}}\\boldsymbol{m}) W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}} + 2k_{\\text{N}}\\boldsymbol{m})\n$$\n其中 $\\boldsymbol{m}$ 是一个整数矢量。\n\n来自 DFT 的原始功率谱 $\\hat{P}_{\\text{raw}}(\\boldsymbol{k}_{\\text{d}})$ 与傅里叶模式模长的平方的系综平均成正比。对于泊松过程，$\\tilde{\\rho}(\\boldsymbol{k})$ 在不同 $\\boldsymbol{k}$ 处的相位是随机且不相关的。因此，交叉项的系综平均为零：\n$$\n\\hat{P}_{\\text{raw}}(\\boldsymbol{k}_{\\text{d}}) \\propto \\langle|\\hat{\\rho}_g(\\boldsymbol{k}_{\\text{d}})|^2\\rangle = \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3} \\langle|\\tilde{\\rho}(\\boldsymbol{k}_{\\text{d}} + 2k_{\\text{N}}\\boldsymbol{m})|^2\\rangle |W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}} + 2k_{\\text{N}}\\boldsymbol{m})|^2\n$$\n由于底层的功率谱是白噪声，对于任何 $\\boldsymbol{k} \\neq \\boldsymbol{0}$，都有 $\\langle|\\tilde{\\rho}(\\boldsymbol{k})|^2\\rangle/V = P_{\\text{shot}}$。经过正确归一化，原始功率为：\n$$\n\\hat{P}_{\\text{raw}}(\\boldsymbol{k}_{\\text{d}}) = P_{\\text{shot}} \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3} |W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}} + 2k_{\\text{N}}\\boldsymbol{m})|^2\n$$\n为了获得估计的功率谱 $P_{\\text{est}}(\\boldsymbol{k}_{\\text{d}})$，我们必须对主频率（$\\boldsymbol{m}=\\boldsymbol{0}$）处的质量分配窗效应进行反卷积。这通过将原始功率除以 $|W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}})|^2$ 来完成：\n$$\nP_{\\text{est}}(\\boldsymbol{k}_{\\text{d}}) = \\frac{\\hat{P}_{\\text{raw}}(\\boldsymbol{k}_{\\text{d}})}{|W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}})|^2} = P_{\\text{shot}} \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3} \\frac{|W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}} + 2k_{\\text{N}}\\boldsymbol{m})|^2}{|W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}})|^2}\n$$\n分数残余散粒噪声偏差 $\\mathcal{R}_p(\\boldsymbol{k}_{\\text{d}})$ 定义为 $(P_{\\text{est}} - P_{\\text{shot}}) / P_{\\text{shot}}$。代入 $P_{\\text{est}}$ 的表达式并将 $\\boldsymbol{m}=\\boldsymbol{0}$ 项从求和中分离出来，得到：\n$$\n\\mathcal{R}_p(\\boldsymbol{k}_{\\text{d}}) = \\left( \\frac{|W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}})|^2}{|W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}})|^2} + \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3\\setminus\\{\\boldsymbol{0}\\}} \\frac{|W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}} + 2k_{\\text{N}}\\boldsymbol{m})|^2}{|W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}})|^2} \\right) - 1\n$$\n$$\n\\mathcal{R}_p(\\boldsymbol{k}_{\\text{d}}) = \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3\\setminus\\{\\boldsymbol{0}\\}} \\left| \\frac{W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}} + 2k_{\\text{N}}\\boldsymbol{m})}{W_p^{(3\\mathrm{D})}(\\boldsymbol{k}_{\\text{d}})} \\right|^2\n$$\n该表达式量化了在减去主散粒噪声功率后，来自混叠图像的残余功率。\n\nB样条窗函数由 $W_{p}^{(1\\mathrm{D})}(k) = [\\mathrm{sinc}(k \\Delta x/2)]^{p+1}$ 和 $W_{p}^{(3\\mathrm{D})}(\\boldsymbol{k}) = \\prod_{i\\in\\{x,y,z\\}} W_{p}^{(1\\mathrm{D})}(k_{i})$ 给出。一个离散波矢量分量是 $k_i = n_i (2\\pi/L)$，其中 $n_i$ 是一个整数模式指数。混叠位移后的分量是 $k_i' = k_i + 2k_{\\text{N}}m_i = (n_i + N m_i)(2\\pi/L)$。sinc 函数的参数变为 $k_i \\Delta x/2 = n_i \\pi/N$ 和 $k_i' \\Delta x/2 = (n_i + N m_i)\\pi/N$。利用属性 $\\sin(x+m\\pi) = (-1)^m \\sin(x)$，一维窗函数之比可大幅简化：\n$$\n\\frac{W_p^{(1\\mathrm{D})}(k_i')}{W_p^{(1\\mathrm{D})}(k_i)} = \\left( \\frac{\\mathrm{sinc}((n_i/N + m_i)\\pi)}{\\mathrm{sinc}(n_i\\pi/N)} \\right)^{p+1} = \\left( \\frac{(-1)^{m_i} n_i}{n_i + N m_i} \\right)^{p+1}\n$$\n这个简化形式在 $n_i \\neq 0$ 时有效。如果 $n_i=0$，当 $m_i \\neq 0$ 时比值为 $0$，当 $m_i=0$ 时为 $1$。具有整数指数 $\\boldsymbol{n}=(n_x, n_y, n_z)$ 的模式的分数偏差为：\n$$\n\\mathcal{R}_p(\\boldsymbol{n}) = \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3\\setminus\\{\\boldsymbol{0}\\}} \\left| \\prod_{j \\in \\{x,y,z\\}} \\left( \\frac{(-1)^{m_j} n_j}{n_j+N m_j} \\right)^{p+1} \\right|^2 = \\sum_{\\boldsymbol{m} \\in \\mathbb{Z}^3\\setminus\\{\\boldsymbol{0}\\}} \\left( \\prod_{j \\in \\{x,y,z\\}} \\left( \\frac{n_j}{n_j+N m_j} \\right)^{p+1} \\right)^2\n$$\n因子 $(-1)^{\\sum m_j}$ 在平方后消失。\n\n对于交错方案，两个相互偏移 $\\Delta x/2$ 的网格的密度场在相位校正后进行平均。此过程会抵消分量之和 $\\sum_i m_i$ 为奇数的混叠图像 $\\boldsymbol{m}$。$\\mathcal{R}_p(\\boldsymbol{n})$ 的公式保持不变，但求和仅限于宇称为偶数（$\\sum_i m_i$ 为偶数）的矢量 $\\boldsymbol{m}$。\n\n### 第2步：算法设计\n\n程序将实现为 $\\mathcal{R}_p(\\boldsymbol{n})$ 推导出的公式，并执行所需的平均和比较。\n\n1.  **常量和网格**：定义数值参数 $L=1$, $N=32$, $m_{\\max}=3$ 和阶数集合 $p \\in \\{0,1,2,3\\}$。使用 `numpy.fft.fftfreq` 和 `numpy.meshgrid` 生成表示整数模式指数 $n_x, n_y, n_z$ 的三维网格。计算相应的波矢量模长 $|\\boldsymbol{k}|$。\n2.  **混叠矢量**：生成所有满足 $|m_i| \\le m_{\\max}$ 且 $\\boldsymbol{m} \\neq \\boldsymbol{0}$ 的混叠矢量 $\\boldsymbol{m}=(m_x, m_y, m_z)$ 的列表。\n3.  **场景迭代**：遍历每个 $\\alpha \\in \\{0.5, 0.7, 0.95\\}$ 值。\n    *   对于每个 $\\alpha$，确定波数截止值 $k_{\\text{cut}} = \\alpha k_{\\text{N}}$，并为所有满足 $0   |\\boldsymbol{k}| \\le k_{\\text{cut}}$ 的网格模式 $\\boldsymbol{k}$ 创建一个布尔掩码。\n    *   遍历每个方案阶数 $p \\in \\{0, 1, 2, 3\\}$。\n    *   对于非交错和交错两种情况：\n        1.  初始化一个三维网格，用于存储总残余偏差 $\\mathcal{R}_p$，并将其值设为零。\n        2.  遍历每个混叠矢量 $\\boldsymbol{m}$。对于交错情况，跳过宇称为奇数（$\\sum_i m_i$ 为奇数）的矢量。\n        3.  对于每个矢量 $\\boldsymbol{m}$，计算混叠贡献的三维网格。这是通过计算每个轴的一维比率项 `(n_j / (n_j + N*m_j))` 的乘积来完成的，同时要正确处理 $n_j=0$ 的情况（此时如果 $m_j \\neq 0$，比率为零）。\n        4.  将得到的总比率网格提升到 $2(p+1)$ 次幂，并加到总残余偏差网格 $\\mathcal{R}_p$ 上。\n        5.  在对所有相关的 $\\boldsymbol{m}$ 求和后，通过对 $\\mathcal{R}_p$ 网格中由波数掩码选定的活动模式的值进行平均，计算平均残余偏差。\n    *   存储每个 $p$ 计算出的平均偏差。\n4.  **结果聚合**：对于当前的 $\\alpha$，分别找到在非交错和交错情况下导致最小平均偏差的方案索引 $p$。记录这些索引及其对应的最小偏差值。\n5.  **输出**：将所有 $\\alpha$ 值的结果连接成一个列表，并以指定的逗号分隔格式打印。\n\n这种结构化方法利用向量化的 `NumPy` 操作，将推导出的物理模型直接映射为一个计算高效且稳健的算法。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the minimal residual shot-noise bias for different mass-assignment\n    schemes as specified in the problem statement.\n    \"\"\"\n    # Problem parameters\n    L = 1.0\n    N = 32\n    m_max = 3\n    alphas = [0.5, 0.7, 0.95]\n    p_orders = [0, 1, 2, 3]  # NGP, CIC, TSC, PCS\n\n    # Derived constants\n    Delta_x = L / N\n    k_f = 2 * np.pi / L\n    k_N = np.pi / Delta_x\n\n    # Generate integer mode indices n_i for the DFT grid\n    # np.fft.fftfreq(N) gives [0, 1/N, .. N/2/N, .., -1/N]\n    # Multiply by N to get integer indices [0, 1, .. N/2, .., -1]\n    n_vals = np.fft.fftfreq(N) * N\n    nx, ny, nz = np.meshgrid(n_vals, n_vals, n_vals, indexing='ij')\n\n    # Calculate wavenumber magnitudes for each grid point\n    kx = nx * k_f\n    ky = ny * k_f\n    kz = nz * k_f\n    k_mags = np.sqrt(kx**2 + ky**2 + kz**2)\n\n    # Generate list of alias vectors m != 0\n    m_vals = np.arange(-m_max, m_max + 1)\n    m_vectors = []\n    for mx in m_vals:\n        for my in m_vals:\n            for mz in m_vals:\n                if mx == 0 and my == 0 and mz == 0:\n                    continue\n                m_vectors.append((mx, my, mz))\n\n    final_results = []\n\n    def get_ratio_contrib(n_grid, m_val, N_grid):\n        \"\"\"\n        Calculates the contribution to the alias ratio for one axis.\n        The ratio is n / (n + N*m).\n        \"\"\"\n        if m_val == 0:\n            # If m_j = 0, the ratio is 1, so it doesn't contribute to the product.\n            return np.ones_like(n_grid, dtype=float)\n        else:\n            # If m_j != 0, the ratio is n_j / (n_j + N*m_j).\n            # This is 0 if n_j = 0.\n            # We use np.divide to handle n_j=0 safely.\n            ratio = np.divide(n_grid, n_grid + N_grid * m_val,\n                              out=np.zeros_like(n_grid, dtype=float),\n                              where=(n_grid != 0))\n            return ratio\n\n    for alpha in alphas:\n        k_cutoff = alpha * k_N\n        # Mask for averaging: 0  k = alpha * k_N\n        mask = (k_mags > 0)  (k_mags = k_cutoff)\n\n        results_no_interlace = []\n        results_interlace = []\n\n        for p in p_orders:\n            # Non-interlaced case\n            R_grid_no_interlace = np.zeros((N, N, N), dtype=float)\n            for mx, my, mz in m_vectors:\n                ratio_x = get_ratio_contrib(nx, mx, N)\n                ratio_y = get_ratio_contrib(ny, my, N)\n                ratio_z = get_ratio_contrib(nz, mz, N)\n                \n                total_ratio = ratio_x * ratio_y * ratio_z\n                term = total_ratio**(2 * (p + 1))\n                R_grid_no_interlace += term\n            \n            mean_R_no_interlace = np.mean(R_grid_no_interlace[mask])\n            results_no_interlace.append(mean_R_no_interlace)\n\n            # Interlaced case\n            R_grid_interlace = np.zeros((N, N, N), dtype=float)\n            for mx, my, mz in m_vectors:\n                # Skip odd-parity images for interlacing\n                if (mx + my + mz) % 2 != 0:\n                    continue\n                \n                ratio_x = get_ratio_contrib(nx, mx, N)\n                ratio_y = get_ratio_contrib(ny, my, N)\n                ratio_z = get_ratio_contrib(nz, mz, N)\n\n                total_ratio = ratio_x * ratio_y * ratio_z\n                term = total_ratio**(2 * (p + 1))\n                R_grid_interlace += term\n            \n            mean_R_interlace = np.mean(R_grid_interlace[mask])\n            results_interlace.append(mean_R_interlace)\n\n        # Find the scheme p that minimizes the residual for the current alpha\n        min_R_no_interlace = min(results_no_interlace)\n        min_p_no_interlace = p_orders[results_no_interlace.index(min_R_no_interlace)]\n\n        min_R_interlace = min(results_interlace)\n        min_p_interlace = p_orders[results_interlace.index(min_R_interlace)]\n\n        final_results.extend([min_p_no_interlace, min_p_interlace,\n                              min_R_no_interlace, min_R_interlace])\n\n    # Print the final concatenated results in the required format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```", "id": "3486486"}, {"introduction": "在功率谱分析中，一个常见且令人困惑的结果是在减去散粒噪声后，在高波数（小尺度）处出现负的功率值。这种情况可能由多种原因造成，准确诊断其来源至关重要。本练习将指导你设计并实现一种强大的诊断技术，通过构建模拟的“mock”巡天数据来区分两种主要可能性：一是由于对平均密度估计不准而导致的散粒噪声“过减除”，二是测量窗口函数将大尺度功率“泄露”到了小尺度。这项实践旨在培养你在处理实际数据分析时进行科学推理和问题排查的关键技能。[@problem_id:3486487]", "problem": "给定一组实测的带功率，它们在减去 $1/\\bar n$ 后在高 $k$ 区域变为负值。在数值宇宙学的背景下，考虑一个用于巡天窗口的一维玩具模型，以设计一种基于原理的诊断方法，该方法能够区分散粒噪声的过度扣除和由窗口函数引起的大尺度功率泄露。该诊断方法必须基于由一个可控的底层功率谱构建、并经过窗口函数卷积的模拟带功率。最终交付成果是一个完整、可运行的程序，该程序实现此诊断方法，并为提供的测试套件输出分类结果。\n\n从以下基本原理出发：\n\n- 实空间中的星系超密度场，乘以一个巡天窗口函数 $W(x)$，在傅里叶空间中对应于真实谱与窗口核的卷积。具体而言，实空间中的乘法对应于傅里叶空间中的卷积。\n- 对于离散示踪物的泊松采样，其对功率谱的散粒噪声贡献近似为一个常数，等于 $1/\\bar n$，其中 $\\bar n$ 是平均数密度。\n- 在窗口函数作用下，实测的伪带功率被建模为经窗口卷积的真实功率加上一个恒定的散粒噪声项。\n\n使用两组经窗口卷积的模拟带功率来设计一个诊断程序：\n\n- 构建一个具有完整大尺度功率的模拟数据，其特征由一个平滑谱 $P_{\\mathrm{true}}(k)$ 描述。\n- 构建另一个模拟数据，其中大尺度功率在一个截断波数 $k_{\\mathrm{cut}}$ 以下被抑制，从而得到一个修正谱 $P_{\\mathrm{cut}}(k)$。\n\n在两个模拟数据中使用相同的巡天窗口。对于该巡天窗口，将实空间窗口建模为一个长度为 $L$ 的顶帽函数，其傅里叶空间核与波数差的 sinc 函数的平方成正比。将波数在一个最小值和一个最大值之间的均匀网格上离散化为 $N$ 个区间，并通过一个矩阵将窗口卷积近似为离散混合，该矩阵的元素仅取决于波数差，并以一种在每个输出行上保持总功率的方式进行归一化。对于完整模拟数据，使用以下真实谱形式：\n$$\nP_{\\mathrm{true}}(k) = \\frac{A_0}{1 + \\left(\\frac{k}{k_0}\\right)^2}.\n$$\n通过设定当 $k \\le k_{\\mathrm{cut}}$ 时 $P_{\\mathrm{cut}}(k) = 0$ 且当 $k  k_{\\mathrm{cut}}$ 时 $P_{\\mathrm{cut}}(k) = P_{\\mathrm{true}}(k)$ 来定义截断模拟数据。\n\n给定真实平均密度 $\\bar n_{\\mathrm{true}}$ 的值和假设值 $\\bar n_{\\mathrm{assumed}}$，将伪带功率构建为经窗口卷积的功率加上恒定的散粒噪声 $1/\\bar n_{\\mathrm{true}}$。根据这些模拟数据，定义以下诊断量，这些量是在由波数网格中比例为 $f_{\\mathrm{high}}$ 的最高波数区间所组成的高 $k$ 子集上计算的：\n\n- 有效散粒噪声估计值 $S_{\\mathrm{eff}}$，即截断模拟数据的伪带功率在高 $k$ 区域的平均值。\n- 泄露度量 $L_{\\mathrm{metric}}$，即完整模拟数据的伪带功率在高 $k$ 区域的平均值与截断模拟数据的伪带功率在高 $k$ 区域的平均值之间的差值。\n\n使用阈值 $\\tau = 0.05 \\times \\left(1/\\bar n_{\\mathrm{assumed}}\\right)$，按如下方式对高 $k$ 处带功率为负的原因进行分类：\n\n- 过度扣除：如果 $1/\\bar n_{\\mathrm{assumed}} - S_{\\mathrm{eff}}  \\tau$ 且 $L_{\\mathrm{metric} } \\le \\tau$。\n- 窗口引起的泄露：如果 $L_{\\mathrm{metric}}  \\tau$ 且 $1/\\bar n_{\\mathrm{assumed}} - S_{\\mathrm{eff}} \\le \\tau$。\n- 无法明确：如果上述两个条件同时为真或同时为假。\n\n您的程序必须实现上述诊断方法，并为以下测试套件生成分类。每个测试用例提供 $\\left(N, L, A_0, k_0, \\bar n_{\\mathrm{true}}, \\bar n_{\\mathrm{assumed}}, k_{\\mathrm{cut}}, f_{\\mathrm{high}}\\right)$：\n\n- 测试用例 1 (过度扣除的理想情况): $\\left(256, 200.0, 10^{-3}, 0.05, 1000.0, 800.0, 0.03, 0.3\\right)$。\n- 测试用例 2 (泄露的理想情况): $\\left(256, 20.0, 5\\times 10^{-3}, 0.02, 1000.0, 1000.0, 0.03, 0.3\\right)$。\n- 测试用例 3 (混合贡献，边界情况): $\\left(256, 20.0, 3\\times 10^{-3}, 0.02, 1000.0, 900.0, 0.03, 0.3\\right)$。\n- 测试用例 4 (边界情况，无强效应): $\\left(256, 200.0, 10^{-3}, 0.05, 1000.0, 1000.0, 0.03, 0.3\\right)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，顺序与测试用例一致。使用以下整数代码进行分类：$0$ 代表过度扣除，$1$ 代表泄露，$2$ 代表无法明确。例如，如果结果是这些，输出格式必须为 $\\left[0,1,2,2\\right]$。\n\n所有计算都是无量纲的；不需要物理单位。不涉及角度。所有导出的数值答案在内部表示为浮点值。最终输出必须是如上所述的单行整数列表。", "solution": "该问题要求设计并实现一个诊断程序，用以区分在扣除散粒噪声后，高波数（$k$）处的功率谱带功率出现负值的两种潜在原因：1) 因星系平均密度（$\\bar{n}$）估计不准导致的散粒噪声过度扣除，以及 2) 由巡天窗口函数引起的大尺度（低 $k$）功率向小尺度（高 $k$）的泄露。该诊断方法在一个简化的一维玩具模型中构建。\n\n其核心原理是构建两个模拟数据集来分离这些效应。一个模拟数据包含完整的宇宙学功率，而第二个模拟数据中的大尺度功率被人为移除。通过比较这两个模拟数据，我们可以量化泄露的贡献，并将其与散粒噪声相关的效应解耦。整个过程通过一系列明确定义的计算步骤来实现。\n\n首先，我们建立计算域。连续的波数 $k$ 在一个有限范围 $[k_{\\min}, k_{\\max}]$ 内被离散化为 $N$ 个均匀的区间。根据问题的特征尺度（$k_0 \\approx 0.02-0.05$），选择一个合理的范围，例如 $k_{\\min} = 0$ 到 $k_{\\max} = 1.0$。每个区间 $i$ 的中心记为 $k_i$。\n\n接下来，我们定义底层的理论功率谱。完整、平滑的功率谱 $P_{\\mathrm{true}}(k)$ 由一个类洛伦兹函数建模：\n$$\nP_{\\mathrm{true}}(k) = \\frac{A_0}{1 + \\left(\\frac{k}{k_0}\\right)^2}\n$$\n其中 $A_0$ 是振幅，$k_0$ 是一个特征尺度。为了分离大尺度功率的效应，定义了第二个谱 $P_{\\mathrm{cut}}(k)$。这个“截断”谱与 $P_{\\mathrm{true}}(k)$ 相同，但在某个截断波数 $k_{\\mathrm{cut}}$ 以下被设为零：\n$$\nP_{\\mathrm{cut}}(k) = \\begin{cases} 0  k \\le k_{\\mathrm{cut}} \\\\ P_{\\mathrm{true}}(k)  k  k_{\\mathrm{cut}} \\end{cases}\n$$\n这两个谱以在各区间中心 $k_i$ 处取值的向量形式表示，作为我们模拟观测的基准真相。\n\n必须对巡天窗口函数的影响进行建模。在位形空间中，观测到的星系场是真实场与窗口函数 $W(x)$ 的乘积。在傅里叶空间中，这对应于真实功率谱与窗口的功率谱（或核）的卷积。对于一个长度为 $L$ 的顶帽窗口，其傅里叶核与一个 sinc 函数的平方成正比。这个卷积通过一个混合矩阵 $M$ 进行离散近似。元素 $M_{ij}$ 量化了从输入区间 $k_j$ “泄露”到输出区间 $k_i$ 的功率大小。它由以下公式给出：\n$$\nM_{ij} \\propto \\mathrm{sinc}^2\\left(\\frac{L(k_i - k_j)}{2}\\right)\n$$\n其中 sinc 函数为 $\\mathrm{sinc}(x) = \\sin(x)/x$。矩阵 $M$ 的构造方式是使其每行之和为 1（对于所有 $i$，$\\sum_j M_{ij} = 1$）。这种归一化确保了平坦的输入谱在卷积后保持平坦，从而在特定意义上使功率守恒。\n\n有了这些组件，我们就可以构建模拟的伪带功率。它们模仿了在真实巡天中会测量到的数据。它们是经窗口卷积的真实功率加上一个由示踪物真实平均密度决定的恒定散粒噪声项 $1/\\bar{n}_{\\mathrm{true}}$：\n$$\n\\vec{P}_{\\mathrm{pseudo}}^{\\mathrm{full}} = M \\cdot \\vec{P}_{\\mathrm{true}} + \\frac{1}{\\bar{n}_{\\mathrm{true}}}\n$$\n$$\n\\vec{P}_{\\mathrm{pseudo}}^{\\mathrm{cut}} = M \\cdot \\vec{P}_{\\mathrm{cut}} + \\frac{1}{\\bar{n}_{\\mathrm{true}}}\n$$\n这里，$\\vec{P}_{\\mathrm{true}}$ 和 $\\vec{P}_{\\mathrm{cut}}$ 是在每个 $k_i$ 处的功率谱值向量，$M \\cdot \\vec{P}$ 表示矩阵-向量乘法。\n\n该诊断依赖于在“高 $k$”区域计算的两个量，该区域定义为波数区间中比例为 $f_{\\mathrm{high}}$ 的最高部分。\n第一个诊断量是有效散粒噪声估计值 $S_{\\mathrm{eff}}$。它是截断模拟数据的伪带功率在高 $k$ 区域的平均值：\n$$\nS_{\\mathrm{eff}} = \\mathrm{mean}\\left( \\left(\\vec{P}_{\\mathrm{pseudo}}^{\\mathrm{cut}}\\right)_{\\mathrm{high-}k} \\right)\n$$\n通过使用截断模拟数据，我们移除了泄露的主要来源（$k \\le k_{\\mathrm{cut}}$ 处的功率）。因此，$S_{\\mathrm{eff}}$ 代表真实散粒噪声与任何从中等尺度（$k  k_{\\mathrm{cut}}$）泄露到高 $k$ 区域的残余功率之和。\n\n第二个诊断量是泄露度量 $L_{\\mathrm{metric}}$。它是完整模拟数据和截断模拟数据在高 $k$ 区域的平均功率之差：\n$$\nL_{\\mathrm{metric}} = \\mathrm{mean}\\left( \\left(\\vec{P}_{\\mathrm{pseudo}}^{\\mathrm{full}}\\right)_{\\mathrm{high-}k} \\right) - \\mathrm{mean}\\left( \\left(\\vec{P}_{\\mathrm{pseudo}}^{\\mathrm{cut}}\\right)_{\\mathrm{high-}k} \\right)\n$$\n这个差值抵消了公共的散粒噪声项和任何来自 $k  k_{\\mathrm{cut}}$ 的泄露，从而完美地分离出从大尺度（$k \\le k_{\\mathrm{cut}}$）泄露到高 $k$ 波段的功率。\n\n最后，基于这些度量进行分类。假设要扣除的散粒噪声是 $1/\\bar{n}_{\\mathrm{assumed}}$。与有效散粒噪声的偏差为 $1/\\bar{n}_{\\mathrm{assumed}} - S_{\\mathrm{eff}}$。我们定义一个显著性阈值 $\\tau = 0.05 \\times (1/\\bar{n}_{\\mathrm{assumed}})$。\n- **过度扣除 (代码 $0$)**：如果散粒噪声差异显著而泄露不显著，则判定为此类：$1/\\bar{n}_{\\mathrm{assumed}} - S_{\\mathrm{eff}}  \\tau$ 且 $L_{\\mathrm{metric}} \\le \\tau$。这表明负带功率主要是由于扣除了过大的散粒噪声值造成的。\n- **窗口引起的泄露 (代码 $1$)**：如果泄露显著而散粒噪声差异很小，则判定为此类：$L_{\\mathrm{metric}}  \\tau$ 且 $1/\\bar{n}_{\\mathrm{assumed}} - S_{\\mathrm{eff}} \\le \\tau$。这表明主要问题是来自低 $k$ 模式的功率污染了高 $k$ 区间。\n- **无法明确 (代码 $2$)**：此类别适用于两种效应都显著（$L_{\\mathrm{metric}}  \\tau$ 且 $1/\\bar{n}_{\\mathrm{assumed}} - S_{\\mathrm{eff}}  \\tau$）或两者都不显著（$L_{\\mathrm{metric}} \\le \\tau$ 且 $1/\\bar{n}_{\\mathrm{assumed}} - S_{\\mathrm{eff}} \\le \\tau$）的情况。\n\n这种基于原理、基于模型的方法为诊断宇宙学功率谱估计中的异常来源提供了一种定量且可自动化的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _run_diagnostic_case(params):\n    \"\"\"\n    Runs the diagnostic procedure for a single test case.\n\n    Args:\n        params (tuple): A tuple containing the parameters for the test case:\n            (N, L, A0, k0, n_true, n_assumed, k_cut, f_high).\n\n    Returns:\n        int: The classification code (0, 1, or 2).\n    \"\"\"\n    # Step 0: Unpack parameters\n    N, L, A0, k0, n_true, n_assumed, k_cut, f_high = params\n\n    # Step 1: Set up the wavenumber grid\n    # Assuming a fixed, reasonable k-range for all cases is sufficient for the diagnostic.\n    k_min, k_max = 0.0, 1.0\n    delta_k = (k_max - k_min) / N\n    # Bin centers\n    k_bins = k_min + (np.arange(N) + 0.5) * delta_k\n    \n    # Step 2: Define the underlying power spectra\n    P_true = A0 / (1.0 + (k_bins / k0)**2)\n    P_cut = np.where(k_bins = k_cut, 0, P_true)\n\n    # Step 3: Construct the window convolution matrix M\n    # Create a matrix of wavenumber differences: k_diff[i, j] = k_bins[i] - k_bins[j]\n    k_diff_matrix = k_bins[:, np.newaxis] - k_bins[np.newaxis, :]\n    \n    # The argument for the sinc function is L * (ki - kj) / 2\n    # To use np.sinc(x) = sin(pi*x)/(pi*x), the argument should be x = arg / pi.\n    sinc_arg = L * k_diff_matrix / (2.0 * np.pi)\n    \n    # Unnormalized mixing matrix M_ij ~ sinc^2(L*(ki-kj)/2)\n    M_unnormalized = np.sinc(sinc_arg)**2\n    \n    # Normalize rows to sum to 1\n    row_sums = M_unnormalized.sum(axis=1, keepdims=True)\n    # Avoid division by zero, though unlikely as diagonal elements are 1 before normalization\n    row_sums[row_sums == 0] = 1.0\n    M = M_unnormalized / row_sums\n\n    # Step 4: Calculate convolved power spectra\n    P_conv_true = M @ P_true\n    P_conv_cut = M @ P_cut\n\n    # Step 5: Construct pseudo-bandpowers\n    shot_noise_true = 1.0 / n_true\n    P_pseudo_full = P_conv_true + shot_noise_true\n    P_pseudo_cut = P_conv_cut + shot_noise_true\n\n    # Step 6: Calculate diagnostic quantities\n    # Define high-k region indices\n    num_high_k_bins = int(N * f_high)\n    high_k_indices = slice(N - num_high_k_bins, N)\n\n    # Effective shot-noise estimate\n    S_eff = np.mean(P_pseudo_cut[high_k_indices])\n\n    # Leakage metric\n    # L_metric = mean(P_pseudo_full_high) - mean(P_pseudo_cut_high)\n    # This simplifies to mean over the convolution of the difference spectrum\n    P_diff = P_true - P_cut\n    P_conv_diff = M @ P_diff\n    L_metric = np.mean(P_conv_diff[high_k_indices])\n\n    # Step 7: Classify the case\n    shot_noise_assumed = 1.0 / n_assumed\n    tau = 0.05 * shot_noise_assumed\n\n    cond_oversub = (shot_noise_assumed - S_eff) > tau\n    cond_leakage = L_metric > tau\n\n    if cond_oversub and not cond_leakage:\n        return 0  # Over-subtraction\n    elif not cond_oversub and cond_leakage:\n        return 1  # Window-induced leakage\n    else:\n        # This covers (cond_oversub and cond_leakage) or (not cond_oversub and not not_leakage)\n        return 2  # Ambiguous\n\ndef solve():\n    \"\"\"\n    Main function to run the diagnostic on the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple: (N, L, A0, k0, n_true, n_assumed, k_cut, f_high)\n    test_cases = [\n        (256, 200.0, 1e-3, 0.05, 1000.0, 800.0, 0.03, 0.3),    # Case 1\n        (256, 20.0, 5e-3, 0.02, 1000.0, 1000.0, 0.03, 0.3),  # Case 2\n        (256, 20.0, 3e-3, 0.02, 1000.0, 900.0, 0.03, 0.3),    # Case 3\n        (256, 200.0, 1e-3, 0.05, 1000.0, 1000.0, 0.03, 0.3),  # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _run_diagnostic_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3486487"}]}