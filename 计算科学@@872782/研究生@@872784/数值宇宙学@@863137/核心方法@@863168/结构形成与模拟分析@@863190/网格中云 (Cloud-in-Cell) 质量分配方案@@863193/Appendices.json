{"hands_on_practices": [{"introduction": "在深入研究云胞单元（Cloud-In-Cell, CIC）质量分配方案引入的数值误差并加以修正之前，我们首先需要从解析上理解其基本性质。本练习将引导你推导CIC在傅里叶空间中的窗函数，并揭示其在大尺度（小$k$）下的行为，证明它等效于一个高斯平滑滤波器。理解这种平滑效应是认识CIC系统误差来源的关键第一步[@problem_id:3466986]。", "problem": "在宇宙学 $N$ 体模拟的粒子-网格方法中，云中网格 (CIC) 质量分配方案将每个粒子的质量线性地分配到一维空间中最近的两个网格点上。设网格间距为 $\\,\\Delta\\,$，定义云中网格 (CIC) 的一维归一化实空间分配核为\n$$\nK_{\\mathrm{CIC}}(x) \\equiv \n\\begin{cases}\n\\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right),  & |x| \\le \\Delta, \\\\\n0, & |x| > \\Delta,\n\\end{cases}\n$$\n该核函数满足 $\\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\mathrm{d}x = 1$。考虑一个连续密度场 $\\,\\rho(x)\\,$ 及其通过卷积得到的网格对应场 $\\,\\rho_{\\mathrm{grid}}(x) = \\int_{-\\infty}^{\\infty} \\rho(x')\\,K_{\\mathrm{CIC}}(x-x')\\,\\mathrm{d}x'$。在傅里叶空间中，该分配操作相当于将真实场的变换乘以一个窗函数 $\\,W_{1\\mathrm{D}}(k)\\,$，该窗函数由傅里叶变换定义：\n$$\nW_{1\\mathrm{D}}(k) \\equiv \\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\n\n从以上定义出发，不使用任何预先制表的傅里叶变换对或专门的质量分配公式，推导出 $\\,W_{1\\mathrm{D}}(k)\\,$，并获得其小 $k$ 展开，直至并包括 $\\,k^{2}\\,$ 项。然后，将主导有效平滑长度 $\\,R_{\\mathrm{eff}}\\,$ 定义为唯一的正量，使得\n$$\nW_{1\\mathrm{D}}(k) \\;=\\; 1 \\;-\\; \\frac{(k\\,R_{\\mathrm{eff}})^{2}}{2} \\;+\\; \\mathcal{O}(k^{4})\n\\quad\\text{for } k \\to 0,\n$$\n并仅用 $\\,\\Delta\\,$ 表示 $\\,R_{\\mathrm{eff}}\\,$。你的最终答案必须是仅用 $\\,\\Delta\\,$ 表示 $\\,R_{\\mathrm{eff}}\\,$ 的单个闭式解析表达式。最终答案中不得包含任何单位，也不得报告级数余项符号 $\\,\\mathcal{O}(k^{4})\\,$。", "solution": "根据指定的验证程序，对问题陈述进行严格评估。\n\n### 步骤1：提取已知条件\n- 云中网格 (CIC) 的一维归一化实空间分配核由以下公式给出：\n$$\nK_{\\mathrm{CIC}}(x) \\equiv \n\\begin{cases}\n\\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right),  & |x| \\le \\Delta, \\\\\n0, & |x| > \\Delta,\n\\end{cases}\n$$\n- 该核函数被归一化，使得 $\\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\mathrm{d}x = 1$。\n- 网格分配密度场通过卷积与连续场相关：$\\rho_{\\mathrm{grid}}(x) = \\int_{-\\infty}^{\\infty} \\rho(x')\\,K_{\\mathrm{CIC}}(x-x')\\,\\mathrm{d}x'$。\n- 傅里叶空间窗函数 $W_{1\\mathrm{D}}(k)$ 是核函数的傅里叶变换：\n$$\nW_{1\\mathrm{D}}(k) \\equiv \\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\n- $W_{1\\mathrm{D}}(k)$ 的小 $k$ 行为定义了有效平滑长度 $R_{\\mathrm{eff}}$：\n$$\nW_{1\\mathrm{D}}(k) \\;=\\; 1 \\;-\\; \\frac{(k\\,R_{\\mathrm{eff}})^{2}}{2} \\;+\\; \\mathcal{O}(k^{4})\n\\quad\\text{for } k \\to 0,\n$$\n其中 $R_{\\mathrm{eff}}$ 是唯一的正量。\n\n### 步骤2：使用提取的已知条件进行验证\n对问题的有效性进行评估：\n- **科学依据充分**：该问题基于计算宇宙学中标准且成熟的概念和方法，特别是粒子-网格 N 体模拟技术。CIC 分配方案及其傅里叶表示是该领域的基本组成部分。\n- **提法恰当**：问题陈述清晰，包含所有必要的定义和约束。目标是进行一项具体的推导，并计算一个有唯一定义且存在唯一解的量。\n- **客观性**：语言精确、正式，没有任何主观或模糊的术语。\n\n### 步骤3：结论与行动\n该问题是**有效的**。它是在特定背景下的标准数学物理推导。将按要求提供解答。\n\n第一步是通过计算核函数 $K_{\\mathrm{CIC}}(x)$ 的傅里叶变换来推导窗函数 $W_{1\\mathrm{D}}(k)$ 的解析形式。\n从定义出发：\n$$\nW_{1\\mathrm{D}}(k) = \\int_{-\\infty}^{\\infty} K_{\\mathrm{CIC}}(x)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\n我们代入 $K_{\\mathrm{CIC}}(x)$ 的分段定义。核函数仅在 $|x| \\le \\Delta$ 时非零，因此积分限变为 $[-\\Delta, \\Delta]$：\n$$\nW_{1\\mathrm{D}}(k) = \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\exp(-\\mathrm{i} k x)\\,\\mathrm{d}x.\n$$\n使用欧拉公式 $\\exp(-\\mathrm{i} k x) = \\cos(kx) - \\mathrm{i}\\sin(kx)$，我们可以将积分拆分为：\n$$\nW_{1\\mathrm{D}}(k) = \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x - \\mathrm{i} \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\sin(k x)\\,\\mathrm{d}x.\n$$\n函数 $\\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)$ 是关于 $x$ 的偶函数。函数 $\\sin(kx)$ 是关于 $x$ 的奇函数。偶函数与奇函数的乘积是奇函数。奇函数在对称区间 $[-\\Delta, \\Delta]$ 上的积分为零。因此，积分的虚部为零。\n剩余的被积函数是两个偶函数的乘积，结果为偶函数。我们可以简化积分的实部：\n$$\nW_{1\\mathrm{D}}(k) = 2 \\int_{0}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x.\n$$\n对于 $x \\ge 0$，$|x| = x$，因此表达式变为：\n$$\nW_{1\\mathrm{D}}(k) = \\frac{2}{\\Delta} \\int_{0}^{\\Delta} \\left(1 - \\frac{x}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x.\n$$\n这个积分可以用分部积分法求解，即 $\\int u\\,\\mathrm{d}v = uv - \\int v\\,\\mathrm{d}u$。令 $u = 1 - \\frac{x}{\\Delta}$ 且 $\\mathrm{d}v = \\cos(kx)\\,\\mathrm{d}x$。这意味着 $\\mathrm{d}u = -\\frac{1}{\\Delta}\\,\\mathrm{d}x$ 且 $v = \\frac{1}{k}\\sin(kx)$。\n$$\n\\int_{0}^{\\Delta} \\left(1 - \\frac{x}{\\Delta}\\right)\\,\\cos(k x)\\,\\mathrm{d}x = \\left[\\left(1 - \\frac{x}{\\Delta}\\right)\\frac{\\sin(kx)}{k}\\right]_{0}^{\\Delta} - \\int_{0}^{\\Delta} \\frac{\\sin(kx)}{k} \\left(-\\frac{1}{\\Delta}\\right)\\,\\mathrm{d}x.\n$$\n第一项在两个积分限处的值都为零：在 $x=\\Delta$ 处，因子 $(1 - \\frac{\\Delta}{\\Delta}) = 0$；在 $x=0$ 处，因子 $\\sin(0) = 0$。\n表达式简化为：\n$$\n\\frac{1}{k\\Delta} \\int_{0}^{\\Delta} \\sin(kx)\\,\\mathrm{d}x = \\frac{1}{k\\Delta} \\left[-\\frac{\\cos(kx)}{k}\\right]_{0}^{\\Delta} = \\frac{1}{k^2\\Delta} \\left(-\\cos(k\\Delta) - (-\\cos(0))\\right) = \\frac{1 - \\cos(k\\Delta)}{k^2\\Delta}.\n$$\n将此结果代回 $W_{1\\mathrm{D}}(k)$ 的表达式中：\n$$\nW_{1\\mathrm{D}}(k) = \\frac{2}{\\Delta} \\left(\\frac{1 - \\cos(k\\Delta)}{k^2\\Delta}\\right) = \\frac{2(1 - \\cos(k\\Delta))}{(k\\Delta)^2}.\n$$\n接下来，我们求 $W_{1\\mathrm{D}}(k)$ 的小 $k$ 展开。我们使用余弦函数在 0 附近的泰勒级数：\n$$\n\\cos(y) = 1 - \\frac{y^2}{2!} + \\frac{y^4}{4!} - \\mathcal{O}(y^6).\n$$\n令 $y = k\\Delta$。那么对于小的 $k$，$y$ 也很小。\n$$\n1 - \\cos(k\\Delta) = 1 - \\left(1 - \\frac{(k\\Delta)^2}{2} + \\frac{(k\\Delta)^4}{24} - \\dots\\right) = \\frac{(k\\Delta)^2}{2} - \\frac{(k\\Delta)^4}{24} + \\mathcal{O}(k^6).\n$$\n将此代入 $W_{1\\mathrm{D}}(k)$ 的表达式中：\n$$\nW_{1\\mathrm{D}}(k) = \\frac{2}{(k\\Delta)^2} \\left[ \\frac{(k\\Delta)^2}{2} - \\frac{(k\\Delta)^4}{24} + \\mathcal{O}(k^6) \\right].\n$$\n分配前置因子，得到直至 $k^2$ 项的展开式：\n$$\nW_{1\\mathrm{D}}(k) = 1 - \\frac{2(k\\Delta)^4}{24(k\\Delta)^2} + \\mathcal{O}(k^4) = 1 - \\frac{(k\\Delta)^2}{12} + \\mathcal{O}(k^4).\n$$\n最后，我们将此推导出的展开式与问题陈述中给出的形式进行比较，该形式定义了有效平滑长度 $R_{\\mathrm{eff}}$：\n$$\nW_{1\\mathrm{D}}(k) = 1 - \\frac{(k R_{\\mathrm{eff}})^2}{2} + \\mathcal{O}(k^4).\n$$\n通过令两个表达式中 $k^2$ 项的系数相等，我们得到：\n$$\n\\frac{(k R_{\\mathrm{eff}})^2}{2} = \\frac{(k\\Delta)^2}{12}.\n$$\n$$\n\\frac{k^2 R_{\\mathrm{eff}}^2}{2} = \\frac{k^2 \\Delta^2}{12}.\n$$\n对于 $k \\neq 0$，我们可以两边同除以 $k^2$：\n$$\nR_{\\mathrm{eff}}^2 = \\frac{2\\Delta^2}{12} = \\frac{\\Delta^2}{6}.\n$$\n问题陈述 $R_{\\mathrm{eff}}$ 是一个正量。对两边取正平方根，得到 $R_{\\mathrm{eff}}$ 的所需表达式：\n$$\nR_{\\mathrm{eff}} = \\sqrt{\\frac{\\Delta^2}{6}} = \\frac{\\Delta}{\\sqrt{6}}.\n$$\n这是用网格间距 $\\Delta$ 表示有效平滑长度的闭式解析表达式。", "answer": "$$\\boxed{\\frac{\\Delta}{\\sqrt{6}}}$$", "id": "3466986"}, {"introduction": "我们通过理论分析了解了CIC方案的平滑特性，但其影响不止于此。本练习提供了一个直接的动手实践，让你体验另一个关键的数值疵瑕：“蛋盒”（eggbox）效应，这是一种破坏平移不变性的虚假力。通过实现一个简单的粒子-网格（Particle-Mesh, PM）求解器，你将亲自测量这些非物理的力，并理解它们如何依赖于粒子相对于网格的位置[@problem_id:3466963]。", "problem": "您的任务是设计并实现一个数值实验，以孤立并量化在粒子-网格（Particle-Mesh, PM）引力求解器中，由云中单元（Cloud-in-Cell, CIC）质量分配方案引入的伪各向异性力。该研究重点关注所谓的“蛋盒”印记：即使在演化一个原本均匀的构型时也会出现的、由网格引起的各向异性。您必须从第一性原理出发构建算法，并生成一个完整、可运行的程序，该程序计算单个粒子因其自身在周期性网格上的云中单元沉积而受到的伪力，然后测量由此产生的速度增量如何随网格间距和积分时间步长而变化。所有量均为无量纲；输出中不包含任何物理单位。\n\n从以下适合该背景的基础开始：\n\n- 粒子-网格（PM）方法通过将粒子质量沉积到规则网格上，在该网格上求解泊松方程以获得引力势，将力场计算为该网格上引力势的负梯度，并将力插值回粒子位置，来近似求解引力。\n- 在周期性盒子中，引力势遵循泊松方程，\n  $$\\nabla^2 \\Phi(\\mathbf{x}) = 4\\pi G\\left[\\rho(\\mathbf{x}) - \\bar{\\rho}\\right],$$\n  其中 $G$ 是引力常数，$\\rho(\\mathbf{x})$ 是质量密度，$\\bar{\\rho}$ 是其空间平均值。在周期性域中，拉普拉斯算子的傅里叶变换是对角的，并且必须将 $\\mathbf{k}=\\mathbf{0}$ 处的平均分量设置为零以避免发散。\n- 在 $d=2$ 维中，云中单元（CIC）质量分配使用可分离的三角形核。对于一个位于位置 $(x,y)$、网格间距为 $\\Delta$ 的粒子，令 $g_x = x/\\Delta$ 和 $g_y = y/\\Delta$，$i_0 = \\lfloor g_x \\rfloor$，$j_0 = \\lfloor g_y \\rfloor$，$f_x = g_x - i_0$ 和 $f_y = g_y - j_0$。那么，周围的四个网格节点 $(i_0,j_0)$、$(i_0+1,j_0)$、$(i_0,j_0+1)$ 和 $(i_0+1,j_0+1)$ 会接收到带有权重的质量分数\n  $$w_{x,0} = 1 - f_x,\\quad w_{x,1} = f_x,\\quad w_{y,0} = 1 - f_y,\\quad w_{y,1} = f_y,$$\n  每个单元面积的质量通过除以 $\\Delta^2$ 获得。相同的权重也用于将网格力插值回粒子位置。定义盒子大小为 $L$，每个维度的网格单元数为 $N$，因此 $\\Delta = L/N$。\n- 泊松方程在傅里叶空间中求解。令 $\\tilde{\\rho}(\\mathbf{k})$ 为密度的离散傅里叶变换。使用与二阶有限差分拉普拉斯算子相关的离散有效波数，\n  $$k_{\\mathrm{eff}}^2(\\mathbf{k}) = \\left(\\frac{2}{\\Delta}\\right)^2\\left[\\sin^2\\left(\\frac{k_x \\Delta}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta}{2}\\right)\\right],$$\n  其中离散波数为 $k_x = 2\\pi n_x / L$ 和 $k_y = 2\\pi n_y / L$，对于整数 $n_x, n_y \\in \\{0,1,\\dots,N-1\\}$ 且具有周期性排序。傅里叶空间中的势为\n  $$\\tilde{\\Phi}(\\mathbf{k}) = -\\frac{4\\pi G\\, \\tilde{\\rho}(\\mathbf{k})}{k_{\\mathrm{eff}}^2(\\mathbf{k})},$$\n  且 $\\tilde{\\Phi}(\\mathbf{0}) = 0$。变换回实空间以获得 $\\Phi(\\mathbf{x})$。\n- 网格力通过二阶中心有限差分计算，\n  $$F_x(i,j) = -\\frac{\\Phi(i+1,j) - \\Phi(i-1,j)}{2\\Delta},\\qquad F_y(i,j) = -\\frac{\\Phi(i,j+1) - \\Phi(i,j-1)}{2\\Delta},$$\n  具有周期性索引。粒子感受到插值后的力\n  $$\\mathbf{F}_p = \\sum_{a\\in\\{0,1\\}}\\sum_{b\\in\\{0,1\\}} \\left[w_{x,a} w_{y,b}\\right]\\, \\mathbf{F}(i_0+a, j_0+b).$$\n- 速度更新（“kick”）通过一个时间步长计算\n  $$\\Delta \\mathbf{v} = \\mathbf{F}_p\\, \\Delta t,$$\n  从零初始速度开始。\n\n您必须为一个位于边长 $L = 1$ 的二维周期性正方形盒子中的单个粒子实现上述流程，粒子质量 $m = 1$，引力常数 $G = 1$。密度必须减去其平均值，即在求解泊松方程时使用 $\\rho(\\mathbf{x}) - \\bar{\\rho}$。使用上面定义的离散有效波数 $k_{\\mathrm{eff}}^2(\\mathbf{k})$，并通过有限差分在实空间中计算梯度。力插值必须使用与质量分配相同的 CIC 权重。粒子被放置在盒子中心附近，位置为 $(x,y) = (L/2 + \\delta_x, L/2 + \\delta_y)$，其中 $(\\delta_x, \\delta_y)$ 是在一个单元格内的指定偏移量。\n\n任务：对于每个测试用例，计算一次“kick”后伪力的大小 $||\\mathbf{F}_p||$ 和由此产生的速度增量 $||\\Delta \\mathbf{v}||$。报告每个测试用例的这两个浮点数，以揭示各向异性和缩放关系。“蛋盒”印记的各向异性通过比较轴对齐与对角线子单元偏移的 $||\\mathbf{F}_p||$ 来揭示。与网格间距 $\\Delta$ 的缩放关系通过比较不同 $N$ 的结果来揭示，与时间步长 $\\Delta t$ 的缩放关系通过比较不同 $\\Delta t$ 的结果来揭示。\n\n测试套件：\n- 用例 1：$N=32$，$\\Delta t = 0.01$，轴向偏移 $(\\delta_x,\\delta_y) = (\\Delta/4, 0)$。\n- 用例 2：$N=32$，$\\Delta t = 0.01$，对角线偏移 $(\\delta_x,\\delta_y) = (\\Delta/4, \\Delta/4)$。\n- 用例 3：$N=16$，$\\Delta t = 0.01$，对角线偏移 $(\\delta_x,\\delta_y) = (\\Delta/4, \\Delta/4)$。\n- 用例 4：$N=32$，$\\Delta t = 0.005$，对角线偏移 $(\\delta_x,\\delta_y) = (\\Delta/4, \\Delta/4)$。\n- 用例 5：$N=32$，$\\Delta t = 0.01$，单元中心偏移 $(\\delta_x,\\delta_y) = (0, 0)$。\n\n对于每个测试用例 $i$，计算 $s_i = \\left\\lVert \\mathbf{F}_p \\right\\rVert$ 和 $u_i = \\left\\lVert \\Delta \\mathbf{v} \\right\\rVert$。您的程序应生成单行输出，其中包含结果，格式为方括号内用逗号分隔的列表，顺序如下\n$$[s_1,u_1,s_2,u_2,s_3,u_3,s_4,u_4,s_5,u_5].$$\n\n所有计算和输出均为无量纲实数。不出现角度。将所有最终输出表示为浮点数。任何地方都不出现百分比。程序必须是自包含的，并且不需要外部输入。", "solution": "用户提供的问题已经过验证，被认为是科学上合理、适定且自包含的。任务是实现一个数值实验，以测量在二维粒子-网格（Particle-Mesh, PM）引力模拟中，由云中单元（Cloud-in-Cell, CIC）质量分配方案产生的伪、网格诱导的各向异性力。该算法将按照规定从第一性原理构建。\n\nPM方法的核心包括四个步骤：\n1.  将粒子的质量分配到离散网格上，以定义密度场 $\\rho$。\n2.  在网格上求解泊松方程 $\\nabla^2 \\Phi = 4\\pi G (\\rho - \\bar{\\rho})$，以求得引力势 $\\Phi$。\n3.  将网格上的力场 $\\mathbf{F}$ 计算为势的负梯度，$\\mathbf{F} = -\\nabla \\Phi$。\n4.  将力从网格插值回粒子位置，以更新其速度。\n\n该过程将针对质量为 $m=1$ 的单个粒子在边长为 $L=1$ 的周期性方形盒子中实现，引力常数 $G=1$。目标是计算几种构型下伪自作用力的大小 $||\\mathbf{F}_p||$ 和由此产生的速度增量 $||\\Delta\\mathbf{v}||$。\n\n过程步骤如下：\n\n1.  **系统离散化和粒子放置**\n    模拟域是一个大小为 $L \\times L$ 的周期性正方形，其中 $L=1$。该域被离散化为一个 $N \\times N$ 单元的均匀网格，得到的网格间距为 $\\Delta = L/N$。对于每个由 $N$、时间步长 $\\Delta t$ 和子单元偏移 $(\\delta_x, \\delta_y)$ 指定的测试用例，一个质量为 $m=1$ 的单个粒子被放置在位置 $\\mathbf{p} = (x,y) = (L/2 + \\delta_x, L/2 + \\delta_y)$。\n\n2.  **质量分配：云中单元 (CIC)**\n    粒子的质量 $m$ 分布到 $N \\times N$ 网格上，以创建质量密度场 $\\rho_{ij}$。CIC 方案将质量分布到最近的四个网格节点。设粒子的位置为 $(x,y)$。其连续网格坐标为 $(g_x, g_y) = (x/\\Delta, y/\\Delta)$。这些坐标的整数部分标识了包含该粒子的单元的左下角：$(i_0, j_0) = (\\lfloor g_x \\rfloor, \\lfloor g_y \\rfloor)$。小数部分 $(f_x, f_y) = (g_x - i_0, g_y - j_0)$ 决定了双线性插值的权重。权重为 $w_{x,0} = 1 - f_x$，$w_{x,1} = f_x$，$w_{y,0} = 1 - f_y$ 和 $w_{y,1} = f_y$。质量 $m$ 根据权重乘积 $w_{x,a}w_{y,b}$ 分配给周围的四个节点 $(i_0+a, j_0+b)$，其中 $a,b \\in \\{0, 1\\}$。节点 $(i,j)$ 处的网格密度是分配的质量除以单元面积 $\\Delta^2$。考虑到周期性边界条件，节点 $(i,j)=( (i_0+a)\\%N, (j_0+b)\\%N )$ 处的密度增加 $m \\cdot w_{x,a} w_{y,b} / \\Delta^2$。\n\n3.  **在傅里叶空间中求解泊松方程**\n    泊松方程 $\\nabla^2 \\Phi(\\mathbf{x}) = 4\\pi G\\left[\\rho(\\mathbf{x}) - \\bar{\\rho}\\right]$ 在傅里叶空间中求解最为高效，因为在傅里叶空间中拉普拉斯算子 $\\nabla^2$ 变成简单的乘法。首先，使用二维离散傅里叶变换（DFT）将实空间密度网格 $\\rho_{ij}$ 变换到傅里叶空间，得到 $\\tilde{\\rho}(\\mathbf{k})$。通过将势的 $\\mathbf{k}=\\mathbf{0}$（直流）分量设置为零，即 $\\tilde{\\Phi}(\\mathbf{0}) = 0$，来处理 $\\rho(\\mathbf{x}) - \\bar{\\rho}$ 项。\n    离散波矢为 $\\mathbf{k} = (k_x, k_y)$，其分量为 $k_x = 2\\pi n_x/L$ 和 $k_y = 2\\pi n_y/L$，其中 $n_x, n_y$ 为整数。问题指定使用拉普拉斯算子的二阶有限差分近似，其傅里叶表示为有效波数的平方：\n    $$k_{\\mathrm{eff}}^2(\\mathbf{k}) = \\left(\\frac{2}{\\Delta}\\right)^2\\left[\\sin^2\\left(\\frac{k_x \\Delta}{2}\\right) + \\sin^2\\left(\\frac{k_y \\Delta}{2}\\right)\\right]$$\n    傅里叶空间中的势则计算为：\n    $$\\tilde{\\Phi}(\\mathbf{k}) = -\\frac{4\\pi G\\, \\tilde{\\rho}(\\mathbf{k})}{k_{\\mathrm{eff}}^2(\\mathbf{k})}$$\n    这对所有 $\\mathbf{k} \\neq \\mathbf{0}$ 进行计算。对于 $\\mathbf{k} = \\mathbf{0}$，我们设置 $\\tilde{\\Phi}(\\mathbf{0}) = 0$。最后，通过对 $\\tilde{\\Phi}(\\mathbf{k})$ 应用二维离散傅里叶逆变换（inverse 2D DFT），恢复实空间势 $\\Phi_{ij}$。\n\n4.  **网格上的力计算**\n    网格上的引力场 $\\mathbf{F}_{ij} = (F_{x,ij}, F_{y,ij})$ 计算为势的负梯度，$\\mathbf{F} = -\\nabla\\Phi$。这通过在势网格 $\\Phi_{ij}$ 上使用二阶中心有限差分格式来近似：\n    $$F_x(i,j) = -\\frac{\\Phi(i+1,j) - \\Phi(i-1,j)}{2\\Delta}$$\n    $$F_y(i,j) = -\\frac{\\Phi(i,j+1) - \\Phi(i,j-1)}{2\\Delta}$$\n    对索引 $(i,j)$ 应用周期性边界条件。\n\n5.  **力插值和速度更新**\n    粒子精确位置 $\\mathbf{p}$ 处的力是通过在质量分配步骤中得到的相同 CIC 权重，从周围四个节点的网格力插值得到的：\n    $$\\mathbf{F}_p = \\sum_{a\\in\\{0,1\\}}\\sum_{b\\in\\{0,1\\}} \\left[w_{x,a} w_{y,b}\\right]\\, \\mathbf{F}((i_0+a)\\%N, (j_0+b)\\%N)$$\n    在一个理想的、完全各向同性的系统中，空盒子里的单个粒子应受到的自作用力为零。任何非零力 $\\mathbf{F}_p$ 都是数值伪影。我们通过其大小 $s = ||\\mathbf{F}_p|| = \\sqrt{F_{p,x}^2 + F_{p,y}^2}$ 来量化这个伪力。\n    从静止开始，粒子的速度通过一个时间步长 $\\Delta t$ 的单次“kick”进行更新：\n    $$\\Delta \\mathbf{v} = \\mathbf{F}_p\\, \\Delta t$$\n    这个速度增量的大小是 $u = ||\\Delta \\mathbf{v}|| = ||\\mathbf{F}_p|| \\Delta t = s \\cdot \\Delta t$。\n\n对于每个测试用例，我们计算并报告值对 $(s, u)$。偏移量为零 $(\\delta_x, \\delta_y) = (0,0)$ 的用例将粒子精确放置在网格节点上，根据对称性，这必须导致净力为零，这可作为实现的关键合理性检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for all test cases.\n    \"\"\"\n\n    def compute_spurious_force(N, dt, delta_offset):\n        \"\"\"\n        Computes the spurious force and speed increment for a single particle.\n\n        Args:\n            N (int): Number of grid cells per dimension.\n            dt (float): Timestep for the velocity kick.\n            delta_offset (tuple): Particle offset (delta_x, delta_y) from the box center.\n\n        Returns:\n            tuple: A tuple containing the force magnitude (s) and speed increment (u).\n        \"\"\"\n        # 1. System Definition and Discretization\n        L = 1.0\n        G = 1.0\n        m = 1.0\n        delta = L / N\n        \n        delta_x, delta_y = delta_offset\n        \n        # Particle position\n        x = L / 2.0 + delta_x\n        y = L / 2.0 + delta_y\n\n        # 2. Mass Assignment (CIC)\n        rho_grid = np.zeros((N, N), dtype=np.float64)\n        \n        g_x = x / delta\n        g_y = y / delta\n        \n        i_0 = int(g_x)\n        j_0 = int(g_y)\n        \n        f_x = g_x - i_0\n        f_y = g_y - j_0\n        \n        weights_x = [1.0 - f_x, f_x]\n        weights_y = [1.0 - f_y, f_y]\n        \n        # Distribute mass to 4 nearest grid nodes\n        for b in range(2):\n            for a in range(2):\n                node_i = (i_0 + a) % N\n                node_j = (j_0 + b) % N\n                mass_fraction = m * weights_x[a] * weights_y[b]\n                rho_grid[node_j, node_i] += mass_fraction / (delta**2)\n\n        # 3. Solve Poisson Equation in Fourier Space\n        rho_k = np.fft.fft2(rho_grid)\n        \n        # Wave numbers\n        k_vals = 2.0 * np.pi * np.fft.fftfreq(N, d=delta)\n        KX, KY = np.meshgrid(k_vals, k_vals)\n\n        # Effective k^2 for finite difference Laplacian\n        k_eff_sq = (2.0 / delta)**2 * (np.sin(KX * delta / 2.0)**2 + np.sin(KY * delta / 2.0)**2)\n        \n        # Avoid division by zero at k=0\n        # The potential at k=0 will be set to 0 anyway.\n        k_eff_sq[0, 0] = 1.0  \n\n        # Potential in Fourier space\n        phi_k = -4.0 * np.pi * G * rho_k / k_eff_sq\n        \n        # Set k=0 mode of potential to zero (enforces mean density subtraction)\n        phi_k[0, 0] = 0.0\n\n        # Potential in real space\n        phi_grid = np.fft.ifft2(phi_k).real\n\n        # 4. Force Calculation on the Grid\n        # Using np.roll for periodic boundary conditions\n        Fx_grid = - (np.roll(phi_grid, -1, axis=1) - np.roll(phi_grid, 1, axis=1)) / (2.0 * delta)\n        Fy_grid = - (np.roll(phi_grid, -1, axis=0) - np.roll(phi_grid, 1, axis=0)) / (2.0 * delta)\n\n        # 5. Force Interpolation (CIC)\n        Fp_x = 0.0\n        Fp_y = 0.0\n        \n        for b in range(2):\n            for a in range(2):\n                node_i = (i_0 + a) % N\n                node_j = (j_0 + b) % N\n                weight = weights_x[a] * weights_y[b]\n                Fp_x += Fx_grid[node_j, node_i] * weight\n                Fp_y += Fy_grid[node_j, node_i] * weight\n\n        # Calculate final quantities\n        s = np.sqrt(Fp_x**2 + Fp_y**2)\n        u = s * dt\n        \n        return s, u\n\n    # Define the test cases from the problem statement.\n    test_params = [\n        {'N': 32, 'dt': 0.01, 'offset_frac': (1/4, 0)},\n        {'N': 32, 'dt': 0.01, 'offset_frac': (1/4, 1/4)},\n        {'N': 16, 'dt': 0.01, 'offset_frac': (1/4, 1/4)},\n        {'N': 32, 'dt': 0.005, 'offset_frac': (1/4, 1/4)},\n        {'N': 32, 'dt': 0.01, 'offset_frac': (0, 0)},\n    ]\n\n    results = []\n    for params in test_params:\n        N = params['N']\n        dt = params['dt']\n        delta = 1.0 / N\n        offset_frac_x, offset_frac_y = params['offset_frac']\n        delta_offset = (offset_frac_x * delta, offset_frac_y * delta)\n        \n        s, u = compute_spurious_force(N, dt, delta_offset)\n        results.extend([s, u])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3466963"}, {"introduction": "本练习是本章学习的高潮。在分析了CIC窗函数并测量了其产生的虚假力之后，我们将转向一个强大的解决方案。你将推导并实现一个联合反卷积滤波器——这是现代宇宙学代码中的一项标准技术——用以同时校正CIC平滑和离散泊松求解器带来的误差，从而恢复计算的精度和各向同性[@problem_id:3466943]。", "problem": "您的任务是推导并实现一种傅里叶空间中的联合反卷积，该反卷积能同时校正Cloud-In-Cell (CIC) 质量分配窗口函数以及在均匀网格上由标准二阶离散拉普拉斯算子引入的各向异性。其背景是一个周期性的立方体域和平面波密度模式，这些模式用于测试恢复出的引力场的各向同性和准确性。目标是从第一性原理出发，展示如何构建一个傅里叶空间中的乘法校正因子，将朴素的离散解映射回连续目标解，并验证该校正在不同方向的波矢量上对各向同性的改进。\n\n从以下基本原理开始：\n- Cloud-In-Cell (CIC) 方案是一种线性质量分配核。在傅里叶空间中，分配后的密度振幅会乘以一个窗口函数 $W_{\\mathrm{CIC}}(\\boldsymbol{k})$，对于间距为 $\\Delta x$ 的均匀立方体网格，该函数可分解为\n$$\nW_{\\mathrm{CIC}}(\\boldsymbol{k}) \\;=\\; \\prod_{i\\in\\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left(\\frac{k_i \\,\\Delta x}{2}\\right) \\right]^2,\n\\quad \\mathrm{sinc}(z)\\equiv\\frac{\\sin z}{z},\n$$\n其中 $k_i$ 是角波矢量 $\\boldsymbol{k}$ 的笛卡尔分量，单位为弧度/单位长度。$\\mathrm{sinc}$ 函数在 $z=0$ 处的值根据连续性取为 1。\n- 在间距为 $\\Delta x$ 的网格上，二阶中心差分离散拉普拉斯算子具有平面波本征值\n$$\n\\tilde{k}^2(\\boldsymbol{k}) \\;=\\; \\frac{2}{\\Delta x^2}\\sum_{i\\in\\{x,y,z\\}} \\left[1 - \\cos\\!\\left(k_i \\,\\Delta x\\right)\\right],\n$$\n使得 $-\\nabla_{\\mathrm{disc}}^2 e^{i\\boldsymbol{k}\\cdot\\boldsymbol{x}} \\;=\\; \\tilde{k}^2(\\boldsymbol{k}) \\, e^{i\\boldsymbol{k}\\cdot\\boldsymbol{x}}$。\n- 在连续谱中，密度衬度场 $\\delta(\\boldsymbol{x})$ 的泊松方程在傅里叶空间中简化为\n$$\n\\phi(\\boldsymbol{k}) \\;=\\; -\\frac{\\delta(\\boldsymbol{k})}{k^2}, \\qquad k^2 \\equiv \\boldsymbol{k}\\cdot\\boldsymbol{k},\n$$\n且引力场为\n$$\n\\boldsymbol{f}(\\boldsymbol{k}) \\;=\\; -i\\,\\boldsymbol{k}\\,\\phi(\\boldsymbol{k}) \\;=\\; i\\,\\frac{\\boldsymbol{k}}{k^2}\\,\\delta(\\boldsymbol{k}),\n$$\n在无量纲单位下。\n\n您的任务：\n1. 仅使用上述事实，推导一个傅里葉空间乘法反卷积 $D(\\boldsymbol{k})$。当将其应用于从CIC分配的密度和离散拉普拉斯算子获得的朴素离散傅里叶空间势时，对于每个非零模式，它能产生连续目标势。具体来说，您的 $D(\\boldsymbol{k})$ 必须同时校正CIC窗口函数 $W_{\\mathrm{CIC}}(\\boldsymbol{k})$ 和离散拉普拉斯算子本征值 $\\tilde{k}^2(\\boldsymbol{k})$。\n2. 实现一个完整的程序，该程序：\n   - 构建一个大小为 $N\\times N\\times N$ 的周期性立方体网格，其中 $N=32$，盒子边长 $L=1$（因此 $\\Delta x = L/N$）。\n   - 对于每个测试用例，使用指定的整数三元组 $(m_x,m_y,m_z)$ 构建一个平面波密度场 $\\delta(\\boldsymbol{x}) = \\cos(\\boldsymbol{k}\\cdot\\boldsymbol{x})$，其中 $\\boldsymbol{k} = \\frac{2\\pi}{L}(m_x,m_y,m_z)$。\n   - 计算 $\\delta(\\boldsymbol{x})$ 的快速傅里叶变换 (FFT)，并通过将每个傅里叶模式乘以 $W_{\\mathrm{CIC}}(\\boldsymbol{k})$ 来应用CIC分配。\n   - 在傅里叶空间中使用离散拉普拉斯算子本征值求解朴素的离散泊松方程，以获得所有非零模式的 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = -\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})/\\tilde{k}^2(\\boldsymbol{k})$，零模式则为零。\n   - 构造朴素力 $\\boldsymbol{f}_{\\mathrm{naive}}(\\boldsymbol{k}) = -i\\,\\boldsymbol{k}\\,\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$，将其变换回实空间，并计算连续目标力 $\\boldsymbol{f}_{\\mathrm{true}}(\\boldsymbol{x}) = -\\frac{\\boldsymbol{k}}{k^2}\\sin(\\boldsymbol{k}\\cdot\\boldsymbol{x})$。\n   - 将您推导的联合反卷积 $D(\\boldsymbol{k})$ 应用于 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ 以获得 $\\phi_{\\mathrm{corr}}(\\boldsymbol{k})$，构造校正后的力 $\\boldsymbol{f}_{\\mathrm{corr}}(\\boldsymbol{k}) = -i\\,\\boldsymbol{k}\\,\\phi_{\\mathrm{corr}}(\\boldsymbol{k})$，并在实空间中对其进行求值。\n   - 对于每个测试用例，计算两个无量纲浮点数：朴素力的相对均方根误差\n     $$\n     \\varepsilon_{\\mathrm{naive}} \\;=\\; \\frac{\\left\\lVert \\boldsymbol{f}_{\\mathrm{naive}} - \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}}{\\left\\lVert \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}},\n     $$\n     以及校正后力的相对均方根误差\n     $$\n     \\varepsilon_{\\mathrm{corr}} \\;=\\; \\frac{\\left\\lVert \\boldsymbol{f}_{\\mathrm{corr}} - \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}}{\\left\\lVert \\boldsymbol{f}_{\\mathrm{true}} \\right\\rVert_{L^2}}.\n     $$\n     此处 $\\left\\lVert \\cdot \\right\\rVert_{L^2}$ 表示在网格上的均方根，即网格点上矢量场欧几里得范数平方的均值的平方根。\n3. 全程使用无量纲单位，并确保所有三角函数使用弧度。\n4. 测试套件：\n   - 使用以下整数模式三元组 $(m_x,m_y,m_z)$ 来探测不同的方向和尺度：\n     - $(1,0,0)$: 长波长轴对齐模式（理想路径）。\n     - $(3,0,0)$: 中等波长轴对齐模式。\n     - $(3,5,2)$: 离轴倾斜模式。\n     - $(15,0,0)$: 近奈奎斯特轴对齐模式（边界）。\n     - $(15,14,0)$: 近奈奎斯特离轴模式（边缘情况）。\n     - $(9,9,9)$: 探测各向同性的对角线模式。\n5. 最终输出格式：\n   - 您的程序应生成单行输出，其中包含结果，格式为无空格的、由逗号分隔的方括号对列表。每个方括号对为 $[\\varepsilon_{\\mathrm{naive}},\\varepsilon_{\\mathrm{corr}}]$，采用科学记数法，小数点后保留六位数字，并按上述测试用例的顺序列出。例如：`[[1.234567e-03,4.567890e-05],[\\dots],[\\dots],\\dots]`。\n\n您的推导和实现应严格基于上述基本原理，不应依赖任何捷径或预先指定的校正公式。清晰地展示您的反卷积为何有效，以及它如何改善所提供的测试模式的各向同性。程序必须是自包含的，不需要任何输入、外部文件或网络访问。全程使用无量纲单位和弧度。", "solution": "用户在数值宇宙学领域提供了一个定义明确的问题。所有必要的物理和数学定义均已提供，目标清晰，并且该问题在科学上基于标准的计算物理技术。因此，该问题被认定为有效。\n\n### 联合反卷积因子的推导\n\n目标是在傅里叶空间中找到一个乘法校正因子 $D(\\boldsymbol{k})$，它能将朴素计算得到的引力势 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ 转换为真实的连续势 $\\phi_{\\mathrm{true}}(\\boldsymbol{k})$。\n\n设 $\\delta(\\boldsymbol{x})$ 为真实的连续密度衬度场。其傅里叶变换为 $\\delta(\\boldsymbol{k})$。在网格上的数值模拟背景下，该场首先被分配到网格单元。问题陈述我们使用 Cloud-In-Cell (CIC) 分配方案对此进行建模，该方案的作用类似于一个线性滤波器。在傅里叶空间中，网格上的密度 $\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})$ 通过 CIC 窗口函数 $W_{\\mathrm{CIC}}(\\boldsymbol{k})$ 与真实密度相关联：\n$$\n\\delta_{\\mathrm{CIC}}(\\boldsymbol{k}) = W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})\n$$\n其中\n$$\nW_{\\mathrm{CIC}}(\\boldsymbol{k}) \\;=\\; \\prod_{i\\in\\{x,y,z\\}} \\left[ \\mathrm{sinc}\\!\\left(\\frac{k_i \\,\\Delta x}{2}\\right) \\right]^2,\n\\quad \\mathrm{sinc}(z)\\equiv\\frac{\\sin z}{z}\n$$\n此处，$k_i$ 是波矢量 $\\boldsymbol{k}$ 的分量，$\\Delta x$ 是网格间距。这个窗口函数解释了 CIC 分配的平滑效应。\n\n接下来，求解离散泊松方程。傅里叶空间中的连续泊松方程为 $\\nabla^2 \\phi = \\delta$（在适当单位下），这变为 $-k^2 \\phi(\\boldsymbol{k}) = \\delta(\\boldsymbol{k})$。朴素的离散方法用二阶有限差分拉普拉斯算子的本征值 $-\\tilde{k}^2(\\boldsymbol{k})$ 替换连续拉普拉斯算子本征值 $-k^2 = -(\\boldsymbol{k}\\cdot\\boldsymbol{k})$，其中：\n$$\n\\tilde{k}^2(\\boldsymbol{k}) \\;=\\; \\frac{2}{\\Delta x^2}\\sum_{i\\in\\{x,y,z\\}} \\left[1 - \\cos\\!\\left(k_i \\,\\Delta x\\right)\\right]\n$$\n因此，朴素的离散求解器通过求解 $-\\tilde{k}^2(\\boldsymbol{k}) \\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = \\delta_{\\mathrm{CIC}}(\\boldsymbol{k})$ 来计算势 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$。对于任何 $\\tilde{k}^2(\\boldsymbol{k}) \\neq 0$ 的模式，朴素势为：\n$$\n\\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = -\\frac{\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})}\n$$\n代入 $\\delta_{\\mathrm{CIC}}(\\boldsymbol{k})$ 的表达式，我们得到：\n$$\n\\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = -\\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})}\n$$\n这个表达式揭示了朴素解中两个误差的来源：分子中的 CIC 窗口函数 $W_{\\mathrm{CIC}}(\\boldsymbol{k})$ 和分母中的离散拉普拉斯算子本征值 $\\tilde{k}^2(\\boldsymbol{k})$。\n\n目标解是由连续泊松方程定义的连续势 $\\phi_{\\mathrm{true}}(\\boldsymbol{k})$：\n$$\n\\phi_{\\mathrm{true}}(\\boldsymbol{k}) = -\\frac{\\delta(\\boldsymbol{k})}{k^2}\n$$\n其中 $k^2 = \\boldsymbol{k}\\cdot\\boldsymbol{k}$ 是连续波矢量的模的平方。\n\n我们寻求一个反卷积因子 $D(\\boldsymbol{k})$，使得将其应用于朴素势能得到真实势：\n$$\n\\phi_{\\mathrm{corr}}(\\boldsymbol{k}) = D(\\boldsymbol{k}) \\, \\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = \\phi_{\\mathrm{true}}(\\boldsymbol{k})\n$$\n代入 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ 和 $\\phi_{\\mathrm{true}}(\\boldsymbol{k})$ 的表达式：\n$$\nD(\\boldsymbol{k}) \\left( -\\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})} \\right) = -\\frac{\\delta(\\boldsymbol{k})}{k^2}\n$$\n对于任何 $\\delta(\\boldsymbol{k}) \\neq 0$ 的模式 $\\boldsymbol{k}$，我们可以消去两边的 $-\\delta(\\boldsymbol{k})$：\n$$\nD(\\boldsymbol{k}) \\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})} = \\frac{1}{k^2}\n$$\n解出 $D(\\boldsymbol{k})$，我们得到联合反卷积因子：\n$$\nD(\\boldsymbol{k}) = \\frac{\\tilde{k}^2(\\boldsymbol{k})}{k^2 \\, W_{\\mathrm{CIC}}(\\boldsymbol{k})}\n$$\n对于每个非零模式 $\\boldsymbol{k}$（即 $k^2 \\neq 0$ 的情况），必须将此因子乘到朴素势 $\\phi_{\\mathrm{naive}}(\\boldsymbol{k})$ 上。对于 $\\boldsymbol{k}=\\boldsymbol{0}$ 模式（直流分量），$k^2$ 和 $\\tilde{k}^2$ 均为零，此时势通常设为零，因为它代表一个任意的常数偏移。反卷积因子 $D(\\boldsymbol{k})$ 同时校正了两个系统误差：\n1.  项 $1/W_{\\mathrm{CIC}}(\\boldsymbol{k})$“反卷积”或反转了 CIC 质量分配的平滑效应。\n2.  项 $\\tilde{k}^2(\\boldsymbol{k})/k^2$ 校正了离散拉普拉斯算子的各向异性和不准确响应，并将其替换为各向同性的连续算子。\n\n因此，校正后的势为：\n$$\n\\phi_{\\mathrm{corr}}(\\boldsymbol{k}) = D(\\boldsymbol{k}) \\, \\phi_{\\mathrm{naive}}(\\boldsymbol{k}) = \\left( \\frac{\\tilde{k}^2(\\boldsymbol{k})}{k^2 \\, W_{\\mathrm{CIC}}(\\boldsymbol{k})} \\right) \\left( -\\frac{W_{\\mathrm{CIC}}(\\boldsymbol{k}) \\, \\delta(\\boldsymbol{k})}{\\tilde{k}^2(\\boldsymbol{k})} \\right) = -\\frac{\\delta(\\boldsymbol{k})}{k^2} = \\phi_{\\mathrm{true}}(\\boldsymbol{k})\n$$\n这证实了所推导的反卷积因子的有效性。实现过程将为所有相关的傅里叶模式计算此因子，并应用它来获得一个校正后的力场，预计该力场将比朴素结果在准确性和各向同性方面有显著提高。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a joint deconvolution in Fourier space to correct\n    for CIC mass assignment and discrete Laplacian anisotropy in a numerical\n    cosmology context.\n    \"\"\"\n    # 1. Setup Grid and Parameters\n    N = 32  # Grid size\n    L = 1.0  # Box side length\n    dx = L / N  # Grid spacing\n\n    # Real space grid coordinates\n    grid_1d = np.arange(N) * dx\n    xx, yy, zz = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n    # Fourier space wave vectors (angular frequencies)\n    k_freq = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    kx, ky, kz = np.meshgrid(k_freq, k_freq, k_freq, indexing='ij')\n\n    # 2. Pre-compute Fourier-space kernels\n\n    # Mask for the k=0 mode\n    k_is_zero = (kx == 0)  (ky == 0)  (kz == 0)\n    non_zero_k = ~k_is_zero\n    \n    # Continuum Laplacian eigenvalue (squared magnitude of wave vector)\n    k_squared = kx**2 + ky**2 + kz**2\n\n    # Discrete Laplacian eigenvalue\n    tilde_k_squared = (2.0 / dx**2) * ( (1 - np.cos(kx * dx)) +\n                                       (1 - np.cos(ky * dx)) +\n                                       (1 - np.cos(kz * dx)) )\n\n    # CIC window function W_CIC(k).\n    # The problem defines sinc(z) = sin(z)/z.\n    # numpy.sinc(x) computes sin(pi*x)/(pi*x).\n    # To compute sin(z)/z, we can use np.sinc(z/pi).\n    # The argument to our sinc is z = k_i * dx / 2.\n    # So the argument to np.sinc is (k_i * dx / 2) / pi = k_i * dx / (2*pi).\n    sinc_arg_x = kx * dx / (2.0 * np.pi)\n    sinc_arg_y = ky * dx / (2.0 * np.pi)\n    sinc_arg_z = kz * dx / (2.0 * np.pi)\n    W_cic = (np.sinc(sinc_arg_x) * np.sinc(sinc_arg_y) * np.sinc(sinc_arg_z))**2\n    \n    # Joint deconvolution factor D(k)\n    # D(k) = tilde_k^2 / (k^2 * W_cic)\n    D_k = np.ones_like(kx, dtype=float) # Initialize to 1\n    # Compute only for non-zero k to avoid division by zero\n    D_k[non_zero_k] = np.divide(tilde_k_squared[non_zero_k],\n                                W_cic[non_zero_k] * k_squared[non_zero_k])\n    \n    # Test suite\n    test_cases = [\n        (1, 0, 0),\n        (3, 0, 0),\n        (3, 5, 2),\n        (15, 0, 0),\n        (15, 14, 0),\n        (9, 9, 9),\n    ]\n\n    results = []\n\n    for m_vec in test_cases:\n        # 3. Define the wave for the current test case\n        k0_vec = (2 * np.pi / L) * np.array(m_vec)\n        k0_sq = np.sum(k0_vec**2)\n\n        # 4. Generate density field and its Fourier transform\n        # delta(x) = cos(k_0 . x)\n        delta_x = np.cos(k0_vec[0] * xx + k0_vec[1] * yy + k0_vec[2] * zz)\n        delta_k = np.fft.fftn(delta_x)\n\n        # Apply CIC window effect\n        delta_cic_k = delta_k * W_cic\n\n        # 5. Naive Solution\n        # phi_naive(k) = -delta_cic(k) / tilde_k^2\n        phi_naive_k = np.zeros_like(delta_k, dtype=complex)\n        phi_naive_k[non_zero_k] = -delta_cic_k[non_zero_k] / tilde_k_squared[non_zero_k]\n        \n        # f_naive(k) = -i * k * phi_naive(k)\n        f_naive_k_x = -1j * kx * phi_naive_k\n        f_naive_k_y = -1j * ky * phi_naive_k\n        f_naive_k_z = -1j * kz * phi_naive_k\n\n        # Transform naive force back to real space\n        f_naive_x = np.real(np.fft.ifftn(f_naive_k_x))\n        f_naive_y = np.real(np.fft.ifftn(f_naive_k_y))\n        f_naive_z = np.real(np.fft.ifftn(f_naive_k_z))\n        f_naive = np.stack([f_naive_x, f_naive_y, f_naive_z])\n        \n        # 6. Corrected Solution\n        # phi_corr(k) = D(k) * phi_naive(k)\n        phi_corr_k = D_k * phi_naive_k\n        \n        # f_corr(k) = -i * k * phi_corr(k)\n        f_corr_k_x = -1j * kx * phi_corr_k\n        f_corr_k_y = -1j * ky * phi_corr_k\n        f_corr_k_z = -1j * kz * phi_corr_k\n\n        # Transform corrected force back to real space\n        f_corr_x = np.real(np.fft.ifftn(f_corr_k_x))\n        f_corr_y = np.real(np.fft.ifftn(f_corr_k_y))\n        f_corr_z = np.real(np.fft.ifftn(f_corr_k_z))\n        f_corr = np.stack([f_corr_x, f_corr_y, f_corr_z])\n\n        # 7. True (Continuum) Solution\n        # f_true(x) = -(k_0 / k_0^2) * sin(k_0 . x)\n        sin_term = np.sin(k0_vec[0] * xx + k0_vec[1] * yy + k0_vec[2] * zz)\n        # Avoid division by zero if k0_sq is zero (not the case here)\n        factor = -1.0 / k0_sq if k0_sq > 0 else 0.0\n        f_true_x = k0_vec[0] * factor * sin_term\n        f_true_y = k0_vec[1] * factor * sin_term\n        f_true_z = k0_vec[2] * factor * sin_term\n        f_true = np.stack([f_true_x, f_true_y, f_true_z])\n\n        # 8. Compute Errors\n        # L2-norm is sqrt of mean of squared magnitudes\n        norm_true_sq = np.mean(np.sum(f_true**2, axis=0))\n        \n        diff_naive_sq = np.mean(np.sum((f_naive - f_true)**2, axis=0))\n        err_naive = np.sqrt(diff_naive_sq / norm_true_sq)\n        \n        diff_corr_sq = np.mean(np.sum((f_corr - f_true)**2, axis=0))\n        err_corr = np.sqrt(diff_corr_sq / norm_true_sq)\n        \n        results.append([err_naive, err_corr])\n\n    # 9. Format and Print Output\n    output_str = '[' + ','.join([f'[{r[0]:.6e},{r[1]:.6e}]' for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "3466943"}]}