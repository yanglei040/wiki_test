{"hands_on_practices": [{"introduction": "在膨胀的宇宙中模拟流体，需要将流体力学方程转换到共动坐标系下。这个变换过程会在方程中引入新的项，例如阻尼奇特速度的“哈勃拖拽”项。本练习将引导你推导共动坐标系下的欧拉方程，并测试你对哈勃拖拽项进行数值积分的能力，通过比较简单的欧拉和拉格朗日风格的时间步进方案的精度，加深你对数值积分误差的理解。[@problem_id:3477164]", "problem": "考虑一个膨胀的、空间平坦的宇宙中的牛顿、非相对论性、可压缩流体。令物理（固有）坐标为 $\\mathbf{r}$，共动坐标为 $\\mathbf{x}$，宇宙尺度因子为 $a(t)$。坐标之间的映射关系为 $\\mathbf{r}(t) = a(t)\\,\\mathbf{x}(t)$。定义物理速度 $\\mathbf{u}(t,\\mathbf{r}) \\equiv d\\mathbf{r}/dt$ 和本动速度 $\\mathbf{v}(t,\\mathbf{x}) \\equiv a(t)\\,d\\mathbf{x}/dt$，使得 $\\mathbf{u} = H(t)\\,\\mathbf{r} + \\mathbf{v}$，其中 $H(t) \\equiv \\dot{a}/a$ 是哈勃参数。从质量和动量守恒以及流体的牛顿第二定律出发，推导欧拉方程的共动形式，并明确指出动量方程中与 $-H(t)\\,\\mathbf{v}$ 成正比的源项（“哈勃阻尼”项）。阐明所有做出的假设并清晰地定义所有变量。您必须从物理欧拉方程开始，通过应用链式法则和本动量的定义，映射到共动变量；不得直接假设目标共动方程的形式。\n\n完成推导后，考虑均匀流和无源极限情况，此时空间导数、压力梯度和本动引力均消失，因此本动速度因哈勃阻尼而服从一个纯粹的常微分方程（ODE）：\n$$\n\\frac{d\\mathbf{v}}{dt} = -H(t)\\,\\mathbf{v}.\n$$\n您的任务是实现两种在思想上分别对应于欧拉方法和拉格朗日方法的时间离散化策略，并量化 $-H(t)\\,\\mathbf{v}$ 项的离散化偏差：\n\n- 欧拉更新（基于网格的观点）：使用在每步开始时计算的一阶向前欧拉步进推进 ODE。\n- 拉格朗日更新（粒子追踪观点）：使用一个二阶时间中心的梯形步进推进 ODE，该步进使用在步长开始和结束时采样的 $H(t)$。\n\n对于每种策略，计算在有限时间区间内 $\\mathbf{v}(t)$ 的数值解，并将其与给定 $H(t)$ 的精确解析解进行比较。将标量速度幅值 $v$ 在最终时刻 $t_{\\mathrm{f}}$ 的离散化偏差定义为相对误差\n$$\n\\epsilon \\equiv \\frac{v_{\\mathrm{num}}(t_{\\mathrm{f}}) - v_{\\mathrm{exact}}(t_{\\mathrm{f}})}{v_{\\mathrm{exact}}(t_{\\mathrm{f}})},\n$$\n以小数形式表示（而非百分比）。两种策略使用相同的初始条件 $v(t_0) = v_0$。\n\n单位和数值规范：\n- 所有时间单位必须是秒（$\\mathrm{s}$），速度单位是米/秒（$\\mathrm{m/s}$），哈勃参数单位是秒的倒数（$\\mathrm{s}^{-1}$）。\n- 为简单起见，将 $v$ 视为标量幅值，并报告每个测试的标量偏差。\n\n实现一个单一程序，为以下测试套件计算欧拉和拉格朗日离散化偏差。对于每种情况，假设一个单一的空间均匀流体元，并仅关注上述 ODE：\n\n- 情况1（恒定哈勃参数，中等步长）：$H(t) = H_0$，$H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$，$t_0 = 0\\,\\mathrm{s}$，$v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$，$\\Delta t = 5.0\\times 10^{16}\\,\\mathrm{s}$，$N = 10$ 步。精确解为 $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp\\!\\left(-H_0\\,N\\,\\Delta t\\right)$。\n- 情况2（物质主导的膨胀）：$H(t) = \\frac{2}{3\\,t}$，$t_0 = 1.0\\times 10^{16}\\,\\mathrm{s}$，$v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$，$\\Delta t = 5.0\\times 10^{15}\\,\\mathrm{s}$，$N = 8$ 步。精确解为 $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\left(\\frac{t_0}{t_0 + N\\,\\Delta t}\\right)^{2/3}$。\n- 情况3（恒定哈勃参数，小步长边界）：$H(t) = H_0$，$H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$，$t_0 = 0\\,\\mathrm{s}$，$v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$，$\\Delta t = 1.0\\times 10^{15}\\,\\mathrm{s}$，$N = 10$ 步。精确解为 $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp\\!\\left(-H_0\\,N\\,\\Delta t\\right)$。\n- 情况4（恒定哈勃参数，极大粗略步长）：$H(t) = H_0$，$H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$，$t_0 = 0\\,\\mathrm{s}$，$v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$，$\\Delta t = 5.0\\times 10^{18}\\,\\mathrm{s}$，$N = 1$ 步。精确解为 $v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp\\!\\left(-H_0\\,N\\,\\Delta t\\right)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目必须是一个双元素列表，其中包含对应情况的欧拉偏差，后跟拉格朗日偏差，并按给定顺序排列。例如，输出格式必须是\n$[\\,[\\epsilon_{\\mathrm{E},1},\\epsilon_{\\mathrm{L},1}],\\,[\\epsilon_{\\mathrm{E},2},\\epsilon_{\\mathrm{L},2}],\\,[\\epsilon_{\\mathrm{E},3},\\epsilon_{\\mathrm{L},3}],\\,[\\epsilon_{\\mathrm{E},4},\\epsilon_{\\mathrm{L},4}]\\,]$。", "solution": "问题首先是推导膨胀宇宙中牛顿流体的欧拉方程的共动形式，其次是实现并比较两种用于求解本动速度演化简化版本的数值方案。\n\n首先将验证问题陈述。\n\n**步骤1：提取给定条件**\n-   坐标映射：$\\mathbf{r}(t) = a(t)\\,\\mathbf{x}(t)$，其中 $\\mathbf{r}$ 是物理坐标，$\\mathbf{x}$ 是共动坐标， $a(t)$ 是宇宙尺度因子。\n-   哈勃参数：$H(t) \\equiv \\dot{a}/a$。\n-   物理速度：$\\mathbf{u}(t,\\mathbf{r}) \\equiv d\\mathbf{r}/dt$。\n-   本动速度：$\\mathbf{v}(t,\\mathbf{x}) \\equiv a(t)\\,d\\mathbf{x}/dt$。\n-   速度关系：$\\mathbf{u} = H(t)\\,\\mathbf{r} + \\mathbf{v}$。\n-   简化的本动速度 ODE：$\\frac{d\\mathbf{v}}{dt} = -H(t)\\,\\mathbf{v}$，在均匀流、无源极限下有效。\n-   离散化偏差定义：$\\epsilon \\equiv \\frac{v_{\\mathrm{num}}(t_{\\mathrm{f}}) - v_{\\mathrm{exact}}(t_{\\mathrm{f}})}{v_{\\mathrm{exact}}(t_{\\mathrm{f}})}$。\n-   欧拉更新：一阶向前欧拉步进。\n-   拉格朗日更新：二阶时间中心梯形步进。\n-   情况1：$H(t) = H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$，$t_0 = 0\\,\\mathrm{s}$，$v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$，$\\Delta t = 5.0\\times 10^{16}\\,\\mathrm{s}$，$N = 10$。精确解：$v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp(-H_0\\,N\\,\\Delta t)$。\n-   情况2：$H(t) = \\frac{2}{3\\,t}$，$t_0 = 1.0\\times 10^{16}\\,\\mathrm{s}$，$v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$，$\\Delta t = 5.0\\times 10^{15}\\,\\mathrm{s}$，$N = 8$。精确解：$v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\left(\\frac{t_0}{t_0 + N\\,\\Delta t}\\right)^{2/3}$。\n-   情况3：$H(t) = H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$，$t_0 = 0\\,\\mathrm{s}$，$v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$，$\\Delta t = 1.0\\times 10^{15}\\,\\mathrm{s}$，$N = 10$。精确解：$v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp(-H_0\\,N\\,\\Delta t)$。\n-   情况4：$H(t) = H_0 = 2.27\\times 10^{-18}\\,\\mathrm{s}^{-1}$，$t_0 = 0\\,\\mathrm{s}$，$v_0 = 3.0\\times 10^{5}\\,\\mathrm{m/s}$，$\\Delta t = 5.0\\times 10^{18}\\,\\mathrm{s}$，$N = 1$。精确解：$v_{\\mathrm{exact}}(t_{\\mathrm{f}}) = v_0\\exp(-H_0\\,N\\,\\Delta t)$。\n\n**步骤2：使用提取的给定条件进行验证**\n-   **科学依据**：该问题设置在牛顿宇宙学的标准框架内，使用了流体近似，这是大尺度结构形成理论的基石。共动欧拉方程的推导是宇宙学中一个基本且标准的练习。物理常数和参数的量级是现实的。\n-   **良态问题**：推导部分是一个标准的证明。数值部分是一个定义明确的常微分方程初值问题，具有指定的初始条件、时间步长和数值方法。提供的精确解是正确的，可作为可靠的基准。\n-   **客观性**：该问题使用了精确的数学和物理术语，没有主观性语言。\n-   该问题没有表现出验证标准中列出的任何缺陷。它在科学上是合理的、自洽的并且可以形式化。\n\n**步骤3：结论与行动**\n该问题有效。将提供一个解决方案。\n\n**第一部分：共动欧拉方程的推导**\n\n我们从物理坐标 $(\\mathbf{r}, t)$ 下的可压缩、无粘性流体的欧拉方程开始。连续性方程（质量守恒）和动量方程为：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\nabla_{\\mathbf{r}} \\cdot (\\rho \\mathbf{u}) = 0\n$$\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla_{\\mathbf{r}}) \\mathbf{u} = -\\frac{1}{\\rho}\\nabla_{\\mathbf{r}} P - \\nabla_{\\mathbf{r}} \\Phi\n$$\n这里，$\\rho(t,\\mathbf{r})$ 是流体密度，$P(t,\\mathbf{r})$ 是压力，$\\mathbf{u}(t,\\mathbf{r})$ 是物理速度场，$\\Phi(t,\\mathbf{r})$ 是引力势。算子 $\\nabla_{\\mathbf{r}}$ 是关于物理坐标 $\\mathbf{r}$ 的梯度。\n\n我们的目标是将这些方程转换到共动坐标 $\\mathbf{x}$ 中，它通过 $\\mathbf{r} = a(t) \\mathbf{x}$ 与物理坐标相关联。尺度因子 $a(t)$ 描述了宇宙的整体膨胀。\n\n首先，我们建立导数和速度的转换规则。\n梯度算子的转换关系为：\n$$\n\\nabla_{\\mathbf{r}} = \\frac{1}{a(t)}\\nabla_{\\mathbf{x}}\n$$\n在固定物理位置 $\\mathbf{r}$ 处的偏时间导数与在固定共动位置 $\\mathbf{x}$ 处的偏时间导数有关。对于任何场 $f(t, \\mathbf{r}(t, \\mathbf{x}))$，链式法则给出：\n$$\n\\frac{\\partial f}{\\partial t}\\bigg|_{\\mathbf{x}} = \\frac{\\partial f}{\\partial t}\\bigg|_{\\mathbf{r}} + \\left(\\frac{\\partial \\mathbf{r}}{\\partial t}\\bigg|_{\\mathbf{x}}\\right) \\cdot \\nabla_{\\mathbf{r}} f\n$$\n由于 $\\mathbf{r} = a(t)\\mathbf{x}$，我们有 $\\frac{\\partial \\mathbf{r}}{\\partial t}\\big|_{\\mathbf{x}} = \\dot{a}\\mathbf{x} = \\frac{\\dot{a}}{a} (a\\mathbf{x}) = H(t)\\mathbf{r}$。这得到：\n$$\n\\frac{\\partial}{\\partial t}\\bigg|_{\\mathbf{r}} = \\frac{\\partial}{\\partial t}\\bigg|_{\\mathbf{x}} - H(t)\\mathbf{r} \\cdot \\nabla_{\\mathbf{r}}\n$$\n物理速度 $\\mathbf{u}$ 是流体元物理位置的全时间导数：\n$$\n\\mathbf{u} = \\frac{d\\mathbf{r}}{dt} = \\frac{d(a\\mathbf{x})}{dt} = \\dot{a}\\mathbf{x} + a\\dot{\\mathbf{x}} = H(a\\mathbf{x}) + a\\frac{d\\mathbf{x}}{dt} = H\\mathbf{r} + \\mathbf{v}\n$$\n这与给定的本动速度 $\\mathbf{v} \\equiv a(t)d\\mathbf{x}/dt$ 定义相符。\n\n现在我们变换连续性方程：\n$$\n\\left(\\frac{\\partial}{\\partial t}\\bigg|_{\\mathbf{x}} - H\\mathbf{r} \\cdot \\nabla_{\\mathbf{r}}\\right) \\rho + \\nabla_{\\mathbf{r}} \\cdot (\\rho \\mathbf{u}) = 0\n$$\n代入 $\\mathbf{r}=a\\mathbf{x}$，$\\mathbf{u}=H a \\mathbf{x} + \\mathbf{v}$ 和 $\\nabla_{\\mathbf{r}} = \\frac{1}{a}\\nabla_{\\mathbf{x}}$：\n$$\n\\frac{\\partial \\rho}{\\partial t} - H(a\\mathbf{x}) \\cdot \\left(\\frac{1}{a}\\nabla_{\\mathbf{x}}\\right) \\rho + \\frac{1}{a}\\nabla_{\\mathbf{x}} \\cdot (\\rho (H a \\mathbf{x} + \\mathbf{v})) = 0\n$$\n$$\n\\frac{\\partial \\rho}{\\partial t} - H(\\mathbf{x} \\cdot \\nabla_{\\mathbf{x}})\\rho + \\frac{1}{a}\\nabla_{\\mathbf{x}} \\cdot (\\rho H a \\mathbf{x}) + \\frac{1}{a}\\nabla_{\\mathbf{x}} \\cdot (\\rho \\mathbf{v}) = 0\n$$\n使用散度的乘积法则，$\\nabla_{\\mathbf{x}} \\cdot (\\rho H a \\mathbf{x}) = H a [(\\nabla_{\\mathbf{x}}\\rho)\\cdot\\mathbf{x} + \\rho(\\nabla_{\\mathbf{x}}\\cdot\\mathbf{x})]$。由于 $\\nabla_{\\mathbf{x}}\\cdot\\mathbf{x}=3$，这变成 $H a [(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}}\\rho) + 3\\rho]$。方程简化为：\n$$\n\\frac{\\partial \\rho}{\\partial t} - H(\\mathbf{x} \\cdot \\nabla_{\\mathbf{x}})\\rho + H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}}\\rho) + 3H\\rho + \\frac{1}{a}\\nabla_{\\mathbf{x}} \\cdot (\\rho \\mathbf{v}) = 0\n$$\n$H(\\mathbf{x} \\cdot \\nabla_{\\mathbf{x}})\\rho$ 项相互抵消，得到共动连续性方程：\n$$\n\\frac{\\partial \\rho}{\\partial t} + 3H\\rho + \\frac{1}{a}\\nabla_{\\mathbf{x}} \\cdot (\\rho \\mathbf{v}) = 0\n$$\n\n接下来，我们变换动量方程。让我们分析左手边（LHS）：\nLHS = $\\frac{\\partial \\mathbf{u}}{\\partial t}\\big|_{\\mathbf{r}} + (\\mathbf{u} \\cdot \\nabla_{\\mathbf{r}}) \\mathbf{u}$。\n第一项是：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t}\\bigg|_{\\mathbf{r}} = \\left(\\frac{\\partial}{\\partial t}\\bigg|_{\\mathbf{x}} - H\\mathbf{r} \\cdot \\nabla_{\\mathbf{r}}\\right) \\mathbf{u} = \\frac{\\partial \\mathbf{u}}{\\partial t}\\bigg|_{\\mathbf{x}} - H(a\\mathbf{x}) \\cdot \\left(\\frac{1}{a}\\nabla_{\\mathbf{x}}\\right)(H a \\mathbf{x} + \\mathbf{v})\n$$\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t}\\bigg|_{\\mathbf{x}} = \\frac{\\partial}{\\partial t}(Ha\\mathbf{x} + \\mathbf{v}) = (\\dot{H}a + H\\dot{a})\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t} = (\\dot{H}+H^2)a\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t}\n$$\n所以，$\\frac{\\partial \\mathbf{u}}{\\partial t}\\big|_{\\mathbf{r}} = (\\dot{H}+H^2)a\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t} - H(\\mathbf{x} \\cdot \\nabla_{\\mathbf{x}})(Ha\\mathbf{x} + \\mathbf{v}) = (\\dot{H}+H^2)a\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t} - H^2a\\mathbf{x} - H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v} = \\dot{H}a\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t} - H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}$。\n\n第二项，即平流导数，是：\n$$\n(\\mathbf{u} \\cdot \\nabla_{\\mathbf{r}}) \\mathbf{u} = \\left((Ha\\mathbf{x}+\\mathbf{v}) \\cdot \\frac{1}{a}\\nabla_{\\mathbf{x}}\\right) (Ha\\mathbf{x}+\\mathbf{v})\n$$\n$$\n= \\left(H\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}} + \\frac{1}{a}\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}}\\right) (Ha\\mathbf{x}+\\mathbf{v})\n$$\n$$\n= H\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}}(Ha\\mathbf{x}) + H\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}}(\\mathbf{v}) + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})(Ha\\mathbf{x}) + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}\n$$\n计算结果为：$H^2a\\mathbf{x} + H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v} + H\\mathbf{v} + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}$。\n\n合并左手边的所有项：\nLHS = $\\left(\\dot{H}a\\mathbf{x} + \\frac{\\partial \\mathbf{v}}{\\partial t} - H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}\\right) + \\left(H^2a\\mathbf{x} + H(\\mathbf{x}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v} + H\\mathbf{v} + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}\\right)$\n$$\n\\text{LHS} = \\frac{\\partial \\mathbf{v}}{\\partial t} + (\\dot{H}+H^2)a\\mathbf{x} + H\\mathbf{v} + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}\n$$\n\n动量方程的右手边（RHS）变换如下：\nRHS = $-\\frac{1}{\\rho}\\nabla_{\\mathbf{r}} P - \\nabla_{\\mathbf{r}} \\Phi = -\\frac{1}{a\\rho}\\nabla_{\\mathbf{x}} P - \\frac{1}{a}\\nabla_{\\mathbf{x}} \\Phi$。\n总引力势 $\\Phi$ 分为一个由平均密度 $\\bar{\\rho}(t)$ 引起的背景部分 $\\Phi_b$ 和一个由密度涨落 $\\delta\\rho = \\rho - \\bar{\\rho}$ 引起的本动部分 $\\phi$。背景势满足 $\\nabla^2_{\\mathbf{r}}\\Phi_b = 4\\pi G \\bar{\\rho}$。根据牛顿极限下的 Birkhoff 定理，$\\mathbf{r}$ 处的背景引力为 $-\\nabla_{\\mathbf{r}}\\Phi_b = -(\\frac{4\\pi G \\bar{\\rho}}{3})\\mathbf{r}$。根据非相对论流体的第二个 Friedmann 方程（$\\ddot{a}/a = \\dot{H}+H^2 = -4\\pi G \\bar{\\rho}/3$），我们有 $-\\nabla_{\\mathbf{r}}\\Phi_b = (\\dot{H}+H^2)\\mathbf{r} = (\\dot{H}+H^2)a\\mathbf{x}$。\n所以，$-\\frac{1}{a}\\nabla_{\\mathbf{x}}\\Phi = -\\frac{1}{a}\\nabla_{\\mathbf{x}}\\Phi_b - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi = -\\nabla_{\\mathbf{r}}\\Phi_b - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi = (\\dot{H}+H^2)a\\mathbf{x} - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi$。\n\n将完整的左手边和右手边相等：\n$$\n\\frac{\\partial \\mathbf{v}}{\\partial t} + (\\dot{H}+H^2)a\\mathbf{x} + H\\mathbf{v} + \\frac{1}{a}(\\mathbf{v}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v} = -\\frac{1}{a\\rho}\\nabla_{\\mathbf{x}} P + (\\dot{H}+H^2)a\\mathbf{x} - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi\n$$\n背景加速度项 $(\\dot{H}+H^2)a\\mathbf{x}$ 从两侧消去。我们得到共动动量方程：\n$$\n\\frac{\\partial \\mathbf{v}}{\\partial t} + H\\mathbf{v} + \\frac{1}{a}(\\mathbf{v} \\cdot \\nabla_{\\mathbf{x}})\\mathbf{v} = -\\frac{1}{a\\rho}\\nabla_{\\mathbf{x}} P - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi\n$$\n共动坐标下本动速度的全导数或对流导数为 $d\\mathbf{v}/dt = \\partial \\mathbf{v}/\\partial t + (\\dot{\\mathbf{x}}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v} = \\partial \\mathbf{v}/\\partial t + (\\frac{\\mathbf{v}}{a}\\cdot\\nabla_{\\mathbf{x}})\\mathbf{v}$。因此，方程可以写成：\n$$\n\\frac{d\\mathbf{v}}{dt} + H\\mathbf{v} = -\\frac{1}{a\\rho}\\nabla_{\\mathbf{x}} P - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi\n$$\n将源项隔离在右侧：\n$$\n\\frac{d\\mathbf{v}}{dt} = -H(t)\\mathbf{v} - \\frac{1}{a\\rho}\\nabla_{\\mathbf{x}} P - \\frac{1}{a}\\nabla_{\\mathbf{x}}\\phi\n$$\n项 **$-H(t)\\mathbf{v}$** 被明确地确定为“哈勃阻尼”项。它起到类似摩擦力的作用，随着宇宙的膨胀而削减本动速度。\n\n**所做假设：**\n1.  流体是理想的（无粘性且非导热）。\n2.  动力学是非相对论性的（$v \\ll c$，$P \\ll \\rho c^2$）。\n3.  引力在背景 FLRW 度规上用牛顿理论描述。这在远小于哈勃半径的尺度上是有效的。\n4.  宇宙是空间平坦的（$k=0$）。\n5.  引力势可分离为一个平滑的背景分量和一个本动扰动。\n\n**第二部分：离散化偏差的数值计算**\n\n我们的任务是使用两种不同的数值方案求解标量速度幅值 $v$ 的简化 ODE $\\frac{dv}{dt} = -H(t)v$，并计算相对误差。\n\n**欧拉更新（向前欧拉法）：**\n这是一种一阶显式方法。步 $n+1$ 的速度使用步 $n$ 的值进行更新：\n$$v_{n+1} = v_n + \\Delta t \\left( \\frac{dv}{dt} \\right)_n = v_n + \\Delta t (-H(t_n)v_n) = v_n(1 - H(t_n)\\Delta t)$$\n\n**拉格朗日更新（梯形法则）：**\n这是一种二阶隐式方法。更新规则对时间步长开始和结束时的导数进行平均：\n$$v_{n+1} = v_n + \\frac{\\Delta t}{2}\\left[ \\left(\\frac{dv}{dt}\\right)_n + \\left(\\frac{dv}{dt}\\right)_{n+1} \\right] = v_n + \\frac{\\Delta t}{2}[-H(t_n)v_n - H(t_{n+1})v_{n+1}]$$\n求解 $v_{n+1}$：\n$$v_{n+1}\\left(1 + \\frac{\\Delta t}{2}H(t_{n+1})\\right) = v_n\\left(1 - \\frac{\\Delta t}{2}H(t_n)\\right)$$\n$$v_{n+1} = v_n \\frac{1 - \\frac{1}{2}H(t_n)\\Delta t}{1 + \\frac{1}{2}H(t_{n+1})\\Delta t}$$\n\n下面的代码为每个测试用例实现了这两种方案，计算最终速度 $v_{\\mathrm{num}}(t_f)$，将其与给定的 $v_{\\mathrm{exact}}(t_f)$ 进行比较，并报告离散化偏差 $\\epsilon = (v_{\\mathrm{num}} - v_{\\mathrm{exact}})/v_{\\mathrm{exact}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the discretization bias for Eulerian (Forward Euler) and\n    Lagrangian (Trapezoidal) schemes for the Hubble drag ODE.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: constant Hubble, moderate step\n        {\n            \"H_func\": lambda t, H0=2.27e-18: H0,\n            \"H0\": 2.27e-18,\n            \"t0\": 0.0,\n            \"v0\": 3.0e5,\n            \"dt\": 5.0e16,\n            \"N\": 10,\n            \"exact_sol\": lambda v0, H0, N, dt, t0: v0 * np.exp(-H0 * N * dt)\n        },\n        # Case 2: matter-dominated expansion\n        {\n            \"H_func\": lambda t: 2.0 / (3.0 * t) if t > 0 else np.inf,\n            \"t0\": 1.0e16,\n            \"v0\": 3.0e5,\n            \"dt\": 5.0e15,\n            \"N\": 8,\n            \"exact_sol\": lambda v0, H0, N, dt, t0: v0 * (t0 / (t0 + N * dt))**(2.0/3.0)\n        },\n        # Case 3: constant Hubble, small step\n        {\n            \"H_func\": lambda t, H0=2.27e-18: H0,\n            \"H0\": 2.27e-18,\n            \"t0\": 0.0,\n            \"v0\": 3.0e5,\n            \"dt\": 1.0e15,\n            \"N\": 10,\n            \"exact_sol\": lambda v0, H0, N, dt, t0: v0 * np.exp(-H0 * N * dt)\n        },\n        # Case 4: constant Hubble, extreme coarse step\n        {\n            \"H_func\": lambda t, H0=2.27e-18: H0,\n            \"H0\": 2.27e-18,\n            \"t0\": 0.0,\n            \"v0\": 3.0e5,\n            \"dt\": 5.0e18,\n            \"N\": 1,\n            \"exact_sol\": lambda v0, H0, N, dt, t0: v0 * np.exp(-H0 * N * dt)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        t0 = case[\"t0\"]\n        v0 = case[\"v0\"]\n        dt = case[\"dt\"]\n        N = case[\"N\"]\n        H_func = case[\"H_func\"]\n        H0 = case.get(\"H0\") # Will be None if not applicable\n\n        # Calculate exact solution\n        v_exact = case[\"exact_sol\"](v0, H0, N, dt, t0)\n\n        # Eulerian (Forward Euler) simulation\n        v_euler = v0\n        t_current = t0\n        for _ in range(N):\n            H_current = H_func(t_current)\n            v_euler = v_euler * (1.0 - H_current * dt)\n            t_current += dt\n        \n        bias_eulerian = (v_euler - v_exact) / v_exact\n\n        # Lagrangian (Trapezoidal) simulation\n        v_lagrange = v0\n        t_current = t0\n        for _ in range(N):\n            H_current = H_func(t_current)\n            H_next = H_func(t_current + dt)\n            \n            numerator = 1.0 - 0.5 * H_current * dt\n            denominator = 1.0 + 0.5 * H_next * dt\n            \n            v_lagrange = v_lagrange * (numerator / denominator)\n            t_current += dt\n\n        bias_lagrangian = (v_lagrange - v_exact) / v_exact\n        \n        results.append([bias_eulerian, bias_lagrangian])\n\n    # Format the final output string exactly as required\n    inner_strings = [f\"[{e_E},{e_L}]\" for e_E, e_L in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3477164"}, {"introduction": "平流项是流体动力学的核心，它描述了各种物理量如何随流体一起运动。对该项的数值离散是区分欧拉方法（基于网格）和拉格朗日方法（基于粒子）的关键，并会导致截然不同的数值产物。在本练习中，你将实现一个经典的欧拉迎风格式和一个拉格朗日平移重映照方法，以直接观察和量化诸如数值扩散和相移之类的典型误差。[@problem_id:3477134]", "problem": "考虑周期性域中被动标量场的一维守恒平流，这是数值宇宙学流体动力学分量中出现的典型子问题。在固定空间网格上的平流可能会产生虚假的相位和振幅伪影，通常称为“幽灵流”误差。设域为 $[0,L]$，其中 $L=1$，标量场为 $u(x,t)$，满足线性平流方程\n$$\n\\partial_t u(x,t) + v\\,\\partial_x u(x,t) = 0,\n$$\n速度 $v$ 为常数。初始条件是一个以弧度指定的平滑周期模式：\n$$\nu(x,0) = \\sin(2\\pi x) + 0.25\\cos(6\\pi x),\n$$\n其中三角函数的参数以弧度为单位。所有量均为无量纲。\n\n您必须实现并比较两种数值方法在长时间内离散 $L_2$ 误差的增长：\n\n- 在具有 $N$ 个单元的均匀网格上使用欧拉有限体积法，采用与 $v$ 符号一致的迎风通量。网格在空间中固定，应用周期性边界条件，并且必须通过适当选择时间步长来确保稳定性。\n- 每步进行拉格朗日平移，然后保守重映到固定的欧拉网格上，使用特征线法在平移后获取固定网格位置上的场。在实践中，在每个时间步，将场平移物理距离 $v\\,\\Delta t$，然后通过尊重周期性的线性插值重映到原始的固定网格上。\n\n为了消除速度与网格之间可能掩盖长期误差累积的可公度性效应，强制使用一个无理数库朗-弗里德里希斯-列维 (CFL) 数。定义库朗数\n$$\nc \\equiv \\frac{v\\,\\Delta t}{\\Delta x},\n$$\n并为每个测试用例设置 $v = \\sqrt{2}$ 和 $c = \\frac{\\sqrt{3}}{7}$。这里 $\\Delta x=L/N$ 且 $\\Delta t = c\\,\\Delta x / v$。\n\n对于每个测试用例，从 $t=0$ 到 $t = n\\,\\Delta t$ 将两种方案演化 $n$ 个时间步，然后计算每种方案相对于精确解的离散 $L_2$ 误差\n$$\nu_{\\text{exact}}(x,t) = \\sin\\!\\big(2\\pi (x - v t)\\big) + 0.25\\cos\\!\\big(6\\pi (x - v t)\\big),\n$$\n使用单元中心 $x_i = (i+0.5)\\Delta x$ 上的离散范数：\n$$\n\\|e\\|_{2,\\Delta} = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left[u_i - u_{\\text{exact}}(x_i,t)\\right]^2 \\right)^{1/2}.\n$$\n\n从守恒律出发，基于第一性原理实现这两种方案，不要调用专门的平流黑箱程序。欧拉更新必须从控制体积上的通量差导出，拉格朗日步骤必须从特征线法及随后与周期性边界一致的基于插值的重映导出。\n\n所有输出均为无量纲浮点数。角度使用弧度。您的程序应评估以下测试套件，该套件涵盖了“理想路径”、步数的边界情况以及分辨率敏感性：\n\n- 测试 $1$：$N=64$，$n=1000$。\n- 测试 $2$：$N=128$，$n=2000$。\n- 测试 $3$：$N=64$，$n=0$。\n- 测试 $4$：$N=64$，$n=1$。\n\n对于每个测试用例，返回一个列表，其中包含两个浮点数，四舍五入到 $6$ 位小数：最终时刻的欧拉离散 $L_2$ 误差和拉格朗日离散 $L_2$ 误差。您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的、以逗号分隔的此类列表。例如，输出格式必须是\n[[e_{E,1},e_{L,1}],[e_{E,2},e_{L,2}],[e_{E,3},e_{L,3}],[e_{E,4},e_{L,4}]]，\n其中每个 $e_{E,k}$ 和 $e_{L,k}$ 都是四舍五入到 $6$ 位小数的浮点数。", "solution": "我们从一维空间中被动标量平流的守恒陈述开始，\n$$\n\\partial_t u(x,t) + \\partial_x (F) = 0, \\quad F = v\\,u,\n$$\n速度 $v$ 为常数。解析解可由特征线法得出。特征线满足 $dx/dt = v$，因此解沿着线 $x - v t = \\text{const}$ 是常数，这意味着\n$$\nu(x,t) = u_0(x - v t),\n$$\n其中 $u_0(x)$ 是初始条件。在 $[0,L]$ 上施加周期性边界条件时，以 $L$ 为模进行环绕可保持此形式。\n\n我们定义一个具有 $N$ 个单元的均匀网格，单元宽度为 $\\Delta x = L/N$，单元中心为 $x_i = (i+0.5)\\Delta x$，其中 $i \\in \\{0,\\dots,N-1\\}$。时间步长根据库朗-弗里德里希斯-列维 (CFL) 数 $c$ 来选择，\n$$\nc \\equiv \\frac{v\\,\\Delta t}{\\Delta x}.\n$$\n我们设置 $v=\\sqrt{2}$ 和 $c = \\frac{\\sqrt{3}}{7}$，这是一个无理数，因此\n$$\n\\Delta t = \\frac{c\\,\\Delta x}{v}.\n$$\n这保证了每步的平移量是单元宽度的无理数倍，从而避免了随时间推移与网格单元的精确对齐，并揭示了累积的数值误差。\n\n欧拉有限体积迎风格式：\n我们将守恒律在控制体积 $[x_{i-1/2},x_{i+1/2}]$ 上积分并应用散度定理，得到\n$$\n\\frac{d}{dt} \\bar{u}_i(t) = -\\frac{1}{\\Delta x}\\left(F_{i+1/2} - F_{i-1/2}\\right),\n$$\n其中 $\\bar{u}_i$ 是单元平均值。当 $v>0$ 时，界面处的迎风通量使用左侧状态，$F_{i+1/2} = v\\,\\bar{u}_i$，而 $F_{i-1/2} = v\\,\\bar{u}_{i-1}$。通过向前欧拉步在时间上进行离散化，\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(v\\,\\bar{u}_i^n - v\\,\\bar{u}_{i-1}^n\\right) = \\bar{u}_i^n - c\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\n$$\n对于 $v>0$ 的情况，当 $0  c \\le 1$ 时该格式是稳定的。通过定义 $\\bar{u}_{-1}^n \\equiv \\bar{u}_{N-1}^n$ 来强制施加周期性边界。虽然在实践中我们演化的是单元中心处的点值，但对于平滑场，此离散更新与有限体积迎风法一致，并能捕捉固定网格上的欧拉平流机制。\n\n拉格朗日平移与重映：\n根据特征线法，在时间 $t^{n+1}$ 位置 $x$ 处的精确连续解是 $u(x,t^{n+1}) = u(x - v\\,\\Delta t, t^n)$。为了在固定网格点 $x_i$ 上求值，我们需要 $u(\\cdot, t^n)$ 在离网位置 $y_i = x_i - v\\,\\Delta t$ 处的值。在离散网格上，我们通过在最近的单元中心样本之间进行周期性线性插值来近似这个值。设对应于 $y_i$ 的分数索引为\n$$\nj_i = \\frac{y_i}{\\Delta x} - 0.5,\n$$\n其整数部分为 $k_i = \\lfloor j_i \\rfloor$，小数部分为 $\\theta_i = j_i - k_i$。周期性索引为 $k_i \\bmod N$ 和 $(k_i+1) \\bmod N$。在 $x_i$ 处的重映值为\n$$\nu_i^{n+1} = (1-\\theta_i) u_{k_i}^n + \\theta_i u_{k_i+1}^n,\n$$\n其中所有索引都对 $N$ 取模以强制周期性。这实现了在每个时间步进行一次拉格朗日步骤（平移 $v\\,\\Delta t$），然后保守重映到固定的欧拉网格上。虽然连续的特征线解是精确的，但离散插值引入了受控的误差，其性质与欧拉数值扩散和色散不同。\n\n精确解与误差度量：\n在最终时间 $t^n = n\\,\\Delta t$，网格上的精确解为\n$$\nu_{\\text{exact}}(x_i,t^n) = \\sin\\!\\big(2\\pi(x_i - v\\,t^n)\\big) + 0.25\\cos\\!\\big(6\\pi(x_i - v\\,t^n)\\big).\n$$\n我们计算离散 $L_2$ 误差为\n$$\n\\|e\\|_{2,\\Delta} = \\left(\\Delta x \\sum_{i=0}^{N-1} \\left[u_i^n - u_{\\text{exact}}(x_i,t^n)\\right]^2 \\right)^{1/2}.\n$$\n该离散范数是连续 $L_2$ 范数的黎曼和近似，保持了随分辨率变化的正确缩放关系。\n\n算法设计：\n- 初始化网格和单元中心 $x_i = (i+0.5)\\Delta x$，并设置 $u_i^0 = \\sin(2\\pi x_i) + 0.25\\cos(6\\pi x_i)$。\n- 计算 $\\Delta t = c\\,\\Delta x / v$，其中 $v=\\sqrt{2}$ 且 $c=\\sqrt{3}/7$。\n- 对于欧拉平流，使用迎风更新 $\\bar{u}_i^{n+1} = \\bar{u}_i^n - c(\\bar{u}_i^n - \\bar{u}_{i-1}^n)$ 迭代 $n$ 次。\n- 对于拉格朗日平移，通过对在 $x_i - v\\,\\Delta t$ 处求值的 $u^n$ 进行周期性线性插值迭代 $n$ 次，以获得 $u^{n+1}$。\n- 经过 $n$ 步后，计算 $t^n = n\\,\\Delta t$，构建 $u_{\\text{exact}}(x_i,t^n)$，并评估每种方案的离散 $L_2$ 误差。\n- 对每个测试用例重复此过程。无理数 $c$ 可防止每步位移与网格间距之间的同步，从而揭示数值伪影的长期累积。\n\n数值考虑：\n- 欧拉迎风法是一阶精确的，并引入随时间累积的数值扩散，通常表现为被平流模式的振幅衰减。其相位误差取决于 $c$ 和分辨率。\n- 带线性重映的拉格朗日平移每步能更有效地保持振幅，但会引入具有不同色散特性的插值误差。在长时间内，无理数的每步位移会阻止重映误差的周期性抵消，从而可以清晰地比较误差增长率。\n- 对三角函数使用弧度可确保与初始模式定义的一致性。所有量均为无量纲，不需要进行物理单位转换。\n\n输出规格：\n对于每个测试用例，返回一个列表 $[e_E, e_L]$，其中 $e_E$ 是欧拉离散 $L_2$ 误差，$e_L$ 是拉格朗日离散 $L_2$ 误差，两者均四舍五入到 $6$ 位小数。将四个测试用例的结果汇总到单行中，格式为\n[[e_{E,1},e_{L,1}],[e_{E,2},e_{L,2}],[e_{E,3},e_{L,3}],[e_{E,4},e_{L,4}]]。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef initial_condition(x):\n    # Trigonometric functions use radians by default in numpy.\n    return np.sin(2.0 * np.pi * x) + 0.25 * np.cos(6.0 * np.pi * x)\n\ndef exact_solution(x, v, t):\n    return np.sin(2.0 * np.pi * (x - v * t)) + 0.25 * np.cos(6.0 * np.pi * (x - v * t))\n\ndef eulerian_upwind(u, c):\n    # v  0 assumed; upwind uses left neighbor. Periodic wrap.\n    # u_{i}^{n+1} = u_{i}^{n} - c (u_{i}^{n} - u_{i-1}^{n})\n    u_prev = u\n    u_shift_left = np.roll(u_prev, 1)\n    return u_prev - c * (u_prev - u_shift_left)\n\ndef lagrangian_translate_linear(u, shift, dx):\n    # shift is physical distance v*dt. Map u(x - shift) to the fixed grid.\n    # Cell centers at x_i = (i + 0.5) * dx. The fractional index for y_i = x_i - shift is:\n    # j = y / dx - 0.5. Then linear interp between floor(j) and floor(j)+1 with periodic wrap.\n    N = u.size\n    # Indices grid i=0..N-1 corresponds to x_i = (i+0.5)*dx\n    # Compute j for all i in vectorized form: j_i = i - shift/dx\n    # Because j = y/dx - 0.5 = ((i+0.5)dx - shift)/dx - 0.5 = i - shift/dx\n    j = np.arange(N, dtype=float) - (shift / dx)\n    k = np.floor(j).astype(int)\n    theta = j - k\n    k0 = np.mod(k, N)\n    k1 = np.mod(k + 1, N)\n    return (1.0 - theta) * u[k0] + theta * u[k1]\n\ndef discrete_L2(u, u_exact, dx):\n    return np.sqrt(dx * np.sum((u - u_exact) ** 2))\n\ndef run_case(N, n_steps, v, c, L=1.0):\n    dx = L / N\n    dt = c * dx / v\n    x_centers = (np.arange(N, dtype=float) + 0.5) * dx\n    # Initialize\n    u0 = initial_condition(x_centers)\n    # Eulerian evolution\n    u_e = u0.copy()\n    # Lagrangian evolution\n    u_l = u0.copy()\n    # Per-step physical shift\n    shift = v * dt\n    for _ in range(n_steps):\n        u_e = eulerian_upwind(u_e, c)\n        u_l = lagrangian_translate_linear(u_l, shift, dx)\n    t_final = n_steps * dt\n    u_exact = exact_solution(x_centers, v, t_final)\n    err_e = discrete_L2(u_e, u_exact, dx)\n    err_l = discrete_L2(u_l, u_exact, dx)\n    return err_e, err_l\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (N, n_steps)\n    test_cases = [\n        (64, 1000),\n        (128, 2000),\n        (64, 0),\n        (64, 1),\n    ]\n    # Constants: v = sqrt(2), c = sqrt(3)/7 (irrational Courant number)\n    v = np.sqrt(2.0)\n    c = np.sqrt(3.0) / 7.0\n\n    results = []\n    for N, n_steps in test_cases:\n        err_e, err_l = run_case(N, n_steps, v, c, L=1.0)\n        # Round to 6 decimal places as required\n        results.append([round(err_e, 6), round(err_l, 6)])\n\n    # Final print statement in the exact required format.\n    # Format: [[eE1,eL1],[eE2,eL2],[eE3,eL3],[eE4,eL4]]\n    print(f\"[{','.join('[' + ','.join(map(lambda x: f'{x:.6f}', pair)) + ']' for pair in results)}]\")\n\nsolve()\n```", "id": "3477134"}, {"introduction": "欧拉快照提供了流体在固定位置的状态，而拉格朗日描述则追踪单个流体元素的历史。当发生壳层穿越（shell-crossing）后，欧拉视图会变得多值，从而丢失了流体元素的唯一历史信息。最优输运理论为从拉格朗日分布到欧拉分布的重构提供了一个强大的框架。本练习挑战你使用最优输运理论从欧拉密度场重构拉格朗日映射，揭示两种描述在信息内容上的根本差异，并突显了在复杂的多流区域进行重构的局限性。[@problem_id:3477115]", "problem": "考虑一个一维周期性宇宙学区域，其坐标为 $x \\in [0,1)$，以及一个均匀的初始拉格朗日坐标 $q \\in [0,1)$。初始拉格朗日质量分布是均匀的，密度为 $\\rho_{\\mathrm{L}}(q)=1$。在给定时间的欧拉快照是由一个作用于 $q$ 的确定性拉格朗日到欧拉的映射 $x(q)$ 生成，然后进行模1的周期性包裹。欧拉密度 $\\rho_{\\mathrm{E}}(x)$ 由质量守恒定义，因此对于任何区间 $I \\subset [0,1)$，都有 $\\int_{I} \\rho_{\\mathrm{E}}(x)\\,dx = \\int_{x^{-1}(I)} \\rho_{\\mathrm{L}}(q)\\,dq$，其中 $x^{-1}(I)$ 是拉格朗日空间中的原像。欧拉描述可以呈现出多流区域，在这些区域中，多个不相交的拉格朗日区间映射到同一个欧拉区间。\n\n您将通过求解二次代价最优输运问题，从欧拉快照 $\\rho_{\\mathrm{E}}(x)$ 中重构一个拉格朗日映射 $\\tilde{x}(q)$：找到一个可测映射 $T:[0,1)\\to[0,1)$，它将 $\\rho_{\\mathrm{L}}(q)\\,dq$ 前推为 $\\rho_{\\mathrm{E}}(x)\\,dx$，并最小化代价泛函 $J[T] = \\int_{0}^{1} \\left(d_{\\mathrm{per}}(T(q),q)\\right)^{2} \\rho_{\\mathrm{L}}(q)\\,dq$，其中 $d_{\\mathrm{per}}$ 是单位圆上的周期性距离，定义为 $d_{\\mathrm{per}}(x,q) = \\min\\{|x-q|,\\,1-|x-q|\\}$。在一维情况下，对于二次代价，最优输运映射是单调不减的，并由质量守恒唯一确定。您的程序必须实现此重构，并评估质量元被恢复的程度，尤其是在多流区域中。\n\n基本原理：\n- 质量守恒：$\\int_{I} \\rho_{\\mathrm{E}}(x)\\,dx = \\int_{x^{-1}(I)} \\rho_{\\mathrm{L}}(q)\\,dq$。\n- 拉格朗日映射的定义：$x(q) = q - a \\sin(2\\pi q)$，并进行周期性包裹 $x(q) \\mapsto x(q)\\bmod 1$，其中 $a$ 是一个实数振幅参数。这个确定性映射是 Zel’dovich 近似的一个理想化一维类比，当 $\\frac{dx}{dq}$ 的符号改变时，它可以产生多流现象。\n- 在具有均匀源密度和周期性区域的一维二次代价最优输运问题中，重构一个单调映射 $\\tilde{x}(q)$，使其最小化 $\\int_{0}^{1} \\left(d_{\\mathrm{per}}(\\tilde{x}(q),q)\\right)^{2} \\,dq$，同时精确匹配欧拉密度 $\\rho_{\\mathrm{E}}(x)$。\n\n算法要求：\n- 将 $q$ 用 $N$ 个在 $[0,1)$ 中等距的样本离散化，并为每个样本生成欧拉位置 $x_{\\mathrm{true}}(q)=\\left(q - a \\sin(2\\pi q)\\right)\\bmod 1$。\n- 通过对集合 $\\{x_{\\mathrm{true}}(q)\\}$ 进行直方图统计，在覆盖 $[0,1)$ 的 $M$ 个均匀区间（bin）上估计欧拉密度 $\\rho_{\\mathrm{E}}(x)$，然后除以区间的宽度以获得与 $\\int_{0}^{1} \\rho_{\\mathrm{E}}(x)\\,dx = 1$ 一致的密度。\n- 通过求解一维周期性二次代价最优输运问题，将均匀的拉格朗日密度 $\\rho_{\\mathrm{L}}(q)=1$ 前推为离散的欧拉密度估计 $\\rho_{\\mathrm{E}}(x)$，从而重构最优输运映射 $\\tilde{x}(q)$。通过累积质量平衡在数值上实现该解法，不使用问题陈述中提供的快捷方式。\n- 通过 $M$ 个均匀区间定义欧拉区间。对于每个粒子索引 $i$，令 $b_{\\mathrm{true}}(i)$ 为包含 $x_{\\mathrm{true}}(q_i)$ 的区间的索引，令 $b_{\\mathrm{OT}}(i)$ 为包含 $\\tilde{x}(q_i)$ 的区间的索引。\n- 定义一个逐区间的（bin-wise）多流指示器：对于每个区间 $b$，收集映射到该区间的粒子索引 $\\{i: b_{\\mathrm{true}}(i)=b\\}$ 并按 $i$ 排序。计算此索引列表中的连续段数量；如果一个区间只有一个连续段，则称其为单流区间；如果多于一个连续段，则称为多流区间。\n- 计算以下定量评估：\n    1. 最优输运平均周期性位移平方 $C_{\\mathrm{OT}} = \\frac{1}{N}\\sum_{i=1}^{N}\\left(d_{\\mathrm{per}}(\\tilde{x}(q_i),q_i)\\right)^{2}$，以无量纲单位表示。\n    2. 重构位置与真实位置之间的均方根周期性误差 $E_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(d_{\\mathrm{per}}(\\tilde{x}(q_i),x_{\\mathrm{true}}(q_i))\\right)^{2}}$，无量纲。\n    3. 全局区间分配准确率 $A_{\\mathrm{global}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{1}\\{b_{\\mathrm{OT}}(i)=b_{\\mathrm{true}}(i)\\}$，无量纲。\n    4. 单流区间分配准确率 $A_{\\mathrm{single}}$，通过将指示器求和限制在仅位于单流区间的粒子上计算得出，无量纲。\n    5. 多流区间分配准确率 $A_{\\mathrm{multi}}$，通过将指示器求和限制在仅位于多流区间的粒子上计算得出，无量纲。如果没有多流区间，按约定定义 $A_{\\mathrm{multi}}=1.0$。\n    6. 单流和多流区间的计数 $N_{\\mathrm{single}}$ 和 $N_{\\mathrm{multi}}$，分别为整数。\n\n测试套件和参数：\n- 对所有案例使用 $N=4096$ 个拉格朗日样本和 $M=256$ 个欧拉区间。\n- 使用以下振幅 $a$：\n    - 案例1：$a=0.10$（单流状态）。\n    - 案例2：$a=\\frac{1}{2\\pi}\\approx 0.15915494309189535$（壳层穿越的开始）。\n    - 案例3：$a=0.30$（中等多流）。\n    - 案例4：$a=0.50$（强多流）。\n所有量均为无量纲；所有输出必须以无量纲单位表示，浮点数应四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成一行输出，包含一个由各案例结果列表组成的逗号分隔列表，每个案例列表按 $[C_{\\mathrm{OT}}, E_{\\mathrm{RMS}}, A_{\\mathrm{global}}, A_{\\mathrm{single}}, A_{\\mathrm{multi}}, N_{\\mathrm{single}}, N_{\\mathrm{multi}}]$ 的顺序排列，并用一对中括号括起来。例如，总输出应类似于 $[[r_{1,1},r_{1,2},\\dots],[r_{2,1},\\dots],\\dots]$，其中每个 $r_{i,j}$ 表示为按规定四舍五入到六位小数的浮点数或整数。", "solution": "该问题要求实现并评估一种对宇宙学质量分布的一维周期性最优输运（OT）重构方法。我们给定一个真实的、确定性的拉格朗日到欧拉的映射，它类似于 Zel'dovich 近似，任务是从其产生的欧拉密度中重构此映射。重构质量的评估重点在于其能否正确地将质量元放置在单流与多流区域。\n\n问题的核心在于流体或粒子系统的两种描述之间的对比。拉格朗日描述追踪由初始坐标 $q \\in [0,1)$ 标记的单个粒子。欧拉描述在固定的空间位置 $x \\in [0,1)$ 上提供系统性质（如密度 $\\rho_{\\mathrm{E}}(x)$）的快照。它们之间的联系是映射 $x(q)$，它给出了初始拉格朗日坐标为 $q$ 的粒子的欧拉位置。\n\n指定的“真实”映射是 $x_{\\mathrm{true}}(q) = (q - a \\sin(2\\pi q)) \\pmod 1$。参数 $a$ 控制位移的振幅。展开映射的导数是 $\\frac{dx}{dq} = 1 - 2\\pi a \\cos(2\\pi q)$。如果 $a > 1/(2\\pi)$，对于某些 $q$，该导数可能变为负值。这意味着映射 $x_{\\mathrm{true}}(q)$ 不再是单调的；不同的初始粒子可以被映射到相同的最终位置，这种现象被称为壳层穿越或多流。这会产生高密度和流重叠的区域，这些是宇宙结构形成的基本特征。\n\n我们的任务是逆转这一过程：给定由此映射产生的欧拉密度 $\\rho_{\\mathrm{E}}(x)$，我们希望找到一个“最优”映射 $\\tilde{x}(q)$，它将初始均匀的拉格朗日密度 $\\rho_{\\mathrm{L}}(q)=1$ 变换为给定的 $\\rho_{\\mathrm{E}}(x)$。最优性的准则是最小化二次代价泛函 $J[T] = \\int_{0}^{1} (d_{\\mathrm{per}}(T(q),q))^{2} \\rho_{\\mathrm{L}}(q)\\,dq$，其中 $d_{\\mathrm{per}}$ 是周期性距离。这是一个最优输运问题。\n\n在此适用的一维最优输运的一个关键定理指出，对于二次代价函数，最优映射 $T(q)$（我们记作 $\\tilde{x}(q)$）是唯一确定且单调不减的。这个映射可以通过在累积分布函数中强制执行质量守恒来找到。令 $M_{\\mathrm{L}}(q) = \\int_0^q \\rho_{\\mathrm{L}}(q')\\,dq'$ 为拉格朗日空间中的累积质量，令 $M_{\\mathrm{E}}(x) = \\int_0^x \\rho_{\\mathrm{E}}(x')\\,dx'$ 为欧拉空间中的累积质量。质量守恒原理规定，拉格朗日坐标直到 $q$ 的粒子质量必须等于欧拉坐标直到 $\\tilde{x}(q)$ 的物质质量。这给出了关系式 $M_{\\mathrm{L}}(q) = M_{\\mathrm{E}}(\\tilde{x}(q))$。\n\n鉴于初始密度是均匀的，$\\rho_{\\mathrm{L}}(q) = 1$，拉格朗日累积质量就是 $M_{\\mathrm{L}}(q) = q$。该关系式变为 $q = M_{\\mathrm{E}}(\\tilde{x}(q))$。求解我们的重构映射，我们得到 $\\tilde{x}(q) = M_{\\mathrm{E}}^{-1}(q)$，其中 $M_{\\mathrm{E}}^{-1}$ 是欧拉累积质量函数的反函数（也称为分位数函数）。\n\n数值算法如下：\n1.  将拉格朗日空间用 $N=4096$ 个粒子离散化，其位置为 $q_i = (i+0.5)/N$，$i=0, 1, \\dots, N-1$。每个粒子代表一个质量为 $1/N$ 的质量元。\n2.  对于给定的振幅 $a$，计算真实的欧拉位置 $x_{\\mathrm{true}}(q_i) = (q_i - a \\sin(2\\pi q_i)) \\pmod 1$。\n3.  通过将 $N$ 个位置 $\\{x_{\\mathrm{true}}(q_i)\\}$ 直方图化到 $[0,1)$ 上的 $M=256$ 个均匀区间中来估计欧拉密度。这给出了每个区间 $j$ 的计数 $N_j$。区间 $j$ 中的质量为 $m_j = N_j/N$，分段常数密度为 $\\rho_{\\mathrm{E}, j} = m_j / (1/M) = M N_j / N$。\n4.  数值上构造离散的欧拉累积质量函数 $C_j = \\sum_{k=0}^{j} m_k$，它给出了直到区间 $j$ 右边缘的总质量。函数 $M_{\\mathrm{E}}(x)$ 是这些值的分段线性插值。\n5.  为了找到重构位置 $\\tilde{x}(q_i)$，我们计算其目标累积质量，即其在均匀分布中的分位数：$q_i = (i+0.5)/N$。然后我们通过首先找到满足 $C_{j-1}  q_i \\le C_j$ 的区间 $j$，再在该区间内进行线性插值，找到对应于累积质量 $q_i$ 的位置 $\\tilde{x}(q_i)$，从而对 $M_{\\mathrm{E}}$ 进行反演。\n6.  真实映射 $x_{\\mathrm{true}}(q)$ 在多流区域是非单调的，而重构映射 $\\tilde{x}(q)$ 根据其构造是单调的。它们之间的差异，尤其是在多流区域中的差异，是研究的对象。\n7.  我们为每个欧拉区间定义一个多流指示器。如果落入某个区间的拉格朗日粒子来自初始拉格朗日线上的多个不连续段，则该区间被分类为多流区间。这通过对映射到给定区间的所有粒子 $\\{q_i\\}$ 的原始索引 $i$ 进行排序，并计算排序后索引列表中的连续块数量来诊断。\n8.  最后，我们计算一组度量指标来量化最优输运重构的性能。$C_{\\mathrm{OT}}$ 衡量最优输运映射本身的总位移平方。$E_{\\mathrm{RMS}}$ 测量重构位置 $\\tilde{x}(q_i)$ 与真实位置 $x_{\\mathrm{true}}(q_i)$ 之间的均方根误差，量化了重构的物理误差。区间分配准确率 $A_{\\mathrm{global}}$、$A_{\\mathrm{single}}$ 和 $A_{\\mathrm{multi}}$ 测量被正确放置到其真实欧拉区间的粒子比例，分析是全局性的，并且根据粒子的真实目的地是单流区间还是多流区间进行条件分析。这使得我们能精确评估最优输运重构如何处理复杂的折叠结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D optimal transport reconstruction problem for four test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (amplitude a)\n        0.10,\n        1.0 / (2.0 * np.pi), # approx 0.15915494309189535\n        0.30,\n        0.50,\n    ]\n    \n    # Discretization parameters\n    N = 4096\n    M = 256\n\n    all_results = []\n\n    for a in test_cases:\n        # Step 1: Generate true particle data\n        q = (np.arange(N) + 0.5) / N\n        x_true = (q - a * np.sin(2 * np.pi * q)) % 1.0\n\n        # Step 2: Estimate Eulerian density on M bins\n        bin_width = 1.0 / M\n        # np.histogram gives counts N_j\n        counts, _ = np.histogram(x_true, bins=M, range=(0, 1))\n        \n        # Mass per bin\n        mass_per_bin = counts / N\n        # Cumulative mass function at bin edges\n        # C_j = mass up to right edge of bin j\n        cumulative_mass = np.cumsum(mass_per_bin)\n        # Prepend 0 for mass at x=0\n        cumulative_mass = np.insert(cumulative_mass, 0, 0)\n        \n        # Step 3: Reconstruct the optimal transport map x_ot(q)\n        # Target cumulative mass for each particle\n        target_mass = (np.arange(N) + 0.5) / N\n        \n        # Find the bin index for each particle via mass conservation\n        # j such that C_{j-1}  target_mass = C_j\n        bin_indices = np.searchsorted(cumulative_mass, target_mass, side='right') - 1\n        \n        # Handle cases where a bin might have zero mass.\n        # This shouldn't happen with the chosen target_mass, but as a safeguard:\n        bin_indices = np.maximum(0, bin_indices)\n\n        mass_in_found_bins = mass_per_bin[bin_indices]\n        cum_mass_before_bin = cumulative_mass[bin_indices]\n\n        # Linearly interpolate position within the bin\n        # Avoid division by zero for empty bins (though target_mass should not fall there)\n        # delta_x = (target_mass - mass_before) / density\n        # density = mass_in_bin / bin_width\n        delta_x = np.zeros_like(target_mass)\n        non_empty_mask = mass_in_found_bins > 0\n        \n        delta_mass = target_mass[non_empty_mask] - cum_mass_before_bin[non_empty_mask]\n        density_in_bin = mass_in_found_bins[non_empty_mask] / bin_width\n        delta_x[non_empty_mask] = delta_mass / density_in_bin\n\n        x_ot = (bin_indices / M) + delta_x\n        # Ensure results are within [0,1] domain\n        x_ot = np.clip(x_ot, 0.0, 1.0)\n        \n        # Step 4: Compute quantitative assessments\n        \n        def periodic_distance_sq(x1, x2):\n            d = np.abs(x1 - x2)\n            dist = np.minimum(d, 1.0 - d)\n            return dist**2\n\n        # 4.1 C_OT: optimal transport mean squared periodic displacement\n        c_ot = np.mean(periodic_distance_sq(x_ot, q))\n        \n        # 4.2 E_RMS: root mean squared periodic error\n        e_rms = np.sqrt(np.mean(periodic_distance_sq(x_ot, x_true)))\n        \n        # 4.3 Bin assignments\n        # Use np.minimum to handle x=1.0 case mapping to M instead of M-1\n        b_true = np.minimum(np.floor(x_true * M).astype(int), M - 1)\n        b_ot = np.minimum(np.floor(x_ot * M).astype(int), M - 1)\n        \n        # 4.4 Global bin-assignment accuracy\n        a_global = np.mean(b_ot == b_true)\n        \n        # 4.5 Multistream analysis\n        is_multistream_bin = np.zeros(M, dtype=bool)\n        bin_contents = [[] for _ in range(M)]\n        for i, b in enumerate(b_true):\n            bin_contents[b].append(i)\n            \n        n_single = 0\n        n_multi = 0\n        for b in range(M):\n            indices = bin_contents[b]\n            if len(indices) = 1:\n                runs = len(indices)\n            else:\n                # Indices must be sorted to count runs\n                sorted_indices = np.sort(indices)\n                runs = 1 + np.sum(np.diff(sorted_indices) > 1)\n            \n            if runs > 1:\n                is_multistream_bin[b] = True\n                n_multi += 1\n            else:\n                n_single += 1\n\n        # Particle masks for single-stream and multi-stream bins\n        particle_in_ss_bin_mask = ~is_multistream_bin[b_true]\n        particle_in_ms_bin_mask = is_multistream_bin[b_true]\n        \n        n_ss_particles = np.sum(particle_in_ss_bin_mask)\n        n_ms_particles = np.sum(particle_in_ms_bin_mask)\n        \n        # 4.6 Single-stream accuracy\n        if n_ss_particles == 0:\n            a_single = 1.0\n        else:\n            correct_ss = np.sum((b_ot == b_true)[particle_in_ss_bin_mask])\n            a_single = correct_ss / n_ss_particles\n            \n        # 4.7 Multistream accuracy\n        if n_multi == 0: # Implies n_ms_particles == 0\n            a_multi = 1.0\n        else:\n            correct_ms = np.sum((b_ot == b_true)[particle_in_ms_bin_mask])\n            a_multi = correct_ms / n_ms_particles\n\n        # Collate results for this case\n        case_results = [c_ot, e_rms, a_global, a_single, a_multi, n_single, n_multi]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    case_strings = []\n    for res in all_results:\n        # First 5 are floats, last 2 are ints\n        float_parts = [f\"{v:.6f}\" for v in res[:5]]\n        int_parts = [str(v) for v in res[5:]]\n        s = f\"[{','.join(float_parts + int_parts)}]\"\n        case_strings.append(s)\n\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "3477115"}]}