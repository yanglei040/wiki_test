{"hands_on_practices": [{"introduction": "再电离模拟的核心是电离辐射的输运。本练习 ([@problem_id:3488852]) 将指导你构建一个光子守恒的有限体积格式，这是一种基本的数值方法，它通过离散化辐射转移方程来严格保证光子总数的守恒。完成此练习将使你对宇宙学模拟中如何实施守恒律，以及数值稳定性在刚性系统中的重要性，有具体而深入的理解。", "problem": "考虑在再电离时期（Epoch of Reionization, EoR）氢致电离光子的数值输运。一种光子守恒的有限体积离散化方法应在每个控制体积中推进光子数，使得全局光子收支与源发射、边界通量和吸收精确平衡。从笛卡尔控制体积上的积分形式光子数守恒定律出发，该定律可由辐射转移方程在灰体（单频率箱）近似下导出：单元内光子数的时间变化率等于通过各个面的净光子流入量加上单元内发射量减去吸收量。设光速为 $c$（单位 $\\mathrm{m\\,s^{-1}}$），吸收系数为 $\\kappa$（单位 $\\mathrm{m^{-1}}$），光子源率密度为 $S$（单位 $\\mathrm{photons\\,m^{-3}\\,s^{-1}}$），光子数密度为 $n_{\\gamma}$（单位 $\\mathrm{photons\\,m^{-3}}$）。汇率密度为 $c\\,\\kappa\\,n_{\\gamma}$（单位 $\\mathrm{photons\\,m^{-3}\\,s^{-1}}$）。对于一个均匀的笛卡尔网格，其单元体积为 $V$，面面积为 $A$，定义每个单元的光子数 $N_i = \\int_{V_i} n_{\\gamma}\\,\\mathrm{d}V$（单位 $\\mathrm{photons}$），以及面光子率 $\\Phi_{i\\pm\\frac{1}{2}} = \\int_{A_{i\\pm\\frac{1}{2}}} \\boldsymbol{F}\\cdot\\mathrm{d}\\boldsymbol{A}$（单位 $\\mathrm{photons\\,s^{-1}}$），其中 $\\boldsymbol{F}$ 是光子数通量密度（单位 $\\mathrm{photons\\,m^{-2}\\,s^{-1}}$）。假设沿 $x$ 轴的一维均匀网格，单元索引为 $i \\in \\{0,\\dots,N_x-1\\}$，面位于 $i\\pm\\frac{1}{2}$；右侧面的外法线方向为 $+\\hat{x}$ 方向，因此正的 $\\Phi$ 表示光子向 $x$ 增加的方向输运。设单元 $i$ 内的体积积分源为 $S_i V$（单位 $\\mathrm{photons\\,s^{-1}}$），记作 $Q_i$。\n\n你的任务：\n\n1) 推导一个离散的、光子守恒的有限体积更新法则，用于在一个时间步长 $\\Delta t$（单位 $\\mathrm{s}$）内更新每个单元的光子数。该更新法则在吸收汇项上应是全隐式的，以保证对刚性吸收问题的正定性和鲁棒性。更新法则必须用单元量 $N_i^n$ 和 $N_i^{n+1}$（单位 $\\mathrm{photons}$）、面光子率 $\\Phi_{i\\pm\\frac{1}{2}}$（单位 $\\mathrm{photons\\,s^{-1}}$）、单元积分源率 $Q_i$（单位 $\\mathrm{photons\\,s^{-1}}$）、光速 $c$（单位 $\\mathrm{m\\,s^{-1}}$）和吸收系数 $\\kappa_i$（单位 $\\mathrm{m^{-1}}$）来表示。\n\n2) 为一维网格实现所推导的更新法则。在该网格中，几何信息已如上所述被吸收到 $N_i$ 和 $\\Phi_{i\\pm\\frac{1}{2}}$ 的定义中，因此在 $\\Delta t$ 时间内，通量对 $N_i$ 的贡献为 $-\\Delta t\\,(\\Phi_{i+\\frac{1}{2}}-\\Phi_{i-\\frac{1}{2}})$（单位 $\\mathrm{photons}$）。\n\n3) 对下面的每个测试用例，执行一个时间步长，并计算由下式定义的绝对全局守恒残差 $R$（单位 $\\mathrm{photons}$）\n$$\nR \\equiv \\left|\\left(\\sum_{i=0}^{N_x-1} N_i^{n+1}-\\sum_{i=0}^{N_x-1} N_i^{n}\\right) - \\left(-\\Delta t\\,\\big(\\Phi_{N_x-\\frac{1}{2}}-\\Phi_{-\\frac{1}{2}}\\big) + \\Delta t\\,\\sum_{i=0}^{N_x-1} Q_i - \\Delta t\\,\\sum_{i=0}^{N_x-1} c\\,\\kappa_i\\,N_i^{n+1}\\right)\\right| ,\n$$\n其中 $\\Phi_{-\\frac{1}{2}}$ 和 $\\Phi_{N_x-\\frac{1}{2}}$ 分别是左右边界的面光子率。一个光子守恒的格式应该产生与舍入误差相当的 $R$。\n\n使用六位有效数字的科学记数法表示残差 $R$ 的最终答案（单位 $\\mathrm{photons}$）。\n\n测试套件（所有量均应按上述指定单位解释）：\n\n- 用例 A（正常路径）：$N_x = 4$，初始每单元光子数 $[N_0^n,N_1^n,N_2^n,N_3^n] = [10^6, 2\\times 10^6, 5\\times 10^5, 1.5\\times 10^6]$，面光子率 $[\\Phi_{-\\frac{1}{2}},\\Phi_{\\frac{1}{2}},\\Phi_{\\frac{3}{2}},\\Phi_{\\frac{5}{2}},\\Phi_{\\frac{7}{2}}] = [10^5, 5\\times 10^4, -2\\times 10^4, 0, -5\\times 10^4]$，单元积分源率 $[Q_0,Q_1,Q_2,Q_3] = [10^4, 0, 2\\times 10^4, 0]$，均匀吸收系数 $\\kappa_i = 10^{-10}$（对所有 $i$），$\\Delta t = 10^{-1}$，$c = 2.99792458\\times 10^8$。\n\n- 用例 B（零通量边界，仅有源和吸收）：$N_x = 3$，初始 $[N_0^n,N_1^n,N_2^n] = [0,0,0]$，面 $[\\Phi_{-\\frac{1}{2}},\\Phi_{\\frac{1}{2}},\\Phi_{\\frac{3}{2}},\\Phi_{\\frac{5}{2}}] = [0,0,0,0]$，源 $[Q_0,Q_1,Q_2] = [10^5,10^5,10^5]$，$\\kappa_i = 10^{-9}$（对所有 $i$），$\\Delta t = 1$，$c = 2.99792458\\times 10^8$。\n\n- 用例 C（真空，检验有源和平衡边界通量下的严格守恒）：$N_x = 2$，初始 $[N_0^n,N_1^n] = [10^3, 2\\times 10^3]$，面 $[\\Phi_{-\\frac{1}{2}},\\Phi_{\\frac{1}{2}},\\Phi_{\\frac{3}{2}}] = [10^2,10^2,10^2]$，源 $[Q_0,Q_1] = [0,10^2]$，$\\kappa_i = 0$（对所有 $i$），$\\Delta t = 10$，$c = 2.99792458\\times 10^8$。\n\n- 用例 D（刚性吸收，隐式汇项下的正定性）：$N_x = 1$，初始 $[N_0^n] = [10^9]$，面 $[\\Phi_{-\\frac{1}{2}},\\Phi_{\\frac{1}{2}}] = [0,0]$，源 $[Q_0] = [10^8]$，$\\kappa_0 = 1$，$\\Delta t = 10^{-9}$，$c = 2.99792458\\times 10^8$。\n\n- 用例 E（边界净流入，无源，无吸收）：$N_x = 3$，初始 $[N_0^n,N_1^n,N_2^n] = [10^4,2\\times 10^4,3\\times 10^4]$，面 $[\\Phi_{-\\frac{1}{2}},\\Phi_{\\frac{1}{2}},\\Phi_{\\frac{3}{2}},\\Phi_{\\frac{5}{2}}] = [5\\times 10^3,0,0,-5\\times 10^3]$，源 $[Q_0,Q_1,Q_2] = [0,0,0]$，$\\kappa_i = 0$（对所有 $i$），$\\Delta t = 1$，$c = 2.99792458\\times 10^8$。\n\n你的程序应产生单行输出，其中包含一个由方括号括起来的逗号分隔的残差列表（例如 $[r_A,r_B,r_C,r_D,r_E]$），其中每个 $r$ 是对应案例的绝对残差 $R$，格式为六位有效数字的科学记数法。所有残差都必须以 $\\mathrm{photons}$ 为单位报告。", "solution": "用户的要求是推导一个用于辐射转移的光子守恒有限体积更新法则，并将其应用于一系列测试用例，报告每个用例的全局守恒残差。\n\n该问题是有效的，因为它在科学上基于辐射转移的原理，数学上是适定的、客观的，并提供了一套完整且一致的数据和定义。该任务是守恒律数值方法的标准练习。我现在将进行推导和实现。\n\n**1. 有限体积更新法则的推导**\n\n基本原理是控制体积 $V_i$ 内的光子数守恒。$V_i$ 中光子数的时间变化率等于进入该体积的净光子率加上内部发射率，再减去内部吸收率。这由输运方程的积分形式表示：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} \\int_{V_i} n_{\\gamma}\\,\\mathrm{d}V = -\\oint_{\\partial V_i} \\boldsymbol{F}\\cdot\\mathrm{d}\\boldsymbol{A} + \\int_{V_i} S\\,\\mathrm{d}V - \\int_{V_i} c\\,\\kappa\\,n_{\\gamma}\\,\\mathrm{d}V\n$$\n在这里，$n_{\\gamma}$ 是光子数密度，$\\boldsymbol{F}$ 是光子数通量密度，$S$ 是源率密度，$c$ 是光速，$\\kappa$ 是吸收系数。\n\n我们将此转换为问题中的离散量：\n- 单元 $i$ 中的每单元光子数为 $N_i(t) = \\int_{V_i} n_{\\gamma}\\,\\mathrm{d}V$。\n- 单元积分源率为 $Q_i = \\int_{V_i} S\\,\\mathrm{d}V$。\n- 假设吸收系数 $\\kappa_i$ 在单元内是常数，则体积积分吸收率为 $\\int_{V_i} c\\,\\kappa\\,n_{\\gamma}\\,\\mathrm{d}V = c\\,\\kappa_i \\int_{V_i} n_{\\gamma}\\,\\mathrm{d}V = c\\,\\kappa_i N_i(t)$。\n- 在一维情况下，面积分 $\\oint_{\\partial V_i} \\boldsymbol{F}\\cdot\\mathrm{d}\\boldsymbol{A}$ 表示流出单元的净通量。问题定义了面光子率 $\\Phi_{i \\pm \\frac{1}{2}}$ 为在 $+\\hat{x}$ 方向上穿过面的光子率。流出单元 $i$ 的净通量是右侧面 ($i+\\frac{1}{2}$) 的流出率减去左侧面 ($i-\\frac{1}{2}$) 的流入率。这对应于 $\\Phi_{i+\\frac{1}{2}} - \\Phi_{i-\\frac{1}{2}}$。\n\n将这些离散量代入守恒定律，得到关于 $N_i$ 的半离散常微分方程：\n$$\n\\frac{\\mathrm{d}N_i}{\\mathrm{d}t} = -(\\Phi_{i+\\frac{1}{2}} - \\Phi_{i-\\frac{1}{2}}) + Q_i - c\\,\\kappa_i N_i\n$$\n为了在从 $t^n$ 到 $t^{n+1}$ 的一个时间步长 $\\Delta t$ 内进行时间离散，我们将导数近似为 $\\frac{N_i^{n+1} - N_i^n}{\\Delta t}$。问题要求吸收汇项被隐式处理，这意味着它在新时间层 $t^{n+1}$ 进行求值。源项和通量项在时间步长内被视为常数。这种混合显式-隐式（IMEX）格式写作：\n$$\n\\frac{N_i^{n+1} - N_i^n}{\\Delta t} = -(\\Phi_{i+\\frac{1}{2}} - \\Phi_{i-\\frac{1}{2}}) + Q_i - c\\,\\kappa_i N_i^{n+1}\n$$\n为了找到更新法则，我们求解 $N_i^{n+1}$。首先，乘以 $\\Delta t$：\n$$\nN_i^{n+1} - N_i^n = \\Delta t \\left[ -(\\Phi_{i+\\frac{1}{2}} - \\Phi_{i-\\frac{1}{2}}) + Q_i \\right] - \\Delta t\\,c\\,\\kappa_i N_i^{n+1}\n$$\n接下来，将所有包含 $N_i^{n+1}$ 的项移到左边：\n$$\nN_i^{n+1} + \\Delta t\\,c\\,\\kappa_i N_i^{n+1} = N_i^n - \\Delta t(\\Phi_{i+\\frac{1}{2}} - \\Phi_{i-\\frac{1}{2}}) + \\Delta t\\,Q_i\n$$\n提取公因子 $N_i^{n+1}$：\n$$\nN_i^{n+1}(1 + c\\,\\kappa_i\\,\\Delta t) = N_i^n + \\Delta t\\,Q_i - \\Delta t(\\Phi_{i+\\frac{1}{2}} - \\Phi_{i-\\frac{1}{2}})\n$$\n最后，除以括号中的项，得到 $N_i^{n+1}$ 的显式更新法则：\n$$\nN_i^{n+1} = \\frac{N_i^n + \\Delta t\\,Q_i - \\Delta t\\,(\\Phi_{i+\\frac{1}{2}} - \\Phi_{i-\\frac{1}{2}})}{1 + c\\,\\kappa_i\\,\\Delta t}\n$$\n对每个单元 $i=0, \\dots, N_x-1$ 实现这个方程，以计算时间 $t^{n+1}$ 的状态。这种对汇项的隐式处理保证了对于非负输入，$N_i^{n+1}$ 的正定性。\n\n**2. 全局守恒与残差 R**\n\n问题定义了绝对全局守恒残差 $R$ 来验证格式。通过对所有单元求和我们的更新法则，我们可以证明该格式在构造上是完全守恒的。在求解 $N_i^{n+1}$ 之前，重排我们的时间离散方程：\n$$\n(N_i^{n+1} - N_i^n) - \\left[ -\\Delta t(\\Phi_{i+\\frac{1}{2}} - \\Phi_{i-\\frac{1}{2}}) + \\Delta t\\,Q_i - \\Delta t\\,c\\,\\kappa_i N_i^{n+1} \\right] = 0\n$$\n对所有单元 $i=0, \\dots, N_x-1$ 求和：\n$$\n\\sum_{i=0}^{N_x-1}(N_i^{n+1} - N_i^n) - \\left[ -\\Delta t \\sum_{i=0}^{N_x-1}(\\Phi_{i+\\frac{1}{2}} - \\Phi_{i-\\frac{1}{2}}) + \\Delta t \\sum_{i=0}^{N_x-1} Q_i - \\Delta t \\sum_{i=0}^{N_x-1} c\\,\\kappa_i N_i^{n+1} \\right] = 0\n$$\n通量求和形成一个伸缩级数：\n$$\n\\sum_{i=0}^{N_x-1}(\\Phi_{i+\\frac{1}{2}} - \\Phi_{i-\\frac{1}{2}}) = (\\Phi_{\\frac{1}{2}} - \\Phi_{-\\frac{1}{2}}) + (\\Phi_{\\frac{3}{2}} - \\Phi_{\\frac{1}{2}}) + \\dots + (\\Phi_{N_x-\\frac{1}{2}} - \\Phi_{N_x-\\frac{3}{2}}) = \\Phi_{N_x-\\frac{1}{2}} - \\Phi_{-\\frac{1}{2}}\n$$\n将其代回，得到全局守恒方程：\n$$\n\\left(\\sum_{i=0}^{N_x-1}N_i^{n+1} - \\sum_{i=0}^{N_x-1}N_i^{n}\\right) - \\left[ -\\Delta t (\\Phi_{N_x-\\frac{1}{2}} - \\Phi_{-\\frac{1}{2}}) + \\Delta t \\sum_{i=0}^{N_x-1} Q_i - \\Delta t \\sum_{i=0}^{N_x-1} c\\,\\kappa_i N_i^{n+1} \\right] = 0\n$$\n残差 $R$ 的绝对值内的表达式正是这个方程。因此，如果更新法则被正确实现，$R$ 将在浮点舍入误差范围内为零。下面的实现根据推导出的公式计算所有单元的 $N_i^{n+1}$，然后计算 $R$ 以证实这一性质。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a photon-conserving finite-volume update rule for \n    radiative transfer, calculates the global conservation residual for a suite \n    of test cases, and prints the results in the specified format.\n    \"\"\"\n    \n    # Define the speed of light, c, in m/s\n    c = 2.99792458e8\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Happy path\n        {'Nx': 4, 'Nn': np.array([1e6, 2e6, 5e5, 1.5e6], dtype=np.float64),\n         'Phi': np.array([1e5, 5e4, -2e4, 0, -5e4], dtype=np.float64),\n         'Q': np.array([1e4, 0, 2e4, 0], dtype=np.float64),\n         'kappa': np.full(4, 1e-10, dtype=np.float64), 'dt': 1e-1},\n        \n        # Case B: Zero-flux boundaries, sources and absorption only\n        {'Nx': 3, 'Nn': np.array([0., 0., 0.], dtype=np.float64),\n         'Phi': np.array([0., 0., 0., 0.], dtype=np.float64),\n         'Q': np.array([1e5, 1e5, 1e5], dtype=np.float64),\n         'kappa': np.full(3, 1e-9, dtype=np.float64), 'dt': 1.0},\n        \n        # Case C: Vacuum, check strict conservation with sources and balanced boundary fluxes\n        {'Nx': 2, 'Nn': np.array([1e3, 2e3], dtype=np.float64),\n         'Phi': np.array([100., 100., 100.], dtype=np.float64),\n         'Q': np.array([0., 100.], dtype=np.float64),\n         'kappa': np.full(2, 0.0, dtype=np.float64), 'dt': 10.0},\n        \n        # Case D: Stiff absorption, positivity under implicit sink\n        {'Nx': 1, 'Nn': np.array([1e9], dtype=np.float64),\n         'Phi': np.array([0., 0.], dtype=np.float64),\n         'Q': np.array([1e8], dtype=np.float64),\n         'kappa': np.array([1.0], dtype=np.float64), 'dt': 1e-9},\n        \n        # Case E: Net inflow from boundaries, no sources, no absorption\n        {'Nx': 3, 'Nn': np.array([1e4, 2e4, 3e4], dtype=np.float64),\n         'Phi': np.array([5e3, 0., 0., -5e3], dtype=np.float64),\n         'Q': np.array([0., 0., 0.], dtype=np.float64),\n         'kappa': np.full(3, 0.0, dtype=np.float64), 'dt': 1.0}\n    ]\n\n    residuals = []\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        Nx = case['Nx']\n        Nn = case['Nn']\n        Phi = case['Phi']\n        Q = case['Q']\n        kappa = case['kappa']\n        dt = case['dt']\n\n        # Array to store the new photon counts\n        Nn_plus_1 = np.zeros(Nx, dtype=np.float64)\n\n        # Apply the update rule for each cell\n        for i in range(Nx):\n            # Flux divergence for cell i\n            flux_diff = Phi[i+1] - Phi[i]\n            \n            # Numerator of the update rule\n            numerator = Nn[i] + dt * Q[i] - dt * flux_diff\n            \n            # Denominator of the update rule (implicit sink term)\n            denominator = 1.0 + c * kappa[i] * dt\n            \n            Nn_plus_1[i] = numerator / denominator\n\n        # Calculate the absolute global conservation residual R\n        \n        # Total change in photon number in the domain\n        total_change_N = np.sum(Nn_plus_1) - np.sum(Nn)\n        \n        # Total contribution from boundary fluxes\n        # The term phi_Nx-1/2 corresponds to Phi[Nx] and phi_-1/2 to Phi[0]\n        boundary_flux_term = -dt * (Phi[Nx] - Phi[0])\n        \n        # Total contribution from internal sources\n        source_term = dt * np.sum(Q)\n        \n        # Total contribution from absorption sinks (using new state Nn+1)\n        sink_term = -dt * c * np.sum(kappa * Nn_plus_1)\n        \n        # Sum of all photon changes due to fluxes, sources, and sinks\n        total_contributions = boundary_flux_term + source_term + sink_term\n        \n        # The residual is the absolute difference, which should be near zero\n        residual = abs(total_change_N - total_contributions)\n        residuals.append(residual)\n\n    # Format the final results as specified: scientific notation with six significant figures\n    # The format specifier '.5e' gives one digit before the decimal and five after.\n    formatted_results = [f\"{r:.5e}\" for r in residuals]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3488852"}, {"introduction": "尽管完整的辐射转移计算很精确，但其巨大的计算成本常常促使研究人员使用更快的“半数值”方法。本练习 ([@problem_id:3488937]) 旨在解决半数值模型中的一个关键问题：当重叠的电离气泡被绘制到网格上时，对光子守恒的违背。你将首先量化这个误差，然后设计一个确定性的修正方案来强制执行全局光子数核算，从而突显在模拟中精确性与速度之间的权衡，并学习一种提高近似模型物理保真度的实用技术。", "problem": "给定一个简化的自洽数值实验，用于诊断和校正在宇宙再电离时期（Epoch of Reionization）中，朴素的电离泡描绘（ionization bubble painting）方法所导致的光子数不守恒问题。实验在一个边长为 $L_{\\mathrm{box}}$（单位为共动百万秒差距，cMpc）的立方共动域中进行，该区域被离散化为一个包含 $N^3$个体素（voxel）的均匀笛卡尔网格，每个体素的边长为 $\\Delta x = L_{\\mathrm{box}}/N$（单位为 cMpc），单元共动体积为 $V_{\\mathrm{cell}} = \\Delta x^3$（单位为 $\\mathrm{cMpc}^3$）。假设重子密度均匀，忽略复合（recombination）和氦，并设氢质量分数为 $X_{\\mathrm{p}}$。现今的临界密度为 $\\rho_{\\mathrm{crit},0} = 3 H_0^2/(8\\pi G)$，因此现今的共动氢数密度（单位为 $\\mathrm{cMpc}^{-3}$）为 $n_{\\mathrm{H},0} = X_{\\mathrm{p}} \\, \\Omega_{\\mathrm{b}} \\, \\rho_{\\mathrm{crit},0} / m_{\\mathrm{p}}$，此值是通过精确的度量单位转换从 $\\mathrm{m}^{-3}$ 转换到 $\\mathrm{cMpc}^{-3}$ 的，其中 $H_0$ 是今天的哈勃常数， $G$ 是 Newton 引力常数， $\\Omega_{\\mathrm{b}}$ 是现今的重子密度参数， $m_{\\mathrm{p}}$ 是质子质量。给定一组离散的电离源，其位置为 $\\{\\mathbf{x}_i\\}$（单位为 cMpc），有效坍缩分数为 $\\{f_{{\\mathrm{coll}},i}\\}$，以及一个全局电离效率 $\\zeta$。在所采纳的简化条件下，源 $i$ 产生的总电离光子数为\n$$\nN_{\\gamma,i} = \\zeta \\, f_{{\\mathrm{coll}},i} \\, n_{\\mathrm{H},0} \\, V_{\\mathrm{cell}},\n$$\n总光子数为 $N_{\\gamma,\\mathrm{tot}}=\\sum_i N_{\\gamma,i}$。盒子中的总氢原子数为 $N_{\\mathrm{H,tot}}=n_{\\mathrm{H},0} \\, L_{\\mathrm{box}}^3$。在整个过程中，将所有数量计数视为共动的无量纲统计量；如果某个量需要单位，在计算 $n_{\\mathrm{H},0}$ 时，请酌情使用指定的 cgs 或 SI 单位，但所有最终的光子和原子统计量及误差都是无量纲的。\n\n通过在每个源的中心描绘非重叠的球形泡来定义一个朴素的、不守恒的电离图，球形泡的半径 $R_i$ 的选择使得每个孤立泡中的原子数等于该源的光子数：\n$$\nN_{\\gamma,i} = n_{\\mathrm{H},0} \\, \\frac{4\\pi}{3} R_i^3 \\quad \\Rightarrow \\quad R_i = \\left(\\frac{3 \\, N_{\\gamma,i}}{4\\pi \\, n_{\\mathrm{H},0}}\\right)^{1/3} = \\left(\\frac{3 \\, \\zeta \\, f_{{\\mathrm{coll}},i} \\, V_{\\mathrm{cell}}}{4\\pi}\\right)^{1/3}.\n$$\n在离散网格上，通过标记那些中心位于至少一个泡内的体素为电离状态，其余为中性状态，来近似朴素的电离场。这种“球体并集”离散化方法产生的总电离原子数为 $N_{\\mathrm{ion,naive}} = n_{\\mathrm{H},0} \\, V_{\\mathrm{cell}} \\, N_{\\mathrm{vox,ion}}$，其中 $N_{\\mathrm{vox,ion}}$ 是电离体素的数量。通常，重叠和离散化会导致光子核算出现不匹配。将全局光子核算目标定义为\n$$\nN_{\\mathrm{use}} = \\min\\!\\left(N_{\\gamma,\\mathrm{tot}}, N_{\\mathrm{H,tot}}\\right),\n$$\n并将朴素的光子数不守恒误差量化为无量纲的分数偏差\n$$\n\\varepsilon_{\\mathrm{naive}} = \\frac{N_{\\mathrm{ion,naive}} - N_{\\mathrm{use}}}{N_{\\mathrm{use}}}.\n$$\n设计并实现一种确定性的全局光子核算校正方法，该方法通过构建一个排序的“光子沉积”场 $D(\\mathbf{x})$ 来强制守恒，然后按 $D(\\mathbf{x})$ 的降序选择体素，直到累积的原子数等于 $N_{\\mathrm{use}}$（误差在一个体素以内），并允许最后一个体素被部分电离以精确匹配 $N_{\\mathrm{use}}$。具体来说，为每个源定义一个基于距离的权重\n$$\nw_i(\\mathbf{x}) = \\frac{1}{\\left(\\lVert \\mathbf{x}-\\mathbf{x}_i \\rVert + \\epsilon\\right)^p},\n$$\n其中 $\\epsilon0$ 是一个以 cMpc 为单位的小软化参数， $p0$ 是一个固定指数。对每个源进行归一化，使得在所有体素上 $\\sum_{\\mathbf{x}} \\tilde{w}_i(\\mathbf{x}) = 1$，其中 $\\tilde{w}_i(\\mathbf{x}) = w_i(\\mathbf{x})/\\sum_{\\mathbf{x}} w_i(\\mathbf{x})$，并定义\n$$\nD(\\mathbf{x}) = \\sum_i N_{\\gamma,i} \\, \\tilde{w}_i(\\mathbf{x}).\n$$\n按 $D(\\mathbf{x})$ 的降序对体素进行排序，并将它们标记为电离，直到累积分配的原子数等于 $N_{\\mathrm{use}}$。通过这种构造，可以得到一个校正后的全局统计量 $N_{\\mathrm{ion,corr}} = N_{\\mathrm{use}}$ 和一个校正后的分数误差\n$$\n\\varepsilon_{\\mathrm{corr}} = \\frac{N_{\\mathrm{ion,corr}} - N_{\\mathrm{use}}}{N_{\\mathrm{use}}}.\n$$\n同时报告校正后的全局电离分数\n$$\n\\bar{x}_{\\mathrm{HII,corr}} = \\frac{N_{\\mathrm{ion,corr}}}{N_{\\mathrm{H,tot}}} = \\frac{N_{\\mathrm{use}}}{N_{\\mathrm{H,tot}}}.\n$$\n\n将上述过程实现在一个程序中。在计算密度时使用以下 SI 单位的宇宙学常数：$G = 6.67430\\times 10^{-11}\\,\\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$，$m_{\\mathrm{p}} = 1.67262192369\\times 10^{-27}\\,\\mathrm{kg}$，$H_0 = 100\\,h\\,\\mathrm{km}\\,\\mathrm{s}^{-1}\\,\\mathrm{Mpc}^{-1}$，其中 $h=0.68$，$\\Omega_{\\mathrm{b}}=0.0486$，$X_{\\mathrm{p}}=0.76$，以及 $1\\,\\mathrm{Mpc} = 3.085677581\\times 10^{22}\\,\\mathrm{m}$。使用这些常数将 $n_{\\mathrm{H},0}$ 精确转换为 $\\mathrm{cMpc}^{-3}$。假设不使用角度；距离单位为 cMpc；光子和原子计数是无量纲的统计量。取沉积参数固定为 $p=2$ 和 $\\epsilon=\\Delta x/2$。\n\n您的任务是编写一个程序，为每个测试用例计算 $\\varepsilon_{\\mathrm{naive}}$、$\\varepsilon_{\\mathrm{corr}}$ 和 $\\bar{x}_{\\mathrm{HII,corr}}$，结果为浮点数。\n\n测试套件（单位如指定；所有位置单位为 cMpc，所有距离使用 cMpc，所有结果均为无量纲）：\n\n- 情况1（泡间距较远，重叠最小）：\n  - $N=32$，$L_{\\mathrm{box}}=32$，$\\zeta=30$，\n  - 源： $\\big([\\;8,16,16\\;],\\, f_{{\\mathrm{coll}},1}=0.4\\big)$ 和 $\\big([\\;24,16,16\\;],\\, f_{{\\mathrm{coll}},2}=0.4\\big)$。\n\n- 情况2（显著重叠）：\n  - $N=32$，$L_{\\mathrm{box}}=32$，$\\zeta=40$，\n  - 源： $\\big([\\;14,16,16\\;],\\, f_{{\\mathrm{coll}},1}=0.5\\big)$，$\\big([\\;18,16,16\\;],\\, f_{{\\mathrm{coll}},2}=0.5\\big)$，$\\big([\\;16,18,16\\;],\\, f_{{\\mathrm{coll}},3}=0.3\\big)$。\n\n- 情况3（光子饱和盒子）：\n  - $N=24$，$L_{\\mathrm{box}}=24$，$\\zeta=3000$，\n  - 源位于八个子盒子的中心：\n    - $\\big([\\;6,6,6\\;],\\, 0.6\\big)$, $\\big([\\;6,6,18\\;],\\, 0.6\\big)$, $\\big([\\;6,18,6\\;],\\, 0.6\\big)$, $\\big([\\;6,18,18\\;],\\, 0.6\\big)$,\n    - $\\big([\\;18,6,6\\;],\\, 0.6\\big)$, $\\big([\\;18,6,18\\;],\\, 0.6\\big)$, $\\big([\\;18,18,6\\;],\\, 0.6\\big)$, $\\big([\\;18,18,18\\;],\\, 0.6\\big)$。\n\n您的程序应生成单行输出，包含一个以逗号分隔的 Python 风格列表的列表，不含空格。每个内部列表按顺序包含对应测试用例的三个浮点数 $[\\varepsilon_{\\mathrm{naive}}, \\varepsilon_{\\mathrm{corr}}, \\bar{x}_{\\mathrm{HII,corr}}]$。例如，精确打印形如 “[[a1,b1,c1],[a2,b2,c2],[a3,b3,c3]]” 的字符串，其中每个 $a_i$、$b_i$、$c_i$ 都打印为十进制浮点数。所有报告的量都是无量纲的；不要在打印输出中包含任何单位。", "solution": "我们从电离光子的守恒开始：在再电离时期，忽略复合和氦，每个电离光子最终电离一个氢原子。由离散源产生的全局光子总数必须等于域中电离氢原子的总数，但朴素的电离泡描绘或受逾渗集（excursion-set）启发的算法在平滑时可能会重复计数，或由于离散化和重叠而导致电离不足或过度电离。\n\n设 $N_{\\mathrm{H,tot}} = n_{\\mathrm{H},0} \\, L_{\\mathrm{box}}^3$ 为域中的总氢原子数。我们从现今的重子密度计算 $n_{\\mathrm{H},0}$：\n$$\n\\rho_{\\mathrm{crit},0} = \\frac{3 H_0^2}{8\\pi G}, \\quad \\rho_{\\mathrm{b},0} = \\Omega_{\\mathrm{b}} \\rho_{\\mathrm{crit},0}, \\quad n_{\\mathrm{H},0}^{\\mathrm{(SI)}} = \\frac{X_{\\mathrm{p}} \\rho_{\\mathrm{b},0}}{m_{\\mathrm{p}}} \\; \\; [\\mathrm{m}^{-3}],\n$$\n并使用 $1\\,\\mathrm{Mpc} = 3.085677581\\times 10^{22}\\,\\mathrm{m}$ 转换为每 $\\mathrm{cMpc}^{-3}$：\n$$\nn_{\\mathrm{H},0} = n_{\\mathrm{H},0}^{\\mathrm{(SI)}} \\times (1\\,\\mathrm{Mpc})^3.\n$$\n由于我们在共动坐标系下工作，在我们的玩具模型中，这个数密度在空间上是均匀的，且与红移无关。\n\n每个源 $i$ 都有一个坍缩分数 $f_{{\\mathrm{coll}},i}$ 和一个电离效率 $\\zeta$。在密度均匀且忽略离散源之外的 $f_{\\mathrm{coll}}$ 空间调制的假设下，我们将每个源的光子产额定义为\n$$\nN_{\\gamma,i} = \\zeta \\, f_{{\\mathrm{coll}},i} \\, n_{\\mathrm{H},0} \\, V_{\\mathrm{cell}},\n$$\n因此总光子数为 $N_{\\gamma,\\mathrm{tot}} = \\sum_i N_{\\gamma,i}$。朴素的电离泡描绘半径将源 $i$ 的光子数与平均密度下半径为 $R_i$ 的球体内的原子数等同起来：\n$$\nN_{\\gamma,i} = n_{\\mathrm{H},0}\\,\\frac{4\\pi}{3} R_i^3 \\;\\Rightarrow\\; R_i = \\left(\\frac{3 N_{\\gamma,i}}{4\\pi n_{\\mathrm{H},0}}\\right)^{1/3} = \\left(\\frac{3 \\zeta f_{{\\mathrm{coll}},i} V_{\\mathrm{cell}}}{4\\pi}\\right)^{1/3}.\n$$\n值得注意的是，$R_i$ 与 $n_{\\mathrm{H},0}$ 无关，因为 $N_{\\gamma,i}\\propto n_{\\mathrm{H},0}$；因此，在连续谱下，根据构造，以 cMpc$^3$ 为单位的泡体积等于 $N_{\\gamma,i}/n_{\\mathrm{H},0}$。\n\n在离散化网格上，我们通过标记中心位于以 $\\mathbf{x}_i$ 为心、半径为 $R_i$ 的任意一个球体内的每个体素来定义朴素的电离图。这产生了一个球体并集体素集，其数量为 $N_{\\mathrm{vox,ion}}$，对应于朴素的电离原子数\n$$\nN_{\\mathrm{ion,naive}} = n_{\\mathrm{H},0} \\, V_{\\mathrm{cell}} \\, N_{\\mathrm{vox,ion}}.\n$$\n由于球体之间的重叠和离散的体素化，$N_{\\mathrm{ion,naive}}$ 可能小于 $N_{\\gamma,\\mathrm{tot}}$（未分配的光子），或者在某些逾渗集算法中可能更大（重复计数）；在我们的球体并集构造中，重叠通常导致 $N_{\\mathrm{ion,naive}} \\le \\sum_i n_{\\mathrm{H},0}\\,\\frac{4\\pi}{3} R_i^3 = N_{\\gamma,\\mathrm{tot}}$，因此不匹配通常是负值。物理限制要求最大使用的光子数不能超过 $N_{\\mathrm{H,tot}}$，因此我们定义全局目标为\n$$\nN_{\\mathrm{use}} = \\min\\!\\left(N_{\\gamma,\\mathrm{tot}},\\, N_{\\mathrm{H,tot}}\\right).\n$$\n那么，朴素光子数不守恒的分数误差为\n$$\n\\varepsilon_{\\mathrm{naive}} = \\frac{N_{\\mathrm{ion,naive}} - N_{\\mathrm{use}}}{N_{\\mathrm{use}}},\n$$\n此值为无量纲，如果朴素方法未充分使用光子，则可以取负值。\n\n为了强制执行全局光子核算，我们设计了一种确定性分配方案，通过根据光子沉积场 $D(\\mathbf{x})$ 对体素进行排序，精确地分配 $N_{\\mathrm{use}}$ 个原子进行电离。我们选择一个具有物理动机的核函数，该核函数随与每个源的距离而衰减，模拟了光子从朴素泡边界向外、与源的邻近度成比例的重新分布。对于源 $i$，定义\n$$\nw_i(\\mathbf{x}) = \\frac{1}{\\left(\\lVert \\mathbf{x}-\\mathbf{x}_i \\rVert + \\epsilon\\right)^p}, \\quad \\epsilon = \\frac{\\Delta x}{2}, \\quad p=2,\n$$\n并对每个源进行归一化：\n$$\n\\tilde{w}_i(\\mathbf{x}) = \\frac{w_i(\\mathbf{x})}{\\sum_{\\mathbf{y}} w_i(\\mathbf{y})}.\n$$\n然后，光子沉积场为\n$$\nD(\\mathbf{x}) = \\sum_i N_{\\gamma,i} \\, \\tilde{w}_i(\\mathbf{x}),\n$$\n根据构造，该场满足 $\\sum_{\\mathbf{x}} D(\\mathbf{x}) = \\sum_i N_{\\gamma,i} = N_{\\gamma,\\mathrm{tot}}$。按 $D(\\mathbf{x})$ 降序对所有体素 $\\mathbf{x}$ 进行排序，得到一个优先考虑与源耦合最强的单元的顺序。然后我们按该顺序电离体素，直到累积的电离原子数达到 $N_{\\mathrm{use}}$。因为 $N_{\\mathrm{use}}$ 可能不是每个单元原子数 $n_{\\mathrm{H},0}V_{\\mathrm{cell}}$ 的整数倍，我们允许最后一个选定的单元以分数占据率被部分电离，从而使分配的电离原子数恰好为 $N_{\\mathrm{ion,corr}} = N_{\\mathrm{use}}$。这保证了校正后的分数误差为\n$$\n\\varepsilon_{\\mathrm{corr}} = \\frac{N_{\\mathrm{ion,corr}} - N_{\\mathrm{use}}}{N_{\\mathrm{use}}} = 0,\n$$\n在浮点舍入误差范围内。校正后的平均电离分数为\n$$\n\\bar{x}_{\\mathrm{HII,corr}} = \\frac{N_{\\mathrm{ion,corr}}}{N_{\\mathrm{H,tot}}} = \\frac{N_{\\mathrm{use}}}{N_{\\mathrm{H,tot}}}.\n$$\n\n每个测试用例的算法步骤：\n- 计算 $\\Delta x = L_{\\mathrm{box}}/N$ 和 $V_{\\mathrm{cell}}=\\Delta x^3$。\n- 根据给定的常数计算 $n_{\\mathrm{H},0}$（单位为 $\\mathrm{cMpc}^{-3}$）。\n- 构建体素中心网格 $\\{\\mathbf{x}\\}$（单位为 cMpc），每个轴的坐标为 $(j+1/2)\\Delta x$，其中 $j\\in\\{0,\\dots,N-1\\}$。\n- 对于每个源 $i$，计算 $N_{\\gamma,i} = \\zeta f_{{\\mathrm{coll}},i} n_{\\mathrm{H},0} V_{\\mathrm{cell}}$ 和 $R_i = \\left(3\\zeta f_{{\\mathrm{coll}},i}V_{\\mathrm{cell}}/(4\\pi)\\right)^{1/3}$。\n- 朴素图：构建一个布尔掩码，如果一个体素的中心位于任何源中心的 $R_i$ 范围内，则将其标记为电离。计算 $N_{\\mathrm{ion,naive}} = n_{\\mathrm{H},0}V_{\\mathrm{cell}} N_{\\mathrm{vox,ion}}$ 和 $N_{\\mathrm{use}}=\\min(N_{\\gamma,\\mathrm{tot}}, n_{\\mathrm{H},0}L_{\\mathrm{box}}^3)$，然后计算 $\\varepsilon_{\\mathrm{naive}}$。\n- 校正：为所有源和体素计算 $w_i(\\mathbf{x})$，归一化为 $\\tilde{w}_i(\\mathbf{x})$，计算 $D(\\mathbf{x})$，降序排序，并选择最小的前缀和一个最终的分数体素，使得分配的原子数等于 $N_{\\mathrm{use}}$。报告 $\\varepsilon_{\\mathrm{corr}}$ 和 $\\bar{x}_{\\mathrm{HII,corr}}$。\n\n数值考虑：\n- 所有距离以 cMpc 为单位，所有体积以 $\\mathrm{cMpc}^3$ 为单位。\n- 软化参数 $\\epsilon=\\Delta x/2$ 避免了包含源的体素处的发散。\n- 排序产生确定性的选择，这是因为排序实现中存在固定的平局决胜顺序；我们不使用随机性。\n\n测试套件涵盖的边缘情况：\n- 情况1的泡间距较远，因此 $\\varepsilon_{\\mathrm{naive}}$ 的绝对值应接近于零，带有残余的离散化误差。\n- 情况2有显著重叠，导致更负的 $\\varepsilon_{\\mathrm{naive}}$，因为并集泡的体积小于单个球体体积之和。\n- 情况3是光子饱和的，即 $N_{\\gamma,\\mathrm{tot}} \\gtrsim N_{\\mathrm{H,tot}}$，因此 $N_{\\mathrm{use}} = N_{\\mathrm{H,tot}}$，校正饱和于完全电离，$\\bar{x}_{\\mathrm{HII,corr}} \\approx 1$；由于边界裁剪和重叠，朴素图未能充分利用光子。\n\n输出规范：\n- 对于每种情况，输出三元组 $[\\varepsilon_{\\mathrm{naive}}, \\varepsilon_{\\mathrm{corr}}, \\bar{x}_{\\mathrm{HII,corr}}]$ 作为十进制浮点数。\n- 将三个三元组聚合成一个单一列表，不含空格，作为 Python 风格的列表的列表打印在单行上： “[[a1,b1,c1],[a2,b2,c2],[a3,b3,c3]]”。\n- 所有三个报告的量都是无量纲的；不打印任何单位。", "answer": "```python\nimport numpy as np\n\n# Numerical cosmology constants and conversions\nG = 6.67430e-11  # m^3 kg^-1 s^-2\nm_p = 1.67262192369e-27  # kg\nh = 0.68\nH0 = 100.0 * h * 1000.0 / 3.085677581e22  # s^-1 (100 h km/s/Mpc converted)\nOmega_b = 0.0486\nX_p = 0.76\nMPC_IN_M = 3.085677581e22  # m\n\ndef hydrogen_number_density_cMpc3():\n    \"\"\"Compute present-day comoving hydrogen number density n_H0 in 1/cMpc^3.\"\"\"\n    rho_crit0 = 3.0 * H0**2 / (8.0 * np.pi * G)  # kg/m^3\n    rho_b0 = Omega_b * rho_crit0  # kg/m^3\n    n_H_SI = X_p * rho_b0 / m_p  # 1/m^3\n    n_H_cMpc3 = n_H_SI * (MPC_IN_M**3)  # convert to 1/Mpc^3 (cMpc^3)\n    return n_H_cMpc3\n\ndef grid_voxel_centers(N, Lbox):\n    \"\"\"Return (N^3, 3) array of voxel center coordinates in cMpc.\"\"\"\n    dx = Lbox / N\n    coords_1d = (np.arange(N, dtype=np.float64) + 0.5) * dx\n    X, Y, Z = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n    positions = np.stack([X.ravel(), Y.ravel(), Z.ravel()], axis=1)\n    return positions, dx\n\ndef naive_union_spheres_mask(positions, sources_pos, radii):\n    \"\"\"Compute union-of-spheres mask (boolean array of length Nvox).\"\"\"\n    Nvox = positions.shape[0]\n    mask = np.zeros(Nvox, dtype=bool)\n    for pos, R in zip(sources_pos, radii):\n        diff = positions - pos  # (Nvox, 3)\n        r2 = np.sum(diff * diff, axis=1)\n        mask |= (r2 = R * R)\n    return mask\n\ndef photon_deposition_field(positions, sources_pos, N_gamma_list, dx, p=2.0):\n    \"\"\"Compute global photon deposition field D(x) normalized to sum to sum(N_gamma).\"\"\"\n    Nvox = positions.shape[0]\n    D = np.zeros(Nvox, dtype=np.float64)\n    # Softening to avoid singularity at r=0\n    eps = dx * 0.5\n    for pos, Ng in zip(sources_pos, N_gamma_list):\n        diff = positions - pos\n        r = np.linalg.norm(diff, axis=1)\n        w = 1.0 / np.power(r + eps, p)\n        w_sum = w.sum()\n        if w_sum == 0.0:\n            continue\n        D += Ng * (w / w_sum)\n    return D\n\ndef enforce_global_photon_accounting(D, nH, Vcell, N_use):\n    \"\"\"Greedy selection by descending D to match N_use atoms. Allows fractional final voxel.\"\"\"\n    atoms_per_cell = nH * Vcell\n    if N_use == 0.0 or atoms_per_cell == 0.0:\n        return 0.0, 0, 0.0  # assigned atoms, number of full cells, fraction in last\n    idx = np.argsort(-D)  # descending\n    # Number of full cells we can take\n    K_full = int(np.floor(N_use / atoms_per_cell))\n    assigned_atoms = atoms_per_cell * K_full\n    frac_last = 0.0\n    last_index = None\n    if assigned_atoms  N_use and K_full  len(idx):\n        # Take one more voxel fractionally\n        last_index = idx[K_full]\n        remaining = N_use - assigned_atoms\n        frac_last = min(1.0, remaining / atoms_per_cell)\n        assigned_atoms += frac_last * atoms_per_cell\n    # If assigned_atoms still less due to reaching end, that's fine; but in practice won't happen.\n    return assigned_atoms, K_full, frac_last\n\ndef run_case(N, Lbox, zeta, sources):\n    \"\"\"\n    sources: list of tuples ([x,y,z], f_coll)\n    Returns epsilon_naive, epsilon_corr, xHII_corr\n    \"\"\"\n    # Grid and constants\n    positions, dx = grid_voxel_centers(N, Lbox)\n    Vcell = dx**3\n    nH = hydrogen_number_density_cMpc3()\n    NH_tot = nH * (Lbox**3)\n\n    # Source photons and bubble radii\n    src_pos = []\n    fcolls = []\n    for (pos, fcoll) in sources:\n        src_pos.append(np.array(pos, dtype=np.float64))\n        fcolls.append(float(fcoll))\n    src_pos = np.array(src_pos, dtype=np.float64)\n    fcolls = np.array(fcolls, dtype=np.float64)\n\n    N_gamma_list = zeta * fcolls * nH * Vcell  # photons per source (dimensionless tally)\n    N_gamma_tot = float(np.sum(N_gamma_list))\n    N_use = min(N_gamma_tot, NH_tot)\n\n    # Radii independent of nH\n    radii = np.power((3.0 * zeta * fcolls * Vcell) / (4.0 * np.pi), 1.0 / 3.0)\n\n    # Naive union-of-spheres mask\n    mask = naive_union_spheres_mask(positions, src_pos, radii)\n    N_vox_ion = int(np.count_nonzero(mask))\n    N_ion_naive = nH * Vcell * N_vox_ion\n    # Fractional error\n    # Guard against division by zero: in our test suite N_use > 0\n    eps_naive = (N_ion_naive - N_use) / N_use if N_use > 0 else 0.0\n\n    # Photon-conserving correction\n    D = photon_deposition_field(positions, src_pos, N_gamma_list, dx, p=2.0)\n    assigned_atoms, _, _ = enforce_global_photon_accounting(D, nH, Vcell, N_use)\n    eps_corr = (assigned_atoms - N_use) / N_use if N_use > 0 else 0.0\n    xHII_corr = assigned_atoms / NH_tot if NH_tot > 0 else 0.0\n\n    return float(eps_naive), float(eps_corr), float(xHII_corr)\n\ndef format_results(results):\n    # Format as [[a,b,c],[...],...] with fixed decimal formatting and no spaces\n    def fmt(x):\n        # Use a reasonable precision; ensure deterministic output\n        return f\"{x:.6f}\"\n    inner = []\n    for triple in results:\n        a, b, c = triple\n        inner.append(f\"[{fmt(a)},{fmt(b)},{fmt(c)}]\")\n    return \"[\" + \",\".join(inner) + \"]\"\n\ndef solve():\n    # Define test cases as specified\n    test_cases = [\n        # Case 1\n        {\n            \"N\": 32,\n            \"Lbox\": 32.0,\n            \"zeta\": 30.0,\n            \"sources\": [\n                ([8.0, 16.0, 16.0], 0.4),\n                ([24.0, 16.0, 16.0], 0.4),\n            ],\n        },\n        # Case 2\n        {\n            \"N\": 32,\n            \"Lbox\": 32.0,\n            \"zeta\": 40.0,\n            \"sources\": [\n                ([14.0, 16.0, 16.0], 0.5),\n                ([18.0, 16.0, 16.0], 0.5),\n                ([16.0, 18.0, 16.0], 0.3),\n            ],\n        },\n        # Case 3\n        {\n            \"N\": 24,\n            \"Lbox\": 24.0,\n            \"zeta\": 3000.0,\n            \"sources\": [\n                ([6.0, 6.0, 6.0], 0.6),\n                ([6.0, 6.0, 18.0], 0.6),\n                ([6.0, 18.0, 6.0], 0.6),\n                ([6.0, 18.0, 18.0], 0.6),\n                ([18.0, 6.0, 6.0], 0.6),\n                ([18.0, 6.0, 18.0], 0.6),\n                ([18.0, 18.0, 6.0], 0.6),\n                ([18.0, 18.0, 18.0], 0.6),\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        eps_naive, eps_corr, xHII_corr = run_case(case[\"N\"], case[\"Lbox\"], case[\"zeta\"], case[\"sources\"])\n        results.append([eps_naive, eps_corr, xHII_corr])\n\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3488937"}, {"introduction": "一旦我们知道了中性和电离气体的分布，我们就可以预测来自这个时代的主要可观测信号：21cm信号。本练习 ([@problem_id:3488955]) 旨在探索星系际介质的微观物理与21cm功率谱之间的联系。你将研究碰撞耦合和莱曼-$\\alpha$耦合如何决定氢自旋温度 ($T_S$)，并因此决定21cm信号是相对于CMB表现为吸收还是发射，从而获得将宇宙气体的物理状态转化为可观测量量的动手经验。", "problem": "要求您设计并实现一个最小化的、自洽的数值实验，以评估再电离时期三维21厘米亮温度功率谱对不同自旋温度耦合方案的敏感性。该研究仅限于一个科学上合理、能够分离出自旋温度耦合效应且明确可测试的玩具模型。\n\n基本原理和定义：\n- 21厘米微分亮温度的模型为 $T_{\\mathrm{b}}(\\mathbf{x}) \\approx 27\\,\\mathrm{mK}\\,x_{\\mathrm{HI}}(\\mathbf{x})\\left[1+\\delta(\\mathbf{x})\\right]\\left(1 - \\frac{T_{\\gamma}}{T_{\\mathrm{S}}(\\mathbf{x})}\\right)\\sqrt{\\frac{1+z}{10}}$，其中 $x_{\\mathrm{HI}}(\\mathbf{x})$ 是中性氢分数，$\\delta(\\mathbf{x})$ 是物质过密度，$T_{\\gamma}$ 是宇宙微波背景（CMB）温度，$T_{\\mathrm{S}}(\\mathbf{x})$ 是自旋温度，$z$ 是红移。\n- 自旋温度耦合由 Wouthuysen-Field 关系给出，$T_{\\mathrm{S}}^{-1} = \\dfrac{T_{\\gamma}^{-1} + x_{c}\\,T_{\\mathrm{K}}^{-1} + x_{\\alpha}\\,T_{\\alpha}^{-1}}{1 + x_{c} + x_{\\alpha}}$，其中 $x_{c}$ 是碰撞耦合系数，$x_{\\alpha}$ 是莱曼-$\\alpha$（Ly$\\alpha$）耦合系数，$T_{\\mathrm{K}}$ 是气体的动理学温度，$T_{\\alpha}$ 是 Ly$\\alpha$ 色温。假设 $T_{\\alpha} = T_{\\mathrm{K}}$。\n- 亮温度涨落的三维功率谱 $P_{21}(k)$ 根据离散周期性盒子中使用的快速傅里叶变换（FFT）的傅里叶变换约定来定义，并通过将 $\\left|\\tilde{\\Delta}_{21}(\\mathbf{k})\\right|^{2}$ 分箱到球形 $k$-壳层中并除以盒子体积来操作性地估计，其中 $\\Delta_{21}(\\mathbf{x}) \\equiv T_{\\mathrm{b}}(\\mathbf{x}) - \\langle T_{\\mathrm{b}}\\rangle$。\n\n物理和数值设置：\n- 区域：一个共动边长为 $L = 200\\,\\mathrm{Mpc}\\,h^{-1}$ 的周期性立方体，每个维度上均匀离散化为 $N = 32$ 个单元。\n- 红移：$z = 10$，因此 $T_{\\gamma} = 2.725\\,(1+z)\\,\\mathrm{K}$。\n- 中性分数：选择一个空间均匀的值 $x_{\\mathrm{HI}}(\\mathbf{x}) = 1$，以分离自旋温度效应。\n- 动理学温度：选择一个空间均匀的值 $T_{\\mathrm{K}} = 5\\,\\mathrm{K}$ 并设置 $T_{\\alpha} = T_{\\mathrm{K}}$。\n- 当耦合“开启”时，耦合系数为：$x_{c,\\mathrm{on}} = 0.1$ 和 $x_{\\alpha,\\mathrm{on}} = 2.0$。当耦合“关闭”时，将其设置为零。\n- 过密度场：通过以下方式构建一个统计均匀且各向同性的高斯随机过密度场 $\\delta(\\mathbf{x})$：\n  1. 在实空间中的网格上采样一个零均值、单位方差的高斯白噪声场。\n  2. 变换到傅里叶空间，并应用球对称传递函数 $T(k) = \\left(\\dfrac{k}{k_{0}}\\right)^{n/2}\\exp\\left[-\\dfrac{1}{2}\\left(\\dfrac{k}{k_{c}}\\right)^{2}\\right]$ 来塑造该场，其中 $n = -2.5$，$k_{0} = 0.1\\,h\\,\\mathrm{Mpc}^{-1}$，$k_{c} = 0.8\\,h\\,\\mathrm{Mpc}^{-1}$，并将零模设置为零。然后逆变换回实空间，并减去任何残余均值以确保 $\\langle \\delta\\rangle = 0$。\n\n目标量：\n- 对于每种自旋温度耦合方案，通过以下方式计算分箱的 $P_{21}(k)$：\n  1. 使用上述公式，并代入 $x_{\\mathrm{HI}}=1$ 和所选的 $T_{\\mathrm{S}}$ 方案，以毫开尔文（milliKelvin）为单位构建 $T_{\\mathrm{b}}(\\mathbf{x})$。\n  2. 减去空间均值以获得 $\\Delta_{21}(\\mathbf{x})$。\n  3. 计算傅里叶变换，并将 $|\\tilde{\\Delta}_{21}(\\mathbf{k})|^{2}$ 分箱到宽度为 $\\Delta k$ 的 $k$ 空间球壳中，然后除以盒子体积 $L^{3}$，以获得单位为 $\\mathrm{mK}^{2}\\,(\\mathrm{Mpc}\\,h^{-1})^{3}$ 的 $P_{21}(k)$ 估计值。\n- 使用三个不相交的 $k$ 箱，中心位于 $k \\in \\{0.1,\\,0.3,\\,0.5\\}\\,h\\,\\mathrm{Mpc}^{-1}$，每个箱的半宽为 $\\Delta k/2 = 0.05\\,h\\,\\mathrm{Mpc}^{-1}$；即箱的范围为 $[0.05,0.15)$、$[0.25,0.35)$ 和 $[0.45,0.55)$。\n\n自旋温度测试套件：\n- 通过“切换” $x_{c}$ 和 $x_{\\alpha}$ 来评估四种耦合方案：\n  1. 情况A（基准）：$x_{c} = x_{c,\\mathrm{on}}$，$x_{\\alpha} = x_{\\alpha,\\mathrm{on}}$。\n  2. 情况B（仅碰撞）：$x_{c} = x_{c,\\mathrm{on}}$，$x_{\\alpha} = 0$。\n  3. 情况C（仅Ly$\\alpha$）：$x_{c} = 0$，$x_{\\alpha} = x_{\\alpha,\\mathrm{on}}$。\n  4. 情况D（两者皆无）：$x_{c} = 0$，$x_{\\alpha} = 0$。\n\n要求输出：\n- 对于每种情况，计算分箱功率谱相对于基准情况的分数变化 $\\Delta_{\\mathrm{frac}}(k) = \\dfrac{P_{21}^{\\mathrm{case}}(k) - P_{21}^{\\mathrm{A}}(k)}{P_{21}^{\\mathrm{A}}(k)}$，并在上述定义的三个 $k$ 箱处进行评估。将这些分数变化表示为无量纲的小数。\n- 您的程序必须使用随机种子 $42$ 以确保可复现性，实现上述所有步骤，并按情况 A、B、C、D 的顺序，将结果以逗号分隔的列表的列表形式在一行中输出。例如，输出的形式必须为 [[a1,a2,a3],[b1,b2,b3],[c1,c2,c3],[d1,d2,d3]]，其中每个条目是对应于三个箱中分数变化的浮点数。因此，基准情况 A 应产生大约 [0,0,0] 的结果。\n\n不使用角度单位。计算中出现的所有物理单位必须一致：温度单位为开尔文，$T_{\\mathrm{b}}$ 单位为毫开尔文，波数单位为 $h\\,\\mathrm{Mpc}^{-1}$，体积单位为 $(\\mathrm{Mpc}\\,h^{-1})^{3}$，$P_{21}$ 单位为 $\\mathrm{mK}^{2}\\,(\\mathrm{Mpc}\\,h^{-1})^{3}$。最终要求的分数变化是无量纲的。程序必须是自包含的，不需要任何输入，并按上述指定格式准确打印一行输出。", "solution": "该问题陈述在物理宇宙学领域提出了一个定义明确且有科学依据的数值实验。它提供了一套清晰、自包含的指令和参数，用于构建再电离时期21厘米亮温度场的玩具模型。其目标是量化21厘米功率谱对控制氢自旋温度的不同物理耦合机制的敏感性。所有提供的定义、方程和数值都与该领域简化模型的标准文献和实践相一致。该问题没有科学缺陷、矛盾或歧义，可以得到一个唯一且有意义的解。所指定的简化（例如均匀的中性分数和动理学温度）对于分离自旋温度耦合效应这一既定目标是适当的。因此，该问题被认为是有效的。\n\n解决方案的流程是严格按照描述实现数值模拟。核心步骤包括：1) 设置计算域和物理常数；2) 生成具有指定统计特性的高斯随机过密度场 $\\delta(\\mathbf{x})$；3) 对四种自旋温度耦合情况中的每一种，计算21厘米亮温度场 $T_{\\mathrm{b}}(\\mathbf{x})$；4) 对每种情况，计算亮温度涨落的分箱功率谱 $P_{21}(k)$；以及 5) 计算每个分箱中功率谱相对于基准情况的分数变化。\n\n首先，我们根据问题陈述定义物理和数值常数。\n模拟区域是一个边长为 $L=200\\,\\mathrm{Mpc}\\,h^{-1}$ 的周期性立方体，位于一个 $N^3=32^3$ 个单元的网格上。\n红移为 $z=10$，得出宇宙微波背景（CMB）温度为 $T_{\\gamma} = 2.725(1+z) = 29.975\\,\\mathrm{K}$。\n给定均匀的中性氢分数 $x_{\\mathrm{HI}}=1$ 和均匀的气体动理学温度 $T_{\\mathrm{K}}=5\\,\\mathrm{K}$。莱曼-$\\alpha$（Ly$\\alpha$）色温被设定为等于动理学温度，$T_{\\alpha}=T_{\\mathrm{K}}$。\n\n过密度场 $\\delta(\\mathbf{x})$ 在傅里叶空间中生成。构建一个波矢 $\\mathbf{k}$ 的网格，其分量由 $k_i = 2\\pi m_i/L$ 给出，其中整数 $m_i \\in [-N/2, N/2-1]$。我们在傅里叶空间中生成一个复高斯白噪声场 $\\tilde{w}(\\mathbf{k})$。这等同于在实空间中生成白噪声然后进行变换。然后通过应用指定的传递函数 $T(k)$ 来塑造该场：\n$$\n\\tilde{\\delta}(\\mathbf{k}) = \\tilde{w}(\\mathbf{k}) T(k)\n$$\n其中 $k=|\\mathbf{k}|$ 且传递函数为\n$$\nT(k) = \\left(\\frac{k}{k_{0}}\\right)^{n/2}\\exp\\left[-\\frac{1}{2}\\left(\\frac{k}{k_{c}}\\right)^{2}\\right]\n$$\n参数为 $n=-2.5$，$k_0 = 0.1\\,h\\,\\mathrm{Mpc}^{-1}$ 和 $k_c = 0.8\\,h\\,\\mathrm{Mpc}^{-1}$。直流分量（DC mode）$\\tilde{\\delta}(\\mathbf{k}=0)$ 被设置为零。一次快速傅里叶逆变换（FFT）得到实空间场 $\\delta(\\mathbf{x})$。减去任何数值残余均值以确保 $\\langle\\delta\\rangle=0$。所有四种情况都使用这个相同的密度场。\n\n对于每个测试情况（A、B、C、D），我们计算相应的空间均匀自旋温度 $T_{\\mathrm{S}}$。Wouthuysen-Field 关系式如下：\n$$\nT_{\\mathrm{S}}^{-1} = \\frac{T_{\\gamma}^{-1} + x_{c}\\,T_{\\mathrm{K}}^{-1} + x_{\\alpha}\\,T_{\\alpha}^{-1}}{1 + x_{c} + x_{\\alpha}}\n$$\n耦合系数 $(x_c, x_\\alpha)$ 根据不同情况设置：A $(x_{c,\\mathrm{on}}, x_{\\alpha,\\mathrm{on}})$，B $(x_{c,\\mathrm{on}}, 0)$，C $(0, x_{\\alpha,\\mathrm{on}})$ 和 D $(0,0)$，其中 $x_{c,\\mathrm{on}}=0.1$ 且 $x_{\\alpha,\\mathrm{on}}=2.0$。\n\n然后计算每种情况下的亮温度场 $T_{\\mathrm{b}}(\\mathbf{x})$。由于 $x_{\\mathrm{HI}}$、$z$、$T_{\\gamma}$ 和 $T_{\\mathrm{S}}$（在给定情况下）都是空间均匀的，表达式简化为过密度的线性函数：\n$$\nT_{\\mathrm{b}}(\\mathbf{x}) = C \\cdot (1 + \\delta(\\mathbf{x}))\n$$\n其中常数 $C$ 由下式给出\n$$\nC = 27\\,\\mathrm{mK} \\cdot x_{\\mathrm{HI}} \\cdot \\left(1 - \\frac{T_{\\gamma}}{T_{\\mathrm{S}}}\\right) \\cdot \\sqrt{\\frac{1+z}{10}}\n$$\n涨落场为 $\\Delta_{21}(\\mathbf{x}) = T_{\\mathrm{b}}(\\mathbf{x}) - \\langle T_{\\mathrm{b}} \\rangle$。由于 $\\langle\\delta\\rangle=0$，我们有 $\\langle T_{\\mathrm{b}}\\rangle = C$，因此 $\\Delta_{21}(\\mathbf{x}) = C \\cdot \\delta(\\mathbf{x})$。\n\n功率谱 $P_{21}(k)$ 是通过数值方法估计的。我们计算离散傅里叶变换 $\\tilde{\\Delta}_{21}(\\mathbf{k}) = \\mathrm{FFT}[\\Delta_{21}(\\mathbf{x})]$。每个模式的功率是 $|\\tilde{\\Delta}_{21}(\\mathbf{k})|^2$。然后在 $k$ 空间中的三个球壳内对这些功率值进行平均，这些球壳由区间 $[0.05, 0.15)$、$[0.25, 0.35)$ 和 $[0.45, 0.55)$ 定义，单位均为 $h\\,\\mathrm{Mpc}^{-1}$。问题要求计算分数变化，即功率谱的比值。任何归一化常数（如关联散和连续傅里叶变换的体积因子）都会被抵消。因此，我们可以简单地对每个分箱内的原始 $|\\tilde{\\Delta}_{21}(\\mathbf{k})|^2$ 值进行平均，以获得一个与分箱功率谱成正比的量。\n\n最后，对于情况 B、C 和 D，计算每个 $k$ 箱相对于基准情况 A 的分数变化：\n$$\n\\Delta_{\\mathrm{frac}}(k) = \\frac{P_{21}^{\\mathrm{case}}(k) - P_{21}^{\\mathrm{A}}(k)}{P_{21}^{\\mathrm{A}}(k)}\n$$\n由于 $\\Delta_{21}(\\mathbf{x}) \\propto \\delta(\\mathbf{x})$，功率谱 $P_{21}(k) \\propto P_{\\delta}(k)$，其中 $P_{\\delta}(k)$ 是过密度场的功率谱。具体来说，$P_{21}^{\\text{case}}(k) = C_{\\text{case}}^2 P_{\\delta}(k)$。因此，分数变化简化为 $\\Delta_{\\mathrm{frac}} = (C_{\\text{case}}/C_{\\text{A}})^2 - 1$，这与波数 $k$ 无关。我们的数值模拟将明确展示该模型简化的这一结果，即对于任何给定情况，在所有三个 $k$ 箱中产生的分数变化值几乎相同。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the sensitivity of the 21cm power spectrum to spin temperature\n    coupling prescriptions in a toy model of the epoch of reionization.\n    \"\"\"\n    \n    # 1. Define constants and parameters\n    L = 200.0  # Box side length in Mpc/h\n    N = 32     # Grid size along each dimension\n    z = 10.0   # Redshift\n    x_HI = 1.0 # Uniform neutral hydrogen fraction\n    T_K = 5.0  # Uniform gas kinetic temperature in K\n    T_alpha = T_K # Ly-alpha color temperature in K\n    x_c_on = 0.1\n    x_alpha_on = 2.0\n    n = -2.5   # Power spectrum spectral index parameter\n    k0 = 0.1   # Power spectrum pivot scale in h/Mpc\n    kc = 0.8   # Power spectrum cutoff scale in h/Mpc\n    T_CMB_0 = 2.725 # CMB temperature at z=0 in K\n    seed = 42\n\n    T_gamma = T_CMB_0 * (1.0 + z)\n    \n    # Define the four test cases\n    cases = {\n        'A': (x_c_on, x_alpha_on),    # Baseline\n        'B': (x_c_on, 0.0),           # Collisions only\n        'C': (0.0, x_alpha_on),       # Ly-alpha only\n        'D': (0.0, 0.0)              # Neither\n    }\n    case_order = ['A', 'B', 'C', 'D']\n\n    # 2. Set up Fourier space grid\n    k_vec = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    kx, ky, kz = np.meshgrid(k_vec, k_vec, k_vec, indexing='ij')\n    k_mag = np.sqrt(kx**2 + ky**2 + kz**2)\n\n    # 3. Generate the overdensity field delta(x)\n    np.random.seed(seed)\n    # Generate Gaussian white noise in real space and transform\n    white_noise = np.random.randn(N, N, N)\n    white_noise_k = np.fft.fftn(white_noise)\n    \n    # Define transfer function T(k)\n    T_k = np.zeros_like(k_mag, dtype=np.float64)\n    non_zero_k = k_mag > 0\n    k_mag_safe = k_mag[non_zero_k]\n    T_k[non_zero_k] = np.power(k_mag_safe / k0, n / 2.0) * np.exp(-0.5 * np.power(k_mag_safe / kc, 2))\n    \n    # Apply transfer function to shape the field\n    delta_k = white_noise_k * T_k\n    delta_k[0, 0, 0] = 0.0  # Set mean to zero\n\n    # Transform back to real space and ensure mean is zero\n    delta_r = np.real(np.fft.ifftn(delta_k))\n    delta_r -= np.mean(delta_r)\n\n    # 4. Define binning scheme and a function to compute binned power spectrum\n    k_bins = [\n        (0.05, 0.15),\n        (0.25, 0.35),\n        (0.45, 0.55)\n    ]\n\n    def get_binned_power_spectrum(delta_21_field):\n        \"\"\"Computes the binned power spectrum of a given field.\"\"\"\n        delta_21_k = np.fft.fftn(delta_21_field)\n        power_modes = np.abs(delta_21_k)**2\n        \n        binned_P = []\n        for k_min, k_max in k_bins:\n            mask = (k_mag >= k_min)  (k_mag  k_max)\n            modes_in_bin = np.sum(mask)\n            if modes_in_bin > 0:\n                # Average power of modes in the k-shell\n                p_k = np.mean(power_modes[mask])\n                binned_P.append(p_k)\n            else:\n                binned_P.append(0.0) # No modes in this bin\n        return np.array(binned_P)\n\n    # 5. Calculate power spectrum for each case\n    all_power_spectra = {}\n    prefactor_Tb = 27.0 * x_HI * np.sqrt((1.0 + z) / 10.0)\n\n    for name, (xc, xa) in cases.items():\n        # Calculate spin temperature T_S\n        denominator = 1.0 + xc + xa\n        if np.isclose(denominator, 0): # Should not happen for problem cases\n            T_S = T_gamma\n        else:\n            T_S_inv = (T_gamma**-1 + xc * T_K**-1 + xa * T_alpha**-1) / denominator\n            T_S = 1.0 / T_S_inv if T_S_inv > 0 else np.inf\n\n        # Calculate the scaling constant C for the brightness temperature\n        if np.isclose(T_S, T_gamma):\n            C = 0.0\n        else:\n            C = prefactor_Tb * (1.0 - T_gamma / T_S)\n        \n        # Fluctuation field is C * delta_r\n        delta_21 = C * delta_r\n\n        # Compute and store binned power spectrum\n        all_power_spectra[name] = get_binned_power_spectrum(delta_21)\n\n    # 6. Compute and format fractional changes\n    P_A_binned = all_power_spectra['A']\n    final_results = []\n\n    for name in case_order:\n        P_case_binned = all_power_spectra[name]\n        \n        # Calculate fractional change, handling potential division by zero\n        frac_change = np.zeros_like(P_A_binned)\n        valid_bins = P_A_binned > 1e-12 # Use a small threshold for float comparison\n        \n        frac_change[valid_bins] = (P_case_binned[valid_bins] - P_A_binned[valid_bins]) / P_A_binned[valid_bins]\n        \n        # Handle case where P_A(k) is zero but P_case(k) is not (very unlikely)\n        # In this specific problem, it indicates P_case(k) must also be zero\n        \n        final_results.append(list(frac_change))\n\n    # Print in the required format\n    print(str(final_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3488955"}]}