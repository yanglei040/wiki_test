{"hands_on_practices": [{"introduction": "任何宇宙学N体模拟都始于一个早期时刻，即初始红移 $z_i$。理论上，这个时刻必须早到足以让线性微扰理论精确描述宇宙的状态。本练习将指导您如何基于拉格朗日微扰理论（LPT）的原理，通过量化分析来确定一个最佳的初始红移，这是一个在精度和计算效率之间取得平衡的关键实践。[@problem_id:3468236]", "problem": "您正在为一个模拟本地宇宙的宇宙学 $N$ 体模拟准备约束初始条件，其中的位移场是通过维纳滤波器从观测到的本动速度中重建的，并用小尺度模进行了增强。为确保可靠的初始化，必须选择起始红移 $z_i$，使得在模拟开始时同时满足两个要求。\n\n将分析建立在拉格朗日微扰理论（LPT）之上。该理论将拉格朗日坐标 $\\boldsymbol{q}$ 到欧拉坐标 $\\boldsymbol{x}$ 在尺度因子为 $a$ 时的共动映射建模为关于位移场的微扰级数，其一阶（Zel’dovich）和二阶修正由增长因子来表征。假设早期膨胀可以由爱因斯坦-德西特（EdS）宇宙很好地描述，并进行归一化，使得一阶增长因子为 $D_1(1)=1$，二阶增长因子为 $D_2(1)=-\\frac{3}{7}$（标准EdS归一化）。将均方根（RMS）定义为在模拟体积上的均方根（RMS）范数。\n\n在对应于起始红移 $z_i$ 的尺度因子 $a_i$ 处，施加以下两个准则：\n\n1. 在 $a_i$ 处，最大一阶（1LPT）粒子位移是网格间距的一个小部分，即：\n$$\n|D_1(a_i)|\\, s_{\\max} \\le \\epsilon\\, \\Delta,\n$$\n其中 $s_{\\max}$ 是在 $z=0$ 时重建的 1LPT 位移场的最大值，$\\Delta$ 是共动网格间距，$\\epsilon$ 是一个选定的分数。\n\n2. 在 $a_i$ 处，二阶（2LPT）修正的 RMS 振幅相对于 1LPT 项的 RMS 振幅是次要的，即：\n$$\n|D_2(a_i)|\\, \\sigma_t \\le \\eta\\, |D_1(a_i)|\\, \\sigma_s,\n$$\n其中 $\\sigma_s$ 和 $\\sigma_t$ 分别是在 $z=0$ 时 1LPT 和 2LPT 位移场的 RMS 大小，$\\eta$ 是一个选定的小数，用于量化初始时所需的次要性。\n\n假设在早期存在 EdS 增长，并采用上述归一化的 $D_1(a)$ 和 $D_2(a)$ 的标准 EdS 标度关系。从第一性原理出发，推导同时满足这两个准则的最小 $z_i$ 的闭式表达式。然后，使用以下适用于本地宇宙约束设置的科学上合理的参数来计算该表达式的值：\n- 网格间距 $\\Delta = $ $0.5$ $h^{-1}\\,\\mathrm{Mpc}$，\n- 分数 $\\epsilon = $ $0.2$，\n- $z=0$ 时的最大 1LPT 位移 $s_{\\max} = $ $5.0$ $h^{-1}\\,\\mathrm{Mpc}$，\n- $z=0$ 时的 RMS 1LPT 位移 $\\sigma_s = $ $1.5$ $h^{-1}\\,\\mathrm{Mpc}$，\n- $z=0$ 时的 RMS 2LPT 位移 $\\sigma_t = $ $3.0$ $h^{-1}\\,\\mathrm{Mpc}$，\n- 次要性参数 $\\eta = $ $0.1$。\n\n将最终答案表示为无量纲数 $z_i$，并四舍五入到三位有效数字。最终答案中不应包含任何单位。", "solution": "经评估，该问题陈述是有效的。它以标准宇宙学微扰理论为科学基础，问题设定适定，目标明确，数据充分，并且没有内部矛盾或含糊不清之处。所提供的参数对于本地宇宙的模拟在物理上是合理的。\n\n目标是确定 $N$ 体模拟的最小起始红移 $z_i$，这对应于最大起始尺度因子 $a_i = (1+z_i)^{-1}$，使得两个准则同时得到满足。该分析基于早期宇宙的爱因斯坦-德西特（EdS）模型。\n\n在 EdS 宇宙中，一阶（1LPT）和二阶（2LPT）增长因子随尺度因子 $a$ 的变化关系为 $D_1(a) \\propto a$ 和 $D_2(a) \\propto a^2$。问题给出了在现今（$z=0$，对应于 $a=1$）的归一化条件：$D_1(1)=1$ 和 $D_2(1)=-3/7$。利用此归一化，我们可以写出在任意尺度因子 $a$ 下增长因子的显式表达式：\n$$\nD_1(a) = D_1(1) \\left(\\frac{a}{1}\\right) = a\n$$\n$$\nD_2(a) = D_2(1) \\left(\\frac{a}{1}\\right)^2 = -\\frac{3}{7}a^2\n$$\n因此，在初始尺度因子 $a_i$ 处，这些增长因子的绝对值为：\n$$\n|D_1(a_i)| = a_i\n$$\n$$\n|D_2(a_i)| = \\left|-\\frac{3}{7}a_i^2\\right| = \\frac{3}{7}a_i^2\n$$\n因为 $a_i$ 是正数。\n\n现在我们将这两个准则应用于初始尺度因子 $a_i$。\n\n**准则1：最大 1LPT 位移**\n第一个准则限制了模拟开始时的最大粒子位移：\n$$\n|D_1(a_i)|\\, s_{\\max} \\le \\epsilon\\, \\Delta\n$$\n代入 $|D_1(a_i)| = a_i$，我们得到：\n$$\na_i\\, s_{\\max} \\le \\epsilon\\, \\Delta\n$$\n这对初始尺度因子 $a_i$ 施加了一个上限：\n$$\na_i \\le \\frac{\\epsilon \\Delta}{s_{\\max}}\n$$\n\n**准则2：2LPT 修正的次要性**\n第二个准则确保了位移场的二阶修正在 RMS 意义上相对于一阶项是次要的：\n$$\n|D_2(a_i)|\\, \\sigma_t \\le \\eta\\, |D_1(a_i)|\\, \\sigma_s\n$$\n代入 $|D_1(a_i)|$ 和 $|D_2(a_i)|$ 的表达式：\n$$\n\\left(\\frac{3}{7}a_i^2\\right) \\sigma_t \\le \\eta\\, a_i\\, \\sigma_s\n$$\n由于 $a_i  0$，我们可以将不等式两边同除以 $a_i$ 而不改变不等号的方向：\n$$\n\\frac{3}{7}a_i\\, \\sigma_t \\le \\eta\\, \\sigma_s\n$$\n这得出了对 $a_i$ 的第二个上限：\n$$\na_i \\le \\frac{7 \\eta \\sigma_s}{3 \\sigma_t}\n$$\n\n**组合约束与最小红移**\n为使模拟能被有效地初始化，两个准则必须同时满足。这意味着 $a_i$ 必须小于或等于两个推导出的上限。最严格的约束决定了 $a_i$ 的最大允许值：\n$$\na_{i, \\text{max}} = \\min\\left(\\frac{\\epsilon \\Delta}{s_{\\max}}, \\frac{7 \\eta \\sigma_s}{3 \\sigma_t}\\right)\n$$\n红移 $z$ 和尺度因子 $a$ 之间的关系是 $z = a^{-1} - 1$。这是一个单调递减函数。因此，最小起始红移 $z_i$ 对应于最大起始尺度因子 $a_{i, \\text{max}}$。\n$$\nz_i = \\frac{1}{a_{i, \\text{max}}} - 1 = \\frac{1}{\\min\\left(\\frac{\\epsilon \\Delta}{s_{\\max}}, \\frac{7 \\eta \\sigma_s}{3 \\sigma_t}\\right)} - 1\n$$\n该表达式可以利用 $1/\\min(x,y) = \\max(1/x, 1/y)$ 的性质重写为：\n$$\nz_i = \\max\\left(\\frac{s_{\\max}}{\\epsilon \\Delta}, \\frac{3 \\sigma_t}{7 \\eta \\sigma_s}\\right) - 1\n$$\n这就是所需的最小起始红移 $z_i$ 的闭式表达式。\n\n**数值计算**\n现在我们将给定的参数值代入此表达式中。这些参数是：\n- $\\Delta = 0.5$ $h^{-1}\\,\\mathrm{Mpc}$\n- $\\epsilon = 0.2$\n- $s_{\\max} = 5.0$ $h^{-1}\\,\\mathrm{Mpc}$\n- $\\sigma_s = 1.5$ $h^{-1}\\,\\mathrm{Mpc}$\n- $\\sigma_t = 3.0$ $h^{-1}\\,\\mathrm{Mpc}$\n- $\\eta = 0.1$\n\n在比率计算中，所有的长度单位（$h^{-1}\\,\\mathrm{Mpc}$）都相互抵消，最终得到所需的无量纲量。\n让我们计算 $\\max$ 函数的两个参数。\n\n第一个参数（来自准则1）：\n$$\n\\frac{s_{\\max}}{\\epsilon \\Delta} = \\frac{5.0}{0.2 \\times 0.5} = \\frac{5.0}{0.1} = 50\n$$\n\n第二个参数（来自准则2）：\n$$\n\\frac{3 \\sigma_t}{7 \\eta \\sigma_s} = \\frac{3 \\times 3.0}{7 \\times 0.1 \\times 1.5} = \\frac{9.0}{1.05} = \\frac{900}{105} = \\frac{180}{21} = \\frac{60}{7} \\approx 8.5714\n$$\n\n现在我们取这两个值的最大值：\n$$\n\\max\\left(50, \\frac{60}{7}\\right) = 50\n$$\n第一个准则是更严格的约束。因此，$1+z_i$ 的最小值为 $50$。\n最小起始红移为：\n$$\nz_i = 50 - 1 = 49\n$$\n问题要求答案四舍五入到三位有效数字。精确值为 $49$。表示为三位有效数字，即为 $49.0$。", "answer": "$$\n\\boxed{49.0}\n$$", "id": "3468236"}, {"introduction": "生成约束性初始条件的核心任务是从晚期宇宙的观测数据（例如星系位置）反推初始的密度场。本练习将带您实现“逆向泽尔多维奇近似”（Reverse Zeldovich Approximation），这是一种基础的重建技术。通过一个模拟实验，您将从已知的初始位移场正向演化出“观测”到的星系位置，然后再尝试反演这一过程，从而深刻理解非线性效应和模型参数不准确性对初始条件重建带来的挑战。[@problem_id:3468288]", "problem": "你的任务是在一个周期性的立方体区域内实现反向 Zeldovich 近似，从观测到的 Eulerian 星系位置推断初始的 Lagrangian 位移，并测试该推断对假设的线性增长因子以及是否包含二阶修正的敏感性。整个工作在牛顿引力框架下，在一个具有共动坐标和周期性边界条件的膨胀宇宙中进行。所有量都必须在三维空间中处理，并且所有空间坐标都必须以百万秒差距除以哈勃参数为单位表示，具体为 $\\mathrm{Mpc}/h$。角度单位在此不适用。\n\n从以下基础开始：\n\n- Zeldovich 近似（ZA）是 Lagrangian 微扰理论（LPT）的一阶解。在标度因子为 $a$ 时，由其 Lagrangian 坐标 $\\mathbf{q}$ 标记的质量元的 Eulerian 位置 $\\mathbf{x}$ 可写作\n$$\n\\mathbf{x}(\\mathbf{q}, a) = \\mathbf{q} + \\mathbf{\\Psi}(\\mathbf{q}, a),\n$$\n其中位移场 $\\mathbf{\\Psi}$ 容许一个微扰展开\n$$\n\\mathbf{\\Psi}(\\mathbf{q}, a) = D(a)\\,\\mathbf{\\Psi}^{(1)}(\\mathbf{q}) + D_2(a)\\,\\mathbf{\\Psi}^{(2)}(\\mathbf{q}) + \\cdots,\n$$\n其中 $D(a)$ 是线性增长因子，$D_2(a)$ 是二阶增长因子。在 Einstein–de Sitter 背景下，有 $D_2(a) = -\\frac{3}{7}D(a)^2$。\n\n- 一阶位移是无旋的，并通过一个满足以下条件的标量势 $\\phi^{(1)}(\\mathbf{q})$ 与线性密度对比度相关联\n$$\n\\nabla^2 \\phi^{(1)}(\\mathbf{q}) = \\delta^{(1)}(\\mathbf{q}), \\quad \\mathbf{\\Psi}^{(1)}(\\mathbf{q}) = -\\nabla \\phi^{(1)}(\\mathbf{q}),\n$$\n其中 $\\delta^{(1)}(\\mathbf{q})$ 是线性密度对比度。在波矢为 $\\mathbf{k}$ 的傅里叶空间中，这意味着\n$$\n\\tilde{\\mathbf{\\Psi}}^{(1)}(\\mathbf{k}) = i\\,\\frac{\\mathbf{k}}{k^2}\\,\\tilde{\\delta}^{(1)}(\\mathbf{k}),\n$$\n对于 $k \\equiv \\|\\mathbf{k}\\| \\neq 0$，且 $\\tilde{\\cdot}$ 表示傅里叶变换。\n\n- 二阶位移可以通过一个满足以下条件的二阶势 $\\phi^{(2)}(\\mathbf{q})$ 来表示\n$$\n\\nabla^2 \\phi^{(2)}(\\mathbf{q}) = S_2(\\mathbf{q}),\n$$\n其中二次源项由 $\\phi^{(1)}$ 的导数构成\n$$\nS_2(\\mathbf{q}) = \\sum_{i>j} \\left[ \\phi^{(1)}_{,ii}(\\mathbf{q})\\,\\phi^{(1)}_{,jj}(\\mathbf{q}) - \\left(\\phi^{(1)}_{,ij}(\\mathbf{q})\\right)^2 \\right],\n$$\n且\n$$\n\\mathbf{\\Psi}^{(2)}(\\mathbf{q}) = -\\nabla \\phi^{(2)}(\\mathbf{q}).\n$$\n\n在一个边长为 $L$、包含 $N^3$ 个代表等质量示踪物的网格点的周期性立方体盒子中，实现以下计算实验：\n\n1. 在盒子中构建一个合成的线性密度场 $\\delta^{(1)}(\\mathbf{q})$，作为两个正交单模余弦波的叠加：\n$$\n\\delta^{(1)}(\\mathbf{q}) = A\\left[\\cos\\left(\\mathbf{k}_1\\cdot \\mathbf{q}\\right) + \\cos\\left(\\mathbf{k}_2\\cdot \\mathbf{q}\\right)\\right],\n$$\n其中 $\\mathbf{k}_1 = \\frac{2\\pi}{L}(1,0,0)$，$\\mathbf{k}_2 = \\frac{2\\pi}{L}(0,1,0)$，以及振幅 $A$。使用傅里叶方法，在周期性边界条件下计算 $\\mathbf{\\Psi}^{(1)}(\\mathbf{q})$ 和 $\\mathbf{\\Psi}^{(2)}(\\mathbf{q})$。\n\n2. 执行到标度因子 $a$ 处的 Eulerian 位置的正向演化：\n$$\n\\mathbf{x}(\\mathbf{q}, a) = \\mathbf{q} + D_{\\mathrm{true}}(a)\\,\\mathbf{\\Psi}^{(1)}(\\mathbf{q}) + D_{2,\\mathrm{true}}(a)\\,\\mathbf{\\Psi}^{(2)}(\\mathbf{q}),\n$$\n如果包含二阶演化，则 $D_{2,\\mathrm{true}}(a) = -\\frac{3}{7}\\left(D_{\\mathrm{true}}(a)\\right)^2$，否则 $D_{2,\\mathrm{true}}(a)=0$。将位置 $\\mathbf{x}$ 视为观测值。\n\n3. 通过假设值 $D_{\\mathrm{assumed}}(a)$ 并可选择性地减去一个带有 $D_{2,\\mathrm{assumed}}(a)$ 的二阶项，来实现对初始位移的反向 Zeldovich 估计：\n- 朴素反向 ZA（忽略二阶）：\n$$\n\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) = \\frac{\\mathbf{x}(\\mathbf{q}, a) - \\mathbf{q}}{D_{\\mathrm{assumed}}(a)}.\n$$\n- 二阶修正的反向 ZA：\n$$\n\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) = \\frac{\\mathbf{x}(\\mathbf{q}, a) - \\mathbf{q} - D_{2,\\mathrm{assumed}}(a)\\,\\mathbf{\\Psi}^{(2)}(\\mathbf{q})}{D_{\\mathrm{assumed}}(a)}.\n$$\n\n4. 对每个测试案例，使用推斷出的 $\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q})$ 与真实的 $\\mathbf{\\Psi}^{(1)}(\\mathbf{q})$ 在所有 $N^3$ 个示踪物上的均方根相对误差来量化推断质量：\n$$\n\\varepsilon = \\frac{\\left[\\frac{1}{N^3}\\sum_{\\mathbf{q}}\\left\\|\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) - \\mathbf{\\Psi}^{(1)}(\\mathbf{q})\\right\\|^2\\right]^{1/2}}{\\left[\\frac{1}{N^3}\\sum_{\\mathbf{q}}\\left\\|\\mathbf{\\Psi}^{(1)}(\\mathbf{q})\\right\\|^2\\right]^{1/2}}.\n$$\n\n使用边长 $L = 100\\,\\mathrm{Mpc}/h$、每维 $N = 32$ 个网格点的立方体盒子。评估以下测试套件，每个测试由元组 $(A, D_{\\mathrm{true}}, \\mathrm{include\\_2LPT}, D_{\\mathrm{assumed}}, \\mathrm{subtract\\_2LPT}, D_{2,\\mathrm{assumed}})$ 定义：\n\n- 测试 1：$(0.05, 1.0, \\mathrm{True}, 1.0, \\mathrm{False}, -\\frac{3}{7}\\cdot 1.0^2)$。\n- 测试 2：$(0.05, 1.0, \\mathrm{True}, 0.9, \\mathrm{False}, -\\frac{3}{7}\\cdot 0.9^2)$。\n- 测试 3：$(0.05, 1.0, \\mathrm{True}, 1.0, \\mathrm{True}, -\\frac{3}{7}\\cdot 1.0^2)$。\n- 测试 4：$(10^{-4}, 1.0, \\mathrm{True}, 1.0, \\mathrm{False}, -\\frac{3}{7}\\cdot 1.0^2)$。\n- 测试 5：$(0.2, 1.0, \\mathrm{False}, 1.0, \\mathrm{False}, 0.0)$。\n\n对每个测试，计算如上定义的 $\\varepsilon$。你的程序应该产生一行输出，包含五个 $\\varepsilon$ 值，形式为用方括号括起来的逗号分隔列表，例如 $\\left[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4,\\varepsilon_5\\right]$。所有空间量和盒子尺寸必须以 $\\mathrm{Mpc}/h$ 为单位，误差是无量纲浮点数。不应打印任何额外文本。", "solution": "用户提供的问题是一个有效的、适定的计算物理问题，它基于标准的宇宙学微扰理论。它要求实现和测试用于重建初始宇宙位移场的反向 Zeldovich 近似。所提供的参数和方程是自洽的、科学上正确的，并且足以推导出一个唯一的数值解。我们现在着手进行逐步推导和实现计划。\n\n问题的核心是使用傅里葉方法在三维周期性网格上求解一组类泊松方程，并评估基于此框架的重建方案的准确性。\n\n### 1. 离散化与傅里葉空间表示\n我们在一个边长为 $L$、有 $N^3$ 个点的立方网格上操作。Lagrangian 坐标 $\\mathbf{q}$ 占据网格节点。我们可以表示这个网格上的任何标量场或矢量场，例如一个泛型场 $f(\\mathbf{q})$。离散傅里葉变换 (DFT) 及其逆变换定义如下：\n$$\n\\tilde{f}(\\mathbf{k}) = \\sum_{\\mathbf{q}} f(\\mathbf{q}) e^{-i\\mathbf{k}\\cdot\\mathbf{q}}\n$$\n$$\nf(\\mathbf{q}) = \\frac{1}{N^3} \\sum_{\\mathbf{k}} \\tilde{f}(\\mathbf{k}) e^{i\\mathbf{k}\\cdot\\mathbf{q}}\n$$\n波矢 $\\mathbf{k}$ 也在傅里葉空间中形成一个网格。对于由整数 $(n_x, n_y, n_z) \\in [0, N-1]^3$ 索引的网格点，其物理坐标为 $q_i = n_i \\frac{L}{N}$。相应的波矢分量为 $k_i = m_i \\frac{2\\pi}{L}$，其中整数频率指数 $m_i$ 通常按 $\\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$ 的顺序排列。\n\n关键的是，微分算子在傅里葉空间中变为代数运算。梯度和拉普拉斯算子变换为：\n$$\n\\widetilde{\\nabla f}(\\mathbf{k}) = i\\mathbf{k} \\tilde{f}(\\mathbf{k}), \\quad \\widetilde{\\nabla^2 f}(\\mathbf{k}) = -k^2 \\tilde{f}(\\mathbf{k})\n$$\n其中 $k^2 = \\|\\mathbf{k}\\|^2 = k_x^2 + k_y^2 + k_z^2$。这使我们能够通过在傅里葉空间中进行简单的除法来求解泊松方程 $\\nabla^2 \\phi = \\rho$：$\\tilde{\\phi}(\\mathbf{k}) = -\\frac{1}{k^2} \\tilde{\\rho}(\\mathbf{k})$，并对 $k=0$ 模式进行特殊处理。\n\n### 2. 构建真实位移场\n\n#### 2.1. 一阶场 $\\mathbf{\\Psi}^{(1)}$\n该过程始于定义线性密度对比度 $\\delta^{(1)}(\\mathbf{q})$。与其在实空间中构建然后进行变换，不如直接构建其傅里葉变换 $\\tilde{\\delta}^{(1)}(\\mathbf{k})$。给定的密度场是：\n$$\n\\delta^{(1)}(\\mathbf{q}) = A\\left[\\cos\\left(\\mathbf{k}_1\\cdot \\mathbf{q}\\right) + \\cos\\left(\\mathbf{k}_2\\cdot \\mathbf{q}\\right)\\right]\n$$\n其中基模为 $\\mathbf{k}_1 = \\frac{2\\pi}{L}(1,0,0)$ 和 $\\mathbf{k}_2 = \\frac{2\\pi}{L}(0,1,0)$。在 $N^3$ 网格上，余弦项 $\\cos(\\mathbf{k}_j \\cdot \\mathbf{q})$ 的离散傅里葉变换在波矢 $\\pm\\mathbf{k}_j$ 处有两个非零分量。因此，$\\tilde{\\delta}^{(1)}(\\mathbf{k})$ 仅在四个特定的波矢处非零：$\\pm \\mathbf{k}_1$ 和 $\\pm \\mathbf{k}_2$。傅里葉空间中这些 delta 函数的每一个的振幅为 $\\frac{A N^3}{2}$。\n\n根据关系式 $\\tilde{\\mathbf{\\Psi}}^{(1)}(\\mathbf{k}) = i\\,\\frac{\\mathbf{k}}{k^2}\\,\\tilde{\\delta}^{(1)}(\\mathbf{k})$，我们计算傅里葉空间中位移场的三个分量。对于 $k=0$，$\\tilde{\\delta}^{(1)}(\\mathbf{0})=0$，因为平均密度涨落为零，所以我们设置 $\\tilde{\\mathbf{\\Psi}}^{(1)}(\\mathbf{0})=\\mathbf{0}$。最后，我们对每个分量执行逆 DFT 以获得实空间场 $\\mathbf{\\Psi}^{(1)}(\\mathbf{q})$。\n\n#### 2.2. 二阶场 $\\mathbf{\\Psi}^{(2)}$\n$\\mathbf{\\Psi}^{(2)}$ 的计算更为复杂。\n1.  **一阶势 $\\phi^{(1)}$**：我们首先从 $\\nabla^2 \\phi^{(1)} = \\delta^{(1)}$ 中找到势 $\\phi^{(1)}$。在傅里葉空间中，这是 $\\tilde{\\phi}^{(1)}(\\mathbf{k}) = -\\frac{1}{k^2} \\tilde{\\delta}^{(1)}(\\mathbf{k})$。$k=0$ 模式 $\\tilde{\\phi}^{(1)}(\\mathbf{0})$ 设置为零。\n\n2.  **$\\phi^{(1)}$ 的导数**：二阶源项 $S_2(\\mathbf{q})$ 需要 $\\phi^{(1)}$ 的六个唯一的二阶导数，即 $\\phi^{(1)}_{,ij} \\equiv \\frac{\\partial^2 \\phi^{(1)}}{\\partial q_i \\partial q_j}$。这些可以利用傅里葉变换高效计算：\n    $$\n    \\phi^{(1)}_{,ij}(\\mathbf{q}) = \\mathcal{F}^{-1}\\left[ (i k_i)(i k_j) \\tilde{\\phi}^{(1)}(\\mathbf{k}) \\right] = \\mathcal{F}^{-1}\\left[ -k_i k_j \\tilde{\\phi}^{(1)}(\\mathbf{k}) \\right]\n    $$\n    其中 $\\mathcal{F}^{-1}$ 表示逆 DFT。我们用这种方式计算六个场（$\\phi^{(1)}_{,xx}, \\phi^{(1)}_{,yy}, \\phi^{(1)}_{,zz}, \\phi^{(1)}_{,xy}, \\phi^{(1)}_{,xz}, \\phi^{(1)}_{,yz}$）中的每一个。\n\n3.  **源项 $S_2$**：在实空间中，我们根据计算出的导数构建源项 $S_2(\\mathbf{q})$：\n    $$\n    S_2(\\mathbf{q}) = \\left[\\phi^{(1)}_{,xx}\\phi^{(1)}_{,yy} - (\\phi^{(1)}_{,xy})^2\\right] + \\left[\\phi^{(1)}_{,xx}\\phi^{(1)}_{,zz} - (\\phi^{(1)}_{,xz})^2\\right] + \\left[\\phi^{(1)}_{,yy}\\phi^{(1)}_{,zz} - (\\phi^{(1)}_{,yz})^2\\right]\n    $$\n\n4.  **求解 $\\mathbf{\\Psi}^{(2)}$**：已知 $S_2(\\mathbf{q})$后，我们以与求解 $\\mathbf{\\Psi}^{(1)}$ 相同的方式求解 $\\mathbf{\\Psi}^{(2)}(\\mathbf{q})$。我们有 $\\nabla^2 \\phi^{(2)} = S_2$ 和 $\\mathbf{\\Psi}^{(2)} = -\\nabla \\phi^{(2)}$，这导致 $\\tilde{\\mathbf{\\Psi}}^{(2)}(\\mathbf{k}) = i\\,\\frac{\\mathbf{k}}{k^2}\\,\\tilde{S}_2(\\mathbf{k})$。我们通过对 $S_2(\\mathbf{q})$ 进行正向 DFT 来计算 $\\tilde{S}_2(\\mathbf{k})$，然后计算 $\\tilde{\\mathbf{\\Psi}}^{(2)}(\\mathbf{k})$ 的分量，最后执行逆 DFT 以获得 $\\mathbf{\\Psi}^{(2)}(\\mathbf{q})$。$k=0$ 模式 $\\tilde{\\mathbf{\\Psi}}^{(2)}(\\mathbf{0})$ 设置为零，这是合理的，因为该模式代表整个网格的均匀平移，这在物理上是不相关的。\n\n### 3. 正向演化与反向估计\n\n对于每个测试案例，我们使用预先计算的场 $\\mathbf{\\Psi}^{(1)}$ 和 $\\mathbf{\\Psi}^{(2)}$（它们依赖于振幅 $A$）执行以下步骤。\n\n1.  **正向演化**：我们使用参数 $D_{\\mathrm{true}}$ 和 `include_2LPT` 从真实的 Lagrangian 位置 $\\mathbf{q}$（我们的网格点）计算“观测到的” Eulerian 位置 $\\mathbf{x}(\\mathbf{q})$：\n    $$\n    D_{2,\\mathrm{true}} = \\begin{cases} - (3/7) D_{\\mathrm{true}}^2  \\text{若 include\\_2LPT 为 True} \\\\ 0  \\text{若 include\\_2LPT 为 False} \\end{cases}\n    $$\n    $$\n    \\mathbf{x}(\\mathbf{q}) = \\mathbf{q} + D_{\\mathrm{true}}\\,\\mathbf{\\Psi}^{(1)}(\\mathbf{q}) + D_{2,\\mathrm{true}}\\,\\mathbf{\\Psi}^{(2)}(\\mathbf{q})\n    $$\n\n2.  **反向估计**：然后我们从“数据”（$\\mathbf{x}$ 和 $\\mathbf{q}$）和假设的模型参数中推断初始位移场 $\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q})$。问题通过假设 $\\mathbf{q}$ 已知而得以简化。\n    -   如果 `subtract_2LPT` 为 `False`，我们使用朴素反向 Zeldovich 近似：\n        $$\n        \\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) = \\frac{\\mathbf{x}(\\mathbf{q}) - \\mathbf{q}}{D_{\\mathrm{assumed}}}\n        $$\n    -   如果 `subtract_2LPT` 为 `True`，我们使用二阶修正公式，这需要真实的 $\\mathbf{\\Psi}^{(2)}$ 场和假设的二阶增长因子 $D_{2,\\mathrm{assumed}}$：\n        $$\n        \\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) = \\frac{\\mathbf{x}(\\mathbf{q}) - \\mathbf{q} - D_{2,\\mathrm{assumed}}\\,\\mathbf{\\Psi}^{(2)}(\\mathbf{q})}{D_{\\mathrm{assumed}}}\n        $$\n\n### 4. 误差量化\n重建的质量通过相对均方根 (RMS) 误差 $\\varepsilon$ 来衡量：\n$$\n\\varepsilon = \\frac{\\left[\\frac{1}{N^3}\\sum_{\\mathbf{q}}\\left\\|\\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) - \\mathbf{\\Psi}^{(1)}(\\mathbf{q})\\right\\|^2\\right]^{1/2}}{\\left[\\frac{1}{N^3}\\sum_{\\mathbf{q}}\\left\\|\\mathbf{\\Psi}^{(1)}(\\mathbf{q})\\right\\|^2\\right]^{1/2}} = \\sqrt{\\frac{\\sum_{\\mathbf{q}}\\|\\Delta \\mathbf{\\Psi}(\\mathbf{q})\\|^2}{\\sum_{\\mathbf{q}}\\|\\mathbf{\\Psi}^{(1)}(\\mathbf{q})\\|^2}}\n$$\n其中 $\\Delta \\mathbf{\\Psi}(\\mathbf{q}) = \\hat{\\mathbf{\\Psi}}^{(1)}(\\mathbf{q}) - \\mathbf{\\Psi}^{(1)}(\\mathbf{q})$，求和遍及所有 $N^3$ 个网格点。该度量将误差向量的 RMS 幅值与真实位移向量的 RMS 幅值进行比较。\n\n这些测试案例旨在探究不同的误差来源：测试 1 展示了忽略二阶项所产生的误差，测试 2 来自不正确的增长因子，测试 3 是一个使用完美模型的对照案例（期望 $\\varepsilon \\approx 0$），测试 4 显示了在极低振幅（线性区域）下的行为，测试 5 是一个基准的仅一阶场景。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements the reverse Zeldovich approximation experiment as specified.\n    \"\"\"\n    L = 100.0  # Box size in Mpc/h\n    N = 32     # Grid points per dimension\n\n    # Define test cases:\n    # (A, D_true, include_2LPT, D_assumed, subtract_2LPT, D2_assumed)\n    test_cases = [\n        (0.05, 1.0, True, 1.0, False, -3.0/7.0 * 1.0**2),\n        (0.05, 1.0, True, 0.9, False, -3.0/7.0 * 0.9**2),\n        (0.05, 1.0, True, 1.0, True, -3.0/7.0 * 1.0**2),\n        (1e-4, 1.0, True, 1.0, False, -3.0/7.0 * 1.0**2),\n        (0.2, 1.0, False, 1.0, False, 0.0),\n    ]\n\n    # --- Setup Grids ---\n    # Real space grid coordinates (Lagrangian)\n    q_coords_1d = np.arange(N) * (L / N)\n    q_grid = np.array(np.meshgrid(q_coords_1d, q_coords_1d, q_coords_1d, indexing='ij'))\n\n    # Fourier space grid of wavevectors\n    k_vals = 2 * np.pi * np.fft.fftfreq(N, d=L/N)\n    k_grid = np.array(np.meshgrid(k_vals, k_vals, k_vals, indexing='ij'))\n    k_sq = np.sum(k_grid**2, axis=0)\n\n    # For safe division, set k=0 component of k_sq to 1 (it will be zeroed out later)\n    inv_k_sq_safe = np.copy(k_sq)\n    if N % 2 == 0:\n        center = (0, 0, 0)\n    else:\n        center = (N//2, N//2, N//2) # Not strictly needed for even N but good practice\n    \n    if k_sq[center] == 0:\n        inv_k_sq_safe[center] = 1.0\n    inv_k_sq_safe = 1.0 / inv_k_sq_safe\n    if k_sq[center] == 0:\n        inv_k_sq_safe[center] = 0.0\n\n    results = []\n    computed_fields = {} # Cache fields based on amplitude A\n\n    for case in test_cases:\n        A, D_true, include_2LPT, D_assumed, subtract_2LPT, D2_assumed = case\n\n        if A not in computed_fields:\n            # --- 1. Construct True Fields ---\n            \n            # 1a. Linear density field in Fourier space\n            delta_k = np.zeros((N, N, N), dtype=np.complex128)\n            # Factor of N**3 comes from numpy's FFT normalization convention\n            val = A * (N**3) / 2.0\n            delta_k[1, 0, 0] = val\n            delta_k[N-1, 0, 0] = val\n            delta_k[0, 1, 0] = val\n            delta_k[0, N-1, 0] = val\n\n            # 1b. First-order displacement field Psi^(1)\n            psi1_k_x = 1j * k_grid[0] * inv_k_sq_safe * delta_k\n            psi1_k_y = 1j * k_grid[1] * inv_k_sq_safe * delta_k\n            psi1_k_z = 1j * k_grid[2] * inv_k_sq_safe * delta_k\n            \n            psi1_x = np.real(np.fft.ifftn(psi1_k_x))\n            psi1_y = np.real(np.fft.ifftn(psi1_k_y))\n            psi1_z = np.real(np.fft.ifftn(psi1_k_z))\n            psi1 = np.array([psi1_x, psi1_y, psi1_z])\n\n            # 1c. Second-order displacement field Psi^(2)\n            # Find first-order potential phi^(1)\n            phi1_k = -inv_k_sq_safe * delta_k\n            \n            # Find second derivatives of phi^(1)\n            phi1_xx = np.real(np.fft.ifftn(-k_grid[0] * k_grid[0] * phi1_k))\n            phi1_yy = np.real(np.fft.ifftn(-k_grid[1] * k_grid[1] * phi1_k))\n            phi1_zz = np.real(np.fft.ifftn(-k_grid[2] * k_grid[2] * phi1_k))\n            phi1_xy = np.real(np.fft.ifftn(-k_grid[0] * k_grid[1] * phi1_k))\n            phi1_xz = np.real(np.fft.ifftn(-k_grid[0] * k_grid[2] * phi1_k))\n            phi1_yz = np.real(np.fft.ifftn(-k_grid[1] * k_grid[2] * phi1_k))\n\n            # Compute source term S2\n            S2 = ((phi1_xx * phi1_yy) - phi1_xy**2 +\n                  (phi1_xx * phi1_zz) - phi1_xz**2 +\n                  (phi1_yy * phi1_zz) - phi1_yz**2)\n            \n            # Solve for Psi^(2)\n            S2_k = np.fft.fftn(S2)\n            psi2_k_x = 1j * k_grid[0] * inv_k_sq_safe * S2_k\n            psi2_k_y = 1j * k_grid[1] * inv_k_sq_safe * S2_k\n            psi2_k_z = 1j * k_grid[2] * inv_k_sq_safe * S2_k\n            \n            psi2_x = np.real(np.fft.ifftn(psi2_k_x))\n            psi2_y = np.real(np.fft.ifftn(psi2_k_y))\n            psi2_z = np.real(np.fft.ifftn(psi2_k_z))\n            psi2 = np.array([psi2_x, psi2_y, psi2_z])\n\n            computed_fields[A] = (psi1, psi2)\n        \n        psi1, psi2 = computed_fields[A]\n\n        # --- 2. Forward Evolution ---\n        D2_true = -3.0/7.0 * D_true**2 if include_2LPT else 0.0\n        x_pos = q_grid + D_true * psi1 + D2_true * psi2\n\n        # --- 3. Reverse Estimation ---\n        if not subtract_2LPT: # Naive reverse ZA\n            psi1_hat = (x_pos - q_grid) / D_assumed\n        else: # Second-order corrected\n            psi1_hat = (x_pos - q_grid - D2_assumed * psi2) / D_assumed\n\n        # --- 4. Quantify Error ---\n        error_vec = psi1_hat - psi1\n        numerator_sq_sum = np.sum(error_vec**2)\n        denominator_sq_sum = np.sum(psi1**2)\n        \n        if denominator_sq_sum == 0:\n            epsilon = 0.0 if numerator_sq_sum == 0 else np.inf\n        else:\n            epsilon = np.sqrt(numerator_sq_sum / denominator_sq_sum)\n        \n        results.append(epsilon)\n\n    # --- Final Output ---\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "3468288"}, {"introduction": "实际的重建过程总是受到系统误差的影响，这些误差源于我们对宇宙模型的先验假设。本练习聚焦于一个关键的系统误差来源：对哈勃-勒梅特常数 $H_0$ 的假设。您将通过一个简化的贝叶斯线性模型，量化一个不准确的 $H_0$ 先验如何系统性地偏移我们对本动流场和密度场的推断结果，从而理解分析和控制系统误差在约束性模拟中的重要性。[@problem_id:3468244]", "problem": "给定一个简化的、有物理基础的线性模型，用于在哈勃参数先验变化的情况下，对近场本动速度场进行约束重建。该模型将假设的哈勃参数先验 $H_0$ 与晚期均匀各向同性宇宙中的体流矢量 $\\mathbf{v}_{\\mathrm{bulk}}$ 和长波长密度模 $\\delta(k \\to 0)$ 的推断联系起来。目标是从基本方程出发，量化将先验 $H_0$ 在 $\\pm 5\\%$ 范围内改变，会如何使 $\\mathbf{v}_{\\mathrm{bulk}}$ 和 $\\delta(k \\to 0)$ 的后验均值发生偏移。\n\n假设以下基本依据和定义：\n- 标度因子为 $a$ 时的线性化连续性方程为 $\\nabla \\cdot \\mathbf{v}(\\mathbf{r}) = -a\\,H\\,f\\,\\delta(\\mathbf{r})$，其中 $\\mathbf{v}$ 是本动速度场， $H$ 是哈勃参数， $f$ 是线性增长率， $\\delta$ 是物质过密度。\n- 对于空间均匀的过密度 $\\delta(\\mathbf{r}) = \\delta_0$，其散度为常数，无旋解意味着 $\\mathbf{v}(\\mathbf{r}) = -\\dfrac{1}{3} a\\,H\\,f\\,\\delta_0\\,\\mathbf{r}$。在红移 $z \\approx 0$ 时，取 $a = 1$。\n- 低红移处观测到的退行速度为 $v^{z} \\approx H_{\\mathrm{true}}\\,d + u_{r}$，其中 $d$ 是以 $\\mathrm{Mpc}$ 为单位的共动距离， $H_{\\mathrm{true}}$ 是以 $\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ 为单位的真实哈勃参数， $u_{r}$ 是以 $\\mathrm{km\\,s^{-1}}$ 为单位的视线方向本动速度。对于位于位置 $\\mathbf{r}$、单位视线方向矢量为 $\\hat{\\mathbf{n}}$、距离为 $d = \\|\\mathbf{r}\\|$ 的示踪物，其径向本动速度为 $u_{r} = \\hat{\\mathbf{n}}\\cdot\\mathbf{v}_{\\mathrm{bulk}} - \\dfrac{1}{3} H_{\\mathrm{true}} f \\delta_0\\,d$。\n\n数据集包含 $N = 8$ 个示踪物，其共动位置（单位为 $\\mathrm{Mpc}$）如下：\n- $\\mathbf{r}_1 = (10, 0, 0)$，\n- $\\mathbf{r}_2 = (0, 12, 0)$，\n- $\\mathbf{r}_3 = (0, 0, 8)$，\n- $\\mathbf{r}_4 = (-9, 0, 0)$，\n- $\\mathbf{r}_5 = (0, -11, 0)$，\n- $\\mathbf{r}_6 = (0, 0, -7)$，\n- $\\mathbf{r}_7 = (7, 7, 0)$，\n- $\\mathbf{r}_8 = (0, 5, 5)$。\n\n设真实参数为：\n- $H_{\\mathrm{true}} = 70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$，\n- $f = 0.5$ (无量纲)，\n- $\\mathbf{v}_{\\mathrm{bulk,true}} = (100, -50, 30)\\,\\mathrm{km\\,s^{-1}}$，\n- $\\delta_{0,\\mathrm{true}} = 0.03$ (无量纲)。\n\n假设高斯测量噪声的标准差对所有示踪物均为 $\\sigma_i = 50\\,\\mathrm{km\\,s^{-1}}$，且在正向生成合成观测数据时，不添加实际的噪声实现。对每个示踪物 $i$，令 $d_i = \\|\\mathbf{r}_i\\|$ 且 $\\hat{\\mathbf{n}}_i = \\mathbf{r}_i / d_i$。无噪声的观测红移空间速度构建如下\n$$\nv_i^{z} = H_{\\mathrm{true}}\\,d_i + \\hat{\\mathbf{n}}_i \\cdot \\mathbf{v}_{\\mathrm{bulk,true}} - \\frac{1}{3} H_{\\mathrm{true}} f \\delta_{0,\\mathrm{true}} \\, d_i.\n$$\n\n为了在假设的哈勃参数先验 $H_0$ 下推断参数，通过减去假设的哈勃流来定义推断的径向本动速度数据，\n$$\nu_i^{\\mathrm{obs}}(H_0) = v_i^{z} - H_0\\, d_i.\n$$\n在线性理论下，假设相同的 $H_0$ 进入速度-密度耦合，数据的正向模型为\n$$\nu_i^{\\mathrm{model}} = \\hat{\\mathbf{n}}_i \\cdot \\mathbf{v}_{\\mathrm{bulk}} - \\frac{1}{3} H_0 f \\delta_0 \\, d_i.\n$$\n将数据堆叠成矢量 $\\mathbf{y} \\in \\mathbb{R}^N$，并定义设计矩阵 $\\mathbf{A} \\in \\mathbb{R}^{N \\times 4}$、参数矢量 $\\boldsymbol{\\theta} \\in \\mathbb{R}^4$ 和噪声协方差 $\\mathbf{N} \\in \\mathbb{R}^{N \\times N}$ 如下：\n- $\\boldsymbol{\\theta} = (v_x, v_y, v_z, \\delta_0)$，\n- $\\mathbf{A}$ 的前三列是 $\\hat{\\mathbf{n}}_i$ 的分量，第四列的元素为 $-\\dfrac{1}{3} H_0 f d_i$，\n- $\\mathbf{N} = \\mathrm{diag}(\\sigma_1^2,\\ldots,\\sigma_N^2)$。\n\n假设 $\\boldsymbol{\\theta}$ 具有独立的零均值高斯先验和对角协方差 $\\mathbf{\\Sigma}_0 = \\mathrm{diag}(\\sigma_v^2, \\sigma_v^2, \\sigma_v^2, \\sigma_\\delta^2)$，其中 $\\sigma_v = 300\\,\\mathrm{km\\,s^{-1}}$ 且 $\\sigma_\\delta = 0.2$。在高斯似然和高斯先验下，$\\boldsymbol{\\theta}$ 的后验分布是均值为如下的高斯分布\n$$\n\\boldsymbol{\\mu}_{\\mathrm{post}} = \\left(\\mathbf{A}^\\top \\mathbf{N}^{-1} \\mathbf{A} + \\mathbf{\\Sigma}_0^{-1}\\right)^{-1} \\mathbf{A}^\\top \\mathbf{N}^{-1} \\mathbf{y}.\n$$\n\n任务：\n- 使用上述定义，从真实参数一次性构建 $\\{v_i^{z}\\}_{i=1}^N$。\n- 对于测试组中的每个假设的哈勃参数先验 $H_0$，构建 $\\mathbf{y}(H_0)$ 和 $\\mathbf{A}(H_0)$，并计算后验均值 $\\boldsymbol{\\mu}_{\\mathrm{post}}(H_0)$。\n- 定义基线为 $H_0 = 70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$。对每个测试用例，计算：\n  - 相对于基线的后验均值体流矢量偏移的模，$\\|\\mathbf{v}_{\\mathrm{bulk}}(H_0) - \\mathbf{v}_{\\mathrm{bulk}}(70)\\|$，单位为 $\\mathrm{km\\,s^{-1}}$。\n  - 相对于基线的后验均值 $\\delta_0$ 的偏移，$\\delta_0(H_0) - \\delta_0(70)$，无量纲。\n- 以 $\\mathrm{km\\,s^{-1}}$ 表示体流偏移，以无量纲数表示密度偏移。不要在打印输出中包含单位符号；它们必须被理解为在此处指定的单位。\n\n测试组：\n- 用例 1：$H_0 = 70.0\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ (基线，根据构造预期偏移为零)。\n- 用例 2：$H_0 = 73.5\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ (一个 $+5\\%$ 的变化)。\n- 用例 3：$H_0 = 66.5\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ (一个 $-5\\%$ 的变化)。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例对应一个包含体流模偏移和密度偏移的双元素列表。所需格式为\n$[\\,[\\Delta v_1,\\Delta \\delta_1],[\\Delta v_2,\\Delta \\delta_2],[\\Delta v_3,\\Delta \\delta_3]\\,]$,\n其中 $\\Delta v_i$ 的单位是 $\\mathrm{km\\,s^{-1}}$，$\\Delta \\delta_i$ 是无量纲的。例如：$[[0.0,0.0],[12.34,-0.0567],[11.11,0.0555]]$。\n\n您的程序必须是一个完整的、可运行的脚本，无需用户输入，并且必须按照上述规定实现全部计算。", "solution": "该问题要求分析因哈勃参数 $H_0$ 的先验不匹配而导致的推断宇宙学参数——特别是局域体流速度 $\\mathbf{v}_{\\mathrm{bulk}}$ 和长波长密度模 $\\delta_0$——产生的系统性偏移。所提供的框架是一个基于物理宇宙学原理的简化线性模型，在贝叶斯线性回归的背景下求解。解决方案分为四个主要阶段：生成合成观测数据、建立针对不同 $H_0$ 先验的贝叶斯推断模型、计算后验参数估计，以及量化由此产生的系统性偏移。\n\n首先，我们生成一个合成的、无噪声的观测红移空间速度数据集 $\\{v_i^z\\}_{i=1}^N$。这些数据代表了我们在一个由给定真实参数描述的宇宙中所能做出的“真实”观测。对于位于给定共动位置 $\\mathbf{r}_i$ 的 $N=8$ 个示踪物中的每一个，我们计算其共动距离 $d_i = \\|\\mathbf{r}_i\\|$ 和其视线方向单位矢量 $\\hat{\\mathbf{n}}_i = \\mathbf{r}_i / d_i$。观测到的红移空间速度 $v_i^z$ 是哈勃膨胀速度与本动速度沿视线方向投影之和。根据问题陈述，这由下式给出：\n$$\nv_i^{z} = H_{\\mathrm{true}}\\,d_i + u_{r,i}\n$$\n其中 $H_{\\mathrm{true}} = 70\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ 是真实的哈勃参数， $u_{r,i}$ 是径向本动速度。本动速度场被建模为一个均匀体流 $\\mathbf{v}_{\\mathrm{bulk,true}} = (100, -50, 30)\\,\\mathrm{km\\,s^{-1}}$ 和一个由均匀物质过密度 $\\delta_{0,\\mathrm{true}} = 0.03$ 引起的速度分量的叠加。这导致径向本动速度的表达式为：\n$$\nu_{r,i} = \\hat{\\mathbf{n}}_i \\cdot \\mathbf{v}_{\\mathrm{bulk,true}} - \\frac{1}{3} H_{\\mathrm{true}} f \\delta_{0,\\mathrm{true}} \\, d_i\n$$\n这里，线性增长率是 $f=0.5$，我们在红移 $z \\approx 0$ 处进行操作，此时标度因子 $a=1$。将这些结合起来，得到我们合成数据的最终表达式：\n$$\nv_i^{z} = H_{\\mathrm{true}}\\,d_i + \\hat{\\mathbf{n}}_i \\cdot \\mathbf{v}_{\\mathrm{bulk,true}} - \\frac{1}{3} H_{\\mathrm{true}} f \\delta_{0,\\mathrm{true}} \\, d_i\n$$\n这 $N=8$ 个 $v_i^z$ 的值只计算一次，并作为后续推断步骤的固定观测数据。\n\n其次，我们构建贝叶斯推断问题。目标是从数据中推断参数矢量 $\\boldsymbol{\\theta} = (v_x, v_y, v_z, \\delta_0)^\\top$。然而，推断过程假设了一个可能与 $H_{\\mathrm{true}}$ 不同的哈勃参数先验 $H_0$。这个假设的 $H_0$ 既影响了对数据的解释，也影响了物理模型。“观测到的”本动速度是通过减去假设的哈勃流得出的：\n$$\ny_i \\equiv u_i^{\\mathrm{obs}}(H_0) = v_i^{z} - H_0\\, d_i\n$$\n矢量 $\\mathbf{y}(H_0) = (y_1, \\ldots, y_N)^\\top$ 是我们用于回归的数据矢量。预测这些观测值的模型是：\n$$\nu_i^{\\mathrm{model}} = \\hat{\\mathbf{n}}_i \\cdot \\mathbf{v}_{\\mathrm{bulk}} - \\frac{1}{3} H_0 f \\delta_0 \\, d_i\n$$\n这可以写成线性系统 $\\mathbf{y} = \\mathbf{A}\\boldsymbol{\\theta}$ 的形式。设计矩阵 $\\mathbf{A}(H_0) \\in \\mathbb{R}^{N \\times 4}$ 的构造方式是，对于每个示踪物 $i$，对应的行为 $[\\hat{n}_{ix}, \\hat{n}_{iy}, \\hat{n}_{iz}, -\\frac{1}{3} H_0 f d_i]$。数据矢量 $\\mathbf{y}$ 和设计矩阵 $\\mathbf{A}$ 都是所假设的 $H_0$ 的函数。\n\n第三，我们计算参数 $\\boldsymbol{\\theta}$ 的后验均值。问题指定了一个高斯似然，其噪声协方差矩阵为对角矩阵 $\\mathbf{N} = \\mathrm{diag}(\\sigma_1^2, \\ldots, \\sigma_N^2)$，其中每个 $\\sigma_i = 50\\,\\mathrm{km\\,s^{-1}}$。$\\boldsymbol{\\theta}$ 的先验是一个零均值高斯分布，其协方差矩阵为对角矩阵 $\\mathbf{\\Sigma}_0 = \\mathrm{diag}(\\sigma_v^2, \\sigma_v^2, \\sigma_v^2, \\sigma_\\delta^2)$，其中 $\\sigma_v = 300\\,\\mathrm{km\\,s^{-1}}$，$\\sigma_\\delta = 0.2$。对于具有高斯先验和高斯似然的贝叶斯线性模型，后验分布也是高斯的。其均值代表了我们对参数的最佳估计，由标准公式给出：\n$$\n\\boldsymbol{\\mu}_{\\mathrm{post}}(H_0) = \\left(\\mathbf{A}(H_0)^\\top \\mathbf{N}^{-1} \\mathbf{A}(H_0) + \\mathbf{\\Sigma}_0^{-1}\\right)^{-1} \\mathbf{A}(H_0)^\\top \\mathbf{N}^{-1} \\mathbf{y}(H_0)\n$$\n我们为三个指定的 $H_0$ 值分别计算这个后验均值矢量 $\\boldsymbol{\\mu}_{\\mathrm{post}}(H_0)$：基线 $H_0 = 70.0\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$、正向变化的 $H_0 = 73.5\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$ 和负向变化的 $H_0 = 66.5\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$。每种情况下得到的矢量包含推断出的参数，即 $\\boldsymbol{\\mu}_{\\mathrm{post}} = (\\hat{v}_x, \\hat{v}_y, \\hat{v}_z, \\hat{\\delta}_0)^\\top$。\n\n最后，我们量化推断参数相对于基线情况（$H_0 = 70.0\\,\\mathrm{km\\,s^{-1}\\,Mpc^{-1}}$）的偏移。令 $\\boldsymbol{\\mu}_{\\mathrm{post}}(70) = (\\mathbf{v}_{\\mathrm{bulk}}(70), \\delta_0(70))^\\top$ 为基线的后验均值。对于每个给定 $H_0$ 的测试用例，我们计算其后验均值 $\\boldsymbol{\\mu}_{\\mathrm{post}}(H_0) = (\\mathbf{v}_{\\mathrm{bulk}}(H_0), \\delta_0(H_0))^\\top$。体流的偏移是推断速度矢量之差的欧几里得范数：\n$$\n\\Delta v = \\|\\mathbf{v}_{\\mathrm{bulk}}(H_0) - \\mathbf{v}_{\\mathrm{bulk}}(70)\\|\n$$\n密度参数的偏移是简单的算术差：\n$$\n\\Delta \\delta = \\delta_0(H_0) - \\delta_0(70)\n$$\n对于基线情况本身（$H_0=70$），这些偏移根据定义为零。对于另外两种情况，这些偏移量化了因假设哈勃参数存在 $\\pm 5\\%$ 误差而引入参数推断的系统误差。数值实现将涉及使用 NumPy 构建指定的矢量和矩阵，并为每种情况求解矩阵方程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cosmological inference problem as specified.\n    \"\"\"\n\n    # 1. Define Givens and Constants\n    # Tracer positions in Mpc\n    r_tracers = np.array([\n        [10.0, 0.0, 0.0],\n        [0.0, 12.0, 0.0],\n        [0.0, 0.0, 8.0],\n        [-9.0, 0.0, 0.0],\n        [0.0, -11.0, 0.0],\n        [0.0, 0.0, -7.0],\n        [7.0, 7.0, 0.0],\n        [0.0, 5.0, 5.0]\n    ])\n    num_tracers = r_tracers.shape[0]\n\n    # True cosmological parameters\n    H_true = 70.0  # km/s/Mpc\n    f_growth = 0.5  # dimensionless\n    v_bulk_true = np.array([100.0, -50.0, 30.0])  # km/s\n    delta_0_true = 0.03  # dimensionless\n    theta_true = np.array([100.0, -50.0, 30.0, 0.03])\n\n    # Measurement and prior standard deviations\n    sigma_noise = 50.0  # km/s\n    sigma_v_prior = 300.0  # km/s\n    sigma_delta_prior = 0.2  # dimensionless\n\n    # Test suite for H0\n    H0_cases = [70.0, 73.5, 66.5]  # km/s/Mpc\n\n    # 2. Generate Synthetic Observational Data\n    # Calculate geometric quantities for tracers\n    dists = np.linalg.norm(r_tracers, axis=1)\n    n_hats = r_tracers / dists[:, np.newaxis]\n\n    # Calculate true radial peculiar velocities\n    u_r_true = n_hats @ v_bulk_true - (1.0/3.0) * H_true * f_growth * delta_0_true * dists\n\n    # Calculate noiseless observed redshift-space velocities (v_z)\n    v_z = H_true * dists + u_r_true\n\n    # 3. Setup Inference Covariance Matrices (constant across cases)\n    # Noise covariance matrix (and its inverse)\n    N_inv = np.diag(np.full(num_tracers, 1.0 / sigma_noise**2))\n\n    # Prior covariance matrix (and its inverse)\n    prior_variances = np.array([sigma_v_prior**2, sigma_v_prior**2, sigma_v_prior**2, sigma_delta_prior**2])\n    Sigma0_inv = np.diag(1.0 / prior_variances)\n\n    # 4. Perform Bayesian Inference for Each H0 Case\n    posterior_means = []\n    for H0 in H0_cases:\n        # Construct data vector y(H0)\n        y = v_z - H0 * dists\n\n        # Construct design matrix A(H0)\n        A = np.zeros((num_tracers, 4))\n        A[:, 0:3] = n_hats\n        A[:, 3] = -(1.0/3.0) * H0 * f_growth * dists\n\n        # Calculate posterior mean using the provided formula\n        # Posterior precision matrix P = A^T N^-1 A + Sigma_0^-1\n        A_T_N_inv = A.T @ N_inv\n        P = A_T_N_inv @ A + Sigma0_inv\n        \n        # Inverse of posterior precision matrix is posterior covariance\n        P_inv = np.linalg.inv(P)\n\n        # Posterior mean mu_post = P^-1 A^T N^-1 y\n        mu_post = P_inv @ A_T_N_inv @ y\n        posterior_means.append(mu_post)\n\n    # 5. Calculate shifts relative to the baseline (H0 = 70)\n    mu_baseline = posterior_means[0]\n    v_bulk_baseline = mu_baseline[0:3]\n    delta_0_baseline = mu_baseline[3]\n\n    results = []\n    for mu_post in posterior_means:\n        v_bulk_post = mu_post[0:3]\n        delta_0_post = mu_post[3]\n\n        # Magnitude of the shift in the bulk flow vector\n        delta_v_mag = np.linalg.norm(v_bulk_post - v_bulk_baseline)\n\n        # Shift in the density mode\n        delta_delta = delta_0_post - delta_0_baseline\n\n        results.append([delta_v_mag, delta_delta])\n    \n    # 6. Format and Print Final Output\n    # Create the final string representation as required.\n    # e.g., [[0.0,0.0],[12.34,-0.0567],[11.11,0.0555]]\n    # Using f-strings and a loop to format numbers to a reasonable precision\n    result_str = \",\".join([f\"[{v:.4f},{d:.4f}]\" for v, d in results])\n    \n    # Per problem spec, the first case should be exactly [0.0, 0.0]\n    # Small floating point errors might make it non-zero. Let's enforce it.\n    results[0] = [0.0, 0.0]\n    final_output_str = f\"[[{results[0][0]},{results[0][1]}],\"\n    final_output_str += \",\".join([f\"[{v},{d}]\" for v, d in results[1:]])\n    final_output_str += \"]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "3468244"}]}