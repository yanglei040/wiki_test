{"hands_on_practices": [{"introduction": "将连续的偏微分方程（PDEs）转化为计算机可以求解的代数方程组，是进行数值模拟的第一步。这个过程被称为离散化，而有限差分法是其中最基础的技术之一。本练习 [@problem_id:3487331] 将引导你推导拉普拉斯算子的经典七点差分格式，这是求解 $f(R)$ 引力中标量场方程的核心，掌握这一基本功是构建所有基于网格的求解器的基础。", "problem": "考虑一种 $f(R)$ 型修正引力理论的准静态、亚视界极限，其中标量场 $f_{R}$ 遵循一个与物质密度衬度耦合的椭圆型偏微分方程（PDE）。在具有尺度因子 $a$ 的共动笛卡尔坐标 $\\boldsymbol{x}=(x,y,z)$ 中，该方程的形式为\n$$\n\\nabla^{2} f_{R}(\\boldsymbol{x}) \\;=\\; \\frac{a^{2}}{3}\\Big[\\,\\delta R\\big(f_{R}(\\boldsymbol{x})\\big) \\;-\\; 8\\pi G\\,\\delta\\rho(\\boldsymbol{x})\\,\\Big],\n$$\n其中 $\\delta R\\big(f_{R}\\big)$ 表示作为 $f_{R}$ 的局域泛函的里奇标量（Ricci scalar）的微扰，$G$ 是牛顿引力常数，而 $\\delta\\rho$ 是物质密度微扰。\n\n你将在一个均匀的三维笛卡尔网格上离散化该方程，该网格代表一个具有固定 $a$ 的单一宇宙学时间切片。设网格由点 $\\boldsymbol{x}_{i,j,k}=(x_{i},y_{j},z_{k})$ 定义，其均匀间距为 $\\Delta x=\\Delta y=\\Delta z=h$，并令 $f_{R\\,i,j,k}$ 表示 $f_{R}$ 在网格点 $(i,j,k)$ 处的值。类似地，定义 $\\delta\\rho_{i,j,k}$ 并将 $\\delta R$ 局域地计算为 $\\delta R\\!\\big(f_{R\\,i,j,k}\\big)$。\n\n从笛卡尔坐标中拉普拉斯算子的定义以及均匀网格上光滑函数的泰勒展开出发，推导在内部网格点 $(i,j,k)$ 处拉普拉斯算子 $\\nabla^{2} f_{R}$ 的二阶精确中心有限差分模板。仅使用导数和泰勒展开的基本定义来确定你所用模板的精度阶数。然后，使用你的拉普拉斯近似以及 $\\delta R$ 和 $\\delta\\rho$ 的局域计算值，写出在 $(i,j,k)$ 点的离散化椭圆方程。\n\n你的最终答案必须是给出在 $(i,j,k)$ 点处 $\\nabla^{2} f_{R}$ 的二阶精确有限差分模板的单一、闭合形式的解析表达式。无需单位。不要四舍五入；给出精确的符号表达式。", "solution": "出发点是笛卡尔坐标中拉普拉斯算子的定义，\n$$\n\\nabla^{2} f_{R} \\;=\\; \\frac{\\partial^{2} f_{R}}{\\partial x^{2}} \\;+\\; \\frac{\\partial^{2} f_{R}}{\\partial y^{2}} \\;+\\; \\frac{\\partial^{2} f_{R}}{\\partial z^{2}}.\n$$\n在每个方向上间距为 $h$ 的均匀网格上，我们通过使用从泰勒展开导出的中心有限差分公式来构造每个二阶导数的二阶精确近似。\n\n考虑一个定义在均匀点 $x_{i}=x_{0}+i h$ 上的一维光滑函数 $g$。关于 $x_{i}$ 的泰勒展开式为\n\\begin{align*}\ng(x_{i}+h) = g(x_{i}) \\;+\\; h\\,g'(x_{i}) \\;+\\; \\frac{h^{2}}{2}\\,g''(x_{i}) \\;+\\; \\frac{h^{3}}{6}\\,g^{(3)}(x_{i}) \\;+\\; \\frac{h^{4}}{24}\\,g^{(4)}(\\xi_{+}), \\\\\ng(x_{i}-h) = g(x_{i}) \\;-\\; h\\,g'(x_{i}) \\;+\\; \\frac{h^{2}}{2}\\,g''(x_{i}) \\;-\\; \\frac{h^{3}}{6}\\,g^{(3)}(x_{i}) \\;+\\; \\frac{h^{4}}{24}\\,g^{(4)}(\\xi_{-}),\n\\end{align*}\n其中 $\\xi_{+}$ 和 $\\xi_{-}$ 分别位于区间 $(x_{i},x_{i}+h)$ 和 $(x_{i}-h,x_{i})$ 内。将这两个展开式相加并减去 $2 g(x_{i})$ 得到\n$$\ng(x_{i}+h) - 2 g(x_{i}) + g(x_{i}-h) \\;=\\; h^{2} g''(x_{i}) \\;+\\; \\frac{h^{4}}{12}\\,g^{(4)}(\\xi),\n$$\n其中 $\\xi$ 位于 $x_{i}-h$ 和 $x_{i}+h$ 之间。两边除以 $h^{2}$ 得到二阶导数的中心差分近似，\n$$\n\\frac{g(x_{i}+h) - 2 g(x_{i}) + g(x_{i}-h)}{h^{2}} \\;=\\; g''(x_{i}) \\;+\\; \\mathcal{O}\\!\\left(h^{2}\\right).\n$$\n这表明中心二阶差分是二阶精确的。\n\n将此构造独立地应用于每个笛卡尔方向上的 $f_{R}$。记 $f_{R\\,i,j,k} \\equiv f_{R}(x_{i},y_{j},z_{k})$。那么\n\\begin{align*}\n\\frac{\\partial^{2} f_{R}}{\\partial x^{2}}\\bigg|_{(i,j,k)} \\approx \\frac{f_{R\\,i+1,j,k} - 2 f_{R\\,i,j,k} + f_{R\\,i-1,j,k}}{h^{2}}, \\\\\n\\frac{\\partial^{2} f_{R}}{\\partial y^{2}}\\bigg|_{(i,j,k)} \\approx \\frac{f_{R\\,i,j+1,k} - 2 f_{R\\,i,j,k} + f_{R\\,i,j-1,k}}{h^{2}}, \\\\\n\\frac{\\partial^{2} f_{R}}{\\partial z^{2}}\\bigg|_{(i,j,k)} \\approx \\frac{f_{R\\,i,j,k+1} - 2 f_{R\\,i,j,k} + f_{R\\,i,j,k-1}}{h^{2}}.\n\\end{align*}\n将这三个近似值相加，得到均匀笛卡尔网格上拉普拉斯算子的标准二阶精确七点有限差分模板：\n$$\n\\nabla^{2} f_{R}\\big|_{(i,j,k)} \\;\\approx\\; \\frac{f_{R\\,i+1,j,k} + f_{R\\,i-1,j,k} + f_{R\\,i,j+1,k} + f_{R\\,i,j-1,k} + f_{R\\,i,j,k+1} + f_{R\\,i,j,k-1} - 6 f_{R\\,i,j,k}}{h^{2}},\n$$\n其截断误差为 $\\mathcal{O}\\!\\left(h^{2}\\right)$，继承自一维二阶导数近似。\n\n为了离散化椭圆标量场方程，我们在 $(i,j,k)$ 点局域地计算右侧项，使用函数依赖关系 $\\delta R\\!\\big(f_{R\\,i,j,k}\\big)$ 和采样的密度衬度 $\\delta\\rho_{i,j,k}$。在内部网格点处的离散方程为\n$$\n\\frac{f_{R\\,i+1,j,k} + f_{R\\,i-1,j,k} + f_{R\\,i,j+1,k} + f_{R\\,i,j-1,k} + f_{R\\,i,j,k+1} + f_{R\\,i,j,k-1} - 6 f_{R\\,i,j,k}}{h^{2}}\n\\;=\\;\n\\frac{a^{2}}{3}\\Big[\\,\\delta R\\!\\big(f_{R\\,i,j,k}\\big) \\;-\\; 8\\pi G\\,\\delta\\rho_{i,j,k}\\,\\Big],\n$$\n对于光滑的 $f_{R}$，该方程在 $h$ 上是二阶精确的。\n\n所要求的最终表达式，即在 $(i,j,k)$ 点处 $\\nabla^{2} f_{R}$ 的二阶精确有限差分模板，是上面所示的分子除以 $h^{2}$。", "answer": "$$\\boxed{\\frac{f_{R\\,i+1,j,k}+f_{R\\,i-1,j,k}+f_{R\\,i,j+1,k}+f_{R\\,i,j-1,k}+f_{R\\,i,j,k+1}+f_{R\\,i,j,k-1}-6 f_{R\\,i,j,k}}{h^{2}}}$$", "id": "3487331"}, {"introduction": "修正引力理论中的场方程通常是高度非线性的，这使得它们的求解比线性方程要困难得多。解决这类问题需要复杂的数值技术，而牛顿-多重网格方法是处理这类非线性椭圆型偏微分方程的强大且高效的前沿算法。这项实践 [@problem_id:3487385] 将指导你构建一个完整的牛顿-多重网格求解器，体验处理从逐次线性化（牛顿法）到在多层网格上高效求解线性系统（多重网格V循环）的全部复杂过程。", "problem": "考虑一个无量纲标量场方程，该方程代表方形域上度规 $f(R)$ 引力在 $f_{R}$ 标量场下的准静态极限。令 $u(x,y)$ 表示无量纲场 $u \\equiv f_{R} / \\bar{f}_{R}$，其中 $\\bar{f}_{R}$ 是一个均匀背景值。在与宇宙学结构形成相关的高曲率区域，修正的爱因斯坦方程的迹给出了一个示意形式为\n$$\n\\nabla^{2} u = \\kappa \\left( u^{-n} - 1 \\right) + s(x,y),\n$$\n的非线性椭圆偏微分方程 (PDE)，其中 $\\kappa  0$ 是一个无量纲耦合常数，表示对广义相对论修正的强度；$n  0$ 控制非线性程度；$s(x,y)$ 是一个与物质密度扰动成正比的无量纲源项。假设单位方形域 $[0,1] \\times [0,1]$，在边界 $\\partial \\Omega$ 上具有狄利克雷边界条件 $u = 1$。任何三角函数内的角度都必须解释为弧度。\n\n从基本原理和经过充分测试的数值方法出发，为该非线性椭圆偏微分方程构建一个牛顿-多重网格V循环求解器。设计必须从以下几点开始：\n- 椭圆算子的定义以及在均匀网格上对 $\\nabla^{2}$ 的有限差分近似。\n- 将牛顿法（也称为牛顿-拉夫逊法）应用于非线性残差，以产生一系列线性化的修正问题。\n- 在每个牛顿步中，使用多重网格V循环来近似求解线性化系统 $J(u) \\, \\delta u = -R(u)$，其中 $R(u)$ 是离散非线性残差，$J(u)$ 是离散化算子的雅可比矩阵。\n\n你的构建必须明确说明：\n1. 使用二阶中心有限差分近似在大小为 $N \\times N$、间距为 $h$ 的均匀网格上，对于边界节点上的狄利克雷边界条件 $u=1$，离散残差 $R(u)$ 的形式。\n2. 针对局部非线性项的雅可比矩阵组装，包括其关于 $u$ 的导数的解析表达式，该导数项贡献于 $J(u)$ 的对角线。\n3. 在每个网格层级上用作线性化系统平滑器的松弛方案。使用加权 Jacobi 方法，松弛参数为 $\\omega \\in (0,1)$。\n4. 粗网格校正，包括：\n   - 将残差完全加权限制到下一个更粗的网格。\n   - 将粗网格校正双线性延长回更细的网格。\n   - 在粗网格上使用限制后的 $u$ 进行重新线性化，以一致地组装粗网格雅可比矩阵的对角线。\n5. 基于残差缩减的稳健收敛准则。令 $\\| R(u) \\|_{2}$ 表示使用网格间距 $h$ 计算的离散 $L^{2}$ 范数。定义初始猜测 $u^{(0)}$ 处的初始残差范数 $\\| R(u^{(0)}) \\|_{2}$。如果以下两个条件都满足，则认为牛顿迭代收敛：\n   - 缩减比 $\\rho \\equiv \\| R(u^{(k)}) \\|_{2} / \\| R(u^{(0)}) \\|_{2}$ 满足 $\\rho \\le \\theta$，其中 $\\theta$ 是预设阈值。\n   - 绝对残差范数满足 $\\| R(u^{(k)}) \\|_{2} \\le \\varepsilon$，其中 $\\varepsilon$ 是预设容差。\n使用最大牛顿迭代次数以防止无限循环。实现简单的线搜索或步长阻尼，以在更新过程中保持内部节点上 $u$ 的正性。\n\n离散化要求：\n- 使用大小为 $N \\times N$ 的均匀网格，其中 $N = 2^{\\ell} + 1$，整数 $\\ell \\ge 3$，以便可以进行标准粗化，直至 $3 \\times 3$ 的网格。\n- 在内部节点上使用二阶中心有限差分近似 $\\nabla^{2}$，离散模板为 $[1,1,-4,1,1]/h^{2}$。\n- 源项 $s(x,y)$ 必须指定为\n$$\ns(x,y) = A \\left[ \\sin(2\\pi x) \\sin(2\\pi y) + \\tfrac{1}{4} \\sin(4\\pi x) \\sin(2\\pi y) \\right],\n$$\n其中振幅 $A$ 是一个无量纲标量。角度以弧度为单位。\n\n牛顿-多重网格规格：\n- 雅可比矩阵 $J(u)$ 是离散拉普拉斯算子与非线性项导数对角线贡献之和。对于非线性项 $\\kappa(u^{-n} - 1)$，其关于 $u$ 的导数为 $-\\kappa n u^{-n-1}$，这在网格上贡献了一个逐点的对角项。在需要时，通过将 $u$ 计算为 $\\max(u,\\epsilon)$，使用一个小的正数 $\\epsilon$ 来避免在 $u^{-n}$ 和 $u^{-n-1}$ 中除以零。\n- 使用带松弛因子 $\\omega$ 的加权 Jacobi 平滑，并在每个层级上进行固定次数 $\\nu_{1}$ 的预平滑迭代和 $\\nu_{2}$ 的后平滑迭代。\n- 对网格间传输使用完全加权限制和双线性延长。\n- 在最粗的层级上，通过在该网格上进行额外的松弛迭代来替代粗网格求解。\n\n收敛准则和输出：\n- 将残差的离散 $L^{2}$ 范数计算为\n$$\n\\| R(u) \\|_{2} = \\left( h^{2} \\sum_{i,j} R(u)_{i,j}^{2} \\right)^{1/2}。\n$$\n- 对于每个测试用例，报告求解器是否在最大牛顿迭代次数内满足收敛准则（$\\rho \\le \\theta$ 和 $\\| R(u) \\|_{2} \\le \\varepsilon$）。每个用例的输出必须是一个布尔值，$\\mathrm{True}$ 表示成功收敛，$\\mathrm{False}$ 表示未收敛。\n\n测试套件：\n提供一个程序，为以下参数集运行求解器。在所有情况下，都施加狄利克雷边界条件 $u=1$，初始猜测为 $u^{(0)} \\equiv 1$，$s(x,y)$ 中的角度以弧度为单位，最终输出必须是单行，包含用方括号括起来的逗号分隔的结果列表。\n\n- 情况 1 (典型情况): $N=65$, $\\kappa=1.0$, $n=1.0$, $A=0.1$, $\\omega=0.8$, $\\nu_{1}=3$, $\\nu_{2}=3$, 最大牛顿迭代次数 $=20$, $\\theta=10^{-6}$, $\\varepsilon=10^{-8}$。\n- 情况 2 (更强的非线性): $N=33$, $\\kappa=2.0$, $n=2.0$, $A=0.3$, $\\omega=0.75$, $\\nu_{1}=4$, $\\nu_{2}=4$, 最大牛顿迭代次数 $=25$, $\\theta=10^{-6}$, $\\varepsilon=10^{-8}$。\n- 情况 3 (近线性区域): $N=65$, $\\kappa=0.2$, $n=1.0$, $A=0.05$, $\\omega=0.8$, $\\nu_{1}=3$, $\\nu_{2}=3$, 最大牛顿迭代次数 $=15$, $\\theta=10^{-7}$, $\\varepsilon=10^{-9}$。\n- 情况 4 (更粗的网格，中等非线性): $N=17$, $\\kappa=1.5$, $n=1.5$, $A=0.2$, $\\omega=0.7$, $\\nu_{1}=4$, $\\nu_{2}=4$, 最大牛顿迭代次数 $=20$, $\\theta=10^{-6}$, $\\varepsilon=10^{-8}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[b_{1},b_{2},b_{3},b_{4}]$），其中每个 $b_{i}$ 是一个布尔值，表示相应测试用例的收敛情况。", "solution": "用户要求为在 $f(R)$ 引力背景下产生的非线性椭圆偏微分方程 (PDE) 构建一个牛顿-多重网格求解器。我将首先验证问题陈述，如果有效，则提出数值算法的原理推导，然后是完整的实现。\n\n### 问题验证\n\n**第1步：提取已知条件**\n\n-   **偏微分方程**: $\\nabla^{2} u = \\kappa \\left( u^{-n} - 1 \\right) + s(x,y)$。\n-   **参数**: $\\kappa > 0$, $n > 0$。\n-   **场**: $u(x,y)$。\n-   **域**: $\\Omega = [0,1] \\times [0,1]$。\n-   **边界条件 (BC)**: 狄利克雷, $u=1$ on $\\partial \\Omega$。\n-   **源项**: $s(x,y) = A \\left[ \\sin(2\\pi x) \\sin(2\\pi y) + \\tfrac{1}{4} \\sin(4\\pi x) \\sin(2\\pi y) \\right]$，角度参数以弧度为单位。\n-   **离散化**:\n    -   网格: 均匀 $N \\times N$, $N = 2^{\\ell} + 1$ for $\\ell \\ge 3$。\n    -   网格间距: $h = 1/(N-1)$。\n    -   拉普拉斯算子近似: 二阶中心有限差分, 模板 $[1,1,-4,1,1]/h^2$。\n-   **求解方法**: 牛顿-多重网格V循环。\n    -   **牛顿法**: 求解线性化系统 $J(u) \\, \\delta u = -R(u)$ 以获得修正量 $\\delta u$。\n    -   **非线性残差, $R(u)$**: $\\nabla^2 u - \\kappa(u^{-n}-1) - s(x,y)$ 的离散形式。\n    -   **雅可比矩阵, $J(u)$**: $J(u) = \\text{Laplacian}_h - \\text{diag}(\\kappa n u^{-n-1})$。问题描述中导数有误，应为$-\\kappa n u^{-n-1}$。包括正则化 $u \\rightarrow \\max(u, \\epsilon)$。\n    -   **线搜索**: 简单的步长阻尼以保持 $u > 0$。\n-   **多重网格组件**:\n    -   **平滑器**: 带松弛因子 $\\omega$ 的加权 Jacobi。\n    -   **扫描次数**: $\\nu_1$ 次预平滑，$\\nu_2$ 次后平滑迭代。\n    -   **网格传输**: 完全加权限制，双线性延长。\n    -   **最粗网格**: 通过额外的松弛迭代求解。\n    -   **粗网格算子**: 使用限制后的解 $u_c$ 进行重新线性化。\n-   **收敛准则**:\n    -   相对残差缩减: $\\| R(u^{(k)}) \\|_{2} / \\| R(u^{(0)}) \\|_{2} \\le \\theta$。\n    -   绝对残差容差: $\\| R(u^{(k)}) \\|_{2} \\le \\varepsilon$。\n    -   最大牛顿迭代次数。\n-   **$L^2$ 范数定义**: $\\| R(u) \\|_{2} = \\left( h^{2} \\sum_{i,j} R(u)_{i,j}^{2} \\right)^{1/2}$ 在内部节点上。\n-   **初始猜测**: $u^{(0)} \\equiv 1$。\n-   **测试用例**: 提供了四个不同的参数集。\n\n**第2步：使用提取的已知条件进行验证**\n\n该问题具有**科学依据**，描述了一种用于现代宇宙学（$f(R)$ 引力）中简化模型的标准数值方法。该偏微分方程是一种著名的非线性椭圆方程（Lane-Emden-Fowler 类型）。问题是**适定的**；带有狄利克雷边界条件的方程预期有唯一解，并且数值策略是牛顿法（用于非线性）和多重网格（用于得到的线性系统）的标准而稳健的组合（也可以使用全近似方案或 FAS，但指定的牛顿-多重网格方法同样有效）。语言是**客观的**，所有参数、方法和准则都以数学精度进行了陈述。\n\n在问题描述的“牛顿-多重网格规格”部分，雅可比矩阵的导数项被误写为$+\\kappa n u^{-n-1}$。对于非线性项 $f(u) = -\\kappa(u^{-n}-1)$，其导数 $df/du$ 是 $(-\\kappa)(-n)u^{-n-1} = +\\kappa n u^{-n-1}$。然而，残差定义为 $R(u) = \\nabla^2 u - \\kappa(u^{-n}-1) - s$。因此，$\\partial R / \\partial u_{ij}$ 贡献的对角项是 $-\\partial(\\kappa(u^{-n}-1))/\\partial u_{ij}$，即 $-\\kappa(-n)u_{ij}^{-n-1} = +\\kappa n u_{ij}^{-n-1}$。因此，雅可比作用于 $\\delta u$ 的对角部分应为 $(\\nabla_h^2 \\delta u)_{i,j} + (\\kappa n u_{i,j}^{-n-1}) \\delta u_{i,j}$。问题中的描述是“关于u的导数为...贡献于J(u)的对角线”，这是正确的，但给出的导数$-\\kappa n u^{-n-1}$是错误的。雅可比的对角线是离散拉普拉斯算子的对角线（$-4/h^2$）加上非线性项的导数。非线性项是 $-\\kappa(u^{-n}-1)$，它的导数是 $\\kappa n u^{-n-1}$。所以雅可比对角线是 $-4/h^2 + \\kappa n u^{-n-1}$。该问题中的描述在符号上有混淆，但实现将遵循正确的数学推导。\n\n**第3步：结论与行动**\n\n问题**有效**。将构建一个解决方案。\n\n### 算法构建\n\n问题的核心是找到满足该偏微分方程的解 $u(x,y)$。我们将使用有限差分离散化，并使用牛顿法求解得到的非线性代数方程组，其中每个线性步骤都由多重网格V循环加速。\n\n**1. 离散化与非线性残差**\n\n我们定义一个均匀网格，点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, \\dots, N-1\\}$，$h=1/(N-1)$。令 $u_{i,j} \\approx u(x_i, y_j)$。该偏微分方程可以重写为残差方程 $R(u) = 0$，其中\n$$\nR(u) \\equiv \\nabla^2 u - \\kappa(u^{-n} - 1) - s(x,y) = 0.\n$$\n对拉普拉斯算子使用二阶中心有限差分近似，内部节点 $(i,j)$ 的离散残差为：\n$$\nR(u)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} - \\kappa\\left(u_{i,j}^{-n} - 1\\right) - s_{i,j} = 0.\n$$\n对于边界节点，$u_{i,j}=1$，残差未定义。我们寻求一个网格函数 $u$，使得所有内部节点 $i,j \\in \\{1, \\dots, N-2\\}$ 的 $R(u)_{i,j}=0$。\n\n**2. 针对非线性系统的牛顿法**\n\n牛顿法迭代地寻找 $R(u)=0$ 的根。给定一个近似解 $u^{(k)}$，通过求解线性化系统来找到下一个近似解 $u^{(k+1)} = u^{(k)} + \\delta u$：\n$$\nR(u^{(k+1)}) \\approx R(u^{(k)}) + J(u^{(k)}) \\delta u = 0,\n$$\n其中 $J(u)$ 是 $R(u)$ 的雅可比矩阵。这导出了修正量 $\\delta u$ 的线性系统：\n$$\nJ(u^{(k)}) \\delta u = -R(u^{(k)}).\n$$\n雅可比矩阵是偏导数矩阵，$J_{ab} = \\partial R_a / \\partial u_b$，其中 $a$ 和 $b$ 是网格点的索引。该算子由两部分组成：离散拉普拉斯算子和非线性项的导数。非线性项 $-\\kappa(u^{-n}-1)$ 关于点 $(i,j)$ 处的 $u$ 的导数是 $+\\kappa n u_{i,j}^{-n-1}$。因此，雅可比矩阵作用在网格函数 $\\delta u$ 上的结果是：\n$$\n(J(u)\\delta u)_{i,j} = (\\nabla_h^2 \\delta u)_{i,j} + \\left(\\kappa n u_{i,j}^{-n-1}\\right) \\delta u_{i,j}.\n$$\n在解出 $\\delta u$ 后，我们用一个带阻尼的步长更新解：$u^{(k+1)} = u^{(k)} + \\alpha \\delta u$，其中 $\\alpha \\in (0,1]$ 是一个阻尼因子，选择它以确保所有内部节点的 $u^{(k+1)}_{i,j} > 0$。\n\n**3. 针对线性系统的多重网格V循环**\n\n在每个牛顿步中，我们必须求解形如 $Ax=b$ 的线性系统，其中 $A=J(u^{(k)})$，$x=\\delta u$，$b=-R(u^{(k)})$。这通过使用几何多重网格方法的一个V循环来近似完成。\n\n一个V循环由以下递归步骤组成，从细网格（层级 $\\ell$）移动到粗网格（层级 $\\ell-1$）：\n\n1.  **预平滑**: 对当前网格上的系统 $Ax=b$ 应用 $\\nu_1$ 次平滑器（加权 Jacobi）迭代，以获得一个近似解 $x'$。对于一个通用线性系统 $Ax=b$，加权 Jacobi 迭代是：\n    $$\n    x^{(m+1)} = (1-\\omega)x^{(m)} + \\omega D^{-1}(b - (A-D)x^{(m)}),\n    $$\n    其中 $D$ 是 $A$ 的对角线。对于我们的特定雅可比矩阵 $J(u)$，对角线元素是 $J_{ii} = -4/h^2 + \\kappa n u_{i,j}^{-n-1}$。\n\n2.  **粗网格校正**:\n    -   计算线性系统的残差：$r' = b - Ax'$。\n    -   将残差限制到下一个更粗的网格：$r_c = \\mathcal{R}(r')$。我们使用**完全加权限制**，即一个 $3\\times3$ 细网格点块的加权平均。\n    -   粗网格上的问题是 $A_c e_c = r_c$，其中 $e_c$ 是误差 $e' = x-x'$ 的粗网格表示。我们必须在粗网格上**重新线性化**。这意味着我们限制当前的非线性解 $u$ 得到 $u_c = \\mathcal{R}(u)$，然后组装粗网格算子 $A_c = J(u_c)$。\n    -   通过在粗网格上调用V循环来递归地求解 $A_c e_c = r_c$。在最粗的层级上（一个 $3\\times3$ 网格），通过应用更多次数的平滑迭代来求解该系统。\n    -   将误差校正延长回细网格：$e' = \\mathcal{P}(e_c)$。我们使用**双线性延长（插值）**。\n    -   校正细网格解：$x'' = x' + e'$。\n\n3.  **后平滑**: 以 $x''$ 为初始猜测，对 $Ax=b$ 应用 $\\nu_2$ 次平滑器迭代，以获得此层级的最终近似解。\n\n**4. 收敛准则**\n\n当非线性残差 $R(u^{(k)})$ 的 $L^2$ 范数足够小时，外部牛顿循环终止。离散 $L^2$ 范数定义为 $\\|R(u)\\|_{2} = \\sqrt{h^2 \\sum_{i,j} (R(u)_{i,j})^2}$。必须满足两个条件：\n1.  相对缩减：当前残差范数与初始残差范数的比率 $\\rho = \\|R(u^{(k)})\\|_2 / \\|R(u^{(0)})\\|_2$ 必须小于阈值 $\\theta$。\n2.  绝对容差：当前残差范数 $\\|R(u^{(k)})\\|_2$ 必须小于容差 $\\varepsilon$。\n也强制执行最大迭代次数以防止不终止。每个测试用例的布尔结果反映了是否满足这些准则。", "answer": "```python\nimport numpy as np\nfrom math import log2\n\n# A small constant to prevent division by zero in u^(-n) terms.\nU_EPSILON = 1e-12\n\ndef _create_levels_data(N_finest):\n    \"\"\"Creates a list of dictionaries holding data for each grid level.\"\"\"\n    if N_finest  3 or log2(N_finest - 1) != int(log2(N_finest - 1)):\n        raise ValueError(\"N must be of the form 2**l + 1 for integer l >= 1.\")\n    l_finest = int(log2(N_finest - 1))\n    levels_data = []\n    # Levels go from finest (l_finest) down to coarsest (l=1, N=3)\n    for l in range(l_finest, 0, -1):\n        N = 2**l + 1\n        h = 1.0 / (N - 1)\n        levels_data.append({'N': N, 'h': h})\n    return levels_data\n\ndef _setup_source_term(N, A):\n    \"\"\"Initializes the source term s(x,y) on the grid.\"\"\"\n    x_coords = np.linspace(0.0, 1.0, N)\n    xx, yy = np.meshgrid(x_coords, x_coords)\n    s = A * (np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy) + 0.25 * np.sin(4 * np.pi * xx) * np.sin(2 * np.pi * yy))\n    return s\n\ndef _calculate_residual(u, s, h, kappa, n):\n    \"\"\"Calculates the nonlinear residual R(u) on the interior of the grid.\"\"\"\n    res = np.zeros_like(u)\n    u_reg = np.maximum(u, U_EPSILON)\n    \n    lap_u = (u[:-2, 1:-1] + u[2:, 1:-1] + u[1:-1, :-2] + u[1:-1, 2:] - 4 * u[1:-1, 1:-1]) / h**2\n    nonlinear_term = kappa * (u_reg[1:-1, 1:-1]**(-n) - 1.0)\n    \n    res[1:-1, 1:-1] = lap_u - nonlinear_term - s[1:-1, 1:-1]\n    return res\n\ndef _calculate_l2_norm(r, h):\n    \"\"\"Calculates the discrete L2 norm of a grid function over interior points.\"\"\"\n    return np.sqrt(h**2 * np.sum(r[1:-1, 1:-1]**2))\n\ndef _calculate_jacobian_diag_inner(u_inner, h, kappa, n):\n    \"\"\"Calculates the diagonal of the Jacobian J(u) on interior points.\"\"\"\n    u_reg_inner = np.maximum(u_inner, U_EPSILON)\n    diag_inner = -4.0 / h**2 + kappa * n * u_reg_inner**(-n-1)\n    return diag_inner\n\ndef _apply_J(x, u, h, kappa, n):\n    \"\"\"Applies the Jacobian operator J(u) to a grid function x.\"\"\"\n    res = np.zeros_like(x)\n    lap_x_inner = (x[:-2, 1:-1] + x[2:, 1:-1] + x[1:-1, :-2] + x[1:-1, 2:] - 4 * x[1:-1, 1:-1]) / h**2\n    \n    u_reg_inner = np.maximum(u[1:-1, 1:-1], U_EPSILON)\n    jac_diag_term_inner = (kappa * n * u_reg_inner**(-n-1)) * x[1:-1, 1:-1]\n    \n    res[1:-1, 1:-1] = lap_x_inner + jac_diag_term_inner\n    return res\n\ndef _relax(x, b, u, h, kappa, n, omega, nu):\n    \"\"\"Performs nu sweeps of weighted Jacobi relaxation for J(u)x=b.\"\"\"\n    diag_J_inner = _calculate_jacobian_diag_inner(u[1:-1, 1:-1], h, kappa, n)\n\n    for _ in range(nu):\n        lap_x_term = (x[:-2, 1:-1] + x[2:, 1:-1] + x[1:-1, :-2] + x[1:-1, 2:])\n        \n        # Calculate (A-D)x. For our Jacobian, (A-D)x is just the Laplacian part.\n        off_diag_Ax_inner = lap_x_term / h**2\n        \n        # Jacobi iteration formula: x_new = D^-1 * (b - (A-D)x)\n        x_jacobi_inner = (b[1:-1, 1:-1] - off_diag_Ax_inner) / diag_J_inner\n        \n        # Weighted Jacobi update\n        x[1:-1, 1:-1] = (1.0 - omega) * x[1:-1, 1:-1] + omega * x_jacobi_inner\n    return x\n\ndef _restrict(f):\n    \"\"\"Performs full-weighting restriction from a fine grid f to a coarse grid c.\"\"\"\n    Nf = f.shape[0]\n    Nc = (Nf - 1) // 2 + 1\n    c = np.zeros((Nc, Nc))\n    \n    # Interior points\n    c[1:-1, 1:-1] = ( f[1:-2:2, 1:-2:2] + f[1:-2:2, 3::2] + f[3::2, 1:-2:2] + f[3::2, 3::2] + # corners (w=1/16)\n                    (f[1:-2:2, 2:-1:2] + f[3::2, 2:-1:2] + f[2:-1:2, 1:-2:2] + f[2:-1:2, 3::2]) * 2.0 + # edges (w=2/16)\n                     f[2:-1:2, 2:-1:2] * 4.0 ) / 16.0 # center (w=4/16)\n\n    # Boundaries are handled by Dirichlet conditions, so we can just restrict them.\n    # The prolongation operator will properly interpolate them back.\n    c[0, :] = f[0, ::2]\n    c[-1, :] = f[-1, ::2]\n    c[:, 0] = f[::2, 0]\n    c[:, -1] = f[::2, -1]\n    \n    return c\n    \ndef _prolongate(c):\n    \"\"\"Performs bilinear prolongation from a coarse grid c to a fine grid f.\"\"\"\n    Nc = c.shape[0]\n    Nf = (Nc - 1) * 2 + 1\n    f = np.zeros((Nf, Nf))\n    \n    f[::2, ::2] = c\n    f[1::2, ::2] = (c[:-1, :] + c[1:, :]) / 2.0\n    f[::2, 1::2] = (c[:, :-1] + c[:, 1:]) / 2.0\n    f[1::2, 1::2] = (c[:-1, :-1] + c[1:, :-1] + c[:-1, 1:] + c[1:, 1:]) / 4.0\n    return f\n\ndef _v_cycle(level_idx, b, levels_u, levels_data, params):\n    \"\"\"A single multigrid V-cycle to approximately solve J(u)x = b.\"\"\"\n    kappa, n = params['kappa'], params['n']\n    omega, nu1, nu2 = params['omega'], params['nu1'], params['nu2']\n    \n    u = levels_u[level_idx]\n    h = levels_data[level_idx]['h']\n    \n    x = np.zeros_like(b)\n\n    if level_idx == len(levels_data) - 1: # Coarsest level\n        coarsest_sweeps = 2 * (nu1 + nu2) * (level_idx + 1)\n        x = _relax(x, b, u, h, kappa, n, omega, coarsest_sweeps)\n        return x\n\n    # 1. Pre-smoothing\n    x = _relax(x, b, u, h, kappa, n, omega, nu1)\n\n    # 2. Coarse-grid correction\n    res_fine = b - _apply_J(x, u, h, kappa, n)\n    res_coarse = _restrict(res_fine)\n    \n    correction_coarse = _v_cycle(level_idx + 1, res_coarse, levels_u, levels_data, params)\n    \n    correction_fine = _prolongate(correction_coarse)\n    x += correction_fine\n\n    # 3. Post-smoothing\n    x = _relax(x, b, u, h, kappa, n, omega, nu2)\n    \n    return x\n\ndef run_case(N, kappa, n, A, omega, nu1, nu2, max_newton, theta, epsilon_conv):\n    \"\"\"Runs the Newton-MG solver for a single test case.\"\"\"\n    try:\n        levels_data = _create_levels_data(N)\n    except ValueError:\n        return False\n        \n    h_finest = levels_data[0]['h']\n\n    u = np.ones((N, N))\n    s = _setup_source_term(N, A)\n\n    r0 = _calculate_residual(u, s, h_finest, kappa, n)\n    norm_r0 = _calculate_l2_norm(r0, h_finest)\n    if norm_r0  epsilon_conv:\n        return True\n\n    for _ in range(max_newton):\n        r_k = _calculate_residual(u, s, h_finest, kappa, n)\n        norm_r_k = _calculate_l2_norm(r_k, h_finest)\n\n        if norm_r_k = epsilon_conv and norm_r_k / norm_r0 = theta:\n            return True\n\n        b = -r_k\n        \n        levels_u = [u]\n        for i in range(len(levels_data) - 1):\n            levels_u.append(_restrict(levels_u[-1]))\n\n        mg_params = {'kappa': kappa, 'n': n, 'omega': omega, 'nu1': nu1, 'nu2': nu2}\n\n        delta_u = _v_cycle(0, b, levels_u, levels_data, mg_params)\n        \n        alpha = 1.0\n        for _ in range(10): # Line search iterations\n            u_new = u + alpha * delta_u\n            if np.min(u_new[1:-1, 1:-1]) > U_EPSILON:\n                break\n            alpha /= 2.0\n        else: # If loop completes without break\n            return False # Failed to find a positive update\n\n        u = u_new\n\n    return False\n\ndef solve():\n    test_cases = [\n        {'N': 65, 'kappa': 1.0, 'n': 1.0, 'A': 0.1, 'omega': 0.8, 'nu1': 3, 'nu2': 3, 'max_newton': 20, 'theta': 1e-6, 'epsilon_conv': 1e-8},\n        {'N': 33, 'kappa': 2.0, 'n': 2.0, 'A': 0.3, 'omega': 0.75, 'nu1': 4, 'nu2': 4, 'max_newton': 25, 'theta': 1e-6, 'epsilon_conv': 1e-8},\n        {'N': 65, 'kappa': 0.2, 'n': 1.0, 'A': 0.05, 'omega': 0.8, 'nu1': 3, 'nu2': 3, 'max_newton': 15, 'theta': 1e-7, 'epsilon_conv': 1e-9},\n        {'N': 17, 'kappa': 1.5, 'n': 1.5, 'A': 0.2, 'omega': 0.7, 'nu1': 4, 'nu2': 4, 'max_newton': 20, 'theta': 1e-6, 'epsilon_conv': 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        converged = run_case(**case)\n        results.append(str(converged).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3487385"}, {"introduction": "编写出求解器只是完成了一半工作；你如何确信计算结果是正确的？在计算科学中，验证是至关重要且不可或缺的一步，这包括检查解的自洽性、对守恒律的遵守情况，以及在适当极限下再现已知物理规律的能力。这最后一个练习 [@problem_id:3487398] 专注于建立一套定量诊断工具来验证你的数值解，你将实现残差、能量平衡和比安基恒等式一致性等检验，并最终验证你的代码能否在引力修正趋于零时，正确地恢复到广义相对论这一已知极限。", "problem": "开发一个完整的程序，在一维周期性域上，为一个 $f(R)$ 型修改引力的简单玩具模型中的准静态标量自由度验证解的质量和自洽性检验，并展示当 $f_{R0} \\to 0$ 时对广义相对论（GR）极限的数值恢复。该程序必须是自包含的，并按指定格式生成单行输出。\n\n您必须从牛顿规范下类 $f(R)$ 模型在准静态、亚视界极限下的以下经过充分测试的场内容开始。令 $a$ 表示尺度因子，$G$ 为牛顿引力常数，$\\delta \\rho$ 为共动物质密度微扰，$\\delta f_R$ 为标量场微扰，$\\Phi$ 和 $\\Psi$ 为两个巴丁势：\n- 标量场（亥姆霍兹型）方程：\n$$\n\\left(\\nabla^2 - a^2 m^2(a)\\right)\\, \\delta f_R \\;=\\; \\frac{a^2}{3}\\, \\delta \\rho \\, .\n$$\n- 修改的泊松方程：\n$$\n\\nabla^2 \\Psi \\;=\\; 4 \\pi G a^2 \\, \\delta \\rho \\;-\\; \\frac{1}{2}\\, \\nabla^2 \\delta f_R \\, .\n$$\n- 引力滑移关系：\n$$\n\\Phi - \\Psi \\;=\\; \\delta f_R \\, .\n$$\n由此，透镜组合满足比安基恒等式层面的自洽性条件：\n$$\n\\nabla^2(\\Phi + \\Psi) \\;=\\; 8 \\pi G a^2 \\, \\delta \\rho \\, .\n$$\n\n采用长度为 $L$ 的一维周期性盒子，包含 $N$ 个点的均匀网格，并使用快速傅里叶变换（FFT）以谱方法求解椭圆方程。在 $a = 1$ 的单个时期工作，并采用 $4 \\pi G a^2 = 1$ 的单位制，使得标准的广义相对论泊松方程为 $\\nabla^2 \\Psi_{\\mathrm{GR}} = \\delta \\rho$。使用零均值的单模物质微扰：\n$$\n\\delta \\rho(x) \\;=\\; A \\, \\sin(k_{\\star} x) \\, ,\n$$\n其中 $k_{\\star} = 2\\pi / L$，振幅为 $A$。使用足够大的 $N$ 以解析正弦波。通过在傅里叶空间中进行代数除法，以周期性边界条件谱方法求解 $\\delta f_R$ 和 $\\Psi$，注意处理 $k=0$ 模式以保持场为零均值。\n\n为了以一种具有正确定性广义相对论极限的方式参数化 $f(R)$ 模型，使用一个玩具但科学上合理的有效质量标度关系，\n$$\nm(a) \\;=\\; \\frac{H_0}{\\sqrt{|f_{R0}|}} \\, a^{-3/2} \\, ,\n$$\n并在所选单位中设置 $H_0 = 1$，因此在 $a=1$ 时有 $m = 1/\\sqrt{|f_{R0}|}$。这反映了 $|f_{R0}| \\to 0$ 意味着大的标量场质量并恢复 $\\delta f_R \\to 0$ 的广义相对论极限这一事实。\n\n实现以下量化诊断，每个都表示为一个无量纲数：\n1. 标量场方程和修改的泊松方程的残差范数。在实空间中定义残差为\n$$\n\\mathcal{R}_f \\equiv \\nabla^2 \\delta f_R - a^2 m^2 \\delta f_R - \\frac{a^2}{3} \\delta \\rho \\, ,\n\\quad\n\\mathcal{R}_P \\equiv \\nabla^2 \\Psi - 4 \\pi G a^2 \\delta \\rho + \\frac{1}{2} \\nabla^2 \\delta f_R \\, .\n$$\n报告归一化的均方根（RMS）范数，\n$$\n\\|\\mathcal{R}_f\\| \\equiv \\frac{\\sqrt{\\langle \\mathcal{R}_f^2 \\rangle}}{\\sqrt{\\left\\langle \\left(\\frac{a^2}{3}\\delta \\rho \\right)^2 \\right\\rangle}} \\, ,\n\\quad\n\\|\\mathcal{R}_P\\| \\equiv \\frac{\\sqrt{\\langle \\mathcal{R}_P^2 \\rangle}}{\\sqrt{\\langle (4\\pi G a^2 \\delta \\rho)^2 \\rangle}} \\, ,\n$$\n其中 $\\langle \\cdot \\rangle$ 表示在周期性域上的平均。\n\n2. 标量场方程的类能量不变量检验。定义\n$$\nQ \\equiv \\int_0^L \\left[ (\\partial_x \\delta f_R)^2 + a^2 m^2 (\\delta f_R)^2 \\right] \\, dx \\, ,\n\\qquad\nS \\equiv \\int_0^L \\left( -\\frac{a^2}{3} \\delta \\rho \\, \\delta f_R \\right) \\, dx \\, .\n$$\n使用周期性边界条件，场方程意味着平衡条件 $Q + S = 0$。报告无量纲偏差\n$$\n\\mathcal{E}_{\\mathrm{bal}} \\equiv \\frac{|Q + S|}{|Q| + |S|} \\, .\n$$\n\n3. 使用派生的透镜方程进行比安基恒等式层面的透镜自洽性检验，\n$$\n\\mathcal{R}_L \\equiv \\nabla^2(\\Phi + \\Psi) - 8 \\pi G a^2 \\delta \\rho \\, ,\n\\quad\n\\|\\mathcal{R}_L\\| \\equiv \\frac{\\sqrt{\\langle \\mathcal{R}_L^2 \\rangle}}{\\sqrt{\\langle (8 \\pi G a^2 \\delta \\rho)^2 \\rangle}} \\, .\n$$\n\n4. 广义相对论恢复误差，\n$$\n\\mathcal{E}_{\\mathrm{GR}} \\equiv \\frac{\\sqrt{\\left\\langle \\left( \\nabla^2 \\Psi - 4 \\pi G a^2 \\delta \\rho \\right)^2 \\right\\rangle}}{\\sqrt{\\langle (4 \\pi G a^2 \\delta \\rho)^2 \\rangle}} \\, ,\n$$\n当 $f_{R0} \\to 0$ 时，该值必须趋近于 $0$。\n\n所有场都应通过谱方法微分在离散网格上进行评估：在网格上计算离散傅里叶模式 $k_n = 2\\pi n/L$（其中 $n$ 为整数），逐模式构建代数解，然后逆变换回实空间。小心处理 $k=0$ 模式以避免除以 $0$。\n\n使用以下测试套件，周期性盒子长度 $L = 2\\pi$，网格大小 $N = 256$，振幅 $A = 1$，尺度因子 $a = 1$，以及 $4\\pi G a^2 = 1$：\n- 情况 1：$f_{R0} = -10^{-4}$。\n- 情况 2：$f_{R0} = -10^{-6}$。\n- 情况 3：$f_{R0} = -10^{-8}$。\n- 情况 4：$f_{R0} = -10^{-12}$。\n\n对于每种情况，求解 $\\delta f_R$、$\\Psi$ 和 $\\Phi$，计算五个诊断量 $\\|\\mathcal{R}_f\\|$, $\\|\\mathcal{R}_P\\|$, $\\|\\mathcal{R}_L\\|$, $\\mathcal{E}_{\\mathrm{bal}}$ 和 $\\mathcal{E}_{\\mathrm{GR}}$，并将结果按以下顺序聚合成一个扁平列表：\n$$\n\\left[ \\|\\mathcal{R}_f\\|_1, \\|\\mathcal{R}_P\\|_1, \\|\\mathcal{R}_L\\|_1, \\mathcal{E}_{\\mathrm{bal},1}, \\mathcal{E}_{\\mathrm{GR},1}, \\ldots, \\|\\mathcal{R}_f\\|_4, \\|\\mathcal{R}_P\\|_4, \\|\\mathcal{R}_L\\|_4, \\mathcal{E}_{\\mathrm{bal},4}, \\mathcal{E}_{\\mathrm{GR},4} \\right] \\, .\n$$\n\n您的程序应生成一个单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[r1,r2,r3,...]”）。所有报告的量都是无量纲浮点数。不出现角度，因此不需要角度单位。输出中不得报告任何物理单位；所采用的单位系统是计算内部的，并且诊断量通过构造是无量纲的。\n\n设计算法，使其数值稳定并利用拉普拉斯算子的谱对角化。确保在有限的 $|f_{R0}|$ 下残差范数远小于 $1$，并且随着 $|f_{R0}|$ 的减小，$\\mathcal{E}_{\\mathrm{GR}}$ 减小，从而说明广义相对论极限的数值恢复。", "solution": "该问题要求对一个描述 $f(R)$ 修改引力玩具模型中标量自由度的耦合线性椭圆偏微分方程组进行数值求解。求解过程将在一个一维周期性域上执行，并且必须使用一套量化诊断来验证其解的质量。一个关键目标是展示对广义相对论（GR）极限的数值恢复。\n\n指导求解的基本原理是使用基于快速傅里叶变换（FFT）的谱方法。这种方法非常适合在周期性域上求解具有常系数的线性偏微分方程。原因是构成傅里叶级数基础的复指数函数是微分算子的本征函数。因此，傅里叶变换可将拉普拉斯算子 $\\nabla^2 = d^2/dx^2$ 对角化。对于一个函数 $g(x)$ 及其傅里叶变换 $\\hat{g}(k)$，其二阶导数的变换由简单的代数关系 $\\widehat{\\nabla^2 g}(k) = (ik)^2 \\hat{g}(k) = -k^2 \\hat{g}(k)$ 给出，其中 $k$ 是波数。此属性将微分方程转化为一组针对每个傅里叶模式 $k$ 的独立代数方程，这些方程可以轻易求解。\n\n我们概述一下系统化的步骤。\n\n首先，我们建立计算域和离散化。我们在长度为 $L$ 的周期性域上使用一个包含 $N$ 个点 $x_j = j (L/N)$（$j = 0, 1, \\ldots, N-1$）的均匀网格。相应的离散傅里叶波数由 $k_n = (2\\pi/L)n$ 给出，其中整数 $n$ 按照 FFT 算法的标准顺序排列。我们使用 `numpy.fft.fftfreq` 工具来生成这些波数。问题指定了物理参数：尺度因子 $a=1$，盒子长度 $L=2\\pi$，网格大小 $N=256$，以及物质微扰的振幅 $A=1$。采用的单位制使得 $4\\pi G a^2 = 1$ 和 $H_0 = 1$。物质微扰是一个单一的正弦模式，$\\delta \\rho(x) = A \\sin(k_{\\star} x)$，其中 $k_{\\star} = 2\\pi/L = 1$。该源项的均值为零，因此其 $k=0$ 的傅里叶模式为零。\n\n求解过程通过在傅里叶空间中求解给定的方程来进行。\n\n1.  **求解标量场方程：**\n    标量场微扰 $\\delta f_R$ 的控制方程是一个亥姆霍兹型方程：\n    $$ \\left(\\nabla^2 - a^2 m^2\\right)\\, \\delta f_R \\;=\\; \\frac{a^2}{3}\\, \\delta \\rho $$\n    在傅里叶空间中，这变为：\n    $$ \\left(-k^2 - a^2 m^2\\right)\\, \\widehat{\\delta f_R}(k) \\;=\\; \\frac{a^2}{3}\\, \\widehat{\\delta \\rho}(k) $$\n    其中 $\\widehat{\\delta f_R}$ 和 $\\widehat{\\delta \\rho}$ 分别是 $\\delta f_R$ 和 $\\delta \\rho$ 的傅里叶变换。质量参数 $m$ 由 $m = H_0/\\sqrt{|f_{R0}|} \\, a^{-3/2}$ 给出，在给定参数下简化为 $m^2 = 1/|f_{R0}|$。标量场傅里叶模式的代数解是：\n    $$ \\widehat{\\delta f_R}(k) \\;=\\; -\\frac{(a^2/3) \\widehat{\\delta \\rho}(k)}{k^2 + a^2 m^2} $$\n    由于 $\\widehat{\\delta \\rho}(k=0) = 0$，所以 $k=0$ 模式 $\\widehat{\\delta f_R}(k=0)$ 也为零，确保了 $\\delta f_R$ 的均值为零。通过应用逆 FFT 可以恢复实空间场 $\\delta f_R(x)$。\n\n2.  **求解修改的泊松方程：**\n    引力势 $\\Psi$ 的方程是：\n    $$ \\nabla^2 \\Psi \\;=\\; 4 \\pi G a^2 \\, \\delta \\rho \\;-\\; \\frac{1}{2}\\, \\nabla^2 \\delta f_R $$\n    变换到傅里叶空间得到：\n    $$ -k^2 \\hat{\\Psi}(k) \\;=\\; (4 \\pi G a^2) \\, \\widehat{\\delta \\rho}(k) \\;-\\; \\frac{1}{2}\\,(-k^2 \\widehat{\\delta f_R}(k)) $$\n    $$ \\hat{\\Psi}(k) \\;=\\; -\\frac{4 \\pi G a^2}{k^2} \\, \\widehat{\\delta \\rho}(k) \\;-\\; \\frac{1}{2}\\, \\widehat{\\delta f_R}(k) $$\n    对于 $k \\neq 0$ 的模式，这个方程可以直接求解。对于 $k=0$ 模式，第一项是 $0/0$ 的形式。我们通过施加势具有零均值的物理条件来解决这个不确定性，这意味着 $\\hat{\\Psi}(k=0)=0$。然后通过逆 FFT 找到实空间势 $\\Psi(x)$。\n\n3.  **计算第二个势 $\\Phi$：**\n    第二个巴丁势 $\\Phi$ 由引力滑移关系确定：\n    $$ \\Phi(x) \\;=\\; \\Psi(x) + \\delta f_R(x) $$\n    这只是将在实空间中已计算出的两个场进行简单相加。\n\n在确定了场 $\\delta f_R$、$\\Psi$ 和 $\\Phi$ 之后，我们计算所需的诊断量。为确保高精度并避免引入有限差分误差，诊断所需的所有空间导数也通过谱方法计算（即，在傅里叶空间中进行乘法，然后进行逆 FFT）。所有平均值 $\\langle \\cdot \\rangle$ 都计算为网格点上的均值，积分 $\\int_0^L (\\cdot) dx$ 计算为平均值乘以域长 $L$。\n\n1.  **残差范数 $\\|\\mathcal{R}_f\\|$ 和 $\\|\\mathcal{R}_P\\|$**：这些检验验证了数值解是否以高精度满足原始的微分方程。残差 $\\mathcal{R}_f$ 和 $\\mathcal{R}_P$ 是在实空间中使用谱方法计算的导数来计算的。由于求解方法是基于在傅里叶空间中代数地满足这些方程，残差应该在浮点精度范围内为零。它们的归一化均方根范数测试了数值求解器的自洽性。\n\n2.  **能量平衡 $\\mathcal{E}_{\\mathrm{bal}}$**：此诊断验证了一个从标量场方程派生出的类守恒定律。通过将标量场方程乘以 $\\delta f_R$ 并在周期性域上积分（使用分部积分法），可以推导出恒等式 $Q+S=0$，其中 $Q$ 和 $S$ 是指定的积分。问题中 $S$ 的定义缺少一个负号，应为 $S = \\int (-\\frac{a^2}{3} \\delta\\rho \\delta f_R) dx$。无量纲比率 $\\mathcal{E}_{\\mathrm{bal}} = |Q+S|/(|Q|+|S|)$ 应接近于零，反映了场解和数值积分的准确性。\n\n3.  **透镜自洽性 $\\|\\mathcal{R}_L\\|$**：此检验验证了一个基本恒等式 $\\nabla^2(\\Phi + \\Psi) = 8 \\pi G a^2 \\delta \\rho$，这是底层场方程的直接结果。与其他残差范数类似，$\\|\\mathcal{R}_L\\|$ 应接近机器精度，为整个求解系统的内部一致性提供了一个强有力的测试。\n\n4.  **广义相对论恢复误差 $\\mathcal{E}_{\\mathrm{GR}}$**：这个关键诊断量化了计算出的势 $\\Psi$ 与标准广义相对论中预期解的偏差，在标准广义相对论中 $\\nabla^2 \\Psi_{\\mathrm{GR}} = 4 \\pi G a^2 \\delta \\rho$。误差 $\\mathcal{E}_{\\mathrm{GR}}$ 是广义相对论残差 $\\nabla^2 \\Psi - 4\\pi G a^2 \\delta \\rho$ 的归一化均方根。根据修改的泊松方程，该残差等于 $-\\frac{1}{2}\\nabla^2\\delta f_R$。在 $|f_{R0}| \\to 0$ 的极限下，标量场质量 $m \\to \\infty$，这会抑制标量场 $\\delta f_R \\to 0$。因此，$\\mathcal{E}_{\\mathrm{GR}}$ 预期会趋近于 $0$，从而证明了广义相对论极限的成功恢复。\n\n该实现迭代遍历指定的 $f_{R0}$ 值，从 $-10^{-4}$ 到 $-10^{-12}$，为每种情况计算这五个诊断量，并将结果汇总到一个列表中以供输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Solves the f(R) toy model equations and computes diagnostics for a suite of test cases.\n    \"\"\"\n\n    def solve_case(f_R0, L, N, A, G_eff, H0, a):\n        \"\"\"\n        Computes the solution and diagnostics for a single f(R) parameter case.\n        \"\"\"\n        # 1. Setup grid and constants\n        x = np.linspace(0, L, N, endpoint=False)\n        dx = L / N\n        k = 2 * np.pi * fftfreq(N, d=dx)\n\n        # 2. Define source term and its Fourier transform\n        k_star = 2 * np.pi / L\n        delta_rho = A * np.sin(k_star * x)\n        delta_rho_k = fft(delta_rho)\n\n        # 3. Model parameters\n        a_sq = a**2\n        m_sq = H0**2 / np.abs(f_R0) * a**(-3)\n        \n        # 4. Solve for the scalaron field delta_fR\n        # The equation in Fourier space is: (-k^2 - a^2*m^2) * delta_fR_k = (a^2/3) * delta_rho_k\n        denominator_fR = -k**2 - a_sq * m_sq\n        delta_fR_k = np.zeros_like(k, dtype=np.complex128)\n        # Avoid division by zero, though for this problem it's not strictly necessary\n        # as k=0 mode of rho is zero.\n        nonzero_mask_fR = denominator_fR != 0\n        delta_fR_k[nonzero_mask_fR] = ((a_sq / 3.0) * delta_rho_k[nonzero_mask_fR]) / denominator_fR[nonzero_mask_fR]\n        \n        delta_fR = ifft(delta_fR_k).real\n\n        # 5. Solve for the gravitational potential Psi\n        # The equation in Fourier space is: -k^2 * Psi_k = G_eff * delta_rho_k + 0.5 * k^2 * delta_fR_k\n        # This simplifies to: Psi_k = - (G_eff * delta_rho_k / k^2) - 0.5 * delta_fR_k\n        Psi_k = np.zeros_like(k, dtype=np.complex128)\n        k_nonzero_mask = k != 0\n        \n        # For k != 0, solve algebraically.\n        Psi_k[k_nonzero_mask] = - (G_eff * delta_rho_k[k_nonzero_mask]) / k[k_nonzero_mask]**2 - 0.5 * delta_fR_k[k_nonzero_mask]\n        \n        # Psi_k[0] remains 0, enforcing a zero mean for the potential.\n        Psi = ifft(Psi_k).real\n\n        # 6. Compute the second potential Phi\n        Phi = Psi + delta_fR\n\n        # 7. Compute diagnostics\n        \n        # Helper functions for spectral derivatives and norms\n        def laplacian(field_real):\n            field_k = fft(field_real)\n            lap_field_k = -k**2 * field_k\n            return ifft(lap_field_k).real\n\n        def grad_sq(field_real):\n            field_k = fft(field_real)\n            grad_field_k = 1j * k * field_k\n            grad_field_real = ifft(grad_field_k).real\n            return grad_field_real**2\n\n        def rms(field):\n            return np.sqrt(np.mean(field**2))\n\n        # Diagnostic 1: Residual Norms\n        lap_delta_fR = laplacian(delta_fR)\n        R_f = lap_delta_fR - a_sq * m_sq * delta_fR - (a_sq / 3.0) * delta_rho\n        norm_source_f = rms((a_sq / 3.0) * delta_rho)\n        norm_R_f = rms(R_f) / norm_source_f if norm_source_f > 1e-15 else 0.0\n\n        lap_Psi = laplacian(Psi)\n        R_P = lap_Psi - G_eff * delta_rho + 0.5 * lap_delta_fR\n        norm_source_P = rms(G_eff * delta_rho)\n        norm_R_P = rms(R_P) / norm_source_P if norm_source_P > 1e-15 else 0.0\n\n        # Diagnostic 2: Energy Balance. Problem definition has a sign error for S.\n        # Integrating the field equation against delta_fR gives integral[-(grad f)^2 - m^2 f^2] = integral [source * f]\n        # So Q = -integral[source*f], or Q+S=0 with S=-integral[source*f]. The prompt defines S with a plus sign.\n        # Adhering to the prompt's formula: Q + S = 0 => S = -Q. We use the prompt's S formula, and fix the expected relation.\n        # The integral relation is $\\int [ (\\partial_x \\delta f_R)^2 + a^2 m^2 (\\delta f_R)^2 ] dx = \\int (-\\frac{a^2}{3} \\delta \\rho \\delta f_R) dx$.\n        # The prompt defines S without the minus sign. So we test |Q-S|/|Q|+|S|. But to be strictly compliant, we test |Q+S|\n        integrand_Q = grad_sq(delta_fR) + a_sq * m_sq * delta_fR**2\n        Q = np.sum(integrand_Q) * dx\n        \n        # Problem statement defines S as integral of -(a^2/3) * rho * f_R.\n        # This gives Q+S=0 as the balance condition.\n        integrand_S = (-a_sq / 3.0) * delta_rho * delta_fR\n        S = np.sum(integrand_S) * dx\n        \n        denominator_E_bal = np.abs(Q) + np.abs(S)\n        E_bal = np.abs(Q + S) / denominator_E_bal if denominator_E_bal > 1e-15 else 0.0\n\n        # Diagnostic 3: Lensing Consistency\n        Phi_plus_Psi = Phi + Psi\n        lap_Phi_plus_Psi = laplacian(Phi_plus_Psi)\n        R_L = lap_Phi_plus_Psi - 2.0 * G_eff * delta_rho\n        norm_source_L = rms(2.0 * G_eff * delta_rho)\n        norm_R_L = rms(R_L) / norm_source_L if norm_source_L > 1e-15 else 0.0\n        \n        # Diagnostic 4: GR Recovery Error\n        R_GR = lap_Psi - G_eff * delta_rho\n        E_GR = rms(R_GR) / norm_source_P if norm_source_P > 1e-15 else 0.0\n\n        return [norm_R_f, norm_R_P, norm_R_L, E_bal, E_GR]\n\n\n    # Define the test cases from the problem statement.\n    L = 2 * np.pi\n    N = 256\n    A = 1.0\n    a = 1.0\n    G_eff = 1.0  # Corresponds to 4*pi*G*a^2 = 1\n    H0 = 1.0\n    \n    test_cases = [\n        -1e-4,\n        -1e-6,\n        -1e-8,\n        -1e-12,\n    ]\n\n    results = []\n    for f_R0 in test_cases:\n        case_results = solve_case(f_R0, L, N, A, G_eff, H0, a)\n        results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.15e}' for x in results)}]\")\n\nsolve()\n```", "id": "3487398"}]}