{"hands_on_practices": [{"introduction": "在选择了耦合不同物理算符的方法之后，一项关键任务是选择一个合适的时间步长 $\\Delta t$ 来推进模拟。为了保证稳定性和准确性，时间步长必须足够小，以解析最快的相关物理过程，这包括光子穿越网格单元的传播，也包括快速的化学反应。本练习将指导您从第一性原理出发，推导出一个复合的、自适应的时间步长约束，这是现代高效天体物理代码的基石[@problem_id:3469642]。", "problem": "你的任务是为膨胀宇宙中的宇宙学辐射转移和电离动力学的显式更新，推导并实现一个类似 Courant–Friedrichs–Lewy (CFL) 的自适应时间步长约束。推导必须从膨胀宇宙中辐射的基本平衡和运动学定义、双曲平流的显式数值稳定性要求以及一阶动力学速率方程开始。\n\n从以下基础出发：\n- 在一个空间均匀、各向同性的膨胀宇宙中，对于比强度 $I(\\nu)$，其宇宙学辐射转移方程在哈勃膨胀率 $H(t)$ 下，以共动空间坐标和频率平流表示为：\n$$\n\\frac{\\partial I}{\\partial t} + c\\,\\mathbf{n}\\cdot\\nabla I - H\\,\\nu\\,\\frac{\\partial I}{\\partial \\nu} = - c\\,\\kappa\\, I + j,\n$$\n其中 $c$ 是光速，$\\kappa$ 是吸收系数，单位为 $\\mathrm{m}^{-1}$，$j$ 是发射率，$H$ 是哈勃参数，单位为 $\\mathrm{s}^{-1}$。为解决此问题，你将考虑用于输运和化学子步骤的显式时间积分器，并受制于稳定性和准确性约束。\n- 标量氢电离分数 $x(t)$ 服从一个一阶速率方程：\n$$\n\\frac{dx}{dt} = \\Gamma(1 - x) - \\alpha_{\\mathrm{B}} n_{\\mathrm{H}} x^2,\n$$\n其中 $\\Gamma$ 是光致电离率，单位为 $\\mathrm{s}^{-1}$，$\\alpha_{\\mathrm{B}}$ 是B情形复合系数，单位为 $\\mathrm{m}^3\\,\\mathrm{s}^{-1}$，$n_{\\mathrm{H}}$ 是总氢数密度，单位为 $\\mathrm{m}^{-3}$。\n\n基于这些基础，推导一个复合的显式时间步长约束，该约束同时强制满足：\n- 对于均匀网格尺寸 $\\Delta x$ 的空间平流的光传播约束，即特征线在一步内穿越不超过一个网格的要求。\n- 由宇宙学红移引起的、跨越均匀频率箱宽度 $\\Delta \\nu$ 的频率空间平流约束。\n- 一个由吸收引起的强度变化约束，限制每步由于 $-c\\,\\kappa\\,I$ 导致的 $I$ 的分数减小。\n- 一个由动力学速率方程决定的电离分数变化约束，限制每步 $x$ 的分数变化。\n\n从第一性原理出发，根据参数 $\\Delta x$、$\\Delta \\nu$、$\\nu$、$H$、$\\kappa$、$c$、$x$、$n_{\\mathrm{H}}$、$\\Gamma$ 和 $\\alpha_{\\mathrm{B}}$，以及用户指定的稳定性/准确性分数 $C_x$、$C_\\nu$、$\\varepsilon_I$ 和 $\\varepsilon_x$（它们分别限制空间和频率平流的 Courant 数以及每步允许的强度和电离分数的分数变化），推导每个约束。通过取各个约束的最小值，将它们组合成一个提议的时间步长 $\\Delta t_{\\mathrm{prop}}$。\n\n使用一个带有嵌入式双半步误差估计器的显式前向欧拉法，为电离更新实现一个自适应步长接受程序：\n- 给定一个候选步长 $\\Delta t$，计算一个全步更新 $x_{\\mathrm{full}} = x + \\Delta t\\,f(x)$，其中速率函数为 $f(x) = \\Gamma(1-x) - \\alpha_{\\mathrm{B}} n_{\\mathrm{H}} x^2$。\n- 计算一个双半步估计 $x_{\\mathrm{half}} = x + \\frac{\\Delta t}{2}\\,f(x)$，然后 $x_{\\mathrm{two}} = x_{\\mathrm{half}} + \\frac{\\Delta t}{2}\\,f(x_{\\mathrm{half}})$。\n- 估计局部误差 $e = |x_{\\mathrm{full}} - x_{\\mathrm{two}}|$，如果 $e \\le \\mathrm{tol}_x$ 则接受该步长，否则根据一个类似比例-积分的规则（该规则按 $(\\mathrm{tol}_x/e)^{1/2}$ 缩放）减小 $\\Delta t$ 并重试，同时受制于一个合理的安全因子和迭代限制。对试探更新强制施加物理边界 $0 \\le x \\le 1$。\n\n数值和输出要求：\n- 所有输出必须以秒为单位表示，并四舍五入到最接近的整数秒。\n- 您的程序必须生成单行输出，其中包含接受的时间步长（每个测试用例一个），格式为用方括号括起来的逗号分隔列表（例如，$[t_1,t_2,t_3,t_4]$）。\n- 不允许用户输入；所有参数均在下方指定。\n\n为以下参数值的测试套件实现上述要求，以检验不同的机制。请严格按照给出的常数和参数使用。\n\n- 测试用例 1 (通用情况):\n  - $\\Delta x = 3.086\\times 10^{19}\\,\\mathrm{m}$, $\\Delta \\nu = 1.0\\times 10^{14}\\,\\mathrm{Hz}$, $\\nu = 3.0\\times 10^{15}\\,\\mathrm{Hz}$,\n  - $H = 1.0\\times 10^{-17}\\,\\mathrm{s}^{-1}$, $\\kappa = 1.3\\times 10^{-19}\\,\\mathrm{m}^{-1}$,\n  - $n_{\\mathrm{H}} = 200.0\\,\\mathrm{m}^{-3}$, $\\Gamma = 1.0\\times 10^{-12}\\,\\mathrm{s}^{-1}$, $\\alpha_{\\mathrm{B}} = 2.6\\times 10^{-19}\\,\\mathrm{m}^3\\,\\mathrm{s}^{-1}$,\n  - $x_0 = 0.10$, $C_x = 0.90$, $C_\\nu = 0.90$, $\\varepsilon_I = 0.02$, $\\varepsilon_x = 0.01$, $\\mathrm{tol}_x = 1.0\\times 10^{-4}$。\n- 测试用例 2 (小空间网格边界):\n  - $\\Delta x = 1.0\\times 10^{16}\\,\\mathrm{m}$, $\\Delta \\nu = 1.0\\times 10^{14}\\,\\mathrm{Hz}$, $\\nu = 3.0\\times 10^{15}\\,\\mathrm{Hz}$,\n  - $H = 1.0\\times 10^{-17}\\,\\mathrm{s}^{-1}$, $\\kappa = 1.3\\times 10^{-19}\\,\\mathrm{m}^{-1}$,\n  - $n_{\\mathrm{H}} = 200.0\\,\\mathrm{m}^{-3}$, $\\Gamma = 5.0\\times 10^{-13}\\,\\mathrm{s}^{-1}$, $\\alpha_{\\mathrm{B}} = 2.6\\times 10^{-19}\\,\\mathrm{m}^3\\,\\mathrm{s}^{-1}$,\n  - $x_0 = 0.50$, $C_x = 0.90$, $C_\\nu = 0.90$, $\\varepsilon_I = 0.02$, $\\varepsilon_x = 0.02$, $\\mathrm{tol}_x = 1.0\\times 10^{-5}$。\n- 测试用例 3 (强吸收边情况):\n  - $\\Delta x = 3.086\\times 10^{19}\\,\\mathrm{m}$, $\\Delta \\nu = 1.0\\times 10^{14}\\,\\mathrm{Hz}$, $\\nu = 3.0\\times 10^{15}\\,\\mathrm{Hz}$,\n  - $H = 1.0\\times 10^{-17}\\,\\mathrm{s}^{-1}$, $\\kappa = 1.0\\times 10^{-16}\\,\\mathrm{m}^{-1}$,\n  - $n_{\\mathrm{H}} = 200.0\\,\\mathrm{m}^{-3}$, $\\Gamma = 1.0\\times 10^{-13}\\,\\mathrm{s}^{-1}$, $\\alpha_{\\mathrm{B}} = 2.6\\times 10^{-19}\\,\\mathrm{m}^3\\,\\mathrm{s}^{-1}$,\n  - $x_0 = 0.01$, $C_x = 0.90$, $C_\\nu = 0.90$, $\\varepsilon_I = 0.01$, $\\varepsilon_x = 0.005$, $\\mathrm{tol}_x = 1.0\\times 10^{-6}$。\n- 测试用例 4 (宇宙学红移主导):\n  - $\\Delta x = 3.086\\times 10^{22}\\,\\mathrm{m}$, $\\Delta \\nu = 1.0\\times 10^{9}\\,\\mathrm{Hz}$, $\\nu = 3.0\\times 10^{15}\\,\\mathrm{Hz}$,\n  - $H = 5.0\\times 10^{-16}\\,\\mathrm{s}^{-1}$, $\\kappa = 1.3\\times 10^{-19}\\,\\mathrm{m}^{-1}$,\n  - $n_{\\mathrm{H}} = 200.0\\,\\mathrm{m}^{-3}$, $\\Gamma = 1.0\\times 10^{-14}\\,\\mathrm{s}^{-1}$, $\\alpha_{\\mathrm{B}} = 2.6\\times 10^{-19}\\,\\mathrm{m}^3\\,\\mathrm{s}^{-1}$,\n  - $x_0 = 0.90$, $C_x = 0.90$, $C_\\nu = 0.90$, $\\varepsilon_I = 0.02$, $\\varepsilon_x = 0.01$, $\\mathrm{tol}_x = 1.0\\times 10^{-4}$。\n\n附加要求：\n- 使用 $c = 2.99792458\\times 10^{8}\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$。\n- 程序必须用 Python 编写，并以指定格式精确生成一行打印输出，其中包含上述案例以秒为单位、四舍五入到最接近整数的已接受时间步长。", "solution": "该问题要求为求解耦合了电离动力学的宇宙学辐射转移方程的显式数值格式，推导并实现一个复合时间步长约束。对于每个贡献的物理过程：空间平流、频率空间平流（宇宙学红移）、吸收和化学反应，其推导必须源于第一性原理。随后，此时间步长将用作电离更新的自适应步长控制算法的初始猜测值。\n\n提供的控制方程为：\n1.  比强度 $I(\\nu, t)$ 的宇宙学辐射转移方程 (RTE)：\n    $$\n    \\frac{\\partial I}{\\partial t} + c\\,\\mathbf{n}\\cdot\\nabla I - H\\,\\nu\\,\\frac{\\partial I}{\\partial \\nu} = - c\\,\\kappa\\, I + j\n    $$\n2.  电离分数 $x(t)$ 的速率方程：\n    $$\n    \\frac{dx}{dt} = \\Gamma(1 - x) - \\alpha_{\\mathrm{B}} n_{\\mathrm{H}} x^2\n    $$\n    该方程描述了光致电离和复合过程之间的平衡。显式速率函数为 $f(x) = \\frac{dx}{dt} = \\Gamma(1-x) - \\alpha_{\\mathrm{B}} n_{\\mathrm{H}} x^2$。\n\n我们现在将从这些方程推导所需的四个时间步长约束。\n\n**1. 空间平流约束 (Courant-Friedrichs-Lewy 条件)**\n\nRTE 中的项 $c\\,\\mathbf{n}\\cdot\\nabla I$ 表示光子以光速 $c$ 进行的空间输运。对于网格尺寸为 $\\Delta x$ 的均匀网格上的一维显式有限差分格式，必须满足 Courant-Friedrichs-Lewy (CFL) 条件以确保数值稳定性。该原则规定，数值依赖域必须包含物理依赖域。在平流的背景下，这意味着信息（这里是光子）在单个时间步长 $\\Delta t$ 内传播的距离不能超过一个网格单元。这表示为：\n$$\nc \\Delta t \\le \\Delta x\n$$\n问题引入了用户指定的 Courant 数 $C_x \\in (0, 1]$ 作为安全因子。因此，约束条件为：\n$$\nc \\Delta t \\le C_x \\Delta x\n$$\n解出 $\\Delta t$ 得到空间平流时间步长限制 $\\Delta t_x$：\n$$\n\\Delta t_x = C_x \\frac{\\Delta x}{c}\n$$\n\n**2. 频率空间平流约束 (红移)**\n\nRTE 中的项 $-H\\,\\nu\\,\\frac{\\partial I}{\\partial \\nu}$ 描述了由于宇宙的哈勃膨胀，光子在频率空间中的平流。该平流的“速度”为 $v_\\nu = \\frac{d\\nu}{dt} = -H\\nu$。与空间 CFL 条件类似，对于频率箱宽度为 $\\Delta \\nu$ 的频率网格上的显式格式，光子频率在一个时间步长 $\\Delta t$ 内的变化量不能大于频率箱宽度。频率变化的幅度为 $|\\Delta \\nu_{\\text{adv}}| = |v_\\nu| \\Delta t = H\\nu\\Delta t$。稳定性条件为：\n$$\nH\\nu\\Delta t \\le \\Delta \\nu\n$$\n引入频率空间 Courant 数 $C_\\nu$ 作为安全因子，我们得到：\n$$\nH\\nu\\Delta t \\le C_\\nu \\Delta \\nu\n$$\n解出 $\\Delta t$ 得到频率平流时间步长限制 $\\Delta t_\\nu$：\n$$\n\\Delta t_\\nu = C_\\nu \\frac{\\Delta \\nu}{H \\nu}\n$$\n\n**3. 吸收引起的强度变化约束**\n\nRTE 右侧的项 $-c\\,\\kappa\\,I$ 是一个表示光子吸收的汇项。仅由吸收引起的时间演化为 $\\frac{\\partial I}{\\partial t} = -c\\,\\kappa\\,I$。一个显式前向欧拉更新步骤是 $I^{n+1} = I^n - \\Delta t (c\\kappa I^n)$。问题要求将强度的分数变化 $\\frac{|I^{n+1} - I^n|}{I^n}$ 限制在用户指定的容差 $\\varepsilon_I$ 内。\n$$\n\\frac{|I^n - \\Delta t c\\kappa I^n - I^n|}{I^n} = \\frac{|-\\Delta t c\\kappa I^n|}{I^n} = c\\kappa\\Delta t \\le \\varepsilon_I\n$$\n这直接给出了吸收时间步长限制 $\\Delta t_I$：\n$$\n\\Delta t_I = \\frac{\\varepsilon_I}{c \\kappa}\n$$\n此条件确保了由于吸收，强度在一个步骤内不会发生大的分数变化，这对于准确性至关重要。\n\n**4. 电离分数变化约束**\n\n电离分数 $x$ 的演化由常微分方程 (ODE) $\\frac{dx}{dt} = f(x)$ 控制，其中 $f(x) = \\Gamma(1-x) - \\alpha_{\\mathrm{B}} n_{\\mathrm{H}} x^2$。与吸收约束类似，我们必须将每时间步长 $x$ 的分数变化限制在指定的准确性参数 $\\varepsilon_x$ 内。在一步长 $\\Delta t$ 内 $x$ 的变化近似为 $\\Delta x_{\\text{change}} \\approx \\Delta t \\left|\\frac{dx}{dt}\\right|$。分数变化为 $\\frac{|\\Delta x_{\\text{change}}|}{x}$。\n$$\n\\frac{\\Delta t \\left| f(x) \\right|}{x} \\le \\varepsilon_x\n$$\n解出 $\\Delta t$ 得到化学时间步长限制，我们表示为 $\\Delta t_{\\text{chem}}$：\n$$\n\\Delta t_{\\text{chem}} = \\frac{\\varepsilon_x x}{\\left| f(x) \\right|} = \\frac{\\varepsilon_x x}{\\left|\\Gamma(1-x) - \\alpha_{\\mathrm{B}} n_{\\mathrm{H}} x^2\\right|}\n$$\n如果系统接近平衡，分母 $|f(x)|$ 趋近于 $0$，$\\Delta t_{\\text{chem}}$ 会变得非常大。这在物理上是合理的，因为接近平衡时，变化的 timescale 很长。\n\n**复合时间步长和自适应控制**\n\n为确保所有物理过程的稳定性和准确性，总的提议时间步长 $\\Delta t_{\\mathrm{prop}}$ 必须是各个约束中的最小值：\n$$\n\\Delta t_{\\mathrm{prop}} = \\min(\\Delta t_x, \\Delta t_\\nu, \\Delta t_I, \\Delta t_{\\text{chem}})\n$$\n这个 $\\Delta t_{\\mathrm{prop}}$ 作为电离 ODE 自适应时间步进格式的初始猜测值。问题指定了一个基于单个前向欧拉步和两个半步的嵌入式误差估计器。\n给定当前状态 $x_n$ 和候选时间步长 $\\Delta t$：\n1.  计算全步更新：$x_{\\text{full}} = x_n + \\Delta t \\, f(x_n)$。\n2.  计算双步更新：$x_{\\text{half}} = x_n + \\frac{\\Delta t}{2} f(x_n)$，然后 $x_{\\text{two}} = x_{\\text{half}} + \\frac{\\Delta t}{2} f(x_{\\text{half}})$。\n3.  试探解必须保持在物理边界 $[0, 1]$ 内。\n4.  局部截断误差估计为 $e = |x_{\\text{full}} - x_{\\text{two}}|$。对于此方法，较不准确的解（$x_{\\text{full}}$）的误差阶为 $\\mathcal{O}(\\Delta t^2)$。\n5.  如果 $e \\le \\mathrm{tol}_x$，则接受该步长，其中 $\\mathrm{tol}_x$ 是给定的容差。\n6.  如果被拒绝，则使用嵌入式 Runge-Kutta 方法的标准控制律计算一个新的、更小的时间步长 $\\Delta t_{\\text{new}}$，其目标是 $e_{\\text{new}} \\approx \\mathrm{tol}_x$：\n    $$\n    \\Delta t_{\\text{new}} = S \\cdot \\Delta t_{\\text{old}} \\left( \\frac{\\mathrm{tol}_x}{e} \\right)^{1/p}\n    $$\n    其中 $p=2$ 是误差估计器的阶数，$S$ 是一个安全因子（例如，$S=0.9$）。使用 $\\Delta t_{\\text{new}}$ 重复此过程，直到步长被接受。最终接受的时间步长是给定测试用例的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements an adaptive time-step constraint for cosmological\n    radiative transfer and ionization kinetics.\n    \"\"\"\n    # Universal constant\n    C_LIGHT = 2.99792458e8  # Speed of light in m/s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (general case)\n        {'dx': 3.086e19, 'dnu': 1.0e14, 'nu': 3.0e15, 'H': 1.0e-17, 'kappa': 1.3e-19,\n         'nH': 200.0, 'Gamma': 1.0e-12, 'alphaB': 2.6e-19, 'x0': 0.10,\n         'Cx': 0.90, 'Cnu': 0.90, 'eps_I': 0.02, 'eps_x': 0.01, 'tol_x': 1.0e-4},\n        # Test Case 2 (small spatial cell boundary)\n        {'dx': 1.0e16, 'dnu': 1.0e14, 'nu': 3.0e15, 'H': 1.0e-17, 'kappa': 1.3e-19,\n         'nH': 200.0, 'Gamma': 5.0e-13, 'alphaB': 2.6e-19, 'x0': 0.50,\n         'Cx': 0.90, 'Cnu': 0.90, 'eps_I': 0.02, 'eps_x': 0.02, 'tol_x': 1.0e-5},\n        # Test Case 3 (strong absorption edge case)\n        {'dx': 3.086e19, 'dnu': 1.0e14, 'nu': 3.0e15, 'H': 1.0e-17, 'kappa': 1.0e-16,\n         'nH': 200.0, 'Gamma': 1.0e-13, 'alphaB': 2.6e-19, 'x0': 0.01,\n         'Cx': 0.90, 'Cnu': 0.90, 'eps_I': 0.01, 'eps_x': 0.005, 'tol_x': 1.0e-6},\n        # Test Case 4 (cosmological redshift dominated)\n        {'dx': 3.086e22, 'dnu': 1.0e9, 'nu': 3.0e15, 'H': 5.0e-16, 'kappa': 1.3e-19,\n         'nH': 200.0, 'Gamma': 1.0e-14, 'alphaB': 2.6e-19, 'x0': 0.90,\n         'Cx': 0.90, 'Cnu': 0.90, 'eps_I': 0.02, 'eps_x': 0.01, 'tol_x': 1.0e-4},\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # --- Part 1: Calculate the composite proposed time-step ---\n\n        # Spatial advection constraint (CFL)\n        dt_x = params['Cx'] * params['dx'] / C_LIGHT\n\n        # Frequency-space advection constraint (Redshift)\n        denom_nu = params['H'] * params['nu']\n        dt_nu = (params['Cnu'] * params['dnu'] / denom_nu) if denom_nu > 0 else np.inf\n\n        # Absorption constraint\n        denom_I = C_LIGHT * params['kappa']\n        dt_I = (params['eps_I'] / denom_I) if denom_I > 0 else np.inf\n\n        # Define the ionization rate function f(x) = dx/dt\n        def f_chem(x, p):\n            ion_term = p['Gamma'] * (1.0 - x)\n            recomb_term = p['alphaB'] * p['nH'] * x**2\n            return ion_term - recomb_term\n\n        # Chemistry constraint\n        rate_at_x0 = f_chem(params['x0'], params)\n        if abs(rate_at_x0)  np.finfo(float).eps:\n            dt_chem = np.inf\n        else:\n            dt_chem = params['eps_x'] * params['x0'] / abs(rate_at_x0)\n        \n        # Composite proposed time-step is the minimum of all constraints\n        dt_prop = min(dt_x, dt_nu, dt_I, dt_chem)\n\n        # --- Part 2: Adaptive step acceptance for ionization update ---\n        \n        dt_current = dt_prop\n        accepted_dt = None\n        \n        # Parameters for adaptive control\n        max_iterations = 50\n        safety_factor = 0.9 \n        # The exponent in the update rule is 1/p, where p=2 for this scheme.\n        power = 0.5 \n\n        for _ in range(max_iterations):\n            f = lambda x: f_chem(x, params)\n            \n            # Compute full-step update (Euler method)\n            x_full = params['x0'] + dt_current * f(params['x0'])\n            x_full = np.clip(x_full, 0.0, 1.0) # Enforce physical bounds\n            \n            # Compute two half-step update (embedded method)\n            x_half = params['x0'] + (dt_current / 2.0) * f(params['x0'])\n            x_half = np.clip(x_half, 0.0, 1.0) # Enforce physical bounds\n            \n            x_two = x_half + (dt_current / 2.0) * f(x_half)\n            x_two = np.clip(x_two, 0.0, 1.0) # Enforce physical bounds\n            \n            # Estimate local error\n            error = abs(x_full - x_two)\n            \n            # Acceptance criterion\n            if error = params['tol_x']:\n                accepted_dt = dt_current\n                break\n            \n            # Step rejection and update of dt\n            # If error is zero, the step should be accepted.\n            # Add a small epsilon to denominator for robustness in case error is tiny.\n            if error > 0:\n                dt_current = safety_factor * dt_current * (params['tol_x'] / error)**power\n            else:\n                # Should not happen as error=0 implies acceptance, but as a failsafe\n                # If the error is truly zero, the step is perfect. We can increase it. \n                # Capping the increase to avoid runaway.\n                dt_current *= 2.0 \n\n        if accepted_dt is None:\n            # If the loop finishes without acceptance (unlikely for this problem),\n            # we use the last computed time step as a failsafe.\n            accepted_dt = dt_current\n            \n        # Round the accepted time step to the nearest integer second.\n        # (int(x + 0.5) for positive x rounds half up)\n        results.append(int(accepted_dt + 0.5))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3469642"}, {"introduction": "宇宙结构形成所涉及的尺度范围极为巨大，这使得均匀计算网格的成本高得令人望而却步。自适应网格加密（AMR）技术通过将分辨率集中在最需要的地方来解决这个问题，但这也带来了在粗细网格间传递物理量的挑战。本实践聚焦于至关重要的守恒原理，指导您实现一个重映算法，以确保像光子数这样的量在网格加密和粗化过程中是守恒的[@problem_id:3469649]。", "problem": "考虑一维周期性域中宇宙学辐射转移的矩量公式。设辐射场由其单位长度的矩量表示：辐射能量密度 $E$、辐射通量 $F$ 和光子数密度 $N$。对于每个宽度为 $\\Delta x$、中心位置为 $x_i$ 的单元 $i$，将单元平均矩量定义为 $M_i = (E_i, F_i, N_i)$，其中 $E_i$、$F_i$ 和 $N_i$ 是该单元上的平均值。自适应网格加密（AMR）操作在粗网格和细网格之间映射矩量。您的任务是为矩量向量 $M = (E, F, N)$ 在 AMR 加密和粗化操作中实现一个守恒重映算法，并证明光子数的 $L^1$ 范数守恒到机器精度。\n\n基本原理：\n- 光子数矩 $N$ 是比强度 $I_\\nu$ 的零阶角频率矩，$N = \\int \\int (I_\\nu / h\\nu)\\,\\mathrm{d}\\Omega\\,\\mathrm{d}\\nu$，在物理真实场景中是非负的。\n- 在网格重映下，一个量的守恒性通过其操作前后的体积分相等来证明。\n- 一个空间域上的非负标量场 $N(x)$ 的 $L^1$ 范数是 $\\|N\\|_1 = \\int |N(x)|\\,\\mathrm{d}x = \\int N(x)\\,\\mathrm{d}x$。\n\n算法要求：\n1. 实现一个长度为 $L$ 的一维周期性域，离散为 $n$ 个宽度为 $\\Delta x = L/n$ 的粗单元，粗单元中心为 $x_i = (i+1/2)\\Delta x$，其中 $i$ 为整数。\n2. 为 AMR 定义一个加密因子 $r \\in \\mathbb{N}$。加密操作将每个粗单元映射为 $r$ 个宽度为 $\\Delta x_f = \\Delta x/r$ 的细子单元，子单元的中点位于父单元内部。\n3. 加密必须在每个粗单元内对每个矩量分量使用分段线性重构：\n   - 对每个粗单元 $i$，重构 $m(x) = a_i + s_i (x - x_i)$，其中 $a_i$ 是该矩量的粗单元平均值，$s_i$ 是一个受限斜率。\n   - 使用带有周期性邻居的 MinMod 限制器估算斜率以防止伪振荡：$s_i = \\operatorname{minmod}\\big((a_i - a_{i-1})/\\Delta x,(a_{i+1} - a_i)/\\Delta x\\big)$，其中如果 $uv \\le 0$，$\\operatorname{minmod}(u,v)$ 等于 $0$，否则等于 $\\operatorname{sign}(u)\\min(|u|,|v|)$。\n   - 对于光子数密度 $N$，通过限制 $|s_i| \\le a_i / \\delta_{\\max}$ 来在加密中强制保持正性，其中 $\\delta_{\\max}$ 是任意子单元中点与 $x_i$ 的最大绝对偏移量；这确保了对于父单元内所有子单元中点偏移量 $\\delta$，都有 $a_i + s_i \\delta \\ge 0$。\n   - 为每个细子单元分配等于在其中心点处求值的线性重构的矩量值。对于线性函数，中点法则对于子单元积分是精确的，从而确保了加密过程中父单元平均值的守恒。\n4. 粗化必须通过体积加权平均将细子单元的矩量映射回粗单元的矩量。对于大小相等的子单元，这简化为每个父单元内子单元值的算术平均值。\n5. 数值上证明，光子数的 $L^1$ 范数（定义为积分 $\\sum_i N_i \\Delta x$）在经过一次加密后粗化的操作后，在机器精度范围内是守恒的。\n\n科学真实性：\n- 将域视为周期性的。\n- 确保所有粗单元的 $N_i \\ge 0$；通过所选的限制器应在加密期间保持正性。\n\n您的程序必须实现上述操作，并为每个测试用例输出执行加密后粗化操作前后总光子数的绝对差。将每个差值表示为代表光子数的浮点数。不涉及角度。程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3]”）。\n\n测试套件：\n- 测试 1（均匀场，理想情况）：$L = 1.0$，$n = 8$，$r = 2$，粗单元矩量初始化为对所有 $i$ 都有 $E_i = 10.0$，$F_i = 0.5$，$N_i = 3.0$。\n- 测试 2（平滑非均匀、周期性）：$L = 2.0$，$n = 16$，$r = 4$，使用 $x_i = (i+1/2)\\Delta x$ 初始化粗单元矩量：\n  - $E_i = 2.0 + 0.1 \\cos(4\\pi x_i / L)$，\n  - $F_i = 0.05 \\sin(2\\pi x_i / L)$，\n  - $N_i = 1.0 + 0.2 \\sin(2\\pi x_i / L)$。\n- 测试 3（具有极值和零的边界情况）：$L = 1.0$，$n = 4$，$r = 3$，粗单元矩量对所有 $i$ 为 $E_i = 1.0$，对所有 $i$ 为 $F_i = 0.0$，以及 $N = [10^{-300}, 10^{5}, 2.0, 0.0]$。\n- 测试 4（强梯度，正性压力测试）：$L = 1.0$，$n = 10$，$r = 5$，粗单元矩量初始化为 $E_i = 1.0 + 0.01 i$，$F_i = 0.3 i (-1)^i$ 以及 $N_i = i^2$，其中 $i = 0,1,\\dots,9$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试 1 到测试 4 的绝对 $L^1$ 光子数差异，格式为用方括号括起来的逗号分隔列表，单位为光子数，例如，“[d1,d2,d3,d4]”。", "solution": "问题陈述要求实现并验证一种用于在一维周期性网格上进行自适应网格加密（AMR）的辐射矩量向量的守恒重映算法。核心任务是证明总光子数（由光子数密度 $N$ 的 $L^1$ 范数表示）在经历一个网格加密和粗化的循环后，在机器精度范围内是守恒的。\n\n守恒原理在以连续性方程表示的物理定律的数值解中至关重要。如果计算域内的总积分量在没有源、汇或穿过域边界的通量的情况下保持不变，则该数值格式是守恒的。对于 AMR，这意味着在加密后，父单元中的总数量必须等于其子单元中数量的总和，粗化过程则反之亦然。所提出的算法在构造上被设计为完全守恒的。\n\n设一维周期性域的长度为 $L$，离散为 $n$ 个粗单元。每个粗单元 $i$（$i \\in \\{0, \\dots, n-1\\}$）的宽度为 $\\Delta x = L/n$，其中心位于 $x_i = (i+1/2)\\Delta x$。系统的状态由单元平均矩量向量 $M_i = (E_i, F_i, N_i)$ 描述。域中的总光子数，由于 $N \\ge 0$ 而等价于 $N$ 的 $L^1$ 范数，由 $\\sum_{i=0}^{n-1} N_i \\Delta x$ 给出。\n\nAMR 操作定义如下：\n\n**1. 加密（从粗到细的映射）**\n\n加密操作将一个粗父单元替换为 $r$ 个更小的、等宽的子单元，其中 $r$ 是加密因子。每个子单元的宽度为 $\\Delta x_f = \\Delta x / r$。为了在保持守恒的同时为这些新的细单元赋值，在每个父单元内执行数据的子网格重构。\n\n- **分段线性重构**：对于每个矩量分量（例如 $E, F,$ 或 $N$），在每个粗单元 $i$ 内重构一个线性函数 $m(x)$。选择此函数使其在单元上的平均值等于已知的粗单元平均值 $a_i$。重构的形式为 $m(x) = a_i + s_i (x - x_i)$，其中 $s_i$ 是一个经过仔细选择的斜率。对 $m(x)$ 在单元 $i$ 上（从 $x_i - \\Delta x/2$ 到 $x_i + \\Delta x/2$）进行积分，可以确认其平均值为 $a_i$，因为奇函数项 $s_i(x-x_i)$ 的积分为零。\n\n- **斜率限制**：一种朴素的斜率计算可能会在陡峭梯度附近引入伪振荡（吉布斯现象）。为防止这种情况，采用了斜率限制器。问题指定了 MinMod 限制器，这是确保单调性的标准选择。斜率 $s_i$ 通过比较后向和前向差分斜率来计算：\n$$s_i = \\operatorname{minmod}\\left(\\frac{a_i - a_{i-1}}{\\Delta x}, \\frac{a_{i+1} - a_i}{\\Delta x}\\right)$$\n邻居 $a_{i-1}$ 和 $a_{i+1}$ 使用周期性边界条件确定。$\\operatorname{minmod}(u,v)$ 函数在两参数符号相同时返回绝对值较小的参数，否则返回零。这种选择会在局部极值处使重构变得平坦，从而防止过冲和下冲。\n\n- **正性保持**：光子数密度 $N$ 是一个物理上的非负量。如果斜率 $s_i$ 太陡，线性重构 $N(x) = N_i + s_i(x - x_i)$ 可能会在单元边缘产生负值。为了强制保持正性，需要进一步约束 $N$ 分量的斜率大小。重构值在所有细单元中点处必须为非负。细单元中点与其父单元中心的最大距离是 $\\delta_{\\max}$。对于有 $r$ 个子单元的父单元，此距离为 $\\delta_{\\max} = \\frac{\\Delta x}{2}(1 - 1/r)$。在单元内所有求值点上 $N(x) \\ge 0$ 的条件意味着 $|s_i| \\le N_i / \\delta_{\\max}$。此界限应用于通过 MinMod 限制器计算出的斜率 $s_i$ 之后。\n\n- **细单元赋值**：问题指定赋给细子单元的值是在子单元中点处求值的线性重构值。线性函数的一个关键属性是，一个区间中点处的值完全等于该函数在该区间上的平均值。因此，该赋值方法精确地计算了重构剖面下每个细单元的单元平均值。对 $r$ 个子单元的总光子数求和得到 $\\sum_{j=0}^{r-1} N^{\\text{fine}}_{ij} \\Delta x_f = \\sum_{j=0}^{r-1} [N_i + s_i(x_{ij} - x_i)] \\Delta x_f = r N_i \\Delta x_f + s_i \\Delta x_f \\sum_{j=0}^{r-1} (x_{ij} - x_i)$。由于子单元的对称布局，偏移量之和 $\\sum (x_{ij} - x_i)$ 为零。因此，子单元中的总光子数为 $r N_i \\Delta x_f = r N_i (\\Delta x / r) = N_i \\Delta x$，这恰好是父单元的光子数。因此，加密步骤是完全守恒的。\n\n**2. 粗化（从细到粗的映射）**\n\n粗化是加密的逆操作。它将 $r$ 个子单元的值映射回单个父单元。守恒原理规定，粗化后的值必须是子单元值的体积加权平均值。由于所有子单元的宽度 $\\Delta x_f$ 相同，这简化为算术平均值：\n$$a_i^{\\text{coarse}} = \\frac{1}{r} \\sum_{j=0}^{r-1} a_{ij}^{\\text{fine}}$$\n新粗单元中的总数量为 $a_i^{\\text{coarse}} \\Delta x = (\\frac{1}{r} \\sum_{j=0}^{r-1} a_{ij}^{\\text{fine}}) (r \\Delta x_f) = \\sum_{j=0}^{r-1} a_{ij}^{\\text{fine}} \\Delta x_f$，这正是细单元中数量的总和。因此，粗化步骤也是完全守恒的。\n\n**3. 守恒性验证**\n\n由于加密和粗化操作在数学上都被设计为完全守恒的，因此对初始数据集执行一个加密后粗化的循环应该能精确地返回原始数据集。程序将计算此循环前的总光子数 $I_{\\text{initial}} = \\sum (N_i \\Delta x)$ 和循环后的总光子数 $I_{\\text{final}} = \\sum (N'_i \\Delta x)$。绝对差 $|I_{\\text{initial}} - I_{\\text{final}}|$ 在浮点运算精度范围内应为零。所实现的代码将为几个测试用例计算此差异，以数值方式证明这一守恒特性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the AMR remapping simulation for all test cases.\n    \"\"\"\n\n    def minmod(u, v):\n        \"\"\"\n        Calculates the MinMod function.\n        Returns the argument with the smallest absolute value if signs are the same,\n        otherwise returns 0.\n        \"\"\"\n        if u * v = 0:\n            return 0.0\n        elif abs(u)  abs(v):\n            return u\n        else:\n            return v\n\n    def remap(coarse_moments, L, n, r):\n        \"\"\"\n        Performs a full refinement-then-coarsening cycle.\n        \n        Args:\n            coarse_moments (np.array): Array of shape (n, 3) for (E, F, N).\n            L (float): Domain length.\n            n (int): Number of coarse cells.\n            r (int): Refinement factor.\n\n        Returns:\n            np.array: The new coarse moments array of shape (n, 3) after the cycle.\n        \"\"\"\n        \n        # --- Refinement Step ---\n        dx = L / n\n        dx_f = dx / r\n        num_fine_cells = n * r\n        fine_moments = np.zeros((num_fine_cells, 3))\n        \n        # Max offset for positivity constraint on N\n        # This is max(|x_fine_midpoint - x_coarse_midpoint|)\n        # delta_max is 0 if r=1, but problem constraints ensure r>1\n        delta_max = (dx / 2.0) * (1.0 - 1.0 / r) if r > 1 else 0.0\n\n        # Process each moment component (E, F, N)\n        for k in range(3):\n            moment_component = coarse_moments[:, k]\n            \n            for i in range(n):\n                # Periodic boundary conditions for neighbors\n                i_prev = (i - 1 + n) % n\n                i_next = (i + 1) % n\n                \n                a_i = moment_component[i]\n                a_prev = moment_component[i_prev]\n                a_next = moment_component[i_next]\n\n                # Calculate slope with MinMod limiter\n                s_i = minmod((a_i - a_prev) / dx, (a_next - a_i) / dx)\n\n                # Enforce positivity for the N component (k=2)\n                if k == 2 and a_i > 0 and delta_max > 0:\n                    max_slope_mag = a_i / delta_max\n                    s_i = np.sign(s_i) * min(abs(s_i), max_slope_mag)\n                elif k == 2 and a_i == 0:\n                    s_i = 0.0\n\n                # Assign values to the r fine child cells\n                for j in range(r):\n                    # Offset of fine cell midpoint from coarse cell midpoint\n                    offset = dx * ((j + 0.5) / r - 0.5)\n                    fine_val = a_i + s_i * offset\n                    \n                    fine_idx = i * r + j\n                    fine_moments[fine_idx, k] = fine_val\n\n        # --- Coarsening Step ---\n        coarsened_moments = np.zeros((n, 3))\n        for i in range(n):\n            # The children of coarse cell i are in the slice [i*r : (i+1)*r]\n            start_idx = i * r\n            end_idx = (i + 1) * r\n            \n            # Average the fine cell values to get the new coarse cell value\n            for k in range(3):\n                coarsened_moments[i, k] = np.mean(fine_moments[start_idx:end_idx, k])\n                \n        return coarsened_moments\n\n\n    test_cases = [\n        {\n            \"L\": 1.0, \"n\": 8, \"r\": 2,\n            \"moments\": np.array([[10.0, 0.5, 3.0] for _ in range(8)])\n        },\n        {\n            \"L\": 2.0, \"n\": 16, \"r\": 4,\n            \"init_func\": lambda x, L: [\n                2.0 + 0.1 * np.cos(4 * np.pi * x / L),\n                0.05 * np.sin(2 * np.pi * x / L),\n                1.0 + 0.2 * np.sin(2 * np.pi * x / L)\n            ]\n        },\n        {\n            \"L\": 1.0, \"n\": 4, \"r\": 3,\n            \"moments\": np.array([\n                [1.0, 0.0, 1e-300],\n                [1.0, 0.0, 1e5],\n                [1.0, 0.0, 2.0],\n                [1.0, 0.0, 0.0]\n            ])\n        },\n        {\n            \"L\": 1.0, \"n\": 10, \"r\": 5,\n            \"moments\": np.array([\n                [1.0 + 0.01 * i, 0.3 * i * ((-1)**i), float(i**2)]\n                for i in range(10)\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        n = case[\"n\"]\n        r = case[\"r\"]\n        dx = L / n\n        \n        if \"moments\" in case:\n            initial_moments = case[\"moments\"]\n        else:\n            # Initialize moments from function\n            x_centers = (np.arange(n) + 0.5) * dx\n            initial_moments = np.array([case[\"init_func\"](x, L) for x in x_centers])\n\n        # Get initial photon number density vector N\n        N_initial = initial_moments[:, 2]\n        \n        # Calculate total initial photon number (L1 norm of N)\n        total_N_initial = np.sum(N_initial) * dx\n\n        # Perform the remapping cycle\n        final_moments = remap(initial_moments, L, n, r)\n        \n        # Get final photon number density vector N\n        N_final = final_moments[:, 2]\n        \n        # Calculate total final photon number\n        total_N_final = np.sum(N_final) * dx\n        \n        # Calculate the absolute difference to check for conservation\n        abs_difference = abs(total_N_initial - total_N_final)\n        results.append(abs_difference)\n    \n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3469649"}]}