{"hands_on_practices": [{"introduction": "这项练习专注于丝绸阻尼的核心物理原理。通过创建 [@problem_id:3463811] 中描述的简化数值实验，你将直接测试并验证光子散射率与扩散阻尼尺度 $k_D$ 之间的基本关系。这项实践对于建立汤姆逊散射的微观物理如何转化为对宇宙学扰动的宏观阻尼效应的直觉至关重要。", "problem": "要求您设计并实现一个独立的数值实验，以在一个受控的玩具模型中验证宇宙微波背景（CMB）中丝绸扩散阻尼尺度的标度关系。该场景涉及紧密耦合的光子-重子流体中的声波振荡，以及由于光子扩散（丝绸阻尼）而在小尺度上对这些振荡的抑制。您的程序必须在散射项中的汤姆孙散射截面受控变化的情况下，计算出阻尼波数的数值估计。\n\n从以下适用于复合时期附近紧密耦合的、经过充分检验的基础模型开始：\n\n- 紧密耦合的光子-重子流体经历声波振荡，其扩散阻尼通常通过一个应用于傅里叶空间温度微扰的指数包络因子来捕捉。\n- 阻尼波数的定义使得扩散包络具有 $\\exp[-(k/k_D)^2]$ 的形式。\n- 一个标准且广泛使用的扩散尺度表示方法，是以共形时间 $\\eta$ 为积分变量，对光子平均自由程进行加权积分，权重由模式传播物理决定：\n  $$\\frac{1}{k_D^2(\\eta)} \\equiv \\int^{\\eta} d\\eta' \\, \\frac{1}{6 \\, \\kappa'(\\eta')} \\left[\\frac{16}{15(1+R(\\eta'))} + \\frac{R(\\eta')^2}{(1+R(\\eta'))^2}\\right],$$\n  其中 $\\kappa'(\\eta)$ 是单位共形时间内的微分汤姆孙光学厚度，$R(\\eta)$ 是由 $R \\equiv \\frac{3 \\rho_b}{4 \\rho_\\gamma}$ 定义的重子负载比。\n- 复合时期光子扩散阻尼在谐空间中的包络可以通过使用一个固定的到最后散射面的共动角直径距离 $\\chi_\\star$ 将波数映射到多极矩来建模，其中\n  $\\ell \\approx k \\, \\chi_\\star$，\n  多极矩空间中的阻尼因子为\n  $$\\mathcal{D}_\\ell \\equiv \\exp\\!\\left[-\\left(\\frac{\\ell}{\\ell_D}\\right)^2\\right], \\quad \\ell_D \\equiv k_D \\, \\chi_\\star.$$\n\n为了隔离和测试标度关系，采用一个受控的玩具模型，该模型在复合的狭窄窗口内保持背景近似恒定，同时允许对汤姆孙散射截面进行受控的重标度。具体来说，实现以下建模选择：\n\n- 在归一化单位下工作，其中未标度的汤姆孙散射截面为单位1。引入一个无量纲标度参数 $\\lambda$ 和一个恒定的自由电子共动数密度 $n_e$，使得微分光学厚度为\n  $$\\kappa'(\\eta) = a(\\eta) \\, n_e \\, \\lambda,$$\n  其中在整个积分窗口内，尺度因子 $a(\\eta) \\equiv 1$ 保持恒定。这模拟了在固定的 $n_e$ 下对散射强度进行 $\\sigma_T \\to \\lambda \\sigma_T$ 的受控重标度。\n- 采用一个恒定的重子负载 $R(\\eta) \\equiv R_\\star$，其中 $R_\\star = 0.6$，代表复合时期。\n- 将积分限制在一个单位宽度的共形时间区间 $\\eta \\in [0,1]$ 内，该区间代表最后散射的可见性窗口。这样做可以在不失一般性的前提下，为标度测试将积分域归一化。\n- 使用一个固定的共动距离 $\\chi_\\star = 14000$（在相同的归一化单位下）将波数映射到多极矩。\n\n根据这些选择，您的程序必须：\n\n1. 数值计算积分\n   $$\\frac{1}{k_D^2} = \\int_0^1 d\\eta \\, \\frac{1}{6 \\, \\kappa'} \\left[\\frac{16}{15(1+R_\\star)} + \\frac{R_\\star^2}{(1+R_\\star)^2}\\right]$$\n   在 $\\eta$ 的均匀网格上进行，不使用解析简化。然后通过 $k_D = \\left(\\frac{1}{k_D^2}\\right)^{-1/2}$ 获得 $k_D$。\n2. 对于任意的 $\\lambda$ 和 $n_e$，在多极矩空间中构建阻尼包络，使用\n   $$\\mathcal{D}_\\ell(\\lambda, n_e) = \\exp\\!\\left[-\\left(\\frac{\\ell}{\\ell_D(\\lambda,n_e)}\\right)^2\\right], \\quad \\ell_D(\\lambda,n_e) = k_D(\\lambda,n_e) \\, \\chi_\\star.$$\n3. 通过数值数据估计对数斜率，数值上展示 $k_D$ 随重标度散射强度的标度关系如何出现。\n\n待您程序实现和评估的测试套件：\n\n- 使用以下具体的参数集和输出。所有输出均为无量纲浮点数。\n- 案例 A（常规路径）：固定 $n_e = 1.0$，对 $\\lambda \\in \\{0.25, 0.5, 1.0, 2.0, 4.0\\}$ 计算 $k_D$。使用最小二乘法对 $\\ln k_D$ 与 $\\ln \\lambda$ 的关系进行线性拟合，并返回拟合的斜率（一个浮点数）。\n- 案例 B（独立的密度标度关系）：固定 $\\lambda = 1.0$，对 $n_e \\in \\{0.25, 0.5, 1.0, 2.0, 4.0\\}$ 计算 $k_D$。对 $\\ln k_D$ 与 $\\ln n_e$ 的关系进行线性拟合，并返回拟合的斜率（一个浮点数）。\n- 案例 C（在多极矩间的确认）：固定 $n_e = 1.0$，对 $\\lambda \\in \\{0.25, 0.5, 1.0, 2.0, 4.0\\}$。对于从 $\\ell = 1000$ 到 $\\ell = 4000$、步长为 $\\Delta \\ell = 250$ 的均匀网格上的每个 $\\ell$，计算 $\\mathcal{D}_\\ell(\\lambda,1.0)$，并定义 $Y_\\ell(\\lambda) \\equiv -\\ln \\mathcal{D}_\\ell(\\lambda,1.0)$。对每个 $\\ell$ 分别进行 $\\ln Y_\\ell$ 与 $\\ln \\lambda$ 的线性拟合，并计算斜率。返回在网格中所有 $\\ell$ 上，这些斜率与值 $-1$ 的最大绝对偏差（一个浮点数）。\n- 案例 D（边界条件与动态范围）：固定 $n_e = 1.0$，对极端重标度 $\\lambda \\in \\{0.05, 20.0\\}$ 计算 $k_D$。仅使用这两点，计算 $\\ln k_D$ 与 $\\ln \\lambda$ 的两点斜率，并将其作为一个浮点数返回。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，包含一个由方括号括起来的、用逗号分隔的结果列表，顺序为 [案例 A 结果, 案例 B 结果, 案例 C 结果, 案例 D 结果]。例如：“[0.5,0.5,0.0,0.5]”。\n- 输出中无需单位，因为所有结果都是无量纲的对数斜率或偏差。", "solution": "该问题陈述是数值宇宙学中一个有效且定义明确的练习。它要求实现一个数值实验，以在一个简化的光子-重子流体玩具模型中，验证复合时期附近丝绸扩散阻尼尺度 $k_D$ 的标度性质。所有参数、方程和简化假设都陈述清晰且对于所述目的而言科学合理。因此，我们将着手提供一个完整的解决方案。\n\n我们的方法是首先从所提供的方程中推导出预期的解析标度关系。这提供了一个理论预测，我们可以用它来验证我们的数值结果。然后，我们将设计并实现一个数值程序来计算阻尼尺度并执行指定的回归分析。\n\n**1. 理论基础与解析标度关系**\n\n该问题通过其平方的倒数来定义阻尼波数 $k_D$：\n$$\n\\frac{1}{k_D^2} = \\int_{0}^{1} d\\eta' \\, \\frac{1}{6 \\, \\kappa'(\\eta')} \\left[\\frac{16}{15(1+R_\\star)} + \\frac{R_\\star^2}{(1+R_\\star)^2}\\right]\n$$\n该玩具模型指定重子负载比 $R_\\star$ 是常数。具体来说，$R_\\star = 0.6$。微分光学厚度由 $\\kappa'(\\eta) = a(\\eta) n_e \\lambda$ 给出，其中尺度因子固定为 $a(\\eta)=1$。在这些假设下，整个被积函数相对于积分变量 $\\eta'$ 是一个常数。\n\n让我们定义一个常数 $C$，它包含了所有与标度参数 $\\lambda$ 和 $n_e$ 无关的项：\n$$\nC \\equiv \\frac{1}{6} \\left[\\frac{16}{15(1+R_\\star)} + \\frac{R_\\star^2}{(1+R_\\star)^2}\\right]\n$$\n被积函数随后简化为 $\\frac{C}{n_e \\lambda}$。由于这在积分区间 $\\eta' \\in [0, 1]$ 上是常数，该积分很容易计算：\n$$\n\\frac{1}{k_D^2} = \\int_{0}^{1} d\\eta' \\, \\frac{C}{n_e \\lambda} = \\frac{C}{n_e \\lambda} \\left(1 - 0\\right) = \\frac{C}{n_e \\lambda}\n$$\n由此，我们可以直接用 $\\lambda$ 和 $n_e$ 表示 $k_D$：\n$$\nk_D^2 = \\frac{n_e \\lambda}{C} \\implies k_D(\\lambda, n_e) = \\left(\\frac{1}{\\sqrt{C}}\\right) \\sqrt{n_e \\lambda}\n$$\n这个结果揭示了基本的标度关系。取自然对数，我们得到：\n$$\n\\ln k_D = \\frac{1}{2} \\ln \\lambda + \\frac{1}{2} \\ln n_e + \\ln\\left(\\frac{1}{\\sqrt{C}}\\right)\n$$\n此方程具有线性关系的形式。在固定的 $n_e$ 下，$\\ln k_D$ 相对于 $\\ln \\lambda$ 的斜率预测为精确的 $0.5$。同样，在固定的 $\\lambda$ 下，$\\ln k_D$ 相对于 $\\ln n_e$ 的斜率也预测为精确的 $0.5$。这些理论预测应该能被案例 A、B 和 D 中的数值拟合所重现。\n\n对于案例 C，我们考察量 $Y_\\ell(\\lambda) \\equiv -\\ln \\mathcal{D}_\\ell(\\lambda)$。多极矩空间中的阻尼包络是 $\\mathcal{D}_\\ell = \\exp[-(\\ell/\\ell_D)^2]$。\n$$\nY_\\ell(\\lambda) = -\\ln\\left(\\exp\\left[-\\left(\\frac{\\ell}{\\ell_D(\\lambda)}\\right)^2\\right]\\right) = \\left(\\frac{\\ell}{\\ell_D(\\lambda)}\\right)^2 = \\frac{\\ell^2}{\\ell_D^2(\\lambda)}\n$$\n阻尼多极矩为 $\\ell_D = k_D \\chi_\\star$，因此 $\\ell_D^2 = k_D^2 \\chi_\\star^2$。代入我们对 $k_D^2$ 的表达式（在此案例中 $n_e=1$）：\n$$\n\\ell_D^2(\\lambda) = \\left(\\frac{\\lambda}{C}\\right) \\chi_\\star^2\n$$\n因此，$Y_\\ell(\\lambda)$ 变为：\n$$\nY_\\ell(\\lambda) = \\frac{\\ell^2}{(\\lambda/C) \\chi_\\star^2} = \\left(\\frac{C \\ell^2}{\\chi_\\star^2}\\right) \\lambda^{-1}\n$$\n取自然对数以为线性拟合做准备：\n$$\n\\ln Y_\\ell(\\lambda) = \\ln\\left(\\frac{C \\ell^2}{\\chi_\\star^2}\\right) - \\ln \\lambda\n$$\n这预测了对于任何 $\\ell$ 值，$\\ln Y_\\ell$ 相对于 $\\ln \\lambda$ 的斜率都精确为 $-1.0$。数值实验应该会证实这一点，任何偏离 $-1.0$ 的值都可归因于积分和拟合过程中的数值精度误差。\n\n**2. 数值实现策略**\n\n程序的核心将是一个计算 $k_D(\\lambda, n_e)$ 的函数。尽管我们有该积分的解析解，但问题要求在均匀网格上进行数值计算，而不依赖于“常数的积分是常数乘以区间宽度”这一解析简化。我们将遵循这一要求，方法是在 $\\eta$ 从 $0$ 到 $1$ 的范围内定义一个均匀网格，在每个网格点上评估常数被积函数，并使用标准的数值求积法则 `numpy.trapz` 来计算积分。该方法对于线性函数是精确的，因此对于常数而言绰绰有余。\n\n总体算法如下：\n- 定义全局常数：$R_\\star = 0.6$ 和 $\\chi_\\star = 14000$。\n- 实现一个主函数 `compute_kD(lambda_val, ne_val)`，它将：\n    - 计算依赖于重子的常数因子。\n    - 根据输入的 $\\lambda$ 和 $n_e$ 定义被积函数的常数值。\n    - 为 $\\eta \\in [0, 1]$ 设置一个具有足够点数（例如，$N=1001$）的均匀网格。\n    - 创建一个与 $\\eta$ 网格对应的、包含常数被积函数值的数组。\n    - 使用 `numpy.trapz` 计算 $1/k_D^2$ 的积分。\n    - 返回 $k_D = (1/\\text{积分})^{-1/2}$。\n- 对于案例 A、B 和 D，我们将为指定的 $\\lambda$ 和 $n_e$ 范围计算 $k_D$。然后，我们将使用 `numpy.polyfit(log_x, log_y, 1)` 对变量的对数进行线性最小二乘拟合，该函数返回系数 `[斜率, 截距]`。对于案例 D，使用直接的两点斜率计算。\n- 对于案例 C，我们将遍历指定的多极矩 $\\ell$ 网格。对于每个 $\\ell$，我们在给定的 $\\lambda$ 值范围内计算 $Y_\\ell(\\lambda)$。然后，我们对 $\\ln Y_\\ell$ 与 $\\ln \\lambda$ 进行线性拟合以求得斜率。我们收集所有计算出的斜率，并找出这些斜率与理论值 $-1.0$ 之间的最大绝对差。\n\n这种结构化的方法确保了数值实验忠实地实现了问题描述，并且其结果可以直接与我们的解析预测进行比较，以确认物理模型和数值代码的有效性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the numerical experiment for Silk damping scaling.\n    \"\"\"\n\n    # --- Model Constants and Parameters ---\n    R_star = 0.6\n    chi_star = 14000.0\n    \n    # --- Test Suite Parameters ---\n    case_A_lambdas = np.array([0.25, 0.5, 1.0, 2.0, 4.0])\n    case_B_nes = np.array([0.25, 0.5, 1.0, 2.0, 4.0])\n    case_C_lambdas = np.array([0.25, 0.5, 1.0, 2.0, 4.0])\n    case_C_ells = np.arange(1000, 4001, 250)\n    case_D_lambdas = np.array([0.05, 20.0])\n\n    def compute_kD(lambda_val: float, ne_val: float) - float:\n        \"\"\"\n        Numerically computes the damping wavenumber k_D for given lambda and n_e.\n\n        The function adheres to the problem's instruction to perform a numerical\n        integration over a uniform grid, even though the integrand is constant.\n        \"\"\"\n        # Calculate constant physical terms based on the corrected formula\n        baryon_term = (16.0 / (15.0 * (1.0 + R_star))) + (R_star**2 / (1.0 + R_star)**2)\n\n        # Define the constant integrand\n        # kappa_prime = a * n_e * lambda, with a=1\n        kappa_prime = ne_val * lambda_val\n        integrand_val = (1.0 / (6.0 * kappa_prime)) * baryon_term\n\n        # Set up the integration grid\n        N_grid = 1001  # Sufficient resolution for a constant integrand\n        eta_grid = np.linspace(0.0, 1.0, N_grid)\n\n        # Evaluate the integrand on the grid\n        integrand_array = np.full_like(eta_grid, integrand_val)\n\n        # Numerically compute the integral for 1/k_D^2 using the trapezoidal rule\n        one_over_kD2 = np.trapz(integrand_array, eta_grid)\n        \n        # Calculate and return k_D\n        kD = np.sqrt(1.0 / one_over_kD2)\n        return kD\n\n    def fit_log_log_slope(x: np.ndarray, y: np.ndarray) - float:\n        \"\"\"\n        Performs a linear least-squares fit to log(y) vs log(x) and returns the slope.\n        \"\"\"\n        log_x = np.log(x)\n        log_y = np.log(y)\n        slope, _ = np.polyfit(log_x, log_y, 1)\n        return slope\n\n    # --- Case A: Scaling with lambda ---\n    ne_A = 1.0\n    kD_vals_A = np.array([compute_kD(l, ne_A) for l in case_A_lambdas])\n    slope_A = fit_log_log_slope(case_A_lambdas, kD_vals_A)\n\n    # --- Case B: Scaling with n_e ---\n    lambda_B = 1.0\n    kD_vals_B = np.array([compute_kD(lambda_B, n) for n in case_B_nes])\n    slope_B = fit_log_log_slope(case_B_nes, kD_vals_B)\n    \n    # --- Case C: Confirmation across multipoles ---\n    ne_C = 1.0\n    slopes_C = []\n    for ell in case_C_ells:\n        Y_vals = []\n        for l_val in case_C_lambdas:\n            kD = compute_kD(l_val, ne_C)\n            ell_D = kD * chi_star\n            # D_ell = exp(-(ell/ell_D)^2)\n            # Y_ell = -log(D_ell) = (ell/ell_D)^2\n            Y_ell = (ell / ell_D)**2\n            Y_vals.append(Y_ell)\n        \n        current_slope = fit_log_log_slope(case_C_lambdas, np.array(Y_vals))\n        slopes_C.append(current_slope)\n    \n    deviations = np.abs(np.array(slopes_C) - (-1.0))\n    result_C = np.max(deviations)\n\n    # --- Case D: Two-point slope for extreme rescalings ---\n    ne_D = 1.0\n    kD_vals_D = np.array([compute_kD(l, ne_D) for l in case_D_lambdas])\n    \n    log_kD_0, log_kD_1 = np.log(kD_vals_D[0]), np.log(kD_vals_D[1])\n    log_lambda_0, log_lambda_1 = np.log(case_D_lambdas[0]), np.log(case_D_lambdas[1])\n    \n    slope_D = (log_kD_1 - log_kD_0) / (log_lambda_1 - log_lambda_0)\n\n    # --- Final Output ---\n    results = [slope_A, slope_B, result_C, slope_D]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3463811"}, {"introduction": "在理想化模型的基础上，这项实践 [@problem_id:3463818] 转向了更真实的宇宙学背景。你将通过实现并比较两种等效的方法——直接积分和求解常微分方程 (ODE) ——来计算复合时期扩散阻尼尺度的累积过程。这项练习展示了如何处理演化中的宇宙学参数，并深入探讨了求解早期宇宙刚性方程组所需的数值技术。", "problem": "你需要通过两种数学上等价的途径计算宇宙微波背景 (CMB, Cosmic Microwave Background) 中的共动光子扩散阻尼波数 $k_D$ (Silk 阻尼)，并对它们的数值等价性进行基准测试，同时识别出标准近似预计会失效的、有物理动机的区间。这两种途径是：(i) 对共形时间 $\\eta$ 的直接积分，以及 (ii) 关于量 $y(\\eta) \\equiv k_D^{-2}(\\eta)$ 的一个以 $\\eta$ 为变量的微分演化方程。物理设定是在一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙中，存在一个紧密耦合的光子-重子流体，其中包含物质和辐射组分（在早期忽略暗能量）。你的推导和实现必须从以下基本出发点开始：\n\n- 耦合流体和辐射输运的能量-动量守恒，其中汤姆孙散射由汤姆孙散射截面 $\\sigma_T$ 和电子数密度 $n_e$ 表征。\n- 共形时间 $\\eta$ 的定义为 $d\\eta = dt/a$，其中 $a$ 是标度因子，$t$ 是宇宙时。\n- 在一个空间平坦的 FLRW 宇宙中的哈勃膨胀，包含非相对论性物质能量密度参数 $\\Omega_m$ 和相对论性物质能量密度参数 $\\Omega_r$，其关系为 $H(a) = H_0 \\sqrt{\\Omega_m a^{-3} + \\Omega_r a^{-4}}$。\n- 当今的临界密度 $\\rho_{c0} = 3 H_0^2 / (8 \\pi G)$，以及当今的光子能量密度 $\\rho_{\\gamma 0} = a_{\\mathrm{rad}} T_0^4 / c^2$，其中 $a_{\\mathrm{rad}}$ 是辐射常数，$T_0$ 是 CMB 温度。\n- 重子-光子动量密度比 $R(a) \\equiv 3 \\rho_b / (4 \\rho_\\gamma)$，以及扩散阻尼由光子剪切粘滞和热传导产生的紧耦合极限。\n\n基于这些出发点，推导 $y(\\eta) \\equiv k_D^{-2}(\\eta)$ 的紧耦合演化，并将其表示为以下两种形式：\n- 从初始标度因子 $a_{\\min}$ 到目标标度因子 $a$ 对共形时间的积分，\n- 以及一个关于 $y$ 的、以 $\\eta$ 或 $a$ 为变量的一阶常微分方程 (ODE)，并说明该 ODE 在形式积分后如何简化为相同的积分。\n\n为了科学真实性，请使用以下定义和关系：\n\n- 共形时间-标度因子关系 $d\\eta/da = 1/\\left(a^2 H(a)\\right)$，因此 $\\eta(a) = \\int_0^a da' / \\left(a'^2 H(a')\\right)$。\n- 电子数密度 $n_e(a) = x_e(a) n_{b0} a^{-3}$，其中 $n_{b0} = \\Omega_b \\rho_{c0} / m_p$ 是当今的重子数密度，$\\Omega_b$ 是重子密度参数，$m_p$ 是质子质量。\n- 光学深度对共形时间的导数为 $d\\tau/d\\eta = a n_e \\sigma_T$。在共形时间单位下，这具有逆长度的量纲。\n- 光子-重子比 $R(a)$ 的演化为 $R(a) = R_0 a$，其中 $R_0 = 3 \\Omega_b \\rho_{c0} / \\left(4 \\rho_{\\gamma 0}\\right)$。\n\n为每个重子的自由电子分数实现一个平滑的唯象复合历史：\n$$\nx_e(a) = x_{e,\\mathrm{post}} + \\frac{1}{2} \\left(f_e - x_{e,\\mathrm{post}}\\right) \\left[1 - \\tanh\\left(\\frac{a - a_*}{w}\\right)\\right],\n$$\n其中 $f_e = 1 - Y_p/2$，$Y_p$ 是原初氦质量分数，$a_*$ 是一个特征复合标度因子，$w$ 是标度因子上的过渡宽度，$x_{e,\\mathrm{post}}$ 是复合后每个重子的残余自由电子分数。这种参数化在科学上是可信的，并且捕捉了从完全电离状态 ($x_e \\approx f_e$) 到大部分中性状态 ($x_e \\approx x_{e,\\mathrm{post}}$) 的过渡。\n\n在紧耦合近似下，使用光子扩散阻尼率来定义 $y(\\eta)$ 的被积函数，用 $R(a)$ 和 $d\\tau/d\\eta$ 表示。在紧耦合机制下，从输运理论推导出演化方程 $dy/d\\eta$。不要在紧耦合框架之外引入任何临时的拟合公式。\n\n你必须在共动单位中进行计算，其中 $H(a)$ 以 $\\mathrm{Mpc}^{-1}$ 表示，共形时间 $\\eta$ 以 $\\mathrm{Mpc}$ 表示，$k_D$ 以 $\\mathrm{Mpc}^{-1}$ 表示。将 $\\sigma_T$ 从 $\\mathrm{m}^2$ 转换为 $\\mathrm{Mpc}^2$，将数密度从 $\\mathrm{m}^{-3}$ 转换为 $\\mathrm{Mpc}^{-3}$，以保持单位一致。在使用共形时间时，光速 $c$ 在 $d\\tau/d\\eta$ 中被消掉，因此该因子中不需要显式的 $c$。\n\n数值任务：\n\n1. 对下面的每个测试用例，计算两次 $k_D(a_*)$：\n   - 作为 $k_{D,\\mathrm{int}}(a_*)$，通过 $y(\\eta)$ 在共形时间上从 $a_{\\min}$ 到 $a_*$ 的积分表示来计算，并使用 $d\\eta/da$ 将其转换为对 $a$ 的积分。\n   - 作为 $k_{D,\\mathrm{ode}}(a_*)$，通过求解 $y(a)$ 从 $a_{\\min}$ 到 $a_*$ 的常微分方程，然后取 $k_D = y^{-1/2}$ 来计算。\n\n2. 通过计算无量纲的相对差异来对等价性进行基准测试\n   $$\n   \\delta \\equiv \\frac{\\left|k_{D,\\mathrm{int}}(a_*) - k_{D,\\mathrm{ode}}(a_*)\\right|}{k_{D,\\mathrm{int}}(a_*)}.\n   $$\n\n3. 使用比率 ... 来诊断在 $a_*$ 处紧耦合的有效性\n   $$\n   h \\equiv \\frac{H(a_*)}{d\\tau/d\\eta(a_*)},\n   $$\n   在共动单位中这是无量纲的。当 $h \\gtrsim 1$ 时，散射率相对于膨胀率而言不够快，紧耦合近似预计会失效。如果 $h \\geq 1$，报告一个布尔标志 $\\mathrm{breakdown}$ 设置为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n所有测试用例的物理常数：\n- $G = 6.67430 \\times 10^{-11}\\ \\mathrm{m}^3\\,\\mathrm{kg}^{-1}\\,\\mathrm{s}^{-2}$，\n- $c = 299792.458\\ \\mathrm{km}\\,\\mathrm{s}^{-1}$，\n- $m_p = 1.67262192369 \\times 10^{-27}\\ \\mathrm{kg}$，\n- $\\sigma_T = 6.6524587321 \\times 10^{-29}\\ \\mathrm{m}^2$，\n- $a_{\\mathrm{rad}} = 7.5657 \\times 10^{-16}\\ \\mathrm{J}\\,\\mathrm{m}^{-3}\\,\\mathrm{K}^{-4}$，\n- $1\\ \\mathrm{Mpc} = 3.0856775814913673 \\times 10^{22}\\ \\mathrm{m}$。\n\n由光子能量密度和有效中微子数决定的相对论性密度参数：\n$$\n\\Omega_\\gamma = \\frac{\\rho_{\\gamma 0}}{\\rho_{c0}},\\quad \\rho_{\\gamma 0} = \\frac{a_{\\mathrm{rad}} T_0^4}{c^2},\\quad \\Omega_r = \\Omega_\\gamma \\left(1 + 0.2271\\,N_{\\mathrm{eff}}\\right),\n$$\n其中 $N_{\\mathrm{eff}}$ 是有效中微子种类数。\n\n所有 $k_D$ 值以 $\\mathrm{Mpc}^{-1}$ 表示。相对差异 $\\delta$ 和比率 $h$ 是无量纲的。最终输出必须是包含在方括号内的单行扁平逗号分隔列表。\n\n测试套件：\n- 用例 1：$(H_0, \\Omega_b, \\Omega_m, N_{\\mathrm{eff}}, T_0, Y_p, a_*, w, x_{e,\\mathrm{post}}) = (67.66,\\ 0.049,\\ 0.315,\\ 3.046,\\ 2.725,\\ 0.24,\\ 1/1100,\\ 5\\times 10^{-4},\\ 10^{-4})$。\n- 用例 2：$(H_0, \\Omega_b, \\Omega_m, N_{\\mathrm{eff}}, T_0, Y_p, a_*, w, x_{e,\\mathrm{post}}) = (67.66,\\ 0.049,\\ 0.315,\\ 3.046,\\ 2.725,\\ 0.24,\\ 1/1400,\\ 10^{-4},\\ 10^{-4})$。\n- 用例 3：$(H_0, \\Omega_b, \\Omega_m, N_{\\mathrm{eff}}, T_0, Y_p, a_*, w, x_{e,\\mathrm{post}}) = (67.66,\\ 0.049,\\ 0.315,\\ 3.046,\\ 2.725,\\ 0.24,\\ 1/900,\\ 10^{-3},\\ 10^{-4})$。\n- 用例 4：$(H_0, \\Omega_b, \\Omega_m, N_{\\mathrm{eff}}, T_0, Y_p, a_*, w, x_{e,\\mathrm{post}}) = (67.66,\\ 0.049,\\ 0.315,\\ 3.046,\\ 2.725,\\ 0.24,\\ 1/1100,\\ 10^{-6},\\ 10^{-4})$。\n\n你必须取 $a_{\\min} = 10^{-8}$ 作为积分下限。\n\n要求的最终输出格式：\n你的程序应生成单行输出，其中按顺序包含每个测试用例的值 $[\\delta_1, h_1, \\mathrm{breakdown}_1, \\delta_2, h_2, \\mathrm{breakdown}_2, \\delta_3, h_3, \\mathrm{breakdown}_3, \\delta_4, h_4, \\mathrm{breakdown}_4]$，即一个用方括号括起来的、包含浮点数和布尔值的扁平结构的逗号分隔列表。", "solution": "用户要求通过两种数学上等价的方法计算和比较共动光子扩散阻尼波数 $k_D$：直接积分法和求解一阶常微分方程 (ODE) 法。该分析在包含物质和辐射的平坦 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙的标准宇宙学框架内进行，并采用了光子-重子流体的紧耦合近似。\n\n### 基于原理的推导\n\n**1. 光子扩散与阻尼波数 $k_D$**\n在早期宇宙中，复合之前，光子通过汤姆孙散射与重子紧密耦合。然而，这种耦合并非完美。光子具有有限的平均自由程，使其能够从过密区域扩散出去，从而平滑掉小尺度上的扰动。这个耗散过程被称为 Silk 阻尼或扩散阻尼。\n\n对共动波数为 $k$ 的密度扰动的阻尼效应通常是指数形式的，其标度关系为 $\\exp(-k^2/k_D^2)$。量 $k_D$ 是共动阻尼波数，其倒数 $k_D^{-1}$ 代表共动光子扩散长度。扩散长度的平方 $\\lambda_D^2 \\equiv k_D^{-2}$ 会因光子的随机行走而随时间累积。\n\n我们将要求解的量定义为 $y(\\eta) \\equiv k_D^{-2}(\\eta)$，其中 $\\eta$ 是共形时间，通过 $d\\eta = c\\,dt/a(t)$ 定义，使其具有长度单位。这里，$c$ 是光速，$t$ 是宇宙时，$a(t)$ 是标度因子。\n\n**2. 紧耦合极限下的演化方程**\n$y(\\eta)$ 的演化可以从紧耦合极限下的光子玻尔兹曼方程推导出来。扩散长度平方的变化率由光子扩散系数决定。该系数取决于光子平均自由时（以共形时间为单位，与汤姆孙散射率的倒数 $\\dot{\\tau}^{-1}$ 相关）以及光子-重子流体的性质，即其剪切粘滞和热传导。\n\n共动汤姆孙散射率由 $\\dot{\\tau} \\equiv d\\tau/d\\eta = a n_e \\sigma_T$ 给出，其中 $n_e$ 是固有的电子数密度，$\\sigma_T$ 是汤姆孙散射截面。\n\n$y(\\eta)$ 的一阶常微分方程结果是：\n$$\n\\frac{dy}{d\\eta} = \\frac{1}{6\\dot{\\tau}(\\eta)} \\left[ \\frac{R(\\eta)^2 + \\frac{16}{15}(1+R(\\eta))}{(1+R(\\eta))^2} \\right]\n$$\n这里，$R(\\eta) \\equiv 3\\rho_b/(4\\rho_\\gamma)$ 是重子-光子动量密度比，它量化了重子对光子的惯性“拖拽”效应。由于 $\\rho_b \\propto a^{-3}$ 且 $\\rho_\\gamma \\propto a^{-4}$，$R$ 与标度因子成正比，$R(a) = R_0 a$。\n\n该方程代表了问题所要求的基本 ODE 形式。\n\n**3. 以标度因子 $a$ 表示的积分和 ODE 形式**\n为了进行数值实现，将标度因子 $a$ 作为自变量更为方便。\n\n**积分表示：**\n在标度因子 $a_*$ 处的总扩散长度平方是通过将变化率从早期时间 ($a \\to 0$) 积分到 $a_*$ 得到的。对于某个非常小的 $a_{\\min}$，初始条件为 $y(a_{\\min}) \\approx 0$:\n$$\ny(a_*) = \\int_0^{\\eta(a_*)} d\\eta' \\, \\frac{dy}{d\\eta'}(\\eta')\n$$\n我们使用关系式 $d\\eta = \\frac{da}{a \\dot{a}} = \\frac{da}{a^2 H(a)/c}$ 将积分变量从共形时间 $\\eta$ 更改为标度因子 $a$。问题指定使用单位为 $\\mathrm{Mpc}^{-1}$ 的 $H(a)$，这对应于 $H_{\\text{phys}}/c$。因此，关系式变为 $d\\eta/da = 1/(a^2 H(a))$。\n将此代入积分，得到积分形式：\n$$\ny(a_*) = \\int_{a_{\\min}}^{a_*} da' \\, \\frac{1}{a'^2 H(a')} \\left\\{ \\frac{1}{6\\dot{\\tau}(a')} \\left[ \\frac{R(a')^2 + \\frac{16}{15}(1+R(a'))}{(1+R(a'))^2} \\right] \\right\\}\n$$\n\n**ODE 表示：**\n使用链式法则 $\\frac{dy}{da} = \\frac{dy}{d\\eta}\\frac{d\\eta}{da}$，以标度因子 $a$ 表示的 ODE 是：\n$$\n\\frac{dy}{da} = \\frac{1}{a^2 H(a)} \\left\\{ \\frac{1}{6\\dot{\\tau}(a)} \\left[ \\frac{R(a)^2 + \\frac{16}{15}(1+R(a))}{(1+R(a))^2} \\right] \\right\\}\n$$\n这是一个关于 $y(a)$ 的一阶 ODE，初始条件为 $y(a_{\\min})=0$。从 $a_{\\min}$ 到 $a_*$ 求解此 ODE 提供了计算 $y(a_*)$ 的另一种方法。如上所示，对此 ODE 进行形式积分会得到完全相同的积分表示，从而证实了它们的数学等价性。数值任务是验证这种等价性，其精度取决于数值求解器的精度。\n\n**4. 数值实现设计**\n算法将对每个测试用例执行以下步骤：\n1.  **常数和参数**：定义所有物理常数，并将其转换为一套一致的单位（Mpc, kg, K）。将给定的单位为 $\\mathrm{km}\\,\\mathrm{s}^{-1}\\,\\mathrm{Mpc}^{-1}$ 的哈勃常数 $H_0$ 转换为 $\\mathrm{s}^{-1}$ 以计算 $\\rho_{c0}$，并转换为 $\\mathrm{Mpc}^{-1}$ 以在宇宙学函数中使用。\n2.  **宇宙学函数**：根据提供的公式实现 $H(a)$、$R(a)$、$x_e(a)$ 和 $\\dot{\\tau}(a)$ 的函数。所有单位都将被处理，以确保像 $H$ 和 $\\dot{\\tau}$ 这样的量以 $\\mathrm{Mpc}^{-1}$ 为单位，最终计算出的 $y$ 以 $\\mathrm{Mpc}^2$ 为单位。\n3.  **被积函数定义**：ODE 的右侧 $\\frac{dy}{da}$ 作为积分方法的被积函数。\n4.  **数值求解**：\n    -   **积分法 ($k_{D,\\mathrm{int}}$)**：使用 `scipy.integrate.quad` 计算 $\\frac{dy}{da}$ 从 $a_{\\min}$ 到 $a_*$ 的定积分。这将得到 $y_{\\mathrm{int}}(a_*)$。\n    -   **ODE 法 ($k_{D,\\mathrm{ode}}$)**：使用 `scipy.integrate.solve_ivp` 求解 ODE $\\frac{dy}{da} = f(a)$，初始条件为 $y(a_{\\min})=0$，求解区间为 $[a_{\\min}, a_*]$。这将得到 $y_{\\mathrm{ode}}(a_*)$。\n5.  **最终计算**：\n    -   计算阻尼波数：$k_{D,\\mathrm{int}} = y_{\\mathrm{int}}^{-1/2}$ 和 $k_{D,\\mathrm{ode}} = y_{\\mathrm{ode}}^{-1/2}$。\n    -   计算相对差异 $\\delta = |k_{D,\\mathrm{int}} - k_{D,\\mathrm{ode}}| / k_{D,\\mathrm{int}}$。\n    -   计算紧耦合失效诊断指标 $h = H(a_*) / \\dot{\\tau}(a_*)$，其中两个量都以 $\\mathrm{Mpc}^{-1}$ 为单位。\n    -   如果 $h \\geq 1$，则将布尔标志 `breakdown` 设置为 `True`，否则设置为 `False`。\n6.  **输出**：收集所有测试用例的结果，并按规定格式化为单个扁平列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes the photon diffusion damping wavenumber k_D via two methods\n    (integral and ODE), compares them, and diagnoses tight-coupling validity.\n    \"\"\"\n    # Physical constants\n    G_SI = 6.67430e-11  # m^3 kg^-1 s^-2\n    C_KMS = 299792.458  # km s^-1\n    C_MS = C_KMS * 1000.  # m s^-1\n    M_P_KG = 1.67262192369e-27  # kg\n    SIGMA_T_M2 = 6.6524587321e-29  # m^2\n    A_RAD_SI = 7.5657e-16  # J m^-3 K^-4\n    MPC_M = 3.0856775814913673e22  # m\n\n    # Unit conversions\n    SIGMA_T_MPC2 = SIGMA_T_M2 / (MPC_M**2)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        (67.66, 0.049, 0.315, 3.046, 2.725, 0.24, 1/1100., 5e-4, 1e-4),\n        (67.66, 0.049, 0.315, 3.046, 2.725, 0.24, 1/1400., 1e-4, 1e-4),\n        (67.66, 0.049, 0.315, 3.046, 2.725, 0.24, 1/900., 1e-3, 1e-4),\n        (67.66, 0.049, 0.315, 3.046, 2.725, 0.24, 1/1100., 1e-6, 1e-4)\n    ]\n    \n    a_min = 1e-8\n    results = []\n\n    for case in test_cases:\n        H0_kmsmpc, Omega_b, Omega_m, N_eff, T0, Yp, a_star, w, xe_post = case\n\n        # --- Derived parameters for this case ---\n\n        # Hubble constant in s^-1 for rho_c0 calculation\n        H0_s_inv = H0_kmsmpc * 1000. / MPC_M\n        \n        # Critical density today in kg/m^3\n        rho_c0_si = 3. * H0_s_inv**2 / (8. * np.pi * G_SI)\n        \n        # Photon energy density today in kg/m^3\n        rho_gamma0_si = A_RAD_SI * T0**4 / C_MS**2\n        \n        # Photon density parameter\n        Omega_gamma = rho_gamma0_si / rho_c0_si\n        \n        # Relativistic energy density parameter\n        Omega_r = Omega_gamma * (1. + 0.2271 * N_eff)\n        \n        # Present-day baryon number density in Mpc^-3\n        n_b0_si = Omega_b * rho_c0_si / M_P_KG  # in m^-3\n        n_b0_mpc_inv3 = n_b0_si * MPC_M**3\n        \n        # Baryon-to-photon ratio parameter R0\n        # R(a) = R0 * a\n        # R0 = 3 * rho_b0 / (4 * rho_gamma0) = 3 * Omega_b * rho_c0 / (4 * Omega_gamma * rho_c0)\n        R0 = 3. * Omega_b / (4. * Omega_gamma)\n\n        # Hubble parameter in Mpc^-1\n        H0_mpc_inv = H0_kmsmpc / C_KMS \n        \n        # --- Cosmological Functions ---\n        \n        def H_mpc_inv(a):\n            return H0_mpc_inv * np.sqrt(Omega_m * a**-3 + Omega_r * a**-4)\n\n        def R(a):\n            return R0 * a\n            \n        f_e = 1. - Yp / 2.\n        def x_e(a):\n            return xe_post + 0.5 * (f_e - xe_post) * (1 - np.tanh((a - a_star) / w))\n\n        def dtau_deta_mpc_inv(a):\n            # dtau/deta = a * n_e * sigma_T\n            # n_e(a) = x_e(a) * n_b0 * a^-3\n            # n_b0 is present-day baryon number density.\n            return a * (x_e(a) * n_b0_mpc_inv3 * a**-3) * SIGMA_T_MPC2\n\n        def dydt_integrand(a, y=None):\n            # This is the RHS of the ODE dy/da = f(a)\n            # y is unused, as the ODE is separable, but added for solve_ivp compatibility\n            R_val = R(a)\n            dtau_val = dtau_deta_mpc_inv(a)\n            \n            # Prevent division by zero if dtau is ever zero, though unlikely in practice\n            if dtau_val == 0:\n                return 0.\n                \n            term1 = 1. / (a**2 * H_mpc_inv(a))\n            \n            # This is the formula from the solution derivation:\n            # dy/deta = 1/(6*dtau) * [ (R^2 + 16/15*(1+R)) / (1+R)^2 ]\n            # Which is equivalent to:\n            # dy/deta = 1/(6*dtau) * [ R^2/(1+R)^2 + 16/15 * 1/(1+R) ]\n            numerator_bracket = R_val**2 + (16./15.) * (1. + R_val)\n            denominator_bracket = (1. + R_val)**2\n            term2 = 1. / (6. * dtau_val) * (numerator_bracket / denominator_bracket)\n            \n            return term1 * term2\n\n        # --- Numerical Calculation ---\n\n        # 1. Integral method\n        y_int_val, _ = integrate.quad(dydt_integrand, a_min, a_star, epsabs=1e-15, epsrel=1e-12)\n        k_D_int = y_int_val**-0.5\n\n        # 2. ODE method\n        sol = integrate.solve_ivp(\n            dydt_integrand, \n            [a_min, a_star], \n            [0.], \n            method='RK45', \n            rtol=1e-12, \n            atol=1e-15\n        )\n        y_ode_val = sol.y[0][-1]\n        k_D_ode = y_ode_val**-0.5\n\n        # --- Final Metrics ---\n\n        # Relative difference\n        delta = np.abs(k_D_int - k_D_ode) / k_D_int\n\n        # Tight-coupling breakdown diagnostic\n        h_val = H_mpc_inv(a_star) / dtau_deta_mpc_inv(a_star)\n        \n        # Breakdown flag\n        breakdown_flag = h_val = 1.0\n\n        results.extend([delta, h_val, breakdown_flag])\n\n    # Final print statement in the exact required format.\n    # Convert booleans to lowercase 'true'/'false' for standard JSON-like output\n    formatted_results = [f'{v}'.lower() if isinstance(v, bool) else f'{v}' for v in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3463818"}, {"introduction": "连接理论与观测的最后一步是将三维的温度扰动投影到我们的二维天球上。这项实践 [@problem_id:3463745] 将处理著名的视线积分问题，该积分将受阻尼的声波振荡转化为角功率谱 $C_l^{TT}$。你将实现一个稳健的数值积分方案来处理尖锐的可见性函数和球贝塞尔函数的高度振荡特性，从而能够计算出高多极矩下特征性的阻尼尾部。", "problem": "你的任务是为宇宙微波背景（CMB）温度各向异性视线积分表达式实现一个数值积分器，该积分器需要能明确处理高度振荡的球贝塞尔函数和锐利峰值的可见性函数。你的实现必须用于计算温度角功率谱的高多极矩阻尼尾部，并且必须测试其相对于求积分辨率的数值收敛性。\n\n物理设置为共形时间下的空间平坦宇宙。温度多极矩传递函数由以下视线积分定义：\n$$\n\\Delta_l(k) \\equiv \\int d\\eta \\, g(\\eta) \\, F(k,\\eta) \\, j_l\\!\\big(k(\\tau_0 - \\eta)\\big),\n$$\n其中 $l$ 是多极矩指数，$k$ 是共动波数，$\\eta$ 是共形时间，$g(\\eta)$ 是可见性函数，$F(k,\\eta)$ 是一个模型源函数，$j_l(x)$ 是第一类球贝塞尔函数。温度角功率谱则建模为：\n$$\nC_l^{TT} \\equiv 4\\pi \\int_{k_{\\min}}^{k_{\\max}} d(\\ln k) \\, \\mathcal{P}_{\\mathcal{R}}(k) \\left[\\Delta_l(k)\\right]^2,\n$$\n其中 $\\mathcal{P}_{\\mathcal{R}}(k)$ 是原初曲率功率谱。你将假设一个以复合时期为中心的高斯可见性函数，以及一个捕捉了声波振荡和扩散阻尼（丝绸阻尼，Silk damping）的简化源函数。\n\n使用以下科学上合理且自洽的模型定义和基准参数：\n- 今日共形时间：$\\tau_0 = 14000 \\,\\mathrm{Mpc}$。\n- 复合时期：$\\eta_* = 280 \\,\\mathrm{Mpc}$。\n- 可见性函数（高斯函数，归一化至单位面积）：\n$$\ng(\\eta) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma_\\eta} \\exp\\!\\left[-\\frac{(\\eta-\\eta_*)^2}{2\\sigma_\\eta^2}\\right],\n$$\n其宽度 $\\sigma_\\eta$ 在每个测试中指定。\n- 带扩散阻尼的声学源因子：\n$$\nF(k,\\eta) = \\cos\\!\\big(k\\,c_s\\,(\\eta_*-\\eta)\\big)\\,\\exp\\!\\left[-\\left(\\frac{k}{k_D}\\right)^2\\right],\n$$\n其中 $c_s = 1/\\sqrt{3}$ 是紧密耦合的重子-光子流体的声速，$k_D = 0.15\\,\\mathrm{Mpc}^{-1}$ 是一个固定的特征扩散阻尼尺度（在最后散射时评估）。\n- 原初曲率功率谱（幂律）：\n$$\n\\mathcal{P}_{\\mathcal{R}}(k) = A_s \\left(\\frac{k}{k_0}\\right)^{n_s - 1},\n$$\n振幅 $A_s = 2.1\\times 10^{-9}$，谱指数 $n_s = 0.965$，以及枢轴尺度 $k_0 = 0.05\\,\\mathrm{Mpc}^{-1}$。\n- 波数积分限：$k_{\\min} = 10^{-4}\\,\\mathrm{Mpc}^{-1}$ 和 $k_{\\max} = 0.5\\,\\mathrm{Mpc}^{-1}$。\n\n数值积分要求：\n- $\\eta$-积分必须利用 $g(\\eta)$ 的高斯形式，使用高斯-埃尔米特求积法（Gauss-Hermite quadrature）进行计算。具体来说，执行变量替换 $y = (\\eta - \\eta_*)/(\\sqrt{2}\\,\\sigma_\\eta)$ 以重写为：\n$$\n\\Delta_l(k) = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{+\\infty} dy \\, e^{-y^2} \\, F\\!\\big(k,\\eta_* + \\sqrt{2}\\,\\sigma_\\eta y\\big) \\, j_l\\!\\Big(k\\big(\\tau_0 - \\eta_* - \\sqrt{2}\\,\\sigma_\\eta y\\big)\\Big),\n$$\n然后应用 $N_\\eta$ 点的高斯-埃尔米特求积 $(x_i,w_i)$：\n$$\n\\Delta_l(k) \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^{N_\\eta} w_i \\, F\\!\\big(k,\\eta_* + \\sqrt{2}\\,\\sigma_\\eta x_i\\big) \\, j_l\\!\\Big(k\\big(\\tau_0 - \\eta_* - \\sqrt{2}\\,\\sigma_\\eta x_i\\big)\\Big).\n$$\n- $k$-积分必须在具有 $N_k$ 个点的对数网格上计算，对 $d(\\ln k)$ 使用稳定的复合规则。\n\n单位和输出：\n- 所有物理量必须使用已指定的单位：百万秒差距（megaparsecs）和百万秒差距的倒数（inverse megaparsecs）。你的最终输出是 $C_l^{TT}$ 的无量纲值；将最终结果表示为不带物理单位的浮点数。\n\n测试套件：\n计算以下参数集的 $C_l^{TT}$，以探测阻尼尾部并测试相对于 $N_\\eta$ 和 $N_k$ 的收敛性。每个测试用例是一个元组 $(l,\\sigma_\\eta,N_\\eta,N_k)$：\n1. $(1500, 20, 40, 300)$ — 在阻尼尾部使用中等精度求积的理想路径。\n2. $(1500, 20, 20, 300)$ — 减少 $N_\\eta$ 以测试对 $\\eta$ 分辨率的敏感性。\n3. $(1500, 20, 80, 300)$ — 增加 $N_\\eta$ 以测试改进的收敛性。\n4. $(2000, 10, 40, 300)$ — 更深的阻尼尾部，更窄的可见性函数。\n5. $(2000, 5, 16, 300)$ — 非常锐利的可见性函数和粗糙的 $N_\\eta$ 作为边缘案例。\n6. $(1500, 20, 40, 150)$ — 减少 $N_k$ 以测试 $k$-网格分辨率。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$），其中每个 $r_i$ 是相应测试用例计算出的 $C_l^{TT}$ 值，表示为不带物理单位的浮点数。", "solution": "该问题要求对高多极矩 $l$ 的宇宙微波背景（CMB）温度角功率谱 $C_l^{TT}$进行数值计算。这涉及到一个二维积分，必须按照指定的数值策略来实现。解决方案涉及开发一个 Python 程序，将这些数值方法正确应用于所提供的物理模型。\n\n问题的核心在于计算角功率谱的表达式，其公式如下：\n$$\nC_l^{TT} \\equiv 4\\pi \\int_{k_{\\min}}^{k_{\\max}} d(\\ln k) \\, \\mathcal{P}_{\\mathcal{R}}(k) \\left[\\Delta_l(k)\\right]^2\n$$\n在此，$\\mathcal{P}_{\\mathcal{R}}(k)$ 是原初曲率功率谱，$\\Delta_l(k)$ 是温度多极矩传递函数，由以下视线积分定义：\n$$\n\\Delta_l(k) \\equiv \\int d\\eta \\, g(\\eta) \\, F(k,\\eta) \\, j_l\\!\\big(k(\\tau_0 - \\eta)\\big)\n$$\n问题为所有分量提供了具体的函数形式和参数。\n\n原初功率谱是一个幂律：\n$$\n\\mathcal{P}_{\\mathcal{R}}(k) = A_s \\left(\\frac{k}{k_0}\\right)^{n_s - 1}\n$$\n振幅 $A_s = 2.1\\times 10^{-9}$，谱指数 $n_s = 0.965$，枢轴尺度 $k_0 = 0.05\\,\\mathrm{Mpc}^{-1}$。\n\n源函数 $F(k,\\eta)$ 模拟了声波振荡和扩散（丝绸）阻尼：\n$$\nF(k,\\eta) = \\cos\\!\\big(k\\,c_s\\,(\\eta_*-\\eta)\\big)\\,\\exp\\!\\left[-\\left(\\frac{k}{k_D}\\right)^2\\right]\n$$\n其中声速为 $c_s = 1/\\sqrt{3}$，阻尼尺度为 $k_D = 0.15\\,\\mathrm{Mpc}^{-1}$。\n\n可见性函数 $g(\\eta)$ 描述了光子在共形时间 $\\eta$ 最后散射的概率密度，它是一个以复合时期 $\\eta_* = 280\\,\\mathrm{Mpc}$ 为中心的归一化高斯函数：\n$$\ng(\\eta) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma_\\eta} \\exp\\!\\left[-\\frac{(\\eta-\\eta_*)^2}{2\\sigma_\\eta^2}\\right]\n$$\n该函数的宽度 $\\sigma_\\eta$ 在不同测试用例中有所不同。\n\n数值求解分两个嵌套阶段实现，分别对应 $\\Delta_l(k)$ 和 $C_l^{TT}$ 的两个积分。\n\n**1. 内层积分：传递函数 $\\Delta_l(k)$ 的计算**\n\n$\\Delta_l(k)$ 的积分使用高斯-埃尔米特求积法（Gauss-Hermite quadrature）进行计算。选择此方法是因为可见性函数 $g(\\eta)$ 提供了一个高斯权重。问题指定了一个变量替换 $y = (\\eta - \\eta_*)/(\\sqrt{2}\\,\\sigma_\\eta)$，这将积分转换为高斯-埃尔米特求积法的标准形式：\n$$\n\\Delta_l(k) = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{+\\infty} dy \\, e^{-y^2} \\, H(y)\n$$\n其中函数 $H(y)$ 是被积函数的其余部分：\n$$\nH(y) = F\\!\\big(k,\\eta_* + \\sqrt{2}\\,\\sigma_\\eta y\\big) \\, j_l\\!\\Big(k\\big(\\tau_0 - \\eta_* - \\sqrt{2}\\,\\sigma_\\eta y\\big)\\Big)\n$$\n应用具有横坐标 $x_i$ 和权重 $w_i$ 的 $N_\\eta$ 点高斯-埃尔米特求积法则可得到近似值：\n$$\n\\Delta_l(k) \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^{N_\\eta} w_i \\, H(x_i)\n$$\n在实现中，所需的横坐标和权重通过 `scipy.special.roots_hermite` 获得。球贝塞尔函数 $j_l(z)$ 使用 `scipy.special.spherical_jn` 计算。为了提高效率，计算在 $N_\\eta$ 个求积点上进行了向量化。\n\n**2. 外层积分：功率谱 $C_l^{TT}$ 的计算**\n\n$C_l^{TT}$ 的外层积分是关于共动波数 $k$ 的积分。问题指定了积分是关于 $d(\\ln k)$ 在一个从 $k_{\\min} = 10^{-4}\\,\\mathrm{Mpc}^{-1}$ 到 $k_{\\max} = 0.5\\,\\mathrm{Mpc}^{-1}$ 的 $N_k$ 个点的对数网格上进行的。我们在 $\\ln k$ 中定义一个由 $N_k$ 个均匀间隔的点组成的网格，然后计算相应的 $k$ 值。\n\n令被积函数为 $I(k) = \\mathcal{P}_{\\mathcal{R}}(k) \\left[\\Delta_l(k)\\right]^2$。积分变为：\n$$\nC_l^{TT} = 4\\pi \\int_{\\ln k_{\\min}}^{\\ln k_{\\max}} d(\\ln k) \\, I(e^{\\ln k})\n$$\n这个定积分使用复合梯形法则进行数值计算，该法则非常适合在均匀网格上采样的函数。`numpy.trapz` 函数用于此目的。\n\n**3. 算法实现和向量化**\n\n整体算法被封装在一个函数 `compute_Cl_TT(l, sigma_eta, N_eta, N_k)` 中。为了获得最佳性能，整个计算使用 NumPy 进行了向量化，尽可能避免了显式的 Python 循环。一个二维网格由 $N_k$ 个波数点和 $N_\\eta$ 个求積点隐式构成。$\\Delta_l(k)$ 被积函数中的所有项都在这个二维网格上使用 NumPy 的广播功能进行计算。然后沿适当的轴执行高斯-埃尔米特求積的和，通过一次操作即可为所有 $k$ 值生成一个 $\\Delta_l(k)$ 值的向量。这个向量随后被用来计算 $C_l^{TT}$ 积分的被积函数，接着使用 `numpy.trapz` 进行求值。\n\n一个主 `solve` 函数会遍历所提供的测试用例，为每组参数调用 `compute_Cl_TT` 函数，并将结果整理到一个列表中。最后，它按照要求格式化并打印输出字符串。所提供的常量，例如 $\\tau_0=14000\\,\\mathrm{Mpc}$，在脚本中被定义为全局变量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Computes the CMB temperature angular power spectrum C_l^{TT} for a set of test cases.\n    \"\"\"\n    # Define physical constants and fiducial cosmological parameters.\n    # All distance units are in Megaparsecs (Mpc).\n    TAU0 = 14000.0  # Conformal time today [Mpc]\n    ETA_STAR = 280.0  # Conformal time at recombination [Mpc]\n    C_S = 1.0 / np.sqrt(3.0)  # Sound speed of the baryon-photon fluid\n    K_D = 0.15  # Diffusion damping scale [Mpc^-1]\n    A_S = 2.1e-9  # Amplitude of the primordial curvature power spectrum\n    N_S = 0.965  # Spectral index of the primordial curvature power spectrum\n    K0 = 0.05  # Pivot scale for the primordial spectrum [Mpc^-1]\n    K_MIN = 1e-4  # Minimum wavenumber for integration [Mpc^-1]\n    K_MAX = 0.5  # Maximum wavenumber for integration [Mpc^-1]\n\n    def P_R(k):\n        \"\"\"\n        Calculates the primordial curvature power spectrum P_R(k).\n        \"\"\"\n        return A_S * (k / K0)**(N_S - 1)\n\n    def compute_Cl_TT(l, sigma_eta, N_eta, N_k):\n        \"\"\"\n        Computes the angular power spectrum C_l^TT using the specified numerical methods.\n        \n        Args:\n            l (int): Multipole index.\n            sigma_eta (float): Width of the Gaussian visibility function [Mpc].\n            N_eta (int): Number of quadrature points for the eta-integral.\n            N_k (int): Number of grid points for the k-integral.\n\n        Returns:\n            float: The computed value of C_l^TT.\n        \"\"\"\n        # 1. Set up the logarithmic wavenumber grid for the outer integral.\n        log_k_grid = np.linspace(np.log(K_MIN), np.log(K_MAX), N_k)\n        k_grid = np.exp(log_k_grid)  # Shape: (N_k,)\n\n        # 2. Set up the Gauss-Hermite quadrature for the inner integral.\n        # roots_hermite returns abscissas x_i and weights w_i for integral e^(-x^2)f(x)dx.\n        x_i, w_i = special.roots_hermite(N_eta)  # Shapes: (N_eta,), (N_eta,)\n\n        # 3. Vectorize the computation of Delta_l(k) over both k and eta grids.\n        # Use NumPy broadcasting to create 2D arrays from 1D grids.\n        # k_grid_2d shape: (N_k, 1), x_i_2d shape: (1, N_eta)\n        k_grid_2d = k_grid[:, np.newaxis]\n        x_i_2d = x_i[np.newaxis, :]\n        \n        # Transform quadrature variable y (our x_i) back to conformal time eta.\n        # eta_i_2d has shape (N_k, N_eta).\n        eta_i_2d = ETA_STAR + np.sqrt(2.0) * sigma_eta * x_i_2d\n\n        # 4. Calculate the components of the Delta_l(k) integrand.\n        \n        # Source function F(k, eta)\n        cos_term = np.cos(k_grid_2d * C_S * (ETA_STAR - eta_i_2d))\n        damping_term = np.exp(-(k_grid_2d / K_D)**2)\n        F_vals_2d = cos_term * damping_term  # Shape: (N_k, N_eta)\n\n        # Spherical Bessel function j_l(k(tau0 - eta))\n        bessel_arg_2d = k_grid_2d * (TAU0 - eta_i_2d)\n        j_l_vals_2d = special.spherical_jn(l, bessel_arg_2d)  # Shape: (N_k, N_eta)\n\n        # 5. Perform the Gauss-Hermite quadrature sum over the eta-axis (axis=1).\n        # w_i is broadcast to shape (1, N_eta).\n        integrand_sum = np.sum(w_i[np.newaxis, :] * F_vals_2d * j_l_vals_2d, axis=1)\n        \n        # The transfer function Delta_l(k) for all k in k_grid.\n        delta_l_k_vals = (1.0 / np.sqrt(np.pi)) * integrand_sum  # Shape: (N_k,)\n\n        # 6. Compute the integrand for the C_l^TT integral.\n        cl_integrand = P_R(k_grid) * (delta_l_k_vals**2)\n\n        # 7. Perform the outer integral over d(ln k) using the trapezoidal rule.\n        cl_integral_val = np.trapz(cl_integrand, x=log_k_grid)\n        \n        return 4.0 * np.pi * cl_integral_val\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (l, sigma_eta, N_eta, N_k)\n        (1500, 20, 40, 300),  # 1. happy path\n        (1500, 20, 20, 300),  # 2. reduced N_eta\n        (1500, 20, 80, 300),  # 3. increased N_eta\n        (2000, 10, 40, 300),  # 4. deeper damping tail\n        (2000, 5, 16, 300),   # 5. sharp visibility, coarse N_eta\n        (1500, 20, 40, 150),  # 6. reduced N_k\n    ]\n\n    results = []\n    for case in test_cases:\n        l, sigma_eta, N_eta, N_k = case\n        result = compute_Cl_TT(l, sigma_eta, N_eta, N_k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3463745"}]}