{"hands_on_practices": [{"introduction": "在数值上求解玻尔兹曼方程组时，我们必须在某个最大多极矩 $\\ell_{\\max}$ 处将其截断，这引入了所谓的“闭合关系”来处理更高阶的矩。这个练习提供了实现截断方程组求解器的基础实践，通过将数值结果与已知的解析解进行比较，来量化一个简单闭合方案所引入的误差。这个过程对于理解和验证任何玻尔兹曼代码的自由传播模块都是至关重要的一步。[@problem_id:3493623]", "problem": "考虑与宇宙微波背景（CMB）各向异性以及遗迹中微子相关的无质量粒子的无碰撞玻尔兹曼方程（在傅里叶空间中，并按勒让德多极矩展开）。令 $k$ 为共动波数，$\\eta$ 为共形时间，并定义无量纲时间变量 $x \\equiv k\\eta$。用 $F_\\ell(x)$ 表示在没有引力驱动和碰撞的情况下，单个自由传播的无质量粒子的相空间亮度微扰的勒让德多极矩。对于所有非负整数 $\\ell$，以 $x$ 表示的精确、无源的方程组是一组耦合的一阶常微分方程链，\n$$\n\\frac{d F_\\ell}{dx} = \\frac{1}{2\\ell+1}\\left[\\ell\\,F_{\\ell-1} - (\\ell+1)\\,F_{\\ell+1}\\right],\n$$\n在 $x \\to 0$ 时具有正则的初始行为，对应于初始各向同性的微扰。在辐射主导（RD）时期，尺度因子遵循 $a(\\eta)\\propto \\eta$，而在物质主导（MD）时期，$a(\\eta)\\propto \\eta^2$。在没有引力驱动的情况下，$F_\\ell$ 的动力学仅取决于 $x$，而不取决于背景膨胀历史。其齐次解析解可用球贝塞尔函数表示。\n\n您的任务是构建并验证一个截断的数值求解器，该求解器仅保留前三个多极矩（$\\ell \\le 2$），并在 $\\ell=3$ 处使用渐近自由传播闭合关系来封闭系统：\n$$\nF_3(x) \\approx \\frac{3}{x}\\,F_2(x).\n$$\n初始条件对应于一个初始各向同性的微扰，在 $x\\to 0$ 极限下具有单位单极矩且高阶多极矩为零，通过在微小但有限的 $x_0$ 处以符合各向同性的正则初始数据开始来实现。使用 $x_0 = 10^{-6}$。\n\n实现以下步骤：\n- 对每个测试用例，从 $x=x_0$ 到指定的 $x=x_{\\mathrm{end}}$ 对 $F_0(x)$、$F_1(x)$ 和 $F_2(x)$ 的截断系统进行积分。\n- 对每个 $x_{\\mathrm{end}}$，计算 $\\ell \\in \\{0,1,2\\}$ 的齐次自由传播解析解，该解用球贝塞尔函数表示，并归一化以匹配相同的初始单极矩振幅。\n- 对每个 $\\ell \\in \\{0,1,2\\}$，计算相对偏差\n$$\n\\epsilon_\\ell(x_{\\mathrm{end}}) \\equiv \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}.\n$$\n- 对每个测试用例，报告在 $\\ell \\in \\{0,1,2\\}$ 上的最大偏差：\n$$\n\\epsilon_{\\max}(x_{\\mathrm{end}}) \\equiv \\max\\{\\epsilon_0(x_{\\mathrm{end}}), \\epsilon_1(x_{\\mathrm{end}}), \\epsilon_2(x_{\\mathrm{end}})\\}.\n$$\n\n测试套件：\n- 辐射主导时期（RD），$x_{\\mathrm{end}} = 10^{-3}$。\n- 辐射主导时期（RD），$x_{\\mathrm{end}} = 1$。\n- 辐射主导时期（RD），$x_{\\mathrm{end}} = 20$。\n- 物质主导时期（MD），$x_{\\mathrm{end}} = 10^{-3}$。\n- 物质主导时期（MD），$x_{\\mathrm{end}} = 1$。\n- 物质主导时期（MD），$x_{\\mathrm{end}} = 20$。\n\n注意事项和要求：\n- 使用以球贝塞尔函数表示的齐次自由传播解析解作为验证的参考。因为忽略了引力驱动，所以方程组与 $x$ 的关系在辐射主导和物质主导时期是相同的；这两个时期仅通过 $x$ 相对于 $\\eta$ 和 $a(\\eta)$ 的解释进入问题，而不影响方程组的 $x$-演化。\n- 确保在 $x_0 = 10^{-6}$ 处的数值初始数据是正则的，并与一个在 $x\\to 0$ 极限下具有单位单极矩振幅且偶极矩和四极矩为零的初始各向同性微扰一致。\n- 角度没有显式出现；不需要角度单位。\n- 所有量都是无量纲的；不需要物理单位转换。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4,r_5,r_6]$），其中每个 $r_i$ 是按上述顺序指定的相应测试用例的 $\\epsilon_{\\max}(x_{\\mathrm{end}})$ 值。每个 $r_i$ 必须以科学记数法打印为浮点数，且恰好有8位有效数字。", "solution": "用户想要解决一个关于玻尔兹曼方程的数值宇宙学问题。\n\n### 问题验证\n\n**步骤1：提取的已知条件**\n- **系统**：无质量粒子的无碰撞玻尔兹曼方程。\n- **变量与定义**：共动波数 $k$，共形时间 $\\eta$，无量纲时间 $x \\equiv k\\eta$。\n- **微扰多极矩**：$F_\\ell(x)$，相空间亮度微扰的勒让德多极矩。\n- **方程**：$\\frac{d F_\\ell}{dx} = \\frac{1}{2\\ell+1}\\left[\\ell\\,F_{\\ell-1} - (\\ell+1)\\,F_{\\ell+1}\\right]$，适用于非负整数 $\\ell$。\n- **初始条件**：当 $x \\to 0$ 时具有正则的初始行为，对应于具有单位单极矩振幅的初始各向同性微扰。\n- **数值截断**：求解 $\\ell \\le 2$ 的情况，即求解 $F_0(x)$、$F_1(x)$ 和 $F_2(x)$。\n- **闭合关系**：系统在 $\\ell=3$ 处通过近似 $F_3(x) \\approx \\frac{3}{x}\\,F_2(x)$ 来封闭。\n- **数值积分起点**：$x_0 = 10^{-6}$，使用正则初始数据。\n- **解析解**：精确的齐次解由球贝塞尔函数 $j_\\ell(x)$ 给出。\n- **误差度量**：\n  - 相对偏差：$\\epsilon_\\ell(x_{\\mathrm{end}}) \\equiv \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}$。\n  - 最大偏差：$\\epsilon_{\\max}(x_{\\mathrm{end}}) \\equiv \\max\\{\\epsilon_0(x_{\\mathrm{end}}), \\epsilon_1(x_{\\mathrm{end}}), \\epsilon_2(x_{\\mathrm{end}})\\}$.\n- **测试用例**：\n    1. 辐射主导（RD），$x_{\\mathrm{end}} = 10^{-3}$。\n    2. 辐射主导（RD），$x_{\\mathrm{end}} = 1$。\n    3. 辐射主导（RD），$x_{\\mathrm{end}} = 20$。\n    4. 物质主导（MD），$x_{\\mathrm{end}} = 10^{-3}$。\n    5. 物质主导（MD），$x_{\\mathrm{end}} = 1$。\n    6. 物质主导（MD），$x_{\\mathrm{end}} = 20$。\n- **辅助信息**：$F_\\ell(x)$ 的演化仅取决于 $x$，与背景膨胀历史（RD 或 MD）无关。\n\n**步骤2：已知条件的验证**\n- **科学依据**：该问题在科学上是合理的。玻尔兹曼方程是物理宇宙学中研究微扰演化的基本工具。所提供的方程对于自由传播的无质量粒子是正确的。使用球贝塞尔函数作为初始各向同性微扰的解析解也是正确的。测试数值截断和闭合方案与解析解的对比，是计算物理学中一个标准且有效的练习。\n- **适定性**：该问题是适定的。它提供了一个常微分方程（ODE）系统、一个使截断系统可解的特定闭合关系，以及一个明确定义的初始条件。计算特定误差度量的目标是明确的。\n- **完整性和一致性**：该问题是自洽的。\n  - 初始条件虽然是描述性的（“正则的初始行为...”），但可以唯一确定。对于初始条件 $F_\\ell(0) = \\delta_{\\ell 0}$，解析解为 $F_\\ell(x) = j_\\ell(x)$。因此，在微小的起始值 $x_0 = 10^{-6}$ 处的数值初始数据应设置为 $F_\\ell(x_0) = j_\\ell(x_0)$，其中 $\\ell \\in \\{0, 1, 2\\}$。\n  - 问题为 RD 和 MD 时期都指定了测试用例，但同时也明确指出，在这两种情况下 $F_\\ell(x)$ 的动力学是相同的。这意味着对于具有相同 $x_{\\mathrm{end}}$ 的测试用例，结果将是相同的（即，用例 1=4, 2=5, 3=6）。这并非矛盾，而是一种冗余，用以测试对底层物理的理解。\n  - 提供的闭合关系 $F_3(x) \\approx \\frac{3}{x}F_2(x)$ 是待测试数值方案的一个决定性特征。虽然它可能不是一个高度准确的物理近似，但其有效性不是问题本身的先决条件，问题本身旨在量化由这一特定近似引入的误差。\n\n**步骤3：结论与行动**\n问题有效。我将继续进行解答。\n\n### 解题设计\n\n问题的核心是求解一个截断的常微分方程组，并将结果与已知的解析解进行比较。\n\n**1. 截断的常微分方程组**\n我们求解微扰向量 $\\vec{F}(x) = [F_0(x), F_1(x), F_2(x)]^T$。对于 $\\ell=0, 1, 2$ 的方程组为：\n$$\n\\frac{d F_0}{dx} = \\frac{1}{1}\\left[0 \\cdot F_{-1} - (0+1)F_1\\right] = -F_1\n$$\n$$\n\\frac{d F_1}{dx} = \\frac{1}{2(1)+1}\\left[1 \\cdot F_0 - (1+1)F_2\\right] = \\frac{1}{3}(F_0 - 2F_2)\n$$\n$$\n\\frac{d F_2}{dx} = \\frac{1}{2(2)+1}\\left[2 \\cdot F_1 - (2+1)F_3\\right] = \\frac{1}{5}(2F_1 - 3F_3)\n$$\n系统使用所提供的关系 $F_3(x) = \\frac{3}{x}F_2(x)$ 进行封闭。将此关系代入 $F_2$ 的方程中，得到：\n$$\n\\frac{d F_2}{dx} = \\frac{1}{5}\\left(2F_1 - 3 \\cdot \\frac{3}{x}F_2\\right) = \\frac{2}{5}F_1 - \\frac{9}{5x}F_2\n$$\n这得到以下线性一阶常微分方程组：\n$$\n\\frac{d}{dx}\n\\begin{pmatrix} F_0 \\\\ F_1 \\\\ F_2 \\end{pmatrix}\n=\n\\begin{pmatrix}\n0  -1  0 \\\\\n1/3  0  -2/3 \\\\\n0  2/5  -9/(5x)\n\\end{pmatrix}\n\\begin{pmatrix} F_0 \\\\ F_1 \\\\ F_2 \\end{pmatrix}\n$$\n\n**2. 初始条件**\n问题指出，初始微扰是各向同性的，具有单位单极矩，即 $F_\\ell(x \\to 0) = \\delta_{\\ell 0}$。具有此初始条件的完整方程组的解析解为 $F_\\ell(x) = j_\\ell(x)$，其中 $j_\\ell(x)$ 是第一类球贝塞尔函数。为了在 $x_0 = 10^{-6}$ 处开始数值积分，我们将初始状态向量设置为该点解析解的值：\n$$\n\\vec{F}(x_0) = \\begin{pmatrix} F_0(x_0) \\\\ F_1(x_0) \\\\ F_2(x_0) \\end{pmatrix} = \\begin{pmatrix} j_0(x_0) \\\\ j_1(x_0) \\\\ j_2(x_0) \\end{pmatrix}\n$$\n\n**3. 数值积分**\n常微分方程组将从 $x_0 = 10^{-6}$ 数值积分到每个指定的 $x_{\\mathrm{end}} \\in \\{10^{-3}, 1, 20\\}$。我们将使用一个高精度的自适应步长求解器，例如 `scipy.integrate.solve_ivp` 提供的求解器，以确保误差主要来自闭合近似本身，而不是数值积分的不准确性。我们设置严格的相对和绝对容差（例如，$10^{-12}$ 和 $10^{-14}$）。\n\n**4. 解析参考与误差计算**\n对于每个 $x_{\\mathrm{end}}$，将数值解 $F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}})$ 与解析解 $F_\\ell^{\\mathrm{ana}}(x_{\\mathrm{end}}) = j_\\ell(x_{\\mathrm{end}})$ 进行比较。使用提供的公式计算每个 $\\ell \\in \\{0,1,2\\}$ 的相对偏差 $\\epsilon_\\ell(x_{\\mathrm{end}})$：\n$$\n\\epsilon_\\ell(x_{\\mathrm{end}}) = \\frac{\\left|F_\\ell^{\\mathrm{num}}(x_{\\mathrm{end}}) - j_\\ell(x_{\\mathrm{end}})\\right|}{\\max\\left(\\left|j_\\ell(x_{\\mathrm{end}})\\right|, 10^{-14}\\right)}\n$$\n每个测试用例的最终结果是这些偏差的最大值，$\\epsilon_{\\max}(x_{\\mathrm{end}}) = \\max_{ \\ell \\in \\{0,1,2\\}} \\epsilon_\\ell(x_{\\mathrm{end}})$。\n\n**5. 测试用例处理**\n如验证中所确立的，RD和MD时期的区别与 $F_\\ell(x)$ 的计算无关。因此，对 $x_{\\mathrm{end}} = 10^{-3}$、$x_{\\mathrm{end}} = 1$ 和 $x_{\\mathrm{end}} = 20$ 的计算只执行一次，其结果在最终输出中为相应的 RD 和 MD 测试用例复制。最终结果列表将有6个条目。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.special import spherical_jn\n\ndef solve():\n    \"\"\"\n    Solves the truncated Boltzmann hierarchy and computes the maximum relative\n    deviation from the analytic solution for a set of test cases.\n    \"\"\"\n    # Define constants from the problem statement.\n    x0 = 1.0e-6\n    floor_val = 1.0e-14\n\n    # Define the test cases. Note that the distinction between RD and MD eras is\n    # irrelevant for the computation of F_l(x), as the hierarchy's evolution\n    # only depends on the dimensionless variable x.\n    x_end_values_unique = [1.0e-3, 1.0, 20.0]\n    test_cases_x_end = [1.0e-3, 1.0, 20.0] * 2 # RD cases followed by MD cases\n\n    def boltzmann_hierarchy_truncated(x, F):\n        \"\"\"\n        Defines the system of ODEs for the truncated Boltzmann hierarchy.\n        \n        Args:\n            x (float): The dimensionless time variable k*eta.\n            F (np.ndarray): The state vector [F0, F1, F2].\n        \n        Returns:\n            list: The derivatives [dF0/dx, dF1/dx, dF2/dx].\n        \"\"\"\n        F0, F1, F2 = F\n        \n        # Equation for F_0: d_x F_0 = -F_1\n        dF0_dx = -F1\n        \n        # Equation for F_1: d_x F_1 = (1/3)*(F_0 - 2*F_2)\n        dF1_dx = F0 / 3.0 - (2.0 / 3.0) * F2\n        \n        # Equation for F_2 with closure F_3 = (3/x)*F_2:\n        # d_x F_2 = (1/5)*(2*F_1 - 3*F_3) = (2/5)*F_1 - (9/5x)*F_2\n        if x == 0:\n            # This case should not be reached since we start at x0  0.\n            # The small-x limit of dF2/dx is 0.\n            dF2_dx = 0.0\n        else:\n            dF2_dx = (2.0 / 5.0) * F1 - (9.0 / (5.0 * x)) * F2\n            \n        return [dF0_dx, dF1_dx, dF2_dx]\n\n    # Store results for unique x_end values to avoid redundant computations.\n    unique_results = {}\n\n    for x_end in x_end_values_unique:\n        # Set initial conditions using the analytic solution at x0.\n        # F_l(x0) = j_l(x0) for l=0,1,2.\n        F_initial = spherical_jn([0, 1, 2], x0)\n\n        # Numerically integrate the system of ODEs.\n        # Use high-precision tolerances to isolate the error from the closure.\n        sol = solve_ivp(\n            fun=boltzmann_hierarchy_truncated,\n            t_span=[x0, x_end],\n            y0=F_initial,\n            t_eval=[x_end],\n            method='LSODA',  # Good for potentially stiff problems like this.\n            rtol=1e-12,\n            atol=1e-14\n        )\n        # Numerical solution at x_end\n        F_num = sol.y.flatten()\n\n        # Analytic solution at x_end is j_l(x_end)\n        F_ana = spherical_jn([0, 1, 2], x_end)\n\n        # Compute the relative deviation for each multipole l={0,1,2}.\n        numerator = np.abs(F_num - F_ana)\n        denominator = np.maximum(np.abs(F_ana), floor_val)\n        epsilons = numerator / denominator\n        \n        # Find the maximum deviation for this test case.\n        epsilon_max = np.max(epsilons)\n        unique_results[x_end] = epsilon_max\n\n    # Assemble the final list of results in the specified order.\n    results = [unique_results[x] for x in test_cases_x_end]\n\n    # Format the output as specified: a list of floats in scientific\n    # notation with 8 significant digits.\n    formatted_results = [f\"{r:.8e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "3493623"}, {"introduction": "闭合关系的选择不仅仅是数值精度的问题，它还具有深刻的物理影响。这个练习旨在揭示数值选择与物理后果之间的联系，指导您证明并用数值方法验证一个不恰当的闭合方案会如何产生伪各向异性应力，从而非物理地改变引力势的演化。通过这项实践，您将深刻理解数值实现与正确物理建模之间的关键纽带。[@problem_id:3493570]", "problem": "考虑一个空间平坦的弗里德曼-勒梅特-罗伯逊-沃尔克宇宙中的线性标量微扰，采用牛顿规范，其线元为 $ds^2 = a^2(\\tau)\\left\\{-(1+2\\psi)d\\tau^2 + (1-2\\phi)d\\mathbf{x}^2\\right\\}$，其中 $a(\\tau)$ 是标度因子，$\\tau$ 是共形时间。关注作为唯一物质组分的无碰撞、无质量中微子，并考虑一个具有共动波数 $k$ 的傅里叶模式。中微子的相空间分布函数微扰被展开为勒让德多极矩，形成一个玻尔兹曼级联 $F_\\ell(\\tau)$，其中 $\\ell = 0,1,2,\\dots$。相关的关系式包括：傅里叶空间中牛顿规范势 $\\phi$ 和 $\\psi$ 的线性化爱因斯坦方程、由玻尔兹曼多极矩定义的各向异性应力，以及无质量物质的无碰撞玻尔兹曼级联。使用以下基本事实作为出发点：\n- 在辐射主导时期，共形哈勃率满足 $H(\\tau) \\equiv a'(\\tau)/a(\\tau) = 1/\\tau$，且背景弗里德曼方程意味着 $8\\pi G a^2 \\rho = 3H^2$。\n- 傅里叶空间中的牛顿规范爱因斯坦方程（约束方程）为\n$$\nk^2 \\psi + 3 H \\left(\\psi' + H \\phi\\right) = -4\\pi G a^2 \\delta \\rho,\\quad\nk^2 \\left(\\psi' + H \\phi\\right) = 4\\pi G a^2 (\\rho + P) \\theta,\\quad\nk^2(\\phi - \\psi) = 12\\pi G a^2 \\sum_s (\\rho_s + P_s) \\sigma_s,\n$$\n其中撇号表示 $d/d\\tau$，$\\delta \\rho$ 是能量密度微扰，$\\theta$ 是速度散度，$\\sigma_s$ 是物质组分 $s$ 的各向异性应力。对于无质量物质，$(\\rho+P)=\\frac{4}{3}\\rho$。\n- 对于无碰撞的无质量中微子，与亮度多极矩的标准对应关系成立：$\\delta_\\nu = F_0$，$\\theta_\\nu = \\frac{3k}{4}F_1$，$\\sigma_\\nu = \\frac{1}{2}F_2$，且对于 $\\ell \\ge 3$，无碰撞演化是自由流。\n- 无质量物质多极矩的无碰撞玻尔兹曼级联是\n$$\nF_0' = -k F_1 - 4\\phi',\\quad\nF_1' = k\\left(\\frac{F_0}{3} - \\frac{2F_2}{3}\\right) + k\\psi,\\quad\nF_2' = k\\left(\\frac{2F_1}{5} - \\frac{3F_3}{5}\\right),\\quad\nF_\\ell' = \\frac{k}{2\\ell+1}\\left[\\ell F_{\\ell-1} - (\\ell+1)F_{\\ell+1}\\right]\\ \\text{for}\\ \\ell\\ge 3.\n$$\n\n您的任务是：\n1. 证明在有限多极矩 $l_{\\max}$ 处截断玻尔兹曼级联，并为 $F_{l_{\\max}+1}$ 使用不恰当的闭合关系，通常会产生伪各向异性应力（通过不正确的 $F_2$），从而导致 $\\phi$ 和 $\\psi$ 之间出现非物理性差异，并反馈到动力学中。您的证明必须从上述基本方程出发，通过逻辑步骤进行，不得假设任何在您的推理中未推导出的简化公式。您必须做出一个科学上现实的近似选择，以便将证明推导出一个清晰的数学陈述，并且必须明确说明您的近似适用的机制。\n2. 设计一个数值测试，以检测因不恰当闭合而对度规演化造成的污染。该测试必须能够作为一个程序实现，并应产生一个可量化的诊断指标。将测试建立在一个仅含中微子的辐射背景 $a(\\tau) \\propto \\tau$ 上，并在次视界、准静态机制下工作，其中 $k \\gg H(\\tau)$ 且在类泊松方程中 $3H(\\psi' + H\\phi)$ 项可忽略不计。检测应基于比较使用物理上合理的自由流闭合与朴素闭合所获得的引力滑移参数 $\\eta(\\tau) \\equiv \\frac{\\phi(\\tau)-\\psi(\\tau)}{\\psi(\\tau)}$。物理上合理的闭合可以采用渐近自由流形式 $F_{l_{\\max}+1} \\approx \\frac{2l_{\\max}+1}{k\\tau}F_{l_{\\max}}$，而朴素闭合则设置 $F_{l_{\\max}+1}=0$。\n3. 将该测试实现为一个完整的可运行程序，该程序为一个单一傅里叶模式积分玻尔兹曼级联，并计算在两种闭合下最终时刻的滑移 $\\eta(\\tau_f)$，如果绝对差异超过指定的阈值，则宣布检测到污染，并为每个测试用例输出一个布尔值。使用准静态次视界近似\n$$\n\\psi(\\tau) \\approx -\\frac{3}{2}\\frac{H^2(\\tau)}{k^2}F_0(\\tau),\\quad\n\\phi(\\tau) \\approx \\psi(\\tau) + \\frac{6H^2(\\tau)}{k^2}\\sigma_\\nu(\\tau) = \\psi(\\tau) + \\frac{3H^2(\\tau)}{k^2}F_2(\\tau),\n$$\n并通过用 $F_0$ 和 $F_2$ 的时间导数消去 $\\phi'$，自洽地实施级联与 $\\phi'$ 的耦合。\n\n定义初始多极矩在 $\\tau=\\tau_i$ 时为 $F_0(\\tau_i)=10^{-5}$ 和 $F_\\ell(\\tau_i)=0$ for $\\ell\\ge 1$。您必须将所有量视为无量纲量，并明确说明您使用的任何近似。您的程序必须使用以下测试套件，涵盖一个理想路径情况、一个截断应力边缘情况和一个高分辨率边界情况：\n\n- 测试用例 1（理想路径情况）：$l_{\\max}=7$, $k=3.0$, $\\tau_i=20.0$, $\\tau_f=120.0$, 阈值 $=10^{-3}$。\n- 测试用例 2（边缘情况，激进截断）：$l_{\\max}=3$, $k=3.0$, $\\tau_i=20.0$, $\\tau_f=120.0$, 阈值 $=10^{-2}$。\n- 测试用例 3（边界情况，高多极矩分辨率）：$l_{\\max}=25$, $k=3.0$, $\\tau_i=20.0$, $\\tau_f=120.0$, 阈值 $=10^{-5}$。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如，\"[True,False,True]\"。每个元素都是一个布尔值，指示在比较朴素闭合与物理上合理的闭合时，相应测试用例是否检测到污染。所有输出均为无量纲。不涉及角度或百分比；输出中不包含任何单位。", "solution": "用户提供的问题已经过分析并被确定为有效。它在科学上基于宇宙学微扰理论的原理，在数学上是良定的，具有完整且一致的方程组和条件，并且其表述是客观的。该问题探讨了数值宇宙学中一个相关且不平凡的主题——玻尔兹曼级联中截断误差的影响。\n\n### 第 1 部分：由截断产生的伪各向异性应力证明\n\n目标是证明在有限多极矩 $\\ell_{\\max}$ 处截断玻尔兹曼级联，并为 $F_{\\ell_{\\max}+1}$ 使用不恰当的闭合关系，会产生非物理的各向异性应力，进而导致引力势 $\\phi$ 和 $\\psi$ 之间出现人为的差异。\n\n1.  **度规势与各向异性应力的关系：**\n    出发点是关联引力滑移 $\\phi-\\psi$ 与各向异性应力 $\\sigma_s$ 的爱因斯坦方程。对于单一物质组分的无质量中微子，该方程为：\n    $$k^2(\\phi - \\psi) = 12\\pi G a^2 (\\rho_\\nu + P_\\nu) \\sigma_\\nu$$\n    对于无质量物质（辐射），状态方程为 $P_\\nu = \\frac{1}{3}\\rho_\\nu$，因此 $\\rho_\\nu + P_\\nu = \\frac{4}{3}\\rho_\\nu$。方程变为：\n    $$k^2(\\phi - \\psi) = 12\\pi G a^2 \\left(\\frac{4}{3}\\rho_\\nu\\right) \\sigma_\\nu = 16\\pi G a^2 \\rho_\\nu \\sigma_\\nu$$\n    从辐射主导宇宙中的背景弗里德曼方程，我们有 $3H^2 = 8\\pi G a^2 \\rho_\\nu$。将此代入前一个方程得到：\n    $$k^2(\\phi - \\psi) = 2 \\cdot (8\\pi G a^2 \\rho_\\nu) \\sigma_\\nu = 2 \\cdot (3H^2) \\sigma_\\nu = 6H^2 \\sigma_\\nu$$\n    问题定义了中微子各向异性应力多极矩为 $\\sigma_\\nu = \\frac{1}{2}F_2$。代入此关系式得到直接关系：\n    $$k^2(\\phi - \\psi) = 3H^2 F_2 \\implies \\phi - \\psi = \\frac{3H^2}{k^2} F_2$$\n    此方程表明，四极矩 $F_2$ 计算中的任何误差都将直接且成比例地在 $\\phi$ 和 $\\psi$ 之间产生非物理的差异。\n\n2.  **截断误差在级联中的传播：**\n    对于 $\\ell \\ge 2$，玻尔兹曼多极矩的演化由无碰撞玻尔兹曼级联控制：\n    $$F_2' = k\\left(\\frac{2F_1}{5} - \\frac{3F_3}{5}\\right)$$\n    $$F_\\ell' = \\frac{k}{2\\ell+1}\\left[\\ell F_{\\ell-1} - (\\ell+1)F_{\\ell+1}\\right] \\quad \\text{for}\\ \\ell\\ge 3$$\n    为了数值求解该系统，必须在某个有限的 $\\ell_{\\max}$ 处进行截断。$F_{\\ell_{\\max}}$ 的方程为：\n    $$F_{\\ell_{\\max}}' = \\frac{k}{2\\ell_{\\max}+1}\\left[\\ell_{\\max} F_{\\ell_{\\max}-1} - (\\ell_{\\max}+1)F_{\\ell_{\\max}+1}\\right]$$\n    此方程需要一个关于 $F_{\\ell_{\\max}+1}$ 的闭合关系。一种朴素但错误的闭合是设置 $F_{\\ell_{\\max}+1} = 0$。\n\n3.  **在自由流机制下的分析：**\n    证明在次视界、自由流机制（$k\\tau \\gg 1$）下最为清晰，在该机制下，微扰以相对论性速度传播。在此机制下，多极矩 $F_\\ell$ 的真实物理演化解非零，且通常呈振荡衰减（类似于球贝塞尔函数，$F_\\ell \\sim j_\\ell(k\\tau)$）。关键在于，如果 $F_{\\ell_{\\max}}$ 非零，那么 $F_{\\ell_{\\max}+1}$ 通常也非零。\n\n4.  **误差级联：**\n    令 $\\tilde{F}_\\ell$ 为使用朴素闭合 $\\tilde{F}_{\\ell_{\\max}+1} = 0$ 计算出的数值多极矩，令 $F_\\ell$ 为真实的物理演化解。\n    计算出的 $\\tilde{F}_{\\ell_{\\max}}$ 的演化变为：\n    $$\\tilde{F}_{\\ell_{\\max}}' = \\frac{k \\ell_{\\max}}{2\\ell_{\\max}+1}\\tilde{F}_{\\ell_{\\max}-1}$$\n    导数的误差 $\\Delta F_{\\ell_{\\max}}' = \\tilde{F}_{\\ell_{\\max}}' - F_{\\ell_{\\max}}'$，可通过从截断后的演化方程中减去真实的演化方程得到：\n    $$\\Delta F_{\\ell_{\\max}}' \\approx \\frac{k(\\ell_{\\max}+1)}{2\\ell_{\\max}+1} F_{\\ell_{\\max}+1}$$\n    此处我们假设较低阶多极矩的误差初始很小，即 $\\tilde{F}_{\\ell_{\\max}-1} \\approx F_{\\ell_{\\max}-1}$。由于物理上 $F_{\\ell_{\\max}+1} \\neq 0$，朴素闭合引入了一个误差源项 $\\Delta F_{\\ell_{\\max}}'$。这个误差会通过级联向下传播。任何较低阶多极矩 $\\ell-1$ 的方程是 $F_{\\ell-1}' = \\frac{k}{2\\ell-1}\\left[(\\ell-1)F_{\\ell-2} - \\ell F_\\ell\\right]$，这表明误差 $\\Delta F_{\\ell_{\\max}}$ 将产生误差 $\\Delta F_{\\ell_{\\max}-1}'$，进而产生 $\\Delta F_{\\ell_{\\max}-2}'$ 的误差，依此类推。这个误差级联不可避免地会到达 $F_3$，产生误差 $\\Delta F_3$。\n\n5.  **结论：**\n    误差 $\\Delta F_3$ 会反馈到四极矩的演化中：\n    $$\\Delta F_2' = \\tilde{F}_2' - F_2' = k\\left(-\\frac{3}{5}\\Delta F_3\\right)$$\n    这会产生一个随时间累积的误差 $\\Delta F_2$。这个伪 $\\tilde{F}_2 = F_2 + \\Delta F_2$ 直接产生了一个伪各向异性应力 $\\tilde{\\sigma}_\\nu = \\frac{1}{2}\\tilde{F}_2$。如步骤 1 所示，这导致了非物理的引力滑移：\n    $$(\\phi - \\psi)_{\\text{spurious}} = \\frac{3H^2}{k^2} \\tilde{F}_2 \\neq \\frac{3H^2}{k^2} F_2 = (\\phi - \\psi)_{\\text{physical}}$$\n    至此证明完成。不恰当的闭合 $F_{\\ell_{\\max}+1}=0$ 引入了系统性误差，污染了整个级联，最终导致度规势的演化在物理上不正确。\n\n### 第 2 部分：数值测试设计\n\n数值测试旨在通过比较两种不同玻尔兹曼级联闭合方案的结果来量化上述污染。\n\n1.  **常微分方程组（System of ODEs）：** 测试的核心是对多极矩向量 $\\vec{F}(\\tau) = [F_0, F_1, \\dots, F_{\\ell_{\\max}}]^T$ 的 $l_{\\max}+1$ 个耦合一阶常微分方程组进行数值积分。\n2.  **运动方程（Equations of Motion）：** 导数 $F_\\ell' = dF_\\ell/d\\tau$ 由玻尔兹曼级联给出。$F_0'$ 和 $F_1'$ 的方程经过修改，以包含在准静态次视界近似（$k \\gg H$）下自洽计算的引力源项 $\\phi'$ 和 $\\psi$。\n    -   势：$\\psi(\\tau) = -\\frac{3}{2}\\frac{H^2(\\tau)}{k^2}F_0(\\tau)$ 和 $\\phi(\\tau) = \\psi(\\tau) + \\frac{3H^2(\\tau)}{k^2}F_2(\\tau)$，其中 $H(\\tau)=1/\\tau$。\n    -   $F_0'$ 项：通过对 $\\phi(\\tau)$ 的表达式求导并将其代回 $F_0'$ 方程，代数消去 $F_0'$ 方程中的 $\\phi'$ 项。这会得到一个依赖于 $F_0, F_1, F_2, F_3$ 的 $F_0'$ 方程。\n    -   $F_1'$ 项：将势 $\\psi$ 直接代入 $F_1'$ 的方程中。\n    -   级联：剩余的 $F_\\ell'$ 方程（$\\ell \\ge 2$）按原样使用。\n\n3.  **闭合方案（Closure Schemes）：** 系统将被积分两次，每次使用不同的 $F_{\\ell_{\\max}+1}$ 闭合方案：\n    -   **朴素闭合：** $F_{\\ell_{\\max}+1}(\\tau) = 0$。预计会产生污染。\n    -   **物理上合理的闭合：** $F_{\\ell_{\\max}+1}(\\tau) \\approx \\frac{2\\ell_{\\max}+1}{k\\tau}F_{\\ell_{\\max}}(\\tau)$。这是一个在自由流极限（$k\\tau \\gg \\ell_{\\max}$）下有效的渐近近似，可作为更准确的物理参考。\n\n4.  **诊断与检测（Diagnostic and Detection）：** 诊断指标是引力滑移参数 $\\eta(\\tau) = \\frac{\\phi(\\tau)-\\psi(\\tau)}{\\psi(\\tau)}$。使用准静态近似：\n    $$\\eta(\\tau) = \\frac{(3H^2/k^2) F_2(\\tau)}{-(3H^2/2k^2) F_0(\\tau)} = -2\\frac{F_2(\\tau)}{F_0(\\tau)}$$\n    测试流程如下：\n    a. 使用初始条件 $F_0(\\tau_i)=10^{-5}$ 和 $F_{\\ell\\ge1}(\\tau_i)=0$，将常微分方程组从 $\\tau_i$ 积分到 $\\tau_f$。对朴素闭合和物理闭合都执行此操作，以获得最终状态向量 $\\vec{F}_{\\text{naive}}(\\tau_f)$ 和 $\\vec{F}_{\\text{phys}}(\\tau_f)$。\n    b. 计算两种情况下的最终滑移参数：$\\eta_{\\text{naive}}(\\tau_f) = -2 \\frac{F_{2, \\text{naive}}(\\tau_f)}{F_{0, \\text{naive}}(\\tau_f)}$ 和 $\\eta_{\\text{phys}}(\\tau_f) = -2 \\frac{F_{2, \\text{phys}}(\\tau_f)}{F_{0, \\text{phys}}(\\tau_f)}$。\n    c. 计算绝对差值 $\\Delta\\eta = |\\eta_{\\text{naive}} - \\eta_{\\text{phys}}|$。\n    d. 如果 $\\Delta\\eta$ 超过测试用例指定的阈值，则检测到污染。\n\n### 第 3 部分：实现策略\n\n该数值测试以 Python 程序实现。\n-   **常微分方程求解器（ODE Solver）：** 使用 `scipy.integrate.solve_ivp` 函数，因其稳健性和自适应步长控制，适用于玻尔兹曼级联可能存在的刚性或振荡行为。\n-   **导数函数（Derivatives Function）：** 定义一个函数 `derivatives(tau, F, k, lmax, closure_type)` 来计算时间导数向量 $\\vec{F}'$。\n    -   它接受当前时间 `tau`、状态向量 `F`、波数 `k`、截断水平 `lmax` 和指定 `closure_type` 的字符串。\n    -   它实现了选择 $F_{\\ell_{\\max}+1}$ 闭合方案的逻辑。\n    -   它根据级联方程和自洽的准静态近似计算每个 $F_\\ell'$。逻辑结构正确处理了 $\\ell=0, 1, 2$ 的特殊形式和 $\\ell \\ge 3$ 的通用形式。\n-   **主循环（Main Loop）：** 一个主函数遍历预定义的测试用例。对于每个用例，它初始化系统，运行求解器两次（每种闭合一次），计算污染诊断指标 $\\Delta\\eta$，并将其与阈值进行比较以产生布尔结果。最终输出格式化为这些布尔值的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef derivatives(tau, F, k, lmax, closure_type):\n    \"\"\"\n    Computes the time derivative of the Boltzmann hierarchy multipoles F_l.\n\n    Args:\n        tau (float): Conformal time.\n        F (np.ndarray): State vector of multipoles [F_0, F_1, ..., F_lmax].\n        k (float): Comoving wavenumber.\n        lmax (int): Maximum multipole moment in the hierarchy.\n        closure_type (str): Either 'naive' or 'phys' for the closure scheme.\n\n    Returns:\n        np.ndarray: The vector of derivatives dF/dtau.\n    \"\"\"\n    dF = np.zeros(lmax + 1)\n\n    # A helper to get F_l, applying the closure rule for l  lmax.\n    # This simplifies the loops and makes the logic clear.\n    def get_F(l):\n        if l = lmax:\n            return F[l]\n        elif l == lmax + 1:\n            if closure_type == 'naive':\n                return 0.0\n            elif closure_type == 'phys':\n                # Physically motivated free-streaming closure\n                return (2 * lmax + 1) / (k * tau) * F[lmax]\n            else:\n                raise ValueError(\"Unknown closure_type\")\n        else:\n            # For l  lmax + 1, we assume the contribution is zero.\n            # This is implicitly part of the truncation scheme.\n            return 0.0\n\n    # The problem specifies test cases with lmax = 3, so F[0]..F[3] exist.\n    F0, F1, F2, F3 = get_F(0), get_F(1), get_F(2), get_F(3)\n\n    # --- F_0' Equation ---\n    # This is the most complex due to the self-consistent treatment of phi'.\n    # F_0'(1 + 6/(k^2*tau^2)) = -k*F_1 - 12/(k^2*tau^3)*F_0 + 24/(k^2*tau^3)*F_2 - 12/(k^2*tau^2)*F_2'\n    # We substitute F_2' = k*(2/5*F_1 - 3/5*F_3)\n    F2_prime = k * (2.0 / 5.0 * F1 - 3.0 / 5.0 * F3)\n    \n    # Pre-computation for clarity\n    k_tau_sq = (k * tau)**2\n    k_sq_tau_cubed = k**2 * tau**3\n    \n    f0_factor = 1.0 + 6.0 / k_tau_sq\n    rhs_f0 = -k * F1 - (12.0 / k_sq_tau_cubed) * F0 \\\n             + (24.0 / k_sq_tau_cubed) * F2 \\\n             - (12.0 / k_tau_sq) * F2_prime\n    dF[0] = rhs_f0 / f0_factor\n\n    # --- F_1' Equation ---\n    # F_1' = k*(F_0/3 - 2*F_2/3) + k*psi, with psi = -1.5/(k^2*tau^2)*F_0\n    psi = -1.5 / k_tau_sq * F0\n    dF[1] = k * (F0 / 3.0 - 2.0 / 3.0 * F2) + k * psi\n\n    # --- F_2' and higher Hierarchy ---\n    # F_2'\n    dF[2] = F2_prime\n\n    # F_l' for l in [3, lmax]\n    for l in range(3, lmax + 1):\n        F_l_minus_1 = get_F(l - 1)\n        F_l_plus_1 = get_F(l + 1)\n        dF[l] = (k / (2 * l + 1.0)) * (l * F_l_minus_1 - (l + 1) * F_l_plus_1)\n\n    return dF\n\n\ndef run_test_case(lmax, k, tau_i, tau_f, threshold):\n    \"\"\"\n    Runs the numerical test for a single case.\n    \"\"\"\n    # Initial conditions\n    y0 = np.zeros(lmax + 1)\n    y0[0] = 1e-5\n\n    # Integration parameters for solve_ivp\n    integration_params = {\n        't_span': [tau_i, tau_f],\n        'y0': y0,\n        'method': 'RK45', # Standard choice\n        'rtol': 1e-9,\n        'atol': 1e-12\n    }\n\n    # Solve with naive closure\n    sol_naive = solve_ivp(derivatives, args=(k, lmax, 'naive'), **integration_params)\n    F_naive_final = sol_naive.y[:, -1]\n\n    # Solve with physical closure\n    sol_phys = solve_ivp(derivatives, args=(k, lmax, 'phys'), **integration_params)\n    F_phys_final = sol_phys.y[:, -1]\n\n    # Calculate slip parameter eta = -2 * F_2 / F_0\n    # Guard against division by zero, although F_0 should be stable.\n    if F_naive_final[0] == 0 or F_phys_final[0] == 0:\n        # This case indicates a numerical failure, should not happen.\n        return False\n        \n    eta_naive = -2.0 * F_naive_final[2] / F_naive_final[0]\n    eta_phys = -2.0 * F_phys_final[2] / F_phys_final[0]\n\n    # Detect contamination\n    delta_eta = abs(eta_naive - eta_phys)\n    return delta_eta  threshold\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (l_max, k, tau_i, tau_f, threshold)\n        (7, 3.0, 20.0, 120.0, 1e-3),\n        (3, 3.0, 20.0, 120.0, 1e-2),\n        (25, 3.0, 20.0, 120.0, 1e-5),\n    ]\n\n    results = []\n    for case in test_cases:\n        lmax, k, tau_i, tau_f, threshold = case\n        result = run_test_case(lmax, k, tau_i, tau_f, threshold)\n        results.append(result)\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3493570"}, {"introduction": "现代宇宙学的一个核心要素是中微子质量，它对宇宙结构和宇宙微波背景辐射（CMB）有着可观测的影响。与无质量的光子不同，有质量中微子扰动的演化需要在其动量分布上进行积分。本练习专注于一项关键的数值技术——构建专门的高斯求积法——来精确计算这些动量积分，这对于准确模拟中微子质量的宇宙学效应至关重要。[@problem_id:3493584]", "problem": "考虑宇宙微波背景（CMB）各向异性线性体系和玻尔兹曼等级结构中的有质量中微子。在没有碰撞的情况下，刘维尔方程意味着未受扰动的相空间分布函数沿着测地线守恒。对于一种具有费米-狄拉克平衡分布且化学势为零的中微子，其共动动量 $q$ 是恒定的，而共动能量为 $\\epsilon(a,q) = \\sqrt{q^2 + a^2 m_\\nu^2}$，其中 $a$ 是尺度因子，$m_\\nu$ 是中微子质量。如果使用今天的中微子温度将共动动量无量纲化为 $q \\rightarrow q/T_{\\nu,0}$，那么无量纲量 $y \\equiv a m_\\nu / T_{\\nu,0}$ 控制着从相对论性到非相对论性的转变。该中微子物种的背景能量密度和压强可以写成对共动动量和费米-狄拉克因子的积分。以无量纲形式，定义以下矩：\n$$\n\\rho_\\nu(y) \\propto \\int_0^\\infty \\frac{q^2 \\sqrt{q^2 + y^2}}{e^{q} + 1} \\, dq, \\qquad\nP_\\nu(y) \\propto \\int_0^\\infty \\frac{q^4}{3 \\sqrt{q^2 + y^2}} \\frac{1}{e^{q} + 1} \\, dq,\n$$\n以及相应的状态方程参数 $w_\\nu(y) \\equiv P_\\nu(y)/\\rho_\\nu(y)$。比例因子相对于 $q$ 和 $y$ 是恒定的，并且为了本次数值练习的目的可以忽略；目标是计算无量纲积分本身。\n\n你的任务是设计并实现一种数值策略，以评估以下形式的积分：\n$$\nI_h(y) \\equiv \\int_0^\\infty \\frac{h(q,y)}{e^{q} + 1} \\, dq\n$$\n针对依赖于共动动量 $q$ 和参数 $y$ 的光滑函数 $h(q,y)$，特别关注 $y$ 既不是极小也不是极大的过渡区域。通过离散化共动动量 $q$ 并构建求积节点和权重，构造一个专门用于半无限区间 $[0,\\infty)$ 的高斯求积法，以便在相对论性过渡区内得到精确的积分结果。该构造必须从第一性原理推导：从 $\\rho_\\nu(y)$ 和 $P_\\nu(y)$ 的相空间积分出发，系统地将积分转换为适合在 $[0,\\infty)$ 上进行高斯求积的形式，而不假设任何预先存在的针对费米-狄拉克积分的专门规则。明确论证求积法中使用的正交多项式和权重函数的选择。\n\n实现一个程序，该程序：\n- 针对所选的权重函数，在 $[0,\\infty)$ 上构造高斯求积节点和权重，并用它们来近似定义给定 $y$ 值的 $\\rho_\\nu(y)$ 和 $P_\\nu(y)$ 的积分。\n- 使用在 $[0,\\infty)$ 上的自适应数值积分计算相同积分的高精度参考值。\n- 报告 $\\rho_\\nu(y)$、$P_\\nu(y)$ 和 $w_\\nu(y)$ 的求积近似值，以及 $\\rho_\\nu(y)$ 和 $P_\\nu(y)$ 相对于参考值的相对误差。\n\n所有量都是无量纲的，因此不需要物理单位。\n\n测试套件：\n提供以下测试用例 $(y,N)$ 的结果，其中 $y$ 是无量纲质量参数，$N$ 是高斯求积点的数量：\n1. $(y,N) = (0.0, 12)$ 用于探究严格相对论极限。\n2. $(y,N) = (0.5, 16)$ 作为轻度相对论情况。\n3. $(y,N) = (1.0, 24)$ 作为过渡区附近的“理想路径”情况。\n4. $(y,N) = (10.0, 12)$ 作为使用较少节点的中度非相对论情况，以测试稳健性。\n5. $(y,N) = (50.0, 48)$ 使用更多节点来探究深度非相对论极限。\n\n对于每个案例，计算：\n- $\\rho_\\nu(y)$ 的高斯求积近似值，\n- $P_\\nu(y)$ 的高斯求积近似值，\n- $w_\\nu(y)$ 的高斯求积近似值，\n- $\\rho_\\nu(y)$ 相对于自适应参考值的相对误差，以小数表示，\n- $P_\\nu(y)$ 相对于自适应参考值的相对误差，以小数表示。\n\n最终输出格式：\n你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个测试用例按 $[\\rho_\\nu(y),P_\\nu(y),w_\\nu(y),\\text{rel\\_err\\_}\\rho_\\nu(y),\\text{rel\\_err\\_}P_\\nu(y)]$ 的顺序列出。例如，对于两个案例，输出格式将为：\n$$\n\\text{[}[r_1,p_1,w_1,e_{\\rho,1},e_{p,1}],[r_2,p_2,w_2,e_{\\rho,2},e_{p,2}]\\text{]}.\n$$\n你的程序必须在内部实现所有计算，并且不得读取任何外部输入。", "solution": "用户提供的问题是有效的。它在科学上基于标准宇宙学模型中的有质量中微子物理学，问题定义明确，目标清晰，数据充分，并使用了精确、客观的语言。任务是开发并实现一种数值方法，用于评估在此背景下出现的特定积分，这是一个在计算物理学中非凡但可行的问​​题。\n\n### 基于原理的解决方案设计\n\n问题的核心是以下形式积分的数值评估：\n$$\nI_h(y) = \\int_0^\\infty \\frac{h(q,y)}{e^{q} + 1} \\, dq\n$$\n其中 $h(q,y)$ 代表与有质量中微子物种的能量密度和压强相关的函数。具体来说，对于能量密度 $\\rho_\\nu(y)$ 和压强 $P_\\nu(y)$，这些函数是：\n$$\nh_\\rho(q,y) = q^2 \\sqrt{q^2 + y^2}\n$$\n$$\nh_P(q,y) = \\frac{q^4}{3 \\sqrt{q^2 + y^2}}\n$$\n因子 $1 / (e^q + 1)$ 是费米-狄拉克分布因子。目标是构建一个高斯求积法则来精确评估这些积分。\n\n#### 1. 求积方案的选择\n\n标准的高斯求积方法，如 Gauss-Legendre 求积，定义在有限区间（通常是 $[-1, 1]$）上，不直接适用于我们积分的半无限区间 $[0, \\infty)$。虽然变量替换可以将 $[0, \\infty)$ 映射到有限区间，但这通常会引入新的数值挑战，或导致被积函数无法用低阶多项式很好地近似。\n\n一种更有效的策略是使用专为区间 $[0, \\infty)$ 设计的高斯求积法则。高斯求积的一般形式是将积分近似为一个加权和：\n$$\n\\int_a^b W(q) f(q) \\, dq \\approx \\sum_{i=1}^{N} w_i f(q_i)\n$$\n其中 $W(q)$ 是一个固定的权重函数，$q_i$ 是求积节点（或点），$w_i$ 是相应的权重。关键是从我们的被积函数中选择一个合适的 $W(q)$。\n\n我们的积分可以通过提取 Gauss-Laguerre 求积的标准权重函数 $W(q) = e^{-q}$ 来重写：\n$$\nI_h(y) = \\int_0^\\infty e^{-q} \\left( \\frac{e^q}{e^q + 1} h(q,y) \\right) \\, dq\n$$\n我们将要求积法则近似的函数确定为：\n$$\nf(q; y) = \\frac{e^q}{e^q + 1} h(q,y) = \\frac{1}{1 + e^{-q}} h(q,y)\n$$\n第二种形式使用 $e^{-q}$，在数值稳定性方面更可取，因为它避免了当 $q$ 值较大时发生溢出。\n\n$W(q) = e^{-q}$ 的选择是充分合理的。它将费米-狄拉克因子在 $q$ 较大时的主要指数衰减行为分离出来，作为一个标准的权重函数。相关的正交多项式是 Laguerre 多项式 $L_n(q)$，所得的求积法即为 Gauss-Laguerre 求积。为了使该方法高效，函数 $f(q;y)$ 必须能被 $q$ 的多项式很好地近似。对于 $\\rho_\\nu$ 和 $P_\\nu$，函数 $h(q,y)$ 在 $q$ 较大时表现为 $q$ 的幂次（具体为 $q^3$），而因子 $1/(1+e^{-q})$ 平滑地趋近于 $1$。因此，$f(q;y)$ 是一个适合多项式近似的光滑函数。\n\n#### 2. Gauss-Laguerre 求积法则的构建\n\n问题要求从第一性原理构建求积法则。一个 $N$ 点 Gauss-Laguerre 求积的节点 $q_i$ 是 $N$ 阶 Laguerre 多项式 $L_N(q)$ 的根。节点和权重可以通过 Golub-Welsch 算法高效且稳定地确定，该算法将问题与一个称为 Jacobi 矩阵的特定对称三对角矩阵的特征系统联系起来。\n\n首一（monic）Laguerre 多项式 $\\hat{L}_n(q)$ 满足三项递推关系：\n$$\n\\hat{L}_{n+1}(q) = (q - \\alpha_n) \\hat{L}_n(q) - \\beta_n \\hat{L}_{n-1}(q)\n$$\n其递推系数为：\n$$\n\\alpha_n = 2n + 1, \\qquad \\beta_n = n^2\n$$\n相应的 $N \\times N$ Jacobi 矩阵 $J_N$ 由这些系数构建：\n$$\nJ_N = \\begin{pmatrix}\n\\alpha_0  \\sqrt{\\beta_1}  0  \\dots  0 \\\\\n\\sqrt{\\beta_1}  \\alpha_1  \\sqrt{\\beta_2}  \\dots  0 \\\\\n0  \\sqrt{\\beta_2}  \\alpha_2  \\ddots  \\vdots \\\\\n\\vdots   \\ddots  \\ddots  \\sqrt{\\beta_{N-1}} \\\\\n0  \\dots  \\dots  \\sqrt{\\beta_{N-1}}  \\alpha_{N-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1  1  0  \\dots  0 \\\\\n1  3  2  \\dots  0 \\\\\n0  2  5  \\ddots  \\vdots \\\\\n\\vdots   \\ddots  \\ddots  N-1 \\\\\n0  \\dots  \\dots  N-1  2N-1\n\\end{pmatrix}\n$$\n该矩阵 $J_N$ 的特征值是求积节点 $\\{q_i\\}_{i=1}^N$。相应的权重 $\\{w_i\\}_{i=1}^N$ 由归一化特征向量的第一个分量的平方给出。权重函数的积分为 $\\int_0^\\infty e^{-q} dq = 1$，这简化了权重的计算。\n\n算法流程如下：\n1. 对于给定的点数 $N$，构建 $N \\times N$ 的 Jacobi 矩阵 $J_N$。\n2. 求解 $J_N$ 的特征值问题，以获得特征值（节点 $q_i$）和相应的归一化特征向量 $\\mathbf{v}_i$。\n3. 权重为 $w_i = (\\mathbf{v}_i)_1^2$，其中 $(\\mathbf{v}_i)_1$ 是特征向量 $\\mathbf{v}_i$ 的第一个分量。\n\n#### 3. 数值实现与评估\n\n在构建了节点 $q_i$ 和权重 $w_i$ 之后，能量密度和压强的积分近似为：\n$$\n\\rho_\\nu(y) \\approx \\sum_{i=1}^N w_i f_\\rho(q_i, y) = \\sum_{i=1}^N w_i \\frac{1}{1+e^{-q_i}} \\left( q_i^2 \\sqrt{q_i^2 + y^2} \\right)\n$$\n$$\nP_\\nu(y) \\approx \\sum_{i=1}^N w_i f_P(q_i, y) = \\sum_{i=1}^N w_i \\frac{1}{1+e^{-q_i}} \\left( \\frac{q_i^4}{3 \\sqrt{q_i^2 + y^2}} \\right)\n$$\n在压强积分中，对 $y=0$ 的情况需要特别处理以避免除以零。在此极限下，$\\sqrt{q^2+y^2} \\to q$，因此 $h_P(q,0) \\to q^3/3$。\n\n为了评估此自定义求积法的准确性，我们使用一个自适应求积程序（具体为 `scipy.integrate.quad`）对原始积分形式 $\\int_0^\\infty g(q,y) dq$ 计算每个积分的高精度参考值。然后相对误差计算如下：\n$$\n\\text{rel\\_err} = \\left| \\frac{I_{\\text{approx}} - I_{\\text{ref}}}{I_{\\text{ref}}} \\right|\n$$\n状态方程参数直接由近似的密度和压强计算得出：$w_\\nu(y) = P_\\nu(y) / \\rho_\\nu(y)$。\n\n这种综合方法能够在从高相对论性（$y \\ll 1$）到非相对论性（$y \\gg 1$）的整个物理区间内，对所需的中微子矩积分进行稳健而精确的计算。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the neutrino integral problem by constructing a Gauss-Laguerre quadrature rule,\n    evaluating the integrals for given test cases, and comparing with a high-accuracy reference.\n    \"\"\"\n\n    test_cases = [\n        (0.0, 12),\n        (0.5, 16),\n        (1.0, 24),\n        (10.0, 12),\n        (50.0, 48),\n    ]\n\n    results = []\n    for y, N in test_cases:\n        # Step 1: Construct Gauss-Laguerre quadrature nodes and weights\n        # using the Golub-Welsch algorithm on the Jacobi matrix.\n        \n        # Coefficients for the three-term recurrence of monic Laguerre polynomials:\n        # alpha_n = 2n + 1, beta_n = n^2\n        alpha = np.arange(1, 2 * N, 2, dtype=float)\n        beta_sqrt = np.arange(1, N, dtype=float)\n\n        # Construct the symmetric tridiagonal Jacobi matrix\n        J = np.diag(alpha) + np.diag(beta_sqrt, k=1) + np.diag(beta_sqrt, k=-1)\n\n        # Solve the eigenvalue problem for the Jacobi matrix.\n        # Eigenvalues are the quadrature nodes.\n        # Weights are the squared first components of the normalized eigenvectors.\n        nodes, evecs = np.linalg.eigh(J)\n        weights = evecs[0, :]**2\n        \n        # Step 2: Define the integrands for density and pressure\n        \n        # Functions h(q,y) from the problem statement\n        def h_rho(q, y_val):\n            return q**2 * np.sqrt(q**2 + y_val**2)\n\n        def h_P(q, y_val):\n            if y_val == 0.0:\n                # For y=0, sqrt(q^2+y^2) = q. The integrand h_P becomes q^3/3.\n                # This correctly handles the limit q-0.\n                return q**3 / 3.0\n            else:\n                return q**4 / (3.0 * np.sqrt(q**2 + y_val**2))\n\n        # Functions f(q,y) = h(q,y) / (1 + exp(-q)) for Gauss-Laguerre quadrature\n        def f_rho(q, y_val):\n            return h_rho(q, y_val) / (1.0 + np.exp(-q))\n\n        def f_P(q, y_val):\n            return h_P(q, y_val) / (1.0 + np.exp(-q))\n        \n        # Step 3: Compute approximations using the constructed quadrature rule\n        rho_approx = np.sum(weights * f_rho(nodes, y))\n        p_approx = np.sum(weights * f_P(nodes, y))\n\n        if rho_approx != 0:\n            w_approx = p_approx / rho_approx\n        else:\n            w_approx = 0.0 # Should not happen as integrand is positive\n\n        # Step 4: Compute high-accuracy reference values using adaptive quadrature\n        \n        # Full integrands g(q,y) = h(q,y) / (exp(q) + 1)\n        def g_rho(q, y_val):\n            return h_rho(q, y_val) / (np.exp(q) + 1.0)\n        \n        def g_P(q, y_val):\n            return h_P(q, y_val) / (np.exp(q) + 1.0)\n\n        rho_ref, _ = integrate.quad(g_rho, 0, np.inf, args=(y,))\n        p_ref, _ = integrate.quad(g_P, 0, np.inf, args=(y,))\n        \n        # Step 5: Calculate relative errors\n        if rho_ref != 0:\n            rel_err_rho = np.abs((rho_approx - rho_ref) / rho_ref)\n        else:\n            rel_err_rho = 0.0 if rho_approx == 0.0 else np.inf\n\n        if p_ref != 0:\n            rel_err_p = np.abs((p_approx - p_ref) / p_ref)\n        else:\n            rel_err_p = 0.0 if p_approx == 0.0 else np.inf\n\n        results.append([\n            rho_approx,\n            p_approx,\n            w_approx,\n            rel_err_rho,\n            rel_err_p\n        ])\n\n    # Final print statement in the exact required format.\n    # We construct the string representation manually to ensure no spaces within sub-lists.\n    formatted_results = []\n    for res_list in results:\n        # Format each sublist to a string like \"[item1,item2,...]\"\n        formatted_sublist = f\"[{','.join(f'{item:.15g}' for item in res_list)}]\"\n        formatted_results.append(formatted_sublist)\n    \n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "3493584"}]}