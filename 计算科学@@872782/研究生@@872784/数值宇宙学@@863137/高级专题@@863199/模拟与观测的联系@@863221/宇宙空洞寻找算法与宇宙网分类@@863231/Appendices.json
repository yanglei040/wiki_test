{"hands_on_practices": [{"introduction": "本次实践将重点介绍基于赫斯矩阵的宇宙网分类方法中的核心数值技术。我们将利用快速傅里叶变换 ($FFT$) 的强大功能来高效地计算空间导数并应用高斯平滑。这项练习 [@problem_id:3502022] 对于理解我们如何通过分析密度场的局部曲率来识别纤维状结构和空洞等宇宙学结构至关重要。", "problem": "给定一个在均匀周期性网格上采样的、代表德劳内三角剖分场估计器（DTFE）重构的二维标量场，你需要实现傅里叶空间中的高斯平滑，并量化其对梯度和黑塞矩阵（Hessian）引起的衰减。请使用通过快速傅里叶变换（FFT）计算的离散傅里叶变换（DFT），并利用以下基本事实：(i) 实空间中的卷积对应于傅里叶空间中的乘法；(ii) 方差为 $\\,\\sigma^{2}\\,$ 的高斯函数的傅里叶变换是另一个高斯函数，在波数域中的乘子为 $\\,\\exp\\!\\left(-k^{2}\\sigma^{2}/2\\right)\\,$，其中 $\\,k^{2} = k_{x}^{2}+k_{y}^{2}\\,$；(iii) 微分在傅里叶空间中对应于乘以 $\\,\\mathrm{i}k_{x}\\,$ 和 $\\,\\mathrm{i}k_{y}\\,$，分别表示对 $\\,x\\,$ 和 $\\,y\\,$ 的偏导数。对于通过将原始场 $\\,\\phi\\,$ 与方差为 $\\,\\sigma^{2}\\,$ 的高斯核进行卷积得到的平滑场 $\\,\\phi_{\\sigma}\\,$，其傅里叶系数满足 $\\,\\widehat{\\phi_{\\sigma}}(\\boldsymbol{k}) = \\widehat{\\phi}(\\boldsymbol{k})\\exp\\!\\left(-k^{2}\\sigma^{2}/2\\right)\\,$。傅里叶空间中的梯度和黑塞矩阵可由这些性质推导得出。在宇宙网分类的背景下，黑塞矩阵的特征值被用来识别空洞和其他结构，高斯平滑通过阻尼高波数模式来改变它们的振幅。\n\n你的任务是编写一个完整的程序，该程序：\n- 在边长为 $\\,L = 1\\,$、在 $\\,N \\times N\\,$（其中 $\\,N = 64\\,$）网格点上采样的周期性方形域上，构建指定的测试场 $\\,\\phi(x,y)\\,$。\n- 在傅里叶空间中，通过乘以 $\\,\\exp\\!\\left(-k^{2}\\sigma^{2}/2\\right)\\,$ 来实现方差为 $\\,\\sigma^{2}\\,$ 的高斯平滑。\n- 通过傅里叶空间微分计算梯度 $\\,\\nabla \\phi\\,$ 和黑塞矩阵 $\\,\\nabla \\nabla \\phi\\,$。\n- 对于单模场，估计梯度大小的均方根（RMS）和最小黑塞特征值的RMS的衰减因子，并将它们与该模式（波数大小为 $\\,k_{0}\\,$）的理论因子 $\\,\\exp\\!\\left(-k_{0}^{2}\\sigma^{2}/2\\right)\\,$ 进行比较。\n- 对于双模叠加场，估计梯度大小的RMS和黑塞矩阵的弗罗贝尼乌斯范数（Frobenius norm）RMS的衰减因子，并将每个因子与纯粹由傅里叶空间能量加权计算出的预测比率进行比较：\n$$\nR_{\\mathrm{grad,pred}}(\\sigma) \\equiv \\sqrt{\\frac{\\sum_{\\boldsymbol{k}} k^{2}\\,\\left|\\widehat{\\phi}(\\boldsymbol{k})\\right|^{2}\\, \\exp\\!\\left(-k^{2}\\sigma^{2}\\right)}{\\sum_{\\boldsymbol{k}} k^{2}\\,\\left|\\widehat{\\phi}(\\boldsymbol{k})\\right|^{2}}}, \\quad\nR_{\\mathrm{H,pred}}(\\sigma) \\equiv \\sqrt{\\frac{\\sum_{\\boldsymbol{k}} k^{4}\\,\\left|\\widehat{\\phi}(\\boldsymbol{k})\\right|^{2}\\, \\exp\\!\\left(-k^{2}\\sigma^{2}\\right)}{\\sum_{\\boldsymbol{k}} k^{4}\\,\\left|\\widehat{\\phi}(\\boldsymbol{k})\\right|^{2}}}.\n$$\n这里 $\\,k^{2} = k_{x}^{2}+k_{y}^{2}\\,$，求和遍及网格上所有的离散傅里叶模式。使用弗罗贝尼乌斯范数 $\\,\\|\\nabla \\nabla \\phi\\|_{F} = \\sqrt{\\phi_{xx}^{2} + 2\\phi_{xy}^{2} + \\phi_{yy}^{2}}\\,$ 可以确保多模场的线性谱加权。\n\n定义和假设：\n- 德劳内三角剖分场估计器（Delaunay Tessellation Field Estimator, DTFE）：一种从离散样本重构连续密度类场的方法。在本任务中，你将操作一个已网格化的、代表DTFE输出的场。\n- 快速傅里叶变换（Fast Fourier Transform, FFT）：一种高效计算离散傅里叶变换（DFT）的算法。\n- 计算域为 $[0,1)\\times[0,1)$，具有周期性边界条件。\n- 所有量均为无量纲；不需要物理单位。\n- 角度（若通过三角函数隐式存在）以弧度为单位。\n\n实现以下测试套件。对于每种情况，在网格上构建指定的场 $\\,\\phi(x,y)\\,$ 并执行上述操作。\n\n- 测试 $\\,1\\,$（单模，基准衰减）：\n  - 场：$\\,\\phi(x,y) = A\\cos(2\\pi n_{x} x)\\,$，其中 $\\,A = 1\\,$ 和 $\\,n_{x} = 4\\,$。\n  - 平滑方差：$\\,\\sigma^{2}\\,$，其中 $\\,\\sigma = 0.05\\,$。\n  - 梯度大小RMS和最小黑塞特征值RMS的预测衰减因子均为：$\\,\\exp\\!\\left(-k_{0}^{2}\\sigma^{2}/2\\right)\\,$，其中 $\\,k_{0} = 2\\pi n_{x}\\,$。\n  - 输出两个浮点数：测量的梯度RMS比率与预测因子之间的相对误差，以及测量的最小特征值RMS比率与预测因子之间的相对误差。\n\n- 测试 $\\,2\\,$（恒等平滑边界）：\n  - 场与测试 $\\,1\\,$ 相同。\n  - 平滑方差：$\\,\\sigma^{2}\\,$，其中 $\\,\\sigma = 0.0\\,$。\n  - 预测衰减因子：$\\,1\\,$。\n  - 输出两个浮点数，与测试 $\\,1\\,$ 相同。\n\n- 测试 $\\,3\\,$（更高频率，更强衰减）：\n  - 场：$\\,\\phi(x,y) = A\\cos(2\\pi n_{x} x)\\,$，其中 $\\,A = 1\\,$ 和 $\\,n_{x} = 8\\,$。\n  - 平滑方差：$\\,\\sigma^{2}\\,$，其中 $\\,\\sigma = 0.12\\,$。\n  - 预测衰减因子：$\\,\\exp\\!\\left(-k_{0}^{2}\\sigma^{2}/2\\right)\\,$，其中 $\\,k_{0} = 2\\pi n_{x}\\,$。\n  - 输出两个浮点数，与测试 $\\,1\\,$ 相同。\n\n- 测试 $\\,4\\,$（双模叠加，谱能量预测）：\n  - 场：$\\,\\phi(x,y) = A_{1}\\cos(2\\pi n_{1} x) + A_{2}\\cos(2\\pi n_{2} y)\\,$，其中 $\\,A_{1} = 1\\,$, $\\,n_{1} = 3\\,$, $\\,A_{2} = 0.8\\,$, $\\,n_{2} = 5\\,$。\n  - 平滑方差：$\\,\\sigma^{2}\\,$，其中 $\\,\\sigma = 0.07\\,$。\n  - 预测的梯度RMS比率 $\\,R_{\\mathrm{grad,pred}}(\\sigma)\\,$ 和预测的黑塞矩阵弗罗贝尼乌斯RMS比率 $\\,R_{\\mathrm{H,pred}}(\\sigma)\\,$，使用未平滑的 $\\,\\widehat{\\phi}\\,$ 根据上述傅里叶空间加权和计算。\n  - 输出两个浮点数：测量的梯度RMS比率与 $\\,R_{\\mathrm{grad,pred}}(\\sigma)\\,$ 之间的相对误差，以及测量的黑塞矩阵弗罗贝尼乌斯RMS比率与 $\\,R_{\\mathrm{H,pred}}(\\sigma)\\,$ 之间的相对误差。\n\n对于每个测试，将测量比率定义为：\n- 梯度RMS比率：$\\,\\|\\nabla \\phi_{\\sigma}\\|\\,$ 的RMS除以 $\\,\\|\\nabla \\phi\\|\\,$ 的RMS，其中 $\\,\\|\\nabla \\phi\\| = \\sqrt{\\phi_{x}^{2} + \\phi_{y}^{2}}\\,$。\n- 单模测试的最小黑塞特征值RMS比率：$\\,\\nabla \\nabla \\phi_{\\sigma}\\,$ 的逐点最小特征值的RMS除以 $\\,\\nabla \\nabla \\phi\\,$ 的逐点最小特征值的RMS。\n- 双模测试的黑塞矩阵弗罗贝尼乌斯RMS比率：弗罗贝尼乌斯范数 $\\,\\|\\nabla \\nabla \\phi_{\\sigma}\\|_{F}\\,$ 的RMS除以 $\\,\\|\\nabla \\nabla \\phi\\|_{F}\\,$ 的RMS。\n\n所有基于FFT的求导和平滑都必须在周期性域上一致地实现。所有测试均使用 $\\,N = 64\\,$ 和 $\\,L = 1\\,$。最终程序必须按顺序计算以下八个浮点数：\n$[\\,$测试 $\\,1$ 梯度相对误差，测试 $\\,1$ 最小特征值相对误差，测试 $\\,2$ 梯度相对误差，测试 $\\,2$ 最小特征值相对误差，测试 $\\,3$ 梯度相对误差，测试 $\\,3$ 最小特征值相对误差，测试 $\\,4$ 梯度相对误差，测试 $\\,4$ 黑塞-弗罗贝尼乌斯相对误差$\\,]$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[\\mathrm{result1},\\mathrm{result2},\\mathrm{result3}]$）。每个结果都必须是浮点数。不需要外部输入，所有计算都是无量纲的，无需单位转换。若有角度，则根据构造默认为弧度。[@problem_id:124]", "solution": "该问题被评估为有效。它在科学上基于傅里叶分析原理及其在数值场论中的应用，问题提法清晰，提供了所有必要的参数和定义，并以客观、正式的语言陈述。它提出了一个非凡但可行的计算任务，用于测试对这些原理的理解和实现。\n\n解决方案通过系统地实现指定的数值方法来推进。首先，我们建立计算网格和相应的傅里叶空间坐标（波数）。然后，我们定义一组函数，使用傅里叶空间微分来计算场的梯度和黑塞矩阵。这些函数将构成我们分析的核心。我们还将实现高斯平滑操作，作为傅里叶空间中的一个乘法运算。最后，我们将处理每个测试案例，方法是构建指定的场，应用平滑和微分算子，计算所需的均方根（RMS）度量，并将结果与其理论预测进行比较。\n\n**1. 网格和波数表示**\n\n问题定义在一个二维周期性域 $[0, L) \\times [0, L)$ 上，边长 $L = 1$，在一个 $N \\times N$ 的均匀网格上采样，其中 $N=64$。网格坐标 $(x_j, y_l)$ 由下式给出：\n$$ x_j = j \\frac{L}{N}, \\quad y_l = l \\frac{L}{N} \\quad \\text{for } j, l \\in \\{0, 1, \\dots, N-1\\} $$\n离散傅里叶变换（DFT）将此实空间网格上的函数映射到离散波数网格上的系数。波数 $(k_x, k_y)$ 由网格大小 $N$ 和域长度 $L$ 决定。对于使用快速傅里叶变换（FFT）算法实现的DFT，相应的频率由标准库函数（例如 `numpy.fft.fftfreq`）提供。波数通过将这些频率乘以 $2\\pi$ 获得：\n$$ k_{x,m} = 2\\pi f_m, \\quad k_{y,n} = 2\\pi f_n $$\n其中 $f_m$ 和 $f_n$ 是采样间距为 $d = L/N$ 的 $N$ 点变换的离散频率。我们为 $k_x$、$k_y$ 以及波数大小的平方 $k^2 = k_x^2 + k_y^2$ 构建二维数组，这些数组将被重复使用。\n\n**2. 傅里叶空间算子**\n\n这个问题的基础在于傅里叶变换的性质。令 $\\widehat{\\phi}(\\boldsymbol{k})$ 表示标量场 $\\phi(\\boldsymbol{x})$ 的DFT，其中 $\\boldsymbol{k} = (k_x, k_y)$。\n\n**a. 高斯平滑：**\n场 $\\phi$ 与方差为 $\\sigma^2$ 的高斯核的卷积，等效于将其傅里叶变换 $\\widehat{\\phi}(\\boldsymbol{k})$ 乘以高斯函数的傅里叶变换。这作为滤波器给出：\n$$ S(\\boldsymbol{k}, \\sigma) = \\exp\\left(-\\frac{k^2 \\sigma^2}{2}\\right) $$\n因此，平滑场 $\\phi_\\sigma$ 的傅里叶变换为：\n$$ \\widehat{\\phi_\\sigma}(\\boldsymbol{k}) = \\widehat{\\phi}(\\boldsymbol{k}) S(\\boldsymbol{k}, \\sigma) $$\n然后通过应用逆DFT恢复平滑场 $\\phi_\\sigma(\\boldsymbol{x})$。\n\n**b. 微分：**\n傅里叶变换的微分性质指出，偏导数的变换等效于将原始变换乘以相应的虚波数。\n$$ \\mathcal{F}\\left[\\frac{\\partial \\phi}{\\partial x}\\right] = \\mathrm{i}k_x \\widehat{\\phi}(\\boldsymbol{k}), \\quad \\mathcal{F}\\left[\\frac{\\partial \\phi}{\\partial y}\\right] = \\mathrm{i}k_y \\widehat{\\phi}(\\boldsymbol{k}) $$\n二阶导数通过应用此规则两次得到：\n$$ \\mathcal{F}\\left[\\frac{\\partial^2 \\phi}{\\partial x^2}\\right] = (\\mathrm{i}k_x)^2 \\widehat{\\phi}(\\boldsymbol{k}) = -k_x^2 \\widehat{\\phi}(\\boldsymbol{k}) $$\n$$ \\mathcal{F}\\left[\\frac{\\partial^2 \\phi}{\\partial y^2}\\right] = (\\mathrm{i}k_y)^2 \\widehat{\\phi}(\\boldsymbol{k}) = -k_y^2 \\widehat{\\phi}(\\boldsymbol{k}) $$\n$$ \\mathcal{F}\\left[\\frac{\\partial^2 \\phi}{\\partial x \\partial y}\\right] = (\\mathrm{i}k_x)(\\mathrm{i}k_y) \\widehat{\\phi}(\\boldsymbol{k}) = -k_x k_y \\widehat{\\phi}(\\boldsymbol{k}) $$\n为了计算梯度向量 $\\nabla\\phi = (\\phi_x, \\phi_y)$ 或黑塞张量 $\\nabla\\nabla\\phi$，我们首先计算 $\\phi$ 的DFT，乘以适当的波数因子（例如，$\\mathrm{i}k_x$, $-k_x^2$），然后应用逆DFT返回到实空间。由于浮点不精确性，得到的场可能含有可忽略的虚部，必须将其舍弃。\n\n**3. 可观测量计算**\n\n问题要求对原始场 $\\phi$ 和平滑场 $\\phi_\\sigma$ 计算若干量。\n\n**a. RMS 值：** 在 $N \\times N$ 网格上，量 $Q$ 的均方根计算如下：\n$$ \\text{RMS}(Q) = \\sqrt{\\frac{1}{N^2} \\sum_{j=0}^{N-1} \\sum_{l=0}^{N-1} Q(x_j, y_l)^2} $$\n\n**b. 梯度大小：** 梯度的大小为 $\\|\\nabla\\phi\\| = \\sqrt{\\phi_x^2 + \\phi_y^2}$。我们计算其在整个网格上的RMS值。\n\n**c. 黑塞特征值（单模测试）：** 在每个网格点，黑塞矩阵是一个 $2 \\times 2$ 的对称矩阵：\n$$ H(\\boldsymbol{x}) = \\begin{pmatrix} \\phi_{xx}(\\boldsymbol{x})  \\phi_{xy}(\\boldsymbol{x}) \\\\ \\phi_{xy}(\\boldsymbol{x})  \\phi_{yy}(\\boldsymbol{x}) \\end{pmatrix} $$\n其特征值由公式 $\\lambda_{\\pm} = \\frac{1}{2}\\left( \\text{Tr}(H) \\pm \\sqrt{(\\text{Tr}(H))^2 - 4\\det(H)} \\right)$ 给出，简化为：\n$$ \\lambda_{\\pm} = \\frac{1}{2}\\left( (\\phi_{xx} + \\phi_{yy}) \\pm \\sqrt{(\\phi_{xx}-\\phi_{yy})^2 + 4\\phi_{xy}^2} \\right) $$\n我们关心的是最小特征值 $\\lambda_{-}$。我们计算最小特征值场，然后计算其RMS值。\n\n**d. 黑塞弗罗贝尼乌斯范数（双模测试）：** 黑塞矩阵的弗罗贝尼乌斯范数由下式给出：\n$$ \\|\\nabla\\nabla\\phi\\|_F = \\sqrt{\\phi_{xx}^2 + \\phi_{yy}^2 + 2\\phi_{xy}^2} $$\n我们计算弗罗贝尼乌斯范数场，然后计算其RMS值。\n\n**4. 理论预测和误差计算**\n\n测量的衰减，由RMS值的比率（例如，$\\text{RMS}(\\|\\nabla\\phi_\\sigma\\|)/\\text{RMS}(\\|\\nabla\\phi\\|)$）量化，将与理论预测进行比较。\n\n**a. 单模场：** 对于由单一波数大小 $k_0$ 主导的场，例如 $\\phi(x,y) = A\\cos(2\\pi n_x x)$（其 $k_0 = 2\\pi n_x$），每次微分操作都只是将场的振幅乘以一个与 $k_0$ 相关的因子。平滑引入了另一个乘法因子 $\\exp(-k_0^2\\sigma^2/2)$。因此，梯度和所有黑塞分量的振幅都以相同的因子衰减。由于RMS与振幅成正比，这些量（梯度大小、黑塞特征值）中任何一个的RMS值比率预测为：\n$$ R_{\\text{pred}}(\\sigma) = \\exp\\left(-\\frac{k_0^2 \\sigma^2}{2}\\right) $$\n\n**b. 双模场：** 对于模式的叠加，上述简单预测不成立。问题提供了谱能量加权预测。RMS梯度大小的预测比率为：\n$$ R_{\\mathrm{grad,pred}}(\\sigma) = \\sqrt{\\frac{\\sum_{\\boldsymbol{k}} k^{2}\\,|\\widehat{\\phi}(\\boldsymbol{k})|^{2}\\, \\exp(-k^{2}\\sigma^{2})}{\\sum_{\\boldsymbol{k}} k^{2}\\,|\\widehat{\\phi}(\\boldsymbol{k})|^{2}}} $$\n该公式通过 $k^2$（来自梯度）和平滑因子对每个模式的功率 $|\\widehat{\\phi}(\\boldsymbol{k})|^2$ 的贡献进行加权。分母是未平滑场的总“梯度功率”。类似地，RMS黑塞弗罗贝尼乌斯范数的预测比率为：\n$$ R_{\\mathrm{H,pred}}(\\sigma) = \\sqrt{\\frac{\\sum_{\\boldsymbol{k}} k^{4}\\,|\\widehat{\\phi}(\\boldsymbol{k})|^{2}\\, \\exp(-k^{2}\\sigma^{2})}{\\sum_{\\boldsymbol{k}} k^{4}\\,|\\widehat{\\phi}(\\boldsymbol{k})|^{2}}} $$\n权重 $k^4$ 的出现是因为弗罗贝尼乌斯范数的平方是二阶导数平方的和，而每个二阶导数在傅里叶空间中贡献一个因子 $k^2$，导致功率的整体缩放因子为 $k^4$。\n\n每个测试的最终输出是测量比率与预测比率之间的相对误差：\n$$ \\text{Relative Error} = \\frac{|\\text{Measured Ratio} - \\text{Predicted Ratio}|}{|\\text{Predicted Ratio}|} $$\n\n将对所有四个测试案例实施此系统过程，以获得所需的八个输出值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Fourier-space smoothing and differentiation.\n    \"\"\"\n\n    def compute_derivatives(phi_hat, kx, ky):\n        \"\"\"Computes gradient and Hessian components in real space from a Fourier-space field.\"\"\"\n        # Gradient components\n        phi_x_hat = 1j * kx * phi_hat\n        phi_y_hat = 1j * ky * phi_hat\n        phi_x = np.fft.ifftn(phi_x_hat).real\n        phi_y = np.fft.ifftn(phi_y_hat).real\n\n        # Hessian components\n        phi_xx_hat = -kx**2 * phi_hat\n        phi_yy_hat = -ky**2 * phi_hat\n        phi_xy_hat = -kx * ky * phi_hat\n        phi_xx = np.fft.ifftn(phi_xx_hat).real\n        phi_yy = np.fft.ifftn(phi_yy_hat).real\n        phi_xy = np.fft.ifftn(phi_xy_hat).real\n        \n        return phi_x, phi_y, phi_xx, phi_yy, phi_xy\n\n    def get_rms(field):\n        \"\"\"Computes the root-mean-square of a 2D field.\"\"\"\n        return np.sqrt(np.mean(field**2))\n\n    def run_analysis(phi, sigma, kx, ky, k_sq, test_type, phi_hat=None):\n        \"\"\"\n        Performs the core analysis for a given field and smoothing parameter.\n        `test_type` can be 'single_mode' or 'two_mode'.\n        \"\"\"\n        N, _ = phi.shape\n        \n        # --- Unsmoothed Field Analysis ---\n        if phi_hat is None:\n            phi_hat = np.fft.fftn(phi)\n        \n        phi_x, phi_y, phi_xx, phi_yy, phi_xy = compute_derivatives(phi_hat, kx, ky)\n\n        # --- Smoothed Field Analysis ---\n        smoothing_kernel = np.exp(-k_sq * sigma**2 / 2.0)\n        phi_sigma_hat = phi_hat * smoothing_kernel\n        \n        phi_sigma_x, phi_sigma_y, phi_sigma_xx, phi_sigma_yy, phi_sigma_xy = \\\n            compute_derivatives(phi_sigma_hat, kx, ky)\n\n        # --- Compute Ratios ---\n        # Gradient RMS ratio\n        grad_mag = np.sqrt(phi_x**2 + phi_y**2)\n        grad_mag_sigma = np.sqrt(phi_sigma_x**2 + phi_sigma_y**2)\n        rms_grad_mag = get_rms(grad_mag)\n        measured_ratio_grad = get_rms(grad_mag_sigma) / rms_grad_mag if rms_grad_mag != 0 else 0\n\n        # Hessian ratio (depends on test type)\n        if test_type == 'single_mode':\n            # Minimum eigenvalue of Hessian\n            trace = phi_xx + phi_yy\n            discriminant = np.sqrt(np.maximum(0, (phi_xx - phi_yy)**2 + 4 * phi_xy**2))\n            min_eig = 0.5 * (trace - discriminant)\n\n            trace_sigma = phi_sigma_xx + phi_sigma_yy\n            discriminant_sigma = np.sqrt(np.maximum(0, (phi_sigma_xx - phi_sigma_yy)**2 + 4 * phi_sigma_xy**2))\n            min_eig_sigma = 0.5 * (trace_sigma - discriminant_sigma)\n\n            rms_min_eig = get_rms(min_eig)\n            measured_ratio_hess = get_rms(min_eig_sigma) / rms_min_eig if rms_min_eig != 0 else 0\n            \n        elif test_type == 'two_mode':\n            # Frobenius norm of Hessian\n            frob_norm = np.sqrt(phi_xx**2 + 2 * phi_xy**2 + phi_yy**2)\n            frob_norm_sigma = np.sqrt(phi_sigma_xx**2 + 2 * phi_sigma_xy**2 + phi_sigma_yy**2)\n            rms_frob_norm = get_rms(frob_norm)\n            measured_ratio_hess = get_rms(frob_norm_sigma) / rms_frob_norm if rms_frob_norm != 0 else 0\n\n        return measured_ratio_grad, measured_ratio_hess, phi_hat\n\n\n    # --- Simulation Parameters ---\n    N = 64\n    L = 1.0\n\n    # --- Grid and Wavenumber Setup ---\n    grid_coords = np.linspace(0, L, N, endpoint=False)\n    xx, yy = np.meshgrid(grid_coords, grid_coords, indexing='ij')\n\n    k_freq = np.fft.fftfreq(N, d=L / N)\n    kx_base = 2 * np.pi * k_freq\n    ky_base = 2 * np.pi * k_freq\n    kx, ky = np.meshgrid(kx_base, ky_base, indexing='ij')\n    k_sq = kx**2 + ky**2\n\n    # --- Test Suite ---\n    test_cases = [\n        # Test 1: single mode, baseline attenuation\n        {'type': 'single_mode', 'A': 1.0, 'nx': 4, 'sigma': 0.05},\n        # Test 2: identity smoothing\n        {'type': 'single_mode', 'A': 1.0, 'nx': 4, 'sigma': 0.0},\n        # Test 3: higher frequency\n        {'type': 'single_mode', 'A': 1.0, 'nx': 8, 'sigma': 0.12},\n        # Test 4: two-mode superposition\n        {'type': 'two_mode', 'A1': 1.0, 'n1': 3, 'A2': 0.8, 'n2': 5, 'sigma': 0.07}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Construct the field\n        if case['type'] == 'single_mode':\n            phi = case['A'] * np.cos(2 * np.pi * case['nx'] * xx)\n        else: # two_mode\n            phi = case['A1'] * np.cos(2 * np.pi * case['n1'] * xx) + \\\n                  case['A2'] * np.cos(2 * np.pi * case['n2'] * yy)\n        \n        # Run analysis\n        measured_grad_ratio, measured_hess_ratio, phi_hat = run_analysis(\n            phi, case['sigma'], kx, ky, k_sq, case['type']\n        )\n\n        # Compute predictions and relative errors\n        if case['type'] == 'single_mode':\n            sigma = case['sigma']\n            if sigma == 0.0:\n                pred_ratio_grad = 1.0\n                pred_ratio_hess = 1.0\n            else:\n                k0 = 2 * np.pi * case['nx']\n                pred_ratio = np.exp(-k0**2 * sigma**2 / 2.0)\n                pred_ratio_grad = pred_ratio\n                pred_ratio_hess = pred_ratio\n        else: # two_mode\n            sigma = case['sigma']\n            power_spectrum = np.abs(phi_hat)**2\n            \n            # Grad prediction\n            grad_numerator = np.sum(k_sq * power_spectrum * np.exp(-k_sq * sigma**2))\n            grad_denominator = np.sum(k_sq * power_spectrum)\n            pred_ratio_grad = np.sqrt(grad_numerator / grad_denominator) if grad_denominator != 0 else 0\n\n            # Hessian prediction\n            hess_numerator = np.sum(k_sq**2 * power_spectrum * np.exp(-k_sq * sigma**2))\n            hess_denominator = np.sum(k_sq**2 * power_spectrum)\n            pred_ratio_hess = np.sqrt(hess_numerator / hess_denominator) if hess_denominator != 0 else 0\n\n        # Relative errors\n        rel_err_grad = np.abs(measured_grad_ratio - pred_ratio_grad) / pred_ratio_grad if pred_ratio_grad != 0 else 0\n        rel_err_hess = np.abs(measured_hess_ratio - pred_ratio_hess) / pred_ratio_hess if pred_ratio_hess != 0 else 0\n        \n        results.extend([rel_err_grad, rel_err_hess])\n\n    # Final print statement\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3502022"}, {"introduction": "尽管上一个练习处理的是一个理想的、干净的理论场，但来自星系巡天或N体模拟的真实数据是离散的。这种离散性会在我们的密度估计中引入泊松“散粒噪声”。这个解析问题 [@problem_id:3502070] 将引导您完成噪声传播的推导过程，量化其在赫斯矩阵本征值中引起的不确定性，这是评估任何宇宙网分类方案可靠性的关键一步。", "problem": "在通过质量过密场的Hessian矩阵的特征值对宇宙网进行分类的背景下，考虑一个由平均数密度为$\\bar{n}$的均匀离散示踪物采样的无量纲过密场的单元计数估计。巡天体积在一个间距为$h$的均匀立方网格上被离散化，因此每个体元的体积为$h^{3}$。设$N_{\\boldsymbol{i}}$表示以网格索引$\\boldsymbol{i}$为中心的体元中的示踪物计数，其中$N_{\\boldsymbol{i}} \\sim \\mathrm{Poisson}(\\bar{n} h^{3})$，且在不同体元间是独立的。将体元$\\boldsymbol{i}$中的过密估计量定义为$\\delta_{\\boldsymbol{i}} \\equiv \\left(N_{\\boldsymbol{i}} - \\bar{n} h^{3}\\right)/\\left(\\bar{n} h^{3}\\right)$。\n\n在一个固定的网格位置$\\boldsymbol{i}_{0}$，$\\delta$的Hessian矩阵使用二阶中心有限差分进行估计：\n- 对于对角二阶导数，\n$$\n\\widehat{H}_{xx} \\equiv \\frac{\\delta_{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{x}}}-2\\,\\delta_{\\boldsymbol{i}_{0}}+\\delta_{\\boldsymbol{i}_{0}-\\hat{\\boldsymbol{x}}}}{h^{2}},\\quad\n\\widehat{H}_{yy} \\equiv \\frac{\\delta_{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{y}}}-2\\,\\delta_{\\boldsymbol{i}_{0}}+\\delta_{\\boldsymbol{i}_{0}-\\hat{\\boldsymbol{y}}}}{h^{2}},\\quad\n\\widehat{H}_{zz} \\equiv \\frac{\\delta_{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{z}}}-2\\,\\delta_{\\boldsymbol{i}_{0}}+\\delta_{\\boldsymbol{i}_{0}-\\hat{\\boldsymbol{z}}}}{h^{2}}.\n$$\n- 对于非对角混合二阶导数，\n$$\n\\widehat{H}_{xy} \\equiv \\frac{\\delta_{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}}-\\delta_{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{x}}-\\hat{\\boldsymbol{y}}}-\\delta_{\\boldsymbol{i}_{0}-\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}}+\\delta_{\\boldsymbol{i}_{0}-\\hat{\\boldsymbol{x}}-\\hat{\\boldsymbol{y}}}}{4 h^{2}},\n$$\n$\\widehat{H}_{xz}$和$\\widehat{H}_{yz}$的定义可通过坐标的循环置换类似地得到。此处，$\\hat{\\boldsymbol{x}},\\hat{\\boldsymbol{y}},\\hat{\\boldsymbol{z}}$表示沿相应坐标轴方向一个体元的单位索引位移。\n\n假设散粒噪声是不确定性的唯一来源，不同体元的过密估计量$\\delta_{\\boldsymbol{i}}$是统计独立的且均值为零，并且在$\\boldsymbol{i}_{0}$处的真实潜在Hessian矩阵是对角的，具有非简并特征值$\\lambda_{1}^{(0)},\\lambda_{2}^{(0)},\\lambda_{3}^{(0)}$，其标准正交特征向量与网格轴$\\{\\hat{\\boldsymbol{x}},\\hat{\\boldsymbol{y}},\\hat{\\boldsymbol{z}}\\}$重合。\n\n任务：\n- 从$N_{\\boldsymbol{i}}$的泊松统计和上述有限差分算子出发，推导在$\\boldsymbol{i}_{0}$处纯粹由散粒噪声引起的Hessian分量估计量$\\widehat{H}_{ab}$的协方差，并用$\\bar{n}$和$h$表示你的结果。\n- 使用针对具有非简并特征值的对称矩阵的一阶微扰理论，传播此协方差，以获得在所述对齐假设下由散粒噪声引起的最小特征值估计量$\\widehat{\\lambda}_{1}$的方差。\n\n以$\\bar{n}$和$h$表示的$\\mathrm{Var}(\\widehat{\\lambda}_{1})$的单个闭式解析表达式的形式提供你的最终答案。无需四舍五入。最终方框内的答案不应包含单位。", "solution": "问题陈述已经过验证，被认为是有效的。它在数值宇宙学的方法上有科学依据，是适定的、客观的且内部一致的。我们可以继续进行解答。\n\n解答过程按问题陈述的要求分为两个主要阶段。首先，我们推导由泊松散粒噪声引起的Hessian估计量各分量的协方差矩阵。其次，我们使用一阶微扰理论传播此不确定性，以确定最小特征值估计量的方差。\n\n**第1部分：Hessian分量估计量的协方差**\n\n噪声的根本来源是每个体元中示踪物计数$N_{\\boldsymbol{i}}$的泊松性质。体元$\\boldsymbol{i}$中的过密估计量由$\\delta_{\\boldsymbol{i}} \\equiv \\left(N_{\\boldsymbol{i}} - \\bar{n} h^{3}\\right)/\\left(\\bar{n} h^{3}\\right)$给出。令$\\mu \\equiv \\bar{n} h^{3}$为每个体元的平均示踪物数量。我们有$N_{\\boldsymbol{i}} \\sim \\mathrm{Poisson}(\\mu)$。\n\n$N_{\\boldsymbol{i}}$的期望值和方差分别为$\\mathrm{E}[N_{\\boldsymbol{i}}] = \\mu$和$\\mathrm{Var}(N_{\\boldsymbol{i}}) = \\mu$。\n过密估计量的期望值为$\\mathrm{E}[\\delta_{\\boldsymbol{i}}] = \\mathrm{E}[N_{\\boldsymbol{i}}/\\mu - 1] = \\mathrm{E}[N_{\\boldsymbol{i}}]/\\mu - 1 = \\mu/\\mu - 1 = 0$。这证实了$\\delta_{\\boldsymbol{i}}$具有零均值的陈述。\n过密估计量的方差为$\\mathrm{Var}(\\delta_{\\boldsymbol{i}}) = \\mathrm{Var}(N_{\\boldsymbol{i}}/\\mu - 1) = \\mathrm{Var}(N_{\\boldsymbol{i}}/\\mu) = \\frac{1}{\\mu^{2}}\\mathrm{Var}(N_{\\boldsymbol{i}}) = \\frac{\\mu}{\\mu^{2}} = \\frac{1}{\\mu}$。\n代入$\\mu = \\bar{n} h^{3}$，我们得到单个体元中过密度的方差：\n$$\n\\sigma_{\\delta}^{2} \\equiv \\mathrm{Var}(\\delta_{\\boldsymbol{i}}) = \\frac{1}{\\bar{n} h^{3}}\n$$\n问题陈述指出，对于不同的体元$\\boldsymbol{i} \\neq \\boldsymbol{j}$，体元计数$N_{\\boldsymbol{i}}$以及因此的过密估计量$\\delta_{\\boldsymbol{i}}$是统计独立的。因此，它们的协方差为：\n$$\n\\mathrm{Cov}(\\delta_{\\boldsymbol{i}}, \\delta_{\\boldsymbol{j}}) = \\sigma_{\\delta}^{2} \\delta_{\\boldsymbol{i}\\boldsymbol{j}}^{\\text{Kronecker}}\n$$\n其中$\\delta_{\\boldsymbol{i}\\boldsymbol{j}}^{\\text{Kronecker}}$是克罗内克δ函数，如果$\\boldsymbol{i}=\\boldsymbol{j}$则等于$1$，否则等于$0$。\n\nHessian估计量$\\widehat{H}_{ab}$是$\\delta_{\\boldsymbol{i}}$值的线性组合。对于任意两个这样的估计量，$\\widehat{H}_{ab} = \\sum_{\\boldsymbol{i}} c_{\\boldsymbol{i}}^{(ab)} \\delta_{\\boldsymbol{i}}$和$\\widehat{H}_{cd} = \\sum_{\\boldsymbol{j}} c_{\\boldsymbol{j}}^{(cd)} \\delta_{\\boldsymbol{j}}$，它们的协方差由下式给出：\n$$\n\\mathrm{Cov}(\\widehat{H}_{ab}, \\widehat{H}_{cd}) = \\mathrm{Cov}\\left(\\sum_{\\boldsymbol{i}} c_{\\boldsymbol{i}}^{(ab)} \\delta_{\\boldsymbol{i}}, \\sum_{\\boldsymbol{j}} c_{\\boldsymbol{j}}^{(cd)} \\delta_{\\boldsymbol{j}}\\right) = \\sum_{\\boldsymbol{i},\\boldsymbol{j}} c_{\\boldsymbol{i}}^{(ab)} c_{\\boldsymbol{j}}^{(cd)} \\mathrm{Cov}(\\delta_{\\boldsymbol{i}}, \\delta_{\\boldsymbol{j}}) = \\sigma_{\\delta}^{2} \\sum_{\\boldsymbol{k}} c_{\\boldsymbol{k}}^{(ab)} c_{\\boldsymbol{k}}^{(cd)}\n$$\n其中最后的求和是对所有系数乘积不为零的体元$\\boldsymbol{k}$进行的。\n\n让我们应用这个公式来计算所需的协方差。\n\n对角分量的方差，例如$\\mathrm{Var}(\\widehat{H}_{xx})$：\n估计量为$\\widehat{H}_{xx} = \\frac{1}{h^{2}}(\\delta_{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{x}}} - 2\\delta_{\\boldsymbol{i}_{0}} + \\delta_{\\boldsymbol{i}_{0}-\\hat{\\boldsymbol{x}}})$。所涉及的体元是不同的。\n$$\n\\mathrm{Var}(\\widehat{H}_{xx}) = \\sigma_{\\delta}^{2} \\left[ \\left(\\frac{1}{h^{2}}\\right)^{2} + \\left(\\frac{-2}{h^{2}}\\right)^{2} + \\left(\\frac{1}{h^{2}}\\right)^{2} \\right] = \\sigma_{\\delta}^{2} \\frac{1^{2} + (-2)^{2} + 1^{2}}{h^{4}} = \\frac{6\\sigma_{\\delta}^{2}}{h^{4}} = \\frac{6}{\\bar{n} h^{7}}\n$$\n根据对称性，$\\mathrm{Var}(\\widehat{H}_{yy}) = \\mathrm{Var}(\\widehat{H}_{zz}) = \\frac{6}{\\bar{n} h^{7}}$。\n\n非对角分量的方差，例如$\\mathrm{Var}(\\widehat{H}_{xy})$：\n估计量为$\\widehat{H}_{xy} = \\frac{1}{4h^{2}}(\\delta_{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}} - \\delta_{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{x}}-\\hat{\\boldsymbol{y}}} - \\delta_{\\boldsymbol{i}_{0}-\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}} + \\delta_{\\boldsymbol{i}_{0}-\\hat{\\boldsymbol{x}}-\\hat{\\boldsymbol{y}}})$。所涉及的体元是不同的。\n$$\n\\mathrm{Var}(\\widehat{H}_{xy}) = \\sigma_{\\delta}^{2} \\left(\\frac{1}{4h^{2}}\\right)^{2} \\left[ (1)^{2} + (-1)^{2} + (-1)^{2} + (1)^{2} \\right] = \\sigma_{\\delta}^{2} \\frac{4}{16h^{4}} = \\frac{\\sigma_{\\delta}^{2}}{4h^{4}} = \\frac{1}{4\\bar{n} h^{7}}\n$$\n根据对称性，$\\mathrm{Var}(\\widehat{H}_{xz}) = \\mathrm{Var}(\\widehat{H}_{yz}) = \\frac{1}{4\\bar{n} h^{7}}$。\n\n两个不同对角分量之间的协方差，例如$\\mathrm{Cov}(\\widehat{H}_{xx}, \\widehat{H}_{yy})$：\n$\\widehat{H}_{xx}$的模板涉及体元$\\{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{x}}, \\boldsymbol{i}_{0}, \\boldsymbol{i}_{0}-\\hat{\\boldsymbol{x}}\\}$。$\\widehat{H}_{yy}$的模板涉及体元$\\{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{y}}, \\boldsymbol{i}_{0}, \\boldsymbol{i}_{0}-\\hat{\\boldsymbol{y}}\\}$。唯一的公共体元是中心体元$\\boldsymbol{i}_{0}$。在两个估计量中，$\\delta_{\\boldsymbol{i}_{0}}$的系数均为$-2/h^{2}$。\n$$\n\\mathrm{Cov}(\\widehat{H}_{xx}, \\widehat{H}_{yy}) = \\sigma_{\\delta}^{2} \\left( \\frac{-2}{h^{2}} \\right) \\left( \\frac{-2}{h^{2}} \\right) = \\frac{4\\sigma_{\\delta}^{2}}{h^{4}} = \\frac{4}{\\bar{n} h^{7}}\n$$\n根据对称性，$\\mathrm{Cov}(\\widehat{H}_{xx}, \\widehat{H}_{zz}) = \\mathrm{Cov}(\\widehat{H}_{yy}, \\widehat{H}_{zz}) = \\frac{4}{\\bar{n} h^{7}}$。\n\n对角分量和非对角分量之间的协方差，例如$\\mathrm{Cov}(\\widehat{H}_{xx}, \\widehat{H}_{xy})$：\n$\\widehat{H}_{xx}$的模板是$\\{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{x}}, \\boldsymbol{i}_{0}, \\boldsymbol{i}_{0}-\\hat{\\boldsymbol{x}}\\}$。$\\widehat{H}_{xy}$的模板是$\\{\\boldsymbol{i}_{0}+\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}, \\boldsymbol{i}_{0}+\\hat{\\boldsymbol{x}}-\\hat{\\boldsymbol{y}}, \\boldsymbol{i}_{0}-\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}, \\boldsymbol{i}_{0}-\\hat{\\boldsymbol{x}}-\\hat{\\boldsymbol{y}}\\}$。这两组体元是不相交的。因此，它们的协方差为零。\n$$\n\\mathrm{Cov}(\\widehat{H}_{xx}, \\widehat{H}_{xy}) = 0\n$$\n根据对称性，所有对角分量和非对角分量之间的协方差都为零。\n\n两个不同非对角分量之间的协方差，例如$\\mathrm{Cov}(\\widehat{H}_{xy}, \\widehat{H}_{xz})$：\n$\\widehat{H}_{xy}$的模板涉及在$\\hat{\\boldsymbol{x}}$和$\\hat{\\boldsymbol{y}}$方向的位移。$\\widehat{H}_{xz}$的模板涉及在$\\hat{\\boldsymbol{x}}$和$\\hat{\\boldsymbol{z}}$方向的位移。这两组体元是不相交的。因此，它们的协方差为零。\n$$\n\\mathrm{Cov}(\\widehat{H}_{xy}, \\widehat{H}_{xz}) = 0\n$$\n根据对称性，所有不同非对角分量之间的协方差都为零。\n\n**第2部分：最小特征值估计量的方差**\n\n估计的Hessian矩阵$\\widehat{H}$可以写成真实Hessian矩阵$H^{(0)}$和噪声微扰矩阵$\\Delta H$之和，即$\\widehat{H} = H^{(0)} + \\Delta H$。估计量的期望是真实值，$\\mathrm{E}[\\widehat{H}] = H^{(0)}$，因此$\\mathrm{E}[\\Delta H] = 0$。$\\Delta H$各分量的协方差矩阵就是我们在第1部分中推导出的结果。\n\n我们使用一阶线性误差传播来求特征值的方差。如果一个关注量$\\lambda$是随机变量$\\{X_k\\}$的函数，其方差近似为$\\mathrm{Var}(\\lambda) \\approx \\sum_{k,l} \\frac{\\partial \\lambda}{\\partial X_k} \\frac{\\partial \\lambda}{\\partial X_l} \\mathrm{Cov}(X_k, X_l)$。这里，$\\lambda$是$\\widehat{H}$的一个特征值，而变量$X_k$是分量$\\widehat{H}_{ab}$。\n\n对称矩阵$H$的特征值$\\lambda_k$对其分量$H_{ab}$的导数由$\\frac{\\partial \\lambda_k}{\\partial H_{ab}} = (2-\\delta_{ab}^{\\text{Kronecker}}) v_{ka} v_{kb}$给出，其中$\\boldsymbol{v}_k$是对应于$\\lambda_k$的归一化特征向量，其分量为$v_{ka}, v_{kb}$。\n\n问题陈述指出，真实Hessian矩阵$H^{(0)}$在网格基底下是对角的，其特征向量与坐标轴$\\{\\hat{\\boldsymbol{x}},\\hat{\\boldsymbol{y}},\\hat{\\boldsymbol{z}}\\}$重合。我们对坐标轴进行排序，使得对应于最小特征值$\\lambda_{1}^{(0)}$的特征向量为$\\boldsymbol{v}_{1}^{(0)} = \\hat{\\boldsymbol{x}} = (1, 0, 0)^T$。其分量为$v_{1x}=1$, $v_{1y}=0$, $v_{1z}=0$。\n\n我们在真实（未受扰动）值处计算偏导数：\n$$\n\\frac{\\partial \\lambda_1}{\\partial \\widehat{H}_{xx}} = (2-1)v_{1x}v_{1x} = 1 \\cdot 1 \\cdot 1 = 1\n$$\n$$\n\\frac{\\partial \\lambda_1}{\\partial \\widehat{H}_{yy}} = (2-1)v_{1y}v_{1y} = 1 \\cdot 0 \\cdot 0 = 0\n$$\n$$\n\\frac{\\partial \\lambda_1}{\\partial \\widehat{H}_{zz}} = (2-1)v_{1z}v_{1z} = 1 \\cdot 0 \\cdot 0 = 0\n$$\n$$\n\\frac{\\partial \\lambda_1}{\\partial \\widehat{H}_{xy}} = (2-0)v_{1x}v_{1y} = 2 \\cdot 1 \\cdot 0 = 0\n$$\n类似地，所有其他关于非对角分量的导数都为零。\n\n唯一的非零导数是$\\frac{\\partial \\lambda_1}{\\partial \\widehat{H}_{xx}} = 1$。于是方差传播公式大大简化为：\n$$\n\\mathrm{Var}(\\widehat{\\lambda}_1) \\approx \\sum_{ab,cd} \\left(\\frac{\\partial \\lambda_1}{\\partial \\widehat{H}_{ab}}\\right) \\left(\\frac{\\partial \\lambda_1}{\\partial \\widehat{H}_{cd}}\\right) \\mathrm{Cov}(\\widehat{H}_{ab}, \\widehat{H}_{cd})\n= \\left(\\frac{\\partial \\lambda_1}{\\partial \\widehat{H}_{xx}}\\right)^{2} \\mathrm{Var}(\\widehat{H}_{xx})\n$$\n$$\n\\mathrm{Var}(\\widehat{\\lambda}_1) \\approx (1)^{2} \\cdot \\mathrm{Var}(\\widehat{H}_{xx}) = \\mathrm{Var}(\\widehat{H}_{xx})\n$$\n这个结果与一阶矩阵微扰理论是一致的。特征值的一阶变化为$\\Delta\\lambda_1 \\approx \\boldsymbol{v}_{1}^{(0)T} (\\Delta H) \\boldsymbol{v}_{1}^{(0)} = \\Delta H_{xx} = \\widehat{H}_{xx} - \\lambda_1^{(0)}$。这个变化的方差就是$\\mathrm{Var}(\\widehat{H}_{xx})$。\n\n代入第1部分的结果：\n$$\n\\mathrm{Var}(\\widehat{\\lambda}_1) = \\frac{6}{\\bar{n} h^{7}}\n$$", "answer": "$$\n\\boxed{\\frac{6}{\\bar{n} h^{7}}}\n$$", "id": "3502070"}, {"introduction": "“空洞”的定义并非唯一，它取决于所选的方法论。本练习 [@problem_id:3502019] 旨在探索两种有着根本区别但功能强大的方法：追踪初始粒子构型的拉格朗日空间ORIGAMI方法，以及分割最终密度场的欧拉空间分水岭算法。通过实现和比较这两种方法，您将对不同物理假设及其产生的分类结果有更深刻的理解。", "problem": "给定一个表示单时间N体快照的合成三维粒子分布，该分布位于边长为 $L$ 的周期性立方体盒子中。初始粒子构型是一个均匀的拉格朗日格点，包含 $N^3$ 个粒子，其位置为 $\\mathbf{q} \\in [0,L)^3$。欧拉位置 $\\mathbf{x}$ 是通过一阶拉格朗日微扰（泽尔多维奇近似）得到的，即 $\\mathbf{x}(\\mathbf{q}) = \\mathbf{q} + \\mathbf{s}(\\mathbf{q})$，其中位移场 $\\mathbf{s}(\\mathbf{q}) = -D \\nabla \\phi(\\mathbf{q})$ 源自一个由尺度为 $R_s$ 的高斯核平滑的随机高斯势 $\\phi$。假设在所有时刻都采用周期性边界条件。\n\n您的任务是，从第一性原理出发，实现并比较两种寻找空洞的度量方法：\n\n1. 使用Order-ReversIng Galaxy Morphology Identification (ORIGAMI)进行拉格朗日空洞分类，定义如下。对于每个主轴 $\\alpha \\in \\{x,y,z\\}$，考虑平行于 $\\alpha$ 且正交坐标固定的粒子一维线。如果一条线上的粒子按其初始拉格朗日坐标 $\\alpha$ 排序后，其欧拉坐标 $\\alpha$ 的序列不是严格递增的，则称该粒子在该轴上经历了壳层穿越。为解决此问题，通过在每条线上寻找欧拉坐标的离散差为负的相邻粒子对来检测 $\\alpha$ 轴上的壳层穿越。如果一个粒子在所有三个轴上检测到的壳层穿越次数均为零，则将其分类为拉格朗日空洞粒子。拉格朗日空洞分数是指被分类为空洞粒子的比例（无量纲小数，范围在 $[0,1]$）。\n\n2. 在通过Cloud-in-Cell (CIC)质量分配得到的密度场上计算欧拉分水岭空洞体积。通过使用CIC权重沉积粒子质量，在 $N^3$ 的网格上构建欧拉密度 $\\rho(\\mathbf{x})$。定义密度对比度 $\\delta(\\mathbf{x}) = \\rho(\\mathbf{x})/\\bar{\\rho} - 1$，其中 $\\bar{\\rho}$ 是平均密度。使用六邻域（面相邻）比较，在周期性边界条件下识别 $\\rho$ 的局部极小值。通过最陡下降法为每个网格单元分配到一个盆地来进行离散分水岭分割：从每个单元迭代地移动到其六个面邻居中密度最低的那个，前提是该邻居的密度严格更低；如果没有严格更低的邻居，则该单元是汇点（一个局部极小值或平坦区域的极小值）。用其汇点单元的索引来标记盆地。将欧拉分水岭空洞体积分数定义为，其盆地汇点密度对比度 $\\delta_{\\mathrm{sink}}$ 小于指定阈值 $\\delta_v$（无量纲小数）的网格单元所占的比例，即由足够欠密度的极小值所构成的盆地。\n\n您必须使用的基本原理和假设是：\n\n- 一阶拉格朗日微扰（泽尔多维奇近似）：$\\mathbf{x}(\\mathbf{q}) = \\mathbf{q} - D \\nabla \\phi(\\mathbf{q})$，其中 $D$ 为某个标量增长幅度。\n- 立方体域上的周期性边界条件。\n- 质量守恒和Cloud-in-Cell (CIC)沉积：每个等质量的粒子根据其在网格单元内的分数偏移，以三线性权重对其周围的八个网格顶点作出贡献。\n- 密度对比度的定义：$\\delta(\\mathbf{x}) = \\rho(\\mathbf{x})/\\bar{\\rho} - 1$。\n\n您必须通过绘制一个实空间高斯随机场并应用尺度为 $R_s$ 的傅里叶空间高斯平滑来生成高斯势 $\\phi$。位移幅度由一个参数 $A$ 设定，该参数乘以平滑后势的梯度，即 $\\mathbf{s} = -A \\nabla \\phi$。使用周期性傅里叶波数 $\\mathbf{k} = (k_x,k_y,k_z)$，其中 $k_\\alpha = 2\\pi n_\\alpha / L$，整数 $n_\\alpha$ 与 $N^3$ 网格上的离散傅里叶变换一致。\n\n实现细节与约束：\n\n- 生成 $\\phi$ 时，每个测试用例使用可复现的随机数种子。\n- 通过将粒子位置沿各轴包装到 $[0,L)$ 区间内来强制执行周期性边界条件。\n- 对于ORIGAMI沿各轴的壳层穿越检测，沿格点逐行操作，并标记任何相邻对中欧拉坐标在该轴上的差为负的两个粒子。对每个粒子，计算其至少检测到一个相邻对反转的轴的数量；拉格朗日空洞粒子的此计数为零。\n- 对于分水岭算法，使用六个面邻居。如果场完全平坦以至于不存在严格的极小值，则将任何没有严格更低邻居的单元视为汇点（平坦区域的极小值），并相应地进行处理。\n\n您的程序必须处理以下测试套件，其中 $N$ 是每个维度的网格分辨率，$L$ 是盒子大小（单位为共动 $h^{-1}\\,\\mathrm{Mpc}$；不应打印单位），$A$ 是位移幅度，$R_s$ 是与 $L$ 具有相同物理单位的高斯平滑尺度，$\\delta_v$ 是汇点密度对比度的分水岭空洞阈值，$\\mathrm{seed}$ 是伪随机种子：\n\n- 测试用例1（正常路径，弱非线性）：$(N,L,A,R_s,\\delta_v,\\mathrm{seed}) = (16,100.0,0.5,5.0,-0.5,42)$。\n- 测试用例2（中度非线性）：$(16,100.0,1.5,3.0,-0.3,123)$。\n- 测试用例3（较强非线性）：$(16,100.0,3.0,2.0,0.0,7)$。\n- 测试用例4（边缘阈值高，小网格）：$(8,100.0,0.1,2.0,0.5,31415)$。\n\n对于每个测试用例，计算并返回三个量：\n\n- 拉格朗日空洞分数 $f_{\\mathrm{L}}$（小数）。\n- 欧拉分水岭空洞体积分数 $f_{\\mathrm{E}}$（小数）。\n- 绝对失配 $m = |f_{\\mathrm{E}} - f_{\\mathrm{L}}|$（小数）。\n\n您的程序应生成一行输出，包含一个由列表组成的列表，每个内部列表对应一个测试用例，按 $[f_{\\mathrm{L}},f_{\\mathrm{E}},m]$ 顺序排列，并表示为十进制浮点数。例如，一个有效的输出格式是 `[[0.9,0.6,0.3],[...],...]`。不应打印任何其他文本。\n\n注意：所有要求的量都是无量纲的小数。不使用角度。百分比必须表示为小数，而不是带百分号。", "solution": "该问题要求在一个合成的宇宙学粒子分布上实现并比较两种不同的空洞寻找算法。粒子位置是使用泽尔多维奇近似（一种一阶拉格朗日微扰理论模型）生成的。分析将分为三个主要阶段：首先，生成粒子快照；其次，应用拉格朗日空间的ORIGAMI分类；第三，应用欧拉空间的分水岭算法。\n\n### I. 粒子分布的生成\n\n宇宙的初始状态被建模为一个均匀的立方格点，包含 $N^3$ 个粒子，其初始（拉格朗日）位置为 $\\mathbf{q}$。网格间距为 $\\Delta q = L/N$，由索引 $(i,j,k)$ 标识的粒子的位置是 $\\mathbf{q}_{ijk} = ((i+0.5)\\Delta q, (j+0.5)\\Delta q, (k+0.5)\\Delta q)$，其中 $i,j,k \\in \\{0, 1, ..., N-1\\}$。\n\n从拉格朗日位置 $\\mathbf{q}$ 到最终（欧拉）位置 $\\mathbf{x}$ 的演化由泽尔多维奇近似描述：\n$$\n\\mathbf{x}(\\mathbf{q}) = \\mathbf{q} + \\mathbf{s}(\\mathbf{q})\n$$\n其中 $\\mathbf{s}(\\mathbf{q})$ 是位移场。位移场由一个标量势 $\\phi(\\mathbf{q})$ 的梯度导出，并由一个幅度参数 $A$ 进行缩放：\n$$\n\\mathbf{s}(\\mathbf{q}) = -A \\nabla \\phi(\\mathbf{q})\n$$\n势 $\\phi(\\mathbf{q})$ 是一个空间随机高斯场，在特征尺度 $R_s$ 上进行了平滑。这个场是在傅里叶空间中计算生成的。\n\n1.  **傅里叶空间网格**：我们定义一个波矢网格 $\\mathbf{k} = (k_x, k_y, k_z)$，对应于 $N^3$ 格点的离散傅里叶模式。分量由 $k_\\alpha = 2\\pi n_\\alpha/L$ 给出，其中 $n_\\alpha$ 是从 $-N/2$ 到 $N/2-1$ 的整数。\n\n2.  **生成势**：首先通过在实空间创建白噪声网格并进行快速傅里叶变换(FFT)来生成一个未平滑的势。记为 $\\hat{\\phi}_{\\text{raw}}(\\mathbf{k})$。这个过程确保了实数条件 $\\hat{\\phi}(\\mathbf{k}) = \\hat{\\phi}^*(-\\mathbf{k})$ 得到满足，使其逆变换是一个实值场。\n\n3.  **平滑**：该场通过在傅里叶空间中与一个高斯滤波器 $W(|\\mathbf{k}|) = \\exp(-|\\mathbf{k}|^2 R_s^2 / 2)$ 相乘来进行平滑。\n    $$\n    \\hat{\\phi}(\\mathbf{k}) = \\hat{\\phi}_{\\text{raw}}(\\mathbf{k}) W(|\\mathbf{k}|)\n    $$\n    直流分量 $\\hat{\\phi}(\\mathbf{k}=\\mathbf{0})$ 被设为零，以确保平均位移为空。\n\n4.  **计算位移**：实空间中的梯度算子 $\\nabla$ 对应于傅里叶空间中的乘法因子 $i\\mathbf{k}$。因此，位移场的傅里叶变换是：\n    $$\n    \\hat{\\mathbf{s}}(\\mathbf{k}) = -A (i\\mathbf{k}) \\hat{\\phi}(\\mathbf{k})\n    $$\n    然后对 $\\hat{\\mathbf{s}}(\\mathbf{k})$ 的每个分量应用逆FFT，以获得拉格朗日网格上的实空间位移场 $\\mathbf{s}(\\mathbf{q})$。\n\n5.  **最终位置**：欧拉位置计算为 $\\mathbf{x} = \\mathbf{q} + \\mathbf{s}$，并使用模运算符将其折叠回边长为 $L$ 的周期性盒子中：$x_\\alpha' = x_\\alpha \\pmod L$。\n\n### II. 通过ORIGAMI计算拉格朗日空洞分数 ($f_L$)\n\nORIGAMI方法根据初始拉格朗日格点的形变来对宇宙网的区域进行分类。空洞区域是指已经膨胀但未经历壳层穿越（不同物质流相交）的区域。\n\n1.  **壳层穿越检测**：我们沿每个主轴 $\\alpha \\in \\{x,y,z\\}$ 独立评估壳层穿越。对于给定的轴，我们考虑 $N^2$ 条最初与该轴对齐的一维粒子线。对于每条线，粒子都按其初始拉格朗日坐标（例如 $q_x$）排序。如果结构没有沿此轴发生壳层穿越，相应的欧拉坐标 $x_x$ 也应该是单调递增的。如果线上任何一对相邻粒子的顺序发生反转，则检测到壳层穿越。\n    具体来说，对于一条按初始 $q_\\alpha$ 坐标排序的粒子线 $p_0, p_1, \\ldots, p_{N-1}$，如果对于任何 $i \\in \\{0, \\ldots, N-2\\}$ 有 $x_\\alpha(p_{i+1})  x_\\alpha(p_i)$，我们就检测到一个穿越。\n\n2.  **粒子分类**：根据问题的规定，如果粒子 $p_i$ 和 $p_{i+1}$ 之间发生了这种顺序反转，则两个粒子都被标记为在 $\\alpha$ 轴上发生了壳层穿越。对每一条线和每一个轴重复此过程。为每个粒子维护一个计数器 $C_{sc}$，用于跟踪粒子被标记为发生壳层穿越的轴的数量。\n\n3.  **空洞分数计算**：如果一个粒子在三个轴上都没有参与任何壳层穿越事件，即其壳层穿越轴计数 $C_{sc}=0$，则该粒子被分类为“拉格朗日空洞粒子”。拉格朗日空洞分数 $f_L$ 是空洞粒子的总数除以粒子总数 $N^3$。\n    $$\n    f_L = \\frac{\\text{具有 } C_{sc}=0 \\text{ 的粒子数}}{N^3}\n    $$\n\n### III. 欧拉分水岭空洞体积分数 ($f_E$)\n\n此方法将空洞识别为欧拉密度场中的欠密度盆地。\n\n1.  **密度场构建**：将连续密度场离散化到 $N^3$ 的网格上。使用Cloud-in-Cell (CIC)方案将粒子的质量分配到网格点上。对于每个粒子，其质量（取为 $m_p=1$）使用基于其子网格位置的三线性插值权重，分配给周围的8个网格顶点。对所有 $N^3$ 个粒子的贡献求和，得到一个网格化的质量场，我们记为 $\\rho_{\\text{grid}}$。\n\n2.  **密度对比度**：密度对比度 $\\delta$ 定义为 $\\delta(\\mathbf{x}) = \\rho(\\mathbf{x})/\\bar{\\rho} - 1$。由于我们为 $N^3$ 个粒子在 $N^3$ 个网格中选择了 $m_p=1$，每个网格单元的平均质量为 $\\bar{m}=1$。因此，密度对比度可以直接从网格化质量计算得出，即 $\\delta = \\rho_{\\text{grid}} - 1$。\n\n3.  **分水岭分割**：分水岭算法将网格划分为与局部密度极小值相关联的盆地。\n    -   **汇点**：汇点是指没有面相邻邻居的密度严格低于其自身密度的网格单元。汇点对应于局部极小值或平坦区域的极小值。\n    -   **最陡下降**：对于每个网格单元，通过迭代地移动到密度最低的邻居来追踪一条最陡下降路径，直到到达一个汇点。\n    -   **盆地分配**：网格中的每个单元都被分配到其下降路径终止的汇点所在的盆地。这就创建了一个 `basin_map`，其中每个单元都由其对应汇点的索引标记。\n\n4.  **空洞体积分数**：如果一个盆地的汇点密度对比度 $\\delta_{\\text{sink}}$ 低于给定的阈值 $\\delta_v$，则该盆地被分类为空洞。欧拉空洞体积分数 $f_E$ 是属于这些空洞盆地的网格单元所占的比例。\n    $$\n    f_E = \\frac{\\text{汇点满足 } \\delta_{\\text{sink}}  \\delta_v \\text{ 的盆地中的网格单元数}}{N^3}\n    $$\n\n最后，两种度量之间的绝对失配计算为 $m = |f_E - f_L|$。", "answer": "```python\nimport numpy as np\n\ndef generate_displacement_field(N, L, A, Rs, seed):\n    \"\"\"\n    Generates a 3D displacement field using the Zel'dovich approximation.\n    \"\"\"\n    np.random.seed(seed)\n\n    # 1. Generate Gaussian random potential in Fourier space\n    # Generate real-space white noise and FFT to get a k-space field\n    # that satisfies the reality condition.\n    noise = np.random.randn(N, N, N)\n    phi_k = np.fft.fftn(noise)\n\n    # 2. Define k-space grid and apply smoothing\n    k_vec = 2 * np.pi * np.fft.fftfreq(N, d=L / N)\n    kx, ky, kz = np.meshgrid(k_vec, k_vec, k_vec, indexing='ij')\n    ksq = kx**2 + ky**2 + kz**2\n    ksq[0, 0, 0] = 1.0  # Avoid division by zero, will be set to 0 later\n    \n    smoothing_filter = np.exp(-ksq * Rs**2 / 2.0)\n    phi_k_smoothed = phi_k * smoothing_filter\n    phi_k_smoothed[0, 0, 0] = 0.0  # Set DC mode to zero\n\n    # 3. Calculate gradient in k-space and transform back\n    grad_phi_x_k = 1j * kx * phi_k_smoothed\n    grad_phi_y_k = 1j * ky * phi_k_smoothed\n    grad_phi_z_k = 1j * kz * phi_k_smoothed\n\n    s_x = np.real(np.fft.ifftn(grad_phi_x_k))\n    s_y = np.real(np.fft.ifftn(grad_phi_y_k))\n    s_z = np.real(np.fft.ifftn(grad_phi_z_k))\n\n    # Displacement field s = -A * grad(phi)\n    return -A * s_x, -A * s_y, -A * s_z\n\ndef compute_lagrangian_void_fraction(x, y, z, N):\n    \"\"\"\n    Computes Lagrangian void fraction using the ORIGAMI method.\n    \"\"\"\n    # sc_on_axis[i,j,k,ax] is True if particle (i,j,k) shell-crossed on axis ax\n    sc_on_axis = np.zeros((N, N, N, 3), dtype=bool)\n\n    # Axis 0 (x)\n    diffs_x = np.diff(x, axis=0)  0\n    sc_on_axis[:-1, :, :, 0] |= diffs_x\n    sc_on_axis[1:, :, :, 0] |= diffs_x\n\n    # Axis 1 (y)\n    diffs_y = np.diff(y, axis=1)  0\n    sc_on_axis[:, :-1, :, 1] |= diffs_y\n    sc_on_axis[:, 1:, :, 1] |= diffs_y\n\n    # Axis 2 (z)\n    diffs_z = np.diff(z, axis=2)  0\n    sc_on_axis[:, :, :-1, 2] |= diffs_z\n    sc_on_axis[:, :, 1:, 2] |= diffs_z\n\n    # Count number of axes with shell-crossing for each particle\n    num_crossed_axes = np.sum(sc_on_axis, axis=3)\n    \n    # Void particles are those with zero shell-crossed axes\n    num_void_particles = np.sum(num_crossed_axes == 0)\n    \n    return num_void_particles / (N**3)\n\ndef compute_eulerian_void_fraction(x_p, y_p, z_p, N, L, delta_v):\n    \"\"\"\n    Computes Eulerian void fraction using a watershed algorithm on a CIC density field.\n    \"\"\"\n    # 1. CIC mass assignment\n    rho_grid = np.zeros((N, N, N), dtype=np.float64)\n    dx = L / N\n    \n    # Flatten particle positions\n    x_flat, y_flat, z_flat = x_p.flatten(), y_p.flatten(), z_p.flatten()\n\n    # Normalized coordinates\n    px_norm = x_flat / dx\n    py_norm = y_flat / dx\n    pz_norm = z_flat / dx\n    \n    i = np.floor(px_norm).astype(int)\n    j = np.floor(py_norm).astype(int)\n    k = np.floor(pz_norm).astype(int)\n    \n    tx = px_norm - i\n    ty = py_norm - j\n    tz = pz_norm - k\n    \n    # Ensure indices are within [0, N-1] after flooring (due to modulo op)\n    i = i % N\n    j = j % N\n    k = k % N\n    \n    i_plus_1 = (i + 1) % N\n    j_plus_1 = (j + 1) % N\n    k_plus_1 = (k + 1) % N\n\n    # Trilinear weights\n    wx = [1 - tx, tx]\n    wy = [1 - ty, ty]\n    wz = [1 - tz, tz]\n\n    indices_i = [i, i_plus_1]\n    indices_j = [j, j_plus_1]\n    indices_k = [k, k_plus_1]\n    \n    # Add mass contributions\n    for a in range(2):\n        for b in range(2):\n            for c in range(2):\n                weight = wx[a] * wy[b] * wz[c]\n                np.add.at(rho_grid, (indices_i[a], indices_j[b], indices_k[c]), weight)\n\n    # 2. Density contrast\n    delta = rho_grid - 1.0\n    delta_flat = delta.flatten()\n\n    # 3. Watershed segmentation\n    basin_map = -np.ones(N**3, dtype=int)\n    indices_flat_grid = np.arange(N**3).reshape(N,N,N)\n\n    for idx in range(N**3):\n        if basin_map[idx] != -1:\n            continue\n            \n        path = []\n        curr_idx = idx\n        \n        while basin_map[curr_idx] == -1:\n            path.append(curr_idx)\n            i, j, k = np.unravel_index(curr_idx, (N, N, N))\n            \n            neighbors_indices = []\n            neighbors_deltas = []\n\n            for di, dj, dk in [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)]:\n                ni, nj, nk = (i + di) % N, (j + dj) % N, (k + dk) % N\n                neighbors_indices.append(indices_flat_grid[ni, nj, nk])\n                neighbors_deltas.append(delta[ni, nj, nk])\n\n            min_delta_neighbor = min(neighbors_deltas)\n            \n            if min_delta_neighbor  delta_flat[curr_idx]:\n                min_neighbor_idx = neighbors_indices[np.argmin(neighbors_deltas)]\n                curr_idx = min_neighbor_idx\n            else:\n                # Current cell is a sink\n                basin_map[curr_idx] = curr_idx\n                break\n        \n        sink_idx = basin_map[curr_idx]\n        for node_idx in path:\n            basin_map[node_idx] = sink_idx\n\n    # 4. Compute void fraction\n    unique_sinks = np.unique(basin_map)\n    sink_deltas = delta_flat[unique_sinks]\n    \n    void_sinks = unique_sinks[sink_deltas  delta_v]\n    \n    is_in_void_basin = np.isin(basin_map, void_sinks)\n    f_E = np.sum(is_in_void_basin) / (N**3)\n    \n    return f_E\n\ndef solve():\n    test_cases = [\n        (16, 100.0, 0.5, 5.0, -0.5, 42),\n        (16, 100.0, 1.5, 3.0, -0.3, 123),\n        (16, 100.0, 3.0, 2.0, 0.0, 7),\n        (8, 100.0, 0.1, 2.0, 0.5, 31415),\n    ]\n\n    results = []\n    for N, L, A, Rs, delta_v, seed in test_cases:\n        # Generate initial Lagrangian grid\n        grid_1d = (np.arange(N) + 0.5) * L / N\n        q_x, q_y, q_z = np.meshgrid(grid_1d, grid_1d, grid_1d, indexing='ij')\n\n        # Generate displacement field\n        s_x, s_y, s_z = generate_displacement_field(N, L, A, Rs, seed)\n        \n        # Calculate Eulerian positions\n        x = (q_x + s_x) % L\n        y = (q_y + s_y) % L\n        z = (q_z + s_z) % L\n\n        # Calculate Lagrangian void fraction\n        f_L = compute_lagrangian_void_fraction(x, y, z, N)\n\n        # Calculate Eulerian void fraction\n        f_E = compute_eulerian_void_fraction(x, y, z, N, L, delta_v)\n        \n        # Calculate mismatch\n        m = abs(f_E - f_L)\n        \n        results.append([f_L, f_E, m])\n    \n    # Print results in the required format\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3502019"}]}