{"hands_on_practices": [{"introduction": "理论知识通过动手实践才能真正融会贯通。这个核心练习将指导你在简化的平坦天空近似下，从头到尾构建一个完整的CMB透镜重建流程。你将亲手生成模拟的透镜CMB数据，应用二次估计器，并实践移除平均场和噪声偏差等关键步骤，最终目的是无偏地恢复输入的透镜势功率谱[@problem_id:3467573]。完成这个练习将为你从事该领域的任何实际分析工作打下坚实的编程和物理基础。", "problem": "您的任务是设计一个自洽的蒙特卡洛管道，用于在平坦天区（flat-sky）上使用二次估计量进行宇宙微波背景（CMB）引力透镜重建。目标是生成具有已知输入偏转势功率谱 $C_L^{\\phi\\phi}$ 的引力透镜化CMB温度图，重建引力透镜势，并在扣除平均场和重建噪声偏差后，展示如何恢复无偏估计 $\\hat C_L^{\\phi\\phi}$。您的程序必须实现以下内容，并以纯数学术语表达，角度单位使用弧度。\n\n基于基本原理和经过充分检验的公式：\n\n1.  平坦天区上的引力透镜重映射由标量偏转势 $\\phi(\\boldsymbol{x})$ 定义，其中偏转场为 $\\boldsymbol{d}(\\boldsymbol{x}) = \\nabla \\phi(\\boldsymbol{x})$。观测到的引力透镜化温度场满足 $T_{\\mathrm{obs}}(\\boldsymbol{x}) = T_{\\mathrm{unl}}\\!\\left(\\boldsymbol{x} + \\boldsymbol{d}(\\boldsymbol{x})\\right) + n(\\boldsymbol{x})$，其中 $n(\\boldsymbol{x})$ 表示仪器噪声。在小偏转情况下，使用一阶泰勒展开 $T_{\\mathrm{obs}}(\\boldsymbol{x}) \\approx T_{\\mathrm{unl}}(\\boldsymbol{x}) + \\nabla T_{\\mathrm{unl}}(\\boldsymbol{x}) \\cdot \\nabla \\phi(\\boldsymbol{x}) + n(\\boldsymbol{x})$。此展开式是二次估计量的基础，因为它引入了由引力透镜效应驱动的、在其他情况下本应独立的未引力透镜化CMB傅里叶模式之间的耦合。\n\n2.  未引力透镜化的CMB温度 $T_{\\mathrm{unl}}(\\boldsymbol{x})$ 和势 $\\phi(\\boldsymbol{x})$ 被建模为在一个边长为 $L_{\\mathrm{box}}$（以弧度为单位）的方形周期性天区上的统计各向同性高斯随机场，并在一个 $N \\times N$ 网格上表示。各向同性功率谱 $C_\\ell^{TT}$ 和 $C_L^{\\phi\\phi}$ 定义了相应傅里叶模式的二阶统计量。仪器噪声被建模为实空间中每个像素方差为 $\\sigma_n^2$ 的不相关高斯噪声，对应于傅里叶空间中的白噪声功率谱。\n\n3.  引力透镜重建是根据观测到的温度 $T_{\\mathrm{obs}}(\\boldsymbol{x})$ 进行的，使用由两个经过不同滤波的温度场及其空间梯度构建的二次估计量，其构建动机源于从泰勒展开中导出的模式耦合。该估计量生成一个重建的势图 $\\hat\\phi(\\boldsymbol{x})$（或其傅里叶表示 $\\hat\\phi(\\boldsymbol{L})$）。该估计量存在两种必须移除的偏差：\n    *   平均场偏差源于任何各向异性，例如掩模（masking）或各向异性噪声，并表现为一个非零的平均值 $\\langle \\hat\\phi(\\boldsymbol{L}) \\rangle$。必须通过对大量具有相同各向异性的未引力透镜化模拟进行蒙特卡洛平均来估计和扣除此偏差。\n    *   $N^{(0)}$（非连通）重建噪声偏差出现在自功率谱 $\\langle |\\hat\\phi(\\boldsymbol{L})|^2 \\rangle$ 中，即使当 $C_L^{\\phi\\phi} = 0$ 时也是如此。必须从未引力透镜化的蒙特卡洛模拟中估计此偏差，并在带功率（band powers）中进行扣除。\n\n4.  由于在有限、带掩模的天区上，二次估计量的解析归一化可能很复杂，您必须使用与已知的模拟输入势的互功率谱来校准估计量的响应，在 $L = |\\boldsymbol{L}|$ 的分箱（bins）中计算响应因子 $R_L$。这允许通过 $\\hat C_L^{\\phi\\phi} \\approx \\left(C_L^{\\mathrm{auto}} - N^{(0)}_L\\right)/R_L^2$ 实现无偏恢复，其中 $C_L^{\\mathrm{auto}}$ 是扣除平均场后的重建自功率谱的带功率，$N^{(0)}_L$ 是估计的噪声偏差带功率。\n\n数值设置和约束：\n\n-   在一个边长为 $L_{\\mathrm{box}}$（以弧度为单位）、包含 $N \\times N$ 像素的方形、周期性平坦天区上工作。所有角度必须以弧度处理。\n-   使用离散傅里叶变换，其波矢 $\\boldsymbol{k} = (k_x, k_y)$ 的分量为 $k_i = 2\\pi n_i / L_{\\mathrm{box}}$，其中整数索引 $n_i$ 由 $N \\times N$ 网格的傅里叶变换约定定义。\n-   通过在傅里叶空间中对高斯白场进行滤波，生成与其功率谱一致的高斯随机场 $T_{\\mathrm{unl}}$ 和 $\\phi$。\n-   实现一个在天区边界附近带有余弦锥削的圆形切趾掩模 $M(\\boldsymbol{x})$，以引入平均场。该掩模的特征是切趾分数 $f_{\\mathrm{apod}}$（相对于半尺寸而言），即锥削宽度等于 $f_{\\mathrm{apod}} \\times L_{\\mathrm{box}}/2$。\n-   使用一阶泰勒近似来对温度进行引力透镜处理：$T_{\\mathrm{lens}}(\\boldsymbol{x}) \\approx T_{\\mathrm{unl}}(\\boldsymbol{x}) + \\nabla T_{\\mathrm{unl}}(\\boldsymbol{x}) \\cdot \\nabla \\phi(\\boldsymbol{x})$。\n-   由两个经过相反滤波的温度场及其梯度构建二次估计量，使用基于 $C_\\ell^{TT}$ 和包含白噪声的总温度功率谱构建的各向同性滤波器。在傅里叶空间中计算重建结果，并在 $L$ 的分箱中形成带功率。\n\n测试套件和验收标准：\n\n实现三个测试用例，每个用例由一个元组 $(A_\\phi, \\sigma_n, f_{\\mathrm{apod}})$ 指定：\n-   用例1（理想路径）：$(3\\times 10^{-7}, 5\\times 10^{-6}, 0.10)$。\n-   用例2（无引力透镜边界）：$(0, 5\\times 10^{-6}, 0.10)$。\n-   用例3（高噪声边缘）：$(3\\times 10^{-7}, 2\\times 10^{-5}, 0.20)$。\n\n在所有用例中，使用固定的 $N$ 和 $L_{\\mathrm{box}}$，以及一个物理上合理且在高 $\\ell$ 处衰减的固定 $C_\\ell^{TT}$ 形状。将重建的谱分箱到适量数量的 $L$ 箱中，覆盖引力透镜信号不可忽略的低至中等 $L$ 范围。\n\n对于每个用例：\n-   使用具有相同掩模和噪声的未引力透镜化蒙特卡洛模拟，估计并扣除平均场和 $N^{(0)}$。使用足够多的蒙特卡洛实现，以使扣除过程稳定。\n-   对于引力透镜化的模拟，通过重建场与输入 $\\phi$ 的互功率谱来校准估计器响应 $R_L$。对于 $A_\\phi=0$ 的情况，跳过响应校准，并根据定义设置 $R_L=1$。\n-   在每个分箱中，使用 $\\hat C_L^{\\phi\\phi} = \\left(C_L^{\\mathrm{auto}} - N^{(0)}_L\\right)/R_L^2$ 形成无偏估计 $\\hat C_L^{\\phi\\phi}$。\n\n验收标准：\n-   用例1和用例3：设 $C_{L,\\,\\mathrm{model}}^{\\phi\\phi}$ 是通过对理论 $C_L^{\\phi\\phi}$进行分箱平均计算得到的输入模型带功率。计算每个分箱的相对偏差为 $\\Delta = \\left|\\hat C_L^{\\phi\\phi} - C_{L,\\,\\mathrm{model}}^{\\phi\\phi}\\right| / \\left(C_{L,\\,\\mathrm{model}}^{\\phi\\phi} + \\epsilon\\right)$，其中 $\\epsilon$ 是一个小的正则化项以避免除以零。如果在具有不可忽略输入信号的分箱上 $\\Delta$ 的中位数低于一个容差，则判为通过。用例1使用0.6，用例3使用0.8。\n-   用例2：当 $A_\\phi = 0$ 时，如果扣除了平均场和 $N^{(0)}$ 的重建带功率在所有分箱中的最大绝对值小于最大 $N^{(0)}$ 带功率的0.2倍，则判为通过。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3]\"），其中每个结果是一个布尔值，指示是否满足了相应测试用例的验收标准。", "solution": "用户提供的问题被评估为 **有效（valid）**。它描述了一个在数值宇宙学领域科学上合理且定义明确的任务，特别关注宇宙微波背景（CMB）引力透镜重建。该问题是自洽的，所有必要的物理模型、数值程序和测试标准都已清晰定义。没有发现矛盾、事实错误或不可行的要求。该任务涉及实现一个标准的、尽管是简化的蒙特卡洛流程，这是一个重要但可行的难题。\n\n因此，我将继续提供一个完整的解决方案。该解决方案的结构遵循CMB引力透镜分析流程的逻辑顺序，从理论原理到数值实现和验证。\n\n### 1. 理论框架与模型\n\n分析在一个边长为 $L_{\\mathrm{box}}$ 的方形、周期性、平坦天区上进行，该天区被离散化到 $N \\times N$ 网格上。所有角度单位均为弧度。\n\n基本场，即未引力透镜化的CMB温度 $T_{\\mathrm{unl}}(\\boldsymbol{x})$ 和引力透镜势 $\\phi(\\boldsymbol{x})$，被建模为统计上各向同性且均匀的高斯随机场。它们的统计特性完全由其角功率谱 $C_\\ell^{TT}$ 和 $C_L^{\\phi\\phi}$ 分别定义。场 $F(\\boldsymbol{x})$ 与其功率谱 $C_L^F$ 之间的关系由其傅里叶模式 $\\tilde{F}(\\boldsymbol{L})$ 的二点相关函数给出：\n$$\n\\langle \\tilde{F}(\\boldsymbol{L}) \\tilde{F}^*(\\boldsymbol{L}') \\rangle = (2\\pi)^2 \\delta^{(2)}(\\boldsymbol{L} - \\boldsymbol{L}') C_L^F\n$$\n其中 $\\boldsymbol{L}$ 是二维波矢（或多极矢量），$L = |\\boldsymbol{L}|$。\n\n观测到的CMB温度 $T_{\\mathrm{obs}}(\\boldsymbol{x})$ 是由引力透镜势的梯度 $\\boldsymbol{d}(\\boldsymbol{x}) = \\nabla\\phi(\\boldsymbol{x})$ 重映射后的未引力透镜化温度场，再加上仪器噪声 $n(\\boldsymbol{x})$：\n$$\nT_{\\mathrm{obs}}(\\boldsymbol{x}) = T_{\\mathrm{unl}}(\\boldsymbol{x} + \\nabla\\phi(\\boldsymbol{x})) + n(\\boldsymbol{x})\n$$\n对于本分析，我们使用此关系的一阶泰勒展开，该展开在小偏转角时有效：\n$$\nT_{\\mathrm{obs}}(\\boldsymbol{x}) \\approx T_{\\mathrm{unl}}(\\boldsymbol{x}) + \\nabla T_{\\mathrm{unl}}(\\boldsymbol{x}) \\cdot \\nabla \\phi(\\boldsymbol{x}) + n(\\boldsymbol{x})\n$$\n这个展开揭示了CMB模式与引力透镜势模式之间的耦合，这是二次估计量的基础。仪器噪声 $n(\\boldsymbol{x})$被建模为一个具有白噪声功率谱的高斯随机场，源于方差为 $\\sigma_n^2$ 的不相关像素噪声。\n\n### 2. 数值模拟流程\n\n**a. 离散化与场的生成：**\n我们定义一个波矢网格 $\\boldsymbol{L} = (L_x, L_y)$，其中 $L_i = 2\\pi n_i/L_{\\mathrm{box}}$，$n_i$ 为整数索引。通过创建一个复高斯随机数网格，并根据期望的功率谱对其进行缩放，可以在傅里叶空间中生成高斯随机场。对于一个 $N \\times N$ 网格上的离散傅里叶变换（DFT），傅里叶系数 $\\tilde{F}_{\\boldsymbol{L}}$ 的方差与连续功率谱 $C_L^F$ 的关系为：\n$$\n\\langle |\\tilde{F}_{\\boldsymbol{L}}|^2 \\rangle = \\frac{N^4}{L_{\\mathrm{box}}^2} C_L^F\n$$\n生成的傅里叶场必须满足实数条件 $\\tilde{F}(\\boldsymbol{L}) = \\tilde{F}^*(-\\boldsymbol{L})$，这在生成具有独立实部和虚部的复数并执行逆FFT时可以自然地处理。\n\n**b. 引力透镜效应与观测：**\n泰勒近似的引力透镜效应通过首先独立生成 $T_{\\mathrm{unl}}$ 和 $\\phi$ 图来实现。它们的梯度 $\\nabla T_{\\mathrm{unl}}$ 和 $\\nabla \\phi$ 在傅里叶空间中使用属性 $\\mathcal{F}[\\nabla F(\\boldsymbol{x})] = i\\boldsymbol{L} \\tilde{F}(\\boldsymbol{L})$ 高效计算。然后根据泰勒展开组合实空间场。加入高斯白噪声，最后将一个带有余弦锥削边缘的圆形切趾掩模 $M(\\boldsymbol{x})$ 应用于最终的图，以生成观测数据 $T_{\\mathrm{obs}}(\\boldsymbol{x})$。该掩模对于引入一个非平凡的平均场偏差至关重要，这在实际观测中很常见。\n\n### 3. 使用二次估计量进行引力透镜重建\n\n**a. 估计量公式：**\n二次估计量通过关联成对的温度模式来重建引力透镜势。一种实用且稳健的实现是使用滤波后温度场的对称组合。我们在傅里叶空间中定义两个滤波图：\n$$\n\\tilde{M}_1(\\boldsymbol{\\ell}) = \\frac{\\tilde{T}_{\\mathrm{obs}}(\\boldsymbol{\\ell})}{C_\\ell^{\\mathrm{tot}}} \\quad \\text{and} \\quad \\tilde{M}_2(\\boldsymbol{\\ell}) = \\frac{\\tilde{T}_{\\mathrm{obs}}(\\boldsymbol{\\ell}) C_\\ell^{TT}}{C_\\ell^{\\mathrm{tot}}}\n$$\n其中 $C_\\ell^{\\mathrm{tot}} = C_\\ell^{TT} + N_\\ell$ 是观测数据的总功率谱，包括信号和噪声。偏转场 $\\boldsymbol{d}(\\boldsymbol{x})$ 的估计量在实空间中构建如下：\n$$\n\\hat{\\boldsymbol{d}}_{\\mathrm{est}}(\\boldsymbol{x}) = M_1(\\boldsymbol{x}) \\nabla M_2(\\boldsymbol{x}) + M_2(\\boldsymbol{x}) \\nabla M_1(\\boldsymbol{x})\n$$\n引力透镜势 $\\phi$ 与其偏转场 $\\boldsymbol{d}$ 的关系为 $\\nabla^2\\phi = \\nabla \\cdot \\boldsymbol{d}$。在傅里叶空间中，这变为 $-L^2 \\tilde{\\phi}(\\boldsymbol{L}) = i\\boldsymbol{L} \\cdot \\tilde{\\boldsymbol{d}}(\\boldsymbol{L})$。因此，傅里叶空间中未归一化的重建势为：\n$$\n\\hat{\\phi}_{\\mathrm{unnorm}}(\\boldsymbol{L}) = \\frac{i\\boldsymbol{L} \\cdot \\tilde{\\boldsymbol{d}}_{\\mathrm{est}}(\\boldsymbol{L})}{L^2}\n$$\n\n**b. 偏差扣除与校准：**\n原始重建 $\\hat{\\phi}_{\\mathrm{unnorm}}$ 是有偏的。我们必须校正两种主要的加性偏差和一种乘性偏差。\n\n1.  **平均场偏差 ($\\hat{\\phi}_{MF}$):** 来自掩模的各向异性导致估计量即使在未引力透镜化的天空下也具有非零的期望值，即 $\\langle \\hat{\\phi}_{\\mathrm{unnorm}} \\rangle \\neq 0$。这就是平均场，通过对大量（$N_{\\mathrm{MC}}$）使用相同掩模的未引力透镜化、含噪声的模拟重建结果进行平均来估计。然后，这个平均值 $\\hat{\\phi}_{\\mathrm{MF}}(\\boldsymbol{L})$ 会从所有后续的重建中扣除。\n\n2.  **重建噪声偏差 ($N^{(0)}$):** 重建的自功率谱 $\\langle |\\hat{\\phi}|^2 \\rangle$ 包含一个大的加性偏差，该偏差来自未引力透镜化CMB模式的随机相关性。这就是 $N^{(0)}$ 偏差。其功率谱 $N_L^{(0)}$ 是通过计算来自同一组 $N_{\\mathrm{MC}}$ 未引力透镜化模拟的、已扣除平均场的重建结果的平均功率谱来估计的。\n\n3.  **响应校准 ($R_L$):** 由于滤波、掩模和近似，估计量对真实势的响应不是1。响应因子 $R_L$ 是通过将一次引力透镜化模拟（具有已知输入势 $\\phi_{\\mathrm{in}}$）的重建结果与输入势本身进行互相关来确定的。响应是互功率谱与输入模型功率谱的比值：\n    $$\n    R_L = \\frac{\\langle \\mathrm{Re}[\\hat{\\phi}_{\\mathrm{sub}}(\\boldsymbol{L}) \\phi_{\\mathrm{in}}^*(\\boldsymbol{L})] \\rangle_L}{C_{L, \\mathrm{model}}^{\\phi\\phi}}\n    $$\n    其中 $\\hat{\\phi}_{\\mathrm{sub}}$ 是已扣除平均场的结果。\n\n### 4. 最终无偏功率谱\n\n引力透镜势功率谱的最终无偏估计 $\\hat{C}_L^{\\phi\\phi}$ 通过组合这些校正来构建。对于一次引力透镜化的“数据”模拟，我们计算其扣除平均场后的重建结果的自功率谱 $C_L^{\\mathrm{auto}}$。最终的谱则为：\n$$\n\\hat{C}_L^{\\phi\\phi} = \\frac{C_L^{\\mathrm{auto}} - N_L^{(0)}}{R_L^2}\n$$\n功率谱在多极矩幅度 $L$ 的离散分箱中计算。然后根据为每个测试用例定义的验收标准来评估结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run the CMB lensing reconstruction pipeline for all test cases.\n    \"\"\"\n\n    # --- Numerical and Physical Setup ---\n    N = 256  # Grid size\n    L_BOX_DEG = 5.0  # Box side length in degrees\n    L_BOX_RAD = np.deg2rad(L_BOX_DEG)  # Box side length in radians\n    PIX_SIZE_RAD = L_BOX_RAD / N\n    N_MC = 100  # Number of Monte Carlo simulations for bias/noise estimation\n    L_BINS = 10  # Number of bins for power spectra\n    EPSILON = 1e-30  # Small regularization constant\n\n    # Fourier space grids for multipole vectors L = (Lx, Ly)\n    _kx = np.fft.fftfreq(N, d=PIX_SIZE_RAD) * 2 * np.pi\n    _ky = np.fft.fftfreq(N, d=PIX_SIZE_RAD) * 2 * np.pi\n    ELL_X, ELL_Y = np.meshgrid(_kx, _ky, indexing='ij')\n    ELL_MAG = np.sqrt(ELL_X**2 + ELL_Y**2)\n    ELL_MAG[0, 0] = 1.0  # Avoid division by zero at DC mode (L=0)\n\n    # Binning setup for power spectra\n    l_max_ana = np.pi / PIX_SIZE_RAD # Theoretical Nyquist limit\n    bin_edges = np.linspace(2, min(l_max_ana, 800), L_BINS + 1)\n        \n    def get_fiducial_spectra(ell_mag, noise_var):\n        \"\"\"Defines the fiducial power spectra C_TT and C_tot.\"\"\"\n        c_ell_tt = np.zeros_like(ell_mag)\n        valid_ells = ell_mag > 1\n        c_ell_tt[valid_ells] = 1.0 / (ell_mag[valid_ells]**2 + 50**2)\n        n_ell_tt = noise_var * PIX_SIZE_RAD**2\n        return c_ell_tt, c_ell_tt + n_ell_tt\n\n    def get_phi_power_spectrum(ell_mag, A_phi):\n        \"\"\"Defines the input lensing potential power spectrum C_phiphi.\"\"\"\n        c_ell_pp = np.zeros_like(ell_mag)\n        valid_ells = ell_mag > 1\n        c_ell_pp[valid_ells] = A_phi / (ell_mag[valid_ells] * (ell_mag[valid_ells] + 1.0))\n        return c_ell_pp\n\n    def generate_gaussian_field(c_ell_2d):\n        \"\"\"Generates a 2D Gaussian random field from a given power spectrum.\"\"\"\n        noise = (np.random.normal(size=(N, N)) + 1j * np.random.normal(size=(N, N))) / np.sqrt(2)\n        fourier_map = noise * np.sqrt(c_ell_2d * (N**4 / L_BOX_RAD**2))\n        fourier_map[0, 0] = 0.0 # Fluctuation field has zero mean\n        return np.fft.ifft2(fourier_map).real\n\n    def get_mask(f_apod):\n        \"\"\"Creates a circular mask with cosine apodization.\"\"\"\n        y, x = np.indices((N, N))\n        center_x, center_y = N // 2, N // 2\n        r = np.sqrt((x - center_x)**2 + (y - center_y)**2)\n        \n        r_max = N / 2.0\n        taper_width = f_apod * r_max\n        inner_radius = r_max - taper_width\n        \n        mask = np.zeros((N, N))\n        mask[r = inner_radius] = 1.0\n        taper_region = (r > inner_radius)  (r = r_max)\n        mask[taper_region] = 0.5 * (1 + np.cos(np.pi * (r[taper_region] - inner_radius) / taper_width))\n        return mask\n\n    def apply_lensing(t_unl, phi):\n        \"\"\"Lenses a temperature map using the first-order Taylor expansion.\"\"\"\n        t_unl_k = np.fft.fft2(t_unl)\n        phi_k = np.fft.fft2(phi)\n\n        grad_t_x = np.fft.ifft2(1j * ELL_X * t_unl_k).real\n        grad_t_y = np.fft.ifft2(1j * ELL_Y * t_unl_k).real\n        d_x = np.fft.ifft2(1j * ELL_X * phi_k).real\n        d_y = np.fft.ifft2(1j * ELL_Y * phi_k).real\n        \n        return t_unl + grad_t_x * d_x + grad_t_y * d_y\n\n    def get_binned_power(field_k, ell_map):\n        \"\"\"Computes the binned 1D power spectrum from a 2D Fourier field.\"\"\"\n        power_2d = np.abs(field_k)**2 * (L_BOX_RAD**2 / N**4)\n        \n        bin_indices = np.digitize(ell_map.flatten(), bin_edges)\n        # Bincount needs non-negative integer indices. Digitize provides 1-based, 0 for  min.\n        # Max index is len(bin_edges). We need to handle this.\n        valid_indices = (bin_indices > 0)  (bin_indices = L_BINS)\n        weights_flat = power_2d.flatten()[valid_indices]\n        indices_flat = bin_indices[valid_indices] - 1 # to 0-based\n        \n        binned_power = np.bincount(indices_flat, weights=weights_flat, minlength=L_BINS)\n        bin_counts = np.bincount(indices_flat, minlength=L_BINS)\n        \n        return np.divide(binned_power, bin_counts, out=np.zeros_like(binned_power), where=bin_counts!=0)\n\n    def quadratic_estimator(t_obs, c_ell_tt, c_ell_tot):\n        \"\"\"Implements the symmetric quadratic estimator for phi.\"\"\"\n        t_obs_k = np.fft.fft2(t_obs)\n        \n        M1_k = t_obs_k / (c_ell_tot + EPSILON)\n        M2_k = t_obs_k * c_ell_tt / (c_ell_tot + EPSILON)\n        \n        M1 = np.fft.ifft2(M1_k).real\n        M2 = np.fft.ifft2(M2_k).real\n\n        grad_M1_x = np.fft.ifft2(1j * ELL_X * M1_k).real\n        grad_M1_y = np.fft.ifft2(1j * ELL_Y * M1_k).real\n        grad_M2_x = np.fft.ifft2(1j * ELL_X * M2_k).real\n        grad_M2_y = np.fft.ifft2(1j * ELL_Y * M2_k).real\n\n        d_est_x = M1 * grad_M2_x + M2 * grad_M1_x\n        d_est_y = M1 * grad_M2_y + M2 * grad_M1_y\n        \n        d_est_x_k = np.fft.fft2(d_est_x)\n        d_est_y_k = np.fft.fft2(d_est_y)\n\n        phi_k_unnorm = (1j * ELL_X * d_est_x_k + 1j * ELL_Y * d_est_y_k) / (ELL_MAG**2 + EPSILON)\n        phi_k_unnorm[0, 0] = 0.0\n        return phi_k_unnorm\n\n    def run_case(A_phi, sigma_n, f_apod):\n        \"\"\"Executes one full test case.\"\"\"\n        c_ell_tt, c_ell_tot = get_fiducial_spectra(ELL_MAG, sigma_n**2)\n        mask = get_mask(f_apod)\n        \n        # --- Monte Carlo for Mean-Field and N0 Bias ---\n        phi_mf_k_sum = np.zeros((N, N), dtype=complex)\n        for _ in range(N_MC):\n            t_unl = generate_gaussian_field(c_ell_tt)\n            noise = np.random.normal(0, sigma_n, (N, N))\n            t_obs_unlensed = (t_unl + noise) * mask\n            phi_mf_k_sum += quadratic_estimator(t_obs_unlensed, c_ell_tt, c_ell_tot)\n        phi_mf_k = phi_mf_k_sum / N_MC\n\n        n0_power_sum = np.zeros(L_BINS)\n        for _ in range(N_MC):\n            t_unl = generate_gaussian_field(c_ell_tt)\n            noise = np.random.normal(0, sigma_n, (N, N))\n            t_obs_unlensed = (t_unl + noise) * mask\n            phi_rec_k = quadratic_estimator(t_obs_unlensed, c_ell_tt, c_ell_tot)\n            phi_rec_k_mf_sub = phi_rec_k - phi_mf_k\n            n0_power_sum += get_binned_power(phi_rec_k_mf_sub, ELL_MAG)\n        n0_binned = n0_power_sum / N_MC\n        \n        # --- Main \"Data\" Simulation and Reconstruction ---\n        c_ell_pp_in = get_phi_power_spectrum(ELL_MAG, A_phi)\n        t_unl_main = generate_gaussian_field(c_ell_tt)\n        phi_in = generate_gaussian_field(c_ell_pp_in)\n        \n        t_lensed = apply_lensing(t_unl_main, phi_in) if A_phi > 0 else t_unl_main\n        noise_main = np.random.normal(0, sigma_n, (N, N))\n        t_obs_lensed = (t_lensed + noise_main) * mask\n        \n        phi_rec_lensed_k = quadratic_estimator(t_obs_lensed, c_ell_tt, c_ell_tot)\n        phi_rec_lensed_mf_sub_k = phi_rec_lensed_k - phi_mf_k\n        c_auto_binned = get_binned_power(phi_rec_lensed_mf_sub_k, ELL_MAG)\n        \n        # --- Calibration and Final Spectrum ---\n        c_model_binned = get_binned_power(np.sqrt(c_ell_pp_in * (N**4 / L_BOX_RAD**2) + EPSILON), ELL_MAG)\n\n        if A_phi > 0:\n            phi_in_k = np.fft.fft2(phi_in)\n            cross_power_2d = np.real(phi_rec_lensed_mf_sub_k * np.conj(phi_in_k)) * (L_BOX_RAD**2 / N**4)\n            c_cross_binned = get_binned_power(np.sqrt(cross_power_2d.clip(min=0)), ELL_MAG) # Hack to use binner\n            \n            # Recalculate cross-power without the hack\n            bin_indices = np.digitize(ELL_MAG.flatten(), bin_edges)\n            valid_indices = (bin_indices > 0)  (bin_indices = L_BINS)\n            weights_flat = cross_power_2d.flatten()[valid_indices]\n            indices_flat = bin_indices[valid_indices] - 1\n            binned_cross = np.bincount(indices_flat, weights=weights_flat, minlength=L_BINS)\n            bin_counts = np.bincount(indices_flat, minlength=L_BINS)\n            c_cross_binned = np.divide(binned_cross, bin_counts, out=np.zeros_like(binned_cross), where=bin_counts!=0)\n            \n            r_binned = np.divide(c_cross_binned, c_model_binned, out=np.ones_like(c_model_binned), where=c_model_binned > EPSILON)\n            c_reco_binned = (c_auto_binned - n0_binned) / (r_binned**2 + EPSILON)\n        else:\n            c_reco_binned = c_auto_binned - n0_binned\n\n        # --- Acceptance Criteria ---\n        if A_phi > 0:\n            significant_bins = c_model_binned > 0.1 * np.max(c_model_binned[np.isfinite(c_model_binned)])\n            if not np.any(significant_bins): return False\n            dev = np.abs(c_reco_binned - c_model_binned) / (c_model_binned + EPSILON)\n            median_dev = np.median(dev[significant_bins])\n            tolerance = 0.6 if sigma_n  1.1e-5 else 0.8\n            return median_dev  tolerance\n        else:\n            max_abs_residual = np.max(np.abs(c_reco_binned))\n            max_n0 = np.max(n0_binned[np.isfinite(n0_binned)])\n            if max_n0 == 0: return True # If N0 is zero, any residual is ok\n            return max_abs_residual  0.2 * max_n0\n\n    # Define test cases\n    test_cases = [\n        (3e-7, 5e-6, 0.10),\n        (0, 5e-6, 0.10),\n        (3e-7, 2e-5, 0.20),\n    ]\n\n    results = []\n    for case in test_cases:\n        A_phi, sigma_n, f_apod = case\n        results.append(run_case(A_phi, sigma_n, f_apod))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3467573"}, {"introduction": "任何科学测量都离不开对其不确定性的量化。在上一节我们得到了透镜功率谱的估计值，一个自然而然的问题是：这个估计的误差有多大？这个实践练习将聚焦于透镜重建的下一个关键步骤：量化最终得到的功率谱分档（bandpower）估计 $\\hat{C}_b^{\\phi\\phi}$ 的统计不确定性[@problem_id:3467597]。你将推导分档协方差矩阵的解析形式，并通过蒙特卡洛模拟进行验证，从而学会如何为你的测量结果提供可靠的误差棒。", "problem": "您的任务是推导、实现并验证宇宙微波背景（CMB; Cosmic Microwave Background）引力透镜势功率谱的带功率估计（记为 $\\hat{C}_b^{\\phi\\phi}$）的协方差。您需要使用二次估计方法框架，并在数值宇宙学中采用标准近似。带功率由引力透镜势 $\\phi$ 的多极矩 $L$ 构建，重建谱包含来自真实信号 $C_L^{\\phi\\phi}$、高斯非关联噪声偏差 $N_L^{(0)}$ 以及关联非高斯偏差 $N_L^{(1)}$ 的贡献。您的程序必须计算包含样本方差和噪声的带功率解析协方差，并通过蒙特卡洛系综对其进行数值验证。\n\n从以下基本前提开始：\n- 重建的引力透镜势谐波系数定义了一个重建谱，其均值是信号和偏差之和。\n- 在各向同性高斯近似和部分天区覆盖率 $f_{\\mathrm{sky}}$ 的条件下，多极模式 $L$ 近似独立，有效模式数与 $(2L+1) f_{\\mathrm{sky}}$ 成比例。\n- 带功率是通过在 $L$ 的不相交区间（bins）上对估计量进行平均而形成的。\n\n您必须：\n1. 在离散多极矩网格上定义一个科学上合理的信号和噪声模型：\n   - 引力透镜势功率谱 $C_L^{\\phi\\phi}$ 被建模为 $L$ 的衰减函数：对于 $L \\ge 2$，$C_L^{\\phi\\phi} = A_{\\phi} \\exp(-L/L_d) / [L(L+1)]$，其中 $A_{\\phi}  0$ 且 $L_d  0$，并且当 $L  2$ 时 $C_L^{\\phi\\phi} = 0$。\n   - 高斯非关联噪声偏差 $N_L^{(0)}$ 被建模为 $N_L^{(0)} = N_0 \\left[1 + (L/L_0)^2\\right]$，其中 $N_0  0$ 且 $L_0  0$。\n   - 关联非高斯偏差 $N_L^{(1)}$ 被建模为 $N_L^{(1)} = \\alpha_1 C_L^{\\phi\\phi}$，其中 $\\alpha_1 \\ge 0$。\n   - 每个多极矩的总重建谱为 $C_L^{\\mathrm{tot}} = C_L^{\\phi\\phi} + N_L^{(0)} + N_L^{(1)}$。\n\n2. 通过在每个区间 $b$ 内对多极矩 $L$ 上的 $\\hat{C}_L$ 进行均匀平均来定义带功率 $\\hat{C}_b^{\\phi\\phi}$。区间被指定为 $L$ 的包含性整数范围。\n\n3. 在各向同性高斯近似和部分天区覆盖率 $f_{\\mathrm{sky}}$ 条件下，从第一性原理推导带功率的解析协方差，明确考虑 $C_L^{\\phi\\phi}$、$N_L^{(0)}$ 和 $N_L^{(1)}$ 的贡献以及模式的有限采样。\n\n4. 通过从符合高斯近似和部分天区覆盖率 $f_{\\mathrm{sky}}$ 的适当分布中抽取 $\\hat{C}_L$ 系综，为每个实现构建带功率，并估计整个系综的样本协方差，以此来实现蒙特卡洛验证。系综应足够大以确保估计稳定，且抽样在不同 $L$ 和实现之间必须独立。\n\n5. 比较解析协方差与蒙特卡洛协方差的对角元素（方差）和非对角元素（协方差）。您的程序必须返回布尔值，指示对角元素的最大相对偏差是否在指定容差范围内，以及最大绝对非对角元素与代表性对角尺度相比是否足够小。\n\n您的实现必须是自包含的，并对以下参数值测试套件进行操作。对于每个测试用例，完全按照指定构建 $L$ 网格和区间：\n\n- 测试用例 1 (一般情况):\n  - $f_{\\mathrm{sky}} = 0.4$\n  - $A_{\\phi} = 1.0 \\times 10^{-7}$\n  - $L_d = 200$\n  - $N_0 = 5.0 \\times 10^{-8}$\n  - $L_0 = 150$\n  - $\\alpha_1 = 0.1$\n  - 多极矩范围: $L \\in \\{10, 11, \\dots, 300\\}$\n  - 区间: 8个等宽区间，将整个范围 $[10,300]$ 划分为不相交的连续整数区间。\n  - 蒙特卡洛实现: $6000$\n\n- 测试用例 2 (边界情况：小天区覆盖率):\n  - $f_{\\mathrm{sky}} = 0.05$\n  - $A_{\\phi} = 1.2 \\times 10^{-7}$\n  - $L_d = 300$\n  - $N_0 = 1.0 \\times 10^{-7}$\n  - $L_0 = 100$\n  - $\\alpha_1 = 0.2$\n  - 多极矩范围: $L \\in \\{20, 21, \\dots, 400\\}$\n  - 区间: 10个等宽区间，将整个范围 $[20,400]$ 划分为不相交的连续整数区间。\n  - 蒙特卡洛实现: $8000$\n\n- 测试用例 3 (边缘情况：单-$L$ 区间，噪声主导，无 $N^{(1)}$):\n  - $f_{\\mathrm{sky}} = 0.7$\n  - $A_{\\phi} = 8.0 \\times 10^{-8}$\n  - $L_d = 80$\n  - $N_0 = 3.0 \\times 10^{-7}$\n  - $L_0 = 120$\n  - $\\alpha_1 = 0.0$\n  - 多极矩集合: $L \\in \\{20, 60, 100\\}$\n  - 区间: 三个区间，每个区间仅包含一个指定的多极矩: $[20,20]$, $[60,60]$, $[100,100]$。\n  - 蒙特卡洛实现: $20000$\n\n每个测试用例的验证标准:\n- 根据指定的近似和模型计算解析带功率协方差矩阵。\n- 从带功率的蒙特卡洛系综中计算样本协方差矩阵。\n- 令 $\\Delta_{\\mathrm{diag}}$ 为解析方差与蒙特卡洛方差之间在所有区间上的最大相对偏差，定义为 $\\left| \\mathrm{Var}_{\\mathrm{MC}}(b) - \\mathrm{Var}_{\\mathrm{ana}}(b) \\right| / \\mathrm{Var}_{\\mathrm{ana}}(b)$ 在所有区间上的最大值。\n- 令 $\\Delta_{\\mathrm{off}}$ 为蒙特卡洛协方差的最大绝对非对角元素除以解析对角方差的平均值。\n- 如果 $\\Delta_{\\mathrm{diag}} \\le 0.12$ 且 $\\Delta_{\\mathrm{off}} \\le 0.10$，则测试用例通过。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），每个结果都是一个布尔值，指示相应的测试用例是否在指定标准下通过。不涉及物理单位；所有量均为无量纲。不使用角度。", "solution": "该问题要求在标准二次估计框架内，并采用数值宇宙学中的几种常见近似，推导和验证宇宙微波背景（CMB）引力透镜势功率谱的带功率估计 $\\hat{C}_b^{\\phi\\phi}$ 的协方差。\n\n首先，我们为构成每个多极矩 $L$ 上总重建功率谱的信号和噪声分量定义理论模型。真实的引力透镜势功率谱由下式给出\n$$C_L^{\\phi\\phi} = \\frac{A_{\\phi} \\exp(-L/L_d)}{L(L+1)} \\quad \\text{for } L \\ge 2,$$\n其中当 $L  2$ 时 $C_L^{\\phi\\phi} = 0$。重建过程引入了噪声，其由两个主要分量建模：高斯非关联噪声偏差 $N_L^{(0)}$ 和关联非高斯偏差 $N_L^{(1)}$。它们的函数形式为：\n$$N_L^{(0)} = N_0 \\left[1 + \\left(\\frac{L}{L_0}\\right)^2\\right]$$\n$$N_L^{(1)} = \\alpha_1 C_L^{\\phi\\phi}$$\n在单个多极矩 $L$ 上的功率谱估计量，记作 $\\hat{C}_L$，是一个随机变量，其期望值是真实信号与所有偏差项之和。这是总重建功率 $C_L^{\\mathrm{tot}}$：\n$$\\langle \\hat{C}_L \\rangle = C_L^{\\mathrm{tot}} = C_L^{\\phi\\phi} + N_L^{(0)} + N_L^{(1)} = (1 + \\alpha_1)C_L^{\\phi\\phi} + N_L^{(0)}$$\n\n在基础CMB场为高斯场的假设下，对于大量模式，估计量 $\\hat{C}_L$ 近似服从高斯分布。$\\hat{C}_L$ 的方差由总功率 $C_L^{\\mathrm{tot}}$ 和该多极矩可用的独立模式数决定。对于全天观测，有 $2L+1$ 个模式。对于覆盖天区比例为 $f_{\\mathrm{sky}}$ 的观测，有效模式数减少到 $(2L+1)f_{\\mathrm{sky}}$。因此，估计量的方差由标准功率谱方差公式给出，并根据天区覆盖率进行调整：\n$$\\mathrm{Var}(\\hat{C}_L) = \\frac{2}{(2L+1)f_{\\mathrm{sky}}} (C_L^{\\mathrm{tot}})^2$$\n该框架中的一个关键假设是不同多极矩 $L$ 和 $L'$ 处的估计量是不相关的。当忽略掩模引起的模式耦合时，这是一个很好的近似。因此，我们可以将多极矩估计量的协方差写为：\n$$\\mathrm{Cov}(\\hat{C}_L, \\hat{C}_{L'}) = \\delta_{LL'} \\mathrm{Var}(\\hat{C}_L)$$\n其中 $\\delta_{LL'}$ 是克罗内克δ符号。\n\n为了减小方差，带功率是通过在 $L$ 空间的不相交区间（bins）上平均多极矩估计量来构建的。对于一个给定的区间 $b$，它包含一个由 $N_b = |\\mathcal{L}_b|$ 个成员组成的多极矩集合 $\\mathcal{L}_b$，带功率估计量 $\\hat{C}_b$ 定义为简单平均值：\n$$\\hat{C}_b = \\frac{1}{N_b} \\sum_{L \\in \\mathcal{L}_b} \\hat{C}_L$$\n两个带功率估计量 $\\hat{C}_b$ 和 $\\hat{C}_{b'}$ 之间的协方差可以使用协方差算符的线性性质推导得出：\n$$\\mathrm{Cov}(\\hat{C}_b, \\hat{C}_{b'}) = \\mathrm{Cov}\\left( \\frac{1}{N_b} \\sum_{L \\in \\mathcal{L}_b} \\hat{C}_L, \\frac{1}{N_{b'}} \\sum_{L' \\in \\mathcal{L}_{b'}} \\hat{C}_{L'} \\right)$$\n$$= \\frac{1}{N_b N_{b'}} \\sum_{L \\in \\mathcal{L}_b} \\sum_{L' \\in \\mathcal{L}_{b'}} \\mathrm{Cov}(\\hat{C}_L, \\hat{C}_{L'})$$\n代入 $\\mathrm{Cov}(\\hat{C}_L, \\hat{C}_{L'})$ 的表达式：\n$$\\mathrm{Cov}(\\hat{C}_b, \\hat{C}_{b'}) = \\frac{1}{N_b N_{b'}} \\sum_{L \\in \\mathcal{L}_b} \\sum_{L' \\in \\mathcal{L}_{b'}} \\delta_{LL'} \\mathrm{Var}(\\hat{C}_L)$$\n此表达式的分析根据区间是否相同分为两种情况。\n\n情况1：非对角元素 ($b \\neq b'$).\n问题指定区间是不相交的，即 $\\mathcal{L}_b \\cap \\mathcal{L}_{b'} = \\emptyset$。在双重求和中，由克罗内克δ符号施加的条件 $L = L'$ 永远无法满足，因为 $L$ 来自 $\\mathcal{L}_b$，$L'$ 来自 $\\mathcal{L}_{b'}$，它们没有共同元素。因此，求和中的每一项都为零。\n$$\\mathrm{Cov}(\\hat{C}_b, \\hat{C}_{b'}) = 0 \\quad \\text{for } b \\neq b'$$\n在这些假设下，解析的带功率协方差矩阵是对角的。\n\n情况2：对角元素 ($b = b'$).\n这给出了带功率估计量 $\\hat{C}_b$ 的方差。这里，$b' = b$，所以 $\\mathcal{L}_{b'} = \\mathcal{L}_b$ 且 $N_{b'} = N_b$。双重求和坍缩为单个求和：\n$$\\mathrm{Var}(\\hat{C}_b) = \\mathrm{Cov}(\\hat{C}_b, \\hat{C}_b) = \\frac{1}{N_b^2} \\sum_{L \\in \\mathcal{L}_b} \\sum_{L' \\in \\mathcal{L}_b} \\delta_{LL'} \\mathrm{Var}(\\hat{C}_L) = \\frac{1}{N_b^2} \\sum_{L \\in \\mathcal{L}_b} \\mathrm{Var}(\\hat{C}_L)$$\n代入 $\\mathrm{Var}(\\hat{C}_L)$ 的公式，我们得到解析带功率方差的最终表达式：\n$$\\mathrm{Var}_{\\mathrm{ana}}(b) = \\mathrm{Var}(\\hat{C}_b) = \\frac{1}{N_b^2} \\sum_{L \\in \\mathcal{L}_b} \\frac{2}{(2L+1)f_{\\mathrm{sky}}} \\left((1 + \\alpha_1)C_L^{\\phi\\phi} + N_L^{(0)}\\right)^2$$\n\n为了验证这一解析结果，需要执行蒙特卡洛模拟。这包括以下步骤：\n1. 对于指定网格上的每个多极矩 $L$，计算估计量的均值 $C_L^{\\mathrm{tot}}$ 和方差 $\\mathrm{Var}(\\hat{C}_L)$。\n2. 生成一个包含 $N_{\\mathrm{MC}}$ 个实现的大系综，其中每个实现都是完整的多极矩估计量集合 $\\{\\hat{C}_L\\}$。对于每个实现 $i$ 和每个多极矩 $L$，从一个独立的、均值为 $\\mu=C_L^{\\mathrm{tot}}$、方差为 $\\sigma^2=\\mathrm{Var}(\\hat{C}_L)$ 的正态分布 $\\mathcal{N}$ 中抽取一个值 $\\hat{C}_{L,i}$。\n3. 对于 $N_{\\mathrm{MC}}$ 个实现中的每一个，通过对各自区间内的模拟 $\\hat{C}_{L,i}$ 值进行平均，计算带功率向量 $\\{\\hat{C}_{b,i}\\}$。\n4. 从 $N_{\\mathrm{MC}}$ 个带功率向量的系综中，计算样本协方差矩阵 $\\mathrm{Cov}_{\\mathrm{MC}}(b, b')$。对于一组带功率向量 $\\{\\mathbf{v}_i\\}_{i=1}^{N_{\\mathrm{MC}}}$，其中 $\\mathbf{v}_i = (\\hat{C}_{1,i}, \\dots, \\hat{C}_{N_{\\text{bins}},i})$，样本协方差通过标准统计方法计算，通常使用无偏估计量。\n\n验证过程包括将解析推导的对角协方差矩阵与蒙特卡洛模拟得出的样本协方差矩阵进行比较。\n- 对角元素（方差）通过最大相对偏差进行比较，$\\Delta_{\\mathrm{diag}} = \\max_{b} |\\mathrm{Var}_{\\mathrm{MC}}(b) - \\mathrm{Var}_{\\mathrm{ana}}(b)| / \\mathrm{Var}_{\\mathrm{ana}}(b)$。这用于检验方差公式的准确性。\n- 解析协方差的非对角元素为零。由于其有限的规模，蒙特卡洛模拟将产生微小但非零的非对角元素。它们的大小通过 $\\Delta_{\\mathrm{off}}$ 进行评估，即 $\\mathrm{Cov}_{\\mathrm{MC}}$ 的最大绝对非对角元素，并用平均解析方差进行归一化。这用于检验多极矩独立性假设的有效性。\n\n如果 $\\Delta_{\\mathrm{diag}}$ 和 $\\Delta_{\\mathrm{off}}$ 都低于各自的阈值，则认为解析模型及其所依据的假设在给定参数下得到验证。", "answer": "```python\nimport numpy as np\nfrom scipy.special import xlogy # Not strictly needed, but can avoid warnings for L(L+1)\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases for CMB lensing bandpower covariance validation.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (general case)\n        {\n            \"f_sky\": 0.4, \"A_phi\": 1.0e-7, \"L_d\": 200, \"N_0\": 5.0e-8,\n            \"L_0\": 150, \"alpha_1\": 0.1, \"L_min\": 10, \"L_max\": 300,\n            \"n_bins\": 8, \"n_mc\": 6000\n        },\n        # Test Case 2 (boundary: small sky fraction)\n        {\n            \"f_sky\": 0.05, \"A_phi\": 1.2e-7, \"L_d\": 300, \"N_0\": 1.0e-7,\n            \"L_0\": 100, \"alpha_1\": 0.2, \"L_min\": 20, \"L_max\": 400,\n            \"n_bins\": 10, \"n_mc\": 8000\n        },\n        # Test Case 3 (edge case: single-L bins, noise dominated, no N(1))\n        {\n            \"f_sky\": 0.7, \"A_phi\": 8.0e-8, \"L_d\": 80, \"N_0\": 3.0e-7,\n            \"L_0\": 120, \"alpha_1\": 0.0, \"Ls\": np.array([20, 60, 100]),\n            \"n_bins\": 3, \"n_mc\": 20000\n        }\n    ]\n\n    results = []\n    \n    # Custom seed for reproducibility\n    # Using np.random.RandomState for compatibility with older numpy versions\n    # although default_rng is preferred in modern numpy. `np.random` functions are also fine.\n    rng = np.random.RandomState(seed=12345)\n\n    for case in test_cases:\n        # 1. Setup Models and Multipole Grid\n        f_sky = case[\"f_sky\"]\n        \n        # Define power spectrum and noise models\n        def c_l_phi_phi(L, A_phi, L_d):\n            # The model is for L = 2. The provided L ranges satisfy this.\n            return A_phi * np.exp(-L / L_d) / (L * (L + 1))\n\n        def n_l_0(L, N_0, L_0):\n            return N_0 * (1 + (L / L_0)**2)\n\n        if \"Ls\" in case: # Case 3 with an explicit list of Ls\n            L_grid = case[\"Ls\"]\n            bins = [[L] for L in L_grid]\n        else: # Cases 1 and 2 with L ranges and binning\n            L_min, L_max, n_bins = case[\"L_min\"], case[\"L_max\"], case[\"n_bins\"]\n            L_grid = np.arange(L_min, L_max + 1)\n            \n            # Partition L_grid into n_bins\n            n_L = len(L_grid)\n            base_width = n_L // n_bins\n            remainder = n_L % n_bins\n            \n            bin_sizes = [base_width + 1] * remainder + [base_width] * (n_bins - remainder)\n            \n            bins = []\n            current_idx = 0\n            for size in bin_sizes:\n                bins.append(L_grid[current_idx : current_idx + size])\n                current_idx += size\n        \n        A_phi, L_d = case[\"A_phi\"], case[\"L_d\"]\n        N_0, L_0 = case[\"N_0\"], case[\"L_0\"]\n        alpha_1 = case[\"alpha_1\"]\n\n        cl_phi_phi_vals = c_l_phi_phi(L_grid, A_phi, L_d)\n        nl0_vals = n_l_0(L_grid, N_0, L_0)\n        \n        cl_tot = (1 + alpha_1) * cl_phi_phi_vals + nl0_vals\n        var_cl = 2 * cl_tot**2 / ((2 * L_grid + 1) * f_sky)\n\n        # 2. Analytic Bandpower Covariance\n        analytic_variances = np.zeros(len(bins))\n        for i, bin_L_values in enumerate(bins):\n            N_b = len(bin_L_values)\n            # Find indices of L_values in the full L_grid\n            indices = np.where(np.isin(L_grid, bin_L_values))[0]\n            \n            # Sum variances of C_L within the bin\n            sum_var_cl = np.sum(var_cl[indices])\n            analytic_variances[i] = sum_var_cl / (N_b**2)\n\n        # 3. Monte Carlo Validation\n        n_mc = case[\"n_mc\"]\n        \n        # Generate all MC realizations for all L's at once\n        mc_cl_realizations = rng.normal(loc=cl_tot, scale=np.sqrt(var_cl), size=(n_mc, len(L_grid)))\n        \n        # Calculate bandpowers for each realization\n        mc_bandpowers = np.zeros((n_mc, len(bins)))\n        for i, bin_L_values in enumerate(bins):\n            indices = np.where(np.isin(L_grid, bin_L_values))[0]\n            # Average over the C_L realizations in the bin\n            mc_bandpowers[:, i] = np.mean(mc_cl_realizations[:, indices], axis=1)\n            \n        # Calculate the sample covariance matrix\n        # rowvar=False because each column is a variable (a bin), and each row is an observation\n        mc_cov = np.cov(mc_bandpowers, rowvar=False)\n\n        # 4. Comparison and Validation\n        mc_variances = np.diag(mc_cov)\n        \n        # Delta_diag: Max relative deviation of variances\n        delta_diag = np.max(np.abs(mc_variances - analytic_variances) / analytic_variances)\n        \n        # Delta_off: Max absolute off-diagonal element of MC cov, normalized\n        # Set diagonal to zero to easily find max off-diagonal element\n        off_diag_mc_cov = mc_cov.copy()\n        np.fill_diagonal(off_diag_mc_cov, 0)\n        max_abs_off_diag = np.max(np.abs(off_diag_mc_cov))\n        mean_analytic_var = np.mean(analytic_variances)\n        \n        # Handle case where mean_analytic_var could be zero (unlikely but safe)\n        delta_off = max_abs_off_diag / mean_analytic_var if mean_analytic_var > 0 else 0\n\n        # Check against validation criteria\n        diag_passed = delta_diag = 0.12\n        off_diag_passed = delta_off = 0.10\n        \n        results.append(diag_passed and off_diag_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r for r in results]))}]\")\n\nsolve()\n```", "id": "3467597"}, {"introduction": "除了统计误差，真实的分析流程还会受到来自数值近似的系统误差的影响。本练习探讨了在实际的全天（full-sky）HEALPix像素化方案中，两种常见的数值系统效应：球谐变换的有限精度以及有限的谱带宽度限制（band-limit）[@problem_id:3467581]。通过解析推导，你将量化这些效应对最终透镜功率谱幅度$A_{L}$测量结果的偏见，这对于确保科学结论的稳健性和准确性至关重要。", "problem": "您正在使用二次估计器，在一种高分辨率等面积等纬度像素化 (HEALPix) 的图上，实现宇宙微波背景 (CMB) 温度的全天引力透镜重建。设 HEALPix 分辨率为 $N_{\\text{side}}$，并假设仪器波束是一个半峰全宽为 $\\theta_{\\text{FWHM}}$ 的圆形高斯函数。球谐变换 (SHT) 在有限的带限 $\\ell_{\\max} = 3 N_{\\text{side}} - 1$ 下执行。您将估计透镜势功率谱，并用 $A_{L}$ 对其振幅进行参数化，其定义满足 $C_{L}^{\\phi\\phi,\\text{true}} = A_{L}\\,C_{L}^{\\phi\\phi,\\text{fid}}$。您的流程对估计器响应使用连续、无限带限的解析归一化，且该归一化中没有明确包含像素窗函数。\n\n仅使用以下基本依据和假设来推导所需的表达式，不要引入任何预先推导的透镜归一化公式：\n- 二次估计器作用于经过滤波的 CMB 场的球谐系数，其对真实透镜势的平均响应与这些系数的加权二次组合成线性关系。\n- 一个施加于所有输入球谐系数 $a_{\\ell m}$ 上的均匀乘性误差 $1+\\epsilon$ 会以乘法方式通过二次估计器传播。\n- 一个标准差为 $\\sigma_{b} = \\theta_{\\text{FWHM}}/\\sqrt{8\\ln 2}$ 的圆形高斯波束会以 $\\exp\\!\\left[-\\frac{1}{2}\\ell(\\ell+1)\\sigma_{b}^{2}\\right]$ 的形式衰减多极矩，在高 $\\ell$ 值下，您可以将其近似为 $\\exp\\!\\left[-\\ell^{2}\\sigma_{b}^{2}\\right]$。\n- HEALPix 像素窗函数在高 $\\ell$ 值下可以近似为一个标准差为 $\\sigma_{\\text{pix}} = \\theta_{\\text{pix}}/\\sqrt{8\\ln 2}$ 的高斯函数，其中 $\\theta_{\\text{pix}} = \\sqrt{A_{\\text{pix}}}$ 且 $A_{\\text{pix}} = 4\\pi/(12 N_{\\text{side}}^{2}) = \\pi/(3N_{\\text{side}}^{2})$。使用相同的高 $\\ell$ 近似，因此组合平滑效应为 $\\exp\\!\\left[-\\ell^{2}\\sigma_{\\text{eff}}^{2}\\right]$，其中 $\\sigma_{\\text{eff}}^{2} = \\sigma_{b}^{2} + \\sigma_{\\text{pix}}^{2}$。\n- 在此设置中，对于主导估计器响应的高 $\\ell$ 值，您可以将连续极限下的各向同性响应权重建模为与 $\\int_{0}^{\\infty} \\ell \\,\\exp(-\\sigma_{\\text{eff}}^{2}\\ell^{2})\\,\\mathrm{d}\\ell$ 成正比。在数值实现中，位于 $\\ell_{\\max}$ 的有限 SHT 带限会将此积分截断于 $\\ell_{\\max}$。\n- 所有角度均使用弧度。\n\n任务：\n1) 仅利用误差通过乘积的乘法传播特性，推导施加于所有 $a_{\\ell m}$ 上的均匀 SHT 乘性误差 $1+\\epsilon$ 在 $A_{L}$ 中引起的一阶分数偏差。施加要求，即仅由此来源引起的分数偏差绝对值小于 $1.0\\times 10^{-3}$，并计算相应的最大允许值 $|\\epsilon|$。将最终答案表示为一个纯数（无单位），并四舍五入到两位有效数字。\n\n2) 在上述带限不匹配的情况下（理论归一化假设为连续无限极限，而数值实现则在 $\\ell_{\\max}$ 处截断并包含波束和平滑像素化效应），推导 $A_{L}$ 中分数乘性偏差的解析表达式，该偏差定义为 $\\Delta A_{L}/A_{L} \\equiv A_{L}^{\\text{rec}}/A_{L}^{\\text{true}} - 1$，并用 $\\sigma_{\\text{eff}}$ 和 $\\ell_{\\max}$ 表示。然后，对于 $N_{\\text{side}} = 2048$，$\\ell_{\\max} = 3 N_{\\text{side}} - 1$ 和 $\\theta_{\\text{FWHM}} = 1.4$ 角分，对其进行数值计算。将结果报告为一个纯数（无单位），并四舍五入到三位有效数字。\n\n使用上述的 $\\ell_{\\max}$，以行矩阵 $\\big[\\,|\\epsilon|_{\\max}\\,,\\,\\Delta A_{L}/A_{L}\\,\\big]$ 的形式报告您的最终答案。不需要其他输出。", "solution": "该问题分为两个部分。第一部分处理输入 CMB 数据中系统性乘性误差的传播，第二部分处理估计器归一化的理论模型与其数值实现之间的不匹配所引起的系统性偏差。\n\n**第 1 部分：SHT 乘性误差引起的偏差**\n\n令观测到的 CMB 图（包括波束、像素化和噪声）的球谐系数表示为 $a_{\\ell m}$。透镜二次估计器通过这些系数的二次组合重建透镜势 $\\phi$。原始重建势 $\\hat{\\phi}_{LM}^{\\text{raw}}$ 可示意性地写为：\n$$\n\\hat{\\phi}_{LM}^{\\text{raw}} \\sim \\sum_{\\ell_1, m_1, \\ell_2, m_2} W_{\\ell_1 m_1 \\ell_2 m_2}^{LM} a_{\\ell_1 m_1} a_{\\ell_2 m_2}\n$$\n其中 $W$ 代表包括 Clebsch-Gordan 系数在内的适当权重。\n\n问题陈述指出，一个均匀的乘性误差被施加到所有输入系数上，使得估计器中使用的系数为 $a'_{\\ell m} = (1+\\epsilon) a_{\\ell m}$。将此代入估计器可得：\n$$\n\\hat{\\phi}_{LM}^{\\text{raw, biased}} \\sim \\sum W (...) [(1+\\epsilon)a_{\\ell_1 m_1}] [(1+\\epsilon)a_{\\ell_2 m_2}] = (1+\\epsilon)^2 \\hat{\\phi}_{LM}^{\\text{raw}}\n$$\n因此，原始重建势图存在一个因子为 $(1+\\epsilon)^2$ 的偏差。\n\n分析流程接着计算该图的功率谱。一般的功率谱估计涉及从原始图的功率中减去一个噪声偏差 $N_L^{(0)}$。噪声偏差本身是由输入数据构建的，通常涉及四阶矩（在高斯情况下为两点函数的乘积）。在功率谱估计中，无论是信号部分还是噪声偏差项，任何一项都将是输入系数 $a_{\\ell m}$ 的四次函数。因此，在变换 $a_{\\ell m} \\to (1+\\epsilon) a_{\\ell m}$下，功率谱计算中的每一项都会按 $(1+\\epsilon)^4$ 的比例缩放。\n估计的功率谱为：\n$$\n\\hat{C}_{L}^{\\phi\\phi, \\text{rec}} = (1+\\epsilon)^4 \\hat{C}_{L}^{\\phi\\phi, \\text{true}}\n$$\n其中 $\\hat{C}_{L}^{\\phi\\phi, \\text{rec}}$ 是有偏差的流程返回的最终、已减去噪声的功率谱，而 $\\hat{C}_{L}^{\\phi\\phi, \\text{true}}$ 是在 $\\epsilon=0$ 时会得到的值。\n\n透镜振幅参数 $A_L$ 是通过将重建的功率谱与一个基准模型 $C_{L}^{\\phi\\phi, \\text{fid}}$进行比较来确定的。重建的振幅 $A_L^{\\text{rec}}$ 与重建的功率谱成正比。因此，它继承了相同的乘性偏差：\n$$\nA_L^{\\text{rec}} = (1+\\epsilon)^4 A_L^{\\text{true}}\n$$\n$A_L$ 中的分数偏差定义为 $\\Delta A_L / A_L = A_L^{\\text{rec}} / A_L^{\\text{true}} - 1$。\n$$\n\\frac{\\Delta A_L}{A_L} = (1+\\epsilon)^4 - 1\n$$\n对于一阶分数偏差，我们对小 $\\epsilon$ 展开此表达式：\n$$\n\\frac{\\Delta A_L}{A_L} = (1 + 4\\epsilon + O(\\epsilon^2)) - 1 \\approx 4\\epsilon\n$$\n我们被给予要求，即绝对分数偏差必须小于 $1.0 \\times 10^{-3}$：\n$$\n\\left| \\frac{\\Delta A_L}{A_L} \\right| \\approx |4\\epsilon|  1.0 \\times 10^{-3}\n$$\n求解 $\\epsilon$ 的最大允许量级：\n$$\n|\\epsilon|  \\frac{1.0 \\times 10^{-3}}{4} = 0.25 \\times 10^{-3} = 2.5 \\times 10^{-4}\n$$\n因此，SHT 误差的最大允许绝对值为 $|\\epsilon|_{\\max} = 2.5 \\times 10^{-4}$。\n\n**第 2 部分：带限不匹配引起的偏差**\n\n这种偏差的产生是因为估计器响应的解析归一化是在假设无限 SHT 带限的情况下计算的，而实际的数值实现则在 $\\ell_{\\max}$ 处被截断。\n\n理论响应 $R_{\\text{theory}}$ 与权重函数在所有多极矩上的积分成正比：\n$$\nR_{\\text{theory}} \\propto \\int_{0}^{\\infty} \\ell \\,\\exp(-\\sigma_{\\text{eff}}^{2}\\ell^{2})\\,\\mathrm{d}\\ell\n$$\n数值流程的实际响应 $R_{\\text{actual}}$ 与相同的积分成正比，但在 $\\ell_{\\max}$ 处截断：\n$$\nR_{\\text{actual}} \\propto \\int_{0}^{\\ell_{\\max}} \\ell \\,\\exp(-\\sigma_{\\text{eff}}^{2}\\ell^{2})\\,\\mathrm{d}\\ell\n$$\n流程通过除以 $R_{\\text{theory}}$ 来归一化重建的势。然而，估计器的真实响应是 $R_{\\text{actual}}$。这种不匹配引入了偏差。正确归一化的势应为 $\\hat{\\phi}_{\\text{norm}} = \\hat{\\phi}_{\\text{raw}}/R_{\\text{actual}}$。而流程计算的却是 $\\hat{\\phi}_{\\text{pipe}} = \\hat{\\phi}_{\\text{raw}}/R_{\\text{theory}}$。因此，流程输出的期望值为：\n$$\n\\langle \\hat{\\phi}_{\\text{pipe}} \\rangle = \\frac{\\langle \\hat{\\phi}_{\\text{raw}} \\rangle}{R_{\\text{theory}}} = \\frac{R_{\\text{actual}}}{R_{\\text{theory}}} \\phi^{\\text{true}}\n$$\n重建的功率谱与势振幅的平方成比例。因此，重建的振幅参数 $A_L^{\\text{rec}}$ 相对于真实振幅 $A_L^{\\text{true}}$ 的偏差为该比率的平方：\n$$\n\\frac{A_L^{\\text{rec}}}{A_L^{\\text{true}}} = \\left(\\frac{R_{\\text{actual}}}{R_{\\text{theory}}}\\right)^2\n$$\n分数偏差为：\n$$\n\\frac{\\Delta A_L}{A_L} = \\frac{A_L^{\\text{rec}}}{A_L^{\\text{true}}} - 1 = \\left(\\frac{R_{\\text{actual}}}{R_{\\text{theory}}}\\right)^2 - 1\n$$\n为了评估它，我们计算这些积分。令 $u = \\ell^2$。则 $\\mathrm{d}u = 2\\ell\\,\\mathrm{d}\\ell$。\n$$\nR_{\\text{theory}} \\propto \\int_{0}^{\\infty} \\frac{1}{2} \\exp(-\\sigma_{\\text{eff}}^{2} u)\\,\\mathrm{d}u = \\frac{1}{2} \\left[ -\\frac{1}{\\sigma_{\\text{eff}}^2} \\exp(-\\sigma_{\\text{eff}}^{2}u) \\right]_0^{\\infty} = \\frac{1}{2\\sigma_{\\text{eff}}^2}\n$$\n$$\nR_{\\text{actual}} \\propto \\int_{0}^{\\ell_{\\max}^2} \\frac{1}{2} \\exp(-\\sigma_{\\text{eff}}^{2} u)\\,\\mathrm{d}u = \\frac{1}{2} \\left[ -\\frac{1}{\\sigma_{\\text{eff}}^2} \\exp(-\\sigma_{\\text{eff}}^{2}u) \\right]_0^{\\ell_{\\max}^2} = \\frac{1 - \\exp(-\\sigma_{\\text{eff}}^2\\ell_{\\max}^2)}{2\\sigma_{\\text{eff}}^2}\n$$\n响应的比率为：\n$$\n\\frac{R_{\\text{actual}}}{R_{\\text{theory}}} = 1 - \\exp(-\\sigma_{\\text{eff}}^2\\ell_{\\max}^2)\n$$\n将此代入偏差表达式，我们得到分数偏差的解析形式：\n$$\n\\frac{\\Delta A_L}{A_L} = \\left(1 - \\exp(-\\sigma_{\\text{eff}}^2\\ell_{\\max}^2)\\right)^2 - 1\n$$\n现在，我们针对给定的参数进行评估。\n- $N_{\\text{side}} = 2048$\n- $\\ell_{\\max} = 3 N_{\\text{side}} - 1 = 3(2048) - 1 = 6143$\n- $\\theta_{\\text{FWHM}} = 1.4$ 角分。我们将其转换为弧度：\n  $\\theta_{\\text{FWHM}} = 1.4 \\text{ arcmin} \\times \\frac{1^{\\circ}}{60 \\text{ arcmin}} \\times \\frac{\\pi \\text{ rad}}{180^{\\circ}} = \\frac{1.4\\pi}{10800} \\text{ rad} \\approx 4.0715 \\times 10^{-4} \\text{ rad}$。\n\n总有效平滑方差 $\\sigma_{\\text{eff}}^2 = \\sigma_b^2 + \\sigma_{\\text{pix}}^2$ 由下式给出：\n$$\n\\sigma_{\\text{eff}}^2 = \\frac{\\theta_{\\text{FWHM}}^2}{8\\ln 2} + \\frac{A_{\\text{pix}}}{8\\ln 2} = \\frac{1}{8\\ln 2} \\left( \\theta_{\\text{FWHM}}^2 + A_{\\text{pix}} \\right)\n$$\n其中 $A_{\\text{pix}} = \\frac{\\pi}{3N_{\\text{side}}^2}$。\n让我们计算数值：\n$$\n\\theta_{\\text{FWHM}}^2 = \\left(\\frac{1.4\\pi}{10800}\\right)^2 \\approx 1.6577 \\times 10^{-7} \\text{ rad}^2\n$$\n$$\nA_{\\text{pix}} = \\frac{\\pi}{3(2048)^2} \\approx \\frac{\\pi}{12582912} \\approx 2.4967 \\times 10^{-7} \\text{ rad}^2\n$$\n常数 $8\\ln 2 \\approx 5.5452$。\n$$\n\\sigma_{\\text{eff}}^2 = \\frac{1.6577 \\times 10^{-7} + 2.4967 \\times 10^{-7}}{5.5452} = \\frac{4.1544 \\times 10^{-7}}{5.5452} \\approx 7.4920 \\times 10^{-8}\n$$\n现在我们计算指数的参数：\n$$\n\\sigma_{\\text{eff}}^2\\ell_{\\max}^2 \\approx (7.4920 \\times 10^{-8}) \\times (6143)^2 \\approx (7.4920 \\times 10^{-8}) \\times (3.7736 \\times 10^7) \\approx 2.8270\n$$\n最后，我们计算分数偏差：\n$$\n\\frac{\\Delta A_L}{A_L} = \\left(1 - \\exp(-2.8270)\\right)^2 - 1 = (1 - 0.05919)^2 - 1 = (0.94081)^2 - 1 \\approx 0.88512 - 1 = -0.11488\n$$\n四舍五入到三位有效数字，分数偏差为 $-0.115$。\n\n最终答案由最大允许绝对误差 $|\\epsilon|_{\\max}$ 和分数偏差 $\\Delta A_L/A_L$ 组成。\n$|\\epsilon|_{\\max} = 2.5 \\times 10^{-4}$（四舍五入到两位有效数字）。\n$\\Delta A_L/A_L = -0.115$（四舍五入到三位有效数字）。", "answer": "$$\n\\boxed{\\begin{bmatrix} 2.5 \\times 10^{-4}  -0.115 \\end{bmatrix}}\n$$", "id": "3467581"}]}