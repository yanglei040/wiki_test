{"hands_on_practices": [{"introduction": "动手实践的第一步是模拟光线追踪的基本任务：计算光线穿过单个透镜平面的路径。我们将使用现代宇宙学中描述暗物质晕的标准模型——Navarro–Frenk–White (NFW) 轮廓。这项练习 ([@problem_id:3483287]) 将指导你从一个解析轮廓创建一个像素化的收敛度 $\\kappa$ 图，并量化由双线性插值引入的数值误差，这是评估透镜代码准确性的关键技能。", "problem": "考虑一个由质量和聚集度参数 $(M_{200},c)$ 定义的解析 Navarro–Frenk–White (NFW) 晕构成的单一透镜平面。在一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙学框架下进行计算，其中物质密度参数为 $\\Omega_{\\mathrm{m}}$，暗能量密度参数为 $\\Omega_{\\Lambda}$，哈勃参数为 $H_0$。将透镜置于红移 $z_{\\mathrm{d}}$ 处，源置于红移 $z_{\\mathrm{s}}$ 处。您的任务是将解析 NFW 剖面嵌入到一个像素化的密度场中，使用双线性插值对生成的会聚图进行光线追迹，并通过与在相同光线位置评估的精确解析会聚值进行比较，来量化插值引起的偏差。\n\n使用以下基本定律和经过充分检验的公式作为基础：\n- 在平坦宇宙中，角直径距离为 $D_{\\mathrm{A}}(z) = \\chi(z)/(1+z)$，其中 $\\chi(z) = \\int_0^z \\frac{c}{H(z')} \\, \\mathrm{d}z'$ 是共动距离， $c$ 是光速， $H(z) = H_0 \\sqrt{\\Omega_{\\mathrm{m}}(1+z)^3 + \\Omega_{\\Lambda}}$。\n- 临界表面密度为 $\\Sigma_{\\mathrm{crit}} = \\frac{c^2}{4\\pi G} \\frac{D_{\\mathrm{s}}}{D_{\\mathrm{d}} D_{\\mathrm{ds}}}$，其中 $D_{\\mathrm{d}} = D_{\\mathrm{A}}(z_{\\mathrm{d}})$，$D_{\\mathrm{s}} = D_{\\mathrm{A}}(z_{\\mathrm{s}})$，以及 $D_{\\mathrm{ds}} = \\frac{\\chi(z_{\\mathrm{s}})-\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{s}}}$。\n- NFW 三维质量剖面通过 $M_{200} = \\frac{4\\pi}{3} 200 \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}}) r_{200}^3$ 定义 $r_{200}$，其中 $\\rho_{\\mathrm{crit}}(z) = \\frac{3 H(z)^2}{8\\pi G}$，且 $r_{\\mathrm{s}} = r_{200}/c$。特征密度为 $\\rho_{\\mathrm{s}} = \\frac{M_{200}}{4\\pi r_{\\mathrm{s}}^3 [\\ln(1+c) - c/(1+c)]}$。\n- 在投影半径 $R$ 处的 NFW 投影表面密度 $\\Sigma(R)$ 可以写为 $\\Sigma(R) = 2 \\rho_{\\mathrm{s}} r_{\\mathrm{s}} f(x)$，其中 $x=R/r_{\\mathrm{s}}$ 且\n$$\nf(x) =\n\\begin{cases}\n\\dfrac{1 - \\frac{2}{\\sqrt{1-x^2}} \\operatorname{arctanh}\\left(\\sqrt{\\frac{1-x}{1+x}}\\right)}{x^2 - 1},  0 \\le x  1, \\\\\n\\dfrac{1}{3},  x=1, \\\\\n\\dfrac{1 - \\frac{2}{\\sqrt{x^2-1}} \\arctan\\left(\\sqrt{\\frac{x-1}{x+1}}\\right)}{x^2 - 1},  x  1,\n\\end{cases}\n$$\n且会聚（无量纲表面质量密度）为 $\\kappa(R) = \\Sigma(R)/\\Sigma_{\\mathrm{crit}}$。\n\n您的任务：\n1. 使用上述基本公式，推导计算 NFW 晕的 $D_{\\mathrm{d}}$、$D_{\\mathrm{s}}$、$D_{\\mathrm{ds}}$、$\\Sigma_{\\mathrm{crit}}$、$r_{200}$、$r_{\\mathrm{s}}$、$\\rho_{\\mathrm{s}}$ 以及解析 $\\kappa(R)$ 所需的表达式。\n2. 构建一个正方形、均匀间隔的二维网格，覆盖以晕为中心、边长为 $L = 4 r_{200}$ 的区域。网格分辨率为 $N \\times N$ 像素，像素宽度为 $\\Delta = L/N$。在每个像素中心 $(x_i,y_j)$ 处，计算投影半径 $R_{ij} = \\sqrt{x_i^2 + y_j^2}$，并将解析 $\\Sigma(R_{ij})$ 赋值给网格以创建表面密度图。然后计算会聚图 $\\kappa_{ij} = \\Sigma(R_{ij})/\\Sigma_{\\mathrm{crit}}$。为保持数值稳定性，定义一个软化尺度 $R_{\\mathrm{soft}} = \\max(10^{-4} r_{\\mathrm{s}}, \\Delta/2)$，并在 $R' = \\max(R,R_{\\mathrm{soft}})$ 处评估 $\\Sigma(R)$，以避免 $R \\to 0$ 时的对数发散。\n3. 通过在透镜平面采样 $N_{\\mathrm{ray}}$ 个光线位置 $(x,y)$ 来模拟光线追迹。使用 $N_{\\mathrm{ray}}=3000$ 个光线位置，其半径 $R$ 在 $R_{\\min} = 2\\Delta$ 到 $R_{\\max} = \\min(1.5 r_{200}, L/2 - 2\\Delta)$ 之间按对数分布抽取，角度 $\\phi$ 在 $[0, 2\\pi)$ 之间均匀抽取（以弧度为单位）。对每条光线，计算：\n   - 解析会聚 $\\kappa_{\\mathrm{true}} = \\kappa(R)$。\n   - 通过对像素化 $\\kappa$ 图在 $(x,y)$ 位置进行双线性插值得到的插值会聚 $\\kappa_{\\mathrm{interp}}$。\n4. 对每个测试案例，计算均方根（RMS）相对偏差\n$$\nb_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_{\\mathrm{ray}}} \\sum_{n=1}^{N_{\\mathrm{ray}}} \\left(\\frac{\\kappa_{\\mathrm{interp},n} - \\kappa_{\\mathrm{true},n}}{\\kappa_{\\mathrm{true},n}}\\right)^2 }。\n$$\n\n宇宙学参数和单位：\n- 使用 $\\Omega_{\\mathrm{m}} = 0.3$，$\\Omega_{\\Lambda} = 0.7$，$H_0 = 70\\,\\mathrm{km}\\,\\mathrm{s}^{-1}\\,\\mathrm{Mpc}^{-1}$，$c = 299{,}792.458\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$，以及 $G = 4.30091\\times 10^{-9}\\,\\mathrm{Mpc}\\,(\\mathrm{km}/\\mathrm{s})^2\\,M_{\\odot}^{-1}$。\n- 将透镜置于 $z_{\\mathrm{d}} = 0.3$，源置于 $z_{\\mathrm{s}} = 1.0$。\n- 所有距离以 $\\mathrm{Mpc}$ 表示，质量以 $M_{\\odot}$ 表示，表面密度以 $M_{\\odot}/\\mathrm{Mpc}^2$ 表示。最终的 RMS 相对偏差 $b_{\\mathrm{RMS}}$ 是无量纲的。\n\n测试套件：\n评估以下四个案例的 $b_{\\mathrm{RMS}}$：\n- 案例 A（理想情况）：$(M_{200}, c, N) = (1.0\\times 10^{14}\\,M_{\\odot}, 6, 256)$。\n- 案例 B（高聚集度，中等网格）：$(M_{200}, c, N) = (1.0\\times 10^{12}\\,M_{\\odot}, 12, 128)$。\n- 案例 C（粗糙分辨率边缘案例）：$(M_{200}, c, N) = (5.0\\times 10^{14}\\,M_{\\odot}, 4, 64)$。\n- 案例 D（大质量晕，精细网格）：$(M_{200}, c, N) = (2.0\\times 10^{15}\\,M_{\\odot}, 3, 512)$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含案例 A–D 的四个 $b_{\\mathrm{RMS}}$ 值，以逗号分隔，并用方括号括起来，顺序为 [A,B,C,D]。例如：“[0.00123,0.00456,0.01234,0.00078]”。所有计算中的角度必须使用弧度。", "solution": "用户提供了一个科学上合理且定义明确的问题。任务是计算在通过一个解析 Navarro–Frenk–White (NFW) 晕的像素化会聚图进行光线追迹时，由双线性插值引入的均方根（RMS）相对偏差。\n\n本解决方案将以结构化的方式进行，首先详细说明所有必要物理量的计算，然后概述为计算指定偏差而设计的数值算法。\n\n### 1. 宇宙学框架和引力透镜物理量\n\n问题设定在一个空间平坦的 Friedmann–Lemaître–Robertson–Walker (FLRW) 宇宙学框架中。哈勃参数 $H(z)$ 随红移 $z$ 的演化由下式给出：\n$$H(z) = H_0 \\sqrt{\\Omega_{\\mathrm{m}}(1+z)^3 + \\Omega_{\\Lambda}}$$\n其中 $H_0 = 70\\,\\mathrm{km}\\,\\mathrm{s}^{-1}\\,\\mathrm{Mpc}^{-1}$ 是哈勃常数，$\\Omega_{\\mathrm{m}} = 0.3$ 是物质密度参数，$\\Omega_{\\Lambda} = 0.7$ 是暗能量密度参数。\n\n从位于 $z=0$ 的观测者到红移为 $z$ 的物体的共动距离 $\\chi(z)$ 通过对哈勃距离积分计算得出：\n$$\\chi(z) = \\int_0^z \\frac{c_{light}}{H(z')} \\, \\mathrm{d}z'$$\n其中 $c_{light} = 299792.458\\,\\mathrm{km}\\,\\mathrm{s}^{-1}$ 是光速。此积分将进行数值计算。\n\n到透镜的角直径距离（$D_{\\mathrm{d}}$）、到源的角直径距离（$D_{\\mathrm{s}}$）以及从透镜到源的角直径距离（$D_{\\mathrm{ds}}$）对于引力透镜计算至关重要。对于平坦宇宙，它们是：\n$$D_{\\mathrm{d}} = D_{\\mathrm{A}}(z_{\\mathrm{d}}) = \\frac{\\chi(z_{\\mathrm{d}})}{1+z_{\\mathrm{d}}}$$\n$$D_{\\mathrm{s}} = D_{\\mathrm{A}}(z_{\\mathrm{s}}) = \\frac{\\chi(z_{\\mathrm{s}})}{1+z_{\\mathrm{s}}}$$\n$$D_{\\mathrm{ds}} = \\frac{\\chi(z_{\\mathrm{s}})-\\chi(z_{\\mathrm{d}})}{1+z_{s}}$$\n其中透镜位于红移 $z_{\\mathrm{d}} = 0.3$，源位于红移 $z_{\\mathrm{s}} = 1.0$。\n\n临界表面质量密度 $\\Sigma_{\\mathrm{crit}}$ 是产生强引力透镜所需的表面密度阈值。它取决于透镜系统的几何结构：\n$$\\Sigma_{\\mathrm{crit}} = \\frac{c_{light}^2}{4\\pi G} \\frac{D_{\\mathrm{s}}}{D_{\\mathrm{d}} D_{\\mathrm{ds}}}$$\n其中 $G = 4.30091\\times 10^{-9}\\,\\mathrm{Mpc}\\,(\\mathrm{km}/\\mathrm{s})^2\\,M_{\\odot}^{-1}$ 是引力常数。\n\n### 2. NFW 晕模型\n\n透镜被建模为一个 NFW 暗物质晕，由其质量 $M_{200}$ 和聚集度参数 $c_{conc}$ 定义。\n半径 $r_{200}$ 包围的平均密度等于宇宙在透镜红移处临界密度 $\\rho_{\\mathrm{crit}}(z_{\\mathrm{d}})$ 的 $200$ 倍。临界密度为：\n$$\\rho_{\\mathrm{crit}}(z) = \\frac{3 H(z)^2}{8\\pi G}$$\n根据 $M_{200}$ 的定义，我们可以解出 $r_{200}$：\n$$M_{200} = \\frac{4\\pi}{3} 200 \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}}) r_{200}^3 \\implies r_{200} = \\left( \\frac{3 M_{200}}{800\\pi \\rho_{\\mathrm{crit}}(z_{\\mathrm{d}})} \\right)^{1/3}$$\nNFW 剖面有两个参数：一个尺度半径 $r_{\\mathrm{s}}$ 和一个特征密度 $\\rho_{\\mathrm{s}}$。它们通过以下方式与 $M_{200}$ 和 $c_{conc}$ 相关联：\n$$r_{\\mathrm{s}} = \\frac{r_{200}}{c_{conc}}$$\n$$\\rho_{\\mathrm{s}} = \\frac{M_{200}}{4\\pi r_{\\mathrm{s}}^3 \\left[\\ln(1+c_{conc}) - \\frac{c_{conc}}{1+c_{conc}}\\right]}$$\n\n### 3. 投影密度和会聚\n\n三维 NFW 密度剖面投影到透镜平面上，在投影半径 $R$ 处产生表面质量密度 $\\Sigma(R)$：\n$$\\Sigma(R) = 2 \\rho_{\\mathrm{s}} r_{\\mathrm{s}} f(x), \\quad \\text{where } x = R/r_{\\mathrm{s}}$$\n无量纲函数 $f(x)$ 由下式给出：\n$$\nf(x) =\n\\begin{cases}\n\\dfrac{1 - \\frac{2}{\\sqrt{1-x^2}} \\operatorname{arctanh}\\left(\\sqrt{\\frac{1-x}{1+x}}\\right)}{x^2 - 1},  0 \\le x  1, \\\\\n\\dfrac{1}{3},  x=1, \\\\\n\\dfrac{1 - \\frac{2}{\\sqrt{x^2-1}} \\arctan\\left(\\sqrt{\\frac{x-1}{x+1}}\\right)}{x^2 - 1},  x  1.\n\\end{cases}\n$$\nNFW 剖面在 $R=0$ 处有一个尖峰，导致 $\\Sigma(R)$ 对数发散。为确保数值稳定性，引入了一个软化长度 $R_{\\mathrm{soft}} = \\max(10^{-4} r_{\\mathrm{s}}, \\Delta/2)$，其中 $\\Delta$ 是网格像素宽度。表面密度在软化半径 $R' = \\max(R, R_{\\mathrm{soft}})$ 处进行评估。\n\n会聚 $\\kappa(R)$ 是由临界密度归一化的表面质量密度：\n$$\\kappa(R) = \\frac{\\Sigma(R)}{\\Sigma_{\\mathrm{crit}}}$$\n\n### 4. 数值算法\n\n#### 网格生成\n在方形网格上创建一个二维会聚图。\n- 网格边长：$L = 4 r_{200}$，以晕为中心。\n- 网格分辨率：$N \\times N$ 像素。\n- 像素宽度：$\\Delta = L/N$。\n- 网格由像素值 $\\kappa_{ij}$ 组成，通过在每个像素 $(i,j)$ 中心（投影半径为 $R_{ij}$）评估解析（软化后）的会聚 $\\kappa(R_{ij})$ 来计算。\n\n#### 光线采样\n$N_{\\mathrm{ray}}=3000$ 条光线穿过透镜平面被追迹。它们的位置 $(x,y)$ 生成如下：\n- 半径 $R$ 从 $R_{\\min} = 2\\Delta$ 和 $R_{\\max} = \\min(1.5 r_{200}, L/2 - 2\\Delta)$ 之间的对数分布中抽取。对于所有测试案例，这简化为 $R_{\\max} = 1.5 r_{200}$。\n- 方位角 $\\phi$ 从 $[0, 2\\pi)$ 的均匀分布中抽取。\n\n#### 插值与比较\n对于每个采样到的位于 $(x,y)$ 的光线：\n- 真实会聚 $\\kappa_{\\mathrm{true}}$ 使用解析公式 $\\kappa(R)$ 计算，其中 $R=\\sqrt{x^2+y^2}$。为了隔离插值误差，$\\kappa_{\\mathrm{true}}$ 使用与应用于网格相同的软化规则计算，即在半径 $R' = \\max(R, R_{\\mathrm{soft}})$ 处。\n- 插值会聚 $\\kappa_{\\mathrm{interp}}$ 通过对 $\\kappa_{ij}$ 图的四个最近像素值进行双线性插值获得。\n\n### 5. 量化插值偏差\n\n计算 RMS 相对偏差 $b_{\\mathrm{RMS}}$ 以量化所有采样光线上插值会聚值与真实会聚值之间的平均差异：\n$$b_{\\mathrm{RMS}} = \\sqrt{\\frac{1}{N_{\\mathrm{ray}}} \\sum_{n=1}^{N_{\\mathrm{ray}}} \\left(\\frac{\\kappa_{\\mathrm{interp},n} - \\kappa_{\\mathrm{true},n}}{\\kappa_{\\mathrm{true},n}}\\right)^2 }$$\n\n此过程对问题陈述中指定的四个测试案例中的每一个重复进行。为实现高效计算，该实现将进行向量化处理。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the gravitational lensing interpolation bias problem.\n    This function encapsulates the entire logic to compute the RMS relative bias\n    for four different NFW halo and grid configurations.\n    \"\"\"\n\n    # Cosmological parameters and physical constants\n    C_LIGHT = 299792.458  # Speed of light in km/s\n    G_CONST = 4.30091e-9  # Gravitational constant in Mpc*(km/s)^2/M_sun\n    H0 = 70.0  # Hubble constant in km/s/Mpc\n    OMEGA_M = 0.3  # Matter density parameter\n    OMEGA_L = 0.7  # Dark energy density parameter\n    Z_D = 0.3  # Lens redshift\n    Z_S = 1.0  # Source redshift\n\n    # Simulation parameters\n    N_RAY = 3000\n\n    # Set a random seed for reproducible ray sampling\n    np.random.seed(42)\n\n    # --- Cosmological Calculations ---\n    memoized_chi = {}\n    def H_z(z):\n        return H0 * np.sqrt(OMEGA_M * (1 + z)**3 + OMEGA_L)\n\n    def H_inv(z):\n        return 1.0 / H_z(z)\n\n    def chi_z(z):\n        if z not in memoized_chi:\n            result, _ = quad(H_inv, 0, z)\n            memoized_chi[z] = C_LIGHT * result\n        return memoized_chi[z]\n\n    chi_d = chi_z(Z_D)\n    chi_s = chi_z(Z_S)\n    \n    D_d = chi_d / (1.0 + Z_D)\n    D_s = chi_s / (1.0 + Z_S)\n    D_ds = (chi_s - chi_d) / (1.0 + Z_S)\n\n    Sigma_crit = (C_LIGHT**2 / (4 * np.pi * G_CONST)) * (D_s / (D_d * D_ds))\n    \n    # --- NFW Profile Functions ---\n    def nfw_f(x):\n        \"\"\"\n        Computes the NFW dimensionless projected density function f(x) for x = R/r_s.\n        This function is vectorized to handle numpy arrays.\n        \"\"\"\n        x = np.atleast_1d(x)\n        out = np.zeros_like(x, dtype=float)\n        \n        # Case 1: 0 = x  1\n        mask_lt1 = (x  1.0)  ~np.isclose(x, 1.0)\n        if np.any(mask_lt1):\n            x_lt1 = x[mask_lt1]\n            term = np.arctanh(np.sqrt((1.0 - x_lt1) / (1.0 + x_lt1)))\n            out[mask_lt1] = (1.0 - (2.0 / np.sqrt(1.0 - x_lt1**2)) * term) / (x_lt1**2 - 1.0)\n\n        # Case 2: x = 1\n        mask_eq1 = np.isclose(x, 1.0)\n        if np.any(mask_eq1):\n            out[mask_eq1] = 1.0 / 3.0\n\n        # Case 3: x > 1\n        mask_gt1 = x > 1.0\n        if np.any(mask_gt1):\n            x_gt1 = x[mask_gt1]\n            term = np.arctan(np.sqrt((x_gt1 - 1.0) / (x_gt1 + 1.0)))\n            out[mask_gt1] = (1.0 - (2.0 / np.sqrt(x_gt1**2 - 1.0)) * term) / (x_gt1**2 - 1.0)\n        \n        return out if x.size > 1 else out.item()\n\n\n    def calculate_rms_bias(M200, c_conc, N):\n        \"\"\"\n        Main function to compute RMS bias for a given set of parameters.\n        \n        Args:\n            M200 (float): Halo mass in solar masses.\n            c_conc (float): Halo concentration.\n            N (int): Grid resolution (N x N).\n        \n        Returns:\n            float: The calculated RMS relative bias.\n        \"\"\"\n        # 1. Calculate NFW halo parameters\n        H_zd = H_z(Z_D)\n        rho_crit_zd = (3.0 * H_zd**2) / (8.0 * np.pi * G_CONST)\n        r200 = ((3.0 * M200) / (4.0 * np.pi * 200.0 * rho_crit_zd))**(1.0/3.0)\n        r_s = r200 / c_conc\n        \n        denominator = 4.0 * np.pi * r_s**3 * (np.log(1.0 + c_conc) - c_conc / (1.0 + c_conc))\n        rho_s = M200 / denominator\n\n        # 2. Set up the pixelized convergence map\n        L = 4.0 * r200\n        delta = L / N\n        R_soft = max(1e-4 * r_s, delta / 2.0)\n\n        grid_coords_1d = np.linspace(-L/2.0 + delta/2.0, L/2.0 - delta/2.0, N)\n        xx, yy = np.meshgrid(grid_coords_1d, grid_coords_1d, indexing='ij')\n        R_grid = np.sqrt(xx**2 + yy**2)\n\n        def kappa_analytic(R):\n            R_eff = np.maximum(R, R_soft)\n            x = R_eff / r_s\n            Sigma = 2.0 * rho_s * r_s * nfw_f(x)\n            return Sigma / Sigma_crit\n        \n        kappa_map = kappa_analytic(R_grid)\n\n        # 3. Sample ray positions\n        R_min = 2.0 * delta\n        R_max = 1.5 * r200\n        \n        radii = np.logspace(np.log10(R_min), np.log10(R_max), N_RAY)\n        angles = np.random.uniform(0, 2.0 * np.pi, N_RAY)\n        \n        ray_x = radii * np.cos(angles)\n        ray_y = radii * np.sin(angles)\n        ray_R = np.sqrt(ray_x**2 + ray_y**2)\n\n        # 4. Compute true and interpolated convergence values\n        kappa_true = kappa_analytic(ray_R)\n\n        # Vectorized bilinear interpolation\n        i_f = (ray_x + L/2.0) / delta - 0.5\n        j_f = (ray_y + L/2.0) / delta - 0.5\n        \n        i1 = np.floor(i_f).astype(int)\n        j1 = np.floor(j_f).astype(int)\n        \n        i1 = np.clip(i1, 0, N - 2)\n        j1 = np.clip(j1, 0, N - 2)\n        i2, j2 = i1 + 1, j1 + 1\n\n        dx, dy = i_f - i1, j_f - j1\n        \n        Q11 = kappa_map[i1, j1] # val at (i1, j1)\n        Q21 = kappa_map[i2, j1] # val at (i2, j1)\n        Q12 = kappa_map[i1, j2] # val at (i1, j2)\n        Q22 = kappa_map[i2, j2] # val at (i2, j2)\n\n        kappa_interp = (Q11 * (1 - dx) * (1 - dy) +\n                        Q21 * dx * (1 - dy) +\n                        Q12 * (1 - dx) * dy +\n                        Q22 * dx * dy)\n\n        # 5. Calculate RMS relative bias\n        relative_errors = (kappa_interp - kappa_true) / kappa_true\n        valid_mask = np.isfinite(relative_errors)  (kappa_true != 0)\n        b_rms = np.sqrt(np.mean(relative_errors[valid_mask]**2))\n        \n        return b_rms\n\n    # --- Test Suite Execution ---\n    test_cases = [\n        # Case A: happy path\n        {'M200': 1.0e14, 'c_conc': 6.0, 'N': 256},\n        # Case B: high concentration, moderate grid\n        {'M200': 1.0e12, 'c_conc': 12.0, 'N': 128},\n        # Case C: coarse resolution edge case\n        {'M200': 5.0e14, 'c_conc': 4.0, 'N': 64},\n        # Case D: massive halo, fine grid\n        {'M200': 2.0e15, 'c_conc': 3.0, 'N': 512},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_rms_bias(case['M200'], case['c_conc'], case['N'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3483287"}, {"introduction": "在实际的宇宙学模拟中，透镜图并非源于解析函数，而是来自 $N$ 体模拟中的离散粒子数据。将粒子分配到网格的过程，例如“云在单元”(Cloud-In-Cell, CIC) 方案，会在傅里叶空间中引入一个已知的卷积核，从而平滑了密度场。本练习 ([@problem_id:3483297]) 演示了通过傅里叶变换对该卷积效应进行反卷积，以恢复真实的收敛度场并精确重建偏折场的关键步骤，这是确保引力透镜计算保真度的核心技术。", "problem": "给定一个平坦天区上的二维收敛场 $\\kappa(\\boldsymbol{\\theta})$，它在一个角大小为 $\\Theta_{\\rm box}$ 弧度的周期性方形区域上被采样。该图是通过使用网格内插云（Cloud-In-Cell, CIC）分配方案将N体粒子投影到网格上生成的，此方案会引入一个已知的卷积核。你的任务是在傅里叶空间中对CIC核进行反卷积，以获得修正后的收敛场 $\\tilde{\\kappa}(\\boldsymbol{\\ell})$，重建偏折场 $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$，并与已知的基准真相进行对比，量化恢复的精度。\n\n基本原理和定义：\n- 二维角坐标为 $\\boldsymbol{\\theta} = (\\theta_x, \\theta_y)$，其中 $\\theta_x, \\theta_y \\in [0,\\Theta_{\\rm box})$，单位为弧度。对应的傅里叶波矢（多极矩）为 $\\boldsymbol{\\ell} = (\\ell_x,\\ell_y)$，其中 $\\ell = \\|\\boldsymbol{\\ell}\\|$，单位为 $\\text{rad}^{-1}$。\n- 平坦天区傅里叶变换的约定为 $\\tilde{f}(\\boldsymbol{\\ell}) = \\int d^2\\boldsymbol{\\theta}\\, f(\\boldsymbol{\\theta}) e^{-i\\boldsymbol{\\ell}\\cdot\\boldsymbol{\\theta}}$，其逆变换为 $f(\\boldsymbol{\\theta}) = \\int \\frac{d^2\\boldsymbol{\\ell}}{(2\\pi)^2}\\, \\tilde{f}(\\boldsymbol{\\ell}) e^{+i\\boldsymbol{\\ell}\\cdot\\boldsymbol{\\theta}}$。\n- 收敛场 $\\kappa(\\boldsymbol{\\theta})$ 和引力透镜势 $\\psi(\\boldsymbol{\\theta})$ 满足关系式 $\\kappa(\\boldsymbol{\\theta}) = \\frac{1}{2}\\nabla^2 \\psi(\\boldsymbol{\\theta})$。在傅里叶空间中，这意味着 $\\tilde{\\kappa}(\\boldsymbol{\\ell}) = -\\frac{1}{2}\\ell^2 \\tilde{\\psi}(\\boldsymbol{\\ell})$，其中 $\\ell^2 \\equiv \\ell_x^2+\\ell_y^2$。\n- 偏折场为 $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta}) = \\nabla \\psi(\\boldsymbol{\\theta})$。在傅里叶空间中，$\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{\\ell}) = i\\boldsymbol{\\ell}\\,\\tilde{\\psi}(\\boldsymbol{\\ell})$，由此可得，对于 $\\ell \\neq 0$ 有关系式 $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{\\ell}) = -2i \\frac{\\boldsymbol{\\ell}}{\\ell^2}\\, \\tilde{\\kappa}(\\boldsymbol{\\ell})$，并且在周期性边界条件下 $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{0})=\\boldsymbol{0}$。\n- 网格内插云（CIC）分配在傅里叶空间中引入一个乘性窗口。对于像素大小为 $\\Delta\\theta = \\Theta_{\\rm box}/N$ 的方形网格，CIC窗口为\n$$\nW_{\\rm CIC}(\\boldsymbol{\\ell}) = \\left[\\operatorname{sinc}\\left(\\frac{\\ell_x \\Delta\\theta}{2}\\right)\\right]^2 \\left[\\operatorname{sinc}\\left(\\frac{\\ell_y \\Delta\\theta}{2}\\right)\\right]^2,\n$$\n其中 $\\operatorname{sinc}(x) \\equiv \\frac{\\sin x}{x}$ 且 $\\operatorname{sinc}(0)=1$。如果 $\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell})$ 是经过CIC分配的收敛场图的傅里叶变换，那么对于 $W_{\\rm CIC}(\\boldsymbol{\\ell}) \\neq 0$ 的模式，反卷积后的估计值为 $\\tilde{\\kappa}(\\boldsymbol{\\ell}) = \\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell})/W_{\\rm CIC}(\\boldsymbol{\\ell})$。\n\n离散设置和算法要求：\n- 该图在一个 $N\\times N$ 的网格上表示，其中 $N$ 为偶数，具有周期性边界条件和均匀的像素间距 $\\Delta\\theta = \\Theta_{\\rm box}/N$。\n- 使用快速傅里叶变换（FFT）来实现所有变换，通过 $f = \\text{fftfreq}(N,\\Delta\\theta)$ 确定离散频率 $f_x,f_y$（单位为周/弧度）并利用关系式 $\\boldsymbol{\\ell} = 2\\pi \\boldsymbol{f}$，使其与上述连续关系保持一致。\n- 通过将 $\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell})$ 逐个模式地除以 $W_{\\rm CIC}(\\boldsymbol{\\ell})$ 来实现反卷积。为保证数值安全性，定义一个小的正阈值 $\\epsilon$，对于 $W_{\\rm CIC}(\\boldsymbol{\\ell}) \\le \\epsilon$ 的模式，将 $\\tilde{\\kappa}(\\boldsymbol{\\ell})$ 设置为零。选择足够小的 $\\epsilon$ 以确保反卷积对于可访问的模式没有偏差，例如 $\\epsilon = 10^{-15}$。\n- 通过计算 $\\ell \\neq 0$ 时的 $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{\\ell}) = -2i \\frac{\\boldsymbol{\\ell}}{\\ell^2}\\, \\tilde{\\kappa}(\\boldsymbol{\\ell})$ 来重建偏折场，然后进行逆FFT以获得位形空间中的 $\\boldsymbol{\\alpha}(\\boldsymbol{\\theta})$。将 $\\ell=\\boldsymbol{0}$ 模式视为零。\n\n测试套件：\n通过定义一个具有已知振幅的单个离散傅里叶模式，为 $\\kappa(\\boldsymbol{\\theta})$ 构建合成的基准真相案例。具体来说，在离散网格上将基准真相 $\\tilde{\\kappa}(\\boldsymbol{\\ell})$ 定义为位于索引 $(m_x,m_y)$ 和 $(-m_x,-m_y)$ 处的两个对称delta系数，以确保场为实数。使用离散FFT归一化，使得在 $(m_x,m_y)$ 和 $(-m_x,-m_y)$ 两处将傅里叶系数设置为 $\\frac{A N^2}{2}$，可以在实空间中产生一个峰值振幅为 $A$ 的余弦模式。然后定义 $\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell}) = W_{\\rm CIC}(\\boldsymbol{\\ell}) \\tilde{\\kappa}(\\boldsymbol{\\ell})$，并应用你的反卷积和偏折重建流程。\n\n提供以下测试案例：\n- 案例1（理想路径）：$N=64$，$\\Theta_{\\rm box} = 0.5$ 弧度，模式索引 $(m_x,m_y)=(5,7)$，振幅 $A=10^{-2}$。\n- 案例2（高频边缘）：$N=64$，$\\Theta_{\\rm box} = 0.5$ 弧度，模式索引 $(m_x,m_y)=(31,0)$，振幅 $A=10^{-2}$。\n- 案例3（零场边界）：$N=64$，$\\Theta_{\\rm box} = 0.5$ 弧度，模式索引 $(m_x,m_y)=(0,0)$，振幅 $A=0$。\n\n对于每个案例：\n- 如上所述生成基准真相 $\\tilde{\\kappa}(\\boldsymbol{\\ell})$，并使用 $\\tilde{\\kappa}(\\boldsymbol{\\ell})$ 和 $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{\\ell})$ 之间的傅里叶域关系计算基准真相偏折场 $\\boldsymbol{\\alpha}_{\\rm true}(\\boldsymbol{\\theta})$。\n- 通过乘以 $W_{\\rm CIC}(\\boldsymbol{\\ell})$ 获得 $\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell})$，然后进行反卷积以估计 $\\tilde{\\kappa}(\\boldsymbol{\\ell})$。\n- 重建修正后的偏折场 $\\boldsymbol{\\alpha}_{\\rm rec}(\\boldsymbol{\\theta})$。\n- 计算以弧度为单位的均方根误差，\n$$\n{\\rm RMSE} = \\left[\\frac{1}{N^2}\\sum_{p=1}^{N^2} \\left(\\alpha_{{\\rm rec},x}^{(p)} - \\alpha_{{\\rm true},x}^{(p)}\\right)^2 + \\left(\\alpha_{{\\rm rec},y}^{(p)} - \\alpha_{{\\rm true},y}^{(p)}\\right)^2 \\right]^{1/2},\n$$\n其中求和遍历所有像素 $p$，$(\\alpha_x,\\alpha_y)$ 是每个像素处偏折向量的两个分量。\n\n角度单位规范：\n- 所有角量，包括偏折场和误差，都必须以弧度表示。\n\n最终输出规范：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目必须是其中一个案例的 ${\\rm RMSE}$，顺序为 $[{\\rm Case}\\,1, {\\rm Case}\\,2, {\\rm Case}\\,3]$，以弧度为单位，使用科学记数法表示，并保留九位有效数字（例如，$[1.234567890e-06,9.876543210e-04,0.000000000e+00]$）。", "solution": "问题陈述完全有效。它提出了一个基于宇宙学中引力透镜分析标准原理的良态数值任务。所有必要的物理关系、数值定义和测试参数都已提供，从而可以得到一个唯一且可验证的解。\n\n解决方案涉及使用快速傅里叶变换（FFT）在傅里叶空间中实现一系列操作。该过程可分解为以下步骤：生成基准真相信号，模拟网格内插云（CIC）分配方案的影响，对此影响进行反卷积，重建感兴趣的物理量（偏折场），以及量化误差。\n\n首先，我们设置离散二维网格。模拟域是一个角大小为 $\\Theta_{\\rm box}$ 弧度的周期性方形区域，被离散化为 $N \\times N$ 的像素网格。像素大小为 $\\Delta\\theta = \\Theta_{\\rm box} / N$。在这个离散域中，我们使用 `numpy.fft` 库来执行傅里叶变换。角频率（多极矩）$\\boldsymbol{\\ell} = (\\ell_x, \\ell_y)$ 通过关系式 $\\boldsymbol{\\ell} = 2\\pi \\boldsymbol{f}$ 与来自 `numpy.fft.fftfreq` 的离散频率 $\\boldsymbol{f} = (f_x, f_y)$ 相关联。我们为 $\\ell_x, \\ell_y$ 和 $\\ell^2 = \\ell_x^2 + \\ell_y^2$ 构建二维网格。\n\n其次，对于每个测试案例，我们生成基准真相收敛场 $\\kappa_{\\rm true}(\\boldsymbol{\\theta})$ 和偏折场 $\\boldsymbol{\\alpha}_{\\rm true}(\\boldsymbol{\\theta})$。这是在傅里叶空间中完成的。问题指明，给定测试案例的基准真相收敛场是一个振幅为 $A$、整数模式索引为 $(m_x, m_y)$ 的单个余弦模式。位形空间中的一个实值余弦模式对应于傅里叶空间中位于对称波矢处的两个delta函数。为了获得峰值振幅为 $A$ 的实数场，我们初始化一个大小为 $N \\times N$ 的复数数组 $\\tilde{\\kappa}_{\\rm true}(\\boldsymbol{\\ell})$ 并填充为零。然后，我们将值 $V = \\frac{A N^2}{2}$ 加到数组索引为 $(m_x, m_y)$ 和 $(-m_x, -m_y)$ 的元素上（其中负索引按模N解释）。此方案能正确处理所有模式类型，包括直流（DC）、奈奎斯特和离轴模式，并且与 `numpy.fft` 的逆变换归一化（包含一个因子 $1/N^2$）相一致。\n\n定义了基准真相 $\\tilde{\\kappa}_{\\rm true}(\\boldsymbol{\\ell})$ 后，我们使用所提供的关系式计算基准真相的傅里叶空间偏折场 $\\tilde{\\boldsymbol{\\alpha}}_{\\rm true}(\\boldsymbol{\\ell})$：\n$$\n\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{\\ell}) = -2i \\frac{\\boldsymbol{\\ell}}{\\ell^2}\\, \\tilde{\\kappa}(\\boldsymbol{\\ell})\n$$\n$\\ell = 0$ 处的奇点按规定通过设置 $\\tilde{\\boldsymbol{\\alpha}}(\\boldsymbol{0}) = \\boldsymbol{0}$ 来处理。在数值上，我们计算一个 $1/\\ell^2$ 的网格，并将其在原点的值设为 $0$。然后，我们对 $\\tilde{\\boldsymbol{\\alpha}}_{\\rm true}(\\boldsymbol{\\ell})$ 应用二维逆FFT，以获得实空间中的基准真相偏折场 $\\boldsymbol{\\alpha}_{\\rm true}(\\boldsymbol{\\theta})$。我们取结果的实部，以丢弃由浮点不精确性产生的可忽略的虚部。\n\n第三，我们模拟与CIC核进行卷积的观测结果。实空间中的这种卷积相当于傅里叶空间中乘以一个窗口函数 $W_{\\rm CIC}(\\boldsymbol{\\ell})$。我们在离散频率网格上计算CIC窗口函数：\n$$\nW_{\\rm CIC}(\\boldsymbol{\\ell}) = \\left[\\operatorname{sinc}\\left(\\frac{\\ell_x \\Delta\\theta}{2}\\right)\\right]^2 \\left[\\operatorname{sinc}\\left(\\frac{\\ell_y \\Delta\\theta}{2}\\right)\\right]^2,\n$$\n其中 $\\operatorname{sinc}(x) = (\\sin x)/x$。我们使用一种安全的实现来处理 $x=0$ 时 $\\operatorname{sinc}(0)=1$ 的情况。傅里叶空间中经CIC卷积的收敛场图为 $\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell}) = \\tilde{\\kappa}_{\\rm true}(\\boldsymbol{\\ell}) W_{\\rm CIC}(\\boldsymbol{\\ell})$。\n\n第四，我们执行反卷积和重建。为了恢复真实收敛场的估计值，我们对CIC窗口进行反卷积。这对应于傅里叶空间中的除法：\n$$\n\\tilde{\\kappa}_{\\rm rec}(\\boldsymbol{\\ell}) = \\frac{\\tilde{\\kappa}_{\\rm CIC}(\\boldsymbol{\\ell})}{W_{\\rm CIC}(\\boldsymbol{\\ell})}\n$$\n为防止因除以零或极小数而导致的数值不稳定性，我们实现了指定的阈值法。对于任何满足 $W_{\\rm CIC}(\\boldsymbol{\\ell}) \\le \\epsilon$（其中 $\\epsilon=10^{-15}$）的模式，我们将重建的系数 $\\tilde{\\kappa}_{\\rm rec}(\\boldsymbol{\\ell})$ 设为 $0$。根据这个反卷积后的 $\\tilde{\\kappa}_{\\rm rec}(\\boldsymbol{\\ell})$，我们使用与处理基准真相时相同的傅里叶空间方法来重建偏折场 $\\boldsymbol{\\alpha}_{\\rm rec}(\\boldsymbol{\\theta})$。\n\n最后，我们通过计算重建偏折场与真实偏折场之间的均方根误差（RMSE）来量化重建的精度。RMSE在所有 $N^2$ 个像素上计算如下：\n$$\n{\\rm RMSE} = \\left[\\frac{1}{N^2}\\sum_{p=1}^{N^2} \\left( \\|\\boldsymbol{\\alpha}_{\\rm rec}^{(p)} - \\boldsymbol{\\alpha}_{\\rm true}^{(p)}\\| \\right)^2 \\right]^{1/2}\n$$\n对三个测试案例中的每一个都执行此计算，并将结果格式化为指定的精度。对于给定的测试案例，由于基准真相仅由单个模式组成且没有噪声，反卷积应该近乎完美，所得的RMSE应非常接近于零，仅受浮点精度限制。$A=0$ 的案例应产生精确为 $0$ 的RMSE。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gravitational lensing deconvolution and reconstruction problem\n    for the specified test cases.\n    \"\"\"\n    test_cases = [\n        # (N, Theta_box, mode_indices, A)\n        {'N': 64, 'Theta_box': 0.5, 'mode_indices': (5, 7), 'A': 1e-2},\n        {'N': 64, 'Theta_box': 0.5, 'mode_indices': (31, 0), 'A': 1e-2},\n        {'N': 64, 'Theta_box': 0.5, 'mode_indices': (0, 0), 'A': 0.0},\n    ]\n\n    results = []\n    epsilon = 1e-15\n\n    for case in test_cases:\n        N = case['N']\n        Theta_box = case['Theta_box']\n        mode_indices = case['mode_indices']\n        A = case['A']\n\n        # Step 1: Setup Grids (Real and Fourier)\n        Delta_theta = Theta_box / N\n        \n        # 1D frequencies and wavenumbers (multipoles)\n        freqs_1d = np.fft.fftfreq(N, d=Delta_theta)\n        ells_1d = 2.0 * np.pi * freqs_1d\n        \n        # 2D grids for wavenumbers\n        ell_x, ell_y = np.meshgrid(ells_1d, ells_1d, indexing='ij')\n        ell_sq = ell_x**2 + ell_y**2\n\n        # Step 2: Generate Ground-Truth Fields\n        # 2a. Ground-truth convergence in Fourier space (kappa_tilde_true)\n        mx, my = mode_indices\n        kappa_tilde_true = np.zeros((N, N), dtype=np.complex128)\n        \n        # Per problem spec, this normalization gives a cosine of peak amplitude A\n        val = A * N**2 / 2.0\n        \n        # Add contributions for mode (mx, my) and its conjugate (-mx, -my)\n        # numpy's += on the same index will correctly sum contributions for DC/Nyquist\n        kappa_tilde_true[mx, my] += val\n        kappa_tilde_true[-mx, -my] += val\n\n        # 2b. Ground-truth deflection field (alpha_true)\n        # We need 1/ell^2, handle ell=0 safely\n        inv_ell_sq = np.zeros_like(ell_sq)\n        nonzero_mask = ell_sq != 0\n        inv_ell_sq[nonzero_mask] = 1.0 / ell_sq[nonzero_mask]\n        \n        # alpha_tilde = -2i * l/l^2 * kappa_tilde\n        alpha_tilde_true_x = -2.0j * ell_x * inv_ell_sq * kappa_tilde_true\n        alpha_tilde_true_y = -2.0j * ell_y * inv_ell_sq * kappa_tilde_true\n\n        # Transform to real space\n        alpha_true_x = np.fft.ifft2(alpha_tilde_true_x).real\n        alpha_true_y = np.fft.ifft2(alpha_tilde_true_y).real\n\n        # Step 3: Simulate CIC-convolved field\n        # 3a. CIC window function W_cic\n        def safe_sinc(x):\n            # sinc(x) = sin(x)/x\n            s = np.ones_like(x, dtype=float)\n            mask = x != 0\n            s[mask] = np.sin(x[mask]) / x[mask]\n            return s\n\n        arg_x = ell_x * Delta_theta / 2.0\n        arg_y = ell_y * Delta_theta / 2.0\n        \n        W_cic = (safe_sinc(arg_x)**2) * (safe_sinc(arg_y)**2)\n        \n        # 3b. Apply CIC window to get kappa_tilde_cic\n        kappa_tilde_cic = kappa_tilde_true * W_cic\n        \n        # Step 4: Deconvolve and Reconstruct\n        # 4a. Deconvolve CIC kernel\n        kappa_tilde_rec = np.zeros_like(kappa_tilde_cic)\n        deconv_mask = W_cic > epsilon\n        kappa_tilde_rec[deconv_mask] = kappa_tilde_cic[deconv_mask] / W_cic[deconv_mask]\n        \n        # 4b. Reconstruct deflection field alpha_rec\n        alpha_tilde_rec_x = -2.0j * ell_x * inv_ell_sq * kappa_tilde_rec\n        alpha_tilde_rec_y = -2.0j * ell_y * inv_ell_sq * kappa_tilde_rec\n\n        # Transform to real space\n        alpha_rec_x = np.fft.ifft2(alpha_tilde_rec_x).real\n        alpha_rec_y = np.fft.ifft2(alpha_tilde_rec_y).real\n\n        # Step 5: Compute RMSE in radians\n        diff_sq_x = (alpha_rec_x - alpha_true_x)**2\n        diff_sq_y = (alpha_rec_y - alpha_true_y)**2\n        \n        mean_sq_err = np.mean(diff_sq_x + diff_sq_y)\n        rmse = np.sqrt(mean_sq_err)\n        \n        results.append(\"{:.9e}\".format(rmse))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3483297"}, {"introduction": "来自遥远星系的光在抵达我们之前会穿过众多居间结构。多平面透镜理论为我们提供了累积光线在一系列透镜平面中传播时所受偏折的数学框架。这项练习 ([@problem_id:3483328]) 将这个复杂过程简化为一个双平面系统，让你能够掌握雅可比矩阵 $\\mathbf{A}$ 传播的核心机制，这对于在完整的宇宙学光线追踪模拟中计算放大率 $\\mu$ 和剪切 $\\gamma$ 等关键可观测量至关重要。", "problem": "考虑一个数值宇宙学光线追踪中的双平面引力透镜构型。你将使用小角度近似和角坐标下的标准多平面形式，实现通过两个透镜平面的雅可比矩阵传播。假设一个平坦宇宙，因此平面之间的角直径距离满足 $D_{ij} = D_j - D_i$ (对于 $i  j$)。源位于平面 $s$。平面 $1$ 具有均匀的汇聚度 $\\,\\kappa_1\\,$ 和零剪切。平面 $2$ 具有纯剪切，其主分量为 $\\,\\gamma_{2,1} = \\gamma\\,$ 和 $\\,\\gamma_{2,2} = -\\gamma\\,$，且汇聚度为零。任务是计算源平面上的最终雅可比矩阵 $\\,\\mathbf{A}_s\\,$ 和放大率 $\\,\\mu = 1/\\det \\mathbf{A}_s\\,$。\n\n使用的基本原理：\n- 对于平面 $\\,j\\,$，角变量下的多平面透镜方程为\n$$\\boldsymbol{\\theta}_j = \\boldsymbol{\\theta} - \\sum_{i=1}^{j-1} \\frac{D_{ij}}{D_j}\\,\\boldsymbol{\\alpha}_i(\\boldsymbol{\\theta}_i),$$\n对于源平面，\n$$\\boldsymbol{\\theta}_s = \\boldsymbol{\\theta} - \\sum_{i=1}^{2} \\boldsymbol{\\alpha}_i(\\boldsymbol{\\theta}_i),$$\n其中 $\\,\\boldsymbol{\\alpha}_i\\,$ 是平面 $\\,i\\,$ 的约化偏转角。\n- 雅可比矩阵传播定义为 $\\,\\mathbf{A}_j = \\partial \\boldsymbol{\\theta}_j / \\partial \\boldsymbol{\\theta}\\,$，平面 $\\,i\\,$ 上的偏转梯度（潮汐）矩阵为 $\\,\\mathbf{U}_i = \\partial \\boldsymbol{\\alpha}_i / \\partial \\boldsymbol{\\theta}_i\\,$。\n- 对于具有汇聚度 $\\,\\kappa\\,$ 和剪切分量 $\\,\\gamma_1\\,$ 和 $\\,\\gamma_2\\,$ 的单个平面，潮汐矩阵为\n$$\\mathbf{U} = \\begin{pmatrix} \\kappa + \\gamma_1  \\gamma_2 \\\\ \\gamma_2  \\kappa - \\gamma_1 \\end{pmatrix}.$$\n- 在选定的具有固定源平面的约化偏转归一化中，用于递归的平面间几何因子是\n$$\\beta_{ij} = \\frac{D_{ij}\\,D_s}{D_j\\,D_{is}}, \\quad \\text{with} \\quad D_{ij} = D_j - D_i, \\quad D_{is} = D_s - D_i,$$\n这确保了当 $\\,j = s\\,$ 时 $\\,\\beta_{is} = 1\\,$。\n\n实现以下步骤：\n1. 为具有均匀汇聚度 $\\,\\kappa_1\\,$ 和零剪切的平面 $\\,1\\,$ 构建 $\\,\\mathbf{U}_1\\,$。\n2. 为具有纯剪切主分量 $\\,\\gamma_{2,1} = \\gamma\\,$ 和 $\\,\\gamma_{2,2} = -\\gamma\\,$ 且汇聚度为零的平面 $\\,2\\,$ 构建 $\\,\\mathbf{U}_2\\,$。\n3. 使用角直径距离 $\\,D_1\\,$, $\\,D_2\\,$ 和 $\\,D_s\\,$ (单位为百万秒差距) 计算 $\\,\\beta_{12}\\,$。\n4. 传播雅可比矩阵：\n   - $\\,\\mathbf{A}_1 = \\mathbf{I}\\,$,\n   - $\\,\\mathbf{A}_2 = \\mathbf{I} - \\beta_{12}\\,\\mathbf{U}_1\\,$,\n   - $\\,\\mathbf{A}_s = \\mathbf{I} - \\mathbf{U}_1 - \\mathbf{U}_2\\,\\mathbf{A}_2\\,$.\n5. 计算行列式 $\\,\\det \\mathbf{A}_s\\,$ 和放大率 $\\,\\mu = 1/\\det \\mathbf{A}_s\\,$。\n\n物理单位：\n- 距离 $\\,D_1\\,$, $\\,D_2\\,$, $\\,D_s\\,$ 以及平面间距离 $\\,D_{ij}\\,$ 必须以百万秒差距 ($\\mathrm{Mpc}$) 为单位处理。放大率 $\\,\\mu\\,$ 是无量纲的。\n\n测试套件：\n使用以下参数集，每个参数集以 $\\,\\{D_1, D_2, D_s, \\kappa_1, \\gamma\\}\\,$ 的形式给出，其中距离单位为 $\\mathrm{Mpc}$：\n- 情况 $\\,1\\,$ (一般正常路径): $\\,\\{1000, 1500, 2000, 0.1, 0.05\\}\\,$.\n- 情况 $\\,2\\,$ (边界，无剪切): $\\,\\{900, 1200, 1800, 0.2, 0.0\\}\\,$.\n- 情况 $\\,3\\,$ (边缘，无汇聚): $\\,\\{1000, 1600, 2000, 0.0, 0.1\\}\\,$.\n- 情况 $\\,4\\,$ (边缘，最小平面间距): $\\,\\{1000, 1001, 3000, 0.4, 0.2\\}\\,$.\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例必须产生一个列表 $\\,\\big[A_{11},A_{12},A_{21},A_{22},\\det(\\mathbf{A}_s),\\mu\\big]\\,$，所有数字四舍五入到六位小数。因此，总输出应是这些按用例排列的列表的单个列表，例如 $\\,\\big[[\\cdots],[\\cdots],[\\cdots],[\\cdots]\\big]\\,$。", "solution": "已对用户提供的问题进行了分析和验证。该问题在科学上是合理的、适定的和客观的。问题提供了一套清晰、自洽的定义和一个用于计算双平面引力透镜系统雅可比矩阵的明确算法。我现在将开始解答。\n\n目标是计算双平面引力透镜场景下的源平面雅可比矩阵 $\\mathbf{A}_s$ 及相应的放大率 $\\mu$。解答将遵循问题陈述中规定的具体算法步骤。\n\n基本量是每个透镜平面 $i$ 的潮汐矩阵 $\\mathbf{U}_i$、平面间几何因子 $\\beta_{12}$ 以及每个平面 $j$ 处的雅可比矩阵 $\\mathbf{A}_j$。\n\n**步骤 1：构建平面 1 的潮汐矩阵 ($\\mathbf{U}_1$)**\n平面 $1$ 的特征是均匀汇聚度 $\\kappa_1$ 和零剪切 ($\\gamma_1 = 0$, $\\gamma_2 = 0$)。潮汐矩阵的一般形式为：\n$$\n\\mathbf{U} = \\begin{pmatrix} \\kappa + \\gamma_1  \\gamma_2 \\\\ \\gamma_2  \\kappa - \\gamma_1 \\end{pmatrix}\n$$\n代入平面 $1$ 的属性，我们得到：\n$$\n\\mathbf{U}_1 = \\begin{pmatrix} \\kappa_1 + 0  0 \\\\ 0  \\kappa_1 - 0 \\end{pmatrix} = \\begin{pmatrix} \\kappa_1  0 \\\\ 0  \\kappa_1 \\end{pmatrix} = \\kappa_1 \\mathbf{I}\n$$\n其中 $\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵。\n\n**步骤 2：构建平面 2 的潮汐矩阵 ($\\mathbf{U}_2$)**\n平面 $2$ 的汇聚度为零 ($\\kappa_2 = 0$) 并具有纯剪切。问题陈述剪切具有“主分量 $\\gamma_{2,1} = \\gamma$ 和 $\\gamma_{2,2} = -\\gamma$”。这意味着在所选坐标系中，剪切场与坐标轴对齐。通常，这对应于将剪切分量设置为 $\\gamma_1 = \\gamma$ 和 $\\gamma_2 = 0$。使用潮汐矩阵的一般公式，并设 $\\kappa=0$, $\\gamma_1=\\gamma$, $\\gamma_2=0$，我们得到：\n$$\n\\mathbf{U}_2 = \\begin{pmatrix} 0 + \\gamma  0 \\\\ 0  0 - \\gamma \\end{pmatrix} = \\begin{pmatrix} \\gamma  0 \\\\ 0  -\\gamma \\end{pmatrix}\n$$\n\n**步骤 3：计算几何因子 $\\beta_{12}$**\n平面间几何因子由以下公式给出：\n$$\n\\beta_{ij} = \\frac{D_{ij}\\,D_s}{D_j\\,D_{is}}\n$$\n使用平坦宇宙的距离关系 $D_{ij} = D_j - D_i$，因子 $\\beta_{12}$ 变为：\n$$\n\\beta_{12} = \\frac{(D_2 - D_1) D_s}{D_2 (D_s - D_1)}\n$$\n其中 $D_1$, $D_2$ 和 $D_s$ 分别是到平面 $1$、平面 $2$ 和源平面的角直径距离。\n\n**步骤 4：将雅可比矩阵传播到源平面 ($\\mathbf{A}_s$)**\n问题为雅可比矩阵 $\\mathbf{A}_j = \\partial\\boldsymbol{\\theta}_j/\\partial\\boldsymbol{\\theta}$ 指定了以下传播关系：\n1.  $\\mathbf{A}_1 = \\mathbf{I}$\n2.  $\\mathbf{A}_2 = \\mathbf{I} - \\beta_{12}\\,\\mathbf{U}_1$\n3.  $\\mathbf{A}_s = \\mathbf{I} - \\mathbf{U}_1 - \\mathbf{U}_2\\,\\mathbf{A}_2$\n\n首先，我们计算 $\\mathbf{A}_2$。代入 $\\mathbf{U}_1$ 的表达式：\n$$\n\\mathbf{A}_2 = \\mathbf{I} - \\beta_{12} (\\kappa_1 \\mathbf{I}) = (1 - \\beta_{12} \\kappa_1) \\mathbf{I}\n$$\n接下来，我们将 $\\mathbf{U}_1$, $\\mathbf{U}_2$ 和推导出的 $\\mathbf{A}_2$ 代入 $\\mathbf{A}_s$ 的表达式中：\n$$\n\\mathbf{A}_s = \\mathbf{I} - \\kappa_1 \\mathbf{I} - \\begin{pmatrix} \\gamma  0 \\\\ 0  -\\gamma \\end{pmatrix} \\left( (1 - \\beta_{12} \\kappa_1) \\mathbf{I} \\right)\n$$\n$$\n\\mathbf{A}_s = (1 - \\kappa_1) \\mathbf{I} - (1 - \\beta_{12} \\kappa_1) \\begin{pmatrix} \\gamma  0 \\\\ 0  -\\gamma \\end{pmatrix}\n$$\n$$\n\\mathbf{A}_s = \\begin{pmatrix} 1 - \\kappa_1  0 \\\\ 0  1 - \\kappa_1 \\end{pmatrix} - \\begin{pmatrix} \\gamma(1 - \\beta_{12} \\kappa_1)  0 \\\\ 0  -\\gamma(1 - \\beta_{12} \\kappa_1) \\end{pmatrix}\n$$\n合并矩阵，我们得到源平面雅可比矩阵的最终形式：\n$$\n\\mathbf{A}_s = \\begin{pmatrix} 1 - \\kappa_1 - \\gamma(1 - \\beta_{12} \\kappa_1)  0 \\\\ 0  1 - \\kappa_1 + \\gamma(1 - \\beta_{12} \\kappa_1) \\end{pmatrix}\n$$\n该矩阵是对角矩阵。设其分量为 $A_{ij}$。则 $A_{12} = A_{21} = 0$。\n\n**步骤 5：计算行列式和放大率 ($\\mu$)**\n对角矩阵的行列式是其对角元素的乘积：\n$$\n\\det \\mathbf{A}_s = A_{11} \\times A_{22} = \\left( 1 - \\kappa_1 - \\gamma(1 - \\beta_{12} \\kappa_1) \\right) \\left( 1 - \\kappa_1 + \\gamma(1 - \\beta_{12} \\kappa_1) \\right)\n$$\n该表达式具有 $(X - Y)(X + Y) = X^2 - Y^2$ 的形式，其中 $X = 1 - \\kappa_1$ 且 $Y = \\gamma(1 - \\beta_{12} \\kappa_1)$。因此，行列式的一个更紧凑的表达式是：\n$$\n\\det \\mathbf{A}_s = (1 - \\kappa_1)^2 - \\gamma^2(1 - \\beta_{12} \\kappa_1)^2\n$$\n引力透镜放大率 $\\mu$ 定义为雅可比矩阵行列式的倒数：\n$$\n\\mu = \\frac{1}{\\det \\mathbf{A}_s}\n$$\n这些推导出的表达式将被用于计算每个测试用例的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Jacobian matrix and magnification for a two-plane gravitational lens system.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is {D1, D2, Ds, kappa1, gamma}\n    test_cases = [\n        (1000, 1500, 2000, 0.1, 0.05),\n        (900, 1200, 1800, 0.2, 0.0),\n        (1000, 1600, 2000, 0.0, 0.1),\n        (1000, 1001, 3000, 0.4, 0.2),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        D1, D2, Ds, kappa1, gamma = case\n        \n        # Ensure distances are floats for division\n        D1, D2, Ds = float(D1), float(D2), float(Ds)\n\n        # Step 3: Compute the geometry factor beta_12\n        # beta_12 = (D_12 * D_s) / (D_2 * D_1s)\n        # where D_ij = D_j - D_i\n        # Note: Added a check for D2 and (Ds - D1) being non-zero to avoid division by zero.\n        # Although not present in test cases, it's good practice.\n        if D2 == 0 or Ds == D1:\n            # This case is physically ill-defined in this formalism\n            # The problem's test cases avoid this.\n            # Propagate an error or handle as per a more detailed model.\n            # For this problem, we can assume valid inputs.\n            beta_12 = np.inf \n        else:\n            beta_12 = ((D2 - D1) * Ds) / (D2 * (Ds - D1))\n\n        # Steps 1, 2, 4 combined: Calculate the components of the final Jacobian A_s\n        # A_s = [[A11, 0], [0, A22]]\n        # A11 = 1 - kappa1 - gamma * (1 - beta_12 * kappa1)\n        # A22 = 1 - kappa1 + gamma * (1 - beta_12 * kappa1)\n        \n        term_common = 1 - beta_12 * kappa1\n        \n        A11 = 1 - kappa1 - gamma * term_common\n        A12 = 0.0\n        A21 = 0.0\n        A22 = 1 - kappa1 + gamma * term_common\n        \n        # Step 5: Compute the determinant and magnification\n        # det(A_s) = (1 - kappa1)^2 - (gamma * (1 - beta_12 * kappa1))^2\n        det_A_s = A11 * A22\n        \n        # Avoid division by zero for magnification calculation\n        mu = 1.0 / det_A_s if det_A_s != 0 else np.inf\n\n        # Store the formatted results for the current case\n        case_result = [\n            round(A11, 6),\n            round(A12, 6),\n            round(A21, 6),\n            round(A22, 6),\n            round(det_A_s, 6),\n            round(mu, 6)\n        ]\n        results.append(case_result)\n\n    # Format the final output string as a list of lists.\n    # Example: [[res1_1, res1_2, ...], [res2_1, res2_2, ...]]\n    output_str = f\"[{','.join([f'[{\",\".join([f\"{val:.6f}\" for val in res])}]' for res in results])}]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3483328"}]}