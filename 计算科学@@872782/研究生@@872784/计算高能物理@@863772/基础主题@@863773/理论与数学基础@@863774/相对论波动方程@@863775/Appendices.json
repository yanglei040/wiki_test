{"hands_on_practices": [{"introduction": "狄拉克方程不仅成功地描述了相对论性电子，还预测了一些与经典直觉相悖的奇特行为。其中最著名的便是“颤动”（Zitterbewegung），即便是对于一个“自由”的电子，其位置也会发生一种极其迅速的震颤。本练习将引导您在海森堡绘景下，直接从算符形式出发，推导出这一现象，从而深刻理解狄拉克方程的内在结构及其正负能量解之间的干涉效应。[@problem_id:3530393]", "problem": "考虑由狄拉克方程描述的自由相对论电子，其哈密顿量为 $H = c\\,\\boldsymbol{\\alpha}\\cdot\\mathbf{p} + \\beta\\,m c^{2}$，其中 $m$ 是质量，$c$ 是光速，$\\mathbf{p}$ 是动量算符，$\\boldsymbol{\\alpha}$ 和 $\\beta$ 是满足反对易关系 $\\{\\alpha_{i},\\alpha_{j}\\} = 2\\,\\delta_{ij}\\,I$，$\\{\\alpha_{i},\\beta\\} = 0$ 和 $\\beta^{2} = I$ 的狄拉克矩阵。在海森堡绘景中，任何算符 $O$ 的时间演化由海森堡运动方程 $dO/dt = (i/\\hbar)[H,O]$ 给出，其中 $\\hbar$ 是约化普朗克常数（定义为 $\\hbar = h/(2\\pi)$）。考虑一个一维（沿 $x$ 轴）波包，它在动量空间中很窄，且中心位于零平均动量，因此在对易子内，你可以在领头阶上设置 $p_{x} \\approx 0$。设初始自旋态被选择为使得速度算符的期望值在 $t=0$ 时为零，同时允许正能量和负能量分量之间存在最大干涉。\n\n从给定的哈密顿量和海森堡方程出发，推导位置算符 $x(t)$ 的精确算符时间依赖关系，识别出被称为“颤动”（Zitterbewegung）的快速振荡项，并提取该指定波包的颤动角频率和期望值 $\\langle x(t)\\rangle$ 中振荡的最大振幅。你的推导必须从基本的算符关系开始，并系统地进行，不援引专门的快捷公式。\n\n将最终的角频率以弧度/秒表示，振幅以米表示。将你的最终答案以单行向量的形式给出，其中包含两个仅用 $m$、$c$ 和 $\\hbar$ 表示的封闭形式解析表达式。不需要进行数值计算，也不需要四舍五入。", "solution": "用户希望我根据提供的设置解决一个问题。\n\n### 第一步：提取已知条件\n- **运动方程**：在海森堡绘景中，算符 $O$ 的时间演化由 $\\frac{dO}{dt} = \\frac{i}{\\hbar}[H,O]$ 给出。\n- **哈密顿量**：自由相对论电子的哈密顿量为 $H = c\\,\\boldsymbol{\\alpha}\\cdot\\mathbf{p} + \\beta\\,m c^{2}$。对于一维情况（沿 $x$ 轴），这简化为 $H = c\\,\\alpha_{x}p_{x} + \\beta\\,m c^{2}$。\n- **狄拉克矩阵性质**：矩阵 $\\boldsymbol{\\alpha}$ 和 $\\beta$ 满足 $\\{\\alpha_{i},\\alpha_{j}\\} = 2\\,\\delta_{ij}\\,I$，$\\{\\alpha_{i},\\beta\\} = 0$ 和 $\\beta^{2} = I$。对于一维问题，这意味着 $\\alpha_x^2 = I$ 和 $\\{\\alpha_x, \\beta\\} = \\alpha_x\\beta + \\beta\\alpha_x = 0$。这些矩阵也是厄米共轭的：$\\alpha_x^\\dagger = \\alpha_x$ 和 $\\beta^\\dagger = \\beta$。\n- **问题陈述**：推导位置算符 $x(t)$ 的精确算符时间依赖关系，识别出“颤动”项，并找到其角频率和最大振幅。\n- **初始条件/状态**：系统是一个沿 $x$ 轴的一维波包。它在动量空间中很窄，且中心位于零平均动量（$p_x \\approx 0$）。初始自旋态被选择为使得速度算符的期望值在 $t=0$ 时为零，即 $\\langle v_x(0) \\rangle = 0$。该状态具有正能量和负能量分量之间的最大干涉。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学依据**：该问题完全基于狄拉克方程和量子力学的海森堡绘景，这些都是相对论量子理论中的基本概念。“颤动”现象是狄拉克理论一个公认的预言。问题的前提是科学上合理的。\n- **问题良定**：问题要求在一组明确的物理条件下推导特定的、可导出的量（算符 $x(t)$、一个角频率和一个振幅）。预期会有一个唯一的、有意义的解。\n- **客观性**：问题以精确、正式的语言陈述，没有主观性或偏见。\n\n### 第三步：结论与行动\n问题是有效的。我现在将进行求解。\n\n问题要求在海森堡绘景中求解位置算符 $x(t)$ 的时间演化。其演化由海森堡运动方程决定。\n\n首先，我们确定速度算符 $v_x = \\frac{dx}{dt}$。在海森堡绘景中，这由下式给出：\n$$ \\frac{dx}{dt} = \\frac{i}{\\hbar}[H, x] $$\n我们计算对易子 $[H, x]$：\n$$ [H, x] = [c\\,\\alpha_{x}p_{x} + \\beta\\,m c^{2}, x] = c[\\alpha_{x}p_{x}, x] + [\\beta\\,m c^{2}, x] $$\n算符 $\\alpha_x$ 和 $\\beta$ 作用于自旋空间，而 $x$ 和 $p_x$ 作用于波函数的空间部分。因此，$\\alpha_x$ 和 $\\beta$ 与 $x$ 对易。第二项为零。\n$$ [H, x] = c\\,\\alpha_x [p_x, x] $$\n使用正则对易关系 $[x, p_x] = i\\hbar$，我们有 $[p_x, x] = -i\\hbar$。\n$$ [H, x] = c\\,\\alpha_x(-i\\hbar) = -i\\hbar c\\,\\alpha_x $$\n将此代入 $\\frac{dx}{dt}$ 的方程中：\n$$ \\frac{dx}{dt} = \\frac{i}{\\hbar}(-i\\hbar c\\,\\alpha_x) = c\\,\\alpha_x $$\n所以，速度算符是 $v_x(t) = c\\,\\alpha_x(t)$。为了求得 $x(t)$，我们必须先求出 $\\alpha_x(t)$ 的时间依赖关系，然后积分。\n\n$\\alpha_x(t)$ 的时间演化也由海森堡方程给出：\n$$ \\frac{d\\alpha_x}{dt} = \\frac{i}{\\hbar}[H, \\alpha_x] $$\n为了求出 $\\alpha_x(t)$ 的演化，我们遵循一个标准方法。考虑反对易子 $\\{H, \\alpha_x\\}$：\n$$ H\\alpha_x + \\alpha_x H = (c\\,\\alpha_x p_x + \\beta m c^2)\\alpha_x + \\alpha_x(c\\,\\alpha_x p_x + \\beta m c^2) $$\n由于 $p_x$ 与 $\\alpha_x$ 对易，我们可以重新排列各项：\n$$ H\\alpha_x + \\alpha_x H = c p_x \\alpha_x^2 + \\beta \\alpha_x m c^2 + c \\alpha_x^2 p_x + \\alpha_x \\beta m c^2 $$\n使用关系 $\\alpha_x^2 = I$ 和 $\\beta\\alpha_x = -\\alpha_x\\beta$：\n$$ H\\alpha_x + \\alpha_x H = c p_x I - \\alpha_x \\beta m c^2 + c p_x I + \\alpha_x \\beta m c^2 = 2c p_x $$\n这给出了重要关系 $H\\alpha_x + \\alpha_x H = 2c p_x$。注意 $[H, p_x] = [c\\alpha_x p_x + \\beta mc^2, p_x] = 0$，所以 $p_x$ 是一个运动常数，$H$ 也是。我们可以写出 $\\alpha_x = c p_x H^{-1} + (\\alpha_x - c p_x H^{-1})$。项 $c p_x H^{-1}$ 是一个运动常数。令 $K = \\alpha_x - c p_x H^{-1}$。这个算符 $K$ 与 $H$ 反对易：\n$$ HK + KH = H(\\alpha_x - c p_x H^{-1}) + (\\alpha_x - c p_x H^{-1})H = H\\alpha_x - cp_x + \\alpha_x H - cp_x = (H\\alpha_x + \\alpha_x H) - 2cp_x = 2cp_x - 2cp_x = 0 $$\n一个与 $H$ 反对易的算符 $K$ 的时间演化是 $K(t) = e^{iHt/\\hbar} K e^{-iHt/\\hbar} = K e^{-2iHt/\\hbar}$。因此，$\\alpha_x(t)$ 的时间演化是：\n$$ \\alpha_x(t) = c p_x H^{-1} + K(t) = c p_x H^{-1} + (\\alpha_x(0) - c p_x H^{-1}) e^{-2iHt/\\hbar} $$\n现在我们可以对 $v_x(t) = c\\,\\alpha_x(t)$ 进行积分以求得 $x(t)$：\n$$ x(t) = x(0) + \\int_0^t v_x(t') dt' = x(0) + \\int_0^t c\\left[ c p_x H^{-1} + (\\alpha_x(0) - c p_x H^{-1}) e^{-2iHt'/\\hbar} \\right] dt' $$\n$$ x(t) = x(0) + c^2 p_x H^{-1} t + c(\\alpha_x(0) - c p_x H^{-1}) \\int_0^t e^{-2iHt'/\\hbar} dt' $$\n积分为 $\\left[ \\frac{e^{-2iHt'/\\hbar}}{-2iH/\\hbar} \\right]_0^t = \\frac{i\\hbar}{2H} (e^{-2iHt/\\hbar} - I)$。\n所以，$x(t)$ 的精确算符表达式为：\n$$ x(t) = x(0) + c^2 p_x H^{-1} t + c(\\alpha_x(0) - c p_x H^{-1}) \\frac{i\\hbar}{2H} (e^{-2iHt/\\hbar} - I) $$\n与 $t$ 成正比的项代表平均速度，而指数项则代表被称为“颤动”（Zitterbewegung）的快速振荡。\n\n问题指定了一个中心在零平均动量的波包。我们考虑一个动量本征值为 $p_x=0$ 的理想化状态。对于这个状态，算符 $p_x$ 可以被其本征值 $0$ 替代。哈密顿量简化为 $H = \\beta m c^2$。\n$x(t)$ 的表达式简化为：\n$$ x(t) = x(0) + c(\\alpha_x(0)) \\frac{i\\hbar}{2\\beta m c^2} (e^{-2i\\beta m c^2 t/\\hbar} - I) $$\n使用 $\\beta^{-1} = \\beta$ 因为 $\\beta^2=I$：\n$$ x(t) = x(0) + \\frac{i\\hbar}{2mc} \\alpha_x(0) \\beta (e^{-2i\\beta m c^2 t/\\hbar} - I) $$\n令 $\\Omega_Z = \\frac{2mc^2}{\\hbar}$。指数项可以展开：$e^{-i\\beta \\Omega_Z t} = I\\cos(\\Omega_Z t) - i\\beta\\sin(\\Omega_Z t)$。括号内的表达式变为：\n$$ \\alpha_x \\beta (I\\cos(\\Omega_Z t) - i\\beta\\sin(\\Omega_Z t) - I) = \\alpha_x\\beta(\\cos(\\Omega_Z t)-1) - i\\alpha_x\\sin(\\Omega_Z t) $$\n所以位置算符的振荡部分是：\n$$ x_Z(t) = \\frac{i\\hbar}{2mc} \\left[ \\alpha_x\\beta(\\cos(\\Omega_Z t)-1) - i\\alpha_x\\sin(\\Omega_Z t) \\right] = \\frac{\\hbar}{2mc} \\left[ \\alpha_x \\sin(\\Omega_Z t) + i\\alpha_x\\beta(\\cos(\\Omega_Z t)-1) \\right] $$\n期望值为 $\\langle x(t) \\rangle = \\langle x(0) \\rangle + \\langle x_Z(t) \\rangle$。\n初始态 $|\\Psi\\rangle$ 在静止时具有正能量（$E=mc^2$）和负能量（$E=-mc^2$）分量之间的最大干涉。我们可以将其写为 $|\\Psi\\rangle = \\frac{1}{\\sqrt{2}}(u_+ + c_- u_-)$，其中 $u_+$ 和 $u_-$ 是静止时的正交归一的正能量和负能量自旋量（$\\beta u_\\pm = \\pm u_\\pm$），且 $|c_-|=1$。\n条件 $\\langle v_x(0) \\rangle = c\\langle\\alpha_x\\rangle = 0$ 意味着 $\\langle\\Psi|\\alpha_x|\\Psi\\rangle = 0$。这个条件固定了相对相位 $c_-$。\n振荡部分的期望值为：\n$$ \\langle x_Z(t) \\rangle = \\frac{\\hbar}{2mc} \\left[ \\langle\\alpha_x\\rangle \\sin(\\Omega_Z t) + i\\langle\\alpha_x\\beta\\rangle(\\cos(\\Omega_Z t)-1) \\right] $$\n由于 $\\langle\\alpha_x\\rangle = 0$：\n$$ \\langle x_Z(t) \\rangle = \\frac{i\\hbar}{2mc} \\langle\\alpha_x\\beta\\rangle(\\cos(\\Omega_Z t)-1) $$\n我们计算 $\\langle\\alpha_x\\beta\\rangle = \\langle\\Psi | \\alpha_x\\beta | \\Psi\\rangle$。算符 $\\alpha_x$ 连接相反能量的状态，所以 $\\langle u_\\pm | \\alpha_x | u_\\pm \\rangle = 0$。\n$\\langle\\alpha_x\\beta\\rangle = \\frac{1}{2}\\langle u_+ + c_- u_- | \\alpha_x\\beta | u_+ + c_- u_- \\rangle = \\frac{1}{2}\\langle u_+ + c_- u_- | \\alpha_x u_+ - c_- \\alpha_x u_- \\rangle = \\frac{1}{2}(-c_-\\langle u_+|\\alpha_x|u_-\\rangle + c_-^*\\langle u_-|\\alpha_x|u_+\\rangle)$。\n由于 $\\langle u_-|\\alpha_x|u_+\\rangle = \\langle u_+|\\alpha_x|u_-\\rangle^*$，这变为 $\\frac{1}{2}(-c_A + c_-^*A^*) = -i \\mathrm{Im}(c_-A)$，其中 $A=\\langle u_+|\\alpha_x|u_-\\rangle$。\n所以，$\\langle x_Z(t) \\rangle = \\frac{i\\hbar}{2mc}(-i\\mathrm{Im}(c_-A))(\\cos(\\Omega_Z t)-1) = \\frac{\\hbar}{2mc}\\mathrm{Im}(c_-A)(\\cos(\\Omega_Z t)-1)$。\n这描述了围绕一个中心点的振荡。\n振荡的角频率可以从余弦函数的宗量中清楚地识别出来：\n$$ \\Omega_Z = \\frac{2mc^2}{\\hbar} $$\n振荡的振幅为 $|\\frac{\\hbar}{2mc}\\mathrm{Im}(c_-A)|$。我们想要找到它的最大值。\n条件 $\\langle\\alpha_x\\rangle=0$ 给出 $\\mathrm{Re}(c_-A)=0$。在此约束下，$|\\mathrm{Im}(c_-A)|=|\\mathrm{Re}(c_-)\\mathrm{Im}(A)+\\mathrm{Im}(c_-)\\mathrm{Re}(A)|=|c_- A|=|A|=|\\langle u_+|\\alpha_x|u_-\\rangle|$。\n为了使振幅最大化，我们必须最大化 $|\\langle u_+|\\alpha_x|u_-\\rangle|$。在标准狄拉克表象中，可以选择基底自旋量，使得这个矩阵元可以等于 $1$。例如，对于一个正能量自旋向上态 $u_+=(1,0,0,0)^T$ 和一个负能量自旋向下态 $u_-=(0,0,0,1)^T$，我们得到 $|\\langle u_+|\\alpha_x|u_-\\rangle|=1$。\n因此，最大振幅为：\n$$ A_{max} = \\frac{\\hbar}{2mc} \\times 1 = \\frac{\\hbar}{2mc} $$\n这个距离是电子的约化康普顿波长的一半。\n\n最终结果是角频率和最大振幅。\n角频率：$\\frac{2mc^2}{\\hbar}$\n最大振幅：$\\frac{\\hbar}{2mc}$\n这些将以单行向量的形式呈现。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{2mc^2}{\\hbar}  \\frac{\\hbar}{2mc}\n\\end{pmatrix}\n}\n$$", "id": "3530393"}, {"introduction": "当我们尝试在离散时空格子上对狄拉克方程进行数值模拟时，一个深刻而基础的问题便会浮现。通过一种朴素的导数离散化方法，我们会在动量空间（布里渊区）的边界上凭空得到不符合物理现实的“复制子”（doubler）粒子。本练习将引导您推导格点上的色散关系，并亲自找出这些复制子，从而揭示格点场论中的一个核心挑战——费米子倍增问题。[@problem_id:3530346]", "problem": "考虑$1+1$维时空中的自旋-$\\tfrac{1}{2}$粒子的相对论性波动方程，即狄拉克方程。在协变形式下，狄拉克方程为$(i\\gamma^{\\mu}\\partial_{\\mu}-m)\\psi=0$，其中$\\gamma^{\\mu}$是狄拉克$\\gamma$矩阵，$m$是静止质量，$\\psi$是$1+1$维下的双分量旋量。使用标准定义$\\alpha=\\gamma^{0}\\gamma^{1}$和$\\beta=\\gamma^{0}$，将其变换为哈密顿形式，方程变为$i\\partial_{t}\\psi=(-i\\alpha\\partial_{x}+\\beta m)\\psi$。你可以选择满足克利福德代数$\\{\\gamma^{\\mu},\\gamma^{\\nu}\\}=2\\eta^{\\mu\\nu}$（其中闵可夫斯基度规为$\\eta^{\\mu\\nu}=\\mathrm{diag}(+1,-1)$）的任意$\\gamma^{\\mu}$矩阵表示。\n\n你的任务是：在间距为$a0$的均匀格点上使用中心差分离散化空间导数，施加周期性边界条件，推导平面波解的格点色散关系$E(k)$，并通过在布里渊区中定位额外的零点来数值展示费米子倍增现象。请在自然单位制（普朗克常数$\\hbar=1$，光速$c=1$）下进行计算，因此能量、质量和波数都以逆长度单位表示。诸如$ka$之类的角度必须以弧度处理。\n\n从哈密顿形式和在格点$x_{n}=na$处的中心差分近似$\\partial_{x}\\psi(x_{n})\\approx\\left[\\psi(x_{n+1})-\\psi(x_{n-1})\\right]/(2a)$出发，应用具有恒定旋量$u$的平面波拟设$\\psi_{n}(t)=u\\,e^{i(kn a - E t)}$，以获得在布里渊区$k\\in[-\\pi/a,\\pi/a)$上的显式格点色散关系$E(k)$。解释与连续情况相比，格点导数如何改变了动量依赖性，并确定$E(k)$出现零点的条件。使用周期性格点动量$k_{j}=-\\pi/a + j\\,(2\\pi/(aN))$，其中$j=0,1,\\dots,N-1$，$N$是一个偶数。\n\n然后，实现一个程序，该程序：\n- 为每个测试用例计算所有离散动量$k_{j}$处的格点色散$E(k)$。\n- 找出所有在指定容差$\\varepsilon$内，$E(k_{j})$数值上为零的$k_{j}$。\n- 报告探测到的零点数量及其位置$k_{j}$（以逆长度单位表示）。\n\n物理与数值单位要求：\n- 所有波数$k$均以逆长度单位报告，与$\\hbar=c=1$保持一致。\n- 诸如$ka$之类的角度以弧度为单位。\n\n测试套件：\n为以下参数集$(a,m,N,\\varepsilon)$提供结果：\n1. $(a=0.2,\\,m=0.0,\\,N=256,\\,\\varepsilon=10^{-12})$ [一般情况；无质量费米子，中等格点]。\n2. $(a=0.1,\\,m=0.001,\\,N=512,\\,\\varepsilon=10^{-6})$ [边缘情况；小的非零质量以测试精确零点的缺失]。\n3. $(a=0.5,\\,m=0.0,\\,N=64,\\,\\varepsilon=10^{-12})$ [更粗的格点；无质量]。\n4. $(a=0.7,\\,m=0.0,\\,N=2,\\,\\varepsilon=10^{-12})$ [边界情况；采样布里渊区两端的最小偶数网格]。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个测试用例结果本身就是一个$[Z,[k_{1},k_{2},\\dots]]$形式的列表，其中$Z$是探测到的零点整数数量，$[k_{1},k_{2},\\dots]$是零点位置的列表。例如，输出应类似于$[[Z_{1},[...]],[[Z_{2},[...]],...]$，在单行上显示，所有$k$都以逆长度单位报告。程序必须是自包含的，并且不需要用户输入。", "solution": "所提出的问题是计算高能物理学中一个定义明确且标准的练习，具体涉及格点上的费米子倍增现象。问题陈述具有科学依据，内容自洽且客观。它要求推导$1+1$维狄拉克费米子的格点色散关系，并数值展示由朴素中心差分离散化方案引起的粒子种类倍增。我们将进行完整的推导和求解。\n\n出发点是在自然单位制$(\\hbar=c=1)$下，$1+1$维中质量为$m$的自旋-$\\frac{1}{2}$粒子的哈密顿形式狄拉克方程：\n$$\ni\\partial_{t}\\psi = H\\psi = (-i\\alpha\\partial_{x} + \\beta m)\\psi\n$$\n此处，$\\psi$是一个双分量旋量，矩阵$\\alpha$和$\\beta$通过狄拉克$\\gamma$矩阵$\\gamma^{\\mu}$定义为$\\alpha=\\gamma^{0}\\gamma^{1}$和$\\beta=\\gamma^{0}$。$\\gamma^{\\mu}$矩阵必须满足克利福德代数$\\{\\gamma^{\\mu},\\gamma^{\\nu}\\} = 2\\eta^{\\mu\\nu}$，其中闵可夫斯基度规为$\\eta^{\\mu\\nu} = \\mathrm{diag}(+1,-1)$。\n\n为了继续，我们必须为$2 \\times 2$的$\\gamma$矩阵选择一个特定的表示。一个满足该代数的常用选择是手性（或Weyl）表示，它由泡利矩阵$\\sigma_i$构建：\n$$\n\\gamma^{0} = \\sigma_1 = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}, \\quad \\gamma^{1} = i\\sigma_2 = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}\n$$\n由此，我们求得$\\beta$和$\\alpha$：\n$$\n\\beta = \\gamma^{0} = \\sigma_1 = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}\n$$\n$$\n\\alpha = \\gamma^{0}\\gamma^{1} = \\sigma_1(i\\sigma_2) = i(\\sigma_1\\sigma_2) = i(i\\sigma_3) = -\\sigma_3 = \\begin{pmatrix} -1  0 \\\\ 0  1 \\end{pmatrix}\n$$\n将这些代入哈密顿量$H$得到：\n$$\nH = -i(-\\sigma_3)\\partial_{x} + m\\sigma_1 = i\\sigma_3\\partial_{x} + m\\sigma_1 = \\begin{pmatrix} i\\partial_x  m \\\\ m  -i\\partial_x \\end{pmatrix}\n$$\n下一步是在格点位置为$x_n = na$、间距为$a$的均匀一维格点上离散化这个连续哈密顿量。空间导数$\\partial_x$使用对称中心差分算符近似：\n$$\n\\partial_x \\psi(x_n) \\approx \\frac{\\psi(x_{n+1}) - \\psi(x_{n-1})}{2a} = \\frac{\\psi_{n+1} - \\psi_{n-1}}{2a}\n$$\n将此代入狄拉克方程$i\\partial_t \\psi_n = H\\psi_n$得到格点上的运动方程：\n$$\ni\\partial_t \\psi_n = i\\sigma_3 \\left(\\frac{\\psi_{n+1} - \\psi_{n-1}}{2a}\\right) + m\\sigma_1 \\psi_n\n$$\n为求解能谱，我们对旋量场采用平面波拟设$\\psi_n(t) = u\\,e^{i(kx_n - Et)} = u\\,e^{i(kna - Et)}$，其中$u$是常数双分量旋量，$k$是波数，$E$是能量。将此拟设应用于格点方程，时间导数变为$\\partial_t \\psi_n = -iE \\psi_n$，相邻格点的旋量通过相位因子关联：$\\psi_{n+1} = e^{ika}\\psi_n$和$\\psi_{n-1} = e^{-ika}\\psi_n$。\n代入这些关系，我们得到一个关于旋量振幅$u$的代数方程：\n$$\ni(-iE) u\\,e^{i(kna - Et)} = i\\sigma_3 \\left(\\frac{e^{ika} - e^{-ika}}{2a}\\right) u\\,e^{i(kna - Et)} + m\\sigma_1 u\\,e^{i(kna - Et)}\n$$\n消去公因子$u\\,e^{i(kna - Et)}$并使用欧拉恒等式$e^{ika} - e^{-ika} = 2i\\sin(ka)$，我们得到关于能量$E$的本征值问题：\n$$\nE u = \\left( i\\sigma_3 \\frac{2i\\sin(ka)}{2a} + m\\sigma_1 \\right) u = \\left( -\\frac{\\sin(ka)}{a}\\sigma_3 + m\\sigma_1 \\right) u\n$$\n这就定义了格点上的动量空间哈密顿量$H_k$：\n$$\nH_k = -\\frac{\\sin(ka)}{a}\\sigma_3 + m\\sigma_1 = \\begin{pmatrix} -\\frac{\\sin(ka)}{a}  m \\\\ m  \\frac{\\sin(ka)}{a} \\end{pmatrix}\n$$\n能量本征值$E(k)$是该矩阵的本征值。它们可以通过求解特征方程$\\det(H_k - E I) = 0$得到：\n$$\n\\det\\begin{pmatrix} -\\frac{\\sin(ka)}{a} - E  m \\\\ m  \\frac{\\sin(ka)}{a} - E \\end{pmatrix} = -\\left(\\frac{\\sin(ka)}{a} + E\\right)\\left(\\frac{\\sin(ka)}{a} - E\\right) - m^2 = 0\n$$\n$$\nE^2 - \\left(\\frac{\\sin(ka)}{a}\\right)^2 - m^2 = 0\n$$\n这给出了显式的格点色散关系：\n$$\nE(k)^2 = m^2 + \\left(\\frac{\\sin(ka)}{a}\\right)^2 \\quad \\implies \\quad E(k) = \\pm\\sqrt{m^2 + \\frac{\\sin^2(ka)}{a^2}}\n$$\n在晶格间距$a \\to 0$的连续极限下，我们有$\\sin(ka) \\approx ka$，因此格点色散关系正确地简化为相对论能量-动量关系$E(k)^2 \\approx m^2 + k^2$。然而，对于有限的$a$，动量$k$被有效动量$p_{\\text{eff}}(k) = \\frac{\\sin(ka)}{a}$所取代。\n\n当我们寻找无质量、低能激发的位置时，“费米子倍增”现象就变得很明显。这些对应于能谱$E(k)$的零点，而零点只可能在质量$m=0$时出现。对于无质量费米子($m=0$)，色散关系简化为$|E(k)| = |\\frac{\\sin(ka)}{a}|$。能量零点出现在$\\sin(ka) = 0$时。对于任意整数$n$，当$ka = n\\pi$时，此条件成立。\n\n在为$k \\in [-\\pi/a, \\pi/a)$定义的第一个布里渊区内，我们找到两个这样的解：\n1.\n$k = 0$ (对于$n=0$)：这对应于预期的零动量物理费米子。\n2.\n$k = \\pm\\pi/a$ (对于$n=\\pm 1$)：这在布里渊区的边缘给出了另一个零能模式。由于格点是周期性的，动量$k = \\pi/a$和$k = -\\pi/a$是等同的。这第二个非物理模式就是“费米子倍增子”。\n\n因此，$1+1$维狄拉克方程的朴素中心差分离散化导致了两种低能费米子，而不是预期的一种。\n\n数值实现将计算离散格点动量$k_j = -\\pi/a + j(2\\pi/(aN))$，其中$j=0, \\dots, N-1$。对于每个$k_j$，它将计算$E(k_j)^2 = m^2 + (\\sin(k_ja)/a)^2$，如果$\\sqrt{E(k_j)^2}  \\varepsilon$（这等价于测试$E(k_j)^2  \\varepsilon^2$），则将其识别为数值零点。然后，代码将计算这些零点的数量并报告它们对应的$k_j$值。对于$m=0$的测试用例，我们预期在$k=0$和$k=-\\pi/a$处有两个零点。对于$m \\neq 0$，最小可能能量为$|E| = |m|$，因此不存在精确零点；是否能找到数值零点将取决于$m$相对于容差$\\varepsilon$的大小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the lattice dispersion relation for the Dirac equation in 1+1D,\n    identifies numerical zeros, and reports the count and locations of these zeros\n    for several test cases, demonstrating fermion doubling.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.2, 0.0, 256, 10**-12),\n        (0.1, 0.001, 512, 10**-6),\n        (0.5, 0.0, 64, 10**-12),\n        (0.7, 0.0, 2, 10**-12)\n    ]\n\n    results = []\n    \n    for a, m, N, epsilon in test_cases:\n        # Generate the list of discrete momenta k_j in the Brillouin zone.\n        # k_j = -pi/a + j * (2*pi / (a*N)) for j = 0, 1, ..., N-1\n        j_values = np.arange(N)\n        k_values = -np.pi / a + j_values * (2.0 * np.pi / (a * N))\n\n        # List to store the k values where E(k) is numerically zero.\n        zero_locations = []\n\n        # Find the zeros of the dispersion relation E(k).\n        # A zero is found if |E(k)|  epsilon, which is equivalent to E(k)^2  epsilon^2.\n        # E(k)^2 = m^2 + (sin(k*a)/a)^2\n        epsilon_sq = epsilon**2\n        \n        for k in k_values:\n            # Calculate the effective momentum term squared.\n            p_eff_sq = (np.sin(k * a) / a)**2\n            \n            # Calculate the energy squared.\n            energy_sq = m**2 + p_eff_sq\n            \n            # Check if the energy is numerically zero.\n            if energy_sq  epsilon_sq:\n                # Handle the case where k is extremely close to 0.0.\n                if np.isclose(k, 0.0):\n                    zero_locations.append(0.0)\n                else:\n                    zero_locations.append(k)\n        \n        # The number of zeros is the length of the list of locations.\n        num_zeros = len(zero_locations)\n        \n        results.append([num_zeros, zero_locations])\n\n    # Format the final output string according to the problem specification.\n    # e.g., [[Z1,[k1,k2,...]],[Z2,[...]],...]\n    case_strings = []\n    for Z, k_list in results:\n        # Format the list of k-values without spaces.\n        k_str = f\"[{','.join(map(str, k_list))}]\"\n        case_strings.append(f\"[{Z},{k_str}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3530346"}, {"introduction": "为了在格点模拟中取得进展，必须解决费米子倍增问题。Wilson项是一种著名的解决方案，它通过赋予不物理的复制子一个很大的质量，从而将它们从低能物理中移除。然而，这个方案是有代价的：它明确地破坏了手征对称性，而这恰恰是原始理论的一个关键对称性。在本练习中，您将通过编程实现Wilson项，并从数值上验证它在移除复制子方面的成功以及其破坏手征对称性的后果，这生动地展示了深刻的Nielsen-Ninomiya定理的实际影响。[@problem_id:3530403]", "problem": "构造一个完整、可运行的程序，演示如何在二维欧几里得维度中，向自由晶格狄拉克算符添加一个威尔逊项能够消除费米子加倍子，但同时明确地破坏手征对称性，并对连续谱极限下的权衡进行定量分析。\n\n从以下适用于计算高能物理的基础出发：\n- 使用中心有限差分在超立方晶格上离散化空间导数。在动量空间中，这得到方向 $\\mu$ 上的对称导数的符号为 $\\sin(q_{\\mu})/a$，其中 $a$ 是晶格间距，$q_{\\mu} \\equiv p_{\\mu} a$ 是第一布里渊区（BZ）内的无量纲晶格动量（角度），以弧度为单位。\n- 在 $d=2$ 欧几里得维度下，动量空间中的自由、无质量、朴素狄拉克算符由这些符号和满足欧几里得克利福德代数的二维伽马矩阵构造而成。使用 $2 \\times 2$ 泡利矩阵作为一个有效表示：定义 $\\gamma_1 = \\sigma_1$，$\\gamma_2 = \\sigma_2$，以及手征矩阵 $\\gamma_5 = \\sigma_3$，它与 $\\gamma_1$ 和 $\\gamma_2$ 反对易。\n- 威尔逊项是通过向朴素算符添加一个晶格拉普拉斯算子来消除加倍子模态而获得的。在动量空间中，沿方向 $\\mu$ 的晶格拉普拉斯算子的符号为 $2(1 - \\cos(q_{\\mu}))/a^2$。添加到狄拉克算符的威尔逊项与此拉普拉斯算子成正比，形式为 $R(\\mathbf{q}) \\,\\mathbf{1}$，其中 $R(\\mathbf{q}) = - r \\sum_{\\mu} (1 - \\cos(q_{\\mu}))/a$，$r$ 是无量纲的威尔逊参数，$\\mathbf{1}$ 是旋量空间中的单位矩阵。这将加倍子模态的质量移动到 $1/a$ 的量级，同时通过 $a$ 量级的项修改了低能行为。\n\n你的程序必须实现以下内容，全部在 $d=2$ 欧几里得维度下，动量在布里渊区的均匀网格上采样：\n1. 定义自由朴素狄拉克算符 $D_{\\text{naive}}(\\mathbf{q}) = i \\sum_{\\mu=1}^{2} \\gamma_{\\mu} \\sin(q_{\\mu})/a + m_0 \\,\\mathbf{1}$，其中 $m_0$ 是裸质量。\n2. 定义威尔逊-狄拉克算符 $D_{\\text{Wilson}}(\\mathbf{q}) = D_{\\text{naive}}(\\mathbf{q}) + R(\\mathbf{q}) \\,\\mathbf{1}$，其中 $R(\\mathbf{q}) = - r \\sum_{\\mu=1}^{2} \\left(1 - \\cos(q_{\\mu})\\right)/a$。\n3. 通过计算 $D_{\\text{naive}}(\\mathbf{q})$ 和 $D_{\\text{Wilson}}(\\mathbf{q})$ 在整个布里渊区内接近零的奇异值的数量来演示加倍子的消除。在这里，“接近零”意味着最小奇异值 $s_{\\min}(\\mathbf{q})$ 低于一个与 $1/a$ 成正比的阈值 $\\varepsilon(a)$。使用 $\\varepsilon(a) = \\varepsilon_0/a$ 和 $\\varepsilon_0 = 10^{-8}$ 以在物理单位中保持一个尺度一致的阈值。\n4. 通过为每个算符 $D(\\mathbf{q})$ 计算与手征性的反对易子 $\\{\\gamma_5, D(\\mathbf{q})\\} = \\gamma_5 D(\\mathbf{q}) + D(\\mathbf{q}) \\gamma_5$，然后构成一个无量纲的红外比率来量化手征对称性破缺\n$$\n\\mathcal{R}_{\\text{IR}} = \\max_{\\mathbf{p} \\in \\mathcal{B}_{\\text{IR}}} \\frac{\\left\\| \\{\\gamma_5, D(\\mathbf{q})\\} \\right\\|_2}{\\left\\| D(\\mathbf{q}) \\right\\|_2},\n$$\n其中 $\\|\\cdot\\|_2$ 表示谱范数，$\\mathbf{q} = a \\mathbf{p}$，$\\mathcal{B}_{\\text{IR}}$ 是由 $\\|\\mathbf{p}\\| \\le p_{\\text{cut}}$ 定义的物理动量的红外球。对于无质量朴素算符，此红外比率恒为零；而对于在有限晶格间距下的威尔逊算符，此比率不为零，但对于固定的 $p_{\\text{cut}}$，它应该随 $a$ 线性地缩放到零。\n5. 使用一个均匀网格实现布里渊区采样，每个方向有 $N$ 个点，其中 $q_{\\mu} = 2\\pi k_{\\mu}/N$，整数 $k_{\\mu} \\in \\{0,1,\\dots,N-1\\}$，使得在 $q$-空间中，布里渊区为 $[0,2\\pi) \\times [0,2\\pi)$。角度（如 $q_{\\mu}$）必须以弧度处理。对于红外比率，将最大化限制在满足 $\\|\\mathbf{p}\\| = \\|\\mathbf{q}\\|/a \\le p_{\\text{cut}}$ 的网格点上。\n\n程序必须评估以下参数集测试套件并产生定量输出：\n- 测试用例 1（无威尔逊项的基线）：$N = 64$，$a = 1.0$（无量纲晶格单位），$r = 0.0$，$m_0 = 0.0$，$p_{\\text{cut}} = 0.5$（以晶格长度的倒数为单位），角度以弧度为单位。\n- 测试用例 2（粗晶格上的威尔逊项）：$N = 64$，$a = 1.0$，$r = 1.0$，$m_0 = 0.0$，$p_{\\text{cut}} = 0.5$，角度以弧度为单位。\n- 测试用例 3（细晶格上的威尔逊项）：$N = 64$，$a = 0.5$，$r = 1.0$，$m_0 = 0.0$，$p_{\\text{cut}} = 0.5$，角度以弧度为单位。\n\n对于每个测试用例，程序必须计算并返回四个数字：\n- $D_{\\text{naive}}$ 在整个布里渊区上的近零模态的整数计数。\n- $D_{\\text{Wilson}}$ 在整个布里渊区上的近零模态的整数计数。\n- $D_{\\text{naive}}$ 的红外手征破缺比率 $\\mathcal{R}_{\\text{IR}}$（一个浮点数）。\n- $D_{\\text{Wilson}}$ 的红外手征破缺比率 $\\mathcal{R}_{\\text{IR}}$（一个浮点数）。\n\n最终输出格式要求：\n- 您的程序应产生单行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来，顺序如下\n$$\n[\\text{cN}_1,\\text{cW}_1,\\text{rN}_1,\\text{rW}_1,\\text{cN}_2,\\text{cW}_2,\\text{rN}_2,\\text{rW}_2,\\text{cN}_3,\\text{cW}_3,\\text{rN}_3,\\text{rW}_3],\n$$\n其中 $\\text{cN}_i$ 是朴素算符的近零计数，$\\text{cW}_i$ 是威尔逊算符的近零计数，$\\text{rN}_i$ 是朴素算符的红外比率，$\\text{rW}_i$ 是威尔逊算符的红外比率，对应测试用例 $i$。计数是整数，比率是浮点数。所有三角函数中的角度必须是弧度。所有输出都是无量纲的。不允许外部输入或文件；程序必须能按原样运行并打印该行。", "solution": "用户提供了一个来自计算高能物理领域（特别是格点规范场论）的有效问题陈述。该问题要求通过数值方法演示威尔逊费米子方案如何以明确破坏手征对称性为代价来解决费米子加倍问题。解决方案将通过首先建立数学框架，然后概述所需分析的计算步骤来展开。\n\n### 基于原理的设计\n\n问题的核心在于欧几里得时空晶格上狄拉克算符的离散化。朴素的离散化方法会导致非物理的费米子副本，即所谓的“加倍子”，这是 Nielsen-Ninomiya 无路定理的一种表现。威尔逊项是一个优雅但并不完美的解决方案。\n\n#### 1. 数学公式化\n\n我们在 $d=2$ 欧几里得维度下操作。连续谱狄拉克算符为 $D = \\sum_{\\mu=1,2} \\gamma_\\mu \\partial_\\mu + m_0$。在间距为 $a$ 的超立方晶格上，使用对称有限差分 $\\partial_\\mu \\psi(x) \\to [\\psi(x+a\\hat{\\mu}) - \\psi(x-a\\hat{\\mu})]/(2a)$ 对其进行离散化，导致动量空间中导数算符的表示为 $i \\sin(p_\\mu a)/a$。我们定义无量纲动量为 $q_\\mu = p_\\mu a$。\n\n在 $d=2$ 维中，伽马矩阵可以用泡利矩阵表示，满足欧几里得克利福德代数 $\\{\\gamma_\\mu, \\gamma_\\nu\\} = 2\\delta_{\\mu\\nu}\\mathbf{1}$。我们使用标准表示：\n$$\n\\gamma_1 = \\sigma_1 = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}, \\quad\n\\gamma_2 = \\sigma_2 = \\begin{pmatrix} 0  -i \\\\ i  0 \\end{pmatrix}\n$$\n手征矩阵是 $\\gamma_5 = \\sigma_3 = \\begin{pmatrix} 1  0 \\\\ 0  -1 \\end{pmatrix}$，它与 $\\gamma_1$ 和 $\\gamma_2$ 反对易：$\\{\\gamma_5, \\gamma_\\mu\\} = 0$。\n\n对于无质量费米子（$m_0=0$），动量空间中的**朴素狄拉克算符**是：\n$$\nD_{\\text{naive}}(\\mathbf{q}) = \\frac{i}{a} \\sum_{\\mu=1}^{2} \\gamma_{\\mu} \\sin(q_{\\mu}) = \\frac{i}{a} \\begin{pmatrix} 0  \\sin(q_1) - i\\sin(q_2) \\\\ \\sin(q_1) + i\\sin(q_2)  0 \\end{pmatrix}\n$$\n\n**威尔逊项**由晶格拉普拉斯算子构造，其符号为 $\\sum_\\mu 2(1-\\cos q_\\mu)/a^2$。它被加到算符中，以赋予加倍子较大的质量。威尔逊项是：\n$$\nR(\\mathbf{q}) = -\\frac{r}{a} \\sum_{\\mu=1}^{2} (1 - \\cos(q_{\\mu}))\n$$\n其中 $r$ 是无量纲的威尔逊参数。该项在旋量空间中与单位矩阵 $\\mathbf{1}$ 成正比。\n\n**威尔逊-狄拉克算符**是朴素算符和威尔逊项的和：\n$$\nD_{\\text{Wilson}}(\\mathbf{q}) = D_{\\text{naive}}(\\mathbf{q}) + R(\\mathbf{q})\\mathbf{1} = \\begin{pmatrix} R(\\mathbf{q})  \\frac{i}{a}(\\sin(q_1) - i\\sin(q_2)) \\\\ \\frac{i}{a}(\\sin(q_1) + i\\sin(q_2))  R(\\mathbf{q}) \\end{pmatrix}\n$$\n\n#### 2. 加倍子消除分析\n\n费米子模态对应于狄拉克算符的零点，即其奇异值为零的地方。奇异值是 $D^\\dagger D$ 的特征值的平方根。\n\n对于朴素算符（当 $m_0=0$ 时），它是反厄米的（$D_{\\text{naive}}^\\dagger = -D_{\\text{naive}}$）。因此，\n$$\nD_{\\text{naive}}^\\dagger D_{\\text{naive}} = -D_{\\text{naive}}^2 = -\\left(\\frac{i}{a}\\right)^2 \\left(\\sum_\\mu \\gamma_\\mu \\sin q_\\mu\\right)^2 = \\frac{1}{a^2} \\left(\\sum_\\mu \\sin^2 q_\\mu\\right)\\mathbf{1}\n$$\n奇异值是简并的，由 $s_{\\text{naive}}(\\mathbf{q}) = \\frac{1}{a} \\sqrt{\\sin^2 q_1 + \\sin^2 q_2}$ 给出。当 $\\sin q_1 = 0$ 和 $\\sin q_2 = 0$ 同时成立时，这些值为零。在布里渊区 $q_\\mu \\in [0, 2\\pi)$ 中，这发生在四个动量点：$(0,0)$、$(0,\\pi)$、$(\\pi,0)$ 和 $(\\pi,\\pi)$。这 $2^d=4$ 个无质量模态分别是物理费米子和三个非物理的“加倍子”。\n\n对于威尔逊算符，$D_{\\text{Wilson}} = D_{\\text{naive}} + R(\\mathbf{q})\\mathbf{1}$。因为 $R(\\mathbf{q})$ 是实数，其厄米共轭操作是平凡的。\n$$\nD_{\\text{Wilson}}^\\dagger D_{\\text{Wilson}} = (-D_{\\text{naive}} + R(\\mathbf{q})\\mathbf{1})(D_{\\text{naive}} + R(\\mathbf{q})\\mathbf{1}) = -D_{\\text{naive}}^2 + R(\\mathbf{q})^2\\mathbf{1}\n$$\n$$\nD_{\\text{Wilson}}^\\dagger D_{\\text{Wilson}} = \\left( \\frac{1}{a^2}(\\sin^2 q_1 + \\sin^2 q_2) + R(\\mathbf{q})^2 \\right)\\mathbf{1}\n$$\n奇异值为 $s_{\\text{Wilson}}(\\mathbf{q}) = \\sqrt{\\frac{1}{a^2}(\\sin^2 q_1 + \\sin^2 q_2) + R(\\mathbf{q})^2}$。要使此值为零，平方根下的两项都必须为零。含正弦的项在与之前相同的四个加倍子位置为零。然而，威尔逊项 $R(\\mathbf{q})$ 仅在 $\\mathbf{q}=(0,0)$ 处为零（对于 $r \\ne 0$）。在其他三个位置，例如 $\\mathbf{q}=(\\pi,0)$，$R(\\pi,0) = -2r/a \\neq 0$。在布里渊区角落的加倍子获得了量级为 $r/a$ 的质量，使它们在连续谱极限（$a \\to 0$）下解耦。只有在 $\\mathbf{q}=(0,0)$ 处的物理模态保持无质量。\n\n算法将计算一个 $N \\times N$ 网格上，最小奇异值低于阈值 $\\varepsilon(a) = \\varepsilon_0/a$（其中 $\\varepsilon_0 = 10^{-8}$）的动量点 $\\mathbf{q}$ 的数量。我们预期朴素算符的计数为 $4$，而威尔逊算符的计数为 $1$（当 $r=1$ 时）。\n\n#### 3. 手征对称性破缺分析\n\n对于一个无质量的狄拉克算符 $D$，手征对称性由条件 $\\{\\gamma_5, D\\} = 0$ 表达。\n\n对于朴素算符，$\\{\\gamma_5, D_{\\text{naive}}\\} = \\frac{i}{a} \\sum_\\mu \\{\\gamma_5, \\gamma_\\mu\\} \\sin q_\\mu = 0$，因为伽马矩阵与 $\\gamma_5$ 反对易。无质量的朴素算符具有精确的手征对称性。\n\n对于威尔逊算符，威尔逊项与 $\\gamma_5$ 不反对易：\n$$\n\\{\\gamma_5, D_{\\text{Wilson}}\\} = \\{\\gamma_5, D_{\\text{naive}}\\} + \\{\\gamma_5, R(\\mathbf{q})\\mathbf{1}\\} = 0 + R(\\mathbf{q})(\\gamma_5 \\mathbf{1} + \\mathbf{1} \\gamma_5) = 2R(\\mathbf{q})\\gamma_5\n$$\n这个非零的反对易子表明威尔逊项明确地破坏了手征对称性。这种破缺的大小与 $R(\\mathbf{q})$ 成正比。在红外（连续谱）极限 $\\mathbf{q} \\to 0$下，$R(\\mathbf{q}) \\approx -\\frac{r}{2a}|\\mathbf{q}|^2 = -\\frac{ra}{2}|\\mathbf{p}|^2$。这种破缺是一个 $O(a)$ 效应，在连续谱极限下会消失。\n\n我们通过计算在一个物理动量的红外球 $\\|\\mathbf{p}\\| \\le p_{\\text{cut}}$ 上的无量纲比率 $\\mathcal{R}_{\\text{IR}}$ 来量化这一点，这等价于 $\\|\\mathbf{q}'\\| \\le a p_{\\text{cut}}$，其中 $\\mathbf{q}'$ 是映射到区间 $[-\\pi, \\pi]^2$ 的动量。\n$$\n\\mathcal{R}_{\\text{IR}} = \\max_{\\|\\mathbf{p}\\| \\le p_{\\text{cut}}} \\frac{\\left\\| \\{\\gamma_5, D(\\mathbf{q})\\} \\right\\|_2}{\\left\\| D(\\mathbf{q}) \\right\\|_2}\n$$\n其中 $\\|\\cdot\\|_2$ 是谱范数（最大奇异值）。\n对于 $D_{\\text{naive}}$，这个比率恒为零。对于 $D_{\\text{Wilson}}$，该比率近似为 $\\frac{|2R(\\mathbf{q})|}{\\|D_{\\text{Wilson}}(\\mathbf{q})\\|_2}$。如上所述，预期该比率与晶格间距 $a$ 成正比。程序将计算两个算符在这个指定的红外区域内的最大比率。\n\n#### 4. 算法实现\n\n程序将遍历指定的测试用例。对于每个用例：\n1.  根据参数 $N, a, r, m_0, p_{\\text{cut}}$ 定义常数和算符。\n2.  生成一个无量纲动量的二维网格 $\\mathbf{q} = (q_1, q_2)$，其中 $q_\\mu = 2\\pi k_\\mu/N$，$k_\\mu \\in \\{0, \\dots, N-1\\}$。\n3.  初始化近零模态的计数器和最大红外比率的变量。\n4.  遍历网格上的每个点 $\\mathbf{q}$。\n    a. 构造 $D_{\\text{naive}}(\\mathbf{q})$ 和 $D_{\\text{Wilson}}(\\mathbf{q})$ 的 $2 \\times 2$ 矩阵。\n    b. 使用 `numpy.linalg.svd` 计算它们的奇异值。\n    c. 将每个算符的最小奇异值与阈值 $\\varepsilon_0/a$ 进行比较，并更新相应的计数器。\n    d. 将动量 $\\mathbf{q}$ 映射到 $\\mathbf{q}' \\in [-\\pi, \\pi]^2$ 以正确测量其与原点的距离。检查是否满足 $\\|\\mathbf{q}'\\| \\le a p_{\\text{cut}}$。\n    e. 如果在红外球内，计算两个算符的 $\\{\\gamma_5, D\\}$，求它们的谱范数，求算符本身的谱范数，并更新最大比率 $\\mathcal{R}_{\\text{IR}}$。\n5.  存储该测试用例的四个计算值（两个计数，两个比率）。\n6.  处理完所有测试用例后，以要求的单行格式打印结果。\n\n这个过程将数值验证理论预测：朴素算符有加倍子但手征对称，而威尔逊算符消除了加倍子，但代价是引入了一个受控的、在连续谱极限下消失的明确的手征对称性破缺。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Demonstrates doubler lifting and chiral symmetry breaking by the Wilson term\n    in the 2D lattice Dirac operator.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, a, r, m0, p_cut)\n        (64, 1.0, 0.0, 0.0, 0.5), # Case 1: Naive operator baseline\n        (64, 1.0, 1.0, 0.0, 0.5), # Case 2: Wilson operator, coarse lattice\n        (64, 0.5, 1.0, 0.0, 0.5), # Case 3: Wilson operator, finer lattice\n    ]\n\n    # Define gamma matrices (Pauli matrices) and identity\n    gamma1 = np.array([[0, 1], [1, 0]], dtype=complex)\n    gamma2 = np.array([[0, -1j], [1j, 0]], dtype=complex)\n    gamma5 = np.array([[1, 0], [0, -1]], dtype=complex)\n    identity = np.eye(2, dtype=complex)\n\n    results = []\n    \n    for N, a, r, m0, p_cut in test_cases:\n        # Initialize outputs for the current test case\n        count_naive = 0\n        count_wilson = 0\n        max_ratio_naive = 0.0\n        max_ratio_wilson = 0.0\n        \n        # Threshold for counting near-zero modes\n        epsilon_0 = 1e-8\n        threshold = epsilon_0 / a\n        \n        # Infrared momentum cutoff in q-space\n        ir_q_radius = a * p_cut\n        \n        # Generate the momentum grid in radians for the Brillouin Zone [0, 2pi) x [0, 2pi)\n        k_vals = np.arange(N)\n        q_vals = 2 * np.pi * k_vals / N\n        \n        # Loop over all momentum points in the Brillouin Zone\n        for q1 in q_vals:\n            for q2 in q_vals:\n                # --- Construct Operators ---\n                \n                # Naive Dirac operator D_naive(q)\n                d_naive_term = (gamma1 * np.sin(q1) + gamma2 * np.sin(q2))\n                D_naive = (1j / a) * d_naive_term + m0 * identity\n\n                # Wilson term R(q)\n                R_q = -r / a * ((1 - np.cos(q1)) + (1 - np.cos(q2)))\n\n                # Wilson-Dirac operator D_Wilson(q)\n                D_wilson_base = (1j / a) * d_naive_term + m0 * identity\n                # The naive part of wilson op has r=0, so D_naive above has r=0.0 from case 1.\n                # For case 2  3, the naive operator must still be calculated with r=0.\n                if r != 0.0:\n                    d_naive_term_r0 = (gamma1 * np.sin(q1) + gamma2 * np.sin(q2))\n                    D_naive_r0 = (1j / a) * d_naive_term_r0 + m0 * identity\n                    D_wilson = D_naive_r0 + R_q * identity\n                else: # if r=0.0, wilson is same as naive\n                    D_wilson = D_naive\n\n\n                # --- 1. Doubler Lifting Analysis ---\n                \n                # Singular values are computed from the operator matrices\n                s_naive = np.linalg.svd(D_naive, compute_uv=False)\n                s_wilson = np.linalg.svd(D_wilson, compute_uv=False)\n                \n                # Check if the smallest singular value is near-zero\n                if np.min(s_naive)  threshold:\n                    count_naive += 1\n                if np.min(s_wilson)  threshold:\n                    count_wilson += 1\n                \n                # --- 2. Chiral Symmetry Breaking Analysis ---\n                \n                # Map q from [0, 2pi) to [-pi, pi) to correctly calculate distance from origin\n                q1_prime = (q1 + np.pi) % (2 * np.pi) - np.pi\n                q2_prime = (q2 + np.pi) % (2 * np.pi) - np.pi\n                \n                q_norm = np.sqrt(q1_prime**2 + q2_prime**2)\n\n                if q_norm = ir_q_radius:\n                    # Anticommutators {gamma5, D}\n                    anticomm_naive = gamma5 @ D_naive + D_naive @ D_naive\n                    anticomm_wilson = gamma5 @ D_wilson + D_wilson @ gamma5\n                    \n                    # Spectral norms ||.||_2 (largest singular value)\n                    norm_D_naive = np.max(s_naive) if len(s_naive) > 0 else 0\n                    norm_D_wilson = np.max(s_wilson) if len(s_wilson) > 0 else 0\n                    \n                    # For anticommutator norm, need to compute SVD as well\n                    s_anticomm_naive = np.linalg.svd(anticomm_naive, compute_uv=False)\n                    norm_anticomm_naive = np.max(s_anticomm_naive) if len(s_anticomm_naive) > 0 else 0\n\n                    s_anticomm_wilson = np.linalg.svd(anticomm_wilson, compute_uv=False)\n                    norm_anticomm_wilson = np.max(s_anticomm_wilson) if len(s_anticomm_wilson) > 0 else 0\n\n                    # Calculate ratios and update maximums\n                    if norm_D_naive > 1e-12: # Avoid division by zero\n                        ratio_naive = norm_anticomm_naive / norm_D_naive\n                        if ratio_naive > max_ratio_naive:\n                            max_ratio_naive = ratio_naive\n                            \n                    if norm_D_wilson > 1e-12:\n                        ratio_wilson = norm_anticomm_wilson / norm_D_wilson\n                        if ratio_wilson > max_ratio_wilson:\n                            max_ratio_wilson = ratio_wilson\n                            \n        results.extend([count_naive, count_wilson, max_ratio_naive, max_ratio_wilson])\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for i, res in enumerate(results):\n        if i % 4  2: # Counts are integers\n            formatted_results.append(str(int(res)))\n        else: # Ratios are floats\n            formatted_results.append(f\"{res:.7f}\") # Format float for consistency\n            \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3530403"}]}