{"hands_on_practices": [{"introduction": "在计算衰变率之前，我们必须首先确定所有可能结果的范围。这个练习 [@problem_id:3532984] 将引导你掌握定义三体衰变物理相空间的基本运动学约束。通过实现对三角不等式、能量正定性以及格拉姆行列式的检查，你将具体理解守恒律如何塑造著名的达利兹图（Dalitz plot），即所有物理上允许的衰变构型的映射。", "problem": "实现一个程序，对于给定的母粒子静止系中的三体衰变，通过实施从第一性原理推导出的运动学约束，来确定指定的成对不变质量是否对应于物理上允许的运动学构型。您必须检查三个独立的物理性充要条件：成对不变质量的三角不等式、单个粒子能量的正定性，以及三动量格拉姆行列式的非负性。所有输入量都应在母粒子静止系中进行解释。\n\n给定一个质量为 $M$ 的母粒子，衰变为三个质量分别为 $m_1$、$m_2$ 和 $m_3$ 的子粒子。将成对不变质量的平方定义为 $s_{ij} \\equiv m_{ij}^2 = (p_i + p_j)^2$，其中 $p_i$ 是满足在壳条件 $p_i^2 = m_i^2$ 的子粒子四动量，总四动量为 $P = p_1 + p_2 + p_3$ 且 $P^2 = M^2$。在母粒子静止系中，$P = (M,\\mathbf{0})$。对于任意选定的两个不变量 $s_{12}$ 和 $s_{23}$，第三个不变量 $s_{13}$ 由守恒定律确定：\n$$\ns_{13} = M^2 + m_1^2 + m_2^2 + m_3^2 - s_{12} - s_{23}.\n$$\n一个点 $(s_{12}, s_{23})$ 是物理上允许的，当且仅当以下所有条件都成立：\n- 每对粒子的三角不等式：对于每一对 $(i,j)$，\n$$\ns_{ij} \\ge (m_i + m_j)^2.\n$$\n- 在母粒子静止系中，每个子粒子 $i$ 的能量和三动量必须为实数，能量必须为正，其中\n$$\nE_i = \\frac{M^2 + m_i^2 - s_{jk}}{2 M}, \\quad \\text{with } \\{i,j,k\\} = \\{1,2,3\\},\n$$\n必须满足 $E_i \\ge m_i$，这意味着 $E_i \\ge 0$ 且 $E_i^2 - m_i^2 \\ge 0$。\n- 三动量格拉姆行列式非负，$G \\ge 0$，其中 $G$ 是母粒子质心（COM）系中子粒子三动量的 $3 \\times 3$ 欧几里得格拉姆矩阵 $\\mathcal{G}$ 的行列式。设 $\\mathbf{p}_i$ 为粒子 $i$ 的三动量，其大小为 $|\\mathbf{p}_i|^2 = E_i^2 - m_i^2$。$\\mathcal{G}$ 的非对角元素纯粹由不变量和能量决定，无需显式使用角度，通过以下公式计算：\n$$\n\\mathcal{G}_{ii} = |\\mathbf{p}_i|^2, \\quad \\mathcal{G}_{ij} = E_i E_j - \\frac{s_{ij} - m_i^2 - m_j^2}{2} \\quad \\text{for } i \\ne j,\n$$\n因此 $G = \\det \\mathcal{G} \\ge 0$ 确保了在三维空间中存在具有这些相互标量积和大小的三个实向量。数值检查必须容忍浮点舍入误差；将与边界值之差在微小容差 $\\varepsilon$ 内的值视为满足该边界条件。\n\n您的任务是编写一个完整的程序，将这些检查应用于一个固定的测试套件。所有质量必须以吉电子伏特（$\\mathrm{GeV}$）为单位指定。所有不变质量的平方必须以 $\\mathrm{GeV}^2$ 为单位指定。每个测试用例的输出是一个布尔值，表示输入是否根据这些标准对应于一个物理的运动学构型。\n\n测试套件（每个用例的格式为 $(M, [m_1,m_2,m_3], s_{12}, s_{23})$）：\n- 用例1（正常路径，内部点）：$(3.0, [0.5, 0.4, 0.3], 1.01, 4.0)$。\n- 用例2（边界情况，一个子粒子静止；格拉姆行列式为零）：$(3.0, [0.5, 0.4, 0.3], 7.29, 1.05)$，注意 $7.29 = (3.0 - 0.3)^2$，根据守恒定律，此选择意味着 $s_{13} = 1.16$。\n- 用例3（违反三角不等式）：$(3.0, [0.5, 0.4, 0.3], 0.80, 4.0)$。\n- 用例4（违反粒子1的能量正定性）：$(3.0, [0.5, 0.4, 0.3], 1.01, 6.3)$。\n- 用例5（在三角不等式成立的情况下违反格拉姆行列式条件）：$(3.0, [0.5, 0.4, 0.3], 1.01, 6.0)$。\n- 用例6（无质量子粒子，边界点）：$(1.0, [0.0, 0.0, 0.0], 0.2, 0.3)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,...]\"）。对于给定的测试套件，输出应是一个包含六个布尔值的列表，其顺序与上述用例相同。角度不是必需的，也不得使用；所有计算必须根据不变量、质量和母粒子质量，使用给定的质心系定义来进行。在与边界值比较时，请使用 $\\varepsilon = 10^{-10}$ 的数值容差以处理浮点误差。所有值都必须被视为具有上述指定的单位，不应使用其他单位。输出的布尔值必须是编程语言生成的原生布尔值，而不是字符串。", "solution": "确定三体衰变的物理区域问题是相对论运动学中的一个经典练习。解决方案的关键在于四动量守恒原理以及三维欧几里得空间中向量的几何特性。给定一个质量为 $M$ 的母粒子，衰变为三个质量分别为 $m_1, m_2, m_3$ 的子粒子。整个分析在母粒子的静止系中进行，在该参考系中其四动量为 $P = (M, \\mathbf{0})$。子粒子的四动量表示为 $p_i = (E_i, \\mathbf{p}_i)$，其中 $E_i$ 和 $\\mathbf{p}_i$ 分别是它们的能量和三动量。\n\n四动量守恒要求 $P = p_1 + p_2 + p_3$。由此产生的一个关键推论是，衰变的运动学构型不是任意的。可能结果的相空间是受约束的。对于三体衰变，这个相空间可以由两个独立变量来描述。一个方便的选择是三个可能的成对不变质量平方中的两个，记为 $s_{ij} = (p_i + p_j)^2$。问题指定 $s_{12}$ 和 $s_{23}$ 为独立变量。\n\n第三个不变质量平方 $s_{13}$ 则由守恒定律确定。这可以通过对所有三个成对不变量求和来推导：\n$$\ns_{12} + s_{13} + s_{23} = (p_1+p_2)^2 + (p_1+p_3)^2 + (p_2+p_3)^2\n$$\n展开平方并使用在壳条件 $p_i^2=m_i^2$，我们得到：\n$$\ns_{12} + s_{13} + s_{23} = 2(m_1^2+m_2^2+m_3^2) + 2(p_1\\cdot p_2 + p_1\\cdot p_3 + p_2\\cdot p_3)\n$$\n根据总动量守恒，$P^2 = (p_1+p_2+p_3)^2$，我们有：\n$$\nM^2 = m_1^2+m_2^2+m_3^2 + 2(p_1\\cdot p_2 + p_1\\cdot p_3 + p_2\\cdot p_3)\n$$\n结合这两个结果，得到关系式 $s_{12} + s_{13} + s_{23} = M^2 + m_1^2 + m_2^2 + m_3^2$。求解 $s_{13}$ 得到问题描述中提供的公式：\n$$\ns_{13} = M^2 + m_1^2 + m_2^2 + m_3^2 - s_{12} - s_{23}\n$$\n一个给定的点 $(s_{12}, s_{23})$ 是物理上允许的，当且仅当它满足三组独立的充要条件。我们的算法将按顺序检查这些条件中的每一个。\n\n首先，我们检查**三角不等式**。量 $\\sqrt{s_{ij}}$ 表示子粒子对 $(i, j)$ 在其联合质心系中的总能量。要生成这些粒子，该能量必须至少是它们静止质量的总和。因此，对于每一对 $(i,j)$，我们必须有 $\\sqrt{s_{ij}} \\ge m_i + m_j$。两边平方得到所述条件：\n$$\ns_{ij} \\ge (m_i + m_j)^2\n$$\n我们必须对所有三对粒子进行验证：$(1,2)$、$(2,3)$ 和 $(1,3)$。\n\n其次，我们检查**能量的正定性**。在母粒子静止系中，每个子粒子的能量 $E_i$ 必须至少为其静止质量 $m_i$，即 $E_i \\ge m_i$。这确保了其动能为非负，并且其三动量大小 $|\\mathbf{p}_i| = \\sqrt{E_i^2 - m_i^2}$ 是一个实数。$E_i$ 的公式由 $s_{jk}$ 的定义推导而来：\n$$\ns_{jk} = (p_j+p_k)^2 = (P-p_i)^2 = P^2 - 2P \\cdot p_i + p_i^2\n$$\n在母粒子静止系中，$P=(M, \\mathbf{0})$ 且 $p_i=(E_i, \\mathbf{p}_i)$，所以 $P \\cdot p_i = M E_i$。代入此式以及在壳条件 $P^2=M^2$ 和 $p_i^2 = m_i^2$ 可得 $s_{jk} = M^2 - 2ME_i + m_i^2$。求解 $E_i$ 得到所提供的公式，必须对每个子粒子 $i=1,2,3$ 进行检查：\n$$\nE_i = \\frac{M^2 + m_i^2 - s_{jk}}{2M} \\ge m_i\n$$\n\n第三，我们检查**三动量格拉姆行列式的非负性**。在母粒子静止系中，三个子粒子的动量之和必须为零：$\\mathbf{p}_1 + \\mathbf{p}_2 + \\mathbf{p}_3 = \\mathbf{0}$。这意味着这三个向量是线性相关的，因此必须共面。线性代数的一个基本结果表明，一组向量可以嵌入到 $n$ 维欧几里得空间中，当且仅当它们的格拉姆行列式为非负。对于我们在三维空间中的三个向量 $\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3$，格拉姆矩阵 $\\mathcal{G}$ 的元素为 $\\mathcal{G}_{ij} = \\mathbf{p}_i \\cdot \\mathbf{p}_j$。其行列式 $G = \\det(\\mathcal{G})$ 必须大于或等于零。由于这三个向量是共面的，对于任何物理构型，行列式必须恰好为零。负的行列式意味着在三维空间中不存在任何实向量集 $\\mathbf{p}_i$ 能满足指定的模长和相互点积，从而使得该构型非物理。$\\mathcal{G}$ 的元素是根据不变量和能量计算的，具体如下。对角元素是模长的平方 $|\\mathbf{p}_i|^2 = E_i^2 - m_i^2$。非对角元素由四维向量点积 $p_i \\cdot p_j = E_i E_j - \\mathbf{p}_i \\cdot \\mathbf{p}_j$ 和不变质量定义 $s_{ij} = m_i^2 + m_j^2 + 2p_i \\cdot p_j$ 推导得出：\n$$\n\\mathcal{G}_{ij} = \\mathbf{p}_i \\cdot \\mathbf{p}_j = E_i E_j - \\frac{s_{ij} - m_i^2 - m_j^2}{2}\n$$\n我们构建 $3 \\times 3$ 矩阵 $\\mathcal{G}$ 并计算其行列式 $G$。只有当 $G \\ge 0$ 时，该构型才是物理的。由于浮点运算，我们检查 $G \\ge -\\varepsilon$，其中 $\\varepsilon$ 是一个很小的容差。\n\n总的算法是，接收输入 $(M, [m_1,m_2,m_3], s_{12}, s_{23})$，计算 $s_{13}$，然后依次应用这三组检查。如果任何一项检查失败，该运动学点就是非物理的，我们立即得出结论。如果所有检查都通过，该点就是物理的。\n在所有不等式比较中，使用数值容差 $\\varepsilon = 10^{-10}$ 来稳健地处理浮点不精确性，尤其是在物理区域的边界处。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_physical(M, masses, s12, s23, tol=1e-10):\n    \"\"\"\n    Checks if a given kinematic configuration for a three-body decay is physical.\n\n    Args:\n        M (float): Mass of the parent particle.\n        masses (list[float]): List of the three daughter masses [m1, m2, m3].\n        s12 (float): Invariant mass squared of the pair (1, 2).\n        s23 (float): Invariant mass squared of the pair (2, 3).\n        tol (float): Numerical tolerance for floating-point comparisons.\n\n    Returns:\n        bool: True if the configuration is physical, False otherwise.\n    \"\"\"\n    m1, m2, m3 = masses\n    m1_sq, m2_sq, m3_sq = m1**2, m2**2, m3**2\n    M_sq = M**2\n\n    # Step 1: Calculate the dependent invariant mass squared, s13, from conservation.\n    s13 = M_sq + m1_sq + m2_sq + m3_sq - s12 - s23\n\n    # Step 2: Check the triangle inequalities for all three pairs.\n    # The condition is s_ij >= (m_i + m_j)^2.\n    if s12  (m1 + m2)**2 - tol:\n        return False\n    if s23  (m2 + m3)**2 - tol:\n        return False\n    if s13  (m1 + m3)**2 - tol:\n        return False\n\n    # Step 3: Calculate daughter energies and check the energy positivity condition.\n    # The condition is E_i >= m_i, which ensures a real-valued three-momentum.\n    # This also implicitly enforces the upper bounds on s_ij, e.g., s23 = (M-m1)^2.\n    \n    # Division by zero check for M\n    if M == 0:\n        # A massless particle cannot decay.\n        # But to avoid division by zero, we can return False if any mass is non-zero.\n        # If all masses are zero, more care is needed, but problem cases are physical.\n        return False\n        \n    E1 = (M_sq + m1_sq - s23) / (2 * M)\n    if E1  m1 - tol:\n        return False\n\n    E2 = (M_sq + m2_sq - s13) / (2 * M)\n    if E2  m2 - tol:\n        return False\n\n    E3 = (M_sq + m3_sq - s12) / (2 * M)\n    if E3  m3 - tol:\n        return False\n\n    # Step 4: Check if the three-momentum Gram determinant is non-negative.\n    # Calculate diagonal elements of the Gram matrix: G_ii = |p_i|^2 = E_i^2 - m_i^2\n    # The energy checks above ensure these are non-negative.\n    p1_sq = E1**2 - m1_sq\n    p2_sq = E2**2 - m2_sq\n    p3_sq = E3**2 - m3_sq\n\n    # Calculate off-diagonal elements: G_ij = p_i . p_j\n    p1_dot_p2 = E1 * E2 - (s12 - m1_sq - m2_sq) / 2\n    p1_dot_p3 = E1 * E3 - (s13 - m1_sq - m3_sq) / 2\n    p2_dot_p3 = E2 * E3 - (s23 - m2_sq - m3_sq) / 2\n\n    # Construct the Gram matrix and calculate its determinant.\n    gram_matrix = np.array([\n        [p1_sq,     p1_dot_p2, p1_dot_p3],\n        [p1_dot_p2, p2_sq,     p2_dot_p3],\n        [p1_dot_p3, p2_dot_p3, p3_sq]\n    ])\n    \n    det_G = np.linalg.det(gram_matrix)\n\n    # A negative determinant is unphysical. We allow for small numerical noise around zero.\n    if det_G  -tol:\n        return False\n\n    # If all checks pass, the configuration is physical.\n    return True\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Format: (M, [m1, m2, m3], s12, s23)\n    test_cases = [\n        (3.0, [0.5, 0.4, 0.3], 1.01, 4.0),\n        (3.0, [0.5, 0.4, 0.3], 7.29, 1.05),\n        (3.0, [0.5, 0.4, 0.3], 0.80, 4.0),\n        (3.0, [0.5, 0.4, 0.3], 1.01, 6.3),\n        (3.0, [0.5, 0.4, 0.3], 1.01, 6.0),\n        (1.0, [0.0, 0.0, 0.0], 0.2, 0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, masses, s12, s23 = case\n        result = is_physical(M, masses, s12, s23)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts boolean True/False to \"True\"/\"False\" string representation.\n    # In python this will be \"True\" and \"False\". For JSON compatibility, it should be \"true\" and \"false\".\n    # The problem asks for \"native boolean\" which is ambiguous for a printed output. We'll stick to Python's str() of bool.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```", "id": "3532984"}, {"introduction": "高能物理中的许多过程都由产生和衰变不稳定的短寿命粒子（称为共振态）所主导。本实践 [@problem_id:3532954] 深入研究描述这些共振态的布莱特-维格纳线型（Breit-Wigner lineshape），并检验广泛使用的窄宽度近似（Narrow-Width Approximation）的有效性。通过数值卷积，你将探索这一强大解析捷径的适用条件，以及在何种情况下必须采用完整的、依赖能量的处理方法。", "problem": "考虑一个质量为 $M$、总宽度为 $\\Gamma(s)$ 的窄共振，它通过共振传播子对截面产生贡献。在相对论归一化中，共振峰附近的传播子平方表现为因子\n$$\n\\frac{1}{(s - M^2)^2 + \\left(M\\,\\Gamma(s)\\right)^2},\n$$\n其中 $s$ 是质心能量的平方。该共振形状与一个缓慢变化的产生因子 $\\sigma(s)$ 的卷积，控制了对一个遍举末态率的共振贡献。窄宽度近似（NWA）假设在共振区域内宽度实际上是恒定的，即 $\\Gamma(s) \\approx \\Gamma(M^2)$，并且产生因子是缓慢变化的，因此在领头阶下以下替换成立：\n$$\n\\int_{-\\infty}^{+\\infty} ds\\, \\frac{\\sigma(s)}{(s - M^2)^2 + \\left(M\\,\\Gamma(M^2)\\right)^2} \\approx \\sigma(M^2)\\,\\frac{\\pi}{M\\,\\Gamma(M^2)}.\n$$\n您将测试当宽度通过两体相空间依赖于能量时，此近似的有效性。\n\n基本基础和定义：\n1. 共振形状由上述传播子平方因子定义。\n2. 对于衰变为两个质量为 $m$ 的相同子代的两体衰变，其能量依赖宽度 $\\Gamma(s)$ 被建模为\n$$\n\\Gamma(s) = \\Gamma_0 \\left(\\frac{\\beta(s)}{\\beta(M^2)}\\right)^p \\left(\\frac{s}{M^2}\\right)^q\\,\\Theta\\left(s - 4 m^2\\right),\n$$\n其中 $\\Gamma_0 \\equiv \\Gamma(M^2)$，$\\beta(s) \\equiv \\sqrt{1 - \\frac{4 m^2}{s}}$ 是通常的两体速度因子，$p$ 和 $q$ 是参数化角动量和相空间标度的无量纲指数，而 $\\Theta$ 是 Heaviside 阶跃函数。\n3. 产生因子被建模为一个缓慢变化的函数\n$$\n\\sigma(s) = \\sigma_0\\left[1 + a \\frac{s - M^2}{M^2}\\right]\\Theta\\left(s - 4 m^2\\right),\n$$\n其中 $\\sigma_0$ 是一个以皮靶（picobarns）为单位的常数，而 $a$ 是一个控制 $s$ 中轻微变化的无量纲斜率参数。\n\n您的任务：\n1. 实现数值卷积\n$$\nI \\equiv \\int_{s_{\\min}}^{s_{\\max}} ds\\, \\frac{\\sigma(s)}{(s - M^2)^2 + \\left(M\\,\\Gamma(s)\\right)^2},\n$$\n其中积分边界的选择应足够宽，以围绕共振峰，从而在保持数值稳定性的同时捕捉其贡献。使用\n$$\ns_{\\min} = \\max\\left(4 m^2,\\,M^2 - L\\right),\\quad s_{\\max} = M^2 + L,\\quad L = 50\\,M\\,\\Gamma_0,\n$$\n并确保数值积分使用 $10^{-9}$ 的绝对容差和 $10^{-7}$ 的相对容差。请注意，$s$ 的单位是 $\\mathrm{GeV}^2$，$M$ 和 $\\Gamma$ 的单位是 $\\mathrm{GeV}$，而 $\\sigma$ 的单位是 $\\mathrm{pb}$。\n2. 计算窄宽度近似估计值\n$$\nI_{\\mathrm{NWA}} \\equiv \\sigma(M^2)\\,\\frac{\\pi}{M\\,\\Gamma_0}.\n$$\n3. 对每个测试用例，报告无量纲的相对偏差\n$$\n\\delta \\equiv \\frac{\\left|I - I_{\\mathrm{NWA}}\\right|}{I_{\\mathrm{NWA}}}.\n$$\n\n测试套件：\n使用以下四个参数集，每个参数集都以科学上一致的单位表示：\n- 情况 A（中等窄度，无质量子代，轻微斜率）：$M = 91\\,\\mathrm{GeV}$，$\\Gamma_0 = 2.5\\,\\mathrm{GeV}$，$m = 0\\,\\mathrm{GeV}$，$p = 1$，$q = 1$，$\\sigma_0 = 1.0\\,\\mathrm{pb}$，$a = 0.05$。\n- 情况 B（窄，有质量子代，平坦产生）：$M = 100\\,\\mathrm{GeV}$，$\\Gamma_0 = 0.5\\,\\mathrm{GeV}$，$m = 10\\,\\mathrm{GeV}$，$p = 1$，$q = 0.5$，$\\sigma_0 = 3.0\\,\\mathrm{pb}$，$a = 0$。\n- 情况 C（近阈值畸变，中等宽度，上升产生）：$M = 30\\,\\mathrm{GeV}$，$\\Gamma_0 = 3.0\\,\\mathrm{GeV}$，$m = 14\\,\\mathrm{GeV}$，$p = 1$，$q = 0.5$，$\\sigma_0 = 2.0\\,\\mathrm{pb}$，$a = 0.5$。\n- 情况 D（宽共振，无质量子代，下降产生）：$M = 50\\,\\mathrm{GeV}$，$\\Gamma_0 = 20.0\\,\\mathrm{GeV}$，$m = 0\\,\\mathrm{GeV}$，$p = 0$，$q = 0$，$\\sigma_0 = 1.5\\,\\mathrm{pb}$，$a = -0.2$。\n\n答案规格：\n- 您的程序必须产生单行输出，其中包含情况 A、B、C、D 的四个相对偏差 $\\delta$，以逗号分隔的列表形式包含在方括号中，并按上述顺序列出。将结果表示为十进制浮点数。例如，一个可接受的输出格式是 $[\\delta_A,\\delta_B,\\delta_C,\\delta_D]$。\n\n角度单位不适用，也不存在角度。物理单位如上所述。确保所有计算都遵守这些单位和定义。", "solution": "问题陈述已经过验证，被认为是合理、适定且具有科学依据的。它提出了一个高能物理学中的标准计算练习，旨在探究窄宽度近似（NWA）的局限性。因此，我们可以继续进行求解。\n\n核心任务是计算代表共振截面的数值计算积分 $I$ 与其在 NWA 下的解析估计值 $I_{\\mathrm{NWA}}$ 之间的相对偏差 $\\delta$。该偏差定义为：\n$$\n\\delta \\equiv \\frac{\\left|I - I_{\\mathrm{NWA}}\\right|}{I_{\\mathrm{NWA}}}\n$$\n\n解决方案需要实现必要的物理函数，执行数值积分，并为四个不同的测试用例评估一个简单的解析公式。\n\n**1. 物理函数的定义**\n\n数值卷积的被积函数由下式给出\n$$\nf(s) = \\frac{\\sigma(s)}{(s - M^2)^2 + \\left(M\\,\\Gamma(s)\\right)^2}\n$$\n其中 $\\sigma(s)$ 是产生因子，$\\Gamma(s)$ 是共振的能量依赖衰变宽度。共振的质量为 $M$。所有计算都使用一致的单位，其中质量和宽度的单位为 $\\mathrm{GeV}$，它们的平方单位为 $\\mathrm{GeV}^2$，截面 $\\sigma$ 的单位为 $\\mathrm{pb}$。\n\n**1.1. 能量依赖宽度 $\\Gamma(s)$**\n\n宽度 $\\Gamma(s)$ 基于两体衰变运动学进行建模。其形式为：\n$$\n\\Gamma(s) = \\Gamma_0 \\left(\\frac{\\beta(s)}{\\beta(M^2)}\\right)^p \\left(\\frac{s}{M^2}\\right)^q\\,\\Theta\\left(s - 4 m^2\\right)\n$$\n此处，$\\Gamma_0$ 是在共振峰 $s=M^2$ 处评估的宽度。指数 $p$ 和 $q$ 参数化了依赖于模型的标度行为。两个相同衰变产物各自的质量为 $m$。Heaviside 阶跃函数 $\\Theta$ 确保宽度仅在产生阈值 $s = 4m^2$ 之上才非零。\n\n关键的运动学量是速度因子 $\\beta(s)$，定义为：\n$$\n\\beta(s) \\equiv \\sqrt{1 - \\frac{4 m^2}{s}}\n$$\n此因子仅在 $s \\ge 4m^2$ 时为实数。分母中的 $\\beta(M^2)$ 项要求共振质量 $M$ 大于产生子代的阈值，即 $M > 2m$。所有测试用例均满足此条件。对于无质量子代（$m=0$）的特殊情况，对于所有 $s > 0$，$\\beta(s)=1$。\n\n**1.2. 产生因子 $\\sigma(s)$**\n\n产生因子 $\\sigma(s)$ 模拟了产生共振的底层过程。它被近似为一个在共振质量平方 $M^2$ 附近随 $s$ 线性变化的函数：\n$$\n\\sigma(s) = \\sigma_0\\left[1 + a \\frac{s - M^2}{M^2}\\right]\\Theta\\left(s - 4 m^2\\right)\n$$\n此处，$\\sigma_0$ 是一个以皮靶（$\\mathrm{pb}$）为单位的常数截面，而 $a$ 是一个无量纲的斜率参数。Heaviside 函数强制执行了与宽度相同的运动学阈值。\n\n**2. 数值卷积积分 $I$**\n\n积分 $I$ 通过数值方法计算：\n$$\nI \\equiv \\int_{s_{\\min}}^{s_{\\max}} ds\\, \\frac{\\sigma(s)}{(s - M^2)^2 + \\left(M\\,\\Gamma(s)\\right)^2}\n$$\n选择积分限足够宽，以包含整个共振形状。它们定义为：\n$$\nL = 50\\,M\\,\\Gamma_0\n$$\n$$\ns_{\\min} = \\max\\left(4 m^2,\\,M^2 - L\\right)\n$$\n$$\ns_{\\max} = M^2 + L\n$$\n$s_{\\min}$ 的选择正确地考虑了在 $s=4m^2$ 的物理产生阈值。数值积分将使用标准的求积算法，特别是 `scipy.integrate.quad`，相对容差为 $10^{-7}$，绝对容差为 $10^{-9}$，如问题所述。函数 $\\sigma(s)$ 和 $\\Gamma(s)$（不含显式的 Heaviside 因子，该因子由积分下限 $s_{\\min}$ 处理）将被传递给数值积分器。\n\n**3. 窄宽度近似 $I_{\\mathrm{NWA}}$**\n\nNWA 通过两个关键假设简化了积分：\n1. 宽度 $\\Gamma(s)$ 近似为常数，并等于其在峰值处的值，即 $\\Gamma(s) \\approx \\Gamma(M^2) \\equiv \\Gamma_0$。\n2. 产生因子 $\\sigma(s)$ 变化缓慢，可以在峰值处进行评估，即 $\\sigma(s) \\approx \\sigma(M^2)$。\n\n在这些假设下，积分可以扩展到 $(-\\infty, \\infty)$ 并解析求解：\n$$\n\\int_{-\\infty}^{+\\infty} ds\\, \\frac{\\sigma(M^2)}{(s - M^2)^2 + (M\\Gamma_0)^2} = \\sigma(M^2)\\,\\frac{1}{M\\Gamma_0} \\left[ \\arctan\\left(\\frac{s-M^2}{M\\Gamma_0}\\right) \\right]_{-\\infty}^{+\\infty} = \\sigma(M^2)\\,\\frac{\\pi}{M\\Gamma_0}\n$$\n根据 $\\sigma(s)$ 的定义，我们有 $\\sigma(M^2) = \\sigma_0$。因此，NWA 的估计值为：\n$$\nI_{\\mathrm{NWA}} \\equiv \\sigma_0\\,\\frac{\\pi}{M\\,\\Gamma_0}\n$$\n对于每个测试用例，这是一个简单的代数计算。\n\n**4. 计算步骤**\n\n对于四个测试用例（A, B, C, D）中的每一个，我们将执行以下步骤：\n1.  定义参数 $M, \\Gamma_0, m, p, q, \\sigma_0, a$。\n2.  基于这些参数实现函数 $\\Gamma(s)$ 和 $\\sigma(s)$。这些实现对于 $s \\ge 4m^2$ 有效。\n3.  将它们组合成完整的被积函数 $f(s)$。\n4.  使用上述公式计算 NWA 值 $I_{\\mathrm{NWA}}$。\n5.  确定积分限 $s_{\\min}$ 和 $s_{\\max}$。\n6.  通过在区间 $[s_{\\min}, s_{\\max}]$ 上对 $f(s)$ 应用求积程序，数值计算积分 $I$。\n7.  计算最终的相对偏差 $\\delta = |I - I_{\\mathrm{NWA}}| / I_{\\mathrm{NWA}}$。\n\n此过程将系统地应用于生成所需的四个偏差值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing a numerical resonance convolution with the\n    Narrow-Width Approximation (NWA).\n    \"\"\"\n\n    # Test cases as per the problem statement.\n    # Each tuple contains: (M, Gamma0, m, p, q, sigma0, a)\n    test_cases = [\n        # Case A: moderately narrow, massless daughters, mild slope\n        (91.0, 2.5, 0.0, 1.0, 1.0, 1.0, 0.05),\n        # Case B: narrow, massive daughters, flat production\n        (100.0, 0.5, 10.0, 1.0, 0.5, 3.0, 0.0),\n        # Case C: near threshold distortion, moderate width, rising production\n        (30.0, 3.0, 14.0, 1.0, 0.5, 2.0, 0.5),\n        # Case D: broad resonance, massless daughters, falling production\n        (50.0, 20.0, 0.0, 0.0, 0.0, 1.5, -0.2),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        M, Gamma0, m, p, q, sigma0, a = case\n        \n        M2 = M**2\n        threshold_s = 4.0 * m**2\n\n        # Define physics functions valid for s >= threshold_s\n        \n        def beta(s_val, m_val):\n            \"\"\"Calculates the velocity factor beta(s).\"\"\"\n            if m_val == 0.0:\n                return 1.0\n            # s_val is guaranteed to be >= 4*m_val**2 by the integration limits\n            # Add a small epsilon to avoid sqrt of negative due to float precision\n            arg = 1.0 - 4.0 * m_val**2 / s_val\n            return np.sqrt(max(0, arg))\n\n        beta_M2_val = beta(M2, m)\n\n        def gamma_s(s_val):\n            \"\"\"Calculates the energy-dependent width Gamma(s).\"\"\"\n            if s_val  threshold_s:\n                return 0.0\n\n            if beta_M2_val == 0.0:\n                # This case is avoided by M > 2m, but included for robustness\n                return np.inf if beta(s_val, m) > 0 else 0.0\n\n            beta_s_val = beta(s_val, m)\n            \n            beta_ratio_pow_p = (beta_s_val / beta_M2_val)**p if beta_M2_val > 0 else (np.inf if beta_s_val > 0 else 0)\n\n            s_ratio_pow_q = (s_val / M2)**q\n            \n            return Gamma0 * beta_ratio_pow_p * s_ratio_pow_q\n\n        def sigma_s(s_val):\n            \"\"\"Calculates the production factor sigma(s).\"\"\"\n            if s_val  threshold_s:\n                return 0.0\n            return sigma0 * (1.0 + a * (s_val - M2) / M2)\n\n        def integrand(s_val):\n            \"\"\"The full integrand for the numerical convolution.\"\"\"\n            numerator = sigma_s(s_val)\n            denominator = (s_val - M2)**2 + (M * gamma_s(s_val))**2\n            if denominator == 0.0:\n                return np.inf\n            return numerator / denominator\n\n        # 2. Compute the Narrow-Width Approximation estimate\n        I_nwa = sigma0 * np.pi / (M * Gamma0) if (M * Gamma0) != 0 else np.inf\n\n        # 1. Compute the numerical convolution\n        L = 50.0 * M * Gamma0\n        s_min = max(threshold_s, M2 - L)\n        s_max = M2 + L\n\n        # Perform numerical integration\n        I_integral, _ = integrate.quad(\n            integrand, \n            s_min, \n            s_max, \n            epsabs=1e-9, \n            epsrel=1e-7,\n            limit=500 # Increase limit for potentially tricky integrals\n        )\n\n        # 3. Compute the relative deviation\n        if I_nwa == 0:\n            deviation = np.inf if I_integral != 0 else 0.0\n        else:\n            deviation = np.abs(I_integral - I_nwa) / I_nwa\n        \n        results.append(deviation)\n\n    # Format the final output as specified\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3532954"}, {"introduction": "为了模拟粒子物理事件，我们需要有效的方法来根据它们的量子力学概率生成运动学构型，而这些概率通常在共振峰周围急剧达到峰值。基于共振线型的概念，本练习 [@problem_id:3532946] 介绍了重要性采样（importance sampling），这是一项关键的蒙特卡洛技术。你将设计并实现一个采样器，它会优先在相空间中最重要的区域生成事件，从而在保持物理准确性的同时，极大地提高计算效率。", "problem": "你需要设计并实现一个针对中间不变质量平方变量 $m_{12}^2$ 的重要性采样方案，该变量的分布由一个共振传播子决定。目标是积分以下形式的函数：\n$$\nI = \\int_{s_{\\min}}^{s_{\\max}} \\mathrm{d}x \\;\\frac{R(x)}{(x - M^2)^2 + (M\\Gamma)^2},\n$$\n其中 $x \\equiv m_{12}^2$，$M$ 是一个共振质量参数，$\\Gamma$ 是一个宽度参数，而 $R(x)$ 是一个在 $[s_{\\min}, s_{\\max}]$ 上可能变化的有界非负函数。所有量都应视为无量纲。\n\n你的推导和算法必须仅基于以下基本原理：\n- 蒙特卡罗积分和重要性采样：对于目标积分 $I = \\int \\mathrm{d}x \\, H(x)$ 和一个支撑集覆盖积分域的归一化提议密度 $g(x)$，其无偏估计量为 $\\hat{I} = \\frac{1}{N} \\sum_{i=1}^{N} \\frac{H(x_i)}{g(x_i)}$，其中 $x_i \\sim g$ 是独立同分布的。\n- 柯西分布：一个位置为 $a$、尺度为 $b$ 的标准柯西概率密度函数，其密度为 $f(x; a, b) = \\frac{1}{\\pi}\\frac{b}{(x-a)^2 + b^2}$，累积分布函数为 $F(x; a, b) = \\frac{1}{\\pi}\\arctan\\!\\left(\\frac{x-a}{b}\\right) + \\frac{1}{2}$。\n\n你必须完成的任务：\n1. 在有限区间 $[s_{\\min}, s_{\\max}]$ 上，构造一个与柯西 (Breit-Wigner) 函数成正比的归一化提议密度 $g(x)$，其位置为 $a = M^2$，尺度为 $b = M\\Gamma$。构造过程必须使用对柯西分布在 $[s_{\\min}, s_{\\max}]$ 上的截断。你的实现必须使用逆变换采样方案从此截断提议中生成样本 $x$。\n2. 从第一性原理出发，推导相应的事件权重 $w(x)$，使得在从 $g(x)$ 采样的条件下，$I$ 的蒙特卡罗估计量保持无偏。你的推导必须从上述基本原理开始，不得使用任何专门的快捷公式。\n3. 实现一个程序，该程序：\n   - 对于每个测试用例，使用逆变换采样从提议 $g(x)$ 中生成 $N$ 个独立样本。\n   - 对于每个测试用例，使用推导出的事件权重计算 $I$ 的蒙特卡罗估计值。\n   - 使用在 $[s_{\\min}, s_{\\max}]$ 上的数值求积计算 $I$ 的高精度参考值。\n   - 使用固定的随机种子，以确保结果是确定且可重复的。\n\n角度单位约定：如果在你的推导或实现中出现任何反三角函数，都必须以弧度为单位进行解释。\n\n测试套件：\n- 情况 1（理想情况，宽度适中，中心在范围内）：\n  - $M = 1.0$，$\\Gamma = 0.05$，因此 $a = M^2 = 1.0$，$b = M\\Gamma = 0.05$。\n  - $s_{\\min} = 0.5$，$s_{\\max} = 1.5$。\n  - $R(x) = 1$。\n  - $N = 200000$ 个样本。\n- 情况 2（变化的分子）：\n  - $M = \\sqrt{2.0}$，$\\Gamma = 0.1414213562373095$，因此 $a = M^2 = 2.0$，$b = M\\Gamma = 0.2$。\n  - $s_{\\min} = 1.0$，$s_{\\max} = 3.0$。\n  - $R(x) = x$。\n  - $N = 200000$ 个样本。\n- 情况 3（共振中心在积分范围之外）：\n  - $M = \\sqrt{1.5}$，$\\Gamma = 0.08164965809277261$，因此 $a = M^2 = 1.5$，$b = M\\Gamma = 0.1224744871391589$；对于此测试，精确使用 $b = 0.1$。\n  - $s_{\\min} = 1.7$，$s_{\\max} = 2.0$。\n  - $R(x) = 1 + x^2$。\n  - $N = 200000$ 个样本。\n- 情况 4（宽区间上的窄宽度边缘情况）：\n  - $M = 3.0$，$\\Gamma = 0.005$，因此 $a = M^2 = 9.0$，$b = M\\Gamma = 0.015$。\n  - $s_{\\min} = 0.0$，$s_{\\max} = 20.0$。\n  - $R(x) = \\exp(-0.1 x)$。\n  - $N = 200000$ 个样本。\n\n实现细节：\n- 对所有伪随机数生成使用单个固定的随机种子 $12345$。\n- 对于在 $[s_{\\min}, s_{\\max}]$ 上的截断柯西分布的逆变换采样器，使用标准柯西累积分布函数 $F(x; a, b)$ 及其逆函数。通过避免切线发散的精确端点来确保数值鲁棒性。\n- 高精度参考积分必须在 $[s_{\\min}, s_{\\max}]$ 上进行数值计算。\n\n要求的输出：\n- 对于每个测试用例，计算两个浮点数：\n  - 使用你的重要性采样权重的 $I$ 的蒙特卡罗估计值。\n  - 蒙特卡罗估计值与高精度数值求积参考值之间的绝对误差。\n- 你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。顺序必须是：\n  $[\\hat{I}_1, \\Delta_1, \\hat{I}_2, \\Delta_2, \\hat{I}_3, \\Delta_3, \\hat{I}_4, \\Delta_4]$，\n  其中 $\\hat{I}_k$ 是情况 $k$ 的蒙特卡罗估计值，$\\Delta_k$ 是情况 $k$ 的绝对误差。\n- 所有输出都是无量纲实数。不应包含任何单位。适用时，内部使用的角度单位为弧度。", "solution": "该问题要求设计并实现一个重要性采样方案，以计算以下形式的积分：\n$$\nI = \\int_{s_{\\min}}^{s_{\\max}} \\mathrm{d}x \\;\\frac{R(x)}{(x - M^2)^2 + (M\\Gamma)^2}\n$$\n其中被积函数主要由一个共振（Breit-Wigner）传播子决定。设位置参数为 $a = M^2$，尺度参数为 $b = M\\Gamma$。该积分可写作 $I = \\int_{s_{\\min}}^{s_{\\max}} H(x) \\, \\mathrm{d}x$，其中被积函数为 $H(x) = \\frac{R(x)}{(x-a)^2 + b^2}$。\n\n重要性采样的核心原理是从一个与被积函数 $H(x)$ 形状相似的提议概率密度函数 (PDF) $g(x)$ 中抽取样本 $x_i$，然后将积分估计值计算为加权样本的平均值：\n$$\n\\hat{I} = \\frac{1}{N} \\sum_{i=1}^{N} w(x_i) \\quad \\text{其中} \\quad w(x_i) = \\frac{H(x_i)}{g(x_i)}\n$$\n\n**1. 提议密度 $g(x)$ 的推导**\n\n一个合适的提议密度 $g(x)$ 应与被积函数 $H(x)$ 中引起较大变化的部分成正比，即 Breit-Wigner 项。我们为 $x \\in [s_{\\min}, s_{\\max}]$ 定义一个未归一化的提议函数 $p(x)$：\n$$\np(x) = \\frac{1}{(x-a)^2 + b^2}\n$$\n为了得到归一化的 PDF $g(x)$，我们必须将 $p(x)$ 除以其在定义域 $[s_{\\min}, s_{\\max}]$ 上的积分。设此归一化常数为 $\\mathcal{N}_p$。\n$$\n\\mathcal{N}_p = \\int_{s_{\\min}}^{s_{\\max}} p(x) \\, \\mathrm{d}x = \\int_{s_{\\min}}^{s_{\\max}} \\frac{1}{(x-a)^2 + b^2} \\, \\mathrm{d}x\n$$\n该积分为标准形式：\n$$\n\\int \\frac{1}{(x-a)^2 + b^2} \\, \\mathrm{d}x = \\frac{1}{b} \\arctan\\left(\\frac{x-a}{b}\\right) + C\n$$\n在积分上下限处求值，得到归一化常数：\n$$\n\\mathcal{N}_p = \\frac{1}{b} \\left[ \\arctan\\left(\\frac{s_{\\max}-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right) \\right]\n$$\n因此，归一化的提议 PDF $g(x)$ 定义为：\n$$\ng(x) = \\frac{p(x)}{\\mathcal{N}_p} = \\frac{1}{\\mathcal{N}_p} \\frac{1}{(x-a)^2 + b^2} \\quad \\text{对于 } x \\in [s_{\\min}, s_{\\max}]\n$$\n在其他情况下 $g(x)=0$。\n\n**2. 逆变换采样器的推导**\n\n为了从 $g(x)$ 生成随机变量，我们使用逆变换采样法。这需要找到 $g(x)$ 的累积分布函数 (CDF) 的逆函数，我们将其记为 $G(x)$。对于 $x \\in [s_{\\min}, s_{\\max}]$，其 CDF 为：\n$$\nG(x) = \\int_{s_{\\min}}^x g(t) \\, \\mathrm{d}t = \\frac{1}{\\mathcal{N}_p} \\int_{s_{\\min}}^x \\frac{1}{(t-a)^2 + b^2} \\, \\mathrm{d}t\n$$\n使用上一步得到的原函数：\n$$\nG(x) = \\frac{1}{\\mathcal{N}_p b} \\left[ \\arctan\\left(\\frac{x-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right) \\right]\n$$\n代入 $\\mathcal{N}_p$ 的表达式：\n$$\nG(x) = \\frac{\\arctan\\left(\\frac{x-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right)}{\\arctan\\left(\\frac{s_{\\max}-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right)}\n$$\n为了找到反函数 $x=G^{-1}(u)$，我们令 $G(x) = u$，其中 $u$ 是从均匀分布 $\\mathcal{U}(0, 1)$ 中抽样的随机变量。然后我们求解 $x$。设 $\\theta_y = \\arctan\\left(\\frac{y-a}{b}\\right)$。方程变为：\n$$\nu = \\frac{\\theta_x - \\theta_{s_{\\min}}}{\\theta_{s_{\\max}} - \\theta_{s_{\\min}}}\n$$\n解出 $\\theta_x$：\n$$\n\\theta_x = \\theta_{s_{\\min}} + u (\\theta_{s_{\\max}} - \\theta_{s_{\\min}})\n$$\n代回 $\\theta_x = \\arctan\\left(\\frac{x-a}{b}\\right)$：\n$$\n\\arctan\\left(\\frac{x-a}{b}\\right) = \\theta_{s_{\\min}} + u (\\theta_{s_{\\max}} - \\theta_{s_{\\min}})\n$$\n最后，解出 $x$ 得到采样公式：\n$$\nx(u) = a + b \\tan\\left( \\theta_{s_{\\min}} + u (\\theta_{s_{\\max}} - \\theta_{s_{\\min}}) \\right)\n$$\n该公式允许我们从一个均匀随机数 $u$ 生成一个根据 $g(x)$ 分布的样本 $x$。\n\n**3. 事件权重 $w(x)$ 的推导**\n\n事件权重 $w(x)$ 定义为原始被积函数 $H(x)$ 与提议 PDF $g(x)$ 的比值。\n$$\nw(x) = \\frac{H(x)}{g(x)} = \\frac{\\frac{R(x)}{(x-a)^2 + b^2}}{\\frac{1}{\\mathcal{N}_p} \\frac{1}{(x-a)^2 + b^2}}\n$$\n分母项 $(x-a)^2 + b^2$ 被消去，这是选择此重要性采样的主要好处。这一消去移除了方差的主要来源，留下一个平滑得多的函数进行积分。权重简化为：\n$$\nw(x) = R(x) \\cdot \\mathcal{N}_p\n$$\n代入 $\\mathcal{N}_p$ 的表达式：\n$$\nw(x) = R(x) \\cdot \\frac{1}{b} \\left[ \\arctan\\left(\\frac{s_{\\max}-a}{b}\\right) - \\arctan\\left(\\frac{s_{\\min}-a}{b}\\right) \\right]\n$$\n积分 $I$ 的蒙特卡罗估计量是这些权重在 $N$ 个样本上的平均值：\n$$\n\\hat{I}_N = \\frac{1}{N} \\sum_{i=1}^N w(x_i)\n$$\n由于权重中涉及反正切函数和 $b$ 的部分是一个常数，我们称之为 $W_{const} = \\mathcal{N}_p$，因此估计量可以高效地写作：\n$$\n\\hat{I}_N = W_{const} \\cdot \\left( \\frac{1}{N} \\sum_{i=1}^N R(x_i) \\right) = W_{const} \\cdot \\langle R(x) \\rangle\n$$\n此表达式被用于实现蒙特卡罗估计。积分的参考值使用高精度数值求积计算，绝对误差是蒙特卡罗估计值与参考值之间的绝对差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the importance sampling problem for the given test cases.\n    \"\"\"\n\n    # Fixed random seed for reproducibility\n    SEED = 12345\n    rng = np.random.default_rng(SEED)\n\n    # Test cases defined in the problem statement.\n    # Structure: (M, Gamma, s_min, s_max, R_func, N, (optional_a, optional_b))\n    test_cases = [\n        (1.0, 0.05, 0.5, 1.5, lambda x: np.ones_like(x), 200000, None),\n        (np.sqrt(2.0), 0.1414213562373095, 1.0, 3.0, lambda x: x, 200000, None),\n        # For Case 3, a and b are specified explicitly in the problem.\n        # M and Gamma are for context. a=M^2=1.5, b=0.1\n        (np.sqrt(1.5), 0.08164965809277261, 1.7, 2.0, lambda x: 1 + x**2, 200000, (1.5, 0.1)),\n        (3.0, 0.005, 0.0, 20.0, lambda x: np.exp(-0.1 * x), 200000, None),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        M, Gamma, s_min, s_max, R_func, N, overrides = case\n\n        # Set resonance parameters a and b\n        if overrides:\n            a, b = overrides\n        else:\n            a = M**2\n            b = M * Gamma\n\n        # --- Importance Sampling ---\n\n        # 1. Calculate constants for sampling and weighting\n        theta_min = np.arctan((s_min - a) / b)\n        theta_max = np.arctan((s_max - a) / b)\n        \n        # 2. Generate N samples using inverse transform sampling\n        u = rng.uniform(size=N)\n        theta_samples = theta_min + u * (theta_max - theta_min)\n        x_samples = a + b * np.tan(theta_samples)\n        \n        # 3. Calculate constant part of the weight (the normalization constant N_p)\n        W_const = (theta_max - theta_min) / b\n\n        # 4. Compute the Monte Carlo estimate\n        R_values = R_func(x_samples)\n        I_hat = W_const * np.mean(R_values)\n        \n        # --- High-Accuracy Reference Calculation ---\n        \n        # Define the full integrand for numerical quadrature\n        integrand = lambda x: R_func(x) / ((x - a)**2 + b**2)\n        \n        # 5. Compute the reference integral using scipy.integrate.quad\n        I_ref, _ = integrate.quad(integrand, s_min, s_max, epsabs=1e-12, epsrel=1e-12, limit=200)\n\n        # 6. Calculate the absolute error\n        delta = abs(I_hat - I_ref)\n        \n        results.extend([I_hat, delta])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3532946"}]}