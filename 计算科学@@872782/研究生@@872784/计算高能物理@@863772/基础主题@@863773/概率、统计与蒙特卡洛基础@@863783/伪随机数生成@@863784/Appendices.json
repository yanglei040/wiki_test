{"hands_on_practices": [{"introduction": "蒙特卡洛积分依赖于一个基本假设：伪随机数生成器能均匀地对定义域进行采样。然而，所有伪随机数生成器都具有潜在的结构性，例如线性同余生成器（LCG）的点会分布在规则的晶格上。本练习将通过一个精心设计的积分函数，戏剧性地揭示这种结构性如何与待解问题发生灾难性的共振，你将亲眼见证蒙特卡洛估计收敛到一个完全错误的答案，从而深刻理解选择和检验生成器的重要性。[@problem_id:3333392]", "problem": "考虑由下式定义的乘法线性同余生成器 (LCG)\n$$x_{k+1} \\equiv a\\,x_{k} \\pmod{m},$$\n其模为 $m = 2^{31}-1$，乘数为 $a = 16807$，种子为 $x_{0} \\in \\{1,2,\\dots,m-1\\}$。假设 $a$ 是模 $m$ 的一个本原根，因此其周期为 $m-1$。输出映射为 $u_{k} = x_{k}/m \\in (0,1)$，从而得到一个伪随机数生成器 (PRNG)。\n\n定义蒙特卡洛估计量\n$$\\widehat{I}_{n} = \\frac{1}{n}\\sum_{k=1}^{n} f(u_{k}),$$\n用于积分\n$$I = \\int_{0}^{1} f(u)\\,du,$$\n其中被积函数为\n$$f(u) = \\cos\\!\\big(2\\pi m\\,u\\big).$$\n\n从线性同余生成器和蒙特卡洛估计的核心定义出发，并且在不假设除给定信息外的任何特殊结构的情况下，构建逻辑步骤以确定渐进偏差\n$$b \\equiv \\lim_{n\\to\\infty} \\widehat{I}_{n} - I.$$\n你的最终答案必须是一个实数。如果需要任何中间数值近似，请不要四舍五入。最终答案不需要单位。", "solution": "目标是确定渐进偏差，其定义为 $b \\equiv \\lim_{n\\to\\infty} \\widehat{I}_{n} - I$。这需要计算两个量：积分的真值 $I$ 和蒙特卡洛估计量的渐进极限 $\\lim_{n\\to\\infty} \\widehat{I}_{n}$。\n\n首先，我们计算积分 $I$ 的真值。该积分定义为：\n$$I = \\int_{0}^{1} f(u)\\,du = \\int_{0}^{1} \\cos(2\\pi m u)\\,du$$\n为了计算这个积分，我们可以使用换元法。令 $v = 2\\pi m u$，这意味着 $du = \\frac{dv}{2\\pi m}$。积分限从 $u=0$ 变为 $v=0$，从 $u=1$ 变为 $v=2\\pi m$。\n$$I = \\int_{0}^{2\\pi m} \\cos(v) \\frac{dv}{2\\pi m} = \\frac{1}{2\\pi m} [\\sin(v)]_{0}^{2\\pi m}$$\n给定模数 $m = 2^{31}-1$ 是一个整数。因此，积分上限 $2\\pi m$ 是 $2\\pi$ 的整数倍。正弦函数在所有 $2\\pi$ 的整数倍处的值都为零。\n$$I = \\frac{1}{2\\pi m} (\\sin(2\\pi m) - \\sin(0)) = \\frac{1}{2\\pi m} (0 - 0) = 0$$\n因此，积分的精确值为 $I=0$。\n\n接下来，我们必须确定蒙特卡洛估计量的渐进极限 $\\lim_{n\\to\\infty} \\widehat{I}_{n}$。该估计量由下式给出：\n$$\\widehat{I}_{n} = \\frac{1}{n}\\sum_{k=1}^{n} f(u_{k})$$\n要求值的函数是 $f(u) = \\cos(2\\pi m u)$。伪随机数 $u_k$ 是通过输出映射 $u_k = x_k/m$ 生成的，其中 $x_k$ 是来自线性同余生成器 (LCG) 的状态序列。\n让我们分析和中的单项 $f(u_k)$：\n$$f(u_k) = f(x_k/m) = \\cos\\left(2\\pi m \\frac{x_k}{m}\\right) = \\cos(2\\pi x_k)$$\nLCG 由 $x_{k+1} \\equiv a x_k \\pmod{m}$ 定义。种子为 $x_0 \\in \\{1, 2, \\dots, m-1\\}$。由于模数 $m$ 是素数，且乘数 $a$ 是模 $m$ 的一个本原根，序列 $\\{x_k\\}_{k \\ge 1}$ 会遍历集合 $\\{1, 2, \\dots, m-1\\}$ 中的所有整数。关键在于，每个状态 $x_k$ 都是一个整数。\n\n对于任意整数值 $j$，余弦函数在 $2\\pi j$ 处的值为：\n$$\\cos(2\\pi j) = 1$$\n由于对所有 $k \\ge 1$，每个状态 $x_k$ 都是一个整数，我们有：\n$$f(u_k) = \\cos(2\\pi x_k) = 1 \\quad \\text{for all } k \\ge 1$$\n蒙特卡洛和中的每一项都精确地等于 1。将此结果代回估计量 $\\widehat{I}_n$ 的表达式中：\n$$\\widehat{I}_{n} = \\frac{1}{n}\\sum_{k=1}^{n} 1 = \\frac{1}{n} \\cdot n = 1$$\n这个结果对任何样本大小 $n \\ge 1$ 都成立。估计量序列是常数，即对所有 $n$ 都有 $\\widehat{I}_n = 1$。因此，极限的计算是微不足道的：\n$$\\lim_{n\\to\\infty} \\widehat{I}_{n} = \\lim_{n\\to\\infty} 1 = 1$$\n问题陈述指出生成器的周期是 $m-1$。这保证了序列 $\\{u_k\\}$ 是周期性的，从而确保极限 $\\lim_{n\\to\\infty} \\widehat{I}_n$ 存在，并且等于 $f(u_k)$ 在一个完整周期内的平均值。虽然这个信息对于严格证明极限的存在性很有用，但我们对 $f(u_k)$ 的直接计算表明，每一项都恒等于 1，这使得极限的计算非常直接。\n\n最后，我们可以计算渐进偏差 $b$。\n$$b = \\lim_{n\\to\\infty} \\widehat{I}_{n} - I$$\n代入我们求得的值：\n$$b = 1 - 0 = 1$$\n渐进偏差精确地为 $1$。这说明了对于这个特定的被积函数，这个特定的 PRNG 存在一个严重的缺陷。生成的点 $u_k=x_k/m$ 的离散性与函数 $f(u)=\\cos(2\\pi m u)$ 的高频特性完美地吻合，导致蒙特卡洛方法系统性地只在函数的最大值点进行采样。", "answer": "$$\\boxed{1}$$", "id": "3333392"}, {"introduction": "高能物理中的大规模模拟常常需要将随机数流分割以进行并行处理。为确保可复现性并避免流之间的关联，我们需要一种能高效地在序列中向前“跳转”巨大步数的方法。本练习将引导你推导并实现“跨步”（skip-ahead）算法，你将利用线性同余生成器的代数结构，开发一个复杂度为 $\\mathcal{O}(\\log n)$ 的方法，将一个对于巨大的 $n$ 而言不可能完成的任务，变为一个可行的计算。[@problem_id:3529403]", "problem": "你的任务是为线性同余生成器（LCG）形式化并实现一种高效的跳步（skip-ahead）方法。LCG 是一种在计算高能物理（HEP）中广泛使用的伪随机数生成器，尤其适用于大规模蒙特卡洛事件生成，在这种场景下，可复现性、并行性和流分区至关重要。其基本过程是 LCG 在整数上对一个正整数模数进行的递推：\n- 状态更新由 $x_{t+1} = (a x_t + c) \\bmod m$ 给出，适用于所有整数 $t \\ge 0$。其中，参数 $a$、$c$ 和 $m$ 是固定的整数，满足 $m \\ge 2$，且 $x_t \\in \\{0,1,\\dots,m-1\\}$。\n\n从 LCG 的这个基本定义和模算术的标准性质（例如加法和乘法在模 $m$ 意义下的结合律和分配律）出发，推导出一个关于 $x_{t+n}$ 的闭式表达式，该表达式是 $a$、$c$、$m$、$x_t$ 和 $n$ 的函数。推导过程中不假设 $m$ 具有任何特殊的数论性质（不要假设素性或互素条件）。你的推导必须从递推定义开始，且不能假定任何已知的闭式解。所得公式必须对所有整数 $n \\ge 0$ 有效，包括 $a = 1$ 和 $c = 0$ 等特殊情况。\n\n然后，设计一个计算 $x_{t+n}$ 的算法，其时间复杂度为 $n$ 的多对数，具体来说，其渐进复杂度为 $\\mathcal{O}(\\log n)$ 次模 $m$ 的算术运算，从而当 $n$ 大至 $10^{12}$ 时，该算法在计算上仍然可行。该算法必须避免使用模逆元，并且对于任意 $m$（包括 2 的幂次的 $m$）都应是正确的。你的设计必须基于第一性原理，并且必须明确指出被求幂的代数结构。\n\n最后，将你的算法实现为一个完整的程序，为以下测试套件生成输出。每个测试用例都是独立的。对每个用例，计算所要求的单个结果，并将所有结果按指定的输出格式收集起来。\n\n测试套件：\n- 用例 A (恒等边界)：参数 $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 0$。输出整数 $x_{t+n}$。\n- 用例 B (单步检查)：参数 $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 1$。输出整数 $x_{t+n}$。\n- 用例 C (两步检查)：参数 $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 2$。输出整数 $x_{t+n}$。\n- 用例 D (大 $n$ 与小素数模数)：参数 $m = 97$, $a = 5$, $c = 3$, $x_t = 42$, $n = 10^{12}$。输出整数 $x_{t+n}$。\n- 用例 E (大 $n$ 与实践中使用的 2 的幂次模数)：参数 $m = 2^{48}$, $a = 25214903917$, $c = 11$, $x_t = 0$, $n = 10^{12}$。输出整数 $x_{t+n}$。\n- 用例 F (乘法生成器边缘情况)：参数 $m = 2^{48}$, $a = 25214903917$, $c = 0$, $x_t = 1$, $n = 10^{12}$。输出整数 $x_{t+n}$。\n- 用例 G (退化乘数 $a = 1$ 边缘情况)：参数 $m = 1{,}000{,}000{,}007$, $a = 1$, $c = 123{,}456{,}789$, $x_t = 987{,}654{,}321$, $n = 10^{12}$。输出整数 $x_{t+n}$。\n- 用例 H (半群一致性属性，布尔值)：参数 $m = 2^{48}$, $a = 25214903917$, $c = 11$, $x_t = 123{,}456{,}789{,}012{,}345$, $n_1 = 10^{12} - 1{,}234{,}567$, $n_2 = 1{,}234{,}567$。计算一个布尔真值，判断 $x_{t+(n_1+n_2)}$ 是否等于先跳步 $n_1$ 再跳步 $n_2$ 的结果，即判断\n$$\n\\bigl(x_{t+n_1}\\bigr) \\xrightarrow{\\text{skip by } n_2} x_{t+n_1+n_2}\n\\quad \\text{是否等于} \\quad\nx_{t+(n_1+n_2)}\n$$\n当两者都由你的 $\\mathcal{O}(\\log n)$ 算法计算时。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用例 A 到 H 的结果，按顺序排列，形式为方括号括起来的逗号分隔列表（例如 `[r_A,r_B,...,r_H]`），其中每个 $r$ 是如上指定的整数或布尔值。不应打印任何额外文本。\n\n不涉及物理单位或角度单位。所有数字输出必须是指定的精确整数或布尔值。通过采用 $\\mathcal{O}(\\log n)$ 的跳步策略，该算法必须能在现代计算机上，在对于 $n = 10^{12}$ 可行的时间内运行。", "solution": "问题要求我们为线性同余生成器（LCG）推导并实现一个高效的跳步算法。LCG 由以下递推关系定义：\n$$x_{t+1} = (a x_t + c) \\bmod m$$\n适用于整数 $t \\ge 0$，其中 $a$（乘数）、$c$（增量）和 $m$（模数）是固定的整数参数，且 $m \\ge 2$。生成器在时刻 $t$ 的状态是 $x_t$，一个属于集合 $\\{0, 1, \\dots, m-1\\}$ 的整数。任务是在给定 $x_t$ 和一个大整数步长 $n$ 的情况下，以 $n$ 的多对数时间复杂度（具体为 $\\mathcal{O}(\\log n)$）求出 $x_{t+n}$。\n\n首先，我们通过展开递推式来推导 $x_{t+n}$ 的闭式表达式。\n对于 $n=1$：\n$$x_{t+1} = a x_t + c$$\n对于 $n=2$：\n$$x_{t+2} = a x_{t+1} + c = a(a x_t + c) + c = a^2 x_t + ac + c$$\n对于 $n=3$：\n$$x_{t+3} = a x_{t+2} + c = a(a^2 x_t + ac + c) + c = a^3 x_t + a^2 c + ac + c$$\n观察该模式，我们假设对于任意整数 $n \\ge 0$，状态 $x_{t+n}$ 由下式给出：\n$$x_{t+n} = a^n x_t + c \\left(\\sum_{i=0}^{n-1} a^i\\right)$$\n所有算术运算都在模 $m$ 的意义下进行。我们用关于 $n$ 的数学归纳法证明此公式。\n\n**归纳基础 ($n=0$)：** 该公式给出 $x_{t+0} = a^0 x_t + c \\sum_{i=0}^{-1} a^i$。空和为 $0$，所以 $x_{t+0} = 1 \\cdot x_t + c \\cdot 0 = x_t$。这是正确的。\n**归纳基础 ($n=1$)：** 该公式给出 $x_{t+1} = a^1 x_t + c \\sum_{i=0}^{0} a^i = a x_t + c \\cdot a^0 = a x_t + c$。这与 LCG 递推式相符。\n\n**归纳步骤：** 假设该公式对某个整数 $k \\ge 0$ 成立：\n$$x_{t+k} = a^k x_t + c \\left(\\sum_{i=0}^{k-1} a^i\\right)$$\n我们现在求 $x_{t+k+1}$ 的表达式：\n$$x_{t+k+1} = a x_{t+k} + c$$\n将关于 $x_{t+k}$ 的归纳假设代入：\n$$x_{t+k+1} = a \\left( a^k x_t + c \\sum_{i=0}^{k-1} a^i \\right) + c$$\n$$x_{t+k+1} = a^{k+1} x_t + a c \\sum_{i=0}^{k-1} a^i + c$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( a \\sum_{i=0}^{k-1} a^i + 1 \\right)$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( \\sum_{i=0}^{k-1} a^{i+1} + a^0 \\right)$$\n$$x_{t+k+1} = a^{k+1} x_t + c \\left( \\sum_{j=1}^{k} a^{j} + a^0 \\right) = a^{k+1} x_t + c \\left( \\sum_{j=0}^{k} a^{j} \\right)$$\n这就是 $n=k+1$ 时的假设公式。归纳完成。$x_{t+n}$ 的闭式表达式为：\n$$x_{t+n} = \\left(a^n x_t + c \\left(\\sum_{i=0}^{n-1} a^i\\right)\\right) \\bmod m$$\n$\\sum_{i=0}^{n-1} a^i$ 这一项是几何级数。如果 $a \\ne 1$，其和为 $\\frac{a^n-1}{a-1}$。使用这个公式需要计算 $(a-1) \\pmod m$ 的模乘法逆元，而如果 $\\gcd(a-1, m) \\ne 1$，该逆元可能不存在。题目明确禁止这种方法。如果 $a=1$，和就是 $n$。因此，需要一个通用的方法。\n\n为了在不使用模逆元的情况下达到 $\\mathcal{O}(\\log n)$ 的复杂度，我们可以将 LCG 更新表示为一个仿射变换，并对该变换使用快速幂（平方求幂）。函数 $f(x) = (ax+c) \\pmod m$ 将状态 $x_t$ 映射到 $x_{t+1}$。应用 LCG $n$ 步等价于将此函数与自身复合 $n$ 次：$f^n(x_t) = f(f(\\dots f(x_t)\\dots))$。\n\n这些仿射变换的代数结构可以用 $2 \\times 2$ 矩阵来捕捉。我们将状态 $x_t$ 扩充为一个向量 $\\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix}$。LCG 的更新可以写成一个矩阵-向量乘积：\n$$ \\begin{pmatrix} x_{t+1} \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix} \\pmod m $$\n令 $T = \\begin{pmatrix} a  c \\\\ 0  1 \\end{pmatrix}$。应用该变换 $n$ 次对应于求矩阵 $T$ 的 $n$ 次幂：\n$$ \\begin{pmatrix} x_{t+n} \\\\ 1 \\end{pmatrix} = T^n \\begin{pmatrix} x_t \\\\ 1 \\end{pmatrix} \\pmod m $$\n幂 $T^n$ 可以使用快速幂在 $\\mathcal{O}(\\log n)$ 时间内高效计算。其中的运算是模 $m$ 的 $2 \\times 2$ 矩阵乘法。\n$T^n$ 的结构是 $T^n = \\begin{pmatrix} a^n  c \\sum_{i=0}^{n-1} a^i \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} A_n  C_n \\\\ 0  1 \\end{pmatrix}$，其中 $A_n = a^n$ 和 $C_n = c \\sum_{i=0}^{n-1} a^i$ 是 $n$ 步的等效乘数和增量。\n无需实现完整的矩阵乘法，我们可以直接处理定义仿射变换 $x \\mapsto Ax+C$ 的系数对 $(A, C)$。\n两个变换 $(A_1, C_1)$ 和 $(A_2, C_2)$ 的复合（先应用 $(A_1, C_1)$，再应用 $(A_2, C_2)$）是：\n$x \\xrightarrow{(A_1, C_1)} A_1 x + C_1 \\xrightarrow{(A_2, C_2)} A_2(A_1 x + C_1) + C_2 = (A_2 A_1) x + (A_2 C_1 + C_2)$。\n这为变换对定义了一个复合律：\n$$(A_2, C_2) \\circ (A_1, C_1) = (A_2 A_1, A_2 C_1 + C_2)$$\n这个复合运算是满足结合律的。我们想计算 $(a,c)^n$，即 $(a,c)$ 与自身复合 $n$ 次。我们可以对这个对结构使用二进制幂（快速幂）。\n\n计算 $(A_n, C_n) = (a, c)^n$ 的算法如下：\n1. 初始化结果对 $(A_{res}, C_{res})$ 为单位变换，即 $(1, 0)$（因为 $1 \\cdot x + 0 = x$）。\n2. 初始化累加器对 $(A_{acc}, C_{acc})$ 为基本变换 $(a, c)$。\n3. 当 $n  0$ 时进行迭代：\n   a. 如果 $n$ 是奇数，则将结果与累加器复合：$(A_{res}, C_{res}) \\leftarrow (A_{acc}, C_{acc}) \\circ (A_{res}, C_{res})$。\n      - $A_{res}' = (A_{acc} \\cdot A_{res}) \\bmod m$\n      - $C_{res}' = (A_{acc} \\cdot C_{res} + C_{acc}) \\bmod m$\n   b. 将累加器自复合（平方）：$(A_{acc}, C_{acc}) \\leftarrow (A_{acc}, C_{acc}) \\circ (A_{acc}, C_{acc})$。\n      - $A_{acc}' = (A_{acc} \\cdot A_{acc}) \\bmod m$\n      - $C_{acc}' = (A_{acc} \\cdot C_{acc} + C_{acc}) \\bmod m$\n   c. 更新 $n$ 为 $n \\leftarrow \\lfloor n/2 \\rfloor$。\n4. 最终的对 $(A_{res}, C_{res})$ 就是 $(A_n, C_n)$。\n\n计算出 $(A_n, C_n)$ 后，最终状态 $x_{t+n}$ 按下式计算：\n$$x_{t+n} = (A_n \\cdot x_t + C_n) \\bmod m$$\n整个过程涉及的模乘法和模加法次数与 $\\log_2 n$ 成正比，满足了复杂度要求。它避免了模逆元，并且对指定的任意参数 $m, a, c$ 均有效。这种基于仿射变换代数结构的第一性原理方法，产生了一个鲁棒且高效的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCG skip-ahead problem for a suite of test cases.\n    \"\"\"\n    \n    def lcg_skip_ahead(m, a, c, x0, n):\n        \"\"\"\n        Computes the n-th state of an LCG starting from x0 in O(log n) time.\n        The LCG is defined by x_next = (a * x + c) % m.\n\n        Args:\n            m (int): The modulus.\n            a (int): The multiplier.\n            c (int): The increment.\n            x0 (int): The initial state.\n            n (int): The number of steps to advance.\n\n        Returns:\n            int: The state x_n.\n        \"\"\"\n        if n == 0:\n            return x0\n\n        # The LCG recurrence x_next = a*x + c is an affine transformation.\n        # Advancing n steps is equivalent to composing this transformation n times.\n        # We can represent the transformation as a pair (A, C) for x - A*x + C.\n        # The composition of (A1, C1) and (A2, C2) is (A2*A1, A2*C1 + C2).\n        # We use binary exponentiation (exponentiation by squaring) on this\n        # transformation pair to compute the n-step transformation (A_n, C_n).\n\n        # Ensure all initial parameters are within the modulus\n        a %= m\n        c %= m\n\n        # A_res, C_res store the resulting n-step transformation.\n        # Initialize to the identity transformation (A=1, C=0).\n        A_res, C_res = 1, 0  \n\n        # A_acc, C_acc store the transformation for the current power of 2.\n        # Initialize to the single-step transformation (a, c).\n        A_acc, C_acc = a, c\n        \n        k = n\n        while k > 0:\n            if k % 2 == 1:\n                # Compose the result with the current power-of-2 transformation.\n                # (A_res, C_res) -> (A_acc, C_acc) o (A_res, C_res)\n                # A_res' = A_acc * A_res\n                # C_res' = A_acc * C_res + C_acc\n                A_res_new = (A_acc * A_res) % m\n                C_res_new = (A_acc * C_res + C_acc) % m\n                A_res, C_res = A_res_new, C_res_new\n\n            # Square the power-of-2 transformation.\n            # (A_acc, C_acc) -> (A_acc, C_acc) o (A_acc, Cacc)\n            # A_acc' = A_acc * A_acc\n            # C_acc' = A_acc * C_acc + C_acc\n            A_acc_new = (A_acc * A_acc) % m\n            C_acc_new = (A_acc * C_acc + C_acc) % m\n            A_acc, C_acc = A_acc_new, C_acc_new\n            \n            k //= 2\n\n        # After the loop, (A_res, C_res) is the n-step transformation.\n        # Apply it to the initial state x0.\n        return (A_res * x0 + C_res) % m\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, a, c, x_t, n_or_n1, n2)\n        ('A', 97, 5, 3, 42, 0, None),\n        ('B', 97, 5, 3, 42, 1, None),\n        ('C', 97, 5, 3, 42, 2, None),\n        ('D', 97, 5, 3, 42, 10**12, None),\n        ('E', 2**48, 25214903917, 11, 0, 10**12, None),\n        ('F', 2**48, 25214903917, 0, 1, 10**12, None),\n        ('G', 1000000007, 1, 123456789, 987654321, 10**12, None),\n        ('H', 2**48, 25214903917, 11, 123456789012345, 10**12 - 1234567, 1234567),\n    ]\n\n    results = []\n    for case in test_cases:\n        case_id, m, a, c, x_t, n1, n2 = case\n        \n        if case_id != 'H':\n            result = lcg_skip_ahead(m, a, c, x_t, n1)\n        else:\n            # Case H: Check semigroup property\n            n_total = n1 + n2\n            \n            # Compute x_{t + n1 + n2} directly\n            res_direct = lcg_skip_ahead(m, a, c, x_t, n_total)\n            \n            # Compute sequentially: skip by n1, then by n2\n            x_intermediate = lcg_skip_ahead(m, a, c, x_t, n1)\n            res_sequential = lcg_skip_ahead(m, a, c, x_intermediate, n2)\n            \n            result = (res_direct == res_sequential)\n            \n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3529403"}, {"introduction": "使用伪随机数生成器的最后一步，通常是将一个随机整数转换为 $[0,1)$ 区间内的浮点数。由于像 IEEE 754 这样的标准具有有限的精度和舍入规则，这个看似简单的转换充满了陷阱。在本问题中，你将量化标准整型到浮点转换方法所引入的系统性偏差，更重要的是，你将设计并检验一种修正方案，从而加深对浮点运算及其对随机模拟精度关键影响的理解。[@problem_id:3529405]", "problem": "考虑一个由确定性伪随机数生成器（PRNG; Pseudo-Random Number Generator）产生的、均匀分布的无符号$32$位整数流，记为 $x \\in \\{0,1,\\dots,2^{32}-1\\}$。一种广泛使用的、用于在单位区间内获得单精度均匀浮点数的映射是 $u = x / 2^{32}$，然后舍入到 Institute of Electrical and Electronics Engineers (IEEE) $754$ 单精度（binary32）格式。在计算高能物理工作流中，这类单精度均匀分布数经常被用于形式为 $u  t$ 的接受检验，其中阈值 $t \\in [0,1]$。你的任务是量化并修正当在单精度下进行决策时，由该映射引入的偏差。\n\n基本原理：使用 IEEE $754$ 关于“舍入到最近，偶数优先”（rounding to nearest, ties-to-even）的定义、“末位单位”（ULP）的概念，以及 binary32 的结构：符号位、偏置为 $127$ 的指数和 $23$ 个小数位。对于任意可表示的单精度值 $r \\in [0,1]$，定义其在 binary32 中的直接前驱 $r^{-}$ 和后继 $r^{+}$，以及下中点 $m^{-}(r) = (r^{-} + r)/2$。映射 $x \\mapsto u$ 在舍入前，在 $[0,1)$ 区间内产生一个步长为 $\\Delta = 2^{-32}$ 的离散网格。当 $u$ 被舍入到 binary32 时，事件 $u_{\\text{float}}  r$ 发生当且仅当 $u  m^{-}(r)$，此结论不考虑在 $\\Delta$ 粒度下可忽略的平局决胜细节。\n\n问题目标：\n1. 从第一性原理（IEEE $754$ 舍入和离散网格）推导决策概率 $P_{\\text{naive}}(t)$ 的公式。该概率对应事件 $u_{\\text{float}}  \\operatorname{round}_{32}(t)$，其中 $u = x / 2^{32}$，且在比较中 $u$ 和 $t$ 都使用单精度，$\\operatorname{round}_{32}$ 表示舍入到 binary32。定义偏差 $\\beta_{\\text{naive}}(t) = P_{\\text{naive}}(t) - t$，并用 $\\operatorname{round}_{32}(t)$ 的局部 ULP 和网格步长 $\\Delta$ 来界定 $|\\beta_{\\text{naive}}(t)|$。\n2. 提出一种修正方法，在单精度下调整阈值以补偿决策边界处的半 ULP 舍入窗口，从而在 $t \\in [0,1]$ 上一致地将偏差幅度降低到 $10^{-7}$ 以下。定义你修正后的决策概率 $P_{\\text{corr}}(t)$ 及其偏差 $\\beta_{\\text{corr}}(t) = P_{\\text{corr}}(t) - t$，并为 $|\\beta_{\\text{corr}}(t)|$ 提供一个严格的界。\n3. 针对整数 $x$ 提出一种比特混合方案（例如，可逆的线性或非线性比特置乱器），以去除阈值调整或抖动中使用的低阶比特的相关性，并论证为什么这种混合不改变在目标1和2中计算的边际偏差，但可以提高大规模蒙特卡洛工作流的鲁棒性。\n\n测试套件：\n评估以下阈值的朴素偏差和修正后偏差，这些阈值被指定为实数，但在决策中以 binary32 格式进行比较：\n- $t_{1} = 1/2$，\n- $t_{2} = 1/3$，\n- $t_{3} = 1 - 2^{-24}$，\n- $t_{4} = 2^{-100}$。\n\n对于每个 $t_{i}$：\n- 计算 $P_{\\text{naive}}(t_{i})$、$\\beta_{\\text{naive}}(t_{i})$ 和一个从你的分析中推导出的保守界 $B_{\\text{naive}}(t_{i})$。\n- 应用你的阈值修正来计算 $P_{\\text{corr}}(t_{i})$、$\\beta_{\\text{corr}}(t_{i})$ 及其界 $B_{\\text{corr}}(t_{i})$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[\\beta_{\\text{naive}}(t_{1}),\\beta_{\\text{naive}}(t_{2}),\\beta_{\\text{naive}}(t_{3}),\\beta_{\\text{naive}}(t_{4}),\\beta_{\\text{corr}}(t_{1}),\\beta_{\\text{corr}}(t_{2}),\\beta_{\\text{corr}}(t_{3}),\\beta_{\\text{corr}}(t_{4}),\\max_{i} |\\beta_{\\text{naive}}(t_{i})|,\\max_{i} |\\beta_{\\text{corr}}(t_{i})|]$。\n\n所有输出必须是实数（浮点数）。不涉及物理单位或角度单位。界必须从 IEEE $754$ 结构和整数网格论证中推导出来，而不是通过经验性蒙特卡洛采样。确保整个过程的科学真实性和内部一致性，特别是在处理 $2^{32}$ 点网格上的舍入和离散概率时。", "solution": "对问题陈述的分析已确认其有效性。该问题在科学上基于 IEEE 754 浮点算术和概率论的原理，问题提法得当，并使用了客观、形式化的语言。它对计算物理学中的高精度蒙特卡洛模拟构成了一个非凡的挑战。因此，我们可以继续提供完整的解决方案。\n\n问题的核心在于输入伪随机数及其最终单精度浮点表示的离散性，这在数值比较中产生了系统性偏差。\n\n设伪随机数流为 $x_i$，从整数集合 $\\{0, 1, \\dots, 2^{32}-1\\}$ 中均匀抽取。通过变换 $u = x / 2^{32}$ 将它们映射到单位区间。这在 $[0, 1)$ 内创建了一个包含 $2^{32}$ 个点的均匀网格，恒定步长为 $\\Delta = 2^{-32}$。这些值为 $\\{0, \\Delta, 2\\Delta, \\dots, (2^{32}-1)\\Delta\\}$。\n\n$u$ 的值随后被舍入到最接近的 IEEE 754 单精度（binary32）数 $u_{\\text{float}}$。接受检验为 $u_{\\text{float}}  t_{\\text{float}}$，其中 $t_{\\text{float}} = \\operatorname{round}_{32}(t)$ 是理想阈值 $t \\in [0,1]$ 的单精度表示。\n\n根据 IEEE 754 标准，对于任何可表示的数 $r$，舍入将实数区间 $[m^{-}(r), m^{+}(r))$ 映射到 $r$，其中 $m^{-}(r) = (r^{-} + r)/2$ 和 $m^{+}(r) = (r + r^{+})/2$ 分别是 $r$ 与其前驱 $r^{-}$ 和后继 $r^{+}$ 之间的中点。平局（值恰好在中点）的处理遵循“舍入到偶数”（ties-to-even）规则。\n\n比较 $u_{\\text{float}}  t_{\\text{float}}$ 为真，当且仅当 $u_{\\text{float}}$ 是一个严格小于 $t_{\\text{float}}$ 的可表示数，即 $u_{\\text{float}} \\le t_{\\text{float}}^{-}$。如果原始高精度值 $u$ 落入任何数 $r \\le t_{\\text{float}}^{-}$ 的舍入区间内，则此条件成立。这些区间的并集是 $(-\\infty, m^{-}(t_{\\text{float}}))$。因此，浮点比较 $u_{\\text{float}}  t_{\\text{float}}$ 等价于实值比较 $u  m^{-}(t_{\\text{float}})$，忽略 $u$ 恰好为中点的可忽略概率。\n\n中点的值为 $m^{-}(r) = r - \\frac{1}{2}\\text{ulp}(r)$，其中 $\\text{ulp}(r)$ 是 $r$ 的“末位单位”（unit in the last place），表示 $r$ 附近连续可表示数之间的间距。\n\n在我们的离散网格上，事件 $u  C$ 的概率由 $P(u  C) = N_C / 2^{32}$ 给出，其中 $N_C$ 是满足 $x/2^{32}  C$ 的整数点 $x \\in \\{0, 1, \\dots, 2^{32}-1\\}$ 的数量。这等价于 $x  C \\cdot 2^{32}$，因此 $N_C = \\lceil C \\cdot 2^{32} \\rceil$。\n\n**1. 朴素偏差**\n\n朴素决策概率 $P_{\\text{naive}}(t)$ 是事件 $u_{\\text{float}}  t_{\\text{float}}$ 的概率，等价于 $P(u  m^{-}(t_{\\text{float}}))$。\n$$P_{\\text{naive}}(t) = \\frac{\\lceil m^{-}(t_{\\text{float}}) \\cdot 2^{32} \\rceil}{2^{32}}, \\quad \\text{其中 } m^{-}(t_{\\text{float}}) = t_{\\text{float}} - \\frac{1}{2}\\text{ulp}(t_{\\text{float}})$$\n朴素偏差为 $\\beta_{\\text{naive}}(t) = P_{\\text{naive}}(t) - t$。\n此偏差主要来自决策边界从理想的 $t$ 偏移到 $m^{-}(t_{\\text{float}})$。偏移量为 $m^{-}(t_{\\text{float}}) - t = (t_{\\text{float}} - t) - \\frac{1}{2}\\text{ulp}(t_{\\text{float}})$。由于舍入误差 $|t_{\\text{float}} - t| \\le \\frac{1}{2}\\text{ulp}(t_{\\text{float}})$，这个偏移量的幅度可以达到一个完整的 $\\text{ulp}(t_{\\text{float}})$。因此，保守界为 $|\\beta_{\\text{naive}}(t)| \\le \\text{ulp}(t_{\\text{float}}) + \\Delta$。\n\n**2. 修正偏差**\n\n为了消除这个系统偏差，我们调整比较阈值。我们的目标是选择一个新的单精度阈值 $t_{corr}$，使得其实际决策边界 $m^{-}(t_{corr})$ 尽可能接近理想阈值 $t$。\n$m^{-}(t_{corr}) \\approx t \\implies t_{corr} - \\frac{1}{2}\\text{ulp}(t_{corr}) \\approx t \\implies t_{corr} \\approx t + \\frac{1}{2}\\text{ulp}(t_{corr})$。\n由于 $\\text{ulp}(t_{corr}) \\approx \\text{ulp}(t)$，我们提出以下修正方案：\n1.  计算理想的修正阈值 $t'_{corr} = t + \\frac{1}{2}\\text{ulp}(t_{\\text{float}})$。\n2.  将其舍入到单精度得到最终的修正阈值 $t_{corr} = \\operatorname{round}_{32}(t'_{corr})$。\n3.  使用新的比较 $u_{\\text{float}}  t_{corr}$。\n\n修正后的概率为：\n$$P_{\\text{corr}}(t) = P(u  m^{-}(t_{corr})) = \\frac{\\lceil m^{-}(t_{corr}) \\cdot 2^{32} \\rceil}{2^{32}}$$\n修正后的偏差 $\\beta_{\\text{corr}}(t) = P_{\\text{corr}}(t) - t$。现在，决策边界 $m^{-}(t_{corr})$ 非常接近 $t$。主要残余偏差来源于 $u$ 的离散网格与 $m^{-}(t_{corr})$ 的相对位置，其幅度受网格步长 $\\Delta=2^{-32}$ 的限制。因此，修正后偏差的界为 $|\\beta_{\\text{corr}}(t)| \\le \\Delta = 2^{-32} \\approx 2.3 \\times 10^{-10}$。\n\n**3. 比特混合方案**\n\n对于问题1和2中计算的边际偏差，任何可逆的比特混合方案（例如，将整数 $x$ 映射到 $x'$）都不会改变结果，因为如果 $x$ 在 $\\{0, \\dots, 2^{32}-1\\}$ 上是均匀的，那么 $x'$ 也是。\n\n然而，在复杂的蒙特卡洛工作流中，同一个随机整数 $x$ 的不同比特位可能被用于不同的目的。例如，高位比特可能决定一个物理过程，而低位比特可能用于抖动或阈值调整。如果PRNG的低位比特具有较差的随机性（例如在某些LCG中），或者如果它们与高位比特存在某种相关性，这可能引入难以察觉的系统偏差。\n\n一个简单的比特混合方案，如 `x' = (x * 2654435761) mod 2^32`（其中乘数是黄金分割比例的小数部分的整数表示），可以有效地将输入的比特重新分布到整个输出字中。这种非线性（在 $\\mathbb{F}_2$ 意义上）混合操作可以破坏潜在的位级相关性，从而提高模拟对PRNG缺陷的鲁棒性，而无需改变其理想的均匀分布特性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Computes and prints the naive and corrected biases for floating-point comparisons.\n    \"\"\"\n    # Set high precision for Decimal calculations to ensure correctness\n    getcontext().prec = 100\n\n    # Define the test cases from the problem statement.\n    test_cases_str = {\n        't1': \"0.5\",\n        't2': \"1/3\",\n        't3': f\"1 - {2**-24}\",\n        't4': f\"{2**-100}\",\n    }\n    \n    # Use Decimal for high-precision representation of t\n    test_cases = {\n        't1': Decimal(\"0.5\"),\n        't2': Decimal(1) / Decimal(3),\n        't3': Decimal(1) - Decimal(2)**-24,\n        't4': Decimal(2)**-100\n    }\n\n    TWO_POW_32 = Decimal(2**32)\n\n    def calculate_biases(t_decimal: Decimal):\n        \"\"\"\n        Calculates the naive and corrected biases for a given threshold t.\n        \n        Args:\n            t_decimal: The ideal threshold as a high-precision Decimal object.\n\n        Returns:\n            A tuple (beta_naive, beta_corr) with the biases as floats.\n        \"\"\"\n\n        # --- Naive Bias Calculation ---\n        # 1. Round the ideal threshold t to single precision\n        t_f = np.float32(t_decimal)\n        \n        # 2. Determine the decision boundary m^-(t_f)\n        pred_tf = np.nextafter(t_f, -np.inf)\n        # Use Decimal for the midpoint calculation to maintain precision\n        m_minus_tf = (Decimal(str(pred_tf)) + Decimal(str(t_f))) / Decimal(2)\n\n        # 3. Calculate the naive probability P_naive\n        # K is the boundary in the integer domain\n        K_naive = TWO_POW_32 * m_minus_tf\n        # Count of integers x in [0, K_naive)\n        # This is equivalent to ceil(K_naive)\n        if K_naive == K_naive.to_integral_value(rounding='ROUND_FLOOR'):\n            num_points_naive = int(K_naive)\n        else:\n            num_points_naive = K_naive.to_integral_value(rounding='ROUND_FLOOR') + 1\n        \n        P_naive = Decimal(num_points_naive) / TWO_POW_32\n        beta_naive = P_naive - t_decimal\n\n        # --- Corrected Bias Calculation ---\n        # 1. Propose corrected threshold t_c\n        ulp_tf = np.spacing(t_f)\n        t_corr_ideal = t_decimal + Decimal(str(ulp_tf)) / Decimal(2)\n        \n        # 2. Round the ideal corrected threshold to single precision\n        t_c = np.float32(t_corr_ideal)\n\n        # 3. Determine the corrected decision boundary m^-(t_c)\n        pred_tc = np.nextafter(t_c, -np.inf)\n        m_minus_tc = (Decimal(str(pred_tc)) + Decimal(str(t_c))) / Decimal(2)\n\n        # 4. Calculate the corrected probability P_corr\n        K_corr = TWO_POW_32 * m_minus_tc\n        if K_corr == K_corr.to_integral_value(rounding='ROUND_FLOOR'):\n            num_points_corr = int(K_corr)\n        else:\n            num_points_corr = K_corr.to_integral_value(rounding='ROUND_FLOOR') + 1\n\n        P_corr = Decimal(num_points_corr) / TWO_POW_32\n        beta_corr = P_corr - t_decimal\n        \n        return float(beta_naive), float(beta_corr)\n\n    results = []\n    betas_naive = []\n    betas_corr = []\n\n    # Process each test case\n    for t_key in ['t1', 't2', 't3', 't4']:\n        t_val = test_cases[t_key]\n        b_naive, b_corr = calculate_biases(t_val)\n        betas_naive.append(b_naive)\n        betas_corr.append(b_corr)\n        \n    results.extend(betas_naive)\n    results.extend(betas_corr)\n    \n    max_beta_naive_abs = max(abs(b) for b in betas_naive)\n    max_beta_corr_abs = max(abs(b) for b in betas_corr)\n    \n    results.append(max_beta_naive_abs)\n    results.append(max_beta_corr_abs)\n\n    # Final print statement in the exact required format.\n    # Use a format specifier to ensure standard float representation.\n    print(f\"[{','.join(f'{v:.17g}' for v in results)}]\")\n\nsolve()\n\n```", "id": "3529405"}]}