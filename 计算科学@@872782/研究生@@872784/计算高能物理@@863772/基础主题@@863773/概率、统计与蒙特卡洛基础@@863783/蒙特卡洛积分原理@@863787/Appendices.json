{"hands_on_practices": [{"introduction": "要在高能物理中真正掌握蒙特卡洛方法，就必须能够将其应用于核心的理论构建。第一个实践练习将挑战你计算三体洛伦兹不变相空间体积，这是粒子散射理论的基石之一 [@problem_id:3523401]。通过将复杂的多维定义简化为关于一个不变质量的、易于处理的一维积分，你将亲身体验那些使蒙特卡洛积分成为物理研究中强大实用工具的解析变换。", "problem": "你的任务是设计并实现一个蒙特卡洛积分算法，用于计算高能物理中一个过程的洛伦兹不变三体相空间体积。该过程的总质心系四维动量平方为 $s$，三个末态粒子的质量分别为 $m_1$、$m_2$ 和 $m_3$。该问题必须基于蒙特卡洛积分和洛伦兹不变相空间测度的第一性原理来构建。你应该从三粒子洛伦兹不变相空间的定义出发，即一个受能量-动量守恒约束的、对末态三维动量的分布积分，而不依赖于任何现成公式。你的程序必须执行一次有效的变量替换，将其转换为单个不变量，并使用蒙特卡洛抽样方法对变换后的变量进行抽样，以估算该积分。\n\n问题的基本原理：洛伦兹不变 $n$-体相空间定义为\n$$\n\\mathrm{d}\\Phi_n(P; m_1,\\dots,m_n) \\equiv (2\\pi)^4\\,\\delta^{(4)}\\!\\left(P - \\sum_{i=1}^{n} p_i\\right)\\,\\prod_{i=1}^{n}\\frac{\\mathrm{d}^3 \\mathbf{p}_i}{(2\\pi)^3\\,2E_i},\n$$\n其中 $P$ 是总入射四维动量，$p_i$ 是满足 $p_i^2 = m_i^2$ 的出射在壳四维动量，$E_i$ 是对应的能量，$\\delta^{(4)}$ 是四维狄拉克 $\\delta$ 函数。你的目标是积分后的三体相空间体积\n$$\n\\Phi_3(s; m_1,m_2,m_3) \\equiv \\int \\mathrm{d}\\Phi_3(P; m_1,m_2,m_3),\n$$\n表示为质心不变量 $s \\equiv P^2$ 和末态质量的函数。你必须使用顺序二体衰变图像，推导出一个对测度的物理上有效的分解，并通过变量替换将其转换为单个不变质量平方 $s_{12} \\equiv (p_1+p_2)^2$。你需要确定 $s_{12}$ 的正确运动学极限，并计算雅可比因子，以便在完成角度积分后将原始测度转换为仅对 $s_{12}$ 的积分。\n\n蒙特卡洛要求：实现一个对 $s_{12}$ 的一维积分的蒙特卡洛估计量，方法是在一个单位区间内进行均匀抽样，并将其通过线性变换映射到物理允许的范围 $\\left[s_{12}^{\\min}, s_{12}^{\\max}\\right]$。然后，对由推导出的测度所决定的被积函数值进行累加，并输出最终的按比例缩放的平均值作为估算结果。程序需包含一项安全措施，当运动学阈值 $s  (m_1 + m_2 + m_3)^2$ 导致相空间为零时，返回 $0$。为保证可复现性，请使用固定的伪随机数生成器种子。报告估算出的 $\\Phi_3(s; m_1,m_2,m_3)$ 值，形式为浮点数。\n\n单位要求：所有能量和质量都必须以吉电子伏特 (GeV) 为单位处理。最终的相空间体积 $\\Phi_3$ 以 GeV$^2$ 表示。\n\n角度单位要求：推导过程中引入的任何角度都必须理解为以弧度为单位。\n\n你的程序必须实现以下功能：\n- 一个计算 Källén 函数 $\\lambda(a,b,c) \\equiv a^2 + b^2 + c^2 - 2ab - 2ac - 2bc$ 的函数，并在正确的变量变换和角度积分后，在雅可比因子中一致地使用它。\n- 一个蒙特卡洛估计量，它从单位区间均匀抽取 $N$ 个独立样本，通过线性变换将它们映射到 $\\left[s_{12}^{\\min}, s_{12}^{\\max}\\right]$ 区间内的 $s_{12}$ 值，累加由推导出的测度所隐含的被积函数值，并输出最终的估算结果（即按比例缩放的平均值）。\n- 使用固定的种子 $12345$ 初始化伪随机数生成器。\n\n测试套件：\n为以下参数集提供估算值，所有单位均按要求使用 GeV 和 GeV$^2$，$N$ 为每个案例指定的样本数：\n1. $s = 100$, $m_1 = 1$, $m_2 = 2$, $m_3 = 3$, $N = 200000$。\n2. $s = 25$, $m_1 = 0$, $m_2 = 0$, $m_3 = 0$, $N = 200000$。\n3. $s = (6.1)^2$, $m_1 = 2$, $m_2 = 2$, $m_3 = 2$, $N = 200000$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。列表中的每个条目是对应测试案例的 $\\Phi_3$ 的蒙特卡洛估算值（单位 GeV$^2$）。例如，你的输出应如下所示\n$$\n[\\varphi_1,\\varphi_2,\\varphi_3],\n$$\n其中每个 $\\varphi_i$ 是一个浮点数。", "solution": "该问题要求设计并实现一个蒙特卡洛算法，用以计算洛伦兹不变三体相空间体积 $\\Phi_3$。该方法必须从第一性原理推导，从洛伦兹不变相空间 (LIPS) 测度的定义开始，通过有效的变量替换，最终得到一个适合蒙特卡洛估算的一维积分。\n\n出发点是 $n$-体 LIPS 的定义，描述一个总四维动量为 $P$ 的系统衰变为 $n$ 个粒子，其四维动量为 $p_i$，质量为 $m_i$：\n$$\n\\mathrm{d}\\Phi_n(P; m_1,\\dots,m_n) \\equiv (2\\pi)^4\\,\\delta^{(4)}\\!\\left(P - \\sum_{i=1}^{n} p_i\\right)\\,\\prod_{i=1}^{n}\\frac{\\mathrm{d}^3 \\mathbf{p}_i}{(2\\pi)^3\\,2E_i}\n$$\n其中 $p_i^2 = m_i^2$。我们关心的是 $n=3$ 时的总相空间体积，即该测度对所有末态动量的积分：\n$$\n\\Phi_3(s; m_1,m_2,m_3) \\equiv \\int \\mathrm{d}\\Phi_3(P; m_1,m_2,m_3)\n$$\n此处，$s=P^2$ 是质心能量的平方。在质心 (CM) 系中，$P=(\\sqrt{s}, \\mathbf{0})$。$\\mathrm{d}\\Phi_n$ 的量纲是 $(\\text{能量})^{2n-4}$，对于 $n=3$，结果是 $(\\text{能量})^2$，与要求的输出单位 $\\text{GeV}^2$ 一致。\n\n简化这个九维动量积分的关键在于将三体衰变分解为一系列二体衰变。我们将此衰变视为一个两步过程：首先，初态衰变为粒子 3 和一个四维动量为 $p_{12} = p_1+p_2$ 的中间虚粒子。然后，这个中间态再衰变为粒子 1 和 2。该中间态的不变质量平方为 $s_{12} \\equiv p_{12}^2 = (p_1+p_2)^2$。\n\n我们可以通过以下方式表达总的三体相空间积分：首先在中间动量 $p_{12}$ 固定的情况下对粒子 1 和 2 的相空间进行积分，然后再对 $p_{12}$ 和 $p_3$ 的相空间进行积分。这可以通过在积分中插入一个恒等式来形式化地证明，从而得到以下分解：\n$$\n\\Phi_3 = \\int \\frac{\\mathrm{d}^3\\mathbf{p}_3}{(2\\pi)^3 2E_3} \\left[ \\int (2\\pi)^4 \\delta^{(4)}(P-p_3-p_{12}) \\frac{\\mathrm{d}^3\\mathbf{p}_1}{(2\\pi)^3 2E_1} \\frac{\\mathrm{d}^3\\mathbf{p}_2}{(2\\pi)^3 2E_2} \\right]\n$$\n其中 $p_{12}$ 被外层的 $\\delta$ 函数固定为 $p_{12}=P-p_3$。方括号中的项是动量为 $p_{12}$ 的虚粒子衰变为粒子 1 和 2 的二体相空间。这正是 $\\Phi_2(s_{12}; m_1, m_2)$，其中 $s_{12} = (P-p_3)^2 = s+m_3^2-2\\sqrt{s}E_3$。积分后的二体相空间体积由一个著名公式给出：\n$$\n\\Phi_2(Q^2; m_a, m_b) = \\frac{\\sqrt{\\lambda(Q^2, m_a^2, m_b^2)}}{8\\pi Q^2}\n$$\n其中 $\\lambda(x,y,z) = x^2+y^2+z^2-2xy-2xz-2yz$ 是 Källén 运动学函数。此结果是无量纲的。应用此公式，我们得到的 $\\Phi_3$ 表达式为：\n$$\n\\Phi_3 = \\int \\frac{\\mathrm{d}^3\\mathbf{p}_3}{(2\\pi)^3 2E_3} \\Phi_2(s-2\\sqrt{s}E_3+m_3^2; m_1, m_2)\n$$\n对 $\\mathrm{d}^3\\mathbf{p}_3$ 的积分在质心系中进行。使用球坐标，$\\mathrm{d}^3\\mathbf{p}_3 = |\\mathbf{p}_3|^2 \\mathrm{d}|\\mathbf{p}_3| \\mathrm{d}\\Omega_3$。角度积分给出一个 $4\\pi$ 因子。利用关系式 $E_3^2 = |\\mathbf{p}_3|^2 + m_3^2 \\implies E_3\\mathrm{d}E_3 = |\\mathbf{p}_3|\\mathrm{d}|\\mathbf{p}_3|$，积分测度变为：\n$$\n\\frac{4\\pi |\\mathbf{p}_3|E_3 \\mathrm{d}E_3}{(2\\pi)^3 2E_3} = \\frac{|\\mathbf{p}_3|}{4\\pi^2} \\mathrm{d}E_3\n$$\n现在我们将积分变量从 $E_3$ 更改为 $s_{12}$。由 $s_{12} = s+m_3^2-2\\sqrt{s}E_3$ 可得 $|\\mathrm{d}E_3| = \\frac{\\mathrm{d}s_{12}}{2\\sqrt{s}}$。质心系中的动量 $|\\mathbf{p}_3|$ 也可以用不变量表示：它是衰变 $P \\to p_3 + p_{12}$ 中任一粒子的动量，因此 $|\\mathbf{p}_3| = \\frac{\\sqrt{\\lambda(s, m_3^2, s_{12})}}{2\\sqrt{s}}$。\n\n将这些表达式代回到 $\\Phi_3$ 的积分中：\n$$\n\\Phi_3 = \\int \\left( \\frac{1}{4\\pi^2} \\frac{\\sqrt{\\lambda(s, m_3^2, s_{12})}}{2\\sqrt{s}} \\right) \\left( \\frac{\\sqrt{\\lambda(s_{12}, m_1^2, m_2^2)}}{8\\pi s_{12}} \\right) \\left( \\frac{\\mathrm{d}s_{12}}{2\\sqrt{s}} \\right)\n$$\n合并常数因子和与 $s$ 相关的项，得到最终的一维积分：\n$$\n\\Phi_3 = \\frac{1}{128\\pi^3 s} \\int_{s_{12}^{\\min}}^{s_{12}^{\\max}} \\frac{\\sqrt{\\lambda(s, s_{12}, m_3^2)} \\sqrt{\\lambda(s_{12}, m_1^2, m_2^2)}}{s_{12}} \\mathrm{d}s_{12}\n$$\n$s_{12}$ 的运动学极限由物理约束决定。$s_{12}$ 的最小值是产生粒子 1 和 2 的阈值，即当它们相对彼此静止时被创造出来：$s_{12}^{\\min} = (m_1+m_2)^2$。最大值发生在粒子 3 以最小可能动量产生时，即相对于粒子 1 和 2 的质心系静止。这对应于总可用能量减去粒子 3 的静止质量后全部用于粒子对 $(1,2)$，因此 $\\sqrt{s_{12}^{\\max}} = \\sqrt{s}-m_3$，从而得到 $s_{12}^{\\max} = (\\sqrt{s}-m_3)^2$。如果 $\\sqrt{s}  m_1+m_2+m_3$，则 $s_{12}^{\\max}  s_{12}^{\\min}$，积分范围为空，$\\Phi_3=0$，这正确地反映了运动学阈值。\n\n为了使用蒙特卡洛方法估算此积分，我们定义被积函数为：\n$$\nf(s_{12}) = \\frac{\\sqrt{\\lambda(s, s_{12}, m_3^2)} \\sqrt{\\lambda(s_{12}, m_1^2, m_2^2)}}{s_{12}}\n$$\n积分 $I = \\int_{s_{12}^{\\min}}^{s_{12}^{\\max}} f(s_{12}) \\mathrm{d}s_{12}$ 可估算为：\n$$\nI \\approx \\frac{s_{12}^{\\max} - s_{12}^{\\min}}{N} \\sum_{i=1}^{N} f(x_i)\n$$\n其中 $x_i$ 是从区间 $[s_{12}^{\\min}, s_{12}^{\\max}]$ 上的均匀分布中抽取的 $N$ 个随机数。这可以通过在 $[0,1]$ 上生成均匀分布的随机数 $u_i$ 并应用线性变换 $x_i = s_{12}^{\\min} + u_i (s_{12}^{\\max} - s_{12}^{\\min})$ 来实现。然后将 $I$ 的估算值乘以积分前因子 $\\frac{1}{128\\pi^3 s}$，即可得到 $\\Phi_3$ 的最终估算值。算法必须实现这一逻辑，包括 Källén 函数、运动学极限的计算和阈值检查。为保证可复现性，随机数生成器使用固定的种子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for three-body phase-space volume estimation.\n    \"\"\"\n    \n    test_cases = [\n        # (s, m1, m2, m3, N)\n        (100.0, 1.0, 2.0, 3.0, 200000),\n        (25.0, 0.0, 0.0, 0.0, 200000),\n        ((6.1)**2, 2.0, 2.0, 2.0, 200000),\n    ]\n\n    results = []\n    seed = 12345\n\n    for case in test_cases:\n        s, m1, m2, m3, N = case\n        phi3_estimate = estimate_phi3(s, m1, m2, m3, N, seed)\n        results.append(phi3_estimate)\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef kallen_lambda(a, b, c):\n    \"\"\"\n    Calculates the Källén (or triangle) function lambda(a, b, c).\n    This function can accept scalar or numpy array inputs.\n    \"\"\"\n    return a**2 + b**2 + c**2 - 2*a*b - 2*a*c - 2*b*c\n\ndef estimate_phi3(s, m1, m2, m3, N, seed):\n    \"\"\"\n    Estimates the three-body phase-space volume Phi_3 using Monte Carlo integration.\n    \n    Args:\n        s (float): The square of the center-of-mass energy in GeV^2.\n        m1 (float): Mass of particle 1 in GeV.\n        m2 (float): Mass of particle 2 in GeV.\n        m3 (float): Mass of particle 3 in GeV.\n        N (int): The number of Monte Carlo samples.\n        seed (int): The seed for the random number generator.\n        \n    Returns:\n        float: The estimated value of Phi_3 in GeV^2.\n    \"\"\"\n    sqrts = np.sqrt(s)\n    \n    # Kinematic threshold check\n    if sqrts  (m1 + m2 + m3):\n        return 0.0\n\n    # Calculate kinematic limits for the invariant mass squared s_12\n    s12_min = (m1 + m2)**2\n    s12_max = (sqrts - m3)**2\n    \n    # If the integration range is non-positive, phase space is zero.\n    if s12_max = s12_min:\n        return 0.0\n\n    # Set up the random number generator with a fixed seed for reproducibility.\n    rng = np.random.default_rng(seed)\n    \n    # Generate N uniform random samples in [0, 1)\n    u_samples = rng.uniform(0, 1, N)\n    \n    # Map samples to the integration domain [s12_min, s12_max]\n    s12_samples = s12_min + (s12_max - s12_min) * u_samples\n\n    # Pre-calculate squared masses\n    m1_sq = m1**2\n    m2_sq = m2**2\n    m3_sq = m3**2\n\n    # Calculate the two Källén functions\n    # Handle potential small negative values from floating point inaccuracies\n    lambda1 = kallen_lambda(s12_samples, m1_sq, m2_sq)\n    lambda1[lambda1  0] = 0.0\n    \n    lambda2 = kallen_lambda(s, s12_samples, m3_sq)\n    lambda2[lambda2  0] = 0.0\n    \n    # Calculate the integrand value for each sample of s12\n    # Ensure s12 is not zero to avoid division by zero. s12_samples will be  s12_min = 0\n    # In the massless case, s12_min is 0, so we need to handle the s12=0 point.\n    # The integrand at s12=0 limit is 0, so we can safely replace NaNs with 0.\n    with np.errstate(divide='ignore', invalid='ignore'):\n        integrand_values = (np.sqrt(lambda1) * np.sqrt(lambda2)) / s12_samples\n    integrand_values = np.nan_to_num(integrand_values, nan=0.0, posinf=0.0, neginf=0.0)\n\n    # Calculate the Monte Carlo estimate of the integral part\n    integral_volume = s12_max - s12_min\n    integral_estimate = integral_volume * np.mean(integrand_values)\n\n    #\n    # Final formula for Phi_3:\n    # Phi_3 = (1 / (128 * pi^3 * s)) * Integral(...)\n    #\n    prefactor = 1.0 / (128.0 * np.pi**3 * s)\n    \n    phi3 = prefactor * integral_estimate\n    \n    return phi3\n\nsolve()\n```", "id": "3523401"}, {"introduction": "当被积函数同时包含大的正值和负值贡献时，标准的蒙特卡洛积分效率可能会很低，而这在次领头阶 (NLO) 计算中是常见问题。本练习将展示分层抽样如何通过将正权重和负权重事件视为不同层来显著提高计算精度 [@problem_id:3523424]。你将推导在计算资源上的最优分配方案以最小化方差，从而掌握一种关键策略，用以应对高阶修正计算中固有的数值不稳定性。", "problem": "给定一个蒙特卡洛积分问题，该问题是高能物理中次领头阶 (NLO) 总截面评估的典型代表，其中由于减除项的存在，事例权重可为正或为负。目标是当事例样本包含混合的正负权重时，为总截面构建一个无偏、最小方差的估计量，并分析按权重符号对样本进行分层抽样的效果。\n\n考虑一个生成器，它产生带有符号权重随机变量 $W$ 的事例。该生成器是一个双组分混合模型：以概率 $p_{+}$ 抽取一个权重为 $W=+U_{+}$ 的正事例，并以概率 $p_{-}=1-p_{+}$ 抽取一个权重为 $W=-U_{-}$ 的负事例。在符号给定的条件下，权重的绝对值是独立的，并服从伽马分布，\n$$U_{+} \\sim \\mathrm{Gamma}(k_{+},\\theta_{+}), \\quad U_{-} \\sim \\mathrm{Gamma}(k_{-},\\theta_{-}),$$\n其中形状参数为 $k_{+}, k_{-} \\in \\mathbb{R}_{0}$，尺度参数为 $\\theta_{+}, \\theta_{-} \\in \\mathbb{R}_{0}$。所有随机抽取都是独立的。总截面（以任意单位计）被建模为期望值\n$$I \\equiv \\mathbb{E}[W] = p_{+}\\,\\mathbb{E}[U_{+}] - p_{-}\\,\\mathbb{E}[U_{-}].$$\n\n你只能从蒙特卡洛基本原理和基本概率事实出发进行推导。允许的出发点是：(i) 期望的线性性，(ii) 方差定义 $\\mathrm{Var}(X)=\\mathbb{E}[X^{2}]-\\mathbb{E}[X]^{2}$，(iii) 和与样本均值的独立性性质，以及 (iv) 对于 $U\\sim \\mathrm{Gamma}(k,\\theta)$ 的伽马分布矩 $\\mathbb{E}[U]=k\\theta$ 和 $\\mathrm{Var}(U)=k\\theta^{2}$。除这些基本原理外，不要假设任何专门的方差缩减公式。\n\n任务：\n1. 仅使用上述原理，基于从混合生成器中进行的 $N$ 次独立抽取（无分层），定义 $I$ 的一个无偏蒙特卡洛估计量。用 $p_{+}$、$k_{+}$、$\\theta_{+}$、$k_{-}$、$\\theta_{-}$ 和 $N$ 表示其方差。\n2. 现在考虑按符号分层。将 $n_{+}$ 个样本分配给正权重层，将 $n_{-}$ 个样本分配给负权重层，其中 $n_{+}+n_{-}=N$，并构建一个使用符号层均值的 $I$ 的无偏分层估计量。推导其方差作为 $n_{+}$ 和 $n_{-}$ 的函数。然后，确定在约束条件 $n_{+}+n_{-}=N$ 和 $n_{+},n_{-} \\in \\mathbb{R}_{0}$ 下使该方差最小化的样本分配方案 $(n_{+},n_{-})$。\n3. 将最小化分配方案表示为最优正权重层比例 $f_{+}^{\\star} \\equiv n_{+}^{\\star}/N$。利用你的推导，同时表示出符号分层下可实现的最小方差。\n\n实现要求：\n- 实现一个完整的程序，使用你的闭式表达式，为每个测试用例计算：\n  - 最优正权重层比例 $f_{+}^{\\star}$，\n  - 比率 $R_{\\mathrm{equal}} \\equiv \\mathrm{Var}_{\\mathrm{equal}}/\\mathrm{Var}_{\\mathrm{naive}}$，其中 $\\mathrm{Var}_{\\mathrm{equal}}$ 是均等分配 $n_{+}=\\lfloor N/2 \\rfloor$、$n_{-}=N-\\lfloor N/2 \\rfloor$ 时的方差，\n  - 比率 $R_{\\mathrm{opt}} \\equiv \\mathrm{Var}_{\\mathrm{opt}}/\\mathrm{Var}_{\\mathrm{naive}}$，其中 $\\mathrm{Var}_{\\mathrm{opt}}$ 是在你的最优分配方案下的最小分层方差。\n- 所有输出都是无量纲实数。\n- 你的程序应产生单行输出，包含一个列表的列表形式的结果，每个测试用例对应一个内部列表，每个内部列表按顺序为 $[f_{+}^{\\star},R_{\\mathrm{equal}},R_{\\mathrm{opt}}]$。在打印前，将每个值数值四舍五入到六位小数。\n\n测试套件：\n- A用例（符号平衡，中度抵消）：$p_{+}=0.5$，$k_{+}=2.0$，$\\theta_{+}=1.0$，$k_{-}=5.0$，$\\theta_{-}=0.4$，$N=10000$。\n- B用例（稀疏但噪声大的负权重）：$p_{+}=0.99$，$k_{+}=2.0$，$\\theta_{+}=1.0$，$k_{-}=3.0$，$\\theta_{-}=5.0$，$N=10000$。\n- C用例（大均值下近乎精确抵消）：$p_{+}=0.5$，$k_{+}=50.0$，$\\theta_{+}=0.2$，$k_{-}=50.0$，$\\theta_{-}=0.2$，$N=10000$。\n- D用例（全正边界情况）：$p_{+}=1.0$，$k_{+}=2.0$，$\\theta_{+}=1.0$，$k_{-}=1.0$，$\\theta_{-}=1.0$，$N=10000$。\n\n你的程序必须计算并打印列表\n$$\\big[ [f_{+}^{\\star},R_{\\mathrm{equal}},R_{\\mathrm{opt}}]_{\\text{Case A}},\\ [f_{+}^{\\star},R_{\\mathrm{equal}},R_{\\mathrm{opt}}]_{\\text{Case B}},\\ [f_{+}^{\\star},R_{\\mathrm{equal}},R_{\\mathrm{opt}}]_{\\text{Case C}},\\ [f_{+}^{\\star},R_{\\mathrm{equal}},R_{\\mathrm{opt}}]_{\\text{Case D}} \\big]$$\n于单行之上，所有浮点数四舍五入到六位小数，且无任何附加文本。", "solution": "我们将目标形式化为在双组分带符号权重混合模型下的期望值 $I \\equiv \\mathbb{E}[W]$。根据混合模型的定义和期望的线性性，\n$$I = \\mathbb{E}[W] = p_{+}\\,\\mathbb{E}[U_{+}] - p_{-}\\,\\mathbb{E}[U_{-}].$$\n对于 $U_{\\pm} \\sim \\mathrm{Gamma}(k_{\\pm},\\theta_{\\pm})$，由伽马分布的矩可得 $\\mathbb{E}[U_{\\pm}] = k_{\\pm}\\theta_{\\pm}$ 和 $\\mathrm{Var}(U_{\\pm}) = k_{\\pm}\\theta_{\\pm}^{2}$。我们将各层的均值和方差记为\n$$\\mu_{+} \\equiv \\mathbb{E}[U_{+}] = k_{+}\\theta_{+},\\quad \\sigma_{+}^{2} \\equiv \\mathrm{Var}(U_{+}) = k_{+}\\theta_{+}^{2},$$\n$$\\mu_{-} \\equiv \\mathbb{E}[U_{-}] = k_{-}\\theta_{-},\\quad \\sigma_{-}^{2} \\equiv \\mathrm{Var}(U_{-}) = k_{-}\\theta_{-}^{2}.$$\n\n任务1（朴素混合估计量）。从混合模型中抽取 $N$ 个独立样本 $W_{1},\\dots,W_{N}$。样本均值\n$$\\hat{I}_{\\mathrm{naive}} \\equiv \\frac{1}{N}\\sum_{i=1}^{N} W_{i}$$\n根据期望的线性性是无偏的，$\\mathbb{E}[\\hat{I}_{\\mathrm{naive}}]=I$。对于其方差，独立性给出\n$$\\mathrm{Var}(\\hat{I}_{\\mathrm{naive}}) = \\frac{1}{N}\\mathrm{Var}(W),$$\n因此只需计算 $\\mathrm{Var}(W)$。根据全期望定律和方差定义 $\\mathrm{Var}(W)=\\mathbb{E}[W^{2}]-\\mathbb{E}[W]^{2}$，并注意到在正权重层中 $W^{2}$ 等于 $U_{+}^{2}$，在负权重层中等于 $U_{-}^{2}$，我们得到\n$$\\mathbb{E}[W^{2}] = p_{+}\\,\\mathbb{E}[U_{+}^{2}] + p_{-}\\,\\mathbb{E}[U_{-}^{2}] = p_{+}\\,(\\sigma_{+}^{2}+\\mu_{+}^{2}) + p_{-}\\,(\\sigma_{-}^{2}+\\mu_{-}^{2}),$$\n其中我们使用了 $\\mathbb{E}[U^{2}] = \\mathrm{Var}(U)+(\\mathbb{E}[U])^{2}$。因此，\n$$\\mathrm{Var}(\\hat{I}_{\\mathrm{naive}}) = \\frac{1}{N}\\left(p_{+}\\,(\\sigma_{+}^{2}+\\mu_{+}^{2}) + p_{-}\\,(\\sigma_{-}^{2}+\\mu_{-}^{2}) - I^{2}\\right),$$\n其中 $I = p_{+}\\mu_{+} - p_{-}\\mu_{-}$。\n\n任务2（符号分层估计量及其方差）。将 $n_{+}$ 个样本分配给正权重层，$n_{-}$ 个样本分配给负权重层，其中 $n_{+}+n_{-}=N$。在每个层内，构建样本均值\n$$\\bar{U}_{+} \\equiv \\frac{1}{n_{+}}\\sum_{i=1}^{n_{+}} U_{+,i}, \\quad \\bar{U}_{-} \\equiv \\frac{1}{n_{-}}\\sum_{j=1}^{n_{-}} U_{-,j}.$$\n定义分层估计量\n$$\\hat{I}_{\\mathrm{strat}}(n_{+},n_{-}) \\equiv p_{+}\\,\\bar{U}_{+} - p_{-}\\,\\bar{U}_{-}.$$\n根据期望的线性性和各层均值，该估计量是无偏的：\n$$\\mathbb{E}[\\hat{I}_{\\mathrm{strat}}] = p_{+}\\,\\mathbb{E}[\\bar{U}_{+}] - p_{-}\\,\\mathbb{E}[\\bar{U}_{-}] = p_{+}\\mu_{+} - p_{-}\\mu_{-} = I.$$\n利用层间独立性和层内样本均值的性质，其方差为\n$$\\mathrm{Var}(\\hat{I}_{\\mathrm{strat}}) = p_{+}^{2}\\,\\mathrm{Var}(\\bar{U}_{+}) + p_{-}^{2}\\,\\mathrm{Var}(\\bar{U}_{-}) = p_{+}^{2}\\,\\frac{\\sigma_{+}^{2}}{n_{+}} + p_{-}^{2}\\,\\frac{\\sigma_{-}^{2}}{n_{-}}.$$\n我们在约束条件 $n_{+}+n_{-}=N$ 和 $n_{+},n_{-} \\in \\mathbb{R}_{0}$ 下，关于 $n_{+}, n_{-}$ 最小化该方差。为该约束引入一个拉格朗日乘子 $\\lambda$，最小化\n$$\\mathcal{L}(n_{+},n_{-},\\lambda) = p_{+}^{2}\\,\\frac{\\sigma_{+}^{2}}{n_{+}} + p_{-}^{2}\\,\\frac{\\sigma_{-}^{2}}{n_{-}} + \\lambda\\,(n_{+}+n_{-}-N).$$\n将偏导数设为零，\n$$\\frac{\\partial \\mathcal{L}}{\\partial n_{+}} = -p_{+}^{2}\\,\\frac{\\sigma_{+}^{2}}{n_{+}^{2}} + \\lambda = 0,\\quad \\frac{\\partial \\mathcal{L}}{\\partial n_{-}} = -p_{-}^{2}\\,\\frac{\\sigma_{-}^{2}}{n_{-}^{2}} + \\lambda = 0,$$\n这意味着\n$$\\frac{p_{+}^{2}\\sigma_{+}^{2}}{n_{+}^{2}} = \\frac{p_{-}^{2}\\sigma_{-}^{2}}{n_{-}^{2}} \\quad \\Rightarrow \\quad \\frac{n_{+}}{n_{-}} = \\frac{p_{+}\\sigma_{+}}{p_{-}\\sigma_{-}}.$$\n使用 $n_{+}+n_{-}=N$，每个层中的最优分配与 $p_{h}\\sigma_{h}$ 成正比。记 $S \\equiv p_{+}\\sigma_{+} + p_{-}\\sigma_{-}$，我们得到\n$$n_{+}^{\\star} = N\\,\\frac{p_{+}\\sigma_{+}}{S},\\quad n_{-}^{\\star} = N\\,\\frac{p_{-}\\sigma_{-}}{S}.$$\n\n任务3（最优比例和最小方差）。最优正权重层比例为\n$$f_{+}^{\\star} \\equiv \\frac{n_{+}^{\\star}}{N} = \\frac{p_{+}\\,\\sigma_{+}}{p_{+}\\sigma_{+}+p_{-}\\sigma_{-}}.$$\n将 $n_{+}^{\\star},n_{-}^{\\star}$ 代入分层方差表达式，得到最小方差\n$$\\mathrm{Var}(\\hat{I}_{\\mathrm{opt}}) = p_{+}^{2}\\frac{\\sigma_{+}^{2}}{n_{+}^{\\star}} + p_{-}^{2}\\frac{\\sigma_{-}^{2}}{n_{-}^{\\star}} = \\frac{(p_{+}\\sigma_{+}+p_{-}\\sigma_{-})^{2}}{N}.$$\n作为对比，采用均等分配 $n_{+}=\\lfloor N/2 \\rfloor$ 和 $n_{-}=N-\\lfloor N/2 \\rfloor$ 的分层方差为\n$$\\mathrm{Var}(\\hat{I}_{\\mathrm{equal}}) = p_{+}^{2}\\frac{\\sigma_{+}^{2}}{n_{+}} + p_{-}^{2}\\frac{\\sigma_{-}^{2}}{n_{-}}.$$\n朴素混合方差为\n$$\\mathrm{Var}(\\hat{I}_{\\mathrm{naive}}) = \\frac{1}{N}\\left(p_{+}\\,(\\sigma_{+}^{2}+\\mu_{+}^{2}) + p_{-}\\,(\\sigma_{-}^{2}+\\mu_{-}^{2}) - (p_{+}\\mu_{+}-p_{-}\\mu_{-})^{2}\\right).$$\n因此，所要求的比率为\n$$R_{\\mathrm{equal}} \\equiv \\frac{\\mathrm{Var}(\\hat{I}_{\\mathrm{equal}})}{\\mathrm{Var}(\\hat{I}_{\\mathrm{naive}})},\\quad R_{\\mathrm{opt}} \\equiv \\frac{\\mathrm{Var}(\\hat{I}_{\\mathrm{opt}})}{\\mathrm{Var}(\\hat{I}_{\\mathrm{naive}})}.$$\n\n边界情况行为与解释：\n- 如果 $p_{-}=0$，那么 $f_{+}^{\\star}=1$ 且 $\\mathrm{Var}(\\hat{I}_{\\mathrm{opt}})=\\sigma_{+}^{2}/N$，与朴素方差相等，而均等分配则浪费了一半的样本预算，并使方差加倍。\n- 如果抵消很强（例如 $p_{+}\\mu_{+}\\approx p_{-}\\mu_{-}$），$\\mathrm{Var}(\\hat{I}_{\\mathrm{naive}})$ 会主要由 $\\mathbb{E}[W^{2}]$ 主导，而按符号分层可以通过消除样本内部的符号抵消来显著减小方差。\n- 如果 $\\sigma_{+}=\\sigma_{-}$，那么 $f_{+}^{\\star}=p_{+}$ 且分层法达到的方差为 $\\mathrm{Var}(\\hat{I}_{\\mathrm{opt}})=(\\sigma_{+})^{2}/N$，当 $\\mu_{\\pm}$ 绝对值很大且近乎抵消时，这通常比朴素方差有所改善。\n\n实现细节。对每个测试用例，计算 $\\mu_{\\pm}=k_{\\pm}\\theta_{\\pm}$ 和 $\\sigma_{\\pm}=\\sqrt{k_{\\pm}}\\,\\theta_{\\pm}$。然后计算\n$$I=p_{+}\\mu_{+}-p_{-}\\mu_{-},\\quad \\mathrm{Var}(\\hat{I}_{\\mathrm{naive}})=\\frac{p_{+}(\\sigma_{+}^{2}+\\mu_{+}^{2})+p_{-}(\\sigma_{-}^{2}+\\mu_{-}^{2})-I^{2}}{N},$$\n$$\\mathrm{Var}(\\hat{I}_{\\mathrm{equal}})=p_{+}^{2}\\frac{\\sigma_{+}^{2}}{\\lfloor N/2 \\rfloor}+p_{-}^{2}\\frac{\\sigma_{-}^{2}}{N-\\lfloor N/2 \\rfloor},\\quad f_{+}^{\\star}=\\frac{p_{+}\\sigma_{+}}{p_{+}\\sigma_{+}+p_{-}\\sigma_{-}},$$\n$$\\mathrm{Var}(\\hat{I}_{\\mathrm{opt}})=\\frac{(p_{+}\\sigma_{+}+p_{-}\\sigma_{-})^{2}}{N},\\quad R_{\\mathrm{equal}}=\\frac{\\mathrm{Var}(\\hat{I}_{\\mathrm{equal}})}{\\mathrm{Var}(\\hat{I}_{\\mathrm{naive}})},\\quad R_{\\mathrm{opt}}=\\frac{\\mathrm{Var}(\\hat{I}_{\\mathrm{opt}})}{\\mathrm{Var}(\\hat{I}_{\\mathrm{naive}})}.$$\n最后，将 $f_{+}^{\\star}$、$R_{\\mathrm{equal}}$ 和 $R_{\\mathrm{opt}}$ 四舍五入到六位小数，并以指定的单行列表的列表格式为每个测试用例打印它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_case(p_plus, k_plus, theta_plus, k_minus, theta_minus, N):\n    # Derived quantities\n    p_minus = 1.0 - p_plus\n\n    # Means and variances of Gamma(k, theta): mean=k*theta, var=k*theta^2\n    mu_plus = k_plus * theta_plus\n    var_plus = k_plus * (theta_plus ** 2)\n    sigma_plus = np.sqrt(var_plus)\n\n    mu_minus = k_minus * theta_minus\n    var_minus = k_minus * (theta_minus ** 2)\n    sigma_minus = np.sqrt(var_minus)\n\n    # Target mean\n    I = p_plus * mu_plus - p_minus * mu_minus\n\n    # Naive (mixture) estimator variance: Var(W)/N\n    EW2 = p_plus * (var_plus + mu_plus**2) + p_minus * (var_minus + mu_minus**2)\n    var_naive = (EW2 - I**2) / N\n\n    # Equal allocation stratification\n    n_plus_eq = N // 2\n    n_minus_eq = N - n_plus_eq\n    # Guard against division by zero in pathological N=0 (not present in tests)\n    var_equal = 0.0\n    if n_plus_eq  0:\n        var_equal += (p_plus**2) * var_plus / n_plus_eq\n    if n_minus_eq  0:\n        var_equal += (p_minus**2) * var_minus / n_minus_eq\n\n    # Optimal allocation (continuous) fraction and variance\n    denom = p_plus * sigma_plus + p_minus * sigma_minus\n    if denom == 0.0:\n        # Degenerate case: zero within-stratum std devs; variance is zero\n        f_opt = 0.5  # arbitrary since variance is zero; choose symmetric\n        var_opt = 0.0\n    else:\n        f_opt = (p_plus * sigma_plus) / denom\n        var_opt = (denom ** 2) / N\n\n    # Ratios; handle possible zero var_naive\n    if var_naive == 0.0:\n        # If var_naive is zero, ratios are undefined/infinite; set to 0 if numerators also zero else large\n        R_equal = 0.0 if var_equal == 0.0 else float('inf')\n        R_opt = 0.0 if var_opt == 0.0 else float('inf')\n    else:\n        R_equal = var_equal / var_naive\n        R_opt = var_opt / var_naive\n\n    # Clamp f_opt to [0,1] to avoid tiny numerical excursions\n    f_opt = min(max(f_opt, 0.0), 1.0)\n\n    # Round to six decimals\n    f_opt = round(f_opt, 6)\n    R_equal = round(R_equal, 6)\n    R_opt = round(R_opt, 6)\n\n    return [f_opt, R_equal, R_opt]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (p_plus, k_plus, theta_plus, k_minus, theta_minus, N)\n    test_cases = [\n        (0.5, 2.0, 1.0, 5.0, 0.4, 10000),   # Case A\n        (0.99, 2.0, 1.0, 3.0, 5.0, 10000),  # Case B\n        (0.5, 50.0, 0.2, 50.0, 0.2, 10000), # Case C\n        (1.0, 2.0, 1.0, 1.0, 1.0, 10000),   # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        p_plus, k_plus, theta_plus, k_minus, theta_minus, N = case\n        result = compute_case(p_plus, k_plus, theta_plus, k_minus, theta_minus, N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Print as a single-line list of lists with six-decimal floats.\n    def format_inner(lst):\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\"\n\n    print(\"[\" + \",\".join(format_inner(r) for r in results) + \"]\")\n\nsolve()\n```", "id": "3523424"}, {"introduction": "一个蒙特卡洛计算结果的可靠性取决于其误差估计的有效性，而误差估计通常依赖于中心极限定理。最后一个实践练习将探讨一个关键的失效场景：当被积函数的方差为无穷大时，中心极限定理不再适用，这种情况在物理模型的重尾分布中可能出现 [@problem_id:2411534]。通过模拟，你将观察到名义置信区间的覆盖率失效，从而深刻理解标准误差分析的局限性，并认识到验证其基本假设的重要性。", "problem": "考虑单位区间上的一族积分，由下式给出\n$$ I(p) \\equiv \\int_{0}^{1} u^{p} \\, du, $$\n其中 $p$ 是一个满足 $p  -1$ 的实数参数，以使积分存在且为有限值。对于一个在 $[0,1]$ 上均匀分布的随机变量 $U$，定义被积函数为 $f_{p}(U) = U^{p}$。其精确值为\n$$ I(p) = \\frac{1}{p+1}. $$\n对于给定的样本量 $n \\in \\mathbb{N}$ 和批次数 $B \\in \\mathbb{N}$，考虑 $B$ 个独立的批次，每个批次包含从 $[0,1]$ 上的均匀分布中独立抽取的 $n$ 个样本 $U_{1},\\dots,U_{n}$。对于每个批次 $b \\in \\{1,\\dots,B\\}$，定义批次样本均值\n$$ \\bar{f}_{b} = \\frac{1}{n} \\sum_{i=1}^{n} f_{p}(U_{i}), $$\n和无偏批次样本方差\n$$ s_{b}^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n} \\left( f_{p}(U_{i}) - \\bar{f}_{b} \\right)^{2}, $$\n前提是 $n \\ge 2$。当 $n \\ge 2$ 时，定义名义 $95\\%$ 水平的正态半宽\n$$ h_{b} = 1.96 \\cdot \\frac{\\sqrt{s_{b}^{2}}}{\\sqrt{n}}. $$\n对于每个 $n \\ge 2$ 的批次 $b$，构建名义区间\n$$ \\left[ \\bar{f}_{b} - h_{b}, \\, \\bar{f}_{b} + h_{b} \\right]. $$\n设批次 $b$ 的覆盖指示符为 $C_{b}$，如果 $I(p)$ 位于上述区间内，则 $C_{b} = 1$，否则 $C_{b} = 0$。如果 $n  2$，由于样本方差未定义，按惯例定义 $C_{b} = 0$。定义跨批次的经验覆盖率分数为\n$$ \\widehat{\\mathrm{cov}} = \\frac{1}{B} \\sum_{b=1}^{B} C_{b}. $$\n请注意，对于 $p \\le -\\frac{1}{2}$，方差 $\\mathbb{V}[f_{p}(U)]$ 是无穷大的，因为\n$$ \\mathbb{E}\\left[ f_{p}(U)^{2} \\right] = \\int_{0}^{1} u^{2p} \\, du $$\n是发散的，尽管对于所有 $p  -1$，$I(p)$ 仍然是有限的。这种情况违反了中心极限定理（CLT）通常要求的有限方差条件，因此基于正态分布的名义误差界限可能会失效。\n\n您的任务是编写一个完整的程序，对于每个测试用例，都生成经验覆盖率分数 $\\widehat{\\mathrm{cov}}$，以小数形式表示。每个测试用例指定 $(p, n, B, \\text{seed})$，其中 $\\text{seed}$ 用于初始化伪随机数生成器以确保可复现性。不涉及角度和物理单位；无需进行单位转换。所有答案必须以小数表示。\n\n测试套件：\n- 测试 1：$p = -\\frac{1}{2}$，$n = 500$，$B = 200$，$\\text{seed} = 17$。\n- 测试 2：$p = -0.6$，$n = 500$，$B = 200$，$\\text{seed} = 19$。\n- 测试 3：$p = \\frac{1}{2}$，$n = 500$，$B = 200$，$\\text{seed} = 23$。\n- 测试 4：$p = \\frac{1}{2}$，$n = 5000$，$B = 200$，$\\text{seed} = 29$。\n- 测试 5：$p = -\\frac{1}{2}$，$n = 5000$，$B = 200$，$\\text{seed} = 31$。\n- 测试 6：$p = \\frac{1}{2}$，$n = 1$，$B = 200$，$\\text{seed} = 37$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试 1 到测试 6 的六个经验覆盖率分数，按顺序排列，形式为用方括号括起来的逗号分隔列表，例如，\n$$ [x_{1},x_{2},x_{3},x_{4},x_{5},x_{6}]. $$", "solution": "问题陈述已经过评估，并被确定为有效。这是一个在计算统计学中定义明确的问题，其基础是蒙特卡洛积分和假设检验的原理。定义清晰，参数完全指定，并且其背景（探索中心极限定理的极限）在科学上是合理的。没有矛盾、歧义或事实错误。\n\n任务是执行蒙特卡洛模拟，以计算积分 $I(p) = \\int_{0}^{1} u^{p} \\, du$ 的名义 $95\\%$ 置信区间的经验覆盖率分数。该模拟将检验覆盖行为如何随参数 $p$ 变化，该参数控制被积函数 $f_{p}(U) = U^{p}$（其中 $U \\sim \\text{Uniform}[0,1]$）方差的有限性。\n\n已知积分的精确值为 $I(p) = \\frac{1}{p+1}$（对于 $p  -1$）。\n\n对于由 $(p, n, B, \\text{seed})$ 指定的单个测试用例，计算经验覆盖率分数 $\\widehat{\\mathrm{cov}}$ 的算法如下：\n\n1.  使用提供的整数 `seed` 初始化伪随机数生成器，以确保可复现性。\n2.  计算积分的真实值，我们将其表示为 $I_{true} = \\frac{1}{p+1}$。\n3.  对于样本量 $n$ 小于 2 的情况，给出了一个特定规则。如果 $n  2$，样本方差 $s_{b}^{2}$ 未定义。根据惯例，所有批次的覆盖指示符 $C_{b}$ 都设置为 0。因此，经验覆盖率分数 $\\widehat{\\mathrm{cov}}$ 为 0。此情况的计算到此终止。\n4.  对于 $n \\ge 2$ 的主要情况，模拟在 $B$ 个独立批次上进行。我们将维护一个计数器，初始值为零，用于记录置信区间覆盖真实值 $I_{true}$ 的批次数。\n5.  一种高效的方法是立即生成所有 $B$ 个批次所需的所有随机数。我们生成一个 $B \\times n$ 的独立随机变量矩阵，其中每个元素都从 $[0,1]$ 上的均匀分布中抽取。设该矩阵为 $\\mathbf{U}$，其元素为 $U_{b,i}$，其中批次 $b \\in \\{1, \\dots, B\\}$，样本索引 $i \\in \\{1, \\dots, n\\}$。\n6.  将被积函数 $f_{p}(u) = u^{p}$ 按元素应用于矩阵 $\\mathbf{U}$，得到一个新矩阵 $\\mathbf{F}$，其元素为 $F_{b,i} = (U_{b,i})^{p}$。$\\mathbf{F}$ 的每一行对应一个批次的样本 $\\{f_{p}(U_{i})\\}_{i=1}^{n}$。\n7.  对于每个批次 $b$（即 $\\mathbf{F}$ 的每一行），我们计算所需的统计量：\n    a. 批次样本均值：$\\bar{f}_{b} = \\frac{1}{n} \\sum_{i=1}^{n} F_{b,i}$。这可以通过对 $\\mathbf{F}$ 的每一行求均值来同时为所有批次进行计算。\n    b. 无偏批次样本方差：$s_{b}^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n} (F_{b,i} - \\bar{f}_{b})^{2}$。这也可以通过对 $\\mathbf{F}$ 的每一行计算样本方差（使用一度自由度校正，`ddof=1`）来为所有批次进行计算。\n8.  使用这些统计量，我们为每个批次计算名义 $95\\%$ 置信区间的半宽：\n    $$h_{b} = 1.96 \\cdot \\frac{\\sqrt{s_{b}^{2}}}{\\sqrt{n}}$$\n    注意，值 $1.96$ 是标准正态分布的 $0.975$ 分位数 $z_{0.025}$ 的近似值。\n9.  对于每个批次 $b$，我们判断置信区间 $[\\bar{f}_{b} - h_{b}, \\bar{f}_{b} + h_{b}]$ 是否包含真实值 $I_{true}$。这个条件等价于检验绝对误差 $|\\bar{f}_{b} - I_{true}|$ 是否小于或等于半宽 $h_{b}$。\n10. 统计满足此条件的批次数。设此计数为 $N_{covered}$。\n11. 经验覆盖率分数是覆盖区间数与总批次数的比率：\n    $$\\widehat{\\mathrm{cov}} = \\frac{N_{covered}}{B}$$\n对指定的六个测试用例中的每一个都执行此过程。理论上的预期是，对于 $p  -1/2$（此时 $f_{p}(U)$ 的方差是有限的），中心极限定理成立，$\\widehat{\\mathrm{cov}}$ 应接近名义水平 $0.95$，尤其是在 $n$ 较大时。相反，对于 $p \\le -1/2$，方差是无穷大的，基于正态分布的置信区间的理论基础无效，我们预计 $\\widehat{\\mathrm{cov}}$ 将显著偏离 $0.95$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_coverage(p: float, n: int, B: int, seed: int) - float:\n    \"\"\"\n    Computes the empirical coverage fraction for a given set of parameters.\n\n    Args:\n        p: The exponent parameter for the integrand u^p.\n        n: The sample size for each batch.\n        B: The number of batches.\n        seed: The seed for the random number generator.\n\n    Returns:\n        The empirical coverage fraction as a float.\n    \"\"\"\n    # Per the problem statement, for n  2, the sample variance is not defined,\n    # and the coverage indicator C_b is 0 by convention. Thus, the total\n    # empirical coverage is 0.\n    if n  2:\n        return 0.0\n\n    # Initialize the pseudorandom number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Calculate the exact value of the integral I(p) = 1/(p+1).\n    I_true = 1.0 / (p + 1.0)\n\n    # Generate all uniform random samples for all B batches at once.\n    # The shape of the resulting array is (B, n).\n    uniform_samples = rng.uniform(size=(B, n))\n\n    # Evaluate the integrand f_p(u) = u^p on the samples.\n    f_p_samples = uniform_samples**p\n\n    # Calculate batch means along axis 1 (across samples in a batch).\n    # The result is an array of shape (B,).\n    batch_means = np.mean(f_p_samples, axis=1)\n\n    # Calculate unbiased batch sample variances along axis 1.\n    # ddof=1 ensures the denominator is (n-1).\n    # The result is an array of shape (B,).\n    batch_variances = np.var(f_p_samples, axis=1, ddof=1)\n\n    # Calculate the half-width of the nominal 95% confidence interval for each batch.\n    # h_b = 1.96 * sqrt(s_b^2 / n)\n    # A small epsilon is not strictly necessary with standard floating point\n    # arithmetic as var = 0, but good practice to consider. Here, it is omitted.\n    half_widths = 1.96 * np.sqrt(batch_variances / n)\n\n    # Determine for each batch if the true value is within the confidence interval.\n    # This is true if |sample_mean - true_value| = half_width.\n    # This operation returns a boolean array of shape (B,).\n    is_covered = np.abs(batch_means - I_true) = half_widths\n\n    # The empirical coverage is the mean of the boolean indicators (True=1, False=0).\n    coverage_fraction = np.mean(is_covered)\n\n    return coverage_fraction\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (p, n, B, seed)\n    test_cases = [\n        (-0.5, 500, 200, 17),    # Test 1\n        (-0.6, 500, 200, 19),    # Test 2\n        (0.5, 500, 200, 23),     # Test 3\n        (0.5, 5000, 200, 29),    # Test 4\n        (-0.5, 5000, 200, 31),   # Test 5\n        (0.5, 1, 200, 37),      # Test 6\n    ]\n\n    results = []\n    for p, n, B, seed in test_cases:\n        # Calculate the empirical coverage for the current test case.\n        result = compute_coverage(p, n, B, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2411534"}]}