{"hands_on_practices": [{"introduction": "在任何减除方案的核心，都依赖于对诸如 $s_{ij}$ 等运动学不变量的精确计算。在共线极限下，即两个部分子变得近乎平行时，对 $s_{ij}$ 的直接计算会遭遇“灾难性相消”（catastrophic cancellation），导致巨大的数值误差。本练习 [@problem_id:3538683] 旨在揭示这一关键的数值陷阱，并演示如何通过一个简单的三角恒等式变换来恢复数值稳定性，这是计算物理学家必须掌握的一项核心技能。", "problem": "考虑在度规符号差为 $(+,-,-,-)$ 的闵可夫斯基空间中，对一对无质量四动量的运动学不变量进行求值，该不变量定义为 $s_{ij} = (p_i + p_j)^2$。在 Catani-Seymour (CS) 偶极减除和 Frixione-Kunszt-Signer (FKS) 方案的背景下，$s_{ij}$ 在红外和共线极限附近的行为至关重要。当 $s_{ij}$ 接近机器精度的数值时，你将对其进行数值精度压力测试，并在计算一个依赖于 $s_{ij}$ 的简化偶极因子时，比较两种计算方法的稳定性。\n\n使用以下基本依据：\n- 四维矢量 $p^\\mu = (E, \\vec{p})$ 的闵可夫斯基点积为 $p^2 = E^2 - \\|\\vec{p}\\|^2$。\n- 对于无质量动量，$E = \\|\\vec{p}\\|$ 且 $s_{ij} = 2\\,p_i \\cdot p_j = 2 E_i E_j \\left(1 - \\cos \\theta_{ij}\\right)$，其中 $\\theta_{ij}$ 是 $\\vec{p}_i$ 和 $\\vec{p}_j$ 之间的夹角。\n- 半角恒等式 $\\sin^2\\left(\\frac{\\theta}{2}\\right) = \\frac{1}{2}\\left(1 - \\cos \\theta\\right)$。\n\n为无质量动量定义两种计算 $s_{ij}$ 的方法：\n1. 直接不变量法：通过和 $(p_i + p_j)^2$ 的闵可夫斯基范数计算 $s_{ij}$，即明确构造空间分量以实现 $s_{ij} = (E_i + E_j)^2 - \\|\\vec{p}_i + \\vec{p}_j\\|^2$。当 $\\theta_{ij}$ 很小时，此评估涉及两个相近大数的相减。\n2. 重缩放角度法：通过半角表示法 $s_{ij} = 4 E_i E_j \\sin^2\\left(\\frac{\\theta_{ij}}{2}\\right)$ 计算 $s_{ij}$，这避免了在共线极限下的灾难性抵消。\n\n定义简化偶极因子 $D_{ij} = \\frac{1}{s_{ij}}$，它捕捉了与减除方案相关的主要共线敏感性。\n\n对于下方的每个测试用例，在 $x$-$z$ 平面内按如下方式构造无质量三动量：\n- 设 $\\vec{p}_i = (0, 0, E_i)$。\n- 设 $\\vec{p}_j = (E_j \\sin \\theta, 0, E_j \\cos \\theta)$。\n- 那么 $p_i = (E_i, \\vec{p}_i)$ 且 $p_j = (E_j, \\vec{p}_j)$。\n\n对于基准真值评估，使用 $s_{ij}^{\\text{true}} = 2 E_i E_j \\left(1 - \\cos \\theta\\right)$，其中对于非常小的角度，必须使用级数展开：\n$$\n1 - \\cos \\theta = \\frac{\\theta^2}{2} - \\frac{\\theta^4}{24} + \\frac{\\theta^6}{720} - \\frac{\\theta^8}{40320},\n$$\n而对于较大的角度，使用精确的余弦值。\n\n对于每个测试用例，计算 $D_{ij}^{\\text{direct}}$ 和 $D_{ij}^{\\text{rescaled}}$ 相对于 $D_{ij}^{\\text{true}} = \\frac{1}{s_{ij}^{\\text{true}}}$ 的绝对相对误差。如果重缩放角度法产生的绝对相对误差严格小于直接不变量法，则输出整数 $1$，否则输出 $0$。如果 $D_{ij}^{\\text{true}}$ 未定义或为无穷大（例如，当 $\\theta = 0$ 导致 $s_{ij}^{\\text{true}} = 0$ 时），则该用例输出 $0$。\n\n角度必须以弧度为单位，能量必须以吉电子伏特 (GeV) 为单位。不需要进行单位转换；计算完全是基于这些输入的无量纲比率和不变量。\n\n测试套件（能量单位为 GeV，角度单位为弧度）：\n- 用例 A (正常路径): $(E_i, E_j, \\theta) = (100, 100, 10^{-3})$。\n- 用例 B (近共线，小角度): $(E_i, E_j, \\theta) = (10^{3}, 10^{3}, 10^{-12})$。\n- 用例 C (接近机器精度): $(E_i, E_j, \\theta) = (10^{3}, 10^{3}, 10^{-16})$。\n- 用例 D (极端能量比，接近机器精度): $(E_i, E_j, \\theta) = (10^{9}, 1, 10^{-16})$。\n- 用例 E (精确共线作为边界): $(E_i, E_j, \\theta) = (100, 35, 0)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述测试套件顺序排列的结果，例如 $\\left[\\texttt{resultA},\\texttt{resultB},\\texttt{resultC},\\texttt{resultD},\\texttt{resultE}\\right]$，其中每个条目为 $0$ 或 $1$。", "solution": "问题陈述已经过分析并被认为是**有效的**。它在科学上基于狭义相对论和计算物理学的原理，特别解决了在高能物理学中次领头阶 (NLO) 计算的一个关键方面——即在共线极限下计算运动学不变量时遇到的数值稳定性问题。该问题是适定的，所有必需的数据、公式和评估标准都已明确定义。\n\n核心任务是比较两种计算两个无质量四动量 $p_i$ 和 $p_j$ 的运动学不变量 $s_{ij} = (p_i + p_j)^2$ 的方法的数值稳定性，尤其是在它们的空间动量 $\\vec{p}_i$ 和 $\\vec{p}_j$ 之间的夹角 $\\theta_{ij}$ 趋近于零（共线极限）的情况下。通过计算每种方法计算出的简化偶极因子 $D_{ij} = 1/s_{ij}$ 相对于高精度基准真值的绝对相对误差来评估其稳定性。\n\n无质量粒子的四动量由 $p^\\mu = (E, \\vec{p})$ 给出，其中能量 $E$ 等于三动量的模 $E = \\|\\vec{p}\\|$。度规符号差为 $(+, -, -, -)$。不变量 $s_{ij}$ 解析上等价于 $s_{ij} = 2 p_i \\cdot p_j = 2 E_i E_j (1 - \\cos \\theta_{ij})$。\n\n该问题为 $s_{ij}$ 定义了三种计算方法：基准真值法、直接不变量法和重缩放角度法。\n\n**1. 基准真值计算 ($s_{ij}^{\\text{true}}$)**\n\n基准真值基于公式 $s_{ij}^{\\text{true}} = 2 E_i E_j (1 - \\cos \\theta)$。对于非常小的 $\\theta$，由于 $\\cos \\theta$ 趋近于 $1$，对 $(1 - \\cos \\theta)$ 项的朴素计算会遭受灾难性抵消。为确保参考值的高精度，问题强制要求对小角度使用 $1 - \\cos \\theta$ 的泰勒级数展开：\n$$\n1 - \\cos \\theta = \\frac{\\theta^2}{2!} - \\frac{\\theta^4}{4!} + \\frac{\\theta^6}{6!} - \\frac{\\theta^8}{8!} + \\mathcal{O}(\\theta^{10})\n$$\n在我们的实现中，我们将对小于 $10^{-6}$ 弧度的角度使用此级数，这是一个阈值，低于此阈值时，标准的双精度浮点运算对于 $(1 - \\cos \\theta)$ 会开始损失显著精度。对于 $\\theta \\ge 10^{-6}$，直接计算已足够精确。\n\n**2. 方法 1：直接不变量法 ($s_{ij}^{\\text{direct}}$)**\n\n此方法通过直接实现四维矢量和的不变量定义来计算 $s_{ij}$：\n$$\ns_{ij}^{\\text{direct}} = (p_i + p_j)^2 = (E_i + E_j)^2 - \\|\\vec{p}_i + \\vec{p}_j\\|^2\n$$\n无质量三动量在 $x$-$z$ 平面中构造：$\\vec{p}_i = (0, 0, E_i)$ 和 $\\vec{p}_j = (E_j \\sin \\theta, 0, E_j \\cos \\theta)$。它们的和是 $\\vec{p}_i + \\vec{p}_j = (E_j \\sin \\theta, 0, E_i + E_j \\cos \\theta)$。其范数的平方是：\n$$\n\\|\\vec{p}_i + \\vec{p}_j\\|^2 = (E_j \\sin \\theta)^2 + (E_i + E_j \\cos \\theta)^2 = E_j^2 \\sin^2 \\theta + E_i^2 + 2 E_i E_j \\cos \\theta + E_j^2 \\cos^2 \\theta = E_i^2 + E_j^2 + 2 E_i E_j \\cos \\theta\n$$\n将此代入 $s_{ij}^{\\text{direct}}$ 的表达式中，得到：\n$$\ns_{ij}^{\\text{direct}} = (E_i^2 + 2 E_i E_j + E_j^2) - (E_i^2 + E_j^2 + 2 E_i E_j \\cos \\theta)\n$$\n在共线极限 ($\\theta \\to 0$) 下，$\\cos \\theta \\to 1$，因此 $\\|\\vec{p}_i + \\vec{p}_j\\|^2 \\to E_i^2 + E_j^2 + 2 E_i E_j = (E_i + E_j)^2$。该计算涉及两个非常大且几乎相等的数相减，这是灾难性抵消和严重精度损失的经典来源。因此，预计此方法对于小 $\\theta$ 值会表现不佳。\n\n**3. 方法 2：重缩放角度法 ($s_{ij}^{\\text{rescaled}}$)**\n\n此方法使用三角半角恒等式 $1 - \\cos \\theta = 2 \\sin^2(\\frac{\\theta}{2})$ 重新表述 $s_{ij}$ 的表达式。\n$$\ns_{ij}^{\\text{rescaled}} = 2 E_i E_j (1 - \\cos \\theta) = 2 E_i E_j \\left(2 \\sin^2\\left(\\frac{\\theta}{2}\\right)\\right) = 4 E_i E_j \\sin^2\\left(\\frac{\\theta}{2}\\right)\n$$\n对于小 $\\theta$，其参数 $\\theta/2$ 也很小，且 $\\sin(\\theta/2) \\approx \\theta/2$。该计算涉及小数相乘，这在数值上是稳定的并能保持相对精度。因此，预计此方法即使对于极小的角度也高度精确。\n\n**评估与比较**\n\n对于每个测试用例，我们计算偶极因子 $D_{ij}^{\\text{direct}} = 1/s_{ij}^{\\text{direct}}$ 和 $D_{ij}^{\\text{rescaled}} = 1/s_{ij}^{\\text{rescaled}}$，并将其与基准真值 $D_{ij}^{\\text{true}} = 1/s_{ij}^{\\text{true}}$ 进行比较。比较指标是绝对相对误差，例如，对于直接法：\n$$\n\\text{err}_{\\text{direct}} = \\left| \\frac{D_{ij}^{\\text{direct}} - D_{ij}^{\\text{true}}}{D_{ij}^{\\text{true}}} \\right| = \\left| \\frac{1/s_{ij}^{\\text{direct}} - 1/s_{ij}^{\\text{true}}}{1/s_{ij}^{\\text{true}}} \\right| = \\left| \\frac{s_{ij}^{\\text{true}}}{s_{ij}^{\\text{direct}}} - 1 \\right|\n$$\n后一种形式在计算上更可取，因为当偶极因子非常大时它更稳定。如果 $\\text{err}_{\\text{rescaled}} < \\text{err}_{\\text{direct}}$，则记录整数 $1$，否则记录 $0$。对于 $\\theta = 0$ 的情况，$s_{ij}^{\\text{true}}=0$，导致 $D_{ij}^{\\text{true}}$ 为无穷大；问题规定对于此边界情况输出 $0$。\n\n**测试用例分析：**\n- **用例 A ($E_i=100, E_j=100, \\theta=10^{-3}$):** 角度很小但并非极端。两种方法都应能提供合理的结果，但预计重缩放角度法会更精确。\n- **用例 B ($E_i=10^3, E_j=10^3, \\theta=10^{-12}$):** 角度非常小。直接法将遭受显著的灾难性抵消，从而产生一个高度不准确或为零的结果。重缩放角度法将保持精确。\n- **用例 C ($E_i=10^3, E_j=10^3, \\theta=10^{-16}$):** 角度接近双精度浮点数的机器精度。在标准浮点数学中，`1 - cos(theta)` 项将精确计算为零，导致直接法完全失效 ($s_{ij}^{\\text{direct}}=0$)。而计算 $\\sin(\\theta/2)$ 的重缩放角度法将产生一个有效的非零结果。\n- **用例 D ($E_i=10^9, E_j=1, \\theta=10^{-16}$):** 与用例 C 相似，但能量比极端。由于小角度问题，再加上能量的巨大数值范围，直接法将再次失效。重缩放角度法依然保持鲁棒性。\n- **用例 E ($E_i=100, E_j=35, \\theta=0$):** 这代表了精确的共线奇点。根据问题的规则，由于 $s_{ij}^{\\text{true}}=0$，输出为 $0$。\n\n基于此分析，我们预期在所有 $\\theta$ 很小的情况下（A、B、C、D），重缩放角度法都将绝对更优，而用例 E 则由特定的问题规则决定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the numerical stability of two methods for calculating\n    the kinematic invariant s_ij in the collinear limit.\n    \"\"\"\n    # Test suite (E_i [GeV], E_j [GeV], theta [rad])\n    test_cases = [\n        (100.0, 100.0, 1.0e-3),   # Case A\n        (1.0e3, 1.0e3, 1.0e-12),  # Case B\n        (1.0e3, 1.0e3, 1.0e-16),  # Case C\n        (1.0e9, 1.0, 1.0e-16),    # Case D\n        (100.0, 35.0, 0.0),       # Case E\n    ]\n\n    results = []\n    \n    # Threshold for using Taylor series for 1 - cos(theta)\n    TAYLOR_THRESHOLD = 1.0e-6\n\n    for case in test_cases:\n        E_i, E_j, theta = case\n\n        # Per problem specification, if theta=0, output 0.\n        if theta == 0.0:\n            results.append(0)\n            continue\n\n        # 1. Ground-Truth Calculation (s_true)\n        # Use Taylor series for small theta to maintain high precision\n        if theta  TAYLOR_THRESHOLD:\n            theta2 = theta**2\n            theta4 = theta**4\n            theta6 = theta**6\n            theta8 = theta**8\n            # Series: theta^2/2 - theta^4/24 + theta^6/720 - theta^8/40320\n            one_minus_cos = theta2/2.0 - theta4/24.0 + theta6/720.0 - theta8/40320.0\n        else:\n            one_minus_cos = 1.0 - np.cos(theta)\n        \n        s_true = 2.0 * E_i * E_j * one_minus_cos\n        \n        # If s_true is zero (due to underflow), D_true is infinite/undefined. Output 0.\n        if s_true == 0.0:\n            results.append(0)\n            continue\n\n        # 2. Method 1: Direct Invariant (s_direct)\n        p_i_vec = np.array([0.0, 0.0, E_i])\n        p_j_vec = np.array([E_j * np.sin(theta), 0.0, E_j * np.cos(theta)])\n        p_sum_vec = p_i_vec + p_j_vec\n        p_sum_vec_norm_sq = np.dot(p_sum_vec, p_sum_vec)\n        s_direct = (E_i + E_j)**2 - p_sum_vec_norm_sq\n\n        # 3. Method 2: Rescaled-Angle (s_rescaled)\n        s_rescaled = 4.0 * E_i * E_j * (np.sin(theta / 2.0))**2\n\n        # 4. Comparison\n        # Handle cases where a method returns zero, implying infinite error.\n        if s_direct == 0.0:\n            # If direct method fails and rescaled doesn't, rescaled is better.\n            if s_rescaled != 0.0:\n                results.append(1)\n                continue\n            # If both fail, rescaled is not strictly better.\n            else:\n                results.append(0)\n                continue\n        \n        # If rescaled method fails (and direct didn't), it's not better.\n        if s_rescaled == 0.0:\n            results.append(0)\n            continue\n\n        # Calculate absolute relative errors using the stable form.\n        err_direct = abs(s_true / s_direct - 1.0)\n        err_rescaled = abs(s_true / s_rescaled - 1.0)\n        \n        if err_rescaled  err_direct:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3538683"}, {"introduction": "掌握了单个不变量的计算之后，我们现在转向减除方案的宏觀逻辑。处理红外发散的两种常用方法是相空间切片法（phase-space slicing）和局域减除法（local subtraction）。尽管它们的操作方式不同——前者引入一个显式的截断，后者通过加减一个局域抵消项——但在奇点被抵消后，它们必须得到相同的、物理的、有限的结果。本练习 [@problem_id:3538697] 提供了一个具体的玩具模型来验证这一等价性。通过同时实现切片方案和减除方案，您将以数值方式验证它们收敛到相同的有限余项，从而巩固您对红外发散抵消普适性的理解。", "problem": "考虑一个玩具模型，用于在计算高能物理学中处理红外发散的扣除方案（如 Catani-Seymour 偶极扣除和 Frixione-Kunszt-Signer (FKS) 扣除）的背景下，验证局域扣除反项与相空间切片方法的一致性。设实发射微分权重在一个二维单位相空间上（变量为 $x \\in (0,1)$ 和 $z \\in (0,1)$）由一个被积函数 $R(x,z)$ 建模，该函数具有软和共线奇异结构，当 $x \\to 0$ 和 $z \\to 1$ 时，分别由其领头项近似。定义三个光滑函数\n$$\nA(x,z) = a_0 + a_1 x + a_2 (1 - z) + a_3 x (1 - z), \\quad\nB(x,z) = b_0 + b_1 x + b_2 (1 - z) + b_3 x (1 - z), \\quad\nG(x,z) = \\gamma\\, x^{r}\\, (1 - z)^{s},\n$$\n其参数 $a_0,a_1,a_2,a_3,b_0,b_1,b_2,b_3,\\gamma,r,s$ 为实数，其中 $\\gamma \\ge 0$，$r \\ge 0$ 且 $s \\ge 0$。该玩具模型的实发射被积函数为\n$$\nR(x,z) = \\frac{A(x,z)}{x} + \\frac{B(x,z)}{1 - z} + G(x,z).\n$$\n为了模拟一个局域扣除方案（本着 Catani-Seymour 或 Frixione-Kunszt-Signer 的精神），定义局域反项\n$$\nS_{\\text{soft}}(x,z) = \\frac{A(0,z)}{x}, \\qquad S_{\\text{coll}}(x,z) = \\frac{B(x,1)}{1 - z},\n$$\n其中 $A(0,z) = a_0 + a_2 (1 - z)$ 且 $B(x,1) = b_0 + b_1 x$。对于给定的多项式 $A(x,z)$ 和 $B(x,z)$，只要 $r \\ge 0$ 和 $s \\ge 0$，则扣除后的被积函数\n$$\nF(x,z) = R(x,z) - S_{\\text{soft}}(x,z) - S_{\\text{coll}}(x,z)\n$$\n在整个单位正方形上必须是有限的。扣除方案的积分有限余项定义为\n$$\nC_{\\text{sub}} = \\int_0^1 \\int_0^1 F(x,z)\\, \\mathrm{d}x\\, \\mathrm{d}z.\n$$\n独立地，定义一个具有红外截断 $\\delta \\in (0,1)$ 的相空间切片方案，该截断同时作用于软和共线区域。实发射被积函数的切片积分为\n$$\nI_{\\text{slice}}(\\delta) = \\int_{0}^{1-\\delta} \\int_{\\delta}^{1} R(x,z)\\, \\mathrm{d}x\\, \\mathrm{d}z.\n$$\n为了分离出可与扣除方案相比较的有限余项，考虑通过减去在互补变量上积分的领头奇异权重来消除对截断的对数依赖性：\n$$\nC_{\\text{slice}}(\\delta) = I_{\\text{slice}}(\\delta) - \\ln\\!\\left(\\frac{1}{\\delta}\\right)\\left(\\int_0^1 A(0,z)\\, \\mathrm{d}z + \\int_0^1 B(x,1)\\, \\mathrm{d}x\\right).\n$$\n交叉验证的目标是数值上证明，对于所描述的玩具模型，积分有限余项的两种定义在极限 $\\delta \\to 0$ 下是等价的，即\n$$\n\\lim_{\\delta \\to 0} \\left[ C_{\\text{slice}}(\\delta) - C_{\\text{sub}} \\right] = 0.\n$$\n从基本前提开始，即红外发散表现为对于红外安全检验函数是可积的奇点，并且逐点减去领头奇异行为会使余项在整个相空间上可积。根据需要使用积分的介值性质和控制收敛定理，但除上述定义外，不要假设任何快捷公式。\n\n你的任务是编写一个完整的程序，该程序针对一组参数化的测试用例，计算三个截断值 $\\delta \\in \\{10^{-2}, 10^{-4}, 10^{-6}\\}$ 对应的 $C_{\\text{sub}}$ 和 $C_{\\text{slice}}(\\delta)$，并为每个测试用例和每个 $\\delta$ 值返回绝对差 $\\left|C_{\\text{slice}}(\\delta) - C_{\\text{sub}}\\right|$。所有量都是无量纲的，因此不需要物理单位。问题不涉及角度，因此也无需指定角度单位。\n\n在指定的定义域上稳健地实现数值积分。对于对数扣除项，根据给定的多项式精确计算 $\\int_0^1 A(0,z)\\, \\mathrm{d}z$ 和 $\\int_0^1 B(x,1)\\, \\mathrm{d}x$。\n\n使用以下测试参数值套件，它探测了不同的奇异结构：\n- 测试用例1（仅软奇异行为）：$(a_0,a_1,a_2,a_3) = (2.0, 1.0, 0.5, 0.3)$，$(b_0,b_1,b_2,b_3) = (0.0, 0.0, 0.0, 0.0)$，$\\gamma = 0.2$，$r = 1.0$，$s = 1.0$。\n- 测试用例2（仅共线奇异行为）：$(a_0,a_1,a_2,a_3) = (0.0, 0.0, 0.0, 0.0)$，$(b_0,b_1,b_2,b_3) = (1.5, 0.4, 0.7, 0.2)$，$\\gamma = 0.3$，$r = 1.0$，$s = 1.0$。\n- 测试用例3（软和共线奇异组合行为）：$(a_0,a_1,a_2,a_3) = (1.0, 0.5, 0.2, 0.1)$，$(b_0,b_1,b_2,b_3) = (0.8, 0.3, 0.4, 0.1)$，$\\gamma = 0.25$，$r = 1.0$，$s = 0.5$。\n- 测试用例4（仅有限项基线）：$(a_0,a_1,a_2,a_3) = (0.0, 0.0, 0.0, 0.0)$，$(b_0,b_1,b_2,b_3) = (0.0, 0.0, 0.0, 0.0)$，$\\gamma = 0.5$，$r = 0.0$，$s = 0.0$。\n\n你的程序应生成单行输出，包含一个由列表组成的列表，格式为逗号分隔。每个内部列表按顺序给出 $\\delta = 10^{-2}, 10^{-4}, 10^{-6}$ 的绝对差。例如，输出格式必须是\n$$\n\\texttt{[[d\\_1(\\delta\\_1),d\\_1(\\delta\\_2),d\\_1(\\delta\\_3)],[d\\_2(\\delta\\_1),d\\_2(\\delta\\_2),d\\_2(\\delta\\_3)],\\ldots]}\n$$\n不含任何额外文本。", "solution": "该问题要求对一个用于处理高能物理计算中红外发散的局域扣除方案的玩具模型进行数值验证。核心任务是证明通过局域扣除方法计算的实发射积分的有限部分 ($C_{\\text{sub}}$)，与通过相空间切片方法计算的有限部分 ($C_{\\text{slice}}(\\delta)$) 在切片截断 $\\delta$ 趋于零的极限下是等价的。\n\n首先，我们分析量 $C_{\\text{sub}}$，即扣除方案的积分有限余项。其定义为：\n$$\nC_{\\text{sub}} = \\int_0^1 \\int_0^1 F(x,z)\\, \\mathrm{d}x\\, \\mathrm{d}z\n$$\n被积函数 $F(x,z)$ 是实发射被积函数 $R(x,z)$ 减去局域扣除反项 $S_{\\text{soft}}(x,z)$ 和 $S_{\\text{coll}}(x,z)$：\n$$\nF(x,z) = R(x,z) - S_{\\text{soft}}(x,z) - S_{\\text{coll}}(x,z)\n$$\n代入 $R$、$S_{\\text{soft}}$ 和 $S_{\\text{coll}}$ 的定义：\n$$\nF(x,z) = \\left( \\frac{A(x,z)}{x} + \\frac{B(x,z)}{1 - z} + G(x,z) \\right) - \\frac{A(0,z)}{x} - \\frac{B(x,1)}{1 - z}\n$$\n通过重新整理各项，我们可以看到奇点是如何被局域抵消的：\n$$\nF(x,z) = \\frac{A(x,z) - A(0,z)}{x} + \\frac{B(x,z) - B(x,1)}{1-z} + G(x,z)\n$$\n我们来计算分子。给定 $A(x,z) = a_0 + a_1 x + a_2 (1 - z) + a_3 x (1 - z)$，我们有 $A(0,z) = a_0 + a_2(1-z)$。其差值为：\n$$\nA(x,z) - A(0,z) = (a_0 + a_1 x + a_2 (1 - z) + a_3 x (1 - z)) - (a_0 + a_2(1-z)) = a_1 x + a_3 x (1-z) = x(a_1 + a_3(1-z))\n$$\n因此，$F(x,z)$ 的第一项简化为一个正则多项式：\n$$\n\\frac{A(x,z) - A(0,z)}{x} = a_1 + a_3(1-z)\n$$\n类似地，对于第二项，有 $B(x,z) = b_0 + b_1 x + b_2 (1 - z) + b_3 x (1 - z)$ 和 $B(x,1) = b_0 + b_1 x$，其差值为：\n$$\nB(x,z) - B(x,1) = (b_0 + b_1 x + b_2 (1 - z) + b_3 x (1 - z)) - (b_0 + b_1 x) = b_2(1-z) + b_3 x (1-z) = (1-z)(b_2 + b_3 x)\n$$\n这简化了第二项：\n$$\n\\frac{B(x,z) - B(x,1)}{1-z} = b_2 + b_3 x\n$$\n因此，扣除后的被积函数 $F(x,z)$ 是在整个定义域 $[0,1] \\times [0,1]$ 上的正则函数之和：\n$$\nF(x,z) = (a_1 + a_3(1-z)) + (b_2 + b_3 x) + \\gamma x^r (1-z)^s\n$$\n由于 $F(x,z)$ 是正则的，其积分 $C_{\\text{sub}}$ 可以解析计算。我们对每一项在 $x \\in [0,1]$ 和 $z \\in [0,1]$ 上积分：\n$$\n\\int_0^1 \\int_0^1 a_1 \\, \\mathrm{d}x \\mathrm{d}z = a_1\n$$\n$$\n\\int_0^1 \\int_0^1 a_3(1-z) \\, \\mathrm{d}x \\mathrm{d}z = a_3 \\left( \\int_0^1 \\! \\mathrm{d}x \\right) \\left( \\int_0^1 (1-z) \\mathrm{d}z \\right) = a_3 (1) \\left[z - \\frac{z^2}{2}\\right]_0^1 = \\frac{a_3}{2}\n$$\n$$\n\\int_0^1 \\int_0^1 b_2 \\, \\mathrm{d}x \\mathrm{d}z = b_2\n$$\n$$\n\\int_0^1 \\int_0^1 b_3 x \\, \\mathrm{d}x \\mathrm{d}z = b_3 \\left( \\int_0^1 x \\mathrm{d}x \\right) \\left( \\int_0^1 \\! \\mathrm{d}z \\right) = b_3 \\left[\\frac{x^2}{2}\\right]_0^1 (1) = \\frac{b_3}{2}\n$$\n$$\n\\int_0^1 \\int_0^1 \\gamma x^r (1-z)^s \\, \\mathrm{d}x \\mathrm{d}z = \\gamma \\left( \\int_0^1 x^r \\mathrm{d}x \\right) \\left( \\int_0^1 (1-z)^s \\mathrm{d}z \\right) = \\gamma \\left[\\frac{x^{r+1}}{r+1}\\right]_0^1 \\left[-\\frac{(1-z)^{s+1}}{s+1}\\right]_0^1 = \\frac{\\gamma}{(r+1)(s+1)}\n$$\n将这些结果相加，得到 $C_{\\text{sub}}$ 的解析表达式：\n$$\nC_{\\text{sub}} = a_1 + \\frac{a_3}{2} + b_2 + \\frac{b_3}{2} + \\frac{\\gamma}{(r+1)(s+1)}\n$$\n接下来，我们分析量 $C_{\\text{slice}}(\\delta)$，其定义为：\n$$\nC_{\\text{slice}}(\\delta) = I_{\\text{slice}}(\\delta) - \\ln\\!\\left(\\frac{1}{\\delta}\\right)\\left(\\int_0^1 A(0,z)\\, \\mathrm{d}z + \\int_0^1 B(x,1)\\, \\mathrm{d}x\\right)\n$$\n积分 $I_{\\text{slice}}(\\delta)$ 在一个排除了奇点的区域上进行，因此是有限的。然而，完整的被积函数 $R(x,z)$ 足够复杂，需要进行数值积分。积分区域为 $x \\in [\\delta, 1]$ 和 $z \\in [0, 1-\\delta]$。\n$$\nI_{\\text{slice}}(\\delta) = \\int_{0}^{1-\\delta} \\int_{\\delta}^{1} \\left( \\frac{A(x,z)}{x} + \\frac{B(x,z)}{1 - z} + G(x,z) \\right) \\, \\mathrm{d}x\\, \\mathrm{d}z\n$$\n对数扣除项需要对领头奇异行为进行解析积分。设 $I_{\\text{log}} = \\int_0^1 A(0,z)\\, \\mathrm{d}z + \\int_0^1 B(x,1)\\, \\mathrm{d}x$。我们计算这两个积分：\n$$\n\\int_0^1 A(0,z)\\, \\mathrm{d}z = \\int_0^1 (a_0 + a_2(1-z)) \\, \\mathrm{d}z = \\left[a_0 z + a_2\\left(z-\\frac{z^2}{2}\\right)\\right]_0^1 = a_0 + \\frac{a_2}{2}\n$$\n$$\n\\int_0^1 B(x,1)\\, \\mathrm{d}x = \\int_0^1 (b_0 + b_1 x) \\, \\mathrm{d}x = \\left[b_0 x + b_1 \\frac{x^2}{2}\\right]_0^1 = b_0 + \\frac{b_1}{2}\n$$\n因此，对数项的系数是：\n$$\nI_{\\text{log}} = a_0 + \\frac{a_2}{2} + b_0 + \\frac{b_1}{2}\n$$\n每个测试用例的步骤如下：\n1.  使用给定的参数，通过推导出的解析公式计算 $C_{\\text{sub}}$ 的精确值。\n2.  计算对数系数 $I_{\\text{log}}$ 的精确值。\n3.  对于每个截断值 $\\delta \\in \\{10^{-2}, 10^{-4}, 10^{-6}\\}$：\n    a. 通过在定义域 $x \\in [\\delta, 1]$ 和 $z \\in [0, 1-\\delta]$ 上对 $R(x,z)$ 进行积分，数值计算 $I_{\\text{slice}}(\\delta)$。\n    b. 计算 $C_{\\text{slice}}(\\delta) = I_{\\text{slice}}(\\delta) - \\ln(1/\\delta) \\cdot I_{\\text{log}}$。\n    c. 计算绝对差 $|C_{\\text{slice}}(\\delta) - C_{\\text{sub}}|$。\n预期是，随着 $\\delta$ 变小，这个差值会减小，从而证实两种正则化方法之间的一致性。程序实现了这一过程。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes and compares finite remainders from subtraction and slicing schemes\n    for a toy model of infrared divergences.\n    \"\"\"\n    \n    # Test cases:\n    # (a_0, a_1, a_2, a_3), (b_0, b_1, b_2, b_3), gamma, r, s\n    test_cases = [\n        ((2.0, 1.0, 0.5, 0.3), (0.0, 0.0, 0.0, 0.0), 0.2, 1.0, 1.0),\n        ((0.0, 0.0, 0.0, 0.0), (1.5, 0.4, 0.7, 0.2), 0.3, 1.0, 1.0),\n        ((1.0, 0.5, 0.2, 0.1), (0.8, 0.3, 0.4, 0.1), 0.25, 1.0, 0.5),\n        ((0.0, 0.0, 0.0, 0.0), (0.0, 0.0, 0.0, 0.0), 0.5, 0.0, 0.0),\n    ]\n\n    deltas = [1e-2, 1e-4, 1e-6]\n\n    # Helper functions for the integrand components\n    def A_func(x, z, a_params):\n        a0, a1, a2, a3 = a_params\n        return a0 + a1 * x + a2 * (1.0 - z) + a3 * x * (1.0 - z)\n\n    def B_func(x, z, b_params):\n        b0, b1, b2, b3 = b_params\n        return b0 + b1 * x + b2 * (1.0 - z) + b3 * x * (1.0 - z)\n\n    def G_func(x, z, gamma, r, s):\n        # Use np.power for safe handling of 0**0 = 1\n        return gamma * np.power(x, r) * np.power(1.0 - z, s)\n\n    # The full real-emission integrand R(x, z)\n    def R_integrand(x, z, a_params, b_params, gamma, r, s):\n        # The integration domain for I_slice ensures x > 0 and 1-z > 0,\n        # so direct division is safe.\n        term_A = A_func(x, z, a_params) / x\n        term_B = B_func(x, z, b_params) / (1.0 - z)\n        term_G = G_func(x, z, gamma, r, s)\n        return term_A + term_B + term_G\n\n    all_results = []\n    for case in test_cases:\n        a_params, b_params, gamma, r, s = case\n        a0, a1, a2, a3 = a_params\n        b0, b1, b2, b3 = b_params\n\n        # 1. Calculate C_sub analytically\n        c_sub = a1 + a3 / 2.0 + b2 + b3 / 2.0 + gamma / ((r + 1.0) * (s + 1.0))\n\n        # 2. Calculate the logarithmic coefficient I_log analytically\n        i_log = (a0 + a2 / 2.0) + (b0 + b1 / 2.0)\n\n        case_diffs = []\n        for delta in deltas:\n            # 3a. Numerically evaluate I_slice(delta)\n            # nquad integrates func(x,y,...) over ranges=[[xmin,xmax],[ymin,ymax],...]\n            # The order of variables in the function must match the order in ranges.\n            integrand_args = (a_params, b_params, gamma, r, s)\n            ranges = [[delta, 1.0], [0.0, 1.0 - delta]]\n            \n            # Using lambda to match the argument signature for nquad\n            # The function to integrate takes x and z as first arguments\n            i_slice, _ = integrate.nquad(lambda x, z: R_integrand(x, z, *integrand_args), ranges)\n\n            # 3b. Calculate C_slice(delta)\n            c_slice = i_slice - np.log(1.0 / delta) * i_log\n            \n            # 3c. Compute the absolute difference\n            diff = np.abs(c_slice - c_sub)\n            case_diffs.append(diff)\n        \n        all_results.append(case_diffs)\n\n    # Format the final output string\n    # e.g., [[d_1(d_1),d_1(d_2),d_1(d_3)],[d_2(d_1),d_2(d_2),d_2(d_3)],...]\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "3538697"}, {"introduction": "对于具有多个末态部分子的过程，任何一对部分子变得共线都可能产生奇点。自动化的次领阶（NLO）计算程序必须系统地划分相空间，以便对每个奇点进行精确且仅有一次的减除。Frixione–Kunszt–Signer (FKS) 方案通过定义“扇区”（sectors）来完成此任务，每个扇区由唯一一个占主导地位的共线对来表征。这项动手练习 [@problem_id:3538653] 要求您实现这种划分的核心逻辑。您将编写代码，根据一个形式化的约束条件来生成这些FKS扇区，并分析该扇区定义如何正确处理简单和模糊的共线构型，从而深入了解现代NLO计算的算法基础。", "problem": "您的任务是构建并分析一个用于弗里西奥内-昆斯特-西格纳（Frixione–Kunszt–Signer, FKS）扇区的程序化生成器，该任务属于计算高能物理中处理红外发散的减除方案范畴。目标是通过显式约束满足，来强制每个扇区中只隔离一个共线对，并研究扇区数量如何随末态多重数变化。\n\n基本依据和定义：\n- 考虑一个包含 $N$ 个无质量部分子的末态，其四动量为 $\\{p_1,\\dots,p_N\\}$，处于度规符号为 $(+,-,-,-)$ 的闵可夫斯基空间中。对于无质量部分子，有 $p_i^2 = 0$。一对粒子 $(i,j)$ 的不变质量定义为 $s_{ij} = 2 p_i \\cdot p_j$。对于三动量为 $\\vec{p}_i$、能量为 $E_i = \\lvert \\vec{p}_i \\rvert$ 的无质量部分子，有\n\n$$\ns_{ij} = 2(E_i E_j - \\vec{p}_i \\cdot \\vec{p}_j) = 2 E_i E_j (1 - \\cos\\theta_{ij}),\n$$\n\n其中 $\\theta_{ij}$ 是 $\\vec{p}_i$ 和 $\\vec{p}_j$ 之间的夹角。\n- 在微扰量子色动力学（QCD）中，当 $s_{ij} \\to 0$ 时会出现共线奇异性。FKS 扇区将实发射相空间分解为多个区域，每个扇区中恰好只有一个此类极限是活跃的。\n\n通过约束满足构建扇区：\n- 令 $\\mathcal{P}$ 为一个允许定义扇区的有序对 $(i,j)$ 的集合。我们将考虑 $\\mathcal{P}$ 的两种模型：\n  1. 一个朴素的全配对模型，其中 $\\mathcal{P}_{\\mathrm{all}} = \\{(i,j) \\mid 1 \\le i \\le N,\\ 1 \\le j \\le N,\\ i \\ne j\\}$。\n  2. 一个色关联循环邻接模型，其中 $\\mathcal{P}_{\\mathrm{cc}} = \\{(i,j) \\mid j = (i \\pm 1) \\pmod N\\}$，对应于领头色循环排序，因此每个部分子有两个邻居。\n- 对于一个给定的事件 $\\{p_i\\}$，为每个允许的配对 $(i,j) \\in \\mathcal{P}$ 定义扇区指示函数如下\n\n$$\n\\mathbb{I}_{ij}(\\{p\\}; r) = \n\\begin{cases}\n1,  \\text{若对于所有 } (a,b) \\in \\mathcal{P},\\ (a,b)\\ne(i,j),\\ \\text{均有 } s_{ab} \\ge r \\, s_{ij} \\\\\n0,  \\text{否则},\n\\end{cases}\n$$\n\n其中 $r  1$ 是一个固定的分离因子。这强制要求 $(i,j)$ 是其扇区中唯一占主导地位的共线对：$s_{ij}$ 严格小于任何其他允许的 $s_{ab}$，且至少小一个因子 $r$。这意味着当 $s_{ij} \\to 0$ 时，所有其他潜在的共线不变量不会以相同的速率趋于零，从而防止了重叠的奇异极限，例如三重共线构型，在此类构型中 $s_{ik}$ 或 $s_{jk}$ 也会变小。\n- 在朴素模型中，扇区的数量为\n\n$$\n\\#\\mathcal{P}_{\\mathrm{all}} = N(N-1),\n$$\n\n因为考虑的是有序对。在色关联循环邻接模型中，\n\n$$\n\\#\\mathcal{P}_{\\mathrm{cc}} = 2N,\n$$\n\n因为 $N$ 个部分子中的每一个都有两个邻居，且顺序是重要的。\n\n算法任务：\n- 实现一个程序，对于给定的 $N$，构建一组包含 $N$ 个无质量四动量 $\\{p_i\\}$ 的集合，其中恰好有一对近共线粒子，或者在边界情况测试中，有两对可比较的近共线粒子。对于近共线性，将 $\\theta_{ij}$ 实现为一个满足 $\\theta_{ij} \\ll 1$ 的小角度，而所有其他两两之间的夹角均为 $\\mathcal{O}(1)$ 弧度。您可以假定任意的能量单位，且无需强制动量守恒；只使用两两配对的不变量 $s_{ij}$。\n- 使用上述指示函数 $\\mathbb{I}_{ij}$ 和固定的分离因子 $r$，确定在 $\\mathcal{P}_{\\mathrm{all}}$ 和 $\\mathcal{P}_{\\mathrm{cc}}$ 这两种 $\\mathcal{P}$ 的选择下，活跃扇区的数量。\n- 对于每个测试用例，报告：\n  1. $N$，\n  2. $\\#\\mathcal{P}_{\\mathrm{all}} = N(N-1)$，\n  3. $\\#\\mathcal{P}_{\\mathrm{cc}} = 2N$，\n  4. 在 $\\mathcal{P}_{\\mathrm{all}}$ 模型下，为生成的事件所激活的扇区数量，\n  5. 在 $\\mathcal{P}_{\\mathrm{cc}}$ 模型下，为生成的事件所激活的扇区数量。\n\n测试套件和覆盖范围：\n- 使用以下参数值的测试套件来探究缩放行为和约束满足情况，确保混合了一般情况和边界条件：\n  1. $N = 4$，构建一对近共线粒子，其他粒子之间保持通用分离。\n  2. $N = 5$，构建两对可比较的近共线粒子，以测试边界条件，即因缺乏唯一主导对而不应有任何扇区被激活的情况。\n  3. $N = 6$，构建一对近共线粒子，其他粒子之间保持通用分离。\n  4. $N = 9$，构建一对近共线粒子，其他粒子之间保持通用分离。\n- 在所有测试中使用固定的分离因子 $r = 10$。最终输出中不需要物理单位，因为报告的量是纯粹的计数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个测试用例的结果，格式为逗号分隔的列表的列表，每个列表包含上述五个值，并用方括号括起来。例如，打印的结构必须是以下形式\n\n$$\n\\texttt{[[n\\_1,c\\_1,d\\_1,a\\_1,b\\_1],[n\\_2,c\\_2,d\\_2,a\\_2,b\\_2],[n\\_3,c\\_3,d\\_3,a\\_3,b\\_3],[n\\_4,c\\_4,d\\_4,a\\_4,b\\_4]]}.\n$$", "solution": "该问题是有效的。它在科学上基于微扰量子色动力学（QCD）的原理，特别涉及用于处理红外发散的 Frixione–Kunszt–Signer（FKS）减除方法。问题中的定义和算法任务是适定的、客观的，并且是可通过计算验证的。\n\n任务是为 FKS 扇区实现一个生成器，并针对两种不同的允许奇异对模型 $\\mathcal{P}_{\\mathrm{all}}$ 和 $\\mathcal{P}_{\\mathrm{cc}}$ 分析其性质。FKS 方法的核心是将实发射的相空间划分为多个扇区，每个扇区精确地隔离一个潜在的红外发散。这可以防止对奇异性的重复计数，并使其能够与相应的虚修正相抵消。该问题使用一个扇区指示函数 $\\mathbb{I}_{ij}$ 来形式化这种隔离，该函数强制实施了一个主导条件。\n\n我们的方法将是构建 $N$ 个无质量部分子的特定运动学构型，以探究此扇区定义的行为。解决方案包括三个主要部分：一个生成具有预定共线属性的部分子四动量的方法，一个计算所有相关配对不变量 $s_{ij}$ 的过程，以及一个根据给定的指示函数 $\\mathbb{I}_{ij}$ 计算活动扇区数量的算法。\n\n**1. 运动学构型的生成**\n\n我们考虑 $N$ 个无质量部分子，其四动量为 $\\{p_1, \\dots, p_N\\}$。对于一个无质量部分子，其四动量 $p_i$ 满足 $p_i^2 = 0$。能量为 $E_i = |\\vec{p}_i|$。为简单起见，且不失一般性，我们在此问题中将所有部分子的能量设置为单位1，即 $E_i = 1$。配对不变质量由公式给出：\n$$s_{ij} = 2 p_i \\cdot p_j = 2 E_i E_j (1 - \\cos\\theta_{ij})$$\n其中 $\\theta_{ij}$ 是三动量 $\\vec{p}_i$ 和 $\\vec{p}_j$ 之间的夹角。当 $E_i=1$ 时，这简化为 $s_{ij} = 2(1 - \\cos\\theta_{ij})$。这表明扇区定义仅依赖于部分子之间的相对角度。\n\n为了生成动量，我们可以将它们限制在一个平面内（例如 x-z 平面），并用单个角度 $\\phi_i$ 定义每个三动量的方向。那么 $\\vec{p}_i$ 和 $\\vec{p}_j$ 之间的夹角就是 $\\theta_{ij} = |\\phi_i - \\phi_j|$。我们使用一个很小的角度 $\\epsilon \\ll 1$ 来表示近共线性。测试用例需要两种类型的构型：\n\n- **单个近共线对：** 对于给定的 $N$，我们将部分子 1 和 2（使用基于 0 的索引 0 和 1）指定为近共线对。我们设定它们的方向角为 $\\phi_0 = 0$ 和 $\\phi_1 = \\epsilon$。其余的 $N-2$ 个部分子被设置为与这对粒子以及彼此之间都充分分离。一个稳健的选择是将其角度分布在区间 $[\\pi/2, 3\\pi/2]$ 内，例如：对于 $i=2, \\dots, N-1$，$\\phi_i = \\pi/2 + (i-2)\\frac{\\pi}{N-2}$。这确保了 $s_{01}$ 是唯一的小量。\n\n- **两个可比较的近共线对：** 对于 $N=5$，我们创建两对具有可比共线性的粒子对 $(0,1)$ 和 $(2,3)$。我们按如下方式设置它们的角度：$\\phi_0=0$，$\\phi_1=\\epsilon$，$\\phi_2=\\pi/2$，$\\phi_3=\\pi/2+\\epsilon$，以及 $\\phi_4=\\pi$。这种构造使得 $s_{01} = 2(1-\\cos\\epsilon) = s_{23}$，而所有其他不变量 $s_{ij}$ 都显著更大。\n\n**2. 扇区定义和计数算法**\n\n活动扇区的数量是满足指示函数 $\\mathbb{I}_{ij}(\\{p\\}; r) = 1$ 的配对 $(i,j) \\in \\mathcal{P}$ 的计数。条件是：\n$$s_{ab} \\ge r \\, s_{ij} \\ \\text{for all } (a,b) \\in \\mathcal{P},\\ (a,b)\\ne(i,j)$$\n其中 $r=10$ 是固定的分离因子。此检查必须对允许配对集合 $\\mathcal{P}$ 的两种定义执行：\n- $\\mathcal{P}_{\\mathrm{all}} = \\{(i,j) \\mid 0 \\le i,j  N, i \\ne j\\}$。这类有序对的总数为 $\\#\\mathcal{P}_{\\mathrm{all}} = N(N-1)$。\n- $\\mathcal{P}_{\\mathrm{cc}} = \\{(i, (i \\pm 1) \\pmod N) \\mid 0 \\le i  N\\}$。我们使用基于 0 的索引，其中部分子 $i$ 的邻居是 $(i-1) \\pmod N$ 和 $(i+1) \\pmod N$。这产生 $2N$ 个配对，因此 $\\#\\mathcal{P}_{\\mathrm{cc}} = 2N$。\n\n计算算法如下：\n1. 对于给定的 $N$ 和运动学构型，生成角度集合 $\\{\\phi_i\\}$。\n2. 计算所有配对不变量的对称 $N \\times N$ 矩阵 $S$，其中 $S_{ij} = s_{ij} = 2(1 - \\cos(\\phi_i - \\phi_j))$。\n3. 为 $\\mathcal{P}_{\\mathrm{all}}$ 和 $\\mathcal{P}_{\\mathrm{cc}}$ 生成配对列表。\n4. 对于每个集合 $\\mathcal{P}$，遍历其中的每一对 $(i,j)$。对于每一个这样的 $(i,j)$，检查条件 $S_{ab} \\ge r \\cdot S_{ij}$ 是否对所有其他配对 $(a,b) \\in \\mathcal{P}$ 都成立。\n5. 满足条件的配对 $(i,j)$ 的总数即为该 $\\mathcal{P}$ 的活动扇区数。\n\n**3. 预期结果分析**\n\n- 对于**单个近共线对**构型，我们有一个唯一的小不变量 $s_{01} = s_{10}$。任何其他不变量 $s_{ab}$ 都将比它大几个数量级。给定 $r=10$，对于配对 $(0,1)$，条件 $s_{ab} \\ge r s_{01}$ 将会满足。对称的配对 $(1,0)$ 也满足此条件。对于任何其他配对 $(k,l)$，其不变量 $s_{kl}$ 很大。尝试为 $(k,l)$ 建立一个扇区会失败，因为检查要求 $s_{01} \\ge r s_{kl}$，而这是不成立的。因此，恰好有两个扇区，即 $(0,1)$ 和 $(1,0)$，将被激活。这对 $\\mathcal{P}_{\\mathrm{all}}$ 和 $\\mathcal{P}_{\\mathrm{cc}}$ 都成立，因为我们的构造使共线对 $(0,1)$ 相邻，因此它也是 $\\mathcal{P}_{\\mathrm{cc}}$ 的一部分。\n\n- 对于**两个可比较的近共线对**构型，我们有两个最小不变量 $s_{01} = s_{23}$。当测试 $(0,1)$ 是否构成一个扇区时，条件 $s_{ab} \\ge r s_{01}$ 必须对所有其他配对 $(a,b) \\in \\mathcal{P}$ 成立。然而，配对 $(2,3)$ 属于 $\\mathcal{P}$（对两个模型都是），并且 $s_{23} = s_{01}$。该条件变为 $s_{01} \\ge 10 \\cdot s_{01}$，这是不成立的。因此，对应于 $(0,1)$ 的扇区不会被激活。通过对称性，对应于 $(2,3)$ 的扇区也不会被激活。没有其他具有更大不变量的配对可以形成活动扇区。因此，活动扇区的数量为零。这展示了 FKS 划分方案如何在共线极限不唯一时正确地避免激活扇区。\n\n程序将对每个测试用例执行这些步骤，并报告五个指定的量：$N$、$\\#\\mathcal{P}_{\\mathrm{all}}$、$\\#\\mathcal{P}_{\\mathrm{cc}}$、在 $\\mathcal{P}_{\\mathrm{all}}$ 模型下的活动扇区数，以及在 $\\mathcal{P}_{\\mathrm{cc}}$ 模型下的活动扇区数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the FKS sector analysis for the given test suite.\n    \"\"\"\n\n    # Test suite: (N, configuration_type)\n    # 'single': One near-collinear pair.\n    # 'double': Two comparable near-collinear pairs.\n    test_cases = [\n        (4, 'single'),\n        (5, 'double'),\n        (6, 'single'),\n        (9, 'single'),\n    ]\n\n    # Fixed separation factor as per the problem statement\n    r = 10.0\n    # Small angle for near-collinear configurations\n    epsilon = 1e-4\n\n    results = []\n    for n_partons, config_type in test_cases:\n        result = analyze_sectors(n_partons, config_type, r, epsilon)\n        results.append(result)\n\n    # Format the final output string exactly as required, without extra spaces\n    output_str = '[' + ','.join(f'[{\",\".join(map(str, sublist))}]' for sublist in results) + ']'\n    print(output_str)\n\ndef generate_momenta_angles(n, config_type, epsilon):\n    \"\"\"\n    Generates the directional angles for N partons based on the configuration type.\n    We assume all momenta are in the x-z plane, so each direction is a single angle.\n    Energies are all 1.\n    \"\"\"\n    angles = np.zeros(n)\n    if config_type == 'single':\n        # Partons 0 and 1 are near-collinear\n        angles[0] = 0.0\n        angles[1] = epsilon\n        # Spread the rest of the partons\n        if n > 2:\n            # Distribute from pi/2 to 3pi/2 to maximize separation\n            for i in range(2, n):\n                angles[i] = np.pi/2 + (i - 2) * np.pi / (n - 2)\n    elif config_type == 'double':\n        if n != 5:\n            raise ValueError(\"Double configuration is defined for N=5 only in this setup.\")\n        # Pairs (0,1) and (2,3) are comparably near-collinear\n        angles[0] = 0.0\n        angles[1] = epsilon\n        angles[2] = np.pi / 2.0\n        angles[3] = np.pi / 2.0 + epsilon\n        angles[4] = np.pi\n    \n    return angles\n\ndef calculate_s_matrix(angles):\n    \"\"\"\n    Calculates the NxN matrix of pairwise invariants s_ij.\n    s_ij = 2 * E_i * E_j * (1 - cos(theta_ij))\n    With E_i=1, s_ij = 2 * (1 - cos(phi_i - phi_j)).\n    \"\"\"\n    n = len(angles)\n    s_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i, n):\n            # Angle difference can be taken in a simple way\n            d_phi = angles[i] - angles[j]\n            s_val = 2.0 * (1.0 - np.cos(d_phi))\n            s_matrix[i, j] = s_val\n            s_matrix[j, i] = s_val\n    return s_matrix\n\ndef get_p_sets(n):\n    \"\"\"\n    Generates the sets of allowed pairs P_all and P_cc.\n    Uses 0-based indexing.\n    \"\"\"\n    p_all = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                p_all.append((i, j))\n\n    p_cc = []\n    for i in range(n):\n        p_cc.append((i, (i + 1) % n))\n        p_cc.append((i, (i - 1 + n) % n))\n        \n    return p_all, p_cc\n\ndef count_active_sectors(s_matrix, p_set, r):\n    \"\"\"\n    Counts the number of active sectors for a given set of pairs P.\n    \"\"\"\n    active_count = 0\n    for i, j in p_set:\n        s_ij = s_matrix[i, j]\n        is_active = True\n        # The condition must hold for all other pairs in the set\n        for a, b in p_set:\n            if (a, b) == (i, j):\n                continue\n            \n            s_ab = s_matrix[a, b]\n            if s_ab  r * s_ij:\n                is_active = False\n                break\n        \n        if is_active:\n            active_count += 1\n            \n    return active_count\n\ndef analyze_sectors(n, config_type, r, epsilon):\n    \"\"\"\n    Performs the full analysis for one test case.\n    \"\"\"\n    \n    # 1. Generate kinematic configuration (angles)\n    angles = generate_momenta_angles(n, config_type, epsilon)\n    \n    # 2. Calculate all pairwise invariants s_ij\n    s_matrix = calculate_s_matrix(angles)\n    \n    # 3. Define the sets of pairs P_all and P_cc\n    p_all, p_cc = get_p_sets(n)\n    \n    # 4. Reportable quantities: total number of pairs\n    num_p_all = n * (n - 1)\n    num_p_cc = 2 * n\n    \n    # 5. Count active sectors for each model\n    active_all = count_active_sectors(s_matrix, p_all, r)\n    active_cc = count_active_sectors(s_matrix, p_cc, r)\n    \n    # 6. Assemble the results list for this case\n    return [n, num_p_all, num_p_cc, active_all, active_cc]\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3538653"}]}