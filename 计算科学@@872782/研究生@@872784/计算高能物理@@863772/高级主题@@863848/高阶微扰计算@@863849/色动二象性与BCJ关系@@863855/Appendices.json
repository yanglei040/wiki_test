{"hands_on_practices": [{"introduction": "在应用颜色-运动学对偶性之前，我们必须首先将散射振幅用一种合适的语言——即对所有立方图的求和——来表示。这个练习提供了识别这些图形并理解支配它们代数约束（雅可比恒等式）范围的基础性实践。这是建立任何满足CK对偶性计算的第一步。[@problem_id:3508621]", "problem": "考虑一个非阿贝尔规范理论中的树级五点色序分振幅 $A_{5}(1,2,3,4,5)$。使用色剥离表示，其中相互作用完全是三次的，并且每个图的贡献是一个运动学分子乘以两个标量传播子的乘积。从 Yang-Mills 理论中的树级振幅可以表示为对所有三次图求和的基本分解出发，这些三次图带有运动学分子 $n_{g}$ 和由曼德尔施塔姆不变量构成的标量传播子。李代数结构常数 $f^{a b c}$ 满足雅可比恒等式 $f^{a b e} f^{e c d} + f^{b c e} f^{e a d} + f^{c a e} f^{e b d} = 0$，而色-运动学对偶要求运动学分子展现出相同的三元组约束。\n\n任务1. 将色序振幅 $A_{5}(1,2,3,4,5)$ 构建为其与固定循环序 $1,2,3,4,5$ 一致的五个平面三次图之和的三次表示。使用双粒子曼德尔施塔姆不变量 $s_{i\\,i+1} = (p_{i} + p_{i+1})^{2}$（其中下标以 $5$ 为模）和附加到每个平面三次图的运动学分子 $n_{i\\,i+1\\,|\\,j\\,j+1}$ 来写出你的表达式。\n\n任务2. 现在考虑带有标记为 $\\{1,2,3,4,5\\}$ 的外腿的全套三次树图，不施加平面性。使用三次树的第一性原理组合学，并结合每个内边定义了唯一的雅可比三元组图这一事实，确定：\n- 不同三次图的总数，以及\n- 在五点情况下，约束色-运动学对偶表示中运动学分子的不同雅可比三元组的总数。\n\n将你的最终答案表示为一个包含两个整数 $(N_{\\text{graphs}}, N_{\\text{Jacobi}})$ 的单行矩阵。不需要四舍五入，最终答案中也不报告单位。", "solution": "该问题要求完成两个与非阿贝尔规范理论中五点树级振幅结构相关的任务，这些任务在色-运动学对偶的框架内。\n\n首先，我们将给定的概念形式化。一个具有 $n$ 个外粒子（腿）的树级散射振幅可以分解为对所有具有 $n$ 个标记外腿的不同三次树图的求和。全振幅由下式给出\n$$ \\mathcal{A}_n = g^{n-2} \\sum_{g} \\frac{c_g n_g}{D_g} $$\n其中 $g$ 索引了三次图的集合，$g$ 是耦合常数，$c_g$ 是由李代数结构常数 $f^{abc}$ 构成的色因子，$n_g$ 是依赖于动量和极化的运动学分子，$D_g$ 是逆传播子（分母）的乘积。对于一个三次图，所有顶点的度都为 $3$。一个 $n$ 点三次图有 $n$ 个外腿，$n-2$ 个内顶点，以及 $n-3$ 条内边（传播子）。对于 $n=5$，有 $5-3=2$ 个内部传播子。\n\n色因子 $c_g$ 对任何通过特定结构变换相关的图三元组 $(i,j,k)$ 满足 $c_i+c_j+c_k=0$ 形式的雅可比恒等式。色-运动学对偶假设，可以找到运动学分子 $n_g$ 的一种表示，使得它们遵守相同的雅可比恒等式，即 $n_i+n_j+n_k=0$。\n\n一个色序分振幅，例如 $A_{5}(1,2,3,4,5)$，是通过仅对相对于指定外腿循环序是平面的三次图求和得到的。\n\n任务1. 构建色序振幅 $A_{5}(1,2,3,4,5)$ 的三次表示。\n\n对于一个具有固定外腿循环序 $(1,2,3,4,5)$ 的五点振幅，存在五个相应的平面三次图。每个图有 $5-3=2$ 个传播子。这些图的拓扑结构可以通过将外腿放在一个圆上，并用不交叉的内线连接顶点来可视化。对于 $n=5$，这五个平面图在腿的标记的循环置换下都是拓扑等价的。\n\n我们来描述其中一个图的拓扑结构。两个相邻的腿，比如 $1$ 和 $2$，在一个顶点相遇。另一对相邻的腿，$4$ 和 $5$，在第二个顶点相遇。来自这两个顶点的内线，与剩下的腿 $3$ 一起，在第三个顶点相遇。\n这个图的传播子与内线相关联。流过它们的动量是 $p_1+p_2$ 和 $p_4+p_5$。对应的分母是 $1/((p_1+p_2)^2 (p_4+p_5)^2)$。使用双粒子曼德尔施塔姆不变量记号 $s_{ij} = (p_i+p_j)^2$，分母的乘积是 $s_{12}s_{45}$。问题将这个图的分子记为 $n_{i\\,i+1\\,|\\,j\\,j+1}$。对于这个特定的图，我们有相邻对 $(1,2)$ 和 $(4,5)$，所以我们可以设 $i=1$ 和 $j=4$。因此分子是 $n_{12|45}$。\n\n对于序 $(1,2,3,4,5)$ 的五个平面图是通过循环置换标记 $1 \\to 2 \\to 3 \\to 4 \\to 5 \\to 1$ 得到的。\n这五个图及其贡献是：\n1.  腿 $(1,2)$ 和 $(4,5)$ 配对。传播子: $s_{12}, s_{45}$。贡献: $\\frac{n_{12|45}}{s_{12}s_{45}}$。\n2.  腿 $(2,3)$ 和 $(5,1)$ 配对。传播子: $s_{23}, s_{51}$。贡献: $\\frac{n_{23|51}}{s_{23}s_{51}}$。\n3.  腿 $(3,4)$ 和 $(1,2)$ 配对。传播子: $s_{34}, s_{12}$。贡献: $\\frac{n_{34|12}}{s_{34}s_{12}}$。\n4.  腿 $(4,5)$ 和 $(2,3)$ 配对。传播子: $s_{45}, s_{23}$。贡献: $\\frac{n_{45|23}}{s_{45}s_{23}}$。\n5.  腿 $(5,1)$ 和 $(3,4)$ 配对。传播子: $s_{51}, s_{34}$。贡献: $\\frac{n_{51|34}}{s_{51}s_{34}}$。\n\n将这些贡献相加，得到色序振幅：\n$$ A_{5}(1,2,3,4,5) = \\frac{n_{12|45}}{s_{12}s_{45}} + \\frac{n_{23|51}}{s_{23}s_{51}} + \\frac{n_{34|12}}{s_{34}s_{12}} + \\frac{n_{45|23}}{s_{45}s_{23}} + \\frac{n_{51|34}}{s_{51}s_{34}} $$\n这个表达式满足了第一个任务的要求。\n\n任务2. 确定五点情况下不同三次图的总数（$N_{\\text{graphs}}$）和不同雅可比三元组的总数（$N_{\\text{Jacobi}}$）。\n\n不同三次图的总数，$N_{\\text{graphs}}$：\n计算具有 $n$ 个标记外腿的不同三次树图的数量问题，等价于计算具有 $n$ 个标记叶子的无根二叉树的数量。这是组合学中的一个标准结果。此类树的数量由双阶乘 $(2n-5)!!$ 给出。\n对于 $n=5$ 个腿，不同三次图的总数是：\n$$ N_{\\text{graphs}} = (2 \\cdot 5 - 5)!! = 5!! = 5 \\cdot 3 \\cdot 1 = 15 $$\n这 $15$ 个图包括平面和非平面拓扑。一个图由其两个传播子指定，这对应于将5个腿划分为两对和一个单腿，例如 $(\\{i,j\\}, \\{k,l\\}, \\{m\\})$。这样做的组合方式数为 $\\frac{1}{2!}\\binom{5}{2}\\binom{3}{2} = 15$，证实了该公式。\n\n不同雅可比三元组的总数，$N_{\\text{Jacobi}}$：\n运动学分子的雅可比恒等式 $n_i+n_j+n_k=0$ 关联了一个图三元组。参与雅可比恒等式的图三元组 $(g_i, g_j, g_k)$ 的结构是由四个子树如何连接到一个中心的类四点顶点结构来定义的。该恒等式源于连接这四个子树的三种方式，对应于一个四点函数的 s、t 和 u 通道。\n因此，不同雅可比恒等式的数量，就是将 $n$ 个外腿划分为四个非空集合的方式数，这些集合代表了四个子树的叶子集。\n对于 $n=5$ 个腿，我们需要找到将标记集合 $\\{1,2,3,4,5\\}$ 划分为 $4$ 个非空子集的方式数。这种划分唯一可能的结构是有一个大小为 $2$ 的子集和三个大小为 $1$ 的子集。例如，这种类型的一个划分是 $\\{\\{1,2\\}, \\{3\\}, \\{4\\}, \\{5\\}\\}$。\n这类划分的数量由选择形成该对的两个腿的方式数决定。剩下的三个腿将自动形成单元素集合。从 $5$ 个腿中选择 $2$ 个的方式数由二项式系数 $\\binom{5}{2}$ 给出。\n$$ N_{\\text{Jacobi}} = \\binom{5}{2} = \\frac{5!}{2!(5-2)!} = \\frac{5 \\cdot 4}{2} = 10 $$\n这 $10$ 个划分中的每一个都定义了一个唯一的分子雅可比三元组。例如，划分 $\\{\\{1,2\\}, \\{3\\}, \\{4\\}, \\{5\\}\\}$ 对应于三个图的分子之间的关系，这三个图的传播子对分别为 $(s_{12},s_{34})$、$(s_{12},s_{35})$ 和 $(s_{12},s_{45})$，假设该关系是通过固定一个传播子通道来构造的。更准确地说，该关系关联了对应于配对 $((\\{1,2\\},\\{3\\}),(\\{4\\},\\{5\\}))$、$((\\{1,2\\},\\{4\\}),(\\{3\\},\\{5\\}))$ 和 $((\\{1,2\\},\\{5\\}),(\\{3\\},\\{4\\}))$ 的图的分子，其中记号表示了这四个组是如何配对的。\n因此，存在 $10$ 个不同的雅可比三元组来约束运动学分子。\n\n最终答案包含两个整数 $(N_{\\text{graphs}}, N_{\\text{Jacobi}})$。\n$N_{\\text{graphs}} = 15$\n$N_{\\text{Jacobi}} = 10$\n\n最终答案: $(15, 10)$。", "answer": "$$ \\boxed{ \\begin{pmatrix} 15 & 10 \\end{pmatrix} } $$", "id": "3508621"}, {"introduction": "颜色-运动学对偶性的一个强大推论是颜色排序振幅之间存在线性关系，即所谓的BCJ关系。这项实践将我们从抽象的图表示带到具体的在壳可观测量；您将通过使用著名的Parke-Taylor公式，亲手验证一个五点BCJ关系。这个计算直接展示了该对偶性的预测能力，并突显了其作为检验理论有效性的在壳工具的价值。[@problem_id:3508625]", "problem": "考虑树级纯杨-米尔斯理论，其中有五个不同的外部胶子，携带满足 $\\sum_{i=1}^{5} p_{i}=0$ 的无质量动量 $\\{p_{1},p_{2},p_{3},p_{4},p_{5}\\}$。在三次图表示中处理色剥离部分振幅 $A(1,2,3,4,5)$。在此表示中，振幅被写为对三次图 $i$ 的求和，其中包含色因子 $c_{i}$、运动学分子 $n_{i}$ 和传播子分母 $D_{i}$，使得\n$$\n\\mathcal{A}_{\\text{tree}}=\\sum_{i} \\frac{c_{i}\\,n_{i}}{D_{i}}.\n$$\n色因子 $c_{i}$ 满足反对称性和雅可比恒等式。色-运动学对偶性（CK对偶性）要求运动学分子 $n_{i}$ 遵守相同的反对称性和雅可比恒等式。分子的局域性意味着每个 $n_{i}$ 都是动量和极化矢量的多项式，并且除了 $D_{i}$ 中已有的极点外，不会在曼德尔施塔姆不变量中引入额外的极点。确保局域性同时保持CK对偶性的一种方法是，从线性化场强 $F_{i}^{\\mu\\nu}=p_{i}^{\\mu}\\,\\varepsilon_{i}^{\\nu}-p_{i}^{\\nu}\\,\\varepsilon_{i}^{\\mu}$ 和曼德尔施塔姆不变量 $s_{ij}=(p_{i}+p_{j})^{2}$ 构建分子，避免出现 $s_{ij}$ 的任何逆幂。\n\n在五点情况下，选择一个半阶梯主图，其有序外部腿沿链遵循 $1\\!-\\!2\\!-\\!3\\!-\\!4\\!-\\!5$ 的顺序，并将其分子记为 $n_{12|3|45}$。构造一个显式的局域拟设\n$$\nn_{12|3|45}= \\alpha\\, s_{12}\\, s_{45}\\, \\operatorname{tr}\\!\\big(F_{1} F_{2} F_{3} F_{4} F_{5}\\big),\n$$\n其中常数 $\\alpha$ 通过与物理振幅匹配来确定，并通过三次顶点的反对称性和内部边上的雅可比关系生成所有其他分子，以使完整的集合 $\\{n_{i}\\}$ 满足CK对偶性。假设螺旋度构型为 $(1^{-},2^{-},3^{+},4^{+},5^{+})$，并使用旋量螺旋度形式，其中包含 $\\langle i j\\rangle$ 和 $[i j]$ 尖括号，且 $s_{ij}=\\langle i j\\rangle [j i]$。\n\n从三次表示出发，解释该拟设的局域性如何防止非局域项的出现，以及施加在局域拟设上的CK对偶性如何导致色序振幅之间的线性关系，即基本伯恩-卡拉斯科-约翰逊（BCJ）关系。然后，使用给定螺旋度构型下色序振幅的最大螺旋度破坏（MHV）帕克-泰勒公式，\n$$\nA(\\sigma(1^{-},2^{-},3^{+},4^{+},5^{+}))= \\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle \\sigma(1)\\sigma(2)\\rangle\\,\\langle \\sigma(2)\\sigma(3)\\rangle\\,\\langle \\sigma(3)\\sigma(4)\\rangle\\,\\langle \\sigma(4)\\sigma(5)\\rangle\\,\\langle \\sigma(5)\\sigma(1)\\rangle},\n$$\n计算以下色序振幅的线性组合，\n$$\nL \\equiv s_{12}\\,A(2,1,3,4,5)+\\big(s_{12}+s_{13}\\big)\\,A(2,3,1,4,5)+\\big(s_{12}+s_{13}+s_{14}\\big)\\,A(2,3,4,1,5),\n$$\n并给出其精确值。最终答案必须是一个无单位的实数值或闭式解析表达式。如果需要任何近似，则四舍五入到四位有效数字；否则，给出精确值。", "solution": "树级杨-米尔斯振幅的三次图表示将贡献组织起来，使得每一项都有一个色因子 $c_{i}$、一个运动学分子 $n_{i}$ 和一个传播子乘积 $D_{i}$。色因子由规范群的结构常数 $f^{abc}$ 构成，并在交换顶点上的腿时满足反对称性，以及对于任何因单一边翻转而不同的三联图，满足雅可比恒等式 $c_{i}+c_{j}+c_{k}=0$。色-运动学对偶性要求运动学分子 $n_{i}$ 满足相同的代数性质：\n- 运动学反对称性：在交换连接到三次顶点的两条腿时，$n_{i}$ 变号。\n- 运动学雅可比：对于任何通过边翻转相关的三联图 $(i,j,k)$，$n_{i}+n_{j}+n_{k}=0$。\n\n在此背景下，局域性意味着分子 $n_{i}$ 不包含曼德尔施塔姆不变量 $s_{ij}$ 的逆幂；振幅中的所有极点都应源于传播子分母 $D_{i}$。在保持规范不变性的同时强制实现局域性的一个可靠方法是，从线性化场强 $F_{i}^{\\mu\\nu}=p_{i}^{\\mu}\\,\\varepsilon_{i}^{\\nu}-p_{i}^{\\nu}\\,\\varepsilon_{i}^{\\mu}$ 构建分子，这些场强在 $\\varepsilon_{i}^{\\mu}\\rightarrow \\varepsilon_{i}^{\\mu}+ \\beta\\, p_{i}^{\\mu}$ 变换下是明显规范不变的，并且是动量和极化矢量的局域多项式。\n\n在五点情况下，考虑外部腿沿链 $1\\!-\\!2\\!-\\!3\\!-\\!4\\!-\\!5$ 排列的半阶梯主图。其分子的一种局域且规范不变的拟设是\n$$\nn_{12|3|45}= \\alpha\\, s_{12}\\, s_{45}\\, \\operatorname{tr}\\!\\big(F_{1} F_{2} F_{3} F_{4} F_{5}\\big),\n$$\n其中迹是利用闵可夫斯基度规对相邻场强的指标进行缩并得到的，而 $\\alpha$ 是一个常数，通过将计算出的振幅与已知的色序振幅进行匹配来确定。该拟设：\n1. 是局域的，因为它只包含对 $p_{i}$ 和 $\\varepsilon_{i}$ 的多项式依赖，而不含曼德尔施塔姆不变量的逆。\n2. 是规范不变的，因为 $F_{i}$ 是规范不变的，并且它们的乘积的迹也是规范不变的。\n3. 可以通过顶点反对称性生成其余分子，并通过在内部边翻转上施加雅可比约束来满足反对称性和雅可比关系。$F_{i}$ 迹中隐含的循环性和对易子结构，加上动量守恒和比安基恒等式 $p_{i[\\mu}F_{i\\nu\\rho]}=0$，为调整接触项提供了足够的自由度，从而在不引入非局域性的情况下满足所有运动学雅可比恒等式。换句话说，接触项用于在等价的局域表示（即“BCJ规范”）之间转换，在这些表示中CK对偶性成立。\n\n一旦一组局域分子满足了运动学雅可比恒等式，在振幅层面上的一个推论是色序振幅之间存在一个线性关系，即基本伯恩-卡拉斯科-约翰逊（BCJ）关系。该关系可以通过用两种等价的方式（使用不同的色基）写出全振幅，并使用运动学雅可比恒等式将一组分子用另一组分子表示出来，其方式反映了色雅可比重排。当分子遵守对偶性时，不同色序之间的不匹配会相互抵消，从而得到一个线性恒等式，其运动学系数是附着于沿色链移动的腿的曼德尔施塔姆不变量之和。\n\n对于 $n=5$，将腿 $1$ 插入到 $(2,3,4,5)$ 中的不同位置，基本BCJ关系产生特定的线性组合\n$$\nL \\equiv s_{12}\\,A(2,1,3,4,5)+\\big(s_{12}+s_{13}\\big)\\,A(2,3,1,4,5)+\\big(s_{12}+s_{13}+s_{14}\\big)\\,A(2,3,4,1,5),\n$$\n当分子满足CK对偶性并且是局域的时，该组合必须为零。为了在最大螺旋度破坏构型 $(1^{-},2^{-},3^{+},4^{+},5^{+})$ 中显式地检验这一点，我们使用帕克-泰勒公式。对于任何排序 $\\sigma$，在腿1和2处具有负螺旋度的色序MHV振幅为\n$$\nA(\\sigma)= \\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle \\sigma(1)\\sigma(2)\\rangle\\,\\langle \\sigma(2)\\sigma(3)\\rangle\\,\\langle \\sigma(3)\\sigma(4)\\rangle\\,\\langle \\sigma(4)\\sigma(5)\\rangle\\,\\langle \\sigma(5)\\sigma(1)\\rangle}.\n$$\n因此，\n\\begin{align*}\nA(2,1,3,4,5)=\\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle 2 1\\rangle\\,\\langle 1 3\\rangle\\,\\langle 3 4\\rangle\\,\\langle 4 5\\rangle\\,\\langle 5 2\\rangle},\\\\\nA(2,3,1,4,5)=\\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle 2 3\\rangle\\,\\langle 3 1\\rangle\\,\\langle 1 4\\rangle\\,\\langle 4 5\\rangle\\,\\langle 5 2\\rangle},\\\\\nA(2,3,4,1,5)=\\mathrm{i}\\,\\frac{\\langle 1 2\\rangle^{4}}{\\langle 2 3\\rangle\\,\\langle 3 4\\rangle\\,\\langle 4 1\\rangle\\,\\langle 1 5\\rangle\\,\\langle 5 2\\rangle}.\n\\end{align*}\n通过将这些振幅乘以它们各自的运动学系数来构成 $L$。使用 $s_{ij}=\\langle i j\\rangle [j i]$ 和反对称性 $\\langle i j\\rangle=-\\langle j i\\rangle$ 来重写所有项，使它们共享公分母 $\\langle 2 3\\rangle\\,\\langle 3 4\\rangle\\,\\langle 4 5\\rangle\\,\\langle 5 2\\rangle$ 和一个因子 $\\mathrm{i}\\,\\langle 1 2\\rangle^{3}$，例如通过适当地乘以每个项的分子和分母。将 $L$ 通分后，分子变成了一个由旋量积的线性项乘以来自 $s_{ij}$ 的 $[j i]$ 因子构成的和。由于尖括号之间的舒outen恒等式（例如，\n$$\n\\langle a b\\rangle \\langle c d\\rangle + \\langle b c\\rangle \\langle a d\\rangle + \\langle c a\\rangle \\langle b d\\rangle = 0,\n$$\n）以及动量守恒恒等式（如 $\\sum_{k} |k]\\langle k|=0$），再加上有序链的重标记对称性，这些项会成对抵消。详细的代数运算反映了CK对偶性在被积函数层面所保证的抵消，并为 $L$ 产生一个恒为零的分子。因此，\n$$\nL=0.\n$$\n这个显式检验与从局域CK对偶分子的一般推导是一致的：对一组局域分子强制施行运动学雅可比恒等式，意味着色序振幅的基本BCJ组合为零。分子拟设的局域性至关重要；非局域项（曼德尔施塔姆不变量的逆）会破坏推导所需的极点结构的匹配，从而阻碍导致振幅层面BCJ关系的抵消。\n\n因此，对于五点MHV构型和任何局域CK对偶表示，上面定义的 $L$ 的值精确为零。", "answer": "$$\\boxed{0}$$", "id": "3508625"}, {"introduction": "CK对偶性方案的最终目标是*构造*满足该对偶性的运动学分子。这个高级练习介绍了一种实现此目标的现代计算技术：在有限域上进行积分核重建。通过将问题视为一个源自幺正割切和雅可比恒等式的线性方程组，这项实践提供了处理振幅研究前沿算法的亲身实践经验。[@problem_id:3508572]", "problem": "你需要为一个玩具$5$-点、$2$-圈三次图子集，实现一个完整的、基于有限域的运动学分子的多变量插值和线性约束重构，这些图受色-运动学（CK）对偶性和广义幺正性割集约束。你编写的程序必须在一个素数模下重构未知的多项式分子系数，并在独立的验证点上验证雅可比恒等式约束和割集自洽性。最终输出必须是单行文本，包含一个布尔值列表，每个布尔值表示相应测试用例是否成功。\n\n从以下基本概念和核心定义开始：\n\n- 色-运动学（CK）对偶性指出，对于色因子服从李代数雅可比恒等式的三次图，存在服从同构雅可比关系的运动学分子，具体而言，对于每一组色因子满足 $c_s + c_t + c_u = 0$ 的三元图组，其对应的运动学分子满足 $n_s + n_t + n_u = 0$。\n\n- Bern-Carrasco-Johansson (BCJ) 关系是 CK 对偶性在振幅层面上的推论，其中，与雅可比关系一致的运动学分子的重排会使物理振幅保持不变。\n\n- 广义幺正性割集通过匹配树图的乘积，从在壳条件重构被积函数。在能够分离出图拓扑结构的最大割集上，割集数据直接在特定的运动学点上约束该图的分子值。\n\n你的任务是在素数模 $p$ 的有限域上，重构一个雅可比三元组中两个图的两个独立分子多项式 $n_a(x)$ 和 $n_b(x)$，并利用 CK 对偶性，通过系数层面的恒等式 $c_c = -c_a - c_b$ 来消去第三个分子 $n_c(x)$。在这里，每个分子都被建模为运动学变量\n$$\nx = (s_{12}, s_{23}, s_{34}, \\ell_1, \\ell_2)\n$$\n的多项式，使用单项式基\n$$\nM(x) = \\big(1,\\, s_{12},\\, s_{23},\\, s_{34},\\, \\ell_1,\\, \\ell_2\\big).\n$$\n因此，每个分子被参数化为\n$$\nn_g(x) = \\sum_{j=1}^{6} c_{g,j}\\, M_j(x),\n$$\n对于 $g \\in \\{a,b,c\\}$，其系数向量 $c_a, c_b, c_c \\in \\mathbb{F}_p^6$ 是未知的。CK 对偶性强制要求\n$$\nc_c = -c_a - c_b \\quad \\text{在} \\quad \\mathbb{F}_p \\text{上}.\n$$\n广义幺正性提供在采样点 $x_i$ 上的割集数据 $y_{g,i}$，对于此处使用的玩具最大割集模型，这直接等于分子在模 $p$ 下的求值结果：\n$$\ny_{g,i} \\equiv n_g(x_i) \\pmod{p}.\n$$\n\n你必须实现一个有限域求解器，该求解器能够：\n- 从采样方程\n$$\nM(x_i)\\cdot c_a = y_{a,i}, \\quad M(x_i)\\cdot c_b = y_{b,i}, \\quad M(x_i)\\cdot c_c = y_{c,i},\n$$\n构建一个线性系统，并使用 CK 对偶性消去 $c_c$ 以得出约束条件\n$$\n-M(x_i)\\cdot c_a - M(x_i)\\cdot c_b = y_{c,i}.\n$$\n- 通过带有模算术的高斯消元法，求解得到的（可能是超定的）模 $p$ 线性系统，以获得 $c_a$ 和 $c_b$。\n- 通过 $c_c = -c_a - c_b$ 恢复 $c_c$ 并验证：\n    1. 在独立的验证点上，雅可比恒等式 $n_a(x) + n_b(x) + n_c(x) \\equiv 0 \\pmod{p}$ 成立。\n    2. 在额外的验证点上，对于 $g \\in \\{a,b,c\\}$，割集自洽性 $n_g(x) \\equiv y_{g}(x) \\pmod{p}$ 成立。\n\n所有算术运算必须在素数模 $p$ 的有限域 $\\mathbb{F}_p$ 中完成。你必须实现模逆运算和模行化简。不要使用浮点运算；所有量都必须是模 $p$ 简化的整数。\n\n单位说明：不涉及物理单位；所有量都是模一个素数的纯整数。不使用角度。\n\n测试套件和最终输出规范：\n- 对所有图和所有测试用例，使用以下单项式基 $M(x) = \\big(1,\\, s_{12},\\, s_{23},\\, s_{34},\\, \\ell_1,\\, \\ell_2\\big)$。\n- 对于每个测试用例，都提供一个固定的素数 $p$、一组采样点和一组验证点。在每个点 $x=(s_{12},s_{23},s_{34},\\ell_1,\\ell_2)$，应用上述方程。割集数据 $y_{g,i}$ 由程序内部的一个隐藏的“神谕”分子（oracle numerator）综合生成，该分子在所有测试用例中都是固定的（程序将确定性地定义和使用它，以使结果可复现）。\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个结果是一个布尔值，表示对于该测试用例，重构的系数是否在所提供的验证点上通过了雅可比恒等式和割集自洽性两项验证。\n\n需要实现的测试用例：\n- 测试用例 1 (理想路径):\n    - 素数模: $p=101$。\n    - 用于重构的采样点（6个点，一个超定系统）：\n        1. $(s_{12},s_{23},s_{34},\\ell_1,\\ell_2)=(1,0,0,0,0)$,\n        2. $(0,1,0,0,0)$,\n        3. $(0,0,1,0,0)$,\n        4. $(0,0,0,1,0)$,\n        5. $(0,0,0,0,1)$,\n        6. $(2,2,2,2,2)$。\n    - 验证点（3个点）：\n        1. $(3,1,4,1,5)$,\n        2. $(9,2,6,5,3)$,\n        3. $(10,20,30,40,50)$。\n- 测试用例 2 (超定系统和鲁棒性)：\n    - 素数模: $p=97$。\n    - 用于重构的采样点（8个点，超定系统）：\n        1. $(1,0,0,0,0)$,\n        2. $(0,1,0,0,0)$,\n        3. $(0,0,1,0,0)$,\n        4. $(0,0,0,1,0)$,\n        5. $(0,0,0,0,1)$,\n        6. $(2,2,2,2,2)$,\n        7. $(4,5,6,7,8)$,\n        8. $(10,9,8,7,6)$。\n    - 验证点（3个点）：\n        1. $(3,5,7,11,13)$,\n        2. $(6,5,4,3,2)$,\n        3. $(8,13,21,34,55)$。\n- 测试用例 3 (包含零的边界值)：\n    - 素数模: $p=89$。\n    - 用于重构的采样点（6个点）：\n        1. $(0,0,0,0,0)$,\n        2. $(1,0,0,0,0)$,\n        3. $(0,1,0,0,0)$,\n        4. $(0,0,1,0,0)$,\n        5. $(0,0,0,1,0)$,\n        6. $(0,0,0,0,1)$。\n    - 验证点（3个点）：\n        1. $(2,3,5,7,11)$,\n        2. $(13,17,19,23,29)$,\n        3. $(1,1,1,1,1)$。\n\n你的程序必须：\n- 构建在 $\\mathbb{F}_p$ 上的增广线性系统，该系统包含图 $a$ 和 $b$ 的方程以及图 $c$ 的 CK 简化方程。\n- 通过有限域高斯消元法并使用行全主元求解 $c_a$ 和 $c_b$（列前向选择即足够）。\n- 使用 CK 对偶性恢复 $c_c$。\n- 在验证点上验证 CK 雅可比恒等式和割集自洽性。\n- 打印形如“[bool1,bool2,bool3]”的单行文本。\n\n不允许外部输入、文件或网络访问。代码必须是完全自包含和确定性的。", "solution": "所提出的问题是理论高能物理学中一个定义明确的计算任务。它要求重构一组费曼图的运动学分子多项式，这些多项式受到色-运动学（CK）对偶性的约束。重构需要在有限域 $\\mathbb{F}_p$ 上进行，使用广义幺正性割集提供的一组采样数据点。然后在一组独立的验证点上测试重构的有效性。该问题具有科学依据，数学上一致，并且计算上可行。因此，该问题被认为是有效的。\n\n解决方案分为四个主要阶段：\n1.  **系统构建**：我们将物理约束转化为有限域 $\\mathbb{F}_p$ 上的线性方程组。\n2.  **数据生成**：我们按要求定义一个“神谕”（oracle），用于综合生成用于重构和验证的割集数据。\n3.  **系统求解**：我们使用带模算术的高斯-若尔当消元法实现一个该线性系统的求解器。\n4.  **重构与验证**：我们使用求解得到的解来重构分子多项式，并根据所需的物理自洽性条件对其进行验证。\n\n### 1. 理论阐述与线性系统构建\n\n问题指定了两个独立的分子 $n_a(x)$ 和 $n_b(x)$，以及第三个分子 $n_c(x)$，它通过雅可比恒等式 $n_a(x) + n_b(x) + n_c(x) = 0$ 依赖于前两者。运动学变量由向量 $x = (s_{12}, s_{23}, s_{34}, \\ell_1, \\ell_2)$ 给出。每个分子被参数化为来自基 $M(x) = (1, s_{12}, s_{23}, s_{34}, \\ell_1, \\ell_2)$ 的单项式的线性组合。\n一个图 $g \\in \\{a,b,c\\}$ 的分子 $n_g(x)$ 写为：\n$$n_g(x) = \\sum_{j=1}^{6} c_{g,j} M_j(x) = M(x) \\cdot c_g$$\n其中 $c_g = (c_{g,1}, \\dots, c_{g,6})^T$ 是在 $\\mathbb{F}_p$ 中的未知系数向量。雅可比恒等式 $n_a+n_b+n_c=0$ 意味着对系数的约束：\n$$M(x) \\cdot c_a + M(x) \\cdot c_b + M(x) \\cdot c_c = 0$$\n由于这对所有 $x$ 都必须成立，且 $M(x)$ 中的单项式是线性无关的，这要求一个系数层面的恒等式：\n$$c_a + c_b + c_c = 0 \\quad \\implies \\quad c_c = -c_a - c_b \\pmod p$$\n需要求解的未知系数是 $c_a$ 的 $6$ 个分量和 $c_b$ 的 $6$ 个分量，总共有 $12$ 个未知数。我们将 $c_a$ 和 $c_b$ 串联起来，定义一个单一的未知数向量 $C \\in \\mathbb{F}_p^{12}$：\n$$C = (c_{a,1}, \\dots, c_{a,6}, c_{b,1}, \\dots, c_{b,6})^T$$\n广义幺正性割集为一组运动学点 $x_i$ 提供了样本数据 $(x_i, y_{a,i}, y_{b,i}, y_{c,i})$，其中 $y_{g,i} \\equiv n_g(x_i) \\pmod p$。这些关系提供了一个线性方程组。对于每个采样点 $x_i$：\n1.  $M(x_i) \\cdot c_a = y_{a,i}$\n2.  $M(x_i) \\cdot c_b = y_{b,i}$\n3.  $M(x_i) \\cdot c_c = y_{c,i}$\n\n将 $c_c = -c_a - c_b$ 代入第三个方程得到：\n$$-M(x_i) \\cdot c_a - M(x_i) \\cdot c_b = y_{c,i}$$\n对于每个采样点 $i$，我们得到一组关于组合未知向量 $C$ 的联立方程。设 $M_i$ 为在 $x_i$ 处求值的单项式基的 $1 \\times 6$ 行向量。这些方程可以写成矩阵形式。对于单个点 $x_i$，我们有：\n$$\n\\begin{pmatrix}\nM_i & \\mathbf{0}_{1 \\times 6} \\\\\n\\mathbf{0}_{1 \\times 6} & M_i \\\\\n-M_i & -M_i\n\\end{pmatrix}\n\\begin{pmatrix} c_a \\\\ c_b \\end{pmatrix}\n=\n\\begin{pmatrix} y_{a,i} \\\\ y_{b,i} \\\\ y_{c,i} \\end{pmatrix}\n$$\n将所有 $k$ 个采样点的这些方程堆叠起来，就得到一个大型线性系统 $A_{sys} \\cdot C = Y_{sys}$，其中 $A_{sys}$ 是一个 $(3k) \\times 12$ 矩阵，$Y_{sys}$ 是一个 $(3k) \\times 1$ 向量。\n\n### 2. “神谕”数据生成\n\n问题指出，割集数据 $y_{g,i}$ 必须由一个固定的、隐藏的“神谕”生成。我们通过选择固定的整系数向量来定义这些“神谕”分子。我们选择：\n-   $c_a^{\\text{true}} = (3, 5, -2, 1, 8, 4)$\n-   $c_b^{\\text{true}} = (7, -1, 0, 6, -3, 2)$\n\n第三个系数向量由雅可比恒等式确定：\n-   $c_c^{\\text{true}} = -c_a^{\\text{true}} - c_b^{\\text{true}} = (-10, -4, 2, -7, -5, -6)$\n\n对于任何给定的运动学点 $x_i$ 和素数 $p$，割集数据生成为 $y_{g,i} = (M(x_i) \\cdot c_g^{\\text{true}}) \\pmod p$。这确保了提供的输入数据与底层的 CK 对偶结构内部一致。\n\n### 3. 有限域线性系统求解器\n\n为了求解模素数 $p$ 的 $A_{sys} \\cdot C = Y_{sys}$，我们实现高斯-若尔当消元法。该算法将增广矩阵 $[A_{sys} | Y_{sys}]$ 转换为其行简化阶梯形（RREF），从中可以直接提取解。所有算术运算（加、减、乘、除）都在模 $p$ 下执行。除以一个元素 $d$ 被替换为乘以其模乘法逆元 $d^{-1} \\pmod p$。由于 $p$ 是素数，费马小定理保证对于任何 $d \\not\\equiv 0 \\pmod p$ 都有 $d^{-1} \\equiv d^{p-2} \\pmod p$。\n\n该算法逐列进行，使用行主元选择（交换行以将非零元素置于主元位置）来确保使用非零主元进行消元。将系统转换为 RREF 后：\n-   对于唯一确定系统（独立方程数等于变量数），增广矩阵的左侧部分变为 $12 \\times 12$ 的单位矩阵，右侧部分包含 $C$ 的唯一解。\n-   对于相容的超定系统（独立方程数多于变量数），RREF 将在系数矩阵部分的底部出现零行。相容性要求增广部分的相应项也为零。唯一解从非零行中读出。\n-   不相容系统将产生形如 $(0, \\dots, 0 | d)$ 且 $d \\not\\equiv 0 \\pmod p$ 的行，表示无解。\n\n### 4. 重构与验证\n\n一旦求解器返回系数向量 $C$，我们就提取出重构的系数 $c_a^{\\text{recon}}$、$c_b^{\\text{recon}}$。然后我们计算 $c_c^{\\text{recon}} = -c_a^{\\text{recon}} - c_b^{\\text{recon}} \\pmod p$。这三个向量定义了重构的分子多项式 $n_g^{\\text{recon}}(x)$。\n\n验证在一组独立的点 $x_v$ 上进行。对于每个验证点，我们执行两个检查：\n1.  **割集自洽性**：我们计算重构分子的值 $n_g^{\\text{recon}}(x_v)$，并将其与“神谕”值 $y_g(x_v) = (M(x_v) \\cdot c_g^{\\text{true}}) \\pmod p$ 进行比较。仅当对于所有 $g \\in \\{a,b,c\\}$ 和所有验证点，$n_g^{\\text{recon}}(x_v) \\equiv y_g(x_v) \\pmod p$ 时，重构才有效。\n2.  **雅可比恒等式**：我们验证重构分子的和模 $p$ 为零：$(n_a^{\\text{recon}}(x_v) + n_b^{\\text{recon}}(x_v) + n_c^{\\text{recon}}(x_v)) \\equiv 0 \\pmod p$。通过我们对 $c_c^{\\text{recon}}$ 的构造，该代数恒等式保证对多项式本身成立，因此在任何求值点上都成立。这个检查可以验证重构过程的内部逻辑。\n\n当且仅当所有验证点都通过这两项检查时，一个测试用例才被认为是成功的（结果为 `True`）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases for numerator reconstruction and validation.\n    \"\"\"\n\n    # Oracle Definition: Hidden, true coefficient vectors for the numerators.\n    # These are fixed for all test cases to ensure reproducibility.\n    TRUE_CA = np.array([3, 5, -2, 1, 8, 4], dtype=np.int64)\n    TRUE_CB = np.array([7, -1, 0, 6, -3, 2], dtype=np.int64)\n    TRUE_CC = -(TRUE_CA + TRUE_CB)\n\n    def monomial_basis_eval(x_point):\n        \"\"\"Evaluates the monomial basis M(x) at a given point x.\"\"\"\n        s12, s23, s34, l1, l2 = x_point\n        return np.array([1, s12, s23, s34, l1, l2], dtype=np.int64)\n\n    def evaluate_numerator(coeffs, x_point, p):\n        \"\"\"Evaluates a numerator polynomial n(x) = M(x) . c at a point x mod p.\"\"\"\n        m_vec = monomial_basis_eval(x_point)\n        # Use Python's arbitrary-precision integers for dot product before modulo\n        val = np.dot(m_vec, coeffs)\n        return int(val % p)\n\n    def generate_cut_data(x_point, p):\n        \"\"\"Generates oracle cut data (y_a, y_b, y_c) for a given point x and prime p.\"\"\"\n        y_a = evaluate_numerator(TRUE_CA, x_point, p)\n        y_b = evaluate_numerator(TRUE_CB, x_point, p)\n        y_c = evaluate_numerator(TRUE_CC, x_point, p)\n        return y_a, y_b, y_c\n\n    def mod_inv(n, p):\n        \"\"\"Computes the modular multiplicative inverse of n modulo p using Fermat's Little Theorem.\"\"\"\n        return pow(n, p - 2, p)\n\n    def solve_modular_linear_system(A, b, p):\n        \"\"\"\n        Solves the linear system Ax = b over the finite field F_p using Gauss-Jordan elimination.\n        A is an m x n matrix, b is an m-element vector.\n        Returns the solution vector x if a unique solution exists, otherwise None.\n        \"\"\"\n        m, n = A.shape\n        # Use python lists of lists of standard ints for safe modular arithmetic\n        aug = [list(map(int, A[i])) + [int(b[i])] for i in range(m)]\n\n        pivot_row = 0\n        for j in range(n):  # Iterate through columns (variables)\n            if pivot_row == m:\n                break\n\n            # Find a row with a non-zero pivot in the current column\n            i = pivot_row\n            while i  m and aug[i][j] == 0:\n                i += 1\n\n            if i  m:  # Pivot found\n                aug[pivot_row], aug[i] = aug[i], aug[pivot_row]  # Swap rows\n\n                # Normalize the pivot row\n                pivot_val = aug[pivot_row][j]\n                inv_pivot = mod_inv(pivot_val, p)\n                for k in range(j, n + 1):\n                    aug[pivot_row][k] = (aug[pivot_row][k] * inv_pivot) % p\n\n                # Eliminate other entries in the current column\n                for i in range(m):\n                    if i != pivot_row:\n                        factor = aug[i][j]\n                        if factor == 0: continue\n                        for k in range(j, n + 1):\n                            aug[i][k] = (aug[i][k] - factor * aug[pivot_row][k]) % p\n                \n                pivot_row += 1\n        \n        # Check for inconsistencies in overdetermined systems\n        for i in range(pivot_row, m):\n            if aug[i][n] != 0:\n                return None  # No solution\n\n        # Check for unique solution (RREF should be [I_n; 0 | solution; 0])\n        if pivot_row  n:\n            return None # Not a unique solution\n        \n        solution = np.zeros(n, dtype=np.int64)\n        for i in range(n):\n            solution[i] = aug[i][n]\n            \n        return solution\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"p\": 101,\n            \"samples\": [(1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1), (2,2,2,2,2)],\n            \"validations\": [(3,1,4,1,5), (9,2,6,5,3), (10,20,30,40,50)],\n        },\n        {\n            \"p\": 97,\n            \"samples\": [(1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1), (2,2,2,2,2), (4,5,6,7,8), (10,9,8,7,6)],\n            \"validations\": [(3,5,7,11,13), (6,5,4,3,2), (8,13,21,34,55)],\n        },\n        {\n            \"p\": 89,\n            \"samples\": [(0,0,0,0,0), (1,0,0,0,0), (0,1,0,0,0), (0,0,1,0,0), (0,0,0,1,0), (0,0,0,0,1)],\n            \"validations\": [(2,3,5,7,11), (13,17,19,23,29), (1,1,1,1,1)],\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = case[\"p\"]\n        sample_points = case[\"samples\"]\n        validation_points = case[\"validations\"]\n        \n        num_samples = len(sample_points)\n        num_unknowns = 12\n        \n        A_sys = np.zeros((3 * num_samples, num_unknowns), dtype=np.int64)\n        Y_sys = np.zeros(3 * num_samples, dtype=np.int64)\n\n        for i, point in enumerate(sample_points):\n            m_vec = monomial_basis_eval(point)\n            y_a, y_b, y_c = generate_cut_data(point, p)\n\n            # Equation for n_a: M(x_i) . c_a = y_a_i\n            A_sys[3*i, 0:6] = m_vec\n            Y_sys[3*i] = y_a\n\n            # Equation for n_b: M(x_i) . c_b = y_b_i\n            A_sys[3*i+1, 6:12] = m_vec\n            Y_sys[3*i+1] = y_b\n            \n            # Equation for n_c via CK: -M(x_i).c_a - M(x_i).c_b = y_c_i\n            A_sys[3*i+2, 0:6] = -m_vec\n            A_sys[3*i+2, 6:12] = -m_vec\n            Y_sys[3*i+2] = y_c\n            \n        C_recon = solve_modular_linear_system(A_sys, Y_sys, p)\n\n        if C_recon is None:\n            results.append(False)\n            continue\n            \n        c_a_recon = C_recon[0:6]\n        c_b_recon = C_recon[6:12]\n        c_c_recon = (-(c_a_recon + c_b_recon)) % p\n\n        case_is_valid = True\n        for point in validation_points:\n            # Oracle values at validation point\n            y_a_val, y_b_val, y_c_val = generate_cut_data(point, p)\n            \n            # Reconstructed numerator values at validation point\n            n_a_recon = evaluate_numerator(c_a_recon, point, p)\n            n_b_recon = evaluate_numerator(c_b_recon, point, p)\n            n_c_recon = evaluate_numerator(c_c_recon, point, p)\n            \n            # 1. Cut consistency check\n            if not (n_a_recon == y_a_val and n_b_recon == y_b_val and n_c_recon == y_c_val):\n                case_is_valid = False\n                break\n                \n            # 2. Jacobi identity check\n            if (n_a_recon + n_b_recon + n_c_recon) % p != 0:\n                case_is_valid = False\n                break\n        \n        if not case_is_valid:\n            results.append(False)\n            continue\n\n        results.append(True)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results)).replace('True', 'True').replace('False', 'False')}]\")\n\nsolve()\n```", "id": "3508572"}]}