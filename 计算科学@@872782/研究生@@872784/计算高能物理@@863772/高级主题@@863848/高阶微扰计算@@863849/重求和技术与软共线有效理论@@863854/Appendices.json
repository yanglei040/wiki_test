{"hands_on_practices": [{"introduction": "在软-共线有效理论（SCET）的框架下，对撞机可观测量的大对数重求和是通过求解硬函数、喷注函数和软函数的重整化群方程（RGEs）来实现的。这项基础实践将指导您完成为推力（thrust）可观测量在次领头对数（NLL）精度下进行重求和的完整计算过程 [@problem_id:3531711]。通过这个练习，您将掌握如何将抽象的因子化定理转化为具体的数值预测，这是高能物理唯象学中的一项核心技能。", "problem": "考虑电子-正电子湮灭为强子的双喷注极限，其特征由推力变量 $\\tau = 1 - T$ 描述，其中 $T$ 是推力。在软-共线有效理论 (SCET) 框架下，小-$\\tau$ 极限下的推力微分分布可因子化为一个硬函数 $H(Q,\\mu)$、两个相同的喷注函数 $J(p^2,\\mu)$ 和一个软函数 $S(k,\\mu)$，其中 $Q$ 是质心能量。在次领头对数精度 (NLL) 下，使用反常维度的单圈表达式，控制这些函数标度依赖性的重整化群 (RG) 方程具有以下通用形式\n$$\n\\mu \\frac{d}{d\\mu} \\ln F = \\gamma_F(\\mu),\n$$\n其中 $F \\in \\{H,J,S\\}$，$\\gamma_F(\\mu)$ 是由尖点部分和非尖点部分组成的反常维度。假设有以下单圈输入：\n- 夸克尖点反常维度为 $\\Gamma_{\\text{cusp}}(\\alpha_s) = \\Gamma_0 \\frac{\\alpha_s}{4\\pi}$，其中 $\\Gamma_0 = 4 C_F$。\n- 单圈非尖点反常维度满足 RG 一致性 $\\gamma_H^0 + 2 \\gamma_J^0 + \\gamma_S^0 = 0$，并取值为 $\\gamma_H^0 = -12 C_F$, $\\gamma_J^0 = 6 C_F$, $\\gamma_S^0 = 0$。\n- 强耦合的单圈量子色动力学 (QCD) $\\beta$-函数为 $\\beta(\\alpha_s) = \\mu \\frac{d\\alpha_s}{d\\mu} = - \\beta_0 \\frac{\\alpha_s^2}{2\\pi}$，其中 $\\beta_0 = \\frac{11 C_A}{3} - \\frac{4 T_F n_f}{3}$。使用 $C_F = \\frac{4}{3}$，$C_A = 3$，$T_F = \\frac{1}{2}$ 和 $n_f = 5$，以及边界条件 $\\alpha_s(M_Z) = 0.118$（在 $M_Z = 91.1876\\,\\text{GeV}$ 处）。\n\n对于双喷注极限下的推力 $\\tau$，取喷注函数和软函数的特征变量分别为 $p^2 \\sim Q^2 \\tau$ 和 $k \\sim Q \\tau$。使用喷注函数和软函数的单圈表达式，并选择典则标度以最小化大对数，\n$$\n\\mu_H = Q, \\quad \\mu_J = Q \\sqrt{\\tau}, \\quad \\mu_S = Q \\tau,\n$$\n建立并求解 RG 方程，将 $H$、$J$ 和 $S$ 从其典则标度演化至公共标度 $\\mu = Q$。将典则标度处的单圈匹配值视为 1，即 $H(Q,\\mu_H)=1$、$J(Q^2 \\tau,\\mu_J)=1$ 和 $S(Q \\tau,\\mu_S)=1$，从而使重求和内容完全通过 RG 演化核进入。为避免非物理的朗道极点行为，施加一个低标度截断 $\\mu_{\\text{min}} = 1\\,\\text{GeV}$，并通过在所有对数和跑动耦合计算中将任何小于 $\\mu_{\\text{min}}$ 的 $\\mu$ 替换为 $\\mu_{\\text{min}}$，来冻结 $\\alpha_s(\\mu)$ 的跑动和典则标度。\n\n使用以下微分形式的显式单圈反常维度进行向 $\\mu = Q$ 的演化：\n- 硬函数：\n$$\n\\mu \\frac{d}{d\\mu} \\ln H = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ 4 \\Gamma_0 \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\gamma_H^0 \\right].\n$$\n- 喷注函数（单个喷注）：\n$$\n\\mu \\frac{d}{d\\mu} \\ln J = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ -2 \\Gamma_0 \\left( 2 \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_J^0 \\right].\n$$\n- 软函数：\n$$\n\\mu \\frac{d}{d\\mu} \\ln S = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ 4 \\Gamma_0 \\left( \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_S^0 \\right].\n$$\n\n将 NLL 重求和的推力分布定义为在公共标度 $\\mu=Q$ 处求值的演化函数的乘积，\n$$\n\\left(\\frac{1}{\\sigma_0}\\frac{d\\sigma}{d\\tau}\\right)_{\\text{NLL}}(\\tau;Q) \\equiv H(Q,\\mu=Q) \\left[J(Q^2 \\tau,\\mu=Q)\\right]^2 S(Q \\tau,\\mu=Q),\n$$\n该分布是无量纲的。使用单圈跑动耦合\n$$\n\\alpha_s(\\mu) = \\frac{\\alpha_s(\\mu_0)}{1 + \\frac{\\alpha_s(\\mu_0)\\beta_0}{2\\pi} \\ln\\!\\left(\\frac{\\mu}{\\mu_0}\\right)},\n$$\n从典则起始标度 $(\\mu_H,\\mu_J,\\mu_S)$ 到 $Q$ 对 RG 方程关于 $\\ln\\mu$ 进行数值积分，其中以 $\\mu_0 = M_Z$ 为参考标度。\n\n您的程序必须计算以下 $(Q,\\tau)$ 对测试套件的重求和值：\n- $Q = 91.1876\\,\\text{GeV}$，其中 $\\tau \\in \\{0.001, 0.010, 0.050, 0.100, 0.250\\}$，\n- $Q = 500\\,\\text{GeV}$，其中 $\\tau \\in \\{0.010, 0.100\\}$。\n\n所有输出均为无量纲浮点数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots]$），结果的顺序与上述参数集的顺序相同。对任何隐含的角度量请使用弧度，尽管此处没有直接要求。通过按规定实现 $\\mu_{\\text{min}}$ 冻结来确保数值稳定性。最终输出应为 Python 生成的完全精度的浮点数，无需四舍五入。", "solution": "The user has provided a problem in computational high-energy physics that requires the calculation of the next-to-leading logarithmic (NLL) resummed thrust distribution in electron-positron annihilation, formulated within the Soft-Collinear Effective Theory (SCET).\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n- **Observable**: Thrust distribution in the dijet limit, $\\tau = 1-T \\ll 1$.\n- **Framework**: Soft-Collinear Effective Theory (SCET).\n- **Factorization**: $\\frac{d\\sigma}{d\\tau} \\propto H(Q,\\mu) J(p^2,\\mu)^2 S(k,\\mu)$.\n- **RG Equations**: $\\mu \\frac{d}{d\\mu} \\ln F = \\gamma_F(\\mu)$ for $F \\in \\{H,J,S\\}$.\n- **Anomalous Dimensions (One-Loop)**:\n  - Cusp: $\\Gamma_{\\text{cusp}}(\\alpha_s) = \\Gamma_0 \\frac{\\alpha_s}{4\\pi}$ with $\\Gamma_0 = 4 C_F$.\n  - Non-cusp: $\\gamma_H^0 = -12 C_F$, $\\gamma_J^0 = 6 C_F$, $\\gamma_S^0 = 0$.\n  - RG Consistency: $\\gamma_H^0 + 2 \\gamma_J^0 + \\gamma_S^0 = 0$.\n- **QCD Parameters**:\n  - Color factors for SU(3): $C_F = 4/3$, $C_A = 3$, $T_F = 1/2$.\n  - Number of active flavors: $n_f = 5$.\n  - QCD $\\beta$-function: $\\beta(\\alpha_s) = - \\beta_0 \\frac{\\alpha_s^2}{2\\pi}$ with $\\beta_0 = \\frac{11 C_A}{3} - \\frac{4 T_F n_f}{3}$.\n  - Strong coupling: $\\alpha_s(M_Z) = 0.118$ at $M_Z = 91.1876\\,\\text{GeV}$.\n- **SCET Scales**:\n  - Characteristic scales: $p^2 \\sim Q^2 \\tau$, $k \\sim Q \\tau$.\n  - Canonical scales: $\\mu_H = Q$, $\\mu_J = Q \\sqrt{\\tau}$, $\\mu_S = Q \\tau$.\n- **Evolution and Boundary Conditions**:\n  - Initial values: $H(Q,\\mu_H)=1$, $J(Q^2\\tau,\\mu_J)=1$, $S(Q\\tau,\\mu_S)=1$.\n  - Evolution target scale: $\\mu = Q$.\n- **Infrared Cutoff**: $\\mu_{\\text{min}} = 1\\,\\text{GeV}$. Any scale $\\mu  \\mu_{\\text{min}}$ is replaced by $\\mu_{\\text{min}}$ for evaluating $\\alpha_s$ and defining canonical scales.\n- **Explicit Anomalous Dimensions for Evolution**:\n  - $\\mu \\frac{d}{d\\mu} \\ln H = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ 4 \\Gamma_0 \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\gamma_H^0 \\right]$.\n  - $\\mu \\frac{d}{d\\mu} \\ln J = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ -2 \\Gamma_0 \\left( 2 \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_J^0 \\right]$.\n  - $\\mu \\frac{d}{d\\mu} \\ln S = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ 4 \\Gamma_0 \\left( \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_S^0 \\right]$.\n- **Final Observable**: $(\\frac{1}{\\sigma_0}\\frac{d\\sigma}{d\\tau})_{\\text{NLL}} = H(Q,Q) [J(Q^2\\tau,Q)]^2 S(Q\\tau,Q)$.\n- **Numerical Task**: Integrate the RG equations from canonical scales to $\\mu=Q$ using the one-loop running coupling: $\\alpha_s(\\mu) = \\frac{\\alpha_s(\\mu_0)}{1 + \\frac{\\alpha_s(\\mu_0)\\beta_0}{2\\pi} \\ln(\\mu/\\mu_0)}$ with $\\mu_0 = M_Z$.\n- **Test Cases**: $(Q, \\tau)$ pairs: $(91.1876\\,\\text{GeV}, \\{0.001, 0.010, 0.050, 0.100, 0.250\\})$ and $(500\\,\\text{GeV}, \\{0.010, 0.100\\})$.\n\n**Step 2: Validate Using Extracted Givens**\n\n1.  **Scientific Grounding**: The problem is located in the core of perturbative QCD and effective field theories (SCET), standard tools for precision physics at high-energy colliders. The factorization of the thrust distribution, the concept of RG evolution, anomalous dimensions, and running coupling are all fundamental and well-established principles. The provided one-loop anomalous dimensions form an internally consistent set, ensuring that the final physical observable is independent of the arbitrary renormalization scale $\\mu$, as can be verified by summing the anomalous dimensions: $\\gamma_H + 2\\gamma_J + \\gamma_S=0$. The physical and numerical parameters are standard.\n2.  **Well-Posedness**: The problem requires solving a system of first-order ordinary differential equations with well-defined initial conditions and integration limits. The infrared freeze-out procedure at $\\mu_{\\text{min}}$ avoids the unphysical Landau pole of the one-loop running coupling, ensuring the numerical stability and uniqueness of the solution.\n3.  **Objectivity**: The problem is stated in precise, quantitative terms, free of ambiguity or subjective claims. All required inputs for a unique solution are provided.\n\nThe problem is scientifically sound, well-posed, objective, complete, and consistent. It does not violate any of the invalidity criteria.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. A solution will be developed.\n\n### Solution\n\nThe NLL-resummed thrust distribution is given by the product of the hard, jet, and soft functions evolved to a common scale $\\mu=Q$:\n$$\n\\left(\\frac{1}{\\sigma_0}\\frac{d\\sigma}{d\\tau}\\right)_{\\text{NLL}}(\\tau;Q) = H(Q,\\mu=Q) \\left[J(Q^2 \\tau,\\mu=Q)\\right]^2 S(Q \\tau,\\mu=Q)\n$$\nThe functions are evolved from their canonical scales $\\mu_H$, $\\mu_J$, $\\mu_S$, where their values are fixed to unity. The evolution is governed by the RG equations. The solution for a generic function $F$ evolved from an initial scale $\\mu_i$ to a final scale $\\mu_f$ is:\n$$\nF(\\mu_f) = F(\\mu_i) \\exp\\left( \\int_{\\mu_i}^{\\mu_f} \\frac{d\\mu}{\\mu} \\gamma_F(\\mu) \\right)\n$$\nGiven the initial conditions $H(Q,\\mu_H)=1$, $J(Q^2\\tau,\\mu_J)=1$, and $S(Q\\tau,\\mu_S)=1$, we can determine the factors at $\\mu=Q$.\n\n1.  **Hard Function**: The canonical scale is $\\mu_H = Q$. The evolution is from $\\mu_i = Q$ to $\\mu_f = Q$. The integration interval is zero, so there is no evolution.\n    $$ H(Q,\\mu=Q) = H(Q,\\mu_H) \\exp(0) = 1 $$\n\n2.  **Jet and Soft Functions**: The jet and soft functions are evolved from their canonical scales, $\\mu_J = Q\\sqrt{\\tau}$ and $\\mu_S = Q\\tau$, to the final scale $\\mu=Q$. The problem specifies an infrared cutoff $\\mu_{\\text{min}}=1\\,\\text{GeV}$, which prevents the evolution from starting at a scale where perturbation theory is invalid. The effective starting scales for integration are therefore:\n    $$ \\mu_{J,\\text{start}} = \\max(\\mu_J, \\mu_{\\text{min}}) = \\max(Q\\sqrt{\\tau}, 1\\,\\text{GeV}) $$\n    $$ \\mu_{S,\\text{start}} = \\max(\\mu_S, \\mu_{\\text{min}}) = \\max(Q\\tau, 1\\,\\text{GeV}) $$\n    The evolved functions at $\\mu = Q$ are thus given by:\n    $$ J(Q^2\\tau, Q) = \\exp\\left( \\int_{\\mu_{J,\\text{start}}}^{Q} \\frac{d\\mu}{\\mu} \\gamma_J(\\mu) \\right) $$\n    $$ S(Q\\tau, Q) = \\exp\\left( \\int_{\\mu_{S,\\text{start}}}^{Q} \\frac{d\\mu}{\\mu} \\gamma_S(\\mu) \\right) $$\n    where $\\gamma_J(\\mu)$ and $\\gamma_S(\\mu)$ are the anomalous dimensions provided in the problem statement.\n\nCombining these results, the final expression for the resummed distribution is:\n$$\n\\left(\\frac{1}{\\sigma_0}\\frac{d\\sigma}{d\\tau}\\right)_{\\text{NLL}} = \\exp\\left( 2 \\int_{\\mu_{J,\\text{start}}}^{Q} \\frac{d\\mu}{\\mu} \\gamma_J(\\mu) + \\int_{\\mu_{S,\\text{start}}}^{Q} \\frac{d\\mu}{\\mu} \\gamma_S(\\mu) \\right)\n$$\nThe integrands are defined as follows, with the given anomalous dimensions:\n$$\n\\gamma_J(\\mu) = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ -2 \\Gamma_0 \\left( 2 \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_J^0 \\right]\n$$\n$$\n\\gamma_S(\\mu) = \\frac{\\alpha_s(\\mu)}{4\\pi} \\left[ 4 \\Gamma_0 \\left( \\ln\\!\\left( \\frac{Q}{\\mu} \\right) + \\ln \\tau \\right) + \\gamma_S^0 \\right]\n$$\nThe strong coupling $\\alpha_s(\\mu)$ runs according to the one-loop RG equation:\n$$\n\\alpha_s(\\mu) = \\frac{\\alpha_s(M_Z)}{1 + \\frac{\\alpha_s(M_Z)\\beta_0}{2\\pi} \\ln\\!\\left(\\frac{\\mu}{M_Z}\\right)}\n$$\nThe parameters are calculated from the given color factors and $n_f=5$:\n- $C_F = 4/3$, $C_A = 3$, $T_F = 1/2$, $n_f = 5$.\n- $\\beta_0 = \\frac{11 C_A}{3} - \\frac{4 T_F n_f}{3} = \\frac{11 \\cdot 3}{3} - \\frac{4 \\cdot (1/2) \\cdot 5}{3} = 11 - \\frac{10}{3} = \\frac{23}{3}$.\n- $\\Gamma_0 = 4 C_F = 16/3$.\n- $\\gamma_J^0 = 6 C_F = 8$.\n- $\\gamma_S^0 = 0$.\n\nThe computation requires numerical integration of the exponent term. For each test case $(Q, \\tau)$, we will:\n1.  Calculate the starting scales $\\mu_{J,\\text{start}}$ and $\\mu_{S,\\text{start}}$.\n2.  Numerically evaluate the two definite integrals for the jet and soft functions using a standard quadrature method.\n3.  Combine the results to compute the final value of the resummed distribution.\nThe integration variable $\\mu$ in both integrals runs from a starting scale (always $\\ge \\mu_{\\text{min}}$) to $Q$. Thus, the argument of the running coupling $\\alpha_s(\\mu)$ is always in the perturbative domain where the formula is valid.\nThe implementation will define functions for the running coupling and the integrands, then use `scipy.integrate.quad` to perform the numerical integration.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    # --- Define constants and parameters ---\n    # Color factors and QCD parameters\n    CF = 4.0 / 3.0\n    CA = 3.0\n    TF = 1.0 / 2.0\n    NF = 5\n\n    # One-loop beta function coefficient\n    BETA0 = (11.0 * CA / 3.0) - (4.0 * TF * NF / 3.0)\n\n    # One-loop anomalous dimensions\n    GAMMA0 = 4.0 * CF\n    GAMMA_H0 = -12.0 * CF\n    GAMMA_J0 = 6.0 * CF\n    GAMMA_S0 = 0.0\n\n    # Strong coupling and reference scale\n    ALPHA_S_MZ = 0.118\n    MZ = 91.1876  # GeV\n\n    # Infrared cutoff\n    MU_MIN = 1.0  # GeV\n\n    # --- Define physical functions ---\n\n    # One-loop running strong coupling constant\n    # The problem asks to freeze the running below MU_MIN. However, the integration\n    # variable mu in our setup will always be >= MU_MIN, so the freeze mechanism\n    # is only relevant for setting the lower integration bounds. For completeness,\n    # a fully robust alpha_s function would handle mu  MU_MIN explicitly, but\n    # it's not triggered here.\n    def alpha_s(mu):\n        \"\"\"Calculates the one-loop running coupling alpha_s at scale mu.\"\"\"\n        # Effective scale after applying the freeze cutoff\n        mu_eff = max(mu, MU_MIN)\n        log_mu_over_mz = np.log(mu_eff / MZ)\n        denominator = 1.0 + (ALPHA_S_MZ * BETA0 / (2.0 * np.pi)) * log_mu_over_mz\n        return ALPHA_S_MZ / denominator\n\n    # Integrand for the jet function evolution kernel\n    def integrand_jet(mu, Q, tau, log_tau):\n        \"\"\"Returns the integrand for the jet function RG evolution over d(mu).\"\"\"\n        term1 = -2.0 * GAMMA0 * (2.0 * np.log(Q / mu) + log_tau)\n        term2 = GAMMA_J0\n        kernel = (alpha_s(mu) / (4.0 * np.pi)) * (term1 + term2)\n        return kernel / mu\n\n    # Integrand for the soft function evolution kernel\n    def integrand_soft(mu, Q, tau, log_tau):\n        \"\"\"Returns the integrand for the soft function RG evolution over d(mu).\"\"\"\n        term1 = 4.0 * GAMMA0 * (np.log(Q / mu) + log_tau)\n        term2 = GAMMA_S0\n        kernel = (alpha_s(mu) / (4.0 * np.pi)) * (term1 + term2)\n        return kernel / mu\n\n    def compute_resummed_xs(Q, tau):\n        \"\"\"Computes the NLL-resummed thrust distribution for given Q and tau.\"\"\"\n        \n        # Hard function does not evolve, H(Q,Q) = 1.\n        log_H = 0.0\n\n        # --- Jet function evolution ---\n        mu_J_canonical = Q * np.sqrt(tau)\n        mu_J_start = max(mu_J_canonical, MU_MIN)\n        \n        log_J = 0.0\n        if mu_J_start  Q:\n            log_tau = np.log(tau)\n            log_J, _ = quad(integrand_jet, mu_J_start, Q, args=(Q, tau, log_tau))\n        \n        # --- Soft function evolution ---\n        mu_S_canonical = Q * tau\n        mu_S_start = max(mu_S_canonical, MU_MIN)\n\n        log_S = 0.0\n        if mu_S_start  Q:\n            log_tau = np.log(tau)\n            log_S, _ = quad(integrand_soft, mu_S_start, Q, args=(Q, tau, log_tau))\n\n        # Combine the evolved functions\n        # Final observable = H * J^2 * S\n        # In log space: log(H) + 2*log(J) + log(S)\n        total_log_exponent = log_H + 2.0 * log_J + log_S\n        \n        return np.exp(total_log_exponent)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Q = 91.1876 GeV\n        (91.1876, 0.001),\n        (91.1876, 0.010),\n        (91.1876, 0.050),\n        (91.1876, 0.100),\n        (91.1876, 0.250),\n        # Q = 500 GeV\n        (500.0, 0.010),\n        (500.0, 0.100),\n    ]\n\n    results = []\n    for Q_val, tau_val in test_cases:\n        result = compute_resummed_xs(Q_val, tau_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.16f}' for r in results)}]\")\n\nsolve()\n```", "id": "3531711"}, {"introduction": "当我们从简单的 $e^+e^-$ 过程转向更普遍的多粒子散射（如 $2 \\to 2$ 过程）时，必须考虑量子色动力学（QCD）的非阿贝尔性质所引入的颜色混合效应。在此类过程中，软函数 $S(\\mu)$ 和它的反常维度 $\\Gamma_S(\\alpha_s)$ 都变成了在颜色空间中的矩阵 [@problem_id:3531771]。这个练习将引导您通过数值对角化方法求解矩阵形式的重整化群方程，并验证物理结果的基底无关性，从而深入理解在多粒子末态中处理颜色自由度的SCET方法。", "problem": "要求您在软共线有效理论（Soft-Collinear Effective Theory, SCET）框架内，实现无质量 $2 \\to 2$ 部分子散射的色空间软函数的单圈重整化群演化。此任务的重点在于由反常维度矩阵编码的色混合，以及评估其基底依赖性。请在一个简化的、科学上一致的情境下进行，其中色空间维度为二，运动学为欧几里德（类空）的，因此所有对数皆为实数，且不出现库仑相位。演化必须通过对角化反常维度矩阵来进行数值计算。\n\n基本依据和定义：\n- 色空间中软函数 $S(\\mu)$ 的重整化群方程（RGE）为\n$$\n\\frac{d}{d \\ln \\mu} S(\\mu) = \\Gamma_S^\\dagger(\\alpha_s(\\mu)) \\, S(\\mu) + S(\\mu) \\, \\Gamma_S(\\alpha_s(\\mu)) \\, ,\n$$\n其中 $\\Gamma_S(\\alpha_s)$ 是色空间中的软反常维度矩阵，而 $\\alpha_s(\\mu)$ 是在重整化标度 $\\mu$ 下的强耦合常数。\n- 在单圈近似下，假设\n$$\n\\Gamma_S(\\alpha_s(\\mu)) = \\frac{\\alpha_s(\\mu)}{\\pi} \\, \\Gamma_S^{(1)} \\, ,\n$$\n其中 $\\Gamma_S^{(1)}$ 是一个由色因子和运动学对数决定的常数矩阵。\n- 使用强耦合的单圈跑动方程，\n$$\n\\frac{d \\alpha_s(\\mu)}{d \\ln \\mu} = - \\beta_0 \\, \\frac{\\alpha_s^2(\\mu)}{2 \\pi} \\, ,\n$$\n其中\n$$\n\\beta_0 = \\frac{11 C_A - 4 T_F n_f}{3} \\, ,\n$$\n其中 $C_A = N_c$，$C_F = \\frac{N_c^2 - 1}{2 N_c}$，$T_F = \\frac{1}{2}$，而 $n_f$ 是活性夸克味的數量；取 $N_c = 3$。\n- 演化方程的解可以写成演化算符 $U(\\mu_f,\\mu_0)$ 的形式，\n$$\nS(\\mu_f) = U^\\dagger(\\mu_f,\\mu_0) \\, S(\\mu_0) \\, U(\\mu_f,\\mu_0) \\, ,\n$$\n其中\n$$\nU(\\mu_f,\\mu_0) = \\exp\\!\\left( K(\\mu_f,\\mu_0) \\, \\Gamma_S^{(1)} \\right) \\, ,\n$$\n其中标量系数 $K(\\mu_f,\\mu_0)$ 由下式给出\n$$\nK(\\mu_f,\\mu_0) = \\int_{\\ln \\mu_0}^{\\ln \\mu_f} \\frac{\\alpha_s(\\mu)}{\\pi} \\, d \\ln \\mu = \\frac{2}{\\beta_0} \\ln \\left( \\frac{\\alpha_s(\\mu_0)}{\\alpha_s(\\mu_f)} \\right) \\, .\n$$\n使用单圈表达式\n$$\n\\alpha_s(\\mu_f) = \\frac{\\alpha_s(\\mu_0)}{1 + \\frac{\\beta_0 \\, \\alpha_s(\\mu_0)}{2 \\pi} \\, \\ln \\left( \\frac{\\mu_f}{\\mu_0} \\right)} \\, .\n$$\n- 在所选的欧几里得运动学（$t  0$, $u  0$, $s > 0$）中，定义实数对数\n$$\nL_s = \\ln \\left( \\frac{s}{\\mu_0^2} \\right) \\, , \\quad L_t = \\ln \\left( \\frac{-t}{\\mu_0^2} \\right) \\, , \\quad L_u = \\ln \\left( \\frac{-u}{\\mu_0^2} \\right) \\, , \\quad \\Delta_{tu} = L_t - L_u \\, .\n$$\n使用以下对称、实数的 $2 \\times 2$ 模型作为单圈软反常维度矩阵，此模型与色混合及欧几里得运动学一致：\n$$\n\\Gamma_S^{(1)} =\n\\begin{pmatrix}\nC_F \\, \\Delta_{tu}  \\frac{C_F \\, C_A}{2 N_c} \\, (L_s + \\Delta_{tu}) \\\\\n\\frac{C_F \\, C_A}{2 N_c} \\, (L_s + \\Delta_{tu})  \\frac{C_A}{2} \\, L_s + \\left( C_F - \\frac{C_A}{2} \\right) \\Delta_{tu}\n\\end{pmatrix} \\, ,\n$$\n其中 $N_c = 3$，$C_F = \\frac{4}{3}$，且 $C_A = 3$。\n\n计算任务：\n1. 根据上述规定，通过对从 $\\mu_0$ 到 $\\mu_f$ 的单圈跑动耦合进行积分来构建 $K(\\mu_f,\\mu_0)$。所有标度 $\\mu$ 必须以 $\\mathrm{GeV}$ 为单位提供和处理，所有运动学不变量 $s$、$t$、$u$ 以 $\\mathrm{GeV}^2$ 为单位。角度必须以弧度为单位。\n2. 使用给定的公式和常数构成矩阵 $\\Gamma_S^{(1)}$。对 $\\Gamma_S^{(1)}$ 进行数值对角化以计算\n$$\nU(\\mu_f,\\mu_0) = V \\, \\mathrm{diag}\\!\\left( e^{K \\lambda_i} \\right) \\, V^{-1} \\, ,\n$$\n其中 $\\lambda_i$ 是 $\\Gamma_S^{(1)}$ 的特征值，$V$ 是其特征向量矩阵。然后评估\n$$\nS(\\mu_f) = U^\\dagger \\, S(\\mu_0) \\, U \\, ,\n$$\n其中 $S(\\mu_0)$ 取为一个对称正定矩阵。\n3. 使用由旋转角 $\\theta$ 参数化的么正（正交）色基底变换 $R(\\theta)$ 来评估基底依赖性，\n$$\nR(\\theta) =\n\\begin{pmatrix}\n\\cos \\theta  -\\sin \\theta \\\\\n\\sin \\theta  \\cos \\theta\n\\end{pmatrix} \\, .\n$$\n通过\n$$\n\\Gamma_S^{(1)\\prime} = R \\, \\Gamma_S^{(1)} \\, R^{-1} = R \\, \\Gamma_S^{(1)} \\, R^T \\, , \\quad S(\\mu_0)^\\prime = R \\, S(\\mu_0) \\, R^T \\, .\n$$\n变换到旋转后的基底。在旋转后的基底中，使用相同的程序进行演化以获得 $S(\\mu_f)^\\prime$。再变换回原始基底，\n$$\n\\widetilde{S}(\\mu_f) = R^T \\, S(\\mu_f)^\\prime \\, R \\, ,\n$$\n并通过 Frobenius 范数\n$$\n\\Delta = \\left\\| \\widetilde{S}(\\mu_f) - S(\\mu_f) \\right\\|_F \\, .\n$$\n来量化基底的一致性。如果演化是基底无关的，标量 $\\Delta$ 在数值上应该很小。\n4. 为了数值稳定性和清晰度，所有矩阵运算均使用双精度实现。确保 $S(\\mu_0)$ 是对称正定的；取\n$$\nS(\\mu_0) = \\begin{pmatrix} 1.0  0.2 \\\\ 0.2  0.6 \\end{pmatrix} \\, .\n$$\n\n测试套件：\n提供一个程序，运行以下四个测试案例；对每个案例，计算如上定义的标量 $\\Delta$。所有标度单位为 $\\mathrm{GeV}$，不变量单位为 $\\mathrm{GeV}^2$，角度单位为弧度。\n- 案例 1（一般混合，大演化范围）：\n  - $\\mu_0 = 2$, $\\mu_f = 100$, $\\alpha_s(\\mu_0) = 0.30$, $n_f = 5$,\n  - $s = 10^4$, $t = -2000$, $u = -8000$ （注意 $s + t + u = 0$）,\n  - $\\theta = 0.3$。\n- 案例 2（边界条件，无演化）：\n  - $\\mu_0 = 2$, $\\mu_f = 2$, $\\alpha_s(\\mu_0) = 0.30$, $n_f = 5$,\n  - $s = 10^4$, $t = -2000$, $u = -8000$,\n  - $\\theta = 0.5$。\n- 案例 3（较重运动学，强演化）：\n  - $\\mu_0 = 10$, $\\mu_f = 1000$, $\\alpha_s(\\mu_0) = 0.25$, $n_f = 5$,\n  - $s = 2 \\times 10^6$, $t = -5 \\times 10^5$, $u = -1.5 \\times 10^6$,\n  - $\\theta = 0.2$。\n- 案例 4（电弱标度起始，中等演化）：\n  - $\\mu_0 = 91.1876$, $\\mu_f = 1000$, $\\alpha_s(\\mu_0) = 0.118$, $n_f = 5$,\n  - $s = 10^5$, $t = -4 \\times 10^4$, $u = -6 \\times 10^4$,\n  - $\\theta = \\frac{\\pi}{4}$。\n\n最终输出格式规范：\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目对应于按所列顺序排列的其中一个测试案例的标量 $\\Delta$，例如 $[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]$。角度必须以弧度为单位提供；标度以 $\\mathrm{GeV}$ 为单位；不变量以 $\\mathrm{GeV}^2$ 为单位。不应打印任何额外文本。", "solution": "用户想要解决一个计算高能物理中的问题，具体是关于SCET中软函数的重整化群（RG）演化。\n\n### 问题验证\n\n#### 第1步：提取给定条件\n- **软函数 $S(\\mu)$ 的重整化群方程（RGE）**：\n$$\n\\frac{d}{d \\ln \\mu} S(\\mu) = \\Gamma_S^\\dagger(\\alpha_s(\\mu)) \\, S(\\mu) + S(\\mu) \\, \\Gamma_S(\\alpha_s(\\mu))\n$$\n- **单圈软反常维度矩阵 $\\Gamma_S(\\alpha_s)$**：\n$$\n\\Gamma_S(\\alpha_s(\\mu)) = \\frac{\\alpha_s(\\mu)}{\\pi} \\, \\Gamma_S^{(1)}\n$$\n- **强耦合常数 $\\alpha_s(\\mu)$ 的单圈跑动**：\n$$\n\\frac{d \\alpha_s(\\mu)}{d \\ln \\mu} = - \\beta_0 \\, \\frac{\\alpha_s^2(\\mu)}{2 \\pi}\n$$\n- **单圈β函数系数 $\\beta_0$**：\n$$\n\\beta_0 = \\frac{11 C_A - 4 T_F n_f}{3}\n$$\n- **色因子**：$N_c = 3$, $C_A = N_c$, $C_F = \\frac{N_c^2 - 1}{2 N_c}$, $T_F = \\frac{1}{2}$。\n- **RGE的解**：\n$$\nS(\\mu_f) = U^\\dagger(\\mu_f,\\mu_0) \\, S(\\mu_0) \\, U(\\mu_f,\\mu_0)\n$$\n- **演化算符 $U(\\mu_f,\\mu_0)$**：\n$$\nU(\\mu_f,\\mu_0) = \\exp\\!\\left( K(\\mu_f,\\mu_0) \\, \\Gamma_S^{(1)} \\right)\n$$\n- **标量演化核 $K(\\mu_f,\\mu_0)$**：\n$$\nK(\\mu_f,\\mu_0) = \\int_{\\ln \\mu_0}^{\\ln \\mu_f} \\frac{\\alpha_s(\\mu)}{\\pi} \\, d \\ln \\mu = \\frac{2}{\\beta_0} \\ln \\left( \\frac{\\alpha_s(\\mu_0)}{\\alpha_s(\\mu_f)} \\right)\n$$\n- **$\\alpha_s(\\mu_f)$ 的单圈表达式**：\n$$\n\\alpha_s(\\mu_f) = \\frac{\\alpha_s(\\mu_0)}{1 + \\frac{\\beta_0 \\, \\alpha_s(\\mu_0)}{2 \\pi} \\, \\ln \\left( \\frac{\\mu_f}{\\mu_0} \\right)}\n$$\n- **运动学对数**：\n$$\nL_s = \\ln \\left( \\frac{s}{\\mu_0^2} \\right) \\, , \\quad L_t = \\ln \\left( \\frac{-t}{\\mu_0^2} \\right) \\, , \\quad L_u = \\ln \\left( \\frac{-u}{\\mu_0^2} \\right) \\, , \\quad \\Delta_{tu} = L_t - L_u\n$$\n- **单圈软反常维度矩阵 $\\Gamma_S^{(1)}$ 的模型**：\n$$\n\\Gamma_S^{(1)} =\n\\begin{pmatrix}\nC_F \\, \\Delta_{tu}  \\frac{C_F \\, C_A}{2 N_c} \\, (L_s + \\Delta_{tu}) \\\\\n\\frac{C_F \\, C_A}{2 N_c} \\, (L_s + \\Delta_{tu})  \\frac{C_A}{2} \\, L_s + \\left( C_F - \\frac{C_A}{2} \\right) \\Delta_{tu}\n\\end{pmatrix}\n$$\n- ** specific色因子值**：$N_c = 3$，$C_F = \\frac{4}{3}$，$C_A = 3$。\n- **初始软函数矩阵 $S(\\mu_0)$**：\n$$\nS(\\mu_0) = \\begin{pmatrix} 1.0  0.2 \\\\ 0.2  0.6 \\end{pmatrix}\n$$\n- **基底变换旋转矩阵 $R(\\theta)$**：\n$$\nR(\\theta) =\n\\begin{pmatrix}\n\\cos \\theta  -\\sin \\theta \\\\\n\\sin \\theta  \\cos \\theta\n\\end{pmatrix}\n$$\n- **变换规则**：$\\Gamma_S^{(1)\\prime} = R \\, \\Gamma_S^{(1)} \\, R^T$，$S(\\mu_0)^\\prime = R \\, S(\\mu_0) \\, R^T$。\n- **基底一致性检验**：计算 $\\widetilde{S}(\\mu_f) = R^T \\, S(\\mu_f)^\\prime \\, R$ 并量化差异 $\\Delta = \\left\\| \\widetilde{S}(\\mu_f) - S(\\mu_f) \\right\\|_F$。\n- **测试案例**：\n    1. $\\mu_0=2$, $\\mu_f=100$, $\\alpha_s(\\mu_0)=0.30$, $n_f=5$, $s=10^4$, $t=-2000$, $u=-8000$, $\\theta=0.3$。\n    2. $\\mu_0=2$, $\\mu_f=2$, $\\alpha_s(\\mu_0)=0.30$, $n_f=5$, $s=10^4$, $t=-2000$, $u=-8000$, $\\theta=0.5$。\n    3. $\\mu_0=10$, $\\mu_f=1000$, $\\alpha_s(\\mu_0)=0.25$, $n_f=5$, $s=2 \\times 10^6$, $t=-5 \\times 10^5$, $u=-1.5 \\times 10^6$, $\\theta=0.2$。\n    4. $\\mu_0=91.1876$, $\\mu_f=1000$, $\\alpha_s(\\mu_0)=0.118$, $n_f=5$, $s=10^5$, $t=-4 \\times 10^4$, $u=-6 \\times 10^4$, $\\theta=\\pi/4$。\n- **单位**：标度（$\\mu$）以 $\\mathrm{GeV}$ 为单位，不变量（$s,t,u$）以 $\\mathrm{GeV}^2$ 为单位，角度（$\\theta$）以弧度为单位。\n\n#### 第2步：使用提取的给定条件进行验证\n该问题具有科学根据、定义明确且客观。\n- **科学根据**：该问题基于量子色动力学（QCD）和软共线有效理论（SCET）的标准原理。RGE、耦合常数 $\\alpha_s$ 的跑动、色因子以及反常维度的结构都是标准概念。$\\Gamma_S^{(1)}$ 的具体形式是一个为简化情景定义的明确模型。\n- **定义明确性**：该问题提供了一个清晰、分步的计算任务，包含了所有必要的输入、方程和初始条件。计算演化、改变基底和比较结果的程序都已明确定义，从而得出一个唯一的数值结果 $\\Delta$。\n- **客观性**：语言精确且数学化，没有主观因素。\n- **缺陷检查**：\n    1.  在明确定义的理论模型背景下，该问题在科学上是合理的。它没有违反任何基本原理。\n    2.  该问题是可形式化的，并且直接涉及指定的计算高能物理领域。\n    3.  该问题是自洽的。所有必要的数据和关系都已提供。无质量粒子的运动学约束 $s+t+u=0$ 在所有测试案例中都得到满足。\n    4.  物理参数和运动学值对于粒子物理实验是现实的。\n    5.  问题结构合理。基底无关性测试是量子场论中的一项基本检验，所提出的方法是执行该检验的正确方式。唯一解的存在性是有保证的。\n    6.  该问题并非微不足道，因为它需要通过矩阵指数正确实现RG演化，并理解基底变换。\n    7.  结果是可进行数值验证的。\n\n#### 第3步：结论与行动\n此问题有效。将提供完整的解决方案。\n\n### 基于原则的设计\n目标是数值验证模型 $2 \\to 2$ 过程中 SCET 软函数重整化群演化的基底无关性。核心原理是物理可观测量（此处由演化后的软函数 $S(\\mu_f)$ 表示）必须独立于用于表示色态的基底选择。我们将在两种不同的基底中——原始基底和旋转后的基底——执行 RG 演化，并证明最终的物理结果在数值精度范围内是相同的。\n\n计算过程结构如下：\n\n1.  **常数和初始设置**：我们首先定义理论的基本常数：色数 $N_c=3$ 和相关的色因子 $C_A = 3$ 和 $C_F = 4/3$。演化的初始条件，即软函数矩阵 $S(\\mu_0)$，也被定义为一个固定的对称正定矩阵。\n\n2.  **演化核计算**：对于每个测试案例，我们计算标量演化核 $K(\\mu_f, \\mu_0)$，它包含了从初始标度 $\\mu_0$ 到最终标度 $\\mu_f$ 之间强耦合常数 $\\alpha_s$ 跑动的积分效应。这首先需要计算给定活性夸克味数 $n_f$ 的单圈QCD β函数系数 $\\beta_0$。然后，我们使用 $\\alpha_s$ 的RGE的单圈解来找到其在最终标度 $\\alpha_s(\\mu_f)$ 的值。有了 $\\alpha_s(\\mu_0)$ 和 $\\alpha_s(\\mu_f)$，我们计算 $K(\\mu_f, \\mu_0) = \\frac{2}{\\beta_0} \\ln(\\alpha_s(\\mu_0)/\\alpha_s(\\mu_f))$。如果 $\\mu_f = \\mu_0$，会出现一个特殊情况，此时正确地得出 $K=0$，没有演化。\n\n3.  **反常维度矩阵构建**：我们使用提供的公式构建 $2 \\times 2$ 单圈反常维度矩阵 $\\Gamma_S^{(1)}$。该矩阵通过对数 $L_s$, $L_t$, 和 $L_u$ 依赖于运动学不变量 $s$, $t$, $u$ 和初始标度 $\\mu_0$。\n\n4.  **在原始基底中的RG演化**：\n    - 演化算符是一个矩阵指数，$U(\\mu_f, \\mu_0) = \\exp(K(\\mu_f, \\mu_0) \\Gamma_S^{(1)})$。\n    - 我们通过首先对角化反常维度矩阵来高效地计算它：$\\Gamma_S^{(1)} = V \\Lambda V^{-1}$，其中 $\\Lambda$ 是特征值 $\\lambda_i$ 的对角矩阵，$V$ 是相应特征向量的矩阵。\n    - 演化算符则为 $U = V \\exp(K\\Lambda) V^{-1}$。由于 $\\Gamma_S^{(1)}$ 是实对称的，其特征向量是正交的，所以 $V^{-1} = V^T$。\n    - 演化后的软函数计算为 $S(\\mu_f) = U^\\dagger S(\\mu_0) U$。由于所有量都是实数，这简化为 $S(\\mu_f) = U^T S(\\mu_0) U$。\n\n5.  **在旋转基底中的RG演化**：\n    - 我们为给定角度 $\\theta$ 定义一个正交旋转矩阵 $R(\\theta)$。\n    - 我们将初始问题转换到新的（带撇号的）基底：\n      - 反常维度: $\\Gamma_S^{(1)\\prime} = R \\Gamma_S^{(1)} R^T$。\n      - 初始软函数: $S(\\mu_0)^\\prime = R S(\\mu_0) R^T$。\n    - 我们完全在这个带撇号的基底中执行演化。通过对角化 $\\Gamma_S^{(1)\\prime}$ 并取指数来计算一个新的演化算符 $U'$：$U' = \\exp(K \\Gamma_S^{(1)\\prime})$。\n    - 在带撇号的基底中演化后的软函数是 $S(\\mu_f)^\\prime = U'^T S(\\mu_0)^\\prime U'$。\n\n6.  **基底无关性验证**：\n    - 为了比较结果，我们将 $S(\\mu_f)^\\prime$ 旋转回原始基底：$\\widetilde{S}(\\mu_f) = R^T S(\\mu_f)^\\prime R$。\n    - 理论一致性要求 $\\widetilde{S}(\\mu_f) = S(\\mu_f)$。我们通过计算差分矩阵的Frobenius范数来量化数值偏差：$\\Delta = \\left\\| \\widetilde{S}(\\mu_f) - S(\\mu_f) \\right\\|_F$。一个接近机器精度的 $\\Delta$ 值证实了实现的基底无关性。\n\n整个过程使用 Python 的 `numpy` 库实现，以稳健地处理矩阵代数和线性 algebra 运算，确保计算以双精度浮点数进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy is not used as per the problem scope and numpy's capabilities.\n\ndef solve():\n    \"\"\"\n    Solves the problem of Renormalization Group Evolution for a SCET soft function,\n    and verifies its basis independence.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general mixing, large evolution range)\n        {'mu0': 2.0, 'muf': 100.0, 'alpha_s_mu0': 0.30, 'nf': 5,\n         's': 1.0e4, 't': -2000.0, 'u': -8000.0, 'theta': 0.3},\n        # Case 2 (boundary condition, no evolution)\n        {'mu0': 2.0, 'muf': 2.0, 'alpha_s_mu0': 0.30, 'nf': 5,\n         's': 1.0e4, 't': -2000.0, 'u': -8000.0, 'theta': 0.5},\n        # Case 3 (heavier kinematics, strong evolution)\n        {'mu0': 10.0, 'muf': 1000.0, 'alpha_s_mu0': 0.25, 'nf': 5,\n         's': 2.0e6, 't': -5.0e5, 'u': -1.5e6, 'theta': 0.2},\n        # Case 4 (electroweak scale start, moderate evolution)\n        {'mu0': 91.1876, 'muf': 1000.0, 'alpha_s_mu0': 0.118, 'nf': 5,\n         's': 1.0e5, 't': -4.0e4, 'u': -6.0e4, 'theta': np.pi / 4.0}\n    ]\n\n    results = []\n    \n    # Fundamental constants and initial condition\n    Nc = 3.0\n    CF = (Nc**2 - 1.0) / (2.0 * Nc)\n    CA = Nc\n    TF = 0.5\n    S_mu0 = np.array([[1.0, 0.2], [0.2, 0.6]], dtype=np.float64)\n\n    for case in test_cases:\n        mu0 = case['mu0']\n        muf = case['muf']\n        alpha_s_mu0 = case['alpha_s_mu0']\n        nf = case['nf']\n        s, t, u = case['s'], case['t'], case['u']\n        theta = case['theta']\n        \n        # 1. Compute the evolution kernel K(muf, mu0)\n        beta0 = (11.0 * CA - 4.0 * TF * nf) / 3.0\n        \n        K = 0.0\n        # Avoid log(1) for mu0=muf case to prevent potential floating point issues.\n        # Although log(1) is exactly 0, log(muf/mu0) is more robust if scales are identical.\n        if mu0 != muf:\n            log_mu_ratio = np.log(muf / mu0)\n            alpha_s_muf = alpha_s_mu0 / (1.0 + beta0 * alpha_s_mu0 / (2.0 * np.pi) * log_mu_ratio)\n            # This can also be written using alpha_s_muf to be more explicit\n            log_alpha_ratio = np.log(alpha_s_mu0 / alpha_s_muf)\n            K = (2.0 / beta0) * log_alpha_ratio\n\n        # 2. Form the anomalous dimension matrix Gamma_S^(1)\n        mu0_sq = mu0**2\n        Ls = np.log(s / mu0_sq)\n        Lt = np.log(-t / mu0_sq)\n        Lu = np.log(-u / mu0_sq)\n        Delta_tu = Lt - Lu\n        \n        Gamma_S1_11 = CF * Delta_tu\n        Gamma_S1_12 = (CF * CA / (2.0 * Nc)) * (Ls + Delta_tu)\n        Gamma_S1_22 = (CA / 2.0) * Ls + (CF - CA / 2.0) * Delta_tu\n        \n        Gamma_S1 = np.array([[Gamma_S1_11, Gamma_S1_12],\n                             [Gamma_S1_12, Gamma_S1_22]], dtype=np.float64)\n\n        # Function to compute evolved S from Gamma and S0\n        def evolve_S(Gamma, S0, K_val):\n            if K_val == 0.0:\n                return S0\n            # Diagonalize the real symmetric matrix Gamma\n            eigenvalues, V = np.linalg.eigh(Gamma)\n            # Compute evolution operator U = V * exp(K*Lambda) * V_inv\n            # For real symmetric, V is orthogonal, so V_inv = V.T\n            exp_K_lambda = np.diag(np.exp(K_val * eigenvalues))\n            U = V @ exp_K_lambda @ V.T\n            # Evolve S. Since U is real, U_dagger = U.T\n            S_evolved = U.T @ S0 @ U\n            return S_evolved\n\n        # 3. Evolve in the original basis\n        S_muf = evolve_S(Gamma_S1, S_mu0, K)\n        \n        # 4. Assess basis dependence\n        # Define rotation matrix R\n        R = np.array([[np.cos(theta), -np.sin(theta)],\n                      [np.sin(theta),  np.cos(theta)]], dtype=np.float64)\n        \n        # Transform to the rotated basis\n        Gamma_S1_prime = R @ Gamma_S1 @ R.T\n        S_mu0_prime = R @ S_mu0 @ R.T\n\n        # Evolve in the rotated basis\n        S_muf_prime = evolve_S(Gamma_S1_prime, S_mu0_prime, K)\n        \n        # Transform back to the original basis\n        S_muf_tilde = R.T @ S_muf_prime @ R\n        \n        # Quantify basis-consistency by the Frobenius norm\n        Delta = np.linalg.norm(S_muf_tilde - S_muf, 'fro')\n        results.append(Delta)\n    \n    # Final print statement in the exact required format.\n    # Use exponential notation for small numbers to maintain precision in string representation.\n    print(f\"[{','.join(f'{r:.16e}' for r in results)}]\")\n\nsolve()\n```", "id": "3531771"}, {"introduction": "任何微扰计算都存在因截断在有限阶而引入的理论不确定性，评估这种不确定性是精确唯象学研究的关键环节。这项实践将指导您研究重求和指数对强耦合常数 $\\alpha_s(\\mu)$ 跑动行为的敏感度 [@problem_id:3531739]。通过比较使用不同圈数（三圈与四圈）的QCD $\\beta$ 函数得到的计算结果，您将亲身体验如何量化来自更高阶修正的理论误差，这是连接理论预测与实验测量不可或缺的一步。", "problem": "你的任务是，在软共线有效理论 (SCET) 的框架内，实现一项关于量子色动力学 (QCD) 中重求和指数对强耦合常数跑动的敏感性的数值研究。该研究必须比较使用 QCD beta 函数的三圈和四圈截断所获得的结果。你的程序必须为指定的测试用例计算 Sudakov 指数和一个简单的重求和分布，然后量化由改变跑动的圈数阶所引起的偏移。\n\n从以下基本要素开始：\n\n1. 强耦合常数的重整化群方程由关于重整化标度的微分方程给出：\n$$\n\\frac{d\\,\\alpha_s(\\mu)}{d\\ln \\mu} \\equiv \\beta(\\alpha_s) \\, ,\n$$\n其中 beta 函数的微扰展开在圈阶 $N \\in \\{3,4\\}$ 处截断，\n$$\n\\beta(\\alpha_s) = -2\\,\\alpha_s \\sum_{n=0}^{N-1} \\beta_n \\left(\\frac{\\alpha_s}{4\\pi}\\right)^{n+1},\n$$\n其中系数 $\\beta_n$ 是 QCD 中修正最小减除方案（记作 $\\overline{\\mathrm{MS}}$）的系数。在此问题中，你必须对所有标度使用固定的活性夸克味数 $n_f = 5$。这些系数是：\n- $ \\beta_0 = 11 - \\frac{2}{3} n_f $,\n- $ \\beta_1 = 102 - \\frac{38}{3} n_f $,\n- $ \\beta_2 = \\frac{2857}{2} - \\frac{5033}{18} n_f + \\frac{325}{54} n_f^2 $,\n- $ \\beta_3 = \\frac{149753}{6} + 3564\\,\\zeta_3 - \\left(\\frac{1078361}{162} + \\frac{6508}{27}\\,\\zeta_3\\right) n_f + \\left(\\frac{50065}{162} + \\frac{6472}{81}\\,\\zeta_3\\right) n_f^2 + \\frac{1093}{729} n_f^3 $,\n其中 $\\zeta_3$ 是 Apéry 常数，即黎曼 zeta 函数在 3 处的值。\n\n2. 对于一个通用的全局事件形状对数 $L \\equiv \\ln(1/v)$，此问题中的 Sudakov 辐射子定义为积分\n$$\nR(L;Q) = 2 \\int_{\\mu_L}^{Q} \\frac{d\\mu'}{\\mu'} \\, \\Gamma_{\\mathrm{cusp}}(\\alpha_s(\\mu')) \\, \\ln\\left(\\frac{Q}{\\mu'}\\right),\n$$\n其中下限标度为 $\\mu_L \\equiv Q e^{-L}$，硬标度 $Q$ 在测试用例中指定。尖角反常维度展开为\n$$\n\\Gamma_{\\mathrm{cusp}}(\\alpha_s) = \\sum_{n=0}^{2} \\Gamma_n \\left(\\frac{\\alpha_s}{4\\pi}\\right)^{n+1},\n$$\n使用量子色动力学色因子 $C_A = 3$、$C_F = 4/3$、$T_F = 1/2$ 和 $n_f = 5$。到三圈的系数为\n- $ \\Gamma_0 = 4 C_F $,\n- $ \\Gamma_1 = 4 C_F \\left[ \\left(\\frac{67}{9} - \\frac{\\pi^2}{3}\\right) C_A - \\frac{20}{9} T_F n_f \\right] $,\n- $ \\Gamma_2 = 4 C_F \\left[ C_A^2 \\left(\\frac{245}{6} - \\frac{134\\pi^2}{27} + \\frac{11\\pi^4}{45} + \\frac{22}{3}\\zeta_3\\right) + C_A T_F n_f \\left(-\\frac{418}{27} + \\frac{40\\pi^2}{27} - \\frac{56}{3}\\zeta_3\\right) + C_F T_F n_f \\left(-\\frac{55}{3} + 16 \\zeta_3\\right) - \\frac{16}{27} T_F^2 n_f^2 \\right].\n$\n\n3. 为此问题定义 Sudakov 指数 $S(Q,L) \\equiv R(L;Q)$，并定义一个简单的重求和分布\n$$\nD(v;Q) = \\frac{1}{v} \\, \\exp\\left[-R(L;Q)\\right] \\, \\frac{dR(L;Q)}{dL},\n$$\n其中 $L \\equiv \\ln(1/v)$，且导数根据 $R(L;Q)$ 的定义以及 $\\mu_L$ 与 $L$ 的关系计算。\n\n4. 耦合常数的边界条件：在 $ \\mu_0 = M_Z = 91.1876 \\, \\mathrm{GeV} $ 处使用 $ \\alpha_s(\\mu_0) = 0.118 $。此问题中的所有能量均以 $\\mathrm{GeV}$ 为单位处理。输出 $S$ 和 $D$ 是无量纲的。\n\n5. 此任务的假设：忽略夸克阈值匹配，并将 $n_f = 5$ 视为对所有标度都固定；使用 $\\overline{\\mathrm{MS}}$ 方案；严格按照所述定义使用。不涉及角度。你必须在 $\\ln \\mu$ 中数值求解跑动耦合微分方程并数值计算积分。不允许使用 $R(L;Q)$ 或跑动耦合的任何闭合形式的“快捷”表达式；你必须直接实现定义。\n\n算法要求：\n- 通过分别在 $N=3$ 和 $N=4$ 处截断 beta 函数，实现跑动耦合的三圈和四圈版本，同时将尖角反常维度固定在三圈。这样可以隔离出对跑动的敏感性。\n- 对于每个测试用例，使用三圈 beta 函数计算 $S_3 \\equiv S(Q,L)$ 和 $D_3 \\equiv D(v;Q)$，并使用四圈 beta 函数计算 $S_4$ 和 $D_4$。然后计算偏移量 $\\Delta S \\equiv S_4 - S_3$ 和 $\\Delta D \\equiv D_4 - D_3$。\n\n数值细节：\n- 使用可靠的数值积分方法，以足够的绝对和相对容差来计算所有关于 $\\ln \\mu$ 或 $\\mu$ 的积分，以确保最终输出至少有六位小数的稳定结果。\n- 确保跑动耦合解的积分范围覆盖所有测试用例所需的整个域，即从测试套件中最小的 $ \\mu_L $ 到最大的 $ Q $。\n- 程序必须将每个报告的浮点数四舍五入到六位小数。\n\n测试套件：\n使用以下测试用例列表，每个由 $(Q, v)$ 指定，$Q$ 的单位是 $\\mathrm{GeV}$，$v$ 是无量纲的：\n- 测试 $1$：$Q = 91.1876$, $v = 0.1$。\n- 测试 $2$：$Q = 30.0$, $v = 0.1$。\n- 测试 $3$：$Q = 91.1876$, $v = 0.9$。\n- 测试 $4$：$Q = 30.0$, $v = 0.3$。\n\n对于每个测试用例，你的程序必须按此顺序输出一个包含六个条目的列表：\n$[\\Delta S, \\Delta D, S_3, S_4, D_3, D_4]$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含所有四个测试用例的结果列表，按顺序排列，作为一个逗号分隔的列表的列表，并用方括号括起来，例如：\n$[[\\Delta S_1,\\Delta D_1,S_{3,1},S_{4,1},D_{3,1},D_{4,1}],[\\Delta S_2,\\Delta D_2,S_{3,2},S_{4,2},D_{3,2},D_{4,2}],\\ldots]$。\n所有浮点数必须四舍五入到六位小数。不应打印任何附加文本。", "solution": "该问题要求对量子色动力学 (QCD) 中重求和可观测量对强耦合常数 $\\alpha_s$ 跑动的圈数阶的敏感性进行数值研究。具体来说，我们需要比较当 $\\alpha_s(\\mu)$ 分别使用三圈和四圈 QCD beta 函数进行演化时，Sudakov 指数 $S$ 和一个重求和分布 $D$ 的结果。该研究的框架是软共线有效理论 (SCET)，所有定义、常数和参数都已给出，且必须按规定使用。\n\n问题的核心在于三个组成部分之间的相互作用：\n1.  由重整化群方程 (RGE) 控制的强耦合常数 $\\alpha_s(\\mu)$ 的跑动。\n2.  Sudakov 辐射子 $R(L;Q)$，它对大对数 $L$ 进行重求和，并通过一个涉及 $\\alpha_s(\\mu)$ 和尖角反常维度 $\\Gamma_{\\mathrm{cusp}}(\\alpha_s)$ 的积分来定义。\n3.  一个重求和微分分布 $D(v;Q)$，它涉及 Sudakov 指数及其对对数 $L$ 的导数。\n\n计算策略是严格遵循所提供的理论公式，对这些组成部分进行数值实现。\n\n首先，我们处理强耦合常数 $\\alpha_s$ 的跑动。它随重整化标度 $\\mu$ 的演化由 RGE 描述：\n$$\n\\frac{d\\,\\alpha_s(\\mu)}{d\\ln \\mu} = \\beta(\\alpha_s)\n$$\n$\\beta$-函数以 $\\alpha_s$ 的微扰级数形式给出：\n$$\n\\beta(\\alpha_s) = -2\\,\\alpha_s \\sum_{n=0}^{N-1} \\beta_n \\left(\\frac{\\alpha_s}{4\\pi}\\right)^{n+1}\n$$\n问题规定我们必须对该级数的两种不同截断进行计算：$N=3$ (三圈) 和 $N=4$ (四圈)。对于固定的活性夸克味数 $n_f=5$ 的系数 $\\beta_n$ 已经提供。这个一阶常微分方程 (ODE) 使用初始条件 $\\alpha_s(\\mu_0) = 0.118$ 在 $\\mu_0 = M_Z = 91.1876 \\, \\mathrm{GeV}$ 处进行数值求解。我们使用一个 ODE 求解器，如 `scipy.integrate.solve_ivp`，来获得两个连续的、可插值的耦合函数，$\\alpha_{s,3\\text{-loop}}(\\mu)$ 和 $\\alpha_{s,4\\text{-loop}}(\\mu)$，它们覆盖了测试用例所需的相关标度范围。\n\n接下来，我们定义 Sudakov 辐射子 $R(L;Q)$，它针对一个通用的事件形状对数 $L = \\ln(1/v)$。其定义为：\n$$\nR(L;Q) = 2 \\int_{\\mu_L}^{Q} \\frac{d\\mu'}{\\mu'} \\, \\Gamma_{\\mathrm{cusp}}(\\alpha_s(\\mu')) \\, \\ln\\left(\\frac{Q}{\\mu'}\\right)\n$$\n其中积分下限是软标度 $\\mu_L = Q e^{-L} = Qv$。尖角反常维度 $\\Gamma_{\\mathrm{cusp}}(\\alpha_s)$ 由其三圈展开给出：\n$$\n\\Gamma_{\\mathrm{cusp}}(\\alpha_s) = \\sum_{n=0}^{2} \\Gamma_n \\left(\\frac{\\alpha_s}{4\\pi}\\right)^{n+1}\n$$\n系数 $\\Gamma_n$ 依赖于 QCD 色因子 $C_A=3$、$C_F=4/3$、$T_F=1/2$ 和 $n_f=5$。为了便于数值计算，我们对 $R(L;Q)$ 的积分进行变量替换。令 $t = \\ln \\mu'$，则有 $d\\mu'/\\mu' = dt$，积分变为：\n$$\nR(L;Q) = 2 \\int_{\\ln \\mu_L}^{\\ln Q} dt \\, \\Gamma_{\\mathrm{cusp}}(\\alpha_s(e^t)) \\, (\\ln Q - t)\n$$\n这种形式适合于数值积分，我们使用 `scipy.integrate.quad` 来完成。然后，Sudakov 指数定义为 $S(Q,L) = R(L;Q)$。\n\n最后的可观测量是重求和分布 $D(v;Q)$：\n$$\nD(v;Q) = \\frac{1}{v} \\, \\exp\\left[-R(L;Q)\\right] \\, \\frac{dR(L;Q)}{dL}\n$$\n一个关键步骤是计算导数 $\\frac{dR}{dL}$。对积分进行朴素的数值微分是一个不好的做法。相反，我们可以对 $R(L;Q)$ 的定义应用莱布尼茨积分法则：\n$$\n\\frac{dR}{dL} = \\frac{d}{dL} \\left( 2 \\int_{Q e^{-L}}^{Q} \\frac{d\\mu'}{\\mu'} \\, \\Gamma_{\\mathrm{cusp}}(\\alpha_s(\\mu')) \\, \\ln\\left(\\frac{Q}{\\mu'}\\right) \\right)\n$$\n上限 $Q$ 与 $L$ 无关，因此只有下限有贡献：\n$$\n\\frac{dR}{dL} = -2 \\left( \\frac{d(Q e^{-L})}{dL} \\right) \\frac{1}{Q e^{-L}} \\Gamma_{\\mathrm{cusp}}(\\alpha_s(Q e^{-L})) \\ln\\left(\\frac{Q}{Q e^{-L}}\\right)\n$$\n$$\n\\frac{dR}{dL} = -2 (-Q e^{-L}) \\frac{1}{Q e^{-L}} \\Gamma_{\\mathrm{cusp}}(\\alpha_s(\\mu_L)) \\ln(e^L) = 2 L \\Gamma_{\\mathrm{cusp}}(\\alpha_s(\\mu_L))\n$$\n这个解析结果为计算导数提供了一种直接且高度精确的方法，仅需要在单个标度 $\\mu_L = Qv$ 上评估 $\\alpha_s$。\n\n总的计算流程如下：\n1.  定义所有物理常数（$\\pi$、$\\zeta_3$、色因子）。\n2.  实现计算 $n_f=5$ 的 $\\beta_n$ 和 $\\Gamma_n$ 系数的函数。\n3.  构建三圈和四圈的 $\\beta$-函数以及三圈的 $\\Gamma_{\\mathrm{cusp}}$ 函数。\n4.  从 $\\mu_0 = M_Z$ 处的初始条件数值求解 $\\alpha_s(\\mu)$ 的 RGE，生成两个在所需能量范围内有效的插值函数 $\\alpha_{s,3}$ 和 $\\alpha_{s,4}$。\n5.  对于每个测试用例对 $(Q, v)$：\n    a. 计算 $L=\\ln(1/v)$ 和 $\\mu_L=Qv$。\n    b. 通过数值积分分别包含 $\\alpha_{s,3}(e^t)$ 和 $\\alpha_{s,4}(e^t)$ 的被积函数，计算 $S_3 = R(L;Q)$ 和 $S_4 = R(L;Q)$。\n    c. 计算 $(\\frac{dR}{dL})_3 = 2L \\Gamma_{\\mathrm{cusp}}(\\alpha_{s,3}(\\mu_L))$ 和 $(\\frac{dR}{dL})_4 = 2L \\Gamma_{\\mathrm{cusp}}(\\alpha_{s,4}(\\mu_L))$。\n    d. 计算 $D_3 = \\frac{1}{v} e^{-S_3} (\\frac{dR}{dL})_3$ 和 $D_4 = \\frac{1}{v} e^{-S_4} (\\frac{dR}{dL})_4$。\n    e. 计算差值 $\\Delta S = S_4 - S_3$ 和 $\\Delta D = D_4 - D_3$。\n    f. 将六个结果按指定顺序存储，并四舍五入到六位小数。\n6.  最后，将所有测试用例的收集结果格式化为单行输出。\n这个稳健的流程确保了问题的所有约束都得到满足，并对所研究的理论不确定性提供了精确的量化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate, special\n\ndef solve():\n    \"\"\"\n    Main solver function to compute and print the results as specified.\n    \"\"\"\n    \n    # ------------------ Physical Constants and Coefficients ------------------\n    \n    # Fundamental constants\n    ZETA_3 = special.zeta(3)\n    PI = np.pi\n\n    # QCD parameters\n    NF = 5      # Number of active quark flavors\n    CA = 3.0    # SU(3) Casimir C_A\n    CF = 4.0/3.0  # SU(3) Casimir C_F\n    TF = 0.5    # SU(3) fundamental trace normalization\n\n    # Initial condition for alpha_s running\n    ALPHA_S_MZ = 0.118\n    MU_Z = 91.1876  # GeV\n    \n    # Beta function coefficients for QCD with NF flavors\n    BETA_COEFFS = [\n        11.0 - 2.0/3.0 * NF,\n        102.0 - 38.0/3.0 * NF,\n        2857.0/2.0 - 5033.0/18.0 * NF + 325.0/54.0 * NF**2,\n        (149753.0/6.0 + 3564.0*ZETA_3) - (1078361.0/162.0 + 6508.0/27.0*ZETA_3) * NF \n        + (50065.0/162.0 + 6472.0/81.0*ZETA_3) * NF**2 + 1093.0/729.0 * NF**3,\n    ]\n\n    # Cusp anomalous dimension coefficients\n    GAMMA_COEFFS = [\n        4.0 * CF,\n        4.0 * CF * ((67.0/9.0 - PI**2/3.0) * CA - 20.0/9.0 * TF * NF),\n        4.0 * CF * (\n            CA**2 * (245.0/6.0 - 134.0*PI**2/27.0 + 11.0*PI**4/45.0 + 22.0/3.0*ZETA_3)\n            + CA * TF * NF * (-418.0/27.0 + 40.0*PI**2/27.0 - 56.0/3.0*ZETA_3)\n            + CF * TF * NF * (-55.0/3.0 + 16.0*ZETA_3)\n            - 16.0/27.0 * TF**2 * NF**2\n        ),\n    ]\n\n    # ------------------ Physics Functions ------------------\n\n    def beta_func(alpha_s, n_loops):\n        \"\"\"QCD beta function up to n_loops.\"\"\"\n        term = 0.0\n        for i in range(n_loops):\n            term += BETA_COEFFS[i] * (alpha_s / (4*PI))**(i+1)\n        return -2.0 * alpha_s * term\n\n    def gamma_cusp_func(alpha_s):\n        \"\"\"3-loop cusp anomalous dimension.\"\"\"\n        res = 0.0\n        for i in range(len(GAMMA_COEFFS)):\n            res += GAMMA_COEFFS[i] * (alpha_s / (4.0 * PI))**(i + 1)\n        return res\n\n    def get_alpha_s_solver(n_loops):\n        \"\"\"Returns an interpolating function for alpha_s(mu).\"\"\"\n        def RGE_dalpha_dlnmu(ln_mu, alpha_s):\n            return beta_func(alpha_s, n_loops)\n\n        # Determine scale range for ODE solver\n        min_mu, max_mu = 1.0, 150.0 # Safe range covering all test cases\n        ln_mu0 = np.log(MU_Z)\n        \n        # We solve from mu_Z to both lower and higher scales\n        sol_down = integrate.solve_ivp(\n            RGE_dalpha_dlnmu, \n            (ln_mu0, np.log(min_mu)), \n            [ALPHA_S_MZ],\n            dense_output=True, \n            rtol=1e-10, atol=1e-12\n        )\n        sol_up = integrate.solve_ivp(\n            RGE_dalpha_dlnmu, \n            (ln_mu0, np.log(max_mu)), \n            [ALPHA_S_MZ],\n            dense_output=True, \n            rtol=1e-10, atol=1e-12\n        )\n        \n        def alpha_s_interpolated(mu):\n            ln_mu = np.log(mu)\n            if ln_mu  ln_mu0:\n                return sol_down.sol(ln_mu)[0]\n            else:\n                return sol_up.sol(ln_mu)[0]\n\n        return alpha_s_interpolated\n\n    # ------------------ Main Calculation Logic ------------------\n\n    def process_case(Q, v, alpha_s_func):\n        \"\"\"Calculates S and D for a single test case and alpha_s function.\"\"\"\n        L = np.log(1.0 / v)\n        mu_L = Q * v\n\n        # Calculate Sudakov exponent S = R(L, Q)\n        def integrand_R(ln_mu, Q_val, alpha_s_solver):\n            mu = np.exp(ln_mu)\n            alpha_s = alpha_s_solver(mu)\n            return 2.0 * gamma_cusp_func(alpha_s) * (np.log(Q_val) - ln_mu)\n        \n        ln_mu_L = np.log(mu_L)\n        ln_Q = np.log(Q)\n\n        # The integration can result in 0 if limits are equal.\n        if np.isclose(ln_mu_L, ln_Q):\n            S = 0.0\n        else:\n            S, _ = integrate.quad(\n                integrand_R, ln_mu_L, ln_Q, \n                args=(Q, alpha_s_func),\n                epsabs=1e-12, epsrel=1e-10\n            )\n\n        # Calculate dR/dL\n        alpha_s_at_mu_L = alpha_s_func(mu_L)\n        dR_dL = 2.0 * L * gamma_cusp_func(alpha_s_at_mu_L)\n\n        # Calculate distribution D(v, Q)\n        D = (1.0 / v) * np.exp(-S) * dR_dL\n        \n        return S, D\n\n    # ------------------ Execution Flow ------------------\n    \n    # Get alpha_s solvers for 3-loop and 4-loop running\n    alpha_s_3loop = get_alpha_s_solver(n_loops=3)\n    alpha_s_4loop = get_alpha_s_solver(n_loops=4)\n\n    test_cases = [\n        (91.1876, 0.1),  # Test 1\n        (30.0, 0.1),     # Test 2\n        (91.1876, 0.9),  # Test 3\n        (30.0, 0.3),     # Test 4\n    ]\n\n    all_results = []\n    for Q_val, v_val in test_cases:\n        S3, D3 = process_case(Q_val, v_val, alpha_s_3loop)\n        S4, D4 = process_case(Q_val, v_val, alpha_s_4loop)\n        \n        delta_S = S4 - S3\n        delta_D = D4 - D3\n        \n        case_results = [delta_S, delta_D, S3, S4, D3, D4]\n        \n        rounded_results = [round(x, 6) for x in case_results]\n        all_results.append(f\"[{','.join(map(str, rounded_results))}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3531739"}]}