{"hands_on_practices": [{"introduction": "在单圈积分的数值计算中，一个核心挑战来自于项的相消。尤其是在使用 Passarino-Veltman (PV) 方法进行张量约化时，最终的系数常常是多个巨大项之间精确相消后得到的微小余项。此练习 [@problem_id:3525479] 旨在揭示在浮点数运算中，朴素求和法如何导致灾难性的精度损失，并量化展示成对求和 (pairwise summation) 与卡汗补偿求和 (Kahan compensated summation) 等算法的优越性。通过处理模拟真实物理场景中相消模式的数值序列，您将深入理解为何高级求和技术是确保计算结果可靠性的必要工具，而非仅仅是学术上的探讨。", "problem": "考虑在相空间点上的单圈积分中，对张量系数贡献的数值聚合问题。在许多由单圈积分的 Passarino–Veltman (PV) 张量约化产生的情况下，会出现大数值项的近似抵消，最终的系数是这些抵消后得到的微小残差。设这些贡献为建模成序列 $\\{x_i\\}_{i=1}^N$ 的实数，求和以产生部分张量系数 $S = \\sum_{i=1}^N x_i$。在浮点运算中，数值求和的稳定性在很大程度上取决于求和算法。\n\n我们将比较并量化两种补偿求和策略相对于朴素求和的数值优势：\n- 朴素求和：按遇到顺序直接累加 $s \\leftarrow s + x_i$。\n- 成对求和：一种平衡二叉树求和方法，重复地对相邻对求和以减少动态范围效应。\n- Kahan 补偿求和：一种补偿算法，维护一个误差累加器以减少低位比特的损失。\n\n在双精度（IEEE 754 binary64）算术下工作，其有效数为 $p = 53$ 位。为进行精度评估，定义算法的绝对误差为 $e = |S_{\\text{alg}} - S_{\\text{true}}|$，其中 $S_{\\text{alg}}$ 是计算出的双精度和，$S_{\\text{true}}$ 是精确有理数和 $\\sum_i x_i$ 的正确舍入双精度值。定义归一化如下：\n- 如果 $|S_{\\text{true}}| > 0$，使用相对误差 $r = e / |S_{\\text{true}}|$。\n- 如果 $S_{\\text{true}} = 0$，使用标度 $L_1 = \\sum_{i=1}^N |x_i|$ 并取 $r = e / L_1$。\n由 $r$ 定义正确比特数为 $b = -\\log_2(r)$（对于 $r > 0$），损失的比特数（相对于 53 位有效数）为 $\\ell = \\max(0,\\, p - b)$。如果 $r = 0$，则设 $\\ell = 0$。\n\n请实现这三种求和算法，并报告每种算法在以下四个科学上合理的测试用例上的 $\\ell$ 值。这些测试用例模拟了在 PV 约化和相空间采样后，数值计算张量系数时遇到的近似抵消模式。在所有情况下，$x_i$ 都应构造成在可能时能用二进制浮点精确表示的有理数（即整数和 2 的负整数次幂），以便获得精确的有理数基准真相。序列定义必须严格遵守。\n\n测试套件：\n- 用例 A（具有缓慢变化偏移量的中等程度交替抵消）：设 $N = 20000$ 并定义\n  $$x_i = (-1)^i\\left(2^{-20} + (i+1)2^{-44}\\right), \\quad i = 0,1,\\dots,N-1.$$\n  这模拟了交替的大贡献项和一个小的、缓慢变化的项，最终产生一个非零残差。\n- 用例 B（通过交错大小项导致的灾难性局部抵消）：设 $M = 8000$，并创建一个重复 $M$ 次的三元组模式：\n  $$\\{2^{30},\\, 2^{-40},\\, -2^{30}\\}.$$\n  每个三元组的精确和为 $2^{-40}$，但按遇到顺序的朴素求和在紧随 $2^{30}$ 之后加上 $2^{-40}$ 时会导致严重的精度损失。\n- 用例 C（具有动态范围和对抗性顺序的精确零和）：设 $M = 7000$，并创建一个重复 $M$ 次的四元组模式：\n  $$\\{2^{30},\\, 2^{-45},\\, -2^{30},\\, -2^{-45}\\}.$$\n  精确和为 $0$，但朴素顺序下的舍入行为可能累积一个非零残差。\n- 用例 D（具有小残差的可变大尺度）：设 $M = 6000$，对 $k = 1,2,\\dots,M$ 创建三元组\n  $$\\{2^{25} + k,\\, 2^{-50},\\, -(2^{25} + k)\\}.$$\n  每个三元组的精确和为 $2^{-50}$，用于测试在不同大数值下的稳定性。\n\n要求：\n- 将序列 $\\{x_i\\}$ 构造成使用整数和 2 的负整数次幂的精确有理数值。计算精确的有理数和 $S_{\\text{exact}} = \\sum_i x_i$。然后将 $S_{\\text{true}}$ 设置为 $S_{\\text{exact}}$ 的正确舍入双精度值。\n- 实现：\n  1. 朴素求和：按序列顺序 $s \\leftarrow s + x_i$。\n  2. 成对求和：以平衡树方式重复对相邻对求和，直到剩下一个值。\n  3. Kahan 补偿求和：使用补偿变量 $c$，通过 $y = x_i - c$，$t = s + y$，$c = (t - s) - y$，$s = t$ 进行更新。\n- 对每种方法在每个用例中，使用上述定义计算损失的比特数 $\\ell$。如果 $S_{\\text{true}} = 0$，则使用上述的 $L_1$ 归一化。将 $\\ell$ 报告为浮点数。\n\n最终输出格式：\n- 您的程序应生成一行输出，包含一个用方括号括起来的逗号分隔列表，其中每个测试用例贡献一个三元素列表，顺序为 [naive, pairwise, kahan]。因此，最终输出必须是一个包含四个内部列表的单一列表：\n  $$\\text{Output} = [[\\ell_{\\text{naive,A}},\\ell_{\\text{pairwise,A}},\\ell_{\\text{kahan,A}}], [\\ell_{\\text{naive,B}},\\ell_{\\text{pairwise,B}},\\ell_{\\text{kahan,B}}], [\\ell_{\\text{naive,C}},\\ell_{\\text{pairwise,C}},\\ell_{\\text{kahan,C}}], [\\ell_{\\text{naive,D}},\\ell_{\\text{pairwise,D}},\\ell_{\\text{kahan,D}}]].$$\n不涉及物理单位或角度；数值必须报告为无量纲浮点数。", "solution": "在 Passarino–Veltman (PV) 张量约化之后，对单圈积分的张量系数贡献进行求和的核心数值问题，源于组合大的、几乎抵消的项时发生的浮点舍入。相空间积分可能产生序列 $\\{x_i\\}$，其中 $x_i$ 数值大且符号交替，而所需的系数是微小的残差。这要求采用精细的数值求和方法。\n\n浮点算术原理：\n- IEEE 754 binary64 的有效数有 $p = 53$ 位。设机器 ε 的相对大小约为 $2^{-53}$。\n- 朴素求和 $s \\leftarrow s + x_i$ 会累积舍入误差。当加数的数量级差异巨大时，较小的项可能会被完全吞噬（其最低有效位消失），当后续减法揭示丢失的信息时，这种现象被称为灾难性抵消。\n- 成对求和通过首先对数量级相似的数求和来减少误差增长，从而减轻了中间值的动态范围。\n- Kahan 补偿求和增加了一个校正项 $c$ 来结转舍入残差，捕获丢失的低位比特，并在后续加法中重新注入它们。\n\n精度度量设计：\n给定一个算法在双精度下的输出 $S_{\\text{alg}}$ 和定义为精确有理数和 $S_{\\text{exact}} = \\sum_i x_i$ 的正确舍入双精度值的基准真相 $S_{\\text{true}}$，定义绝对误差 $e = |S_{\\text{alg}} - S_{\\text{true}}|$。我们按如下方式对误差进行归一化：\n- 如果 $|S_{\\text{true}}| > 0$，使用 $r = e / |S_{\\text{true}}|$。\n- 如果 $S_{\\text{true}} = 0$，使用标度 $L_1 = \\sum_i |x_i|$ 并设 $r = e / L_1$。这反映了对于一个真实和为零的情况，绝对误差必须与一个有意义的标度进行比较，以避免除以零并反映问题的条件数。\n由 $r$ 定义正确比特数为 $b = -\\log_2(r)$（对于 $r > 0$）。将 binary64 解释为在有效数中提供 $p = 53$ 位，则损失的比特数为 $\\ell = \\max(0, p - b)$。如果 $r = 0$，则设 $\\ell = 0$。该度量量化了相对于理想的最佳舍入双精度结果，有效损失了多少位精度。\n\n算法细节：\n- 朴素求和实现为一个简单的循环，按输入顺序累加一个运行总和。它对输入顺序和动态范围敏感。\n- 成对求和执行一个平衡二叉树约简。相邻的对被相加以形成一个新的、更短的列表，此过程重复进行，直到只剩下一个值。这使得中间和的量级与输入更接近，降低了舍入误差的增长，尤其是在对抗性排序中。\n- Kahan 补偿求和维护一个补偿项 $c$，用于捕获每次加法时的舍入误差。对每个 $x_i$，我们计算 $y = x_i - c$ 和 $t = s + y$，然后更新 $c = (t - s) - y$ 和 $s = t$。该策略恢复了许多丢失的低位比特。\n\n有理数基准真相：\n为避免用浮点舍入污染基准真相，我们使用精确有理数来构建测试序列：整数和 2 的幂次可以产生在二进制浮点中精确表示的值。使用精确有理数算术（例如，分数），我们精确计算 $S_{\\text{exact}}$。然后我们通过正确舍入将 $S_{\\text{exact}}$ 转换为双精度以获得 $S_{\\text{true}}$。这确保我们只测量由求和引起的误差，而不是最终格式中的表示误差。\n\n测试套件原理：\n- 用例 A 使用 $x_i = (-1)^i(2^{-20} + (i+1)2^{-44})$，其中 $i = 0, \\dots, 19999$。$2^{-20}$ 项交替并大部分抵消；$(i+1)2^{-44}$ 项缓慢变化并产生一个小的残差，模拟了在张量约化中一个主导的交替结构与一个温和的净漂移共存的常见情况。\n- 用例 B 使用重复的三元组 $\\{2^{30}, 2^{-40}, -2^{30}\\}$。每个三元组的真实和是 $2^{-40}$。在 $2^{30}$ 之后立即进行朴素加法 $2^{-40}$ 会损失低位比特，因为 $2^{-40} \\ll \\varepsilon \\cdot 2^{30} \\approx 2^{30}2^{-53} = 2^{-23}$。成对求和在加上 $2^{-40}$ 之前有效地将 $2^{30}$ 与 $-2^{30}$ 分组，从而保留了小的残差。Kahan 补偿求和也通过补偿恢复了丢失的比特。\n- 用例 C 使用重复的四元组 $\\{2^{30}, 2^{-45}, -2^{30}, -2^{-45}\\}$，其和恰好为零。当在 $2^{30}$ 之后加上 $2^{-45}$ 时，该顺序会导致 $2^{-45}$ 的贡献丢失，而后来的 $-2^{-45}$ 加法在朴素求和中可能产生一个非零残差。由于 $S_{\\text{true}} = 0$，我们用 $L_1$ 进行归一化。\n- 用例 D 使用具有三元组 $\\{2^{25} + k, 2^{-50}, -(2^{25} + k)\\}$ 的可变大尺度，其中 $k = 1, \\dots, 6000$。这测试了算法在不同的大量级下局部抵消并留下小残差时的鲁棒性。\n\n实现计划：\n- 将每个测试用例生成为一个精确有理数列表。计算它们对应的双精度值用于求和。\n- 实现三种求和方法。\n- 通过精确求和有理数并转换为双精度来计算 $S_{\\text{true}}$。\n- 精确计算 $L_1$ 并转换为双精度。\n- 使用上述定义为每种方法计算损失的比特数。\n- 生成单行输出：一个包含四个内部列表的列表，每个列表包含三个浮点数，顺序为 [naive, pairwise, kahan]。\n\n此过程清晰地分离了算法求和误差与表示误差，并对在计算高能物理中遇到的近似抵消的张量系数贡献情景下，补偿求和方法进行了严谨的定量比较。", "answer": "```python\nimport math\nfrom fractions import Fraction\n\ndef naive_sum(arr):\n    s = 0.0\n    for x in arr:\n        s += x\n    return s\n\ndef pairwise_sum(arr):\n    # Balanced binary-tree summation without sorting\n    n = len(arr)\n    if n == 0:\n        return 0.0\n    work = arr[:]\n    while len(work)  1:\n        new_work = []\n        it = iter(work)\n        for a in it:\n            try:\n                b = next(it)\n                new_work.append(a + b)\n            except StopIteration:\n                new_work.append(a)\n        work = new_work\n    return work[0]\n\ndef kahan_sum(arr):\n    s = 0.0\n    c = 0.0\n    for x in arr:\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef bits_lost(computed, true_value, l1_scale, significand_bits=53):\n    error = abs(computed - true_value)\n    if abs(true_value)  0.0:\n        ratio = error / abs(true_value)\n    else:\n        ratio = (error / l1_scale) if l1_scale  0.0 else 0.0\n    if ratio == 0.0:\n        return 0.0\n    bits_correct = -math.log2(ratio)\n    lost = significand_bits - bits_correct\n    if lost  0.0:\n        lost = 0.0\n    return lost\n\ndef case_A():\n    # N = 20000, x_i = (-1)^i (2^-20 + (i+1) 2^-44), i = 0..N-1\n    N = 20000\n    exact = []\n    for i in range(N):\n        sign = 1 if (i % 2 == 0) else -1\n        term = Fraction(1, 2**20) + Fraction(i + 1, 2**44)\n        exact.append(sign * term)\n    floats = [float(x) for x in exact]\n    true_exact = sum(exact, Fraction(0, 1))\n    true_val = float(true_exact)\n    l1_exact = sum((abs(x) for x in exact), Fraction(0, 1))\n    l1_val = float(l1_exact)\n    return floats, true_val, l1_val\n\ndef case_B():\n    # M = 8000, triads {2^30, 2^-40, -2^30}\n    M = 8000\n    exact = []\n    for _ in range(M):\n        exact.append(Fraction(2**30, 1))\n        exact.append(Fraction(1, 2**40))\n        exact.append(Fraction(-2**30, 1))\n    floats = [float(x) for x in exact]\n    true_exact = sum(exact, Fraction(0, 1))\n    true_val = float(true_exact)\n    l1_exact = sum((abs(x) for x in exact), Fraction(0, 1))\n    l1_val = float(l1_exact)\n    return floats, true_val, l1_val\n\ndef case_C():\n    # M = 7000, quads {2^30, 2^-45, -2^30, -2^-45}; true sum = 0\n    M = 7000\n    exact = []\n    for _ in range(M):\n        exact.append(Fraction(2**30, 1))\n        exact.append(Fraction(1, 2**45))\n        exact.append(Fraction(-2**30, 1))\n        exact.append(Fraction(-1, 2**45))\n    floats = [float(x) for x in exact]\n    true_exact = sum(exact, Fraction(0, 1))\n    true_val = float(true_exact)\n    l1_exact = sum((abs(x) for x in exact), Fraction(0, 1))\n    l1_val = float(l1_exact)\n    return floats, true_val, l1_val\n\ndef case_D():\n    # M = 6000, triads {2^25 + k, 2^-50, -(2^25 + k)}, k=1..M\n    M = 6000\n    exact = []\n    for k in range(1, M + 1):\n        H = Fraction(2**25 + k, 1)\n        exact.append(H)\n        exact.append(Fraction(1, 2**50))\n        exact.append(-H)\n    floats = [float(x) for x in exact]\n    true_exact = sum(exact, Fraction(0, 1))\n    true_val = float(true_exact)\n    l1_exact = sum((abs(x) for x in exact), Fraction(0, 1))\n    l1_val = float(l1_exact)\n    return floats, true_val, l1_val\n\ndef solve():\n    # Generate test cases\n    test_cases = [case_A(), case_B(), case_C(), case_D()]\n    results = []\n    for floats, true_val, l1_val in test_cases:\n        # Compute sums\n        s_naive = naive_sum(floats)\n        s_pair = pairwise_sum(floats)\n        s_kahan = kahan_sum(floats)\n        # Compute bits lost\n        b_naive = bits_lost(s_naive, true_val, l1_val)\n        b_pair = bits_lost(s_pair, true_val, l1_val)\n        b_kahan = bits_lost(s_kahan, true_val, l1_val)\n        results.append([b_naive, b_pair, b_kahan])\n    # Print final output in required format\n    # Single line: list of four inner lists [naive, pairwise, kahan] for each case\n    print(f\"[{','.join(str(lst) for lst in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3525479"}, {"introduction": "理论计算的可靠性不仅取决于内部的数值精度，还依赖于输入参数的准确性。在粒子物理学中，运动学不变量（如 $s$ 和 $t$）源于实验测量，不可避免地带有不确定性。此练习 [@problem_id:3525497] 将指导您量化这种输入不确定性如何传播到 Passarino-Veltman (PV) 系数中。您将通过数值积分和有限差分方法计算系数向量关于运动学不变量的雅可比矩阵，从而评估最终结果对输入误差的敏感度，并估算最坏情况下的误差放大效应。这是连接理论预测与实验现实、评估计算结果置信度的关键一步。", "problem": "考虑一个具有无质量外腿和相等内线质量的单圈积分的秩-1 Passarino–Veltman (PV) 三角张量约化。设运动学不变量为序对 $\\mathbf{k} = (s,t)$，单位为 $\\mathrm{GeV}^2$，其中 $u$ 由动量守恒确定为 $u = -s - t$。定义相等的内线质量参数 $m^2$，单位为 $\\mathrm{GeV}^2$。使用费曼参数，引入分母\n$$\n\\Delta(x,y;s,t,m^2) = m^2 - s\\,x\\,y - t\\,y\\,(1-x-y) - u\\,x\\,(1-x-y),\n$$\n其中 $(x,y)$ 位于标准三角域 $\\{(x,y)\\,|\\,0 \\le x \\le 1,\\; 0 \\le y \\le 1-x\\}$ 内，且 $u = -s - t$。用于秩-1 约化的 PV 张量矩系数可由以下参数矩积分表示：\n$$\nC_0(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{1}{\\Delta(x,y;s,t,m^2)},\n$$\n$$\nC_1(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{x}{\\Delta(x,y;s,t,m^2)},\n$$\n$$\nC_2(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{y}{\\Delta(x,y;s,t,m^2)}.\n$$\n这些积分以一种数学上受控的方式，模拟了秩-1 PV 系数对运动学不变量的依赖关系。假设在分母中加入一个小的正调节子 $\\varepsilon$ 以确保数值稳定性，即用 $\\Delta + \\varepsilon$ 替换 $\\Delta$，其中 $\\varepsilon$ 的单位为 $\\mathrm{GeV}^2$，且其值与物理尺度相比小到可以忽略不计。\n\n假设不变量 $\\mathbf{k} = (s,t)$ 的测量带有不确定度 $(\\delta s, \\delta t)$，二者单位均为 $\\mathrm{GeV}^2$。系数向量 $\\mathbf{C} = (C_0,C_1,C_2)$ 关于不变量的雅可比矩阵是一个 $3 \\times 2$ 矩阵\n$$\nJ(\\mathbf{k}) =\n\\begin{bmatrix}\n\\frac{\\partial C_0}{\\partial s}  \\frac{\\partial C_0}{\\partial t} \\\\\n\\frac{\\partial C_1}{\\partial s}  \\frac{\\partial C_1}{\\partial t} \\\\\n\\frac{\\partial C_2}{\\partial s}  \\frac{\\partial C_2}{\\partial t}\n\\end{bmatrix}.\n$$\n对于小的不确定度，线性误差传播给出 $\\delta \\mathbf{C} \\approx J(\\mathbf{k})\\,\\delta \\mathbf{k}$，并且最坏情况下的放大因子（在欧几里得范数下）受 $J$ 的诱导算子 2-范数所约束，即：\n$$\n\\|\\delta \\mathbf{C}\\|_2 \\le \\|J(\\mathbf{k})\\|_2 \\,\\|\\delta \\mathbf{k}\\|_2,\n$$\n其中 $\\|J(\\mathbf{k})\\|_2$ 是 $J(\\mathbf{k})$ 的最大奇异值，$\\|\\cdot\\|_2$ 表示欧几里得范数。量 $\\|\\delta \\mathbf{C}\\|_2$ 的单位是 $\\mathrm{GeV}^{-2}$。\n\n任务：从费曼参数表示和诱导范数的定义出发，设计并实现一个程序，该程序能够：\n- 通过在参数域上使用稳健的求积方法，对带有调节子分母 $\\Delta + \\varepsilon$ 的 $C_0(s,t;m^2)$、$C_1(s,t;m^2)$ 和 $C_2(s,t;m^2)$ 进行数值计算。\n- 使用中心有限差分法在 $s$ 和 $t$ 上近似雅可比矩阵 $J(\\mathbf{k})$，并选择合适的步长以平衡截断误差和舍入误差。\n- 通过奇异值分解计算诱导算子 2-范数 $\\|J(\\mathbf{k})\\|_2$。\n- 对于每个测试用例，返回两个浮点数：最坏情况下的界限 $B = \\|J(\\mathbf{k})\\|_2 \\,\\sqrt{(\\delta s)^2 + (\\delta t)^2}$ 和线性估计 $L = \\|J(\\mathbf{k})\\,(\\delta s,\\delta t)\\|_2$，两者均以 $\\mathrm{GeV}^{-2}$ 为单位，并由默认的浮点表示法进行舍入。\n\n使用以下测试套件，其中所有量的单位均为 $\\mathrm{GeV}^2$：\n- 案例 1 (一般情况)：$s = 1.0$, $t = 0.5$, $m^2 = 1.0$, $(\\delta s, \\delta t) = (1.0\\times 10^{-3}, 2.0\\times 10^{-3})$。\n- 案例 2 (近似抵消)：$s = 2.0$, $t = -1.2$, $m^2 = 1.0$, $(\\delta s, \\delta t) = (5.0\\times 10^{-4}, 5.0\\times 10^{-4})$。\n- 案例 3 (小不变量)：$s = 0.05$, $t = -0.02$, $m^2 = 1.0$, $(\\delta s, \\delta t) = (1.0\\times 10^{-4}, 1.0\\times 10^{-4})$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应一个测试用例的序对 $[B,L]$。例如，输出格式必须为 $[[B_1,L_1],[B_2,L_2],[B_3,L_3]]$，所有量的单位均为 $\\mathrm{GeV}^{-2}$。", "solution": "该问题是有效的，因为它提出了一个自洽的、有科学依据且适定的计算任务。它要求对一组单圈积分系数进行数值评估，并分析它们对运动学参数的敏感性。所提供的与高能物理中的 Passarino-Veltman 约化相关的物理背景是合理的，其数学表述是精确且无歧义的。该问题通过设计一个结合了数值求积、有限差分微分和奇异值分解的算法来解决。\n\n问题的核心是确定系数向量 $\\mathbf{C} = (C_0, C_1, C_2)$ 对运动学不变量 $\\mathbf{k} = (s, t)$ 变化的敏感性。这种敏感性由雅可比矩阵 $J(\\mathbf{k})$ 体现。分析过程依赖于几个不同的计算步骤。\n\n首先，我们必须定义向量函数 $\\mathbf{C}(s,t; m^2)$，其分量由以下积分表达式给出：\n$$ C_0(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{1}{\\Delta_{reg}(x,y;s,t,m^2,\\varepsilon)} $$\n$$ C_1(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{x}{\\Delta_{reg}(x,y;s,t,m^2,\\varepsilon)} $$\n$$ C_2(s,t;m^2) = \\int_{0}^{1} \\mathrm{d}x \\int_{0}^{1-x} \\mathrm{d}y \\,\\frac{y}{\\Delta_{reg}(x,y;s,t,m^2,\\varepsilon)} $$\n分母 $\\Delta_{reg}$ 是函数 $\\Delta(x,y;s,t,m^2) = m^2 - s\\,x\\,y - t\\,y\\,(1-x-y) - u\\,x\\,(1-x-y)$（其中 $u = -s - t$）加上一个小的正调节子 $\\varepsilon$ 以防止除以零并确保数值稳定性。积分在由 $0 \\le x \\le 1$ 和 $0 \\le y \\le 1-x$ 定义的二维单形域上进行。这些二重积分使用稳健的求积方法进行数值计算，具体来说是 `scipy.integrate` 库中的 `dblquad` 函数。该函数在指定域上执行迭代积分。\n\n其次，必须计算 $3 \\times 2$ 的雅可比矩阵 $J(\\mathbf{k})$。其元素是偏导数 $\\frac{\\partial C_i}{\\partial s}$ 和 $\\frac{\\partial C_i}{\\partial t}$（其中 $i \\in \\{0, 1, 2\\}$）。由于对积分进行解析微分是繁琐的，我们使用中心有限差分法来近似这些导数。该方法在截断误差和舍入误差之间提供了良好的平衡。雅可比矩阵的两列计算如下：\n$$ \\frac{\\partial \\mathbf{C}}{\\partial s} \\approx \\frac{\\mathbf{C}(s+h, t) - \\mathbf{C}(s-h, t)}{2h} $$\n$$ \\frac{\\partial \\mathbf{C}}{\\partial t} \\approx \\frac{\\mathbf{C}(s, t+h) - \\mathbf{C}(s, t-h)}{2h} $$\n在这里，$\\mathbf{C}(s,t)$ 是为给定的 $(s,t)$ 计算 $(C_0, C_1, C_2)$ 的向量函数，而 $h$ 是一个小步长，对于双精度计算，其选择在 $10^{-6}$ 的量级。每个偏导数向量的计算都需要两次调用数值积分程序。\n\n第三，我们确定最坏情况下的不确定度放大因子，它由雅可比矩阵的诱导算子 2-范数 $\\|J(\\mathbf{k})\\|_2$ 给出。此范数等价于矩阵 $J$ 的最大奇异值。我们使用奇异值分解 (SVD)（如 `numpy.linalg.svd` 中所实现的）来计算数值上获得的 $3 \\times 2$ 雅可比矩阵的奇异值。最大值 $\\sigma_{max}$ 给出 $\\|J(\\mathbf{k})\\|_2$。\n\n最后，当所有组件都准备就绪后，我们为每个测试用例计算两个所需的量。设不确定度向量为 $\\delta\\mathbf{k} = (\\delta s, \\delta t)^T$。\n1.  最坏情况下的不确定度界限 $B$，计算为雅可比矩阵的 2-范数与输入不确定度向量的欧几里得范数的乘积：\n    $$ B = \\|J(\\mathbf{k})\\|_2 \\|\\delta \\mathbf{k}\\|_2 = \\sigma_{max} \\sqrt{(\\delta s)^2 + (\\delta t)^2} $$\n2.  输出不确定度大小的线性估计 $L$，是将雅可比矩阵应用于输入不确定度向量所得到的向量的欧几里得范数：\n    $$ L = \\|J(\\mathbf{k}) \\delta \\mathbf{k}\\|_2 $$\n这涉及矩阵-向量乘积，然后是向量范数计算。\n\n这整个过程被封装在一个程序中，该程序遍历提供的测试用例，为每组参数 $(s, t, m^2, \\delta s, \\delta t)$ 执行数值计算，并将最终的 $(B, L)$ 对格式化为指定的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating error propagation bounds for one-loop\n    tensor integral coefficients.\n    \"\"\"\n    # Define problem constants and numerical parameters\n    # Small positive regulator ε to ensure numerical stability\n    REGULATOR_EPS = 1e-12\n    # Step size h for central finite differences\n    FD_STEP = 1e-6\n\n    # Define the test cases from the problem statement. All units are GeV^2.\n    test_cases = [\n        # (s, t, m^2, δs, δt)\n        # Case 1 (general case)\n        {'s': 1.0, 't': 0.5, 'm2': 1.0, 'ds': 1.0e-3, 'dt': 2.0e-3},\n        # Case 2 (near-cancellation)\n        {'s': 2.0, 't': -1.2, 'm2': 1.0, 'ds': 5.0e-4, 'dt': 5.0e-4},\n        # Case 3 (small invariants)\n        {'s': 0.05, 't': -0.02, 'm2': 1.0, 'ds': 1.0e-4, 'dt': 1.0e-4},\n    ]\n\n    def get_denominator(x, y, s, t, m2, eps):\n        \"\"\"\n        Calculates the regulated denominator Δ(x, y; s, t, m^2) + ε.\n        The variable u is fixed by u = -s - t.\n        \"\"\"\n        u = -s - t\n        delta = m2 - s * x * y - t * y * (1 - x - y) - u * x * (1 - x - y)\n        return delta + eps\n\n    def compute_C_vector(s, t, m2, eps):\n        \"\"\"\n        Numerically evaluates the coefficient vector C = [C0, C1, C2] using\n        2D numerical quadrature (scipy.integrate.dblquad).\n        \n        Note: dblquad integrates f(y, x), so the integrand must have y as the\n        first argument, followed by x. The integration limits are y from 0 to 1-x,\n        and x from 0 to 1.\n        \"\"\"\n        args = (s, t, m2, eps)\n        \n        # Integrand for C0\n        integrand0 = lambda y, x, *a: 1.0 / get_denominator(x, y, *a)\n        c0, _ = integrate.dblquad(integrand0, 0, 1, lambda x: 0, lambda x: 1 - x, args=args)\n        \n        # Integrand for C1\n        integrand1 = lambda y, x, *a: x / get_denominator(x, y, *a)\n        c1, _ = integrate.dblquad(integrand1, 0, 1, lambda x: 0, lambda x: 1 - x, args=args)\n        \n        # Integrand for C2\n        integrand2 = lambda y, x, *a: y / get_denominator(x, y, *a)\n        c2, _ = integrate.dblquad(integrand2, 0, 1, lambda x: 0, lambda x: 1 - x, args=args)\n        \n        return np.array([c0, c1, c2])\n\n    results = []\n    for case in test_cases:\n        s, t, m2, ds, dt = case['s'], case['t'], case['m2'], case['ds'], case['dt']\n        h = FD_STEP\n\n        # Step 1: Approximate the Jacobian J using central finite differences.\n        # Column 1: dC/ds\n        C_plus_s = compute_C_vector(s + h, t, m2, REGULATOR_EPS)\n        C_minus_s = compute_C_vector(s - h, t, m2, REGULATOR_EPS)\n        dC_ds = (C_plus_s - C_minus_s) / (2 * h)\n\n        # Column 2: dC/dt\n        C_plus_t = compute_C_vector(s, t + h, m2, REGULATOR_EPS)\n        C_minus_t = compute_C_vector(s, t - h, m2, REGULATOR_EPS)\n        dC_dt = (C_plus_t - C_minus_t) / (2 * h)\n        \n        # Construct the 3x2 Jacobian matrix\n        J = np.stack((dC_ds, dC_dt), axis=1)\n\n        # Step 2: Compute the induced 2-norm of J (largest singular value).\n        singular_values = np.linalg.svd(J, compute_uv=False)\n        norm_J_2 = singular_values[0]\n\n        # Step 3: Calculate the uncertainty bound B and linear estimate L.\n        delta_k = np.array([ds, dt])\n        \n        # Worst-case bound B\n        norm_delta_k_2 = np.linalg.norm(delta_k)\n        B = norm_J_2 * norm_delta_k_2\n\n        # Linear estimate L\n        delta_C = J @ delta_k\n        L = np.linalg.norm(delta_C)\n        \n        results.append((B, L))\n\n    # Final print statement in the exact required format.\n    res_strings = [f\"[{b},{l}]\" for b, l in results]\n    print(f\"[{','.join(res_strings)}]\")\n\nsolve()\n```", "id": "3525497"}, {"introduction": "张量约化的过程通常可以归结为求解一个大规模的线性方程组 $\\mathbf{A}\\mathbf{c} = \\mathbf{b}$。数值求解器给出的近似解 $\\hat{\\mathbf{c}}$ 质量如何？一个容易计算的量是残差 $\\mathbf{r} = \\mathbf{b} - \\mathbf{A}\\hat{\\mathbf{c}}$，但一个很小的残差并不总能保证解的误差 $\\hat{\\mathbf{c}} - \\mathbf{c}^{\\star}$ 也很小。此练习 [@problem_id:3525516] 将引导您推导并实现一个严格的、基于残差的误差估计器，它利用残差的范数和矩阵 $\\mathbf{A}$ 的逆的范数来为解的误差提供一个可计算的上限。这个实践揭示了系统矩阵的条件数在误差放大中的关键作用，为您提供了一个强大的、无需知道精确解的后验误差估计工具，以检验张量约化过程的数值稳定性。", "problem": "考虑一个单圈张量约化，其中分子项在一组标量主积分基中表示。在一组有限条件（例如，张量结构或采样配置）下投影到该基上后，标量主积分的系数向量 $\\mathbf{c} \\in \\mathbb{R}^{m}$ 通过求解线性系统 $\\mathbf{A}\\mathbf{c} = \\mathbf{b}$ 来确定，其中 $\\mathbf{A} \\in \\mathbb{R}^{m \\times m}$ 是由投影构建的系数矩阵，而 $\\mathbf{b} \\in \\mathbb{R}^{m}$ 包含投影后的分子项数据。假设一个数值程序产生了一个近似系数向量 $\\hat{\\mathbf{c}}$。\n\n从恒等式 $\\mathbf{A}(\\mathbf{c}^{\\star} - \\hat{\\mathbf{c}}) = \\mathbf{b} - \\mathbf{A}\\hat{\\mathbf{c}}$ 和诱导矩阵范数的定义出发，推导一个基于残差的估计量，该估计量使用算子范数 $\\lVert \\mathbf{A}^{-1} \\rVert_{2}$ 和残差范数 $\\lVert \\mathbf{b} - \\mathbf{A}\\hat{\\mathbf{c}} \\rVert_{2}$ 来界定系数误差 $\\lVert \\mathbf{c}^{\\star} - \\hat{\\mathbf{c}} \\rVert_{2}$。然后，考虑由标量主积分重构的标量振幅为 $a = \\mathbf{s}^{\\top}\\mathbf{c}$，其中给定权重向量 $\\mathbf{s} \\in \\mathbb{R}^{m}$（编码了在指定运动学条件下标量主积分的数值），推导振幅误差 $\\lvert \\mathbf{s}^{\\top}\\hat{\\mathbf{c}} - \\mathbf{s}^{\\top}\\mathbf{c}^{\\star} \\rvert$ 的一个相应界，该界用 $\\lVert \\mathbf{s} \\rVert_{2}$ 和基于残差的系数误差估计量表示。\n\n实现一个完整的程序，该程序：\n- 对向量和矩阵使用谱范数（诱导2-范数）。\n- 将 $\\lVert \\mathbf{A}^{-1} \\rVert_{2}$ 计算为 $\\mathbf{A}$ 的最小奇异值的倒数。\n- 对每个测试用例，构建残差 $\\mathbf{r} = \\mathbf{b} - \\mathbf{A}\\hat{\\mathbf{c}}$，计算系数误差估计量和振幅误差估计量，并使用 $\\tau = 10^{-12}$ 的容差将它们与实际误差进行比较。\n- 对每个测试用例，报告两个布尔结果：\n  1. $\\lVert \\hat{\\mathbf{c}} - \\mathbf{c}^{\\star} \\rVert_{2} \\le \\lVert \\mathbf{A}^{-1} \\rVert_{2}\\,\\lVert \\mathbf{r} \\rVert_{2} + \\tau$ 是否成立。\n  2. $\\lvert \\mathbf{s}^{\\top}(\\hat{\\mathbf{c}} - \\mathbf{c}^{\\star}) \\rvert \\le \\lVert \\mathbf{s} \\rVert_{2}\\,\\lVert \\mathbf{A}^{-1} \\rVert_{2}\\,\\lVert \\mathbf{r} \\rVert_{2} + \\tau$ 是否成立。\n\n使用以下测试套件。对于每个用例，计算 $\\mathbf{b} = \\mathbf{A}\\mathbf{c}^{\\star}$，然后使用指定的 $\\hat{\\mathbf{c}}$ 和 $\\mathbf{s}$。\n\n- 测试用例1（良态，小微扰）：\n  - $\\mathbf{A}_{1} = \\begin{bmatrix} 3  1  0 \\\\ 1  2  1 \\\\ 0  1  2 \\end{bmatrix}$，\n    $\\mathbf{c}^{\\star}_{1} = \\begin{bmatrix} 1 \\\\ -2 \\\\ 0.5 \\end{bmatrix}$，\n    $\\hat{\\mathbf{c}}_{1} = \\mathbf{c}^{\\star}_{1} + \\begin{bmatrix} 10^{-6} \\\\ -2\\times 10^{-6} \\\\ 10^{-6} \\end{bmatrix}$，\n    $\\mathbf{s}_{1} = \\begin{bmatrix} 0.7 \\\\ -1.3 \\\\ 0.2 \\end{bmatrix}$。\n- 测试用例2（病态对角矩阵）：\n  - $\\mathbf{A}_{2} = \\mathrm{diag}(1, 10^{-6}, 10^{-9})$，\n    $\\mathbf{c}^{\\star}_{2} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$，\n    $\\hat{\\mathbf{c}}_{2} = \\mathbf{c}^{\\star}_{2} + \\begin{bmatrix} 10^{-10} \\\\ -10^{-10} \\\\ 10^{-10} \\end{bmatrix}$，\n    $\\mathbf{s}_{2} = \\begin{bmatrix} 1 \\\\ -2 \\\\ 3 \\end{bmatrix}$。\n- 测试用例3（精确重构）：\n  - $\\mathbf{A}_{3} = \\begin{bmatrix} 2  -1 \\\\ -1  2 \\end{bmatrix}$，\n    $\\mathbf{c}^{\\star}_{3} = \\begin{bmatrix} 0.3 \\\\ -0.4 \\end{bmatrix}$，\n    $\\hat{\\mathbf{c}}_{3} = \\mathbf{c}^{\\star}_{3}$，\n    $\\mathbf{s}_{3} = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$。\n- 测试用例4（近奇异且带有小的非对角微扰）：\n  - $\\mathbf{A}_{4} = \\begin{bmatrix} 1  1  1 \\\\ 1  1 + 10^{-12}  1 \\\\ 1  1  1 + 10^{-12} \\end{bmatrix}$，\n    $\\mathbf{c}^{\\star}_{4} = \\begin{bmatrix} 0.2 \\\\ -0.1 \\\\ 0.05 \\end{bmatrix}$，\n    $\\hat{\\mathbf{c}}_{4} = \\mathbf{c}^{\\star}_{4} + \\begin{bmatrix} 10^{-8} \\\\ -2\\times 10^{-8} \\\\ 3\\times 10^{-8} \\end{bmatrix}$，\n    $\\mathbf{s}_{4} = \\begin{bmatrix} 2 \\\\ -0.5 \\\\ 0.3 \\end{bmatrix}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按从 $1$ 到 $4$ 的顺序包含每个测试用例的结果，首先是系数误差界有效性的布尔值，然后是振幅误差界有效性的布尔值。因此，输出总共必须有 $8$ 个布尔条目，例如 $[\\mathrm{True},\\mathrm{True},\\dots]$。", "solution": "该问题要求推导两个基于残差的误差估计量并对其进行数值验证。第一个估计量界定标量主积分系数向量中的误差，第二个估计量界定重构标量振幅中的相应误差。其背景是求解线性系统 $\\mathbf{A}\\mathbf{c} = \\mathbf{b}$，其中 $\\mathbf{c}^{\\star}$ 是精确解，$\\hat{\\mathbf{c}}$ 是数值上获得的近似解。所有矩阵和向量范数都指定为2-范数（向量为欧几里得范数，矩阵为谱范数）。\n\n首先，我们推导系数误差的界 $\\lVert \\hat{\\mathbf{c}} - \\mathbf{c}^{\\star} \\rVert_{2}$。我们从给定的恒等式开始，该恒等式将解的误差与近似解的残差联系起来。设精确解 $\\mathbf{c}^{\\star}$ 满足 $\\mathbf{A}\\mathbf{c}^{\\star} = \\mathbf{b}$。近似解 $\\hat{\\mathbf{c}}$ 的残差向量 $\\mathbf{r}$ 定义为 $\\mathbf{r} = \\mathbf{b} - \\mathbf{A}\\hat{\\mathbf{c}}$。将 $\\mathbf{b} = \\mathbf{A}\\mathbf{c}^{\\star}$ 代入残差的定义，得到：\n$$ \\mathbf{r} = \\mathbf{A}\\mathbf{c}^{\\star} - \\mathbf{A}\\hat{\\mathbf{c}} = \\mathbf{A}(\\mathbf{c}^{\\star} - \\hat{\\mathbf{c}}) $$\n假设矩阵 $\\mathbf{A}$ 是非奇异的，则其逆矩阵 $\\mathbf{A}^{-1}$ 存在。因此我们可以解出系数误差向量，此处记为 $\\mathbf{e}_{\\mathbf{c}} = \\mathbf{c}^{\\star} - \\hat{\\mathbf{c}}$：\n$$ \\mathbf{e}_{\\mathbf{c}} = \\mathbf{A}^{-1}\\mathbf{r} $$\n为了找到误差大小的界，我们对等式两边取2-范数：\n$$ \\lVert \\mathbf{e}_{\\mathbf{c}} \\rVert_{2} = \\lVert \\mathbf{A}^{-1}\\mathbf{r} \\rVert_{2} $$\n根据诱导矩阵范数的定义，我们有性质 $\\lVert \\mathbf{M}\\mathbf{x} \\rVert \\le \\lVert \\mathbf{M} \\rVert \\lVert \\mathbf{x} \\rVert$。将此不等式应用于矩阵 $\\mathbf{A}^{-1}$ 和向量 $\\mathbf{r}$ 的2-范数，可得：\n$$ \\lVert \\mathbf{A}^{-1}\\mathbf{r} \\rVert_{2} \\le \\lVert \\mathbf{A}^{-1} \\rVert_{2} \\lVert \\mathbf{r} \\rVert_{2} $$\n结合这些结果，我们便得到了所期望的误差界。由于 $\\lVert \\hat{\\mathbf{c}} - \\mathbf{c}^{\\star} \\rVert_{2} = \\lVert -(\\mathbf{c}^{\\star} - \\hat{\\mathbf{c}}) \\rVert_{2} = \\lVert \\mathbf{c}^{\\star} - \\hat{\\mathbf{c}} \\rVert_{2} = \\lVert \\mathbf{e}_{\\mathbf{c}} \\rVert_{2}$，该不等式为：\n$$ \\lVert \\hat{\\mathbf{c}} - \\mathbf{c}^{\\star} \\rVert_{2} \\le \\lVert \\mathbf{A}^{-1} \\rVert_{2} \\lVert \\mathbf{r} \\rVert_{2} = \\lVert \\mathbf{A}^{-1} \\rVert_{2} \\lVert \\mathbf{b} - \\mathbf{A}\\hat{\\mathbf{c}} \\rVert_{2} $$\n这个不等式建立了残差 $\\mathbf{r}$ 的范数（一个可计算的量）与实际误差 $\\hat{\\mathbf{c}} - \\mathbf{c}^{\\star}$ 的范数（在不知道 $\\mathbf{c}^{\\star}$ 的情况下通常是不可计算的）之间的直接关系。因子 $\\lVert \\mathbf{A}^{-1} \\rVert_{2}$ 充当一个放大因子；对于病态矩阵，该项可能非常大，这意味着小的残差并不保证小的误差。\n\n其次，我们推导振幅误差的界 $\\lvert \\mathbf{s}^{\\top}\\hat{\\mathbf{c}} - \\mathbf{s}^{\\top}\\mathbf{c}^{\\star} \\rvert$。标量振幅 $a$ 由系数的线性组合给出，$a = \\mathbf{s}^{\\top}\\mathbf{c}$。振幅中的误差 $e_{a}$ 为：\n$$ e_{a} = \\lvert \\mathbf{s}^{\\top}\\hat{\\mathbf{c}} - \\mathbf{s}^{\\top}\\mathbf{c}^{\\star} \\rvert = \\lvert \\mathbf{s}^{\\top}(\\hat{\\mathbf{c}} - \\mathbf{c}^{\\star}) \\rvert $$\n认识到 $\\hat{\\mathbf{c}} - \\mathbf{c}^{\\star} = -\\mathbf{e}_{\\mathbf{c}} = -(\\mathbf{c}^{\\star} - \\hat{\\mathbf{c}})$，我们可以写出：\n$$ e_{a} = \\lvert \\mathbf{s}^{\\top}(-\\mathbf{e}_{\\mathbf{c}}) \\rvert = \\lvert -\\mathbf{s}^{\\top}\\mathbf{e}_{\\mathbf{c}} \\rvert = \\lvert \\mathbf{s}^{\\top}\\mathbf{e}_{\\mathbf{c}} \\rvert $$\n表达式 $\\mathbf{s}^{\\top}\\mathbf{e}_{\\mathbf{c}}$ 是向量 $\\mathbf{s}$ 和 $\\mathbf{e}_{\\mathbf{c}}$ 之间的标准点积。我们可以应用柯西-施瓦茨不等式 $\\lvert \\mathbf{u}^{\\top}\\mathbf{v} \\rvert \\le \\lVert \\mathbf{u} \\rVert_{2} \\lVert \\mathbf{v} \\rVert_{2}$，其中 $\\mathbf{u} = \\mathbf{s}$ 且 $\\mathbf{v} = \\mathbf{e}_{\\mathbf{c}}$：\n$$ \\lvert \\mathbf{s}^{\\top}\\mathbf{e}_{\\mathbf{c}} \\rvert \\le \\lVert \\mathbf{s} \\rVert_{2} \\lVert \\mathbf{e}_{\\mathbf{c}} \\rVert_{2} $$\n现在，我们代入先前为 $\\lVert \\mathbf{e}_{\\mathbf{c}} \\rVert_{2}$ 推导出的界：\n$$ e_{a} \\le \\lVert \\mathbf{s} \\rVert_{2} (\\lVert \\mathbf{A}^{-1} \\rVert_{2} \\lVert \\mathbf{r} \\rVert_{2}) $$\n因此，振幅误差的最终界为：\n$$ \\lvert \\mathbf{s}^{\\top}(\\hat{\\mathbf{c}} - \\mathbf{c}^{\\star}) \\rvert \\le \\lVert \\mathbf{s} \\rVert_{2} \\lVert \\mathbf{A}^{-1} \\rVert_{2} \\lVert \\mathbf{b} - \\mathbf{A}\\hat{\\mathbf{c}} \\rVert_{2} $$\n这一结果表明，最终物理量（振幅）的误差由相同的基于残差的估计量界定，并按权重向量 $\\mathbf{s}$ 的范数进行缩放。\n\n在实现方面，我们遵循问题的指示。逆矩阵的谱范数 $\\lVert \\mathbf{A}^{-1} \\rVert_{2}$ 计算为 $\\mathbf{A}$ 的最小奇异值的倒数，即 $1/\\sigma_{\\min}(\\mathbf{A})$。奇异值通过奇异值分解（SVD）获得。所有向量范数都计算为标准的欧几里得（$L_2$）范数。对于每个测试用例，程序会构建相关的向量和矩阵，计算精确的右端项 $\\mathbf{b} = \\mathbf{A}\\mathbf{c}^{\\star}$、残差 $\\mathbf{r} = \\mathbf{b} - \\mathbf{A}\\hat{\\mathbf{c}}$ 以及误差估计量。然后，它将实际误差与估计量进行比较，包括指定的浮点容差 $\\tau = 10^{-12}$，以生成所需的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and verifies residual-based error estimators for a linear system\n    arising in one-loop tensor reduction.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[3.0, 1.0, 0.0], [1.0, 2.0, 1.0], [0.0, 1.0, 2.0]]),\n            \"c_star\": np.array([1.0, -2.0, 0.5]),\n            \"c_hat\": np.array([1.0, -2.0, 0.5]) + np.array([1e-6, -2e-6, 1e-6]),\n            \"s\": np.array([0.7, -1.3, 0.2]),\n        },\n        {\n            \"A\": np.diag([1.0, 1e-6, 1e-9]),\n            \"c_star\": np.array([1.0, 1.0, 1.0]),\n            \"c_hat\": np.array([1.0, 1.0, 1.0]) + np.array([1e-10, -1e-10, 1e-10]),\n            \"s\": np.array([1.0, -2.0, 3.0]),\n        },\n        {\n            \"A\": np.array([[2.0, -1.0], [-1.0, 2.0]]),\n            \"c_star\": np.array([0.3, -0.4]),\n            \"c_hat\": np.array([0.3, -0.4]),\n            \"s\": np.array([1.0, 1.0]),\n        },\n        {\n            \"A\": np.array([[1.0, 1.0, 1.0], \n                           [1.0, 1.0 + 1e-12, 1.0], \n                           [1.0, 1.0, 1.0 + 1e-12]]),\n            \"c_star\": np.array([0.2, -0.1, 0.05]),\n            \"c_hat\": np.array([0.2, -0.1, 0.05]) + np.array([1e-8, -2e-8, 3e-8]),\n            \"s\": np.array([2.0, -0.5, 0.3]),\n        },\n    ]\n\n    tau = 1e-12\n    results = []\n    \n    for case in test_cases:\n        A = case[\"A\"]\n        c_star = case[\"c_star\"]\n        c_hat = case[\"c_hat\"]\n        s = case[\"s\"]\n\n        # b is determined from the exact solution c_star\n        b = A @ c_star\n        \n        # Residual vector r = b - A*c_hat\n        r = b - (A @ c_hat)\n        \n        # Spectral norm of A_inv is 1 / smallest singular value of A\n        singular_values = np.linalg.svd(A, compute_uv=False)\n        norm_A_inv = 1.0 / np.min(singular_values)\n        \n        # L2 norm of the residual vector\n        norm_r = np.linalg.norm(r, 2)\n        \n        # --- Coefficient Error Check ---\n        \n        # Estimator for the coefficient error\n        coeff_error_estimator = norm_A_inv * norm_r\n        \n        # Actual coefficient error\n        actual_coeff_error = np.linalg.norm(c_hat - c_star, 2)\n        \n        # Check condition 1\n        is_coeff_bound_valid = actual_coeff_error = coeff_error_estimator + tau\n        results.append(is_coeff_bound_valid)\n\n        # --- Amplitude Error Check ---\n        \n        # L2 norm of the weight vector s\n        norm_s = np.linalg.norm(s, 2)\n\n        # Estimator for the amplitude error\n        amp_error_estimator = norm_s * coeff_error_estimator\n        \n        # Actual amplitude error\n        actual_amp_error = np.abs(s @ (c_hat - c_star))\n        \n        # Check condition 2\n        is_amp_bound_valid = actual_amp_error = amp_error_estimator + tau\n        results.append(is_amp_bound_valid)\n\n    # Final print statement in the exact required format.\n    # The map(str,...) is used to get 'True'/'False' instead of 'true'/'false'.\n    print(f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\"))\n```", "id": "3525516"}]}