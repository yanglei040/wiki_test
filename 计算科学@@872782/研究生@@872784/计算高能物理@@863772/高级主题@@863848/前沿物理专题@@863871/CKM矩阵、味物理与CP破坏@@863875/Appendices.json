{"hands_on_practices": [{"introduction": "这项练习是味物理学中任何数值探索的基石。我们将从实现CKM矩阵（Cabibbo-Kobayashi-Maskawa矩阵）的标准参数化开始，正是这个矩阵主宰着夸克的味混合。通过从基本的混合角和CP破坏相位构建该矩阵，然后检验其幺正性，你将亲身体验其数学结构以及在计算物理中有限精度运算带来的实际挑战。[@problem_id:3507884]", "problem": "您的任务是为 Cabibbo–Kobayashi–Maskawa (CKM) 矩阵实现一个数值诊断程序，该程序应用于粒子物理学标准模型中的味物理学和电荷-宇称 (CP) 破坏的背景下。Cabibbo–Kobayashi–Maskawa (CKM) 矩阵是一个酉矩阵，它将下夸克类型的弱相互作用本征态旋转到质量本征基，并且它可以通过三个混合角和一个破坏 CP 对称的相位来参数化。目标是使用标准的粒子数据组 (Particle Data Group, PDG) 参数化方法，根据给定的参数构建 CKM 矩阵，然后通过计算最大幺正性破坏和的大小来测试其数值幺正性。\n\n基本原理：\n- 带电流弱相互作用通过三维酉矩阵——Cabibbo–Kobayashi–Maskawa (CKM) 矩阵——耦合夸克味二重态。\n- 一个酉矩阵 $U$ 满足 $U^{\\dagger} U = I$ 和 $U U^{\\dagger} = I$，其中 $I$ 是相同维度的单位矩阵，$U^{\\dagger}$ 是共轭转置。\n- 标准的粒子数据组 (PDG) 参数化将 CKM 矩阵 $V$ 表示为乘积 $V = R_{23}(\\theta_{23}) R_{13}(\\theta_{13}, \\delta) R_{12}(\\theta_{12})$，其中 $R_{12}$ 和 $R_{23}$ 是相应二维子空间中的实旋转，而 $R_{13}$ 是一个复旋转，它将破坏 CP 对称的相位 $\\delta$ 以单位模相位因子的形式嵌入到 $(1,3)$ 和 $(3,1)$ 元中。记 $c_{ij} \\equiv \\cos \\theta_{ij}$ 和 $s_{ij} \\equiv \\sin \\theta_{ij}$，$R_{12}$、$R_{23}$ 和 $R_{13}$ 定义如下：\n$$\nR_{12}(\\theta_{12}) =\n\\begin{pmatrix}\nc_{12} & s_{12} & 0 \\\\\n-s_{12} & c_{12} & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix},\\quad\nR_{23}(\\theta_{23}) =\n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & c_{23} & s_{23} \\\\\n0 & -s_{23} & c_{23}\n\\end{pmatrix},\n$$\n$$\nR_{13}(\\theta_{13}, \\delta) =\n\\begin{pmatrix}\nc_{13} & 0 & s_{13} e^{-i \\delta} \\\\\n0 & 1 & 0 \\\\\n- s_{13} e^{i \\delta} & 0 & c_{13}\n\\end{pmatrix}.\n$$\n这些是 $3 \\times 3$ 的酉矩阵；在精确算术中，它们的乘积也是酉的。\n\n您的任务是：\n1. 使用浮点算术，根据输入 $(\\theta_{12}, \\theta_{23}, \\theta_{13}, \\delta)$ 和上述 PDG 参数化方法实现 $V$ 的构建。所有角度必须以弧度为单位进行解释。\n2. 为任意复 $3 \\times 3$ 矩阵 $V$ 定义一个幺正性破坏诊断量\n$$\nD(V) \\equiv \\max\\big\\{\\ \\max_{i,j} \\left| \\left(V^{\\dagger} V - I\\right)_{ij} \\right|,\\ \\max_{i,j} \\left| \\left(V V^{\\dagger} - I\\right)_{ij} \\right| \\ \\big\\}.\n$$\n该诊断量是一个非负实数，对于完全幺正的矩阵，其值精确为零；而在发生舍入误差的浮点算术中，其值为正。\n3. 对于下面测试套件中的每一组参数，构建 $V$ 并计算 $D(V)$ 的浮点数值。\n\n角度单位要求：\n- 所有角度 $(\\theta_{12}, \\theta_{23}, \\theta_{13}, \\delta)$ 均以弧度为单位指定。\n\n测试套件：\n- 情况 1 (典型的小混合角，非平凡的 CP 相位)：$\\theta_{12} = \\arcsin(0.2243)$，$\\theta_{23} = \\arcsin(0.0422)$，$\\theta_{13} = \\arcsin(0.00394)$，$\\delta = \\pi/3$。\n- 情况 2 (相同的混合角，CP 守恒)：$\\theta_{12} = \\arcsin(0.2243)$，$\\theta_{23} = \\arcsin(0.0422)$，$\\theta_{13} = \\arcsin(0.00394)$，$\\delta = 0$。\n- 情况 3 (无混合角，任意相位)：$\\theta_{12} = 0$，$\\theta_{23} = 0$，$\\theta_{13} = 0$，$\\delta = 2.0$。\n- 情况 4 (强的 $(1,3)$ 混合边缘情况，带相位)：$\\theta_{12} = 0.7$，$\\theta_{23} = 1.1$，$\\theta_{13} = \\pi/2$，$\\delta = \\pi$。\n- 情况 5 (极小角度，通用相位)：$\\theta_{12} = 10^{-8}$，$\\theta_{23} = 10^{-8}$，$\\theta_{13} = 10^{-8}$，$\\delta = \\pi/7$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 每个条目必须是对应测试用例的 $D(V)$ 值，四舍五入并格式化为科学记数法，小数点后精确到 $12$ 位。\n- 例如，包含两个结果的输出应如下所示：`[1.234000000000e-12,5.670000000000e-16]`。\n\n除了上述指定的角度单位外，最终答案中没有其他物理单位。", "solution": "该问题要求实现一个数值诊断程序，用以测试使用标准粒子数据组 (PDG) 参数化方法构建的 Cabibbo-Kobayashi-Maskawa (CKM) 矩阵 $V$ 的幺正性。解决方案涉及从一组给定的参数构建矩阵，然后计算一个度量，该度量用于量化由浮点运算引起的与完美幺正性的偏差。\n\n基本原理是 CKM 矩阵必须是酉矩阵，即 $V^{\\dagger}V = VV^{\\dagger} = I$，其中 $I$ 是 $3 \\times 3$ 单位矩阵，$V^{\\dagger}$ 是 $V$ 的共轭转置。在精确算术中，酉矩阵的乘积也是酉的。在数值计算中，任何与此恒等式的偏差都源于浮点舍入误差。我们的目标是量化这种偏差。\n\n该解决方案按步骤实现。\n\n**第 1 步：构建旋转矩阵**\n\nCKM 矩阵 $V$ 由三个混合角 $\\theta_{12}$、$\\theta_{23}$、$\\theta_{13}$ 和一个破坏 CP 对称的相位 $\\delta$ 参数化。其构建由三个旋转矩阵的乘积给出：$V = R_{23}(\\theta_{23}) R_{13}(\\theta_{13}, \\delta) R_{12}(\\theta_{12})$。我们首先实现这三个 $3 \\times 3$ 矩阵中每一个的构建。为清晰起见，令 $c_{ij} = \\cos \\theta_{ij}$ 和 $s_{ij} = \\sin \\theta_{ij}$。\n\n$R_{12}(\\theta_{12})$ 旋转矩阵定义如下：\n$$\nR_{12}(\\theta_{12}) =\n\\begin{pmatrix}\nc_{12} & s_{12} & 0 \\\\\n-s_{12} & c_{12} & 0 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n$$\n这是一个表示在 $(1,2)$ 平面中旋转的实值矩阵。\n\n$R_{23}(\\theta_{23})$ 旋转矩阵定义如下：\n$$\nR_{23}(\\theta_{23}) =\n\\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & c_{23} & s_{23} \\\\\n0 & -s_{23} & c_{23}\n\\end{pmatrix}\n$$\n这是一个表示在 $(2,3)$ 平面中旋转的实值矩阵。\n\n包含破坏 CP 对称相位 $\\delta$ 的旋转矩阵 $R_{13}(\\theta_{13}, \\delta)$ 定义如下：\n$$\nR_{13}(\\theta_{13}, \\delta) =\n\\begin{pmatrix}\nc_{13} & 0 & s_{13} e^{-i \\delta} \\\\\n0 & 1 & 0 \\\\\n- s_{13} e^{i \\delta} & 0 & c_{13}\n\\end{pmatrix}\n$$\n由于存在复指数项 $e^{\\pm i \\delta} = \\cos\\delta \\pm i \\sin\\delta$，该矩阵是复值的。因此，所有后续的矩阵运算都必须使用复数算术执行。在我们的实现中，我们将对所有矩阵使用复数浮点数据类型（例如 `np.complex128`），以确保兼容性和精度。\n\n**第 2 步：CKM 矩阵组装**\n\n在定义了各个旋转矩阵后，CKM 矩阵 $V$ 通过按指定顺序执行矩阵乘法来计算：\n$$\nV = R_{23}(\\theta_{23}) \\cdot R_{13}(\\theta_{13}, \\delta) \\cdot R_{12}(\\theta_{12})\n$$\n乘法顺序至关重要，必须严格遵守。此操作可由 NumPy 等数值库使用 `numpy.matmul` 或 `@` 运算符高效处理。\n\n**第 3 步：幺正性破坏诊断**\n\n任务的核心是计算诊断量 $D(V)$，它用于度量与幺正性的偏差。其定义如下：\n$$\nD(V) \\equiv \\max\\big\\{\\ \\max_{i,j} \\left| \\left(V^{\\dagger} V - I\\right)_{ij} \\right|,\\ \\max_{i,j} \\left| \\left(V V^{\\dagger} - I\\right)_{ij} \\right| \\ \\big\\}\n$$\n计算过程如下：\n1.  计算 $V$ 的共轭转置，记为 $V^{\\dagger}$。\n2.  计算幺正性条件的两个残差矩阵：$M_1 = V^{\\dagger}V - I$ 和 $M_2 = VV^{\\dagger} - I$。在理想情况下，$M_1$ 和 $M_2$ 都应为零矩阵。\n3.  计算 $M_1$ 中所有元素的最大绝对值，即 $\\max_{i,j} |(M_1)_{ij}|$。由于 $M_1$ 的元素是复数，因此必须取绝对值。\n4.  类似地，计算 $M_2$ 中所有元素的最大绝对值：$\\max_{i,j} |(M_2)_{ij}|$。\n5.  诊断量 $D(V)$ 是这两个最大值中较大的一个。这个单一的非负实数代表了所有矩阵元素中对幺正性条件的最大破坏幅度。\n\n**第 4 步：算法实现与输出格式化**\n\n整体算法将这些步骤封装在一个循环中，该循环遍历所提供的测试用例。\n1.  定义一个参数集列表 $(\\theta_{12}, \\theta_{23}, \\theta_{13}, \\delta)$，对应五个测试用例。以 `arcsin(x)` 形式给出的角度值需要进行数值计算。\n2.  对每个参数集，调用一个函数来执行第 1-3 步，返回 $D(V)$ 的值。\n3.  计算出的 $D(V)$ 值存储在一个列表中。\n4.  最后，将结果列表格式化为单个字符串。每个数值都转换为科学记数法字符串，小数点后精确到 $12$ 位（例如，`1.234000000000e-16`）。这些字符串用逗号连接，并用方括号 `[...]` 括起来，然后作为最终输出打印。在此类科学计算中，使用双精度浮点数（$64$ 位）是标准做法，以最大限度地减少舍入误差，而 $D(V)$ 正是为此设计的度量。\n\n此过程为构建 CKM 矩阵并评估其数值幺正性提供了一个稳健且可验证的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to compute and print the CKM unitarity diagnostic for a suite of test cases.\n    \"\"\"\n\n    def calculate_ckm_diagnostic(theta_12, theta_23, theta_13, delta):\n        \"\"\"\n        Constructs the CKM matrix and computes its unitarity violation diagnostic.\n\n        Args:\n            theta_12 (float): Mixing angle in the 1-2 plane (radians).\n            theta_23 (float): Mixing angle in the 2-3 plane (radians).\n            theta_13 (float): Mixing angle in the 1-3 plane (radians).\n            delta (float): CP-violating phase (radians).\n\n        Returns:\n            float: The unitarity diagnostic D(V).\n        \"\"\"\n        # Calculate cosines and sines of the mixing angles\n        c12, s12 = np.cos(theta_12), np.sin(theta_12)\n        c23, s23 = np.cos(theta_23), np.sin(theta_23)\n        c13, s13 = np.cos(theta_13), np.sin(theta_13)\n\n        # Define the rotation matrix R_12\n        # All matrices are initialized as complex to handle complex arithmetic\n        R12 = np.array([\n            [c12,  s12, 0],\n            [-s12, c12, 0],\n            [0,    0,   1]\n        ], dtype=np.complex128)\n\n        # Define the rotation matrix R_23\n        R23 = np.array([\n            [1, 0,    0   ],\n            [0, c23,  s23 ],\n            [0, -s23, c23 ]\n        ], dtype=np.complex128)\n\n        # Define the complex rotation matrix R_13\n        R13 = np.array([\n            [c13, 0, s13 * np.exp(-1j * delta)],\n            [0,   1, 0                       ],\n            [-s13 * np.exp(1j * delta), 0, c13]\n        ], dtype=np.complex128)\n\n        # Construct the CKM matrix V = R_23 @ R_13 @ R_12\n        V = R23 @ R13 @ R12\n\n        # Define the 3x3 identity matrix\n        I = np.identity(3, dtype=np.complex128)\n        # Compute the conjugate transpose of V\n        V_dagger = V.conj().T\n\n        # Compute the residual matrices for the unitarity check\n        res_V_dagger_V = V_dagger @ V - I\n        res_V_V_dagger = V @ V_dagger - I\n\n        # Compute the maximum absolute element value for each residual matrix\n        d1 = np.abs(res_V_dagger_V).max()\n        d2 = np.abs(res_V_V_dagger).max()\n\n        # The diagnostic is the maximum of the two values\n        return max(d1, d2)\n\n    # Define the test cases from the problem statement.\n    # Parameters: (theta_12, theta_23, theta_13, delta) in radians.\n    test_cases = [\n        # Case 1: typical small mixings, nontrivial CP phase\n        (np.arcsin(0.2243), np.arcsin(0.0422), np.arcsin(0.00394), np.pi / 3),\n        # Case 2: same mixings, CP-conserving\n        (np.arcsin(0.2243), np.arcsin(0.0422), np.arcsin(0.00394), 0.0),\n        # Case 3: no mixing angles, arbitrary phase\n        (0.0, 0.0, 0.0, 2.0),\n        # Case 4: strong (1,3) mixing edge with phase\n        (0.7, 1.1, np.pi / 2, np.pi),\n        # Case 5: tiny angles, generic phase\n        (1e-8, 1e-8, 1e-8, np.pi / 7)\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the diagnostic D(V) for the current case\n        result = calculate_ckm_diagnostic(*case)\n        results.append(result)\n\n    # Format results to scientific notation with 12 decimal places\n    formatted_results = [f\"{res:.12e}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "3507884"}, {"introduction": "构建了CKM矩阵之后，我们现在转向一个关键问题：它是如何产生可观测的CP破坏的？本练习使用一个简化但功能强大的“玩具模型”来揭示直接CP破坏的内在机制，该机制源于不同衰变振幅之间的量子力学干涉。通过调控树图和企鹅图振幅的强相位与弱相位，你将发现使得一个衰变过程的速率与其CP共轭过程不同的两个基本要素。[@problem_id:3507893]", "problem": "实现一个程序，在一个介子衰变的树图-企鹅图干涉的玩具模型中，测试振幅级别的电荷共轭-宇称 (CP) 变换，并计算直接 CP 不对称性。其科学基础是带有 Cabibbo–Kobayashi–Maskawa (CKM) 矩阵的标准模型，该矩阵在衰变振幅中提供了复数弱相位，以及量子力学中的振幅叠加原理。将到末态 $f$ 的衰变振幅定义为一个树图贡献和一个企鹅图贡献的相干叠加，每个贡献都由一个实数量级、一个强相位和一个弱相位来表征。在 CP 变换下，弱相位反号，而强相位因其源于量子色动力学 (QCD) 而保持不变。直接 CP 不对称性定义为一个过程与其 CP 共轭过程的衰变概率的归一化差异。\n\n从以下基本事实出发：\n- 衰变概率与量子力学振幅的模平方成正比。\n- 在 CP 变换下，来自 Cabibbo–Kobayashi–Maskawa (CKM) 矩阵的弱相位变号，而强相位不变。\n\n为一个双拓扑模型构建以下对象：\n- 一个到末态 $f$ 的衰变振幅 $A_f$，由以下部分组成\n  $$A_f = T\\,e^{i(\\delta_T + \\phi_T)} + P\\,e^{i(\\delta_P + \\phi_P)},$$\n  其中 $T$ 和 $P$ 是实数非负量级，$\\delta_T$ 和 $\\delta_P$ 是实数强相位，$\\phi_T$ 和 $\\phi_P$ 是实数弱相位。\n- 其 CP 共轭振幅 $\\bar A_{\\bar f}$，通过反转弱相位并保持强相位不变得到：\n  $$\\bar A_{\\bar f} = T\\,e^{i(\\delta_T - \\phi_T)} + P\\,e^{i(\\delta_P - \\phi_P)}.$$\n\n你的程序必须：\n1. 实现一个函数，根据给定的 $(T,P,\\delta_T,\\delta_P,\\phi_T,\\phi_P)$（所有相位参数单位为弧度）计算 $A_f$ 和 $\\bar A_{\\bar f}$。\n2. 实现一个振幅级别的 CP 变换验证，明确检查树图和企鹅图贡献是否按照 $T\\,e^{i(\\delta_T + \\phi_T)} \\to T\\,e^{i(\\delta_T - \\phi_T)}$ 和 $P\\,e^{i(\\delta_P + \\phi_P)} \\to P\\,e^{i(\\delta_P - \\phi_P)}$ 进行变换，并且总振幅在微小的数值容差内遵循 $A_f \\to \\bar A_{\\bar f}$。每个测试用例的验证输出必须是一个布尔值。\n3. 计算直接 CP 不对称性，定义为\n  $$A_{CP} = \\frac{|A_f|^2 - |\\bar A_{\\bar f}|^2}{|A_f|^2 + |\\bar A_{\\bar f}|^2},$$\n  对于每个测试用例，结果为一个浮点数。\n4. 所有相位参数均使用弧度作为单位。\n5. 将每个测试用例的布尔值 CP 变换检查结果和浮点数 $A_{CP}$ 汇总到一个列表中，顺序为 $[\\text{check}_1, A_{CP,1}, \\text{check}_2, A_{CP,2}, \\dots]$。\n6. 精确地打印一行，包含最终的汇总列表，格式为 $[x_1,x_2,\\dots,x_{2N}]$。\n\n测试套件：\n提供以下测试用例，每个用例为一个元组 $(T,P,\\delta_T,\\delta_P,\\phi_T,\\phi_P)$，角度单位为弧度：\n- 情况 1 (一般干涉): $(0.3, 1.0, 0.1, 0.5, 1.2, 0.0)$。\n- 情况 2 (无企鹅图边界): $(1.0, 0.0, 0.7, 0.0, 0.9, 0.0)$。\n- 情况 3 (强相位差为零): $(0.6, 0.6, 0.2, 0.2, 1.0, 0.1)$。\n- 情况 4 (近最大干涉): $(1.0, 1.0, 0.0, \\pi/2, \\pi/3, 0.0)$。\n- 情况 5 (具有大强相位的层级结构): $(0.05, 1.0, 0.4, 2.5, 1.2, 0.2)$。\n\n覆盖性设计：\n- 情况 1 练习具有非平凡强相位和弱相位的一般树图-企鹅图干涉。\n- 情况 2 确保当一种拓扑不存在时，不对称性消失。\n- 情况 3 检查当强相位差为零时，尽管存在弱相位，直接 CP 不对称性仍然消失。\n- 情况 4 探测具有正交强相位和相当大的弱相位差的近最大直接 CP 不对称性。\n- 情况 5 检查在小树图振幅和大的企鹅图强相位下，数值稳定性和 CP 变换。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[\\text{result}_1,\\text{result}_2,\\dots]$。角度必须以弧度为单位进行解释。除弧度外，不涉及其他物理单位。所有浮点数必须以标准十进制表示法打印。", "solution": "该问题是有效的，因为它在科学上基于标准模型对电荷共轭-宇称 (CP) 破坏的描述，其定义和参数完整一致，问题阐述清晰，并且在计算上是可行的。我们将提供一个完整的解决方案。\n\n我们所研究的物理现象是介子衰变中的直接 CP 破坏。当一个粒子衰变到末态 $f$ 的衰变率（表示为 $\\Gamma(M \\to f)$）与其反粒子衰变到 CP 共轭末态 $\\bar{f}$ 的衰变率（表示为 $\\Gamma(\\bar{M} \\to \\bar{f})$）不同时，就会发生这种现象。在标准模型中，这种不对称性源于至少两个具有不同强相位和弱相位的不同衰变振幅的干涉。弱相位是源于 Cabibbo-Kobayashi-Maskawa (CKM) 矩阵的复数参数。\n\n一个过程 $M \\to f$ 的衰变振幅 $A_f$ 由一个树图级振幅和一个企鹅图级振幅的和给出。每个贡献都是一个复数，由一个实数量级、一个来自量子色动力学 (QCD) 的强相位 $\\delta$ 和一个来自 CKM 矩阵的弱相位 $\\phi$ 来表征。总振幅为：\n$$A_f = T\\,e^{i(\\delta_T + \\phi_T)} + P\\,e^{i(\\delta_P + \\phi_P)}$$\n在这里，$T$ 和 $P$ 分别是树图振幅和企鹅图振幅的实数非负量级。项 $\\delta_T$ 和 $\\delta_P$ 是强相位，$\\phi_T$ 和 $\\phi_P$ 是弱相位。所有相位都以弧度为单位。\n\nCP 变换的一个基本性质是它不改变强相互作用的动力学，但作用于弱相互作用的耦合常数。因此，在 CP 变换下，强相位保持不变（$\\delta \\to \\delta$），而弱相位改变符号（$\\phi \\to -\\phi$）。将此变换应用于 $A_f$ 会得到过程 $\\bar{M} \\to \\bar{f}$ 的 CP 共轭振幅 $\\bar{A}_{\\bar{f}}$：\n$$\\bar{A}_{\\bar{f}} = T\\,e^{i(\\delta_T - \\phi_T)} + P\\,e^{i(\\delta_P - \\phi_P)}$$\n\n衰变率（或概率）与衰变振幅的模平方成正比。让我们计算 $|A_f|^2$ 和 $|\\bar{A}_{\\bar{f}}|^2$。一个振幅 $A = M_1 e^{i\\alpha_1} + M_2 e^{i\\alpha_2}$ 的模平方为 $|A|^2 = A A^* = M_1^2 + M_2^2 + 2 M_1 M_2 \\cos(\\alpha_1 - \\alpha_2)$。\n将此应用于 $A_f$：\n$$|A_f|^2 = T^2 + P^2 + 2TP \\cos\\left((\\delta_T + \\phi_T) - (\\delta_P + \\phi_P)\\right)$$\n$$|A_f|^2 = T^2 + P^2 + 2TP \\cos\\left((\\delta_T - \\delta_P) + (\\phi_T - \\phi_P)\\right)$$\n对 $\\bar{A}_{\\bar{f}}$ 也类似：\n$$|\\bar{A}_{\\bar{f}}|^2 = T^2 + P^2 + 2TP \\cos\\left((\\delta_T - \\phi_T) - (\\delta_P - \\phi_P)\\right)$$\n$$|\\bar{A}_{\\bar{f}}|^2 = T^2 + P^2 + 2TP \\cos\\left((\\delta_T - \\delta_P) - (\\phi_T - \\phi_P)\\right)$$\n\n直接 CP 不对称性 $A_{CP}$ 定义为这两个衰变率之间的归一化差异：\n$$A_{CP} = \\frac{|A_f|^2 - |\\bar{A}_{\\bar{f}}|^2}{|A_f|^2 + |\\bar{A}_{\\bar{f}}|^2}$$\n让我们使用三角恒等式 $\\cos(a+b) - \\cos(a-b) = -2\\sin(a)\\sin(b)$ 来分析分子，其中 $a = \\delta_T - \\delta_P$，$b = \\phi_T - \\phi_P$：\n$$|A_f|^2 - |\\bar{A}_{\\bar{f}}|^2 = 2TP \\left[ \\cos(a+b) - \\cos(a-b) \\right] = -4TP \\sin(\\delta_T - \\delta_P) \\sin(\\phi_T - \\phi_P)$$\n这个结果意义深远：要发生直接 CP 破坏（$A_{CP} \\neq 0$），必须同时满足两个条件（假设 $T, P > 0$）：\n1. 必须存在非零的强相位差：$\\sin(\\delta_T - \\delta_P) \\neq 0$，这意味着对于任何整数 $n$，$\\delta_T - \\delta_P \\neq n\\pi$。\n2. 必须存在非零的弱相位差：$\\sin(\\phi_T - \\phi_P) \\neq 0$，这意味着对于任何整数 $k$，$\\phi_T - \\phi_P \\neq k\\pi$。\n\n分母是：\n$$|A_f|^2 + |\\bar{A}_{\\bar{f}}|^2 = 2(T^2 + P^2) + 2TP \\left( \\cos(a+b) + \\cos(a-b) \\right)$$\n使用恒等式 $\\cos(a+b) + \\cos(a-b) = 2\\cos(a)\\cos(b)$：\n$$|A_f|^2 + |\\bar{A}_{\\bar{f}}|^2 = 2(T^2 + P^2) + 4TP \\cos(\\delta_T - \\delta_P) \\cos(\\phi_T - \\phi_P)$$\n因此，CP 不对称性的完整表达式为：\n$$A_{CP} = \\frac{-2TP \\sin(\\delta_T - \\delta_P) \\sin(\\phi_T - \\phi_P)}{T^2 + P^2 + 2TP \\cos(\\delta_T - \\delta_P) \\cos(\\phi_T - \\phi_P)}$$\n\n对于每组参数 $(T, P, \\delta_T, \\delta_P, \\phi_T, \\phi_P)$，计算任务包括两个部分：\n1.  **CP 变换验证**：问题要求明确检查 CP 变换规则是否被正确应用。这不仅仅是同义反复的检查，而是对振幅结构的验证。对于树图振幅 $A_T = T e^{i(\\delta_T + \\phi_T)}$，我们可以将其分为强相互作用部分 $S_T = T e^{i\\delta_T}$ 和弱相互作用部分 $W_T = e^{i\\phi_T}$，使得 $A_T = S_T W_T$。CP 变换后的振幅为 $A'_T = S_T W_T^*$，其中 $W_T^*$ 是 $W_T$ 的复共轭。验证将包括确认以这种方式构建的 $A'_T$ 在数值上等于定义为 $\\bar{A}_T = T e^{i(\\delta_T - \\phi_T)}$ 的振幅。此检查对树图和企鹅图贡献以及它们的总和都进行。\n2.  **CP 不对称性计算**：这涉及使用复数算术计算 $|A_f|^2$ 和 $|\\bar{A}_{\\bar{f}}|^2$，然后将这些值代入 $A_{CP}$ 的定义中。将使用一个小的数值容差（例如，$10^{-12}$）进行浮点比较。如果分母 $|A_f|^2 + |\\bar{A}_{\\bar{f}}|^2$ 为零（仅当 $T=0$ 和 $P=0$ 时发生），则不对称性未定义 ($0/0$)，应视为 $0$，因为没有衰变意味着没有不对称性。\n\n算法通过遍历提供的 5 个测试用例来执行。对于每个用例，它将计算两个所需的量——布尔验证结果和浮点不对称性 $A_{CP}$——并将它们汇总到一个有序列表中以供最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes direct CP asymmetries and verifies CP transformation for a set of\n    toy model decay parameters.\n    \"\"\"\n\n    # Test suite with each case as a tuple (T, P, delta_T, delta_P, phi_T, phi_P)\n    # in radians for all phase parameters.\n    test_cases = [\n        # Case 1 (general interference)\n        (0.3, 1.0, 0.1, 0.5, 1.2, 0.0),\n        # Case 2 (no penguin boundary)\n        (1.0, 0.0, 0.7, 0.0, 0.9, 0.0),\n        # Case 3 (zero strong-phase difference)\n        (0.6, 0.6, 0.2, 0.2, 1.0, 0.1),\n        # Case 4 (near-maximal interference)\n        (1.0, 1.0, 0.0, np.pi/2, np.pi/3, 0.0),\n        # Case 5 (hierarchical with large strong phase)\n        (0.05, 1.0, 0.4, 2.5, 1.2, 0.2),\n    ]\n\n    results = []\n    for params in test_cases:\n        check, A_CP = process_case(params)\n        results.append(check)\n        results.append(A_CP)\n\n    # Final print statement in the exact required format.\n    # The str() conversion for booleans produces 'True' or 'False'.\n    # The str() conversion for floats may use scientific notation for very small\n    # or large numbers, but for values of Acp between -1 and 1, this is unlikely.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(params):\n    \"\"\"\n    Calculates the CP transform verification and asymmetry for a single case.\n\n    Args:\n        params (tuple): A tuple containing (T, P, delta_T, delta_P, phi_T, phi_P).\n\n    Returns:\n        tuple: A tuple containing (boolean_check, A_CP_float).\n    \"\"\"\n    T, P, delta_T, delta_P, phi_T, phi_P = params\n    \n    # Numerical tolerance for floating point comparisons\n    TOL = 1e-12\n\n    # 1. Implement functions to compute A_f and A_bar_f_bar\n    # Using Euler's formula e^(i*x) = cos(x) + i*sin(x), represented by np.exp(1j*x)\n    \n    # Amplitudes for the original process\n    tree_amp = T * np.exp(1j * (delta_T + phi_T))\n    penguin_amp = P * np.exp(1j * (delta_P + phi_P))\n    A_f = tree_amp + penguin_amp\n\n    # Amplitudes for the CP-conjugate process\n    cp_tree_amp = T * np.exp(1j * (delta_T - phi_T))\n    cp_penguin_amp = P * np.exp(1j * (delta_P - phi_P))\n    A_bar_f_bar = cp_tree_amp + cp_penguin_amp\n    \n    # 2. Implement amplitude-level CP transformation verification\n    # This check validates that the CP-transformed components, constructed by\n    # conjugating the weak phase factor, match the directly computed CP-conjugate amplitudes.\n    \n    # Construct strong and weak phase factors\n    strong_part_T = T * np.exp(1j * delta_T)\n    weak_part_T = np.exp(1j * phi_T)\n    \n    strong_part_P = P * np.exp(1j * delta_P)\n    weak_part_P = np.exp(1j * phi_P)\n\n    # Apply CP transformation by conjugating the weak phase factor\n    verified_cp_tree = strong_part_T * np.conj(weak_part_T)\n    verified_cp_penguin = strong_part_P * np.conj(weak_part_P)\n    verified_A_bar = verified_cp_tree + verified_cp_penguin\n\n    # Perform a numerical comparison with a tolerance\n    check_tree = np.isclose(verified_cp_tree, cp_tree_amp, atol=TOL, rtol=TOL)\n    check_penguin = np.isclose(verified_cp_penguin, cp_penguin_amp, atol=TOL, rtol=TOL)\n    check_full = np.isclose(verified_A_bar, A_bar_f_bar, atol=TOL, rtol=TOL)\n    \n    # The final boolean check aggregates the component-wise checks\n    cp_check_result = bool(check_tree and check_penguin and check_full)\n\n    # 3. Compute the direct CP asymmetry A_CP\n    # Probability (rate) is proportional to the squared modulus of the amplitude.\n    prob_f = np.abs(A_f)**2\n    prob_f_bar = np.abs(A_bar_f_bar)**2\n    \n    denominator = prob_f + prob_f_bar\n    \n    if np.isclose(denominator, 0.0, atol=TOL):\n        # If there is no decay, there can be no asymmetry.\n        A_CP = 0.0\n    else:\n        numerator = prob_f - prob_f_bar\n        A_CP = numerator / denominator\n        \n    return cp_check_result, A_CP\n\nsolve()\n```", "id": "3507893"}, {"introduction": "理论最终必须与实验相结合。这项练习演示了如何利用味物理观测量（例如中性K介子系统中的间接CP破坏参数 $\\epsilon_K$）的精确测量值来约束CKM矩阵的基本参数。你将进行一次灵敏度分析，以量化理论输入（如粲夸克质量）的不确定性如何传播到幺正三角顶点 $(\\bar{\\rho}, \\bar{\\eta})$ 的允许区域，从而让你一窥粒子物理现象学家的日常工作。[@problem_id:3507844]", "problem": "考虑标准模型(SM)的Cabibbo-Kobayashi-Maskawa (CKM)框架内的中性K介子间接电荷-宇称(CP)破坏参数$\\epsilon_K$。$\\epsilon_K$对粲夸克质量和短程量子色动力学(QCD)修正因子$\\eta_{ct}$的灵敏度，可以通过检验$\\epsilon_K$对进入$\\Delta S = 2$有效哈密顿量的输入的依赖性来评估。使用在SM中经单圈计算并包含Inami-Lim函数和短程QCD修正的、经过充分检验的混合振幅$M_{12}^K$的短程表达式，并将小的输入变化传播到对幺正三角的Wolfenstein顶点$(\\bar{\\rho},\\bar{\\eta})$的约束中。所有质量必须以$\\text{GeV}$为单位，最终的数值输出是无量纲的。\n\n请基于以下基础定义和事实进行计算：\n- 相关的CKM组合为$\\lambda_i \\equiv V_{is}^* V_{id}$。在Wolfenstein参数化的领头非平凡阶，\n  $$\\lambda_c \\approx -\\lambda\\left(1 - \\frac{\\lambda^2}{2}\\right), \\quad \\lambda_t \\approx -A^2 \\lambda^5 \\left(1 - \\bar{\\rho} - i \\bar{\\eta}\\right).$$\n- SM中的色散混合振幅为\n  $$M_{12}^K \\;=\\; \\frac{G_F^2\\,M_W^2}{12\\pi^2}\\, f_K^2\\, m_K\\, \\hat{B}_K \\left[ \\lambda_c^2\\,\\eta_{cc}\\,S_0(x_c) \\;+\\; \\lambda_t^2\\,\\eta_{tt}\\,S_0(x_t) \\;+\\; 2\\,\\lambda_c\\lambda_t\\,\\eta_{ct}\\,S_0(x_c,x_t)\\right],$$\n  其中$x_q \\equiv m_q^2/M_W^2$且$q \\in \\{c,t\\}$。用于同味和混合味盒图的Inami-Lim函数为\n  $$S_0(x) \\;=\\; x\\left[ \\frac{4 - 11x + x^2}{4(1-x)^2} \\;-\\; \\frac{3x^2 \\ln x}{2(1-x)^3} \\right],$$\n  $$S_0(x_c,x_t) \\;\\approx\\; x_c \\left[ \\ln\\!\\left(\\frac{x_t}{x_c}\\right) \\;-\\; \\frac{3x_t}{4(1-x_t)} \\;-\\; \\frac{3x_t^2 \\ln x_t}{4(1-x_t)^2} \\right],$$\n  这是在K介子混合中有效的小$x_c$标准近似。\n- 间接CP破坏参数的大小取为\n  $$|\\epsilon_K| \\;=\\; \\kappa_\\epsilon\\, \\frac{\\left| \\mathrm{Im}\\, M_{12}^K \\right|}{\\Delta M_K},$$\n  其中$\\kappa_\\epsilon$是一个已知的修正因子，包含了长程和相位效应，$\\Delta M_K$是中性K介子质量差。此定义在量纲上是一致的，因为$M_{12}^K$和$\\Delta M_K$的质量量纲都为1。\n\n对于数值评估，请使用以下基准参数（所有质量以$\\text{GeV}$为单位，所有输出均为无量纲）：\n- 费米常数：$G_F = 1.1663787\\times 10^{-5}\\ \\text{GeV}^{-2}$。\n- W玻色子质量：$M_W = 80.379$。\n- K介子衰变常数：$f_K = 0.1557$。\n- 中性K介子质量：$m_K = 0.497611$。\n- 中性K介子质量差：$\\Delta M_K = 3.484\\times 10^{-15}$。\n- 重整化群不变的K介子袋参数：$\\hat{B}_K = 0.762$。\n- 短程QCD因子：$\\eta_{cc} = 1.87$，$\\eta_{tt} = 0.5765$，基准$\\eta_{ct} = 0.496$。\n- Wolfenstein参数：$\\lambda = 0.2253$, $A = 0.826$，基准$(\\bar{\\rho},\\bar{\\eta}) = (0.159,0.348)$。\n- 顶夸克质量（修改的最小减除，$\\overline{\\mathrm{MS}}$）：$m_t = 163.0$。\n- 粲夸克质量（修改的最小减除，$\\overline{\\mathrm{MS}}$）基准：$m_c = 1.27$。\n- 长程修正因子：$\\kappa_\\epsilon = 0.94$。\n\n灵敏度任务：\n- 将$\\epsilon_K$视为函数$|\\epsilon_K|(\\bar{\\rho},\\bar{\\eta}; m_c,\\eta_{ct})$，其中所有其他输入固定为上述基准值。\n- 在给定的基准$(\\bar{\\rho}_0,\\bar{\\eta}_0)$和$(m_{c,0},\\eta_{ct,0})$下，定义基准值$|\\epsilon_K|_0 \\equiv |\\epsilon_K|(\\bar{\\rho}_0,\\bar{\\eta}_0; m_{c,0},\\eta_{ct,0})$。\n- 对于$(m_c,\\eta_{ct})$在基准值附近的微小变化，定义诱导的变化\n  $$\\Delta \\epsilon \\;\\equiv\\; |\\epsilon_K|(\\bar{\\rho}_0,\\bar{\\eta}_0; m_c,\\eta_{ct}) \\;-\\; |\\epsilon_K|_0.$$\n- 令相对于顶点的梯度为\n  $$\\mathbf{g} \\;\\equiv\\; \\left(\\frac{\\partial |\\epsilon_K|}{\\partial \\bar{\\rho}},\\, \\frac{\\partial |\\epsilon_K|}{\\partial \\bar{\\eta}}\\right)\\Bigg|_{\\text{baseline}},$$\n  您可以通过对称有限差分进行数值评估，步长应足够小以确保数值稳定性。\n- 补偿$\\Delta \\epsilon$同时保持$|\\epsilon_K|$为其基准值的最小范数顶点位移$\\delta \\boldsymbol{\\theta} \\equiv (\\delta\\bar{\\rho},\\delta\\bar{\\eta})$由线性化约束$\\mathbf{g}\\cdot \\delta \\boldsymbol{\\theta} = -\\Delta \\epsilon$和最小欧几里得范数定义，其唯一解为\n  $$\\delta \\boldsymbol{\\theta} \\;=\\; -\\, \\frac{\\Delta \\epsilon}{\\|\\mathbf{g}\\|^2}\\, \\mathbf{g}.$$\n\n实现一个执行以下步骤的程序：\n1. 使用上述定义，在$(\\bar{\\rho}_0,\\bar{\\eta}_0)$处计算基准值$|\\epsilon_K|_0$和基准梯度$\\mathbf{g}$。\n2. 对于下方的每个测试案例，在固定的$(\\bar{\\rho}_0,\\bar{\\eta}_0)$和给定的$(m_c,\\eta_{ct})$下计算$\\Delta \\epsilon$。然后计算定义的最小范数顶点位移$\\delta \\boldsymbol{\\theta} = (\\delta\\bar{\\rho},\\delta\\bar{\\eta})$。\n3. 报告每个测试案例的$(\\delta\\bar{\\rho},\\delta\\bar{\\eta})$。\n\n测试套件（四个案例）：\n- 案例1（基准，正常路径）：$m_c = 1.27$，$\\eta_{ct} = 0.496$。\n- 案例2（向上改变粲夸克质量）：$m_c = 1.295$，$\\eta_{ct} = 0.496$。\n- 案例3（向上改变$\\eta_{ct}$）：$m_c = 1.27$，$\\eta_{ct} = 0.543$。\n- 案例4（两者向下改变，边缘情况）：$m_c = 1.245$，$\\eta_{ct} = 0.449$。\n\n所有质量输入必须以$\\text{GeV}$为单位，您的输出$(\\delta\\bar{\\rho},\\delta\\bar{\\eta})$必须报告为无量纲浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含四个案例的结果，形式为一个包含四个对的列表，每个对形如$[\\delta\\bar{\\rho},\\delta\\bar{\\eta}]$，且这四个对被包含在一个外部列表中。例如：[[dr1,de1],[dr2,de2],[dr3,de3],[dr4,de4]]。", "solution": "该问题被认为是有效的，因为它在粒子物理标准模型中有科学依据，数学上是适定的，并提供了一套自洽、一致的参数和定义。任务是计算Wolfenstein参数$(\\bar{\\rho},\\bar{\\eta})$所需的补偿性位移，以在粲夸克质量$m_c$和QCD修正因子$\\eta_{ct}$发生变化时，保持间接CP破坏参数$|\\epsilon_K|$恒定。\n\n解决方案分为几个步骤：\n1. 构建$|\\epsilon_K|$作为相关参数的函数的解析表达式。\n2. 计算$|\\epsilon_K|$相对于$(\\bar{\\rho},\\bar{\\eta})$的解析梯度。\n3. 实现数值计算以确定基准值$|\\epsilon_K|_0$和梯度$\\mathbf{g}$。\n4. 对于每个测试案例，计算诱导的变化$\\Delta\\epsilon$和相应的最小范数顶点位移$\\delta\\boldsymbol{\\theta} = (\\delta\\bar{\\rho},\\delta\\bar{\\eta})$。\n\n$|\\epsilon_K|$的理论构建\n\n间接CP破坏参数的大小由下式给出\n$$|\\epsilon_K| = \\kappa_\\epsilon \\frac{\\left| \\mathrm{Im}\\, M_{12}^K \\right|}{\\Delta M_K}$$\n其中色散混合振幅$M_{12}^K$为\n$$M_{12}^K = C_{\\text{pre}}' \\left[ \\lambda_c^2\\,\\eta_{cc}\\,S_0(x_c) + \\lambda_t^2\\,\\eta_{tt}\\,S_0(x_t) + 2\\,\\lambda_c\\lambda_t\\,\\eta_{ct}\\,S_0(x_c,x_t)\\right]$$\n其中实数前置因子$C_{\\text{pre}}' = \\frac{G_F^2 M_W^2}{12\\pi^2} f_K^2 m_K \\hat{B}_K$。\n\nCKM因子$\\lambda_c \\approx -\\lambda(1 - \\lambda^2/2)$为实数，而$\\lambda_t \\approx -A^2 \\lambda^5 (1 - \\bar{\\rho} - i \\bar{\\eta})$为复数。我们定义实数负常数$K_t \\equiv -A^2 \\lambda^5$。则$\\lambda_t = K_t(1 - \\bar{\\rho} - i\\bar{\\eta})$。\n\n$M_{12}^K$的虚部仅来自包含$\\lambda_t$的项：\n$$\\mathrm{Im}\\, M_{12}^K = C_{\\text{pre}}' \\, \\mathrm{Im} \\left[ \\lambda_t^2\\,\\eta_{tt}\\,S_0(x_t) + 2\\,\\lambda_c\\lambda_t\\,\\eta_{ct}\\,S_0(x_c,x_t)\\right]$$\nInami-Lim函数$S_0(x_q)$、$S_0(x_c,x_t)$和QCD因子$\\eta_{ij}$均为实数。CKM因子的虚部为：\n$$\\mathrm{Im}(\\lambda_t) = \\mathrm{Im}(K_t(1 - \\bar{\\rho} - i\\bar{\\eta})) = -K_t \\bar{\\eta}$$\n$$\\mathrm{Im}(\\lambda_t^2) = \\mathrm{Im}(K_t^2((1 - \\bar{\\rho})^2 - \\bar{\\eta}^2 - 2i\\bar{\\eta}(1-\\bar{\\rho}))) = -2K_t^2\\bar{\\eta}(1-\\bar{\\rho})$$\n\n将这些代入$\\mathrm{Im}\\, M_{12}^K$的表达式中：\n$$\\mathrm{Im}\\, M_{12}^K = C_{\\text{pre}}' \\left[ \\mathrm{Im}(\\lambda_t^2)\\,\\eta_{tt}\\,S_0(x_t) + 2\\,\\lambda_c\\,\\mathrm{Im}(\\lambda_t)\\,\\eta_{ct}\\,S_0(x_c,x_t)\\right]$$\n$$\\mathrm{Im}\\, M_{12}^K = C_{\\text{pre}}' \\left[ -2K_t^2\\bar{\\eta}(1-\\bar{\\rho})\\,\\eta_{tt}\\,S_0(x_t) - 2\\lambda_c K_t \\bar{\\eta}\\,\\eta_{ct}\\,S_0(x_c,x_t)\\right]$$\n$$\\mathrm{Im}\\, M_{12}^K = -2 C_{\\text{pre}}' \\bar{\\eta} \\left[ K_t^2(1-\\bar{\\rho})\\,\\eta_{tt}\\,S_0(x_t) + \\lambda_c K_t \\,\\eta_{ct}\\,S_0(x_c,x_t)\\right]$$\n此表达式中的所有参数（$C_{\\text{pre}}'$, $\\bar{\\eta}$, $\\eta_{tt}$, $S_0(x_t)$, $\\eta_{ct}$, $S_0(x_c,x_t)$, 和$1-\\bar{\\rho}$）均为正。乘积$K_t^2$和$\\lambda_c K_t$也为正，因为$K_t  0$且$\\lambda_c  0$。因此，方括号中的整个项为正，意味着$\\mathrm{Im}\\, M_{12}^K  0$。于是我们可以写出$|\\mathrm{Im}\\, M_{12}^K| = -\\mathrm{Im}\\, M_{12}^K$。\n\n$|\\epsilon_K|$的最终表达式为：\n$$|\\epsilon_K|(\\bar{\\rho},\\bar{\\eta}; m_c, \\eta_{ct}) = \\frac{2 \\kappa_\\epsilon C_{\\text{pre}}'}{\\Delta M_K} \\bar{\\eta} \\left[ K_t^2(1-\\bar{\\rho})\\eta_{tt}S_0(x_t) + \\lambda_c K_t \\eta_{ct}S_0(x_c, x_t)\\right]$$\n这个解析形式巧妙地揭示了对模型参数的依赖关系。$S_0(x_c, x_t)$项通过$x_c = m_c^2/M_W^2$依赖于$m_c$。\n\n梯度计算\n\n解析形式允许直接计算梯度$\\mathbf{g} = (\\frac{\\partial |\\epsilon_K|}{\\partial \\bar{\\rho}}, \\frac{\\partial |\\epsilon_K|}{\\partial \\bar{\\eta}})$，避免了有限差分的数值不准确性。\n$$\\frac{\\partial |\\epsilon_K|}{\\partial \\bar{\\rho}} = \\frac{2 \\kappa_\\epsilon C_{\\text{pre}}'}{\\Delta M_K} \\bar{\\eta} \\left[ -K_t^2 \\eta_{tt} S_0(x_t) \\right]$$\n$$\\frac{\\partial |\\epsilon_K|}{\\partial \\bar{\\eta}} = \\frac{2 \\kappa_\\epsilon C_{\\text{pre}}'}{\\Delta M_K} \\left[ K_t^2(1-\\bar{\\rho})\\eta_{tt}S_0(x_t) + \\lambda_c K_t \\eta_{ct}S_0(x_c, x_t)\\right] = \\frac{|\\epsilon_K|}{\\bar{\\eta}}$$\n梯度$\\mathbf{g}$在基准参数集$(\\bar{\\rho}_0,\\bar{\\eta}_0; m_{c,0},\\eta_{ct,0})$处进行评估。\n\n灵敏度分析\n\n寻找补偿性顶点位移$\\delta\\boldsymbol{\\theta} = (\\delta\\bar{\\rho}, \\delta\\bar{\\eta})$的步骤如下：\n1.  计算基准值$|\\epsilon_K|_0 = |\\epsilon_K|(\\bar{\\rho}_0, \\bar{\\eta}_0; m_{c,0}, \\eta_{ct,0})$。\n2.  对于每个具有参数$(m_c, \\eta_{ct})$的测试案例，计算扰动值$|\\epsilon_K|' = |\\epsilon_K|(\\bar{\\rho}_0, \\bar{\\eta}_0; m_c, \\eta_{ct})$。\n3.  计算差值$\\Delta\\epsilon = |\\epsilon_K|' - |\\epsilon_K|_0$。\n4.  在基准点计算梯度向量$\\mathbf{g}$。\n5.  满足线性化约束$\\mathbf{g} \\cdot \\delta\\boldsymbol{\\theta} = -\\Delta\\epsilon$的最小补偿位移$\\delta\\boldsymbol{\\theta}$通过投影到梯度方向找到：\n    $$\\delta\\boldsymbol{\\theta} = -\\frac{\\Delta\\epsilon}{\\|\\mathbf{g}\\|^2} \\mathbf{g}$$\n\n计算策略\n\n实现将包含一个主函数，用于根据上面推导的解析表达式计算$|\\epsilon_K|$。该函数将用于计算$|\\epsilon_K|_0$、每个测试案例的$\\Delta\\epsilon$以及梯度$\\mathbf{g}$的分量。然后根据公式为每个测试案例计算最终的位移$\\delta\\boldsymbol{\\theta}$。测试参数与基准参数相匹配的案例将作为一种验证，因为它必须产生$\\Delta\\epsilon = 0$并因此得到$\\delta\\boldsymbol{\\theta}=(0,0)$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the sensitivity of the CKM unitarity triangle apex (rho_bar, eta_bar)\n    to variations in the charm quark mass and QCD correction factors, in the context\n    of indirect CP violation in the neutral kaon system (epsilon_K).\n    \"\"\"\n\n    # Baseline parameters (masses in GeV)\n    G_F = 1.1663787e-5  # GeV^-2\n    M_W = 80.379\n    f_K = 0.1557\n    m_K = 0.497611\n    Delta_M_K = 3.484e-15\n    B_K_hat = 0.762\n    eta_cc = 1.87\n    eta_tt = 0.5765\n    eta_ct_0 = 0.496\n    lam = 0.2253  # Wolfenstein lambda\n    A = 0.826\n    rho_bar_0 = 0.159\n    eta_bar_0 = 0.348\n    m_t = 163.0\n    m_c_0 = 1.27\n    kappa_epsilon = 0.94\n\n    # Test cases for (m_c, eta_ct)\n    test_cases = [\n        (1.27, 0.496),   # Case 1: Baseline\n        (1.295, 0.496),  # Case 2: Vary m_c up\n        (1.27, 0.543),   # Case 3: Vary eta_ct up\n        (1.245, 0.449),  # Case 4: Vary both down\n    ]\n\n    def S0_x(x):\n        \"\"\"Inami-Lim function S0(x).\"\"\"\n        if x == 1.0:\n            return np.nan # Avoid division by zero, though not expected for c, t quarks\n        term1 = (4.0 - 11.0 * x + x**2) / (4.0 * (1.0 - x)**2)\n        term2 = (3.0 * x**2 * np.log(x)) / (2.0 * (1.0 - x)**3)\n        return x * (term1 - term2)\n\n    def S0_xc_xt(xc, xt):\n        \"\"\"Inami-Lim function S0(xc, xt) in the small-xc approximation.\"\"\"\n        if xt == 1.0:\n            return np.nan # Avoid division by zero\n        term1 = np.log(xt / xc)\n        term2 = 3.0 * xt / (4.0 * (1.0 - xt))\n        term3 = 3.0 * xt**2 * np.log(xt) / (4.0 * (1.0 - xt)**2)\n        return xc * (term1 - term2 - term3)\n\n    def calculate_epsilon_k(rho_bar, eta_bar, m_c, eta_ct):\n        \"\"\"\n        Calculates the magnitude of the CP violation parameter |epsilon_K|.\n        - rho_bar, eta_bar: Wolfenstein parameters\n        - m_c: Charm quark mass in GeV\n        - eta_ct: Short-distance QCD factor\n        \"\"\"\n        # Derived constants and intermediate variables\n        xc = (m_c / M_W)**2\n        xt = (m_t / M_W)**2\n        \n        # CKM parameters\n        lam_c = -lam * (1.0 - lam**2 / 2.0)\n        K_t = -A**2 * lam**5\n        \n        # Inami-Lim functions\n        S0_xt_val = S0_x(xt)\n        S0_xc_xt_val = S0_xc_xt(xc, xt)\n        \n        # Prefactor for M_12\n        C_pre = (G_F**2 * M_W**2) / (12.0 * np.pi**2) * f_K**2 * m_K * B_K_hat\n        \n        # Expression for Im(M_12^K)\n        # Im(M_12^K) = -2 * C_pre * eta_bar * [K_t^2*(1-rho_bar)*eta_tt*S0_xt + lambda_c*K_t*eta_ct*S0_xc_xt]\n        # Since Im(M_12^K) is negative, |Im(M_12^K)| = -Im(M_12^K)\n        \n        term_tt = K_t**2 * (1.0 - rho_bar) * eta_tt * S0_xt_val\n        term_ct = lam_c * K_t * eta_ct * S0_xc_xt_val\n        \n        im_M12 = -2.0 * C_pre * eta_bar * (term_tt + term_ct)\n        \n        # |epsilon_K|\n        abs_epsilon_k = kappa_epsilon * abs(im_M12) / Delta_M_K\n        \n        return abs_epsilon_k\n\n    # 1. Compute baseline |epsilon_K|_0\n    epsilon_k_0 = calculate_epsilon_k(rho_bar_0, eta_bar_0, m_c_0, eta_ct_0)\n    \n    # 2. Compute the baseline gradient g = (d|eps|/d(rho_bar), d|eps|/d(eta_bar))\n    # Using analytical derivatives for precision.\n    \n    # Common constants for gradient calculation\n    xt_0 = (m_t / M_W)**2\n    lam_c = -lam * (1.0 - lam**2 / 2.0)\n    K_t = -A**2 * lam**5\n    S0_xt_val_0 = S0_x(xt_0)\n    C_pre = (G_F**2 * M_W**2) / (12.0 * np.pi**2) * f_K**2 * m_K * B_K_hat\n    const_factor = (2.0 * kappa_epsilon * C_pre) / Delta_M_K\n\n    # d|eps|/d(rho_bar) = const_factor * eta_bar * [-K_t^2 * eta_tt * S0(xt)]\n    grad_rho = const_factor * eta_bar_0 * (-K_t**2 * eta_tt * S0_xt_val_0)\n    \n    # d|eps|/d(eta_bar) = |epsilon_K| / eta_bar\n    grad_eta = epsilon_k_0 / eta_bar_0\n    \n    g = np.array([grad_rho, grad_eta])\n    g_norm_sq = np.dot(g, g)\n\n    results = []\n    for m_c_case, eta_ct_case in test_cases:\n        # 3. Compute Delta_epsilon for the current test case\n        epsilon_k_case = calculate_epsilon_k(rho_bar_0, eta_bar_0, m_c_case, eta_ct_case)\n        delta_epsilon = epsilon_k_case - epsilon_k_0\n        \n        # 4. Compute the minimal-norm apex shift delta_theta\n        if g_norm_sq == 0:\n            # This case shouldn't happen unless the gradient is null\n            delta_theta = np.array([0.0, 0.0])\n        else:\n            delta_theta = - (delta_epsilon / g_norm_sq) * g\n\n        delta_rho, delta_eta = delta_theta\n        results.append(f\"[{delta_rho},{delta_eta}]\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3507844"}]}