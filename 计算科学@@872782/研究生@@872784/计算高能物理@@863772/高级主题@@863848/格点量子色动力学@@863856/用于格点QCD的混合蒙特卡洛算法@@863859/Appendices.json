{"hands_on_practices": [{"introduction": "混合蒙特卡罗（HMC）算法的核心在于其分子动力学部分，它使用数值积分器在虚构的时间中演化系统。这个练习 [@problem_id:3516854] 提供了一个基础性的实践：在一个简化的 $\\mathrm{SU}(2)$ 规范连线上推导力并实现一个对称的蛙跳积分步。通过分析哈密顿量的局部误差，我们可以验证积分器的理论精度，这是构建任何HMC代码的第一步。", "problem": "实现、分析并测试一个用于格点量子色动力学（QCD）混合蒙特卡罗（HMC）积分器的单步对称蛙跳更新，该更新针对单个规范连线，并专用于二阶特殊酉群（$\\mathrm{SU}(2)$）。你必须从第一性原理出发推导力，并以单步之后哈密顿量的漂移来量化积分器的主要局部误差。\n\n从以下基本基础开始：\n- 规范连线 $U$ 是 $\\mathrm{SU}(2)$ 的一个元素，即一个行列式为 1 的 $2\\times 2$ 复酉矩阵。\n- 共轭动量 $P$ 是李代数 $\\mathfrak{su}(2)$ 的一个元素，即一个 $2\\times 2$ 的无迹反厄米矩阵。\n- 哈密顿量是可分的：$H(U,P) = T(P) + S(U)$，其中动能项为 $T(P) = -\\tfrac{1}{2}\\operatorname{Re}\\operatorname{Tr}(P^{2})$（由 $\\mathfrak{su}(2)$ 上的右不变度规 $\\langle A,B\\rangle = -\\operatorname{Re}\\operatorname{Tr}(A B)$ 导出），势能项为 $S(U) = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(U M^{\\dagger})$，其中 $\\alpha  0$ 是一个实数耦合常数，且 $M\\in \\mathrm{SU}(2)$ 是一个固定的类U型矩阵。\n- $U$ 的变分形式为 $\\delta U = A U$，其中 $A\\in \\mathfrak{su}(2)$，力 $F(U)\\in \\mathfrak{su}(2)$ 由 $\\delta S = \\langle F(U), A\\rangle$ 对所有这样的 $A$ 定义。\n- 群流形上的辛动力学遵循哈密顿方程：$\\dot U = P U$ 和 $\\dot P = -F(U)$。\n- 步长为 $\\epsilon$ 的对称蛙跳（也称为速度 Verlet）更新是半步动量推进、整步连线漂移和半步动量推进的复合。\n\n任务：\n1) 从上述基础出发，推导出力 $F(U)$ 关于 $U$ 和 $M$ 的显式表达式，过程中需明确使用内积 $\\langle \\cdot,\\cdot\\rangle$ 和到 $\\mathfrak{su}(2)$ 上的投影。你必须仅使用 $\\delta U = A U$（其中 $A\\in \\mathfrak{su}(2)$）以及 $\\mathrm{SU}(2)$ 是具有给定内积的酉群子群这些性质。你的最终表达式必须是一个仅由 $U$ 和 $M$ 构造的矩阵到 $\\mathfrak{su}(2)$ 上的投影。\n2) 使用推导出的力，实现一个单步对称蛙跳：\n- 半步推进：$P \\leftarrow P - \\tfrac{\\epsilon}{2} F(U)$。\n- 漂移：$U \\leftarrow \\exp(\\epsilon P)\\, U$，其中指数是矩阵指数，将 $\\mathfrak{su}(2)$ 映射到 $\\mathrm{SU}(2)$。\n- 半步推进：$P \\leftarrow P - \\tfrac{\\epsilon}{2} F(U)$。\n确保 $U\\in \\mathrm{SU}(2)$ 和 $P\\in \\mathfrak{su}(2)$ 在数值舍入误差范围内得以保持。你可以使用 $\\mathrm{SU}(2)$ 中的闭式指数函数或通用的矩阵指数函数。\n3) 对下面的每个测试用例，计算初始状态的哈密顿量值 $H_{\\text{before}} = H(U,P)$ 和经过一步蛙跳后的哈密顿量值 $H_{\\text{after}} = H(U',P')$。定义局部能量误差 $\\Delta H = H_{\\text{after}} - H_{\\text{before}}$。通过缩放量 $C \\approx \\Delta H/\\epsilon^{3}$ 来估计首项 $\\mathcal{O}(\\epsilon^{3})$ 误差系数。\n4) 角度必须以弧度为单位进行解释和计算。\n5) 你的程序必须产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，即 $[C_{1},C_{2},C_{3}]$，其中 $C_{k}$ 是测试用例 $k$ 的浮点数值。\n\n测试套件规范。使用泡利矩阵 $\\sigma_{1},\\sigma_{2},\\sigma_{3}$ 和以下参数化：\n- 对于任意满足 $\\lVert \\mathbf{n}\\rVert=1$ 的实轴向量 $\\mathbf{n}$ 和角度 $\\theta$，定义 $U(\\theta,\\mathbf{n}) = \\exp\\!\\big(i\\,\\theta\\, \\mathbf{n}\\cdot \\boldsymbol{\\sigma}\\big) = \\cos(\\theta)\\,\\mathbf{1}_{2} + i \\sin(\\theta)\\,\\mathbf{n}\\cdot \\boldsymbol{\\sigma}$，该矩阵属于 $\\mathrm{SU}(2)$。\n- 对于任意实向量 $\\mathbf{w}$，定义 $P(\\mathbf{w}) = i\\,\\mathbf{w}\\cdot \\boldsymbol{\\sigma}\\in \\mathfrak{su}(2)$。\n\n实现并评估以下三个案例：\n- 案例 1（一般情况）：\n  - $\\alpha = 1.1$，$\\epsilon = 0.05$。\n  - $U = U(\\theta_{U}, \\mathbf{n}_{U})$，其中 $\\theta_{U} = 0.8$，$\\mathbf{n}_{U} = \\frac{(1,2,3)}{\\lVert(1,2,3)\\rVert}$。\n  - $M = U(\\theta_{M}, \\mathbf{n}_{M})$，其中 $\\theta_{M} = 0.3$，$\\mathbf{n}_{M} = (0,1,0)$。\n  - $P = P(\\mathbf{w})$，其中 $\\mathbf{w} = 0.4\\,(1,0,0)$。\n- 案例 2（小步长以探测标度行为）：\n  - $\\alpha = 0.9$，$\\epsilon = 0.01$。\n  - $U = U(\\theta_{U}, \\mathbf{n}_{U})$，其中 $\\theta_{U} = 1.2$，$\\mathbf{n}_{U} = \\frac{(0.3,0.4,0.5)}{\\lVert(0.3,0.4,0.5)\\rVert}$。\n  - $M = U(\\theta_{M}, \\mathbf{n}_{M})$，其中 $\\theta_{M} = 0.7$，$\\mathbf{n}_{M} = (0,0,1)$。\n  - $P = P(\\mathbf{w})$，其中 $\\mathbf{w} = 0.2\\,\\frac{(0.2,0.8,0.5)}{\\lVert(0.2,0.8,0.5)\\rVert}$。\n- 案例 3（初始动量为零的边界情况）：\n  - $\\alpha = 1.5$，$\\epsilon = 0.02$。\n  - $U = U(\\theta_{U}, \\mathbf{n}_{U})$，其中 $\\theta_{U} = 0.5$，$\\mathbf{n}_{U} = \\frac{(0,1,1)}{\\lVert(0,1,1)\\rVert}$。\n  - $M = U(\\theta_{M}, \\mathbf{n}_{M})$，其中 $\\theta_{M} = 1.0$，$\\mathbf{n}_{M} = (1,0,0)$。\n  - $P = P(\\mathbf{w})$，其中 $\\mathbf{w} = (0,0,0)$。\n\n最终输出格式：\n- 你的程序必须精确打印一行形如 $[C_{1},C_{2},C_{3}]$ 的内容，其中每个 $C_{k}$ 是对应案例的 $\\Delta H/\\epsilon^{3}$ 的浮点估计值，不得包含任何额外文本。", "solution": "我们将此构造基于李群 $\\mathrm{SU}(2)$ 上的哈密顿动力学，其具有右不变动能和一个类规范势。基本定义如下：\n- 连线 $U\\in \\mathrm{SU}(2)$ 通过 $\\dot U = P U$ 演化，其中 $P\\in \\mathfrak{su}(2)$ 是右不变动量。\n- 动量通过 $\\dot P = -F(U)$ 演化，其中力 $F(U)$ 是势能 $S(U)$ 相对于 $\\mathfrak{su}(2)$ 上的右不变度规 $\\langle A,B\\rangle = -\\operatorname{Re}\\operatorname{Tr}(A B)$ 的变分导数。\n\n力的推导。设作用量为 $S(U) = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(U M^{\\dagger})$，其中给定 $M\\in \\mathrm{SU}(2)$ 且 $\\alpha0$。$U$ 在点 $U$ 处切于 $\\mathrm{SU}(2)$ 的一个普遍变分是 $\\delta U = A U$，其中 $A\\in \\mathfrak{su}(2)$。计算一阶变分：\n\n$$\n\\delta S \\;=\\; -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(\\delta U\\, M^{\\dagger})\n\\;=\\; -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(A\\, U M^{\\dagger}).\n$$\n\n我们希望将 $\\delta S$ 表示为 $\\delta S = \\langle F(U), A\\rangle = -\\operatorname{Re}\\operatorname{Tr}(F(U)\\, A)$ 的形式，该形式对所有 $A\\in \\mathfrak{su}(2)$ 均成立。注意以下两个事实：\n- 对于任意 $A\\in \\mathfrak{su}(2)$ 和任意矩阵 $X$，有 $\\operatorname{Re}\\operatorname{Tr}(A X) = \\operatorname{Re}\\operatorname{Tr}\\big(A\\, \\tfrac{1}{2}(X - X^{\\dagger})\\big)$，因为 $A$ 是反厄米矩阵，在实迹运算中与厄米部分配对为零。\n- 如果我们给 $F(U)$ 加上单位矩阵的任何倍数，它与 $A$ 的配对也为零，因为 $\\operatorname{Tr}(A) = 0$。\n\n因此，要使 $\\delta S = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(A\\, U M^{\\dagger})$ 对所有 $A\\in \\mathfrak{su}(2)$ 都等于 $-\\operatorname{Re}\\operatorname{Tr}(F(U) A)$，只需选择 $F(U)$ 作为 $\\alpha\\, U M^{\\dagger}$ 在由 $-\\operatorname{Re}\\operatorname{Tr}(\\cdot\\,\\cdot)$ 导出的内积下到 $\\mathfrak{su}(2)$ 上的投影。将反厄米投影写为 $\\mathrm{AH}(X) = \\tfrac{1}{2}(X - X^{\\dagger})$，然后再移除迹，力即为\n\n$$\nF(U) \\;=\\; \\mathrm{proj}_{\\mathfrak{su}(2)}\\!\\big(\\alpha\\, U M^{\\dagger}\\big)\n\\;=\\; \\alpha\\left[\\tfrac{1}{2}\\big( U M^{\\dagger} - M U^{\\dagger}\\big) \\;-\\; \\tfrac{1}{2}\\operatorname{Tr}\\!\\left(\\tfrac{1}{2}\\big( U M^{\\dagger} - M U^{\\dagger}\\big)\\right)\\mathbf{1}_{2}\\right].\n$$\n\n根据构造，$F(U)\\in \\mathfrak{su}(2)$ 并且对所有 $A\\in \\mathfrak{su}(2)$ 都满足 $\\delta S = -\\operatorname{Re}\\operatorname{Tr}(F(U) A)$，因此哈密顿方程 $\\dot P = -F(U)$ 成立。\n\n蛙跳积分器。对于一个可分的哈密顿量 $H(U,P)=T(P)+S(U)$，步长为 $\\epsilon$ 的对称蛙跳法以 Strang 分裂的形式复合了 $T$ 和 $S$ 的精确流：\n- 在 $S$ 下的半步推进：$P \\leftarrow P - \\tfrac{\\epsilon}{2} F(U)$，其中 $U$ 固定。\n- 在 $T$ 下的漂移：$U \\leftarrow \\exp(\\epsilon P)\\, U$，其中 $P$ 固定。\n- 在 $S$ 下的半步推进：$P \\leftarrow P - \\tfrac{\\epsilon}{2} F(U)$，使用更新后的 $U$。\n\n在 $\\mathrm{SU}(2)$ 上，如果 $P\\in \\mathfrak{su}(2)$ 是反厄米无迹矩阵，那么对于某个 $\\mathbf{w}\\in \\mathbb{R}^{3}$，有 $P = i\\,\\mathbf{w}\\cdot \\boldsymbol{\\sigma}$ 且 $P^{2} = -\\lVert \\mathbf{w}\\rVert^{2}\\,\\mathbf{1}_{2}$。因此指数函数有如下闭式解\n\n$$\n\\exp(\\epsilon P) \\;=\\; \\cos(\\epsilon \\lVert \\mathbf{w}\\rVert)\\,\\mathbf{1}_{2} \\;+\\; \\frac{\\sin(\\epsilon \\lVert \\mathbf{w}\\rVert)}{\\lVert \\mathbf{w}\\rVert}\\, P,\n$$\n\n当 $\\lVert \\mathbf{w}\\rVert \\to 0$ 时，其极限值为 $\\mathbf{1}_{2} + \\epsilon P$。这保证了只要通过推进的构造使 $P$ 保持在 $\\mathfrak{su}(2)$ 中，漂移就能在浮点误差范围内保持在 $\\mathrm{SU}(2)$ 上。\n\n哈密顿量和局部误差。对于 $T(P) = -\\tfrac{1}{2}\\operatorname{Re}\\operatorname{Tr}(P^{2})$ 和 $S(U) = -\\alpha\\, \\operatorname{Re}\\operatorname{Tr}(U M^{\\dagger})$，在一步蛙跳前后计算的哈密顿量得到\n\n$$\n\\Delta H \\;=\\; H_{\\text{after}} - H_{\\text{before}}.\n$$\n\n因为蛙跳法是一个二阶、对称、辛积分器，对于光滑的 $H$，其每步的局部能量误差标度为 $\\mathcal{O}(\\epsilon^{3})$。对于给定的一个小的 $\\epsilon$，可以通过计算 $C \\approx \\Delta H / \\epsilon^{3}$ 来估计首项系数。对于对称分裂，被精确守恒的修正（影子）哈密顿量与真实的 $H$ 相差 $\\mathcal{O}(\\epsilon^{2})$ 项，而观测到的 $H$ 本身的单步漂移是 $\\mathcal{O}(\\epsilon^{3})$，这是由于在单步对称更新中偶数阶项相互抵消所致。\n\n数值实现细节：\n- 将 $U$ 参数化为 $U(\\theta,\\mathbf{n}) = \\cos(\\theta)\\,\\mathbf{1}_{2} + i \\sin(\\theta)\\,\\mathbf{n}\\cdot \\boldsymbol{\\sigma}$（对于单位向量 $\\mathbf{n}$）可确保 $U\\in \\mathrm{SU}(2)$。\n- 将 $P$ 参数化为 $P(\\mathbf{w}) = i\\,\\mathbf{w}\\cdot \\boldsymbol{\\sigma}$ 可确保 $P\\in \\mathfrak{su}(2)$。\n- 投影 $\\mathrm{proj}_{\\mathfrak{su}(2)}(X)$ 的实现方式是先计算 $\\tfrac{1}{2}(X - X^{\\dagger})$，然后通过减去 $\\tfrac{1}{2}\\operatorname{Tr}(\\cdot)\\,\\mathbf{1}_{2}$ 来移除迹。\n- 漂移使用 $\\mathrm{SU}(2)$ 上的闭式指数函数，并仔细处理小范数极限的情况。\n- 哈密顿量各项是通过迹的实部计算得到的标量，没有物理单位，并且所有角度按要求均以弧度为单位。\n\n测试套件覆盖范围：\n- 案例 1 使用中等程度不对易的 $U$、$M$ 和非零的 $P$，并取 $\\epsilon = 0.05$ 来测试一般路径。\n- 案例 2 使用更小的 $\\epsilon = 0.01$ 来凸显 $\\epsilon^{3}$ 的标度行为。\n- 案例 3 使用零初始动量 $P=0$ 以及非平凡的 $U$ 和 $M$，以探测从静止状态开始的力推进的正确性。\n\n该程序为所有三个案例计算 $C_{k} = \\Delta H_{k}/\\epsilon_{k}^{3}$，并打印单行结果 $[C_{1},C_{2},C_{3}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Pauli matrices\nsigma1 = np.array([[0, 1], [1, 0]], dtype=complex)\nsigma2 = np.array([[0, -1j], [1j, 0]], dtype=complex)\nsigma3 = np.array([[1, 0], [0, -1]], dtype=complex)\npaulis = np.array([sigma1, sigma2, sigma3], dtype=complex)\nI2 = np.eye(2, dtype=complex)\n\ndef su2_from_axis_angle(theta: float, axis: np.ndarray) - np.ndarray:\n    \"\"\"\n    Construct U = cos(theta) I + i sin(theta) (n · sigma), for unit axis n.\n    \"\"\"\n    axis = np.asarray(axis, dtype=float)\n    nrm = np.linalg.norm(axis)\n    if nrm == 0.0:\n        return I2.copy()\n    n = axis / nrm\n    H = n[0] * sigma1 + n[1] * sigma2 + n[2] * sigma3  # Hermitian\n    return np.cos(theta) * I2 + 1j * np.sin(theta) * H\n\ndef p_from_vec(w: np.ndarray) - np.ndarray:\n    \"\"\"\n    Construct P = i (w · sigma), which is anti-Hermitian and traceless.\n    \"\"\"\n    w = np.asarray(w, dtype=float)\n    H = w[0] * sigma1 + w[1] * sigma2 + w[2] * sigma3  # Hermitian traceless\n    return 1j * H\n\ndef proj_su2(X: np.ndarray) - np.ndarray:\n    \"\"\"\n    Project a 2x2 complex matrix X onto su(2) using the inner product -Re Tr(A B).\n    This is the anti-Hermitian part with trace removed.\n    \"\"\"\n    AH = 0.5 * (X - X.conj().T)  # anti-Hermitian\n    tr = 0.5 * np.trace(AH)      # complex scalar; for su(2), subtract (tr)*I\n    return AH - tr * I2\n\ndef exp_su2(eps: float, P: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute exp(eps * P) for P in su(2) using the closed form:\n    exp(eps P) = cos(eps*|w|) I + (sin(eps*|w|)/|w|) P with P = i w·sigma.\n    Handles the small-norm limit stably.\n    \"\"\"\n    # Norm |w| satisfies: P^2 = -|w|^2 I, and -Tr(P^2)/2 = |w|^2\n    P2 = P @ P\n    # Tr(P^2) should be negative real\n    trP2 = np.trace(P2)\n    # Use real part for safety\n    w2 = -np.real(trP2) / 2.0\n    # Numerical guard\n    if w2  0:\n        # Clamp tiny negative due to numerical rounding\n        if w2 > -1e-14:\n            w2 = 0.0\n        else:\n            raise RuntimeError(\"Encountered negative w^2 beyond rounding.\")\n    wnorm = np.sqrt(w2)\n    if wnorm  1e-14:\n        # Use series expansion: exp(eps P) ≈ I + eps P + (eps^2/2) P^2\n        return I2 + eps * P + 0.5 * (eps ** 2) * (P2)\n    c = np.cos(eps * wnorm)\n    s_over_w = np.sin(eps * wnorm) / wnorm\n    return c * I2 + s_over_w * P\n\ndef force(U: np.ndarray, alpha: float, M: np.ndarray) - np.ndarray:\n    \"\"\"\n    F(U) = proj_su2(alpha * U * M†)\n    \"\"\"\n    return proj_su2(alpha * (U @ M.conj().T))\n\ndef kinetic(P: np.ndarray) - float:\n    # T(P) = -0.5 Re Tr(P^2)\n    return float(-0.5 * np.real(np.trace(P @ P)))\n\ndef potential(U: np.ndarray, alpha: float, M: np.ndarray) - float:\n    # S(U) = - alpha Re Tr(U M†)\n    return float(-alpha * np.real(np.trace(U @ M.conj().T)))\n\ndef hamiltonian(U: np.ndarray, P: np.ndarray, alpha: float, M: np.ndarray) - float:\n    return kinetic(P) + potential(U, alpha, M)\n\ndef leapfrog_step(U: np.ndarray, P: np.ndarray, alpha: float, M: np.ndarray, eps: float):\n    \"\"\"\n    Perform one symmetric leapfrog step:\n    P - P - (eps/2) F(U)\n    U - exp(eps P) U\n    P - P - (eps/2) F(U)\n    \"\"\"\n    # Half-kick\n    F = force(U, alpha, M)\n    P_half = P - 0.5 * eps * F\n    # Drift\n    R = exp_su2(eps, P_half)\n    U_new = R @ U\n    # Half-kick\n    F_new = force(U_new, alpha, M)\n    P_new = P_half - 0.5 * eps * F_new\n    return U_new, P_new\n\ndef case_general():\n    alpha = 1.1\n    eps = 0.05\n    # U: theta=0.8, axis=(1,2,3)/||...||\n    axis_U = np.array([1.0, 2.0, 3.0])\n    axis_U /= np.linalg.norm(axis_U)\n    U = su2_from_axis_angle(0.8, axis_U)\n    # M: theta=0.3, axis=(0,1,0)\n    M = su2_from_axis_angle(0.3, np.array([0.0, 1.0, 0.0]))\n    # P: w=0.4*(1,0,0)\n    P = p_from_vec(np.array([0.4, 0.0, 0.0]))\n    return U, P, alpha, M, eps\n\ndef case_small_step():\n    alpha = 0.9\n    eps = 0.01\n    # U: theta=1.2, axis=(0.3,0.4,0.5)/||...||\n    axis = np.array([0.3, 0.4, 0.5])\n    axis /= np.linalg.norm(axis)\n    U = su2_from_axis_angle(1.2, axis)\n    # M: theta=0.7, axis=(0,0,1)\n    M = su2_from_axis_angle(0.7, np.array([0.0, 0.0, 1.0]))\n    # P: w=0.2 * normalized (0.2,0.8,0.5)\n    w = np.array([0.2, 0.8, 0.5])\n    w = 0.2 * w / np.linalg.norm(w)\n    P = p_from_vec(w)\n    return U, P, alpha, M, eps\n\ndef case_zero_momentum():\n    alpha = 1.5\n    eps = 0.02\n    # U: theta=0.5, axis=(0,1,1)/||...||\n    axis = np.array([0.0, 1.0, 1.0])\n    axis /= np.linalg.norm(axis)\n    U = su2_from_axis_angle(0.5, axis)\n    # M: theta=1.0, axis=(1,0,0)\n    M = su2_from_axis_angle(1.0, np.array([1.0, 0.0, 0.0]))\n    # P: zero\n    P = np.zeros((2, 2), dtype=complex)\n    return U, P, alpha, M, eps\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        case_general(),\n        case_small_step(),\n        case_zero_momentum(),\n    ]\n\n    results = []\n    for U, P, alpha, M, eps in test_cases:\n        # Compute initial Hamiltonian\n        H_before = hamiltonian(U, P, alpha, M)\n        # One leapfrog step\n        U_new, P_new = leapfrog_step(U, P, alpha, M, eps)\n        # Compute final Hamiltonian\n        H_after = hamiltonian(U_new, P_new, alpha, M)\n        dH = H_after - H_before\n        # Estimate leading O(eps^3) coefficient\n        if eps == 0:\n            c = float('nan')\n        else:\n            c = dH / (eps ** 3)\n        results.append(c)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3516854"}, {"introduction": "真实的QCD模拟涉及大小和计算成本迥异的多种力，例如规范力和费米子力。这个练习 [@problem_id:3516754] 深入探讨了一种由 Sexton 和 Weingarten 提出的关键优化技术——多时间尺度积分方法。我们将学习如何在固定的计算预算下，通过调整不同力的步长来最小化总的能量漂移，这是进行高效模拟的一项关键技能。", "problem": "考虑用于格点量子色动力学 (QCD) 的混合蒙特卡洛 (HMC) 算法，其中作用量被分为规范部分 $S_{g}$ 和赝费米子部分 $S_{f}$。在一个使用可逆、辛、二阶更新的双层多重时间尺度积分方案 (Sexton–Weingarten 方案) 中，假设分子动力学轨迹长度固定为 $\\tau = 1$ (以分子动力学时间单位计)。令费米子力的粗略步数为 $N_{f}$，步长为 $h_{f} = \\tau / N_{f}$；规范子力的精细步数为 $N_{g}$，步长为 $h_{g} = \\tau / N_{g}$。定义时间尺度比为 $m = N_{g}/N_{f}$，因此 $h_{g} = h_{f}/m$。\n\n假设关于步长的领头阶期望能量差模型为\n$$\n\\langle \\Delta H \\rangle \\approx C_{g}\\, h_{g}^{2} + C_{f}\\, h_{f}^{2},\n$$\n其中有效系数由 $C_{i} = \\zeta_{i}\\, \\|F_{i}\\|^{2}$ 给出，$i \\in \\{g,f\\}$，$\\|F_{g}\\|$ 和 $\\|F_{f}\\|$ 分别表示测得的规范子力和费米子力的 $\\ell_{2}$ 范数，而 $\\zeta_{g}$ 和 $\\zeta_{f}$ 是测得的正常数，它们包含了积分器的主导对易子结构和流的几何信息。\n\n您已执行了简短的校准运行并测量得到\n- $\\|F_{g}\\| = 0.75$,\n- $\\|F_{f}\\| = 0.30$,\n- $\\zeta_{g} = 1.8$,\n- $\\zeta_{f} = 2.5$.\n\n每次力计算的计算成本为：规范子力 $c_{g} = 1$，费米子力 $c_{f} = 40$。对于单条轨迹，您有固定的总力计算预算 $B = 400$，这施加了以下约束\n$$\nN_{g}\\, c_{g} + N_{f}\\, c_{f} = B.\n$$\n\n在这些假设下，确定最优的实数值比率 $m = N_{g}/N_{f}$，使得在预算约束下，$\\langle \\Delta H \\rangle$ 的领头阶模型最小化。将您的最终答案表示为一个四舍五入到四位有效数字的单一数值。比率 $m$ 是无量纲的，因此不需要单位。", "solution": "用户要求我解决一个源于格点量子色动力学 (QCD) 的混合蒙特卡洛 (HMC) 算法背景下的约束优化问题。\n\n### 问题验证\n\n#### 步骤1：提取已知条件\n\n-   **算法背景**：用于格点QCD的混合蒙特卡洛 (HMC)。\n-   **作用量分解**：$S = S_g + S_f$，其中 $S_g$ 是规范部分，$S_f$ 是赝费米子部分。\n-   **积分方案**：使用可逆、辛、二阶更新的双层多重时间尺度积分 (Sexton–Weingarten)。\n-   **轨迹长度**：$\\tau = 1$ (分子动力学时间单位)。\n-   **步数**：$N_f$ 为粗略步数（费米子力），$N_g$ 为精细步数（规范子力）。\n-   **步长**：$h_f = \\tau / N_f$，$h_g = \\tau / N_g$。\n-   **时间尺度比**：$m = N_g / N_f$，这意味着 $h_g = h_f / m$。\n-   **能量差模型**：$\\langle \\Delta H \\rangle \\approx C_{g}\\, h_{g}^{2} + C_{f}\\, h_{f}^{2}$。\n-   **有效系数**：$C_{i} = \\zeta_{i}\\, \\|F_{i}\\|^{2}$，对于 $i \\in \\{g,f\\}$。\n-   **测得的校准数据**：\n    -   $\\|F_{g}\\| = 0.75$\n    -   $\\|F_{f}\\| = 0.30$\n    -   $\\zeta_{g} = 1.8$\n    -   $\\zeta_{f} = 2.5$\n-   **计算成本**：每次规范子力计算 $c_{g} = 1$，每次费米子力计算 $c_{f} = 40$。\n-   **计算预算**：单条轨迹的总成本由预算 $B = 400$ 固定。\n-   **预算约束**：$N_{g}\\, c_{g} + N_{f}\\, c_{f} = B$。\n-   **目标**：确定最优的实数值比率 $m = N_g/N_f$，使得在预算约束下 $\\langle \\Delta H \\rangle$ 最小。\n-   **输出要求**：$m$ 的最终答案必须四舍五入到四位有效数字。\n\n#### 步骤2：使用提取的已知条件进行验证\n\n-   **科学基础**：该问题在计算高能物理学领域有坚实的基础。Sexton–Weingarten 方案是HMC模拟中使用的标准多重时间尺度积分器。能量差的领头阶误差模型 $\\langle \\Delta H \\rangle$ 与步长的平方 ($h_g^2, h_f^2$) 成比例，这是二阶辛积分器的典型特征。计算成本的制定及其优化是大规模模拟中的核心和实际任务。所有前提都具有科学合理性。\n-   **良态问题**：该问题提供了一个明确的待最小化目标函数 ($\\langle \\Delta H \\rangle$)、一个明确定义的约束（预算 $B$），以及所有必需的常数和变量之间的关系。这种结构允许存在唯一解。\n-   **客观性**：该问题使用精确的数学和物理术语陈述，没有主观或模糊的语言。\n\n该问题没有任何无效性缺陷。它是一个标准的、定义明确的、具有科学相关性的约束优化问题。\n\n#### 步骤3：结论与行动\n\n问题陈述是**有效的**。开始求解。\n\n### 求解过程\n\n目标是在固定的计算预算下，最小化期望能量差 $\\langle \\Delta H \\rangle$。该问题可以表述为一个约束优化问题。\n\n需要最小化的量是能量差，我们将其表示为 $E$：\n$$ E = C_{g}\\, h_{g}^{2} + C_{f}\\, h_{f}^{2} $$\n步长与步数和轨迹长度 $\\tau=1$ 相关：\n$$ h_{f} = \\frac{\\tau}{N_{f}} = \\frac{1}{N_{f}} \\quad \\text{以及} \\quad h_{g} = \\frac{\\tau}{N_{g}} = \\frac{1}{N_{g}} $$\n将这些代入 $E$ 的表达式，得到以 $N_f$ 和 $N_g$ 为变量的目标函数：\n$$ E(N_f, N_g) = \\frac{C_g}{N_g^2} + \\frac{C_f}{N_f^2} $$\n该最小化问题受计算预算约束：\n$$ N_{g}\\, c_{g} + N_{f}\\, c_{f} = B $$\n我们首先使用所提供的数据计算系数 $C_g$ 和 $C_f$ 的数值：\n$C_{g} = \\zeta_{g}\\, \\|F_{g}\\|^{2} = 1.8 \\times (0.75)^{2} = 1.8 \\times 0.5625 = 1.0125$。\n$C_{f} = \\zeta_{f}\\, \\|F_{f}\\|^{2} = 2.5 \\times (0.30)^{2} = 2.5 \\times 0.09 = 0.225$。\n\n为了解决这个约束优化问题，我们使用拉格朗日乘数法。拉格朗日量 $\\mathcal{L}$ 为：\n$$ \\mathcal{L}(N_f, N_g, \\lambda) = \\left( \\frac{C_g}{N_g^2} + \\frac{C_f}{N_f^2} \\right) + \\lambda (N_{g}\\, c_{g} + N_{f}\\, c_{f} - B) $$\n为了找到极值，我们将 $\\mathcal{L}$ 对 $N_f$、$N_g$ 和 $\\lambda$ 的偏导数设为零。我们主要关心的是使 $E$ 最小化的 $N_f$ 和 $N_g$ 之间的关系。\n$$ \\frac{\\partial \\mathcal{L}}{\\partial N_g} = -\\frac{2 C_g}{N_g^3} + \\lambda c_g = 0 \\implies \\lambda c_g = \\frac{2 C_g}{N_g^3} $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial N_f} = -\\frac{2 C_f}{N_f^3} + \\lambda c_f = 0 \\implies \\lambda c_f = \\frac{2 C_f}{N_f^3} $$\n我们可以从两个方程中解出拉格朗日乘子 $\\lambda$：\n$$ \\lambda = \\frac{2 C_g}{c_g N_g^3} \\quad \\text{以及} \\quad \\lambda = \\frac{2 C_f}{c_f N_f^3} $$\n令 $\\lambda$ 的两个表达式相等，得到最优性条件：\n$$ \\frac{2 C_g}{c_g N_g^3} = \\frac{2 C_f}{c_f N_f^3} $$\n$$ \\frac{C_g}{c_g N_g^3} = \\frac{C_f}{c_f N_f^3} $$\n我们想要求解最优比率 $m = N_g/N_f$。重排方程以求解 $N_g/N_f$：\n$$ \\frac{N_g^3}{N_f^3} = \\frac{C_g c_f}{C_f c_g} $$\n$$ \\left(\\frac{N_g}{N_f}\\right)^3 = \\frac{c_f C_g}{c_g C_f} $$\n$$ m^3 = \\frac{c_f C_g}{c_g C_f} $$\n对两边取立方根，得到最优比率 $m$ 的表达式：\n$$ m = \\left( \\frac{c_f C_g}{c_g C_f} \\right)^{1/3} $$\n现在我们代入给定的数值：\n-   $c_g = 1$\n-   $c_f = 40$\n-   $C_g = 1.0125$\n-   $C_f = 0.225$\n\n$$ m = \\left( \\frac{40 \\times 1.0125}{1 \\times 0.225} \\right)^{1/3} $$\n$$ m = \\left( \\frac{40.5}{0.225} \\right)^{1/3} $$\n为了简化分数：\n$$ \\frac{40.5}{0.225} = \\frac{40500}{225} = 180 $$\n所以，最优比率为：\n$$ m = (180)^{1/3} $$\n我们被要求提供一个四舍五入到四位有效数字的值。\n$$ m \\approx 5.646237 \\dots $$\n四舍五入到四位有效数字得到 $m = 5.646$。\n注意，预算 $B=400$ 并非求最优比率 $m$ 所必需，但若要求解 $N_f$ 和 $N_g$ 的实际值则需要用到：$N_g = m N_f \\implies (m c_g + c_f)N_f = B \\implies N_f = B / (m c_g + c_f)$。", "answer": "$$\\boxed{5.646}$$", "id": "3516754"}, {"introduction": "HMC算法的理论正确性依赖于其分子动力学积分器的时间可逆性。然而，数值不精确性，特别是不精确的费米子力计算，会破坏这一性质。这个练习 [@problem_id:3516849] 通过一个玩具模型展示了如何执行前向-后向可逆性检验来量化这些破坏。这是确保HMC模拟可靠性的一个必不可少的诊断工具。", "problem": "给定用于格点量子色动力学 (Lattice Quantum Chromodynamics, QCD) 的混合蒙特卡罗 (Hybrid Monte Carlo, HMC) 算法，考虑一个简化的阿贝尔格点规范模型，其中每个格点上的规范场是一个角度变量。设一个位形由具有 $V$ 个格点的角度向量 $U \\in \\mathbb{R}^{V}$ 和共轭动量 $P \\in \\mathbb{R}^{V}$ 表示。对单链接近似使用 Wilson 规范作用量，\n$$\nS_{\\text{g}}[U] = \\beta \\sum_{i=1}^{V} \\left(1 - \\cos U_i\\right),\n$$\n并定义哈密顿量\n$$\nH(U,P) = S_{\\text{g}}[U] + \\frac{1}{2} \\sum_{i=1}^{V} P_i^2.\n$$\n精确规范力为\n$$\nF(U) = \\frac{\\partial S_{\\text{g}}}{\\partial U} = \\beta \\, \\sin U,\n$$\n按分量施加。Hamilton 方程为\n$$\n\\frac{dU}{d\\tau} = \\frac{\\partial H}{\\partial P} = P, \\quad \\frac{dP}{d\\tau} = -\\frac{\\partial H}{\\partial U} = -F(U).\n$$\n使用步长为 $\\delta \\tau$ 且包含 $L$ 步的标准蛙跳积分法：\n1. 动量的半步更新：$P \\leftarrow P - \\frac{\\delta \\tau}{2} \\tilde{F}(U;\\epsilon)$。\n2. 对于 $s = 1,\\dots,L-1$，执行：\n   a. 坐标的全步更新：$U \\leftarrow U + \\delta \\tau \\, P$。\n   b. 动量的全步更新：$P \\leftarrow P - \\delta \\tau \\, \\tilde{F}(U;\\epsilon)$。\n3. 坐标的最终全步更新：$U \\leftarrow U + \\delta \\tau \\, P$。\n4. 动量的最终半步更新：$P \\leftarrow P - \\frac{\\delta \\tau}{2} \\tilde{F}(U;\\epsilon)$。\n\n在精确算术和精确力的情况下，蛙跳映射是时间可逆的。然而，在包含费米子的真实 HMC 中，不精确的线性求解会引入一个有限残差 $\\epsilon$，从而污染力。通过一个近似力来模拟这种有限精度和求解器残差的污染\n$$\n\\tilde{F}(U;\\epsilon) = F(U) + \\epsilon \\, \\lVert F(U) \\rVert_2 \\, \\hat{r},\n$$\n其中 $\\hat{r}$ 是一个单位向量，由一个伪随机数生成器种子确定性地构造，并且每次力计算时都会改变，$\\lVert \\cdot \\rVert_2$ 是欧几里得范数。这模拟了残差容忍度为 $\\epsilon$ 的共轭梯度 (Conjugate Gradient, CG) 方法所引入的力误差，该误差与 $\\epsilon$ 乘以真实力的范数成正比。前向-后向可逆性测试使用以下循环：\n- 从 $(U_0, P_0)$ 开始，计算 $H_0 = H(U_0,P_0)$。\n- 使用 $\\tilde{F}(U;\\epsilon)$ 运行 $L$ 步的前向轨迹，得到 $(U_1, P_1)$。\n- 翻转动量为 $(U_1, -P_1)$，并使用 $\\tilde{F}(U;\\epsilon)$ 运行 $L$ 步的后向轨迹，得到 $(U_2, P_2)$。\n- 计算循环能量差\n$$\n\\Delta H_{\\text{cycle}} = H(U_2, P_2) - H(U_0, P_0).\n$$\n\n你的任务是实现这个模型，并通过测量 $\\Delta H_{\\text{cycle}}$ 作为线性求解器残差 $\\epsilon$ 的函数，来量化由有限精度引起的可逆性违背。在这个玩具模型中，描绘并验证标度趋势 $\\Delta H_{\\text{cycle}} \\propto \\epsilon \\times \\lVert \\partial H/\\partial U \\rVert_2$，其中 $\\partial H/\\partial U = F(U)$。\n\n实现要求：\n- 使用上面定义的蛙跳积分法。\n- 使用近似力模型 $\\tilde{F}(U;\\epsilon)$。\n- 使用带有指定整数种子的确定性伪随机数生成器用于：\n  - 初始动量（零均值和单位方差的高斯分量）。\n  - 在每次力调用时构造单位向量 $\\hat{r}$。前向轨迹和后向轨迹使用不同的种子，以模拟与方向相关的有限精度差异。\n- 在起始位形 $(U_0,P_0)$ 处计算 $\\lVert \\partial H/\\partial U \\rVert_2$ 即 $\\lVert F(U_0) \\rVert_2$，用于解法中的诊断目的。程序的最终输出仅为整个测试套件的 $\\Delta H_{\\text{cycle}}$ 列表。\n\n单位：\n- 所有量都是无量纲的。不需要物理单位。\n\n测试套件：\n为以下参数集提供结果，每个参数集产生一个标量 $\\Delta H_{\\text{cycle}}$（一个浮点数）：\n1. 具有中等残差的一般情况：\n   - $V = 128$, $\\beta = 5.7$, $\\delta \\tau = 0.1$, $L = 50$, $\\epsilon = 10^{-8}$, 初始 $U_0$ 使用种子 $123456$ 从均值为 $0$、标准差为 $1$ 的正态分布中独立同分布地抽取，初始 $P_0$ 使用种子 $123457$ 从均值为 $0$、标准差为 $1$ 的正态分布中独立同分布地抽取，前向力噪声种子 $987650$，后向力噪声种子 $987651$。\n2. 精确力（无残差）的边界情况：\n   - $V = 128$, $\\beta = 5.7$, $\\delta \\tau = 0.1$, $L = 50$, $\\epsilon = 0$, 初始 $U_0$ 种子 $123456$, 初始 $P_0$ 种子 $123457$, 前向种子 $111111$, 后向种子 $222222$。\n3. 小残差：\n   - $V = 128$, $\\beta = 5.7$, $\\delta \\tau = 0.1$, $L = 50$, $\\epsilon = 10^{-10}$, 初始 $U_0$ 种子 $123456$, 初始 $P_0$ 种子 $123457$, 前向种子 $333333$, 后向种子 $444444$。\n4. 较大残差：\n   - $V = 128$, $\\beta = 5.7$, $\\delta \\tau = 0.1$, $L = 50$, $\\epsilon = 10^{-6}$, 初始 $U_0$ 种子 $123456$, 初始 $P_0$ 种子 $123457$, 前向种子 $555555$, 后向种子 $666666$。\n5. 初始规范力范数消失的边缘情况：\n   - $V = 128$, $\\beta = 5.7$, $\\delta \\tau = 0.1$, $L = 50$, $\\epsilon = 10^{-8}$, 初始 $U_0$ 设置为零向量, 初始 $P_0$ 种子 $777777$, 前向种子 $888888$, 后向种子 $999999$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含五个测试用例的 $\\Delta H_{\\text{cycle}}$ 结果，格式为逗号分隔的列表，并用方括号括起来（例如 $[r_1,r_2,r_3,r_4,r_5]$）。$r_i$ 必须以标准 Python 浮点数格式打印。此行前后不应打印任何其他文本。", "solution": "该问题要求实现并分析一个用于混合蒙特卡罗 (Hybrid Monte Carlo, HMC) 算法中可逆性违背的玩具模型。HMC 算法是现代格点量子色动力学 (Lattice Quantum Chromodynamics, QCD) 模拟的基石。HMC 算法生成遵循概率密度（该密度正比于 $e^{-S[U]}$）分布的位形 $U$，其中 $S[U]$ 是作用量。它通过引入虚拟动量 $P$ 并在相空间 $(U, P)$ 中模拟哈密顿动力学，然后进行 Metropolis-Hastings 接受步骤来实现这一点。此接受步骤的有效性关键依赖于用于分子动力学 (MD) 轨迹的数值积分器的性质，特别是其时间可逆性和保面积性（辛性）。\n\n所提供的模型将 QCD 的复杂动力学简化为 $V$ 个格点上的阿贝尔规范模型，其中位形由角度向量 $U = (U_1, \\dots, U_V)$ 描述。系统的演化由哈密顿量决定：\n$$\nH(U,P) = S_{\\text{g}}[U] + \\frac{1}{2} \\sum_{i=1}^{V} P_i^2\n$$\n其中 $S_{\\text{g}}[U] = \\beta \\sum_{i=1}^{V} (1 - \\cos U_i)$ 是 Wilson 规范作用量，第二项是动能。运动方程由 Hamilton 方程给出：\n$$\n\\frac{dU_i}{d\\tau} = \\frac{\\partial H}{\\partial P_i} = P_i\n$$\n$$\n\\frac{dP_i}{d\\tau} = -\\frac{\\partial H}{\\partial U_i} = -\\frac{\\partial S_{\\text{g}}}{\\partial U_i} = -\\beta \\sin U_i = -F_i(U)\n$$\n此处，$\\tau$ 是虚拟模拟时间， $F(U)$ 是规范力。\n\n这些方程使用蛙跳积分法进行数值求解，这是一种二阶辛方法。从时间 $\\tau$到 $\\tau + \\delta\\tau$ 的单步蛙跳积分可以写成算符的复合：动量的半步漂移、位置的全步漂移以及另一个动量的半步漂移。辛性确保了它保持相空间体积。至关重要的是，它也是时间可逆的。如果我们将从 $(U(\\tau), P(\\tau))$到 $(U(\\tau+\\delta\\tau), P(\\tau+\\delta\\tau))$ 的映射表示为 $\\Phi_{\\delta\\tau}$，那么反转时间步长 $\\delta\\tau \\to -\\delta\\tau$ 等价于反转该映射：$\\Phi_{-\\delta\\tau} = \\Phi_{\\delta\\tau}^{-1}$。一个实用的可逆性测试包括：首先以总时间 $T = L\\delta\\tau$ 向前运行一条轨迹，然后翻转最终动量 $P \\to -P$，再以后向方式运行相同的时间长度。对于一个完全可逆的积分器，系统会返回其精确的初始状态 $(U_0, P_0)$。\n\n在真实的 HMC 模拟中，特别是包含动力学费米子的模拟，力的计算成本非常高昂。它需要求解一个形如 $D\\psi = \\eta$ 的大型稀疏线性系统，其中 $D$ 是费米子矩阵。这通常通过像共轭梯度 (Conjugate Gradient, CG) 算法这样的迭代求解器来完成，当残差的范数达到某个容忍度 $\\epsilon$ 时，算法终止。这会在力计算中引入一个小的、等效的随机误差。该问题使用一个近似力来模拟此效应：\n$$\n\\tilde{F}(U;\\epsilon) = F(U) + \\epsilon \\, \\lVert F(U) \\rVert_2 \\, \\hat{r}\n$$\n其中 $F(U)$ 是精确的规范力，$\\lVert F(U) \\rVert_2$ 是其欧几里得范数，$\\hat{r}$ 是一个随机取向的单位向量，在每次力计算时都会改变。误差的量级与求解器容忍度 $\\epsilon$ 和力的量级成正比，这是一个符合实际的模型。\n\n这个误差项 $\\epsilon \\, \\lVert F(U) \\rVert_2 \\, \\hat{r}$ 的引入破坏了蛙跳积分法的时间可逆性。误差向量 $\\hat{r}$ 由伪随机数生成器 (PRNG) 生成。当通过翻转动量来反转轨迹时，后向路径中追踪的状态 $U$ 序列与前向路径中的大致相同，但 PRNG 的状态会继续演进。它会生成一个新的、独立的随机向量 $\\hat{r}$ 序列。前向轨迹的误差不会被后向轨迹的误差抵消，从而导致对初始状态的偏离。\n\n任务是通过测量一个完整前向-后向循环中的哈密顿量变化 $\\Delta H_{\\text{cycle}} = H(U_2, P_2) - H(U_0, P_0)$来量化这种违背。最终状态相对于初始状态的偏差 $(U_2 - U_0, P_2 - P_0)$ 预期为 $\\mathcal{O}(\\epsilon)$ 阶。通过泰勒展开，哈密顿量的变化为 $\\Delta H_{\\text{cycle}} \\approx \\nabla H \\cdot (U_2 - U_0, P_2 - P_0)$，这意味着 $\\Delta H_{\\text{cycle}}$ 也应该是 $\\mathcal{O}(\\epsilon)$ 阶。问题进一步提出了一个特定的标度关系 $\\Delta H_{\\text{cycle}} \\propto \\epsilon \\times \\lVert F(U_0) \\rVert_2$，我们将对此进行研究。\n\n实现将包括以下几个部分：\n1.  用于计算作用量 $S_{\\text{g}}[U]$ 和总哈密顿量 $H(U, P)$ 的函数。\n2.  用于计算近似力 $\\tilde{F}(U; \\epsilon)$ 的函数，该函数内部会计算精确力 $F(U) = \\beta \\sin U$ 并添加误差项。此函数将接受一个 PRNG 对象作为参数，以正确管理随机数序列的状态。\n3.  用于实现蛙跳积分法的函数，如问题中所述，该函数执行 $L$ 个大小为 $\\delta\\tau$ 的积分步。\n4.  为每个参数集执行完整可逆性测试的主程序：\n    a. 使用指定的种子初始化相空间坐标 $(U_0, P_0)$。\n    b. 计算初始能量 $H_0$。\n    c. 从 $(U_0, P_0)$ 开始，运行 $L$ 步的前向 MD 轨迹以得到 $(U_1, P_1)$，并为力噪声使用特定的 PRNG 种子。\n    d. 从 $(U_1, -P_1)$ 开始，运行 $L$ 步的后向 MD 轨迹以得到 $(U_2, P_2)$，并为力噪声使用不同的 PRNG 种子。\n    e. 计算最终能量 $H_2 = H(U_2, P_2)$ 和能量差 $\\Delta H_{\\text{cycle}} = H_2 - H_0$。\n\n测试套件旨在探究 $\\Delta H_{\\text{cycle}}$ 的行为：\n-   情况 1 ($V=128$, $\\beta=5.7$, $\\epsilon=10^{-8}$)：一个典型场景，应产生一个微小但可测量的可逆性违背。\n-   情况 2 ($\\epsilon=0$)：对照情况。使用精确力时，蛙跳积分法在标准浮点算术误差范围内是可逆的。$\\Delta H_{\\text{cycle}}$ 应接近于零（例如，约 $10^{-14}$ 或更小）。\n-   情况 3 和 4 ($\\epsilon=10^{-10}$ 和 $\\epsilon=10^{-6}$)：这些情况与情况 1 一起，用于测试 $\\Delta H_{\\text{cycle}}$ 随 $\\epsilon$ 的线性标度关系。我们预期结果相对于情况 1 会按 $10^{-2}$ 和 $10^2$ 的因子进行缩放。\n-   情况 5 ($U_0 = \\vec{0}$)：一个边缘情况，其中初始力为零，$\\lVert F(U_0) \\rVert_2 = 0$。这意味着在第一步时误差项也为零。然而，随着系统在非零初始动量 $P_0$ 的影响下演化，$U$ 变为非零，导致非零的力以及随后可逆性破坏误差的累积。这个案例表明，所提出的与 $\\lVert F(U_0) \\rVert_2$ 的简单标度关系可能具有误导性；一个更准确的标度关系将取决于整个轨迹上的积分力范数。结果仍应为非零，并大致与 $\\epsilon$ 成正比。\n\n通过执行这些测试，我们可以数值上验证关于 HMC 中求解器不精确性如何表现为对基本守恒定律和对称性违背的理论理解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_action(U, beta):\n    \"\"\"Calculates the Wilson gauge action for the U(1) model.\"\"\"\n    return beta * np.sum(1.0 - np.cos(U))\n\ndef calculate_hamiltonian(U, P, beta):\n    \"\"\"Calculates the Hamiltonian for the system.\"\"\"\n    action = calculate_action(U, beta)\n    kinetic_energy = 0.5 * np.sum(P**2)\n    return action + kinetic_energy\n\ndef exact_force(U, beta):\n    \"\"\"Calculates the exact gauge force F(U) = beta * sin(U).\"\"\"\n    return beta * np.sin(U)\n\ndef approximate_force(U, beta, epsilon, rng):\n    \"\"\"\n    Calculates the approximate force, including a modeled error term.\n    F_tilde = F(U) + epsilon * ||F(U)||_2 * r_hat\n    \"\"\"\n    F = exact_force(U, beta)\n    if epsilon == 0.0:\n        return F\n    \n    F_norm = np.linalg.norm(F)\n    if F_norm == 0.0:\n        return F\n        \n    # Generate a random vector and normalize it to get the unit vector r_hat\n    r = rng.standard_normal(size=U.shape)\n    r_norm = np.linalg.norm(r)\n    \n    # Handle the unlikely case where the random vector is zero\n    if r_norm == 0.0:\n      r_hat = np.zeros_like(r)\n    else:\n      r_hat = r / r_norm\n    \n    # Calculate the contaminated force\n    F_tilde = F + epsilon * F_norm * r_hat\n    return F_tilde\n\ndef leapfrog_integrator(U_start, P_start, dt, L, beta, epsilon, force_rng):\n    \"\"\"\n    Performs a molecular dynamics trajectory using the leapfrog algorithm.\n    \"\"\"\n    U = U_start.copy()\n    P = P_start.copy()\n\n    # Initial half-step for momentum (\"P-U-P\" scheme)\n    P -= 0.5 * dt * approximate_force(U, beta, epsilon, force_rng)\n\n    # L-1 full steps for position and momentum\n    for _ in range(L - 1):\n        U += dt * P\n        P -= dt * approximate_force(U, beta, epsilon, force_rng)\n\n    # Final full step for position\n    U += dt * P\n    \n    # Final half-step for momentum\n    P -= 0.5 * dt * approximate_force(U, beta, epsilon, force_rng)\n\n    return U, P\n\ndef run_reversibility_test(V, beta, dt, L, epsilon, u0_seed, p0_seed, fwd_seed, bwd_seed, u0_is_zero=False):\n    \"\"\"\n    Runs the full forward-backward reversibility test for a given set of parameters.\n    \"\"\"\n    # 1. Initialize initial conditions\n    p0_rng = np.random.default_rng(p0_seed)\n    \n    if u0_is_zero:\n        U0 = np.zeros(V, dtype=np.float64)\n    else:\n        u0_rng = np.random.default_rng(u0_seed)\n        U0 = u0_rng.normal(loc=0.0, scale=1.0, size=V)\n    \n    P0 = p0_rng.normal(loc=0.0, scale=1.0, size=V)\n\n    # 2. Calculate the initial Hamiltonian\n    H0 = calculate_hamiltonian(U0, P0, beta)\n\n    # 3. Run the forward trajectory\n    fwd_rng = np.random.default_rng(fwd_seed)\n    U1, P1 = leapfrog_integrator(U0, P0, dt, L, beta, epsilon, fwd_rng)\n\n    # 4. Run the backward trajectory with flipped momentum\n    bwd_rng = np.random.default_rng(bwd_seed)\n    U2, P2 = leapfrog_integrator(U1, -P1, dt, L, beta, epsilon, bwd_rng)\n    \n    # 5. Calculate the final Hamiltonian and the cycle energy difference\n    H2 = calculate_hamiltonian(U2, P2, beta)\n    delta_H_cycle = H2 - H0\n    \n    return delta_H_cycle\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (V, beta, dt, L, epsilon, u0_seed, p0_seed, fwd_seed, bwd_seed, u0_is_zero)\n        (128, 5.7, 0.1, 50, 1e-8, 123456, 123457, 987650, 987651, False),\n        (128, 5.7, 0.1, 50, 0.0, 123456, 123457, 111111, 222222, False),\n        (128, 5.7, 0.1, 50, 1e-10, 123456, 123457, 333333, 444444, False),\n        (128, 5.7, 0.1, 50, 1e-6, 123456, 123457, 555555, 666666, False),\n        (128, 5.7, 0.1, 50, 1e-8, 0, 777777, 888888, 999999, True), \n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_reversibility_test(*params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3516849"}]}