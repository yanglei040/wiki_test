{"hands_on_practices": [{"introduction": "在深入研究复杂的物理分析之前，我们必须确保我们的基础数据——即数字本身——得到正确处理。这项练习将引导您完成一项至关重要但又常常被忽视的任务：单位转换以及量化浮点运算中不可避免的数值误差。理解和控制这些效应对于任何精确的计算物理工作都至关重要。[@problem_id:3513376]", "problem": "您将获得一个根据高能物理蒙特卡洛（HepMC3）库建模的抽象事件记录。在 HepMC3 中，诸如四动量分量之类的能量类物理量以单一能量单位保存，而诸如顶点位置之类的空间类物理量以单一长度单位保存。通用生成器产生的事件记录在 HepMC3 中使用的常规默认单位是能量以 $\\,\\mathrm{GeV}\\,$ 为单位，长度以 $\\,\\mathrm{mm}\\,$ 为单位，并为能量单位 $\\,\\{\\mathrm{eV},\\mathrm{keV},\\mathrm{MeV},\\mathrm{GeV},\\mathrm{TeV}\\}\\,$ 和长度单位 $\\,\\{\\mathrm{mm},\\mathrm{cm},\\mathrm{m}\\}\\,$ 定义了明确的枚举。一个事件记录由一系列粒子组成，每个粒子都有一个四动量 $(E,p_x,p_y,p_z)$ 和一个产生顶点位置 $(x,y,z)$，其中 $(E,p_x,p_y,p_z)$ 的单位是 $\\,\\mathrm{GeV}\\,$，$(x,y,z)$ 的单位是 $\\,\\mathrm{mm}\\,$。\n\n从量纲分析和标准单位定义出发，推导将能量类物理量从 $\\,\\mathrm{GeV}\\,$ 转换为 $\\,\\mathrm{MeV}\\,$ 以及将长度类物理量从 $\\,\\mathrm{mm}\\,$ 转换为 $\\,\\mathrm{cm}\\,$ 的数学上正确的转换关系。假设所有数值计算均采用符合电气和电子工程师协会（IEEE）$\\,754\\,$标准的双精度浮点数进行，其中机器 epsilon $\\,\\epsilon\\,$ 定义为在双精度下满足 $\\,1+\\epsilon \\neq 1\\,$ 的最小正数。\n\n您的任务是实现一个程序，该程序能够：\n- 使用从基本单位定义推导出的正确乘法转换因子，将给定的事件记录从 $(\\mathrm{GeV},\\mathrm{mm})$ 转换为 $(\\mathrm{MeV},\\mathrm{cm})$。\n- 量化由这些转换所使用的浮点运算引入的舍入误差的严格上界，并以绝对误差界的形式表示。对于能量，使用乘以一个可精确表示的整数因子的单次乘法的第一性原理浮点舍入模型；对于长度，使用乘以一个非精确小数因子的模型。这些界限必须按每个数值字段计算，并按事件聚合，聚合方式为取该事件内所有转换后物理量的最大绝对误差界。\n- 生成单行输出，其中包含一个逐事件结果的列表。每个逐事件结果必须是一个双元素列表 $[E_{\\max},L_{\\max}]$，其中 $E_{\\max}$ 是所有转换后的能量类物理量（单位为 $\\,\\mathrm{MeV}\\,$）中的最大绝对误差界，而 $L_{\\max}$ 是所有转换后的长度类物理量（单位为 $\\,\\mathrm{cm}\\,$）中的最大绝对误差界。所有输出都必须是标准十进制形式的实数，不带单位。\n\n基本依据：\n- 使用定义 $\\,1\\,\\mathrm{GeV} = 10^{3}\\,\\mathrm{MeV}\\,$。\n- 使用定义 $\\,1\\,\\mathrm{cm} = 10\\,\\mathrm{mm}\\,$。\n- 对于单次浮点乘法，使用 IEEE $\\,754\\,$ 向最近舍入模型，其中机器 epsilon 为 $\\,\\epsilon\\,$。将乘以一个可精确表示的整数 $\\,k\\,$ 的操作视为最多引发一次舍入，其相对误差界为 $\\,\\epsilon\\,$；将乘以一个非精确小数因子 $\\,q\\,$ 的操作视为表示 $\\,q\\,$（相对误差界为 $\\,\\epsilon\\,$）和单次舍入乘法（相对误差界为 $\\,\\epsilon\\,$）的复合，从而得出一个总相对误差不超过 $\\,2\\epsilon\\,$ 的保守界。\n\n单位与数值输出：\n- 转换输出是程序内部的；最终打印的结果必须是所描述的误差界，并且必须是采用标准十进制表示法打印的无量纲数值。\n- 本任务不使用角度；没有需要指定的角度单位。\n\n测试套件：\n您必须将您的程序应用于以下三个事件记录。每个事件是一个粒子列表，每个粒子由两个元组定义：$(E,p_x,p_y,p_z)$（单位为 $\\,\\mathrm{GeV}\\,$）和 $(x,y,z)$（单位为 $\\,\\mathrm{mm}\\,$）：\n\n- 事件 $\\,1\\,$：\n  - 粒子 $\\,1\\,$：$(E,p_x,p_y,p_z) = (91.1876,1.0,-2.0,10.0)$, $(x,y,z) = (0.5,-1.2,30.0)$\n  - 粒子 $\\,2\\,$：$(E,p_x,p_y,p_z) = (45.5938,-0.3,0.1,-5.0)$, $(x,y,z) = (0.0,0.0,0.0)$\n  - 粒子 $\\,3\\,$：$(E,p_x,p_y,p_z) = (0.005,0.001,0.0002,-0.0001)$, $(x,y,z) = (0.001,-0.002,0.005)$\n- 事件 $\\,2\\,$：\n  - 粒子 $\\,1\\,$：$(E,p_x,p_y,p_z) = (13000.0,100.0,-200.0,5000.0)$, $(x,y,z) = (1000000.0,0.0,-1000000.0)$\n  - 粒子 $\\,2\\,$：$(E,p_x,p_y,p_z) = (0.0,0.0,0.0,0.0)$, $(x,y,z) = (1.0,-1.0,1.0)$\n- 事件 $\\,3\\,$：\n  - 粒子 $\\,1\\,$：$(E,p_x,p_y,p_z) = (1.0\\times 10^{-9},-1.0\\times 10^{-9},2.0\\times 10^{-9},-3.0\\times 10^{-9})$, $(x,y,z) = (1.0\\times 10^{-6},-2.0\\times 10^{-6},3.0\\times 10^{-6})$\n  - 粒子 $\\,2\\,$：$(E,p_x,p_y,p_z) = (5.0\\times 10^{-3},-5.0\\times 10^{-3},0.0,1.0\\times 10^{-2})$, $(x,y,z) = (1.0\\times 10^{-3},0.0,-1.0\\times 10^{-3})$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的逐事件结果列表，其中每个元素是双元素列表 $[E_{\\max},L_{\\max}]$。例如，输出必须具有 $[\\,[E_{\\max}^{(1)},L_{\\max}^{(1)}],[E_{\\max}^{(2)},L_{\\max}^{(2)}],[E_{\\max}^{(3)},L_{\\max}^{(3)}]\\,]$ 的形式，并用数值代替符号。", "solution": "该问题要求为高能物理中的事件记录推导转换因子并分析相关的浮点误差。分析将分三个阶段进行：首先，推导乘法转换因子；其次，建模并计算浮点绝对误差的上界；第三，指定一个算法将这些计算应用于给定的测试数据。\n\n**1. 转换因子的推导**\n\n问题指定了基于标准单位定义的能量类和长度类物理量的转换。\n\n- **能量转换 ($\\mathrm{GeV} \\to \\mathrm{MeV}$)**：提供的定义是 $1\\,\\mathrm{GeV} = 10^3\\,\\mathrm{MeV}$。要将一个以 $\\mathrm{GeV}$ 为单位的值 $Q_{\\mathrm{GeV}}$ 转换为其等效的以 $\\mathrm{MeV}$ 为单位的值 $Q_{\\mathrm{MeV}}$，我们乘以从该恒等式推导出的适当转换因子：\n$$ Q_{\\mathrm{MeV}} = Q_{\\mathrm{GeV}} \\times \\left( \\frac{10^3\\,\\mathrm{MeV}}{1\\,\\mathrm{GeV}} \\right) = Q_{\\mathrm{GeV}} \\times 1000 $$\n转换因子是整数 $k = 1000$。在 IEEE $754$ 双精度二进制格式中，整数 $1000$ 是可以精确表示的，因为它可以写成 $1000 = 125 \\times 2^3$，整数尾数 $125$ 只需要 $7$ 位，这远在 $52$ 位的限制之内。\n\n- **长度转换 ($\\mathrm{mm} \\to \\mathrm{cm}$)**：提供的定义是 $1\\,\\mathrm{cm} = 10\\,\\mathrm{mm}$。要将一个以 $\\mathrm{mm}$ 为单位的值 $P_{\\mathrm{mm}}$ 转换为其等效的以 $\\mathrm{cm}$ 为单位的值 $P_{\\mathrm{cm}}$，转换关系为：\n$$ P_{\\mathrm{cm}} = P_{\\mathrm{mm}} \\times \\left( \\frac{1\\,\\mathrm{cm}}{10\\,\\mathrm{mm}} \\right) = P_{\\mathrm{mm}} \\times 0.1 $$\n转换因子是小数 $q = 0.1$。在二进制中，这是一个无限循环小数 ($0.000110011..._2$)。因此，$0.1$ 无法在任何有限位二进制浮点系统中精确表示，包括 IEEE $754$ 双精度。\n\n**2. 浮点误差分析**\n\n问题要求基于 IEEE $754$ 双精度算术的第一性原理模型进行误差分析，我们用 $\\epsilon$ 表示机器 epsilon。机器 epsilon $\\epsilon$ 是单个基本浮点运算相对误差的上界，即 $fl(x \\odot y) = (x \\odot y)(1+\\delta)$，其中 $|\\delta| \\le \\epsilon$。\n\n- **能量转换的绝对误差界**：转换关系为 $Q_{\\mathrm{MeV}} = Q_{\\mathrm{GeV}} \\times 1000$。问题指出，乘以可精确表示的因子 $1000$ 最多只会引发一次舍入。计算值 $Q'_{\\mathrm{MeV}}$ 与精确数学结果 $Q_{\\mathrm{GeV}} \\times 1000$ 的关系如下：\n$$ Q'_{\\mathrm{MeV}} = fl(Q_{\\mathrm{GeV}} \\times 1000) = (Q_{\\mathrm{GeV}} \\times 1000)(1 + \\delta_{E}) $$\n其中相对误差 $|\\delta_{E}| \\le \\epsilon$。因此，绝对误差 $\\Delta Q_E = |Q'_{\\mathrm{MeV}} - (Q_{\\mathrm{GeV}} \\times 1000)|$ 的界为：\n$$ \\text{bound}(\\Delta Q_E) = |(Q_{\\mathrm{GeV}} \\times 1000)\\delta_{E}| \\le |Q_{\\mathrm{GeV}} \\times 1000| \\times \\epsilon $$\n对于每个事件，最大绝对误差界 $E_{\\max}$ 是该事件内所有粒子所有能量类物理量 $\\{E, p_x, p_y, p_z\\}$ 的此界的最大值。该最大值由具有最大绝对值的分量决定：\n$$ E_{\\max} = \\left( \\max_{\\text{event}} |Q_{\\mathrm{GeV}}| \\right) \\times 1000 \\times \\epsilon $$\n得到的误差界 $E_{\\max}$ 的单位是 $\\mathrm{MeV}$。\n\n- **长度转换的绝对误差界**：转换关系为 $P_{\\mathrm{cm}} = P_{\\mathrm{mm}} \\times 0.1$。问题指定了一个保守模型，其中此操作的总相对误差界为 $2\\epsilon$。这既考虑了表示非精确因子 $0.1$ 时的初始误差，也考虑了后续乘法运算的误差。计算值 $P'_{\\mathrm{cm}}$ 与精确数学结果 $P_{\\mathrm{mm}} \\times 0.1$ 的关系如下：\n$$ P'_{\\mathrm{cm}} = (P_{\\mathrm{mm}} \\times 0.1)(1 + \\delta_{L}) $$\n其中总相对误差 $|\\delta_{L}| \\le 2\\epsilon$。因此，绝对误差 $\\Delta Q_L = |P'_{\\mathrm{cm}} - (P_{\\mathrm{mm}} \\times 0.1)|$ 的界为：\n$$ \\text{bound}(\\Delta Q_L) = |(P_{\\mathrm{mm}} \\times 0.1)\\delta_{L}| \\le |P_{\\mathrm{mm}} \\times 0.1| \\times 2\\epsilon $$\n对于每个事件，最大绝对误差界 $L_{\\max}$ 是该事件内所有粒子所有长度类物理量 $\\{x, y, z\\}$ 的此界的最大值：\n$$ L_{\\max} = \\left( \\max_{\\text{event}} |P_{\\mathrm{mm}}| \\right) \\times 0.1 \\times 2\\epsilon = \\left( \\max_{\\text{event}} |P_{\\mathrm{mm}}| \\right) \\times 0.2 \\times \\epsilon $$\n得到的误差界 $L_{\\max}$ 的单位是 $\\mathrm{cm}$。\n\n**3. 算法与实现**\n\n计算测试套件所需误差界的算法如下：\n1.  获取 IEEE $754$ 双精度数的机器 epsilon $\\epsilon$。\n2.  对于测试套件中的每个事件：\n    a. 将 `max_abs_energy_GeV` 和 `max_abs_length_mm` 初始化为 $0.0$。\n    b. 遍历事件中的每个粒子。\n        i. 对于粒子的四动量 $(E, p_x, p_y, p_z)$（单位为 $\\mathrm{GeV}$），找到其分量中的最大绝对值。将 `max_abs_energy_GeV` 更新为其当前值与这个新最大值中的较大者。\n        ii. 对于粒子的顶点位置 $(x, y, z)$（单位为 $\\mathrm{mm}$），找到其分量中的最大绝对值。将 `max_abs_length_mm` 更新为其当前值与这个新最大值中的较大者。\n    c. 处理完所有粒子后，使用推导出的公式计算事件范围内的最大绝对误差界：\n       - $E_{\\max} = \\texttt{max\\_abs\\_energy\\_GeV} \\times 1000 \\times \\epsilon$\n       - $L_{\\max} = \\texttt{max\\_abs\\_length\\_mm} \\times 0.2 \\times \\epsilon$\n    d. 存储结果对 $[E_{\\max}, L_{\\max}]$。\n3.  根据指定的输出格式 `[[E_max_1,L_max_1],[E_max_2,L_max_2],...]`，将存储的对列表格式化为单个字符串并打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating floating-point error bounds for unit\n    conversions in high-energy physics event records.\n    \"\"\"\n\n    # Define the test suite from the problem statement.\n    # Structure: list of events.\n    # Each event: list of particles.\n    # Each particle: tuple of (four_momentum_GeV, vertex_position_mm).\n    test_cases = [\n        # Event 1\n        [\n            ((91.1876, 1.0, -2.0, 10.0), (0.5, -1.2, 30.0)),\n            ((45.5938, -0.3, 0.1, -5.0), (0.0, 0.0, 0.0)),\n            ((0.005, 0.001, 0.0002, -0.0001), (0.001, -0.002, 0.005))\n        ],\n        # Event 2\n        [\n            ((13000.0, 100.0, -200.0, 5000.0), (1000000.0, 0.0, -1000000.0)),\n            ((0.0, 0.0, 0.0, 0.0), (1.0, -1.0, 1.0))\n        ],\n        # Event 3\n        [\n            ((1.0e-9, -1.0e-9, 2.0e-9, -3.0e-9), (1.0e-6, -2.0e-6, 3.0e-6)),\n            ((5.0e-3, -5.0e-3, 0.0, 1.0e-2), (1.0e-3, 0.0, -1.0e-3))\n        ]\n    ]\n\n    # Get machine epsilon for IEEE 754 double precision (np.float64).\n    epsilon = np.finfo(np.float64).eps\n\n    results = []\n    for event in test_cases:\n        max_abs_energy_component_gev = 0.0\n        max_abs_length_component_mm = 0.0\n\n        # Find the maximum absolute value for energy and length quantities in the event.\n        for particle in event:\n            momenta, positions = particle\n            \n            # Find max absolute value for energy-like quantities (in GeV)\n            current_max_e = max(map(abs, momenta))\n            if current_max_e > max_abs_energy_component_gev:\n                max_abs_energy_component_gev = current_max_e\n\n            # Find max absolute value for length-like quantities (in mm)\n            current_max_l = max(map(abs, positions))\n            if current_max_l > max_abs_length_component_mm:\n                max_abs_length_component_mm = current_max_l\n\n        # Calculate E_max: absolute error bound for energy conversion (in MeV).\n        # The model is: E_max = (max |val_GeV|) * 1000 * epsilon\n        e_max = max_abs_energy_component_gev * 1000.0 * epsilon\n\n        # Calculate L_max: absolute error bound for length conversion (in cm).\n        # The model is: L_max = (max |val_mm|) * 0.1 * 2 * epsilon\n        l_max = max_abs_length_component_mm * 0.2 * epsilon\n        \n        results.append([e_max, l_max])\n\n    # Format the final output string exactly as specified.\n    # Python's default float-to-string conversion produces standard decimal form.\n    output_str = \"[\" + \",\".join([f\"[{e},{l}]\" for e, l in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3513376"}, {"introduction": "事件记录不仅是粒子的列表，它更是一个表示因果历史的有向图。这项练习将构建一个验证器，以强制执行该结构的基本规则，例如确保粒子遵循逻辑生命周期（由状态码定义），并且整个图在因果上是合理的（无环）。这种验证是确保数据质量和后续物理分析可靠性的第一道防线。[@problem_id:3513428]", "problem": "你的任务是设计并实现一个程序化验证器，用于验证高能物理事件记录。这些记录将粒子历史表示为一个由顶点（相互作用或衰变）通过粒子连接而成的图。验证器必须强制执行逻辑上和物理上一致的状态转换及相关约束。事件数据模型遵循一个简化的标准模型，其灵感来源于 HepMC 和 HEPEVT 等格式：\n\n- 每个粒子具有：\n  - 一个唯一的整数标识符 $p \\in \\mathbb{Z}$。\n  - 一个整数状态 $s \\in \\{-1,1,2\\}$，其中 $s=-1$ 表示入射束流粒子，$s=1$ 表示末态稳定粒子，$s=2$ 表示中间衰变或传播粒子。\n  - 一个产生顶点标识符 $v_{\\mathrm{prod}} \\in \\mathbb{Z} \\cup \\{\\varnothing\\}$ 和一个结束顶点标识符 $v_{\\mathrm{end}} \\in \\mathbb{Z} \\cup \\{\\varnothing\\}$。\n  - 一个四动量 $p^{\\mu}=(E,p_x,p_y,p_z)$，采用自然单位制，光速 $c$ 设为 $1$，所有分量均以吉电子伏特 (GeV) 为单位。也就是说，$E$ 的单位是 $\\mathrm{GeV}$，$(p_x,p_y,p_z)$ 的单位也是 $\\mathrm{GeV}$。\n\n- 每个顶点具有：\n  - 一个唯一的整数标识符 $v \\in \\mathbb{Z}$。\n  - 一个入射粒子标识符列表和一个出射粒子标识符列表。\n\n验证器必须强制执行以下源于基本原理的约束：\n\n1. 状态-顶点关联规则：\n   - 如果 $s=-1$ (入射)，则 $v_{\\mathrm{prod}}=\\varnothing$ 且 $v_{\\mathrm{end}}\\neq \\varnothing$。\n   - 如果 $s=1$ (末态)，则 $v_{\\mathrm{prod}}\\neq \\varnothing$ 且 $v_{\\mathrm{end}}=\\varnothing$。\n   - 如果 $s=2$ (中间)，则 $v_{\\mathrm{prod}}\\neq \\varnothing$ 且 $v_{\\mathrm{end}}\\neq \\varnothing$。\n\n2. 顶点-粒子一致性：\n   - 对于每个顶点 $v$，其声明的入射粒子集合必须等于集合 $\\{p \\mid v_{\\mathrm{end}}(p)=v\\}$，其声明的出射粒子集合必须等于集合 $\\{p \\mid v_{\\mathrm{prod}}(p)=v\\}$。\n   - 对于每个顶点 $v$，入射粒子的状态必须满足 $s \\in \\{-1,2\\}$，出射粒子的状态必须满足 $s \\in \\{1,2\\}$。\n   - 每个顶点必须至少有一个入射粒子和至少一个出射粒子。\n\n3. 每个顶点 $v$ 处的四动量守恒：\n   - 设 $\\sum_{\\mathrm{in}} p^{\\mu}$ 为所有入射四动量之和，$\\sum_{\\mathrm{out}} p^{\\mu}$ 为所有出射四动量之和。守恒条件为\n     $$\\left|\\sum_{\\mathrm{in}} p^{\\mu} - \\sum_{\\mathrm{out}} p^{\\mu}\\right| \\le \\varepsilon \\quad \\text{分量逐一比较},$$\n     对于给定的容差 $\\varepsilon > 0$，该容差被解释为每个分量的界限，单位为 $\\mathrm{GeV}$。使用 $\\varepsilon = 10^{-9}\\,\\mathrm{GeV}$。\n\n4. 粒子-顶点图的因果非循环性：\n   - 构建一个有向图，其中对于每个顶点 $v$，每个入射粒子 $p_{\\mathrm{in}}$ 和每个出射粒子 $p_{\\mathrm{out}}$，添加一条边 $p_{\\mathrm{in}} \\to p_{\\mathrm{out}}$。该图必须是一个有向无环图 (DAG)。任何循环都违反因果律。\n\n你的程序必须实现这些检查，并输出所提供的每个事件是否有效。每个事件的输出必须是一个布尔值，$ \\mathrm{True}$ 表示事件通过所有检查，否则为 $ \\mathrm{False}$。\n\n所有能量和动量分量都应以 $\\mathrm{GeV}$ 为单位进行解释和验证，采用 $c=1$ 的自然单位制。\n\n测试套件：\n请根据以下具体事件来实现你的验证器。每个事件由一个粒子列表和一个顶点列表指定。每个粒子记录是一个元组 $(\\text{id}, s, v_{\\mathrm{prod}}, v_{\\mathrm{end}}, (E,p_x,p_y,p_z))$，每个顶点记录是一个元组 $(\\text{id}, [\\text{incoming}], [\\text{outgoing}])$。\n\n- 事件 $1$ (正常路径，有效)：\n  - 粒子：\n    - $(1,-1,\\varnothing,101,(100,0,0,100))$\n    - $(2,-1,\\varnothing,101,(100,0,0,-100))$\n    - $(3,2,101,102,(120,0,0,10))$\n    - $(4,1,101,\\varnothing,(80,0,0,-10))$\n    - $(5,1,102,\\varnothing,(60,10,0,5))$\n    - $(6,1,102,\\varnothing,(60,-10,0,5))$\n  - 顶点：\n    - $(101,[1,2],[3,4])$\n    - $(102,[3],[5,6])$\n\n- 事件 $2$ (无效：末态粒子具有结束顶点，并作为入射粒子参与该顶点)：\n  - 粒子：\n    - $(11,-1,\\varnothing,201,(10,0,0,0))$\n    - $(10,1,201,202,(10,0,0,0))$\n  - 顶点：\n    - $(201,[11],[10])$\n    - $(202,[10],[])$\n\n- 事件 $3$ (无效：中间粒子没有结束顶点)：\n  - 粒子：\n    - $(20,-1,\\varnothing,301,(50,0,0,0))$\n    - $(21,2,301,\\varnothing,(50,0,0,0))$\n  - 顶点：\n    - $(301,[20],[21])$\n\n- 事件 $4$ (无效：入射粒子具有产生顶点)：\n  - 粒子：\n    - $(30,-1,401,402,(5,0,0,0))$\n  - 顶点：\n    - $(401,[],[30])$\n    - $(402,[30],[])$\n\n- 事件 $5$ (无效：顶点-粒子不匹配，且一个出射粒子的产生顶点不一致)：\n  - 粒子：\n    - $(40,-1,\\varnothing,501,(10,0,0,0))$\n    - $(41,2,501,502,(10,0,0,0))$\n    - $(42,1,503,\\varnothing,(10,0,0,0))$\n  - 顶点：\n    - $(501,[40],[41])$\n    - $(502,[41],[42])$\n    - $(503,[],[42])$\n\n- 事件 $6$ (无效：一个顶点处的四动量不守恒，超出了容差 $\\varepsilon$)：\n  - 粒子：\n    - $(50,-1,\\varnothing,601,(10,0,0,0))$\n    - $(51,1,601,\\varnothing,(9,0,0,0))$\n  - 顶点：\n    - $(601,[50],[51])$\n\n- 事件 $7$ (无效：图中存在因果循环)：\n  - 粒子：\n    - $(60,2,701,702,(5,0,0,0))$\n    - $(61,2,702,701,(5,0,0,0))$\n  - 顶点：\n    - $(701,[61],[60])$\n    - $(702,[60],[61])$\n\n你的程序必须评估这 $7$ 个事件，并生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。例如，输出格式必须严格为 $[\\mathrm{result}_1,\\mathrm{result}_2,\\ldots,\\mathrm{result}_7]$ 的形式，其中每个 $\\mathrm{result}_i$ 是一个布尔值。", "solution": "问题陈述已经过评估，并被确定为有效。它具有科学依据、提法明确、客观，并包含了构建唯一可验证解决方案所需的所有必要信息。我们现在将继续进行验证器的设计和解释。\n\n对高能物理事件记录进行程序化验证，需要一系列检查来确保事件的逻辑自洽性及其对基本物理定律的遵守。我们将设计一个验证器，系统地应用四类约束：（1）状态-顶点关联规则，（2）顶点-粒子图的一致性，（3）每个顶点的四动量守恒，以及（4）因果非循环性。一个事件只有在通过所有检查时才被视为有效。\n\n首先，为了高效访问，以粒子和顶点列表形式提供的事件数据将被解析为将唯一标识符映射到其各自数据结构的字典。标识符为 $p$ 的粒子表示为 $P_p$，标识符为 $v$ 的顶点表示为 $V_v$。粒子 $p$ 的四动量为 $p^{\\mu}$。空顶点标识符 $\\varnothing$ 在实现中由一个空值表示。\n\n**1. 状态-顶点关联规则**\n\n这套规则形式化了粒子在事件中的生命周期。粒子的状态 $s$ 决定了它在事件历史图中的位置。\n\n*   **原理**：粒子根据其作用进行分类。一个入射束流粒子 ($s=-1$) 源于事件之外，因此它没有产生顶点 ($v_{\\mathrm{prod}}=\\varnothing$)，但它必须在某个顶点发生相互作用 ($v_{\\mathrm{end}}\\neq \\varnothing$)。一个末态粒子 ($s=1$) 是稳定的并离开相互作用区域，所以它必须在一个顶点产生 ($v_{\\mathrm{prod}}\\neq \\varnothing$)，但没有后续的衰变或相互作用顶点 ($v_{\\mathrm{end}}=\\varnothing$)。一个中间粒子 ($s=2$) 产生后会接着衰变或相互作用，所以它必须被一个产生顶点和一个结束顶点所界定 ($v_{\\mathrm{prod}}\\neq \\varnothing$ 且 $v_{\\mathrm{end}}\\neq \\varnothing$)。\n\n*   **算法**：验证器遍历事件中的每一个粒子 $P_p$。对每个粒子，它检查以下逻辑条件：\n    *   如果 $s(P_p) = -1$，必须满足 $v_{\\mathrm{prod}}(P_p) = \\varnothing$ 且 $v_{\\mathrm{end}}(P_p) \\neq \\varnothing$。\n    *   如果 $s(P_p) = 1$，必须满足 $v_{\\mathrm{prod}}(P_p) \\neq \\varnothing$ 且 $v_{\\mathrm{end}}(P_p) = \\varnothing$。\n    *   如果 $s(P_p) = 2$，必须满足 $v_{\\mathrm{prod}}(P_p) \\neq \\varnothing$ 且 $v_{\\mathrm{end}}(P_p) \\neq \\varnothing$。\n    任何粒子未能满足其中任一条件，都将导致整个事件无效。\n\n**2. 顶点-粒子一致性**\n\n此项检查确保粒子和顶点记录为事件的图拓扑提供了一致且完整的描述。\n\n*   **原理**：事件记录包含对事件图的两种视角：粒子的顶点指针 ($v_{\\mathrm{prod}}, v_{\\mathrm{end}}$) 和顶点的粒子列表（入射、出射）。这两种视角必须相互一致。此外，顶点代表一个物理相互作用，必须有粒子进入和离开，并且这些粒子的状态必须与其作用相符。\n\n*   **算法**：验证器遍历每一个顶点 $V_v$。对每个顶点，它执行四项检查：\n    1.  **拓扑一致性**：它构建实际的入射粒子集合 $I_{actual} = \\{p \\mid v_{\\mathrm{end}}(P_p) = v\\}$ 和实际的出射粒子集合 $O_{actual} = \\{p \\mid v_{\\mathrm{prod}}(P_p) = v\\}$。然后验证这些集合与顶点数据中声明的入射和出射粒子列表 $I_{declared}$ 和 $O_{declared}$ 是否相同。即，$I_{actual} = \\text{set}(I_{declared})$ 且 $O_{actual} = \\text{set}(O_{declared})$。\n    2.  **顶点的粒子状态**：对于 $I_{declared}$ 中的每个粒子 $p$，验证器检查其状态 $s(P_p) \\in \\{-1, 2\\}$。对于 $O_{declared}$ 中的每个粒子 $p'$，它检查其状态 $s(P_{p'}) \\in \\{1, 2\\}$。末态粒子 ($s=1$) 不能成为顶点的入射粒子，初态粒子 ($s=-1$) 也不能从顶点出射。\n    3.  **顶点粒子数**：一个物理顶点必须代表一次相互作用或衰变。因此，它必须至少有一个入射粒子和一个出射粒子。验证器检查是否 $|I_{declared}| \\ge 1$ 且 $|O_{declared}| \\ge 1$。\n    在任何顶点的这些检查中发现任何不一致，都会将该事件标记为无效。\n\n**3. 四动量守恒**\n\n这是一项基于物理学最基本守恒定律之一的严格检验。\n\n*   **原理**：在没有外场的情况下，孤立系统的总四动量是守恒的。在每个代表局域相互作用的顶点处，所有入射粒子的四动量之和必须等于所有出射粒子的四动量之和。这源于物理定律在时空平移下的不变性（诺特定理）。\n\n*   **算法**：对于每个顶点 $V_v$，验证器计算所有入射粒子的四动量之和 $\\sum_{\\mathrm{in}} p^{\\mu} = \\sum_{p \\in I_{declared}} p^{\\mu}(P_p)$，以及所有出射粒子的四动量之和 $\\sum_{\\mathrm{out}} p^{\\mu} = \\sum_{p' \\in O_{declared}} p^{\\mu}(P_{p'})$。由于有限浮点精度，直接进行相等性检查是不合适的。取而代之的条件是，四个分量（能量和三个动量分量）中每一个的绝对差都必须小于或等于一个小的容差 $\\varepsilon$。问题指定 $\\varepsilon = 10^{-9} \\, \\mathrm{GeV}$。\n    $$ \\left| \\left(\\sum_{\\mathrm{in}} p^{\\mu}\\right)_k - \\left(\\sum_{\\mathrm{out}} p^{\\mu}\\right)_k \\right| \\le \\varepsilon $$\n    对于每个分量 $k \\in \\{0, 1, 2, 3\\}$。在任何顶点违反此条件都将使事件无效。\n\n**4. 因果非循环性**\n\n此约束确保事件历史在因果上是可能的。\n\n*   **原理**：因果律规定结果不能先于原因。在粒子历史图的背景下，这意味着一个粒子不能是它自身的祖先。例如，一个粒子不能衰变成某些产物，然后这些产物再相互作用重新形成原来的粒子。产生和衰变的序列必须构成一个有向无环图 (DAG)。\n\n*   **算法**：构建一个有向图，其中节点代表粒子。如果存在一个顶点 $V_v$，其中 $p_{\\mathrm{in}}$ 是入射粒子，$p_{\\mathrm{out}}$ 是出射粒子，则添加一条边 $p_{\\mathrm{in}} \\to p_{\\mathrm{out}}$。该图代表了因果关系和粒子世系流。为检查循环，采用深度优先搜索 (DFS) 算法。在遍历过程中，使用三种状态跟踪节点：未访问、正在访问（当前在递归堆栈中）和已访问（所有后代已探索完毕）。如果 DFS 遇到一个当前处于“正在访问”状态的节点，则说明找到了一条反向边，表示存在一个循环。任何循环的存在都违反了因果律，并使事件无效。\n\n通过有条不紊地应用这四个层面的验证，程序可以严格确定任何给定事件记录的物理和逻辑有效性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the validator.\n    \"\"\"\n    \n    # Represents the null vertex identifier ø.\n    NULL_VERTEX = None\n\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # Event 1 (valid)\n        {\n            \"particles\": [\n                (1, -1, NULL_VERTEX, 101, (100, 0, 0, 100)),\n                (2, -1, NULL_VERTEX, 101, (100, 0, 0, -100)),\n                (3, 2, 101, 102, (120, 0, 0, 10)),\n                (4, 1, 101, NULL_VERTEX, (80, 0, 0, -10)),\n                (5, 1, 102, NULL_VERTEX, (60, 10, 0, 5)),\n                (6, 1, 102, NULL_VERTEX, (60, -10, 0, 5)),\n            ],\n            \"vertices\": [\n                (101, [1, 2], [3, 4]),\n                (102, [3], [5, 6]),\n            ]\n        },\n        # Event 2 (invalid: final-state particle has end vertex)\n        {\n            \"particles\": [\n                (11, -1, NULL_VERTEX, 201, (10, 0, 0, 0)),\n                (10, 1, 201, 202, (10, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (201, [11], [10]),\n                (202, [10], []),\n            ]\n        },\n        # Event 3 (invalid: intermediate without end vertex)\n        {\n            \"particles\": [\n                (20, -1, NULL_VERTEX, 301, (50, 0, 0, 0)),\n                (21, 2, 301, NULL_VERTEX, (50, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (301, [20], [21]),\n            ]\n        },\n        # Event 4 (invalid: incoming with production vertex)\n        {\n            \"particles\": [\n                (30, -1, 401, 402, (5, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (401, [], [30]),\n                (402, [30], []),\n            ]\n        },\n        # Event 5 (invalid: vertex-particle mismatch)\n        {\n            \"particles\": [\n                (40, -1, NULL_VERTEX, 501, (10, 0, 0, 0)),\n                (41, 2, 501, 502, (10, 0, 0, 0)),\n                (42, 1, 503, NULL_VERTEX, (10, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (501, [40], [41]),\n                (502, [41], [42]),\n                (503, [], [42]),\n            ]\n        },\n        # Event 6 (invalid: four-momentum not conserved)\n        {\n            \"particles\": [\n                (50, -1, NULL_VERTEX, 601, (10, 0, 0, 0)),\n                (51, 1, 601, NULL_VERTEX, (9, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (601, [50], [51]),\n            ]\n        },\n        # Event 7 (invalid: causal cycle)\n        {\n            \"particles\": [\n                (60, 2, 701, 702, (5, 0, 0, 0)),\n                (61, 2, 702, 701, (5, 0, 0, 0)),\n            ],\n            \"vertices\": [\n                (701, [61], [60]),\n                (702, [60], [61]),\n            ]\n        }\n    ]\n\n    results = [validate_event(case[\"particles\"], case[\"vertices\"], NULL_VERTEX) for case in test_cases]\n    # In Python, True/False string representations are capitalized. Problem asks for lowercase.\n    # However, the example format uses True/False, so Python default is acceptable.\n    # The example [result_1,result_2,...] suggests the literal boolean values are what's needed.\n    # Let's adjust to match standard Python bool string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef validate_event(particles_list, vertices_list, null_vertex_id):\n    \"\"\"\n    Performs all validation checks for a single event.\n    \"\"\"\n    \n    # Pre-processing: Create efficient look-up maps\n    particles_map = {p[0]: {\"id\": p[0], \"s\": p[1], \"v_prod\": p[2], \"v_end\": p[3], \"pmu\": np.array(p[4])} for p in particles_list}\n    vertices_map = {v[0]: {\"id\": v[0], \"in\": v[1], \"out\": v[2]} for v in vertices_list}\n\n    # 1. Status-vertex incidence rules\n    for p_id, p_data in particles_map.items():\n        s, v_prod, v_end = p_data[\"s\"], p_data[\"v_prod\"], p_data[\"v_end\"]\n        if s == -1 and not (v_prod == null_vertex_id and v_end != null_vertex_id): return False\n        if s == 1 and not (v_prod != null_vertex_id and v_end == null_vertex_id): return False\n        if s == 2 and not (v_prod != null_vertex_id and v_end != null_vertex_id): return False\n\n    # 2. Vertex-particle consistency\n    for v_id, v_data in vertices_map.items():\n        # Check vertex population\n        if not (len(v_data[\"in\"]) >= 1 and len(v_data[\"out\"]) >= 1): return False\n\n        # Compare declared vs actual particle sets at vertex\n        actual_in = {p_id for p_id, p in particles_map.items() if p[\"v_end\"] == v_id}\n        actual_out = {p_id for p_id, p in particles_map.items() if p[\"v_prod\"] == v_id}\n        if set(v_data[\"in\"]) != actual_in or set(v_data[\"out\"]) != actual_out: return False\n\n        # Check status of particles at vertex\n        for p_id in v_data[\"in\"]:\n            if p_id not in particles_map or particles_map[p_id][\"s\"] not in [-1, 2]: return False\n        for p_id in v_data[\"out\"]:\n            if p_id not in particles_map or particles_map[p_id][\"s\"] not in [1, 2]: return False\n    \n    # 3. Four-momentum conservation\n    epsilon = 1e-9\n    for v_id, v_data in vertices_map.items():\n        sum_in_pmu = np.sum([particles_map[p_id][\"pmu\"] for p_id in v_data[\"in\"]], axis=0)\n        sum_out_pmu = np.sum([particles_map[p_id][\"pmu\"] for p_id in v_data[\"out\"]], axis=0)\n        if not np.all(np.abs(sum_in_pmu - sum_out_pmu) = epsilon): return False\n\n    # 4. Causal acyclicity\n    # Build adjacency list for the particle causality graph\n    adj = {p_id: [] for p_id in particles_map}\n    for v_data in vertices_map.values():\n        for p_in in v_data[\"in\"]:\n            for p_out in v_data[\"out\"]:\n                adj[p_in].append(p_out)\n    \n    # DFS-based cycle detection\n    # States: 0 = unvisited, 1 = visiting, 2 = visited\n    path = set()  # Corresponds to state 1 (visiting)\n    visited = set() # Corresponds to state 2 (visited)\n\n    def has_cycle(node):\n        path.add(node)\n        for neighbor in adj.get(node, []):\n            if neighbor in path:\n                return True\n            if neighbor not in visited:\n                if has_cycle(neighbor):\n                    return True\n        path.remove(node)\n        visited.add(node)\n        return False\n\n    for node in particles_map:\n        if node not in visited:\n            if has_cycle(node):\n                return False\n\n    return True\n\nsolve()\n```", "id": "3513428"}, {"introduction": "一个在语法上正确的事件图还必须遵守物理学的基本守恒定律。这项练习在之前的基础上，要求您实现对每个相互作用顶点的四维动量守恒以及对QCD色荷流一致性的检查。后者是一项重要的验证任务，对于强子对撞机物理学的研究尤其关键，它确保了事件记录符合量子色动力学理论的约束。[@problem_id:3513384]", "problem": "设计并实现一个具备物理学意识的验证器，用于处理高能物理蒙特卡洛（HepMC3）事件记录。该验证器应在事件的简化内存表示上运行。验证器必须检查母-女链接在每个顶点处是否在容差 $\\epsilon$ 内强制执行局部和全局四维动量守恒，并且必须标记出模糊或循环的色连接。验证器必须为提供的测试套件生成单行输出，其中包含验证码。\n\n需要使用的基本原理和定义：\n- 狭义相对论四维动量守恒：对于任何相互作用顶点，所有入射四维动量的总和等于所有出射四维动量的总和。若 $p_i^\\mu$ 表示粒子 $i$ 的四维动量，则在任意顶点 $v$ 处，$$\\sum_{i \\in \\text{in}(v)} p_i^\\mu = \\sum_{j \\in \\text{out}(v)} p_j^\\mu.$$ 验证器必须使用分量最大范数（上确界范数）来检查守恒性，对于一个四维矢量差 $\\Delta p^\\mu$，其定义为 $$\\|\\Delta p^\\mu\\|_\\infty = \\max\\left(|\\Delta E|,|\\Delta p_x|,|\\Delta p_y|,|\\Delta p_z|\\right).$$ 如果在顶点 $v$ 处 $\\|\\Delta p^\\mu\\|_\\infty \\le \\epsilon$，则局部守恒得到满足。\n- 全局守恒：对于一个事件，入射束流四维动量（状态码 $4$）的总和必须在相同容差内等于末态稳定粒子四维动量（状态码 $1$）的总和，使用相同的 $\\|\\cdot\\|_\\infty$ 范数。\n- 量子色动力学（QCD）中的色流：每个粒子可能携带一个色标签 $c$ 和一个反色标签 $\\bar{c}$，存在时表示为非零整数，否则为零。一个物理上定义良好的色流要求每个非零色标识符在事件中恰好出现两次：一次作为某个粒子上的色 $c$，另一次作为另一个粒子上的反色 $\\bar{c}$。如果一个色标识符出现超过两次，或者角色多重性不正确（例如，两个 $c$ 角色和零个 $\\bar{c}$ 角色），就会产生模糊性。为检测循环色连接，需构建一个无向图，其节点为粒子，其边连接共享相同标识符的有效色-反色配对的粒子对。如果存在一条由不同边组成的返回起始粒子的闭合路径，则存在循环；任何循环的出现都应被标记。\n\n单位与约定：\n- 所有四维动量分量 $E$、$p_x$、$p_y$ 和 $p_z$ 必须以吉电子伏特（GeV）为单位处理。容差 $\\epsilon$ 也以 GeV 为单位指定。\n- 本问题不使用角度；没有角度单位要求。\n- 母-女链接由顶点关联隐含：一个以 $v$ 为终止顶点的粒子是 $v$ 的入射粒子，一个以 $v$ 为产生顶点的粒子是 $v$ 的出射粒子。\n\n输入和数据表示（程序内部，无外部输入）：\n- 一个事件是粒子的集合，每个粒子由以下字段描述：粒子标识符 $id$，状态 $s \\in \\{1,2,4\\}$，四维动量 $(E,p_x,p_y,p_z)$（单位 GeV），产生顶点 $v_{\\text{prod}}$（整数，若无则为 $0$），终止顶点 $v_{\\text{end}}$（整数，若无则为 $0$），色标签 $c$（整数，若无则为 $0$），反色标签 $\\bar{c}$（整数，若无则为 $0$）。\n- 顶点由一个非零整数标识。为进行验证，需考虑任何粒子引用的每个顶点。\n\n验证器输出与编码：\n- 对每个事件，生成一个整数代码 $r$，定义为四个检查的位掩码：\n  - 位 $0$ (值 $1$)：在任意顶点处违反局部四维动量守恒（若违反则为 $1$，否则为 $0$）。\n  - 位 $1$ (值 $2$)：事件违反全局四维动量守恒（若违反则为 $2$，否则为 $0$）。\n  - 位 $2$ (值 $4$)：检测到模糊的色连接（若模糊则为 $4$，否则为 $0$）。\n  - 位 $3$ (值 $8$)：检测到循环的色连接（若循环则为 $8$，否则为 $0$）。\n- 因此，$r = 0$ 表示所有检查均通过。\n\n测试套件：\n实现验证器，并在以下参数化事件上对其进行评估，每个事件都与一个容差 $\\epsilon$ 配对：\n- 测试用例 $1$ (基准有效的 $2 \\to 2$ 散射)：\n  - 束流：两个无质量的入射束流粒子，其四维动量分别为 $(E,p_x,p_y,p_z) = (100,0,0,100)$ 和 $(100,0,0,-100)$，均终止于顶点 $100$（状态 $4$）。\n  - 出射：两个末态喷注，在顶点 $100$ 产生，四维动量分别为 $(100,50,0,0)$ 和 $(100,-50,0,0)$（状态 $1$）。\n  - 色：束流 $1$ 携带 $c=101$，喷注 $1$ 携带 $\\bar{c}=101$；束流 $2$ 携带 $c=102$，喷注 $2$ 携带 $\\bar{c}=102$；所有其他色标签为零。\n  - 容差 $\\epsilon = 10^{-6}$ GeV。\n  - 预期行为：所有检查均通过，因此 $r=0$。\n- 测试用例 $2$ (局部和全局违规，对 $\\epsilon$ 敏感，通过有轻微不平衡的衰变)：\n  - 基于测试用例 1，喷注 1 变为中间态（状态 2）并在顶点 200 衰变为两个在 200 处产生的末态子粒子：\n    - 喷注 1 (入射到顶点 200)：$(100,50,0,0)$，终止顶点 200，反色标签设为 0。\n    - 子粒子：粒子 5，四维动量为 $(60,30,0,0)$，反色标签 $\\bar{c}=101$（状态 1）；粒子 6，四维动量为 $(39.99999,19.99999,0,0)$，均在顶点 200 处产生（状态 1）。\n    - 喷注 2 与测试用例 1 中保持一致。\n  - 容差 $\\epsilon = 10^{-6}$ GeV。\n  - 预期行为：顶点 200 处存在局部违规，且由于 $E$ 和 $p_x$ 的亏损 $\\approx 10^{-5}$ GeV 超出容差，存在全局违规，因此 $r=1+2=3$。\n- 测试用例 $3$ (与测试用例 2 事件相同，但容差更宽松)：\n  - 容差 $\\epsilon = 10^{-3}$ GeV。\n  - 预期行为：不平衡量 $\\approx 10^{-5}$ GeV 在容差范围内；所有检查均通过，因此 $r=0$。\n- 测试用例 $4$ (通过排除一个非末态的出射动量，实现仅有全局违规而无局部违规)：\n  - 束流与测试用例 1 中相同，中心顶点为 100：\n    - 出射：喷注 1 $(100,50,0,0)$（状态 1），喷注 2 $(99.9,-50.1,0,0)$（状态 1），类中微子粒子 7 $(0.1,0.1,0,0)$（状态 2），均在顶点 100 产生。\n  - 当包含非末态的出射粒子时，顶点 100 处的局部守恒成立，但当仅对状态 1 的末态求和时，由于存在 0.1 GeV 的净差值，全局守恒失败。\n  - 色：束流 1 和喷注 1 通过 $c=101$ 和 $\\bar{c}=101$ 配对；束流 2 和喷注 2 通过 $c=102$ 和 $\\bar{c}=102$ 配对；非末态粒子色标签为零。\n  - 容差 $\\epsilon = 10^{-3}$ GeV。\n  - 预期行为：局部通过，全局失败，因此 $r=2$。\n- 测试用例 $5$ (模糊的色连接)：\n  - 束流与测试用例 1 中相同，中心顶点为 300：\n    - 出射：三个末态夸克 $q_1$、$q_2$、$q_3$ 在顶点 300 产生，四维动量分别为 $(80,30,0,0)$、$(60,-20,0,0)$、$(60,-10,0,0)$（状态 $1$）。\n  - 色：所有三个夸克都携带相同的色标签 $c=200$，且没有反色（$\\bar{c}=0$）。这导致单个色标识符以 $c$ 角色出现三次，以 $\\bar{c}$ 角色出现零次，这是模糊的。\n  - 容差 $\\epsilon = 10^{-6}$ GeV。\n  - 预期行为：标记为模糊色，其他检查通过，因此 $r=4$。\n- 测试用例 $6$ (三个胶子构成的循环色连接)：\n  - 束流与测试用例 1 中相同，中心顶点为 400：\n    - 出射：三个末态胶子 $g_1$、$g_2$、$g_3$ 在顶点 400 产生，四维动量分别为 $(70,30,0,0)$、$(70,-10,0,0)$、$(60,-20,0,0)$（状态 $1$）。\n  - 色：通过分配 $(c,\\bar{c})$ 对来构建一个三角环：$g_1$ 具有 $(301,303)$，$g_2$ 具有 $(302,301)$，$g_3$ 具有 $(303,302)$。每个色标识符都恰好出现两次，一次是 $c$ 一次是 $\\bar{c}$，因此没有模糊性，但所得的关于 $\\{g_1,g_2,g_3\\}$ 的图具有边 $(g_1,g_2)$、$(g_2,g_3)$、$(g_3,g_1)$，形成一个循环。\n  - 容差 $\\epsilon = 10^{-6}$ GeV。\n  - 预期行为：标记为循环色，其他检查通过，因此 $r=8$。\n- 测试用例 $7$ (对测试用例 1 的基准事件使用 $\\epsilon = 0$ 的边界条件)：\n  - 事件与测试用例 1 相同。\n  - 容差 $\\epsilon = 0$ GeV。\n  - 预期行为：精确的算术相等成立，因此 $r=0$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含测试套件的结果，形式为方括号内由逗号分隔的整数列表（例如 $\\texttt{[r_1,r_2,\\dots]}$）。不应打印任何附加文本。", "solution": "任务是为高能物理事件记录的简化内存表示设计并实现一个验证器。验证器必须执行四个不同的检查：每个相互作用顶点的局部四维动量守恒，整个事件的全局四维动量守恒，以及对量子色动力学（QCD）色流一致性的两个检查，即模糊性和循环连接的存在。每个事件的这些检查结果将被编码成一个单一的整数位掩码。\n\n验证器的设计分为四个主要部分，每个部分对应一个所需的检查。一个总括函数负责协调这些检查并组装最终的结果代码 $r$。\n\n一个事件被定义为粒子的集合。每个粒子都拥有一个标识符 $id$、一个状态码 $s$、一个四维动量 $p^\\mu = (E, p_x, p_y, p_z)$、一个产生顶点 $v_{\\text{prod}}$、一个终止顶点 $v_{\\text{end}}$、一个色标签 $c$ 和一个反色标签 $\\bar{c}$。\n\n一个事件的最终验证码 $r$ 是一个通过位掩码构建的整数：\n$$ r = w_0 \\cdot b_0 + w_1 \\cdot b_1 + w_2 \\cdot b_2 + w_3 \\cdot b_3 $$\n其中 $b_i \\in \\{0, 1\\}$ 是检查 $i$ 的二进制结果（$1$ 代表违规，$0$ 代表成功），$w_i$ 是权重，分别为 $w_0=1, w_1=2, w_2=4, w_3=8$。\n\n**1. 四维动量守恒**\n\n四维动量守恒原理是相对论物理学的基础。验证器在两个层面上检查此原理：局部（在每个顶点）和全局（对整个事件）。\n\n**局部守恒检查**：对于任何相互作用顶点 $v$，所有入射粒子的四维动量总和必须等于所有出射粒子的四维动量总和。如果一个粒子的终止顶点 $v_{\\text{end}}$ 是 $v$，则它被视为 $v$ 的入射粒子。如果它的产生顶点 $v_{\\text{prod}}$ 是 $v$，则它被视为从 $v$ 出射的粒子。\n算法流程如下：\n1.  首先，从所有粒子的 $v_{\\text{prod}}$ 和 $v_{\\text{end}}$ 字段中收集事件记录中所有唯一的非零顶点标识符。\n2.  对于每个唯一的顶点 $v$，我们计算总的入射四维动量 $p^\\mu_{\\text{in}}(v) = \\sum_{i \\in \\text{in}(v)} p_i^\\mu$ 和总的出射四维动量 $p^\\mu_{\\text{out}}(v) = \\sum_{j \\in \\text{out}(v)} p_j^\\mu$。\n3.  计算差值 $\\Delta p^\\mu(v) = p^\\mu_{\\text{in}}(v) - p^\\mu_{\\text{out}}(v)$。\n4.  使用分量最大范数（上确界范数）检查守恒性：$\\|\\Delta p^\\mu(v)\\|_\\infty = \\max(|\\Delta E|, |\\Delta p_x|, |\\Delta p_y|, |\\Delta p_z|)$。\n5.  如果对于任何顶点 $v$，有 $\\|\\Delta p^\\mu(v)\\|_\\infty  \\epsilon$（其中 $\\epsilon$ 是一个指定的数值容差），则标记为违规。如果发现违规，结果代码 $r$ 的位 0 被设置为 1。\n\n**全局守恒检查**：对于整个事件，初始态的总四维动量必须等于末态的总四维动量。初始态由入射束流粒子（状态 $s=4$）定义，末态由所有稳定的末态粒子（状态 $s=1$）组成。\n算法如下：\n1.  计算束流粒子的总四维动量 $p^\\mu_{\\text{beams}} = \\sum_{i | s_i=4} p_i^\\mu$。\n2.  计算末态粒子的总四维动量 $p^\\mu_{\\text{final}} = \\sum_{j | s_j=1} p_j^\\mu$。\n3.  计算差值 $\\Delta p^\\mu_{\\text{global}} = p^\\mu_{\\text{beams}} - p^\\mu_{\\text{final}}$。\n4.  如果 $\\|\\Delta p^\\mu_{\\text{global}}\\|_\\infty  \\epsilon$，则标记为违规。若是，则 $r$ 的位 1 被设置为 1。\n\n**2. 色流验证**\n\n在 QCD 中，色是一个守恒的量子数。一个物理上一致的事件需要一个行为良好的色流。验证器为此实现了两个检查。\n\n**模糊色连接检查**：一个有效色流的规则是，每个非零色标识符必须在事件中恰好出现两次：一次作为某个粒子上的色标签 $c$，另一次作为另一个粒子上的反色标签 $\\bar{c}$。任何偏离此模式的情况都构成模糊性。\n检测模糊性的算法如下：\n1.  使用一个映射（map）来计算每个非零色标识符的出现次数，并跟踪其作为色（$c$）或反色（$\\bar{c}$）的角色。\n2.  算法遍历事件中的所有粒子。对于每个粒子，如果其色标签 $c$ 非零，则标签 $c$ 在‘色’角色下的计数增加。如果其反色标签 $\\bar{c}$ 非零，则标签 $\\bar{c}$ 在‘反色’角色下的计数增加。\n3.  处理完所有粒子后，检查该映射。对于每个色标识符，如果其在‘色’角色下的出现次数不恰好为 1，且在‘反色’角色下的出现次数不恰好为 1，则色流是模糊的。\n4.  如果检测到模糊性，$r$ 的位 2 被设置为 1。\n\n**循环色连接检查**：即使色连接不模糊，它们也可能形成非物理的闭合回路。为了检测这一点，事件的色连接被建模为一个无向图。\n检测循环的算法如下：\n1.  图的节点是粒子，由其唯一 ID 标识。\n2.  如果两个粒子通过一个有效的色-反色对相连，则在它们之间创建一条边。具体来说，如果粒子 $p_i$ 有色 $c=k$，而粒子 $p_j$ 有反色 $\\bar{c}=k$（对于某个非零标识符 $k$），则连接节点 $i$ 和 $j$。这个构建依赖于色流的非模糊性。\n3.  图构建完成后（通常使用邻接表），采用一个循环检测算法。一种标准方法是执行深度优先搜索（DFS）遍历。\n4.  DFS 算法探索图，同时跟踪已访问的节点。为了在无向图中检测循环，DFS 过程还必须跟踪遍历树中当前节点的父节点。如果 DFS 遇到一个已访问过但不是当前节点直接父节点的节点，则说明找到了一条反向边，这表示存在一个循环。\n5.  如果在图中检测到任何此类循环，$r$ 的位 3 被设置为 1。\n\n通过结合这四个检查，验证器对事件记录的物理和结构完整性提供了一个全面的评估，并总结在整数代码 $r$ 中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef validate_event(particles, epsilon):\n    \"\"\"\n    Validates a single event based on four criteria: local and global momentum conservation,\n    and ambiguous or cyclic color connections.\n\n    Args:\n        particles (list): A list of dictionaries, where each dictionary represents a particle.\n        epsilon (float): The tolerance for momentum conservation checks.\n\n    Returns:\n        int: A bitmask integer representing the validation result.\n    \"\"\"\n    result_code = 0\n    \n    # Check 1: Local four-momentum conservation\n    if check_local_momentum_violation(particles, epsilon):\n        result_code |= 1\n        \n    # Check 2: Global four-momentum conservation\n    if check_global_momentum_violation(particles, epsilon):\n        result_code |= 2\n        \n    # Check 3: Ambiguous color connections\n    is_ambiguous, color_map, anticolor_map = check_ambiguous_color(particles)\n    if is_ambiguous:\n        result_code |= 4\n        \n    # Check 4: Cyclic color connections. This check is meaningful only if colors are not ambiguous.\n    if not is_ambiguous and check_cyclic_color(particles, color_map, anticolor_map):\n        result_code |= 8\n        \n    return result_code\n\ndef check_local_momentum_violation(particles, epsilon):\n    \"\"\"Checks for local momentum conservation at each vertex.\"\"\"\n    vertices = defaultdict(lambda: {'in': np.zeros(4), 'out': np.zeros(4)})\n    \n    # Collect all unique vertices and sum momenta\n    for p in particles:\n        if p['v_end'] != 0:\n            vertices[p['v_end']]['in'] += p['p']\n        if p['v_prod'] != 0:\n            vertices[p['v_prod']]['out'] += p['p']\n            \n    # Check conservation for each vertex\n    for v_id, momenta in vertices.items():\n        delta_p = momenta['in'] - momenta['out']\n        norm_inf = np.max(np.abs(delta_p))\n        if norm_inf > epsilon:\n            return True # Violation found\n            \n    return False # No violation\n\ndef check_global_momentum_violation(particles, epsilon):\n    \"\"\"Checks for global event momentum conservation.\"\"\"\n    p_beams = np.zeros(4)\n    p_final = np.zeros(4)\n    \n    for p in particles:\n        if p['s'] == 4: # Incoming beam\n            p_beams += p['p']\n        elif p['s'] == 1: # Final-state stable\n            p_final += p['p']\n            \n    delta_p = p_beams - p_final\n    norm_inf = np.max(np.abs(delta_p))\n    \n    return norm_inf > epsilon\n\ndef check_ambiguous_color(particles):\n    \"\"\"\n    Checks for ambiguous color connections.\n    Returns a tuple: (is_ambiguous, color_map, anticolor_map).\n    The maps are returned for reuse in the cycle check.\n    \"\"\"\n    color_counts = defaultdict(lambda: {'c': 0, 'ac': 0})\n    color_map = {}\n    anticolor_map = {}\n    \n    for p in particles:\n        if p['c'] != 0:\n            color_counts[p['c']]['c'] += 1\n            color_map[p['c']] = p['id']\n        if p['ac'] != 0:\n            color_counts[p['ac']]['ac'] += 1\n            anticolor_map[p['ac']] = p['id']\n            \n    for tag_id, counts in color_counts.items():\n        if counts['c'] != 1 or counts['ac'] != 1:\n            return True, color_map, anticolor_map # Ambiguity found\n            \n    return False, color_map, anticolor_map # No ambiguity\n\ndef check_cyclic_color(particles, color_map, anticolor_map):\n    \"\"\"\n    Builds a graph from color connections and checks for cycles.\n    Assumes color flow is not ambiguous.\n    \"\"\"\n    particle_ids = {p['id'] for p in particles}\n    adj = {pid: [] for pid in particle_ids}\n    \n    # Build graph\n    for c_id, p_id_c in color_map.items():\n        if c_id in anticolor_map:\n            p_id_ac = anticolor_map[c_id]\n            adj[p_id_c].append(p_id_ac)\n            adj[p_id_ac].append(p_id_c)\n            \n    visited = set()\n    \n    def has_cycle_dfs(u, parent):\n        visited.add(u)\n        for v in adj[u]:\n            if v not in visited:\n                if has_cycle_dfs(v, u):\n                    return True\n            elif v != parent:\n                return True # Cycle detected\n        return False\n        \n    for pid in particle_ids:\n        if pid not in visited:\n            if has_cycle_dfs(pid, -1): # Use -1 as a virtual parent for the start node\n                return True\n                \n    return False\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Baseline valid\n        ([\n            {'id': 1, 's': 4, 'p': np.array([100., 0., 0., 100.]), 'v_prod': 0, 'v_end': 100, 'c': 101, 'ac': 0},\n            {'id': 2, 's': 4, 'p': np.array([100., 0., 0., -100.]), 'v_prod': 0, 'v_end': 100, 'c': 102, 'ac': 0},\n            {'id': 3, 's': 1, 'p': np.array([100., 50., 0., 0.]), 'v_prod': 100, 'v_end': 0, 'c': 0, 'ac': 101},\n            {'id': 4, 's': 1, 'p': np.array([100., -50., 0., 0.]), 'v_prod': 100, 'v_end': 0, 'c': 0, 'ac': 102},\n        ], 1e-6),\n        # Case 2: Local and global violation\n        ([\n            {'id': 1, 's': 4, 'p': np.array([100., 0., 0., 100.]), 'v_prod': 0, 'v_end': 100, 'c': 101, 'ac': 0},\n            {'id': 2, 's': 4, 'p': np.array([100., 0., 0., -100.]), 'v_prod': 0, 'v_end': 100, 'c': 102, 'ac': 0},\n            {'id': 3, 's': 2, 'p': np.array([100., 50., 0., 0.]), 'v_prod': 100, 'v_end': 200, 'c': 0, 'ac': 0},\n            {'id': 4, 's': 1, 'p': np.array([100., -50., 0., 0.]), 'v_prod': 100, 'v_end': 0, 'c': 0, 'ac': 102},\n            {'id': 5, 's': 1, 'p': np.array([60., 30., 0., 0.]), 'v_prod': 200, 'v_end': 0, 'c': 0, 'ac': 101},\n            {'id': 6, 's': 1, 'p': np.array([39.99999, 19.99999, 0., 0.]), 'v_prod': 200, 'v_end': 0, 'c': 0, 'ac': 0},\n        ], 1e-6),\n        # Case 3: Same as 2, looser epsilon\n        ([\n            {'id': 1, 's': 4, 'p': np.array([100., 0., 0., 100.]), 'v_prod': 0, 'v_end': 100, 'c': 101, 'ac': 0},\n            {'id': 2, 's': 4, 'p': np.array([100., 0., 0.,-100.]), 'v_prod': 0, 'v_end': 100, 'c': 102, 'ac': 0},\n            {'id': 3, 's': 2, 'p': np.array([100., 50., 0., 0.]), 'v_prod': 100, 'v_end': 200, 'c': 0, 'ac': 0},\n            {'id': 4, 's': 1, 'p': np.array([100., -50., 0., 0.]), 'v_prod': 100, 'v_end': 0, 'c': 0, 'ac': 102},\n            {'id': 5, 's': 1, 'p': np.array([60., 30., 0., 0.]), 'v_prod': 200, 'v_end': 0, 'c': 0, 'ac': 101},\n            {'id': 6, 's': 1, 'p': np.array([39.99999, 19.99999, 0., 0.]), 'v_prod': 200, 'v_end': 0, 'c': 0, 'ac': 0},\n        ], 1e-3),\n        # Case 4: Global violation only\n        ([\n            {'id': 1, 's': 4, 'p': np.array([100., 0., 0., 100.]), 'v_prod': 0, 'v_end': 100, 'c': 101, 'ac': 0},\n            {'id': 2, 's': 4, 'p': np.array([100., 0., 0., -100.]), 'v_prod': 0, 'v_end': 100, 'c': 102, 'ac': 0},\n            {'id': 3, 's': 1, 'p': np.array([100., 50., 0., 0.]), 'v_prod': 100, 'v_end': 0, 'c': 0, 'ac': 101},\n            {'id': 4, 's': 1, 'p': np.array([99.9, -50.1, 0., 0.]), 'v_prod': 100, 'v_end': 0, 'c': 0, 'ac': 102},\n            {'id': 7, 's': 2, 'p': np.array([0.1, 0.1, 0., 0.]), 'v_prod': 100, 'v_end': 0, 'c': 0, 'ac': 0},\n        ], 1e-3),\n        # Case 5: Ambiguous color\n        ([\n            {'id': 1, 's': 4, 'p': np.array([100., 0., 0., 100.]), 'v_prod': 0, 'v_end': 300, 'c': 0, 'ac': 0},\n            {'id': 2, 's': 4, 'p': np.array([100., 0., 0., -100.]), 'v_prod': 0, 'v_end': 300, 'c': 0, 'ac': 0},\n            {'id': 8, 's': 1, 'p': np.array([80., 30., 0., 0.]), 'v_prod': 300, 'v_end': 0, 'c': 200, 'ac': 0},\n            {'id': 9, 's': 1, 'p': np.array([60., -20., 0., 0.]), 'v_prod': 300, 'v_end': 0, 'c': 200, 'ac': 0},\n            {'id': 10, 's': 1, 'p': np.array([60., -10., 0., 0.]), 'v_prod': 300, 'v_end': 0, 'c': 200, 'ac': 0},\n        ], 1e-6),\n        # Case 6: Cyclic color\n        ([\n            {'id': 1, 's': 4, 'p': np.array([100., 0., 0., 100.]), 'v_prod': 0, 'v_end': 400, 'c': 0, 'ac': 0},\n            {'id': 2, 's': 4, 'p': np.array([100., 0., 0., -100.]), 'v_prod': 0, 'v_end': 400, 'c': 0, 'ac': 0},\n            {'id': 11, 's': 1, 'p': np.array([70., 30., 0., 0.]), 'v_prod': 400, 'v_end': 0, 'c': 301, 'ac': 303},\n            {'id': 12, 's': 1, 'p': np.array([70., -10., 0., 0.]), 'v_prod': 400, 'v_end': 0, 'c': 302, 'ac': 301},\n            {'id': 13, 's': 1, 'p': np.array([60., -20., 0., 0.]), 'v_prod': 400, 'v_end': 0, 'c': 303, 'ac': 302},\n        ], 1e-6),\n        # Case 7: Baseline with epsilon=0\n        ([\n            {'id': 1, 's': 4, 'p': np.array([100., 0., 0., 100.]), 'v_prod': 0, 'v_end': 100, 'c': 101, 'ac': 0},\n            {'id': 2, 's': 4, 'p': np.array([100., 0., 0., -100.]), 'v_prod': 0, 'v_end': 100, 'c': 102, 'ac': 0},\n            {'id': 3, 's': 1, 'p': np.array([100., 50., 0., 0.]), 'v_prod': 100, 'v_end': 0, 'c': 0, 'ac': 101},\n            {'id': 4, 's': 1, 'p': np.array([100., -50., 0., 0.]), 'v_prod': 100, 'v_end': 0, 'c': 0, 'ac': 102},\n        ], 0.0),\n    ]\n\n    results = []\n    for particles, epsilon in test_cases:\n        result_code = validate_event(particles, epsilon)\n        results.append(result_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3513384"}]}