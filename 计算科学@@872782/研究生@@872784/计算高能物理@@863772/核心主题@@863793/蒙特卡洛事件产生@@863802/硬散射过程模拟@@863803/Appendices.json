{"hands_on_practices": [{"introduction": "在现代高能物理中，重加权（reweighting）是一项用于评估理论不确定性（源于标度选择、PDF集等）的关键技术，它避免了重新生成海量事件样本所需的高昂计算成本。这项练习将指导你构建一个简化但功能完备的重加权器，通过在一个可控的玩具模型中验证重加权公式，你将巩固对量子色动力学（QCD）因子化定理及其在数据分析中直接应用的理解。[@problem_id:3534365]", "problem": "您需要实现一个独立的程序，该程序在领头阶模拟部分子层面硬散射事件的 Les Houches 事件 (LHE) 重加权，并使用备选的部分子分布函数以及重整化和因子化标度，通过显式重新计算（“完全重生成”）来验证重加权过程。任务是从量子色动力学 (QCD) 因子化的第一性原理和强耦合的单圈跑动中推导出所需的关系，然后在一个稳健且可测试的数值程序中实现它们。所有能量必须以 $\\mathrm{GeV}$ 为单位处理，无量纲的动量分数为无单位量。\n\n基础出发点是 QCD 因子化定理：硬过程的强子截面微分可以写成部分子分布函数 (PDF) 和部分子截面的卷积。在领头阶，部分子截面与强耦合常数的一个幂成比例，该幂由领头阶振幅中 QCD 顶点的数量决定。具体来说，对于由动量分数为 $x_1$ 和 $x_2$ 的入射味 $a$ 和 $b$ 引发、在重整化标度 $\\mu_R$ 和因子化标度 $\\mu_F$ 下计算的事件权重，其形式为\n$$\nw \\propto f_a(x_1,\\mu_F)\\,f_b(x_2,\\mu_F)\\,\\alpha_s(\\mu_R)^{n}\\,\\mathcal{K}(a,b,\\text{flow}),\n$$\n其中 $f_a$ 和 $f_b$ 是 PDF，$\\alpha_s$ 是强耦合，$n$ 是领头阶 $\\alpha_s$ 的幂次，$\\mathcal{K}$ 编码了一个与标度无关的色因子，该因子依赖于初态味和色流类别。\n\n您必须使用具有 $n_f=5$ 个活性味的强耦合单圈跑动：\n$$\n\\alpha_s^{(i)}(\\mu) = \\frac{4\\pi}{\\beta_0 \\ln\\!\\left(\\mu^2/\\Lambda_i^2\\right)},\\quad \\beta_0 = 11 - \\frac{2}{3} n_f,\\quad n_f=5,\n$$\n其中 $\\Lambda_i$ 是 PDF 集 $i$ 的量子色动力学 (QCD) 标度。\n\n为使此问题独立且可进行数值测试，请使用以下两个玩具 PDF 集，它们在 $x\\in(0,1)$ 和远高于 $\\Lambda_i$ 的 $\\mu$ 上是解析且正定的。这些模拟了在实际拟合中看到的标度和 $x$ 依赖性，但并非旨在成为精确的物理模型。\n\n定义一个共同的红外调节标度 $\\mu_0$ 以稳定 PDF 前置因子中的对数：\n$$\n\\mu_0 = 1.0~\\mathrm{GeV}.\n$$\n\n为两个集合 $\\mathcal{S}_0$ 和 $\\mathcal{S}_1$ 定义胶子和轻夸克分布。对于每个集合 $i\\in\\{0,1\\}$，胶子密度为\n$$\nf_g^{(i)}(x,\\mu) = A_g^{(i)}\\left[\\ln\\!\\left(\\frac{\\mu^2+\\mu_0^2}{\\Lambda_i^2}\\right)\\right]^{p_g^{(i)}} x^{-a_g^{(i)}} (1-x)^{b_g^{(i)}},\n$$\n轻夸克和反夸克密度（对于 $u,\\bar u,d,\\bar d,s,\\bar s$）为\n$$\nf_q^{(i)}(x,\\mu) = A_q^{(i)}\\left[\\ln\\!\\left(\\frac{\\mu^2+\\mu_0^2}{\\Lambda_i^2}\\right)\\right]^{p_q^{(i)}} x^{-a_q^{(i)}} (1-x)^{b_q^{(i)}},\n$$\n参数如下：\n- 对于 $\\mathcal{S}_0$：$\\Lambda_0 = 0.20~\\mathrm{GeV}$，$A_g^{(0)}=3.0$，$a_g^{(0)}=0.3$，$b_g^{(0)}=5.0$，$p_g^{(0)}=1.1$，$A_q^{(0)}=0.8$，$a_q^{(0)}=0.2$，$b_q^{(0)}=3.0$，$p_q^{(0)}=0.8$。\n- 对于 $\\mathcal{S}_1$：$\\Lambda_1 = 0.25~\\mathrm{GeV}$，$A_g^{(1)}=3.5$，$a_g^{(1)}=0.35$，$b_g^{(1)}=4.8$，$p_g^{(1)}=1.05$，$A_q^{(1)}=0.9$，$a_q^{(1)}=0.25$，$b_q^{(1)}=2.8$，$p_q^{(1)}=0.75$。\n\n使用以下色因子归一化，它仅取决于初态味，而不取决于标度或 PDF 集：\n- 定义 $C_A=3$ 和 $C_F=\\frac{4}{3}$。\n- 如果两个入射部分子都是胶子，则设 $\\mathcal{K}=C_A^2$。\n- 如果一个入射部分子是胶子，另一个是夸克或反夸克，则设 $\\mathcal{K}=C_A\\,C_F$。\n- 如果两个入射部分子都是夸克和/或反夸克（无胶子），则设 $\\mathcal{K}=C_F^2$。\n- 对于色单态电弱类 Drell–Yan 道，设 $\\mathcal{K}=1$。\n\n使用以下从色流类别到 $\\alpha_s$ 领头阶幂次的映射：\n- 对于色流类别 “DY”（类 Drell–Yan 色单态），使用 $n=0$。\n- 对于色流类别 “QCD_2to2”，使用 $n=2$。\n- 对于色流类别 “Hprod”（胶子融合有效点相互作用），使用 $n=2$。\n\n按如下方式实现重加权逻辑。对于每个事件，给定其存储的 $(x_1,x_2,\\mu_R,\\mu_F)$、入射味和色流类别，使用 PDF 集 $\\mathcal{S}_0$ 和标度 $(\\mu_R,\\mu_F)$ 定义名义权重。通过选择一个目标 PDF 集 $\\mathcal{S}_{\\text{alt}} \\in \\{\\mathcal{S}_0,\\mathcal{S}_1\\}$ 和经过缩放的重整化与因子化标度 $(\\mu_R',\\mu_F')=(k_R \\mu_R, k_F \\mu_F)$（其中 $k_R$ 和 $k_F$ 是给定的标度乘数）来定义一个备选配置。从名义配置到备选配置的重加权因子需要从上述基本关系中推导出来。在备选配置下的“完全重生成”权重必须独立计算，并与重加权后的权重进行比较。对于每个测试用例，报告在所提供事件中的最大绝对相对偏差：\n$$\n\\max_{\\text{events}} \\left| \\frac{w_{\\text{rw}} - w_{\\text{full}}}{w_{\\text{full}}} \\right|.\n$$\n\n要使用的事件，所有能量单位为 $\\mathrm{GeV}$， $x_{1,2}$ 无量纲：\n- 事件 1：类别 “DY”，初态味 $u$ 和 $\\bar u$，$x_1=0.12$，$x_2=0.18$，$\\mu_R=91.1876$，$\\mu_F=91.1876$。\n- 事件 2：类别 “QCD_2to2”，初态味 $u$ 和 $g$，$x_1=0.05$，$x_2=0.20$，$\\mu_R=100.0$，$\\mu_F=100.0$。\n- 事件 3：类别 “QCD_2to2”，初态味 $g$ 和 $g$，$x_1=0.01$，$x_2=0.03$，$\\mu_R=200.0$，$\\mu_F=200.0$。\n- 事件 4：类别 “QCD_2to2”，初态味 $d$ 和 $u$，$x_1=0.20$，$x_2=0.25$，$\\mu_R=150.0$，$\\mu_F=150.0$。\n- 事件 5：类别 “Hprod”，初态味 $g$ 和 $g$，$x_1=0.02$，$x_2=0.02$，$\\mu_R=125.0$，$\\mu_F=125.0$。\n- 事件 6：类别 “QCD_2to2”，初态味 $u$ 和 $g$，$x_1=1.0\\times 10^{-4}$，$x_2=0.60$，$\\mu_R=80.0$，$\\mu_F=80.0$。\n\n用于验证重加权器的备选配置测试套件：\n- 测试 1：$\\mathcal{S}_{\\text{alt}}=\\mathcal{S}_0$，$k_R=2$，$k_F=1$。\n- 测试 2：$\\mathcal{S}_{\\text{alt}}=\\mathcal{S}_0$，$k_R=1$，$k_F=0.5$。\n- 测试 3：$\\mathcal{S}_{\\text{alt}}=\\mathcal{S}_1$，$k_R=1$，$k_F=1$。\n- 测试 4：$\\mathcal{S}_{\\text{alt}}=\\mathcal{S}_1$，$k_R=0.5$，$k_F=2$。\n- 测试 5：$\\mathcal{S}_{\\text{alt}}=\\mathcal{S}_1$，$k_R=2$，$k_F=0.5$。\n\n您的程序应为每个测试计算在所有事件中，重加权权重与完全重生成权重之间的最大绝对相对偏差。最终输出必须是单行，包含一个用方括号括起来的逗号分隔的十进制数列表，例如，“$[r_1,r_2,r_3,r_4,r_5]$”。\n\n所有能量必须以 $\\mathrm{GeV}$ 为单位处理，所有 $x$ 都是无量纲的，并且不出现角度。唯一可接受的输出是如上定义的浮点数，聚合到指定的单行格式中。", "solution": "该问题要求实现并验证一个用于强子对撞中硬散射过程的领头阶 (LO) Les Houches 事件 (LHE) 重加权程序。验证过程包括将通过重加权获得的事件权重与在备选参数配置下通过完全、直接重新计算获得的权重进行比较。预期的结果是，这两个权重在数值浮点精度范围内应该是相同的。这个练习是对正确重加权实现的关键测试。\n\n### 基于原理的推导\n\n**1. 事件权重的基本公式**\n\n出发点是 QCD 因子化定理，该定理指出微分截面，也就是单个事件的权重 $w$，可以表示为部分子分布函数 (PDF) 与部分子硬散射截面的卷积。在领头阶，对于由动量分数为 $x_1$ 和 $x_2$、味为 $a$ 和 $b$ 的部分子在因子化标度 $\\mu_F$ 和重整化标度 $\\mu_R$ 下引发的过程，权重与以下成正比：\n$$\nw \\propto f_a(x_1, \\mu_F) \\, f_b(x_2, \\mu_F) \\, \\alpha_s(\\mu_R)^n \\, \\mathcal{K}\n$$\n这里，$f_i(x, \\mu_F)$ 是味 $i$ 的 PDF，$\\alpha_s(\\mu_R)$ 是强耦合常数，$n$ 是出现在领头阶矩阵元中的 $\\alpha_s$ 的幂次，$\\mathcal{K}$ 是一个与标度无关的因子，与部分子过程的色结构有关。比例常数取决于部分子运动学，但与标度 $\\mu_R, \\mu_F$ 和 PDF 集的选择无关。我们用 $\\sigma_0$ 表示这个常数。\n\n**2. 配置定义**\n\n我们定义两种用于权重计算的配置：\n- **名义配置 (Nominal Configuration)**：这是事件生成的原始配置。它使用 PDF 集 $\\mathcal{S}_0$ 和事件存储的标度 $(\\mu_R, \\mu_F)$。\n- **备选配置 (Alternate Configuration)**：这是我们想要重加权到的新配置。它由一个目标 PDF 集 $\\mathcal{S}_{\\text{alt}}$（可以是 $\\mathcal{S}_0$ 或 $\\mathcal{S}_1$）和新的标度 $(\\mu_R', \\mu_F') = (k_R \\mu_R, k_F \\mu_F)$ 定义。\n\n**3. 权重显式表达式**\n\n使用基本公式，我们可以写出两种配置下权重的表达式。\n\n**名义权重** $w_{\\text{nom}}$ 是使用名义配置计算的：\n$$\nw_{\\text{nom}} = \\sigma_0 \\cdot f_a^{(0)}(x_1, \\mu_F) \\, f_b^{(0)}(x_2, \\mu_F) \\, \\left[\\alpha_s^{(0)}(\\mu_R)\\right]^n \\, \\mathcal{K}\n$$\n其中上标 $(0)$ 表示使用 PDF 集 $\\mathcal{S}_0$ 的参数进行评估。\n\n**完全重生成权重** $w_{\\text{full}}$ 是直接使用备选配置计算的：\n$$\nw_{\\text{full}} = \\sigma_0 \\cdot f_a^{(\\text{alt})}(x_1, \\mu_F') \\, f_b^{(\\text{alt})}(x_2, \\mu_F') \\, \\left[\\alpha_s^{(\\text{alt})}(\\mu_R')\\right]^n \\, \\mathcal{K}\n$$\n其中上标 $(\\text{alt})$ 表示使用备选 PDF 集 $\\mathcal{S}_{\\text{alt}}$ 的参数进行评估。\n\n**4. 重加权因子的推导**\n\n重加权因子 $R$ 定义为备选配置中的事件权重与名义配置中事件权重的比值。\n$$\nR = \\frac{w_{\\text{alt}}}{w_{\\text{nom}}} = \\frac{\\sigma_0 \\cdot f_a^{(\\text{alt})}(x_1, \\mu_F') \\, f_b^{(\\text{alt})}(x_2, \\mu_F') \\, \\left[\\alpha_s^{(\\text{alt})}(\\mu_R')\\right]^n \\, \\mathcal{K}}{\\sigma_0 \\cdot f_a^{(0)}(x_1, \\mu_F) \\, f_b^{(0)}(x_2, \\mu_F) \\, \\left[\\alpha_s^{(0)}(\\mu_R)\\right]^n \\, \\mathcal{K}}\n$$\n与标度无关的因子 $\\sigma_0$ 和 $\\mathcal{K}$ 被约掉，得到可以从已知量计算的重加权因子：\n$$\nR = \\left( \\frac{f_a^{(\\text{alt})}(x_1, \\mu_F') \\, f_b^{(\\text{alt})}(x_2, \\mu_F')}{f_a^{(0)}(x_1, \\mu_F) \\, f_b^{(0)}(x_2, \\mu_F)} \\right) \\cdot \\left( \\frac{\\alpha_s^{(\\text{alt})}(\\mu_R')}{\\alpha_s^{(0)}(\\mu_R)} \\right)^n\n$$\n\n**5. 重加权权重与验证原理**\n\n**重加权后的权重** $w_{\\text{rw}}$ 是通过将名义权重乘以重加权因子 $R$ 得到的：\n$$\nw_{\\text{rw}} = w_{\\text{nom}} \\times R\n$$\n代入 $w_{\\text{nom}}$ 和 $R$ 的表达式：\n$$\nw_{\\text{rw}} = \\left( \\sigma_0 \\cdot f_a^{(0)} f_b^{(0)} (\\alpha_s^{(0)})^n \\mathcal{K} \\right) \\times \\left( \\frac{f_a^{(\\text{alt})} f_b^{(\\text{alt})}}{f_a^{(0)} f_b^{(0)}} \\cdot \\frac{(\\alpha_s^{(\\text{alt})})^n}{(\\alpha_s^{(0)})^n} \\right)\n$$\n对应于名义配置的项被约掉，剩下：\n$$\nw_{\\text{rw}} = \\sigma_0 \\cdot f_a^{(\\text{alt})}(x_1, \\mu_F') \\, f_b^{(\\text{alt})}(x_2, \\mu_F') \\, \\left[\\alpha_s^{(\\text{alt})}(\\mu_R')\\right]^n \\, \\mathcal{K}\n$$\n这个表达式与 $w_{\\text{full}}$ 的表达式完全相同。因此，我们得到了理论上的恒等式：\n$$\nw_{\\text{rw}} \\equiv w_{\\text{full}}\n$$\n程序的目标是数值上验证这个恒等式。任何偏差都将归因于浮点精度误差。\n\n### 算法实现\n\n验证通过以下步骤实现：\n1.  **定义数值常数和参数**：存储所有物理常数（例如，对于 $n_f=5$，$β_0 = 11 - \\frac{2}{3}n_f = \\frac{23}{3}$）以及两个玩具 PDF 集 $\\mathcal{S}_0$ 和 $\\mathcal{S}_1$ 的参数。\n2.  **实现组件函数**：创建函数来计算：\n    - 单圈强耦合 $\\alpha_s^{(i)}(\\mu)$。\n    - 玩具 PDF 值 $f_{\\text{flavor}}^{(i)}(x, \\mu)$，根据胶子或夸克味进行分派。\n    - 与过程相关的 $\\alpha_s$ 的幂次 $n$。\n    - 初态色因子 $\\mathcal{K}$。此逻辑必须正确处理 “DY” 类别规则相对于一般基于味的规则的优先级。\n3.  **实现权重计算函数**：一个函数 `calculate_weight` 封装了对给定 PDF 集和标度的事件权重的直接计算，对应于 $w_{\\text{full}}$。我们可以设置未知的比例常数 $\\sigma_0=1$，因为它在最终的相对偏差中会被约掉。\n4.  **主验证循环**：\n    - 遍历五个测试配置 $(\\mathcal{S}_{\\text{alt}}, k_R, k_F)$ 中的每一个。\n    - 对于每个测试，初始化一个最大相对偏差 $\\max_{\\text{dev}}$ 为零。\n    - 遍历提供的六个事件中的每一个。\n    - 对于每个事件：\n        a. 使用 $\\mathcal{S}_0$ 和事件的原始标度 $(\\mu_R, \\mu_F)$ 计算名义权重 $w_{\\text{nom}}$。\n        b. 使用 $\\mathcal{S}_{\\text{alt}}$ 和修改后的标度 $(\\mu_R', \\mu_F')$ 计算完全重生成权重 $w_{\\text{full}}$。\n        c. 使用推导出的公式计算重加权因子 $R$。\n        d. 计算重加权权重 $w_{\\text{rw}} = w_{\\text{nom}} \\times R$。\n        e. 计算绝对相对偏差 $|\\frac{w_{\\text{rw}} - w_{\\text{full}}}{w_{\\text{full}}}|$。\n        f. 如果当前偏差更大，则更新 $\\max_{\\text{dev}}$。\n    - 存储该测试配置的最终 $\\max_{\\text{dev}}$。\n5.  **输出**：将所有测试的最大偏差列表格式化为指定的字符串格式。预期的结果是非常接近于零的值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates LHE reweighting for parton-level hard-scattering events.\n    \"\"\"\n\n    # --- Constants and Parameters ---\n\n    # Physical constants for QCD with n_f=5\n    BETA0 = 11.0 - (2.0 / 3.0) * 5.0\n    MU0 = 1.0  # Common IR regulator scale in GeV\n    C_A = 3.0\n    C_F = 4.0 / 3.0\n\n    # PDF set parameters for S0 (id=0) and S1 (id=1)\n    PDF_PARAMS = [\n        {  # Set S0\n            'Lambda': 0.20,\n            'g': {'A': 3.0, 'a': 0.3, 'b': 5.0, 'p': 1.1},\n            'q': {'A': 0.8, 'a': 0.2, 'b': 3.0, 'p': 0.8}\n        },\n        {  # Set S1\n            'Lambda': 0.25,\n            'g': {'A': 3.5, 'a': 0.35, 'b': 4.8, 'p': 1.05},\n            'q': {'A': 0.9, 'a': 0.25, 'b': 2.8, 'p': 0.75}\n        }\n    ]\n\n    # Event data as specified in the problem\n    EVENTS = [\n        {'category': \"DY\", 'flav1': 'u', 'flav2': 'ubar', 'x1': 0.12, 'x2': 0.18, 'mu_R': 91.1876, 'mu_F': 91.1876},\n        {'category': \"QCD_2to2\", 'flav1': 'u', 'flav2': 'g', 'x1': 0.05, 'x2': 0.20, 'mu_R': 100.0, 'mu_F': 100.0},\n        {'category': \"QCD_2to2\", 'flav1': 'g', 'flav2': 'g', 'x1': 0.01, 'x2': 0.03, 'mu_R': 200.0, 'mu_F': 200.0},\n        {'category': \"QCD_2to2\", 'flav1': 'd', 'flav2': 'u', 'x1': 0.20, 'x2': 0.25, 'mu_R': 150.0, 'mu_F': 150.0},\n        {'category': \"Hprod\", 'flav1': 'g', 'flav2': 'g', 'x1': 0.02, 'x2': 0.02, 'mu_R': 125.0, 'mu_F': 125.0},\n        {'category': \"QCD_2to2\", 'flav1': 'u', 'flav2': 'g', 'x1': 1.0e-4, 'x2': 0.60, 'mu_R': 80.0, 'mu_F': 80.0},\n    ]\n\n    # Test suite of alternate configurations\n    test_cases = [\n        {'alt_pdf_set_id': 0, 'k_R': 2.0, 'k_F': 1.0},\n        {'alt_pdf_set_id': 0, 'k_R': 1.0, 'k_F': 0.5},\n        {'alt_pdf_set_id': 1, 'k_R': 1.0, 'k_F': 1.0},\n        {'alt_pdf_set_id': 1, 'k_R': 0.5, 'k_F': 2.0},\n        {'alt_pdf_set_id': 1, 'k_R': 2.0, 'k_F': 0.5},\n    ]\n\n    # --- Helper Functions ---\n\n    def get_parton_type(flavor):\n        return 'g' if flavor == 'g' else 'q'\n\n    def alpha_s(mu, Lambda):\n        return (4.0 * np.pi) / (BETA0 * np.log(mu**2 / Lambda**2))\n\n    def pdf(flavor, x, mu, pdf_set_id):\n        parton_type = get_parton_type(flavor)\n        params = PDF_PARAMS[pdf_set_id]\n        p_params = params[parton_type]\n        Lambda = params['Lambda']\n        log_term = np.log((mu**2 + MU0**2) / Lambda**2)\n        \n        return (p_params['A'] *\n                np.power(log_term, p_params['p']) *\n                np.power(x, -p_params['a']) *\n                np.power(1.0 - x, p_params['b']))\n\n    def get_alpha_s_power(category):\n        if category == \"DY\":\n            return 0\n        return 2 # For \"QCD_2to2\" and \"Hprod\"\n\n    def get_color_factor(flav1, flav2, category):\n        if category == \"DY\":\n            return 1.0\n        \n        num_gluons = (1 if flav1 == 'g' else 0) + (1 if flav2 == 'g' else 0)\n        \n        if num_gluons == 2:\n            return C_A**2\n        elif num_gluons == 1:\n            return C_A * C_F\n        else:  # num_gluons == 0\n            return C_F**2\n\n    def calculate_weight(event, pdf_set_id, mu_R, mu_F):\n        f1, f2 = event['flav1'], event['flav2']\n        x1, x2 = event['x1'], event['x2']\n        category = event['category']\n        \n        pdf1 = pdf(f1, x1, mu_F, pdf_set_id)\n        pdf2 = pdf(f2, x2, mu_F, pdf_set_id)\n        \n        n = get_alpha_s_power(category)\n        if n  0:\n            Lambda = PDF_PARAMS[pdf_set_id]['Lambda']\n            as_val = alpha_s(mu_R, Lambda)\n            as_factor = np.power(as_val, n)\n        else:\n            as_factor = 1.0\n        \n        K = get_color_factor(f1, f2, category)\n        \n        return pdf1 * pdf2 * as_factor * K\n\n    # --- Main Logic ---\n    results = []\n    for case in test_cases:\n        alt_pdf_set_id = case['alt_pdf_set_id']\n        k_R, k_F = case['k_R'], case['k_F']\n        \n        max_rel_dev = 0.0\n        \n        for event in EVENTS:\n            # Nominal configuration\n            nom_pdf_set_id = 0\n            nom_mu_R, nom_mu_F = event['mu_R'], event['mu_F']\n\n            # Alternate configuration\n            alt_mu_R, alt_mu_F = k_R * nom_mu_R, k_F * nom_mu_F\n\n            # 1. Calculate nominal weight\n            w_nom = calculate_weight(event, nom_pdf_set_id, nom_mu_R, nom_mu_F)\n            \n            # 2. Calculate full regenerated weight\n            w_full = calculate_weight(event, alt_pdf_set_id, alt_mu_R, alt_mu_F)\n            \n            # 3. Calculate reweighted weight via reweighting factor R\n            n = get_alpha_s_power(event['category'])\n            \n            f1_nom = pdf(event['flav1'], event['x1'], nom_mu_F, nom_pdf_set_id)\n            f2_nom = pdf(event['flav2'], event['x2'], nom_mu_F, nom_pdf_set_id)\n            f1_alt = pdf(event['flav1'], event['x1'], alt_mu_F, alt_pdf_set_id)\n            f2_alt = pdf(event['flav2'], event['x2'], alt_mu_F, alt_pdf_set_id)\n            pdf_ratio = (f1_alt * f2_alt) / (f1_nom * f2_nom)\n            \n            if n  0:\n                as_nom = alpha_s(nom_mu_R, PDF_PARAMS[nom_pdf_set_id]['Lambda'])\n                as_alt = alpha_s(alt_mu_R, PDF_PARAMS[alt_pdf_set_id]['Lambda'])\n                as_ratio_pow = np.power(as_alt / as_nom, n)\n            else:\n                as_ratio_pow = 1.0\n\n            R = pdf_ratio * as_ratio_pow\n            w_rw = w_nom * R\n\n            # 4. Compare and update max relative deviation\n            if w_full != 0:\n                rel_dev = np.abs((w_rw - w_full) / w_full)\n                if rel_dev  max_rel_dev:\n                    max_rel_dev = rel_dev\n        \n        results.append(max_rel_dev)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.1g}' for r in results)}]\")\n\nsolve()\n```", "id": "3534365"}, {"introduction": "规范不变性（gauge invariance）是量子场论的基石，任何有效的模拟都必须遵守这一原则。然而，一些看似合理的近似方法，例如只考虑共振图，可能会破坏这一原则，从而导致非物理的结果。这项练习提供了一个具体的例子来揭示这一陷阱，并演示了如何使用标准技术（壳上投影）来恢复规范不变性，让你深入理解理论原则与实际模拟选择之间的相互作用。[@problem_id:3534352]", "problem": "考虑在一次硬散射过程中，软光子发射的瓦德恒等式的数值验证。该过程包含一个带电中间共振态，并且是与硬散射过程模拟相关的部分子级过程。您将研究过程 $u \\,\\bar{d} \\to W^{+} \\to \\ell^{+} \\,\\nu_{\\ell}$，其中带电粒子线发射一个动量为 $k^\\mu$ 的额外实光子。在自然单位制（$c=\\hbar=1$）下进行计算，并使用闵可夫斯基度规，其号差为 $(+,-,-,-)$。\n\n从经过充分检验的 Low-Burnett-Kroll 软光子定理出发，矩阵元的主导软光子因子化由普适的程函电流决定。设带电外部粒子腿的集合由 $i$ 索引，每个粒子腿都带有电荷 $Q_i$（以正电子电荷为单位）和四维动量 $p_i^\\mu$。对于入射粒子腿，指定 $\\eta_i=-1$；对于出射粒子腿，指定 $\\eta_i=+1$。程函电流 $J^\\mu$ 正比于对所有带电粒子腿求和，各项权重为 $\\eta_i Q_i$ 和程函因子 $p_i^\\mu/(p_i\\cdot k)$。规范不变性所要求的瓦德恒等式为 $k_\\mu J^\\mu = 0$。模拟中规范不变性破缺的一个常见来源是唯共振近似，即只保留一部分费曼图（例如，仅来自带电衰变产物）的光子发射，这通常会导致 $k_\\mu J^\\mu \\neq 0$。一种补救方法是在一个规范不变子集内通过在壳投影来恢复流守恒。该方法将共振中间玻色子视为衰变子过程中的一个外部在壳态，并将其对程函电流的贡献以适当的符号包含在内。\n\n您的任务是实现一个程序，针对指定的运动学参数，构建相关的四维矢量，并计算软流收缩 $k_\\mu J^\\mu$ 的三种变体：\n- 变体 A（唯共振朴素近似）：仅包含出射带电轻子 $\\ell^{+}$ 的贡献。\n- 变体 B（在壳投影衰变流）：包含出射带电轻子 $\\ell^{+}$ 的贡献，以及一个对应于进入衰变子过程的入射 $W^{+}$ 粒子腿的附加项。该附加项被视为一个外部在壳动量 $\\hat{q}^\\mu$，与 $q^\\mu = p_1^\\mu + p_2^\\mu - k^\\mu$ 共线，并满足 $\\hat{q}^2 = M_W^2$。投影定义为 $\\hat{q}^\\mu = \\lambda q^\\mu$，其中 $\\lambda = \\sqrt{M_W^2 / q^2}$ 且 $\\operatorname{sign}(\\hat{q}^0) = \\operatorname{sign}(q^0)$。使用 $Q_W=+1$。\n- 变体 C（全部外部带电粒子腿）：包含入射 $u$ 夸克、入射 $\\bar{d}$ 反夸克和出射 $\\ell^{+}$ 的贡献。\n\n对于每个变体，计算规范不变性诊断量\n$$\n\\Delta \\equiv \\frac{\\left|k_\\mu J^\\mu\\right|}{e},\n$$\n其中 $e$ 是正电子电荷的大小。在程函近似中，$\\Delta$ 简化为带符号 $\\eta_i$ 的电荷的代数和，并且是无量纲的。如果在浮点容差范围内 $\\Delta$ 数值上为零，则规范不变性得到满足。\n\n运动学构建与输入：\n- 在质心能量为 $\\sqrt{s}$ 的部分子质心系中工作，其中入射动量对于 $u$ 夸克为 $p_1^\\mu = (\\sqrt{s}/2, 0, 0, +\\sqrt{s}/2)$，对于 $\\bar{d}$ 反夸克为 $p_2^\\mu = (\\sqrt{s}/2, 0, 0, -\\sqrt{s}/2)$。\n- 实光子的能量为 $E_\\gamma$，方向由极角 $\\theta_\\gamma$ 和方位角 $\\phi_\\gamma$ 指定；其四维动量为 $k^\\mu = (E_\\gamma, E_\\gamma \\sin\\theta_\\gamma \\cos\\phi_\\gamma, E_\\gamma \\sin\\theta_\\gamma \\sin\\phi_\\gamma, E_\\gamma \\cos\\theta_\\gamma)$。\n- 中间玻色子的动量为 $q^\\mu = p_1^\\mu + p_2^\\mu - k^\\mu$，通常是离壳的，即 $q^2 \\neq M_W^2$。\n- 衰变 $W^+ \\to \\ell^+ \\nu$ 在 $q$ 静止系中被建模为向无质量粒子的两体衰变，其中带电轻子的衰变方向为 $(\\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}})$。然后将衰变产物通过洛伦兹变换助推回实验室参考系，以获得 $p_\\ell^\\mu$ 和 $p_\\nu^\\mu$，使得 $p_\\ell^\\mu + p_\\nu^\\mu = q^\\mu$ 精确成立。您必须确保对于所选参数，$q^2 > 0$。\n- 使用电荷 $Q_u = +2/3$、$Q_{\\bar{d}} = +1/3$、$Q_\\ell = +1$ 和 $Q_W = +1$。在变体 C 中，符号 $\\eta_i$ 应用为 $\\eta_u = -1$、$\\eta_{\\bar{d}} = -1$、$\\eta_{\\ell} = +1$。中微子是中性的，没有贡献。\n\n实现要求：\n- 为构建两体衰变，明确地实现到 $q$ 静止系以及从 $q$ 静止系返回的洛伦兹变换。\n- 实现 在壳投影 $\\hat{q}^\\mu = \\lambda q^\\mu$，其中 $\\lambda = \\sqrt{M_W^2/q^2}$，并在变体 B 中使用 $\\hat{q}\\cdot k$。\n- 对下面的每个测试用例，计算变体 A、B 和 C 的 $\\Delta$ 值。所有四维矢量均以 $\\mathrm{GeV}$ 为单位，角度以弧度为单位。将输出报告为无量纲浮点数。\n\n测试套件：\n使用 $M_W = 80.379\\,\\mathrm{GeV}$ 以及以下由元组 $(\\sqrt{s}, E_\\gamma, \\theta_\\gamma, \\phi_\\gamma, \\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}})$ 指定的四个测试用例，其中所有能量单位为 $\\mathrm{GeV}$，所有角度单位为弧度：\n- 用例 1（通用运动学）：$(\\sqrt{s}, E_\\gamma, \\theta_\\gamma, \\phi_\\gamma, \\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}}) = (500, 5, 0.7, 1.0, 1.3, 0.5)$。\n- 用例 2（软光子）：$(\\sqrt{s}, E_\\gamma, \\theta_\\gamma, \\phi_\\gamma, \\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}}) = (500, 10^{-3}, 1.1, 2.2, 0.9, 1.7)$。\n- 用例 3（近共线轻子-光子）：$(\\sqrt{s}, E_\\gamma, \\theta_\\gamma, \\phi_\\gamma, \\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}}) = (500, 2, 0.9005, 0.2005, 0.9, 0.2)$。\n- 用例 4（硬光子，离壳 $q^2$）：$(\\sqrt{s}, E_\\gamma, \\theta_\\gamma, \\phi_\\gamma, \\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}}) = (500, 200, 1.2, 2.0, 0.4, 2.5)$。\n\n必需的最终输出：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按上述顺序包含每个用例的三个值 $\\left[\\Delta_{\\mathrm{A}}, \\Delta_{\\mathrm{B}}, \\Delta_{\\mathrm{C}}\\right]$，并按此顺序连接所有用例的结果。例如，输出格式必须为\n$[\\Delta_{\\mathrm{A}}^{(1)},\\Delta_{\\mathrm{B}}^{(1)},\\Delta_{\\mathrm{C}}^{(1)},\\Delta_{\\mathrm{A}}^{(2)},\\Delta_{\\mathrm{B}}^{(2)},\\Delta_{\\mathrm{C}}^{(2)},\\Delta_{\\mathrm{A}}^{(3)},\\Delta_{\\mathrm{B}}^{(3)},\\Delta_{\\mathrm{C}}^{(3)},\\Delta_{\\mathrm{A}}^{(4)},\\Delta_{\\mathrm{B}}^{(4)},\\Delta_{\\mathrm{C}}^{(4)}]$，其中每个 $\\Delta$ 都报告为无量纲浮点数。", "solution": "该问题要求对过程 $u \\,\\bar{d} \\to W^{+} \\to \\ell^{+} \\,\\nu_{\\ell} + \\gamma$ 中软光子发射的规范不变性进行数值验证。该验证通过计算光子动量 $k^\\mu$ 与程函电流 $J^\\mu$ 的收缩来实现，其中程函电流针对发射带电粒子的集合采用了三种不同的近似（变体）。规范不变性的诊断量定义为 $\\Delta \\equiv \\left|k_\\mu J^\\mu\\right|/e$，其中 $e$ 是元电荷。\n\n**基本原理：规范不变性与软光子定理**\n\n量子电动力学的一个基本原理是规范不变性。对于一个涉及发射动量为 $k^\\mu$、极化矢量为 $\\epsilon^\\mu$ 的实光子的过程，其散射振幅 $\\mathcal{M}$ 必须在规范变换 $\\epsilon^\\mu \\to \\epsilon^\\mu + \\alpha k^\\mu$ 下保持不变，其中 $\\alpha$ 为任意标量。这意味着，如果我们将极化矢量替换为光子动量，得到的振幅必须为零：$k_\\mu \\mathcal{M}^\\mu(k) = 0$。这是瓦德-高桥恒等式的一种体现。\n\n在软光子极限下（$E_\\gamma \\to 0$），Low-Burnett-Kroll (LBK) 定理给出了散射振幅的一个普适因子化。主导项由程函近似给出，其中带光子过程的振幅与不带光子过程的振幅 $\\mathcal{M}_0$ 相关：\n$$\n\\mathcal{M} \\approx e \\left( \\sum_{i \\in \\text{charged}} \\eta_i Q_i \\frac{p_i^\\mu}{p_i \\cdot k} \\right) \\epsilon_\\mu^* \\mathcal{M}_0 \\equiv J^\\mu \\epsilon_\\mu^* \\mathcal{M}_0\n$$\n此处，求和遍及所有外部带电粒子，$Q_i$ 是粒子 $i$ 的电荷（以 $e$ 为单位），$p_i^\\mu$ 是其四维动量，$\\eta_i$ 是一个符号因子，对于入射粒子为 $-1$，对于出射粒子为 $+1$。\n\n规范不变性条件 $k_\\mu \\mathcal{M}^\\mu = 0$ 转化为对程函电流的要求 $k_\\mu J^\\mu = 0$。让我们来计算这个收缩：\n$$\nk_\\mu J^\\mu = k_\\mu \\left( e \\sum_i \\eta_i Q_i \\frac{p_i^\\mu}{p_i \\cdot k} \\right) = e \\sum_i \\eta_i Q_i \\frac{k \\cdot p_i}{p_i \\cdot k}\n$$\n由于闵可夫斯基点积是对称的，因此 $k \\cdot p_i = p_i \\cdot k$。只要没有带电粒子与光子完全共线（即 $p_i \\cdot k \\neq 0$），每一项 $\\frac{k \\cdot p_i}{p_i \\cdot k}$ 都精确地等于 $1$。因此，该收缩简化为对流中所包含粒子的带符号电荷求和：\n$$\nk_\\mu J^\\mu = e \\sum_i \\eta_i Q_i\n$$\n当且仅当所考虑的粒子集合的总电荷守恒时，此表达式为零。因此，诊断量 $\\Delta$ 变为：\n$$\n\\Delta = \\frac{|k_\\mu J^\\mu|}{e} = \\left| \\sum_i \\eta_i Q_i \\right|\n$$\n只要计算具有足够的数值精度，这个结果纯粹是代数的，并且与具体的运动学（动量）无关。问题的核心是构建完整的运动学，并验证这个简单的解析结果能够被数值再现。\n\n**三种变体的分析**\n\n1.  **变体 A（唯共振朴素近似）：** 电流仅包含出射带电轻子 $\\ell^+$ 的贡献。发射体集合为 $\\{\\ell^+\\}$。\n    -   $\\sum_i \\eta_i Q_i = \\eta_\\ell Q_\\ell = (+1)(+1) = 1$。\n    -   理论上，$\\Delta_A = |1| = 1$。此电流不是规范不变的，因为它不对应于一个电荷守恒的过程。\n\n2.  **变体 B（在壳投影衰变流）：** 电流包含出射 $\\ell^+$ 和对于衰变子过程 $W^+ \\to \\ell^+ \\nu_\\ell$ 的入射有效 $W^+$ 的贡献。发射体集合为 $\\{W^+_{\\text{in}}, \\ell^+_{\\text{out}}\\}$。\n    -   $\\sum_i \\eta_i Q_i = \\eta_W Q_W + \\eta_\\ell Q_\\ell = (-1)(+1) + (+1)(+1) = 0$。\n    -   理论上，$\\Delta_B = |0| = 0$。此电流是规范不变的，因为在子过程中电荷是守恒的。为 $W^+$ 使用投影动量 $\\hat{q}^\\mu$ 是一种为中间粒子定义在壳动量的技术，但它不改变基本的电荷守恒性质。\n\n3.  **变体 C（全部外部带电粒子腿）：** 电流包含整个过程 $u\\,\\bar{d} \\to \\ell^+\\nu_\\ell\\gamma$ 的所有外部带电粒子：入射 $u$ 夸克、入射 $\\bar{d}$ 反夸克和出射 $\\ell^+$。发射体集合为 $\\{u_{\\text{in}}, \\bar{d}_{\\text{in}}, \\ell^+_{\\text{out}}\\}$。\n    -   $Q_u = +2/3$，$Q_{\\bar{d}}=+1/3$。注意 $\\bar{d}$ 反夸克的电荷与 $d$ 夸克相反。\n    -   $\\sum_i \\eta_i Q_i = \\eta_u Q_u + \\eta_{\\bar{d}} Q_{\\bar{d}} + \\eta_\\ell Q_\\ell = (-1)(+2/3) + (-1)(+1/3) + (+1)(+1) = -1 + 1 = 0$。\n    -   理论上，$\\Delta_C = |0| = 0$。此电流是规范不变的，因为它包含了一个电荷守恒的物理过程的所有外部带电粒子。\n\n**数值实现策略**\n\n程序将对每个测试用例执行完整的运动学构建，然后数值计算 $\\Delta$ 值，以验证预期的解析结果 $[1, 0, 0]$。\n\n1.  **定义常数和四维矢量：** 所有常数（$M_W$、电荷）和初始四维矢量（$u$ 的 $p_1^\\mu$、$\\bar{d}$ 的 $p_2^\\mu$、$\\gamma$ 的 $k^\\mu$）均使用给定参数在部分子质心系中构建。中间玻色子动量计算为 $q^\\mu = p_1^\\mu + p_2^\\mu - k^\\mu$。我们对所有点积使用号差为 $(+,-,-,-)$ 的闵可夫斯基度规。\n\n2.  **两体衰变与洛伦兹变换：** 为了获得轻子动量 $p_\\ell^\\mu$，我们首先在中间矢量玻色子的静止系（“$q$-系”）中对衰变进行建模。在此参考系中，玻色子的动量为 $q'^\\mu = (\\sqrt{q^2}, 0, 0, 0)$。衰变产物 $\\ell^+$ 和 $\\nu_\\ell$ 是无质量的，能量为 $E'_\\ell = E'_\\nu = \\sqrt{q^2}/2$。轻子的动量四维矢量 $p'^\\mu_\\ell$ 使用给定的衰变角 $(\\theta_{\\mathrm{dec}}, \\phi_{\\mathrm{dec}})$ 构建。然后使用洛伦兹变换将此矢量变换回实验室参考系。该变换由 $q$-系相对于实验室参考系的速度 $\\vec{\\beta} = \\vec{q}/q_0$ 参数化。使用数值稳定的洛伦兹变换公式来求得 $p_\\ell^\\mu$。\n\n3.  **诊断量计算：** 对每个变体（A、B、C），计算 $\\Delta$ 的求和。这包括计算每个相关动量（$p_1^\\mu, p_2^\\mu, p_\\ell^\\mu, \\hat{q}^\\mu$）的点积 $p_i \\cdot k$，然后评估表达式 $\\left|\\sum_i \\eta_i Q_i (k \\cdot p_i) / (p_i \\cdot k)\\right|$。此过程将测试在浮点运算条件下，数值评估是否能重现电荷守恒所预测的整数结果，尤其是在用例 3 的近共线运动学中，$p_\\ell \\cdot k$ 会变得非常小。$\\Delta_B$ 和 $\\Delta_C$ 的结果预计在数值上接近于零（例如，在机器精度量级）。\n\n这一详细的数值步骤可作为对软光子近似实现的稳健性检查，以及在计算环境中对基本规范原理的验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the computational high-energy physics problem regarding Ward identities\n    for soft photon emission.\n    \"\"\"\n\n    # --- Constants and Physical Parameters ---\n    M_W = 80.379  # GeV\n    Q_u = 2.0 / 3.0\n    Q_dbar = 1.0 / 3.0\n    Q_ell = 1.0\n    Q_W = 1.0\n    eta_u = -1.0\n    eta_dbar = -1.0\n    eta_ell = 1.0\n    eta_W = -1.0  # W+ is an incoming particle in the decay subprocess\n\n    # --- Test Cases ---\n    # Tuples of (sqrt_s, E_gamma, theta_gamma, phi_gamma, theta_dec, phi_dec)\n    test_cases = [\n        (500.0, 5.0, 0.7, 1.0, 1.3, 0.5),\n        (500.0, 1e-3, 1.1, 2.2, 0.9, 1.7),\n        (500.0, 2.0, 0.9005, 0.2005, 0.9, 0.2),\n        (500.0, 200.0, 1.2, 2.0, 0.4, 2.5),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        sqrt_s, E_gamma, theta_gamma, phi_gamma, theta_dec, phi_dec = case\n\n        # --- Helper Functions for 4-Vector Operations ---\n        def minkowski_dot(v1, v2):\n            \"\"\"Computes the dot product of two 4-vectors using (+, -, -, -) metric.\"\"\"\n            return v1[0] * v2[0] - np.dot(v1[1:], v2[1:])\n\n        def lorentz_boost(p_prime, q_lab):\n            \"\"\"\n            Boosts a 4-vector p_prime from the rest frame of a particle q\n            to the lab frame where q has 4-momentum q_lab.\n            Uses a numerically stable formula.\n            \"\"\"\n            m_q_sq = minkowski_dot(q_lab, q_lab)\n            if m_q_sq = 1e-12:  # Protect against spacelike or null q\n                raise ValueError(\"Cannot boost to rest frame of a space-like or light-like particle.\")\n            m_q = np.sqrt(m_q_sq)\n            q0 = q_lab[0]\n            q_vec = q_lab[1:]\n\n            if np.allclose(q_vec, 0):\n                return p_prime\n\n            p_prime_E = p_prime[0]\n            p_prime_vec = p_prime[1:]\n\n            # Energy in lab frame: E_lab = (q0*E' + q_vec . p'_vec) / m_q\n            p_lab_E = (q0 * p_prime_E + np.dot(q_vec, p_prime_vec)) / m_q\n            \n            # 3-momentum in lab frame: p_vec_lab = p'_vec + ( (q_vec . p'_vec) / (m_q * (q0+m_q)) + E'/m_q ) * q_vec\n            factor = (np.dot(q_vec, p_prime_vec) / (m_q * (q0 + m_q))) + (p_prime_E / m_q)\n            p_lab_vec = p_prime_vec + factor * q_vec\n            \n            p_lab = np.zeros(4)\n            p_lab[0] = p_lab_E\n            p_lab[1:] = p_lab_vec\n            return p_lab\n\n        # --- Step 1: Kinematics Construction ---\n        p1 = np.array([sqrt_s / 2.0, 0.0, 0.0, sqrt_s / 2.0])  # u quark\n        p2 = np.array([sqrt_s / 2.0, 0.0, 0.0, -sqrt_s / 2.0]) # d-bar antiquark\n\n        k = np.array([\n            E_gamma,\n            E_gamma * np.sin(theta_gamma) * np.cos(phi_gamma),\n            E_gamma * np.sin(theta_gamma) * np.sin(phi_gamma),\n            E_gamma * np.cos(theta_gamma)\n        ]) # Photon\n\n        q = p1 + p2 - k # Intermediate boson\n\n        # --- Step 2: W* Decay and Boost ---\n        q_sq = minkowski_dot(q, q)\n        if q_sq = 0:\n            raise ValueError(f\"q^2 must be positive, but got {q_sq}. Check kinematics.\")\n        m_q = np.sqrt(q_sq)\n\n        # Lepton in q-rest frame (massless decay)\n        E_prime_l = m_q / 2.0\n        p_prime_l = np.array([\n            E_prime_l,\n            E_prime_l * np.sin(theta_dec) * np.cos(phi_dec),\n            E_prime_l * np.sin(theta_dec) * np.sin(phi_dec),\n            E_prime_l * np.cos(theta_dec)\n        ])\n\n        # Boost lepton to lab frame\n        p_ell = lorentz_boost(p_prime_l, q)\n\n        # --- Step 3: Compute Gauge Invariance Diagnostics ---\n        def current_term(eta, Q, p, k_photon):\n            \"\"\"Computes one term in the eikonal current sum, eta*Q*p/(p.k).\"\"\"\n            pk_dot = minkowski_dot(p, k_photon)\n            # The problem is designed such that the analytical result of k.J simplifies.\n            # Numerically, we compute k.p/p.k which should be 1.\n            if abs(pk_dot)  1e-15:\n                # In a real collinear singularity, this term would diverge.\n                # Here, we expect k.p == p.k, so the ratio is 1. We return the charge factor.\n                return eta * Q\n            return eta * Q * minkowski_dot(k_photon, p) / pk_dot\n\n        # Variant A: Resonant-only naive (only lepton emits)\n        sum_A = current_term(eta_ell, Q_ell, p_ell, k)\n        Delta_A = abs(sum_A)\n\n        # Variant B: On-shell projected decay current (W+ - l+)\n        # Construct projected on-shell momentum for W\n        lambda_proj = np.sqrt(M_W**2 / q_sq)\n        q_hat = lambda_proj * q\n        \n        sum_B = (current_term(eta_ell, Q_ell, p_ell, k) +\n                 current_term(eta_W, Q_W, q_hat, k))\n        Delta_B = abs(sum_B)\n\n        # Variant C: Full external charged legs (u, d-bar, l+)\n        sum_C = (current_term(eta_u, Q_u, p1, k) +\n                 current_term(eta_dbar, Q_dbar, p2, k) +\n                 current_term(eta_ell, Q_ell, p_ell, k))\n        Delta_C = abs(sum_C)\n\n        all_results.extend([Delta_A, Delta_B, Delta_C])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3534352"}, {"introduction": "为了获得精确的理论预言，从领头阶（LO）计算过渡到次领头阶（NLO）至关重要，但这一过程会引入必须被小心消除的红外（软和共线）奇异性。这项练习通过一个玩具模型来阐明 Frixione–Kunszt–Signer (FKS) 减除方法，这是一种处理这些奇异性的强大技术。通过数值上验证局域抵消项的积分能够重现所需的PDF抵消项，你将对NLO事件生成器如何获得其有限的物理预言获得实践性的理解。[@problem_id:3534373]", "problem": "你的任务是为一个产生$Z$玻色子和一个喷注的质子-质子对撞次领头阶硬散射过程的玩具模型，实现 Frixione–Kunszt–Signer (FKS) 减除思想的一个最小但忠实的计算实现，用于处理初态共线奇异性。目标是将实发射相空间划分为与初态发射子关联的扇区，构造分扇区的共线抵消项，并数值上证明它们的积分能够再现质量因子化（部分子分布函数）共线抵消项。该实现必须是一个可运行的程序。\n\n必须使用的基本原理仅限于：\n\n- 量子色动力学 (QCD) 中初态奇异性的共线因子化：在共线极限下，$(m+1)$-部分子矩阵元因子化为一个 $m$-部分子矩阵元乘以一个分裂函数再乘以一个发散的共线因子。\n- QCD 中经过充分检验的夸克到夸克-胶子分裂核，$P_{qq}(z) = C_F \\frac{1+z^2}{1-z}$，其中 $C_F = \\frac{4}{3}$。\n- 用于初态因子化的部分子分布函数 (PDF) 中的卷积：共线抵消项通过变量 $z$ 将分裂核与部分子密度进行卷积，其中母部分子动量分数的运动学关系为 $x \\to x/z$。\n\n为了纯粹关注初态共线结构，同时保持模拟易于处理，你将使用以下玩具模型假设：\n\n1. 质子部分子分布函数由光滑的类贝塔函数形状建模。对于一个夸克，$f_q(x; a_q, b_q) = x^{a_q} (1-x)^{b_q}$ 当 $x \\in (0,1)$ 时，否则 $f_q(x) = 0$。对于一个反夸克，$f_{\\bar q}(x; a_{\\bar q}, b_{\\bar q}) = x^{a_{\\bar q}} (1-x)^{b_{\\bar q}}$ 当 $x \\in (0,1)$ 时，否则 $f_{\\bar q}(x) = 0$。\n2. $pp \\to Z+\\text{jet}$ 的领头阶 (LO) Born 权重表示为 $B(x_a, x_b) = \\sigma_0 f_q(x_a) f_{\\bar q}(x_b)$，其中 $\\sigma_0 = 1$ 作为总体归一化因子。\n3. 只包括初态共线奇异性。未分辨角被映射到一个变量 $t \\in (0,1)$，该变量测量与两个束流方向的邻近度，距离为 $d_a = t$ 和 $d_b = 1-t$。FKS 扇区函数定义为 $S_a(t) = \\frac{d_b}{d_a + d_b} = 1-t$ 和 $S_b(t) = \\frac{d_a}{d_a + d_b} = t$，它们构成单位分解，$S_a(t) + S_b(t) = 1$。\n4. 初态发射子 $a$ 的分扇区共线抵消项密度建模为\n$$\n\\mathcal{C}_a(x_a,x_b; z, t) = \\alpha_s \\, B\\!\\left(\\frac{x_a}{z}, x_b\\right) \\, \\frac{P_{qq}(z)}{z} \\, \\frac{S_a(t)}{t},\n$$\n对于初态发射子 $b$ 也类似，\n$$\n\\mathcal{C}_b(x_a,x_b; z, t) = \\alpha_s \\, B\\!\\left(x_a, \\frac{x_b}{z}\\right) \\, \\frac{P_{qq}(z)}{z} \\, \\frac{S_b(t)}{1-t}.\n$$\n这里 $z \\in (0,1)$ 是分裂后的初态夸克携带的动量分数，该夸克从分裂母体进入 Born 振幅；$t \\in (0,1)$ 是如上所述的扇区变量。\n\n5. 通过截断引入红外正规化。对于共线角，$t \\in [\\lambda_c, 1 - \\lambda_c]$，其中 $\\lambda_c \\in (0, \\frac{1}{2})$。对于卷积变量，$z \\in [x, 1 - \\lambda_z]$（对于相应的 Bjorken $x$），其中 $\\lambda_z \\in (0,1)$ 是一个小的上限截断，用于移除 $z \\to 1$ 区域。所有积分必须显式使用这些截断。\n\n你的程序必须：\n\n- 实现扇区分解函数 $S_a(t)$ 和 $S_b(t)$，并在一个 $(0,1)$ 内的稠密均匀 $t$ 值网格上数值验证 $S_a(t) + S_b(t) = 1$。\n- 计算总的扇区积分抵消项\n$$\nI_{\\text{sec}}(x_a,x_b) = \\int_{x_a}^{1-\\lambda_z} \\!\\! \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(\\frac{x_a}{z}, x_b\\right) \\int_{\\lambda_c}^{1-\\lambda_c} \\!\\! \\mathrm{d}t \\, \\alpha_s \\frac{S_a(t)}{t} \\; + \\; \\int_{x_b}^{1-\\lambda_z} \\!\\! \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(x_a, \\frac{x_b}{z}\\right) \\int_{\\lambda_c}^{1-\\lambda_c} \\!\\! \\mathrm{d}t \\, \\alpha_s \\frac{S_b(t)}{1-t}.\n$$\n- 计算共线部分子分布函数 (PDF) 抵消项\n$$\nI_{\\text{PDF}}(x_a,x_b) = \\alpha_s \\, L_c(\\lambda_c) \\left[\\int_{x_a}^{1-\\lambda_z} \\!\\! \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(\\frac{x_a}{z}, x_b\\right) \\; + \\; \\int_{x_b}^{1-\\lambda_z} \\!\\! \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(x_a, \\frac{x_b}{z}\\right)\\right],\n$$\n其中 $L_c(\\lambda_c)$ 是由 FKS 扇区函数加权的角积分的解析结果，\n$$\nL_c(\\lambda_c) \\equiv \\int_{\\lambda_c}^{1-\\lambda_c} \\mathrm{d}t \\, \\frac{S_a(t)}{t} \\; = \\; \\int_{\\lambda_c}^{1-\\lambda_c} \\mathrm{d}t \\, \\frac{S_b(t)}{1-t} \\; = \\; \\ln\\frac{1-\\lambda_c}{\\lambda_c} - 1 + 2 \\lambda_c.\n$$\n\n- 通过报告每个测试用例的绝对差 $|I_{\\text{sec}} - I_{\\text{PDF}}|$，数值上证明 $I_{\\text{sec}}(x_a,x_b)$ 在数值精度范围内等于 $I_{\\text{PDF}}(x_a,x_b)$。\n\n使用 QCD 分裂核 $P_{qq}(z) = C_F \\frac{1+z^2}{1-z}$，其中 $C_F = \\frac{4}{3}$，并使用上面定义的模型 PDF。Born 权重中的常数 $\\sigma_0$ 设置为 $1$。\n\n在这个玩具模型中，角度单位是无量纲的，没有需要报告的物理单位。\n\n测试套件。你的程序必须运行以下三个测试用例：\n\n- 测试用例 1 (理想路径):\n  - $x_a = 0.13$, $x_b = 0.19$\n  - $a_q = 0.5$, $b_q = 3.0$\n  - $a_{\\bar q} = 0.7$, $b_{\\bar q} = 4.2$\n  - $\\alpha_s = 0.118$\n  - $\\lambda_c = 10^{-3}$, $\\lambda_z = 10^{-5}$\n\n- 测试用例 2 ($x$ 的边界值和更紧的共线截断):\n  - $x_a = 0.91$, $x_b = 0.05$\n  - $a_q = 0.3$, $b_q = 5.0$\n  - $a_{\\bar q} = 0.2$, $b_{\\bar q} = 7.0$\n  - $\\alpha_s = 0.118$\n  - $\\lambda_c = 10^{-2}$, $\\lambda_z = 10^{-4}$\n\n- 测试用例 3 (更粗的截断和对称的 PDF):\n  - $x_a = 0.5$, $x_b = 0.5$\n  - $a_q = 1.0$, $b_q = 1.0$\n  - $a_{\\bar q} = 1.0$, $b_{\\bar q} = 1.0$\n  - $\\alpha_s = 0.2$\n  - $\\lambda_c = 10^{-1}$, $\\lambda_z = 10^{-2}$\n\n对于每个测试用例，你的程序必须输出两个浮点数值：\n- 绝对差 $|I_{\\text{sec}} - I_{\\text{PDF}}|$。\n- 单位分解与 1 的最大绝对偏差，$\\max_{t \\in \\mathcal{G}} |S_a(t) + S_b(t) - 1|$，其中 $\\mathcal{G}$ 是一个在 $(0,1)$ 上包含 $M = 1001$ 个点的均匀网格。\n\n最终输出格式。你的程序应生成单行输出，包含一个由三对数值组成的逗号分隔列表，每对本身是按上述顺序排列的双元素列表。例如，输出格式必须与 $[[r_{11},r_{12}],[r_{21},r_{22}],[r_{31},r_{32}]]$ 完全一样，其中 $r_{i1}$ 是测试用例 $i$ 的绝对差，$r_{i2}$ 是测试用例 $i$ 的最大单位分解偏差。", "solution": "我们从量子色动力学 (QCD) 在共线极限下的因子化性质开始。对于初态过程的实发射修正，当部分子 $i$ 共线分裂时，矩阵元的平方因子化为\n$$\n|M_{m+1}|^2 \\xrightarrow{\\text{coll}} \\frac{4 \\pi \\alpha_s}{k_T^2} P_{i \\to i g}(z) \\, |M_m(\\tilde{p})|^2,\n$$\n其中 $k_T$ 是与分裂相关的横向动量，$z$ 是分裂后的部分子携带的动量分数，该部分子进入约化的 Born 组态，$P_{i \\to i g}(z)$ 是分裂核。相应的相空间测度也因子化为一个 $m$ 体相空间和一个依赖于 $z$ 和角变量的普适共线测度。在维数正规化中，对共线变量积分后会得到 $1/\\epsilon$ 奇异性。在 Frixione–Kunszt–Signer (FKS) 减除法中，实发射相空间使用光滑的分解函数划分为扇区，以便每个扇区只隔离一个奇异区域。对于初态共线奇异性，我们根据到两个束流的距离来定义扇区变量。\n\n我们实现一个只保留初态共线结构的玩具模型。未分辨的自由度被编码在一个无量纲变量 $t \\in (0,1)$ 中，该变量测量与两个束流的邻近度，距离为\n$$\nd_a = t, \\quad d_b = 1-t.\n$$\nFKS 扇区函数取为\n$$\nS_a(t) = \\frac{d_b}{d_a + d_b} = 1 - t, \\qquad S_b(t) = \\frac{d_a}{d_a + d_b} = t,\n$$\n它们明确地对所有 $t \\in (0,1)$ 满足 $S_a(t) + S_b(t) = 1$，并且 $S_a(0) = 1$, $S_a(1) = 0$, $S_b(0) = 0$, $S_b(1) = 1$，从而隔离了腿 $a$ 的共线极限 $t \\to 0$ 和腿 $b$ 的共线极限 $t \\to 1$。\n\n夸克发射一个胶子的共线分裂核是\n$$\nP_{qq}(z) = C_F \\frac{1+z^2}{1-z}, \\qquad C_F = \\frac{4}{3}.\n$$\n在初态情况下，分裂后从腿 $a$ 进入 Born 组态的动量分数变为 $x_a' = \\frac{x_a}{z}$，对腿 $b$ 类似，$x_b' = \\frac{x_b}{z}$。强子截面中的卷积涉及对 $z$ 的积分，其中 $1/z$ 的因子来自能量分数映射的雅可比行列式和部分子分布函数 (PDF) 的卷积结构。我们用光滑的类贝塔函数形状来建模质子 PDF\n$$\nf_q(x; a_q, b_q) = \\begin{cases}\nx^{a_q} (1-x)^{b_q},   x \\in (0,1),\\\\\n0,   \\text{otherwise},\n\\end{cases}\n\\qquad\nf_{\\bar q}(x; a_{\\bar q}, b_{\\bar q}) = \\begin{cases}\nx^{a_{\\bar q}} (1-x)^{b_{\\bar q}},   x \\in (0,1),\\\\\n0,   \\text{otherwise}.\n\\end{cases}\n$$\nBorn 权重取为 $B(x_a, x_b) = \\sigma_0 f_q(x_a) f_{\\bar q}(x_b)$，其中 $\\sigma_0 = 1$。\n\n与 FKS 一致的分扇区共线抵消项是通过将 Born 权重（在映射后的动量分数处取值）与分裂核和扇区化的角因子相乘来构造的。忽略不影响比较的总体常数，我们采用\n$$\n\\mathcal{C}_a(x_a,x_b; z, t) = \\alpha_s \\, B\\!\\left(\\frac{x_a}{z}, x_b\\right) \\, \\frac{P_{qq}(z)}{z} \\, \\frac{S_a(t)}{t},\n\\quad\n\\mathcal{C}_b(x_a,x_b; z, t) = \\alpha_s \\, B\\!\\left(x_a, \\frac{x_b}{z}\\right) \\, \\frac{P_{qq}(z)}{z} \\, \\frac{S_b(t)}{1-t}.\n$$\n为了在不显式使用维数正规化的情况下使积分为有限，我们引入红外截断：$t \\in [\\lambda_c, 1 - \\lambda_c]$，其中 $\\lambda_c \\in (0, \\frac{1}{2})$；$z \\in [x, 1 - \\lambda_z]$，其中 $\\lambda_z \\in (0,1)$ 是一个小的截断值（对于相应的 Bjorken $x$）。对扇区积分的抵消项为\n$$\nI_{\\text{sec}}(x_a,x_b) = \\int_{x_a}^{1-\\lambda_z} \\!\\! \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(\\frac{x_a}{z}, x_b\\right) \\int_{\\lambda_c}^{1-\\lambda_c} \\!\\! \\mathrm{d}t \\, \\alpha_s \\frac{S_a(t)}{t}\n+ \\int_{x_b}^{1-\\lambda_z} \\!\\! \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(x_a, \\frac{x_b}{z}\\right) \\int_{\\lambda_c}^{1-\\lambda_c} \\!\\! \\mathrm{d}t \\, \\alpha_s \\frac{S_b(t)}{1-t}.\n$$\n因为 $S_a(t) = 1 - t$ 且 $S_b(t) = t$，所以两个角积分相等，并且可以解析地计算得到\n$$\nL_c(\\lambda_c) \\equiv \\int_{\\lambda_c}^{1-\\lambda_c} \\mathrm{d}t \\, \\frac{1-t}{t}\n= \\left[\\ln t - t\\right]_{\\lambda_c}^{1-\\lambda_c}\n= \\ln\\frac{1-\\lambda_c}{\\lambda_c} - 1 + 2 \\lambda_c,\n$$\n以及\n$$\n\\int_{\\lambda_c}^{1-\\lambda_c} \\mathrm{d}t \\, \\frac{t}{1-t}\n= \\int_{\\lambda_c}^{1-\\lambda_c} \\mathrm{d}t \\, \\left(\\frac{1}{1-t} - 1\\right)\n= \\left[-\\ln(1-t) - t\\right]_{\\lambda_c}^{1-\\lambda_c}\n= \\ln\\frac{1-\\lambda_c}{\\lambda_c} - 1 + 2 \\lambda_c = L_c(\\lambda_c).\n$$\n因此，总的扇区积分抵消项因子化为\n$$\nI_{\\text{sec}}(x_a,x_b) = \\alpha_s \\, L_c(\\lambda_c) \\left[\n\\int_{x_a}^{1-\\lambda_z} \\!\\! \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(\\frac{x_a}{z}, x_b\\right)\n+\n\\int_{x_b}^{1-\\lambda_z} \\!\\! \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(x_a, \\frac{x_b}{z}\\right)\n\\right].\n$$\n这正是质量因子化共线 PDF 抵消项的结构，\n$$\nI_{\\text{PDF}}(x_a,x_b) = \\alpha_s \\, L_c(\\lambda_c) \\left[\n\\int_{x_a}^{1-\\lambda_z} \\!\\! \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(\\frac{x_a}{z}, x_b\\right)\n+\n\\int_{x_b}^{1-\\lambda_z} \\!\\! \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(x_a, \\frac{x_b}{z}\\right)\n\\right],\n$$\n这表明积分后的 FKS 扇区抵消项再现了 PDF 共线抵消项，正如因子化所要求的那样。\n\n算法设计。程序遵循以下步骤：\n1. 定义 $P_{qq}(z)$，其中 $C_F = \\frac{4}{3}$。\n2. 如上定义 $f_q(x; a_q, b_q)$ 和 $f_{\\bar q}(x; a_{\\bar q}, b_{\\bar q})$，以及 $B(x_a,x_b) = f_q(x_a) f_{\\bar q}(x_b)$。\n3. 实现 $S_a(t) = 1 - t$，$S_b(t) = t$，并在一个包含 $M = 1001$ 个点的 $(0,1)$ 网格 $\\mathcal{G}$ 上通过计算 $\\max_{t \\in \\mathcal{G}} |S_a(t) + S_b(t) - 1|$ 来验证单位分解性质。\n4. 数值计算角积分，\n$$\nT_a = \\int_{\\lambda_c}^{1-\\lambda_c} \\mathrm{d}t \\, \\frac{S_a(t)}{t}, \\qquad T_b = \\int_{\\lambda_c}^{1-\\lambda_c} \\mathrm{d}t \\, \\frac{S_b(t)}{1-t},\n$$\n并解析地计算 $L_c(\\lambda_c)$。\n5. 使用自适应求积法数值计算 $z$-卷积：\n$$\nI_a = \\int_{x_a}^{1-\\lambda_z} \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(\\frac{x_a}{z}, x_b\\right), \\qquad\nI_b = \\int_{x_b}^{1-\\lambda_z} \\mathrm{d}z \\, \\frac{P_{qq}(z)}{z} \\, B\\!\\left(x_a, \\frac{x_b}{z}\\right),\n$$\n其中定义域限制 $x/z \\in (0,1)$ 由下限 $z \\ge x$ 和 PDF 的支集强制实施。\n6. 构造\n$$\nI_{\\text{sec}} = \\alpha_s \\left(T_a I_a + T_b I_b\\right), \\qquad\nI_{\\text{PDF}} = \\alpha_s \\, L_c(\\lambda_c) \\left(I_a + I_b\\right),\n$$\n并报告绝对差 $|I_{\\text{sec}} - I_{\\text{PDF}}|$。\n7. 对每个测试用例重复操作。输出单行列表，包含每对测试结果：$[|I_{\\text{sec}} - I_{\\text{PDF}}|, \\max_{t \\in \\mathcal{G}} |S_a + S_b - 1|]$。\n\n数值考量。对 $z$ 的积分由截断 $\\lambda_z$ 正规化，它移除了 $P_{qq}(z)$ 在 $z \\to 1$ 处的奇异性，而下限 $z \\ge x$ 确保变换后的动量分数等于或小于 $1$。角积分由于 $\\lambda_c$ 的存在而是有限的，并且在求积容差范围内将与 $L_c(\\lambda_c)$ 的解析表达式数值上匹配。因此，$|I_{\\text{sec}} - I_{\\text{PDF}}|$ 在数值上应该很小，对于给定的截断值，通常远小于 $10^{-8}$，而最大单位分解偏差应处于浮点舍入误差的水平（约 $10^{-16}$）。\n\n最终的程序将计算并以要求的格式打印出所需的三对结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\n# Constants\nCF = 4.0 / 3.0  # C_F for SU(3)\n\ndef P_qq(z: float) - float:\n    \"\"\"Quark - quark gluon splitting kernel P_qq(z) = C_F * (1 + z^2)/(1 - z).\"\"\"\n    return CF * (1.0 + z * z) / (1.0 - z)\n\ndef pdf_shape(x: float, a: float, b: float) - float:\n    \"\"\"Beta-like PDF shape x^a * (1-x)^b on (0,1), zero outside.\"\"\"\n    if x = 0.0 or x = 1.0:\n        return 0.0\n    return (x ** a) * ((1.0 - x) ** b)\n\ndef born_weight(xa: float, xb: float, aq: float, bq: float, aqb: float, bqb: float) - float:\n    \"\"\"Born weight B(xa, xb) = f_q(xa) * f_qbar(xb). Normalization sigma0 = 1.\"\"\"\n    fq = pdf_shape(xa, aq, bq)\n    fqb = pdf_shape(xb, aqb, bqb)\n    return fq * fqb\n\ndef sector_Sa(t: float) - float:\n    \"\"\"FKS sector function for emitter a: S_a(t) = 1 - t.\"\"\"\n    return 1.0 - t\n\ndef sector_Sb(t: float) - float:\n    \"\"\"FKS sector function for emitter b: S_b(t) = t.\"\"\"\n    return t\n\ndef Lc_analytic(lc: float) - float:\n    \"\"\"Analytic angular integral Lc(lc) = ln((1-lc)/lc) - 1 + 2*lc.\"\"\"\n    return np.log((1.0 - lc) / lc) - 1.0 + 2.0 * lc\n\ndef compute_case(xa, xb, aq, bq, aqb, bqb, alpha_s, lc, lz):\n    # Partition of unity check on a grid\n    M = 1001\n    ts = (np.arange(M) + 0.5) / M  # midpoints in (0,1)\n    Sa = 1.0 - ts\n    Sb = ts\n    max_partition_dev = float(np.max(np.abs((Sa + Sb) - 1.0)))\n\n    # Angular integrals (numerical)\n    # Note: integrands are finite due to cutoffs.\n    Ta_val, _ = quad(lambda t: sector_Sa(t) / t, lc, 1.0 - lc, epsabs=1e-11, epsrel=1e-10, limit=200)\n    Tb_val, _ = quad(lambda t: sector_Sb(t) / (1.0 - t), lc, 1.0 - lc, epsabs=1e-11, epsrel=1e-10, limit=200)\n\n    # z-convolution integrals for emitter a and b\n    def Ia_integrand(z):\n        xa_over_z = xa / z\n        return (P_qq(z) / z) * born_weight(xa_over_z, xb, aq, bq, aqb, bqb)\n\n    def Ib_integrand(z):\n        xb_over_z = xb / z\n        return (P_qq(z) / z) * born_weight(xa, xb_over_z, aq, bq, aqb, bqb)\n\n    # Integration limits respecting support: z in [x, 1-lz], provided x  1-lz\n    Ia = 0.0\n    if xa  1.0 - lz:\n        Ia, _ = quad(Ia_integrand, xa, 1.0 - lz, epsabs=1e-10, epsrel=1e-9, limit=500)\n    Ib = 0.0\n    if xb  1.0 - lz:\n        Ib, _ = quad(Ib_integrand, xb, 1.0 - lz, epsabs=1e-10, epsrel=1e-9, limit=500)\n\n    # Assemble sector-integrated counterterm and PDF counterterm\n    I_sec = alpha_s * (Ta_val * Ia + Tb_val * Ib)\n    Lc = Lc_analytic(lc)\n    I_pdf = alpha_s * Lc * (Ia + Ib)\n\n    diff = abs(I_sec - I_pdf)\n    return [diff, max_partition_dev]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (xa, xb, aq, bq, aqb, bqb, alpha_s, lambda_c, lambda_z)\n    test_cases = [\n        (0.13, 0.19, 0.5, 3.0, 0.7, 4.2, 0.118, 1e-3, 1e-5),  # Test 1\n        (0.91, 0.05, 0.3, 5.0, 0.2, 7.0, 0.118, 1e-2, 1e-4),  # Test 2\n        (0.5, 0.5, 1.0, 1.0, 1.0, 1.0, 0.2, 1e-1, 1e-2),      # Test 3\n    ]\n\n    results = []\n    for case in test_cases:\n        xa, xb, aq, bq, aqb, bqb, alpha_s, lc, lz = case\n        res = compute_case(xa, xb, aq, bq, aqb, bqb, alpha_s, lc, lz)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    # A single line: list of [diff, max_partition_dev] pairs for each test.\n    # Ensure default Python repr prints floats as needed.\n    print(str(results))\n\nsolve()\n```", "id": "3534373"}]}