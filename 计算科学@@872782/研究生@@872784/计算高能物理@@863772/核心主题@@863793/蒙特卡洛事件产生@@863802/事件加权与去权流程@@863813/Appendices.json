{"hands_on_practices": [{"introduction": "在使用加权蒙特卡洛事件时，并非所有事件对我们测量的统计精度贡献相同。“有效样本量” ($N_{\\text{eff}}$) 的概念量化了由于权重方差导致的统计功效损失。本练习将指导您推导和解释 $N_{\\text{eff}}$，为您评估加权事件样本的质量提供一个关键工具。[@problem_id:3513799]", "problem": "在计算高能物理学中，事件生成器通常会产生带有正权重 $w_i > 0$ 的模拟事件，这些权重反映了微分截面因子或重要性采样调整。考虑使用 $N$ 个独立的事件级贡献 $Y_i$ 来估计一个标量可观测量，这些贡献在目标物理分布下具有共同的有限方差 $\\sigma^2$。一个标准的自归一化加权估计量被构造为 $\\hat{\\mu} = \\sum_{i=1}^{N}\\alpha_i Y_i$，其中归一化系数为 $\\alpha_i = w_i/\\sum_{j=1}^{N}w_j$。利用独立随机变量线性组合的方差法则以及对 $\\{\\alpha_i\\}$ 的归一化约束，通过将 $\\hat{\\mu}$ 的方差与未加权样本均值的方差相匹配，来定义有效样本量 $N_{\\text{eff}}$ 的概念。对权重 $\\{2,1,1,0.5\\}$ 数值计算 $N_{\\text{eff}}$，并从统计功效的角度解释 $N_{\\text{eff}}$。\n\n选择所有正确的陈述：\n\nA. 对于具有共同方差 $\\sigma^2$ 的独立事件贡献，自归一化加权估计量的方差满足 $\\operatorname{Var}(\\hat{\\mu}) = \\sigma^2 \\sum_{i=1}^{N}\\alpha_i^2$，并且令 $\\operatorname{Var}(\\hat{\\mu}) = \\sigma^2/N_{\\text{eff}}$ 可得 $N_{\\text{eff}} = \\left(\\sum_{i=1}^{N}w_i\\right)^2/\\left(\\sum_{i=1}^{N}w_i^2\\right)$。\n\nB. 对于任意选择的非负权重，总是有 $N_{\\text{eff}} \\ge N$。\n\nC. 数量 $N_{\\text{eff}}$ 等于严格正权重的数量。\n\nD. 当且仅当所有权重都相同，即对于某个常数 $c > 0$ 和所有 $i$ 都有 $w_i = c$ 时，才有 $N_{\\text{eff}}=N$。\n\nE. 对于权重 $\\{2,1,1,0.5\\}$，$N_{\\text{eff}}$ 为 $3.24$，因此 $\\operatorname{Var}(\\hat{\\mu}) = \\sigma^2/3.24$，这在统计功效的意义上，与从 $3.24$ 个独立的等权重事件计算出的未加权均值的方差相匹配。\n\nF. 在接受-拒绝去权重法中，对于归一化常数 $w_{\\max}=\\max_i w_i$，接受概率为 $\\min\\{1, w_i/w_{\\max}\\}$，接受事件的期望数量等于 $N_{\\text{eff}}$。", "solution": "问题陈述在计算物理的统计数据分析背景下提出了一个定义明确的问题。它要求推导和解释加权样本的有效样本量 $N_{\\text{eff}}$。所有提供的信息在科学上都是合理的、自洽的，并且足以进行严格的求解。因此，该问题是有效的。\n\n核心任务是通过比较加权均值的方差和未加权均值的方差来定义有效样本量 $N_{\\text{eff}}$。\n\n设 $N$ 个权重的集合为 $\\{w_1, w_2, \\ldots, w_N\\}$，其中 $w_i  0$。标量可观测量 $\\mu$ 的加权估计量由下式给出：\n$$ \\hat{\\mu} = \\sum_{i=1}^{N} \\alpha_i Y_i $$\n其中 $Y_i$ 是具有共同方差 $\\operatorname{Var}(Y_i) = \\sigma^2$ 的独立贡献，系数 $\\alpha_i$ 是归一化权重：\n$$ \\alpha_i = \\frac{w_i}{\\sum_{j=1}^{N} w_j} $$\n这些系数满足归一化条件 $\\sum_{i=1}^{N} \\alpha_i = 1$。\n\n估计量 $\\hat{\\mu}$ 的方差是使用独立随机变量线性组合的方差性质 $\\operatorname{Var}\\left(\\sum_i c_i X_i\\right) = \\sum_i c_i^2 \\operatorname{Var}(X_i)$ 来计算的。在我们的例子中，系数是 $\\alpha_i$，在此计算中被视为常数。\n$$ \\operatorname{Var}(\\hat{\\mu}) = \\operatorname{Var}\\left(\\sum_{i=1}^{N} \\alpha_i Y_i\\right) = \\sum_{i=1}^{N} \\alpha_i^2 \\operatorname{Var}(Y_i) = \\sum_{i=1}^{N} \\alpha_i^2 \\sigma^2 = \\sigma^2 \\sum_{i=1}^{N} \\alpha_i^2 $$\n\n$M$ 个独立事件的未加权均值 $\\bar{Y} = \\frac{1}{M}\\sum_{i=1}^{M} Y_i$ 的方差为：\n$$ \\operatorname{Var}(\\bar{Y}) = \\operatorname{Var}\\left(\\frac{1}{M}\\sum_{i=1}^{M} Y_i\\right) = \\frac{1}{M^2} \\sum_{i=1}^{M} \\operatorname{Var}(Y_i) = \\frac{1}{M^2} (M \\sigma^2) = \\frac{\\sigma^2}{M} $$\n\n有效样本量 $N_{\\text{eff}}$ 的定义是通过将加权估计量 $\\hat{\\mu}$ 的方差与 $N_{\\text{eff}}$ 个事件的未加权均值的方差相等来确定的：\n$$ \\operatorname{Var}(\\hat{\\mu}) = \\frac{\\sigma^2}{N_{\\text{eff}}} $$\n代入我们关于 $\\operatorname{Var}(\\hat{\\mu})$ 的表达式：\n$$ \\sigma^2 \\sum_{i=1}^{N} \\alpha_i^2 = \\frac{\\sigma^2}{N_{\\text{eff}}} $$\n$$ N_{\\text{eff}} = \\frac{1}{\\sum_{i=1}^{N} \\alpha_i^2} $$\n现在，我们用原始权重 $w_i$ 来代入 $\\alpha_i$ 的定义。令 $W = \\sum_{j=1}^{N} w_j$。\n$$ N_{\\text{eff}} = \\frac{1}{\\sum_{i=1}^{N} \\left(\\frac{w_i}{W}\\right)^2} = \\frac{1}{\\frac{1}{W^2} \\sum_{i=1}^{N} w_i^2} = \\frac{W^2}{\\sum_{i=1}^{N} w_i^2} $$\n因此，有效样本量的公式为：\n$$ N_{\\text{eff}} = \\frac{\\left(\\sum_{i=1}^{N} w_i\\right)^2}{\\sum_{i=1}^{N} w_i^2} $$\n\n现在，我们评估每个选项。\n\n**A. 对于具有共同方差 $\\sigma^2$ 的独立事件贡献，自归一化加权估计量的方差满足 $\\operatorname{Var}(\\hat{\\mu})=\\sigma^2\\sum_{i=1}^{N}\\alpha_i^2$，并且令 $\\operatorname{Var}(\\hat{\\mu})=\\sigma^2/N_{\\text{eff}}$ 可得 $N_{\\text{eff}}=\\left(\\sum_{i=1}^{N}w_i\\right)^2/\\left(\\sum_{i=1}^{N}w_i^2\\right)$。**\n我们上面的推导证实了该陈述的两个部分。方差计算是正确的，得到的 $N_{\\text{eff}}$ 表达式也是正确的。\n结论：**正确**。\n\n**B. 对于任意选择的非负权重，总是有 $N_{\\text{eff}}\\geq N$。**\n为了评估这一点，我们将 $N_{\\text{eff}} = \\frac{(\\sum w_i)^2}{\\sum w_i^2}$ 与 $N$ 进行比较。\n考虑 $\\mathbb{R}^N$ 中两个向量 $u = (w_1, \\ldots, w_N)$ 和 $v = (1, \\ldots, 1)$ 的柯西-施瓦茨不等式：\n$$ \\left(\\sum_{i=1}^{N} u_i v_i\\right)^2 \\leq \\left(\\sum_{i=1}^{N} u_i^2\\right) \\left(\\sum_{i=1}^{N} v_i^2\\right) $$\n$$ \\left(\\sum_{i=1}^{N} w_i \\cdot 1\\right)^2 \\leq \\left(\\sum_{i=1}^{N} w_i^2\\right) \\left(\\sum_{i=1}^{N} 1^2\\right) $$\n$$ \\left(\\sum_{i=1}^{N} w_i\\right)^2 \\leq \\left(\\sum_{i=1}^{N} w_i^2\\right) \\cdot N $$\n由于权重是正的，$\\sum w_i^2  0$，所以我们可以用它来除，而不会改变不等式的方向：\n$$ \\frac{\\left(\\sum_{i=1}^{N} w_i\\right)^2}{\\sum_{i=1}^{N} w_i^2} \\leq N $$\n这意味着 $N_{\\text{eff}} \\leq N$。该陈述声称 $N_{\\text{eff}} \\ge N$，这恰恰相反。因此，该陈述是错误的。权重的非均一性会减小有效样本量。\n结论：**错误**。\n\n**C. 数量 $N_{\\text{eff}}$ 等于严格正权重的数量。**\n问题提供了一组特定的权重进行测试：$w = \\{2, 1, 1, 0.5\\}$。这里，事件数量为 $N=4$，并且所有权重都是严格为正的。\n我们来计算这组权重的 $N_{\\text{eff}}$：\n$$ \\sum_{i=1}^{4} w_i = 2 + 1 + 1 + 0.5 = 4.5 $$\n$$ \\sum_{i=1}^{4} w_i^2 = 2^2 + 1^2 + 1^2 + 0.5^2 = 4 + 1 + 1 + 0.25 = 6.25 $$\n$$ N_{\\text{eff}} = \\frac{(4.5)^2}{6.25} = \\frac{20.25}{6.25} = 3.24 $$\n严格正权重的数量是 $4$，但 $N_{\\text{eff}} = 3.24$。因此，$3.24 \\neq 4$。该陈述是错误的。\n结论：**错误**。\n\n**D. 当且仅当所有权重都相同，即对于某个常数 $c0$ 和所有 $i$ 都有 $w_i=c$ 时，才有 $N_{\\text{eff}}=N$。**\n短语“在相差一个公共缩放因子的情况下是相同的”被“即对于某个常数 $c0$ 有 $w_i=c$”所阐明。这意味着我们必须检验条件 $w_1 = w_2 = \\ldots = w_N = c  0$。在选项 B 中使用的柯西-施瓦茨不等式中，等号成立的充要条件是向量 $u$ 和 $v$ 线性相关，即对于某个标量 $k$ 有 $u = k v$。在我们的例子中，$u = (w_1, \\ldots, w_N)$ 且 $v=(1, \\ldots, 1)$。线性相关意味着对所有 $i$ 都有 $w_i = k \\cdot 1$。由于权重是正的， $k$ 必须是一个正常数，我们称之为 $c$。因此，$N_{\\text{eff}} = N$ 的充要条件是对所有 $i$ 都有 $w_i = c$。该陈述是正确的。它精确地描述了获得最大有效样本量的条件。\n结论：**正确**。\n\n**E. 对于权重 $\\{2,1,1,0.5\\}$，$N_{\\text{eff}}$ 为 $3.24$，因此 $\\operatorname{Var}(\\hat{\\mu})=\\sigma^2/3.24$，这在统计功效的意义上，与从 $3.24$ 个独立的等权重事件计算出的未加权均值的方差相匹配。**\n选项 C 中的计算表明，对于给定的权重，$N_{\\text{eff}} = 3.24$ 是正确的。根据 $N_{\\text{eff}}$ 的定义，我们有 $\\operatorname{Var}(\\hat{\\mu}) = \\sigma^2 / N_{\\text{eff}}$，即 $\\sigma^2 / 3.24$。这是正确的。$M$ 个事件的未加权均值的方差是 $\\sigma^2/M$。对于一个包含 $M=3.24$ 个事件的假设样本，其方差确实是 $\\sigma^2/3.24$。对于关于均值的检验，统计功效是估计量标准误 $\\sqrt{\\operatorname{Var}(\\hat{\\mu})}$ 的函数。由于加权均值的方差在数学上等同于一个包含 $3.24$ 个事件的未加权均值的方差，因此统计功效是相同的。这个解释是合理的，并且代表了 $N_{\\text{eff}}$ 概念的根本目的。\n结论：**正确**。\n\n**F. 在接受-拒绝去权重法中，对于归一化常数 $w_{\\max}=\\max_i w_i$，接受概率为 $\\min\\{1,w_i/w_{\\max}\\}$，接受事件的期望数量等于 $N_{\\text{eff}}$。**\n第 $i$ 个事件的接受概率是 $p_i = w_i/w_{\\max}$ (因为 $w_i \\le w_{\\max}$，所以 $\\min$ 是多余的)。接受或拒绝每个事件的过程是一个伯努利试验。接受事件的期望数量 $E[N_{\\text{acc}}]$ 是在所有 $N$ 个初始事件上对各个接受概率求和：\n$$ E[N_{\\text{acc}}] = \\sum_{i=1}^{N} p_i = \\sum_{i=1}^{N} \\frac{w_i}{w_{\\max}} = \\frac{1}{w_{\\max}} \\sum_{i=1}^{N} w_i $$\n该陈述声称 $E[N_{\\text{acc}}] = N_{\\text{eff}}$。我们用给定的权重 $w = \\{2, 1, 1, 0.5\\}$ 来检验这一点。\n我们有 $w_{\\max} = \\max\\{2, 1, 1, 0.5\\} = 2$ 且 $\\sum w_i = 4.5$。\n$$ E[N_{\\text{acc}}] = \\frac{4.5}{2} = 2.25 $$\n从选项 C，我们知道 $N_{\\text{eff}} = 3.24$。\n由于 $2.25 \\neq 3.24$，该陈述是错误的。这是两个描述加权样本不同属性的不同量。它们仅在所有权重都相等的平凡情况下才相等。\n结论：**错误**。", "answer": "$$\\boxed{ADE}$$", "id": "3513799"}, {"introduction": "现代的高精度计算，例如次领头阶 (NLO) 模拟，经常会产生带有负权重的事件，这对分析构成了重大挑战。对负权重的朴素物理解释是不可能的，因此我们需要特殊的技术来处理。本实践探讨“有符号泊松抽样”过程，该过程将单个具有正负权重分量的事件转换为可变数量的带符号的非加权事件。通过推导该估计量的性质并实现一个模拟，您将获得处理负权重的强大方法的实践经验，并理解其伴随的固有方差膨胀效应。[@problem_id:3513801]", "problem": "您的任务是形式化并测试一个带符号的泊松稀疏化程序，用于处理计算高能物理中的负事件权重。考虑一个权重可分解为 $w = w_{+} - w_{-}$ 的单一加权事件，其中 $w_{+} \\ge 0$ 且 $w_{-} \\ge 0$。目标是通过两个独立的泊松随机变量构建一个带符号的无权样本来表示该事件，并研究其无偏性和方差特性，包括负权重对方差膨胀的影响。\n\n从以下基本事实出发：\n- 如果 $N \\sim \\mathrm{Poisson}(\\lambda)$，那么对于任意 $\\lambda \\ge 0$，有 $\\mathbb{E}[N] = \\lambda$ 和 $\\mathrm{Var}[N] = \\lambda$。\n- 如果 $X$ 和 $Y$ 是独立的随机变量，那么 $\\mathbb{E}[X \\pm Y] = \\mathbb{E}[X] \\pm \\mathbb{E}[Y]$ 且 $\\mathrm{Var}[X \\pm Y] = \\mathrm{Var}[X] + \\mathrm{Var}[Y]$。\n- 对于任意常数 $c$，有 $\\mathbb{E}[c X] = c\\,\\mathbb{E}[X]$ 和 $\\mathrm{Var}[c X] = c^{2}\\,\\mathrm{Var}[X]$。\n\n为选定的单位尺度 $a > 0$ 定义带符号的泊松稀疏化估计量如下。抽取两个独立的泊松随机变量 $N_{+} \\sim \\mathrm{Poisson}(\\lambda_{+})$ 和 $N_{-} \\sim \\mathrm{Poisson}(\\lambda_{-})$，其速率分别为 $\\lambda_{+} = w_{+}/a$ 和 $\\lambda_{-} = w_{-}/a$。定义带符号的无权估计量为 $S = a\\,(N_{+} - N_{-})$。\n\n需要解决的任务：\n- 从第一性原理出发，推导 $S$ 是 $w$ 的无偏估计量，并推导其方差（用 $w_{+}$、$w_{-}$ 和 $a$ 表示）。\n- 定义并推导一个方差膨胀因子，以分离符号抵消效应：对于 $|w| > 0$，定义 $F = \\dfrac{w_{+} + w_{-}}{|w|}$，并将其解释为方差 $a\\,(w_{+} + w_{-})$ 超出仅使用非负权重产生相同绝对净重 $|w|$ 时（即 $a\\,|w|$）的方差的倍数。对于 $|w| = 0$ 的特殊情况，指明该膨胀因子未定义，并且必须如下文所述通过一个哨兵值报告。\n\n编程任务：\n- 实现一个程序，对于给定的测试套件，模拟带符号的稀疏化估计量 $S$，并将经验均值和经验方差与推导出的理论值进行比较。对于每个测试用例，使用 $R$ 次独立重复来生成 $S$ 的独立样本，并使用总体归一化计算经验均值 $\\hat{\\mu}$ 和经验方差 $\\hat{v}$。理论均值为 $\\mu = w_{+} - w_{-}$，理论方差为 $v = a\\,(w_{+} + w_{-})$。\n- 对于 $|w| > 0$，计算经验膨胀因子 $\\hat{F} = \\hat{v}/(a\\,|w|)$ 和理论膨胀因子 $F = (w_{+} + w_{-})/|w|$。对于 $|w| = 0$ 的情况，不计算膨胀因子；而是如下文规定，为膨胀因子误差输出哨兵值 $-1.0$。\n- 对于每个测试用例，输出差异三元组\n  $(\\Delta_{\\mu}, \\Delta_{v}, \\Delta_{F}) = \\big(\\hat{\\mu} - \\mu,\\; \\hat{v} - v,\\; \\hat{F} - F\\big)$，\n  其中按照约定，当 $|w| = 0$ 时，必须输出 $\\Delta_{F} = -1.0$。\n\n模拟细节：\n- 对于每个测试用例，使用指定的速率生成 $R$ 个独立的对 $(N_{+}, N_{-})$，对每次重复构造 $S = a\\,(N_{+} - N_{-})$，并使用总体归一化计算 $\\hat{\\mu}$ 和 $\\hat{v}$。每个测试用例使用独立的随机数生成器种子以确保可复现性。\n\n测试套件：\n- 程序必须使用以下测试用例，每个用例指定为一个五元组 $(w_{+}, w_{-}, a, R, \\text{seed})$：\n  - 案例 A：$(3.0, 0.0, 1.2, 1000000, 12345)$\n  - 案例 B：$(0.0, 2.5, 0.8, 1000000, 271828)$\n  - 案例 C：$(5.0, 5.0, 1.0, 1000000, 314159)$\n  - 案例 D：$(4.0, 1.5, 0.7, 1000000, 1618033)$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例结果的串接列表，格式为用方括号括起来的逗号分隔列表。结果必须按 $[\\Delta_{\\mu}^{A}, \\Delta_{v}^{A}, \\Delta_{F}^{A}, \\Delta_{\\mu}^{B}, \\Delta_{v}^{B}, \\Delta_{F}^{B}, \\Delta_{\\mu}^{C}, \\Delta_{v}^{C}, \\Delta_{F}^{C}, \\Delta_{\\mu}^{D}, \\Delta_{v}^{D}, \\Delta_{F}^{D}]$ 的顺序排列，每个值都呈现为浮点数。对于 $|w| = 0$ 的情况，膨胀因子误差应输出哨兵值 $-1.0$。", "solution": "问题陈述是有效的。它在科学上基于概率论和统计学，问题提出得很好，提供了所有必要信息，并且表述客观。它代表了计算高能物理中一个可形式化且相关的问题，涉及加权蒙特卡洛事件的统计处理。我们现在开始解答。\n\n### 理论推导\n\n问题为权重为 $w = w_{+} - w_{-}$（其中 $w_{+} \\ge 0$ 且 $w_{-} \\ge 0$）的加权事件定义了一个带符号的无权估计量 $S$。该估计量使用单位尺度 $a > 0$ 和两个独立的泊松随机变量 $N_{+} \\sim \\mathrm{Poisson}(\\lambda_{+})$ 与 $N_{-} \\sim \\mathrm{Poisson}(\\lambda_{-})$ 构建，其速率分别为 $\\lambda_{+} = w_{+}/a$ 和 $\\lambda_{-} = w_{-}/a$。该估计量由 $S = a\\,(N_{+} - N_{-})$ 给出。\n\n#### 1. 估计量 $S$ 的无偏性\n如果一个估计量的期望值等于它所估计的参数的真值，那么这个估计量就是无偏的。这里，我们必须证明 $\\mathbb{E}[S] = w$。我们使用期望的基本性质。根据期望的线性性质，我们有：\n$$\n\\mathbb{E}[S] = \\mathbb{E}[a\\,(N_{+} - N_{-})] = a\\,\\mathbb{E}[N_{+} - N_{-}]\n$$\n由于 $N_{+}$ 和 $N_{-}$ 是独立的，它们差的期望等于它们期望的差：\n$$\n\\mathbb{E}[S] = a\\,(\\mathbb{E}[N_{+}] - \\mathbb{E}[N_{-}])\n$$\n泊松随机变量 $N \\sim \\mathrm{Poisson}(\\lambda)$ 的期望是 $\\mathbb{E}[N] = \\lambda$。将此应用于 $N_{+}$ 和 $N_{-}$：\n$$\n\\mathbb{E}[S] = a\\,(\\lambda_{+} - \\lambda_{-})\n$$\n代入给定的速率定义 $\\lambda_{+} = w_{+}/a$ 和 $\\lambda_{-} = w_{-}/a$：\n$$\n\\mathbb{E}[S] = a\\,\\left(\\frac{w_{+}}{a} - \\frac{w_{-}}{a}\\right) = a\\,\\left(\\frac{w_{+} - w_{-}}{a}\\right) = w_{+} - w_{-}\n$$\n根据定义，$w = w_{+} - w_{-}$，因此我们证明了 $\\mathbb{E}[S] = w$。所以，$S$ 是 $w$ 的一个无偏估计量。\n\n#### 2. 估计量 $S$ 的方差\n接下来，我们推导 $S$ 的方差，记为 $\\mathrm{Var}(S)$。我们使用性质 $\\mathrm{Var}(cX) = c^2\\,\\mathrm{Var}(X)$，其中 $c$ 为任意常数：\n$$\n\\mathrm{Var}(S) = \\mathrm{Var}(a\\,(N_{+} - N_{-})) = a^2\\,\\mathrm{Var}(N_{+} - N_{-})\n$$\n对于独立的随机变量 $X$ 和 $Y$，它们的和或差的方差等于它们方差的和：$\\mathrm{Var}(X \\pm Y) = \\mathrm{Var}(X) + \\mathrm{Var}(Y)$。由于 $N_{+}$ 和 $N_{-}$ 是独立的：\n$$\n\\mathrm{Var}(S) = a^2\\,(\\mathrm{Var}(N_{+}) + \\mathrm{Var}(N_{-}))\n$$\n泊松随机变量 $N \\sim \\mathrm{Poisson}(\\lambda)$ 的方差是 $\\mathrm{Var}(N) = \\lambda$。应用此性质：\n$$\n\\mathrm{Var}(S) = a^2\\,(\\lambda_{+} + \\lambda_{-})\n$$\n代入速率 $\\lambda_{+}$ 和 $\\lambda_{-}$ 的定义：\n$$\n\\mathrm{Var}(S) = a^2\\,\\left(\\frac{w_{+}}{a} + \\frac{w_{-}}{a}\\right) = a^2\\,\\left(\\frac{w_{+} + w_{-}}{a}\\right) = a\\,(w_{+} + w_{-})\n$$\n这就是估计量的理论方差 $v = a\\,(w_{+} + w_{-})$，与问题陈述一致。\n\n#### 3. 方差膨胀因子 $F$\n对于 $|w| > 0$，方差膨胀因子定义为 $F = \\dfrac{w_{+} + w_{-}}{|w|}$。为解释这一点，我们将实际方差 $v = a\\,(w_{+} + w_{-})$ 与一个理想化估计量的方差进行比较，该理想化估计量能达到相同的净重大小 $|w|$，但没有任何由负权重引起的抵消。\n\n在这种理想情况下，总权重大小 $|w|$ 将完全由正权重构成（或完全由负权重构成，这在方差上是等效的）。这对应于权重分解 $w'_{\\text{total}} = w'_+ + w'_- = |w|$，其中一个分量为零。在这种理想情景下，估计量的方差 $v_{\\text{ideal}}$ 将是：\n$$\nv_{\\text{ideal}} = a\\,(w'_+ + w'_-) = a\\,|w|\n$$\n这代表了使用此估计方案为净重大小 $|w|$ 可实现的最小方差。\n\n实际方差与此理想最小方差的比值为：\n$$\n\\frac{v}{v_{\\text{ideal}}} = \\frac{a\\,(w_{+} + w_{-})}{a\\,|w|} = \\frac{w_{+} + w_{-}}{|w|} = F\n$$\n因此，$F$ 正是由于同时存在正负权重分量（$w_{+} > 0$ 和 $w_{-} > 0$）导致净重 $w$ 中发生抵消而使方差膨胀的因子。根据三角不等式，$w_{+} + w_{-} \\ge |w_{+} - w_{-}| = |w|$，这意味着 $F \\ge 1$。当且仅当 $w_{+}$ 或 $w_{-}$ 为零（无抵消）时，因子 $F$ 等于 $1$；当两者均为正数时，$F > 1$，表明存在方差膨胀。\n\n对于 $|w| = 0$ 的情况（当 $w_{+} = w_{-}$ 时发生），$F$ 的分母为 $0$，使该因子未定义。问题正确地指明了这种情况必须用一个哨兵值来处理。在这种情况下，方差为 $v = a\\,(w_{+} + w_{-}) = 2aw_{+}$，它非零，而净重为零，导致相对不确定性为无穷大。\n\n以下 Python 程序实现了仿真，以数值方式验证这些理论发现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a signed Poisson thinning procedure for several test cases,\n    compares empirical and theoretical statistics, and outputs the differences.\n    \"\"\"\n    # Test cases are given as quintuples: (w+, w-, a, R, seed)\n    test_cases = [\n        # Case A\n        (3.0, 0.0, 1.2, 1000000, 12345),\n        # Case B\n        (0.0, 2.5, 0.8, 1000000, 271828),\n        # Case C\n        (5.0, 5.0, 1.0, 1000000, 314159),\n        # Case D\n        (4.0, 1.5, 0.7, 1000000, 1618033),\n    ]\n\n    results = []\n    for w_plus, w_minus, a, R, seed in test_cases:\n        # Create a dedicated random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # 1. Theoretical calculations\n        w_net = w_plus - w_minus\n        mu_th = w_net\n        v_th = a * (w_plus + w_minus)\n\n        # 2. Simulation\n        # Define Poisson rates\n        lambda_plus = w_plus / a\n        lambda_minus = w_minus / a\n\n        # Generate R independent Poisson-distributed random numbers\n        N_plus_samples = rng.poisson(lam=lambda_plus, size=R)\n        N_minus_samples = rng.poisson(lam=lambda_minus, size=R)\n\n        # Construct samples of the estimator S\n        S_samples = a * (N_plus_samples - N_minus_samples)\n\n        # 3. Compute empirical statistics\n        # Empirical mean\n        mu_emp = np.mean(S_samples)\n        \n        # Empirical variance using population normalization (ddof=0)\n        v_emp = np.var(S_samples, ddof=0)\n\n        # 4. Calculate differences\n        delta_mu = mu_emp - mu_th\n        delta_v = v_emp - v_th\n\n        # Handle the inflation factor F\n        # Use np.isclose for robust floating-point comparison to zero\n        if not np.isclose(w_net, 0.0):\n            # Theoretical inflation factor\n            F_th = (w_plus + w_minus) / abs(w_net)\n            \n            # Empirical inflation factor\n            F_emp = v_emp / (a * abs(w_net))\n            \n            delta_F = F_emp - F_th\n        else:\n            # As per problem specification, use sentinel value for delta_F when w=0\n            delta_F = -1.0\n        \n        results.extend([delta_mu, delta_v, delta_F])\n    \n    # Format and print the final output in the required single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3513801"}, {"introduction": "接受-拒绝方法（非加权过程）的效率取决于包络函数对真实权重分布的包络紧密程度。一个松散的包络会导致接受率低下和计算资源的浪费。本练习将介绍一种实用算法，使用保序回归和分段线性插值来构建一个紧凑的、可分离的凸上包络函数。通过实现该算法并将其性能与简单的常数包络进行比较，您将获得优化非加权过程的具体见解，这是生成高效非加权事件样本的一项关键技能。[@problem_id:3513821]", "problem": "您的任务是设计并分析一个算法，用于在计算高能物理中为事件去权重构建一个接受-拒绝包络。您将重点研究在相空间域 $\\Phi$ 上定义的比率函数 $w = f/q$，并使用有序维度上的保序回归来开发一个可分离的凸上包络。您的程序必须实现该包络的构建，与基线常数包络相比验证接受率的改进，并报告一个计算成本代理以及一个小测试套件的接受率。\n\n基本设置如下。考虑在 $\\Phi = [0,1]^d$ 上的一个可分离目标权重比，其提议密度 $q$ 在 $[0,1]^d$ 上是均匀的。该比率为 $w(\\mathbf{x}) = f(\\mathbf{x})/q(\\mathbf{x})$，具有可分离形式 $w(\\mathbf{x}) = \\prod_{k=1}^d g_k(x_k)$，其中每个 $g_k:[0,1]\\to \\mathbb{R}_{0}$ 都已知是凸函数和非递减函数。您将使用函数族 $g_k(x) = \\exp(\\alpha_k x)$，其中 $\\alpha_k$ 是指定的正参数，这确保了凸性和坐标单调性。\n\n您必须实现以下组件：\n- 对于每个维度 $k$，在一组均匀节点 $t_i = i/K_k$（其中 $i \\in \\{0,\\dots,K_k\\}$）上，使用由 $g_k(t_i)$ 值沿有序节点的累积最大值定义的最小非递减优势函数，构建一个保序（非递减）优势函数。然后通过对这些优势函数值进行分段线性插值，形成在 $[0,1]$ 上的凸上包络 $U_k(x)$。由于 $g_k$ 是凸函数和非递减函数，并且插值弦在节点之间位于 $g_k$ 之上，因此 $U_k$ 是一维上的有效凸上包络。\n- 将可分离的多维包络定义为 $E(\\mathbf{x}) = \\prod_{k=1}^d U_k(x_k)$。论证对于所有 $\\mathbf{x} \\in [0,1]^d$ 都有 $E(\\mathbf{x}) \\ge w(\\mathbf{x})$，因此当从 $q$ 提议并以概率 $w(\\mathbf{x})/E(\\mathbf{x})$ 接受时，它是一个有效的接受-拒绝包络。\n- 计算此可变包络的接受率，定义为 $A_{\\text{env}} = \\int_{[0,1]^d} q(\\mathbf{x}) \\, \\frac{w(\\mathbf{x})}{E(\\mathbf{x})} \\, d\\mathbf{x}$。在均匀 $q$ 和可分离形式的设置下，这可以分解为 $A_{\\text{env}} = \\prod_{k=1}^d \\int_0^1 \\frac{g_k(x)}{U_k(x)} \\, dx$。您必须以高精度数值计算这些一维积分。\n- 使用最佳常数包络 $M = \\sup_{\\mathbf{x}} w(\\mathbf{x})$ 计算基线接受率，对于此函数族，它等于 $M = \\prod_{k=1}^d g_k(1) = \\prod_{k=1}^d \\exp(\\alpha_k)$。基线接受率为 $A_{\\text{base}} = \\frac{\\int_{[0,1]^d} w(\\mathbf{x}) \\, d\\mathbf{x}}{M} = \\prod_{k=1}^d \\frac{\\int_0^1 g_k(x)\\,dx}{g_k(1)}$，并且对于 $g_k(x)=\\exp(\\alpha_k x)$，我们有 $\\int_0^1 g_k(x)\\,dx = \\frac{e^{\\alpha_k}-1}{\\alpha_k}$ 和 $g_k(1) = e^{\\alpha_k}$，因此 $A_{\\text{base}} = \\prod_{k=1}^d \\frac{1-e^{-\\alpha_k}}{\\alpha_k}$。\n- 定义并计算一个简单的计算成本代理 $C_{\\text{env}} = \\sum_{k=1}^d (K_k+1)$，它等于跨维度的包络断点总数，可作为构建和评估复杂度的代理。您还必须计算改进比 $R = A_{\\text{env}}/A_{\\text{base}}$。\n\n您的程序必须实现所述的包络构建，并为下面的每个测试用例计算元组 $(A_{\\text{base}}, A_{\\text{env}}, R, C_{\\text{env}})$。\n\n在您的解决方案中证明上述定义的包络是有效的，即对于所有 $\\mathbf{x} \\in [0,1]^d$ 都有 $E(\\mathbf{x}) \\ge w(\\mathbf{x})$。\n\n使用以下固定的测试套件，它涵盖了一系列维度和曲率：\n- 测试用例 1：$d=1$, $\\alpha_1 = 2$, $K_1 = 8$。\n- 测试用例 2：$d=1$, $\\alpha_1 = 6$, $K_1 = 8$。\n- 测试用例 3：$d=1$, $\\alpha_1 = 4$, $K_1 = 1$。\n- 测试用例 4：$d=2$, $(\\alpha_1,\\alpha_2) = (1,3)$, $(K_1,K_2) = (8,8)$。\n- 测试用例 5：$d=2$, $(\\alpha_1,\\alpha_2) = (3,5)$, $(K_1,K_2) = (32,16)$。\n\n每个一维积分的数值积分必须足够精确，至少达到 $10^{-8}$ 的绝对精度，以确保稳定、可复现的接受率估计。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是按 $[A_{\\text{base}}, A_{\\text{env}}, R, C_{\\text{env}}]$ 顺序排列的四个浮点数列表。例如：\"[[0.1,0.2,2.0,9.0],[...],...]\"。\n- 此问题中没有物理单位。\n- 此问题中未使用角度。\n- 所有结果必须是浮点格式。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于蒙特卡洛积分和方差缩减技术的原理，特别是在计算物理学中使用的接受-拒绝方法。该问题是适定的，提供了一套完整且一致的定义、函数和参数，用以构建一个唯一、稳定且有意义的数值解。语言是客观和正式的。\n\n### 1. 问题陈述验证\n\n**步骤 1：提取的已知条件**\n- **定义域:** $\\Phi = [0,1]^d$。\n- **权重比函数:** $w(\\mathbf{x}) = f(\\mathbf{x})/q(\\mathbf{x})$ 其中 $q$ 是在 $[0,1]^d$ 上的均匀概率密度，因此 $q(\\mathbf{x})=1$。\n- **可分离形式:** $w(\\mathbf{x}) = \\prod_{k=1}^d g_k(x_k)$。\n- **分量函数:** $g_k(x) = \\exp(\\alpha_k x)$ 对于 $x \\in [0,1]$ 和 $\\alpha_k  0$。\n- **包络节点:** 对于每个维度 $k$，一组均匀节点 $t_i = i/K_k$ 对于 $i \\in \\{0, \\dots, K_k\\}$。\n- **保序优势函数:** 一组值 $M_k(t_i) = \\max_{j \\le i} g_k(t_j)$。\n- **一维包络:** $U_k(x)$ 定义为对点 $(t_i, M_k(t_i))$ 进行插值的分段线性函数。\n- **多维包络:** $E(\\mathbf{x}) = \\prod_{k=1}^d U_k(x_k)$。\n- **包络接受率:** $A_{\\text{env}} = \\prod_{k=1}^d \\int_0^1 \\frac{g_k(x)}{U_k(x)} \\, dx$。\n- **基线接受率:** $A_{\\text{base}} = \\prod_{k=1}^d \\frac{1-e^{-\\alpha_k}}{\\alpha_k}$，源自常数包络 $M = \\sup_{\\mathbf{x}} w(\\mathbf{x}) = \\prod_k \\exp(\\alpha_k)$。\n- **计算成本代理:** $C_{\\text{env}} = \\sum_{k=1}^d (K_k+1)$。\n- **改进比:** $R = A_{\\text{env}}/A_{\\text{base}}$。\n- **数值精度:** 每个一维积分必须以至少 $10^{-8}$ 的绝对精度进行评估。\n- **测试用例:**\n    1. $d=1$, $\\alpha_1 = 2$, $K_1 = 8$。\n    2. $d=1$, $\\alpha_1 = 6$, $K_1 = 8$。\n    3. $d=1$, $\\alpha_1 = 4$, $K_1 = 1$。\n    4. $d=2$, $(\\alpha_1,\\alpha_2) = (1,3)$, $(K_1,K_2) = (8,8)$。\n    5. $d=2$, $(\\alpha_1,\\alpha_2) = (3,5)$, $(K_1,K_2) = (32,16)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题是有效的。它描述了计算科学中的一种标准数值方法。所有术语都有正式定义，设置是自洽且一致的，所需的计算是可行的。对一个已经单调的函数使用保序回归是一个指定的算法选择，这简化了问题但并未使其失效。\n\n**步骤 3：结论与行动**\n问题有效。将开发一个完整的解决方案。\n\n### 2. 包络有效性证明\n\n问题要求证明所构建的包络 $E(\\mathbf{x})$ 是权重函数 $w(\\mathbf{x})$ 的一个有效上界，即对于所有 $\\mathbf{x} \\in [0,1]^d$ 都有 $E(\\mathbf{x}) \\ge w(\\mathbf{x})$。\n\n定义为 $E(\\mathbf{x}) = \\prod_{k=1}^d U_k(x_k)$ 和 $w(\\mathbf{x}) = \\prod_{k=1}^d g_k(x_k)$。由于对于所有 $x \\in [0,1]$ 都有 $g_k(x) = \\exp(\\alpha_k x)  0$，并且 $U_k(x)$ 是由 $g_k$ 的正值构建的，所以所有的 $U_k(x_k)$ 也都是正的。因此，不等式 $E(\\mathbf{x}) \\ge w(\\mathbf{x})$ 等价于证明对于每个维度 $k \\in \\{1, \\dots, d\\}$ 和所有 $x_k \\in [0,1]$ 都有 $U_k(x_k) \\ge g_k(x_k)$。\n\n为清晰起见，我们考虑单个维度并省略下标 $k$。我们需要证明对于 $x \\in [0,1]$ 有 $U(x) \\ge g(x)$。\n\n函数为 $g(x) = \\exp(\\alpha x)$，其中 $\\alpha  0$。此函数是凸函数，因为其二阶导数 $g''(x) = \\alpha^2 \\exp(\\alpha x)$ 严格为正。它也是非递减的，因为其一阶导数 $g'(x) = \\alpha \\exp(\\alpha x)$ 严格为正。\n\n包络 $U(x)$ 是由在节点 $t_i = i/K$（其中 $i \\in \\{0, \\dots, K\\}$）处的优势函数值 $M(t_i)$ 构建的。优势函数定义为 $M(t_i) = \\max_{j \\le i} g(t_j)$。由于 $g(x)$ 是非递减的，对于任何 $j \\le i$，我们有 $t_j \\le t_i$，因此 $g(t_j) \\le g(t_i)$。因此，最大值在 $j=i$ 时取得，所以 $M(t_i) = g(t_i)$。\n\n包络 $U(x)$ 是对点 $(t_i, g(t_i))$（其中 $i \\in \\{0, \\dots, K\\}$）进行插值的分段线性函数。考虑任意两个连续节点之间的区间 $[t_i, t_{i+1}]$。在此区间上，$U(x)$ 是连接点 $(t_i, g(t_i))$ 和 $(t_{i+1}, g(t_{i+1}))$ 的线段。\n\n凸函数 $g(x)$ 的一个基本性质是，连接其图像上任意两点的弦位于这两点之间函数图像的上方或之上。形式上，对于任何 $x \\in [t_i, t_{i+1}]$，$x$ 可以写成 $x = (1-\\lambda)t_i + \\lambda t_{i+1}$，其中 $\\lambda \\in [0,1]$。根据凸性：\n$$g(x) = g((1-\\lambda)t_i + \\lambda t_{i+1}) \\le (1-\\lambda)g(t_i) + \\lambda g(t_{i+1})$$\n不等式的右边恰好是连接 $(t_i, g(t_i))$ 和 $(t_{i+1}, g(t_{i+1}))$ 的线性函数在点 $x$ 处的值。这个线性函数就是在区间 $[t_i, t_{i+1}]$ 上的 $U(x)$。\n$$U(x) = (1-\\lambda)g(t_i) + \\lambda g(t_{i+1}) \\quad \\text{for } x \\in [t_i, t_{i+1}]$$\n因此，对于所有 $x \\in [t_i, t_{i+1}]$，都有 $g(x) \\le U(x)$。由于这对所有这样的区间 $i \\in \\{0, \\dots, K-1\\}$ 都成立，所以它对这些区间的并集，即整个定义域 $[0,1]$ 也成立。\n\n因此，我们已经证明了对于每个维度 $k$ 都有 $U_k(x_k) \\ge g_k(x_k)$。通过将这些不等式对 $k=1, \\dots, d$ 相乘，我们得出结论 $E(\\mathbf{x}) \\ge w(\\mathbf{x})$，从而证明了该包络是有效的。\n\n### 3. 计算方法\n\n对于每个测试用例，我们计算四元组 $(A_{\\text{base}}, A_{\\text{env}}, R, C_{\\text{env}})$。\n\n**基线接受率 ($A_{\\text{base}}$):**\n这可以使用提供的解析公式直接计算，该公式通过将权重函数 $w(\\mathbf{x})$ 在 $[0,1]^d$ 上积分并除以权重的上确界 $M = w(\\mathbf{1})$ 得出。\n$$A_{\\text{base}} = \\prod_{k=1}^d \\frac{\\int_0^1 g_k(x) \\, dx}{g_k(1)} = \\prod_{k=1}^d \\frac{\\int_0^1 \\exp(\\alpha_k x) \\, dx}{\\exp(\\alpha_k)} = \\prod_{k=1}^d \\frac{[\\exp(\\alpha_k x)/\\alpha_k]_0^1}{\\exp(\\alpha_k)} = \\prod_{k=1}^d \\frac{(\\exp(\\alpha_k)-1)/\\alpha_k}{\\exp(\\alpha_k)} = \\prod_{k=1}^d \\frac{1 - \\exp(-\\alpha_k)}{\\alpha_k}$$\n\n**包络接受率 ($A_{\\text{env}}$):**\n该比率由 $A_{\\text{env}} = \\int_{[0,1]^d} \\frac{w(\\mathbf{x})}{E(\\mathbf{x})} \\, d\\mathbf{x}$ 给出。由于 $w$ 和 $E$ 的可分离性，这变成了一维积分的乘积：\n$$A_{\\text{env}} = \\prod_{k=1}^d I_k, \\quad \\text{其中 } I_k = \\int_0^1 \\frac{g_k(x)}{U_k(x)} \\, dx$$\n为了计算每个 $I_k$，我们必须首先定义 $U_k(x)$。如证明所示，$U_k(x)$ 是对点 $(t_i, \\exp(\\alpha_k t_i))$（其中 $i \\in \\{0, \\dots, K_k\\}$）进行插值的分段线性函数。积分 $I_k$ 被分解为在节点区间上的和：\n$$I_k = \\sum_{i=0}^{K_k-1} \\int_{t_i}^{t_{i+1}} \\frac{g_k(x)}{U_k(x)} \\, dx$$\n对于每个区间 $[t_i, t_{i+1}]$，分母 $U_k(x)$ 是一个线性函数：\n$$U_k(x) = \\exp(\\alpha_k t_i) + \\frac{\\exp(\\alpha_k t_{i+1}) - \\exp(\\alpha_k t_i)}{t_{i+1} - t_i} (x - t_i)$$\n和中的每个积分都使用高精度求积方法（例如 `scipy.integrate.quad` 提供的方法）进行数值计算，确保每个 $I_k$ 的绝对误差低于 $10^{-8}$ 的要求容差。\n\n**改进比 ($R$) 和成本代理 ($C_{\\text{env}}$):**\n改进比是两个计算出的接受率的直接比值：$R = A_{\\text{env}} / A_{\\text{base}}$。计算成本代理是定义所有维度上包络的点的总数：$C_{\\text{env}} = \\sum_{k=1}^d (K_k + 1)$。\n\n对问题陈述中提供的每个测试用例实施这些步骤，得出最终的数值结果。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Designs and analyzes an algorithm for constructing an acceptance-rejection\n    envelope for event unweighting. The algorithm implements a separable convex\n    upper hull envelope and computes acceptance rates, cost proxies, and improvement\n    ratios for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1: d=1, alpha_1=2, K_1=8\n        {'d': 1, 'alphas': [2.0], 'Ks': [8]},\n        # Test case 2: d=1, alpha_1=6, K_1=8\n        {'d': 1, 'alphas': [6.0], 'Ks': [8]},\n        # Test case 3: d=1, alpha_1=4, K_1=1\n        {'d': 1, 'alphas': [4.0], 'Ks': [1]},\n        # Test case 4: d=2, (alpha_1,alpha_2)=(1,3), (K_1,K_2)=(8,8)\n        {'d': 2, 'alphas': [1.0, 3.0], 'Ks': [8, 8]},\n        # Test case 5: d=2, (alpha_1,alpha_2)=(3,5), (K_1,K_2)=(32,16)\n        {'d': 2, 'alphas': [3.0, 5.0], 'Ks': [32, 16]},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        d = case['d']\n        alphas = case['alphas']\n        Ks = case['Ks']\n\n        # 1. Calculate the baseline acceptance rate (A_base)\n        A_base_factors = []\n        for alpha_k in alphas:\n            # The problem statement guarantees alpha_k  0, so no division by zero.\n            A_base_factors.append((1.0 - np.exp(-alpha_k)) / alpha_k)\n        A_base = np.prod(A_base_factors)\n\n        # 2. Calculate the envelope acceptance rate (A_env)\n        A_env_factors = []\n        for k in range(d):\n            alpha_k = alphas[k]\n            K_k = Ks[k]\n            \n            # g_k(x) = exp(alpha_k * x)\n            g_k = lambda x: np.exp(alpha_k * x)\n            \n            # Define knots and evaluate g_k at these knots.\n            # Since g_k is non-decreasing, the isotonic majorant values are simply g_k(t_i).\n            knots = np.linspace(0.0, 1.0, K_k + 1)\n            majorant_values = g_k(knots)\n\n            # Numerically integrate g_k(x) / U_k(x) over [0, 1].\n            # The integral is split into a sum of integrals over each knot interval.\n            integral_1D = 0.0\n            for i in range(K_k):\n                t_i, t_i_plus_1 = knots[i], knots[i+1]\n                val_i, val_i_plus_1 = majorant_values[i], majorant_values[i+1]\n                \n                # Integrand for the interval [t_i, t_{i+1}]\n                def integrand_piece(x):\n                    # Define U_k(x) on the current interval [t_i, t_{i+1}]\n                    # U_k(x) = val_i + (val_{i+1}-val_i)/(t_{i+1}-t_i) * (x-t_i)\n                    # Note: t_{i+1} - t_i = 1/K_k\n                    slope = (val_i_plus_1 - val_i) * K_k\n                    U_k_val = val_i + slope * (x - t_i)\n                    return g_k(x) / U_k_val\n\n                # Use quad for high-precision numerical integration\n                # Set tight tolerance to ensure overall accuracy target is met.\n                integral_piece, _ = quad(\n                    integrand_piece, t_i, t_i_plus_1, \n                    epsabs=1e-12, epsrel=1e-12\n                )\n                integral_1D += integral_piece\n            \n            A_env_factors.append(integral_1D)\n\n        A_env = np.prod(A_env_factors)\n        \n        # 3. Calculate the improvement ratio (R)\n        # Check for A_base == 0 to prevent division by zero, though unlikely with alpha  0.\n        R = A_env / A_base if A_base != 0 else float('inf')\n\n        # 4. Calculate the computational cost proxy (C_env)\n        C_env = sum(K_val + 1 for K_val in Ks)\n        \n        all_results.append([A_base, A_env, R, float(C_env)])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'[{v[0]},{v[1]},{v[2]},{v[3]}]' for v in all_results)}]\")\n\nsolve()\n```", "id": "3513821"}]}