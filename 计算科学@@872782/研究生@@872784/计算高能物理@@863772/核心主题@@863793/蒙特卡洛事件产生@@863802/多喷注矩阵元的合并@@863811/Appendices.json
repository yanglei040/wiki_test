{"hands_on_practices": [{"introduction": "在任何合并算法中，第一步都是将一个固定阶的多部分子末态诠释为部分子簇射演化的结果。这个练习 [@problem_id:3522316] 让你亲手实践纵向不分的 $k_T$ 算法，这是一个用于逆向还原簇射过程的标准工具。通过实现这一聚类算法，你将重建分支历史及其相关的动量标度，这些是匹配矩阵元与部分子簇射的基本输入。", "problem": "在每个测试用例中，您会得到四个无质量的部分子，由横向动量 $p_T$（单位 $\\mathrm{GeV}$）、快度 $y$（无量纲）和方位角 $\\phi$（单位弧度）指定。您的任务是从这些输入动量开始，实现纵向不变 $k_T$ 喷注算法，以计算完整的聚类序列，并重建 Catani–Krauss–Kuhn–Webber (CKKW) 合并所需的有序分支历史。在合并两个伪粒子时，使用 $E$ 方案复合（四维矢量相加）。角度单位为弧度，所有与动量相关的量均应以 $\\mathrm{GeV}$ 为单位。喷注半径参数固定为 $R=0.6$。\n\n需要使用的基本定义：\n- 对于每个伪粒子 $i$，定义其横向动量 $p_{T,i} = \\sqrt{p_{x,i}^2 + p_{y,i}^2}$、方位角 $\\phi_i = \\mathrm{atan2}(p_{y,i}, p_{x,i})$ 和快度 $y_i = \\frac{1}{2}\\ln\\left(\\frac{E_i + p_{z,i}}{E_i - p_{z,i}}\\right)$。\n- 对于参数 $p=1$ 的纵向不变 $k_T$ 算法，其对距离为\n$$\nd_{ij} = \\min\\left(p_{T,i}^2,\\, p_{T,j}^2\\right)\\,\\frac{\\Delta R_{ij}^2}{R^2},\n$$\n其中 $\\Delta R_{ij}^2 = (y_i - y_j)^2 + \\Delta\\phi_{ij}^2$，且 $\\Delta\\phi_{ij}$ 通过标准环绕取值在 $[-\\pi, \\pi]$ 范围内。\n- 束流距离为\n$$\nd_{iB} = p_{T,i}^2.\n$$\n- 在每次迭代中，找出所有 $\\{d_{ij}\\}$ 和 $\\{d_{iB}\\}$ 中的最小距离。如果最小值是 $d_{ij}$，则使用四维矢量相加 $(E, \\vec{p}) \\rightarrow (E_i + E_j, \\vec{p}_i + \\vec{p}_j)$ 合并 $i$ 和 $j$，并记录此次合并事件。如果最小值是 $d_{iB}$，则将 $i$ 声明为最终喷注并移除，不记录合并事件。\n- 持续此过程，直到没有伪粒子剩下。\n- 对于 CKKW 历史，与 $i$ 和 $j$ 的合并相关的分支标度定义为 $k_T = \\sqrt{d_{ij}}$。按 $k_T$ 降序排列记录的合并事件，并以有序列表的形式提供分支历史。\n\n每个合并事件表示为一个列表 $[\\,[\\text{orig}_i],\\,[\\text{orig}_j],\\,k_T\\,]$，其中 $[\\text{orig}_i]$ 和 $[\\text{orig}_j]$ 是两个合并团簇中包含的原始部分子索引（每个测试用例的第一个部分子索引从 $0$ 开始）的列表，而 $k_T$ 是一个浮点数。按 $k_T$ 降序排列合并事件。如果没有发生合并，则为该测试用例返回一个空列表。所有 $k_T$ 值表示为四舍五入到 $6$ 位小数。角度必须是弧度，所有动量分量必须以 $\\mathrm{GeV}$ 为单位。对于无质量的部分子，通过以下方式构建输入四维矢量：\n$$\nE = p_T\\,\\cosh(y),\\quad p_x = p_T\\cos(\\phi),\\quad p_y = p_T\\sin(\\phi),\\quad p_z = p_T\\,\\sinh(y).\n$$\n\n测试套件（每个测试用例是一个包含四个三元组 $(p_T, y, \\phi)$ 的列表）：\n- 测试用例 $1$（一般聚类行为）：\n  $[(50.0,\\,0.1,\\,0.0),\\,(48.0,\\,0.12,\\,0.15),\\,(40.0,\\,1.5,\\,2.0),\\,(30.0,\\,-1.2,\\,-2.5)]$。\n- 测试用例 $2$（在 $\\pm\\pi$ 附近的方位角环绕）：\n  $[(35.0,\\,0.0,\\,3.10),\\,(33.0,\\,0.0,\\,-3.08),\\,(20.0,\\,0.5,\\,1.0),\\,(10.0,\\,-0.5,\\,-1.0)]$。\n- 测试用例 $3$（软粒子通过束流距离立即成为喷注）：\n  $[(100.0,\\,0.0,\\,0.5),\\,(80.0,\\,0.3,\\,-0.2),\\,(5.0,\\,2.0,\\,1.0),\\,(60.0,\\,-1.0,\\,2.0)]$。\n- 测试用例 $4$（近共线软粒子对）：\n  $[(15.0,\\,0.2,\\,0.2),\\,(14.0,\\,0.201,\\,0.201),\\,(50.0,\\,-2.0,\\,0.5),\\,(45.0,\\,2.0,\\,-0.5)]$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个元素对应于上述顺序中的一个测试用例。每个元素必须是该测试用例按规定排列的合并事件有序列表。例如，四个测试用例的有效输出形式为\n$[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$，\n其中每个内部列表是相应测试用例的有序分支历史。不应打印任何额外文本。", "solution": "该问题是有效的，要求实现纵向不变 $k_T$ 喷注聚类算法，以为四组无质量部分子确定 CKKW 合并历史。解决方案的结构是一个分步的算法流程，之后是 Python 实现。\n\n**基于原理的算法设计**\n\n解决方案的核心是一个迭代算法，该算法将初始的部分子列表逐步分组为喷注。此过程由一个距离度量控制，该度量在每一步都确定哪些粒子在动量空间中“最接近”。\n\n**1. 状态表示：伪粒子**\n我们首先为每个部分子或中间团簇定义一个计算表示，称之为“伪粒子”。每个伪粒子对象封装了两个关键信息：\n- 其四维动量 $P^\\mu = (E, p_x, p_y, p_z)$，存储为一个 $4$ 分量矢量。所有后续的运动学属性都由此派生。\n- 已合并形成此伪粒子的原始（$0$ 索引）部分子列表。\n\n最初，对于每个具有运动学参数 $(p_{T,i}, y_i, \\phi_i)$ 的输入部分子 $i$，我们使用无质量粒子的关系式构建其四维动量：\n$$\nE_i = p_{T,i}\\,\\cosh(y_i)\n$$\n$$\np_{x,i} = p_{T,i}\\cos(\\phi_i)\n$$\n$$\np_{y,i} = p_{T,i}\\sin(\\phi_i)\n$$\n$$\np_{z,i} = p_{T,i}\\,\\sinh(y_i)\n$$\n这将创建初始的伪粒子集合，每个伪粒子包含一个原始部分子索引。根据任何伪粒子的四维动量 $P^\\mu=(E, p_x, p_y, p_z)$，其横向动量 $p_T$、快度 $y$ 和方位角 $\\phi$ 会根据需要重新计算：\n$$\np_T = \\sqrt{p_x^2 + p_y^2}\n$$\n$$\ny = \\frac{1}{2}\\ln\\left(\\frac{E + p_z}{E - p_z}\\right)\n$$\n$$\n\\phi = \\mathrm{atan2}(p_y, p_x)\n$$\n\n**2. 迭代聚类循环**\n算法在一个循环中进行，直到活动伪粒子列表为空。在每次迭代中，根据一组计算出的距离做出单个决策。\n\n**2a. 距离计算**\n对于当前集合中的 $N$ 个伪粒子，计算两种类型的距离：\n- **对距离（$d_{ij}$）**：对于每对唯一的伪粒子 $(i, j)$，计算一个距离。此度量量化了它们在动量空间中的分离。对于参数 $p=1$ 的纵向不变 $k_T$ 算法，公式为：\n$$\nd_{ij} = \\min\\left(p_{T,i}^2,\\, p_{T,j}^2\\right)\\,\\frac{\\Delta R_{ij}^2}{R^2}\n$$\n其中 $R=0.6$ 是喷注半径参数，$\\Delta R_{ij}^2$ 是在快度-方位角平面上的平方分离：\n$$\n\\Delta R_{ij}^2 = (y_i - y_j)^2 + (\\Delta\\phi_{ij})^2\n$$\n方位角差 $\\Delta\\phi_{ij} = \\phi_i - \\phi_j$ 必须小心处理以遵循其周期性，确保其位于区间 $[-\\pi, \\pi]$ 内。\n\n- **束流距离（$d_{iB}$）**：对于每个伪粒子 $i$，计算一个束流距离。该度量代表粒子的“硬度”及其成为独立喷注而非更大喷注一部分的倾向。它定义为：\n$$\nd_{iB} = p_{T,i}^2\n$$\n\n**2b. 寻找最小距离**\n在计算完所有 $N(N-1)/2$ 个对距离 $\\{d_{ij}\\}$ 和所有 $N$ 个束流距离 $\\{d_{iB}\\}$ 后，算法识别出全局最小值 $d_{\\min} = \\min(\\min_{\\{i,j\\}} d_{ij}, \\min_k d_{kB})$。\n\n**2c. 操作：合并或最终化**\n采取的操作取决于 $d_{\\min}$ 是对距离还是束流距离：\n- **如果 $d_{\\min} = d_{ij}$（对合并）：** 这表示粒子 $i$ 和 $j$ 是最接近的一对。它们被合并成一个新的、单一的伪粒子。\n    - **复合：** $E$ 方案复合规则规定四维动量相加：$P_{new}^\\mu = P_i^\\mu + P_j^\\mu$。原始部分子索引列表被连接起来：$\\text{orig}_{new} = \\text{orig}_i \\cup \\text{orig}_j$。\n    - **记录：** 此合并事件是 CKKW 历史中的一个分支。我们将其记录为一个三元组 $[\\,[\\text{orig}_i],\\,[\\text{orig}_j],\\,k_T\\,]$，其中 $[\\text{orig}_i]$ 和 $[\\text{orig}_j]$ 是原始索引的排序列表，而 $k_T = \\sqrt{d_{ij}}$ 是该分裂的特征横向动量标度。\n    - **状态更新：** 粒子 $i$ 和 $j$ 从活动列表中移除，新的合并粒子被添加进去。\n\n- **如果 $d_{\\min} = d_{iB}$（最终化喷注）：** 这表示粒子 $i$ 比它与其他任何粒子的“距离”更“硬”（即具有更大的 $p_T^2$）。因此，它被声明为末态喷注。\n    - **状态更新：** 粒子 $i$ 从活动列表中移除。此操作不记录合并事件。\n\n**3. 终止与输出生成**\n当没有伪粒子剩下时，循环终止。最后一步是准备输出。收集到的合并事件列表按分支标度 $k_T$ 的降序排列。这个排序后的列表代表了 CKKW 分支历史，显示了从最硬到最软的分裂序列。最终输出中的 $k_T$ 值按要求四舍五入到 $6$ 位小数。如果在整个过程中没有发生合并（例如，所有初始部分子都立即被声明为喷注），则为该测试用例返回一个空列表。", "answer": "```python\nimport numpy as np\n\nclass PseudoParticle:\n    \"\"\"A class to represent a pseudo-particle in the jet clustering process.\"\"\"\n    def __init__(self, E, px, py, pz, original_indices):\n        \"\"\"\n        Initializes a pseudo-particle with its 4-momentum and original parton indices.\n        \n        Args:\n            E (float): Energy.\n            px (float): Momentum in x-direction.\n            py (float): Momentum in y-direction.\n            pz (float): Momentum in z-direction.\n            original_indices (list[int]): List of 0-indexed original partons.\n        \"\"\"\n        self.four_vector = np.array([E, px, py, pz], dtype=np.float64)\n        # Keep original indices sorted for canonical representation\n        self.original_indices = sorted(original_indices)\n        self.update_kinematics()\n\n    def update_kinematics(self):\n        \"\"\"Calculates pT, rapidity (y), and azimuth (phi) from the 4-momentum.\"\"\"\n        E, px, py, pz = self.four_vector\n        self.pT = np.sqrt(px**2 + py**2)\n        \n        if self.pT  1e-12: # Effectively zero transverse momentum\n            self.phi = 0.0\n            # Rapidity is singular for massless particles with pT=0.\n            # Handle this case, although unlikely with E-scheme recombination.\n            if abs(E - abs(pz))  1e-9:\n                self.y = np.sign(pz) * 1e9 if pz != 0 else 0.0\n            else:\n                self.y = 0.5 * np.log((E + pz) / (E - pz))\n        else:\n            self.phi = np.arctan2(py, px)\n            # This formula is robust for massive particles (E-pz > 0 for E^2 > p^2)\n            self.y = 0.5 * np.log((E + pz) / (E - pz))\n\ndef run_kt_algorithm(initial_partons_data, R):\n    \"\"\"\n    Implements the longitudinally invariant kt jet algorithm.\n\n    Args:\n        initial_partons_data (list[tuple]): List of (pT, y, phi) for each initial parton.\n        R (float): The jet radius parameter.\n\n    Returns:\n        list: The ordered list of merge events, sorted by descending kT.\n    \"\"\"\n    particles = []\n    for i, (pT, y, phi) in enumerate(initial_partons_data):\n        E = pT * np.cosh(y)\n        px = pT * np.cos(phi)\n        py = pT * np.sin(phi)\n        pz = pT * np.sinh(y)\n        particles.append(PseudoParticle(E, px, py, pz, [i]))\n\n    merges = []\n    R2 = R**2\n\n    while particles:\n        num_particles = len(particles)\n        if num_particles == 0:\n            break\n\n        min_dist = float('inf')\n        min_type = None\n        min_indices = None\n\n        # Calculate pairwise distances (d_ij)\n        for i in range(num_particles):\n            for j in range(i + 1, num_particles):\n                p_i, p_j = particles[i], particles[j]\n                \n                delta_y = p_i.y - p_j.y\n                delta_phi = p_i.phi - p_j.phi\n                # Wrap delta_phi to the range [-pi, pi]\n                delta_phi = (delta_phi + np.pi) % (2 * np.pi) - np.pi\n                \n                delta_R2 = delta_y**2 + delta_phi**2\n                d_ij = min(p_i.pT**2, p_j.pT**2) * delta_R2 / R2\n\n                if d_ij  min_dist:\n                    min_dist = d_ij\n                    min_type = 'pair'\n                    min_indices = (i, j)\n        \n        # Calculate beam distances (d_iB)\n        for i in range(num_particles):\n            d_iB = particles[i].pT**2\n            if d_iB  min_dist:\n                min_dist = d_iB\n                min_type = 'beam'\n                min_indices = (i,)\n\n        # Perform the action corresponding to the minimum distance\n        if min_type == 'pair':\n            i, j = min_indices\n            \n            # Ensure i  j for easier list removal\n            if i > j: i, j = j, i\n            \n            p_i, p_j = particles[i], particles[j]\n\n            # Record the merge event for CKKW history\n            kT = np.sqrt(min_dist)\n            orig_i, orig_j = p_i.original_indices, p_j.original_indices\n            \n            # Ensure canonical ordering of original index lists for deterministic output\n            if orig_i > orig_j: orig_i, orig_j = orig_j, orig_i\n            \n            merges.append([orig_i, orig_j, kT])\n\n            # Merge particles using E-scheme recombination (4-vector addition)\n            new_4vec = p_i.four_vector + p_j.four_vector\n            new_orig_indices = p_i.original_indices + p_j.original_indices\n            new_particle = PseudoParticle(new_4vec[0], new_4vec[1], new_4vec[2], new_4vec[3], new_orig_indices)\n\n            # Remove old particles (higher index first) and add the new one\n            del particles[j]\n            del particles[i]\n            particles.append(new_particle)\n            \n        elif min_type == 'beam':\n            i = min_indices[0]\n            del particles[i] # Declare particle as a jet and remove\n        elif num_particles == 1: # Handle the last remaining particle\n            del particles[0]\n        else: # Should not occur\n            break\n\n    # Sort merges by k_T in descending order\n    merges.sort(key=lambda x: x[2], reverse=True)\n    \n    # Format the final list with rounded k_T\n    formatted_merges = [[m[0], m[1], round(m[2], 6)] for m in merges]\n        \n    return formatted_merges\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final result.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        [(50.0, 0.1, 0.0), (48.0, 0.12, 0.15), (40.0, 1.5, 2.0), (30.0, -1.2, -2.5)],\n        # Test Case 2\n        [(35.0, 0.0, 3.10), (33.0, 0.0, -3.08), (20.0, 0.5, 1.0), (10.0, -0.5, -1.0)],\n        # Test Case 3\n        [(100.0, 0.0, 0.5), (80.0, 0.3, -0.2), (5.0, 2.0, 1.0), (60.0, -1.0, 2.0)],\n        # Test Case 4\n        [(15.0, 0.2, 0.2), (14.0, 0.201, 0.201), (50.0, -2.0, 0.5), (45.0, 2.0, -0.5)],\n    ]\n    \n    JET_RADIUS = 0.6\n    \n    all_results = []\n    for case in test_cases:\n        result = run_kt_algorithm(case, JET_RADIUS)\n        all_results.append(result)\n    \n    # Convert the list of results to a string, removing spaces for a compact format.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3522316"}, {"introduction": "重建了簇射历史之后，像 CKKW-L 这样的合并算法必须决定是接受该矩阵元事例，还是让部分子簇射来产生相应的辐射。这个决定是通过“否决簇射”(vetoed shower)机制做出的，即禁止在某个合并标度之上发生辐射。这个练习 [@problem_id:3522333] 将指导你计算一个事例在否决机制下“存活”的概率，其中 Sudakov 因子被用作计算无辐射概率的工具。", "problem": "给定一个简化的计算模型，用于研究多喷注过程中 Catani-Krauss-Kuhn-Webber 的 Lönnblad 变体 (CKKW-L) 合并方案。考虑质子-质子 (pp) 碰撞产生一个 $Z$ 玻色子和两个部分子的过程，记为 $pp \\to Z + 2$ partons。在 CKKW-L 框架中，来自矩阵元生成器的每个事件都被赋予聚类节点标度，这些标度被解释为有色腿的簇射起始标度。然后，从每个节点标度向下到合并标度执行一次带否决的部分子簇射，如果任何簇射出射的演化标度高于合并标度，则该事件被拒绝。您的任务是实现一个程序，对于指定的事件样本和合并标度，计算被 CKKW-L 否决拒绝的事件的比例。\n\n基本和建模假设：\n- 假设量子色动力学 (QCD) 的软共线出射，其演化变量被确定为一个类横向动量的标度 $t$（单位为 $\\mathrm{GeV}$）。单位 $\\ln t$ 的出射率的前导近似由以下模型给出\n$$ \\mathrm{d} \\mathcal{P} \\approx \\frac{\\alpha_s(t) \\, C}{\\pi} \\, \\frac{\\mathrm{d}t}{t}, $$\n其中 $C$ 是一个色因子。对于夸克腿，取 $C = C_F = \\frac{4}{3}$。\n- 使用单圈强耦合常数跑动，其中包含 $n_f$ 个活性味，且 Landau 极点位于 $\\Lambda_{\\mathrm{QCD}}$：\n$$ \\alpha_s(Q) = \\frac{4 \\pi}{\\beta_0 \\ln\\left(\\frac{Q^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)}, \\quad \\beta_0 = 11 - \\frac{2 n_f}{3}. $$\n- 在上标度 $t_{\\mathrm{upper}}$ 和下标度 $t_{\\mathrm{lower}}$ 之间的无出射概率（Sudakov 形状因子）为\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\exp\\left(- \\int_{t_{\\mathrm{lower}}}^{t_{\\mathrm{upper}}} \\frac{\\alpha_s(t) \\, C}{\\pi} \\, \\frac{\\mathrm{d}t}{t} \\right). $$\n对于上述单圈 $\\alpha_s$，该积分得出解析表达式\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\left( \\frac{\\ln\\!\\left(\\frac{t_{\\mathrm{lower}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)}{\\ln\\!\\left(\\frac{t_{\\mathrm{upper}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)} \\right)^{\\frac{2 C}{\\beta_0}}, \\quad \\text{for } t_{\\mathrm{upper}}  t_{\\mathrm{lower}}  \\Lambda_{\\mathrm{QCD}}, $$\n如果 $t_{\\mathrm{upper}} \\le t_{\\mathrm{lower}}$，则 $\\Delta = 1$。\n- 对于一个 $pp \\to Z + 2$ partons 事件，模型包含两个有色腿，每个腿从其节点标度 $t_i$（单位为 $\\mathrm{GeV}$）开始。如果两条腿都没有在合并标度 $t_{\\mathrm{merge}}$（单位为 $\\mathrm{GeV}$）之上发生出射，则该事件被带否决的簇射所接受。在简化的解析模型中，事件的接受概率是 Sudakov 因子的乘积\n$$ P_{\\mathrm{acc}} = \\prod_{i=1}^{2} \\Delta(t_i, t_{\\mathrm{merge}}), \\quad \\text{with the convention } \\Delta(t_i, t_{\\mathrm{merge}}) = 1 \\text{ if } t_i \\le t_{\\mathrm{merge}}. $$\n拒绝概率为 $P_{\\mathrm{rej}} = 1 - P_{\\mathrm{acc}}$。\n- 对于所有有色腿，您必须使用 $n_f = 5$、$\\Lambda_{\\mathrm{QCD}} = 0.2~\\mathrm{GeV}$ 和 $C = C_F = \\frac{4}{3}$。所有能量标度必须以 $\\mathrm{GeV}$ 为单位处理。\n\n您的程序必须为下面的每个测试用例计算被 CKKW-L 否决拒绝的事件比例：\n$$ R = \\frac{1}{N} \\sum_{e=1}^{N} \\left( 1 - \\prod_{i=1}^{2} \\Delta(t_{e,i}, t_{\\mathrm{merge}}) \\right), $$\n其中 $t_{e,i}$ 是事件 $e$ 中腿 $i$ 的节点标度，而 $N$ 是该测试用例样本中的事件数。\n\n测试套件：\n- 测试用例 $1$ (正常路径)：合并标度 $t_{\\mathrm{merge}} = 15~\\mathrm{GeV}$，包含 $N = 5$ 个事件的样本，其节点标度（单位为 $\\mathrm{GeV}$）如下：\n    - 事件 $1$：$[35.0, 25.0]$\n    - 事件 $2$：$[40.0, 18.0]$\n    - 事件 $3$：$[22.0, 21.0]$\n    - 事件 $4$：$[30.0, 16.0]$\n    - 事件 $5$：$[15.0, 50.0]$\n- 测试用例 $2$ (包含等于和低于截断值的腿的边界条件)：合并标度 $t_{\\mathrm{merge}} = 20~\\mathrm{GeV}$，包含 $N = 5$ 个事件的样本：\n    - 事件 $1$：$[20.0, 50.0]$\n    - 事件 $2$：$[20.0, 20.0]$\n    - 事件 $3$：$[25.0, 20.0]$\n    - 事件 $4$：$[21.0, 19.5]$\n    - 事件 $5$：$[100.0, 35.0]$\n- 测试用例 $3$ (低合并标度的近红外边缘情况)：合并标度 $t_{\\mathrm{merge}} = 0.5~\\mathrm{GeV}$，包含 $N = 5$ 个事件的样本：\n    - 事件 $1$：$[30.0, 25.0]$\n    - 事件 $2$：$[80.0, 60.0]$\n    - 事件 $3$：$[22.0, 21.0]$\n    - 事件 $4$：$[100.0, 35.0]$\n    - 事件 $5$：$[15.0, 50.0]$\n\n答案规格：\n- 所有计算必须以 $\\mathrm{GeV}$ 为单位。\n- 对于每个测试用例，将比例 $R$ 作为区间 $[0, 1]$ 内的浮点数输出。\n- 您的程序应生成单行输出，其中包含三个结果，格式为方括号内的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是相应测试用例的浮点数结果。", "solution": "用户提供的问题是有效的。这是一个来自计算高能物理领域的、定义明确且有科学依据的问题。所有必要的数据、常数和公式都已提供，并且没有内部矛盾或含糊不清之处。该模型虽然经过简化，但基于量子色动力学 (QCD) 的既定原理，特别是 CKKW-L 合并程序。\n\n任务是为几个模拟的 $pp \\to Z + 2$ 部分子事件样本计算平均拒绝比例 $R$。拒绝比例是单个事件拒绝概率 $P_{\\mathrm{rej}, e}$ 在 $N$ 个事件样本上的平均值：\n$$ R = \\frac{1}{N} \\sum_{e=1}^{N} P_{\\mathrm{rej}, e} $$\n事件的拒绝由带否决的部分子簇射决定。只有当事件的有色腿在其各自的起始标度 $t_i$ 和一个共同的合并标度 $t_{\\mathrm{merge}}$ 之间没有发生部分子出射时，该事件才被接受。两个标度之间无出射的概率由 Sudakov 形状因子 $\\Delta$ 给出。对于指定的包含 $2$ 个有色腿且起始标度为 $t_1$ 和 $t_2$ 的过程，假设出射是独立的，则总的事件接受概率是各个无出射概率的乘积：\n$$ P_{\\mathrm{acc}} = \\Delta(t_1, t_{\\mathrm{merge}}) \\cdot \\Delta(t_2, t_{\\mathrm{merge}}) $$\n因此，单个事件的拒绝概率为 $P_{\\mathrm{rej}} = 1 - P_{\\mathrm{acc}}$。\n\n此计算的核心部分是 Sudakov 形状因子 $\\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}})$。问题提供了其解析表达式，该表达式由强耦合常数 $\\alpha_s(t)$ 的单圈跑动推导得出：\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\left( \\frac{\\ln\\left(\\frac{t_{\\mathrm{lower}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)}{\\ln\\left(\\frac{t_{\\mathrm{upper}}^2}{\\Lambda_{\\mathrm{QCD}}^2}\\right)} \\right)^{\\frac{2 C}{\\beta_0}} $$\n此公式适用于条件 $t_{\\mathrm{upper}}  t_{\\mathrm{lower}}  \\Lambda_{\\mathrm{QCD}}$。根据 CKKW-L 规则的规定，如果起始标度 $t_{\\mathrm{upper}}$ 已经等于或低于合并标度 $t_{\\mathrm{lower}}$，则簇射区间不存在。在这种情况下，不可能发生可被否决的出射，无出射概率为 1，即当 $t_{\\mathrm{upper}} \\le t_{\\mathrm{lower}}$ 时 $\\Delta = 1$。\n\n为实现计算，我们首先确定所需物理常数的数值。\n活性夸克味数给定为 $n_f = 5$。\nQCD 标度参数指定为 $\\Lambda_{\\mathrm{QCD}} = 0.2~\\mathrm{GeV}$。\n夸克腿（这里预期的部分子类型）的色因子是 Casimir 不变量 $C = C_F = \\frac{4}{3}$。\n使用这些输入，我们计算 QCD β 函数的前导阶系数：\n$$ \\beta_0 = 11 - \\frac{2 n_f}{3} = 11 - \\frac{2 \\cdot 5}{3} = 11 - \\frac{10}{3} = \\frac{23}{3} $$\nSudakov 公式中的指数现在可以预先计算为一个单一的常数值：\n$$ \\frac{2 C}{\\beta_0} = \\frac{2 \\cdot \\frac{4}{3}}{\\frac{23}{3}} = \\frac{\\frac{8}{3}}{\\frac{23}{3}} = \\frac{8}{23} $$\n为了提高数值稳定性和计算效率，可以使用对数性质 $\\ln(x^2) = 2 \\ln(x)$ 来简化 Sudakov 公式：\n$$ \\Delta(t_{\\mathrm{upper}}, t_{\\mathrm{lower}}) = \\left( \\frac{2 \\ln(t_{\\mathrm{lower}}/\\Lambda_{\\mathrm{QCD}})}{2 \\ln(t_{\\mathrm{upper}}/\\Lambda_{\\mathrm{QCD}})} \\right)^{\\frac{8}{23}} = \\left( \\frac{\\ln(t_{\\mathrm{lower}}/\\Lambda_{\\mathrm{QCD}})}{\\ln(t_{\\mathrm{upper}}/\\Lambda_{\\mathrm{QCD}})} \\right)^{\\frac{8}{23}} $$\n这就是将要实现的形式。\n\n解决每个测试用例的算法步骤如下：\n$1$. 对于每个由合并标度 $t_{\\mathrm{merge}}$ 和一个包含 $N$ 个事件的样本所定义的测试用例，初始化一个列表以存储每个事件的拒绝概率。\n$2$. 遍历样本中的每个事件 $e$。每个事件由两个节点标度 $t_{e,1}$ 和 $t_{e,2}$ 描述。\n$3$. 对于当前事件，计算其接受概率 $P_{\\mathrm{acc}, e}$。\n    a. 对于第一条腿，计算 Sudakov 因子 $\\Delta_1 = \\Delta(t_{e,1}, t_{\\mathrm{merge}})$。计算首先检查是否 $t_{e,1} \\le t_{\\mathrm{merge}}$。如果此条件为真，则 $\\Delta_1 = 1$。否则，使用解析公式。\n    b. 类似地，对于第二条腿，计算其 Sudakov 因子 $\\Delta_2 = \\Delta(t_{e,2}, t_{\\mathrm{merge}})$。\n    c. 事件的总接受概率是各独立腿的因子的乘积：$P_{\\mathrm{acc}, e} = \\Delta_1 \\cdot \\Delta_2$。\n$4$. 计算事件的拒绝概率为 $P_{\\mathrm{rej}, e} = 1 - P_{\\mathrm{acc}, e}$。\n$5$. 存储该值 $P_{\\mathrm{rej}, e}$。\n$6$. 遍历样本中所有 $N$ 个事件后，通过取所有存储的 $P_{\\mathrm{rej}, e}$ 值的算术平均值来计算该测试用例的最终拒绝比例 $R$。\n$7$. 对所有三个测试用例重复此过程，并将得到的 $R$ 值收集起来作为最终输出。\n\n这个分步逻辑在提供的 Python 程序中实现。一个专门的函数计算 Sudakov 因子，正确处理边界条件。另一个函数统筹整个事件样本的平均拒绝比例的计算。主函数 `solve` 设置测试用例数据，为每个用例调用计算逻辑，并将结果格式化为指定精确的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Define global constants based on the problem statement.\n# All scales are in GeV.\nLAMBDA_QCD = 0.2  # QCD scale parameter\nN_F = 5          # Number of active flavors\nC_F = 4.0 / 3.0  # Casimir color factor for quarks\n\n# Pre-calculate derived constants for efficiency.\nBETA_0 = 11.0 - (2.0 * N_F / 3.0)  # Leading-order beta function coefficient\nSUDOKOV_EXPONENT = (2.0 * C_F) / BETA_0   # Exponent for the Sudakov form factor\n\ndef sudakov(t_upper, t_lower):\n    \"\"\"\n    Calculates the Sudakov form factor (no-emission probability)\n    between an upper scale t_upper and a lower scale t_lower.\n\n    Args:\n        t_upper (float): The shower starting scale (node scale).\n        t_lower (float): The lower scale cutoff (merging scale).\n\n    Returns:\n        float: The no-emission probability Delta(t_upper, t_lower).\n    \"\"\"\n    # Per the CKKW-L convention, if the starting scale is at or below the\n    # merging scale, there is no phase space for a vetoable emission.\n    # The no-emission probability is therefore 1.\n    if t_upper = t_lower:\n        return 1.0\n\n    # The analytic formula is valid for scales > Lambda_QCD. Here we apply\n    # the simplified and more numerically stable version of the formula.\n    log_arg_lower = t_lower / LAMBDA_QCD\n    log_arg_upper = t_upper / LAMBDA_QCD\n\n    base = np.log(log_arg_lower) / np.log(log_arg_upper)\n    \n    return base ** SUDOKOV_EXPONENT\n\ndef calculate_rejection_fraction(t_merge, event_sample):\n    \"\"\"\n    Calculates the average rejection fraction for a sample of events.\n\n    Args:\n        t_merge (float): The merging scale.\n        event_sample (list of lists of floats): A list of events, where each\n                                                event is a list of node scales.\n\n    Returns:\n        float: The average rejection fraction for the sample.\n    \"\"\"\n    rejection_probabilities = []\n    for node_scales in event_sample:\n        # For each event, calculate acceptance probability as the product of\n        # Sudakov factors for each of its two colored legs.\n        p_acc = 1.0\n        for t_node in node_scales:\n            p_acc *= sudakov(t_node, t_merge)\n        \n        # The rejection probability is 1 - acceptance probability.\n        p_rej = 1.0 - p_acc\n        rejection_probabilities.append(p_rej)\n    \n    # The rejection fraction is the average of rejection probabilities over the sample.\n    return np.mean(rejection_probabilities)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (merging_scale, list_of_events)\n    # Each event is a list of its node scales.\n    test_cases = [\n        (15.0, [\n            [35.0, 25.0],\n            [40.0, 18.0],\n            [22.0, 21.0],\n            [30.0, 16.0],\n            [15.0, 50.0]\n        ]),\n        (20.0, [\n            [20.0, 50.0],\n            [20.0, 20.0],\n            [25.0, 20.0],\n            [21.0, 19.5],\n            [100.0, 35.0]\n        ]),\n        (0.5, [\n            [30.0, 25.0],\n            [80.0, 60.0],\n            [22.0, 21.0],\n            [100.0, 35.0],\n            [15.0, 50.0]\n        ])\n    ]\n\n    results = []\n    for t_merge, event_sample in test_cases:\n        rejection_fraction = calculate_rejection_fraction(t_merge, event_sample)\n        results.append(rejection_fraction)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3522333"}, {"introduction": "一个成功的合并程序不仅要结合矩阵元和部分子簇射，还必须保持基本的物理原理，例如幺正性，它要求所有专属截面之和必须等于总的遍举截面。这个练习 [@problem_id:3522327] 通过一个简化模型来探索这一概念，你将量化合并过程中的不完美之处如何导致对幺正性的破坏。这个实践突出了任何产品级事例产生器都必须进行的一项关键验证检查。", "problem": "考虑质心能量为 $Q$ 的电子-正电子湮灭为强子的过程，即 $e^+ e^- \\to$ 强子。在量子色动力学 (QCD) 中，对于给定的喷注分辨或合并尺度 $Q_{\\text{cut}}$，独占 $n$-喷注率可以在领头对数近似 (LLA) 下建模。该模型将高于 $Q_{\\text{cut}}$ 的发射视为一个泊松过程，其平均发射数 $\\lambda(Q,Q_{\\text{cut}})$ 由积分的强耦合常数确定。在多喷注矩阵元 (ME) 与部分子簇射 (PS) 的幺正合并中，所有独占 $n$-喷注截面之和等于总包含截面。您的任务是使用一个合并样本来演示幺正性检验：对独占 $n$-喷注率按 $n$ 求和，并与总截面（归一化为1）进行比较，并在一个受控的玩具模型中量化偏差。\n\n基本定义和假设：\n- 使用具有独立发射和用于无发射概率的 Sudakov 形状因子的领头对数近似 (LLA)。\n- 高于 $Q_{\\text{cut}}$ 的可分辨发射数 $m$ 服从平均值为 $\\lambda$ 的泊松分布，独占 $n$-喷注末态恰好对应于 $m = n - 2$ 次发射。\n- 使用归一化截面，即，将总包含截面设为 $\\sigma_{\\text{tot}} = 1$ (无量纲)。\n- 平均发射数 $\\lambda(Q,Q_{\\text{cut}})$ 定义为\n$$\n\\lambda(Q,Q_{\\text{cut}}) \\equiv \\frac{2 C_F}{\\pi} \\int_{Q_{\\text{cut}}}^{Q} \\frac{\\alpha_s(\\mu)}{\\mu} \\, d\\mu,\n$$\n其中 $C_F = \\frac{4}{3}$ 是 $\\mathrm{SU}(3)$ 基本表示的二次 Casimir 算子，强耦合常数 $\\alpha_s(\\mu)$ 服从单圈跑动，\n$$\n\\alpha_s(\\mu) = \\frac{4\\pi}{\\beta_0 \\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)}, \\quad \\beta_0 = 11 - \\frac{2}{3} n_f, \\quad n_f = 5, \\quad \\Lambda = 0.2~\\mathrm{GeV}.\n$$\n假设 $Q  Q_{\\text{cut}}  \\Lambda$，因此所有对数都有定义。\n\n独占概率：\n- 高于 $Q_{\\text{cut}}$ 恰好有 $m$ 次发射的概率为\n$$\nP(m; \\lambda) = \\frac{e^{-\\lambda} \\lambda^m}{m!}.\n$$\n- 独占 $n$-喷注率为 $R_n = P(n-2; \\lambda)$，其中 $n \\ge 2$。\n\n合并样本模型：\n- 假设矩阵元合并至最多 $N_{\\mathrm{ME}}$ 个喷注。这意味着最多 $m_{\\mathrm{ME}} = N_{\\mathrm{ME}} - 2$ 次发射通过基于 ME 的重加权进行修正，而 $m  m_{\\mathrm{ME}}$ 的发射仍然由 PS 描述。\n- 通过为 ME 修正的多重数引入一个权重因子来模拟残余合并扭曲：\n$$\nw(m) = 1 + \\varepsilon \\, g(m), \\quad \\text{for } m \\le m_{\\mathrm{ME}},\n$$\n且对于 $m  m_{\\mathrm{ME}}$ 有 $w(m) = 1$。这里 $\\varepsilon$ 是一个控制扭曲幅度的可调实参数，而 $g(m)$ 是一个捕捉典型 ME-PS 张力模式的固定形状函数。使用显式函数形式\n$$\ng(m) = \\exp\\!\\left(-\\frac{m}{m_0}\\right) - c, \\quad m_0 = 1.5, \\quad c = 0.4,\n$$\n仅适用于 $m \\le m_{\\mathrm{ME}}$，且对于 $m  m_{\\mathrm{ME}}$ 有 $g(m)=0$。\n\n幺正性检验：\n- 合并的独占和 $S$ 为\n$$\nS(Q,Q_{\\text{cut}},N_{\\mathrm{ME}},\\varepsilon) = \\sum_{m=0}^{\\infty} P(m;\\lambda(Q,Q_{\\text{cut}})) \\, w(m).\n$$\n- 理想极限下的幺正性意味着 $S = 1$。将分数偏差（无量纲）定义为\n$$\n\\Delta \\equiv S - 1.\n$$\n\n算法要求：\n- 使用上述积分，以及单圈跑动的 $\\alpha_s$、$C_F = \\frac{4}{3}$、$n_f = 5$ 和 $\\Lambda = 0.2~\\mathrm{GeV}$ 来计算 $\\lambda(Q,Q_{\\text{cut}})$。\n- 计算 $m = 0,1,2,\\dots$ 的 $P(m;\\lambda)$，直到被忽略的尾部 $\\sum_{m=M_{\\max}+1}^{\\infty} P(m;\\lambda)$ 小于容差 $10^{-12}$；如果需要，可以为 $M_{\\max}$ 设定上限。\n- 应用合并权重 $w(m)$ 以获得 $S$ 然后获得 $\\Delta$。\n- 返回四舍五入到8位小数的 $\\Delta$ 值，形式为十进制数（无百分号）。所有量均为无量纲。\n\n测试套件：\n为以下参数集 $(Q, Q_{\\text{cut}}, N_{\\mathrm{ME}}, \\varepsilon)$ 提供结果，其中能量单位为 $\\mathrm{GeV}$：\n- 情况1：$(Q = 91.1876, Q_{\\text{cut}} = 5.0, N_{\\mathrm{ME}} = 6, \\varepsilon = 0.0)$，一个预期具有完美幺正性的“理想路径”情况。\n- 情况2：$(Q = 91.1876, Q_{\\text{cut}} = 5.0, N_{\\mathrm{ME}} = 4, \\varepsilon = 0.5)$，在低多重数区域有中度合并扭曲。\n- 情况3：$(Q = 91.1876, Q_{\\text{cut}} = 1.0, N_{\\mathrm{ME}} = 5, \\varepsilon = 0.2)$，较低的 $Q_{\\text{cut}}$ 会增加平均发射数。\n- 情况4：$(Q = 200.0, Q_{\\text{cut}} = 20.0, N_{\\mathrm{ME}} = 4, \\varepsilon = -0.3)$，更高的能量和负扭曲参数以探查压低效应。\n- 情况5：$(Q = 91.1876, Q_{\\text{cut}} = 80.0, N_{\\mathrm{ME}} = 6, \\varepsilon = 1.0)$，接近边界，其中 $Q_{\\text{cut}}$ 接近 $Q$，产生较小的平均发射数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含五个测试用例的分数偏差 $\\Delta$，格式为逗号分隔的列表并用方括号括起来，例如 $\\left[\\delta_1,\\delta_2,\\delta_3,\\delta_4,\\delta_5\\right]$，其中每个 $\\delta_i$ 都四舍五入到8位小数。所有输出都是无量纲的小数。", "solution": "此问题的目标是在一个将多喷注矩阵元 (ME) 与部分子簇射 (PS) 合并的简化模型中，计算对幺正性的分数偏差 $\\Delta$。幺正性要求所有独占喷注率之和等于总包含截面。在这个归一化框架中，该和应等于 $1$。偏差 $\\Delta$ 量化了由 ME 修正的玩具模型引入的对此原则的违反程度。\n\n计算过程分为两个主要阶段：首先，我们推导平均发射数 $\\lambda(Q, Q_{\\text{cut}})$ 的解析表达式；其次，我们利用它来推导一个计算上高效的偏差 $\\Delta$ 的精确公式。\n\n**1. 平均发射数 $\\lambda(Q, Q_{\\text{cut}})$ 的计算**\n\n平均发射数 $\\lambda$ 由强耦合常数 $\\alpha_s(\\mu)$ 对发射标度 $\\mu$ 的积分定义：\n$$\n\\lambda(Q,Q_{\\text{cut}}) \\equiv \\frac{2 C_F}{\\pi} \\int_{Q_{\\text{cut}}}^{Q} \\frac{\\alpha_s(\\mu)}{\\mu} \\, d\\mu\n$$\n单圈跑动强耦合常数由下式给出：\n$$\n\\alpha_s(\\mu) = \\frac{4\\pi}{\\beta_0 \\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)}\n$$\n其中 $\\beta_0 = 11 - \\frac{2}{3} n_f$。当 $n_f = 5$ 时，我们有 $\\beta_0 = 11 - \\frac{10}{3} = \\frac{23}{3}$。基本表示的二次 Casimir 算子为 $C_F = \\frac{4}{3}$。\n\n将 $\\alpha_s(\\mu)$ 的表达式代入 $\\lambda$ 的积分中：\n$$\n\\lambda = \\frac{2 C_F}{\\pi} \\int_{Q_{\\text{cut}}}^{Q} \\left( \\frac{4\\pi}{\\beta_0 \\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)} \\right) \\frac{d\\mu}{\\mu} = \\frac{8 C_F}{\\beta_0} \\int_{Q_{\\text{cut}}}^{Q} \\frac{1}{\\ln\\left(\\frac{\\mu^2}{\\Lambda^2}\\right)} \\frac{d\\mu}{\\mu}\n$$\n使用对数性质 $\\ln(a^b) = b \\ln(a)$，分母可以写为 $2\\ln(\\mu/\\Lambda)$。\n$$\n\\lambda = \\frac{8 C_F}{\\beta_0} \\int_{Q_{\\text{cut}}}^{Q} \\frac{1}{2\\ln(\\mu/\\Lambda)} \\frac{d\\mu}{\\mu} = \\frac{4 C_F}{\\beta_0} \\int_{Q_{\\text{cut}}}^{Q} \\frac{1}{\\ln(\\mu/\\Lambda)} \\frac{d\\mu}{\\mu}\n$$\n为了求解这个积分，我们进行变量替换。令 $u = \\ln(\\mu/\\Lambda)$。其微分为 $du = \\frac{1}{\\mu/\\Lambda} \\cdot \\frac{1}{\\Lambda} d\\mu = \\frac{d\\mu}{\\mu}$。积分限从 $\\mu \\in [Q_{\\text{cut}}, Q]$ 变为 $u \\in [\\ln(Q_{\\text{cut}}/\\Lambda), \\ln(Q/\\Lambda)]$。\n积分变为：\n$$\n\\lambda = \\frac{4 C_F}{\\beta_0} \\int_{\\ln(Q_{\\text{cut}}/\\Lambda)}^{\\ln(Q/\\Lambda)} \\frac{1}{u} \\, du = \\frac{4 C_F}{\\beta_0} \\left[ \\ln u \\right]_{\\ln(Q_{\\text{cut}}/\\Lambda)}^{\\ln(Q/\\Lambda)}\n$$\n计算该定积分，得到 $\\lambda$ 的最终解析表达式：\n$$\n\\lambda(Q, Q_{\\text{cut}}) = \\frac{4 C_F}{\\beta_0} \\left( \\ln\\left(\\ln\\frac{Q}{\\Lambda}\\right) - \\ln\\left(\\ln\\frac{Q_{\\text{cut}}}{\\Lambda}\\right) \\right) = \\frac{4 C_F}{\\beta_0} \\ln\\left( \\frac{\\ln(Q/\\Lambda)}{\\ln(Q_{\\text{cut}}/\\Lambda)} \\right)\n$$\n代入 $C_F$ 和 $\\beta_0$ 的数值：\n$$\n\\frac{4 C_F}{\\beta_0} = \\frac{4 \\cdot (4/3)}{23/3} = \\frac{16/3}{23/3} = \\frac{16}{23}\n$$\n因此，我们得到了一个仅依赖于能量标度 $Q$、$Q_{\\text{cut}}$ 和 $\\Lambda$ 的 $\\lambda$ 的闭合形式解。\n\n**2. 分数偏差 $\\Delta$ 的计算**\n\n总合并独占和 $S$ 定义为对所有可能的发射数 $m$ 的求和，并由泊松概率 $P(m;\\lambda)$ 和合并权重因子 $w(m)$ 加权：\n$$\nS = \\sum_{m=0}^{\\infty} P(m; \\lambda) w(m)\n$$\n权重因子 $w(m)$ 是分段定义的：\n$$\nw(m) = \\begin{cases} 1 + \\varepsilon \\, g(m)  \\text{for } m \\le m_{\\mathrm{ME}} \\\\ 1  \\text{for } m  m_{\\mathrm{ME}} \\end{cases}\n$$\n其中 $m_{\\mathrm{ME}} = N_{\\mathrm{ME}} - 2$ 是被矩阵元修正的最大发射数。\n\n我们可以将 $S$ 的求和分成两部分：\n$$\nS = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) + \\sum_{m=m_{\\mathrm{ME}}+1}^{\\infty} P(m; \\lambda) \\cdot 1\n$$\n第二项是泊松分布的尾部。泊松分布的一个基本性质是其归一化为1：$\\sum_{m=0}^{\\infty} P(m; \\lambda) = 1$。这意味着第二项可以表示为：\n$$\n\\sum_{m=m_{\\mathrm{ME}}+1}^{\\infty} P(m; \\lambda) = 1 - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda)\n$$\n将此代回 $S$ 的表达式中：\n$$\nS = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) + \\left( 1 - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) \\right)\n$$\n分数偏差定义为 $\\Delta \\equiv S - 1$。\n$$\n\\Delta = S - 1 = \\left( \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) + 1 - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) \\right) - 1\n$$\n$$\n\\Delta = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) w(m) - \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) (w(m) - 1)\n$$\n根据 $w(m)$ 的定义，对于 $m \\le m_{\\mathrm{ME}}$，我们有 $w(m) - 1 = \\varepsilon g(m)$。这得出了 $\\Delta$ 的最终精确表达式：\n$$\n\\Delta = \\sum_{m=0}^{m_{\\mathrm{ME}}} P(m; \\lambda) (\\varepsilon g(m)) = \\varepsilon \\sum_{m=0}^{m_{\\mathrm{ME}}} \\frac{e^{-\\lambda} \\lambda^m}{m!} \\left( \\exp\\left(-\\frac{m}{m_0}\\right) - c \\right)\n$$\n这个结果是一个从 $m=0$ 到 $m_{\\mathrm{ME}} = N_{\\mathrm{ME}}-2$ 的有限和。这在计算上是有利的，因为它避免了近似无穷级数和处理截断误差的需要。问题描述中提到的求和直到满足容差的方法对应于对 $S$ 的数值暴力计算，而此处的解析简化直接提供了精确结果。\n\n**3. 算法流程**\n\n对于由参数集 $(Q, Q_{\\text{cut}}, N_{\\mathrm{ME}}, \\varepsilon)$ 给出的每个测试用例，$\\Delta$ 的计算按以下步骤进行：\n1.  定义物理和模型常数：$\\Lambda = 0.2 \\ \\mathrm{GeV}$, $C_F = 4/3$, $n_f = 5$, $m_0 = 1.5$, 以及 $c = 0.4$。\n2.  计算 $\\beta_0 = 11 - 2/3 \\cdot n_f = 23/3$。\n3.  使用推导出的解析公式计算平均发射数 $\\lambda$：\n    $$ \\lambda = \\frac{16}{23} \\ln\\left( \\frac{\\ln(Q/\\Lambda)}{\\ln(Q_{\\text{cut}}/\\Lambda)} \\right) $$\n4.  确定最大修正多重数 $m_{\\mathrm{ME}} = N_{\\mathrm{ME}} - 2$。\n5.  如果 $\\varepsilon = 0$，偏差 $\\Delta$ 立刻为 $0$。否则，计算 $\\Delta$ 的有限和。\n6.  初始化一个求和变量 $\\Delta_{\\text{sum}} = 0$。\n7.  对 $m$ 从 $0$ 到 $m_{\\mathrm{ME}}$ 进行迭代。在每一步中：\n    a.  计算泊松概率 $P(m; \\lambda) = \\frac{e^{-\\lambda}\\lambda^m}{m!}$。为保持数值稳定性，最好迭代计算：$P(m;\\lambda) = P(m-1;\\lambda) \\cdot \\frac{\\lambda}{m}$，其中 $P(0;\\lambda) = e^{-\\lambda}$。\n    b.  计算扭曲项 $g(m) = \\exp(-m/m_0) - c$。\n    c.  将乘积 $P(m; \\lambda) \\cdot g(m)$ 加到累加和 $\\Delta_{\\text{sum}}$ 中。\n8.  最终偏差为 $\\Delta = \\varepsilon \\cdot \\Delta_{\\text{sum}}$。\n9.  按要求将 $\\Delta$ 的最终结果四舍五入到8位小数。\n该流程将为指定的五个测试用例中的每一个实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the unitarity deviation problem for the given test cases.\n    \"\"\"\n\n    # Define physical and model constants from the problem statement.\n    LAMBDA_QCD = 0.2  # GeV\n    C_F = 4.0 / 3.0\n    N_F = 5.0\n    BETA_0 = 11.0 - (2.0 / 3.0) * N_F\n    \n    # Distortion function parameters\n    M0 = 1.5\n    C_G = 0.4\n\n    # Define the test cases from the problem statement.\n    # Format: (Q [GeV], Q_cut [GeV], N_ME, epsilon)\n    test_cases = [\n        (91.1876, 5.0, 6, 0.0),   # Case 1\n        (91.1876, 5.0, 4, 0.5),   # Case 2\n        (91.1876, 1.0, 5, 0.2),   # Case 3\n        (200.0, 20.0, 4, -0.3),  # Case 4\n        (91.1876, 80.0, 6, 1.0),   # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        q, q_cut, n_me_jets, epsilon = case\n        \n        # Calculate the fractional deviation Delta.\n        delta = calculate_deviation(q, q_cut, n_me_jets, epsilon,\n                                    LAMBDA_QCD, C_F, BETA_0, M0, C_G)\n        \n        # Round the result to 8 decimal places.\n        results.append(round(delta, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_deviation(q, q_cut, n_me_jets, epsilon,\n                        lambda_qcd, c_f, beta_0, m0, c_g):\n    \"\"\"\n    Calculates the fractional deviation Delta for a single parameter set.\n    \n    The calculation uses the analytical formula derived in the solution:\n    Delta = epsilon * sum_{m=0 to m_ME} P(m; lambda) * g(m)\n    \"\"\"\n    # A merging distortion of size epsilon=0 leads to perfect unitarity, Delta=0.\n    if epsilon == 0.0:\n        return 0.0\n\n    # Calculate the mean number of emissions, lambda.\n    # lambda = (4*C_F/beta_0) * ln( ln(Q/Lambda)/ln(Q_cut/Lambda) )\n    prefactor = (4.0 * c_f) / beta_0\n    log_arg = np.log(q / lambda_qcd) / np.log(q_cut / lambda_qcd)\n    lambda_val = prefactor * np.log(log_arg)\n    \n    # Maximum number of ME-corrected emissions.\n    m_me = n_me_jets - 2\n\n    # Calculate the sum part of the Delta formula.\n    # sum_{m=0 to m_ME} (P(m; lambda) * g(m))\n    delta_sum = 0.0\n    \n    # To avoid large numbers in lambda^m and m!, calculate Poisson probabilities\n    # iteratively: P(m) = P(m-1) * lambda / m\n    poisson_prob = np.exp(-lambda_val)  # P(0; lambda)\n    \n    for m in range(m_me + 1):\n        # For m=0, poisson_prob is already P(0).\n        # For m > 0, it was updated in the previous iteration's end.\n        \n        # Calculate distortion function g(m)\n        g_m = np.exp(-m / m0) - c_g\n        \n        # Add term to the sum\n        delta_sum += poisson_prob * g_m\n        \n        # Update Poisson probability for the next iteration m+1\n        if m  m_me: # No need to update after the last term.\n            poisson_prob *= lambda_val / (m + 1.0)\n            \n    # Final deviation is epsilon times the sum.\n    delta = epsilon * delta_sum\n    \n    return delta\n\nsolve()\n```", "id": "3522327"}]}