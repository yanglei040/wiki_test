{"hands_on_practices": [{"introduction": "任何物理过程的模拟都必须严格遵守能量-动量守恒定律，部分子簇射也不例外。在部分子簇射中，每次粒子分支都必须精确地将父部分子的四动量分配给子部分子。这个练习 [@problem_id:3527678] 将让你亲手实现并验证两种不同的运动学方案，帮助你理解不同的反冲（recoil）策略如何确保守恒律在每次分裂中都得到满足。", "problem": "考虑在量子色动力学 (QCD) 部分子簇射的简化模型中，能量动量守恒的构建与验证。使用狭义相对论中的基本原理，即孤立系统中的总四维动量守恒，因此所有末态四维动量的总和等于初态四维动量。设四维动量在四维闵可夫斯基空间中表示为 $p^{\\mu} = (E, p_x, p_y, p_z)$，度规符号为 $(+,-,-,-)$，并设所有部分子都视为具有指定不变质量的点状粒子。任务是实现两种不同的簇射运动学和一个验证程序：\n\n1. 角序类时分支，建模为连续的两体衰变，其中一个质量为 $M$ 的有质量母部分子衰变为两个不变质量分别为 $m_1$ 和 $m_2$ 的子粒子。在母粒子静止系中，精确的两体相对论衰变运动学要求子粒子的三维动量大小等于\n$$\np^* = \\frac{\\sqrt{\\lambda(M^2,m_1^2,m_2^2)}}{2M}, \\quad \\lambda(a,b,c) = a^2 + b^2 + c^2 - 2ab - 2ac - 2bc,\n$$\n子粒子的能量为\n$$\nE_1 = \\frac{M^2 + m_1^2 - m_2^2}{2M}, \\quad E_2 = \\frac{M^2 + m_2^2 - m_1^2}{2M}.\n$$\n后续的衰变发生在正在衰变的子粒子的静止系中，然后使用洛伦兹变换将产生的子粒子变换回实验室参考系。发射方向由极角和方位角 $(\\theta,\\phi)$ 指定；角序通过要求连续发射满足 $\\theta_{\\text{next}} \\le \\theta_{\\text{previous}}$ 来强制执行。这种局域反冲方案确保了每次分支的精确守恒，因为两个子粒子在内部共享反冲，使得它们的四维矢量在静止系中相加等于母粒子的四维矢量，之后再进行 boost，而洛伦兹变换保持四维动量总和不变。\n\n2. 偶极子反冲映射，用于一个末态偶极子。该偶极子最初由质心系 (CM) 中的两个无质量部分子组成，总四维动量为 $P^{\\mu} = (Q, 0, 0, 0)$，其中 $Q$ 是质心能量。产生一个单一的无质量发射，其三维动量大小为 $|\\vec{k}|$，方向为 $\\hat{k}$ ($\\theta_k,\\phi_k$)，能量为 $E_k = |\\vec{k}|$，并满足 $0  |\\vec{k}|  Q/2$。剩下的两个反冲部分子被视为无质量，并对称地共享反冲，使得它们的三维动量之和为 $-\\vec{k}$，能量之和为 $Q - E_k$。定义\n$$\nE = \\frac{Q - |\\vec{k}|}{2}, \\quad \\cos\\alpha = \\frac{|\\vec{k}|}{Q - |\\vec{k}|}, \\quad \\alpha = \\arccos\\left(\\frac{|\\vec{k}|}{Q - |\\vec{k}|}\\right).\n$$\n选择一个与 $\\hat{k}$ 正交的单位矢量 $\\hat{u}$。然后构造两个单位矢量\n$$\n\\hat{n}_1 = -\\cos\\alpha\\,\\hat{k} + \\sin\\alpha\\,\\hat{u}, \\quad \\hat{n}_2 = -\\cos\\alpha\\,\\hat{k} - \\sin\\alpha\\,\\hat{u},\n$$\n并将反冲四维矢量设置为\n$$\np_1^{\\mu} = (E, E\\,\\hat{n}_1), \\quad p_2^{\\mu} = (E, E\\,\\hat{n}_2), \\quad k^{\\mu} = (|\\vec{k}|, |\\vec{k}|\\,\\hat{k}),\n$$\n这样通过构造就能精确确保 $p_1^{\\mu} + p_2^{\\mu} + k^{\\mu} = (Q, 0, 0, 0)$。\n\n实现一个程序，该程序：\n- 使用提供的参数为两种运动学组装末态四维矢量。\n- 对末态四维矢量求和，并将结果与初态四维动量进行比较，以验证能量动量守恒。\n- 对四维动量比较的每个分量使用 $10^{-9}\\,\\mathrm{GeV}$ 的数值容差。\n\n所有能量必须以 $\\mathrm{GeV}$ 表示，所有角度必须以弧度表示。程序必须输出布尔值，以指示每个测试用例的守恒是否在容差范围内成立。\n\n测试套件。对于角序分支，使用三组参数集，每组指定 $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2)$：\n- 情况 A1: $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2) = (100, 20, 0, 0.6, 1.0, 0.3, 0.4)$。\n- 情况 A2 (软第一次发射): $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2) = (50, 49, 0, 0.2, 2.2, 0.1, 1.7)$。\n- 情况 A3 (近共线第一次发射): $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2) = (80, 10, 0, 0.000001, 0.0, 0.0000005, 1.1)$。\n\n对于偶极子反冲映射，使用三组参数集，每组指定 $(Q, |\\vec{k}|, \\theta_k, \\phi_k)$：\n- 情况 D1: $(Q, |\\vec{k}|, \\theta_k, \\phi_k) = (100, 20, 1.0, 2.4)$。\n- 情况 D2 (软发射): $(Q, |\\vec{k}|, \\theta_k, \\phi_k) = (100, 1.0, 0.8, 0.5)$。\n- 情况 D3 (近最大能量发射): $(Q, |\\vec{k}|, \\theta_k, \\phi_k) = (100, 49.999, 2.0, 0.1)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[result_1,result_2,...]`），其中每个 $result_i$ 是 `True` 或 `False`。", "solution": "用户的请求是验证并解决一个关于两种简化部分子簇射运动学模型中能量动量守恒的问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   原理：孤立系统中四维动量守恒。\n*   四维动量：$p^{\\mu} = (E, p_x, p_y, p_z)$，度规符号为 $(+,-,-,-)$。\n*   容差：数值比较容差为 $10^{-9}\\,\\mathrm{GeV}$。\n*   单位：能量/质量单位为 $\\mathrm{GeV}$，角度单位为弧度。\n\n*   **模型 1 (角序类时分支)**：\n    *   一系列 $1 \\to 2$ 衰变。\n    *   初始粒子：质量为 $M$，处于静止状态。初始四维动量 $p_{init}^{\\mu} = (M,0,0,0)$。\n    *   一般衰变 $A \\to B+C$：在 $A$（质量为 $M_A$）的静止系中，子粒子（质量为 $m_B, m_C$）的动量大小为 $p^* = \\frac{\\sqrt{\\lambda(M_A^2, m_B^2, m_C^2)}}{2M_A}$，能量为 $E_B = \\frac{M_A^2 + m_B^2 - m_C^2}{2M_A}$，$E_C = \\frac{M_A^2 + m_C^2 - m_B^2}{2M_A}$，其中 $\\lambda(a,b,c) = a^2 + b^2 + c^2 - 2ab - 2ac - 2bc$ 是 Källén 函数。\n    *   后续衰变的产物从母粒子的静止系 boost 回实验室参考系。\n    *   测试用例提供参数 $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2)$。\n        *   A1: $(100, 20, 0, 0.6, 1.0, 0.3, 0.4)$\n        *   A2: $(50, 49, 0, 0.2, 2.2, 0.1, 1.7)$\n        *   A3: $(80, 10, 0, 0.000001, 0.0, 0.0000005, 1.1)$\n\n*   **模型 2 (偶极子反冲映射)**：\n    *   初始状态：质心系，总四维动量为 $P^{\\mu} = (Q, 0, 0, 0)$。\n    *   末态：一个无质量发射粒子 $k$，两个无质量反冲部分子 $p_1, p_2$。\n    *   发射粒子的动量大小为 $|\\vec{k}|$，能量为 $E_k = |\\vec{k}|$，方向为 $\\hat{k}(\\theta_k, \\phi_k)$，满足 $0  |\\vec{k}|  Q/2$。\n    *   反冲参数：$E = \\frac{Q-|\\vec{k}|}{2}$ 和 $\\cos\\alpha = \\frac{|\\vec{k}|}{Q-|\\vec{k}|}$。\n    *   反冲方向：对于与 $\\hat{k}$ 正交的 $\\hat{u}$，$\\hat{n}_1 = -\\cos\\alpha\\,\\hat{k} + \\sin\\alpha\\,\\hat{u}$ 且 $\\hat{n}_2 = -\\cos\\alpha\\,\\hat{k} - \\sin\\alpha\\,\\hat{u}$。\n    *   末态四维矢量：$k^{\\mu}=(|\\vec{k}|, |\\vec{k}|\\hat{k})$，$p_1^{\\mu}=(E, E\\hat{n}_1)$，$p_2^{\\mu}=(E, E\\hat{n}_2)$。\n    *   测试用例提供参数 $(Q, |\\vec{k}|, \\theta_k, \\phi_k)$。\n        *   D1: $(100, 20, 1.0, 2.4)$\n        *   D2: $(100, 1.0, 0.8, 0.5)$\n        *   D3: $(100, 49.999, 2.0, 0.1)$\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题在科学上基于狭义相对论和标准的高能物理运动学。它是客观且可形式化的。\n\n存在两点模糊之处：\n1.  模型 1：问题描述了“连续的两体衰变”，并提供了一个参数元组 $(M, m_1, m_2, \\theta_1, \\phi_1, \\theta_2, \\phi_2)$。第一次衰变产生的中间粒子的质量没有明确说明。这构成了一个设置不完整（未指定）的缺陷。然而，一个合理且标准的解释可以解决这个问题：\n    *   第一次衰变是 $P_0(M) \\to P_1(m_1) + P_2(m_2)$，其中 $M, m_1, m_2$ 在测试用例中给出。\n    *   第二次衰变是 $P_1(m_1) \\to P_{11} + P_{12}$。最终产物 $P_{11}$ 和 $P_{12}$ 的质量必须做出假设。在这类简化模型中，一个标准的假设是它们是无质量的。\n    这种解释以物理上一致的顺序使用了所有提供的参数，并使问题变得可解。\n2.  模型 2：构造过程需要选择一个与 $\\hat{k}$ 正交的单位矢量 $\\hat{u}$。$\\hat{u}$ 的选择没有被指定，这是一个不适定/模糊的缺陷。然而，分析表明末态四维动量之和 $p_1^\\mu + p_2^\\mu + k^\\mu$ 与 $\\hat{u}$ 的选择无关。因此，任何对 $\\hat{u}$ 的有效选择都将导致关于四维动量守恒的相同结论。这个模糊性不影响所提问题的最终答案。\n\n鉴于这些模糊之处可以通过合理且标准的解释（模型 1）解决，或者不影响最终结果（模型 2），该问题被认为是有效的。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。着手求解。\n\n### 解法\n\n解法要求实现所述的两种运动学方案，并对提供的测试用例进行四维动量守恒的数值验证。\n\n**模型 1：角序分支**\n\n该过程被解释为一个两步衰变链。\n1.  初始状态：一个质量为 $M$ 的粒子 $P_0$ 在实验室参考系中静止。其四维动量为 $p_{P_0}^\\mu = (M, 0, 0, 0)$。\n2.  第一次衰变：$P_0$ 衰变为 $P_1$（质量为 $m_1$）和 $P_2$（质量为 $m_2$）。由于 $P_0$ 是静止的，这次衰变发生在实验室参考系中。\n    *   子粒子的动量大小 $p^*$ 使用 Källén 函数计算：$p^* = \\frac{\\sqrt{\\lambda(M^2,m_1^2,m_2^2)}}{2M}$。\n    *   能量为 $E_1 = \\frac{M^2+m_1^2-m_2^2}{2M}$ 和 $E_2 = \\frac{M^2+m_2^2-m_1^2}{2M}$。\n    *   $P_1$ 的方向由 $(\\theta_1, \\phi_1)$ 给出。我们构造一个单位矢量 $\\hat{n}_1$ 并找到三维动量 $\\vec{p}_1 = p^*\\hat{n}_1$ 和 $\\vec{p}_2 = -p^*\\hat{n}_1$。\n    *   在实验室参考系中的四维动量为 $p_1^\\mu = (E_1, \\vec{p}_1)$ 和 $p_2^\\mu = (E_2, \\vec{p}_2)$。粒子 $P_2$ 是一个末态粒子。\n3.  第二次衰变：粒子 $P_1$ 衰变为两个无质量的子粒子 $P_{11}$ 和 $P_{12}$。这次衰变发生在 $P_1$ 的静止系中。\n    *   在 $P_1$ 静止系中，母粒子质量为 $m_1$，子粒子质量为 $0$。\n    *   子粒子的动量大小为 $p' = \\frac{\\sqrt{\\lambda(m_1^2,0,0)}}{2m_1} = \\frac{m_1}{2}$。它们的能量为 $E'_{11}=E'_{12}=\\frac{m_1}{2}$。\n    *   衰变方向由 $(\\theta_2, \\phi_2)$ 给出，定义了一个单位矢量 $\\hat{n}_2$。三维动量为 $\\vec{p}'_{11} = p'\\hat{n}_2$ 和 $\\vec{p}'_{12} = -p'\\hat{n}_2$。\n    *   静止系中的四维动量为 $p_{11}^{\\prime\\mu} = (m_1/2, \\vec{p}'_{11})$ 和 $p_{12}^{\\prime\\mu} = (m_1/2, \\vec{p}'_{12})$。\n4.  洛伦兹变换：四维动量 $p_{11}^{\\prime\\mu}$ 和 $p_{12}^{\\prime\\mu}$ 从 $P_1$ 静止系 boost 回实验室参考系。Boost 速度矢量为 $\\vec{\\beta} = \\vec{p}_1/E_1$。应用标准的洛伦兹变换得到实验室参考系中的四维动量 $p_{11}^\\mu$ 和 $p_{12}^\\mu$。\n5.  验证：将末态四维动量之和 $p_{final}^\\mu = p_2^\\mu + p_{11}^\\mu + p_{12}^\\mu$ 与初始四维动量 $p_{P_0}^\\mu$ 进行比较。每个分量必须在 $10^{-9}\\,\\mathrm{GeV}$ 的容差内匹配。\n\n**模型 2：偶极子反冲映射**\n\n1.  初始状态：系统的总四维动量为 $P_{init}^\\mu = (Q, 0, 0, 0)$。\n2.  发射构造：发射的无质量粒子 $k$ 的能量为 $E_k=|\\vec{k}|$，其三维动量 $\\vec{k}$ 由 $|\\vec{k}|, \\theta_k$ 和 $\\phi_k$ 构造。其四维动量为 $k^\\mu=(|\\vec{k}|, \\vec{k})$。\n3.  反冲构造：两个无质量反冲部分子 ($p_1, p_2$) 具有相等的能量 $E = (Q-|\\vec{k}|)/2$。\n    *   我们计算 $\\cos\\alpha = \\frac{|\\vec{k}|}{Q-|\\vec{k}|}$ 和 $\\sin\\alpha = \\sqrt{1-\\cos^2\\alpha}$。\n    *   一个与发射方向 $\\hat{k}$ 正交的单位矢量 $\\hat{u}$ 通过编程方式构造。\n    *   反冲方向单位矢量为 $\\hat{n}_1 = -\\cos\\alpha\\,\\hat{k} + \\sin\\alpha\\,\\hat{u}$ 和 $\\hat{n}_2 =-\\cos\\alpha\\,\\hat{k} - \\sin\\alpha\\,\\hat{u}$。\n    *   反冲四维动量为 $p_1^\\mu = (E, E\\hat{n}_1)$ 和 $p_2^\\mu = (E, E\\hat{n}_2)$。\n4.  验证：将末态四维动量之和 $p_{final}^\\mu = k^\\mu + p_1^\\mu + p_2^\\mu$ 与初始四维动量 $P_{init}^\\mu$ 进行比较。\n\n实现将表明，对于所有测试用例，守恒定律都成立，因为运动学构造是精确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef spherical_to_cartesian(r, theta, phi):\n    \"\"\"Converts spherical coordinates to a Cartesian 3-vector.\"\"\"\n    x = r * np.sin(theta) * np.cos(phi)\n    y = r * np.sin(theta) * np.sin(phi)\n    z = r * np.cos(theta)\n    return np.array([x, y, z])\n\ndef kallen_lambda(a, b, c):\n    \"\"\"Calculates the Källén function lambda(a, b, c).\"\"\"\n    return a**2 + b**2 + c**2 - 2*a*b - 2*a*c - 2*b*c\n\ndef lorentz_boost(p_prime, beta_vec):\n    \"\"\"\n    Boosts a 4-vector p_prime from a frame moving with velocity beta_vec.\n    p_prime: 4-vector (E', p'_x, p'_y, p'_z) in the moving frame.\n    beta_vec: 3-vector velocity of the moving frame relative to the lab frame.\n    Returns: Boosted 4-vector (E, p_x, p_y, p_z) in the lab frame.\n    \"\"\"\n    beta_sq = np.dot(beta_vec, beta_vec)\n    if beta_sq >= 1.0:\n        raise ValueError(\"Velocity must be less than the speed of light (c=1).\")\n    if beta_sq  1e-16:\n        return p_prime\n\n    beta = np.sqrt(beta_sq)\n    gamma = 1.0 / np.sqrt(1.0 - beta_sq)\n    beta_hat = beta_vec / beta\n\n    E_prime = p_prime[0]\n    p_prime_vec = p_prime[1:]\n\n    p_prime_parallel_mag = np.dot(p_prime_vec, beta_hat)\n    p_prime_parallel = p_prime_parallel_mag * beta_hat\n    p_prime_perp = p_prime_vec - p_prime_parallel\n\n    p_parallel_mag_boosted = gamma * (p_prime_parallel_mag + beta * E_prime)\n    p_parallel_boosted = p_parallel_mag_boosted * beta_hat\n    E_boosted = gamma * (E_prime + beta * p_prime_parallel_mag)\n\n    p_vec_boosted = p_parallel_boosted + p_prime_perp\n\n    return np.array([E_boosted, p_vec_boosted[0], p_vec_boosted[1], p_vec_boosted[2]])\n\ndef get_orthogonal_unit_vector(v):\n    \"\"\"Computes a unit vector that is orthogonal to the input 3-vector v.\"\"\"\n    v_norm = np.linalg.norm(v)\n    if v_norm  1e-12:\n        return np.array([1.0, 0.0, 0.0])\n    v_unit = v / v_norm\n\n    if np.abs(v_unit[2]) > 0.9: \n        fixed_vec = np.array([1.0, 0.0, 0.0])\n    else:\n        fixed_vec = np.array([0.0, 0.0, 1.0])\n    \n    ortho_vec = np.cross(v_unit, fixed_vec)\n    return ortho_vec / np.linalg.norm(ortho_vec)\n\ndef solve_angular_ordered(M, m1, m2, theta1, phi1, theta2, phi2, tol):\n    \"\"\"Solution for the angular-ordered branching case.\"\"\"\n    p_initial = np.array([M, 0.0, 0.0, 0.0])\n    \n    if M = m1 + m2: return False\n    lambda_val = kallen_lambda(M**2, m1**2, m2**2)\n    if lambda_val  0: return False\n    p_star = np.sqrt(lambda_val) / (2 * M)\n\n    E1 = (M**2 + m1**2 - m2**2) / (2 * M)\n    E2 = (M**2 + m2**2 - m1**2) / (2 * M)\n\n    n1_vec = spherical_to_cartesian(1.0, theta1, phi1)\n    p1 = np.concatenate(([E1], p_star * n1_vec))\n    p2 = np.concatenate(([E2], -p_star * n1_vec))\n\n    final_momenta = [p2]\n\n    if m1  1e-12:\n        final_momenta.append(p1)\n    else:\n        p_prime = m1 / 2.0\n        E_prime_daughter = m1 / 2.0\n\n        n2_vec = spherical_to_cartesian(1.0, theta2, phi2)\n        p11_prime = np.concatenate(([E_prime_daughter], p_prime * n2_vec))\n        p12_prime = np.concatenate(([E_prime_daughter], -p_prime * n2_vec))\n    \n        beta_vec_p1 = p1[1:] / p1[0]\n        p11 = lorentz_boost(p11_prime, beta_vec_p1)\n        p12 = lorentz_boost(p12_prime, beta_vec_p1)\n\n        final_momenta.append(p11)\n        final_momenta.append(p12)\n\n    p_final = np.sum(final_momenta, axis=0)\n    return np.all(np.abs(p_final - p_initial)  tol)\n\ndef solve_dipole_recoil(Q, k_mag, theta_k, phi_k, tol):\n    \"\"\"Solution for the dipole recoil mapping case.\"\"\"\n    p_initial = np.array([Q, 0.0, 0.0, 0.0])\n\n    k_vec = spherical_to_cartesian(k_mag, theta_k, phi_k)\n    k_hat = k_vec / k_mag if k_mag > 0 else np.array([0., 0., 0.])\n    p_k = np.concatenate(([k_mag], k_vec))\n\n    if Q - k_mag = 0 or k_mag >= Q - k_mag: return False\n    \n    E = (Q - k_mag) / 2.0\n    cos_alpha = k_mag / (Q - k_mag)\n    sin_alpha = np.sqrt(1.0 - cos_alpha**2)\n\n    u_hat = get_orthogonal_unit_vector(k_hat)\n    \n    n1_hat = -cos_alpha * k_hat + sin_alpha * u_hat\n    n2_hat = -cos_alpha * k_hat - sin_alpha * u_hat\n    \n    p1 = np.concatenate(([E], E * n1_hat))\n    p2 = np.concatenate(([E], E * n2_hat))\n\n    p_final = p_k + p1 + p2\n    return np.all(np.abs(p_final - p_initial)  tol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    angular_cases = [\n        (100, 20, 0, 0.6, 1.0, 0.3, 0.4),\n        (50, 49, 0, 0.2, 2.2, 0.1, 1.7),\n        (80, 10, 0, 0.000001, 0.0, 0.0000005, 1.1),\n    ]\n    dipole_cases = [\n        (100, 20, 1.0, 2.4),\n        (100, 1.0, 0.8, 0.5),\n        (100, 49.999, 2.0, 0.1),\n    ]\n\n    tolerance = 1e-9\n    results = []\n\n    for case in angular_cases:\n        result = solve_angular_ordered(*case, tol=tolerance)\n        results.append(result)\n\n    for case in dipole_cases:\n        result = solve_dipole_recoil(*case, tol=tolerance)\n        results.append(result)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3527678"}, {"introduction": "在掌握了基本的运动学构建后，我们需要深入一个现代偶极子（dipole）运动学映射的技术细节。这个练习的目标是将抽象的簇射变量（如动量份额 $z$ 和横向动量 $p_T$）转化为一组物理上有效、且处于壳（on-shell）的末态粒子动量。这个练习 [@problem_id:3527734] 不仅要求你推导保证映射物理有效性的条件，还需要你测试其数值稳定性，这是编写真实科研级软件时至关重要的一环。", "problem": "末态类时部分子簇射可以使用偶极子图像 (dipole picture) 来建模，其中两个出射的无质量部分子（四动量记为 $p_i$ 和 $p_j$）形成一个色关联偶极子，其不变质量平方为 $s = (p_i + p_j)^2$。一次共线辐射表示为辐射体 $i$ 分裂成两个无质量的子部分子，其四动量分别为 $p_a$ 和 $p_b$，而旁观部分子 $j$ 反冲到一个新的四动量 $p_j'$，以保证总四动量守恒，并且所有出射部分子都保持在各自的质量壳上。该分裂由一个能量分配变量 $z \\in (0,1)$ 和一个相对于偶极子轴定义的横动量标度 $p_T^2 \\ge 0$ 来参数化。该映射必须是精确的，即它在闵可夫斯基空间中是代数上一致的，并避免任何出射部分子的四动量为类空，同时确保能量为非负值。\n\n从计算高能物理适用的第一性原理出发，即：\n- 对于一个四动量为 $p$、质量为 $m$ 的粒子，其在壳条件为 $p^2 = m^2$，其中 $p^2 = p^\\mu p_\\mu$ 使用符号为 $(+,-,-,-)$ 的闵可夫斯基度规计算。\n- 对于无质量部分子，条件为 $p^2 = 0$。\n- 四动量守恒要求 $p_i + p_j = p_a + p_b + p_j'$。\n- 物理动量必须具有非负的能量分量，$p^0 \\ge 0$。\n\n你的任务是：\n1. 仅从这些原理出发，推导出关于运动学映射参数的条件，确保对于任意 $z \\in (0,1)$ 和 $p_T^2 \\ge 0$，$p_a^2 = p_b^2 = p_j'^2 = 0$，$p_a^0 \\ge 0$，$p_b^0 \\ge 0$，$p_j'^0 \\ge 0$ 以及 $p_i + p_j = p_a + p_b + p_j'$ 这些条件同时满足。用 $z$、$p_T^2$ 和 $s$ 明确表达你的条件。\n2. 实现一个程序，在偶极子质心系中构造一个与所推导条件一致的偶极子运动学映射。在此参考系中，使用 $p_i = (\\sqrt{s}/2, 0, 0, \\sqrt{s}/2)$ 和 $p_j = (\\sqrt{s}/2, 0, 0, -\\sqrt{s}/2)$，两者均为无质量且背对背。使用一个横向四动量 $k_T = (0, \\sqrt{p_T^2}, 0, 0)$，它与 $p_i$ 和 $p_j$ 都正交且满足 $k_T^2 = -p_T^2$。用 $p_i$、$p_j$、$z$、$p_T^2$ 和 $k_T$ 构造 $p_a$、$p_b$ 和 $p_j'$，以满足精确的动量守恒和在壳条件。\n3. 通过检查每个测试用例的以下内容，在极端能量分配极限 $z \\to 0$ 和 $z \\to 1$ 以及典型和边界构型下，测试偶极子映射的数值稳定性和物理有效性：\n   - 在壳性：$|p_a^2|$、$|p_b^2|$ 和 $|p_j'^2|$ 各自小于一个与 $s$ 成正比的容差，具体为 $\\epsilon_{\\text{mass}} = 10^{-12} \\, s$。\n   - 能量非负性：$p_a^0 \\ge -\\epsilon_E$，$p_b^0 \\ge -\\epsilon_E$，$p_j'^0 \\ge -\\epsilon_E$，其中 $\\epsilon_E = 10^{-12} \\, \\sqrt{s}$。\n   - 在数值容差范围内的精确四动量守恒：$\\|p_i + p_j - (p_a + p_b + p_j')\\|_2 \\le \\epsilon_{\\text{mom}}$，其中 $\\epsilon_{\\text{mom}} = 10^{-12} \\, \\sqrt{s}$。\n\n量 $s$ 和 $p_T^2$ 必须以 $\\mathrm{GeV}^2$ 为单位表示，能量以 $\\mathrm{GeV}$ 为单位，程序必须通过横向构造隐式地处理所有角度，而不引入任何角度变量。输出应为无单位的布尔值。\n\n使用以下测试套件，该套件旨在探测典型、边界和极端条件：\n- 情况 1 (典型内部)：$s = 10^{4}$，$z = 0.5$，$p_T^2 = 0.5 \\, s \\, z (1 - z)$。\n- 情况 2 (接近边界下方)：$s = 10^{4}$，$z = 0.5$，$p_T^2 = s \\, z (1 - z) - 10^{-5}$。\n- 情况 3 (精确边界)：$s = 10^{4}$，$z = 0.5$，$p_T^2 = s \\, z (1 - z)$。\n- 情况 4 (边界上方无效)：$s = 10^{4}$，$z = 0.5$，$p_T^2 = 1.01 \\, s \\, z (1 - z)$。\n- 情况 5 (极端 $z \\to 0$)：$s = 10^{4}$，$z = 10^{-12}$，$p_T^2 = 0.9 \\, s \\, z (1 - z)$。\n- 情况 6 (极端 $z \\to 1$)：$s = 10^{4}$，$z = 1 - 10^{-12}$，$p_T^2 = 0.9 \\, s \\, z (1 - z)$。\n- 情况 7 (大标度)：$s = 10^{8}$，$z = 0.5$，$p_T^2 = 0.1 \\, s \\, z (1 - z)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[result1,result2,result3]`），每个条目都是一个布尔值，指示该测试用例的运动学映射是否通过了所有检查。", "solution": "这个问题旨在推导偶极子部分子簇射分裂的运动学约束，并实现和测试一个相应的运动学映射。该过程涉及一对色关联的无质量部分子，即辐射体 $i$ 和旁观者 $j$，它们经历一次分裂 $i \\to a+b$，同时由旁观者 $j \\to j'$ 承担反冲。这必须以尊重基本物理原理的方式完成：四动量守恒和所有末态无质量粒子的在壳条件，以及能量非负的要求。\n\n我们首先从第一性原理出发，正式推导运动学参数（即能量分配分数 $z$ 和横动量平方 $p_T^2$）的约束条件。\n\n### 第1部分：运动学条件的推导\n\n给定初始态有两个无质量部分子 $p_i$ 和 $p_j$，满足 $p_i^2=0$ 和 $p_j^2=0$。它们的总不变质量平方为 $s=(p_i+p_j)^2 = p_i^2 + p_j^2 + 2p_i \\cdot p_j = 2p_i \\cdot p_j$。末态由三个无质量部分子 $p_a$、$p_b$ 和 $p_j'$ 组成，它们必须满足 $p_a^2=0$、$p_b^2=0$ 和 $p_j'^2=0$。该过程遵守四动量守恒：$p_i+p_j = p_a+p_b+p_j'$。\n\n为了构造末态动量，我们需要一个用初始动量 $p_i, p_j$ 和运动学变量 $z, p_T^2$ 表示的参数化形式。对于分裂 $i \\to a+b$，一个通用且有物理动机的拟设是，将子部分子的动量表示为母部分子动量 $p_i$、一个横向分量 $k_T$ 和一个与另一偶极子腿 $p_j$ 成比例的修正项的组合，以维持在壳条件。我们定义一个横向四动量 $k_T$，它满足 $k_T \\cdot p_i = 0$、$k_T \\cdot p_j = 0$ 和 $k_T^2=-p_T^2$。提议的参数化形式是：\n$$p_a = z p_i + \\alpha p_j + k_T$$\n$$p_b = (1-z) p_i + \\beta p_j - k_T$$\n这里，$z$ 代表在共线极限下（$p_T^2 \\to 0$）部分子 $a$ 的能量分数。系数 $\\alpha$ 和 $\\beta$ 是待定未知数，将由在壳条件确定。\n\n接下来，我们施加在壳条件 $p_a^2=0$：\n$$p_a^2 = (z p_i + \\alpha p_j + k_T)^2 = z^2 p_i^2 + \\alpha^2 p_j^2 + k_T^2 + 2z\\alpha (p_i \\cdot p_j) + 2z (p_i \\cdot k_T) + 2\\alpha (p_j \\cdot k_T) = 0$$\n利用已知性质 $p_i^2=0$、$p_j^2=0$、$k_T^2=-p_T^2$、$p_i \\cdot k_T=0$、$p_j \\cdot k_T=0$ 以及 $p_i \\cdot p_j = s/2$，方程显著简化：\n$$0 + 0 - p_T^2 + 2z\\alpha (s/2) + 0 + 0 = 0$$\n$$- p_T^2 + z\\alpha s = 0$$\n解出 $\\alpha$ 得：\n$$\\alpha = \\frac{p_T^2}{zs}$$\n\n类似地，我们施加在壳条件 $p_b^2=0$：\n$$p_b^2 = ((1-z)p_i + \\beta p_j - k_T)^2 = (1-z)^2 p_i^2 + \\beta^2 p_j^2 + k_T^2 + 2(1-z)\\beta (p_i \\cdot p_j) - 2(1-z) (p_i \\cdot k_T) - 2\\beta (p_j \\cdot k_T) = 0$$\n这简化为：\n$$-p_T^2 + (1-z)\\beta s = 0$$\n解出 $\\beta$ 得：\n$$\\beta = \\frac{p_T^2}{(1-z)s}$$\n\n确定 $\\alpha$ 和 $\\beta$ 后，$p_a$ 和 $p_b$ 的动量就完全确定了：\n$$p_a = z p_i + \\frac{p_T^2}{zs} p_j + k_T$$\n$$p_b = (1-z) p_i + \\frac{p_T^2}{(1-z)s} p_j - k_T$$\n\n现在，我们利用四动量守恒来确定反冲后的旁观者动量 $p_j'$：\n$$p_j' = p_i + p_j - (p_a + p_b)$$\n代入 $p_a$ 和 $p_b$ 的表达式：\n$$p_j' = p_i + p_j - \\left( \\left(z p_i + \\frac{p_T^2}{zs} p_j + k_T\\right) + \\left((1-z) p_i + \\frac{p_T^2}{(1-z)s} p_j - k_T\\right) \\right)$$\n$$p_j' = p_i + p_j - \\left( (z+1-z)p_i + \\left(\\frac{p_T^2}{zs} + \\frac{p_T^2}{(1-z)s}\\right)p_j \\right)$$\n$$p_j' = p_i + p_j - p_i - \\frac{p_T^2}{s}\\left(\\frac{1}{z} + \\frac{1}{1-z}\\right)p_j$$\n$$p_j' = p_j - \\frac{p_T^2}{s}\\left(\\frac{1-z+z}{z(1-z)}\\right)p_j$$\n$$p_j' = \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right) p_j$$\n这个关于反冲旁观者动量的形式非常简洁，它确保了其在壳条件 $p_j'^2=0$ 自动满足，因为 $p_j'^2 = (\\text{标量因子})^2 p_j^2$ 且 $p_j^2=0$。\n\n最后，我们必须强制所有末态粒子具有非负能量（$p^0 \\ge 0$）的条件。我们在指定的偶极子质心系中计算能量分量：\n$$p_i = (\\sqrt{s}/2, 0, 0, \\sqrt{s}/2)$$\n$$p_j = (\\sqrt{s}/2, 0, 0, -\\sqrt{s}/2)$$\n$$k_T = (0, \\sqrt{p_T^2}, 0, 0)$$\n能量分量为：\n$$p_a^0 = z p_i^0 + \\frac{p_T^2}{zs} p_j^0 + k_T^0 = z \\frac{\\sqrt{s}}{2} + \\frac{p_T^2}{zs} \\frac{\\sqrt{s}}{2} + 0 = \\frac{\\sqrt{s}}{2} \\left( z + \\frac{p_T^2}{zs} \\right)$$\n$$p_b^0 = (1-z) p_i^0 + \\frac{p_T^2}{(1-z)s} p_j^0 - k_T^0 = (1-z) \\frac{\\sqrt{s}}{2} + \\frac{p_T^2}{(1-z)s} \\frac{\\sqrt{s}}{2} - 0 = \\frac{\\sqrt{s}}{2} \\left( 1-z + \\frac{p_T^2}{(1-z)s} \\right)$$\n$$p_j'^0 = \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right) p_j^0 = \\frac{\\sqrt{s}}{2} \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right)$$\n鉴于 $s>0$，$z \\in (0,1)$，以及 $p_T^2 \\ge 0$，对于 $p_a^0$ 和 $p_b^0$ 的表达式显然是非负项之和，因此是非负的。唯一非平凡的约束来自于要求 $p_j'^0 \\ge 0$：\n$$\\frac{\\sqrt{s}}{2} \\left( 1 - \\frac{p_T^2}{s z(1-z)} \\right) \\ge 0$$\n因为 $\\sqrt{s}/2 > 0$，这意味着：\n$$1 - \\frac{p_T^2}{s z(1-z)} \\ge 0$$\n$$\\implies p_T^2 \\le s z(1-z)$$\n\n综上所述，对于一个具有参数 $z \\in (0,1)$ 和 $p_T^2 \\ge 0$ 的物理上有效的运动学映射，必须满足以下条件：\n$$0 \\le p_T^2 \\le s z(1-z)$$\n这定义了辐射可及的相空间。\n\n### 第2部分：实现与测试\n程序将实现所推导的运动学映射，并对其进行问题陈述中指定的一系列测试。一个函数将根据输入参数 $s, z, p_T^2$ 构造末态四动量 $p_a, p_b, p_j'$。然后，将在指定的数值容差内，对这些动量进行三个标准的验证：在壳性、非负能量和四动量守恒。每个测试用例的这些检查结果将决定最终的布尔值输出。情况4中，$p_T^2 > s z(1-z)$，预计会未通过 $p_j'$ 的能量非负性测试，从而证实我们推导的边界的有效性。所有其他情况都被构造为处于物理相空间内部或边界上，预计将通过检查，从而测试实现的数值稳定性，特别是在软极限 ($z \\to 0$) 和共线极限 ($z \\to 1$) 下。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the dipole kinematic map tests.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: typical interior\n        {'s': 1e4, 'z': 0.5, 'pT2': 0.5 * 1e4 * 0.5 * (1 - 0.5)},\n        # Case 2: near-boundary below\n        {'s': 1e4, 'z': 0.5, 'pT2': 1e4 * 0.5 * (1 - 0.5) - 1e-5},\n        # Case 3: exact boundary\n        {'s': 1e4, 'z': 0.5, 'pT2': 1e4 * 0.5 * (1 - 0.5)},\n        # Case 4: above-boundary invalid\n        {'s': 1e4, 'z': 0.5, 'pT2': 1.01 * 1e4 * 0.5 * (1 - 0.5)},\n        # Case 5: extreme z -> 0\n        {'s': 1e4, 'z': 1e-12, 'pT2': 0.9 * 1e4 * 1e-12 * (1 - 1e-12)},\n        # Case 6: extreme z -> 1\n        {'s': 1e4, 'z': 1.0 - 1e-12, 'pT2': 0.9 * 1e4 * (1.0 - 1e-12) * (1 - (1.0 - 1e-12))},\n        # Case 7: large scale\n        {'s': 1e8, 'z': 0.5, 'pT2': 0.1 * 1e8 * 0.5 * (1 - 0.5)},\n    ]\n\n    results = []\n    for case in test_cases:\n        s, z, pT2 = case['s'], case['z'], case['pT2']\n        \n        # Perform the kinematic test for the current case\n        passed = test_kinematic_map(s, z, pT2)\n        results.append(passed)\n\n    # Format and print the final output as a single-line string.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef dot_product(p1, p2):\n    \"\"\"\n    Computes the Minkowski dot product of two four-vectors.\n    Metric signature is (+, -, -, -).\n    \"\"\"\n    return p1[0] * p2[0] - p1[1] * p2[1] - p1[2] * p2[2] - p1[3] * p2[3]\n\ndef mass_sq(p):\n    \"\"\"Computes the squared invariant mass of a four-vector.\"\"\"\n    return dot_product(p, p)\n\ndef construct_kinematic_map(s, z, pT2):\n    \"\"\"\n    Constructs the final-state four-momenta for a dipole splitting.\n    \n    Args:\n        s (float): Invariant mass squared of the dipole.\n        z (float): Energy sharing fraction.\n        pT2 (float): Transverse momentum squared of the emission.\n        \n    Returns:\n        tuple: A tuple containing the four-momenta of the initial state (p_i, p_j)\n               and final state (p_a, p_b, p_j_prime).\n    \"\"\"\n    sqrt_s = np.sqrt(s)\n    E_cm_half = sqrt_s / 2.0\n    \n    # Define initial state momenta in the CM frame\n    p_i = np.array([E_cm_half, 0.0, 0.0, E_cm_half])\n    p_j = np.array([E_cm_half, 0.0, 0.0, -E_cm_half])\n    \n    # Define the transverse vector. Handle pT2  0 case for safety, though not expected by givens.\n    pT = np.sqrt(max(0, pT2))\n    k_T = np.array([0.0, pT, 0.0, 0.0])\n\n    # Calculate coefficients for the kinematic map based on the derivation\n    alpha = pT2 / (z * s)\n    beta = pT2 / ((1.0 - z) * s)\n    \n    # Construct final state momenta\n    p_a = z * p_i + alpha * p_j + k_T\n    p_b = (1.0 - z) * p_i + beta * p_j - k_T\n    \n    # The recoil factor for p_j' can lead to precision loss if pT2 is very close\n    # to the kinematic limit. Reconstructing from conservation is more robust for tests.\n    p_j_prime_reco = p_i + p_j - (p_a + p_b)\n\n    return p_i, p_j, p_a, p_b, p_j_prime_reco\n\n\ndef test_kinematic_map(s, z, pT2):\n    \"\"\"\n    Tests the physical validity of the kinematic map for a given set of parameters.\n    \n    Args:\n        s (float): Invariant mass squared of the dipole.\n        z (float): Energy sharing fraction.\n        pT2 (float): Transverse momentum squared of the emission.\n        \n    Returns:\n        bool: True if all checks pass, False otherwise.\n    \"\"\"\n    sqrt_s = np.sqrt(s)\n\n    # Define numerical tolerances\n    eps_mass = 1e-12 * s\n    eps_E = 1e-12 * sqrt_s\n    eps_mom = 1e-12 * sqrt_s\n    \n    # The derived condition for physical kinematics\n    kinematic_limit = s * z * (1 - z)\n    \n    # If pT2 is clearly unphysical, fail early. This is primarily for the energy check.\n    # The code must still be able to handle this case numerically.\n    # Note: pT2 can be slightly above the limit due to float precision issues\n    # in the test case definitions. The energy check is the ultimate arbiter.\n    \n    # Construct the momenta\n    p_i, p_j, p_a, p_b, p_j_prime = construct_kinematic_map(s, z, pT2)\n\n    # 1. On-shellness check\n    # Check that final state particles are on their mass shell (m=0)\n    check_a_mass = np.abs(mass_sq(p_a))  eps_mass\n    check_b_mass = np.abs(mass_sq(p_b))  eps_mass\n    check_j_mass = np.abs(mass_sq(p_j_prime))  eps_mass\n    \n    # 2. Energy non-negativity check\n    # The tolerance eps_E allows for small negative values from floating-point errors.\n    check_a_E = p_a[0] >= -eps_E\n    check_b_E = p_b[0] >= -eps_E\n    check_j_E = p_j_prime[0] >= -eps_E\n    \n    # 3. Four-momentum conservation check\n    p_initial = p_i + p_j\n    p_final = p_a + p_b + p_j_prime\n    mom_diff_vec = p_initial - p_final\n    # The problem specifies the L2 norm of the difference 4-vector.\n    check_mom_cons = np.linalg.norm(mom_diff_vec) = eps_mom\n\n    # The case passes only if all checks are satisfied\n    all_checks_passed = all([\n        check_a_mass, check_b_mass, check_j_mass,\n        check_a_E, check_b_E, check_j_E,\n        check_mom_cons\n    ])\n    \n    # Un-comment the following block to debug individual checks for a failing case.\n    # if not all_checks_passed:\n    #     print(f\"\\n--- FAILED CASE: s={s}, z={z}, pT2={pT2} ---\")\n    #     print(f\"pT2_limit = {kinematic_limit}\")\n    #     print(f\"Mass checks (a, b, j'): {check_a_mass}, {check_b_mass}, {check_j_mass}\")\n    #     print(f\"  Values: p_a^2={mass_sq(p_a)}, p_b^2={mass_sq(p_b)}, p_j'^2={mass_sq(p_j_prime)}\")\n    #     print(f\"Energy checks (a, b, j'): {check_a_E}, {check_b_E}, {check_j_E}\")\n    #     print(f\"  Values: E_a={p_a[0]}, E_b={p_b[0]}, E_j'={p_j_prime[0]}\")\n    #     print(f\"Momentum conservation check: {check_mom_cons}\")\n    #     print(f\"  Value: ||diff|| = {np.linalg.norm(mom_diff_vec)}\")\n    #     print(f\"Tolerances: eps_mass={eps_mass}, eps_E={eps_E}, eps_mom={eps_mom}\")\n    \n    return all_checks_passed\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3527734"}, {"introduction": "我们已经知道如何为*单次*发射构建运动学，但下一个问题是：发射*何时*发生，以及它*是否*发生？这由量子力学概率决定，并由所谓的 Sudakov 形状因子（Sudakov form factor）描述。这个练习 [@problem_id:3527761] 探索了否决算法（veto algorithm）——所有现代部分子簇射生成器的核心引擎——展示了这种巧妙的蒙特卡洛方法如何高效地模拟正确的发射概率，并让你能够将其性质与解析结果进行直接的数值验证。", "problem": "考虑一个马尔可夫部分子簇射中的单个类时部分子演化变量 $t$，它从一个初始尺度 $t_0$ 向下演化至一个截断尺度 $t_{\\min}$。其基本原理是将辐射表示为一个沿着有序演化的非齐次泊松过程，其瞬时强度（风险率）为 $\\lambda_{\\text{true}}(t)$。无辐射概率，也称为 Sudakov 形状因子，由标准公式定义：\n$$\n\\Delta(t) = \\exp\\!\\left(-\\int_{t}^{t_0} \\lambda_{\\text{true}}(t')\\, dt'\\right),\n$$\n该公式表示在区间 $[t, t_0]$ 内，非齐次泊松过程的点数为零的概率。\n\n在部分子簇射蒙特卡洛中使用的否决算法中，引入一个过高估计强度 $\\lambda_{\\text{over}}(t)$，使得对于所有 $t \\in [t_{\\min}, t_0]$，都有 $\\lambda_{\\text{true}}(t) \\le \\lambda_{\\text{over}}(t)$，并根据 $\\lambda_{\\text{over}}(t)$ 生成提议点。每个在尺度 $t_i$ 的提议以概率 $p(t_i) = \\lambda_{\\text{true}}(t_i)/\\lambda_{\\text{over}}(t_i)$ 被接受，否则被否决（拒绝）。被接受的提议定义了筛选后的点过程，该过程复现了真实的辐射分布。\n\n你的任务是：\n\n1. 从 Sudakov 形状因子的定义出发，推导特定真实强度\n$$\n\\lambda_{\\text{true}}(t) = \\frac{A + B\\, t}{t}\n$$\n下的 $\\Delta(t_{\\min})$，其中 $A \\ge 0$ 和 $B \\ge 0$ 为固定实数参数，适用范围为 $t \\in [t_{\\min}, t_0]$。用 $A$、$B$、$t_0$ 和 $t_{\\min}$ 表示你最终的 $\\Delta(t_{\\min})$ 公式。\n\n2. 使用带有过高估计强度\n$$\n\\lambda_{\\text{over}}(t) = \\frac{C_{\\text{over}}}{t}\n$$\n的否决算法的筛选表示，推导 $\\Delta(t_{\\min})$ 的两个无偏蒙特卡洛估计量：\n   - 一个拒绝乘积估计量，\n     $$\n     \\hat{\\Delta}_{\\Pi} = \\left\\langle \\prod_{i=1}^{N_{\\text{prop}}} \\bigl(1 - p(t_i)\\bigr) \\right\\rangle,\n     $$\n     其中 $t_i$ 是在 $[t_{\\min}, t_0]$ 内根据 $\\lambda_{\\text{over}}(t)$ 生成的提议尺度，$p(t_i) = \\lambda_{\\text{true}}(t_i)/\\lambda_{\\text{over}}(t_i)$，$N_{\\text{prop}}$ 是在该区间内生成的提议的（随机）数量。\n   - 一个零接受指示函数估计量，\n     $$\n     \\hat{\\Delta}_0 = \\left\\langle \\mathbb{I}\\{N_{\\text{acc}} = 0\\} \\right\\rangle,\n     $$\n     其中 $N_{\\text{acc}}$ 是在 $[t_{\\min}, t_0]$ 内通过接受概率为 $p(t_i)$ 的筛选后接受的提议数量，$\\mathbb{I}\\{\\cdot\\}$ 是指示函数。\n\n3. 实现一个完整的、可运行的程序，该程序：\n   - 通过使用统计上正确的方法，从 $t_0$ 向下到 $t_{\\min}$ 根据 $\\lambda_{\\text{over}}(t)$ 生成提议尺度 $t_i$，为每个测试用例模拟 $N$ 个独立的演化区间。为保证数值稳定性，你可以将演化变量重新参数化为 $u = \\ln t$，并注意在 $u$ 中的提议生成是齐次的。\n   - 对于每个演化区间，计算乘积 $\\prod_i (1 - p(t_i))$ 和零接受指示函数 $\\mathbb{I}\\{N_{\\text{acc}} = 0\\}$，其中 $p(t_i) = \\min\\!\\left( \\frac{A + B\\, t_i}{C_{\\text{over}}},\\, 1 \\right)$。\n   - 通过样本方差，估计在 $N$ 个区间上 $\\hat{\\Delta}_{\\Pi}$ 和 $\\hat{\\Delta}_0$ 的样本均值和样本均值的标准误（样本均值的标准差）。\n   - 将每个估计量与第 1 部分的解析 $\\Delta(t_{\\min})$ 进行比较，并报告其绝对差是否小于或等于其估计的样本均值标准误的 $3$ 倍。对于每个测试用例，生成两个布尔结果：一个用于 $\\hat{\\Delta}_{\\Pi}$，一个用于 $\\hat{\\Delta}_0$。\n   - 使用以下测试套件，它涵盖了常数强度情况、一个饱和过高估计的 $t$ 依赖强度情况，以及一个真实强度为零的边界情况：\n     - 情况 1：$t_0 = 1.0$, $t_{\\min} = 10^{-3}$, $A = 0.5$, $B = 0.0$, $C_{\\text{over}} = 1.0$, $N = 100000$。\n     - 情况 2：$t_0 = 1.0$, $t_{\\min} = 10^{-3}$, $A = 0.4$, $B = 0.5$, $C_{\\text{over}} = 0.9$, $N = 120000$。\n     - 情况 3：$t_0 = 10^{-2}$, $t_{\\min} = 10^{-3}$, $A = 0.0$, $B = 0.0$, $C_{\\text{over}} = 0.3$, $N = 80000$。\n\n4. 最终输出格式规范：\n   - 你的程序应生成单行输出，其中包含六个布尔结果，格式为逗号分隔的列表并用方括号括起，顺序如下：\n     $$\n     [\\text{Case1-}\\hat{\\Delta}_{\\Pi},\\, \\text{Case1-}\\hat{\\Delta}_0,\\, \\text{Case2-}\\hat{\\Delta}_{\\Pi},\\, \\text{Case2-}\\hat{\\Delta}_0,\\, \\text{Case3-}\\hat{\\Delta}_{\\Pi},\\, \\text{Case3-}\\hat{\\Delta}_0].\n     $$\n\n本问题不涉及角度、物理单位和百分比。所有量都是无量纲的。每个布尔值的验证标准是 $\\left|\\hat{\\Delta} - \\Delta(t_{\\min})\\right| \\le 3\\, \\sigma_{\\hat{\\Delta}}$ 是否成立，其中 $\\sigma_{\\hat{\\Delta}}$ 是相应蒙特卡洛估计量的估计样本均值标准误。程序必须是自包含的，不需要任何输入，并遵守指定的运行时环境。", "solution": "该问题提法明确，科学上可靠，且内部一致。我们接下来进行求解，求解过程包括三个部分：解析推导、蒙特卡洛估计量的理论证明，以及用于验证结果的数值实现。\n\n该问题围绕类时部分子演化的模拟展开，该演化被建模为在演化变量 $t \\in [t_{\\min}, t_0]$ 上的一个非齐次泊松过程。此过程的瞬时速率由 $\\lambda_{\\text{true}}(t)$ 给出。在初始尺度 $t_0$ 和一个更低的尺度 $t$ 之间不发生辐射的概率即为 Sudakov 形状因子 $\\Delta(t)$。\n\n**第一部分：Sudakov 形状因子的解析计算**\n\nSudakov 形状因子定义为：\n$$\n\\Delta(t) = \\exp\\left(-\\int_{t}^{t_0} \\lambda_{\\text{true}}(t')\\, dt'\\right)\n$$\n我们需要计算特定真实强度函数下的 $\\Delta(t_{\\min})$：\n$$\n\\lambda_{\\text{true}}(t) = \\frac{A + B\\, t}{t}\n$$\n其中 $A \\ge 0$ 和 $B \\ge 0$ 是常数。\n\n首先，我们计算指数中的定积分，记为 $I$：\n$$\nI = \\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t')\\, dt' = \\int_{t_{\\min}}^{t_0} \\frac{A + B\\, t'}{t'}\\, dt'\n$$\n被积函数可以分为两项：\n$$\nI = \\int_{t_{\\min}}^{t_0} \\left( \\frac{A}{t'} + B \\right) dt'\n$$\n进行积分得到：\n$$\nI = \\left[ A \\ln|t'| + B t' \\right]_{t_{\\min}}^{t_0}\n$$\n由于演化变量 $t$ 是正数（$t_{\\min} > 0$），我们可以去掉绝对值符号：\n$$\nI = (A \\ln(t_0) + B t_0) - (A \\ln(t_{\\min}) + B t_{\\min})\n$$\n按常数 $A$ 和 $B$ 分组：\n$$\nI = A (\\ln(t_0) - \\ln(t_{\\min})) + B (t_0 - t_{\\min})\n$$\n使用对数性质 $\\ln(x) - \\ln(y) = \\ln(x/y)$，我们得到：\n$$\nI = A \\ln\\left(\\frac{t_0}{t_{\\min}}\\right) + B (t_0 - t_{\\min})\n$$\n将此积分代回 Sudakov 形状因子的定义，得到 $\\Delta(t_{\\min})$ 的最终解析表达式：\n$$\n\\Delta(t_{\\min}) = \\exp(-I) = \\exp\\left( -A \\ln\\left(\\frac{t_0}{t_{\\min}}\\right) - B (t_0 - t_{\\min}) \\right)\n$$\n该公式也可以写成以下形式：\n$$\n\\Delta(t_{\\min}) = \\left(\\frac{t_0}{t_{\\min}}\\right)^{-A} \\exp(-B (t_0 - t_{\\min}))\n$$\n\n**第二部分：无偏蒙特卡洛估计量的推导**\n\n否决算法通过对一个从更易采样的过高估计过程（强度为 $\\lambda_{\\text{over}}(t) \\ge \\lambda_{\\text{true}}(t)$）生成的提议流进行筛选，来生成强度为 $\\lambda_{\\text{true}}(t)$ 的过程的事件。筛选过程中被接受的辐射是真实泊松过程的一个点。\n\n**估计量 $\\hat{\\Delta}_0 = \\left\\langle \\mathbb{I}\\{N_{\\text{acc}} = 0\\} \\right\\rangle$ (零接受指示函数)**\n\n根据定义，$\\Delta(t_{\\min})$ 是在区间 $[t_{\\min}, t_0]$ 内真实辐射数 $N_{\\text{emissions}}$ 为零的概率。从否决算法中接受的提议数 $N_{\\text{acc}}$ 与 $N_{\\text{emissions}}$ 服从相同的分布。具体来说，$N_{\\text{acc}}$ 是一个泊松分布的随机变量，其均值为 $\\mu_{\\text{acc}} = \\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t') dt'$。\n\n观测到 $N_{\\text{acc}} = 0$ 的概率由泊松概率的零事件公式给出：\n$$\nP(N_{\\text{acc}} = 0) = \\frac{\\mu_{\\text{acc}}^0 e^{-\\mu_{\\text{acc}}}}{0!} = e^{-\\mu_{\\text{acc}}} = \\exp\\left(-\\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t') dt'\\right) = \\Delta(t_{\\min})\n$$\n指示函数 $\\mathbb{I}\\{N_{\\text{acc}} = 0\\}$ 的期望根据定义就是它所指示事件的概率：\n$$\n\\left\\langle \\mathbb{I}\\{N_{\\text{acc}} = 0\\} \\right\\rangle = P(N_{\\text{acc}} = 0) = \\Delta(t_{\\min})\n$$\n因此，$\\hat{\\Delta}_0$ 是 $\\Delta(t_{\\min})$ 的一个无偏估计量。通过对多次独立模拟的 $\\mathbb{I}\\{N_{\\text{acc}} = 0\\}$ 值取平均，可以获得一个蒙特卡洛估计值。\n\n**估计量 $\\hat{\\Delta}_{\\Pi} = \\left\\langle \\prod_{i=1}^{N_{\\text{prop}}} \\bigl(1 - p(t_i)\\bigr) \\right\\rangle$ (拒绝乘积)**\n\n这个估计量的无偏性可以用泊松点过程的性质来证明。提议尺度 $\\{t_i\\}$ 构成一个强度为 $\\lambda_{\\text{over}}(t)$ 的泊松点过程。对于任意函数 $g(t)$，在区间 $[a,b]$ 内，对于一个速率为 $\\lambda(t)$ 的泊松过程的所有点，乘积 $\\prod_i g(t_i)$ 的期望由其特征泛函给出：\n$$\n\\mathbb{E}\\left[ \\prod_{i} g(t_i) \\right] = \\exp\\left( \\int_a^b (g(t)-1) \\lambda(t) dt \\right)\n$$\n在我们的情况中，过程是 $[t_{\\min}, t_0]$ 上的提议过程，所以 $\\lambda(t) = \\lambda_{\\text{over}}(t)$。被相乘的函数是 $g(t_i) = 1 - p(t_i)$，其中 $p(t_i) = \\lambda_{\\text{true}}(t_i)/\\lambda_{\\text{over}}(t_i)$ 是接受概率。\n将这些代入公式中：\n$$\n\\hat{\\Delta}_{\\Pi} = \\mathbb{E}\\left[ \\prod_{i=1}^{N_{\\text{prop}}} \\left(1 - \\frac{\\lambda_{\\text{true}}(t_i)}{\\lambda_{\\text{over}}(t_i)}\\right) \\right]\n= \\exp\\left( \\int_{t_{\\min}}^{t_0} \\left( \\left(1 - \\frac{\\lambda_{\\text{true}}(t')}{\\lambda_{\\text{over}}(t')}\\right) - 1 \\right) \\lambda_{\\text{over}}(t') dt' \\right)\n$$\n积分内的项可以简化：\n$$\n\\left( 1 - \\frac{\\lambda_{\\text{true}}(t')}{\\lambda_{\\text{over}}(t')} - 1 \\right) \\lambda_{\\text{over}}(t') = \\left( - \\frac{\\lambda_{\\text{true}}(t')}{\\lambda_{\\text{over}}(t')} \\right) \\lambda_{\\text{over}}(t') = - \\lambda_{\\text{true}}(t')\n$$\n因此，期望变为：\n$$\n\\hat{\\Delta}_{\\Pi} = \\exp\\left( - \\int_{t_{\\min}}^{t_0} \\lambda_{\\text{true}}(t') dt' \\right) = \\Delta(t_{\\min})\n$$\n这表明 $\\hat{\\Delta}_{\\Pi}$ 也是 $\\Delta(t_{\\min})$ 的一个无偏估计量。每次模拟试验产生一个权重，这些权重在多次试验中的平均值会收敛到真实的 Sudakov 形状因子。\n\n**第三部分：蒙特卡洛模拟策略**\n\n实现将遵循推导出的原理，以数值方式估计 $\\Delta(t_{\\min})$ 并验证估计量。\n\n**提议尺度的生成：** 提议强度为 $\\lambda_{\\text{over}}(t) = C_{\\text{over}}/t$。顺序生成辐射可能效率低下。一个更有效的方法是重新参数化演化变量。令 $u = \\ln t$。从 $t_0$ 向下演化至 $t_{\\min}$ 对应于从 $u_0 = \\ln t_0$ 向下演化至 $u_{\\min} = \\ln t_{\\min}$。强度测度变换为 $d\\mu = \\lambda(t) dt$。在新变量 $u$ 中，强度变为 $\\lambda_u(u) = \\lambda_t(t(u)) |dt/du| = (C_{\\text{over}}/e^u) \\cdot e^u = C_{\\text{over}}$。\n$u$ 变量中的提议过程是在区间 $[u_{\\min}, u_0]$ 上速率为常数 $C_{\\text{over}}$ 的齐次泊松过程。这可以被高效模拟：\n1.  计算提议的平均数量：$\\mu_{\\text{prop}} = C_{\\text{over}} (u_0 - u_{\\min}) = C_{\\text{over}} \\ln(t_0/t_{\\min})$。\n2.  对于给定的试验，从均值为 $\\mu_{\\text{prop}}$ 的泊松分布中抽取实际的提议数量 $N_{\\text{prop}}$。\n3.  在区间 $[u_{\\min}, u_0]$ 内均匀生成 $N_{\\text{prop}}$ 个值 $u_i$。\n4.  转换回原始变量：$t_i = \\exp(u_i)$。\n\n**估计量的计算：** 对于 $N$ 次独立试验中的每一次：\n1.  如上所述生成一组提议尺度 $\\{t_i\\}_{i=1}^{N_{\\text{prop}}}$。\n2.  每个提议的接受概率计算为 $p(t_i) = (A + B t_i) / C_{\\text{over}}$。问题中给出的 $p(t_i) = \\min\\!\\left( \\frac{A + B\\, t_i}{C_{\\text{over}}},\\, 1 \\right)$，但由于在所有测试用例中以及对于 $t \\in [t_{\\min}, t_0]$ 都有 $A + Bt \\le C_{\\text{over}}$ 的保证，$\\min$ 操作是多余的。\n3.  试验中 $\\hat{\\Delta}_{\\Pi}$ 估计量的值为 $V_{\\Pi} = \\prod_{i=1}^{N_{\\text{prop}}} (1 - p(t_i))$。\n4.  为了得到试验中 $\\hat{\\Delta}_0$ 估计量的值，我们模拟筛选过程：对于每个提议 $t_i$，生成一个均匀随机数 $r_i \\in [0,1)$，如果 $r_i  p(t_i)$ 则接受。我们计算接受的提议总数 $N_{\\text{acc}}$。估计量的值为 $V_0 = \\mathbb{I}\\{N_{\\text{acc}}=0\\}$，即如果 $N_{\\text{acc}}=0$ 则为 $1$，否则为 $0$。\n\n**统计分析：** 经过 $N$ 次试验后，我们得到两组结果，$\\{V_{\\Pi,j}\\}_{j=1}^N$ 和 $\\{V_{0,j}\\}_{j=1}^N$。\n对于每个估计量 $\\hat{\\Delta}$（代表 $\\hat{\\Delta}_{\\Pi}$ 或 $\\hat{\\Delta}_0$），我们计算：\n- 样本均值：$\\bar{V} = \\frac{1}{N} \\sum_{j=1}^N V_j$。这是我们对 $\\Delta(t_{\\min})$ 的数值估计。\n- 样本标准差：$s = \\sqrt{\\frac{1}{N-1} \\sum_{j=1}^N (V_j - \\bar{V})^2}$。\n- 均值的样本标准误：$\\sigma_{\\bar{V}} = s / \\sqrt{N}$。\n\n最后的验证步骤是检查解析值 $\\Delta(t_{\\min})$ 是否落在估计均值的 $3$ 个标准误范围内，即 $|\\bar{V} - \\Delta(t_{\\min})| \\le 3 \\sigma_{\\bar{V}}$ 是否成立。这是一个标准的一致性统计检验，其中 $3\\sigma$ 内的结果通常被认为是兼容的。对于每个测试用例中的每个估计量，将报告一个布尔值（`True` 或 `False`）。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (t0, t_min, A, B, C_over, N)\n        (1.0, 1e-3, 0.5, 0.0, 1.0, 100000),\n        (1.0, 1e-3, 0.4, 0.5, 0.9, 120000),\n        (1e-2, 1e-3, 0.0, 0.0, 0.3, 80000),\n    ]\n\n    all_results = []\n    # A fixed seed ensures reproducibility of the Monte Carlo simulation.\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    for i, case in enumerate(test_cases):\n        t0, t_min, A, B, C_over, N = case\n        \n        # 1. Analytical Sudakov calculation\n        log_ratio = np.log(t0 / t_min)\n        t_diff = t0 - t_min\n        integral_val = A * log_ratio + B * t_diff\n        delta_analytic = np.exp(-integral_val)\n\n        # 2. Monte Carlo simulation setup\n        u0 = np.log(t0)\n        u_min = np.log(t_min)\n        # Mean number of proposals in u-space for a homogeneous Poisson process\n        mu_prop = C_over * (u0 - u_min)\n\n        pi_estimator_values = np.zeros(N)\n        zero_estimator_values = np.zeros(N)\n\n        for j in range(N):\n            # Generate number of proposals from Poisson distribution\n            N_prop = rng.poisson(mu_prop)\n\n            if N_prop == 0:\n                pi_estimator_values[j] = 1.0\n                zero_estimator_values[j] = 1.0\n            else:\n                # Generate proposal locations in u-space (uniform)\n                u_proposals = rng.uniform(u_min, u0, size=N_prop)\n                # Transform back to t-space\n                t_proposals = np.exp(u_proposals)\n                \n                # Acceptance probabilities for each proposal\n                # The min(..., 1) is not strictly needed due to problem constraints\n                # but included for robustness.\n                p_values = np.minimum((A + B * t_proposals) / C_over, 1.0)\n                \n                # Estimator 1: Product of rejections\n                pi_estimator_values[j] = np.prod(1.0 - p_values)\n                \n                # Estimator 2: Zero acceptances\n                # Perform thinning to find number of accepted proposals\n                accept_rolls = rng.uniform(0.0, 1.0, size=N_prop)\n                N_acc = np.sum(accept_rolls  p_values)\n                zero_estimator_values[j] = 1.0 if N_acc == 0 else 0.0\n        \n        # 3. Statistical analysis and verification\n        # For pi_estimator\n        mean_pi = np.mean(pi_estimator_values)\n        std_pi = np.std(pi_estimator_values, ddof=1)\n        sem_pi = std_pi / np.sqrt(N)\n        \n        # Handle the case where standard error is zero (e.g., constant results)\n        if sem_pi > 0:\n            is_valid_pi = np.abs(mean_pi - delta_analytic) = 3 * sem_pi\n        else:\n            is_valid_pi = np.isclose(mean_pi, delta_analytic)\n            \n        all_results.append(is_valid_pi)\n        \n        # For zero_estimator\n        mean_zero = np.mean(zero_estimator_values)\n        std_zero = np.std(zero_estimator_values, ddof=1)\n        sem_zero = std_zero / np.sqrt(N)\n\n        if sem_zero > 0:\n            is_valid_zero = np.abs(mean_zero - delta_analytic) = 3 * sem_zero\n        else:\n            is_valid_zero = np.isclose(mean_zero, delta_analytic)\n\n        all_results.append(is_valid_zero)\n\n    # 4. Final print statement in the exact required format\n    # The output will be like [True,True,True,True,True,True]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3527761"}]}