{"hands_on_practices": [{"introduction": "本练习为不确定度分析提供了一个基础的入门点。我们从高能物理中的一个常见情景开始：测量一个截面，其最终结果同时受到事件数统计涨落和探测器效率系统不确定度的影响。通过这个实践[@problem_id:3540032]，你将应用误差传播公式来区分并量化这两种截然不同的不确定度来源，为解读任何实验结果建立一项核心技能。", "problem": "在计算高能物理（HEP）中，一个过程的总截面 $\\sigma$ 通常是根据观测到的事例计数和探测器接受度来估算的。考虑一次测量，其中由于计数统计，观测到的信号事例数 $N$ 服从泊松分布，而探测效率 $\\epsilon$ 通过刻度已知，但会受到一个未知的微小分数刻度漂移的影响。积分亮度 $L$ 是精确已知的。用于截面的点估计量是观测产额与曝光量之比，该曝光量由积分亮度与名义效率的乘积给出。\n\n假设测量模型和输入如下：\n- 观测计数为 $N = 1692$。\n- 积分亮度为 $L = 140\\,\\mathrm{fb}^{-1}$。\n- 名义效率为 $\\epsilon_{0} = 0.60$。\n- 真实效率通过一个刻度漂移与名义效率相关联，其关系为 $\\epsilon = \\epsilon_{0}\\left(1 + \\delta\\right)$，其中刻度讨厌参数 $\\delta$ 是一个均值为零、标准差为 $s_{\\delta} = 0.035$ 的高斯变量。计数 $N$ 和刻度漂移 $\\delta$ 是独立的。\n\n使用一阶误差传播方法，从计数的泊松模型定义和不确定度传播的线性化方法出发，计算由以下各项对截面估计量 $\\hat{\\sigma}$ 的标准差的单独贡献：\n1. 泊松计数产生的随机不确定度。\n2. 效率刻度漂移产生的认知不确定度。\n\n将这两项贡献以飞靶（fb）为单位表示为数值，并各自四舍五入到三位有效数字。", "solution": "该问题是有效的，因为它呈现了一个在实验高能物理中常见的自洽、有科学依据且定义良好的场景。所有必要的数据都已提供，任务是应用一种标准的不确定度传播方法。\n\n真实截面 $\\sigma$、信号事例的真实平均数 $\\mu$、积分亮度 $L$以及真实探测效率 $\\epsilon$ 通过方程 $\\mu = \\sigma L \\epsilon$ 相关联。我们得到一个观测计数 $N$，它是均值为 $\\mu$ 的泊松随机变量的单次实现。真实效率建模为 $\\epsilon = \\epsilon_0(1+\\delta)$，其中 $\\epsilon_0$ 是名义效率，$\\delta$ 是代表未知刻度漂移的讨厌参数。\n\n我们可以将截面表示为我们测量或拥有其概率信息的量（即 $N$ 和 $\\delta$）的函数。通过使用 $N$ 作为 $\\mu$ 的估计量，我们得到：\n$$ \\sigma(N, \\delta) = \\frac{N}{L \\epsilon} = \\frac{N}{L \\epsilon_0 (1 + \\delta)} $$\n截面的中心值 $\\hat{\\sigma}$ 是通过在观测值 $N = 1692$ 和 $\\delta$ 的平均值 $\\langle\\delta\\rangle = 0$ 处计算此函数得到的：\n$$ \\hat{\\sigma} = \\sigma(1692, 0) = \\frac{1692}{L \\epsilon_0} $$\n为了求出 $\\sigma$ 的不确定度，我们使用一阶误差传播。由于问题指出计数统计量 $N$ 和刻度漂移 $\\delta$ 是独立的，总方差 $V[\\sigma]$ 可近似为各项贡献之和：\n$$ V[\\sigma] \\approx \\left(\\frac{\\partial\\sigma}{\\partial N}\\right)^2 V[N] + \\left(\\frac{\\partial\\sigma}{\\partial \\delta}\\right)^2 V[\\delta] $$\n问题要求计算对标准差的单独贡献，我们将其记为 $\\Delta\\sigma_N$ 和 $\\Delta\\sigma_\\delta$。它们的计算方法如下：\n$$ \\Delta\\sigma_N = \\left| \\frac{\\partial\\sigma}{\\partial N} \\right| \\sqrt{V[N]} \\quad \\text{和} \\quad \\Delta\\sigma_\\delta = \\left| \\frac{\\partial\\sigma}{\\partial \\delta} \\right| \\sqrt{V[\\delta]} $$\n偏导数在参数的中心值处计算，即在 $N = 1692$ 和 $\\delta = 0$ 处。\n\n1. 来自随机不确定度（$N$ 的泊松计数）的贡献\n观测计数 $N$ 服从泊松分布。对于泊松过程，方差等于均值，即 $V[N] = E[N]$。均值 $E[N]$ 的最佳可用估计是观测计数 $N$ 本身。因此，我们将方差近似为 $V[N] \\approx N$，标准差近似为 $\\sqrt{V[N]} \\approx \\sqrt{N}$。\n$\\sigma$ 对 $N$ 的偏导数为：\n$$ \\frac{\\partial\\sigma}{\\partial N} = \\frac{\\partial}{\\partial N} \\left[ \\frac{N}{L \\epsilon_0 (1 + \\delta)} \\right] = \\frac{1}{L \\epsilon_0 (1 + \\delta)} $$\n在 $\\delta=0$ 处计算此导数：\n$$ \\left.\\frac{\\partial\\sigma}{\\partial N}\\right|_{\\delta=0} = \\frac{1}{L \\epsilon_0} $$\n来自计数不确定度的标准差贡献为：\n$$ \\Delta\\sigma_N = \\left| \\frac{1}{L \\epsilon_0} \\right| \\sqrt{N} = \\frac{\\sqrt{N}}{L \\epsilon_0} $$\n代入给定值，$N = 1692$，$L = 140\\,\\mathrm{fb}^{-1}$ 和 $\\epsilon_0 = 0.60$：\n$$ \\Delta\\sigma_N = \\frac{\\sqrt{1692}}{140 \\times 0.60}\\,\\mathrm{fb} = \\frac{\\sqrt{1692}}{84}\\,\\mathrm{fb} \\approx \\frac{41.133928...}{84}\\,\\mathrm{fb} \\approx 0.4896896... \\,\\mathrm{fb} $$\n四舍五入到三位有效数字，随机不确定度贡献为 $0.490\\,\\mathrm{fb}$。\n\n2. 来自认知不确定度（效率刻度漂移 $\\delta$）的贡献\n刻度漂移 $\\delta$ 被描述为一个均值为 0、标准差为 $s_\\delta = 0.035$ 的高斯随机变量。因此，$\\delta$ 的标准差为 $\\sqrt{V[\\delta]} = s_\\delta$。\n$\\sigma$ 对 $\\delta$ 的偏导数为：\n$$ \\frac{\\partial\\sigma}{\\partial \\delta} = \\frac{\\partial}{\\partial \\delta} \\left[ \\frac{N}{L \\epsilon_0} (1+\\delta)^{-1} \\right] = \\frac{N}{L \\epsilon_0} \\left[ -1 \\cdot (1+\\delta)^{-2} \\right] = -\\frac{N}{L \\epsilon_0 (1+\\delta)^2} $$\n在中心值 $N=1692$ 和 $\\delta=0$ 处计算此导数：\n$$ \\left.\\frac{\\partial\\sigma}{\\partial \\delta}\\right|_{N=1692, \\delta=0} = -\\frac{1692}{L \\epsilon_0 (1+0)^2} = -\\frac{N}{L \\epsilon_0} = -\\hat{\\sigma} $$\n来自效率不确定度的标准差贡献为：\n$$ \\Delta\\sigma_\\delta = \\left| -\\frac{N}{L \\epsilon_0} \\right| s_\\delta = \\hat{\\sigma} \\cdot s_\\delta $$\n首先，我们计算估计的截面 $\\hat{\\sigma}$：\n$$ \\hat{\\sigma} = \\frac{1692}{140 \\times 0.60}\\,\\mathrm{fb} = \\frac{1692}{84}\\,\\mathrm{fb} = 20.142857... \\,\\mathrm{fb} $$\n现在我们可以计算不确定度贡献：\n$$ \\Delta\\sigma_\\delta = (20.142857... \\,\\mathrm{fb}) \\times 0.035 \\approx 0.704999... \\,\\mathrm{fb} $$\n四舍五入到三位有效数字，认知不确定度贡献为 $0.705\\,\\mathrm{fb}$。\n\n所要求的两项不确定度贡献是：\n- 随机不确定度：$0.490\\,\\mathrm{fb}$\n- 认知不确定度：$0.705\\,\\mathrm{fb}$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.490  0.705\n\\end{pmatrix}\n}\n$$", "id": "3540032"}, {"introduction": "真实世界的分析通常涉及测量分布，而不仅仅是单个数值，并且系统不确定度会扭曲这些分布的形状。本实践[@problem_id:3540041]介绍了“模板变形”(template morphing)技术，这是一种强大且标准的方法，用于对此类形状变化进行建模。通过在名义、“上”、“下”系统不确定度模板之间实现二次插值，你将学习如何构建一个连续且可微的形状不确定度模型，这是构建复杂似然函数的关键组成部分。", "problem": "给定三个分箱模板，它们表示高能物理（HEP）中在单一系统不确定度来源下的微分事例产额分布：一个在参数值 $\\theta=0$ 处的名义模板，一个在 $\\theta=+1$ 处的“up”模板，以及一个在 $\\theta=-1$ 处的“down”模板。参数 $\\theta$ 是一个控制系统性偏移的无量纲讨厌参数。目标是实现对箱内容的垂直形变，并计算在中间参数值 $\\theta=0.3$ 时每个箱中的预期事例产额。在垂直形变中，形变是在箱内容上“垂直”执行的，这意味着对于每个箱 $i$，我们定义一个平滑函数 $y_i(\\theta)$，该函数对三个控制点 $\\{(\\theta,y_i(\\theta))\\} = \\{(-1,y_i^{-}), (0,y_i^{0}), (1,y_i^{+})\\}$ 进行插值，其中 $y_i^{-}$、$y_i^{0}$ 和 $y_i^{+}$ 分别是“down”模板、名义模板和“up”模板的箱内容。假设 $\\theta$ 位于区间 $[-1,1]$ 内。预期事例产额是所有箱内容的总和，事例计数是无量纲的。\n\n本问题的基本原理：在基于分箱模板的事例产额预测中，箱 $i$ 中的预期产额是微分期望在该箱范围内的积分，当使用离散直方图时，这在计算上简化为箱内容 $y_i$。当不确定度仅影响形状（shape-only）时，总预期产额（所有箱的总和）在系统性变化中保持不变。一个模板形变方案必须在每个箱中都满足边界条件 $y_i(-1)=y_i^{-}$、$y_i(0)=y_i^{0}$ 和 $y_i(1)=y_i^{+}$，以与“up”/“down”变化和名义预测保持一致。在不指定任何特定简化公式的情况下，为每个箱实现与这三个边界条件一致的唯一最低阶多项式，并用它来插值到 $\\theta=0.3$。然后，验证当“up”和“down”模板被预先归一化到与名义模板相同的总和时，插值是否保持总产额不变。\n\n实现以下测试套件。对于每个测试用例，计算在 $\\theta=0.3$ 时的插值箱产额，并计算两个布尔值：一个表示插值后的总产额是否在 $10^{-12}$ 的绝对容差内等于名义总产额，另一个表示是否意图保持总产额不变（即，$\\sum_i y_i^{+} = \\sum_i y_i^{0} = \\sum_i y_i^{-}$ 是否成立）。对于每个测试用例，程序必须返回一个列表，其中包含：在 $\\theta=0.3$ 时每个箱的插值产额列表、“总产额保持”的布尔值，以及“意图保持”的布尔值。\n\n测试套件：\n- 情况A（仅影响形状，up/down 已预先归一化）：$y^{0}=[100.0, 150.0, 80.0, 70.0]$，$y^{+}=[110.0, 140.0, 85.0, 65.0]$，$y^{-}=[90.0, 160.0, 75.0, 75.0]$。\n- 情况B（未预先归一化）：$y^{0}=[50.0, 50.0, 50.0]$，$y^{+}=[60.0, 55.0, 50.0]$，$y^{-}=[45.0, 45.0, 45.0]$。\n- 情况C（含零内容箱的边缘情况，仅影响形状且已预先归一化）：$y^{0}=[0.0, 100.0, 0.0, 50.0]$，$y^{+}=[0.0, 110.0, 0.0, 40.0]$，$y^{-}=[0.0, 90.0, 0.0, 60.0]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。此顶层列表的每个元素对应一个测试用例，其本身也是一个形如 $[\\text{在}\\theta=0.3\\text{时的箱产额列表},\\ \\text{保持布尔值},\\ \\text{意图布尔值}]$ 的列表。输出中不得包含任何空格。例如，语法结构必须与“[[...,...,...],[...,...,...],[...,...,...]]”完全一样，所有数字和布尔值均以纯文本表示。不涉及物理单位；所有量均为无量纲计数。本问题不出现角度或角度单位。\n\n精确的解题步骤：\n- 对于测试用例中的每个箱 $i$，构建与 $\\theta=-1,0,1$ 处的三个给定边界条件一致的唯一最低阶多项式 $y_i(\\theta)$。\n- 对所有箱计算 $y_i(0.3)$。\n- 计算总产额 $\\sum_i y_i(0.3)$ 并与 $\\sum_i y_i^{0}$ 进行比较，使用 $10^{-12}$ 的绝对容差来形成“保持的”布尔值。\n- 通过检查 $\\sum_i y_i^{+}$、$\\sum_i y_i^{0}$ 和 $\\sum_i y_i^{-}$ 是否在相同容差内相等，来确定“意图的”布尔值。\n- 汇总并完全按照指定的单行无空格格式打印最终结果。", "solution": "该问题要求实现一种用于分箱事例产额模板的垂直形变算法，这是高能物理中为系统不确定度效应建模的标准技术。任务的核心是为讨厌参数值 $\\theta=0.3$ 找到一个插值模板，给定三个输入模板：在 $\\theta=0$ 处的名义模板（$y^0$）、在 $\\theta=+1$ 处的“up”变化模板（$y^+$）以及在 $\\theta=-1$ 处的“down”变化模板（$y^-$）。我们还必须验证一个与总事例产额守恒相关的属性。\n\n该问题是有效的，因为它在科学上基于常见的物理分析实践，在数学上是适定的，并提供了完整且明确的规范。\n\n第一步是确定每个箱 $i$ 内容的插值函数。问题指定使用通过三个给定控制点：$(-1, y_i^{-})$、$(0, y_i^{0})$ 和 $(1, y_i^{+})$ 的唯一最低阶多项式。能够拟合三个点的多项式通常是一个二次多项式，形式为：\n$$y_i(\\theta) = a_i \\theta^2 + b_i \\theta + c_i$$\n\n每个箱 $i$ 的系数 $a_i$、$b_i$ 和 $c_i$ 通过施加边界条件来确定：\n1. 在 $\\theta=0$ 处：\n$$y_i(0) = a_i(0)^2 + b_i(0) + c_i = y_i^0 \\implies c_i = y_i^0$$\n2. 在 $\\theta=1$ 处：\n$$y_i(1) = a_i(1)^2 + b_i(1) + c_i = a_i + b_i + c_i = y_i^+$$\n代入 $c_i=y_i^0$，我们得到：\n$$a_i + b_i = y_i^+ - y_i^0 \\quad (\\text{方程 1})$$\n3. 在 $\\theta=-1$ 处：\n$$y_i(-1) = a_i(-1)^2 + b_i(-1) + c_i = a_i - b_i + c_i = y_i^-$$\n代入 $c_i=y_i^0$，我们得到：\n$$a_i - b_i = y_i^- - y_i^0 \\quad (\\text{方程 2})$$\n\n我们现在得到了一个关于 $a_i$ 和 $b_i$ 的二元一次方程组。将方程 1 和方程 2 相加得到：\n$$2a_i = (y_i^+ - y_i^0) + (y_i^- - y_i^0) = y_i^+ + y_i^- - 2y_i^0$$\n$$a_i = \\frac{y_i^+ + y_i^- - 2y_i^0}{2}$$\n将方程 1 减去方程 2 得到：\n$$2b_i = (y_i^+ - y_i^0) - (y_i^- - y_i^0) = y_i^+ - y_i^-$$\n$$b_i = \\frac{y_i^+ - y_i^-}{2}$$\n\n因此，在任意参数值 $\\theta$ 下，插值箱内容 $y_i$ 的显式公式为：\n$$y_i(\\theta) = \\left( \\frac{y_i^+ + y_i^- - 2y_i^0}{2} \\right) \\theta^2 + \\left( \\frac{y_i^+ - y_i^-}{2} \\right) \\theta + y_i^0$$\n该公式将对每个箱在 $\\theta=0.3$ 处进行求值，以找到插值模板。\n\n接下来，我们分析总事例产额的保持性。在给定 $\\theta$ 下的总产额是所有箱内容的总和，$S(\\theta) = \\sum_i y_i(\\theta)$。使用插值公式和求和算子的线性性质：\n$$S(\\theta) = \\sum_i \\left[ \\left( \\frac{y_i^+ + y_i^- - 2y_i^0}{2} \\right) \\theta^2 + \\left( \\frac{y_i^+ - y_i^-}{2} \\right) \\theta + y_i^0 \\right]$$\n$$S(\\theta) = \\left( \\frac{\\sum_i y_i^+ + \\sum_i y_i^- - 2\\sum_i y_i^0}{2} \\right) \\theta^2 + \\left( \\frac{\\sum_i y_i^+ - \\sum_i y_i^-}{2} \\right) \\theta + \\sum_i y_i^0$$\n令 $S_0 = \\sum_i y_i^0$、$S_+ = \\sum_i y_i^+$ 和 $S_- = \\sum_i y_i^-$ 分别为名义模板、“up”模板和“down”模板的总产额。总插值产额的表达式简化为：\n$$S(\\theta) = \\left( \\frac{S_+ + S_- - 2S_0}{2} \\right) \\theta^2 + \\left( \\frac{S_+ - S_-}{2} \\right) \\theta + S_0$$\n问题将“意图保持”定义为输入模板被预先归一化的情况，即 $S_+ = S_0$ 且 $S_- = S_0$。这对应于“仅影响形状”的不确定度。如果这些条件成立，$S(\\theta)$ 表达式中 $\\theta^2$ 和 $\\theta$ 项的系数将变为零：\n$\\theta^2$ 的系数：$\\frac{S_0 + S_0 - 2S_0}{2} = 0$。\n$\\theta$ 的系数：$\\frac{S_0 - S_0}{2} = 0$。\n因此，如果意图保持成立，则对于所有 $\\theta \\in [-1, 1]$，$S(\\theta) = S_0$。这证明了二次垂直形变保持总事例产额的充要条件是，输入的“up”和“down”模板具有与名义模板相同的总产额。\n\n将要实现的算法将对每个测试用例执行以下步骤：\n1. 对于给定的测试用例，其模板为 $y^0$、$y^+$ 和 $y^-$，计算它们的总和 $S_0$、$S_+$ 和 $S_-$。\n2. 通过检查 $|S_+ - S_0|  10^{-12}$ 和 $|S_- - S_0|  10^{-12}$ 是否成立来确定 `intended_preservation` 布尔值。\n3. 对于每个箱 $i$，使用推导出的公式计算系数 $a_i, b_i, c_i$。通过对模板数组使用向量化操作可以高效地完成此步骤。\n4. 对所有箱计算 $y_i(0.3) = a_i(0.3)^2 + b_i(0.3) + c_i$ 以获得插值模板。\n5. 计算插值模板的总产额 $S_{0.3} = \\sum_i y_i(0.3)$。\n6. 通过检查 $|S_{0.3} - S_0|  10^{-12}$ 是否成立来确定 `preserved_total` 布尔值。\n7. 收集插值产额列表、`preserved_total` 布尔值和 `intended_preservation` 布尔值。\n8. 按照规定，将收集到的所有测试用例的结果格式化为无空格的单行字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the vertical morphing problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"y0\": [100.0, 150.0, 80.0, 70.0],\n            \"y_up\": [110.0, 140.0, 85.0, 65.0],\n            \"y_down\": [90.0, 160.0, 75.0, 75.0]\n        },\n        {\n            \"y0\": [50.0, 50.0, 50.0],\n            \"y_up\": [60.0, 55.0, 50.0],\n            \"y_down\": [45.0, 45.0, 45.0]\n        },\n        {\n            \"y0\": [0.0, 100.0, 0.0, 50.0],\n            \"y_up\": [0.0, 110.0, 0.0, 40.0],\n            \"y_down\": [0.0, 90.0, 0.0, 60.0]\n        }\n    ]\n\n    theta = 0.3\n    tolerance = 1e-12\n    all_results = []\n\n    for case in test_cases:\n        y0 = np.array(case[\"y0\"])\n        y_up = np.array(case[\"y_up\"])\n        y_down = np.array(case[\"y_down\"])\n\n        # Step 1: Check for \"intended preservation\"\n        s0 = np.sum(y0)\n        s_up = np.sum(y_up)\n        s_down = np.sum(y_down)\n        \n        intended_preservation = np.isclose(s0, s_up, atol=tolerance, rtol=0) and \\\n                                np.isclose(s0, s_down, atol=tolerance, rtol=0)\n\n        # Step 2: Calculate quadratic coefficients for each bin (vectorized)\n        # y_i(theta) = a_i * theta**2 + b_i * theta + c_i\n        c = y0\n        b = (y_up - y_down) / 2.0\n        a = (y_up + y_down - 2.0 * y0) / 2.0\n        \n        # Step 3: Evaluate the polynomial at theta = 0.3\n        interpolated_yields = a * theta**2 + b * theta + c\n        \n        # Step 4: Check if the total yield is actually preserved\n        s_interp = np.sum(interpolated_yields)\n        total_preserved = np.isclose(s0, s_interp, atol=tolerance, rtol=0)\n\n        # Step 5: Assemble the results for the current case\n        result_list = [\n            interpolated_yields.tolist(),\n            total_preserved,\n            intended_preservation\n        ]\n        all_results.append(result_list)\n\n    # Step 6: Format the final output string exactly as required (no spaces)\n    case_strings = []\n    for res in all_results:\n        yields_str = f\"[{','.join(f'{y:.15g}' for y in res[0])}]\"\n        preserved_str = str(res[1]).lower()\n        intended_str = str(res[2]).lower()\n        case_strings.append(f\"[{yields_str},{preserved_str},{intended_str}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3540041"}, {"introduction": "量化系统不确定度的最终目标是理解它们对我们物理结论的影响，例如一个潜在发现的显著性。这个高级实践[@problem_id:3540042]模拟了一个完整的分析流程，你将构建一个完整的分箱似然模型，其中包含归一化和形状不确定度作为讨厌参数(nuisance parameters)。利用阿西莫夫数据集(Asimov dataset)的概念和剖面似然方法，你将计算这些系统不确定度如何降低预期的发现显著性，从而具体理解为什么在寻找新物理的过程中，对它们的审慎处理至关重要。", "problem": "考虑一个计算高能物理中的分箱计数实验，其中预期的信号和本底产额按箱进行建模，并使用Asimov数据集的概念来分析数据。核心目标是通过构建并剖析一个包含带高斯约束的讨厌参数的似然函数，来量化系统不确定度对预期发现显著性的影响。该计算必须纯粹以数学术语完成，且不得依赖任何外部数据源。\n\n假设有$N$个箱，索引为$i \\in \\{0,1,\\dots,N-1\\}$。令$s_i \\ge 0$表示第$i$个箱中的预期信号产额，$b_i > 0$表示第$i$个箱中的预期本底产额。定义Asimov数据集（一个确定性的数据集，其计数在名义讨厌参数下与信号加本底假设的期望值一致）的计数为\n$$\nn_i^{A} = \\mu_{\\text{true}} s_i + b_i,\n$$\n其中$\\mu_{\\text{true}}$是构建Asimov数据集时所用的真实信号强度。在本问题中，取$\\mu_{\\text{true}} = 1$。\n\n在假设信号强度为$\\mu \\ge 0$和存在两个讨厌参数的情况下，第$i$个箱中预期计数的统计模型为：\n$$\n\\lambda_i(\\mu,\\theta_n,\\theta_s) = \\mu s_i + b_i \\exp(\\theta_n) \\exp(\\theta_s k_i),\n$$\n其中：\n- $\\theta_n$是本底归一化讨厌参数，其高斯先验以$0$为中心，相对标准差为$\\sigma_n$（表示为小数）。\n- $\\theta_s$是形状讨厌参数，其高斯先验以$0$为中心，标准差为$\\sigma_s$。\n- $k_i$编码了各箱之间线性倾斜的形状模式，定义为\n$$\nk_i = r_i - \\frac{1}{N} \\sum_{j=0}^{N-1} r_j, \\quad \\text{其中} \\quad r_i = -1 + \\frac{2i}{N-1},\n$$\n使得$\\sum_i k_i = 0$，确保这是一个纯粹的倾斜，一阶上不改变总体归一化。\n\n在假设每个箱中的计数服从独立的泊松涨落，且讨厌参数具有独立的高斯约束的条件下，对于Asimov数据的负对数似然（不计与参数无关的加性常数）为：\n$$\n\\text{NLL}(\\mu,\\theta_n,\\theta_s) = \\sum_{i=0}^{N-1} \\left[ \\lambda_i(\\mu,\\theta_n,\\theta_s) - n_i^{A} \\ln \\lambda_i(\\mu,\\theta_n,\\theta_s) \\right]\n+ \\frac{1}{2}\\left(\\frac{\\theta_n}{\\sigma_n}\\right)^2 \\mathbb{I}[\\sigma_n > 0]\n+ \\frac{1}{2}\\left(\\frac{\\theta_s}{\\sigma_s}\\right)^2 \\mathbb{I}[\\sigma_s > 0],\n$$\n其中$\\mathbb{I}[\\cdot]$是指示函数，仅当相应的标准差严格为正时才包含高斯惩罚项。当标准差为零时，相关的讨厌参数被固定在其名义值$0$。\n\n定义用于检验纯本底假设$\\mu=0$的剖面似然比为：\n$$\n\\lambda(0) = \\frac{L(0,\\hat{\\hat{\\theta}})}{L(\\hat{\\mu},\\hat{\\theta})},\n$$\n其中$L$是与上述负对数似然$\\text{NLL}$相对应的似然函数，$\\hat{\\hat{\\theta}}$表示在$\\mu$固定为$0$时最小化$\\text{NLL}$的讨厌参数，而$(\\hat{\\mu},\\hat{\\theta})$是在$\\mu \\ge 0$和讨厌参数上联合最小化$\\text{NLL}$的参数。基于似然比的发现检验统计量为\n$$\nq_0 = -2 \\ln \\lambda(0),\n$$\n而Asimov预期发现显著性为\n$$\nZ_A = \\sqrt{q_0}.\n$$\n此$Z_A$无单位，应以浮点数形式报告。\n\n实现一个程序，对于下面定义的每个测试用例，构建Asimov数据集$n_i^{A}$，剖析负对数似然以在$\\mu=0$时获得$\\hat{\\hat{\\theta}}$以及在$\\mu \\ge 0$自由变化时获得$(\\hat{\\mu},\\hat{\\theta})$，计算$q_0$，并返回$Z_A$。上述建模选择，包括系统效应的指数参数化，确保了期望值$\\lambda_i(\\mu,\\theta_n,\\theta_s)$的正定性。\n\n您的程序必须将所有测试用例的结果作为单行输出，该行包含一个用方括号括起来的逗号分隔列表，每个条目四舍五入到六位小数，例如，“[0.123456,1.234568]”。不得打印任何其他文本。\n\n测试套件：\n- 用例1（同时包含归一化和形状不确定度的一般情况）：\n  - $N=6$\n  - $b = [120, 100, 90, 80, 70, 60]$\n  - $s = [10, 12, 15, 18, 20, 22]$\n  - $\\sigma_n = 0.05$\n  - $\\sigma_s = 1.0$\n- 用例2（仅归一化不确定度；形状不确定度禁用）：\n  - $N=6$\n  - $b = [120, 100, 90, 80, 70, 60]$\n  - $s = [10, 12, 15, 18, 20, 22]$\n  - $\\sigma_n = 0.05$\n  - $\\sigma_s = 0.0$\n- 用例3（仅形状不确定度；归一化不确定度禁用）：\n  - $N=6$\n  - $b = [120, 100, 90, 80, 70, 60]$\n  - $s = [10, 12, 15, 18, 20, 22]$\n  - $\\sigma_n = 0.0$\n  - $\\sigma_s = 1.0$\n- 用例4（弱信号；两种不确定度均激活）：\n  - $N=6$\n  - $b = [120, 100, 90, 80, 70, 60]$\n  - $s = [1, 1.2, 1.5, 1.8, 2.0, 2.2]$\n  - $\\sigma_n = 0.05$\n  - $\\sigma_s = 1.0$\n- 用例5（强信号；两种不确定度均激活）：\n  - $N=6$\n  - $b = [120, 100, 90, 80, 70, 60]$\n  - $s = [50, 60, 75, 90, 100, 110]$\n  - $\\sigma_n = 0.05$\n  - $\\sigma_s = 1.0$\n- 用例6（部分箱中本底较低的边界情况；两种不确定度均激活）：\n  - $N=6$\n  - $b = [5, 10, 15, 5, 3, 1]$\n  - $s = [2, 2, 3, 3, 4, 5]$\n  - $\\sigma_n = 0.05$\n  - $\\sigma_s = 1.0$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，顺序与上面列出的用例完全相同。每个数字必须是四舍五入到六位小数的浮点数，并且方括号内不得有额外的空格。", "solution": "该问题要求在不同的系统不确定度情景下，为一个分箱计数实验计算Asimov发现显著性$Z_A$。该计算依赖于剖面似然比方法，这是高能物理中统计推断的基石。\n\n### 科学原理与方法论\n\n问题的核心是使用从似然函数导出的检验统计量，来量化信号加本底假设（$\\mu=1$）与纯本底假设（$\\mu=0$）之间的预期区分度。\n\n1.  **似然函数**：该统计模型假设每个箱$i$中观测到的事件数服从均值为$\\lambda_i$的独立泊松分布。总似然函数是这些泊松概率的乘积，并增加了由讨厌参数建模的系统不确定度的惩罚项。讨厌参数$\\theta_n$和$\\theta_s$受到高斯先验的约束，这反映了关于其期望值（零）和不确定度（$\\sigma_n$和$\\sigma_s$）的先验知识。为计算方便，我们使用负对数似然（$\\text{NLL}$），它是一个各项之和而非乘积：\n    $$\n    \\text{NLL}(\\mu,\\theta_n,\\theta_s) = \\sum_{i=0}^{N-1} \\left[ \\lambda_i(\\mu,\\theta_n,\\theta_s) - n_i \\ln \\lambda_i(\\mu,\\theta_n,\\theta_s) \\right] + \\text{Penalty}(\\theta_n, \\theta_s)\n    $$\n    其中惩罚项是二次的，对应于高斯先验。\n\n2.  **Asimov数据集**：为了在不使用计算成本高昂的蒙特卡洛模拟的情况下计算*预期*显著性，我们使用Asimov数据集。这是一个确定性的、有代表性的数据集，其中“观测”计数$n_i^A$被设定为等于特定假设下的预期计数。在这里，这个假设是信号强度为$\\mu_{\\text{true}}=1$且讨厌参数为名义值（$\\theta_n=0, \\theta_s=0$）的信号加本底假设。因此，$n_i^A = s_i + b_i$。\n\n3.  **剖面似然比与检验统计量$q_0$**：假设之间的区分度通过剖面似然比检验统计量$q_0$来量化。\n    $$\n    q_0 = -2 \\ln \\frac{ L(\\mu=0, \\hat{\\hat{\\theta}}) }{ L(\\hat{\\mu}, \\hat{\\theta}) } = 2 \\left[ \\text{NLL}(0, \\hat{\\hat{\\theta}}) - \\text{NLL}(\\hat{\\mu}, \\hat{\\theta}) \\right]\n    $$\n    这需要在两种情景下找到最小化NLL的参数：\n    -   **全局最小值**：$(\\hat{\\mu}, \\hat{\\theta})$是为数据提供最佳拟合的参数，代表NLL的全局最小值。Asimov数据集的一个关键特性是，NLL的全局最小值恰好出现在生成该数据集所依据的真实参数值处。在我们的情况下，即$(\\hat{\\mu}, \\hat{\\theta}_n, \\hat{\\theta}_s) = (1, 0, 0)$。\n    -   **约束下最小值**：$\\hat{\\hat{\\theta}}$是在纯本底假设（$\\mu=0$）的约束下为数据提供最佳拟合的讨厌参数。这给出了在$\\mu=0$子空间上NLL的最小值。\n\n4.  **Asimov显著性$Z_A$**：对于Asimov数据集，显著性就是$Z_A = \\sqrt{q_0}$。这个值代表了实验的中位预期发现显著性。\n\n### 算法实现\n\n该解决方案通过对每个测试用例执行以下步骤来实现：\n\n1.  **初始化**：定义输入参数：箱数$N$、信号产额$s_i$、本底产额$b_i$以及系统不确定度$\\sigma_n$和$\\sigma_s$。\n\n2.  **预计算**：\n    -   根据定义计算形状因子$k_i$。\n    -   构建Asimov数据集计数为$n_i^A = s_i + b_i$。\n\n3.  **计算全局最小值处的NLL**：\n    -   NLL的全局最小值出现在$(\\mu, \\theta_n, \\theta_s) = (1, 0, 0)$处。\n    -   将这些值代入NLL公式计算$\\text{NLL}(\\hat{\\mu}, \\hat{\\theta}) = \\text{NLL}(1, 0, 0)$的值，该式简化为$\\sum_i [n_i^A - n_i^A \\ln(n_i^A)]$。\n\n4.  **计算约束下最小值处的NLL**：\n    -   找到$\\text{NLL}(0, \\hat{\\hat{\\theta}})$需要将$\\mu$固定为$0$，同时对讨厌参数$(\\theta_n, \\theta_s)$最小化NLL函数。\n    -   这是一个数值优化问题。我们定义一个目标函数`nll_mu0(thetas)`来计算$\\text{NLL}(0, \\theta_n, \\theta_s)$。\n    -   使用`scipy.optimize.minimize`函数和`L-BFGS-B`方法来找到此目标函数的最小值。讨厌参数的初始猜测值为$(0, 0)$。\n    -   当$\\sigma_n=0$或$\\sigma_s=0$时，对应于一个固定的讨厌参数。这通过在优化器中将相应参数的边界设置为$(0, 0)$来处理。\n\n5.  **计算显著性$Z_A$**：\n    -   检验统计量$q_0$计算为$q_0 = 2 \\left[ \\text{NLL}(0, \\hat{\\hat{\\theta}}) - \\text{NLL}(1, 0, 0) \\right]$。为防止微小的数值浮点不精确性导致问题，$q_0$的下限设为$0$。\n    -   然后，Asimov显著性为$Z_A = \\sqrt{q_0}$。\n\n最终结果是所有测试用例计算出的$Z_A$值的列表，并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves for the Asimov significance Z_A for a series of binned counting experiments.\n    \"\"\"\n    test_cases = [\n        # Case 1: General case with both uncertainties\n        {'N': 6, 'b': [120, 100, 90, 80, 70, 60], 's': [10, 12, 15, 18, 20, 22], 'sigma_n': 0.05, 'sigma_s': 1.0},\n        # Case 2: Normalization uncertainty only\n        {'N': 6, 'b': [120, 100, 90, 80, 70, 60], 's': [10, 12, 15, 18, 20, 22], 'sigma_n': 0.05, 'sigma_s': 0.0},\n        # Case 3: Shape uncertainty only\n        {'N': 6, 'b': [120, 100, 90, 80, 70, 60], 's': [10, 12, 15, 18, 20, 22], 'sigma_n': 0.0, 'sigma_s': 1.0},\n        # Case 4: Weak signal\n        {'N': 6, 'b': [120, 100, 90, 80, 70, 60], 's': [1, 1.2, 1.5, 1.8, 2.0, 2.2], 'sigma_n': 0.05, 'sigma_s': 1.0},\n        # Case 5: Strong signal\n        {'N': 6, 'b': [120, 100, 90, 80, 70, 60], 's': [50, 60, 75, 90, 100, 110], 'sigma_n': 0.05, 'sigma_s': 1.0},\n        # Case 6: Low background edge case\n        {'N': 6, 'b': [5, 10, 15, 5, 3, 1], 's': [2, 2, 3, 3, 4, 5], 'sigma_n': 0.05, 'sigma_s': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        b = np.array(case['b'], dtype=float)\n        s = np.array(case['s'], dtype=float)\n        sigma_n = case['sigma_n']\n        sigma_s = case['sigma_s']\n\n        # Step 1: Pre-computation of k_i and Asimov data n_A\n        i_indices = np.arange(N)\n        r_i = -1.0 + 2.0 * i_indices / (N - 1)\n        k_i = r_i - np.mean(r_i)\n\n        n_A = s + b\n\n        # Step 2: Calculate NLL at the global minimum (mu=1, thetas=0)\n        # NLL(1, 0, 0) = sum(lambda_i - n_A*ln(lambda_i)) = sum(n_A - n_A*ln(n_A))\n        # We can drop n_A*ln(n_A) as a constant, but for clarity we compute the full difference.\n        nll_min_global = np.sum(n_A - n_A * np.log(n_A))\n\n        # Step 3: Define the NLL function for the mu=0 hypothesis to be minimized\n        def nll_mu0(thetas):\n            theta_n, theta_s = thetas\n            \n            # Expected counts under mu=0 hypothesis\n            lambda_i = b * np.exp(theta_n + theta_s * k_i)\n            \n            # Poisson term of NLL\n            poisson_term = np.sum(lambda_i - n_A * np.log(lambda_i))\n            \n            # Gaussian penalty terms for nuisance parameters\n            penalty_n = 0.0\n            if sigma_n > 0:\n                penalty_n = 0.5 * (theta_n / sigma_n)**2\n            \n            penalty_s = 0.0\n            if sigma_s > 0:\n                penalty_s = 0.5 * (theta_s / sigma_s)**2\n                \n            return poisson_term + penalty_n + penalty_s\n\n        # Step 4: Minimize NLL for mu=0\n        # Set bounds to (0,0) for parameters with sigma=0 to fix them\n        bounds = []\n        if sigma_n > 0:\n            bounds.append((None, None))\n        else:\n            bounds.append((0, 0))\n        \n        if sigma_s > 0:\n            bounds.append((None, None))\n        else:\n            bounds.append((0, 0))\n        \n        # Initial guess for optimization\n        x0 = [0.0, 0.0]\n\n        res_mu0 = minimize(nll_mu0, x0, method='L-BFGS-B', bounds=bounds)\n        nll_min_mu0 = res_mu0.fun\n\n        # Step 5: Calculate q0 and Z_A\n        q0 = 2 * (nll_min_mu0 - nll_min_global)\n        \n        # Guard against small numerical noise making q0 negative\n        if q0  0:\n            q0 = 0\n            \n        Z_A = np.sqrt(q0)\n        results.append(f\"{Z_A:.6f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3540042"}]}