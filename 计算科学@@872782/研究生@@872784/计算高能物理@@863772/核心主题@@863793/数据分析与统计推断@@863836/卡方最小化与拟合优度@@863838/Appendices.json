{"hands_on_practices": [{"introduction": "卡方最小化是数据分析的基石。这个首次实践将带你亲手实现线性模型的加权最小二乘法拟合，这是所有复杂拟合问题的基础。你将学习如何计算最佳拟合参数，评估拟合优度，并应用威尔科斯定理（Wilks' theorem）通过 $\\Delta\\chi^2$ 构建置信区间，这些都是物理学数据处理中无处不在的任务。[@problem_id:3507420]", "problem": "考虑一个具有高斯噪声和已知的、逐箱（bin-wise）标准差的分箱（binned）测量序列。令 $y_i$ 表示箱 $i$ 中的观测值，$\\sigma_i$ 表示箱 $i$ 中已知的标准差，以及 $f(x_i;\\boldsymbol{\\theta})$ 表示依赖于参数向量 $\\boldsymbol{\\theta} \\in \\mathbb{R}^k$ 的线性模型预测。在高斯噪声假设下，对数似然函数与加权最小二乘目标函数仅相差一个加性常数，因此最小化负对数似然等价于最小化加权残差平方和。将 $\\chi^2$ 目标函数表示为\n$$\n\\chi^2(\\boldsymbol{\\theta}) \\equiv \\sum_{i=1}^{N} \\frac{\\left(y_i - f(x_i;\\boldsymbol{\\theta})\\right)^2}{\\sigma_i^2}.\n$$\n令 $\\hat{\\boldsymbol{\\theta}}$ 为最小化 $\\chi^2(\\boldsymbol{\\theta})$ 的参数向量。最小值为 $\\chi^2_{\\min} = \\chi^2(\\hat{\\boldsymbol{\\theta}})$。模型的拟合优度（goodness-of-fit）可以通过将 $\\chi^2_{\\min}$ 与一个参考分布进行比较来评估，该参考分布由高斯模型和自由度（DoF）导出，对于具有满秩设计矩阵的线性模型，自由度定义为 $\\nu \\equiv N - k$。此外，Wilks 定理指出，在标准正则性条件下和渐近情况下，差值\n$$\n\\Delta \\chi^2(\\boldsymbol{\\theta}) \\equiv \\chi^2(\\boldsymbol{\\theta}) - \\chi^2_{\\min}\n$$\n服从卡方（chi-squared）随机变量分布，其自由度由约束参数的数量（即感兴趣参数的数量）给出，前提是已经对讨厌参数（nuisance parameters）进行了剖析（profiled，即最小化）。这允许在参数空间中构建由 $\\Delta \\chi^2(\\boldsymbol{\\theta}) \\le q_\\alpha$ 定义的置信区域，其中 $q_\\alpha$ 是对应于置信水平 $\\alpha$ 和相应卡方分布的上尾分位数。\n\n任务。编写一个完整的、自包含的程序，该程序：\n- 实现加权线性最小二乘估计，以获得 $\\hat{\\boldsymbol{\\theta}}$、$\\chi^2_{\\min}$ 以及拟合优度 $p$-值。此 $p$-值用于检验原假设，即数据可由某个真实参数向量的模型描述，其中使用 $\\nu = N - k$ 个自由度和卡方参考分布。\n- 通过 $\\Delta \\chi^2$ 实现 Wilks 定理的置信区域构建，用于：\n  - 当所有参数都为感兴趣参数时，在完整参数空间中的联合置信区域。\n  - 当其余参数被视为讨厌参数并对其进行最小时，为单个感兴趣参数构建剖析置信区间。\n\n仅使用下面给出的数据集。所有量都是无量纲的。不涉及角度。所有置信水平都表示为 $[0,1]$ 区间内的小数。\n\n数据集和模型：\n- 情况 1（单参数模板拟合）：对于 $i \\in \\{1,\\dots,5\\}$，定义模板向量 $t_i$ 为 $t = [1,2,3,4,5]$。模型为 $f_i(a) = a\\,t_i$，参数为 $a \\in \\mathbb{R}$。观测数据和不确定度为 $y = [1.1, 2.0, 2.9, 4.1, 4.9]$ 和 $\\sigma = [1,1,1,1,1]$。计算：\n  - 使用 $\\nu = N - k = 5 - 1 = 4$ 计算最佳拟合值 $\\hat{a}$ 和拟合优度 $p$-值。\n  - 使用含一个感兴趣参数的 Wilks 定理，通过检验 $\\Delta \\chi^2(a_0)$ 和 $\\Delta \\chi^2(a_1)$ 是否小于或等于对应于 1 个自由度的卡方分位数，来判断固定值 $a_0 = 1.3$ 和 $a_1 = 1.1$ 是否分别位于 $\\alpha = 0.95$ 和 $\\alpha = 0.68$ 的置信区间内。\n- 情况 2（双参数加权线性模型）：令 $x = [-3,-2,-1,0,1,2,3,4]$，模型为 $f_i(a,b) = a + b\\,x_i$，参数为 $(a,b) \\in \\mathbb{R}^2$。观测数据和不确定度为 $y = [-0.7, 0.1, 0.6, 1.1, 1.6, 2.0, 2.7, 3.1]$ 和 $\\sigma = [0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2]$。计算：\n  - 使用 $\\nu = N - k = 8 - 2 = 6$ 计算最佳拟合值 $(\\hat{a},\\hat{b})$ 和拟合优度 $p$-值。\n  - 使用含两个感兴趣参数的 Wilks 定理构建联合区域，通过检验 $\\Delta \\chi^2(a,b)$ 是否小于或等于对应于 2 个自由度的卡方分位数，来判断点 $(a,b) = (1.169, 0.527381)$ 和 $(a,b) = (1.209, 0.527381)$ 是否位于 $\\alpha = 0.90$ 的置信区域内。\n  - 使用含一个感兴趣参数 $a$ 的剖析版 Wilks 定理（将 $b$ 视为讨厌参数并对其进行最小化），通过检验剖析的 $\\Delta \\chi^2_{\\mathrm{prof}}(a)$ 是否小于或等于对应于 1 个自由度的卡方分位数，来判断固定值 $a_2 = 1.169$ 和 $a_3 = 1.209$ 是否位于 $\\alpha = 0.95$ 的置信区间内。\n- 情况 3（具有异方差不确定度的单参数模板拟合）：对于 $i \\in \\{1,\\dots,6\\}$，定义模板向量 $t = [1.0, 0.5, 2.0, 1.5, 3.0, 2.5]$。模型为 $f_i(a) = a\\,t_i$。观测数据和不确定度为 $y = [2.1, 1.0, 4.1, 2.9, 6.2, 5.1]$ 和 $\\sigma = [0.3, 0.2, 0.5, 0.4, 0.6, 0.5]$。计算：\n  - 使用 $\\nu = N - k = 6 - 1 = 5$ 计算最佳拟合值 $\\hat{a}$ 和拟合优度 $p$-值。\n  - 使用含一个感兴趣参数的 Wilks 定理，通过检验 $\\Delta \\chi^2(a)$ 是否小于或等于对应于 1 个自由度的卡方分位数，来判断固定值 $a_4 = 2.2$ 和 $a_5 = 2.5$ 是否位于 $\\alpha = 0.99$ 的置信区间内。\n\n算法和统计要求：\n- 从独立分箱的高斯似然和 $\\chi^2(\\boldsymbol{\\theta})$ 的定义出发；推导线性模型的加权正规方程，并使用设计矩阵形式和对角权重矩阵 $W = \\mathrm{diag}(1/\\sigma_i^2)$ 求解 $\\hatboldsymbol{\\theta}$。\n- 根据 $\\chi^2_{\\min}$ 和 $\\nu$ 个自由度，从卡方生存函数计算 $\\chi^2_{\\min}$ 和拟合优度 $p$-值。\n- 对于任意候选参数向量 $\\boldsymbol{\\theta}_0$，计算 $\\Delta \\chi^2(\\boldsymbol{\\theta}_0)$。对于剖析单参数检验，通过加权正规方程所蕴含的线性代数方法，对讨厌参数进行解析最小化。\n- 通过将 $\\Delta \\chi^2$ 与指定置信水平和自由度下的卡方分位数进行比较，来确定是否属于置信区域。\n\n测试套件和最终输出规范：\n- 精确使用上述三种情况作为测试套件。\n- 对每种情况，按顺序返回一个包含以下元素的列表：\n  - 情况 1: [`$\\hat{a}$`, `$p$-value`, `inside_C0.95_a=1.3`, `inside_C0.68_a=1.1`]。\n  - 情况 2: [[`$\\hat{a}$`, `$\\hat{b}$`], `$p$-value`, `inside_C0.90_2D(1.169,0.527381)`, `inside_C0.90_2D(1.209,0.527381)`, `inside_C0.95_profile_a=1.169`, `inside_C0.95_profile_a=1.209`]。\n  - 情况 3: [`$\\hat{a}$`, `$p$-value`, `inside_C0.99_a=2.2`, `inside_C0.99_a=2.5`]。\n- 将所有浮点数输出四舍五入到 6 位小数。布尔值应为精确的逻辑值。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，`[result1,result2,result3]`）。输出行中不允许有任何额外的文本或空格。", "solution": "用户提供的问题是一个关于线性统计模型的恰当练习，具体涉及加权最小二乘估计和应用 Wilks 定理构建置信区域。问题陈述在科学上是合理的，内容是自包含的，并且在算法上是可处理的。因此，该问题被认为是有效的，下面将给出完整解法。\n\n### 理论框架\n\n问题的核心是最小化一个在其参数上呈线性的模型的卡方（$\\chi^2$）目标函数。\n\n给定一组 $N$ 个数据点 $(x_i, y_i)$，其测量值 $y_i$ 的不确定度为 $\\sigma_i$，以及一个在 $k$ 个参数 $\\boldsymbol{\\theta} \\in \\mathbb{R}^k$ 上呈线性的模型函数 $f(x_i; \\boldsymbol{\\theta})$，我们可以将该模型表示为矩阵形式：\n$$\n\\mathbb{E}[\\boldsymbol{y}] = \\boldsymbol{f}(\\boldsymbol{x}; \\boldsymbol{\\theta}) = A \\boldsymbol{\\theta}\n$$\n其中 $\\boldsymbol{y} = (y_1, \\dots, y_N)^T$ 是观测值向量，$A$ 是 $N \\times k$ 的设计矩阵，$\\boldsymbol{\\theta} = (\\theta_1, \\dots, \\theta_k)^T$ 是参数向量。设计矩阵的元素 $A_{ij}$ 是模型中第 $i$ 个数据点对应的第 $j$ 个参数的系数。\n\n假设高斯不确定度是独立的，$\\chi^2$ 目标函数是加权残差平方和：\n$$\n\\chi^2(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left(\\frac{y_i - f(x_i; \\boldsymbol{\\theta})}{\\sigma_i}\\right)^2\n$$\n用矩阵表示法，这变为：\n$$\n\\chi^2(\\boldsymbol{\\theta}) = (\\boldsymbol{y} - A\\boldsymbol{\\theta})^T W (\\boldsymbol{y} - A\\boldsymbol{\\theta})\n$$\n其中 $W$ 是对角权重矩阵，其元素为 $W_{ii} = 1/\\sigma_i^2$。\n\n为了找到最小化 $\\chi^2$ 的参数向量 $\\hat{\\boldsymbol{\\theta}}$，我们将 $\\chi^2(\\boldsymbol{\\theta})$ 对 $\\boldsymbol{\\theta}$ 的梯度设为零：\n$$\n\\nabla_{\\boldsymbol{\\theta}} \\chi^2(\\boldsymbol{\\theta}) = -2 A^T W \\boldsymbol{y} + 2 A^T W A \\boldsymbol{\\theta} = \\boldsymbol{0}\n$$\n这得到了**正规方程**：\n$$\n(A^T W A) \\boldsymbol{\\theta} = A^T W \\boldsymbol{y}\n$$\n假设设计矩阵 $A$ 具有满列秩，则矩阵 $A^T W A$ 是可逆的。那么 $\\boldsymbol{\\theta}$ 的最佳拟合估计量为：\n$$\n\\hat{\\boldsymbol{\\theta}} = (A^T W A)^{-1} (A^T W \\boldsymbol{y})\n$$\n$\\chi^2$ 函数的最小值，记为 $\\chi^2_{\\min}$，通过将 $\\hat{\\boldsymbol{\\theta}}$ 代回目标函数得到：\n$$\n\\chi^2_{\\min} = \\chi^2(\\hat{\\boldsymbol{\\theta}}) = (\\boldsymbol{y} - A\\hat{\\boldsymbol{\\theta}})^T W (\\boldsymbol{y} - A\\hat{\\boldsymbol{\\theta}})\n$$\n在原假设下，即数据是由模型 $f(x_i; \\boldsymbol{\\theta}_{\\text{true}})$ 为某个真实参数向量 $\\boldsymbol{\\theta}_{\\text{true}}$ 生成的，统计量 $\\chi^2_{\\min}$ 服从具有 $\\nu = N - k$ 个自由度的卡方分布。拟合优度可以用 $p$-值来量化，即获得一个等于或大于观测到的 $\\chi^2_{\\min}$ 值的概率。这可以通过使用 $\\chi^2(\\nu)$ 分布的生存函数（1 - CDF）来计算：\n$$\np\\text{-value} = P(\\chi^2_\\nu \\ge \\chi^2_{\\min}) = \\text{sf}(\\chi^2_{\\min}, \\nu)\n$$\n\n### 通过 Wilks 定理构建置信区域\n\nWilks 定理指出，统计量 $\\Delta\\chi^2(\\boldsymbol{\\theta}) \\equiv \\chi^2(\\boldsymbol{\\theta}) - \\chi^2_{\\min}$ 服从卡方变量分布。该分布的自由度 $d$ 等于被检验的感兴趣参数的数量。\n\n对于一组 $d$ 个参数，置信水平为 $\\alpha$ 的置信区域是所有满足以下条件的参数点 $\\boldsymbol{\\theta}_0$ 的集合：\n$$\n\\Delta\\chi^2(\\boldsymbol{\\theta}_0) \\le q_\\alpha\n$$\n其中 $q_\\alpha$ 是 $\\chi^2(d)$ 分布的上尾分位数，即 $P(\\chi^2_d \\le q_\\alpha) = \\alpha$。这个临界值可以使用百分点函数（逆 CDF）找到。\n\n对于线性模型，可以推导出一个计算效率高的 $\\Delta\\chi^2$ 公式：\n$$\n\\Delta\\chi^2(\\boldsymbol{\\theta}_0) = (\\boldsymbol{\\theta}_0 - \\hat{\\boldsymbol{\\theta}})^T (A^T W A) (\\boldsymbol{\\theta}_0 - \\hat{\\boldsymbol{\\theta}})\n$$\n\n对于单个参数（例如 $\\theta_j$）的剖析置信区间，我们将其余 $k-1$ 个参数视为讨厌参数。对于每个固定值 $\\theta_j = \\theta_{j,0}$，我们对讨厌参数最小化 $\\chi^2$。得到的剖析统计量 $\\Delta\\chi^2_{\\text{prof}}(\\theta_{j,0})$ 服从 $\\chi^2(1)$ 分布。对于线性模型，这简化为：\n$$\n\\Delta\\chi^2_{\\text{prof}}(\\theta_{j,0}) = \\frac{(\\theta_{j,0} - \\hat{\\theta}_j)^2}{C_{jj}}\n$$\n其中 $C = (A^T W A)^{-1}$ 是最小二乘估计量的协方差矩阵，而 $C_{jj}$ 是其第 $j$ 个对角元素（即 $\\hat{\\theta}_j$ 的方差）。\n\n### 算法实现策略\n\n将定义一个通用函数来解决加权线性最小二乘问题。该函数以设计矩阵 $A$、数据向量 $\\boldsymbol{y}$ 和不确定度向量 $\\boldsymbol{\\sigma}$ 作为输入。它计算并返回最佳拟合参数 $\\hat{\\boldsymbol{\\theta}}$、最小 $\\chi^2$、协方差矩阵 $C$ 和拟合优度 $p$-值。然后，针对每种情况的特定函数将使用这些结果来执行所需的置信区域检验。\n\n#### 情况 1：单参数模板拟合\n- 模型: $f_i(a) = a\\,t_i$.\n- 参数: $\\boldsymbol{\\theta} = [a]$.\n- 设计矩阵: $A$ 是一个由模板 $t$ 给出的 $N \\times 1$ 矩阵（列向量）。\n- $N=5$, $k=1$, $\\nu=4$。对于置信区间（CI）检验，$d=1$。\n- 不确定度是同方差的（$\\sigma_i=1$），所以 $W=I$。\n\n#### 情况 2：双参数线性模型\n- 模型: $f_i(a,b) = a + b\\,x_i$.\n- 参数: $\\boldsymbol{\\theta} = [a, b]^T$.\n- 设计矩阵: $A$ 是一个 $N \\times 2$ 矩阵，第一列全为 1，第二列为值 $x_i$。\n- $N=8$, $k=2$, $\\nu=6$。\n- 对于联合置信区域检验，我们使用 $\\Delta\\chi^2(\\boldsymbol{\\theta}_0)$ 且 $d=2$。\n- 对于 $a$ 的剖析置信区间，我们使用 $\\Delta\\chi^2_{\\text{prof}}(a_0)$ 且 $d=1$。\n\n#### 情况 3：异方差模板拟合\n- 模型: $f_i(a) = a\\,t_i$.\n- 参数: $\\boldsymbol{\\theta} = [a]$.\n- 设计矩阵: $A$ 是一个由模板 $t$ 给出的 $N \\times 1$ 矩阵。\n- $N=6$, $k=1$, $\\nu=5$。对于置信区间（CI）检验，$d=1$。\n- 不确定度是异方差的，所以权重矩阵 $W$ 是对角矩阵，但不是单位矩阵的倍数。需要使用完整的加权最小二乘法。\n\n每个情况的计算将使用 `numpy` 进行矩阵运算，使用 `scipy.stats.chi2` 进行分位数和生存函数的计算。所有浮点结果都按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve_weighted_least_squares(A, y, sigma):\n    \"\"\"\n    Solves a weighted linear least-squares problem.\n    \n    Args:\n        A (np.ndarray): Design matrix (N x k).\n        y (np.ndarray): Observed data vector (N,).\n        sigma (np.ndarray): Uncertainties vector (N,).\n\n    Returns:\n        tuple: A tuple containing:\n            - theta_hat (np.ndarray): Best-fit parameters (k,).\n            - chi2_min (float): Minimum chi-squared value.\n            - C (np.ndarray): Covariance matrix of parameters (k x k).\n            - p_value (float): Goodness-of-fit p-value.\n            - A_T_W_A (np.ndarray): The matrix (A^T W A) for delta chi2 calculations.\n    \"\"\"\n    N, k = A.shape\n    W = np.diag(1 / sigma**2)\n\n    # Normal equations: (A^T W A) theta = A^T W y\n    A_T_W_A = A.T @ W @ A\n    A_T_W_y = A.T @ W @ y\n    \n    # Covariance matrix and best-fit parameters\n    C = np.linalg.inv(A_T_W_A)\n    theta_hat = C @ A_T_W_y\n    \n    # Minimum chi-squared\n    residuals = y - A @ theta_hat\n    chi2_min = residuals.T @ W @ residuals\n    \n    # Goodness-of-fit p-value\n    dof = N - k\n    p_value = chi2.sf(chi2_min, df=dof)\n    \n    return theta_hat, chi2_min, C, p_value, A_T_W_A\n\ndef format_results(data):\n    \"\"\"\n    Recursively formats results, rounding floats and leaving booleans.\n    \"\"\"\n    if isinstance(data, list):\n        return [format_results(item) for item in data]\n    if isinstance(data, (float, np.floating)):\n        return round(data, 6)\n    return data\n\ndef solve_case1():\n    \"\"\"Calculates and returns results for Case 1.\"\"\"\n    y = np.array([1.1, 2.0, 2.9, 4.1, 4.9])\n    sigma = np.array([1.0, 1.0, 1.0, 1.0, 1.0])\n    t = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n    A = t.reshape(-1, 1)\n\n    a_hat_vec, chi2_min, _, p_value, A_T_W_A = solve_weighted_least_squares(A, y, sigma)\n    a_hat = a_hat_vec[0]\n\n    # Confidence interval tests for a\n    def check_ci(a_test, alpha):\n        theta_test = np.array([a_test])\n        theta_hat = np.array([a_hat])\n        delta_chi2 = (theta_test - theta_hat).T @ A_T_W_A @ (theta_test - theta_hat)\n        q_alpha = chi2.ppf(alpha, df=1)\n        return delta_chi2 = q_alpha\n\n    inside_c095_a13 = check_ci(1.3, 0.95)\n    inside_c068_a11 = check_ci(1.1, 0.68)\n    \n    return [a_hat, p_value, inside_c095_a13, inside_c068_a11]\n\ndef solve_case2():\n    \"\"\"Calculates and returns results for Case 2.\"\"\"\n    x = np.array([-3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0])\n    y = np.array([-0.7, 0.1, 0.6, 1.1, 1.6, 2.0, 2.7, 3.1])\n    sigma = np.array([0.2] * 8)\n    A = np.vstack([np.ones_like(x), x]).T\n\n    theta_hat, chi2_min, C, p_value, A_T_W_A = solve_weighted_least_squares(A, y, sigma)\n\n    # Joint confidence region tests (d=2)\n    def check_joint_cr(theta_test, alpha):\n        delta_chi2 = (theta_test - theta_hat).T @ A_T_W_A @ (theta_test - theta_hat)\n        q_alpha = chi2.ppf(alpha, df=2)\n        return delta_chi2 = q_alpha\n\n    pt1 = np.array([1.169, 0.527381])\n    pt2 = np.array([1.209, 0.527381])\n    inside_cr90_pt1 = check_joint_cr(pt1, 0.90)\n    inside_cr90_pt2 = check_joint_cr(pt2, 0.90)\n\n    # Profiled confidence interval tests for a (d=1)\n    def check_profiled_ci(a_test, alpha):\n        delta_chi2_prof = (a_test - theta_hat[0])**2 / C[0, 0]\n        q_alpha = chi2.ppf(alpha, df=1)\n        return delta_chi2_prof = q_alpha\n\n    inside_ci95_a1169 = check_profiled_ci(1.169, 0.95)\n    inside_ci95_a1209 = check_profiled_ci(1.209, 0.95)\n\n    return [list(theta_hat), p_value, inside_cr90_pt1, inside_cr90_pt2, inside_ci95_a1169, inside_ci95_a1209]\n\ndef solve_case3():\n    \"\"\"Calculates and returns results for Case 3.\"\"\"\n    t = np.array([1.0, 0.5, 2.0, 1.5, 3.0, 2.5])\n    y = np.array([2.1, 1.0, 4.1, 2.9, 6.2, 5.1])\n    sigma = np.array([0.3, 0.2, 0.5, 0.4, 0.6, 0.5])\n    A = t.reshape(-1, 1)\n\n    a_hat_vec, chi2_min, _, p_value, A_T_W_A = solve_weighted_least_squares(A, y, sigma)\n    a_hat = a_hat_vec[0]\n\n    # Confidence interval tests for a\n    def check_ci(a_test, alpha):\n        theta_test = np.array([a_test])\n        theta_hat = np.array([a_hat])\n        delta_chi2 = (theta_test - theta_hat).T @ A_T_W_A @ (theta_test - theta_hat)\n        q_alpha = chi2.ppf(alpha, df=1)\n        return delta_chi2 = q_alpha\n\n    inside_c099_a22 = check_ci(2.2, 0.99)\n    inside_c099_a25 = check_ci(2.5, 0.99)\n    \n    return [a_hat, p_value, inside_c099_a22, inside_c099_a25]\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final output.\n    \"\"\"\n    result1 = solve_case1()\n    result2 = solve_case2()\n    result3 = solve_case3()\n\n    all_results = [\n        format_results(result1),\n        format_results(result2),\n        format_results(result3)\n    ]\n    \n    # Use str() to handle nested lists and booleans correctly\n    # and replace spaces for compactness\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3507420"}, {"introduction": "在掌握了基础应用之后，我们将探讨一个关键的边界情况，此时威尔科斯定理的假设不再成立。通过为一个位于物理边界（例如不能为负的质量或截面）的参数模拟数据，你将凭经验发现标准 $chi^2$ 分布（自由度为1）的失效，并学会使用“玩具蒙特卡洛”（toy Monte Carlo）这一强大技术来推导正确的置信区间。这个练习强调了批判性地评估统计定理适用性的重要性。[@problem_id:3507406]", "problem": "考虑一个用于带有高斯不确定度的分箱截面测量的单参数有效场论 (EFT) 模板。设分箱 $i = 1, \\dots, N_{\\mathrm{bins}}$ 的预测均值为 $m_i(\\theta) = b_i + s_i \\,\\theta$，其中 $\\theta \\ge 0$ 是一个受零点物理边界约束的无量纲 EFT 耦合常数，$b_i, s_i$ 分别是已知的各分箱的本底和信号模板。观测数据为 $x_i$，建模为独立的高斯随机变量，其均值为 $m_i(\\theta_{\\mathrm{true}})$，标准差为已知的 $\\sigma_i$。对于给定的 $\\theta$ 和观测值 $x$，定义卡方函数为\n$$\n\\chi^2(\\theta; x) \\;=\\; \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{\\left(x_i - b_i - s_i \\,\\theta\\right)^2}{\\sigma_i^2}.\n$$\n剖面最佳拟合值 $\\hat{\\theta}$ 在物理边界 $\\theta \\ge 0$ 的约束下最小化 $\\chi^2(\\theta;x)$。对于原假设参数值 $\\theta_0$，似然比检验统计量是剖面差值\n$$\n\\Delta \\chi^2(\\theta_0; x) \\;=\\; \\chi^2(\\theta_0; x) \\;-\\; \\min_{\\theta \\ge 0} \\chi^2(\\theta; x).\n$$\n在满足正则性条件的渐近区，威尔克斯定理 (Wilks’ theorem) 指出，对于单个参数，$\\Delta \\chi^2$ 服从自由度为 1 的卡方分布。然而，在小样本情况下以及当参数接近物理边界时，渐近预测可能会失效。您的任务是使用玩具蒙特卡洛 (toy Monte Carlo) 方法，经验性地研究威尔克斯定理的有效性，并定义修正的置信区域。\n\n从第一性原理和核心定义出发，实现以下步骤：\n- 模型设定：使用 $N_{\\mathrm{bins}} = 3$，以及无量纲数组 $b = [10.0,12.0,8.0]$、$s = [4.0,6.0,3.0]$ 和 $\\sigma = [3.2,3.5,3.0]$。这些在所有测试中保持不变。\n- 估计：对于任何观测值 $x$，在 $\\theta \\ge 0$ 的范围内最小化 $\\chi^2(\\theta;x)$ 以获得 $\\hat{\\theta}$ 和 $\\chi^2_{\\min}(x) = \\chi^2(\\hat{\\theta}; x)$。\n- 检验统计量：对于给定的 $\\theta_0$，计算 $\\Delta \\chi^2(\\theta_0;x)$。\n- 覆盖率研究（威尔克斯）：对于每个测试案例，通过从均值为 $m_i(\\theta_{\\mathrm{true}})$、标准差为 $\\sigma_i$ 的高斯分布中抽取每个 $x_i^{(t)}$，来生成 $N_{\\mathrm{toys}}$ 个独立的玩具实验 $x^{(t)}$。为每个玩具实验计算 $\\Delta \\chi^2(\\theta_{\\mathrm{true}}; x^{(t)})$。使用自由度为 1 的卡方分布的理论 95% 分位数 $q_{0.95}^{(\\chi^2_1)}$，计算经验覆盖率，即满足 $\\Delta \\chi^2(\\theta_{\\mathrm{true}}; x^{(t)}) \\le q_{0.95}^{(\\chi^2_1)}$ 条件的玩具实验所占的比例。将覆盖率表示为小数。\n- 拟合优度有效性检验：使用 $\\Delta \\chi^2(\\theta_{\\mathrm{true}}; x)$ 的玩具实验分布，与自由度为 1 的 $\\chi^2$ 分布的累积分布函数进行柯尔莫哥洛夫-斯米尔诺夫 (Kolmogorov–Smirnov, KS) 检验。报告 KS 检验在 0.05 的显著性水平下是否未能拒绝威尔克斯假设；返回一个布尔值。\n- 修正的置信阈值：将修正的 95% 阈值 $q_{0.95}^{\\mathrm{corr}}$ 定义为 $\\Delta \\chi^2(\\theta_{\\mathrm{true}}; x)$ 的玩具实验分布的经验 95 百分位数。\n- 置信区间构建：对于每个测试案例中的单个观测数据集 $\\tilde{x}$，构建基于威尔克斯定理的和修正后的 95% 置信区间，该区间为满足 $\\chi^2(\\theta; \\tilde{x}) \\le \\chi^2_{\\min}(\\tilde{x}) + q$ 条件（其中 $q \\in \\{q_{0.95}^{(\\chi^2_1)}, q_{0.95}^{\\mathrm{corr}}\\}$）的 $\\theta \\ge 0$ 的集合。以无量纲耦合单位的浮点数形式报告区间端点。\n\n使用以下测试套件（每个案例均使用无量纲单位）：\n- 案例 1 (边界)：$\\theta_{\\mathrm{true}} = 0.0$， $N_{\\mathrm{toys}} = 10000$，玩具实验随机种子 $12345$，观测数据集种子 $54321$。\n- 案例 2 (近边界)：$\\theta_{\\mathrm{true}} = 0.05$， $N_{\\mathrm{toys}} = 10000$，玩具实验随机种子 $23456$，观测数据集种子 $65432$。\n- 案例 3 (内部)：$\\theta_{\\mathrm{true}} = 0.5$, $N_{\\mathrm{toys}} = 10000$, 玩具实验随机种子 $34567$, 观测数据集种子 $76543$。\n\n您的程序应为每个案例计算：\n1. 使用 $q_{0.95}^{(\\chi^2_1)}$ 计算的经验覆盖率（小数形式）。\n2. 修正后的阈值 $q_{0.95}^{\\mathrm{corr}}$（浮点数）。\n3. KS 检验的决策，以布尔值表示在 0.05 水平上是否未拒绝威尔克斯假设。\n4. 观测数据集的基于威尔克斯定理的置信区间端点 $(\\theta_{\\mathrm{low}}^{\\mathrm{Wilks}}, \\theta_{\\mathrm{high}}^{\\mathrm{Wilks}})$。\n5. 观测数据集的修正后的置信区间端点 $(\\theta_{\\mathrm{low}}^{\\mathrm{corr}}, \\theta_{\\mathrm{high}}^{\\mathrm{corr}})$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个内部列表的列表（每个测试案例对应一个）。每个内部列表必须严格按以下顺序包含七个条目：\n$$\n\\left[\\mathrm{coverage},\\; q_{0.95}^{\\mathrm{corr}},\\; \\mathrm{KS\\_pass},\\; \\theta_{\\mathrm{low}}^{\\mathrm{Wilks}},\\; \\theta_{\\mathrm{high}}^{\\mathrm{Wilks}},\\; \\theta_{\\mathrm{low}}^{\\mathrm{corr}},\\; \\theta_{\\mathrm{high}}^{\\mathrm{corr}}\\right].\n$$\n例如，程序应打印一个形如\n$$\n\\left[ [c_1,q_1,p_1,w\\ell_1,wh_1,cl_1,ch_1], [c_2,q_2,p_2,w\\ell_2,wh_2,cl_2,ch_2], [c_3,q_3,p_3,w\\ell_3,wh_3,cl_3,ch_3] \\right],\n$$\n的字符串，其中的数值条目使用无量纲单位，KS 决策使用布尔值。不应打印任何额外文本。", "solution": "这个问题要求对一个由单参数有效场论 (EFT) 模型描述的分箱截面测量进行全面的统计分析。核心任务包括通过卡方最小化进行参数估计，使用玩具蒙特卡洛模拟评估威尔克斯定理的有效性，以及构建修正的置信区间。\n\n### 1. 数学模型和 $\\chi^2$ 函数\n\n第 $i$ 个分箱中的预测事件数由 EFT 耦合参数 $\\theta$ 的线性函数给出：\n$$\nm_i(\\theta) = b_i + s_i \\theta\n$$\n其中 $b_i$ 是本底预测，$s_i$ 是来自 EFT 算符的信号缩放因子，$\\theta$ 是我们关心的参数。施加了物理约束 $\\theta \\ge 0$。假设每个分箱中的观测数据 $x_i$ 服从独立的高斯分布，其均值为 $m_i(\\theta_{\\mathrm{true}})$，标准差为已知的 $\\sigma_i$。\n\n$\\chi^2$ 函数，在此模型中作为负对数似然（相差一个常数），定义为：\n$$\n\\chi^2(\\theta; x) = \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{\\left(x_i - m_i(\\theta)\\right)^2}{\\sigma_i^2} = \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{\\left(x_i - b_i - s_i \\theta\\right)^2}{\\sigma_i^2}\n$$\n该函数是关于 $\\theta$ 的二次函数，可以展开为 $\\chi^2(\\theta) = A\\theta^2 - 2B\\theta + C$ 的形式，其中系数 $A$、$B$ 和 $C$ 是数据 $x$ 和固定模板的函数：\n$$\nA = \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{s_i^2}{\\sigma_i^2}\n$$\n$$\nB = \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{s_i(x_i - b_i)}{\\sigma_i^2}\n$$\n$$\nC = \\sum_{i=1}^{N_{\\mathrm{bins}}} \\frac{(x_i - b_i)^2}{\\sigma_i^2}\n$$\n由于 $A  0$，该抛物线开口向上，保证了唯一的全局最小值。\n\n### 2. 最佳拟合参数估计\n\n为了找到使 $\\chi^2(\\theta; x)$ 最小化的 $\\theta$ 值，我们首先通过将其导数设为零来找到无约束的最小值：\n$$\n\\frac{d\\chi^2}{d\\theta} = 2A\\theta - 2B = 0\n$$\n这得到了无约束的最佳拟合值，记为 $\\theta_{\\mathrm{uc}}$：\n$$\n\\theta_{\\mathrm{uc}}(x) = \\frac{B}{A} = \\frac{\\sum_i s_i(x_i - b_i)/\\sigma_i^2}{\\sum_i s_i^2/\\sigma_i^2}\n$$\n然而，问题规定了物理边界 $\\theta \\ge 0$。剖面最佳拟合估计值 $\\hat{\\theta}$ 是允许区域内使 $\\chi^2$ 最小化的 $\\theta$ 值。其计算方法如下：\n$$\n\\hat{\\theta}(x) = \\max(0, \\theta_{\\mathrm{uc}}(x))\n$$\n如果无约束最小值 $\\theta_{\\mathrm{uc}}$ 是物理的（即非负），那么它就是解。如果 $\\theta_{\\mathrm{uc}}$ 是负数，则物理区域 $\\theta \\ge 0$ 内的最小值位于边界上，即 $\\hat{\\theta} = 0$。对于给定的数据集 $x$，$\\chi^2$ 的最小值为 $\\chi^2_{\\min}(x) = \\chi^2(\\hat{\\theta}(x); x)$。\n\n### 3. 似然比检验统计量\n\n对于原假设 $\\theta_0$ 的检验统计量是剖面似然比，表示为 $\\chi^2$ 值的差：\n$$\n\\Delta \\chi^2(\\theta_0; x) = \\chi^2(\\theta_0; x) - \\chi^2_{\\min}(x) = \\chi^2(\\theta_0; x) - \\chi^2(\\hat{\\theta}; x)\n$$\n这个值可以被高效地计算。通过配方法，我们可以将 $\\chi^2(\\theta)$ 写成 $\\chi^2(\\theta) = A(\\theta - \\theta_{\\mathrm{uc}})^2 + \\chi^2(\\theta_{\\mathrm{uc}})$。将此代入 $\\Delta\\chi^2$ 的定义中，得到：\n$$\n\\Delta \\chi^2(\\theta_0; x) = \\left[A(\\theta_0 - \\theta_{\\mathrm{uc}})^2 + \\chi^2(\\theta_{\\mathrm{uc}})\\right] - \\left[A(\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 + \\chi^2(\\theta_{\\mathrm{uc}})\\right] = A \\left[ (\\theta_0 - \\theta_{\\mathrm{uc}})^2 - (\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 \\right]\n$$\n这种形式在计算上是高效的，因为它避免了重新计算完整的 $\\chi^2$ 总和。\n\n### 4. 蒙特卡洛模拟与覆盖率研究\n\n威尔克斯定理指出，在某些正则性条件下，$\\Delta\\chi^2(\\theta_{\\mathrm{true}}; x)$ 统计量渐近地服从自由度为 1 的卡方分布 ($\\chi^2_1$)。当真实参数值 $\\theta_{\\mathrm{true}}$ 位于参数空间的边界上时，这些条件不被满足。我们使用玩具蒙特卡洛模拟来研究此问题。\n\n对于由 $\\theta_{\\mathrm{true}}$ 定义的每个测试案例：\n1.  通过从高斯分布 $\\mathcal{N}(m_i(\\theta_{\\mathrm{true}}), \\sigma_i^2)$ 中抽取每个分箱值 $x_i^{(t)}$，生成 $N_{\\mathrm{toys}}$ 个伪数据集（玩具实验）$x^{(t)}$。\n2.  对于每个玩具实验 $x^{(t)}$，计算 $\\theta_{\\mathrm{uc}}(x^{(t)})$、$\\hat{\\theta}(x^{(t)})$ 和检验统计量 $\\Delta\\chi^2_t = \\Delta\\chi^2(\\theta_{\\mathrm{true}}; x^{(t)})$。\n3.  这 $N_{\\mathrm{toys}}$ 个 $\\Delta\\chi^2_t$ 值的集合构成了该检验统计量的经验概率分布。\n\n经验覆盖率是真实参数值包含在名义 95% 置信区间内的玩具实验所占的比例。这对应于 $\\Delta\\chi^2_t \\le q_{0.95}^{(\\chi^2_1)}$ 的玩具实验所占的比例，其中 $q_{0.95}^{(\\chi^2_1)} \\approx 3.841$ 是 $\\chi^2_1$ 分布的第 95 百分位数。如果威尔克斯定理成立，这个覆盖率应接近 0.95。\n\n### 5. 假设检验与修正阈值\n\n为了正式检验威尔克斯定理的有效性，我们进行柯尔莫哥洛夫-斯米尔诺夫 (KS) 检验。将玩具实验中 $\\Delta\\chi^2_t$ 值的经验累积分布函数 (CDF) 与 $\\chi^2_1$ 分布的理论 CDF 进行比较。如果检验的 p 值小于显著性水平 $\\alpha=0.05$，我们就拒绝数据服从 $\\chi^2_1$ 分布的原假设。\n\n当威尔克斯定理失效时，名义阈值 $q_{0.95}^{(\\chi^2_1)}$ 是不正确的。一个修正的阈值 $q_{0.95}^{\\mathrm{corr}}$ 可以通过经验确定，即为 $\\Delta\\chi^2_t$ 的玩具实验分布的第 95 百分位数。这确保了由此产生的置信区间将具有正确的覆盖率（通过构造）。\n\n### 6. 置信区间构建\n\n$\\theta$ 的置信区间是通过反转假设检验来构建的。对于一个观测数据集 $\\tilde{x}$，95% 置信区间是在 5% 水平上未被拒绝的 $\\theta$ 值的集合。这个集合是 $\\{\\theta \\ge 0 \\mid \\Delta\\chi^2(\\theta; \\tilde{x}) \\le q \\}$，其中 $q$ 是所选的阈值（对于基于威尔克斯的区间是 $q_{0.95}^{(\\chi^2_1)}$，对于修正的区间是 $q_{0.95}^{\\mathrm{corr}}$）。该条件可以写成：\n$$\n\\chi^2(\\theta; \\tilde{x}) \\le \\chi^2_{\\min}(\\tilde{x}) + q\n$$\n使用表达式 $\\Delta\\chi^2(\\theta; \\tilde{x}) = A [ (\\theta - \\theta_{\\mathrm{uc}})^2 - (\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 ]$，不等式变为：\n$$\nA [ (\\theta - \\theta_{\\mathrm{uc}})^2 - (\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 ] \\le q\n$$\n$$\n(\\theta - \\theta_{\\mathrm{uc}})^2 \\le (\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 + \\frac{q}{A}\n$$\n该不等式定义了一个围绕 $\\theta_{\\mathrm{uc}}$ 的对称区间：\n$$\n\\theta_{\\mathrm{uc}} - \\delta \\le \\theta \\le \\theta_{\\mathrm{uc}} + \\delta\n$$\n其中 $\\delta = \\sqrt{(\\hat{\\theta} - \\theta_{\\mathrm{uc}})^2 + q/A}$。考虑到物理边界 $\\theta \\ge 0$，最终的置信区间是 $[\\theta_{\\mathrm{low}}, \\theta_{\\mathrm{high}}]$：\n$$\n\\theta_{\\mathrm{low}} = \\max\\left(0, \\theta_{\\mathrm{uc}} - \\delta\\right)\n$$\n$$\n\\theta_{\\mathrm{high}} = \\theta_{\\mathrm{uc}} + \\delta\n$$\n对于每个测试案例，此过程都应用于生成的“观测”数据集 $\\tilde{x}$，同时使用威尔克斯阈值和修正阈值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2, kstest\n\ndef solve():\n    \"\"\"\n    Performs a statistical analysis of an EFT model, including chi-squared minimization,\n    coverage studies via toy MC, and confidence interval construction.\n    \"\"\"\n    # Fixed model parameters (dimensionless)\n    b = np.array([10.0, 12.0, 8.0])\n    s = np.array([4.0, 6.0, 3.0])\n    sigma = np.array([3.2, 3.5, 3.0])\n\n    # Pre-calculate the coefficient 'A' of the quadratic chi-squared function,\n    # as it is independent of the data.\n    # chi^2(theta) = A*theta^2 - 2*B*theta + C\n    A = np.sum((s / sigma)**2)\n\n    # Theoretical 95% quantile of the chi-square distribution with 1 d.o.f.\n    # This is the threshold 'q' used for Wilks-based intervals.\n    q_wilks = chi2.ppf(0.95, 1)\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        # (theta_true, N_toys, toy_seed, observed_data_seed)\n        (0.0, 10000, 12345, 54321),\n        (0.05, 10000, 23456, 65432),\n        (0.5, 10000, 34567, 76543),\n    ]\n\n    all_results = []\n    \n    for theta_true, N_toys, toy_seed, obs_seed in test_cases:\n        # --- Part 1: Toy Monte Carlo Simulation to study Delta chi^2 distribution ---\n        rng_toy = np.random.default_rng(toy_seed)\n        \n        # Calculate true means for toy generation\n        m_true = b + s * theta_true\n        \n        delta_chi2_toys = np.zeros(N_toys)\n        \n        for t in range(N_toys):\n            # Generate a toy dataset x by sampling from Gaussian distributions\n            x_toy = rng_toy.normal(loc=m_true, scale=sigma)\n            \n            # For the toy data, find the best-fit parameter theta_hat\n            # B_toy is the coefficient of the linear term in the chi-squared function\n            B_toy = np.sum(s * (x_toy - b) / sigma**2)\n            theta_uc_toy = B_toy / A  # Unconstrained best-fit\n            theta_hat_toy = np.maximum(0.0, theta_uc_toy) # Constrained best-fit\n\n            # Calculate the test statistic Delta chi^2(theta_true; x_toy)\n            # Delta_chi2 = chi2(theta_true) - chi2(theta_hat)\n            # This is equivalent to A * ((theta_true - theta_uc)^2 - (theta_hat - theta_uc)^2)\n            delta_chi2 = A * ((theta_true - theta_uc_toy)**2 - (theta_hat_toy - theta_uc_toy)**2)\n            delta_chi2_toys[t] = delta_chi2\n\n        # Filter out any small negative values from floating point inaccuracies\n        delta_chi2_toys = np.maximum(0, delta_chi2_toys)\n\n        # --- Part 2: Analyze the toy distribution ---\n\n        # 1. Empirical Coverage using Wilks' threshold\n        coverage = np.sum(delta_chi2_toys = q_wilks) / N_toys\n        \n        # 2. Corrected 95% Threshold (q_corr)\n        q_corr = np.percentile(delta_chi2_toys, 95)\n        \n        # 3. KS test for Wilks' hypothesis validity\n        # Null hypothesis: the toy delta_chi2 distribution is a chi2 with 1 d.o.f.\n        ks_statistic, p_value = kstest(delta_chi2_toys, 'chi2', args=(1,))\n        ks_pass = p_value > 0.05  # True if we fail to reject the null at alpha=0.05\n\n        # --- Part 3: Confidence Interval for a single \"observed\" dataset ---\n        \n        rng_obs = np.random.default_rng(obs_seed)\n        x_obs = rng_obs.normal(loc=m_true, scale=sigma)\n        \n        # Find best-fit theta for the observed data\n        B_obs = np.sum(s * (x_obs - b) / sigma**2)\n        theta_uc_obs = B_obs / A\n        theta_hat_obs = np.maximum(0.0, theta_uc_obs)\n\n        def get_interval(q_val, theta_uc, theta_hat):\n            \"\"\"Calculates the confidence interval for a given threshold q.\"\"\"\n            # The interval is defined by chi2(theta) = chi2_min + q, which solves to:\n            # |theta - theta_uc|^2 = |theta_hat - theta_uc|^2 + q/A\n            delta = np.sqrt((theta_hat - theta_uc)**2 + q_val / A)\n            low = np.maximum(0.0, theta_uc - delta)\n            high = theta_uc + delta\n            return low, high\n\n        # 4. Wilks-based confidence interval\n        wilks_low, wilks_high = get_interval(q_wilks, theta_uc_obs, theta_hat_obs)\n        \n        # 5. Corrected confidence interval\n        corr_low, corr_high = get_interval(q_corr, theta_uc_obs, theta_hat_obs)\n        \n        # Assemble results for this case in the specified order\n        case_results = [\n            coverage, q_corr, ks_pass, \n            wilks_low, wilks_high, \n            corr_low, corr_high\n        ]\n        all_results.append(case_results)\n\n    # Convert boolean to lower case for consistency if needed, but python default is fine.\n    # Format the final output string as a list of lists.\n    # str([1, 2, True]) -> '[1, 2, True]', which is a valid representation.\n    final_output_str = \"[\" + \",\".join([str(res) for res in all_results]) + \"]\"\n    \n    # Print the final result in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "3507406"}, {"introduction": "最后的这个实践项目将处理一个在实验物理中更复杂且真实的挑战：不适定反问题（ill-posed inverse problems），例如探测器解卷（unfolding）。在这种情况下，由于问题的高度不适定性，朴素的卡方最小化会失败。本练习引入了吉洪诺夫正则化（Tikhonov regularization）作为稳定解的方法，通过在 $\\chi^2$ 目标函数中加入惩罚项，以少量偏差（bias）换取方差（variance）的大幅降低。你还将学习如何计算“有效自由度”（effective degrees of freedom），以便对此类正则化模型的拟合优度进行恰当的评估。[@problem_id:3507369]", "problem": "考虑一个计算高能物理中典型的探测器解谱线性反演问题，其中一个真实的分箱谱 $t \\in \\mathbb{R}^{M}$ 通过一个已知的响应矩阵 $R \\in \\mathbb{R}^{N \\times M}$ 和可加的计数涨落，映射到观测到的分箱计数 $d \\in \\mathbb{R}^{N}$。假设测量误差服从高斯分布，其协方差为已知的对角矩阵 $V = \\mathrm{diag}(\\sigma_1^2,\\ldots,\\sigma_N^2)$。定义加权数据保真项\n$$\n\\chi^2_{\\mathrm{data}}(t) = (d - R t)^{\\top} V^{-1} (d - R t).\n$$\n为了对这个潜在的不适定问题进行正则化，考虑Tikhonov型二次罚项\n$$\n\\mathcal{P}_k(t) = \\| L_k t \\|_2^2,\n$$\n其中 $L_k$ 是一个阶数 $k \\in \\{0,1,2\\}$ 的离散线性算子，定义如下：\n- 对于 $k = 0$：$L_0 = I_M$（$M \\times M$ 的单位矩阵）。\n- 对于 $k = 1$：$L_1 \\in \\mathbb{R}^{(M-1) \\times M}$ 是一阶差分算子，其第 $i$ 行在第 $i$ 列的元素为 $-1$，在第 $i+1$ 列的元素为 $+1$，其他位置为零，其中 $i \\in \\{1,\\ldots,M-1\\}$。\n- 对于 $k = 2$：$L_2 \\in \\mathbb{R}^{(M-2) \\times M}$ 是二阶差分算子，其第 $i$ 行在第 $i$ 列的元素为 $+1$，在第 $i+1$ 列的元素为 $-2$，在第 $i+2$ 列的元素为 $+1$，其他位置为零，其中 $i \\in \\{1,\\ldots,M-2\\}$。\n\n对于给定的非负正则化强度 $\\lambda \\ge 0$，定义带罚项的目标函数\n$$\n\\chi^2_{\\mathrm{reg}}(t;\\lambda,k) = \\chi^2_{\\mathrm{data}}(t) + \\lambda \\, \\mathcal{P}_k(t).\n$$\n\n给定以下实例，其中 $N = 6$ 且 $M = 5$：\n- 响应矩阵 $R \\in \\mathbb{R}^{6 \\times 5}$：\n$$\nR =\n\\begin{pmatrix}\n0.60  0.25  0.05  0.00  0.00 \\\\\n0.30  0.50  0.15  0.02  0.00 \\\\\n0.08  0.20  0.55  0.15  0.02 \\\\\n0.02  0.04  0.20  0.60  0.14 \\\\\n0.00  0.01  0.05  0.18  0.60 \\\\\n0.00  0.00  0.00  0.05  0.24 \\\\\n\\end{pmatrix}.\n$$\n- 观测计数 $d \\in \\mathbb{R}^6$：\n$$\nd = \\begin{pmatrix} 120 \\\\ 150 \\\\ 160 \\\\ 140 \\\\ 90 \\\\ 30 \\end{pmatrix}.\n$$\n- 标准差 $\\sigma \\in \\mathbb{R}^6$（$V$ 的对角不确定度）：\n$$\n\\sigma = \\begin{pmatrix} 11.0 \\\\ 12.2 \\\\ 12.6 \\\\ 11.8 \\\\ 9.5 \\\\ 5.6 \\end{pmatrix}.\n$$\n\n任务：\n1. 对于下面每个指定的测试用例 $(\\lambda, k)$，计算 $\\chi^2_{\\mathrm{reg}}(t;\\lambda,k)$ 在 $t \\in \\mathbb{R}^M$ 上的最小化子 $\\hat{t}(\\lambda,k)$。\n2. 对于每个 $\\hat{t}(\\lambda,k)$，计算数据空间残差卡方（不包括罚项），\n$$\n\\chi^2_{\\mathrm{data}}(\\hat{t}) = (d - R \\hat{t})^{\\top} V^{-1} (d - R \\hat{t}).\n$$\n3. 对于每个 $\\hat{t}(\\lambda,k)$，计算广义有效自由度\n$$\n\\nu_{\\mathrm{eff}}(\\lambda,k) = N - \\mathrm{tr}(S_{\\lambda,k}),\n$$\n其中影响（也称为帽子）矩阵 $S_{\\lambda,k}$ 定义为\n$$\nS_{\\lambda,k} = R \\left(R^{\\top} V^{-1} R + \\lambda L_k^{\\top} L_k\\right)^{-1} R^{\\top} V^{-1}.\n$$\n4. 使用 $\\chi^2_{\\mathrm{data}}(\\hat{t})$ 和 $\\nu_{\\mathrm{eff}}(\\lambda,k)$，计算在具有 $\\nu_{\\mathrm{eff}}(\\lambda,k)$ 个自由度的卡方分布下的上尾概率（拟合优度p值），\n$$\np = \\mathbb{P}\\left(\\chi^2 \\ge \\chi^2_{\\mathrm{data}}(\\hat{t}) \\, ; \\, \\nu_{\\mathrm{eff}}(\\lambda,k)\\right).\n$$\n将 $\\nu_{\\mathrm{eff}}(\\lambda,k)$ 视为实值自由度参数。\n\n测试套件：\n- 用例 1：$(\\lambda, k) = (0, 2)$。\n- 用例 2：$(\\lambda, k) = (1, 0)$。\n- 用例 3：$(\\lambda, k) = (10, 1)$。\n- 用例 4：$(\\lambda, k) = (10^{3}, 2)$。\n\n您的程序必须：\n- 针对指定的 $R$、$d$ 和 $\\sigma$ 精确实现上述计算。\n- 对于每个测试用例，输出一个包含三个浮点数的列表 $[\\chi^2_{\\mathrm{data}}(\\hat{t}), \\nu_{\\mathrm{eff}}(\\lambda,k), p]$，每个浮点数四舍五入到 $6$ 位小数。\n- 将所有测试用例的结果聚合到单行输出中，该输出包含一个类Python的列表，其中包含按测试套件顺序排列的各用例列表，例如 $[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],\\ldots]$。\n\n不涉及物理单位。不出现角度。所有数值答案必须是按规定格式的浮点数。", "solution": "用户提供的问题是计算物理领域中一个明确定义的任务，特别是在反演问题和数据分析领域。它涉及求解一个线性系统的正则化解，并评估其统计特性。该问题具有科学依据、适定性、客观性和完整性。所有必需的数据、矩阵、向量和公式均已提供，且没有内部矛盾或歧义。因此，该问题是有效的，并且可以推导出解决方案。\n\n问题的核心是对于给定的正则化参数 $\\lambda \\ge 0$ 和正则化阶数 $k \\in \\{0, 1, 2\\}$，找到一个向量 $t \\in \\mathbb{R}^{M}$，以最小化带罚项的卡方目标函数。该目标函数定义为：\n$$\n\\chi^2_{\\mathrm{reg}}(t;\\lambda,k) = \\chi^2_{\\mathrm{data}}(t) + \\lambda \\, \\mathcal{P}_k(t)\n$$\n第一项 $\\chi^2_{\\mathrm{data}}(t)$ 量化了解与观测数据 $d$ 的保真度。它由以下公式给出：\n$$\n\\chi^2_{\\mathrm{data}}(t) = (d - R t)^{\\top} V^{-1} (d - R t)\n$$\n此处，$R$ 是响应矩阵，$d$ 是观测计数向量，$V$ 是测量误差的对角协方差矩阵，其中 $V_{ii} = \\sigma_i^2$。\n\n第二项 $\\mathcal{P}_k(t)$ 是一个Tikhonov型正则化罚项，它包含了关于真实向量 $t$ 光滑性的先验信念。其定义为：\n$$\n\\mathcal{P}_k(t) = \\| L_k t \\|_2^2 = t^{\\top} L_k^{\\top} L_k t\n$$\n其中 $L_k$ 是一个近似 $k$ 阶导数的离散线性算子。\n\n为了找到 $\\chi^2_{\\mathrm{reg}}(t)$ 的最小化子 $\\hat{t}$，我们必须找到其关于 $t$ 的梯度为零的点。目标函数可以展开为：\n$$\n\\chi^2_{\\mathrm{reg}}(t) = (d^{\\top} - t^{\\top}R^{\\top}) V^{-1} (d - R t) + \\lambda t^{\\top} L_k^{\\top} L_k t = d^{\\top}V^{-1}d - 2 t^{\\top} R^{\\top} V^{-1} d + t^{\\top} R^{\\top} V^{-1} R t + \\lambda t^{\\top} L_k^{\\top} L_k t\n$$\n关于 $t$ 的梯度是：\n$$\n\\nabla_t \\chi^2_{\\mathrm{reg}}(t) = -2 R^{\\top} V^{-1} d + 2 R^{\\top} V^{-1} R t + 2 \\lambda L_k^{\\top} L_k t\n$$\n将梯度设为零，即 $\\nabla_t \\chi^2_{\\mathrm{reg}}(\\hat{t}) = 0$，得到以下线性方程组：\n$$\n(R^{\\top} V^{-1} R + \\lambda L_k^{\\top} L_k) \\hat{t} = R^{\\top} V^{-1} d\n$$\n这是一个用于Tikhonov正则化的标准正规方程组。通过求解该方程组可以找到最小化子 $\\hat{t}(\\lambda,k)$。令 $A = R^{\\top} V^{-1} R + \\lambda L_k^{\\top} L_k$ 和 $b = R^{\\top} V^{-1} d$。问题简化为求解 $M \\times M$ 线性系统 $A \\hat{t} = b$。对于 $\\lambda  0$，或者当 $\\lambda=0$ 且 $R^{\\top}V^{-1}R$ 可逆时（在本问题中成立，因为 $R$ 是列满秩的），该系统有唯一解。\n\n每个测试用例 $(\\lambda, k)$ 的计算步骤如下：\n\n1.  **构造矩阵**：\n    -   问题提供了 $d \\in \\mathbb{R}^6$、$R \\in \\mathbb{R}^{6 \\times 5}$ 和 $\\sigma \\in \\mathbb{R}^6$ 的数值。\n    -   逆协方差矩阵 $V^{-1}$ 是一个对角矩阵，其元素为 $(V^{-1})_{ii} = 1/\\sigma_i^2$。\n    -   矩阵 $L_k \\in \\mathbb{R}^{D \\times M}$（其中 $D$ 取决于 $k$）根据阶数 $k$ 为 $M=5$ 构建：\n        -   对于 $k=0$，$L_0 = I_5$ 是 $5 \\times 5$ 的单位矩阵。\n        -   对于 $k=1$，$L_1$ 是 $4 \\times 5$ 的一阶差分矩阵。\n        -   对于 $k=2$，$L_2$ 是 $3 \\times 5$ 的二阶差分矩阵。\n\n2.  **求解最小化子 $\\hat{t}(\\lambda,k)$**：\n    -   构建矩阵 $A = R^{\\top}V^{-1}R + \\lambda L_k^{\\top}L_k$。\n    -   构建向量 $b = R^{\\top}V^{-1}d$。\n    -   求解线性系统 $A \\hat{t} = b$ 以得到 $\\hat{t}$。\n\n3.  **计算数据空间卡方 $\\chi^2_{\\mathrm{data}}(\\hat{t})$**：\n    -   利用解 $\\hat{t}$，计算残差向量 $r = d - R \\hat{t}$。\n    -   计算 $\\chi^2_{\\mathrm{data}}(\\hat{t}) = r^{\\top} V^{-1} r = \\sum_{i=1}^{N} (r_i^2 / \\sigma_i^2)$。\n\n4.  **计算有效自由度 $\\nu_{\\mathrm{eff}}(\\lambda,k)$**：\n    -   首先，计算影响矩阵 $S_{\\lambda,k}$：\n      $$\n      S_{\\lambda,k} = R \\left(R^{\\top} V^{-1} R + \\lambda L_k^{\\top} L_k\\right)^{-1} R^{\\top} V^{-1}\n      $$\n    -   有效自由度是拟合后数据可变自由度的度量：\n      $$\n      \\nu_{\\mathrm{eff}}(\\lambda,k) = N - \\mathrm{tr}(S_{\\lambda,k})\n      $$\n      其中 $N=6$ 是数据点的数量，$\\mathrm{tr}(\\cdot)$ 是矩阵的迹。此处，$\\mathrm{tr}(S_{\\lambda,k})$ 是拟合所消耗的有效参数数量。\n\n5.  **计算拟合优度p值**：\n    -   p值计算为具有 $\\nu_{\\mathrm{eff}}$ 个自由度的卡方分布的上尾概率：\n      $$\n      p = \\mathbb{P}\\left(\\chi^2 \\ge \\chi^2_{\\mathrm{data}}(\\hat{t}) \\, ; \\, \\nu_{\\mathrm{eff}}(\\lambda,k)\\right)\n      $$\n    -   这对应于 $\\chi^2$ 分布的生存函数（1 - 累积分布函数），在 $\\chi^2_{\\mathrm{data}}(\\hat{t})$ 处、自由度为 $\\nu_{\\mathrm{eff}}(\\lambda,k)$ 时求值。\n\n对四个指定的测试用例中的每一个都执行此计算序列。然后收集结果 $[\\chi^2_{\\mathrm{data}}(\\hat{t}), \\nu_{\\mathrm{eff}}(\\lambda,k), p]$ 并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Solves the Tikhonov-regularized unfolding problem for a series of test cases.\n    \"\"\"\n    \n    # Define the problem data as specified\n    R = np.array([\n        [0.60, 0.25, 0.05, 0.00, 0.00],\n        [0.30, 0.50, 0.15, 0.02, 0.00],\n        [0.08, 0.20, 0.55, 0.15, 0.02],\n        [0.02, 0.04, 0.20, 0.60, 0.14],\n        [0.00, 0.01, 0.05, 0.18, 0.60],\n        [0.00, 0.00, 0.00, 0.05, 0.24]\n    ])\n\n    d = np.array([120., 150., 160., 140., 90., 30.])\n    \n    sigma = np.array([11.0, 12.2, 12.6, 11.8, 9.5, 5.6])\n\n    N, M = R.shape\n\n    # Construct the inverse covariance matrix V^{-1}\n    V_inv = np.diag(1 / sigma**2)\n\n    # Define the test cases\n    test_cases = [\n        (0, 2),\n        (1, 0),\n        (10, 1),\n        (1000, 2),\n    ]\n\n    all_results = []\n\n    for lambda_val, k_val in test_cases:\n        # Step 1: Construct the regularization operator L_k\n        if k_val == 0:\n            # k=0: L_0 = I_M\n            L_k = np.identity(M)\n        elif k_val == 1:\n            # k=1: First-difference operator\n            L_k = np.zeros((M - 1, M))\n            for i in range(M - 1):\n                L_k[i, i] = -1.0\n                L_k[i, i + 1] = 1.0\n        elif k_val == 2:\n            # k=2: Second-difference operator\n            L_k = np.zeros((M - 2, M))\n            for i in range(M - 2):\n                L_k[i, i] = 1.0\n                L_k[i, i + 1] = -2.0\n                L_k[i, i + 2] = 1.0\n        \n        # Pre-compute parts of the normal equations\n        RT_Vinv = R.T @ V_inv\n        RT_Vinv_R = RT_Vinv @ R\n        Lk_T_Lk = L_k.T @ L_k\n\n        # Step 2: Solve for the minimizer t_hat\n        A_matrix = RT_Vinv_R + lambda_val * Lk_T_Lk\n        b_vector = RT_Vinv @ d\n        t_hat = np.linalg.solve(A_matrix, b_vector)\n\n        # Step 3: Compute data-space residual chi-squared\n        residuals = d - R @ t_hat\n        chi2_data = residuals.T @ V_inv @ residuals\n\n        # Step 4: Compute effective degrees of freedom\n        # Note: A_matrix_inv = (R'V^{-1}R + lambda*L'L)^{-1}\n        A_matrix_inv = np.linalg.inv(A_matrix)\n        S_matrix = R @ A_matrix_inv @ RT_Vinv\n        nu_eff = N - np.trace(S_matrix)\n\n        # Step 5: Compute the goodness-of-fit p-value\n        p_value = chi2.sf(chi2_data, nu_eff)\n\n        # Store the results rounded to 6 decimal places\n        case_results = [\n            round(chi2_data, 6),\n            round(nu_eff, 6),\n            round(p_value, 6)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    # Creates strings like '[1.0,2.0,3.0]' for each case\n    results_as_strs = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    \n    # Joins these strings into the final format '[[...],[...]]'\n    final_output = f\"[{','.join(results_as_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "3507369"}]}