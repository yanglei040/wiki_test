{"hands_on_practices": [{"introduction": "在高粒子密度环境下，从大量击中点中构建初始径迹候选（即“种子”）是径迹重建的首要挑战，其巨大的组合可能性是主要的计算瓶颈。本练习 [@problem_id:3539679] 探索如何利用现代探测器提供的高精度时间信息，构建一个四维（时空）的种子生成策略。通过推导并计算随机组合通过时间匹配测试的概率，你将量化时间信息在抑制伪径迹种子方面的强大作用。", "problem": "您正在为均匀磁场中的带电粒子径迹重建算法设计一个三层径迹种子（seed）生成阶段。一个径迹种子是由来自三个分别标记为 $1$、$2$ 和 $3$ 的探测器层上的三个击中（hit）组成的集合。每个击中都带有时空坐标 $(x,y,z,t)$，其中 $t$ 是击中时间。您的任务是开发并分析一种利用时间信息（timing-aware）的径迹种子生成策略，该策略使用 $t$ 作为第四坐标，以在高堆积（pileup）环境中抑制由空间上兼容的随机击中组合带来的组合爆炸，并推导出一个关于伪径迹种子（fake seed）数量与时间分辨率关系的解析定标（analytic scaling）。\n\n基本原理与假设：\n- 带电粒子是超相对论性的，其速度 $v \\approx c$，其中 $c$ 是光速。\n- 对于真实径迹，层 $i$ 和层 $j$ 之间的飞行时间差（time-of-flight difference）可近似为 $\\Delta t_{ij} \\approx \\ell_{ij}/c$，其中 $\\ell_{ij}$ 是沿径迹轨迹在两层之间的几何路径长度。\n- 测得的击中时间围绕其真实值呈高斯分布，标准差为 $\\sigma_t$，且各个击中之间相互独立。\n- 用于径迹种子生成的预测飞行时间差 $\\Delta t_{ij}^{\\mathrm{pred}}$ 存在一个模型不确定性，该不确定性由一个标准差为 $\\sigma_{\\mathrm{TOF}}$ 的高斯分布表示（例如，该不确定性可能源于未知的横向动量、路径长度或残余对准误差）。\n- 对于来自堆积事件的、空间上兼容的随机击中，其击中时间是相互独立的，并在持续时间为 $T_{\\mathrm{bx}}$ 的束团穿越（bunch-crossing）时间间隔内均匀分布。\n- 一个利用时间信息的径迹种子接受标准要求两个成对的残差（residual）同时满足一致性条件：\n  $$\\left|(t_2 - t_1) - \\Delta t_{12}^{\\mathrm{pred}}\\right| \\le k\\,S \\quad \\text{和} \\quad \\left|(t_3 - t_2) - \\Delta t_{23}^{\\mathrm{pred}}\\right| \\le k\\,S,$$\n  其中 $k$ 是一个选定的一致性乘数（例如，对于一个三倍标准差的窗口，$k=3$），且\n  $$S = \\sqrt{2\\,\\sigma_t^2 + \\sigma_{\\mathrm{TOF}}^2}.$$\n- 在几何径迹种子窗口内，每层空间上兼容的有效击中数分别为 $N_1$、$N_2$ 和 $N_3$。在不使用时间信息的情况下，候选三联体（triplet）的数量与 $N_1 N_2 N_3$ 成正比。\n\n问题要求：\n1. 从上述基本原理出发，推导一个解析表达式，用于计算一个由随机、空间兼容的击中组成的三联体通过两个时间窗口的概率，该表达式需用 $\\sigma_t$、$\\sigma_{\\mathrm{TOF}}$、$T_{\\mathrm{bx}}$ 和 $k$ 表示。对于相对于 $T_{\\mathrm{bx}}$ 而言很小的时间窗口，请使用针对两个独立均匀分布随机变量之差的主导项近似（leading-order approximation），并证明其合理性。然后给出每个事件中伪三联体的期望数量：\n   $$N_{\\mathrm{fake}} \\approx N_1 N_2 N_3 \\, p_{\\mathrm{fake}}(\\sigma_t,\\sigma_{\\mathrm{TOF}},T_{\\mathrm{bx}},k),$$\n   其中为了符合物理现实，$p_{\\mathrm{fake}}$ 的值被限制在区间 $[0,1]$ 内。\n2. 使用您推导的表达式，实现一个程序来计算下列测试集的 $N_{\\mathrm{fake}}$。在计算中，所有时间都必须以秒为单位处理。计数是无单位的。仅在理论推导中使用 $c$；程序中无需其数值，因为 $\\Delta t_{ij}^{\\mathrm{pred}}$ 仅通过 $\\sigma_{\\mathrm{TOF}}$ 来体现。\n   - 测试用例 A (理想情况): $N_1 = 60$, $N_2 = 80$, $N_3 = 70$, $\\sigma_t = 50\\,\\mathrm{ps}$, $\\sigma_{\\mathrm{TOF}} = 30\\,\\mathrm{ps}$, $T_{\\mathrm{bx}} = 25\\,\\mathrm{ns}$, $k = 3$。\n   - 测试用例 B (高占用率，良好时间分辨率): $N_1 = 200$, $N_2 = 220$, $N_3 = 180$, $\\sigma_t = 30\\,\\mathrm{ps}$, $\\sigma_{\\mathrm{TOF}} = 50\\,\\mathrm{ps}$, $T_{\\mathrm{bx}} = 25\\,\\mathrm{ns}$, $k = 3$。\n   - 测试用例 C (较差时间分辨率): $N_1 = 60$, $N_2 = 80$, $N_3 = 70$, $\\sigma_t = 300\\,\\mathrm{ps}$, $\\sigma_{\\mathrm{TOF}} = 30\\,\\mathrm{ps}$, $T_{\\mathrm{bx}} = 25\\,\\mathrm{ns}$, $k = 3$。\n   - 测试用例 D (接近理想时间分辨率，受模型限制): $N_1 = 60$, $N_2 = 80$, $N_3 = 70$, $\\sigma_t = 5\\,\\mathrm{ps}$, $\\sigma_{\\mathrm{TOF}} = 30\\,\\mathrm{ps}$, $T_{\\mathrm{bx}} = 25\\,\\mathrm{ns}$, $k = 3$。\n   - 测试用例 E (饱和边界情况): $N_1 = 60$, $N_2 = 80$, $N_3 = 70$, $\\sigma_t = 10\\,\\mathrm{ns}$, $\\sigma_{\\mathrm{TOF}} = 30\\,\\mathrm{ps}$, $T_{\\mathrm{bx}} = 25\\,\\mathrm{ns}$, $k = 3$。\n3. 您的程序应生成单行输出，其中包含用例 A 到 E 的结果，格式为一个用方括号括起来的逗号分隔列表（例如，$[r_A,r_B,r_C,r_D,r_E]$），其中每个 $r_\\cdot$ 是伪三联体的期望数量（一个浮点数）。\n\n答案格式：\n- 提供完整的推导和解答。\n- 提供最终答案，形式为一个完整、可运行的程序。", "solution": "该问题陈述在科学上是合理的、定义明确的且客观的。它提出了一个高能物理径迹重建中的真实场景，并要求进行一个标准但并非无足轻重的概率推导，随后进行数值实现。所有必要的定义和参数均已提供，不存在内部矛盾或违反物理原理之处。因此，该问题被判定为**有效**。\n\n任务是推导一个解析表达式，用以计算一个由随机、空间兼容的击中组成的三联体通过一组基于时间的筛选条件从而形成“伪径迹种子”的概率。然后，我们被要求为几组参数计算这种伪径迹种子的期望数量。\n\n设第 $1$、$2$ 和 $3$ 层中三个击中的时间分别为 $t_1$、$t_2$ 和 $t_3$。对于源自随机堆积相互作用的伪径迹种子，这些时间是独立同分布的随机变量，服从于持续时间为 $T_{\\mathrm{bx}}$ 的束团穿越时间间隔上的均匀分布。我们可以将其建模为 $t_i \\sim U(0, T_{\\mathrm{bx}})$，其中 $i=1, 2, 3$。\n\n利用时间信息的径迹种子生成条件以对成对的飞行时间残差的两个同时要求给出：\n$$\nC_1: \\quad |(t_2 - t_1) - \\Delta t_{12}^{\\mathrm{pred}}| \\le kS\n$$\n$$\nC_2: \\quad |(t_3 - t_2) - \\Delta t_{23}^{\\mathrm{pred}}| \\le kS\n$$\n其中 $k$ 是一个乘数，$\\Delta t_{ij}^{\\mathrm{pred}}$ 是假设径迹的预测飞行时间差，$S = \\sqrt{2\\sigma_t^2 + \\sigma_{\\mathrm{TOF}}^2}$ 是单个飞行时间残差测量的总不确定度。为方便标记，设 $W = kS$ 为接受窗口的半宽度。条件变为：\n$$\nC_1: \\quad |(t_2 - t_1) - \\Delta t_{12}^{\\mathrm{pred}}| \\le W\n$$\n$$\nC_2: \\quad |(t_3 - t_2) - \\Delta t_{23}^{\\mathrm{pred}}| \\le W\n$$\n\n我们需要找到一个随机击中三联体同时满足这两个条件的概率 $p_{\\mathrm{fake}}$，即 $p_{\\mathrm{fake}} = P(C_1 \\cap C_2)$。由于击中时间 $t_1, t_2, t_3$ 是独立的，它们的联合概率密度函数（PDF）为 $f(t_1, t_2, t_3) = (1/T_{\\mathrm{bx}})^3$，其中 $(t_1, t_2, t_3) \\in [0, T_{\\mathrm{bx}}]^3$，在其他情况下为 $0$。概率 $p_{\\mathrm{fake}}$ 是此联合概率密度函数在 $(t_1, t_2, t_3)$ 空间中由条件 $C_1$、$C_2$ 和边界 $0 \\le t_i \\le T_{\\mathrm{bx}}$ 定义的体积上的积分。\n\n让我们为时间差定义新变量：$u_1 = t_2 - t_1$ 和 $u_2 = t_3 - t_2$。条件 $C_1$ 和 $C_2$ 是在这些变量上定义的。时间差 $u_1$ 和 $u_2$ 不是独立的，因为它们都依赖于 $t_2$。为了正确计算联合概率，我们执行一个变量代换，从 $(t_1, t_2, t_3)$ 变换到 $(u_1, u_2, u_3)$，为简单起见，我们可以选择 $u_3 = t_2$。逆变换为：\n$$\nt_1 = t_2 - (t_2 - t_1) = u_3 - u_1\n$$\n$$\nt_2 = u_3\n$$\n$$\nt_3 = (t_3 - t_2) + t_2 = u_2 + u_3\n$$\n该变换的雅可比行列式是：\n$$\nJ = \\det \\begin{pmatrix} \\frac{\\partial t_1}{\\partial u_1}  \\frac{\\partial t_1}{\\partial u_2}  \\frac{\\partial t_1}{\\partial u_3} \\\\ \\frac{\\partial t_2}{\\partial u_1}  \\frac{\\partial t_2}{\\partial u_2}  \\frac{\\partial t_2}{\\partial u_3} \\\\ \\frac{\\partial t_3}{\\partial u_1}  \\frac{\\partial t_3}{\\partial u_2}  \\frac{\\partial t_3}{\\partial u_3} \\end{pmatrix} = \\det \\begin{pmatrix} -1  0  1 \\\\ 0  0  1 \\\\ 0  1  1 \\end{pmatrix} = -1(0-1) = 1\n$$\n雅可比行列式的绝对值为 $|J|=1$。新坐标系下的联合概率密度函数是 $f(u_1, u_2, u_3) = (1/T_{\\mathrm{bx}})^3 |J| = 1/T_{\\mathrm{bx}}^3$。\n\n概率是在变换后的体积上的积分：\n$$\np_{\\mathrm{fake}} = \\iiint \\frac{1}{T_{\\mathrm{bx}}^3} \\, du_1 \\, du_2 \\, du_3\n$$\n积分限由以下条件给出：\n1.  来自 $C_1$：$\\Delta t_{12}^{\\mathrm{pred}} - W \\le u_1 \\le \\Delta t_{12}^{\\mathrm{pred}} + W$\n2.  来自 $C_2$：$\\Delta t_{23}^{\\mathrm{pred}} - W \\le u_2 \\le \\Delta t_{23}^{\\mathrm{pred}} + W$\n3.  来自 $0 \\le t_i \\le T_{\\mathrm{bx}}$：\n    - $0 \\le u_3 - u_1 \\le T_{\\mathrm{bx}} \\implies u_1 \\le u_3 \\le T_{\\mathrm{bx}} + u_1$\n    - $0 \\le u_3 \\le T_{\\mathrm{bx}}$\n    - $0 \\le u_2 + u_3 \\le T_{\\mathrm{bx}} \\implies -u_2 \\le u_3 \\le T_{\\mathrm{bx}} - u_2$\n\n问题指定对相对于 $T_{\\mathrm{bx}}$ 而言很小的时间窗口使用主导项近似。这意味着 $W \\ll T_{\\mathrm{bx}}$。此外，对于穿越探测器的超相对论性粒子，物理飞行时间 $\\Delta t^{\\mathrm{pred}}$ 与束团穿越时间间隔 $T_{\\mathrm{bx}}$ 相比非常小。因此，积分变量 $u_1$ 和 $u_2$ 被限制在零附近的小区间内。这意味着 $|u_1| \\ll T_{\\mathrm{bx}}$ 并且 $|u_2| \\ll T_{\\mathrm{bx}}$。\n\n在此近似下，$u_3$ 的边界简化。下界变为 $\\max(0, u_1, -u_2) \\approx 0$，上界变为 $\\min(T_{\\mathrm{bx}}, T_{\\mathrm{bx}}+u_1, T_{\\mathrm{bx}}-u_2) \\approx T_{\\mathrm{bx}}$。$u_3$ 的积分区间长度近似为 $T_{\\mathrm{bx}}$。\n\n因此，$p_{\\mathrm{fake}}$ 的积分简化为：\n$$\np_{\\mathrm{fake}} \\approx \\frac{1}{T_{\\mathrm{bx}}^3} \\int_{\\Delta t_{12}^{\\mathrm{pred}} - W}^{\\Delta t_{12}^{\\mathrm{pred}} + W} du_1 \\int_{\\Delta t_{23}^{\\mathrm{pred}} - W}^{\\Delta t_{23}^{\\mathrm{pred}} + W} du_2 \\int_{0}^{T_{\\mathrm{bx}}} du_3\n$$\n$$\np_{\\mathrm{fake}} \\approx \\frac{1}{T_{\\mathrm{bx}}^3} \\left[ ((\\Delta t_{12}^{\\mathrm{pred}} + W) - (\\Delta t_{12}^{\\mathrm{pred}} - W)) \\times ((\\Delta t_{23}^{\\mathrm{pred}} + W) - (\\Delta t_{23}^{\\mathrm{pred}} - W)) \\times T_{\\mathrm{bx}} \\right]\n$$\n$$\np_{\\mathrm{fake}} \\approx \\frac{1}{T_{\\mathrm{bx}}^3} [ (2W) \\times (2W) \\times T_{\\mathrm{bx}} ] = \\frac{(2W)^2}{T_{\\mathrm{bx}}^2}\n$$\n这个推导证实了，在小窗口近似下，通过两个筛选条件的概率等同于独立通过每个筛选条件的概率之积。通过单个筛选条件 $|(t_i - t_j) - \\Delta t_{ij}^{\\mathrm{pred}}| \\le W$ 的概率，是两个均匀分布随机变量之差的概率密度函数（PDF）下方一个宽度为 $2W$ 的窗口的面积。这个 PDF 是一个在 $[-T_{\\mathrm{bx}}, T_{\\mathrm{bx}}]$ 上的三角分布，其中心处的最大高度为 $1/T_{\\mathrm{bx}}$。对于中心附近的一个小窗口，其概率近似为 $(2W)/T_{\\mathrm{bx}}$。\n\n代入 $W = kS$ 和 $S^2 = 2\\sigma_t^2 + \\sigma_{\\mathrm{TOF}}^2$，我们得到：\n$$\np_{\\mathrm{fake}} = \\frac{(2kS)^2}{T_{\\mathrm{bx}}^2} = \\frac{4k^2S^2}{T_{\\mathrm{bx}}^2} = \\frac{4k^2(2\\sigma_t^2 + \\sigma_{\\mathrm{TOF}}^2)}{T_{\\mathrm{bx}}^2}\n$$\n这个近似在 $2kS \\ll T_{\\mathrm{bx}}$ 时有效。如果时间窗口变得非常大（与 $T_{\\mathrm{bx}}$ 相当或更大），在其中找到一个随机时间差的概率将接近 $1$。因此，为了符合物理现实，我们必须将计算出的概率限制在区间 $[0, 1]$ 内。\n$$\np_{\\mathrm{fake}}(\\sigma_t, \\sigma_{\\mathrm{TOF}}, T_{\\mathrm{bx}}, k) = \\min\\left(1, \\frac{4k^2(2\\sigma_t^2 + \\sigma_{\\mathrm{TOF}}^2)}{T_{\\mathrm{bx}}^2}\\right)\n$$\n伪三联体的期望数量 $N_{\\mathrm{fake}}$，是空间兼容的随机三联体总数 $N_1 N_2 N_3$ 乘以其中任意一个通过时间筛选条件的概率 $p_{\\mathrm{fake}}$。\n$$\nN_{\\mathrm{fake}} \\approx N_1 N_2 N_3 \\cdot p_{\\mathrm{fake}}\n$$\n\n我们现在将实现这个公式来计算给定测试用例的 $N_{\\mathrm{fake}}$，确保所有时间单位都一致地转换为秒。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the track reconstruction problem by calculating the expected number of fake seeds.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (N1, N2, N3, sigma_t_ps, sigma_tof_ps, T_bx_ns, k)\n    # Note: sigma_t and sigma_tof are given in ps or ns in the test cases,\n    # and T_bx is in ns. We will convert them to seconds in the calculation.\n    test_cases = [\n        # A: (N1, N2, N3, sigma_t, sigma_tof, T_bx, k)\n        (60, 80, 70, 50, 30, 25, 3),\n        # B:\n        (200, 220, 180, 30, 50, 25, 3),\n        # C:\n        (60, 80, 70, 300, 30, 25, 3),\n        # D:\n        (60, 80, 70, 5, 30, 25, 3),\n        # E: (sigma_t is 10 ns, which is 10000 ps)\n        (60, 80, 70, 10e3, 30, 25, 3),\n    ]\n\n    results = []\n    \n    # Unit conversion factors\n    PS_TO_S = 1e-12  # picoseconds to seconds\n    NS_TO_S = 1e-9   # nanoseconds to seconds\n\n    for case in test_cases:\n        N1, N2, N3, sigma_t_ps, sigma_tof_ps, T_bx_ns, k = case\n\n        # Convert all time values to seconds for consistent calculation\n        sigma_t = sigma_t_ps * PS_TO_S\n        sigma_tof = sigma_tof_ps * PS_TO_S\n        T_bx = T_bx_ns * NS_TO_S\n\n        # Total number of spatially compatible triplets without timing\n        N_cand = N1 * N2 * N3\n\n        # Calculate S^2 = 2*sigma_t^2 + sigma_TOF^2\n        S_squared = 2 * sigma_t**2 + sigma_tof**2\n\n        # Calculate the raw probability based on the derived formula\n        # p_raw = (4 * k^2 * S^2) / T_bx^2\n        p_raw = (4 * k**2 * S_squared) / T_bx**2\n        \n        # The probability must be clipped to the interval [0, 1] for physical realism.\n        # This handles cases where the timing window is larger than the bunch crossing interval.\n        p_fake = min(1.0, p_raw)\n\n        # Calculate the expected number of fake triplets\n        N_fake = N_cand * p_fake\n        \n        results.append(N_fake)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3539679"}, {"introduction": "当多个径迹候选延伸到同一探测器层面时，正确地将探测器上的击中点与相应径迹关联起来，是确保重建质量的关键，这便是“数据关联”问题。本练习 [@problem_id:3539732] 将引导你超越简单的“最近邻”匹配，构建一个基于最大后验概率（MAP）的稳健关联框架。你将学习如何综合考虑径迹的预测位置、探测效率、存在先验概率以及噪声模型，来找到全局最优的分配方案。", "problem": "给定一组外推到单个探测器层的候选粒子径迹，以及同一层中的一组测量到的命中点。对于每个候选径迹，您都有一个预测的二维位置和一个表示外推不确定性的协方差。探测器提供二维命中位置，且测量噪声协方差是已知的。此外，还有一个用于描述伪命中的均匀杂波模型，该模型由泊松点过程 (PPP) 描述。您的任务是基于一个有原则的概率模型计算径迹与命中之间的关联概率，然后根据最大后验 (MAP) 规则选择命中到径迹的一对一分配。\n\n基本基础与物理建模：\n- 假设测量模型为多元正态 (MVN) 分布：对于具有预测位置 $\\mathbf{x}_i \\in \\mathbb{R}^2$ 和外推协方差 $\\mathbf{S}_i \\in \\mathbb{R}^{2 \\times 2}$ 的径迹，一个真实的关联命中 $\\mathbf{z}_j \\in \\mathbb{R}^2$ 服从分布 $\\mathcal{N}(\\mathbf{x}_i, \\mathbf{C}_i)$，其中 $\\mathbf{C}_i = \\mathbf{S}_i + \\mathbf{R}$，$\\mathbf{R} \\in \\mathbb{R}^{2 \\times 2}$ 是测量噪声协方差。所有位置均以毫米 (mm) 表示，协方差以平方毫米 ($\\mathrm{mm}^2$) 表示。\n- 假设在一个已知的传感器区域 $A$（单位为 $\\mathrm{mm}^2$）上，杂波密度 $\\lambda$ 是均匀的，每次读出的预期杂波命中数为 $\\Lambda$。那么 $\\lambda = \\Lambda / A$ 的单位是 $\\mathrm{mm}^{-2}$。\n- 每个径迹 $i$ 都有一个探测概率 (PoD) $P_D^{(i)} \\in (0,1)$ 和一个先验存在概率 $P_T^{(i)} \\in (0,1)$。\n- 使用标准的门控规则，该规则基于马氏距离的平方 $d_{ij}^2 = (\\mathbf{z}_j - \\mathbf{x}_i)^\\top \\mathbf{C}_i^{-1} (\\mathbf{z}_j - \\mathbf{x}_i)$ 和一个门限 $\\gamma  0$。只有当 $d_{ij}^2 \\le \\gamma$ 时，关联 $(i,j)$ 才是可接受的。\n\n关联概率：\n- 对于一个可接受的配对 $(i,j)$，定义局部似然比为 $L_{ij} = \\dfrac{P_D^{(i)} \\cdot \\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i)}{\\lambda}$，其中 $\\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i)$ 是在 $\\mathbf{z}_j$ 处求值的多元正态概率密度函数。对于不可接受的配对，设置 $L_{ij} = 0$。\n- 对于径迹 $i$ 的漏检假设，定义 $L_{i0} = 1 - P_D^{(i)}$。\n- 那么，对于每个可接受的命中 $j$，归一化的每径迹关联概率为 $p_{ij} = \\dfrac{L_{ij}}{L_{i0} + \\sum_k L_{ik}}$，对于漏检，其概率为 $p_{i0} = \\dfrac{L_{i0}}{L_{i0} + \\sum_k L_{ik}}$。\n\n最大后验 (MAP) 分配：\n- 考虑联合分配问题，其中每个径迹要要么分配给一个命中，要要么分配为漏检，并满足一个命中最多只能分配给一个径迹的约束条件。MAP 分配在独立性假设和 PPP 杂波模型下最大化联合后验概率。在不考虑与分配无关的加性常数的情况下，问题简化为最大化 $\\sum_i \\left[ \\log P_T^{(i)} + \\log L_{i,a(i)} \\right]$，其中 $a(i)$ 是为径迹 $i$ 选择的假设（可以是特定的命中 $j$ 或表示漏检的 $0$），并受限于命中之间的一对一约束。\n- 通过求解一个线性分配问题来实现此选择，该问题旨在最小化负对数后验贡献的总和。使用一个代价矩阵，其条目对于可接受的配对为 $c_{ij} = -\\left(\\log P_T^{(i)} + \\log P_D^{(i)} + \\log \\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i) - \\log \\lambda\\right)$，对于不可接受的配对为一个非常大的代价，对于漏检为 $c_{i,\\text{miss}} = -\\left(\\log P_T^{(i)} + \\log(1 - P_D^{(i)})\\right)$。通过为每个径迹提供一个唯一的漏检列来强制执行一对一约束。\n\n数值和单位要求：\n- 位置必须以毫米 (mm) 处理，协方差以平方毫米 ($\\mathrm{mm}^2$) 处理。本问题不涉及角度。\n- 最终输出由分配索引组成，这些索引是使用从零开始的索引方式的无量纲整数。使用 $-1$ 表示径迹的漏检。\n\n测试套件：\n提供四个具有科学合理参数的测试用例。对于每个用例，您必须按所述计算 MAP 分配。\n\n- 测试用例 1 (两个径迹，三个命中，宽门控)：\n  - 传感器面积：$A = 10000\\,\\mathrm{mm}^2$，预期杂波：$\\Lambda = 0.5$，因此 $\\lambda = 0.00005\\,\\mathrm{mm}^{-2}$。\n  - 测量协方差：$\\mathbf{R} = \\begin{bmatrix} 1.0  0 \\\\ 0  1.0 \\end{bmatrix}\\,\\mathrm{mm}^2$。\n  - 门限：$\\gamma = 9.0$。\n  - 径迹：\n    - 径迹 1：$\\mathbf{x}_1 = [10.0, 10.0]\\,\\mathrm{mm}$，$\\mathbf{S}_1 = \\begin{bmatrix} 0.5  0 \\\\ 0  0.5 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(1)} = 0.9$，$P_T^{(1)} = 0.95$。\n    - 径迹 2：$\\mathbf{x}_2 = [20.0, 20.0]\\,\\mathrm{mm}$，$\\mathbf{S}_2 = \\begin{bmatrix} 0.7  0 \\\\ 0  0.7 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(2)} = 0.85$，$P_T^{(2)} = 0.9$。\n  - 命中：$\\mathbf{z}_1 = [9.6, 10.4]\\,\\mathrm{mm}$，$\\mathbf{z}_2 = [20.2, 19.7]\\,\\mathrm{mm}$，$\\mathbf{z}_3 = [50.0, 50.0]\\,\\mathrm{mm}$。\n\n- 测试用例 2 (三个径迹，三个命中，竞争一个命中)：\n  - 传感器面积：$A = 400\\,\\mathrm{mm}^2$，预期杂波：$\\Lambda = 0.2$，因此 $\\lambda = 0.0005\\,\\mathrm{mm}^{-2}$。\n  - 测量协方差：$\\mathbf{R} = \\begin{bmatrix} 0.2  0 \\\\ 0  0.2 \\end{bmatrix}\\,\\mathrm{mm}^2$。\n  - 门限：$\\gamma = 4.0$。\n  - 径迹：\n    - 径迹 1：$\\mathbf{x}_1 = [0.0, 0.0]\\,\\mathrm{mm}$，$\\mathbf{S}_1 = \\begin{bmatrix} 0.3  0 \\\\ 0  0.3 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(1)} = 0.95$，$P_T^{(1)} = 0.99$。\n    - 径迹 2：$\\mathbf{x}_2 = [0.5, 0.0]\\,\\mathrm{mm}$，$\\mathbf{S}_2 = \\begin{bmatrix} 0.3  0 \\\\ 0  0.3 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(2)} = 0.95$，$P_T^{(2)} = 0.99$。\n    - 径迹 3：$\\mathbf{x}_3 = [5.0, 5.0]\\,\\mathrm{mm}$，$\\mathbf{S}_3 = \\begin{bmatrix} 0.3  0 \\\\ 0  0.3 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(3)} = 0.9$，$P_T^{(3)} = 0.9$。\n  - 命中：$\\mathbf{z}_1 = [0.2, -0.1]\\,\\mathrm{mm}$，$\\mathbf{z}_2 = [0.6, 0.1]\\,\\mathrm{mm}$，$\\mathbf{z}_3 = [5.1, 4.9]\\,\\mathrm{mm}$。\n\n- 测试用例 3 (一个径迹，命中在门控外，低探测概率)：\n  - 传感器面积：$A = 10000\\,\\mathrm{mm}^2$，预期杂波：$\\Lambda = 1.0$，因此 $\\lambda = 0.0001\\,\\mathrm{mm}^{-2}$。\n  - 测量协方差：$\\mathbf{R} = \\begin{bmatrix} 1.0  0 \\\\ 0  1.0 \\end{bmatrix}\\,\\mathrm{mm}^2$。\n  - 门限：$\\gamma = 9.0$。\n  - 径迹 1：$\\mathbf{x}_1 = [100.0, 100.0]\\,\\mathrm{mm}$，$\\mathbf{S}_1 = \\begin{bmatrix} 1.0  0 \\\\ 0  1.0 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(1)} = 0.2$，$P_T^{(1)} = 0.8$。\n  - 命中：$\\mathbf{z}_1 = [110.0, 110.0]\\,\\mathrm{mm}$，$\\mathbf{z}_2 = [90.0, 90.0]\\,\\mathrm{mm}$。\n\n- 测试用例 4 (在门限处的边界门控)：\n  - 传感器面积：$A = 100\\,\\mathrm{mm}^2$，预期杂波：$\\Lambda = 0.1$，因此 $\\lambda = 0.001\\,\\mathrm{mm}^{-2}$。\n  - 测量协方差：$\\mathbf{R} = \\begin{bmatrix} 10^{-8}  0 \\\\ 0  10^{-8} \\end{bmatrix}\\,\\mathrm{mm}^2$。\n  - 门限：$\\gamma = 4.0$。\n  - 径迹 1：$\\mathbf{x}_1 = [0.0, 0.0]\\,\\mathrm{mm}$，$\\mathbf{S}_1 = \\begin{bmatrix} 1.0  0 \\\\ 0  1.0 \\end{bmatrix}\\,\\mathrm{mm}^2$，$P_D^{(1)} = 0.7$，$P_T^{(1)} = 0.9$。\n  - 命中：$\\mathbf{z}_1 = [2.0, 0.0]\\,\\mathrm{mm}$，$\\mathbf{z}_2 = [10.0, 0.0]\\,\\mathrm{mm}$。\n\n程序输出规范：\n- 对于每个测试用例，计算 MAP 分配，并生成一个整数列表，其长度等于径迹数量，使用从零开始的索引表示命中索引，使用 $-1$ 表示漏检。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是每个测试用例的分配列表。例如，输出应类似于 $[\\,[a_{1,1}, a_{1,2}, \\dots], [a_{2,1}, \\dots], \\dots\\,]$，使用从零开始的索引，并用 $-1$ 表示漏检。", "solution": "我们从概率论和一个符合物理现实的测量模型开始。一个外推到探测器层的候选径迹 $i$ 由一个预测位置 $\\mathbf{x}_i \\in \\mathbb{R}^2$ 和一个外推协方差 $\\mathbf{S}_i \\in \\mathbb{R}^{2 \\times 2}$ 表示。一个测量到的命中 $\\mathbf{z}_j \\in \\mathbb{R}^2$ 被建模为受到探测器噪声（其协方差为 $\\mathbf{R} \\in \\mathbb{R}^{2 \\times 2}$）污染的真实位置。在标准假设下，一个关联命中的条件分布是多元正态 (MVN) 分布，$\\mathbf{z}_j \\mid \\text{track } i \\sim \\mathcal{N}(\\mathbf{x}_i, \\mathbf{C}_i)$，其中 $\\mathbf{C}_i = \\mathbf{S}_i + \\mathbf{R}$。所有位置均以毫米 (mm) 测量，协方差以平方毫米 ($\\mathrm{mm}^2$) 测量。\n\n为确保物理和数值上的真实性，我们应用一个基于马氏距离平方的门控\n$$\nd_{ij}^2 = (\\mathbf{z}_j - \\mathbf{x}_i)^\\top \\mathbf{C}_i^{-1} (\\mathbf{z}_j - \\mathbf{x}_i),\n$$\n并且只考虑满足 $d_{ij}^2 \\le \\gamma$ 的关联 $(i,j)$，其中 $\\gamma  0$ 是一个指定的门限（例如，对应于 MVN 分布下的一个置信区域）。\n\n我们将伪命中建模为传感器区域 $A$ 上的均匀泊松点过程 (PPP)，其期望计数为 $\\Lambda$，从而得到空间杂波密度 $\\lambda = \\Lambda / A$（单位 $\\mathrm{mm}^{-2}$）。该密度为评估一个命中是杂波而非源自特定径迹的可能性提供了一个参考。\n\n每个径迹 $i$ 都有一个探测概率 (PoD) $P_D^{(i)} \\in (0,1)$ 和一个先验存在概率 $P_T^{(i)} \\in (0,1)$。给定一个命中 $\\mathbf{z}_j$，一个可接受关联 $(i,j)$ 的局部似然比可由贝叶斯规则和 PPP 杂波模型得出：\n$$\nL_{ij} = \\frac{P_D^{(i)} \\, \\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i)}{\\lambda}.\n$$\n对于不可接受的 $(i,j)$（在门控之外），我们设置 $L_{ij} = 0$。径迹 $i$ 的漏检假设的似然比为\n$$\nL_{i0} = 1 - P_D^{(i)}.\n$$\n这些量是无量纲的，因为 $\\mathcal{N}(\\cdot)$ 和 $\\lambda$ 都是密度，而 $P_D^{(i)}$ 是无量纲的。\n\n对于每径迹关联概率，我们使用以下公式进行归一化\n$$\np_{ij} = \\frac{L_{ij}}{L_{i0} + \\sum_{k} L_{ik}}, \\quad p_{i0} = \\frac{L_{i0}}{L_{i0} + \\sum_{k} L_{ik}},\n$$\n这可由贝叶斯规则在径迹 $i$ 的互斥假设下得出。\n\n全局最大后验 (MAP) 分配问题考虑将每个径迹分配给单个假设 $a(i)$（特定的命中索引 $j$ 或表示漏检的 $0$），同时强制要求每个命中最多只能分配给一个径迹。在独立性假设下，并忽略与分配无关的常数，联合后验概率正比于\n$$\n\\prod_i \\left( P_T^{(i)} \\cdot L_{i,a(i)} \\right),\n$$\n因此我们寻求最大化\n$$\n\\sum_i \\left[ \\log P_T^{(i)} + \\log L_{i,a(i)} \\right].\n$$\n如果我们构建一个合适的代价矩阵，这就是一个线性分配问题。对于可接受的关联 $(i,j)$，定义代价为\n$$\nc_{ij} = -\\left(\\log P_T^{(i)} + \\log P_D^{(i)} + \\log \\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i) - \\log \\lambda \\right),\n$$\n对于不可接受的关联，将 $c_{ij}$ 设置为一个非常大的值，以有效禁止该配对。对于漏检，我们为每个径迹定义一个唯一的虚拟列，其代价为\n$$\nc_{i,\\text{miss}} = -\\left(\\log P_T^{(i)} + \\log(1 - P_D^{(i)})\\right).\n$$\n对于 $N$ 个径迹和 $M$ 个命中，我们通过附加 $N$ 个漏检列（每个径迹一个）来构建一个大小为 $N \\times (M + N)$ 的代价矩阵。这确保算法为每个径迹精确分配一个假设，并强制每个命中最多只能被分配一次。然后可以使用匈牙利算法（也称为 Kuhn–Munkres 算法）来找到最小化总代价的分配，这对应于 MAP 解。\n\n实现细节：\n- 为每个径迹计算 $\\mathbf{C}_i = \\mathbf{S}_i + \\mathbf R$。\n- 使用数值稳定的方法计算 $d_{ij}^2$，例如求解 $\\mathbf{C}_i \\mathbf{y} = \\mathbf{z}_j - \\mathbf{x}_i$ 得到 $\\mathbf{y}$，然后计算 $d_{ij}^2 = (\\mathbf{z}_j - \\mathbf{x}_i)^\\top \\mathbf{y}$。\n- 计算 MVN 密度\n$$\n\\mathcal{N}(\\mathbf{z}_j; \\mathbf{x}_i, \\mathbf{C}_i) = \\frac{1}{2\\pi \\sqrt{\\det \\mathbf{C}_i}} \\exp\\left( -\\frac{1}{2} d_{ij}^2 \\right).\n$$\n- 使用一个大的有限代价（例如 $10^9$）来表示不允许的分配。通过不对门控外的配对计算对数密度来避免对 $0$ 取对数。\n- 对于每个测试用例，构建代价矩阵，求解分配问题，并解码结果：如果一个径迹被分配给命中列 $j  M$，则输出 $j$；如果它被分配给其唯一的漏检列，则输出 $-1$。\n\n边界情况：\n- 如果一个径迹的所有配对都在门控之外，它将被分配为漏检，因为可接受的命中代价实际上是无限大，而 $c_{i,\\text{miss}}$ 是有限的。\n- 如果马氏距离的平方等于门限（$d_{ij}^2 = \\gamma$），根据定义（$\\le \\gamma$），该关联是可接受的，并且其密度会相应地计入贡献。\n- 当 $P_D^{(i)}$ 较低时，即使某些命中在门控内，$c_{i,\\text{miss}}$ 也可能相对于命中关联变得有竞争力，这反映了低探测概率的内在物理原理。\n\n程序将计算四个提供的测试用例的分配，并打印一行包含分配列表的列表，其中每个分配列表都是一个使用从零开始的命中索引和 $-1$ 表示漏检的整数列表。此输出是无量纲的，因为它表示离散索引。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef mvn_density(diff: np.ndarray, C: np.ndarray) -> tuple[float, float]:\n    \"\"\"\n    Compute the multivariate normal density N(z; x, C) at diff = z - x\n    where C is the covariance matrix.\n    Returns density and Mahalanobis distance squared.\n    \"\"\"\n    # Solve C y = diff to avoid explicit inverse for Mahalanobis distance\n    try:\n        y = np.linalg.solve(C, diff)\n    except np.linalg.LinAlgError:\n        # In case C is ill-conditioned, fall back to pseudo-inverse\n        y = np.linalg.pinv(C).dot(diff)\n    d2 = float(diff.T.dot(y))\n    detC = float(np.linalg.det(C))\n    if detC = 0:\n        # Numerical safeguard: if covariance is near-singular, use pseudo-det via SVD\n        s = np.linalg.svd(C, compute_uv=False)\n        detC = float(np.prod(s))\n        # If still zero, return an extremely small density\n        if detC = 0:\n            return 0.0, d2\n    norm_const = 1.0 / (2.0 * np.pi * np.sqrt(detC))\n    return norm_const * np.exp(-0.5 * d2), d2\n\ndef compute_cost_matrix(tracks, hits, R, gamma, lam):\n    \"\"\"\n    Build the cost matrix for MAP assignment.\n    tracks: list of dicts with keys x (2,), S (2x2), P_D, P_T\n    hits: list of 2D arrays\n    R: 2x2 measurement covariance\n    gamma: gating threshold\n    lam: clutter density (Lambda / A)\n    Returns:\n        cost_matrix: shape (N_tracks, N_hits + N_tracks)\n    \"\"\"\n    n_tracks = len(tracks)\n    n_hits = len(hits)\n    big_M = 1e9  # large cost for disallowed\n    cost = np.full((n_tracks, n_hits + n_tracks), big_M, dtype=float)\n    for i, trk in enumerate(tracks):\n        x = np.array(trk[\"x\"], dtype=float)\n        S = np.array(trk[\"S\"], dtype=float)\n        P_D = float(trk[\"P_D\"])\n        P_T = float(trk[\"P_T\"])\n        C = S + R\n        # Missed detection column for track i\n        miss_col = n_hits + i\n        # c_{i,miss} = - [ log P_T + log(1 - P_D) ]\n        miss_cost = - (np.log(P_T) + np.log(max(1e-12, 1.0 - P_D)))\n        cost[i, miss_col] = miss_cost\n        # Hit costs\n        for j, z in enumerate(hits):\n            z = np.array(z, dtype=float)\n            diff = z - x\n            density, d2 = mvn_density(diff, C)\n            if d2 = gamma and density > 0.0:\n                # c_{ij} = - [ log P_T + log P_D + log N - log lam ]\n                cij = - (np.log(P_T) + np.log(P_D) + np.log(density) - np.log(lam))\n                cost[i, j] = cij\n            else:\n                # inadmissible or negligible density\n                cost[i, j] = big_M\n    return cost\n\ndef map_assignment(tracks, hits, R, gamma, A, Lambda):\n    \"\"\"\n    Compute MAP assignment given tracks and hits.\n    Returns a list of ints per track: hit index (0-based) or -1 for missed detection.\n    \"\"\"\n    lam = Lambda / A\n    cost = compute_cost_matrix(tracks, hits, R, gamma, lam)\n    row_ind, col_ind = linear_sum_assignment(cost)\n    n_hits = len(hits)\n    assignment = [-1] * len(tracks)\n    for i, j in zip(row_ind, col_ind):\n        if j  n_hits:\n            # Assigned to hit j\n            assignment[i] = j\n        else:\n            # Assigned to missed detection (unique column per track)\n            assignment[i] = -1\n    return assignment\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"A\": 10000.0,\n            \"Lambda\": 0.5,\n            \"R\": np.array([[1.0, 0.0], [0.0, 1.0]], dtype=float),\n            \"gamma\": 9.0,\n            \"tracks\": [\n                {\"x\": [10.0, 10.0], \"S\": np.array([[0.5, 0.0], [0.0, 0.5]], dtype=float), \"P_D\": 0.9, \"P_T\": 0.95},\n                {\"x\": [20.0, 20.0], \"S\": np.array([[0.7, 0.0], [0.0, 0.7]], dtype=float), \"P_D\": 0.85, \"P_T\": 0.9},\n            ],\n            \"hits\": [\n                [9.6, 10.4],\n                [20.2, 19.7],\n                [50.0, 50.0],\n            ],\n        },\n        # Test Case 2\n        {\n            \"A\": 400.0,\n            \"Lambda\": 0.2,\n            \"R\": np.array([[0.2, 0.0], [0.0, 0.2]], dtype=float),\n            \"gamma\": 4.0,\n            \"tracks\": [\n                {\"x\": [0.0, 0.0], \"S\": np.array([[0.3, 0.0], [0.0, 0.3]], dtype=float), \"P_D\": 0.95, \"P_T\": 0.99},\n                {\"x\": [0.5, 0.0], \"S\": np.array([[0.3, 0.0], [0.0, 0.3]], dtype=float), \"P_D\": 0.95, \"P_T\": 0.99},\n                {\"x\": [5.0, 5.0], \"S\": np.array([[0.3, 0.0], [0.0, 0.3]], dtype=float), \"P_D\": 0.9, \"P_T\": 0.9},\n            ],\n            \"hits\": [\n                [0.2, -0.1],\n                [0.6, 0.1],\n                [5.1, 4.9],\n            ],\n        },\n        # Test Case 3\n        {\n            \"A\": 10000.0,\n            \"Lambda\": 1.0,\n            \"R\": np.array([[1.0, 0.0], [0.0, 1.0]], dtype=float),\n            \"gamma\": 9.0,\n            \"tracks\": [\n                {\"x\": [100.0, 100.0], \"S\": np.array([[1.0, 0.0], [0.0, 1.0]], dtype=float), \"P_D\": 0.2, \"P_T\": 0.8},\n            ],\n            \"hits\": [\n                [110.0, 110.0],\n                [90.0, 90.0],\n            ],\n        },\n        # Test Case 4\n        {\n            \"A\": 100.0,\n            \"Lambda\": 0.1,\n            \"R\": np.array([[1e-8, 0.0], [0.0, 1e-8]], dtype=float),\n            \"gamma\": 4.0,\n            \"tracks\": [\n                {\"x\": [0.0, 0.0], \"S\": np.array([[1.0, 0.0], [0.0, 1.0]], dtype=float), \"P_D\": 0.7, \"P_T\": 0.9},\n            ],\n            \"hits\": [\n                [2.0, 0.0],\n                [10.0, 0.0],\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        Lambda = case[\"Lambda\"]\n        R = case[\"R\"]\n        gamma = case[\"gamma\"]\n        tracks = case[\"tracks\"]\n        hits = case[\"hits\"]\n        assignment = map_assignment(tracks, hits, R, gamma, A, Lambda)\n        results.append(assignment)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3539732"}, {"introduction": "一旦一个击中点被成功地关联到一条径迹上，下一步的核心任务就是利用这个新的测量信息来更新径迹的状态（如位置、动量）及其不确定度，卡尔曼滤波器（Kalman Filter）正是完成这一递归状态估计的标准工具。本练习 [@problem_id:3539735] 提供了一个具体的数值计算案例，让你亲手执行一次卡尔曼滤波器的“预测-更新”循环。通过这个练习，你将深入理解滤波器如何权衡先验知识和新测量数据，并掌握其核心算法的每一个细节。", "problem": "在对撞机实验中，一个带电粒子径迹在两个硅探测器层中被重建。从前一个表面到当前测量平面的一个小步长内，采用线性化状态空间径迹模型，其状态向量为 $\\mathbf{x} = (u, t)^{\\mathsf{T}}$，其中 $u$ 是以 $\\mathrm{cm}$ 为单位的局部横向位置，$t = \\mathrm{d}u/\\mathrm{d}z$ 是局部斜率（无量纲）。过程模型是线性的，具有输运矩阵 $F$ 和表示微小多重散射涨落的过程噪声协方差 $Q$。当前平面上的测量是一个单击中坐标 $y$，它通过一个测量矩阵 $H$ 与状态线性相关，测量噪声协方差为 $R$。所有噪声都假定为零均值高斯分布、相互独立，并具有给定的协方差。你需要从之前的滤波状态开始，执行一个预测-更新循环，以整合该击中点。\n\n使用以下数值输入：\n- 前一个滤波状态和协方差：$\\mathbf{x}_{0} = \\begin{pmatrix} 0.05 \\\\ 0.002 \\end{pmatrix}$，$P_{0} = \\begin{pmatrix} 1.0 \\times 10^{-4}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix}$。\n- 输运矩阵和过程噪声协方差：$F = \\begin{pmatrix} 1  20 \\\\ 0  1 \\end{pmatrix}$，$Q = \\begin{pmatrix} 1.0 \\times 10^{-5}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix}$。\n- 测量模型和噪声协方差：$H = \\begin{pmatrix} 1  0 \\end{pmatrix}$，$R = 4.0 \\times 10^{-4}$。\n- 测得的击中坐标：$y = 0.115$（单位 $\\mathrm{cm}$）。\n\n从状态传播和测量的贝叶斯线性高斯模型的第一性原理出发，推导并计算：\n1. 预测状态 $\\mathbf{x}^{-}$ 和预测协方差 $P^{-}$。\n2. 用于更新的测量残差 $r$、新息协方差 $S$ 和最优线性增益（卡尔曼增益） $K$。\n3. 整合击中点后的更新状态 $\\mathbf{x}^{+}$ 和更新协方差 $P^{+}$。\n4. 该击中点贡献的增量卡方 $\\Delta \\chi^{2}$。\n\n将增量卡方 $\\Delta \\chi^{2}$ 作为你的最终数值答案。将你的答案四舍五入到四位有效数字。由于 $\\Delta \\chi^{2}$ 是无量纲的，最终答案不应报告单位。", "solution": "该问题要求执行线性卡尔曼滤波器的一个预测-更新循环，以便将新的测量值整合到带电粒子径迹的状态估计中。该过程基于线性高斯系统的贝叶斯推断原理。我们将首先验证问题陈述，然后系统地推导和计算所要求的量。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n- 前一个滤波状态向量：$\\mathbf{x}_{0} = \\begin{pmatrix} 0.05 \\\\ 0.002 \\end{pmatrix}$\n- 前一个滤波协方差矩阵：$P_{0} = \\begin{pmatrix} 1.0 \\times 10^{-4}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix}$\n- 输运矩阵：$F = \\begin{pmatrix} 1  20 \\\\ 0  1 \\end{pmatrix}$\n- 过程噪声协方差矩阵：$Q = \\begin{pmatrix} 1.0 \\times 10^{-5}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix}$\n- 测量矩阵：$H = \\begin{pmatrix} 1  0 \\end{pmatrix}$\n- 测量噪声协方差（标量）：$R = 4.0 \\times 10^{-4}$\n- 测得的击中坐标（标量）：$y = 0.115$\n\n**步骤2：使用提取的给定信息进行验证**\n- **科学依据：** 该问题描述了卡尔曼滤波器在高能物理中径迹重建的标准应用。线性状态空间模型对于小步长传播是常见且有效的近似。状态向量分量（$u$ 表示位置，$t$ 表示斜率）和矩阵（$F$ 表示线性输运，$Q$ 表示多重散射，$H$ 表示位置测量，$R$ 表示传感器分辨率）的物理解释在该领域都是标准的。对于硅探测器系统，这些数值是物理上合理的。\n- **适定性：** 问题提供了执行卡尔曼滤波器一个循环所需的全部初始条件和模型参数。计算过程将导出一个唯一且稳定的解。\n- **客观性：** 问题陈述使用了精确的数学和物理术语，没有含糊不清或主观的论断。\n\n**步骤3：结论与行动**\n该问题是有效的。这是一个在应用卡尔曼滤波器算法方面适定且有科学依据的练习。我们将继续进行求解。\n\n### 推导与计算\n\n卡尔曼滤波器循环包括两个主要步骤：预测步骤（将状态传播到新的测量表面）和更新步骤（使用新的测量值校正状态）。\n\n**1. 预测状态和协方差**\n\n状态使用输运矩阵 $F$ 从前一个表面传播到当前测量平面。过程噪声 $Q$ 解释了在此输运过程中增加的不确定性，例如由多重散射引起的不确定性。\n\n预测（先验）状态 $\\mathbf{x}^{-}$ 是传播后状态的期望值：\n$$\n\\mathbf{x}^{-} = F \\mathbf{x}_{0}\n$$\n预测（先验）协方差 $P^{-}$ 是传播后的前一协方差与过程噪声协方差之和：\n$$\nP^{-} = F P_{0} F^{\\mathsf{T}} + Q\n$$\n代入给定值：\n$$\n\\mathbf{x}^{-} = \\begin{pmatrix} 1  20 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 0.05 \\\\ 0.002 \\end{pmatrix} = \\begin{pmatrix} 1 \\cdot (0.05) + 20 \\cdot (0.002) \\\\ 0 \\cdot (0.05) + 1 \\cdot (0.002) \\end{pmatrix} = \\begin{pmatrix} 0.05 + 0.04 \\\\ 0.002 \\end{pmatrix} = \\begin{pmatrix} 0.09 \\\\ 0.002 \\end{pmatrix}\n$$\n对于协方差：\n$$\nF P_{0} F^{\\mathsf{T}} = \\begin{pmatrix} 1  20 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\times 10^{-4}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 20  1 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} 1.0 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 20  1 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} (1.0 \\times 10^{-4}) + (2.0 \\times 10^{-5})(20)  2.0 \\times 10^{-5} \\\\ 1.0 \\times 10^{-6}(20)  1.0 \\times 10^{-6} \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} 1.0 \\times 10^{-4} + 4.0 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  1.0 \\times 10^{-6} \\end{pmatrix} = \\begin{pmatrix} 5.0 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  1.0 \\times 10^{-6} \\end{pmatrix}\n$$\n现在，加上过程噪声协方差 $Q$：\n$$\nP^{-} = \\begin{pmatrix} 5.0 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  1.0 \\times 10^{-6} \\end{pmatrix} + \\begin{pmatrix} 1.0 \\times 10^{-5}  0 \\\\ 0  1.0 \\times 10^{-6} \\end{pmatrix}\n$$\n$$\nP^{-} = \\begin{pmatrix} 5.1 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  2.0 \\times 10^{-6} \\end{pmatrix}\n$$\n\n**2. 测量残差、新息协方差和卡尔曼增益**\n\n测量残差 $r$（或称新息）是实际测量值 $y$ 与预测测量值 $H \\mathbf{x}^{-}$ 之间的差值。新息协方差 $S$ 是该残差的方差。卡尔曼增益 $K$ 是将预测与残差相结合的最优权重。\n\n残差 $r$ 为：\n$$\nr = y - H \\mathbf{x}^{-}\n$$\n新息协方差 $S$ 为：\n$$\nS = H P^{-} H^{\\mathsf{T}} + R\n$$\n卡尔曼增益 $K$ 为：\n$$\nK = P^{-} H^{\\mathsf{T}} S^{-1}\n$$\n代入数值：\n$$\nr = 0.115 - \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 0.09 \\\\ 0.002 \\end{pmatrix} = 0.115 - 0.09 = 0.025\n$$\n对于新息协方差 $S$（在本例中为标量）：\n$$\nH P^{-} H^{\\mathsf{T}} = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 5.1 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  2.0 \\times 10^{-6} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 5.1 \\times 10^{-4}  2.0 \\times 10^{-5} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 5.1 \\times 10^{-4}\n$$\n$$\nS = H P^{-} H^{\\mathsf{T}} + R = (5.1 \\times 10^{-4}) + (4.0 \\times 10^{-4}) = 9.1 \\times 10^{-4}\n$$\n对于卡尔曼增益 $K$（这是一个 $2 \\times 1$ 的向量）：\n$$\nP^{-} H^{\\mathsf{T}} = \\begin{pmatrix} 5.1 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  2.0 \\times 10^{-6} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 5.1 \\times 10^{-4} \\\\ 2.0 \\times 10^{-5} \\end{pmatrix}\n$$\n$$\nK = P^{-} H^{\\mathsf{T}} S^{-1} = \\begin{pmatrix} 5.1 \\times 10^{-4} \\\\ 2.0 \\times 10^{-5} \\end{pmatrix} (9.1 \\times 10^{-4})^{-1} = \\frac{1}{9.1 \\times 10^{-4}} \\begin{pmatrix} 5.1 \\times 10^{-4} \\\\ 2.0 \\times 10^{-5} \\end{pmatrix} = \\frac{1}{9.1} \\begin{pmatrix} 5.1 \\\\ 0.2 \\end{pmatrix}\n$$\n\n**3. 更新状态和协方差**\n\n更新（后验）状态 $\\mathbf{x}^{+}$ 是由加权残差校正的预测状态。更新协方差 $P^{+}$ 是预测协方差减去从测量中获得的信息。\n\n更新状态 $\\mathbf{x}^{+}$ 为：\n$$\n\\mathbf{x}^{+} = \\mathbf{x}^{-} + K r\n$$\n更新协方差 $P^{+}$ 为：\n$$\nP^{+} = (I - K H) P^{-}\n$$\n代入数值：\n$$\n\\mathbf{x}^{+} = \\begin{pmatrix} 0.09 \\\\ 0.002 \\end{pmatrix} + \\frac{1}{9.1} \\begin{pmatrix} 5.1 \\\\ 0.2 \\end{pmatrix} (0.025) = \\begin{pmatrix} 0.09 \\\\ 0.002 \\end{pmatrix} + \\begin{pmatrix} \\frac{0.1275}{9.1} \\\\ \\frac{0.005}{9.1} \\end{pmatrix} \\approx \\begin{pmatrix} 0.09 + 0.01401 \\\\ 0.002 + 0.000549 \\end{pmatrix} = \\begin{pmatrix} 0.10401 \\\\ 0.002549 \\end{pmatrix}\n$$\n对于协方差：\n$$\nK H = \\frac{1}{9.1} \\begin{pmatrix} 5.1 \\\\ 0.2 \\end{pmatrix} \\begin{pmatrix} 1  0 \\end{pmatrix} = \\frac{1}{9.1} \\begin{pmatrix} 5.1  0 \\\\ 0.2  0 \\end{pmatrix}\n$$\n$$\nI - K H = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} - \\frac{1}{9.1} \\begin{pmatrix} 5.1  0 \\\\ 0.2  0 \\end{pmatrix} = \\begin{pmatrix} 1 - \\frac{5.1}{9.1}  0 \\\\ -\\frac{0.2}{9.1}  1 \\end{pmatrix} = \\begin{pmatrix} \\frac{4.0}{9.1}  0 \\\\ -\\frac{0.2}{9.1}  1 \\end{pmatrix}\n$$\n$$\nP^{+} = \\begin{pmatrix} \\frac{4.0}{9.1}  0 \\\\ -\\frac{0.2}{9.1}  1 \\end{pmatrix} \\begin{pmatrix} 5.1 \\times 10^{-4}  2.0 \\times 10^{-5} \\\\ 2.0 \\times 10^{-5}  2.0 \\times 10^{-6} \\end{pmatrix} \\approx \\begin{pmatrix} 2.24 \\times 10^{-4}  8.79 \\times 10^{-6} \\\\ 8.79 \\times 10^{-6}  1.56 \\times 10^{-6} \\end{pmatrix}\n$$\n\n**4. 增量卡方**\n\n增量卡方 $\\Delta \\chi^2$ 量化了测量值与预测状态的兼容性。它是残差的马氏距离（Mahalanobis distance）的平方，并由其协方差归一化。对于标量测量，其表达式为：\n$$\n\\Delta \\chi^{2} = r^{\\mathsf{T}} S^{-1} r = \\frac{r^2}{S}\n$$\n使用先前计算的值：\n$$\nr = 0.025\n$$\n$$\nS = 9.1 \\times 10^{-4}\n$$\n$$\n\\Delta \\chi^{2} = \\frac{(0.025)^2}{9.1 \\times 10^{-4}} = \\frac{6.25 \\times 10^{-4}}{9.1 \\times 10^{-4}} = \\frac{6.25}{9.1} \\approx 0.6868131868...\n$$\n四舍五入到四位有效数字，该击中点贡献的增量卡方为 $0.6868$。", "answer": "$$\n\\boxed{0.6868}\n$$", "id": "3539735"}]}