{"hands_on_practices": [{"introduction": "理论物理学中的实践始于对基石性问题的透彻理解。本节的第一个练习将引导您完成量子场论中一个最基本也是最重要的计算：标量“气泡”图的单圈积分。通过这个练习，您将亲手实践维度正则化的威力，这是一种处理紫外发散的强大技术，并学习如何从积分中精确地分离出发散的极点和有限的物理部分，为更高阶的计算和重整化程序奠定坚实的基础。[@problem_id:3515127]", "problem": "考虑一个在四维闵可夫斯基时空中的无质量标量场论，以及外部动量为 $p$ 的单圈二点（气泡）图。使用维度正则化，将圈动量积分解析延拓到 $d=4-2\\epsilon$ 维，并引入重整化标度 $\\mu$ 以保持积分的无量纲性。标量气泡图积分定义为\n$$\nI(p^{2}) \\equiv \\mu^{2\\epsilon} \\int \\frac{d^{d}k}{(2\\pi)^{d}} \\frac{1}{\\big(k^{2}+i0\\big)\\big((k+p)^{2}+i0\\big)}\\,,\n$$\n其中 $p^{2} \\equiv p_{\\mu}p^{\\mu}$ 且无穷小量 $+i0$ 实现了费曼处方。从量子场论的基本原理出发，即传播子乘积的费曼参数表示和经过充分检验的 $d$ 维高斯积分结果，推导出一个用 $\\epsilon$、$\\mu$ 和 $p^{2}$ 表示的 $I(p^{2})$ 的解析表达式。提取出 $\\epsilon$ 的完整极点结构，并明确给出有限的 $\\mathcal{O}(\\epsilon^{0})$ 阶项。你应该保留维度正则化中出现的欧拉-马歇罗尼常数 $\\gamma_{E}$ 和 $\\ln(4\\pi)$ 因子。假设 $p^{2}$ 是类空的，因此 $\\ln(-p^{2}-i0)$ 通过解析延拓是良定义的。\n\n请以单个闭合形式的解析表达式给出 $I(p^{2})$ 的最终答案，结果包含到有限的 $\\mathcal{O}(\\epsilon^{0})$ 阶项。不需要进行数值舍入，最终表达式中不应包含单位。", "solution": "该问题要求使用维度正则化，在 $d=4-2\\epsilon$ 维中计算单圈无质量标量气泡积分 $I(p^2)$。该积分定义为：\n$$\nI(p^{2}) = \\mu^{2\\epsilon} \\int \\frac{d^{d}k}{(2\\pi)^{d}} \\frac{1}{\\big(k^{2}+i0\\big)\\big((k+p)^{2}+i0\\big)}\n$$\n\n首先，我们使用费曼参数恒等式来合并两个分母：\n$$\n\\frac{1}{A B} = \\int_{0}^{1} dx \\frac{1}{[xA + (1-x)B]^2}\n$$\n令 $A = (k+p)^2+i0$ 和 $B = k^2+i0$。分母变为：\n$$\n[x((k+p)^2+i0) + (1-x)(k^2+i0)]^2 = [k^2 + 2xk \\cdot p + xp^2 + i0]^2\n$$\n我们可以对圈动量 $k$ 进行配方。令 $l = k+xp$，则 $k = l-xp$。方括号中的项变为：\n$$\n(l-xp)^2 + 2x(l-xp)\\cdot p + xp^2 + i0 = l^2 - 2xl\\cdot p + x^2p^2 + 2xl\\cdot p - 2x^2p^2 + xp^2 + i0 = l^2 - x^2p^2 + xp^2 + i0 = l^2 + x(1-x)p^2 + i0\n$$\n现在积分 $I(p^2)$ 为：\n$$\nI(p^2) = \\mu^{2\\epsilon} \\int_0^1 dx \\int \\frac{d^d l}{(2\\pi)^d} \\frac{1}{[l^2 + x(1-x)p^2 + i0]^2}\n$$\n分母可以写为 $(l^2 - \\Delta + i0)^2$，其中 $\\Delta = -x(1-x)p^2$。动量积分可以通过进行威克转动 ($l_0 = i l_{E0}$) 并使用闵可夫斯基空间积分的标准公式来计算：\n$$\n\\int \\frac{d^d l}{(2\\pi)^d} \\frac{1}{(l^2 - \\Delta + i0)^n} = \\frac{i(-1)^n}{(4\\pi)^{d/2}} \\frac{\\Gamma(n-d/2)}{\\Gamma(n)} (\\Delta)^{d/2-n}\n$$\n在我们的情况中，$n=2$ 且 $d=4-2\\epsilon$。因此，$d/2 = 2-\\epsilon$，$n-d/2 = 2-(2-\\epsilon) = \\epsilon$，且 $d/2-n = (2-\\epsilon)-2 = -\\epsilon$。动量积分变为：\n$$\n\\int \\frac{d^d l}{(2\\pi)^d} \\frac{1}{[l^2 - \\Delta + i0]^2} = \\frac{i(-1)^2}{(4\\pi)^{2-\\epsilon}} \\frac{\\Gamma(\\epsilon)}{\\Gamma(2)} (\\Delta)^{-\\epsilon} = \\frac{i}{(4\\pi)^{2-\\epsilon}} \\Gamma(\\epsilon) (\\Delta)^{-\\epsilon}\n$$\n代入 $\\Delta = -x(1-x)p^2$：\n$$\n\\frac{i}{(4\\pi)^{2}} (4\\pi)^{\\epsilon} \\Gamma(\\epsilon) [-x(1-x)p^2]^{-\\epsilon}\n$$\n现在，我们将其代回 $I(p^2)$ 的表达式中：\n$$\nI(p^2) = \\mu^{2\\epsilon} \\int_0^1 dx \\, \\left( \\frac{i}{(4\\pi)^2} (4\\pi)^{\\epsilon} \\Gamma(\\epsilon) [-x(1-x)p^2]^{-\\epsilon} \\right)\n$$\n$$\nI(p^2) = \\frac{i \\Gamma(\\epsilon)}{(4\\pi)^2} (4\\pi \\mu^2)^{\\epsilon} (-p^2)^{-\\epsilon} \\int_0^1 dx \\, [x(1-x)]^{-\\epsilon}\n$$\n剩下的关于费曼参数 $x$ 的积分是欧拉贝塔函数：\n$$\n\\int_0^1 dx \\, x^{-\\epsilon} (1-x)^{-\\epsilon} = B(1-\\epsilon, 1-\\epsilon) = \\frac{\\Gamma(1-\\epsilon)\\Gamma(1-\\epsilon)}{\\Gamma(2-2\\epsilon)}\n$$\n因此 $I(p^2)$ 的完整表达式为：\n$$\nI(p^2) = \\frac{i}{(4\\pi)^2} \\Gamma(\\epsilon) \\left( \\frac{4\\pi \\mu^2}{-p^2} \\right)^{\\epsilon} \\frac{\\Gamma(1-\\epsilon)^2}{\\Gamma(2-2\\epsilon)}\n$$\n为了找到极点结构和有限项，我们对该表达式在小 $\\epsilon$ 情况下进行展开。我们使用以下展开式：\n1. $\\Gamma(\\epsilon) = \\frac{1}{\\epsilon} - \\gamma_E + \\mathcal{O}(\\epsilon)$\n2. $\\left( \\frac{4\\pi \\mu^2}{-p^2} \\right)^{\\epsilon} = \\exp\\left[\\epsilon \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right)\\right] = 1 + \\epsilon \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) + \\mathcal{O}(\\epsilon^2)$\n3. $\\Gamma(1-\\epsilon) = 1 + \\epsilon\\gamma_E + \\mathcal{O}(\\epsilon^2)$，所以 $\\Gamma(1-\\epsilon)^2 = 1 + 2\\epsilon\\gamma_E + \\mathcal{O}(\\epsilon^2)$\n4. $\\Gamma(2-2\\epsilon) = (1-2\\epsilon)\\Gamma(1-2\\epsilon) \\approx (1-2\\epsilon)(1+2\\epsilon\\gamma_E) = 1+2\\epsilon\\gamma_E-2\\epsilon + \\mathcal{O}(\\epsilon^2)$。因此，$\\frac{1}{\\Gamma(2-2\\epsilon)} \\approx 1-(2\\epsilon\\gamma_E-2\\epsilon) = 1-2\\epsilon\\gamma_E+2\\epsilon + \\mathcal{O}(\\epsilon^2)$。\nGamma 函数的比值为：\n$$\n\\frac{\\Gamma(1-\\epsilon)^2}{\\Gamma(2-2\\epsilon)} \\approx (1+2\\epsilon\\gamma_E)(1-2\\epsilon\\gamma_E+2\\epsilon) = 1 - 2\\epsilon\\gamma_E + 2\\epsilon + 2\\epsilon\\gamma_E + \\mathcal{O}(\\epsilon^2) = 1 + 2\\epsilon + \\mathcal{O}(\\epsilon^2)\n$$\n现在，我们将这些展开式相乘：\n$$\nI(p^2) = \\frac{i}{16\\pi^2} \\left[ \\frac{1}{\\epsilon} - \\gamma_E + \\mathcal{O}(\\epsilon) \\right] \\left[ 1 + \\epsilon \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) + \\mathcal{O}(\\epsilon^2) \\right] \\left[ 1 + 2\\epsilon + \\mathcal{O}(\\epsilon^2) \\right]\n$$\n我们先将最后两个括号相乘：\n$$\n\\left[ 1 + \\epsilon \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) \\right] [1+2\\epsilon] = 1 + 2\\epsilon + \\epsilon \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) + \\mathcal{O}(\\epsilon^2) = 1 + \\epsilon \\left[ 2 + \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) \\right] + \\mathcal{O}(\\epsilon^2)\n$$\n最后，我们乘以 $\\Gamma(\\epsilon)$ 的展开式：\n$$\nI(p^2) = \\frac{i}{16\\pi^2} \\left[ \\frac{1}{\\epsilon} - \\gamma_E \\right] \\left[ 1 + \\epsilon \\left( 2 + \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) \\right) \\right] + \\mathcal{O}(\\epsilon)\n$$\n$$\nI(p^2) = \\frac{i}{16\\pi^2} \\left[ \\frac{1}{\\epsilon} \\left( 1 + \\epsilon \\left( 2 + \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) \\right) \\right) - \\gamma_E(1) \\right] + \\mathcal{O}(\\epsilon)\n$$\n$$\nI(p^2) = \\frac{i}{16\\pi^2} \\left[ \\frac{1}{\\epsilon} + 2 + \\ln\\left(\\frac{4\\pi \\mu^2}{-p^2}\\right) - \\gamma_E \\right] + \\mathcal{O}(\\epsilon)\n$$\n题目指明使用 $\\ln(-p^2-i0)$ 进行解析延拓。对于类空的 $p^20$，有 $-p^20$，因此 $\\ln(-p^2-i0) = \\ln(|-p^2|)$。我们的结果成立。最终表达式，包括在 $\\epsilon=0$ 处的极点和所有 $\\mathcal{O}(\\epsilon^0)$ 阶项，为：\n$$\nI(p^2) = \\frac{i}{16\\pi^2} \\left( \\frac{1}{\\epsilon} - \\gamma_E + 2 + \\ln\\left(\\frac{4\\pi\\mu^2}{-p^2-i0}\\right) \\right)\n$$\n该表达式包含了所要求的极点结构和有限项。", "answer": "$$\\boxed{\\frac{i}{16\\pi^{2}} \\left( \\frac{1}{\\epsilon} - \\gamma_{E} + 2 + \\ln\\left(\\frac{4\\pi\\mu^{2}}{-p^{2}-i0}\\right) \\right)}$$", "id": "3515127"}, {"introduction": "在掌握了基本的标量积分之后，我们面临着更普遍的挑战：含有圈动量的张量积分。本练习将向您介绍Passarino-Veltman约化方法，这是一种将任何单圈张量积分系统地分解为一组标准标量积分（如 $B_0$, $C_0$, $D_0$）的算法。通过编程实现并验证这一过程，您将体验到将复杂问题转化为可计算模块的强大思想，这是现代高能物理自动化计算流程的核心。[@problem_id:3515188]", "problem": "实现一个完整的、可运行的程序，对特定的单圈张量积分执行基于原理的 Passarino–Veltman 约化，并使用 Feynman 参数表示法，根据标量积分基对该约化进行数值验证。所有计算必须在维数正规化下，并采用常规的圈积分归一化。仅使用确定性数值求积；不要进行随机抽样。\n\n数学设定如下。考虑 $d$ 维中的单圈 $N$ 点张量积分，其分母为 $D_i = (\\ell + q_i)^2 - m_i^2 + i0$,\n$$\nI_N^{\\mu_1\\cdots\\mu_r}(d) \\equiv \\mu^{4-d} \\int \\frac{d^d\\ell}{i\\pi^{d/2}} \\frac{\\ell^{\\mu_1}\\cdots \\ell^{\\mu_r}}{D_1 \\cdots D_N}\\,,\n$$\n其中 $\\mu$ 是重整化标度，度规为闵可夫斯基度规。标量积分是秩 $r=0$ 时的 $I_N(d)$。Passarino–Veltman 约化将任意张量积分表示为由 $g^{\\mu\\nu}$ 和外动量 $q_i$ 构建的张量结构之和，其标量系数是标量基 $A_0$、$B_0$、$C_0$ 和 $D_0$ 的线性组合。\n\n使用 $d=4$ 和以下 Feynman 参数表示，这些表示可从维数正规化中的基本 Feynman 参数恒等式和动量平移推导得出。设 $x_i \\ge 0$ 且 $\\sum_i x_i = 1$，并定义 $Q^\\mu \\equiv \\sum_{i=1}^N x_i q_i^\\mu$ 和\n$$\n\\Delta \\equiv \\sum_{i=1}^N x_i\\,(q_i^2 - m_i^2) - Q^2 \\,.\n$$\n使用上述归一化，我们有\n$$\nB_0(p^2;m_1^2,m_2^2) = \\Delta_{\\text{div}} + B_0^{\\text{fin}}(p^2;m_1^2,m_2^2)\\,,\n\\quad\nB_0^{\\text{fin}}(p^2;m_1^2,m_2^2) = - \\int_0^1 dx\\, \\ln\\!\\left(\\frac{x\\,m_1^2 + (1-x)\\,m_2^2 - x(1-x)\\,p^2}{\\mu^2}\\right),\n$$\n$$\nC_0(q_1,q_2,q_3;m_1^2,m_2^2,m_3^2) = - \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta}\\,,\n$$\n$$\nD_0(q_1,q_2,q_3,q_4;m_1^2,m_2^2,m_3^2,m_4^2) = \\int_{x_1,x_2,x_3 \\ge 0,\\, x_1+x_2+x_3 \\le 1} \\frac{dx_1\\,dx_2\\,dx_3}{\\Delta^2}\\,,\n$$\n其中 $\\Delta_{\\text{div}}$ 表示维数正规化中的常规发散项，该项在适当的差分中会被抵消；在下面的所有验证中，您必须仅在那些会抵消的组合中使用 $B_0^{\\text{fin}}$。对于测试套件中提供的严格离壳运动学，上述表示是良定义且有限的。\n\n实现 $N=3$ 且 $q_3^\\mu \\equiv 0$ 的秩为 1 的三角图约化，使得 $q_1^\\mu$ 和 $q_2^\\mu$ 张成外空间。定义格拉姆矩阵 $G_{ij} \\equiv q_i \\cdot q_j$ (其中 $i,j \\in \\{1,2\\}$) 和标量 $\\Delta_i \\equiv q_i^2 - m_i^2$ (以及 $\\Delta_3 \\equiv -m_3^2$)。该矢量积分分解为\n$$\nI_3^\\mu = \\sum_{i=1}^2 C_i \\, q_i^\\mu\\,.\n$$\n与 $q_j^\\mu$ 进行缩并，并使用基本恒等式 $2\\,\\ell \\cdot (q_j - q_3) = (D_j - D_3) - (\\Delta_j - \\Delta_3)$，推导并实现以下线性系统\n$$\n\\sum_{i=1}^2 G_{ji}\\, C_i = \\frac{1}{2}\\Big( B_0^{\\text{fin}}(\\text{excluding } j) - B_0^{\\text{fin}}(\\text{excluding } 3) - (\\Delta_j - \\Delta_3)\\, C_0 \\Big)\\,,\n\\quad j=1,2,\n$$\n其中 $B_0^{\\text{fin}}(\\text{excluding } j)$ 表示从 $\\{D_1,D_2,D_3\\}$ 中省略 $D_j$ 后，由剩下的两个分母构成的两点标量。求解该系统以获得 Passarino–Veltman 系数 $C_i$。\n\n通过 $I_3^\\mu$ 的 Feynman 参数表示（从相同的基本基底获得），独立计算缩并项 $q_j \\cdot I_3^\\mu$ 来验证此约化。在合并分母并平移 $\\ell \\to \\ell' = \\ell + Q$ 后，奇数次积分消失，并且\n$$\nI_3^\\mu = \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta} \\, Q^\\mu \\,,\n\\quad Q^\\mu = x_1 q_1^\\mu + x_2 q_2^\\mu,\n$$\n因此\n$$\nq_1 \\cdot I_3 = \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta} \\, (x_1\\, q_1^2 + x_2\\, q_1\\cdot q_2),\n\\quad\nq_2 \\cdot I_3 = \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta} \\, (x_1\\, q_1\\cdot q_2 + x_2\\, q_2^2).\n$$\n将这些数值积分结果与 $j=1,2$ 时的 $\\sum_i G_{ji} C_i$ 进行比较。\n\n在所有测试中均使用严格离壳运动学，以确保积分是有限的，并且在一般情况下格拉姆矩阵是可逆的。在自然单位制下工作，固定 $\\mu^2 = 1$；所有输出均报告为无单位的无量纲浮点值。\n\n您必须在单位区间上实现确定性的 Gauss-Legendre 求积法，并通过光滑、保体积的变换将其映射到单纯形上。避免使用任何随机方法。使用足够高的求积阶数，以在指定情况下达到优于 $10^{-6}$ 的绝对精度。\n\n测试套件。您的程序必须运行以下三个测试，并按下面指定的方式将结果汇总到单个输出列表中。\n\n- 测试 1（通用三角图，理想路径）：三点矢量积分，其中 $q_3^\\mu = 0$，不变量为 $q_1^2 = -1.1$，$q_2^2 = -0.9$，$q_1\\cdot q_2 = -0.25$，内部质量为 $m_1^2 = 2.0$，$m_2^2 = 2.7$，$m_3^2 = 3.3$。使用上述算法计算 $C_0$ 和两个 Passarino–Veltman 系数 $C_1$ 和 $C_2$。通过 Feynman 参数公式计算 $q_1 \\cdot I_3$ 和 $q_2 \\cdot I_3$，并检查其与重构的 $\\sum_i G_{ji} C_i$ 是否在 $10^{-6}$ 的绝对容差内一致，以此进行验证。记录两个布尔值以表示这两项验证结果。\n\n- 测试 2（有限标量箱形图）：四点标量积分 $D_0$，其中 $q_4^\\mu = 0$，不变量为 $q_1^2 = -0.4$，$q_2^2 = -0.6$，$q_3^2 = -0.5$，两两点积为 $q_1\\cdot q_2 = -0.1$，$q_1\\cdot q_3 = -0.05$，$q_2\\cdot q_3 = -0.07$，内部质量为 $m_1^2 = 3.0$，$m_2^2 = 3.5$，$m_3^2 = 4.1$，$m_4^2 = 2.7$。使用三参数积分计算并记录 $D_0$ 的数值。\n\n- 测试 3（近奇异格拉姆矩阵压力测试）：三点矢量积分，其中 $q_3^\\mu = 0$，不变量为 $q_1^2 = -1.0$，$q_2^2 = -1.0$，$q_1\\cdot q_2 = -0.999$，内部质量为 $m_1^2 = 3.0$，$m_2^2 = 3.0$，$m_3^2 = 3.0$。执行与测试 1 相同的验证，但由于病态条件，接受 $5\\times 10^{-4}$ 的绝对容差。记录一个布尔值，指示对 $q_1 \\cdot I_3$ 的验证是否通过；对于此压力测试，仅检查 $q_1$ 投影即可。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。该列表必须按顺序包含：\n- 来自测试 1 的两个布尔值，\n- 来自测试 1 的 $C_0$ 的浮点数值，\n- 来自测试 2 的 $D_0$ 的浮点数值，\n- 来自测试 3 的布尔值。\n\n例如：\"[true,true,0.12345,0.00678,false]\"。所有布尔值必须为小写，浮点数必须为标准十进制表示法。不得打印任何其他文本。", "solution": "### 问题验证\n\n根据指定标准对问题陈述进行严格评估。\n\n#### 第 1 步：提取已知条件\n\n- **张量积分的通用公式**:\n$$\nI_N^{\\mu_1\\cdots\\mu_r}(d) \\equiv \\mu^{4-d} \\int \\frac{d^d\\ell}{i\\pi^{d/2}} \\frac{\\ell^{\\mu_1}\\cdots \\ell^{\\mu_r}}{D_1 \\cdots D_N}\n$$\n- **传播子分母**: $D_i = (\\ell + q_i)^2 - m_i^2 + i0$。\n- **Feynman 参数化定义**: 对于 $\\sum_i x_i = 1, x_i \\ge 0$:\n  - $Q^\\mu \\equiv \\sum_{i=1}^N x_i q_i^\\mu$\n  - $\\Delta \\equiv \\sum_{i=1}^N x_i\\,(q_i^2 - m_i^2) - Q^2$\n- **标量积分公式 ($d=4, \\mu^2 = 1$)**:\n  - $B_0(p^2;m_1^2,m_2^2) = \\Delta_{\\text{div}} + B_0^{\\text{fin}}(p^2;m_1^2,m_2^2)$\n  - $B_0^{\\text{fin}}(p^2;m_1^2,m_2^2) = - \\int_0^1 dx\\, \\ln\\!\\left(x\\,m_1^2 + (1-x)\\,m_2^2 - x(1-x)\\,p^2\\right)$ (其中 $\\mu^2=1$)\n  - $C_0(q_1,q_2,q_3;m_1^2,m_2^2,m_3^2) = - \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta}$\n  - $D_0(q_1,\\dots,q_4;m_1^2,\\dots,m_4^2) = \\int_{x_1,x_2,x_3 \\ge 0,\\, x_1+x_2+x_3 \\le 1} \\frac{dx_1\\,dx_2\\,dx_3}{\\Delta^2}$\n- **秩为 1 的三角图约化 ($N=3, q_3^\\mu=0$)**:\n  - 分解: $I_3^\\mu = \\sum_{i=1}^2 C_i \\, q_i^\\mu$\n  - 格拉姆矩阵: $G_{ij} \\equiv q_i \\cdot q_j$ 其中 $i,j \\in \\{1,2\\}$\n  - 标量: $\\Delta_i \\equiv q_i^2 - m_i^2$ 其中 $i=1,2$; $\\Delta_3 \\equiv -m_3^2$\n  - 线性系统: $\\sum_{i=1}^2 G_{ji}\\, C_i = \\frac{1}{2}\\Big( B_0^{\\text{fin}}(\\text{excl } j) - B_0^{\\text{fin}}(\\text{excl } 3) - (\\Delta_j - \\Delta_3)\\, C_0 \\Big)$ 其中 $j=1,2$。\n- **三角图积分的验证公式**:\n  - $q_1 \\cdot I_3 = \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta} \\, (x_1\\, q_1^2 + x_2\\, q_1\\cdot q_2)$\n  - $q_2 \\cdot I_3 = \\int_{x_1,x_2 \\ge 0,\\, x_1+x_2 \\le 1} \\frac{dx_1\\,dx_2}{\\Delta} \\, (x_1\\, q_1\\cdot q_2 + x_2\\, q_2^2)$\n- **测试套件参数**:\n  - **测试 1**: $q_1^2 = -1.1$, $q_2^2 = -0.9$, $q_1\\cdot q_2 = -0.25$, $m_1^2 = 2.0$, $m_2^2 = 2.7$, $m_3^2 = 3.3$, $q_3=0$。容差: $10^{-6}$。\n  - **测试 2**: $q_1^2 = -0.4$, $q_2^2 = -0.6$, $q_3^2 = -0.5$, $q_1\\cdot q_2 = -0.1$, $q_1\\cdot q_3 = -0.05$, $q_2\\cdot q_3 = -0.07$, $m_1^2 = 3.0$, $m_2^2 = 3.5$, $m_3^2 = 4.1$, $m_4^2 = 2.7$, $q_4=0$。\n  - **测试 3**: $q_1^2 = -1.0$, $q_2^2 = -1.0$, $q_1\\cdot q_2 = -0.999$, $m_1^2 = 3.0$, $m_2^2 = 3.0$, $m_3^2 = 3.0$, $q_3=0$。容差: $5\\times 10^{-4}$。\n- **方法论约束**: 确定性 Gauss-Legendre 求积，映射到单纯形。使用 Python 及 `numpy` 和 `scipy`。\n- **输出格式**: 单行列表 `[bool,bool,float,float,bool]`。\n\n#### 第 2 步：使用提取的已知条件进行验证\n\n对问题的有效性进行评估：\n\n1.  **科学上成立**：该问题牢固地植根于基础量子场论，特别是单圈积分的计算。Passarino-Veltman 约化、Feynman 参数化和维数正规化都是标准的、成熟的技术。所提供的公式是这些概念的正确表示。\n2.  **良构的**：该问题是良构的。它要求实现并数值验证具体、明确定义的数学公式。使用“严格离壳运动学”确保了被积函数非奇异，从而使积分结果有限且唯一定义。用于 Passarino-Veltman 系数的线性系统是良定义的，且对于指定的非共线运动学，格拉姆矩阵是可逆的。\n3.  **客观的**：语言精确且技术性强。所有量都有数学定义，任务是计算性的、可验证的，没有主观性。\n4.  **完整且一致的**：问题提供了完成任务所需的所有数据（运动学不变量、质量、常数）和公式。设置中没有明显的矛盾。验证过程本身就是对计算同一物理量的两种不同但等效方法之间的一致性检查，这是一种标准做法。\n5.  **相关的**：该问题直接切合*计算高能物理*的主题，专注于*Feynman 规则、传播子和图计算*。\n\n#### 第 3 步：结论与行动\n\n问题陈述是**有效的**。这是一个理论物理学中合理、良定义且非平凡的计算问题。将继续进行求解过程。\n\n### 解法\n\n该解法涉及开发一个 Python 程序，用以使用 Feynman 参数化数值计算单圈标量积分，并应用这些结果来执行和验证 Passarino-Veltman 约化。实现的核心是一组用于在单纯形上进行积分的鲁棒数值求积函数。\n\n#### 单纯形上的数值求积\n\n$B_0$、$C_0$ 和 $D_0$ 的积分分别定义在线段、三角形和四面体上。为此，我们实现了确定性的 Gauss-Legendre 求积法。标准的 Gauss-Legendre 法则定义在区间 $[-1, 1]$ 上。我们首先将其映射到单位区间 $[0, 1]$。对于更高维的单纯形，我们采用 Duffy 变换将 n 维单位超立方体映射到 n 维单位单纯形。这将积分转换为一组在 $[0, 1]$ 上的嵌套一维积分，每个都可以通过一维求积法则处理。\n\n- **一维积分 ($B_0$)**: 在将节点和权重从 $[-1, 1]$ 移位后，使用标准的 $n$ 点 Gauss-Legendre 法则计算 $[0, 1]$ 上的积分。\n- **二维积分 ($C_0$)**: 积分域是单位三角形 $\\{ (x_1, x_2) | x_1, x_2 \\ge 0, x_1+x_2 \\le 1 \\}$。我们使用变换 $x_1 = u$，$x_2 = (1-u)v$，其中 $(u,v) \\in [0,1]^2$。积分变为：\n$$\n\\int_0^1 \\int_0^1 f(u, (1-u)v) \\, (1-u) \\, du \\, dv\n$$\n术语 $(1-u)$ 是变换的雅可比行列式。这个在单位正方形上的积分是在一个二维 Gauss-Legendre 点网格上执行的。\n\n- **三维积分 ($D_0$)**: 积分域是单位四面体 $\\{ (x_1, x_2, x_3) | x_i \\ge 0, \\sum x_i \\le 1 \\}$。我们使用变换 $x_1 = u$，$x_2 = (1-u)v$，$x_3 = (1-u)(1-v)w$，其中 $(u,v,w) \\in [0,1]^3$。积分变为：\n$$\n\\int_0^1 \\int_0^1 \\int_0^1 f(u, (1-u)v, (1-u)(1-v)w) \\, (1-u)^2(1-v) \\, du \\, dv \\, dw\n$$\n雅可比行列式是 $(1-u)^2(1-v)$。这是在一个三维 Gauss-Legendre 点网格上计算的。\n\n选择一个高的求積阶数（例如，每维 128 个点），以确保数值误差远低于 $10^{-6}$ 的目标精度。\n\n#### 标量积分的实现\n\n基于该求积框架，我们通过提供问题陈述中定义的各自的被积函数，实现了 $B_0^{\\text{fin}}$、$C_0$ 和 $D_0$ 的函数。为提高效率，计算使用 `numpy` 进行了向量化。例如，$C_0$ 的函数接收运动学不变量和质量，构造 $-1/\\Delta$ 的被积函数，并将其传递给二维求积例程。\n\n#### Passarino-Veltman 约化与验证\n\n对于测试 1 和 3，我们实现了秩为 1 的三角图约化。\n\n1.  **计算标量基**：所需的标量积分 $C_0$ 和三个 $B_0^{\\text{fin}}$ 函数通过数值方法计算。$B_0$ 函数的参数通过识别排除一个传播子后剩余的传播子来确定。\n    - $B_0(\\text{excl } 1) = B_0(q_2^2; m_2^2, m_3^2)$\n    - $B_0(\\text{excl } 2) = B_0(q_1^2; m_1^2, m_3^2)$\n    - $B_0(\\text{excl } 3) = B_0((q_1-q_2)^2; m_1^2, m_2^2)$\n\n2.  **求解线性系统**：构造格拉姆矩阵 $G_{ij} = q_i \\cdot q_j$ 和右侧向量 $R_j$。使用 `numpy.linalg.solve` 求解 $2 \\times 2$ 线性系统 $G \\cdot C = R$，得到 Passarino-Veltman 系数 $C_1$ 和 $C_2$。\n\n3.  **验证**：验证的核心是比较计算物理量 $q_j \\cdot I_3$ 的两种不同方法。\n    - **方法 A (重构)**：根据约化，$q_j \\cdot I_3 = \\sum_i G_{ji} C_i$。由于 $R = G \\cdot C$，这只是向量 $R = (R_1, R_2)$，其分量是标量积分的代数组合。\n    - **方法 B (直接积分)**：物理量 $q_j \\cdot I_3$ 也通过它们自己的 Feynman 参数表示直接计算，这涉及到新的二维积分。\n    验证包括检查 $|(\\text{方法 B})_j - (\\text{方法 A})_j|  \\text{容差}$ 对于 $j=1,2$ 是否成立。这证实了底层场论恒等式的一致性。\n\n整个过程被封装在一个 `solve` 函数中，该函数运行三个指定的测试用例，收集结果，并以要求的格式打印它们。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\n# Global cache for Legendre roots and weights to avoid recomputation\n_legendre_cache = {}\n\ndef get_legendre_params(order):\n    \"\"\"\n    Computes or retrieves from cache the Gauss-Legendre nodes and weights\n    for integration over the interval [0, 1].\n    \"\"\"\n    if order not in _legendre_cache:\n        nodes, weights = roots_legendre(order)\n        # Shift nodes from [-1, 1] to [0, 1]\n        nodes = 0.5 * (nodes + 1)\n        weights = 0.5 * weights\n        _legendre_cache[order] = (nodes, weights)\n    return _legendre_cache[order]\n\ndef quad_1d(func, order):\n    \"\"\"Performs 1D Gauss-Legendre quadrature over [0, 1].\"\"\"\n    nodes, weights = get_legendre_params(order)\n    # The function `func` is expected to be vectorized.\n    integral = np.sum(weights * func(nodes))\n    return integral\n\ndef quad_2d(func, order):\n    \"\"\"Performs 2D Gauss-Legendre quadrature over the unit triangle.\"\"\"\n    u_nodes, u_weights = get_legendre_params(order)\n    v_nodes, v_weights = get_legendre_params(order)\n    \n    # Create a grid of points in the unit square [0,1]x[0,1]\n    U, V = np.meshgrid(u_nodes, v_nodes, indexing='ij')\n    \n    # Apply Duffy transformation to map to the unit triangle\n    X1 = U\n    X2 = (1 - U) * V\n    \n    integrand_values = func(X1, X2)\n    \n    # Jacobian of the transformation\n    jacobian = 1 - U\n    \n    # Weight matrix for the 2D grid\n    W_matrix = np.outer(u_weights, v_weights)\n    \n    integral = np.sum(W_matrix * jacobian * integrand_values)\n    return integral\n\ndef quad_3d(func, order):\n    \"\"\"Performs 3D Gauss-Legendre quadrature over the unit tetrahedron.\"\"\"\n    nodes, weights = get_legendre_params(order)\n    \n    # Create a 3D grid of points in the unit cube [0,1]^3\n    U, V, W_grid = np.meshgrid(nodes, nodes, nodes, indexing='ij')\n\n    # Apply Duffy transformation to map to the unit tetrahedron\n    X1 = U\n    X2 = (1 - U) * V\n    X3 = (1 - U) * (1 - V) * W_grid\n    \n    integrand_values = func(X1, X2, X3)\n    \n    # Jacobian of the transformation\n    jacobian = (1 - U)**2 * (1 - V)\n    \n    # Weight tensor for the 3D grid\n    W_tensor = np.einsum('i,j,k-ijk', weights, weights, weights)\n    \n    integral = np.sum(W_tensor * jacobian * integrand_values)\n    return integral\n\ndef B0_fin(p2, m1_2, m2_2, mu_2, order):\n    \"\"\"Computes the finite part of the scalar 2-point function B0.\"\"\"\n    def integrand(x):\n        # Argument of the logarithm in the B0 formula\n        arg = x * m1_2 + (1 - x) * m2_2 - x * (1 - x) * p2\n        # The kinematic space is chosen such that arg  0\n        return -np.log(arg / mu_2)\n    return quad_1d(integrand, order)\n\ndef C0(q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, mu_2, order):\n    \"\"\"Computes the scalar 3-point function C0.\"\"\"\n    def integrand(x1, x2):\n        x3 = 1 - x1 - x2\n        Q_2 = x1**2 * q1_2 + x2**2 * q2_2 + 2 * x1 * x2 * q1q2\n        delta = (x1 * (q1_2 - m1_2) + \n                 x2 * (q2_2 - m2_2) + \n                 x3 * (-m3_2) - Q_2)\n        return -1.0 / delta\n    return quad_2d(integrand, order)\n\ndef D0(q1_2, q2_2, q3_2, q1q2, q1q3, q2q3, m1_2, m2_2, m3_2, m4_2, mu_2, order):\n    \"\"\"Computes the scalar 4-point function D0.\"\"\"\n    def integrand(x1, x2, x3):\n        x4 = 1 - x1 - x2 - x3\n        Q_2 = (x1**2 * q1_2 + x2**2 * q2_2 + x3**2 * q3_2 +\n               2 * x1 * x2 * q1q2 + 2 * x1 * x3 * q1q3 + 2 * x2 * x3 * q2q3)\n        delta = (x1 * (q1_2 - m1_2) + x2 * (q2_2 - m2_2) + \n                 x3 * (q3_2 - m3_2) + x4 * (-m4_2) - Q_2)\n        return 1.0 / delta**2\n    return quad_3d(integrand, order)\n\ndef validate_I3_projection(proj_idx, q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, order):\n    \"\"\"Computes q_j . I3 directly from its Feynman parameter representation.\"\"\"\n    def integrand(x1, x2):\n        x3 = 1 - x1 - x2\n        Q_2 = x1**2 * q1_2 + x2**2 * q2_2 + 2 * x1 * x2 * q1q2\n        delta = (x1 * (q1_2 - m1_2) + \n                 x2 * (q2_2 - m2_2) + \n                 x3 * (-m3_2) - Q_2)\n        \n        if proj_idx == 1:\n            # Numerator for q1 . I3 is q1 . (x1*q1 + x2*q2)\n            num = x1 * q1_2 + x2 * q1q2\n        else: # proj_idx == 2\n            # Numerator for q2 . I3 is q2 . (x1*q1 + x2*q2)\n            num = x1 * q1q2 + x2 * q2_2\n        return num / delta\n    return quad_2d(integrand, order)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and generate the final output.\n    \"\"\"\n    QUAD_ORDER = 128\n    MU_2 = 1.0\n    results = []\n\n    # --- Test 1: Generic triangle ---\n    q1_2, q2_2, q1q2 = -1.1, -0.9, -0.25\n    m1_2, m2_2, m3_2 = 2.0, 2.7, 3.3\n    \n    # Calculate scalar C0 integral\n    c0_val = C0(q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, MU_2, QUAD_ORDER)\n    \n    # Calculate scalar B0 integrals needed for the PV reduction\n    p_12_2 = q1_2 + q2_2 - 2 * q1q2 # (q1-q2)^2\n    b0_excl1 = B0_fin(q2_2, m2_2, m3_2, MU_2, QUAD_ORDER)\n    b0_excl2 = B0_fin(q1_2, m1_2, m3_2, MU_2, QUAD_ORDER)\n    b0_excl3 = B0_fin(p_12_2, m1_2, m2_2, MU_2, QUAD_ORDER)\n    \n    # Construct the RHS of the linear system\n    delta1 = q1_2 - m1_2\n    delta2 = q2_2 - m2_2\n    delta3 = -m3_2\n    R1 = 0.5 * (b0_excl1 - b0_excl3 - (delta1 - delta3) * c0_val)\n    R2 = 0.5 * (b0_excl2 - b0_excl3 - (delta2 - delta3) * c0_val)\n    \n    # Perform validation by direct integration\n    val_I3_proj1 = validate_I3_projection(1, q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, QUAD_ORDER)\n    val_I3_proj2 = validate_I3_projection(2, q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, QUAD_ORDER)\n    \n    # Check agreement\n    valid1 = np.isclose(val_I3_proj1, R1, atol=1e-6, rtol=0)\n    valid2 = np.isclose(val_I3_proj2, R2, atol=1e-6, rtol=0)\n    \n    results.append(str(valid1).lower())\n    results.append(str(valid2).lower())\n    results.append(f\"{c0_val:.10f}\") # Problem asks for float, format for readability\n\n    # --- Test 2: Scalar box integral D0 ---\n    q1_2, q2_2, q3_2 = -0.4, -0.6, -0.5\n    q1q2, q1q3, q2q3 = -0.1, -0.05, -0.07\n    m1_2, m2_2, m3_2, m4_2 = 3.0, 3.5, 4.1, 2.7\n    \n    d0_val = D0(q1_2, q2_2, q3_2, q1q2, q1q3, q2q3, m1_2, m2_2, m3_2, m4_2, MU_2, QUAD_ORDER)\n    results.append(f\"{d0_val:.10f}\")\n\n    # --- Test 3: Near-singular Gram matrix ---\n    q1_2, q2_2, q1q2 = -1.0, -1.0, -0.999\n    m1_2, m2_2, m3_2 = 3.0, 3.0, 3.0\n    \n    c0_val_t3 = C0(q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, MU_2, QUAD_ORDER)\n    \n    p_12_2_t3 = q1_2 + q2_2 - 2 * q1q2\n    b0_excl1_t3 = B0_fin(q2_2, m2_2, m3_2, MU_2, QUAD_ORDER)\n    b0_excl3_t3 = B0_fin(p_12_2_t3, m1_2, m2_2, MU_2, QUAD_ORDER)\n    \n    delta1_t3 = q1_2 - m1_2\n    delta3_t3 = -m3_2\n    R1_t3 = 0.5 * (b0_excl1_t3 - b0_excl3_t3 - (delta1_t3 - delta3_t3) * c0_val_t3)\n    \n    val_I3_proj1_t3 = validate_I3_projection(1, q1_2, q2_2, q1q2, m1_2, m2_2, m3_2, QUAD_ORDER)\n    \n    valid3 = np.isclose(val_I3_proj1_t3, R1_t3, atol=5e-4, rtol=0)\n    results.append(str(valid3).lower())\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3515188"}, {"introduction": "超越了计算散射振幅本身，物理学的许多前沿应用都要求我们能高效地计算振幅对物理参数（如质量 $m$ 和能量 $s$）的导数。本练习将带您进入现代计算科学的前沿，应用自动微分（AD）技术来精确求解圈积分的梯度。您将通过实践发现AD相比传统有限差分法的优势，并直面一个关键的物理与数值挑战：如何在振幅产生非解析行为的物理阈值（例如 $s=4m^2$）附近确保计算的稳定性和准确性。[@problem_id:3515172]", "problem": "您的任务是使用自动微分来实现量子场论（QFT）中单圈标量气泡振幅的数值评估和微分，并评估在存在支割线和非解析性的情况下所计算梯度的稳定性。您将使用 Feynman 参数来构建振幅，对粒子质量和 Mandelstam 不变量进行微分，并将自动微分与阈值奇点附近的有限差分进行比较。\n\n起点和物理背景：在标量理论中，等质量单圈二点函数（气泡图）源于两个标量传播子的乘积。使用 Feynman 参数化，并舍弃与具体方案相关的附加常数，一个代表性的振幅可以写成关于 Feynman 参数的积分形式\n$$\n\\mathcal{M}(s,m;\\mu,\\varepsilon) \\equiv \\int_{0}^{1} \\mathrm{d}x \\,\\ln\\!\\left(\\frac{m^{2} - s\\,x(1-x) - i\\,\\varepsilon}{\\mu^{2}}\\right),\n$$\n其中 $m$ 是标量质量，$s$ 是 Mandelstam 不变量，$\\mu$ 是一个参考重整化标度，$\\varepsilon$ 是一个强制执行因果性规定的正无穷小量。复对数取其主支，支割线沿负实轴。该积分在 $s=4m^{2}$ 处有一个支点，这意味着在 $s$ 上存在一个非解析性阈值；当 $s\\to 4m^{2}$ 时，对于 $x=1/2$，被积函数可能趋近于零，这使得导数变得敏感且可能不稳定。\n\n您的任务：\n\n1. 使用对偶数实现前向模式自动微分，以便通过在基本运算层面应用链式法则，在数值积分的被积函数内部执行微分。您必须同时获得梯度 $\\partial \\mathcal{M}/\\partial m$ 和 $\\partial \\mathcal{M}/\\partial s$。\n\n2. 使用具有固定节点数 $N$ 的 Gauss–Legendre 求积法在区间 $[0,1]$ 上对积分进行数值评估。将节点从 $[-1,1]$ 映射到 $[0,1]$，并使用相应的权重。您必须使用复对数 $\\ln$ 的主支，并包含 $-i\\,\\varepsilon$ 规定。\n\n3. 使用对称差分和小的微扰量 $\\delta m$ 和 $\\delta s$，计算梯度 $\\partial \\mathcal{M}/\\partial m$ 和 $\\partial \\mathcal{M}/\\partial s$ 的有限差分近似。通过计算相对误差，将自动微分结果与有限差分结果进行比较\n$$\nE_m \\equiv \\frac{\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{AD}} - \\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{FD}}\\right|}{\\max\\left(10^{-12},\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{FD}}\\right|\\right)},\n\\quad\nE_s \\equiv \\frac{\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{AD}} - \\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{FD}}\\right|}{\\max\\left(10^{-12},\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{FD}}\\right|\\right)}.\n$$\n定义一个稳定性阈值 $\\tau$，如果一个案例满足 $\\max(E_m,E_s) \\le \\tau$，则将其分类为数值稳定。\n\n4. 单位和数值参数：使用 $m$（单位 $\\mathrm{GeV}$），$s$（单位 $\\mathrm{GeV}^{2}$），以及 $\\mu=1\\,\\mathrm{GeV}$，以使对数的参数为无量纲。在所有测试案例中，使用 $\\varepsilon=10^{-12}\\,\\mathrm{GeV}^{2}$。使用 $N=200$ 个求积节点。使用对称差分步长 $\\delta m=\\max(10^{-6},\\,10^{-6}\\,m)$（单位 $\\mathrm{GeV}$）和 $\\delta s=\\max(10^{-6},\\,10^{-6}\\,s)$（单位 $\\mathrm{GeV}^{2}$）。使用 $\\tau=10^{-3}$。\n\n5. 测试套件：对以下参数集 $(m,s)$ 进行稳定性分类评估，保持 $\\mu=1$ 和 $\\varepsilon=10^{-12}$ 固定：\n   - 案例1（阈值以下，理想情况）：$(m=0.5,\\,s=0.2)$。\n   - 案例2（从下方接近阈值）：$(m=0.5,\\,s=0.999)$。\n   - 案例3（在阈值处）：$(m=0.5,\\,s=1.0)$。\n   - 案例4（刚好在阈值之上）：$(m=0.5,\\,s=1.001)$。\n   - 案例5（远高于阈值）：$(m=0.5,\\,s=10.0)$。\n   - 案例6（小质量在阈值处）：$(m=0.1,\\,s=0.04)$。\n   - 案例7（小质量刚好在阈值之上）：$(m=0.1,\\,s=0.041)$。\n\n6. 最终输出格式：您的程序应生成单行输出，其中包含所有七个测试案例的稳定性结果，格式为方括号内以逗号分隔的列表，每个条目是一个布尔值，指示该案例是否稳定，顺序如上所列（例如，$\\texttt{[True,False,True, ...]}$）。不应打印任何其他文本。\n\n此问题陈述中的所有数学实体都必须以 LaTeX 表示。答案布尔值没有单位；所有内部计算必须一致地使用指定的单位和复对数的主支。解决方案必须从第一性原理构建：Feynman 规则导出传播子，参数化为积分，并通过对偶数方法以算法方式实现在积分号下微分，而非通过闭式公式。", "solution": "用户请求实现并分析一种数值方法，用于计算量子场论（QFT）中单圈标量气泡振幅及其导数。在提供解决方案之前，需要对问题的科学合理性和完整性进行验证。\n\n### 步骤1：提取给定条件\n- **积分定义**：标量单圈振幅由 Feynman 参数积分给出：\n$$\n\\mathcal{M}(s,m;\\mu,\\varepsilon) \\equiv \\int_{0}^{1} \\mathrm{d}x \\,\\ln\\!\\left(\\frac{m^{2} - s\\,x(1-x) - i\\,\\varepsilon}{\\mu^{2}}\\right)\n$$\n- **变量和常数**：$m$（标量质量，GeV），$s$（Mandelstam 不变量，GeV$^2$），$\\mu$（重整化标度，GeV），$\\varepsilon$（因果性规定参数，GeV$^2$）。\n- **数学细节**：复对数 $\\ln$ 取其主支。该积分在粒子产生阈值 $s=4m^2$ 处表现出支点奇点。\n- **计算任务**：\n    1.  使用对偶数实现前向模式自动微分（AD），以同时计算 $\\partial \\mathcal{M}/\\partial m$ 和 $\\partial \\mathcal{M}/\\partial s$。\n    2.  使用具有 $N=200$ 个节点的 Gauss-Legendre 求积法对区间 $x \\in [0,1]$ 上的积分进行数值评估。\n    3.  使用对称差分方案计算相同梯度的有限差分（FD）近似。\n    4.  通过相对误差 $E_m$ 和 $E_s$ 比较 AD 和 FD 的结果：\n    $$\n    E_m \\equiv \\frac{\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{AD}} - \\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{FD}}\\right|}{\\max\\left(10^{-12},\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial m}\\right)_{\\mathrm{FD}}\\right|\\right)},\n    \\quad\n    E_s \\equiv \\frac{\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{AD}} - \\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{FD}}\\right|}{\\max\\left(10^{-12},\\left|\\left(\\frac{\\partial \\mathcal{M}}{\\partial s}\\right)_{\\mathrm{FD}}\\right|\\right)}.\n    $$\n    5.  如果一个案例满足 $\\max(E_m, E_s) \\le \\tau$，则认为其数值稳定。\n- **数值参数**：\n    - $\\mu = 1\\,\\mathrm{GeV}$\n    - $\\varepsilon = 10^{-12}\\,\\mathrm{GeV}^{2}$\n    - $N = 200$\n    - 对称差分步长：$\\delta m = \\max(10^{-6}, 10^{-6}\\,m)\\,\\mathrm{GeV}$，$\\delta s = \\max(10^{-6}, 10^{-6}\\,s)\\,\\mathrm{GeV}^{2}$\n    - 稳定性阈值：$\\tau = 10^{-3}$\n- **测试套件**：为稳定性分析提供了七个参数集 $(m, s)$。\n    1. $(m=0.5,\\,s=0.2)$\n    2. $(m=0.5,\\,s=0.999)$\n    3. $(m=0.5,\\,s=1.0)$\n    4. $(m=0.5,\\,s=1.001)$\n    5. $(m=0.5,\\,s=10.0)$\n    6. $(m=0.1,\\,s=0.04)$\n    7. $(m=0.1,\\,s=0.041)$\n- **输出**：一个单行的、以逗号分隔的布尔值列表，指示每个测试案例的稳定性。\n\n### 步骤2：使用提取的给定条件进行验证\n根据验证标准对问题陈述进行评估：\n\n1.  **科学上成立**：该问题根植于微扰 QFT 的基本概念。标量气泡图的积分是教科书中的一个经典例子。Feynman 参数的使用、传播子的 $-i\\varepsilon$ 规定以及对阈值奇点的分析都是标准且正确的物理概念。\n2.  **定义良好**：该问题在数学和计算上都有明确的定义。由于有 $-i\\varepsilon$ 项，积分是良态的，它阻止了对数参数变为零。所有参数和所需方法（AD、FD、数值求积）都已明确指定，从而可以得到唯一且可验证的解。\n3.  **客观**：语言是精确和定量的。任务以算法方式指定，成功的标准（稳定性）由具体公式给出。没有歧义或主观性。\n4.  **完整性与一致性**：所有必要的数据、常数和测试案例都已提供。整个设置是自洽的，没有矛盾。\n\n### 步骤3：结论与行动\n该问题是**有效的**。它是一个在计算物理领域中表述良好且科学合理的问题，旨在测试在存在非解析性的情况下数值微分技术的实现和稳定性。我将继续提供解决方案。\n\n### 基于原则的设计\n解决方案将基于以下原则构建：\n\n1.  **自动微分（AD）**：我们将为多变量复函数实现前向模式 AD。这通过定义一个 `DualComplex` 数类型来实现，该类型扩展了复数以携带导数信息。对于函数 $f(m, s)$，此类型的对象将储存一个复数三元组：$(f, \\partial f/\\partial m, \\partial f/\\partial s)$。我们将为此对偶数类型重载所有标准算术运算（$+、-、\\times、\\div$）和初等函数（$\\ln$），在每一步都实现链式法则。例如，对于乘法 $h = f \\cdot g$，导数计算为 $\\partial h/\\partial p = (\\partial f/\\partial p)g + f(\\partial g/\\partial p)$，其中 $p$ 为 $m$ 或 $s$。\n\n2.  **数值求积**：积分将使用 Gauss-Legendre 求积法近似为一个加权和。定义在区间 $[-1, 1]$ 上的标准节点和权重将通过线性变换 $x = (t+1)/2$ 映射到积分域 $[0, 1]$，其中 $t \\in [-1, 1]$。积分则为 $\\int_0^1 f(x) dx = \\int_{-1}^1 f((t+1)/2) (1/2) dt \\approx \\sum_i (w_i/2) f((t_i+1)/2)$，其中 $(t_i, w_i)$ 是标准的 Gauss-Legendre 节点和权重。\n\n3.  **振幅及其梯度的评估**：\n    - **AD 方法**：为了通过 AD 计算梯度，输入参数 $m$ 和 $s$ 被初始化为种子 `DualComplex` 数：$m_{\\text{dual}} = (m, 1, 0)$ 和 $s_{\\text{dual}} = (s, 0, 1)$。然后使用对偶数算术在每个求积节点 $x_i$ 处评估被积函数。被积函数得到的 `DualComplex` 值乘以相应的求积权重并求和。最终的 `DualComplex` 和将在其值部分包含积分值 $\\mathcal{M}$，在其导数部分包含梯度 $\\partial \\mathcal{M}/\\partial m$ 和 $\\partial \\mathcal{M}/\\partial s$。这有效地执行了积分号下微分。\n    - **FD 方法**：为了比较，梯度也使用对称有限差分公式计算：$\\partial f/\\partial p \\approx (f(p+\\delta p) - f(p-\\delta p))/(2\\delta p)$。这需要在 $m$ 和 $s$ 的微扰值上多次评估原始积分（使用标准复数算术）。\n\n4.  **稳定性分析**：在阈值 $s=4m^2$ 附近，被积函数的行为变化迅速。在阈值之上，对数的参数穿过负实轴上的支割线，为积分引入了一个非解析性贡献。这可能导致 AD 和 FD 之间的差异，因为 FD 对函数值在有限步长 $\\delta s$ 上的变化敏感，该步长可能跨越这个非解析区域，而 AD 则在单一点计算导数。所提供的相对误差度量 $E_m$ 和 $E_s$ 量化了这种差异，如果差异超过容差 $\\tau=10^{-3}$，则将一个案例分类为“不稳定”。此过程系统地测试了数值微分方法的鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\nclass DualComplex:\n    \"\"\"\n    A class for forward-mode automatic differentiation of complex functions\n    with respect to two real variables 'm' and 's'.\n    \"\"\"\n    def __init__(self, val, d_m=0.0, d_s=0.0):\n        self.val = complex(val)\n        self.d_m = complex(d_m)\n        self.d_s = complex(d_s)\n\n    def __add__(self, other):\n        if isinstance(other, DualComplex):\n            return DualComplex(self.val + other.val, self.d_m + other.d_m, self.d_s + other.d_s)\n        # Addition with a scalar (real or complex)\n        return DualComplex(self.val + other, self.d_m, self.d_s)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, DualComplex):\n            return DualComplex(self.val - other.val, self.d_m - other.d_m, self.d_s - other.d_s)\n        # Subtraction with a scalar\n        return DualComplex(self.val - other, self.d_m, self.d_s)\n\n    def __rsub__(self, other):\n        return DualComplex(other - self.val, -self.d_m, -self.d_s)\n\n    def __mul__(self, other):\n        if isinstance(other, DualComplex):\n            # Product rule for two dual numbers\n            return DualComplex(self.val * other.val,\n                               self.val * other.d_m + other.val * self.d_m,\n                               self.val * other.d_s + other.val * self.d_s)\n        # Multiplication by a scalar\n        return DualComplex(self.val * other, self.d_m * other, self.d_s * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, DualComplex):\n            # Quotient rule for two dual numbers\n            val_inv = 1.0 / other.val\n            val_inv_sq = val_inv**2\n            return DualComplex(self.val * val_inv,\n                               (self.d_m * other.val - self.val * other.d_m) * val_inv_sq,\n                               (self.d_s * other.val - self.val * other.d_s) * val_inv_sq)\n        # Division by a scalar\n        other_inv = 1.0 / other\n        return DualComplex(self.val * other_inv, self.d_m * other_inv, self.d_s * other_inv)\n    \n    def __rtruediv__(self, other):\n        val_inv = 1.0 / self.val\n        val_inv_sq = val_inv**2\n        return DualComplex(other * val_inv,\n                           (-other * self.d_m) * val_inv_sq,\n                           (-other * self.d_s) * val_inv_sq)\n\n\ndef log_dual(z):\n    \"\"\"Computes the natural logarithm for a DualComplex number.\"\"\"\n    if not isinstance(z, DualComplex):\n        return np.log(complex(z))\n    \n    val_inv = 1.0 / z.val\n    # Chain rule: d(log(u))/dp = (1/u) * (du/dp)\n    return DualComplex(np.log(z.val), z.d_m * val_inv, z.d_s * val_inv)\n\n\ndef solve():\n    # Define the parameters from the problem statement.\n    MU = 1.0\n    EPSILON = 1e-12\n    N_NODES = 200\n    TAU = 1e-3\n    \n    test_cases = [\n        (0.5, 0.2),    # Case 1: below threshold\n        (0.5, 0.999),  # Case 2: near threshold from below\n        (0.5, 1.0),    # Case 3: at threshold\n        (0.5, 1.001),  # Case 4: just above threshold\n        (0.5, 10.0),   # Case 5: far above threshold\n        (0.1, 0.04),   # Case 6: small mass at threshold\n        (0.1, 0.041),  # Case 7: small mass just above threshold\n    ]\n\n    # Pre-compute Gauss-Legendre nodes and weights for [-1, 1]\n    t_nodes, std_weights = roots_legendre(N_NODES)\n    # Map nodes to [0, 1] and adjust weights\n    x_nodes = (t_nodes + 1.0) / 2.0\n    weights = std_weights / 2.0\n    \n    # --- Integrand function using standard complex numbers ---\n    def integrand(x, m, s):\n        arg = (m**2 - s * x * (1 - x) - 1j * EPSILON) / MU**2\n        return np.log(arg)\n\n    # --- Numerical integration function for FD ---\n    def calculate_amplitude_base(m, s):\n        integral_val = 0.0j\n        for i in range(N_NODES):\n            integral_val += weights[i] * integrand(x_nodes[i], m, s)\n        return integral_val\n\n    results = []\n    for m, s in test_cases:\n        # --- Automatic Differentiation Calculation ---\n        m_dual = DualComplex(m, 1.0, 0.0)\n        s_dual = DualComplex(s, 0.0, 1.0)\n        \n        total_dual = DualComplex(0.0)\n        for i in range(N_NODES):\n            x = x_nodes[i]\n            integrand_arg_dual = (m_dual*m_dual - s_dual * x * (1 - x) - 1j * EPSILON) / MU**2\n            integrand_val_dual = log_dual(integrand_arg_dual)\n            total_dual += integrand_val_dual * weights[i]\n\n        grad_m_ad = total_dual.d_m\n        grad_s_ad = total_dual.d_s\n\n        # --- Finite Difference Calculation ---\n        delta_m = max(1e-6, 1e-6 * m)\n        delta_s = max(1e-6, 1e-6 * s)\n\n        m_plus = calculate_amplitude_base(m + delta_m, s)\n        m_minus = calculate_amplitude_base(m - delta_m, s)\n        grad_m_fd = (m_plus - m_minus) / (2 * delta_m)\n\n        s_plus = calculate_amplitude_base(m, s + delta_s)\n        s_minus = calculate_amplitude_base(m, s - delta_s)\n        grad_s_fd = (s_plus - s_minus) / (2 * delta_s)\n        \n        # --- Comparison and Stability Check ---\n        # Note: |...| on complex numbers is their magnitude (np.abs)\n        err_m_denom = max(1e-12, np.abs(grad_m_fd))\n        e_m = np.abs(grad_m_ad - grad_m_fd) / err_m_denom\n\n        err_s_denom = max(1e-12, np.abs(grad_s_fd))\n        e_s = np.abs(grad_s_ad - grad_s_fd) / err_s_denom\n        \n        is_stable = max(e_m, e_s) = TAU\n        results.append(str(is_stable).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3515172"}]}