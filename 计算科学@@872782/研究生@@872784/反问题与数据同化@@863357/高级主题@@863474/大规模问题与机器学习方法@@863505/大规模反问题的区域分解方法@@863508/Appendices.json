{"hands_on_practices": [{"introduction": "本练习将引导您体验区域分解的基本力学原理。通过为一个简单的离散问题手动构建和分析舒尔补 (Schur complement)，您将对子结构化 (substructuring) 如何将大问题简化为仅在子区域间界面上定义的问题有一个具体的理解。这是许多强大的区域分解求解器中的基础代数步骤。", "problem": "考虑一个受泊松型偏微分方程约束的吉洪诺夫正则化逆源识别问题的单次线性化高斯-牛顿步。计算域被分解为两个不重叠的子域，状态被离散为 $6$ 个自由度，并分组为两个大小各为 $3$ 的子域向量。通过两个等式约束（每个界面自由度一个）来施加界面连续性。在标准的拉格朗日乘子法中，该线性系统呈现为如下鞍点形式\n$$\n\\begin{pmatrix}\n\\mathbf{K}  \\mathbf{B}^{\\top} \\\\\n\\mathbf{B}  \\mathbf{0}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{u} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{f} \\\\\n\\mathbf{0}\n\\end{pmatrix},\n$$\n其中 $\\mathbf{u}\\in\\mathbb{R}^{6}$ 汇集了子域的状态未知量，$\\boldsymbol{\\lambda}\\in\\mathbb{R}^{2}$ 是界面拉格朗日乘子，$\\mathbf{K}\\in\\mathbb{R}^{6\\times 6}$ 是一个由两个 $3\\times 3$ 子域算子组成的块对角矩阵，$\\mathbf{B}\\in\\mathbb{R}^{2\\times 6}$ 用于施加界面连续性。\n\n假设每个子域算子是在均匀网格上带有狄利克雷边界条件的标准一维泊松刚度矩阵，即\n$$\n\\mathbf{K}_1=\\mathbf{K}_2=\\begin{pmatrix}\n2  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  2\n\\end{pmatrix},\n$$\n并且\n$$\n\\mathbf{K}=\\mathrm{diag}(\\mathbf{K}_1,\\mathbf{K}_2).\n$$\n设 $\\mathbf{u}$ 的排序为 $\\mathbf{u}=\\begin{pmatrix}u_{1,a}  u_{1,b}  u_{1,c}  u_{2,a}  u_{2,b}  u_{2,c}\\end{pmatrix}^{\\top}$，并施加两个界面连续性约束 $u_{1,b}-u_{2,a}=0$ 和 $u_{1,c}-u_{2,b}=0$，即：\n$$\n\\mathbf{B}=\\begin{pmatrix}\n0  1  0  -1  0  0 \\\\\n0  0  1  0  -1  0\n\\end{pmatrix}.\n$$\n取右端项为\n$$\n\\mathbf{f}=\\begin{pmatrix}1  0  0  0  1  0\\end{pmatrix}^{\\top}.\n$$\n\n从约束最小二乘子问题的一阶最优性（Karush–Kuhn–Tucker）条件出发，并使用块高斯消元作为唯一的代数工具，消去内部状态变量 $\\mathbf{u}$ 以构造关于界面乘子的舒尔补，然后求解简化系统以得到 $\\boldsymbol{\\lambda}$。回代以恢复 $\\mathbf{u}$。最后，将关于界面乘子的 $2\\times 2$ 舒尔补矩阵的行列式以精确有理数的形式报告。无需四舍五入。你的最终答案必须是一个不带单位的实数。", "solution": "问题陈述已通过验证，被认为是数值线性代数中的一个适定问题，源于偏微分方程的区域分解。因此，我们可以进行正式求解。\n\n待求解的系统是一个鞍点线性系统，由一个约束优化问题的 Karush–Kuhn–Tucker (KKT) 条件给出。该系统以块矩阵形式表示如下：\n$$\n\\begin{pmatrix}\n\\mathbf{K}  \\mathbf{B}^{\\top} \\\\\n\\mathbf{B}  \\mathbf{0}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{u} \\\\\n\\boldsymbol{\\lambda}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{f} \\\\\n\\mathbf{0}\n\\end{pmatrix}\n$$\n这对应于两个块方程：\n$$\n\\mathbf{K}\\mathbf{u} + \\mathbf{B}^{\\top}\\boldsymbol{\\lambda} = \\mathbf{f} \\quad (1)\n$$\n$$\n\\mathbf{B}\\mathbf{u} = \\mathbf{0} \\quad (2)\n$$\n任务是通过首先为拉格朗日乘子 $\\boldsymbol{\\lambda}$ 构造舒尔补系统来求解此系统。这可以通过块高斯消元来实现。\n\n首先，我们必须确定矩阵 $\\mathbf{K}$ 是可逆的。矩阵 $\\mathbf{K}$ 由 $\\mathbf{K}=\\mathrm{diag}(\\mathbf{K}_1,\\mathbf{K}_2)$ 给出，其中：\n$$\n\\mathbf{K}_1=\\mathbf{K}_2=\\begin{pmatrix} 2  -1  0 \\\\ -1  2  -1 \\\\ 0  -1  2 \\end{pmatrix}\n$$\n这是一个对称三对角矩阵。其行列式为 $\\det(\\mathbf{K}_1) = 2(2 \\cdot 2 - (-1)(-1)) - (-1)(-1 \\cdot 2 - 0) = 2(3) - 2 = 4$。由于行列式非零，$\\mathbf{K}_1$ 是可逆的。因为 $\\mathbf{K}_2 = \\mathbf{K}_1$，所以它也是可逆的。因此，$\\mathbf{K}$ 作为一个由可逆块组成的块对角矩阵，其本身也是可逆的。\n\n从方程（1），我们可以将 $\\mathbf{u}$ 形式上表示为：\n$$\n\\mathbf{u} = \\mathbf{K}^{-1}(\\mathbf{f} - \\mathbf{B}^{\\top}\\boldsymbol{\\lambda})\n$$\n将这个 $\\mathbf{u}$ 的表达式代入方程（2）可以消去状态变量 $\\mathbf{u}$：\n$$\n\\mathbf{B} \\left( \\mathbf{K}^{-1}(\\mathbf{f} - \\mathbf{B}^{\\top}\\boldsymbol{\\lambda}) \\right) = \\mathbf{0}\n$$\n根据线性性质，我们可以分配 $\\mathbf{B}$：\n$$\n\\mathbf{B}\\mathbf{K}^{-1}\\mathbf{f} - \\mathbf{B}\\mathbf{K}^{-1}\\mathbf{B}^{\\top}\\boldsymbol{\\lambda} = \\mathbf{0}\n$$\n重排此方程得到关于 $\\boldsymbol{\\lambda}$ 的舒尔补系统：\n$$\n(\\mathbf{B}\\mathbf{K}^{-1}\\mathbf{B}^{\\top})\\boldsymbol{\\lambda} = \\mathbf{B}\\mathbf{K}^{-1}\\mathbf{f}\n$$\n我们记为 $\\mathbf{S}$ 的舒尔补矩阵是左侧的 $2 \\times 2$ 矩阵：\n$$\n\\mathbf{S} = \\mathbf{B}\\mathbf{K}^{-1}\\mathbf{B}^{\\top}\n$$\n问题要求计算 $\\mathbf{S}$ 的行列式。为计算 $\\mathbf{S}$，我们首先需要 $\\mathbf{K}$ 的逆。由于 $\\mathbf{K} = \\mathrm{diag}(\\mathbf{K}_1, \\mathbf{K}_2)$，其逆为 $\\mathbf{K}^{-1} = \\mathrm{diag}(\\mathbf{K}_1^{-1}, \\mathbf{K}_2^{-1})$。我们使用伴随矩阵法计算 $\\mathbf{K}_1^{-1}$：\n$$\n\\mathbf{K}_1^{-1} = \\frac{1}{\\det(\\mathbf{K}_1)}\\mathrm{adj}(\\mathbf{K}_1)^{\\top} = \\frac{1}{4} \\begin{pmatrix} 3  2  1 \\\\ 2  4  2 \\\\ 1  2  3 \\end{pmatrix}\n$$\n因为 $\\mathbf{K}_1 = \\mathbf{K}_2$，所以 $\\mathbf{K}_2^{-1} = \\mathbf{K}_1^{-1}$。因此，\n$$\n\\mathbf{K}^{-1} = \\frac{1}{4} \\begin{pmatrix}\n3  2  1  0  0  0 \\\\\n2  4  2  0  0  0 \\\\\n1  2  3  0  0  0 \\\\\n0  0  0  3  2  1 \\\\\n0  0  0  2  4  2 \\\\\n0  0  0  1  2  3\n\\end{pmatrix}\n$$\n矩阵 $\\mathbf{B}$ 给出如下：\n$$\n\\mathbf{B}=\\begin{pmatrix}\n0  1  0  -1  0  0 \\\\\n0  0  1  0  -1  0\n\\end{pmatrix}\n$$\n现在我们计算乘积 $\\mathbf{B}\\mathbf{K}^{-1}$：\n$$\n\\mathbf{B}\\mathbf{K}^{-1} = \\begin{pmatrix}\n0  1  0  -1  0  0 \\\\\n0  0  1  0  -1  0\n\\end{pmatrix} \\frac{1}{4} \\begin{pmatrix}\n3  2  1  0  0  0 \\\\\n2  4  2  0  0  0 \\\\\n1  2  3  0  0  0 \\\\\n0  0  0  3  2  1 \\\\\n0  0  0  2  4  2 \\\\\n0  0  0  1  2  3\n\\end{pmatrix}\n$$\n结果的第一行是 $\\frac{1}{4}$ 倍的（$\\mathbf{K}^{-1}$ 的第2行 - $\\mathbf{K}^{-1}$ 的第4行），第二行是 $\\frac{1}{4}$ 倍的（$\\mathbf{K}^{-1}$ 的第3行 - $\\mathbf{K}^{-1}$ 的第5行）。这得到：\n$$\n\\mathbf{B}\\mathbf{K}^{-1} = \\frac{1}{4} \\begin{pmatrix}\n2  4  2  -3  -2  -1 \\\\\n1  2  3  -2  -4  -2\n\\end{pmatrix}\n$$\n接下来，我们将此结果乘以 $\\mathbf{B}^{\\top}$ 来构成 $\\mathbf{S}$：\n$$\n\\mathbf{B}^{\\top} = \\begin{pmatrix} 0  0 \\\\ 1  0 \\\\ 0  1 \\\\ -1  0 \\\\ 0  -1 \\\\ 0  0 \\end{pmatrix}\n$$\n$$\n\\mathbf{S} = (\\mathbf{B}\\mathbf{K}^{-1})\\mathbf{B}^{\\top} = \\frac{1}{4} \\begin{pmatrix}\n2  4  2  -3  -2  -1 \\\\\n1  2  3  -2  -4  -2\n\\end{pmatrix} \\begin{pmatrix} 0  0 \\\\ 1  0 \\\\ 0  1 \\\\ -1  0 \\\\ 0  -1 \\\\ 0  0 \\end{pmatrix}\n$$\n执行矩阵乘法：\n$$\nS_{11} = \\frac{1}{4} (2(0) + 4(1) + 2(0) - 3(-1) - 2(0) - 1(0)) = \\frac{1}{4}(4+3) = \\frac{7}{4}\n$$\n$$\nS_{12} = \\frac{1}{4} (2(0) + 4(0) + 2(1) - 3(0) - 2(-1) - 1(0)) = \\frac{1}{4}(2+2) = \\frac{4}{4} = 1\n$$\n$$\nS_{21} = \\frac{1}{4} (1(0) + 2(1) + 3(0) - 2(-1) - 4(0) - 2(0)) = \\frac{1}{4}(2+2) = \\frac{4}{4} = 1\n$$\n$$\nS_{22} = \\frac{1}{4} (1(0) + 2(0) + 3(1) - 2(0) - 4(-1) - 2(0)) = \\frac{1}{4}(3+4) = \\frac{7}{4}\n$$\n因此，舒尔补矩阵为：\n$$\n\\mathbf{S} = \\begin{pmatrix} \\frac{7}{4}  1 \\\\ 1  \\frac{7}{4} \\end{pmatrix}\n$$\n问题要求计算该矩阵的行列式。\n$$\n\\det(\\mathbf{S}) = \\left(\\frac{7}{4}\\right)\\left(\\frac{7}{4}\\right) - (1)(1) = \\frac{49}{16} - 1 = \\frac{49}{16} - \\frac{16}{16} = \\frac{33}{16}\n$$\n这就是所求的值。为了完整起见，可以接着使用 $\\mathbf{S}\\boldsymbol{\\lambda} = \\mathbf{B}\\mathbf{K}^{-1}\\mathbf{f}$ 求解 $\\boldsymbol{\\lambda}$，然后回代以找到 $\\mathbf{u} = \\mathbf{K}^{-1}(\\mathbf{f} - \\mathbf{B}^{\\top}\\boldsymbol{\\lambda})$。然而，题目要求最终答案仅为 $\\mathbf{S}$ 的行列式。", "answer": "$$\\boxed{\\frac{33}{16}}$$", "id": "3377575"}, {"introduction": "现实世界的问题通常涉及复杂的几何形状，导致子区域界面处的网格不匹配。本实践介绍了砂浆法 (mortar methods) [@problem_id:3377564]，这是一种在这种情况下确保精确耦合的强大技术，对于反问题中的梯度计算至关重要。您将通过实现此方法，探索中间“砂浆”空间的选择如何影响梯度计算的一致性。", "problem": "考虑一个定义在两个共享一个界面的子域上的线性椭圆反问题。令界面为由 $s \\in (0,1)$ 参数化的开区间 $\\Gamma = (0,1)$。这些子域通过施加连续性条件在界面上耦合。区域分解方法产生作用于状态变量沿 $\\Gamma$ 的迹的界面算子。为了抽象而又真实地对此设定进行建模，假设界面两侧离散的 Dirichlet-to-Neumann 映射的作用由一个形式如下的对称正定有限差分算子来近似\n$$\n\\mathsf{S}_n = \\frac{1}{h_n^2} \\operatorname{tridiag}(-1,2,-1) + \\mathsf{I}_n,\n$$\n在 $s=0$ 和 $s=1$ 处具有齐次 Dirichlet 条件，其中 $n$ 是一侧的界面网格点数，$h_n = \\frac{1}{n-1}$ 是均匀网格间距，$\\mathsf{I}_n$ 是 $n \\times n$ 的单位矩阵。这是一个与椭圆偏微分方程相关的界面 Schur 补的经过充分检验的替代模型。\n\n令 $\\theta \\in \\mathbb{R}^m$ 通过一个维度为 $m$ 的 mortar 空间来参数化界面上的 Dirichlet 控制。该空间由在 $[0,1]$ 的均匀剖分（节点为 $\\{t_k\\}_{k=0}^{m-1}$，其中 $t_k = \\frac{k}{m-1}$）上的连续分片线性（帽子）函数张成。控制量 $\\theta$ 被视为其在 mortar 节点上的节点值。\n\n对于两个尺寸为 $n_1$ 和 $n_2$ 的不匹配界面网格（$n_1 \\neq n_2$），定义线性插值（延拓）矩阵 $\\mathsf{P}_1 \\in \\mathbb{R}^{n_1 \\times m}$ 和 $\\mathsf{P}_2 \\in \\mathbb{R}^{n_2 \\times m}$，它们将 mortar 系数 $\\theta$ 映射到在每个子域对应的界面网格节点上采样的迹值。令 $\\mathsf{I}_{\\text{eval}\\leftarrow n}$ 表示从尺寸为 $n$ 的网格到尺寸为 $n_{\\text{eval}}$ 的公共评估网格（在 $[0,1]$ 上均匀分布）的线性插值矩阵。这定义了复合算子\n$$\n\\mathsf{R}_m = \\mathsf{I}_{\\text{eval}\\leftarrow n_1} \\, \\mathsf{S}_{n_1} \\, \\mathsf{P}_1 \\;+\\; \\mathsf{I}_{\\text{eval}\\leftarrow n_2} \\, \\mathsf{S}_{n_2} \\, \\mathsf{P}_2 \\;\\in\\; \\mathbb{R}^{n_{\\text{eval}} \\times m}.\n$$\n考虑二次代价泛函\n$$\nJ(\\theta) \\;=\\; \\frac{1}{2} \\, \\lVert \\mathsf{R}_m \\, \\theta \\rVert_2^2,\n$$\n它惩罚了在公共评估网格上计算的通量失配的 $L^2$ 范数的平方。这抽象地模拟了界面耦合条件中的残差，是降空间反问题中的一种标准结构。对于这个线性最小二乘问题，关于控制量的降梯度为\n$$\nJ'(\\theta) \\;=\\; \\mathsf{R}_m^\\top \\mathsf{R}_m \\, \\theta.\n$$\n\n为了在不匹配网格和有限维 mortar 空间下量化 $J'(\\theta)$ 的相容性，定义一个高保真参考模型。该模型具有一个两侧尺寸均为 $n_{\\text{ref}}$ 的匹配界面网格、相同的算子构造 $\\mathsf{S}_{n_{\\text{ref}}}$，以及一个通过从 mortar 节点到参考网格的线性插值构建的 mortar 到参考网格的延拓矩阵 $\\mathsf{P}_{\\text{ref}} \\in \\mathbb{R}^{n_{\\text{ref}} \\times m}$。相应的参考算子是\n$$\n\\mathsf{R}_{\\text{true}} \\;=\\; 2 \\, \\mathsf{I}_{\\text{eval}\\leftarrow n_{\\text{ref}}} \\, \\mathsf{S}_{n_{\\text{ref}}} \\, \\mathsf{P}_{\\text{ref}} \\;\\in\\; \\mathbb{R}^{n_{\\text{eval}} \\times m},\n$$\n且 mortar 空间中相关的参考梯度是\n$$\nJ'_{\\text{true}}(\\theta) \\;=\\; \\mathsf{R}_{\\text{true}}^\\top \\mathsf{R}_{\\text{true}} \\, \\theta.\n$$\n注意，因子 $2$ 代表在匹配网格极限情况下，来自两侧的相同贡献之和。\n\n您的任务是：\n1. 从线性最小二乘问题的 $J(\\theta)$ 定义出发，推导在不匹配网格 mortar 设定和高保真参考设定下降梯度 $J'(\\theta)$ 的表达式。解释为什么差值 $J'(\\theta) - J'_{\\text{true}}(\\theta)$ 度量了由不匹配网格和有限的 mortar 空间维度 $m$ 共同导致的梯度相容性误差。\n2. 使用均匀剖分上连续分片线性基函数的插值误差估计，解释为什么 mortar 空间维度 $m$ 控制了相容性误差，并讨论在固定的 $n_1$、$n_2$ 和 $n_{\\text{eval}}$ 条件下，当 $m$ 增加时 $\\lVert J'(\\theta) - J'_{\\text{true}}(\\theta) \\rVert_2$ 的预期渐进行为。\n3. 实现一个程序，构建上述算子，并为一个由光滑函数 $\\theta_k = \\sin(\\pi t_k)$ 在 mortar 节点上定义的固定测试控制量 $\\theta$ 评估梯度的相对相容性误差。在所有有限差分算子中，均在 $s=0$ 和 $s=1$ 处使用齐次 Dirichlet 条件。\n\n使用以下参数测试套件来探究 mortar 空间维度的影响：\n- 不匹配界面网格尺寸: $n_1 = 53$, $n_2 = 77$。\n- 评估网格尺寸: $n_{\\text{eval}} = 301$。\n- 参考网格尺寸: $n_{\\text{ref}} = 401$。\n- Mortar 空间维度: $m \\in \\{2, 5, 10, 20, 40\\}$。\n- 测试控制量: $\\theta_k = \\sin(\\pi t_k)$，对于 $k = 0, 1, \\dots, m-1$。\n\n对于测试套件中的每个 mortar 维度 $m$，计算梯度相容性误差的相对 $2$-范数\n$$\n\\varepsilon(m) \\;=\\; \\frac{\\lVert J'(\\theta) - J'_{\\text{true}}(\\theta) \\rVert_2}{\\lVert J'_{\\text{true}}(\\theta) \\rVert_2}。\n$$\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个结果对应于上面列出的 mortar 维度的 $\\varepsilon(m)$，顺序相同。所有输出必须是使用 Python 默认浮点格式的实数。此问题不涉及物理单位；所有量均为无量纲量。", "solution": "该问题被评估为有效。它在科学上基于偏微分方程和反问题的数值分析，特别使用了区域分解和 mortar 方法的概念。该问题是适定的、客观的，并包含获得唯一解所需的所有信息。\n\n### 第1部分：降梯度的推导\n\n二次代价泛函由下式给出\n$$\nJ(\\theta) = \\frac{1}{2} \\lVert \\mathsf{R}_m \\theta \\rVert_2^2\n$$\n其中 $\\theta \\in \\mathbb{R}^m$ 是控制参数向量，$\\mathsf{R}_m \\in \\mathbb{R}^{n_{\\text{eval}} \\times m}$ 是一个线性算子。\n\n$L^2$范数的平方可以用内积（点积）表示为 $\\lVert v \\rVert_2^2 = v^\\top v$。因此，该泛函可以写为：\n$$\nJ(\\theta) = \\frac{1}{2} (\\mathsf{R}_m \\theta)^\\top (\\mathsf{R}_m \\theta)\n$$\n利用乘积转置的性质 $(AB)^\\top = B^\\top A^\\top$，我们有：\n$$\nJ(\\theta) = \\frac{1}{2} \\theta^\\top \\mathsf{R}_m^\\top \\mathsf{R}_m \\theta\n$$\n这是关于 $\\theta$ 的一个二次型。为了找到问题中表示为 $J'(\\theta)$ 的梯度，我们可以对向量 $\\theta$ 的每个分量 $\\theta_k$ 求导。对于具有对称矩阵 $A$ 的二次型 $f(x) = \\frac{1}{2} x^\\top A x$，矩阵微积分中的一个标准结果是 $\\nabla f(x) = A x$。矩阵 $\\mathsf{H} = \\mathsf{R}_m^\\top \\mathsf{R}_m$ 是对称的，因为 $(\\mathsf{R}_m^\\top \\mathsf{R}_m)^\\top = \\mathsf{R}_m^\\top (\\mathsf{R}_m^\\top)^\\top = \\mathsf{R}_m^\\top \\mathsf{R}_m$。\n\n因此，$J(\\theta)$ 的梯度是：\n$$\nJ'(\\theta) = \\nabla_\\theta J(\\theta) = \\mathsf{R}_m^\\top \\mathsf{R}_m \\theta\n$$\n这证实了问题描述中给出的不匹配网格 mortar 设定的表达式。\n\n高保真参考设定的推导是相同的。我们只需将不匹配算子 $\\mathsf{R}_m$ 替换为参考算子 $\\mathsf{R}_{\\text{true}}$：\n$$\nJ_{\\text{true}}(\\theta) = \\frac{1}{2} \\lVert \\mathsf{R}_{\\text{true}} \\theta \\rVert_2^2 = \\frac{1}{2} \\theta^\\top \\mathsf{R}_{\\text{true}}^\\top \\mathsf{R}_{\\text{true}} \\theta\n$$\n相应的梯度是：\n$$\nJ'_{\\text{true}}(\\theta) = \\mathsf{R}_{\\text{true}}^\\top \\mathsf{R}_{\\text{true}} \\theta\n$$\n这证实了提供的第二个表达式。\n\n差值 $J'(\\theta) - J'_{\\text{true}}(\\theta)$ 代表了梯度的相容性误差。在反问题的优化算法中，梯度 $J'(\\theta)$ 是决定搜索方向的关键量。其计算中的任何误差都可能导致收敛变慢或收敛到非最优解。这个误差的产生是因为在实际的不匹配网格设定中使用的算子 $\\mathsf{R}_m$ 是理想算子（这里由 $\\mathsf{R}_{\\text{true}}$ 作为其代理）的一个近似。$\\mathsf{R}_m$ 的结构结合了两种不同的离散化（在尺寸为 $n_1$ 和 $n_2$ 的网格上），而 $\\mathsf{R}_{\\text{true}}$ 是基于单一、更精细的匹配离散化 ($n_{\\text{ref}}$)。此外，两个算子都依赖于从维度为 $m$ 的抽象 mortar 控制空间到物理界面网格的投影。因此，差值 $J'(\\theta) - J'_{\\text{true}}(\\theta) = (\\mathsf{R}_m^\\top \\mathsf{R}_m - \\mathsf{R}_{\\text{true}}^\\top \\mathsf{R}_{\\text{true}}) \\theta$ 度量了这两个数值近似误差来源的综合效应：不匹配网格的几何不相容性以及通过 mortar 空间对控制函数的有限维表示。\n\n### 第2部分：Mortar 空间维度的作用和渐进行为\n\nmortar 空间的维度 $m$ 在控制相容性误差方面起着关键作用。控制向量 $\\theta \\in \\mathbb{R}^m$ 并不直接表示界面函数，而是其在一组定义于间距为 $h_m = 1/(m-1)$ 的 $[0,1]$ 均匀剖分上的分片线性帽子函数基 $\\{B_k^m(s)\\}_{k=0}^{m-1}$ 中的系数。界面上的连续函数是 $u_m(s) = \\sum_{k=0}^{m-1} \\theta_k B_k^m(s)$。\n\n测试控制量被选为 $\\theta_k = \\sin(\\pi t_k)$，其中 $t_k = k/(m-1)$ 是 mortar 节点。这意味着 $u_m(s)$ 是光滑函数 $u(s) = \\sin(\\pi s)$ 的分片线性插值。这种插值的精度由 mortar 网格间距 $h_m$决定。根据标准数值分析理论，对于像 $u(s)=\\sin(\\pi s)$ 这样足够光滑的函数，插值误差是有界的。例如，最大误差由以下公式界定：\n$$\n\\lVert u(s) - u_m(s) \\rVert_{L^\\infty[0,1]} \\leq C h_m^2 \\lVert u''(s) \\rVert_{L^\\infty[0,1]} = O(1/m^2)\n$$\n其中 $C$ 是一个与 $m$ 无关的常数。\n\n不匹配算子 $\\mathsf{R}_m$ 和参考算子 $\\mathsf{R}_{\\text{true}}$ 都作用于同一个底层函数 $u_m(s)$，尽管通过不同的离散化和投影步骤。随着 $m$ 的增加，$u_m(s)$ 成为光滑函数 $u(s) = \\sin(\\pi s)$ 的一个越来越好的近似。\n\n梯度相容性误差 $\\lVert J'(\\theta) - J'_{\\text{true}}(\\theta) \\rVert_2$ 量化了一个连续泛函的梯度的两种不同离散近似之间的差异。随着 $m$ 的增加，这些离散系统的输入（向量 $\\mathsf{P}_1\\theta$、$\\mathsf{P}_2\\theta$、$\\mathsf{P}_{\\text{ref}}\\theta$）成为同一底层光滑函数 $u(s)$ 的更精确的离散表示。因此，不匹配系统和参考系统处理此函数的不同方式应该会产生彼此更接近的结果。随着它们所建模的函数被控制参数化更好地解析，两种离散模型之间的误差预计会减小。\n\n因此，对于中等偏小值的 $m$，当 mortar 空间提供系统中（即 $h_m > h_{n_1}, h_{n_2}$）最粗糙的近似时，我们预计相容性误差 $\\lVert J'(\\theta) - J'_{\\text{true}}(\\theta) \\rVert_2$ 会随着 $m$ 的增加而减小。收敛速度与分片线性基的逼近性质以及所涉及算子的阶数有关。由于算子 $\\mathsf{S}_n$ 涉及一个二阶有限差分，梯度的误差预计会以 $h_m$ 的某个次幂进行缩放，即 $O(m^{-p})$，其中 $p>0$。\n\n然而，这种改善不会无限持续下去。物理网格（$n_1$、$n_2$、$n_{\\text{ref}}$）上的离散化是固定的。一旦 mortar 网格变得比物理网格显著更精细（即 $m \\gg n_1, n_2$），误差将不再由 mortar 近似质量主导。取而代之的是，它将由不匹配离散化（在网格 $n_1, n_2$ 上取平均）与参考离散化（$n_{\\text{ref}}$）之间的内在差异主导。此时，进一步增加 $m$ 将产生递减的回报，误差 $\\varepsilon(m)$ 将趋于平稳。误差将收敛到一个非零值，该值代表了对于固定的网格 $n_1$ 和 $n_2$ 的不可约相容性误差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative consistency error of the gradient for a mortar-based\n    domain decomposition problem with nonmatching grids.\n    \"\"\"\n\n    def construct_s_operator(n):\n        \"\"\"\n        Constructs the symmetric positive definite operator S_n.\n        S_n = (1/h^2) * tridiag(-1, 2, -1) + I_n\n        \"\"\"\n        if n == 1:\n            return np.array([[1.0]])\n        h = 1.0 / (n - 1)\n        h2_inv = 1.0 / (h * h)\n        \n        diag_main = (2.0 * h2_inv + 1.0) * np.ones(n)\n        diag_off = -h2_inv * np.ones(n - 1)\n        \n        s_op = np.diag(diag_main) + np.diag(diag_off, k=1) + np.diag(diag_off, k=-1)\n        return s_op\n\n    def construct_interpolation_matrix(target_nodes, source_nodes):\n        \"\"\"\n        Constructs a linear interpolation matrix P that maps function values from\n        source_nodes to target_nodes.\n        Resulting matrix has shape (len(target_nodes), len(source_nodes)).\n        \"\"\"\n        n_target = len(target_nodes)\n        n_source = len(source_nodes)\n        \n        if n_source == 1:\n            if n_source == 1:\n                return np.ones((n_target, 1))\n            else:\n                return np.zeros((n_target, 0))\n\n        p_matrix = np.zeros((n_target, n_source))\n        h_source = 1.0 / (n_source - 1)\n        \n        for j in range(n_target):\n            s_j = target_nodes[j]\n            \n            # Handle edge case where s_j is exactly 1.0\n            if s_j >= 1.0:\n                p_matrix[j, -1] = 1.0\n                continue\n\n            # Find k such that s_j is in [source_nodes[k], source_nodes[k+1]]\n            k_float = s_j / h_source\n            k = int(k_float)\n            \n            # Linear interpolation weights\n            # The value at s_j is w * source[k] + (1-w) * source[k+1]\n            # No, it's (1-alpha)*source[k] + alpha*source[k+1] where alpha = (s_j-t_k)/h\n            alpha = k_float - k\n\n            p_matrix[j, k] = 1.0 - alpha\n            if k + 1  n_source:\n                p_matrix[j, k + 1] = alpha\n                \n        return p_matrix\n\n    # --- Problem Parameters ---\n    n1 = 53\n    n2 = 77\n    neval = 301\n    nref = 401\n    m_values = [2, 5, 10, 20, 40]\n    \n    results = []\n\n    # --- Pre-construct grids and S operators which are constant for all m ---\n    n1_nodes = np.linspace(0, 1, n1)\n    n2_nodes = np.linspace(0, 1, n2)\n    neval_nodes = np.linspace(0, 1, neval)\n    nref_nodes = np.linspace(0, 1, nref)\n\n    S1 = construct_s_operator(n1)\n    S2 = construct_s_operator(n2)\n    S_ref = construct_s_operator(nref)\n\n    I_eval1 = construct_interpolation_matrix(neval_nodes, n1_nodes)\n    I_eval2 = construct_interpolation_matrix(neval_nodes, n2_nodes)\n    I_eval_ref = construct_interpolation_matrix(neval_nodes, nref_nodes)\n\n    for m in m_values:\n        # --- Construct m-dependent entities ---\n        m_nodes = np.linspace(0, 1, m)\n        theta = np.sin(np.pi * m_nodes)\n\n        # Prolongation operators from mortar space to interface grids\n        P1 = construct_interpolation_matrix(n1_nodes, m_nodes)\n        P2 = construct_interpolation_matrix(n2_nodes, m_nodes)\n        P_ref = construct_interpolation_matrix(nref_nodes, m_nodes)\n        \n        # --- Construct composite operators R_m and R_true ---\n        # Nonmatching-grid operator\n        R_m = (I_eval1 @ S1 @ P1) + (I_eval2 @ S2 @ P2)\n        \n        # High-fidelity reference operator\n        R_true = 2.0 * I_eval_ref @ S_ref @ P_ref\n\n        # --- Compute gradients ---\n        # Gradient for nonmatching-grid functional\n        grad_J = R_m.T @ R_m @ theta\n        \n        # Gradient for reference functional\n        grad_J_true = R_true.T @ R_true @ theta\n\n        # --- Compute relative consistency error ---\n        error_norm = np.linalg.norm(grad_J - grad_J_true)\n        ref_norm = np.linalg.norm(grad_J_true)\n        \n        relative_error = 0.0\n        if ref_norm  1e-15: # Avoid division by zero\n            relative_error = error_norm / ref_norm\n        \n        results.append(relative_error)\n\n    # --- Format and print the final output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3377564"}, {"introduction": "这最后一个实践将区域分解方法集成到一个完整的非线性反问题中。您将实现一个高斯-牛顿 (Gauss-Newton) 优化步骤，其中正问题和灵敏度系统都使用基于舒尔补的区域分解求解器 [@problem_id:3377614] 进行高效求解。这个综合性练习展示了这些技术如何通过将问题分解为更小、可管理的部分来解决大規模、复杂的反问题。", "problem": "考虑一维非线性扩散边界值问题\n$$ -\\frac{d}{dx}\\big(\\kappa(m(x)) \\frac{du(x)}{dx}\\big) = f(x), \\quad x \\in (0,1), \\quad u(0)=0,\\;u(1)=0, $$\n其中扩散通过 $\\kappa(m)=\\exp(m)$ 在标量参数场中呈非线性。区域 $(0,1)$被分解为两个不重叠的子区域 $\\Omega_1=(0,0.5]$ 和 $\\Omega_2=[0.5,1)$，在交界面处状态和通量是连续的。参数场被限制为在分解的区域上是分段常数，即在 $\\Omega_1$ 上 $m(x)=m_1$，在 $\\Omega_2$ 上 $m(x)=m_2$，因此在 $\\Omega_1$ 上 $\\kappa(x)=\\exp(m_1)$，在 $\\Omega_2$ 上 $\\kappa(x)=\\exp(m_2)$。\n\n使用包含 $N=33$ 个节点的均匀网格对区间 $[0,1]$ 进行离散化，节点位于点 $x_i = i h$，其中 $h = 1/(N-1)$ 且 $i \\in \\{0,1,\\dots,N-1\\}$。设交界面位于节点索引 $i_{\\mathrm{I}} = 16$ 处（即 $x_{i_{\\mathrm{I}}}=0.5$）。使用带有可变系数的标准二阶守恒有限差分格式来近似扩散算子，其中边心系数 $\\kappa_{i+\\frac{1}{2}}$ 在每个子区域上是常数，对于边 $i+\\frac{1}{2} \\in \\{0.5,1.5,\\dots,15.5\\}$ 取值为 $\\exp(m_1)$，对于边 $i+\\frac{1}{2} \\in \\{16.5,17.5,\\dots,31.5\\}$ 取值为 $\\exp(m_2)$。在所有内部节点 $i \\in \\{1,2,\\dots,N-2\\}$ 处使用源项值 $f_i = 1$，且 $f_0=f_{N-1}=0$。在 $x_0=0$ 和 $x_{N-1}=1$ 处施加 Dirichlet 边界条件。使用 Schur 补或子结构化方法，通过交界面上的未知量耦合两个子区域的求解，从而在交界面处强制离散解的连续性和在交界面节点处强制离散外向通量的平衡。\n\n定义观测算子，该算子在节点索引 $\\{6,12,20,26\\}$ 处采样离散状态，这些节点对应于空间位置 $\\{x_6,x_{12},x_{20},x_{26}\\} = \\{6h,12h,20h,26h\\}$。通过使用真实参数 $m_{\\mathrm{true}} = [0.2,-0.1]$ 求解正问题来生成合成数据，得到离散解 $u^{\\mathrm{true}}$，提取其观测分量 $y^{\\mathrm{true}} \\in \\mathbb{R}^4$，并添加一个固定的噪声向量 $\\eta = [10^{-4},-2\\cdot 10^{-4},1.5\\cdot 10^{-4},-10^{-4}]$（单位与 $u$ 相同）以获得数据 $d = y^{\\mathrm{true}} + \\eta$。\n\n对于给定的初始猜测 $m^{(0)}=[m^{(0)}_1,m^{(0)}_2]$，对带有零阶正则化和单位数据协方差的 Tikhonov 正则化最小二乘问题执行一个 Gauss–Newton 步，\n$$ \\min_{m \\in \\mathbb{R}^2} \\; \\frac{1}{2}\\|F(m)-d\\|_2^2 + \\frac{\\gamma}{2}\\|m - m_{\\mathrm{ref}}\\|_2^2, $$\n其中 $F(m)$ 将参数对 $m$ 映射到 $4$ 个观测值，$m_{\\mathrm{ref}}=[0,0]$，$\\gamma0$ 是正则化参数。使用在 $m^{(0)}$ 处数据失配的 Gauss–Newton 线性化，并通过求解由带有 Hessian 矩阵的 Gauss–Newton 近似的法方程产生的 $2\\times 2$ 线性系统来计算参数增量。Jacobian 作用必须通过离散正向模型线性化得到的灵敏度方程获得，并且所有正向和灵敏度线性系统都必须使用上述的在交界面处耦合的两个子区域分解方法来求解。在计算更新后的参数 $m^{(1)}=m^{(0)}+\\delta m$ 后，报告数据失配的变化，\n$$ \\Delta \\Phi = \\frac{1}{2}\\|F(m^{(0)})-d\\|_2^2 - \\frac{1}{2}\\|F(m^{(1)})-d\\|_2^2. $$\n\n您的程序必须实现以上内容，并运行以下包含三个案例的测试套件，每个案例由一个初始猜测和一个正则化参数指定：\n- 案例 A (理想路径): $m^{(0)} = [0.0,0.0]$, $\\gamma = 10^{-2}$。\n- 案例 B (高对比度初始猜测): $m^{(0)} = [-1.0,1.0]$, $\\gamma = 10^{-2}$。\n- 案例 C (强正则化): $m^{(0)} = [0.0,0.0]$, $\\gamma = 1.0$。\n\n所有计算都是无量纲的；不需要物理单位。不涉及角度。不涉及百分比。\n\n您的程序应生成单行输出，其中包含案例 A、B 和 C 的三个失配减少量，形式为用方括号括起来的逗号分隔列表，每个数字都打印为小数点后保留六位的小数浮点数（例如，$[0.123456,0.000001,0.987654]$）。", "solution": "该问题要求对一个由一维非线性扩散方程控制的参数估计问题执行一个 Gauss-Newton 优化步骤。求解过程包括几个阶段：偏微分方程(PDE)的数值离散化、区域分解求解器的实现、合成数据的生成、Jacobian 灵敏度方程的推导与求解，以及最后 Gauss-Newton 系统的组装与求解。\n\n首先，我们定义离散化的正问题。控制方程为\n$$ -\\frac{d}{dx}\\left(\\kappa(m(x)) \\frac{du(x)}{dx}\\right) = f(x), \\quad x \\in (0,1) $$\n边界条件为 $u(0)=0$ 和 $u(1)=0$。该区域用 $N=33$ 个节点 $x_i = i h$ 进行离散化，其中 $i \\in \\{0, 1, \\dots, N-1\\}$ 且 $h=1/(N-1) = 1/32$。参数场是分段常数：在 $\\Omega_1=(0, 0.5]$ 上 $m(x)=m_1$，在 $\\Omega_2=[0.5, 1)$ 上 $m(x)=m_2$，因此扩散系数在 $\\Omega_1$ 上为 $\\kappa(x)=\\kappa_1=\\exp(m_1)$，在 $\\Omega_2$ 上为 $\\kappa(x)=\\kappa_2=\\exp(m_2)$。\n\n在内部节点 $i \\in \\{1, 2, \\dots, N-2\\}$ 上使用守恒有限差分格式，我们得到离散方程：\n$$ -\\frac{1}{h}\\left( \\kappa_{i+\\frac{1}{2}} \\frac{u_{i+1}-u_i}{h} - \\kappa_{i-\\frac{1}{2}} \\frac{u_i-u_{i-1}}{h} \\right) = f_i $$\n这为 $N-2=31$ 个内部未知量向量 $u_{int} = [u_1, u_2, \\dots, u_{31}]^T$ 构成一个线性方程组 $A(m)u_{int} = f_{int}$。所有内部节点的源项为 $f_i=1$。边界条件 $u_0=0$ 和 $u_{32}=0$ 已被纳入。\n\n问题指定了一种基于子结构化的区域分解方法。内部节点被划分为三组：$\\Omega_1$ 中的未知量 ($u_{\\Omega_1} = [u_1, \\dots, u_{15}]^T$)、交界面 $i_I=16$ 处的未知量 ($u_I = u_{16}$) 和 $\\Omega_2$ 中的未知量 ($u_{\\Omega_2} = [u_{17}, \\dots, u_{31}]^T$) 。该系统重新排序为：\n$$\n\\begin{pmatrix}\nA_{11}  0  A_{1I} \\\\\n0  A_{22}  A_{2I} \\\\\nA_{I1}  A_{I2}  A_{II}\n\\end{pmatrix}\n\\begin{pmatrix}\nu_{\\Omega_1} \\\\\nu_{\\Omega_2} \\\\\nu_I\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf_{\\Omega_1} \\\\\nf_{\\Omega_2} \\\\\nf_I\n\\end{pmatrix}\n$$\n对角块 $A_{11}$ 和 $A_{22}$ 是 $15 \\times 15$ 的对称三对角矩阵，表示在外部边界和交界面处带有 Dirichlet 条件的每个子区域上的离散拉普拉斯算子：\n$$ A_{11} = \\frac{\\kappa_1}{h^2} \\text{tridiag}(-1, 2, -1), \\quad A_{22} = \\frac{\\kappa_2}{h^2} \\text{tridiag}(-1, 2, -1) $$\n耦合块源于交界面节点 $i_I=16$ 处的有限差分方程：\n$$ \\frac{1}{h^2} (-\\kappa_1 u_{15} + (\\kappa_1 + \\kappa_2) u_{16} - \\kappa_2 u_{17}) = f_{16} $$\n这定义了 $A_{II} = (\\kappa_1+\\kappa_2)/h^2$ 和非对角耦合向量。\n\n这个分块系统使用 Schur 补约化来求解。通过求解 Schur 补系统来找到交界面未知量 $u_I$：\n$$ S u_I = f_I - A_{I1} A_{11}^{-1} f_{\\Omega_1} - A_{I2} A_{22}^{-1} f_{\\Omega_2} $$\n其中 Schur 补 $S$ 是一个标量，由 $S = A_{II} - A_{I1} A_{11}^{-1} A_{1I} - A_{I2} A_{22}^{-1} A_{2I}$ 给出。涉及 $A_{11}$ 和 $A_{22}$ 逆的所需矩阵向量积是通过在每个子区域上求解线性系统来计算的。一旦 $u_I$ 已知，子区域的解可通过回代求得：\n$$ u_{\\Omega_1} = A_{11}^{-1} (f_{\\Omega_1} - A_{1I} u_I), \\quad u_{\\Omega_2} = A_{22}^{-1} (f_{\\Omega_2} - A_{2I} u_I) $$\n这个过程定义了正向算子 $F(m)$，它将参数向量 $m=[m_1, m_2]^T$ 映射到节点 $\\{6, 12, 20, 26\\}$ 处的 4 个观测值向量。\n\n合成数据 $d$ 通过计算 $d = F(m_{\\mathrm{true}}) + \\eta$ 生成，其中 $m_{\\mathrm{true}}=[0.2,-0.1]$ 且 $\\eta = [10^{-4}, -2 \\cdot 10^{-4}, 1.5 \\cdot 10^{-4}, -10^{-4}]$。逆问题是找到使 Tikhonov 正则化成本函数最小化的 $m$：\n$$ \\min_{m \\in \\mathbb{R}^2} \\; \\mathcal{J}(m) = \\frac{1}{2}\\|F(m)-d\\|_2^2 + \\frac{\\gamma}{2}\\|m - m_{\\mathrm{ref}}\\|_2^2 $$\n其中 $m_{\\mathrm{ref}}=[0,0]$。我们从一个初始猜测 $m^{(0)}$ 开始，执行一个 Gauss-Newton 步。参数更新 $\\delta m$ 通过求解源于法方程的 $2 \\times 2$ 线性系统得到：\n$$ (J^T J + \\gamma I) \\delta m = J^T(d - F(m^{(0)})) - \\gamma(m^{(0)} - m_{\\mathrm{ref}}) $$\n其中 $J$ 是 $F$ 在 $m^{(0)}$ 处计算的 Jacobian 矩阵，而 $I$ 是 $2 \\times 2$ 的单位矩阵。\n\nJacobian 矩阵的列 $J_j = \\partial F / \\partial m_j$（$j \\in \\{1,2\\}$）是使用灵敏度分析计算的。将正向系统 $A(m)u_{int}(m) = f_{int}$ 对 $m_j$ 求导，得到灵敏度向量 $s_j = \\partial u_{int} / \\partial m_j$ 的线性系统：\n$$ A(m) s_j = -\\frac{\\partial A(m)}{\\partial m_j} u_{int}(m) =: g_j $$\n这个关于 $s_j$ 的系统与正问题具有相同的矩阵 $A(m)$，并且使用相同的 Schur 补方法高效求解。右侧向量 $g_j$ 是由离散算子的导数构成的。对于 $j=1$，$g_1$ 的非零分量对应于节点 $i \\in \\{1, \\dots, 16\\}$ 的方程；对于 $j=2$，它们对应于节点 $i \\in \\{16, \\dots, 31\\}$ 的方程。具体来说，利用 $(A u)_i = f_i$ 这一事实，在 $m^{(0)}$ 处的灵敏度右侧项的分量为：\n$$ (g_1)_i = \\begin{cases} -f_i = -1   i \\in \\{1, \\dots, 15\\} \\\\ -\\frac{\\kappa_1}{h^2}(-u_{15}+u_{16})  i=16 \\\\ 0  \\text{其他} \\end{cases} \\quad \\text{和} \\quad (g_2)_i = \\begin{cases} -\\frac{\\kappa_2}{h^2}(u_{16}-u_{17})  i=16 \\\\ -f_i = -1  i \\in \\{17, \\dots, 31\\} \\\\ 0  \\text{其他} \\end{cases} $$\n在求解出 $s_1$ 和 $s_2$ 后，通过应用观测算子得到 Jacobian 矩阵的列：$J_j = s_j|_{\\text{obs_indices}}$。\n\n每个测试案例的算法流程如下：\n1. 给定 $m^{(0)}$ 和 $\\gamma$，求解正问题得到 $u^{(0)}=u(m^{(0)})$，以找到预测数据 $F(m^{(0)})$ 和初始数据失配 $\\Phi_0 = \\frac{1}{2}\\|F(m^{(0)})-d\\|_2^2$。\n2. 使用 $u^{(0)}$ 和 $m^{(0)}$ 计算灵敏度右侧项 $g_1$ 和 $g_2$。\n3. 求解灵敏度系统 $A(m^{(0)})s_j=g_j$ 得到 $s_1$ 和 $s_2$。\n4. 根据 $s_1$ 和 $s_2$ 的观测分量构建 $4 \\times 2$ 的 Jacobian 矩阵 $J$。\n5. 组装并求解 $2 \\times 2$ 的 Gauss-Newton 系统，以获得参数更新 $\\delta m$。\n6. 计算更新后的参数 $m^{(1)} = m^{(0)} + \\delta m$。\n7. 求解正问题得到 $u^{(1)}=u(m^{(1)})$，以找到新的预测数据 $F(m^{(1)})$ 和最终数据失配 $\\Phi_1 = \\frac{1}{2}\\|F(m^{(1)})-d\\|_2^2$。\n8. 最终结果是数据失配的变化量 $\\Delta \\Phi = \\Phi_0 - \\Phi_1$。\n对指定的三个测试案例中的每一个重复此过程。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the entire process for the given test cases.\n    \"\"\"\n    N = 33\n    h = 1.0 / (N - 1)\n    i_I = 16  # Interface node index\n\n    # Observation nodes (1-based index)\n    obs_nodes = np.array([6, 12, 20, 26])\n    # Corresponding 0-based index in the interior solution vector u_int[0...30]\n    obs_indices_in_u_int = obs_nodes - 1\n\n    # Ground truth and data generation\n    m_true = np.array([0.2, -0.1])\n    eta = np.array([1e-4, -2e-4, 1.5e-4, -1e-4])\n    m_ref = np.array([0.0, 0.0])\n\n    u_true_int, _ = solve_forward(m_true, N, h, i_I)\n    y_true = u_true_int[obs_indices_in_u_int]\n    d = y_true + eta\n    \n    # Test cases\n    test_cases = [\n        # Case A\n        {'m0': np.array([0.0, 0.0]), 'gamma': 1e-2},\n        # Case B\n        {'m0': np.array([-1.0, 1.0]), 'gamma': 1e-2},\n        # Case C\n        {'m0': np.array([0.0, 0.0]), 'gamma': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        m0 = case['m0']\n        gamma = case['gamma']\n\n        # 1. Evaluate forward model and Jacobian at m0\n        u0_int, F_m0 = solve_forward(m0, N, h, i_I, obs_indices_in_u_int)\n        \n        g1_rhs = compute_sensitivity_rhs(m0, u0_int, 1, h, N, i_I)\n        g2_rhs = compute_sensitivity_rhs(m0, u0_int, 2, h, N, i_I)\n        \n        s1_int, J_col1 = solve_forward(m0, N, h, i_I, obs_indices_in_u_int, rhs=g1_rhs)\n        s2_int, J_col2 = solve_forward(m0, N, h, i_I, obs_indices_in_u_int, rhs=g2_rhs)\n        \n        J = np.vstack((J_col1, J_col2)).T\n\n        # 2. Compute misfit and Gauss-Newton step\n        residual = d - F_m0\n        phi0 = 0.5 * np.dot(residual, residual)\n\n        H_GN = J.T @ J + gamma * np.eye(2)\n        rhs_GN = J.T @ residual - gamma * (m0 - m_ref)\n        \n        delta_m = np.linalg.solve(H_GN, rhs_GN)\n        m1 = m0 + delta_m\n\n        # 3. Evaluate forward model at m1 and compute final misfit\n        _, F_m1 = solve_forward(m1, N, h, i_I, obs_indices_in_u_int)\n        phi1 = 0.5 * np.dot(d - F_m1, d - F_m1)\n\n        delta_phi = phi0 - phi1\n        results.append(delta_phi)\n\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\n\ndef solve_schur_system(k1, k2, h, i_I, rhs_int):\n    \"\"\"\n    Solves a linear system using the Schur complement (substructuring) method.\n    `rhs_int` is the right-hand side for the interior nodes [1, ..., N-2].\n    \"\"\"\n    num_sub_nodes = i_I - 1  # 15 nodes in each subdomain interior\n\n    # Partition the RHS\n    rhs1 = rhs_int[:num_sub_nodes]\n    rhs_I = rhs_int[num_sub_nodes]\n    rhs2 = rhs_int[num_sub_nodes+1:]\n\n    # Build subdomain matrices A11 and A22 (banded format for solve_banded)\n    # A = diag(d) + diag(e, 1) + diag(e, -1) has banded form:\n    # [e, d, e] - ab = [[0, *e], [d], [*e, 0]]\n    A11_banded = np.zeros((3, num_sub_nodes))\n    A11_banded[0, 1:] = -1.0\n    A11_banded[1, :] = 2.0\n    A11_banded[2, :-1] = -1.0\n    A11_banded *= k1 / h**2\n\n    A22_banded = np.zeros((3, num_sub_nodes))\n    A22_banded[0, 1:] = -1.0\n    A22_banded[1, :] = 2.0\n    A22_banded[2, :-1] = -1.0\n    A22_banded *= k2 / h**2\n\n    # Coupling vectors\n    A1I = np.zeros(num_sub_nodes); A1I[-1] = -k1 / h**2\n    A2I = np.zeros(num_sub_nodes); A2I[0] = -k2 / h**2\n    AI1 = A1I\n    AI2 = A2I\n\n    # Interface 'matrix'\n    AII = (k1 + k2) / h**2\n\n    # Solve for constituents of Schur complement system\n    # v1 = A11^{-1} f1\n    v1 = solve_banded((1, 1), A11_banded, rhs1)\n    # v2 = A22^{-1} f2\n    v2 = solve_banded((1, 1), A22_banded, rhs2)\n    # w1 = A11^{-1} A1I\n    w1 = solve_banded((1, 1), A11_banded, A1I)\n    # w2 = A22^{-1} A2I\n    w2 = solve_banded((1, 1), A22_banded, A2I)\n    \n    # Schur complement and its RHS (both are scalars)\n    S = AII - np.dot(AI1, w1) - np.dot(AI2, w2)\n    rhs_S = rhs_I - np.dot(AI1, v1) - np.dot(AI2, v2)\n    \n    # Solve for interface unknown\n    u_I = rhs_S / S\n    \n    # Back-substitute for subdomain unknowns\n    u1 = v1 - w1 * u_I\n    u2 = v2 - w2 * u_I\n    \n    # Assemble full interior solution\n    u_int = np.concatenate((u1, [u_I], u2))\n    return u_int\n\n\ndef solve_forward(m, N, h, i_I, obs_indices_in_u_int=None, rhs=None):\n    \"\"\"\n    Solves the forward or sensitivity problem. If rhs is None, solves the\n    forward problem with source f=1. Otherwise, solves with the given rhs.\n    Returns the full interior solution and optionally the observed values.\n    \"\"\"\n    k1, k2 = np.exp(m[0]), np.exp(m[1])\n    num_int_nodes = N - 2\n\n    if rhs is None:\n        # Standard forward problem RHS (f_i = 1 for all interior nodes)\n        rhs = np.ones(num_int_nodes)\n        \n    u_int = solve_schur_system(k1, k2, h, i_I, rhs)\n\n    if obs_indices_in_u_int is not None:\n        return u_int, u_int[obs_indices_in_u_int]\n    return u_int, None\n\n\ndef compute_sensitivity_rhs(m, u_int, param_idx, h, N, i_I):\n    \"\"\"\n    Computes the right-hand side vector g_j for the sensitivity equation.\n    param_idx is 1 for m1, 2 for m2.\n    \"\"\"\n    k1, k2 = np.exp(m[0]), np.exp(m[1])\n    num_int_nodes = N - 2\n    num_sub_nodes = i_I - 1\n\n    g = np.zeros(num_int_nodes)\n    \n    u_full = np.concatenate(([0], u_int, [0]))\n    u_15 = u_full[i_I - 1]\n    u_16 = u_full[i_I]\n    u_17 = u_full[i_I + 1]\n\n    if param_idx == 1:\n        g[:num_sub_nodes] = -1.0 # correspoding to nodes 1...15\n        g[num_sub_nodes] = -(k1 / h**2) * (-u_15 + u_16)\n    elif param_idx == 2:\n        g[num_sub_nodes] = -(k2 / h**2) * (u_16 - u_17)\n        g[num_sub_nodes+1:] = -1.0 # correspoding to nodes 17...31\n    \n    return g\n\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3377614"}]}