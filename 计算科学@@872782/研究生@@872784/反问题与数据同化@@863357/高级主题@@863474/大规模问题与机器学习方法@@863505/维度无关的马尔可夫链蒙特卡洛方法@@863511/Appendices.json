{"hands_on_practices": [{"introduction": "本练习聚焦于预处理克兰克-尼科尔森 (Preconditioned Crank-Nicolson, pCN) 算法，这是函数空间MCMC方法的一块基石。通过分析一个后验等于先验的简化场景[@problem_id:3376428]，你将推导出一个关键结论：马尔可夫链的自相关性与离散化的维度无关。这项实践对于从第一性原理层面理解为何pCN提议在高维环境中依然有效至关重要。", "problem": "考虑一个定义在可分希尔伯特空间 $\\mathcal{H}$ 上的贝叶斯线性反问题，其高斯先验为 $u \\sim \\mathcal{N}(0,\\mathcal{C})$，其中 $\\mathcal{C}:\\mathcal{H}\\to\\mathcal{H}$ 是一个迹类、自伴、正定的协方差算子。假设似然是平坦的（等价于正向算子是零映射，因此数据不包含任何信息），所以后验等于先验。令 $\\{(\\lambda_{k},e_{k})\\}_{k\\geq 1}$ 表示 $\\mathcal{C}$ 的特征对，其中 $\\lambda_{k}0$，且 $\\{e_{k}\\}$ 构成 $\\mathcal{H}$ 的一个标准正交基。对于一个固定的截断水平 $J\\in\\mathbb{N}$，定义 Karhunen–Loève (KL) 截断为\n$$\nu^{(J)}=\\sum_{k=1}^{J}\\sqrt{\\lambda_{k}}\\,\\xi_{k}\\,e_{k},\\quad \\xi_{k}\\stackrel{\\text{i.i.d.}}{\\sim}\\mathcal{N}(0,1).\n$$\n令 $\\ell:\\mathcal{H}\\to\\mathbb{R}$ 是一个连续线性泛函，其先验方差 $\\sigma_{\\ell}^{2}=\\langle \\ell,\\mathcal{C}\\ell\\rangle$ 是有限的，其中 $\\langle\\cdot,\\cdot\\rangle$ 表示由 $\\mathcal{H}$ 导出的对偶配对。考虑参数为 $\\beta\\in(0,1)$ 的预处理克兰克-尼科尔森 (pCN) 马尔可夫链，它在截断空间上由以下更新规则定义：\n$$\nu_{n+1}^{(J)}=\\sqrt{1-\\beta^{2}}\\,u_{n}^{(J)}+\\beta\\,\\xi_{n+1}^{(J)},\n$$\n其中 $\\xi_{n+1}^{(J)}\\sim\\mathcal{N}(0,\\mathcal{C}^{(J)})$ 与 $u_{n}^{(J)}$ 独立，并且 $\\mathcal{C}^{(J)}$ 是对应于 $J$-模态截断的协方差。在上述零信息似然设置中，pCN 提议总是被接受，因此这定义了马尔可夫链的精确转移。\n\n令 $s_{n}^{(J)}=\\ell(u_{n}^{(J)})$ 表示将 $\\ell$ 应用于该链所得到的标量时间序列。在链平穩的条件下，推导 $s_{n}^{(J)}$ 的滞后-1 自相关，其定义为\n$$\n\\rho_{1}^{(J)}=\\frac{\\operatorname{Cov}\\big(s_{n+1}^{(J)},s_{n}^{(J)}\\big)}{\\operatorname{Var}\\big(s_{n}^{(J)}\\big)},\n$$\n推导一个仅用 $\\beta$ 表示的解析表达式。证明该表达式与截断水平 $J$ 无关。将你的最终答案表示为一个闭式符号表达式。无需四舍五入，最终表达式中也不应包含单位。", "solution": "该问题被确定为有效的，因为它在科学上基于贝叶斯反问题和马尔可夫链蒙特卡洛方法的理论，问题是良定的且目标明确，并以无歧义的形式化语言表述。因此，我们可以进行推导。\n\n我们的目标是计算标量时间序列 $s_{n}^{(J)} = \\ell(u_{n}^{(J)})$ 的滞后-1 自相关，其定义为：\n$$\n\\rho_{1}^{(J)} = \\frac{\\operatorname{Cov}\\big(s_{n+1}^{(J)}, s_{n}^{(J)}\\big)}{\\operatorname{Var}\\big(s_{n}^{(J)}\\big)}\n$$\n问题指明马尔可夫链处于其平稳状态。预处理克兰克-尼科尔森 (pCN) 算法被设计为以目标分布为其不变测度。在这种情况下，由于似然是平坦的，目标分布就是先验分布。对于 J 维截断系统，目标分布是 $\\mathcal{N}(0, \\mathcal{C}^{(J)})$，其中 $\\mathcal{C}^{(J)}$ 是对应于 J-模态截断的协方差算子。因此，在平稳状态下，对于任何时间指标 n，状态 $u_{n}^{(J)}$ 是一个从该分布中抽样的随机变量：\n$$\nu_{n}^{(J)} \\sim \\mathcal{N}(0, \\mathcal{C}^{(J)})\n$$\n标量时间序列是通过将连续线性泛函 $\\ell$ 应用于状态得到的，$s_{n}^{(J)} = \\ell(u_{n}^{(J)})$。由于 $u_{n}^{(J)}$ 是一个零均值高斯随机变量且 $\\ell$ 是线性的，所以 $s_{n}^{(J)}$ 也是一个零均值高斯随机变量。我们可以通过计算其期望来形式化地证明这一点：\n$$\n\\mathbb{E}\\big[s_{n}^{(J)}\\big] = \\mathbb{E}\\big[\\ell(u_{n}^{(J)})\\big] = \\ell\\big(\\mathbb{E}[u_{n}^{(J)}]\\big) = \\ell(0) = 0\n$$\n$\\rho_{1}^{(J)}$ 定义中的分母是 $s_{n}^{(J)}$ 的方差。由于均值为零，方差由下式给出：\n$$\n\\operatorname{Var}\\big(s_{n}^{(J)}\\big) = \\mathbb{E}\\big[(s_{n}^{(J)})^{2}\\big]\n$$\n这是一个线性泛函应用于高斯随机变量的方差，它由与协方差算子相关的二次型给出：\n$$\n\\operatorname{Var}\\big(s_{n}^{(J)}\\big) = \\langle \\ell, \\mathcal{C}^{(J)}\\ell \\rangle\n$$\n我们假设 $\\ell$ 不是零泛函，以确保对于任何 $J$，只要截断先验的支撑集在 $\\ell$ 上有非平凡投影，就有 $\\operatorname{Var}(s_{n}^{(J)})  0$。如果我们假设 $\\ell$ 关于基 $\\{e_k\\}$ 的第一个分量非零，那么对于任何 $J \\ge 1$，这一点都是有保证的。问题给出的条件 $\\sigma_{\\ell}^{2}=\\langle \\ell,\\mathcal{C}\\ell\\rangle$ 是有限的，意味着 $\\ell$ 在一个合适的域中，并且假设 $\\ell \\neq 0$ 意味着 $\\sigma_{\\ell}^2  0$。\n\n接下来，我们处理分子，即协方差项 $\\operatorname{Cov}(s_{n+1}^{(J)}, s_{n}^{(J)})$。由于均值为零，这可以简化为：\n$$\n\\operatorname{Cov}\\big(s_{n+1}^{(J)}, s_{n}^{(J)}\\big) = \\mathbb{E}\\big[s_{n+1}^{(J)}s_{n}^{(J)}\\big]\n$$\n我们使用问题陈述中给出的 $u_{n+1}^{(J)}$ 的 pCN 更新规则：\n$$\nu_{n+1}^{(J)} = \\sqrt{1-\\beta^{2}}\\,u_{n}^{(J)} + \\beta\\,\\xi_{n+1}^{(J)}\n$$\n其中 $\\beta \\in (0,1)$ 且新息项 $\\xi_{n+1}^{(J)} \\sim \\mathcal{N}(0, \\mathcal{C}^{(J)})$ 与 $u_{n}^{(J)}$ 独立。将线性泛函 $\\ell$ 应用于该更新方程的两边，得到 $s_{n+1}^{(J)}$ 的表达式：\n$$\ns_{n+1}^{(J)} = \\ell\\left(\\sqrt{1-\\beta^{2}}\\,u_{n}^{(J)} + \\beta\\,\\xi_{n+1}^{(J)}\\right) = \\sqrt{1-\\beta^{2}}\\,\\ell(u_{n}^{(J)}) + \\beta\\,\\ell(\\xi_{n+1}^{(J)})\n$$\n认识到 $\\ell(u_{n}^{(J)}) = s_{n}^{(J)}$，我们得到标量时间序列的以下自回归关系：\n$$\ns_{n+1}^{(J)} = \\sqrt{1-\\beta^{2}}\\,s_{n}^{(J)} + \\beta\\,\\ell(\\xi_{n+1}^{(J)})\n$$\n我们现在计算期望 $\\mathbb{E}[s_{n+1}^{(J)}s_{n}^{(J)}]$：\n$$\n\\mathbb{E}\\big[s_{n+1}^{(J)}s_{n}^{(J)}\\big] = \\mathbb{E}\\left[\\left(\\sqrt{1-\\beta^{2}}\\,s_{n}^{(J)} + \\beta\\,\\ell(\\xi_{n+1}^{(J)})\\right) s_{n}^{(J)}\\right]\n$$\n根据期望的线性性：\n$$\n\\mathbb{E}\\big[s_{n+1}^{(J)}s_{n}^{(J)}\\big] = \\sqrt{1-\\beta^{2}}\\,\\mathbb{E}\\big[(s_{n}^{(J)})^{2}\\big] + \\beta\\,\\mathbb{E}\\big[\\ell(\\xi_{n+1}^{(J)})s_{n}^{(J)}\\big]\n$$\n第一项可被识别为 $\\sqrt{1-\\beta^{2}}\\,\\operatorname{Var}(s_{n}^{(J)})$。在第二项中，我们分析期望 $\\mathbb{E}[\\ell(\\xi_{n+1}^{(J)})s_{n}^{(J)}]$。根据构造，新息 $\\xi_{n+1}^{(J)}$ 与当前状态 $u_{n}^{(J)}$ 无关。因此，$\\xi_{n+1}^{(J)}$ 的任何函数（如 $\\ell(\\xi_{n+1}^{(J)})$）都与 $u_{n}^{(J)}$ 的任何函数（如 $s_{n}^{(J)}$）无关。因此，乘积的期望等于期望的乘积：\n$$\n\\mathbb{E}\\big[\\ell(\\xi_{n+1}^{(J)})s_{n}^{(J)}\\big] = \\mathbb{E}\\big[\\ell(\\xi_{n+1}^{(J)})\\big] \\mathbb{E}\\big[s_{n}^{(J)}\\big]\n$$\n我们已经确定了 $\\mathbb{E}[s_{n}^{(J)}] = 0$。新息项的期望也为零：\n$$\n\\mathbb{E}\\big[\\ell(\\xi_{n+1}^{(J)})\\big] = \\ell\\left(\\mathbb{E}[\\xi_{n+1}^{(J)}]\\right) = \\ell(0) = 0\n$$\n因此，第二项完全消失：\n$$\n\\beta\\,\\mathbb{E}\\big[\\ell(\\xi_{n+1}^{(J)})s_{n}^{(J)}\\big] = \\beta \\cdot 0 \\cdot 0 = 0\n$$\n这给我们留下了协方差的最终表达式：\n$$\n\\operatorname{Cov}\\big(s_{n+1}^{(J)}, s_{n}^{(J)}\\big) = \\sqrt{1-\\beta^{2}}\\,\\operatorname{Var}\\big(s_{n}^{(J)}\\big)\n$$\n我们现在可以组合出滞后-1 自相关：\n$$\n\\rho_{1}^{(J)} = \\frac{\\operatorname{Cov}\\big(s_{n+1}^{(J)}, s_{n}^{(J)}\\big)}{\\operatorname{Var}\\big(s_{n}^{(J)}\\big)} = \\frac{\\sqrt{1-\\beta^{2}}\\,\\operatorname{Var}\\big(s_{n}^{(J)}\\big)}{\\operatorname{Var}\\big(s_{n}^{(J)}\\big)}\n$$\n假定 $\\operatorname{Var}(s_{n}^{(J)}) \\neq 0$，我们可以消去方差项得到：\n$$\n\\rho_{1}^{(J)} = \\sqrt{1-\\beta^{2}}\n$$\n这个结果仅是 pCN 参数 $\\beta$ 的函数，并且确实与截断水平 $J$、协方差算子 $\\mathcal{C}$ 以及线性泛函 $\\ell$ 的选择无关。这一性质是 pCN 方法在这种理想化设置下的一个标志性特征，其中算法的自回归结构直接转化为任何线性可观测量的自回归结构。", "answer": "$$\\boxed{\\sqrt{1-\\beta^{2}}}$$", "id": "3376428"}, {"introduction": "本练习转向一种更复杂的算法，探讨函数空间中的哈密顿蒙特卡洛 (HMC) [@problem_id:3376383]。你将运用尺度分析来确定，为保持采样效率，数值积分器的参数必须如何随着问题维度的增加而调整。这项实践揭示了数值分析与统计性能之间微妙的相互作用，这是设计稳健的、维度无关的采样器时的一个核心考量。", "problem": "考虑一个定义在可分希尔伯特空间 $\\mathcal{H}$ 上的贝叶斯线性反问题，其高斯先验为 $u \\sim \\mathcal{N}(0,\\mathcal{C})$，其中 $\\mathcal{C}:\\mathcal{H}\\to\\mathcal{H}$ 是一个严格正定、自伴、迹类的协方差算子，其特征对 $\\{(\\lambda_{i},\\phi_{i})\\}_{i\\geq 1}$ 构成一个完备标准正交基。数据模型是线性的，带有加性高斯观测噪声，这导致后验测度相对于先验测度是绝对连续的，其负对数似然（通常称为势）$\\Phi(u)$ 假定为二次 Fréchet 可微且是平滑的，即 $\\nabla \\Phi$ 映射到与 $\\mathcal{C}$ 相关的 Cameron–Martin 空间中。你在函数空间上使用质量矩阵 $M=\\mathcal{C}^{-1}$ 运行哈密顿蒙特卡洛（HMC）方法，并使用步长为 $\\epsilon$、每个提议包含 $L$ 步的蛙跳（leapfrog，也称为 Störmer–Verlet）积分器来离散化哈密顿流。\n\n为了数值上实现该算法，你在第 $K$ 阶截断 Karhunen–Loève 展开，用 $\\{\\phi_{1},\\dots,\\phi_{K}\\}$ 的张成空间中的元素来近似 $u$。令 $u_{K}$ 表示截断后的参数，并将截断空间上的哈密顿量写为 $H_{K}(u_{K},p_{K})=\\Phi(u_{K})+\\frac{1}{2}\\langle u_{K},\\mathcal{C}^{-1}u_{K}\\rangle+\\frac{1}{2}\\langle p_{K},\\mathcal{C}p_{K}\\rangle$，其中 $p_{K}$ 是动量。\n\n在白化坐标 $x_{i}=\\lambda_{i}^{-1/2}\\langle u,\\phi_{i}\\rangle$ 和 $v_{i}=\\lambda_{i}^{1/2}\\langle p,\\phi_{i}\\rangle$（其中 $i=1,\\dots,K$）下进行计算。在这些坐标下，高斯先验部分解耦为 $K$ 个独立的单位频率的简谐振子。在单个 HMC 提议中，当 $K$ 变化时保持总积分时间 $\\tau=L\\epsilon$ 固定，蛙跳积分器是辛的且时间可逆的。对于每个模式 $i$，在时间 $\\tau$ 后的全局能量误差满足 $\\Delta H_{i}=\\mathcal{O}(\\epsilon^{2})$ 形式的展开，其主导偏差消失，涨落为 $\\mathcal{O}(\\epsilon^{2})$ 阶，其对 Metropolis–Hastings 接受概率的贡献为每个模式 $\\mathcal{O}(\\epsilon^{4})$ 阶。假设似然贡献 $\\Phi$ 足够平滑，使得高频模式由高斯先验主导，并且这些 $\\mathcal{O}(\\cdot)$ 表达式中每个模式的常数关于 $i$是一致有界的。\n\n利用谱解耦、蛙跳积分器的性质以及独立模式能量误差之和的中心极限定理启发式方法，从第一性原理出发进行论证：为了在谱截断下，当 $K\\to\\infty$ 时保持 $u\\in\\mathcal{H}$ 的 Metropolis–Hastings 接受概率稳定（有界地远离 $0$ 和 $1$），步长必须按 $\\epsilon_{K}\\asymp K^{-\\gamma}$ 的方式随 $K$ 缩放，并且步数必须按 $L_{K}\\asymp K^{\\gamma}$ 的方式缩放以保持 $\\tau$ 固定。确定缩放指数 $\\gamma$ 的精确值。\n\n你的最终答案应该是 $\\gamma$ 的单个精确值。不要提供不等式或描述性条件。不要包含任何单位。无需四舍五入。", "solution": "我们从贝叶斯反问题的函数空间哈密顿表述开始：对于先验 $u\\sim \\mathcal{N}(0,\\mathcal{C})$ 和似然势 $\\Phi(u)$，哈密顿量为\n$$\nH(u,p) \\;=\\; \\Phi(u) \\;+\\; \\frac{1}{2}\\langle u,\\mathcal{C}^{-1}u\\rangle \\;+\\; \\frac{1}{2}\\langle p,\\mathcal{C}p\\rangle,\n$$\n当质量矩阵取为 $M=\\mathcal{C}^{-1}$ 时。在由 $\\mathcal{C}$ 的特征对 $\\{(\\lambda_{i},\\phi_{i})\\}_{i\\geq 1}$ 定义的白化坐标中，即\n$$\nx_{i}\\;=\\;\\lambda_{i}^{-1/2}\\langle u,\\phi_{i}\\rangle,\\qquad v_{i}\\;=\\;\\lambda_{i}^{1/2}\\langle p,\\phi_{i}\\rangle,\n$$\n哈密顿量的高斯先验部分解耦为一系列单位频率的简谐振子（SHO）之和：\n$$\nH_{\\text{prior}}(x,v)\\;=\\;\\sum_{i=1}^{K}\\frac{1}{2}\\big(x_{i}^{2}+v_{i}^{2}\\big).\n$$\n假设似然势 $\\Phi(u)$ 是平滑的，因此其贡献主要耦合低阶模式；对于高阶模式，动力学由解耦的高斯简谐振子结构主导。因此，对 Metropolis–Hastings 接受概率的、依赖于截断的主导贡献来自于高斯部分，我们只需分析跨模式的简谐振子能量误差即可。\n\n在使用步长为 $\\epsilon$、步数为 $L$ 且总积分时间 $\\tau=L\\epsilon$ 固定的蛙跳（Störmer–Verlet）积分器下，每个单位频率简谐振子模式 $(x_{i},v_{i})$ 的数值流是一个辛的、时间可逆的映射，它是对角度为 $\\tau$ 的精确旋转的二阶精确近似。设时间 $\\tau$ 上的精确流由旋转矩阵 $R(\\tau)$ 表示，蛙跳单步映射由 $A(\\epsilon)$ 表示。那么经过 $L$ 步后，\n$$\nA(\\epsilon)^{L}\\;=\\;R(\\tau)\\;+\\;\\epsilon^{2}B(\\tau)\\;+\\;\\mathcal{O}(\\epsilon^{4}),\n$$\n根据对辛积分器的标准后向误差分析，对于某个与模式指标 $i$ 无关的有界矩阵 $B(\\tau)$。简谐振子的哈密顿量为 $H_{i}(x_{i},v_{i})=\\frac{1}{2}(x_{i}^{2}+v_{i}^{2})$，因此模式 $i$ 在时间 $\\tau$ 后的能量误差为\n$$\n\\Delta H_{i}\\;=\\;H_{i}\\big(A(\\epsilon)^{L}(x_{i},v_{i})\\big)\\;-\\;H_{i}(x_{i},v_{i}).\n$$\n由于蛙跳法是辛的且时间可逆的，$\\Delta H_{i}$ 中的主导项 $\\mathcal{O}(\\epsilon^{2})$ 在时间反演下是奇函数，并且相对于 $(x_{i},v_{i})$ 的不变高斯（正则）测度，其平均值为零。因此，对于每个模式 $i$，\n$$\n\\mathbb{E}[\\Delta H_{i}]\\;=\\;\\mathcal{O}(\\epsilon^{4}),\\qquad \\operatorname{Var}(\\Delta H_{i})\\;=\\;\\mathcal{O}(\\epsilon^{4}),\n$$\n其中期望是针对平稳高斯分布 $x_{i}\\sim \\mathcal{N}(0,1)$ 和 $v_{i}\\sim \\mathcal{N}(0,1)$（两者独立）计算的。$\\mathcal{O}(\\cdot)$ 记号中隐藏的常数取决于 $\\tau$ 和积分器的性质，但关键的是，由于选择了 $M=\\mathcal{C}^{-1}$ 从而产生了单位频率解耦，这些常数在模式指标 $i$ 上是一致的。$\\Phi$ 的平滑性确保了加上似然贡献不会改变这些界在高阶模式下的标度行为。\n\n对 $K$ 个独立模式求和，总能量误差为\n$$\n\\Delta H_{K}\\;=\\;\\sum_{i=1}^{K}\\Delta H_{i}.\n$$\n根据独立性和一致有界性，我们得到\n$$\n\\mathbb{E}[\\Delta H_{K}]\\;=\\;\\mathcal{O}(K\\epsilon^{4}),\\qquad \\operatorname{Var}(\\Delta H_{K})\\;=\\;\\mathcal{O}(K\\epsilon^{4}).\n$$\n对于一个通过积分时间 $\\tau$ 并进行动量翻转生成的提议，其 Metropolis–Hastings 接受概率为\n$$\n\\alpha_{K}\\;=\\;\\min\\big(1,\\exp(-\\Delta H_{K})\\big).\n$$\n为了当 $K\\to\\infty$ 时保持 $\\alpha_{K}$ 一致地有界于 $0$ 和 $1$ 之外（即，在谱截断下保持接受概率稳定），随机变量 $\\Delta H_{K}$ 的涨落必须是常数阶，既不趋于 $0$ 也不发散到 $\\infty$。上述标度关系表明，要实现这一点，必须满足\n$$\nK\\epsilon^{4}\\;\\asymp\\;1,\n$$\n这样 $\\Delta H_{K}$ 的均值和标准差就都是一阶的。因此，步长必须随 $K$ 减小，其关系为\n$$\n\\epsilon_{K}\\;\\asymp\\;K^{-1/4}.\n$$\n由于总积分时间 $\\tau=L\\epsilon$ 保持固定（为了算法的有效性），因此步数 $L$ 的标度行为如下\n$$\nL_{K}\\;\\asymp\\;\\tau\\,\\epsilon_{K}^{-1}\\;\\asymp\\;\\tau\\,K^{1/4}.\n$$\n因此，步长标度律 $\\epsilon_{K}\\asymp K^{-\\gamma}$ 中所要求的指数是\n$$\n\\gamma\\;=\\;\\frac{1}{4}.\n$$\n这个值是质量矩阵选择 $M=\\mathcal{C}^{-1}$ 所引起的单位频率解耦，以及蛙跳积分器的二阶、对称、辛性质的直接结果。这些性质确保了每个模式对接受率下降的贡献为 $\\mathcal{O}(\\epsilon^{4})$ 阶，从而当 $\\epsilon_{K}$ 按 $K^{-1/4}$ 衰减且 $L_{K}$ 按 $K^{1/4}$ 增长以保持 $\\tau$ 固定时，能够获得截断稳定的接受率。", "answer": "$$\\boxed{\\tfrac{1}{4}}$$", "id": "3376383"}, {"introduction": "本练习将理论与实践联系起来，要求你为一个偏微分方程（PDE）约束的逆问题实现一个函数空间Metropolis调整的朗之万算法 (MALA) [@problem_id:3376373]。你将处理离散算子，使用傅里叶方法进行先验条件化，并凭经验验证算法的维度无关行为。这次动手实践将巩固你对这些高级MCMC方法在实际计算环境中的表现的理解。", "problem": "考虑单位区间上的周期性边界条件的一维扩散初值问题，该问题由偏微分方程 (PDE) $\\,\\partial_t y - \\partial_x\\!\\left(u(x)\\,\\partial_x y\\right)=0\\,$ 定义，其中 $\\,x\\in[0,1]\\,$ 且 $\\,t\\ge 0\\,$, $\\,u(x)\\,$ 是从观测中推断的空间变化的扩散系数。设初始条件为 $\\,y(x,0)=y_0(x)\\,$，其中 $\\,y_0\\,$ 是光滑函数。假设在微小时间 $\\,T0\\,$ 时的观测值可以通过线性化关系近似\n$$\ny(x,T)\\approx y_0(x) + T\\,\\partial_x\\!\\left(u(x)\\,\\partial_x y_0(x)\\right),\n$$\n因此离散数据向量 $\\,d\\,$ 的模型为\n$$\nd = A u + \\varepsilon,\\quad A u := T\\,D u,\\quad D u := \\partial_x u \\cdot \\partial_x y_0 + u \\cdot \\partial_{xx} y_0,\n$$\n其中 $\\,\\varepsilon\\,$ 是均值为零、协方差为 $\\,\\Gamma = \\sigma^2 I\\,$ 的高斯噪声，$\\,I\\,$ 是离散网格上的单位矩阵。\n\n对 $\\,u\\,$ 采用高斯先验，其均值为 $\\,m(x)\\,$，协方差算子为 $\\,L^2([0,1])\\,$ 上带有周期性边界条件的 $\\,\\mathcal{C} = \\left(\\alpha I - \\Delta\\right)^{-\\kappa}\\,$，其中 $\\,\\alpha0\\,$, $\\,\\kappa\\ge 1\\,$, $\\,\\Delta\\,$ 是拉普拉斯算子。对于间距为 $\\,h\\,$ 的离散网格，负对数后验（不计加性常数）为\n$$\nJ(u) = \\frac{1}{2}\\,\\left\\langle A u - d,\\,\\Gamma^{-1}(A u - d)\\right\\rangle_{L^2} + \\frac{1}{2}\\,\\left\\langle u - m,\\,\\mathcal{C}^{-1}(u - m)\\right\\rangle_{L^2},\n$$\n其中 $\\,L^2\\,$ 内积通过 $\\,\\langle v,w\\rangle_{L^2} \\approx h \\sum_j v_j w_j\\,$ 进行离散化。\n\n构建一个函数空间 Metropolis-Adjusted Langevin Algorithm (MALA)，该算法通过预处理提议来更新 $\\,u\\,$\n$$\nu' = u + \\eta\\,\\mathcal{C}\\,\\nabla \\Phi(u) + \\sqrt{2\\eta}\\,\\mathcal{C}^{1/2}\\,\\xi,\n$$\n其中 $\\,\\Phi(u)\\,$ 是对数后验（因此 $\\,\\nabla \\Phi(u) = -\\nabla J(u)\\,$），$\\,\\eta0\\,$ 是步长，$\\,\\xi\\sim \\mathsf{Normal}(0,I)\\,$ 是网格上的白噪声。使用由 $\\,L^2\\,$ 内积定义的伴随算子 $\\,A^*\\,$ 来计算 $\\,\\nabla J(u) = A^*\\Gamma^{-1}(Au-d) + \\mathcal{C}^{-1}(u-m)\\,$。由此产生的提议密度是高斯的，均值为 $\\,u + \\eta\\,g(u)\\,$，协方差为 $\\,2\\eta\\,\\mathcal{C}\\,$，其中 $\\,g(u)=-\\mathcal{C}\\,\\nabla J(u)\\,$，MALA 的接受概率为\n$$\na(u,u') = \\min\\left\\{1,\\ \\exp\\!\\Big(\\Phi(u')-\\Phi(u) + \\log q(u\\mid u') - \\log q(u'\\mid u)\\Big)\\right\\},\n$$\n其中\n$$\n\\log q(u'\\mid u) = -\\frac{1}{4\\eta}\\,\\left\\langle u' - u - \\eta g(u),\\,\\mathcal{C}^{-1}\\left(u' - u - \\eta g(u)\\right)\\right\\rangle_{L^2} + \\text{const}.\n$$\n\n你的任务是：\n- 从 PDE 和分部积分出发，在周期性边界条件下推导 $\\,D\\,$ 及其 $\\,L^2\\,$ 伴随算子 $\\,D^*\\,$ 的显式离散形式。\n- 使用这些形式，在尺寸为 $\\,N\\,$、间距为 $\\,h=1/N\\,$ 的均匀网格上实现 $\\,A\\,$ 和 $\\,A^*\\,$。\n- 在周期性边界条件下，使用 $\\,\\alpha I - \\Delta\\,$ 的离散傅里叶变换对角化来实现 $\\,\\mathcal{C}\\,$, $\\,\\mathcal{C}^{-1}\\,$ 和 $\\,\\mathcal{C}^{1/2}\\,$。使用 $\\,\\kappa=1\\,$。\n- 使用上述接受准则，构建并运行函数空间 MALA 采样器，并为每个测试用例计算在固定迭代次数下的经验接受率。\n\n识别并证明步长 $\\,\\eta\\,$ 的一种缩放方式，该方式能在网格尺寸 $\\,N\\,$ 增加时保持维度无关 (DI) 行为，即在网格加密过程中接受率大致保持稳定。通过在所有网格上使用单一恒定的 $\\,\\eta\\,$ 选择来运行你的采样器，从而经验性地证明这一点。\n\n测试套件的参数：\n- 使用 $\\,y_0(x) = \\sin(2\\pi x) + \\tfrac{1}{2}\\cos(6\\pi x)\\,$；在网格上将其离散化。\n- 设置 $\\,T = 10^{-2}\\,$, $\\,\\sigma = 5\\times 10^{-2}\\,$, $\\,\\alpha = 1\\,$, $\\,\\kappa = 1\\,$，以及先验均值 $\\,m(x)\\equiv 1\\,$.\n- 通过从先验中抽取一个真实值 $\\,u^\\dagger\\,$（振幅较小以保持 $\\,u^\\dagger0\\,$）并设置 $\\,d = A u^\\dagger + \\varepsilon\\,$（其中 $\\,\\varepsilon\\sim \\mathsf{Normal}(0,\\sigma^2 I)\\,$）来生成合成数据 $\\,d\\,$.\n- 使用固定的随机种子以确保可复现性。\n- 从初始化 $\\,u_0=m\\,$ 开始，对所有网格使用相同的恒定 $\\,\\eta\\,$ 运行 MALA 链 $\\,K\\,$ 次迭代。\n\n测试用例：\n- 用例 1: $\\,N=32\\,$.\n- 用例 2: $\\,N=64\\,$.\n- 用例 3: $\\,N=128\\,$.\n\n输出规格：\n- 对于每个测试用例，计算经验接受率，结果为 $\\,[0,1]\\,$ 内的浮点数，四舍五入到六位小数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序排列，例如 $\\,\\left[r_1,r_2,r_3\\right]\\,$.\n\n该程序必须是一个完整的、可运行的脚本，执行所有计算并仅输出指定的最后一行。", "solution": "该问题要求实现并分析一个用于贝叶斯逆问题的函数空间 Metropolis-Adjusted Langevin Algorithm (MALA)，该问题涉及一个一维扩散方程。核心任务是推导和实现必要的离散算子，构建 MALA 采样器，并展示其维度无关的收敛性质。\n\n### 1. 离散化与算子推导\n\n我们在一个包含 $N$ 个点 $x_j = j h$（其中 $j=0, \\dots, N-1$）的均匀网格上操作，网格间距为 $h=1/N$。函数由其在这些网格点上的值构成的向量表示。$L^2$ 内积被离散化为 $\\langle v, w \\rangle_{L^2} \\approx h \\sum_{j=0}^{N-1} v_j w_j$。\n\n**前向算子 $A$ 及其伴随算子 $A^*$**\n\n前向算子定义为 $A u = T D u$，其中 $D u = (\\partial_x y_0) (\\partial_x u) + (\\partial_{xx} y_0) u$。\n为了离散化 $D$，我们对导数 $\\partial_x u$ 使用二阶中心差分格式，这适用于周期性边界条件：\n$$\n(\\partial_x u)_j \\approx \\frac{u_{j+1} - u_{j-1}}{2h}\n$$\n其中索引对 $N$ 取模。令 $\\mathbf{u}$、$\\mathbf{\\partial_x y_0}$ 和 $\\mathbf{\\partial_{xx} y_0}$ 为表示网格上函数的向量。作用于 $\\mathbf{u}$ 的离散算子 $D$ 为：\n$$\n(D \\mathbf{u})_j = (\\mathbf{\\partial_x y_0})_j \\left( \\frac{\\mathbf{u}_{j+1} - \\mathbf{u}_{j-1}}{2h} \\right) + (\\mathbf{\\partial_{xx} y_0})_j \\mathbf{u}_j\n$$\n算子 $A$ 则简单地为 $A = T D$。\n\n为了找到 $L^2$-伴随算子 $D^*$，我们使用定义 $\\langle Dv, w \\rangle_{L^2} = \\langle v, D^*w \\rangle_{L^2}$。在连续层面，使用分部积分和周期性：\n$$\n\\begin{align*}\n\\langle Du, v \\rangle_{L^2} = \\int_0^1 \\left( (\\partial_x y_0)(\\partial_x u) + (\\partial_{xx} y_0) u \\right) v \\, dx \\\\\n= \\int_0^1 (\\partial_x y_0) v (\\partial_x u) \\, dx + \\int_0^1 u (\\partial_{xx} y_0) v \\, dx \\\\\n= \\left[ u (\\partial_x y_0) v \\right]_0^1 - \\int_0^1 u \\, \\partial_x ((\\partial_x y_0) v) \\, dx + \\int_0^1 u (\\partial_{xx} y_0) v \\, dx \\\\\n= -\\int_0^1 u \\left( (\\partial_{xx} y_0) v + (\\partial_x y_0) (\\partial_x v) \\right) \\, dx + \\int_0^1 u (\\partial_{xx} y_0) v \\, dx \\\\\n= \\int_0^1 u \\left( -(\\partial_x y_0) (\\partial_x v) \\right) \\, dx\n\\end{align*}\n$$\n因此，我们确定伴随算子为 $D^* v = -(\\partial_x y_0) (\\partial_x v)$。其离散形式，对 $\\partial_x v$ 使用相同的中心差分格式，为：\n$$\n(D^* \\mathbf{v})_j = -(\\mathbf{\\partial_x y_0})_j \\left( \\frac{\\mathbf{v}_{j+1} - \\mathbf{v}_{j-1}}{2h} \\right)\n$$\n完整前向算子的伴随算子为 $A^* = (TD)^* = T D^*$，因为 $T$ 是一个实标量。\n\n### 2. 傅里叶空间中的先验协方差算子\n\n先验协方差 $\\mathcal{C} = (\\alpha I - \\Delta)^{-\\kappa}$（其中 $\\kappa=1$）定义在周期函数的空间上。这类平移不变算子可由傅里叶基对角化。算子 $\\mathcal{C}$ 及其幂次（$\\mathcal{C}^{-1}$、$\\mathcal{C}^{1/2}$）可以使用快速傅里叶变换 (FFT) 高效地应用。\n\n在周期区间 $[0,1]$ 上，负拉普拉斯算子 $-\\Delta$ 的特征值为 $(2\\pi k)^2$，其中 $k$ 为整数。在一个尺寸为 $N$、间距为 $h$ 的离散网格上，相应的离散波数为 $q_k = 2\\pi k'$，其中 $k' = \\texttt{fftfreq}(N, h)$。$-\\Delta$ 的离散特征值为 $\\lambda_k = q_k^2$。\n\n算子 $\\mathcal{C}^{-1} = \\alpha I - \\Delta$ 在傅里叶空间中是一个乘法算子，其特征值为 $\\mu_k = \\alpha + \\lambda_k = \\alpha + (2\\pi k')^2$。因此，$\\mathcal{C}$、$\\mathcal{C}^{-1}$ 和 $\\mathcal{C}^{1/2}$ 对向量 $\\mathbf{v}$ 的作用计算如下：\n1. 计算离散傅里叶变换：$\\hat{\\mathbf{v}} = \\text{FFT}(\\mathbf{v})$。\n2. 将傅里叶系数 $\\hat{\\mathbf{v}}_k$ 乘以相应的特征值：\n   - 对于 $\\mathcal{C}\\mathbf{v}$：乘以 $\\mu_k^{-\\kappa} = (\\alpha + \\lambda_k)^{-1}$ (因为 $\\kappa=1$)。\n   - 对于 $\\mathcal{C}^{-1}\\mathbf{v}$：乘以 $\\mu_k^{\\kappa} = \\alpha + \\lambda_k$。\n   - 对于 $\\mathcal{C}^{1/2}\\mathbf{v}$：乘以 $\\mu_k^{-\\kappa/2} = (\\alpha + \\lambda_k)^{-1/2}$。\n3. 计算结果的逆离散傅里叶变换。\n\n此过程为这些算子提供了一种无矩阵且高效（$O(N \\log N)$）的实现方式。\n\n### 3. MALA 采样器与接受概率\n\n函数空间 MALA 通过一个预处理的朗之万型更新从当前状态 $u$ 提议一个新状态 $u'$：\n$$\nu' = u + \\eta\\,g(u) + \\sqrt{2\\eta}\\,\\mathcal{C}^{1/2}\\,\\xi\n$$\n其中 $\\eta$ 是步长，$\\xi \\sim \\mathsf{Normal}(0,I)$ 是离散白噪声，且 $g(u) = -\\mathcal{C}\\,\\nabla \\Phi(u) = -\\mathcal{C}(-\\nabla J(u)) = \\mathcal{C}\\,\\nabla J(u)$。问题陈述中有一个微小的符号不一致；提议应该是在增加对数后验 $\\Phi$ 的方向上迈出的一步。我们使用 MALA 的标准形式，即对 $\\Phi$ 进行梯度上升：$u' = u + \\eta\\,\\mathcal{C}\\,\\nabla\\Phi(u) + \\dots = u - \\eta\\,\\mathcal{C}\\,\\nabla J(u) + \\dots$。然而，问题定义了 $g(u)=-\\mathcal{C}\\nabla J(u)$ 并在提议中使用了加号。为与所给公式保持一致，我们将遵循问题陈述：$u' = u + \\eta\\,g(u) + \\dots$。\n\n负对数后验 $J(u)$ 关于 $L^2$ 内积的梯度为：\n$$\n\\nabla J(u) = A^*\\Gamma^{-1}(Au-d) + \\mathcal{C}^{-1}(u-m) = \\frac{1}{\\sigma^2}A^*(Au-d) + \\mathcal{C}^{-1}(u-m)\n$$\n接受概率为 $a(u,u') = \\min\\{1, \\exp(\\log\\alpha)\\}$，其中对数比为：\n$$\n\\log\\alpha = \\Phi(u') - \\Phi(u) + \\log q(u\\mid u') - \\log q(u'\\mid u)\n$$\n使用 $\\Phi(u) = -J(u)$，这变成：\n$$\n\\log\\alpha = J(u) - J(u') + \\log q(u\\mid u') - \\log q(u'\\mid u)\n$$\n对数提议密度由下式给出：\n$$\n\\log q(v \\mid w) = -\\frac{1}{4\\eta}\\,\\left\\langle v - w - \\eta g(w),\\,\\mathcal{C}^{-1}\\left(v - w - \\eta g(w)\\right)\\right\\rangle_{L^2} + \\text{const}\n$$\n为了计算此项，我们计算残差 $r = v - w - \\eta g(w)$，然后评估内积 $\\langle r, \\mathcal{C}^{-1}r \\rangle_{L^2} = \\langle \\mathcal{C}^{-1/2}r, \\mathcal{C}^{-1/2}r \\rangle_{L^2}$，其离散化为 $h \\sum_j (\\mathcal{C}^{-1/2}r)_j^2$。因此，所有分量都使用上面推导的算子进行计算。\n\n### 4. 维度无关步长的合理性证明\n\n标准的高维 MCMC 方法，如随机游走 Metropolis 或未预处理的 MALA，都受维度灾难的影响：为了保持恒定的接受率，步长 $\\eta$ 必须随着状态空间维度 $N$ 的增加而缩小（例如，对于标准 MALA，$\\eta \\propto N^{-1/3}$）。\n\n这里实现的函数空间 MALA 是专门为克服这个问题而设计的。关键在于通过先验协方差算子 $\\mathcal{C}$ 对更新进行预处理。提议由两部分组成：一个漂移项 $\\eta g(u) = -\\eta \\mathcal{C} \\nabla J(u)$ 和一个扩散项 $\\sqrt{2\\eta}\\mathcal{C}^{1/2}\\xi$。这两个部分都由与 $\\mathcal{C}$ 相关的算子进行缩放。这等效于在一个“白化”参数 $v$ 上执行标准 MALA，其中 $u = m + \\mathcal{C}^{1/2} v$，并且 $v$ 的先验是标准高斯分布 $\\mathsf{Normal}(0, I)$。\n\n通过将先验结构融入提议机制，该算法提出的步长对于由先验定义的函数空间是自然的。采样器实际上是在函数空间中进行探索，而不是在高维向量空间中。随着离散化的加密（即 $N$ 增加），只要底层的函数空间问题是适定的，采样器的性能（包括其对固定 $\\eta$ 的接受率）预计将保持稳定。这种维度无关的行为是函数空间 MCMC 方法的一个标志。我们通过对所有网格尺寸（$N=32, 64, 128$）使用单一的恒定步长 $\\eta$ 并观察到经验接受率近似恒定来证明这一点。", "answer": "```python\nimport numpy as np\nfrom numpy.fft import fft, ifft, fftfreq\n\n# This program implements a function-space Metropolis-Adjusted Langevin Algorithm (MALA)\n# to solve a Bayesian inverse problem for the diffusion coefficient in a 1D PDE.\n\ndef solve():\n    \"\"\"\n    Main function to run the MALA simulation for specified test cases and print the results.\n    \"\"\"\n    # Problem parameters\n    T = 1e-2\n    SIGMA = 5e-2\n    ALPHA = 1.0\n    KAPPA = 1.0\n    PRIOR_MEAN_VAL = 1.0\n    K_ITER = 10000  # Number of MCMC iterations\n    ETA = 0.04      # MALA step size, constant across all dimensions\n    SEED = 42\n\n    def y0_func(x):\n        return np.sin(2 * np.pi * x) + 0.5 * np.cos(6 * np.pi * x)\n\n    def dy0dx_func(x):\n        return 2 * np.pi * np.cos(2 * np.pi * x) - 3 * np.pi * np.sin(6 * np.pi * x)\n\n    def d2y0dx2_func(x):\n        return -4 * np.pi**2 * np.sin(2 * np.pi * x) - 18 * np.pi**2 * np.cos(6 * np.pi * x)\n\n    def get_fourier_multipliers(N, h, alpha, kappa):\n        \"\"\"Computes Fourier multipliers for C, C^-1, C^1/2, C^-1/2.\"\"\"\n        fourier_freqs = 2 * np.pi * fftfreq(N, h)\n        lambda_k = fourier_freqs**2  # Eigenvalues of -Delta\n        mu_k = alpha + lambda_k     # Eigenvalues of (alpha*I - Delta)\n        \n        # Regularize to avoid division by zero, although not expected for alpha > 0\n        mu_k[mu_k == 0] = 1e-16\n\n        C_mult = mu_k**(-kappa)\n        C_inv_mult = mu_k**(kappa)\n        C_half_mult = mu_k**(-kappa / 2.0)\n        C_half_inv_mult = mu_k**(kappa / 2.0)\n        return C_mult, C_inv_mult, C_half_mult, C_half_inv_mult\n\n    def apply_fourier_op(v, multipliers):\n        \"\"\"Applies a Fourier-diagonal operator.\"\"\"\n        return np.real(ifft(multipliers * fft(v)))\n\n    def apply_A(u, T, dy0_dx, d2y0_dx2, h):\n        \"\"\"Applies the forward operator A.\"\"\"\n        # Central difference for du/dx with periodic boundary conditions\n        du_dx = (np.roll(u, -1) - np.roll(u, 1)) / (2 * h)\n        D_u = dy0_dx * du_dx + d2y0_dx2 * u\n        return T * D_u\n\n    def apply_A_star(v, T, dy0_dx, h):\n        \"\"\"Applies the adjoint operator A*.\"\"\"\n        # Central difference for dv/dx with periodic boundary conditions\n        dv_dx = (np.roll(v, -1) - np.roll(v, 1)) / (2 * h)\n        D_star_v = -dy0_dx * dv_dx\n        return T * D_star_v\n\n    def compute_J(u, d, m, T, dy0_dx, d2y0_dx2, h, sigma, C_half_inv_mult):\n        \"\"\"Computes the negative log-posterior J(u).\"\"\"\n        Au_minus_d = apply_A(u, T, dy0_dx, d2y0_dx2, h) - d\n        misfit_term = (1.0 / (2.0 * sigma**2)) * h * np.sum(Au_minus_d**2)\n        \n        u_minus_m = u - m\n        C_half_inv_u_minus_m = apply_fourier_op(u_minus_m, C_half_inv_mult)\n        reg_term = 0.5 * h * np.sum(C_half_inv_u_minus_m**2)\n\n        return misfit_term + reg_term\n\n    def run_mala_for_N(N, K, eta):\n        \"\"\"Runs the MALA sampler for a given grid size N.\"\"\"\n        h = 1.0 / N\n        x_grid = np.arange(N) * h\n        \n        dy0_dx = dy0dx_func(x_grid)\n        d2y0_dx2 = d2y0dx2_func(x_grid)\n        m = np.full(N, PRIOR_MEAN_VAL)\n\n        C_mult, C_inv_mult, C_half_mult, C_half_inv_mult = get_fourier_multipliers(N, h, ALPHA, KAPPA)\n\n        rng = np.random.default_rng(SEED)\n        \n        # Generate synthetic data\n        zeta_true = rng.standard_normal(N)\n        u_true = m + apply_fourier_op(zeta_true, C_half_mult)\n        d_true = apply_A(u_true, T, dy0_dx, d2y0_dx2, h)\n        noise = rng.normal(0, SIGMA, N)\n        d = d_true + noise\n\n        # MALA chain initialization\n        u = np.copy(m)\n        accepted_count = 0\n        J_u = compute_J(u, d, m, T, dy0_dx, d2y0_dx2, h, SIGMA, C_half_inv_mult)\n        \n        for _ in range(K):\n            # 1. Compute gradient of J\n            Au_minus_d = apply_A(u, T, dy0_dx, d2y0_dx2, h) - d\n            grad_misfit = apply_A_star(Au_minus_d / SIGMA**2, T, dy0_dx, h)\n            grad_reg = apply_fourier_op(u - m, C_inv_mult)\n            grad_J = grad_misfit + grad_reg\n\n            # 2. Compute proposal drift term g(u)\n            g_u = -apply_fourier_op(grad_J, C_mult)\n\n            # 3. Generate proposal u'\n            xi = rng.standard_normal(N)\n            noise_term = np.sqrt(2 * eta) * apply_fourier_op(xi, C_half_mult)\n            u_proposal = u + eta * g_u + noise_term\n            \n            # 4. Compute acceptance probability\n            J_u_proposal = compute_J(u_proposal, d, m, T, dy0_dx, d2y0_dx2, h, SIGMA, C_half_inv_mult)\n            \n            # log q(u'|u) term\n            log_q_num_term = u_proposal - u - eta * g_u\n            C_half_inv_log_q_num = apply_fourier_op(log_q_num_term, C_half_inv_mult)\n            log_q_u_prime_given_u = -1.0/(4.0*eta) * h * np.sum(C_half_inv_log_q_num**2)\n            \n            # log q(u|u') term requires g(u')\n            Au_prop_minus_d = apply_A(u_proposal, T, dy0_dx, d2y0_dx2, h) - d\n            grad_misfit_prop = apply_A_star(Au_prop_minus_d / SIGMA**2, T, dy0_dx, h)\n            grad_reg_prop = apply_fourier_op(u_proposal - m, C_inv_mult)\n            grad_J_prop = grad_misfit_prop + grad_reg_prop\n            g_u_prime = -apply_fourier_op(grad_J_prop, C_mult)\n            \n            log_q_den_term = u - u_proposal - eta * g_u_prime\n            C_half_inv_log_q_den = apply_fourier_op(log_q_den_term, C_half_inv_mult)\n            log_q_u_given_u_prime = -1.0/(4.0*eta) * h * np.sum(C_half_inv_log_q_den**2)\n            \n            log_alpha = (J_u - J_u_proposal) + log_q_u_given_u_prime - log_q_u_prime_given_u\n            \n            # 5. Accept/Reject\n            if np.log(rng.uniform(0, 1))  log_alpha:\n                u = u_proposal\n                J_u = J_u_proposal\n                accepted_count += 1\n                \n        return accepted_count / K\n\n    test_cases_N = [32, 64, 128]\n    results = []\n    \n    for N_val in test_cases_N:\n        rate = run_mala_for_N(N_val, K_ITER, ETA)\n        results.append(rate)\n        \n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3376373"}]}