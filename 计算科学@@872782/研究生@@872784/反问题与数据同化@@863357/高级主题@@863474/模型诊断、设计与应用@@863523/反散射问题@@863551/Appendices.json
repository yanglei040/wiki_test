{"hands_on_practices": [{"introduction": "逆散射问题的核心在于从散射数据中推断物体的信息。为了建立这种直观联系，我们首先从一个简化的正问题入手。本练习将指导你分析计算在一个重要近似——玻恩近似（Born approximation）——下一个特定形状散射体产生的远场模式。通过这个解析计算，你将亲手揭示散射体的傅里叶变换与其远场模式之间的深刻联系，这是许多线性化反演方法的基础。[@problem_id:3392438]", "problem": "考虑三维空间中的时谐标量声散射，其中总场 $u(x)$ 满足带有散射衬度 $q(x)$ 的自由空间亥姆霍兹方程，\n$$\n\\Delta u(x) + k^{2}\\big(1+q(x)\\big)u(x) = 0,\n$$\n其中波数 $k>0$。入射场为平面波 $u_{\\mathrm{inc}}(x) = \\exp\\big(i k\\, d\\cdot x\\big)$，入射方向为 $d\\in\\mathbb{S}^{2}$，其中 $\\mathbb{S}^{2}$ 表示 $\\mathbb{R}^{3}$ 中的单位球面。散射场 $u^{s}(x) = u(x) - u_{\\mathrm{inc}}(x)$ 满足 Sommerfeld 辐射条件，并具有标准的远场渐近形式\n$$\nu^{s}(x) = \\frac{\\exp\\big(i k |x|\\big)}{|x|}u_{\\infty}(\\hat x,d) + \\mathcal{O}\\!\\left(\\frac{1}{|x|^{2}}\\right),\\quad |x|\\to\\infty,\\quad \\hat x := \\frac{x}{|x|}\\in\\mathbb{S}^{2}.\n$$\n从亥姆霍兹算子的自由空间格林函数、Lippmann–Schwinger 表示法以及一阶玻恩近似（将体积积分中的总场替换为入射平面波）出发，推导球对称高斯形衬度下的玻恩远场 $u_{\\infty}(\\hat x,d)$\n$$\nq(x) \\;=\\; \\alpha\\,\\exp\\!\\left(-\\frac{|x|^{2}}{a^{2}}\\right),\n$$\n其中 $\\alpha\\in\\mathbb{R}$ 和 $a>0$ 为给定常数。然后，将玻恩远场图样的角分辨率建模为散射强度 $|u_{\\infty}(\\theta)|^{2}$ 关于散射角 $\\theta := \\arccos\\!\\big(\\hat x\\cdot d\\big)\\in[0,\\pi]$ 的函数的半峰全宽（FWHM）。求出 FWHM 的闭式解析表达式，记为 $\\Delta\\theta_{\\mathrm{FWHM}}$，并用 $a$ 和 $k$ 明确表示。\n\n你的最终答案必须是精确的闭式表达式。将角宽度 $\\Delta\\theta_{\\mathrm{FWHM}}$ 以弧度表示。如果进行任何小角度近似，请明确地将其作为一个中间步骤说明，但所要求的 $\\Delta\\theta_{\\mathrm{FWHM}}$ 最终表达式必须是精确的（即没有近似）。请按顺序以数对形式提供你的最终答案：玻恩远场 $u_{\\infty}(\\hat x,d)$ 和以弧度表示的 $\\Delta\\theta_{\\mathrm{FWHM}}$。", "solution": "用户希望在玻恩近似下解决一个正散射问题。步骤是首先验证问题，然后推导高斯势的玻恩远场散射振幅，最后计算所得散射强度的半峰全宽（FWHM）。\n\n### 步骤 1：提取已知条件\n- 控制方程：$\\Delta u(x) + k^{2}\\big(1+q(x)\\big)u(x) = 0$\n- 波数：$k>0$\n- 散射衬度：$q(x) = \\alpha\\,\\exp\\!\\left(-\\frac{|x|^{2}}{a^{2}}\\right)$，其中 $\\alpha\\in\\mathbb{R}$ 和 $a>0$。\n- 入射场：$u_{\\mathrm{inc}}(x) = \\exp\\big(i k\\, d\\cdot x\\big)$，方向为 $d\\in\\mathbb{S}^{2}$。\n- 总场：$u(x)$\n- 散射场：$u^{s}(x) = u(x) - u_{\\mathrm{inc}}(x)$\n- 远场渐近式：$u^{s}(x) = \\frac{\\exp\\big(i k |x|\\big)}{|x|}u_{\\infty}(\\hat x,d) + \\mathcal{O}\\!\\left(\\frac{1}{|x|^{2}}\\right)$，当 $|x|\\to\\infty$ 时，其中 $\\hat x = x/|x|\\in\\mathbb{S}^{2}$。\n- 散射角：$\\theta := \\arccos\\!\\big(\\hat x\\cdot d\\big)\\in[0,\\pi]$\n- 要求方法：从 Lippmann–Schwinger 表示法出发，并使用一阶玻恩近似。\n- 要求输出：\n    1. 玻恩远场振幅 $u_{\\infty}(\\hat x,d)$ 的闭式解析表达式。\n    2. 散射强度 $|u_{\\infty}(\\theta)|^{2}$ 的 FWHM 的闭式解析表达式，记为 $\\Delta\\theta_{\\mathrm{FWHM}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于亥姆霍兹方程、Lippmann-Schwinger 方程和玻恩近似，这些都是波散射理论（例如，在声学、电磁学和量子力学中）中的标准、基本概念。使用高斯势是一种常见且具有物理意义的模型。\n- **适定性**：该问题是一个直接计算。它要求在明确定义的近似（玻恩近似）下，针对指定的势，推导一个特定量（远场振幅）及其一个性质（FWHM）。这些步骤在数学上是合理的，并能得到唯一解。\n- **客观性**：该问题以精确、客观的数学语言陈述，没有歧义或主观因素。\n- **完整性和一致性**：提供了所有必要的方程、定义和参数。这些定义是标准的，彼此之间以及与散射理论的既有文献都相一致。\n\n### 步骤 3：结论与行动\n该问题是有效的。这是散射理论中的一个标准练习。我将继续进行解答。\n\n### 玻恩远场振幅的推导\n时谐声波方程可以改写为非齐次亥姆霍兹方程：\n$$\n\\Delta u(x) + k^{2}u(x) = -k^{2}q(x)u(x)\n$$\n使用亥姆霍兹算子的自由空间格林函数 $G(x,y) = \\frac{\\exp(ik|x-y|)}{4\\pi|x-y|}$，该方程可以表示为积分形式，即 Lippmann-Schwinger 方程：\n$$\nu(x) = u_{\\mathrm{inc}}(x) + \\int_{\\mathbb{R}^3} G(x,y) \\left(-k^2 q(y) u(y)\\right) d^3y\n$$\n因此，散射场 $u^s(x) = u(x) - u_{\\mathrm{inc}}(x)$ 由下式给出：\n$$\nu^s(x) = -k^2 \\int_{\\mathbb{R}^3} \\frac{\\exp(ik|x-y|)}{4\\pi|x-y|} q(y) u(y) d^3y\n$$\n一阶玻恩近似在于将积分内未知的总场 $u(y)$ 替换为已知的入射场 $u_{\\mathrm{inc}}(y) = \\exp(ik d\\cdot y)$。玻恩近似下的散射场 $u^s_B(x)$ 为：\n$$\nu^s_B(x) = -k^2 \\int_{\\mathbb{R}^3} \\frac{\\exp(ik|x-y|)}{4\\pi|x-y|} q(y) \\exp(ik d\\cdot y) d^3y\n$$\n为了求得远场振幅 $u_\\infty(\\hat x, d)$，我们考虑极限 $|x|\\to\\infty$。在此极限下，我们使用近似：\n$$\n|x-y| \\approx |x| - \\hat x \\cdot y \\quad \\text{和} \\quad \\frac{1}{|x-y|} \\approx \\frac{1}{|x|}\n$$\n将这些近似代入 $u^s_B(x)$ 的积分中：\n$$\nu^s_B(x) \\approx -k^2 \\int_{\\mathbb{R}^3} \\frac{\\exp(ik(|x| - \\hat x \\cdot y))}{4\\pi|x|} q(y) \\exp(ik d\\cdot y) d^3y\n$$\n$$\nu^s_B(x) \\approx \\frac{\\exp(ik|x|)}{|x|} \\left[ -\\frac{k^2}{4\\pi} \\int_{\\mathbb{R}^3} q(y) \\exp(-ik\\hat x \\cdot y) \\exp(ik d \\cdot y) d^3y \\right]\n$$\n通过与给定的渐近形式 $u^s(x) = \\frac{\\exp(ik|x|)}{|x|}u_{\\infty}(\\hat x,d) + \\mathcal{O}(|x|^{-2})$ 比较，我们确定玻恩远场振幅为：\n$$\nu_{\\infty}(\\hat x,d) = -\\frac{k^2}{4\\pi} \\int_{\\mathbb{R}^3} q(y) \\exp\\big(ik(d - \\hat x)\\cdot y\\big) d^3y\n$$\n此表达式表明，远场振幅与散射衬度 $q(y)$ 在空间频率矢量 $k(\\hat x - d)$ 处的 3D 傅里叶变换成正比。\n现在，我们代入给定的高斯衬度 $q(y) = \\alpha \\exp(-|y|^2/a^2)$：\n$$\nu_{\\infty}(\\hat x,d) = -\\frac{\\alpha k^2}{4\\pi} \\int_{\\mathbb{R}^3} \\exp\\left(-\\frac{|y|^2}{a^2}\\right) \\exp\\big(i k(d - \\hat x)\\cdot y\\big) d^3y\n$$\n该积分为标准高斯积分，即高斯函数的 3D 傅里叶变换。高斯函数傅里叶变换的通用公式为：\n$$\n\\int_{\\mathbb{R}^3} \\exp(-b|y|^2) \\exp(i v \\cdot y) d^3y = \\left(\\frac{\\pi}{b}\\right)^{3/2} \\exp\\left(-\\frac{|v|^2}{4b}\\right)\n$$\n在我们的情况中，$b = 1/a^2$ 且矢量 $v = k(d-\\hat x)$。因此，积分的计算结果为：\n$$\n\\int_{\\mathbb{R}^3} \\exp\\left(-\\frac{|y|^2}{a^2}\\right) \\exp\\big(i k(d - \\hat x)\\cdot y\\big) d^3y = \\left(\\frac{\\pi}{1/a^2}\\right)^{3/2} \\exp\\left(-\\frac{|k(d-\\hat x)|^2}{4(1/a^2)}\\right) = (\\pi a^2)^{3/2} \\exp\\left(-\\frac{k^2 a^2 |d-\\hat x|^2}{4}\\right)\n$$\n我们来化简 $|d-\\hat x|^2$ 这一项。由于 $d$ 和 $\\hat x$ 是单位矢量，\n$$\n|d-\\hat x|^2 = (d-\\hat x)\\cdot(d-\\hat x) = |d|^2 + |\\hat x|^2 - 2(d\\cdot\\hat x) = 1 + 1 - 2(d\\cdot \\hat x) = 2(1 - d\\cdot\\hat x)\n$$\n将此结果代回指数项中：\n$$\n\\exp\\left(-\\frac{k^2 a^2}{4} \\cdot 2(1-d\\cdot\\hat x)\\right) = \\exp\\left(-\\frac{k^2 a^2}{2}(1-d\\cdot\\hat x)\\right)\n$$\n现在，将积分结果代回 $u_\\infty(\\hat x, d)$ 的表达式中：\n$$\nu_{\\infty}(\\hat x,d) = -\\frac{\\alpha k^2}{4\\pi} \\left[ \\pi^{3/2} a^3 \\exp\\left(-\\frac{k^2 a^2}{2}(1-d\\cdot\\hat x)\\right) \\right]\n$$\n简化前置因子，得到最终答案的第一部分：\n$$\nu_{\\infty}(\\hat x,d) = -\\frac{\\alpha k^2 a^3 \\sqrt{\\pi}}{4} \\exp\\left(-\\frac{k^2 a^2}{2}(1 - \\hat x \\cdot d)\\right)\n$$\n\n### FWHM 的推导\n散射强度由 $I = |u_{\\infty}(\\hat x,d)|^2$ 给出。由于对 $\\hat x$ 和 $d$ 的依赖仅通过它们的点积体现，我们可以将强度写成散射角 $\\theta = \\arccos(\\hat x \\cdot d)$ 的函数：\n$$\nI(\\theta) = \\left| -\\frac{\\alpha k^2 a^3 \\sqrt{\\pi}}{4} \\exp\\left(-\\frac{k^2 a^2}{2}(1 - \\cos\\theta)\\right) \\right|^2\n$$\n$$\nI(\\theta) = \\frac{\\alpha^2 k^4 a^6 \\pi}{16} \\exp\\left(-k^2 a^2(1 - \\cos\\theta)\\right)\n$$\n最大强度 $I_{\\mathrm{max}}$ 出现在指数的自变量取最小值时，即 $1-\\cos\\theta$ 最小。这发生在 $\\theta=0$（前向散射），此时 $\\cos(0)=1$。\n$$\nI_{\\mathrm{max}} = I(0) = \\frac{\\alpha^2 k^4 a^6 \\pi}{16}\n$$\n半峰全宽（FWHM），记为 $\\Delta\\theta_{\\mathrm{FWHM}}$，是强度分布在其最大值一半处的宽度。强度分布 $I(\\theta)$ 是关于 $\\theta$ 的偶函数，对称于 $\\theta=0$。我们找到角度 $\\theta^*>0$ 使得强度为其最大值的一半，即 $I(\\theta^*) = I_{\\mathrm{max}}/2$。那么 FWHM 由 $\\Delta\\theta_{\\mathrm{FWHM}} = 2\\theta^*$ 给出。\n条件 $I(\\theta^*) = I_{\\mathrm{max}}/2$ 给出：\n$$\n\\frac{\\alpha^2 k^4 a^6 \\pi}{16} \\exp\\left(-k^2 a^2(1 - \\cos\\theta^*)\\right) = \\frac{1}{2} \\frac{\\alpha^2 k^4 a^6 \\pi}{16}\n$$\n$$\n\\exp\\left(-k^2 a^2(1 - \\cos\\theta^*)\\right) = \\frac{1}{2}\n$$\n对两边取自然对数：\n$$\n-k^2 a^2(1 - \\cos\\theta^*) = \\ln\\left(\\frac{1}{2}\\right) = -\\ln(2)\n$$\n$$\n1 - \\cos\\theta^* = \\frac{\\ln(2)}{k^2 a^2}\n$$\n解出 $\\cos\\theta^*$：\n$$\n\\cos\\theta^* = 1 - \\frac{\\ln(2)}{k^2 a^2}\n$$\n半宽角 $\\theta^*$ 则为：\n$$\n\\theta^* = \\arccos\\left(1 - \\frac{\\ln(2)}{k^2 a^2}\\right)\n$$\n这个表达式会产生一个实数角度 $\\theta^*$，前提是 $\\arccos$ 的自变量在 $[-1, 1]$ 范围内，这要求 $k^2 a^2 \\ge \\ln(2)/2$。假设此条件成立，则 FWHM 为：\n$$\n\\Delta\\theta_{\\mathrm{FWHM}} = 2\\theta^* = 2\\arccos\\left(1 - \\frac{\\ln(2)}{k^2 a^2}\\right)\n$$\n这是最终答案的第二部分。", "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{\\alpha k^{2} a^{3} \\sqrt{\\pi}}{4} \\exp\\left(-\\frac{k^{2} a^{2}}{2}(1 - \\hat x \\cdot d)\\right) \\quad 2\\arccos\\left(1 - \\frac{\\ln(2)}{k^{2}a^{2}}\\right) \\end{pmatrix}}\n$$", "id": "3392438"}, {"introduction": "虽然线性化近似（如玻恩近似）为我们提供了宝贵的解析洞察力，但它们的有效性是有限的。在实际应用中，判断何时可以使用这些简化模型至关重要。本练习要求你设计一个数值实验，通过计算李普曼-施温格方程（Lippmann-Schwinger equation）的残差，来定量地比较和区分玻恩近似与另一种重要的线性化方法——雷托夫近似（Rytov approximation）的适用范围。这项实践将使你掌握验证物理模型有效性的关键技能，并深入理解不同近似在何种散射机制下表现更优。[@problem_id:3392387]", "problem": "考虑由三维空间中具有紧支集相对衬度的亥姆霍兹方程所描述的时间谐波标量波。令 $q: \\mathbb{R}^3 \\to \\mathbb{C}$ 为衬度，令 $k > 0$ 为波数。总场 $u(x)$ 遵循 $(\\Delta + k^2(1 + q(x))) u(x) = 0$，入射平面波为 $u^{\\mathrm{i}}(x) = e^{\\mathrm{i} k d \\cdot x}$，其中单位入射方向 $d \\in \\mathbb{S}^2$。散射场满足 Lippmann–Schwinger 积分方程\n$$\nu(x) = u^{\\mathrm{i}}(x) + k^2 \\int_{\\mathbb{R}^3} G_k(x,y) \\, q(y) \\, u(y) \\, \\mathrm{d}y,\n$$\n其中 $G_k(x,y) = \\dfrac{e^{\\mathrm{i}k |x-y|}}{4\\pi |x-y|}$ 是三维自由空间格林函数。远场模式由下式给出\n$$\nu^\\infty(\\hat{x}, d) = \\frac{k^2}{4\\pi} \\int_{\\mathbb{R}^3} e^{-\\mathrm{i} k \\hat{x} \\cdot y} \\, q(y) \\, u(y) \\, \\mathrm{d}y, \\quad \\hat{x} \\in \\mathbb{S}^2.\n$$\n两种经典的一阶线性化是玻恩近似和雷托夫近似。玻恩近似在积分中用 $u^{\\mathrm{i}}(y)$ 替换 $u(y)$。雷托夫近似将 $u(x)$ 表示为 $u(x) = u^{\\mathrm{i}}(x) e^{\\psi(x)}$ 并对 $\\psi(x)$ 进行线性化，得到满足以下条件的一阶相位 $\\psi_1(x)$\n$$\n\\psi_1(x) \\approx k^2 \\int_{\\mathbb{R}^3} G_k(x,y) \\, q(y) \\, e^{\\mathrm{i} k d \\cdot (y - x)} \\, \\mathrm{d}y,\n$$\n以及雷托夫场 $u^{\\mathrm{R}}(x) \\approx u^{\\mathrm{i}}(x) \\, e^{\\psi_1(x)}$。\n\n你的任务是设计并实现一个数值实验，以区分在哪些区域中，对于每种线性化，远场模式 $u^\\infty(\\hat{x},d)$ 中的二阶误差 $O(\\|q\\|^2)$ 可以忽略不计，并使用 Lippmann–Schwinger 残差来验证预测。实验必须在三维环境中进行，其中 $q(x)$ 紧支集于以原点为中心、半径为 $R$ 的球内。所有量均为无量纲。\n\n基本依据和推导要求：\n- 从所述的亥姆霍兹方程和 Lippmann–Schwinger 积分方程出发。使用所提供的格林函数和远场表示。\n- 定义一个无量纲小量预测器，用于估计二阶项 $O(\\|q\\|^2)$ 在远场中何时可以忽略。使用从 Lippmann–Schwinger 方程的算子形式推导出的基于范数的界来论证该预测器。你必须在性质上论证并以量化方式实现该预测器。\n- 对于在点 $\\{x_i\\}$ 处离散化的候选内场 $v(x)$，将 Lippmann–Schwinger 残差定义为\n$$\n\\mathcal{R}[v] = \\frac{\\left\\|v - u^{\\mathrm{i}} - k^2 \\int G_k(\\cdot,y) q(y) v(y) \\, \\mathrm{d}y \\right\\|_{L^2(\\Omega)}}{\\|v\\|_{L^2(\\Omega)}},\n$$\n并使用你的离散求积法对其进行近似。\n- 计算并比较玻恩和雷托夫在正向方向 $\\hat{x} = d$ 的远场振幅预测。将它们与通过求解离散化的 Lippmann–Schwinger 积分方程得到的数值计算参考解 $u(x)$ 进行验证。\n- 提供并使用一个容差 $\\varepsilon$ 来判断二阶误差是否可以忽略，并报告残差和远场相对误差。\n\n离散化与算法：\n- 使用间距为 $h$ 的立方网格对半径为 $R$ 的支集球进行离散化，保留位于球内 $\\|x\\| \\le R$ 的网格点。对保留的点使用统一的体积权重 $\\Delta V = h^3$。通过在对角线上将核设置为零来排除对角线奇点。\n- 对 $i \\ne j$ 组装稠密格林函数矩阵 $G_{ij} = \\dfrac{e^{\\mathrm{i} k |x_i - x_j|}}{4\\pi |x_i - x_j|}$，并令 $G_{ii} = 0$。\n- 令衬度为高斯函数 $q(x) = a \\exp\\!\\left(-\\frac{\\|x\\|^2}{2\\sigma^2}\\right)$，其振幅为 $a$，宽度为 $\\sigma$。\n- 求解离散的 Lippmann–Schwinger 方程以获得内场 $u$，\n$$\nu = u^{\\mathrm{i}} + k^2 \\, \\Delta V \\, G \\, (q \\odot u),\n$$\n作为一个线性系统 $(I - k^2 \\Delta V \\, G \\, \\mathrm{diag}(q)) u = u^{\\mathrm{i}}$。\n- 计算玻恩内场 $u^{\\mathrm{B}} = u^{\\mathrm{i}} + k^2 \\Delta V \\, G \\, (q \\odot u^{\\mathrm{i}})$。\n- 通过下式计算一阶雷托夫相位 $\\psi_1$\n$$\n\\psi_{1,i} = k^2 \\Delta V \\sum_{j} G_{ij} \\, q_j \\, e^{\\mathrm{i} k \\, d \\cdot (x_j - x_i)},\n$$\n然后计算 $u^{\\mathrm{R}}_i = u^{\\mathrm{i}}_i \\, e^{\\psi_{1,i}}$。\n- 通过离散求积法计算正向方向 $\\hat{x} = d$ 的远场振幅，\n$$\nu^\\infty(d,d) \\approx \\frac{k^2}{4\\pi} \\, \\Delta V \\sum_j e^{-\\mathrm{i} k \\, d \\cdot x_j} \\, q_j \\, u_j,\n$$\n并对 $u^{\\mathrm{B}}$ 和 $u^{\\mathrm{R}}$ 进行类似计算。\n\n预测与验证：\n- 定义小量预测器 $\\mu = k^2 R^2 \\|q\\|_{\\infty}$ 并报告其值。论证当 $\\mu \\ll 1$ 时，二阶项在远场中可以忽略。\n- 通过使用网格和权重离散化 $L^2$ 范数来定义残差 $\\mathcal{R}[u^{\\mathrm{B}}]$ 和 $\\mathcal{R}[u^{\\mathrm{R}}]$。\n- 定义远场相对误差，对于从求解的 $u$ 得到的参考远场 $u^\\infty_{\\mathrm{ref}}$，\n$$\ne_{\\mathrm{B}} = \\frac{|u^\\infty_{\\mathrm{B}} - u^\\infty_{\\mathrm{ref}}|}{\\max(|u^\\infty_{\\mathrm{ref}}|, \\delta)}, \\quad e_{\\mathrm{R}} = \\frac{|u^\\infty_{\\mathrm{R}} - u^\\infty_{\\mathrm{ref}}|}{\\max(|u^\\infty_{\\mathrm{ref}}|, \\delta)},\n$$\n其中有一个小的 $\\delta$ 以避免除以零。\n- 使用一个容差 $\\varepsilon$，如果残差和远场相对误差均低于 $\\varepsilon$，则判定二阶误差可以忽略。\n\n测试套件：\n- 在所有测试中使用 $d = (1,0,0)$ 和 $\\hat{x} = d$。令 $R = 0.25$ 和 $h = R/2$，以便从球内的 $5 \\times 5 \\times 5$ 网格中采样点。统一使用体积权重 $\\Delta V = h^3$。\n- 令容差为 $\\varepsilon = 0.05$ 和 $\\delta = 10^{-12}$。\n- 考虑四个具有参数 $(k, a, \\sigma)$ 的测试用例：\n    1. $k = 5$, $a = 0.02$, $\\sigma = 0.10$。\n    2. $k = 10$, $a = 0.10$, $\\sigma = 0.10$。\n    3. $k = 20$, $a = 0.50$, $\\sigma = 0.08$。\n    4. $k = 2$, $a = 0.30$, $\\sigma = 0.10$。\n\n答案规范和最终输出格式：\n- 对于每个测试用例，计算并返回一个包含六个值的列表：$[\\mu, \\mathcal{R}[u^{\\mathrm{B}}], \\mathcal{R}[u^{\\mathrm{R}}], e_{\\mathrm{B}}, e_{\\mathrm{R}}, b]$，其中如果 $e_{\\mathrm{R}} < e_{\\mathrm{B}}$，则 $b$ 为整数 $1$，否则为 $0$。\n- 你的程序应生成单行输出，其中包含四个测试用例的结果，格式为由列表组成的逗号分隔列表，并用方括号括起，例如 $[[\\text{case1}],[\\text{case2}],[\\text{case3}],[\\text{case4}]]$。", "solution": "### 小量预测器的论证\n\nLippmann-Schwinger 方程，$u(x) = u^{\\mathrm{i}}(x) + k^2 \\int_{\\Omega} G_k(x,y) q(y) u(y) \\mathrm{d}y$，其中 $\\Omega$ 是衬度 $q$ 的支集，可以写成算子形式 $u = u^{\\mathrm{i}} + \\mathcal{T}u$。这里，算子 $\\mathcal{T}$ 定义为 $(\\mathcal{T}v)(x) = k^2 \\int_{\\Omega} G_k(x,y) q(y) v(y) \\mathrm{d}y$。该方程的形式解为 $u = (I - \\mathcal{T})^{-1} u^{\\mathrm{i}}$。\n\n当算子范数 $\\|\\mathcal{T}\\|$ 小于 1 时，我们可以将此解展开为 Neumann 级数：\n$$\nu = \\sum_{n=0}^{\\infty} \\mathcal{T}^n u^{\\mathrm{i}} = u^{\\mathrm{i}} + \\mathcal{T} u^{\\mathrm{i}} + \\mathcal{T}^2 u^{\\mathrm{i}} + \\dots\n$$\n玻恩近似 $u^{\\mathrm{B}} = u^{\\mathrm{i}} + \\mathcal{T} u^{\\mathrm{i}}$ 仅保留了一阶散射项。因此，该近似的误差由二阶及更高阶项决定，从 $\\mathcal{T}^2 u^{\\mathrm{i}}$ 开始。这些项的大小，以及近似的准确性，取决于 $\\mathcal{T}$ 的范数。\n\n为了估计 $\\|\\mathcal{T}\\|$，我们考虑其在 $L^\\infty(\\Omega)$ 范数下对函数 $v$ 的作用：\n$$\n\\|\\mathcal{T}v\\|_{\\infty} = \\sup_{x \\in \\Omega} \\left| k^2 \\int_{\\Omega} G_k(x,y) q(y) v(y) \\mathrm{d}y \\right| \\le k^2 \\|q\\|_{\\infty} \\|v\\|_{\\infty} \\sup_{x \\in \\Omega} \\int_{\\Omega} |G_k(x,y)| \\mathrm{d}y\n$$\n其中 $|G_k(x,y)| = (4\\pi |x-y|)^{-1}$。区域 $\\Omega$ 是一个半径为 $R$ 的球。积分 $\\int_{\\Omega} |x-y|^{-1} \\mathrm{d}y$ 在 $x$ 位于球心时达到最大值，其值为 $2\\pi R^2$。因此，\n$$\n\\sup_{x \\in \\Omega} \\int_{\\Omega} |G_k(x,y)| \\mathrm{d}y = \\sup_{x \\in \\Omega} \\frac{1}{4\\pi} \\int_{\\Omega} \\frac{1}{|x-y|} \\mathrm{d}y \\le \\frac{1}{4\\pi} (2\\pi R^2) = \\frac{1}{2} R^2\n$$\n这导致界 $\\|\\mathcal{T}\\|_{\\infty} \\le \\frac{1}{2} k^2 R^2 \\|q\\|_{\\infty}$。无量纲量 $\\mu = k^2 R^2 \\|q\\|_{\\infty}$ 因此可作为 $\\|\\mathcal{T}\\|$ 的数量级估计。如果 $\\mu \\ll 1$，Neumann 级数会快速收敛，而与 $\\|\\mathcal{T}\\|^2 \\approx \\mu^2$ 成正比的二阶误差项是可忽略的。这证明了 $\\mu$ 作为一阶近似有效性预测器的合理性。\n\n### 数值实现策略\n\n该数值实验通过在散射体支集内的网格点上离散化连续方程来进行。\n\n1.  **离散化**：使用间距为 $h=0.125$ 的立方网格上的点对半径为 $R=0.25$ 的支集球进行离散化，只保留球内的 $N$ 个点 $\\{x_i\\}$。积分算子被替换为带有统一体积元 $\\Delta V = h^3$ 的矩阵-向量乘积。\n\n2.  **参考解**：离散化的 Lippmann-Schwinger 方程变成了一个关于内场值向量 $\\mathbf{u} = [u(x_1), \\dots, u(x_N)]^T$ 的线性系统：\n    $$\n    (I - k^2 \\Delta V G Q) \\mathbf{u} = \\mathbf{u}^{\\mathrm{i}}\n    $$\n    这里，$I$ 是单位矩阵，$G$ 是 $N \\times N$ 矩阵，其元素为 $G_{ij} = G_k(x_i, x_j)$（对于 $i \\neq j$，否则为 $0$），$Q = \\mathrm{diag}(q(x_1), \\dots, q(x_N))$，$\\mathbf{u}^{\\mathrm{i}}$ 是入射场值的向量。求解此系统以获得参考场 $\\mathbf{u}_{\\mathrm{ref}}$。\n\n3.  **近似解**：\n    -   玻恩内场直接计算：$\\mathbf{u}_{\\mathrm{B}} = \\mathbf{u}^{\\mathrm{i}} + k^2 \\Delta V G Q \\mathbf{u}^{\\mathrm{i}}$。\n    -   雷托夫相位 $\\psi_1(x) \\approx u^{\\mathrm{s}}_{\\mathrm{B}}(x) / u^{\\mathrm{i}}(x)$，其中 $u^{\\mathrm{s}}_{\\mathrm{B}}$ 是玻恩场的散射部分。在离散形式下，相位向量为 $\\boldsymbol{\\psi}_1 = (k^2 \\Delta V G Q \\mathbf{u}^{\\mathrm{i}}) \\oslash \\mathbf{u}^{\\mathrm{i}}$，其中 $\\oslash$ 表示逐元素除法。雷托夫场则为 $\\mathbf{u}_{\\mathrm{R}} = \\mathbf{u}^{\\mathrm{i}} \\odot \\exp(\\boldsymbol{\\psi}_1)$，其中 $\\odot$ 为逐元素乘法。\n\n4.  **远场和度量**：\n    -   正向方向 $\\hat{x}=d$ 的远场振幅通过离散求和计算：\n        $$\n        u^\\infty(d,d) \\approx \\frac{k^2}{4\\pi} \\Delta V \\sum_{j=1}^{N} e^{-\\mathrm{i} k d \\cdot x_j} q_j u_j = \\frac{k^2}{4\\pi} \\Delta V (\\mathbf{u}^{\\mathrm{i}})^{\\dagger} Q \\mathbf{u}\n        $$\n        此公式应用于 $\\mathbf{u}_{\\mathrm{ref}}$、$\\mathbf{u}_{\\mathrm{B}}$ 和 $\\mathbf{u}_{\\mathrm{R}}$ 以获得 $u^\\infty_{\\mathrm{ref}}$、$u^\\infty_{\\mathrm{B}}$ 和 $u^\\infty_{\\mathrm{R}}$。\n    -   相对误差 $e_{\\mathrm{B}}$ 和 $e_{\\mathrm{R}}$ 使用提供的公式与 $u^\\infty_{\\mathrm{ref}}$ 进行计算。\n    -   对于近似场 $\\mathbf{v}$（$\\mathbf{u}_{\\mathrm{B}}$ 或 $\\mathbf{u}_{\\mathrm{R}}$），Lippmann-Schwinger 残差计算如下：\n        $$\n        \\mathcal{R}[\\mathbf{v}] = \\frac{\\|\\mathbf{v} - \\mathbf{u}^{\\mathrm{i}} - k^2 \\Delta V G Q \\mathbf{v}\\|_2}{\\|\\mathbf{v}\\|_2}\n        $$\n        使用欧几里得范数 $(\\|\\cdot\\|_2)$，因为来自离散 $L^2$ 范数的常数因子 $\\sqrt{\\Delta V}$ 在比率中被抵消了。\n\n对于每个测试用例，计算这些量并编译成指定的输出格式。", "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for all test cases.\n    \"\"\"\n    \n    # Define fixed parameters for the experiment\n    R = 0.25\n    h = R / 2.0\n    d_vec = np.array([1.0, 0.0, 0.0])\n    delta = 1e-12\n    dV = h**3\n\n    # Generate grid points within the sphere of radius R\n    coords = []\n    indices_1d = np.arange(-2, 3) \n    for i in indices_1d:\n        for j in indices_1d:\n            for l in indices_1d:\n                if i**2 + j**2 + l**2 = 4:\n                    coords.append([i * h, j * h, l * h])\n    x_pts = np.array(coords)\n    N = x_pts.shape[0]\n\n    # Pre-compute distance matrix and incident field structure\n    dist_matrix = cdist(x_pts, x_pts)\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        (5.0, 0.02, 0.10),\n        (10.0, 0.10, 0.10),\n        (20.0, 0.50, 0.08),\n        (2.0, 0.30, 0.10),\n    ]\n\n    all_results = []\n    for k, a, sigma in test_cases:\n        # 1. Construct case-specific vectors and matrices\n        u_inc = np.exp(1j * k * (x_pts @ d_vec))\n        q_vec = a * np.exp(-np.sum(x_pts**2, axis=1) / (2 * sigma**2))\n        \n        # Green's function matrix\n        G = np.zeros((N, N), dtype=np.complex128)\n        mask = dist_matrix > 0\n        G[mask] = np.exp(1j * k * dist_matrix[mask]) / (4 * np.pi * dist_matrix[mask])\n        \n        # 2. Reference solution (solving the full Lippmann-Schwinger system)\n        Q_diag = np.diag(q_vec)\n        system_matrix = np.eye(N) - (k**2 * dV) * (G @ Q_diag)\n        u_ref = np.linalg.solve(system_matrix, u_inc)\n        \n        # 3. Approximate solutions (Born and Rytov)\n        u_born_s = (k**2 * dV) * (G @ (q_vec * u_inc))\n        u_born = u_inc + u_born_s\n        \n        psi1 = u_born_s / u_inc\n        u_rytv = u_inc * np.exp(psi1)\n        \n        # 4. Far-field amplitudes in the forward direction\n        u_inc_conj = np.conj(u_inc)\n        common_factor = (k**2 / (4 * np.pi)) * dV\n        \n        u_inf_ref = common_factor * np.sum(u_inc_conj * q_vec * u_ref)\n        u_inf_born = common_factor * np.sum(u_inc_conj * q_vec * u_born)\n        u_inf_rytv = common_factor * np.sum(u_inc_conj * q_vec * u_rytv)\n        \n        # 5. Compute validation metrics\n        # Smallness predictor\n        mu = k**2 * R**2 * np.abs(a)\n        \n        # Lippmann-Schwinger residuals (using vector 2-norm)\n        res_num_born = u_born - u_inc - (k**2 * dV) * G @ (q_vec * u_born)\n        residual_born = np.linalg.norm(res_num_born) / np.linalg.norm(u_born)\n        \n        res_num_rytv = u_rytv - u_inc - (k**2 * dV) * G @ (q_vec * u_rytv)\n        residual_rytv = np.linalg.norm(res_num_rytv) / np.linalg.norm(u_rytv)\n        \n        # Far-field relative errors\n        denom = max(np.abs(u_inf_ref), delta)\n        e_born = np.abs(u_inf_born - u_inf_ref) / denom\n        e_rytv = np.abs(u_inf_rytv - u_inf_ref) / denom\n        \n        # Comparison flag\n        b = 1 if e_rytv  e_born else 0\n        \n        all_results.append([mu, residual_born, residual_rytv, e_born, e_rytv, float(b)])\n\n    # Final print statement in the exact required format\n    case_strings = [f\"[{','.join(f'{v:.8f}' for v in r)}]\" for r in all_results]\n    print(f\"[{','.join(case_strings)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3392387"}, {"introduction": "在许多现实场景中，散射现象具有强非线性，简单的线性化近似不再适用。此时，我们必须直面并求解完整的非线性逆问题。本练习是一个综合性的计算项目，旨在引导你设计并实现一个现代混合反演流程，它结合了用于初步定位散射体支撑集的快速定性方法，以及用于精确重建物体细节的定量优化方法（如全变分正则化）。通过这项实践，你将学习如何解决由非线性带来的不适定性与局部极小值等挑战，并体会到先进的初始化策略对提升反演成功率的巨大价值。[@problem_id:3392423]", "problem": "考虑一维空间中标量频域波的反散射问题。设空间域为闭区间 $\\left[0,1\\right]$，令 $N$ 为网格节点数，均匀间距为 $h = \\dfrac{1}{N-1}$。在 $x=0$ 和 $x=1$ 处施加齐次 Dirichlet 边界条件。记 $M = N-2$ 为内部节点数，这些节点是状态变量的自由度。\n\n正演模型由线性椭圆偏微分方程给出\n$$\n- \\dfrac{d^2 u(x)}{dx^2} + k^2 \\left( 1 + q(x) \\right) u(x) = f(x), \\quad x \\in (0,1),\n$$\n其中 $u(0)=0$ 和 $u(1)=0$， $k  0$ 是波数，$q(x)$ 是未知的散射势（无量纲对比度），$u(x)$ 是总场，$f(x)$ 代表源。使用内部节点上的标准二阶中心有限差分将 $- \\dfrac{d^2}{dx^2}$ 离散化为对称正定三对角矩阵 $\\mathbf{L} \\in \\mathbb{R}^{M \\times M}$，其对角线元素为 $\\dfrac{2}{h^2}$，次对角线元素为 $\\dfrac{-1}{h^2}$。令 $\\mathbf{q} \\in \\mathbb{R}^{M}$ 为离散化的对比度，令 $\\mathbf{A}(\\mathbf{q}) = \\mathbf{L} + k^2 \\operatorname{diag}(\\mathbf{1} + \\mathbf{q})$ 为离散正演算子。对于给定的源向量 $\\mathbf{f} \\in \\mathbb{R}^{M}$，离散场满足\n$$\n\\mathbf{A}(\\mathbf{q}) \\mathbf{u} = \\mathbf{f}.\n$$\n假设有 $S$ 个源配置 $\\left\\{ \\mathbf{f}_j \\right\\}_{j=1}^S$，产生解 $\\left\\{ \\mathbf{u}_j \\right\\}_{j=1}^S$。令 $\\mathbf{P} \\in \\mathbb{R}^{R \\times M}$ 为限制（采样）算子，它在 $R$ 个接收器节点处提取场值。对于一个固定但未知的真实对比度 $\\mathbf{q}^{\\mathrm{true}}$，测量数据为 $\\left\\{ \\mathbf{y}_j \\right\\}_{j=1}^S$，满足\n$$\n\\mathbf{y}_j = \\mathbf{P} \\mathbf{u}_j^{\\mathrm{true}} + \\boldsymbol{\\eta}_j, \\quad \\text{其中} \\quad \\mathbf{A}(\\mathbf{q}^{\\mathrm{true}}) \\mathbf{u}_j^{\\mathrm{true}} = \\mathbf{f}_j,\n$$\n且 $\\boldsymbol{\\eta}_j$ 是加性测量噪声。\n\n你的任务是设计、实现并测试一个混合定性-定量反演流程，以从 $\\left\\{ \\mathbf{y}_j \\right\\}_{j=1}^S$ 重建 $\\mathbf{q}$：\n\n- 步骤 $1$（定性支撑集检测）：使用从背景场导出的采样指示函数来估计 $\\mathbf{q}^{\\mathrm{true}}$ 的支撑集。令 $\\mathbf{u}_{0,j}$ 为方程 $\\mathbf{A}(\\mathbf{0}) \\mathbf{u}_{0,j} = \\mathbf{f}_j$ 的解。定义残差 $\\mathbf{r}_j = \\mathbf{y}_j - \\mathbf{P}\\mathbf{u}_{0,j}$。令 $\\mathbf{v}_j$ 为伴随背景问题 $\\mathbf{A}(\\mathbf{0}) \\mathbf{v}_j = \\mathbf{P}^{\\top} \\mathbf{r}_j$ 的解。定义逐点指示函数 \n$$\n\\mathbf{s} = \\sum_{j=1}^{S} \\left| \\mathbf{u}_{0,j} \\odot \\mathbf{v}_j \\right| \\in \\mathbb{R}^M,\n$$\n其中 $\\odot$ 表示逐元素乘积，绝对值也是逐元素应用的。将 $\\mathbf{s}$ 除以其最大值进行归一化，使其值落在 $\\left[0,1\\right]$ 区间内。通过在给定水平 $\\tau \\in (0,1)$ 进行阈值化来选择支撑掩码 $\\mathbf{m} \\in \\left\\{0,1\\right\\}^M$，即如果 $\\mathbf{s}_i \\ge \\tau \\max(\\mathbf{s})$，则设 $\\mathbf{m}_i = 1$，否则设 $\\mathbf{m}_i = 0$。\n\n- 步骤 $2$（使用平滑总变差（TV）正则化的定量反演）：求解无约束优化问题\n$$\n\\min_{\\mathbf{q} \\in \\mathbb{R}^M, \\, \\mathbf{q} \\ge \\mathbf{0}} \\; \\Phi(\\mathbf{q}) \\equiv \\dfrac{1}{2} \\sum_{j=1}^S \\left\\| \\mathbf{P}\\mathbf{u}_j(\\mathbf{q}) - \\mathbf{y}_j \\right\\|_2^2 \\;+\\; \\alpha \\sum_{i=1}^{M-1} \\sqrt{\\left( \\mathbf{q}_{i+1} - \\mathbf{q}_i \\right)^2 + \\epsilon},\n$$\n其中 $\\alpha  0$ 是正则化权重，$\\epsilon  0$ 是平滑参数。对于每个源 $j$，状态 $\\mathbf{u}_j(\\mathbf{q})$ 满足 $\\mathbf{A}(\\mathbf{q}) \\mathbf{u}_j(\\mathbf{q}) = \\mathbf{f}_j$。使用基于梯度的优化方法，其中数据失配项的梯度使用伴随状态法计算，平滑 TV 项使用其精确梯度。\n\n定义两种初始化策略：\n\n- 基准：随机初始化 $\\mathbf{q}^{(0)}_{\\mathrm{rand}}$，其分量从指定 $a_{\\max}  0$ 的均匀分布 $\\left[0, a_{\\max}\\right]$ 中采样。\n\n- 支撑集种子：定性初始化 $\\mathbf{q}^{(0)}_{\\mathrm{sup}} = a^\\star \\mathbf{m}$，其中 $a^\\star \\in \\left[0, a_{\\max}\\right]$ 是通过在有限多个点上进行简单的离散线搜索，以最小化沿射线 $\\left\\{ a \\mathbf{m} : a \\in \\left[0, a_{\\max}\\right] \\right\\}$ 的数据失配来选择的，然后加上一个小的随机扰动以避免确定性。\n\n按如下方式量化经验吸引盆的改进。对于每个测试用例，运行 $T$ 次独立试验。在每次试验中，从 $\\mathbf{q}^{(0)}_{\\mathrm{rand}}$ 开始运行定量反演固定次数的迭代，如果相对重建误差 \n$$\n\\mathrm{rel\\_err} = \\dfrac{\\left\\| \\widehat{\\mathbf{q}} - \\mathbf{q}^{\\mathrm{true}} \\right\\|_2}{\\left\\| \\mathbf{q}^{\\mathrm{true}} \\right\\|_2}\n$$\n小于或等于预定容差 $\\rho$，则将结果分类为成功。从受扰动的支撑集种子初始化开始重复 $T$ 次试验，并使用相同的标准对成功进行分类。经验吸引盆增益定义为\n$$\n\\mathrm{gain} = \\left(\\dfrac{\\text{成功的支撑集种子试验次数}}{T}\\right) - \\left(\\dfrac{\\text{成功的基准试验次数}}{T}\\right).\n$$\n\n你的程序必须实现上述混合流程，并为以下测试套件产生增益。所有数值均为无量纲。\n\n测试套件规格：\n\n- 案例 $\\mathbf{1}$（理想情况）：\n  - $N = 80$, $M = 78$, $k = 25$。\n  - 源：$S = 3$ 个，位于内部索引 $\\left\\{2, 6, 10\\right\\}$ 处（从 $0$ 到 $M-1$ 计数）。\n  - 接收器：$R = 3$ 个，位于内部索引 $\\left\\{M-6, M-4, M-2\\right\\}$ 处。\n  - 真实对比度：$\\mathbf{q}^{\\mathrm{true}}$ 在两个区间 $[i_1, i_2]$ 和 $[i_3, i_4]$ 上等于 $a_{\\mathrm{true}} = 1.0$，其中 $i_1 = \\lfloor 0.30 M \\rfloor$, $i_2 = \\lfloor 0.40 M \\rfloor$, $i_3 = \\lfloor 0.65 M \\rfloor$, $i_4 = \\lfloor 0.75 M \\rfloor$，在其他地方为零。\n  - 噪声：加性高斯噪声，对于每个源，标准差等于 $\\sigma \\left\\| \\mathbf{y} \\right\\|_2$，其中 $\\sigma = 0.01$。\n  - 定性阈值 $\\tau = 0.60$。\n  - TV 参数：$\\alpha = 0.02$, $\\epsilon = 10^{-6}$。\n  - 优化：步长 $\\delta = 10^{-3}$，迭代次数 $K = 60$，每步之后进行投影 $\\mathbf{q} \\ge \\mathbf{0}}$。\n  - 初始化界限：$a_{\\max} = 1.5$，线搜索样本数 $L = 8$。\n  - 试验次数：$T = 6$，成功容差 $\\rho = 0.25$。\n\n- 案例 $\\mathbf{2}$（有限照明，较高噪声）：\n  - $N = 80$, $M = 78$, $k = 25$。\n  - 源：$S = 1$ 个，位于内部索引 $\\left\\{2\\right\\}$ 处。\n  - 接收器：$R = 3$ 个，位于内部索引 $\\left\\{M-6, M-4, M-2\\right\\}$ 处。\n  - 真实对比度：与案例 $\\mathbf{1}$ 相同的双区间结构，其中 $a_{\\mathrm{true}} = 1.0$。\n  - 噪声：$\\sigma = 0.02$。\n  - 定性阈值 $\\tau = 0.60$。\n  - TV 参数：$\\alpha = 0.03$, $\\epsilon = 10^{-6}$。\n  - 优化：$\\delta = 10^{-3}$, $K = 60$。\n  - 初始化界限：$a_{\\max} = 1.5$, $L = 8$。\n  - 试验次数：$T = 6$，成功容差 $\\rho = 0.30$。\n\n- 案例 $\\mathbf{3}$（低对比度）：\n  - $N = 80$, $M = 78$, $k = 25$。\n  - 源：$S = 3$ 个，位于内部索引 $\\left\\{2, 6, 10\\right\\}$ 处。\n  - 接收器：$R = 3$ 个，位于内部索引 $\\left\\{M-6, M-4, M-2\\right\\}$ 处。\n  - 真实对比度：单个区间 $[i_1, i_2]$，其中 $i_1 = \\lfloor 0.40 M \\rfloor$, $i_2 = \\lfloor 0.55 M \\rfloor$，振幅 $a_{\\mathrm{true}} = 0.40$，其他地方为零。\n  - 噪声：$\\sigma = 0.01$。\n  - 定性阈值 $\\tau = 0.50$。\n  - TV 参数：$\\alpha = 0.02$, $\\epsilon = 10^{-6}$。\n  - 优化：$\\delta = 10^{-3}$, $K = 60$。\n  - 初始化界限：$a_{\\max} = 0.8$, $L = 8$。\n  - 试验次数：$T = 6$，成功容差 $\\rho = 0.35$。\n\n- 案例 $\\mathbf{4}$（较高波数）：\n  - $N = 80$, $M = 78$, $k = 35$。\n  - 源：$S = 3$ 个，位于内部索引 $\\left\\{2, 6, 10\\right\\}$ 处。\n  - 接收器：$R = 3$ 个，位于内部索引 $\\left\\{M-6, M-4, M-2\\right\\}$ 处。\n  - 真实对比度：与案例 $\\mathbf{1}$ 相同，其中 $a_{\\mathrm{true}} = 1.0$。\n  - 噪声：$\\sigma = 0.015$。\n  - 定性阈值 $\\tau = 0.60$。\n  - TV 参数：$\\alpha = 0.03$, $\\epsilon = 10^{-6}$。\n  - 优化：$\\delta = 10^{-3}$, $K = 60$。\n  - 初始化界限：$a_{\\max} = 1.5$, $L = 8$。\n  - 试验次数：$T = 6$，成功容差 $\\rho = 0.30$。\n\n实现要求：\n\n- 使用离散伴随状态法计算数据失配的梯度。如果 $\\mathbf{r}_j = \\mathbf{P}\\mathbf{u}_j(\\mathbf{q}) - \\mathbf{y}_j$ 且伴随变量 $\\mathbf{p}_j$ 求解 $\\mathbf{A}(\\mathbf{q}) \\mathbf{p}_j = \\mathbf{P}^{\\top} \\mathbf{r}_j$，则数据失配梯度的贡献为 \n$$\n\\nabla_{\\mathbf{q}} \\left( \\dfrac{1}{2} \\sum_{j=1}^S \\left\\| \\mathbf{P}\\mathbf{u}_j(\\mathbf{q}) - \\mathbf{y}_j \\right\\|_2^2 \\right) \\;=\\; - k^2 \\sum_{j=1}^S \\left( \\mathbf{u}_j(\\mathbf{q}) \\odot \\mathbf{p}_j \\right).\n$$\n- 平滑总变差的梯度为\n$$\n\\nabla_{\\mathbf{q}} \\left( \\sum_{i=1}^{M-1} \\sqrt{\\left( \\mathbf{q}_{i+1} - \\mathbf{q}_i \\right)^2 + \\epsilon} \\right) \\;=\\; \\mathbf{D}^{\\top} \\left( \\dfrac{\\mathbf{D}\\mathbf{q}}{\\sqrt{(\\mathbf{D}\\mathbf{q})^2 + \\epsilon}} \\right),\n$$\n其中 $\\mathbf{D} \\in \\mathbb{R}^{(M-1)\\times M}$ 是前向差分算子，除法和平方根是逐元素应用的。实现相应的离散向量公式，而無需显式地构造 $\\mathbf{D}$。\n\n- 使用投影梯度下降法，步长为 $\\delta$，每次迭代后逐分量投影到非负象限，共 $K$ 次迭代。\n\n- 定性初始化振幅 $a^\\star$ 必须通过在 $\\left[0, a_{\\max}\\right]$ 中的 $L$ 个均匀间隔值上进行離散線搜索来选择，以最小化沿 $a \\mathbf{m}$ 的数据失配。\n\n最终输出格式：\n\n- 你的程序应生成单行输出，其中包含案例 $\\mathbf{1}$ 到 $\\mathbf{4}$ 的增益，按顺序排列，格式为方括号括起来的逗号分隔列表（例如，$\\left[ g_1, g_2, g_3, g_4 \\right]$）。每个 $g_i$ 必须是标准浮点表示法的十进制数。\n\n- 不提供外部输入；所有参数必须按上述规定设置，并且程序必须是自包含和可复现的。", "solution": "我们从离散正演模型、偏微分方程约束问题的梯度计算的伴随状态法以及平滑总变差正则化的基本定义中推导出算法。\n\n离散化和正演算子：在均匀内部网格上，齐次 Dirichlet 边界条件下的一维负拉普拉斯算子被离散化为三对角矩阵 $\\mathbf{L} \\in \\mathbb{R}^{M\\times M}$，其对角线元素为 $\\dfrac{2}{h^2}$，第一亚对角线和第一超对角线元素为 $\\dfrac{-1}{h^2}$。包含空间变化对比度 $\\mathbf{q}$ 的亥姆霍兹型离散算子为\n$$\n\\mathbf{A}(\\mathbf{q}) = \\mathbf{L} + k^2 \\operatorname{diag}(\\mathbf{1} + \\mathbf{q}).\n$$\n给定一组源 $\\left\\{\\mathbf{f}_j\\right\\}_{j=1}^S$，状态变量 $\\left\\{\\mathbf{u}_j\\right\\}_{j=1}^S$ 通过求解 $\\mathbf{A}(\\mathbf{q}) \\mathbf{u}_j = \\mathbf{f}_j$ 获得。由限制矩阵 $\\mathbf{P}$ 采样的测量值的数据失配为\n$$\n\\Phi_{\\mathrm{mis}}(\\mathbf{q}) = \\dfrac{1}{2} \\sum_{j=1}^S \\left\\| \\mathbf{P} \\mathbf{u}_j(\\mathbf{q}) - \\mathbf{y}_j \\right\\|_2^2.\n$$\n\n伴随状态梯度推导：我们通过拉格朗日方法推导 $\\Phi_{\\mathrm{mis}}(\\mathbf{q})$ 关于 $\\mathbf{q}$ 的梯度。引入拉格朗日乘子 $\\left\\{\\boldsymbol{\\lambda}_j\\right\\}_{j=1}^S$ 并定义拉格朗日函数\n$$\n\\mathcal{L}(\\mathbf{q}, \\{ \\mathbf{u}_j \\}, \\{ \\boldsymbol{\\lambda}_j \\}) = \\dfrac{1}{2}\\sum_{j=1}^S \\left\\| \\mathbf{P}\\mathbf{u}_j - \\mathbf{y}_j \\right\\|_2^2 + \\sum_{j=1}^S \\boldsymbol{\\lambda}_j^{\\top} \\left( \\mathbf{A}(\\mathbf{q})\\mathbf{u}_j - \\mathbf{f}_j \\right).\n$$\n关于 $\\mathbf{u}_j$ 的平稳性条件得出伴随方程：\n$$\n\\dfrac{\\partial \\mathcal{L}}{\\partial \\mathbf{u}_j} = \\mathbf{P}^{\\top} \\left( \\mathbf{P}\\mathbf{u}_j - \\mathbf{y}_j \\right) + \\mathbf{A}(\\mathbf{q})^{\\top} \\boldsymbol{\\lambda}_j = \\mathbf{0}.\n$$\n因为 $\\mathbf{A}(\\mathbf{q})$ 是对称的，这变为 $\\mathbf{A}(\\mathbf{q}) \\boldsymbol{\\lambda}_j = - \\mathbf{P}^{\\top} \\left( \\mathbf{P}\\mathbf{u}_j - \\mathbf{y}_j \\right)$。定义伴随变量 $\\mathbf{p}_j = -\\boldsymbol{\\lambda}_j$，它们满足\n$$\n\\mathbf{A}(\\mathbf{q}) \\mathbf{p}_j = \\mathbf{P}^{\\top} \\left( \\mathbf{P}\\mathbf{u}_j - \\mathbf{y}_j \\right) \\equiv \\mathbf{P}^{\\top} \\mathbf{r}_j,\n$$\n其中 $\\mathbf{r}_j$ 是残差。拉格朗日函数关于 $\\mathbf{q}$ 的导数利用了 $\\dfrac{\\partial \\mathbf{A}}{\\partial \\mathbf{q}_i} = k^2 \\mathbf{E}_i$ 这一事实，其中 $\\mathbf{E}_i$ 是在 $(i,i)$ 位置为 $1$ 其他位置为零的对角矩阵。因此，\n$$\n\\dfrac{\\partial \\mathcal{L}}{\\partial \\mathbf{q}_i} = \\sum_{j=1}^S \\boldsymbol{\\lambda}_j^{\\top} k^2 \\mathbf{E}_i \\mathbf{u}_j = k^2 \\sum_{j=1}^S \\boldsymbol{\\lambda}_j(i) \\, \\mathbf{u}_j(i) = - k^2 \\sum_{j=1}^S \\mathbf{p}_j(i) \\, \\mathbf{u}_j(i).\n$$\n收集所有分量，数据失配的梯度为\n$$\n\\nabla \\Phi_{\\mathrm{mis}}(\\mathbf{q}) = - k^2 \\sum_{j=1}^S \\left( \\mathbf{u}_j(\\mathbf{q}) \\odot \\mathbf{p}_j(\\mathbf{q}) \\right).\n$$\n\n平滑总变差梯度：平滑总变差为\n$$\n\\mathrm{TV}_{\\epsilon}(\\mathbf{q}) = \\sum_{i=1}^{M-1} \\sqrt{\\left( \\mathbf{q}_{i+1} - \\mathbf{q}_i \\right)^2 + \\epsilon}.\n$$\n令 $\\mathbf{w} \\in \\mathbb{R}^{M-1}$ 为归一化的前向差分，其分量为\n$$\n\\mathbf{w}_i = \\dfrac{\\mathbf{q}_{i+1} - \\mathbf{q}_i}{\\sqrt{\\left( \\mathbf{q}_{i+1} - \\mathbf{q}_i \\right)^2 + \\epsilon}}, \\quad i = 1, \\dots, M-1.\n$$\n$\\mathrm{TV}_{\\epsilon}(\\mathbf{q})$ 的梯度则是 $\\mathbf{w}$ 的负离散散度，以向量形式表示为\n$$\n\\nabla \\mathrm{TV}_{\\epsilon}(\\mathbf{q}) = \\mathbf{D}^{\\top} \\mathbf{w},\n$$\n其中 $\\mathbf{D}$ 是前向差分算子。在坐标系中，这变为\n$$\n\\left[ \\nabla \\mathrm{TV}_{\\epsilon}(\\mathbf{q}) \\right]_1 = - \\mathbf{w}_1, \\quad \\left[ \\nabla \\mathrm{TV}_{\\epsilon}(\\mathbf{q}) \\right]_i = \\mathbf{w}_{i-1} - \\mathbf{w}_i \\; \\text{ for } \\; 2 \\le i \\le M-1, \\quad \\left[ \\nabla \\mathrm{TV}_{\\epsilon}(\\mathbf{q}) \\right]_M = \\mathbf{w}_{M-1}.\n$$\n\n投影梯度下降法：总目标函数为 $\\Phi(\\mathbf{q}) = \\Phi_{\\mathrm{mis}}(\\mathbf{q}) + \\alpha \\mathrm{TV}_{\\epsilon}(\\mathbf{q})$。给定步长 $\\delta  0$，执行迭代\n$$\n\\mathbf{q}^{(k+1)} = \\Pi_{\\ge 0} \\left( \\mathbf{q}^{(k)} - \\delta \\left[ \\nabla \\Phi_{\\mathrm{mis}}(\\mathbf{q}^{(k)}) + \\alpha \\nabla \\mathrm{TV}_{\\epsilon}(\\mathbf{q}^{(k)}) \\right] \\right), \\quad k = 0, 1, \\dots, K-1,\n$$\n其中 $\\Pi_{\\ge 0}$ 表示逐分量投影到非负象限。步长 $\\delta$ 按规定固定；$\\mathbf{A}(\\mathbf{q})$ 的对称性和正定性确保了正演和伴随求解的适定性。\n\n定性采样指示函数：为实现计算成本较低的支撑集检测，使用背景解和由残差驱动的伴随解。对于每个源 $j$，通过求解 $\\mathbf{A}(\\mathbf{0}) \\mathbf{u}_{0,j} = \\mathbf{f}_j$ 计算背景场 $\\mathbf{u}_{0,j}$。令 $\\mathbf{r}_j = \\mathbf{y}_j - \\mathbf{P}\\mathbf{u}_{0,j}$。求解 $\\mathbf{A}(\\mathbf{0}) \\mathbf{v}_j = \\mathbf{P}^{\\top} \\mathbf{r}_j$。然后构造指示函数\n$$\n\\mathbf{s} = \\sum_{j=1}^S \\left| \\mathbf{u}_{0,j} \\odot \\mathbf{v}_j \\right|.\n$$\n该指示函数受到扰动的互易性和拓扑敏感性的启发：乘积 $\\mathbf{u}_{0,j}(x) \\mathbf{v}_j(x)$ 关系到失配函数对点 $x$ 处局部对比度变化的敏感度。在 $\\tau$ 处对归一化的 $\\mathbf{s}$ 进行阈值化处理，得到支撑掩码 $\\mathbf{m}$。\n\n初始化方案：\n\n- 基准随机：从 $\\mathcal{U}(0, a_{\\max})$ 中逐分量抽取 $\\mathbf{q}^{(0)}_{\\mathrm{rand}}$。这在没有先验支撑集信息的情况下探索了初始猜测的空间。\n\n- 支撑集种子：给定 $\\mathbf{m}$，考虑单参数族 $\\left\\{ a \\mathbf{m} : a \\in [0, a_{\\max}] \\right\\}$。对于 $L$ 个均匀候选值 $a_{\\ell} \\in [0, a_{\\max}]$，计算数据失配 $\\Phi_{\\mathrm{mis}}(a_{\\ell} \\mathbf{m})$ 并选择 $a^\\star = \\arg\\min_{\\ell} \\Phi_{\\mathrm{mis}}(a_{\\ell} \\mathbf{m})$。设 $\\mathbf{q}^{(0)}_{\\mathrm{sup}} = a^\\star \\mathbf{m} + \\boldsymbol{\\xi}$，其中 $\\boldsymbol{\\xi}$ 是一个小的非负随机扰动以避免确定性，然后投影到非负值。\n\n经验吸引盆增益：对于每种情况，使用 $\\mathbf{q}^{\\mathrm{true}}$ 和固定的噪声统计数据生成一次带噪数据 $\\left\\{ \\mathbf{y}_j \\right\\}$。然后，分别从随机初始化和受扰动的支撑集种子初始化（使用相同的数据）开始，运行 $T$ 次独立的定量反演试验。计算相对误差不超过容差 $\\rho$ 的试验次数。增益是成功率的差异。这量化了支撑集检测如何在给定的计算预算内提高收敛到可接受重建结果的概率。\n\n每种情况的算法结构：\n\n- 构建 $\\mathbf{L}$，选择源和接收器索引，形成 $\\mathbf{P}$。\n\n- 根据案例规格定义 $\\mathbf{q}^{\\mathrm{true}}$。\n\n- 生成带噪数据：对于每个 $j$，求解 $\\mathbf{A}(\\mathbf{q}^{\\mathrm{true}})\\mathbf{u}_j^{\\mathrm{true}} = \\mathbf{f}_j$，设置 $\\mathbf{y}_j = \\mathbf{P}\\mathbf{u}_j^{\\mathrm{true}} + \\boldsymbol{\\eta}_j$，其中每个 $\\boldsymbol{\\eta}_j$ 是标准差为 $\\sigma \\left\\| \\mathbf{y}_j \\right\\|_2$ 的高斯噪声。\n\n- 计算背景场 $\\mathbf{u}_{0,j}$ 和残差 $\\mathbf{r}_j$；求解伴随问题以形成 $\\mathbf{s}$；在 $\\tau$ 处进行阈值化以获得 $\\mathbf{m}$，必要时使用回退机制以确保支撑集非空。\n\n- 通过对 $L$ 个候选值进行离散线搜索确定 $a^\\star$；定义 $\\mathbf{q}^{(0)}_{\\mathrm{sup}}$。\n\n- 对于基准组和支撑集种子组中的每次试验，使用步长 $\\delta$ 以及 TV 参数 $\\alpha$ 和 $\\epsilon$ 运行 $K$ 次投影梯度下降迭代；每步之后投影到 $\\mathbf{q} \\ge \\mathbf{0}$。\n\n- 计算最终估计的相对误差，如果误差不超过 $\\rho$，则计为成功。\n\n- 计算增益，即成功率之差。\n\n输出是包含案例 $\\mathbf{1}$ 到 $\\mathbf{4}$ 增益的单行文本，格式为方括号括起来的逗号分隔列表。此流程通过离散正演模型遵循了基础物理原理，采用了基于原理的伴随状态梯度，结合了保持边缘的平滑总变差正则化，并使用基于互易性的定性指示函数来增强初始化并经验性地擴大吸引盆。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_laplacian(M, h):\n    # Discrete -d2/dx2 with Dirichlet BCs on interior (size M)\n    main = (2.0 / (h * h)) * np.ones(M)\n    off = (-1.0 / (h * h)) * np.ones(M - 1)\n    L = diags([off, main, off], offsets=[-1, 0, 1], format='csr')\n    return L\n\ndef build_A(L, k, q):\n    # A(q) = L + k^2 * diag(1 + q)\n    M = L.shape[0]\n    diag_add = (k * k) * (1.0 + q)\n    A = L + diags(diag_add, offsets=0, format='csr')\n    return A\n\ndef solve_forward(A, f):\n    return spsolve(A, f)\n\ndef make_P(M, recv_idx):\n    # P extracts entries at recv_idx\n    R = len(recv_idx)\n    data = np.ones(R)\n    rows = np.arange(R)\n    cols = np.array(recv_idx, dtype=int)\n    P = csr_matrix((data, (rows, cols)), shape=(R, M))\n    return P\n\ndef tv_grad_1d(q, eps):\n    # Gradient of smoothed 1D TV: D^T ( D q / sqrt((D q)^2 + eps) )\n    dq = q[1:] - q[:-1]  # size M-1\n    denom = np.sqrt(dq * dq + eps)\n    w = dq / denom\n    M = q.size\n    g = np.zeros_like(q)\n    # [0] = -w[0]\n    g[0] = -w[0]\n    # middle entries\n    g[1:-1] = w[:-1] - w[1:]\n    # last\n    g[-1] = w[-1]\n    return g\n\ndef grad_data(q, L, k, sources, P, y_list):\n    # Adjoint-state gradient of data misfit\n    A = build_A(L, k, q)\n    M = L.shape[0]\n    grad = np.zeros(M)\n    for f, y in zip(sources, y_list):\n        u = solve_forward(A, f)\n        r = P.dot(u) - y\n        rhs_adj = P.T.dot(r)\n        p = solve_forward(A, rhs_adj)\n        grad += -(k * k) * (u * p)\n    return grad\n\ndef projected_gradient_descent(q0, L, k, sources, P, y_list, alpha, eps, step, iters):\n    q = q0.copy()\n    for _ in range(iters):\n        g_data = grad_data(q, L, k, sources, P, y_list)\n        g_tv = tv_grad_1d(q, eps)\n        q = q - step * (g_data + alpha * g_tv)\n        q[q  0.0] = 0.0\n    return q\n\ndef qualitative_support(L, k, sources, P, y_list, tau):\n    # Background fields and adjoints for indicator\n    M = L.shape[0]\n    A0 = build_A(L, k, np.zeros(M))\n    s = np.zeros(M)\n    for f, y in zip(sources, y_list):\n        u0 = solve_forward(A0, f)\n        r = P.dot(u0) - y\n        rhs_adj = P.T.dot(r)\n        v = solve_forward(A0, rhs_adj)\n        s += np.abs(u0 * v)\n    maxs = np.max(s) if np.max(s) > 0 else 1.0\n    s_norm = s / maxs\n    mask = s_norm >= tau\n    # Fallback: ensure nonempty support\n    if not np.any(mask):\n        m = max(1, M // 10)\n        idx = np.argsort(s_norm)[-m:]\n        mask = np.zeros(M, dtype=bool)\n        mask[idx] = True\n    return mask.astype(float)\n\ndef line_search_amplitude(mask, L, k, sources, P, y_list, amax, Lsamp):\n    # Discrete line search over a in [0, amax] to minimize data misfit\n    best_a = 0.0\n    best_val = np.inf\n    a_vals = np.linspace(0.0, amax, Lsamp)\n    for a in a_vals:\n        q = a * mask\n        A = build_A(L, k, q)\n        mis = 0.0\n        for f, y in zip(sources, y_list):\n            u = solve_forward(A, f)\n            r = P.dot(u) - y\n            mis += 0.5 * float(r.T @ r)\n        if mis = best_val:\n            best_val = mis\n            best_a = a\n    return best_a\n\ndef generate_true_q(M, case_id):\n    q_true = np.zeros(M)\n    if case_id == 1 or case_id == 2 or case_id == 4:\n        i1 = int(np.floor(0.30 * M))\n        i2 = int(np.floor(0.40 * M))\n        i3 = int(np.floor(0.65 * M))\n        i4 = int(np.floor(0.75 * M))\n        q_true[i1:i2] = 1.0\n        q_true[i3:i4] = 1.0\n    elif case_id == 3:\n        i1 = int(np.floor(0.40 * M))\n        i2 = int(np.floor(0.55 * M))\n        a_true = 0.40\n        q_true[i1:i2] = a_true\n    return q_true\n\ndef setup_case(case):\n    N = case['N']\n    M = N - 2\n    h = 1.0 / (N - 1)\n    L = build_laplacian(M, h)\n    k = case['k']\n    \n    src_idx = case['src_idx']\n    sources = []\n    for si in src_idx:\n        f = np.zeros(M)\n        f[si] = 1.0\n        sources.append(f)\n        \n    rec_idx = case['rec_idx']\n    P = make_P(M, rec_idx)\n    \n    q_true = generate_true_q(M, case['case_id'])\n    \n    y_list = []\n    A_true = build_A(L, k, q_true)\n    for i, f in enumerate(sources):\n        u_true = solve_forward(A_true, f)\n        y = P.dot(u_true)\n        sigma = case['sigma']\n        rng = np.random.default_rng(case['noise_seed'] + i)\n        noise = rng.normal(loc=0.0, scale=sigma * np.linalg.norm(y), size=y.shape)\n        y_noisy = y + noise\n        y_list.append(y_noisy)\n    return L, k, sources, P, y_list, q_true\n\ndef run_trials(case):\n    L, k, sources, P, y_list, q_true = setup_case(case)\n    M = L.shape[0]\n    \n    mask = qualitative_support(L, k, sources, P, y_list, case['tau'])\n    a_star = line_search_amplitude(mask, L, k, sources, P, y_list, case['amax'], case['Lsamp'])\n    \n    T = case['T']\n    step = case['step']\n    iters = case['iters']\n    alpha = case['alpha']\n    eps = case['eps']\n    tol = case['tol']\n    norm_q_true = np.linalg.norm(q_true)\n    if norm_q_true == 0: norm_q_true = 1.0\n\n    # Baseline trials\n    rng_base = np.random.default_rng(case['base_seed'])\n    success_base = 0\n    for _ in range(T):\n        q0 = rng_base.uniform(low=0.0, high=case['amax'], size=M)\n        qhat = projected_gradient_descent(q0, L, k, sources, P, y_list, alpha, eps, step, iters)\n        rel_err = np.linalg.norm(qhat - q_true) / norm_q_true\n        if rel_err = tol:\n            success_base += 1\n            \n    # Support-seeded trials\n    rng_sup = np.random.default_rng(case['sup_seed'])\n    success_sup = 0\n    for _ in range(T):\n        perturb_scale = 0.05 * max(1e-8, a_star)\n        perturb = np.abs(rng_sup.normal(loc=0.0, scale=perturb_scale, size=M))\n        q0s = a_star * mask + perturb\n        q0s[q0s  0] = 0.0 # Ensure non-negativity\n        qhat = projected_gradient_descent(q0s, L, k, sources, P, y_list, alpha, eps, step, iters)\n        rel_err = np.linalg.norm(qhat - q_true) / norm_q_true\n        if rel_err = tol:\n            success_sup += 1\n            \n    gain = (success_sup / T) - (success_base / T)\n    return gain\n\ndef solve():\n    N = 80\n    M = N - 2\n    rec_idx = [M - 6, M - 4, M - 2]\n    cases = [\n        {'case_id': 1, 'N': 80, 'k': 25, 'src_idx': [2, 6, 10], 'rec_idx': rec_idx, 'sigma': 0.01, 'tau': 0.60, 'alpha': 0.02, 'eps': 1e-6, 'step': 1e-3, 'iters': 60, 'amax': 1.5, 'Lsamp': 8, 'T': 6, 'tol': 0.25, 'noise_seed': 123, 'base_seed': 1001, 'sup_seed': 2001},\n        {'case_id': 2, 'N': 80, 'k': 25, 'src_idx': [2], 'rec_idx': rec_idx, 'sigma': 0.02, 'tau': 0.60, 'alpha': 0.03, 'eps': 1e-6, 'step': 1e-3, 'iters': 60, 'amax': 1.5, 'Lsamp': 8, 'T': 6, 'tol': 0.30, 'noise_seed': 223, 'base_seed': 1002, 'sup_seed': 2002},\n        {'case_id': 3, 'N': 80, 'k': 25, 'src_idx': [2, 6, 10], 'rec_idx': rec_idx, 'sigma': 0.01, 'tau': 0.50, 'alpha': 0.02, 'eps': 1e-6, 'step': 1e-3, 'iters': 60, 'amax': 0.8, 'Lsamp': 8, 'T': 6, 'tol': 0.35, 'noise_seed': 323, 'base_seed': 1003, 'sup_seed': 2003},\n        {'case_id': 4, 'N': 80, 'k': 35, 'src_idx': [2, 6, 10], 'rec_idx': rec_idx, 'sigma': 0.015, 'tau': 0.60, 'alpha': 0.03, 'eps': 1e-6, 'step': 1e-3, 'iters': 60, 'amax': 1.5, 'Lsamp': 8, 'T': 6, 'tol': 0.30, 'noise_seed': 423, 'base_seed': 1004, 'sup_seed': 2004},\n    ]\n\n    results = [run_trials(case) for case in cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3392423"}]}