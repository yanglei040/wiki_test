{"hands_on_practices": [{"introduction": "为了解决反问题（即从测量数据重建内部参数），我们通常使用基于梯度的迭代方法。这些方法依赖于雅可比矩阵（或称灵敏度矩阵），它描述了未知参数的微小变化如何影响测量结果。本练习介绍了一种强大的数值验证技术——泰勒余项检验，用于验证计算出的雅可比矩阵的正确性 ([@problem_id:3378201])。完成此练习后，您将能确保灵敏度分析的准确性，这是着手解决完整反问题之前的关键一步。", "problem": "考虑在单位正方形域上采用齐次狄利克雷边界条件的稳态漫射光学断层成像（DOT）模型，该模型处于扩散近似下。其控制偏微分方程为标量椭圆扩散问题\n$$\n- \\nabla \\cdot \\left( D \\nabla u \\right) + \\mu_a(\\mathbf{r}) \\, u(\\mathbf{r}) = q(\\mathbf{r}) \\quad \\text{in } \\Omega = (0,1)^2, \\quad u|_{\\partial \\Omega} = 0,\n$$\n其中 $D$ 是恒定扩散系数，$\\mu_a(\\mathbf{r})$ 是空间变化的吸收系数，$u$ 是光子注量（无量纲），$q$ 是一个源项。所有量均为无量纲。\n\n我们在每边有 $N$ 个节点的均匀笛卡尔网格上使用有限差分离散化，并在边界节点上强制施加齐次狄利克雷边界条件。设内部网格有 $(N-2)^2$ 个节点。令 $L \\in \\mathbb{R}^{n \\times n}$ 表示内部网格上的标准5点有限差分格式的离散拉普拉斯算子，网格间距为 $h = 1/(N-1)$，因此 $L$ 是对称正定的（对于狄利克雷情况）。设恒定扩散系数 $D=1$。令 $x \\in \\mathbb{R}^K$ 是一个低维参数矢量，它通过分片常数区域来参数化吸收场：\n$$\n\\mu = B x \\in \\mathbb{R}^n,\n$$\n其中 $B \\in \\mathbb{R}^{n \\times K}$ 是一个二进制分配矩阵，它将每个内部节点精确地映射到 $K$ 个不相交区域中的一个。在本问题中，取 $K=4$，对应于内部网格的四个象限。\n\n对于任意 $x \\in \\mathbb{R}^4$，定义离散正演算子\n$$\nA(x) = D L + \\mathrm{diag}(B x) \\in \\mathbb{R}^{n \\times n},\n$$\n离散注量 $u(x) \\in \\mathbb{R}^n$ 求解\n$$\nA(x) \\, u(x) = q,\n$$\n其中 $q \\in \\mathbb{R}^n$ 是位于最接近域中心的内部节点上的一个固定点源。定义一个线性测量算子 $M \\in \\mathbb{R}^{m \\times n}$，它在边界附近一组指定的内部节点上提取 $u$ 的值（代表邻近边界的探测器）。参数到数据的映射则为\n$$\nF(x) = M \\, u(x) = M \\, A(x)^{-1} \\, q \\in \\mathbb{R}^m.\n$$\n\n您将需要对在不同基点 $x$ 和扰动方向 $h \\in \\mathbb{R}^4$ 下计算出的 $F$ 的雅可比矩阵进行一阶泰勒余项检验。对于小扰动 $h$，泰勒余项比\n$$\nR(h) \\equiv \\frac{\\|F(x+h) - F(x) - J(x) h\\|_2}{\\|h\\|_2}\n$$\n应随 $\\|h\\|_2$ 线性衰减，其中 $J(x) \\in \\mathbb{R}^{m \\times 4}$ 是 $F$ 在 $x$ 处的雅可比矩阵。雅可比矩阵-向量积可以在不显式构造 $J(x)$ 的情况下，通过以下恒等式进行计算\n$$\nJ(x) h \\;=\\; - M \\, A(x)^{-1} \\left( \\mathrm{diag}(B h) \\, u(x) \\right),\n$$\n该式可通过对 $F(x) = M A(x)^{-1} q$ 求导并利用恒等式 $\\mathrm{d}A^{-1} = -A^{-1} (\\mathrm{d}A) A^{-1}$ 得出。\n\n实现以下数值实验，以验证 $R(t h)$ 作为 $\\|t h\\|_2$ 的函数（其中 $t > 0$）的线性衰减特性：\n\n- 离散化和算子：\n  - 使用每边 $N = 20$ 个节点，因此内部节点数为 $n = (N-2)^2 = 324$。使用标准的5点格式拉普拉斯算子 $L$，网格间距为 $h = 1/(N-1)$，并在内部区域外设置狄利克雷边界值为零。\n  - 使用 $D = 1$。\n  - 在内部网格上定义四个区域（象限）以构建 $B \\in \\mathbb{R}^{n \\times 4}$。每个内部节点根据其内部索引位于内部网格的左下、右下、左上还是右上半部分，而精确地属于一个象限。\n  - 将源 $q \\in \\mathbb{R}^n$ 定义为位于最接近域中心的内部节点上的单位点源。\n  - 将测量算子 $M$ 定义为一个行选择器，用于在边界附近的一组内部节点上提取 $u$ 的值：\n    - 传感器组 $\\mathcal{S}_1$：选择与顶部边界相邻的内部行，以及列 $\\{2,6,10,14,17\\}$（使用内部索引）。\n    - 传感器组 $\\mathcal{S}_2$：选择与左侧边界相邻的内部列，以及行 $\\{2,6,10,14,17\\}$（使用内部索引）。\n    - 传感器组 $\\mathcal{S}_3$：选择与底部边界相邻的内部行，以及列 $\\{3,7,11,15\\}$（使用内部索引）。\n  在每种情况下，$M$ 都从 $u$ 中选取这些节点。\n\n- 对于下面的每个测试用例，通过对一系列等比步长上的点 $\\{(\\log \\|t h\\|_2, \\log R(t h))\\}$ 进行线性最小二乘拟合，来估计经验收敛率 $\\hat{p}$。使用步长 $t_k = 10^{-1} \\cdot 2^{-k}$，其中 $k \\in \\{0,1,2,3,4,5\\}$。使用 $F(x+t_k h)$ 的精确正演求解和上面给出的雅可比矩阵-向量积公式来计算 $R(t_k h)$。\n\n- 接受标准：对于每个测试用例，返回一个布尔值，表示估计的斜率 $\\hat{p}$ 是否满足 $|\\hat{p} - 1| \\le 0.1$。\n\n所有量均为无量纲。测试套件包含三个用例：\n\n- 用例 A（均匀背景，顶部传感器）：\n  - 基准参数 $x_A = [\\,0.02,\\, 0.02,\\, 0.02,\\, 0.02\\,]^{\\top}$。\n  - 方向 $h_A = [\\,0.01,\\,-0.015,\\,0.02,\\,-0.005\\,]^{\\top}$。\n  - 测量集 $\\mathcal{S}_1$。\n\n- 用例 B（非均匀背景，左侧传感器）：\n  - 基准参数 $x_B = [\\,0.04,\\, 0.02,\\, 0.03,\\, 0.01\\,]^{\\top}$。\n  - 方向 $h_B = [\\,-0.008,\\,0.012,\\,-0.006,\\,0.004\\,]^{\\top}$。\n  - 测量集 $\\mathcal{S}_2$。\n\n- 用例 C（低吸收，底部传感器）：\n  - 基准参数 $x_C = [\\,0.005,\\, 0.005,\\, 0.005,\\, 0.005\\,]^{\\top}$。\n  - 方向 $h_C = [\\,-0.002,\\,0.001,\\,-0.001,\\,0.001\\,]^{\\top}$。\n  - 测量集 $\\mathcal{S}_3$。\n\n您的程序必须构造 $L$、$B$、$q$ 和指定的测量算子 $M$，实现 $F(x)$，对每个 $h$ 通过对 $A(x)$ 进行一次线性求解来实现雅可比矩阵-向量积 $J(x) h$，并按指定要求为每个用例计算比率 $R(t_k h)$ 和估计斜率 $\\hat{p}$。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个含有三个布尔值的列表，分别对应于用例 A、B 和 C，表示每个用例是否通过接受标准。该行的格式必须与带有布尔字面量的 Python 风格列表完全一致，例如，“[True,False,True]”。", "solution": "用户在计算科学和反问题领域提供了一个适定的、有科学依据的问题。任务是验证一个漫射光学断层成像（DOT）模型中参数到观测映射的雅可比矩阵的实现。此验证将使用一阶泰勒余项检验来执行。\n\n该问题是有效的。它内容自洽，科学上合理，所有参数和条件都已明确指定，足以实现一个唯一的解决方案。关于网格索引约定的一些微小歧义（例如，中心节点的选择）可以通过标准实践来解决，这些将在解决方案中予以说明。\n\n解决方案按以下步骤进行：首先，我们将详细介绍控制偏微分方程（PDE）的离散化。其次，我们将定义离散正演模型和雅可比-向量积的公式。第三，我们将解释用于验证的泰勒余项检验的原理。最后，我们将概述针对给定问题参数的测试的具体数值实现。\n\n### 1. 控制方程的离散化\n\n物理模型是单位正方形 $\\Omega = (0,1)^2$ 上的稳态扩散方程：\n$$\n- \\nabla \\cdot \\left( D \\nabla u \\right) + \\mu_a(\\mathbf{r}) \\, u(\\mathbf{r}) = q(\\mathbf{r}) \\quad \\text{in } \\Omega,\n$$\n边界条件为齐次狄利克雷边界条件 $u|_{\\partial \\Omega} = 0$。扩散系数 $D$ 是一个常数，设为 $D=1$。\n\n我们使用有限差分法在一个 $N \\times N$（其中 $N=20$）的均匀笛卡尔网格上对此偏微分方程进行离散化。这产生一个 $(N-2) \\times (N-2) = 18 \\times 18$ 的内部网格。令 $n = (N-2)^2 = 324$ 为内部节点数。网格间距为 $h = 1/(N-1) = 1/19$。\n\n$-D \\nabla^2 u$ 项使用标准的5点格式进行近似。这产生一个由矩阵 $L \\in \\mathbb{R}^{n \\times n}$ 表示的离散线性算子。我们将 $L$ 定义为对应于负拉普拉斯算子 $-\\nabla^2$ 并按 $D/h^2$ 缩放的矩阵。对于一个二维内部索引 $(i,j)$ 映射到一维索引 $k$ 的节点，离散算子的作用是：\n$$\n(L u)_k \\approx \\frac{D}{h^2} \\left( 4u_k - u_{k_{i-1,j}} - u_{k_{i+1,j}} - u_{k_{i,j-1}} - u_{k_{i,j+1}} \\right),\n$$\n其中 $u_k$ 是内部网格上的注量值。由于算子和狄利克雷边界条件，$L$ 矩阵是对称正定（SPD）的。\n\n吸收项 $\\mu_a(\\mathbf{r}) u(\\mathbf{r})$ 由一个低维向量 $x \\in \\mathbb{R}^4$ 参数化。吸收场 $\\mu_a$ 在 $K=4$ 个不相交的区域（内部网格的象限）上是分片常数。这表示为 $\\mu = Bx$，其中 $B \\in \\mathbb{R}^{n \\times 4}$ 是一个二进制矩阵，将 $n$ 个内部节点中的每一个分配到四个象限之一。离散吸收算子是一个对角矩阵 $\\mathrm{diag}(\\mu) = \\mathrm{diag}(Bx)$。\n\n偏微分方程的离散形式成为一个线性系统：\n$$\n(L + \\mathrm{diag}(Bx)) u = q \\quad \\implies \\quad A(x) u(x) = q,\n$$\n其中 $u \\in \\mathbb{R}^n$ 是内部节点处的注量值向量，$q \\in \\mathbb{R}^n$ 是离散源向量，$A(x) = L + \\mathrm{diag}(Bx)$ 是系统矩阵，或称离散正演算子。由于 $L$ 是对称正定的，且吸收系数非负，所以 $\\mathrm{diag}(Bx)$ 是半正定的，这使得 $A(x)$ 也是对称正定且可逆的。\n\n### 2. 正演模型与雅可比-向量积\n\n参数到观测的映射 $F(x)$ 给出给定参数向量 $x$ 的模拟测量值。它定义为：\n$$\nF(x) = M u(x) = M A(x)^{-1} q,\n$$\n其中 $M \\in \\mathbb{R}^{m \\times n}$ 是一个线性测量算子，用于在 $m$ 个传感器位置选择注量值。\n\n为验证 $F(x)$ 的雅可比矩阵的正确性，我们需要计算它在一个扰动向量 $h \\in \\mathbb{R}^4$ 上的作用，记为 $J(x)h$。将 $F(x)$ 沿方向 $h$ 对 $x$ 求导得到：\n$$\nJ(x)h = M \\, \\frac{d}{d\\alpha}\\Big|_{\\alpha=0} \\left[ A(x+\\alpha h)^{-1} \\right] q.\n$$\n使用矩阵逆的导数恒等式 $\\mathrm{d}(A^{-1}) = -A^{-1}(\\mathrm{d}A)A^{-1}$，并注意到 $A(x)$ 中唯一依赖于 $x$ 的部分是 $\\mathrm{diag}(Bx)$，我们有 $\\mathrm{d}A = \\mathrm{diag}(B(\\mathrm{d}x))$。对于方向导数，这变成 $\\mathrm{diag}(Bh)$。将此代入表达式，我们得到雅可比-向量积：\n$$\nJ(x)h = -M A(x)^{-1} \\left( \\mathrm{diag}(Bh) \\, u(x) \\right).\n$$\n这个公式在计算上很有优势，因为它避免了显式构造 $m \\times 4$ 的雅可比矩阵 $J(x)$。它需要对同一个矩阵 $A(x)$ 进行两次线性求解：一次用于计算 $u(x) = A(x)^{-1}q$，第二次用于计算 $A(x)^{-1}$ 在向量 $w = \\mathrm{diag}(Bh)u(x)$ 上的作用。\n\n### 3. 泰勒余项检验\n\n$F(x)$ 在点 $x$ 附近的泰勒展开为：\n$$\nF(x+h) = F(x) + J(x)h + \\mathcal{O}(\\|h\\|^2).\n$$\n此展开式的余项是 $F(x+h) - F(x) - J(x)h$。对于一个足够光滑的函数 $F$，该余项的阶数为 $\\|h\\|^2$。我们可以通过检查余项比的行为来验证我们计算的雅可比矩阵：\n$$\nR(h) = \\frac{\\| F(x+h) - F(x) - J(x)h \\|_2}{\\|h\\|_2}.\n$$\n理论上，我们期望 $R(h) \\propto \\|h\\|_2$，这意味着当 $\\|h\\|_2 \\to 0$ 时，$R(h)$ 应线性收敛于零。这意味着存在形如 $\\log(R(h)) = p \\log(\\|h\\|_2) + c$ 的关系，其中收敛率 $p=1$。\n\n数值实验将估计这个速率 $p$。我们沿一个固定方向 $h$，对一个递减步长序列 $t > 0$ 计算 $R(t h)$。通过对点 $(\\log \\|t h\\|_2, \\log R(t h))$ 进行线性最小二乘拟合，我们得到一个经验收敛率 $\\hat{p}$（直线的斜率）。如果 $\\hat{p}$ 接近 1，我们就可以确信我们的雅可比-向量积的实现是正确的。问题指定了一个接受标准 $|\\hat{p}-1| \\le 0.1$。\n\n### 4. 实现细节\n\n- **网格和算子：** 我们为 $N=20$ 和 $D=1$ 构造稀疏矩阵 $L$。吸收基矩阵 $B$ 是通过将 $n=324$ 个内部节点中的每一个映射到四个象限（左下、右下、左上、右上）之一来构造的。源向量 $q$ 是一个单位向量，其非零项对应于网格索引为 $(8,8)$（0-based 索引）的内部节点，该节点是最靠近域中心 $(0.5, 0.5)$ 的四个节点之一。每个用例的测量矩阵 $M$ 被实现为选择器，用于在指定的节点索引处从注量向量 $u$ 中提取值。\n- **数值测试流程：** 对于三个测试用例（A、B、C）中的每一个，我们执行以下步骤：\n    1. 定义基准参数 $x$、扰动方向 $h$ 和测量索引。\n    2. 在基点 $x$ 预计算相关量：$A(x)$、$u(x) = A(x)^{-1}q$、$F(x)=Mu(x)$ 以及方向 $h$ 的雅可比-向量积 $J(x)h = -M A(x)^{-1} (\\mathrm{diag}(Bh)u(x))$。\n    3. 对等比步长序列 $t_k = 10^{-1} \\cdot 2^{-k}$（其中 $k \\in \\{0, \\dots, 5\\}$）进行循环。\n    4. 在每次迭代中，计算扰动后的正演解 $F(x+t_k h)$ 和余项比 $R(t_k h)$。\n    5. 收集 $\\log \\|t_k h\\|_2$ 和 $\\log R(t_k h)$ 的值。\n    6. 循环结束后，通过这些对数-对数点计算最佳拟合线的斜率 $\\hat{p}$。\n    7. 检查 $\\hat{p}$ 是否满足接受标准 $|\\hat{p}-1| \\le 0.1$。\n收集并报告所有三个用例的检查结果。对于涉及稀疏矩阵 $A(x)$ 的所有线性求解，我们使用一个高效的稀疏直接求解器。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the DOT Jacobian verification problem.\n    \"\"\"\n    \n    # 1. Discretization and operator setup\n    N = 20\n    N_int = N - 2\n    n = N_int**2\n    h_grid = 1 / (N - 1)\n    D = 1.0\n\n    # Create the discrete negative Laplacian L corresponding to -D*nabla^2\n    # with 5-point stencil (4 on diag, -1 on off-diags), scaled by D/h^2\n    main_diag = np.full(n, 4.0)\n    side_diag = np.full(n - 1, -1.0)\n    # Periodicity for side_diag (jumps at end of rows)\n    side_diag[N_int-1::N_int] = 0\n    up_down_diag = np.full(n - N_int, -1.0)\n    \n    diagonals = [up_down_diag, side_diag, main_diag, side_diag, up_down_diag]\n    offsets = [-N_int, -1, 0, 1, N_int]\n    \n    L = (D / h_grid**2) * diags(diagonals, offsets, shape=(n, n), format='csc')\n\n    # Create the patch assignment matrix B\n    K = 4\n    B = np.zeros((n, K))\n    half_grid = N_int // 2\n    for i in range(N_int):\n        for j in range(N_int):\n            k = i * N_int + j\n            if i  half_grid and j  half_grid: # Lower-left\n                B[k, 0] = 1\n            elif i  half_grid and j >= half_grid: # Lower-right\n                B[k, 1] = 1\n            elif i >= half_grid and j  half_grid: # Upper-left\n                B[k, 2] = 1\n            else: # Upper-right\n                B[k, 3] = 1\n\n    # Create the source vector q\n    # Tie-break for the central node by picking the one with smallest indices\n    center_idx_i = half_grid - 1\n    center_idx_j = half_grid - 1\n    q_idx = center_idx_i * N_int + center_idx_j\n    q = np.zeros(n)\n    q[q_idx] = 1.0\n    q = csc_matrix(q).T # Use sparse column vector for spsolve\n\n    # Define sensor sets (1D indices)\n    # Interior indices are 0-based\n    # S1: top row (i=17), cols {2,6,10,14,17}\n    M1_indices = [17 * N_int + c for c in [2, 6, 10, 14, 17]]\n    # S2: left col (j=0), rows {2,6,10,14,17}\n    M2_indices = [r * N_int + 0 for r in [2, 6, 10, 14, 17]]\n    # S3: bottom row (i=0), cols {3,7,11,15}\n    M3_indices = [0 * N_int + c for c in [3, 7, 11, 15]]\n\n    # 2. Test case execution logic\n    def run_test_case(x_base, h_dir, M_indices):\n        \"\"\"\n        Performs the Taylor remainder test for a single case.\n        \"\"\"\n        \n        # Helper to construct A(x)\n        def get_A(x):\n            mu_vec = B @ x\n            return L + diags(mu_vec, 0, shape=(n, n), format='csc')\n\n        # Compute base quantities\n        A_base = get_A(x_base)\n        u_base = spsolve(A_base, q)\n        F_base = u_base[M_indices]\n        \n        # Compute Jacobian-vector product J(x_base) @ h_dir\n        # J(x)h = -M A(x)^{-1} (diag(B h) u(x))\n        bh_dir = B @ h_dir\n        w = bh_dir * u_base\n        v = spsolve(A_base, w)\n        Jvh_base = -v[M_indices]\n\n        log_h_norms = []\n        log_R_values = []\n        \n        for k in range(6):\n            t_k = 1e-1 * (2.0**(-k))\n            h_k = t_k * h_dir\n\n            # Compute F(x + h)\n            A_pert = get_A(x_base + h_k)\n            u_pert = spsolve(A_pert, q)\n            F_pert = u_pert[M_indices]\n            \n            # Jacobian-vector product for h_k: J(x_base) @ h_k = t_k * (J(x_base) @ h_dir)\n            Jvh_k = t_k * Jvh_base\n\n            # Compute Taylor remainder ratio R(h_k)\n            num_norm = np.linalg.norm(F_pert - F_base - Jvh_k)\n            den_norm = np.linalg.norm(h_k)\n            \n            if den_norm > 0 and num_norm > 0:\n                R_k = num_norm / den_norm\n                log_h_norms.append(np.log(den_norm))\n                log_R_values.append(np.log(R_k))\n\n        # Perform linear regression to find the convergence rate p_hat\n        if len(log_h_norms)  2:\n            return False\n\n        p_hat, _ = np.polyfit(log_h_norms, log_R_values, 1)\n\n        return abs(p_hat - 1.0) = 0.1\n\n    # 3. Define and run test cases\n    test_cases = [\n        # Case A\n        {'x': np.array([0.02, 0.02, 0.02, 0.02]),\n         'h': np.array([0.01, -0.015, 0.02, -0.005]),\n         'M': M1_indices},\n        # Case B\n        {'x': np.array([0.04, 0.02, 0.03, 0.01]),\n         'h': np.array([-0.008, 0.012, -0.006, 0.004]),\n         'M': M2_indices},\n        # Case C\n        {'x': np.array([0.005, 0.005, 0.005, 0.005]),\n         'h': np.array([-0.002, 0.001, -0.001, 0.001]),\n         'M': M3_indices}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(case['x'], case['h'], case['M'])\n        results.append(result)\n\n    # Final output\n    print(f\"[{','.join(map(str, [r.item() for r in results]))}]\".replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\nsolve()\n```", "id": "3378201"}, {"introduction": "EIT和DOT的反问题通常是病态的，这意味着数据中的微小噪声可能导致解的巨大误差。为了获得稳定且有意义的重建结果，正则化是必不可少的。Tikhonov正则化是一种常用方法，它可以在贝叶斯框架下进行解释，但其关键挑战在于选择正则化参数 $\\alpha$。本练习将通过一个具体算例 [@problem_id:3378196]，探讨如何使用证据最大化（II型最大似然）这一原则性方法来自动选择 $\\alpha$，并理解有效自由度等相关概念。", "problem": "考虑一个源于电阻抗断层成像（EIT）的线性化逆问题，其中数据失配由高斯噪声模型建模，先验为Tikhonov型高斯先验。具体来说，令测量向量 $y \\in \\mathbb{R}^{m}$ 通过线性模型 $y = A x + \\varepsilon$ 与参数增量 $x \\in \\mathbb{R}^{n}$ 相关联，其中 $A \\in \\mathbb{R}^{m \\times n}$ 是在均匀背景下通过线性化正向映射得到的灵敏度矩阵，噪声 $\\varepsilon \\sim \\mathcal{N}(0,\\beta^{-1} I)$，且噪声精度 $\\beta  0$ 为已知。假设一个高斯先验 $x \\sim \\mathcal{N}\\!\\left(0,\\alpha^{-1} R^{-T} R^{-1}\\right)$，其中 $R \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵，$\\alpha  0$ 是待通过证据最大化（II型最大似然）选择的Tikhonov正则化参数。引入变量 $u = R x$，并定义变换后的设计矩阵 $\\Phi = A R^{-1}$。你可以假设多元高斯分布、高斯条件化以及迹下的标准矩阵微分的性质。\n\n任务：\n1) 从线性高斯模型和高斯先验出发，通过对 $u$ 积分，推导 $u$ 的后验分布和边际似然（证据）$p(y \\mid \\alpha)$。然后，通过最大化关于 $\\alpha$ 的对数证据，推导一个用 $u$ 的后验均值和 $\\Phi^{T}\\Phi$ 的谱表示的 $\\alpha$ 的显式更新公式。将你的更新表示为一个仅依赖于 $\\alpha$、$\\beta$、$\\Phi$ 和 $y$ 的闭式解析表达式（无未知常数）。同时推导将 $y$ 映射到拟合数据 $\\hat{y}$ 的帽子矩阵 $H(\\alpha)$，并展示如何将有效自由度计算为 $H(\\alpha)$ 的迹。\n\n2) 现在考虑以下一个 $m = 2$ 且 $n = 2$ 的具体EIT线性化实例。令\n$$\nA = \\begin{pmatrix}\n1.0  0.2 \\\\\n0.3  0.9\n\\end{pmatrix}, \\quad\nR = \\begin{pmatrix}\n1  0 \\\\\n0  2\n\\end{pmatrix}, \\quad\n\\beta = 25, \\quad\ny = \\begin{pmatrix}\n0.7 \\\\\n0.1\n\\end{pmatrix}.\n$$\n从初始值 $\\alpha^{(0)} = 1$ 开始，使用一次证据最大化更新，计算从你推导的更新公式中获得的更新值 $\\alpha^{(1)}$。然后，在 $\\alpha = \\alpha^{(1)}$ 处，计算作为帽子矩阵 $H(\\alpha)$ 的迹的有效自由度。\n\n将 $\\alpha^{(1)}$ 和有效自由度均四舍五入到四位有效数字。将你的最终答案以包含这两个数字（按此顺序）的行矩阵形式提供。无需单位。", "solution": "用户提供了一个有效的、基于线性逆问题贝叶斯推断原理的问题陈述。该问题是适定的、客观的，并包含了唯一解所需的所有信息。我将进行完整的推导和计算。\n\n### 第1部分：理论推导\n\n问题在于使用贝叶斯框架找到线性系统 $y = Ax + \\varepsilon$ 的正则化解。\n\n**1. 模型变换**\n\n模型由以下部分给出：\n- 似然：$p(y \\mid x, \\beta) = \\mathcal{N}(y \\mid Ax, \\beta^{-1}I)$，其中 $\\mathcal{N}(\\cdot \\mid \\mu, \\Sigma)$ 表示均值为 $\\mu$、协方差为 $\\Sigma$ 的多元正态分布。\n- 先验：$p(x \\mid \\alpha) = \\mathcal{N}(x \\mid 0, \\alpha^{-1}(R^T R)^{-1})$。由于给定 $R$ 是对称正定的，因此 $R^T=R$，所以先验协方差为 $\\alpha^{-1}(R^2)^{-1}$。\n\n我们引入变量替换 $u = Rx$。由于这是对高斯随机变量 $x$ 的线性变换，$u$ 也是高斯分布的。$u$ 的均值为 $R \\cdot 0 = 0$。$u$ 的协方差为 $R(\\alpha^{-1}(R^T R)^{-1})R^T = \\alpha^{-1} R(R^T R)^{-1}R^T = \\alpha^{-1} R(R^{-1}(R^T)^{-1})R^T = \\alpha^{-1}(R R^{-1})((R^T)^{-1}R^T) = \\alpha^{-1}I$。\n因此，$u$ 上的先验是一个更简单的球形高斯分布：\n$$p(u \\mid \\alpha) = \\mathcal{N}(u \\mid 0, \\alpha^{-1}I)$$\n\n似然也必须用 $u$ 来表示。由于 $R$ 是可逆的，$x = R^{-1}u$。将此代入似然模型得到：\n$$y = A(R^{-1}u) + \\varepsilon = \\Phi u + \\varepsilon$$\n其中 $\\Phi = AR^{-1}$ 是变换后的设计矩阵。似然变为：\n$$p(y \\mid u, \\beta) = \\mathcal{N}(y \\mid \\Phi u, \\beta^{-1}I)$$\n\n**2. $u$ 的后验分布**\n\n给定数据 $y$ 时 $u$ 的后验分布可以通过贝叶斯定理找到：$p(u \\mid y, \\alpha, \\beta) \\propto p(y \\mid u, \\beta) p(u \\mid \\alpha)$。\n由于似然和先验都是高斯分布，后验也将是高斯分布，$p(u \\mid y, \\alpha, \\beta) = \\mathcal{N}(u \\mid \\mu_u, \\Sigma_u)$。\n\n后验精度（协方差的逆）是先验精度和（关于 $u$ 的）似然精度的和。\n- 先验精度：从 $p(u \\mid \\alpha)$ 可知，精度为 $(\\alpha^{-1}I)^{-1} = \\alpha I$。\n- 似然数据项：似然的指数部分为 $-\\frac{\\beta}{2}(y-\\Phi u)^T(y-\\Phi u) = -\\frac{\\beta}{2}(u^T\\Phi^T\\Phi u - 2y^T\\Phi u + y^T y)$。$u$ 的二次项表明，由似然贡献的精度为 $\\beta\\Phi^T\\Phi$。\n\n因此，后验精度为 $\\Sigma_u^{-1} = \\alpha I + \\beta\\Phi^T\\Phi$。\n后验协方差为 $\\Sigma_u = (\\alpha I + \\beta\\Phi^T\\Phi)^{-1}$。\n\n后验均值 $\\mu_u$ 可以通过配方法或使用标准公式 $\\mu_u = \\Sigma_u (\\text{先验精度} \\times \\text{先验均值} + \\text{似然项})$ 找到。先验均值为 $0$。指数中关于 $u$ 的线性项来自 $-2\\beta y^T\\Phi u$，因此似然项为 $\\beta\\Phi^T y$。\n$$\\mu_u = \\Sigma_u (\\alpha I \\cdot 0 + \\beta\\Phi^T y) = \\beta(\\alpha I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T y$$\n所以，后验分布为 $p(u \\mid y, \\alpha, \\beta) = \\mathcal{N}(u \\mid \\mu_u, \\Sigma_u)$。\n\n**3. 边际似然（证据）**\n\n边际似然，或称证据，$p(y \\mid \\alpha, \\beta)$ 是通过对参数 $u$ 积分得到的：\n$$p(y \\mid \\alpha, \\beta) = \\int p(y \\mid u, \\beta) p(u \\mid \\alpha) du$$\n这对应于两个高斯分布的卷积。对于一个模型 $u \\sim \\mathcal{N}(\\mu_0, \\Sigma_0)$ 和 $y \\mid u \\sim \\mathcal{N}(Hu, \\Sigma_n)$，$y$ 的边际分布是 $y \\sim \\mathcal{N}(H\\mu_0, \\Sigma_n + H\\Sigma_0 H^T)$。\n在我们的例子中，$\\mu_0=0$，$\\Sigma_0=\\alpha^{-1}I$，$H=\\Phi$，$\\Sigma_n=\\beta^{-1}I$。\n边际分布的均值为 $\\Phi \\cdot 0 = 0$。\n协方差为 $\\beta^{-1}I + \\Phi(\\alpha^{-1}I)\\Phi^T = \\beta^{-1}I + \\alpha^{-1}\\Phi\\Phi^T$。\n所以，证据是一个高斯分布：\n$$p(y \\mid \\alpha, \\beta) = \\mathcal{N}(y \\mid 0, \\alpha^{-1}\\Phi\\Phi^T + \\beta^{-1}I)$$\n对数证据为：\n$$\\mathcal{L}(\\alpha) = \\ln p(y \\mid \\alpha, \\beta) = -\\frac{1}{2} y^T (\\alpha^{-1}\\Phi\\Phi^T + \\beta^{-1}I)^{-1} y - \\frac{1}{2}\\ln\\det(\\alpha^{-1}\\Phi\\Phi^T + \\beta^{-1}I) - \\frac{m}{2}\\ln(2\\pi)$$\n（注：我们视 $\\beta$ 为固定值，因此 $\\mathcal{L}$ 是 $\\alpha$ 的函数）。\n\n**4. 证据最大化与 $\\alpha$ 的更新公式**\n\n为了找到最优的 $\\alpha$，我们最大化 $\\mathcal{L}(\\alpha)$。另一个通常更方便的对数证据表达式是：\n$$\\mathcal{L}(\\alpha) = \\frac{m}{2}\\ln\\beta + \\frac{n}{2}\\ln\\alpha - \\frac{1}{2}\\ln\\det(\\alpha I + \\beta\\Phi^T\\Phi) - \\frac{1}{2}E_{\\text{data}}$$\n其中 $E_{\\text{data}} = \\beta\\|y - \\Phi\\mu_u\\|^2 + \\alpha\\|\\mu_u\\|^2$。简化后，这变为 $\\beta y^T y - \\mu_u^T \\Sigma_u^{-1}\\mu_u = \\beta y^T y - \\beta^2 y^T\\Phi \\Sigma_u \\Phi^T y$。\n所以，$\\mathcal{L}(\\alpha) = \\frac{m}{2}\\ln\\beta + \\frac{n}{2}\\ln\\alpha - \\frac{1}{2}\\ln\\det(\\Sigma_u^{-1}) - \\frac{\\beta}{2}y^T y + \\frac{\\beta^2}{2}y^T\\Phi \\Sigma_u \\Phi^T y + C$。\n\n对 $\\alpha$ 求导：\n$\\frac{\\partial \\mathcal{L}}{\\partial \\alpha} = \\frac{n}{2\\alpha} - \\frac{1}{2}\\frac{\\partial}{\\partial\\alpha}\\ln\\det(\\alpha I + \\beta\\Phi^T\\Phi) + \\frac{\\beta^2}{2}y^T\\Phi \\frac{\\partial\\Sigma_u}{\\partial\\alpha} \\Phi^T y$。\n使用 $\\frac{d}{dt}\\ln\\det(M(t)) = \\text{tr}(M^{-1}\\frac{dM}{dt})$ 和 $\\frac{d}{dt}M^{-1} = -M^{-1}\\frac{dM}{dt}M^{-1}$：\n- $\\frac{\\partial}{\\partial\\alpha}\\ln\\det(\\alpha I + \\beta\\Phi^T\\Phi) = \\text{tr}((\\alpha I + \\beta\\Phi^T\\Phi)^{-1} I) = \\text{tr}(\\Sigma_u)$。\n- $\\frac{\\partial\\Sigma_u}{\\partial\\alpha} = \\frac{\\partial}{\\partial\\alpha}(\\alpha I + \\beta\\Phi^T\\Phi)^{-1} = -(\\alpha I + \\beta\\Phi^T\\Phi)^{-2} = -\\Sigma_u^2$。\n所以，$\\frac{\\partial \\mathcal{L}}{\\partial \\alpha} = \\frac{n}{2\\alpha} - \\frac{1}{2}\\text{tr}(\\Sigma_u) - \\frac{\\beta^2}{2}y^T\\Phi \\Sigma_u^2 \\Phi^T y$。\n最后一项是 $\\frac{1}{2} \\| \\beta \\Sigma_u \\Phi^T y \\|^2 = \\frac{1}{2}\\|\\mu_u\\|^2$。\n因此，$\\frac{\\partial \\mathcal{L}}{\\partial \\alpha} = \\frac{n}{2\\alpha} - \\frac{1}{2}\\text{tr}(\\Sigma_u) - \\frac{1}{2}\\|\\mu_u\\|^2$。\n\n将导数设为零得到：$\\frac{n}{\\alpha} = \\text{tr}(\\Sigma_u) + \\|\\mu_u\\|^2$。\n两边乘以 $\\alpha$ 得到 $n = \\alpha \\text{tr}(\\Sigma_u) + \\alpha\\|\\mu_u\\|^2$。\n整理得到 $\\alpha$ 的表达式：\n$$\\alpha = \\frac{n - \\alpha \\text{tr}(\\Sigma_u)}{\\|\\mu_u\\|^2}$$\n让我们定义 $\\gamma = n - \\alpha \\text{tr}(\\Sigma_u)$。令 $\\lambda_i$ 为 $\\Phi^T\\Phi$ 的特征值。\n那么 $\\text{tr}(\\Sigma_u) = \\text{tr}((\\alpha I + \\beta\\Phi^T\\Phi)^{-1}) = \\sum_{i=1}^n \\frac{1}{\\alpha + \\beta\\lambda_i}$。\n所以，$\\gamma = n - \\alpha \\sum_{i=1}^n \\frac{1}{\\alpha + \\beta\\lambda_i} = \\sum_{i=1}^n (1 - \\frac{\\alpha}{\\alpha + \\beta\\lambda_i}) = \\sum_{i=1}^n \\frac{\\beta\\lambda_i}{\\alpha + \\beta\\lambda_i}$。\n量 $\\gamma$ 是有效参数的数量。\n对数证据最大化的条件变为 $\\alpha\\|\\mu_u\\|^2 = \\gamma$。这没有给出 $\\alpha$ 的闭式解，而是一个迭代更新方案。给定当前估计值 $\\alpha^{(k)}$，我们计算一个新的估计值 $\\alpha^{(k+1)}$：\n$$\\alpha^{(k+1)} = \\frac{\\gamma^{(k)}}{\\|\\mu_u^{(k)}\\|^2}$$\n其中 $\\gamma^{(k)} = \\sum_{i=1}^n \\frac{\\beta\\lambda_i}{\\alpha^{(k)} + \\beta\\lambda_i}$ 且 $\\mu_u^{(k)} = \\beta(\\alpha^{(k)} I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T y$。这就是所要求的更新公式。\n\n**5. 帽子矩阵和有效自由度**\n\n拟合数据 $\\hat{y}$ 是在参数的后验分布下测量的期望值。这由 $\\hat{y} = \\Phi \\mu_u$ 给出。\n代入 $\\mu_u$ 的表达式：\n$$\\hat{y} = \\Phi \\left(\\beta(\\alpha I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T y\\right)$$\n将观测数据 $y$ 映射到拟合数据 $\\hat{y}$ 的矩阵就是帽子矩阵 $H(\\alpha)$：\n$$H(\\alpha) = \\beta\\Phi(\\alpha I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T$$\n模型的有效自由度由帽子矩阵的迹给出。利用迹的循环性质 $\\text{tr}(ABC) = \\text{tr}(BCA)$：\n$$\\text{tr}(H(\\alpha)) = \\text{tr}(\\beta\\Phi(\\alpha I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T) = \\text{tr}(\\Phi^T\\beta\\Phi(\\alpha I + \\beta\\Phi^T\\Phi)^{-1})$$\n令 $M = \\beta\\Phi^T\\Phi$。表达式为 $\\text{tr}(M(\\alpha I + M)^{-1})$。设 $\\Phi^T\\Phi$ 的特征值为 $\\{\\lambda_i\\}_{i=1}^n$。那么 $M$ 的特征值为 $\\{\\beta\\lambda_i\\}_{i=1}^n$。$M(\\alpha I + M)^{-1}$ 的特征值为 $\\frac{\\beta\\lambda_i}{\\alpha + \\beta\\lambda_i}$。\n迹是这些特征值的和：\n$$\\text{tr}(H(\\alpha)) = \\sum_{i=1}^{n} \\frac{\\beta\\lambda_i}{\\alpha + \\beta\\lambda_i}$$\n这正是我们定义为 $\\gamma$ 的量。因此，有效自由度是 $\\gamma = \\text{tr}(H(\\alpha))$。\n\n### 第2部分：数值计算\n\n我们已知：\n$A = \\begin{pmatrix} 1.0  0.2 \\\\ 0.3  0.9 \\end{pmatrix}$, $R = \\begin{pmatrix} 1  0 \\\\ 0  2 \\end{pmatrix}$, $\\beta = 25$, $y = \\begin{pmatrix} 0.7 \\\\ 0.1 \\end{pmatrix}$, 以及 $\\alpha^{(0)} = 1$。\n\n**1. 初步计算**\n$R^{-1} = \\begin{pmatrix} 1  0 \\\\ 0  0.5 \\end{pmatrix}$\n$\\Phi = AR^{-1} = \\begin{pmatrix} 1.0  0.2 \\\\ 0.3  0.9 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  0.5 \\end{pmatrix} = \\begin{pmatrix} 1.0  0.1 \\\\ 0.3  0.45 \\end{pmatrix}$\n$\\Phi^T\\Phi = \\begin{pmatrix} 1.0  0.3 \\\\ 0.1  0.45 \\end{pmatrix} \\begin{pmatrix} 1.0  0.1 \\\\ 0.3  0.45 \\end{pmatrix} = \\begin{pmatrix} 1.09  0.235 \\\\ 0.235  0.2125 \\end{pmatrix}$\n\n**2. $\\Phi^T\\Phi$ 的特征值**\n我们通过求解 $\\det(\\Phi^T\\Phi - \\lambda I)=0$ 来找到特征值 $\\lambda$。\n$\\lambda^2 - \\text{tr}(\\Phi^T\\Phi)\\lambda + \\det(\\Phi^T\\Phi) = 0$\n$\\text{tr}(\\Phi^T\\Phi) = 1.09 + 0.2125 = 1.3025$\n$\\det(\\Phi^T\\Phi) = (1.09)(0.2125) - (0.235)^2 = 0.231625 - 0.055225 = 0.1764$\n$\\lambda^2 - 1.3025\\lambda + 0.1764 = 0$\n$\\lambda = \\frac{1.3025 \\pm \\sqrt{1.3025^2 - 4(0.1764)}}{2} = \\frac{1.3025 \\pm \\sqrt{1.69650625 - 0.7056}}{2} = \\frac{1.3025 \\pm \\sqrt{0.99090625}}{2}$\n$\\lambda_1 = \\frac{1.3025 + 0.9954427}{2} \\approx 1.14897$\n$\\lambda_2 = \\frac{1.3025 - 0.9954427}{2} \\approx 0.153529$\n\n**3. 从 $\\alpha^{(0)}=1$ 更新 $\\alpha$**\n我们使用更新公式 $\\alpha^{(1)} = \\frac{\\gamma^{(0)}}{\\|\\mu_u^{(0)}\\|^2}$。\n首先，用 $\\alpha^{(0)}=1$ 计算 $\\gamma^{(0)}$：\n$\\beta\\lambda_1 \\approx 25 \\times 1.14897 = 28.7243$\n$\\beta\\lambda_2 \\approx 25 \\times 0.153529 = 3.8382$\n$\\gamma^{(0)} = \\frac{\\beta\\lambda_1}{\\alpha^{(0)} + \\beta\\lambda_1} + \\frac{\\beta\\lambda_2}{\\alpha^{(0)} + \\beta\\lambda_2} \\approx \\frac{28.7243}{1 + 28.7243} + \\frac{3.8382}{1 + 3.8382} \\approx 0.966358 + 0.793315 = 1.75967$\n\n接下来，计算 $\\|\\mu_u^{(0)}\\|^2$。\n$\\mu_u^{(0)} = \\beta(\\alpha^{(0)} I + \\beta\\Phi^T\\Phi)^{-1}\\Phi^T y$\n$S_0 = \\alpha^{(0)} I + \\beta\\Phi^T\\Phi = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} + 25 \\begin{pmatrix} 1.09  0.235 \\\\ 0.235  0.2125 \\end{pmatrix} = \\begin{pmatrix} 28.25  5.875 \\\\ 5.875  6.3125 \\end{pmatrix}$\n$\\det(S_0) = (28.25)(6.3125) - (5.875)^2 = 178.328125 - 34.515625 = 143.8125$\n$S_0^{-1} = \\frac{1}{143.8125} \\begin{pmatrix} 6.3125  -5.875 \\\\ -5.875  28.25 \\end{pmatrix}$\n$\\Phi^T y = \\begin{pmatrix} 1.0  0.3 \\\\ 0.1  0.45 \\end{pmatrix}\\begin{pmatrix} 0.7 \\\\ 0.1 \\end{pmatrix} = \\begin{pmatrix} 0.73 \\\\ 0.115 \\end{pmatrix}$\n$\\mu_u^{(0)} = 25 \\cdot \\frac{1}{143.8125} \\begin{pmatrix} 6.3125  -5.875 \\\\ -5.875  28.25 \\end{pmatrix} \\begin{pmatrix} 0.73 \\\\ 0.115 \\end{pmatrix} = \\frac{25}{143.8125} \\begin{pmatrix} 3.9325 \\\\ -1.04 \\end{pmatrix} \\approx \\begin{pmatrix} 0.683616 \\\\ -0.180791 \\end{pmatrix}$\n$\\|\\mu_u^{(0)}\\|^2 \\approx 0.683616^2 + (-0.180791)^2 \\approx 0.46733 + 0.032685 = 0.500015$\n\n现在，我们计算更新后的值 $\\alpha^{(1)}$：\n$\\alpha^{(1)} = \\frac{1.75967}{0.500015} \\approx 3.51922$\n四舍五入到四位有效数字，$\\alpha^{(1)} = 3.519$。\n\n**4. $\\alpha = \\alpha^{(1)}$ 时的有效自由度**\n有效自由度由 $\\gamma^{(1)} = \\text{tr}(H(\\alpha^{(1)}))$ 给出。\n$\\gamma^{(1)} = \\frac{\\beta\\lambda_1}{\\alpha^{(1)} + \\beta\\lambda_1} + \\frac{\\beta\\lambda_2}{\\alpha^{(1)} + \\beta\\lambda_2}$\n使用 $\\alpha^{(1)} \\approx 3.51922$：\n$\\gamma^{(1)} \\approx \\frac{28.7243}{3.51922 + 28.7243} + \\frac{3.8382}{3.51922 + 3.8382} = \\frac{28.7243}{32.24352} + \\frac{3.8382}{7.35742} \\approx 0.89085 + 0.52167 = 1.41252$\n四舍五入到四位有效数字，有效自由度为 $1.413$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 3.519  1.413 \\end{pmatrix}}\n$$", "id": "3378196"}]}