{"hands_on_practices": [{"introduction": "在许多科学成像问题中，我们都需要处理反卷积问题——即从模糊的观测数据中恢复出清晰的原始信号。为了在放大信号的同时抑制噪声，我们通常会引入正则化。然而，正则化强度的选择是一个关键的权衡：过强的正则化会过度平滑结果，降低分辨率。本练习将通过计算点扩散函数（PSF）及其半峰全宽（FWHM），让您亲手量化正则化参数 $\\lambda$ 对反演结果分辨率的直接影响。[@problem_id:3417719]", "problem": "考虑一个一维线性反问题，其离散模型向量为 $m \\in \\mathbb{R}^{N}$，数据向量为 $d \\in \\mathbb{R}^{N}$，由正向模型 $d = A m + n$ 给出。其中，$A$ 是一个具有已知核函数的离散卷积算子，$n$ 是零均值高斯加性噪声，其协方差为 $C_{n} = \\sigma^{2} I$。假设采用周期性边界条件，因此 $A$ 是一个循环矩阵。考虑采用零阶惩罚的 Tikhonov 正则化，即估计量 $\\hat{m}$ 被定义为严格凸泛函的唯一最小化子：\n$$\nJ(m) = \\| A m - d \\|_{C_{n}^{-1}}^{2} + \\lambda^{2} \\| m \\|_{2}^{2},\n$$\n其中 $\\| x \\|_{C_{n}^{-1}}^{2} = x^{\\top} C_{n}^{-1} x$，$\\lambda > 0$ 是正则化参数。通过精确线性关系 $\\mathbb{E}[\\hat{m}] = R m$ 定义分辨率矩阵（也称为点扩散算子）$R$，其中期望是针对数据噪声计算的。在网格位置 $j$ 处的点扩散函数（PSF）被定义为估计量对 $j$ 处单位脉冲的响应，即 $R$ 的第 $j$ 列。换句话说，如果真实模型是 $m = e_{j}$（在索引 $j$ 处为 1，其他位置为 0 的标准基向量），那么 $\\mathbb{E}[\\hat{m}]$ 等于以 $j$ 为中心的 PSF。PSF 的半峰全宽（FWHM）在此定义为 PSF 达到其最大振幅一半的两个点之间的距离，该距离通过在网格样本之间进行线性插值计算得出。所有宽度必须以网格单位表示。\n\n你的任务是：\n- 从上述定义以及假设 $C_{n} = \\sigma^{2} I$ 和周期性边界条件出发，推导分辨率矩阵 $R$ 关于 $A$、$\\lambda$ 和 $\\sigma$ 的显式公式，并将 PSF 表征为离散网格上的函数。\n- 将结果特化到 $A$ 是与已知核函数进行卷积的情况，并使用离散傅里叶变换（DFT）获得 PSF 的可实现表达式。\n- 实现一个程序，为下面列出的每个测试用例构建 PSF，并针对两个不同的正则化参数 $\\lambda$ 计算其 FWHM。使用等于 1 的网格间距，以便 FWHM 以网格单位表示。使用相邻样本之间的线性插值来确定半峰值交叉位置。在计算 FWHM 之前，将每个 PSF 归一化至单位峰值。将每个 FWHM 四舍五入到六位小数。\n\n需要使用的精确定义和约定：\n- 点扩散函数（PSF）：$R$ 的第 $j$ 列；由于周期性边界条件下的位移不变性，其形状不依赖于 $j$。你必须计算并报告以中间网格索引 $j = \\lfloor N/2 \\rfloor$ 为中心的 PSF。\n- 离散傅里叶变换（DFT）：一致地使用标准的酉或非酉 DFT；任何一致的归一化方法都是可以接受的，因为 PSF 是通过传递函数的逆 DFT 恢复的，然后会重新归一化至单位峰值。\n- $A$ 的卷积核：下面指定了三种情况。对于高斯核，构建一个周期性离散高斯核 $k[n] \\propto \\exp\\!\\left(-\\tfrac{1}{2} (\\mathrm{dist}(n,0)/\\sigma_{k})^{2}\\right)$，其中 $\\mathrm{dist}(n,0) = \\min\\{ |n|, N - |n| \\}$ 是网格上的循环距离，并将其归一化以使 $\\sum_{n=0}^{N-1} k[n] = 1$。对于 delta 核函数，使用 $k[0]=1$ 和 $k[n]=0$（对于 $n \\neq 0$）。\n- 半峰全宽（FWHM）：给定一个对称、单峰、非负且已归一化至最大值为 1 的 PSF 剖面 $p[n]$，定义半峰值水平 $h = 1/2$。令 $c = \\lfloor N/2 \\rfloor$ 为中心索引。FWHM 计算为左右两侧半峰值交叉位置之间的差值，这些位置是通过对中心 $c$ 两侧第一对跨越 $h$ 的相邻样本进行线性插值得到的。假设网格间距为 1，结果以网格单位表示。\n\n测试套件：\n- 情况 1（理想情况）：$N = 257$，噪声标准差 $\\sigma = 0.1$，高斯模糊核的标准差 $\\sigma_{k} = 2.0$（网格单位），两个正则化参数 $\\lambda_{1} = 0.2$ 和 $\\lambda_{2} = 2.0$。\n- 情况 2（窄核）：$N = 257$，噪声标准差 $\\sigma = 0.1$，高斯模糊核的标准差 $\\sigma_{k} = 0.8$（网格单位），两个正则化参数 $\\lambda_{1} = 0.2$ 和 $\\lambda_{2} = 2.0$。\n- 情况 3（边界核情况）：$N = 257$，噪声标准差 $\\sigma = 0.1$，delta 核函数（单位正向算子），两个正则化参数 $\\lambda_{1} = 0.2$ 和 $\\lambda_{2} = 2.0$。\n\n数值和输出要求：\n- 对于每种情况，使用推导的方法构建 PSF，并为两个 $\\lambda$ 值分别计算 FWHM。PSF 必须在周期性边界条件下，使用循环结构所暗示的基于 DFT 的方法进行计算。\n- 最终程序输出必须是单行，包含一个 Python 风格的列表，内含六个四舍五入到六位小数的浮点数，顺序如下：\n  $[\\text{情况 1 的 } \\mathrm{FWHM}(\\lambda_{1}),\\ \\text{情况 1 的 } \\mathrm{FWHM}(\\lambda_{2}),\\ \\text{情况 2 的 } \\mathrm{FWHM}(\\lambda_{1}),\\ \\text{情况 2 的 } \\mathrm{FWHM}(\\lambda_{2}),\\ \\text{情况 3 的 } \\mathrm{FWHM}(\\lambda_{1}),\\ \\text{情况 3 的 } \\mathrm{FWHM}(\\lambda_{2})]$。\n- 所有宽度必须以网格单位表示，并以四舍五入到六位小数的实数形式给出。\n- 你的程序必须完全独立，不得读取输入，也不得访问外部资源。它必须仅按所描述的精确格式生成唯一的所需输出行。", "solution": "该问题要求推导并实现一种方法，用于计算 Tikhonov 正则化线性反问题中点扩散函数（PSF）的半峰全宽（FWHM）。\n\n### 第 1 部分：理论推导\n\n分析从需要最小化的 Tikhonov 泛函开始：\n$$\nJ(m) = \\| A m - d \\|_{C_{n}^{-1}}^{2} + \\lambda^{2} \\| m \\|_{2}^{2}\n$$\n给定噪声协方差 $C_{n} = \\sigma^{2} I$，其逆为 $C_{n}^{-1} = (\\sigma^{2})^{-1} I$。该泛函简化为：\n$$\nJ(m) = \\frac{1}{\\sigma^{2}} \\| A m - d \\|_{2}^{2} + \\lambda^{2} \\| m \\|_{2}^{2} = \\frac{1}{\\sigma^{2}} (A m - d)^{\\top}(A m - d) + \\lambda^{2} m^{\\top}m\n$$\n为了找到唯一的最小化子 $\\hat{m}$，我们将 $J(m)$ 对 $m$ 的梯度设为零。\n$$\n\\nabla_{m} J(m) = \\frac{\\partial}{\\partial m} \\left( \\frac{1}{\\sigma^{2}} (m^{\\top}A^{\\top}Am - 2d^{\\top}Am + d^{\\top}d) + \\lambda^{2} m^{\\top}m \\right)\n$$\n使用标准矩阵求导恒等式 $\\nabla_x(x^{\\top}Bx) = (B+B^{\\top})x$（对于对称矩阵 $B$ 可简化为 $2Bx$）和 $\\nabla_x(b^{\\top}x) = b$，我们得到梯度：\n$$\n\\nabla_{m} J(m) = \\frac{1}{\\sigma^{2}} (2 A^{\\top} A m - 2 A^{\\top} d) + 2 \\lambda^{2} m\n$$\n将最优估计 $\\hat{m}$ 的梯度设为零：\n$$\n\\frac{1}{\\sigma^{2}} (2 A^{\\top} A \\hat{m} - 2 A^{\\top} d) + 2 \\lambda^{2} \\hat{m} = 0\n$$\n两边乘以 $\\sigma^2/2$ 并重新整理，得到该正则化问题的正规方程：\n$$\n(A^{\\top} A + \\sigma^{2} \\lambda^{2} I) \\hat{m} = A^{\\top} d\n$$\n求解 $\\hat{m}$ 得到正则化解的表达式：\n$$\n\\hat{m} = (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} d\n$$\n分辨率矩阵 $R$ 由估计值的期望 $\\mathbb{E}[\\hat{m}]$ 和真实模型 $m_{\\text{true}}$ 之间的关系定义，即 $\\mathbb{E}[\\hat{m}] = R m_{\\text{true}}$。期望是针对噪声分布计算的。将正向模型 $d = A m_{\\text{true}} + n$ 代入 $\\hat{m}$ 的表达式中：\n$$\n\\mathbb{E}[\\hat{m}] = \\mathbb{E}[ (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} (A m_{\\text{true}} + n) ]\n$$\n利用期望的线性性质以及噪声是零均值的事实（$\\mathbb{E}[n]=0$）：\n$$\n\\mathbb{E}[\\hat{m}] = (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} A m_{\\text{true}} + (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} \\mathbb{E}[n]\n$$\n$$\n\\mathbb{E}[\\hat{m}] = (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} A m_{\\text{true}}\n$$\n通过将此结果与分辨率矩阵的定义进行比较，我们得到其显式形式：\n$$\nR = (A^{\\top} A + \\sigma^{2} \\lambda^{2} I)^{-1} A^{\\top} A\n$$\n问题指定了周期性边界条件，这意味着卷积算子 $A$ 是一个循环矩阵。循环矩阵的一个基本性质是它们可以被离散傅里叶变换（DFT）对角化。设 $F$ 为 DFT 矩阵。我们可以写出 $A = F^{-1} \\Lambda_A F$，其中 $\\Lambda_A$ 是一个对角矩阵，其对角元是 $A$ 的特征值。这些特征值是 $A$ 的第一列（即卷积核 $k$）的 DFT。令 $\\tilde{k} = \\mathcal{F}(k)$ 为这些特征值的向量。\n\n转置 $A^{\\top}$ 也是循环矩阵，其特征值是 $A$ 特征值的复共轭。因此，$A^{\\top} = F^{-1} \\Lambda_A^* F$，其中 $\\Lambda_A^*$ 的对角线包含 $\\overline{\\tilde{k}}$。乘积 $A^{\\top}A$ 变为：\n$$\nA^{\\top} A = (F^{-1} \\Lambda_A^* F)(F^{-1} \\Lambda_A F) = F^{-1} (\\Lambda_A^* \\Lambda_A) F = F^{-1} |\\Lambda_A|^2 F\n$$\n其中 $|\\Lambda_A|^2$ 是对角元为 $|\\tilde{k}_i|^2$ 的对角矩阵。将此代入 $R$ 的表达式中：\n$$\nR = (F^{-1} |\\Lambda_A|^2 F + \\sigma^{2} \\lambda^{2} I)^{-1} (F^{-1} |\\Lambda_A|^2 F)\n$$\n使用 $I = F^{-1}IF$ 以及矩阵求逆的性质：\n$$\nR = [F^{-1} (|\\Lambda_A|^2 + \\sigma^{2} \\lambda^{2}I) F]^{-1} (F^{-1} |\\Lambda_A|^2 F) = [F^{-1} (|\\Lambda_A|^2 + \\sigma^{2} \\lambda^{2}I)^{-1} F] (F^{-1} |\\Lambda_A|^2 F)\n$$\n$$\nR = F^{-1} [ (|\\Lambda_A|^2 + \\sigma^{2} \\lambda^{2}I)^{-1} |\\Lambda_A|^2 ] F\n$$\n这表明 $R$ 也是一个循环矩阵。它的特征值（我们用向量 $\\tilde{r}$ 表示）由分辨率传递函数给出：\n$$\n\\tilde{r}_i = \\frac{|\\tilde{k}_{i}|^2}{|\\tilde{k}_{i}|^2 + \\sigma^2 \\lambda^2}\n$$\nPSF 是 $R$ 的一列。由于 $R$ 是循环矩阵，其各列是其第一列的移位版本。$R$ 的第一列是通过对其特征值 $\\tilde{r}$ 应用逆 DFT 得到的：\n$$\n\\text{psf}_{\\text{uncentered}} = \\mathcal{F}^{-1}(\\tilde{r})\n$$\n指定的核函数是实数且对称的，因此它们的 DFT $\\tilde{k}$ 是实数。这使得 $\\tilde{r}$ 也是实数且对称的，从而确保得到的 PSF 关于索引 0 是实数且对称的。然后将 PSF 循环移位，使其中心位于索引 $j = \\lfloor N/2 \\rfloor$。\n\n### 第 2 部分：实现策略\n\nFWHM 的计算遵循以下步骤：\n1.  **核函数构建**：对于给定的测试用例，构建大小为 $N$ 的离散卷积核 $k$。对于高斯核，使用周期性距离 $\\mathrm{dist}(n,0) = \\min\\{ |n|, N-|n| \\}$ 来定义核函数，然后将其归一化使其总和为 1。对于 delta 核函数，使用索引 0 处的单位脉冲。\n2.  **傅里叶变换**：使用 `scipy.fft.fft` 计算核函数的 DFT，即 $\\tilde{k} = \\mathcal{F}(k)$。\n3.  **传递函数**：使用推导的公式计算每个频率分量的分辨率传递函数 $\\tilde{r}$。\n4.  **PSF 计算**：通过逆 DFT 计算未中心化的 PSF，$p = \\mathcal{F}^{-1}(\\tilde{r})$，使用 `scipy.fft.ifft`。取其实部以丢弃由数值精度误差引起的可以忽略的虚部。\n5.  **中心化与归一化**：将 PSF 循环移位 $\\lfloor N/2 \\rfloor$ 个位置以使其峰值居中。然后通过除以其最大值进行归一化，使峰值振幅为 1。\n6.  **FWHM 计算**：对于归一化、对称的 PSF，通过找到其值跨越 0.5 的两个相邻网格点并应用线性插值，来找到右半峰值交叉点 $x_{\\text{right}}$。FWHM 则是 $2 \\times (x_{\\text{right}} - \\lfloor N/2 \\rfloor)$。对所有测试用例和参数重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the FWHM for each test case.\n    The final output is a single line containing a list of FWHM values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 257, 'sigma_noise': 0.1, 'kernel_type': 'gaussian', 'sigma_k': 2.0, 'lambdas': [0.2, 2.0]},\n        {'N': 257, 'sigma_noise': 0.1, 'kernel_type': 'gaussian', 'sigma_k': 0.8, 'lambdas': [0.2, 2.0]},\n        {'N': 257, 'sigma_noise': 0.1, 'kernel_type': 'delta', 'sigma_k': None, 'lambdas': [0.2, 2.0]},\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        for lambda_reg in case['lambdas']:\n            fwhm = calculate_psf_and_fwhm(\n                N=case['N'],\n                sigma_noise=case['sigma_noise'],\n                kernel_type=case['kernel_type'],\n                sigma_k=case['sigma_k'],\n                lambda_reg=lambda_reg\n            )\n            results.append(f\"{fwhm:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_psf_and_fwhm(N, sigma_noise, kernel_type, sigma_k, lambda_reg):\n    \"\"\"\n    Constructs the PSF and computes its FWHM for a given set of parameters.\n    \n    Args:\n        N (int): Grid size.\n        sigma_noise (float): Standard deviation of the additive noise.\n        kernel_type (str): Type of convolution kernel ('gaussian' or 'delta').\n        sigma_k (float or None): Standard deviation of the Gaussian kernel.\n        lambda_reg (float): Tikhonov regularization parameter.\n        \n    Returns:\n        float: The computed FWHM in grid units.\n    \"\"\"\n    # Step 1: Construct the convolution kernel k\n    if kernel_type == 'gaussian':\n        n = np.arange(N)\n        # Circular distance from origin for periodic boundary conditions\n        dist = np.minimum(n, N - n)\n        kernel = np.exp(-0.5 * (dist / sigma_k)**2)\n        # Normalize so that the kernel sums to 1\n        kernel /= np.sum(kernel)\n    elif kernel_type == 'delta':\n        kernel = np.zeros(N)\n        kernel[0] = 1.0\n    else:\n        raise ValueError(\"Unknown kernel type specified.\")\n\n    # Step 2: Compute the DFT of the kernel\n    k_tilde = fft.fft(kernel)\n\n    # Step 3: Compute the resolution transfer function r_tilde\n    k_tilde_mag_sq = np.abs(k_tilde)**2\n    sigma_lambda_sq = (sigma_noise * lambda_reg)**2\n    r_tilde = k_tilde_mag_sq / (k_tilde_mag_sq + sigma_lambda_sq)\n\n    # Step 4: Compute the PSF via inverse DFT\n    # For a real and symmetric r_tilde, the ifft is real. We take np.real to handle\n    # potential floating point inaccuracies.\n    psf_uncentered = np.real(fft.ifft(r_tilde))\n\n    # Step 5: Center the PSF at index N // 2\n    center_index = N // 2\n    psf_centered = np.roll(psf_uncentered, center_index)\n\n    # Step 6: Normalize the PSF to have a peak value of 1\n    psf_max = np.max(psf_centered)\n    if psf_max > 0:\n        psf_normalized = psf_centered / psf_max\n    else:\n        # Handle the case of a zero PSF, though unlikely\n        psf_normalized = psf_centered\n\n    # Step 7: Compute the FWHM\n    fwhm = compute_fwhm_from_psf(psf_normalized)\n    \n    return fwhm\n\ndef compute_fwhm_from_psf(psf):\n    \"\"\"\n    Computes the Full Width at Half Maximum for a normalized, centered PSF.\n    \n    Args:\n        psf (np.ndarray): A 1D array representing the centered, normalized PSF.\n        \n    Returns:\n        float: The FWHM value.\n    \"\"\"\n    N = len(psf)\n    center_index = N // 2\n    half_max = 0.5\n    \n    # Check if PSF is a delta function (only one non-zero point at the center)\n    if psf[center_index] == 1.0 and np.sum(psf) == 1.0:\n        # By our linear interpolation definition between grid points [c] and [c+1]\n        # with values 1.0 and 0.0, the half-max is crossed at c+0.5.\n        # FWHM = 2 * ((c+0.5) - c) = 1.0\n        return 1.0\n\n    # Search for the crossing on the right side of the center\n    # Find the index of the first point that drops below half_max\n    try:\n        # `[0]` accesses the array from the tuple, `[0]` gets the first index\n        first_idx_below_rel = np.where(psf[center_index:]  half_max)[0][0]\n    except IndexError:\n        # This occurs if the PSF never drops below 0.5, e.g., if it's broad and flat.\n        #  In this case, the FWHM is arguably the width of the domain.\n        return float(N)\n\n    # The point just before this one is above or at half_max\n    idx_above_rel = first_idx_below_rel - 1\n    \n    # Get absolute indices in the full PSF array\n    idx_above_abs = center_index + idx_above_rel\n    idx_below_abs = center_index + first_idx_below_rel\n\n    # Get values and coordinates for linear interpolation\n    y1 = psf[idx_above_abs]  # Value >= 0.5\n    y2 = psf[idx_below_abs]  # Value  0.5\n    \n    x1 = float(idx_above_abs)\n    x2 = float(idx_below_abs)\n\n    # Linear interpolation to find x_right where y = half_max\n    # x = x1 + (y - y1) * (x2 - x1) / (y2 - y1)\n    if (y2 - y1) == 0:\n         # Avoid division by zero, though unlikely if y1 > 0.5 and y2  0.5\n         x_right = (x1 + x2) / 2.0\n    else:\n         x_right = x1 + (half_max - y1) * (x2 - x1) / (y2 - y1)\n         \n    # Due to symmetry, FWHM is twice the distance from the center to the right crossing\n    fwhm = 2.0 * (x_right - float(center_index))\n    \n    return fwhm\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3417719"}, {"introduction": "在理想情况下，我们精确地知道造成数据模糊的点扩散函数（PSF）。然而在现实世界中，我们使用的前向模型（即我们假设的 PSF）往往与真实物理过程存在偏差。本练习将探讨这种模型失配的后果，您将比较使用正确与不正确的 PSF 进行反演时，分辨率算子的差异。通过分析过度锐化和伪影等现象，您将深刻理解为何一个准确的前向模型对于获得可靠的反演结果至关重要。[@problem_id:3417750]", "problem": "考虑一个长度为 $N$、单位网格间距的一维周期性网格。令正演算子 $H$ 为与点扩散函数 (PSF) $P$ 的循环卷积，因此对于真实模型 $m_{\\text{true}}$ 和数据 $d$，我们有\n$$\nd = H\\,m_{\\text{true}} + n,\n$$\n其中 $n$ 表示加性噪声，该噪声是白噪声且已被预白化至单位方差。假设一位分析师使用一个假定的 PSF $\\tilde{P}$ 和一个单位正则化算子来构建一个二次惩罚（吉洪诺夫）估计器，旨在寻求一个估计值 $\\hat{m}$，该估计值能最小化\n$$\n\\| \\tilde{H}\\,m - d \\|_2^2 + \\alpha^2 \\| m \\|_2^2,\n$$\n其中 $\\tilde{H}$ 是与 $\\tilde{P}$ 的循环卷积，$\\alpha0$ 是正则化参数。该线性估计器可以写成 $\\hat{m} = W\\,d$ 的形式，其中算子 $W$ 由 $(\\tilde{H},\\alpha)$ 决定。相对于真实正演映射 $H$ 的分辨率算子（也称为平均核）定义为\n$$\nA = W\\,H,\n$$\n因此（在无噪声的情况下）均值估计满足 $\\hat{m} = A\\,m_{\\text{true}}$。\n\n您将在周期性边界条件下，在离散傅里叶域中进行操作。您只需利用以下基本事实：循环卷积可通过离散傅里叶变换对角化，以及通过最小化严格凸二次泛函得到的二次惩罚估计器是线性的。您需要：\n- 从二次最小化问题的正规方程和离散傅里叶变换对循环卷积的对角化出发，推导在正确指定情况（$\\tilde{P}=P$）和错误指定情况（$\\tilde{P}\\neq P$）下 $A$ 的频率响应表达式。\n- 对离散 PSF $P$ 和 $\\tilde{P}$ 进行这些表达式的数值实现。这些 PSF 是标准差分别为 $\\sigma$ 和 $\\tilde{\\sigma}$（以网格单位度量）的循环包裹的离散高斯函数，并被归一化以使其总和为1。具体来说，在索引 $n\\in\\{0,1,\\dots,N-1\\}$ 上定义的离散 PSF 为\n$$\nP[n] \\propto \\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{\\min(n,\\,N-n)}{\\sigma}\\right)^2\\right),\n$$\n并通过归一化强制 $\\sum_{n=0}^{N-1} P[n] = 1$。$\\tilde{P}$ 和 $\\tilde{\\sigma}$ 的定义与此类似。\n- 通过对其频率响应进行逆变换，计算正确指定和错误指定情况下在空间域中的离散分辨率核（在周期性边界条件下 $A$ 的第一行）。\n\n按如下方式量化分辨率和伪影：\n- 令 $a_{\\text{cor}}[n]$ 表示正确情况下的分辨率核，$a_{\\text{mis}}[n]$ 表示错误指定情况下的分辨率核。对于任何在索引 0 处有全局最大值的偶核 $a[n]$，将其半峰全宽 (FWHM)（以网格单位度量）定义为 $2x_{1/2}$，其中 $x_{1/2}\\ge 0$ 是这样一个最小非负实数：当从 $n=0$ 向正索引移动时，在网格点之间进行线性插值的核函数首次穿过其峰值的一半。在首次跨越半最大值点的连续索引对之间使用线性插值。\n- 定义过锐化比为\n$$\nr = \\frac{\\text{FWHM}(a_{\\text{mis}})}{\\text{FWHM}(a_{\\text{cor}})}.\n$$\n$r  1$ 的值表示相对于正确指定情况存在过锐化（即分辨率核比应有的更窄）。\n- 对于核 $a[n]$，定义主瓣外的伪影比为\n$$\n\\eta(a) = \\frac{\\sum_{n=0}^{N-1} |a[n]| - \\sum_{|n|\\le \\lfloor x_{1/2}\\rfloor} |a[n]|}{\\sum_{n=0}^{N-1} |a[n]|},\n$$\n其中索引区间 $|n|\\le \\lfloor x_{1/2}\\rfloor$ 表示集合 $\\{0,1,\\dots,\\lfloor x_{1/2}\\rfloor\\}$ 及其模N的对称对应部分。利用周期性对称性和偶性来考虑两侧。定义错误指定下的伪影增量为\n$$\n\\Delta \\eta = \\eta(a_{\\text{mis}}) - \\eta(a_{\\text{cor}}).\n$$\n- 对于核 $a[n]$，定义最负旁瓣振幅为 $\\min_n a[n]$。\n\n您的程序必须使用离散傅里叶变换实现以上步骤，以获取给定测试套件的正确情况和错误指定情况下的分辨率核。对于每个测试用例，计算并返回一个三元组 $[r, \\Delta\\eta, \\min_n a_{\\text{mis}}[n]]$，其中的值为浮点数。\n\n测试套件（每个用例为 $(N,\\sigma,\\tilde{\\sigma},\\alpha)$）：\n- 用例1：$(512, 3.0, 3.0, 0.1)$。\n- 用例2：$(512, 3.0, 2.0, 0.1)$。\n- 用例3：$(512, 3.0, 4.5, 0.1)$。\n- 用例4：$(512, 3.0, 2.0, 0.5)$。\n- 用例5：$(512, 3.0, 2.0, 0.01)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个项目本身是对应测试用例的三个逗号分隔浮点数列表，顺序为 $[r, \\Delta\\eta, \\min a_{\\text{mis}}]$，例如：[[r1,DeltaEta1,minMis1],[r2,DeltaEta2,minMis2],...]。不允许外部输入，所有计算都必须假设周期性边界条件并遵循上述定义。所有角度（如果出现）必须以弧度为单位，但此处没有出现角度。不涉及物理单位；所有网格单位都是无量纲的。", "solution": "问题陈述已经过仔细审查，并被确定为有效。它在科学上基于反演问题理论的原理，特别是吉洪诺夫正则化和分辨率分析。该问题是适定的、客观的，并为唯一的、可验证的解提供了一套完整且一致的定义和数据。\n\n问题的核心是推导和计算一个线性反演问题的分辨率算子，包括当系统的点扩散函数 (PSF) 模型正确和错误指定两种情况。我们将在离散傅里叶域中进行操作，在该域中循环卷积变为简单的乘法。\n\n### 分辨率算子频率响应的推导\n\n给定一个需要最小化的吉洪诺夫正则化代价泛函：\n$$\nJ(m) = \\| \\tilde{H}m - d \\|_2^2 + \\alpha^2 \\| m \\|_2^2\n$$\n在此，$m$ 是我们寻求的模型向量，$d$ 是数据向量，$\\tilde{H}$ 是基于假定 PSF $\\tilde{P}$ 的正演算子，$\\alpha  0$ 是正则化参数。范数 $\\| \\cdot \\|_2$ 是欧几里得范数。算子 $\\tilde{H}$ 表示与 $\\tilde{P}$ 的循环卷积。\n\n为了找到最小化 $J(m)$ 的模型估计 $\\hat{m}$，我们计算 $J(m)$ 关于 $m$ 的梯度并将其设为零。对于实值模型和算子，这给出：\n$$\n\\nabla_m J(m) = 2 \\tilde{H}^T (\\tilde{H}m - d) + 2 \\alpha^2 m = 0\n$$\n其中 $\\tilde{H}^T$ 是 $\\tilde{H}$ 的转置。在更一般的复数情况下，转置被共轭转置 $\\tilde{H}^*$ 替代。重新排列各项以求解 $m$ 可得到正规方程：\n$$\n(\\tilde{H}^T \\tilde{H} + \\alpha^2 I) m = \\tilde{H}^T d\n$$\n其中 $I$ 是单位算子。因此，解 $\\hat{m}$ 由下式给出：\n$$\n\\hat{m} = (\\tilde{H}^T \\tilde{H} + \\alpha^2 I)^{-1} \\tilde{H}^T d\n$$\n这将估计值 $\\hat{m}$ 表示为数据 $d$ 的一个线性变换。我们已知 $\\hat{m} = Wd$，所以估计器算子 $W$ 是：\n$$\nW = (\\tilde{H}^T \\tilde{H} + \\alpha^2 I)^{-1} \\tilde{H}^T\n$$\n分辨率算子（或平均核）$A$ 通过 $\\hat{m} = A m_{\\text{true}}$（在无噪声的情况下，此时 $d = H m_{\\text{true}}$）将均值估计与真实模型 $m_{\\text{true}}$ 关联起来。其定义为 $A = WH$。代入 $W$ 和 $d$ 的表达式：\n$$\n\\hat{m} = Wd = W(H m_{\\text{true}}) = (WH) m_{\\text{true}}\n$$\n因此，分辨率算子是：\n$$\nA = W H = (\\tilde{H}^T \\tilde{H} + \\alpha^2 I)^{-1} \\tilde{H}^T H\n$$\n该问题设置在周期性网格上，因此循环卷积算子可由离散傅里叶变换 (DFT) 对角化。令 $\\mathcal{F}$ 表示 DFT 算子。任何带有核 $c$ 的循环卷积算子 $C$ 都可以被对角化为 $C = \\mathcal{F}^{-1} D_c \\mathcal{F}$，其中 $D_c$ 是一个对角矩阵，其对角线元素是核 $c$ 的 DFT，记为 $\\hat{c}$。算子的频率响应就是这组对角线元素。\n\n算子 $H$ 和 $\\tilde{H}$ 在傅里叶域中对应于对角矩阵，其对角线元素分别为 $\\hat{P}[k]$ 和 $\\hat{P}_{\\text{tilde}}[k]$，即真实 PSF $P$ 和假定 PSF $\\tilde{P}$ 的 DFT。共轭转置 $\\tilde{H}^*$（对于实核，即为 $\\tilde{H}^T$）对应于一个对角线元素为 $\\hat{P}_{\\text{tilde}}[k]^*$ 的对角矩阵。\n\n将 $A$ 的表达式变换到傅里叶域，每个算子都被其对应的频率响应对角矩阵所取代。$A$ 的频率响应的第 $k$ 个分量，记为 $\\hat{A}[k]$，是：\n$$\n\\hat{A}[k] = \\frac{1}{|\\hat{P}_{\\text{tilde}}[k]|^2 + \\alpha^2} \\cdot \\hat{P}_{\\text{tilde}}[k]^* \\cdot \\hat{P}[k]\n$$\n给定的 PSF 是实数且对称的（对于 $n \\neq 0$ 有 $P[n] = P[N-n]$），因此它们的 DFT $\\hat{P}[k]$ 和 $\\hat{P}_{\\text{tilde}}[k]$ 是实值的。表达式简化为：\n$$\n\\hat{A}[k] = \\frac{\\hat{P}_{\\text{tilde}}[k] \\hat{P}[k]}{\\hat{P}_{\\text{tilde}}[k]^2 + \\alpha^2}\n$$\n这就是分辨率算子的通用频率响应。我们现在考虑两种指定的情况。\n\n1.  **正确指定情况 ($\\tilde{P} = P$):**\n    如果假定的 PSF 是正确的，即 $\\tilde{P} = P$，这意味着 $\\hat{P}_{\\text{tilde}}[k] = \\hat{P}[k]$。分辨率算子的频率响应 $\\hat{A}_{\\text{cor}}$ 变为：\n    $$\n    \\hat{A}_{\\text{cor}}[k] = \\frac{\\hat{P}[k]^2}{\\hat{P}[k]^2 + \\alpha^2}\n    $$\n\n2.  **错误指定情况 ($\\tilde{P} \\neq P$):**\n    如果假定的 PSF 是不正确的，通用公式直接适用于频率响应 $\\hat{A}_{\\text{mis}}$：\n    $$\n    \\hat{A}_{\\text{mis}}[k] = \\frac{\\hat{P}_{\\text{tilde}}[k] \\hat{P}[k]}{\\hat{P}_{\\text{tilde}}[k]^2 + \\alpha^2}\n    $$\n\n### 数值实现\n\n实现过程如下：\n1.  **PSF 生成：** 对于给定的参数 $(N, \\sigma)$，使用公式 $P[n] \\propto \\exp(-\\frac{1}{2}(\\frac{\\min(n, N-n)}{\\sigma})^2)$ (其中 $n \\in \\{0, 1, ..., N-1\\}$) 生成一个离散的、循环包裹的高斯 PSF。将生成的向量归一化，使其总和为 1。对 $(\\sigma)$ 和 $(\\tilde{\\sigma})$ 分别执行此操作，以得到 $P$ 和 $\\tilde{P}$。\n2.  **傅里叶变换：** 使用 `numpy.fft.fft` 计算 $P$ 和 $\\tilde{P}$ 的 DFT。如前所述，得到的频域表示 $\\hat{P}$ 和 $\\hat{P}_{\\text{tilde}}$ 是实值的。\n3.  **分辨率核：** 使用推导出的公式计算频率响应 $\\hat{A}_{\\text{cor}}[k]$ 和 $\\hat{A}_{\\text{mis}}[k]$。然后通过应用逆 DFT (`numpy.fft.ifft`) 获得空间域分辨率核 $a_{\\text{cor}}[n]$ 和 $a_{\\text{mis}}[n]$。得到的核是实数且对称的，中心在索引 $n=0$ 处。\n4.  **度量计算：** 从空间核计算所需的度量：\n    - **FWHM：** 为每个核计算半峰全宽。由于核的中心在 $n=0$ 处，我们找到最小的非负值 $x_{1/2}$，使得线性插值的核值等于其峰值的一半，即 $a[0]/2$。FWHM 是 $2x_{1/2}$。这涉及到找到第一个网格区间 $[i, i+1]$，其中 $a[i] \\ge a[0]/2$ 且 $a[i+1]  a[0]/2$，然后进行线性插值。\n    - **过锐化比 ($r$)：** 计算比率 $\\text{FWHM}(a_{\\text{mis}}) / \\text{FWHM}(a_{\\text{cor}})$。\n    - **伪影比 ($\\eta$)：** 对每个核，计算伪影比 $\\eta(a)$，即位于中央主瓣之外的总绝对质量的分数。主瓣由整数索引 $|n| \\le \\lfloor x_{1/2} \\rfloor$ 定义。\n    - **伪影增量 ($\\Delta\\eta$)：** 计算差值 $\\eta(a_{\\text{mis}}) - \\eta(a_{\\text{cor}})$。\n    - **最负旁瓣：** 找到 $a_{\\text{mis}}$ 核的最小值。\n\n对每个测试用例应用此过程，以生成所需的输出三元组 $[r, \\Delta\\eta, \\min_n a_{\\text{mis}}[n]]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef create_psf(N, sigma):\n    \"\"\"\n    Creates a normalized, circularly wrapped 1D discrete Gaussian PSF.\n    \"\"\"\n    if sigma == 0:\n        psf = np.zeros(N)\n        psf[0] = 1.0\n        return psf\n    n_indices = np.arange(N)\n    distances = np.minimum(n_indices, N - n_indices)\n    psf = np.exp(-0.5 * (distances / sigma)**2)\n    psf /= np.sum(psf)\n    return psf\n\ndef calculate_x_half(kernel):\n    \"\"\"\n    Calculates the half-width at half-maximum (x_1/2) for a centered kernel.\n    Uses linear interpolation to find the crossing point.\n    \"\"\"\n    N = len(kernel)\n    peak_value = kernel[0]\n    \n    if peak_value = 0:\n        return float('inf') # FWHM is not well-defined\n\n    half_peak = peak_value / 2.0\n\n    # Search for the first crossing of the half-peak value on the positive index side\n    for i in range(N // 2):\n        if kernel[i] >= half_peak and kernel[i+1]  half_peak:\n            y1, y2 = kernel[i], kernel[i+1]\n            x1 = i\n            # Avoid division by zero if kernel is flat\n            if (y1 - y2) == 0:\n                return float(i)\n            # Linear interpolation to find x_half\n            x_half = x1 + (y1 - half_peak) / (y1 - y2)\n            return x_half\n            \n    # If no crossing is found, kernel is wider than half the domain\n    return float(N // 2)\n\ndef calculate_eta(kernel, x_half):\n    \"\"\"\n    Calculates the artifact ratio eta for a given kernel and its x_1/2.\n    \"\"\"\n    N = len(kernel)\n    total_abs_sum = np.sum(np.abs(kernel))\n    if total_abs_sum == 0:\n        return 0.0\n\n    main_lobe_limit = int(np.floor(x_half))\n    \n    # Sum absolute values over the main lobe, defined by |n| = floor(x_1/2)\n    main_lobe_abs_sum = np.abs(kernel[0])\n    if main_lobe_limit > 0:\n        # Sum for positive indices: 1, ..., limit\n        main_lobe_abs_sum += np.sum(np.abs(kernel[1:main_lobe_limit + 1]))\n        # Sum for negative indices (periodic): N-limit, ..., N-1\n        main_lobe_abs_sum += np.sum(np.abs(kernel[N - main_lobe_limit:]))\n\n    eta = (total_abs_sum - main_lobe_abs_sum) / total_abs_sum\n    return eta\n\ndef analyze_resolution(N, sigma, sigma_tilde, alpha):\n    \"\"\"\n    Performs the full resolution analysis for a single test case.\n    \"\"\"\n    # 1. Generate true and assumed PSFs\n    P = create_psf(N, sigma)\n    P_tilde = create_psf(N, sigma_tilde)\n\n    # 2. Compute their DFTs.\n    # Since PSFs are real and symmetric, their FFTs will be real.\n    hat_p = np.fft.fft(P).real\n    hat_p_tilde = np.fft.fft(P_tilde).real\n\n    # 3. Compute frequency responses of resolution operators\n    # Correctly specified case\n    hat_A_cor = (hat_p**2) / (hat_p**2 + alpha**2)\n    # Mis-specified case\n    hat_A_mis = (hat_p_tilde * hat_p) / (hat_p_tilde**2 + alpha**2)\n\n    # 4. Compute spatial resolution kernels via inverse DFT\n    # Resulting kernels are real and symmetric (centered at index 0)\n    a_cor = np.fft.ifft(hat_A_cor).real\n    a_mis = np.fft.ifft(hat_A_mis).real\n\n    # 5. Calculate metrics for both kernels\n    # Correct case\n    x_half_cor = calculate_x_half(a_cor)\n    fwhm_cor = 2.0 * x_half_cor\n    eta_cor = calculate_eta(a_cor, x_half_cor)\n\n    # Mis-specified case\n    x_half_mis = calculate_x_half(a_mis)\n    fwhm_mis = 2.0 * x_half_mis\n    eta_mis = calculate_eta(a_mis, x_half_mis)\n    min_a_mis = np.min(a_mis)\n\n    # 6. Compute final quantities\n    if fwhm_cor == 0:  # Avoid division by zero\n        r = float('inf') if fwhm_mis > 0 else 1.0\n    else:\n        r = fwhm_mis / fwhm_cor\n\n    delta_eta = eta_mis - eta_cor\n\n    return [r, delta_eta, min_a_mis]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (512, 3.0, 3.0, 0.1),\n        (512, 3.0, 2.0, 0.1),\n        (512, 3.0, 4.5, 0.1),\n        (512, 3.0, 2.0, 0.5),\n        (512, 3.0, 2.0, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, sigma, sigma_tilde, alpha = case\n        result = analyze_resolution(N, sigma, sigma_tilde, alpha)\n        results.append(result)\n\n    # Prepare the output string in the exact required format\n    # Example: [[r1,d1,m1],[r2,d2,m2]]\n    result_strings = []\n    for res in results:\n        # Format each triplet [r, delta_eta, min_a_mis]\n        # to ensure no spaces and standard float representation\n        triplet_str = f\"[{res[0]},{res[1]},{res[2]}]\"\n        result_strings.append(triplet_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3417750"}, {"introduction": "分辨率分析的应用远不止于图像处理，它在地球科学等领域的数据同化中也扮演着核心角色，例如评估天气观测网络的有效性。在本练习中，您将把分辨率的概念推广到更一般化的平均核矩阵（averaging kernel matrix），并用它来评估不同传感器网络的设计。通过计算信号自由度（DFS）和代表性点扩散函数的宽度，您将学会如何从量化的角度比较不同观测系统约束真实状态的能力。[@problem_id:3417773]", "problem": "给定一个一维线性高斯数据同化设定，其空间状态位于一条线段上，并有两个由不同观测算子表示的独立传感器网络。对于每种情景，两个网络的背景误差协方差和观测误差协方差是相同的。您的任务是，在每种情景下，为每个传感器网络计算信号自由度（DFS）和代表性点扩散函数（PSF）的半峰全宽（FWHM），然后按规定汇总结果。\n\n基本原理和定义：\n- 数据同化更新是带有加性误差的线性高斯过程。空间状态表示为 $x \\in \\mathbb{R}^N$，观测向量为 $y \\in \\mathbb{R}^M$，观测算子为 $H \\in \\mathbb{R}^{M \\times N}$，背景误差协方差为 $B \\in \\mathbb{R}^{N \\times N}$，观测误差协方差为 $R \\in \\mathbb{R}^{M \\times M}$。\n- 卡尔曼增益 $K \\in \\mathbb{R}^{N \\times M}$ 由经过充分检验的公式 $K = B H^\\top (H B H^\\top + R)^{-1}$ 定义。\n- 平均核（也称为分辨率矩阵）$A \\in \\mathbb{R}^{N \\times N}$ 定义为 $A = K H$，它量化了分析结果如何对真实状态的扰动做出线性响应。\n- 信号自由度（DFS）定义为 $\\mathrm{DFS} = \\mathrm{trace}(A)$。\n- 某个位置 $j$ 的点扩散函数（PSF）是矩阵 $A$ 的第 $j$ 列，它表示分析结果对真实状态中索引 $j$ 处单位脉冲响应的空间分布。代表性PSF取自中心网格索引 $j_0 = \\lfloor N/2 \\rfloor$。\n- 半峰全宽（FWHM）是在PSF最大振幅一半处测得的PSF宽度（以物理单位计）。它必须以公里为单位计算。\n\n空间域和离散化：\n- 空间域是一维区间 $[0,L]$，其中 $L$ 的单位为公里。状态在 $N$ 个等间距的网格点上进行离散化，点 $x_i$ 的位置为 $p_i = i \\,\\Delta x$（对于 $i = 0,1,\\dots,N-1$），其中 $\\Delta x = L/(N-1)$，单位为公里。\n\n协方差：\n- 背景误差协方差 $B$ 是使用高斯相关模型构建的，其方差为 $\\sigma_b^2$，相关长度为 $L_b$（单位为公里）：$B_{ij} = \\sigma_b^2 \\exp\\!\\left(-\\frac{(p_i - p_j)^2}{2 L_b^2}\\right)$。\n- 观测误差协方差 $R$ 是对角矩阵，对角线元素为 $\\sigma_r^2$（方差齐性），即 $R = \\sigma_r^2 I_M$。\n\n观测算子：\n- 每个传感器网络由一组沿 $[0,L]$ 的传感器位置 $\\{s_m\\}_{m=1}^M$ 定义，每个传感器测量的是状态的高斯加权局部平均值，其足迹宽度参数（标准差）为 $L_h$（单位为公里）。观测算子 $H$ 的行 $H_{m,:}$ 定义为\n$$\nH_{m,i} = \\frac{\\exp\\!\\left(-\\frac{(p_i - s_m)^2}{2 L_h^2}\\right)}{\\sum_{k=0}^{N-1} \\exp\\!\\left(-\\frac{(p_k - s_m)^2}{2 L_h^2}\\right)},\n$$\n因此每行之和为1。\n\n每个情景的计算任务：\n1. 使用指定的 $L$、$N$、$\\sigma_b^2$、$L_b$ 和 $\\sigma_r^2$ 构建 $B$ 和 $R$。\n2. 使用各自的传感器位置和足迹宽度构建两个不同的观测算子 $H^{(1)}$ 和 $H^{(2)}$。\n3. 对每个 $H$ 使用公式 $K = B H^\\top (H B H^\\top + R)^{-1}$ 计算卡尔曼增益 $K$。\n4. 对每个网络计算平均核 $A = K H$。\n5. 对每个网络计算 $\\mathrm{DFS} = \\mathrm{trace}(A)$。\n6. 提取 $A$ 的第 $j_0 = \\lfloor N/2 \\rfloor$ 列作为代表性PSF，并计算其FWHM（单位为公里）。FWHM必须通过对在网格位置 $p_i$ 处采样的PSF进行线性插值来确定左侧和右侧的半最大值交叉点。如果PSF的最大值为非正数，或者两个半最大值交叉点不都在域内，则将FWHM作为“非数值”返回。\n\n测试套件：\n对于每个情景，提供两个传感器网络，它们仅在观测算子 $H$ 上有所不同，而共享相同的 $B$ 和 $R$。\n\n- 情景 1：\n  - $L = 100$, $N = 50$, $\\sigma_b^2 = 1.0$, $L_b = 10$, $\\sigma_r^2 = 0.04$。\n  - 网络 1：$M_1 = 25$ 个传感器，位置在 $[0,L]$ 上均匀分布（包括端点），足迹宽度 $L_{h,1} = 4$。\n  - 网络 2：$M_2 = 8$ 个传感器，位置在 $[0,L]$ 上均匀分布（包括端点），足迹宽度 $L_{h,2} = 6$。\n\n- 情景 2：\n  - $L = 100$, $N = 50$, $\\sigma_b^2 = 1.0$, $L_b = 5$, $\\sigma_r^2 = 0.01$。\n  - 网络 1：$M_1 = 50$ 个传感器，位置在 $[0,L]$ 上均匀分布（包括端点），足迹宽度 $L_{h,1} = 2$。\n  - 网络 2：$M_2 = 4$ 个传感器，位置在 $[0,L]$ 上均匀分布（包括端点），足迹宽度 $L_{h,2} = 8$。\n\n- 情景 3：\n  - $L = 100$, $N = 50$, $\\sigma_b^2 = 1.0$, $L_b = 15$, $\\sigma_r^2 = 1.0$。\n  - 网络 1：$M_1 = 20$ 个传感器，位置在 $[0,L]$ 上均匀分布（包括端点），足迹宽度 $L_{h,1} = 4$。\n  - 网络 2：$M_2 = 20$ 个传感器，位置在 $[0,L]$ 上均匀分布，但偏移了标称传感器间距的一半（经裁剪以保持在 $[0,L]$ 范围内），足迹宽度 $L_{h,2} = 4$。\n\n要求的输出和单位：\n- 对于每个情景中的每个传感器网络，计算：\n  - DFS，作为一个浮点数（无单位）。\n  - 代表性PSF的FWHM，单位为公里，作为一个浮点数。\n- 最终程序输出必须是单行，包含一个用方括号括起来的逗号分隔列表，按以下顺序汇总结果：\n  $[\\mathrm{DFS}_{1,1},\\mathrm{FWHM}_{1,1},\\mathrm{DFS}_{1,2},\\mathrm{FWHM}_{1,2},\\mathrm{DFS}_{2,1},\\mathrm{FWHM}_{2,1},\\mathrm{DFS}_{2,2},\\mathrm{FWHM}_{2,2},\\mathrm{DFS}_{3,1},\\mathrm{FWHM}_{3,1},\\mathrm{DFS}_{3,2},\\mathrm{FWHM}_{3,2}]$，其中第一个索引表示情景编号，第二个索引表示情景内的网络编号。FWHM值必须以公里表示。如果无法按规定确定FWHM，则将其值输出为“非数值”浮点数。\n\n您的程序必须以指定格式精确生成一行输出，不得包含任何额外文本。无需输入；所有参数值均已在上方提供。", "solution": "经评估，此问题是有效的。它在科学上基于线性高斯数据同化的原理，问题是适定的，所有必要的参数和定义都已提供，并且陈述客观。计算任务明确且可行。\n\n求解过程是通过为三个情景中的每一个（每个情景包含两个传感器网络）执行定义的计算步骤来展开的。\n\n问题的核心在于计算平均核矩阵 $A \\in \\mathbb{R}^{N \\times N}$，该矩阵描述了估计状态（分析结果）如何成为真实状态的空间加权平均。分析结果 $x_a$ 通过方程 $x_a = x_b + K(y - Hx_b)$ 与背景状态 $x_b$ 和观测向量 $y$ 相关联，其中 $K$ 是卡尔曼增益。当考虑分析结果与真实状态 $x_t$ 之间的关系时，假设 $y = Hx_t + \\epsilon_r$ 和 $x_b = x_t + \\epsilon_b$（其中 $\\epsilon_r$ 和 $\\epsilon_b$ 分别是观测误差和背景误差），期望的分析结果为 $\\mathbb{E}[x_a] = (I - KH)x_b + KHy$。假设背景无偏 $\\mathbb{E}[x_b] = x_t$ 且观测无偏 $\\mathbb{E}[y] = Hx_t$，则分析结果也是无偏的：$\\mathbb{E}[x_a] = x_t$。矩阵 $A = KH$ 是平均核，它将分析扰动与真实状态扰动联系起来。\n\n每个网络的处理流程如下：\n\n1.  **离散化空间域**：将长度为 $L$ 的一维域离散化为 $N$ 个网格点。这些点的位置由 $p_i = i \\cdot \\Delta x$ 给出，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $\\Delta x = L/(N-1)$。\n\n2.  **构建协方差矩阵**：\n    *   背景误差协方差矩阵 $B \\in \\mathbb{R}^{N \\times N}$ 使用高斯相关函数构建。元素 $B_{ij}$ 表示网格点 $i$ 和 $j$ 处背景误差之间的协方差。\n        $$\n        B_{ij} = \\sigma_b^2 \\exp\\!\\left(-\\frac{(p_i - p_j)^2}{2 L_b^2}\\right)\n        $$\n        其中 $\\sigma_b^2$ 是背景误差方差，$L_b$ 是相关长度。\n    *   观测误差协方差矩阵 $R \\in \\mathbb{R}^{M \\times M}$ 假设为对角矩阵，表示观测误差不相关。对于方差齐性的误差，该矩阵是一个标量单位矩阵：\n        $$\n        R = \\sigma_r^2 I_M\n        $$\n        其中 $\\sigma_r^2$ 是观测误差方差，$I_M$ 是 $M \\times M$ 的单位矩阵。\n\n3.  **构建观测算子**：观测算子 $H \\in \\mathbb{R}^{M \\times N}$ 将状态空间映射到观测空间。$H$ 的每一行 $m$ 对应一个传感器，并定义为状态变量的归一化高斯加权平均。\n    $$\n    H_{m,i} = \\frac{\\exp\\!\\left(-\\frac{(p_i - s_m)^2}{2 L_h^2}\\right)}{\\sum_{k=0}^{N-1} \\exp\\!\\left(-\\frac{(p_k - s_m)^2}{2 L_h^2}\\right)}\n    $$\n    这里，$s_m$ 是第 $m$ 个传感器的位置，$L_h$ 是足迹宽度参数。分母确保 $H$ 的每一行之和为1，使得每次观测成为一个真正的加权平均。传感器位置根据每个网络指定的配置来确定。\n\n4.  **计算平均核**：\n    *   首先，计算卡尔曼增益矩阵 $K \\in \\mathbb{R}^{N \\times M}$。它提供了背景信息与新观测之间的最优加权。\n        $$\n        K = B H^\\top (H B H^\\top + R)^{-1}\n        $$\n    *   接着，计算平均核矩阵 $A \\in \\mathbb{R}^{N \\times N}$。\n        $$\n        A = K H\n        $$\n\n5.  **计算分辨率指标**：\n    *   **信号自由度（DFS）**：这个标量值衡量状态中可被观测约束的独立信号的数量。它是平均核的迹。\n        $$\n        \\mathrm{DFS} = \\mathrm{trace}(A)\n        $$\n    *   **半峰全宽（FWHM）**：该指标量化了分析结果的空间分辨率。点扩散函数（PSF）是平均核的一列 $A_{:,j}$，表示分析结果对真实状态在网格点 $j$ 处的δ函数扰动的响应。我们使用中心网格索引 $j_0 = \\lfloor N/2 \\rfloor$ 处的代表性PSF。FWHM是此PSF剖面在其最大振幅一半处的宽度。其计算包括：\n        1.  提取列向量 $A_{:,j_0}$。\n        2.  找到其最大值 $A_{\\max}$。\n        3.  确定半最大值 $A_{\\max}/2$。\n        4.  对PSF剖面（在位置 $p_i$ 处采样）进行线性插值，以找到PSF值等于 $A_{\\max}/2$ 的两个空间位置 $x_{\\text{left}}$ 和 $x_{\\text{right}}$。\n        5.  然后FWHM计算为 $x_{\\text{right}} - x_{\\text{left}}$，单位为公里。如果最大值为非正数，或者在域内无法同时找到两个半最大值交叉点，则FWHM被视为未定义，并表示为“非数值”（NaN）。\n\n这些步骤被系统地应用于六个指定的网络配置中的每一个（三个情景各两个）。所得的十二个值（每个配置的 $\\mathrm{DFS}$ 和 $\\mathrm{FWHM}$）按要求汇总到一个列表中。", "answer": "```python\nimport numpy as np\n\ndef calculate_fwhm(psf: np.ndarray, p: np.ndarray) -> float:\n    \"\"\"\n    Computes the Full Width at Half Maximum (FWHM) of a point-spread function.\n\n    Args:\n        psf: The point-spread function values at grid points.\n        p: The spatial positions of the grid points (in km).\n\n    Returns:\n        The FWHM in kilometers, or np.nan if it cannot be determined.\n    \"\"\"\n    if psf.size != p.size:\n        raise ValueError(\"psf and p must have the same size.\")\n    \n    n = psf.shape[0]\n    max_val = np.max(psf)\n\n    if max_val = 0:\n        return np.nan\n\n    half_max_val = max_val / 2.0\n    max_idx = np.argmax(psf)\n\n    # Find left crossing\n    # Find indices on the left of the peak where psf is below half_max\n    left_indices = np.where(psf[:max_idx] = half_max_val)[0]\n    if left_indices.size == 0:\n        return np.nan  # No crossing on the left side\n    \n    i_left = left_indices[-1]\n    p1, p2 = p[i_left], p[i_left + 1]\n    v1, v2 = psf[i_left], psf[i_left + 1]\n    left_pos = p1 + (p2 - p1) * (half_max_val - v1) / (v2 - v1)\n\n    # Find right crossing\n    # Find indices on the right of the peak where psf is below half_max\n    # We search in psf[max_idx+1:] and then adjust the index\n    right_indices = np.where(psf[max_idx+1:] = half_max_val)[0]\n    if right_indices.size == 0:\n        return np.nan  # No crossing on the right side\n    \n    i_right = right_indices[0] + max_idx + 1\n    p1, p2 = p[i_right - 1], p[i_right]\n    v1, v2 = psf[i_right - 1], psf[i_right]\n    right_pos = p1 + (p2 - p1) * (half_max_val - v1) / (v2 - v1)\n\n    return right_pos - left_pos\n\ndef compute_metrics(L, N, sigma_b2, L_b, sigma_r2, M, sensor_config, L_h):\n    \"\"\"\n    Computes DFS and FWHM for a given data assimilation setup.\n    \"\"\"\n    # 1. Setup Domain\n    p = np.linspace(0, L, N)\n    delta_x = L / (N - 1)\n\n    # 2. Construct Covariance Matrices\n    # B matrix: Background Error Covariance\n    dist_sq = (p[:, None] - p[None, :])**2\n    B = sigma_b2 * np.exp(-dist_sq / (2 * L_b**2))\n    \n    # R matrix: Observation Error Covariance\n    R = sigma_r2 * np.eye(M)\n\n    # 3. Construct Observation Operator H\n    # Sensor positions\n    if sensor_config[0] == 'uniform':\n        s = np.linspace(0, L, M)\n    elif sensor_config[0] == 'shifted':\n        if M > 1:\n            nominal_spacing = L / (M - 1)\n            shift = nominal_spacing / 2.0\n            s_nominal = np.linspace(0, L, M)\n            s_shifted = s_nominal + shift\n            s = np.clip(s_shifted, 0, L)\n        else: # Handle M=1 case\n             s = np.array([L/2.0])\n    else:\n        raise ValueError(f\"Unknown sensor_config: {sensor_config}\")\n\n    H = np.zeros((M, N))\n    for m in range(M):\n        weights = np.exp(-(p - s[m])**2 / (2 * L_h**2))\n        H[m, :] = weights / np.sum(weights)\n\n    # 4. Data Assimilation Calculations\n    HBHt = H @ B @ H.T\n    S_inv = np.linalg.inv(HBHt + R)\n    K = B @ H.T @ S_inv\n    A = K @ H\n\n    # 5. Calculate Metrics\n    dfs = np.trace(A)\n    \n    j0 = N // 2\n    psf = A[:, j0]\n    fwhm = calculate_fwhm(psf, p)\n    \n    return dfs, fwhm\n\ndef solve():\n    \"\"\"\n    Main function to run all test scenarios and print results.\n    \"\"\"\n    test_cases = [\n        # Scenario 1, Net 1\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 10, 'sigma_r2': 0.04, 'M': 25, 'sensor_config': ('uniform',), 'L_h': 4},\n        # Scenario 1, Net 2\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 10, 'sigma_r2': 0.04, 'M': 8, 'sensor_config': ('uniform',), 'L_h': 6},\n        # Scenario 2, Net 1\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 5, 'sigma_r2': 0.01, 'M': 50, 'sensor_config': ('uniform',), 'L_h': 2},\n        # Scenario 2, Net 2\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 5, 'sigma_r2': 0.01, 'M': 4, 'sensor_config': ('uniform',), 'L_h': 8},\n        # Scenario 3, Net 1\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 15, 'sigma_r2': 1.0, 'M': 20, 'sensor_config': ('uniform',), 'L_h': 4},\n        # Scenario 3, Net 2\n        {'L': 100, 'N': 50, 'sigma_b2': 1.0, 'L_b': 15, 'sigma_r2': 1.0, 'M': 20, 'sensor_config': ('shifted',), 'L_h': 4},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        dfs, fwhm = compute_metrics(**params)\n        all_results.append(dfs)\n        all_results.append(fwhm)\n    \n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3417773"}]}