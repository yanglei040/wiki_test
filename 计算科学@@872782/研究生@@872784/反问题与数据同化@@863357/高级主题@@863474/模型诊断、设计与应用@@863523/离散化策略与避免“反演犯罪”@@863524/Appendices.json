{"hands_on_practices": [{"introduction": "在求解变分反问题时，我们面临一个根本性的选择：是先推导连续的欧拉-拉格朗日方程再进行离散化（先正则化后离散化），还是先离散化目标泛函再求其梯度（先离散化后正则化）？这个练习 [@problem_id:3376894] 将通过一个全变分正则化问题，具体地揭示这两种策略如何导致不同的离散最优性条件。通过直接比较结果，您将亲身体会到离散化顺序对最终数值格式的重要影响。", "problem": "考虑在域 $[0,1]$ 上的一个一维反问题，其具有线性恒等正演算子和二次数据失配项，并由全变分 (TV) 半范数的可微近似进行正则化。连续目标泛函为\n$$\n\\mathcal{J}(u) \\;=\\; \\frac{1}{2}\\int_{0}^{1} \\left(u(x)-y(x)\\right)^{2}\\,dx \\;+\\; \\lambda \\int_{0}^{1} \\sqrt{\\left(u'(x)\\right)^{2} + \\varepsilon^{2}}\\,dx,\n$$\n其中 $u$ 是未知状态，$y$ 是观测值，$\\lambda0$ 是正则化权重，$\\varepsilon0$ 是一个可微性参数。为了避免所谓的“反演犯罪”，在生成合成数据时，通常采用与反演中所用离散化不同的离散化方法；然而，在本题中，你将推导并比较由反演泛函本身的两种不同离散化策略产生的离散欧拉-拉格朗日方程，作为一项关于离散化选择如何影响一阶最优性条件的研究。\n\n任务1（先正则化后离散）。从 $\\mathcal{J}(u)$ 的一阶变分出发，推导在齐次狄利克雷边界条件 $u(0)=u(1)=0$ 下驻点 $u$ 的连续欧拉-拉格朗日方程。然后，在步长为 $h=1/N$ 的均匀网格 $x_{i}=ih$（$i=0,1,\\dots,N$）上对该微分方程进行如下离散化：使用中点通量近似\n$$\np_{i+\\frac{1}{2}} \\;=\\; \\frac{\\frac{u_{i+1}-u_{i}}{h}}{\\sqrt{\\left(\\frac{u_{i+1}-u_{i}}{h}\\right)^{2} + \\varepsilon^{2}}},\n$$\n并通过下式近似节点 $i$ 处的散度\n$$\n\\left(\\nabla\\cdot p\\right)_{i} \\;\\approx\\; \\frac{p_{i+\\frac{1}{2}} - p_{i-\\frac{1}{2}}}{h},\n$$\n得到形如下式的离散欧拉-拉格朗日残差\n$$\nr^{\\mathrm{RtD}}_{i}(u) \\;=\\; \\left(u_{i} - y_{i}\\right) \\;-\\; \\lambda\\,\\frac{p_{i+\\frac{1}{2}} - p_{i-\\frac{1}{2}}}{h}, \\quad i=1,\\dots,N-1,\n$$\n其中 $u_{0}=u_{N}=0$。\n\n任务2（先离散后正则化）。使用黎曼和近似积分项，在相同的均匀网格上直接离散化泛函 $\\mathcal{J}(u)$，即\n$$\n\\mathcal{J}_{h}(u) \\;=\\; \\frac{1}{2}\\,h\\,\\sum_{i=1}^{N-1} \\left(u_{i}-y_{i}\\right)^{2} \\;+\\; \\lambda\\,\\sum_{i=0}^{N-1} \\sqrt{\\left(u_{i+1}-u_{i}\\right)^{2} + \\left(\\varepsilon h\\right)^{2}},\n$$\n其中 $u_{0}=u_{N}=0$。计算 $\\mathcal{J}_{h}(u)$ 关于内部自由度的梯度，以获得离散欧拉-拉格朗日残差\n$$\ng^{\\mathrm{DtR}}_{i}(u) \\;=\\; h\\left(u_{i} - y_{i}\\right) \\;+\\; \\lambda \\left[\\frac{u_{i}-u_{i-1}}{\\sqrt{\\left(u_{i}-u_{i-1}\\right)^{2} + \\left(\\varepsilon h\\right)^{2}}} \\;-\\; \\frac{u_{i+1}-u_{i}}{\\sqrt{\\left(u_{i+1}-u_{i}\\right)^{2} + \\left(\\varepsilon h\\right)^{2}}}\\right], \\quad i=1,\\dots,N-1,\n$$\n其中 $u_{0}=u_{N}=0$。\n\n任务3（特定实例的定量比较）。考虑 $N=4$，因此 $h=1/4$，选择 $\\lambda=1$ 和 $\\varepsilon=1$，施加 $u_{0}=u_{4}=0$，并取内部网格值为 $u_{1}=1$，$u_{2}=0$，$u_{3}=-1$。取观测值为 $y_{i}=0$（$i=1,2,3$）。使用任务1和任务2中推导的公式，计算比率\n$$\n\\frac{r^{\\mathrm{RtD}}_{1}(u)}{g^{\\mathrm{DtR}}_{1}(u)}.\n$$\n\n你的最终答案必须是一个实数。不需要四舍五入，也不需要单位。", "solution": "本题要求推导和比较一个一维变分问题的两种不同离散化策略，然后对一个特定实例进行定量评估。这两种策略是“先正则化后离散”（RtD）和“先离散后正则化”（DtR）。请注意，题目使用了“先离散后正则化”这一术语，但对这种方法更常规的术语是“先离散后优化”，因为正则化项已经存在于连续泛函中。我们将遵循题目的术语。\n\n连续目标泛函由下式给出\n$$\n\\mathcal{J}(u) \\;=\\; \\frac{1}{2}\\int_{0}^{1} \\left(u(x)-y(x)\\right)^{2}\\,dx \\;+\\; \\lambda \\int_{0}^{1} \\sqrt{\\left(u'(x)\\right)^{2} + \\varepsilon^{2}}\\,dx\n$$\n我们依次处理这三个任务。\n\n**任务1：先正则化后离散 (RtD)**\n\n在RtD方法中，我们首先找到连续的一阶最优性条件，即欧拉-拉格朗日方程，然后对该方程进行离散化。泛函 $\\mathcal{J}(u)$ 的被积函数是拉格朗日量 $\\mathcal{L}(x, u, u')$。\n$$\n\\mathcal{L}(x, u(x), u'(x)) \\;=\\; \\frac{1}{2}\\left(u(x)-y(x)\\right)^{2} \\;+\\; \\lambda \\sqrt{\\left(u'(x)\\right)^{2} + \\varepsilon^{2}}\n$$\n极小值点 $u(x)$ 的欧拉-拉格朗日方程由下式给出\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial u} - \\frac{d}{dx}\\left(\\frac{\\partial \\mathcal{L}}{\\partial u'}\\right) \\;=\\; 0\n$$\n我们计算 $\\mathcal{L}$ 的偏导数：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial u} \\;=\\; u(x) - y(x)\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial u'} \\;=\\; \\lambda \\cdot \\frac{1}{2\\sqrt{(u'(x))^2 + \\varepsilon^2}} \\cdot 2u'(x) \\;=\\; \\lambda \\frac{u'(x)}{\\sqrt{(u'(x))^2 + \\varepsilon^2}}\n$$\n将这些代入欧拉-拉格朗日方程，得到连续最优性条件：\n$$\n\\left(u(x) - y(x)\\right) - \\lambda \\frac{d}{dx}\\left(\\frac{u'(x)}{\\sqrt{\\left(u'(x)\\right)^{2} + \\varepsilon^{2}}}\\right) \\;=\\; 0\n$$\n现在，我们在步长为 $h=1/N$ 的均匀网格 $x_i = ih$（$i=0, \\dots, N$）上对该微分方程进行离散化。令 $u_i \\approx u(x_i)$。节点 $x_i$ 处的方程被离散化为\n$$\n(u_i - y_i) - \\lambda \\left[\\frac{d}{dx}(\\cdot)\\right]_i \\;\\approx\\; 0\n$$\n题目指定了一种有限体积式的离散化方法。令 $p(x) = \\frac{u'(x)}{\\sqrt{(u'(x))^2 + \\varepsilon^2}}$。微分方程为 $u(x)-y(x)-\\lambda p'(x) = 0$。我们使用在单元中点定义的通量的中心差分来近似散度项 $p'(x_i)$：\n$$\np'(x_i) \\;\\approx\\; \\frac{p(x_{i+1/2}) - p(x_{i-1/2})}{h} \\;=\\; \\frac{p_{i+1/2} - p_{i-1/2}}{h}\n$$\n通量 $p_{i+1/2}$ 本身通过在其中点 $x_{i+1/2}$ 处计算其参数来近似。导数 $u'(x_{i+1/2})$ 通过在区间 $[x_i, x_{i+1}]$ 上的中心差分来近似：\n$$\nu'(x_{i+1/2}) \\;\\approx\\; \\frac{u_{i+1}-u_i}{h}\n$$\n将此代入 $p$ 的表达式，得到中点通量：\n$$\np_{i+1/2} \\;\\approx\\; \\frac{\\frac{u_{i+1}-u_i}{h}}{\\sqrt{\\left(\\frac{u_{i+1}-u_i}{h}\\right)^2 + \\varepsilon^2}}\n$$\n这与题目中提供的表达式相匹配。因此，在内部节点 $i \\in \\{1, \\dots, N-1\\}$ 处，欧拉-拉格朗日方程的离散残差为\n$$\nr^{\\mathrm{RtD}}_{i}(u) \\;=\\; (u_{i} - y_{i}) - \\lambda\\,\\frac{p_{i+\\frac{1}{2}} - p_{i-\\frac{1}{2}}}{h}\n$$\n这验证了题目描述中为任务1给出的公式。\n\n**任务2：先离散后正则化 (DtR)**\n\n在DtR方法中，我们首先离散化泛函 $\\mathcal{J}(u)$，然后计算得到的离散函数的梯度。离散泛函 $\\mathcal{J}_h(u)$ 如下所示\n$$\n\\mathcal{J}_{h}(u) \\;=\\; \\frac{1}{2}\\,h\\,\\sum_{j=1}^{N-1} \\left(u_{j}-y_{j}\\right)^{2} \\;+\\; \\lambda\\,\\sum_{j=0}^{N-1} \\sqrt{\\left(u_{j+1}-u_{j}\\right)^{2} + \\left(\\varepsilon h\\right)^{2}}\n$$\n通过将关于内部自由度 $u_i$（对于 $i=1, \\dots, N-1$）的偏导数设为零，可以找到离散的欧拉-拉格朗日方程。残差 $g^{\\mathrm{DtR}}_{i}(u)$ 定义为该偏导数 $\\frac{\\partial \\mathcal{J}_h}{\\partial u_i}$。\n\n我们对 $\\mathcal{J}_h(u)$ 关于特定的 $u_i$ 求导：\n数据失配项（第一个和式）仅在求和指数 $j=i$ 时依赖于 $u_i$。其导数为：\n$$\n\\frac{\\partial}{\\partial u_i}\\left(\\frac{1}{2}\\,h\\,\\left(u_{i}-y_{i}\\right)^{2}\\right) \\;=\\; h(u_i - y_i)\n$$\n正则化项（第二个和式）在和式的两个连续项中依赖于 $u_i$：当 $j=i-1$ 和 $j=i$ 时。\n令 $R_j = \\sqrt{(u_{j+1}-u_j)^2 + (\\varepsilon h)^2}$。我们需要计算 $\\frac{\\partial}{\\partial u_i} (\\lambda R_{i-1} + \\lambda R_i)$。\n对于项 $j=i-1$，我们有 $R_{i-1} = \\sqrt{(u_i - u_{i-1})^2 + (\\varepsilon h)^2}$。其导数为：\n$$\n\\frac{\\partial}{\\partial u_i} (\\lambda R_{i-1}) = \\lambda \\frac{2(u_i - u_{i-1})}{2\\sqrt{(u_i - u_{i-1})^2 + (\\varepsilon h)^2}} = \\lambda \\frac{u_i - u_{i-1}}{\\sqrt{(u_i-u_{i-1})^2 + (\\varepsilon h)^2}}\n$$\n对于项 $j=i$，我们有 $R_i = \\sqrt{(u_{i+1} - u_i)^2 + (\\varepsilon h)^2}$。其导数为：\n$$\n\\frac{\\partial}{\\partial u_i} (\\lambda R_i) = \\lambda \\frac{2(u_{i+1} - u_i)(-1)}{2\\sqrt{(u_{i+1} - u_i)^2 + (\\varepsilon h)^2}} = - \\lambda \\frac{u_{i+1} - u_i}{\\sqrt{(u_{i+1} - u_i)^2 + (\\varepsilon h)^2}}\n$$\n将所有部分组合起来，梯度为：\n$$\ng^{\\mathrm{DtR}}_{i}(u) \\;=\\; \\frac{\\partial \\mathcal{J}_h}{\\partial u_i} \\;=\\; h\\left(u_{i} - y_{i}\\right) \\;+\\; \\lambda \\left[\\frac{u_{i}-u_{i-1}}{\\sqrt{\\left(u_{i}-u_{i-1}\\right)^{2} + \\left(\\varepsilon h\\right)^{2}}} \\;-\\; \\frac{u_{i+1}-u_{i}}{\\sqrt{\\left(u_{i+1}-u_{i}\\right)^{2} + \\left(\\varepsilon h\\right)^{2}}}\\right]\n$$\n这验证了题目描述中为任务2给出的公式。\n\n**任务3：定量比较**\n\n我们被要求在以下参数下计算 $i=1$ 时的比率 $\\frac{r^{\\mathrm{RtD}}_{1}(u)}{g^{\\mathrm{DtR}}_{1}(u)}$：\n- $N=4$，因此网格间距为 $h=1/N=1/4$。\n- 正则化参数：$\\lambda=1$，$\\varepsilon=1$。\n- 状态向量（内部节点）：$u_1=1$, $u_2=0$, $u_3=-1$。\n- 边界条件：$u_0=0$, $u_4=0$。\n- 观测向量（内部节点）：$y_1=0$, $y_2=0$, $y_3=0$。\n\n首先，我们计算残差 $r^{\\mathrm{RtD}}_{1}(u)$：\n$$\nr^{\\mathrm{RtD}}_{1}(u) \\;=\\; (u_1 - y_1) - \\lambda \\frac{p_{1+1/2} - p_{1-1/2}}{h}\n$$\n使用给定值：$u_1=1$, $y_1=0$, $\\lambda=1$, $h=1/4$。\n$$\nr^{\\mathrm{RtD}}_{1}(u) \\;=\\; (1-0) - 1 \\cdot \\frac{p_{3/2} - p_{1/2}}{1/4} \\;=\\; 1 - 4(p_{3/2} - p_{1/2})\n$$\n我们需要计算通量 $p_{1/2}$ 和 $p_{3/2}$。\n对于 $p_{1/2}$，我们使用节点 $u_0=0$ 和 $u_1=1$：\n$$\n\\frac{u_1-u_0}{h} = \\frac{1-0}{1/4} = 4\n$$\n$$\np_{1/2} = \\frac{4}{\\sqrt{4^2 + \\varepsilon^2}} = \\frac{4}{\\sqrt{16 + 1^2}} = \\frac{4}{\\sqrt{17}}\n$$\n对于 $p_{3/2}$，我们使用节点 $u_1=1$ 和 $u_2=0$：\n$$\n\\frac{u_2-u_1}{h} = \\frac{0-1}{1/4} = -4\n$$\n$$\np_{3/2} = \\frac{-4}{\\sqrt{(-4)^2 + \\varepsilon^2}} = \\frac{-4}{\\sqrt{16 + 1^2}} = \\frac{-4}{\\sqrt{17}}\n$$\n将这些通量代回 $r^{\\mathrm{RtD}}_{1}(u)$ 的表达式中：\n$$\nr^{\\mathrm{RtD}}_{1}(u) \\;=\\; 1 - 4\\left(\\frac{-4}{\\sqrt{17}} - \\frac{4}{\\sqrt{17}}\\right) \\;=\\; 1 - 4\\left(\\frac{-8}{\\sqrt{17}}\\right) \\;=\\; 1 + \\frac{32}{\\sqrt{17}}\n$$\n接下来，我们计算残差 $g^{\\mathrm{DtR}}_{1}(u)$：\n$$\ng^{\\mathrm{DtR}}_{1}(u) = h\\left(u_{1} - y_{1}\\right) + \\lambda \\left[\\frac{u_{1}-u_{0}}{\\sqrt{\\left(u_{1}-u_{0}\\right)^{2} + \\left(\\varepsilon h\\right)^{2}}} - \\frac{u_{2}-u_{1}}{\\sqrt{\\left(u_{2}-u_{1}\\right)^{2} + \\left(\\varepsilon h\\right)^{2}}}\\right]\n$$\n使用给定值：$\\varepsilon h = 1 \\cdot (1/4) = 1/4$。\n$$\ng^{\\mathrm{DtR}}_{1}(u) = \\frac{1}{4}(1-0) + 1 \\cdot \\left[\\frac{1-0}{\\sqrt{(1-0)^2 + (1/4)^2}} - \\frac{0-1}{\\sqrt{(0-1)^2 + (1/4)^2}}\\right]\n$$\n$$\ng^{\\mathrm{DtR}}_{1}(u) = \\frac{1}{4} + \\left[\\frac{1}{\\sqrt{1 + 1/16}} - \\frac{-1}{\\sqrt{1 + 1/16}}\\right] = \\frac{1}{4} + \\frac{1 - (-1)}{\\sqrt{17/16}}\n$$\n$$\ng^{\\mathrm{DtR}}_{1}(u) = \\frac{1}{4} + \\frac{2}{\\sqrt{17}/4} = \\frac{1}{4} + \\frac{8}{\\sqrt{17}}\n$$\n最后，我们计算所需的比率：\n$$\n\\frac{r^{\\mathrm{RtD}}_{1}(u)}{g^{\\mathrm{DtR}}_{1}(u)} = \\frac{1 + \\frac{32}{\\sqrt{17}}}{\\frac{1}{4} + \\frac{8}{\\sqrt{17}}}\n$$\n我们可以从分子中提取因子4：\n$$\n1 + \\frac{32}{\\sqrt{17}} = 4\\left(\\frac{1}{4} + \\frac{8}{\\sqrt{17}}\\right)\n$$\n因此，该比率简化为：\n$$\n\\frac{r^{\\mathrm{RtD}}_{1}(u)}{g^{\\mathrm{DtR}}_{1}(u)} = \\frac{4\\left(\\frac{1}{4} + \\frac{8}{\\sqrt{17}}\\right)}{\\frac{1}{4} + \\frac{8}{\\sqrt{17}}} = 4\n$$\n这表明，对于所选的离散化方法，这两个残差通过一个简单的缩放因子 $1/h$ 关联起来。具体来说，$r^{\\mathrm{RtD}}_i = (1/h) g^{\\mathrm{DtR}}_i$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3376894"}, {"introduction": "正确的离散化不仅意味着要精确地近似积分和微分，还要求我们准确地对物理观测过程本身进行建模。本练习 [@problem_id:3376940] 以一个带有降采样的信号解卷积问题为例，展示了一个看似简单的观测步骤（降采样）必须如何在离散正向算子中被显式地数学表达。通过在傅里叶域中分析其效应，您将理解为何忽略或不当处理这类观测算子会构成一种建模误差，从而影响反演结果的准确性。", "problem": "考虑一个在循环群 $\\mathbb{Z}_N$ 上的维周期性反卷积问题，其中 $N \\in \\mathbb{N}$。在此问题中，未知信号 $x \\in \\mathbb{C}^N$ 通过与一个已知核 $k \\in \\mathbb{C}^N$ 进行卷积，然后进行均匀下采样，被映射到无噪声数据。正向映射为 $A = S C_k$，其中 $C_k$ 是由 $k$ 生成的循环卷积算子，$S$ 对每第 $m$ 个元素进行采样，其中 $m \\in \\mathbb{N}$ 且 $m$ 整除 $N$。为避免所谓的“反演犯罪”，采样算子 $S$ 必须显式地包含在离散正向模型中，而不是被隐式处理或忽略。\n\n你需要基于循环卷积和离散傅里叶变换 (DFT) 的定义，从第一性原理出发进行推导。令 $F_N$ 表示酉离散傅里叶变换 (DFT) 矩阵，其元素为 $(F_N)_{p,j} = \\frac{1}{\\sqrt{N}}\\exp(-2\\pi i pj/N)$，其中 $0 \\le p,j \\le N-1$。令 $C_k$ 表示与 $k$ 的循环卷积，因此 $C_k = F_N^{*}\\Lambda F_N$，其中 $\\Lambda = \\mathrm{diag}(K[0],\\dots,K[N-1])$ 且 $K[p] = \\sum_{n=0}^{N-1} k[n]\\exp(-2\\pi i pn/N)$ 是循环算子的特征值。采样算子 $S:\\mathbb{C}^N \\to \\mathbb{C}^{N/m}$ 定义为 $(S z)[n] = z[m n]$，其中 $0 \\le n \\le N/m - 1$，其伴随算子 $S^{*}$ 是在能被 $m$ 整除的索引处插入零。\n\n(a) 仅使用这些定义以及空间域中的均匀下采样对应于频率域中的混叠这一事实，推导出正规算子 $A^{*}A = C_k^{*}S^{*}S C_k$ 在 DFT 基下的显式表达式。证明在 DFT 域中，算子 $A^{*}A$ 是块对角的，具有 $N/m$ 个大小为 $m \\times m$ 的块，每个块对应一个混叠类 $\\{r + \\ell(N/m)\\}_{\\ell=0}^{m-1}$，并根据卷积特征值 $\\{K[p]\\}_{p=0}^{N-1}$ 确定每个块中唯一的非零特征值。你的推导必须从 $F_N$、$C_k$ 和 $S$ 的定义出发，且不得假定任何现成的谱混叠公式。\n\n(b) 将问题特化到 $N=12$ 和 $m=3$ 的情况。设核为 $\\mathbb{Z}_{12}$ 上的最近邻平滑模板，由 $k[0]=1$、$k[1]=k[11]=\\frac{1}{2}$ 给出，其他 $k[n]=0$。精确计算 $A^{*}A$ 的最小非零特征值（无需四舍五入）。将你的最终答案表示为一个不带单位的实数。", "solution": "该问题包含两部分。部分 (a) 要求在离散傅里叶变换 (DFT) 基下推导正规算子 $A^*A$ 的结构。部分 (b) 要求基于部分 (a) 的结果计算一个具体值。\n\n### 部分 (a)：DFT 基下正规算子的结构\n\n正向算子由 $A = S C_k$ 给出，其中 $C_k$ 是循环卷积算子，$S$ 是下采样算子。因此，正规算子为 $A^*A = (S C_k)^* (S C_k) = C_k^* S^* S C_k$。我们想求出该算子在 DFT 基下的表示。这对应于计算矩阵 $\\mathcal{A} = F_N (A^*A) F_N^*$，其中 $F_N$ 是酉 DFT 矩阵。\n\n使用给定的性质 $C_k = F_N^* \\Lambda F_N$，其中 $\\Lambda = \\mathrm{diag}(K[p])$，我们可以将 $C_k^*$ 表示为：\n$C_k^* = (F_N^* \\Lambda F_N)^* = F_N^* \\Lambda^* (F_N^*)^* = F_N^* \\Lambda^* F_N$。\n这里 $\\Lambda^*$ 是 $\\Lambda$ 的共轭转置，因此 $\\Lambda^* = \\mathrm{diag}(\\overline{K[p]})$。\n\n现在我们将这些代入 $\\mathcal{A}$ 的表达式中：\n$$ \\mathcal{A} = F_N (F_N^* \\Lambda^* F_N) (S^*S) (F_N^* \\Lambda F_N) F_N^* $$\n由于 $F_N$ 是酉矩阵，$F_N F_N^* = I$，其中 $I$ 是单位矩阵。表达式简化为：\n$$ \\mathcal{A} = (F_N F_N^*) \\Lambda^* (F_N S^*S F_N^*) \\Lambda (F_N F_N^*) $$\n$$ \\mathcal{A} = \\Lambda^* (F_N S^*S F_N^*) \\Lambda $$\n该表达式的核心部分是算子 $M = F_N S^*S F_N^*$，它表示频率域中的采样与重建过程。我们来求它的矩阵元素 $M_{p,q}$。\n\n算子 $S^*S$ 作用于向量 $z \\in \\mathbb{C}^N$。算子 $S$ 选取索引是 $m$ 的倍数的元素。伴随算子 $S^*$ 插入零。复合算子 $S^*S$ 是一个投影。具体来说，如果 $j$ 是 $m$ 的倍数，则 $(S^*S z)[j] = z[j]$，否则为 $0$。作为矩阵，$S^*S$ 是一个对角矩阵，其第 $j$ 个对角元素在 $j \\equiv 0 \\pmod{m}$ 时为 $1$，否则为 $0$。我们用指示函数 $\\mathbf{1}_{j \\equiv 0 \\pmod m}$ 来表示。\n\n矩阵 $M = F_N (S^*S) F_N^*$ 的元素由下式给出：\n$$ M_{p,q} = (F_N (S^*S) F_N^*)_{p,q} = \\sum_{j=0}^{N-1} \\sum_{l=0}^{N-1} (F_N)_{p,j} (S^*S)_{j,l} (F_N^*)_{l,q} $$\n由于 $(S^*S)_{j,l} = \\delta_{j,l} \\mathbf{1}_{j \\equiv 0 \\pmod m}$：\n$$ M_{p,q} = \\sum_{j=0}^{N-1} (F_N)_{p,j} \\mathbf{1}_{j \\equiv 0 \\pmod m} (F_N^*)_{j,q} $$\n代入 DFT 矩阵元素的定义 $(F_N)_{p,j} = \\frac{1}{\\sqrt{N}}\\exp(-2\\pi i pj/N)$ 和 $(F_N^*)_{j,q} = \\frac{1}{\\sqrt{N}}\\exp(2\\pi i qj/N)$：\n$$ M_{p,q} = \\sum_{j=0}^{N-1} \\left( \\frac{1}{\\sqrt{N}}\\exp(-2\\pi i pj/N) \\right) \\mathbf{1}_{j \\equiv 0 \\pmod m} \\left( \\frac{1}{\\sqrt{N}}\\exp(2\\pi i qj/N) \\right) $$\n仅当索引 $j$ 是 $m$ 的倍数时，该和才非零。我们可以写成 $j=nm$，其中 $n \\in \\{0, 1, \\dots, N/m-1\\}$。\n$$ M_{p,q} = \\frac{1}{N} \\sum_{n=0}^{N/m-1} \\exp(-2\\pi i p(nm)/N) \\exp(2\\pi i q(nm)/N) $$\n$$ M_{p,q} = \\frac{1}{N} \\sum_{n=0}^{N/m-1} \\exp\\left(-\\frac{2\\pi i (p-q)n}{N/m}\\right) $$\n这是一个等比级数和。如果指数的参数是 $2\\pi i$ 的整数倍，即 $(p-q)/(N/m)$ 是一个整数，则和等于 $N/m$。这等价于 $p \\equiv q \\pmod{N/m}$。如果 $p-q$ 不是 $N/m$ 的倍数，则和为零。\n因此，\n$$ M_{p,q} = \\begin{cases} \\frac{1}{N} \\cdot \\frac{N}{m} = \\frac{1}{m}  \\text{if } p \\equiv q \\pmod{N/m} \\\\ 0  \\text{otherwise} \\end{cases} $$\n这表明空间域中的均匀下采样对应于频率域中的混叠，将那些模 $N/m$ 具有相同余数的频率耦合在一起。\n\n现在我们可以确定 $\\mathcal{A} = \\Lambda^* M \\Lambda$ 的元素：\n$$ \\mathcal{A}_{p,q} = \\sum_{a=0}^{N-1} \\sum_{b=0}^{N-1} (\\Lambda^*)_{p,a} M_{a,b} \\Lambda_{b,q} $$\n由于 $\\Lambda$ 是对角矩阵，$(\\Lambda^*)_{p,a} = \\overline{K[p]}\\delta_{p,a}$ 且 $\\Lambda_{b,q} = K[b]\\delta_{b,q}$。\n$$ \\mathcal{A}_{p,q} = \\overline{K[p]} M_{p,q} K[q] $$\n代入 $M_{p,q}$ 的表达式：\n$$ \\mathcal{A}_{p,q} = \\begin{cases} \\frac{1}{m} \\overline{K[p]} K[q]  \\text{if } p \\equiv q \\pmod{N/m} \\\\ 0  \\text{otherwise} \\end{cases} $$\n这个表达式表明 $\\mathcal{A}$ 是一个块对角矩阵。频率索引 $\\{0, \\dots, N-1\\}$ 被划分为 $N/m$ 个不相交的集合，称为混叠类。令 $r \\in \\{0, 1, \\dots, N/m - 1\\}$。第 $r$ 个混叠类是索引集合 $I_r = \\{r + \\ell(N/m) \\mid \\ell=0, \\dots, m-1\\}$。\n仅当 $p$ 和 $q$ 都属于同一个类 $I_r$ 时，矩阵 $\\mathcal{A}$ 才有非零元素。因此，$\\mathcal{A}$ 分解为 $N/m$ 个大小为 $m \\times m$ 的块。\n\n我们来分析第 $r$ 个块 $\\mathcal{A}^{(r)}$，它对应于索引 $p_\\ell = r + \\ell(N/m)$，其中 $\\ell \\in \\{0, \\dots, m-1\\}$。该块的元素由下式给出：\n$$ (\\mathcal{A}^{(r)})_{\\ell, \\ell'} = \\mathcal{A}_{p_\\ell, p_{\\ell'}} = \\frac{1}{m} \\overline{K[p_\\ell]} K[p_{\\ell'}] $$\n其中 $\\ell, \\ell' \\in \\{0, \\dots, m-1\\}$。这是一个秩一矩阵。形式为 $uv^*$ 的秩一矩阵有一个等于 $v^*u$ 的非零特征值，其余特征值均为零。在我们的例子中，我们定义一个向量 $w \\in \\mathbb{C}^m$，其分量为 $w_\\ell = K[p_\\ell]$。块矩阵的元素为 $(\\mathcal{A}^{(r)})_{\\ell, \\ell'} = \\frac{1}{m} \\overline{w_\\ell} w_{\\ell'}$。让我们直接验证其特征向量性质。考虑一个向量 $v$，其分量为 $v_{\\ell'} = \\overline{w_{\\ell'}}$。\n$$ (\\mathcal{A}^{(r)} v)_\\ell = \\sum_{\\ell'=0}^{m-1} (\\mathcal{A}^{(r)})_{\\ell, \\ell'} v_{\\ell'} = \\sum_{\\ell'=0}^{m-1} \\left(\\frac{1}{m} \\overline{w_\\ell} w_{\\ell'}\\right) \\overline{w_{\\ell'}} = \\frac{1}{m} \\overline{w_\\ell} \\sum_{\\ell'=0}^{m-1} |w_{\\ell'}|^2 $$\n这可以写成 $(\\mathcal{A}^{(r)} v)_\\ell = \\lambda_r v_\\ell$，其中特征值 $\\lambda_r$ 是：\n$$ \\lambda_r = \\frac{1}{m} \\sum_{\\ell'=0}^{m-1} |w_{\\ell'}|^2 = \\frac{1}{m} \\sum_{\\ell=0}^{m-1} |K[p_\\ell]|^2 = \\frac{1}{m} \\sum_{\\ell=0}^{m-1} |K[r + \\ell(N/m)]|^2 $$\n特征向量是 $v$，其元素为 $\\overline{K[p_\\ell]}$。该块的其他 $m-1$ 个特征值均为零。因此，对于每个块 $r \\in \\{0, \\dots, N/m-1\\}$，存在一个由 $\\lambda_r$ 的表达式给出的唯一非零特征值。\n\n### 部分 (b)：最小非零特征值计算\n\n给定 $N=12$，$m=3$，所以 $N/m=4$。核为 $k[0]=1$，$k[1]=k[11]=1/2$，其他 $k[n]=0$。由于我们在 $\\mathbb{Z}_{12}$ 上工作，$k[11]$ 等价于 $k[-1]$。\n\n首先，我们计算核的 DFT，$K[p]$，其中 $p \\in \\{0, \\dots, 11\\}$：\n$$ K[p] = \\sum_{n=0}^{11} k[n] \\exp\\left(-\\frac{2\\pi i pn}{12}\\right) = k[0] + k[1]\\exp\\left(-\\frac{2\\pi i p}{12}\\right) + k[11]\\exp\\left(-\\frac{2\\pi i p(11)}{12}\\right) $$\n使用 $11 \\equiv -1 \\pmod{12}$，上式简化为：\n$$ K[p] = 1 + \\frac{1}{2}\\exp\\left(-\\frac{i \\pi p}{6}\\right) + \\frac{1}{2}\\exp\\left(\\frac{i \\pi p}{6}\\right) = 1 + \\cos\\left(\\frac{\\pi p}{6}\\right) $$\n由于 $K[p]$ 是实数，所以 $|K[p]|^2 = (K[p])^2 = (1 + \\cos(\\pi p/6))^2$。\n\n$A^*A$ 的非零特征值由 $\\lambda_r$ 给出，其中 $r \\in \\{0, 1, 2, 3\\}$。\n$$ \\lambda_r = \\frac{1}{3} \\sum_{\\ell=0}^{2} (K[r+4\\ell])^2 = \\frac{1}{3} \\left( K[r]^2 + K[r+4]^2 + K[r+8]^2 \\right) $$\n\n我们计算这四个特征值：\n\n对于 $r=0$：\n$K[0] = 1+\\cos(0) = 2$.\n$K[4] = 1+\\cos(4\\pi/6) = 1+\\cos(2\\pi/3) = 1-1/2 = 1/2$.\n$K[8] = 1+\\cos(8\\pi/6) = 1+\\cos(4\\pi/3) = 1-1/2 = 1/2$.\n$\\lambda_0 = \\frac{1}{3}(2^2 + (1/2)^2 + (1/2)^2) = \\frac{1}{3}(4 + 1/4 + 1/4) = \\frac{1}{3}(4.5) = 1.5 = \\frac{3}{2}$.\n\n对于 $r=1$：\n$K[1] = 1+\\cos(\\pi/6) = 1+\\sqrt{3}/2$.\n$K[5] = 1+\\cos(5\\pi/6) = 1-\\sqrt{3}/2$.\n$K[9] = 1+\\cos(9\\pi/6) = 1+\\cos(3\\pi/2) = 1+0 = 1$.\n$\\lambda_1 = \\frac{1}{3}((1+\\sqrt{3}/2)^2 + (1-\\sqrt{3}/2)^2 + 1^2) = \\frac{1}{3}((1+\\sqrt{3}+3/4) + (1-\\sqrt{3}+3/4) + 1) = \\frac{1}{3}(7/4+7/4+1) = \\frac{1}{3}(7/2+1) = \\frac{1}{3}(9/2) = 1.5 = \\frac{3}{2}$.\n\n对于 $r=2$：\n$K[2] = 1+\\cos(2\\pi/6) = 1+\\cos(\\pi/3) = 1+1/2 = 3/2$.\n$K[6] = 1+\\cos(6\\pi/6) = 1+\\cos(\\pi) = 1-1 = 0$.\n$K[10] = 1+\\cos(10\\pi/6) = 1+\\cos(5\\pi/3) = 1+1/2 = 3/2$.\n$\\lambda_2 = \\frac{1}{3}((3/2)^2 + 0^2 + (3/2)^2) = \\frac{1}{3}(9/4 + 9/4) = \\frac{1}{3}(9/2) = 1.5 = \\frac{3}{2}$.\n\n对于 $r=3$：\n$K[3] = 1+\\cos(3\\pi/6) = 1+\\cos(\\pi/2) = 1+0 = 1$.\n$K[7] = 1+\\cos(7\\pi/6) = 1-\\sqrt{3}/2$.\n$K[11] = 1+\\cos(11\\pi/6) = 1+\\sqrt{3}/2$.\n$\\lambda_3 = \\frac{1}{3}(1^2 + (1-\\sqrt{3}/2)^2 + (1+\\sqrt{3}/2)^2)$. 这与 $\\lambda_1$ 的求和相同。\n$\\lambda_3 = 1.5 = \\frac{3}{2}$.\n\n$A^*A$ 的所有四个非零特征值都等于 $3/2$。因此，最小非零特征值为 $3/2$。", "answer": "$$\\boxed{\\frac{3}{2}}$$", "id": "3376940"}, {"introduction": "本练习 [@problem_id:3376948] 是一个综合性的编程实践，旨在将避免“反演犯罪”的原则付诸于实际代码中。您将通过一个积分方程反问题，从零开始构建一个完整的数值实验：首先，使用解析公式生成“真实”数据，从而绕开反演犯罪的陷阱；然后，通过实施网格加密研究来系统地评估和验证您的离散化方案和重建算法的收敛阶。这项实践对于验证任何反问题数值方法的可靠性而言都是一项至关重要的核心技能。", "problem": "为某个线性反问题设计一个网格加密研究，该研究需演示如何避免反演犯罪，并验证重构中离散化误差的收敛阶。考虑以下连续模型：从由线性积分算子生成的精确数据 $y(s)$ 中恢复区间 $[0,1]$ 上的未知函数 $x(t)$\n$$\ny(s) = \\int_{0}^{1} K(s,t)\\,x(t)\\,dt,\\quad s\\in[0,1],\\quad K(s,t)=\\min(s,t).\n$$\n为避免反演犯罪（即使用完全相同的离散模型来合成和反演数据），数据必须从连续模型解析地合成，而不是通过用于重构的相同离散算子来合成。\n\n使用一个人为构造的光滑真值\n$$\nx_{\\mathrm{true}}(t) = \\sin(2\\pi t) + \\tfrac{1}{2}\\cos(3\\pi t),\n$$\n并使用恒等式推导出精确数据 $y(s)$\n$$\ny(s) = \\int_{0}^{s} t\\,x_{\\mathrm{true}}(t)\\,dt + s\\int_{s}^{1} x_{\\mathrm{true}}(t)\\,dt,\n$$\n这样 $y$ 就是根据连续公式计算得出的。对于网格尺寸为 $h=1/N$ 的均匀网格和单元区间 $I_j=[(j-1)h,jh]$，将离散未知量表示为位于单元中点 $t_j=(j-\\tfrac{1}{2})h$ 的分片常数 $x_h\\in\\mathbb{R}^N$。令测量点为 $s_i=t_i$, $i=1,\\dots,N$。\n\n构建两个离散正演算子 $A_h\\in\\mathbb{R}^{N\\times N}$：\n- 精确单元积分组装（在子空间上无求积误差）：对每个 $i,j$ 设置\n$$\n(A_h)_{ij} = \\int_{I_j} \\min(s_i,t)\\,dt\n=\n\\begin{cases}\ns_i h, \\text{if } s_i \\le (j-1)h,\\\\\n\\tfrac{1}{2}\\!\\left((jh)^2-((j-1)h)^2\\right), \\text{if } s_i \\ge jh,\\\\\n\\tfrac{1}{2}\\!\\left(s_i^2-((j-1)h)^2\\right) + s_i\\left(jh-s_i\\right), \\text{if } s_i\\in\\left((j-1)h,jh\\right).\n\\end{cases}\n$$\n- 中点求积组装（一阶求积）：对每个 $i,j$ 设置\n$$\n(A_h^{\\mathrm{mid}})_{ij} = K\\big(s_i,t_j\\big)\\,h = \\min\\big(s_i,t_j\\big)\\,h.\n$$\n\n将重构 $x_h^\\ast$ 构造为最小二乘（LS）极小化子\n$$\nx_h^\\ast = \\operatorname*{arg\\,min}_{x\\in\\mathbb{R}^N}\\,\\|A_h x - y_h\\|_2,\n$$\n对 $A_h^{\\mathrm{mid}}$ 也进行类似操作，其中 $y_h\\in\\mathbb{R}^N$ 是在测量点 $s_i$ 处采样的精确数据向量。此处 $\\|\\cdot\\|_2$ 表示欧几里得范数。在离散 $L^2$ 范数下计算重构误差\n$$\nE_h = \\left(\\sum_{j=1}^N h\\,\\big(x_h^\\ast(j)-x_{\\mathrm{true}}(t_j)\\big)^2\\right)^{1/2} = \\sqrt{h}\\,\\|x_h^\\ast - x_{\\mathrm{true}}(t_\\cdot)\\|_2.\n$$\n\n根据分片常数近似的基本原理以及核函数为 $K(s,t)=\\min(s,t)$ 的积分算子的光滑性质（这是一个二阶椭圆算子的格林核），在分片常数空间中光滑真值 $x_{\\mathrm{true}}$ 的最佳逼近误差表现为 $\\mathcal{O}(h)$。当数据精确且离散正演映射在逼近空间上是精确的（即精确单元积分的 $A_h$）时，随着 $h\\to 0$，重构误差预计会呈现 $p=1$ 的阶数。使用中点求积时，算子离散化会引入一个阶为 $\\mathcal{O}(h)$ 的额外建模误差，因此总阶数仍为 $p=1$。\n\n你的程序必须：\n- 使用 $y(s)$ 的精确解析公式以避免反演犯罪。禁止使用相同的离散算子生成 $y$。\n- 通过精确单元积分和中点求积两种方式组装 $A_h$。\n- 使用数值稳定的求解器求解 $x_h^\\ast$ 的最小二乘问题。\n- 在一个加密序列上计算 $E_h$。\n\n测试套件：\n- 情况 1（理想情况）：使用精确单元积分的 $A_h$，$N\\in\\{16,32,64,128\\}$。通过对最密的三个网格上的 $\\log(E_h)$ 与 $\\log(h)$ 进行线性回归，计算观测到的阶数 $p_{\\mathrm{obs}}$。\n- 情况 2（求积下的一致性）：使用中点求积的 $A_h^{\\mathrm{mid}}$，$N\\in\\{16,32,64,128\\}$。以相同方式计算观测到的阶数 $p_{\\mathrm{obs}}^{\\mathrm{mid}}$。\n- 情况 3（边缘情况单调性）：验证对于精确 $A_h$ 和 $N\\in\\{8,16,32,64,128\\}$，当 $h$ 减小时，$E_h$ 是否严格递减。\n\n可量化的输出：\n- 对于情况 1，返回浮点数 $p_{\\mathrm{obs}}$（四舍五入到三位小数）和一个布尔值，指示是否满足 $\\lvert p_{\\mathrm{obs}}-1\\rvert\\le 0.15$。\n- 对于情况 2，返回浮点数 $p_{\\mathrm{obs}}^{\\mathrm{mid}}$（四舍五入到三位小数）和一个布尔值，指示是否满足 $\\lvert p_{\\mathrm{obs}}^{\\mathrm{mid}}-1\\rvert\\le 0.15$。\n- 对于情况 3，返回一个布尔值，指示 $E_h$ 是否随网格加密而严格单调递减。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”）。要求的输出顺序是：\n$$\n\\big[ p_{\\mathrm{obs}},\\ \\text{is\\_first\\_order\\_exact},\\ p_{\\mathrm{obs}}^{\\mathrm{mid}},\\ \\text{is\\_first\\_order\\_mid},\\ \\text{is\\_monotone} \\big].\n$$\n不涉及物理单位或角度，因此不需要单位转换。所有数字都应按规定表示为普通浮点数或布尔值。", "solution": "我们从连续算子出发构建反问题\n$$\n(\\mathcal{K}x)(s) = \\int_0^1 K(s,t)\\,x(t)\\,dt,\\quad K(s,t)=\\min(s,t).\n$$\n核函数 $K$ 是一维二阶算子在齐次狄利克雷边界条件下的格林核，它将 $L^2(0,1)$ 有界地映射到 $H^2(0,1)$，这是一个 2 阶的光滑化过程。从精确数据进行重构在无限维空间中是病态的，但是当我们将 $x$ 约束在分片常数构成的有限维空间 $\\mathbb{V}_h$ 中时，带有精确单元积分的离散正演映射在 $\\mathbb{V}_h$ 上是精确的，从而将子空间逼近误差分离出来。\n\n避免反演犯罪要求生成数据 $y$ 的方式与离散算子无关。因此，我们使用连续恒等式来合成 $y$\n$$\ny(s) = \\int_0^s t\\,x_{\\mathrm{true}}(t)\\,dt + s\\int_s^1 x_{\\mathrm{true}}(t)\\,dt,\n$$\n并且我们选择一个光滑的人为构造真值\n$$\nx_{\\mathrm{true}}(t)=\\sin(2\\pi t) + \\tfrac{1}{2}\\cos(3\\pi t).\n$$\n对于这个 $x_{\\mathrm{true}}$，两个积分都可以通过初等微积分解析地计算出来。令 $a=2\\pi$ 和 $b=3\\pi$。我们使用以下恒等式\n$$\n\\int t\\sin(a t)\\,dt = -\\frac{t\\cos(a t)}{a} + \\frac{\\sin(a t)}{a^2},\\quad\n\\int \\sin(a t)\\,dt = -\\frac{\\cos(a t)}{a},\n$$\n$$\n\\int t\\cos(b t)\\,dt = \\frac{t\\sin(b t)}{b} + \\frac{\\cos(b t)}{b^2},\\quad\n\\int \\cos(b t)\\,dt = \\frac{\\sin(b t)}{b}.\n$$\n因此，对于任意 $s\\in[0,1]$,\n$$\n\\int_0^s t\\sin(a t)\\,dt = -\\frac{s\\cos(a s)}{a} + \\frac{\\sin(a s)}{a^2},\\quad\n\\int_s^1 \\sin(a t)\\,dt = -\\frac{\\cos(a)}{a}+\\frac{\\cos(a s)}{a},\n$$\n$$\n\\int_0^s t\\cos(b t)\\,dt = \\frac{s\\sin(b s)}{b} + \\frac{\\cos(b s)}{b^2} - \\frac{1}{b^2},\\quad\n\\int_s^1 \\cos(b t)\\,dt = \\frac{\\sin(b)}{b} - \\frac{\\sin(b s)}{b}.\n$$\n结合这些，我们得到精确数据\n$$\ny(s) = \\left(-\\frac{s\\cos(a s)}{a} + \\frac{\\sin(a s)}{a^2}\\right)\n+ \\tfrac{1}{2}\\left(\\frac{s\\sin(b s)}{b} + \\frac{\\cos(b s)}{b^2} - \\frac{1}{b^2}\\right)\n+ s\\left[ \\left(-\\frac{\\cos(a)}{a}+\\frac{\\cos(a s)}{a}\\right)\n+ \\tfrac{1}{2}\\left(\\frac{\\sin(b)}{b} - \\frac{\\sin(b s)}{b}\\right)\\right].\n$$\n这个 $y$ 相对于连续模型是精确的，从而避免了反演犯罪。\n\n我们用大小为 $h=1/N$ 的均匀网格对 $[0,1]$ 进行离散化，单元为 $I_j=[(j-1)h,jh]$，中点为 $t_j=(j-\\tfrac{1}{2})h$，并设置测量点 $s_i=t_i$。精确单元积分的正演算子通过闭式积分进行组装\n$$\n(A_h)_{ij} = \\int_{I_j} \\min(s_i,t)\\,dt =\n\\begin{cases}\ns_i h, \\text{if } s_i \\le (j-1)h,\\\\\n\\tfrac{1}{2}\\left((jh)^2-((j-1)h)^2\\right), \\text{if } s_i \\ge jh,\\\\\n\\tfrac{1}{2}\\left(s_i^2-((j-1)h)^2\\right) + s_i\\left(jh - s_i\\right), \\text{if } s_i\\in((j-1)h,jh).\n\\end{cases}\n$$\n中点求积组装为\n$$\n(A_h^{\\mathrm{mid}})_{ij} = \\min(s_i,t_j)\\,h.\n$$\n对于每种组装方式，我们求解最小二乘（LS）问题\n$$\nx_h^\\ast = \\operatorname*{arg\\,min}_{x\\in\\mathbb{R}^N}\\|A_h x - y_h\\|_2,\n$$\n其中 $y_h=(y(s_1),\\dots,y(s_N))^\\top$ 是在测量点采样的精确数据。我们使用一个稳健的数值最小二乘求解器，例如通过奇异值分解（SVD），正如标准线性代数程序库中所实现的那样。\n\n然后我们计算离散 $L^2$ 误差\n$$\nE_h = \\sqrt{h}\\,\\|x_h^\\ast - x_{\\mathrm{true}}(t_\\cdot)\\|_2.\n$$\n对于一个光滑的 $x_{\\mathrm{true}}$，通过分片常数的最佳逼近满足\n$$\n\\inf_{v_h\\in\\mathbb{V}_h}\\|x_{\\mathrm{true}}-v_h\\|_{L^2(0,1)} \\le C\\,h\\,\\|x_{\\mathrm{true}}'\\|_{L^2(0,1)},\n$$\n因此我们期望 $E_h=\\mathcal{O}(h)$。通过精确单元积分，离散正演算子在 $\\mathbb{V}_h$ 上是精确的，因此重构的收敛速度与最佳逼近的速度相同。通过中点求积，算子额外地被 $\\mathcal{O}(h)$ 扰动，这对于光滑数据不会改变总体阶数：主导阶数仍为 $p=1$。\n\n为了验证，我们对两种组装方式运行网格加密 $N\\in\\{16,32,64,128\\}$，对最密的三个网格上的 $(\\log(h),\\log(E_h))$ 拟合一条直线，并报告观测到的斜率 $p_{\\mathrm{obs}}$ 和 $p_{\\mathrm{obs}}^{\\mathrm{mid}}$，它们应该接近 $1$。作为一个边缘情况，我们测试 $E_h$ 在 $N\\in\\{8,16,32,64,128\\}$ 上的单调递减性。\n\n程序输出单行\n$$\n\\big[ p_{\\mathrm{obs}},\\ \\text{is\\_first\\_order\\_exact},\\ p_{\\mathrm{obs}}^{\\mathrm{mid}},\\ \\text{is\\_first\\_order\\_mid},\\ \\text{is\\_monotone} \\big],\n$$\n其中 $p_{\\mathrm{obs}}$ 和 $p_{\\mathrm{obs}}^{\\mathrm{mid}}$ 四舍五入到三位小数，如果 $\\lvert p_{\\mathrm{obs}}-1\\rvert\\le 0.15$，$\\text{is\\_first\\_order\\_exact}$ 为真，如果 $\\lvert p_{\\mathrm{obs}}^{\\mathrm{mid}}-1\\rvert\\le 0.15$，$\\text{is\\_first\\_order\\_mid}$ 为真，如果对于精确组装，误差随网格加密严格递减，则 $\\text{is\\_monotone}$ 为真。这确认了预期的阶数，并通过使用解析合成的 $y$ 而非离散算子，演示了如何避免反演犯罪。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef x_true(t):\n    # x_true(t) = sin(2*pi*t) + 0.5*cos(3*pi*t)\n    return np.sin(2*np.pi*t) + 0.5*np.cos(3*np.pi*t)\n\ndef y_exact(s):\n    # Exact y(s) from analytical integration for x_true(t) = sin(2πt) + 0.5 cos(3πt)\n    a = 2*np.pi\n    b = 3*np.pi\n    s = np.asarray(s)\n    # Components for sin(a t)\n    I1 = -s*np.cos(a*s)/a + np.sin(a*s)/(a*a)\n    J1 = (-np.cos(a)/a) + np.cos(a*s)/a\n    # Components for cos(b t)\n    I2 = s*np.sin(b*s)/b + np.cos(b*s)/(b*b) - 1.0/(b*b)\n    J2 = np.sin(b)/b - np.sin(b*s)/b\n    y = I1 + 0.5*I2 + s*(J1 + 0.5*J2)\n    return y\n\ndef assemble_A_exact(s_points, N):\n    # Assemble A_h with exact cell integrals of min(s_i, t) over each cell I_j.\n    s_points = np.asarray(s_points)\n    h = 1.0 / N\n    A = np.zeros((len(s_points), N), dtype=float)\n    # Cell edges\n    edges = np.linspace(0.0, 1.0, N+1)\n    for i, s in enumerate(s_points):\n        for j in range(N):\n            a = edges[j]\n            b = edges[j+1]\n            if s = a:  # cell entirely to the right of s\n                A[i, j] = s * (b - a)\n            elif s >= b:  # cell entirely to the left of s\n                A[i, j] = 0.5 * (b*b - a*a)\n            else:\n                # s is inside the cell (a  s  b)\n                A[i, j] = 0.5*(s*s - a*a) + s*(b - s)\n    return A\n\ndef assemble_A_midpoint(s_points, N):\n    # Assemble A_h^{mid} with midpoint quadrature of min(s_i, t) over each cell I_j.\n    s_points = np.asarray(s_points)\n    h = 1.0 / N\n    mids = (np.arange(N) + 0.5) * h\n    # Compute min(s_i, t_j_mid) for all pairs\n    S = s_points[:, None]\n    T = mids[None, :]\n    A = np.minimum(S, T) * h\n    return A\n\ndef reconstruct_ls(A, y):\n    # Solve least squares min ||A x - y||_2 using robust solver\n    # rcond=None selects machine precision cutoff as default\n    x, *_ = np.linalg.lstsq(A, y, rcond=None)\n    return x\n\ndef compute_error(N, assembly='exact'):\n    # Build s_i = t_i midpoints, assemble A, synthesize y exactly, reconstruct and compute L2 error\n    h = 1.0 / N\n    mids = (np.arange(N) + 0.5) * h\n    y = y_exact(mids)  # exact data sampled at s_i\n    if assembly == 'exact':\n        A = assemble_A_exact(mids, N)\n    elif assembly == 'mid':\n        A = assemble_A_midpoint(mids, N)\n    else:\n        raise ValueError(\"Unknown assembly type\")\n    x_rec = reconstruct_ls(A, y)\n    x_ref = x_true(mids)\n    err = np.sqrt(h) * np.linalg.norm(x_rec - x_ref)\n    return err\n\ndef observed_rate(hs, errs):\n    # Fit slope p in log(err) ~ p*log(h) + c using least squares\n    logh = np.log(hs)\n    loge = np.log(errs)\n    # p = cov(logh, loge)/var(logh)\n    A = np.vstack([logh, np.ones_like(logh)]).T\n    p, c = np.linalg.lstsq(A, loge, rcond=None)[0]\n    return p\n\ndef solve():\n    # Test cases as specified in the problem statement\n    Ns_rate = [16, 32, 64, 128]\n    hs_rate = [1.0/n for n in Ns_rate]\n\n    # Case 1: exact assembly\n    errs_exact = [compute_error(N, 'exact') for N in Ns_rate]\n    # Use finest three meshes for rate\n    hs_exact_fit = np.array(hs_rate[-3:])\n    errs_exact_fit = np.array(errs_exact[-3:])\n    p_exact = observed_rate(hs_exact_fit, errs_exact_fit)\n\n    # Case 2: midpoint assembly\n    errs_mid = [compute_error(N, 'mid') for N in Ns_rate]\n    hs_mid_fit = np.array(hs_rate[-3:])\n    errs_mid_fit = np.array(errs_mid[-3:])\n    p_mid = observed_rate(hs_mid_fit, errs_mid_fit)\n\n    # Case 3: monotonicity with exact assembly\n    Ns_mono = [8, 16, 32, 64, 128]\n    errs_mono = [compute_error(N, 'exact') for N in Ns_mono]\n    is_monotone = all(errs_mono[k+1]  errs_mono[k] for k in range(len(errs_mono)-1))\n\n    # Checks against expected first-order\n    tol = 0.15\n    is_first_order_exact = abs(p_exact - 1.0) = tol\n    is_first_order_mid = abs(p_mid - 1.0) = tol\n\n    results = [\n        round(float(p_exact), 3),\n        bool(is_first_order_exact),\n        round(float(p_mid), 3),\n        bool(is_first_order_mid),\n        bool(is_monotone),\n    ]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3376948"}]}