{"hands_on_practices": [{"introduction": "理论的价值在于实践。本练习旨在将连续的数学算子——即拉东变换及其伴随算子——转化为具体的离散计算机程序。通过亲手实现前向投影和反投影，并执行伴随测试，您将能够深刻理解这些算子之间的对偶关系，这是计算科学和逆问题中验证数值方法正确性的基石。[@problem_id:3416112]", "problem": "您需要为平行束二维计算机断层扫描实现一个Radon变换及其伴随的全离散模型，以及一个斜坡滤波反投影映射。您将使用这个离散模型执行两项验证任务：伴随测试和可微性测试。伴随测试在数值上验证了在指定的内积下，离散反投影是离散Radon变换的伴随。可微性测试验证了滤波反投影算子的Fréchet可微性。\n\n从以下基础概念开始：\n- Radon变换将一个二维紧支可积图像函数（表示为$f(\\mathbf{x})$，其中$\\mathbf{x} \\in \\mathbb{R}^2$）映射到其线积分。这些线积分由角度$\\theta \\in [0,\\pi)$和距原点的有符号距离$s \\in \\mathbb{R}$索引，定义为$f$在直线$\\{\\mathbf{x} \\in \\mathbb{R}^2 : \\mathbf{x} \\cdot \\boldsymbol{\\nu}(\\theta) = s\\}$上的积分，其中$\\boldsymbol{\\nu}(\\theta) = (\\cos \\theta, \\sin \\theta)$。\n- 滤波反投影将在探测器空间中与斜坡核进行的一维卷积与跨角度的反投影相结合，从而从正弦图数据中获得重建。\n- 伴随算子由内积等式$\\langle A x, y \\rangle = \\langle x, A^{\\ast} y \\rangle$定义，该等式对各自希尔伯特空间中的所有元素$x$和$y$成立，其中$A^{\\ast}$表示$A$的伴随，$\\langle \\cdot, \\cdot \\rangle$表示内积。\n\n您必须遵循以下要求实现这些算子的离散近似，不得使用任何闭式反演公式作为捷径：\n\n1. 离散图像网格和坐标。\n   - 在一个大小为$N \\times N$的方形图像网格上工作，该网格表示方形区域$[-1,1] \\times [-1,1]$上的一个紧支函数。\n   - 使用位于坐标$x_i = -1 + \\left(i + \\tfrac{1}{2}\\right)\\Delta$，$y_j = -1 + \\left(j + \\tfrac{1}{2}\\right)\\Delta$的像素中心，其中$i,j \\in \\{0,\\dots,N-1\\}$且$\\Delta = \\tfrac{2}{N}$。\n\n2. 投影几何和采样。\n   - 使用$K$个投影角度，这些角度以弧度为单位在$[0,\\pi)$内均匀分布，即$\\theta_k = \\tfrac{k \\pi}{K}$，其中$k \\in \\{0,\\dots,K-1\\}$。\n   - 使用$M$个探测器单元，其有符号距离$s_m$均匀分布在$[-L,L]$区间内，其中$L = \\sqrt{2}$，即$s_m = -L + \\tfrac{2 L m}{M-1}$，其中$m \\in \\{0,\\dots,M-1\\}$。\n   - 通过沿线上坐标$v \\in [-L,L]$进行数值积分来近似每个在$(\\theta_k, s_m)$处的线积分，使用$N_v$个等距样本$v_n = -L + \\tfrac{2 L n}{N_v-1}$（其中$n \\in \\{0,\\dots,N_v-1\\}$），步长为$\\mathrm{d}v = \\tfrac{2 L}{N_v-1}$。\n\n3. 坐标变换和插值。\n   - 使用由$u = x \\cos \\theta + y \\sin \\theta$和$v = - x \\sin \\theta + y \\cos \\theta$定义的旋转坐标系$(u,v)$。对于固定的角度$\\theta_k$和探测器坐标$s_m$，直线由$u = s_m$和$v \\in [-L,L]$参数化。通过$x = u \\cos \\theta - v \\sin \\theta$和$y = u \\sin \\theta + v \\cos \\theta$转换回笛卡尔坐标。\n   - 在图像网格上使用双线性插值来评估网格外的点$(x,y)$处的图像值。仅包含图像方形区域$[-1,1] \\times [-1,1]$内的点$(x,y)$的贡献。\n   - 将每个$(\\theta_k, s_m)$的线积分近似为对所有$v_n$的双线性插值样本乘以$\\mathrm{d}v$的总和，以此来定义离散Radon变换$R$。\n\n4. 离散伴随。\n   - 将离散反投影$B$定义为对$R$的实现（相对于离散空间上的标准欧几里得内积）的精确算法转置。也就是说，它必须通过反转累加过程来实现：$R$从图像读取并写入正弦图，而$B$必须使用相同的双线性权重和相同的$\\mathrm{d}v$因子从正弦图读取并写入图像。这确保了在使用下面定义的标准欧几里得内积时，对于所有离散化的$f$和$y$，在精确算术下$\\langle R f, y \\rangle = \\langle f, B y \\rangle$成立。\n\n5. 内积。\n   - 在图像网格上使用标准欧几里得内积：对于图像$x,z \\in \\mathbb{R}^{N \\times N}$，$\\langle x,z \\rangle_{\\mathrm{img}} = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} x_{ij} z_{ij}$。\n   - 在正弦图上使用标准欧几里得内积：对于正弦图$p,q \\in \\mathbb{R}^{K \\times M}$，$\\langle p,q \\rangle_{\\mathrm{sin}} = \\sum_{k=0}^{K-1} \\sum_{m=0}^{M-1} p_{km} q_{km}$。\n\n6. 滤波反投影算子。\n   - 定义一个离散斜坡滤波器$H$，它对每个角度沿探测器坐标独立作用。具体方法是将每个角度的探测器样本的离散傅里叶变换乘以一个离散斜坡$|\\omega|$，然后进行逆变换。您可以使用离散傅里叶变换；角度以弧度为单位，不需要物理单位。\n   - 定义滤波反投影映射$F$为$F(y) = B(H(y))$。\n\n7. 要计算的验证任务。\n   - 伴随测试。对于给定的图像$f$和正弦图$y$，计算相对伴随失配\n     $$E_{\\mathrm{adj}} = \\frac{\\left|\\langle R f, y \\rangle_{\\mathrm{sin}} - \\langle f, B y \\rangle_{\\mathrm{img}} \\right|}{\\left|\\langle R f, y \\rangle_{\\mathrm{sin}} \\right| + \\left|\\langle f, B y \\rangle_{\\mathrm{img}} \\right| + 10^{-12}}.$$\n   - 可微性测试。对于给定的基准正弦图$y_0$、一个方向$v$和一个步长$\\varepsilon$，计算$F$的相对线性化误差：\n     $$E_{\\mathrm{diff}} = \\frac{\\left\\| F(y_0 + \\varepsilon v) - F(y_0) - \\varepsilon F(v) \\right\\|_F}{\\left\\| \\varepsilon F(v) \\right\\|_F + 10^{-16}},$$\n     其中$\\|\\cdot\\|_F$表示弗罗贝尼乌斯范数。\n\n角度必须以弧度为单位。不需要物理单位。\n\n测试套件。您的程序必须使用指定的参数和伪随机种子，为以下三个测试用例中的每一个计算上述两个误差。对于所有随机抽样，请使用零均值和单位方差的独立标准正态随机变量。\n- 用例A（一般情况）：$N = 32$, $K = 30$, $M = 45$, $N_v = 201$, $\\varepsilon = 10^{-5}$，此用例中所有随机对象的随机种子为$1$。\n- 用例B（具有单个角度的边界几何）：$N = 16$, $K = 1$, $M = 23$, $N_v = 121$, $\\varepsilon = 10^{-5}$，此用例中所有随机对象的随机种子为$2$。\n- 用例C（较粗的采样，非正方形尺寸）：$N = 28$, $K = 19$, $M = 29$, $N_v = 151$, $\\varepsilon = 10^{-5}$，此用例中所有随机对象的随机种子为$3$。\n\n对于每个用例：\n- 对于伴随测试，使用指定的种子生成$f \\in \\mathbb{R}^{N \\times N}$，并使用相同的种子生成$y \\in \\mathbb{R}^{K \\times M}$。\n- 对于可微性测试，使用相同的种子和给定的参数生成$y_0 \\in \\mathbb{R}^{K \\times M}$和方向$v \\in \\mathbb{R}^{K \\times M}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，顺序为\n$$[E_{\\mathrm{adj}}^{A}, E_{\\mathrm{diff}}^{A}, E_{\\mathrm{adj}}^{B}, E_{\\mathrm{diff}}^{B}, E_{\\mathrm{adj}}^{C}, E_{\\mathrm{diff}}^{C}],$$\n其中上标$A,B,C$分别指代用例A、B和C。输出必须是实值浮点数。角度以弧度为单位，输出不需要单位。", "solution": "该问题要求实现并验证一个用于二维平行束计算机断层扫描（CT）的离散模型。其核心组件是离散Radon变换、其伴随（即反投影算子）以及斜坡滤波反投影算子。该实现通过一项伴随测试和一项可微性测试进行验证。\n\n连续问题的离散化过程如下。由函数$f(\\mathbf{x})$表示的图像定义在方形区域$\\mathbf{x} \\in [-1, 1] \\times [-1, 1]$上，并在一个$N \\times N$像素的网格上进行采样。像素$(i, j)$的中心（其中$i,j \\in \\{0, \\dots, N-1\\}$）位于笛卡尔坐标$(x_i, y_j)$处，其中$x_i = -1 + (i + \\frac{1}{2})\\Delta$且$y_j = -1 + (j + \\frac{1}{2})\\Delta$，像素大小为$\\Delta = \\frac{2}{N}$。正弦图数据在$K$个投影角度$\\theta_k = \\frac{k \\pi}{K}$（其中$k \\in \\{0, \\dots, K-1\\}$）和$M$个探测器单元（距原点的有符号距离）$s_m$处进行采样，$s_m$在$[-L, L]$区间内均匀分布，其中$L = \\sqrt{2}$是图像域的半对角线长度。具体来说，$s_m = -L + \\frac{2Lm}{M-1}$，其中$m \\in \\{0, \\dots, M-1\\}$。\n\n离散Radon变换（由算子$R$表示）将一个$N \\times N$的离散图像$f$映射到一个$K \\times M$的正弦图$p$。正弦图的每个元素$p_{km}$是图像函数沿着由$\\mathbf{x} \\cdot \\boldsymbol{\\nu}(\\theta_k) = s_m$定义的直线的线积分的近似值，其中$\\boldsymbol{\\nu}(\\theta_k) = (\\cos \\theta_k, \\sin \\theta_k)$。该直线由坐标$v \\in [-L, L]$参数化，因此直线上的一个点$\\mathbf{x}$由$\\mathbf{x} = s_m \\boldsymbol{\\nu}(\\theta_k) + v \\boldsymbol{\\nu}(\\theta_k)^{\\perp}$给出，其中$\\boldsymbol{\\nu}(\\theta_k)^{\\perp} = (-\\sin\\theta_k, \\cos\\theta_k)$。该积分通过对沿线的$N_v$个点$v_n$进行黎曼求和来近似，步长为$\\mathrm{d}v = \\frac{2L}{N_v-1}$。在沿线的每个点$(x(v_n), y(v_n))$处，图像值是通过对离散图像网格上四个最近的像素值进行双线性插值来计算的。正弦图在$(\\theta_k, s_m)$处的值则由以下公式给出：\n$$\np_{km} = (R f)_{km} \\approx \\sum_{n=0}^{N_v-1} f_{\\text{interp}}(s_m \\cos\\theta_k - v_n \\sin\\theta_k, s_m \\sin\\theta_k + v_n \\cos\\theta_k) \\cdot \\mathrm{d}v\n$$\n其中$f_{\\text{interp}}$表示双线性插值过程。仅当点$(x,y)$位于图像域$[-1,1]^2$内时，其贡献才被计算在内。\n\n反投影算子（用$B$表示）被定义为Radon变换算子$R$在图像和正弦图空间上相对于标准欧几里得内积的伴随。伴随关系由$\\langle R f, y \\rangle_{\\mathrm{sin}} = \\langle f, B y \\rangle_{\\mathrm{img}}$给出，适用于任何离散图像$f$和正弦图$y$。此属性决定了$B$的算法实现。算子$R$可以被看作是一个“收集”（gather）操作，即对于每个正弦图点，从图像网格中读取值并加权。因此，伴随算子$B$是一个“散布”（scatter）或“溅射”（splatting）操作。对于每个正弦图值$y_{km}$，其贡献$y_{km} \\cdot \\mathrm{d}v$会沿着相同的积分线被分布回图像网格上。在沿线的每个点上，该值使用与前向投影中相同的双线性权重被分布到四个最近的像素上。\n\n滤波反投影算子$F$用于从正弦图中重建图像。它由复合运算$F(y) = B(H(y))$定义，其中$H$是一个斜坡滤波算子。斜坡滤波器$H$独立地作用于正弦图的每一行（即，对于每个固定的角度$\\theta_k$）。它在傅里叶域中实现，具体方法是对探测器样本应用一维离散傅里叶变换（$\\mathcal{F}$），然后乘以一个离散斜坡函数$|\\omega|$，最后应用逆离散傅里叶变换（$\\mathcal{F}^{-1}$）。频率变量$\\omega$对应于沿探测器坐标$s$的空间频率。对于正弦图的单行$y_k(s)$，其操作为$H(y_k) = \\mathcal{F}^{-1}\\{|\\omega| \\mathcal{F}\\{y_k(s)\\}\\}$。\n\n执行两项验证任务。第一项是伴随测试，它数值上验证了所实现的算子$R$和$B$之间的伴随关系。相对伴随失配，\n$$\nE_{\\mathrm{adj}} = \\frac{\\left|\\langle R f, y \\rangle_{\\mathrm{sin}} - \\langle f, B y \\rangle_{\\mathrm{img}} \\right|}{\\left|\\langle R f, y \\rangle_{\\mathrm{sin}} \\right| + \\left|\\langle f, B y \\rangle_{\\mathrm{img}} \\right| + 10^{-12}}\n$$\n是为随机生成的$f$和$y$计算的。由于$B$被构造为$R$的精确算法转置，该误差预计在机器浮点精度的数量级。\n\n第二项任务是针对滤波反投影算子$F$的可微性测试。由于斜坡滤波器$H$和反投影$B$都是线性算子，它们的复合$F = B \\circ H$也是线性的。对于一个线性算子，其Fréchet导数就是该算子本身。这一点通过计算相对线性化误差来验证：\n$$\nE_{\\mathrm{diff}} = \\frac{\\left\\| F(y_0 + \\varepsilon v) - F(y_0) - \\varepsilon F(v) \\right\\|_F}{\\left\\| \\varepsilon F(v) \\right\\|_F + 10^{-16}}\n$$\n对于一个完全线性的实现，分子$F(y_0 + \\varepsilon v) - F(y_0) - \\varepsilon F(v) = (F(y_0) + \\varepsilon F(v)) - F(y_0) - \\varepsilon F(v)$将为零。因此，$E_{\\mathrm{diff}}$也预计接近机器精度，从而证实了实现的线性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates a discrete 2D Radon transform model.\n    \"\"\"\n\n    class TomographyModel:\n        \"\"\"\n        Encapsulates the discrete operators for parallel-beam tomography.\n        \"\"\"\n        def __init__(self, N: int, K: int, M: int, N_v: int):\n            self.N, self.K, self.M, self.N_v = N, K, M, N_v\n            \n            self.L = np.sqrt(2.0)\n            self.delta = 2.0 / N\n\n            self.thetas = np.linspace(0, np.pi, K, endpoint=False)\n            self.s_coords = np.linspace(-self.L, self.L, M) if M > 1 else np.array([0.0])\n            self.v_coords = np.linspace(-self.L, self.L, N_v) if N_v > 1 else np.array([0.0])\n            \n            self.dv = (2 * self.L) / (N_v - 1) if N_v > 1 else 2 * self.L\n\n        def _get_pixel_value(self, img: np.ndarray, i: int, j: int) -> float:\n            if 0 = i  self.N and 0 = j  self.N:\n                return img[i, j]\n            return 0.0\n\n        def radon(self, img: np.ndarray) -> np.ndarray:\n            \"\"\"Discrete Radon Transform (Forward Projection).\"\"\"\n            sino = np.zeros((self.K, self.M))\n\n            for k, theta in enumerate(self.thetas):\n                ct, st = np.cos(theta), np.sin(theta)\n                for m, s in enumerate(self.s_coords):\n                    line_integral = 0.0\n                    for v in self.v_coords:\n                        x = s * ct - v * st\n                        y = s * st + v * ct\n\n                        if abs(x) > 1.0 or abs(y) > 1.0:\n                            continue\n\n                        ix = (x + 1.0) / self.delta - 0.5\n                        iy = (y + 1.0) / self.delta - 0.5\n                        \n                        ix0 = int(np.floor(ix))\n                        iy0 = int(np.floor(iy))\n                        \n                        tx = ix - ix0\n                        ty = iy - iy0\n\n                        v00 = self._get_pixel_value(img, iy0, ix0)\n                        v01 = self._get_pixel_value(img, iy0, ix0 + 1)\n                        v10 = self._get_pixel_value(img, iy0 + 1, ix0)\n                        v11 = self._get_pixel_value(img, iy0 + 1, ix0 + 1)\n                        \n                        interp_val = (v00 * (1 - tx) * (1 - ty) +\n                                      v01 * tx * (1 - ty) +\n                                      v10 * (1 - tx) * ty +\n                                      v11 * tx * ty)\n                        \n                        line_integral += interp_val\n                    \n                    sino[k, m] = line_integral * self.dv\n            return sino\n\n        def back_project(self, sino: np.ndarray) -> np.ndarray:\n            \"\"\"Discrete Back-Projection (Adjoint of Radon).\"\"\"\n            recon = np.zeros((self.N, self.N))\n            \n            for k, theta in enumerate(self.thetas):\n                ct, st = np.cos(theta), np.sin(theta)\n                for m, s in enumerate(self.s_coords):\n                    val_to_add = sino[k, m] * self.dv\n                    if val_to_add == 0:\n                        continue\n\n                    for v in self.v_coords:\n                        x = s * ct - v * st\n                        y = s * st + v * ct\n\n                        if abs(x) > 1.0 or abs(y) > 1.0:\n                            continue\n\n                        ix = (x + 1.0) / self.delta - 0.5\n                        iy = (y + 1.0) / self.delta - 0.5\n                        \n                        ix0 = int(np.floor(ix))\n                        iy0 = int(np.floor(iy))\n                        \n                        tx = ix - ix0\n                        ty = iy - iy0\n                        \n                        w00 = (1 - tx) * (1 - ty)\n                        w01 = tx * (1 - ty)\n                        w10 = (1 - tx) * ty\n                        w11 = tx * ty\n\n                        ix1 = ix0 + 1\n                        iy1 = iy0 + 1\n                        \n                        if 0 = iy0  self.N and 0 = ix0  self.N: recon[iy0, ix0] += w00 * val_to_add\n                        if 0 = iy0  self.N and 0 = ix1  self.N: recon[iy0, ix1] += w01 * val_to_add\n                        if 0 = iy1  self.N and 0 = ix0  self.N: recon[iy1, ix0] += w10 * val_to_add\n                        if 0 = iy1  self.N and 0 = ix1  self.N: recon[iy1, ix1] += w11 * val_to_add\n            return recon\n\n        def filter_sinogram(self, sino: np.ndarray) -> np.ndarray:\n            \"\"\"Ramp filtering of the sinogram.\"\"\"\n            if self.M == 1:\n                return np.zeros_like(sino)\n\n            ds = (2 * self.L) / (self.M - 1)\n            omega = np.fft.fftfreq(self.M, d=ds)\n            ramp = np.abs(omega)\n            \n            filtered_sino = np.zeros_like(sino, dtype=float)\n            for k in range(self.K):\n                row_fft = np.fft.fft(sino[k, :])\n                filtered_row_fft = row_fft * ramp\n                filtered_row = np.fft.ifft(filtered_row_fft)\n                filtered_sino[k, :] = np.real(filtered_row)\n                \n            return filtered_sino\n\n        def fbp(self, sino: np.ndarray) -> np.ndarray:\n            \"\"\"Filtered Back-Projection.\"\"\"\n            return self.back_project(self.filter_sinogram(sino))\n\n    test_cases = [\n        {'N': 32, 'K': 30, 'M': 45, 'N_v': 201, 'eps': 1e-5, 'seed': 1},\n        {'N': 16, 'K': 1, 'M': 23, 'N_v': 121, 'eps': 1e-5, 'seed': 2},\n        {'N': 28, 'K': 19, 'M': 29, 'N_v': 151, 'eps': 1e-5, 'seed': 3},\n    ]\n\n    results = []\n    for case in test_cases:\n        N, K, M, N_v = case['N'], case['K'], case['M'], case['N_v']\n        eps, seed = case['eps'], case['seed']\n        \n        model = TomographyModel(N, K, M, N_v)\n        rng = np.random.default_rng(seed)\n\n        # 1. Adjoint Test\n        f = rng.standard_normal(size=(N, N))\n        y = rng.standard_normal(size=(K, M))\n        \n        Rf = model.radon(f)\n        By = model.back_project(y)\n        \n        inner_prod_sin = np.sum(Rf * y)\n        inner_prod_img = np.sum(f * By)\n        \n        E_adj_num = np.abs(inner_prod_sin - inner_prod_img)\n        E_adj_den = np.abs(inner_prod_sin) + np.abs(inner_prod_img) + 1e-12\n        E_adj = E_adj_num / E_adj_den\n        results.append(E_adj)\n\n        # 2. Differentiability Test\n        y0 = rng.standard_normal(size=(K, M))\n        v = rng.standard_normal(size=(K, M))\n\n        Fy0 = model.fbp(y0)\n        F_y0_eps_v = model.fbp(y0 + eps * v)\n        Fv = model.fbp(v)\n        \n        numerator = np.linalg.norm(F_y0_eps_v - Fy0 - eps * Fv)\n        denominator = np.linalg.norm(eps * Fv) + 1e-16\n        E_diff = numerator / denominator\n        results.append(E_diff)\n        \n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3416112"}, {"introduction": "在实际应用中，任何测量都不可避免地伴随着噪声，这直接影响重建图像的可靠性。本练习将引导您超越简单的图像重建，进入不确定性量化（UQ）这一关键领域。您将推导并实现一种方法，用于预测并验证由测量噪声引起的重建图像中每个像素的方差，这对于任何定量的科学或医学诊断都至关重要。[@problem_id:3416055]", "problem": "给定一个基于拉东变换和滤波反投影 (FBP) 在平行束几何下的线性图像重建设定。设未知图像为一个定义在方形区域 $[-1,1]\\times[-1,1]$ 上的实值函数 $f(x,y)$。在角度 $\\theta$ 和带符号探测器坐标 $s$ 处的拉东变换 $R f(\\theta,s)$ 定义为 $f$ 沿着与单位方向 $\\boldsymbol{n}(\\theta) = (\\cos\\theta,\\sin\\theta)$ 正交的直线的积分：\n$$\nR f(\\theta,s) = \\int_{\\mathbb{R}^2} f(x,y)\\,\\delta\\big(s - x\\cos\\theta - y\\sin\\theta\\big)\\,dx\\,dy,\n$$\n其中 $\\delta(\\cdot)$ 表示狄拉克δ分布。滤波反投影 (FBP) 通过首先对每个固定的 $\\theta$，沿着 $s$ 对 $R f(\\theta,\\cdot)$ 应用一维高通滤波器，然后进行角度反投影，来重建 $f(x,y)$ 的一个近似 $\\hat{f}(x,y)$。在离散设定中，我们在 $[0,\\pi)$ 弧度范围内均匀采样角度 $\\{\\theta_k\\}_{k=0}^{K-1}$，并均匀采样覆盖 $[-s_{\\max}, s_{\\max}]$ 的探测器坐标 $\\{s_j\\}_{j=0}^{D-1}$。离散化的正弦图是一个数组 $g_{k,j} \\approx R f(\\theta_k, s_j)$。\n\n假设在离散化的正弦图上存在加性、零均值的高斯测量噪声，其协方差已知。设测量数据为 $m_{k,j} = g_{k,j} + \\eta_{k,j}$，其中 $\\mathbb{E}[\\eta_{k,j}] = 0$，协方差矩阵为 $\\Sigma \\in \\mathbb{R}^{(K D)\\times(K D)}$。从 $m$ 到重建图像 $\\hat{f}$ 的 FBP 映射是线性的，并且可以写成一个从向量化正弦图到向量化图像的单一线性算子。\n\n您的任务是推导、实现并验证通过 FBP 的不确定性传播，具体包括：\n- 从第一性原理出发，推导测量协方差 $\\Sigma$ 如何通过 FBP 线性算子传播，从而得到重建图像 $\\hat{f}$ 的逐像素方差图。\n- 实现一个离散 FBP，该 FBP 沿着探测器坐标使用斜坡状高通滤波器，对每个角度使用基于离散傅里叶变换的滤波，并在反投影时使用周期性插值。\n- 通过已实现的离散 FBP 算子传播已知的测量协方差，来预测逐像素方差图。\n- 通过蒙特卡洛重建来验证预测的逐像素方差图，具体方法是使用独立的高斯噪声实现进行重复的 FBP 重建，并计算每像素的样本方差。使用定量指标比较预测和经验方差图。\n\n所有计算中的角度单位必须是弧度。离散化和几何细节：\n- 使用大小为 $N\\times N$ 的方形图像网格，其中 $N$ 由每个测试用例指定，均匀覆盖坐标 $(x,y)\\in[-1,1]\\times[-1,1]$。\n- 使用 $K$ 个均匀间隔的角度 $\\theta_k = k\\,\\pi/K$，其中 $k\\in\\{0,1,\\dots,K-1\\}$。\n- 使用 $D$ 个探测器样本，均匀覆盖 $[-s_{\\max}, s_{\\max}]$，其中 $s_{\\max} = 1$，样本间距为 $\\Delta s = 2 s_{\\max}/(D-1)$。\n- 在反投影已滤波的投影到像素时，在探测器索引空间中使用周期性插值。\n\n要使用的噪声模型：\n- 在所有 $(k,j)$ 上独立同分布 (i.i.d.) 且方差为 $\\sigma^2$ 的高斯噪声。\n- 角度相关的异方差高斯噪声，其方差 $\\sigma_k^2$ 随 $\\theta_k$ 变化，但在固定的 $k$ 下对所有探测器索引 $j$ 保持不变。\n- 零噪声的边界情况。\n\n您必须使用以下具有固定参数的测试套件：\n- 测试用例1（理想情况）：$N=32$，$K=18$，$D=64$，$\\sigma^2 = 10^{-4}$，蒙特卡洛重复实验次数 $M=200$。\n- 测试用例2（异方差）：$N=32$，$K=18$，$D=64$，角度相关方差 $\\sigma_k^2 = 10^{-4}\\,\\big(1 + 0.5\\,\\sin\\theta_k\\big)$，蒙特卡洛重复实验次数 $M=200$。\n- 测试用例3（边界）：$N=32$，$K=18$，$D=64$，$\\sigma^2 = 0$，蒙特卡洛重复实验次数 $M=50$。\n\n为了科学上的真实性，实现一个非平凡的体模 $f(x,y)$（例如，高斯凸起的和），为蒙特卡洛重建生成一个基线正弦图 $g_{k,j}\\approx R f(\\theta_k,s_j)$。但是请注意，对于线性 FBP 算子和加性零均值噪声，$\\hat{f}$ 的逐像素方差仅取决于噪声统计和算子，而不取决于体模。\n\n您的程序必须：\n- 隐式地构造离散 FBP 算子，并通过该算子传播测量协方差来预测逐像素方差图，而不形成超出必要大小的稠密矩阵。\n- 如上所述，通过蒙特卡洛模拟验证预测结果，为每个测试用例计算两个指标：在所有 $N^2$ 个像素上，预测和经验逐像素方差之间的均方根差 (RMSD)，以及最大绝对差 (MAXD)。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{RMSD}_1,\\text{MAXD}_1,\\text{RMSD}_2,\\text{MAXD}_2,\\text{RMSD}_3,\\text{MAXD}_3]$，其中下标对应于测试用例编号。\n\n所有答案都是纯数值。角度必须是弧度，并且没有需要报告的物理单位。最终程序必须是自包含的，并且可以按原样执行。", "solution": "本问题要求对计算机断层扫描中的滤波反投影 (FBP) 算法进行不确定性传播的推导和实现。我们首先将推导理论框架，用于将测量噪声协方差通过线性 FBP 算子进行传播，以获得逐像素方差图。随后，我们将根据蒙特卡洛模拟的经验结果来验证这一理论预测。\n\n### 1. 方差传播的理论推导\n\n滤波反投影 (FBP) 算法是一个线性过程。设离散的、测量的正弦图由一个向量化的列向量 $\\mathbf{m} \\in \\mathbb{R}^{KD}$ 表示，其中 $K$ 是投影角度的数量， $D$ 是每个角度的探测器单元数量。同样，设重建的图像由一个向量化的向量 $\\hat{\\mathbf{f}} \\in \\mathbb{R}^{N^2}$ 表示，其中图像大小为 $N \\times N$。FBP 的线性特性允许我们将重建过程表示为矩阵向量乘积：\n$$\n\\hat{\\mathbf{f}} = \\mathbf{L} \\mathbf{m}\n$$\n其中 $\\mathbf{L} \\in \\mathbb{R}^{N^2 \\times KD}$ 是代表整个 FBP 流水线（滤波和反投影）的线性算子。\n\n测量模型由加性、零均值的高斯噪声给出：\n$$\n\\mathbf{m} = \\mathbf{g} + \\mathbf{\\eta}\n$$\n其中 $\\mathbf{g}$ 是真实的、无噪声的正弦图，$\\mathbf{\\eta}$ 是噪声向量，满足 $\\mathbb{E}[\\mathbf{\\eta}] = \\mathbf{0}$。测量噪声的协方差由矩阵 $\\Sigma_m = \\mathbb{E}[\\mathbf{\\eta}\\mathbf{\\eta}^T] \\in \\mathbb{R}^{KD \\times KD}$ 给出。\n\n重建的图像可以用真实的正弦图和噪声来表示：\n$$\n\\hat{\\mathbf{f}} = \\mathbf{L}(\\mathbf{g} + \\mathbf{\\eta}) = \\mathbf{L}\\mathbf{g} + \\mathbf{L}\\mathbf{\\eta}\n$$\n项 $\\mathbf{L}\\mathbf{g}$ 代表从无噪声数据得到的理想重建，我们可以将其表示为 $\\mathbf{f}_{\\text{ideal}}$。项 $\\mathbf{L}\\mathbf{\\eta}$ 代表重建图像中的噪声分量。重建的期望值为 $\\mathbb{E}[\\hat{\\mathbf{f}}] = \\mathbf{L}\\mathbf{g} + \\mathbf{L}\\mathbb{E}[\\mathbf{\\eta}] = \\mathbf{f}_{\\text{ideal}}$。\n\n重建图像的协方差 $\\Sigma_f \\in \\mathbb{R}^{N^2 \\times N^2}$ 推导如下：\n$$\n\\Sigma_f = \\mathbb{E}\\left[ (\\hat{\\mathbf{f}} - \\mathbb{E}[\\hat{\\mathbf{f}}]) (\\hat{\\mathbf{f}} - \\mathbb{E}[\\hat{\\mathbf{f}}])^T \\right] = \\mathbb{E}\\left[ (\\mathbf{L}\\mathbf{\\eta}) (\\mathbf{L}\\mathbf{\\eta})^T \\right]\n$$\n$$\n\\Sigma_f = \\mathbb{E}\\left[ \\mathbf{L}\\mathbf{\\eta}\\mathbf{\\eta}^T\\mathbf{L}^T \\right] = \\mathbf{L} \\mathbb{E}\\left[\\mathbf{\\eta}\\mathbf{\\eta}^T\\right] \\mathbf{L}^T\n$$\n这就得到了线性协方差传播的核心公式：\n$$\n\\Sigma_f = \\mathbf{L} \\Sigma_m \\mathbf{L}^T\n$$\n我们的目标是计算重建的逐像素方差，这对应于图像协方差矩阵 $\\Sigma_f$ 的对角线元素。设 $p$ 是向量化图像中像素的索引，范围从 $0$ 到 $N^2-1$。第 $p$ 个像素的方差是 $(\\Sigma_f)_{pp}$。\n\n问题中指定的噪声模型（独立同分布和角度相关）导致了对角的测量协方差矩阵 $\\Sigma_m$。设 $\\sigma_{k,j}^2$ 是在角度 $\\theta_k$ 和探测器位置 $s_j$ 处的测量方差。那么 $\\Sigma_m = \\text{diag}(\\{\\sigma_{k,j}^2\\})$，其中方差的排序与正弦图的向量化方式一致。\n\n第 $p$ 个像素的方差是：\n$$\n\\text{Var}(\\hat{f}_p) = (\\mathbf{L} \\Sigma_m \\mathbf{L}^T)_{pp} = \\sum_{i=0}^{KD-1} \\sum_{j=0}^{KD-1} L_{pi} (\\Sigma_m)_{ij} L_{pj}\n$$\n由于 $\\Sigma_m$ 是对角的，$(\\Sigma_m)_{ij} = \\sigma_i^2 \\delta_{ij}$（使用单个索引 $i$ 代表 $(k,j)$）。表达式简化为：\n$$\n\\text{Var}(\\hat{f}_p) = \\sum_{i=0}^{KD-1} L_{pi}^2 \\sigma_i^2\n$$\n为清晰起见，恢复使用双索引 $(k,j)$，其中 $i$ 对应于 $(k,j)$：\n$$\n\\text{Var}(\\hat{f}_p) = \\sum_{k=0}^{K-1} \\sum_{j=0}^{D-1} \\left(L_{p, (k,j)}\\right)^2 \\sigma_{k,j}^2\n$$\n其中 $L_{p, (k,j)}$ 是算子 $\\mathbf{L}$ 中将 $(k,j)$ 处的正弦图值映射到图像像素 $p$ 的元素。\n\n### 2. 方差预测的算法实现\n\n构造完整的矩阵 $\\mathbf{L}$ 在计算上是不可行的。需要一种更实用的“无矩阵”方法。$\\text{Var}(\\hat{f}_p)$ 的表达式可以从算法角度进行解释。令 $\\mathbf{c}_{k,j} = \\mathbf{L}\\boldsymbol{\\delta}_{k,j}$ 为矩阵 $\\mathbf{L}$ 的第 $(k,j)$ 列。这个列向量正是将 FBP 算法应用于“delta 正弦图”所获得的重建图像——即一个除了在投影角度 $\\theta_k$ 和探测器仓 $s_j$ 处值为 $1$ 外，其他地方都为零的正弦图。该向量的元素是 $(c_{k,j})_p = L_{p, (k,j)}$。\n\n将此代入方差公式，像素方差变为对所有正弦图仓的求和：\n$$\n\\text{Var}(\\hat{f}_p) = \\sum_{k=0}^{K-1} \\sum_{j=0}^{D-1} \\sigma_{k,j}^2 \\left( (c_{k,j})_p \\right)^2\n$$\n这个公式提供了一个直接计算整个方差图 $\\mathbf{V}$ 的算法，其中 $V_p = \\text{Var}(\\hat{f}_p)$：\n1. 初始化一个大小为 $N \\times N$ 的方差图 $\\mathbf{V}$，所有元素为零。\n2. 对于从 $k=0, \\dots, K-1$ 和 $j=0, \\dots, D-1$ 的每个正弦图仓 $(k,j)$：\n    a. 创建一个大小为 $K \\times D$ 的 delta 正弦图 $\\boldsymbol{\\delta}_{k,j}$。\n    b. 对 $\\boldsymbol{\\delta}_{k,j}$ 应用 FBP 重建算法以获得图像 $\\mathbf{c}_{k,j}$。\n    c. 对该图像进行逐元素平方：$\\mathbf{c}_{k,j} \\odot \\mathbf{c}_{k,j}$。\n    d. 乘以对应的噪声方差 $\\sigma_{k,j}^2$ 并将结果加到总方差图中：$\\mathbf{V} \\leftarrow \\mathbf{V} + \\sigma_{k,j}^2 (\\mathbf{c}_{k,j} \\odot \\mathbf{c}_{k,j})$。\n\n此过程无需存储算子 $\\mathbf{L}$ 即可计算出精确的理论方差图，满足了问题的约束。\n\n### 3. FBP 与蒙特卡洛验证\n\n实现将包括以下几个部分：\n- **FBP 算法**：一个函数，它接受一个 $K \\times D$ 的正弦图并返回一个 $N \\times N$ 的图像。\n    - **滤波**：对于 $K$ 个投影中的每一个，应用一个一维高通斜坡滤波器。这可以通过使用快速傅里叶变换 (FFT) 在傅里叶域中高效实现。该滤波器在频率空间中定义为与频率的绝对值成正比，即 $|\\nu|$。\n    - **反投影**：然后将滤波后的投影反投影到图像网格上。对于每个像素 $(x,y)$ 和角度 $\\theta_k$，计算相应的探测器坐标 $s' = x\\cos\\theta_k + y\\sin\\theta_k$。根据指定，通过对探测器索引进行周期性线性插值来找到在 $s'$ 处的滤波投影值。对于每个像素，将来自所有角度的贡献相加，然后乘以一个最终的归一化常数（我们使用 $\\pi/(2K)$）。\n- **方差预测**：实现第 2 节中推导的算法，该算法会重复调用 FBP 函数。\n- **蒙特卡洛验证**：为了验证预测的方差，我们进行蒙特卡洛模拟。\n    1. 从一个解析体模（高斯凸起的和，其拉东变换也是高斯凸起的和）生成一个无噪声的“基准真相”正弦图 $\\mathbf{g}$。\n    2. 根据指定的噪声协方差 $\\Sigma_m$ 生成大量（$M$ 个）独立的噪声实现 $\\mathbf{\\eta}^{(i)}$。\n    3. 对于每次实现，创建一个带噪正弦图 $\\mathbf{m}^{(i)} = \\mathbf{g} + \\mathbf{\\eta}^{(i)}$。\n    4. 使用相同的 FBP 算法重建每个 $\\mathbf{m}^{(i)}$，得到一组 $M$ 个重建图像 $\\{\\hat{\\mathbf{f}}^{(i)}\\}_{i=1}^M$。\n    5. 对这 $M$ 次重建中的每个像素计算样本方差。这会产生一个经验方差图。\n- **比较**：使用均方根差 (RMSD) 和最大绝对差 (MAXD) 作为指标，将理论预测的方差图与蒙特卡洛模拟得出的经验方差图进行比较。零噪声测试用例作为一个关键的合理性检查，其中预测方差和经验方差都应恒为零。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for FBP uncertainty propagation.\n    \"\"\"\n\n    def get_fbp_reconstruction(sinogram, N, K, D):\n        \"\"\"\n        Performs Filtered Back-Projection (FBP) reconstruction.\n        \n        Args:\n            sinogram (np.ndarray): The input sinogram of shape (K, D).\n            N (int): The side length of the square output image.\n            K (int): The number of projection angles.\n            D (int): The number of detector bins.\n        \n        Returns:\n            np.ndarray: The reconstructed image of shape (N, N).\n        \"\"\"\n        # Define image and sinogram coordinates\n        image_coords = np.linspace(-1.0, 1.0, N)\n        xx, yy = np.meshgrid(image_coords, image_coords)\n        \n        thetas = np.linspace(0.0, np.pi, K, endpoint=False)\n        detector_spacing = 2.0 / (D - 1) if D > 1 else 0\n\n        # Create ramp filter in Fourier domain\n        # A simple |f| filter. Normalization is handled by using the same FBP\n        # for prediction and MC.\n        ramp_filter = np.abs(np.fft.rfftfreq(D))\n        \n        # Filter projections\n        filtered_sinogram = np.zeros_like(sinogram)\n        for i in range(K):\n            projection = sinogram[i, :]\n            projection_fft = np.fft.rfft(projection)\n            filtered_projection_fft = projection_fft * ramp_filter\n            filtered_sinogram[i, :] = np.fft.irfft(filtered_projection_fft, n=D)\n            \n        # Back-project\n        reconstructed_image = np.zeros((N, N), dtype=np.float64)\n        detector_indices = np.arange(D)\n        \n        for i in range(K):\n            theta = thetas[i]\n            # Coordinates in the detector space for each pixel\n            s_coords = xx * np.cos(theta) + yy * np.sin(theta)\n            \n            # Map s_coords to fractional detector indices for interpolation\n            # s = -1 + j * ds => j = (s + 1) / ds\n            if detector_spacing > 0:\n                j_float = (s_coords + 1.0) / detector_spacing\n            else:\n                j_float = np.full((N,N), (D-1)/2.0)\n\n            # Periodic interpolation\n            interpolated_projection = np.interp(\n                j_float.ravel(),\n                detector_indices,\n                filtered_sinogram[i, :],\n                period=D\n            ).reshape(N, N)\n            \n            reconstructed_image += interpolated_projection\n\n        # Normalization constant for FBP\n        reconstructed_image *= np.pi / (2.0 * K)\n            \n        return reconstructed_image\n\n    def predict_variance(noise_variances, N, K, D):\n        \"\"\"\n        Predicts the per-pixel variance map using the derived formula.\n        \n        Args:\n            noise_variances (np.ndarray): Per-measurement variance, shape (K, D).\n            N (int): Image size.\n            K (int): Number of angles.\n            D (int): Number of detector bins.\n        \n        Returns:\n            np.ndarray: The predicted variance map of shape (N, N).\n        \"\"\"\n        total_variance_map = np.zeros((N, N), dtype=np.float64)\n        \n        for k_in in range(K):\n            for j_in in range(D):\n                if noise_variances[k_in, j_in] == 0:\n                    continue\n                \n                # Create a delta sinogram\n                delta_sino = np.zeros((K, D))\n                delta_sino[k_in, j_in] = 1.0\n                \n                # Reconstruct the image from the delta sinogram -> column of L\n                img_c_kj = get_fbp_reconstruction(delta_sino, N, K, D)\n                \n                # Accumulate variance\n                total_variance_map += noise_variances[k_in, j_in] * (img_c_kj ** 2)\n                \n        return total_variance_map\n\n    def create_phantom_sinogram(K, D):\n        \"\"\"\n        Generates a ground-truth sinogram from an analytical phantom.\n        The phantom is a sum of two Gaussian bumps.\n        \n        Args:\n            K (int): Number of angles.\n            D (int): Number of detector bins.\n        \n        Returns:\n            np.ndarray: The ground-truth sinogram of shape (K, D).\n        \"\"\"\n        thetas = np.linspace(0.0, np.pi, K, endpoint=False)\n        s_coords = np.linspace(-1.0, 1.0, D)\n        \n        # Phantom parameters: (Amplitude, x0, y0, sigma)\n        gaussians = [\n            (1.0, 0.3, 0.2, 0.1),\n            (0.5, -0.5, 0.4, 0.08)\n        ]\n        \n        sinogram = np.zeros((K, D))\n        \n        for A, x0, y0, sigma in gaussians:\n            for i, theta in enumerate(thetas):\n                s0_theta = x0 * np.cos(theta) + y0 * np.sin(theta)\n                # Radon transform of an isotropic Gaussian\n                projection = A * np.sqrt(2 * np.pi) * sigma * np.exp(-(s_coords - s0_theta)**2 / (2 * sigma**2))\n                sinogram[i, :] += projection\n\n        return sinogram\n\n    def run_monte_carlo(base_sinogram, noise_variances, M, N, K, D):\n        \"\"\"\n        Runs Monte Carlo simulation to find the empirical variance map.\n        \n        Args:\n            base_sinogram (np.ndarray): Ground-truth sinogram.\n            noise_variances (np.ndarray): Per-measurement variance.\n            M (int): Number of Monte Carlo replicates.\n            N, K, D (int): Geometry parameters.\n        \n        Returns:\n            np.ndarray: The empirical variance map of shape (N, N).\n        \"\"\"\n        if M == 0 or np.all(noise_variances == 0):\n            return np.zeros((N, N))\n\n        reconstructions = np.zeros((M, N, N))\n        noise_stds = np.sqrt(noise_variances)\n        \n        # for reproducible results\n        rng = np.random.default_rng(seed=42)\n\n        for i in range(M):\n            noise = rng.normal(0.0, noise_stds, size=(K, D))\n            noisy_sinogram = base_sinogram + noise\n            reconstructions[i, :, :] = get_fbp_reconstruction(noisy_sinogram, N, K, D)\n            \n        empirical_variance_map = np.var(reconstructions, axis=0, ddof=1)\n        return empirical_variance_map\n\n    test_cases = [\n        # (N, K, D, M, noise_params, case_type)\n        (32, 18, 64, 200, {'sigma_sq': 1e-4}, 'iid'),\n        (32, 18, 64, 200, {}, 'heteroskedastic'),\n        (32, 18, 64, 50,  {'sigma_sq': 0.0}, 'zero_noise')\n    ]\n\n    results = []\n    \n    # Pre-calculate base sinogram\n    base_sinogram = create_phantom_sinogram(test_cases[0][1], test_cases[0][2])\n\n    for N, K, D, M, params, case_type in test_cases:\n        thetas = np.linspace(0.0, np.pi, K, endpoint=False)\n        \n        if case_type == 'iid':\n            noise_variances = np.full((K, D), params['sigma_sq'])\n        elif case_type == 'heteroskedastic':\n            # Angle-dependent variance: sigma_k^2 = 1e-4 * (1 + 0.5 * sin(theta_k))\n            var_k = 1e-4 * (1.0 + 0.5 * np.sin(thetas))\n            noise_variances = np.tile(var_k[:, np.newaxis], (1, D))\n        elif case_type == 'zero_noise':\n            noise_variances = np.full((K, D), params['sigma_sq'])\n\n        # Predict variance\n        predicted_var = predict_variance(noise_variances, N, K, D)\n        \n        # Run Monte Carlo to get empirical variance\n        empirical_var = run_monte_carlo(base_sinogram, noise_variances, M, N, K, D)\n\n        # Calculate metrics\n        diff = predicted_var - empirical_var\n        rmsd = np.sqrt(np.mean(diff**2))\n        maxd = np.max(np.abs(diff))\n        \n        results.extend([rmsd, maxd])\n        \n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "3416055"}, {"introduction": "滤波反投影（FBP）算法为何如此有效？本练习将带您深入探索其背后的数学原理，揭示它与更普适的迭代优化方法之间的深刻联系。通过将 FBP 的修正过程视为一种预处理的 Landweber 迭代，您将分析其核心算子 $\\mathcal{R}^{\\ast}\\mathcal{W}\\mathcal{R}$ 的谱特性，从而领悟到 FBP 不仅仅是一个巧妙的配方，更是一个具有坚实理论基础的最优单步解。[@problem_id:3416090]", "problem": "考虑二维平行束拉东变换 $\\mathcal{R}$，它为足够光滑且快速衰减的函数 $f:\\mathbb{R}^2 \\to \\mathbb{C}$ 定义如下：\n$$\n(\\mathcal{R} f)(\\theta,s) \\;=\\; \\int_{\\mathbb{R}^2} f(x)\\,\\delta\\!\\big(s - x \\cdot \\theta\\big)\\, \\mathrm{d}x,\\quad \\theta \\in [0,\\pi),\\; s \\in \\mathbb{R},\n$$\n其希尔伯特空间内积为\n$$\n\\langle f_1,f_2 \\rangle_{L^2(\\mathbb{R}^2)} \\;=\\; \\int_{\\mathbb{R}^2} f_1(x)\\,\\overline{f_2(x)}\\,\\mathrm{d}x,\\qquad\n\\langle g_1,g_2 \\rangle_{L^2([0,\\pi)\\times \\mathbb{R})} \\;=\\; \\int_{0}^{\\pi}\\!\\int_{\\mathbb{R}} g_1(\\theta,s)\\,\\overline{g_2(\\theta,s)}\\,\\mathrm{d}s\\,\\mathrm{d}\\theta,\n$$\n因此希尔伯特伴随算子 $\\mathcal{R}^{\\ast}$ 是反投影算子\n$$\n(\\mathcal{R}^{\\ast} g)(x) \\;=\\; \\int_{0}^{\\pi} g(\\theta, x \\cdot \\theta)\\,\\mathrm{d}\\theta.\n$$\n令 $\\mathcal{F}$ 表示二维傅里叶变换\n$$\n\\widehat{f}(\\xi) \\;=\\; \\int_{\\mathbb{R}^2} f(x)\\,\\exp\\!\\big(-\\mathrm{i}\\,\\xi \\cdot x\\big)\\,\\mathrm{d}x,\\qquad \\xi \\in \\mathbb{R}^2,\n$$\n其逆变换为\n$$\nf(x) \\;=\\; \\frac{1}{(2\\pi)^{2}}\\int_{\\mathbb{R}^2} \\widehat{f}(\\xi)\\,\\exp\\!\\big(\\mathrm{i}\\,\\xi \\cdot x\\big)\\,\\mathrm{d}\\xi,\n$$\n并令 $\\mathcal{F}_s$ 表示关于探测器变量 $s$ 的一维傅里叶变换，\n$$\n(\\mathcal{F}_s g)(\\theta,\\omega) \\;=\\; \\int_{\\mathbb{R}} g(\\theta,s)\\,\\exp\\!\\big(-\\mathrm{i}\\,\\omega s\\big)\\,\\mathrm{d}s,\\qquad \\omega \\in \\mathbb{R}.\n$$\n假设傅里叶切片定理成立，即\n$$\n(\\mathcal{F}_s \\mathcal{R} f)(\\theta,\\omega) \\;=\\; \\widehat{f}\\!\\big(\\omega\\,\\theta\\big).\n$$\n定义在正弦图上的滤波反投影 (FBP) 加权算子 $\\mathcal{W}$ 为关于变量 $s$ 的卷积，其频率响应为斜坡乘子，即\n$$\n(\\mathcal{F}_s\\, \\mathcal{W} g)(\\theta,\\omega) \\;=\\; |\\omega|\\,(\\mathcal{F}_s g)(\\theta,\\omega).\n$$\n考虑 FBP 的预处理 Landweber 迭代\n$$\nx_{k+1} \\;=\\; x_k \\;+\\; \\beta\\,\\mathcal{R}^{\\ast}\\,\\mathcal{W}\\,\\big(y - \\mathcal{R} x_k\\big),\n$$\n其中标量增益 $\\beta \\in \\mathbb{R}$，数据为无噪声数据 $y = \\mathcal{R} x^{\\dagger}$，对应某个真实解 $x^{\\dagger} \\in L^2(\\mathbb{R}^2)$。\n\n从上述定义出发，并仅使用已验证的事实（特别是傅里叶切片定理），完成以下任务：\n\n(1) 在二维傅里叶域中，推导复合算子 $\\mathcal{A} \\equiv \\mathcal{R}^{\\ast}\\,\\mathcal{W}\\,\\mathcal{R}$ 的谱作用。也就是说，找到径向乘子 $m(|\\xi|)$ 使得\n$$\n\\widehat{\\mathcal{A} f}(\\xi) \\;=\\; m\\!\\big(|\\xi|\\big)\\,\\widehat{f}(\\xi).\n$$\n\n(2) 结论：$\\mathcal{A}$ 是单位算子的一个常数倍，并确定该常数 $c$ 使得\n$$\n\\mathcal{A} \\;=\\; c\\,\\mathrm{Id}.\n$$\n\n(3) 对于误差 $e_k = x_k - x^{\\dagger}$，用 $c$ 写出误差传播算子 $E(\\beta)$ 及其谱半径 $\\rho(\\beta)$。\n\n(4) 确定在 $\\beta  0$ 上使 $\\rho(\\beta)$ 最小化的 $\\beta$ 值以及相应的最小谱半径。将你的最终答案以单个闭式解析表达式对 $\\big(\\beta^{\\star}, \\rho_{\\min}\\big)$ 的形式给出。不需要数值近似，也不涉及单位。使用精确常数陈述你的最终答案。如果你报告多个量，请将它们呈现在一个单行矩阵中。如果你选择一个数值，则将其四舍五入到指定的有效数字位数；否则，提供一个精确表达式。", "solution": "该问题经验证具有科学依据、适定、客观且自洽。所有提供的定义和定理都是反问题和计算断层成像领域的标准内容。这些任务代表了一组连贯且可解的数学推导。\n\n按照问题陈述的要求，解答分为四个部分。\n\n(1) 推导 $\\mathcal{A} \\equiv \\mathcal{R}^{\\ast}\\,\\mathcal{W}\\,\\mathcal{R}$ 的谱作用。\n(2) 确定 $\\mathcal{A} = c\\,\\mathrm{Id}$ 中的常数 $c$。\n\n我们将通过推导算子恒等式来同时解决第 (1) 和第 (2) 部分。出发点是函数 $f(x)$ 的二维傅里叶逆变换：\n$$\nf(x) \\;=\\; \\frac{1}{(2\\pi)^{2}}\\int_{\\mathbb{R}^2} \\widehat{f}(\\xi)\\,\\exp\\!\\big(\\mathrm{i}\\,\\xi \\cdot x\\big)\\,\\mathrm{d}\\xi\n$$\n我们将傅里叶平面 $\\mathbb{R}^2$ 上的积分转换为极坐标。令 $\\xi = \\omega \\theta$，其中 $\\theta$ 是由角度 $\\phi \\in [0, 2\\pi)$ 给出的单位向量，且 $\\omega = |\\xi| \\in [0,\\infty)$。此变换的雅可比行列式为 $|\\omega|$，或者更准确地说，面积元为 $\\mathrm{d}\\xi = |\\omega| \\,\\mathrm{d}\\omega\\,\\mathrm{d}\\phi$。然而，拉东变换定义的角度在 $[0, \\pi)$ 内。一个关键的恒等式，有时称为极坐标到笛卡尔坐标积分公式或傅里叶变换的卡瓦列里原理，将 $\\mathbb{R}^2$ 上的积分与正弦图域 $(\\theta, \\omega)$ 上的积分联系起来：\n$$\n\\int_{\\mathbb{R}^2} h(\\xi)\\,\\mathrm{d}\\xi \\;=\\; \\int_{0}^{\\pi} \\int_{-\\infty}^{\\infty} h(\\omega\\theta)\\,|\\omega|\\,\\mathrm{d}\\omega\\,\\mathrm{d}\\theta\n$$\n将此恒等式应用于 $f(x)$ 的傅里叶逆变换表达式：\n$$\nf(x) \\;=\\; \\frac{1}{(2\\pi)^{2}} \\int_{0}^{\\pi} \\int_{-\\infty}^{\\infty} \\widehat{f}(\\omega\\theta) \\exp\\!\\big(\\mathrm{i}\\,(\\omega\\theta) \\cdot x\\big)\\,|\\omega|\\,\\mathrm{d}\\omega\\,\\mathrm{d}\\theta\n$$\n我们使用傅里叶切片定理，其形式为 $\\widehat{f}(\\omega\\theta) = (\\mathcal{F}_s \\mathcal{R} f)(\\theta,\\omega)$。将此代入 $f(x)$ 的方程中：\n$$\nf(x) \\;=\\; \\frac{1}{(2\\pi)^{2}} \\int_{0}^{\\pi} \\int_{-\\infty}^{\\infty} (\\mathcal{F}_s \\mathcal{R} f)(\\theta,\\omega) \\exp\\!\\big(\\mathrm{i}\\,\\omega(x \\cdot \\theta)\\big)\\,|\\omega|\\,\\mathrm{d}\\omega\\,\\mathrm{d}\\theta\n$$\n让我们重新排列积分内的项，以便有意义地分组：\n$$\nf(x) \\;=\\; \\frac{1}{(2\\pi)^{2}} \\int_{0}^{\\pi} \\left( \\int_{-\\infty}^{\\infty} |\\omega|\\,(\\mathcal{F}_s \\mathcal{R} f)(\\theta,\\omega) \\exp\\!\\big(\\mathrm{i}\\,\\omega(x \\cdot \\theta)\\big)\\,\\mathrm{d}\\omega \\right) \\mathrm{d}\\theta\n$$\n滤波器算子 $\\mathcal{W}$ 的定义由其在傅里叶域中的作用给出：$(\\mathcal{F}_s\\, \\mathcal{W} g)(\\theta,\\omega) = |\\omega|\\,(\\mathcal{F}_s g)(\\theta,\\omega)$。令 $g = \\mathcal{R}f$。那么 $|\\omega|\\,(\\mathcal{F}_s \\mathcal{R} f)(\\theta,\\omega)$ 这一项恰好是 $(\\mathcal{F}_s\\, \\mathcal{W} \\mathcal{R} f)(\\theta,\\omega)$。\n所以表达式变为：\n$$\nf(x) \\;=\\; \\frac{1}{(2\\pi)^{2}} \\int_{0}^{\\pi} \\left( \\int_{-\\infty}^{\\infty} (\\mathcal{F}_s\\, \\mathcal{W} \\mathcal{R} f)(\\theta,\\omega) \\exp\\!\\big(\\mathrm{i}\\,\\omega(x \\cdot \\theta)\\big)\\,\\mathrm{d}\\omega \\right) \\mathrm{d}\\theta\n$$\n内部积分是一维傅里叶逆变换（关于 $s$）的定义，乘以一个因子 $2\\pi$。具体来说，对于函数 $h(s)$，其傅里叶逆变换为 $h(s) = \\frac{1}{2\\pi} \\int \\widehat{h}(\\omega) e^{\\mathrm{i}\\omega s} \\mathrm{d}\\omega$。\n这里，被变换的函数是 $(\\mathcal{W} \\mathcal{R} f)(\\theta, s)$，并且它在 $s' = x \\cdot \\theta$ 处求值。\n因此，内部积分等于 $2\\pi (\\mathcal{W} \\mathcal{R} f)(\\theta, x \\cdot \\theta)$。\n将其代回：\n$$\nf(x) \\;=\\; \\frac{1}{(2\\pi)^{2}} \\int_{0}^{\\pi} 2\\pi\\, (\\mathcal{W} \\mathcal{R} f)(\\theta, x \\cdot \\theta)\\,\\mathrm{d}\\theta \\;=\\; \\frac{1}{2\\pi} \\int_{0}^{\\pi} (\\mathcal{W} \\mathcal{R} f)(\\theta, x \\cdot \\theta)\\,\\mathrm{d}\\theta\n$$\n剩下的积分是反投影算子 $\\mathcal{R}^{\\ast}$ 应用于滤波后的正弦图 $\\mathcal{W}\\mathcal{R}f$ 的定义：\n$$\n(\\mathcal{R}^{\\ast} g)(x) \\;=\\; \\int_{0}^{\\pi} g(\\theta, x \\cdot \\theta)\\,\\mathrm{d}\\theta\n$$\n因此，我们得到了著名的滤波反投影 (FBP) 公式：\n$$\nf(x) \\;=\\; \\frac{1}{2\\pi} (\\mathcal{R}^{\\ast} (\\mathcal{W} \\mathcal{R} f))(x) \\;=\\; \\frac{1}{2\\pi} (\\mathcal{A} f)(x)\n$$\n由此可见，对于任何合适的函数 $f$，我们有 $\\mathcal{A}f = 2\\pi f$。这意味着算子 $\\mathcal{A}$ 是单位算子的一个标量倍，$\\mathcal{A} = 2\\pi\\,\\mathrm{Id}$。\n这回答了第 (2) 部分：常数是 $c=2\\pi$。\n对于第 (1) 部分，我们对 $\\mathcal{A}f = 2\\pi f$ 进行傅里叶变换：\n$$\n\\widehat{\\mathcal{A}f}(\\xi) \\;=\\; \\widehat{2\\pi f}(\\xi) \\;=\\; 2\\pi \\widehat{f}(\\xi)\n$$\n将其与所需形式 $\\widehat{\\mathcal{A} f}(\\xi) = m(|\\xi|)\\,\\widehat{f}(\\xi)$ 进行比较，我们发现径向乘子是一个常数函数：\n$$\nm(|\\xi|) \\;=\\; 2\\pi\n$$\n\n(3) 推导误差传播算子 $E(\\beta)$ 及其谱半径 $\\rho(\\beta)$。\n\n给定的迭代格式是：\n$$\nx_{k+1} \\;=\\; x_k \\;+\\; \\beta\\,\\mathcal{R}^{\\ast}\\,\\mathcal{W}\\,\\big(y - \\mathcal{R} x_k\\big)\n$$\n给定数据是无噪声的，因此 $y = \\mathcal{R} x^{\\dagger}$，其中 $x^{\\dagger}$ 是真实解图像。\n代入 $y$ 和 $\\mathcal{A}$ 的定义：\n$$\nx_{k+1} \\;=\\; x_k \\;+\\; \\beta\\,\\mathcal{R}^{\\ast}\\,\\mathcal{W}\\,\\big(\\mathcal{R} x^{\\dagger} - \\mathcal{R} x_k\\big) \\;=\\; x_k \\;+\\; \\beta\\,\\mathcal{R}^{\\ast}\\,\\mathcal{W}\\,\\mathcal{R}\\,(x^{\\dagger} - x_k) \\;=\\; x_k \\;+\\; \\beta\\,\\mathcal{A}\\,(x^{\\dagger} - x_k)\n$$\n第 $k$ 次迭代的误差定义为 $e_k = x_k - x^{\\dagger}$。我们希望找到 $e_{k+1}$ 和 $e_k$ 之间的关系。\n$$\nx_{k+1} - x^{\\dagger} \\;=\\; x_k - x^{\\dagger} \\;+\\; \\beta\\,\\mathcal{A}\\,(x^{\\dagger} - x_k)\n$$\n$$\ne_{k+1} \\;=\\; e_k \\;-\\; \\beta\\,\\mathcal{A}\\,e_k \\;=\\; (\\mathrm{Id} - \\beta\\,\\mathcal{A})e_k\n$$\n因此，误差传播算子为 $E(\\beta) = \\mathrm{Id} - \\beta\\,\\mathcal{A}$。\n使用第 (2) 部分的结果，$\\mathcal{A} = c\\,\\mathrm{Id}$ 且 $c=2\\pi$，我们得到：\n$$\nE(\\beta) \\;=\\; \\mathrm{Id} - \\beta\\,(c\\,\\mathrm{Id}) \\;=\\; (1 - \\beta c)\\,\\mathrm{Id}\n$$\n单位算子的标量倍的谱仅由一个值组成，即该标量本身。$E(\\beta)$ 的特征值都是 $1 - \\beta c$。谱半径 $\\rho(E(\\beta))$ 是特征值绝对值的最大值。\n$$\n\\rho(\\beta) \\;=\\; |1 - \\beta c| \\;=\\; |1 - 2\\pi\\beta|\n$$\n\n(4) 确定最优增益 $\\beta^{\\star}$ 和最小谱半径 $\\rho_{\\min}$。\n\n我们想找到使 $\\rho(\\beta) = |1 - 2\\pi\\beta|$ 最小的 $\\beta  0$ 值。绝对值函数 $|z|$ 在 $z=0$ 时取得最小值 $0$。\n$\\rho(\\beta)$ 的最小值在其自变量为零时达到：\n$$\n1 - 2\\pi\\beta \\;=\\; 0\n$$\n解出 $\\beta$ 得到最优增益 $\\beta^{\\star}$：\n$$\n\\beta^{\\star} \\;=\\; \\frac{1}{2\\pi}\n$$\n该值为正，因此满足约束 $\\beta  0$。\n相应的最小谱半径 $\\rho_{\\min}$ 为：\n$$\n\\rho_{\\min} \\;=\\; \\rho(\\beta^{\\star}) \\;=\\; |1 - 2\\pi \\left(\\frac{1}{2\\pi}\\right)| \\;=\\; |1 - 1| \\;=\\; 0\n$$\n谱半径为 $0$ 意味着无论初始猜测 $x_0$ 是什么，迭代都会在单步内收敛到精确解。\n代表最优增益和最小谱半径的对是 $(\\beta^{\\star}, \\rho_{\\min}) = (\\frac{1}{2\\pi}, 0)$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{2\\pi}  0 \\end{pmatrix}}\n$$", "id": "3416090"}]}