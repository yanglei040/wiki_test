{"hands_on_practices": [{"introduction": "质量控制的基石在于将观测值与其模型预测值（即背景场）进行比较。由于背景误差和观测误差的存在，我们并不期望二者之差（即新息，$d = y - \\mathcal{H}(x_b)$）为零。本练习将介绍卡方检验（chi-squared test），这是一种基本的统计工具，用于判断新息的大小是否与我们假定的误差统计特性相符，构成了抵御观测资料中严重误差的第一道防线[@problem_id:3406849]。", "problem": "考虑一个变分资料同化系统中的单观测质量控制任务。设模型状态的维度为 $n=3$，观测算子在背景场状态 $x_b$ 处可微且线性化，其雅可比（行）向量为 $H \\in \\mathbb{R}^{1 \\times 3}$。背景误差 $x - x_b$ 被建模为一个零均值随机向量，其协方差矩阵为 $B \\in \\mathbb{R}^{3 \\times 3}$。观测误差是仪器误差和代表性误差之和，两者均被建模为零均值、相互独立的随机变量，且独立于背景误差。新息（观测空间中的观测减背景）为 $d = y - \\mathcal{H}(x_b)$，其中 $\\mathcal{H}$ 是非线性观测算子，$H$ 是其在 $x_b$ 处的雅可比矩阵。仅使用方差的线性化误差传播法则和独立性假设，推导标量新息方差 $S = \\operatorname{Var}(d)$，然后计算卡方大误差检验统计量 $z = d^2 / S$。\n\n给定：\n- 线性化观测算子雅可比矩阵为 $H = \\begin{bmatrix} 0.5  -1.2  0.3 \\end{bmatrix}$。\n- 背景误差协方差\n$$\nB = \\begin{bmatrix}\n1.0  0.2  -0.1 \\\\\n0.2  2.0  0.4 \\\\\n-0.1  0.4  1.5\n\\end{bmatrix}.\n$$\n- 仪器误差方差 $R = 0.49$。\n- 代表性误差方差 $R_{\\text{rep}} = 0.36$。\n- 已实现的新息 $d = 5.0$。\n- 一个预设的标量卡方阈值 $\\gamma = 6.635$，对应一个自由度。\n\n从给定的建模假设和线性化出发，首先推导标量新息方差 $S$，然后计算统计量 $z = d^2 / S$。在你的推理中，通过将 $z$ 与 $\\gamma$ 进行比较，说明残差是否与假设的误差统计量相符。仅报告 $z$ 的值作为最终答案。将你的数值答案四舍五入到四位有效数字。不需要单位。", "solution": "该问题要求在资料同化背景下计算单个观测的卡方大误差检验统计量。该统计量定义为 $z = d^2 / S$，其中 $d$ 是新息，$S$ 是新息方差。\n\n首先，我们必须推导新息方差 $S$ 的表达式。新息是观测值 $y$ 与模式对观测值的预报 $\\mathcal{H}(x_b)$ 之间的差值，其中 $\\mathcal{H}$ 是（可能为非线性的）观测算子，$x_b$ 是背景场状态。\n$$d = y - \\mathcal{H}(x_b)$$\n观测值 $y$ 通过观测算子和观测误差 $\\epsilon_o$ 与真实状态 $x_t$ 相关联：\n$$y = \\mathcal{H}(x_t) + \\epsilon_o$$\n背景场状态 $x_b$ 是真实状态的估计值，与之相差一个背景误差 $\\epsilon_b = x_b - x_t$。\n\n使用一阶泰勒展开，将算子 $\\mathcal{H}$ 在背景场状态 $x_b$ 附近进行线性化：\n$$\\mathcal{H}(x_t) \\approx \\mathcal{H}(x_b) + H(x_t - x_b)$$\n其中 $H$ 是 $\\mathcal{H}$ 在 $x_b$ 处求得的雅可比矩阵。将此近似代入 $d$ 的表达式中：\n$$d \\approx (\\mathcal{H}(x_b) + H(x_t - x_b) + \\epsilon_o) - \\mathcal{H}(x_b) = H(x_t - x_b) + \\epsilon_o = -H\\epsilon_b + \\epsilon_o$$\n新息方差 $S$ 是新息平方的期望值，$S = \\operatorname{Var}(d) = E[d^2]$，因为 $\\epsilon_b$ 和 $\\epsilon_o$ 都被陈述为零均值，这意味着 $E[d]=0$。\n$$S = E[(-H\\epsilon_b + \\epsilon_o)(-H\\epsilon_b + \\epsilon_o)^T]$$\n利用背景误差和观测误差的独立性（交叉项的期望为零），我们得到：\n$$S = H E[\\epsilon_b\\epsilon_b^T] H^T + E[\\epsilon_o\\epsilon_o^T]$$\n根据定义，背景误差协方差矩阵为 $B = E[\\epsilon_b\\epsilon_b^T]$。总观测误差 $\\epsilon_o$ 是仪器误差 $\\epsilon_{inst}$ 和代表性误差 $\\epsilon_{rep}$ 之和。据陈述，这些误差是零均值且相互独立的。因此，总观测误差方差 $R_o$ 是各部分方差之和：$R_o = \\operatorname{Var}(\\epsilon_{inst}) + \\operatorname{Var}(\\epsilon_{rep}) = R + R_{\\text{rep}}$。\n新息方variance的最终公式是：\n$$S = HBH^T + R + R_{\\text{rep}}$$\n现在，我们将给定的值代入这个公式。\n给定：\n$H = \\begin{bmatrix} 0.5  -1.2  0.3 \\end{bmatrix}$\n$B = \\begin{bmatrix} 1.0  0.2  -0.1 \\\\ 0.2  2.0  0.4 \\\\ -0.1  0.4  1.5 \\end{bmatrix}$\n$R = 0.49$\n$R_{\\text{rep}} = 0.36$\n$d = 5.0$\n\n首先，计算项 $HBH^T$。\n$$H B = \\begin{bmatrix} 0.5  -1.2  0.3 \\end{bmatrix} \\begin{bmatrix} 1.0  0.2  -0.1 \\\\ 0.2  2.0  0.4 \\\\ -0.1  0.4  1.5 \\end{bmatrix}$$\n$$H B = \\begin{bmatrix} 0.5 - 0.24 - 0.03  0.1 - 2.4 + 0.12  -0.05 - 0.48 + 0.45 \\end{bmatrix} = \\begin{bmatrix} 0.23  -2.18  -0.08 \\end{bmatrix}$$\n接下来，我们计算 $HBH^T = (HB)H^T$：\n$$HBH^T = \\begin{bmatrix} 0.23  -2.18  -0.08 \\end{bmatrix} \\begin{bmatrix} 0.5 \\\\ -1.2 \\\\ 0.3 \\end{bmatrix}$$\n$$HBH^T = (0.23)(0.5) + (-2.18)(-1.2) + (-0.08)(0.3) = 0.115 + 2.616 - 0.024 = 2.707$$\n现在，计算总观测误差方差 $R_o$：\n$$R_o = R + R_{\\text{rep}} = 0.49 + 0.36 = 0.85$$\n总新息方差 $S$ 为：\n$$S = HBH^T + R_o = 2.707 + 0.85 = 3.557$$\n最后，我们计算卡方统计量 $z$：\n$$z = \\frac{d^2}{S} = \\frac{(5.0)^2}{3.557} = \\frac{25}{3.557} \\approx 7.02839...$$\n四舍五入到四位有效数字，我们得到 $z = 7.028$。\n\n计算出的统计量 $z \\approx 7.028$ 大于预设的阈值 $\\gamma = 6.635$。因此，在与此阈值对应的显著性水平下，观测值与误差统计量一致的原假设被拒绝。该观测值将被标记为大误差。要求的最终答案仅为 $z$ 的值。", "answer": "$$\\boxed{7.028}$$", "id": "3406849"}, {"introduction": "简单地拒绝一个观测值（如卡方检验所暗示的）可能是一种过于激进的措施，特别是当该观测值仍包含部分有效信息时。本练习将探讨一种更为精妙的方法——稳健统计（robust statistics）。我们将通过实践Huber权重方案，该方法会自动降低具有较大残差（潜在异常值）的观测数据的影响力，而不是完全抛弃它们，从而得到一个更稳定和稳健的分析结果[@problem_id:3406858]。", "problem": "在一个一维变分数据同化步骤中，考虑有 $n=6$ 个独立的传感器通过线性观测算子 $\\mathcal{H}_i(x)=h_i x$ 观测同一标量状态 $x$。在迭代 $t$ 时，当前估计值为 $x^{(t)}=1.0$，标量残差 $r_i=y_i-\\mathcal{H}_i(x^{(t)})$ 可用于质量控制。为了使用 Huber 加权方案进行稳健的粗差检查，请使用以下基本定义：\n- 残差定义为 $r_i=y_i-\\mathcal{H}_i(x^{(t)})$。\n- 残差的稳健尺度 $\\sigma$ 已给出。\n- Huber 阈值为 $\\delta=k\\sigma$，其中 $k$ 为选定参数。\n- Huber 权重 $w_i$ 遵循标准的 M-估计规则 $w_i=\\psi(r_i)/r_i$，其中 Huber 得分函数为：当 $|r|\\le \\delta$ 时 $\\psi(r)=r$，当 $|r|\\delta$ 时 $\\psi(r)=\\delta\\operatorname{sign}(r)$。由此得出，当 $|r_i|\\le \\delta$ 时 $w_i=1$，当 $|r_i|\\delta$ 时 $w_i=\\delta/|r_i|$。\n- 加权最小二乘 (WLS) 更新求解 $x^{(t+1)}=\\arg\\min_x \\sum_{i=1}^{n} w_i \\left(y_i-\\mathcal{H}_i(x)\\right)^2$。\n\n假设传感器灵敏度为 $(h_1,h_2,h_3,h_4,h_5,h_6)=(1.0,0.8,1.2,0.6,1.5,0.7)$，迭代 $t$ 时的残差为 $(r_1,r_2,r_3,r_4,r_5,r_6)=(0.2,-0.1,0.5,-0.4,4.0,-3.5)$，稳健尺度为 $\\sigma=0.3$。选择 $k=2$，因此 $\\delta=k\\sigma$。使用给定的 $r_i$、$\\sigma$、$k$ 和 $h_i$ 来：\n\n1. 计算 Huber 权重 $w_i$。\n2. 从 $r_i=y_i-h_i x^{(t)}$ 中恢复观测值 $y_i$。\n3. 执行一次 WLS 更新以获得 $x^{(t+1)}$。\n\n将最终的 $x^{(t+1)}$ 报告为一个无量纲数，四舍五入到四位有效数字。", "solution": "此问题要求我们执行一次使用Huber加权方案的加权最小二乘（WLS）更新。解题步骤如下：\n\n**1. 计算Huber权重 $w_i$**\n\n首先，根据给定的稳健尺度 $\\sigma=0.3$ 和参数 $k=2$ 计算Huber阈值 $\\delta$。\n$$ \\delta = k \\sigma = 2 \\times 0.3 = 0.6 $$\n接下来，我们将每个残差的绝对值 $|r_i|$ 与此阈值 $\\delta=0.6$ 进行比较，以确定相应的权重 $w_i$。该规则是：如果 $|r_i| \\le \\delta$，则 $w_i=1$；如果 $|r_i| > \\delta$，则 $w_i = \\delta / |r_i|$。\n\n- 对于 $i=1$：$|r_1| = |0.2| = 0.2 \\le 0.6$，所以 $w_1 = 1$。\n- 对于 $i=2$：$|r_2| = |-0.1| = 0.1 \\le 0.6$，所以 $w_2 = 1$。\n- 对于 $i=3$：$|r_3| = |0.5| = 0.5 \\le 0.6$，所以 $w_3 = 1$。\n- 对于 $i=4$：$|r_4| = |-0.4| = 0.4 \\le 0.6$，所以 $w_4 = 1$。\n- 对于 $i=5$：$|r_5| = |4.0| = 4.0 > 0.6$，所以 $w_5 = \\frac{0.6}{4.0} = 0.15$。\n- 对于 $i=6$：$|r_6| = |-3.5| = 3.5 > 0.6$，所以 $w_6 = \\frac{0.6}{3.5} = \\frac{6}{35} \\approx 0.1714$。\n\n**2. 恢复观测值 $y_i$**\n\n观测值 $y_i$ 可以从残差的定义 $r_i = y_i - \\mathcal{H}_i(x^{(t)})$ 中恢复。给定 $\\mathcal{H}_i(x) = h_i x$ 和 $x^{(t)}=1.0$，我们有 $y_i = r_i + h_i x^{(t)}$。\n- $y_1 = 0.2 + 1.0 \\times 1.0 = 1.2$\n- $y_2 = -0.1 + 0.8 \\times 1.0 = 0.7$\n- $y_3 = 0.5 + 1.2 \\times 1.0 = 1.7$\n- $y_4 = -0.4 + 0.6 \\times 1.0 = 0.2$\n- $y_5 = 4.0 + 1.5 \\times 1.0 = 5.5$\n- $y_6 = -3.5 + 0.7 \\times 1.0 = -2.8$\n\n**3. 执行WLS更新以获得 $x^{(t+1)}$**\n\n更新后的状态估计值 $x^{(t+1)}$ 是使加权最小二乘成本函数 $J(x) = \\sum_{i=1}^{n} w_i (y_i - h_i x)^2$ 最小化的 $x$ 值。其解为：\n$$ x^{(t+1)} = \\frac{\\sum_{i=1}^{n} w_i h_i y_i}{\\sum_{i=1}^{n} w_i h_i^2} $$\n我们分别计算分子和分母。\n\n分母 $\\sum_{i=1}^{6} w_i h_i^2$：\n$$ 1 \\cdot (1.0)^2 + 1 \\cdot (0.8)^2 + 1 \\cdot (1.2)^2 + 1 \\cdot (0.6)^2 + 0.15 \\cdot (1.5)^2 + \\frac{6}{35} \\cdot (0.7)^2 \\\\ = 1.0 + 0.64 + 1.44 + 0.36 + 0.3375 + 0.084 = 3.8615 $$\n\n分子 $\\sum_{i=1}^{6} w_i h_i y_i$：\n$$ 1 \\cdot 1.0 \\cdot 1.2 + 1 \\cdot 0.8 \\cdot 0.7 + 1 \\cdot 1.2 \\cdot 1.7 + 1 \\cdot 0.6 \\cdot 0.2 + 0.15 \\cdot 1.5 \\cdot 5.5 + \\frac{6}{35} \\cdot 0.7 \\cdot (-2.8) \\\\ = 1.2 + 0.56 + 2.04 + 0.12 + 1.2375 - 0.336 = 4.8215 $$\n\n最后，我们计算 $x^{(t+1)}$：\n$$ x^{(t+1)} = \\frac{4.8215}{3.8615} \\approx 1.248608... $$\n四舍五入到四位有效数字，得到 $x^{(t+1)} \\approx 1.249$。", "answer": "$$\n\\boxed{1.249}\n$$", "id": "3406858"}, {"introduction": "前面的练习大多基于线性或线性化的模型。然而，现实世界中的观测算子通常是高度非线性的，线性近似本身就可能成为一个显著的误差来源，甚至可能导致有效的观测被错误地标记为异常值。本练习将深入探讨一种考虑了曲率的质量控制检验方法，该方法将非线性引入的潜在误差也纳入考量，从而能够更准确地区分真正的严重误差与由模型曲率引起的较大新息[@problem_id:3406926]。", "problem": "在反演问题和数据同化的背景下，考虑一个将状态向量映射到标量观测值的观测算子。设状态为 $\\mathbf{x} \\in \\mathbb{R}^2$，并定义三个标量观测函数 $h_1, h_2, h_3$，使得完整的观测算子为 $H(\\mathbf{x}) = \\big(h_1(\\mathbf{x}), h_2(\\mathbf{x}), h_3(\\mathbf{x})\\big) \\in \\mathbb{R}^3$，其中\n- $h_1(\\mathbf{x}) = \\exp(x_1) + \\sin(x_2)$,\n- $h_2(\\mathbf{x}) = \\log\\!\\big(1 + x_1^2\\big) + x_1 x_2$,\n- $h_3(\\mathbf{x}) = \\sqrt{1 + x_2^2} + \\tanh(x_1)$.\n\n所有三角函数都必须以弧度为单位计算角度。\n\n对于给定的背景（先验）状态 $\\hat{\\mathbf{x}} \\in \\mathbb{R}^2$ 和增量 $\\delta \\mathbf{x} \\in \\mathbb{R}^2$，将每个标量观测 $h_i$ 的线性化预测器定义为 $h_i(\\hat{\\mathbf{x}}) + \\nabla h_i(\\hat{\\mathbf{x}})^\\top \\delta \\mathbf{x}$。设观测 $i$ 的残差为 $r_i = y_i - h_i(\\hat{\\mathbf{x}})$，其中 $y_i$ 是观测值。观测残差与线性化预测之间的不匹配量则为 $e_i = r_i - \\nabla h_i(\\hat{\\mathbf{x}})^\\top \\delta \\mathbf{x}$。\n\n观测质量控制（QC）旨在标记由模型非线性（曲率）和重大误差引起的离群值。我们考虑一种基于二阶泰勒余项界的、能够感知曲率的重大误差检查。对于每个观测 $i$，令 $C_i$ 表示由下式给出的曲率界：\n$$\nC_i = \\frac{1}{2} \\left\\| \\nabla^2 h_i(\\hat{\\mathbf{x}}) \\right\\|_2 \\, \\left\\| \\delta \\mathbf{x} \\right\\|_2^2,\n$$\n其中 $\\nabla^2 h_i(\\hat{\\mathbf{x}})$ 是 $h_i$在 $\\hat{\\mathbf{x}}$ 处的 Hessian 矩阵，$\\|\\cdot\\|_2$ 表示矩阵的谱范数和向量的欧几里得范数。设 $\\sigma_i > 0$ 为观测 $i$ 的观测噪声标准差，$\\tau > 0$ 为一个固定的判定因子。\n\n通过以下规则定义观测 $i$ 的感知曲率的重大误差标志：\n- 当且仅当 $\\left| e_i \\right|  \\tau \\left( \\sigma_i + C_i \\right)$ 时，将观测 $i$ 标记为离群值。\n\n您的任务是在一个完整的、可运行的程序中实现上述 QC 测试。您必须：\n- 根据上面给出的 $h_i$ 的定义，精确计算 $i \\in \\{1,2,3\\}$ 的 $\\nabla h_i(\\hat{\\mathbf{x}})$ 和 $\\nabla^2 h_i(\\hat{\\mathbf{x}})$。\n- 对 $\\left\\| \\delta \\mathbf{x} \\right\\|_2$ 使用欧几里得范数，对 $\\left\\| \\nabla^2 h_i(\\hat{\\mathbf{x}}) \\right\\|_2$ 使用谱范数（最大奇异值）。\n- 根据预设的不匹配乘子 $a_i$，通过以下公式间接构造观测值 $y_i$：\n$$\ne_i = a_i \\, \\tau \\left( \\sigma_i + C_i \\right), \\quad\ny_i = h_i(\\hat{\\mathbf{x}}) + \\nabla h_i(\\hat{\\mathbf{x}})^\\top \\delta \\mathbf{x} + e_i,\n$$\n从而使测试结果由 $a_i$ 相对于 $1$ 的大小控制。\n\n使用固定的判定因子 $\\tau = 3$。\n\n测试套件：\n提供一个包含五个案例的测试套件。每个案例包含 $(\\hat{\\mathbf{x}}, \\delta \\mathbf{x}, \\boldsymbol{\\sigma}, \\mathbf{a})$，其中 $\\hat{\\mathbf{x}} \\in \\mathbb{R}^2$, $\\delta \\mathbf{x} \\in \\mathbb{R}^2$, $\\boldsymbol{\\sigma} \\in \\mathbb{R}^3$, $\\mathbf{a} \\in \\mathbb{R}^3$。对于每个案例，计算三个观测值的离群值标志并以布尔值的形式返回。测试套件必须是：\n- 案例1（正常路径，小增量，无标志）：$\\hat{\\mathbf{x}} = [0.1, 0.2]$, $\\delta \\mathbf{x} = [0.01, -0.02]$, $\\boldsymbol{\\sigma} = [0.05, 0.05, 0.05]$, $\\mathbf{a} = [0.5, -0.2, 0.0]$。\n- 案例2（曲率驱动的离群值，混合结果）：$\\hat{\\mathbf{x}} = [2.0, 1.2]$, $\\delta \\mathbf{x} = [0.5, -0.4]$, $\\boldsymbol{\\sigma} = [0.02, 0.02, 0.02]$, $\\mathbf{a} = [1.1, 0.8, 2.0]$。\n- 案例3（阈值相等的边界条件，无标志）：$\\hat{\\mathbf{x}} = [-1.0, 2.0]$, $\\delta \\mathbf{x} = [0.3, 0.3]$, $\\boldsymbol{\\sigma} = [0.03, 0.03, 0.03]$, $\\mathbf{a} = [1.0, 1.0, 1.0]$。\n- 案例4（零增量，纯重大误差测试）：$\\hat{\\mathbf{x}} = [0.0, -0.5]$, $\\delta \\mathbf{x} = [0.0, 0.0]$, $\\boldsymbol{\\sigma} = [0.1, 0.1, 0.1]$, $\\mathbf{a} = [1.2, 0.3, -0.9]$。\n- 案例5（高曲率附近的弧度角，混合标志）：$\\hat{\\mathbf{x}} = [0.0, \\pi/2]$, $\\delta \\mathbf{x} = [-0.2, 0.1]$, $\\boldsymbol{\\sigma} = [0.02, 0.02, 0.02]$, $\\mathbf{a} = [0.95, 1.05, 1.5]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试案例，并且本身是按观测 $\\big(h_1, h_2, h_3\\big)$ 顺序排列的包含三个布尔值的列表。例如，一个有效的输出格式是 $[[\\text{False},\\text{True},\\text{False}], [\\text{True},\\text{True},\\text{False}], \\dots]$。", "solution": "任务是为一组三个标量观测 $h_1, h_2, h_3$ 实现一个感知曲率的重大误差检查，这些观测是二维状态向量 $\\mathbf{x} = [x_1, x_2]^\\top$ 的函数。该检查旨在当观测值 $y_i$ 与线性化模型预测的偏差过大时，将其标记为离群值，同时考虑了观测噪声和模型非线性。\n\n质量控制（QC）测试的核心是以下不等式：\n$$\n\\left| e_i \\right| > \\tau \\left( \\sigma_i + C_i \\right)\n$$\n其中 $i \\in \\{1, 2, 3\\}$ 是观测索引。我们来定义其中涉及的各项。\n- $e_i$ 是观测残差与其线性化预测之间的不匹配量。它被定义为 $e_i = (y_i - h_i(\\hat{\\mathbf{x}})) - \\nabla h_i(\\hat{\\mathbf{x}})^\\top \\delta \\mathbf{x}$，其中 $\\hat{\\mathbf{x}}$ 是背景状态，$\\delta \\mathbf{x}$ 是分析增量。\n- $\\tau = 3$ 是一个固定的正判定因子。\n- $\\sigma_i$ 是第 $i$ 个观测的观测噪声标准差。\n- $C_i$ 是曲率界，它估计了使用观测算子 $h_i$ 的线性近似可能产生的最大误差。其定义为：\n$$\nC_i = \\frac{1}{2} \\left\\| \\nabla^2 h_i(\\hat{\\mathbf{x}}) \\right\\|_2 \\, \\left\\| \\delta \\mathbf{x} \\right\\|_2^2\n$$\n在这里，$\\nabla^2 h_i(\\hat{\\mathbf{x}})$ 是 $h_i$ 在 $\\hat{\\mathbf{x}}$ 处求值的 Hessian 矩阵，$\\|\\cdot\\|_2$ 表示矩阵的谱范数和向量的欧几里得范数。\n\n为了执行此检查，我们必须首先计算每个观测函数的 Hessian 矩阵。状态向量为 $\\mathbf{x} = [x_1, x_2]^\\top$。\n\n1.  对于 $h_1(\\mathbf{x}) = \\exp(x_1) + \\sin(x_2)$，Hessian 矩阵为：\n    $$\n    \\nabla^2 h_1(\\mathbf{x}) = \\begin{pmatrix} \\exp(x_1)  0 \\\\ 0  -\\sin(x_2) \\end{pmatrix}\n    $$\n\n2.  对于 $h_2(\\mathbf{x}) = \\log(1 + x_1^2) + x_1 x_2$，Hessian 矩阵为：\n    $$\n    \\nabla^2 h_2(\\mathbf{x}) = \\begin{pmatrix} \\frac{2(1-x_1^2)}{(1+x_1^2)^2}  1 \\\\ 1  0 \\end{pmatrix}\n    $$\n\n3.  对于 $h_3(\\mathbf{x}) = \\sqrt{1 + x_2^2} + \\tanh(x_1)$，Hessian 矩阵为（其中 $\\operatorname{sech}$ 是双曲正割函数）：\n    $$\n    \\nabla^2 h_3(\\mathbf{x}) = \\begin{pmatrix} -2\\tanh(x_1)\\operatorname{sech}^2(x_1)  0 \\\\ 0  (1+x_2^2)^{-3/2} \\end{pmatrix}\n    $$\n\n问题描述为不匹配项 $e_i$ 提供了一种特定的构造方法以方便测试：\n$$\ne_i = a_i \\, \\tau \\left( \\sigma_i + C_i \\right)\n$$\n其中 $a_i$ 是一个预设的不匹配乘子。将此定义代入 QC 不等式可得：\n$$\n\\left| a_i \\, \\tau \\left( \\sigma_i + C_i \\right) \\right| > \\tau \\left( \\sigma_i + C_i \\right)\n$$\n由于 $\\tau > 0$，$\\sigma_i > 0$ 且 $C_i \\ge 0$，项 $\\tau(\\sigma_i + C_i)$ 是严格为正的。因此，我们可以简化不等式为 $|a_i| > 1$。这揭示了 QC 测试的结果完全取决于乘子 $a_i$ 的绝对值是否严格大于 $1$。\n\n一个严谨的实现应该遵循计算的因果链。程序将首先计算 Hessian 矩阵、它们的谱范数以及曲率界 $C_i$。然后，它将使用这些值来计算 $e_i$ 的值和阈值 $\\tau(\\sigma_i+C_i)$，最后执行比较。\n\n每个测试案例的算法如下：\n对于每个观测 $i \\in \\{1, 2, 3\\}$：\n1.  在给定的背景状态 $\\hat{\\mathbf{x}}$ 处计算 Hessian 矩阵 $\\nabla^2 h_i(\\hat{\\mathbf{x}})$。\n2.  计算其谱范数 $\\|\\nabla^2 h_i(\\hat{\\mathbf{x}})\\|_2$。\n3.  计算增量的欧几里得范数的平方 $\\|\\delta \\mathbf{x}\\|_2^2$。\n4.  计算曲率界 $C_i = \\frac{1}{2} \\|\\nabla^2 h_i(\\hat{\\mathbf{x}})\\|_2 \\|\\delta \\mathbf{x}\\|_2^2$。\n5.  使用给定的乘子 $a_i$ 和标准差 $\\sigma_i$，计算不匹配量 $e_i = a_i \\tau (\\sigma_i + C_i)$。\n6.  计算标记阈值 $T_i = \\tau (\\sigma_i + C_i)$。\n7.  如果 $|e_i| > T_i$，标志设置为 `True`，否则设置为 `False`。\n对所有五个提供的测试案例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a curvature-aware gross error check for a set of nonlinear\n    observation operators.\n    \"\"\"\n\n    # Helper function for hyperbolic secant, as it's not a direct numpy function.\n    def sech(x):\n        return 1.0 / np.cosh(x)\n\n    # --- Hessian Matrix Definitions ---\n    # These functions compute the Hessian matrix for each observation operator h_i.\n\n    def hessian_h1(x: np.ndarray) - np.ndarray:\n        \"\"\"Computes the Hessian of h_1(x) = exp(x_1) + sin(x_2).\"\"\"\n        x1, x2 = x\n        return np.array([\n            [np.exp(x1), 0.0],\n            [0.0, -np.sin(x2)]\n        ])\n\n    def hessian_h2(x: np.ndarray) - np.ndarray:\n        \"\"\"Computes the Hessian of h_2(x) = log(1 + x_1^2) + x_1 * x_2.\"\"\"\n        x1, x2 = x\n        term_11 = (2.0 * (1.0 - x1**2)) / (1.0 + x1**2)**2\n        return np.array([\n            [term_11, 1.0],\n            [1.0, 0.0]\n        ])\n\n    def hessian_h3(x: np.ndarray) - np.ndarray:\n        \"\"\"Computes the Hessian of h_3(x) = sqrt(1 + x_2^2) + tanh(x_1).\"\"\"\n        x1, x2 = x\n        term_11 = -2.0 * np.tanh(x1) * sech(x1)**2\n        term_22 = (1.0 + x2**2)**(-1.5)\n        return np.array([\n            [term_11, 0.0],\n            [0.0, term_22]\n        ])\n\n    # Fixed decision factor\n    tau = 3.0\n\n    # List of Hessian functions for easy iteration\n    hessian_functions = [hessian_h1, hessian_h2, hessian_h3]\n    \n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1 (happy path, small increment, no flags)\n        ([0.1, 0.2], [0.01, -0.02], [0.05, 0.05, 0.05], [0.5, -0.2, 0.0]),\n        # Case 2 (curvature-driven outliers with mixed outcomes)\n        ([2.0, 1.2], [0.5, -0.4], [0.02, 0.02, 0.02], [1.1, 0.8, 2.0]),\n        # Case 3 (boundary condition at threshold equality, no flags)\n        ([-1.0, 2.0], [0.3, 0.3], [0.03, 0.03, 0.03], [1.0, 1.0, 1.0]),\n        # Case 4 (zero increment, pure gross error test)\n        ([0.0, -0.5], [0.0, 0.0], [0.1, 0.1, 0.1], [1.2, 0.3, -0.9]),\n        # Case 5 (angles in radians near high curvature, mixed flags)\n        ([0.0, np.pi/2], [-0.2, 0.1], [0.02, 0.02, 0.02], [0.95, 1.05, 1.5]),\n    ]\n    \n    all_results = []\n    for case in test_cases:\n        x_hat_list, dx_list, sigma_list, a_list = case\n        x_hat = np.array(x_hat_list)\n        dx = np.array(dx_list)\n        sigma = np.array(sigma_list)\n        a = np.array(a_list)\n        \n        case_flags = []\n        \n        # Pre-compute the squared norm of the increment vector\n        norm_dx_sq = np.linalg.norm(dx)**2\n        \n        for i in range(3):\n            # 1. Compute the Hessian matrix and its spectral norm\n            H_i = hessian_functions[i](x_hat)\n            # The spectral norm is the largest singular value (ord=2)\n            norm_H_i = np.linalg.norm(H_i, ord=2)\n            \n            # 2. Compute the curvature bound C_i\n            C_i = 0.5 * norm_H_i * norm_dx_sq\n            \n            # 3. Compute the mismatch e_i from its definition in the problem\n            e_i = a[i] * tau * (sigma[i] + C_i)\n            \n            # 4. Compute the flagging threshold\n            threshold = tau * (sigma[i] + C_i)\n            \n            # 5. Apply the QC test: |e_i| > threshold\n            # Note: This is logically equivalent to |a[i]| > 1\n            is_outlier = np.abs(e_i) > threshold\n            case_flags.append(bool(is_outlier))\n            \n        all_results.append(case_flags)\n\n    # Format the final output string as specified\n    # The replacement of ' ' with '' ensures no spaces in the final list format\n    # and 'True'/'False' are capitalized as is standard for Python booleans to string.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n```", "id": "3406926"}]}