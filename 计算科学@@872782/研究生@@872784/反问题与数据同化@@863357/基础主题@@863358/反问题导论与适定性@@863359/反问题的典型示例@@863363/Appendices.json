{"hands_on_practices": [{"introduction": "许多逆问题本质上是“不适定的”，这意味着它们的解可能不唯一或对测量噪声极其敏感。第一个实践练习提供了一个来自断层成像领域的具体例子，其中测量几何本身就阻碍了我们唯一地确定成像对象。我们将使用基本的线性代数来找出这个成像系统的“盲点”，即其前向算子的零空间，从而直观地理解不适定性的来源 ([@problem_id:3370624])。", "problem": "考虑一个二维直线射线走时层析成像问题，该问题建立在一个均匀的 $2 \\times 2$ 方形单元笛卡尔网格上，其未知慢度为 $m = (s_{1}, s_{2}, s_{3}, s_{4})^{\\top} \\in \\mathbb{R}^{4}$。射线的连续走时由路径积分 $t = \\int_{\\gamma} s(\\mathbf{x}) \\, \\mathrm{d}\\ell$ 定义，其中 $\\gamma$ 表示直线射线路径，$s(\\mathbf{x})$ 是慢度场。在标准的分片常数离散化中，每个测量的走时 $t_{i}$ 被近似为 $m$ 的一个线性泛函，\n$$\nt_{i} \\approx \\sum_{j=1}^{4} L_{ij} s_{j},\n$$\n其中 $L_{ij}$ 是射线 $i$ 在单元 $j$ 内的路径长度。将 $t_{i}$ 堆叠成数据向量 $t \\in \\mathbb{R}^{4}$，将 $L_{ij}$ 堆叠成系统矩阵 $G \\in \\mathbb{R}^{4 \\times 4}$，因此有 $t \\approx G m$。\n\n假设几何结构和采集方式如下。共有 $4$ 条射线：\n(i) 一条穿过顶行单元的水平射线，\n(ii) 一条穿过底行单元的水平射线，\n(iii) 一条穿过左列单元的垂直射线，以及\n(iv) 一条穿过右列单元的垂直射线。\n假设每条射线穿过每个相交单元的路径长度为单位长度，即 $L_{ij} \\in \\{0,1\\}$，其中 $L_{ij} = 1$ 当且仅当射线 $i$ 穿过单元 $j$。因此，$G$ 具有二进制元素并编码了这种几何结构。假设测量误差为独立同分布的高斯误差，其协方差为 $\\sigma^{2} I$，并采用加权最小二乘 (WLS) 目标函数\n$$\n\\Phi(m) = \\frac{1}{2} \\| t - G m \\|_{2}^{2},\n$$\n因此正规方程为 $G^{\\top} G \\, m = G^{\\top} t$。\n\n任务：\n(1) 根据所述的采集几何结构，组装出显式矩阵 $G$，并构建正规矩阵 $N = G^{\\top} G$。\n(2) 仅使用 $N$ 的结构，找出 $N$ 的零空间中的一个非平凡向量，并从采集引起的模糊性的角度对其进行解释。\n(3) 按非递增顺序计算 $N$ 的特征值。\n\n请将您的最终答案以单行矩阵的形式，按顺序给出 $N$ 的特征值。无需四舍五入；请提供精确整数。最终答案中不要包含单位。", "solution": "该问题陈述经核实具有科学依据，为适定分析问题，客观且自洽。它展示了地球物理层析成像领域中一个典型的线性反演问题。所有必需信息均已提供，且任务明确。因此，我们可以开始求解。\n\n该问题要求完成与一个 $2 \\times 2$ 走时层析成像问题相关的三项任务。我们将按顺序逐一解决。\n\n首先，我们建立一个清晰的索引约定。四个单元按行主序索引：\n- 单元 1：左上\n- 单元 2：右上\n- 单元 3：左下\n- 单元 4：右下\n未知慢度向量为 $m = (s_1, s_2, s_3, s_4)^{\\top}$。\n\n四条射线的索引如下：\n- 射线 1：水平，顶行\n- 射线 2：水平，底行\n- 射线 3：垂直，左列\n- 射线 4：垂直，右列\n测量的走时向量为 $t = (t_1, t_2, t_3, t_4)^{\\top}$。\n\n离散正演模型由线性系统 $t = G m$ 给出，其中 $G_{ij}$ 是射线 $i$ 在单元 $j$ 内的路径长度。问题陈述中说明，如果射线 $i$ 穿过单元 $j$，则 $G_{ij}=1$，否则 $G_{ij}=0$。\n\n(1) 组装显式矩阵 $G$ 并构建正规矩阵 $N = G^{\\top} G$。\n\n我们逐行构建矩阵 $G$，其中每一行对应一次射线测量：\n- 射线 1 穿过单元 1 和 2。因此，$t_1 = 1 \\cdot s_1 + 1 \\cdot s_2 + 0 \\cdot s_3 + 0 \\cdot s_4$。$G$ 的第一行是 $(1, 1, 0, 0)$。\n- 射线 2 穿过单元 3 和 4。因此，$t_2 = 0 \\cdot s_1 + 0 \\cdot s_2 + 1 \\cdot s_3 + 1 \\cdot s_4$。$G$ 的第二行是 $(0, 0, 1, 1)$。\n- 射线 3 穿过单元 1 和 3。因此，$t_3 = 1 \\cdot s_1 + 0 \\cdot s_2 + 1 \\cdot s_3 + 0 \\cdot s_4$。$G$ 的第三行是 $(1, 0, 1, 0)$。\n- 射线 4 穿过单元 2 和 4。因此，$t_4 = 0 \\cdot s_1 + 1 \\cdot s_2 + 0 \\cdot s_3 + 1 \\cdot s_4$。$G$ 的第四行是 $(0, 1, 0, 1)$。\n\n结合这些行，系统矩阵 $G$ 为：\n$$\nG = \\begin{pmatrix}\n1  1  0  0 \\\\\n0  0  1  1 \\\\\n1  0  1  0 \\\\\n0  1  0  1\n\\end{pmatrix}\n$$\n正规矩阵 $N$ 定义为 $N = G^{\\top} G$。首先，我们写出 $G$ 的转置：\n$$\nG^{\\top} = \\begin{pmatrix}\n1  0  1  0 \\\\\n1  0  0  1 \\\\\n0  1  1  0 \\\\\n0  1  0  1\n\\end{pmatrix}\n$$\n现在我们计算乘积：\n$$\nN = G^{\\top} G = \\begin{pmatrix}\n1  0  1  0 \\\\\n1  0  0  1 \\\\\n0  1  1  0 \\\\\n0  1  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\n1  1  0  0 \\\\\n0  0  1  1 \\\\\n1  0  1  0 \\\\\n0  1  0  1\n\\end{pmatrix}\n= \\begin{pmatrix}\n1 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 0   1 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0 + 0 \\cdot 1   1 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 0   1 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 1 \\\\\n1 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 0   1 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 1   1 \\cdot 0 + 0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 0   1 \\cdot 0 + 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 1 \\\\\n0 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 0   0 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 0 + 0 \\cdot 1   0 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 0   0 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 1 \\\\\n0 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 0   0 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 1   0 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 0   0 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 1\n\\end{pmatrix}\n$$\n$$\nN = \\begin{pmatrix}\n2  1  1  0 \\\\\n1  2  0  1 \\\\\n1  0  2  1 \\\\\n0  1  1  2\n\\end{pmatrix}\n$$\n\n(2) 仅使用 $N$ 的结构，找出 $N$ 的零空间中的一个非平凡向量，并对其进行解释。\n\n一个向量 $v$ 属于 $N=G^\\top G$ 的零空间，当且仅当它属于 $G$ 的零空间。我们寻找一个非零向量 $v = (v_1, v_2, v_3, v_4)^\\top$，使得 $Gv=0$。这等价于以下线性方程组：\n$$\nv_1 + v_2 = 0 \\\\\nv_3 + v_4 = 0 \\\\\nv_1 + v_3 = 0 \\\\\nv_2 + v_4 = 0\n$$\n从第一个方程，得到 $v_2 = -v_1$。从第三个方程，得到 $v_3 = -v_1$。将这些代入第二个方程，得到 $(-v_1) + v_4 = 0$，这意味着 $v_4 = v_1$。第四个方程 $v_2+v_4 = (-v_1) + v_1 = 0$ 自动满足，不提供新信息。\n因此，$G$（以及 $N$）的零空间中的任何向量都必须具有 $(c, -c, -c, c)^\\top$ 的形式，其中 $c \\in \\mathbb{R}$ 为某个标量。\n通过设 $c=1$，可以得到一个简单的非平凡向量：\n$$\nv_{\\text{null}} = (1, -1, -1, 1)^\\top\n$$\n该向量表示一种慢度扰动的“棋盘”模式。如果我们将此模式（按任意常数 $\\alpha$ 缩放）加到给定的慢度模型 $m$ 上，得到新模型 $m' = m + \\alpha v_{\\text{null}}$，则使用给定的测量值无法将 $m'$ 与 $m$ 区分开。每条射线的走时保持不变：\n- 射线 1：变化为 $\\alpha v_1 + \\alpha v_2 = \\alpha(1-1) = 0$。\n- 射线 2：变化为 $\\alpha v_3 + \\alpha v_4 = \\alpha(-1+1) = 0$。\n- 射线 3：变化为 $\\alpha v_1 + \\alpha v_3 = \\alpha(1-1) = 0$。\n- 射线 4：变化为 $\\alpha v_2 + \\alpha v_4 = \\alpha(-1+1) = 0$。\n这代表了采集几何中的一种基本模糊性：水平和垂直射线集合无法分辨慢度场中的棋盘状结构。非平凡零空间的存在意味着矩阵 $N$ 是奇异的，且反演问题是不适定的（具体来说，解不是唯一的）。\n\n(3) 按非递增顺序计算 $N$ 的特征值。\n\n我们需要求出矩阵 $N$ 的特征值。\n$$\nN = \\begin{pmatrix}\n2  1  1  0 \\\\\n1  2  0  1 \\\\\n1  0  2  1 \\\\\n0  1  1  2\n\\end{pmatrix}\n$$\n由于我们已经在 $N$ 的零空间中找到了一个非零向量，因此其中一个特征值必定是 $\\lambda = 0$。\n\n矩阵 $N$ 具有分块结构。设 $A = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}$ 和 $I_2 = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}$。那么 $N$ 可以写成：\n$$\nN = \\begin{pmatrix} A  I_2 \\\\ I_2  A \\end{pmatrix}\n$$\n这种形式的分块矩阵的特征值是矩阵 $A+I_2$ 和 $A-I_2$ 的特征值的集合。\n\n首先，我们求出子矩阵的特征值。\n对于 $A+I_2$：\n$$\nA+I_2 = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} + \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 3  1 \\\\ 1  3 \\end{pmatrix}\n$$\n特征方程为 $\\det((A+I_2) - \\lambda I) = 0$：\n$$\n(3-\\lambda)^2 - 1 = 0 \\implies 3-\\lambda = \\pm 1 \\implies \\lambda = 3 \\mp 1\n$$\n这给出两个特征值：$\\lambda_a = 4$ 和 $\\lambda_b = 2$。\n\n对于 $A-I_2$：\n$$\nA-I_2 = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} - \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1  1 \\\\ 1  1 \\end{pmatrix}\n$$\n特征方程为 $\\det((A-I_2) - \\lambda I) = 0$：\n$$\n(1-\\lambda)^2 - 1 = 0 \\implies 1-\\lambda = \\pm 1 \\implies \\lambda = 1 \\mp 1\n$$\n这给出两个特征值：$\\lambda_c = 2$ 和 $\\lambda_d = 0$。\n\n$N$ 的特征值集合是 $A+I_2$ 和 $A-I_2$ 的特征值的并集，即 $\\{4, 2, 2, 0\\}$。\n将这些按非递增顺序排列，我们得到：$4, 2, 2, 0$。\n\n特征值 $\\lambda=0$ 对应于我们找出的零空间向量。$N$ 的秩为 $3$，零度为 $1$。零特征值的存在证实了该矩阵是奇异的，且最小二乘问题没有唯一解。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4  2  2  0\n\\end{pmatrix}\n}\n$$", "id": "3370624"}, {"introduction": "在诊断出不适定性之后，下一步是学习如何“治愈”它。Tikhonov 正则化是稳定不适定问题的一种经典而强大的方法。本练习将探讨反卷积问题——即对信号或图像进行“去模糊”处理——我们将通过在频域中分析，来精确地观察正则化是如何防止朴素逆运算中出现的噪声放大问题，并推导出最优的重建滤波器 ([@problem_id:3370633])。", "problem": "考虑离散时间中的典范线性逆问题：从由卷积模型 $y[n] = (h * x)[n]$ 生成的测量值 $y[n]$ 中恢复未知序列 $x[n]$，其中 $h[n]$ 是一个已知的点扩散函数。假设重建是通过带二次惩罚项的吉洪诺夫正则化（Tikhonov regularization）得到的，即通过在所有平方可和序列 $x[n]$ 上最小化泛函 $\\|h * x - y\\|_{2}^{2} + \\lambda \\|x\\|_{2}^{2}$ 来实现，其中 $\\lambda > 0$ 是正则化参数。\n\n给定在 $n = 0, 1, 2$ 上支撑的三抽头平均核 $h[n] = \\tfrac{1}{3}(1, 1, 1)$。使用离散时间傅里叶变换（DTFT）在频域中进行求解，其约定为 $X(\\omega) = \\sum_{n=-\\infty}^{\\infty} x[n] \\exp(-\\mathrm{j}\\,\\omega n)$ 和 $Y(\\omega) = \\sum_{n=-\\infty}^{\\infty} y[n] \\exp(-\\mathrm{j}\\,\\omega n)$（其中 $\\omega \\in [-\\pi, \\pi)$），以及卷积定理 $(h * x) \\xleftrightarrow{\\text{DTFT}} H(\\omega) X(\\omega)$。\n\n从第一性原理以及DTFT和最小二乘最小化的标准性质出发，推导最小化 $\\|h * x - y\\|_{2}^{2} + \\lambda \\|x\\|_{2}^{2}$ 的频域解 $\\widehat{X}(\\omega)$。然后，针对特定的 $h[n] = \\tfrac{1}{3}(1,1,1)$，计算重建滤波器 $G(\\omega)$ 的闭式频率响应，使得 $\\widehat{X}(\\omega) = G(\\omega)\\,Y(\\omega)$。将 $G(\\omega)$ 明确地用 $\\omega$ 和 $\\lambda$ 表示，并尽可能地化简。\n\n最后，从幅度和相位的角度对重建滤波器进行定性分析：确定滤波器幅度为零的频率，描述当 $\\lambda \\to 0^{+}$ 和 $\\lambda \\to \\infty$ 时的极限行为，并评论 $G(\\omega)$ 的相位。\n\n你的最终答案必须是 $G(\\omega)$ 的单一闭式解析表达式，经过化简并表示为 $\\omega$ 和 $\\lambda$ 的函数。不需要进行数值计算。如果引入任何缩写词，请在首次使用时定义。角度以弧度为单位。", "solution": "目标是为一个吉洪诺夫正则化反卷积问题找到重建滤波器 $G(\\omega)$。解 $\\widehat{x}[n]$ 是最小化以下泛函的序列：\n$$J(x) = \\|h * x - y\\|_{2}^{2} + \\lambda \\|x\\|_{2}^{2}$$\n这里，$x$ 代表未知序列 $x[n]$，$y$ 是测量序列 $y[n]$，$h$ 是已知的核 $h[n]$，`*` 表示卷积，$\\lambda > 0$ 是正则化参数。范数 $\\|\\cdot\\|_2$ 是离散时间序列的标准 $\\ell_2$-范数，定义为 $\\|s\\|_{2}^{2} = \\sum_{n=-\\infty}^{\\infty} |s[n]|^2$。\n\n这个问题最方便在频域中使用离散时间傅里叶变换（DTFT）求解。我们将利用帕塞瓦尔定理（Parseval's theorem），该定理将序列的平方和与频域中其幅度的平方积分联系起来：\n$$\\|s\\|_{2}^{2} = \\sum_{n=-\\infty}^{\\infty} |s[n]|^2 = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} |S(\\omega)|^2 \\, d\\omega$$\n其中 $S(\\omega)$ 是序列 $s[n]$ 的DTFT。\n\n将帕塞瓦尔定理应用于泛函 $J(x)$ 中的两项，我们将最小化问题转换到频域。设 $X(\\omega)$、$Y(\\omega)$ 和 $H(\\omega)$ 分别是 $x[n]$、$y[n]$ 和 $h[n]$ 的DTFT。根据卷积定理，卷积项 $(h * x)[n]$ 的DTFT是 $H(\\omega)X(\\omega)$。\n\n第一项，即数据保真项，变为：\n$$\\|h * x - y\\|_{2}^{2} = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} |H(\\omega)X(\\omega) - Y(\\omega)|^2 \\, d\\omega$$\n第二项，即正则化项，变为：\n$$\\lambda \\|x\\|_{2}^{2} = \\lambda \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} |X(\\omega)|^2 \\, d\\omega$$\n将它们结合起来，频域中的泛函为：\n$$J(X) = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} \\left( |H(\\omega)X(\\omega) - Y(\\omega)|^2 + \\lambda |X(\\omega)|^2 \\right) \\, d\\omega$$\n为了最小化积分 $J(X)$，我们可以对每个频率 $\\omega \\in [-\\pi, \\pi)$ 逐点最小化被积函数。设被积函数为 $L(\\omega, X(\\omega))$：\n$$L(\\omega, X(\\omega)) = |H(\\omega)X(\\omega) - Y(\\omega)|^2 + \\lambda |X(\\omega)|^2$$\n对于每个频率 $\\omega$，这是一个关于复变量 $X(\\omega)$ 的标准最小二乘问题。我们通过求 $L$ 关于 $X(\\omega)^*$ 的复导数并将其设为零来找到最小值。\n$$\\frac{\\partial L}{\\partial X(\\omega)^*} = \\frac{\\partial}{\\partial X(\\omega)^*} \\left( (H(\\omega)X(\\omega) - Y(\\omega))(H(\\omega)^*X(\\omega)^* - Y(\\omega)^*) + \\lambda X(\\omega)X(\\omega)^* \\right) = 0$$\n$$\\frac{\\partial L}{\\partial X(\\omega)^*} = (H(\\omega)X(\\omega) - Y(\\omega)) H(\\omega)^* + \\lambda X(\\omega) = 0$$\n$$(|H(\\omega)|^2 + \\lambda) X(\\omega) - H(\\omega)^* Y(\\omega) = 0$$\n求解最优频域表示 $\\widehat{X}(\\omega)$：\n$$(|H(\\omega)|^2 + \\lambda) \\widehat{X}(\\omega) = H(\\omega)^* Y(\\omega)$$\n$$\\widehat{X}(\\omega) = \\frac{H(\\omega)^*}{|H(\\omega)|^2 + \\lambda} Y(\\omega)$$\n这是频域中解的一般形式。重建滤波器 $G(\\omega)$ 由关系式 $\\widehat{X}(\\omega) = G(\\omega)Y(\\omega)$ 定义，因此我们可以确定：\n$$G(\\omega) = \\frac{H(\\omega)^*}{|H(\\omega)|^2 + \\lambda}$$\n现在，我们必须为特定的点扩散函数 $h[n] = \\frac{1}{3}(1, 1, 1)$（在 $n = 0, 1, 2$ 上支撑）计算它。其DTFT $H(\\omega)$ 为：\n$$H(\\omega) = \\sum_{n=0}^{2} \\frac{1}{3} \\exp(-\\mathrm{j}\\omega n) = \\frac{1}{3} (1 + \\exp(-\\mathrm{j}\\omega) + \\exp(-\\mathrm{j}2\\omega))$$\n这是一个几何级数。我们可以通过提出一个中心相位项来化简它：\n$$H(\\omega) = \\frac{1}{3} \\exp(-\\mathrm{j}\\omega) (\\exp(\\mathrm{j}\\omega) + 1 + \\exp(-\\mathrm{j}\\omega))$$\n使用恒等式 $2\\cos(\\omega) = \\exp(\\mathrm{j}\\omega) + \\exp(-\\mathrm{j}\\omega)$，我们得到：\n$$H(\\omega) = \\frac{1}{3} \\exp(-\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))$$\n从这个表达式中，我们计算其复共轭 $H(\\omega)^*$ 和模的平方 $|H(\\omega)|^2$：\n$$H(\\omega)^* = \\frac{1}{3} \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))$$\n$$|H(\\omega)|^2 = H(\\omega)H(\\omega)^* = \\left( \\frac{1}{3} \\exp(-\\mathrm{j}\\omega) (1 + 2\\cos(\\omega)) \\right) \\left( \\frac{1}{3} \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega)) \\right) = \\frac{1}{9} (1 + 2\\cos(\\omega))^2$$\n将这些代入 $G(\\omega)$ 的表达式中：\n$$G(\\omega) = \\frac{\\frac{1}{3} \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))}{\\frac{1}{9}(1 + 2\\cos(\\omega))^2 + \\lambda}$$\n为了化简，我们将分子和分母乘以9：\n$$G(\\omega) = \\frac{3 \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))}{(1+2\\cos(\\omega))^2 + 9\\lambda}$$\n这就是重建滤波器 $G(\\omega)$ 的最终闭式表达式。\n\n最后，我们对这个滤波器进行定性分析。\n\n幅度：滤波器的幅度为：\n$$|G(\\omega)| = \\frac{3 |1 + 2\\cos(\\omega)|}{(1+2\\cos(\\omega))^2 + 9\\lambda}$$\n当 $1 + 2\\cos(\\omega) = 0$ 时，幅度为零，这发生在频率 $\\omega = \\pm 2\\pi/3$ 处。这些是前向滤波器 $H(\\omega)$ 具有零点的频率，在这些频率上关于信号的任何信息都无法恢复。正则化正确地确保了逆滤波器在这些频率处的增益也为零。\n\n相位：$G(\\omega)$ 的相位由项 $ \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega)) $ 决定。对于 $\\lambda > 0$，分母总是实数且为正。项 $(1 + 2\\cos(\\omega))$ 是实数，但可能为负。\n- 当 $1+2\\cos(\\omega) > 0$ 时，即对于 $|\\omega|  2\\pi/3$，$G(\\omega)$ 的相位是 $\\omega$。\n- 当 $1+2\\cos(\\omega)  0$ 时，即对于 $2\\pi/3  |\\omega| \\leq \\pi$，该项为负，贡献一个 $\\pi$ 的相移。$G(\\omega)$ 的相位是 $\\omega + \\pi$（或 $\\omega - \\pi$ 以保持在主值范围内）。\n因此，滤波器在频率 $\\omega = \\pm 2\\pi/3$ 处表现出相位反转。\n\n极限行为：\n- 当 $\\lambda \\to 0^{+}$ 时（无正则化）：\n$$G(\\omega) \\to \\frac{3 \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))}{(1+2\\cos(\\omega))^2} = \\frac{3 \\exp(\\mathrm{j}\\omega)}{1+2\\cos(\\omega)} = \\frac{1}{H(\\omega)}$$\n滤波器趋近于朴素逆滤波器，该滤波器不稳定，并在 $H(\\omega)$ 为零的频率处无限放大噪声。\n- 当 $\\lambda \\to \\infty$ 时（强正则化）：\n$$G(\\omega) \\to 0$$\n滤波器增益对所有频率都趋于零。这意味着重建信号 $\\widehat{X}(\\omega) = G(\\omega)Y(\\omega)$ 趋于零，从而得到 $\\widehat{x}[n] = 0$。这是符合预期的，因为对信号能量的无限惩罚会迫使解为零信号，而不管测量值如何。", "answer": "$$\\boxed{\\frac{3 \\exp(\\mathrm{j}\\omega) (1 + 2\\cos(\\omega))}{(1+2\\cos(\\omega))^{2} + 9\\lambda}}$$", "id": "3370633"}, {"introduction": "本章的最后一个实践将我们从解析解带入现代计算方法的世界。这个练习旨在解决一个在地震学或声学中常见的任务：从波场测量数据中定位若干个点源。我们将利用 $\\ell_1$ 正则化（LASSO）来施加源分布是稀疏的这一先验知识，并实现 FISTA 算法——现代信号处理中的主力算法之一——来求解这个问题 ([@problem_id:3370666])。", "problem": "考虑在区间 $[0,L]$ 上，一个具有恒定波速 $c$ 的均匀介质中的一维波传播模型，其中在边界位置 $x=0$ 和 $x=L$ 处设置了点传感器。未知的源分布被假定为稀疏的，并建模为狄拉克点源之和 $s(x) = \\sum_{j=1}^{J} a_j \\,\\delta(x - x_j)$，其中振幅 $a_j$ 是复数值，位置 $x_j$ 位于给定的离散空间网格上。测量的量是通过对记录的时域信号应用时间傅里叶变换，在边界传感器处获得的频域迹。设角频率由 $\\omega$ 表示（单位为弧度每秒）。在频域中，场 $u(x,\\omega)$ 满足带源项的一维亥姆霍兹方程。为解决此问题，使用亥姆霍兹算子的自由空间一维格林函数，来对从稀疏源分布到边界传感器测量的映射进行建模。对于给定的角频率 $\\omega$，定义 $k = \\omega/c$。位于传感器位置 $x_m \\in \\{0,L\\}$ 的频域测量可以建模为线性叠加\n$$\ny(x_m,\\omega) \\;=\\; \\sum_{j=1}^{J} a_j \\, G_\\omega\\left(|x_m - x_j|\\right),\n$$\n其中\n$$\nG_\\omega(r) \\;=\\; \\frac{i}{2k}\\, e^{i k r},\n$$\n且 $r$ 是从源位置到传感器位置的距离。在此模型下，将多个角频率 $\\{\\omega_\\ell\\}_{\\ell=1}^{F}$ 和两个传感器位置的测量叠加成一个单一的复值测量向量，会得到一个形如以下的线性系统\n$$\n\\mathbf{y} \\;=\\; \\mathbf{A}\\,\\mathbf{x} \\;+\\; \\boldsymbol{\\varepsilon},\n$$\n其中 $\\mathbf{x} \\in \\mathbb{C}^{N}$ 是与 $N$ 点空间网格对齐的未知稀疏源振幅向量，$\\mathbf{A} \\in \\mathbb{C}^{MF \\times N}$ 是正向算子，其元素为 $A_{(\\ell,m),j} = G_{\\omega_\\ell}(|x_m - x_j|)$，$M=2$ 是传感器数量，$\\boldsymbol{\\varepsilon}$ 模型化了测量中的加性复噪声。相位角 $kr$ 以弧度为单位。\n\n逆源定位任务是从带噪声的边界测量 $\\mathbf{y}$ 中恢复稀疏向量 $\\mathbf{x}$，从而推断出源所在的支撑集（网格位置）及其振幅。为稳定反演过程并促进稀疏性，使用最小绝对收缩和选择算子 (LASSO) 公式，通过最小化一个凸惩罚最小二乘目标函数来求解 $\\widehat{\\mathbf{x}}$：\n$$\n\\widehat{\\mathbf{x}} \\;=\\; \\arg\\min_{\\mathbf{z}\\in\\mathbb{C}^{N}} \\;\\frac{1}{2}\\,\\|\\mathbf{A}\\,\\mathbf{z} - \\mathbf{y}\\|_2^2 \\;+\\; \\lambda \\,\\|\\mathbf{z}\\|_1,\n$$\n其中 $\\lambda > 0$ 是正则化参数，$\\|\\cdot\\|_2$ 是欧几里得范数，$\\|\\cdot\\|_1$ 是对复向量定义的逐项 $\\ell_1$ 范数，即 $\\|\\mathbf{z}\\|_1 = \\sum_{j=1}^{N} |z_j|$。\n\n为上述目标函数实现一个基于近端梯度原理的求解器（使用快速迭代收缩阈值算法 (FISTA)）。使用多个角频率来改善条件（多频稳定），并通过幂迭代估计 $\\mathbf{A}^*\\mathbf{A}$ 的最大特征值（其中 $\\mathbf{A}^*$ 表示共轭转置），以设置梯度步长。使用一个逐项作用的复值软阈值算子 $S_\\tau(z)$，定义为 $S_\\tau(0)=0$ 并且\n$$\nS_\\tau(z) \\;=\\; \\max\\{ |z| - \\tau, \\, 0 \\}\\,\\frac{z}{|z|} \\quad \\text{for } z\\neq 0.\n$$\n\n噪声模型：向 $\\mathbf{y}$ 添加独立同分布的复高斯噪声，其中每个分量的实部和虚部都具有标准差 $\\sigma$，该标准差通过相对噪声水平参数 $\\eta$ 由 $\\sigma = \\eta \\cdot \\operatorname{median}(|\\mathbf{y}_\\text{clean}|)$ 确定，其中 $\\mathbf{y}_\\text{clean} = \\mathbf{A}\\,\\mathbf{x}_\\text{true}$ 表示无噪声的测量向量；如果 $\\operatorname{median}(|\\mathbf{y}_\\text{clean}|) = 0$，则设置 $\\sigma = \\eta$。\n\n检测与评分：对于指定的检测阈值 $\\tau_\\text{det}$，如果在网格索引 $j$ 处 $|\\widehat{x}_j| \\ge \\tau_\\text{det}$，则声明在该处恢复了一个源。如果一个恢复源的网格索引与一个真实源的索引相差最多为 $1$，则该恢复源被计为与真实源匹配。对于匹配的源，使用 $|\\,|\\widehat{x}_j| - |x^\\text{true}_j|\\,|}$ 计算平均绝对位置误差（单位：米）和平均绝对振幅误差，其中 $x^\\text{true}_j$ 是在匹配网格索引处的真实振幅。同时，计算假阳性的数量，定义为在上述标准下不与任何真实源匹配的恢复源的数量。对于每个测试案例，按顺序报告匹配源的整数数量、平均位置误差（单位：米）、平均振幅误差（无量纲）以及假阳性的整数数量。\n\n单位：位置以米表示，波速以米每秒表示，角频率以弧度每秒表示，时间以秒表示。平均位置误差必须以米报告。振幅误差是无量纲的。除了相位 $kr$ 外，没有出现其他角度，并且它们被解释为弧度。\n\n您的程序必须实现上述模型和求解器，并运行以下测试套件。对于每个测试案例，使用一个包含 $N=101$ 个点的均匀空间网格，覆盖 $[0,L]$（含端点），在 $x=0$ 和 $x=L$ 处设置两个传感器，并使用指定的参数。最多使用 $T=800$ 次 FISTA 迭代，用零向量初始化算法，并使用固定的随机种子 $12345$ 生成噪声以确保可复现性。\n\n测试套件：\n- 案例1（两个良好分离的源，中等噪声，多频）：\n  - $L = 1.0$ 米, $c = 1.0$ 米每秒。\n  - 角频率 $\\omega \\in \\{10.0,\\,20.0,\\,30.0,\\,40.0,\\,50.0\\}$ 弧度每秒。\n  - 真实源位置 $x_1 = 0.25$ 米, $x_2 = 0.75$ 米；振幅 $a_1 = 1.0$, $a_2 = 0.7$（无量纲），对齐到最近的网格点。\n  - 噪声水平 $\\eta = 0.05$，正则化参数 $\\lambda = 0.05$，检测阈值 $\\tau_\\text{det} = 0.20$。\n- 案例2（单个近边界源，较少频率，较高噪声）：\n  - $L = 1.0$ 米, $c = 1.0$ 米每秒。\n  - 角频率 $\\omega \\in \\{5.0,\\,10.0,\\,15.0\\}$ 弧度每秒。\n  - 真实源位置 $x_1 = 0.02$ 米；振幅 $a_1 = 1.0$（无量纲），对齐到最近的网格点。\n  - 噪声水平 $\\eta = 0.10$，正则化参数 $\\lambda = 0.08$，检测阈值 $\\tau_\\text{det} = 0.25$。\n- 案例3（无源，中等噪声，较强正则化）：\n  - $L = 1.0$ 米, $c = 1.0$ 米每秒。\n  - 角频率 $\\omega \\in \\{10.0,\\,20.0,\\,30.0\\}$ 弧度每秒。\n  - 无源（即 $\\mathbf{x}_\\text{true} = \\mathbf{0}$）。\n  - 噪声水平 $\\eta = 0.05$，正则化参数 $\\lambda = 0.10$，检测阈值 $\\tau_\\text{det} = 0.25$。\n- 案例4（两个紧邻的源，较高频率，低噪声）：\n  - $L = 1.0$ 米, $c = 1.0$ 米每秒。\n  - 角频率 $\\omega \\in \\{60.0,\\,80.0,\\,100.0,\\,120.0\\}$ 弧度每秒。\n  - 真实源位置 $x_1 = 0.49$ 米, $x_2 = 0.51$ 米；振幅 $a_1 = 1.0$, $a_2 = 0.8$（无量纲），对齐到最近的网格点。\n  - 噪声水平 $\\eta = 0.02$，正则化参数 $\\lambda = 0.04$，检测阈值 $\\tau_\\text{det} = 0.15$。\n\n对于每个测试案例，计算并返回一个包含四个量的列表：匹配源的整数数量、平均绝对位置误差（浮点数，单位：米）、平均绝对振幅误差（浮点数）以及假阳性的整数数量。您的程序应生成一行输出，其中包含所有四个测试案例的结果，形式为一个以逗号分隔的各案例列表的列表，并用方括号括起来，不含嵌入的空格。例如，一个有效的输出格式是 $[[1,0.01,0.05,0],[\\dots]]$（所示数字仅为说明，并非实际答案）。", "solution": "用户提供了一个关于一维波传播模型下逆源定位的问题。我将首先验证问题陈述，然后提供详细的解决方案。\n\n### 第1步：提取已知条件\n- **物理模型**：在区间 $[0,L]$ 上的恒定波速为 $c$ 的一维波传播。\n- **源模型**：狄拉克点源的稀疏和，$s(x) = \\sum_{j=1}^{J} a_j \\,\\delta(x - x_j)$，其中 $a_j$ 是复振幅，$x_j$ 是离散空间网格上的位置。\n- **测量设置**：两个点传感器位于 $x=0$ 和 $x=L$。测量是在一组角频率 $\\{\\omega_\\ell\\}_{\\ell=1}^{F}$ 下的频域中进行的。\n- **正向算子**：测量向量 $\\mathbf{y} \\in \\mathbb{C}^{MF}$（其中 $M=2$ 是传感器数量）与源振幅向量 $\\mathbf{x} \\in \\mathbb{C}^{N}$（在 $N$ 点网格上离散化）通过线性系统 $\\mathbf{y} = \\mathbf{A}\\,\\mathbf{x} + \\boldsymbol{\\varepsilon}$ 相关联。矩阵 $\\mathbf{A} \\in \\mathbb{C}^{MF \\times N}$ 的元素为 $A_{(\\ell,m),j} = G_{\\omega_\\ell}(|x_m - x_j|)$，其中 $G_\\omega(r) = \\frac{i}{2k}\\, e^{i k r}$ 是自由空间格林函数，且 $k = \\omega/c$。\n- **逆问题**：任务是通过求解LASSO优化问题，从带噪声的测量 $\\mathbf{y}$ 中恢复稀疏向量 $\\mathbf{x}$：\n$$\n\\widehat{\\mathbf{x}} \\;=\\; \\arg\\min_{\\mathbf{z}\\in\\mathbb{C}^{N}} \\;\\frac{1}{2}\\,\\|\\mathbf{A}\\,\\mathbf{z} - \\mathbf{y}\\|_2^2 \\;+\\; \\lambda \\,\\|\\mathbf{z}\\|_1.\n$$\n- **求解器**：指定使用快速迭代收缩阈值算法 (FISTA)。\n    - 最大迭代次数 $T=800$。\n    - 使用零向量进行初始化。\n    - 梯度步长由 $\\mathbf{A}^*\\mathbf{A}$ 的最大特征值决定，该特征值通过幂迭代估计。\n    - 近端步使用复值软阈值算子：$z \\neq 0$ 时为 $S_\\tau(z) = \\max\\{|z|-\\tau, 0\\}\\,\\frac{z}{|z|}$。\n- **噪声模型**：加性独立同分布复高斯噪声，其中每个分量的实部和虚部的标准差为 $\\sigma = \\eta \\cdot \\operatorname{median}(|\\mathbf{y}_\\text{clean}|)$，如果中位数为零，则备用为 $\\sigma = \\eta$。使用固定的随机种子 $12345$。\n- **评估**：如果在网格索引 $j$ 处 $|\\widehat{x}_j| \\ge \\tau_\\text{det}$，则检测到一个源。如果一个检测到的源的网格索引与一个真实源的索引相差不超过 $1$，则认为它是一个匹配项。所需的输出指标是匹配数、平均绝对位置误差、平均绝对振幅误差和假阳性数。\n- **问题参数**：提供了四个不同测试案例的所有参数，包括几何形状 ($L$)、波速 ($c$)、频率 ($\\omega$)、真实源位置和振幅、正则化参数 ($\\lambda$)、噪声水平 ($\\eta$)、检测阈值 ($\\tau_\\text{det}$) 和网格大小 ($N=101$)。\n\n### 第2步：使用提取的已知条件进行验证\n对该问题进行严格的验证检查。\n- **科学基础**：该问题在波传播物理学（亥姆霍兹方程）、逆问题数学和凸优化理论方面有坚实的基础。格林函数、LASSO正则化和FISTA算法的使用都是该领域的标准和合理原则。\n- **适定性**：虽然底层的逆问题是不适定的，但LASSO公式将其正则化为一个具有唯一解的适定的凸优化问题。评估标准清晰明确。\n- **客观性**：问题以精确、定量和客观的语言陈述，没有任何主观因素。\n- **完整性与一致性**：问题陈述异常详尽，提供了所有必要的参数、常数、算法，甚至一个随机种子，以确保单一、可复现的结果。没有明显的矛盾。\n- **可行性**：物理和计算参数是合理的，允许在标准环境中计算出解决方案。对于这个基于仿真的问题，选择自由空间格林函数作为模型是一个有效且自洽的简化。\n\n### 第3步：结论与行动\n该问题是**有效的**。它是一个在计算反演理论中定义明确、科学上正确且完整的问题。我将继续开发解决方案。\n\n### 解决方案设计\n\n该解决方案将使用`numpy`库在Python中实现。总体结构将遵循测试套件，按顺序处理每个案例。对于每个案例，执行以下步骤：\n\n1.  **模型构建**：\n    - 在域 $[0, L]$ 上创建一个包含 $N=101$ 个点的均匀空间网格。\n    - 通过将给定的源振幅放置在最接近指定物理位置的网格点上，构建真实源向量 $\\mathbf{x}_{\\text{true}} \\in \\mathbb{C}^N$。\n    - 组装正向算子矩阵 $\\mathbf{A} \\in \\mathbb{C}^{MF \\times N}$。每一行对应一个特定的频率和传感器组合，每一列对应网格上的一个潜在源位置。矩阵元素使用提供的格林函数公式 $G_\\omega(r) = \\frac{i}{2k} e^{ikr}$ 计算，其中 $k=\\omega/c$。\n\n2.  **数据生成**：\n    - 计算干净的测量向量 $\\mathbf{y}_{\\text{clean}} = \\mathbf{A}\\,\\mathbf{x}_{\\text{true}}$。\n    - 根据噪声水平 $\\eta$ 和干净测量绝对值的中位数计算噪声标准差 $\\sigma$。\n    - 使用指定的随机种子 ($12345$) 生成加性复高斯噪声，并将其添加到干净数据中，以获得带噪声的测量向量 $\\mathbf{y}$。\n\n3.  **逆求解器 (FISTA)**：\n    - 使用FISTA最小化LASSO目标函数。此函数结合了最小二乘数据拟合项 $\\frac{1}{2}\\|\\mathbf{A}\\mathbf{z} - \\mathbf{y}\\|_2^2$ 和 $\\ell_1$ 范数正则化项 $\\lambda\\|\\mathbf{z}\\|_1$。\n    - **步长**：FISTA算法需要一个步长 $\\alpha$，它被设置为最小二乘项梯度的利普希茨常数的倒数。此常数是矩阵 $\\mathbf{A}^*\\mathbf{A}$ 的最大特征值。它使用标准的幂迭代方法估计，并用一个随机向量初始化以保证鲁棒性。共享的随机数生成器的使用确保了可复现性。\n    - **迭代**：FISTA算法对解估计进行 $T=800$ 次迭代更新。每次迭代包括：\n        a. 一个动量步以加速收敛。\n        b. 一个关于最小二乘项的梯度下降步。\n        c. 一个近端步，涉及应用复数软阈值算子 $S_{\\lambda\\alpha}(\\cdot)$ 以促进稀疏性。\n    - 算法的最终输出是估计的稀疏源向量 $\\widehat{\\mathbf{x}}$。\n\n4.  **结果评估**：\n    - 通过查找所有振幅大小 $|\\widehat{x}_j|$ 超过检测阈值 $\\tau_\\text{det}$ 的网格索引 $j$，从 $\\widehat{\\mathbf{x}}$ 中识别恢复的源位置。\n    - 实现一个匹配程序，将恢复的源与真实源关联起来。如果一个恢复源的网格索引与一个真实源的网格索引相差最多为 $1$，则认为该恢复源与真实源匹配。为处理模糊性，每个恢复源最多只能与一个真实源匹配，反之亦然，采用优先匹配更近索引的贪心方法。\n    - 基于此匹配，计算所需的四个指标：\n        1.  匹配源的总数。\n        2.  匹配对的平均绝对位置误差。\n        3.  匹配对的平均绝对振幅误差。\n        4.  假阳性（未匹配任何真实源的恢复源）的数量。\n    - 如果没有匹配到源，则平均误差报告为 $0.0$。\n\n整个过程被封装在一个函数中，为每个测试案例调用。最终结果被收集并格式化为指定的单个字符串。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the inverse source localization problem.\n    \"\"\"\n\n    test_cases = [\n        # Case 1\n        {\n            \"L\": 1.0, \"c\": 1.0, \"N\": 101,\n            \"omegas\": [10.0, 20.0, 30.0, 40.0, 50.0],\n            \"true_sources\": [(0.25, 1.0), (0.75, 0.7)],\n            \"eta\": 0.05, \"lambda_reg\": 0.05, \"tau_det\": 0.20,\n            \"T\": 800, \"seed\": 12345\n        },\n        # Case 2\n        {\n            \"L\": 1.0, \"c\": 1.0, \"N\": 101,\n            \"omegas\": [5.0, 10.0, 15.0],\n            \"true_sources\": [(0.02, 1.0)],\n            \"eta\": 0.10, \"lambda_reg\": 0.08, \"tau_det\": 0.25,\n            \"T\": 800, \"seed\": 12345\n        },\n        # Case 3\n        {\n            \"L\": 1.0, \"c\": 1.0, \"N\": 101,\n            \"omegas\": [10.0, 20.0, 30.0],\n            \"true_sources\": [],\n            \"eta\": 0.05, \"lambda_reg\": 0.10, \"tau_det\": 0.25,\n            \"T\": 800, \"seed\": 12345\n        },\n        # Case 4\n        {\n            \"L\": 1.0, \"c\": 1.0, \"N\": 101,\n            \"omegas\": [60.0, 80.0, 100.0, 120.0],\n            \"true_sources\": [(0.49, 1.0), (0.51, 0.8)],\n            \"eta\": 0.02, \"lambda_reg\": 0.04, \"tau_det\": 0.15,\n            \"T\": 800, \"seed\": 12345\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = run_case(params)\n        all_results.append(result)\n\n    list_of_strings = [str(r).replace(' ', '') for r in all_results]\n    print(f\"[{','.join(list_of_strings)}]\")\n\ndef run_case(params):\n    \"\"\"\n    Executes a single test case for the source localization problem.\n    \"\"\"\n    L, c, N = params[\"L\"], params[\"c\"], params[\"N\"]\n    omegas = np.array(params[\"omegas\"])\n    true_sources = params[\"true_sources\"]\n    eta, lambda_reg, tau_det = params[\"eta\"], params[\"lambda_reg\"], params[\"tau_det\"]\n    T_max = params[\"T\"]\n    seed = params[\"seed\"]\n    \n    # Setup grid and sensors\n    grid = np.linspace(0, L, N)\n    sensor_pos = np.array([0.0, L])\n    M = len(sensor_pos)\n    F = len(omegas)\n\n    # Construct true source vector x_true\n    x_true = np.zeros(N, dtype=complex)\n    for pos, amp in true_sources:\n        idx = np.argmin(np.abs(grid - pos))\n        x_true[idx] = amp\n\n    # Construct forward operator A\n    A = np.zeros((M * F, N), dtype=complex)\n    for i_f, omega in enumerate(omegas):\n        k = omega / c\n        if k == 0: continue\n        \n        G_func = lambda r: (1j / (2 * k)) * np.exp(1j * k * r)\n        \n        for i_m, xm in enumerate(sensor_pos):\n            row_idx = i_f * M + i_m\n            r_vec = np.abs(xm - grid)\n            A[row_idx, :] = G_func(r_vec)\n    \n    # Generate noisy measurement vector y\n    y_clean = A @ x_true\n    \n    median_abs_y = np.median(np.abs(y_clean)) if len(y_clean) > 0 else 0.0\n    sigma = eta * median_abs_y if median_abs_y > 0 else eta\n        \n    rng = np.random.RandomState(seed)\n    noise = sigma * (rng.randn(M * F) + 1j * rng.randn(M * F))\n    y = y_clean + noise\n\n    # Solve with FISTA\n    x_hat = fista_solver(A, y, lambda_reg, T_max, rng)\n\n    # Evaluate results\n    true_indices = np.where(np.abs(x_true) > 1e-9)[0]\n    detected_indices = np.where(np.abs(x_hat) >= tau_det)[0]\n\n    matched_pairs = []\n    used_detections = set()\n\n    for jt in sorted(list(true_indices)):\n        candidates = [jd for jd in detected_indices if abs(jd - jt) = 1 and jd not in used_detections]\n        if candidates:\n            # Find the best match (closest in index) and mark it as used\n            closest_jd = min(candidates, key=lambda jd: abs(jd - jt))\n            matched_pairs.append((jt, closest_jd))\n            used_detections.add(closest_jd)\n            \n    num_matched = len(matched_pairs)\n    num_fp = len(detected_indices) - len(used_detections)\n\n    pos_errors = []\n    amp_errors = []\n    if num_matched > 0:\n        for jt, jd in matched_pairs:\n            pos_errors.append(np.abs(grid[jd] - grid[jt]))\n            amp_errors.append(np.abs(np.abs(x_hat[jd]) - np.abs(x_true[jt])))\n\n    mean_pos_err = np.mean(pos_errors) if pos_errors else 0.0\n    mean_amp_err = np.mean(amp_errors) if amp_errors else 0.0\n\n    return [num_matched, mean_pos_err, mean_amp_err, num_fp]\n\ndef soft_thresholding(z, tau):\n    \"\"\"Complex-valued soft-thresholding operator.\"\"\"\n    abs_z = np.abs(z)\n    shrunk_abs = np.maximum(abs_z - tau, 0.0)\n    \n    # Handle division by zero for elements where abs_z is 0\n    unit_z = np.divide(z, abs_z, out=np.zeros_like(z, dtype=complex), where=abs_z != 0)\n    \n    return shrunk_abs * unit_z\n\ndef fista_solver(A, y, lambda_reg, T_max, rng):\n    \"\"\"\n    Solves the LASSO problem using the FISTA algorithm.\n    \"\"\"\n    N = A.shape[1]\n\n    # Estimate Lipschitz constant via power iteration\n    B = A.conj().T @ A\n    v = rng.randn(N) + 1j * rng.randn(N)\n    v /= np.linalg.norm(v)\n    for _ in range(20): # Power iterations\n        Bv = B @ v\n        v = Bv / np.linalg.norm(Bv)\n    \n    L_f = np.real(v.conj().T @ B @ v)\n    alpha = 1.0 / L_f if L_f > 0 else 1.0\n\n    # FISTA iteration\n    x_k = np.zeros(N, dtype=complex)\n    x_km1 = np.zeros(N, dtype=complex)\n    t_k = 1.0\n    t_km1 = 1.0\n    \n    for _ in range(T_max):\n        y_k = x_k + ((t_km1 - 1.0) / t_k) * (x_k - x_km1)\n        grad_y_k = A.conj().T @ (A @ y_k - y)\n        x_kp1 = soft_thresholding(y_k - alpha * grad_y_k, lambda_reg * alpha)\n        \n        t_kp1 = (1.0 + np.sqrt(1.0 + 4.0 * t_k**2)) / 2.0\n        \n        # Update state for next iteration\n        x_km1 = x_k\n        x_k = x_kp1\n        t_km1 = t_k\n        t_k = t_kp1\n        \n    return x_k\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3370666"}]}