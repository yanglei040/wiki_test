{"hands_on_practices": [{"introduction": "在浮点运算中，数学上等价的计算路径可能产生截然不同的结果。本练习通过一个精心设计的例子，要求您分析求解一个三角系统及其转置系统的两种不同方法。通过这个过程，您将亲身体会到，由于大数吃小数和灾难性抵消等效应，一个看似微小的算法选择会对数值稳定性产生巨大的影响 [@problem_id:3579228]。", "problem": "考虑一个下单位三角矩阵 $L \\in \\mathbb{R}^{4 \\times 4}$ 和精确解向量 $x^{\\star} \\in \\mathbb{R}^{4}$，其定义如下\n$$\nL \\;=\\;\n\\begin{pmatrix}\n1  0  0  0 \\\\\n10^{16}  1  0  0 \\\\\n-10^{16}  10^{-16}  1  0 \\\\\n0  -10^{-16}  10^{-16}  1\n\\end{pmatrix},\n\\qquad\nx^{\\star} \\;=\\;\n\\begin{pmatrix}\n1 \\\\ 1 \\\\ 1 \\\\ 1\n\\end{pmatrix}.\n$$\n定义右端项 $b \\in \\mathbb{R}^{4}$ 和 $c \\in \\mathbb{R}^{4}$ 如下\n$$\nb \\;=\\; L^{\\top} x^{\\star}, \\qquad c \\;=\\; L x^{\\star}.\n$$\n我们在电气与电子工程师协会 754 (IEEE 754) 标准的双精度 (binary64) 浮点算术模型下进行运算，采用舍入到最近，平局取偶的规则。设单位舍入误差为 $u = 2^{-53}$，并假设每个基本运算都遵循标准模型，\n$$\n\\operatorname{fl}(a \\circ b) \\;=\\; (a \\circ b)\\,(1 + \\delta), \\qquad |\\delta| \\leq u,\n$$\n对于 $\\circ \\in \\{+, -, \\times, \\div\\}$，不使用积和熔加运算，点积按照循环顺序通过朴素的从左到右求和方式累加。假设 $L$ 以列主序布局存储。考虑两种计算路径：\n\n1. 路径 A：通过回代法求解 $L^{\\top} x = b$。对于从 $4$ 降到 $1$ 的索引 $i$，计算\n$$\nx_i \\;=\\; \\frac{b_i - \\sum_{j=i+1}^{4} L_{j,i} \\, x_j}{L_{i,i}},\n$$\n内积的求和范围为 $j = i+1, i+2, \\dots, 4$。\n\n2. 路径 B：通过前代法求解 $L x = c$。对于从 $1$ 升到 $4$ 的索引 $i$，计算\n$$\nx_i \\;=\\; \\frac{c_i - \\sum_{j=1}^{i-1} L_{i,j} \\, x_j}{L_{i,i}},\n$$\n内积的求和范围为 $j = 1, 2, \\dots, i-1$。\n\n使用指定的算术模型、内存布局和求和顺序，分析浮点舍入效应，以解释为什么对于此数据，路径 A 在数值上优于路径 B。特别地，确定路径 B 产生的计算值 $\\hat{x}^{(B)}_2$，然后计算绝对前向误差 $|\\,\\hat{x}^{(B)}_2 - x^{\\star}_2\\,|$。将你的最终答案表示为一个实数值。无需舍入。", "solution": "该问题陈述是有效的。这是一个数值线性代数中的适定问题，基于标准的浮点算术模型。所有必要的数据和定义均已提供，不存在内部矛盾或科学上的不准确之处。\n\n该问题要求分析求解涉及矩阵 $L$ 及其转置 $L^{\\top}$ 的三角系统的两种计算路径。一种路径相对于另一种路径的优越性取决于其在面对浮点舍入误差时的数值稳定性。我们将首先为不同的稳定性提供一个总体解释，然后对路径 B 进行详细的浮点分析，以计算所需的误差。\n\n矩阵 $L$ 和精确解 $x^{\\star}$ 如下所示：\n$$\nL \\;=\\;\n\\begin{pmatrix}\n1  0  0  0 \\\\\n10^{16}  1  0  0 \\\\\n-10^{16}  10^{-16}  1  0 \\\\\n0  -10^{-16}  10^{-16}  1\n\\end{pmatrix},\n\\qquad\nx^{\\star} \\;=\\;\n\\begin{pmatrix}\n1 \\\\ 1 \\\\ 1 \\\\ 1\n\\end{pmatrix}.\n$$\n右端向量 $b$ 和 $c$ 定义为 $b = L^{\\top} x^{\\star}$ 和 $c = L x^{\\star}$。它们的精确值为：\n$$\nc \\;=\\; L x^{\\star} \\;=\\; \\begin{pmatrix} 1 \\\\ 10^{16} + 1 \\\\ -10^{16} + 10^{-16} + 1 \\\\ 1 \\end{pmatrix}\n$$\n$$\nb \\;=\\; L^{\\top} x^{\\star} \\;=\\; \\begin{pmatrix} 1 + 10^{16} - 10^{16} \\\\ 1 + 10^{-16} - 10^{-16} \\\\ 1 + 10^{-16} \\\\ 1 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 + 10^{-16} \\\\ 1 \\end{pmatrix}\n$$\n分析的核心在于用 IEEE 754 双精度算术表示这些向量并进行计算。单位舍入误差为 $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。\n\n首先，我们分析为什么路径 A 在数值上更优。路径 A 的算法使用回代法求解 $L^{\\top} x = b$。计算机实现的第一步是以浮点格式存储向量 $b$，我们将其记为 $\\hat{b}$。\n- $\\hat{b}_1 = \\operatorname{fl}(1) = 1$。\n- $\\hat{b}_2 = \\operatorname{fl}(1) = 1$。\n- $\\hat{b}_3 = \\operatorname{fl}(1 + 10^{-16})$。对于数字 $1$，其末位单位（ulp）为 $\\operatorname{ulp}(1) = 2^{-52}$。如果一个增量的绝对值小于 ulp 的一半，即 $2^{-52}/2 = 2^{-53} = u$，则该增量将被舍去。我们必须将 $10^{-16}$ 与 $u$ 进行比较。由于 $\\log_{10}(u) \\approx -15.95$，我们有 $u \\approx 1.12 \\times 10^{-16}$。因此，$10^{-16}  u$，将 $10^{-16}$ 加到 $1$ 上的操作在舍入中丢失了。所以，$\\hat{b}_3 = 1$。\n- $\\hat{b}_4 = \\operatorname{fl}(1) = 1$。\n存储的右端项是 $\\hat{b} = (1, 1, 1, 1)^{\\top}$。然后，回代算法计算 $L^{\\top} \\hat{x}^{(A)} = \\hat{b}$ 的解 $\\hat{x}^{(A)}$。事实证明，此计算没有明显的舍入误差；例如，$\\hat{x}^{(A)}_1$ 的计算涉及项 $\\operatorname{fl}(10^{16} \\times \\hat{x}^{(A)}_2 - 10^{16} \\times \\hat{x}^{(A)}_3)$。当 $\\hat{x}^{(A)}_2=1$ 和 $\\hat{x}^{(A)}_3=1$ 时，此项计算结果为 $\\operatorname{fl}(10^{16} - 10^{16}) = 0$。最终计算出的解是 $\\hat{x}^{(A)} = (1, 1, 1, 1)^{\\top} = x^{\\star}$。路径 A 非常稳定，产生零前向误差。\n\n现在，我们分析路径 B，它使用前代法求解 $L x = c$。我们必须首先以浮点格式存储向量 $c$，得到 $\\hat{c}$。\n- $\\hat{c}_1 = \\operatorname{fl}(1) = 1$。\n- $\\hat{c}_2 = \\operatorname{fl}(10^{16} + 1)$。为确定此值，我们分析 $10^{16}$ 附近数字的表示。可以证明数字 $10^{16}$ 在双精度中是精确可表示的。$10^{16}$ 的二进制指数 $E$ 是 $53$，所以 $\\operatorname{ulp}(10^{16}) = 2^{E-52} = 2^{53-52} = 2$。因此，$10^{16}$附近的可表示数为偶数整数，例如 $10^{16}$ 和 $10^{16}+2$。值 $10^{16}+1$ 正好位于这两个可表示数之间。根据指定的“平局取偶”规则，我们必须选择整数尾数为偶数的可表示数。\n一个数的值是 $M \\times 2^k$。对于 $10^{16}$，尾数是 $M_1 = 10^{16} \\times 2^{-1} = 5 \\times 10^{15}$，这是一个奇数。对于 $10^{16}+2$，尾数是 $M_2 = (10^{16}+2) \\times 2^{-1} = 5 \\times 10^{15}+1$，这是一个偶数。因此，通过向上舍入到 $10^{16}+2$ 来打破平局。所以，$\\hat{c}_2 = 10^{16}+2$。这种表示引入了初始绝对误差 $|\\hat{c}_2 - c_2| = |(10^{16}+2) - (10^{16}+1)| = 1$。\n- 为完整起见，$\\hat{c}_3 = \\operatorname{fl}(1+10^{-16}-10^{16}) = \\operatorname{fl}(\\operatorname{fl}(1+10^{-16}) - 10^{16}) = \\operatorname{fl}(1-10^{16})$。这也是一个平局情况，舍入到 $-10^{16}+2$。\n- $\\hat{c}_4 = \\operatorname{fl}(1) = 1$。\n存储的右端项是 $\\hat{c} = (1, 10^{16}+2, -10^{16}+2, 1)^{\\top}$。\n\n前代算法按以下步骤计算 $\\hat{x}^{(B)}$：\n对于 $i=1$：\n$$ \\hat{x}^{(B)}_1 = \\frac{\\hat{c}_1}{L_{1,1}} = \\frac{1}{1} = 1. $$\n对于 $i=2$：\n$$ \\hat{x}^{(B)}_2 = \\frac{\\hat{c}_2 - L_{2,1} \\hat{x}^{(B)}_1}{L_{2,2}} $$\n该计算在浮点算术中执行：\n$$ \\hat{x}^{(B)}_2 = \\operatorname{fl}\\left(\\frac{\\operatorname{fl}(\\hat{c}_2 - \\operatorname{fl}(L_{2,1} \\times \\hat{x}^{(B)}_1))}{\\operatorname{fl}(L_{2,2})}\\right) $$\n使用值 $L_{2,1} = 10^{16}$，$L_{2,2} = 1$，$\\hat{x}^{(B)}_1 = 1$ 和 $\\hat{c}_2 = 10^{16}+2$：\n$$ \\operatorname{fl}(L_{2,1} \\times \\hat{x}^{(B)}_1) = \\operatorname{fl}(10^{16} \\times 1) = 10^{16}. $$\n分子变为：\n$$ \\operatorname{fl}(\\hat{c}_2 - 10^{16}) = \\operatorname{fl}((10^{16}+2) - 10^{16}) = \\operatorname{fl}(2) = 2. $$\n分母是 $1$。因此，计算值为：\n$$ \\hat{x}^{(B)}_2 = 2. $$\n这与精确解的分量 $x^{\\star}_2 = 1$ 有显著差异。在存储 $c_2$ 时引入的巨大初始误差，通过两个相近大数的相减而被揭示出来，这个过程称为灾难性抵消。这种不稳定性使得对于这个问题，路径 B 远不如路径 A。\n\n路径 B 中解向量第二个分量的绝对前向误差为：\n$$ |\\hat{x}^{(B)}_2 - x^{\\star}_2| = |2 - 1| = 1. $$\n这个误差源于将 $c_2 = 10^{16}+1$ 舍入为 $\\hat{c}_2 = 10^{16}+2$，展示了当前代算法的矩阵 $L$ 包含大元素时，该算法对右端项的微小相对扰动的敏感性。", "answer": "$$\n\\boxed{1}\n$$", "id": "3579228"}, {"introduction": "在现代计算机体系结构中，数据移动的成本远高于算术运算，这使得内存访问成为许多数值算法的性能瓶颈。本练习将引导您从第一性原理出发，分析一种关键的性能优化技术——分块（blocking）。您将推导并比较逐列求解和分块求解三角系统时的算术强度，从而量化分块操作为何能显著提高计算效率 [@problem_id:3579175]。", "problem": "考虑使用前向替换法求解下三角系统 $L X = B$，其中 $L \\in \\mathbb{R}^{m \\times m}$ 是对角线元素非零的下三角矩阵，$X \\in \\mathbb{R}^{m \\times n}$ 是解，$B \\in \\mathbb{R}^{m \\times n}$ 是右端项。有两种实现策略可供选择：(i) 对每一列 $L x^{(k)} = b^{(k)}$ ($k = 1, 2, \\dots, n$) 独立地使用前向替换法求解，以及 (ii) 以 $b$ 个右端项为一块，分块求解 $L X_j = B_j$，其中 $B$ 被划分为 $B = [B_1 \\, | \\, B_2 \\, | \\, \\dots \\, | \\, B_{n/b}]$，$B_j \\in \\mathbb{R}^{m \\times b}$ 且 $n$ 是 $b$ 的整数倍。假设一个双层内存模型：一个快速内存，可以在块计算期间保留 $B$ 的 $b$ 列和 $X$ 相应的 $b$ 列（即当前块 $B_j$ 和 $X_j$），但在当前流式传输过程之后无法保留 $L$；以及一个慢速内存（主存），数据从主存加载并存储到主存。设每个浮点元素的传输（加载或存储）移动 $w$ 字节。采用以下科学上现实的假设：\n- $B$ 的每个元素从慢速内存中精确读取一次，$X$ 的每个元素精确写入慢速内存一次（允许原地更新）。\n- 在逐列策略中，对于每一次列求解，$L$ 的整个下三角部分从慢速内存中流式传输一次。\n- 在分块策略中，对于 $b$ 列的每一个块，$L$ 的整个下三角部分从慢速内存中流式传输一次。\n将算术强度 $\\mathcal{I}$ 定义为浮点运算次数与慢速内存和快速内存之间移动的总字节数之比。从单列的基本前向替换递推关系出发，并且不借助任何现成的性能公式，推导出两种策略的总浮点运算次数和总数据移动量的表达式，然后求得分块策略与逐列策略的算术强度之比。请以仅含 $m$ 和 $b$ 的单个封闭形式表达式给出最终结果。不需要四舍五入，也不需要报告物理单位。您的推导必须从前向替换的定义和上述数据移动假设开始，并根据第一性原理推导出最终表达式。假设 $n$ 是 $b$ 的正整数倍，且 $L$ 是满秩的，因此前向替换是良定义的。", "solution": "目标是推导分块前向替换算法与逐列算法的算术强度之比，即 $\\frac{\\mathcal{I}_{\\text{blocked}}}{\\mathcal{I}_{\\text{col-wise}}}$。算术强度 $\\mathcal{I}$ 定义为总浮点运算次数（flops）与慢速内存和快速内存之间移动的总数据字节数之比。我们将按照规定从第一性原理推导这个比率。\n\n首先，我们确定求解系统 $L X = B$ 所需的总浮点运算次数，其中 $L \\in \\mathbb{R}^{m \\times m}$，$X \\in \\mathbb{R}^{m \\times n}$，$B \\in \\mathbb{R}^{m \\times n}$。求解过程与实现策略（逐列或分块）无关。我们首先分析求解单个列向量 $L x = b$ 的情况，其中 $x, b \\in \\mathbb{R}^m$。解向量 $x$ 的第 $i$ 个分量 $x_i$ 的前向替换递推关系由下式给出：\n$$x_i = \\frac{1}{l_{ii}} \\left( b_i - \\sum_{j=1}^{i-1} l_{ij} x_j \\right) \\quad \\text{for } i = 1, 2, \\dots, m$$\n对于每个 $i$，计算总和 $\\sum_{j=1}^{i-1} l_{ij} x_j$ 需要 $i-1$ 次乘法和 $i-2$ 次加法（对于 $i>1$）。之后，有一次从 $b_i$ 的减法和一次除以 $l_{ii}$ 的除法。一个标准的约定是将一次乘加运算计为 $2$ 次浮点运算。或者，我们分别计算加/减法和乘/除法。求和需要 $i-1$ 次乘法。括号内的项总共需要 $i-1$ 次减法（或1次减法和 $i-2$ 次加法）。最后，执行一次除法。计算 $x_i$ 的总浮点运算次数是 $(i-1)$ 次乘法、$(i-1)$ 次加/减法和 $1$ 次除法，总计为 $(i-1) + (i-1) + 1 = 2i - 1$ 次浮点运算。对于 $i=1$，这得到 $2(1)-1=1$ 次浮点运算（一次除法），这是正确的。\n\n求解一列的总浮点运算次数 $\\text{flops}_{\\text{col}}$ 是对所有分量 $i=1, \\dots, m$求和：\n$$\\text{flops}_{\\text{col}} = \\sum_{i=1}^{m} (2i-1) = 2\\sum_{i=1}^{m} i - \\sum_{i=1}^{m} 1 = 2 \\frac{m(m+1)}{2} - m = m(m+1) - m = m^2$$\n由于完整系统 $L X = B$ 由 $n$ 个这样的独立列求解组成，总浮点运算次数为：\n$$\\text{Flops}_{\\text{total}} = n \\cdot \\text{flops}_{\\text{col}} = n m^2$$\n\n接下来，我们分析每种策略的数据移动。设 $w$ 是每个浮点元素的字节数。矩阵 $B$ 和 $X$ 的移动对于两种策略是共同的。根据问题陈述，$B$ 的每个元素从慢速内存中读取一次，$X$ 的每个元素写入慢速内存一次。\n读取 $B$ 的数据量：$m \\times n$ 个元素 $\\times w$ 字节/元素 $= mnw$ 字节。\n写入 $X$ 的数据量：$m \\times n$ 个元素 $\\times w$ 字节/元素 $= mnw$ 字节。\n$B$ 和 $X$ 的总数据移动量是 $2mnw$ 字节。\n\n策略 (i)：逐列求解。\n在此策略中，我们对每一列 $k=1, \\dots, n$ 求解 $L x^{(k)} = b^{(k)}$。问题陈述指出，对于每一次列求解，$L$ 的整个下三角部分从慢速内存中流式传输一次。$L$ 的下三角部分中的非零元素数量为 $\\sum_{i=1}^{m} i = \\frac{m(m+1)}{2}$。\n读取 $L$ 的数据量：$n$ 列 $\\times \\frac{m(m+1)}{2}$ 元素/列 $\\times w$ 字节/元素 $= n \\frac{m(m+1)}{2} w$ 字节。\n逐列策略的总数据移动量 $M_{\\text{col-wise}}$ 是 $B$、$X$ 和 $L$ 的移动量之和：\n$$M_{\\text{col-wise}} = 2mnw + n \\frac{m(m+1)}{2} w = nw \\left( 2m + \\frac{m(m+1)}{2} \\right) = nw \\left( \\frac{4m + m^2 + m}{2} \\right) = nw \\frac{m(m+5)}{2}$$\n逐列策略的算术强度为：\n$$\\mathcal{I}_{\\text{col-wise}} = \\frac{\\text{Flops}_{\\text{total}}}{M_{\\text{col-wise}}} = \\frac{n m^2}{nw \\frac{m(m+5)}{2}} = \\frac{2m^2}{w m(m+5)} = \\frac{2m}{w(m+5)}$$\n\n策略 (ii)：分块求解。\n在此策略中，系统以 $b$ 列为一块进行求解。总列数为 $n$，因此有 $n/b$ 个块。问题陈述指出，$L$ 的下三角部分每个块从慢速内存中流式传输一次。\n读取 $L$ 的数据量：$\\frac{n}{b}$ 块 $\\times \\frac{m(m+1)}{2}$ 元素/块 $\\times w$ 字节/元素 $= \\frac{n}{b} \\frac{m(m+1)}{2} w$ 字节。\n分块策略的总数据移动量 $M_{\\text{blocked}}$ 是 $B$、$X$ 和 $L$ 的移动量之和：\n$$M_{\\text{blocked}} = 2mnw + \\frac{n}{b} \\frac{m(m+1)}{2} w = nw \\left( 2m + \\frac{m(m+1)}{2b} \\right) = nw \\left( \\frac{4mb + m^2 + m}{2b} \\right) = nw \\frac{m(m+4b+1)}{2b}$$\n分块策略的算术强度为：\n$$\\mathcal{I}_{\\text{blocked}} = \\frac{\\text{Flops}_{\\text{total}}}{M_{\\text{blocked}}} = \\frac{n m^2}{nw \\frac{m(m+4b+1)}{2b}} = \\frac{2b m^2}{w m(m+4b+1)} = \\frac{2bm}{w(m+4b+1)}$$\n\n最后，我们计算算术强度的比率。\n$$\\frac{\\mathcal{I}_{\\text{blocked}}}{\\mathcal{I}_{\\text{col-wise}}} = \\frac{\\frac{2bm}{w(m+4b+1)}}{\\frac{2m}{w(m+5)}}$$\n我们可以消去分子和分母中的公因式 $2m$ 和 $w$：\n$$\\frac{\\mathcal{I}_{\\text{blocked}}}{\\mathcal{I}_{\\text{col-wise}}} = \\frac{b}{m+4b+1} \\cdot (m+5) = \\frac{b(m+5)}{m+4b+1}$$\n该表达式给出了算术强度的比率，仅用矩阵维度 $m$ 和块大小 $b$ 表示，符合要求。", "answer": "$$\n\\boxed{\\frac{b(m+5)}{m+4b+1}}\n$$", "id": "3579175"}, {"introduction": "许多科学与工程问题最终都归结为稀疏线性系统的求解，其效率在很大程度上取决于矩阵的存储方式。本练习聚焦于一种广泛使用的格式——压缩稀疏行（CSR）格式，并要求您为其设计并实现一个前向替换求解器。此任务的核心在于分析算法在CSR表示下的内存访问模式，特别是区分直接与间接内存访问，这对于在稀疏计算中实现高性能至关重要 [@problem_id:3579221]。", "problem": "考虑使用前向替换法，在压缩稀疏行（CSR）格式下求解下三角线性系统。设该系统由一个方形、结构下三角矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个右端向量 $b \\in \\mathbb{R}^n$ 给出。目标是设计一个为前向替换法量身定制的、基于 CSR 的数据结构，形式化地推导该算法在这种数据表示下的访问模式，并根据非零元素的数量来界定每行的间接内存访问次数。在全文中，将间接内存访问解释为对解向量 $x$ 中任一元素 $x_j$ 的访问，其中索引 $j$ 是从列索引数组中获取的，而不是词法上已知的。\n\n基本基础：\n- 使用三角系统 $A x = b$（其中 $A$ 为下三角矩阵）的基本定义，以及由该三角结构产生的前向替换递推关系。\n- 使用压缩稀疏行（CSR）格式的规范定义：数组 $\\text{row\\_ptr} \\in \\mathbb{Z}^{n+1}$、$\\text{col\\_ind} \\in \\mathbb{Z}^{\\text{nnz}}$ 和 $\\text{val} \\in \\mathbb{R}^{\\text{nnz}}$，其中 $\\text{nnz}$ 表示存储的非零元素总数。行是连续存储的，因此第 $i$ 行占据索引范围 $k \\in [\\text{row\\_ptr}[i], \\text{row\\_ptr}[i+1])$。\n- 您可以假设在每个 CSR 行内，列索引是严格递增的。\n\n问题任务：\n1. 为下三角系统提出一个基于 CSR 的稀疏三角求解数据结构。该结构除了 $(\\text{row\\_ptr}, \\text{col\\_ind}, \\text{val})$ 外，还应包含以下两者之一：\n   - 一个整数数组 $\\text{diag\\_ind} \\in \\mathbb{Z}^n$，对于每一行 $i$ 满足 $\\text{col\\_ind}[\\text{diag\\_ind}[i]] = i$ 和 $\\text{diag\\_ind}[i] \\in [\\text{row\\_ptr}[i], \\text{row\\_ptr}[i+1])$；或者\n   - 一个约定，即对角线为单位对角线（不存储），这一点必须明确说明。\n   阐明一行中的哪些元素是“严格下三角”元素，哪些是“对角线”元素，以及如何在不扫描整行的情况下识别它们。\n2. 仅从三角系统和 CSR 的定义出发，推导在这种表示下的前向替换访问模式。准确识别对解向量 $x$ 的哪些内存引用是间接的，并根据该行中的非零元素数量（记为 $\\text{nnz}_i$）来界定每行 $i$ 的此类间接访问次数。您的界定必须区分两种情况：\n   - 存储了一般对角线（非单位对角线），\n   - 单位对角线（对角线元素未存储，等于 $1$）。\n   提供一个对所有行都有效的界，并论证为何在所述假设下它是紧凑的。\n3. 实现一个算法，给定 CSR 数据（包含由 $\\text{diag\\_ind}$ 定位的已存储对角线或单位对角线）和 $b$，执行前向替换来计算 $x$，并对每一行 $i$，计算生成 $x_i$ 所需的对 $x$ 的间接内存访问次数。返回每行的计数值以及解。通过对每个测试用例进行数值检验 $A x = b$ 来验证正确性。\n4. 对于测试套件中的每个测试用例，计算：\n   - 测量的每行间接访问计数的列表，\n   - 以及根据任务2推导出的、用 $\\text{nnz}_i$ 和对角线约定表示的每行访问次数上界的列表。\n   将所有测试用例的结果汇总到下面指定的最终输出格式中。\n\n使用的定义和约定：\n- 在非单位对角线情况下，对于每一行 $i$，严格下三角元素的索引为 $k \\in [\\text{row\\_ptr}[i], \\text{diag\\_ind}[i])$，对角线元素的索引为 $k = \\text{diag\\_ind}[i]$。\n- 在单位对角线情况下，对于每一行 $i$，该行中所有存储的元素都是严格下三角的，且对角线元素隐式地等于 $1$ 并且不被存储。\n\n测试套件：\n- 测试用例 1（非单位对角线，$n = 5$）：\n  - $\\text{row\\_ptr} = [0, 1, 3, 6, 9, 12]$,\n  - $\\text{col\\_ind} = [0, 0, 1, 0, 1, 2, 0, 2, 3, 1, 3, 4]$,\n  - $\\text{val} = [2.0, 1.0, 3.0, -1.0, 2.0, 4.0, 0.5, -1.0, 2.0, -2.0, 1.5, 5.0]$,\n  - $\\text{diag\\_ind} = [0, 2, 5, 8, 11]$,\n  - $x^{\\star} = [1.0, 2.0, 3.0, 4.0, 5.0]$,\n  - $b = A x^{\\star}$ 使用给定的 CSR 数据计算得出。\n- 测试用例 2（单位对角线，$n = 5$；对角线隐式地等于 $1$ 且不被存储）：\n  - $\\text{row\\_ptr} = [0, 0, 1, 3, 4, 6]$,\n  - $\\text{col\\_ind} = [0, 0, 1, 2, 0, 3]$,\n  - $\\text{val} = [0.25, -1.0, 0.5, 2.0, 1.0, -0.5]$,\n  - $x^{\\star} = [1.0, -1.0, 2.0, 0.0, 3.0]$,\n  - $b = A x^{\\star}$ 使用给定的 CSR 数据和隐式单位对角线计算得出。\n- 测试用例 3（非单位对角线，$n = 6$）：\n  - $\\text{row\\_ptr} = [0, 1, 3, 6, 10, 11, 14]$,\n  - $\\text{col\\_ind} = [0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 4, 2, 4, 5]$,\n  - $\\text{val} = [10.0, -3.0, -2.0, 7.0, 5.0, 1.0, -1.0, -1.0, -1.0, 8.0, 2.0, 2.0, -8.0, 4.0]$,\n  - $\\text{diag\\_ind} = [0, 2, 5, 9, 10, 13]$,\n  - $x^{\\star} = [1.0, 2.0, -1.0, 0.0, 3.0, -2.0]$,\n  - $b = A x^{\\star}$ 使用给定的 CSR 数据计算得出。\n\n答案规范和要求的输出格式：\n- 对于每个测试用例 $t$，设 $m^{(t)}$ 为测量的每行间接访问计数的列表，设 $u^{(t)}$ 为根据您在任务2中的推导获得的每行访问次数上界的列表。\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表形式的结果，并用方括号括起，结构为 $[[m^{(1)}, u^{(1)}], [m^{(2)}, u^{(2)}], [m^{(3)}, u^{(3)}]]$。每个 $m^{(t)}$ 和 $u^{(t)}$ 都必须是对应测试用例的长度为 $n$ 的整数列表。", "solution": "问题陈述已经过验证，被认为是合理的。它在数值线性代数方面有科学依据，问题提出得很好，目标明确，数据充分，并且没有矛盾或含糊之处。因此，我们可以着手提供完整的解决方案。\n\n任务是分析并实现一种用于稀疏下三角系统 $A x = b$ 的前向替换算法，其中矩阵 $A$ 以压缩稀疏行（CSR）格式存储。分析的重点是数据访问模式，特别是对解向量 $x$ 的间接内存访问次数。\n\n### 任务1：用于三角求解的基于 CSR 的数据结构\n\n标准的 CSR 格式由数组 $(\\text{row\\_ptr}, \\text{col\\_ind}, \\text{val})$ 组成，对于一般的稀疏矩阵-向量乘法是高效的，但对于三角求解则需要修改，因为对角线元素必须与严格下三角元素分开处理。我们形式化这两种被提出的结构。\n\n**情况A：存储的非单位对角线**\n数据结构为元组 $(\\text{row\\_ptr}, \\text{col\\_ind}, \\text{val}, \\text{diag\\_ind})$。\n- 数组 $\\text{row\\_ptr} \\in \\mathbb{Z}^{n+1}$、$\\text{col\\_ind} \\in \\mathbb{Z}^{\\text{nnz}}$ 和 $\\text{val} \\in \\mathbb{R}^{\\text{nnz}}$ 以标准 CSR 格式表示矩阵 $A$，存储所有非零元素。这里，$\\text{nnz}$ 是存储的非零元素的总数。\n- 辅助数组 $\\text{diag\\_ind} \\in \\mathbb{Z}^n$ 提供了对每行对角线元素的直接访问。对于行 $i$，$\\text{diag\\_ind}[i]$ 是 `val` 和 `col_ind` 中对应于对角线元素 $A_{ii}$ 的索引。保证 $\\text{col\\_ind}[\\text{diag\\_ind}[i]] = i$。\n- 假设每行内的列索引是排序的，则行 $i$ 的元素划分如下：\n  - **严格下三角元素**：这些是索引 $k$ 在范围 $[\\text{row\\_ptr}[i], \\text{diag\\_ind}[i] - 1]$ 内的元素。\n  - **对角线元素**：这是索引为 $k = \\text{diag\\_ind}[i]$ 的元素。\n  - 由于矩阵是下三角矩阵，不存在列索引 $j > i$ 的非零元素。\n\n**情况B：隐式单位对角线**\n数据结构为元组 $(\\text{row\\_ptr}, \\text{col\\_ind}, \\text{val})$。\n- CSR 数组只存储 $A$ 的**严格**下三角部分的非零元素。\n- 对角线元素 $A_{ii}$ 全部隐式地等于 $1$，并且不存储在 `val` 数组中。\n- 对于行 $i$，所有存储的元素（索引 $k$ 在范围 $[\\text{row\\_ptr}[i], \\text{row\\_ptr}[i+1] - 1]$ 内）都对应于严格下三角元素 $A_{ij}$，其中 $j  i$。\n\n### 任务2：前向替换访问模式的推导与间接访问的界定\n\n求解下三角系统 $A x = b$ 的前向替换基本方程是通过求解第 $i$ 个方程得到 $x_i$：\n$$ \\sum_{j=0}^{n-1} A_{ij} x_j = b_i \\implies A_{ii} x_i + \\sum_{j=0}^{i-1} A_{ij} x_j = b_i $$\n假设 $A_{ii} \\neq 0$，这会产生 $x_i$ 的递推关系：\n$$ x_i = \\frac{1}{A_{ii}} \\left( b_i - \\sum_{j=0}^{i-1} A_{ij} x_j \\right) $$\n“间接内存访问”被定义为对解向量中元素 $x_j$ 的一次访问，其中索引 $j$ 是从 `col_ind` 数组中检索的。\n\n**情况A的分析（存储的非单位对角线）**\n我们将递推关系转换到指定的 CSR 数据结构中。对行 $i$ 的严格下三角部分的求和对应于从该行的起始位置遍历 `val` 和 `col_ind` 数组，直到（但不包括）对角线元素。对角线的位置由 `diag_ind[i]` 给出。\n这个和是 $\\sum_{j=0}^{i-1} A_{ij} x_j = \\sum_{k=\\text{row\\_ptr}[i]}^{\\text{diag\\_ind}[i]-1} \\text{val}[k] \\cdot x_{\\text{col\\_ind}[k]}$。\n对角线元素是 $A_{ii} = \\text{val}[\\text{diag\\_ind}[i]]$。\n所以，$x_i$ 的计算公式为：\n$$ x_i = \\frac{1}{\\text{val}[\\text{diag\\_ind}[i]]} \\left( b_i - \\sum_{k=\\text{row\\_ptr}[i]}^{\\text{diag\\_ind}[i]-1} \\text{val}[k] \\cdot x_{\\text{col\\_ind}[k]} \\right) $$\n间接访问是求和式中的项 $x_{\\text{col\\_ind}[k]}$。这类项的数量等于行 $i$ 的严格下三角部分中非零元素的数量。\n设 $\\text{nnz}_i = \\text{row\\_ptr}[i+1] - \\text{row\\_ptr}[i]$ 为行 $i$ 中存储的非零元素总数。由于其中一个是对角线元素，因此有 $\\text{nnz}_i - 1$ 个严格下三角元素。每一个都需要一次间接内存访问。\n因此，行 $i$ 的间接访问次数恰好是 $\\text{nnz}_i - 1$。根据问题的定义，这不仅仅是一个界，而是一个精确的计数。因此，这个界是紧凑的。\n\n**情况A的界：**每行 $i$ 的间接访问次数为 $\\text{nnz}_i - 1$。\n\n**情况B的分析（隐式单位对角线）**\n在这种情况下，$A_{ii} = 1$ 是隐式的，并且只存储严格下三角的非零元素。求和 $\\sum_{j=0}^{i-1} A_{ij} x_j$ 现在涉及行 $i$ 的所有存储元素。\n这个和是 $\\sum_{j=0}^{i-1} A_{ij} x_j = \\sum_{k=\\text{row\\_ptr}[i]}^{\\text{row\\_ptr}[i+1]-1} \\text{val}[k] \\cdot x_{\\text{col\\_ind}[k]}$。\n$x_i$ 的计算简化为：\n$$ x_i = b_i - \\sum_{k=\\text{row\\_ptr}[i]}^{\\text{row\\_ptr}[i+1]-1} \\text{val}[k] \\cdot x_{\\text{col\\_ind}[k]} $$\n间接访问同样是项 $x_{\\text{col\\_ind}[k]}$。求和遍历行 $i$ 的所有存储元素。\n设 $\\text{nnz}_i = \\text{row\\_ptr}[i+1] - \\text{row\\_ptr}[i]$ 为行 $i$ 中存储的非零元素数量。由于所有存储的元素都在严格下三角部分，每个元素都会产生一次间接内存访问。\n因此，行 $i$ 的间接访问次数恰好是 $\\text{nnz}_i$。和之前一样，这是一个精确的计数，并且界是紧凑的。\n\n**情况B的界：**每行 $i$ 的间接访问次数为 $\\text{nnz}_i$。\n\n### 任务3和4：实现与验证\n\n实现将包含一个主函数，该函数遍历定义的测试用例。对于每个用例，它首先通过执行稀疏矩阵-向量乘积 $A x^{\\star}$ 来构造右端向量 $b$。然后，它调用一个专门的前向替换求解器。该求解器实现上面推导出的递推关系，从 $i = 0$到 $n-1$ 逐行处理。在计算每个 $x_i$ 的过程中，它将统计使用 `col_ind` 数组中索引的对解向量 $x$ 的查找次数，从而测量每行的间接访问计数 $m^{(t)}$。同时，根据对角线类型使用公式 $\\text{nnz}_i - 1$ 或 $\\text{nnz}_i$ 为每行计算理论界 $u^{(t)}$。最终输出将按照规定汇总所有测试用例的测量计数和理论界。计算出的解 $x$ 的正确性可以通过检查 $A x$ 是否在数值上接近原始的 $b$ 来验证。", "answer": "[[[0, 1, 2, 2, 2], [0, 1, 2, 2, 2]], [[0, 1, 2, 1, 2], [0, 1, 2, 1, 2]], [[0, 1, 2, 3, 0, 2], [0, 1, 2, 3, 0, 2]]]", "id": "3579221"}]}