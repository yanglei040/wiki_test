{"hands_on_practices": [{"introduction": "Golub-Kahan-Reinsch SVD 算法的第一个关键阶段是将输入矩阵简化为更易于处理的双对角形式。这个练习 [@problem_id:3588842] 将引导您亲身体验这一过程的核心机制，通过对一个具体矩阵逐步应用 Householder 反射变换。通过手动完成这些计算，您将对双对角化过程的底层工作原理建立起深刻的机械性理解。", "problem": "考虑在对实矩形矩阵应用 Golub–Kahan–Reinsch 奇异值分解 (SVD) 算法时出现的双对角化计算任务。设 $A \\in \\mathbb{R}^{4 \\times 3}$ 由下式给出\n$$\nA \\;=\\;\n\\begin{pmatrix}\n3  0  0 \\\\\n4  5  0 \\\\\n0  4  6 \\\\\n0  0  1\n\\end{pmatrix}.\n$$\n使用 Golub–Kahan–Reinsch 双对角化框架，对列相继应用左 Householder 反射，并对行相继应用右 Householder 反射，从而将矩阵 $A$ 变换为上双对角形式。在每个左变换步骤中，目标是将当前列的子向量变为相应基向量的非负倍数（即，在第 $i$ 步，将工作子向量映射到 $\\alpha_i \\, e_1$，其中 $\\alpha_i \\ge 0$）；在每个右变换步骤中，目标是将当前行的尾部子向量变为第一基方向的非负倍数（即，将工作子向量映射到 $\\beta_i \\, e_1$，其中 $\\beta_i \\ge 0$）。\n\n执行以下操作，并明确给出中间量：\n- 确定在双对角化过程中使用的左反射 $P_1$, $P_2$, $P_3$ 和右反射 $Q_1$, $Q_2$ 的 Householder 向量。\n- 根据已确定的 Householder 反射，写出乘积 $U_0 = P_1 P_2 P_3 \\in \\mathbb{R}^{4 \\times 4}$ 和 $V_0 = Q_1 Q_2 \\in \\mathbb{R}^{3 \\times 3}$。\n- 确定此过程产生的双对角矩阵 $B \\in \\mathbb{R}^{4 \\times 3}$，其对角线元素为 $\\alpha_1, \\alpha_2, \\alpha_3$，超对角线元素为 $\\beta_1, \\beta_2$。\n\n你的最终任务是一项计算：报告此过程产生的双对角矩阵 $B$ 的第三个对角线元素 $\\alpha_3$ 的精确值（不要四舍五入）。以单一的封闭形式解析表达式提供你的最终答案。无需四舍五入；给出精确表达式。", "solution": "用户要求我使用 Golub-Kahan-Reinsch SVD 算法框架对给定的 $4 \\times 3$ 矩阵 $A$ 进行双对角化。\n\n**问题分解：**\n1.  **输入：** 一个矩阵 $A \\in \\mathbb{R}^{4 \\times 3}$。\n    $$\n    A = \\begin{pmatrix}\n    3  0  0 \\\\\n    4  5  0 \\\\\n    0  4  6 \\\\\n    0  0  1\n    \\end{pmatrix}\n    $$\n2.  **过程：** 应用一系列 Householder 变换将 $A$ 转换为上双对角矩阵 $B$。变换序列为 $P_1, Q_1, P_2, Q_2, P_3$。\n    -   $P_i$ 是左反射（作用于列）。\n    -   $Q_i$ 是右反射（作用于行）。\n    -   左反射的目标是将一列的次对角线元素置零。目标向量是 $\\alpha_i e_1$，其中 $\\alpha_i \\ge 0$。\n    -   右反射的目标是将一行中超对角线右侧的元素置零。目标向量是 $\\beta_i e_1$，其中 $\\beta_i \\ge 0$。\n3.  **要求输出：**\n    -   $P_1, P_2, P_3$ 和 $Q_1, Q_2$ 的 Householder 向量。\n    -   $U_0 = P_1 P_2 P_3$ 和 $V_0 = Q_1 Q_2$ 的表达式。（这有点奇怪，通常我们有 $A = U B V^T$，所以 $U^T A V = B$。这里，变换的应用方式是 $P_3 P_2 P_1 A Q_1 Q_2 = B$。所以 $U^T = P_3 P_2 P_1$ 且 $V = Q_1 Q_2$。因此 $U = (P_3 P_2 P_1)^T = P_1^T P_2^T P_3^T = P_1 P_2 P_3$ 因为 Householder 反射是对称的。而 $V_0$ 就是 $V$。这看起来是正确的）。\n    -   最终的双对角矩阵 $B$。\n    -   $B$ 的第三个对角线元素 $\\alpha_3$ 的具体值。\n\n**验证步骤：**\n\n1.  **提取已知条件：**\n    -   矩阵 $A \\in \\mathbb{R}^{4 \\times 3}$:\n        $$ A = \\begin{pmatrix} 3  0  0 \\\\ 4  5  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix} $$\n    -   算法：Golub-Kahan-Reinsch 双对角化。\n    -   变换：相继的左 Householder 反射（$P_i$）和右 Householder 反射（$Q_i$）。\n    -   左反射的目标：对于子向量 $x$，将其映射到 $\\alpha e_1$，其中 $\\alpha \\ge 0$。\n    -   右反射的目标：对于子向量 $y$，将其映射到 $\\beta e_1$，其中 $\\beta \\ge 0$。\n    -   最终矩阵 $B$ 是上双对角矩阵。\n    -   $U_0 = P_1 P_2 P_3$。\n    -   $V_0 = Q_1 Q_2$。\n    -   $B$ 的对角线元素为 $\\alpha_1, \\alpha_2, \\alpha_3$，超对角线元素为 $\\beta_1, \\beta_2$。\n    -   最终任务：报告 $\\alpha_3$ 的精确值。\n\n2.  **使用提取的已知条件进行验证：**\n    -   **科学依据：** 该问题来自数值线性代数，具体涉及 SVD 算法。Golub-Kahan-Reinsch 双对角化是一个标准且成熟的过程。Householder 反射的使用是此过程的核心。该问题在数学上是合理的。\n    -   **良构性：** 矩阵已给出，过程已指定，要求的输出已明确定义。遵循指定的规则（基向量的非负倍数），将产生唯一的变换序列和唯一的结果矩阵 $B$。该问题是良构的。\n    -   **客观性：** 问题陈述精确，并使用了标准的数学术语。没有主观因素。\n    -   **缺陷检查清单：**\n        1.  没有科学/事实上的不合理之处。\n        2.  问题是可形式化的，并与主题直接相关。\n        3.  设置是完整的。维度和数值已给出。过程已定义。\n        4.  条件是数值算法的标准条件，并非物理上不可能。\n        5.  问题结构良好，并导向唯一的解。\n        6.  问题并非微不足道。它需要多个计算步骤。它不是同义反复的。\n        7.  问题可通过计算来验证。\n\n3.  **结论与行动：** 问题是**有效的**。我将继续进行解答。\n\n---\n**解题计划：**\n\n过程是 $B = P_3 P_2 P_1 A Q_1 Q_2$。\n\n**第 0 步：初始矩阵**\n$A^{(0)} = A = \\begin{pmatrix} 3  0  0 \\\\ 4  5  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix}$\n\n**第 1 步：第一次左变换 ($P_1$)**\n-   目标：第一列，$x_1 = (3, 4, 0, 0)^T$。我们想将其变换为 $\\alpha_1 e_1 \\in \\mathbb{R}^4$。\n-   Householder 反射定义：$P = I - 2 \\frac{vv^T}{v^T v}$。\n-   向量 $v$ 由 $v = x - \\sigma e_1$ 给出，其中 $\\sigma = -\\text{sgn}(x_1) \\|x\\|_2$。\n-   问题指定映射到 $e_1$ 的一个*非负*倍数，即 $\\alpha_1 e_1$ 且 $\\alpha_1 \\ge 0$。这是关于映射目标的直接指令。这意味着目标向量是 $y = \\|x\\|_2 e_1$，并且得到的对角线元素将是 $\\alpha = \\|x\\|_2 \\ge 0$。\n-   设 $x = \\begin{pmatrix} 3 \\\\ 4 \\\\ 0 \\\\ 0 \\end{pmatrix}$。$\\|x\\|_2 = \\sqrt{3^2 + 4^2 + 0^2 + 0^2} = \\sqrt{9+16} = 5$。\n-   目标向量是 $y = 5e_1 = (5, 0, 0, 0)^T$。因此，$\\alpha_1 = 5$。\n-   Householder 向量是 $v_1 = x - y = (3-5, 4, 0, 0)^T = (-2, 4, 0, 0)^T$。\n-   反射是 $P_1 = I_4 - 2 \\frac{v_1 v_1^T}{v_1^T v_1}$。我们计算 $v_1^T v_1 = (-2)^2 + 4^2 = 20$。\n-   $A^{(1)} = P_1 A = (I_4 - \\frac{1}{10} v_1 v_1^T)A = A - \\frac{1}{10} v_1 (v_1^T A)$。\n-   $v_1^T A = \\begin{pmatrix} -2  4  0  0 \\end{pmatrix} \\begin{pmatrix} 3  0  0 \\\\ 4  5  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} 10  20  0 \\end{pmatrix}$。\n-   $A^{(1)} = A - \\frac{1}{10} \\begin{pmatrix} -2 \\\\ 4 \\\\ 0 \\\\ 0 \\end{pmatrix} \\begin{pmatrix} 10  20  0 \\end{pmatrix} = \\begin{pmatrix} 3  0  0 \\\\ 4  5  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix} - \\begin{pmatrix} -2  -4  0 \\\\ 4  8  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 5  4  0 \\\\ 0  -3  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix}$。\n\n**第 2 步：第一次右变换 ($Q_1$)**\n-   该过程要求将 $j2$ 的元素 $a_{1,j}$ 置零。我们对行子向量 $A^{(1)}(1, 2:3) = \\begin{pmatrix} 4  0 \\end{pmatrix}$ 进行操作。\n-   设 $x_r^T = (4,0)$，一个 $\\mathbb{R}^2$ 中的向量。目标是将其映射到 $\\beta_1 e_1^T = (\\|x_r\\|_2, 0)$。\n-   $\\|x_r\\|_2 = \\sqrt{4^2+0^2} = 4$。所以 $\\beta_1 = 4$。\n-   目标是 $(4,0)$。该向量已经处于目标形式。变换是单位变换。\n-   用于 $2 \\times 2$ 反射 $Q_1'$ 的 Householder 向量是 $w_1 = (4,0)^T - 4(1,0)^T = (0,0)^T$。反射 $Q_1'$ 是 $I_2$。\n-   完整的 $3 \\times 3$ 反射是 $Q_1 = \\begin{pmatrix} 1  0 \\\\ 0  Q_1' \\end{pmatrix} = I_3$。\n-   $A^{(2)} = A^{(1)} Q_1 = A^{(1)} = \\begin{pmatrix} 5  4  0 \\\\ 0  -3  0 \\\\ 0  4  6 \\\\ 0  0  1 \\end{pmatrix}$。\n\n**第 3 步：第二次左变换 ($P_2$)**\n-   我们对子列 $A^{(2)}(2:4, 2) = (-3, 4, 0)^T$ 进行操作。\n-   设 $x_2 = (-3, 4, 0)^T \\in \\mathbb{R}^3$。目标是将其映射到 $\\alpha_2 e_1 = (\\|x_2\\|_2, 0, 0)^T$。\n-   $\\|x_2\\|_2 = \\sqrt{(-3)^2 + 4^2 + 0^2} = \\sqrt{9+16} = 5$。所以 $\\alpha_2 = 5$。\n-   目标是 $y_2 = (5, 0, 0)^T$。\n-   用于 $3 \\times 3$ 反射 $P_2'$ 的 Householder 向量是 $v_2' = x_2 - y_2 = (-3-5, 4, 0)^T = (-8, 4, 0)^T$。\n-   完整的 $4 \\times 4$ 反射是 $P_2 = \\text{diag}(1, P_2')$。定义向量是 $v_2 = (0,-8,4,0)^T$。\n-   为求得 $A^{(3)} = P_2 A^{(2)}$，我们将 $P_2'$ 应用于 $A^{(2)}(2:4, :) = \\begin{pmatrix} -3  0 \\\\ 4  6 \\\\ 0  1 \\end{pmatrix}$。\n-   该子矩阵的第一列是 $x_2$，它被映射到 $(5,0,0)^T$。\n-   为求得对第二列 $c = (0, 6, 1)^T$ 的影响，我们计算 $P_2' c = c - 2 \\frac{v_2'(v_2'^T c)}{v_2'^T v_2'}$。\n-   $v_2'^T v_2' = (-8)^2+4^2 = 80$。\n-   $v_2'^T c = (-8)(0) + (4)(6) + (0)(1) = 24$。\n-   $P_2' c = \\begin{pmatrix} 0 \\\\ 6 \\\\ 1 \\end{pmatrix} - 2\\frac{24}{80} \\begin{pmatrix} -8 \\\\ 4 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 6 \\\\ 1 \\end{pmatrix} - \\frac{3}{5} \\begin{pmatrix} -8 \\\\ 4 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 6 \\\\ 1 \\end{pmatrix} - \\begin{pmatrix} -24/5 \\\\ 12/5 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 24/5 \\\\ 18/5 \\\\ 1 \\end{pmatrix}$。\n-   所以 $A^{(3)} = \\begin{pmatrix} 5  4  0 \\\\ 0  5  24/5 \\\\ 0  0  18/5 \\\\ 0  0  1 \\end{pmatrix}$。\n\n**第 4 步：第二次右变换 ($Q_2$)**\n-   我们对行子向量 $A^{(3)}(2, 3:3) = (24/5)$ 进行操作。\n-   设 $x_{r2}^T = (24/5)$，一个 $\\mathbb{R}^1$ 中的向量。目标是将其映射到 $\\beta_2 e_1^T = (\\|x_{r2}\\|_2)$。\n-   $\\|x_{r2}\\|_2 = 24/5$。所以 $\\beta_2 = 24/5$。\n-   该向量已经处于目标形式。$1 \\times 1$ 反射 $Q_2'$ 是单位矩阵 $[1]$。\n-   Householder 向量是 $w_2 = (24/5) - (24/5) = 0$。\n-   完整的 $3 \\times 3$ 反射是 $Q_2 = \\text{diag}(1,1,1) = I_3$。\n-   $A^{(4)} = A^{(3)} Q_2 = A^{(3)}$。\n\n**第 5 步：第三次左变换 ($P_3$)**\n-   我们对子列 $A^{(4)}(3:4, 3) = (18/5, 1)^T$ 进行操作。\n-   设 $x_3 = (18/5, 1)^T \\in \\mathbb{R}^2$。目标是将其映射到 $\\alpha_3 e_1 = (\\|x_3\\|_2, 0)^T$。\n-   $\\|x_3\\|_2 = \\sqrt{(18/5)^2 + 1^2} = \\sqrt{\\frac{324}{25} + \\frac{25}{25}} = \\sqrt{\\frac{349}{25}} = \\frac{\\sqrt{349}}{5}$。\n-   第三个对角线元素是 $\\alpha_3 = \\frac{\\sqrt{349}}{5}$。\n\n这就是所要求的值。为了完整起见，我们列出所有需要的量。\n用于 $2 \\times 2$ 反射 $P_3'$ 的 Householder 向量是 $v_3' = (\\frac{18 - \\sqrt{349}}{5}, 1)^T$。\n矩阵 $P_3 = \\text{diag}(1,1,P_3')$ 应用于 $A^{(4)}$。\n子矩阵 $A^{(4)}(3:4,:)=\\begin{pmatrix} 0  0  18/5 \\\\ 0  0  1 \\end{pmatrix}$ 被 $P_3'$ 变换。前两列是零向量，保持不变。第三列变为 $(\\alpha_3, 0)^T$。\n得到的子矩阵是 $\\begin{pmatrix} 0  0  \\sqrt{349}/5 \\\\ 0  0  0 \\end{pmatrix}$。\n最终的双对角矩阵是 $B = P_3 A^{(4)} = \\begin{pmatrix} 5  4  0 \\\\ 0  5  \\frac{24}{5} \\\\ 0  0  \\frac{\\sqrt{349}}{5} \\\\ 0  0  0 \\end{pmatrix}$。\n\n\n**各量汇总**\n\n-   **Householder 向量：**\n    -   对于 $P_1$：$v_1 = (-2, 4, 0, 0)^T \\in \\mathbb{R}^4$。\n    -   对于 $P_2$：反射 $P_2'$ 作用于第 2,3,4 行的子空间。向量是 $v_2' = (-8, 4, 0)^T \\in \\mathbb{R}^3$。在 $\\mathbb{R}^4$ 中对应于 $P_2$ 的向量是 $v_2 = (0, -8, 4, 0)^T$。\n    -   对于 $P_3$：反射 $P_3'$ 作用于第 3,4 行。向量是 $v_3' = (\\frac{18 - \\sqrt{349}}{5}, 1)^T \\in \\mathbb{R}^2$。在 $\\mathbb{R}^4$ 中对应于 $P_3$ 的向量是 $v_3 = (0, 0, \\frac{18 - \\sqrt{349}}{5}, 1)^T$。\n    -   对于 $Q_1$：反射是单位矩阵。按惯例，Householder 向量是零向量 $w_1 = (0, 0, 0)^T \\in \\mathbb{R}^3$。\n    -   对于 $Q_2$：反射是单位矩阵。Householder 向量是 $w_2 = (0, 0, 0)^T \\in \\mathbb{R}^3$。\n\n-   **正交矩阵：**\n    -   $U_0 = P_1 P_2 P_3$，其中 $P_i = I - 2 \\frac{v_i v_i^T}{v_i^T v_i}$。\n    -   $V_0 = Q_1 Q_2 = I_3 I_3 = I_3$。\n\n-   **双对角矩阵 $B$：**\n    $$ B = \\begin{pmatrix} 5  4  0 \\\\ 0  5  \\frac{24}{5} \\\\ 0  0  \\frac{\\sqrt{349}}{5} \\\\ 0  0  0 \\end{pmatrix} $$\n    对角线元素为 $\\alpha_1=5, \\alpha_2=5, \\alpha_3 = \\frac{\\sqrt{349}}{5}$。超对角线元素为 $\\beta_1=4, \\beta_2=24/5$。\n\n问题要求第三个对角线元素 $\\alpha_3$ 的精确值。根据我们的计算，这个值是 $\\frac{\\sqrt{349}}{5}$。", "answer": "$$\\boxed{\\frac{\\sqrt{349}}{5}}$$", "id": "3588842"}, {"introduction": "正交变换拥有一个优美而关键的特性：它们能够保持数据的几何结构和“能量”（通过范数来衡量）。这个实践 [@problem_id:3588807] 挑战您从理论走向代码，要求您实现双对角化过程，并从数值上验证这一能量守恒原理。您将发现，理论上完美的正交性在面对有限精度计算机算法的实际情况时表现如何。", "problem": "设 $A \\in \\mathbb{R}^{m \\times n}$，并设 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 为正交矩阵。在 Golub–Kahan–Reinsch 算法中，奇异值分解 (SVD) 是通过一系列 Householder 反射（它们是正交变换）将 $A$ 约简为双对角形式来计算的。本问题要求您从第一性原理出发，论证 Frobenius 范数在正交变换下的不变性，并设计一个鲁棒的数值测试，以验证由 Golub–Kahan–Reinsch 式双对角化在有限精度算术中计算出的正交因子的此属性。您还必须诊断与精确正交性的偏差。\n\n任务：\n1) 理论推导。从 Frobenius 范数和正交矩阵的定义出发，并且仅使用迹的循环不变性等标准恒等式，证明对于正交的 $U$ 和 $V$，\n$$\\|A\\|_F = \\|U^\\top A V\\|_F.$$\n您的推导必须从定义 $\\|A\\|_F = \\sqrt{\\operatorname{trace}(A^\\top A)}$、正交性定义 $U^\\top U = I$ 和 $V^\\top V = I$、以及当乘积有定义时迹的循环性质 $\\operatorname{trace}(XYZ) = \\operatorname{trace}(ZXY)$ 开始。请勿使用任何未经证明的快捷恒等式。\n\n2) 数值实验设计。用双精度实现一个 Golub–Kahan–Reinsch 式的将 $A$ 约简为双对角形式的方法，使用 Householder 反射，并显式地累积左右正交因子 $\\hat{U}$ 和 $\\hat{V}$，使得计算出的双对角矩阵满足 $\\hat{B} \\approx \\hat{U}^\\top A \\hat{V}$。您的实现必须：\n- 从第一性原理构造 Householder 反射，以消去列中的次对角线元素（左反射）和行中的超对角线元素（右反射）。\n- 将每个反射应用于相应的尾随子矩阵，并将相应的变换累积到 $\\hat{U}$ 或 $\\hat{V}$ 中。\n- 使用双精度算术，并避免调用任何黑盒 SVD 例程。\n\n3) 能量保持测试与诊断。对于给定的输入矩阵 $A$，计算：\n- 相对 Frobenius 范数差异\n$$\\mathrm{rel\\_err} = \\frac{\\big|\\|A\\|_F - \\|\\hat{U}^\\top A \\hat{V}\\|_F\\big|}{\\max(\\|A\\|_F, 1)}.$$\n如果 $\\|A\\|_F = 0$，则定义 $\\mathrm{rel\\_err} = 0$。\n- 正交性缺陷\n$$\\mathrm{orthU} = \\|I - \\hat{U}^\\top \\hat{U}\\|_F, \\quad \\mathrm{orthV} = \\|I - \\hat{V}^\\top \\hat{V}\\|_F.$$\n使用双精度的单位舍入误差 $u$ 和接受阈值\n$$\\tau(m,n) = c \\, u \\, (m + n), \\quad c = 100.$$\n如果 $\\mathrm{rel\\_err} \\le \\tau(m,n)$，则判定该案例为通过（pass），否则为失败（fail）。此外，设计一个实验，通过向 $\\hat{U}$ 和 $\\hat{V}$ 各添加一个大小为 $\\delta$ 的稠密扰动，故意使其轻微非正交，并证明正交性缺陷和相对 Frobenius 范数差异的增加与扰动幅度相称。\n\n4) 测试套件。您的程序必须运行以下五个可复现的测试案例并汇总结果：\n- 案例 1（正常路径）：$m=50, n=30$，$A$ 的元素为独立的标准正态分布，种子为 $1$。\n- 案例 2（方阵）：$m=10, n=10$，$A$ 的元素为独立的标准正态分布，种子为 $2$。\n- 案例 3（零矩阵）：$m=20, n=15$，$A$ 为零矩阵。\n- 案例 4（病态）：$m=60, n=5$，构造 $A = U_0 \\Sigma V_0^\\top$，其中 $U_0 \\in \\mathbb{R}^{60 \\times 60}$ 和 $V_0 \\in \\mathbb{R}^{5 \\times 5}$ 是随机正交矩阵（分别通过对种子为 $3$ 和 $4$ 的高斯矩阵进行 $QR$ 分解生成），奇异值 $\\Sigma = \\operatorname{diag}(\\sigma_1,\\dots,\\sigma_5)$ 满足 $\\sigma_i = 10^{-12 \\cdot (i-1)/(5-1)}$，因此 $\\sigma_1 = 1$ 且 $\\sigma_5 = 10^{-12}$。\n- 案例 5（诊断性扰动）：$m=40, n=35$，$A$ 的元素为独立的标准正态分布，种子为 $5$。在计算出 $\\hat{U}$ 和 $\\hat{V}$ 后，将它们替换为 $\\tilde{U} = \\hat{U} + \\delta R_U$ 和 $\\tilde{V} = \\hat{V} + \\delta R_V$，其中 $R_U$ 和 $R_V$ 是形状相同、种子为 $6$ 的稠密高斯矩阵，且 $\\delta = 10^{-8}$。在此案例中，使用 $\\tilde{U}$ 和 $\\tilde{V}$ 进行度量。\n\n5) 要求的最终输出格式。您的程序应生成单行输出，包含一个逗号分隔的各案例结果列表，每个案例打印为一个方括号括起来的四元组 $[\\mathrm{rel\\_err},\\mathrm{orthU},\\mathrm{orthV},\\mathrm{pass}]$，其中如果案例通过，$\\mathrm{pass}$ 为 $1$，否则为 $0$。所有浮点数必须以科学记数法打印，小数点后保留 $16$ 位数字。该行中不得有任何空格。整个列表必须用方括号括起来。例如，包含两个案例的一行应如下所示：$[[1.2340000000000000e-10,2.0000000000000000e-15,2.0000000000000000e-15,1],[3.2100000000000000e-08,4.0000000000000000e-14,4.0000000000000000e-14,1]]$。\n\n您的程序必须是完全自包含的，且不得读取任何输入。它必须按所述实现双对角约简和正交累积，为指定的测试套件计算所需的度量，并以上述确切格式打印结果。", "solution": "该问题是有效的，因为它在科学上基于数值线性代数，问题定义明确、客观且自包含。它提出了一个标准但并非微不足道的任务，涉及理论证明、算法实现和数值分析。\n\n### 1) 理论推导\n\n目标是证明对于一个正交矩阵 $U \\in \\mathbb{R}^{m \\times m}$ 和一个正交矩阵 $V \\in \\mathbb{R}^{n \\times n}$，Frobenius 范数在变换 $A \\mapsto U^\\top A V$ 下是不变的，即 $\\|A\\|_F = \\|U^\\top A V\\|_F$。\n\n推导从给定的定义开始：\n1.  Frobenius 范数：$\\|X\\|_F = \\sqrt{\\operatorname{trace}(X^\\top X)}$。\n2.  正交性：$U^\\top U = I_m$ 且 $V^\\top V = I_n$。对于方阵 $Q$，$Q^\\top Q=I$ 意味着 $QQ^\\top=I$。\n3.  迹的循环性质：对于任何乘积有定义的矩阵 $X, Y, Z$，$\\operatorname{trace}(XYZ) = \\operatorname{trace}(ZXY)$。\n\n我们从分析变换后矩阵的范数平方 $\\|U^\\top A V\\|_F^2$ 开始。\n\n使用 Frobenius 范数的定义：\n$$ \\|U^\\top A V\\|_F^2 = \\operatorname{trace}\\left((U^\\top A V)^\\top (U^\\top A V)\\right) $$\n\n乘积的转置 $(XYZ)^\\top$ 是 $Z^\\top Y^\\top X^\\top$。应用此规则：\n$$ (U^\\top A V)^\\top = V^\\top A^\\top (U^\\top)^\\top $$\n因为对于任何矩阵 $X$，$(X^\\top)^\\top = X$，所以我们有 $(U^\\top)^\\top = U$。该表达式变为：\n$$ (U^\\top A V)^\\top = V^\\top A^\\top U $$\n将此代回迹的表达式中：\n$$ \\|U^\\top A V\\|_F^2 = \\operatorname{trace}\\left((V^\\top A^\\top U) (U^\\top A V)\\right) $$\n\n矩阵 $U$ 和 $U^\\top$ 相邻。因为 $U$ 是一个正交矩阵，所以 $U U^\\top = I_m$。\n$$ \\|U^\\top A V\\|_F^2 = \\operatorname{trace}\\left(V^\\top A^\\top (U U^\\top) A V\\right) = \\operatorname{trace}\\left(V^\\top A^\\top I_m A V\\right) = \\operatorname{trace}\\left(V^\\top A^\\top A V\\right) $$\n\n现在，我们通过设 $X = V^\\top$，$Y = A^\\top A$ 和 $Z = V$ 来应用迹的循环性质 $\\operatorname{trace}(XYZ) = \\operatorname{trace}(ZXY)$。\n$$ \\operatorname{trace}\\left( (V^\\top) (A^\\top A) (V) \\right) = \\operatorname{trace}\\left( (V) (V^\\top) (A^\\top A) \\right) $$\n\n因为 $V$ 是一个正交矩阵，所以 $V V^\\top = I_n$。\n$$ \\|U^\\top A V\\|_F^2 = \\operatorname{trace}\\left(I_n (A^\\top A)\\right) = \\operatorname{trace}(A^\\top A) $$\n\n根据 Frobenius 范数的定义，$\\operatorname{trace}(A^\\top A) = \\|A\\|_F^2$。\n因此，我们证明了：\n$$ \\|U^\\top A V\\|_F^2 = \\|A\\|_F^2 $$\n\n由于 Frobenius 范数根据定义是非负的，我们可以对两边取平方根得到最终结果：\n$$ \\|U^\\top A V\\|_F = \\|A\\|_F $$\n证明完毕。\n\n### 2) 数值实验设计与实现\n\n用于矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 双对角化的 Golub-Kahan-Reinsch 算法通过从左侧和右侧应用一系列 Householder 变换，来消去主对角线下方的元素和第一超对角线上方的元素。\n\n一个 Householder 变换由一个反射矩阵 $H = I - 2vv^\\top$ 定义，其中 $v$ 是一个单位向量。对于给定的向量 $x$，可以选择向量 $v$ 使得 $Hx$ 是标准基向量 $e_1$ 的倍数。对于（未归一化的）Householder 向量，一个数值稳定的选择是 $v' = x + \\operatorname{sgn}(x_1) \\|x\\|_2 e_1$。然后将此向量归一化，$v = v'/\\|v'\\|_2$。\n\n双对角化算法如下：\n设 $A^{(0)} = A$。我们对 $k = 0, 1, \\dots, \\min(m, n)-1$ 进行迭代。\n\n1.  **左反射（列消元）**：构造一个 Householder 变换 $U_k'$，以消去当前矩阵 $A^{(k-1)}$ 的第 $k$ 列的次对角线元素。该反射作用于第 $k$ 行到第 $m-1$ 行。完整的变换 $U_k$ 是将 $U_k'$ 嵌入到一个 $m \\times m$ 的单位矩阵中。\n    $$ A^{(k-1/2)} = U_k A^{(k-1)} $$\n2.  **右反射（行消元）**：如果 $k  n-2$，构造一个 Householder 变换 $V_k'$，以消去第 $k$ 行中从第 $k+2$ 列开始的元素。该反射作用于第 $k+1$ 列到第 $n-1$ 列。完整的变换 $V_k$ 是将 $V_k'$ 嵌入到一个 $n \\times n$ 的单位矩阵中。\n    $$ A^{(k)} = A^{(k-1/2)} V_k $$\n\n最终的双对角矩阵为 $\\hat{B} \\approx A^{(\\min(m,n))}$。累积的正交矩阵为 $\\hat{U} = U_0 U_1 \\dots$ 和 $\\hat{V} = V_0 V_1 \\dots$。实现将通过将 $\\hat{U}$ 和 $\\hat{V}$ 初始化为单位矩阵并在每一步应用变换来显式构造它们。\n\n### 3) 能量保持测试与诊断\n\n理论证明表明，对于精确的正交矩阵 $\\hat{U}$ 和 $\\hat{V}$，Frobenius 范数是完全保持不变的。在有限精度算术中，$\\hat{U}$ 和 $\\hat{V}$ 将仅是近似正交的，导致范数出现微小差异。\n\n量化此行为的度量是：\n-   **相对 Frobenius 范数差异**：这衡量了矩阵“能量”的变化，并用原始能量进行归一化。\n    $$ \\mathrm{rel\\_err} = \\frac{\\big|\\|A\\|_F - \\|\\hat{U}^\\top A \\hat{V}\\|_F\\big|}{\\max(\\|A\\|_F, 1)} $$\n    分母项 $\\max(\\|A\\|_F, 1)$ 防止了除以零，并为小范数矩阵提供了一个合理的相对误差。\n-   **正交性缺陷**：这衡量了计算出的因子 $\\hat{U}$ 和 $\\hat{V}$ 与完全正交的接近程度。\n    $$ \\mathrm{orthU} = \\|I - \\hat{U}^\\top \\hat{U}\\|_F, \\quad \\mathrm{orthV} = \\|I - \\hat{V}^\\top \\hat{V}\\|_F $$\n    对于完全正交的矩阵，这些缺陷将为零。在实践中，它们应该在机器精度乘以某个与矩阵维度相关的因子的数量级上。\n\n接受阈值 $\\tau(m,n) = c \\, u \\, (m + n)$，其中 $c=100$，$u$ 为双精度单位舍入误差，为稳定算法的预期相对误差提供了一个合理的界限。如果 $\\mathrm{rel\\_err} \\le \\tau(m,n)$，则声明为通过（pass）。\n\n案例 5 中的诊断测试通过添加一个小的随机扰动，故意向 $\\hat{U}$ 和 $\\hat{V}$ 引入非正交性。预计这会增加正交性缺陷和 Frobenius 范数差异，从而证明它们对正交性损失的敏感性。`orthU` 和 `orthV` 的量级预计将与扰动大小 $\\delta$ 大致成比例，而 `rel_err` 预计将显著增加，可能导致测试失败。", "answer": "```python\nimport numpy as np\n\ndef bidiagonalize(A_in):\n    \"\"\"\n    Performs Golub-Kahan-Reinsch bidiagonalization of a matrix A.\n\n    Args:\n        A_in (np.ndarray): The m x n matrix to bidiagonalize.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: The accumulated orthogonal matrices U (m x m) and V (n x n).\n    \"\"\"\n    m, n = A_in.shape\n    A = A_in.copy().astype(float)\n    U = np.eye(m, dtype=float)\n    V = np.eye(n, dtype=float)\n\n    for k in range(min(m, n)):\n        # Left (column) reflector to annihilate A[k+1:m, k]\n        # v is constructed from the k-th column of the trailing submatrix\n        x = A[k:m, k].copy()\n        norm_x = np.linalg.norm(x)\n\n        if norm_x > 0:\n            s_sign = np.copysign(1.0, x[0]) if x[0] != 0.0 else 1.0\n            s = s_sign * norm_x\n            x[0] += s\n            norm_v = np.linalg.norm(x)\n            if norm_v > 0:\n                v = x / norm_v\n\n                # Apply transformation to the trailing submatrix of A\n                sub_A = A[k:m, k:n]\n                sub_A -= 2 * np.outer(v, v.T @ sub_A)\n\n                # Accumulate transformation in U\n                sub_U = U[:, k:m]\n                sub_U -= 2 * np.outer(sub_U @ v, v.T)\n\n        # Right (row) reflector to annihilate A[k, k+2:n]\n        if k  n - 2:\n            # w is constructed from the k-th row of the trailing submatrix\n            y = A[k, k+1:n].copy()\n            norm_y = np.linalg.norm(y)\n\n            if norm_y > 0:\n                s_sign = np.copysign(1.0, y[0]) if y[0] != 0.0 else 1.0\n                s = s_sign * norm_y\n                y[0] += s\n                norm_w = np.linalg.norm(y)\n                if norm_w > 0:\n                    w = y / norm_w\n\n                    # Apply transformation to the trailing submatrix of A\n                    sub_A = A[k:m, k+1:n]\n                    sub_A -= 2 * np.outer(sub_A @ w, w.T)\n                    \n                    # Accumulate transformation in V\n                    sub_V = V[:, k+1:n]\n                    sub_V -= 2 * np.outer(sub_V @ w, w.T)\n\n    return U, V\n\ndef run_test_case(m, n, A_generator, seeds):\n    \"\"\"\n    Sets up and runs a single test case.\n\n    Args:\n        m (int): Number of rows.\n        n (int): Number of columns.\n        A_generator (str): Method to generate matrix A.\n        seeds (dict): Seeds for random number generation.\n\n    Returns:\n        list: A list containing [rel_err, orthU, orthV, is_pass].\n    \"\"\"\n    # 1. Generate matrix A based on case description\n    if A_generator == 'normal':\n        rng = np.random.default_rng(seeds['A'])\n        A = rng.standard_normal((m, n))\n    elif A_generator == 'zero':\n        A = np.zeros((m, n))\n    elif A_generator == 'ill-cond':\n        rng_U = np.random.default_rng(seeds['U0'])\n        rand_U = rng_U.standard_normal((m, m))\n        U0, _ = np.linalg.qr(rand_U)\n        \n        rng_V = np.random.default_rng(seeds['V0'])\n        rand_V = rng_V.standard_normal((n, n))\n        V0, _ = np.linalg.qr(rand_V)\n        \n        num_sv = min(m, n)\n        sigma_vals = [10.0**(-12.0 * i / (num_sv - 1)) for i in range(num_sv)]\n        Sigma = np.zeros((m, n))\n        np.fill_diagonal(Sigma, sigma_vals)\n        A = U0 @ Sigma @ V0.T\n    \n    # 2. Perform bidiagonalization\n    U_hat, V_hat = bidiagonalize(A)\n\n    # 3. Handle diagnostic perturbation (Case 5)\n    if 'perturb' in seeds:\n        delta = 1e-8\n        rng_pert = np.random.default_rng(seeds['perturb'])\n        R_U = rng_pert.standard_normal((m, m))\n        R_V = rng_pert.standard_normal((n, n))\n        U_hat += delta * R_U\n        V_hat += delta * R_V\n        \n    # 4. Compute metrics\n    norm_A_F = np.linalg.norm(A, 'fro')\n    \n    transformed_A = U_hat.T @ A @ V_hat\n    norm_transformed_A_F = np.linalg.norm(transformed_A, 'fro')\n    \n    if norm_A_F == 0.0:\n        rel_err = 0.0\n    else:\n        rel_err = abs(norm_A_F - norm_transformed_A_F) / max(norm_A_F, 1.0)\n        \n    orthU = np.linalg.norm(np.eye(m) - U_hat.T @ U_hat, 'fro')\n    orthV = np.linalg.norm(np.eye(n) - V_hat.T @ V_hat, 'fro')\n\n    # 5. Evaluate pass/fail criterion\n    u = np.finfo(float).eps / 2.0\n    c = 100.0\n    tau = c * u * (m + n)\n    is_pass = 1 if rel_err = tau else 0\n    \n    return [rel_err, orthU, orthV, is_pass]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'m': 50, 'n': 30, 'gen': 'normal', 'seeds': {'A': 1}},\n        {'m': 10, 'n': 10, 'gen': 'normal', 'seeds': {'A': 2}},\n        {'m': 20, 'n': 15, 'gen': 'zero',   'seeds': {}},\n        {'m': 60, 'n': 5,  'gen': 'ill-cond', 'seeds': {'U0': 3, 'V0': 4}},\n        {'m': 40, 'n': 35, 'gen': 'normal', 'seeds': {'A': 5, 'perturb': 6}},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(case['m'], case['n'], case['gen'], case['seeds'])\n        results.append(result)\n\n    result_strings = []\n    for res in results:\n        rel_err, orthU, orthV, is_pass = res\n        s = f\"[{rel_err:.16e},{orthU:.16e},{orthV:.16e},{is_pass}]\"\n        result_strings.append(s)\n\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3588807"}, {"introduction": "为什么 GKR 算法在其迭代阶段要采用复杂的位移策略？这个动手实践 [@problem_id:3588808] 通过让您构建一个特殊的“对抗性”矩阵来回答这个问题，该矩阵会使朴素的 QR 迭代收敛速度变得极其缓慢。通过实现并观察这种缓慢的收敛过程，您将深刻体会到那些使现代 SVD 算法兼具速度和鲁棒性的设计选择的重要性。", "problem": "考虑通过 Golub-Kahan-Reinsch (GKR) 算法计算的奇异值分解 (SVD)，该算法首先将矩阵约简为双对角形式，然后应用隐式正交变换来获得奇异值。在本问题中，构造一个下双对角矩阵 $B \\in \\mathbb{R}^{n \\times n}$，其对角线元素构成一个几何级数，该级数设计为对朴素的、无位移的迭代具有对抗性，并量化次对角线衰减随几何比率变化的减慢程度。\n\n设 $B$ 是一个具有正元素的下双对角矩阵，其对角线元素 $d_i$ 和次对角线元素 $s_i$ 定义如下\n$$\nd_i = \\rho^{\\,i-1}, \\quad s_i = \\begin{cases}\n0  \\text{若 } i = 1, \\\\\n\\gamma \\, d_i  \\text{若 } i \\ge 2,\n\\end{cases}\n$$\n其中 $n \\ge 2$ 是一个固定的值，几何比率 $\\rho \\in (0,1)$，耦合因子 $\\gamma \\in (0,1)$。令 $T = B^\\top B$；则 $T$ 是对称三对角矩阵，其对角线元素为\n$$\nt_i = d_i^2 + s_{i+1}^2 \\quad \\text{对于 } i=1,\\dots,n-1, \\quad t_n = d_n^2,\n$$\n次对角线元素为\n$$\nz_i = s_{i+1} d_{i+1} = \\gamma \\, d_{i+1}^2 \\quad \\text{对于 } i=1,\\dots,n-1.\n$$\n我们将朴素迭代定义为应用于 $T$ 的无位移对称正交 QR 迭代，即，在每一步中对 $T$ 执行标准的、不带任何位移的 QR 分解，并更新 $T \\leftarrow RQ$。已知当特征值高度聚集时，该迭代收敛缓慢，而在上述构造中，当 $\\rho$ 接近 1 时就会发生这种情况。\n\n你的任务是：\n1. 根据给定的参数 $(n,\\rho,\\gamma)$ 构造矩阵 $B$ 并形成 $T = B^\\top B$。\n2. 对 $T$ 实现无位移对称 QR 迭代，重复应用 $T \\leftarrow RQ$，直到 $T$ 的次对角线元素的最大绝对值（即 $\\max_{i} |T_{i+1,i}|$）低于预设的容差 $\\tau$，或达到最大迭代次数 $k_{\\max}$。\n3. 对于每个测试用例，返回实际执行的迭代次数 $k$（一个整数）。如果在 $k_{\\max}$ 次迭代内未达到容差，则返回 $k_{\\max}$。\n\n通过数值证据，展示在这种对抗性构造下，迭代次数如何随比率 $\\rho = d_i/d_{i+1}$ 变化。使用以下参数值测试套件，每个测试指定为 $(n,\\rho,\\gamma,\\tau,k_{\\max})$：\n- 测试 1：$(n,\\rho,\\gamma,\\tau,k_{\\max}) = (\\,12,\\,0.5,\\,0.3,\\,10^{-12},\\,5000\\,)$\n- 测试 2：$(n,\\rho,\\gamma,\\tau,k_{\\max}) = (\\,12,\\,0.9,\\,0.3,\\,10^{-12},\\,5000\\,)$\n- 测试 3：$(n,\\rho,\\gamma,\\tau,k_{\\max}) = (\\,12,\\,0.99,\\,0.3,\\,10^{-12},\\,12000\\,)$\n- 测试 4：$(n,\\rho,\\gamma,\\tau,k_{\\max}) = (\\,12,\\,0.995,\\,0.3,\\,10^{-10},\\,12000\\,)$\n- 边界测试 5（强调末尾的 $2\\times 2$ 块）：$(n,\\rho,\\gamma,\\tau,k_{\\max}) = (\\,2,\\,0.999,\\,0.3,\\,10^{-12},\\,50000\\,)$\n\n所有量均为无量纲；不涉及物理单位。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[k_1,k_2,k_3,k_4,k_5]$），其中 $k_j$ 是测试 $j$ 的迭代次数。", "solution": "### 解决方案\n\n目标是数值上展示无位移对称 QR 算法在应用于一类其特征值日益聚集的三对角矩阵时的性能下降情况。这个问题对于理解在现代 SVD 和特征值算法（如 Golub-Kahan-Reinsch (GKR) SVD 算法）中采用位移策略的必要性至关重要。\n\n核心原理是，应用于对称矩阵 $T$ 的无位移 QR 算法的收敛速率取决于其特征值 $\\lambda_i$ 的比率。具体来说，经过 $k$ 次迭代后，次对角线元素 $T_{n, n-1}$ 以与 $(\\lambda_n / \\lambda_{n-1})^k$ 成正比的速率收敛到零。如果特征值聚集，即对于不同的 $i$ 和 $j$，有 $\\lambda_i / \\lambda_j \\approx 1$，那么收敛将会非常缓慢。\n\n**1. 矩阵构造与特征值聚集**\n\n我们的任务是构造一个对称三对角矩阵 $T$，其形式为 $T = B^\\top B$，其中 $B$ 是一个特殊设计的下双对角矩阵。$B$ 的元素由以下公式给出：\n- 对角线：$d_i = \\rho^{i-1}$，对于 $i \\in \\{1, \\dots, n\\}$\n- 次对角线：$s_i = \\gamma d_i$，对于 $i \\in \\{2, \\dots, n\\}$（且 $s_1=0$）\n\n根据这些定义，对称三对角矩阵 $T = B^\\top B$ 的元素推导如下：\n- 对角线 $t_i$：\n$$ t_i = d_i^2 + s_{i+1}^2 = (\\rho^{i-1})^2 + (\\gamma d_{i+1})^2 = \\rho^{2(i-1)} + \\gamma^2(\\rho^i)^2 = \\rho^{2(i-1)}(1 + \\gamma^2\\rho^2), \\quad i \\in \\{1, \\dots, n-1\\} $$\n$$ t_n = d_n^2 = (\\rho^{n-1})^2 = \\rho^{2(n-1)} $$\n- 次对角线 $z_i$：\n$$ z_i = s_{i+1}d_{i+1} = (\\gamma d_{i+1})d_{i+1} = \\gamma d_{i+1}^2 = \\gamma (\\rho^i)^2 = \\gamma\\rho^{2i}, \\quad i \\in \\{1, \\dots, n-1\\} $$\n\n关键的洞见是，当几何比率 $\\rho \\to 1$ 时，$T$ 的特征值会变得聚集。我们可以使用 Gershgorin 圆盘定理来证明这一点。对于对称矩阵，所有特征值都是实数。该定理指出，每个特征值都位于至少一个 Gershgorin 圆盘 $G_i$ 内，该圆盘以对角线元素 $t_i$ 为中心，半径 $R_i$ 等于该行非对角线元素绝对值之和。对于我们的矩阵 $T$：\n- 圆盘 $i$ 的中心：$C_i = t_i = \\rho^{2(i-1)}(1 + \\gamma^2\\rho^2)$\n- 圆盘 $i$ 的半径：$R_i = |z_{i-1}| + |z_i| = \\gamma\\rho^{2(i-1)} + \\gamma\\rho^{2i} = \\gamma\\rho^{2(i-1)}(1+\\rho^2)$（对于 $i=1$ 和 $i=n$ 需特殊处理）\n\n当 $\\rho \\to 1$ 时，我们有：\n$$ \\lim_{\\rho \\to 1} C_i = 1+\\gamma^2 $$\n$$ \\lim_{\\rho \\to 1} R_i = 2\\gamma $$\n所有的 Gershgorin 圆盘都集中在几乎相同的值 $1+\\gamma^2$ 附近。对于 $\\rho, \\gamma \\in (0,1)$，矩阵 $T$ 是严格对角占优的，因为 $t_i  R_i$ 等价于 $1+\\gamma^2\\rho^2  \\gamma(1+\\rho^2)$，这可以简化为 $(1-\\gamma)^2 + \\gamma^2(1-\\rho^2) + \\gamma(\\rho-1)^2  0$，此条件成立。这种对角占优性意味着特征值位于对角线元素附近。由于当 $\\rho \\to 1$ 时，对角线元素 $t_i$ 聚集在 $1+\\gamma^2$ 附近，因此 $T$ 的特征值也必定聚集，从而导致无位移 QR 算法收敛缓慢。\n\n**2. 算法流程**\n\n算法按以下步骤进行：\n- **初始化**：给定参数 $(n, \\rho, \\gamma)$，构造初始的对称三对角矩阵 $T^{(0)} = T$。设置迭代计数器 $k=0$。\n- **迭代循环**：对于 $k = 0, 1, 2, \\dots, k_{\\max}-1$：\n    a. **收敛性检查**：计算当前迭代矩阵 $T^{(k)}$ 的最大次对角线元素的大小，即 $m_k = \\max_{i} |T^{(k)}_{i+1,i}|$。如果 $m_k  \\tau$，算法已收敛。终止循环并返回当前迭代次数 $k$。\n    b. **QR 步骤**：对当前矩阵执行 QR 分解，$T^{(k)} = Q^{(k)}R^{(k)}$。\n    c. **更新**：通过反转乘法顺序形成下一个迭代矩阵：$T^{(k+1)} = R^{(k)}Q^{(k)}$。这构成一次完整的迭代。\n- **终止**：如果循环完成而未满足收敛准则（即 $k$ 达到 $k_{\\max}$），则返回 $k_{\\max}$。\n\n从 $T^{(k)}$ 到 $T^{(k+1)}$ 的变换是一个相似变换，$T^{(k+1)} = (Q^{(k)})^\\top T^{(k)} Q^{(k)}$，它保持了矩阵的特征值和对称三对角结构。实现将使用库函数进行 QR 分解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    # Test cases defined as (n, rho, gamma, tau, k_max)\n    test_cases = [\n        (12, 0.5,   0.3, 1e-12, 5000),\n        (12, 0.9,   0.3, 1e-12, 5000),\n        (12, 0.99,  0.3, 1e-12, 12000),\n        (12, 0.995, 0.3, 1e-10, 12000),\n        (2,  0.999, 0.3, 1e-12, 50000),\n    ]\n\n    results = []\n    for params in test_cases:\n        iterations = run_qr_iterations(*params)\n        results.append(iterations)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_qr_iterations(n, rho, gamma, tau, k_max):\n    \"\"\"\n    Constructs the tridiagonal matrix T and runs the unshifted QR algorithm.\n\n    Args:\n        n (int): The dimension of the matrix.\n        rho (float): The geometric ratio for diagonal entries of B.\n        gamma (float): The coupling factor for subdiagonal entries of B.\n        tau (float): The convergence tolerance.\n        k_max (int): The maximum number of iterations.\n\n    Returns:\n        int: The number of iterations performed.\n    \"\"\"\n    # 1. Construct the symmetric tridiagonal matrix T\n    T = np.zeros((n, n), dtype=float)\n\n    # Populate the main diagonal t_i\n    i_vals = np.arange(1, n, dtype=float)\n    diag_entries = (rho**(2 * (i_vals - 1))) * (1 + (gamma**2) * (rho**2))\n    T[np.arange(n - 1), np.arange(n - 1)] = diag_entries\n    T[n - 1, n - 1] = rho**(2 * (n - 1))\n\n    # Populate the subdiagonal and superdiagonal z_i\n    if n > 1:\n        i_vals_sub = np.arange(1, n, dtype=float)\n        subdiag_entries = gamma * (rho**(2 * i_vals_sub))\n        T[np.arange(1, n), np.arange(n - 1)] = subdiag_entries\n        T[np.arange(n - 1), np.arange(1, n)] = subdiag_entries\n\n    # 2. Implement the unshifted symmetric QR iteration\n    k = 0\n    while k  k_max:\n        # Check convergence criterion\n        if n > 1:\n            # np.diag(T, k=-1) extracts the first subdiagonal\n            max_subdiag = np.max(np.abs(np.diag(T, k=-1)))\n            if max_subdiag  tau:\n                return k\n        else: # For n=1, matrix is a scalar, already diagonal\n            return 0\n\n        # Perform one step of QR iteration\n        # T_k = Q_k * R_k\n        Q, R = qr(T)\n        # T_{k+1} = R_k * Q_k\n        T = R @ Q\n        \n        k += 1\n\n    # If the loop finishes without converging, return k_max\n    return k_max\n\nsolve()\n```", "id": "3588808"}]}