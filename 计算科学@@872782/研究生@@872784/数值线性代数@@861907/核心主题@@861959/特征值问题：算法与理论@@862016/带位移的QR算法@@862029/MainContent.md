## 引言
[特征值问题](@entry_id:142153)是科学与工程计算的基石，它揭示了[线性系统](@entry_id:147850)的内在特性，如[振动频率](@entry_id:199185)、系统稳定性或量子能级。在众多求解[特征值](@entry_id:154894)的数值方法中，[QR算法](@entry_id:145597)因其卓越的稳定性和可靠性而脱颖而出，成为现代计算软件的核心。然而，基础的[QR算法](@entry_id:145597)存在一个显著的瓶颈：其收敛速度通常是线性的，对于大规模或复杂的现实问题而言，这往往意味着无法接受的计算时间。

为了克服这一局限，**[带位移的QR算法](@entry_id:149245)（shifted QR algorithm）** 应运而生。通过在每次迭代中引入一个精心选择的“位移”参数，该算法能够戏剧性地将收敛速度从线性提升至二次甚至三次，从而彻底改变了[特征值计算](@entry_id:145559)的效率。本文旨在系统性地剖析这一强大的数值技术。

在接下来的章节中，你将踏上一段从理论到实践的深度探索之旅。在“**原理与机制**”一章，我们将揭示位移如何通过与[反幂法](@entry_id:148185)的深刻联系来加速收敛，并详细介绍各种实用的位移策略，如瑞利商位移、[Wilkinson位移](@entry_id:634015)，以及用于处理复数[特征值](@entry_id:154894)的精妙的Francis双步位移法和“凸起追逐”技术。随后，在“**应用与跨学科连接**”一章，我们将展示该算法如何超越纯数学的范畴，成为解决固体力学、控制理论、数据科学等领域实际问题的关键工具。最后，通过“**动手实践**”部分，你将有机会亲手演练算法的核心步骤，将理论知识转化为扎实的计算技能。

## 原理与机制

在介绍篇中，我们已经了解了[QR算法](@entry_id:145597)作为一种强大的[特征值计算](@entry_id:145559)工具的基本概念。本章将深入探讨其核心原理与机制，重点关注通过引入“位移”策略来显著[提升算法](@entry_id:635795)性能的“[带位移的QR算法](@entry_id:149245)”。我们将从位移的基本动机出发，系统性地揭示其加速收敛的深层机理，并详细阐述在实际应用中至关重要的各种实用策略，包括处理复数[特征值](@entry_id:154894)、隐式实现以及确保[算法稳健性](@entry_id:635315)的高级技术。

### 通过位移加速收敛

标准的[QR算法](@entry_id:145597)（或称[无位移QR算法](@entry_id:756287)）通过迭代地进行[QR分解](@entry_id:139154)与矩阵乘法重组，将原矩阵$A$转化为一系列正交相似的矩阵序列$\{A_k\}$。具体而言，其迭代步骤为：
1.  初始化 $A_0 = A$。
2.  对 $k=0, 1, 2, \dots$，计算QR分解 $A_k = Q_k R_k$。
3.  定义下一个矩阵 $A_{k+1} = R_k Q_k$。

由于 $R_k = Q_k^{\top} A_k$，我们有 $A_{k+1} = Q_k^{\top} A_k Q_k$。这表明每次迭代都是一次正交[相似变换](@entry_id:152935)，因此矩阵序列$\{A_k\}$中的所有矩阵都与初始矩阵$A$具有完全相同的[特征值](@entry_id:154894)。在一定条件下，该序列会收敛到一个[上三角矩阵](@entry_id:150931)（或[实舒尔形式](@entry_id:190856)），其对角线元素即为$A$的[特征值](@entry_id:154894)。然而，[无位移QR算法](@entry_id:756287)的收敛速度通常是线性的，对于许多实际问题而言过慢。

为了克服这一瓶颈，**[带位移的QR算法](@entry_id:149245)（shifted QR algorithm）** 应运而生。其迭代步骤稍作修改：
1.  在第$k$步，选择一个标量位移参数 $\sigma_k$。
2.  对位移后的矩阵进行[QR分解](@entry_id:139154)：$A_k - \sigma_k I = Q_k R_k$。
3.  通过 $A_{k+1} = R_k Q_k + \sigma_k I$ 更新矩阵。

与无位移版本类似，我们同样可以证明这仍是一个正交相似变换：
$A_{k+1} = R_k Q_k + \sigma_k I = Q_k^{\top}(A_k - \sigma_k I)Q_k + \sigma_k I = Q_k^{\top}A_k Q_k - \sigma_k Q_k^{\top}I Q_k + \sigma_k I = Q_k^{\top}A_k Q_k$。
因此，位移的引入并未改变算法保持[特征值](@entry_id:154894)不变的基本性质。

那么，引入位移$\sigma_k$的根本动机是什么呢？其核心目的在于**极大地加速算法的[收敛速度](@entry_id:636873)** ([@problem_id:1397742])。通过精心选择位移$\sigma_k$，算法可以从[线性收敛](@entry_id:163614)提升至二次甚至[三次收敛](@entry_id:168106)。这意味着找到一个[特征值](@entry_id:154894)所需的迭代次数将大幅减少。其他关于位移的猜想，例如确保[矩阵可逆性](@entry_id:152978)、处理复数[特征值](@entry_id:154894)或改变算法目标等，均非其主要动机。QR分解本身对[矩阵可逆性](@entry_id:152978)没有要求，而处理复数[特征值](@entry_id:154894)有更专门的策略（如双步位移法），位移本身也并未改变算法求解[特征值](@entry_id:154894)的根本目标。

### 加速收敛的内在机理：与[反幂法](@entry_id:148185)的联系

要理解位移为何能加速收敛，我们需要探究其更深层次的数学原理。其关键在于，[带位移的QR算法](@entry_id:149245)与一种称为**[反幂法](@entry_id:148185)（inverse iteration）** 的方法有着深刻的内在联系 ([@problem_id:3597289])。

[反幂法](@entry_id:148185)是一种用于寻找矩阵最接近给定值$\sigma$的[特征值](@entry_id:154894)及其对应[特征向量](@entry_id:151813)的迭代方法。其核心思想是，若$\lambda_j$是矩阵$A$的一个[特征值](@entry_id:154894)，那么$(A - \sigma I)^{-1}$的[特征值](@entry_id:154894)为$1/(\lambda_j - \sigma)$。如果位移$\sigma$非常接近某个[特征值](@entry_id:154894)$\lambda_j$，那么$|\lambda_j - \sigma|$将是一个非常小的数，从而使得$1/|\lambda_j - \sigma|$成为$(A - \sigma I)^{-1}$在所有[特征值](@entry_id:154894)中[绝对值](@entry_id:147688)最大的一个。对任意向量进行迭代乘以$(A - \sigma I)^{-1}$，根据幂法原理，迭代结果将迅速向[绝对值](@entry_id:147688)最大[特征值](@entry_id:154894)（即$1/(\lambda_j - \sigma)$）所对应的[特征向量](@entry_id:151813)方向收敛，而这个[特征向量](@entry_id:151813)恰好也是原矩阵$A$中对应于$\lambda_j$的[特征向量](@entry_id:151813)。

[带位移的QR算法](@entry_id:149245)巧妙地、隐式地执行了这一过程。我们可以将QR迭代看作是一种更复杂的、同时作用于一组[标准基向量](@entry_id:152417)的“[子空间迭代](@entry_id:168266)”。一步带位移$\sigma_k$的QR迭代，其效果等价于对一个[子空间](@entry_id:150286)进行了一次基于矩阵$(A_k - \sigma_k I)^{-1}$的反[幂迭代](@entry_id:141327)，然后再进行[正交化](@entry_id:149208)。

具体来说，假设任意向量$v$可以表示为矩阵$A_k$的[特征向量](@entry_id:151813)$\{v_i\}$的[线性组合](@entry_id:154743)：$v = \sum_i c_i v_i$。应用算子$(A_k - \sigma_k I)^{-1}$后，我们得到：
$$
(A_k - \sigma_k I)^{-1} v = \sum_{i} c_i (A_k - \sigma_k I)^{-1} v_i = \sum_{i} \frac{c_i}{\lambda_i - \sigma_k} v_i
$$
如果$\sigma_k$非常接近某个[特征值](@entry_id:154894)$\lambda_j$，那么分母$|\lambda_i - \sigma_k|$中当$i=j$时最小，使得对应项的系数$\frac{c_j}{\lambda_j - \sigma_k}$在所有项中占主导地位。结果向量$(A_k - \sigma_k I)^{-1} v$的方向将极大地偏向[特征向量](@entry_id:151813)$v_j$。

在[QR算法](@entry_id:145597)的迭代过程中，这种效应导致矩阵的最后一个（或最后几个）列向量所张成的[子空间](@entry_id:150286)迅速地与最接近位移$\sigma_k$的[特征值](@entry_id:154894)所对应的[特征向量](@entry_id:151813)（或不变子空间）对齐。这种对齐的直接后果是，代表矩阵最后一个元素与其余部分耦合程度的次对角线元素$(A_k)_{n, n-1}$会迅速衰减至零。当这个元素足够小时，我们便可以认为一个[特征值](@entry_id:154894)已经被分离出来，这个过程称为**收缩（deflation）**。

### 实用的位移策略

既然选择一个好的位移（即[特征值](@entry_id:154894)的良好近似）是关键，那么我们如何获得这样的位移呢？实践中发展出了多种有效的位移策略。

#### 瑞利商位移（Rayleigh Quotient Shift）

最简单而有效的策略之一是使用当前[迭代矩阵](@entry_id:637346)$A_k$的右下角元素作为位移，即$\sigma_k = (A_k)_{nn}$。这个值被称为关于[标准基向量](@entry_id:152417)$e_n$的**瑞利商（Rayleigh quotient）**。对于对称矩阵，瑞利商是[特征值](@entry_id:154894)的良好近似，能够带来显著的[收敛加速](@entry_id:165787)。

#### [威尔金森位移](@entry_id:634015)（Wilkinson Shift）

对于对称矩阵，存在一种更为强大且能保证[全局收敛](@entry_id:635436)的策略，即**[威尔金森位移](@entry_id:634015)**。该策略不只看$(A_k)_{nn}$，而是考察$A_k$右下角的$2 \times 2$子矩阵：
$$
B = \begin{bmatrix} a  b \\ c  d \end{bmatrix} = \begin{bmatrix} (A_k)_{n-1,n-1}  (A_k)_{n-1,n} \\ (A_k)_{n,n-1}  (A_k)_{nn} \end{bmatrix}
$$
[威尔金森位移](@entry_id:634015)被定义为这个$2 \times 2$子矩阵$B$的两个[特征值](@entry_id:154894)中，与$d = (A_k)_{nn}$更接近的那一个 ([@problem_id:3597295])。

例如，对于子矩阵 $$B=\begin{bmatrix} 9/5  1/4 \\ 3/10  2 \end{bmatrix}$$，其特征多项式为 $\det(B-\lambda I) = \lambda^2 - (\frac{9}{5}+2)\lambda + (\frac{9}{5}\cdot 2 - \frac{1}{4}\cdot \frac{3}{10}) = 0$。解这个[二次方程](@entry_id:163234)得到的两个[特征值](@entry_id:154894)为 $\lambda = \frac{19}{10} \pm \sqrt{\frac{17}{200}}$。由于$d=2=\frac{20}{10}$，显然，$\frac{19}{10}+\sqrt{\frac{17}{200}}$ 这个根距离$d$更近。因此，[威尔金森位移](@entry_id:634015)就是$\mu = \frac{19}{10}+\sqrt{\frac{17}{200}}$。对于[对称矩阵](@entry_id:143130)，该策略能实现渐进三次的[收敛速度](@entry_id:636873)，效率极高。

### 处理复数[特征值](@entry_id:154894)：弗朗西斯双步位移

当实矩阵$A$具有复数[特征值](@entry_id:154894)时，它们必然以共轭对（$\mu, \bar{\mu}$）的形式出现。此时，任何实数位移$\sigma_k$都无法有效逼近任何一个复数[特征值](@entry_id:154894)。直接使用复数位移$\mu$会导致矩阵$A_k - \mu I$变为复数矩阵，从而使后续所有计算都进入[复数域](@entry_id:153768)，这会使计算量和存储量加倍，是需要极力避免的。

**弗朗西斯双步位移法（Francis double-shift step）** 提供了一个绝妙的解决方案，它能在完全实数算术下实现一对共轭复数位移的效果 ([@problem_id:3597283])。其思想是连续执行两步QR迭代，分别使用共轭位移$\mu$和$\bar{\mu}$。最终的变换矩阵将是两个复数[正交矩阵](@entry_id:169220)的乘积，而这个乘积恰好是一个实数正交矩阵。

根据**[隐式Q定理](@entry_id:750561)（Implicit Q Theorem）**，我们无需显式地计算这两步迭代。我们只需要构造一个与这两步迭代“等价”的、初始变换行为相同的实数正交变换即可。这个初始变换行为由一个实系数多项式$p(z)$决定：
$$
p(z) = (z - \mu)(z - \bar{\mu}) = z^2 - (\mu + \bar{\mu})z + \mu\bar{\mu} = z^2 - 2\operatorname{Re}(\mu)z + |\mu|^2
$$
由于多项式$p(z)$的系数均为实数，因此将它作用于实矩阵$A_k$得到的矩阵$p(A_k)$也是实矩阵。双步位移的隐式实现正是从$p(A_k)$的第一列向量开始的。

### 隐式算法与“凸起追逐”

在实际计算中，为了效率，[QR算法](@entry_id:145597)通常应用于一个预先通过正交相似变换化简得到的**[上海森堡矩阵](@entry_id:756367)（upper Hessenberg matrix）**。海森堡矩阵是一种近[上三角矩阵](@entry_id:150931)，其主对角线下方只有第一条次对角线（即$a_{i+1,i}$）上的元素可以非零。QR迭代的一个重要性质是它能保持海森堡结构。

[隐式QR算法](@entry_id:750559)（特别是双步位移）的实现过程被称为**“凸起追逐”（bulge chasing）**。

1.  **引发凸起**：算法的第一步是计算向量$x = p(A_k)e_1$。由于$A_k$是海森堡矩阵，向量$x$通常只有前三个分量非零。然后，构造一个小的（通常是$3 \times 3$）**[豪斯霍尔德变换](@entry_id:168808)（Householder transformation）** $Q_1$，使得$Q_1 x$与[标准基向量](@entry_id:152417)$e_1$平行 ([@problem_id:3597276])。将这个$Q_1$嵌入到一个$n \times n$的单位矩阵中，得到第一个变换矩阵。对$A_k$进行相似变换$A'_k = Q_1^{\top} A_k Q_1$。这个操作会破坏$A_k$的海森堡结构，在原本应该是零的位置（如$(3,1)$或$(4,1)$处）产生非零元，形成一个“凸起”。

2.  **追逐凸起**：接下来，算法会执行一系列精心设计的相似变换，其目的就是将这个“凸起”沿着次次对角线“追赶”下去，直至将其“挤出”矩阵的右下角。每一步都使用一个小的正交变换（如[豪斯霍尔德变换](@entry_id:168808)或**[吉文斯旋转](@entry_id:167475)（Givens rotation）**），作用于包含凸起的局部区域，恢复该列的海森堡结构，但代价是在下一列的更下方制造一个新的凸起 ([@problem_id:2176476])。例如，一个作用于第2行和第3行的[吉文斯旋转](@entry_id:167475)可以消除$(3,1)$位置的凸起，但会在$(4,2)$位置引入新的非零元。这个过程持续进行，直到整个矩阵恢复海森堡形式。

整个“凸起追逐”过程构成了一次完整的隐式双步QR迭代。最终得到的矩阵与显式执行两次复数位移QR迭代的结果（在数学上）是等价的，但全程都在实数算术下完成，且计算效率更高。

### 算法的终止：收缩与[收敛判据](@entry_id:158093)

[QR算法](@entry_id:145597)的迭代过程并非无休止。当某个次对角[线元](@entry_id:196833)素$h_{i+1,i}$变得足够小时，我们就可以认为矩阵在该处已经“解耦”，可以将其置为零。这个过程称为**收缩（deflation）** ([@problem_id:3543153])。

置零操作将原矩阵分裂成两个更小的、独立的子问题，从而可以[分而治之](@entry_id:273215)。那么，何为“足够小”？在有限精度计算中，我们几乎永远不会得到精确的零。一个稳健的收缩判据必须考虑[舍入误差](@entry_id:162651)的尺度。业界标准的判据是基于**[后向稳定性](@entry_id:140758)（backward stability）** 的局部判据：
$$
|h_{i+1,i}| \le c \cdot u \cdot (|h_{i,i}| + |h_{i+1,i+1}|)
$$
其中，$u$是机器的[单位舍入误差](@entry_id:756332)（machine epsilon），$c$是一个小的常数。这个判据的意义是，如果一个耦合项$h_{i+1,i}$的[绝对值](@entry_id:147688)，相对于其相邻对角[线元](@entry_id:196833)素的尺度而言，已经小到了舍入误差的级别，那么将它置为零所引入的扰动，可以看作是算法在计算过程中本就会产生的[舍入误差](@entry_id:162651)的一部分。

通过不断地应用带位移的QR迭代和收缩，矩阵$\{A_k\}$最终会收敛为一个**[实舒尔形式](@entry_id:190856)（real Schur form）** ([@problem_id:3597268])。这是一个[准上三角矩阵](@entry_id:753962)，其对角线上可能包含$1 \times 1$的块（对应实[特征值](@entry_id:154894)）和$2 \times 2$的块。对于$2 \times 2$的块，其[特征值](@entry_id:154894)是一对共轭复数，也即原矩阵的复数[特征值](@entry_id:154894)。至此，所有[特征值](@entry_id:154894)均已求出。

### 高级主题与病态问题

尽管[带位移的QR算法](@entry_id:149245)极为强大和稳健，但在某些极端情况下仍会遇到挑战。

#### 收敛缓慢的场景

当矩阵的[特征值](@entry_id:154894)高度聚集（即多个[特征值](@entry_id:154894)非常接近）时，收敛可能会变慢 ([@problem_id:3597268])。从几何上看，这意味着对应的多个[不变子空间](@entry_id:152829)之间的夹角非常小，算法需要更多次的迭代才能将它们分离开。

#### [非正规矩阵](@entry_id:752668)的危害

对于**[非正规矩阵](@entry_id:752668)（non-normal matrices）**（即满足$A A^{\top} \neq A^{\top} A$的矩阵），[QR算法](@entry_id:145597)的行为可能变得复杂。严重非正规的矩阵，其[特征向量](@entry_id:151813)之间可能接近[线性相关](@entry_id:185830)，特征值问题本身是病态的。在这种情况下，即使是先进的位移策略也可能失效。

一个典型的例子是，简单的瑞利商位移策略在应用于一个高度非正规的$2 \times 2$矩阵时，可能会收敛到一个根本不是[特征值](@entry_id:154894)的点 ([@problem_id:3597294])。这种现象与矩阵的**伪谱（pseudospectrum）** 有关。即使一个点$z$不是[特征值](@entry_id:154894)，如果其对应的“伪[谱半径](@entry_id:138984)”很大（即算子范数$\|(A-zI)^{-1}\|$很大），那么它在数值上表现得就像一个[特征值](@entry_id:154894)。在迭代过程中，还可能出现**残差增长（residual growth）** 的现象，即旨在减小的次对角线元素反而增大了。这警示我们，对于[非正规矩阵](@entry_id:752668)，必须采用更为复杂的、经过验证的稳健策略（如弗朗西斯双步位移法）。

#### 停滞与异常位移

在极少数情况下，即使是弗朗西斯双步位移法也可能陷入“停滞”或“循环”，即经过多次迭代后，没有任何一个次对角[线元](@entry_id:196833)素显著减小。这通常发生在矩阵具有特殊结构，导致[威尔金森位移](@entry_id:634015)本身也陷入一个重复的模式。

为了打破这种僵局，现代[QR算法](@entry_id:145597)的实现中包含了一种**异常位移（exceptional shift）** 策略 ([@problem_id:3597264])。其目的不是为了直接逼近某个[特征值](@entry_id:154894)，而是为了“扰乱”当前的迭代模式。一个稳健的异常位移策略会在检测到连续多次迭代（例如10次或20次）没有发生收缩后被触发。它会采用一个特设的、与当前循环模式无关的位移（通常也是一个共轭对，以保持实数算术），进行一次QR迭代。这个“随机”的扰动通常足以打破循环，使算法恢复到正常的快速收敛[轨道](@entry_id:137151)上。

通过结合高效的位移策略、稳健的隐式实现、可靠的收缩判据以及处理病态情况的异常策略，[带位移的QR算法](@entry_id:149245)成为了现代[计算数学](@entry_id:153516)中求解稠密[矩阵特征值问题](@entry_id:142446)的标准方法，在科学与工程计算的各个领域都发挥着不可或缺的作用。