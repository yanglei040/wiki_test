{"hands_on_practices": [{"introduction": "要真正理解向Hessenberg形式的约化，我们必须首先掌握其基本构件：单个Householder反射变换的应用。本练习将指导你通过符号运算构建一个反射变换，以在矩阵的第一列中引入所需的零元素。通过这个循序渐进的计算过程 [@problem_id:3572572]，你将对这种强大的相似变换的工作原理获得具体的理解。", "problem": "设 $A \\in \\mathbb{R}^{4 \\times 4}$ 是一个具有一般元素 $a_{ij}$ 的实矩阵。考虑使用一个由Householder反射器构建的相似变换将$A$约化为上Hessenberg形式，该反射器作用于与第2到第4行和列相关的尾部$3 \\times 3$子空间。令 $x \\in \\mathbb{R}^{3}$ 表示由$A$的第一列中位于$(1,1)$元素下方的元素构成的子向量，即 $x = \\begin{pmatrix} a_{21} \\\\ a_{31} \\\\ a_{41} \\end{pmatrix}$。假设 $a_{21}$、$a_{31}$、$a_{41}$ 中至少有一个非零，因此 $x \\neq 0$。\n\nHouseholder反射器是一个形如 $H = I - 2 \\dfrac{v v^{T}}{v^{T} v}$ 的实正交对称矩阵，其中 $v \\in \\mathbb{R}^{m}$ 为某个非零向量，$I$ 是相应维度的单位矩阵。这样的反射器通过跨越与$v$正交的超平面的反射，将一个给定向量映射到一个坐标向量的倍数。\n\n构造一个 $3 \\times 3$ 的Householder反射器 $Q$，它将 $x$ 映射到一个与第一个基向量 $e_{1} \\in \\mathbb{R}^{3}$ 共线的向量。将 $Q$ 提升为一个正交的 $4 \\times 4$ 相似因子 $H_{1} = \\operatorname{diag}(1, Q)$，并构成相似变换 $A^{(1)} = H_{1} A H_{1}^{T}$。仅使用Householder反射器的定义，符号化地推导出$Q$，并解释为什么$A^{(1)}$的$(3,1)$和$(4,1)$元素为零，从而展示第一列中更新后的Hessenberg模式。\n\n采用数值稳定的符号约定，即在从$x$构造反射器时，选择$e_1$的目标倍数以避免相减抵消。将下面的最终答案表示为标量 $\\tau$ 的单一闭式解析表达式，使得 $Q = I - \\tau u u^{T}$，其中 $u = x - \\alpha e_{1}$ 且 $\\alpha$ 根据前述的稳定约定选择。你的最终表达式必须仅用 $a_{21}$、$a_{31}$ 和 $a_{41}$ 明确给出。不需要四舍五入。", "solution": "该问题要求推导在将一个 $4 \\times 4$ 矩阵 $A$ 约化为上Hessenberg形式的第一步中，所使用的Householder反射中的一个标量 $\\tau$。它还要求解释为什么此变换会在第一列的正确位置引入零。\n\n设 $A \\in \\mathbb{R}^{4 \\times 4}$ 是一个元素为 $a_{ij}$ 的矩阵。目标是找到一个相似变换，在位置 $(3,1)$ 和 $(4,1)$ 处引入零。这是创建上Hessenberg矩阵的第一步，该矩阵在第一条次对角线下方为零。变换矩阵构造为 $H_1 = \\begin{pmatrix} 1 & 0 \\\\ 0 & Q \\end{pmatrix}$，其中 $Q \\in \\mathbb{R}^{3 \\times 3}$ 是一个Householder反射器。\n\n要变换的向量是$A$的第一列中对角线下方的子向量，给出为 $x = \\begin{pmatrix} a_{21} \\\\ a_{31} \\\\ a_{41} \\end{pmatrix} \\in \\mathbb{R}^{3}$。问题假设 $x \\neq 0$。Householder反射器 $Q$ 必须将 $x$ 映射到一个与第一个标准基向量 $e_1 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\in \\mathbb{R}^{3}$ 共线的向量。即，对于某个标量 $\\alpha \\in \\mathbb{R}$，有 $Qx = \\alpha e_1$。\n\nHouseholder反射器是一个正交矩阵。正交变换保持欧几里得范数（$L^2$范数）。因此，我们必须有 $\\|Qx\\|_2 = \\|x\\|_2$。\n应用此性质：\n$\\|\\alpha e_1\\|_2 = \\|x\\|_2$\n$|\\alpha| \\|e_1\\|_2 = \\|x\\|_2$\n由于 $\\|e_1\\|_2 = 1$，我们得到 $|\\alpha| = \\|x\\|_2$。\n$x$的范数由 $\\|x\\|_2 = \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2}$ 给出。因此，$\\alpha = \\pm \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2}$。\n\n问题指定使用数值稳定的符号约定。反射向量由 $x$ 及其目标 $\\alpha e_1$ 构造。反射向量是 $u = x - \\alpha e_1$。为避免相减抵消（当两个几乎相等的数相减时可能导致精度损失），$\\alpha$的符号选择为与$x$的第一个分量$a_{21}$的符号相反。这确保了$u$的第一个分量$u_1 = a_{21} - \\alpha$涉及相同符号量的相加（或相反符号量的相减）。\n$\\alpha$的稳定选择是：\n$\\alpha = -\\operatorname{sgn}(a_{21}) \\|x\\|_2 = -\\operatorname{sgn}(a_{21}) \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2}$。\n这里，$\\operatorname{sgn}(z)$ 是符号函数。如果 $a_{21} = 0$，符号选择是任意的；一个常见的约定是设置 $\\operatorname{sgn}(0) = 1$。\n\n将 $x$ 映射到 $\\alpha e_1$ 的Householder反射器由公式 $Q = I - 2 \\frac{v v^{T}}{v^{T} v}$ 给出，其中反射向量为 $v = x - \\alpha e_1$。在问题的记号中，这个向量表示为 $u$。所以，我们有 $u = x - \\alpha e_1$。\n问题将 $Q$ 定义为 $Q = I - \\tau u u^{T}$。与标准定义比较，我们可以确定 $\\tau = \\frac{2}{u^{T} u}$。\n\n我们现在计算 $u^{T} u = \\|u\\|_2^2$：\n$u^{T} u = (x - \\alpha e_1)^{T} (x - \\alpha e_1) = x^{T}x - 2\\alpha x^{T}e_1 + \\alpha^2 e_1^{T}e_1$。\n我们有：\n- $x^{T}x = \\|x\\|_2^2 = a_{21}^2 + a_{31}^2 + a_{41}^2$。\n- $x^{T}e_1 = a_{21}$。\n- $e_1^{T}e_1 = \\|e_1\\|_2^2 = 1$。\n- $\\alpha^2 = (\\|x\\|_2)^2 = \\|x\\|_2^2$。\n\n将这些代入 $u^{T} u$ 的表达式：\n$u^{T} u = \\|x\\|_2^2 - 2\\alpha a_{21} + \\|x\\|_2^2 = 2\\|x\\|_2^2 - 2\\alpha a_{21}$。\n现在，我们代入 $\\alpha$ 的表达式：\n$u^{T} u = 2\\|x\\|_2^2 - 2(-\\operatorname{sgn}(a_{21}) \\|x\\|_2) a_{21} = 2\\|x\\|_2^2 + 2(\\operatorname{sgn}(a_{21})a_{21}) \\|x\\|_2$。\n因为 $\\operatorname{sgn}(z)z = |z|$，这可以简化为：\n$u^{T} u = 2\\|x\\|_2^2 + 2|a_{21}| \\|x\\|_2 = 2\\|x\\|_2 (\\|x\\|_2 + |a_{21}|)$。\n\n现在我们可以求出 $\\tau$：\n$\\tau = \\frac{2}{u^{T} u} = \\frac{2}{2\\|x\\|_2 (\\|x\\|_2 + |a_{21}|)} = \\frac{1}{\\|x\\|_2 (\\|x\\|_2 + |a_{21}|)}$。\n\n代入 $\\|x\\|_2 = \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2}$，我们得到 $\\tau$ 关于矩阵元素的最终表达式：\n$\\tau = \\frac{1}{\\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2} \\left( \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2} + |a_{21}| \\right)}$。\n\n接下来，我们必须解释为什么 $A^{(1)} = H_1 A H_1^{T}$ 的 $(3,1)$ 和 $(4,1)$ 元素为零。由于 $H_1$ 是一个基于Householder的矩阵，它是对称的，所以 $H_1^{T} = H_1$。因此，$A^{(1)} = H_1 A H_1$。\n我们关注 $A^{(1)}$ 的第一列，它由 $A^{(1)} e_1^{(4)}$ 给出，其中 $e_1^{(4)} = \\begin{pmatrix} 1 & 0 & 0 & 0 \\end{pmatrix}^\\top$。\n$A^{(1)}$ 的第一列是 $H_1 A H_1 e_1^{(4)}$。\n首先，我们计算 $H_1 e_1^{(4)}$：\n$H_1 e_1^{(4)} = \\begin{pmatrix} 1 & 0 \\\\ 0 & Q \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = e_1^{(4)}$。\n所以，$A^{(1)}$ 的第一列就是 $H_1 (A e_1^{(4)})$。\n$A e_1^{(4)}$ 是 $A$ 的第一列：$A e_1^{(4)} = \\begin{pmatrix} a_{11} \\\\ a_{21} \\\\ a_{31} \\\\ a_{41} \\end{pmatrix} = \\begin{pmatrix} a_{11} \\\\ x \\end{pmatrix}$。\n现在，我们应用 $H_1$：\n$A^{(1)}$ 的第一列 $= H_1 \\begin{pmatrix} a_{11} \\\\ x \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & Q \\end{pmatrix} \\begin{pmatrix} a_{11} \\\\ x \\end{pmatrix} = \\begin{pmatrix} a_{11} \\\\ Qx \\end{pmatrix}$。\n根据构造，反射器 $Q$ 的设计使得 $Qx = \\alpha e_1^{(3)}$，其中 $e_1^{(3)} = \\begin{pmatrix} 1 & 0 & 0 \\end{pmatrix}^\\top \\in \\mathbb{R}^3$。\n因此，变换后矩阵 $A^{(1)}$ 的第一列是：\n$\\begin{pmatrix} a_{11} \\\\ \\alpha e_1^{(3)} \\end{pmatrix} = \\begin{pmatrix} a_{11} \\\\ \\alpha \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n$A^{(1)}$ 的 $(3,1)$ 元素是此列向量的第三个元素，为 $0$。\n$A^{(1)}$ 的 $(4,1)$ 元素是此列向量的第四个元素，为 $0$。\n这证实了该变换成功地在第一列的次对角线下方引入了零，这是Hessenberg约化这一步骤的目标。之后，同样的过程将应用于对应于第3到第4行和列的子矩阵，以将 $(4,2)$ 元素置零，从而完成对一个 $4 \\times 4$ 矩阵的约化。\n\n最终要求的量是 $\\tau$ 的表达式。\n$\\tau = \\frac{1}{\\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2} \\left( \\sqrt{a_{21}^2 + a_{31}^2 + a_{41}^2} + |a_{21}| \\right)}$。", "answer": "$$\n\\boxed{\\frac{1}{\\sqrt{a_{21}^{2} + a_{31}^{2} + a_{41}^{2}} \\left( \\sqrt{a_{21}^{2} + a_{31}^{2} + a_{41}^{2}} + |a_{21}| \\right)}}\n$$", "id": "3572572"}, {"introduction": "理解了单个步骤后，我们自然会关心整个算法的效率。本练习将我们的分析扩展到确定将一个稠密的 $n \\times n$ 矩阵约化为Hessenberg形式所需的总计算成本。通过对每次迭代的成本进行求和 [@problem_id:3572651]，你将推导出该算法的复杂度，这是其在处理大规模特征值问题时的一个关键考量因素。", "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 为一个稠密实矩阵。考虑使用 Householder 反射将矩阵约化为上Hessenberg形式的标准非分块算法，即一个相似变换 $A \\leftarrow H_{n-2} \\cdots H_{2} H_{1} \\, A \\, H_{1} H_{2} \\cdots H_{n-2}$，其中，对于每个迭代索引 $k$（$1 \\leq k \\leq n-2$），构造 Householder 反射 $H_{k} = I - \\tau_{k} \\tilde{v}_{k} \\tilde{v}_{k}^{\\mathsf{T}}$ 来将第一条次对角线下方的元素 $A_{k+2:n,\\,k}$ 置零，其中 $\\tilde{v}_{k} \\in \\mathbb{R}^{n}$ 是将向量 $v_{k} \\in \\mathbb{R}^{n-k}$ 的分量置于第 $k+1$ 到 $n$ 位置，而其他位置为零所得到的向量。假设为实数运算，并将一个浮点运算（flop）定义为一次标量加法或乘法；标量平方根和除法不计入渐近三次项。\n\n仅从以下基本事实出发：\n- 一个 $a \\times b$ 的稠密矩阵与一个 $b \\times 1$ 的向量进行矩阵向量乘法的成本在实数运算中为 $2ab$ 次浮点运算。\n- 对一个 $a \\times b$ 的矩阵进行 $u v^{\\mathsf{T}}$ 的秩一更新的成本在实数运算中为 $2ab$ 次浮点运算。\n- 在第 $k$ 次迭代中，左乘应用 $A \\leftarrow H_{k} A$ 非平凡地作用于由 $A$ 的第 $k+1$ 行到第 $n$ 行以及第 $k$ 列到第 $n$ 列组成的尾部子矩阵，而右乘应用 $A \\leftarrow A H_{k}$ 则非平凡地作用于由第 $k+1$ 列到第 $n$ 列以及所有行组成的尾部块。\n\n通过对每次迭代的成本（$k = 1, \\dots, n-2$）求和，推导出这种非分块Hessenberg约化的总浮点运算数的主导项。你的推理应明确指出每一步受影响的子矩阵的大小，并仅使用上述的运算计数。忽略所有对 $n^{3}$ 的系数没有贡献的低阶项。\n\n以 $n$ 的单个闭式表达式形式给出你的最终答案，该表达式等于浮点运算数的主导项。最终答案中不要包含大$\\mathcal{O}$符号。不需要进行舍入。", "solution": "用户希望找出使用 Householder 反射将一个稠密矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 进行非分块约化至上Hessenberg形式的总浮点运算（flop）计数的主导项。分析将通过计算单次迭代 $k$ 的成本，然后对 $k$ 从 $1$ 到 $n-2$ 的这些成本求和来进行。一次浮点运算被定义为一次标量加法或乘法。\n\n在迭代 $k$（其中 $1 \\le k \\le n-2$）时的变换由 $A \\leftarrow H_k A H_k$ 给出，其中 $H_k = I - \\tau_k \\tilde{v}_k \\tilde{v}_k^{\\mathsf{T}}$。向量 $\\tilde{v}_k \\in \\mathbb{R}^n$ 的前 $k$ 个分量为零。令 $v_k \\in \\mathbb{R}^{n-k}$ 表示 $\\tilde{v}_k$ 中从位置 $k+1$ 到 $n$ 的非零元素组成的子向量。\n\n第 $k$ 次迭代的总成本（记为 $C_k$）是左乘（$A \\leftarrow H_k A$）和右乘（$A \\leftarrow A H_k$）成本之和。\n\n**1. 左乘成本, $A \\leftarrow H_k A$**\n\n左乘 $H_k$ 由 $A \\leftarrow (I - \\tau_k \\tilde{v}_k \\tilde{v}_k^{\\mathsf{T}})A$ 给出。此操作仅影响矩阵 $A$ 的第 $k+1$ 行到第 $n$ 行。在第 $k$ 次迭代开始时，$A$ 的第 $1, \\dots, k-1$ 列已经具有所需的Hessenberg结构，这意味着对于 $i > j+1$ 和 $j < k$，元素 $A_{i,j}$ 为零。特别地，对于任何列 $j < k$，子矩阵 $A(k+1:n, j)$ 是零。这些零行的线性组合（这正是 $H_k A$ 对这些列所做的计算）将保持为零。因此，该更新仅非平凡地影响第 $k$ 列到第 $n$ 列。\n\n如问题所述，此操作作用于由 $A$ 的第 $k+1$ 行到第 $n$ 行以及第 $k$ 列到第 $n$ 列组成的子矩阵。我们将此子矩阵表示为 $A_{sub,L} = A(k+1:n, k:n)$。$A_{sub,L}$ 的大小为 $(n-k) \\times (n-k+1)$。对该子矩阵的变换为 $A_{sub,L} \\leftarrow (I_{n-k} - \\tau_k v_k v_k^{\\mathsf{T}}) A_{sub,L}$。这可以分两步实现：\na. 计算临时行向量 $w^{\\mathsf{T}} = v_k^{\\mathsf{T}} A_{sub,L}$。这等同于计算列向量 $w = A_{sub,L}^{\\mathsf{T}} v_k$。这是一个矩阵向量乘积，其中矩阵 $A_{sub,L}^{\\mathsf{T}}$ 的维度为 $(n-k+1) \\times (n-k)$，向量 $v_k$ 的维度为 $(n-k) \\times 1$。根据给定的规则（对于一个 $a \\times b$ 的矩阵，成本为 $2ab$），成本为 $2(n-k+1)(n-k)$ 次浮点运算。\nb. 执行秩一更新 $A_{sub,L} \\leftarrow A_{sub,L} - (\\tau_k v_k) w^{\\mathsf{T}}$。矩阵 $A_{sub,L}$ 的维度为 $(n-k) \\times (n-k+1)$。根据问题的规则，对一个 $a \\times b$ 矩阵的秩一更新成本为 $2ab$ 次浮点运算。这里，$a=n-k$ 且 $b=n-k+1$。成本为 $2(n-k)(n-k+1)$ 次浮点运算。\n\n在第 $k$ 次迭代中，左乘的总成本是这些成本之和：\n$C_{k,L} = 2(n-k)(n-k+1) + 2(n-k)(n-k+1) = 4(n-k)(n-k+1)$ 次浮点运算。\n\n**2. 右乘成本, $A \\leftarrow A H_k$**\n\n右乘由 $A \\leftarrow A(I - \\tau_k \\tilde{v}_k \\tilde{v}_k^{\\mathsf{T}}) = A - \\tau_k (A \\tilde{v}_k) \\tilde{v}_k^{\\mathsf{T}}$ 给出。此操作可分为两步：\na. 计算临时列向量 $y = A \\tilde{v}_k$。由于 $\\tilde{v}_k$ 仅在位置 $k+1$ 到 $n$ 有非零项，该乘积是 $A$ 的第 $k+1$ 列到第 $n$ 列的线性组合。即，$y = A(:, k+1:n) v_k$。这是一个矩阵向量乘积，其中矩阵 $A(:, k+1:n)$ 的维度为 $n \\times (n-k)$，向量 $v_k$ 的维度为 $(n-k) \\times 1$。使用 $2ab$ 规则，其中 $a=n$ 和 $b=n-k$，浮点运算数为 $2n(n-k)$。\nb. 执行秩一更新 $A \\leftarrow A - (\\tau_k y) \\tilde{v}_k^{\\mathsf{T}}$。由于 $\\tilde{v}_k^{\\mathsf{T}}$ 的稀疏性（非零项在位置 $k+1$ 到 $n$），此更新仅修改 $A$ 的第 $k+1$ 列到第 $n$ 列。这对应于对子矩阵 $A(:,k+1:n)$ 的秩一更新，该子矩阵的维度为 $n \\times (n-k)$。当 $a=n$ 且 $b=n-k$ 时，成本为 $2n(n-k)$ 次浮点运算。\n\n在第 $k$ 次迭代中，右乘的总成本为：\n$C_{k,R} = 2n(n-k) + 2n(n-k) = 4n(n-k)$ 次浮点运算。\n\n**3. 总浮点运算数**\n\n第 $k$ 次迭代的总浮点运算数为 $C_k = C_{k,L} + C_{k,R}$:\n$C_k = 4(n-k)(n-k+1) + 4n(n-k)$。\n\n为求得总浮点运算数的主导项，我们将 $C_k$ 从 $k=1$ 到 $n-2$ 求和，并仅保留对 $n^3$ 项有贡献的项。为了找到主导项，我们可以近似认为 $(n-k+1) \\approx (n-k)$。\n$C_k \\approx 4(n-k)^2 + 4n(n-k) = 4(n^2 - 2nk + k^2) + 4n^2 - 4nk = 8n^2 - 12nk + 4k^2$。\n总浮点运算数 $C_{total}$ 是对 $k$ 的求和：\n$C_{total} = \\sum_{k=1}^{n-2} C_k \\approx \\sum_{k=1}^{n-2} (8n^2 - 12nk + 4k^2)$。\n\n我们计算每个分量的和：\n- $\\sum_{k=1}^{n-2} 8n^2 = 8n^2(n-2) = 8n^3 - 16n^2$。主导项是 $8n^3$。\n- $\\sum_{k=1}^{n-2} (-12nk) = -12n \\sum_{k=1}^{n-2} k = -12n \\frac{(n-2)(n-1)}{2} = -6n(n^2 - 3n + 2) = -6n^3 + 18n^2 - 12n$。主导项是 $-6n^3$。\n- $\\sum_{k=1}^{n-2} 4k^2 = 4 \\sum_{k=1}^{n-2} k^2 = 4 \\frac{(n-2)(n-1)(2(n-2)+1)}{6} = \\frac{2}{3}(n-2)(n-1)(2n-3)$。这个关于 $n$ 的多项式的主导项是 $\\frac{2}{3}(n)(n)(2n) = \\frac{4}{3}n^3$。\n\n对各部分的主导项求和：\n$C_{total} \\approx 8n^3 - 6n^3 + \\frac{4}{3}n^3 = 2n^3 + \\frac{4}{3}n^3 = \\frac{6n^3 + 4n^3}{3} = \\frac{10}{3}n^3$。\n\n非分块Hessenberg约化的总浮点运算数的主导项是 $\\frac{10}{3}n^3$。", "answer": "$$\n\\boxed{\\frac{10}{3}n^{3}}\n$$", "id": "3572651"}, {"introduction": "理论上的算法最终必须在计算机上实现，而有限精度算术会带来挑战。这个动手编程练习 [@problem_id:3572579] 通过要求你设计一个程序来验证一个矩阵是否“接近”Hessenberg形式，从而弥合了理论与实践之间的鸿沟。这涉及到理解如何为数值误差定义一个实用的容差，并实现一个能验证真实世界算法输出的测试套件。", "problem": "设计并实现一个程序，该程序给定一组测试矩阵，在有限精度算术中验证每个矩阵是否接近上Hessenberg形式。验证方法是通过限定严格位于第一条次对角线下方元素的弗罗贝尼乌斯范数 (Frobenius norm) 的界来实现。请在实数双精度浮点算术中工作，并通过浮点算术的标准模型对浮点舍入进行建模：对于应用于实数的任何基本算术运算，计算结果满足 $\\mathrm{fl}(x \\,\\mathrm{op}\\, y) = (x \\,\\mathrm{op}\\, y)\\,(1+\\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入。对于 binary64（双精度），假设 $u = \\tfrac{1}{2}\\,\\mathrm{eps}$，其中 $\\mathrm{eps}$ 是机器 epsilon。一个 $n \\times n$ 的实矩阵 $H$ 是上Hessenberg矩阵，如果对于所有满足 $i \\ge j + 2$ 的索引 $i,j$，都有 $H_{ij} = 0$。对于任何矩阵 $M \\in \\mathbb{R}^{n \\times n}$，定义矩阵 $L(M)$ 为位于第一条次对角线下方的严格下三角部分，即如果 $i \\ge j + 2$，则 $L(M)_{ij} = M_{ij}$，否则 $L(M)_{ij} = 0$。弗罗贝尼乌斯范数定义为 $\\|X\\|_{F} = \\sqrt{\\sum_{i=1}^{n}\\sum_{j=1}^{n} X_{ij}^{2}}$。待实现的验证测试必须确定，对于给定矩阵 $M$，不等式 $\\|L(M)\\|_{F} \\le \\tau(n,M)$ 是否成立，其中容差规定为\n$$\n\\tau(n,M) = \\gamma \\, n \\, u \\, \\|M\\|_{F},\n$$\n固定常数 $\\gamma = 10$。每个测试用例的输出必须是一个布尔值，指示不等式是否成立。程序必须仅使用实数算术，并且不得假定除每个测试用例指定之外的任何结构。\n\n您的程序必须实现以下测试套件。所有随机数必须使用具有指定种子和大小的实值标准正态分布 $\\mathcal{N}(0,1)$ 生成，并且每个确定性构造都必须严格按照所述进行。对于给定的正整数 $n$，令 $\\mathrm{HessMask}(n)$ 表示索引集 $\\{(i,j): 1 \\le i \\le n,\\, 1 \\le j \\le n,\\, i \\le j+1\\}$，对应于上Hessenberg矩阵中可能非零的元素，令 $\\mathrm{LowerMask}(n)$ 表示索引集 $\\{(i,j): i \\ge j+2\\}$。\n\n按顺序构建和评估的测试用例：\n\n1. 理想情况下的精确上Hessenberg矩阵。设 $n = 6$ 且种子 $s = 11$。通过为 $\\mathrm{HessMask}(n)$ 中的元素从 $\\mathcal{N}(0,1)$ 中抽取独立样本来构造 $H \\in \\mathbb{R}^{n \\times n}$，并将 $\\mathrm{LowerMask}(n)$ 中的所有元素设置为 $0$。评估 $\\|L(H)\\|_{F} \\le \\tau(n,H)$ 是否成立。\n\n2. 带有微小下部噪声的近似Hessenberg矩阵。设 $n = 10$ 且种子 $s_H = 13$。使用种子 $s_H$ 如测试用例 $1$ 中构造 $H \\in \\mathbb{R}^{n \\times n}$。接下来，设种子 $s_E = 1313$，并仅在 $\\mathrm{LowerMask}(n)$ 上从 $\\mathcal{N}(0,1)$ 中抽取独立样本来构造矩阵 $E \\in \\mathbb{R}^{n \\times n}$，其他地方为零。如果 $\\|E\\|_{F} \\ne 0$，则缩放 $E$ 使其 $\\|E\\|_{F}$ 等于目标下部范数 $t = 5\\, n \\, u \\, \\|H\\|_{F}$；如果 $\\|E\\|_{F} = 0$，则保持 $E = 0$。定义 $M = H + E$ 并评估 $\\|L(M)\\|_{F} \\le \\tau(n,M)$ 是否成立。\n\n3. 明显的非Hessenberg下部扰动。设 $n = 10$ 且种子 $s_H = 17$。使用种子 $s_H$ 如测试用例 $1$ 中构造 $H \\in \\mathbb{R}^{n \\times n}$。接下来，设种子 $s_E = 1717$，并如上文所述，仅在 $\\mathrm{LowerMask}(n)$ 上抽取 $E$。如果 $\\|E\\|_{F} \\ne 0$，则缩放 $E$ 使其 $\\|E\\|_{F}$ 等于目标下部范数 $t = 10^{-8} \\, \\|H\\|_{F}$；如果 $\\|E\\|_{F} = 0$，则保持 $E = 0$。定义 $M = H + E$ 并评估 $\\|L(M)\\|_{F} \\le \\tau(n,M)$ 是否成立。\n\n4. 边界情况 $n=1$。设 $n = 1$ 且种子 $s = 19$。从 $\\mathcal{N}(0,1)$ 中抽取其单个元素来构造 $M \\in \\mathbb{R}^{1 \\times 1}$。评估 $\\|L(M)\\|_{F} \\le \\tau(n,M)$ 是否成立。\n\n5. 边界情况 $n=2$。设 $n = 2$ 且种子 $s = 23$。从 $\\mathcal{N}(0,1)$ 中独立抽取元素来构造 $M \\in \\mathbb{R}^{2 \\times 2}$。评估 $\\|L(M)\\|_{F} \\le \\tau(n,M)$ 是否成立。\n\n6. 有限精度下的算法上Hessenberg约简。设 $n = 8$ 且种子 $s_A = 29$。从 $\\mathcal{N}(0,1)$ 中独立抽取元素来构造一个稠密矩阵 $A \\in \\mathbb{R}^{n \\times n}$。使用一系列 Householder 反射变换计算相似变换 $\\widetilde{H} = Q^{\\top} A Q$，以将第一条次对角线下方的元素清零，该过程在如上所述的单位舍入 $u$ 的浮点算术中执行。使用标准的非主元 Householder Hessenberg约简：对于从 $1$ 到 $n-2$ 的每个 $k$，计算作用于行 $k+1$ 到 $n$ 的 Householder 反射变换，以将第 $k$ 列中第一条次对角线以下的元素清零，并将其从左侧和右侧应用于 $A$ 以就地更新它；将最终更新的矩阵设为 $\\widetilde{H}$。评估 $\\|L(\\widetilde{H})\\|_{F} \\le \\tau(n,\\widetilde{H})$ 是否成立。\n\n7. 缩放不变性合理性检查。重用测试用例 $2$ 的构造，以种子 $s_H = 13$ 和 $s_E = 1313$ 形成 $M \\in \\mathbb{R}^{10 \\times 10}$。定义标量 $s = 10^{6}$ 和缩放后的矩阵 $\\widehat{M} = s\\, M$。评估 $\\|L(\\widehat{M})\\|_{F} \\le \\tau(10,\\widehat{M})$ 是否成立。\n\n实现要求：\n\n- 使用双精度。计算 $u$ 为 $u = \\tfrac{1}{2}\\,\\mathrm{eps}$，其中 $\\mathrm{eps}$ 是双精度下的机器 epsilon。\n- 所有范数必须是如上定义的弗罗贝尼乌斯范数。\n- 测试用例 $6$ 中的 Householder 约简必须显式实现（不要假设精确算术；使用浮点运算）。\n- 您的程序应产生一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[true_or_false_1,true_or_false_2,...]”），其中每个条目是相应测试用例的布尔结果，按上面列出的顺序排列。\n\n所有测试用例的最终答案都是布尔值。不涉及任何物理单位或角度；所有计算都是在 $\\mathbb{R}$ 上的纯数值计算，并且必须在指定的有限精度模型中执行。", "solution": "所提供的问题是数值线性代数领域中一个定义明确的计算任务。它是科学合理的、客观的，并包含唯一可验证解所需的所有信息。该问题要求实现一个验证例程，以根据精确定义的容差来检查给定矩阵是否接近上Hessenberg形式。问题有效性已确认，解决方案如下。\n\n### 验证方法的原理\n一个 $n \\times n$ 的实矩阵 $H$ 被定义为上Hessenberg矩阵，如果其第一条次对角线以下的所有元素都为零。也就是说，对于所有满足 $i \\ge j+2$ 的索引 $i,j$，$H_{ij} = 0$。在有限精度算术中，理论上是上Hessenberg形式的矩阵可能会因为舍入误差而在这些位置上获得微小的非零值。本任务是实现一个测试，以确定矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 是否“接近”上Hessenberg形式。\n\n这是通过量化矩阵中本应为零的部分的“大小”来完成的。我们定义一个矩阵 $L(M)$，它只包含 $M$ 中严格位于第一条次对角线下方的元素：\n$$\nL(M)_{ij} = \\begin{cases} M_{ij} & \\text{if } i \\ge j+2 \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\n这个下部部分的大小使用弗罗贝尼乌斯范数来衡量，对于任何矩阵 $X \\in \\mathbb{R}^{n \\times n}$，其定义为：\n$$\n\\|X\\|_{F} = \\sqrt{\\sum_{i=1}^{n}\\sum_{j=1}^{n} X_{ij}^{2}}\n$$\n问题规定了一个容差 $\\tau(n,M)$，用于与 $\\|L(M)\\|_{F}$ 进行比较。这个容差是数值分析中的一种标准形式，它随矩阵维度 $n$、矩阵范数 $\\|M\\|_{F}$ 和单位舍入 $u$ 进行缩放。单位舍入 $u$ 表征了浮点算术的精度。对于双精度（binary64），$u = \\frac{1}{2} \\mathrm{eps}$，其中 $\\mathrm{eps}$ 是机器 epsilon，约等于 $2.22 \\times 10^{-16}$。容差由下式给出：\n$$\n\\tau(n,M) = \\gamma \\, n \\, u \\, \\|M\\|_{F}\n$$\n常数 $\\gamma$ 被给定为 $10$。如果以下不等式成立，矩阵 $M$ 被认为是“接近Hessenberg”的：\n$$\n\\|L(M)\\|_{F} \\le \\tau(n,M)\n$$\n程序将对一系列根据问题规范构建的测试矩阵实现此检查。\n\n### 测试用例实现\n七个测试用例的构建和评估如下：\n\n1.  **精确上Hessenberg矩阵**：构建一个 $6 \\times 6$ 的矩阵 $H$，其第一条次对角线及其上方的元素从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取，而第一条次对角线以下的所有元素都精确地设置为 $0$。对于这个矩阵，$L(H)$ 是零矩阵，所以 $\\|L(H)\\|_F = 0$，不等式自然满足。\n\n2.  **近似Hessenberg矩阵**：形成一个 $10 \\times 10$ 的矩阵 $M = H+E$。$H$ 是一个精确的上海森伯格矩阵。$E$ 是一个扰动矩阵，其非零元素仅位于第一条次对角线以下，并被缩放以使 $\\|E\\|_F = 5 \\, n \\, u \\, \\|H\\|_F$。由于 $L(M) = E$，测试评估的是 $5 \\, n \\, u \\, \\|H\\|_F \\le 10 \\, n \\, u \\, \\|H+E\\|_F$ 是否成立。因为 $E$ 非常小，所以 $\\|H+E\\|_F \\approx \\|H\\|_F$，因此条件近似为 $5 \\le 10$，这是成立的。\n\n3.  **明显非Hessenberg矩阵**：与情况2类似，但扰动 $E$ 被缩放为 $\\|E\\|_F = 10^{-8} \\|H\\|_F$。测试变成了检查 $10^{-8} \\|H\\|_F \\le 10 \\, n \\, u \\, \\|H+E\\|_F$ 是否成立。当 $n=10$ 且 $u \\approx 1.11 \\times 10^{-16}$ 时，右侧约为 $10 \\cdot 10 \\cdot (1.11 \\times 10^{-16}) \\|H\\|_F \\approx 10^{-14} \\|H\\|_F$。由于 $10^{-8} > 10^{-14}$，不等式不成立。\n\n4.  **边界情况 $n=1$**：对于任何 $1 \\times 1$ 矩阵，条件 $i \\ge j+2$（即 $1 \\ge 1+2$）永远不会满足。因此，$L(M)$ 始终是零矩阵，其范数为 $0$，测试通过。\n\n5.  **边界情况 $n=2$**：对于任何 $2 \\times 2$ 矩阵，条件 $i \\ge j+2$ 对于任何索引 $(i,j)$ 都不满足。$L(M)$ 是零矩阵，测试通过。\n\n6.  **算法上Hessenberg约简**：使用 Householder 约简算法的显式实现，将一个稠密的 $8 \\times 8$ 随机矩阵 $A$ 约简为上Hessenberg形式 $\\widetilde{H}$。该算法迭代地应用 Householder 反射变换 $P_k$ 来将每列中次对角线以下的元素清零。对于每列 $k=0, \\dots, n-3$：\n    a. 根据子列 $A[k+1:n, k]$ 构建 Householder 向量 $v$，以将其从第二个元素开始的条目清零。使用 $v = x + \\mathrm{sign}(x_1)\\|x\\|_2 e_1$ 的选择来避免相消误差。\n    b. 高效地应用相似变换 $A \\leftarrow P_k A P_k$，而无需构造稠密的反射矩阵。这通过秩-1 更新完成：$A \\leftarrow A - 2 v(v^T A)$ 和 $A \\leftarrow A - 2(Av)v^T$，其中 $v$ 是归一化的。\n    Householder 方法的后向稳定性确保了所得矩阵 $\\widetilde{H}$ 在第一条次对角线以下的元素非常小，其范数 $\\|L(\\widetilde{H})\\|_F$ 在 $u \\|A\\|_F$ 的数量级上。容差 $\\tau$ 就是为此设计的，因此预计测试会通过。\n\n7.  **缩放不变性检查**：测试条件在理论上对于用非零标量 $s$ 缩放 $M$ 是不变的，因为 $\\|L(sM)\\|_F = |s|\\|L(M)\\|_F$ 且 $\\tau(n,sM) = |s|\\tau(n,M)$。这个测试用例通过重用情况2的矩阵并将其缩放 $s=10^6$ 来计算验证此属性。结果应与情况2的结果相匹配。\n\n该实现使用 `numpy` 进行矩阵运算。所需的弗罗贝尼乌斯范数和矩阵构造是使用标准库函数执行的，以确保效率和正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as per problem statement\nGAMMA = 10.0\n# Unit roundoff for double precision (binary64)\nU = 0.5 * np.finfo(np.float64).eps\n\ndef check_is_near_hessenberg(M: np.ndarray) -> bool:\n    \"\"\"\n    Verifies if a matrix M is close to upper Hessenberg form.\n    Checks if ||L(M)||_F <= gamma * n * u * ||M||_F.\n    \"\"\"\n    n = M.shape[0]\n    \n    if n <= 2:\n        # For n=1 or n=2, the set of indices i >= j+2 is empty.\n        # Thus L(M) is the zero matrix and its norm is 0.\n        norm_L_M = 0.0\n    else:\n        # Extract elements where i >= j+2 and compute the norm.\n        # np.tril_indices(n, k=-2) gives indices for the lower triangle starting\n        # from the second subdiagonal.\n        rows, cols = np.tril_indices(n, k=-2)\n        lower_elements = M[rows, cols]\n        # The L2 norm of this vector of elements is the Frobenius norm of L(M).\n        norm_L_M = np.linalg.norm(lower_elements)\n\n    norm_M = np.linalg.norm(M, 'fro')\n    \n    # If M is the zero matrix, its norm is 0. L(M) is also zero.\n    # The tolerance is 0, and norm_L_M is 0. The test 0 <= 0 passes.\n    if norm_M == 0.0:\n        return True\n\n    tolerance = GAMMA * n * U * norm_M\n    \n    return norm_L_M <= tolerance\n\ndef test_case_1():\n    \"\"\"Happy-path exact upper Hessenberg.\"\"\"\n    n = 6\n    seed = 11\n    rng = np.random.default_rng(seed)\n    \n    H = np.zeros((n, n), dtype=np.float64)\n    # HessMask(n) corresponds to i <= j+1.\n    rows, cols = np.triu_indices(n, k=-1)\n    H[rows, cols] = rng.normal(size=len(rows))\n    \n    return check_is_near_hessenberg(H)\n\ndef test_case_2_and_7_builder(scale: float):\n    \"\"\"Builder for test cases 2 and 7.\"\"\"\n    n = 10\n    seed_H = 13\n    seed_E = 1313\n    \n    # Construct H (upper Hessenberg part)\n    rng_H = np.random.default_rng(seed_H)\n    H = np.zeros((n, n), dtype=np.float64)\n    rows_h, cols_h = np.triu_indices(n, k=-1)\n    H[rows_h, cols_h] = rng_H.normal(size=len(rows_h))\n    \n    # Construct E (lower perturbation part)\n    rng_E = np.random.default_rng(seed_E)\n    E = np.zeros((n, n), dtype=np.float64)\n    rows_e, cols_e = np.tril_indices(n, k=-2)\n    E[rows_e, cols_e] = rng_E.normal(size=len(rows_e))\n\n    # Scale E\n    norm_H = np.linalg.norm(H, 'fro')\n    norm_E = np.linalg.norm(E, 'fro')\n    \n    target_lower_norm = 5.0 * n * U * norm_H\n\n    E_scaled = np.zeros_like(E)\n    if norm_E != 0.0:\n        E_scaled = E * (target_lower_norm / norm_E)\n        \n    M = H + E_scaled\n    M_final = scale * M\n    \n    return check_is_near_hessenberg(M_final)\n\ndef test_case_3():\n    \"\"\"Clearly non-Hessenberg lower perturbation.\"\"\"\n    n = 10\n    seed_H = 17\n    seed_E = 1717\n    \n    rng_H = np.random.default_rng(seed_H)\n    H = np.zeros((n, n), dtype=np.float64)\n    rows_h, cols_h = np.triu_indices(n, k=-1)\n    H[rows_h, cols_h] = rng_H.normal(size=len(rows_h))\n    \n    rng_E = np.random.default_rng(seed_E)\n    E = np.zeros((n, n), dtype=np.float64)\n    rows_e, cols_e = np.tril_indices(n, k=-2)\n    E[rows_e, cols_e] = rng_E.normal(size=len(rows_e))\n    \n    norm_H = np.linalg.norm(H, 'fro')\n    norm_E = np.linalg.norm(E, 'fro')\n    \n    target_lower_norm = 1e-8 * norm_H\n    \n    E_scaled = np.zeros_like(E)\n    if norm_E != 0:\n        E_scaled = E * (target_lower_norm / norm_E)\n        \n    M = H + E_scaled\n    return check_is_near_hessenberg(M)\n\ndef test_case_4():\n    \"\"\"Boundary case n=1.\"\"\"\n    n = 1\n    seed = 19\n    rng = np.random.default_rng(seed)\n    M = rng.normal(size=(n, n))\n    return check_is_near_hessenberg(M)\n\ndef test_case_5():\n    \"\"\"Boundary case n=2.\"\"\"\n    n = 2\n    seed = 23\n    rng = np.random.default_rng(seed)\n    M = rng.normal(size=(n, n))\n    return check_is_near_hessenberg(M)\n    \ndef householder_hessenberg_reduction(A: np.ndarray) -> np.ndarray:\n    \"\"\"Explicitly performs Householder reduction to upper Hessenberg form.\"\"\"\n    M = A.copy()\n    n = M.shape[0]\n    \n    for k in range(n - 2):\n        x = M[k+1:n, k].copy()\n        norm_x = np.linalg.norm(x)\n        \n        s = np.copysign(1.0, x[0] if x[0] != 0 else 1.0)\n        \n        v = x.copy()\n        v[0] += s * norm_x\n        \n        norm_v = np.linalg.norm(v)\n\n        if norm_v > 1e-15: # Safeguard against zero vector\n            v /= norm_v\n            \n            # Left multiplication: M_new = P*M = M - 2*v*(v.T*M)\n            sub_M_left = M[k+1:n, k:n]\n            w_left = 2.0 * (v.T @ sub_M_left)\n            M[k+1:n, k:n] -= np.outer(v, w_left)\n            \n            # Right multiplication: M_new = M*P = M - 2*(M*v)*v.T\n            sub_M_right = M[:, k+1:n]\n            w_right = 2.0 * (sub_M_right @ v)\n            M[:, k+1:n] -= np.outer(w_right, v)\n            \n    return M\n\ndef test_case_6():\n    \"\"\"Algorithmic Hessenberg reduction in finite precision.\"\"\"\n    n = 8\n    seed_A = 29\n    rng = np.random.default_rng(seed_A)\n    A = rng.normal(size=(n, n))\n    \n    H_tilde = householder_hessenberg_reduction(A)\n    \n    return check_is_near_hessenberg(H_tilde)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_functions = [\n        test_case_1,\n        lambda: test_case_2_and_7_builder(scale=1.0),\n        test_case_3,\n        test_case_4,\n        test_case_5,\n        test_case_6,\n        lambda: test_case_2_and_7_builder(scale=1e6),\n    ]\n    \n    results = [str(func()).lower() for func in test_functions]\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3572579"}]}