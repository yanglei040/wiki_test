{"hands_on_practices": [{"introduction": "在计算不变子空间之前，我们必须首先理解其理论结构。本练习通过一个直接的分析方法，要求您为一个小的、不可对角化的矩阵枚举出其所有的不变子空间和约化子空间，从而将抽象的定义与广义特征空间的具体结构联系起来 ([@problem_id:3551519])。这项基础性的计算练习将为您后续学习更高级的算法打下坚实的理论基础。", "problem": "设 $A \\in \\mathbb{R}^{3 \\times 3}$ 作用于配备了标准欧几里得内积的 $\\mathbb{R}^{3}$，其中\n$$\nA=\\begin{bmatrix}2  1  0 \\\\ 0  2  0 \\\\ 0  0  3 \\end{bmatrix}.\n$$\n如果一个子空间 $W \\subseteq \\mathbb{R}^{3}$ 满足 $A W \\subseteq W$，则称其为 $A$-不变子空间。如果 $W$ 及其正交补 $W^{\\perp}$ 都是 $A$-不变的，则称子空间 $W$ 为 $A$ 的一个约化子空间；等价地，$W$ 对 $A$ 及其关于给定内积的伴随算子 $A^{\\ast}$ 都是不变的。\n\n仅从这些定义和 $A$ 的结构出发，推导出 $\\mathbb{R}^{3}$ 的所有 $A$-不变子空间，并确定其中哪些是约化子空间。然后计算有序对 $(N_{\\mathrm{inv}}, N_{\\mathrm{red}})$，其中 $N_{\\mathrm{inv}}$ 是 $A$-不变子空间的总数，$N_{\\mathrm{red}}$ 是约化子空间的总数，此计数包含平凡子空间 $\\{0\\}$ 和 $\\mathbb{R}^{3}$。将最终答案以该有序对的形式给出。无需四舍五入，也不得使用单位。", "solution": "本题要求确定并枚举给定矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$ 的所有 $A$-不变子空间和约化子空间。设 $\\mathbb{R}^3$ 的标准基为 $\\{e_1, e_2, e_3\\}$，其中 $e_1 = (1, 0, 0)^T$，$e_2 = (0, 1, 0)^T$，$e_3 = (0, 0, 1)^T$。\n\n首先，我们分析矩阵 $A$ 的结构：\n$$\nA=\\begin{bmatrix}2  1  0 \\\\ 0  2  0 \\\\ 0  0  3 \\end{bmatrix}\n$$\n其特征多项式为 $\\det(A - \\lambda I) = (2-\\lambda)^2(3-\\lambda)$。特征值为 $\\lambda_1 = 2$（代数重数为 $m_1 = 2$）和 $\\lambda_2 = 3$（代数重数为 $m_2 = 1$）。\n\n$A$ 的一个不变子空间是子空间 $W \\subseteq \\mathbb{R}^3$，满足对所有 $w \\in W$ 都有 $Aw \\in W$。根据线性算子理论，$A$ 的任何不变子空间 $W$ 都可以分解为其与 $A$ 的广义特征空间的交集的直和。设 $G_{\\lambda}(A) = \\ker((A - \\lambda I)^m)$ 是对应于代数重数为 $m$ 的特征值 $\\lambda$ 的广义特征空间。则 $W = (W \\cap G_{2}(A)) \\oplus (W \\cap G_{3}(A))$。\n\n我们来确定 $A$ 的广义特征空间。\n对于 $\\lambda_1 = 2$：\n$A - 2I = \\begin{bmatrix}0  1  0 \\\\ 0  0  0 \\\\ 0  0  1 \\end{bmatrix}$。特征空间为 $E_2 = \\ker(A-2I) = \\text{span}\\{e_1\\}$。\n广义特征空间为 $G_2(A) = \\ker((A-2I)^2)$。\n$$\n(A-2I)^2 = \\begin{bmatrix}0  1  0 \\\\ 0  0  0 \\\\ 0  0  1 \\end{bmatrix}\\begin{bmatrix}0  1  0 \\\\ 0  0  0 \\\\ 0  0  1 \\end{bmatrix} = \\begin{bmatrix}0  0  0 \\\\ 0  0  0 \\\\ 0  0  1 \\end{bmatrix}\n$$\n$(A-2I)^2$ 的零空间是满足 $z=0$ 的向量 $(x, y, z)^T$ 的集合。因此，$G_2(A) = \\text{span}\\{e_1, e_2\\}$。\n\n对于 $\\lambda_2 = 3$：\n代数重数为 $1$，所以广义特征空间与特征空间相同。\n$A - 3I = \\begin{bmatrix}-1  1  0 \\\\ 0  -1  0 \\\\ 0  0  0 \\end{bmatrix}$。\n零空间由 $-x+y=0$ 和 $-y=0$ 给出，这意味着 $x=y=0$。因此，$G_3(A) = E_3 = \\ker(A-3I) = \\text{span}\\{e_3\\}$。\n\n现在，我们求 $A$ 在其广义特征空间上的限制算子的不变子空间。\n1. 包含在 $G_3(A) = \\text{span}\\{e_3\\}$ 中的 $A$ 的不变子空间：由于这是一个 1 维特征空间，唯一的不变子空间是 $\\{0\\}$ 和 $G_3(A)$ 本身。共有 2 个这样的子空间。\n\n2. 包含在 $G_2(A) = \\text{span}\\{e_1, e_2\\}$ 中的 $A$ 的不变子空间：$A$ 在 $G_2(A)$ 上的限制算子在基 $\\{e_1, e_2\\}$ 下的矩阵为 $A_2 = \\begin{bmatrix}2  1 \\\\ 0  2 \\end{bmatrix}$。该算子的不变子空间有：\n   - 0 维子空间：$\\{0\\}$。\n   - 任何 1 维不变子空间都必须是特征空间。唯一的特征值是 $2$，对应的特征空间为 $\\ker(A_2-2I) = \\ker(\\begin{bmatrix}0  1 \\\\ 0  0 \\end{bmatrix}) = \\text{span}\\{e_1\\}$。\n   - 2 维子空间：$G_2(A)$ 本身。\n   因此，共有 3 个包含在 $G_2(A)$ 中的不变子空间。\n\n任意一个 $A$-不变子空间 $W$ 都是 $G_2(A)$ 中的一个不变子空间与 $G_3(A)$ 中的一个不变子空间的直和。$A$-不变子空间的总数是每个广义特征空间中此类子空间数量的乘积。\n$N_{\\mathrm{inv}} = 3 \\times 2 = 6$。\n$A$-不变子空间为：\n\\begin{enumerate}\n    \\item $\\{0\\} \\oplus \\{0\\} = \\{0\\}$\n    \\item $\\{0\\} \\oplus \\text{span}\\{e_3\\} = \\text{span}\\{e_3\\}$\n    \\item $\\text{span}\\{e_1\\} \\oplus \\{0\\} = \\text{span}\\{e_1\\}$\n    \\item $\\text{span}\\{e_1\\} \\oplus \\text{span}\\{e_3\\} = \\text{span}\\{e_1, e_3\\}$\n    \\item $\\text{span}\\{e_1, e_2\\} \\oplus \\{0\\} = \\text{span}\\{e_1, e_2\\}$\n    \\item $\\text{span}\\{e_1, e_2\\} \\oplus \\text{span}\\{e_3\\} = \\mathbb{R}^3$\n\\end{enumerate}\n\n接下来，我们确定约化子空间。一个子空间 $W$ 是 $A$ 的约化子空间，如果它在 $A$ 及其伴随算子 $A^*$ 下都是不变的。由于我们使用的是标准欧几里得内积，$A^* = A^T$。\n$$\nA^T = \\begin{bmatrix}2  0  0 \\\\ 1  2  0 \\\\ 0  0  3 \\end{bmatrix}\n$$\n一个子空间是约化子空间，当且仅当它既是 $A$-不变子空间，也是 $A^T$-不变子空间。我们继续寻找 $A^T$ 的不变子空间。$A^T$ 的特征值与 $A$ 的相同：$\\lambda_1 = 2$ 和 $\\lambda_2 = 3$。\n\n$A^T$ 的广义特征空间为：\n对于 $\\lambda_1=2$：$A^T - 2I = \\begin{bmatrix}0  0  0 \\\\ 1  0  0 \\\\ 0  0  1 \\end{bmatrix}$。特征空间为 $E'_2 = \\ker(A^T-2I) = \\text{span}\\{e_2\\}$。\n广义特征空间 $G_2(A^T) = \\ker((A^T-2I)^2)$。\n$$\n(A^T-2I)^2 = \\begin{bmatrix}0  0  0 \\\\ 0  0  0 \\\\ 0  0  1 \\end{bmatrix}\n$$\n零空间是 $z=0$ 的空间，所以 $G_2(A^T) = \\text{span}\\{e_1, e_2\\}$。\n\n对于 $\\lambda_2=3$：$G_3(A^T) = \\ker(A^T-3I) = \\text{span}\\{e_3\\}$。\n\n$A^T$ 的不变子空间可类似地构造。\n1. 在 $G_3(A^T) = \\text{span}\\{e_3\\}$ 内的不变子空间是 $\\{0\\}$ 和 $\\text{span}\\{e_3\\}$。（2个子空间）\n2. 在 $G_2(A^T) = \\text{span}\\{e_1, e_2\\}$ 内的不变子空间：$A^T$ 在此空间上的限制算子的矩阵为 $A^T_2 = \\begin{bmatrix}2  0 \\\\ 1  2 \\end{bmatrix}$。\n   - $\\{0\\}$\n   - 1 维不变子空间（特征空间）是 $\\ker(A^T_2-2I) = \\ker(\\begin{bmatrix}0  0 \\\\ 1  0 \\end{bmatrix}) = \\text{span}\\{e_2\\}$。\n   - $G_2(A^T)$ 本身。\n   共有 3 个这样的子空间。\n\n$A^T$-不变子空间为：\n\\begin{enumerate}\n    \\item $\\{0\\}$\n    \\item $\\text{span}\\{e_3\\}$\n    \\item $\\text{span}\\{e_2\\}$\n    \\item $\\text{span}\\{e_2, e_3\\}$\n    \\item $\\text{span}\\{e_1, e_2\\}$\n    \\item $\\mathbb{R}^3$\n\\end{enumerate}\n\n$A$ 的约化子空间是同时出现在两个不变子空间列表中的子空间。\n比较这两个列表：\n- $\\{0\\}$ 是公共的。\n- $\\text{span}\\{e_3\\}$ 是公共的。\n- $\\text{span}\\{e_1\\}$ 仅是 $A$-不变的。\n- $\\text{span}\\{e_1, e_3\\}$ 仅是 $A$-不变的。\n- $\\text{span}\\{e_1, e_2\\}$ 是公共的。\n- $\\mathbb{R}^3$ 是公共的。\n- $\\text{span}\\{e_2\\}$ 仅是 $A^T$-不变的。\n- $\\text{span}\\{e_2, e_3\\}$ 仅是 $A^T$-不变的。\n\n约化子空间是 $\\{0\\}$，$\\text{span}\\{e_3\\}$，$\\text{span}\\{e_1, e_2\\}$ 和 $\\mathbb{R}^3$。\n共有 $N_{\\mathrm{red}} = 4$ 个约化子空间。\n\n约化子空间 $W$ 的一个等价定义是，$W$ 及其正交补 $W^\\perp$ 都是 $A$-不变的。\n- 对于 $W = \\{0\\}$，$W^\\perp = \\mathbb{R}^3$。两者都是 $A$-不变的。\n- 对于 $W = \\mathbb{R}^3$，$W^\\perp = \\{0\\}$。两者都是 $A$-不变的。\n- 对于 $W = \\text{span}\\{e_3\\}$，$W^\\perp = \\text{span}\\{e_1, e_2\\}$。两者都在 $A$-不变子空间列表中。\n- 对于 $W = \\text{span}\\{e_1, e_2\\}$，$W^\\perp = \\text{span}\\{e_3\\}$。两者都在 $A$-不变子空间列表中。\n这证实了这四个约化子空间。\n\n$A$-不变子空间的总数是 $N_{\\mathrm{inv}} = 6$。约化子空间的总数是 $N_{\\mathrm{red}} = 4$。\n所求的有序对为 $(N_{\\mathrm{inv}}, N_{\\mathrm{red}})$。", "answer": "$$\n\\boxed{(6, 4)}\n$$", "id": "3551519"}, {"introduction": "在理论基础之上，我们转向计算线性代数的一个基石：Arnoldi迭代。这个动手编程练习将演示如何通过生成Krylov子空间的基来算法化地构造一个不变子空间。您会发现，当该子空间成为不变子空间时，算法会发生一种被称为“幸运中断”(lucky breakdown)的现象，这为理论概念提供了清晰的计算信号 ([@problem_id:3551503])。", "problem": "给定一个方形实矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个非零向量 $b \\in \\mathbb{R}^n$。令 $m$ 阶 Krylov 子空间定义为\n$$\n\\mathcal{K}_m(A,b) \\equiv \\operatorname{span}\\{b, Ab, A^2 b, \\dots, A^{m-1} b\\}.\n$$\n如果一个子空间 $\\mathcal{S} \\subseteq \\mathbb{R}^n$ 满足 $A \\mathcal{S} \\subseteq \\mathcal{S}$，则称其在 $A$ 下是不变的（或称为 $A$-不变子空间）。您的任务是，对于每个给定的矩阵-向量对 $(A,b)$，计算使得 $\\mathcal{K}_m(A,b)$ 在 $A$ 下不变的最小正整数 $m$，并通过 Arnoldi 关系的残差来数值验证这种不变性。\n\n您的推理只能基于以下基本定义和经过充分检验的事实：\n- Krylov 子空间 $\\mathcal{K}_m(A,b)$是通过将 $A$ 重复作用于 $b$ 构建的，其维数最多为 $m$ 且最多为 $n$。\n- Arnoldi 过程为 $\\mathcal{K}_m(A,b)$ 构建一个标准正交基 $V_m = [v_1,\\dots,v_m]$（其中 $v_1 = b/\\lVert b\\rVert_2$）和一个上 Hessenberg 矩阵 $H_m \\in \\mathbb{R}^{m \\times m}$，它们满足 Arnoldi 关系\n$$\nA V_m = V_m H_m + h_{m+1,m} v_{m+1} e_m^\\top,\n$$\n其中 $e_m \\in \\mathbb{R}^m$ 是第 $m$ 个标准基向量且 $h_{m+1,m} \\ge 0$。在精确算术中，$h_{m+1,m} = 0$ 当且仅当 $\\mathcal{K}_m(A,b)$ 在 $A$ 下是不变的。\n- 有限精度下的数值计算只能在一定容差范围内确定等式 $h_{m+1,m} = 0$ 是否成立。\n\n设计一个算法，给定 $(A,b)$ 和一个容差 $\\tau  0$，计算使得 Arnoldi 过程满足 $h_{m+1,m} \\le \\tau$ 的最小 $m$。将此解释为不变性的数值检测。然后，通过计算 Arnoldi 残差的 Frobenius 范数来验证不变性\n$$\nR_m \\equiv A V_m - V_m H_m,\n$$\n当 $h_{m+1,m}$ 在数值上为零时，该范数也应在数值上很小。使用带二次再正交化的修正 Gram-Schmidt 方法来提高数值稳定性。使用欧几里得范数进行向量归一化，使用 Frobenius 范数计算矩阵范数。\n\n将您的算法实现为一个完整的程序，用于解决以下测试用例。对于每种情况，使用容差 $\\tau = 10^{-12}$：\n\n- 情况1（具有多个活动特征值的可对角化矩阵）：令\n$$\nA_1 = \\operatorname{diag}(1,2,4,7,11), \\quad b_1 = [1, \\, 1, \\, 0, \\, 1, \\, 0]^\\top.\n$$\n- 情况2（单个 Jordan 块，不可对角化，完整链）：令 $A_2 \\in \\mathbb{R}^{4 \\times 4}$ 为特征值为2的 Jordan 块，即 $(A_2)_{ii} = 2$ 且当 $i=1,2,3$ 时 $(A_2)_{i,i+1} = 1$，其余元素为零。令\n$$\nb_2 = [1, \\, 0, \\, 0, \\, 0]^\\top.\n$$\n- 情况3（输入为特征向量，立即不变）：令\n$$\nA_3 = \\begin{bmatrix}\n3  1  0  0 \\\\\n0  5  2  0 \\\\\n0  0  7  0 \\\\\n0  0  0  9\n\\end{bmatrix}, \\quad b_3 = [0, \\, 0, \\, 1, \\, 0]^\\top.\n$$\n- 情况4（带有幂零块的分块对角矩阵）：令\n$$\nA_4 = \\begin{bmatrix}\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  5  0 \\\\\n0  0  0  6\n\\end{bmatrix}, \\quad b_4 = [1, \\, 0, \\, 0, \\, 0]^\\top.\n$$\n\n对于每种情况，您的程序必须：\n- 运行 Arnoldi 过程，直到遇到第一个满足 $h_{m+1,m} \\le \\tau$ 的索引 $m$（这是声明数值不变性的最小 $m$）。\n- 计算 Frobenius 范数 $\\lVert R_m \\rVert_F$ 以验证 Arnoldi 关系，从而验证不变性。\n- 返回由整数 $m$、标量 $h_{m+1,m}$ 和标量 $\\lVert R_m \\rVert_F$组成的三元组。将两个标量输出四舍五入到12位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是一个三元列表 $[m, h, r]$，按上述顺序对应一个测试用例。例如，包含四个测试用例的输出应如下所示\n$$\n[[m_1,h_1,r_1],[m_2,h_2,r_2],[m_3,h_3,r_3],[m_4,h_4,r_4]].\n$$\n不应打印任何额外文本。", "solution": "该问题要求我们对于给定的实矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和非零向量 $b \\in \\mathbb{R}^n$，确定最小的正整数 $m$，使得 Krylov 子空间 $\\mathcal{K}_m(A,b) = \\operatorname{span}\\{b, Ab, \\dots, A^{m-1} b\\}$ 是 $A$ 的一个不变子空间。一个子空间 $\\mathcal{S}$ 在 $A$ 下是不变的，如果对于任意向量 $s \\in \\mathcal{S}$，向量 $As$ 也属于 $\\mathcal{S}$，记作 $A\\mathcal{S} \\subseteq \\mathcal{S}$。\n\nArnoldi 迭代是为 $\\mathcal{K}_m(A,b)$ 构建标准正交基的直接方法，并提供了检测不变性的准则。该过程生成一系列标准正交向量 $\\{v_1, v_2, \\dots, v_m\\}$，它们构成 $\\mathcal{K}_m(A,b)$ 的一个基，其中 $v_1 = b / \\lVert b \\rVert_2$。这些向量作为列存储在一个矩阵 $V_m = [v_1, v_2, \\dots, v_m] \\in \\mathbb{R}^{n \\times m}$ 中。该算法还产生一个上 Hessenberg 矩阵 $H_m \\in \\mathbb{R}^{m \\times m}$。这些矩阵通过 Arnoldi 关系关联起来：\n$$\nA V_m = V_m H_m + h_{m+1,m} v_{m+1} e_m^\\top\n$$\n其中 $v_{m+1}$ 是一个与 $V_m$ 的列正交的单位向量，$e_m \\in \\mathbb{R}^m$ 是第 $m$ 个标准基向量，且 $h_{m+1,m} = \\lVert (I - V_m V_m^\\top) A v_m \\rVert_2 \\ge 0$。\n\n子空间 $\\mathcal{K}_m(A,b)$ 在 $A$ 下不变，当且仅当对于所有的 $j \\in \\{1, \\dots, m\\}$，都有 $A v_j \\in \\mathcal{K}_m(A,b)$。由于 Arnoldi 过程的结构，此条件简化为检查是否有 $A v_m \\in \\mathcal{K}_m(A,b)$。向量 $(I - V_m V_m^\\top) A v_m$ 表示 $A v_m$ 在与 $\\mathcal{K}_m(A,b)$ 正交方向上的分量。因此，$A v_m \\in \\mathcal{K}_m(A,b)$ 当且仅当该正交分量为零向量。该向量的范数恰好是 $h_{m+1,m}$。因此，在精确算术中，Krylov 子空间 $\\mathcal{K}_m(A,b)$ 在 $A$ 下不变当且仅当 $h_{m+1,m}=0$。这标志着 Arnoldi 过程的“崩溃”（breakdown），因为无法生成新的基向量 $v_{m+1}$。满足条件的最小 $m$ 对应于向量 $b$ 相对于矩阵 $A$ 的最小多项式的次数。\n\n在有限精度算術中，我們通過測試 $h_{m+1,m}$ 是否小於給定的容差 $\\tau  0$ 來檢查數值不變性。任務是找到滿足 $h_{m+1,m} \\le \\tau$ 的最小正整數 $m$。\n\n要实现的算法是使用修正 Gram-Schmidt (MGS) 方法进行正交化的 Arnoldi 迭代。为了减轻 MGS 中可能出现的正交性损失，算法中包含了一个二次再正交化步骤。\n\n该算法流程如下：\n1.  初始化：给定 $A \\in \\mathbb{R}^{n \\times n}$，$b \\in \\mathbb{R}^n$ 和容差 $\\tau  0$。令 $n$ 为空间维数。预分配矩阵 $V \\in \\mathbb{R}^{n \\times (n+1)}$ 和 $H \\in \\mathbb{R}^{(n+1) \\times n}$。\n2.  开始：计算第一个基向量 $v_1 = b / \\lVert b \\rVert_2$。将其存储为 $V$ 的第一列。\n3.  对 $m = 1, 2, \\dots, n$进行迭代：\n    a. 令 $v_m$ 为第 $m$ 个基向量（$V$ 的第 $m$ 列）。计算新向量 $w = A v_m$。\n    b. 将 $w$ 与现有基 $\\{v_1, \\dots, v_m\\}$ 正交化。这是 MGS 的第一遍。对于 $j = 1, \\dots, m$：\n       i.  计算投影系数：$h_{j,m} = v_j^\\top w$。将其存入矩阵 $H$。\n       ii. 从 $w$ 中减去投影：$w \\leftarrow w - h_{j,m} v_j$。\n    c. 为提高数值稳定性进行再正交化。这是第二遍。对于 $j = 1, \\dots, m$：\n       i.  计算修正项：$\\delta h = v_j^\\top w$。\n       ii. 更新 Hessenberg 矩阵的元素：$h_{j,m} \\leftarrow h_{j,m} + \\delta h$。\n       iii. 更新向量：$w \\leftarrow w - \\delta h v_j$。\n    d. 计算所得向量 $w$ 的范数，即 $h_{m+1,m} = \\lVert w \\rVert_2$。将其存入 $H$。\n    e. 检查终止条件：如果 $h_{m+1,m} \\le \\tau$，则过程终止。子空间达到数值不变性的最小维数是 $m$。跳出循环。\n    f. 如果过程未终止，则进行归一化以获得下一个基向量：$v_{m+1} = w / h_{m+1,m}$。将其存储为 $V$ 的第 $(m+1)$ 列。\n\n在第 $m$ 步终止时，我们得到标准正交基 $V_m = [v_1, \\dots, v_m]$ 和上 Hessenberg 矩阵 $H_m \\in \\mathbb{R}^{m \\times m}$。Arnoldi 关系式的残差是矩阵 $R_m = A V_m - V_m H_m$。根据该关系式，$R_m = h_{m+1,m} v_{m+1} e_m^\\top$。为了验证数值不变性和实现的正确性，我们计算 Frobenius 范数 $\\lVert R_m \\rVert_F$。理论上，我们有 $\\lVert R_m \\rVert_F = \\lVert h_{m+1,m} v_{m+1} e_m^\\top \\rVert_F = h_{m+1,m} \\lVert v_{m+1} e_m^\\top \\rVert_F = h_{m+1,m}$。直接计算 $\\lVert A V_m - V_m H_m \\rVert_F$ 可作为一个稳健的数值检验。\n\n每个测试用例的最终输出将是一个三元组 $(m, h_{m+1,m}, \\lVert R_m \\rVert_F)$，其中 $m$ 是不变子空间的维数，$h_{m+1,m}$ 是触发终止的值，$\\lVert R_m \\rVert_F$ 是计算出的残差的 Frobenius 范数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef arnoldi_invariance(A, b, tol=1e-12):\n    \"\"\"\n    Computes the smallest m for which the Krylov subspace K_m(A,b) is invariant.\n\n    Args:\n        A (np.ndarray): The square matrix of size n x n.\n        b (np.ndarray): The starting vector of size n.\n        tol (float): The tolerance for h_{m+1,m} to be considered zero.\n\n    Returns:\n        tuple: A triplet (m, h, r) where:\n            m (int): The smallest dimension of the invariant Krylov subspace.\n            h (float): The value of h_{m+1,m} at termination.\n            r (float): The Frobenius norm of the residual matrix R_m = A V_m - V_m H_m.\n    \"\"\"\n    n = A.shape[0]\n    V = np.zeros((n, n + 1), dtype=float)\n    H = np.zeros((n + 1, n), dtype=float)\n\n    # Step 1: Initialize\n    V[:, 0] = b / np.linalg.norm(b)\n\n    for m in range(n):\n        # Step 2: Generate new vector\n        v_m = V[:, m]\n        w = A @ v_m\n\n        # Step 3: Modified Gram-Schmidt with reorthogonalization\n        # First pass\n        h_col = V[:, :m+1].T @ w\n        w = w - V[:, :m+1] @ h_col\n        H[:m+1, m] = h_col\n\n        # Second reorthogonalization pass for stability\n        h_corr = V[:, :m+1].T @ w\n        w = w - V[:, :m+1] @ h_corr\n        H[:m+1, m] += h_corr\n        \n        # Step 4: Compute h_{m+1,m} and check for invariance\n        h_next = np.linalg.norm(w)\n        H[m+1, m] = h_next\n\n        # Termination condition\n        if h_next = tol:\n            m_final = m + 1\n            Vm = V[:, :m_final]\n            Hm = H[:m_final, :m_final]\n            \n            # Verification: Compute residual norm\n            Rm = A @ Vm - Vm @ Hm\n            res_norm = np.linalg.norm(Rm, 'fro')\n            \n            return m_final, h_next, res_norm\n\n        # Step 5: Normalize to get next basis vector\n        V[:, m+1] = w / h_next\n\n    # If loop completes, the space is the full R^n\n    m_final = n\n    Vm = V[:, :n]\n    Hm = H[:n, :n]\n    Rm = A @ Vm - Vm @ Hm\n    res_norm = np.linalg.norm(Rm, 'fro')\n    h_final = H[n, n-1]\n\n    return m_final, h_final, res_norm\n\n\ndef solve():\n    \"\"\"\n    Defines and solves the test suite of problems.\n    \"\"\"\n    tol = 1e-12\n\n    # Case 1\n    A1 = np.diag([1, 2, 4, 7, 11])\n    b1 = np.array([1, 1, 0, 1, 0], dtype=float)\n\n    # Case 2\n    A2 = np.diag([2.0]*4) + np.diag([1.0]*3, k=1)\n    b2 = np.array([1, 0, 0, 0], dtype=float)\n\n    # Case 3\n    A3 = np.array([\n        [3, 1, 0, 0],\n        [0, 5, 2, 0],\n        [0, 0, 7, 0],\n        [0, 0, 0, 9]\n    ], dtype=float)\n    b3 = np.array([0, 0, 1, 0], dtype=float)\n    \n    # Case 4\n    A4 = np.array([\n        [0, 1, 0, 0],\n        [0, 0, 0, 0],\n        [0, 0, 5, 0],\n        [0, 0, 0, 6]\n    ], dtype=float)\n    b4 = np.array([1, 0, 0, 0], dtype=float)\n    \n    test_cases = [\n        (A1, b1),\n        (A2, b2),\n        (A3, b3),\n        (A4, b4),\n    ]\n\n    results = []\n    for A, b in test_cases:\n        m, h, r = arnoldi_invariance(A, b, tol)\n        # Format h and r to 12 decimal places as strings, m is an integer\n        h_str = f\"{h:.12f}\"\n        r_str = f\"{r:.12f}\"\n        results.append(f\"[{m},{h_str},{r_str}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3551503"}, {"introduction": "最后的这项练习介绍了一种功能强大且优雅的方法，它利用复分析工具来计算不变子空间。通过对Riesz谱投影算子进行围道积分的数值近似，您可以分离出与特定特征值簇相关的谱不变子空间。该技术在现代大规模计算中尤为重要，并能让我们对算子的谱特性有更深刻的理解 ([@problem_id:3551525])。", "problem": "考虑一个复方阵 $A \\in \\mathbb{C}^{n \\times n}$ 以及复平面中的一条简单闭合围线 $\\Gamma$，该围线是一个由 $z(\\theta) = c + r e^{\\mathrm{i}\\theta}$ 参数化的圆，其圆心为 $c \\in \\mathbb{C}$，半径为 $r \\in \\mathbb{R}_{0}$，角度 $\\theta \\in [0,2\\pi)$ 以弧度为单位。与 $A$ 的被 $\\Gamma$ 包围的特征值相关联的广义特征空间直和上的谱投影算子 $P$ 可以通过 Riesz 投影算子定义为围线积分\n$$\nP = \\frac{1}{2\\pi \\mathrm{i}} \\oint_{\\Gamma} (z I - A)^{-1} \\,\\mathrm{d}z,\n$$\n其中 $I$ 表示单位矩阵，$(z I - A)^{-1}$ 是 $A$ 的预解式。如果 $A\\mathcal{S} \\subseteq \\mathcal{S}$，则子空间 $\\mathcal{S}$ 是 $A$-不变的。对于一个值域为 $\\mathcal{S}$ 的投影算子 $P$，$A$-不变性等价于 $(I - P) A P = 0$。您将设计并实现一个基于求积的数值方法来近似 $P$，然后估计不变性的后向误差。\n\n仅从上述核心定义和标准数值求积原理出发，完成以下任务：\n- 使用 $z(\\theta)=c+r e^{\\mathrm{i}\\theta}$（其中 $\\theta \\in [0,2\\pi)$，单位为弧度）对圆形围线 $\\Gamma$ 进行参数化，并使用在 $\\theta$ 上有 $N$ 个等距节点的梯形法则来离散化 $P$ 的积分。\n- 通过在梯形法则于圆上导出的 $N$ 个节点 $\\{z_k\\}$ 处计算并求和预解式 $(z_k I - A)^{-1}$，来计算 $P$ 的求积近似 $P_N$（作为一个完整的 $n \\times n$ 复矩阵）。在计算预解式作用于 $I$ 时，使用稳定的线性求解方法，而不是显式矩阵求逆。\n- 量化该近似的三个诊断指标：\n  1. 近似子空间维度 $d_N$，定义为 $\\operatorname{trace}(P_N)$ 的实部。对于精确的投影算子，该值等于 $\\Gamma$ 内所有特征值的代数重数之和。\n  2. 幂等缺陷 $\\delta_{\\mathrm{idem}} = \\frac{\\lVert P_N^2 - P_N \\rVert_{\\mathrm{F}}}{\\lVert P_N \\rVert_{\\mathrm{F}}}$，其中 $\\lVert \\cdot \\rVert_{\\mathrm{F}}$ 表示 Frobenius 范数，用于衡量 $P_N$ 偏离投影算子性质的程度。\n  3. 不变性后向误差的估计 $\\delta_{\\mathrm{inv}} = \\frac{\\lVert (I - P_N) A P_N \\rVert_{\\mathrm{F}}}{\\lVert A \\rVert_{\\mathrm{F}}}$。其理由是，使得 $\\operatorname{range}(P_N)$ 对于 $A + \\Delta A$ 成为不变子空间的最小 Frobenius 范数扰动 $\\Delta A$ 可以通过将非对角块 $(I - P_N) A P_N$ 置零来实现。\n\n您的程序必须实现上述方法，并为以下每个测试用例计算这三个诊断指标。所有角度必须以弧度解释，所有范数必须是 Frobenius 范数。矩阵和参数如下：\n\n- 测试用例 1（厄米特矩阵聚类，清晰分离）：\n  - $A_1 = \\operatorname{diag}(-2.0,-1.5,0.1,0.2,3.0,4.0)$，\n  - $c_1 = 0.15$， $r_1 = 0.15$， $N_1 = 32$。\n- 测试用例 2（非正规矩阵，特征值靠近边界，较粗的求积）：\n  - $A_2$ 是一个上三角矩阵，其对角线元素为 $(-1.0, 0.5, 0.8, 2.0, 3.0)$，超对角线元素全为 $0.1$，\n  - $c_2 = 0.7$， $r_2 = 0.22$， $N_2 = 16$。\n- 测试用例 3（围线内没有特征值）：\n  - $A_3 = \\operatorname{diag}(1.1,1.2,1.3,2.0,2.5)$，\n  - $c_3 = 0.0$， $r_3 = 0.5$， $N_3 = 32$。\n- 测试用例 4（与测试用例 2 相同，但使用更精细的求积以比较 $N$ 的影响）：\n  - $A_4 = A_2$，\n  - $c_4 = 0.7$， $r_4 = 0.22$， $N_4 = 64$。\n\n对于每个测试用例 $(A,c,r,N)$，计算：\n- $d_N = \\Re(\\operatorname{trace}(P_N))$，\n- $\\delta_{\\mathrm{idem}}$，\n- $\\delta_{\\mathrm{inv}}$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个列表对应一个测试用例，顺序如上。每个列表必须包含三个浮点数 $[d_N, \\delta_{\\mathrm{idem}}, \\delta_{\\mathrm{inv}}]$。确切格式为：\n$[[d_1,\\delta_{\\mathrm{idem},1},\\delta_{\\mathrm{inv},1}],[d_2,\\delta_{\\mathrm{idem},2},\\delta_{\\mathrm{inv},2}],[d_3,\\delta_{\\mathrm{idem},3},\\delta_{\\mathrm{inv},3}],[d_4,\\delta_{\\mathrm{idem},4},\\delta_{\\mathrm{inv},4}]]$。", "solution": "本题的核心任务是利用数值积分来近似计算谱投影算子 $P$，该算子由Riesz围线积分定义。\n$$ P = \\frac{1}{2\\pi \\mathrm{i}} \\oint_{\\Gamma} (z I - A)^{-1} \\,\\mathrm{d}z $$\n我们将围线 $\\Gamma$ 参数化为圆 $z(\\theta) = c + r e^{\\mathrm{i}\\theta}$，其中 $\\theta \\in [0, 2\\pi)$。微分元为 $\\mathrm{d}z = r \\mathrm{i} e^{\\mathrm{i}\\theta} \\mathrm{d}\\theta$。代入积分表达式并简化，得到：\n$$ P = \\frac{r}{2\\pi} \\int_{0}^{2\\pi} e^{\\mathrm{i}\\theta} (z(\\theta) I - A)^{-1} \\,\\mathrm{d}\\theta $$\n我们使用 $N$ 个等距节点的梯形法则来近似此积分。离散节点为 $\\theta_k = \\frac{2\\pi k}{N}$，对应的复平面上的点为 $z_k = c + r e^{\\mathrm{i}\\theta_k}$（$k=0, \\dots, N-1$）。积分的数值近似 $P_N$ 为：\n$$ P_N = \\frac{2\\pi}{N} \\sum_{k=0}^{N-1} \\left( \\frac{r}{2\\pi} e^{\\mathrm{i}\\theta_k} (z(\\theta_k) I - A)^{-1} \\right) = \\frac{r}{N} \\sum_{k=0}^{N-1} e^{\\mathrm{i}\\theta_k} (z_k I - A)^{-1} $$\n在计算中，我们通过求解线性方程组 $(z_k I - A)X_k = I$ 来获得预解式矩阵 $X_k = (z_k I - A)^{-1}$，以保证数值稳定性。\n计算出 $P_N$ 后，我们评估三个指定的诊断指标：\n1.  **近似维度 $d_N$**: $\\Re(\\operatorname{trace}(P_N))$。它估计了围线内特征值的总代数重数。\n2.  **幂等缺陷 $\\delta_{\\mathrm{idem}}$**: $\\frac{\\lVert P_N^2 - P_N \\rVert_{\\mathrm{F}}}{\\lVert P_N \\rVert_{\\mathrm{F}}}$。它衡量了计算出的 $P_N$ 偏离真实投影算子（必须满足 $P^2=P$）的程度。\n3.  **不变性后向误差 $\\delta_{\\mathrm{inv}}$**: $\\frac{\\lVert (I - P_N) A P_N \\rVert_{\\mathrm{F}}}{\\lVert A \\rVert_{\\mathrm{F}}}$。它量化了使 $P_N$ 的值域成为不变子空间所需的对 $A$ 的最小相对扰动的大小。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_projector_diagnostics(A, c, r, N):\n    \"\"\"\n    Computes the spectral projector approximation and related diagnostics.\n\n    Args:\n        A (np.ndarray): The complex square matrix.\n        c (complex): The center of the circular contour.\n        r (float): The radius of the circular contour.\n        N (int): The number of quadrature nodes.\n\n    Returns:\n        list: A list containing [d_N, delta_idem, delta_inv].\n    \"\"\"\n    n = A.shape[0]\n    I = np.eye(n, dtype=np.complex128)\n    P_N = np.zeros((n, n), dtype=np.complex128)\n    \n    # Trapezoidal rule for the contour integral\n    for k in range(N):\n        theta_k = 2 * np.pi * k / N\n        exp_theta = np.exp(1j * theta_k)\n        z_k = c + r * exp_theta\n        \n        # Form resolvent matrix M_k = z_k * I - A\n        M_k = z_k * I - A\n        \n        # Solve (z_k * I - A) * X = I to get the resolvent (z_k * I - A)^-1\n        # This is more stable than explicit inversion.\n        resolvent_matrix = np.linalg.solve(M_k, I)\n        \n        # Add the term for the sum: e^{i*theta_k} * (z_k*I - A)^-1\n        P_N += exp_theta * resolvent_matrix\n\n    # Scale the sum by the prefactor r/N\n    P_N *= (r / N)\n\n    # 1. Approximate subspace dimension\n    d_N = np.trace(P_N).real\n\n    # 2. Idempotency defect\n    norm_PN = np.linalg.norm(P_N, 'fro')\n    if norm_PN == 0:\n        # If P_N is the zero matrix, it is perfectly idempotent.\n        delta_idem = 0.0\n    else:\n        idempotency_defect_num = np.linalg.norm(P_N @ P_N - P_N, 'fro')\n        delta_idem = idempotency_defect_num / norm_PN\n\n    # 3. Invariance backward error\n    norm_A = np.linalg.norm(A, 'fro')\n    if norm_A == 0:\n        # If A is the zero matrix, invariance is trivial.\n        delta_inv = 0.0\n    else:\n        invariance_defect_num = np.linalg.norm((I - P_N) @ A @ P_N, 'fro')\n        delta_inv = invariance_defect_num / norm_A\n\n    return [d_N, delta_idem, delta_inv]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Test case 1: Hermitian cluster, clear separation\n    A1 = np.diag([-2.0, -1.5, 0.1, 0.2, 3.0, 4.0])\n    c1, r1, N1 = 0.15, 0.15, 32\n\n    # Test case 2: nonnormal, eigenvalues near boundary, coarser quadrature\n    diag2 = np.array([-1.0, 0.5, 0.8, 2.0, 3.0])\n    superdiag2 = np.array([0.1, 0.1, 0.1, 0.1])\n    A2 = np.diag(diag2) + np.diag(superdiag2, k=1)\n    c2, r2, N2 = 0.7, 0.22, 16\n\n    # Test case 3: no eigenvalues inside the contour\n    A3 = np.diag([1.1, 1.2, 1.3, 2.0, 2.5])\n    c3, r3, N3 = 0.0, 0.5, 32\n\n    # Test case 4: same as test case 2, finer quadrature\n    A4 = A2\n    c4, r4, N4 = 0.7, 0.22, 64\n\n    test_cases = [\n        (A1, c1, r1, N1),\n        (A2, c2, r2, N2),\n        (A3, c3, r3, N3),\n        (A4, c4, r4, N4),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, c, r, N = case\n        # Ensure matrix A is complex for calculations\n        A_complex = A.astype(np.complex128)\n        result = compute_projector_diagnostics(A_complex, complex(c), r, N)\n        results.append(result)\n\n    # Format the final output string as specified\n    formatted_results = ','.join([str(res) for res in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "3551525"}]}