{"hands_on_practices": [{"introduction": "理论分析揭示了经典格拉姆-施密特（CGS）方法在有限精度计算中的不稳定性。本实践旨在通过一个具体的数值实验来直观地展示这一问题。你将对一组精心设计的、包含近乎共线向量的矩阵，分别应用经典格拉姆-施密特（CGS）和修正格拉姆-施密特（MGS）方法，并通过计算最终基向量的正交性误差，来量化和对比这两种算法的数值稳定性。[@problem_id:2419987]", "problem": "给定一个在实向量空间中构造的近似共线的列向量族。对于给定的整数 $n \\ge k \\ge 1$ 和实数参数 $\\epsilon \\ge 0$，定义 $\\mathbb{R}^n$ 的标准基 $\\{e_1,\\dots,e_n\\}$，并构造 $n \\times k$ 矩阵 $A = [a_1,\\dots,a_k]$，其列向量为\n- $a_1 = e_1$，\n- 对于 $2 \\le j \\le k$，$a_j = e_1 + \\epsilon^{j-1} e_j$。\n所有计算都应在双精度浮点运算中执行。\n\n任务：\n1. 使用上面定义的矩阵 $A$，对 $A$ 的列向量进行标准正交化，得到两个结果：\n   - 一个使用经典格拉姆-施密特 (Classical Gram-Schmidt, CGS) 方法，得到矩阵 $Q^{(c)} \\in \\mathbb{R}^{n \\times k}$，\n   - 一个使用修正格拉姆-施密特 (Modified Gram-Schmidt, MGS) 方法，得到矩阵 $Q^{(m)} \\in \\mathbb{R}^{n \\times k}$。\n   对于这两种方法，如果用于归一化列向量的范数为零，则 $Q$ 中的相应列必须设置成零向量。\n2. 对任意 $Q \\in \\mathbb{R}^{n \\times k}$，其正交性误差定义如下。设 $q_j$ 表示 $Q$ 的第 $j$ 列，设 $\\delta = 10^{-14}$，并定义索引集 $J = \\{ j \\in \\{1,\\dots,k\\} : \\|q_j\\|_2  \\delta \\}$。设 $r = |J|$，并设 $Q_J \\in \\mathbb{R}^{n \\times r}$ 是一个子矩阵，它只包含由 $J$ 索引的 $Q$ 的列（按 $j$ 的升序排列）。定义\n   $$E(Q) = \\begin{cases}\n   \\left\\| Q_J^{\\mathsf{T}} Q_J - I_r \\right\\|_F,  r \\ge 1, \\\\\n   0,  r = 0,\n   \\end{cases}$$\n   其中 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数（Frobenius norm），$I_r$ 是 $r \\times r$ 的单位矩阵。\n3. 对于下面测试套件中的每个测试用例，根据 $(n,k,\\epsilon)$ 构造 $A$，计算 $Q^{(c)}$ 和 $Q^{(m)}$，然后计算正交性误差对 $\\big(E(Q^{(c)}), E(Q^{(m)})\\big)$。\n\n测试套件：\n- 用例 1 (happy path): $(n,k,\\epsilon) = (6, 3, 10^{-8})$。\n- 用例 2 (boundary, exact collinearity of all but one direction): $(n,k,\\epsilon) = (6, 3, 0)$。\n- 用例 3 (deeper chain of near-collinearity): $(n,k,\\epsilon) = (10, 8, 10^{-12})$。\n- 用例 4 (edge, perturbations near machine precision): $(n,k,\\epsilon) = (6, 5, 10^{-16})$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，包含一个Python风格的浮点数列表的列表形式的结果：\n  $$\\big[ [E(Q^{(c)}_1), E(Q^{(m)}_1)], [E(Q^{(c)}_2), E(Q^{(m)}_2)], [E(Q^{(c)}_3), E(Q^{(m)}_3)], [E(Q^{(c)}_4), E(Q^{(m)}_4)] \\big],$$\n  其中下标表示测试用例编号。数字应以标准十进制或科学记数法打印，不含任何附加文本。程序不得读取任何输入，且必须能直接运行。", "solution": "提交的问题陈述已经过验证，并被认定是有效的。这是一个计算工程学和数值线性代数领域的良态问题，旨在展示经典格拉姆-施密特 (Classical Gram-Schmidt, CGS) 和修正格拉姆-施密特 (Modified Gram-Schmidt, MGS) 这两种标准正交化算法在数值稳定性上的差异。\n\n任务是比较将CGS和MGS应用于一组近似共线向量时正交性的损失情况。共线程度由参数 $\\epsilon$ 控制。当 $\\epsilon$ 很小时，这些向量在数值上变得难以区分，这暴露了数值不稳定算法的弱点。\n\n首先，我们为给定的整数 $n \\ge k \\ge 1$ 和实数参数 $\\epsilon \\ge 0$ 定义矩阵 $A \\in \\mathbb{R}^{n \\times k}$。其列向量 $a_j$ (其中 $j=1, \\dots, k$) 的构造如下：\n- $a_1 = e_1$\n- $a_j = e_1 + \\epsilon^{j-1} e_j$ 对于 $2 \\le j \\le k$\n其中 $\\{e_1, \\dots, e_n\\}$ 是 $\\mathbb{R}^n$ 的标准基。当 $\\epsilon \\to 0$ 时，对于 $j \\ge 2$ 的向量 $a_j$ 会趋近于 $a_1$，从而产生一族近似线性相关的向量。这种构造对标准正交化算法提出了严峻的考验。所有计算都在标准的双精度浮点运算中执行，其中机器ε (epsilon) 大约是 $\\epsilon_{mach} \\approx 2.22 \\times 10^{-16}$。\n\n两种标准正交化算法如下：\n\n**经典格拉姆-施密特 (Classical Gram-Schmidt, CGS)**\nCGS算法从输入向量 $\\{a_1, \\dots, a_k\\}$ 生成一组标准正交向量 $\\{q_1, \\dots, q_k\\}$。对于每个向量 $a_j$，它会减去其在先前计算出的标准正交向量 $\\{q_1, \\dots, q_{j-1}\\}$ 方向上的分量。该过程定义为：\n1. 初始化 $v_j = a_j$。\n2. 计算投影和：$v_j = a_j - \\sum_{i=1}^{j-1} (q_i^{\\mathsf{T}} a_j) q_i$。\n3. 归一化：$q_j = v_j / \\|v_j\\|_2$。\n\nCGS的数值不稳定性源于步骤2。项 $(q_i^{\\mathsf{T}} a_j)$ 是使用原始向量 $a_j$ 计算的。如果 $a_j$ 与由 $\\{q_1, \\dots, q_{j-1}\\}$ 张成的子空间近似平行，那么向量 $v_j$ 将是一个大向量减去另一个几乎相同的大向量的结果。这个操作被称为灾难性抵消，会导致相对精度的巨大损失。最终计算出的向量 $\\hat{v}_j$ 可能仍含有与 $\\{q_1, \\dots, q_{j-1}\\}$ 平行的显著分量，这意味着最终的向量集 $\\{\\hat{q}_1, \\dots, \\hat{q}_k\\}$ 未能实现正交。\n\n**修正格拉姆-施密特 (Modified Gram-Schmidt, MGS)**\nMGS算法是CGS计算的一种重新排列，在数值上更为稳定。MGS不是将单个向量 $a_j$ 投影到所有先前的 $q_i$ 上，而是取每个新的标准正交向量 $q_j$ 并立即从所有后续向量 $\\{a_{j+1}, \\dots, a_k\\}$ 中移除其分量。\n过程如下：\n1. 对所有 $j=1, \\dots, k$ 初始化 $v_j = a_j$。\n2. 对于 $j=1, \\dots, k$：\n   a. 归一化当前向量：$q_j = v_j / \\|v_j\\|_2$。\n   b. 将所有后续向量与新的 $q_j$ 正交化：$v_l = v_l - (q_j^{\\mathsf{T}} v_l) q_j$ 对于 $l = j+1, \\dots, k$。\n\n这个过程在数学上与CGS等价，但在有限精度计算中的表现却大相径庭。通过在每一步都对向量 $v_l$ 进行正交化，MGS有效地执行了正交性的迭代改进，防止了CGS中出现的误差累积。进行投影所依据的向量 $v_l$ 已经被正交化以垂直于 $\\{q_1, \\dots, q_{j-1}\\}$，这使得计算更加稳健。\n\n对于这两种算法，问题规定如果要归一化的向量范数 $\\|v_j\\|_2$ 为零，则生成的列 $q_j$ 应为零向量。在浮点环境中，我们通过检查范数是否低于一个小的容差（例如 $10^{-20}$）来实现这一点，以便稳健地处理那些数学上为零但由于舍入误差而数值上非零的值。\n\n**正交性误差度量**\n标准正交化的质量由正交性误差 $E(Q)$ 来衡量。给定一个矩阵 $Q \\in \\mathbb{R}^{n \\times k}$，我们首先过滤掉所有零列或接近零的列。我们定义一个索引集 $J = \\{ j \\in \\{1,\\dots,k\\} : \\|q_j\\|_2  \\delta \\}$，容差为 $\\delta = 10^{-14}$。如果 $r = |J|$ 是不可忽略列的数量，我们从这些列构成一个子矩阵 $Q_J \\in \\mathbb{R}^{n \\times r}$。误差是 $Q_J^{\\mathsf{T}} Q_J$ 与单位矩阵 $I_r$ 之间偏差的弗罗贝尼乌斯范数（Frobenius norm）：\n$$\nE(Q) = \\begin{cases}\n   \\left\\| Q_J^{\\mathsf{T}} Q_J - I_r \\right\\|_F,  r \\ge 1, \\\\\n   0,  r = 0.\n\\end{cases}\n$$\n对于 $Q_J$ 中一组完全标准正交的列，此误差将为 $0$。\n\n**测试用例分析**\n- **用例 1: $(n, k, \\epsilon) = (6, 3, 10^{-8})$**。这里，$\\epsilon = 10^{-8}$。向量 $a_2$ 接近 $a_1$，而 $a_3$ 极其接近，因为它的扰动是 $\\epsilon^2 = 10^{-16}$，这已处于双精度的极限。值 $\\epsilon=10^{-8}$ 大约是 $\\sqrt{\\epsilon_{mach}}$，这是一个已知的阈值，超过该阈值CGS会开始显著丧失正交性。我们预计CGS会出现显著误差，而MGS应保持准确。\n- **用例 2: $(n, k, \\epsilon) = (6, 3, 0)$**。当 $\\epsilon=0$ 时，各列完全共线：$A = [e_1, e_1, e_1]$。两种算法都应能正确识别出线性相关性，生成 $Q = [e_1, 0, 0, \\dots]$。最终的误差 $E(Q)$ 对两者都应为 $0$，因为只有一个列向量非零。\n- **用例 3: $(n, k, \\epsilon) = (10, 8, 10^{-12})$**。扰动项 $\\epsilon^{j-1}$ 会迅速变得小于机器精度。对于 $j=3$，$\\epsilon^2 = 10^{-24}$，所以 $a_3$ 在计算上将与 $e_1$ 完全相同。矩阵 $A$ 在数值上将是 $[e_1, e_1 + 10^{-12}e_2, e_1, e_1, \\dots]$。由于误差传播，CGS将遭受严重的正交性损失。MGS将正确地将 $a_2$ 相对于 $a_1$ 进行正交化，然后会发现所有后续向量都在 $q_1$ 的张成空间内，从而产生零向量。MGS的误差应该很小，而CGS的误差会很大。\n- **用例 4: $(n, k, \\epsilon) = (6, 5, 10^{-16})$**。这里 $\\epsilon$ 本身就处于机器精度的水平。向量 $a_2 = e_1 + 10^{-16} e_2$ 几乎无法与 $a_1$ 区分。所有后续的向量 $a_j$ (对于 $j \\ge 3$) 在数值上都将与 $e_1$ 相同。这是一个极端情况，预计CGS会完全失败，生成的列向量将远非正交。MGS应能优雅地处理这种情况，产生两个标准正交向量和随后的零向量，从而得到非常低的误差。\n\n实现将遵循这些原则来为每个测试用例计算指定的误差对。", "answer": "```python\nimport numpy as np\n\ndef build_A(n, k, epsilon):\n    \"\"\"\n    Constructs the n x k matrix A with nearly collinear columns.\n    \n    Args:\n        n (int): Number of rows.\n        k (int): Number of columns.\n        epsilon (float): Parameter controlling collinearity.\n    \n    Returns:\n        np.ndarray: The n x k matrix A.\n    \"\"\"\n    A = np.zeros((n, k), dtype=np.float64)\n    # a_1 = e_1\n    A[0, 0] = 1.0\n    # a_j = e_1 + epsilon^(j-1) * e_j for j >= 2 (1-based index)\n    # The code loop variable j is a 0-based column index.\n    for j in range(1, k):\n        A[0, j] = 1.0\n        # The row index j must be less than n.\n        if j  n:\n            # For 1-based problem index p >= 2, the code index is j = p-1.\n            # The power should be p-1, which is equal to j.\n            # So epsilon**j is correct.\n            A[j, j] = epsilon**j\n    return A\n\ndef classical_gram_schmidt(A):\n    \"\"\"\n    Orthonormalizes the columns of A using the Classical Gram-Schmidt method.\n    \n    Args:\n        A (np.ndarray): The matrix to orthonormalize.\n    \n    Returns:\n        np.ndarray: The matrix Q with orthonormal columns.\n    \"\"\"\n    n, k = A.shape\n    Q = np.zeros((n, k), dtype=np.float64)\n    # A small tolerance to check for zero norm\n    norm_tol = 1e-20 \n    \n    for j in range(k):\n        v = A[:, j].copy()\n        for i in range(j):\n            # CGS projects the original vector A[:, j] onto each q_i\n            proj_coeff = np.dot(Q[:, i].T, A[:, j])\n            v -= proj_coeff * Q[:, i]\n        \n        norm_v = np.linalg.norm(v)\n        if norm_v > norm_tol:\n            Q[:, j] = v / norm_v\n        # If norm_v is too small, Q[:, j] remains a zero vector.\n            \n    return Q\n\ndef modified_gram_schmidt(A):\n    \"\"\"\n    Orthonormalizes the columns of A using the Modified Gram-Schmidt method.\n    \n    Args:\n        A (np.ndarray): The matrix to orthonormalize.\n    \n    Returns:\n        np.ndarray: The matrix Q with orthonormal columns.\n    \"\"\"\n    V = A.copy()\n    n, k = V.shape\n    Q = np.zeros((n, k), dtype=np.float64)\n    # A small tolerance to check for zero norm\n    norm_tol = 1e-20\n\n    for j in range(k):\n        norm_v = np.linalg.norm(V[:, j])\n        if norm_v > norm_tol:\n            Q[:, j] = V[:, j] / norm_v\n            # MGS orthogonalizes all subsequent vectors against the new q_j\n            for l in range(j + 1, k):\n                proj_coeff = np.dot(Q[:, j].T, V[:, l])\n                V[:, l] -= proj_coeff * Q[:, j]\n        # If norm_v is too small, Q[:, j] remains zero and no orthogonalization\n        # is performed against it.\n            \n    return Q\n\ndef orthogonality_error(Q):\n    \"\"\"\n    Calculates the orthogonality error E(Q) as defined in the problem.\n    \n    Args:\n        Q (np.ndarray): The matrix with putatively orthonormal columns.\n        \n    Returns:\n        float: The orthogonality error.\n    \"\"\"\n    n, k = Q.shape\n    delta = 1e-14\n    \n    J = [j for j in range(k) if np.linalg.norm(Q[:, j]) > delta]\n    r = len(J)\n    \n    if r == 0:\n        return 0.0\n    \n    Q_J = Q[:, J]\n    \n    I_r = np.identity(r, dtype=np.float64)\n    error_matrix = Q_J.T @ Q_J - I_r\n    \n    return np.linalg.norm(error_matrix, 'fro')\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        (6, 3, 1e-8),      # Case 1\n        (6, 3, 0.0),       # Case 2\n        (10, 8, 1e-12),    # Case 3\n        (6, 5, 1e-16),     # Case 4\n    ]\n\n    all_results = []\n    for n, k, epsilon in test_cases:\n        A = build_A(n, k, epsilon)\n        \n        Q_cgs = classical_gram_schmidt(A)\n        Q_mgs = modified_gram_schmidt(A)\n        \n        error_cgs = orthogonality_error(Q_cgs)\n        error_mgs = orthogonality_error(Q_mgs)\n        \n        all_results.append([error_cgs, error_mgs])\n\n    # The final print statement must follow the exact specified format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2419987"}, {"introduction": "我们已经看到，修正格拉姆-施密特（MGS）方法通常比经典方法（CGS）具有更好的数值稳定性。然而，MGS的性能也并非不受影响，它对矩阵的列序很敏感。本练习将引导你探究这一更深层次的现象，通过对同一矩阵的不同列排列进行正交化，你将观察到MGS产生的正交性缺陷有显著差异，并将这种现象与部分条件数的增长联系起来。[@problem_id:3557033]", "problem": "您的任务是研究修正 Gram-Schmidt (MGS) 算法中正交性的敏感度，具体分析其如何受到列序和部分条件数演进的影响。请从以下基本概念开始：修正 Gram-Schmidt (MGS) 算法通过以下方式对矩阵进行正交规范化：迭代地将当前列投影到先前已构建的正交规范向量上，减去这些投影，然后进行归一化；浮点舍入模型假设实数上的任何基本算术运算都遵循 $ \\mathrm{fl}(x \\circ y) = (x \\circ y)(1 + \\delta) $，其中 $ |\\delta| \\le u $，$ u $ 是单位舍入误差；矩阵 $ A $ 的奇异值分解 (SVD) 为 $ A = U \\Sigma V^\\top $，2-范数条件数定义为 $ \\kappa_2(A) = \\sigma_{\\max}(A) / \\sigma_{\\min}(A) $，其中 $ \\sigma_{\\max}(A) $ 和 $ \\sigma_{\\min}(A) $ 分别是 $ A $ 的最大和最小奇异值。\n\n请按如下方式构造一个高瘦矩阵 $ A \\in \\mathbb{R}^{n \\times m} $，其中 $ n = 100 $ 且 $ m = 6 $。令 $ G \\in \\mathbb{R}^{n \\times m} $ 的元素为独立的标准正态分布随机数，使用固定的伪随机种子 $ 0 $ 确定性地生成。通过 $ c_1 = G_{:,1} $，$ c_2 = c_1 + \\varepsilon_1 G_{:,2} $，$ c_3 = G_{:,3} $，$ c_4 = c_3 + \\varepsilon_2 G_{:,4} $，$ c_5 = G_{:,5} $，$ c_6 = G_{:,6} $ 来定义 $ A $ 的列 $ c_1, c_2, \\dots, c_6 $，其中 $ \\varepsilon_1 = 10^{-12} $ 和 $ \\varepsilon_2 = 10^{-8} $。这些构造产生了两个近似共线的向量对 $ (c_1, c_2) $ 和 $ (c_3, c_4) $，它们具有不同程度的近似相关性。\n\n请实现修正 Gram-Schmidt (MGS) 算法，为给定的 $ A $ 的列序计算一个正交规范基 $ Q \\in \\mathbb{R}^{n \\times m} $ 和一个上三角矩阵 $ R \\in \\mathbb{R}^{m \\times m} $。为了数值稳健性，如果在任何步骤中计算出的对角线元素 $ R_{jj} $ 为 $ 0 $（表示在浮点运算中存在精确相关性），则将 $ Q $ 的第 $ j $ 列设置为零向量。将 $ Q $ 的正交性缺陷定义为弗罗贝尼乌斯范数 $ d(Q) = \\| Q^\\top Q - I_m \\|_F $，其中 $ I_m $ 是 $ m \\times m $ 的单位矩阵，$ \\| \\cdot \\|_F $ 表示弗罗贝尼乌斯范数。此外，对于给定的列置换 $ \\pi $，定义部分条件数序列为 $ \\kappa_k = \\kappa_2\\!\\left(A_{:, \\pi(1:k)}\\right) $（$ k = 1, 2, \\dots, m $），这些是在给定排序下前 $ k $ 列子矩阵的条件数。\n\n您的程序必须：\n- 根据上述规范构造 $ A $。\n- 对每个指定的列置換，使用 MGS 对置换后的列计算 $ Q $，然后计算正交性缺陷 $ d(Q) $。\n- 使用以下列置換测试套件，每个置换表示为 $ \\{1,2,3,4,5,6\\} $ 的一个排序 $ \\pi $：\n  1. 恒等排序 $ \\pi_1 = [1,2,3,4,5,6] $（两个近似共线对都出现在早期）。\n  2. 排序 $ \\pi_2 = [3,4,5,6,1,2] $（两个近似共线对都出现在晚期）。\n  3. 交错排序 $ \\pi_3 = [1,3,2,4,5,6] $（每个近似共线向量都与其伙伴相隔一段距离）。\n  4. 逆序 $ \\pi_4 = [6,5,4,3,2,1] $（将较温和的近似相关性置于较严重的之前，并反转整体进程）。\n- 对每个置换，仅输出正交性缺陷 $ d(Q) $，格式为浮点数。\n\n覆盖性设计：\n- 恒等排序是早期出现严重近似相关性的一般情况。\n- 晚期放置排序旨在探究推迟处理严重近似相关性是否能减少正交性的累积损失。\n- 交错排序旨在探究将近似相关列混合在独立列中的效果。\n- 逆序旨在探究部分条件数演进过程被翻转的边界情况。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的正交性缺陷，格式为用方括号括起来的逗号分隔列表，顺序为 $ [d(Q_{\\pi_1}), d(Q_{\\pi_2}), d(Q_{\\pi_3}), d(Q_{\\pi_4})] $。例如，如果计算出的缺陷为 $ a $、$ b $、$ c $ 和 $ d $，则程序必须打印行 $ [a,b,c,d] $。不涉及任何物理单位或角度单位；所有输出均为无量纲的浮点数。", "solution": "所提供的问题是数值线性代数领域一个有效的数值实验。它具有科学依据，定义明确且客观。所有必要的参数和定义都已提供，任务是实现一个标准算法（修正 Gram-Schmidt）和一个标准诊断工具（正交性缺陷），以研究一个众所周知的现象：在存在近似线性相关的情况下，Gram-Schmidt 过程对列排序的敏感性。\n\n该问题旨在分析对于一个特殊构造的病态矩阵，修正 Gram-Schmidt (MGS) 算法中正交性的损失如何随列排序的变化而变化。矩阵 $A \\in \\mathbb{R}^{n \\times m}$ 的维度为 $n = 100$ 和 $m = 6$，其被设计为含有两对近似共线的列向量 $(c_1, c_2)$ 和 $(c_3, c_4)$，且严重程度不同。这是通过定义 $c_2 = c_1 + \\varepsilon_1 G_{:,2}$ 和 $c_4 = c_3 + \\varepsilon_2 G_{:,4}$ 来实现的，其中 $G$ 是一个标准正态随机变量矩阵，参数 $\\varepsilon_1 = 10^{-12}$ 和 $\\varepsilon_2 = 10^{-8}$ 控制着近似共线程度。由于 $\\varepsilon_1 \\ll \\varepsilon_2$，向量对 $(c_1, c_2)$ 的共线性远高于 $(c_3, c_4)$，因此构成了更严重的病态来源。\n\n任务的核心是实现修正 Gram-Schmidt (MGS) 算法，以计算 $A$ 在不同列排序下的 $QR$ 分解。MGS 算法将一个矩阵 $A = [a_1, a_2, \\dots, a_m]$ 分解为一个正交规范矩阵 $Q = [q_1, q_2, \\dots, q_m]$ 和一个上三角矩阵 $R=\\{r_{ij}\\}$。算法定义如下：\n初始化 $v_j = a_j$，$j=1, \\dots, m$。\n对于 $i = 1, \\dots, m$：\n$1$. 归一化当前向量：$r_{ii} = \\|v_i\\|_2$。如果 $r_{ii}$ 非零，则 $q_i = v_i / r_{ii}$。否则，该向量已在先前向量的张成空间内，根据问题规范将 $q_i$ 设置为零。\n$2$. 将所有后续向量与新计算出的 $q_i$ 正交化。对于 $j = i+1, \\dots, m$：\n$$ r_{ij} = q_i^\\top v_j $$\n$$ v_j \\leftarrow v_j - r_{ij} q_i $$\nMGS 的关键特性在于，在步骤 $i$ 对向量 $v_j$ 进行正交化时，使用的是已经与 $q_1, \\dots, q_{i-1}$ 正交化后的 $v_j$ 版本。与经典 Gram-Schmidt (CGS) 算法相比，此特性赋予了 MGS 更优的数值稳定性，尽管其稳健性不如基于 Householder 变换的方法。\n\n在以单位舍入误差 $u$ 为特征的有限精度算法中，计算出的矩阵 $Q$ 不会是完全正交的。正交性的损失由缺陷度量 $d(Q) = \\| Q^\\top Q - I_m \\|_F$ 量化，其中 $I_m$ 是 $m \\times m$ 的单位矩阵，$ \\| \\cdot \\|_F$ 是弗罗贝尼乌斯范数。理论分析预测 $\\| Q^\\top Q - I_m \\|$ 受一个与 $u \\cdot \\kappa_2(A)$ 成正比的量所约束，其中 $\\kappa_2(A)$ 是 $A$ 的 2-范数条件数。\n\n该实验研究了四种不同的列置换 $\\pi_1, \\pi_2, \\pi_3, \\pi_4$，以理解病态列的排序如何影响最终的正交性。关键思想是舍入误差的累积对前导子矩阵的条件数 $\\kappa_k = \\kappa_2(A_{:, \\pi(1:k)})$ 敏感。\n- $\\pi_1 = [1,2,3,4,5,6]$：这种排序首先处理病态最严重的向量对 $(c_1, c_2)$。子矩阵 $[c_1, c_2]$ 的条件数非常大，约为 $1/\\varepsilon_1$ 的量级。这预计会在第二步引入大的正交性损失，该损失会传播并污染后续计算，从而导致最大的总体缺陷。\n- $\\pi_2 = [3,4,5,6,1,2]$：这种排序推迟了与病态的对抗，将最严重的向量对放在最后处理。初始的子矩阵是良态的。与 $c_1$ 和 $c_2$ 的近似相关性相关的大误差仅在计算 $Q$ 的最后两列时才被引入。这应导致正交性缺陷显著小于 $\\pi_1$。\n- $\\pi_3 = [1,3,2,4,5,6]$：这种排序交错了相关的向量对。向量 $c_2$ 会与 $q_1$（源于 $c_1$）和 $q_3$（源于 $c_3$）进行正交化。在使 $c_2$ 与 $c_1$ 正交时发生的灾难性抵消是主要的误差来源。与独立向量交错并不能从根本上改变以下事实：$c_2$ 中与 $c_1$ 正交的信息被 $\\varepsilon_1$ 缩放，因此被舍入误差所淹没。预期的缺陷应该很大，与 $\\pi_1$ 的缺陷相当。\n- $\\pi_4 = [6,5,4,3,2,1]$：这种排序反转了列序列。它首先处理良态的列，然后是 $(c_4, c_3)$ 对，最后是 $(c_2, c_1)$ 对。与 $\\pi_2$ 类似，该策略延迟处理病态最严重的列，预计会产生较低的正交性缺陷。\n\n实现将使用固定的伪随机种子 $0$ 来构造矩阵 $A$，以确保可复现性。对于 4 个指定的置换中的每一个，将对 $A$ 的列进行重排序，应用 MGS 算法，并计算所得 $Q$ 矩阵的正交性缺陷。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Investigates the sensitivity of orthogonality in Modified Gram-Schmidt (MGS)\n    as a function of column ordering for an ill-conditioned matrix.\n    \"\"\"\n    # 1. Define problem parameters\n    n = 100\n    m = 6\n    eps1 = 1e-12\n    eps2 = 1e-8\n    seed = 0\n\n    # 2. Construct the matrix A\n    # Use a deterministic random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n    G = rng.standard_normal((n, m))\n    \n    A = np.zeros((n, m), dtype=float)\n    # Column 1\n    A[:, 0] = G[:, 0]\n    # Column 2 (nearly collinear with Column 1)\n    A[:, 1] = A[:, 0] + eps1 * G[:, 1]\n    # Column 3\n    A[:, 2] = G[:, 2]\n    # Column 4 (nearly collinear with Column 3)\n    A[:, 3] = A[:, 2] + eps2 * G[:, 3]\n    # Column 5\n    A[:, 4] = G[:, 4]\n    # Column 6\n    A[:, 5] = G[:, 5]\n\n    def modified_gram_schmidt(A_in: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n        \"\"\"\n        Computes the QR factorization of a matrix A using the\n        Modified Gram-Schmidt algorithm.\n\n        Args:\n            A_in: The input matrix of shape (n, m).\n\n        Returns:\n            A tuple (Q, R) where Q is an n x m orthonormal matrix and\n            R is an m x m upper-triangular matrix.\n        \"\"\"\n        V = A_in.copy()\n        n_rows, n_cols = V.shape\n        Q = np.zeros((n_rows, n_cols), dtype=float)\n        R = np.zeros((n_cols, n_cols), dtype=float)\n\n        for i in range(n_cols):\n            # Compute the norm of the current vector\n            r_ii = np.linalg.norm(V[:, i])\n            R[i, i] = r_ii\n            \n            # Normalize to get the i-th orthonormal vector q_i\n            # Handle the case of a zero vector for robustness.\n            if r_ii > 0.0:\n                Q[:, i] = V[:, i] / r_ii\n            else:\n                Q[:, i] = 0.0\n            \n            # Orthogonalize all subsequent vectors against q_i\n            for j in range(i + 1, n_cols):\n                r_ij = Q[:, i].T @ V[:, j]\n                R[i, j] = r_ij\n                V[:, j] = V[:, j] - r_ij * Q[:, i]\n        \n        return Q, R\n\n    # 3. Define test cases (column permutations)\n    # Permutations are 1-based as per the problem description.\n    permutations = [\n        [1, 2, 3, 4, 5, 6],  # pi_1: Identity ordering\n        [3, 4, 5, 6, 1, 2],  # pi_2: Late near-dependence\n        [1, 3, 2, 4, 5, 6],  # pi_3: Interleaved near-dependence\n        [6, 5, 4, 3, 2, 1],  # pi_4: Reverse ordering\n    ]\n\n    results = []\n    # 4. Execute test cases and compute orthogonality defects\n    for perm in permutations:\n        # Convert 1-based permutation to 0-based indices for numpy\n        perm_indices = [p - 1 for p in perm]\n        A_permuted = A[:, perm_indices]\n        \n        Q, _ = modified_gram_schmidt(A_permuted)\n        \n        # Calculate the orthogonality defect: d(Q) = || Q^T Q - I_m ||_F\n        identity_m = np.eye(m)\n        defect_matrix = Q.T @ Q - identity_m\n        defect = np.linalg.norm(defect_matrix, 'fro')\n        results.append(defect)\n\n    # 5. Print the final results in the specified format\n    # Using scientific notation for consistent floating-point representation.\n    print(f\"[{','.join(f'{r:.10e}' for r in results)}]\")\n\nsolve()\n```", "id": "3557033"}, {"introduction": "在分析了CGS的失效和MGS的微妙之处后，最后的挑战是从分析转向工程实践，即构建一个在实际应用中足够鲁棒的正交化程序。在本练习中，你将设计并实现一个自适应算法，它能根据局部正交性损失的度量，在CGS、MGS和再正交化策略之间进行智能切换，以满足预设的正交性容差。这项实践模拟了开发兼具效率与数值稳定性的科学计算软件所面临的真实挑战。[@problem_id:3557035]", "problem": "给定一个实数矩阵 $A \\in \\mathbb{R}^{m \\times n}$（其中 $m \\ge n$）和一个容差 $\\tau  0$。任务是设计并实现一种自适应正交化算法，该算法构建一个近似矩阵 $Q \\in \\mathbb{R}^{m \\times n}$，其列旨在成为标准正交列，使得在数值上可行时，谱范数条件 $\\lVert I - \\widehat{Q}^{\\mathsf{T}} \\widehat{Q} \\rVert_2 \\le \\tau$ 得以满足。其中，$\\widehat{Q}$ 表示在浮点运算中计算出的矩阵，$I$ 表示 $n \\times n$ 的单位矩阵。该算法必须根据局部测量的正交性损失，在经典格拉姆-施密特（CGS）、修正格拉姆-施密特（MGS）以及列/全局再正交化之间自适应地切换。如果由于数值限制（例如，秩亏或相对于单位舍入而言过紧的 $\\tau$）而无法满足容差，程序必须为该测试用例返回一个表示失败的布尔指示符。\n\n从以下基本基础开始：\n- 浮点运算法则模型：对于任何基本运算，计算结果 $\\operatorname{fl}(x \\circ y)$（其中 $\\circ \\in \\{+,-,\\times,/\\}$）满足 $\\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入。\n- CGS 和 MGS 的定义：CGS 通过一次聚合投影，将一个新向量与整个当前基进行正交化，而 MGS 则是依次将新向量与每个当前基向量进行正交化。\n- 谱范数 $\\lVert \\cdot \\rVert_2$ 定义为矩阵的最大奇异值。\n\n你的算法设计必须：\n1. 为追求速度，对每一列的初次尝试实现 CGS。\n2. 检测潜在的数值抵消或大的局部正交性损失，并在适当时切换到 MGS。\n3. 当局部误差 $\\lVert Q_{:,1:j-1}^{\\mathsf{T}} q_j \\rVert_2$ 超过一个从 $\\tau$ 推导出的列向阈值时，对单个列应用再正交化。\n4. 如果最终的格拉姆矩阵误差 $\\lVert I - \\widehat{Q}^{\\mathsf{T}} \\widehat{Q} \\rVert_2$ 超过 $\\tau$，则对所有列执行一次或多次全局再正交化扫描。\n5. 当候选列的范数降至一个有数值意义的阈值以下时，检测到秩亏，并为该测试用例返回失败。\n\n通过将浮点模型与 CGS 为何会损失正交性、MGS 如何减缓这种损失、以及迭代再正交化为何能将格拉姆矩阵误差降低到目标水平（受可行性约束，例如关于 $u$ 和问题维度的界限）联系起来，来证明自适应切换和再正交化策略的正确性。\n\n将算法实现为一个可运行的程序。该程序必须使用以下确定性测试套件，完全按照规定生成矩阵，并为每个案例返回一个布尔值，指示计算出的 $\\widehat{Q}$ 是否满足 $\\lVert I - \\widehat{Q}^{\\mathsf{T}} \\widehat{Q} \\rVert_2 \\le \\tau$。\n\n测试套件：\n- 案例1（一般随机，中等条件）：$m=60$，$n=20$，种子 $0$，$A$ 的元素为独立的标准正态分布，容差 $\\tau = 10^{-12}$。\n- 案例2（列缩放，宽动态范围）：$m=60$，$n=20$，种子 $7$，生成具有独立标准正态分布元素的 $A$，然后将第 $j$ 列乘以 $10^{j/6}$，其中 $j=0,1,\\dots,n-1$，容差 $\\tau = 10^{-12}$。\n- 案例3（类范德蒙矩阵，病态条件）：$m=80$，$n=20$，节点 $x_i$ 在 $[0, 1.1]$ 上线性间隔，其中 $i=0,1,\\dots,m-1$，矩阵 $A$ 的元素为 $A_{i,j} = x_i^j$，其中 $j=0,1,\\dots,n-1$，容差 $\\tau = 10^{-10}$。此案例不需要随机种子。\n- 案例4（边界可行性检查）：$m=50$，$n=15$，种子 $3$，$A$ 的元素为独立的标准正交分布，容差 $\\tau = 10^{-16}$。\n- 案例5（因列重复导致的秩亏）：$m=40$，$n=12$，种子 $11$，$A$ 的元素为独立的标准正交分布，然后将第 $6$ 列设置为与第 $2$ 列相同，容差 $\\tau = 10^{-12}$。\n\n程序要求：\n- 对于每个测试用例，输出一个布尔值 $b \\in \\{\\text{True}, \\text{False}\\}$，指示算法是否生成了满足 $\\lVert I - \\widehat{Q}^{\\mathsf{T}} \\widehat{Q} \\rVert_2 \\le \\tau$ 的 $\\widehat{Q}$。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[\\text{True},\\text{False},\\text{True},\\text{True},\\text{False}]$。\n\n此问题不涉及物理单位、角度单位或百分比。", "solution": "用户在数值线性代数领域提供了一个良置问题。问题陈述有科学依据、形式化规定且客观。它没有矛盾、歧义或伪科学论断。所有必要的数据、约束和目标都已明确定义。因此，该问题被认为是有效的，并在下面提供了解决方案。\n\n目标是设计并实现一种自适应算法，用于对矩阵 $A \\in \\mathbb{R}^{m \\times n}$（其中 $m \\ge n$）进行正交化。该算法必须生成一个近似标准正交矩阵 $\\widehat{Q}$，使其格拉姆矩阵误差的谱范数 $\\lVert I - \\widehat{Q}^{\\mathsf{T}} \\widehat{Q} \\rVert_2$ 受给定的容差 $\\tau  0$ 的约束。该算法的自适应性在于它根据局部和全局误差度量，动态选择正交化方法——经典格拉姆-施密特（CGS）、修正格拉姆-施密特（MGS）和再正交化。\n\n这个问题的基础在于格拉姆-施密特算法在有限精度浮点运算中的行为。浮点运算 $\\circ$ 的标准模型是 $\\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入（机器ε）。\n\n设矩阵 $A$ 的列为 $a_1, a_2, \\dots, a_n$。格拉姆-施密特过程为 $A$ 的值域计算一个标准正交基 $q_1, q_2, \\dots, q_n$。第 $j$ 步将 $a_j$ 与先前计算出的标准正交向量 $q_1, \\dots, q_{j-1}$ 进行正交化，生成向量 $v_j$，然后将其归一化得到 $q_j$。\n\n经典格拉姆-施密特（CGS）算法将 $v_j$ 的计算作为单次操作：\n$$v_j = a_j - \\sum_{i=1}^{j-1} (q_i^{\\mathsf{T}} a_j) q_i = a_j - Q_{j-1} (Q_{j-1}^{\\mathsf{T}} a_j)$$\n其中 $Q_{j-1}$ 是以 $q_1, \\dots, q_{j-1}$ 为列的矩阵。CGS 的主要数值问题源于减法操作。如果向量 $a_j$ 与 $Q_{j-1}$ 的列近似线性相关，其投影 $P_j = Q_{j-1} (Q_{j-1}^{\\mathsf{T}} a_j)$ 将非常接近 $a_j$ 本身。浮点计算 $\\operatorname{fl}(a_j - P_j)$ 将会遭受灾难性抵消，导致计算出的向量 $\\hat{v}_j$ 相对于真实数学残差损失了大部分有效数字。因此，$\\hat{v}_j$ 在数值上将不再与 $Q_{j-1}$ 的列正交。由 $\\lVert I - \\widehat{Q}^{\\mathsf{T}} \\widehat{Q} \\rVert_2$ 衡量的正交性损失可能严重到 $O(u \\cdot \\kappa(A)^2)$ 的程度，其中 $\\kappa(A)$ 是 $A$ 的条件数。\n\n修正格拉姆-施密特（MGS）算法在数学上与 CGS 等价，但它依次执行正交化：\n$$v_j^{(0)} = a_j$$\n$$v_j^{(i)} = v_j^{(i-1)} - (q_i^{\\mathsf{T}} v_j^{(i-1)}) q_i, \\quad \\text{for } i = 1, \\dots, j-1$$\n$$v_j = v_j^{(j-1)}$$\n通过在每一步更新被正交化的向量，MGS 减缓了 CGS 中出现的灾难性抵消问题。MGS 的正交性损失被限制在 $O(u \\cdot \\kappa(A))$ 之内，这代表了数值稳定性上的显著改进。\n\n一个自适应算法可以利用这两种方法的优点。CGS 富含 2 级 BLAS 操作（矩阵-向量乘积），这比主导 MGS 的 1 级 BLAS 操作（向量-向量操作）在计算上可能更有效率。因此，一个有效的策略是默认使用 CGS，并监测即将发生的正交性损失。\n\n再正交化的需求是可以预测的。当残差的范数远小于原始向量的范数时，CGS 会发生大的正交性损失。Daniel-Gragg-Kaufman-Stewart (DGKS) 条件将此形式化：如果对于某个常数 $\\alpha$ 有 $\\lVert v_j \\rVert_2 \\le \\alpha \\lVert a_j \\rVert_2$，则建议进行再正交化。一个标准的、有理论支持的选择是 $\\alpha = 1/\\sqrt{2} \\approx 0.7071$。当满足此条件时，它表明 $a_j$ 接近于由 $Q_{j-1}$ 张成的子空间，这正是 CGS 不稳定的精确场景。对计算出的残差 $v_j$ 应用第二步正交化（CGS-2），通常能将该列的正交性恢复到接近机器精度的水平。\n提出的算法如下：\n1.  对于 $A$ 的每一列 $a_j$：\n    a. 使用一步 CGS 计算初始残差 $v_j$。\n    b. 检查 DGKS 条件：如果 $\\lVert v_j \\rVert_2 / \\lVert a_j \\rVert_2 \\le \\alpha$，则对 $v_j$ 执行第二步 CGS 以“纯化”它。\n    c. 在任何再正交化之后，检查数值秩亏。如果残差的最终范数 $\\lVert v_j \\rVert_2$ 小于一个与 $n \\cdot u \\cdot \\lVert a_j \\rVert_2$ 成比例的容差，则认为列 $a_j$ 与前面的列线性相关。算法终止并报告此情况失败。\n    d. 归一化最终残差以获得 $q_j$。\n\n即使有这种局部再正交化，小的误差仍可能跨列累积。如果最终的矩阵 $\\widehat{Q}$ 未能满足全局容差 $\\lVert I - \\widehat{Q}^{\\mathsf{T}} \\widehat{Q} \\rVert_2 \\le \\tau$，我们可以执行全局再正交化扫描。这涉及到对已经是近似标准正交的矩阵 $\\widehat{Q}$ 的列应用格拉姆-施密特过程。由于其卓越的稳定性，MGS 是此修饰步骤的首选方法。对于一个已经接近标准正交的矩阵，一到两次 MGS 遍历通常足以将正交性误差降低到 $O(u)$。\n\n该算法通过两种方式处理不可行性：\n1.  **秩亏**：如上所述，如果检测到某一列是其前面列的线性组合，则过程无法继续并返回失败。\n2.  **不可行的容差**：如果指定的容差 $\\tau$ 过于严苛（例如，小于给定机器精度 $u$ 和问题维度 $n$ 所能达到的水平，大致为 $\\tau \\le n \\cdot u$），即使在最大次数的全局扫描后，算法也可能无法满足条件。在这种情况下，它会正确地报告失败。\n\n这种自适应设计结合了 CGS 的速度与再正交化和 MGS 的鲁棒性，创建了一个实用且数值稳定的正交化过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef mgs_reortho(A):\n    \"\"\"\n    Performs one sweep of Modified Gram-Schmidt on the columns of matrix A.\n    Used for global reorthogonalization.\n\n    Args:\n        A (np.ndarray): A real matrix with m >= n.\n\n    Returns:\n        np.ndarray: The reorthogonalized matrix Q.\n        bool: True if successful, False if rank deficiency was detected.\n    \"\"\"\n    m, n = A.shape\n    Q = np.zeros_like(A, dtype=float)\n    u = np.finfo(float).eps\n    \n    for j in range(n):\n        v = A[:, j].copy()\n        for i in range(j):\n            # Orthogonalize v against the already computed q_i\n            dot_product = Q[:, i].T @ v\n            v -= dot_product * Q[:, i]\n            \n        norm_v = np.linalg.norm(v)\n\n        # In a global sweep on a nearly-orthonormal matrix, a tiny norm\n        # is unexpected, but we check for it as a safeguard.\n        if norm_v  n * u:\n            return Q, False\n            \n        Q[:, j] = v / norm_v\n        \n    return Q, True\n\ndef adaptive_gram_schmidt(A, tau):\n    \"\"\"\n    Performs adaptive orthogonalization of matrix A.\n\n    Args:\n        A (np.ndarray): Input matrix of size m x n.\n        tau (float): Tolerance for the spectral norm of (I - Q^T Q).\n\n    Returns:\n        bool: True if the resulting Q satisfies the tolerance, False otherwise.\n    \"\"\"\n    m, n = A.shape\n    u = np.finfo(float).eps\n    Q = np.zeros((m, n), dtype=float)\n    \n    # DGKS condition constant\n    alpha = 1.0 / np.sqrt(2.0)\n\n    for j in range(n):\n        a_j = A[:, j].copy()\n        norm_a_j = np.linalg.norm(a_j)\n\n        if norm_a_j  n * u:\n            # Column is essentially zero, indicating rank deficiency.\n            return False\n\n        # --- CGS Step ---\n        v = a_j\n        if j > 0:\n            s = Q[:, :j].T @ v\n            v = v - Q[:, :j] @ s\n        norm_v = np.linalg.norm(v)\n\n        # --- Local Reorthogonalization (CGS2) ---\n        # Triggered by the Daniel-Gragg-Kaufman-Stewart (DGKS) condition.\n        if norm_v  alpha * norm_a_j and j > 0:\n            s_reorth = Q[:, :j].T @ v\n            v = v - Q[:, :j] @ s_reorth\n            norm_v = np.linalg.norm(v)\n\n        # --- Rank Deficiency Check ---\n        # If the norm of the vector after orthogonalization is numerically zero\n        # relative to its original norm, the column is linearly dependent.\n        if norm_v  n * u * norm_a_j:\n            return False\n\n        # --- Normalization ---\n        Q[:, j] = v / norm_v\n\n    # --- Global Reorthogonalization Loop ---\n    max_global_sweeps = 2\n    for _ in range(max_global_sweeps):\n        I = np.eye(n, dtype=float)\n        gram_matrix = Q.T @ Q\n        defect = np.linalg.norm(I - gram_matrix, ord=2)\n\n        if defect = tau:\n            # Tolerance met, no more sweeps needed.\n            return True\n\n        # Perform one global sweep using the more stable MGS.\n        Q_new, success = mgs_reortho(Q)\n        if not success:\n            # This is unlikely but indicates a problem during the sweep.\n            return False\n        Q = Q_new\n    \n    # --- Final Check ---\n    # After all allowed sweeps, check the tolerance one last time.\n    I = np.eye(n, dtype=float)\n    gram_matrix = Q.T @ Q\n    final_defect = np.linalg.norm(I - gram_matrix, ord=2)\n    \n    return final_defect = tau\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test suite for the adaptive Gram-Schmidt algorithm.\n    \"\"\"\n    test_cases_params = [\n        {'type': 'random', 'm': 60, 'n': 20, 'seed': 0, 'tau': 1e-12},\n        {'type': 'scaled', 'm': 60, 'n': 20, 'seed': 7, 'tau': 1e-12},\n        {'type': 'vander', 'm': 80, 'n': 20, 'tau': 1e-10},\n        {'type': 'boundary', 'm': 50, 'n': 15, 'seed': 3, 'tau': 1e-16},\n        {'type': 'rank_deficient', 'm': 40, 'n': 12, 'seed': 11, 'tau': 1e-12},\n    ]\n\n    results = []\n    \n    for case in test_cases_params:\n        A = None\n        if case['type'] == 'random' or case['type'] == 'boundary':\n            rng = np.random.default_rng(case['seed'])\n            A = rng.standard_normal((case['m'], case['n']))\n        \n        elif case['type'] == 'scaled':\n            rng = np.random.default_rng(case['seed'])\n            A = rng.standard_normal((case['m'], case['n']))\n            for j in range(case['n']):\n                A[:, j] *= 10**(j / 6.0)\n        \n        elif case['type'] == 'vander':\n            x = np.linspace(0, 1.1, case['m'])\n            # np.vander produces columns with decreasing powers, we want increasing.\n            A = np.vander(x, N=case['n'], increasing=True)\n            \n        elif case['type'] == 'rank_deficient':\n            rng = np.random.default_rng(case['seed'])\n            A = rng.standard_normal((case['m'], case['n']))\n            A[:, 6] = A[:, 2].copy()\n\n        result = adaptive_gram_schmidt(A, case['tau'])\n        results.append(result)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: str(x), results))}]\")\n\nsolve()\n```", "id": "3557035"}]}