{"hands_on_practices": [{"introduction": "动手实践是掌握任何算法的关键。这个练习将引导你逐步完成使用吉文斯旋转将子对角线元素清零的过程。通过手动计算一个小的 $3 \\times 3$ 矩阵的例子[@problem_id:1029885]，你将为该算法如何将矩阵分解为 $Q$ 和 $R$ 因子建立具体的直觉。", "problem": "考虑如下给出的 $3 \\times 3$ 矩阵 $A$：\n\n$$\nA = \\begin{bmatrix} \n1 & 2 & 1 \\\\\n0 & 3 & 1 \\\\\n2 & 1 & 2 \n\\end{bmatrix}.\n$$\n\n使用 Givens 旋转计算 $A$ 的 QR 分解，并确保上三角矩阵 $R$ 的对角线元素为正。求 $R$ 的 $(2,3)$ 元素是什么？", "solution": "我们对 $A$ 的行进行两次 Givens 旋转，以将次对角线元素清零，同时保持 $R$ 的对角线元素为正。\n\n1.  将 $(3,1)$ 元素清零。令\n   $$\n   c_1 = \\frac{a_{11}}{\\sqrt{a_{11}^2 + a_{31}^2}}\n       = \\frac{1}{\\sqrt{1+4}}\n       = \\frac{1}{\\sqrt5}, \n   \\quad\n   s_1 = \\frac{a_{31}}{\\sqrt{1+4}}\n       = \\frac{2}{\\sqrt5}.\n   $$\n   在 $(1,3)$ 平面中的 Givens 旋转 $G_1$ 给出\n   $$\n   G_1 A = \\begin{bmatrix}\\sqrt5 & \\frac{4}{\\sqrt5} & \\sqrt5\\\\\n                             0 & 3 & 1\\\\\n                             0 & -\\frac{3}{\\sqrt5} & 0\n            \\end{bmatrix}.\n   $$\n\n2.  将新的 $(3,2)$ 元素清零。设\n   $$\n   c_2 = \\frac{3}{\\sqrt{9 + \\tfrac{9}{5}}}\n       = \\sqrt{\\frac56},\n   \\quad\n   s_2 = \\frac{-\\tfrac{3}{\\sqrt5}}{\\sqrt{9 + \\tfrac{9}{5}}}\n       = -\\frac{1}{\\sqrt6}.\n   $$\n   将 $G_2$ 应用于后两行得到\n   $$\n   G_2G_1 A\n     = \\begin{bmatrix}\n         \\sqrt5       & \\tfrac{4}{\\sqrt5}   & \\sqrt5 \\\\[6pt]\n         0            & \\tfrac{3\\sqrt{30}}{5}  & \\tfrac{\\sqrt{30}}{6} \\\\[4pt]\n         0            & 0                     & r_{33}\n       \\end{bmatrix}\n     = R,\n   $$\n   根据构造，$r_{33}$ 自动为正。因此 $R$ 的 $(2,3)$ 元素是\n   $$\n   r_{23} = \\frac{\\sqrt{30}}{6}.\n   $$", "answer": "$$\\boxed{\\frac{\\sqrt{30}}{6}}$$", "id": "1029885"}, {"introduction": "将算法思想转化为稳健的计算机代码是数值计算的核心挑战。这个练习[@problem_id:3236226]要求你编写一个数值稳定的吉文斯 QR 分解程序，并特别关注如何避免上溢/下溢以及不使用三角函数等常见的编程陷阱。这是将理论知识转化为实用工具的关键一步。", "problem": "实现一个程序，使用 Givens 旋转计算一个实矩阵的瘦分解，将其分解为一个正交因子和一个上三角因子，并遵循以下约束和检查。\n\n给定一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$，其中 $m \\ge n$，目标是找到矩阵 $Q \\in \\mathbb{R}^{m \\times m}$ 和 $R \\in \\mathbb{R}^{m \\times n}$，使得 $Q$ 是正交矩阵，$R$ 是上三角矩阵，并且它们在浮点舍入误差范围内满足 $A \\approx Q R$。您必须使用 Givens 旋转来计算这些因子，通过对行进行左乘来将单个次对角线元素置零。严禁使用任何三角函数；您应仅从待消去的矩阵元素计算 Givens 参数。具体来说，当消去主元 $a$ 下方的元素 $b$ 时，您的旋转必须仅由 $a$ 和 $b$ 构造。\n\n基础知识：\n- 方阵 $Q$ 是正交的，如果 $Q^\\mathsf{T} Q = I$。\n- 在由第 $i$ 和第 $j$ 坐标轴张成的平面中的 Givens 旋转由一个 $2 \\times 2$ 的块定义\n$$\nG_{(i,j)} = \\begin{bmatrix} c & s \\\\ -s & c \\end{bmatrix}\n$$\n其中实标量 $c$ 和 $s$ 满足 $c^2 + s^2 = 1$，其余位置为单位矩阵的元素。左乘 $G_{(i,j)}$ 仅混合目标矩阵的第 $i$ 行和第 $j$ 行。\n\n您的任务：\n- 实现一个鲁棒的算法，对每一列 $j$，使用连续的 Givens 旋转来消去所有 $i > j$ 的元素 $A_{i,j}$。\n- 当消去主元 $a$ 下方的元素 $b$ 时，不使用三角函数，仅根据 $a$ 和 $b$ 来确定 $c$ 和 $s$。对于极大、极小或零值的 $a$ 和 $b$，您的方法必须是适度缩放且数值稳定的。\n- 将最终的正交因子累积为所施加的 Givens 旋转的转置之积，以使最终的分解满足 $A \\approx Q R$。\n\n验证要求：\n- 定义一个容差 $\\tau = 10^{-10}$。\n- 对于每个测试矩阵 $A$，计算因子 $Q$ 和 $R$ 并验证以下内容：\n  1. 重构：相对 Frobenius 范数误差满足\n  $$\n  \\frac{\\lVert A - Q R \\rVert_F}{\\max\\{\\lVert A \\rVert_F, 1\\}} \\le \\tau.\n  $$\n  2. 正交性：与正交性的偏差满足\n  $$\n  \\lVert Q^\\mathsf{T} Q - I \\rVert_{\\max} \\le \\tau.\n  $$\n  3. 三角性：$R$ 的严格下三角部分很小，\n  $$\n  \\max_{i > j} |R_{i,j}| \\le \\tau.\n  $$\n- 对于每个测试矩阵，您的程序必须返回一个布尔值，当且仅当上述所有三个检查都通过时，该值为真。\n\n测试套件：\n请精确使用以下五个实矩阵（每个矩阵都满足 $m \\ge n$）：\n\n1. $A_1 \\in \\mathbb{R}^{4 \\times 3}$：\n   第 $1$ 到 $4$ 行具体为：\n   $\n   (\\,\\,2,\\,-1,\\,0\\,),\\quad (\\,\\,3,\\,4,\\,1\\,),\\quad (\\,\\,0,\\,1,\\,3\\,),\\quad (\\,\\,5,\\,-2,\\,2\\,).\n   $\n\n2. $A_2 \\in \\mathbb{R}^{5 \\times 3}$：\n   第 $1$ 到 $5$ 行是\n   $\n   (\\,\\,10^{-12},\\,2,\\,-3\\,),\\quad (\\,\\,4,\\,-5,\\,6\\,),\\quad (\\,\\,7,\\,8,\\,-10^{-12}\\,),\n   $\n   $\n   (\\,\\,-2,\\,0.5,\\,1.5\\,),\\quad (\\,\\,3,\\,-10^{-9},\\,2.5\\,).\n   $\n\n3. $A_3 \\in \\mathbb{R}^{3 \\times 3}$ (已经是上三角矩阵):\n   行是\n   $\n   (\\,\\,4,\\,-1,\\,2\\,),\\quad (\\,\\,0,\\,3,\\,-5\\,),\\quad (\\,\\,0,\\,0,\\,2\\,).\n   $\n\n4. $A_4 \\in \\mathbb{R}^{6 \\times 4}$：\n   行是\n   $\n   (\\,\\,1,\\,2,\\,3,\\,4\\,),\\quad (\\,\\,2,\\,0,\\,-1,\\,1\\,),\\quad (\\,\\,0,\\,-3,\\,1,\\,2\\,),\n   $\n   $\n   (\\,\\,-1,\\,4,\\,0,\\,-2\\,),\\quad (\\,\\,3,\\,-1,\\,2,\\,0\\,),\\quad (\\,\\,5,\\,2,\\,-2,\\,1\\,).\n   $\n\n5. $A_5 \\in \\mathbb{R}^{4 \\times 3}$ (秩亏损列：第三列等于第一列加第二列的两倍):\n   行是\n   $\n   (\\,\\,1,\\,0,\\,1\\,),\\quad (\\,\\,2,\\,-1,\\,0\\,),\\quad (\\,\\,3,\\,1,\\,5\\,),\\quad (\\,\\,4,\\,2,\\,8\\,).\n   $\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个布尔值按 $A_1$ 到 $A_5$ 的顺序对应一个测试矩阵。例如，输出应如下所示\n$\n[\\mathrm{True},\\mathrm{True},\\mathrm{True},\\mathrm{True},\\mathrm{True}]\n$\n如果所有测试都通过。\n\n角度和物理单位：\n- 此问题不要求任何角度或物理单位；不要报告任何角度或物理量。\n\n实现约束：\n- 不要调用任何三角函数。您可以使用平方根以及从 $a$ 和 $b$ 计算的欧几里得范数。\n- 实现语言在最终答案部分指定；无需读取输入。", "solution": "用户要求使用 Givens 旋转实现实矩阵 $A \\in \\mathbb{R}^{m \\times n}$（其中 $m \\ge n$）的 QR 分解。该分解应生成一个正交矩阵 $Q \\in \\mathbb{R}^{m \\times m}$ 和一个上三角矩阵 $R \\in \\mathbb{R}^{m \\times n}$，使得 $A \\approx QR$。实现过程不得使用三角函数，且必须是数值稳定的。\n\n### 问题验证\n\n首先，我将根据既定标准验证问题陈述。\n\n**步骤 1：提取要点**\n\n-   **任务**：使用 Givens 旋转计算矩阵 $A \\in \\mathbb{R}^{m \\times n}$ ($m \\ge n$) 的 QR 分解。\n-   **输出矩阵**：一个正交矩阵 $Q \\in \\mathbb{R}^{m \\times m}$ 和一个上三角矩阵 $R \\in \\mathbb{R}^{m \\times n}$。\n-   **方法**：通过左乘 Givens 旋转矩阵 $G$ 顺序消去次对角线元素 $A_{i,j}$ ($i > j$)。\n-   **Givens 参数约束**：旋转的参数 $c$ 和 $s$ 必须从主元元素 $a$ 和待置零元素 $b$ 计算得出，且不使用三角函数。计算过程必须是数值稳定的。\n-   **Q 的累积**：$Q$ 由各个 Givens 旋转矩阵的转置累积而成：$Q = G_1^\\mathsf{T} G_2^\\mathsf{T} \\cdots G_k^\\mathsf{T}$。\n-   **验证**：需要用容差 $\\tau = 10^{-10}$ 进行三项检查：\n    1.  重构误差：$\\frac{\\lVert A - Q R \\rVert_F}{\\max\\{\\lVert A \\rVert_F, 1\\}} \\le \\tau$。\n    2.  正交性误差：$\\lVert Q^\\mathsf{T} Q - I \\rVert_{\\max} \\le \\tau$。\n    3.  三角性误差：$\\max_{i > j} |R_{i,j}| \\le \\tau$。\n-   **测试用例**：提供了五个特定的矩阵 $A_1, \\dots, A_5$。\n-   **最终输出**：一个布尔值列表，每个测试用例对应一个值，表示所有三项检查是否都通过。\n\n**步骤 2：使用提取的要点进行验证**\n\n该问题具有科学依据、适定且客观。它描述了数值线性代数中的一个标准基础算法。其约束和验证检查是精确且可形式化的。\n\n存在一个微小的不一致之处：问题标题为“瘦分解”(thin-factorization)，但输出矩阵的明确定义（$Q \\in \\mathbb{R}^{m \\times m}$，$R \\in \\mathbb{R}^{m \\times n}$）描述的是通常所说的*完全* QR 分解。正交性检查 $\\lVert Q^\\mathsf{T} Q - I \\rVert_{\\max} \\le \\tau$ 进一步证实了期望得到的是完整的 $m \\times m$ 单位矩阵，从而强化了对完全分解的要求。这种差异是标题中的用词不当，而非实质性矛盾。问题主体中的详细说明是一致且明确的。\n\n**步骤 3：结论与行动**\n\n该问题被判定为**有效**。我将根据维度和验证要求中明确规定的内容，着手实现完全 QR 分解。\n\n### 算法设计与原理\n\n算法的核心是通过从左侧应用一系列 Givens 旋转，将矩阵 $A$ 转换为上三角矩阵 $R$：\n$$\nG_k \\cdots G_2 G_1 A = R\n$$\n每个 Givens 旋转 $G$ 都是一个正交矩阵，因此它们的乘积也是正交的。令 $Q_{\\text{applied}} = G_k \\cdots G_1$。则有 $Q_{\\text{applied}} A = R$，这意味着 $A = Q_{\\text{applied}}^\\mathsf{T} R$。因此，所求的正交因子是 $Q = Q_{\\text{applied}}^\\mathsf{T} = (G_k \\cdots G_1)^\\mathsf{T} = G_1^\\mathsf{T} G_2^\\mathsf{T} \\cdots G_k^\\mathsf{T}$。\n\n我们可以通过初始化 $R=A$ 和 $Q=I_m$（$m \\times m$ 的单位矩阵）并迭代更新它们来实现。对于用于将某个元素置零的每个 Givens 旋转 $G$，我们更新：\n1.  $R \\leftarrow G R$\n2.  $Q \\leftarrow Q G^\\mathsf{T}$\n\n**Givens 旋转**\n\nGivens 旋转矩阵 $G$ 用于将向量中的特定元素置零。为了使用第 $j$ 行的主元 $a$（在同一列中）消去第 $i$ 行的元素 $b$，我们在 $(j, i)$ 平面内应用一个旋转。对向量 $\\begin{pmatrix} a \\\\ b \\end{pmatrix}$ 的变换为：\n$$\n\\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix} \\begin{pmatrix} a \\\\ b \\end{pmatrix} = \\begin{pmatrix} \\sqrt{a^2+b^2} \\\\ 0 \\end{pmatrix}\n$$\n这要求 $c^2 + s^2 = 1$。参数 $c$ 和 $s$ 可以在不使用三角函数的情况下确定：\n$$\nr = \\sqrt{a^2+b^2}, \\quad c = \\frac{a}{r}, \\quad s = \\frac{b}{r}\n$$\n为了数值稳定性，特别是为了防止大的 $a, b$ 导致溢出或小的 $a, b$ 导致精度损失，计算 $r = \\sqrt{a^2+b^2}$ 时应使用一个等效于 `hypot(a, b)` 的鲁棒函数。\n\n**过程**\n\n该算法逐列进行，从 $j=0$ 到 $n-1$。对于每一列 $j$，它遍历对角线以下的行，从 $i=j+1$ 到 $m-1$，将元素 $R_{i,j}$ 置零。\n\n对于每个要置零的元素 $R_{i,j}$：\n1.  主元是 $a = R_{j,j}$，目标元素是 $b = R_{i,j}$。\n2.  稳定地计算旋转参数 $c$ 和 $s$。如果 $b$ 已经为零，则旋转是单位变换（$c=1, s=0$）。\n3.  将旋转应用于矩阵 $R$ 的第 $j$ 行和第 $i$ 行。对于从 $j$ 到 $n-1$ 的每一列 $k$，元素 $(R_{j,k}, R_{i,k})$ 更新如下：\n    $$\n    \\begin{pmatrix} R'_{j,k} \\\\ R'_{i,k} \\end{pmatrix} = \\begin{pmatrix} c & s \\\\ -s & c \\end{pmatrix} \\begin{pmatrix} R_{j,k} \\\\ R_{i,k} \\end{pmatrix}\n    $$\n4.  通过右乘 $G^\\mathsf{T}$ 来更新矩阵 $Q$。这会混合 $Q$ 的第 $j$ 列和第 $i$ 列：\n    $$\n    \\begin{pmatrix} Q'_{\\text{col } j} & Q'_{\\text{col } i} \\end{pmatrix} = \\begin{pmatrix} Q_{\\text{col } j} & Q_{\\text{col } i} \\end{pmatrix} \\begin{pmatrix} c & -s \\\\ s & c \\end{pmatrix}\n    $$\n\n重复此过程，直到所有次对角线元素都为零，最终得到矩阵 $Q$ 和 $R$。然后对计算出的因子执行验证检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef givens_qr_factorization(A: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Computes the full QR factorization of a matrix A using Givens rotations.\n\n    Args:\n        A (np.ndarray): An m x n real matrix with m >= n.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple (Q, R) where Q is an m x m\n        orthogonal matrix and R is an m x n upper triangular matrix.\n    \"\"\"\n    m, n = A.shape\n    # Use float64 for higher precision to meet the tight tolerance\n    R = A.copy().astype(np.float64)\n    Q = np.identity(m, dtype=np.float64)\n\n    # Iterate through columns to introduce zeros\n    for j in range(n):\n        # Iterate through rows below the diagonal to zero out elements.\n        # This implementation uses the more common top-down approach for\n        # eliminating elements in a column, which is valid.\n        for i in range(j + 1, m):\n            # Pivot element is R[j, j], element to zero is R[i, j]\n            a = R[j, j]\n            b = R[i, j]\n\n            # If the subdiagonal element is already zero, no rotation is needed.\n            # Using a small tolerance check is robust for floating point numbers.\n            if np.isclose(b, 0.0):\n                continue\n\n            # Compute Givens rotation parameters c and s stably.\n            # np.hypot(a, b) calculates sqrt(a^2 + b^2) without intermediate\n            # overflow or underflow. This satisfies the problem's constraint\n            # as it relies only on arithmetic and square roots.\n            r = np.hypot(a, b)\n            c = a / r\n            s = b / r\n\n            # The Givens rotation G has the 2x2 block [[c, s], [-s, c]].\n            # Update R: R_new = G @ R_old.\n            # This transformation affects rows j and i of R.\n            # new_row_j = c * old_row_j + s * old_row_i\n            # new_row_i = -s * old_row_j + c * old_row_i\n            # We copy the slices to avoid overwriting data that's still needed.\n            R_j_row = R[j, j:].copy()\n            R_i_row = R[i, j:].copy()\n            R[j, j:] = c * R_j_row + s * R_i_row\n            R[i, j:] = -s * R_j_row + c * R_i_row\n\n            # Update Q: Q_new = Q_old @ G.T.\n            # G.T has the 2x2 block [[c, -s], [s, c]].\n            # This transformation affects columns j and i of Q.\n            # new_col_j = c * old_col_j + s * old_col_i\n            # new_col_i = -s * old_col_j + c * old_col_i\n            Q_j_col = Q[:, j].copy()\n            Q_i_col = Q[:, i].copy()\n            Q[:, j] = c * Q_j_col + s * Q_i_col\n            Q[:, i] = -s * Q_j_col + c * Q_i_col\n\n    return Q, R\n\ndef solve():\n    \"\"\"\n    Main function to run the Givens QR factorization on test cases and verify.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[2, -1, 0], [3, 4, 1], [0, 1, 3], [5, -2, 2]], dtype=float),\n        np.array([[1e-12, 2, -3], [4, -5, 6], [7, 8, -1e-12], [-2, 0.5, 1.5], [3, -1e-9, 2.5]], dtype=float),\n        np.array([[4, -1, 2], [0, 3, -5], [0, 0, 2]], dtype=float),\n        np.array([[1, 2, 3, 4], [2, 0, -1, 1], [0, -3, 1, 2], [-1, 4, 0, -2], [3, -1, 2, 0], [5, 2, -2, 1]], dtype=float),\n        np.array([[1, 0, 1], [2, -1, 0], [3, 1, 5], [4, 2, 8]], dtype=float),\n    ]\n\n    tau = 1e-10\n    results = []\n\n    for A in test_cases:\n        m, n = A.shape\n        Q, R = givens_qr_factorization(A)\n\n        # 1. Reconstruction check\n        norm_A = np.linalg.norm(A, 'fro')\n        recon_err = np.linalg.norm(A - Q @ R, 'fro') / max(norm_A, 1.0)\n        check1 = recon_err <= tau\n\n        # 2. Orthogonality check\n        I_m = np.identity(m)\n        ortho_err = np.max(np.abs(Q.T @ Q - I_m))\n        check2 = ortho_err <= tau\n\n        # 3. Triangularity check\n        # np.tril(R, k=-1) extracts the strict lower triangular part of R.\n        tri_err = np.max(np.abs(np.tril(R, k=-1)))\n        check3 = tri_err <= tau\n        \n        results.append(check1 and check2 and check3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3236226"}, {"introduction": "吉文斯旋转的真正威力体现在稀疏矩阵等专门应用中。这个练习[@problem_id:3569157]探讨了“填充”（fill-in）这一关键概念，即分解过程在初始稀疏的矩阵中引入了非零元。你将运用组合推理来理解为何朴素的运算顺序会对性能造成灾难性影响，并学习如何通过深思熟虑的排序来保持稀疏性。", "problem": "设 $k \\ge 3$ 为一个整数，并考虑一个稀疏矩阵 $A \\in \\mathbb{R}^{(k+1)\\times (k+1)}$，其列和行均由 $0,1,2,\\dots,k$ 索引，定义如下\n$$\nA_{0,0}=1,\\quad A_{i,0}=1\\ \\text{for}\\ i=1,\\dots,k,\\quad A_{i,i}=1\\ \\text{for}\\ i=1,\\dots,k,\n$$\n所有其他元素均为 $0$。换句话说，第一列在每一行都有一个非零元，而其他每一列 $i \\in \\{1,\\dots,k\\}$ 仅在第 $i$ 行有一个非零元。\n\n您使用 Givens 旋转，并遵循以下协议，执行瘦 QR 分解 $A=Q R$：按 $0,1,2,\\dots,k$ 的顺序处理各列；对于每一列 $j$，对行对应用一系列 Givens 旋转，以将列 $j$ 中对角线位置 $(j,j)$ 下方的所有元素置零，同时保持 $Q$ 的正交性和 $R$ 的上三角性。\n\n从以下核心事实出发：(i) Givens 旋转是一种正交变换，除了在选定的 $2\\times 2$ 主子空间行上，其作用等同于单位变换；(ii) 在没有列主元选择的情况下，QR 分解中的上三角因子 $R$ 的非零模式与相同列排序下 $A^{\\top}A$ 的 Cholesky 因子的非零模式相同。请回答以下问题：\n\n1. 构造与 $A$ 相关的列交集图，并使用图消去法解释为什么在形成 $R$ 时首先处理第 $0$ 列会导致严重的填充。\n2. 以 $k$ 的闭式表达式，确定 $R$ 中对应于列 $1,2,\\dots,k$ 的子矩阵中，仅因此排序导致的填充而变为非零的严格上三角元的精确数量（即，在输入中结构上为零但在 $R$ 中为非零的元素）。\n3. 提出一种避免这种填充的列排序策略，并从组合学的角度证明其合理性。\n\n您的最终答案应为第 2 项所要求的单个闭式表达式。无需四舍五入。", "solution": "所述问题具有科学依据，提法恰当且客观。它基于数值线性代数的既定原理，特别是稀疏 QR 分解。所有必要信息均已提供，问题明确无误。因此，该问题是有效的，我将给出完整解答。\n\n对于整数 $k \\ge 3$，矩阵 $A \\in \\mathbb{R}^{(k+1)\\times (k+1)}$ 由其非零元定义：$A_{0,0}=1$，$A_{i,0}=1$ 对于 $i=1,\\dots,k$，$A_{i,i}=1$ 对于 $i=1,\\dots,k$。所有其他元素均为零。行和列的索引从 $0$ 到 $k$。\n\n设 $c_j$ 表示 $A$ 的第 $j$ 列。根据定义：\n- 第一列 $c_0$ 的元素为 $A_{i,0}=1$，其中 $i \\in \\{0, 1, \\dots, k\\}$。因此，$c_0$ 是全 1 向量。\n- 对于任何其他列 $j \\in \\{1, \\dots, k\\}$，唯一的非零元素是 $A_{j,j}=1$。因此，$c_j$ 是标准基向量 $e_j$（使用从 0 开始的索引，在第 $j$ 个位置为 1）。\n\n例如，当 $k=3$ 时，矩阵 $A$ 为：\n$$\nA = \\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n1 & 1 & 0 & 0 \\\\\n1 & 0 & 1 & 0 \\\\\n1 & 0 & 0 & 1\n\\end{pmatrix}\n$$\n这个矩阵是下三角矩阵。然而，正如我们将看到的，通过从左到右逐列消去次对角线元素来执行 QR 分解会引入大量的填充。\n\n问题陈述了一个关键事实：$A$ 的 QR 分解得到的上三角因子 $R$ 的非零模式与矩阵 $A^{\\top}A$ 的 Cholesky 因子的非零模式相同。这使我们能够通过分析 $A^{\\top}A$ 的结构及其符号 Cholesky 分解来确定 $R$ 中的填充。\n\n设 $B = A^{\\top}A$。元素 $B_{ij}$ 是 $A$ 的第 $i$ 列 $c_i$ 和第 $j$ 列 $c_j$ 的内积。\n- 对于 $i=j=0$：$B_{00} = c_0^{\\top} c_0 = \\sum_{l=0}^{k} 1^2 = k+1$。\n- 对于 $i=0$ 和 $j \\in \\{1, \\dots, k\\}$：$B_{0j} = c_0^{\\top} c_j = c_0^{\\top} e_j = 1$。根据对称性，$B_{j0}=1$。\n- 对于 $i, j \\in \\{1, \\dots, k\\}$ 且 $i \\neq j$：$B_{ij} = c_i^{\\top} c_j = e_i^{\\top} e_j = 0$。\n- 对于 $i \\in \\{1, \\dots, k\\}$：$B_{ii} = c_i^{\\top} c_i = e_i^{\\top} e_i = 1$。\n\n所以，矩阵 $B=A^{\\top}A$ 的结构如下：\n$$\nB = \\begin{pmatrix}\nk+1 & 1 & 1 & \\dots & 1 \\\\\n1 & 1 & 0 & \\dots & 0 \\\\\n1 & 0 & 1 & \\dots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & 0 & 0 & \\dots & 1\n\\end{pmatrix}\n$$\n\n**1. 列交集图与填充**\n\n$A$ 的列交集图，记为 $G_A$，其顶点为 $\\{0, 1, \\dots, k\\}$，对应于 $A$ 的各列。当且仅当列 $c_i$ 和 $c_j$ 在同一行中都有非零元素时，顶点 $i$ 和 $j$ 之间存在一条边。这等价于条件 $B_{ij} = (A^{\\top}A)_{ij} \\neq 0$（对于 $i \\neq j$）。\n\n根据 $B$ 的结构，我们可以构造 $G_A$：\n- 对于所有 $j \\in \\{1, \\dots, k\\}$，存在边 $(0, j)$，因为 $B_{0j}=1$。\n- 对于 $i, j \\in \\{1, \\dots, k\\}$ 且 $i \\neq j$，不存在边 $(i, j)$，因为 $B_{ij}=0$。\n该图是一个“星形图”，其中顶点 $0$ 是中心，顶点 $\\{1, 2, \\dots, k\\}$ 是叶节点。\n\n形成 Cholesky 因子（或执行高斯消去）的过程可以在此图上建模。当一个顶点 $v$ 被消去时，它的所有邻居会形成一个团（即它们两两相连）。这些新增加的边对应于“填充”——即在 $B$ 中为零但在 Cholesky 因子中变为非零的元素。\n\n问题指定按 $0, 1, 2, \\dots, k$ 的顺序处理列。这对应于按相同顺序消去 $G_A$ 中的顶点。我们首先消去顶点 $0$。顶点 $0$ 的邻居是集合 $\\{1, 2, \\dots, k\\}$。当顶点 $0$ 被消去时，它的所有邻居对之间都会添加一条边。也就是说，对于每一对不同的 $i, j \\in \\{1, 2, \\dots, k\\}$，都会创建一条新边 $(i, j)$。\n\n由顶点 $\\{1, \\dots, k\\}$ 诱导的原始子图是空图（没有边）。在消去顶点 $0$ 之后，该子图变成一个完全图（一个团）。这表示 $B$ 的 Cholesky 因子中（以及 $R$ 中）对应的子矩阵变得完全稠密。这就是此排序引起的“严重填充”。\n\n**2. 填充元素的数量**\n\n题目要求我们计算 $R$ 中对应于列 $1, 2, \\dots, k$ 的子矩阵中属于填充的严格上三角元的数量。我们将这个 $k \\times k$ 的子矩阵表示为 $R_{1:k, 1:k}$。\n\n- **原始结构**：原始矩阵 $A$ 中从 $1$ 到 $k$ 的列是标准基向量 $e_1, \\dots, e_k$。因此，对于任何满足 $1 \\le i < j \\le k$ 的索引对 $(i, j)$，元素 $A_{ij}$ 为 $0$。$A$ 中对应于列 $\\{1, \\dots, k\\}$ 和行 $\\{1, \\dots, k\\}$ 的子矩阵的严格上三角部分完全为零。\n- **分解后结构**：如上所述，首先消去第 $0$ 列会导致顶点 $\\{1, \\dots, k\\}$ 上的子图变成一个团。这意味着在上三角因子 $R$ 中，子矩阵 $R_{1:k, 1:k}$ 将是一个稠密的上三角矩阵。对于 $1 \\le i \\le j \\le k$，每个元素 $R_{ij}$ 都将是非零的。\n- **计算填充**：填充元素是指那些在 $A$ 中为零但在 $R$ 中非零的元素。我们关心的是对应于列 $1, \\dots, k$ 的子矩阵的严格上三角元。这些是满足 $1 \\le i < j \\le k$ 的元素 $R_{ij}$。由于所有这些元素在 $A$ 中都为零，而在 $R$ 中变为非零，所以填充元素的数量就是这些位置的总数。这正是一个 $k \\times k$ 矩阵的严格上三角部分的元素数量。\n\n这些元素的数量由以下总和给出：\n$$ \\sum_{j=2}^{k} (j-1) = \\sum_{i=1}^{k-1} i = \\frac{(k-1)k}{2} = \\binom{k}{2} $$\n该表达式给出了所要求的填充元素的精确数量。对于 $k \\ge 3$，这个数总是正的。\n\n**3. 最优列排序**\n\n严重的填充是由于首先消去了度数最高的顶点（星形图的中心）造成的。为了最小化填充，一种通用的启发式方法是“最小度”排序，它优先消去邻居最少的顶点。\n\n在图 $G_A$ 中，顶点 $0$ 的度为 $k$，而每个顶点 $j \\in \\{1, \\dots, k\\}$ 的度为 $1$。因此，最小度排序会先消去顶点 $1, 2, \\dots, k$（以任意顺序），然后再消去顶点 $0$。\n让我们考虑排序 $1, 2, \\dots, k, 0$。\n- 消去顶点 $1$：它唯一的邻居是 $0$。没有邻居对需要连接，所以没有填充。\n- 消去顶点 $2$：它唯一的邻居是 $0$。没有填充。\n- ...\n- 消去顶点 $k$：它唯一的邻居是 $0$。没有填充。\n在消去所有从 $1$ 到 $k$ 的顶点后，没有创建任何新边。图中只剩下一个孤立的顶点 $0$。接着消去顶点 $0$ 也不会产生填充。\n这种排序是一种“完美消去排序”，因为它产生零填充。\n\n因此，任何将第 $0$ 列放在最后处理的排序，例如 $(1, 2, \\dots, k, 0)$，都将避免所描述的填充。从组合学的角度来看，这可以通过对列交集图应用最小度算法来证明其合理性。\n\n最终需要的答案是第 2 部分的闭式表达式。\n填充元素的数量 = $\\frac{k(k-1)}{2}$。", "answer": "$$\\boxed{\\frac{k(k-1)}{2}}$$", "id": "3569157"}]}