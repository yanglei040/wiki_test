{"hands_on_practices": [{"introduction": "本练习是掌握对称三对角矩阵特征值二分法的基础。你将从头开始实现整个算法，包括通过$LDL^\\top$分解实现Sturm序列计数，以及使用Gershgorin圆盘定理确定初始搜索区间。通过这个编码实践[@problem_id:3586250]，你将把理论知识转化为可工作的代码，并根据一个具有已知解析解的矩阵族来验证其准确性和数值行为，从而加深对核心机制的理解。", "problem": "要求您从第一性原理出发，使用Sturm理论实现用于计算实对称三对角矩阵所有特征值的二分法，并在一个具有已知谱的矩阵族上验证其数值精度和缩放行为。该矩阵族是在单位区间上带狄利克雷（Dirichlet）边界条件的一维负二阶导数的中心二阶差分离散化。对于选定的整数大小 $n \\ge 1$，内部网格间距为 $h = 1/(n+1)$，未缩放的矩阵是一个 $n \\times n$ 的三对角矩阵，其对角线元素为 $2/h^2$，次对角线/超对角线元素为 $-1/h^2$。对于任意正常数标量 $c  0$，考虑缩放后的矩阵 $A_n(c) = c \\cdot A_n(1)$。$A_n(c)$ 的精确特征值具有闭式解，可用作验证的基准真相。\n\n您可以依赖的基础知识仅包括以下经过充分检验的事实和核心定义：\n- 实对称矩阵具有实特征值，并且可以进行正交对角化。\n- 通过Sturm理论，可以计算实对称三对角矩阵严格小于某个实数标量平移的特征值数量，这等价于计算平移后矩阵的 $LDL^\\top$ 分解中负主元的数量。\n- Gershgorin圆盘定理提供了包含谱的界。\n- 对于在 $[0,1]$ 上带狄利克雷边界条件的中心二阶差分算子，离散正弦变换可将矩阵族 $A_n(c)$ 对角化，其精确特征值构成一个严格递增的序列。\n- 将一个矩阵乘以一个正常数标量 $c$，其特征值也会被乘以相同的标量 $c$。\n\n您的任务是：\n- 实现一个函数，该函数接收一个大小为 $n$ 的实对称三对角矩阵的对角线元素 $d_i$ 和次对角线元素 $e_i$，以及一个实数标量 $x$，并使用一种基于无主元 $LDL^\\top$ 分解的数值稳定Sturm理论实现，返回严格小于 $x$ 的特征值数量。\n- 实现一个全局特征值二分程序，该程序接收 $(d,e)$ 和容差，并按非递减顺序返回所有 $n$ 个特征值。使用Gershgorin界来获得一个可证明的包围区间，并在Sturm计数法的指导下执行区间细分，从而将每个特征值隔离在指定的容差范围内。\n- 构造具有 $n$ 个内部点和缩放因子 $c$ 的矩阵族 $A_n(c)$，并根据离散正弦变换所蕴含的闭式表达式计算精确特征值。使用这些精确值来量化精度。\n- 设计并执行以下测试套件，每个测试报告一个标量值：\n  1. 中等规模未缩放情况下的精度：$n=8, c=1$。\n  2. 边界情况：$n=1, c=1$。\n  3. 小规模情况：$n=2, c=1$。\n  4. 中等规模情况下的缩放验证：$n=32, c=3.7$。\n  5. 较大规模情况下的性能和聚类行为：$n=200, c=1$。\n\n对于每个测试，计算数值计算出的特征值 $\\{\\hat{\\lambda}_k\\}_{k=1}^n$ 与精确特征值 $\\{\\lambda_k\\}_{k=1}^n$ 之间的最大相对误差：\n$$\n\\varepsilon_{\\max} = \\max_{1 \\le k \\le n} \\frac{|\\hat{\\lambda}_k - \\lambda_k|}{|\\lambda_k|}.\n$$\n将每个 $\\varepsilon_{\\max}$ 报告为浮点数。\n\n实现要求：\n- 您的程序必须仅通过对对称三对角矩阵使用由Sturm计数驱动的二分法来计算所有特征值，不得调用任何黑盒稠密矩阵特征值例程。\n- 使用Gershgorin圆盘构造初始全局搜索区间。\n- 当包含一个特征值的区间宽度小于或等于 $\\max\\{ \\text{atol}, \\text{rtol} \\cdot \\max(|a|,|b|,1) \\}$ 时，终止该区间的二分过程。其中 $[a,b]$ 是当前区间，绝对容差 $\\text{atol}$ 和相对容差 $\\text{rtol}$ 的选择应在双精度算术中既严格又可行。\n\n用于验证的精确谱：\n- 对于网格间距为 $h = 1/(n+1)$ 的 $A_n(c)$，其精确特征值由下式给出\n$$\n\\lambda_k = c \\cdot \\frac{4}{h^2} \\sin^2\\!\\left( \\frac{k \\pi}{2 (n+1)} \\right), \\quad k=1,2,\\dots,n.\n$$\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]”），其中 $r_i$ 是测试 $i$ 的最大相对误差 $\\varepsilon_{\\max}$。\n\n测试套件参数正是上面列出的五对 $(n,c)$：\n- 测试 1: $(n,c) = (8,1)$。\n- 测试 2: $(n,c) = (1,1)$。\n- 测试 3: $(n,c) = (2,1)$。\n- 测试 4: $(n,c) = (32,3.7)$。\n- 测试 5: $(n,c) = (200,1)$。\n\n不涉及物理单位。精确谱公式中的角度使用弧度。最终答案必须是浮点数。程序不得要求任何输入，并且除了指定的单行输出外，不得打印任何额外文本。", "solution": "用户提供的问题是有效的，要求实现二分法来寻找一个实对称三对角矩阵的所有特征值。解决方案将通过一个已知的解析测试案例进行验证。实现将遵循指定的第一性原理方法，结合用于特征值计数的Sturm理论和用于初始谱界的Gershgorin圆盘。\n\n### 1. 理论基础\n\n一个大小为 $n$ 的实对称三对角矩阵 $T$ 有 $n$ 个实特征值。寻找这些特征值的二分法依赖于一个函数 `count(x)`，该函数确定 $T$ 的特征值中小于或等于给定标量 $x$ 的数量。\n\n#### 1.1. Sturm序列与特征值计数\n\nSturm理论为 `count(x)` 函数提供了基础。对于一个对称矩阵 $T$，严格小于 $x$ 的特征值数量由 $T - xI$ 的顺序主子式行列式序列 $\\{p_k(x) = \\det((T-xI)_{1:k, 1:k})\\}_{k=1}^n$ 中的符号变化次数给出。通过分析 $T - xI$ 的 $LDL^\\top$ 分解，可以稳定地计算这个数量，而没有溢出或下溢的风险。其中 $L$ 是单位下双对角矩阵，$D$ 是主元组成的对角矩阵。\n\n根据西尔维斯特惯性定理（Sylvester's Law of inertia），$D$ 中的负主元数量等于 $T - xI$ 的负特征值数量，这恰好是 $T$ 的严格小于 $x$ 的特征值数量。这些主元，我们称之为 $\\delta_i$，可以通过以下递推关系计算：\n$$\n\\delta_1 = d_1 - x \\\\\n\\delta_i = (d_i - x) - \\frac{e_{i-1}^2}{\\delta_{i-1}}, \\quad i=2, \\dots, n\n$$\n其中 $d_i$ 是 $T$ 的对角线元素，$e_{i-1}$ 是次对角线元素。如果一个主元 $\\delta_{i-1}$ 为零，则会发生除以零的情况，这当且仅当 $x$ 是顺序主子矩阵 $T_{i-1}$ 的一个特征值时才会发生。在浮点运算中，这种情况很少见。一个稳健的实现通过将零主元扰动为一个很小的值 $\\varepsilon$ 来处理此问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global tolerances for bisection, chosen to be stringent for double precision.\nATOL = 1e-14\nRTOL = 1e-14\n\ndef sturm_count(d, e, x):\n    \"\"\"\n    Counts the number of eigenvalues of a symmetric tridiagonal matrix T\n    that are strictly less than a given scalar x.\n    Uses the LDL^T factorization of T - xI and Sylvester's Law of Inertia.\n    The number of eigenvalues  x is the number of negative pivots (diagonal entries of D).\n\n    Args:\n        d (np.ndarray): Diagonal entries of T (length n).\n        e (np.ndarray): Off-diagonal entries of T (length n-1).\n        x (float): The scalar shift.\n\n    Returns:\n        int: The number of eigenvalues of T strictly less than x.\n    \"\"\"\n    n = len(d)\n    if n == 0:\n        return 0\n\n    count = 0\n    # A small positive value to perturb zero pivots, relative to the matrix norm.\n    # This ensures numerical stability and prevents division by zero.\n    # A positive perturbation corresponds to counting eigenvalues strictly less than x.\n    if n == 1:\n        norm_est = np.abs(d[0])\n    else:\n        norm_est = np.max(np.abs(d)) + 2 * np.max(np.abs(e))\n    \n    eps = np.finfo(float).eps * (norm_est if norm_est > 0 else 1.0)\n    \n    delta = d[0] - x\n    if delta  0:\n        count += 1\n    if delta == 0:\n        delta = eps\n    \n    for i in range(1, n):\n        delta = (d[i] - x) - (e[i-1]**2) / delta\n        if delta  0:\n            count += 1\n        if delta == 0:\n            delta = eps\n            \n    return count\n\ndef find_all_eigenvalues(d, e):\n    \"\"\"\n    Computes all eigenvalues of a real symmetric tridiagonal matrix\n    using the bisection method driven by Sturm sequence counts.\n\n    Args:\n        d (np.ndarray): Diagonal entries of T (length n).\n        e (npndarray): Off-diagonal entries of T (length n-1).\n\n    Returns:\n        np.ndarray: A sorted array of the computed eigenvalues.\n    \"\"\"\n    n = len(d)\n    if n == 0:\n        return np.array([])\n    if n == 1:\n        return np.array([d[0]])\n\n    # Step 1: Find an interval [low, high] containing all eigenvalues using Gershgorin circles.\n    radii = np.zeros(n)\n    radii[0] = np.abs(e[0])\n    radii[-1] = np.abs(e[-1])\n    for i in range(1, n - 1):\n        radii[i] = np.abs(e[i - 1]) + np.abs(e[i])\n    \n    low = np.min(d - radii)\n    high = np.max(d + radii)\n\n    # Slightly expand the interval to ensure endpoints are not eigenvalues and counts are stable.\n    span = high - low\n    if span == 0:\n        span = abs(low) if low != 0 else 1.0\n    low -= span * 1e-10 + 1e-10\n    high += span * 1e-10 + 1e-10\n\n    # Step 2: Use bisection to isolate eigenvalues.\n    # Each item is (l, h, n_l, n_h), where [l, h) contains n_h - n_l eigenvalues.\n    n_low = sturm_count(d, e, low)\n    n_high = sturm_count(d, e, high)\n    intervals = [(low, high, n_low, n_high)]\n    \n    found_eigs = []\n\n    while intervals:\n        l, h, nl, nh = intervals.pop(0)\n        \n        num_eigs_in_interval = nh - nl\n        if num_eigs_in_interval == 0:\n            continue\n        \n        # Termination tolerance for isolating a single eigenvalue.\n        tol = max(ATOL, RTOL * max(abs(l), abs(h), 1.0))\n        \n        if num_eigs_in_interval == 1:\n            # Refine the interval for the single eigenvalue.\n            while (h - l) > tol:\n                m = l + (h - l) / 2\n                nm = sturm_count(d, e, m)\n                if nm == nl:  # Eigenvalue is in [m, h)\n                    l = m\n                else:  # Eigenvalue is in [l, m)\n                    h = m\n            found_eigs.append(l + (h - l) / 2)\n        else:\n            # If interval is too small to split but contains multiple eigenvalues,\n            # it indicates a cluster. We cannot resolve them further.\n            if (h - l) = tol:\n                mid = l + (h - l) / 2\n                for _ in range(num_eigs_in_interval):\n                    found_eigs.append(mid)\n                continue\n\n            # Split the interval and add new sub-intervals to the queue.\n            mid = l + (h - l) / 2\n            n_mid = sturm_count(d, e, mid)\n            \n            # Left sub-interval [l, mid)\n            if n_mid > nl:\n                intervals.append((l, mid, nl, n_mid))\n            \n            # Right sub-interval [mid, h)\n            if nh > n_mid:\n                intervals.append((mid, h, n_mid, nh))\n\n    found_eigs.sort()\n    return np.array(found_eigs)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (8, 1.0),\n        (1, 1.0),\n        (2, 1.0),\n        (32, 3.7),\n        (200, 1.0),\n    ]\n\n    results = []\n    for n, c in test_cases:\n        # Construct the matrix T = A_n(c) and its exact eigenvalues.\n        h = 1.0 / (n + 1)\n        d_val = c * 2.0 / h**2\n        e_val = c * -1.0 / h**2\n        \n        d = np.full(n, d_val)\n        e = np.full(n - 1, e_val) if n > 1 else np.array([])\n        \n        k = np.arange(1, n + 1)\n        exact_eigs = c * (4.0 / h**2) * np.sin(k * np.pi / (2.0 * (n + 1)))**2\n        \n        # Compute eigenvalues using the implemented bisection method.\n        computed_eigs = find_all_eigenvalues(d, e)\n        \n        if len(computed_eigs) != n:\n             raise RuntimeError(f\"Error: Found {len(computed_eigs)} eigenvalues, expected {n} for case (n={n}, c={c}).\")\n\n        # Quantify the maximum relative error.\n        if n > 0:\n            relative_errors = np.abs(computed_eigs - exact_eigs) / np.abs(exact_eigs)\n            max_rel_error = np.max(relative_errors)\n        else:\n            max_rel_error = 0.0\n\n        results.append(max_rel_error)\n\n    # Final print statement must be in the exact specified format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3586250"}, {"introduction": "实际的数值算法必须考虑浮点运算的局限性。这个练习探讨了“缩减”（deflation）这一关键概念，即当一个非对角线元素在数值上可以忽略时，将其设置为零以提高算法的效率和稳定性。通过这个练习[@problem_id:3586270]，你将基于浮点误差模型推导出一个实用的缩减准则，并运用Weyl定理为这一近似操作所引入的特征值扰动提供一个严格的界。", "problem": "考虑一个实对称三对角矩阵 $T \\in \\mathbb{R}^{n \\times n}$，其对角线元素为 $\\{a_{i}\\}_{i=1}^{n}$，次对角线元素为 $\\{b_{i}\\}_{i=1}^{n-1}$，形式如下\n$$\nT = \\begin{pmatrix}\na_{1}  b_{1}  0  \\cdots  0 \\\\\nb_{1}  a_{2}  b_{2}  \\ddots  \\vdots \\\\\n0  b_{2}  a_{3}  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  b_{n-1} \\\\\n0  \\cdots  0  b_{n-1}  a_{n}\n\\end{pmatrix}.\n$$\n在计算 $T$ 的特征值的二分法中，Sturm 序列计数是通过对 $T - x I$ 进行标量 $L D L^{\\top}$ 分解得到的，其中 $x$ 为实数位移，其递推关系为\n$$\np_{1}(x) = a_{1} - x,\\qquad p_{i+1}(x) = a_{i+1} - x - \\frac{b_{i}^{2}}{p_{i}(x)},\\quad i=1,\\dots,n-1,\n$$\n并且负主元 $\\{p_{i}(x)\\}$ 的数量等于 $T$ 小于 $x$ 的特征值的数量。在标准浮点运算误差模型下，对于任意基本运算 $\\circ \\in \\{+,-,\\times,\\div\\}$，计算结果满足 $\\operatorname{fl}(u \\circ v) = (u \\circ v)(1+\\delta)$，其中 $|\\delta| \\leq \\varepsilon$，$\\varepsilon$ 表示机器精度（对于电气和电子工程师协会浮点算术标准 (IEEE 754) 双精度，$\\varepsilon = 2^{-53}$）。可以观察到，如果 $|b_{i}|$ 相对于相邻对角线元素的大小足够小，则可以通过将 $b_{i}$ 置为零来进行有效的降阶（deflation），而不会对 Sturm 计数或特征值产生超出浮点舍入范围的实质性影响。\n\n请从浮点误差模型的基本原理和上述 Sturm 序列递推关系出发，推导一个形如\n$$\n|b_{i}| \\leq \\tau_{i},\n$$\n的充分降阶检测准则，其中 $\\tau_{i}$ 仅依赖于 $\\varepsilon$ 和相邻对角线元素的大小，并证明该准则能确保在 $x$ 的相关范围内，耦合项 $\\frac{b_{i}^{2}}{p_{i}(x)}$ 与舍入扰动处于同一量级。然后，利用对称矩阵的 Weyl 特征值扰动界，并通过显式计算将一个 $b_{i}$ 置为零时的扰动范数，为降阶引起的每个特征值的可能变化提供一个严格的界。\n\n将您的分析应用于以下 $n=5$ 的具体实例：\n$$\nT = \\begin{pmatrix}\n6.0  0.5  0  0  0 \\\\\n0.5  5.5  0.45  0  0 \\\\\n0  0.45  5.6  3.2 \\times 10^{-9}  0 \\\\\n0  0  3.2 \\times 10^{-9}  -1.0  0.3 \\\\\n0  0  0  0.3  2.0\n\\end{pmatrix}.\n$$\n取 $\\varepsilon = 2^{-53}$。使用您推导的降阶准则来判断在位置 $i=3$ 处进行降阶（即将 $b_{3}$ 置为零）是否合理。然后计算将 $b_{3}$ 置为零导致的 $T$ 的每个特征值变化的上界 $B$，该上界表示为相应对称扰动的谱范数。\n\n将您最终的数值界 $B$ 四舍五入到四位有效数字。本问题不涉及物理单位，您的最终答案必须是一个实数。", "solution": "该问题被评估为有效。在数值线性代数的既定框架内，这是一个适定问题，特别涉及对称三对角矩阵的特征值计算。其前提科学合理，术语精确，目标明确，并可利用所提供的信息解决。\n\n此问题需要进行多部分分析。首先，我们基于二分法中使用的 Sturm 序列递推关系，推导并证明一个针对对称三对角矩阵中小的次对角线元素的降阶准则。其次，我们使用矩阵范数分析，为由此产生的特征值扰动建立一个严格的界。最后，我们将这些结果应用于一个具体的数值例子。\n\n**第一部分：降阶准则的推导**\n\n寻找实对称三对角矩阵 $T$ 特征值的二分法可以利用 Sturm 序列性质，即 $T$ 小于给定实数位移 $x \\in \\mathbb{R}$ 的特征值数量等于一个特定序列中负项的数量。这个序列可以由 $T-xI$ 的 $L D L^{\\top}$ 分解的主元生成。这些主元 $\\{p_i(x)\\}_{i=1}^n$ 的递推关系如下：\n$$p_{1}(x) = a_{1} - x$$\n$$p_{i+1}(x) = (a_{i+1} - x) - \\frac{b_{i}^{2}}{p_{i}(x)}, \\quad i=1,\\dots,n-1$$\n在位置 $i$ 进行降阶涉及将次对角线元素 $b_i$ 置为 $0$。在递推关系的背景下，这意味着在计算 $p_{i+1}(x)$ 时忽略耦合项 $C_i(x) = \\frac{b_i^2}{p_i(x)}$。是否进行降阶的决定取决于这个被忽略的项是否小到可以被视为浮点计算中的“噪声”。\n\n我们遵循这样一个原则：如果一个项的量级与计算中主要项的浮点舍入误差所引入的不确定性相当或更小，那么该项可以被忽略。标准浮点运算误差模型对于一个运算 $\\circ$ 是 $\\operatorname{fl}(u \\circ v) = (u \\circ v)(1+\\delta)$，其中 $|\\delta| \\leq \\varepsilon$。当计算一个差值 $\\alpha - \\beta$ 时，绝对舍入误差约为 $\\varepsilon|\\alpha - \\beta|$。如果我们要忽略项 $\\beta$，我们引入的误差是 $|\\beta|$。允许这样做的充分条件是，这个引入的误差与本来就存在的舍入误差是同一量级，即 $|\\beta| \\lesssim \\varepsilon|\\alpha - \\beta|$。如果 $|\\beta| \\ll |\\alpha|$，这个条件简化为 $|\\beta| \\lesssim \\varepsilon|\\alpha|$。\n\n在我们的递推关系中，$\\alpha = a_{i+1} - x$ 且 $\\beta = C_i(x) = \\frac{b_i^2}{p_i(x)}$。应用简化的条件，我们要求：\n$$ \\left| \\frac{b_i^2}{p_i(x)} \\right| \\lesssim \\varepsilon |a_{i+1} - x| $$\n这等价于 $b_i^2 \\lesssim \\varepsilon |p_i(x) (a_{i+1} - x)|$。这个准则依赖于位移 $x$，这对于一个通用的降阶规则来说是不理想的。为了获得一个稳健的、不依赖于 $x$ 的准则，我们用其特征量级替换依赖于 $x$ 的项。对于一个小的次对角线元素 $b_{i-1}$，主元 $p_i(x)$ 近似为 $a_i - x$。在 $T$ 的整个谱上，$|a_k - x|$ 的特征尺度可以取为 $|a_k|$。代入这些尺度，我们得到：\n$$ b_i^2 \\lesssim \\varepsilon |a_i a_{i+1}| $$\n这为降阶提供了一个充分条件。我们将其形式化为：\n$$ |b_i| \\leq \\sqrt{\\varepsilon |a_i a_{i+1}|} $$\n这是我们的降阶检测准则。阈值 $\\tau_i = \\sqrt{\\varepsilon |a_i a_{i+1}|}$ 仅依赖于机器精度 $\\varepsilon$ 和相邻对角线元素的大小，符合要求。\n\n**第二部分：特征值变化的界**\n\n接下来，我们为这种降阶导致的特征值变化提供一个严格的界。将 $b_i$ 置为 $0$ 会将矩阵 $T$ 转换为一个新矩阵 $T'$。差值为扰动矩阵 $E = T - T'$。这个矩阵 $E$ 只有两个非零项：$E_{i,i+1} = E_{i+1,i} = b_i$。我们可以将 $E$ 写为：\n$$ E = b_i (e_i e_{i+1}^{\\top} + e_{i+1} e_i^{\\top}) $$\n其中 $e_k$ 是第 $k$ 个标准基向量。\n\n特征值变化的幅度由扰动矩阵 $E$ 的谱范数（$2$-范数）界定。根据对称矩阵的 Weyl 特征值扰动定理，如果 $\\lambda_k(T)$ 和 $\\lambda_k(T')$ 分别是 $T$ 和 $T'$ 的第 $k$ 个特征值（按非降序排列），那么：\n$$ |\\lambda_k(T) - \\lambda_k(T')| \\leq \\|E\\|_2 $$\n$E$ 的谱范数由 $\\|E\\|_2 = |b_i| \\|e_i e_{i+1}^{\\top} + e_{i+1} e_i^{\\top}\\|_2$ 给出。矩阵 $S = e_i e_{i+1}^{\\top} + e_{i+1} e_i^{\\top}$ 是一个置换矩阵，对应于在由 $e_i$ 和 $e_{i+1}$ 张成的子空间内交换索引 $i$ 和 $i+1$。其特征值是 $S v = \\lambda v$ 的解。对于 $\\mathrm{span}\\{e_i, e_{i+1}\\}$ 的正交补中的任意向量 $v$，$Sv=0$，因此存在一个重数为 $n-2$ 的特征值 $0$。对于 $v = \\alpha e_i + \\beta e_{i+1}$，我们有 $Sv = \\beta e_i + \\alpha e_{i+1}$。特征值方程变为 $\\beta e_i + \\alpha e_{i+1} = \\lambda (\\alpha e_i + \\beta e_{i+1})$，这意味着 $\\beta = \\lambda \\alpha$ 和 $\\alpha = \\lambda \\beta$。将一个代入另一个得到 $\\beta = \\lambda^2 \\beta$，所以 $\\lambda^2=1$，从而得到特征值 $\\lambda = 1$ 和 $\\lambda = -1$。\n对称矩阵的谱范数是其谱半径（其特征值的最大绝对值）。因此，$\\|S\\|_2 = \\max\\{|-1|,|1|,|0|\\} = 1$。\n因此，扰动的谱范数为：\n$$ \\|E\\|_2 = |b_i| \\cdot 1 = |b_i| $$\n当将 $b_i$ 置为 $0$ 时，$T$ 的任何特征值的绝对变化的上界 $B$ 恰好是 $|b_i|$。\n\n**第三部分：具体实例的应用**\n\n我们给定的矩阵是 $T \\in \\mathbb{R}^{5 \\times 5}$：\n$$\nT = \\begin{pmatrix}\n6.0  0.5  0  0  0 \\\\\n0.5  5.5  0.45  0  0 \\\\\n0  0.45  5.6  3.2 \\times 10^{-9}  0 \\\\\n0  0  3.2 \\times 10^{-9}  -1.0  0.3 \\\\\n0  0  0  0.3  2.0\n\\end{pmatrix}\n$$\n我们必须分析在位置 $i=3$ 处的降阶。相关参数如下：\n$a_3 = 5.6$\n$a_4 = -1.0$\n$b_3 = 3.2 \\times 10^{-9}$\n$\\varepsilon = 2^{-53}$\n\n首先，我们使用第一部分推导的准则来检查降阶是否合理：\n$$ |b_3| \\leq \\sqrt{\\varepsilon |a_3 a_4|} $$\n不等式左边是 $|b_3| = 3.2 \\times 10^{-9}$。\n不等式右边是阈值 $\\tau_3$：\n$$ \\tau_3 = \\sqrt{2^{-53} |(5.6)(-1.0)|} = \\sqrt{5.6 \\times 2^{-53}} $$\n我们对其进行数值计算。给定 $2^{-53} \\approx 1.110223 \\times 10^{-16}$：\n$$ \\tau_3 \\approx \\sqrt{5.6 \\times 1.110223 \\times 10^{-16}} \\approx \\sqrt{6.217249 \\times 10^{-16}} \\approx 2.493441 \\times 10^{-8} $$\n需要检查的条件是：\n$$ 3.2 \\times 10^{-9} \\leq 2.493441 \\times 10^{-8} $$\n这个不等式是成立的，因为 $0.32 \\times 10^{-8} \\leq 2.493441 \\times 10^{-8}$。因此，根据我们推导的准则，在位置 $i=3$ 进行降阶是合理的。\n\n其次，我们计算每个特征值变化的上界 $B$。正如在第二部分所确定的，这个界是扰动的谱范数，即 $|b_i|$。\n对于 $i=3$：\n$$ B = \\|E\\|_2 = |b_3| = 3.2 \\times 10^{-9} $$\n题目要求将此值四舍五入到四位有效数字。\n$$ B = 3.200 \\times 10^{-9} $$\n此值表示当次对角线元素 $b_3$ 被置为零时，矩阵 $T$ 的任何特征值可能发生的最大绝对偏移。", "answer": "$$\\boxed{3.200 \\times 10^{-9}}$$", "id": "3586270"}, {"introduction": "二分法的效率在很大程度上取决于特征值的分布。这个练习将探讨一个具有挑战性的场景：特征值呈几何级数形式聚集。通过分析这个“最坏情况”的设定[@problem_id:3586212]，你将深入理解特征值之间的间距如何决定分离它们所需的二分迭代次数，从而将算法的计算复杂度与矩阵的谱特性直接联系起来。", "problem": "考虑使用由施图姆序列计数引导的二分法来定位实对称三对角矩阵的特征值问题，其中施图姆序列计数给出严格小于某个实数位移的特征值数量。二分法通过重复对半将初始谱区间细化为子区间，并利用计数的单调性来确定每个子区间内包含多少个特征值。在特征值高度聚集的最坏情况下，对半操作的次数主要取决于为分辨簇间间隙而必须设置的子区间边界的精细程度，以及对最终区间宽度的容差要求。\n\n你的任务是构造其特征值呈几何聚集的最坏情况下的输入矩阵，并对每个矩阵确定两个衡量二分法细化复杂度的整数：\n\n- 第一个整数是所需的最小均匀二分层级数，使得所得到的二进剖分的端点能够对齐所有簇间间隙，即每个连续簇之间的间隙都至少包含一个子区间边界。\n- 第二个整数是所需的最小均匀二分层级数，使得最小子区间的宽度至多为指定的绝对容差 $\\,\\varepsilon\\,$。\n\n矩阵应按如下方式构造。设 $\\,n\\,$ 是一个正整数，存在 $\\,q\\,$ 个簇，其中心为 $\\,c_1,\\dots,c_q\\,$，大小为 $\\,m_1,\\dots,m_q\\,$，且总和为 $\\,n\\,$。对于固定的基准偏移量 $\\,\\delta0\\,$ 和比率 $\\,r\\in(0,1)\\,$，为每个簇 $\\,j\\,$ 定义特征值\n$$\n\\lambda_{j,k} \\;=\\; c_j \\;+\\; \\delta\\, r^{\\,k}, \\qquad k=0,1,\\dots,m_j-1,\n$$\n然后通过将这 $\\,n\\,$ 个值放在对角线上并将所有非对角元素设为零，来构成 $\\,n\\times n\\,$ 的对称三对角矩阵 $\\,T\\,$。这种构造产生了一个具有几何聚集特征值的对称三对角矩阵，并且它实现了二分法的最坏情况，即簇的分离完全由二进子区间边界的位置决定，而与非零非对角元素的任何平滑效应无关。\n\n对于下面的每个测试用例，你必须：\n\n1. 根据所述的几何聚集规则构造 $\\,T\\,$。\n2. 使用基于三对角结构的Gershgorin型界，确定一个包含 $\\,T\\,$ 所有特征值的安全全局谱区间 $[a,b]$。\n3. 将簇间间隙识别为按簇中心排序后，一个簇的最大值与下一个簇的最小值之间的开区间。\n4. 计算：\n   - 最小均匀二分层级数 $\\,s_{\\mathrm{clusters}}\\,$，使得将 $[a,b]$ 划分为 $2^{\\,s_{\\mathrm{clusters}}}$ 个等长子区间的二进剖分在每个簇间间隙内都至少有一个严格位于其内部的边界点。\n   - 最小均匀二分层级数 $\\,s_{\\varepsilon}\\,$，使得每个二进子区间的宽度至多为给定的绝对容差 $\\,\\varepsilon\\,$。\n\n你必须从第一性原理出发实现该逻辑：对称三对角矩阵的施图姆序列计数定义了特征值计数函数，而二分法的均匀细化创建了二进剖分，其边界间距随层级数几何递减。量 $\\,s_{\\mathrm{clusters}}\\,$ 和 $\\,s_{\\varepsilon}\\,$ 将这些原理转化为整数，用以量化分辨簇间间隙和满足规定绝对容差所需的最坏情况下的细化程度。\n\n测试套件：\n- 测试用例 $\\,1\\,$：\n  - $\\,n=12\\,$, $\\,q=2\\,$, 中心 $\\,c_1=0\\,$ 和 $\\,c_2=1\\,$, 大小 $\\,m_1=7\\,$ 和 $\\,m_2=5\\,$。\n  - 基准偏移量 $\\,\\delta = 10^{-3}\\,$, 比率 $\\,r = \\tfrac{1}{3}\\,$。\n  - 绝对容差 $\\,\\varepsilon = 10^{-6}\\,$。\n- 测试用例 $\\,2\\,$：\n  - $\\,n=10\\,$, $\\,q=2\\,$, 中心 $\\,c_1=0\\,$ 和 $\\,c_2=3\\,$, 大小 $\\,m_1=9\\,$ 和 $\\,m_2=1\\,$。\n  - 基准偏移量 $\\,\\delta = 10^{-8}\\,$, 比率 $\\,r = 0.9\\,$。\n  - 绝对容差 $\\,\\varepsilon = 10^{-12}\\,$。\n- 测试用例 $\\,3\\,$：\n  - $\\,n=8\\,$, $\\,q=3\\,$, 中心 $\\,c_1=-2\\,$, $\\,c_2=0\\,$, $\\,c_3=2\\,$, 大小 $\\,m_1=3\\,$, $\\,m_2=3\\,$, $\\,m_3=2\\,$。\n  - 基准偏移量 $\\,\\delta = 10^{-5}\\,$, 比率 $\\,r = \\tfrac{1}{2}\\,$。\n  - 绝对容差 $\\,\\varepsilon = 10^{-8}\\,$。\n\n最终输出格式：\n你的程序应生成单行输出，包含测试套件中的六个结果，按 $[s_{\\mathrm{clusters}}^{(1)}, s_{\\varepsilon}^{(1)}, s_{\\mathrm{clusters}}^{(2)}, s_{\\varepsilon}^{(2)}, s_{\\mathrm{clusters}}^{(3)}, s_{\\varepsilon}^{(3)}]$ 的顺序列出，打印为用逗号分隔并用方括号括起来的列表（例如，$[1,2,3,4,5,6]$）。每个条目都必须是整数。", "solution": "该问题要求计算两个整数 $s_{\\mathrm{clusters}}$ 和 $s_{\\varepsilon}$，它们量化了为一类特殊的对角矩阵分辨特征值簇并满足指定容差所需的均匀二分层级数。求解过程首先将待计算的量形式化，然后将这些公式应用于具体的测试用例。\n\n矩阵 $T$ 是一个 $n \\times n$ 的对称三对角矩阵，但其构造为对角矩阵。它的对角元素是指定的特征值，非对角元素为零。特征值被分为 $q$ 个簇。对于每个簇 $j \\in \\{1, \\dots, q\\}$，其中心为 $c_j$，大小为 $m_j$，特征值由以下公式给出：\n$$\n\\lambda_{j,k} = c_j + \\delta r^k, \\qquad k=0, 1, \\dots, m_j-1\n$$\n其中 $\\delta  0$ 是一个基准偏移量， $r \\in (0,1)$ 是一个比率。特征值的总数为 $n = \\sum_{j=1}^q m_j$。\n\n第一步是确定一个包含所有特征值的安全全局谱区间 $[a, b]$。问题建议使用Gershgorin型界。对于一个对角元素为 $d_i$、非对角元素为 $e_i$ 的一般对称三对角矩阵，其特征值位于区间 $[d_i - |e_{i-1}| - |e_i|, d_i + |e_{i-1}| + |e_i|]$ 的并集中（其中 $e_0=e_n=0$）。在我们的特定情况下，矩阵 $T$ 是对角矩阵，因此所有非对角元素都为零。Gershgorin圆盘就是与对角元素相对应的点，即特征值本身。因此，包含所有特征值的最小严格区间 $[a, b]$ 是 $[ \\min(\\lambda), \\max(\\lambda) ]$。\n\n由于 $\\delta  0$ 且 $r \\in (0,1)$，项 $\\delta r^k$ 为正且随 $k$ 严格递减。\n簇 $j$ 中的最大特征值为 $\\lambda_{j,0} = c_j + \\delta r^0 = c_j + \\delta$。\n簇 $j$ 中的最小特征值为 $\\lambda_{j,m_j-1} = c_j + \\delta r^{m_j-1}$。\n全局最大特征值是各簇最大值的最大值：$b = \\max_{j} (\\lambda_{j,0}) = \\max_{j} (c_j + \\delta) = (\\max_{j} c_j) + \\delta$。\n全局最小特征值是各簇最小值的最小值：$a = \\min_{j} (\\lambda_{j,m_j-1}) = \\min_{j} (c_j + \\delta r^{m_j-1})$。\n谱区间的总宽度为 $W = b-a$。\n\n第二步是识别簇间间隙。设簇中心已排序为 $c_{(1)}  c_{(2)}  \\dots  c_{(q)}$，对应的大小为 $m_{(1)}, m_{(2)}, \\dots, m_{(q)}$。共有 $q-1$ 个簇间间隙。第 $i$ 个间隙（对于 $i \\in \\{1, \\dots, q-1\\}$）是簇 $(i)$ 的最大特征值与簇 $(i+1)$ 的最小特征值之间的开区间。\n第 $i$ 个间隙的左边界是 $g_{i,L} = \\max_{\\text{eigs in cluster }(i)} \\lambda = c_{(i)} + \\delta$。\n第 $i$ 个间隙的右边界是 $g_{i,R} = \\min_{\\text{eigs in cluster }(i+1)} \\lambda = c_{(i+1)} + \\delta r^{m_{(i+1)}-1}$。\n第 $i$ 个间隙的宽度是 $w_i = g_{i,R} - g_{i,L}$。这些间隙中最窄的一个决定了分辨率要求：$w_{\\mathrm{gap\\_min}} = \\min_{i} w_i$。\n\n第三步是计算 $s_{\\mathrm{clusters}}$。对 $[a,b]$ 进行 $s$ 层的均匀二分会产生 $2^s$ 个等宽的子区间，宽度为 $W_s = (b-a)/2^s$。为了让二进剖分的边界能够分辨每个簇间间隙，每个间隙内部必须严格包含至少一个边界点。保证这一点的充分条件是子区间宽度 $W_s$ 必须严格小于最窄间隙的宽度 $w_{\\mathrm{gap\\_min}}$。\n$$\nW_s  w_{\\mathrm{gap\\_min}} \\implies \\frac{b-a}{2^s}  w_{\\mathrm{gap\\_min}}\n$$\n整理该不等式得到：\n$$\n2^s  \\frac{b-a}{w_{\\mathrm{gap\\_min}}} \\implies s  \\log_2\\left(\\frac{b-a}{w_{\\mathrm{gap\\_min}}}\\right)\n$$\n由于 $s$ 必须是整数，其最小值为 $s_{\\mathrm{clusters}} = \\left\\lfloor \\log_2\\left(\\frac{b-a}{w_{\\mathrm{gap\\_min}}}\\right) \\right\\rfloor + 1$。即使对数的参数是2的幂，该公式也成立，因为不等式是严格的。\n\n第四步是计算 $s_{\\varepsilon}$。这要求每个子区间的宽度不超过绝对容差 $\\varepsilon$。\n$$\nW_s \\le \\varepsilon \\implies \\frac{b-a}{2^s} \\le \\varepsilon\n$$\n整理该不等式得到：\n$$\n2^s \\ge \\frac{b-a}{\\varepsilon} \\implies s \\ge \\log_2\\left(\\frac{b-a}{\\varepsilon}\\right)\n$$\n由于 $s$ 必须是整数，其最小值为 $s_{\\varepsilon} = \\left\\lceil \\log_2\\left(\\frac{b-a}{\\varepsilon}\\right) \\right\\rceil$。\n\n将这些推导出的公式应用于每个测试用例，以找到所需的整数值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_refinement_levels(n, q, centers, sizes, delta, r, epsilon):\n    \"\"\"\n    Calculates the minimal bisection levels s_clusters and s_epsilon.\n\n    Args:\n        n (int): Total number of eigenvalues.\n        q (int): Number of clusters.\n        centers (list): List of cluster centers c_j.\n        sizes (list): List of cluster sizes m_j.\n        delta (float): Base offset.\n        r (float): Ratio.\n        epsilon (float): Absolute tolerance.\n\n    Returns:\n        tuple: A tuple containing (s_clusters, s_epsilon).\n    \"\"\"\n\n    # Combine centers and sizes for sorting\n    clusters = sorted(zip(centers, sizes))\n    sorted_centers = [c for c, s in clusters]\n    sorted_sizes = [s for c, s in clusters]\n\n    # Step 1: Determine the global spectral interval [a, b]\n    # b = max(c_j) + delta\n    b = sorted_centers[-1] + delta\n    \n    # a = min(c_j + delta * r^(m_j-1))\n    min_eigs_per_cluster = [\n        c + delta * (r**(s - 1)) for c, s in clusters\n    ]\n    a = min(min_eigs_per_cluster)\n\n    # Total width of the spectral interval\n    interval_width = b - a\n\n    # Step 2: Identify inter-cluster gaps and find the minimum width\n    if q > 1:\n        gap_widths = []\n        for i in range(q - 1):\n            # Left boundary of gap i: max eigenvalue of cluster i\n            gap_left = sorted_centers[i] + delta\n            # Right boundary of gap i: min eigenvalue of cluster i+1\n            gap_right = sorted_centers[i+1] + delta * (r**(sorted_sizes[i+1] - 1))\n            \n            width = gap_right - gap_left\n            if width = 0:\n                # This case implies overlapping clusters, which would invalidate the premise\n                # of inter-cluster gaps as defined. The problem setup avoids this.\n                raise ValueError(\"Invalid problem setup: Non-positive gap width detected.\")\n            gap_widths.append(width)\n        \n        min_gap_width = min(gap_widths)\n\n        # Step 3: Compute s_clusters\n        # We need 2^s > (b-a) / w_gap_min\n        if min_gap_width > 0:\n            ratio_clusters = interval_width / min_gap_width\n            s_clusters = int(np.floor(np.log2(ratio_clusters))) + 1\n        else: # Should not happen with problem data\n            s_clusters = -1 # Error indicator\n    else:\n        # If there is only one cluster, there are no inter-cluster gaps.\n        # The concept of s_clusters is not applicable.\n        # We can set it to 0 as no refinement is needed to separate clusters.\n        s_clusters = 0\n\n    # Step 4: Compute s_epsilon\n    # We need 2^s >= (b-a) / epsilon\n    ratio_epsilon = interval_width / epsilon\n    s_epsilon = int(np.ceil(np.log2(ratio_epsilon)))\n\n    return s_clusters, s_epsilon\n\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        {\n            \"n\": 12, \"q\": 2, \"centers\": [0, 1], \"sizes\": [7, 5],\n            \"delta\": 1e-3, \"r\": 1/3, \"epsilon\": 1e-6\n        },\n        # Test Case 2\n        {\n            \"n\": 10, \"q\": 2, \"centers\": [0, 3], \"sizes\": [9, 1],\n            \"delta\": 1e-8, \"r\": 0.9, \"epsilon\": 1e-12\n        },\n        # Test Case 3\n        {\n            \"n\": 8, \"q\": 3, \"centers\": [-2, 0, 2], \"sizes\": [3, 3, 2],\n            \"delta\": 1e-5, \"r\": 1/2, \"epsilon\": 1e-8\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_c, s_e = calculate_refinement_levels(\n            case[\"n\"], case[\"q\"], case[\"centers\"], case[\"sizes\"],\n            case[\"delta\"], case[\"r\"], case[\"epsilon\"]\n        )\n        results.extend([s_c, s_e])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3586212"}]}