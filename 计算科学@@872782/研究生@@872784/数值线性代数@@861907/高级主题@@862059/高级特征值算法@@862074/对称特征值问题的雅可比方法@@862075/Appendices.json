{"hands_on_practices": [{"introduction": "任何迭代方法的核心在于其基本步骤的效率。雅可比方法的心脏是单个平面旋转，但若采用完全的矩阵乘法，其计算成本高昂。本练习旨在深入剖析单次雅可比旋转的力学原理，引导你从抽象的相似变换概念走向高效的 $O(n)$ 更新实现。掌握这一关键计算核心是构建实用求解器的第一步。[@problem_id:3552566]", "problem": "给定一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和两个不同的索引 $(p,q)$，其中 $0 \\leq p  q \\leq n-1$。考虑通过一次正交相似变换，使用一次 Jacobi 旋转来消去非对角元素 $a_{pq}$。你的任务是实现 Jacobi 方法的单步操作，计算更新后的矩阵 $A' \\in \\mathbb{R}^{n \\times n}$，对应于 $A' \\leftarrow G^\\top A G$。其中 $G \\in \\mathbb{R}^{n \\times n}$ 是一个仅作用于 $(p,q)$ 平面的正交旋转矩阵，其选择旨在消去 $a_{pq}$。实现必须避免构造完整的乘积 $G^\\top A G$，并且必须通过为受影响的行和列复用临时变量，以 $O(n)$ 的时间复杂度更新 $A$。\n\n使用的基本原理：\n- 实对称矩阵 $A$ 具有实特征值，并且可以被正交对角化。正交相似变换 $A' = Q^\\top A Q$ 保持对称性和特征值不变。\n- Jacobi 旋转是一个正交矩阵 $G$，它除了在作用于索引 $(p,q)$ 的一个 $2 \\times 2$ 旋转子块外，其余部分与单位矩阵相同；通过恰当选择旋转参数，它可以消去单个非对角元素 $a_{pq}$。\n\n定义和要求：\n- 令 $a_{ij}$ 表示 $A$ 的 $(i,j)$ 元素，令 $a'_{ij}$ 表示 $A'$ 的 $(i,j)$ 元素。\n- 必须以数值稳定的方式选择旋转参数以消去 $a_{pq}$。\n- 效率要求：仅更新由 $p$ 和 $q$ 索引的行和列，复用临时变量以避免不必要的内存操作。不要显式构造 $G$，也不要执行稠密矩阵乘法。\n- 正确性要求：$A'$ 必须保持对称，并且在浮点（FP）舍入误差范围内满足 $a'_{pq} \\approx 0$。\n\n对于每个测试用例，计算并报告以下三个量：\n1. 整数 $m$，等于满足 $|a'_{ij} - a_{ij}| > \\varepsilon$ 的元素 $(i,j)$ 的数量，其中 $\\varepsilon = 10^{-12}$。\n2. 浮点数 $r$，等于 $|a'_{pq}|$。\n3. 浮点数 $f$，等于弗罗贝尼乌斯范数 $\\|A' - A\\|_F$，其中 $\\|X\\|_F = \\sqrt{\\sum_{i,j} x_{ij}^2}$。\n\n角度单位：任何内部形成的旋转角（如果计算的话）必须以弧度为单位；然而，角度不是要求输出的一部分。\n\n测试套件：\n- 案例1（边界情况，平凡消去）：$n=2$，\n$$\nA = \\begin{bmatrix}\n2.0  0.0 \\\\\n0.0  3.0\n\\end{bmatrix},\\quad (p,q) = (0,1).\n$$\n- 案例2（一般情况，混合符号）：$n=5$，\n$$\nA = \\begin{bmatrix}\n4  1  2  0  0 \\\\\n1  3  -1  2  0 \\\\\n2  -1  5  0  1 \\\\\n0  2  0  4  -2 \\\\\n0  0  1  -2  3\n\\end{bmatrix},\\quad (p,q) = (1,2).\n$$\n- 案例3（边缘情况，对角元素相等）：$n=8$，\n$$\nA = \\begin{bmatrix}\n7  2  0  1  0  0  3  0 \\\\\n2  6  1  0  0  2  0  0 \\\\\n0  1  5  0  2  0  0  1 \\\\\n1  0  0  6  0  0  2  0 \\\\\n0  0  2  0  4  1  0  0 \\\\\n0  2  0  0  1  3  1  0 \\\\\n3  0  0  2  0  1  6  0 \\\\\n0  0  1  0  0  0  0  5\n\\end{bmatrix},\\quad (p,q) = (3,6).\n$$\n\n你的程序必须对每个测试用例应用一次 Jacobi 旋转以生成更新后的矩阵 $A'$，为每个测试用例计算 $(m,r,f)$，并在一行中输出结果，格式为逗号分隔的列表之列表：\n$$\n\\text{[}[m_1,r_1,f_1],[m_2,r_2,f_2],[m_3,r_3,f_3]\\text{]}.\n$$\n所有数值输出必须是标准的浮点格式（除了常规的十进制表示法外，不含科学记数法符号），并且没有物理单位。容差固定为 $\\varepsilon = 10^{-12}$。", "solution": "用户提供的问题是有效的。它在科学上是合理的、适定的、客观的，并包含了唯一解所需的所有必要信息。任务是为对称矩阵实现 Jacobi 方法的单次高效步骤。\n\n### 基于原理的设计\n\n问题的核心是对一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 应用一次正交相似变换 $A' = G^\\top A G$。变换矩阵 $G$ 是一个 Jacobi 旋转（也称为 Givens 旋转），其设计目的是消去一个特定的非对角元素 $a_{pq}$（及其对称的对应元素 $a_{qp}$）。\n\n**1. Jacobi 旋转矩阵 ($G$)**\n\n矩阵 $G$ 是一个正交矩阵，它除了在作用于索引 $(p,q)$（其中 $0 \\leq p  q \\leq n-1$）的一个 $2 \\times 2$ 旋转子块外，其余部分与单位矩阵相同。其定义如下：\n$$\nG_{ij} =\n\\begin{cases}\n    c = \\cos(\\theta)  \\text{if } i=j=p \\text{ or } i=j=q \\\\\n    s = \\sin(\\theta)  \\text{if } (i,j) = (p,q) \\\\\n    -s = -\\sin(\\theta)  \\text{if } (i,j) = (q,p) \\\\\n    1  \\text{if } i=j \\text{ and } i \\notin \\{p,q\\} \\\\\n    0  \\text{otherwise}\n\\end{cases}\n$$\n选择 $\\theta$ 的值是为了使变换后矩阵 $A'$ 的元素 $a'_{pq}$ 等于零。正交性（$G^\\top G = I$）由属性 $c^2 + s^2 = 1$ 保证。\n\n**2. 旋转参数 ($c, s$) 的推导**\n\n该变换对 $A$ 在索引 $(p,q)$ 处的 $2 \\times 2$ 子矩阵的影响如下：\n$$\n\\begin{pmatrix} a'_{pp}  a'_{pq} \\\\ a'_{qp}  a'_{qq} \\end{pmatrix} = \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix} \\begin{pmatrix} a_{pp}  a_{pq} \\\\ a_{qp}  a_{qq} \\end{pmatrix} \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}\n$$\n执行此矩阵乘法，得到新的非对角元素 $a'_{pq}$ 的表达式：\n$$ a'_{pq} = (c^2 - s^2) a_{pq} + c s (a_{pp} - a_{qq}) $$\n为了消去该元素（令 $a'_{pq} = 0$），我们必须有：\n$$ (c^2 - s^2) a_{pq} = -c s (a_{pp} - a_{qq}) $$\n使用二倍角恒等式 $c^2-s^2 = \\cos(2\\theta)$ 和 $2cs = \\sin(2\\theta)$，我们得到：\n$$ \\cot(2\\theta) = \\frac{\\cos(2\\theta)}{\\sin(2\\theta)} = \\frac{a_{qq} - a_{pp}}{2 a_{pq}} $$\n令 $\\tau = \\frac{a_{qq} - a_{pp}}{2 a_{pq}}$。为了在不显式求解 $\\theta$ 的情况下以数值稳定的方式计算 $c$ 和 $s$，我们首先求出 $t = \\tan(\\theta)$。关系式 $\\cot(2\\theta) = \\frac{1-t^2}{2t} = \\tau$ 导出一元二次方程 $t^2 + 2\\tau t - 1 = 0$。为了稳定性，选择绝对值较小的根，这对应于一个较小的旋转角 $|\\theta| \\leq \\pi/4$。该根由以下公式给出：\n$$ t = \\frac{\\text{sgn}(\\tau)}{|\\tau| + \\sqrt{\\tau^2 + 1}} $$\n当 $\\tau = 0$（即 $a_{pp}=a_{qq}$）时出现特殊情况，此时我们取 $t=1$（对应于 $\\theta = \\pi/4$ 的旋转）。如果 $a_{pq}=0$，则不需要旋转，因此我们设置 $\\theta=0$，这意味着 $t=0, c=1, s=0$。\n一旦 $t$ 已知，$c$ 和 $s$ 可通过以下方式求得：\n$$ c = \\frac{1}{\\sqrt{1+t^2}}, \\quad s = t c $$\n\n**3. 高效的 $O(n)$ 矩阵更新**\n\n变换 $A' = G^\\top A G$ 只修改第 $p$ 行、第 $q$ 行、第 $p$ 列和第 $q$ 列。涉及完全矩阵乘法的朴素实现将是 $O(n^3)$ 的。通过推导变化元素的显式公式，可以实现高效的 $O(n)$ 更新。\n- 对于 $i,j \\notin \\{p,q\\}$，元素 $a_{ij}$ 保持不变：$a'_{ij} = a_{ij}$。\n- 对于受影响的行和列中的元素（但在 $2 \\times 2$ 块之外），对于 $i \\notin \\{p,q\\}$：\n  $$ a'_{pi} = a'_{ip} = c \\cdot a_{pi} - s \\cdot a_{qi} $$\n  $$ a'_{qi} = a'_{iq} = s \\cdot a_{pi} + c \\cdot a_{qi} $$\n  这需要 $O(n)$ 次操作。\n- 对于索引为 $(p,q)$ 的 $2 \\times 2$ 子矩阵，更新后的值为：\n  $$ a'_{pp} = c^2 a_{pp} - 2cs a_{pq} + s^2 a_{qq} $$\n  $$ a'_{qq} = s^2 a_{pp} + 2cs a_{pq} + c^2 a_{qq} $$\n  并且根据构造，$a'_{pq} = a'_{qp}$ 为零。这些更新需要 $O(1)$ 次操作。\n\n**4. 算法实现与输出计算**\n\n算法流程如下：\n1. 对于给定的矩阵 $A$ 和索引 $(p,q)$，首先处理 $a_{pq}$ 已经为零的平凡情况。\n2. 如果 $a_{pq} \\neq 0$，计算 $\\tau$，然后使用稳定公式求出 $t, c, s$。\n3. 创建原始矩阵的副本 $A_{orig}$，以供后续比较。工作矩阵 $A$（或其副本 $A'$）将被更新。\n4. 从 $i=0$ 迭代到 $n-1$。对于每个 $i \\notin \\{p,q\\}$，使用上述公式更新元素 $a'_{pi}, a'_{ip}, a'_{qi}, a'_{iq}$。\n5. 更新 $2 \\times 2$ 子矩阵的四个元素 $a'_{pp}, a'_{qq}, a'_{pq}, a'_{qp}$。计算并存储 $a'_{pq}$ 的值以求出 $r$，然后可以在矩阵中将其精确设置为 $0.0$ 以反映完美的消去效果。\n6. 然后计算所需的度量指标：\n   - $m$：满足 $|a'_{ij} - a_{ij}| > \\varepsilon$ 的元素 $(i,j)$ 的数量。这通过在 $A'$ 和 $A_{orig}$ 之间进行逐元素比较得出。\n   - $r$：根据变换公式计算出的绝对值 $|a'_{pq}|$，它衡量了消去过程中的数值误差。\n   - $f$：差值的弗罗贝尼乌斯范数，$\\|A' - A_{orig}\\|_F = \\sqrt{\\sum_{i,j} (a'_{ij} - a_{ij})^2}$。\n\n此过程正确且高效地实现了 Jacobi 旋转的一步，并遵守所有指定的约束。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes one step of the Jacobi rotation for multiple test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.array([[2.0, 0.0], [0.0, 3.0]], dtype=float),\n            \"p\": 0, \"q\": 1\n        },\n        {\n            \"A\": np.array([\n                [4.0, 1.0, 2.0, 0.0, 0.0],\n                [1.0, 3.0, -1.0, 2.0, 0.0],\n                [2.0, -1.0, 5.0, 0.0, 1.0],\n                [0.0, 2.0, 0.0, 4.0, -2.0],\n                [0.0, 0.0, 1.0, -2.0, 3.0]\n            ], dtype=float),\n            \"p\": 1, \"q\": 2\n        },\n        {\n            \"A\": np.array([\n                [7.0, 2.0, 0.0, 1.0, 0.0, 0.0, 3.0, 0.0],\n                [2.0, 6.0, 1.0, 0.0, 0.0, 2.0, 0.0, 0.0],\n                [0.0, 1.0, 5.0, 0.0, 2.0, 0.0, 0.0, 1.0],\n                [1.0, 0.0, 0.0, 6.0, 0.0, 0.0, 2.0, 0.0],\n                [0.0, 0.0, 2.0, 0.0, 4.0, 1.0, 0.0, 0.0],\n                [0.0, 2.0, 0.0, 0.0, 1.0, 3.0, 1.0, 0.0],\n                [3.0, 0.0, 0.0, 2.0, 0.0, 1.0, 6.0, 0.0],\n                [0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 5.0]\n            ], dtype=float),\n            \"p\": 3, \"q\": 6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        p = case[\"p\"]\n        q = case[\"q\"]\n        results.append(jacobi_step(A, p, q))\n\n    # Format the final output string\n    result_strings = []\n    for res in results:\n        # Format list to string '[m,r,f]' without extra spaces\n        result_strings.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef jacobi_step(A, p, q):\n    \"\"\"\n    Performs a single Jacobi rotation on matrix A to annihilate element (p,q).\n    \n    Args:\n        A (np.ndarray): The real symmetric matrix.\n        p (int): The first index (row/column).\n        q (int): The second index (row/column).\n\n    Returns:\n        list: A list containing [m, r, f].\n    \"\"\"\n    A_orig = A.copy()\n    A_prime = A.copy()\n    n = A.shape[0]\n\n    app = A_orig[p, p]\n    aqq = A_orig[q, q]\n    apq = A_orig[p, q]\n\n    # If the element is already zero, no rotation is necessary.\n    if np.isclose(apq, 0.0):\n        return [0, 0.0, 0.0]\n\n    # Calculate rotation parameters c and s\n    tau = (aqq - app) / (2.0 * apq)\n    if tau >= 0:\n        t = 1.0 / (tau + np.sqrt(1.0 + tau**2))\n    else:\n        t = -1.0 / (-tau + np.sqrt(1.0 + tau**2))\n    \n    c = 1.0 / np.sqrt(1.0 + t**2)\n    s = t * c\n\n    # Update the matrix A_prime in an O(n) fashion\n    # First, update elements in rows/cols p,q but not the 2x2 block\n    for i in range(n):\n        if i != p and i != q:\n            a_pi = A_orig[p, i]\n            a_qi = A_orig[q, i]\n            \n            val_pi_prime = c * a_pi - s * a_qi\n            val_qi_prime = s * a_pi + c * a_qi\n            \n            A_prime[p, i] = val_pi_prime\n            A_prime[i, p] = val_pi_prime\n            A_prime[q, i] = val_qi_prime\n            A_prime[i, q] = val_qi_prime\n\n    # Second, update the 2x2 submatrix\n    A_prime[p, p] = c**2 * app - 2 * c * s * apq + s**2 * aqq\n    A_prime[q, q] = s**2 * app + 2 * c * s * apq + c**2 * aqq\n    \n    apq_prime = (c**2 - s**2) * apq + c * s * (app - aqq)\n    A_prime[p, q] = apq_prime\n    A_prime[q, p] = apq_prime\n\n    # Compute the required metrics\n    eps = 1e-12\n    m = int(np.sum(np.abs(A_prime - A_orig) > eps))\n    r = float(np.abs(A_prime[p, q]))\n    f = float(np.linalg.norm(A_prime - A_orig, 'fro'))\n    \n    return [m, r, f]\n\n# Execute the main function\nsolve()\n```", "id": "3552566"}, {"introduction": "一个算法不仅包含其核心操作，还涉及控制流程，例如选择要湮灭的元素（主元选择）和决定何时停止（收敛准则）。本练习将挑战你组装这些部件，并使用你完整的求解器来研究一个微妙的算法行为：收敛后特征值在对角线上的排列顺序。这项任务将填补单个操作与完整数值实验之间的鸿沟。[@problem_id:2405313]", "problem": "您将研究用于实对称特征问题的经典 Jacobi 旋转方法，在其对角线元素收敛到特征值的过程中，是否表现出任何固有的“排序”行为。该研究必须通过从第一性原理出发实现该方法，并根据非递减顺序的概念验证最终对角线元素的排序来完成。\n\n从以下基本原理开始：\n- 对于任何实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，存在一个正交矩阵 $V$，使得 $V^{\\mathsf{T}} A V$ 是对角矩阵。正交相似变换保持了 $A$ 的对称性和特征值多重集。\n- Jacobi 旋转是在二维坐标平面 $(p,q)$ 中的一种正交变换，可以选择它来消去对称矩阵的 $(p,q)$ 和 $(q,p)$ 位置上的元素，同时保持对称性。\n\n任务：\n1. 推导在 $(p,q)$ 平面中必要的平面旋转，通过正交相似变换 $G^{\\mathsf{T}}(p,q,\\theta) A G(p,q,\\theta)$ 将实对称矩阵 $A$ 的一个非对角元素置零。其中 $G$ 是单位矩阵，但在作用于索引 $(p,q)$ 的位置有一个 $2 \\times 2$ 的旋转块。角度必须以弧度表示。不要假设任何预先给定的旋转参数公式；从变换后的非对角元素变为零以及 $G$ 的正交性这两个条件推导出它们。\n2. 设计并实现一个经典的 Jacobi 算法，该算法重复应用此类旋转，以将非对角元素的 Frobenius 范数驱动到低于一个容差。使用一种稳健的主元选择策略，在每一步选择绝对值最大的非对角元素进行消去。当非对角范数小于指定容差乘以当前矩阵的 Frobenius 范数，或达到合理的迭代上限时终止。角度必须以弧度表示。\n3. 对于下面列出的每个测试矩阵，运行您的实现直至收敛，并报告最终的对角向量是否按非递减顺序排列。使用数值容差 $ \\varepsilon $ 定义非递减顺序，要求对于所有相邻对，满足 $d_i \\le d_{i+1} + \\varepsilon$，其中 $d_i$ 表示最终矩阵的第 $i$ 个对角元素。使用 $ \\varepsilon = 10^{-10} $。\n4. Jacobi 方法的数值容差应为绝对容差，定义为 $ \\tau = 10^{-12} \\|A\\|_F $，其中 $ \\|A\\|_F $ 是初始矩阵的 Frobenius 范数，角度必须以弧度表示。\n\n测试套件（每个矩阵都是对称的，数值无单位）：\n- 案例 1 (非平凡 $2 \\times 2$): $A_1 = \\begin{bmatrix} 2  1 \\\\ 1  0 \\end{bmatrix}$。\n- 案例 2 (已对角化，已排序): $A_2 = \\mathrm{diag}(1,2,3)$。\n- 案例 3 (已对角化，未排序): $A_3 = \\mathrm{diag}(3,1,2)$。\n- 案例 4 (已对角化，有重复特征值，已排序): $A_4 = \\mathrm{diag}(1,1,2,2)$。\n- 案例 5 (已对角化，有重复特征值，未排序): $A_5 = \\mathrm{diag}(2,2,1)$。\n\n对于每个案例，如果最终的对角线按非递减顺序排列（在容差 $ \\varepsilon $ 范围内），您的程序必须输出整数 $1$，否则输出 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含以上述顺序排列的测试案例的结果，结果为逗号分隔的列表，并用方括号括起来。例如，格式为 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k \\in \\{0,1\\}$。\n\n角度必须以弧度表示。矩阵或输出中不涉及物理单位。", "solution": "问题陈述经评估为**有效**。它在科学上基于数值线性代数的原理，特别是针对对称矩阵的 Jacobi 特征值算法。该问题是适定的，所有必要的数据、常数和边界条件都已明确提供。术语精确，目标客观且可验证。\n\n以下是按要求提供的完整推理和推导过程。\n\n### 1. Jacobi 旋转的推导\n\n设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实对称矩阵。Jacobi 方法旨在通过应用一系列正交相似变换来对角化 $A$。每次变换，即一次 Jacobi 旋转，都旨在消去一个特定的非对角元素。\n\nJacobi 旋转是一种正交变换 $A \\to A' = G^{\\mathsf{T}} A G$。矩阵 $G \\equiv G(p, q, \\theta)$ 是一个 Givens 旋转矩阵，它是一个单位矩阵，但在对应于索引 $p$ 和 $q$ 的位置有一个 $2 \\times 2$ 的子块（不失一般性，我们假设 $p  q$）。我们将此块定义为：\n$$\n\\begin{pmatrix} g_{pp}  g_{pq} \\\\ g_{qp}  g_{qq} \\end{pmatrix} = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix} = \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix}\n$$\n该矩阵对应于一个角度为 $\\theta$ 的旋转。矩阵 $G$ 是正交的，即 $G^{\\mathsf{T}}G = I$。\n\n变换 $A' = G^{\\mathsf{T}} A G$ 仅影响 $A$ 的第 $p$ 行和第 $q$ 行以及第 $p$ 列和第 $q$ 列。新矩阵 $A'$ 的元素与 $A$ 的元素关系如下。我们来分析由索引 $p$ 和 $q$ 定义的子矩阵的变换：\n$$\n\\begin{pmatrix} a'_{pp}  a'_{pq} \\\\ a'_{qp}  a'_{qq} \\end{pmatrix} = \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix}^{\\mathsf{T}} \\begin{pmatrix} a_{pp}  a_{pq} \\\\ a_{pq}  a_{qq} \\end{pmatrix} \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix} = \\begin{pmatrix} c  s \\\\ -s  c \\end{pmatrix} \\begin{pmatrix} a_{pp}  a_{pq} \\\\ a_{pq}  a_{qq} \\end{pmatrix} \\begin{pmatrix} c  -s \\\\ s  c \\end{pmatrix}\n$$\n新的非对角元素 $a'_{pq}$ 计算如下：\n$$\na'_{pq} = (c a_{pp} + s a_{pq})(-s) + (c a_{pq} + s a_{qq})c = -cs a_{pp} - s^2 a_{pq} + c^2 a_{pq} + cs a_{qq}\n$$\n$$\na'_{pq} = (c^2 - s^2) a_{pq} + cs(a_{qq} - a_{pp})\n$$\n使用三角函数的倍角公式，上式变为：\n$$\na'_{pq} = \\cos(2\\theta) a_{pq} - \\frac{1}{2}\\sin(2\\theta) (a_{pp} - a_{qq})\n$$\n我们要求 $a'_{pq} = 0$，这导出了旋转角 $\\theta$ 所需满足的条件：\n$$\n\\cos(2\\theta) a_{pq} = \\frac{1}{2}\\sin(2\\theta) (a_{pp} - a_{qq})\n$$\n如果 $a_{pq} \\neq 0$ 且 $\\cos(2\\theta) \\neq 0$，我们可以写出：\n$$\n\\tan(2\\theta) = \\frac{2 a_{pq}}{a_{pp} - a_{qq}}\n$$\n如果 $a_{pp} = a_{qq}$，方程简化为 $a_{pq}\\cos(2\\theta) = 0$。对于 $a_{pq} \\neq 0$，这要求 $\\cos(2\\theta) = 0$，所以 $2\\theta = \\pm \\pi/2$，即 $\\theta = \\pm \\pi/4$。\n\n为了数值稳定性，我们避免直接计算 $\\theta$。而是从 $t = \\tan\\theta$ 计算 $c = \\cos\\theta$ 和 $s = \\sin\\theta$。令 $\\xi = \\frac{a_{pp} - a_{qq}}{2 a_{pq}}$。那么 $\\tan(2\\theta) = 1/\\xi$。恒等式 $\\tan(2\\theta) = \\frac{2t}{1-t^2}$ 导出了关于 $t$ 的一元二次方程：$t^2 + 2\\xi t - 1 = 0$。其根为 $t = -\\xi \\pm \\sqrt{\\xi^2 + 1}$。为了最小化旋转角度，我们选择绝对值较小的根。这对应于 $|\\theta| \\le \\pi/4$ 和 $|t| \\le 1$。所需的根由数值稳定的公式给出：\n$$\nt = \\frac{\\mathrm{sgn}(\\xi)}{|\\xi| + \\sqrt{1 + \\xi^2}}\n$$\n其中我们定义 $\\mathrm{sgn}(0)=1$。\n从 $t$ 出发，我们找到 $c$ 和 $s$：\n$$\nc = \\frac{1}{\\sqrt{1 + t^2}}, \\quad s = c \\cdot t\n$$\n这些值必须用于更新矩阵。$2 \\times 2$ 子块的元素变为：\n$$\na'_{pp} = c^2 a_{pp} + s^2 a_{qq} + 2cs a_{pq}\n$$\n$$\na'_{qq} = s^2 a_{pp} + c^2 a_{qq} - 2cs a_{pq}\n$$\n可以验证迹是不变的：$a'_{pp} + a'_{qq} = a_{pp} + a_{qq}$。此外，可以推导出 $a'_{pp} - a'_{qq} = \\sqrt{(a_{pp}-a_{qq})^2 + 4a_{pq}^2}$，这意味着对于我们选择的旋转，$a'_{pp} \\geq a'_{qq}$。这意味着子矩阵的两个特征值中较大的一个被放在索引 $p$ 处，较小的放在索引 $q$ 处（因为按照约定 $p", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It implements the Jacobi rotation method and checks the ordering of the resulting eigenvalues.\n    \"\"\"\n    \n    test_cases = [\n        np.array([[2.0, 1.0], [1.0, 0.0]]),\n        np.diag([1.0, 2.0, 3.0]),\n        np.diag([3.0, 1.0, 2.0]),\n        np.diag([1.0, 1.0, 2.0, 2.0]),\n        np.diag([2.0, 2.0, 1.0]),\n    ]\n    \n    results = []\n    \n    for A in test_cases:\n        final_diagonal = jacobi_eigen_solver(A)\n        is_sorted_flag = is_nondecreasing(final_diagonal)\n        results.append(is_sorted_flag)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef jacobi_eigen_solver(A, convergence_tol_factor=1e-12, max_iter=100):\n    \"\"\"\n    Computes the eigenvalues of a symmetric matrix A using the classical Jacobi method.\n\n    Args:\n        A (np.ndarray): The symmetric input matrix.\n        convergence_tol_factor (float): Factor for the convergence tolerance.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        np.ndarray: A vector containing the eigenvalues (the diagonal of the final matrix).\n    \"\"\"\n    A_k = np.copy(A).astype(np.float64)\n    n = A.shape[0]\n    if n == 1:\n        return np.diag(A_k)\n\n    initial_fro_norm = np.linalg.norm(A, 'fro')\n    convergence_tol = convergence_tol_factor * initial_fro_norm\n\n    for _ in range(max_iter):\n        # Calculate the Frobenius norm of off-diagonal elements\n        off_diag_norm = np.sqrt(max(0, np.linalg.norm(A_k, 'fro')**2 - np.linalg.norm(np.diag(A_k))**2))\n\n        if off_diag_norm  convergence_tol:\n            break\n\n        # Find the off-diagonal element with the largest magnitude\n        # We only need to search the upper triangle\n        p, q = np.unravel_index(np.argmax(np.abs(np.triu(A_k, 1))), A_k.shape)\n\n        app, aqq, apq = A_k[p, p], A_k[q, q], A_k[p, q]\n\n        # Compute rotation parameters c and s\n        if apq == 0.0:\n            c, s = 1.0, 0.0\n        else:\n            xi = (app - aqq) / (2.0 * apq)\n            # Use sgn(0)=1 convention for the t formula\n            t_sign = np.sign(xi) if xi != 0 else 1.0\n            t = t_sign / (np.abs(xi) + np.sqrt(1.0 + xi**2))\n            \n            c = 1.0 / np.sqrt(1.0 + t**2)\n            s = c * t\n\n        # Store old values needed for updates\n        app_old, aqq_old = A_k[p, p], A_k[q, q]\n        apq_old = A_k[p, q]\n\n        # Update the 2x2 sub-block diagonal elements\n        A_k[p, p] = c**2 * app_old + s**2 * aqq_old + 2 * c * s * apq_old\n        A_k[q, q] = s**2 * app_old + c**2 * aqq_old - 2 * c * s * apq_old\n\n        # Update the rest of rows/columns p and q\n        for k in range(n):\n            if k != p and k != q:\n                apk_old = A_k[p, k]\n                aqk_old = A_k[q, k]\n                A_k[p, k] = c * apk_old + s * aqk_old\n                A_k[q, k] = -s * apk_old + c * aqk_old\n                # Maintain symmetry\n                A_k[k, p] = A_k[p, k]\n                A_k[k, q] = A_k[q, k]\n\n        # Annihilate the target off-diagonal element\n        A_k[p, q] = 0.0\n        A_k[q, p] = 0.0\n\n    return np.diag(A_k)\n\ndef is_nondecreasing(d, tol=1e-10):\n    \"\"\"\n    Checks if a vector d is in nondecreasing order within a given tolerance.\n    The condition is d_i = d_{i+1} + tol for all i.\n\n    Args:\n        d (np.ndarray): The vector to check.\n        tol (float): The numerical tolerance for comparison.\n\n    Returns:\n        int: 1 if the vector is in nondecreasing order, 0 otherwise.\n    \"\"\"\n    for i in range(len(d) - 1):\n        if d[i] > d[i+1] + tol:\n            return 0\n    return 1\n\nsolve()\n```", "id": "2405313"}, {"introduction": "在掌握了将矩阵对角化的“正向”过程之后，这个练习将颠倒视角，作为对概念理解的最终检验。通过从特征值（$\\Lambda$）和旋转序列（$Q$）中重构原始矩阵（$A$），你将巩固对雅可比方法作为构造谱分解 $A = Q \\Lambda Q^T$ 过程的理解。这项任务将程序性实现提升到对底层线性代数的更深层次的领悟。[@problem_id:2405315]", "problem": "您将处理经典对称特征值问题雅可比方法的一个逆向表述。在正向雅可比过程中，一个实对称矩阵通过一系列正交平面旋转（雅可比旋转）被对角化。在这个逆向问题中，您会得到一个对角矩阵和一系列指定的雅可比旋转，您必须重建出那个在正向应用这些旋转后会被对角化的稠密对称矩阵。\n\n基本原理：\n- 如果一个实方阵 $Q$ 满足 $Q^{\\mathsf{T}}Q=I$，则称其为正交矩阵，其中 $I$ 是单位矩阵，${\\mathsf{T}}$ 表示转置。正交相似变换将对称矩阵映射到对称矩阵，并保持特征值不变。\n- 在由索引为 $p$ 和 $q$ 的标准基向量所张成的坐标平面中的一次雅可比旋转，是一个正交矩阵，它除了在行和列 $(p,q)$ 上的 $2\\times 2$ 子块等于一个角度为 $\\theta$ 的旋转外，其余部分与单位矩阵相同。\n\n本问题的定义与约定：\n- 角度以弧度为单位。\n- 索引 $p$ 和 $q$ 是从零开始的整数，满足 $0\\le pqn$，其中 $n$ 是矩阵的维度。\n- 对于给定的 $n$，初等雅可比旋转 $G(p,q,\\theta)\\in\\mathbb{R}^{n\\times n}$ 定义为单位矩阵，但以下条目除外：\n  $$\n  G_{pp}=\\cos\\theta,\\quad G_{qq}=\\cos\\theta,\\quad G_{pq}=\\sin\\theta,\\quad G_{qp}=-\\sin\\theta,\n  $$\n  且对于行或列 $p$ 和 $q$ 中的所有其他非对角线条目，$G_{ij}=0$。这定义了嵌入在 $\\mathbb{R}^n$ 中的标准平面旋转。\n- 给定一个包含 $k$ 次旋转的序列 $\\{(p_1,q_1,\\theta_1),\\ldots,(p_k,q_k,\\theta_k)\\}$，构造正交矩阵\n  $$\n  Q \\equiv G(p_1,q_1,\\theta_1)\\,G(p_2,q_2,\\theta_2)\\,\\cdots\\,G(p_k,q_k,\\theta_k).\n  $$\n- 设 $\\Lambda=\\mathrm{diag}(\\lambda_0,\\ldots,\\lambda_{n-1})$ 是一个实对角矩阵。您的任务是仅根据 $\\Lambda$ 和旋转序列，重建出在正向雅可比过程中使用给定旋转而被对角化的对称矩阵 $A$。您必须仅使用上述定义和正交相似变换的一般性质，从第一性原理出发推导出如何计算 $A$。\n\n程序要求：\n- 实现一个程序，对于下方的每个测试用例，根据旋转序列构建指定的 $Q$ 矩阵，并以行主序返回重建矩阵 $A$ 的上三角元素，包括对角线。例如，对于 $n=3$，返回列表 $[A_{00},A_{01},A_{02},A_{11},A_{12},A_{22}]$。\n- 为了数值报告，将返回的每个数字四舍五入到 $10^{-6}$，并格式化为小数点后恰好六位数字。\n- 最终输出必须是单行，包含一个列表，该列表连接了每个测试用例的上三角输出，形式为用方括号括起来的逗号分隔列表，不含空格。\n\n测试套件（角度单位为弧度，索引从零开始）：\n- 测试用例 1（边界情况：旋转序列为空）：$n=3$，$\\Lambda=\\mathrm{diag}(1.5,-0.5,2.5)$，旋转序列 $\\varnothing$。\n- 测试用例 2（单次旋转）：$n=3$，$\\Lambda=\\mathrm{diag}(1,2,4)$，旋转序列 $\\{(0,1,\\pi/6)\\}$。\n- 测试用例 3（多次旋转，索引有重叠）：$n=4$，$\\Lambda=\\mathrm{diag}(0.5,1.5,2.5,3.5)$，旋转序列 $\\{(0,2,\\pi/4),(1,3,\\pi/3),(0,1,-\\pi/8)\\}$。\n- 测试用例 4（角度包含零）：$n=3$，$\\Lambda=\\mathrm{diag}(3,1,2)$，旋转序列 $\\{(0,2,0),(0,2,\\pi/2),(1,2,0)\\}$。\n\n您的程序应生成单行输出，其中包含一个连接所有结果的逗号分隔列表，并用方括号括起来（例如，$\\big[$result$1,$result$2,\\ldots\\big]$）。不应打印任何其他文本。", "solution": "该问题要求从一个实对称矩阵 $A$ 的对角形式 $\\Lambda$ 和产生此对角化的一系列雅可比旋转中，重建出矩阵 $A$。这是雅可比特征值算法的逆过程。我们将首先从线性代数的基本原理推导出重建公式，然后开发一个算法来计算它。\n\n谱理论的一个基本结果指出，任何实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 都可以通过正交相似变换进行对角化。也就是说，存在一个正交矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 和一个对角矩阵 $\\Lambda \\in \\mathbb{R}^{n \\times n}$，使得：\n$$ \\Lambda = P^{\\mathsf{T}} A P $$\n在这里，$\\Lambda$ 的对角线条目是 $A$ 的特征值，而 $P$ 的列是相应的标准正交特征向量。这个关系可以被反转，以 $A$ 的特征值和特征向量来表示 $A$。由于 $P$ 是正交的，其转置是其逆，即 $P^{\\mathsf{T}} = P^{-1}$。通过左乘 $P$ 并右乘 $P^{\\mathsf{T}}$，我们得到：\n$$ P \\Lambda P^{\\mathsf{T}} = P (P^{\\mathsf{T}} A P) P^{\\mathsf{T}} = (P P^{\\mathsf{T}}) A (P P^{\\mathsf{T}}) = I A I = A $$\n因此，重建公式为 $A = P \\Lambda P^{\\mathsf{T}}$。\n\n问题陈述中提到，正向雅可比过程使用一个包含 $k$ 次初等旋转的序列 $\\{(p_1,q_1,\\theta_1), \\ldots, (p_k,q_k,\\theta_k)\\}$ 来对角化 $A$。一次初等雅可比旋转是由矩阵 $G(p,q,\\theta)$ 表示的正交变换。正向过程将这些旋转作为一系列相似变换来应用。设 $A_0 = A$。该序列为：\n$$ A_1 = G(p_1,q_1,\\theta_1)^{\\mathsf{T}} A_0 G(p_1,q_1,\\theta_1) $$\n$$ A_2 = G(p_2,q_2,\\theta_2)^{\\mathsf{T}} A_1 G(p_2,q_2,\\theta_2) $$\n$$ \\vdots $$\n$$ \\Lambda = A_k = G(p_k,q_k,\\theta_k)^{\\mathsf{T}} A_{k-1} G(p_k,q_k,\\theta_k) $$\n通过递归代入，我们得到 $A$ 和 $\\Lambda$ 之间的关系：\n$$ \\Lambda = \\left(G_k^{\\mathsf{T}} \\cdots G_2^{\\mathsf{T}} G_1^{\\mathsf{T}}\\right) A \\left(G_1 G_2 \\cdots G_k\\right) $$\n这里我们使用简写 $G_i = G(p_i,q_i,\\theta_i)$。利用 $(AB)^{\\mathsf{T}} = B^{\\mathsf{T}}A^{\\mathsf{T}}$ 的性质，上式可简化为：\n$$ \\Lambda = (G_1 G_2 \\cdots G_k)^{\\mathsf{T}} A (G_1 G_2 \\cdots G_k) $$\n问题将总变换矩阵 $Q$ 定义为初等旋转的有序乘积：\n$$ Q \\equiv G_1 G_2 \\cdots G_k $$\n将此定义与 $\\Lambda$ 的表达式进行比较，我们发现标准谱分解中的变换矩阵 $P$ 正好对应于 $Q$。\n$$ \\Lambda = Q^{\\mathsf{T}} A Q $$\n因此，重建 $A$ 的公式为：\n$$ A = Q \\Lambda Q^{\\mathsf{T}} $$\n由于每个 $G_i$ 都是正交矩阵，它们的乘积 $Q$ 也是正交矩阵，这验证了此推导的正确性。\n\n解决该问题的算法如下：\n1. 对于每个测试用例，给定维度 $n$、特征值列表 $(\\lambda_0, \\ldots, \\lambda_{n-1})$ 以及旋转序列 $\\{(p_1,q_1,\\theta_1), \\ldots, (p_k,q_k,\\theta_k)\\}$。\n2. 构造对角矩阵 $\\Lambda = \\mathrm{diag}(\\lambda_0, \\ldots, \\lambda_{n-1})$。\n3. 构造总旋转矩阵 $Q$。这可以通过先初始化一个矩阵，然后按指定顺序将其乘以每个初等雅可比旋转矩阵 $G_i = G(p_i,q_i,\\theta_i)$ 来完成。\n    - 如果旋转序列为空（$k=0$），$Q$ 是大小为 $n \\times n$ 的单位矩阵 $I$。\n    - 如果序列不为空，则计算 $Q = G_1 G_2 \\cdots G_k$。这可以通过迭代完成：从 $Q=G_1$ 开始，然后计算 $Q \\leftarrow Q G_2$，以此类推，直到 $Q \\leftarrow Q G_k$。一个初等旋转矩阵 $G(p,q,\\theta)$ 是一个 $n \\times n$ 的单位矩阵，除了四个条目之外：\n    $$ G_{pp}=\\cos\\theta, \\quad G_{qq}=\\cos\\theta, \\quad G_{pq}=\\sin\\theta, \\quad G_{qp}=-\\sin\\theta $$\n4. 使用推导出的公式 $A = Q \\Lambda Q^{\\mathsf{T}}$ 计算对称矩阵 $A$。\n5. 以行主序提取 $A$ 的上三角元素，包括主对角线。这些是满足 $0 \\le i \\le j  n$ 的元素 $A_{ij}$。\n6. 将每个提取的元素四舍五入到 $10^{-6}$ 并以小数点后恰好六位数字的形式呈现。将所有测试用例的所有结果连接成一个单一的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reverse Jacobi rotation problem for a suite of test cases.\n    \"\"\"\n    # Test suite (angles in radians, indices zero-based):\n    # - Case 1: n=3, Lambda=diag(1.5,-0.5,2.5), sequence []\n    # - Case 2: n=3, Lambda=diag(1,2,4), sequence [(0,1,pi/6)]\n    # - Case 3: n=4, Lambda=diag(0.5,1.5,2.5,3.5), sequence [(0,2,pi/4),(1,3,pi/3),(0,1,-pi/8)]\n    # - Case 4: n=3, Lambda=diag(3,1,2), sequence [(0,2,0),(0,2,pi/2),(1,2,0)]\n    test_cases = [\n        {'n': 3, 'lambdas': [1.5, -0.5, 2.5], 'rotations': []},\n        {'n': 3, 'lambdas': [1, 2, 4], 'rotations': [(0, 1, np.pi / 6)]},\n        {'n': 4, 'lambdas': [0.5, 1.5, 2.5, 3.5], 'rotations': [(0, 2, np.pi / 4), (1, 3, np.pi / 3), (0, 1, -np.pi / 8)]},\n        {'n': 3, 'lambdas': [3, 1, 2], 'rotations': [(0, 2, 0), (0, 2, np.pi / 2), (1, 2, 0)]}\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n = case['n']\n        lambdas = case['lambdas']\n        rotations = case['rotations']\n\n        # Step 1: Construct the diagonal matrix Lambda\n        Lambda_mat = np.diag(lambdas)\n\n        # Step 2: Construct the orthogonal matrix Q from the sequence of rotations\n        if not rotations:\n            Q_mat = np.identity(n)\n        else:\n            # Initialize Q with the first rotation matrix G_1\n            p, q, theta = rotations[0]\n            c, s = np.cos(theta), np.sin(theta)\n            G = np.identity(n)\n            G[p, p], G[q, q] = c, c\n            G[p, q], G[q, p] = s, -s\n            Q_mat = G\n\n            # Accumulate the product Q = G_1 * G_2 * ... * G_k\n            for i in range(1, len(rotations)):\n                p, q, theta = rotations[i]\n                c, s = np.cos(theta), np.sin(theta)\n                G = np.identity(n)\n                G[p, p], G[q, q] = c, c\n                G[p, q], G[q, p] = s, -s\n                Q_mat = Q_mat @ G\n        \n        # Step 3: Reconstruct matrix A using A = Q * Lambda * Q^T\n        A_mat = Q_mat @ Lambda_mat @ Q_mat.T\n\n        # Step 4: Extract the upper-triangular entries in row-major order\n        case_results = []\n        for i in range(n):\n            for j in range(i, n):\n                # Format to 6 decimal places, including trailing zeros\n                formatted_val = f\"{A_mat[i, j]:.6f}\"\n                case_results.append(formatted_val)\n        \n        all_results.extend(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n\n```", "id": "2405315"}]}