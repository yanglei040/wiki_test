{"hands_on_practices": [{"introduction": "为什么我们在处理大型矩阵时要考虑随机算法？一个核心驱动力是其卓越的计算效率。本练习将引导你量化这一优势，通过推导和比较基础随机SVD、带 $q$ 次幂迭代的随机SVD以及经典的确定性Lanczos方法在计算复杂度和数据访问次数上的差异[@problem_id:3570685]。通过这个实践，你将能清晰地理解不同算法在求解秩 $k$ 近似问题时的性能权衡。", "problem": "考虑一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$，目标秩 $k \\ll \\min\\{m,n\\}$，过采样参数 $p \\geq 0$，以及表示幂迭代次数的非负整数 $q$。定义草图大小 $\\ell = k + p$。目标是估计用于随机化奇异值分解 (SVD) 的两种随机化值域寻找过程的算法成本，并将这些成本与通过 Golub–Kahan–Lanczos 双对角化过程计算的确定性截断 SVD 的成本进行比较。\n\n基本的随机化值域寻找器通过抽取一个测试矩阵 $\\Omega \\in \\mathbb{R}^{n \\times \\ell}$，形成 $Y = A \\Omega$，并计算 $Y$ 的薄 QR 分解（正交-三角分解），即 $Y = Q R$ 且 $Q^{\\top}Q = I_{\\ell}$，来构建 $A$ 的近似值域的一个标准正交基 $Q \\in \\mathbb{R}^{m \\times \\ell}$。其幂迭代变体通过一系列与 $A^{\\top}$ 和 $A$ 的交替乘法来形成 $Y = (A A^{\\top})^{q} A \\Omega$，从 $Y_{0} = A \\Omega$ 开始，对 $i = 1,2,\\dots,q$ 迭代 $Y_{i} = A \\big( A^{\\top} Y_{i-1} \\big)$，然后对最终的 $Y$ 执行薄 QR 分解。\n\n对于确定性截断 SVD，考虑运行 $k$ 步的 Golub–Kahan–Lanczos 双对角化过程以获得前 $k$ 个奇异三元组，该过程在每一步中对向量应用一次与 $A$ 的乘法和一次与 $A^{\\top}$ 的乘法。\n\n采用以下运算计数模型作为成本推导的基础：\n- 一个 $m \\times n$ 矩阵与一个 $n \\times r$ 矩阵相乘的成本为 $2 m n r$ 次浮点运算 (flops)。\n- 一个 $n \\times m$ 矩阵与一个 $m \\times r$ 矩阵相乘的成本为 $2 m n r$ 次 flops。\n- 对一个 $m \\times r$ 矩阵（$m \\geq r$）进行薄 Householder QR 分解（正交-三角分解）的成本为 $2 m r^{2} - \\tfrac{2}{3} r^{3}$ 次 flops。\n- 对 $A$ 的一次遍历定义为与任意操作数（矩阵或向量）进行一次完整的与 $A$ 或 $A^{\\top}$ 的乘法；换句话说，每一次应用 $A$ 和每一次应用 $A^{\\top}$ 都算作一次遍历。\n\n在此模型下，推导以下各项的符号表达式：\n1. 基本随机化值域寻找器所需的总 flop 计数和对 $A$ 的遍历次数（一次乘法 $Y = A \\Omega$ 后跟对 $Y$ 的薄 QR 分解）。\n2. 幂迭代变体所需的总 flop 计数和对 $A$ 的遍历次数（如上所述的 $q$ 次幂迭代，后跟对 $Y$ 的薄 QR 分解）。\n3. 通过运行 $k$ 步的 Golub–Kahan–Lanczos 双对角化实现的确定性截断 SVD 所需的总 flop 计数和对 $A$ 的遍历次数。\n\n用 $m$、$n$、$k$、$p$ 和 $q$（其中 $\\ell = k + p$）精确表示各项成本。只关注上述模型中指定的主要运算；忽略随机矩阵生成、与所述步骤无关的小型稠密矩阵分解，以及确定性方法中除所述矩阵-向量乘法之外的任何再正交化开销。不需要四舍五入。以一个单行矩阵的形式提供你的最终答案，该矩阵包含六个条目，顺序如下：\n$(\\text{flops}_{\\text{basic}}, \\text{passes}_{\\text{basic}}, \\text{flops}_{\\text{power}}, \\text{passes}_{\\text{power}}, \\text{flops}_{\\text{Lanczos}}, \\text{passes}_{\\text{Lanczos}})$。", "solution": "问题陈述已被解析和验证。所有必需的数据、定义和成本模型都已明确提供。该问题在数值线性代数领域具有科学依据，具体涉及矩阵分解的随机化算法。该问题是良定的、客观的且内部一致的。未发现任何缺陷。因此，将推导一个解决方案。\n\n任务是根据提供的成本模型，确定三种不同算法的浮点运算 (flop) 计数和对矩阵 $A$ 的遍历次数。设 $A \\in \\mathbb{R}^{m \\times n}$，目标秩为 $k$，过采样参数为 $p$，草图大小为 $\\ell = k + p$。幂迭代次数为 $q$。\n\n成本模型如下：\n- 一个 $m \\times n$ 矩阵与一个 $n \\times r$ 矩阵相乘的成本为 $2mnr$ 次 flops。\n- 对一个 $m \\times r$ 矩阵（$m \\geq r$）进行薄 Householder QR 分解的成本为 $2mr^2 - \\frac{2}{3}r^3$ 次 flops。\n- 对 $A$ 的一次遍历是与 $A$ 或 $A^\\top$ 的一次乘法。\n\n1. **基本的随机化值域寻找器**\n该过程包括两个阶段：\na) 形成草图矩阵 $Y = A \\Omega$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 且 $\\Omega \\in \\mathbb{R}^{n \\times \\ell}$。\nb) 计算 $Y \\in \\mathbb{R}^{m \\times \\ell}$ 的薄 QR 分解。\n\na) 形成 $Y = A \\Omega$ 的成本是一个 $m \\times n$ 矩阵与一个 $n \\times \\ell$ 矩阵的矩阵-矩阵乘法。根据模型，当 $r = \\ell$ 时，成本为：\n$$ \\text{flops}(A\\Omega) = 2mn\\ell $$\n此步骤涉及一次与 $A$ 的乘法，构成对 $A$ 的 1 次遍历。\n\nb) 计算 $Y \\in \\mathbb{R}^{m \\times \\ell}$ 的薄 QR 分解的成本由模型给出，其中 $r = \\ell$：\n$$ \\text{flops}(QR(Y)) = 2m\\ell^2 - \\frac{2}{3}\\ell^3 $$\n此步骤不涉及矩阵 $A$。\n\n总 flop 计数是这些成本的总和。代入 $\\ell = k+p$：\n$$ \\text{flops}_{\\text{basic}} = 2mn\\ell + 2m\\ell^2 - \\frac{2}{3}\\ell^3 = 2mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3 $$\n总遍历次数为：\n$$ \\text{passes}_{\\text{basic}} = 1 $$\n\n2. **幂迭代的随机化值域寻找器**\n该过程涉及三个阶段：\na) 形成初始草图矩阵 $Y_0 = A \\Omega$。\nb) 执行 $q$ 次幂迭代：$Y_i = A (A^{\\top} Y_{i-1})$，其中 $i = 1, \\dots, q$。\nc) 计算最终矩阵 $Y = Y_q$ 的薄 QR 分解。\n\na) 形成 $Y_0 = A \\Omega$ 的成本与基本方法的第一步相同：\n$$ \\text{flops}(Y_0) = 2mn\\ell $$\n此步骤使用对 $A$ 的 1 次遍历。\n\nb) $q$ 次幂迭代中的每一次都涉及两次矩阵-矩阵乘法：\n- 首先，形成 $Z_i = A^{\\top} Y_{i-1}$，其中 $A^{\\top} \\in \\mathbb{R}^{n \\times m}$ 且 $Y_{i-1} \\in \\mathbb{R}^{m \\times \\ell}$。根据模型，成本为 $2nm\\ell$ 次 flops。这是对 $A$ 的 1 次遍历（通过 $A^\\top$）。\n- 其次，形成 $Y_i = A Z_i$，其中 $A \\in \\mathbb{R}^{m \\times n}$ 且 $Z_i \\in \\mathbb{R}^{n \\times \\ell}$。成本为 $2mn\\ell$ 次 flops。这是对 $A$ 的另一次遍历。\n一次幂迭代的总成本为 $2nm\\ell + 2mn\\ell = 4mn\\ell$ 次 flops，并且需要对 $A$ 进行 2 次遍历。\n对于 $q$ 次迭代，总成本和遍历次数为：\n$$ \\text{flops}(\\text{幂迭代}) = q \\cdot (4mn\\ell) = 4qmn\\ell $$\n$$ \\text{passes}(\\text{幂迭代}) = 2q $$\n\nc) 最终 $Y_q \\in \\mathbb{R}^{m \\times \\ell}$ 的 QR 分解成本与基本方法中的相同：\n$$ \\text{flops}(QR(Y_q)) = 2m\\ell^2 - \\frac{2}{3}\\ell^3 $$\n\n总 flop 计数是所有三个阶段成本的总和。代入 $\\ell = k+p$：\n$$ \\text{flops}_{\\text{power}} = 2mn\\ell + 4qmn\\ell + 2m\\ell^2 - \\frac{2}{3}\\ell^3 = (2+4q)mn\\ell + 2m\\ell^2 - \\frac{2}{3}\\ell^3 $$\n$$ \\text{flops}_{\\text{power}} = 2(1+2q)mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3 $$\n总遍历次数是阶段 (a) 和 (b) 遍历次数的总和：\n$$ \\text{passes}_{\\text{power}} = 1 + 2q $$\n\n3. **通过 Golub–Kahan–Lanczos 双对角化实现的确定性截断 SVD**\n该过程运行 $k$ 步。问题陈述指出，每一步都对向量应用一次与 $A$ 的乘法和一次与 $A^{\\top}$ 的乘法。按照指示，我们忽略任何其他成本。\n\n矩阵-向量乘法是矩阵-矩阵乘法的一个特例，其中一个矩阵只有一列（$r=1$）。\n- 将 $A \\in \\mathbb{R}^{m \\times n}$ 与一个向量 $\\mathbf{v} \\in \\mathbb{R}^{n \\times 1}$ 相乘的成本为 $2mn(1) = 2mn$ 次 flops。这是对 $A$ 的 1 次遍历。\n- 将 $A^{\\top} \\in \\mathbb{R}^{n \\times m}$ 与一个向量 $\\mathbf{u} \\in \\mathbb{R}^{m \\times 1}$ 相乘的成本为 $2nm(1) = 2nm$ 次 flops。这是对 $A$ 的 1 次遍历（通过 $A^\\top$）。\n\n一步的总成本是这两个乘法的总和：\n$$ \\text{flops}(\\text{1 步}) = 2mn + 2nm = 4mn $$\n一步的遍历次数为 $1 + 1 = 2$。\n\n对于 $k$ 步，总成本和遍历次数为：\n$$ \\text{flops}_{\\text{Lanczos}} = k \\cdot (4mn) = 4mnk $$\n$$ \\text{passes}_{\\text{Lanczos}} = k \\cdot 2 = 2k $$\n\n结果摘要：\n- 基本随机化值域寻找器：\n  - Flops: $2mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3$\n  - 遍历次数: $1$\n- 幂迭代变体：\n  - Flops: $2(1+2q)mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3$\n  - 遍历次数: $1+2q$\n- Lanczos 双对角化：\n  - Flops: $4mnk$\n  - 遍历次数: $2k$\n\n这些结果将被编译成一个单行矩阵作为最终答案。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3  1  2(1+2q)mn(k+p) + 2m(k+p)^2 - \\frac{2}{3}(k+p)^3  1+2q  4mnk  2k\n\\end{pmatrix}\n}\n$$", "id": "3570685"}, {"introduction": "随机算法的效率令人信服，但我们如何确信其结果的可靠性？一个关键环节是能够有效地估计近似误差，例如残差 $A - QQ^{\\top}A$ 的范数。本练习探讨了一种利用随机高斯探针 $z \\sim \\mathcal{N}(0, I)$ 来估计残差平方Frobenius范数的方法，这是许多随机算法理论分析和实际应用中的基石[@problem_id:3570736]。你将通过第一性原理推导该估计量的统计特性，证明其无偏性并计算其方差，从而深入理解这些概率工具如何保证随机方法的可靠性。", "problem": "设 $A \\in \\mathbb{R}^{m \\times n}$ 是一个固定矩阵，设 $Q \\in \\mathbb{R}^{m \\times k}$ 的列是标准正交的，这些列是通过一个随机化奇异值分解（SVD）算法中的随机化值域查找器得到的。定义残差算子 $B \\in \\mathbb{R}^{m \\times n}$ 为 $B = (I_{m} - Q Q^{\\top}) A$，其中 $I_{m}$ 是 $m \\times m$ 单位矩阵。考虑一个单探针高斯残差范数估计量，它通过抽取 $z \\sim \\mathcal{N}(0, I_{n})$ 并计算可观测量\n$$\n\\widehat{S} \\;=\\; \\|B z\\|_{2}^{2} \\;=\\; z^{\\top} B^{\\top} B z,\n$$\n来构造，该估计量在实践中用于近似残差大小 $\\|A - Q Q^{\\top} A\\|$。在本题中，将 $\\widehat{S}$ 视为弗罗贝尼乌斯（Frobenius）残差平方\n$$\nS \\;=\\; \\|B\\|_{F}^{2} \\;=\\; \\operatorname{tr}(B^{\\top} B)\n$$\n的一个估计量。从概率论和线性代数的基本原理出发，即标准正态分布的各向同性、正交投影算子的性质以及高斯二次型的矩恒等式，推导以下各项的闭式表达式：\n- $\\widehat{S}$ 作为 $S$ 的估计量的偏差，即 $\\mathbb{E}[\\widehat{S}] - S$，以及\n- 方差 $\\operatorname{Var}(\\widehat{S})$，\n这些表达式需用 $B$ 的奇异值 $\\{\\sigma_{i}(B)\\}_{i=1}^{\\rho}$（其中 $\\rho = \\operatorname{rank}(B)$）明确表示。您的最终答案必须是一个单一的解析表达式，在一个单行矩阵中包含偏差和方差，且仅用 $\\{\\sigma_{i}(B)\\}$ 表示。不需要进行数值近似。", "solution": "我们首先回顾一下背景设定。矩阵 $Q \\in \\mathbb{R}^{m \\times k}$ 具有标准正交列，因此 $Q^{\\top} Q = I_{k}$，而矩阵 $I_{m} - Q Q^{\\top}$ 是到 $Q$ 的列空间的正交补空间上的正交投影算子。残差算子是 $B = (I_{m} - Q Q^{\\top}) A \\in \\mathbb{R}^{m \\times n}$。高斯探针是 $z \\sim \\mathcal{N}(0, I_{n})$，因此 $z$ 具有零均值和单位协方差，即 $\\mathbb{E}[z] = 0$ 和 $\\mathbb{E}[z z^{\\top}] = I_{n}$。估计量是 $\\widehat{S} = \\|B z\\|_{2}^{2} = z^{\\top} B^{\\top} B z$。\n\n我们的目标是以闭式形式计算 $\\widehat{S}$ 作为 $S = \\|B\\|_{F}^{2} = \\operatorname{tr}(B^{\\top} B)$ 的估计量的偏差和方差。我们使用的核心概率工具是关于标准正态向量二次型的恒等式。设 $M \\in \\mathbb{R}^{n \\times n}$ 是一个固定的对称矩阵，且 $z \\sim \\mathcal{N}(0, I_{n})$。那么以下事实成立：\n1. $\\mathbb{E}[z^{\\top} M z] = \\operatorname{tr}(M)$。\n2. $\\operatorname{Var}(z^{\\top} M z) = 2 \\|M\\|_{F}^{2} = 2 \\operatorname{tr}(M^{2})$。\n\n这些结论可由标准正态分布的各向同性以及关于高斯变量四阶矩的 Wick (Isserlis) 定理推导得出：\n$$\n\\mathbb{E}[z_{i} z_{j} z_{k} z_{l}] = \\delta_{i j} \\delta_{k l} + \\delta_{i k} \\delta_{j l} + \\delta_{i l} \\delta_{j k},\n$$\n其中 $\\delta_{i j}$ 是克罗内克（Kronecker）delta。\n\n我们将这些恒等式应用于 $M = B^{\\top} B$。注意 $M$ 是对称半正定矩阵。于是\n$$\n\\widehat{S} = z^{\\top} M z.\n$$\n\n首先，计算期望：\n$$\n\\mathbb{E}[\\widehat{S}] = \\mathbb{E}[z^{\\top} M z] = \\operatorname{tr}(M) = \\operatorname{tr}(B^{\\top} B) = \\|B\\|_{F}^{2} = S.\n$$\n因此，偏差为\n$$\n\\mathbb{E}[\\widehat{S}] - S = 0.\n$$\n\n接下来，计算方差：\n$$\n\\operatorname{Var}(\\widehat{S}) = \\operatorname{Var}(z^{\\top} M z) = 2 \\operatorname{tr}(M^{2}) = 2 \\|M\\|_{F}^{2}.\n$$\n为了用 $B$ 的奇异值来表示这个结果，我们回顾一下，如果 $\\{\\sigma_{i}(B)\\}_{i=1}^{\\rho}$ 是 $B$ 的非零奇异值，那么 $M = B^{\\top} B$ 的特征值是 $\\{\\sigma_{i}(B)^{2}\\}_{i=1}^{\\rho}$ 以及一些零。因此，\n$$\n\\operatorname{tr}(M) = \\sum_{i=1}^{\\rho} \\sigma_{i}(B)^{2}, \\quad \\operatorname{tr}(M^{2}) = \\sum_{i=1}^{\\rho} \\sigma_{i}(B)^{4}.\n$$\n因此，\n$$\n\\operatorname{Var}(\\widehat{S}) = 2 \\sum_{i=1}^{\\rho} \\sigma_{i}(B)^{4}.\n$$\n\n总而言之，对于残差范数平方的单探针高斯估计量\n$$\n\\widehat{S} = \\|(I_{m} - Q Q^{\\top}) A z\\|_{2}^{2},\n$$\n其偏差等于零，方差等于 $2 \\sum_{i=1}^{\\rho} \\sigma_{i}(B)^{4}$，其中 $B = (I_{m} - Q Q^{\\top}) A$，$\\{\\sigma_{i}(B)\\}$ 是其奇异值。这些恒等式是精确的，并且可以从高斯二次型和奇异值分解（SVD）的基本性质推导得出。", "answer": "$$\\boxed{\\begin{pmatrix} 0  2 \\sum_{i=1}^{\\rho} \\sigma_{i}(B)^{4} \\end{pmatrix}}$$", "id": "3570736"}, {"introduction": "从理论分析到实际应用，我们必须面对真实世界的工程约束，其中最常见的就是内存限制。本练习将理论与实践相结合，要求你为巨大的矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 设计一个能够在内存预算 $B$ 内高效运行的分块随机SVD算法[@problem_id:3570738]。你需要精确分析算法的内存占用，结合误差界来确定超采样参数 $p$，最终在给定约束下推导出最优的分块大小 $s$。这个综合性问题将全面考验你对随机SVD算法实现细节和性能调优的理解。", "problem": "考虑一种分块实现的随机奇异值分解（RSVD），其目标是通过构造一个正交基 $Q \\in \\mathbb{R}^{m \\times r}$（其中 $r = k + p$，$p$ 是一个过采样参数）来近似一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的前 $k$ 个奇异分量。给定所有内存数组的内存预算为 $B$ 个机器字。假设存在以下算法结构和实现约束，您在推理中必须使用它们：\n\n- 使用一个高斯测试矩阵 $\\Omega \\in \\mathbb{R}^{n \\times r}$ 来构建样本矩阵 $Y = A \\Omega$。为了满足内存预算，以大小为 $s$ 的列分块形式访问 $A$，并应用相应的 $\\Omega$ 分块，以便在对 $A$ 的列进行单次遍历时在内存中累积 $Y$。\n- 矩阵 $Y \\in \\mathbb{R}^{m \\times r}$ 通过一个数值稳定的正交化程序被正交化以产生 $Q \\in \\mathbb{R}^{m \\times r}$（您可以假定该程序需要一个大小为 $O(r^{2})$ 的内存暂存空间，在您的内存计算中明确地按一个 $r \\times r$ 数组处理）。\n- 算法不显式地形成 $B = Q^{\\mathsf{T}} A \\in \\mathbb{R}^{r \\times n}$，而是通过再次以相同大小 $s$ 的列分块流式处理 $A$ 来形成 $r \\times r$ 的协方差矩阵 $F = Q^{\\mathsf{T}} A A^{\\mathsf{T}} Q$，对每个分块 $A_{j} \\in \\mathbb{R}^{m \\times s}$ 累积 $F \\leftarrow F + (Q^{\\mathsf{T}} A_{j})(Q^{\\mathsf{T}} A_{j})^{\\mathsf{T}}$。这样可以避免将 $B$ 或整个 $A$ 存储在内存中。\n- 您必须确保谱范数相对误差的期望值满足 $\\mathbb{E}\\!\\left[\\lVert A - Q Q^{\\mathsf{T}} A \\rVert_{2}\\right] \\leq (1 + \\epsilon)\\, \\sigma_{k+1}$ 的形式，其中 $\\sigma_{k+1}$ 表示 $A$ 的第 $(k+1)$ 个奇异值。这是通过使用 RSVD 标准幂方案中的 $q \\geq 0$ 次幂迭代和一个高斯测试矩阵来实现的。您可以假设过采样 $p \\geq 4$ 是允许的，并且高斯素描和幂迭代的经过充分检验的期望界是适用的。\n\n任务：\n- 从所涉及矩阵的核心定义、分块矩阵乘积和正交化出发，推导该分块 RSVD 流水线主要步骤的精确内存占用量（以机器字为单位），将其表示为 $m$、$n$、$k$、$p$ 和分块大小 $s$ 的函数。明确计算在每个步骤中必须同时驻留在内存中的所有数组，以论证一个单一的上限表达式 $M(s)$，该表达式能安全地覆盖整个算法过程中的内存使用量。\n- 使用带有 $q$ 次幂迭代的高斯 RSVD 的经过充分检验的误差界，推导一个关于过采样参数 $p$ 的充分闭式不等式（用 $k$、$q$ 和 $\\epsilon$ 表示），以保证达到所述的误差目标。将此不等式转换为 $p$ 的一个显式闭式下界。\n- 结合内存占用量和过采样要求，为满足内存预算 $B$ 并达到误差目标的最大允许整数分块大小 $s^{\\star}$ 推导一个单一的闭式解析表达式。您的设计必须强制 $s^{\\star} \\leq n$ 和 $s^{\\star} \\geq 0$。\n\n以 $m$、$n$、$k$、$\\epsilon$、$q$ 和 $B$ 表示 $s^{\\star}$ 的单一闭式数学表达式的形式提供您的最终答案。不要包含任何数值计算。最终表达式中不要包含任何单位。如果您必须使用任何非初等函数或整值运算符，请在推导中隐式定义它们，但最终公式仅使用标准数学符号，如 $\\lfloor \\cdot \\rfloor$、$\\lceil \\cdot \\rceil$、$\\min$ 和 $\\max$。", "solution": "该问题是有效的，因为它科学地基于数值线性代数的原理，特别是随机算法，并且问题提法良好、客观，并包含足够的信息以得到唯一解。\n\n解的推导分为三个部分：首先，确定所述算法的内存占用量；其次，从给定的误差界推导出对过采样参数 $p$ 的要求；最后，结合这两个结果来找到最大允许分块大小 $s^{\\star}$。\n\n**第 1 部分：内存占用量的推导**\n\n总内存占用量是算法执行期间任意时刻所需的最大内存。该算法包括对矩阵 $A$ 的两次主要遍历。我们分析每次遍历的内存需求。素描大小为 $r = k+p$。\n\n遍历 1：生成正交基 $Q$。\n这个阶段计算 $Y = (A A^{\\mathsf{T}})^q A \\Omega$，然后将 $Y$ 正交化得到 $Q$。\n\n情况 $q=0$：样本矩阵为 $Y = A \\Omega$。计算是分块的：$Y = \\sum_j A_j \\Omega_j$。在这个求和的每一步，内存必须存放累加器 $Y \\in \\mathbb{R}^{m \\times r}$、当前矩阵分块 $A_j \\in \\mathbb{R}^{m \\times s}$ 以及相应的测试矩阵分块 $\\Omega_j \\in \\mathbb{R}^{s \\times r}$。所需内存为 $m r + m s + s r$。\n\n情况 $q \\geq 1$：样本矩阵为 $Y = (A A^{\\mathsf{T}})^q A \\Omega$。这是迭代计算的。令 $Y_{(0)} = A\\Omega$。这个初始步骤的内存为 $m r + m s + s r$。然后，对于 $i=1, \\dots, q$，我们计算 $Y_{(i)} = A A^{\\mathsf{T}} Y_{(i-1)}$。这是以分块方式执行的，$Y_{(i)} = \\sum_j A_j (A_j^{\\mathsf{T}} Y_{(i-1)})$。为了执行此求和中的一个更新步骤，我们需要在内存中保存：\n1. 上一次迭代的输入向量 $Y_{(i-1)} \\in \\mathbb{R}^{m \\times r}$（大小为 $m r$）。\n2. 当前迭代输出的累加器 $Y_{(i)} \\in \\mathbb{R}^{m \\times r}$（大小为 $m r$）。\n3. 矩阵的当前分块 $A_j \\in \\mathbb{R}^{m \\times s}$（大小为 $m s$）。\n4. 中间乘积 $A_j^{\\mathsf{T}} Y_{(i-1)} \\in \\mathbb{R}^{s \\times r}$（大小为 $s r$）。\n因此，幂迭代步骤中的峰值内存使用量为 $m s + 2 m r + s r$。这大于初始采样步骤的内存。因此，对于 $q \\ge 1$，采样的峰值内存为 $m s + 2 m r + s r$。\n\n我们可以将任何 $q \\geq 0$ 的采样内存需求表示为 $M_{samp}(s) = m s + s r + (1 + \\min(1, q)) m r$。\n\n计算出最终样本矩阵 $Y$ 后，将其正交化为 $Q \\in \\mathbb{R}^{m \\times r}$。此步骤需要矩阵 $Y$（大小为 $m r$）和一个大小为 $r \\times r$ 的内存暂存空间。正交化的内存为 $M_{ortho} = m r + r^2$。\n\n第一次遍历的总内存是采样和正交化阶段的最大值：$M_{pass1}(s) = \\max(M_{samp}(s), M_{ortho}) = \\max(m s + s r + (1 + \\min(1, q)) m r, m r + r^2)$。\n\n遍历 2：形成协方差矩阵 $F$。\n这次遍历通过累积分块更新来计算 $F = Q^{\\mathsf{T}} A A^{\\mathsf{T}} Q$：$F \\leftarrow F + (Q^{\\mathsf{T}} A_j)(Q^{\\mathsf{T}} A_j)^{\\mathsf{T}}$。在每一步，内存必须保存：\n1. 正交基 $Q \\in \\mathbb{R}^{m \\times r}$（大小为 $m r$）。\n2. 当前矩阵分块 $A_j \\in \\mathbb{R}^{m \\times s}$（大小为 $m s$）。\n3. $F \\in \\mathbb{R}^{r \\times r}$ 的累加器（大小为 $r^2$）。\n4. 中间乘积 $Q^{\\mathsf{T}} A_j \\in \\mathbb{R}^{r \\times s}$（大小为 $r s$）。\n这次遍历的总内存为 $M_{pass2}(s) = m r + m s + r^2 + r s$。\n\n整体内存占用量 $M(s)$：\n整个算法的峰值内存为 $M(s) = \\max(M_{pass1}(s), M_{pass2}(s))$。\n$M(s) = \\max(\\max(m s + s r + (1 + \\min(1, q)) m r, m r + r^2), m r + m s + r^2 + r s)$。\n由于 $m r + m s + r^2 + r s = (m r + r^2) + s(m+r)$，对于 $s > 0$，遍历 2 的项严格大于正交化内存 $m r + r^2$。\n因此，表达式简化为：\n$M(s) = \\max(m s + s r + (1 + \\min(1, q)) m r, m s + s r + m r + r^2)$。\n这可以通过提取公因式重写为：\n$M(s) = m s + s r + \\max((1 + \\min(1, q)) m r, m r + r^2)$。\n$M(s) = s(m+r) + m r + \\max(\\min(1, q) m r, r^2)$。\n\n**第 2 部分：过采样参数解析表达式的推导**\n\n问题要求一个形如 $\\mathbb{E}\\!\\left[\\lVert A - Q Q^{\\mathsf{T}} A \\rVert_{2}\\right] \\leq (1 + \\epsilon)\\, \\sigma_{k+1}$ 的误差界。对于带有 $q$ 次幂迭代和高斯测试矩阵的 RSVD，标准的理论结果提供了一个界，在有足够谱隙（使得尾部追逐项可以忽略不计）的假设下，可以表示为：\n$$ \\mathbb{E}\\!\\left[\\lVert A - Q Q^{\\mathsf{T}} A \\rVert_{2}\\right] \\leq \\left(1 + \\sqrt{\\frac{k}{p-1}}\\right)^{\\frac{1}{2q+1}} \\sigma_{k+1} $$\n为了满足问题的要求，我们必须有：\n$$ \\left(1 + \\sqrt{\\frac{k}{p-1}}\\right)^{\\frac{1}{2q+1}} \\leq 1 + \\epsilon $$\n将两边同时取 $2q+1$ 次幂：\n$$ 1 + \\sqrt{\\frac{k}{p-1}} \\leq (1+\\epsilon)^{2q+1} $$\n$$ \\sqrt{\\frac{k}{p-1}} \\leq (1+\\epsilon)^{2q+1} - 1 $$\n对两边进行平方（注意到对于 $\\epsilon \\ge 0$，两边都是非负的）：\n$$ \\frac{k}{p-1} \\leq \\left( (1+\\epsilon)^{2q+1} - 1 \\right)^2 $$\n$$ p-1 \\geq \\frac{k}{\\left( (1+\\epsilon)^{2q+1} - 1 \\right)^2} $$\n$$ p \\geq 1 + \\frac{k}{\\left( (1+\\epsilon)^{2q+1} - 1 \\right)^2} $$\n由于 $p$ 必须是整数，且问题说明 $p \\geq 4$ 是允许的，因此我们记为 $p^{\\star}$ 的最小充分整数值为：\n$$ p^{\\star} = \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right) $$\n\n**第 3 部分：最大允许分块大小的推导**\n\n我们结合前面几个部分的结果。总内存占用量 $M(s)$ 不得超过预算 $B$。我们使用最小的充分素描大小 $r^{\\star} = k+p^{\\star}$。\n$$ s(m+r^{\\star}) + m r^{\\star} + \\max(\\min(1, q) m r^{\\star}, (r^{\\star})^2) \\leq B $$\n解出 $s$：\n$$ s(m+r^{\\star}) \\leq B - m r^{\\star} - \\max(\\min(1, q) m r^{\\star}, (r^{\\star})^2) $$\n$$ s \\leq \\frac{B - m r^{\\star} - \\max(\\min(1, q) m r^{\\star}, (r^{\\star})^2)}{m+r^{\\star}} $$\n分块大小 $s$ 必须是整数，并受限于 $0 \\leq s \\leq n$。因此，最大允许整数分块大小 $s^{\\star}$ 是上述表达式向下取整，并以 $n$ 为上限、以 $0$ 为下限的结果。\n$$ s^{\\star} = \\max\\left(0, \\min\\left(n, \\left\\lfloor \\frac{B - m r^{\\star} - \\max(\\min(1, q) m r^{\\star}, (r^{\\star})^2)}{m+r^{\\star}} \\right\\rfloor\\right)\\right) $$\n将 $r^{\\star} = k+p^{\\star}$ 和 $p^{\\star}$ 的完整表达式代入，得到以给定参数表示的 $s^{\\star}$ 的最终闭式表达式。\n令 $P_0 = \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right)$。\n则 $r^{\\star} = k + P_0$。\n$s^{\\star}$ 的表达式变为：\n$$ s^{\\star} = \\max\\left(0, \\min\\left(n, \\left\\lfloor \\frac{B - m(k+P_0) - \\max(\\min(1, q) m(k+P_0), (k+P_0)^2)}{m+k+P_0} \\right\\rfloor\\right)\\right) $$\n这个表达式将所有约束组合成一个单一的公式。", "answer": "$$ \\boxed{\\max\\left(0, \\min\\left(n, \\left\\lfloor \\frac{B - m\\left(k + \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right)\\right) - \\max\\left(\\min(1,q)m\\left(k + \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right)\\right), \\left(k + \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right)\\right)^2\\right)}{m + k + \\max\\left(4, \\left\\lceil 1 + \\frac{k}{\\left((1+\\epsilon)^{2q+1} - 1\\right)^2} \\right\\rceil\\right)} \\right\\rfloor\\right)\\right)} $$", "id": "3570738"}]}