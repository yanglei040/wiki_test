{"hands_on_practices": [{"introduction": "掌握重排序算法的第一步是理解其核心目标：减少填充（fill-in）。本练习将通过一个具体实例，让你动手实践高斯消元法单步操作中填充是如何产生的。通过使用稀疏矩阵的图表示，你将直观地看到在消除一个顶点时，图结构如何发生变化并产生新的“填充”边，这是理解更复杂算法的基础。[@problem_id:3574459]", "problem": "考虑一个实对称正定矩阵 $A \\in \\mathbb{R}^{5 \\times 5}$，其非对角稀疏模式由顶点集为 $\\{1,2,3,4,5\\}$ 的无向图 $G(A)$ 表示。图 $G(A)$ 由以下对称邻接表指定（边是无向的，对角线元素是隐式的，不表示为边）：\n- 顶点 $1$：邻居 $\\{2,3\\}$。\n- 顶点 $2$：邻居 $\\{1,3,4\\}$。\n- 顶点 $3$：邻居 $\\{1,2\\}$。\n- 顶点 $4$：邻居 $\\{2,5\\}$。\n- 顶点 $5$：邻居 $\\{4\\}$。\n\n你需要对顶点 $2$ 执行一步稀疏 Cholesky 消元（等价于对称主元高斯消元）。使用对称矩阵消元的标准图论解释：当消去一个顶点时，其所有当前邻居在剩余顶点中被连接起来形成一个团（clique），然后被消去的顶点从图中移除。经过这一步消元后，在剩余顶点上得到的图被称为该步骤的消元图，任何原先在 $G(A)$ 中不存在但因团的形成而引入的新边，被称为填充边。\n\n从给定的图 $G(A)$ 开始，首先消去顶点 $2$，根据上述规则在剩余的顶点 $\\{1,3,4,5\\}$ 上构建消元图，并精确确定此步骤引入了多少条填充边。只需报告首先消去顶点 $2$ 所引入的填充边的总数。将你的最终答案表示为一个整数。无需四舍五入。", "solution": "基本原理是对称矩阵稀疏模式的图解释，以及在稀疏 Cholesky 分解的消元过程中控制填充（fill-in）的规则。对于一个对称矩阵 $A$，其稀疏模式可以由一个无向图 $G(A)$ 来描述，图的顶点对应于 $A$ 的索引。当且仅当 $a_{ij} \\neq 0$ 时，图中存在一条边 $(i,j)$（其中 $i \\neq j$）。当对顶点 $v$ 执行单步消元时（对应于在 Cholesky 分解中以索引 $v$ 为主元），消元规则规定：在当前图中，$v$ 的所有邻居相互连接（形成一个团），以反映舒尔补（Schur complement）的更新，然后顶点 $v$ 被移除。在 $v$ 的邻居之间引入的任何原本不存在的边被称为填充边。这个图论过程与一个代数事实相匹配，即舒尔补更新会在与被消去顶点的邻居对相应的位置上产生新的非零元。\n\n我们从给定的、顶点集为 $\\{1,2,3,4,5\\}$ 的图 $G(A)$ 开始。其邻接关系如下：\n- 顶点 $1$：邻居 $\\{2,3\\}$。\n- 顶点 $2$：邻居 $\\{1,3,4\\}$。\n- 顶点 $3$：邻居 $\\{1,2\\}$。\n- 顶点 $4$：邻居 $\\{2,5\\}$。\n- 顶点 $5$：邻居 $\\{4\\}$。\n\n我们首先消去顶点 $2$。顶点 $2$ 的邻居集合是\n$$\nN(2) = \\{1,3,4\\}。\n$$\n根据消元规则，我们必须在剩余的顶点中连接 $N(2)$ 中的所有点对，以在 $\\{1,3,4\\}$ 上形成一个团。$\\{1,3,4\\}$ 中可能的点对是：\n$$\n\\{(1,3), (1,4), (3,4)\\}。\n$$\n我们确定这些边中哪些已存在于 $G(A)$ 中，哪些将成为填充边：\n- 边 $(1,3)$ 已存在，因为顶点 $1$ 的邻居列表包含 $3$，顶点 $3$ 的邻居列表包含 $1$。\n- 边 $(1,4)$ 在原图中不存在，因为顶点 $1$ 的邻居列表是 $\\{2,3\\}$，顶点 $4$ 的邻居列表是 $\\{2,5\\}$，所以 $(1,4)$ 不存在。\n- 边 $(3,4)$ 在原图中不存在，因为顶点 $3$ 的邻居列表是 $\\{1,2\\}$，顶点 $4$ 的邻居列表是 $\\{2,5\\}$，所以 $(3,4)$ 不存在。\n\n因此，该消元步骤恰好引入了以下填充边：\n$$\n(1,4) \\quad \\text{和} \\quad (3,4)。\n$$\n在剩余顶点中添加这些边并移除顶点 $2$ 后，在 $\\{1,3,4,5\\}$ 上的消元图具有以下边：\n- 来自原图中剩余顶点的边：$(1,3)$ 和 $(4,5)$。\n- 来自填充的边：$(1,4)$ 和 $(3,4)$。\n\n消去顶点 $2$ 所引入的填充边的总数是新添加的边的数量，即\n$$\n2.\n$$", "answer": "$$\\boxed{2}$$", "id": "3574459"}, {"introduction": "在局部层面理解了填充的产生机制后，下一步是分析整个消元顺序对全局分解结构的影响。本练习对比了三种基本的排序策略——自然排序、最小度排序和嵌套剖分排序——在一个典型的路径图上的表现。通过推导每种策略产生的消元树及其高度，你将深刻体会到局部贪心选择与全局分治策略之间的巨大差异，这对于理解填充抑制和并行计算潜力至关重要。[@problem_id:3574498]", "problem": "考虑一个由一维最近邻离散化产生的对称正定 (SPD) 块三对角矩阵 $A \\in \\mathbb{R}^{nb \\times nb}$，该矩阵有 $n$ 个大小为 $b \\times b$ 的块，其中 $b \\geq 1$。其在超节点层级的关联块稀疏图的顶点为 $\\{1,2,\\dots,n\\}$，边为 $\\{(i,i+1): i=1,2,\\dots,n-1\\}$，即路径图 $P_n$。我们研究在对超节点进行重排序的不同置换 $P$ 下，$P^{T} A P$ 的超节点消去树（一个有向树，其中一个超节点的父节点是在排序中位于其后、且在对应的 Cholesky 因子中具有非零元的最小超节点）。\n\n从以下基本事实和定义出发：\n\n1. $P^{T} A P$ 的 Cholesky 因子的消去树仅取决于超节点的排序以及消去过程中产生的填充图中的图可达性，而不取决于块内的数值。\n2. 对于超节点的一个排序 $\\pi$，如果 $(i,j)$ 是一条原始边，或者在原始图中 $i$ 和 $j$ 之间存在一条路径，其内部顶点在排序 $\\pi$ 下都位于 $\\max\\{i,j\\}$ 之前，那么填充图 $F$ 中 $i$ 和 $j$ 之间就存在一条边。\n3. 在消去树中，超节点 $i$ 的父节点是在排序 $\\pi$ 中位于 $i$ 之后、且 Cholesky 因子在位置 $(j,i)$ 上有非零元的最小超节点 $j$；等价地，$j$ 是 $i$ 在填充图 $F$ 中位于其后的最小邻居。\n\n定义消去树的高度为从叶节点到根节点的最长路径上的顶点数。\n\n分析以下三种超节点排序：\n\n(a) 自然从左到右排序 $\\pi_{\\mathrm{nat}} = (1,2,\\dots,n)$。\n\n(b) 在路径图 $P_n$ 上的最小度 (MD) 排序 $\\pi_{\\mathrm{md}}$，其决胜规则是确定性的，即在每一步中总是从具有最小度的超节点中选择索引最小的那个。\n\n(c) 一个平衡嵌套剖分 (ND) 排序 $\\pi_{\\mathrm{nd}}$，通过在其中心超节点处递归地二分路径，并在每个递归层级上按“左子路径，右子路径，分隔符最后”的顺序排序而得到。假设对于某个整数 $k \\geq 1$，有 $n=2^{k}-1$，因此每次二分都会产生两个大小相等的子路径和一个单顶点分隔符。\n\n仅使用上述原理，推导每种排序下消去树的结构及其高度（作为 $n$ 的函数）。然后，针对 $n=15$（$b \\geq 1$ 为任意值）的特殊情况，计算量\n$$\nH_{\\mathrm{nat}} - H_{\\mathrm{nd}},\n$$\n其中 $H_{\\mathrm{nat}}$ 和 $H_{\\mathrm{nd}}$ 分别表示在 $\\pi_{\\mathrm{nat}}$ 和 $\\pi_{\\mathrm{nd}}$ 排序下消去树的高度。请提供您的最终答案，形式为一个整数。不需要单位，也无需四舍五入。", "solution": "我们通过分析每种排序策略对路径图 $P_n$ 的消去过程和所得消去树结构的影响来求解。\n\n**(a) 自然排序：$\\pi_{\\mathrm{nat}} = (1, 2, \\dots, n)$**\n\n在此排序下，超节点按 $1, 2, \\dots, n$ 的顺序依次消去。根据消去树父节点的定义，超节点 $i$ 的父节点是在排序中位于 $i$ 之后、且与 $i$ 在填充图中有连接的最小索引 $j$。在路径图 $P_n$ 中，对于任何超节点 $i  n$，它都与 $i+1$ 相邻。由于在自然排序中 $i+1$ 总是在 $i$ 之后，因此 $i+1$ 是 $i$ 的一个候选父节点。因为 $i+1$ 是所有大于 $i$ 的索引中最小的一个，所以它必然是 $i$ 的最小的、位于其后的邻居。因此，对于所有 $i \\in \\{1, \\dots, n-1\\}$，都有 $\\text{parent}(i) = i+1$。\n这构成了消去树的一条长链：$1 \\to 2 \\to \\dots \\to n$。根节点是 $n$。此树的高度 $H_{\\mathrm{nat}}$ 等于链中的顶点数，即 $n$。\n\n**(b) 最小度排序：$\\pi_{\\mathrm{md}}$**\n\n在路径图 $P_n$ 中，顶点 $1$ 和 $n$ 的度为 $1$，所有内部顶点 $i \\in \\{2, \\dots, n-1\\}$ 的度为 $2$。最小度为 $1$。根据决胜规则（从具有最小度的顶点中选择索引最小的那个），算法将首先选择顶点 $1$。消去 $1$ 后，顶点 $2$ 在剩余图中的度变为 $1$。此时，图中度为 $1$ 的顶点是 $2$ 和 $n$。再次根据决胜规则，选择索引较小的顶点 $2$。这个过程将持续下去，依次选择 $3, 4, \\dots, n-1$。最后剩下顶点 $n$。因此，最小度排序为 $\\pi_{\\mathrm{md}} = (1, 2, \\dots, n)$，与自然排序完全相同。其消去树的结构和高度也必然相同，$H_{\\mathrm{md}} = n$。\n\n**(c) 嵌套剖分排序：$\\pi_{\\mathrm{nd}}$**\n\n对于 $n=2^k-1$，嵌套剖分通过递归地寻找中心顶点作为分隔符来剖分图。在第1层，中心顶点 $2^{k-1}$ 作为分隔符，将图分为两个大小为 $2^{k-1}-1$ 的子图。在第2层，每个子图再次被其中点分隔。这个过程持续 $k-1$ 步。排序规则是“左子路径，右子路径，分隔符最后”。\n消去树的结构直接反映了这种递归剖分。一个子图中的所有顶点在消去树中都将是其分隔符顶点的后代。因此，叶节点（来自最小的子问题）的父节点是第一轮剖分的分隔符，这些分隔符的父节点是第二轮剖分的分隔符，依此类推，直到树的根，即最顶层的分隔符。\n消去树的高度等于递归的层数。对于大小为 $n=2^k-1$ 的问题，共有 $k$ 个层级（从叶节点到根，对应 $k-1$ 次剖分）。因此，树的高度 $H_{\\mathrm{nd}} = k$。由 $n=2^k-1$ 可得 $k = \\log_2(n+1)$。\n\n**计算 $n=15$ 的情况**\n\n我们现在将这些通式应用于 $n=15$ 的情况。\n对于 $n=15$，我们有 $15 = 2^4 - 1$，所以 $k=4$。\n\n- **自然排序的高度**：\n  根据公式，$H_{\\mathrm{nat}} = n = 15$。\n\n- **嵌套剖分排序的高度**：\n  根据公式，$H_{\\mathrm{nd}} = k = \\log_2(n+1) = \\log_2(15+1) = \\log_2(16) = 4$。\n\n- **计算差值**：\n  所求的量为 $H_{\\mathrm{nat}} - H_{\\mathrm{nd}}$。\n  $$\n  H_{\\mathrm{nat}} - H_{\\mathrm{nd}} = 15 - 4 = 11\n  $$", "answer": "$$\n\\boxed{11}\n$$", "id": "3574498"}, {"introduction": "最后的实践练习将连接纯粹的图论与数值计算的现实。这个编程挑战要求你实现重排序算法，并模拟一个对称不定分解过程，其中数值稳定性需要阈值主元选择。通过建模预计算的排序与动态主元决策之间的相互作用，你将发现“最佳”算法往往是在最小化填充和维持数值精度之间复杂权衡的结果。[@problem_id:3574496]", "problem": "考虑对称稀疏线性系统及其使用基于阈值的对称不定 $L D L^{T}$ 分解的因式分解。消元对非零模式的组合效应可以在系数矩阵的邻接图上建模。设无向图为 $G = (V, E)$，其中 $V = \\{0, 1, \\dots, n-1\\}$ 对应于变量，当且仅当矩阵在位置 $(i,j)$ 和 $(j,i)$（其中 $i \\neq j$）处有结构上非零的元素时，存在一条边 $\\{i,j\\} \\in E$。对于给定的消元顺序 $\\pi$ 和当前的剩余顶点集 $R \\subseteq V$，通过一个 $1 \\times 1$ 主元消去顶点 $i \\in R$ 会添加填充边，以使其当前邻域 $N(i) \\cap R$ 成为一个团。在 $\\{i,k\\} \\subseteq R$ 上消去一个 $2 \\times 2$ 主元会添加填充边，以使 $\\left(\\left(N(i) \\cup N(k)\\right) \\cap R\\right) \\setminus \\{i,k\\}$ 成为一个团。填充计数是在这些团补全过程中添加的、先前不存在的新边的数量。\n\n我们将比较两种重排序策略：\n- 近似最小度 (AMD)，此处通过演化图上的精确最小度启发式算法进行建模：在每一步中，选择一个当前度最小的顶点（通过最小索引进行确定性平局打破），执行符号填充以将其邻居连接成一个团，然后移除该顶点。\n- 嵌套剖分 (ND)，此处通过在二维网格图上进行递归几何二分来建模：在每次递归中，如果网格的宽度大于其高度，则选择中间列作为分隔集；如果高度更大，则选择中间行作为分隔集。对两个子域进行递归，并将分隔集顶点放在两个子域的排序之后。当子问题的顶点数最多为 $4$ 个时，停止递归，此时使用自然的行主序。\n\n为了模拟主元阈值的影响，引入一个对角线幅值向量 $d \\in \\mathbb{R}^{n}$（其元素为 $|d_i|$）和一个阈值参数 $\\tau \\in [0, 1]$。我们使用以下稳定性代理：在固定排序 $\\pi$ 中处理顶点 $i$ 时，如果 $|d_i| \\ge \\tau$，则接受在 $i$ 上的 $1 \\times 1$ 主元；否则，在顶点对 $\\{i, k\\}$ 上使用 $2 \\times 2$ 主元，其中 $k$ 是 $i$ 的当前邻居中具有最大当前度的顶点（通过最小索引打破平局）。如果 $i$ 没有当前邻居，则使用 $1 \\times 1$ 主元。在这两种情况下，计算相应团补全所产生的填充边，并更新图。持续此过程，直到所有顶点都被消去。这个符号方案捕捉了较大的 $\\tau$ 值如何增加 $2 \\times 2$ 主元的发生率，从而通常通过更大的团补全来增加填充。\n\n从这些核心的图论定义和 $L D L^{T}$ 分解结构出发，实现一个程序，该程序：\n- 构建一个大小为 $n_x \\times n_y$ 的二维 $5$ 点模板网格图，使得每个内部顶点都与其上、下、左、右的网格邻居有边相连。\n- 构造 AMD 排序（通过上文定义的精确最小度启发式算法）和 ND 排序（通过上文定义的递归二分法）。\n- 对于给定的 $\\tau$ 和对角线幅值 $d$，使用上述阈值规则模拟符号消元，计算每种排序的总填充边数。\n\n您的任务是研究是否存在这样的参数范围：即使 ND 构造了更大的显式分隔集，AMD 产生的填充仍然比 ND 少。使用以下测试套件，它涵盖了一个基准情况、一个对分隔集加权的不利情况以及一个混合情况：\n- 测试用例 1（基准，全为 $1 \\times 1$）：$n_x = 8$，$n_y = 8$，$\\tau = 0.0$，且对于所有 $i \\in V$，$|d_i| = 1.0$。\n- 测试用例 2（高阈值下对ND不利的情况）：$n_x = 16$，$n_y = 16$，$\\tau = 0.99$。令 $S \\subset V$ 为在此网格上的 ND 构建中任何递归级别出现的所有分隔集顶点的并集。对于 $i \\in S$ 设置 $|d_i| = 0.1$，对于 $i \\notin S$ 设置 $|d_i| = 1.0$。\n- 测试用例 3（混合，随机对角线）：$n_x = 12$，$n_y = 8$，$\\tau = 0.7$，且 $|d_i|$ 从 $[0,1]$ 上的均匀分布中独立抽取，使用固定的随机种子 $42$ 以确保确定性。\n\n对于每个测试用例，计算两个整数：AMD 下的总填充数和 ND 下的总填充数。然后为每个测试用例生成一个整数结果，定义如下：\n- 如果该测试用例中 AMD 的填充数严格小于 ND 的填充数，则输出 $1$。\n- 否则输出 $0$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含三个结果，格式为方括号内的逗号分隔列表（例如 `[1,0,1]`）。\n\n不涉及物理单位；所有输出均为纯整数。\n\n您的实现必须是通用的，并且必须如上所述，从图的第一性原理计算排序和符号填充效应。除了您在程序中直接实现的功能外，请勿使用任何外部的重排序或分解黑盒例程。代码必须是自包含的、确定性的，并且不得需要任何用户输入或外部文件。", "solution": "该问题的核心是实现一个符号分解模拟器，以比较在考虑数值稳定性（通过阈值主元选择建模）时，AMD 和 ND 两种重排序策略产生的填充量。解决方案遵循问题描述，通过实现以下几个关键模块来完成：\n\n1.  **网格图生成**：首先，实现一个函数用于创建一个 $n_x \\times n_y$ 的二维网格图。图中每个内部顶点都与其上、下、左、右四个邻居相连。顶点按行主序进行索引。该图的数据结构是一个邻接表（字典嵌套集合），便于高效地查找和修改。\n\n2.  **AMD 排序**：其次，实现一个函数以计算问题中定义的精确最小度启发式算法排序。它在一个循环中迭代，每一步都从*当前演化图*中寻找度数最小的顶点。如果存在多个度数最小的顶点，则选择索引最小的那个作为决胜规则。选中顶点后，将其加入排序列表，并模拟消元过程：将其所有邻居连接成一个团（clique），并更新受影响顶点的度数。然后，从图中移除该顶点。此过程重复进行，直到所有顶点都被排序。\n\n3.  **ND 排序**：接着，实现一个函数通过递归几何二分法生成嵌套剖分排序。一个递归辅助函数负责处理顶点子集。它首先确定子集的几何边界，然后比较其宽度和高度。如果宽度大于高度，则选择中间的垂直列作为分隔集；反之，则选择中间的水平行。然后，算法对由分隔集划分出的两个子域进行递归调用。最终的排序由第一个子域的排序、第二个子域的排序和分隔集顶点的排序串联而成，其中分隔集顶点排在最后。当子问题规模小于或等于4个顶点时，递归停止，并对这些顶点使用自然排序。对于测试用例2，此函数还用于收集所有在递归过程中被选为分隔集的顶点。\n\n4.  **符号分解模拟**：分析的核心是一个模拟函数，它接收一个固定的排序（来自 AMD 或 ND）、初始图结构、对角线幅值向量 $d$ 和主元阈值 $\\tau$。该函数按给定顺序遍历顶点，模拟消元过程：\n    -   对于当前顶点 $i$，如果其对角线幅值 $|d_i| \\ge \\tau$ 或它没有剩余的邻居，则选择一个 $1 \\times 1$ 主元。这会使其所有*当前*邻居形成一个团。\n    -   否则，选择一个 $2 \\times 2$ 主元。主元对为 $\\{i, k\\}$，其中 $k$ 是 $i$ 的当前邻居中度数最大的那个（若有多个，选索引最小的）。这会使 $i$ 和 $k$ 的邻居的并集（除去 $i, k$ 本身）形成一个团。\n    -   在每次团补全过程中，新增加的边被计数为填充。被消去的顶点（$1 \\times 1$ 或 $2 \\times 2$ 主元）从剩余顶点集中移除，然后继续处理排序中的下一个顶点。\n\n对于每个测试用例，程序首先根据要求构建网格图和对角线幅值向量 $d$。然后，分别计算 AMD 和 ND 排序。最后，将两种排序及相应参数输入符号分解模拟器，计算各自产生的总填充量。比较两个填充数，如果 AMD 的填充数严格小于 ND，则该测试用例的结果为 $1$，否则为 $0$。所有三个测试用例的结果被收集并以指定格式 `[result1,result2,result3]` 输出。通过运行此确定性程序，我们得到每个测试用例的结果。", "answer": "$$\\boxed{[1,1,1]}$$", "id": "3574496"}]}