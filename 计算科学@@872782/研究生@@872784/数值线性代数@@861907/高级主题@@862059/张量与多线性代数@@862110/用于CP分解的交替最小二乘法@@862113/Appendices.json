{"hands_on_practices": [{"introduction": "为了真正理解CP分解，从基础入手至关重要。第一个练习提供了一个上手实践的机会，让您能够直接从给定的因子矩阵构建一个小张量。通过执行这个计算[@problem_id:3533244]，您将巩固对因子向量的外积如何构建最终张量的理解，并熟悉CP模型的切片式表示法。", "problem": "考虑一个三维张量的CANonical DECOMPosition/PARAFAC (CP)模型，及其在交替最小二乘法（ALS）中的应用。在ALS中，我们固定两个因子矩阵，并为剩余的因子矩阵求解一个最小二乘子问题。使用一个大小为 $I \\times J \\times K$ 的张量的具体秩-$R$ CP表示，该表示由 $R$ 个秩-1外积之和给出。设 $I=J=K=2$ 且 $R=2$。指定因子矩阵为\n$$\nA=\\begin{pmatrix}\n1  2\\\\\n3  1\n\\end{pmatrix},\\quad\nB=\\begin{pmatrix}\n0  1\\\\\n2  -1\n\\end{pmatrix},\\quad\nC=\\begin{pmatrix}\n1  0\\\\\n1  2\n\\end{pmatrix},\n$$\n其中每一列对应一个秩-1分量。使用CP定义，重构的张量 $\\mathcal{X}\\in\\mathbb{R}^{2\\times 2\\times 2}$ 的元素 $x_{i j k}$ 从这些因子中获得。\n\n任务：\n- 从定义CP的秩-1外积结构出发，根据 $A$、$B$ 和 $C$ 推导出元素 $x_{i j k}$ 的公式，并为指定的 $A$、$B$ 和 $C$ 计算重构张量 $\\mathcal{X}$ 的所有八个元素。\n- 将每个额面切片 $\\mathcal{X}(:,:,k)$ 表示为一个关于 $A$、$B$ 以及由 $C$ 的第 $k$ 行构成的对角矩阵的矩阵，并验证与计算所得元素的一致性。\n- 计算重构张量的弗罗贝尼乌斯范数 $\\|\\mathcal{X}\\|_{F}$。如果您决定进行近似计算，请将答案四舍五入至四位有效数字；否则，请提供精确值。\n\n您最终报告的量必须是弗罗贝尼乌斯范数 $\\|\\mathcal{X}\\|_{F}$，形式为单个实数或单个闭式解析表达式。", "solution": "该问题是有效的，因为它科学地基于多重线性代数的原理，特别是CANDECOMP/PARAFAC (CP)分解，并且问题设定良好，为得到唯一解提供了所有必要信息。\n\n一个秩为$R$的三维张量 $\\mathcal{X} \\in \\mathbb{R}^{I \\times J \\times K}$ 的CANDECOMP/PARAFAC (CP)分解由$R$个秩-1张量的和给出。每个秩-1张量是三个向量的外积。设因子矩阵为 $A \\in \\mathbb{R}^{I \\times R}$，$B \\in \\mathbb{R}^{J \\times R}$ 和 $C \\in \\mathbb{R}^{K \\times R}$。设这些矩阵的列向量为 $\\mathbf{a}_r$, $\\mathbf{b}_r$ 和 $\\mathbf{c}_r$，其中 $r=1, \\dots, R$。张量 $\\mathcal{X}$ 则表示为：\n$$\n\\mathcal{X} = \\sum_{r=1}^{R} \\mathbf{a}_r \\circ \\mathbf{b}_r \\circ \\mathbf{c}_r\n$$\n其中 $\\circ$ 表示外积。\n\n第一个任务是推导张量 $\\mathcal{X}$ 的元素 $x_{ijk}$ 的公式。根据外积的定义，张量 $\\mathbf{a}_r \\circ \\mathbf{b}_r \\circ \\mathbf{c}_r$ 的一个元素 $(i,j,k)$ 由相应向量元素的乘积给出，即 $(a_r)_i (b_r)_j (c_r)_k$。在矩阵表示法中，这些是 $a_{ir}$, $b_{jr}$ 和 $c_{kr}$。因此，张量 $\\mathcal{X}$ 的元素 $x_{ijk}$是通过对$R$个分量求和得到的：\n$$\nx_{ijk} = \\sum_{r=1}^{R} a_{ir} b_{jr} c_{kr}\n$$\n在本问题中，维度为 $I=J=K=2$，秩为 $R=2$。给定的因子矩阵是：\n$$\nA=\\begin{pmatrix} 1  2\\\\ 3  1 \\end{pmatrix},\\quad\nB=\\begin{pmatrix} 0  1\\\\ 2  -1 \\end{pmatrix},\\quad\nC=\\begin{pmatrix} 1  0\\\\ 1  2 \\end{pmatrix}\n$$\n重构张量 $\\mathcal{X} \\in \\mathbb{R}^{2 \\times 2 \\times 2}$ 的元素使用 $R=2$ 的公式计算：\n$$\nx_{ijk} = a_{i1}b_{j1}c_{k1} + a_{i2}b_{j2}c_{k2}\n$$\n我们计算所有8个元素，并将它们组织成两个额面切片，$\\mathcal{X}(:,:,1)$ 和 $\\mathcal{X}(:,:,2)$。\n\n对于第一个额面切片 ($k=1$):\n$C$ 的第一行是 $(c_{11}, c_{12}) = (1, 0)$。\n$x_{111} = a_{11}b_{11}c_{11} + a_{12}b_{12}c_{12} = (1)(0)(1) + (2)(1)(0) = 0$\n$x_{121} = a_{11}b_{21}c_{11} + a_{12}b_{22}c_{12} = (1)(2)(1) + (2)(-1)(0) = 2$\n$x_{211} = a_{21}b_{11}c_{11} + a_{22}b_{12}c_{12} = (3)(0)(1) + (1)(1)(0) = 0$\n$x_{221} = a_{21}b_{21}c_{11} + a_{22}b_{22}c_{12} = (3)(2)(1) + (1)(-1)(0) = 6$\n所以，第一个额面切片是矩阵 $\\mathcal{X}(:,:,1) = \\begin{pmatrix} 0  2 \\\\ 0  6 \\end{pmatrix}$。\n\n对于第二个额面切片 ($k=2$):\n$C$ 的第二行是 $(c_{21}, c_{22}) = (1, 2)$。\n$x_{112} = a_{11}b_{11}c_{21} + a_{12}b_{12}c_{22} = (1)(0)(1) + (2)(1)(2) = 4$\n$x_{122} = a_{11}b_{21}c_{21} + a_{12}b_{22}c_{22} = (1)(2)(1) + (2)(-1)(2) = 2 - 4 = -2$\n$x_{212} = a_{21}b_{11}c_{21} + a_{22}b_{12}c_{22} = (3)(0)(1) + (1)(1)(2) = 2$\n$x_{222} = a_{21}b_{21}c_{21} + a_{22}b_{22}c_{22} = (3)(2)(1) + (1)(-1)(2) = 6 - 2 = 4$\n所以，第二个额面切片是矩阵 $\\mathcal{X}(:,:,2) = \\begin{pmatrix} 4  -2 \\\\ 2  4 \\end{pmatrix}$。\n\n第二个任务是将每个额面切片 $\\mathcal{X}(:,:,k)$（我们将其表示为矩阵 $X_{(k)}$）表示为关于 $A$、$B$ 以及由 $C$ 的第 $k$ 行构成的对角矩阵的表达式。第 $k$ 个额面切片的公式为 $X_{(k)} = A D_k(C) B^T$，其中 $D_k(C)$ 是一个对角矩阵，其对角线元素是 $C$ 的第 $k$ 行的元素，即 $(D_k(C))_{rr} = c_{kr}$。\n让我们通过计算 $A D_k(C) B^T$ 的第 $(i,j)$ 个元素来验证这个公式：\n$$\n(A D_k(C) B^T)_{ij} = \\sum_{r=1}^{R} (A D_k(C))_{ir} (B^T)_{rj} = \\sum_{r=1}^{R} \\left( \\sum_{s=1}^{R} a_{is} (D_k(C))_{sr} \\right) b_{jr}\n$$\n由于 $D_k(C)$ 是对角矩阵，$(D_k(C))_{sr} = c_{kr}\\delta_{sr}$，其中 $\\delta_{sr}$ 是克罗内克δ。\n$$\n(A D_k(C) B^T)_{ij} = \\sum_{r=1}^{R} \\left( \\sum_{s=1}^{R} a_{is} c_{ks}\\delta_{sr} \\right) b_{jr} = \\sum_{r=1}^{R} a_{ir} c_{kr} b_{jr} = \\sum_{r=1}^{R} a_{ir}b_{jr}c_{kr} = x_{ijk}\n$$\n这证实了切片公式。现在我们对给定的矩阵进行验证。\n\n对于 $k=1$，$C$ 的第一行是 $(1,0)$，所以 $D_1(C) = \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix}$。\n$$\nX_{(1)} = A D_1(C) B^T = \\begin{pmatrix} 1  2 \\\\ 3  1 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} 0  1 \\\\ 2  -1 \\end{pmatrix}^T\n= \\begin{pmatrix} 1  0 \\\\ 3  0 \\end{pmatrix} \\begin{pmatrix} 0  2 \\\\ 1  -1 \\end{pmatrix}\n= \\begin{pmatrix} 0  2 \\\\ 0  6 \\end{pmatrix}\n$$\n这与我们计算的 $\\mathcal{X}(:,:,1)$ 相符。\n\n对于 $k=2$，$C$ 的第二行是 $(1,2)$，所以 $D_2(C) = \\begin{pmatrix} 1  0 \\\\ 0  2 \\end{pmatrix}$。\n$$\nX_{(2)} = A D_2(C) B^T = \\begin{pmatrix} 1  2 \\\\ 3  1 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  2 \\end{pmatrix} \\begin{pmatrix} 0  1 \\\\ 2  -1 \\end{pmatrix}^T\n= \\begin{pmatrix} 1  4 \\\\ 3  2 \\end{pmatrix} \\begin{pmatrix} 0  2 \\\\ 1  -1 \\end{pmatrix}\n= \\begin{pmatrix} 4  2-4 \\\\ 2  6-2 \\end{pmatrix}\n= \\begin{pmatrix} 4  -2 \\\\ 2  4 \\end{pmatrix}\n$$\n这与我们计算的 $\\mathcal{X}(:,:,2)$ 相符。\n\n第三个任务是计算重构张量的弗罗贝尼乌斯范数 $\\|\\mathcal{X}\\|_{F}$。弗罗贝尼乌斯范数的平方是其所有元素平方的和：\n$$\n\\|\\mathcal{X}\\|_{F}^2 = \\sum_{i=1}^{I} \\sum_{j=1}^{J} \\sum_{k=1}^{K} x_{ijk}^2\n$$\n使用我们已计算出的元素：\n$$\n\\|\\mathcal{X}\\|_{F}^2 = \\underbrace{(0^2 + 2^2 + 0^2 + 6^2)}_{\\text{切片 1}} + \\underbrace{(4^2 + (-2)^2 + 2^2 + 4^2)}_{\\text{切片 2}}\n$$\n$$\n\\|\\mathcal{X}\\|_{F}^2 = (0 + 4 + 0 + 36) + (16 + 4 + 4 + 16)\n$$\n$$\n\\|\\mathcal{X}\\|_{F}^2 = 40 + 40 = 80\n$$\n弗罗贝尼乌斯范数是该值的平方根：\n$$\n\\|\\mathcal{X}\\|_{F} = \\sqrt{80} = \\sqrt{16 \\times 5} = 4\\sqrt{5}\n$$\n问题要求提供精确值或精确到四位有效数字的近似值。精确值为 $4\\sqrt{5}$。", "answer": "$$\n\\boxed{4\\sqrt{5}}\n$$", "id": "3533244"}, {"introduction": "交替最小二乘（ALS）算法通过迭代求解一系列线性最小二乘问题。这些子问题的数值稳定性对算法的准确性和收敛性至关重要。本练习[@problem_id:3533190]要求您比较两种求解这些子问题的标准方法，量化潜在的精度损失，并强调在数值算法中实现选择的重要性。", "problem": "考虑典范多项式（CP）分解中的单次交替最小二乘（ALS）更新。为更新因子矩阵 $A \\in \\mathbb{R}^{I_{A} \\times R}$，需要逐行求解超定最小二乘问题。这些问题具有一个公共的设计矩阵 $Z \\in \\mathbb{R}^{(I_{B} I_{C}) \\times R}$，该矩阵由 Khatri–Rao 积 $Z = C \\odot B$ 给出，其中 $B \\in \\mathbb{R}^{I_{B} \\times R}$ 且 $C \\in \\mathbb{R}^{I_{C} \\times R}$。右端项通过矩阵化张量与 Khatri–Rao 积的乘积（MTTKRP）得到。假设 $Z$ 是满列秩的，并且计算在浮点运算下进行，单位舍入误差为 $u$。使用两种经典方法：\n\n- 正规方程组与 Cholesky 分解：构造 $G = Z^{\\top} Z$ 并通过 Cholesky 分解求解 $G x = Z^{\\top} b$。\n- 正交-三角（QR）分解：计算一个瘦 QR 分解 $Z = Q R$（其中 $Q^{\\top} Q = I$）并求解 $R x = Q^{\\top} b$。\n\n从 $2$-范数条件数 $\\kappa_{2}(Z) = \\sigma_{\\max}(Z)/\\sigma_{\\min}(Z)$ 的奇异值分解定义、$Z$ 和 $Z^{\\top} Z$ 的奇异值之间的关系，以及 Cholesky 和 QR 分解的标准后向稳定性性质出发，比较这两种方法在求解设计矩阵为 $Z = C \\odot B$ 的超定最小二乘问题时的前向精度。在你的比较中，仅使用以下基本事实：(i) 谱范数是次乘性的，(ii) $Z^{\\top} Z$ 的奇异值是 $Z$ 的奇异值的平方，(iii) 满秩矩阵的 QR 分解是后向稳定的，以及 (iv) 对称正定矩阵的 Cholesky 分解是后向稳定的。你还可以使用以下事实：Khatri–Rao 积满足 $Z = C \\odot B$，并且是 Kronecker 积 $C \\otimes B$ 的一个列子矩阵，Kronecker 积的范数恒等式是已知的。\n\n用 $u$ 和 $\\kappa_{2}(Z)$ 来量化精度差距，然后在以下具体场景中进行评估：假设 $\\kappa_{2}(B) = 10^{4}$，$\\kappa_{2}(C) = 10^{3}$，并使用 IEEE 双精度浮点数，其 $u \\approx 10^{-16}$。选择所有正确的陈述。\n\nA. 在浮点运算中，正规方程组加 Cholesky 分解的路径产生的最小二乘解的前向相对误差约为 $u \\,\\kappa_{2}(Z)^{2}$（对每个右端项而言），而正交-三角（QR）路径产生的前向相对误差约为 $u \\,\\kappa_{2}(Z)$。因此，相对于 QR，正规方程组大约额外损失 $\\log_{10}\\!\\big(\\kappa_{2}(Z)\\big)$ 个正确的十进制数字。对于给定的数值，可以界定 $\\kappa_{2}(Z) \\le \\kappa_{2}(C)\\,\\kappa_{2}(B) = 10^{7}$，因此误差量级近似为 $10^{-2}$（正规方程组）对 $10^{-9}$（QR），即正规方程组大约额外损失 7 个数字的精度。\n\nB. 因为 $(C \\odot B)^{\\top} (C \\odot B) = (C^{\\top} C) \\circ (B^{\\top} B)$ 是一个 Hadamard 积，所以正规方程组的条件数至多为 $\\max\\{\\kappa_{2}(B)^{2}, \\kappa_{2}(C)^{2}\\}$，这意味着相对于 QR 没有渐进的精度损失。\n\nC. 如果 $B$ 和 $C$ 的列被缩放到单位范数，那么无论列相关性如何，$\\kappa_{2}(C \\odot B) = 1$，因此两种方法的精度在常数因子内是可比的。\n\nD. 当 $Z$ 是一个非常高且瘦的矩阵，即 $(I_{B} I_{C}) \\gg R$ 时，两种方法实现的前向相对误差都约为 $u$，且与 $\\kappa_{2}(Z)$ 无关，因此在这种情况下它们之间没有显著的精度差距。", "solution": "用户要求比较用于求解典范多项式（CP）分解的交替最小二乘（ALS）算法中出现的超定最小二乘问题的两种方法的前向精度。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **问题背景**：CP 分解中因子矩阵 $A \\in \\mathbb{R}^{I_{A} \\times R}$ 的单次 ALS 更新。\n- **任务**：逐行求解超定最小二乘问题 $\\min_{x} \\|Zx-b\\|_{2}$。\n- **设计矩阵**：$Z \\in \\mathbb{R}^{(I_{B} I_{C}) \\times R}$，其中 $Z = C \\odot B$ (Khatri-Rao 积)。\n- **因子矩阵**：$B \\in \\mathbb{R}^{I_{B} \\times R}$ 和 $C \\in \\mathbb{R}^{I_{C} \\times R}$。\n- **右端项**：$b$ 来自矩阵化张量与 Khatri–Rao 积的乘积 (MTTKRP)。\n- **假设**：$Z$ 具有满列秩。计算在浮点运算下进行，单位舍入误差为 $u$。\n- **方法 1 (正规方程组)**：构造 $G = Z^{\\top} Z$ 并使用 Cholesky 分解求解 $Gx = Z^{\\top} b$。\n- **方法 2 (QR 分解)**：计算一个瘦 QR 分解 $Z = QR$ 并求解 $Rx = Q^{\\top}b$。\n- **基本事实**：(i) 谱范数是次乘性的。(ii) $Z^{\\top} Z$ 的奇异值是 $Z$ 的奇异值的平方。(iii) 满秩矩阵的 QR 分解是后向稳定的。(iv) 对称正定矩阵的 Cholesky 分解是后向稳定的。\n- **附加信息**：可以使用 $Z = C \\odot B$ 是 $C \\otimes B$ 的列子矩阵这一事实，并使用 Kronecker 积的已知范数恒等式。\n- **数值场景**：$\\kappa_{2}(B) = 10^{4}$，$\\kappa_{2}(C) = 10^{3}$，$u \\approx 10^{-16}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述科学合理、定义明确且客观。它提出了数值线性代数中一个关于求解最小二乘问题算法稳定性的标准问题。CP-ALS 的背景是恰当的，因为这些子问题是该算法的核心组成部分。给出的事实是矩阵分析和数值分析中的标准结果。假设清晰且足以进行所要求的比较。该问题没有违反任何无效性标准。\n\n**步骤 3：结论和行动**\n问题有效。我将继续进行详细的推导和评估。\n\n### 推导和求解\n\n问题的核心是比较通过正规方程组和 QR 分解计算出的最小二乘解的前向误差。设 $\\min_{x} \\|Zx - b\\|_{2}$ 的精确解为 $x_{LS} = (Z^{\\top}Z)^{-1}Z^{\\top}b$。对于一个计算解 $\\hat{x}$，其相对前向误差由 $\\frac{\\|\\hat{x} - x_{LS}\\|_{2}}{\\|x_{LS}\\|_{2}}$ 给出。\n\n**1. 正规方程组（NE）方法分析**\n\n该方法包括两个主要步骤：\n1.  构造正规方程矩阵 $G = Z^{\\top}Z$ 和向量 $Z^{\\top}b$。\n2.  使用 Cholesky 分解求解线性系统 $Gx = Z^{\\top}b$。\n\n数值不稳定性的主要来源是构造 $G = Z^{\\top}Z$ 的过程，这会显式地将问题的条件数平方。\n\n-   设 $Z$ 的奇异值为 $\\sigma_{1} \\ge \\sigma_{2} \\ge \\dots \\ge \\sigma_{R} > 0$。\n-   $Z$ 的 $2$-范数条件数为 $\\kappa_{2}(Z) = \\frac{\\sigma_{\\max}(Z)}{\\sigma_{\\min}(Z)} = \\frac{\\sigma_{1}}{\\sigma_{R}}$。\n-   根据给定的事实 (ii)，$G = Z^{\\top}Z$ 的奇异值是 $Z$ 奇异值的平方。对称正定矩阵 $G$ 的特征值就是其奇异值，因此 $\\lambda_{i}(G) = \\sigma_{i}(Z)^{2}$。\n-   因此，$G$ 的条件数为：\n    $$ \\kappa_{2}(G) = \\frac{\\lambda_{\\max}(G)}{\\lambda_{\\min}(G)} = \\frac{\\sigma_{\\max}(Z)^{2}}{\\sigma_{\\min}(Z)^{2}} = \\left(\\frac{\\sigma_{\\max}(Z)}{\\sigma_{\\min}(Z)}\\right)^{2} = \\kappa_{2}(Z)^{2} $$\n-   用于求解 $Gx = Z^{\\top}b$ 的 Cholesky 分解是后向稳定的（事实 (iv)）。标准的求解线性系统 $Ax=b$ 的前向误差分析表明，相对前向误差受一个与矩阵条件数成正比的量所界定，即 $\\frac{\\|\\delta x\\|_{2}}{\\|x\\|_{2}} \\lesssim u \\kappa_{2}(A)$。将此应用于系统 $Gx=Z^{\\top}b$，仅求解该系统所产生的误差约为 $u \\kappa_{2}(G) = u \\kappa_{2}(Z)^{2}$。这甚至还没有考虑构造 $G$ 和 $Z^{\\top}b$ 时的误差。完整的分析证实，NE 方法的前向误差主要由该项决定。\n-   因此，正规方程组方法的相对前向误差近似为 $\\mathcal{O}(u \\, \\kappa_{2}(Z)^{2})$。\n\n**2. QR 分解方法分析**\n\n此方法避免了构造 $Z^{\\top}Z$。\n1.  计算一个瘦 QR 分解 $Z = QR$，其中 $Q \\in \\mathbb{R}^{(I_{B} I_{C}) \\times R}$ 具有标准正交列（$Q^{\\top}Q=I_{R}$），而 $R \\in \\mathbb{R}^{R \\times R}$ 是一个上三角矩阵。\n2.  最小二乘问题 $\\min \\|Zx-b\\|_{2}$ 被转换为 $\\min \\|QRx-b\\|_{2}$。由于 $Q$ 是一个正交变换（保持 $2$-范数），这等价于 $\\min \\|Rx - Q^{\\top}b\\|_{2}$。\n3.  由于 $Z$ 具有满列秩，$R$ 是可逆的，通过求解三角系统 $Rx = Q^{\\top}b$ 找到解。\n\n-   满秩矩阵的 QR 分解是后向稳定的（事实 (iii)）。标准分析表明，计算出的解 $\\hat{x}_{QR}$ 是一个涉及 $(Z+\\delta Z)$ 和 $(b+\\delta b)$ 的轻微扰动问题的精确最小二乘解。\n-   QR 方法得到的前向误差界近似为 $\\mathcal{O}(u \\, \\kappa_{2}(Z))$，这里忽略了依赖于残差范数的项，尽管这些项也可能很重要。对于矩阵条件敏感性的一般比较，这是关键项。\n\n**3. 比较和量化**\n-   **正规方程组误差**：$\\approx C_{NE} \\, u \\, \\kappa_{2}(Z)^{2}$\n-   **QR 分解误差**：$\\approx C_{QR} \\, u \\, \\kappa_{2}(Z)$\n-   因子 $\\kappa_{2}(Z)$ 代表了精度差距。如果 $\\kappa_{2}(Z)$ 很大，正规方程组方法的精度会显著降低。\n-   一个相对误差为 $\\epsilon$ 的结果中正确的十进制数字位数约为 $-\\log_{10}(\\epsilon)$。\n-   与 QR 相比，NE 额外损失的数字位数 = $(-\\log_{10}(\\text{Error}_{QR})) - (-\\log_{10}(\\text{Error}_{NE})) \\approx (-\\log_{10}(u \\, \\kappa_{2}(Z))) - (-\\log_{10}(u \\, \\kappa_{2}(Z)^{2})) = \\log_{10}(u \\, \\kappa_{2}(Z)^{2}) - \\log_{10}(u \\, \\kappa_{2}(Z)) = \\log_{10}\\left(\\frac{u \\, \\kappa_{2}(Z)^{2}}{u \\, \\kappa_{2}(Z)}\\right) = \\log_{10}(\\kappa_{2}(Z))$。\n\n**4. 具体场景评估**\n-   给定：$\\kappa_{2}(B) = 10^{4}$，$\\kappa_{2}(C) = 10^{3}$，$u \\approx 10^{-16}$。\n-   问题允许使用 $Z = C \\odot B$ 与 Kronecker 积 $C \\otimes B$ 相关的性质。关于 Khatri-Rao 积的一个标准结果是不等式 $\\kappa_{2}(C \\odot B) \\le \\kappa_{2}(C) \\kappa_{2}(B)$。这为 $Z$ 的条件数提供了一个上界。\n-   使用此界限：$\\kappa_{2}(Z) \\le \\kappa_{2}(C)\\kappa_{2}(B) = 10^{3} \\times 10^{4} = 10^{7}$。\n-   我们用这个值进行估算：$\\kappa_{2}(Z) \\approx 10^{7}$。\n-   **NE 误差估计**：$u \\, \\kappa_{2}(Z)^{2} \\approx 10^{-16} \\times (10^{7})^{2} = 10^{-16} \\times 10^{14} = 10^{-2}$。\n-   **QR 误差估计**：$u \\, \\kappa_{2}(Z) \\approx 10^{-16} \\times 10^{7} = 10^{-9}$。\n-   **NE 额外损失的数字位数**：$\\log_{10}(\\kappa_{2}(Z)) \\approx \\log_{10}(10^{7}) = 7$。\n\n### 逐项分析\n\n**A. 在浮点运算中，正规方程组加 Cholesky 分解的路径产生的最小二乘解的前向相对误差约为 $u \\,\\kappa_{2}(Z)^{2}$（对每个右端项而言），而正交-三角（QR）路径产生的前向相对误差约为 $u \\,\\kappa_{2}(Z)$。因此，相对于 QR，正规方程组大约额外损失 $\\log_{10}\\!\\big(\\kappa_{2}(Z)\\big)$ 个正确的十进制数字。对于给定的数值，可以界定 $\\kappa_{2}(Z) \\le \\kappa_{2}(C)\\,\\kappa_{2}(B) = 10^{7}$，因此误差量级近似为 $10^{-2}$（正规方程组）对 $10^{-9}$（QR），即正规方程组大约额外损失 7 个数字的精度。**\n这个陈述与上面的推导完全吻合。它正确地指出了两种方法前向误差的量级，正确地量化了精度的数字损失，正确地应用了 Khatri-Rao 积条件数的标准不等式，并为给定场景正确地计算了估计误差和损失的数字位数。\n**结论：正确**\n\n**B. 因为 $(C \\odot B)^{\\top} (C \\odot B) = (C^{\\top} C) \\circ (B^{\\top} B)$ 是一个 Hadamard 积，所以正规方程组的条件数至多为 $\\max\\{\\kappa_{2}(B)^{2}, \\kappa_{2}(C)^{2}\\}$，这意味着相对于 QR 没有渐进的精度损失。**\n恒等式 $(C \\odot B)^{\\top} (C \\odot B) = (C^{\\top} C) \\circ (B^{\\top} B)$ 是正确的。然而，后续关于条件数的断言，$\\kappa_{2}((C^{\\top} C) \\circ (B^{\\top} B)) \\le \\max\\{\\kappa_{2}(C^{\\top} C), \\kappa_{2}(B^{\\top} B)\\}$，是不正确的。矩阵分析中没有通用定理能为两个半正定矩阵的 Hadamard 积的条件数提供如此紧密的界。Hadamard 积的条件数通常不受各个条件数的最大值限制。实际上，标准界限是将其与条件数的乘积联系起来，而不是最大值。因此，“没有渐进精度损失”的结论是基于一个错误的前提。\n**结论：不正确**\n\n**C. 如果 $B$ 和 $C$ 的列被缩放到单位范数，那么无论列相关性如何，$\\kappa_{2}(C \\odot B) = 1$，因此两种方法的精度在常数因子内是可比的。**\n如果 $B$ 和 $C$ 的列 $b_r$ 和 $c_r$ 具有单位范数，那么 $Z = C \\odot B$ 的列（即 $z_r = c_r \\otimes b_r$）也具有单位范数，因为 $\\|z_r\\|_2 = \\|c_r \\otimes b_r\\|_2 = \\|c_r\\|_2 \\|b_r\\|_2 = 1 \\times 1 = 1$。然而，要使 $\\kappa_2(Z)$ 为 $1$，$Z$ 矩阵必须有标准正交列，即 $Z^{\\top}Z = I$。$Z^{\\top}Z$ 的第 $(i,j)$ 个元素是 $(c_i^{\\top}c_j)(b_i^{\\top}b_j)$。对于 $i \\neq j$，该乘积必须为零。这并不能保证；如果 $C$ 和 $B$ 内部的列是相关的（即非正交的），这个乘积将不为零。“无论列相关性如何”这一短语使得该陈述绝对错误。即使所有列都已归一化，列之间的高度相关性也可以使 $\\kappa_2(Z)$ 任意大。\n**结论：不正确**\n\n**D. 当 $Z$ 是一个非常高且瘦的矩阵，即 $(I_{B} I_{C}) \\gg R$ 时，两种方法实现的前向相对误差都约为 $u$，且与 $\\kappa_{2}(Z)$ 无关，因此在这种情况下它们之间没有显著的精度差距。**\n这是一个错误的论断。对于最小二乘求解器（包括 NE 和 QR 方法），标准的前向误差界根本上取决于条件数 $\\kappa_{2}(Z)$。解 $x_{LS}$ 对 $Z$ 和 $b$ 扰动的敏感性由 $\\kappa_{2}(Z)$ 控制，与矩阵的维度无关。“高且瘦”的几何形状并不能消除这种固有的敏感性。虽然对于某些随机矩阵系综，随着维度的增长，条件数的表现可能会很好，但对于一个*给定*的矩阵 $Z$，其误差界总是取决于*它*的条件数。没有普遍的原则能使误差达到 $\\mathcal{O}(u)$。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3533190"}, {"introduction": "除了理解单个步骤，数值科学家的一个关键技能是分析算法的整体性能。最后一个练习[@problem_id:3586499]要求您对一个完整的CP-ALS扫描进行详细的计算成本分析。通过推导浮点运算数和内存使用的精确表达式，您将深入了解该算法的可扩展性并识别其计算瓶颈。", "problem": "考虑一个稠密的N阶数据张量 $\\mathcal{X} \\in \\mathbb{R}^{I_1 \\times \\cdots \\times I_N}$ 及其秩为 $R$ 的典范分解/平行因子 (CANDECOMP/PARAFAC, CP) 模型，该模型由因子矩阵 $\\{A^{(n)} \\in \\mathbb{R}^{I_n \\times R}\\}_{n=1}^{N}$ 表示，因此模型近似为 $\\sum_{r=1}^{R} a^{(1)}_{:,r} \\circ \\cdots \\circ a^{(N)}_{:,r}$。一次交替最小二乘 (ALS) 扫描会遍历每个模 $n \\in \\{1,\\dots,N\\}$，并通过求解一个由模n矩阵化 $X_{(n)}$ 和其他因子矩阵的 Khatri–Rao 积构建的最小二乘子问题来更新 $A^{(n)}$。假设存在以下实现和计算规则，您必须使用这些规则作为推导的基础：\n\n- 模 $n$ 的矩阵化张量与 Khatri–Rao 积的乘积 (MTTKRP) 在计算时无需显式构建任何 Khatri–Rao 积。它被评估为 $X_{(n)} \\in \\mathbb{R}^{I_n \\times \\left(\\prod_{m \\neq n} I_m\\right)}$ 与一个在收缩中隐式表示的 $ \\left(\\prod_{m \\neq n} I_m\\right) \\times R$ 操作数之间的稠密矩阵-矩阵乘积。将其计为 $2\\,I_n \\left(\\prod_{m \\neq n} I_m\\right) R$ 浮点运算 (flops)。\n- 对每个模 $n$，通过 Hadamard (逐元素) 积 $H^{(n)} = \\underset{m \\neq n}{\\bigodot}\\, S^{(m)}$ 形成正规方程系数 $H^{(n)} \\in \\mathbb{R}^{R \\times R}$，其中 $S^{(m)} = A^{(m)\\top} A^{(m)} \\in \\mathbb{R}^{R \\times R}$ 是第 $m$ 个因子的 Gram 矩阵。通过稠密矩阵-矩阵乘法计算每个 $S^{(m)}$，并将其计为 $2\\,I_m R^2$ flops。对每个模朴素地组合 $H^{(n)}$，不跨模重用，通过链接 $(N-1)$ 个逐元素矩阵乘积，每个模的成本为 $(N-2)R^2$ flops。\n- 通过对 $H^{(n)}$ 进行 Cholesky 分解，然后进行两次具有 $I_n$ 个右端项的三角求解，来求解用于更新 $A^{(n)}$ 的正规方程 (即更新 $A^{(n)} = M^{(n)} H^{(n)^{-1}}$，其中 $M^{(n)}$ 是 MTTKRP 的输出)。将一个 $R \\times R$ 对称正定矩阵的 Cholesky 分解计为 $\\tfrac{1}{3}R^3$ flops，每次具有 $I_n$ 个右端项的三角求解计为 $I_n R^2$ flops，因此两次求解的总成本为 $2 I_n R^2$ flops。\n- 更新 $A^{(n)}$ 后，重新计算其 Gram 矩阵 $S^{(n)} = A^{(n)\\top} A^{(n)}$，成本为 $2\\,I_n R^2$ flops，以用于同一次扫描中的后续模。\n- 所有稠密乘法都使用标准成本规则：将一个 $m \\times k$ 矩阵与一个 $k \\times n$ 矩阵相乘的成本为 $2 m k n$ flops。\n- 内存模型 (峰值存储，以标量字为单位)：显式存储稠密张量 $\\mathcal{X}$、所有因子矩阵 $\\{A^{(n)}\\}_{n=1}^{N}$、所有 Gram 矩阵 $\\{S^{(n)}\\}_{n=1}^{N}$、一个用于一次一个模的临时右端项 $M^{(n)} \\in \\mathbb{R}^{I_n \\times R}$，以及一个用于 $H^{(n)}$ 的 $R \\times R$ 临时空间。不显式存储任何 Khatri–Rao 积或张量展开。\n\n仅从这些规则以及 CP 分解和 ALS 的定义出发，推导以下内容的精确封闭形式表达式：\n- 一次完整的 ALS 扫描遍历所有 $N$ 个模的总 flop 计数，以及\n- 在指定内存模型下，存储的标量字峰值数量，\n\n两者都用 $N$、$R$ 和模大小 $\\{I_n\\}_{n=1}^{N}$ 表示。您的最终答案必须是一个单行矩阵，其第一个条目是 flop 计数表达式，第二个条目是峰值内存表达式，不带单位。不要使用渐进表示法。不要四舍五入或近似。", "solution": "用户提供了一个问题陈述，要求推导 CANDECOMP/PARAFAC 交替最小二乘 (CP-ALS) 算法的计算成本和内存需求的解析表达式。该问题附有一套用于计算和内存核算的具体规则。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- 数据张量：$\\mathcal{X} \\in \\mathbb{R}^{I_1 \\times \\cdots \\times I_N}$。\n- CP 秩：$R$。\n- 因子矩阵：$\\{A^{(n)} \\in \\mathbb{R}^{I_n \\times R}\\}_{n=1}^{N}$。\n- ALS 扫描：一次完整的遍历，更新 $A^{(n)}$，其中 $n = 1, \\dots, N$。\n- 模 $n$ 的矩阵化张量与 Khatri–Rao 积的乘积 (MTTKRP) 的成本：$2\\,I_n \\left(\\prod_{m \\neq n} I_m\\right) R$ flops。\n- 构建正规矩阵 $H^{(n)}$ 的成本：对每个模 $n$，计算所有 $N-1$ 个 Gram 矩阵 $S^{(m)} = A^{(m)\\top}A^{(m)}$，每个成本为 $2 I_m R^2$ flops，然后通过 $(N-2)R^2$ flops 的 Hadamard 积组合成 $H^{(n)} = \\underset{m \\neq n}{\\bigodot}\\, S^{(m)}$。这对每个模都朴素地进行。\n- 求解 $A^{(n)}$ 的正规方程的成本：$H^{(n)}$ 的 Cholesky 分解成本为 $\\tfrac{1}{3}R^3$ flops，随后的两次三角求解总成本为 $2 I_n R^2$ flops。\n- 更新 Gram 矩阵的成本：更新 $A^{(n)}$ 后，重新计算 $S^{(n)} = A^{(n)\\top} A^{(n)}$，成本为 $2 I_n R^2$ flops，用于后续模的更新。\n- 内存模型：存储 $\\mathcal{X}$、所有 $\\{A^{(n)}\\}$、所有 $\\{S^{(n)}\\}$、一个最大的 $M^{(n)} \\in \\mathbb{R}^{I_n \\times R}$ 的临时空间，以及一个 $H^{(n)} \\in \\mathbb{R}^{R \\times R}$ 的临时空间。\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题具有科学依据，描述了数值线性代数中的一个标准算法 (CP-ALS)。所提供的成本和内存模型是明确的，尽管经过简化，但并未违反任何数学或科学原理。问题是适定的、客观的、自洽的且内部一致的。关于 $H^{(n)}$ 的“朴素”计算的关键模糊之处，已通过指定在一次扫描内 Gram 矩阵的重新计算和重用规则得以解决，这指向了一个标准的、高效的 ALS 实现方案。因此，该问题是计算成本分析的一个有效练习。\n\n**第 3 步：结论与行动**\n问题有效。将推导完整解。\n\n### 解的推导\n\n我们来推导一次完整 ALS 扫描的总 flop 计数和峰值内存使用量，该扫描涉及按顺序更新因子矩阵 $A^{(1)}, A^{(2)}, \\dots, A^{(N)}$。\n\n**第 1 部分：总 Flop 计数**\n\n总 flop 计数 $C_{\\text{total}}$ 是更新每个模 $n \\in \\{1,\\dots,N\\}$ 的成本之和。设 $C_n$ 为更新模 $n$ 的成本。\n$$ C_{\\text{total}} = \\sum_{n=1}^{N} C_n $$\n更新 $A^{(n)}$ 的过程包括几个步骤。我们假设在开始更新 $A^{(n)}$ 时，Gram 矩阵 $\\{S^{(k)}\\}_{k=1}^{N}$ 是可用的，反映了因子矩阵的当前状态。\n\n1.  **MTTKRP 计算**：计算模 $n$ 的 MTTKRP 的成本，结果是一个矩阵 $M^{(n)} \\in \\mathbb{R}^{I_n \\times R}$，成本为 $2\\,I_n \\left(\\prod_{m \\neq n} I_m\\right) R$。这可以简化为 $2R \\prod_{k=1}^{N} I_k$。\n    $$ C_{\\text{MTTKRP}, n} = 2R \\prod_{k=1}^{N} I_k $$\n\n2.  **$H^{(n)}$ 的形成**：矩阵 $H^{(n)} \\in \\mathbb{R}^{R \\times R}$ 是通过对所有 $m \\neq n$ 的预先计算好的 Gram 矩阵 $S^{(m)}$ 进行逐元素乘积而形成的。这需要 $N-2$ 次矩阵-矩阵 Hadamard 积。成本如下：\n    $$ C_{H, n} = (N-2)R^2 $$\n\n3.  **求解线性系统**：通过求解正规方程找到 $A^{(n)}$ 的更新。这涉及对 $H^{(n)}$ 进行 Cholesky 分解和两次三角求解。总成本为：\n    $$ C_{\\text{solve}, n} = \\frac{1}{3}R^3 + 2I_n R^2 $$\n\n4.  **Gram 矩阵更新**：更新 $A^{(n)}$ 后，其对应的 Gram 矩阵 $S^{(n)} = A^{(n)\\top}A^{(n)}$ 会被重新计算，以用于同一次扫描中后续模的更新。这种稠密矩阵乘法的成本是：\n    $$ C_{S, n} = 2I_n R^2 $$\n\n更新模 $n$ 的总成本是这些部分的总和：\n$$ C_n = C_{\\text{MTTKRP}, n} + C_{H, n} + C_{\\text{solve}, n} + C_{S, n} $$\n$$ C_n = \\left(2R \\prod_{k=1}^{N} I_k\\right) + (N-2)R^2 + \\left(\\frac{1}{3}R^3 + 2I_n R^2\\right) + 2I_n R^2 $$\n$$ C_n = 2R \\prod_{k=1}^{N} I_k + \\frac{1}{3}R^3 + (N-2)R^2 + 4I_n R^2 $$\n\n为求得一次扫描的总成本，我们将 $C_n$ 对 $n=1, \\dots, N$ 求和：\n$$ C_{\\text{total}} = \\sum_{n=1}^{N} \\left( 2R \\prod_{k=1}^{N} I_k + \\frac{1}{3}R^3 + (N-2)R^2 + 4I_n R^2 \\right) $$\n$$ C_{\\text{total}} = \\left(\\sum_{n=1}^{N} 2R \\prod_{k=1}^{N} I_k\\right) + \\left(\\sum_{n=1}^{N} \\frac{1}{3}R^3\\right) + \\left(\\sum_{n=1}^{N} (N-2)R^2\\right) + \\left(\\sum_{n=1}^{N} 4I_n R^2\\right) $$\n$$ C_{\\text{total}} = N \\left(2R \\prod_{k=1}^{N} I_k\\right) + N\\frac{1}{3}R^3 + N(N-2)R^2 + 4R^2\\sum_{n=1}^{N} I_n $$\n按 $R$ 的幂次对各项进行分组，总 flop 计数为：\n$$ C_{\\text{total}} = \\frac{N}{3}R^3 + \\left(N(N-2) + 4\\sum_{k=1}^{N} I_k\\right)R^2 + 2NR\\prod_{k=1}^{N} I_k $$\n\n**第 2 部分：峰值内存使用量**\n\n峰值内存使用量 $M_{\\text{peak}}$ 是存储所有指定数据结构所需的标量字总数。我们将永久和临时存储组件的大小相加。\n\n1.  **稠密张量 $\\mathcal{X}$**：大小为 $\\prod_{k=1}^{N} I_k$。\n2.  **因子矩阵 $\\{A^{(n)}\\}_{n=1}^{N}$**：每个 $A^{(n)}$ 的大小为 $I_n \\times R$。总大小为 $\\sum_{n=1}^{N} I_n R = R\\sum_{n=1}^{N} I_n$。\n3.  **Gram 矩阵 $\\{S^{(n)}\\}_{n=1}^{N}$**：每个 $S^{(n)}$ 的大小为 $R \\times R$。总大小为 $\\sum_{n=1}^{N} R^2 = NR^2$。\n4.  **MTTKRP $M^{(n)}$ 的临时空间**：需要一个缓冲区来存放 $I_n \\times R$ 矩阵 $M^{(n)}$。为了适应任何模，其大小必须足以容纳最大的可能 $M^{(n)}$，即 $\\max_{k \\in \\{1,\\dots,N\\}} (I_k R) = R \\max_{k \\in \\{1,\\dots,N\\}} I_k$。\n5.  **$H^{(n)}$ 的临时空间**：需要一个大小为 $R \\times R$ 的缓冲区用于 $H^{(n)}$，对应 $R^2$ 个标量。\n\n峰值内存是这些组件的总和：\n$$ M_{\\text{peak}} = \\left(\\prod_{k=1}^{N} I_k\\right) + \\left(R\\sum_{k=1}^{N} I_k\\right) + NR^2 + \\left(R \\max_{k \\in \\{1,\\dots,N\\}} I_k\\right) + R^2 $$\n合并各项，总的峰值内存使用量为：\n$$ M_{\\text{peak}} = \\prod_{k=1}^{N} I_k + R\\left(\\sum_{k=1}^{N} I_k + \\max_{k \\in \\{1,\\dots,N\\}} I_k\\right) + (N+1)R^2 $$\n\n总 flop 计数和峰值内存使用量的两个推导表达式构成了该问题的完整解。", "answer": "$$ \\boxed{\\pmatrix{ 2NR\\prod_{k=1}^{N} I_k + \\left(N(N-2) + 4\\sum_{k=1}^{N} I_k\\right)R^2 + \\frac{N}{3}R^3  \\prod_{k=1}^{N} I_k + R\\left( \\sum_{k=1}^{N} I_k + \\max_{k \\in \\{1,\\dots,N\\}} I_k \\right) + (N+1)R^2 }} $$", "id": "3586499"}]}