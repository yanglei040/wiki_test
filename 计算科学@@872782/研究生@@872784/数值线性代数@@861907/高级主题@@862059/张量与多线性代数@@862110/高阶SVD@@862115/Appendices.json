{"hands_on_practices": [{"introduction": "为了真正理解高阶奇异值分解，亲手实践其计算过程至关重要。这第一个练习提供了一个具体的小规模三阶张量，引导您完成HOSVD算法的基本步骤，包括模态-$n$展开、因子矩阵的计算以及核心张量的求解[@problem_id:1071392]。通过逐步执行这些计算，您将为所学的概念建立一个坚实而直观的基础。", "problem": "高阶奇异值分解 (HOSVD)，也称为 Tucker 分解，是矩阵 SVD 向高阶张量的推广。一个 $N$ 阶实值张量 $\\mathcal{A} \\in \\mathbb{R}^{I_1 \\times I_2 \\times \\dots \\times I_N}$ 可以分解为一个核心张量 $\\mathcal{G} \\in \\mathbb{R}^{R_1 \\times R_2 \\times \\dots \\times R_N}$ 和一组正交因子矩阵 $U^{(n)} \\in \\mathbb{R}^{I_n \\times R_n}$（其中 $n=1, \\dots, N$）。该分解的多线性秩为 $(R_1, \\dots, R_N)$，其中 $R_n \\le I_n$。\n\n该分解使用 n-模积表示：\n$$ \\mathcal{A} \\approx \\mathcal{G} \\times_1 U^{(1)} \\times_2 U^{(2)} \\dots \\times_N U^{(N)} $$\n张量 $\\mathcal{X} \\in \\mathbb{R}^{I_1 \\times \\dots \\times I_N}$ 与矩阵 $M \\in \\mathbb{R}^{J_n \\times I_n}$ 沿第 $n$ 模态的 n-模积是一个新张量 $\\mathcal{Y} = \\mathcal{X} \\times_n M$，其大小为 $I_1 \\times \\dots \\times J_n \\times \\dots \\times I_N$，其元素由下式给出：\n$$ (\\mathcal{Y})_{i_1, \\dots, j_n, \\dots, i_N} = \\sum_{k=1}^{I_n} (\\mathcal{X})_{i_1, \\dots, k, \\dots, i_N} (M)_{j_n, k} $$\n\nHOSVD 的因子矩阵 $U^{(n)}$ 是从 $\\mathcal{A}$ 的 n-模展开中获得的。$\\mathcal{A}$ 的 n-模展开（或矩阵化），记作 $A_{(n)}$，是一个大小为 $I_n \\times (I_1 \\dots I_{n-1} I_{n+1} \\dots I_N)$ 的矩阵，其列是 $\\mathcal{A}$ 的 n-模纤维。因子矩阵 $U^{(n)}$ 由 $A_{(n)}$ 的前 $R_n$ 个左奇异向量构成，这些向量根据其对应的奇异值按降序排列。\n\n然后，通过将 $\\mathcal{A}$ 投影到由因子矩阵张成的空间上来计算核心张量 $\\mathcal{G}$：\n$$ \\mathcal{G} = \\mathcal{A} \\times_1 (U^{(1)})^T \\times_2 (U^{(2)})^T \\dots \\times_N (U^{(N)})^T $$\n\n张量 $\\mathcal{A}$ 的弗罗贝尼乌斯范数由 $\\|\\mathcal{A}\\|_F = \\sqrt{\\sum_{i_1, \\dots, i_N} |a_{i_1 \\dots i_N}|^2}$ 给出。\n\n考虑一个三阶张量 $\\mathcal{A} \\in \\mathbb{R}^{2 \\times 3 \\times 2}$，它由其两个额切片（通过固定第三个索引获得的矩阵）定义：\n$$ A_1 = \\mathcal{A}(:,:,1) = \\begin{pmatrix} 1 & 0 & 1 \\\\ 0 & 2 & 0 \\end{pmatrix} $$\n$$ A_2 = \\mathcal{A}(:,:,2) = \\begin{pmatrix} 0 & 1 & 0 \\\\ 1 & 0 & 1 \\end{pmatrix} $$\n\n计算从 $\\mathcal{A}$ 的 Tucker 分解（指定多线性秩为 $(R_1, R_2, R_3) = (1, 2, 1)$）中获得的核心张量 $\\mathcal{G}$ 的弗罗贝尼乌斯范数。", "solution": "1.  1-模展开 $A_{(1)} \\in \\mathbb{R}^{2 \\times 6}$。按字典序使用 $(i_2, i_3)$ 排序，\n    $$\n    A_{(1)} = \\begin{pmatrix}\n    1 & 0 & 1 & 0 & 1 & 0 \\\\\n    0 & 2 & 0 & 1 & 0 & 1\n    \\end{pmatrix}.\n    $$\n    则\n    $$\n    A_{(1)}A_{(1)}^T = \\begin{pmatrix} 3 & 0 \\\\ 0 & 6 \\end{pmatrix},\n    $$\n    因此最大特征值为 $6$，单位特征向量为 $\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$。因此\n    $$\n    U^{(1)} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}, \\; R_1=1.\n    $$\n\n2.  2-模展开 $A_{(2)} \\in \\mathbb{R}^{3 \\times 4}$，按字典序使用 $(i_1, i_3)$ 排序，\n    $$\n    A_{(2)} = \\begin{pmatrix} 1 & 0 & 0 & 1 \\\\ 0 & 2 & 1 & 0 \\\\ 1 & 0 & 0 & 1 \\end{pmatrix},\n    $$\n    因此\n    $$\n    A_{(2)}A_{(2)}^T = \\begin{pmatrix} 2 & 0 & 2 \\\\ 0 & 5 & 0 \\\\ 2 & 0 & 2 \\end{pmatrix}.\n    $$\n    其最大的两个特征值为 $5$ 和 $4$，对应的标准正交特征向量为 $(0,1,0)^T$ 和 $\\frac{1}{\\sqrt{2}}(1,0,1)^T$。因此\n    $$\n    U^{(2)} = \\begin{pmatrix} 0 & \\frac{1}{\\sqrt{2}} \\\\ 1 & 0 \\\\ 0 & \\frac{1}{\\sqrt{2}} \\end{pmatrix}, \\; R_2=2.\n    $$\n\n3.  3-模展开 $A_{(3)} \\in \\mathbb{R}^{2 \\times 6}$，使用 $(i_1, i_2)$ 排序，\n    $$\n    A_{(3)} = \\begin{pmatrix} 1 & 0 & 1 & 0 & 2 & 0 \\\\ 0 & 1 & 0 & 1 & 0 & 1 \\end{pmatrix},\n    $$\n    且\n    $$\n    A_{(3)}A_{(3)}^T = \\begin{pmatrix} 6 & 0 \\\\ 0 & 3 \\end{pmatrix}.\n    $$\n    最大特征值为 $6$，特征向量为 $(1,0)^T$，因此\n    $$\n    U^{(3)} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\; R_3=1.\n    $$\n\n4.  核心张量 $\\mathcal{G} = \\mathcal{A} \\times_1 (U^{(1)})^T \\times_2 (U^{(2)})^T \\times_3 (U^{(3)})^T$ 的元素为\n    $G_{1,1,1}=2, \\quad G_{1,2,1}=0$,\n    因此 $\\mathcal{G} \\in \\mathbb{R}^{1 \\times 2 \\times 1}$。\n\n5.  弗罗贝尼乌斯范数\n    $$\n    \\|\\mathcal{G}\\|_F = \\sqrt{2^2+0^2} = 2.\n    $$", "answer": "$$\\boxed{2}$$", "id": "1071392"}, {"introduction": "HOSVD最强大的应用之一是张量近似，其关键在于选择一个合适的多线性秩。本练习将探讨秩选择这一关键而微妙的任务，通过比较一种简单的逐模态截断策略与一种更稳健的联合能量方法[@problem_id:3549407]。通过一个编程练习，您将发现朴素的秩选择策略在某些情况下会失效，并理解为何整体性的视角对于有效的张量压缩至关重要。", "problem": "考虑一个实数三阶张量 $X \\in \\mathbb{R}^{I \\times J \\times K}$。令 $X_{(n)}$ 表示 $X$ 的模-$n$ 展开，其中 $n \\in \\{1,2,3\\}$，并令 $X_{(n)}$ 的奇异值分解（SVD）为 $X_{(n)} = U_{(n)} \\Sigma_{(n)} V_{(n)}^{\\top}$，其奇异值 $\\{\\sigma_{n,i}\\}_{i \\ge 1}$ 按非增序排列。$X$ 的高阶奇异值分解（HOSVD）由正交因子矩阵 $U_1 \\in \\mathbb{R}^{I \\times I}$、$U_2 \\in \\mathbb{R}^{J \\times J}$、$U_3 \\in \\mathbb{R}^{K \\times K}$（分别通过 $X_{(1)}$、$X_{(2)}$ 和 $X_{(3)}$ 的左奇异向量获得）和一个由 $G = X \\times_1 U_1^{\\top} \\times_2 U_2^{\\top} \\times_3 U_3^{\\top}$ 给出的核心张量 $G \\in \\mathbb{R}^{I \\times J \\times K}$ 定义，其中 $\\times_n$ 是模-$n$ 张量-矩阵乘积。具有多线性秩 $(r_1,r_2,r_3)$ 的截断 HOSVD 使用 $U_n$ 的前 $r_n$ 列以及 $G$ 的相应子张量来形成一个近似 $\\widehat{X}^{(r_1,r_2,r_3)}$。\n\n你需要实现并比较两种秩选择策略：\n\n- 逐模碎石图选择（独立截断）：对于给定的阈值 $\\alpha \\in (0,1)$，选择最小的 $r_n$ 使得 $\\sum_{i=1}^{r_n} \\sigma_{n,i}^2 \\ge \\alpha \\sum_{i \\ge 1} \\sigma_{n,i}^2$，对每个模 $n \\in \\{1,2,3\\}$ 独立进行。\n- 联合能量目标（全局选择）：对于给定的目标 $\\beta \\in (0,1)$ 和上界元组 $(r_{1,\\max}, r_{2,\\max}, r_{3,\\max})$（其中 $1 \\le r_n \\le r_{n,\\max}$），按字典序搜索所有可行的三元组 $(r_1,r_2,r_3)$，以找到满足所捕获的相对弗罗贝尼乌斯能量 $\\| \\widehat{X}^{(r_1,r_2,r_3)} \\|_F^2 / \\| X \\|_F^2 \\ge \\beta$ 的字典序最小的三元组。如果在界限内不存在这样的三元组，则选择能最大化捕获能量的三元组。\n\n按如下方式构造表现出联合出现的低能量模态的张量。对于每个测试用例，将 $X$ 构建为秩-1 分量之和，其正交因子与标准基向量对齐：\n$$\nX \\;=\\; \\sum_{t=1}^{R} \\lambda_t \\, u_t \\otimes v_t \\otimes w_t,\n$$\n其中 $\\{u_t\\}_{t=1}^R \\subset \\mathbb{R}^I$、$\\{v_t\\}_{t=1}^R \\subset \\mathbb{R}^J$ 和 $\\{w_t\\}_{t=1}^R \\subset \\mathbb{R}^K$ 是正交向量集，对于每个 $t$，它们被选为各自空间中相应的标准基向量 $e_t$（例如，$u_t = e_t \\in \\mathbb{R}^I$）。假设所有 $\\lambda_t \\ge 0$。这种构造确保了每个展开 $X_{(n)}$ 的奇异值都等于集合 $\\{\\lambda_t\\}_{t=1}^R$（可能用零填充），而任何由 $t \\ge 2$ 索引的分量只有在所有三个模的秩都满足 $r_1 \\ge t$、$r_2 \\ge t$ 和 $r_3 \\ge t$ 时才能被表示。这测试了独立逐模截断的陷阱，即它可能会在任何单个模中丢弃一个联合必需的方向，从而即使一个分量的总能量很显著，也会被整个移除。\n\n实现以下任务：\n\n1. 给定 $X$，通过 $X_{(1)}$、$X_{(2)}$、$X_{(3)}$ 的 SVD 计算 HOSVD 因子 $U_1$、$U_2$、$U_3$，并为指定的 $(r_1,r_2,r_3)$ 构建截断 HOSVD 重建 $\\widehat{X}^{(r_1,r_2,r_3)}$。\n2. 实现给定 $\\alpha$ 的逐模碎石图选择，以产生 $(r_1^{\\text{per}}, r_2^{\\text{per}}, r_3^{\\text{per}})$，然后计算相对弗罗贝尼乌斯误差 $e_{\\text{per}} = \\| X - \\widehat{X}^{(r_1^{\\text{per}}, r_2^{\\text{per}}, r_3^{\\text{per}})} \\|_F / \\| X \\|_F$。\n3. 实现给定 $\\beta$ 和界限 $(r_{1,\\max}, r_{2,\\max}, r_{3,\\max})$ 的联合能量目标，以产生 $(r_1^{\\text{joint}}, r_2^{\\text{joint}}, r_3^{\\text{joint}})$ 和相对弗罗贝尼乌斯误差 $e_{\\text{joint}} = \\| X - \\widehat{X}^{(r_1^{\\text{joint}}, r_2^{\\text{joint}}, r_3^{\\text{joint}})} \\|_F / \\| X \\|_F$。\n4. 对于每个测试用例，还需报告乘积 $d_{\\text{per}} = r_1^{\\text{per}} r_2^{\\text{per}} r_3^{\\text{per}}$ 和 $d_{\\text{joint}} = r_1^{\\text{joint}} r_2^{\\text{joint}} r_3^{\\text{joint}}$ 以量化模型大小。\n\n你的程序必须实现以上内容，并运行以下测试套件，严格按照标准基向量的规定构造 X：\n\n- 测试用例 1（联合必需的第二模态，独立截断失败）：$I = 8$, $J = 8$, $K = 8$, $R = 2$, $(\\lambda_1,\\lambda_2) = (1.0, 0.6)$, $\\alpha = 0.85$, $\\beta = 0.95$, $(r_{1,\\max}, r_{2,\\max}, r_{3,\\max}) = (2,2,2)$。\n- 测试用例 2（独立截断足够的顺利情况）：$I = 8$, $J = 8$, $K = 8$, $R = 2$, $(\\lambda_1,\\lambda_2) = (1.0, 0.4)$, $\\alpha = 0.6$, $\\beta = 0.8$, $(r_{1,\\max}, r_{2,\\max}, r_{3,\\max}) = (2,2,2)$。\n- 测试用例 3（无隐藏模态的边界情况）：$I = 8$, $J = 8$, $K = 8$, $R = 2$, $(\\lambda_1,\\lambda_2) = (1.0, 0.0)$, $\\alpha = 0.99$, $\\beta = 0.99$, $(r_{1,\\max}, r_{2,\\max}, r_{3,\\max}) = (2,2,2)$。\n- 测试用例 4（多个联合必需的低能量模态）：$I = 6$, $J = 6$, $K = 6$, $R = 3$, $(\\lambda_1,\\lambda_2,\\lambda_3) = (1.0, 0.5, 0.5)$, $\\alpha = 0.66$, $\\beta = 0.9$, $(r_{1,\\max}, r_{2,\\max}, r_{3,\\max}) = (3,3,3)$。\n\n最终输出格式。你的程序必须生成单行文本，其中包含一个数字列表，该列表按固定顺序汇总了四个测试用例的结果\n$$\n\\big[ e_{\\text{per}}^{(1)},\\; e_{\\text{joint}}^{(1)},\\; d_{\\text{per}}^{(1)},\\; d_{\\text{joint}}^{(1)},\\; e_{\\text{per}}^{(2)},\\; e_{\\text{joint}}^{(2)},\\; d_{\\text{per}}^{(2)},\\; d_{\\text{joint}}^{(2)},\\; e_{\\text{per}}^{(3)},\\; e_{\\text{joint}}^{(3)},\\; d_{\\text{per}}^{(3)},\\; d_{\\text{joint}}^{(3)},\\; e_{\\text{per}}^{(4)},\\; e_{\\text{joint}}^{(4)},\\; d_{\\text{per}}^{(4)},\\; d_{\\text{joint}}^{(4)} \\big],\n$$\n其中每个误差 $e_{\\text{per}}^{(i)}$ 和 $e_{\\text{joint}}^{(i)}$ 四舍五入到6位小数，每个 $d_{\\text{per}}^{(i)}$ 和 $d_{\\text{joint}}^{(i)}$ 是整数。\n\n你的实现必须是自包含的，不需要任何用户输入。除了指定的值之外，不需要任何物理单位、角度单位或百分比，所有数值答案都是无单位的实数。程序必须仅依赖于上面定义的标准线性代数运算，无需任何绘图。", "solution": "该问题要求实现并比较两种不同的策略，用于选择三阶张量的高阶奇异值分解（HOSVD）中的多线性秩。其目标是突显一种情景：一种常见的启发式方法，即独立的逐模秩选择，未能保留重要的结构信息，而这些信息本可以被一种更全面的联合秩选择方法所捕获。\n\n我们首先形式化张量代数中的必要概念。一个三阶张量是向量空间张量积中的一个元素，我们将其表示为一个三维数组 $X \\in \\mathbb{R}^{I \\times J \\times K}$。\n\n$X$ 的模-$n$ 展开（或称矩阵化），记作 $X_{(n)}$，是将张量元素重新排列成一个矩阵的过程。对于 $n=1, 2, 3$，展开如下：\n-   $X_{(1)} \\in \\mathbb{R}^{I \\times JK}$，其中位于 $(i, (j-1)K+k)$ 的元素是 $X_{ijk}$。\n-   $X_{(2)} \\in \\mathbb{R}^{J \\times IK}$，其中位于 $(j, (k-1)I+i)$ 的元素是 $X_{ijk}$。\n-   $X_{(3)} \\in \\mathbb{R}^{K \\times IJ}$，其中位于 $(k, (i-1)J+j)$ 的元素是 $X_{ijk}$。\n\n一个张量 $X \\in \\mathbb{R}^{I_1 \\times \\dots \\times I_N}$ 与一个矩阵 $A \\in \\mathbb{R}^{J_n \\times I_n}$ 的模-$n$ 乘积，记作 $Y = X \\times_n A$，结果是一个张量 $Y \\in \\mathbb{R}^{I_1 \\times \\dots \\times J_n \\times \\dots \\times I_N}$。其元素由 $Y_{i_1 \\dots j_n \\dots i_N} = \\sum_{k=1}^{I_n} X_{i_1 \\dots k \\dots i_N} A_{j_n k}$ 给出。\n\n$X$ 的高阶奇异值分解（HOSVD）是一种形式为 $X = G \\times_1 U_1 \\times_2 U_2 \\times_3 U_3$ 的分解，其中：\n1.  $U_1 \\in \\mathbb{R}^{I \\times I}$、$U_2 \\in \\mathbb{R}^{J \\times J}$ 和 $U_3 \\in \\mathbb{R}^{K \\times K}$ 是正交因子矩阵。$U_n$ 的列是从模-$n$ 展开的奇异值分解（SVD）中获得的左奇异向量：$X_{(n)} = U_n \\Sigma_{(n)} V_n^\\top$。\n2.  $G \\in \\mathbb{R}^{I \\times J \\times K}$ 是核心张量，计算方式为 $G = X \\times_1 U_1^\\top \\times_2 U_2^\\top \\times_3 U_3^\\top$。核心张量 $G$ 捕获了因子矩阵各分量之间的相互作用。由于因子矩阵的正交性，$X$ 和 $G$ 的弗罗贝尼乌斯范数相等，即 $\\|X\\|_F = \\|G\\|_F$。\n\n截断 HOSVD 提供了 $X$ 的一个低秩近似。给定一个多线性秩 $(r_1, r_2, r_3)$，其中 $1 \\le r_n \\le \\text{dim}_n(X)$，我们将因子矩阵截断为其前 $r_n$ 列，得到 $\\tilde{U}_n \\in \\mathbb{R}^{\\text{dim}_n(X) \\times r_n}$，并将核心张量截断为主子张量 $\\tilde{G} = G(1:r_1, 1:r_2, 1:r_3)$。近似则为 $\\widehat{X}^{(r_1,r_2,r_3)} = \\tilde{G} \\times_1 \\tilde{U}_1 \\times_2 \\tilde{U}_2 \\times_3 \\tilde{U}_3$。\n一个关键性质是，近似的弗罗贝尼乌斯范数的平方就是截断核心张量的弗罗贝尼乌斯范数的平方，即 $\\|\\widehat{X}^{(r_1,r_2,r_3)}\\|_F^2 = \\|\\tilde{G}\\|_F^2$。相对近似误差由 $e = \\|X - \\widehat{X}\\|_F / \\|X\\|_F$ 给出。利用范数保持性质，这可以高效地计算为 $e = \\sqrt{1 - \\|\\widehat{X}\\|_F^2 / \\|X\\|_F^2}$。\n\n该问题指定了一种特殊的张量构造：$X = \\sum_{t=1}^{R} \\lambda_t \\, u_t \\otimes v_t \\otimes w_t$，其中 $u_t=e_t$、$v_t=e_t$ 和 $w_t=e_t$ 是标准基向量，且 $\\lambda_t \\ge 0$。这会产生一个对角张量，其中唯一的非零项是 $X_{t,t,t} = \\lambda_t$，对于 $t=1, \\dots, R$。对于这样的张量，其展开 $X_{(n)}$ 具有正交的行。$X_{(n)}$ 的 SVD 产生的因子矩阵 $U_n$ 是单位矩阵（如果 $\\lambda_t$ 未排序，则为置换矩阵），奇异值为 $\\{\\lambda_t\\}_{t=1}^R$。因此，核心张量为 $G=X$。近似 $\\widehat{X}^{(r_1,r_2,r_3)}$ 的弗罗贝尼乌斯范数平方简化为 $\\|\\widehat{X}^{(r_1,r_2,r_3)}\\|_F^2 = \\sum_{t=1}^{\\min(r_1,r_2,r_3)} \\lambda_t^2$，假设 $\\lambda_t$ 按非增序排列。这种特殊结构使得近似的能量取决于三个秩中的最小值，这是测试用例的基础。\n\n两种秩选择策略是：\n1.  **逐模碎石图选择**：此方法独立处理每个模。对于一个阈值 $\\alpha$，它为每个模态 $n$ 找到最小的秩 $r_n$，使得该模态的奇异值所捕获的能量至少为 $\\alpha$ 部分：$\\sum_{i=1}^{r_n} \\sigma_{n,i}^2 \\ge \\alpha \\sum_{i \\ge 1} \\sigma_{n,i}^2$。对于所构造的张量，所有模态的奇异值平方 $\\{\\sigma_{n,i}^2\\}$ 都相同，等于 $\\{\\lambda_t^2\\}$。\n2.  **联合能量目标**：此方法考虑重建张量的总能量。对于一个目标能量分数 $\\beta$，它在给定的界限 $(r_{1,\\max}, r_{2,\\max}, r_{3,\\max})$ 内搜索字典序最小的秩元组 $(r_1, r_2, r_3)$，使得 $\\|\\widehat{X}^{(r_1,r_2,r_3)}\\|_F^2 / \\|X\\|_F^2 \\ge \\beta$。搜索通过在嵌套循环中迭代 $r_1, r_2, r_3$ 来进行。对于每个元组，从核心张量高效计算捕获的能量，并与阈值进行比较。如果没有元组满足条件，则选择最大化捕获能量的那个。\n\n我们将用测试用例 4 来说明这个过程：\n-   给定：$I=J=K=6$, $R=3$, $(\\lambda_1, \\lambda_2, \\lambda_3) = (1.0, 0.5, 0.5)$, $\\alpha=0.66$, $\\beta=0.9$, 和 $r_{\\max}=(3,3,3)$。\n-   张量构造：$X_{111}=1.0, X_{222}=0.5, X_{333}=0.5$（使用基于1的索引）。\n-   总能量：$\\|X\\|_F^2 = 1.0^2 + 0.5^2 + 0.5^2 = 1.5$。\n-   任何模态的奇异值平方都是 $(1.0, 0.25, 0.25)$。平方和的总和是 $1.5$。\n\n-   **逐模选择 ($r^{\\text{per}}$)**：目标能量是 $\\alpha \\sum \\sigma^2 = 0.66 \\times 1.5 = 0.99$。\n    -   对于 $r=1$，累积能量是 $1.0^2=1.0$。因为 $1.0 \\ge 0.99$，所以每个模态的最小秩是 $r_n=1$。\n    -   这得到 $r^{\\text{per}} = (1,1,1)$ 和模型大小 $d_{\\text{per}}=1 \\times 1 \\times 1=1$。\n    -   近似 $\\widehat{X}^{(1,1,1)}$ 只捕获了第一个分量。其能量是 $\\lambda_1^2=1.0$。\n    -   相对误差是 $e_{\\text{per}} = \\sqrt{1 - 1.0/1.5} = \\sqrt{1/3} \\approx 0.577350$。\n\n-   **联合能量目标 ($r^{\\text{joint}}$)**：目标相对能量是 $\\beta=0.9$。\n    -   对 $(r_1,r_2,r_3)$ 的搜索按字典序从 $(1,1,1)$ 到 $(3,3,3)$ 进行。\n    -   一个元组的相对捕获能量是 $(\\sum_{t=1}^{\\min(r_1,r_2,r_3)} \\lambda_t^2) / 1.5$。\n    -   对于任何 $\\min(r_1,r_2,r_3)=1$ 的元组，相对能量是 $1.0/1.5 \\approx 0.667 < 0.9$。\n    -   对于任何 $\\min(r_1,r_2,r_3)=2$ 的元组，相对能量是 $(1.0+0.25)/1.5 \\approx 0.833 < 0.9$。\n    -   对于任何 $\\min(r_1,r_2,r_3)=3$ 的元组，相对能量是 $(1.0+0.25+0.25)/1.5 = 1.0 \\ge 0.9$。\n    -   满足此条件的字典序第一个元组是 $(3,3,3)$。\n    -   这得到 $r^{\\text{joint}} = (3,3,3)$ 和模型大小 $d_{\\text{joint}}=3 \\times 3 \\times 3=27$。\n    -   近似 $\\widehat{X}^{(3,3,3)}$ 捕获了所有分量。其能量是 $1.5$。\n    -   相对误差是 $e_{\\text{joint}} = \\sqrt{1 - 1.5/1.5} = 0$。\n\n这个案例展示了陷阱：逐模选择被每个模中第一个奇异值的主导地位所误导，选择了秩为 1，从而丢弃了两个分量并导致了很大的误差。联合选择则正确地识别出所有三个秩必须至少为 3 才能满足期望的整体近似质量，尽管这导致了更大的模型。程序将对所有指定的测试用例执行此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef construct_tensor(I, J, K, lambdas):\n    \"\"\"Constructs the special diagonal tensor X.\"\"\"\n    X = np.zeros((I, J, K))\n    R = len(lambdas)\n    for t in range(R):\n        if t < I and t < J and t < K:\n            X[t, t, t] = lambdas[t]\n    return X\n\ndef mode_n_unfolding(X, n):\n    \"\"\"Computes the mode-n unfolding of a tensor X.\"\"\"\n    if n == 1:\n        return np.reshape(X, (X.shape[0], -1))\n    elif n == 2:\n        return np.reshape(np.transpose(X, (1, 0, 2)), (X.shape[1], -1))\n    elif n == 3:\n        return np.reshape(np.transpose(X, (2, 0, 1)), (X.shape[2], -1))\n    else:\n        raise ValueError(\"Mode must be 1, 2, or 3 for an order-3 tensor.\")\n\ndef mode_n_product(X, A, n):\n    \"\"\"Computes the mode-n product of a tensor X with a matrix A.\"\"\"\n    # This implementation is for order-3 tensors\n    if n not in [1, 2, 3]:\n        raise ValueError(\"Mode must be 1, 2, or 3.\")\n    \n    # np.tensordot contracts over specified axes. \n    # For X_abc and A_ij, we want to sum over the n-th mode of X and the second dim of A.\n    # X mode-1 (a) is index 0. X mode-2 (b) is index 1. X mode-3 (c) is index 2.\n    res_tensor = np.tensordot(X, A, axes=([n-1], [1]))\n    \n    # The new dimension from A is at the end. We move it to the correct (n-th) position.\n    # The original axes shift. e.g. for n=1, original axes are (1,2) of X.\n    # result shape is (J, K, I_new), need to move I_new to front.\n    return np.moveaxis(res_tensor, -1, n-1)\n\ndef compute_hosvd(X):\n    \"\"\"Computes the HOSVD of a tensor X.\"\"\"\n    dims = X.shape\n    U_factors = []\n    singular_values = []\n\n    for n in range(1, 4):\n        X_n = mode_n_unfolding(X, n)\n        # We need the full U matrix to compute the core tensor G correctly\n        U, s, _ = svd(X_n, full_matrices=True)\n        # Make sure U has the correct dimensions if X_n is skinny\n        if U.shape[1] < dims[n-1]:\n             U_full = np.zeros((dims[n-1], dims[n-1]))\n             U_full[:, :U.shape[1]] = U\n             U = U_full\n        U_factors.append(U)\n\n        s_full = np.zeros(min(X_n.shape))\n        s_full[:len(s)] = s\n        singular_values.append(s_full)\n    \n    U1, U2, U3 = U_factors\n    G = mode_n_product(X, U1.T, 1)\n    G = mode_n_product(G, U2.T, 2)\n    G = mode_n_product(G, U3.T, 3)\n    \n    return U_factors, singular_values, G\n\ndef per_mode_scree_selection(singular_values, alpha):\n    \"\"\"Performs per-mode scree plot based rank selection.\"\"\"\n    ranks = []\n    for s_n in singular_values:\n        s_n_sq = s_n**2\n        total_energy = np.sum(s_n_sq)\n        if total_energy == 0:\n            ranks.append(1)\n            continue\n        \n        cumulative_energy = np.cumsum(s_n_sq)\n        target_energy = alpha * total_energy\n        \n        # Find first rank r where cumulative energy exceeds target\n        # np.where returns a tuple of arrays, we need the first element of the first array\n        r_n_candidates = np.where(cumulative_energy >= target_energy)[0]\n        \n        if len(r_n_candidates) > 0:\n            r_n = r_n_candidates[0] + 1\n        else: # Should not happen if alpha <= 1, but for safety\n             r_n = len(s_n)\n        ranks.append(r_n)\n    return tuple(ranks)\n\ndef joint_energy_targeting(G, total_energy_sq, beta, r_max):\n    \"\"\"Performs joint energy targeting rank selection.\"\"\"\n    r1_max, r2_max, r3_max = r_max\n    \n    best_ranks = (1, 1, 1)\n    max_captured_energy = -1.0\n\n    for r1 in range(1, r1_max + 1):\n        for r2 in range(1, r2_max + 1):\n            for r3 in range(1, r3_max + 1):\n                G_trunc = G[:r1, :r2, :r3]\n                captured_energy_sq = np.sum(G_trunc**2)\n\n                if total_energy_sq > 0 and captured_energy_sq / total_energy_sq >= beta:\n                    return (r1, r2, r3)\n                \n                if captured_energy_sq > max_captured_energy:\n                    max_captured_energy = captured_energy_sq\n                    best_ranks = (r1, r2, r3)\n    \n    # This fallback is executed if no rank combination meets the beta threshold\n    return best_ranks\n\ndef calculate_error_and_size(ranks, G, total_energy_sq):\n    \"\"\"Calculates relative Frobenius error and model size for given ranks.\"\"\"\n    r1, r2, r3 = ranks\n    d = r1 * r2 * r3\n    \n    G_trunc = G[:r1, :r2, :r3]\n    captured_energy_sq = np.sum(G_trunc**2)\n    \n    if total_energy_sq == 0:\n        error = 0.0\n    else:\n        # Avoid numerical issues with captured_energy_sq > total_energy_sq\n        ratio = min(1.0, captured_energy_sq / total_energy_sq)\n        error = np.sqrt(1.0 - ratio)\n\n    return error, d\n\ndef solve():\n    test_cases = [\n        # (I, J, K, lambdas, alpha, beta, (r1_max, r2_max, r3_max))\n        (8, 8, 8, (1.0, 0.6), 0.85, 0.95, (2, 2, 2)),\n        (8, 8, 8, (1.0, 0.4), 0.6, 0.8, (2, 2, 2)),\n        (8, 8, 8, (1.0, 0.0), 0.99, 0.99, (2, 2, 2)),\n        (6, 6, 6, (1.0, 0.5, 0.5), 0.66, 0.9, (3, 3, 3)),\n    ]\n\n    all_results = []\n\n    for I, J, K, lambdas, alpha, beta, r_max in test_cases:\n        # 1. Construct tensor and compute total energy\n        X = construct_tensor(I, J, K, lambdas)\n        total_energy_sq = np.sum(X**2)\n\n        # 2. Compute HOSVD\n        U_factors, singular_values, G = compute_hosvd(X)\n\n        # 3. Per-mode scree selection\n        r_per = per_mode_scree_selection(singular_values, alpha)\n        e_per, d_per = calculate_error_and_size(r_per, G, total_energy_sq)\n\n        # 4. Joint energy targeting\n        r_joint = joint_energy_targeting(G, total_energy_sq, beta, r_max)\n        e_joint, d_joint = calculate_error_and_size(r_joint, G, total_energy_sq)\n        \n        # 5. Append results\n        all_results.append(round(e_per, 6))\n        all_results.append(round(e_joint, 6))\n        all_results.append(d_per)\n        all_results.append(d_joint)\n\n    # Final print statement\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3549407"}]}