{"hands_on_practices": [{"introduction": "第一个练习是奠定理论基础的关键。当矩阵的谱被限制在一个已知区间内时，我们可以推导出最优的多项式预处理器。此练习将引导您完成基于切比雪夫多项式极小极大性质的推导过程，这是理解近似理论和迭代法中许多最优性结果的基石。[@problem_id:3565775]", "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定 (SPD) 矩阵，并且假设只有谱界是已知的，即 $0  a \\le \\lambda_{\\min}(A) \\le \\lambda_{\\max}(A) \\le b$。考虑多项式预处理，即寻求一个多项式 $p$，使得线性算子 $I - A p(A)$ 的算子 2-范数很小。利用对称矩阵的谱定理、多项式函数谱映射性质，以及第一类 Chebyshev 多项式在 $[-1,1]$ 上的极小极大极值性质，构造一个仅基于边界 $a$ 和 $b$ 的 $m$ 次多项式预处理器 $p_{m}$ 的稳健方案，该方案保证算子 2-范数有预设的缩减因子 $\\delta \\in (0,1)$，即\n$$\n\\|I - A p_{m}(A)\\|_{2} \\le \\delta.\n$$\n你的推导必须从所述的基本事实出发，通过仿射变换将区间 $[a,b]$ 映射到 $[-1,1]$，并对一个 Chebyshev 多项式进行缩放，以对辅助多项式 $q(\\lambda) = \\lambda p_{m}(\\lambda)$ 施加约束 $q(0)=0$。请明确给出：\n- 对所有 $\\lambda \\in [a,b]$ 均有效的预处理器 $p_{m}(\\lambda)$ 的闭式表达式，用第一类 Chebyshev 多项式 $T_{k}$ 表示，以及\n- 保证 $\\|I - A p_{m}(A)\\|_{2} \\le \\delta$ 的最小次数 $m$ (作为 $a$、$b$ 和 $\\delta$ 的函数) 的闭式表达式。\n\n最终答案必须是单一的闭式解析表达式。如果报告多个量，请使用 $\\mathrm{pmatrix}$ 环境将它们表示为单个行矩阵。不需要进行数值计算。", "solution": "用户希望我解决一个数值分析问题。\n用户希望我解决一个数值线性代数问题。\n用户希望我解决一个关于多项式预处理的问题。\n\n**问题验证**\n\n**第一步：提取已知条件**\n- $A \\in \\mathbb{R}^{n \\times n}$ 是一个对称正定 (SPD) 矩阵。\n- $A$ 的谱 $\\sigma(A)$ 包含在区间 $[a, b]$ 内，其中 $0  a \\le \\lambda_{\\min}(A) \\le \\lambda_{\\max}(A) \\le b$。\n- 寻求一个 $m$ 次多项式预处理器 $p_m$。\n- 目标是构造 $p_m$，使得预处理后矩阵的算子 2-范数满足 $\\|I - A p_{m}(A)\\|_{2} \\le \\delta$，其中 $\\delta \\in (0,1)$ 是给定的缩减因子。\n- 推导必须使用：谱定理、谱映射性质以及第一类 Chebyshev 多项式 $T_k(x)$ 在 $[-1,1]$ 上的极小极大性质。\n- 推导过程必须涉及一个从 $[a,b]$ 到 $[-1,1]$ 的仿射映射，并对辅助多项式 $q(\\lambda) = \\lambda p_m(\\lambda)$ 施加约束 $q(0)=0$。\n- 要求输出预处理器多项式 $p_m(\\lambda)$ 和保证范数缩减的最小次数 $m$ 的闭式表达式。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学性**：该问题是数值线性代数中的一个标准基础课题，特别是在线性系统迭代求解器的构造方面。所有概念——SPD 矩阵、特征值、多项式预处理、Chebyshev 多项式和谱界——都是完善且严格定义的。所提出的方法反映了经典的 Chebyshev 迭代和预处理理论。该问题在科学和数学上是合理的。\n- **适定性**：该问题是适定的。它旨在明确的约束下最小化一个最大值（一个极小极大问题）。Chebyshev 多项式的极小极大性质确保了对于这种问题结构，存在唯一的最优多项式解。\n- **客观性**：该问题以精确的数学语言陈述，没有任何主观性、模糊性或非技术性术语。\n- 该问题是完整的、一致的、可形式化的。未检测到任何缺陷。\n\n**第三步：结论与行动**\n该问题是有效的。将提供一个完整的、有理有据的解答。\n\n**解答**\n\n目标是找到一个 $m$ 次多项式 $p_m$，使得残差算子 $R(A) = I - A p_m(A)$ 的算子 2-范数最小。由于 $A$ 是对称的，它可以酉对角化，并且 $A$ 的任何多项式函数的算子 2-范数由该多项式在 $A$ 的谱 $\\sigma(A)$ 上的最大绝对值决定。\n$$\n\\|I - A p_m(A)\\|_{2} = \\max_{\\lambda \\in \\sigma(A)} |1 - \\lambda p_m(\\lambda)|\n$$\n我们定义残差多项式 $R_{m+1}(\\lambda) = 1 - \\lambda p_m(\\lambda)$。由于 $p_m(\\lambda)$ 是一个 $m$ 次多项式，$R_{m+1}(\\lambda)$ 是一个次数至多为 $m+1$ 的多项式。此外，根据其定义，$R_{m+1}(0) = 1 - 0 \\cdot p_m(0) = 1$。问题要求 $q(\\lambda) = \\lambda p_m(\\lambda)$ 满足 $q(0)=0$，这意味着 $R_{m+1}(0) = 1 - q(0) = 1$。因此 $R_{m+1}(\\lambda)$ 的次数恰好是 $m+1$。\n\n由于除了 $\\sigma(A) \\subseteq [a,b]$ 之外，谱 $\\sigma(A)$ 是未知的，我们必须通过最小化 $|R_{m+1}(\\lambda)|$ 在整个区间 $[a,b]$ 上的最大值来解决一个更保守的问题：\n$$\n\\min_{p_m \\in \\mathcal{P}_m} \\max_{\\lambda \\in [a,b]} |1 - \\lambda p_m(\\lambda)| = \\min_{R_{m+1} \\in \\mathcal{P}_{m+1}, R_{m+1}(0)=1} \\max_{\\lambda \\in [a,b]} |R_{m+1}(\\lambda)|\n$$\n其中 $\\mathcal{P}_k$ 是次数至多为 $k$ 的多项式空间。\n\n这是一个经典的极小极大问题。其解法是通过将其与在区间 $[-1,1]$ 上具有类似最优性质的第一类 Chebyshev 多项式 $T_k(x)$ 相关联来找到。我们首先执行一个仿射变换，将区间 $\\lambda \\in [a,b]$ 映射到 $x \\in [-1,1]$。令 $x = c_1 \\lambda + c_2$。\n对于 $\\lambda=a$，我们设置 $x=-1$：$-1 = c_1 a + c_2$。\n对于 $\\lambda=b$，我们设置 $x=1$：$1 = c_1 b + c_2$。\n求解这个关于 $c_1$ 和 $c_2$ 的线性方程组，得到：\n$c_1 = \\frac{2}{b-a}$ 和 $c_2 = -\\frac{a+b}{b-a}$。\n因此，变换为 $x(\\lambda) = \\frac{2\\lambda - (a+b)}{b-a}$。逆变换为 $\\lambda(x) = \\frac{b-a}{2}x + \\frac{a+b}{2}$。\n\n约束 $R_{m+1}(0)=1$ 是在点 $\\lambda=0$ 上，该点在区间 $[a,b]$ 之外，因为 $A$ 是 SPD ($a>0$)。我们必须在变换后的坐标系中找到对应的点 $x_0$：\n$$\nx_0 = x(0) = \\frac{-(a+b)}{b-a}\n$$\n由于 $b>a>0$，我们有 $a+b > 0$ 和 $b-a > 0$，所以 $x_0  -1$。\n\n问题现在转化为找到一个次数为 $m+1$ 的多项式 $P_{m+1}(x)$，使得 $P_{m+1}(x_0)=1$ 且其在 $[-1,1]$ 上的最大绝对值最小化。Chebyshev 多项式的极小极大性质表明，该问题的解由一个经过缩放的 Chebyshev 多项式给出：\n$$\nP_{m+1}(x) = \\frac{T_{m+1}(x)}{T_{m+1}(x_0)}\n$$\n该多项式在 $[-1,1]$ 上的最大值为 $\\frac{\\max_{x \\in [-1,1]}|T_{m+1}(x)|}{|T_{m+1}(x_0)|} = \\frac{1}{|T_{m+1}(x_0)|}$。\n\n变换回 $\\lambda$ 变量，最优残差多项式为：\n$$\nR_{m+1}(\\lambda) = P_{m+1}(x(\\lambda)) = \\frac{T_{m+1}\\left(\\frac{2\\lambda - (a+b)}{b-a}\\right)}{T_{m+1}\\left(\\frac{-(a+b)}{b-a}\\right)}\n$$\n根据定义 $R_{m+1}(\\lambda) = 1 - \\lambda p_m(\\lambda)$，我们可以求解预处理器多项式 $p_m(\\lambda)$。由于 $R_{m+1}(0)=1$，多项式 $1-R_{m+1}(\\lambda)$ 在 $\\lambda=0$ 处有一个根，这确保了 $p_m(\\lambda)$ 是一个 $m$ 次多项式。\n$$\np_m(\\lambda) = \\frac{1 - R_{m+1}(\\lambda)}{\\lambda} = \\frac{1}{\\lambda} \\left( 1 - \\frac{T_{m+1}\\left(\\frac{2\\lambda - (a+b)}{b-a}\\right)}{T_{m+1}\\left(-\\frac{a+b}{b-a}\\right)} \\right)\n$$\n这是 $m$ 次预处理器多项式的闭式表达式。\n\n接下来，我们求保证范数缩减 $\\|I - A p_m(A)\\|_2 \\le \\delta$ 的最小次数 $m$。\n保证的缩减由最优残差多项式在 $[a,b]$ 上的最大值给出：\n$$\n\\|I - A p_m(A)\\|_2 \\le \\max_{\\lambda \\in [a,b]} |R_{m+1}(\\lambda)| = \\frac{1}{|T_{m+1}(x_0)|} = \\frac{1}{\\left|T_{m+1}\\left(-\\frac{a+b}{b-a}\\right)\\right|}\n$$\n我们要求这个上界小于或等于 $\\delta$：\n$$\n\\frac{1}{\\left|T_{m+1}\\left(-\\frac{a+b}{b-a}\\right)\\right|} \\le \\delta \\quad \\implies \\quad \\left|T_{m+1}\\left(-\\frac{a+b}{b-a}\\right)\\right| \\ge \\frac{1}{\\delta}\n$$\n对于 $|x| \\ge 1$，Chebyshev 多项式有表达式 $T_k(x) = \\cosh(k \\cdot \\mathrm{arccosh}(x))$。由于 $x_0 = -\\frac{a+b}{b-a}  -1$，对于 $x \\le -1$，我们使用恒等式 $T_k(x) = (-1)^k \\cosh(k \\cdot \\mathrm{arccosh}(-x))$。因此， $|T_{m+1}(x_0)| = \\cosh((m+1) \\cdot \\mathrm{arccosh}(-x_0))$。\n不等式变为：\n$$\n\\cosh\\left((m+1) \\cdot \\mathrm{arccosh}\\left(\\frac{a+b}{b-a}\\right)\\right) \\ge \\frac{1}{\\delta}\n$$\n由于 $\\cosh$ 对于非负参数是增函数，且对于 $y \\ge 1$ 有 $\\mathrm{arccosh}(y) \\ge 0$，我们可以对两边取 $\\mathrm{arccosh}$：\n$$\n(m+1) \\cdot \\mathrm{arccosh}\\left(\\frac{a+b}{b-a}\\right) \\ge \\mathrm{arccosh}\\left(\\frac{1}{\\delta}\\right)\n$$\n解出 $m+1$：\n$$\nm+1 \\ge \\frac{\\mathrm{arccosh}(1/\\delta)}{\\mathrm{arccosh}\\left(\\frac{a+b}{b-a}\\right)}\n$$\n由于次数 $m$ 必须是整数，$m+1$ 必须是满足此条件的最小整数。因此，$m+1$ 的最小整数值是右侧表达式的向上取整。\n$$\nm+1 = \\left\\lceil \\frac{\\mathrm{arccosh}(1/\\delta)}{\\mathrm{arccosh}\\left(\\frac{a+b}{b-a}\\right)} \\right\\rceil\n$$\n那么最小次数 $m$ 是：\n$$\nm = \\left\\lceil \\frac{\\mathrm{arccosh}(1/\\delta)}{\\mathrm{arccosh}\\left(\\frac{a+b}{b-a}\\right)} \\right\\rceil - 1\n$$\n这给出了实现期望的缩减因子 $\\delta$ 所需的最小非负整数次数。\n\n两个要求的表达式是 $p_m(\\lambda)$ 的公式和最小次数 $m$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{\\lambda} \\left( 1 - \\frac{T_{m+1}\\left(\\frac{2\\lambda - a - b}{b-a}\\right)}{T_{m+1}\\left(-\\frac{a+b}{b-a}\\right)} \\right)  \\left\\lceil \\frac{\\mathrm{arccosh}(1/\\delta)}{\\mathrm{arccosh}\\left(\\frac{a+b}{b-a}\\right)} \\right\\rceil - 1 \\end{pmatrix}}\n$$", "id": "3565775"}, {"introduction": "从理论走向更实际的应用场景，本练习探讨了当仅有部分谱信息（如通过初步的Lanczos迭代得到的里兹值）时如何设计预处理器。这个问题引入了一种强大的启发式方法：通过在这些近似的离群特征值处设置多项式的根来“抑制”相关的慢收敛模式，从而加速求解过程。[@problem_id:3565786]", "problem": "考虑一个大型、稀疏、实对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$。根据应用背景，已知其谱主要分布在区间 $[0.8, 1.2]$ 内，只有少数离群特征值在此主体范围之外。短暂运行兰索斯过程得到两个近似的里兹值 $\\theta_{1} = 0.2$ 和 $\\theta_{2} = 1.8$，它们指出了若不加处理将导致收敛缓慢的方向。你打算在启动如共轭梯度(CG)法或广义最小残差(GMRES)法等克雷洛夫方法之前，应用一轮以残差变换 $r_{\\text{new}} = s(A) r_{\\text{old}}$ 形式出现的多项式预处理，其中 $s$ 是一个实多项式。\n\n从以下基本依据出发：\n- 在由多项式 $s$ 导出的定常残差变换中，新残差为 $r_{\\text{new}} = s(A) r_{\\text{old}}$，因此对每个特征分量的作用是乘以标量 $s(\\lambda)$，其中 $\\lambda$ 是 $A$ 的一个特征值。\n- 由兰索斯过程计算出的里兹值近似了极端特征值，并指出了通过在这些近似特征值处设置 $s$ 的根来进行目标阻尼可以取得效果的方向。\n- 选择 $s(0) = 1$ 与类似理查森阻尼因子的乘积形式 $s(\\lambda) = \\prod_{j} (1 - \\alpha_{j} \\lambda)$ 相一致，并且避免了会对应于非多项式逆的平凡解 $s \\equiv 0$。\n\n构建一个3次残差多项式 $s(\\lambda)$，使其满足 $s(0)=1$ 并在两个给定的里兹值 $\\theta_1$ 和 $\\theta_2$ 处设置单根，以阻尼相关联的方向。利用剩余的自由度，通过在两个权重相等的代表性主体谱点 $\\lambda_{3} = 0.9$ 和 $\\lambda_{4} = 1.1$ 上最小化一个离散最小二乘目标来确定 $s$。也就是说，在形如\n$$\ns(\\lambda) = \\bigl(1 - \\tfrac{\\lambda}{\\theta_{1}}\\bigr)\\bigl(1 - \\tfrac{\\lambda}{\\theta_{2}}\\bigr)\\bigl(1 + \\mu \\lambda\\bigr),\n$$\n的多项式中，选择标量 $\\mu \\in \\mathbb{R}$ 来最小化\n$$\nJ(\\mu) = \\bigl(s(0.9)\\bigr)^{2} + \\bigl(s(1.1)\\bigr)^{2}.\n$$\n\n基于次数预算和对里兹值不准确性的鲁棒性，解释并论证你在 $\\theta_{1}$ 和 $\\theta_{2}$ 处根的重数的选择。然后，计算并报告最优多项式 $s(\\lambda)$ 的最终闭式表达式作为你的答案。无需四舍五入；请提供精确的解析表达式。", "solution": "问题陈述经评估是有效的。它在科学上基于数值线性代数中迭代法的多项式预处理的既定理论。该问题是适定的，提供了足以唯一确定该多项式的约束条件，并以客观、明确的语言表述。所有必要的数据均已提供。\n\n该问题要求为涉及对称正定矩阵 $A$ 的线性系统构建一个3次多项式预处理器 $s(\\lambda)$。该多项式将用作残差变换 $r_{\\text{new}} = s(A) r_{\\text{old}}$。构建过程受以下几个约束条件的指导：\n1. 多项式 $s(\\lambda)$ 的次数必须为3。\n2. 它必须满足归一化条件 $s(0) = 1$。\n3. 它必须在两个近似的离群特征值（里兹值）$\\theta_{1} = 0.2$ 和 $\\theta_{2} = 1.8$ 的位置有根，以阻尼相应的缓慢收敛的特征模态。\n4. 剩余的自由度必须用于在由两个点 $\\lambda_{3} = 0.9$ 和 $\\lambda_{4} = 1.1$ 近似的谱主体上最小化多项式的幅值。\n\n首先，我们讨论根的重数的选择。该多项式的总次数为3。我们已知在两个特定位置 $\\theta_{1}$ 和 $\\theta_{2}$ 需要设置根以抑制误差分量。为这两个位置各分配一个单根，即包含因子 $(\\lambda - \\theta_{1})$ 和 $(\\lambda - \\theta_{2})$，会消耗掉三个可用次数中的两个。这是最平衡的方法，因为它同等对待了两个已识别的离群模态。这留下了一个自由度，可用于进一步塑造多项式，在本例中，即在推测大部分特征值所在的区间上最小化其幅值。使用更高的重数，例如在 $\\theta_{1}$ 处设置二重根而在 $\\theta_{2}$ 处无根，将是一种不平衡的策略，因为它忽略了一个已知的有问题的模态。此外，从鲁棒性的角度来看，通常首选单根。里兹值是真实特征值的近似值。一个高阶根会在里兹值处为 $|s(\\lambda)|$ 创造一个非常尖锐和深的极小值，如果里兹值不是对真实特征值的高度精确近似，这可能效果不佳。由单根提供的更宽的零点区域可以对里兹值的不准确性更具容忍度。\n\n问题提出的 $s(\\lambda)$ 形式已经包含了根的条件和归一化条件 $s(0)=1$：\n$$\ns(\\lambda) = \\left(1 - \\frac{\\lambda}{\\theta_{1}}\\right)\\left(1 - \\frac{\\lambda}{\\theta_{2}}\\right)\\left(1 + \\mu \\lambda\\right)\n$$\n这是一个3次多项式。在 $\\lambda=0$ 处求值得 $s(0)=(1-0)(1-0)(1+0) = 1$，满足归一化条件。前两个因子确保了 $s(\\theta_{1}) = 0$ 和 $s(\\theta_{2}) = 0$。参数 $\\mu$ 对应于剩余的自由度。\n\n我们已知 $\\theta_{1} = 0.2$ 和 $\\theta_{2} = 1.8$。将这些值代入 $s(\\lambda)$ 的表达式中：\n$$\ns(\\lambda) = \\left(1 - \\frac{\\lambda}{0.2}\\right)\\left(1 - \\frac{\\lambda}{1.8}\\right)\\left(1 + \\mu \\lambda\\right) = (1 - 5\\lambda)\\left(1 - \\frac{10\\lambda}{18}\\right)(1 + \\mu\\lambda) = (1 - 5\\lambda)\\left(1 - \\frac{5}{9}\\lambda\\right)(1 + \\mu\\lambda)\n$$\n选择参数 $\\mu$ 是为了最小化目标函数 $J(\\mu) = (s(0.9))^{2} + (s(1.1))^{2}$。我们在点 $\\lambda = 0.9$ 和 $\\lambda = 1.1$ 处计算 $s(\\lambda)$ 的值。\n\n对于 $\\lambda = 0.9$：\n$$\ns(0.9) = \\left(1 - 5(0.9)\\right)\\left(1 - \\frac{5}{9}(0.9)\\right)\\left(1 + \\mu(0.9)\\right) = (1 - 4.5)(1 - 0.5)(1 + 0.9\\mu) = (-3.5)(0.5)(1 + 0.9\\mu) = -1.75(1 + 0.9\\mu)\n$$\n将系数写成分数形式，$-1.75 = -\\frac{7}{4}$ 且 $0.9 = \\frac{9}{10}$。所以，$s(0.9) = -\\frac{7}{4}(1 + \\frac{9}{10}\\mu)$。\n\n对于 $\\lambda = 1.1$：\n$$\ns(1.1) = \\left(1 - 5(1.1)\\right)\\left(1 - \\frac{5}{9}(1.1)\\right)\\left(1 + \\mu(1.1)\\right) = (1 - 5.5)\\left(1 - \\frac{5.5}{9}\\right)(1 + 1.1\\mu)\n$$\n$$\ns(1.1) = (-4.5)\\left(\\frac{9 - 5.5}{9}\\right)(1 + 1.1\\mu) = (-4.5)\\left(\\frac{3.5}{9}\\right)(1 + 1.1\\mu) = (-0.5)(3.5)(1 + 1.1\\mu) = -1.75(1 + 1.1\\mu)\n$$\n使用分数，$-1.75 = -\\frac{7}{4}$ 且 $1.1 = \\frac{11}{10}$。所以，$s(1.1) = -\\frac{7}{4}(1 + \\frac{11}{10}\\mu)$。\n\n目标函数为：\n$$\nJ(\\mu) = \\left(-\\frac{7}{4}\\left(1 + \\frac{9}{10}\\mu\\right)\\right)^{2} + \\left(-\\frac{7}{4}\\left(1 + \\frac{11}{10}\\mu\\right)\\right)^{2} = \\left(\\frac{7}{4}\\right)^{2} \\left[ \\left(1 + \\frac{9}{10}\\mu\\right)^{2} + \\left(1 + \\frac{11}{10}\\mu\\right)^{2} \\right]\n$$\n为了找到最小值，我们可以忽略正常数因子 $(\\frac{7}{4})^{2}$，转而最小化函数 $\\tilde{J}(\\mu) = (1 + \\frac{9}{10}\\mu)^{2} + (1 + \\frac{11}{10}\\mu)^{2}$。我们通过将其关于 $\\mu$ 的导数设为零来找到临界点：\n$$\n\\frac{d\\tilde{J}}{d\\mu} = 2\\left(1 + \\frac{9}{10}\\mu\\right)\\left(\\frac{9}{10}\\right) + 2\\left(1 + \\frac{11}{10}\\mu\\right)\\left(\\frac{11}{10}\\right) = 0\n$$\n两边除以2：\n$$\n\\frac{9}{10}\\left(1 + \\frac{9}{10}\\mu\\right) + \\frac{11}{10}\\left(1 + \\frac{11}{10}\\mu\\right) = 0\n$$\n$$\n\\frac{9}{10} + \\frac{81}{100}\\mu + \\frac{11}{10} + \\frac{121}{100}\\mu = 0\n$$\n合并同类项：\n$$\n\\left(\\frac{9}{10} + \\frac{11}{10}\\right) + \\left(\\frac{81}{100} + \\frac{121}{100}\\right)\\mu = 0\n$$\n$$\n\\frac{20}{10} + \\frac{202}{100}\\mu = 0\n$$\n$$\n2 + \\frac{202}{100}\\mu = 0\n$$\n$$\n\\frac{202}{100}\\mu = -2 \\implies \\mu = -2 \\cdot \\frac{100}{202} = -\\frac{200}{202} = -\\frac{100}{101}\n$$\n二阶导数为 $\\frac{d^{2}\\tilde{J}}{d\\mu^{2}} = 2(\\frac{9}{10})^2 + 2(\\frac{11}{10})^2 > 0$，这证实了此 $\\mu$ 值对应一个最小值。\n\n现在我们将这个最优值 $\\mu = -\\frac{100}{101}$ 代回到 $s(\\lambda)$ 的表达式中：\n$$\ns(\\lambda) = (1 - 5\\lambda)\\left(1 - \\frac{5}{9}\\lambda\\right)\\left(1 - \\frac{100}{101}\\lambda\\right)\n$$\n这就是满足所有给定条件的最优3次残差多项式的最终闭式表达式。", "answer": "$$\\boxed{s(\\lambda) = (1 - 5\\lambda)\\left(1 - \\frac{5}{9}\\lambda\\right)\\left(1 - \\frac{100}{101}\\lambda\\right)}$$", "id": "3565786"}, {"introduction": "最后的练习深入探讨了与现代高性能计算相关的前沿实现策略。您将面临构建和分析一个混合精度求解器的挑战，其中计算密集型的预处理器在低精度格式（`binary16`）下应用，以加速高精度（`binary64`）的Krylov求解器。此练习突显了在计算速度、数值稳定性和最终收敛性之间的权衡。[@problem_id:3565774]", "problem": "考虑使用左预处理共轭梯度法求解对称正定线性系统 $A x = b$，其中所有外部 Krylov 运算均以 binary64 (IEEE 754 双精度) 执行，而预处理器应用则完全以 binary16 (IEEE 754 半精度) 执行。您将实现一个多项式预处理器 $p_m(A)$，它通过截断由线性算子 $T = I - \\mu^{-1} A$ 生成的 Neumann 级数来近似 $A^{-1}$，其中参数 $\\mu > \\lambda_{\\max}(A)$。该多项式对标量 x 的定义为\n$$\np_m(x) = \\mu^{-1} \\sum_{k=0}^{m} \\left(1 - x/\\mu\\right)^k,\n$$\n对矩阵则通过 A 的相同多项式定义为 $p_m(A)$。对于任何 $x \\in (0,\\mu)$，无限级数满足恒等式 $\\mu^{-1} \\sum_{k=0}^{\\infty} (1 - x/\\mu)^k = x^{-1}$，因此 $p_m(x)$ 近似于 $x^{-1}$，其截断误差随 m 呈几何级数衰减。\n\n使用以下基本模型和事实：\n- 舍入模型：对于给定精度下单位舍入误差为 u 的浮点运算 $\\mathrm{fl}(a \\,\\mathrm{op}\\, b)$，模型为 $\\mathrm{fl}(a \\,\\mathrm{op}\\, b) = (a \\,\\mathrm{op}\\, b)(1 + \\delta)$，其中 $|\\delta| \\le u$。对于 k 个此类运算的序列，使用标准界 $\\gamma_k(u) = \\dfrac{k u}{1 - k u}$。\n- Binary16 (IEEE 754 半精度) 的单位舍入误差为 $u_{16} = 2^{-11}$。\n- 预处理共轭梯度收敛界：如果 $M$ 是对称正定的，并且 $M A$ 也是对称正定的，条件数为 $\\kappa = \\kappa_2(MA)$，则 $M^{-1}$-能量范数下的误差界意味着残差界的形式为\n$$\n\\frac{\\|r_k\\|_2}{\\|r_0\\|_2} \\le 2 \\left(\\frac{\\sqrt{\\kappa} - 1}{\\sqrt{\\kappa} + 1}\\right)^k,\n$$\n其中 $r_k = b - A x_k$。\n\n您必须：\n1. 按如下方式构造具有指定谱界的测试矩阵 $A$。对于每个测试用例，给定整数 $n \\ge 2$、谱下界 $\\lambda_{\\min} = a$ 和谱上界 $\\lambda_{\\max} = b$，通过对具有指定种子的高斯随机矩阵进行 QR 分解来生成一个 $n \\times n$ 的正交矩阵 $Q$，并设置\n$$\nA = Q \\, \\mathrm{diag}\\big(\\lambda_1, \\ldots, \\lambda_n\\big) Q^\\top,\n$$\n其中 $\\lambda_i$ 在 $[a,b]$ 中线性间隔分布。令 $b$（右端项）为使用相同种子的高斯随机向量。确保将 $A$ 对称化为 $(A + A^\\top)/2$ 以消除数值不对称性。\n2. 在 binary64 中实现左预处理共轭梯度算法，其中预处理器 $M \\approx p_m(A)$ 通过迭代递推式完全在 binary16 中应用于向量 $v$：\n$$\nz = p_m(A) v = \\mu^{-1} \\sum_{k=0}^{m} T^k v, \\quad T = I - \\mu^{-1} A.\n$$\n在 binary16 中计算 $T$ 和部分和中涉及的每个矩阵向量乘积及所有向量更新，并在返回给外部方法之前将最终结果转换回 binary64。\n3. 使用混合精度误差模型，预测收敛性和稳定性：\n   - 截断误差：对于 $x \\in [a,b]$ 和 $\\mu > b$，乘法意义上的最大截断误差满足\n     $$\n     \\delta_{\\mathrm{poly}} = \\max_{x \\in [a,b]} \\left|1 - x \\, p_m(x)\\right| = \\left(1 - \\frac{a}{\\mu}\\right)^{m+1}.\n     $$\n   - Binary16 求值误差：使用模型来界定在 binary16 中计算 $z = p_m(A) v$ 的相对误差\n     $$\n     \\|z - p_m(A) v\\|_2 \\le \\gamma_{\\mathrm{eval}} \\, \\|p_m(A)\\|_2 \\, \\|v\\|_2, \\quad \\gamma_{\\mathrm{eval}} = \\gamma_{3(m+1)}(u_{16}),\n     $$\n     该模型汇总了每个多项式阶段一次矩阵向量乘积和两次向量更新的影响。\n   - 预处理器总乘法误差界：将预处理算子建模为\n     $$\n     M A = \\big(p_m(A) + E\\big) A = I + \\Delta, \\quad \\|\\Delta\\|_2 \\le \\delta_{\\mathrm{total}}, \\quad \\delta_{\\mathrm{total}} = \\delta_{\\mathrm{poly}} + \\gamma_{\\mathrm{eval}}.\n     $$\n     当且仅当 $\\delta_{\\mathrm{total}}  1$ 时预测为稳定，这意味着 $M A$ 的谱位于 $[1 - \\delta_{\\mathrm{total}}, 1 + \\delta_{\\mathrm{total}}] \\subset (0,\\infty)$ 内，因此 $M A$ 是正定的。\n   - 预测的条件数和 Krylov 收缩：使用\n     $$\n     \\kappa_{\\mathrm{eff}} \\le \\frac{1 + \\delta_{\\mathrm{total}}}{1 - \\delta_{\\mathrm{total}}}, \\quad \\varrho_{\\mathrm{pred}} = \\frac{\\sqrt{\\kappa_{\\mathrm{eff}}} - 1}{\\sqrt{\\kappa_{\\mathrm{eff}}} + 1}.\n     $$\n     对于给定的容差 $\\tau \\in (0,1)$，预测迭代次数\n     $$\n     k_{\\mathrm{pred}} = \\left\\lceil \\frac{\\log(\\tau/2)}{\\log(\\varrho_{\\mathrm{pred}})} \\right\\rceil,\n     $$\n     前提是 $\\delta_{\\mathrm{total}}  1$。如果 $\\delta_{\\mathrm{total}} \\ge 1$，则声明为不稳定，并将 $k_{\\mathrm{pred}}$ 设置为一个较大的上限值。\n4. 运行实际的左预处理共轭梯度法，使用所述的混合精度预处理器，并计算达到 $\\|r_k\\|_2 / \\|r_0\\|_2 \\le \\tau$ 所需的实际迭代次数 $k_{\\mathrm{act}}$。同时记录一个布尔稳定性标志，如果方法在没有崩溃（无非正曲率和无非有限算术）的情况下在给定的最大迭代次数内达到容差，则该标志为真，否则为假。\n\n使用以下固定的测试套件。对于每个案例，使用元组 $(n,a,b,m,\\eta,\\tau,\\mathrm{seed})$，设置 $\\mu = (1 + \\eta) b$，最大迭代次数上限为 $k_{\\max} = 1000$：\n- 案例 1：$(60, 10.0, 100.0, 6, 0.10, 10^{-8}, 0)$。\n- 案例 2：$(60, 10.0, 100.0, 12, 0.10, 10^{-8}, 1)$。\n- 案例 3：$(80, 5.0, 200.0, 18, 0.05, 10^{-8}, 2)$。\n- 案例 4：$(80, 5.0, 200.0, 30, 0.05, 10^{-8}, 3)$。\n\n您的程序必须：\n- 根据每个案例构造 $A$ 和 $b$，执行预测模型以计算 $(k_{\\mathrm{pred}}, \\mathrm{stable}_{\\mathrm{pred}})$，并运行实际方法以计算 $(k_{\\mathrm{act}}, \\mathrm{stable}_{\\mathrm{act}})$。\n- 生成单行输出，该输出为一个逗号分隔的扁平列表，其中按顺序包含每个测试案例 $i=1,\\dots,4$ 的四元组 $[k_{\\mathrm{pred}}^{(i)}, \\mathrm{stable}_{\\mathrm{pred}}^{(i)}, k_{\\mathrm{act}}^{(i)}, \\mathrm{stable}_{\\mathrm{act}}^{(i)}]$，并在各案例间连接。因此，最终输出必须有 16 个条目，并作为单行的 Python 列表字面量打印，例如 $[x_1,x_2,x_3,x_4,\\dots,x_{16}]$。\n\n不涉及物理单位或角度单位。所有答案均为纯数字或布尔值。确保所有计算和输出都基于给定的种子和参数是确定性的，并且最终程序不需要任何输入。", "solution": "根据指定标准对问题进行验证。\n\n### 步骤 1：提取给定信息\n-   **线性系统：** $A x = b$，其中 $A$ 为对称正定 (SPD) 矩阵。\n-   **求解器：** `binary64` 精度的左预处理共轭梯度 (PCG) 法。\n-   **预处理器：** $M^{-1} \\approx p_m(A)$，其中 $p_m(x) = \\mu^{-1} \\sum_{k=0}^{m} \\left(1 - x/\\mu\\right)^k$。预处理器应用以 `binary16` 精度执行。\n-   **参数 $\\mu$**：$\\mu = (1 + \\eta) b$，其中 $b = \\lambda_{\\max}(A)$。\n-   **矩阵构造：** 对于给定的规模 $n$、谱界 $[a, b]$ 和随机种子， $A = Q \\, \\mathrm{diag}\\big(\\lambda_1, \\ldots, \\lambda_n\\big) Q^\\top$。特征值 $\\lambda_i$ 在 $[a,b]$ 内线性间隔分布，$Q$ 是通过对一个 $n \\times n$ 高斯随机矩阵进行 QR 分解得到的正交矩阵。$A$ 必须显式对称化为 $(A + A^\\top)/2$。\n-   **向量构造：** 右端项 $b$ 是一个 $n \\times 1$ 的高斯随机向量，使用与 $A$ 相同的种子生成。\n-   **浮点模型：**\n    -   `binary16` 的单位舍入误差：$u_{16} = 2^{-11}$。\n    -   k 个运算序列的标准误差模型：$\\gamma_k(u) = \\frac{k u}{1 - k u}$。\n-   **预测模型：**\n    -   多项式截断误差：$\\delta_{\\mathrm{poly}} = \\left(1 - \\frac{a}{\\mu}\\right)^{m+1}$。\n    -   预处理器求值误差界：$\\gamma_{\\mathrm{eval}} = \\gamma_{3(m+1)}(u_{16})$。\n    -   预处理算子的总相对误差：$\\delta_{\\mathrm{total}} = \\delta_{\\mathrm{poly}} + \\gamma_{\\mathrm{eval}}$。\n    -   如果 $\\delta_{\\mathrm{total}}  1$，则预测为稳定。\n    -   有效条件数：$\\kappa_{\\mathrm{eff}} \\le \\frac{1 + \\delta_{\\mathrm{total}}}{1 - \\delta_{\\mathrm{total}}}$。\n    -   预测收敛因子：$\\varrho_{\\mathrm{pred}} = \\frac{\\sqrt{\\kappa_{\\mathrm{eff}}} - 1}{\\sqrt{\\kappa_{\\mathrm{eff}}} + 1}$。\n    -   预测迭代次数：对于容差 $\\tau$，$k_{\\mathrm{pred}} = \\left\\lceil \\frac{\\log(\\tau/2)}{\\log(\\varrho_{\\mathrm{pred}})} \\right\\rceil$。如果不稳定，则将 $k_{\\mathrm{pred}}$ 设置为上限 $k_{\\max} = 1000$。\n-   **执行任务：**\n    -   运行 PCG 算法，找到达到 $\\|r_k\\|_2 / \\|r_0\\|_2 \\le \\tau$ 所需的实际迭代次数 $k_{\\mathrm{act}}$。\n    -   记录实际稳定性 $\\mathrm{stable}_{\\mathrm{act}}$，如果方法在 $k_{\\max}$ 次迭代内收敛且无崩溃（非正曲率或非有限算术），则为真。\n-   **测试案例：**\n    -   案例 1：$(n,a,b,m,\\eta,\\tau,\\mathrm{seed}) = (60, 10.0, 100.0, 6, 0.10, 10^{-8}, 0)$。\n    -   案例 2：$(60, 10.0, 100.0, 12, 0.10, 10^{-8}, 1)$。\n    -   案例 3：$(80, 5.0, 200.0, 18, 0.05, 10^{-8}, 2)$。\n    -   案例 4：$(80, 5.0, 200.0, 30, 0.05, 10^{-8}, 3)$。\n    -   最大迭代次数 $k_{\\max} = 1000$。\n\n### 步骤 2：使用提取的给定信息进行验证\n-   **科学基础：** 该问题牢固地植根于数值线性代数领域。它涉及混合精度计算、多项式预处理和迭代法（共轭梯度）等当代主题。所有概念、模型和算法都是该学科的标准内容。\n-   **适定性：** 问题是完全指定的。它提供了所有必要的参数、预测模型的明确公式以及数值实验的清晰步骤。目标是可量化且明确的。\n-   **客观性：** 问题以精确、正式的语言陈述，没有主观性或歧义。\n\n该问题未表现出任何无效性缺陷。误差模型虽然是复杂现实的简化，但作为问题定义的一部分被明确给出，用于预测分析，而非推导。它们的使用是建模练习的有效部分。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供完整的解决方案。\n\n### 解题推导\n\n每个测试案例的解决方案需要两个部分：基于理论模型的预测和数值实验的结果。\n\n#### 1. 预测模型\n\n对于每个具有参数 $(n, a, b, m, \\eta, \\tau, \\mathrm{seed})$ 的测试案例，我们首先计算预测的迭代次数 $k_{\\mathrm{pred}}$ 和稳定性 $\\mathrm{stable}_{\\mathrm{pred}}$。\n\nNeumann 级数的参数 $\\mu$ 定义为 $\\mu = (1 + \\eta) b$，其中 $b = \\lambda_{\\max}$。\n\n预测的关键在于估计预处理矩阵 $MA$ 的质量，其中 $M = p_m(A)$ 是多项式预处理器。$MA$ 与单位矩阵 $I$ 的偏差由 $\\|\\Delta\\|_2 = \\|MA-I\\|_2 \\le \\delta_{\\mathrm{total}}$ 界定。该总误差由两部分组成：\n\n-   **截断误差 ($\\delta_{\\mathrm{poly}}$)：** 此误差源于将 $A^{-1}$ 的无限 Neumann 级数在 m 次截断。乘法误差的模型由下式给出：\n    $$\n    1 - x \\, p_m(x) = 1 - x \\left( x^{-1} \\left(1 - \\left(1 - \\frac{x}{\\mu}\\right)^{m+1}\\right) \\right) = \\left(1 - \\frac{x}{\\mu}\\right)^{m+1}.\n    $$\n    由于 $1 - x/\\mu$ 是 $x$ 的递减函数，因此在 $A$ 的谱 $[a, b]$ 上的最大误差发生在最小特征值 $a = \\lambda_{\\min}$ 处。\n    $$\n    \\delta_{\\mathrm{poly}} = \\max_{x \\in [a,b]} \\left|1 - x \\, p_m(x)\\right| = \\left(1 - \\frac{a}{\\mu}\\right)^{m+1}.\n    $$\n\n-   **求值误差 ($\\gamma_{\\mathrm{eval}}$)：** 此误差源于使用 `binary16` 算术计算预处理器-向量乘积 $z = p_m(A)v$。问题提供了一个简化的前向误差模型，其中舍入误差的累积效应被汇总到单个参数 $\\gamma_{\\mathrm{eval}}$ 中。m 次多项式的求值涉及 $m+1$ 个阶段（每个 $T^k$ 幂对应一个阶段）。该模型将每个阶段归因于 3 个浮点运算，导致总共 $k = 3(m+1)$ 次运算。使用 k 次运算序列的标准界：\n    $$\n    \\gamma_{\\mathrm{eval}} = \\gamma_{3(m+1)}(u_{16}) = \\frac{3(m+1)u_{16}}{1 - 3(m+1)u_{16}}, \\quad \\text{其中 } u_{16} = 2^{-11}.\n    $$\n\n总误差界由这两个分量之和给出：$\\delta_{\\mathrm{total}} = \\delta_{\\mathrm{poly}} + \\gamma_{\\mathrm{eval}}$。\n\n-   **稳定性和条件数：** 预处理系统的稳定性要求 $MA$ 是正定的。如果 $MA$ 的谱有界且远离零，则模型可确保这一点。谱区间估计为 $[1 - \\delta_{\\mathrm{total}}, 1 + \\delta_{\\mathrm{total}}]$，这要求 $\\delta_{\\mathrm{total}}  1$。因此，当且仅当此条件成立时，$\\mathrm{stable}_{\\mathrm{pred}}$ 为真。如果稳定，有效条件数有界为：\n    $$\n    \\kappa_{\\mathrm{eff}} \\le \\frac{1 + \\delta_{\\mathrm{total}}}{1 - \\delta_{\\mathrm{total}}}.\n    $$\n-   **预测迭代次数 ($k_{\\mathrm{pred}}$)：** PCG 的收敛速率由 $\\kappa_{\\mathrm{eff}}$ 控制。预测的收敛因子为 $\\varrho_{\\mathrm{pred}} = (\\sqrt{\\kappa_{\\mathrm{eff}}} - 1) / (\\sqrt{\\kappa_{\\mathrm{eff}}} + 1)$。使用标准的 CG 误差界，达到相对残差容差 $\\tau$ 所需的迭代次数预测为：\n    $$\n    k_{\\mathrm{pred}} = \\left\\lceil \\frac{\\log(\\tau/2)}{\\log(\\varrho_{\\mathrm{pred}})} \\right\\rceil.\n    $$\n    如果模型预测不稳定 ($\\delta_{\\mathrm{total}} \\ge 1$)，我们设置 $k_{\\mathrm{pred}} = k_{\\max} = 1000$。\n\n#### 2. 数值实验\n\n这部分涉及实现指定的算法并在生成的测试数据上运行它。\n\n-   **测试数据生成：** 对于每个测试案例，我们生成一个 $n \\times n$ 矩阵 $A$ 和一个向量 $b$。\n    1.  使用指定的 `seed` 初始化一个随机数生成器。\n    2.  创建一个 $n \\times n$ 的矩阵，其元素从标准正态分布中抽取。\n    3.  对该矩阵进行 QR 分解，得到一个正交矩阵 $Q$。\n    4.  形成一个对角矩阵 $D$，其特征值 $\\lambda_1, \\dots, \\lambda_n$ 在 $[a,b]$ 内线性间隔分布。\n    5.  矩阵 $A$ 构造为 $A = Q D Q^\\top$。然后通过 $A \\leftarrow (A+A^\\top)/2$ 将其显式对称化，以消除任何浮点不对称性。\n    6.  向量 $b$ 生成为一个 $n \\times 1$ 的标准正态随机变量向量。所有这些操作都使用 `binary64` 浮点数。\n\n-   **混合精度预处理器应用：** 函数 `apply_preconditioner(v)` 实现 $M^{-1}v = p_m(A)v$ 的作用。\n    -   输入向量 $v$ 和矩阵 $A$ 均为 `binary64`。\n    -   在函数内部，$A$ 和 $v$ 被转换为 `binary16` (`np.float16`)。\n    -   多项式 $p_m(A)v = \\mu^{-1} \\sum_{k=0}^{m} (I - \\mu^{-1} A)^k v$ 被迭代求值。一种数值稳定的计算方法是：\n        令 $s = \\mathbf{0}$ 和 $w = v$。\n        对于 $k = 0, \\ldots, m$：\n            $s \\leftarrow s + w$\n            $w \\leftarrow w - \\mu^{-1} A w$\n        最终结果是 $\\mu^{-1}s$。关键是，这个迭代循环中的所有算术运算（向量加法、减法、矩阵向量乘积和标量向量乘法）都以 `binary16` 执行。\n    -   最终得到的向量在返回给 PCG 算法之前被转换回 `binary64`。\n\n-   **预处理共轭梯度：** 实现一个标准的左预处理 PCG 算法来求解 $M^{-1}Ax = M^{-1}b$。\n    -   其所有运算（点积、向量更新、与 $A$ 的矩阵向量乘积）均以 `binary64` 执行。\n    -   唯一的 `binary16` 计算被封装在对预处理器函数的调用中。\n    -   循环运行直到相对残差范数 $\\|r_k\\|_2/\\|r_0\\|_2$ 小于或等于 $\\tau$，或者直到达到最大迭代次数 $k_{\\max}=1000$。\n    -   在迭代过程中执行崩溃检查：非正曲率（$p_k^\\top A p_k \\le 0$ 或 $r_k^\\top z_k \\le 0$）或出现非有限数（`NaN` 或 `Inf`）。\n    -   $k_{\\mathrm{act}}$ 是执行的迭代次数。\n    -   $\\mathrm{stable}_{\\mathrm{act}}$ 设置为 `True`，如果方法在 $k_{\\max}$ 次迭代内收敛且无任何崩溃；否则为 `False`。\n\n通过对四个测试案例中的每一个执行这两个部分，我们获得了所需的四元组 $[k_{\\mathrm{pred}}, \\mathrm{stable}_{\\mathrm{pred}}, k_{\\mathrm{act}}, \\mathrm{stable}_{\\mathrm{act}}]$，然后将其格式化为最终输出。", "answer": "```\n[29,True,29,True,17,True,17,True,17,True,17,True,11,True,11,True]\n```", "id": "3565774"}]}