{"hands_on_practices": [{"introduction": "第一个实践是一项基础练习，旨在引导你完成对一个具有复特征值的简单 $2 \\times 2$ 矩阵计算其矩阵函数的过程。通过执行复舒尔分解并在特征值层面应用函数，你将具体理解该方法如何将矩阵运算与标量函数求值联系起来。这项练习 [@problem_id:3596559] 强化了理论与计算之间的联系。", "problem": "设 $B \\in \\mathbb{R}^{2 \\times 2}$ 由下式给出\n$$\nB \\;=\\; \\begin{pmatrix} 4  6 \\\\ -6  4 \\end{pmatrix}.\n$$\n考虑由主标量对数导出的主矩阵函数，即通过解析泛函演算定义的主矩阵对数 $\\log(B)$。仅使用 Schur 分解的第一性原理以及上三角矩阵上主矩阵函数的定义，计算标量\n$$\n\\operatorname{trace}\\big(\\log(B)\\big).\n$$\n您的方法必须从将 $B$ 转换为其复 Schur 形式开始，然后将标量函数应用于复特征值以获得 Schur 因子的函数，最后映射回实数运算以确定与共轭特征对对应的实 $2 \\times 2$ 块。将您的最终答案表示为单个闭式解析表达式。无需四舍五入。", "solution": "问题是计算给定 $2 \\times 2$ 实矩阵 $B$ 的主矩阵对数的迹。问题指定该方法必须基于复 Schur 分解。\n\n首先，我们对问题陈述进行验证。\n给定矩阵为 $B = \\begin{pmatrix} 4  6 \\\\ -6  4 \\end{pmatrix}$。这是一个 $\\mathbb{R}^{2 \\times 2}$ 中的矩阵。要应用的函数是主矩阵对数 $\\log(B)$。要计算的量是 $\\operatorname{trace}(\\log(B))$。方法是指定的：使用复 Schur 分解。\n该问题在科学上植根于数值线性代数，特别是矩阵函数理论。要定义矩阵的主对数，其特征值不能位于非正实轴 $(-\\infty, 0]$ 上。我们通过求解特征方程 $\\det(B - \\lambda I) = 0$ 来求 $B$ 的特征值。\n$$\n\\det\\begin{pmatrix} 4-\\lambda  6 \\\\ -6  4-\\lambda \\end{pmatrix} = (4-\\lambda)^2 - (6)(-6) = (4-\\lambda)^2 + 36 = 0\n$$\n这得到 $(4-\\lambda)^2 = -36$，所以 $4-\\lambda = \\pm\\sqrt{-36} = \\pm 6i$。\n特征值为 $\\lambda_1 = 4 - 6i$ 和 $\\lambda_2 = 4 + 6i$。\n由于两个特征值都不是非正实数，因此主对数对于 $B$ 的谱是良定义的，因此，主矩阵函数 $\\log(B)$ 是良定义的。因此，该问题在数学上和科学上都是合理的、适定的、客观的和完整的。我们可以继续进行求解。\n\n指定的方法从 $B$ 的复 Schur 分解开始，该分解指出任何方阵 $B$ 都可以写成 $B = UTU^*$，其中 $U$ 是一个酉矩阵，$T$ 是一个上三角矩阵。$T$ 的对角线元素是 $B$ 的特征值。由于矩阵 $B$ 是正规矩阵（满足 $BB^* = B^*B$），其 Schur 形式 $T$ 是一个对角矩阵，并且酉矩阵 $U$ 的列由 $B$ 的归一化特征向量构成。\n\n我们来求特征向量：\n对于 $\\lambda_1 = 4 - 6i$：\n$(B - \\lambda_1 I)v_1 = \\begin{pmatrix} 6i  6 \\\\ -6  6i \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$\n第一行意味着 $6ix + 6y = 0$，即 $y = -ix$。我们可以选择一个特征向量 $v_1 = \\begin{pmatrix} 1 \\\\ -i \\end{pmatrix}$。\n\n对于 $\\lambda_2 = 4 + 6i$：\n$(B - \\lambda_2 I)v_2 = \\begin{pmatrix} -6i  6 \\\\ -6  -6i \\end{pmatrix} \\begin{pmatrix} x \\\\ y \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$\n第一行意味着 $-6ix + 6y = 0$，即 $y = ix$。我们可以选择一个特征向量 $v_2 = \\begin{pmatrix} 1 \\\\ i \\end{pmatrix}$。\n\n接下来，我们对特征向量进行归一化，以构建酉矩阵 $U$：\n$u_1 = \\frac{v_1}{\\|v_1\\|_2} = \\frac{1}{\\sqrt{|1|^2 + |-i|^2}} \\begin{pmatrix} 1 \\\\ -i \\end{pmatrix} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -i \\end{pmatrix}$\n$u_2 = \\frac{v_2}{\\|v_2\\|_2} = \\frac{1}{\\sqrt{|1|^2 + |i|^2}} \\begin{pmatrix} 1 \\\\ i \\end{pmatrix} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ i \\end{pmatrix}$\n\n酉矩阵 $U$ 的列由这些归一化的特征向量构成：\n$U = \\begin{pmatrix} u_1  u_2 \\end{pmatrix} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1  1 \\\\ -i  i \\end{pmatrix}$。\nSchur 形式 $T = U^* B U$ 是一个对角矩阵，其对角线元素为对应的特征值：\n$T = \\begin{pmatrix} \\lambda_1  0 \\\\ 0  \\lambda_2 \\end{pmatrix} = \\begin{pmatrix} 4-6i  0 \\\\ 0  4+6i \\end{pmatrix}$。\n\nSchur 分解为 $B = UTU^*$，其中 $U$ 和 $T$ 如上所示。\n\n下一步是计算 $F = \\log(T)$。对于对角矩阵，这是通过将函数应用于每个对角元素来完成的。\n$$\nF = \\log(T) = \\begin{pmatrix} \\log(4-6i)  0 \\\\ 0  \\log(4+6i) \\end{pmatrix}\n$$\n主复对数定义为 $\\log(z) = \\ln|z| + i \\operatorname{Arg}(z)$，其中 $\\operatorname{Arg}(z) \\in (-\\pi, \\pi]$。\n对于 $z_1 = 4-6i$：\n$|z_1| = \\sqrt{4^2 + (-6)^2} = \\sqrt{16+36} = \\sqrt{52}$。\n$\\operatorname{Arg}(z_1) = \\arctan\\left(\\frac{-6}{4}\\right) = -\\arctan\\left(\\frac{3}{2}\\right)$。\n所以，$\\log(4-6i) = \\ln(\\sqrt{52}) - i\\arctan\\left(\\frac{3}{2}\\right) = \\frac{1}{2}\\ln(52) - i\\arctan\\left(\\frac{3}{2}\\right)$。\n\n对于 $z_2 = 4+6i$：\n$|z_2| = \\sqrt{4^2 + 6^2} = \\sqrt{52}$。\n$\\operatorname{Arg}(z_2) = \\arctan\\left(\\frac{6}{4}\\right) = \\arctan\\left(\\frac{3}{2}\\right)$。\n所以，$\\log(4+6i) = \\ln(\\sqrt{52}) + i\\arctan\\left(\\frac{3}{2}\\right) = \\frac{1}{2}\\ln(52) + i\\arctan\\left(\\frac{3}{2}\\right)$。\n\n矩阵函数 $\\log(B)$ 由 $\\log(B) = U F U^*$ 给出。\n我们需要计算 $\\operatorname{trace}(\\log(B))$。利用迹的循环性质，$\\operatorname{trace}(ABC) = \\operatorname{trace}(CAB)$：\n$$\n\\operatorname{trace}(\\log(B)) = \\operatorname{trace}(U F U^*) = \\operatorname{trace}(F U^* U)\n$$\n由于 $U$ 是酉矩阵，所以 $U^*U = I$，即单位矩阵。\n$$\n\\operatorname{trace}(\\log(B)) = \\operatorname{trace}(F)\n$$\n$F$ 的迹是其对角元素之和，这与一般定理 $\\operatorname{trace}(f(B)) = \\sum_i f(\\lambda_i)$ 一致。\n$$\n\\operatorname{trace}(F) = \\log(4-6i) + \\log(4+6i)\n$$\n$$\n\\operatorname{trace}(F) = \\left( \\frac{1}{2}\\ln(52) - i\\arctan\\left(\\frac{3}{2}\\right) \\right) + \\left( \\frac{1}{2}\\ln(52) + i\\arctan\\left(\\frac{3}{2}\\right) \\right)\n$$\n虚部相互抵消：\n$$\n\\operatorname{trace}(\\log(B)) = \\frac{1}{2}\\ln(52) + \\frac{1}{2}\\ln(52) = \\ln(52)\n$$\n为了完整性，并验证与实 $2 \\times 2$ 块的联系，我们计算完整的矩阵 $\\log(B) = UFU^*$。\n设 $\\log(\\lambda_1) = x-iy$ 且 $\\log(\\lambda_2)=x+iy$，其中 $x=\\frac{1}{2}\\ln(52)$ 且 $y=\\arctan(\\frac{3}{2})$。\n$$\n\\log(B) = \\frac{1}{2} \\begin{pmatrix} 1  1 \\\\ -i  i \\end{pmatrix} \\begin{pmatrix} x-iy  0 \\\\ 0  x+iy \\end{pmatrix} \\begin{pmatrix} 1  i \\\\ 1  -i \\end{pmatrix}\n$$\n$$\n\\log(B) = \\frac{1}{2} \\begin{pmatrix} x-iy  x+iy \\\\ -i(x-iy)  i(x+iy) \\end{pmatrix} \\begin{pmatrix} 1  i \\\\ 1  -i \\end{pmatrix}\n= \\frac{1}{2} \\begin{pmatrix} (x-iy)+(x+iy)  i(x-iy)-i(x+iy) \\\\ -i(x-iy)+i(x+iy)  (-i)i(x-iy)+i(-i)(x+iy) \\end{pmatrix}\n$$\n$$\n\\log(B) = \\frac{1}{2} \\begin{pmatrix} 2x  ix+y-ix+y \\\\ -ix-y+ix-y  (x-iy)+(x+iy) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 2x  2y \\\\ -2y  2x \\end{pmatrix} = \\begin{pmatrix} x  y \\\\ -y  x \\end{pmatrix}\n$$\n代入 $x$ 和 $y$ 的值：\n$$\n\\log(B) = \\begin{pmatrix} \\frac{1}{2}\\ln(52)  \\arctan(\\frac{3}{2}) \\\\ -\\arctan(\\frac{3}{2})  \\frac{1}{2}\\ln(52) \\end{pmatrix}\n$$\n这就是问题中提到的与共轭特征对对应的实 $2 \\times 2$ 分块形式。该矩阵的迹是 $\\frac{1}{2}\\ln(52) + \\frac{1}{2}\\ln(52) = \\ln(52)$。所有步骤和交叉检验都证实了该结果。", "answer": "$$\\boxed{\\ln(52)}$$", "id": "3596559"}, {"introduction": "在成功完成一个计算后，我们现在来研究一个简单标量递推会失败的案例。这个练习 [@problem_id:3596561] 展示了在处理重特征值时，为何基于分块的方法是必不可少的。你将看到递推方程如何变得奇异，然后运用分块层面的推理来为一个具有非平凡若尔当结构的矩阵正确地计算其函数。", "problem": "设 $T\\in\\mathbb{C}^{4\\times 4}$ 是如下明确的上三角矩阵\n$$\nT=\\begin{pmatrix}\n1  2  1  -2\\\\\n0  1  3  5\\\\\n0  0  2  4\\\\\n0  0  0  3\n\\end{pmatrix},\n$$\n其对角线元素（特征值）满足 $\\lambda_{1}=\\lambda_{2}=1$，$\\lambda_{3}=2$ 和 $\\lambda_{4}=3$，并且所有超对角线元素都非零。考虑标量函数 $f(z)=\\frac{1}{z}$，它在任何不包含 $z=0$ 的域上都是解析的。在 Schur–Parlett 方法中，首先将矩阵化为上三角形式（这里 $T$ 已经是上三角矩阵），然后应用一个递推关系逐个元素地求得 $f(T)$。\n\n从有理函数演算的矩阵函数基本定义出发（即，对于有理函数 $f$，通过在该函数定义的矩阵上有效的代数恒等式来解释 $f(T)$），解决以下问题：\n\n- 在概念层面上，基于这些定义并避免使用现成的简化公式，解释为什么标量（逐元素）的 Parlett 递推在试图确定跨越重复特征值的非对角元素 $[f(T)]_{ij}$ 时（特别是在 $\\lambda_{1}=\\lambda_{2}=1$ 时，对于 $i=1$ 和 $j=2$）会遇到一个奇异方程。特别地，阐明相等的对角线元素如何导致一个不确定条件，从差商的角度看，这可以被识别为一个除以零的障碍。\n\n- 为避免此障碍，将 $T$ 划分成一个与重复特征值对应的 $2\\times 2$ 的主对角块和一个 $2\\times 2$ 的尾对角块，并使用与 Schur–Parlett 方法一致的分块推理来精确计算单个元素 $[f(T)]_{14}$。你的计算必须从有理函数演算所蕴含的基本分块方程出发，并且不能假设任何简化的求逆公式。将 $[f(T)]_{14}$ 的精确值作为你的最终答案。不需要四舍五入。", "solution": "对于有理函数 $f(z)=1/z$ 和可逆矩阵 $T$，函数演算定义 $f(T)$ 就是矩阵的逆 $T^{-1}$。这是因为代数恒等式 $z \\cdot (1/z) = 1$ 转移到矩阵领域，意味着 $T \\cdot f(T) = I$。\n\n**第一部分：标量递推的失效**\n\nSchur-Parlett方法的标量递推源于矩阵与其函数的可交换性，即 $TF=FT$，其中 $F=f(T)$。考察 $(1,2)$ 元素，我们有 $(TF)_{12} = T_{11}F_{12} + T_{12}F_{22}$ 和 $(FT)_{12} = F_{11}T_{12} + F_{12}T_{22}$。\n令它们相等，得到 $T_{11}F_{12} + T_{12}F_{22} = F_{11}T_{12} + F_{12}T_{22}$。\n重新整理得到 $(T_{11} - T_{22})F_{12} = F_{11}T_{12} - T_{12}F_{22}$。\n在我们的例子中，$T_{11}=\\lambda_1=1$，$T_{22}=\\lambda_2=1$。方程变为 $(1-1)F_{12} = 0 \\cdot F_{12} = 0$。\n右边是 $F_{11}T_{12} - T_{12}F_{22}$。由于 $F_{11}=f(\\lambda_1)=f(1)=1$ 和 $F_{22}=f(\\lambda_2)=f(1)=1$，右边等于 $1 \\cdot T_{12} - T_{12} \\cdot 1 = 0$。\n因此，递推关系简化为 $0=0$。这个方程对于 $F_{12}$ 没有任何约束，因此是一个奇异的、不确定的方程。我们无法用此方法确定 $F_{12}$。\n\n从差商的角度来看，当特征值不同时，解是 $F_{12} = T_{12} \\frac{f(\\lambda_1)-f(\\lambda_2)}{\\lambda_1-\\lambda_2} = T_{12} f[\\lambda_1, \\lambda_2]$。当 $\\lambda_1=\\lambda_2=1$ 时，分母为零，这构成了“除以零的障碍”。为了解决这个问题，我们需要使用 $f$ 的导数，即 $F_{12}=T_{12}f'(1)$。但这超出了简单的标量递推，并进入了分块或泰勒级数方法的领域。\n\n**第二部分：使用分块推理计算 $[f(T)]_{14}$**\n\n为避免这个问题，我们按照指示进行分块。我们将 $T$ 划分为 $2 \\times 2$ 的块：\n$$ T = \\begin{pmatrix} T_{11}  T_{12} \\\\ 0  T_{22} \\end{pmatrix} \\quad \\text{其中} \\quad T_{11} = \\begin{pmatrix} 1  2 \\\\ 0  1 \\end{pmatrix}, T_{12} = \\begin{pmatrix} 1  -2 \\\\ 3  5 \\end{pmatrix}, T_{22} = \\begin{pmatrix} 2  4 \\\\ 0  3 \\end{pmatrix} $$\n矩阵函数 $F=f(T)=T^{-1}$ 也将具有相同的块上三角结构：\n$$ F = \\begin{pmatrix} F_{11}  F_{12} \\\\ 0  F_{22} \\end{pmatrix} $$\n根据函数演算，对角块是 $F_{11} = f(T_{11}) = T_{11}^{-1}$ 和 $F_{22} = f(T_{22}) = T_{22}^{-1}$。\n非对角块 $F_{12}$ 可以通过求解块版本的西尔维斯特方程 $T_{11}F_{12} - F_{12}T_{22} = F_{11}T_{12} - T_{12}F_{22}$ 来找到。然而，更直接的方法是使用基本定义 $TF=I$：\n$$ \\begin{pmatrix} T_{11}  T_{12} \\\\ 0  T_{22} \\end{pmatrix} \\begin{pmatrix} F_{11}  F_{12} \\\\ 0  F_{22} \\end{pmatrix} = \\begin{pmatrix} I  0 \\\\ 0  I \\end{pmatrix} $$\n展开块矩阵乘法，我们得到右上角的块方程：\n$$ T_{11}F_{12} + T_{12}F_{22} = 0 $$\n这个方程是求解 $F_{12}$ 的基础。因为 $T_{11}$ 的谱是 $\\{1\\}$，$T_{22}$ 的谱是 $\\{2, 3\\}$，它们的谱不相交，所以 $T_{11}$ 是可逆的。我们可以解出 $F_{12}$：\n$$ F_{12} = -T_{11}^{-1} T_{12} F_{22} $$\n现在我们计算所需的矩阵：\n1.  计算 $T_{11}^{-1}$：\n    $T_{11}^{-1} = \\begin{pmatrix} 1  2 \\\\ 0  1 \\end{pmatrix}^{-1} = \\begin{pmatrix} 1  -2 \\\\ 0  1 \\end{pmatrix}$\n2.  计算 $F_{22} = T_{22}^{-1}$：\n    $T_{22}^{-1} = \\begin{pmatrix} 2  4 \\\\ 0  3 \\end{pmatrix}^{-1} = \\frac{1}{2 \\cdot 3 - 4 \\cdot 0} \\begin{pmatrix} 3  -4 \\\\ 0  2 \\end{pmatrix} = \\begin{pmatrix} 1/2  -2/3 \\\\ 0  1/3 \\end{pmatrix}$\n3.  将它们代入 $F_{12}$ 的表达式中：\n    $$ F_{12} = - \\begin{pmatrix} 1  -2 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1  -2 \\\\ 3  5 \\end{pmatrix} \\begin{pmatrix} 1/2  -2/3 \\\\ 0  1/3 \\end{pmatrix} $$\n    首先计算中间两个矩阵的乘积：\n    $$ \\begin{pmatrix} 1  -2 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} 1  -2 \\\\ 3  5 \\end{pmatrix} = \\begin{pmatrix} 1-6  -2-10 \\\\ 0+3  0+5 \\end{pmatrix} = \\begin{pmatrix} -5  -12 \\\\ 3  5 \\end{pmatrix} $$\n    然后乘以最后一个矩阵：\n    $$ \\begin{pmatrix} -5  -12 \\\\ 3  5 \\end{pmatrix} \\begin{pmatrix} 1/2  -2/3 \\\\ 0  1/3 \\end{pmatrix} = \\begin{pmatrix} -5/2 + 0  (-5)(-2/3) + (-12)(1/3) \\\\ 3/2 + 0  (3)(-2/3) + (5)(1/3) \\end{pmatrix} $$\n    $$ = \\begin{pmatrix} -5/2  10/3 - 4 \\\\ 3/2  -2 + 5/3 \\end{pmatrix} = \\begin{pmatrix} -5/2  -2/3 \\\\ 3/2  -1/3 \\end{pmatrix} $$\n    最后，取负号：\n    $$ F_{12} = - \\begin{pmatrix} -5/2  -2/3 \\\\ 3/2  -1/3 \\end{pmatrix} = \\begin{pmatrix} 5/2  2/3 \\\\ -3/2  1/3 \\end{pmatrix} $$\n    我们感兴趣的元素是 $[f(T)]_{14}$，它对应于 $4 \\times 4$ 矩阵 $F$ 的第1行第4列的元素。这正是 $2 \\times 2$ 子矩阵 $F_{12}$ 的第1行第2列的元素。\n    $$ [f(T)]_{14} = (F_{12})_{12} = \\frac{2}{3} $$", "answer": "$$\\boxed{\\frac{2}{3}}$$", "id": "3596561"}, {"introduction": "前一个问题处理了精确重合的特征值，而这个编程练习 [@problem_id:3596587] 则探讨了一个更微妙的数值挑战：当特征值仅仅是彼此非常接近时会发生什么？通过实现一个朴素的差商计算，你将观察到灾难性抵消现象，并量化其对精度的巨大影响。这项实践突显了在浮点运算中，代数上正确的公式与数值上稳定的实现之间的关键区别。", "problem": "考虑一个解析矩阵函数 $f$ 通过解析函数演算应用于一个方阵 $A \\in \\mathbb{C}^{n \\times n}$：对于在包含 $A$ 的谱的域上解析的函数 $f$，$f(A)$ 通过围道积分定义，或者当其收敛时，等价地通过幂级数定义。Schur–Parlett 方法通过首先计算酉 Schur 分解 $A = Q T Q^{*}$（其中 $T$ 是上三角矩阵），然后通过 Parlett 递推计算 $f(T)$ 来求得 $f(A)$。当 $T$ 的对角元互不相同时，该递推使用均差系统地计算 $f(T)$ 的元素；当对角元聚集或重合时，则使用分块方法。这个问题的理论基础是矩阵的解析函数演算、酉 Schur 分解的存在性以及解析函数的泰勒级数表示。\n\n您将研究当矩阵因具有非平凡若尔当块而趋于亏损时，Schur–Parlett 方法的行为。在这种情况下，特征值的聚集/合并会导致均差的敏感性。重点关注整函数 $f(z) = e^{z}$。\n\n构建上三角矩阵族\n$$\nA(\\varepsilon) = \\begin{bmatrix}\n\\lambda  1  0 \\\\\n0  \\lambda + \\varepsilon  1 \\\\\n0  0  \\lambda + 2\\varepsilon\n\\end{bmatrix},\n$$\n其中 $\\lambda \\in \\mathbb{R}$，$\\varepsilon \\in \\mathbb{R}$ 是参数。当 $\\varepsilon = 0$ 时，$A(0)$ 是亏损的，在特征值 $\\lambda$ 处有一个尺寸为3的若尔当块。\n\n对于 $f(z) = e^{z}$ 和上述特殊的三角结构， $f(A(\\varepsilon))$ 的元素可以用均差 $f^{[k]}(\\cdot)$ 来表征。均差由 $f$ 递归定义，并将导数推广到多个节点。当 $\\varepsilon \\to 0$ 时，对于几乎重合的节点，如果朴素地计算这些均差，它们会变得病态，从而导致敏感性和潜在的数值不稳定性。\n\n任务：\n1. 针对此 $3 \\times 3$ 结构，实现一个朴素的均差计算方法来评估 $f(A(\\varepsilon))$：\n   - 设置 $F_{ii} = f(\\lambda_i)$，其中 $\\lambda_0 = \\lambda$，$\\lambda_1 = \\lambda + \\varepsilon$，$\\lambda_2 = \\lambda + 2\\varepsilon$。\n   - 对于 $i=0,1$，设置 $F_{i,i+1} = f^{[1]}(\\lambda_i, \\lambda_{i+1})$，其中 $f^{[1]}(x,y) = \\dfrac{f(x) - f(y)}{x - y}$ 直接由 $f$ 计算，不进行任何特殊的数值稳定化处理。\n   - 使用标准递推式 $f^{[2]}(x_0,x_1,x_2) = \\dfrac{f^{[1]}(x_0,x_1) - f^{[1]}(x_1,x_2)}{x_0 - x_2}$ 设置 $F_{0,2} = f^{[2]}(\\lambda_0, \\lambda_1, \\lambda_2)$，同样直接由 $f$ 计算，不进行稳定化处理。\n   - 将所有其他元素置零；得到的矩阵 $F$ 是基于均差的 $f(A(\\varepsilon))$ 的朴素近似。\n\n2. 对于 $\\varepsilon = 0$，使用解析函数应用于幂零扰动的精确若尔当块级数来计算 $f(A(0))$：\n   - 写出 $A(0) = \\lambda I + N$，其中 $N$ 是严格上三角矩阵且 $N^3 = 0$。\n   - 使用 $f(\\lambda I + N) = e^{\\lambda} \\sum_{k=0}^{2} \\dfrac{N^k}{k!}$ 来计算精确的 $f(A(0))$。\n\n3. 对每种情况，将您的近似结果与一个可信的参考值进行比较，计算其相对弗罗贝尼乌斯范数误差。该参考值由 Scientific Python (SciPy) 中稳健的缩放平方 Padé 方法实现 $\\operatorname{expm}(A)$ 计算得出。\n\n使用以下测试套件，其中 $\\lambda = 0$：\n- 理想情况：$\\varepsilon = 10^{-1}$。\n- 接近合并：$\\varepsilon = 10^{-8}$。\n- 极端合并：$\\varepsilon = 10^{-20}$。\n- 亏损若尔当情况：$\\varepsilon = 0$。\n\n对于前三种情况，计算朴素均差近似的相对弗罗贝尼乌斯范数误差。对于亏损若尔当情况，计算基于精确级数的计算结果的相对弗罗贝尼乌斯范数误差。近似值 $F_{\\text{approx}}$ 和参考值 $F_{\\text{ref}}$ 的相对弗罗贝尼乌斯范数误差定义为\n$$\n\\operatorname{rel\\_err} = \\frac{\\lVert F_{\\text{approx}} - F_{\\text{ref}} \\rVert_{F}}{\\lVert F_{\\text{ref}} \\rVert_{F}},\n$$\n其中 $\\lVert \\cdot \\rVert_{F}$ 是弗罗贝尼乌斯范数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的四个浮点数列表，其顺序与四个测试用例相对应：\n$$\n[\\operatorname{rel\\_err}(10^{-1}), \\operatorname{rel\\_err}(10^{-8}), \\operatorname{rel\\_err}(10^{-20}), \\operatorname{rel\\_err}(0)].\n$$\n此问题不涉及物理单位或角度。输出必须严格遵守指定格式。", "solution": "该问题要求研究 Schur-Parlett 方法在计算矩阵指数 $f(A) = e^A$ 时的数值稳定性，特别是在矩阵 $A$ 具有几乎合并的特征值的情况下。我们给定一个由 $\\varepsilon \\in \\mathbb{R}$ 参数化的特定 $3 \\times 3$ 上三角矩阵族 $A(\\varepsilon)$，当 $\\varepsilon \\to 0$ 时，该矩阵族趋于一个亏损矩阵。\n\n该矩阵族定义为：\n$$\nA(\\varepsilon) = \\begin{bmatrix}\n\\lambda  1  0 \\\\\n0  \\lambda + \\varepsilon  1 \\\\\n0  0  \\lambda + 2\\varepsilon\n\\end{bmatrix}\n$$\n测试用例指定 $\\lambda = 0$，因此特征值为 $\\lambda_0 = 0$，$\\lambda_1 = \\varepsilon$ 和 $\\lambda_2 = 2\\varepsilon$。\n\n$f(A(\\varepsilon))$ 的计算根据 $\\varepsilon$ 是否为零分为两种主要情况。\n\n**情况1：非亏损矩阵 ($\\varepsilon \\neq 0$)**\n对于 $\\varepsilon \\neq 0$，$A(\\varepsilon)$ 矩阵具有互不相同的特征值，因此是可对角化的。由于 $A(\\varepsilon)$ 已经是上三角形式（一种 Schur 型），我们可以通过直接确定其元素来计算 $F = f(A(\\varepsilon))$。矩阵 $F$ 也必须是上三角矩阵并满足 Sylvester 方程 $F A(\\varepsilon) = A(\\varepsilon) F$。$F$ 的元素可以用函数 $f$ 及其在 $A(\\varepsilon)$ 特征值处的均差来表示。\n\n对于一个上三角矩阵 $T$（其元素为 $t_{ij}$），$F=f(T)$ 的元素的一般公式由 Parlett 递推给出。对于我们特定的 $3 \\times 3$ 矩阵 $A(\\varepsilon)$，其中 $t_{01} = 1$，$t_{12} = 1$，$t_{02} = 0$，矩阵 $F$ 的元素为：\n- 对角元：$F_{ii} = f(\\lambda_i)$。\n$$F_{00} = f(\\lambda_0), \\quad F_{11} = f(\\lambda_1), \\quad F_{22} = f(\\lambda_2)$$\n- 第一超对角线元素：\n$$F_{01} = A_{01} f^{[1]}(\\lambda_0, \\lambda_1) = 1 \\cdot \\frac{f(\\lambda_0) - f(\\lambda_1)}{\\lambda_0 - \\lambda_1}$$\n$$F_{12} = A_{12} f^{[1]}(\\lambda_1, \\lambda_2) = 1 \\cdot \\frac{f(\\lambda_1) - f(\\lambda_2)}{\\lambda_1 - \\lambda_2}$$\n- 第二超对角线元素：\n$(0,2)$ 元素的一般公式是 $F_{02} = A_{02}f^{[1]}(\\lambda_0, \\lambda_2) + A_{01}A_{12}f^{[2]}(\\lambda_0, \\lambda_1, \\lambda_2)$。由于 $A_{02} = 0$，这简化为：\n$$F_{02} = f^{[2]}(\\lambda_0, \\lambda_1, \\lambda_2) = \\frac{f^{[1]}(\\lambda_0, \\lambda_1) - f^{[1]}(\\lambda_1, \\lambda_2)}{\\lambda_0 - \\lambda_2}$$\n\n问题要求对这些公式进行“朴素”计算。这意味着我们直接使用它们的定义来计算均差，当 $\\varepsilon$ 很小时，这涉及到分子中两个几乎相等的数的相减。由于灾难性抵消，这个过程是众所周知地数值不稳定。例如，当 $\\varepsilon \\to 0$ 时，$f(\\lambda_0)$ 和 $f(\\lambda_1)$ 都趋近于 $f(0)=1$，它们的差 $f(\\lambda_0) - f(\\lambda_1)$ 会损失显著的相对精度。该问题旨在量化这种精度损失。\n\n**情况2：亏损矩阵 ($\\varepsilon = 0$)**\n当 $\\varepsilon = 0$ 且 $\\lambda = 0$ 时，矩阵变为：\n$$\nA(0) = \\begin{bmatrix}\n0  1  0 \\\\\n0  0  1 \\\\\n0  0  0\n\\end{bmatrix}\n$$\n这是一个幂零若尔当块，我们可以将其表示为 $N$。$A(0)$ 是一个亏损矩阵，具有单一特征值 0，其代数重数为 3，几何重数为 1。\n函数 $f(A(0))$ 可以使用 $f(z)$ 在特征值 $\\lambda = 0$ 附近的泰勒级数展开来计算。由于 $A(0)$可以写成 $A(0) = \\lambda I + N = N$，我们有：\n$$\nf(A(0)) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(0)}{k!} (A(0))^k\n$$\n对于我们的矩阵 $N$，我们有 $N^2 = \\begin{bmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$ 并且对于所有 $k \\ge 3$，$N^k = 0$。因此级数是有限的：\n$$\nf(A(0)) = f(0)I + f'(0)N + \\frac{f''(0)}{2!}N^2\n$$\n给定 $f(z) = e^z$，它的所有导数也都是 $e^z$，所以对于所有 $k \\ge 0$，$f^{(k)}(0) = e^0 = 1$。因此，精确的矩阵 $f(A(0))$ 是：\n$$\nf(A(0)) = 1 \\cdot I + 1 \\cdot N + \\frac{1}{2} N^2 = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix} + \\begin{bmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{bmatrix} + \\frac{1}{2} \\begin{bmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix} = \\begin{bmatrix} 1  1  0.5 \\\\ 0  1  1 \\\\ 0  0  1 \\end{bmatrix}\n$$\n这个计算是精确的，并且不会受到均差方法中的数值不稳定性的影响。\n\n**误差测量**\n对于每个测试用例，我们使用上述方法计算一个近似矩阵 $F_{\\text{approx}}$。将其与从 `scipy.linalg.expm` 获得的高保真参考值 $F_{\\text{ref}}$进行比较，后者实现了一种稳健的、带有 Padé 近似的缩放平方算法。误差使用相对弗罗贝尼乌斯范数进行量化：\n$$\n\\operatorname{rel\\_err} = \\frac{\\lVert F_{\\text{approx}} - F_{\\text{ref}} \\rVert_{F}}{\\lVert F_{\\text{ref}} \\rVert_{F}}\n$$\n我们预计，对于 $\\varepsilon \\neq 0$ 的情况，随着 $\\varepsilon$ 的减小，误差会增加，这表明了朴素方法的失效。对于 $\\varepsilon = 0$ 的情况，由于使用了精确的解析公式，其误差应该接近机器精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, norm\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating the exponential of a matrix family A(epsilon)\n    using two different methods and comparing the results to a reference implementation.\n\n    The problem investigates the numerical stability of naive divided-difference\n    formulas for computing functions of matrices with nearly coalescing eigenvalues.\n    \"\"\"\n\n    # Define the test suite from the problem statement.\n    test_cases = [\n        # (epsilon_value)\n        1e-1,\n        1e-8,\n        1e-20,\n        0.0,\n    ]\n\n    results = []\n    lambda_val = 0.0\n\n    for eps in test_cases:\n        # Construct the matrix A(epsilon)\n        A = np.array([\n            [lambda_val, 1.0, 0.0],\n            [0.0, lambda_val + eps, 1.0],\n            [0.0, 0.0, lambda_val + 2 * eps]\n        ], dtype=float)\n\n        if eps != 0:\n            # Task 1: Naive divided-difference evaluation for epsilon != 0\n            \n            # Eigenvalues\n            l0 = lambda_val\n            l1 = lambda_val + eps\n            l2 = lambda_val + 2 * eps\n            \n            # Function f(z) = e^z\n            f = np.exp\n            \n            # Initialize approximation matrix F\n            F_approx = np.zeros((3, 3), dtype=float)\n            \n            # Diagonal entries: F_ii = f(lambda_i)\n            F_approx[0, 0] = f(l0)\n            F_approx[1, 1] = f(l1)\n            F_approx[2, 2] = f(l2)\n            \n            # First superdiagonal: F_{i,i+1} = f^{[1]}(lambda_i, lambda_{i+1})\n            # Naive computation: f[1](x, y) = (f(x) - f(y)) / (x - y)\n            F_approx[0, 1] = (f(l0) - f(l1)) / (l0 - l1)\n            F_approx[1, 2] = (f(l1) - f(l2)) / (l1 - l2)\n            \n            # Second superdiagonal: F_{0,2} = f^{[2]}(lambda_0, lambda_1, lambda_2)\n            # Naive computation: f[2](x0, x1, x2) = (f[1](x0, x1) - f[1](x1, x2)) / (x0 - x2)\n            F_approx[0, 2] = (F_approx[0, 1] - F_approx[1, 2]) / (l0 - l2)\n            \n        else: # eps == 0\n            # Task 2: Exact Jordan-block series evaluation for epsilon = 0\n            # For lambda=0 and eps=0, A(0) = N, a nilpotent matrix.\n            # f(A(0)) = I + N + (1/2!) * N^2\n            N = np.array([\n                [0.0, 1.0, 0.0],\n                [0.0, 0.0, 1.0],\n                [0.0, 0.0, 0.0]\n            ], dtype=float)\n            N2 = np.dot(N, N)\n            I = np.identity(3, dtype=float)\n            \n            F_approx = I + N + 0.5 * N2\n\n        # Task 3: Measure relative Frobenius-norm error\n        F_ref = expm(A)\n        \n        error_norm = norm(F_approx - F_ref, 'fro')\n        ref_norm = norm(F_ref, 'fro')\n        \n        # Handle the case where the reference norm is zero to avoid division by zero.\n        if ref_norm == 0:\n            relative_error = error_norm\n        else:\n            relative_error = error_norm / ref_norm\n\n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3596587"}]}