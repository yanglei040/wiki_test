{"hands_on_practices": [{"introduction": "若尔当标准型是理解矩阵函数的理论基石。对于任意方阵，其指数都可以通过其若尔当分解来理解。本练习 [@problem_id:3591573] 将引导你直接计算一个若尔当块的矩阵指数，这是构成任意矩阵指数的基本单元。通过这个计算，你将亲眼看到不可对角化性如何表现为指数项前的多项式因子，这是理解具有重特征值的系统行为的关键一步。", "problem": "设 $J \\in \\mathbb{C}^{3 \\times 3}$ 是与特征值 $\\lambda \\in \\mathbb{C}$ 相关联的 $3 \\times 3$ 若尔当块，定义为 $J = \\lambda I + N$，其中 $I$ 是单位矩阵，$N$ 是一个幂零指数为3的矩阵，其第一超对角线上的元素为1，即\n$$\nN = \\begin{pmatrix}\n0  1  0 \\\\\n0  0  1 \\\\\n0  0  0\n\\end{pmatrix}, \\quad N^{3} = 0.\n$$\n仅使用矩阵指数的幂级数定义以及矩阵多项式的基本性质（包括 $N$ 的幂零性及其与 $I$ 的可交换性），通过显式写出幂零级数，推导 $\\exp(J)$ 作为一个以 $\\exp(\\lambda)$ 表示的 $3 \\times 3$ 矩阵的闭式表达式。然后，从第一性原理出发，论证为何 $\\exp(J)$ 的非零超对角线元素具有乘以 $\\exp(\\lambda)$ 的多项式前置因子，并确定本例中的这些前置因子。你的最终答案必须是单一的解析矩阵表达式，无需四舍五入。使用 $\\exp(\\cdot)$ 而非 $e^{(\\cdot)}$ 表示最终的指数函数。", "solution": "问题是推导矩阵指数 $\\exp(J)$ 的闭式表达式，其中 $J$ 是一个特征值为 $\\lambda$ 的 $3 \\times 3$ 若尔当块。\n\n首先，我们验证问题陈述的有效性。\n已知条件如下：\n- $J \\in \\mathbb{C}^{3 \\times 3}$ 是一个若尔当块。\n- 相关特征值为 $\\lambda \\in \\mathbb{C}$。\n- $J$ 定义为 $J = \\lambda I + N$，其中 $I$ 是 $3 \\times 3$ 单位矩阵。\n- $N$ 是幂零矩阵 $N = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix}$。\n- 幂零条件为 $N^3=0$。\n\n任务是：\n1.  使用幂级数定义推导 $\\exp(J)$ 的闭式表达式。\n2.  使用 $N$ 是幂零的且与 $I$ 可交换的性质。\n3.  论证超对角线元素上的多项式前置因子。\n4.  确定这些前置因子。\n\n该问题在矩阵函数理论，特别是矩阵指数方面，具有科学依据。问题是适定的，提供了所有必要信息且无矛盾。语言客观而精确。因此，该问题被认为是有效的。\n\n我们从矩阵指数的幂级数定义开始：\n$$ \\exp(J) = \\sum_{k=0}^{\\infty} \\frac{J^k}{k!} $$\n代入 $J = \\lambda I + N$ 的定义：\n$$ \\exp(J) = \\sum_{k=0}^{\\infty} \\frac{(\\lambda I + N)^k}{k!} $$\n矩阵 $\\lambda I$ 是单位矩阵的标量倍，它与任何矩阵（包括 $N$）都可交换。即 $(\\lambda I)N = \\lambda(IN) = \\lambda N$ 且 $N(\\lambda I) = \\lambda(NI) = \\lambda N$。由于 $\\lambda I$ 和 $N$ 可交换，我们可以对可交换矩阵 $A$ 和 $B$ 应用性质 $\\exp(A+B) = \\exp(A)\\exp(B)$。令 $A = \\lambda I$ 且 $B = N$。\n$$ \\exp(J) = \\exp(\\lambda I) \\exp(N) $$\n我们分别计算每个指数项。\n\n对于 $\\exp(\\lambda I)$ 项：\n$$ \\exp(\\lambda I) = \\sum_{k=0}^{\\infty} \\frac{(\\lambda I)^k}{k!} = \\sum_{k=0}^{\\infty} \\frac{\\lambda^k I^k}{k!} $$\n由于对于所有整数 $k \\geq 0$，$I^k = I$（其中 $I^0=I$），我们可以将 $I$ 因子提出来：\n$$ \\exp(\\lambda I) = \\left( \\sum_{k=0}^{\\infty} \\frac{\\lambda^k}{k!} \\right) I = \\exp(\\lambda) I $$\n这是一个对角线上元素为 $\\exp(\\lambda)$ 的标量矩阵。\n\n对于 $\\exp(N)$ 项：\n$$ \\exp(N) = \\sum_{k=0}^{\\infty} \\frac{N^k}{k!} = \\frac{N^0}{0!} + \\frac{N^1}{1!} + \\frac{N^2}{2!} + \\frac{N^3}{3!} + \\dots $$\n按照约定，$N^0 = I$ 且 $0! = 1$。问题陈述 $N$ 的幂零指数为3，即 $N^3 = 0$。这意味着所有更高次的幂也为零，即对于所有 $k \\geq 3$，$N^k = 0$。因此，$\\exp(N)$ 的无穷级数截断为一个有限和：\n$$ \\exp(N) = I + N + \\frac{1}{2!}N^2 $$\n我们计算 $N$ 的各次幂：\n$N^0 = I = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$\n$N^1 = N = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix}$\n$N^2 = N \\cdot N = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}$\n$N^3 = N^2 \\cdot N = \\begin{pmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix}$，即零矩阵。\n\n将这些矩阵代入 $\\exp(N)$ 的表达式中：\n$$ \\exp(N) = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} + \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} + \\frac{1}{2} \\begin{pmatrix} 0  0  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} $$\n$$ \\exp(N) = \\begin{pmatrix} 1  1  \\frac{1}{2} \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix} $$\n现在，我们合并结果以求得 $\\exp(J)$：\n$$ \\exp(J) = \\exp(\\lambda I) \\exp(N) = (\\exp(\\lambda) I) \\exp(N) = \\exp(\\lambda) \\exp(N) $$\n$$ \\exp(J) = \\exp(\\lambda) \\begin{pmatrix} 1  1  \\frac{1}{2} \\\\ 0  1  1 \\\\ 0  0  1 \\end{pmatrix} = \\begin{pmatrix} \\exp(\\lambda)  \\exp(\\lambda)  \\frac{1}{2}\\exp(\\lambda) \\\\ 0  \\exp(\\lambda)  \\exp(\\lambda) \\\\ 0  0  \\exp(\\lambda) \\end{pmatrix} $$\n这就是所求的闭式表达式。\n\n接下来，我们从第一性原理出发，论证为何 $\\exp(J)$ 的非零超对角线元素具有乘以 $\\exp(\\lambda)$ 的多项式前置因子。\n从幂级数出发，并对可交换矩阵 $\\lambda I$ 和 $N$ 使用二项式定理：\n$$ J^k = (\\lambda I + N)^k = \\sum_{j=0}^{k} \\binom{k}{j} (\\lambda I)^{k-j} N^j = \\sum_{j=0}^{k} \\binom{k}{j} \\lambda^{k-j} N^j $$\n由于幂零性，当 $j \\ge 3$ 时 $N^j = 0$，因此对于任意 $k$，该和式在 $j=2$ 处截断：\n$$ J^k = \\binom{k}{0}\\lambda^k I + \\binom{k}{1}\\lambda^{k-1} N + \\binom{k}{2}\\lambda^{k-2} N^2 $$", "answer": "$$\n\\boxed{\\begin{pmatrix} \\exp(\\lambda)  \\exp(\\lambda)  \\frac{1}{2}\\exp(\\lambda) \\\\ 0  \\exp(\\lambda)  \\exp(\\lambda) \\\\ 0  0  \\exp(\\lambda) \\end{pmatrix}}\n$$", "id": "3591573"}, {"introduction": "对于非正规矩阵，仅靠特征值不足以完全预测其动态行为。本练习 [@problem_id:3591545] 将通过一个计算实验，探索所谓的“瞬态增长”现象——即一个理论上稳定的系统（所有特征值均在左半平面）可能在衰减前经历巨大的瞬时放大。你将学习使用伪谱这一强大工具来理解和预测这种行为，这对于流体力学、控制理论等领域的实际应用至关重要。", "problem": "您必须编写一个完整、可运行的程序，以构建显式的稳定但高度非正规的矩阵，并定量地展示矩阵指数中的巨大瞬态增长。此任务必须基于矩阵指数和 $\\varepsilon$-伪谱的核心定义，并且必须生成数值证据，通过拉普拉斯变换围线，将观察到的瞬态增长与 $\\varepsilon$-伪谱横坐标以及一个可计算的矩阵指数伪谱界联系起来。所有量均为纯数学量且无量纲，因此不涉及物理单位或角度。\n\n请使用以下基础定义和事实作为您推导和计算的基础：\n\n- 对于任何复方阵 $A$ 和实标量 $t \\ge 0$，矩阵指数由幂级数 $e^{tA} = \\sum_{k=0}^{\\infty} \\frac{t^k}{k!} A^k$ 定义。\n- 谱横坐标为 $\\alpha(A) := \\max\\{\\operatorname{Re}(\\lambda) : \\lambda \\in \\sigma(A)\\}$，其中 $\\sigma(A)$ 表示 $A$ 的谱（特征值集合）。\n- 矩阵 $M$ 的算子 $2$-范数为 $\\|M\\|_2 := \\sigma_{\\max}(M)$，即最大奇异值。特别地，对于任何可逆矩阵 $B$，$\\|B^{-1}\\|_2 = 1 / \\sigma_{\\min}(B)$。\n- 对于 $\\varepsilon  0$，$\\varepsilon$-伪谱为 $\\Lambda_{\\varepsilon}(A) := \\{ z \\in \\mathbb{C} : \\|(zI - A)^{-1}\\|_2 \\ge 1/\\varepsilon \\}$，$\\varepsilon$-伪谱横坐标为 $\\alpha_{\\varepsilon}(A) := \\sup\\{\\operatorname{Re}(z) : z \\in \\Lambda_{\\varepsilon}(A)\\}$。\n- 对于任何满足 $\\gamma  \\alpha(A)$ 的固定实数 $\\gamma \\in \\mathbb{R}$，矩阵指数的拉普拉斯变换表示为\n$$\ne^{tA} = \\frac{1}{2\\pi i} \\int_{\\gamma - i\\infty}^{\\gamma + i\\infty} e^{tz} (zI - A)^{-1} \\, dz,\n$$\n因此\n$$\n\\|e^{tA}\\|_2 \\le \\frac{e^{\\gamma t}}{2\\pi} \\int_{-\\infty}^{\\infty} \\|( \\gamma + i\\omega)I - A \\|_2^{-1} \\, d\\omega.\n$$\n如果 $\\gamma  \\alpha_{\\varepsilon}(A)$，那么对于所有 $\\omega \\in \\mathbb{R}$，都有 $\\|( \\gamma + i\\omega)I - A \\|_2^{-1}  1/\\varepsilon$。将积分截断至 $|\\omega| \\le \\Omega$ 会得到一个可计算的界\n$$\n\\|e^{tA}\\|_2 \\le \\frac{e^{\\gamma t}}{2\\pi} \\int_{-\\Omega}^{\\Omega} \\|( \\gamma + i\\omega)I - A \\|_2^{-1} \\, d\\omega,\n$$\n我们将在截断的围线上对其进行数值评估，作为其上界。\n\n您的程序必须为指定的测试套件实现以下步骤：\n\n1.  根据给定的维度和参数构造三个测试矩阵 $A$，每个矩阵的 $\\sigma(A)$ 都严格位于左半平面：\n    -   情况 1：$A_1 = \\operatorname{diag}(-1, -2, -3)$。\n    -   情况 2：$A_2 = \\begin{bmatrix} -1  K_2 \\\\ 0  -10 \\end{bmatrix}$，其中 $K_2 = 300$。这是一个上三角矩阵，其较大的上对角线元素导致了非正规性。\n    -   情况 3：$A_3 = -I + K_3 N$，其中 $I$ 是 $3 \\times 3$ 单位矩阵，$N$ 是 $3 \\times 3$ 幂零矩阵，其第一条上对角线元素为 1，其余元素为 0，且 $K_3 = 25$。显式地，$N = \\begin{bmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{bmatrix}$。\n\n2.  对于每个矩阵 $A$，通过在均匀时间网格 $t \\in [0, T]$（其中 $T = 8$，$N_t = 601$ 个点，包括端点）上计算 $\\| e^{tA} \\|_2$ 来计算观察到的瞬态增长。记录最大放大倍数\n    $$\n    M_{\\mathrm{obs}} := \\max_{t \\in \\{t_j\\}_{j=0}^{N_t-1}} \\| e^{tA} \\|_2\n    $$\n    以及达到最大值时的网格时间 $t^\\star$（如果存在多个，则选择网格上最小的此类 $t$）。同时计算谱横坐标 $\\alpha(A)$。\n\n3.  对于每个矩阵 $A$ 和每个 $\\varepsilon \\in \\{ 10^{-1}, 5 \\cdot 10^{-2} \\}$，通过在复平面的矩形网格上对预解式范数进行采样来近似 $\\alpha_{\\varepsilon}(A)$：\n    -   实轴范围：$\\operatorname{Re}(z) \\in [ -5 , 1.5 ]$，步长 $\\Delta x = 0.05$。\n    -   虚轴范围：$\\operatorname{Im}(z) \\in [ -20 , 20 ]$，步长 $\\Delta y = 0.1$。\n    在每个网格点 $z = x + i y$ 处，计算 $\\|(zI - A)^{-1}\\|_2 = 1 / \\sigma_{\\min}(zI - A)$，如果该值至少为 $1/\\varepsilon$，则标记该点。将 $\\alpha_{\\varepsilon}(A)$ 估计为所有标记点中的最大实部 $x$（如果没有点被标记，则报告最小的实网格值 -5，这表示所选网格未能达到阈值，但对于指定的矩阵和 $\\varepsilon$ 值，这种情况不应发生）。\n\n4.  对于每个矩阵 $A$，在时间 $t = t^\\star$ 处，为 $\\varepsilon = 10^{-1}$ 构造一个截断的伪谱界，方法如下：\n    -   设置 $\\gamma = \\alpha_{\\varepsilon}(A) + \\delta$，其中 $\\delta = 2 \\cdot 10^{-2}$。这确保了 $\\gamma  \\alpha_{\\varepsilon}(A)$。\n    -   使用梯形法则，以 $\\Omega = 50$ 和在 $[-\\Omega, \\Omega]$ 上的 $N_\\omega = 1001$ 个节点的均匀网格，数值近似\n        $$\n        B_{\\varepsilon}(t^\\star) := \\frac{e^{\\gamma t^\\star}}{2\\pi} \\int_{-\\Omega}^{\\Omega} \\|(\\gamma + i\\omega)I - A \\|_2^{-1} \\, d\\omega\n        $$\n    这个 $B_{\\varepsilon}(t^\\star)$ 是截断的 Bromwich 围线上的一个可计算上界，并量化了由伪谱横坐标预测的增长。\n\n5.  对于每个测试用例，生成一个包含六个条目的结果列表：\n    -   观察到的最大放大倍数 $M_{\\mathrm{obs}}$（浮点数）。\n    -   最大化网格时间 $t^\\star$（浮点数）。\n    -   谱横坐标 $\\alpha(A)$（浮点数）。\n    -   $\\varepsilon = 10^{-1}$ 时的 $\\varepsilon$-伪谱横坐标 $\\alpha_{\\varepsilon}(A)$（浮点数）。\n    -   $\\varepsilon = 5 \\cdot 10^{-2}$ 时的 $\\varepsilon$-伪谱横坐标 $\\alpha_{\\varepsilon}(A)$（浮点数）。\n    -   $\\varepsilon = 10^{-1}$ 时的截断伪谱界 $B_{\\varepsilon}(t^\\star)$（浮点数）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个内部列表，每个内部列表包含按上述顺序排列的六个浮点数。例如，输出必须类似于\n$[ [ r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}, r_{1,5}, r_{1,6} ], [ r_{2,1}, r_{2,2}, r_{2,3}, r_{2,4}, r_{2,5}, r_{2,6} ], [ r_{3,1}, r_{3,2}, r_{3,3}, r_{3,4}, r_{3,5}, r_{3,6} ] ]$\n其中每个 $r_{i,j}$ 都打印为 Python 浮点数。\n\n此测试套件探讨了：\n-   一个正规的对角矩阵（基准，无瞬态增长）。\n-   一个 $2 \\times 2$ 的上三角、强非正规矩阵（显著的瞬态增长）。\n-   一个 $3 \\times 3$ 的 Jordan 型、强非正规矩阵（多项式加权的瞬态响应）。\n结果展示了非正规性如何使得 $\\|e^{tA}\\|_2$ 远超 $e^{t \\alpha(A)}$，并将其与 $\\alpha_{\\varepsilon}(A)$ 在小 $\\varepsilon$ 值下变为非负数相联系，同时使用由 $\\Lambda_{\\varepsilon}(A)$ 构建的截断伪譜界来量化这种增长。", "solution": "该问题要求对由 $\\dot{\\boldsymbol{x}} = A \\boldsymbol{x}$ 控制的线性动力系统中的瞬态增长现象进行数值演示，其解为 $\\boldsymbol{x}(t) = e^{tA} \\boldsymbol{x}(0)$。分析的关键在于矩阵指数 $e^{tA}$ 的性质，特别是其算子 2-范数 $\\|e^{tA}\\|_2$。对于一个稳定的矩阵 $A$（由谱横坐标 $\\alpha(A)  0$ 定义），其长期行为是衰减的，即 $\\lim_{t \\to \\infty} \\|e^{tA}\\|_2 = 0$。然而，如果 $A$ 是非正规的（即 $A^*A \\ne AA^*$），$\\|e^{tA}\\|_2$ 可能会表现出显著的瞬态增长，在衰减前达到远大于 1 的值。仅凭特征值无法预测这种行为。$\\varepsilon$-伪谱 $\\Lambda_{\\varepsilon}(A)$ 通过刻画特征值对扰动的敏感性，提供了一个更全面的图像。显著的瞬态增长与 $\\varepsilon$-伪谱横坐标 $\\alpha_{\\varepsilon}(A)$ 在 $\\varepsilon$ 值很小时为正相关，即使当 $\\alpha(A)$ 为负时也是如此。这表明对 $A$ 的一个微小扰动就可能将特征值移到右半平面，这是易于产生瞬态效应的非正规系统的一个标志。我们将通过构建和分析三个不同的矩阵来验证这些原理。\n\n首先，根据问题说明构建三个测试矩阵。\n情况 1：一个正规（对角）矩阵，预计不会表现出瞬态增长。\n$$\nA_1 = \\operatorname{diag}(-1, -2, -3) = \\begin{bmatrix} -1  0  0 \\\\ 0  -2  0 \\\\ 0  0  -3 \\end{bmatrix}\n$$\n情况 2：一个非正规上三角矩阵，其较大的上对角线元素 $K_2=300$ 旨在产生显著的瞬态增长。\n$$\nA_2 = \\begin{bmatrix} -1  300 \\\\ 0  -10 \\end{bmatrix}\n$$\n情况 3：一个由幂零 Jordan 块构造的非正规矩阵。这种结构已知会引起多项式加权的增长。这里，$K_3=25$。\n$$\nA_3 = -I + 25 N = \\begin{bmatrix} -1  25  0 \\\\ 0  -1  25 \\\\ 0  0  -1 \\end{bmatrix}\n$$\n所有三个矩阵的特征值都完全位于严格的左半平面，这意味着它们是渐近稳定的。\n\n其次，我们分析观察到的瞬态增长。对于每个矩阵 $A$，我们在离散时间网格 $t_j \\in [0, T]$（其中 $T=8$，$N_t = 601$ 个点）上计算 $\\|e^{tA}\\|_2$。最大放大倍数是 $M_{\\mathrm{obs}} = \\max_{j} \\|e^{t_j A}\\|_2$，而 $t^\\star$ 是该最大值出现的最早时间。矩阵指数 $e^{tA}$ 使用 `scipy.linalg.expm` 函数计算，算子 2-范数通过 `numpy.linalg.norm` 找到。谱横坐标 $\\alpha(A) = \\max\\{\\operatorname{Re}(\\lambda) : \\lambda \\in \\sigma(A)\\}$ 也从 $A$ 的特征值计算得出。对于像 $A_1$ 这样的正规矩阵，我们预期在 $t^\\star=0$ 时 $M_{\\mathrm{obs}}=1$。对于非正规矩阵 $A_2$ 和 $A_3$，我们预计对于某个 $t^\\star > 0$ 会有 $M_{\\mathrm{obs}} \\gg 1$。\n\n第三，我们近似计算 $\\varepsilon$-伪谱横坐标 $\\alpha_{\\varepsilon}(A)$，其中 $\\varepsilon \\in \\{10^{-1}, 5 \\cdot 10^{-2}\\}$。根据定义，$\\Lambda_{\\varepsilon}(A) = \\{ z \\in \\mathbb{C} : \\|(zI - A)^{-1}\\|_2 \\ge 1/\\varepsilon \\}$。预解式范数 $\\|(zI - A)^{-1}\\|_2$ 等于 $1/\\sigma_{\\min}(zI - A)$，其中 $\\sigma_{\\min}$ 是最小奇异值。因此，该条件等价于 $\\sigma_{\\min}(zI - A) \\le \\varepsilon$。我们离散化复平面的一个矩形区域，网格点为 $z_{jk} = x_j + i y_k$，其中 $x_j \\in [-5, 1.5]$，$y_k \\in [-20, 20]$。在每个点上，我们计算 $\\sigma_{\\min}(z_{jk}I - A)$ 并检查它是否小于或等于 $\\varepsilon$。然后将 $\\alpha_{\\varepsilon}(A)$ 的值估计为满足条件的所有网格点 $z_{jk}$ 中的最大实部 $x_j$。对于一个稳定的矩阵 $A$，一个正的 $\\alpha_{\\varepsilon}(A)$ 是潜在瞬态增长的强有力指标。\n\n第四，我们使用伪谱计算瞬态增长的定量界。拉普拉斯变换表示法导致不等式 $\\|e^{tA}\\|_2 \\le \\frac{e^{\\gamma t}}{2\\pi} \\int_{-\\infty}^{\\infty} \\|((\\gamma + i\\omega)I - A)^{-1}\\|_2 \\, d\\omega$对任何 $\\gamma  \\alpha(A)$ 都成立。通过选择比 $\\alpha_{\\varepsilon}(A)$ 稍大的 $\\gamma$，具体为 $\\gamma = \\alpha_{\\varepsilon}(A) + \\delta$，其中 $\\delta = 2 \\cdot 10^{-2}$ 且 $\\varepsilon = 10^{-1}$，我们将积分围线置于 $\\varepsilon$-伪谱的右侧。该界可以通过截断积分并进行数值计算来近似。我们在观察到的峰值时间 $t=t^\\star$ 计算截断的伪谱界：\n$$\nB_{\\varepsilon}(t^\\star) = \\frac{e^{\\gamma t^\\star}}{2\\pi} \\int_{-\\Omega}^{\\Omega} \\|(\\gamma + i\\omega)I - A \\|_2^{-1} \\, d\\omega\n$$\n该积分使用梯形法则在区间 $[-\\Omega, \\Omega]$（其中 $\\Omega=50$）上的 $N_{\\omega}=1001$ 个点的网格上进行评估。被积函数 $\\|(\\gamma + i\\omega)I - A\\|_2^{-1}$ 再次被计算为 $1/\\sigma_{\\min}((\\gamma + i\\omega)I-A)$。这个界 $B_{\\varepsilon}(t^\\star)$ 为观察到的最大放大倍数 $M_{\\mathrm{obs}}$ 提供了一个理论估计，它直接源于伪谱的几何形状。\n\n最后，对于三个测试用例中的每一个，我们按指定顺序编制一个包含六个数值结果的列表：观察到的最大放大倍数 $M_{\\mathrm{obs}}$、达到最大放大倍数的时间 $t^\\star$、谱横坐标 $\\alpha(A)$、两个估计的 $\\varepsilon$-伪谱横坐标（分别对应 $\\varepsilon = 10^{-1}$ 和 $\\varepsilon = 5 \\cdot 10^{-2}$），以及计算出的截断伪谱界 $B_{\\varepsilon}(t^\\star)$（对应 $\\varepsilon = 10^{-1}$）。这提供了一个全面的图像，将非正规性和伪谱的抽象理论与瞬态动力学的具体数值观测联系起来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Constructs stable but nonnormal matrices and demonstrates transient growth in the matrix exponential,\n    connecting it to the epsilon-pseudospectrum.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    K2 = 300.0\n    K3 = 25.0\n    A1 = np.diag([-1.0, -2.0, -3.0])\n    A2 = np.array([[-1.0, K2], [0.0, -10.0]])\n    A3 = np.array([[-1.0, K3, 0.0], [0.0, -1.0, K3], [0.0, 0.0, -1.0]])\n\n    test_cases = [A1, A2, A3]\n\n    # Shared parameters for all cases\n    T = 8.0\n    Nt = 601\n    t_grid = np.linspace(0, T, Nt)\n\n    eps_vals = [1e-1, 5e-2]\n\n    x_range = np.arange(-5.0, 1.5 + 0.05, 0.05)\n    y_range = np.arange(-20.0, 20.0 + 0.1, 0.1)\n\n    delta_bound = 2e-2\n    Omega_bound = 50.0\n    N_omega_bound = 1001\n\n    all_results = []\n\n    for A in test_cases:\n        # Step 2: Compute observed transient growth\n        n = A.shape[0]\n        identity = np.eye(n)\n        \n        etA_norms = [np.linalg.norm(expm(A * t), ord=2) for t in t_grid]\n        \n        M_obs = np.max(etA_norms)\n        # Find the smallest t at which the maximum occurs\n        t_star_idx = np.argmax(etA_norms)\n        t_star = t_grid[t_star_idx]\n\n        alpha_A = np.max(np.real(np.linalg.eigvals(A)))\n\n        # Step 3: Approximate epsilon-pseudospectral abscissa\n        alpha_eps_results = []\n        for eps in eps_vals:\n            max_x = -5.0  # Default value if no point is found\n            \n            # Using np.linalg.svd is more numerically stable than inv\n            # We check for sigma_min(zI - A) = eps\n            for x in x_range[::-1]: # Search from right to left for efficiency\n                found_in_col = False\n                for y in y_range:\n                    z = x + 1j * y\n                    # Smallest singular value of (zI - A)\n                    s_min = np.linalg.svd(z * identity - A, compute_uv=False)[-1]\n                    if s_min = eps:\n                        max_x = x\n                        found_in_col = True\n                        break # Found for this x, go to the next (larger) x\n                if found_in_col:\n                    break # exit x-loop\n            alpha_eps_results.append(max_x)\n        \n        alpha_eps_1 = alpha_eps_results[0]\n        alpha_eps_2 = alpha_eps_results[1]\n\n        # Step 4: Compute truncated pseudospectral bound\n        eps_bound = 1e-1\n        alpha_eps_A_for_bound = alpha_eps_1\n        \n        gamma = alpha_eps_A_for_bound + delta_bound\n        \n        omega_grid = np.linspace(-Omega_bound, Omega_bound, N_omega_bound)\n        \n        integrand_values = []\n        for omega in omega_grid:\n            z = gamma + 1j * omega\n            # resolvent norm is 1 / sigma_min\n            s_min = np.linalg.svd(z * identity - A, compute_uv=False)[-1]\n            integrand_values.append(1.0 / s_min)\n            \n        integral = np.trapz(integrand_values, omega_grid)\n        \n        B_eps = (np.exp(gamma * t_star) / (2 * np.pi)) * integral\n\n        # Step 5: Collate results\n        case_results = [\n            M_obs,\n            t_star,\n            alpha_A,\n            alpha_eps_1,\n            alpha_eps_2,\n            B_eps\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Convert nested list to string with desired formatting\n    result_str = \"[\" + \", \".join([str(res) for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```", "id": "3591545"}, {"introduction": "在科学与工程计算中，我们遇到的矩阵常具有特殊结构，例如分块上三角形式。本练习 [@problem_id:3591556] 旨在探索如何利用这种结构来更高效地计算矩阵指数，这是一个核心的算法设计问题。你将推導关键的数学公式，包括积分表示和 Sylvester 方程，并实现和比较两种不同的计算方法，同时分析它们的数值稳定性，从而将深刻的理论与实用的算法设计联系起来。", "problem": "给定一个分块上三角矩阵，其形式为\n$$\nA \\;=\\; \\begin{bmatrix} B  E \\\\ 0  C \\end{bmatrix},\n$$\n其中 $B \\in \\mathbb{C}^{m \\times m}$，$C \\in \\mathbb{C}^{n \\times n}$，$E \\in \\mathbb{C}^{m \\times n}$，且 $m, n \\in \\mathbb{N}$。你的任务是推导矩阵指数的保结构公式，根据谱分离分析其稳定性，并实现利用三角结构高效计算非对角块的算法。\n\n你可以使用的基本依据包括以下核心定义和事实：\n- 矩阵指数由绝对收敛的级数定义\n$$\n\\exp(A) \\;=\\; \\sum_{k=0}^{\\infty} \\frac{A^{k}}{k!}.\n$$\n- 对于分块上三角矩阵 $A$，其乘积 $A^{k}$ 对每个 $k \\in \\mathbb{N}$ 也都是分块上三角矩阵。\n- 若 $L(X) = BX - XC$ 且 $\\operatorname{vec}(X)$ 是将 $X$ 的列堆叠而成的向量，则 $\\operatorname{vec}(L(X)) = \\left(I_{n} \\otimes B - C^{\\top} \\otimes I_{m}\\right)\\operatorname{vec}(X)$，其中 $\\otimes$ 表示克罗内克积（Kronecker product）。\n- 对于一个方阵 $M$，其（矩阵）$1$-范数是 $\\|M\\|_{1} = \\max_{j} \\sum_{i} |M_{ij}|$。\n\n除了这些基本事实外，不要假设任何其他公式。特别是，不要假设任何关于 $\\exp(A)$ 非对角块的现成公式；你必须按照下面的规定从第一性原理出发进行推导。\n\n您的任务：\n\n1. 仅从矩阵指数的级数定义出发，证明 $\\exp(A)$ 是分块上三角矩阵，并推导出 $\\exp(A)$ 的非对角块 $X$ 关于 $B$、$E$ 和 $C$ 的显式分块级数表达式。然后，推导出一个等价的积分表示，将 $X$ 表示为一个关于标量参数的积分。最后，利用积分符号下的微分法推导出 $X$ 满足的一个西尔维斯特型（Sylvester-type）线性矩阵方程。陈述在该西尔维斯特方程有唯一解时 $B$ 和 $C$ 需满足的条件，并讨论这些条件如何通过谱分离\n$$\n\\operatorname{sep}(B,C) \\;=\\; \\sigma_{\\min}\\!\\left(I_{n} \\otimes B \\;-\\; C^{\\top} \\otimes I_{m}\\right),\n$$\n与数值稳定性相关联，其中 $\\sigma_{\\min}$ 表示最小奇异值。你的分析应完全基于 $B$、$E$ 和 $C$，并且除非明确证明，否则不应假设交换性。\n\n2. 提出两种利用分块上三角结构计算非对角块 $X$ 的算法：\n   - 一种基于求积的算法，使用 $[0,1]$ 上的高斯求积法（Gaussian quadrature）来计算积分表达式。\n   - 一种基于西尔维斯特求解的算法，该算法首先计算 $\\exp(B)$ 和 $\\exp(C)$，然后求解 $X$ 的西尔维斯特型线性矩阵方程。\n   对于每种算法，讨论其作为 $m$、$n$ 和所选求积点数的函数的大-$\\mathcal{O}$ 表示法下的计算成本，并评论其与 $\\operatorname{sep}(B,C)$ 相关的预期数值稳定性。\n\n3. 实现这两种算法，并与对完整分块矩阵进行 $\\exp(A)$ 的密集计算参考值进行数值验证。对于下面指定的每个测试用例，从 $(B,E,C)$ 构建 $A$，计算参考值 $\\exp(A)$，通过两种算法计算 $X$，组装相应的 $\\exp(A)$ 结构化近似值，并报告：\n   - 基于西尔维斯特求解的组合相对于密集计算参考值的相对 $1$-范数误差，\n     $$\n     \\mathrm{err}_{\\mathrm{syl}} \\;=\\; \\frac{\\left\\|\\exp(A)_{\\mathrm{ref}} - \\begin{bmatrix}\\exp(B)  X_{\\mathrm{syl}} \\\\ 0  \\exp(C)\\end{bmatrix}\\right\\|_{1}}{\\left\\|\\exp(A)_{\\mathrm{ref}}\\right\\|_{1}}.\n     $$\n   - 基于积分求积的组合相对于密集计算参考值的相对 $1$-范数误差，\n     $$\n     \\mathrm{err}_{\\mathrm{int}} \\;=\\; \\frac{\\left\\|\\exp(A)_{\\mathrm{ref}} - \\begin{bmatrix}\\exp(B)  X_{\\mathrm{int}} \\\\ 0  \\exp(C)\\end{bmatrix}\\right\\|_{1}}{\\left\\|\\exp(A)_{\\mathrm{ref}}\\right\\|_{1}}.\n     $$\n   - 谱分离 $\\operatorname{sep}(B,C)$。\n\n对于基于积分的计算，使用在 $[0,1]$ 上的 $q = 64$ 阶高斯求积法。你可以使用奇异值分解（SVD）来计算 $\\operatorname{sep}(B,C)$。\n\n测试套件包括以下四个案例。所有矩阵都是实数；你可以将 $\\mathbb{R}$ 视为 $\\mathbb{C}$ 的一个子域：\n- 案例 1 ($m = 2$, $n = 2$): \n  $$\n  B = \\begin{bmatrix} -1  2 \\\\ 0  -2 \\end{bmatrix},\\quad\n  C = \\begin{bmatrix} -\\tfrac{1}{2}  \\tfrac{1}{2} \\\\ 0  -3 \\end{bmatrix},\\quad\n  E = \\begin{bmatrix} 0.3  -0.2 \\\\ 0.1  0.4 \\end{bmatrix}.\n  $$\n- 案例 2 ($m = 2$, $n = 2$): 设 $\\delta = 10^{-6}$ 且\n  $$\n  B = \\begin{bmatrix} 0  1 \\\\ 0  0 \\end{bmatrix},\\quad\n  C = \\begin{bmatrix} \\delta  1 \\\\ 0  \\delta \\end{bmatrix},\\quad\n  E = \\begin{bmatrix} 1  0 \\\\ 0  -1 \\end{bmatrix}.\n  $$\n- 案例 3 ($m = 3$, $n = 1$): \n  $$\n  B = \\begin{bmatrix} 0.1  1  0 \\\\ 0  0.2  1 \\\\ 0  0  0.3 \\end{bmatrix},\\quad\n  C = \\begin{bmatrix} -0.25 \\end{bmatrix},\\quad\n  E = \\begin{bmatrix} 1 \\\\ 0.5 \\\\ -0.25 \\end{bmatrix}.\n  $$\n- 案例 4 ($m = 2$, $n = 2$): \n  $$\n  B = \\begin{bmatrix} 5  0 \\\\ 1  4 \\end{bmatrix},\\quad\n  C = \\begin{bmatrix} -3  1 \\\\ 0  -2 \\end{bmatrix},\\quad\n  E = \\begin{bmatrix} 0.2  -0.1 \\\\ 0.05  0.05 \\end{bmatrix}.\n  $$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的四个条目的列表，每个条目对应一个测试用例。每个条目本身必须是一个包含三个浮点数的列表，以科学记数法表示 $[\\mathrm{err}_{\\mathrm{syl}}, \\mathrm{err}_{\\mathrm{int}}, \\operatorname{sep}(B,C)]$。例如：\n$$\n\\big[ [x_{1}, y_{1}, z_{1}], [x_{2}, y_{2}, z_{2}], [x_{3}, y_{3}, z_{3}], [x_{4}, y_{4}, z_{4}] \\big].\n$$\n\n不涉及物理单位。不出现角度。不得使用百分比；所有报告的量均为无量纲的浮点数。程序必须完全自包含，除了打印这一行之外，不执行任何其他输入或输出。你可以使用的数值库由执行环境规范固定。", "solution": "该问题要求对分块上三角矩阵的指数计算进行全面的理论推导、算法设计和数值实现。我们将首先验证问题陈述，然后按顺序处理三个任务中的每一个。\n\n该问题被确定为有效，因为它在科学上基于数值线性代数的既定原则，其给定的条件和目标清晰一致，问题设置良好，并且不含任何主观或不可形式化的内容。所有定义和任务在指定领域内都是标准的。\n\n### 任务 1：推导与分析\n\n设分块上三角矩阵为 $A = \\begin{bmatrix} B  E \\\\ 0  C \\end{bmatrix}$，其中 $B \\in \\mathbb{C}^{m \\times m}$，$C \\in \\mathbb{C}^{n \\times n}$，$E \\in \\mathbb{C}^{m \\times n}$。\n\n**1. $\\exp(A)$ 的分块结构及非对角块的级数**\n\n我们首先考察 $A$ 的幂。已知 $A^k$ 是分块上三角矩阵。我们用归纳法来确定 $A^k$ 的形式。设 $A^k = \\begin{bmatrix} B^k  X_k \\\\ 0  C^k \\end{bmatrix}$。对于基例 $k=0$，有 $A^0 = I = \\begin{bmatrix} I_m  0 \\\\ 0  I_n \\end{bmatrix}$，因此 $X_0 = 0$。对于 $k=1$，有 $A^1 = A = \\begin{bmatrix} B  E \\\\ 0  C \\end{bmatrix}$，因此 $X_1 = E$。\n假设该假设对整数 $k \\ge 1$ 成立。那么，\n$$\nA^{k+1} = A^k A = \\begin{bmatrix} B^k  X_k \\\\ 0  C^k \\end{bmatrix} \\begin{bmatrix} B  E \\\\ 0  C \\end{bmatrix} = \\begin{bmatrix} B^{k+1}  B^k E + X_k C \\\\ 0  C^{k+1} \\end{bmatrix}.\n$$\n这证实了 $A^{k+1}$ 也是分块上三角矩阵，且 $X_{k+1} = B^k E + X_k C$。展开这个关于 $X_k$ 的递推关系，我们发现：\n$X_1 = E$\n$X_2 = BE + X_1C = BE + EC$\n$X_3 = B^2E + X_2C = B^2E + (BE+EC)C = B^2E + BEC + EC^2$\n其一般形式是所有可能的 $B$ 和 $C$ 夹着 $E$ 的乘积之和，其中 $B$ 和 $C$ 的因子总数为 $k-1$。这可以写成：\n$$\nX_k = \\sum_{j=0}^{k-1} B^{k-1-j} E C^j.\n$$\n矩阵指数由级数 $\\exp(A) = \\sum_{k=0}^{\\infty} \\frac{A^k}{k!}$ 定义。代入 $A^k$ 的分块形式：\n$$\n\\exp(A) = \\sum_{k=0}^{\\infty} \\frac{1}{k!} \\begin{bmatrix} B^k  X_k \\\\ 0  C^k \\end{bmatrix} = \\begin{bmatrix} \\sum_{k=0}^{\\infty} \\frac{B^k}{k!}  \\sum_{k=0}^{\\infty} \\frac{X_k}{k!} \\\\ 0  \\sum_{k=0}^{\\infty} \\frac{C^k}{k!} \\end{bmatrix}.\n$$\n识别出矩阵指数的级数，我们得到其分块结构：\n$$\n\\exp(A) = \\begin{bmatrix} \\exp(B)  X \\\\ 0  \\exp(C) \\end{bmatrix},\n$$\n其中非对角块 $X$ 由以下级数给出：\n$$\nX = \\sum_{k=0}^{\\infty} \\frac{X_k}{k!} = \\sum_{k=1}^{\\infty} \\frac{1}{k!} \\left( \\sum_{j=0}^{k-1} B^{k-1-j} E C^j \\right).\n$$\n这就是 $X$ 的显式分块级数表达式。注意，因为 $X_0=0$，所以 $X$ 的求和从 $k=1$ 开始。\n\n**2. $X$ 的积分表示**\n\n通过考虑矩阵值函数 $F(s) = \\exp(As)$（其中 $s \\in \\mathbb{R}$），可以推导出 $X$ 的一个更紧凑的表示。我们知道 $\\frac{dF}{ds} = A F(s)$ 且 $F(0) = I$。设 $F(s)$ 的分块结构为 $F(s) = \\begin{bmatrix} \\exp(Bs)  Y(s) \\\\ 0  \\exp(Cs) \\end{bmatrix}$。对 $s$ 求导得到：\n$$\n\\frac{dF}{ds} = \\begin{bmatrix} B\\exp(Bs)  Y'(s) \\\\ 0  C\\exp(Cs) \\end{bmatrix}.\n$$\n乘积 $AF(s)$ 为：\n$$\nA F(s) = \\begin{bmatrix} B  E \\\\ 0  C \\end{bmatrix} \\begin{bmatrix} \\exp(Bs)  Y(s) \\\\ 0  \\exp(Cs) \\end{bmatrix} = \\begin{bmatrix} B\\exp(Bs)  B Y(s) + E \\exp(Cs) \\\\ 0  C\\exp(Cs) \\end{bmatrix}.\n$$\n令 $\\frac{dF}{ds}$ 和 $AF(s)$ 的 $(1,2)$ 块相等，得到一个关于 $Y(s)$ 的线性常微分方程：\n$$\nY'(s) = B Y(s) + E \\exp(Cs),\n$$\n初始条件为 $Y(0)=0$（由 $F(0)=I$ 得出）。我们使用积分因子 $\\exp(-Bs)$ 来求解此方程。在等式左边乘以 $\\exp(-Bs)$ 得到：\n$$\n\\exp(-Bs)Y'(s) - \\exp(-Bs)B Y(s) = \\exp(-Bs) E \\exp(Cs).\n$$\n左边是一个乘积的导数：$\\frac{d}{ds}(\\exp(-Bs)Y(s))$。从 $0$ 到参数 $t$ 积分：\n$$\n\\int_0^t \\frac{d}{ds}(\\exp(-Bs)Y(s)) ds = \\int_0^t \\exp(-Bs) E \\exp(Cs) ds.\n$$\n对左边应用微积分基本定理：\n$$\n\\exp(-Bt)Y(t) - \\exp(-B\\cdot 0)Y(0) = \\exp(-Bt)Y(t).\n$$\n因此，$Y(t) = \\exp(Bt) \\int_0^t \\exp(-Bs) E \\exp(Cs) ds = \\int_0^t \\exp(B(t-s)) E \\exp(Cs) ds$。\n$\\exp(A)$ 的非对角块 $X$ 对应于 $Y(1)$。\n$$\nX = Y(1) = \\int_0^1 \\exp(B(1-s)) E \\exp(Cs) ds.\n$$\n这就是所要求的积分表示。\n\n**3. $X$ 的西尔维斯特方程**\n\n为了推导 $X$ 的西尔维斯特方程，我们按照建议使用积分符号下的微分法。考虑函数 $G(t) = \\exp(B(1-t)) E \\exp(Ct)$。积分表示为 $X = \\int_0^1 G(t) dt$。\n我们来计算 $G(t)$ 关于 $t$ 的导数：\n\\begin{align*}\n\\frac{dG}{dt} = \\frac{d}{dt} \\left( \\exp(B(1-t)) \\right) E \\exp(Ct) + \\exp(B(1-t)) E \\frac{d}{dt} \\left( \\exp(Ct) \\right) \\\\\n= \\exp(B(1-t))(-B) E \\exp(Ct) + \\exp(B(1-t)) E \\exp(Ct)C \\\\\n= -B G(t) + G(t) C.\n\\end{align*}\n现在，我们将这个恒等式从 $t=0$ 积分到 $t=1$：\n$$\n\\int_0^1 \\frac{dG}{dt} dt = \\int_0^1 (-B G(t) + G(t) C) dt.\n$$\n左边计算结果为 $G(1) - G(0)$：\n$$\nG(1) - G(0) = \\exp(B(0)) E \\exp(C) - \\exp(B(1)) E \\exp(0) = E\\exp(C) - \\exp(B)E.\n$$\n由于积分的线性性质，右边可以被拆分：\n$$\n\\int_0^1 (-B G(t) + G(t) C) dt = -B \\left(\\int_0^1 G(t) dt\\right) + \\left(\\int_0^1 G(t) dt\\right) C = -B X + X C.\n$$\n令两个结果相等，得到 $E\\exp(C) - \\exp(B)E = -B X + X C$。整理后得到西尔维斯特方程：\n$$\nBX - XC = \\exp(B)E - E\\exp(C).\n$$\n该方程的形式为 $L(X) = F$，其中 $L(X) = BX-XC$ 是西尔维斯特算子，$F = \\exp(B)E - E\\exp(C)$。\n\n**4. 解的唯一性与数值稳定性**\n\n使用所提供的恒等式，西尔维斯特方程 $BX-XC=F$ 可以写成向量化的线性系统形式：\n$$\n(I_n \\otimes B - C^T \\otimes I_m) \\operatorname{vec}(X) = \\operatorname{vec}(F).\n$$\n对于任意右端项 $F$，该系统有唯一解的充分必要条件是系数矩阵 $K = I_n \\otimes B - C^T \\otimes I_m$ 可逆。一个矩阵可逆的充分必要条件是其所有特征值都非零。$K$ 的特征值由 $\\lambda_i(B) - \\lambda_j(C)$ 给出，其中 $\\lambda_i(B) \\in \\Lambda(B)$ 和 $\\lambda_j(C) \\in \\Lambda(C)$ 是所有特征值对。因此，$X$ 的唯一解存在的充分必要条件是 $\\Lambda(B) \\cap \\Lambda(C) = \\emptyset$，即 $B$ 和 $C$ 的谱不相交。\n\n数值稳定性关系到解 $X$ 对输入数据（$B$、$C$、$E$ 以及因此产生的 $F$）扰动的敏感性。对于线性系统 $K \\operatorname{vec}(X) = \\operatorname{vec}(F)$，矩阵 $K$ 的条件数决定了这种敏感性。条件数与 $K$ 的最小奇异值 $\\sigma_{\\min}(K)$ 的倒数成正比。谱分离 $\\operatorname{sep}(B, C)$ 正好被定义为这个值：\n$$\n\\operatorname{sep}(B, C) = \\sigma_{\\min}(I_n \\otimes B - C^T \\otimes I_m).\n$$\n一个小的 $\\operatorname{sep}(B, C)$ 值意味着 $K$ 是病态的（接近奇异）。当 $B$ 的一个特征值接近 $C$ 的一个特征值时，就会发生这种情况。在这种情况下，求解西尔维斯特方程在数值上是不稳定的：计算 $\\exp(B)$、$\\exp(C)$ 或 $E$ 时的微小误差，甚至矩阵本身的表示误差，都可能被一个与 $1/\\operatorname{sep}(B, C)$ 成比例的因子放大，从而导致计算出的解 $X$ 出现巨大误差。\n\n### 任务 2：算法\n\n**1. 基于求积的算法**\n该算法使用数值求积来近似计算积分 $X = \\int_0^1 \\exp(B(1-t)) E \\exp(Ct) dt$。具体来说，我们使用在 $[0,1]$ 上的 $q$ 点高斯求积法。\n该积分由一个加权和近似：$X \\approx \\sum_{i=1}^q w_i \\exp(B(1-t_i)) E \\exp(Ct_i)$，其中 $\\{t_i\\}$ 是 $[0,1]$ 上的求积节点，$\\{w_i\\}$ 是相应的权重。\n- **算法**：\n    1. 获取标准高斯-勒让德求积（Gauss-Legendre quadrature）在 $[-1,1]$ 上的 $q$ 个节点 $\\{s_i\\}$ 和权重 $\\{\\hat{w}_i\\}$。\n    2. 将它们变换到区间 $[0,1]$ 上：$t_i = (s_i+1)/2$，$w_i = \\hat{w}_i/2$。\n    3. 初始化 $X_{\\mathrm{int}} = 0_{m \\times n}$。\n    4. 对于 $i = 1, \\dots, q$：a. 计算 $M_i = \\exp(B(1-t_i))$ 和 $N_i = \\exp(Ct_i)$。b. 计算项 $T_i = w_i M_i E N_i$。c. 累加结果：$X_{\\mathrm{int}} = X_{\\mathrm{int}} + T_i$。\n- **计算成本**：主要成本在循环内部，该循环执行 $q$ 次。在循环中，我们计算两个矩阵指数 $\\exp(B(1-t_i))$ 和 $\\exp(Ct_i)$，其成本分别为 $O(m^3)$ 和 $O(n^3)$（使用标准方法，如缩放与平方法）。矩阵乘法的成本为 $O(m^2n + mn^2)$。因此，总成本为 $O(q(m^3+n^3))$。\n- **数值稳定性**：该方法通常是稳定的。其准确性取决于高斯求积法中固有的多项式近似能够多好地捕捉被积函数的行为。该方法的稳定性不直接且灾难性地依赖于 $\\operatorname{sep}(B,C)$。即使 $\\Lambda(B) \\cap \\Lambda(C) \\neq \\emptyset$，积分也是良定义的，并且当 $q \\to \\infty$ 时方法会收敛。预计在 $\\operatorname{sep}(B,C)$ 很小时，它比西尔维斯特方法更稳健。\n\n**2. 基于西尔维斯特求解的算法**\n该算法直接求解线性矩阵方程 $BX - XC = \\exp(B)E - E\\exp(C)$。\n- **算法**：\n    1. 计算 $\\exp(B)$ 和 $\\exp(C)$。\n    2. 构建右端项矩阵 $F = \\exp(B)E - E\\exp(C)$。\n    3. 求解西尔维斯特方程 $BX - XC = F$ 以得到 $X_{\\mathrm{syl}}$。标准求解器如 `scipy.linalg.solve_sylvester` 使用 Bartels-Stewart 算法。\n- **计算成本**：步骤 1 的成本为 $O(m^3+n^3)$。步骤 2 的成本为 $O(m^2n+mn^2)$。步骤 3 使用 Bartels-Stewart 算法，涉及对 $B$ 和 $C$ 的舒尔分解（Schur decomposition）（$O(m^3+n^3)$），然后是一个代换过程（$O(mn(m+n))$）。总成本主要由矩阵指数和舒尔分解决定，导致总复杂度为 $O(m^3+n^3)$。\n- **数值稳定性**：如任务 1 中所分析，该方法的稳定性严重依赖于 $\\operatorname{sep}(B,C)$。如果 $\\operatorname{sep}(B,C)$ 很小，预计该方法将非常不准确且数值不稳定，因为其底层的线性系统会变得严重病态。\n\n### 任务 3：数值实现与验证\n\n实现将遵循任务 2 中描述的算法。我们将使用 `numpy` 进行矩阵代数运算，`scipy.linalg.expm` 用于参考指数和算法组件，`scipy.linalg.solve_sylvester` 用于西尔维斯特求解器，`numpy.polynomial.legendre.leggauss` 用于求积点，以及 `scipy.linalg.svd` 用于计算 $\\operatorname{sep}(B,C)$ 所需的奇异值。将计算四个指定测试用例的结果，并按要求格式化。对测试用例的分析表明，由于其极小的谱分离，案例 2（其中 $\\delta=10^{-6}$）将凸显两种算法之间的稳定性差异。其他案例具有良好分离的谱，两种方法都应能产生准确的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, solve_sylvester, svd\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases.\n    It derives and implements two algorithms to compute the off-diagonal block\n    of the exponential of a block upper triangular matrix.\n    \"\"\"\n    \n    # Define the quadrature order as specified in the problem statement.\n    q = 64\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([[-1.0, 2.0], [0.0, -2.0]]),\n            np.array([[-0.5, 0.5], [0.0, -3.0]]),\n            np.array([[0.3, -0.2], [0.1, 0.4]])\n        ),\n        (\n            np.array([[0.0, 1.0], [0.0, 0.0]]),\n            np.array([[1e-6, 1.0], [0.0, 1e-6]]),\n            np.array([[1.0, 0.0], [0.0, -1.0]])\n        ),\n        (\n            np.array([[0.1, 1.0, 0.0], [0.0, 0.2, 1.0], [0.0, 0.0, 0.3]]),\n            np.array([[-0.25]]),\n            np.array([[1.0], [0.5], [-0.25]])\n        ),\n        (\n            np.array([[5.0, 0.0], [1.0, 4.0]]),\n            np.array([[-3.0, 1.0], [0.0, -2.0]]),\n            np.array([[0.2, -0.1], [0.05, 0.05]])\n        )\n    ]\n\n    results = []\n    \n    # Get Gauss-Legendre quadrature nodes and weights for interval [-1, 1]\n    # np.polynomial.legendre.leggauss is part of numpy and its use is permitted.\n    s, w_hat = np.polynomial.legendre.leggauss(q)\n    # Transform nodes and weights to interval [0, 1]\n    t_quad = (s + 1.0) / 2.0\n    w_quad = w_hat / 2.0\n\n    for B, C, E in test_cases:\n        m, _ = B.shape\n        n = C.shape[0] if C.ndim > 1 else 1\n        m_rows_e = E.shape[0]\n        n_cols_e = E.shape[1] if E.ndim > 1 else 1\n        if m != m_rows_e or n != n_cols_e:\n            C = C.reshape(n, n)\n            E = E.reshape(m, n)\n\n\n        # 1. Construct the full matrix A and compute the reference solution.\n        A = np.block([\n            [B, E],\n            [np.zeros((n, m)), C]\n        ])\n        exp_A_ref = expm(A)\n        norm_ref = np.linalg.norm(exp_A_ref, ord=1)\n        \n        # Pre-compute diagonal blocks of the exponential.\n        exp_B = expm(B)\n        exp_C = expm(C)\n\n        # 2. Algorithm 1: Sylvester-solve-based method.\n        F = exp_B @ E - E @ exp_C\n        try:\n            # The Sylvester equation is BX - XC = F, which maps to AX + XB = Q with A=B, X=X, B=-C, Q=F\n            X_syl = solve_sylvester(B, -C, F)\n        except Exception:\n            # In case of failure, though solve_sylvester is robust\n            X_syl = np.full((m, n), np.nan)\n            \n        exp_A_syl = np.block([\n            [exp_B, X_syl],\n            [np.zeros((n, m)), exp_C]\n        ])\n        err_syl = np.linalg.norm(exp_A_ref - exp_A_syl, ord=1) / norm_ref\n\n        # 3. Algorithm 2: Integral-quadrature-based method.\n        X_int = np.zeros((m, n))\n        for i in range(q):\n            ti = t_quad[i]\n            wi = w_quad[i]\n            # Integrand is exp(B(1-t)) * E * exp(Ct)\n            term = expm(B * (1.0 - ti)) @ E @ expm(C * ti)\n            X_int += wi * term\n\n        exp_A_int = np.block([\n            [exp_B, X_int],\n            [np.zeros((n, m)), exp_C]\n        ])\n        err_int = np.linalg.norm(exp_A_ref - exp_A_int, ord=1) / norm_ref\n\n        # 4. Compute spectral separation sep(B, C).\n        # sep(B,C) = sigma_min(I_n kron B - C^T kron I_m)\n        K = np.kron(np.eye(n), B) - np.kron(C.T, np.eye(m))\n        # scipy.linalg.svd returns singular values in descending order.\n        singular_values = svd(K, compute_uv=False)\n        sep_BC = singular_values[-1]\n\n        results.append([err_syl, err_int, sep_BC])\n    \n    # Format the final output string.\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{res[0]:.6e}, {res[1]:.6e}, {res[2]:.6e}]\"\n        if i  len(results) - 1:\n            output_str += \", \"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3591556"}]}