{"hands_on_practices": [{"introduction": "要直接求解西尔维斯特方程，最经典和稳健的方法之一是Bartels-Stewart算法。该算法的核心思想是首先将系数矩阵变换为更简单的形式（实舒尔形式），然后通过一个类似于回代的过程逐块求解。本练习将引导你推导该算法核心的块回代步骤，通过处理不同尺寸对角块的组合情况，你将亲手构建解决方案，从而深刻理解该算法的内部工作机制。[@problem_id:3578476]", "problem": "设 $T \\in \\mathbb{R}^{n \\times n}$ 和 $S \\in \\mathbb{R}^{m \\times m}$ 均为实 Schur 形式，即两者均为分块上拟三角矩阵，其对角块的大小为 $1 \\times 1$ 或 $2 \\times 2$。考虑 Sylvester 方程 $T Y + Y S = \\tilde{C}$，其中 $Y \\in \\mathbb{R}^{n \\times m}$ 为未知矩阵，$\\tilde{C} \\in \\mathbb{R}^{n \\times m}$ 为给定的右端项。将 $T$ 和 $S$ 沿其 Schur 块进行分块，并将 $Y$ 和 $\\tilde{C}$ 共形地分块为块矩阵 $Y_{ij}$ 和 $\\tilde{C}_{ij}$，其中每个 $Y_{ij}$ 的大小等于 $T$ 的第 $i$ 个对角块的大小乘以 $S$ 的第 $j$ 个对角块的大小。\n\n从实 Schur 形式、Sylvester 方程和上三角块结构的定义出发，推导块回代方程，这些方程能够用先前计算出的块来表示并分离出 $Y_{ij}$。显式地写出 $Y_{ij}$ 的系数算子，针对由对角块大小决定的四种情况：\n\n- $T$ 中为 $1 \\times 1$ 块，$S$ 中为 $1 \\times 1$ 块，\n- $T$ 中为 $2 \\times 2$ 块，$S$ 中为 $1 \\times 1$ 块，\n- $T$ 中为 $1 \\times 1$ 块，$S$ 中为 $2 \\times 2$ 块，\n- $T$ 中为 $2 \\times 2$ 块，$S$ 中为 $2 \\times 2$ 块。\n\n对于每种情况，写出求解 $Y_{ij}$ 所得的线性系统，并用 $T$ 和 $S$ 的相应对角块明确地表示出系数矩阵。\n\n最后，专门研究 $2 \\times 2$–$2 \\times 2$ 的情况。假设 $T$ 的 $2 \\times 2$ 对角块具有复特征值 $\\lambda$ 和 $\\overline{\\lambda}$，且 $S$ 的 $2 \\times 2$ 对角块具有复特征值 $\\mu$ 和 $\\overline{\\mu}$，每个块都处于实 Schur 形式。设 $M$ 为用于求解 $2 \\times 2$ 块 $Y_{ij}$ 的向量化线性系统的 $4 \\times 4$ 系数矩阵。计算 $\\det(M)$ 并为其提供一个闭式解析表达式，该表达式仅用 $\\lambda$、$\\overline{\\lambda}$、$\\mu$ 和 $\\overline{\\mu}$ 表示。不需要四舍五入；请提供精确表达式。", "solution": "该问题要求推导用于 Sylvester 方程 $T Y + Y S = \\tilde{C}$ 的块回代方法（其中 $T$ 和 $S$ 处于实 Schur 形式），并分析待求解的局部线性系统，包括对一个特定情况进行行列式计算。\n\n\\subsection*{第一部分：块回代方程的推导}\n设矩阵 $T \\in \\mathbb{R}^{n \\times n}$ 和 $S \\in \\mathbb{R}^{m \\times m}$ 根据其实 Schur 形式进行分块。这意味着它们是分块上拟三角矩阵。设 $T$ 有 $p$ 个对角块，$S$ 有 $q$ 个对角块。\n$$\nT = \\begin{pmatrix} T_{11}  T_{12}  \\cdots  T_{1p} \\\\  T_{22}  \\cdots  T_{2p} \\\\   \\ddots  \\vdots \\\\    T_{pp} \\end{pmatrix}, \\quad\nS = \\begin{pmatrix} S_{11}  S_{12}  \\cdots  S_{1q} \\\\  S_{22}  \\cdots  S_{2q} \\\\   \\ddots  \\vdots \\\\    S_{qq} \\end{pmatrix}\n$$\n此处，$ik$ 时 $T_{ik} = 0$，$lj$ 时 $S_{lj} = 0$。对角块 $T_{ii}$ 和 $S_{jj}$ 的大小为 $1 \\times 1$ 或 $2 \\times 2$。矩阵 $Y \\in \\mathbb{R}^{n \\times m}$ 和 $\\tilde{C} \\in \\mathbb{R}^{n \\times m}$ 被共形分块，其块 $Y_{ij}$ 和 $\\tilde{C}_{ij}$ 的大小为 $n_i \\times m_j$，其中 $n_i$ 是 $T_{ii}$ 的大小，$m_j$ 是 $S_{jj}$ 的大小。\n\nSylvester 方程 $T Y + Y S = \\tilde{C}$ 可以写成分块形式。方程的第 $(i,j)$ 块由下式给出：\n$$\n(T Y)_{ij} + (Y S)_{ij} = \\tilde{C}_{ij}\n$$\n矩阵乘积 $TY$ 的第 $(i,j)$ 块为 $\\sum_{k=1}^{p} T_{ik} Y_{kj}$。由于 $T$ 是分块上三角矩阵（$ik$ 时 $T_{ik}=0$），这个和简化为 $\\sum_{k=i}^{p} T_{ik} Y_{kj}$。\n$YS$ 的第 $(i,j)$ 块为 $\\sum_{l=1}^{q} Y_{il} S_{lj}$。由于 $S$ 是分块上三角矩阵（$lj$ 时 $S_{lj}=0$），这个和简化为 $\\sum_{l=1}^{j} Y_{il} S_{lj}$。\n\n将这些代入分块方程得到：\n$$\n\\sum_{k=i}^{p} T_{ik} Y_{kj} + \\sum_{l=1}^{j} Y_{il} S_{lj} = \\tilde{C}_{ij}\n$$\n我们可以分离出包含 $Y_{ij}$ 的项（对应于第一个和中的 $k=i$ 和第二个和中的 $l=j$）：\n$$\n\\left( T_{ii} Y_{ij} + \\sum_{k=i+1}^{p} T_{ik} Y_{kj} \\right) + \\left( Y_{ij} S_{jj} + \\sum_{l=1}^{j-1} Y_{il} S_{lj} \\right) = \\tilde{C}_{ij}\n$$\n重新整理以求解含 $Y_{ij}$ 的项：\n$$\nT_{ii} Y_{ij} + Y_{ij} S_{jj} = \\tilde{C}_{ij} - \\sum_{k=i+1}^{p} T_{ik} Y_{kj} - \\sum_{l=1}^{j-1} Y_{il} S_{lj}\n$$\n该方程为块 $Y_{ij}$ 定义了一个小型的 Sylvester 方程。右端项，我们称之为 $C'_{ij}$，仅依赖于 $k  i$ 的块 $Y_{kj}$ （即第 $i$ 个块行下方的块）和 $l  j$ 的块 $Y_{il}$ （即第 $j$ 个块列左侧的块）。\n\n这种结构表明了计算 $Y$ 的各个块的特定顺序。我们可以通过将 $i$ 从 $p$ 向下迭代到 $1$，并对每个 $i$ 将 $j$ 从 $1$ 向上迭代到 $q$ 来计算块 $Y_{ij}$。在步骤 $(i,j)$，所有需要的块 $Y_{kj}$ ($ki$) 和 $Y_{il}$ ($lj$) 都已经计算过了。\n\n\\subsection*{第二部分：按块大小划分的线性系统}\n对于每个 $(i,j)$，我们都必须求解一个小的 Sylvester 方程 $T_{ii} Y_{ij} + Y_{ij} S_{jj} = C'_{ij}$。通过向量化，这变成了一个标准的线性系统 $(I_{m_j} \\otimes T_{ii} + S_{jj}^{\\top} \\otimes I_{n_i}) \\mathrm{vec}(Y_{ij}) = \\mathrm{vec}(C'_{ij})$。系数矩阵的大小是 $(n_i m_j) \\times (n_i m_j)$。\n1.  **$1 \\times 1$–$1 \\times 1$ 情况**：$n_i=1, m_j=1$。$T_{ii}$ 和 $S_{jj}$ 都是标量。方程变为 $T_{ii} Y_{ij} + Y_{ij} S_{jj} = C'_{ij}$，解是 $Y_{ij} = C'_{ij} / (T_{ii} + S_{jj})$。线性系统是 $1 \\times 1$ 的，系数矩阵是 $[T_{ii}+S_{jj}]$。\n2.  **$2 \\times 2$–$1 \\times 1$ 情况**：$n_i=2, m_j=1$。$T_{ii}$ 是一个 $2 \\times 2$ 矩阵，$S_{jj}$ 是一个标量，$Y_{ij}$ 是一个 $2 \\times 1$ 向量。方程是 $T_{ii} Y_{ij} + Y_{ij} S_{jj} = C'_{ij}$，这可以重写为 $(T_{ii} + S_{jj} I_2) Y_{ij} = C'_{ij}$。这是一个 $2 \\times 2$ 的线性系统，系数矩阵是 $T_{ii} + S_{jj} I_2$。\n3.  **$1 \\times 1$–$2 \\times 2$ 情况**：$n_i=1, m_j=2$。$T_{ii}$ 是一个标量，$S_{jj}$ 是一个 $2 \\times 2$ 矩阵，$Y_{ij}$ 是一个 $1 \\times 2$ 行向量。方程是 $T_{ii} Y_{ij} + Y_{ij} S_{jj} = C'_{ij}$，这可以重写为 $Y_{ij} (T_{ii} I_2 + S_{jj}) = C'_{ij}$。两边取转置得到 $(T_{ii} I_2 + S_{jj}^{\\top}) Y_{ij}^{\\top} = (C'_{ij})^{\\top}$。这是一个 $2 \\times 2$ 的线性系统，系数矩阵是 $T_{ii} I_2 + S_{jj}^{\\top}$。\n4.  **$2 \\times 2$–$2 \\times 2$ 情况**：$n_i=2, m_j=2$。$T_{ii}$ 和 $S_{jj}$ 都是 $2 \\times 2$ 矩阵，$Y_{ij}$ 是一个 $2 \\times 2$ 矩阵。向量化方程 $(I_2 \\otimes T_{ii} + S_{jj}^{\\top} \\otimes I_2) \\mathrm{vec}(Y_{ij}) = \\mathrm{vec}(C'_{ij})$ 是一个 $4 \\times 4$ 的线性系统。系数矩阵是 $M = I_2 \\otimes T_{ii} + S_{jj}^{\\top} \\otimes I_2$。\n\n\\subsection*{第三部分：$2 \\times 2$–$2 \\times 2$ 情况下的行列式}\n我们要求解 $M = I_2 \\otimes T_{ii} + S_{jj}^{\\top} \\otimes I_2$ 的行列式。一个关于克罗内克和的基本定理指出，如果 $A \\in \\mathbb{R}^{n \\times n}$ 且 $B \\in \\mathbb{R}^{m \\times m}$，则 $I_m \\otimes A + B \\otimes I_n$ 的特征值是所有可能的 $\\lambda_p + \\mu_q$ 的和，其中 $\\lambda_p \\in \\sigma(A)$ 且 $\\mu_q \\in \\sigma(B)$。在本例中，系数矩阵是 $M = I_2 \\otimes T_{ii} + S_{jj}^{\\top} \\otimes I_2$。$M$ 的特征值是 $T_{ii}$ 的特征值与 $S_{jj}^{\\top}$ 的特征值的所有可能组合之和。由于一个矩阵和它的转置有相同的特征值，$\\sigma(S_{jj}^{\\top}) = \\sigma(S_{jj})$。\n\n给定 $T_{ii}$ 的特征值是 $\\{\\lambda, \\overline{\\lambda}\\}$，$S_{jj}$ 的特征值是 $\\{\\mu, \\overline{\\mu}\\}$。那么 $M$ 的四个特征值是：\n$$\n\\lambda + \\mu, \\quad \\lambda + \\overline{\\mu}, \\quad \\overline{\\lambda} + \\mu, \\quad \\overline{\\lambda} + \\overline{\\mu}\n$$\n矩阵的行列式是其特征值的乘积。因此，\n$$\n\\det(M) = (\\lambda + \\mu)(\\lambda + \\overline{\\mu})(\\overline{\\lambda} + \\mu)(\\overline{\\lambda} + \\overline{\\mu})\n$$\n由于 $(\\overline{z_1} + \\overline{z_2}) = \\overline{z_1+z_2}$，第三项 $\\overline{\\lambda}+\\mu$ 与第二项 $\\lambda+\\overline{\\mu}$ 是复共轭关系，而第四项 $\\overline{\\lambda}+\\overline{\\mu}$ 与第一项 $\\lambda+\\mu$ 是复共轭关系。因此，行列式 $\\det(M)$ 是实数，因为它是两个复共轭对的乘积。\n该表达式是最终的解析结果。", "answer": "$$\n\\boxed{(\\lambda+\\mu)(\\overline{\\lambda}+\\overline{\\mu})(\\lambda+\\overline{\\mu})(\\overline{\\lambda}+\\mu)}\n$$", "id": "3578476"}, {"introduction": "西尔维斯特方程不仅是一个抽象的代数问题，它更是矩阵扰动理论中的一个基本工具。其中一个最重要的应用是计算矩阵在微小扰动下其不变子空间的一阶变化。本练习将引导你从第一性原理出发，推导出描述舒尔基变化的西尔维斯特方程，并通过编程实现其求解过程。这不仅能巩固你对理论的理解，还能让你接触到如保持解的正交性等实际数值计算中的重要考量。[@problem_id:3578469]", "problem": "考虑一个实方阵 $A \\in \\mathbb{R}^{n \\times n}$，它允许进行实舒尔分解 $A = Q T Q^{\\top}$，其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$T \\in \\mathbb{R}^{n \\times n}$ 是上拟三角矩阵。令 $A(t) = A + t E$ 为一个光滑扰动，其中 $E \\in \\mathbb{R}^{n \\times n}$ 是一个固定矩阵，$t \\in \\mathbb{R}$ 是一个小标量。假设 $A(t)$ 以实舒尔形式表示为 $A(t) = Q(t) T(t) Q(t)^{\\top}$，且满足 $Q(0) = Q$ 和 $T(0) = T$。根据一个选定的 $k$ 维不变子空间，将舒尔形式分块如下\n$$\nT = \\begin{bmatrix}\nT_{11}  T_{12} \\\\\n0  T_{22}\n\\end{bmatrix}, \\quad Q = \\begin{bmatrix} Q_1  Q_2 \\end{bmatrix},\n$$\n其中 $T_{11} \\in \\mathbb{R}^{k \\times k}$ 对应于选定的特征值簇，$T_{22} \\in \\mathbb{R}^{(n-k) \\times (n-k)}$ 对应于其补集，$T_{12} \\in \\mathbb{R}^{k \\times (n-k)}$。\n\n从数值线性代数的第一性原理出发，即可正交分解和实舒尔形式的可微性，推导连接 $E$、舒尔因子的导数以及由 $Q(t)$ 的斜对称生成元导出的换位子的一阶关系。具体来说，证明如果为了保持块上三角结构，强制 $T$ 的导数在 $t=0$ 处的左下块为零，那么 $Q(t)$ 生成元的非对角块必须满足一个西尔维斯特方程。你的推导必须从恒等式 $Q(t)^{\\top} Q(t) = I$ 和 $A(t) = Q(t) T(t) Q(t)^{\\top}$ 开始，通过在 $t=0$ 处对 $t$ 求导来进行，并且仅使用这些基本性质和矩阵换位子的定义。\n\n实现一个算法，在给定 $(Q, T)$、一个扰动 $E$ 和块大小 $k$ 的情况下，执行以下步骤：\n- 计算 $F = Q^{\\top} E Q$ 并根据 $T$ 的分块方式对其进行相应的分块。\n- 通过构建并求解适当的西尔维斯特方程，求解关系式 $Q^{\\top} \\dot{Q} = \\Omega$ 中斜对称生成元 $\\Omega \\in \\mathbb{R}^{n \\times n}$ 的非对角块。\n- 使用求解出的非对角块和对角块上的零元素构造一个斜对称矩阵 $\\Omega$，并计算与推导关系一致的一阶扰动 $dT$。\n- 用一个小步长 $\\varepsilon$ 形成更新后的正交因子 $Q' = Q + \\varepsilon Q \\Omega$，并实施一个正交性控制步骤，使用一种在弗罗贝尼乌斯范数下保持与 $Q'$ 接近的数值稳定方法来重新正交化 $Q'$。\n\n你的程序必须生成定量诊断信息，以验证西尔维斯特方程解的正确性和正交性控制的有效性。对每个测试用例，计算：\n1. 西尔维斯特残差的弗罗贝尼乌斯范数 $\\| T_{22} \\Omega_{21} - \\Omega_{21} T_{11} + F_{21} \\|_F$。\n2. $dT$ 左下块的弗罗贝尼乌斯范数，即 $\\| (dT)_{21} \\|_F$。\n3. $Q'$ 的正交性缺陷的弗罗贝尼乌斯范数，定义为 $\\| Q'^{\\top} Q' - I \\|_F$。\n4. 重新正交化后的相同正交性缺陷，定义为 $\\| \\widehat{Q}^{\\top} \\widehat{Q} - I \\|_F$，其中 $\\widehat{Q}$ 是 $Q'$ 的重新正交化版本。\n5. 一个布尔值，指示正交性控制是否减少了缺陷，即控制后的缺陷是否严格小于控制前的缺陷。\n\n设计一个包含四个案例的测试套件，使用固定的种子生成可复现的数据，覆盖特征值簇分离良好、近共振簇、最小子空间维度和对称情况：\n- 案例 1 (特征值簇分离良好): $n = 6$, $k = 3$。设置 $T_{11}$ 的对角线元素为 $[1.0, 1.5, 2.0]$，$T_{22}$ 的对角线元素为 $[4.0, 5.0, 6.0]$，$T_{12}$ 的元素使用种子为 $10$ 的伪随机数生成器从 $[-0.1, 0.1]$ 均匀抽取。从一个种子为 $11$ 的标准正态矩阵的 $\\mathrm{QR}$ 分解构造 $Q$。将 $E$ 设置为一个种子为 $12$、经 $10^{-3}$ 缩放的标准正态矩阵。\n- 案例 2 (近共振簇): $n = 6$, $k = 3$。设置 $T_{11}$ 的对角线元素为 $[2.00, 2.10, 2.20]$，$T_{22}$ 的对角线元素为 $[2.05, 2.15, 2.25]$，$T_{12}$ 的元素使用种子为 $20$ 从 $[-0.5, 0.5]$ 均匀抽取。从一个种子为 $21$ 的标准正态矩阵的 $\\mathrm{QR}$ 分解构造 $Q$。将 $E$ 设置为一个种子为 $22$、经 $10^{-3}$ 缩放的标准正态矩阵。\n- 案例 3 (最小子空间维度): $n = 3$, $k = 1$。设置 $T_{11}$ 的对角线元素为 $[1.0]$，$T_{22}$ 的对角线元素为 $[3.0, 4.0]$，$T_{12} = 0$。使用 $Q = I$。将 $E$ 设置为一个种子为 $30$、经 $10^{-2}$ 缩放的标准正态矩阵。\n- 案例 4 (对称情况): $n = 5$, $k = 2$。构造 $A$ 为 $A = Q D Q^{\\top}$，其中 $D = \\mathrm{diag}(1.0, 2.0, 3.0, 4.0, 5.0)$，且 $Q$ 来自一个种子为 $41$ 的标准正态矩阵的 $\\mathrm{QR}$ 分解，因此 $T=D$ 是对角矩阵。将 $E$ 设置为一个通过对称化一个种子为 $42$ 的标准正态矩阵并按 $10^{-3}$ 缩放得到的对称矩阵。\n\n在所有案例中，对 $Q'$ 更新使用 $\\varepsilon = 10^{-3}$。你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例按上述顺序贡献一个包含五个条目的列表。例如，输出格式必须是\n$$\n[ [r_1, d_1, o^{\\mathrm{pre}}_1, o^{\\mathrm{post}}_1, b_1], [r_2, d_2, o^{\\mathrm{pre}}_2, o^{\\mathrm{post}}_2, b_2], [r_3, d_3, o^{\\mathrm{pre}}_3, o^{\\mathrm{post}}_3, b_3], [r_4, d_4, o^{\\mathrm{pre}}_4, o^{\\mathrm{post}}_4, b_4] ].\n$$\n所有数值量都应报告为浮点数，不带任何物理单位。此任务中不出现角度。布尔值必须打印为 True 或 False。程序必须是自包含的，不需要任何输入，并且必须遵守指定的执行环境。", "solution": "该问题要求推导一个西尔维斯特方程，该方程控制了矩阵 $A$ 的一个不变子空间在光滑扰动 $A(t) = A+tE$ 下的一阶扰动。推导之后是一个数值实现，用于求解该方程并验证相关的理论结果。推导从第一性原理开始，考虑实舒尔分解的定义性质。\n\n令 $A(t) = A + tE$ 为一个光滑矩阵值函数，其中 $A, E \\in \\mathbb{R}^{n \\times n}$，$t \\in \\mathbb{R}$ 是一个小标量。$A(t)$ 的实舒尔分解由 $A(t) = Q(t) T(t) Q(t)^{\\top}$ 给出，其中 $Q(t)$ 是一个正交矩阵，$T(t)$ 是一个上拟三角矩阵。在 $t=0$ 时，我们有 $A(0)=A$，$Q(0)=Q$ 和 $T(0)=T$。\n\n我们的推导从两个在 $0$ 的邻域内对所有 $t$ 都成立的基本恒等式开始：\n1. 正交性条件：$Q(t)^{\\top} Q(t) = I$，其中 $I$ 是单位矩阵。\n2. 舒尔分解恒等式：$A(t) = Q(t) T(t) Q(t)^{\\top}$。\n\n我们对这些恒等式关于 $t$ 求导，并在 $t=0$ 处计算结果。令 $\\dot{Q} = \\frac{d Q(t)}{dt}|_{t=0}$ 和 $\\dot{T} = \\frac{d T(t)}{dt}|_{t=0}$。\n\n首先，使用乘法法则对正交性条件求导得到：\n$$\n\\frac{d}{dt} (Q(t)^{\\top} Q(t)) = \\dot{Q}(t)^{\\top} Q(t) + Q(t)^{\\top} \\dot{Q}(t) = \\frac{d}{dt}(I) = 0\n$$\n在 $t=0$ 处取值：\n$$\n\\dot{Q}^{\\top} Q + Q^{\\top} \\dot{Q} = 0\n$$\n我们定义旋转生成元 $\\Omega \\in \\mathbb{R}^{n \\times n}$ 为 $\\Omega = Q^{\\top} \\dot{Q}$。将其代入方程，我们得到 $(\\dot{Q}^{\\top} Q) + \\Omega = (Q^{\\top} \\dot{Q})^{\\top} + \\Omega = \\Omega^{\\top} + \\Omega = 0$。这证明了 $\\Omega$ 是一个斜对称矩阵，即 $\\Omega^{\\top} = -\\Omega$。从 $\\Omega = Q^{\\top} \\dot{Q}$，我们可以将正交因子的导数表示为 $\\dot{Q} = Q\\Omega$。\n\n其次，我们对舒尔分解恒等式求导。左侧的导数是 $\\frac{d}{dt}A(t) = \\frac{d}{dt}(A+tE) = E$。对右侧应用乘法法则得到：\n$$\nE = \\dot{Q} T Q^{\\top} + Q \\dot{T} Q^{\\top} + Q T \\dot{Q}^{\\top}\n$$\n为了分离出导数项，我们左乘 $Q^{\\top}$ 并右乘 $Q$：\n$$\nQ^{\\top} E Q = Q^{\\top}\\dot{Q} T Q^{\\top}Q + Q^{\\top}Q \\dot{T} Q^{\\top}Q + Q^{\\top}Q T \\dot{Q}^{\\top}Q\n$$\n使用 $Q^{\\top}Q=I$，$\\Omega = Q^{\\top}\\dot{Q}$ 和 $\\dot{Q}^{\\top}Q = \\Omega^{\\top} = -\\Omega$，方程得以简化。注意 $\\dot{Q}^{\\top}Q = (Q^{\\top}\\dot{Q})^{\\top} = \\Omega^\\top$。一个常见的错误是算错最后一项：出现的不是 $\\dot{Q}^{\\top}Q$，而是 $\\dot{Q}^{\\top}$。而 $\\dot{Q}^\\top = (Q\\Omega)^\\top = \\Omega^\\top Q^\\top = -\\Omega Q^\\top$。所以最后一项变为 $Q^\\top Q T (-\\Omega Q^\\top) Q = -T\\Omega$。\n让我们将 $\\dot{Q} = Q\\Omega$ 和 $\\dot{Q}^{\\top} = \\Omega^\\top Q^\\top = -\\Omega Q^{\\top}$ 代入 $E$ 的表达式中：\n$$\nE = (Q\\Omega) T Q^{\\top} + Q \\dot{T} Q^{\\top} + Q T (\\Omega^\\top Q^{\\top}) = Q ( \\Omega T + \\dot{T} + T \\Omega^\\top ) Q^{\\top} = Q ( \\Omega T - T \\Omega + \\dot{T} ) Q^{\\top}\n$$\n左乘 $Q^{\\top}$ 并右乘 $Q$ 得到：\n$$\nQ^{\\top} E Q = \\Omega T - T \\Omega + \\dot{T}\n$$\n令 $F = Q^{\\top} E Q$。该方程可以用矩阵换位子 $[\\Omega, T] = \\Omega T - T \\Omega$ 来表示：\n$$\n\\dot{T} = F - [\\Omega, T]\n$$\n现在，我们根据 $k$ 维不变子空间对矩阵 $T$、$F$、$\\Omega$ 和 $\\dot{T}$ 进行相应的分块：\n$$\nT = \\begin{bmatrix} T_{11}  T_{12} \\\\ 0  T_{22} \\end{bmatrix}, \\quad F = \\begin{bmatrix} F_{11}  F_{12} \\\\ F_{21}  F_{22} \\end{bmatrix}, \\quad \\Omega = \\begin{bmatrix} \\Omega_{11}  \\Omega_{12} \\\\ \\Omega_{21}  \\Omega_{22} \\end{bmatrix}, \\quad \\dot{T} = \\begin{bmatrix} \\dot{T}_{11}  \\dot{T}_{12} \\\\ \\dot{T}_{21}  \\dot{T}_{22} \\end{bmatrix}\n$$\n其中 $T_{11} \\in \\mathbb{R}^{k \\times k}$，$F_{11} \\in \\mathbb{R}^{k \\times k}$ 等。由于 $\\Omega$ 是斜对称的，$\\Omega_{11}$ 和 $\\Omega_{22}$ 必须是斜对称的，并且 $\\Omega_{12} = -\\Omega_{21}^{\\top}$。\n\n换位子的分块形式是：\n$$\n[\\Omega, T] = \\begin{bmatrix} [\\Omega_{11}, T_{11}] - T_{12}\\Omega_{21}  \\Omega_{11}T_{12} + \\Omega_{12}T_{22} - T_{11}\\Omega_{12} - T_{12}\\Omega_{22} \\\\ \\Omega_{21}T_{11} - T_{22}\\Omega_{21}  [\\Omega_{22}, T_{22}] + \\Omega_{21}T_{12} \\end{bmatrix}\n$$\n将此代入 $\\dot{T} = F - [\\Omega, T]$ 并考察 (2,1) 块可得：\n$$\n\\dot{T}_{21} = F_{21} - (\\Omega_{21}T_{11} - T_{22}\\Omega_{21}) = F_{21} + T_{22}\\Omega_{21} - \\Omega_{21}T_{11}\n$$\n问题陈述我们必须强制 $T(t)$ 的块上三角结构在小 $t$ 时保持不变。这意味着其导数 $\\dot{T}$ 的 (2,1) 块必须为零：$\\dot{T}_{21}=0$。这个条件得出：\n$$\n0 = F_{21} + T_{22}\\Omega_{21} - \\Omega_{21}T_{11}\n$$\n整理后得到关于非对角块 $\\Omega_{21}$ 的西尔维斯特方程：\n$$\nT_{22} \\Omega_{21} - \\Omega_{21} T_{11} = -F_{21}\n$$\n这个基本方程决定了不变子空间在扰动 $E$ 下的旋转。解 $\\Omega_{21}$ 的存在性和唯一性取决于 $T_{11}$ 和 $T_{22}$ 的谱是分离的。\n\n接下来的实现将计算问题中指定的量。它将求解这个关于 $\\Omega_{21}$ 的西尔维斯特方程。为了唯一确定 $\\Omega$，我们施加规范条件，即其对角块为零，即 $\\Omega_{11}=0$ 和 $\\Omega_{22}=0$。这得到 $\\Omega = \\begin{pmatrix} 0  -\\Omega_{21}^{\\top} \\\\ \\Omega_{21}  0 \\end{pmatrix}$。当 $\\Omega$ 完全确定后，$\\dot{T}$ 也随之确定。然后我们将计算 $Q$ 的一阶更新 $Q' = Q + \\varepsilon\\dot{Q} = Q(I + \\varepsilon\\Omega)$，并评估其与正交性的偏差。最后，我们将使用极分解对 $Q'$ 应用重新正交化程序，该程序找到弗罗贝尼乌斯范数意义下最近的正交矩阵，并量化正交性的改善。所要求的诊断信息将验证此过程的每一步。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_sylvester, polar, qr\n\ndef solve():\n    \"\"\"\n    Solves the numerical linear algebra problem for four test cases.\n    \"\"\"\n\n    def run_case(n, k, T, Q, E, epsilon):\n        \"\"\"\n        Executes the logic for a single test case.\n        \"\"\"\n        # Step 1: Compute F and partition it\n        F = Q.T @ E @ Q\n        F11 = F[:k, :k]\n        F12 = F[:k, k:]\n        F21 = F[k:, :k]\n        F22 = F[k:, k:]\n        \n        T11 = T[:k, :k]\n        T22 = T[k:, k:]\n\n        # Step 2: Solve the Sylvester equation for Omega_21\n        # T22 * Omega_21 - Omega_21 * T11 = -F21\n        # Scipy solves AX + XB = Q, so A=T22, X=Omega_21, B=-T11, Q=-F21\n        Omega_21 = solve_sylvester(T22, -T11, -F21)\n        \n        # Diagnostic 1: Sylvester residual norm\n        sylvester_residual = np.linalg.norm(T22 @ Omega_21 - Omega_21 @ T11 + F21, 'fro')\n\n        # Step 3: Construct Omega and compute dT\n        Omega_11 = np.zeros((k, k))\n        Omega_22 = np.zeros((n - k, n - k))\n        Omega_12 = -Omega_21.T\n        Omega = np.block([\n            [Omega_11, Omega_12],\n            [Omega_21, Omega_22]\n        ])\n        \n        # dT = F - [Omega, T] = F - (Omega @ T - T @ Omega)\n        dT = F - (Omega @ T - T @ Omega)\n        \n        # Diagnostic 2: Norm of the (2,1) block of dT\n        dT_21_norm = np.linalg.norm(dT[k:, :k], 'fro')\n        \n        # Step 4: Form updated Q' and perform orthogonality control\n        I_n = np.identity(n)\n        # Q' = Q + eps * dQ = Q + eps * Q @ Omega = Q @ (I + eps * Omega)\n        Q_prime = Q @ (I_n + epsilon * Omega)\n        \n        # Diagnostic 3: Pre-control orthogonality defect\n        pre_ortho_defect = np.linalg.norm(Q_prime.T @ Q_prime - I_n, 'fro')\n\n        # Re-orthonormalize Q' using polar decomposition to find the closest orthogonal matrix.\n        Q_hat, _ = polar(Q_prime)\n        \n        # Diagnostic 4: Post-control orthogonality defect\n        post_ortho_defect = np.linalg.norm(Q_hat.T @ Q_hat - I_n, 'fro')\n        \n        # Diagnostic 5: Boolean for defect reduction\n        defect_reduced = post_ortho_defect  pre_ortho_defect\n        \n        return [sylvester_residual, dT_21_norm, pre_ortho_defect, post_ortho_defect, defect_reduced]\n\n    test_cases = []\n    epsilon = 1e-3\n\n    # Case 1: Well-separated cluster\n    n, k = 6, 3\n    rng_T12 = np.random.default_rng(10)\n    rng_Q = np.random.default_rng(11)\n    rng_E = np.random.default_rng(12)\n    \n    T11 = np.diag([1.0, 1.5, 2.0])\n    T22 = np.diag([4.0, 5.0, 6.0])\n    T12 = rng_T12.uniform(-0.1, 0.1, size=(k, n - k))\n    T = np.block([[T11, T12], [np.zeros((n - k, k)), T22]])\n    Q, _ = qr(rng_Q.standard_normal(size=(n, n)))\n    E = rng_E.standard_normal(size=(n, n)) * 1e-3\n    test_cases.append(('Case 1', n, k, T, Q, E, epsilon))\n\n    # Case 2: Near-resonant cluster\n    n, k = 6, 3\n    rng_T12 = np.random.default_rng(20)\n    rng_Q = np.random.default_rng(21)\n    rng_E = np.random.default_rng(22)\n    \n    T11 = np.diag([2.00, 2.10, 2.20])\n    T22 = np.diag([2.05, 2.15, 2.25])\n    T12 = rng_T12.uniform(-0.5, 0.5, size=(k, n - k))\n    T = np.block([[T11, T12], [np.zeros((n - k, k)), T22]])\n    Q, _ = qr(rng_Q.standard_normal(size=(n, n)))\n    E = rng_E.standard_normal(size=(n, n)) * 1e-3\n    test_cases.append(('Case 2', n, k, T, Q, E, epsilon))\n    \n    # Case 3: Minimal subspace dimension\n    n, k = 3, 1\n    rng_E = np.random.default_rng(30)\n    \n    T11 = np.array([[1.0]])\n    T22 = np.diag([3.0, 4.0])\n    T12 = np.zeros((k, n-k))\n    T = np.block([[T11, T12], [np.zeros((n - k, k)), T22]])\n    Q = np.identity(n)\n    E = rng_E.standard_normal(size=(n, n)) * 1e-2\n    test_cases.append(('Case 3', n, k, T, Q, E, epsilon))\n    \n    # Case 4: Symmetric case\n    n, k = 5, 2\n    rng_Q = np.random.default_rng(41)\n    rng_E = np.random.default_rng(42)\n    \n    T = np.diag([1.0, 2.0, 3.0, 4.0, 5.0])\n    Q, _ = qr(rng_Q.standard_normal(size=(n, n)))\n    E_rand = rng_E.standard_normal(size=(n, n))\n    E = (E_rand + E_rand.T) / 2 * 1e-3\n    test_cases.append(('Case 4', n, k, T, Q, E, epsilon))\n\n    results = []\n    for _, n_case, k_case, T_case, Q_case, E_case, eps_case in test_cases:\n        result = run_case(n_case, k_case, T_case, Q_case, E_case, eps_case)\n        results.append(result)\n\n    # Format the final output string\n    # E.g., [[1.23, ...], [4.56, ...]]\n    output_str = \"[\" + \", \".join([str(res) for res in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3578469"}, {"introduction": "西尔维斯特方程 $AX+XB=C$ 的可解性与解的稳定性，取决于矩阵 $A$ 与 $-B$ 谱的分离程度。当它们的谱非常接近时，问题可能变得高度病态，即微小的扰动可能导致解发生巨大变化。本计算实践让你能够亲手探究这种敏感性，通过对比真实逆算子范数与基于伪谱的估计，你将建立起一种实践直觉，理解为何非正规性会使问题的敏感度远超简单特征值分析所能预测的范围。[@problem_id:3578480]", "problem": "构造一个完整的、可运行的程序，用于研究当矩阵 $A$ 和 $-B$ 的谱（spectra）几乎碰撞时，西尔维斯特方程（Sylvester equation）$AX+XB=C$ 对扰动的敏感性。您的任务必须从数值线性代数中基础且广为接受的定义出发，并遵循第一性原理进行推导。具体来说，请从西尔维斯特映射的线性算子视角和 $\\varepsilon$-伪谱（$\\varepsilon$-pseudospectrum）的定义入手，并且除了这些基础事实外，不假设任何特殊情况下的公式。核心目标是通过伪谱的考量，量化谱分离度 $\\mathrm{sep}(A,-B)$ 如何决定西尔维斯特逆映射的条件数。\n\n您必须完成以下任务，且仅使用以下基本事实：(i) 定义为 $L[X]=AX+XB$ 的西尔维斯特映射 $L:\\mathbb{C}^{n\\times m}\\to\\mathbb{C}^{n\\times m}$ 是线性的；(ii) 向量化算子 $\\operatorname{vec}(\\cdot)$ 是在赋范空间 $\\left(\\mathbb{C}^{n\\times m},\\|\\cdot\\|_F\\right)$ 与 $\\left(\\mathbb{C}^{nm},\\|\\cdot\\|_2\\right)$ 之间的一个线性等距同构；(iii) 一个方阵 $M$ 的 $\\varepsilon$-伪谱为 $\\Lambda_{\\varepsilon}(M)=\\{z\\in\\mathbb{C}:\\sigma_{\\min}(zI-M)\\le \\varepsilon\\}$，其中 $\\sigma_{\\min}(\\cdot)$ 表示最小奇异值。\n\n1) 从给定的基本事实出发，且不预设任何专门公式，推导出谱分离量 $\\mathrm{sep}(A,-B)$ 的一个精确且可实现的计算方法，该方法应为西尔维斯特算子 $L$ 的某个具体、有限维矩阵表示的最小奇异值。然后实现此计算，以数值方式获得 $\\mathrm{sep}(A,-B)$。\n\n2) 仅利用 $L$ 的线性性质和范数定义，设计并实现一个蒙特卡洛（Monte Carlo）过程，以估计由弗罗贝尼乌斯范数（Frobenius norm）诱导的 $L^{-1}$ 的算子范数，即 $\\|L^{-1}\\|=\\sup_{\\|E\\|_F=1}\\|L^{-1}[E]\\|_F$。该过程通过对随机抽取的、满足 $\\|E\\|_F=1$ 的右手边矩阵 $E$ 重复求解 $AX+XB=E$，并取所观测到的最大 $\\|X\\|_F$ 来实现。为确保数值可复现性，需在必要处明确设置伪随机数种子。\n\n3) 从 $\\varepsilon$-伪谱的定义出发，构造并实现一个用于衡量 $A$ 和 $-B$ 之间分离度的伪谱代理指标，方法如下：对于复平面中的一个有界矩形搜索区域和候选点 $z$ 的均匀网格，计算 $s_A(z)=\\sigma_{\\min}(zI-A)$ 和 $s_{-B}(z)=\\sigma_{\\min}(zI+ B)$，然后计算\n$$\n\\mu=\\inf_{z\\ \\text{in the grid}} \\max\\{s_A(z), s_{-B}(z)\\}.\n$$\n使用此 $\\mu$ 作为伪谱分离度的替代指标，并报告其倒数 $1/\\mu$ 作为 $\\|L^{-1}\\|$ 的一个启发式上界预测值。设计方案必须清楚地解释如何选择网格以捕捉 $A$ 和 $-B$ 的谱之间的相关相互作用。\n\n4) 对于下文列出的三个测试案例（每个案例的维度均为 $n=m=3$），分别报告由以下三元实数组构成的结果：\n$$\n\\big(\\ \\mathrm{sep}(A,-B),\\ \\widehat{\\|L^{-1}\\|},\\ 1/\\mu\\ \\big),\n$$\n其中 $\\widehat{\\|L^{-1}\\|}$ 是您的蒙特卡洛估计值，$1/\\mu$ 是伪谱代理值。所有范数都必须是弗罗贝尼乌斯范数，奇异值计算采用标准的欧几里得诱导方法。\n\n测试案例说明：\n\n- 案例 1 (正规矩阵，中度分离)：令 $A=\\operatorname{diag}(1,2,3)$ 和 $B=\\operatorname{diag}(-1-\\delta,-2-\\delta,-3-\\delta)$，其中 $\\delta=10^{-1}$。搜索网格的实部范围为 $\\{\\operatorname{Re}\\lambda:\\lambda\\in\\Lambda(A)\\cup\\Lambda(-B)\\}$ 的最小值到最大值，并对称地向外扩展 $0.5$ 的边距；虚部范围为 $-0.5$ 到 $0.5$。两轴均在一个 $101\\times 101$ 的均匀格点上采样。\n\n- 案例 2 (正规矩阵，几乎碰撞)：令 $A=\\operatorname{diag}(1,2,3)$ 和 $B=\\operatorname{diag}(-1-\\delta,-2-\\delta,-3-\\delta)$，其中 $\\delta=10^{-4}$，并使用与案例 1 相同的网格构造和分辨率。\n\n- 案例 3 (高度非正规的 $A$)：令 $A$ 为一个上三角矩阵，其对角线元素均为 1，超对角线元素等于 $\\alpha=20$，即\n$$\nA=\\begin{bmatrix}\n1  \\alpha  0\\\\\n0  1  \\alpha\\\\\n0  0  1\n\\end{bmatrix},\n$$\n并令 $B=-\\left(1+\\delta\\right)I$，其中 $\\delta=10^{-3}$。使用与案例 1 相同的网格构造和分辨率。\n\n对于每个案例中的蒙特卡洛估计，使用伪随机数种子 $1$，抽取 $M=200$ 个独立的矩阵 $E$，其元素从标准正态分布中采样，并重新缩放以满足 $\\|E\\|_F=1$。求解 $AX+XB=E$ 得到 $X$，并记录观测到的最大 $\\|X\\|_F$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个由逗号分隔的列表，并用方括号括起来。按顺序连接三个案例的三元组，因此输出格式为\n$$\n[\\ \\mathrm{sep}_1,\\ \\widehat{\\|L^{-1}\\|}_1,\\ (1/\\mu)_1,\\ \\mathrm{sep}_2,\\ \\widehat{\\|L^{-1}\\|}_2,\\ (1/\\mu)_2,\\ \\mathrm{sep}_3,\\ \\widehat{\\|L^{-1}\\|}_3,\\ (1/\\mu)_3\\ ].\n$$\n所有量都必须是标准浮点小数形式的实数，不带单位。本问题不涉及物理单位，也不需要角度。程序必须是自包含的，不需要用户输入，并且只能使用指定的数值库。\n\n设计约束和覆盖范围：\n\n- 三个案例共同覆盖了一种普遍的、分离良好的正规情况，一种近乎碰撞的情况，以及一种强非正规情况，以探究伪谱效应。\n\n- 您的推导必须仅依赖于西尔维斯特算子、向量化映射、奇异值和 $\\varepsilon$-伪谱的定义；从这些定义出发，推导出用于计算 $\\mathrm{sep}(A,-B)$ 的有限维奇异值问题，并为估计 $\\|L^{-1}\\|$ 的蒙特卡洛策略提供 justifications。\n\n- 程序必须计算所有要求的值，并以精确指定的格式打印最终结果行。", "solution": "对西尔维斯特方程 $AX+XB=C$（其中 $A \\in \\mathbb{C}^{n\\times n}$，$B \\in \\mathbb{C}^{m\\times m}$，$C, X \\in \\mathbb{C}^{n\\times m}$）的分析始于将其重塑为一个线性算子问题。我们定义西尔维斯特算子 $L: \\mathbb{C}^{n\\times m} \\to \\mathbb{C}^{n\\times m}$，其作用于矩阵 $X$ 的方式为 $L[X] = AX+XB$。因此，原问题等价于求解线性系统 $L[X]=C$。解 $X$ 对 $C$ 中扰动的敏感性由逆算子范数 $\\|L^{-1}\\|$ 控制。一个大的范数表明 $C$ 的微小变化可能导致 $X$ 的巨大变化，这是病态问题的标志。本解答将推导并计算三个表征此条件数的量：谱分离度 $\\mathrm{sep}(A,-B)$、$\\|L^{-1}\\|$ 的蒙特卡洛估计值，以及 $\\|L^{-1}\\|$ 的一个伪谱代理值。\n\n**1. $\\mathrm{sep}(A,-B)$ 的推导与计算**\n\n题目要求从第一性原理推导谱分离度 $\\mathrm{sep}(A,-B)$。两个矩阵 $M_1$ 和 $M_2$ 之间的分离度形式上定义为 $\\mathrm{sep}(M_1, M_2) = \\inf_{\\|X\\|_F=1} \\|M_1 X - X M_2\\|_F$。对于我们的西尔维斯特方程，相关的量是 $\\mathrm{sep}(A,-B) = \\inf_{\\|X\\|_F=1} \\|A X - X(-B)\\|_F = \\inf_{\\|X\\|_F=1} \\|AX+XB\\|_F$。这正是在算子 $L$ 作用下，单位球面的像的范数的下确界，它对应于算子 $L$ 的最小奇异值。\n\n为了计算这个量，我们必须找到 $L$ 的一个有限维矩阵表示。这可以通过向量化算子 $\\operatorname{vec}(\\cdot)$ 实现，该算子将矩阵的列堆叠成一个单独的列向量。根据题目，我们已知 $\\operatorname{vec}$ 是从配备弗罗贝尼乌斯范数的矩阵空间 $(\\mathbb{C}^{n\\times m}, \\|\\cdot\\|_F)$ 到配备欧几里得 2-范数的向量空间 $(\\mathbb{C}^{nm}, \\|\\cdot\\|_2)$ 的一个线性等距同构。这意味着 $\\|X\\|_F = \\|\\operatorname{vec}(X)\\|_2$。\n\n将 $\\operatorname{vec}$ 算子应用于西尔维斯特方程 $AX+XB=C$ 可得：\n$$\n\\operatorname{vec}(AX+XB) = \\operatorname{vec}(C)\n$$\n利用 $\\operatorname{vec}$ 的线性性质和克罗内克积（Kronecker product, $\\otimes$）的一个基本性质，我们可以写出：\n$$\n\\operatorname{vec}(AXB) = (B^T \\otimes A)\\operatorname{vec}(X)\n$$\n将此性质应用于西尔维斯特表达式的每一项：\n$$\n\\operatorname{vec}(AX) = \\operatorname{vec}(AXI_m) = (I_m^T \\otimes A)\\operatorname{vec}(X) = (I_m \\otimes A)\\operatorname{vec}(X)\n$$\n$$\n\\operatorname{vec}(XB) = \\operatorname{vec}(I_nXB) = (B^T \\otimes I_n)\\operatorname{vec}(X)\n$$\n这里，$I_k$ 是 $k \\times k$ 的单位矩阵。对于本问题，$n=m=3$，所以单位矩阵的尺寸是 $3 \\times 3$。\n结合这些，向量化的西尔维斯特方程变成了一个标准的矩阵-向量方程：\n$$\n\\big( (I_m \\otimes A) + (B^T \\otimes I_n) \\big) \\operatorname{vec}(X) = \\operatorname{vec}(C)\n$$\n设西尔维斯特算子的矩阵表示为 $K = (I_m \\otimes A) + (B^T \\otimes I_n)$。这里，$K$ 是一个在 $\\mathbb{C}^{nm \\times nm}$ 中的矩阵。方程现在是 $K\\mathbf{x} = \\mathbf{c}$，其中 $\\mathbf{x}=\\operatorname{vec}(X)$ 且 $\\mathbf{c}=\\operatorname{vec}(C)$。\n\n谱分离量 $\\mathrm{sep}(A,-B)$ 现在可以用这个矩阵表示来表达：\n$$\n\\mathrm{sep}(A,-B) = \\inf_{\\|X\\|_F=1} \\|L[X]\\|_F = \\inf_{\\|\\operatorname{vec}(X)\\|_2=1} \\|K \\operatorname{vec}(X)\\|_2\n$$\n等式右边恰好是矩阵 $K$ 的最小奇异值的定义，记为 $\\sigma_{\\min}(K)$。因此，我们推导出了精确的计算公式：\n$$\n\\mathrm{sep}(A,-B) = \\sigma_{\\min}(I_m \\otimes A + B^T \\otimes I_n)\n$$\n对于每个测试案例，我们将构造 $9 \\times 9$ 矩阵 $K$ 并计算其最小奇异值。理论上，这个值也等于 $1/\\|L^{-1}\\|$。\n\n**2. $\\|L^{-1}\\|$ 的蒙特卡洛估计**\n\n由弗罗贝尼乌斯范数诱导的逆西尔维斯特算子的范数定义为：\n$$\n\\|L^{-1}\\| = \\sup_{C \\neq 0} \\frac{\\|L^{-1}[C]\\|_F}{\\|C\\|_F} = \\sup_{\\|C\\|_F=1} \\|L^{-1}[C]\\|_F\n$$\n令 $X = L^{-1}[C]$，这等价于寻找 $\\sup_{\\|L[X]\\|_F=1} \\|X\\|_F$。蒙特卡洛过程通过采样为这个量提供了一个数值估计值 $\\widehat{\\|L^{-1}\\|}$。该方法包括：生成一组随机矩阵 $E$ 作为方程的右手边，将它们归一化以使弗罗贝尼乌斯范数为 1，对每个 $E$ 求解西尔维斯特方程 $AX+XB=E$，并找出所得解的最大范数 $\\|X\\|_F$。\n\n该过程如下：\n1. 用一个固定的种子（$1$）初始化一个伪随机数生成器，以保证可复现性。\n2. 初始化一个变量 `max_norm` 为 $0$。\n3. 对于 $M=200$ 次迭代：\n    a. 生成一个 $n \\times m$ 的矩阵 $E_{raw}$，其元素是来自标准正态分布 $\\mathcal{N}(0,1)$ 的独立样本。\n    b. 归一化此矩阵：$E = E_{raw} / \\|E_{raw}\\|_F$。现在，$\\|E\\|_F=1$。\n    c. 对矩阵 $X$ 求解西尔维斯特方程 $AX+XB=E$。这可以使用专门的求解器如 `scipy.linalg.solve_sylvester` 高效完成。\n    d. 计算解的弗罗贝尼乌斯范数 $\\|X\\|_F$。\n    e. 更新 `max_norm = max(max_norm, \\|X\\|_F)`。\n4. 最终值 `max_norm` 即为估计值 $\\widehat{\\|L^{-1}\\|}$。随着样本数量 $M$ 的增加，这个估计值会逼近真实范数，因为随机的右手边 $E$ 与 $L^{-1}$ 的最大放大方向对齐的可能性会越来越大。\n\n**3. 敏感性的伪谱代理指标**\n\n矩阵 $M$ 的伪谱提供了关于其对扰动敏感性的信息。$\\varepsilon$-伪谱 $\\Lambda_{\\varepsilon}(M)$ 是复数 $z$ 的集合，这些 $z$ 是某个扰动矩阵 $M+E$（其中 $\\|E\\| \\le \\varepsilon$）的特征值。一个等价的定义，如问题中所给，是 $\\Lambda_{\\varepsilon}(M) = \\{ z \\in \\mathbb{C} : \\sigma_{\\min}(zI-M) \\le \\varepsilon \\}$。一个小的 $\\sigma_{\\min}(zI-M)$ 值表明 $z$ “接近”于成为 $M$ 的一个特征值。\n\n当 $A$ 和 $-B$ 的谱接近时，西尔维斯特方程的敏感性很高。伪谱将这一概念推广：当 $A$ 和 $-B$ 的伪谱接近或重叠时，敏感性很高。我们可以通过寻找函数 $z \\mapsto \\sigma_{\\min}(zI-A)$ 和 $z \\mapsto \\sigma_{\\min}(zI+B)$ 的等值线相交的最小“高度”$\\varepsilon$ 来量化这种接近程度。\n\n代理指标 $\\mu$ 定义为在一个搜索网格上这两个函数的最大值的最小值：\n$$\n\\mu = \\inf_{z\\ \\text{in grid}} \\max \\{ \\sigma_{\\min}(zI-A), \\sigma_{\\min}(zI+B) \\}\n$$\n一个小的 $\\mu$ 值意味着在复平面中存在一个点 $z$，使得 $\\sigma_{\\min}(zI-A)$ 和 $\\sigma_{\\min}(zI+B)$ 都很小。这个点 $z$ 同时位于 $\\Lambda_{\\mu}(A)$ 和 $\\Lambda_{\\mu}(-B)$ 中，表明 $A$ 和 $-B$ 的 $\\mu$-伪谱发生了重叠。这种重叠是问题病态的一个强烈指标。因此，其倒数 $1/\\mu$ 预计将成为 $\\|L^{-1}\\|$ 的一个启发式预测值，通常是一个上界。\n\n网格的构建旨在覆盖 $A$ 和 $-B$ 的谱发生相互作用的区域。对于每个案例，我们计算 $A$ 和 $-B$ 的特征值，找到实部的极值，并围绕它们定义一个矩形网格，外扩 $0.5$。虚轴范围设为 $[-0.5, 0.5]$。对于给定的测试案例，这是一个合理的选择，因为所有特征值都是实数或接近实轴。然后，我们遍历这个 $101 \\times 101$ 的复数 $z$ 网格，在每个点计算 $\\sigma_{\\min}(zI-A)$ 和 $\\sigma_{\\min}(zI+B)$，并找出它们最大值的最小值，从而得到 $\\mu$。\n\n**4. 数值实现与结果**\n\n针对三个测试案例，我们实现了这三种方法。\n- **案例 1：** $A$ 和 $B$ 是正规（对角）矩阵。$A$ 和 $-B$ 的谱分别为 $\\Lambda(A)=\\{1,2,3\\}$ 和 $\\Lambda(-B)=\\{1.1, 2.1, 3.1\\}$。最小谱距离为 $\\delta=0.1$。由于矩阵是正规的，$\\|L^{-1}\\| = 1/\\mathrm{sep}(A,-B)$，我们预计计算出的三个量会很接近。\n- **案例 2：** A 和 B 是正规矩阵，但谱几乎碰撞，最小距离为 $\\delta=10^{-4}$。我们预计所有三个量都会很大，大约在 $1/\\delta = 10000$ 的量级。\n- **案例 3：** $A$ 是一个高度非正规的上三角矩阵，而 $B$ 是单位矩阵的标量倍。$A$ 的特征值均为 $1$，而 $-B$ 的特征值均为 $1+\\delta = 1.001$。谱分离度很小，为 $\\delta=10^{-3}$。然而，由于 $A$ 的高度非正规性，其伪谱比谱距离 $\\delta$ 所暗示的要大得多。因此，我们预期 $\\widehat{\\|L^{-1}\\|}$ 和 $1/\\mu$ 将显著大于 $1/\\mathrm{sep}(A,-B)$，这展示了简单的谱分离度在预测非正规矩阵问题条件数时的失效。\n\n以下程序实现了这些计算，并按要求格式报告了九个指定的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_sylvester\n\ndef solve():\n    \"\"\"\n    Performs the required derivations and computations for the Sylvester equation\n    sensitivity analysis across three test cases.\n    \"\"\"\n    \n    # Test suite specifications\n    n = 3\n    m = 3\n    alpha = 20.0\n    \n    test_cases = [\n        {\n            \"name\": \"Case 1: Normal, moderately separated\",\n            \"A\": np.diag([1.0, 2.0, 3.0]),\n            \"B\": np.diag([-1.0 - 1e-1, -2.0 - 1e-1, -3.0 - 1e-1]),\n        },\n        {\n            \"name\": \"Case 2: Normal, nearly colliding\",\n            \"A\": np.diag([1.0, 2.0, 3.0]),\n            \"B\": np.diag([-1.0 - 1e-4, -2.0 - 1e-4, -3.0 - 1e-4]),\n        },\n        {\n            \"name\": \"Case 3: Highly nonnormal A\",\n            \"A\": np.array([[1.0, alpha, 0.0], [0.0, 1.0, alpha], [0.0, 0.0, 1.0]]),\n            \"B\": -(1.0 + 1e-3) * np.eye(m),\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        A = case[\"A\"]\n        B = case[\"B\"]\n\n        # 1. Compute sep(A, -B)\n        # K = I_m kron A + B^T kron I_n\n        K = np.kron(np.eye(m), A) + np.kron(B.T, np.eye(n))\n        # sep(A, -B) = sigma_min(K)\n        # Use svdvals to avoid computing U and Vh, which is more efficient.\n        singular_values_K = np.linalg.svd(K, compute_uv=False)\n        sep_A_minus_B = np.min(singular_values_K)\n        results.append(sep_A_minus_B)\n\n        # 2. Monte Carlo estimation of ||L^-1||\n        M = 200\n        rng = np.random.default_rng(seed=1)\n        max_norm_X = 0.0\n        for _ in range(M):\n            E_raw = rng.standard_normal(size=(n, m))\n            E = E_raw / np.linalg.norm(E_raw, 'fro')\n            \n            # Solve AX + XB = E\n            X = solve_sylvester(A, B, E)\n            \n            norm_X = np.linalg.norm(X, 'fro')\n            if norm_X > max_norm_X:\n                max_norm_X = norm_X\n        \n        estimated_norm_L_inv = max_norm_X\n        results.append(estimated_norm_L_inv)\n\n        # 3. Compute pseudospectral proxy 1/mu\n        # Define the grid\n        eigs_A = np.linalg.eigvals(A)\n        eigs_minus_B = np.linalg.eigvals(-B)\n        all_eigs = np.concatenate((eigs_A, eigs_minus_B))\n        \n        re_min = np.min(np.real(all_eigs))\n        re_max = np.max(np.real(all_eigs))\n        \n        grid_re = np.linspace(re_min - 0.5, re_max + 0.5, 101)\n        grid_im = np.linspace(-0.5, 0.5, 101)\n        \n        mu = np.inf\n        I_n = np.eye(n)\n\n        for re_z in grid_re:\n            for im_z in grid_im:\n                z = re_z + 1j * im_z\n                \n                # s_A(z) = sigma_min(zI - A)\n                s_A_z = np.min(np.linalg.svd(z * I_n - A, compute_uv=False))\n                \n                # s_-B(z) = sigma_min(zI + B)\n                s_minusB_z = np.min(np.linalg.svd(z * I_n + B, compute_uv=False))\n                \n                max_s = max(s_A_z, s_minusB_z)\n                \n                if max_s  mu:\n                    mu = max_s\n        \n        proxy_1_over_mu = 1.0 / mu\n        results.append(proxy_1_over_mu)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3578480"}]}