{"hands_on_practices": [{"introduction": "灾难性抵消是数值计算中的一个基本挑战，即使在求和这样简单的操作中也会出现。本练习将通过一个专门设计的、具有严重抵消效应的交替符号序列，让您亲手比较几种求和算法的稳定性和准确性。通过实现和对比朴素求和、成对求和以及Kahan补偿求和算法，您将直观地理解不同计算策略如何影响误差的累积和增长，从而为设计稳健的数值程序奠定基础。[@problem_id:3536136]", "problem": "设 $u$ 表示电气与电子工程师协会（IEEE）$754$ 算术标准中标准双精度二进制格式的单位舍入误差，具体为 $u = 2^{-53}$。考虑加法的浮点模型：对于实数 $x$ 和 $y$，计算出的浮点和为 $\\operatorname{fl}(x + y) = (x + y)(1 + \\delta)$，其中 $|\\delta| \\le u$，假设采用“舍入到最近，偶数优先”（rounding to nearest with ties to even）的规则，并且没有上溢、下溢或次正规数等复杂情况。当两个符号相反、大小相近的数相加时，会出现灾难性抵消现象，导致有效最高位的丢失以及结果中舍入误差的放大。在数值线性代数中，求和策略会影响抵消如何作用于累积误差。\n\n设计一个表现出严重抵消的测试序列，以便在单位舍入误差 $u$ 固定的情况下，随着序列长度 $n$ 的增长，对三种求和策略进行经验性比较：\n- 朴素顺序求和：通过从 $i=1$到 $n$ 迭代累加 $s \\leftarrow \\operatorname{fl}(s + x_i)$ 来计算 $S_{\\text{naive}}(x_1,\\dots,x_n)$，其中 $s$ 初始化为 $0$。\n- 成对（二叉树）求和：通过递归地将索引集分成两半，对每一半求和，然后将两个部分和相加来计算 $S_{\\text{pairwise}}(x_1,\\dots,x_n)$。\n- Kahan 补偿求和：使用一个补偿变量 $c$ 来携带低位部分，通过迭代 $y \\leftarrow \\operatorname{fl}(x_i - c)$，$t \\leftarrow \\operatorname{fl}(s + y)$，$c \\leftarrow \\operatorname{fl}(\\operatorname{fl}(t - s) - y)$，$s \\leftarrow t$ 来计算 $S_{\\text{Kahan}}(x_1,\\dots,x_n)$，其中 $s$ 和 $c$ 初始化为 $0$。\n\n对于一个固定的标量 $s = 1$，为每个 $n \\in \\mathbb{N}$ 定义一个长度为 $n$ 的向量 $x \\in \\mathbb{R}^n$：\n$$\nx_i = (-1)^{i-1} + \\frac{s}{n}, \\quad i = 1,2,\\dots,n.\n$$\n该序列具有交替符号，这会强制 $\\pm 1$ 分量之间发生抵消，同时增加一个均匀的偏置 $\\frac{s}{n}$，使得精确和为\n$$\nS_{\\text{exact}}(n) = \\sum_{i=1}^{n} x_i = \n\\begin{cases}\ns,  \\text{若 } n \\text{ 为偶数}, \\\\\n1 + s,  \\text{若 } n \\text{ 为奇数}.\n\\end{cases}\n$$\n给定三种求和策略的浮点计算结果，将每种策略在给定 $n$ 下的绝对误差定义为\n$$\nE_{\\text{naive}}(n) = \\left| S_{\\text{naive}}(x_1,\\dots,x_n) - S_{\\text{exact}}(n) \\right|,\n$$\n$$\nE_{\\text{pairwise}}(n) = \\left| S_{\\text{pairwise}}(x_1,\\dots,x_n) - S_{\\text{exact}}(n) \\right|,\n$$\n$$\nE_{\\text{Kahan}}(n) = \\left| S_{\\text{Kahan}}(x_1,\\dots,x_n) - S_{\\text{exact}}(n) \\right|.\n$$\n\n实现一个完整的程序，该程序：\n- 通过依赖宿主语言的双精度算术，隐式地使用指定的浮点模型。\n- 为提供的测试套件中的每个 $n$ 构建上述序列 $x$。\n- 为每个 $n$ 计算 $E_{\\text{naive}}(n)$、$E_{\\text{pairwise}}(n)$ 和 $E_{\\text{Kahan}}(n)$。\n\n测试套件和覆盖范围：\n- 使用测试套件 $n \\in \\{1, 2, 8, 64, 1024, 16384, 65536\\}$ 以覆盖：\n  - 一个边界最小情况 $n = 1$，其中没有抵消。\n  - 较小的偶数 $n$ 值 $n = 2, 8$，用以说明初始的抵消效应。\n  - 中等 $n$ 值 $n = 64$，显示增加的抵消深度。\n  - 较大的 $n$ 值 $n = 1024, 16384, 65536$，用以评估误差增长随 $n$ 的尺度变化。\n- 对每个 $n$，计算并记录三个绝对误差，作为浮点数。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的列表，用方括号括起来，并按如下顺序排列：\n$$\n[\\;E_{\\text{naive}}(1),E_{\\text{pairwise}}(1),E_{\\text{Kahan}}(1),E_{\\text{naive}}(2),E_{\\text{pairwise}}(2),E_{\\text{Kahan}}(2),\\dots,E_{\\text{naive}}(65536),E_{\\text{pairwise}}(65536),E_{\\text{Kahan}}(65536)\\;].\n$$\n不应打印任何额外文本。所有数值必须是纯浮点单位，不附带任何物理单位。", "solution": "对问题陈述进行分析后，认定其是有效的。它描述了一个在数值线性代数领域中定义明确、有科学依据的计算实验，旨在展示灾难性抵消的影响，并比较三种基本求和算法的稳定性。提供了所有必要的数据、定义和约束，没有矛盾或模糊之处。\n\n### 理论框架\n\n这个问题的核心是观察灾难性抵消，这是一种浮点运算现象，其中两个几乎相等的数相减会导致相对精度的急剧损失。计算出的结果主要由先前计算的舍入误差主导，而不是真实的数学差值。\n\n对于一个求和问题，这个问题的严重性可以通过其条件数来量化。对于一个和 $S = \\sum_{i=1}^{n} x_i$，条件数由 $\\kappa = \\frac{\\sum_{i=1}^{n} |x_i|}{|S|}$ 给出。大的条件数表明输入值 $x_i$ 中的小相对误差可能会被放大为最终和 $S$ 中的大相对误差。\n\n对于提供的测试序列 $x_i = (-1)^{i-1} + \\frac{s}{n}$（其中 $s=1$），单个项 $|x_i|$ 都接近于 $1$。因此，$\\sum_{i=1}^{n} |x_i| \\approx n$。精确和 $S_{\\text{exact}}(n)$ 要么是 $s=1$（当 $n$ 为偶数时），要么是 $1+s=2$（当 $n$ 为奇数时）。因此条件数 $\\kappa \\approx n$，对于大的 $n$ 来说这个值很大。这表明该求和问题是病态的，并且极易受舍入误差影响。目标是观察不同算法如何应对这种固有的不稳定性。\n\n### 算法分析与实现策略\n\n我们将实现并比较三种算法，每种算法都有不同的误差传播特性。实现将依赖于标准的双精度浮点算术（$u = 2^{-53}$），这由 Python 运行时环境隐式提供。\n\n1.  **朴素顺序求和 ($S_{\\text{naive}}$)**\n    *   **原理：** 这是最基本的方法，由简单的迭代累加 $s_{new} \\leftarrow \\operatorname{fl}(s_{old} + x_i)$ 定义。和按固定顺序计算，通常从 $i=1$ 到 $n$。\n    *   **误差分析：** 对于像这样的病态和，朴素求和的表现很差。运行中的和 $s_k = \\sum_{i=1}^{k} x_i$ 在接近 $1$（当 $k$ 为奇数时）和接近 $0$（当 $k$ 为偶数时）的值之间交替。当一个中间和 $s_{k-1} \\approx 1$ 与下一项 $x_k \\approx -1$ 相加时，就会发生灾难性抵消。每一步的舍入误差都会带入下一步，总的绝对误差在理论上受 $n \\cdot u \\cdot \\max_k |s_k|$ 的限制，并且经验上观察到与其成正比增长。对于这个问题，误差的尺度为 $O(n \\cdot u)$。\n    *   **实现：** 一个标准的 `for` 循环，遍历输入序列的元素，并在一个初始化为 $0.0$ 的浮点变量中累加和。\n\n2.  **成对求和 ($S_{\\text{pairwise}}$)**\n    *   **原理：** 这是一种递归的、分治的算法。序列被分成两半，每一半被递归地求和，然后将两个得到的部分和最终相加：$S(x_1, \\dots, x_n) = \\operatorname{fl}(S(x_1, \\dots, x_{\\lfloor n/2 \\rfloor}) + S(x_{\\lfloor n/2 \\rfloor+1}, \\dots, x_n))$。\n    *   **误差分析：** 成对求和通过将加法构造成二叉树来减轻误差累积。这将任何单个项 $x_i$ 可能累积的最大舍入误差数量从约 $n$ 减少到 $\\log_2 n$。最终的误差界尺度为 $O(u \\cdot \\log n)$。这种对数增长相对于朴素方法的线性增长是一个实质性的改进。\n    *   **实现：** 递归函数是实现此算法的自然方式。为了避免在递归的每一层创建数组切片所带来的性能开销，实现将传递起始和结束索引，以便在单个共享数组上操作。递归的基准情况处理长度为 $1$ 或 $0$ 的序列。\n\n3.  **Kahan 补偿求和 ($S_{\\text{Kahan}}$)**\n    *   **原理：** 这种复杂的算法显式地跟踪并校正每次加法中的舍入误差。它使用一个补偿变量 $c$ 来存储因舍入而丢失的结果的低位部分。迭代的核心是 $y \\leftarrow \\operatorname{fl}(x_i - c)$，$t \\leftarrow \\operatorname{fl}(s + y)$，$c \\leftarrow \\operatorname{fl}(\\operatorname{fl}(t - s) - y)$，以及 $s \\leftarrow t$。项 $\\operatorname{fl}(t-s) - y$ 是一种巧妙的方法，可以从加法 $s+y$ 中恢复舍入误差的负值。这个误差随后从下一项 $x_{i+1}$ 中减去（通过 $y \\leftarrow x_{i+1} - c$ 步骤），从而有效地将丢失的精度重新注入到求和中。\n    *   **误差分析：** Kahan 算法的精妙之处在于，累积误差受单位舍入误差的一个小的常数倍所限制，且与项数 $n$ 无关。误差界为 $O(u)$。这使得它即使对于非常长且病态的和也异常精确。\n    *   **实现：** 一个 `for` 循环，将和 $s$ 与补偿器 $c$ 都初始化为 $0.0$。在循环内部，对序列中的每个元素执行四步 Kahan 更新。\n\n### 计算实验\n程序将为测试套件 $\\{1, 2, 8, 64, 1024, 16384, 65536\\}$ 中的每个 $n$ 执行以下步骤：\n-   **生成序列：** 构建长度为 $n$ 的向量 $x$，其中 $x_i = (-1)^{i-1} + \\frac{s}{n}$，对于 $i=1,\\dots,n$ 且 $s=1$。这通过使用 `numpy` 来实现高效的向量操作。\n-   **计算精确和：** 计算 $S_{\\text{exact}}(n)$，当 $n$ 为偶数时为 $s$，当 $n$ 为奇数时为 $1+s$。\n-   **计算数值和：** 将三个已实现的求和函数（$S_{\\text{naive}}$、$S_{\\text{pairwise}}$、$S_{\\text{Kahan}}$）应用于向量 $x$。\n-   **计算误差：** 计算三种方法的绝对误差 $E(n) = |S_{\\text{computed}}(n) - S_{\\text{exact}}(n)|$。\n-   **汇总结果：** 计算出的误差被收集到一个列表中，按指定顺序排列，并以要求的格式打印。对于大的 $n$，预计结果将显示 $E_{\\text{Kahan}}(n) \\ll E_{\\text{pairwise}}(n) \\ll E_{\\text{naive}}(n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef naive_sum(x: np.ndarray) - float:\n    \"\"\"\n    Computes the sum of a sequence using naive iterative accumulation.\n    s - fl(s + x_i)\n    \"\"\"\n    s = 0.0\n    for val in x:\n        s += val\n    return s\n\ndef _pairwise_sum_recursive(arr: np.ndarray, start: int, end: int) - float:\n    \"\"\"\n    Recursive helper for pairwise summation using indices to avoid slicing.\n    \"\"\"\n    n = end - start\n    if n == 0:\n        return 0.0\n    if n == 1:\n        # Return a Python float to ensure standard float arithmetic.\n        return float(arr[start])\n    \n    mid = start + n // 2\n    # Recursively sum each half and then add the results.\n    sum1 = _pairwise_sum_recursive(arr, start, mid)\n    sum2 = _pairwise_sum_recursive(arr, mid, end)\n    return sum1 + sum2\n\ndef pairwise_sum(x: np.ndarray) - float:\n    \"\"\"\n    Computes the sum of a sequence using a recursive pairwise (binary tree) strategy.\n    \"\"\"\n    return _pairwise_sum_recursive(x, 0, len(x))\n\ndef kahan_sum(x: np.ndarray) - float:\n    \"\"\"\n    Computes the sum of a sequence using Kahan's compensated summation algorithm.\n    \"\"\"\n    s = 0.0  # The running sum\n    c = 0.0  # The compensation for lost low-order bits\n    for val in x:\n        # y incorporates the previous compensation.\n        y = float(val) - c\n        # s is updated. t is the new sum, but a low-order part of y might be lost.\n        t = s + y\n        # (t - s) is the high-order part of y that was successfully added to s.\n        # (t - s) - y retrieves the negative of the low-order part (the error).\n        c = (t - s) - y\n        s = t\n    return s\n\ndef solve():\n    \"\"\"\n    Main function to run the summation experiment and print results.\n    \"\"\"\n    \n    # Test suite covering various scales of n as specified in the problem.\n    test_cases = [1, 2, 8, 64, 1024, 16384, 65536]\n    \n    # The fixed scalar s for the sequence definition.\n    s_scalar = 1.0\n    \n    results = []\n    \n    for n in test_cases:\n        # Step 1: Construct the sequence x for the current n.\n        # x_i = (-1)^(i-1) + s/n, for i=1,...,n\n        # Using 0-based indexing j=i-1: x_j = (-1)^j + s/n\n        indices = np.arange(n, dtype=np.float64)\n        signs = (-1.0)**indices\n        bias = s_scalar / n\n        x = (signs + bias).astype(np.float64)\n\n        # Step 2: Calculate the exact sum S_exact(n).\n        # S_exact is s if n is even, and 1+s if n is odd.\n        if n % 2 == 0:\n            s_exact = s_scalar\n        else:\n            s_exact = 1.0 + s_scalar\n\n        # Step 3: Compute sums using the three different strategies.\n        s_naive = naive_sum(x)\n        s_pairwise = pairwise_sum(x)\n        s_kahan = kahan_sum(x)\n        \n        # Step 4: Calculate absolute errors.\n        e_naive = abs(s_naive - s_exact)\n        e_pairwise = abs(s_pairwise - s_exact)\n        e_kahan = abs(s_kahan - s_exact)\n        \n        # Step 5: Append errors to the results list.\n        results.extend([e_naive, e_pairwise, e_kahan])\n\n    # Final Step: Format the final output as a single comma-separated string in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3536136"}, {"introduction": "在求解线性系统的迭代方法中，残差范数通常被用作衡量收敛性的关键指标。然而，当近似解非常接近真实解时，残差的计算本身可能会遭遇灾难性抵消，从而产生误导性的结果。本练习构建了一个巧妙的场景，其中计算出的残差范数因数值抵消而停滞甚至变为零，而真实误差仍在减小，揭示了“假收敛”的现象。通过这个实践，您将学会审慎地评估数值度量，并理解浮点运算的局限性如何影响算法的可靠性。[@problem_id:3536159]", "problem": "考虑一个线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个对角矩阵，其对角线上有一个非常大的尺度 $S = 2^{p}$，$x^{\\star} \\in \\mathbb{R}^{n}$ 是精确解，且 $b = A x^{\\star}$。设迭代近似解为 $x_{k} = x^{\\star} - \\delta_{k} \\mathbf{1}$，其中 $\\mathbf{1} \\in \\mathbb{R}^{n}$ 是全一向量，且 $\\delta_{k} = 2^{-k}$。\n\n使用以下基本原理：\n- 残差向量 $r_{k} = b - A x_{k}$ 和真实误差 $e_{k} = x_{k} - x^{\\star}$ 的定义。\n- “向偶数舍入”（Round To Nearest Even）算法的浮点模型：如果 $\\operatorname{fl}(\\cdot)$ 表示一个浮点运算，$\\epsilon_{\\text{mach}}$ 是机器精度，那么我们使用一个经过充分检验的事实，即 $\\operatorname{fl}(u \\circ v) = (u \\circ v)(1 + \\delta)$，其中 $\\circ \\in \\{+, -, \\times\\}$ 且 $|\\delta| \\le \\epsilon_{\\text{mach}}$，这适用于不涉及严重相消的运算。在减法中，当 $u \\approx v$ 时，$u - v$ 的相对误差可能任意大，因为 $|u - v|$ 很小，从而以可预测的方式降低精度。\n\n构建并分析一个由于相消导致残差范数停滞而真实误差仍在减小的例子。严格基于这些原理来量化这种差异机制，不引入任何快捷公式。具体而言：\n- 固定 $n = 4, p = 54$，因此 $S = 2^{54}$，并取 $x^{\\star} = \\mathbf{1}$ 和 $b = S \\mathbf{1}$。\n- 考虑三个值 $k \\in \\{40, 54, 60\\}$，定义 $\\delta_{k} = 2^{-k}$ 和 $x_{k} = \\mathbf{1} - \\delta_{k} \\mathbf{1}$。\n\n你的程序必须：\n1. 使用 Python 标准库的 decimal 模块，以至少 $100$ 位精度的多精度算术计算真实误差的欧几里得范数 $\\|e_{k}\\|_{2} = \\|x_{k} - x^{\\star}\\|_{2}$。\n2. 用两种方式计算残差范数：\n   - 使用双精度（IEEE 754 binary64）计算的朴素残差：$\\|r_{k}^{(\\text{float64})}\\|_{2} = \\|b - A x_{k}\\|_{2}$，完全使用 NumPy 数组和运算在 `float64` 中执行。\n   - 使用 decimal 模块计算的高精度残差：$\\|r_{k}^{(\\text{dec})}\\|_{2} = \\|b - A x_{k}\\|_{2}$，以至少 $100$ 位精度计算。\n3. 对每个 $k$，以浮点数形式报告三元组 $[\\|e_{k}\\|_{2}, \\|r_{k}^{(\\text{float64})}\\|_{2}, \\|r_{k}^{(\\text{dec})}\\|_{2}]$。\n4. 通过评估布尔条件来检测连续 $k$ 值之间的停滞现象：朴素残差范数未能严格减小，而真实误差范数却严格减小。形式上，对于 $k_{i}$ 和 $k_{i+1}$ 之间，报告\n   $$\\text{flag}_{i} = \\left( \\|e_{k_{i+1}}\\|_{2}  \\|e_{k_{i}}\\|_{2} \\right) \\land \\left( \\|r_{k_{i+1}}^{(\\text{float64})}\\|_{2} \\ge \\|r_{k_{i}}^{(\\text{float64})}\\|_{2} \\right).$$\n   为每对相邻的 $k$ 值生成一个布尔值。\n\n测试套件：\n- 案例 1：$n=4$, $p=54$, $k=40$。\n- 案例 2：$n=4$, $p=54$, $k=54$。\n- 案例 3：$n=4$, $p=54$, $k=60$。\n\n覆盖设计：\n- 案例 1 是一个“理想情况”，此时残差范数和真实误差范数都很大，应能被准确表示。\n- 案例 2 接近相消变得严重的边界：在 `float64` 中，$1 - 2^{-54}$ 会舍入为 $1$，因此朴素残差会突然下降并表现出误导性行为。\n- 案例 3 是一个边界情况，此时真实误差进一步减小，但朴素残差已经达到其数值下限并停滞，可能停在零。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。\n- 该行必须具有以下格式：\n  $$[\\,[\\|e_{k_{1}}\\|_{2}, \\|r_{k_{1}}^{(\\text{float64})}\\|_{2}, \\|r_{k_{1}}^{(\\text{dec})}\\|_{2}],\\, [\\|e_{k_{2}}\\|_{2}, \\|r_{k_{2}}^{(\\text{float64})}\\|_{2}, \\|r_{k_{2}}^{(\\text{dec})}\\|_{2}],\\, [\\|e_{k_{3}}\\|_{2}, \\|r_{k_{3}}^{(\\text{float64})}\\|_{2}, \\|r_{k_{3}}^{(\\text{dec})}\\|_{2}],\\, [\\text{flag}_{1}, \\text{flag}_{2}]\\,].$$\n所有条目都必须是原始类型（范数为浮点数，标志为布尔值）。不允许有任何额外文本。", "solution": "问题陈述是数值分析中一个有效的练习，旨在演示灾难性相消现象及其对线性系统计算残差的影响。所有参数都定义明确，任务在计算上是可行的，在科学上是合理的。\n\n### 1. 问题的理论分析\n\n给定一个线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个对角矩阵，且 $n=4$。矩阵 $A$ 定义为 $A = S \\cdot I$，其中 $I$ 是单位矩阵，尺度因子 $S = 2^p$，且 $p=54$。因此，$A = 2^{54}I$。\n\n精确解给定为 $x^{\\star} = \\mathbf{1}$，其中 $\\mathbf{1} \\in \\mathbb{R}^{n}$ 是全一向量。右端向量 $b$ 随之计算为 $b = A x^{\\star} = (S \\cdot I) \\mathbf{1} = S \\mathbf{1}$。$b$ 的每个分量都是 $S = 2^{54}$。\n\n迭代近似解由 $x_{k} = x^{\\star} - \\delta_{k} \\mathbf{1}$ 给出，其中 $\\delta_{k} = 2^{-k}$。代入 $x^{\\star} = \\mathbf{1}$，我们得到 $x_{k} = (1 - \\delta_{k})\\mathbf{1} = (1 - 2^{-k})\\mathbf{1}$。\n\n我们分析给定值 $k \\in \\{40, 54, 60\\}$ 下的真实误差 $e_k$ 和真实残差 $r_k$。\n\n**真实误差范数，$\\|e_{k}\\|_{2}$**\n\n真实误差向量定义为 $e_{k} = x_{k} - x^{\\star}$。\n$$e_{k} = (1 - \\delta_{k})\\mathbf{1} - \\mathbf{1} = -\\delta_{k}\\mathbf{1} = -2^{-k}\\mathbf{1}$$\n真实误差的欧几里得范数（$\\ell_2$-范数）为：\n$$\\|e_{k}\\|_{2} = \\|-2^{-k}\\mathbf{1}\\|_{2} = \\sqrt{\\sum_{i=1}^{n} (-2^{-k})^2} = \\sqrt{n \\cdot (2^{-k})^2} = \\sqrt{n} \\cdot 2^{-k}$$\n当 $n=4$ 时，我们有：\n$$\\|e_{k}\\|_{2} = \\sqrt{4} \\cdot 2^{-k} = 2 \\cdot 2^{-k} = 2^{1-k}$$\n\n**真实残差范数，$\\|r_{k}\\|_{2}$**\n\n真实残差向量定义为 $r_{k} = b - A x_{k}$。\n$$r_{k} = S\\mathbf{1} - (S \\cdot I) ((1 - \\delta_{k})\\mathbf{1}) = S\\mathbf{1} - S(1 - \\delta_{k})\\mathbf{1} = (S - S(1 - \\delta_{k}))\\mathbf{1} = S\\delta_{k}\\mathbf{1}$$\n$$r_{k} = S \\cdot 2^{-k} \\mathbf{1} = 2^{54} \\cdot 2^{-k} \\mathbf{1} = 2^{54-k}\\mathbf{1}$$\n真实残差的欧几里得范数为：\n$$\\|r_{k}\\|_{2} = \\|2^{54-k}\\mathbf{1}\\|_{2} = \\sqrt{\\sum_{i=1}^{n} (2^{54-k})^2} = \\sqrt{n \\cdot (2^{54-k})^2} = \\sqrt{n} \\cdot 2^{54-k}$$\n当 $n=4$ 时，我们有：\n$$\\|r_{k}\\|_{2} = \\sqrt{4} \\cdot 2^{54-k} = 2 \\cdot 2^{54-k} = 2^{55-k}$$\n\n这些精确值将使用高精度算术计算，并作为我们的参考值 $\\|e_{k}\\|_{2}$ 和 $\\|r_{k}^{(\\text{dec})}\\|_{2}$。\n\n### 2. 浮点算术分析\n\n问题的核心在于朴素残差 $\\|r_{k}^{(\\text{float64})}\\|_2$ 的浮点计算。该计算涉及两个几乎相等的大数相减，容易发生灾难性相消。关键步骤是在 IEEE 754 双精度（`float64`）算术中计算 $x_k$ 的分量。一个 `float64` 数的有效数字精度为 53 位（1 个隐含位 + 52 个显式位），对应于机器精度 $\\epsilon_{\\text{mach}} = 2^{-52}$。\n\n$x_k$ 的分量是 $v_k = 1 - 2^{-k}$。它们的浮点表示是 $\\operatorname{fl}(v_k) = \\operatorname{fl}(1 - 2^{-k})$。\n数字 $1$ 可以被精确表示。比 $1$ 小的下一个可表示数是 $1 - 2^{-52}$。这两个数之间的中点是 $1 - 2^{-53}$。根据“向最近舍入，偶数优先”（round to nearest, ties to even）规则：\n- 区间 $(1 - 2^{-53}, 1)$ 内的任何值都舍入为 $1$。\n- 区间 $(1 - 2^{-52}, 1 - 2^{-53})$ 内的任何值都舍入为 $1 - 2^{-52}$。\n- 中点 $1 - 2^{-53}$ 会舍入到其有效数字最后一位为零的值，即 $1$。\n\n让我们针对具体的 $k$ 值进行分析：\n- **对于 $k=40$：**由于 $40  53$，值 $1 - 2^{-40}$ 是一个可以精确表示的 `float64` 数。因此，$\\operatorname{fl}(1 - 2^{-40}) = 1 - 2^{-40}$。朴素残差的计算 $r_{k,i} = \\operatorname{fl}(S - \\operatorname{fl}(S \\cdot (1-2^{-40})))$ 涉及两个相近大数的相减。$S = 2^{54}$ 且 $S(1-2^{-40}) = 2^{54} - 2^{14}$。这个减法将损失大约 40 位的精度，但由于精确结果（$2^{14}$）与舍入误差（$S \\cdot \\epsilon_{\\text{mach}} \\approx 2^{54} \\cdot 2^{-52} = 4$）相比仍然很大，计算结果应该相当准确。\n\n- **对于 $k=54$：**我们计算 $\\operatorname{fl}(1 - 2^{-54})$。由于 $54 > 53$，值 $1 - 2^{-54}$ 不能被精确表示。它落在区间 $(1 - 2^{-53}, 1)$ 内，并且比 $1 - 2^{-52}$ 更接近 $1$。因此，它会舍入为 $1$。所以，$\\operatorname{fl}(1 - 2^{-54}) = 1$。\n    计算出的向量 $\\hat{x}_{54}$ 实际上是 $\\mathbf{1}$。朴素残差随之计算为：\n    $$\\hat{r}_{54} = \\operatorname{fl}(b - A \\hat{x}_{54}) = \\operatorname{fl}(S\\mathbf{1} - (S \\cdot I)\\mathbf{1}) = \\operatorname{fl}(S\\mathbf{1} - S\\mathbf{1}) = \\mathbf{0}$$\n    因此，计算出的范数 $\\|r_{54}^{(\\text{float64})}\\|_2$ 将为 $0$。\n\n- **对于 $k=60$：**分析与 $k=54$ 的情况相同。由于 $60 > 53$，$\\operatorname{fl}(1 - 2^{-60}) = 1$。计算出的残差向量 $\\hat{r}_{60}$ 将是零向量，其范数 $\\|r_{60}^{(\\text{float64})}\\|_2$ 也将为 $0$。\n\n### 3. 差异与停滞\n\n现在我们可以预测结果和停滞标志。\n- **对于 $k=40 \\to k=54$：**\n    - 真实误差范数减小：$\\|e_{54}\\|_2 = 2^{-53}  2^{-39} = \\|e_{40}\\|_2$。\n    - 朴素残差范数也减小：$\\|r_{54}^{(\\text{float64})}\\|_2 = 0  \\|r_{40}^{(\\text{float64})}\\|_2 \\approx 2^{15}$。\n    - 停滞条件 $\\left( \\|e_{54}\\|_{2}  \\|e_{40}\\|_{2} \\right) \\land \\left( \\|r_{54}^{(\\text{float64})}\\|_{2} \\ge \\|r_{40}^{(\\text{float64})}\\|_{2} \\right)$ 是 `True` $\\land$ `False`，其计算结果为 `False`。\n\n- **对于 $k=54 \\to k=60$：**\n    - 真实误差范数继续减小：$\\|e_{60}\\|_2 = 2^{-59}  2^{-53} = \\|e_{54}\\|_2$。\n    - 朴素残差范数停滞：$\\|r_{60}^{(\\text{float64})}\\|_2 = 0$ 且 $\\|r_{54}^{(\\text{float64})}\\|_2 = 0$。条件 $\\|r_{60}^{(\\text{float64})}\\|_2 \\ge \\|r_{54}^{(\\text{float64})}\\|_2$ 是 $0 \\ge 0$，即 `True`。\n    - 停滞条件 $\\left( \\|e_{60}\\|_{2}  \\|e_{54}\\|_{2} \\right) \\land \\left( \\|r_{60}^{(\\text{float64})}\\|_{2} \\ge \\|r_{54}^{(\\text{float64})}\\|_{2} \\right)$ 是 `True` $\\land$ `True`，其计算结果为 `True`。\n\n这个分析突显了在迭代求解器中使用朴素残差作为停止准则的一个关键局限性。当灾难性相消发生时，计算出的残差可能会变得人为地小（或为零），表现出假收敛，而此时真实误差可能仍然很大。高精度计算避免了这一陷阱，并能正确跟踪真实残差，从而显示出当 $k \\ge 54$ 时，$\\|r_{k}^{(\\text{float64})}\\|_2$ 和 $\\|r_{k}^{(\\text{dec})}\\|_{2}$ 之间存在巨大差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport decimal\n\ndef solve():\n    \"\"\"\n    Analyzes the effect of catastrophic cancellation on residual norm computation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'n': 4, 'p': 54, 'k': 40},\n        {'n': 4, 'p': 54, 'k': 54},\n        {'n': 4, 'p': 54, 'k': 60},\n    ]\n\n    # Set high precision for decimal calculations, as required.\n    decimal.getcontext().prec = 100\n    \n    results_data = []\n    for case in test_cases:\n        n_val = case['n']\n        p_val = case['p']\n        k_val = case['k']\n        \n        # --- High-precision calculations using decimal ---\n        n_dec = decimal.Decimal(n_val)\n        p_dec = decimal.Decimal(p_val)\n        k_dec = decimal.Decimal(k_val)\n\n        S_dec = decimal.Decimal(2) ** p_dec\n        delta_k_dec = decimal.Decimal(2) ** (-k_dec)\n        \n        # True error norm: ||e_k||_2 = ||x_k - x*||_2\n        # Based on the analytical derivation: ||e_k||_2 = sqrt(n) * delta_k\n        norm_e_k_dec = n_dec.sqrt() * delta_k_dec\n        \n        # High-precision residual norm: ||r_k||_2 = ||b - A*x_k||_2\n        # Based on the analytical derivation: ||r_k||_2 = sqrt(n) * S * delta_k\n        norm_r_k_dec = n_dec.sqrt() * S_dec * delta_k_dec\n        \n        # --- Naive float64 calculations using numpy ---\n        S_np = np.float64(2.0**p_val)\n        b_np = S_np * np.ones(n_val, dtype=np.float64)\n        A_np = S_np * np.identity(n_val, dtype=np.float64)\n        \n        # Compute the components of x_k in float64. This is the critical step\n        # where rounding occurs. For k >= 54, 1.0 - 2.0**(-k) rounds to 1.0.\n        x_k_comp_np = np.float64(1.0) - np.float64(2.0**(-k_val))\n        x_k_np = np.full(n_val, x_k_comp_np, dtype=np.float64)\n        \n        # Compute naive residual and its norm in float64.\n        # Catastrophic cancellation occurs here.\n        r_k_np = b_np - A_np @ x_k_np\n        norm_r_k_np = np.linalg.norm(r_k_np)\n        \n        results_data.append([\n            float(norm_e_k_dec),\n            norm_r_k_np,\n            float(norm_r_k_dec)\n        ])\n\n    # --- Calculate stagnation flags between successive k values ---\n    # Compare k=40 and k=54\n    flag1 = (results_data[1][0]  results_data[0][0]) and \\\n            (results_data[1][1] >= results_data[0][1])\n    \n    # Compare k=54 and k=60\n    flag2 = (results_data[2][0]  results_data[1][0]) and \\\n            (results_data[2][1] >= results_data[1][1])\n    \n    flags = [flag1, flag2]\n\n    # --- Format the final output string as specified ---\n    # Create string representations for each result list to ensure no spaces.\n    str_results_k1 = f\"[{results_data[0][0]},{results_data[0][1]},{results_data[0][2]}]\"\n    str_results_k2 = f\"[{results_data[1][0]},{results_data[1][1]},{results_data[1][2]}]\"\n    str_results_k3 = f\"[{results_data[2][0]},{results_data[2][1]},{results_data[2][2]}]\"\n    str_flags = f\"[{str(flags[0]).lower()},{str(flags[1]).lower()}]\"\n    \n    # Final print statement in the exact required format.\n    # The problem specifies boolean values. Python's str(True) is \"True\", not \"true\".\n    # But JSON-like output often uses lowercase. Let's stick to Python's default.\n    final_flags_str = f\"[{flags[0]},{flags[1]}]\"\n\n    print(f\"[{str_results_k1},{str_results_k2},{str_results_k3},{final_flags_str}]\")\n\nsolve()\n```", "id": "3536159"}, {"introduction": "当灾难性抵消发生在更复杂的矩阵运算中时，我们往往需要借助数学分析来寻找出路。本练习探讨了计算矩阵逆的微小扰动效应，即计算 $(A+E)^{-1} - A^{-1}$，其中直接相减会导致严重的精度损失。您将通过推导和实现一个基于Fréchet导数和代数重构的数值稳定公式，来有效避免这种抵消。这个高级实践展示了如何利用分析工具将一个不稳定的计算问题转化为一个稳健的求解过程，体现了数值分析中理论与实践的深刻结合。[@problem_id:3536151]", "problem": "给定一个方形非奇异矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个具有小范数的扰动 $E \\in \\mathbb{R}^{n \\times n}$。当 $E$ 很小且 $A$ 是病态的时，通过计算每个逆矩阵然后相减来直接计算差值 $(A+E)^{-1} - A^{-1}$ 可能会导致灾难性抵消。您的任务是：使用弗雷歇导数推导一个稳定的一阶近似；获得一个代数上稳定的精确表达式，以避免两个几乎相等的矩阵相减；并以数值方式实现和测试这些计算。\n\n从以下基本概念开始：\n- 矩阵逆的定义：对于非奇异矩阵 $A$，$A^{-1}$ 满足 $A A^{-1} = I$。\n- 矩阵函数 $f$ 的弗雷歇导数的定义：一个线性算子 $L_f(A,\\cdot)$，当 $\\|E\\| \\to 0$ 时，它满足 $f(A+E) - f(A) = L_f(A,E) + o(\\|E\\|)$，其中 $L_f(A,\\cdot)$ 对 $E$ 是线性的。\n- 弗雷歇导数的乘积法则：对于矩阵函数 $g$ 和 $h$，$g(A)h(A)$ 的导数满足 $L_{g h}(A,E) = L_g(A,E) h(A) + g(A) L_h(A,E)$。\n- 矩阵的标准范数属性，包括弗罗贝尼乌斯范数 $\\|X\\|_F = \\sqrt{\\sum_{i,j} x_{ij}^2}$。\n\n按以下步骤进行：\n1) 从第一性原理出发，仅从恒等式 $A A^{-1} = I$ 和弗雷歇导数的乘积法则开始，推导函数 $f(A) = A^{-1}$ 的弗雷歇导数 $L_f(A,E)$，而不使用任何预先记忆的矩阵逆导数公式。\n2) 仅使用基于恒等式 $(A+E)(A+E)^{-1} = I$ 和 $A A^{-1} = I$ 的代数操作，推导 $(A+E)^{-1} - A^{-1}$ 的精确表达式，该表达式避免了两个几乎相等的矩阵直接相减，并且可以通过求解系数矩阵为 $A$ 和 $A+E$ 的线性系统来求值，而无需显式计算任何矩阵的逆。\n3) 定性解释为什么当 $\\|E\\|$ 相对于 $\\|A\\|$ 很小且 $A$ 是病态的时，减法 $(A+E)^{-1} - A^{-1}$ 容易发生灾难性抵消，并将其与减法条件数 $\\kappa_{\\mathrm{sub}} = \\dfrac{\\|X\\|_F + \\|Y\\|_F}{\\|X-Y\\|_F}$ 联系起来，其中 $X = (A+E)^{-1}$ 和 $Y = A^{-1}$。\n\n然后实现一个程序，完成以下操作：\n- 对每个测试用例，计算三个量：\n  a) 参考“精确”差值 $D_{\\mathrm{ref}}$，使用您在步骤 2) 中得到的代数稳定恒等式，通过求解线性系统进行计算；不要显式计算任何逆矩阵。\n  b) 从步骤 1) 得到的一阶弗雷歇近似 $D_{\\mathrm{lin}}$，通过求解线性系统进行计算；不要显式计算任何逆矩阵。\n  c) 朴素差值 $D_{\\mathrm{naive}} = (A+E)^{-1} - A^{-1}$，通过显式计算两个逆矩阵然后相减得到。\n- 对每个测试用例，报告以下四个浮点数：\n  i) $r_{\\mathrm{naive}} = \\dfrac{\\|D_{\\mathrm{naive}} - D_{\\mathrm{ref}}\\|_F}{\\|D_{\\mathrm{ref}}\\|_F}$，\n  ii) $r_{\\mathrm{lin}} = \\dfrac{\\|D_{\\mathrm{lin}} - D_{\\mathrm{ref}}\\|_F}{\\|D_{\\mathrm{ref}}\\|_F}$，\n  iii) $\\kappa_{\\mathrm{sub}} = \\dfrac{\\|(A+E)^{-1}\\|_F + \\|A^{-1}\\|_F}{\\|(A+E)^{-1} - A^{-1}\\|_F}$，\n  iv) $\\kappa_2(A)$，$A$ 的 $2$-范数条件数。\n- 如上文明确指出，对所有范数均使用弗罗贝尼乌斯范数。\n- 最终输出格式必须是单行，包含一个由每个测试用例结果组成的列表，每个结果本身是如上所述的四个浮点数的列表，以逗号分隔并用方括号括起来。\n\n测试套件：\n- 测试用例 1 (希尔伯特矩阵)：$n=8$，$A \\in \\mathbb{R}^{8 \\times 8}$ 的元素为 $a_{ij} = \\frac{1}{i+j+1}$，其中 $i,j = 0,1,\\dots,7$。令 $E = \\tau \\, e_1 e_1^\\top$，其中 $e_1 = [1,0,\\dots,0]^\\top \\in \\mathbb{R}^8$ 且 $\\tau = 10^{-10}$。\n- 测试用例 2 (类托普利茨对称正定矩阵)：$n=12$，$A \\in \\mathbb{R}^{12 \\times 12}$ 的元素为 $a_{ij} = \\rho^{|i-j|}$，其中 $i,j = 0,1,\\dots,11$ 且 $\\rho = 0.999$。令 $E = \\tau \\, (e_1 e_n^\\top + e_n e_1^\\top)$，其中 $n=12$，$e_1, e_n$ 是第一个和最后一个标准基向量，且 $\\tau = 10^{-8}$。\n- 测试用例 3 (高度缩放的对角矩阵)：$n=8$，$A = \\operatorname{diag}(10^0,10^{-2},10^{-4},10^{-6},10^{-8},10^{-10},10^{-12},10^{-14})$。令 $E = \\tau \\operatorname{diag}(1,-1,1,-1,1,-1,1,-1)$，其中 $\\tau = 10^{-16}$。\n\n角度单位和物理单位不适用于此问题。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔并用方括号括起来的结果列表，每个元素是对应一个测试用例的四个浮点数 $[r_{\\mathrm{naive}}, r_{\\mathrm{lin}}, \\kappa_{\\mathrm{sub}}, \\kappa_2(A)]$ 的列表，顺序与上面的测试套件相同。例如，三个测试用例的有效输出格式为：\n- [[0.1,0.2,3.0,4.0],[...],[...]]\n不应打印任何其他文本。", "solution": "此问题被评估为有效。它在科学上基于数值线性代数的原理，问题设定良好，提供了所有必要的信息，并且陈述客观。\n\n**1. 矩阵逆的弗雷歇导数推导**\n\n设矩阵函数为 $f(A) = A^{-1}$。矩阵逆的定义恒等式是 $A f(A) = I$，其中 $I$ 是单位矩阵。我们希望找到 $f(A)$ 的弗雷歇导数，记为 $L_f(A, E)$。\n\n我们对恒等式 $A A^{-1} = I$ 的两边取弗雷歇导数。常数函数 $C(A) = I$ 的导数是零算子，因此其对扰动 $E$ 的求值为零矩阵，即 $L_C(A, E) = \\mathbf{0}$。\n\n对于左侧的 $A A^{-1}$，我们应用弗雷歇导数的乘积法则：$L_{gh}(A,E) = L_g(A,E) h(A) + g(A) L_h(A,E)$。令 $g(A) = A$ 和 $h(A) = A^{-1}$。\n\n恒等函数 $g(A)=A$ 的弗雷歇导数就是 $L_g(A,E) = E$。$h(A)=A^{-1}$ 的导数是我们想要找到的量，$L_{A^{-1}}(A,E)$。\n\n将乘积法则应用于 $A A^{-1}$ 得到：\n$$\nL_{A A^{-1}}(A,E) = (L_A(A,E)) A^{-1} + A (L_{A^{-1}}(A,E)) = E A^{-1} + A L_{A^{-1}}(A,E)\n$$\n令原始恒等式 $A A^{-1} = I$ 两边的导数相等，我们得到：\n$$\nE A^{-1} + A L_{A^{-1}}(A,E) = \\mathbf{0}\n$$\n为了解出 $L_{A^{-1}}(A,E)$，我们整理方程：\n$$\nA L_{A^{-1}}(A,E) = -E A^{-1}\n$$\n由于 $A$ 是非奇异的，我们可以从左侧乘以 $A^{-1}$：\n$$\nA^{-1} (A L_{A^{-1}}(A,E)) = A^{-1}(-E A^{-1})\n$$\n$$\nI L_{A^{-1}}(A,E) = -A^{-1} E A^{-1}\n$$\n因此，矩阵求逆函数的弗雷歇导数为：\n$$\nL_{A^{-1}}(A,E) = -A^{-1} E A^{-1}\n$$\n所以，差值 $(A+E)^{-1} - A^{-1}$ 的一阶近似由该导数给出：\n$$\nD_{\\mathrm{lin}} = (A+E)^{-1} - A^{-1} \\approx -A^{-1} E A^{-1}\n$$\n\n**2. 代数稳定精确表达式的推导**\n\n我们的目标是为差值 $\\Delta = (A+E)^{-1} - A^{-1}$ 找出一个精确表达式，以避免两个几乎相等的矩阵直接相减。我们从扰动后矩阵的逆的恒等式开始：\n$$\n(A+E)(A+E)^{-1} = I\n$$\n我们将 $(A+E)^{-1}$ 表示为原始逆与差值的和：$(A+E)^{-1} = A^{-1} + \\Delta$。将此代入恒等式中得到：\n$$\n(A+E)(A^{-1} + \\Delta) = I\n$$\n使用分配律展开左侧：\n$$\nA(A^{-1} + \\Delta) + E(A^{-1} + \\Delta) = I\n$$\n$$\nA A^{-1} + A\\Delta + E A^{-1} + E\\Delta = I\n$$\n利用 $A A^{-1} = I$：\n$$\nI + A\\Delta + E A^{-1} + E\\Delta = I\n$$\n两边减去 $I$ 剩下：\n$$\nA\\Delta + E A^{-1} + E\\Delta = \\mathbf{0}\n$$\n现在我们求解 $\\Delta$。将含有 $\\Delta$ 的项提取公因子：\n$$\n(A+E)\\Delta + E A^{-1} = \\mathbf{0}\n$$\n$$\n(A+E)\\Delta = -E A^{-1}\n$$\n由于 $E$ 的范数很小，$A+E$ 和 $A$ 一样是非奇异的。因此我们可以从左侧乘以 $(A+E)^{-1}$：\n$$\n\\Delta = -(A+E)^{-1} E A^{-1}\n$$\n这给出了精确差值 $D_{\\mathrm{ref}} = (A+E)^{-1} - A^{-1} = -(A+E)^{-1} E A^{-1}$。这种形式在数值上是稳定的，因为小的结果 $\\Delta$ 是通过涉及小矩阵 $E$ 的乘法得到的，而不是通过大数值的抵消。\n\n为了在不显式计算任何矩阵逆的情况下计算该表达式，我们可以使用线性系统求解器。计算过程分两步：\n1.  计算中间矩阵 $M = E A^{-1}$。我们不求 $A$ 的逆，而是解矩阵方程 $M A = E$。这等价于求解 $A^T M^T = E^T$ 以得到矩阵 $M^T$。这需要解 $n$ 个以 $A^T$ 为系数矩阵的线性系统。\n2.  计算最终结果 $D_{\\mathrm{ref}} = -(A+E)^{-1} M$。这等价于解矩阵方程 $(A+E) D_{\\mathrm{ref}} = -M$，这也需要解 $n$ 个线性系统，这次的系数矩阵是 $A+E$。\n\n**3. 灾难性抵消的定性解释**\n\n灾难性抵消是浮点运算中的一种现象，即两个几乎相等的数相减导致结果具有很大的相对误差。这两个数的有效数字的前导高位相互抵消，结果由尾部的低位有效数字决定，而这些低位数字通常受到先前计算中舍入误差的影响。\n\n在这个问题中，我们考虑朴素计算 $D_{\\mathrm{naive}} = (A+E)^{-1} - A^{-1}$。当扰动 $E$ 的范数相对于 $A$ 很小时，矩阵 $A+E$ 接近于 $A$。因此，它们的逆也相近：$(A+E)^{-1} \\approx A^{-1}$。因此，执行减法 $(A+E)^{-1} - A^{-1}$ 是对两个几乎相等的矩阵进行操作，这使其容易发生灾难性抵消。\n\n当 $A$ 是病态的时，这个问题的严重性会被放大。减法的敏感性由减法条件数 $\\kappa_{\\mathrm{sub}}$ 来量化。令 $X=(A+E)^{-1}$ 和 $Y=A^{-1}$。\n$$\n\\kappa_{\\mathrm{sub}} = \\frac{\\|X\\|_F + \\|Y\\|_F}{\\|X-Y\\|_F}\n$$\n对于小的 $\\|E\\|_F$，我们有近似 $\\|X-Y\\|_F = \\|(A+E)^{-1} - A^{-1}\\|_F \\approx \\|-A^{-1} E A^{-1}\\|_F \\le \\|A^{-1}\\|_F^2 \\|E\\|_F$。分子约等于 $2\\|A^{-1}\\|_F$。因此，\n$$\n\\kappa_{\\mathrm{sub}} \\approx \\frac{2\\|A^{-1}\\|_F}{\\|-A^{-1} E A^{-1}\\|_F}\n$$\n一个病态矩阵 $A$ 具有很大的条件数 $\\kappa(A) = \\|A\\|\\|A^{-1}\\|$，这意味着 $\\|A^{-1}\\|$ 相对于 $1/\\|A\\|$ 很大。这使得 $\\kappa_{\\mathrm{sub}}$ 的分子很大。分母由于 $\\|E\\|_F$ 因子而很小。两者的组合导致一个非常大的 $\\kappa_{\\mathrm{sub}}$，表明该减法是极端病态的。计算出的 $(A+E)^{-1}$ 和 $A^{-1}$ 值中的任何微小相对误差都会被这个大因子放大，可能导致最终结果 $D_{\\mathrm{naive}}$ 的相对精度完全丧失。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import toeplitz, solve as scipy_solve\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the results\n    in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (Hilbert matrix)\n        {'n': 8, 'type': 'hilbert', 'tau': 1e-10},\n        # Test case 2 (Toeplitz-like SPD matrix)\n        {'n': 12, 'type': 'toeplitz', 'rho': 0.999, 'tau': 1e-8},\n        # Test case 3 (Highly scaled diagonal)\n        {'n': 8, 'type': 'diag', 'tau': 1e-16},\n    ]\n\n    results = []\n    for params in test_cases:\n        n = params['n']\n        \n        # --- Construct matrices A and E for the current test case ---\n        if params['type'] == 'hilbert':\n            # A_ij = 1/(i+j+1) for i,j = 0..n-1\n            A = np.fromfunction(lambda i, j: 1.0 / (i + j + 1), (n, n), dtype=float)\n            E = np.zeros((n, n), dtype=float)\n            E[0, 0] = params['tau']\n        elif params['type'] == 'toeplitz':\n            # A_ij = rho^|i-j| for i,j = 0..n-1\n            rho = params['rho']\n            A = toeplitz(rho**np.arange(n))\n            E = np.zeros((n, n), dtype=float)\n            tau = params['tau']\n            E[0, n - 1] = tau\n            E[n - 1, 0] = tau\n        elif params['type'] == 'diag':\n            # A = diag(1, 1e-2, ..., 10^(-2*(n-1)))\n            A = np.diag(10.0**(-2 * np.arange(n)))\n            E_diag = np.ones(n)\n            E_diag[1::2] = -1\n            E = params['tau'] * np.diag(E_diag)\n\n        A_plus_E = A + E\n        \n        # --- a) Compute D_ref (stable exact formula) ---\n        # D_ref = -(A+E)^{-1} E A^{-1}\n        # Step 1: Compute M = E A^{-1} by solving A^T M^T = E^T\n        M_T = scipy_solve(A.T, E.T, assume_a='gen')\n        M = M_T.T\n        # Step 2: Compute D_ref by solving (A+E) D_ref = -M\n        D_ref = scipy_solve(A_plus_E, -M, assume_a='gen')\n\n        # --- b) Compute D_lin (Fréchet approximation) ---\n        # D_lin = -A^{-1} E A^{-1} = -A^{-1} M\n        # We reuse M = E A^{-1} from the previous step.\n        # Solve A D_lin = -M\n        D_lin = scipy_solve(A, -M, assume_a='gen')\n\n        # --- c) Compute D_naive (direct subtraction) ---\n        A_inv = np.linalg.inv(A)\n        A_plus_E_inv = np.linalg.inv(A_plus_E)\n        D_naive = A_plus_E_inv - A_inv\n\n        # --- d) Compute the four required metrics ---\n        norm_fro = lambda x: np.linalg.norm(x, 'fro')\n\n        # i) r_naive: Relative error of the naive computation\n        D_ref_norm = norm_fro(D_ref)\n        if D_ref_norm > 0:\n            r_naive = norm_fro(D_naive - D_ref) / D_ref_norm\n        else:\n            r_naive = norm_fro(D_naive - D_ref)\n\n        # ii) r_lin: Relative error of the linear approximation\n        if D_ref_norm > 0:\n            r_lin = norm_fro(D_lin - D_ref) / D_ref_norm\n        else:\n            r_lin = norm_fro(D_lin - D_ref)\n\n        # iii) kappa_sub: Subtraction condition number\n        A_plus_E_inv_norm = norm_fro(A_plus_E_inv)\n        A_inv_norm = norm_fro(A_inv)\n        D_naive_norm = norm_fro(D_naive)\n        \n        if D_naive_norm > 0:\n            kappa_sub = (A_plus_E_inv_norm + A_inv_norm) / D_naive_norm\n        else:\n            # If the computed naive difference is zero, the cancellation is \"total\",\n            # indicating an infinitely ill-conditioned operation.\n            kappa_sub = np.inf\n        \n        # iv) kappa_2(A): 2-norm condition number of A\n        kappa_A = np.linalg.cond(A, 2)\n\n        results.append([r_naive, r_lin, kappa_sub, kappa_A])\n\n    # Final print statement in the exact required format.\n    # Format: [[r1_1,r1_2,k1_sub,k1_A],[r2_1,r2_2,k2_sub,k2_A],...]\n    case_strings = []\n    for res in results:\n        # Convert each float to a string. Using `repr` for full precision.\n        res_str = \",\".join(map(repr, res))\n        case_strings.append(f\"[{res_str}]\")\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "3536151"}]}