{"hands_on_practices": [{"introduction": "真正理解机器 epsilon ($\\mathrm{eps}$) 和单位舍入 ($u$) 的最好方法是从底层定义出发进行推导。本练习将引导你基于 IEEE `binary32` 标准，从第一性原理推导这些关键值，并阐明舍入规则（特别是“向偶数舍入”）如何影响像 $1+\\frac{1}{2}\\mathrm{eps}$ 这样的边界情况的计算结果。通过这个过程，你将对浮点数系统的基本属性建立起坚实的直观理解 [@problem_id:3558422]。", "problem": "考虑电气和电子工程师协会 (IEEE) 的 binary32 浮点系统，其基数 $\\beta=2$，精度 $p=24$，使用规格化有效数，并采用向最近舍入、偶数优先的舍入规则。请从规格化浮点表示和向最近舍入的标准定义出发，不要假设任何关于间距或误差的预先推导出的公式。\n\n设机器 epsilon $\\mathrm{eps}$ 定义为在该系统中，1 与严格大于 1 的最小浮点数之间的距离。设单位舍入误差 $u$ 定义为满足以下条件的最小正实数：对于区间 $[1,2)$ 中的任意实数 $x$，在采用向最近舍入、偶数优先的规则下，其舍入后的浮点数 $\\mathrm{fl}(x)$ 满足 $|\\mathrm{fl}(x)-x| \\leq u\\,|x|$。\n\n任务：\n- 从指数为 0 时的规格化二进制表示以及有效数的结构推导出 $\\mathrm{eps}$。\n- 从第一性原理出发，推导出在 binade $[1,2)$ 中，由向最近舍入、偶数优先规则所引起的最坏情况舍入误差界 $u$。\n- 使用你的推导，证明为何在浮点运算中 $1+\\mathrm{eps}1$，而 $1+\\frac{1}{2}\\mathrm{eps}$ 在同样的运算中由于偶数优先规则会舍入到 $1$。\n\n将 $\\mathrm{eps}$ 和 $u$ 表示为 2 的精确次幂。将最终答案以行向量 $(\\mathrm{eps},\\,u)$ 的形式报告。", "solution": "问题陈述是有效的。这是一个在数值分析领域中适定的、有科学依据的问题，特别涉及 IEEE 754 binary32 浮点标准。所有必要的参数都已提供，并且机器 epsilon 和单位舍入误差的定义是标准的。\n\n在 IEEE binary32 系统中，一个规格化浮点数具有以下形式：\n$$ f = (-1)^s \\times (1.m)_{2} \\times 2^{E} $$\n其中 $s$ 是符号位，$(1.m)_2$ 是有效数（或尾数），$E$ 是指数。该系统由基数 $\\beta=2$ 和精度 $p=24$ 定义。这意味着有效数共有 $p=24$ 位：一个隐含的前导位（对于规格化数总是 1）和 $p-1=23$ 个显式的小数位。因此，有效数的形式为 $(1.d_1 d_2 \\dots d_{23})_2$。\n\n**1. 机器 Epsilon ($\\mathrm{eps}$) 的推导**\n\n机器 epsilon, $\\mathrm{eps}$，定义为 1 与下一个可表示的更大浮点数之间的距离。\n数字 1 在此系统中的表示，其指数为 $E=0$，有效数的小数部分全为零。其表示形式为：\n$$ 1 = (1.000\\dots0)_2 \\times 2^0 $$\n这里，有效数在二进制小数点后有 23 个零。\n\n下一个可表示的更大浮点数，我们称之为 $x_{\\text{next}}$，必须具有相同的指数 $E=0$，但其有效数有最小的可能增量。这通过将小数部分的最低有效位 (LSB) 从 0 变为 1 来实现。LSB 对应于二进制小数点后的第 $23^{\\text{rd}}$ 位，其权重为 $2^{-23}$。\n所以，$x_{\\text{next}}$ 的有效数是：\n$$ (1.000\\dots01)_2 $$\n其中 1 位于第 $23^{\\text{rd}}$ 位。该数的值为：\n$$ x_{\\text{next}} = (1.000\\dots01)_2 \\times 2^0 = 1 \\times 2^0 + 1 \\times 2^{-23} = 1 + 2^{-23} $$\n根据其定义，机器 epsilon 是 $x_{\\text{next}}$ 和 1 之间的差：\n$$ \\mathrm{eps} = x_{\\text{next}} - 1 = (1 + 2^{-23}) - 1 = 2^{-23} $$\n这个结果可以推广到任何基数为 $\\beta=2$、精度为 $p$ 的系统。1 之后的下一个数是 $1 + \\beta^{-(p-1)}$，因此 $\\mathrm{eps} = \\beta^{-(p-1)}$。对于 $\\beta=2$ 和 $p=24$，这得到 $\\mathrm{eps} = 2^{-(24-1)} = 2^{-23}$。\n\n**2. 单位舍入误差 ($u$) 的推导**\n\n单位舍入误差 $u$ 是将一个实数舍入为其浮点表示时所产生的最大相对误差。问题将其定义为满足以下条件的最小正数 $u$：对于每个实数 $x \\in [1, 2)$，其舍入误差满足 $|\\mathrm{fl}(x) - x| \\leq u|x|$。这等价于找到最大相对误差：\n$$ u = \\max_{x \\in [1, 2)} \\frac{|\\mathrm{fl}(x) - x|}{|x|} $$\n在区间（或 binade）$[1, 2)$ 中，所有浮点数的指数均为 $E=0$。可表示的数的形式为 $f_k = (1.d_1 d_2 \\dots d_{23})_2 \\times 2^0$。\n在这个 binade 中，任意两个连续浮点数之间的间距是均匀的。该间距是有效数 LSB 的值乘以指数项 $2^E = 2^0$。LSB 的权重是 $2^{-23}$。因此，间距为 $\\Delta = 2^{-23}$，这等于 $\\mathrm{eps}$。\n\n舍入规则是“向最近舍入”。对于一个实数 $x$，其绝对误差 $|\\mathrm{fl}(x) - x|$ 最多是界定 $x$ 的两个浮点数之间间距的一半。\n$$ |\\mathrm{fl}(x) - x| \\leq \\frac{\\Delta}{2} = \\frac{\\mathrm{eps}}{2} $$\n因此，在 binade $[1, 2)$ 中舍入的最大绝对误差为：\n$$ \\max_{x \\in [1, 2)} |\\mathrm{fl}(x) - x| = \\frac{\\mathrm{eps}}{2} = \\frac{2^{-23}}{2} = 2^{-24} $$\n为了找到最大相对误差，我们必须将绝对误差除以 $|x|$，并在 $x \\in [1, 2)$ 上最大化该结果：\n$$ \\frac{|\\mathrm{fl}(x) - x|}{|x|} \\leq \\frac{2^{-24}}{|x|} $$\n当分母 $|x|$ 最小时，该表达式取得最大值。在区间 $[1, 2)$ 中，$|x|$ 的最小值为 1。\n因此，最大相对误差为：\n$$ u = \\frac{2^{-24}}{1} = 2^{-24} $$\n这表明 $u = \\frac{1}{2}\\mathrm{eps}$。\n\n**3. 运算结果的证明**\n\n我们使用推导出的值 $\\mathrm{eps} = 2^{-23}$ 和 $u = 2^{-24}$。\n\n*   **情况 1: `1 + eps`**\n    要表示的实数是 $x = 1 + \\mathrm{eps} = 1 + 2^{-23}$。\n    在二进制中，这个数是 $(1.00\\dots01)_2$，其中 1 位于二进制小数点后的第 $23^{\\text{rd}}$ 位。有效数是 $(1.m)$，其中 $m$ 是一个 23 位的字符串。这个数在 binary32 格式中是精确可表示的，因为它的有效数正好需要 $p-1=23$ 个小数位。\n    由于 $1 + \\mathrm{eps}$ 是一个精确的浮点数，因此不需要舍入。\n    $$ \\mathrm{fl}(1 + \\mathrm{eps}) = 1 + \\mathrm{eps} = 1 + 2^{-23} $$\n    由于 $2^{-23} > 0$，结果 $1 + \\mathrm{eps}$ 严格大于 1。\n\n*   **情况 2: `1 + 0.5 * eps`**\n    要表示的实数是 $x = 1 + \\frac{1}{2}\\mathrm{eps} = 1 + \\frac{1}{2}(2^{-23}) = 1 + 2^{-24}$。\n    在二进制中，这个数是 $(1.00\\dots001)_2$，其中 1 位于二进制小数点后的第 $24^{\\text{th}}$ 位。这种表示需要 24 个小数位，比 binary32 有效数中可用的 $p-1=23$ 位多一位。因此，该数不能被精确表示，必须进行舍入。\n    数 $x = 1 + 2^{-24}$ 正好位于两个最接近的可表示浮点数的正中间：\n    $$ f_{\\text{lower}} = (1.00\\dots00)_2 \\times 2^0 = 1 $$\n    $$ f_{\\text{upper}} = (1.00\\dots01)_2 \\times 2^0 = 1 + 2^{-23} = 1 + \\mathrm{eps} $$\n    中点是 $f_{\\text{lower}} + \\frac{1}{2}(f_{\\text{upper}}-f_{\\text{lower}}) = 1 + \\frac{1}{2}(2^{-23}) = 1 + 2^{-24} = x$。\n    这是一个平局情况。舍入规则是“向最近舍入，偶数优先”。这意味着我们必须选择其有效数的 LSB 为 0 的那个可表示数。\n    $f_{\\text{lower}}$ 的有效数是 $(1.00\\dots00)_2$。其第 $23^{\\text{rd}}$ 个小数位是 0。\n    $f_{\\text{upper}}$ 的有效数是 $(1.00\\dots01)_2$。其第 $23^{\\text{rd}}$ 个小数位是 1。\n    “偶数”的选择是 $f_{\\text{lower}}$，因为它的 LSB 是 0。\n    因此，$\\mathrm{fl}(1 + \\frac{1}{2}\\mathrm{eps})$ 向下舍入到 1。\n\n这些推导证实了 $\\mathrm{eps}=2^{-23}$ 和 $u=2^{-24}$。", "answer": "$$ \\boxed{ \\begin{pmatrix} 2^{-23}  2^{-24} \\end{pmatrix} } $$", "id": "3558422"}, {"introduction": "在掌握了基本原理之后，我们将把这些概念应用到更常用的 `binary64`（双精度）标准上。这个练习不仅要求你计算机器 epsilon 和单位舍入，还要求你确定特定浮点数的精确十六进制位模式 [@problem_id:3558455]。这项任务将理论数值与计算机硬件中的具体二进制表示联系起来，加深你对浮点数在内存中如何存储和操作的理解。", "problem": "考虑电气和电子工程师协会 (IEEE) 754 binary64 浮点系统，其基数 $\\beta=2$，精度 $p=53$，并采用“四舍五入至最近，偶数优先” (round-to-nearest, ties-to-even) 的舍入规则。令 $\\mathrm{eps}$ 表示机器 epsilon，其定义为在该系统中，1 与下一个严格大于 1 的可表示浮点数之差。令 $u$ 表示单位舍入误差 (unit roundoff)，其定义为在该系统中，当实数在 1 的邻域内根据“偶数优先”规则舍入到最近的可表示浮点数时，所产生的最大相对舍入误差。\n\n仅使用这些定义以及 IEEE 754 binary64 规范化数的编码结构（符号位、偏置为 1023 的偏置指数和一个带有隐式前导 1 的 52 位小数部分），确定：\n- $\\mathrm{eps}$ 和 $u$ 以 2 的幂表示的精确值，以及\n- 浮点数 $\\mathrm{fl}(1+\\mathrm{eps})$ 和 $\\mathrm{fl}(1+u)$ 在该系统中的精确 64 位十六进制编码（表示为 16 位十六进制数字的字），其中 $\\mathrm{fl}(\\cdot)$ 表示使用“偶数优先”规则舍入到最近的可表示浮点数。\n\n将您的最终答案表示为一个单行行向量，依次包含 $\\mathrm{eps}$、$u$、$\\mathrm{fl}(1+\\mathrm{eps})$ 的十六进制编码和 $\\mathrm{fl}(1+u)$ 的十六进制编码。您的答案中不需要进行数值舍入。将“十六进制编码”解释为标准的 64 位字，表示为一个以 0x 为前缀的 16 位十六进制数字字符串，按通常的最高有效十六进制位在前的顺序表示符号、指数和小数部分。", "solution": "在尝试给出解答之前，将根据指定标准对问题进行验证。\n\n### 步骤 1：提取给定信息\n- **系统**：IEEE 754 binary64 浮点系统\n- **基数**：$\\beta=2$\n- **精度**：$p=53$\n- **舍入规则**：四舍五入至最近，偶数优先\n- **机器 Epsilon 定义 ($\\mathrm{eps}$)**：1 与下一个严格大于 1 的可表示浮点数之间的差值。\n- **单位舍入误差定义 ($u$)**：在 1 的邻域内舍入到最近的可表示数时的最大相对舍入误差。\n- **编码结构**：规范化数使用一个符号位、一个偏置为 1023 的偏置指数和一个带有隐式前导 1 的 52 位小数部分。\n- **任务**：确定 $\\mathrm{eps}$ 和 $u$ 的精确值，以及 $\\mathrm{fl}(1+\\mathrm{eps})$ 和 $\\mathrm{fl}(1+u)$ 的 64 位十六进制编码。\n\n### 步骤 2：使用提取的给定信息进行验证\n- **科学依据**：该问题完全基于 IEEE 754 标准，这是浮点算术的一个基本且普遍接受的规范。机器 epsilon、单位舍入误差和数字表示等概念是数值分析的核心。该问题是科学合理的。\n- **适定性**：该问题提供了精确的定义和所有必要的参数（$\\beta=2$，$p=53$，偏置=1023，舍入规则），以唯一地确定所要求的值。问题清晰明确，并导向一个唯一的、稳定的解。\n- **客观性**：问题陈述使用正式、客观的语言。它不包含任何主观主张、偏见或意见。\n- **结论**：该问题是自包含的、一致的且定义明确的。它符合所有有效性标准。\n\n### 步骤 3：结论与行动\n该问题有效。将提供完整的解答。\n\n### 解答推导\nIEEE 754 binary64 格式的规范化浮点数 $x$ 由 $x = (-1)^s \\times (1.f)_2 \\times 2^E$ 给出，其中 $s$ 是符号位，$(1.f)_2$ 是有效数（或尾数），$E$ 是指数。有效数的精度为 $p=53$ 位，包括一个隐式前导位（对于规范化数总是 1）和 52 个显式小数位，由位串 $f$ 表示。指数 $E$ 以偏置值 $e = E + 1023$ 的形式存储。\n\n首先，我们确定机器 epsilon $\\mathrm{eps}$ 的值。\n数字 $1$ 在此系统中的表示为 $s=0$，指数 $E=0$，小数部分 $f$ 全为零。\n1 的值：$x_1 = (-1)^0 \\times (1.00...0)_2 \\times 2^0 = 1$。\n有效数为 $1.0$，总共有 $p=53$ 位（1 个隐式位，52 个显式零位）。\n下一个更大的可表示数 $x_{next}$ 是通过将有效数的最低有效位 (LSB) 加一形成的。有效数变为 $(1.0...01)_2$，其中最后的 1 在二进制小数点后的第 52 位。该位的值为 $2^{-52}$。\n$x_{next}$ 的值：$x_{next} = (-1)^0 \\times (1.0 + 2^{-52}) \\times 2^0 = 1 + 2^{-52}$。\n根据定义，机器 epsilon 是这两个数之差：\n$\\mathrm{eps} = x_{next} - x_1 = (1 + 2^{-52}) - 1 = 2^{-52}$。\n\n接下来，我们确定单位舍入误差 $u$。\n单位舍入误差是当一个实数舍入到最近的浮点数时的最大相对误差。对于一个数 $x$，误差的界限是 $x$ 周围可表示数之间间距的一半。两个连续机器数之间的间距称为“最低有效位的单位”或 ULP。对于任何数 $y \\in [1, 2)$，ULP 是恒定的，等于 $2^{-52}$，这恰好是 $\\mathrm{eps}$。\n因此，在 $[1, 2)$ 区间内的一个数的最大绝对舍入误差为 $\\frac{1}{2} \\text{ULP}(1) = \\frac{1}{2}\\mathrm{eps}$。\n当分母最小时，即对于该区间中最小的数（即一个刚大于 1 的数），相对误差最大。因此，最大相对舍入误差为：\n$u = \\frac{\\frac{1}{2}\\mathrm{eps}}{1} = \\frac{1}{2}\\mathrm{eps} = \\frac{1}{2} \\times 2^{-52} = 2^{-53}$。\n\n现在我们确定 $\\mathrm{fl}(1+\\mathrm{eps})$ 的十六进制编码。\n我们有 $\\mathrm{eps} = 2^{-52}$。要表示的值是 $1 + \\mathrm{eps} = 1 + 2^{-52}$。如在推导 $\\mathrm{eps}$ 时所示，这正是 1 之后的下一个可表示浮点数。因为它是一个精确可表示的数，所以舍入函数 $\\mathrm{fl}(\\cdot)$ 返回该数本身：\n$\\mathrm{fl}(1+\\mathrm{eps}) = 1 + 2^{-52}$。\n为了找到它的编码，我们确定其组成部分：\n- 符号：该数为正，所以符号位 $s=0$。\n- 指数：该值为 $(1+2^{-52}) \\times 2^0$，所以真实指数为 $E=0$。偏置指数为 $e = E + 1023 = 1023$。在 11 位二进制中，$1023 = (01111111111)_2$。\n- 小数部分：有效数是 $1+2^{-52} = (1.00...01)_2$。隐式的前导 1 不被存储。52 位的小数部分 $f$ 由 51 个零后跟一个 1 组成，即 $f = (00...001)_2$。\n64 位的表示是 $s | e | f$ 的串联：\n$0 | 01111111111 | 00...001$（小数部分有 51 个零）。\n将这些位分组为 16 个十六进制数字：\n$0011\\;1111\\;1111\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0001$\n这转换为十六进制字符串 $3\\text{FF}0000000000001$。根据要求，我们将其写为 $0\\text{x}3\\text{FF}0000000000001$。\n\n最后，我们确定 $\\mathrm{fl}(1+u)$ 的十六进制编码。\n我们有 $u = 2^{-53}$。要表示的值是 $1 + u = 1 + 2^{-53}$。这个数不是精确可表示的。它恰好位于两个连续可表示数 $x_1 = 1$ 和 $x_{next} = 1 + 2^{-52}$ 的正中间。\n中点是 $\\frac{x_1 + x_{next}}{2} = \\frac{1 + (1 + 2^{-52})}{2} = \\frac{2 + 2^{-52}}{2} = 1 + 2^{-53}$。\n我们遇到了一个平局 (tie)。舍入规则是“四舍五入至最近，偶数优先”。这意味着我们必须舍入到其有效数最低有效位为 0 的那个邻近数。\n- $x_1 = 1$ 的有效数是 $(1.00...0)_2$。其小数部分全为零，所以其 LSB 是 0。\n- $x_{next} = 1+2^{-52}$ 的有效数是 $(1.00...01)_2$。其小数部分的 LSB 是 1。\n“偶数”的选择是 $x_1 = 1$。因此，$\\mathrm{fl}(1+u) = 1$。\n数字 1 的十六进制表示如下找到：\n- 符号：$s=0$。\n- 指数：$E=0$，所以偏置指数为 $e=1023 = (01111111111)_2$。\n- 小数部分：有效数是 $1.0$，所以小数部分 $f$ 全为零：$f=(00...000)_2$。\n64 位表示为：\n$0 | 01111111111 | 00...000$（小数部分有 52 个零）。\n分组为十六进制数字：\n$0011\\;1111\\;1111\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000\\;0000$\n这转换为十六进制字符串 $3\\text{FF}0000000000000$。根据要求，我们将其写为 $0\\text{x}3\\text{FF}0000000000000$。\n\n最终答案由这四个结果组成一个单行行向量。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2^{-52}  2^{-53}  \\text{0x3FF0000000000001}  \\text{0x3FF0000000000000}\n\\end{pmatrix}\n}\n$$", "id": "3558455"}, {"introduction": "理论模型是强大的，但在实践中，计算环境的细节可能会导致意外的结果。本练习探讨了一个经典的实际场景：硬件（如 x87 浮点处理单元）的扩展精度寄存器如何导致在高级语言中凭经验测量的机器 epsilon 与理论值不符 [@problem_id:3558465]。解决这个问题能够让你认识到，在进行严谨的数值工作时，理解从编译器到硬件的整个计算栈是至关重要的。", "problem": "考虑一个用高级语言编写的程序，该程序根据电气和电子工程师协会（IEEE）754标准的定义，指定了基于$64$位二进制浮点（$\\text{binary64}$，通常称为双精度）的算术运算。该程序试图通过教科书式的对半方法来经验性地估计机器epsilon：从一个正数 $ \\epsilon_0 $ 开始，然后迭代 $ \\epsilon_{k+1} = \\epsilon_k / 2 $，直到谓词 $ \\mathrm{fl}(1 + \\epsilon_k)  1 $ 不再成立，并返回最后一个使该谓词成立的 $ \\epsilon_k $。此处，$ \\mathrm{fl}(\\cdot) $ 表示在当前舍入模式（假定为“向最近的偶数舍入”）下，由运行时提供的浮点运算的结果。\n\n在 Intel IA-32 处理器上，历史上称为 $x87$ 的浮点单元（FPU）可以在内部使用 $80$位扩展精度（$\\text{binary80}$）寄存器来评估算术运算，而语言中的类型是 $\\text{binary64}$。即时（JIT）编译器可能生成将临时变量保留在 $x87$ 寄存器中的代码，从而将向 $\\text{binary64}$ 的舍入操作延迟到存储至内存时才执行。在这种情况下，一个通过对半方法经验性地测量机器epsilon的程序，可能会报告一个与该语言抽象语义所预期的 $\\text{binary64}$ 单位舍入误差不符的值。\n\n仅使用浮点模型 $ \\mathrm{fl}(x \\,\\circ\\, y) = (x \\,\\circ\\, y)(1 + \\delta) $（其中对于基本运算 $ \\circ \\in \\{+, -, \\times, \\div\\} $ 和向最近舍入模式，$ |\\delta| \\leq u $），并结合单位舍入误差 $ u $ 是 $1$ 处连续规格化数之间间距的一半的定义，分析当临时变量以 $\\text{binary80}$ 计算但稍后才舍入到 $\\text{binary64}$ 时，这种差异是如何产生的。然后，选择唯一一个既能正确解释根本原因，又能给出一种有原则的缓解措施以确保经验性测量能反映语言所预期的 $\\text{binary64}$ 算术的最佳选项。\n\nA. 当临时变量驻留在 $x87$ 寄存器中时，谓词 $ \\mathrm{fl}(1 + \\epsilon)  1 $ 可以在 $80$位扩展精度下完全求值，因此循环会一直运行，直到 $ \\epsilon $ 的数量级达到 $\\text{binary80}$ 的单位舍入误差 $ u_{\\text{80}} $，而不是 $\\text{binary64}$ 的单位舍入误差 $ u_{\\text{64}} $。一种有原则的缓解措施是在每一步强制以 $\\text{binary64}$ 进行求值和比较，例如通过使用 Java 的严格浮点修饰符（strictfp），或者通过保证在操作之间进行内存存储和重新加载，从而使每个 $ \\mathrm{fl}(\\cdot) $ 都舍入到 $\\text{binary64}$。\n\nB. 产生差异是因为接近 $0$ 的次规格化（非规格化）数通过渐进下溢干扰了对半循环。缓解措施是启用刷新为零（flush-to-zero），使次规格化数被视为 $0$，从而恢复正确的 $\\text{binary64}$ 机器epsilon。\n\nC. 这个问题是由于编译器执行常量折叠和循环展开，改变了 $ 1 + \\epsilon $ 的算术特性所引起的。将 $ \\epsilon $ 声明为 volatile 变量可以确保循环不被优化，从而修正 epsilon 的测量。\n\nD. 不正确的测量是由于舍入模式为“向零舍入”而非“向最近的偶数舍入”。将舍入模式切换为“向最近的偶数舍入”将使经验性epsilon符合 $\\text{binary64}$ 的预期，而与寄存器精度无关。", "solution": "首先将验证问题陈述的科学合理性、自洽性和清晰性。\n\n### 步骤1：提取已知条件\n- **目标算术：** 符合 IEEE 754 标准的 $64$位二进制浮点（`binary64`，双精度）。\n- **经验算法：** 一个估计机器epsilon的迭代过程：\n    1. 从一个正数 $\\epsilon_0$ 开始。\n    2. 迭代 $\\epsilon_{k+1} = \\epsilon_k / 2$。\n    3. 循环条件是 $\\mathrm{fl}(1 + \\epsilon_k)  1$。\n    4. 结果是使条件为真的最后一个 $\\epsilon_k$。\n- **运行时环境：**\n    - 处理器：带 $x87$ 浮点单元（FPU）的 Intel IA-32。\n    - FPU能力：可使用 $80$位扩展精度（`binary80`）进行内部寄存器计算。\n    - 编译器行为：即时（JIT）编译器可能将临时变量保留在 $x87$ 寄存器中，以 `binary80` 精度执行计算。向 `binary64` 的舍入操作被延迟到值存储到主内存时。\n- **浮点模型：**\n    - $\\mathrm{fl}(\\cdot)$ 表示浮点运算的结果。\n    - 假定的舍入模式：向最近的偶数舍入。\n    - 对于基本运算 $\\circ$，$\\mathrm{fl}(x \\,\\circ\\, y) = (x \\,\\circ\\, y)(1 + \\delta)$ 其中 $|\\delta| \\leq u$。\n    - 单位舍入误差 $u$ 的定义：$1$ 处连续规格化数之间间距的一半。\n- **观察到的差异：** 经验性测量的 epsilon 值可能与 `binary64` 的理论值不匹配。\n- **任务：** 分析差异的原因，并找出解释该原因并提供有原则的缓解措施的唯一最佳选项。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：** 该问题坚实地基于数值分析、计算机体系结构和编译器设计的既定原则。IEEE 754标准、Intel $x87$ FPU 及其扩展精度寄存器的行为，以及JIT编译器的优化策略都是有据可查的现实世界概念。所描述的现象——浮点运算的有效精度超过语言类型的名义精度——是科学计算中的一个经典且重要的问题。该问题在科学上是合理的，在事实上是正确的。\n- **良态性：** 该问题是良态的。它描述了一个特定的场景，一个特定的观察（差异），并要求进行特定的分析（原因和缓解措施）。所提供的信息足以从第一性原理推导出唯一正确的解释。\n- **客观性：** 该问题以精确、客观、技术性的语言陈述，没有歧义或主观论断。\n\n### 步骤3：结论与行动\n该问题有效。这是一个数值计算领域中形式良好的问题。可以继续求解过程。\n\n### 推导\n问题的核心在于谓词 $\\mathrm{fl}(1 + \\epsilon_k)  1$ 的求值。让我们在两种不同的精度语义下分析这一点。\n\n**1. 在严格`binary64`语义下的分析：**\nIEEE 754 `binary64` 标准对尾数使用 $p=53$ 位的精度。单位舍入误差 $u_{64}$ 定义为 $1$ 处间距的一半。$1$ 与下一个更大的可表示数之间的间距是指数为 $0$ 时尾数最低有效位的值，即 $2^{1-p} = 2^{1-53} = 2^{-52}$。这个值也称为机器epsilon, $\\epsilon_{m,64}$。\n因此，单位舍入误差为 $u_{64} = \\frac{1}{2} \\epsilon_{m,64} = 2^{-53}$。\n谓词是 $\\mathrm{fl}_{64}(1 + \\epsilon_k)  1$。根据向最近舍入的模式，一个值被舍入到最接近的可表示数。一个恰好在两个可表示数中间的值，将被舍入到尾数最低有效位为偶数（零）的那个数。\n数字 $1$ 可以写成 $1.0...0 \\times 2^0$（小数点后有 $52$ 个零）。下一个可表示的数是 $1.0...01 \\times 2^0 = 1 + 2^{-52}$。\n中点是 $1 + 2^{-53}$。\n- 如果真实和 $1 + \\epsilon_k$ 小于 $1 + 2^{-53}$，它会向下舍入到 $1$。\n- 如果真实和 $1 + \\epsilon_k$ 大于 $1 + 2^{-53}$，它会向上舍入到 $1 + 2^{-52}$。\n- 如果真实和 $1 + \\epsilon_k$恰好是 $1 + 2^{-53}$，则出现平局情况。两个选择是 $1$（尾数以 $0$ 结尾）和 $1+2^{-52}$（尾数以 $1$ 结尾）。向最近的偶数舍入规则选择 $1$。\n所以，$\\mathrm{fl}_{64}(1 + \\epsilon_k)  1$ 当且仅当 $1 + \\epsilon_k  1 + 2^{-53}$，简化为 $\\epsilon_k  2^{-53}$。\n对半过程生成一个序列 $\\epsilon_k$。当 $\\epsilon_k \\le 2^{-53}$ 时循环终止。循环条件为真的最后一个值是 $\\epsilon_{k-1} = 2 \\epsilon_k$。如果序列包含2的幂，最后一个成功的值将是 $2 \\times (2^{-53}) = 2^{-52}$。这是 `binary64` 的正确机器epsilon。\n\n**2. 在`binary80`临时求值下的分析：**\n问题陈述指出，在 $x87$ FPU 上，$1 + \\epsilon_k$ 的中间计算可能会以 `binary80` 扩展精度执行。\nIEEE 754 `binary80` 标准使用 $p=64$ 位的精度。\n机器epsilon是 $\\epsilon_{m,80} = 2^{1-64} = 2^{-63}$。单位舍入误差是 $u_{80} = \\frac{1}{2} \\epsilon_{m,80} = 2^{-64}$。\n如果表达式 $1 + \\epsilon_k$ 在一个 $80$位寄存器中计算和保存，并且 ` 1` 的比较也是用这个 $80$位的值与一个提升到 `binary80` 的值 $1$ 进行比较，那么整个谓词都以 `binary80` 精度进行求值：$\\mathrm{fl}_{80}(1 + \\epsilon_k)  1$。\n根据与上述相同的逻辑，此条件成立当且仅当 $\\epsilon_k  u_{80} = 2^{-64}$。\n因此，循环将持续更长时间，直到 $\\epsilon_k$ 达到 $2^{-64}$ 的数量级。该过程返回的值将约为 $\\epsilon_{m,80} = 2^{-63}$，而不是 $\\epsilon_{m,64} = 2^{-52}$。这就解释了这种差异。经验性测量反映了用于临时变量的底层硬件寄存器的精度，而不是源代码中指定的变量类型的精度。\n\n**3. 有原则的缓解措施：**\n为了获得正确的 `binary64` 机器epsilon，源代码所隐含的每一次浮点运算都必须以 `binary64` 语义执行。这意味着加法 $1 + \\epsilon_k$ 的结果必须在进行比较*之前*舍入到 `binary64` 精度。\n一个通用的策略是强制将中间结果从宽 FPU 寄存器移出，存入为 `binary64` 变量分配的内存位置。当 $80$位值写入 $64$位内存槽时，硬件会执行必要的舍入。为进行比较而重新加载此值，可确保比较是在两个符合 `binary64` 标准的数之间进行。\n语言级别的机制可以强制执行此操作。在 Java 中，`strictfp` 关键字强制严格遵守 IEEE 754 `binary32` 和 `binary64` 语义，禁止对中间结果使用扩展精度。在像 C/C++ 这样的语言中，将变量声明为 `volatile` 通常会迫使编译器生成在每次访问时都从内存中存储和重新加载变量的代码，从而防止它跨语句保留在寄存器中。\n\n### 逐项分析\n\n**A. 当临时变量驻留在 $x87$ 寄存器中时，谓词 $ \\mathrm{fl}(1 + \\epsilon)  1 $ 可以在 $80$-bit 扩展精度下完全求值，因此循环会一直运行，直到 $ \\epsilon $ 的数量级达到 $\\text{binary80}$ 的单位舍入误差 $ u_{\\text{80}} $，而不是 $\\text{binary64}$ 的单位舍入误差 $ u_{\\text{64}} $。一种有原则的缓解措施是在每一步强制以 $\\text{binary64}$ 进行求值和比较，例如通过使用 Java 的严格浮点修饰符（strictfp），或者通过保证在操作之间进行内存存储和重新加载，从而使每个 $ \\mathrm{fl}(\\cdot) $ 都舍入到 $\\text{binary64}$。**\n- **理由：** 此选项正确地指出了根本原因：临时表达式 $(1 + \\epsilon)$ 的求值精度（`binary80`）高于名义上的语言类型精度（`binary64`）。它正确地推断出这将导致循环一直运行，直到 $\\epsilon$ 接近更高精度的单位舍入误差 $u_{\\text{80}}$。此外，它提供了正确且标准的有原则的缓解措施：使用像 `strictfp` 这样的语言特性或强制内存存储和重载，这两种方法都确保中间结果被舍入到名义上的 `binary64` 精度。\n- **结论：** **正确**。\n\n**B. 产生差异是因为接近 $ 0 $ 的次规格化（非规格化）数通过渐进下溢干扰了对半循环。缓解措施是启用刷新为零（flush-to-zero），使次规格化数被视为 $ 0 $，从而恢复正确的 $\\text{binary64}$ 机器epsilon。**\n- **理由：** 这个解释是错误的。机器epsilon的计算涉及对 $1$ 附近的数进行算术运算，特别是 $1 + \\epsilon$ (其中 $\\epsilon$ 很小)。结果总是非常接近 $1$。次规格化（非规格化）数和渐进下溢涉及非常接近零的浮点数，即量级上小于最小规格化数的数。这种浮点运算的范畴与当前问题无关。\n- **结论：** **错误**。\n\n**C. 这个问题是由于编译器执行常量折叠和循环展开，改变了 $ 1 + \\epsilon $ 的算术特性所引起的。将 $ \\epsilon $ 声明为 `volatile` 变量可以确保循环不被优化，从而修正 epsilon 的测量。**\n- **理由：** 此选项错误地识别了原因。虽然涉及到编译器优化，但“常量折叠”不适用，因为 $\\epsilon$ 是一个循环变量。循环展开本身并不改变算术精度。虽然将 $\\epsilon$ 声明为 `volatile` 可能是一种有效的缓解措施，但原因并非它笼统地“确保循环不被优化”。它之所以有效的具体原因是 `volatile` 强制对内存进行读写，其副作用是强制将 FPU 寄存器中的 $80$位值舍入为内存中的 $64$位表示。对原因的解释是有缺陷的，对缓解措施为何有效的解释也不精确。选项 A 提供了更根本、更准确的说明。\n- **结论：** **错误**。\n\n**D. 不正确的测量是由于舍入模式为“向零舍入”而非“向最近的偶数舍入”。将舍入模式切换为“向最近的偶数舍入”将使经验性epsilon符合 $\\text{binary64}$ 的预期，而与寄存器精度无关。**\n- **理由：** 这是错误的。首先，问题明确指出假定“向最近的偶数舍入”是当前模式。问题并非由使用不同模式引起。其次，改变舍入模式不会解决根本问题，即*精度*（$64$位 vs. $80$位）的差异，而不是舍入*规则*的差异。执行计算的寄存器精度决定了结果，而与舍入模式无关。声称该修复“无论寄存器精度如何”都有效，直接与问题的实际性质相矛盾。\n- **结论：** **错误**。", "answer": "$$\\boxed{A}$$", "id": "3558465"}]}