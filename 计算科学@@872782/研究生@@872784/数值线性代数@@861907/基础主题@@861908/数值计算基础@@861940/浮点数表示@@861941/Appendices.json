{"hands_on_practices": [{"introduction": "要分析浮点误差，我们必须首先掌握其表示法的基础。本练习将提供一个具体的 IEEE 754 binary32 比特模式，要求您将其转换回其精确的十进制值。这项实践旨在巩固您对符号、偏置指数和有效数（尾数）作用的理解，这些是构成所有浮点数的基石。[@problem_id:3546510]", "problem": "考虑 Institute of Electrical and Electronics Engineers (IEEE) 754 binary32 浮点格式。一个浮点数据由其位域给出：符号位 $s=0$，指数域 $E=(10000001)_{2}$，以及小数域 $f=(01000000000000000000000)_{2}$。仅使用该标准关于 binary32 编码的核心定义（符号位、偏置指数（偏置值为 $b=127$），以及规格化有效数的隐含前导 $1$），确定此位模式所表示的精确实数值。您的推导过程必须根据域值明确证明该数的分类（规格化数、非规格化数或特殊值），并且必须解释偏置值 $b=127$ 在从存储的指数域中恢复真实指数时的作用。请以无舍入的精确实数形式提供最终答案。", "solution": "该问题是有效的。这是一个基于既有的 IEEE $754$ 浮点算术标准的、形式良好且有科学依据的问题。所有必要信息均已提供，任务是根据该标准的定义进行直接计算。\n\n在 IEEE $754$ 标准中，一个浮点数的值由其三个部分决定：符号位 $s$、指数域 $E$ 和小数域 $f$。问题中给出的这些值为：\n- 符号位：$s=0$\n- 指数域：$E = (10000001)_{2}$\n- 小数域：$f = (01000000000000000000000)_{2}$\n\n分析过程是根据 binary32 格式规则解释这些位域。\n\n首先，我们必须将该数分类为规格化数、非规格化数或特殊值。这个分类取决于指数域 $E$ 的值。binary32 格式使用一个 8 位指数域，所以其值的范围可以从 $0$ 到 $255$。特殊值是 $E=0$（用于零和非规格化数）和 $E=255$（用于无穷大和 NaNs）。所有其他值，即 $1 \\le E \\le 254$，都表示规格化数。\n\n我们将给定的指数域 $E$ 从二进制转换为十进制：\n$$E = (10000001)_{2} = 1 \\times 2^{7} + 0 \\times 2^{6} + 0 \\times 2^{5} + 0 \\times 2^{4} + 0 \\times 2^{3} + 0 \\times 2^{2} + 0 \\times 2^{1} + 1 \\times 2^{0}$$\n$$E = 128 + 1 = 129$$\n由于 $1 \\le 129 \\le 254$，该位模式表示一个**规格化**数。\n\n对于规格化数，其值 $v$ 由以下公式给出：\n$$v = (-1)^{s} \\times M \\times 2^{e}$$\n其中 $M$ 是有效数（尾数），$e$ 是真实指数。\n\n符号由符号位 $s$ 决定。由于 $s=0$，该数为正数。因子 $(-1)^{s}$ 为 $(-1)^{0} = 1$。\n\n真实指数 $e$ 是通过从存储的指数域 $E$ 中减去一个偏置值 $b$ 来恢复的。对于 binary32 格式，偏置值为 $b=127$。偏置值的目的是允许 8 位的无符号指数域表示正负两种真实指数。存储值为 $E=127$ 对应于真实指数 $e=0$。大于 $127$ 的值产生正指数，小于 $127$ 的值产生负指数。\n计算真实指数：\n$$e = E - b = 129 - 127 = 2$$\n\n有效数 $M$ 由小数域 $f$ 构成。对于规格化数，存在一个不被存储的隐含前导位 $1$。因此，有效数的形式为 $1.f$。\n给定小数域 $f=(01000000000000000000000)_{2}$，完整的二进制有效数是：\n$$M = (1.01000000000000000000000)_{2}$$\n为了求出 $M$ 的十进制值，我们将每一位对应的 $2$ 的幂相加：\n$$M = 1 \\times 2^{0} + 0 \\times 2^{-1} + 1 \\times 2^{-2} + 0 \\times 2^{-3} + \\dots$$\n$$M = 1 + \\frac{1}{4} = 1 + 0.25 = 1.25$$\n\n最后，我们将所有部分组合起来，求出精确实数值 $v$：\n$$v = (-1)^{s} \\times M \\times 2^{e}$$\n$$v = (-1)^{0} \\times 1.25 \\times 4$$\n$$v = 5$$\n此位模式所表示的精确实数值是 $5$。", "answer": "$$\\boxed{5}$$", "id": "3546510"}, {"introduction": "一个常见的误解是，简单的小数总能被精确地表示为二进制浮点数。本练习将通过分析数字 $0.1$ 来打破这一迷思。通过推导其无限循环的二进制展开，并确定它如何被舍入以适应 binary64 格式的有限精度，您将计算出其中引入的精确误差，从而深刻体会到为何表示误差是浮点系统固有的特性。[@problem_id:3546541]", "problem": "给定由电气和电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) 754 binary64 格式定义的二进制浮点系统，回顾以下基本定义。一个规格化浮点数的形式为 $x = \\pm (1 + f) \\times 2^{e}$，其中 $f \\in [0,1)$ 在二进制下的小数部分最多有 $p-1$ 位（对于 binary64，$p=53$，计算了隐藏的前导位），$e$ 是一个整数指数。舍入模式为向最近舍入，平局时取偶数有效数。一个实数 $x$ 通过此规则舍入到最接近的可表示浮点数，从而映射到其浮点值 $\\operatorname{fl}(x)$。\n\n仅从这些定义和有理数二进制展开的基本原理出发，对 $x = 0.1$ 执行以下操作：\n- 推导 $x$ 的无限二进制展开式，并确定其循环节。\n- 确定唯一的最近 binary64 表示 $\\operatorname{fl}(0.1)$，方法是找出其精确的规格化有效数和指数，表示为 $(1 + f) \\times 2^{e}$ 的形式，其中 $f$ 是一个分子和分母均为整数的有理数。\n- 计算精确误差 $\\operatorname{fl}(0.1) - 0.1$，结果表示为一个最简有理数。\n\n你的最终答案必须仅为精确误差 $\\operatorname{fl}(0.1) - 0.1$，以单个最简有理数的形式给出。无需舍入。不包含单位。", "solution": "本题要求解当实数 $x = 0.1$ 用 IEEE 754 binary64 浮点格式表示时产生的精确舍入误差。此任务需要三个主要步骤：首先，确定 $x=0.1$ 的二进制展开式；其次，应用指定的舍入规则找到其 binary64 表示 $\\operatorname{fl}(0.1)$；第三，计算误差 $\\operatorname{fl}(0.1) - 0.1$。\n\n首先，我们将 $x=0.1$ 表示为有理数 $x = \\frac{1}{10}$。我们推导其二进制展开式，形式为 $x = (0.b_1 b_2 b_3 \\dots)_2 = \\sum_{i=1}^{\\infty} b_i 2^{-i}$，其中 $b_i \\in \\{0, 1\\}$。比特 $b_i$ 通过“乘2取整”法得到。\n令 $x_0 = x = \\frac{1}{10}$。\n$2x_0 = \\frac{2}{10} = \\frac{1}{5}$。整数部分为 $b_1 = \\lfloor \\frac{1}{5} \\rfloor = 0$。小数部分为 $x_1 = \\frac{1}{5}$。\n$2x_1 = \\frac{2}{5}$。整数部分为 $b_2 = \\lfloor \\frac{2}{5} \\rfloor = 0$。小数部分为 $x_2 = \\frac{2}{5}$。\n$2x_2 = \\frac{4}{5}$。整数部分为 $b_3 = \\lfloor \\frac{4}{5} \\rfloor = 0$。小数部分为 $x_3 = \\frac{4}{5}$。\n$2x_3 = \\frac{8}{5} = 1 + \\frac{3}{5}$。整数部分为 $b_4 = \\lfloor \\frac{8}{5} \\rfloor = 1$。小数部分为 $x_4 = \\frac{3}{5}$。\n$2x_4 = \\frac{6}{5} = 1 + \\frac{1}{5}$。整数部分为 $b_5 = \\lfloor \\frac{6}{5} \\rfloor = 1$。小数部分为 $x_5 = \\frac{1}{5}$。\n在这一步，我们发现 $x_5 = x_1$。小数部分的序列将开始重复，因此从 $b_2$ 开始的相应比特也将重复。重复的比特块是 $b_2 b_3 b_4 b_5$，即 $0011$。\n因此，$0.1$ 的二进制展开式为 $x = (0.0001100110011\\dots)_2$，可以简写为 $x = (0.0\\overline{0011})_2$。循环节是序列 $0011$，长度为 $4$。\n\n为了验证这一点，我们可以使用等比级数将循环二进制展开式转换回有理数。\n令 $y = (0.\\overline{0011})_2$。则 $y = \\sum_{k=1}^{\\infty} (0 \\cdot 2^{-4k+3} + 0 \\cdot 2^{-4k+2} + 1 \\cdot 2^{-4k+1} + 1 \\cdot 2^{-4k}) = \\sum_{k=1}^{\\infty} 3 \\cdot (2^{-4})^k = 3 \\sum_{k=1}^{\\infty} (\\frac{1}{16})^k$。\n这是一个首项为 $\\frac{3}{16}$、公比为 $\\frac{1}{16}$ 的等比级数。其和为 $\\frac{3/16}{1 - 1/16} = \\frac{3/16}{15/16} = \\frac{3}{15} = \\frac{1}{5}$。\n$x$ 的展开式为 $(0.0\\overline{0011})_2 = \\frac{1}{2} \\times (0.\\overline{0011})_2 = \\frac{1}{2} \\times y = \\frac{1}{2} \\times \\frac{1}{5} = \\frac{1}{10}$，这证实了结果。\n\n接下来，我们确定 $x$ 的 binary64 表示。一个规格化浮点数的形式为 $\\pm (1+f) \\times 2^e$。我们必须将 $x$ 重写为这种科学记数法形式。\n$x = (0.000110011\\dots)_2$。\n为了规格化，我们将二进制小数点向右移动 4 位：\n$x = (1.100110011\\dots)_2 \\times 2^{-4}$。\n由此，我们确定指数 $e = -4$。理想的有效数是 $M = (1.100110011\\dots)_2 = 1 + (0.100110011\\dots)_2$。理想的小数部分是 $f_{ideal} = (0.100110011\\dots)_2$。小数部分中重复的比特块是 $1001$。\n\nbinary64 格式对有效数使用 $p=53$ 位的精度（1 个隐藏位和 $p-1=52$ 个小数位）。我们必须将理想的有效数舍入到 52 个小数位。舍入模式是“向最近舍入，平局时取偶”。\n我们将 $x$ 表示为适合舍入的形式。$x = M \\times 2^e$，其中 $M$ 是理想的有效数，且 $e=-4$。浮点表示将是 $\\operatorname{fl}(x) = \\frac{S}{2^{52}} \\times 2^e$，其中 $S$ 是一个 53 位的整数。$S$ 是通过将值 $M \\times 2^{52}$ 舍入到最近的整数得到的。\n需要舍入的值是 $x \\times 2^{52-e} = \\frac{1}{10} \\times 2^{52 - (-4)} = \\frac{1}{10} \\times 2^{56} = \\frac{2^{55}}{5}$。\n要将此值舍入到最近的整数，我们分析其小数部分。我们可以使用模运算来求 $2^{55}$ 除以 5 的余数。\n$2^1 \\equiv 2 \\pmod 5$\n$2^2 \\equiv 4 \\equiv -1 \\pmod 5$\n$2^4 \\equiv (-1)^2 \\equiv 1 \\pmod 5$\n我们可以将 55 写为 $55 = 4 \\times 13 + 3$。\n所以，$2^{55} = 2^{4 \\times 13 + 3} = (2^4)^{13} \\times 2^3 \\equiv 1^{13} \\times 8 \\equiv 8 \\equiv 3 \\pmod 5$。\n这意味着对于某个整数 $k$，有 $2^{55} = 5k + 3$。\n所以，要舍入的值是 $\\frac{5k+3}{5} = k + \\frac{3}{5}$。\n最近的整数是 $k+1$，因为小数部分 $\\frac{3}{5} = 0.6$ 大于 $0.5$。这不是平局情况，因此规则中“平局时取偶”的部分不被调用。我们向上舍入。\n整数 $k$ 是 $k = \\frac{2^{55}-3}{5}$。\n舍入后的整数有效数是 $S = k+1 = \\frac{2^{55}-3}{5} + 1 = \\frac{2^{55}-3+5}{5} = \\frac{2^{55}+2}{5}$。\n这是一个整数，因为 $2^{55}+2 \\equiv 3+2 \\equiv 5 \\equiv 0 \\pmod 5$。\n\n因此，$0.1$ 的 binary64 表示为：\n$\\operatorname{fl}(0.1) = \\frac{S}{2^{52}} \\times 2^e = \\frac{(2^{55}+2)/5}{2^{52}} \\times 2^{-4} = \\frac{2^{55}+2}{5 \\times 2^{52} \\times 2^4} = \\frac{2^{55}+2}{5 \\times 2^{56}}$。\n我们可以简化这个表达式：\n$\\operatorname{fl}(0.1) = \\frac{2^{55}}{5 \\times 2^{56}} + \\frac{2}{5 \\times 2^{56}} = \\frac{1}{5 \\times 2} + \\frac{1}{5 \\times 2^{55}} = \\frac{1}{10} + \\frac{1}{5 \\times 2^{55}}$。\n\n规格化形式 $(1+f) \\times 2^e$ 如下。指数是 $e=-4$。舍入后的有效数是 $M_{fl} = \\frac{S}{2^{52}} = \\frac{2^{55}+2}{5 \\times 2^{52}} = \\frac{2^3 \\times 2^{52} + 2}{5 \\times 2^{52}} = \\frac{8 \\times 2^{52} + 2}{5 \\times 2^{52}} = \\frac{8}{5} + \\frac{2}{5 \\times 2^{52}} = \\frac{8}{5} + \\frac{2}{5}2^{-52}$。\n$M_{fl} = 1+f$，所以 $f = M_{fl}-1 = \\frac{3}{5} + \\frac{2}{5}2^{-52} = \\frac{3 \\times 2^{52} + 2}{5 \\times 2^{52}}$，这是一个分子和分母均为整数的有理数。\n\n最后，我们计算精确误差 $E = \\operatorname{fl}(0.1) - 0.1$。\n$E = \\left(\\frac{1}{10} + \\frac{1}{5 \\times 2^{55}}\\right) - \\frac{1}{10}$。\n$E = \\frac{1}{5 \\times 2^{55}}$。\n分子是 $1$，分母是 $5 \\times 2^{55}$。它们没有公因数，所以这个分数是最简分数。这就是精确误差。", "answer": "$$\\boxed{\\frac{1}{5 \\times 2^{55}}}$$", "id": "3546541"}, {"introduction": "表示误差虽然微小，但在算术运算中可能带来毁灭性的后果。本问题通过减去两个非常接近的数，来演示“灾难性抵消”现象。您将首先观察这些数字在表示时如何被舍入，然后看到减法如何放大它们尾部不精确比特的重要性，最终导致结果的相对精度严重损失。[@problem_id:3642283]", "problem": "考虑在电气和电子工程师协会（IEEE 754）浮点数算术标准中执行的算术运算，具体是 binary32 格式，该格式具有一个符号位、八个指数位（偏置值为 127）、以及 23 个小数部分位（对于规格化数，有一个隐藏的前导 1）。两个十进制输入 $x = 123456.78$ 和 $y = 123456.77$ 首先使用“向最近舍入，偶数优先”的规则转换为 binary32 格式，然后执行减法 $x - y$，并使用相同的规则将结果正确舍入到 binary32 格式。仅从 binary32 的结构定义和规格化出发，确定硬件为该减法运算返回的精确十进制值。\n\n将最终答案表示为一个精确的十进制数。无需单位。", "solution": "### 解题过程\n\n该问题要求我们模拟硬件遵循 IEEE 754 binary32 标准执行浮点转换和减法运算的过程。\n\n**1. 确定相关的浮点精度 (ULP)**\n\n首先，我们必须确定输入数 $x = 123456.78$ 和 $y = 123456.77$ 的量级。我们可以找到界定它们的 2 的幂：\n$$2^{16} = 65536$$\n$$2^{17} = 131072$$\n由于 $2^{16}  x, y  2^{17}$，这些数的任何规格化 binary32 表示都将具有一个无偏指数 $E=16$。\n在这种格式下，一个规格化数的值由 $v = (-1)^s \\times (1.f)_2 \\times 2^E$ 给出，其中 $s$ 是符号位，$f$ 是 $23$ 位的小数部分。储存在 $8$ 位指数域中的偏置指数是 $e = E + 127 = 16 + 127 = 143$。\n\n在这个范围内的数的精度由有效数的最低有效位的值决定。这被称为最后一位单位（Unit in the Last Place, ULP）。\n$$\\text{ULP} = 2^E \\times 2^{-23} = 2^{16} \\times 2^{-23} = 2^{-7}$$\n作为十进制数，ULP 是：\n$$\\text{ULP} = \\frac{1}{128} = 0.0078125$$\n在 $[2^{16}, 2^{17})$ 范围内的每个实数都会被映射到这个 ULP 值的最近倍数。\n\n**2. 将输入 `x` 转换为 binary32 格式**\n\n为了找到 $x = 123456.78$ 的 binary32 表示，我们将 $x$ 除以 ULP，以确定它最接近哪个倍数。\n$$\\frac{x}{\\text{ULP}} = \\frac{123456.78}{0.0078125} = 123456.78 \\times 128 = 15802467.84$$\n这个数字表示由 $2^{23}$ 缩放的有效数。根据“向最近舍入，偶数优先”规则，我们必须将其舍入到最近的整数。由于小数部分 $0.84$ 大于 $0.5$，我们向上舍入。\n$$N_x = \\text{round}(15802467.84) = 15802468$$\n$x$ 的储存值，我们称之为 $x_{b32}$，是 ULP 的这个整数倍。\n$$x_{b32} = N_x \\times \\text{ULP} = 15802468 \\times 0.0078125 = 123456.78125$$\n\n**3. 将输入 `y` 转换为 binary32 格式**\n\n我们对 $y = 123456.77$ 重复同样的过程。\n$$\\frac{y}{\\text{ULP}} = \\frac{123456.77}{0.0078125} = 123456.77 \\times 128 = 15802466.56$$\n小数部分 $0.56$ 大于 $0.5$，所以我们向上舍入。注意这里不是平局，所以规则中“偶数优先”的部分没有被触发。\n$$N_y = \\text{round}(15802466.56) = 15802467$$\n$y$ 的储存值，我们称之为 $y_{b32}$，是：\n$$y_{b32} = N_y \\times \\text{ULP} = 15802467 \\times 0.0078125 = 123456.7734375$$\n\n**4. 执行减法并确定最终结果**\n\n硬件对储存的表示 $x_{b32}$ 和 $y_{b32}$ 执行减法。这次减法的精确结果是：\n$$d = x_{b32} - y_{b32} = 123456.78125 - 123456.7734375 = 0.0078125$$\n最后一步是确保这个结果 $d$ 能被正确地储存在 binary32 寄存器中，这可能涉及到另一次舍入。我们必须检查 $d$ 是否可以被精确表示。\n$$d = 0.0078125 = \\frac{1}{128} = 2^{-7}$$\n这个值可以写成规格化浮点形式 $1.0_2 \\times 2^{-7}$。\n- 符号为正 ($s=0$)。\n- 有效数是 $1.0_2$，所以小数部分 $f$ 全为零。\n- 无偏指数是 $E = -7$。\n这个指数在规格化 binary32 数的有效范围 $[-126, 127]$ 内。由于该值是 2 的幂，因此它可以在二进制浮点格式中被精确表示。因此，最终结果不需要舍入。\n\n硬件返回的值是储存值相减的精确结果。", "answer": "$$\n\\boxed{0.0078125}\n$$", "id": "3642283"}]}