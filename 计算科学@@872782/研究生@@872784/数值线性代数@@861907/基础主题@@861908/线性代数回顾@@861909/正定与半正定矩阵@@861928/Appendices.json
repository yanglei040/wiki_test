{"hands_on_practices": [{"introduction": "对于对称矩阵，西尔维斯特准则（所有顺序主子式均为正）是判断其正定性的一个强大而便捷的工具。然而，这个准则中的对称性假设是至关重要的，绝不能忽略。本练习 [@problem_id:3566008] 将通过构造一个具体的反例，让您亲手验证一个非对称矩阵即使所有顺序主子式都为正，也未必是正定的，从而深刻理解正定性定义与判定准则之间的微妙关系。", "problem": "设 $A \\in \\mathbb{R}^{n \\times n}$，如果对于所有非零向量 $x \\in \\mathbb{R}^{n}$ 都有 $x^{\\top} A x  0$，则称矩阵 $A$ 为正定矩阵。对于对称矩阵，一个经过充分检验的事实（西尔维斯特判据）是，所有顺序主子式均为正数等价于矩阵的正定性。本题要求您仅从正定性的定义和标准的线性代数恒等式出发，通过显式构造和分析，说明该判据中对称性的必要性。\n\n考虑由 $t \\in \\mathbb{R}$ 给出的单参数实上三角矩阵族 $A_{t} \\in \\mathbb{R}^{3 \\times 3}$：\n$$\nA_{t} \\;=\\; \\begin{pmatrix}\n1  t  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix},\n$$\n\n任务：\n- 仅使用行列式和三角矩阵的基本性质，分析 $A_{t}$ 的顺序主子式，并确定它们的符号作为 $t$ 的函数。\n- 仅使用正定性的定义和恒等式\n$$\nx^{\\top} A x \\;=\\; x^{\\top} \\left( \\tfrac{A + A^{\\top}}{2} \\right) x \\quad \\text{for all } x \\in \\mathbb{R}^{n},\n$$\n确定使得 $A_{t}$ 非正定的、严格大于 $2$ 的最小整数 $t$。您的推理应明确说明为什么即使在所有顺序主子式均为正的情况下，非对称矩阵 $A_{t}$ 也可能不是正定的。\n- 使用该 $t$ 值和特定向量 $x_{0} = \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$，精确计算二次型 $q = x_{0}^{\\top} A_{t} x_{0}$。\n\n答案规格：\n- 您的最终答案应为 $q$ 的精确值，形式为一个不带单位的实数。\n- 无需四舍五入。", "solution": "该问题经评估是有效的，因为它在科学上基于线性代数，问题提出得当且有唯一答案，并且陈述客观。所有给出的定义和陈述都是标准且正确的。该问题构成了一个形式化的练习，用以展示数值线性代数中的一个关键理论点。\n\n按照要求，该问题分三部分进行解答。\n\n### 第一部分：顺序主子式分析\n\n给定的单参数矩阵族为\n$$\nA_{t} = \\begin{pmatrix}\n1  t  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n其中 $t \\in \\mathbb{R}$。顺序主子式是 $A_t$ 的顺序主子矩阵的行列式。我们将 $k \\times k$ 顺序主子式记为 $\\Delta_k$。\n\n第一个顺序主子式 $\\Delta_1$ 是 $1 \\times 1$ 左上角子矩阵的行列式：\n$$\n\\Delta_1 = \\det \\begin{pmatrix} 1 \\end{pmatrix} = 1\n$$\n\n第二个顺序主子式 $\\Delta_2$ 是 $2 \\times 2$ 左上角子矩阵的行列式：\n$$\n\\Delta_2 = \\det \\begin{pmatrix} 1  t \\\\ 0  1 \\end{pmatrix} = (1)(1) - (t)(0) = 1\n$$\n\n第三个顺序主子式 $\\Delta_3$ 是矩阵 $A_t$ 本身的行列式。由于 $A_t$ 是一个上三角矩阵，其行列式是其对角线元素的乘积：\n$$\n\\Delta_3 = \\det(A_t) = (1)(1)(1) = 1\n$$\n\n对于任意 $t \\in \\mathbb{R}$，所有三个顺序主子式都等于 $1$，这是一个正数。如果西尔维斯特判据适用于非对称矩阵，这将意味着对于所有 $t$，$A_t$ 都是正定的。\n\n### 第二部分：正定性条件\n\n根据定义，一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是正定的，如果对于所有非零向量 $x \\in \\mathbb{R}^{n}$，二次型 $x^{\\top} A x  0$。问题提供了恒等式 $x^{\\top} A x = x^{\\top} \\left( \\frac{A + A^{\\top}}{2} \\right) x$。矩阵 $S = \\frac{A + A^{\\top}}{2}$ 是 $A$ 的对称部分。这个恒等式表明，与任何方阵 $A$ 相关联的二次型都与其对称部分 $S$ 相关联的二次型相同。因此，一个矩阵 $A$ 是正定的，当且仅当其对称部分 $S$ 是正定的。\n\n对于给定的矩阵 $A_t$，其转置是\n$$\nA_{t}^{\\top} = \\begin{pmatrix}\n1  0  0 \\\\\nt  1  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n$A_t$ 的对称部分，我们记为 $S_t$，是：\n$$\nS_t = \\frac{A_t + A_t^{\\top}}{2} = \\frac{1}{2} \\left[ \\begin{pmatrix}\n1  t  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix} + \\begin{pmatrix}\n1  0  0 \\\\\nt  1  0 \\\\\n0  0  1\n\\end{pmatrix} \\right] = \\frac{1}{2} \\begin{pmatrix}\n2  t  0 \\\\\nt  2  0 \\\\\n0  0  2\n\\end{pmatrix} = \\begin{pmatrix}\n1  \\frac{t}{2}  0 \\\\\n\\frac{t}{2}  1  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n由于 $S_t$ 是一个对称矩阵，我们可以对其应用西尔维斯特判据，以确定它（并因此 $A_t$）是正定的条件。$S_t$ 的所有顺序主子式必须都为正。\n\n$S_t$ 的第一个顺序主子式是 $\\det(1) = 1  0$。\n\n$S_t$ 的第二个顺序主子式是：\n$$\n\\det \\begin{pmatrix} 1  \\frac{t}{2} \\\\ \\frac{t}{2}  1 \\end{pmatrix} = (1)(1) - \\left(\\frac{t}{2}\\right)\\left(\\frac{t}{2}\\right) = 1 - \\frac{t^2}{4}\n$$\n为使该式为正，我们必须有 $1 - \\frac{t^2}{4}  0$，这意味着 $t^2  4$，即 $-2  t  2$。\n\n$S_t$ 的第三个顺序主子式是 $\\det(S_t)$：\n$$\n\\det(S_t) = \\det \\begin{pmatrix} 1  \\frac{t}{2}  0 \\\\ \\frac{t}{2}  1  0 \\\\ 0  0  1 \\end{pmatrix} = (1) \\det \\begin{pmatrix} 1  \\frac{t}{2} \\\\ \\frac{t}{2}  1 \\end{pmatrix} = 1 - \\frac{t^2}{4}\n$$\n这得出了相同的条件，$-2  t  2$。\n\n因此，矩阵 $A_t$ 是正定的，当且仅当 $-2  t  2$。这明确地表明，尽管非对称矩阵 $A_t$ 的顺序主子式始终为正，但当 $|t| \\ge 2$ 时，该矩阵本身不是正定的。出现这种情况的原因是，该判据仅适用于对称矩阵，而非对称矩阵的正定性由其对称部分决定，而其对称部分的子式可能为非正数。\n\n题目要求我们找到使得 $A_t$ 非正定的、严格大于 $2$ 的最小整数 $t$。根据我们的分析，对于任何满足 $t \\ge 2$ 或 $t \\le -2$ 的 $t$，$A_t$ 都不是正定的。严格大于 $2$ 的整数是 $3, 4, 5, \\dots$。其中最小的是 $t=3$。\n\n### 第三部分：二次型的计算\n\n我们现在必须为 $t=3$ 和特定向量 $x_{0} = \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}$ 计算二次型 $q = x_{0}^{\\top} A_{t} x_{0}$。\n\n矩阵 $A_3$ 是：\n$$\nA_{3} = \\begin{pmatrix}\n1  3  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix}\n$$\n向量及其转置是：\n$$\nx_{0} = \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix}, \\quad x_{0}^{\\top} = \\begin{pmatrix} 1  -1  0 \\end{pmatrix}\n$$\n我们首先计算乘积 $A_3 x_0$：\n$$\nA_3 x_0 = \\begin{pmatrix}\n1  3  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{pmatrix} \\begin{pmatrix} 1 \\\\ -1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1(1) + 3(-1) + 0(0) \\\\ 0(1) + 1(-1) + 0(0) \\\\ 0(1) + 0(-1) + 1(0) \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ -1 \\\\ 0 \\end{pmatrix}\n$$\n现在，我们计算 $q$ 的最终值：\n$$\nq = x_{0}^{\\top} (A_3 x_0) = \\begin{pmatrix} 1  -1  0 \\end{pmatrix} \\begin{pmatrix} -2 \\\\ -1 \\\\ 0 \\end{pmatrix} = (1)(-2) + (-1)(-1) + (0)(0) = -2 + 1 + 0 = -1\n$$\n二次型的值是 $q=-1$。由于对于一个非零向量 $x_0$，我们有 $q  0$，这证实了矩阵 $A_3$ 不是正定的。", "answer": "$$\\boxed{-1}$$", "id": "3566008"}, {"introduction": "在许多应用中，我们希望在不进行昂贵的完整特征值计算的情况下，快速判断一个矩阵是否为正定。盖尔圆定理（Gershgorin Circle Theorem）为此提供了一个优雅而高效的分析工具，它能帮助我们估计特征值在复平面上的位置。在本练习 [@problem_id:3565998] 中，您将应用该定理于一个结构化的对称矩阵，不仅要证明其正定性，还要进一步推导出其谱条件数的上界，体验理论工具在数值估计中的威力。", "problem": "考虑实对称三对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其中 $n \\geq 3$，其元素定义如下：\n- $a_{11} = a_{nn} = 4$，\n- $a_{ii} = 6$ 对所有满足 $2 \\leq i \\leq n-1$ 的 $i$ 成立，\n- $a_{i,i+1} = a_{i+1,i} = -1$ 对所有满足 $1 \\leq i \\leq n-1$ 的 $i$ 成立，\n- 所有其他元素均为 $0$。\n\n仅使用数值线性代数的基本事实，包括正定性的定义、实对称矩阵的谱定理和盖尔什戈林圆盘定理（Gershgorin Circle Theorem），按以下步骤进行：\n1. 使用盖尔什戈林界（Gershgorin bounds）来证明 $A$ 是正定的。\n2. 从这些相同的界推导出谱条件数 $\\kappa_{2}(A)$ 的一个显式标量上界。\n\n将直接从 $A$ 的盖尔什戈林行界得到的关于 $\\kappa_{2}(A)$ 的最紧上界作为您的最终答案，以精确形式（不进行四舍五入）报告该单个实数。不要使用任何对角缩放或预处理。您的答案必须是一个精确的分数。不需要单位。", "solution": "问题首先是证明给定的实对称三对角矩阵 $A$ 是正定的，其次是推导其谱条件数 $\\kappa_2(A)$ 的一个上界。分析必须基于盖尔什戈林圆盘定理（Gershgorin Circle Theorem）。\n\n矩阵 $A \\in \\mathbb{R}^{n \\times n}$ (其中 $n \\geq 3$) 的非零元素定义如下：\n- 对角元素：$a_{11} = 4$， $a_{nn} = 4$，以及对 $2 \\leq i \\leq n-1$ 有 $a_{ii} = 6$。\n- 非对角元素：对 $1 \\leq i \\leq n-1$ 有 $a_{i,i+1} = a_{i+1,i} = -1$。\n所有其他元素均为 $0$。\n\n盖尔什戈林圆盘定理指出，矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 的每个特征值都位于复平面上至少一个盖尔什戈林圆盘 $G_i$ 内，其中对于每一行 $i=1, \\dots, n$，圆盘定义为：\n$$ G_i = \\{z \\in \\mathbb{C} : |z - a_{ii}| \\leq R_i\\}, \\quad \\text{其中 } R_i = \\sum_{j \\neq i} |a_{ij}| $$\n这些圆盘的并集 $G = \\bigcup_{i=1}^n G_i$ 包含了 $A$ 的整个谱，记为 $\\sigma(A)$。\n\n由于给定的矩阵 $A$ 是实对称的，实对称矩阵的谱定理保证其所有特征值 $\\lambda_j$ 都是实数。因此，这些特征值必须位于盖尔什戈林圆盘与实轴相交得到的实区间之并集中。我们来计算矩阵 $A$ 的中心 $a_{ii}$ 和半径 $R_i$。\n\n对于第一行 $i=1$：\n中心是 $a_{11}=4$。\n半径是 $R_1 = |a_{12}| = |-1| = 1$。\n对应的实数区间是 $[\\, a_{11} - R_1, a_{11} + R_1 \\,] = [\\, 4-1, 4+1 \\,] = [3, 5]$。\n\n对于内部行 $2 \\leq i \\leq n-1$：\n中心是 $a_{ii}=6$。\n半径是 $R_i = |a_{i,i-1}| + |a_{i,i+1}| = |-1| + |-1| = 2$。\n对应的实数区间是 $[\\, a_{ii} - R_i, a_{ii} + R_i \\,] = [\\, 6-2, 6+2 \\,] = [4, 8]$。\n\n对于最后一行 $i=n$：\n中心是 $a_{nn}=4$。\n半径是 $R_n = |a_{n,n-1}| = |-1| = 1$。\n对应的实数区间是 $[\\, a_{nn} - R_n, a_{nn} + R_n \\,] = [\\, 4-1, 4+1 \\,] = [3, 5]$。\n\n$A$ 的所有特征值的集合 $\\sigma(A)$ 必须包含在这些区间的并集内：\n$$ \\sigma(A) \\subseteq [3, 5] \\cup [4, 8] \\cup [3, 5] = [3, 8] $$\n\n1. 正定性的证明：\n一个实对称矩阵是正定的，当且仅当其所有特征值都严格为正。设 $\\lambda_{min}$ 是 $A$ 的最小特征值。根据盖尔什戈林分析，我们已经确定 $A$ 的所有特征值 $\\lambda$ 都必须满足 $3 \\leq \\lambda \\leq 8$。\n这意味着 $\\lambda_{min} \\geq 3$。因为 $3  0$，所以 $A$ 的所有特征值都严格为正。因此，矩阵 $A$ 是正定的。\n\n2. 谱条件数 $\\kappa_2(A)$ 的上界：\n矩阵 $A$ 的谱条件数定义为 $\\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2$。对于一个对称正定矩阵，这可以简化为其最大和最小特征值的比值：\n$$ \\kappa_2(A) = \\frac{\\lambda_{max}}{\\lambda_{min}} $$\n其中 $\\lambda_{max}$ 是 $A$ 的最大特征值，$\\lambda_{min}$ 是 $A$ 的最小特征值。\n\n盖尔什戈林圆盘定理提供了 $A$ 的谱的界。从包含关系 $\\sigma(A) \\subseteq [3, 8]$，我们可以推断出：\n- 最大特征值的上界：$\\lambda_{max} \\leq 8$。\n- 最小特征值的下界：$\\lambda_{min} \\geq 3$。\n\n使用这些界，我们可以建立条件数的一个上界：\n$$ \\kappa_2(A) = \\frac{\\lambda_{max}}{\\lambda_{min}} \\leq \\frac{\\text{upper bound on } \\lambda_{max}}{\\text{lower bound on } \\lambda_{min}} $$\n代入从盖尔什戈林行界推导出的值：\n$$ \\kappa_2(A) \\leq \\frac{8}{3} $$\n这是在不进行任何进一步变换的情况下，直接应用盖尔什戈林圆盘定理于 $A$ 的行所能得到的最紧上界。由于 $A$ 是对称的，基于列的盖尔什戈林界是相同的，并产生相同的结果。\n\n最终答案即为该上界的值。", "answer": "$$\n\\boxed{\\frac{8}{3}}\n$$", "id": "3565998"}, {"introduction": "理论上的正定矩阵在计算机的浮点运算环境中可能会因为舍入误差而表现出微小的负特征值，这在许多算法（如求逆或Cholesky分解）中会引发严重问题。为了确保数值稳定性，一种常见的策略是向矩阵对角线添加一个微小的正数（“抖动”或“Jittering”）。这个编程实践 [@problem_id:3566014] 直面这一现实挑战，要求您基于向后误差分析和威尔不等式，设计并实现一个算法来校准保证矩阵在数值上严格正定所需的最小“抖动”量 $\\delta$。", "problem": "设计并实现一个程序，对于每个给定的实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，校准一个最小的非负对角抖动 $\\delta$，以保证即使在因浮点舍入导致最小特征值存在不确定性的情况下，$A + \\delta I \\succ 0$ 仍然成立。推导和算法必须从以下基本基础出发：\n\n- 核心定义：\n  - 实对称矩阵 $A$ 是正定的，当且仅当其最小特征值 $\\lambda_{\\min}(A)$ 满足 $\\lambda_{\\min}(A) \\gt 0$。\n  - 谱范数为 $\\lVert A \\rVert_2 = \\max_{\\lVert x \\rVert_2 = 1} \\lVert A x \\rVert_2$，它等于最大的奇异值；对于实对称矩阵 $A$，$\\lVert A \\rVert_2 = \\max_i \\lvert \\lambda_i(A) \\rvert$。\n  - 当 $A$ 可逆时，谱条件数为 $\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2$（否则 $\\kappa_2(A) = +\\infty$）。\n  - 对于范数为 $\\lVert x \\rVert_2 = 1$ 的向量 $x$，瑞利商为 $x^\\top A x$，且 $\\lambda_{\\min}(A) = \\min_{\\lVert x \\rVert_2 = 1} x^\\top A x$。\n\n- 经过充分检验的扰动事实：\n  - 对于对称矩阵 $A$ 和任意对称扰动 $E$，Weyl 不等式指出，对于所有特征值 $\\lambda_i(\\cdot)$，都有 $\\lvert \\lambda_i(A + E) - \\lambda_i(A) \\rvert \\le \\lVert E \\rVert_2$。\n  - 标准对称特征值求解器的后向稳定性意味着，计算出的特征值是某个邻近矩阵 $\\widehat{A} = A + \\Delta A$ 的精确特征值，其范数界为 $\\lVert \\Delta A \\rVert_2 \\le \\gamma_n \\lVert A \\rVert_2$，其中 $\\gamma_n$ 与 $n u$ 成正比，$u$ 是单位舍入误差。\n\n按如下方式对最小特征值的不确定性进行建模。假设执行环境为 IEEE binary64 算术，单位舍入误差 $u = 2^{-53}$。采用以下保守的不确定性半径分解：\n- 范数后向误差界 $\\varepsilon_{\\text{back}} = c \\, n \\, u \\, \\lVert A \\rVert_2$，其中 $c = 10$ 是一个适中的常数。\n- 一个额外的条件敏感性裕度 $\\varepsilon_{\\text{cond}} = c' \\, n \\, u \\, \\kappa_2(A) \\, \\lVert A \\rVert_2$，用于在 $A$ 用于后续操作（其敏感性与 $\\kappa_2(A)$ 成比例）时保护决策边界，其中 $c' = 2$。如果 $A$ 被视为数值奇异（见下文的可逆性检验），则设置 $\\varepsilon_{\\text{cond}} = 0$。\n\n将总不确定性半径定义为 $\\varepsilon_{\\text{tot}} = \\varepsilon_{\\text{back}} + \\varepsilon_{\\text{cond}}$。使用 Weyl 不等式和瑞利商的特性，从 $\\lambda_{\\min}(A)$ 的浮点估计值得出一个可计算且有保证的下界，并由此确定最小的非负 $\\delta$，以保证对于谱范数最多为 $\\varepsilon_{\\text{tot}}$ 的所有 $A$ 的对称扰动，$A + \\delta I \\succ 0$ 成立。\n\n算法要求：\n- 使用 $A$ 的特征值计算 $\\lVert A \\rVert_2$ 和最小特征值的估计值 $\\widehat{\\lambda}_{\\min}(A)$（对对称矩阵 $A$ 有效）。\n- 使用准则 $\\min_i \\lvert \\lambda_i(A) \\rvert \\le \\tau_{\\text{sing}}$ 来判断构造 $\\kappa_2(A)$ 时的可逆性，其中 $\\tau_{\\text{sing}} = 100 \\, n \\, u \\, \\lVert A \\rVert_2$。如果此不等式成立，则将 $A$ 视为数值奇异，并设置 $\\kappa_2(A) = +\\infty$ 和 $\\varepsilon_{\\text{cond}} = 0$。否则，对于可逆的对称矩阵 $A$，使用 $\\kappa_2(A) = \\dfrac{\\max_i \\lvert \\lambda_i(A) \\rvert}{\\min_i \\lvert \\lambda_i(A) \\rvert}$。\n- 结合这些界限，生成最小的非负 $\\delta$，以保证上述意义下的严格正定性。\n\n测试套件：\n使用以下四个测试矩阵，每个矩阵以十进制条目的列表的列表形式提供。对于每个矩阵 $A^{(k)}$，使用固定的常数 $u = 2^{-53}$、$c = 10$、$c' = 2$ 以及上述可逆性阈值，计算模型所要求的 $\\delta^{(k)}$。\n\n- 案例 1（接近不定，微小负特征值）：\n  $$\n  A^{(1)} =\n  \\begin{bmatrix}\n  1.0  0.99 \\\\\n  0.99  0.98\n  \\end{bmatrix}.\n  $$\n- 案例 2（半正定，有零特征值）：\n  $$\n  A^{(2)} =\n  \\begin{bmatrix}\n  1.0  1.0 \\\\\n  1.0  1.0\n  \\end{bmatrix}.\n  $$\n- 案例 3（病态正定，最小特征值微小）：\n  $$\n  A^{(3)} =\n  \\begin{bmatrix}\n  10^{-12}  0  0 \\\\\n  0  1.0  0.999 \\\\\n  0  0.999  2.0\n  \\end{bmatrix}.\n  $$\n- 案例 4（良态正定）：\n  $$\n  A^{(4)} = 5.0 \\, I_3.\n  $$\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如：“[$r_1$,$r_2$,$r_3$,$r_4$]”。\n- 每个 $r_k$ 必须是对应于上述顺序中相应矩阵 $A^{(k)}$ 的校准 $\\delta^{(k)}$ 的浮点十进制数。\n\n无需用户输入；所有数据和常数必须严格按照规定硬编码。", "solution": "该问题被认为是有效的，因为它在数值线性代数方面有科学依据，问题定义明确、客观，并且自成一体，提供了所有必要的数据和常数。\n\n目标是找到最小的非负对角抖动 $\\delta \\ge 0$，使得在面临两种不确定性来源（特征值计算的内在后向误差和为扰动指定的裕度）时，矩阵 $A + \\delta I$ 保证是严格正定的 ($A + \\delta I \\succ 0$)。矩阵 $M$ 是正定的，当且仅当其最小特征值 $\\lambda_{\\min}(M)$ 严格为正。\n\n问题陈述我们必须保证对于 $A$ 的所有对称扰动 $E$（其中扰动的谱范数受总不确定性半径限制，即 $\\lVert E \\rVert_2 \\le \\varepsilon_{\\text{tot}}$），矩阵是正定的。这意味着我们需要矩阵 $(A+E) + \\delta I$ 对于所有这样的 $E$ 都是正定的。\n\n使用最小特征值的瑞利商表征，矩阵 $M$ 是正定的，当且仅当对于所有非零向量 $x \\in \\mathbb{R}^n$，$x^\\top M x  0$。我们将此应用于 $(A+E) + \\delta I$：\n$$x^\\top (A+E+\\delta I) x  0$$\n除以 $\\lVert x \\rVert_2^2$ 并只考虑单位向量（$ \\lVert x \\rVert_2 = 1 $），这等价于：\n$$x^\\top A x + x^\\top E x + \\delta  0$$\n这个不等式必须对所有单位向量 $x$ 和所有谱范数 $\\lVert E \\rVert_2 \\le \\varepsilon_{\\text{tot}}$ 的对称扰动 $E$ 成立。为了保证这一点，我们必须确保它在使左侧最小化的最坏情况下的 $x$ 和 $E$ 选择下成立。\n$$ \\min_{\\lVert x \\rVert_2=1, \\lVert E \\rVert_2 \\le \\varepsilon_{\\text{tot}}} (x^\\top A x + x^\\top E x) + \\delta  0 $$\n项 $x^\\top E x$ 是 $E$ 的瑞利商。其值受 $E$ 的特征值限制：$\\lambda_{\\min}(E) \\le x^\\top E x \\le \\lambda_{\\max}(E)$。由于 $\\lVert E \\rVert_2 = \\max(|\\lambda_{\\min}(E)|, |\\lambda_{\\max}(E)|)$， $E$ 的任意特征值的最小可能值为 $-\\varepsilon_{\\text{tot}}$。$x^\\top E x$ 的这个最小值可以通过选择 $x$ 为对应于 $\\lambda_{\\min}(E)$ 的特征向量，并选择一个 $E$（例如，$E = -\\varepsilon_{\\text{tot}} x x^\\top$）使得 $\\lambda_{\\min}(E) = -\\varepsilon_{\\text{tot}}$ 来达到。因此，$\\min_{\\lVert E \\rVert_2 \\le \\varepsilon_{\\text{tot}}} x^\\top E x = -\\varepsilon_{\\text{tot}}$。\n\n代入这个最小值，我们的条件变为：\n$$ \\min_{\\lVert x \\rVert_2=1} (x^\\top A x - \\varepsilon_{\\text{tot}}) + \\delta  0 $$\n$$ \\left( \\min_{\\lVert x \\rVert_2=1} x^\\top A x \\right) - \\varepsilon_{\\text{tot}} + \\delta  0 $$\n根据定义，$\\lambda_{\\min}(A) = \\min_{\\lVert x \\rVert_2=1} x^\\top A x$。所以，对 $\\delta$ 的条件是：\n$$ \\lambda_{\\min}(A) - \\varepsilon_{\\text{tot}} + \\delta  0 \\implies \\delta  \\varepsilon_{\\text{tot}} - \\lambda_{\\min}(A) $$\n这个不等式涉及真实、精确的最小特征值 $\\lambda_{\\min}(A)$，而这是未知的。我们只能访问它的浮点估计值，我们记为 $\\widehat{\\lambda}_{\\min}(A)$。问题提供了一个基于标准对称特征值求解器后向稳定性的该估计值不确定性的模型。计算出的特征值是某个邻近矩阵 $A + \\Delta A$ 的精确特征值，其中扰动 $\\Delta A$ 的范数有界，$\\lVert \\Delta A \\rVert_2 \\le \\varepsilon_{\\text{back}}$。这里，$\\varepsilon_{\\text{back}} = c \\, n \\, u \\, \\lVert A \\rVert_2$。\n所以，$\\widehat{\\lambda}_{\\min}(A) = \\lambda_{\\min}(A + \\Delta A)$。根据 Weyl 不等式：\n$$ \\lvert \\lambda_{\\min}(A) - \\lambda_{\\min}(A + \\Delta A) \\rvert \\le \\lVert \\Delta A \\rVert_2 \\le \\varepsilon_{\\text{back}} $$\n$$ \\lvert \\lambda_{\\min}(A) - \\widehat{\\lambda}_{\\min}(A) \\rvert \\le \\varepsilon_{\\text{back}} $$\n这为我们提供了真实最小特征值的一个有保证的下界，用计算出的值表示：\n$$ \\lambda_{\\min}(A) \\ge \\widehat{\\lambda}_{\\min}(A) - \\varepsilon_{\\text{back}} $$\n为了稳健地满足条件 $\\delta  \\varepsilon_{\\text{tot}} - \\lambda_{\\min}(A)$，我们必须使其对于 $\\lambda_{\\min}(A)$ 的最坏情况（最小）可能值成立。代入其下界：\n$$ \\delta  \\varepsilon_{\\text{tot}} - (\\widehat{\\lambda}_{\\min}(A) - \\varepsilon_{\\text{back}}) $$\n总不确定性 $\\varepsilon_{\\text{tot}}$ 被定义为后向误差和条件敏感性裕度之和：$\\varepsilon_{\\text{tot}} = \\varepsilon_{\\text{back}} + \\varepsilon_{\\text{cond}}$。将其代入不等式：\n$$ \\delta  (\\varepsilon_{\\text{back}} + \\varepsilon_{\\text{cond}}) - \\widehat{\\lambda}_{\\min}(A) + \\varepsilon_{\\text{back}} $$\n$$ \\delta  2\\varepsilon_{\\text{back}} + \\varepsilon_{\\text{cond}} - \\widehat{\\lambda}_{\\min}(A) $$\n我们寻求满足此严格不等式的最小非负 $\\delta$。这导出了公式：\n$$ \\delta = \\max \\left(0, 2\\varepsilon_{\\text{back}} + \\varepsilon_{\\text{cond}} - \\widehat{\\lambda}_{\\min}(A) \\right) $$\n\n完整的算法如下：\n1.  对于给定的对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，使用标准的数值特征值求解器计算其特征值 $\\{\\widehat{\\lambda}_i\\}$。\n2.  根据计算出的特征值，确定估计的最小特征值 $\\widehat{\\lambda}_{\\min}(A) = \\min_i \\widehat{\\lambda}_i$ 和估计的谱范数 $\\widehat{\\lVert A \\rVert_2} = \\max_i \\lvert \\widehat{\\lambda}_i \\rvert$。\n3.  计算范数后向误差界：$\\varepsilon_{\\text{back}} = c \\, n \\, u \\, \\widehat{\\lVert A \\rVert_2}$，其中 $c=10$，$n$ 是矩阵维度，$u=2^{-53}$ 是单位舍入误差。\n4.  检验数值奇异性。如果 $\\min_i \\lvert \\widehat{\\lambda}_i \\rvert \\le \\tau_{\\text{sing}}$，则认为矩阵是数值奇异的，其中阈值为 $\\tau_{\\text{sing}} = 100 \\, n \\, u \\, \\widehat{\\lVert A \\rVert_2}$。\n5.  计算条件敏感性裕度 $\\varepsilon_{\\text{cond}}$。\n    - 如果矩阵是数值奇异的，则设置 $\\varepsilon_{\\text{cond}} = 0$。\n    - 否则，计算估计的谱条件数 $\\widehat{\\kappa}_2(A) = \\dfrac{\\max_i \\lvert \\widehat{\\lambda}_i \\rvert}{\\min_i \\lvert \\widehat{\\lambda}_i \\rvert} = \\dfrac{\\widehat{\\lVert A \\rVert_2}}{\\min_i \\lvert \\widehat{\\lambda}_i \\rvert}$。然后，$\\varepsilon_{\\text{cond}} = c' \\, n \\, u \\, \\widehat{\\kappa}_2(A) \\, \\widehat{\\lVert A \\rVert_2}$，其中 $c'=2$。\n6.  最后，使用推导出的公式计算所需的抖动 $\\delta$：$\\delta = \\max(0, 2\\varepsilon_{\\text{back}} + \\varepsilon_{\\text{cond}} - \\widehat{\\lambda}_{\\min}(A))$。\n该过程应用于每个测试矩阵。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to calculate the diagonal jitter for each test case.\n    \"\"\"\n    \n    # Define constants as specified in the problem statement.\n    u = 2**-53  # Unit roundoff for IEEE binary64\n    c = 10      # Constant for backward error\n    c_prime = 2 # Constant for condition-sensitivity margin\n    k_tau = 100   # Constant for singularity threshold\n\n    test_cases = [\n        # Case 1: nearly indefinite, tiny negative eigenvalue\n        np.array([\n            [1.0, 0.99],\n            [0.99, 0.98]\n        ]),\n        # Case 2: positive semidefinite with zero eigenvalue\n        np.array([\n            [1.0, 1.0],\n            [1.0, 1.0]\n        ]),\n        # Case 3: ill-conditioned positive definite, tiny smallest eigenvalue\n        np.array([\n            [1e-12, 0.0, 0.0],\n            [0.0, 1.0, 0.999],\n            [0.0, 0.999, 2.0]\n        ]),\n        # Case 4: well-conditioned positive definite\n        np.array([\n            [5.0, 0.0, 0.0],\n            [0.0, 5.0, 0.0],\n            [0.0, 0.0, 5.0]\n        ])\n    ]\n\n    def calculate_delta(A: np.ndarray) - float:\n        \"\"\"\n        Calculates the smallest non-negative diagonal jitter delta for a given matrix A.\n        \"\"\"\n        n = A.shape[0]\n\n        # Step 1  2: Compute eigenvalues and derived quantities.\n        # Use eigh for symmetric matrices. It returns eigenvalues in ascending order.\n        eigvals = np.linalg.eigh(A)[0]\n        \n        lambda_min_hat = eigvals[0]\n        norm_A_2_hat = np.max(np.abs(eigvals))\n        min_abs_lambda = np.min(np.abs(eigvals))\n\n        # Step 3: Calculate backward error bound.\n        eps_back = c * n * u * norm_A_2_hat\n        \n        # Step 4: Test for numerical singularity.\n        tau_sing = k_tau * n * u * norm_A_2_hat\n        is_singular = min_abs_lambda = tau_sing\n        \n        # Step 5: Calculate condition-sensitivity margin.\n        if is_singular:\n            eps_cond = 0.0\n        else:\n            # Note: For non-singular symmetric A, kappa_2(A) calculation is based on eigenvalues.\n            # Using norm_A_2_hat / min_abs_lambda directly avoids recomputing norms.\n            kappa_2_hat = norm_A_2_hat / min_abs_lambda\n            eps_cond = c_prime * n * u * kappa_2_hat * norm_A_2_hat\n\n        # Step 6: Combine bounds to produce the final delta.\n        delta_raw = 2 * eps_back + eps_cond - lambda_min_hat\n        delta = max(0.0, delta_raw)\n        \n        return delta\n\n    results = []\n    for A in test_cases:\n        delta_k = calculate_delta(A)\n        results.append(delta_k)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3566014"}]}