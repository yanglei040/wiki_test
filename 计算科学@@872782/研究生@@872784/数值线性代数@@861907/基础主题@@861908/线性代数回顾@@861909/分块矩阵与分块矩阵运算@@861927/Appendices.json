{"hands_on_practices": [{"introduction": "许多大规模科学计算问题产生的矩阵具有特殊的块结构，例如块双对角矩阵。本练习旨在通过从第一性原理推导求解过程（块前向/后向替换）并分析其计算成本，来培养设计高效数值算法的关键技能。这不仅是理论上的推导，更是理解如何将一个大问题分解为一系列更小、可管理子问题的核心实践。[@problem_id:3535162]", "problem": "设 $p \\in \\mathbb{N}$，考虑一个分块下双对角矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其中 $n = \\sum_{i=1}^{p} n_i$。每个对角块 $A_i \\in \\mathbb{R}^{n_i \\times n_i}$ 是方阵且非奇异，每个次对角块 $B_{i} \\in \\mathbb{R}^{n_{i+1} \\times n_{i}}$ 对于 $i = 1, \\dots, p-1$ 是任意的稠密矩阵。矩阵 $A$ 的分块结构如下：\n$$\nA \\;=\\;\n\\begin{pmatrix}\nA_1 & 0 & \\cdots & \\cdots & 0 \\\\\nB_1 & A_2 & 0 & & \\vdots \\\\\n0 & B_2 & A_3 & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & 0 \\\\\n0 & \\cdots & 0 & B_{p-1} & A_p\n\\end{pmatrix},\n$$\n我们希望求解分块线性系统 $A x = b$，其中 $x = \\begin{pmatrix} x_1^{\\top} & \\cdots & x_p^{\\top} \\end{pmatrix}^{\\top}$ 且 $b = \\begin{pmatrix} b_1^{\\top} & \\cdots & b_p^{\\top} \\end{pmatrix}^{\\top}$，$x_i, b_i \\in \\mathbb{R}^{n_i}$。\n\n1. 仅使用分块划分和矩阵向量乘法的定义，推导求解 $A x = b$ 的关于 $x_i$ 的前向代入递推关系，过程中不形成 $A^{-1}$。\n\n2. 假设每个稠密块 $A_i$ 的求解是通过首先计算 $A_i$ 的无主元选取的 LU 分解，然后进行前向代入和回代来将 $A_i^{-1}$ 应用于单个右端项。采用以下计算成本模型：将一次浮点加法或乘法计为一次浮点运算（flop），忽略除法和比较的成本。从第一性原理出发，推导出一个以分块大小 $n_1, \\dots, n_p$ 表示的计算 $x$ 所需总浮点运算次数的精确表达式。\n\n3. 反之，考虑一个具有相同对角块 $A_i \\in \\mathbb{R}^{n_i \\times n_i}$ 和任意稠密超对角块 $C_i \\in \\mathbb{R}^{n_i \\times n_{i+1}}$ 的上分块双对角系统，并推导求解 $A x = b$ 的回代递推关系。除所述的分块位置外，不作任何特殊结构假设。\n\n你的最终答案必须是问题2所要求的浮点运算界的一个单一闭式解析表达式，且仅用 $n_1, \\dots, n_p$ 表示。最终答案中不要提供中间步骤。", "solution": "所述问题在科学上是合理的、适定的、客观的、完整的且一致的。它代表了数值线性代数中的一个标准分析。因此，该问题是有效的，并将提供解答。\n\n该问题由三部分组成。我们将按顺序解决它们。\n\n**第一部分：分块下双对角系统的前向代入递推**\n\n给定分块线性系统 $A x = b$，其中 $A$ 是一个分块下双对角矩阵，形式如下：\n$$\nA \\;=\\;\n\\begin{pmatrix}\nA_1 & 0 & \\cdots & 0 \\\\\nB_1 & A_2 & 0 & \\cdots & 0 \\\\\n0 & B_2 & A_3 & & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & 0 \\\\\n0 & \\cdots & 0 & B_{p-1} & A_p\n\\end{pmatrix}\n$$\n向量 $x$ 和 $b$ 与 $A$ 的分块方式相对应：\n$$\nx = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_p \\end{pmatrix}, \\quad b = \\begin{pmatrix} b_1 \\\\ b_2 \\\\ \\vdots \\\\ b_p \\end{pmatrix}\n$$\n其中 $A_i \\in \\mathbb{R}^{n_i \\times n_i}$，$B_i \\in \\mathbb{R}^{n_{i+1} \\times n_i}$，$x_i, b_i \\in \\mathbb{R}^{n_i}$，且 $n = \\sum_{i=1}^{p} n_i$。\n\n通过执行分块矩阵向量乘法 $A x$，我们得到一个分块方程组：\n\\begin{align*}\nA_1 x_1 = b_1 \\\\\nB_1 x_1 + A_2 x_2 = b_2 \\\\\nB_2 x_2 + A_3 x_3 = b_3 \\\\\n\\vdots \\\\\nB_{i-1} x_{i-1} + A_i x_i = b_i \\\\\n\\vdots \\\\\nB_{p-1} x_{p-1} + A_p x_p = b_p\n\\end{align*}\n\n该系统呈现出顺序依赖关系，允许使用前向代入过程求解分块向量 $x_i$。\n\n从第一个方程开始，由于 $A_1$ 是非奇异的，我们可以解出 $x_1$：\n$$ x_1 = A_1^{-1} b_1 $$\n\n利用 $x_1$ 的结果，我们将其代入第二个方程求解 $x_2$：\n$$ B_1 x_1 + A_2 x_2 = b_2 \\implies A_2 x_2 = b_2 - B_1 x_1 $$\n由于 $A_2$ 是非奇异的，我们有：\n$$ x_2 = A_2^{-1} (b_2 - B_1 x_1) $$\n\n这个模式继续下去。假设 $x_1, x_2, \\dots, x_{i-1}$ 已知，我们可以使用第 $i$ 个方程求解 $x_i$：\n$$ B_{i-1} x_{i-1} + A_i x_i = b_i \\implies A_i x_i = b_i - B_{i-1} x_{i-1} $$\n由于对于所有 $i=1, \\dots, p$，$A_i$ 都是非奇异的，我们可以写出 $x_i$ 的一般递推关系：\n$$ x_i = A_i^{-1} (b_i - B_{i-1} x_{i-1}) \\quad \\text{for } i=2, \\dots, p $$\n\n完整的前向代入递推关系为：\n1.  计算 $x_1 = A_1^{-1} b_1$。\n2.  对于 $i = 2, \\dots, p$，计算 $x_i = A_i^{-1} (b_i - B_{i-1} x_{i-1})$。\n\n**第二部分：浮点运算次数分析**\n\n我们根据第一部分中的递推关系，并遵循指定的成本模型（加法/乘法=1 flop，除法/比较免费），推导求解该系统所需的总浮点运算（flops）次数的表达式。这需要从第一性原理出发，推导组成运算的浮点运算次数。\n\n**基本操作成本：**\n设 $M$ 是一个稠密的 $m \\times m$ 矩阵。\n1.  **$M$ 的 LU 分解（无主元选取）：** 分解过程分 $m-1$ 步进行。在第 $k$ 步（$k=1, \\dots, m-1$），我们更新一个 $(m-k) \\times (m-k)$ 的子矩阵。$(m-k)^2$ 个元素中的每一个都通过一次乘法和一次减法进行更新（$M_{ij} \\leftarrow M_{ij} - L_{ik} M_{kj}$）。这需要 $2(m-k)^2$ 次浮点运算。计算乘子 $L_{ik}$ 的除法被忽略。总浮点运算次数为：\n    $$ F_{LU}(m) = \\sum_{k=1}^{m-1} 2(m-k)^2 = 2 \\sum_{j=1}^{m-1} j^2 = 2 \\frac{(m-1)m(2m-1)}{6} = \\frac{m(m-1)(2m-1)}{3} = \\frac{2m^3 - 3m^2 + m}{3} $$\n2.  **前向代入（$Ly=c$）：** 对于单位下三角矩阵 $L$，$y_i = c_i - \\sum_{j=1}^{i-1} L_{ij} y_j$。对于每个 $i=2, \\dots, m$，这涉及到 $i-1$ 次乘法和 $i-1$ 次加/减法。总浮点运算次数为：\n    $$ F_{FS}(m) = \\sum_{i=2}^{m} 2(i-1) = 2 \\sum_{j=1}^{m-1} j = 2 \\frac{(m-1)m}{2} = m(m-1) = m^2-m $$\n3.  **回代（$Ux=y$）：** 对于上三角矩阵 $U$，$x_i = (y_i - \\sum_{j=i+1}^{m} U_{ij} x_j)/U_{ii}$。对于每个 $i=m-1, \\dots, 1$，这涉及到 $m-i$ 次乘法和 $m-i$ 次减法。被 $U_{ii}$ 除的操作被忽略。总浮点运算次数为：\n    $$ F_{BS}(m) = \\sum_{i=1}^{m-1} 2(m-i) = 2 \\sum_{j=1}^{m-1} j = m(m-1) = m^2-m $$\n4.  **矩阵向量乘积（$z=Qv$）：** 设 $Q$ 是 $m \\times k$ 矩阵，$v$ 是 $k \\times 1$ 向量。每个元素 $z_i = \\sum_{j=1}^{k} Q_{ij} v_j$ 需要 $k$ 次乘法和 $k-1$ 次加法。单个元素的总浮点运算次数是 $2k-1$。对于 $z$ 的所有 $m$ 个元素，总次数为：\n    $$ F_{MV}(m, k) = m(2k-1) $$\n5.  **向量减法（$u-w$）：** 对于 $u, w \\in \\mathbb{R}^m$，这需要 $m$ 次浮点运算。\n\n**总浮点运算次数推导：**\n前向代入算法包含一系列针对 $i=1, \\dots, p$ 的步骤。\n\n对于 $i=1$：我们求解 $A_1 x_1 = b_1$。成本包括 $A_1$ 的 LU 分解以及随后的前向代入和回代。\n$$\n\\text{Cost(1)} = F_{LU}(n_1) + F_{FS}(n_1) + F_{BS}(n_1) = \\frac{n_1(n_1-1)(2n_1-1)}{3} + n_1(n_1-1) + n_1(n_1-1)\n$$\n$$\n\\text{Cost(1)} = n_1(n_1-1)\\left(\\frac{2n_1-1}{3} + 2\\right) = \\frac{n_1(n_1-1)(2n_1+5)}{3} = \\frac{2n_1^3+3n_1^2-5n_1}{3}\n$$\n\n对于 $i=2, \\dots, p$：我们计算 $x_i = A_i^{-1}(b_i - B_{i-1}x_{i-1})$。这可分解为：\n(a) 计算矩阵向量乘积 $v = B_{i-1} x_{i-1}$。这里，$B_{i-1}$ 是 $n_i \\times n_{i-1}$。\n    成本：$F_{MV}(n_i, n_{i-1}) = n_i(2n_{i-1}-1)$ 次浮点运算。\n(b) 计算更新后的右端项 $\\tilde{b}_i = b_i - v$。这是一个向量减法。\n    成本：$n_i$ 次浮点运算。\n(c) 求解系统 $A_i x_i = \\tilde{b}_i$。成本与 $i=1$ 的情况形式相同。\n    成本：$F_{LU}(n_i) + F_{FS}(n_i) + F_{BS}(n_i) = \\frac{2n_i^3+3n_i^2-5n_i}{3}$ 次浮点运算。\n\n第 $i$ 步（其中 $i \\ge 2$）的总成本是这些成本的总和：\n$$\n\\text{Cost(i)} = \\left(n_i(2n_{i-1}-1) + n_i\\right) + \\frac{2n_i^3+3n_i^2-5n_i}{3} = 2n_i n_{i-1} + \\frac{2n_i^3+3n_i^2-5n_i}{3}\n$$\n\n总浮点运算次数是所有步骤成本的总和：\n$$ F = \\text{Cost(1)} + \\sum_{i=2}^{p} \\text{Cost(i)} $$\n$$ F = \\left(\\frac{2n_1^3+3n_1^2-5n_1}{3}\\right) + \\sum_{i=2}^{p} \\left(2n_i n_{i-1} + \\frac{2n_i^3+3n_i^2-5n_i}{3}\\right) $$\n我们可以将各项分组：\n$$ F = \\sum_{i=1}^{p} \\left(\\frac{2n_i^3+3n_i^2-5n_i}{3}\\right) + \\sum_{i=2}^{p} (2n_i n_{i-1}) $$\n对第二项求和重新索引得到最终表达式：\n$$ F = \\frac{1}{3}\\sum_{i=1}^{p} (2n_i^3 + 3n_i^2 - 5n_i) + 2\\sum_{i=1}^{p-1} n_{i+1} n_i $$\n在指定的模型和稠密分块的条件下，这是浮点运算次数的精确表达式，而不是一个上界。\n\n**第三部分：分块上双对角系统的回代递推**\n\n现在考虑一个上分块双对角矩阵 $A$：\n$$\nA \\;=\\;\n\\begin{pmatrix}\nA_1 & C_1 & 0 & \\cdots & 0 \\\\\n0 & A_2 & C_2 & & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & 0 \\\\\n0 & \\cdots & 0 & A_{p-1} & C_{p-1} \\\\\n0 & \\cdots & \\cdots & 0 & A_p\n\\end{pmatrix}\n$$\n其中 $C_i \\in \\mathbb{R}^{n_i \\times n_{i+1}}$。系统 $A x = b$ 展开为：\n\\begin{align*}\nA_1 x_1 + C_1 x_2 = b_1 \\\\\nA_2 x_2 + C_2 x_3 = b_2 \\\\\n\\vdots \\\\\nA_i x_i + C_i x_{i+1} = b_i \\\\\n\\vdots \\\\\nA_{p-1} x_{p-1} + C_{p-1} x_p = b_{p-1} \\\\\nA_p x_p = b_p\n\\end{align*}\n\n这种结构表明可以采用一种回代过程，从最后一个分块方程开始，向上进行。\n\n从最后一个方程开始，由于 $A_p$ 是非奇异的，我们解出 $x_p$：\n$$ x_p = A_p^{-1} b_p $$\n\n利用 $x_p$ 的结果，我们将其代入第 $(p-1)$ 个方程求解 $x_{p-1}$：\n$$ A_{p-1} x_{p-1} + C_{p-1} x_p = b_{p-1} \\implies A_{p-1} x_{p-1} = b_{p-1} - C_{p-1} x_p $$\n由于 $A_{p-1}$ 是非奇异的，我们有：\n$$ x_{p-1} = A_{p-1}^{-1} (b_{p-1} - C_{p-1} x_p) $$\n\n这就揭示了一般模式。假设 $x_{p}, x_{p-1}, \\dots, x_{i+1}$ 已知，我们可以使用第 $i$ 个方程求解 $x_i$：\n$$ A_i x_i + C_i x_{i+1} = b_i \\implies A_i x_i = b_i - C_i x_{i+1} $$\n由于 $A_i$ 是非奇异的，一般递推关系为：\n$$ x_i = A_i^{-1} (b_i - C_i x_{i+1}) \\quad \\text{for } i=p-1, \\dots, 1 $$\n\n完整的回代递推关系为：\n1.  计算 $x_p = A_p^{-1} b_p$。\n2.  对于 $i = p-1$ 到 $1$，计算 $x_i = A_i^{-1} (b_i - C_i x_{i+1})$。", "answer": "$$\n\\boxed{\\frac{1}{3}\\sum_{i=1}^{p} (2n_i^3 + 3n_i^2 - 5n_i) + 2\\sum_{i=1}^{p-1} n_{i+1} n_i}\n$$", "id": "3535162"}, {"introduction": "矩阵的最优块结构有时并非一目了然。本练习将探讨矩阵可约性与其关联有向图结构之间的深刻联系。通过识别图的强连通分量，您可以对矩阵进行重排，将其转化为块三角形式，从而极大地简化其分解和求解过程。这个练习展示了一种更高层次的优化策略，揭示了如何利用图论的洞察力来加速线性代数计算。[@problem_id:3535135]", "problem": "设 $A \\in \\mathbb{R}^{6 \\times 6}$ 是一个依赖于小参数 $\\varepsilon > 0$ 的稀疏矩阵，\n$$\nA \\;=\\;\n\\begin{pmatrix}\n4 & \\varepsilon & 1 & 0 & 2\\varepsilon & 0 \\\\\n0 & 5 & 0 & 1 & 0 & 0 \\\\\n1 & 0 & 3 & \\varepsilon & 0 & 3\\varepsilon \\\\\n0 & 1 & 0 & 6 & 2 & 0 \\\\\n0 & 0 & 0 & 2 & 7 & 3 \\\\\n0 & 0 & 0 & 0 & 3 & 8\n\\end{pmatrix}.\n$$\n该矩阵通过以下规则编码一个有向图：当且仅当 $A_{ij} \\neq 0$ 时，存在一条有向边 $i \\to j$。考虑将此有向图分解为强连通分量，并将其收缩为一个有向无环图 (DAG)，该图是通过将每个强连通分量收缩为单个顶点，并保留由原图的边所导出的分量之间的边而得到的。\n\n- 仅使用矩阵的有向图、强连通分量和图收缩产生的有向无环图的定义，推导关于 $A$ 的稀疏模式的充分必要条件，使得存在一个置换矩阵 $P$ 使得 $P A P^{\\top}$ 为块上三角矩阵。通过收缩 DAG 来解释这些条件。\n\n- 对于上述特定矩阵 $A$，找出其有向图的强连通分量，构造一个明确的置换矩阵 $P$ 使得 $P A P^{\\top}$ 为块上三角矩阵，并展示其块结构\n$$\nP A P^{\\top} \\;=\\;\n\\begin{pmatrix}\nB & E \\\\\n0 & C\n\\end{pmatrix},\n$$\n其中 $B \\in \\mathbb{R}^{2 \\times 2}$， $C \\in \\mathbb{R}^{4 \\times 4}$，以及 $E \\in \\mathbb{R}^{2 \\times 4}$。\n\n- 在数值线性代数中，人们经常比较不同分解策略的运算量。考虑两种分解 $A$ 的策略：一种是对完整的 $6 \\times 6$ 矩阵进行稠密高斯消去法，另一种是块策略，对于一个耦合量级最多为 $\\varepsilon$ 的近可约矩阵，该策略对对角块 $B$ 和 $C$ 进行独立的稠密分解，并在一阶上忽略严格上三角块 $E$。使用经过充分检验的稠密 LU 分解的浮点运算次数（flop）公式，计算在 $\\varepsilon \\to 0$ 极限下，主阶浮点运算量缩减因子 $R$，定义为\n$$\nR \\;=\\; \\frac{\\text{$B$ 和 $C$ 的块对角分解的浮点运算次数}}{\\text{$A$ 的稠密 LU 分解的浮点运算次数}}。\n$$\n将 $R$ 表示为一个精确的数值。无需四舍五入。", "solution": "首先根据指定标准验证问题。\n\n### 第 1 步：提取已知条件\n-   一个依赖于小参数 $\\varepsilon > 0$ 的稀疏矩阵 $A \\in \\mathbb{R}^{6 \\times 6}$：\n$$\nA \\;=\\;\n\\begin{pmatrix}\n4 & \\varepsilon & 1 & 0 & 2\\varepsilon & 0 \\\\\n0 & 5 & 0 & 1 & 0 & 0 \\\\\n1 & 0 & 3 & \\varepsilon & 0 & 3\\varepsilon \\\\\n0 & 1 & 0 & 6 & 2 & 0 \\\\\n0 & 0 & 0 & 2 & 7 & 3 \\\\\n0 & 0 & 0 & 0 & 3 & 8\n\\end{pmatrix}.\n$$\n-   有向图构造规则：当且仅当 $A_{ij} \\neq 0$ 时，存在一条边 $i \\to j$。\n-   待使用的概念：强连通分量 (SCCs)，收缩为有向无环图 (DAG)。\n-   任务 1：推导 $A$ 的稀疏模式需满足的充分必要条件，使得存在一个置换矩阵 $P$ 使得 $P A P^{\\top}$ 为块上三角矩阵，并通过收缩 DAG 解释这些条件。\n-   任务 2：对于给定矩阵 $A$，找出其强连通分量，构造一个明确的置换矩阵 $P$，并展示其块结构 $P A P^{\\top} = \\begin{pmatrix} B & E \\\\ 0 & C \\end{pmatrix}$，其中 $B \\in \\mathbb{R}^{2 \\times 2}$，$C \\in \\mathbb{R}^{4 \\times 4}$，$E \\in \\mathbb{R}^{2 \\times 4}$。\n-   任务 3：计算主阶浮点运算量缩减因子 $R$，定义为对角块 $B$ 和 $C$ 的块对角分解的浮点运算次数与对完整矩阵 $A$ 进行稠密 LU 分解的浮点运算次数之比。一个 $n \\times n$ 矩阵的稠密 LU 分解的浮点运算次数公式取为 $\\frac{2}{3}n^3$。\n\n### 第 2 步：使用提取的已知条件进行验证\n-   **科学基础**：该问题基于数值线性代数和图论中公认的原理，包括矩阵-图对偶性、强连通性以及像 LU 分解这类算法的复杂度分析。所有概念都是标准的、科学上合理的。\n-   **适定性**：问题陈述清晰，结构合理。每个任务都要求一个具体的、可推导的结果。所提供的数据足以完成所有任务。\n-   **客观性**：问题以精确、形式化的数学语言陈述，没有任何主观性或模糊性。\n\n### 第 3 步：结论与行动\n问题被判定为**有效**。将提供完整解答。\n\n### 解答\n\n解答分为三部分，对应于问题陈述中的三个任务。\n\n**第一部分：块三角化的条件**\n\n如果存在一个置换矩阵 $P$ 使得 $P M P^{\\top}$ 为块上三角矩阵，则称方阵 $M \\in \\mathbb{R}^{n \\times n}$ 是**可约的 (reducible)**。如果不存在这样的置换，则称该矩阵是**不可约的 (irreducible)**。\n\n理解可约性的关键在于与矩阵相关的有向图 $G(M)$。$G(M)$ 的顶点是整数 $\\{1, 2, \\dots, n\\}$，当且仅当矩阵项 $M_{ij} \\neq 0$ 时，存在一条从顶点 $i$ 到顶点 $j$ 的有向边（记为 $i \\to j$）。非零项的集合定义了矩阵的**稀疏模式 (sparsity pattern)**。\n\n数值线性代数中的一个基本定理指出，一个矩阵 $M$ 是不可约的当且仅当其关联的有向图 $G(M)$ 是**强连通的**。如果对于每一对有序顶点 $(i, j)$，都存在一条从 $i$ 到 $j$ 的有向边路径，则该有向图是强连通的。\n\n因此，一个矩阵 $M$ 是可约的当且仅当其有向图 $G(M)$ **不是**强连通的。所以，一个矩阵的稀疏模式能够通过置换变为块上三角形式的充分必要条件是，由其非零项定义的有向图不是强连通的。\n\n通过收缩 DAG 对此条件的解释如下。如果一个图 $G(M)$ 不是强连通的，它的顶点集可以被唯一地划分为一组强连通分量 (SCCs)，例如 $\\{S_1, S_2, \\dots, S_k\\}$，其中 $k > 1$。**收缩图 (condensation graph)** 是通过将每个 SCC $S_i$ 收缩成一个单一的超顶点而形成的。当且仅当在原图 $G(M)$ 中存在一条从 $S_i$ 中的某个顶点到 $S_j$ 中的某个顶点的边时，超顶点 $S_i$ 到 $S_j$ 之间才存在有向边。根据构造，这个收缩图是一个有向无环图 (DAG)。\n\n由于收缩图是一个 DAG 并且有多于一个顶点（因为 $k>1$），它的顶点可以进行拓扑排序。拓扑排序提供了一个超顶点的排序，比如 $(S_{\\pi(1)}, S_{\\pi(2)}, \\dots, S_{\\pi(k)})$，使得如果存在一条从 $S_{\\pi(i)}$ 到 $S_{\\pi(j)}$ 的边，那么 $i  j$。\n\n将 $M$ 转换为块上三角形式的置换矩阵 $P$ 是通过根据这个拓扑排序重新排列基向量（也就是 $M$ 的行和列）来构造的。具体来说，将属于 $S_{\\pi(1)}$ 的 $G(M)$ 的顶点分组，然后是属于 $S_{\\pi(2)}$ 的顶点，依此类推。得到的置换矩阵 $P M P^{\\top}$ 在其严格下三角部分将有零块，因为拓扑排序确保了没有从后面的分量 $S_{\\pi(j)}$ 到前面的分量 $S_{\\pi(i)}$ 的边（其中 $ji$）。\n\n**第二部分：对特定矩阵 $A$ 的分析**\n\n首先，我们确定给定矩阵 $A$ 的有向图 $G(A)$。顶点为 $\\{1, 2, 3, 4, 5, 6\\}$。由非零项 $A_{ij}$（其中 $\\varepsilon  0$）确定的边是：\n$1 \\to 1, 1 \\to 2, 1 \\to 3, 1 \\to 5$\n$2 \\to 2, 2 \\to 4$\n$3 \\to 1, 3 \\to 3, 3 \\to 4, 3 \\to 6$\n$4 \\to 2, 4 \\to 4, 4 \\to 5$\n$5 \\to 4, 5 \\to 5, 5 \\to 6$\n$6 \\to 5, 6 \\to 6$\n\n接下来，我们寻找强连通分量 (SCCs)。\n- 从顶点 $1$到 $3$ 有一条路径（$1 \\to 3$ 因为 $A_{13}=1$），从 $3$ 到 $1$ 也有一条路径（$3 \\to 1$ 因为 $A_{31}=1$）。因此，顶点 $\\{1, 3\\}$ 在同一个强连通分量中。没有从 $\\{1, 3\\}$ 到任何其他顶点再返回的路径。例如，$1 \\to 2$，但没有从任何其他顶点返回到 $1$ 或 $3$ 的路径。所以，一个强连通分量是 $S_1 = \\{1, 3\\}$。\n- 对于剩余的顶点 $\\{2, 4, 5, 6\\}$：\n    - $2 \\to 4$（因为 $A_{24}=1$）且 $4 \\to 2$（因为 $A_{42}=1$），所以 $2$ 和 $4$ 是相互可达的。\n    - $4 \\to 5$（因为 $A_{45}=2$）且 $5 \\to 4$（因为 $A_{54}=2$），所以 $4$ 和 $5$ 是相互可达的。\n    - $5 \\to 6$（因为 $A_{56}=3$）且 $6 \\to 5$（因为 $A_{65}=3$），所以 $5$ 和 $6$ 是相互可达的。\n- 根据传递性，$\\{2, 4, 5, 6\\}$ 中的所有顶点都是相互可达的。因此，第二个强连通分量是 $S_2 = \\{2, 4, 5, 6\\}$。\n强连通分量是 $S_1 = \\{1, 3\\}$ 和 $S_2 = \\{2, 4, 5, 6\\}$。\n\n现在，我们构造收缩 DAG。存在从 $S_1$ 到 $S_2$ 的边（例如，由 $A_{12}=\\varepsilon$ 产生的 $1 \\to 2$）。不存在从 $S_2$ 到 $S_1$ 的边。收缩 DAG 是 $S_1 \\to S_2$。\n\n收缩 DAG 的一个拓扑排序是 $(S_1, S_2)$。为了得到块上三角形式，我们重新排列顶点，先将 $S_1$ 中的顶点分组，然后是 $S_2$ 中的顶点。一个新的有效排序是 $(1, 3, 2, 4, 5, 6)$。\n将标准基 $(e_1, e_2, e_3, e_4, e_5, e_6)$ 映射到新基 $(e_1, e_3, e_2, e_4, e_5, e_6)$ 的置换是通过一个置换矩阵 $P$ 实现的，该矩阵的行是新排序的基向量。具体来说，$P$ 的第一行是 $e_1^\\top$，第二行是 $e_3^\\top$，第三行是 $e_2^\\top$，以此类推。\n$$\nP = \\begin{pmatrix}\n1  0  0  0  0  0 \\\\\n0  0  1  0  0  0 \\\\\n0  1  0  0  0  0 \\\\\n0  0  0  1  0  0 \\\\\n0  0  0  0  1  0 \\\\\n0  0  0  0  0  1\n\\end{pmatrix}\n$$\n这个矩阵交换了第 2 行和第 3 行。执行相似变换 $P A P^{\\top}$（即交换第 2 行和第 3 行，然后再交换第 2 列和第 3 列）得到：\n$$\nP A P^{\\top} \\;=\\; \\begin{pmatrix}\n4  1  \\varepsilon  0  2\\varepsilon  0 \\\\\n1  3  0  \\varepsilon  0  3\\varepsilon \\\\\n0  0  5  1  0  0 \\\\\n0  0  1  6  2  0 \\\\\n0  0  0  2  7  3 \\\\\n0  0  0  0  3  8\n\\end{pmatrix}\n$$\n该矩阵具有所需的块上三角形式：\n$$\nP A P^{\\top} \\;=\\;\n\\begin{pmatrix}\nB  E \\\\\n0  C\n\\end{pmatrix}\n$$\n其中各块为：\n$B = \\begin{pmatrix} 4  1 \\\\ 1  3 \\end{pmatrix} \\in \\mathbb{R}^{2 \\times 2}$\n$C = \\begin{pmatrix} 5  1  0  0 \\\\ 1  6  2  0 \\\\ 0  2  7  3 \\\\ 0  0  3  8 \\end{pmatrix} \\in \\mathbb{R}^{4 \\times 4}$\n$E = \\begin{pmatrix} \\varepsilon  0  2\\varepsilon  0 \\\\ 0  \\varepsilon  0  3\\varepsilon \\end{pmatrix} \\in \\mathbb{R}^{2 \\times 4}$\n左下角的 $4 \\times 2$ 块是零矩阵，这证实了块上三角结构。\n\n**第三部分：浮点运算量缩减**\n\n一个 $n \\times n$ 矩阵的稠密 LU 分解所需的浮点运算次数（flops）主要由项 $\\frac{2}{3}n^3$ 决定。\n\n对于第一种策略，即对完整的 $6 \\times 6$ 矩阵 $A$ 进行稠密 LU 分解，浮点运算次数为：\n$$\n\\text{flops}_A = \\frac{2}{3} \\times 6^3 = \\frac{2}{3} \\times 216 = 2 \\times 72 = 144\n$$\n\n对于第二种策略，即块对角分解，我们对对角块 $B$ 和 $C$ 分别进行 LU 分解。\n- 块 $B$ 是一个 $2 \\times 2$ 矩阵。其分解的浮点运算次数为：\n$$\n\\text{flops}_B = \\frac{2}{3} \\times 2^3 = \\frac{2}{3} \\times 8 = \\frac{16}{3}\n$$\n- 块 $C$ 是一个 $4 \\times 4$ 矩阵。其分解的浮点运算次数为：\n$$\n\\text{flops}_C = \\frac{2}{3} \\times 4^3 = \\frac{2}{3} \\times 64 = \\frac{128}{3}\n$$\n块策略的总浮点运算次数是每个块的浮点运算次数之和：\n$$\n\\text{flops}_{\\text{block}} = \\text{flops}_B + \\text{flops}_C = \\frac{16}{3} + \\frac{128}{3} = \\frac{144}{3} = 48\n$$\n\n缩减因子 $R$ 是块分解浮点运算次数与完整矩阵分解浮点运算次数之比：\n$$\nR = \\frac{\\text{flops}_{\\text{block}}}{\\text{flops}_A} = \\frac{48}{144} = \\frac{1}{3}\n$$", "answer": "$$\\boxed{\\frac{1}{3}}$$", "id": "3535135"}, {"introduction": "本节将从直接法转向迭代法，这对于求解最大规模的问题至关重要。本练习介绍了一种前沿技术——带低秩压缩的块迭代精化。该方法能同时处理多个右端项，并通过利用残差的低秩结构来提高解的精度和算法的稳健性。它展示了块操作如何与奇异值分解（SVD）和混合精度计算等概念相结合，以构建出高性能的现代数值算法。[@problem_id:3535155]", "problem": "考虑分块线性系统 $A X = B$，其中 $A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times m}$，$m \\geq 1$ 表示多个右端项。迭代精化是一种通过重复计算和校正分块残差 $R = B - A X$ 来改进近似解 $X$ 的过程。在本问题中，您将设计一种分块迭代精化方法，该方法能同时作用于所有右端项，并利用残差中的分块低秩结构来降低计算成本和提高数值鲁棒性。\n\n您必须使用的基本原理包括：分块矩阵及其运算的定义；分块残差 $R = B - A X$ 的定义；奇异值分解 (SVD) 的概念，其定义如下：对于任意矩阵 $R \\in \\mathbb{R}^{n \\times m}$，存在标准正交矩阵 $U \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{m \\times m}$，以及一个对角元为非负数（奇异值）的对角矩阵 $S \\in \\mathbb{R}^{n \\times m}$，使得 $R = U S V^\\top$。您也可以使用一个经过充分检验的事实：通过预先计算的分解（如下三角-上三角分解）来求解线性系统比在每次迭代中重新分解更高效。\n\n您的任务是：\n- 从第一性原理推导如何从分块残差的低秩分解中计算分块校正，从而将对所有右端项的计算简化为求解少数几个以 $A$ 为系数矩阵的方程组。\n- 解释当残差具有快速衰减的奇异值时，为何压缩残差能提高鲁棒性并降低成本。\n- 实现一个完整的算法，该算法应：\n  1. 使用较低的数值精度，一次性计算并存储 $A$ 的一个分解，并对残差使用更高的精度进行迭代精化。\n  2. 在每次迭代中，通过一个揭示秩的分解来压缩分块残差，并基于其压缩表示应用校正。\n  3. 使用基于后向误差的停止准则。对于 $X$ 的第 $j$ 列 $x_j$ 和 $B$ 的第 $j$ 列 $b_j$，后向误差定义为 $\\eta_j = \\dfrac{\\lVert r_j \\rVert_2}{\\lVert A \\rVert_2 \\lVert x_j \\rVert_2 + \\lVert b_j \\rVert_2}$，其中 $\\lVert A \\rVert_2$ 是谱范数，$r_j = b_j - A x_j$。当 $\\max_j \\eta_j$ 小于或等于预设的容差时，算法应停止。\n- 确保所有分块操作在数学上是一致的，并且在数值上是适定的。\n\n不涉及物理单位或角度单位。所有输出必须是纯数值的。\n\n您的程序必须实现上述算法并运行以下测试套件。为保证可复现性，请使用指定的随机种子。在每种情况下，计算并报告算法终止后的最终最大后向误差 $\\max_j \\eta_j$。\n\n测试套件：\n- 情况1（理想情况，低秩右端项和良态的 $A$）：\n  - 维度：$n = 50$, $m = 20$。\n  - 矩阵 $A$：令 $M \\in \\mathbb{R}^{n \\times n}$ 的元素服从种子为 $1$ 的标准正态分布，并定义 $A = M^\\top M + n I$，其中 $I$ 是单位矩阵。\n  - 分块右端项 $B$：令 $Q \\in \\mathbb{R}^{n \\times n}$ 为一个种子为 $2$ 的标准正态随机矩阵的QR分解得到的 $Q$ 因子。令 $U_b \\in \\mathbb{R}^{n \\times r}$ 为 $Q$ 的前 $r = 3$ 列。令 $V \\in \\mathbb{R}^{m \\times r}$ 的元素服从种子为 $3$ 的标准正态分布。定义 $B = U_b V^\\top$。\n  - 算法参数：秩上限 $k_{\\max} = 5$，SVD相对截断阈值 $\\tau = 10^{-12}$，停止容差 $\\varepsilon = 10^{-14}$，最大迭代次数 $N_{\\text{it}} = 5$。\n\n- 情况2（边界情况，满秩右端项和中等条件的非对称 $A$）：\n  - 维度：$n = 60$, $m = 60$。\n  - 矩阵 $A$：通过对种子分别为 $7$ 和 $8$ 的标准正态随机矩阵进行QR分解，生成标准正交矩阵 $U \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{n \\times n}$。令奇异值 $s_i$ 在 $[0.05, 30]$ 区间内线性间隔，其中 $i = 1, \\dots, n$。定义 $A = U \\operatorname{diag}(s) V^\\top$。\n  - 分块右端项 $B$：元素服从种子为 $4$ 的标准正态分布。\n  - 算法参数：秩上限 $k_{\\max} = 15$，SVD相对截断阈值 $\\tau = 10^{-2}$，停止容差 $\\varepsilon = 10^{-12}$，最大迭代次数 $N_{\\text{it}} = 8$。\n\n- 情况3（极端情况，病态的 $A$ 和低秩右端项）：\n  - 维度：$n = 20$, $m = 10$。\n  - 矩阵 $A$：希尔伯特矩阵，$A_{i j} = \\dfrac{1}{i + j - 1}$，其中 $i, j = 1, \\dots, n$。\n  - 分块右端项 $B$：令 $Q \\in \\mathbb{R}^{n \\times n}$ 为一个种子为 $5$ 的标准正态随机矩阵的QR分解得到的 $Q$ 因子。令 $U_b \\in \\mathbb{R}^{n \\times r}$ 为 $Q$ 的前 $r = 2$ 列。令 $V \\in \\mathbb{R}^{m \\times r}$ 的元素服从种子为 $6$ 的标准正态分布。定义 $B = U_b V^\\top$。\n  - 算法参数：秩上限 $k_{\\max} = 3$，SVD相对截断阈值 $\\tau = 10^{-6}$，停止容差 $\\varepsilon = 10^{-8}$，最大迭代次数 $N_{\\text{it}} = 20$。\n\n算法要求：\n- 以较低精度计算并存储 $A$ 的一个分解，并在整个精化过程中使用它进行求解。以较高精度计算残差和进行揭示秩的分解。\n- 在每次迭代中，通过揭示秩的分解来压缩分块残差，并以一种能将以 $A$ 为系数矩阵的求解次数从 $m$ 次减少到至多为截断秩 $k$ 次的方式更新近似解。\n- 使用上文定义的后向误差准则作为停止条件。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个条目是按情况1、情况2、情况3顺序排列的其中一个测试用例的最终最大后向误差（例如，“[result_case1,result_case2,result_case3]”）。", "solution": "我们考虑分块线性系统 $A X = B$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 且 $B \\in \\mathbb{R}^{n \\times m}$。分块残差定义为 $R = B - A X \\in \\mathbb{R}^{n \\times m}$。迭代精化通过辅助系统 $A \\Delta X = R$ 从残差中计算校正量 $\\Delta X$，并更新 $X \\leftarrow X + \\Delta X$。我们提出一种分块算法，该算法通过低秩分解压缩残差以减少求解次数，并利用了不同右端项之间的耦合关系。\n\n原理与推导：\n1. 对于每次迭代，我们从基本定义 $R = B - A X$ 出发。校正问题是 $A \\Delta X = R$。如果直接对所有 $m$ 个右端项求解，我们将在每次迭代中求解具有 $m$ 列的系统。\n\n2. 为降低成本，我们使用残差的揭示秩的分解。一个有原则的选择是奇异值分解 (SVD)，对于 $R \\in \\mathbb{R}^{n \\times m}$，它产生 $R = U S V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times n}$ 和 $V \\in \\mathbb{R}^{m \\times m}$ 是标准正交的，$S \\in \\mathbb{R}^{n \\times m}$ 是具有非负奇异值的对角矩阵。我们用 $k$ 表示根据某一准则通过截断选择的数值秩；也就是说，我们写出近似式 $R \\approx U_k S_k V_k^\\top$，其中 $U_k \\in \\mathbb{R}^{n \\times k}$ 具有标准正交列，$S_k \\in \\mathbb{R}^{k \\times k}$ 是对角矩阵，而 $V_k \\in \\mathbb{R}^{m \\times k}$ 具有标准正交列。这利用了一个经过充分检验的事实：在谱范数或弗罗贝尼乌斯范数意义下，截断小的奇异值可以得到近乎最优的低秩近似。\n\n3. 将此压缩表示代入校正问题 $A \\Delta X = R$ 中，得到近似校正模型 $A \\Delta X \\approx U_k S_k V_k^\\top$。我们使用分块运算来避免 $m$ 次求解。如果我们通过具有 $k$ 个右端项的系统 $A Y = U_k$ 定义 $Y \\in \\mathbb{R}^{n \\times k}$，那么校正量可以通过分块乘法 $\\Delta X \\approx Y S_k V_k^\\top$ 组装而成。这个结论可以通过设 $\\Delta X = Y S_k V_k^\\top$ 并将其代入 $A \\Delta X$ 来验证：$A (Y S_k V_k^\\top) = (AY) S_k V_k^\\top$。由于 $AY = U_k$，我们得到 $A\\Delta X = U_k S_k V_k^\\top \\approx R$。\n\n4. 计算上的好处在于，求解 $A Y = U_k$ 只需要 $k$ 次求解，如果由于低秩残差结构而使得 $k \\ll m$，我们就能降低每次迭代的成本，同时仍然能对所有 $m$ 个右端项进行校正。鲁棒性上的好处来自SVD的稳定性以及对那些直接应用时可能放大舍入误差的小奇异分量的抑制。\n\n5. 迭代精化通常使用混合精度来改进以较低精度计算的近似解，具体方法是用较高精度的残差进行精化。我们采用 $A$ 的较低精度分解来进行求解，并以较高精度计算残差和SVD。这符合数值线性代数中一个经过充分检验的策略，即较高精度的残差计算可以校正较低精度的求解误差。\n\n6. 我们使用基于后向误差的停止准则。对于每一列 $j$，$r_j = b_j - A x_j$。全局后向误差是 $\\max_j \\eta_j$，其中\n   $$\\eta_j = \\frac{\\lVert r_j \\rVert_2}{\\lVert A \\rVert_2 \\lVert x_j \\rVert_2 + \\lVert b_j \\rVert_2}。$$\n   此处 $\\lVert A \\rVert_2$ 是谱范数，我们将其计算为 $A$ 的最大奇异值。该准则确保了计算出的解是在分块意义下具有小相对扰动的一个邻近问题的精确解。\n\n算法设计：\n- 以较低精度预先计算 $A$ 的一个下三角-上三角 (LU) 分解，然后在所有求解步骤中使用该分解以避免重复分解。其合理性在于 LU 分解能够对多个右端项进行高效的三角求解。\n- 通过使用较低精度的分解求解 $A X^{(0)} \\approx B$ 来初始化 $X$。\n- 对于迭代 $t = 0, 1, \\dots$，计算高精度残差 $R^{(t)} = B - A X^{(t)}$。\n- 计算 $R^{(t)}$ 的SVD，并根据奇异值的相对阈值通过截断选择一个数值秩 $k \\leq k_{\\max}$。这将得到 $U_k$、$S_k$ 和 $V_k$。\n- 使用较低精度的分解求解 $A Y^{(t)} = U_k$。通过分块乘法组装 $\\Delta X^{(t)} = Y^{(t)} S_k V_k^\\top$。\n- 更新 $X^{(t+1)} = X^{(t)} + \\Delta X^{(t)}$。\n- 评估后向误差，当 $\\max_j \\eta_j \\leq \\varepsilon$ 或迭代次数达到 $N_{\\text{it}}$ 时停止。\n\n数值考虑：\n- 秩截断阈值应是相对的，例如，保留满足 $\\sigma_i \\geq \\tau \\sigma_1$ 的奇异值 $\\sigma_i$，其中 $\\sigma_1$ 是残差的最大奇异值。这可以防止丢弃重要的子空间分量。\n- 如果残差在数值上为零，SVD将揭示所有奇异值都接近于零，此时后向误差将已经低于容差。\n- 使用一次性计算的 LU 分解，通过分块三角求解可以高效地解决具有多列 $U_k$ 的方程组 $A Y = U_k$。\n- 谱范数 $\\lVert A \\rVert_2$ 通过对 $A$ 进行一次奇异值分解来计算，以避免重复计算。\n\n测试套件实现：\n- 情况1构造了一个条件良好的对称正定矩阵 $A$ 和一个秩为3的分块结构 $B$，预期会实现快速收敛和有效的低秩压缩。\n- 情况2构造了一个具有受控奇异值的非对称矩阵 $A$ 和一个完全随机的矩阵 $B$；预期残差的奇异值会适度衰减，激进的截断将测试边界情况。\n- 情况3使用一个病态的希尔伯特矩阵 $A$ 和一个秩为2的矩阵 $B$。较低精度的分解与较高精度的残差相结合，用以检验鲁棒性，并且迭代精化过程试图在矩阵病态的情况下减小后向误差。\n\n程序实现了上述算法，计算了每种情况下的最终最大后向误差，并以指定格式在单行中打印这三个值。所有计算均无单位，且为纯数值计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve, qr\n\ndef spectral_norm(A: np.ndarray) - float:\n    # Compute spectral norm as largest singular value\n    # Use full SVD for robustness; for moderate n this is fine.\n    s = np.linalg.svd(A, compute_uv=False)\n    return float(s[0])\n\ndef build_case1():\n    # Case 1: n=50, m=20, SPD A, low-rank B\n    n, m = 50, 20\n    rng_M = np.random.default_rng(1)\n    M = rng_M.standard_normal((n, n))\n    A = M.T @ M + n * np.eye(n, dtype=np.float64)\n\n    rng_Q = np.random.default_rng(2)\n    Q_rand = rng_Q.standard_normal((n, n))\n    Q, _ = qr(Q_rand, mode='economic')\n    r = 3\n    U_b = Q[:, :r]\n\n    rng_V = np.random.default_rng(3)\n    V = rng_V.standard_normal((m, r))\n    B = U_b @ V.T\n\n    params = {\n        \"rank_cap\": 5,\n        \"svd_tol\": 1e-12,\n        \"tol\": 1e-14,\n        \"max_iter\": 5,\n    }\n    return A, B, params\n\ndef build_case2():\n    # Case 2: n=60, m=60, general A with controlled singular values, full-rank B\n    n, m = 60, 60\n\n    rng_U = np.random.default_rng(7)\n    U_rand = rng_U.standard_normal((n, n))\n    U_q, _ = qr(U_rand, mode='economic')\n\n    rng_V = np.random.default_rng(8)\n    V_rand = rng_V.standard_normal((n, n))\n    V_q, _ = qr(V_rand, mode='economic')\n\n    # Singular values linearly spaced between 0.05 and 30\n    svals = np.linspace(0.05, 30.0, n)\n    A = (U_q @ (np.diag(svals) @ V_q.T)).astype(np.float64)\n\n    rng_B = np.random.default_rng(4)\n    B = rng_B.standard_normal((n, m))\n\n    params = {\n        \"rank_cap\": 15,\n        \"svd_tol\": 1e-2,\n        \"tol\": 1e-12,\n        \"max_iter\": 8,\n    }\n    return A, B, params\n\ndef build_case3():\n    # Case 3: n=20, m=10, Hilbert A, low-rank B\n    n, m = 20, 10\n    # Hilbert matrix\n    i = np.arange(1, n + 1, dtype=np.float64)\n    j = np.arange(1, n + 1, dtype=np.float64)\n    A = 1.0 / (i[:, None] + j[None, :] - 1.0)\n\n    rng_Q = np.random.default_rng(5)\n    Q_rand = rng_Q.standard_normal((n, n))\n    Q, _ = qr(Q_rand, mode='economic')\n    r = 2\n    U_b = Q[:, :r]\n\n    rng_V = np.random.default_rng(6)\n    V = rng_V.standard_normal((m, r))\n    B = U_b @ V.T\n\n    params = {\n        \"rank_cap\": 3,\n        \"svd_tol\": 1e-6,\n        \"tol\": 1e-8,\n        \"max_iter\": 20,\n    }\n    return A, B, params\n\ndef block_iterative_refinement(A: np.ndarray,\n                               B: np.ndarray,\n                               rank_cap: int,\n                               svd_tol: float,\n                               tol: float,\n                               max_iter: int) - float:\n    \"\"\"\n    Perform block iterative refinement with low-rank residual compression.\n\n    A: (n,n) float64\n    B: (n,m) float64\n    Returns the final maximum backward error across RHSs.\n    \"\"\"\n    n, m = B.shape\n    # Lower precision factorization\n    A32 = A.astype(np.float32)\n    lu, piv = lu_factor(A32)\n\n    # Initial solve in lower precision, cast to float64 for accumulation\n    X = lu_solve((lu, piv), B.astype(np.float32)).astype(np.float64)\n\n    # Precompute spectral norm for backward error\n    normA2 = spectral_norm(A)\n\n    # Iterative refinement\n    for it in range(max_iter):\n        R = B - A @ X  # residual in double precision\n\n        # Backward error computation\n        # Compute columnwise norms\n        r_norms = np.linalg.norm(R, axis=0)\n        x_norms = np.linalg.norm(X, axis=0)\n        b_norms = np.linalg.norm(B, axis=0)\n        # Avoid division by zero: if denominator is zero, set error as norm(r)\n        denom = normA2 * x_norms + b_norms\n        with np.errstate(divide='ignore', invalid='ignore'):\n            eta = np.where(denom  0, r_norms / denom, r_norms)\n        max_eta = float(np.max(eta))\n        if max_eta = tol:\n            break\n\n        # SVD of residual\n        # Use economical SVD to get U (n x min(n,m)), S (min(n,m)), Vh (min(n,m) x m)\n        U, S, Vh = np.linalg.svd(R, full_matrices=False)\n        # Determine truncated rank k: keep singular values above relative threshold, cap by rank_cap\n        if S.size == 0 or S[0] == 0.0:\n            # Residual is (near) zero; no correction needed\n            break\n        k_rel = int(np.sum(S = svd_tol * S[0]))\n        k = max(1, min(rank_cap, k_rel))\n        U_k = U[:, :k]\n        S_k = S[:k]\n        Vh_k = Vh[:k, :]\n\n        # Solve A Y = U_k with lower precision factorization\n        Y = lu_solve((lu, piv), U_k.astype(np.float32)).astype(np.float64)\n        # Assemble correction: ΔX = Y S_k Vh_k\n        # Compute W = S_k[:,None] * Vh_k (k x m), then ΔX = Y (n x k) @ W (k x m)\n        W = (S_k[:, None] * Vh_k)\n        dX = Y @ W\n\n        # Update\n        X += dX\n\n    # Final backward error\n    R = B - A @ X\n    r_norms = np.linalg.norm(R, axis=0)\n    x_norms = np.linalg.norm(X, axis=0)\n    b_norms = np.linalg.norm(B, axis=0)\n    denom = normA2 * x_norms + b_norms\n    with np.errstate(divide='ignore', invalid='ignore'):\n        eta = np.where(denom  0, r_norms / denom, r_norms)\n    max_eta = float(np.max(eta))\n    return max_eta\n\ndef solve():\n    # Define the test cases from the problem statement.\n    cases = []\n    cases.append(build_case1())\n    cases.append(build_case2())\n    cases.append(build_case3())\n\n    results = []\n    for (A, B, params) in cases:\n        res = block_iterative_refinement(\n            A=A,\n            B=B,\n            rank_cap=params[\"rank_cap\"],\n            svd_tol=params[\"svd_tol\"],\n            tol=params[\"tol\"],\n            max_iter=params[\"max_iter\"],\n        )\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3535155"}]}