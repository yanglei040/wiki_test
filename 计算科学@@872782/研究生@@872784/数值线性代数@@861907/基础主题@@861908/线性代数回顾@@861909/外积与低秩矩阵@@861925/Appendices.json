{"hands_on_practices": [{"introduction": "任何低秩矩阵都可以表示为外积之和。因此，理解单个秩为1的外积 $A = uv^T$ 的基本性质是至关重要的。本练习将从第一性原理出发，深入探讨与这一基本构造相关的几何结构。通过推导其列空间和行空间的正交投影算子 ([@problem_id:3563738])，您将加深对代数表示（外积）与几何概念（子空间投影）之间内在联系的理解。这项实践旨在夯实您对低秩逼近核心构件的掌握。", "problem": "设 $m,n \\in \\mathbb{N}$，设 $u \\in \\mathbb{R}^{m}$ 和 $v \\in \\mathbb{R}^{n}$ 为非零向量，并设 $A \\in \\mathbb{R}^{m \\times n}$ 为秩一外积 $A = u v^{T}$。在 $\\mathbb{R}^{m}$ 和 $\\mathbb{R}^{n}$ 上使用标准的欧几里得内积。对于一个有限维内积空间中的线性子空间 $S$，其上的正交投影算子是满足 $P^{2} = P$、$P$ 是自伴的、$\\operatorname{range}(P) = S$ 的唯一线性映射，并且对于任意 $y$，向量 $Py$ 是 $S$ 中唯一一个使到 $y$ 的欧几里得距离最小化的元素。\n\n从这些定义和外积的基本性质出发，完成以下任务：\n- 确定 $\\operatorname{col}(A)$ 和 $\\operatorname{row}(A)$，其中 $\\operatorname{col}(A)$ 是 $\\mathbb{R}^{m}$ 中的列空间，$\\operatorname{row}(A)$ 是 $\\mathbb{R}^{n}$ 中的行空间。\n- 通过定义的最小化性质，从第一性原理推导出到这些子空间上的正交投影算子 $P_{\\operatorname{col}(A)} \\in \\mathbb{R}^{m \\times m}$ 和 $P_{\\operatorname{row}(A)} \\in \\mathbb{R}^{n \\times n}$ 的显式公式，并验证每个这样的投影算子都是对称和幂等的。\n- 仅使用这些性质和基本矩阵恒等式，计算 $P_{\\operatorname{col}(A)}$ 和 $P_{\\operatorname{row}(A)}$ 的秩和迹。\n\n以单行矩阵的形式提供您的最终答案，其元素按以下顺序排列：\n$[\\operatorname{rank}(P_{\\operatorname{col}(A)}), \\operatorname{tr}(P_{\\operatorname{col}(A)}), \\operatorname{rank}(P_{\\operatorname{row}(A)}), \\operatorname{tr}(P_{\\operatorname{row}(A)})]$。\n\n无需四舍五入。不要包含任何单位。最终答案必须是如上指定的单行矩阵。", "solution": "该问题是有效的，因为它是数学上良定义的、自洽的，并且基于线性代数的标准原理。\n\n首先，我们确定矩阵 $A = u v^{T}$ 的列空间 $\\operatorname{col}(A)$ 和行空间 $\\operatorname{row}(A)$，其中 $u \\in \\mathbb{R}^{m}$ 和 $v \\in \\mathbb{R}^{n}$ 是非零向量。\n\n矩阵 $A$ 由外积 $A = u v^{T}$ 给出。将向量 $v$ 用其分量表示，$v = [v_1, v_2, \\dots, v_n]^T$，则矩阵 $A$ 可以表示为：\n$$\nA = u [v_1, v_2, \\dots, v_n] = [v_1 u, v_2 u, \\dots, v_n u]\n$$\n$A$ 的列是 $a_j = v_j u$，其中 $j = 1, \\dots, n$。每一列都是向量 $u$ 的标量倍。列空间 $\\operatorname{col}(A)$ 是这些列的张成空间。$\\operatorname{col}(A)$ 中的任何向量 $x$ 都可以写成 $A$ 的列的线性组合：\n$$\nx = \\sum_{j=1}^{n} c_j (v_j u) = \\left( \\sum_{j=1}^{n} c_j v_j \\right) u\n$$\n这表明 $\\operatorname{col}(A)$ 中的任何向量都是 $u$ 的标量倍。因此，$\\operatorname{col}(A) \\subseteq \\operatorname{span}(u)$。\n由于 $v$ 是一个非零向量，所以至少存在一个分量 $v_k \\neq 0$。$A$ 的第 $k$ 列是 $a_k = v_k u$。因为 $u$ 也是一个非零向量，所以 $a_k$ 是 $\\operatorname{col}(A)$ 中的一个非零向量。我们可以写出 $u = (1/v_k) a_k$，这表明 $u \\in \\operatorname{col}(A)$。因此，$\\operatorname{span}(u) \\subseteq \\operatorname{col}(A)$。结合这两个包含关系，我们得出结论 $\\operatorname{col}(A) = \\operatorname{span}(u)$。\n\n行空间 $\\operatorname{row}(A)$ 是转置矩阵 $A^T$ 的列空间。\n$$\nA^T = (u v^T)^T = (v^T)^T u^T = v u^T\n$$\n通过相同的论证，A^T 的列都是向量 $v$ 的标量倍。由于 $u \\neq 0$，至少有一列是 $v$ 的非零倍数。因此，$A^T$ 的列空间是 $v$ 的张成空间。所以，$\\operatorname{row}(A) = \\operatorname{col}(A^T) = \\operatorname{span}(v)$。\n\n接下来，我们从定义的最小化性质推导出正交投影算子 $P_{\\operatorname{col}(A)}$ 和 $P_{\\operatorname{row}(A)}$ 的显式公式。\n\n对于到 $S = \\operatorname{col}(A) = \\operatorname{span}(u)$ 上的投影算子 $P_{\\operatorname{col}(A)} \\in \\mathbb{R}^{m \\times m}$，我们为任意向量 $y \\in \\mathbb{R}^m$ 寻找唯一的向量 $p \\in S$，使得欧几里得距离 $\\|y - p\\|_2$ 最小。任何向量 $p \\in S$ 都可以写成 $p = c u$ 的形式，其中 $c \\in \\mathbb{R}$ 是某个标量。我们想要找到使距离平方 $f(c) = \\|y - c u\\|_2^2$ 最小的 $c$ 的值。\n使用内积（点积），其中 $\\langle x, z \\rangle = x^T z$：\n$$\nf(c) = \\langle y - c u, y - c u \\rangle = \\langle y, y \\rangle - 2c \\langle u, y \\rangle + c^2 \\langle u, u \\rangle = \\|y\\|_2^2 - 2c (u^T y) + c^2 (u^T u)\n$$\n这是一个关于 $c$ 的二次函数。为了找到最小值，我们对 $c$ 求导并令导数为零：\n$$\n\\frac{df}{dc} = -2(u^T y) + 2c (u^T u) = 0\n$$\n由于 $u \\neq 0$，其范数的平方 $\\|u\\|_2^2 = u^T u$ 非零。我们可以解出 $c$：\n$$\nc = \\frac{u^T y}{u^T u}\n$$\n$y$ 到 $S$ 上的投影是 $p = c u = \\left(\\frac{u^T y}{u^T u}\\right)u$。这可以用矩阵乘法重写为：\n$$\np = u \\left(\\frac{u^T y}{u^T u}\\right) = \\frac{u(u^T y)}{u^T u} = \\frac{(u u^T)y}{u^T u}\n$$\n该投影是一个线性变换 $p = P_{\\operatorname{col}(A)} y$。因此，该投影算子的矩阵表示为：\n$$\nP_{\\operatorname{col}(A)} = \\frac{u u^T}{u^T u}\n$$\n对于到 $S' = \\operatorname{row}(A) = \\operatorname{span}(v)$ 上的投影算子 $P_{\\operatorname{row}(A)} \\in \\mathbb{R}^{n \\times n}$，一个类似的推导得出：\n$$\nP_{\\operatorname{row}(A)} = \\frac{v v^T}{v^T v}\n$$\n现在，我们验证这些投影算子是对称的（自伴的）和幂等的（$P^2 = P$）。\n对于 $P_{\\operatorname{col}(A)}$：\n对称性：$P_{\\operatorname{col}(A)}^T = \\left(\\frac{u u^T}{u^T u}\\right)^T = \\frac{(u u^T)^T}{u^T u} = \\frac{(u^T)^T u^T}{u^T u} = \\frac{u u^T}{u^T u} = P_{\\operatorname{col}(A)}$。它是对称的。\n幂等性：\n$$\nP_{\\operatorname{col}(A)}^2 = \\left(\\frac{u u^T}{u^T u}\\right) \\left(\\frac{u u^T}{u^T u}\\right) = \\frac{(u u^T)(u u^T)}{(u^T u)^2} = \\frac{u(u^T u)u^T}{(u^T u)^2}\n$$\n由于 $u^T u$ 是一个标量，它可以交换位置，得到：\n$$\nP_{\\operatorname{col}(A)}^2 = \\frac{(u^T u)(u u^T)}{(u^T u)^2} = \\frac{u u^T}{u^T u} = P_{\\operatorname{col}(A)}\n$$\n它是幂等的。对于 $P_{\\operatorname{row}(A)}$ 的验证是相同的，只需将 $u$ 替换为 $v$。\n\n最后，我们计算这些投影算子的秩和迹。\n一个正交投影算子的秩是它所投影到的子空间的维度。\n$$\n\\operatorname{rank}(P_{\\operatorname{col}(A)}) = \\dim(\\operatorname{col}(A)) = \\dim(\\operatorname{span}(u))\n$$\n因为 $u$ 是一个非零向量，集合 $\\{u\\}$ 是其张成空间的基。因此，$\\dim(\\operatorname{span}(u)) = 1$。\n所以，$\\operatorname{rank}(P_{\\operatorname{col}(A)}) = 1$。\n类似地，$\\operatorname{rank}(P_{\\operatorname{row}(A)}) = \\dim(\\operatorname{row}(A)) = \\dim(\\operatorname{span}(v)) = 1$，因为 $v \\neq 0$。\n\n矩阵的迹可以使用性质 $\\operatorname{tr}(XY) = \\operatorname{tr}(YX)$ 来计算。对于 $P_{\\operatorname{col}(A)} \\in \\mathbb{R}^{m \\times m}$：\n$$\n\\operatorname{tr}(P_{\\operatorname{col}(A)}) = \\operatorname{tr}\\left(\\frac{u u^T}{u^T u}\\right) = \\frac{1}{u^T u} \\operatorname{tr}(u u^T)\n$$\n使用循环性质，$\\operatorname{tr}(u u^T) = \\operatorname{tr}(u^T u)$。项 $u^T u$ 是一个 $1 \\times 1$ 矩阵（一个标量），所以它的迹就是该标量本身，$\\operatorname{tr}(u^T u) = u^T u$。\n$$\n\\operatorname{tr}(P_{\\operatorname{col}(A)}) = \\frac{1}{u^T u} (u^T u) = 1\n$$\n根据同样的推理，对于 $P_{\\operatorname{row}(A)} \\in \\mathbb{R}^{n \\times n}$：\n$$\n\\operatorname{tr}(P_{\\operatorname{row}(A)}) = \\operatorname{tr}\\left(\\frac{v v^T}{v^T v}\\right) = \\frac{1}{v^T v} \\operatorname{tr}(v^T v) = \\frac{1}{v^T v} (v^T v) = 1\n$$\n这证实了一个普遍性质，即对于任何正交投影算子 $P$，其秩等于其迹。\n\n所求的量为：\n$\\operatorname{rank}(P_{\\operatorname{col}(A)}) = 1$\n$\\operatorname{tr}(P_{\\operatorname{col}(A)}) = 1$\n$\\operatorname{rank}(P_{\\operatorname{row}(A)}) = 1$\n$\\operatorname{tr}(P_{\\operatorname{row}(A)}) = 1$\n将这些值组合成一个单行矩阵得到 $[1, 1, 1, 1]$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 1  1  1  1 \\end{pmatrix}}\n$$", "id": "3563738"}, {"introduction": "低秩分解的核心优势在于其计算效率。本练习将理论付诸实践，要求您设计并实现一个高效算法，用于计算两个以低秩因子形式表示的矩阵 $A = U_A V_A^T$ 和 $B = U_B V_B^T$ 的乘积。关键在于利用矩阵乘法的结合律，避免显式构造大矩阵 $A$ 和 $B$，从而大幅降低计算成本。通过完成这项编码任务 ([@problem_id:3563735])，您不仅将验证乘积矩阵的秩上界，还将亲身体验低秩结构在加速数值计算中的强大威力。", "problem": "给定两个矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times p}$，它们以低秩分解的形式给出：$A = U_A V_A^T$ 和 $B = U_B V_B^T$，其中 $U_A \\in \\mathbb{R}^{m \\times k_A}$，$V_A \\in \\mathbb{R}^{n \\times k_A}$，$U_B \\in \\mathbb{R}^{n \\times k_B}$，$V_B \\in \\mathbb{R}^{p \\times k_B}$。请设计一个算法来计算 $A B$，该算法不显式地构造 $A$ 或 $B$，而是利用矩阵乘法的结合律来使用恒等式 $A B = U_A \\left(V_A^T U_B\\right) V_B^T$。使用矩阵乘法和结合律的定义从基本原理出发证明其正确性。仅使用秩的次可乘不等式 $\\operatorname{rank}(X Y) \\le \\min\\{\\operatorname{rank}(X), \\operatorname{rank}(Y)\\}$ 和矩形矩阵乘积的秩定义，推导出 $A B$ 的秩关于 $k_A$ 和 $k_B$ 的一个界限。提供一个清晰的论证，说明 $\\operatorname{rank}(A B) \\le \\min(k_A, k_B)$。\n\n您的程序必须：\n- 实现将 $A B$ 计算为 $U_A \\left(V_A^T U_B\\right) V_B^T$ 的算法，仅使用低秩因子。\n- 为了验证，也要通过首先构造 $A = U_A V_A^T$ 和 $B = U_B V_B^T$ 然后将它们相乘来朴素地计算 $A B$。\n- 计算两个结果之差的弗罗贝尼乌斯范数：$\\lVert A B_{\\text{fast}} - A B_{\\text{naive}} \\rVert_F$。\n- 使用奇异值分解计算 $A B$ 的数值秩，容差为 $\\tau = \\max\\{m, p\\} \\, \\epsilon \\, \\sigma_{\\max}$，其中 $\\epsilon$ 是双精度下的机器ε，$\\sigma_{\\max}$ 是 $A B$ 的最大奇异值。数值秩是严格大于 $\\tau$ 的奇异值的数量。\n- 对于每个测试用例，返回一个四元组，包含：弗罗贝尼乌斯误差（浮点数）、$A B$ 的数值秩（整数）、界限 $\\min(k_A, k_B)$（整数）以及一个布尔值，指示不等式 $\\operatorname{rank}(A B) \\le \\min(k_A, k_B)$ 是否成立。\n\n您的推导应仅基于：\n- 矩阵乘法和结合律的定义。\n- 将低秩矩阵表示为外积之和。\n- 不等式 $\\operatorname{rank}(X Y) \\le \\min\\{\\operatorname{rank}(X), \\operatorname{rank}(Y)\\}$。\n- 使用奇异值分解的数值秩定义。\n\n您的程序必须是自包含的，不使用任何输入。使用以下测试套件，它定义了 $U_A$、$V_A$、$U_B$、$V_B$ 的维度和构造方法：\n- 测试用例 1（一般情况）：$m=7$，$n=5$，$p=6$，$k_A=3$，$k_B=2$。使用随机种子 $0$ 构造具有独立标准正态分布元素的 $U_A$、$V_A$、$U_B$、$V_B$。\n- 测试用例 2（秩-1 因子）：$m=8$，$n=4$，$p=3$，$k_A=1$，$k_B=1$。使用随机种子 $1$ 构造具有独立标准正态分布元素的 $U_A$、$V_A$、$U_B$、$V_B$。\n- 测试用例 3（通过正交性实现零乘积）：$m=6$，$n=4$，$p=5$，$k_A=2$，$k_B=2$。使用随机种子 $2$ 构造具有独立标准正态分布元素的 $U_A$ 和 $V_B$。构造具有独立标准正态分布元素且满列秩的 $U_B \\in \\mathbb{R}^{n \\times k_B}$。令 $Q \\in \\mathbb{R}^{n \\times n}$ 是一个正交矩阵，其前 $k_B$ 列张成 $U_B$ 的列空间（例如，来自完全 QR 分解）。设置 $V_A = Q[:, k_B:(k_B+k_A)]$，使得 $V_A^T U_B = 0$，因此通过构造可得 $A B = 0$。\n- 测试用例 4（一般情况，$k_A > k_B$）：$m=5$，$n=5$，$p=5$，$k_A=4$，$k_B=3$。使用随机种子 $3$ 构造具有独立标准正态分布元素的 $U_A$、$V_A$、$U_B$、$V_B$。\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算：\n- $e_i = \\lVert A B_{\\text{fast}} - A B_{\\text{naive}} \\rVert_F$，\n- $r_i = \\operatorname{rank}_{\\text{num}}(A B)$，在指定容差下，\n- $b_i = \\min(k_A, k_B)$，\n- $q_i =$ 谓词 $r_i \\le b_i$ 的布尔值。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。\n- 该列表必须是 $[e_1, r_1, b_1, q_1, e_2, r_2, b_2, q_2, e_3, r_3, b_3, q_3, e_4, r_4, b_4, q_4]$ 的串联。\n- 所有浮点值必须以标准 Python 格式打印；无需特殊舍入。\n- 此问题不涉及物理单位、角度或百分比。", "solution": "该问题要求设计并验证一种高效算法，用于乘以两个以低秩分解形式给出的矩阵 $A$ 和 $B$。我们必须证明该算法的正确性，推导乘积矩阵 $A B$ 的秩的界限，并实现算法以进行数值验证。\n\n### 算法的正确性\n\n给定两个矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times p}$ 及其各自的低秩分解：\n$$\nA = U_A V_A^T \\quad \\text{其中 } U_A \\in \\mathbb{R}^{m \\times k_A}, V_A \\in \\mathbb{R}^{n \\times k_A}\n$$\n$$\nB = U_B V_B^T \\quad \\text{其中 } U_B \\in \\mathbb{R}^{n \\times k_B}, V_B \\in \\mathbb{R}^{p \\times k_B}\n$$\n乘积 $A B$ 可以通过代入这些分解来写出：\n$$\nA B = (U_A V_A^T) (U_B V_B^T)\n$$\n矩阵乘法具有结合律，这是一个基本性质，即对于任意三个可相乘的矩阵 $X$、$Y$ 和 $Z$，等式 $(XY)Z = X(YZ)$ 成立。我们可以将此性质应用于四矩阵乘积 $U_A V_A^T U_B V_B^T$。我们可以按如下方式对矩阵进行分组：\n$$\nA B = (U_A V_A^T) (U_B V_B^T) = U_A (V_A^T U_B V_B^T) = U_A (V_A^T U_B) V_B^T\n$$\n这证实了所提出算法的正确性，该算法通过首先计算中间的较小矩阵乘积 $C = V_A^T U_B$，然后计算 $A B = U_A C V_B^T$ 来得到最终乘积。\n\n所涉及矩阵的维度为：$U_A \\in \\mathbb{R}^{m \\times k_A}$，$V_A^T \\in \\mathbb{R}^{k_A \\times n}$，$U_B \\in \\mathbb{R}^{n \\times k_B}$，以及 $V_B^T \\in \\mathbb{R}^{k_B \\times p}$。\n朴素方法包括首先构造完整矩阵 $A$（耗费 $O(mnk_A)$ 次运算）和 $B$（耗费 $O(npk_B)$ 次运算），然后将它们相乘（耗费 $O(mnp)$ 次运算）。当维度较大时，总复杂度主要由 $O(mnp)$ 决定。\n所提出的“快速”算法计算如下：\n1. $C = V_A^T U_B$。这是一个 $(k_A \\times n) \\times (n \\times k_B)$ 的乘积，得到一个 $k_A \\times k_B$ 的矩阵，耗费 $O(k_A n k_B)$ 次运算。\n2. $D = U_A C$。这是一个 $(m \\times k_A) \\times (k_A \\times k_B)$ 的乘积，得到一个 $m \\times k_B$ 的矩阵，耗费 $O(m k_A k_B)$ 次运算。\n3. $AB = D V_B^T$。这是一个 $(m \\times k_B) \\times (k_B \\times p)$ 的乘积，耗费 $O(m k_B p)$ 次运算。\n总复杂度为 $O(k_A n k_B + m k_A k_B + m k_B p)$。当秩 $k_A$ 和 $k_B$ 远小于矩阵维度 $m, n, p$ 时，这种方法比朴素方法效率高得多。\n\n### 秩界限的推导\n\n我们的任务是使用秩的次可乘性质 $\\operatorname{rank}(XY) \\le \\min\\{\\operatorname{rank}(X), \\operatorname{rank}(Y)\\}$ 和秩的定义来证明 $\\operatorname{rank}(A B) \\le \\min(k_A, k_B)$。\n\n矩阵的秩是其列空间的维度。矩阵乘积 $XY$ 的列空间是 $X$ 的列空间的子空间，即 $\\operatorname{Col}(XY) \\subseteq \\operatorname{Col}(X)$。这直接意味着 $\\operatorname{rank}(XY) \\le \\operatorname{rank}(X)$。\n\n考虑矩阵 $A = U_A V_A^T$。$A$ 的列是 $U_A$ 的列的线性组合。因此，$A$ 的列空间是 $U_A$ 的列空间的子空间。\n$$\n\\operatorname{Col}(A) \\subseteq \\operatorname{Col}(U_A)\n$$\n这意味着 $\\operatorname{Col}(A)$ 的维度最多是 $\\operatorname{Col}(U_A)$ 的维度。\n$$\n\\operatorname{rank}(A) \\le \\operatorname{rank}(U_A)\n$$\n矩阵 $U_A \\in \\mathbb{R}^{m \\times k_A}$ 有 $k_A$ 列。这些列所张成的空间的维度最多为 $k_A$。因此，$\\operatorname{rank}(U_A) \\le k_A$。\n综合这些，我们得到：\n$$\n\\operatorname{rank}(A) \\le k_A\n$$\n这也可以通过将 $A$ 看作 $k_A$ 个秩为 1 的矩阵（外积）之和来理解，$A = \\sum_{i=1}^{k_A} u_i v_i^T$，其中 $u_i$ 和 $v_i$ 分别是 $U_A$ 和 $V_A$ 的列。矩阵和的秩最多是它们秩的和，所以 $\\operatorname{rank}(A) \\le \\sum_{i=1}^{k_A} \\operatorname{rank}(u_i v_i^T) = \\sum_{i=1}^{k_A} 1 = k_A$。\n\n对于矩阵 $B = U_B V_B^T$，其中 $U_B \\in \\mathbb{R}^{n \\times k_B}$，通过同样的推理，我们有：\n$$\n\\operatorname{rank}(B) \\le \\operatorname{rank}(U_B) \\le k_B\n$$\n现在，我们将给定的秩的次可乘不等式应用于乘积 $A B$：\n$$\n\\operatorname{rank}(A B) \\le \\min\\{\\operatorname{rank}(A), \\operatorname{rank}(B)\\}\n$$\n代入我们为 $\\operatorname{rank}(A)$ 和 $\\operatorname{rank}(B)$ 推导出的界限：\n$$\n\\operatorname{rank}(A B) \\le \\min\\{k_A, k_B\\}\n$$\n推导完成。\n\n### 数值秩的计算\n\n矩阵的数值秩通过其奇异值分解（SVD）来确定。对于一个矩阵 $C \\in \\mathbb{R}^{m \\times p}$，其奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$，数值秩是大于指定容差 $\\tau$ 的奇异值的数量。问题将此容差定义为：\n$$\n\\tau = \\max\\{m, p\\} \\cdot \\epsilon \\cdot \\sigma_{\\max}\n$$\n其中 $\\sigma_{\\max} = \\sigma_1$ 是 $C$ 的最大奇异值，$\\epsilon$ 是双精度浮点运算的机器ε。数值秩 $r$ 随后被计算为满足 $\\sigma_i > \\tau$ 的索引 $i$ 的数量。该过程提供了一种在存在浮点不精确性的情况下稳健估计矩阵有效秩的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _process_case(m, n, p, k_A, k_B, seed, special_case_3=False):\n    \"\"\"\n    Generates matrices for a test case, computes the product AB via two methods,\n    and returns the required analysis quadruple.\n    \n    Args:\n        m, n, p (int): Dimensions of matrices A (m,n) and B (n,p).\n        k_A, k_B (int): Ranks of the low-rank factors.\n        seed (int): Random seed for reproducibility.\n        special_case_3 (bool): Flag to trigger special construction for Test Case 3.\n        \n    Returns:\n        tuple: (error, num_rank, rank_bound, inequality_holds)\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # Construct the low-rank factors U_A, V_A, U_B, V_B\n    if not special_case_3:\n        U_A = rng.standard_normal(size=(m, k_A))\n        V_A = rng.standard_normal(size=(n, k_A))\n        U_B = rng.standard_normal(size=(n, k_B))\n        V_B = rng.standard_normal(size=(p, k_B))\n    else:\n        # Special construction for Test Case 3 to ensure V_A.T @ U_B = 0.\n        U_A = rng.standard_normal(size=(m, k_A))\n        V_B = rng.standard_normal(size=(p, k_B))\n        U_B = rng.standard_normal(size=(n, k_B))\n        \n        # Use complete QR decomposition of U_B to find an orthogonal basis for R^n.\n        # np.linalg.qr with mode='complete' returns a square orthogonal matrix Q.\n        # The first k_B columns of Q form an orthonormal basis for Col(U_B).\n        if n  k_A + k_B:\n            # This case should not happen with the given test parameters.\n            raise ValueError(\n                f\"Cannot construct V_A for special case 3: n={n} must be >= k_A+k_B={k_A+k_B}\"\n            )\n        Q, _ = np.linalg.qr(U_B, mode='complete')\n        \n        # V_A's columns are chosen from the orthogonal complement of Col(U_B).\n        # This ensures the columns of V_A are orthogonal to columns of U_B.\n        V_A = Q[:, k_B : k_B + k_A]\n\n    # Fast computation: AB_fast = U_A @ (V_A.T @ U_B) @ V_B.T\n    intermediate_product = V_A.T @ U_B\n    AB_fast = U_A @ intermediate_product @ V_B.T\n\n    # Naive computation: AB_naive = (U_A @ V_A.T) @ (U_B @ V_B.T)\n    A = U_A @ V_A.T\n    B = U_B @ V_B.T\n    AB_naive = A @ B\n\n    # 1. Compute Frobenius norm of the difference\n    e = np.linalg.norm(AB_fast - AB_naive, 'fro')\n\n    # 2. Compute the numerical rank of AB\n    singular_values = np.linalg.svd(AB_fast, compute_uv=False)\n    \n    sigma_max = 0.0\n    if singular_values.size > 0:\n        sigma_max = singular_values[0]\n\n    epsilon = np.finfo(float).eps\n    tolerance = max(m, p) * epsilon * sigma_max\n    \n    r = np.sum(singular_values > tolerance)\n\n    # 3. Compute the rank bound\n    b = min(k_A, k_B)\n\n    # 4. Check if the inequality rank(AB) = min(k_A, k_B) holds\n    q = (r = b)\n\n    return e, r, b, q\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (m, n, p, k_A, k_B, seed, special_case_3)\n        (7, 5, 6, 3, 2, 0, False),  # Test case 1\n        (8, 4, 3, 1, 1, 1, False),  # Test case 2\n        (6, 4, 5, 2, 2, 2, True),   # Test case 3\n        (5, 5, 5, 4, 3, 3, False),  # Test case 4\n    ]\n\n    results = []\n    for params in test_cases:\n        m, n, p, k_A, k_B, seed, special = params\n        result_tuple = _process_case(m, n, p, k_A, k_B, seed, special)\n        results.extend(list(result_tuple))\n\n    # Format the final output string as per requirements.\n    # The boolean values are converted to their string representations ('True'/'False').\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3563735"}, {"introduction": "虽然奇异值分解（SVD）提供了理论上最优的低秩逼近，但在实践中，我们常采用启发式算法（如交叉逼近）来高效地构造近似。然而，这些启发式方法并非万无一失。本练习通过一个精心设计的例子，揭示了一种常用启发式策略（最大体积/最大元素法）的潜在缺陷。您将分析一个特定的秩为2的矩阵，其中启发式方法选择的秩为1的近似远非最优，并量化其与最佳近似之间的误差 ([@problem_id:3563748])。这项挑战性的实践旨在培养您对算法局限性的批判性思维，这对于在复杂应用中选择和设计稳健的数值方法至关重要。", "problem": "考虑以下旨在探讨由最大体积启发式驱动的交叉或骨架近似的局限性的构造。设 $n \\geq 3$ 为一个整数，并定义向量 $u \\in \\mathbb{R}^{n}$ 和 $v \\in \\mathbb{R}^{n}$ 如下：\n$$\nu \\;=\\; \\frac{1}{\\sqrt{n-1}}\\begin{pmatrix}0 \\\\ 1 \\\\ \\vdots \\\\ 1\\end{pmatrix}, \n\\qquad\nv \\;=\\; \\frac{1}{\\sqrt{n-1}}\\begin{pmatrix}1 \\\\ \\vdots \\\\ 1 \\\\ 0\\end{pmatrix},\n$$\n使得 $u$ 的第一个分量为零，$v$ 的第 $n$ 个分量为零，所有其他分量均等于 $1/\\sqrt{n-1}$。设 $e_{1}, e_{n} \\in \\mathbb{R}^{n}$ 分别表示第一个和第 $n$ 个标准基向量。对于满足下式的标量 $s>0$ 和 $t>0$：\n$$\ns \\;\\; t \\;\\; \\frac{s}{\\,n-1\\,},\n$$\n定义矩阵\n$$\nA \\;=\\; s\\,u\\,v^{\\top} \\;+\\; t\\,e_{1}\\,e_{n}^{\\top} \\;\\in\\; \\mathbb{R}^{n \\times n}.\n$$\n假设通过最大体积启发式选择一行和一列来构造一个交叉/骨架秩-1 近似。对于 $1 \\times 1$ 的子矩阵，该启发式简化为选择 $A$ 中绝对值最大的元素。设 $(i^{\\star}, j^{\\star})$ 表示该元素的索引，并设骨架近似为\n$$\n\\widetilde{A} \\;=\\; A(:, j^{\\star})\\,\\big(A(i^{\\star}, j^{\\star})\\big)^{-1}\\,A(i^{\\star}, :),\n$$\n其中 $A(:, j)$ 表示 $A$ 的第 $j$ 列，$A(i, :)$ 表示 $A$ 的第 $i$ 行。设 $A_{1}$ 表示在算子范数（谱范数）下 $A$ 的最佳秩-1 近似，该近似通过奇异值分解（SVD）理论来理解，而无需使用问题陈述中的任何显式公式。\n\n从外积、算子范数和奇异值分解（SVD）的基本定义出发，并仅使用上面提供的构造，确定误差膨胀因子\n$$\n\\mathcal{E}(n,s,t) \\;=\\; \\frac{\\|A - \\widetilde{A}\\|_{2}}{\\|A - A_{1}\\|_{2}},\n$$\n其形式为关于 $s$ 和 $t$ 的闭式表达式。您的最终答案必须是单一的解析表达式。不要提供任何不等式或中间方程作为最终答案。不需要进行四舍五入或数值计算。", "solution": "我们首先分析矩阵 $A = s\\,u\\,v^{\\top} + t\\,e_{1}\\,e_{n}^{\\top}$ 的结构。根据构造，$u$ 和 $e_{1}$ 是正交的，因为 $u$ 的第一个分量等于 $0$，而 $e_{1}$ 除了第一个分量外所有分量都为零。类似地，$v$ 和 $e_{n}$ 是正交的，因为 $v$ 的第 $n$ 个分量等于 $0$，而 $e_{n}$ 除了第 $n$ 个分量外所有分量都为零。此外，$u$ 和 $v$ 都是单位向量，因为它们各有 $(n-1)$ 个分量等于 $1/\\sqrt{n-1}$，一个分量等于 $0$，所以 $\\|u\\|_{2} = \\|v\\|_{2} = 1$。同样地，$\\|e_{1}\\|_{2} = \\|e_{n}\\|_{2} = 1$。\n\n因此，矩阵 $A$ 是两个秩-1 外积之和，其左奇异向量是正交的（$u \\perp e_{1}$），右奇异向量也是正交的（$v \\perp e_{n}$）。这种正交性意味着 $A$ 的奇异值恰好是每一项各自的奇异值，即 $s$ 和 $t$，其余 $n-2$ 个奇异值为零。这可以通过考虑 $\\mathbb{R}^{n}$ 的左空间和右空间的正交基来证明，这些基分别以 $\\{u, e_{1}\\}$ 和 $\\{v, e_{n}\\}$ 开始，并扩展为完整的正交基。在这些基中，$A$ 的作用如下：\n$$\nA\\,v = s\\,u, \\qquad A\\,e_{n} = t\\,e_{1},\n$$\n并且将与 $\\operatorname{span}\\{v, e_{n}\\}$ 正交的向量映射到零向量。因此，$A$ 的两个非零奇异值是 $s$ 和 $t$。\n\n接下来，我们研究用于 $1 \\times 1$ 子矩阵的最大体积启发式，该方法选择 $A$ 中绝对值最大的元素。由项 $s\\,u\\,v^{\\top}$ 产生的 $A$ 的元素为\n$$\n(s\\,u\\,v^{\\top})_{ij} \\;=\\; s\\,u_{i}\\,v_{j} \\;=\\; \n\\begin{cases}\n\\displaystyle \\frac{s}{n-1},  \\text{若 } i \\geq 2 \\text{ 且 } j \\leq n-1,\\\\\n0,  \\text{若 } i = 1 \\text{ 或 } j = n.\n\\end{cases}\n$$\n由项 $t\\,e_{1}\\,e_{n}^{\\top}$ 产生的 $A$ 的元素除了在 $(1,n)$ 处等于 $t$（即 $A_{1n} = t$）外，其他地方都为零。因此，只要 $t > s/(n-1)$，$A$ 中绝对值最大的元素就位于 $(1,n)$，这由假设的不等式 $s > t > s/(n-1)$ 所保证。因此，最大体积启发式选择 $(i^{\\star}, j^{\\star}) = (1,n)$。\n\n由 $(i^{\\star}, j^{\\star}) = (1,n)$ 构造的骨架近似为\n$$\n\\widetilde{A} \\;=\\; A(:, n)\\,\\big(A(1, n)\\big)^{-1}\\,A(1, :) .\n$$\n我们显式地计算这些因子。由于 $v_{n} = 0$，列 $A(:, n)$ 没有来自 $s\\,u\\,v^{\\top}$ 的贡献，唯一的贡献来自 $t\\,e_{1}\\,e_{n}^{\\top}$：\n$$\nA(:, n) \\;=\\; t\\,e_{1}.\n$$\n类似地，由于 $u_{1} = 0$，行 $A(1, :)$ 没有来自 $s\\,u\\,v^{\\top}$ 的贡献，唯一的贡献来自 $t\\,e_{1}\\,e_{n}^{\\top}$：\n$$\nA(1, :) \\;=\\; t\\,e_{n}^{\\top}.\n$$\n并且，$A(1, n) = t$。因此，\n$$\n\\widetilde{A} \\;=\\; \\big(t\\,e_{1}\\big)\\,\\frac{1}{t}\\,\\big(t\\,e_{n}^{\\top}\\big) \\;=\\; t\\,e_{1}\\,e_{n}^{\\top}.\n$$\n我们看到，交叉/骨架近似精确地再现了尖峰分量 $t\\,e_{1}\\,e_{n}^{\\top}$，而丢弃了占主导地位的低秩分量 $s\\,u\\,v^{\\top}$。因此，近似误差为\n$$\nA - \\widetilde{A} \\;=\\; s\\,u\\,v^{\\top}.\n$$\n其算子范数等于 $s\\,u\\,v^{\\top}$ 的奇异值，即 $s$，因为 $\\|u\\|_{2} = \\|v\\|_{2} = 1$ 且秩-1 外积 $s\\,u\\,v^{\\top}$ 的算子范数为 $s$。\n\n现在考虑在算子范数下的最佳秩-1 近似 $A_{1}$。由于 $A$ 的奇异值为 $s$ 和 $t$，且 $s > t$，最佳秩-1 近似是通过保留奇异值 $s$ 及其对应的奇异向量得到的，而最优的算子范数误差等于下一个奇异值，即 $t$。因此，\n$$\n\\|A - A_{1}\\|_{2} \\;=\\; t.\n$$\n最后，误差膨胀因子为\n$$\n\\mathcal{E}(n,s,t) \\;=\\; \\frac{\\|A - \\widetilde{A}\\|_{2}}{\\|A - A_{1}\\|_{2}} \\;=\\; \\frac{s}{t}.\n$$\n通过选择任意大的 $s/t$（受约束 $t > s/(n-1)$ 的限制），这个因子可以变得任意大；例如，对于固定的 $t$，取足够大的 $n$ 可以让 $s$ 增长，同时保持 $t > s/(n-1)$。因此，所要求的闭式表达式为 $\\mathcal{E}(n,s,t) = s/t$。", "answer": "$$\\boxed{\\frac{s}{t}}$$", "id": "3563748"}]}