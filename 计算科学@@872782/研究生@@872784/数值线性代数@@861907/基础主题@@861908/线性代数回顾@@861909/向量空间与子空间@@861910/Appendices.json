{"hands_on_practices": [{"introduction": "要理解子空间，一个最基本的问题就是如何判定一个给定的向量是否位于某个子空间内。这个练习将抽象的生成空间（span）概念与具体的线性方程组求解联系起来。通过这个练习，你将通过分析矩阵的秩来判断向量成员关系，并进一步运用正交投影来量化向量到子空间的几何距离，从而加深对子空间几何意义的理解。", "problem": "设 $n \\in \\mathbb{N}$，并考虑赋有标准欧几里得内积的实向量空间 $\\mathbb{R}^{n}$。向量 $v_{1},\\dots,v_{k} \\in \\mathbb{R}^{n}$ 的张成 $\\operatorname{span}\\{v_{1},\\dots,v_{k}\\}$ 是这些向量的所有有限线性组合的集合。一个向量 $w \\in \\mathbb{R}^{n}$ 属于 $\\operatorname{span}\\{v_{1},\\dots,v_{k}\\}$ 当且仅当存在标量 $c_{1},\\dots,c_{k} \\in \\mathbb{R}$ 使得 $w = \\sum_{j=1}^{k} c_{j} v_{j}$，这等价于由以 $v_{1},\\dots,v_{k}$ 为列的矩阵构成的线性方程组有解。\n\n从这些定义以及线性代数中关于线性方程组、秩和正交投影的公认事实出发，对以下具体数据执行下列操作：\n$$\nv_{1} = \\begin{pmatrix}1 \\\\ 0 \\\\ 1 \\\\ 0\\end{pmatrix},\\quad\nv_{2} = \\begin{pmatrix}0 \\\\ 1 \\\\ 1 \\\\ 0\\end{pmatrix},\\quad\nv_{3} = \\begin{pmatrix}1 \\\\ 1 \\\\ 2 \\\\ 0\\end{pmatrix},\\quad\nw = \\begin{pmatrix}2 \\\\ -1 \\\\ 1 \\\\ 3\\end{pmatrix} \\in \\mathbb{R}^{4}.\n$$\n1. 构建表达条件 $w \\in \\operatorname{span}\\{v_{1},v_{2},v_{3}\\}$ 的线性方程组，并根据线性方程组和秩的定义及性质，通过严谨的推理来判断该方程组是否相容。\n2. 利用关于正交投影到由向量张成的子空间上的基础知识，求解 $w$ 在子空间 $V = \\operatorname{span}\\{v_{1},v_{2},v_{3}\\}$ 上的正交投影，并推导出 $w$ 到 $V$ 的欧几里得距离。\n\n将最终答案表示为 $w$ 到 $V$ 的欧几里得距离（即2-范数）的精确值，无需四舍五入。", "solution": "该问题是有效的，因为它定义明确、内容完整，并且基于线性代数的标准原理。\n\n该问题包含两部分。首先，我们判断向量 $w$ 是否位于子空间 $V = \\operatorname{span}\\{v_{1}, v_{2}, v_{3}\\}$ 中。其次，我们计算 $w$ 到 $V$ 上的正交投影，并求出 $w$ 到 $V$ 的欧几里得距离。\n\n**第一部分：线性方程组的相容性**\n\n一个向量 $w$ 属于一组向量 $\\{v_{1}, v_{2}, v_{3}\\}$ 的张成空间，当且仅当它可以表示为这些向量的线性组合。也就是说，必须存在标量 $c_{1}, c_{2}, c_{3} \\in \\mathbb{R}$ 使得：\n$$ c_{1}v_{1} + c_{2}v_{2} + c_{3}v_{3} = w $$\n这个向量方程可以写成矩阵形式的线性方程组 $Ac=w$，其中矩阵 $A$ 以向量 $v_{1}, v_{2}, v_{3}$ 为其列，$c$ 是系数向量。\n给定向量：\n$$ v_{1} = \\begin{pmatrix}1 \\\\ 0 \\\\ 1 \\\\ 0\\end{pmatrix},\\quad v_{2} = \\begin{pmatrix}0 \\\\ 1 \\\\ 1 \\\\ 0\\end{pmatrix},\\quad v_{3} = \\begin{pmatrix}1 \\\\ 1 \\\\ 2 \\\\ 0\\end{pmatrix},\\quad w = \\begin{pmatrix}2 \\\\ -1 \\\\ 1 \\\\ 3\\end{pmatrix} $$\n矩阵 $A$ 和向量 $c$ 分别是：\n$$ A = \\begin{pmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 1  1  2 \\\\ 0  0  0 \\end{pmatrix}, \\quad c = \\begin{pmatrix} c_{1} \\\\ c_{2} \\\\ c_{3} \\end{pmatrix} $$\n线性方程组相容的充要条件是系数矩阵 $A$ 的秩等于增广矩阵 $[A|w]$ 的秩。\n\n首先，我们通过将 $A$ 化为行阶梯形来确定其秩。\n$$ A = \\begin{pmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 1  1  2 \\\\ 0  0  0 \\end{pmatrix} \\xrightarrow{R_3 \\to R_3-R_1} \\begin{pmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 0  1  1 \\\\ 0  0  0 \\end{pmatrix} \\xrightarrow{R_3 \\to R_3-R_2} \\begin{pmatrix} 1  0  1 \\\\ 0  1  1 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} $$\n$A$ 的行阶梯形有两个非零行，所以 $\\operatorname{rank}(A) = 2$。秩小于向量的个数（$2  3$）这一事实表明集合 $\\{v_{1}, v_{2}, v_{3}\\}$ 是线性相关的。我们可以观察到 $v_{3} = v_{1} + v_{2}$。\n\n接下来，我们确定增广矩阵 $[A|w]$ 的秩。\n$$ [A|w] = \\begin{pmatrix} 1  0  1  2 \\\\ 0  1  1  -1 \\\\ 1  1  2  1 \\\\ 0  0  0  3 \\end{pmatrix} $$\n我们执行相同的行操作：\n$$ \\begin{pmatrix} 1  0  1  2 \\\\ 0  1  1  -1 \\\\ 1  1  2  1 \\\\ 0  0  0  3 \\end{pmatrix} \\xrightarrow{R_3 \\to R_3-R_1} \\begin{pmatrix} 1  0  1  2 \\\\ 0  1  1  -1 \\\\ 0  1  1  -1 \\\\ 0  0  0  3 \\end{pmatrix} \\xrightarrow{R_3 \\to R_3-R_2} \\begin{pmatrix} 1  0  1  2 \\\\ 0  1  1  -1 \\\\ 0  0  0  0 \\\\ 0  0  0  3 \\end{pmatrix} $$\n交换 $R_3$ 行和 $R_4$ 行以得到行阶梯形：\n$$ \\begin{pmatrix} 1  0  1  2 \\\\ 0  1  1  -1 \\\\ 0  0  0  3 \\\\ 0  0  0  0 \\end{pmatrix} $$\n$[A|w]$ 的行阶梯形有三个非零行，因此 $\\operatorname{rank}([A|w]) = 3$。\n由于 $\\operatorname{rank}(A) = 2 \\neq \\operatorname{rank}([A|w]) = 3$，该线性方程组不相容。这证明了 $w \\notin \\operatorname{span}\\{v_{1}, v_{2}, v_{3}\\}$。\n\n**第二部分：正交投影与距离**\n\n子空间 $V$ 由 $V = \\operatorname{span}\\{v_{1}, v_{2}, v_{3}\\}$ 给出。如前所述，$v_{3} = v_{1} + v_{2}$，所以 $v_{3}$ 是多余的。$V$ 的一组基是 $\\{v_{1}, v_{2}\\}$。因此，$V = \\operatorname{span}\\{v_{1}, v_{2}\\}$。\n\n$w$ 在 $V$ 上的正交投影，我们记作 $p = \\operatorname{proj}_{V}(w)$，是 $V$ 中的唯一向量，使得向量 $w - p$ 与 $V$ 中的每个向量都正交。$w$ 到 $V$ 的欧几里得距离就是 $\\|w - p\\|$。\n\n投影 $p$ 可以通过求解法方程组得到。设 $A'$ 是其列构成 $V$ 的一组基的矩阵，即 $A' = [v_{1}|v_{2}]$。\n$$ A' = \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 1  1 \\\\ 0  0 \\end{pmatrix} $$\n投影 $p$ 由公式 $p = A'(A'^{T}A')^{-1}A'^{T}w$ 给出。\n首先，我们计算格拉姆矩阵 $A'^{T}A'$：\n$$ A'^{T}A' = \\begin{pmatrix} 1  0  1  0 \\\\ 0  1  1  0 \\end{pmatrix} \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 1  1 \\\\ 0  0 \\end{pmatrix} = \\begin{pmatrix} 1\\cdot1+1\\cdot1  1\\cdot0+1\\cdot1 \\\\ 1\\cdot1+0\\cdot1  1\\cdot1+1\\cdot1 \\end{pmatrix} = \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} $$\n接下来，我们求这个矩阵的逆矩阵：\n$$ (A'^{T}A')^{-1} = \\frac{1}{(2)(2) - (1)(1)} \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} = \\frac{1}{3} \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} $$\n现在我们计算 $A'^{T}w$：\n$$ A'^{T}w = \\begin{pmatrix} 1  0  1  0 \\\\ 0  1  1  0 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ -1 \\\\ 1 \\\\ 3 \\end{pmatrix} = \\begin{pmatrix} 1\\cdot2+0\\cdot(-1)+1\\cdot1+0\\cdot3 \\\\ 0\\cdot2+1\\cdot(-1)+1\\cdot1+0\\cdot3 \\end{pmatrix} = \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix} $$\n我们现在可以求出投影 $p$。基向量的线性组合系数为 $c' = (A'^{T}A')^{-1}A'^{T}w$：\n$$ c' = \\frac{1}{3} \\begin{pmatrix} 2  -1 \\\\ -1  2 \\end{pmatrix} \\begin{pmatrix} 3 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\frac{1}{3}(6) \\\\ \\frac{1}{3}(-3) \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ -1 \\end{pmatrix} $$\n投影向量为 $p = A'c' = 2v_{1} - 1v_{2}$：\n$$ p = \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 1  1 \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 2 \\\\ -1 \\\\ 1 \\\\ 0 \\end{pmatrix} $$\n表示 $w$ 到子空间 $V$ 最短距离的向量是 $w$ 正交于 $V$ 的分量，即 $w - p$：\n$$ w - p = \\begin{pmatrix} 2 \\\\ -1 \\\\ 1 \\\\ 3 \\end{pmatrix} - \\begin{pmatrix} 2 \\\\ -1 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 3 \\end{pmatrix} $$\n$w$ 到 $V$ 的欧几里得距离是这个正交向量的范数：\n$$ \\|w - p\\| = \\left\\| \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 3 \\end{pmatrix} \\right\\| = \\sqrt{0^{2} + 0^{2} + 0^{2} + 3^{2}} = \\sqrt{9} = 3 $$\n因此，$w$ 到子空间 $V$ 的精确欧几里得距离是 $3$。", "answer": "$$ \\boxed{3} $$", "id": "3600936"}, {"introduction": "在掌握了单个子空间的基本操作后，我们可以将视野扩展到与一个线性变换相关联的完整空间结构。这个练习要求你使用奇异值分解（SVD）——数值线性代数中的核心工具——来为任意矩阵的四个基本子空间（列空间、零空间、行空间和左零空间）构造标准正交基。通过编程实践，你将有机会亲手验证线性代数基本定理所描述的优美几何关系，例如子空间之间的正交性。", "problem": "您的任务是以编程方式提取与实矩阵 $A$ 相关的四个基本子空间的标准正交基，并从数值上验证由线性代数基本定理产生的正交关系。这四个基本子空间是列空间 $\\mathcal{R}(A)$、零空间 $\\mathcal{N}(A)$、行空间 $\\mathcal{R}(A^\\top)$ 和左零空间 $\\mathcal{N}(A^\\top)$。我们从以下定义开始：$\\mathbb{R}$ 上向量空间的子空间是任何对加法和标量乘法封闭的子集；列空间 $\\mathcal{R}(A)$ 是 $\\{A x : x \\in \\mathbb{R}^n\\}$；零空间 $\\mathcal{N}(A)$ 是 $\\{x \\in \\mathbb{R}^n : A x = 0\\}$；行空间 $\\mathcal{R}(A^\\top)$ 是 $\\{A^\\top y : y \\in \\mathbb{R}^m\\}$；左零空间 $\\mathcal{N}(A^\\top)$ 是 $\\{y \\in \\mathbb{R}^m : A^\\top y = 0\\}$。您可以使用奇异值分解 (SVD) 或 QR 分解 (QR)，但标准正交基的提取必须通过这些分解得到数值上的证明。\n\n根据奇异值分解 (SVD)，如果 $A \\in \\mathbb{R}^{m \\times n}$，则 $A = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 具有标准正交列（即为正交矩阵），而 $\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是对角矩阵，其对角线上的非负奇异值为 $\\sigma_1 \\ge \\sigma_2 \\ge \\cdots \\ge \\sigma_{\\min(m,n)} \\ge 0$。根据由容差决定的数值秩 $r$，将 $U$ 和 $V$ 划分为 $U = [U_r \\; U_0]$ 和 $V = [V_r \\; V_0]$。那么 $\\mathcal{R}(A)$ 由 $U_r$ 的列张成，$\\mathcal{R}(A^\\top)$ 由 $V_r$ 的列张成，$\\mathcal{N}(A)$ 由 $V_0$ 的列张成，$\\mathcal{N}(A^\\top)$ 由 $U_0$ 的列张成。基本正交关系是 $\\mathcal{N}(A)$ 与 $\\mathcal{R}(A^\\top)$ 正交，以及 $\\mathcal{N}(A^\\top)$ 与 $\\mathcal{R}(A)$ 正交。\n\n您的程序必须：\n- 对于每个测试矩阵 $A$，计算其 SVD $A = U \\Sigma V^\\top$ 并使用以下容差来确定数值秩 $r$：\n$$\\tau = \\max(m,n) \\, \\sigma_{\\max} \\, \\epsilon,$$\n其中 $m \\times n$ 是 $A$ 的形状，$\\sigma_{\\max}$ 是 $A$ 的最大奇异值，$\\epsilon$ 是双精度机器精度（$\\epsilon \\approx 2.22 \\times 10^{-16}$）。\n- 为四个基本子空间构建标准正交基：\n    1. $\\mathcal{R}(A)$ 基：$U_r \\in \\mathbb{R}^{m \\times r}$ 的列。\n    2. $\\mathcal{R}(A^\\top)$ 基：$V_r \\in \\mathbb{R}^{n \\times r}$ 的列。\n    3. $\\mathcal{N}(A)$ 基：$V_0 \\in \\mathbb{R}^{n \\times (n-r)}$ 的列。\n    4. $\\mathcal{N}(A^\\top)$ 基：$U_0 \\in \\mathbb{R}^{m \\times (m-r)}$ 的列。\n- 使用弗罗贝尼乌斯范数，在数值上验证每个基的标准正交性以及子空间间的正交关系：\n    - 对于任何具有 $k$ 列的基矩阵 $Q$，通过计算 $\\|Q^\\top Q - I_k\\|_F$ 来检验 $Q^\\top Q \\approx I_k$。\n    - 检验 $\\|V_r^\\top V_0\\|_F \\approx 0$ 和 $\\|U_r^\\top U_0\\|_F \\approx 0$。\n- 此外，确认截断重构 $A_r = U_r \\Sigma_r V_r^\\top$ 以较小的相对残差 $\\|A - A_r\\|_F / \\|A\\|_F$ 近似于 $A$（如果 $\\|A\\|_F = 0$，则使用绝对残差 $\\|A - A_r\\|_F$）。\n- 验证维度等式 $r + \\dim(\\mathcal{N}(A)) = n$ 和 $r + \\dim(\\mathcal{N}(A^\\top)) = m$ 为精确的整数等式。\n\n对于每个测试矩阵，将上述所有残差范数（标准正交性残差、正交性残差和重构残差）中的最大值汇总为一个浮点数，并附上一个表示维度等式是否成立的布尔值。最终输出必须将所有提供的测试用例的结果汇总到一行中，格式为方括号括起来的逗号分隔列表，顺序如下：\n$$[e_1, b_1, e_2, b_2, e_3, b_3, e_4, b_4],$$\n其中 $e_k$ 是第 $k$ 个测试矩阵的最大残差浮点数，$b_k$ 是对应的布尔值。\n\n测试矩阵套件（必须严格按照规定使用）：\n1. 一个高的、满列秩的情况（$4 \\times 3$）：\n$$\nA_1 = \\begin{bmatrix}\n2  -1  0 \\\\\n0  1  3 \\\\\n4  -2  1 \\\\\n1  0  -1\n\\end{bmatrix}.\n$$\n2. 一个宽的、有行相关性的秩亏情况（$3 \\times 4$）：\n$$\nA_2 = \\begin{bmatrix}\n1  0  1  1 \\\\\n0  1  1  2 \\\\\n1  1  2  3\n\\end{bmatrix}.\n$$\n3. 一个方形的、秩为 3 的情况（$5 \\times 5$），其构造使得两列是前三列的线性组合：\n设列向量为\n$$\nc_1 = \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 2 \\\\ 3 \\end{bmatrix},\\quad\nc_2 = \\begin{bmatrix} 0 \\\\ 1 \\\\ 2 \\\\ -1 \\\\ 0 \\end{bmatrix},\\quad\nc_3 = \\begin{bmatrix} 2 \\\\ -1 \\\\ 0 \\\\ 1 \\\\ 1 \\end{bmatrix},\\quad\nc_4 = c_1 + c_2,\\quad\nc_5 = c_2 - c_3,\n$$\n从而\n$$\nA_3 = \\begin{bmatrix}\n1  0  2  1  -2 \\\\\n0  1  -1  1  2 \\\\\n1  2  0  3  2 \\\\\n2  -1  1  1  -2 \\\\\n3  0  1  3  -1\n\\end{bmatrix}.\n$$\n4. 一个近乎秩亏的对角矩阵情况（$4 \\times 4$），其中一个奇异值低于容差：\n$$\nA_4 = \\operatorname{diag}\\!\\left(10,\\; 1\\times 10^{-16},\\; 3,\\; 1\\right).\n$$\n\n角度单位不适用。没有出现物理单位，因此不需要。您的程序必须只产生一行输出，其中包含如上所述的、用方括号括起来的逗号分隔列表形式的结果，不带任何多余的空格或文本。", "solution": "该问题要求以编程方式提取实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的四个基本子空间（列空间 $\\mathcal{R}(A)$、零空间 $\\mathcal{N}(A)$、行空间 $\\mathcal{R}(A^\\top)$ 和左零空间 $\\mathcal{N}(A^\\top)$）的标准正交基，并进行数值验证。这个任务是线性代数基本定理的直接应用，该定理建立了这些子空间之间的维度和正交关系。奇异值分解 (SVD) 为计算这些基提供了一个强大且数值稳定的工具。\n\n矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的 SVD 是一个分解 $A = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵，对角线上的非负实数（称为奇异值）按降序排列：$\\sigma_1 \\ge \\sigma_2 \\ge \\cdots \\ge \\sigma_p \\ge 0$，其中 $p = \\min(m, n)$。\n\n其核心原理是 $U$ 和 $V$ 的列（奇异向量）为四个基本子空间提供了标准正交基。张成这些空间及其正交补空间的向量之间的区别由数值秩 $r$ 决定。秩 $r$ 是“显著”大于零的奇异值的数量。在数值计算中，我们使用容差 $\\tau$ 来定义这一点。问题为该容差指定了一个标准选择：\n$$\n\\tau = \\max(m, n) \\cdot \\sigma_{\\max} \\cdot \\epsilon,\n$$\n其中 $\\sigma_{\\max}$ 是最大奇异值 $\\sigma_1$，$\\epsilon$ 是双精度浮点运算的机器精度。数值秩 $r$ 则是大于 $\\tau$ 的奇异值 $\\sigma_i$ 的数量。\n\n给定秩 $r$，我们划分正交矩阵 $U$ 和 $V$。设 $U$ 的列为 $u_1, \\dots, u_m$，$V$ 的列为 $v_1, \\dots, v_n$。我们形成以下划分：\n- $U_r = [u_1, \\dots, u_r] \\in \\mathbb{R}^{m \\times r}$\n- $U_0 = [u_{r+1}, \\dots, u_m] \\in \\mathbb{R}^{m \\times (m-r)}$\n- $V_r = [v_1, \\dots, v_r] \\in \\mathbb{R}^{n \\times r}$\n- $V_0 = [v_{r+1}, \\dots, v_n] \\in \\mathbb{R}^{n \\times (n-r)}$\n\nSVD 直接给出了四个基本子空间的标准正交基：\n1.  **列空间 $\\mathcal{R}(A)$**：一个标准正交基由 $U_r$ 的列给出。其维度为 $r$。\n2.  **左零空间 $\\mathcal{N}(A^\\top)$**：一个标准正交基由 $U_0$ 的列给出。其维度为 $m-r$。\n3.  **行空间 $\\mathcal{R}(A^\\top)$**：一个标准正交基由 $V_r$ 的列给出。其维度为 $r$。\n4.  **零空间 $\\mathcal{N}(A)$**：一个标准正交基由 $V_0$ 的列给出。其维度为 $n-r$。\n\n线性代数基本定理确立了 $\\mathcal{R}(A)$ 是 $\\mathcal{N}(A^\\top)$ 在 $\\mathbb{R}^m$ 中的正交补，而 $\\mathcal{R}(A^\\top)$ 是 $\\mathcal{N}(A)$ 在 $\\mathbb{R}^n$ 中的正交补。我们的算法将从数值上验证这些性质。\n\n对于每个测试矩阵 $A$ 的算法流程如下：\n1.  计算完全 SVD $A = U \\Sigma V^\\top$。矩阵 $U$ 和 $V$ 必须是方阵（正交），而不是半正交矩阵。\n2.  通过计算超过容差 $\\tau$ 的奇异值 $s_i$ 的数量来确定数值秩 $r$。\n3.  根据秩 $r$ 将 $U$ 和 $V$ 划分为 $U_r, U_0, V_r, V_0$。\n4.  进行数值验证，并使用弗罗贝尼乌斯范数 $\\| \\cdot \\|_F$ 计算它们的残差：\n    a. **基的标准正交性**：对于每个非空基矩阵 $Q \\in \\{U_r, U_0, V_r, V_0\\}$，计算残差 $\\|Q^\\top Q - I\\|_F$。这里的 $I$ 是相应大小的单位矩阵。\n    b. **子空间的正交性**：计算残差 $\\|U_r^\\top U_0\\|_F$ 和 $\\|V_r^\\top V_0\\|_F$。这些值代表了一个空间与其正交补空间的基向量之间的点积，其结果应接近于零。\n    c. **重构精度**：计算截断 SVD 重构 $A_r = U_r \\Sigma_r V_r^\\top$，其中 $\\Sigma_r$ 是由前 $r$ 个奇异值构成的 $r \\times r$ 对角矩阵。计算相对重构误差 $\\|A - A_r\\|_F / \\|A\\|_F$。\n5.  将维度定理（秩-零度定理）的恒等式 $r + \\dim(\\mathcal{N}(A)) = n$ 和 $r + \\dim(\\mathcal{N}(A^\\top)) = m$ 作为精确整数等式进行验证。根据我们的构造，$\\dim(\\mathcal{N}(A))$ 是 $V_0$ 的列数，即 $n-r$，而 $\\dim(\\mathcal{N}(A^\\top))$ 是 $U_0$ 的列数，即 $m-r$。因此，检验变为 $r + (n-r) = n$ 和 $r + (m-r) = m$，这在代数上是重言式。通过编程对其进行验证，可以确认矩阵划分的实现是正确的。\n6.  将矩阵 $A_k$ 的结果汇总为一个序对 $(e_k, b_k)$，其中 $e_k$ 是所有计算出的浮点残差中的最大值，$b_k$ 是维度等式检查的布尔结果。\n\n此流程将应用于所提供的四个测试矩阵中的每一个。最终输出将是一个列表，其中连接了所有测试用例的 $(e_k, b_k)$ 序对。", "answer": "```python\nimport numpy as np\n\ndef analyze_matrix(A):\n    \"\"\"\n    Analyzes a matrix A to find its four fundamental subspaces,\n    validates their properties, and returns aggregated error metrics.\n    \"\"\"\n    m, n = A.shape\n    \n    # Step 1: Compute SVD\n    # full_matrices=True is essential to get square U and V for partitioning.\n    try:\n        U, s, Vt = np.linalg.svd(A, full_matrices=True)\n    except np.linalg.LinAlgError:\n        # Handle cases where SVD does not converge, though unlikely for these examples.\n        return float('inf'), False\n\n    # Initialize a list to store all computed numerical residuals.\n    residuals = []\n\n    # Step 2: Determine numerical rank\n    # s is sorted in descending order.\n    # Handle the case of a zero matrix where s would be empty or all zeros.\n    s_max = s[0] if len(s) > 0 else 0.0\n    eps = np.finfo(float).eps\n    tau = max(m, n) * s_max * eps\n    r = np.sum(s > tau)\n    \n    # Step 3: Partition U and V based on rank r\n    V = Vt.T\n    Ur = U[:, :r]\n    U0 = U[:, r:]\n    Vr = V[:, :r]\n    V0 = V[:, r:]\n\n    # Step 4a: Check orthonormality of each basis\n    # Q^T Q should be close to I_k.\n    # The check is only performed if the basis is non-empty (k > 0).\n    if Ur.shape[1] > 0:\n        residuals.append(np.linalg.norm(Ur.T @ Ur - np.eye(r), 'fro'))\n    if U0.shape[1] > 0:\n        residuals.append(np.linalg.norm(U0.T @ U0 - np.eye(m - r), 'fro'))\n    if Vr.shape[1] > 0:\n        residuals.append(np.linalg.norm(Vr.T @ Vr - np.eye(r), 'fro'))\n    if V0.shape[1] > 0:\n        residuals.append(np.linalg.norm(V0.T @ V0 - np.eye(n - r), 'fro'))\n\n    # Step 4b: Check orthogonality between subspaces\n    # These products should be close to zero matrices. numpy.linalg.norm handles\n    # products involving empty matrices correctly (norm is 0).\n    residuals.append(np.linalg.norm(Ur.T @ U0, 'fro'))\n    residuals.append(np.linalg.norm(Vr.T @ V0, 'fro'))\n\n    # Step 4c: Check reconstruction accuracy\n    # Ar = Ur @ diag(s_r) @ Vr.T\n    if r > 0:\n        Ar = Ur @ np.diag(s[:r]) @ Vr.T\n    else: # If rank is 0, A is the zero matrix\n        Ar = np.zeros_like(A, dtype=float)\n        \n    norm_A = np.linalg.norm(A, 'fro')\n    if norm_A == 0:\n        reconstruction_resid = np.linalg.norm(A - Ar, 'fro')\n    else:\n        reconstruction_resid = np.linalg.norm(A - Ar, 'fro') / norm_A\n    residuals.append(reconstruction_resid)\n\n    # Step 5: Verify dimension equalities\n    dim_N_A = V0.shape[1]\n    dim_N_At = U0.shape[1]\n    dim_check1 = (r + dim_N_A == n)\n    dim_check2 = (r + dim_N_At == m)\n    b_k = dim_check1 and dim_check2\n\n    # Step 6: Aggregate results\n    # If residuals list is empty (can happen for trivial cases), max would error.\n    e_k = max(residuals) if residuals else 0.0\n\n    return e_k, b_k\n\ndef solve():\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [2, -1, 0],\n        [0, 1, 3],\n        [4, -2, 1],\n        [1, 0, -1]\n    ], dtype=float)\n\n    A2 = np.array([\n        [1, 0, 1, 1],\n        [0, 1, 1, 2],\n        [1, 1, 2, 3]\n    ], dtype=float)\n\n    c1 = np.array([1, 0, 1, 2, 3])\n    c2 = np.array([0, 1, 2, -1, 0])\n    c3 = np.array([2, -1, 0, 1, 1])\n    c4 = c1 + c2\n    c5 = c2 - c3\n    A3 = np.vstack([c1, c2, c3, c4, c5]).T\n\n    A4 = np.diag([10.0, 1e-16, 3.0, 1.0])\n\n    test_cases = [A1, A2, A3, A4]\n\n    results = []\n    for case in test_cases:\n        e_k, b_k = analyze_matrix(case)\n        results.append(e_k)\n        results.append(b_k)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3600957"}, {"introduction": "这项练习将我们带入一个更高级的挑战，它建立在前两个练习的基础之上。在许多高级应用中，计算两个子空间（例如一个列空间与一个零空间）的交集是一个常见任务。这个练习不仅要求你设计一个稳健的数值算法来完成这项任务，更关键的是，它还引导你分析算法对输入数据扰动的敏感性，从而引入数值稳定性和误差界这一至关重要的概念。", "problem": "设计并实现一个有理论依据的数值算法，并附带一个可计算的扰动界，以近似计算给定实矩阵 $\\,A\\in\\mathbb{R}^{m\\times n}\\,$ 和 $\\,B\\in\\mathbb{R}^{p\\times m}\\,$ 的交子空间 $\\,\\mathcal{R}(A)\\cap \\mathcal{N}(B)\\,$。您的程序必须产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，条目必须是一个布尔值，指示观测到的精确交子空间与计算出的交子空间之间的最大主夹角正弦距离是否小于或等于理论推导出的上界。在本问题中，角度是无量纲的；不涉及物理单位。\n\n从值域和零空间的核心定义以及正交投影算子的标准性质出发。使用以下基本基础：\n- 值域 $\\mathcal{R}(A)$ 是集合 $\\{Ax : x\\in\\mathbb{R}^n\\}$，零空间 $\\mathcal{N}(B)$ 是集合 $\\{y\\in\\mathbb{R}^m : By=0\\}$。\n- 子空间 $\\,\\mathcal{S}\\subset\\mathbb{R}^m\\,$ 的一个标准正交基可以由一个矩阵 $\\,Q\\in\\mathbb{R}^{m\\times r}\\,$ 表示，其中 $\\,Q^\\top Q=I_r\\,$ 且 $\\,\\mathcal{S}=\\mathcal{R}(Q)$。\n- 到 $\\,\\mathcal{R}(Q)\\,$ 上的正交投影算子是 $\\,P=QQ^\\top$。\n- 两个子空间之间的距离由谱范数 $\\,\\|P_1-P_2\\|_2$ 量化，其中 $\\,P_1\\,$ 和 $\\,P_2\\,$ 是它们的正交投影算子。该范数等于 $\\,\\sin\\Theta\\,$ 的算子范数，其中 $\\,\\Theta\\,$ 是主夹角的对角矩阵。\n- 奇异值分解 (SVD) 是一种因子分解 $\\,M=U\\Sigma V^\\top\\,$，其中 $\\,U,V\\,$ 是正交的，$\\,\\Sigma\\,$ 是非负对角矩阵。薄奇异值分解提取非零奇异值。最小正奇异值提供了一个谱隙。QR 分解是一种因子分解 $\\,A=QR\\,$，其中 $\\,Q\\,$ 是正交的，$\\,R\\,$ 是上三角矩阵；列主元 QR 分解选择一个置换来揭示数值秩。\n\n您的任务是：\n1. 从第一性原理出发推导一个算法，该算法使用 $\\,A\\,$ 的列主元 QR 分解获得 $\\,\\mathcal{R}(A)$ 的一个标准正交基 $\\,Q_A\\,$，然后使用 $\\,B Q_A\\,$ 的 SVD 获得 $\\,\\mathcal{R}(A)\\cap\\mathcal{N}(B)$ 的一个标准正交基。推导必须从恒等式\n$$\n\\mathcal{R}(A)\\cap\\mathcal{N}(B) \\;=\\; \\{\\,Q_A z : z\\in\\mathbb{R}^r,\\; BQ_A z=0\\,\\},\n$$\n开始，并且必须仅依赖于上面列出的基本性质。\n2. 给定扰动 $\\,\\Delta A\\,$ 和 $\\,\\Delta B\\,$，定义扰动后的量 $\\,\\widehat{A}=A+\\Delta A\\,$、$\\,\\widehat{B}=B+\\Delta B\\,$、$\\,\\mathcal{R}(\\widehat{A})\\,$ 的基 $\\,Q_{\\widehat{A}}\\,$ 和 $\\,\\widehat{Q}_A\\,$，以及矩阵 $\\,M=BQ_A\\,$ 和 $\\,\\widehat{M}=\\widehat{B}Q_{\\widehat{A}}\\,$。令 $\\,\\gamma\\,$ 表示 $\\,M\\,$ 的最小正奇异值，令 $\\,\\|\\widehat{M}-M\\|_2\\,$ 为 $\\,M\\,$ 中扰动的谱范数。令 $\\,d_A=\\|Q_AQ_A^\\top - Q_{\\widehat{A}}Q_{\\widehat{A}}^\\top\\|_2\\,$. 使用经过充分检验的 SVD 不变子空间的子空间扰动理论，将精确交子空间与计算出的交子空间之间的距离界定为一个可计算的量，形式如下：\n$$\n\\mathrm{Bound} \\;=\\; \\min\\Bigl(1,\\; d_A \\;+\\; \\frac{\\|\\widehat{M}-M\\|_2}{\\gamma}\\Bigr),\n$$\n在标准的分离条件 $\\,\\gamma0\\,$ 下。如果 $\\,M\\,$ 没有正奇异值，则设 $\\,\\gamma=+\\infty\\,$ 并将该分数解释为 $\\,0\\,$. 您必须论证为何这样的界可以从基本基础和 SVD 的子空间扰动理论中得出。\n3. 将上述内容实现为一个独立的程序，对于下面提供的每个测试用例，计算：\n   - 精确交子空间 $\\,\\mathcal{R}(A)\\cap\\mathcal{N}(B)\\,$ 的一个标准正交基 $\\,U_\\star\\,$。\n   - 计算出的交子空间 $\\,\\mathcal{R}(\\widehat{A})\\cap\\mathcal{N}(\\widehat{B})\\,$ 的一个标准正交基 $\\,\\widehat{U}\\,$。\n   - 实际的子空间误差 $\\,\\|U_\\star U_\\star^\\top - \\widehat{U}\\widehat{U}^\\top\\|_2\\,$.\n   - 上述描述的界，其中 $\\,d_A\\,$、$\\,\\|\\widehat{M}-M\\|_2\\,$ 和 $\\,\\gamma\\,$ 按规定计算。\n   - 一个布尔值，指示实际误差是否小于或等于该界（在数值容差范围内）。\n使用固定的 SVD 阈值 $\\,\\tau=10^{-8}\\,$ 来决定在形成零空间时哪些奇异值被视为数值零。所有计算都应在实数算术中进行。\n\n测试套件。对于每种情况，请完全按照指定使用给定的 $\\,A\\,$、$\\,B\\,$、$\\,\\Delta A\\,$ 和 $\\,\\Delta B\\,$。所有数字都是无量纲的实数。矩阵按行给出，列被连接起来。\n\n- 情况 $\\,1\\,$ ($\\,m=6\\,$, $\\,n=3\\,$, $\\,p=2\\,$):\n  $$\n  A=\\begin{bmatrix}\n  1  0  0\\\\\n  1  1  0\\\\\n  0  1  1\\\\\n  0  0  1\\\\\n  0  0  0\\\\\n  0  0  0\n  \\end{bmatrix},\\quad\n  B=\\begin{bmatrix}\n  1  -1  0  0  0  0\\\\\n  0  1  -1  0  0  0\n  \\end{bmatrix},\n  $$\n  $$\n  \\Delta A=10^{-3}\\!\\cdot\\!\\begin{bmatrix}\n  0  2  -1\\\\\n  -1  0.5  0\\\\\n  0  0  1.5\\\\\n  1  -0.5  0\\\\\n  0.2  -0.1  0.3\\\\\n  -0.2  0.1  -0.3\n  \\end{bmatrix},\\quad\n  \\Delta B=10^{-3}\\!\\cdot\\!\\begin{bmatrix}\n  0.5  -0.2  0.1  0  0  0\\\\\n  -0.3  0.4  -0.1  0  0  0\n  \\end{bmatrix}.\n  $$\n\n- 情况 $\\,2\\,$ ($\\,m=6\\,$, $\\,n=3\\,$, $\\,p=3\\,$):\n  $$\n  A=\\begin{bmatrix}\n  1  0  0\\\\\n  1  1  0\\\\\n  0  1  1\\\\\n  0  0  1\\\\\n  0  0  0\\\\\n  0  0  0\n  \\end{bmatrix},\\quad\n  B=\\begin{bmatrix}\n  1  0  0  0  0  0\\\\\n  0  1  0  0  0  0\\\\\n  0  0  1  0  0  0\n  \\end{bmatrix},\n  $$\n  $$\n  \\Delta A=5\\cdot 10^{-4}\\!\\cdot\\!\\begin{bmatrix}\n  0  2  -1\\\\\n  -1  0.5  0\\\\\n  0  0  1.5\\\\\n  1  -0.5  0\\\\\n  0.2  -0.1  0.3\\\\\n  -0.2  0.1  -0.3\n  \\end{bmatrix},\\quad\n  \\Delta B=10^{-3}\\!\\cdot\\!\\begin{bmatrix}\n  0.2  -0.1  0.05  0  0  0\\\\\n  -0.05  0.1  -0.02  0  0  0\\\\\n  0.03  -0.04  0.02  0  0  0\n  \\end{bmatrix}.\n  $$\n\n- 情况 $\\,3\\,$ (接近奇异的谱隙; $\\,m=6\\,$, $\\,n=3\\,$, $\\,p=2\\,$):\n  $$\n  A=\\begin{bmatrix}\n  1  0  0\\\\\n  1  1  0\\\\\n  0  1  1\\\\\n  0  0  1\\\\\n  0  0  0\\\\\n  0  0  0\n  \\end{bmatrix},\\quad\n  B=\\begin{bmatrix}\n  1  -1  0  0  0  0\\\\\n  1  -1+10^{-3}  -10^{-3}  0  0  0\n  \\end{bmatrix},\n  $$\n  $$\n  \\Delta A=10^{-3}\\!\\cdot\\!\\begin{bmatrix}\n  0.1  -0.2  0.1\\\\\n  -0.1  0.2  -0.1\\\\\n  0.05  0.05  -0.1\\\\\n  -0.05  0.1  0.05\\\\\n  0.01  -0.02  0.03\\\\\n  -0.01  0.02  -0.03\n  \\end{bmatrix},\\quad\n  \\Delta B=5\\cdot 10^{-4}\\!\\cdot\\!\\begin{bmatrix}\n  -0.1  0.05  -0.02  0  0  0\\\\\n  0.08  -0.04  0.01  0  0  0\n  \\end{bmatrix}.\n  $$\n\n- 情况 $\\,4\\,$ ($\\,m=5\\,$, $\\,n=2\\,$, $\\,p=1\\,$):\n  $$\n  A=\\begin{bmatrix}\n  1  0\\\\\n  0  1\\\\\n  0  0\\\\\n  1  1\\\\\n  0  1\n  \\end{bmatrix},\\quad\n  B=\\begin{bmatrix}\n  1  1  0  0  0\n  \\end{bmatrix},\n  $$\n  $$\n  \\Delta A=10^{-3}\\!\\cdot\\!\\begin{bmatrix}\n  0.2  -0.1\\\\\n  -0.1  0.3\\\\\n  0.05  -0.02\\\\\n  -0.2  0.1\\\\\n  0.1  -0.05\n  \\end{bmatrix},\\quad\n  \\Delta B=10^{-3}\\!\\cdot\\!\\begin{bmatrix}\n  -0.2  0.1  0  0  0\n  \\end{bmatrix}.\n  $$\n\n角度单位说明。主夹角是算法内部的，无需直接报告；程序必须计算和比较子空间距离 $\\,\\|P_\\star-\\widehat{P}\\|_2\\,$，这些是 $[0,1]$ 范围内的实数，没有单位。\n\n最终输出格式。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $\\,r_i\\,$ 是一个布尔值，指示实际子空间误差是否小于或等于为测试用例 $\\,i\\,$ 计算的界。\n\n实现约束。使用列主元 QR 分解（首次出现定义：Column Pivoted QR factorization (CPQR)）来提取 $\\,Q_A\\,$，并使用奇异值分解 (SVD) 进行零空间步骤。在将奇异值分类为零时，使用固定的数值零阈值 $\\,\\tau=10^{-8}\\,$。所有计算都应是确定性的，并使用给定的矩阵。", "solution": "该问题被评估为**有效**。这是一个数值线性代数领域内提法恰当、有科学依据的问题。它是自洽的、客观的，并且其要求在数学上和计算上都是可行的。解答过程如下。\n\n### 1. 数值算法的推导\n\n目标是给定矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{p \\times m}$，计算两个子空间交集 $\\mathcal{S} = \\mathcal{R}(A) \\cap \\mathcal{N}(B)$ 的一个标准正交基。\n\n**步骤 1：值域 $\\mathcal{R}(A)$ 的标准正交基**\n\n一个向量 $y \\in \\mathbb{R}^m$ 只有当它属于 $\\mathcal{R}(A)$ 时，才可能在交集 $\\mathcal{S}$ 中。因此，任何这样的 $y$ 都可以表示为 $\\mathcal{R}(A)$ 的基向量的线性组合。我们首先构造 $\\mathcal{R}(A)$ 的一个标准正交基。\n\n问题指定使用 $A$ 的列主元 QR (CPQR) 分解，其形式为 $AP = QR$，其中 $P \\in \\mathbb{R}^{n \\times n}$ 是一个置换矩阵，$Q \\in \\mathbb{R}^{m \\times m}$ 是一个正交矩阵，$R \\in \\mathbb{R}^{m \\times n}$ 是一个上三角矩阵。$A$ 的值域与 $AP$ 的值域相同，即 $\\mathcal{R}(QR)$。由于 $R$ 是上三角矩阵，其前 $r = \\mathrm{rank}(A)$ 列是线性无关的（假设置换 $P$ 是这样排列的）。$\\mathcal{R}(QR)$ 由 $Q$ 的前 $r$ 列张成。\n\n设 $r$ 为 $A$ 的数值秩，由 $R$ 的对角线上绝对值大于给定容差 $\\tau$ 的元素数量确定。那么 $\\mathcal{R}(A)$ 的一个标准正交基由 $Q$ 的前 $r$ 列给出。设这个基由矩阵 $Q_A \\in \\mathbb{R}^{m \\times r}$ 表示，其中 $Q_A = Q[:, :r]$。根据构造，有 $Q_A^\\top Q_A = I_r$ 和 $\\mathcal{R}(A) = \\mathcal{R}(Q_A)$。\n\n**步骤 2：交集的刻画**\n\n任何向量 $y \\in \\mathcal{R}(A)$ 都可以唯一地写为 $y = Q_A z$，其中 $z \\in \\mathbb{R}^r$ 是某个坐标向量。$y$ 同时位于零空间 $\\mathcal{N}(B)$ 的条件是 $By=0$。代入 $y$ 的表达式，我们得到：\n$$\nB(Q_A z) = 0 \\implies (BQ_A)z = 0\n$$\n这个方程表明，一个交集向量（在基 $Q_A$ 下）的坐标向量 $z$ 必须位于矩阵 $M = BQ_A \\in \\mathbb{R}^{p \\times r}$ 的零空间中。\n因此，寻找交集 $\\mathcal{R}(A) \\cap \\mathcal{N}(B)$ 的问题被转化为寻找 $M$ 的零空间。问题陈述中给出的恒等式 $\\mathcal{R}(A)\\cap\\mathcal{N}(B) = \\{Q_A z : z\\in\\mathbb{R}^r,\\; BQ_A z=0\\,\\}$，在此被正式确立为算法的核心。\n\n**步骤 3：零空间 $\\mathcal{N}(M)$ 的标准正交基**\n\n问题指定使用奇异值分解 (SVD) 来找到 $M$ 的零空间。设 $M$ 的 SVD 为 $M = U_M \\Sigma_M V_M^\\top$，其中 $U_M$ 和 $V_M$ 是正交矩阵，$\\Sigma_M$ 是奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$ 的对角矩阵。\n\n$M$ 的零空间由 $V_M$ 中对应于零奇异值的右奇异向量张成。在数值上，我们认为奇异值 $\\sigma_i \\le \\tau$ 为零，其中 $\\tau$ 是指定的阈值。设 $k$ 为 $M$ 的数值秩，其定义域的维数为 $r$。那么，零空间 $\\mathcal{N}(M)$ 的维数是 $d_{null} = r-k$。$\\mathcal{N}(M)$ 的一个标准正交基由 $V_M$ 的最后 $d_{null}$ 列组成。设这个基由矩阵 $Z \\in \\mathbb{R}^{r \\times d_{null}}$ 表示。\n\n**步骤 4：交子空间 $\\mathcal{S}$ 的标准正交基**\n\n如前所述，交集中的向量形式为 $y = Q_A z$，其中 $z \\in \\mathcal{N}(M)$。由于任何 $z \\in \\mathcal{N}(M)$ 都可以写为 $z = Zc$（对于某个坐标向量 $c \\in \\mathbb{R}^{d_{null}}$），交集中的向量形式为 $y = Q_A(Zc) = (Q_A Z) c$。这表明交子空间 $\\mathcal{S}$ 是矩阵 $U_\\star = Q_A Z$ 的值域。\n\n矩阵 $U_\\star \\in \\mathbb{R}^{m \\times d_{null}}$ 构成了 $\\mathcal{S}$ 的一个基。我们验证这个基是标准正交的：\n$$\nU_\\star^\\top U_\\star = (Q_A Z)^\\top (Q_A Z) = Z^\\top Q_A^\\top Q_A Z = Z^\\top I_r Z = Z^\\top Z = I_{d_{null}}\n$$\n倒数第二个等式成立是因为 $Q_A$ 的列是标准正交的，最后一个等式成立是因为 $Z$ 的列（$V_M$ 的列的子集）是标准正交的。因此，$U_\\star = Q_A Z$ 是交子空间 $\\mathcal{R}(A) \\cap \\mathcal{N}(B)$ 的一个标准正交基。\n\n### 2. 扰动界的论证\n\n我们被要求论证精确交集 $\\mathcal{S} = \\mathcal{R}(A) \\cap \\mathcal{N}(B)$ 与扰动后交集 $\\widehat{\\mathcal{S}} = \\mathcal{R}(\\widehat{A}) \\cap \\mathcal{N}(\\widehat{B})$ 之间的子空间距离上界：\n$$\n\\|P_\\mathcal{S} - P_{\\widehat{\\mathcal{S}}}\\|_2 \\le \\mathrm{Bound} = \\min\\left(1, d_A + \\frac{\\|\\widehat{M}-M\\|_2}{\\gamma}\\right)\n$$\n其中 $P_\\mathcal{S}$ 和 $P_{\\widehat{\\mathcal{S}}}$ 分别是到 $\\mathcal{S}$ 和 $\\widehat{\\mathcal{S}}$ 上的正交投影算子。这里 $d_A = \\|Q_A Q_A^\\top - Q_{\\widehat{A}} Q_{\\widehat{A}}^\\top\\|_2$ 是 $\\mathcal{R}(A)$ 和 $\\mathcal{R}(\\widehat{A})$ 之间的距离，$M=BQ_A$，$\\widehat{M}=\\widehat{B}Q_{\\widehat{A}}$，而 $\\gamma$ 是 $M$ 的最小正奇异值。\n\n这个界可以通过将总扰动分解为两个阶段并应用标准的子空间扰动定理来论证。在此推导中，我们假设 $A$ 和 $\\widehat{A}$ 的秩相等，因此 $Q_A$ 和 $Q_{\\widehat{A}}$ 具有相同数量的列 $r$。\n\n1.  **投影算子表示**：从算法推导中，投影算子为 $P_\\mathcal{S} = U_\\star U_\\star^\\top = (Q_A Z)(Q_A Z)^\\top = Q_A Z Z^\\top Q_A^\\top$，类似地 $P_{\\widehat{\\mathcal{S}}} = Q_{\\widehat{A}} \\widehat{Z} \\widehat{Z}^\\top Q_{\\widehat{A}}^\\top$。设 $P_{\\mathcal{N}(M)} = ZZ^\\top$ 和 $P_{\\mathcal{N}(\\widehat{M})} = \\widehat{Z}\\widehat{Z}^\\top$ 分别是到坐标空间中的零空间上的投影算子。则 $P_\\mathcal{S} = Q_A P_{\\mathcal{N}(M)} Q_A^\\top$ 且 $P_{\\widehat{\\mathcal{S}}} = Q_{\\widehat{A}} P_{\\mathcal{N}(\\widehat{M})} Q_{\\widehat{A}}^\\top$。\n\n2.  **三角不等式**：我们可以通过引入一个中间投影算子，使用三角不等式来界定距离 $\\|P_\\mathcal{S} - P_{\\widehat{\\mathcal{S}}}\\|_2$：\n    $$\n    \\|P_\\mathcal{S} - P_{\\widehat{\\mathcal{S}}}\\|_2 \\le \\|Q_A P_{\\mathcal{N}(M)} Q_A^\\top - Q_{\\widehat{A}} P_{\\mathcal{N}(M)} Q_{\\widehat{A}}^\\top\\|_2 + \\|Q_{\\widehat{A}} P_{\\mathcal{N}(M)} Q_{\\widehat{A}}^\\top - Q_{\\widehat{A}} P_{\\mathcal{N}(\\widehat{M})} Q_{\\widehat{A}}^\\top\\|_2\n    $$\n\n3.  **第一个项的界定**：第一个项衡量了将嵌入子空间从 $\\mathcal{R}(A)$ 变为 $\\mathcal{R}(\\widehat{A})$，同时保持零空间条件（由 $P_{\\mathcal{N}(M)}$ 表示）不变的影响。设 $\\mathcal{T} = \\mathcal{R}(Q_A Z)$ 和 $\\widehat{\\mathcal{T}} = \\mathcal{R}(Q_{\\widehat{A}} Z)$。该项是这两个子空间之间的距离。子空间之间的距离不能大于它们所嵌入的更大空间之间的距离。因此，该项受 $\\mathcal{R}(A)$ 和 $\\mathcal{R}(\\widehat{A})$ 之间的距离界定：\n    $$\n    \\|P_{\\mathcal{T}} - P_{\\widehat{\\mathcal{T}}}\\|_2 \\le \\|Q_A Q_A^\\top - Q_{\\widehat{A}} Q_{\\widehat{A}}^\\top\\|_2 = d_A\n    $$\n\n4.  **第二个项的界定**：第二个项，由于谱范数的酉不变性，可以简化为：\n    $$\n    \\|Q_{\\widehat{A}} (P_{\\mathcal{N}(M)} - P_{\\mathcal{N}(\\widehat{M})}) Q_{\\widehat{A}}^\\top\\|_2 = \\|P_{\\mathcal{N}(M)} - P_{\\mathcal{N}(\\widehat{M})}\\|_2\n    $$\n    这是 $M=BQ_A$ 和 $\\widehat{M}=\\widehat{B}Q_{\\widehat{A}}$ 的零空间之间的距离。矩阵的零空间是一个 SVD 不变子空间。根据奇异值分解的 Davis-Kahan 定理，$M$ 和 $\\widehat{M}$ 的零空间之间最大主夹角正弦值受扰动范数与谱隙之比的界定。零空间的谱隙是 $M$ 的最小正奇异值，即 $\\gamma = \\sigma_{\\min+}(M)$。假设 $\\mathcal{N}(M)$ 和 $\\mathcal{N}(\\widehat{M})$ 的维数相同，投影算子距离的界为：\n    $$\n    \\|P_{\\mathcal{N}(M)} - P_{\\mathcal{N}(\\widehat{M})}\\|_2 \\le \\frac{\\|\\widehat{M}-M\\|_2}{\\gamma}\n    $$\n    这个界在条件 $\\gamma  \\|\\widehat{M}-M\\|_2$ 下成立，但也存在更通用的形式。该表达式是一个标准的一阶扰动结果。\n\n5.  **组合界**：组合两个项的界，得到所期望的不等式：\n    $$\n    \\|P_\\mathcal{S} - P_{\\widehat{\\mathcal{S}}}\\|_2 \\le d_A + \\frac{\\|\\widehat{M}-M\\|_2}{\\gamma}\n    $$\n    由于子空间距离（作为角度的正弦值）不能超过 $1$，我们可以将界写为 $\\min(1, \\dots)$。如果 $M$ 没有正奇异值（即，数值上 $M=0$），其零空间是整个定义域。$\\gamma=+\\infty$ 的约定使得分数项为零，这正确地反映了在这种情况下，零空间条件对 $\\mathcal{R}(A)$ 中的向量没有施加任何约束。扰动则完全由 $\\mathcal{R}(A)$ 的变化引起，由 $d_A$ 捕获。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import qr, svd\n\ndef compute_intersection_basis(A, B, tau):\n    \"\"\"\n    Computes an orthonormal basis for the intersection subspace R(A) intersect N(B).\n\n    Args:\n        A (np.ndarray): The matrix defining the range space R(A).\n        B (np.ndarray): The matrix defining the null space N(B).\n        tau (float): The numerical tolerance for rank determination.\n\n    Returns:\n        np.ndarray: A matrix whose columns form an orthonormal basis for the intersection.\n    \"\"\"\n    m, n = A.shape\n    \n    # Step 1: Find an orthonormal basis for R(A) using Column Pivoted QR.\n    # The factorization is AP = QR. R(A) is spanned by the first r columns of Q.\n    if n == 0:\n        r = 0\n        Q_A = np.zeros((m, 0))\n    else:\n        # Use scipy.linalg.qr for column-pivoted QR factorization.\n        Q, R, _ = qr(A, pivoting=True, mode='economic')\n        \n        # Determine numerical rank based on the diagonal of R.\n        # It's a common practice to use a relative tolerance, but for this problem,\n        # we stick to the provided absolute tolerance for consistency.\n        if R.shape[0] > 0 and R.shape[1] > 0:\n            diag_R = np.abs(np.diag(R))\n            r = np.sum(diag_R > tau)\n        else:\n            r = 0\n        Q_A = Q[:, :r]\n\n    # If R(A) is the trivial subspace {0}, the intersection is also {0}.\n    if Q_A.shape[1] == 0:\n        return np.zeros((m, 0))\n        \n    # Step 2: Form the matrix M = BQ_A. The intersection corresponds to the null space of M.\n    M = B @ Q_A\n    \n    # If M is an empty matrix, its null space is the entire domain R^r.\n    # The intersection is thus R(A) itself.\n    if M.size == 0 and M.shape[1] > 0:\n        return Q_A\n\n    # Step 3: Find an orthonormal basis for N(M) using SVD.\n    _, s_M, Vh_M = svd(M)\n    V_M = Vh_M.T\n    \n    # Determine the dimension of the null space.\n    rank_M = np.sum(s_M > tau)\n    null_dim = V_M.shape[1] - rank_M\n    \n    # If N(M) is trivial, the intersection is trivial.\n    if null_dim == 0:\n        return np.zeros((m, 0))\n    else:\n        # The last `null_dim` columns of V_M form an orthonormal basis for N(M).\n        Z = V_M[:, -null_dim:]\n        \n        # Step 4: The basis for the intersection is Q_A @ Z. This is orthonormal.\n        # (Q_A Z)^T (Q_A Z) = Z^T Q_A^T Q_A Z = Z^T I Z = Z^T Z = I.\n        U_intersect = Q_A @ Z\n        return U_intersect\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and produce the final output.\n    \"\"\"\n    tau = 1e-8\n    \n    test_cases = [\n        # Case 1\n        {\n            \"A\": np.array([[1, 0, 0], [1, 1, 0], [0, 1, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0]], dtype=float),\n            \"B\": np.array([[1, -1, 0, 0, 0, 0], [0, 1, -1, 0, 0, 0]], dtype=float),\n            \"Delta_A\": 1e-3 * np.array([[0, 2, -1], [-1, 0.5, 0], [0, 0, 1.5], [1, -0.5, 0], [0.2, -0.1, 0.3], [-0.2, 0.1, -0.3]], dtype=float),\n            \"Delta_B\": 1e-3 * np.array([[0.5, -0.2, 0.1, 0, 0, 0], [-0.3, 0.4, -0.1, 0, 0, 0]], dtype=float)\n        },\n        # Case 2\n        {\n            \"A\": np.array([[1, 0, 0], [1, 1, 0], [0, 1, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0]], dtype=float),\n            \"B\": np.array([[1, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0]], dtype=float),\n            \"Delta_A\": 5e-4 * np.array([[0, 2, -1], [-1, 0.5, 0], [0, 0, 1.5], [1, -0.5, 0], [0.2, -0.1, 0.3], [-0.2, 0.1, -0.3]], dtype=float),\n            \"Delta_B\": 1e-3 * np.array([[0.2, -0.1, 0.05, 0, 0, 0], [-0.05, 0.1, -0.02, 0, 0, 0], [0.03, -0.04, 0.02, 0, 0, 0]], dtype=float)\n        },\n        # Case 3\n        {\n            \"A\": np.array([[1, 0, 0], [1, 1, 0], [0, 1, 1], [0, 0, 1], [0, 0, 0], [0, 0, 0]], dtype=float),\n            \"B\": np.array([[1, -1, 0, 0, 0, 0], [1, -1 + 1e-3, -1e-3, 0, 0, 0]], dtype=float),\n            \"Delta_A\": 1e-3 * np.array([[0.1, -0.2, 0.1], [-0.1, 0.2, -0.1], [0.05, 0.05, -0.1], [-0.05, 0.1, 0.05], [0.01, -0.02, 0.03], [-0.01, 0.02, -0.03]], dtype=float),\n            \"Delta_B\": 5e-4 * np.array([[-0.1, 0.05, -0.02, 0, 0, 0], [0.08, -0.04, 0.01, 0, 0, 0]], dtype=float)\n        },\n        # Case 4\n        {\n            \"A\": np.array([[1, 0], [0, 1], [0, 0], [1, 1], [0, 1]], dtype=float),\n            \"B\": np.array([[1, 1, 0, 0, 0]], dtype=float),\n            \"Delta_A\": 1e-3 * np.array([[0.2, -0.1], [-0.1, 0.3], [0.05, -0.02], [-0.2, 0.1], [0.1, -0.05]], dtype=float),\n            \"Delta_B\": 1e-3 * np.array([[-0.2, 0.1, 0, 0, 0]], dtype=float)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A, B = case[\"A\"], case[\"B\"]\n        Delta_A, Delta_B = case[\"Delta_A\"], case[\"Delta_B\"]\n        \n        A_hat, B_hat = A + Delta_A, B + Delta_B\n\n        # Compute basis for exact and perturbed intersection subspaces\n        U_star = compute_intersection_basis(A, B, tau)\n        U_hat = compute_intersection_basis(A_hat, B_hat, tau)\n\n        # Compute actual subspace error\n        P_star = U_star @ U_star.T\n        P_hat = U_hat @ U_hat.T\n        actual_error = np.linalg.norm(P_star - P_hat, 2)\n\n        # Compute the theoretical bound\n        Q_A, R_A, _ = qr(A, pivoting=True, mode='economic')\n        if R_A.shape[0] > 0 and R_A.shape[1] > 0:\n            rank_A = np.sum(np.abs(np.diag(R_A)) > tau)\n        else:\n            rank_A = 0\n        Q_A = Q_A[:, :rank_A]\n\n        Q_A_hat, R_A_hat, _ = qr(A_hat, pivoting=True, mode='economic')        \n        if R_A_hat.shape[0] > 0 and R_A_hat.shape[1] > 0:\n            rank_A_hat = np.sum(np.abs(np.diag(R_A_hat)) > tau)\n        else:\n            rank_A_hat = 0\n        Q_A_hat = Q_A_hat[:, :rank_A_hat]\n        \n        P_A = Q_A @ Q_A.T\n        P_A_hat = Q_A_hat @ Q_A_hat.T\n        d_A = np.linalg.norm(P_A - P_A_hat, 2)\n\n        M = B @ Q_A\n        M_hat = B_hat @ Q_A_hat\n        norm_M_hat_minus_M = np.linalg.norm(M_hat - M, 2)\n\n        if M.size > 0:\n            s_M = svd(M, compute_uv=False)\n            positive_s_M = s_M[s_M > tau]\n            if positive_s_M.size > 0:\n                gamma = np.min(positive_s_M)\n            else:\n                gamma = np.inf\n        else:\n            gamma = np.inf\n            \n        if np.isinf(gamma):\n            bound_val = d_A\n        else:\n            bound_val = d_A + norm_M_hat_minus_M / gamma\n            \n        bound = min(1.0, bound_val)\n        \n        # Compare actual error to the bound, with a small numerical tolerance\n        is_valid_bound = actual_error = bound + 1e-12\n        results.append(is_valid_bound)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3600943"}]}