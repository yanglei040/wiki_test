{"hands_on_practices": [{"introduction": "有限差分法的核心在于利用泰勒级数展开来构建导数的近似。本练习将带你从第一性原理出发，通过待定系数法推导一个处理边界问题时常用的高阶单边差分格式。掌握这一基本功，不仅能让你理解现有公式的来源，更为你将来需要自定义格式以适应复杂物理模型时奠定坚实的理论基础。[@problem_id:3307331]", "problem": "在一维横电磁场的麦克斯韦旋度方程的时域有限差分 (FDTD) 离散化中，位于位置 $x_{0}$ 的理想导电边界上的空间导数必须使用单边模板进行近似，以避免在域外采样。设 $f(x)$ 表示沿边界法线方向的足够光滑的笛卡尔场分量。您需要使用网格样本点 $f(x_{0})$、$f(x_{0}+h)$、$f(x_{0}+2h)$ 和 $f(x_{0}+3h)$ 构建一个用于计算 $f'(x_{0})$ 的单边 $3$ 阶精度有限差分近似，其中 $h>0$ 是均匀的空间步长。\n\n仅从 $f(x)$ 在 $x_{0}$ 点的泰勒级数展开和一阶导数的定义出发，确定系数 $c_{0}$、$c_{1}$、$c_{2}$ 和 $c_{3}$，使得\n$$\nf'(x_{0}) \\approx \\frac{c_{0} f(x_{0}) + c_{1} f(x_{0}+h) + c_{2} f(x_{0}+2h) + c_{3} f(x_{0}+3h)}{h}\n$$\n其截断误差的阶为 $\\mathcal{O}(h^{3})$。将最终的近似式表示为由样本点除以 $h$ 构成的单个闭式有理组合。最终答案必须是单个解析表达式。不包含任何单位。", "solution": "该问题要求为在点 $x_0$ 处求足够光滑函数 $f(x)$ 的一阶导数，构建一个单边三阶精度有限差分近似。该近似必须使用四个网格点 $x_0$、$x_0+h$、$x_0+2h$ 和 $x_0+3h$，其中 $h > 0$ 是均匀的网格间距。近似式的指定形式为：\n$$\nf'(x_0) \\approx \\frac{c_0 f(x_0) + c_1 f(x_0+h) + c_2 f(x_0+2h) + c_3 f(x_0+3h)}{h}\n$$\n任务是确定未知系数 $c_0$、$c_1$、$c_2$ 和 $c_3$，使得该近似的截断误差阶为 $\\mathcal{O}(h^3)$。推导必须从函数 $f(x)$ 在指定网格点处的泰勒级数展开开始。\n\n我们首先写出 $f(x)$ 在点 $x_0$ 附近的泰勒级数展开。对于一个足够光滑的函数，$f(x_0+h)$、$f(x_0+2h)$ 和 $f(x_0+3h)$ 的展开式为：\n$$\nf(x_0+h) = f(x_0) + h f'(x_0) + \\frac{h^2}{2!} f''(x_0) + \\frac{h^3}{3!} f'''(x_0) + \\frac{h^4}{4!} f^{(4)}(x_0) + \\mathcal{O}(h^5)\n$$\n$$\nf(x_0+2h) = f(x_0) + (2h) f'(x_0) + \\frac{(2h)^2}{2!} f''(x_0) + \\frac{(2h)^3}{3!} f'''(x_0) + \\frac{(2h)^4}{4!} f^{(4)}(x_0) + \\mathcal{O}(h^5)\n$$\n$$\nf(x_0+3h) = f(x_0) + (3h) f'(x_0) + \\frac{(3h)^2}{2!} f''(x_0) + \\frac{(3h)^3}{3!} f'''(x_0) + \\frac{(3h)^4}{4!} f^{(4)}(x_0) + \\mathcal{O}(h^5)\n$$\n我们将这些展开式代入有限差分公式的分子中：\n$$\nc_0 f(x_0) + c_1 f(x_0+h) + c_2 f(x_0+2h) + c_3 f(x_0+3h)\n$$\n代入并按 $f(x)$ 在 $x_0$ 处的各阶导数对各项进行分组：\n$$\n= c_0 f(x_0) + c_1 \\left( \\sum_{k=0}^{\\infty} \\frac{h^k}{k!} f^{(k)}(x_0) \\right) + c_2 \\left( \\sum_{k=0}^{\\infty} \\frac{(2h)^k}{k!} f^{(k)}(x_0) \\right) + c_3 \\left( \\sum_{k=0}^{\\infty} \\frac{(3h)^k}{k!} f^{(k)}(x_0) \\right)\n$$\n$$\n= (c_0 + c_1 + c_2 + c_3) f(x_0) + h(c_1 + 2c_2 + 3c_3) f'(x_0) + \\frac{h^2}{2}(c_1 + 4c_2 + 9c_3) f''(x_0) + \\frac{h^3}{6}(c_1 + 8c_2 + 27c_3) f'''(x_0) + \\frac{h^4}{24}(c_1 + 16c_2 + 81c_3) f^{(4)}(x_0) + \\dots\n$$\n现在，我们将其代回完整的近似表达式，并要求它等于 $f'(x_0) + \\mathcal{O}(h^3)$。\n$$\n\\frac{1}{h} \\left[ (c_0 + c_1 + c_2 + c_3) f(x_0) + h(c_1 + 2c_2 + 3c_3) f'(x_0) + \\frac{h^2}{2}(c_1 + 4c_2 + 9c_3) f''(x_0) + \\frac{h^3}{6}(c_1 + 8c_2 + 27c_3) f'''(x_0) + \\dots \\right] = f'(x_0) + \\mathcal{O}(h^3)\n$$\n为了满足这个等式，左侧各阶导数的系数必须与右侧匹配。\n\\begin{itemize}\n    \\item $f(x_0)/h$ 的系数必须为 $0$：$c_0 + c_1 + c_2 + c_3 = 0$。\n    \\item $f'(x_0)$ 的系数必须为 $1$：$c_1 + 2c_2 + 3c_3 = 1$。\n    \\item $h f''(x_0)$ 的系数必须为 $0$：$\\frac{1}{2}(c_1 + 4c_2 + 9c_3) = 0 \\implies c_1 + 4c_2 + 9c_3 = 0$。\n    \\item $h^2 f'''(x_0)$ 的系数必须为 $0$：$\\frac{1}{6}(c_1 + 8c_2 + 27c_3) = 0 \\implies c_1 + 8c_2 + 27c_3 = 0$。\n\\end{itemize}\n这就建立了一个关于四个未知系数 $c_0, c_1, c_2, c_3$ 的四元线性方程组：\n\\begin{align}\n    c_0 + c_1 + c_2 + c_3 = 0 \\quad (1) \\\\\n    c_1 + 2c_2 + 3c_3 = 1 \\quad (2) \\\\\n    c_1 + 4c_2 + 9c_3 = 0 \\quad (3) \\\\\n    c_1 + 8c_2 + 27c_3 = 0 \\quad (4)\n\\end{align}\n我们可以使用方程 $(2)$、$(3)$ 和 $(4)$ 解出 $c_1, c_2, c_3$。\n将方程 $(3)$ 减去方程 $(2)$：\n$$\n(c_1 + 4c_2 + 9c_3) - (c_1 + 2c_2 + 3c_3) = 0 - 1 \\implies 2c_2 + 6c_3 = -1 \\quad (5)\n$$\n将方程 $(4)$ 减去方程 $(3)$：\n$$\n(c_1 + 8c_2 + 27c_3) - (c_1 + 4c_2 + 9c_3) = 0 - 0 \\implies 4c_2 + 18c_3 = 0 \\implies 2c_2 + 9c_3 = 0 \\quad (6)\n$$\n现在我们求解方程组 $(5)$ 和 $(6)$。将方程 $(6)$ 减去方程 $(5)$：\n$$\n(2c_2 + 9c_3) - (2c_2 + 6c_3) = 0 - (-1) \\implies 3c_3 = 1 \\implies c_3 = \\frac{1}{3}\n$$\n将 $c_3 = 1/3$ 代入方程 $(6)$：\n$$\n2c_2 + 9\\left(\\frac{1}{3}\\right) = 0 \\implies 2c_2 + 3 = 0 \\implies c_2 = -\\frac{3}{2}\n$$\n将 $c_2 = -3/2$ 和 $c_3 = 1/3$ 代入方程 $(2)$：\n$$\nc_1 + 2\\left(-\\frac{3}{2}\\right) + 3\\left(\\frac{1}{3}\\right) = 1 \\implies c_1 - 3 + 1 = 1 \\implies c_1 = 3\n$$\n最后，使用方程 $(1)$ 求出 $c_0$：\n$$\nc_0 + 3 + \\left(-\\frac{3}{2}\\right) + \\frac{1}{3} = 0 \\implies c_0 + \\frac{18-9+2}{6} = 0 \\implies c_0 + \\frac{11}{6} = 0 \\implies c_0 = -\\frac{11}{6}\n$$\n因此，系数为：$c_0 = -11/6$，$c_1 = 3$，$c_2 = -3/2$，以及 $c_3 = 1/3$。\n\n截断误差的主项由级数展开中的下一个非零项确定，即包含 $f^{(4)}(x_0)$ 的项。误差 $E$ 由下式给出：\n$$\nE = \\frac{1}{h} \\left( \\frac{h^4}{24} (c_1 + 16c_2 + 81c_3) f^{(4)}(x_0) \\right) + \\mathcal{O}(h^4) = \\frac{h^3}{24} (c_1 + 16c_2 + 81c_3) f^{(4)}(x_0) + \\mathcal{O}(h^4)\n$$\n我们来计算这个系数：\n$$\nc_1 + 16c_2 + 81c_3 = 3 + 16\\left(-\\frac{3}{2}\\right) + 81\\left(\\frac{1}{3}\\right) = 3 - 24 + 27 = 6\n$$\n所以，主误差项是 $\\frac{6h^3}{24}f^{(4)}(x_0) = \\frac{h^3}{4}f^{(4)}(x_0)$。误差的阶为 $\\mathcal{O}(h^3)$，符合要求。\n\n现在，我们通过将系数代回给定形式来构建最终的近似公式：\n$$\nf'(x_0) \\approx \\frac{1}{h} \\left( -\\frac{11}{6} f(x_0) + 3 f(x_0+h) - \\frac{3}{2} f(x_0+2h) + \\frac{1}{3} f(x_0+3h) \\right)\n$$\n为了将其表示为单个有理组合，我们为系数找到一个公分母，即 $6$。\n$$\nf'(x_0) \\approx \\frac{1}{h} \\left( \\frac{-11 f(x_0) + 18 f(x_0+h) - 9 f(x_0+2h) + 2 f(x_0+3h)}{6} \\right)\n$$\n这就得到了该近似的最终闭式表达式：\n$$\nf'(x_0) \\approx \\frac{-11 f(x_0) + 18 f(x_0+h) - 9 f(x_0+2h) + 2 f(x_0+3h)}{6h}\n$$\n该表达式表示用于求在 $x_0$ 处一阶导数的三阶精度单边有限差分近似。", "answer": "$$\n\\boxed{\\frac{-11 f(x_0) + 18 f(x_0+h) - 9 f(x_0+2h) + 2 f(x_0+3h)}{6h}}\n$$", "id": "3307331"}, {"introduction": "理论上的收敛阶只是故事的一半，在实际计算中，我们还必须面对有限精度算法带来的舍入误差。本练习要求你通过一个经典的网格加密研究，亲手实现一个中心差分格式，并观察其在步长$h$变化时误差行为的完整过程。你将清晰地看到截断误差和舍入误差之间的此消彼长，并从实践中理解为何过小的步长反而会导致精度灾难，这是每个计算科学家必须掌握的关键一课。[@problem_id:3307315]", "problem": "考虑空间微分在计算电磁学中的作用，特别是在麦克斯韦方程组的有限差分离散化中。在诸如时域有限差分（FDTD）等方法中，空间导数在网格上通过有限差分进行近似，电磁场更新方程的精度和稳定性取决于微分算子的离散化方式以及步长的大小。为了在受控的环境下研究这些数值特性，我们将重点研究使用对称模板来近似一个光滑标量函数的导数。\n\n从一个足够光滑的函数 $f$ 在点 $x$ 处的泰勒展开出发，推导出一个对称双点模板来近似导数 $f'(x)$。该近似通过在必要的最低阶截断泰勒级数以消除 $h$ 的奇数阶项而得到，并实现了关于 $h$ 的二阶相容性。在您的程序中，对特定函数 $f(x) = \\cos x$ 在点 $x = 1$ 处使用该近似，角度以弧度为单位。\n\n对于步长 $h$，将绝对误差定义为 $E(h) = \\left|D(h) - f'(1)\\right|$，其中 $D(h)$ 是您使用对称模板得到的 $f'(1)$ 的数值近似值，$f'(1)$ 是在 $x = 1$ 处的精确导数。使用一个递减的步长序列 $(h_i)$，将连续步长之间的观测阶定义为\n$$\np_i = \\frac{\\log\\left(E(h_i)/E(h_{i+1})\\right)}{\\log\\left(h_i/h_{i+1}\\right)}.\n$$\n在网格加密研究中，当截断误差占主导时，理论上的二阶行为意味着 $p_i \\approx 2$。对于足够小的 $h$，$f(x+h) - f(x-h)$ 中的相消误差和浮点舍入误差（由机器精度表征）可能导致偏离这种理想行为。您的解答必须根据截断误差和舍入误差来解释这些偏离的来源。\n\n实现一个程序，对于以下每个 $h$ 的测试序列，计算：\n- $f'(1)$ 的数值近似序列 $D(h_i)$，\n- 绝对误差序列 $E(h_i)$，\n- 连续对 $(h_i, h_{i+1})$ 的观测阶序列 $(p_i)$。\n\n角度必须以弧度为单位。本问题中没有其他物理单位。程序的最终输出应将所有测试序列的观测阶聚合为一行，其中包含一个列表的列表，每个内部列表对应一个测试序列，并包含作为浮点数的 $p_i$ 值。\n\n步长序列的测试套件：\n- 情况 A（中等加密）：$[10^{-1},\\, 5 \\cdot 10^{-2},\\, 2.5 \\cdot 10^{-2},\\, 1.25 \\cdot 10^{-2}]$。\n- 情况 B（从粗到中等加密）：$[5 \\cdot 10^{-1},\\, 2.5 \\cdot 10^{-1},\\, 1.25 \\cdot 10^{-1},\\, 6.25 \\cdot 10^{-2}]$。\n- 情况 C（接近平衡截断误差和舍入误差的预期最优 $h$）：$[10^{-5},\\, 5 \\cdot 10^{-6},\\, 2.5 \\cdot 10^{-6},\\, 1.25 \\cdot 10^{-6}]$。\n- 情况 D（舍入误差占主导的极小步长）：$[10^{-8},\\, 5 \\cdot 10^{-9},\\, 2.5 \\cdot 10^{-9},\\, 1.25 \\cdot 10^{-9}]$。\n- 情况 E（非均匀比率以测试通用性）：$[10^{-3},\\, 7.5 \\cdot 10^{-4},\\, 3 \\cdot 10^{-4},\\, 10^{-4},\\, 7.5 \\cdot 10^{-5}]$。\n\n您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表形式的结果，每个元素是对应情况的观测阶的内部列表（例如，`[[p_{A,1},p_{A,2},p_{A,3}],[p_{B,1},\\dots],\\dots]`）。", "solution": "该问题要求推导一阶导数的二阶精度有限差分近似，分析其数值误差特性，并实现一个程序来计算特定函数和几组步长下的收敛观测阶。\n\n**1. 对称有限差分模板的推导**\n\n为了推导一阶导数 $f'(x)$ 的对称双点模板，我们从足够光滑的函数 $f(x)$ 在点 $x$ 附近对点 $x+h$ 和 $x-h$ 的泰勒级数展开开始，其中 $h > 0$ 是步长。\n\n$f(x+h)$ 关于 $x$ 的泰勒展开式为：\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2!}f''(x) + \\frac{h^3}{3!}f'''(x) + \\frac{h^4}{4!}f^{(4)}(x) + \\dots\n$$\n\n$f(x-h)$ 关于 $x$ 的泰勒展开式为：\n$$\nf(x-h) = f(x) - hf'(x) + \\frac{h^2}{2!}f''(x) - \\frac{h^3}{3!}f'''(x) + \\frac{h^4}{4!}f^{(4)}(x) - \\dots\n$$\n\n为了分离出一阶导数项 $f'(x)$，我们用第一个展开式减去第二个展开式。这可以方便地消去所有 $h$ 的偶次幂项：\n$$\nf(x+h) - f(x-h) = (f(x) - f(x)) + (h - (-h))f'(x) + \\left(\\frac{h^2}{2} - \\frac{h^2}{2}\\right)f''(x) + \\left(\\frac{h^3}{6} - \\left(-\\frac{h^3}{6}\\right)\\right)f'''(x) + \\dots\n$$\n$$\nf(x+h) - f(x-h) = 2hf'(x) + \\frac{2h^3}{6}f'''(x) + O(h^5)\n$$\n其中 $O(h^5)$ 代表 $h^5$ 及更高阶的项。\n\n重新整理此方程以求解 $f'(x)$，得到：\n$$\nf'(x) = \\frac{f(x+h) - f(x-h)}{2h} - \\frac{h^2}{6}f'''(x) - O(h^4)\n$$\n\n由此，我们通过截断级数来定义 $f'(x)$ 的数值近似 $D(h)$：\n$$\nD(h) = \\frac{f(x+h) - f(x-h)}{2h}\n$$\n这就是所要求的对称双点模板，通常称为中心差分公式。\n\n这种近似的误差，即截断误差 $E_t(h)$，是精确导数与其近似值之间的差：\n$$\nE_t(h) = f'(x) - D(h) = -\\frac{h^2}{6}f'''(x) - O(h^4)\n$$\n由于误差的首项与 $h^2$ 成正比，该方法是二阶精度的（或具有二阶相容性）。\n\n**2. 数值误差来源分析**\n\n在浮点计算中，总绝对误差 $E(h) = |D(h) - f'(x)|$ 是由两个主要来源组合而成的：截断误差和舍入误差。\n\n**截断误差**：如上所述，截断误差是由于用有限过程（模板）来近似无限过程（泰勒级数）而产生的。对于较小的 $h$，该误差由其首项主导：\n$$\nE_t(h) \\approx \\left|-\\frac{h^2}{6}f'''(x)\\right| = C_t h^2\n$$\n其中 $C_t = |f'''(x)|/6$。该误差随着 $h$ 的减小呈二次方递减。对于指定的函数 $f(x) = \\cos x$，我们有 $f'(x) = -\\sin x$，$f''(x) = -\\cos x$，以及 $f'''(x) = \\sin x$。在 $x=1$ 处，常数是 $C_t = \\sin(1)/6 \\approx 0.140$。\n\n**舍入误差**：舍入误差的产生是因为数字计算机用有限精度表示实数。当 $h$ 非常小时，$f(x+h)$ 和 $f(x-h)$ 的值变得非常接近。此时，做减法 $f(x+h) - f(x-h)$ 会遭受**相消**，导致有效数字的损失。设 $\\epsilon_{mach}$ 为机器ε（浮点运算中舍入导致的相对误差的上界）。计算分子 $f(x+h) - f(x-h)$ 的误差大约与 $|f(x)|\\epsilon_{mach}$ 成正比。这个误差随后被除以一个小数 $2h$ 而放大。因此，舍入误差 $E_r(h)$ 可以建模为：\n$$\nE_r(h) \\approx \\frac{C_r}{h}\n$$\n其中常数 $C_r$ 的数量级与 $|f(x)|\\epsilon_{mach}$ 相当。该误差随着 $h$ 的减小而增大。\n\n**总误差和最优步长**：总误差是这两个分量的和：\n$$\nE(h) \\approx C_t h^2 + \\frac{C_r}{h}\n$$\n对于大的 $h$，$C_t h^2$ 项占主导。对于非常小的 $h$，$C_r/h$ 项占主导。存在一个最优步长 $h_{opt}$ 可以最小化这个总误差，可以通过将 $E(h)$ 对 $h$ 的导数设为零来找到：\n$$\n\\frac{dE}{dh} = 2C_t h - \\frac{C_r}{h^2} = 0 \\implies h_{opt} = \\left(\\frac{C_r}{2C_t}\\right)^{1/3}\n$$\n对于双精度浮点运算，$\\epsilon_{mach} \\approx 2.22 \\times 10^{-16}$。对于 $f(x)=\\cos x$ 在 $x=1$ 处，$h_{opt}$ 的数量级在 $10^{-5}$ 到 $10^{-6}$ 之间。\n\n**3. 收敛的观测阶**\n\n两个连续步长 $h_i$ 和 $h_{i+1}$ 之间的收敛观测阶 $p_i$ 计算如下：\n$$\np_i = \\frac{\\log\\left(E(h_i)/E(h_{i+1})\\right)}{\\log\\left(h_i/h_{i+1}\\right)}\n$$\n该公式源于误差行为符合 $E(h) \\approx C h^p$ 的假设。如果该假设成立，则有 $E(h_i)/E(h_{i+1}) \\approx (h_i/h_{i+1})^p$，两边取对数即可解出 $p$。\n\n对于测试用例，$p_i$ 的预期行为如下：\n- **情况 A、B 和 E**：步长 $h_i$ 处于截断误差占主导的区域 ($E(h) \\propto h^2$)。因此，我们预期观测阶 $p_i$ 约等于 $2$。\n- **情况 C**：步长接近 $h_{opt}$。在此区域，截断误差和舍入误差都很显著。误差不遵循简单的幂律，因此 $p_i$ 将偏离 $2$，并可能减小。\n- **情况 D**：步长非常小，深处于舍入误差主导的区域。误差预计会随着 $h$ 的减小而增大，大约遵循 $E(h) \\propto 1/h$。在这种情况下，$E(h_i)/E(h_{i+1}) \\approx (1/h_i)/(1/h_{i+1}) = h_{i+1}/h_i$。$p_i$ 的公式得出 $p_i \\approx \\log(h_{i+1}/h_i) / \\log(h_i/h_{i+1}) = -1$。由于浮点运算的随机性，观测值可能会很混乱，但通常应为负数或接近于零，表明收敛性已经破坏。\n现在，程序将根据指定的测试用例计算这些值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and applies a central difference approximation for f'(x) to study\n    numerical error behavior. The function computes numerical derivatives, errors,\n    and observed orders of convergence for several sequences of step sizes.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (moderate refinement)\n        [1e-1, 5e-2, 2.5e-2, 1.25e-2],\n        # Case B (coarse-to-moderate refinement)\n        [5e-1, 2.5e-1, 1.25e-1, 6.25e-2],\n        # Case C (near the expected optimal h)\n        [1e-5, 5e-6, 2.5e-6, 1.25e-6],\n        # Case D (extremely small steps where round-off dominates)\n        [1e-8, 5e-9, 2.5e-9, 1.25e-9],\n        # Case E (non-uniform ratios to test generality)\n        [1e-3, 7.5e-4, 3e-4, 1e-4, 7.5e-5],\n    ]\n\n    # The point at which to evaluate the derivative\n    x = 1.0\n    \n    # The function f(x) = cos(x)\n    f = np.cos\n    \n    # The exact derivative f'(x) = -sin(x) at x=1\n    f_prime_exact = -np.sin(x)\n\n    all_p_results = []\n\n    for h_sequence in test_cases:\n        errors = []\n        for h in h_sequence:\n            # Symmetric, two-point stencil (central difference) approximation\n            # D(h) = (f(x+h) - f(x-h)) / (2*h)\n            d_approx = (f(x + h) - f(x - h)) / (2.0 * h)\n            \n            # Absolute error E(h) = |D(h) - f'(x)|\n            error = np.abs(d_approx - f_prime_exact)\n            errors.append(error)\n\n        p_values = []\n        # Calculate observed order p_i for successive pairs (h_i, h_{i+1})\n        for i in range(len(h_sequence) - 1):\n            h_i = h_sequence[i]\n            h_i_plus_1 = h_sequence[i+1]\n            \n            error_i = errors[i]\n            error_i_plus_1 = errors[i+1]\n            \n            # Formula for observed order: p_i = log(E_i/E_{i+1}) / log(h_i/h_{i+1})\n            # Handle cases where error might be zero to avoid log(0)\n            if error_i_plus_1 == 0.0 or error_i == 0.0:\n                # If the error becomes zero, the order is theoretically infinite.\n                # In practice with floating point, this suggests perfect cancellation or\n                # reaching the limits of precision.\n                p = np.inf\n            else:\n                log_error_ratio = np.log(error_i / error_i_plus_1)\n                log_h_ratio = np.log(h_i / h_i_plus_1)\n                p = log_error_ratio / log_h_ratio\n            \n            p_values.append(p)\n        \n        all_p_results.append(p_values)\n\n    # Format the final output string exactly as required: [[...],[...],...]\n    # without extraneous spaces.\n    outer_list_str = []\n    for p_list in all_p_results:\n        inner_list_str = \"[\" + \",\".join(map(str, p_list)) + \"]\"\n        outer_list_str.append(inner_list_str)\n    \n    final_output = \"[\" + \",\".join(outer_list_str) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3307315"}, {"introduction": "为了在不扩大模板宽度的前提下实现更高的精度，我们可以从显式格式转向隐式紧致格式。本练习将指导你推导并实现一个四阶紧致差分格式，这一过程会自然地导出一个全局的线性方程组。通过解决这个挑战，你将体会到数值离散化问题如何与高效的线性代数求解器紧密相连，并学习利用问题本身的结构（例如周期性）来设计快速算法。[@problem_id:3307323]", "problem": "考虑在一维周期性网格上计算空间导数 $\\partial_x E_y$ 的任务，这在计算电磁学中麦克斯韦方程组的旋度算子离散化过程中会出现。在一个位于区间 $[0,2\\pi)$ 上的均匀周期性网格上进行计算，该网格有 $N$ 个点，网格间距为 $\\Delta x = 2\\pi/N$，节点位置为 $x_i = i \\,\\Delta x$，其中 $i = 0,1,\\dots,N-1$。角度必须以弧度为单位处理。从导数的定义和围绕网格点的泰勒级数展开出发，推导一个用于计算 $\\partial_x E_y$ 的三点四阶紧致有限差分格式，该格式具有以下特点：\n\n- 节点 $i$ 处的近似使用一个线性系统，该系统在左侧通过一个对称的最近邻模板耦合离散导数 $\\{(\\partial_x E_y)_j\\}$，并在右侧对函数值 $\\{E_y(x_j)\\}$ 使用一个最近邻反对称模板。\n- 该格式对于光滑周期函数 $E_y(x)$ 必须具有四阶精度，即局部截断误差为 $\\mathcal{O}(\\Delta x^4)$。\n- 由于周期性边界条件，所得到的离散导数向量的全局线性系统必须是循环三对角矩阵。\n\n根据这些要求：\n\n1. 确定能产生满足上述约束的三点紧致格式的四阶精度的唯一系数（如果存在）。仅使用导数的基本定义以及 $E_y(x)$ 及其在相邻节点上的导数的泰勒展开，通过匹配泰勒级数系数来推导这些系数。\n\n2. 明确写出为获得离散导数向量 $\\mathbf{d} \\in \\mathbb{R}^N$（其中 $d_i \\approx (\\partial_x E_y)(x_i)$）而必须求解的线性系统，并强调系统矩阵的循环三对角结构。给出一个高效求解器的原理性简述，该求解器应利用此结构，避免使用稠密线性代数。你的概述必须基于可逆矩阵低秩更新的基本线性代数恒等式。\n\n3. 将该方法实现为一个程序，该程序：\n   - 使用指定的 $N$ 构建周期性网格 $x_i$，并使用 $\\Delta x = 2\\pi/N$。\n   - 对下面列出的每个测试函数 $E_y(x)$，组装相应的右端项，并求解循环三对角线性系统，以获得 $\\partial_x E_y$ 的紧致四阶近似。\n   - 将数值结果与每个网格点上的精确导数进行比较，并返回每个测试用例在整个网格上的最大绝对误差。\n\n仅使用纯数学单位（不需要物理单位），角度必须以弧度为单位。最终输出必须将所有测试用例的结果汇总为单行、用方括号括起来的逗号分隔列表，其中每个条目是相应测试用例的最大绝对误差，以浮点数形式打印。您必须将每个条目四舍五入到 $12$ 位有效数字的科学记数法。\n\n测试套件（每个用例必须按给定顺序独立评估）：\n\n- 用例 1（光滑，中等波数）：$N = 64$，$E_y(x) = \\sin(3 x)$，精确导数 $\\partial_x E_y = 3 \\cos(3 x)$。\n- 用例 2（恒定场）：$N = 32$，$E_y(x) = 5$，精确导数 $\\partial_x E_y = 0$。\n- 用例 3（接近奈奎斯特频率的高频）：$N = 128$，令 $k = N/2 - 1 = 63$，$E_y(x) = \\sin(k x)$，精确导数 $\\partial_x E_y = k \\cos(k x)$。\n- 用例 4（非多项式光滑函数）：$N = 100$，$E_y(x) = \\exp(\\sin x)$，精确导数 $\\partial_x E_y = \\cos x \\,\\exp(\\sin x)$。\n- 用例 5（非常小的网格）：$N = 4$，$E_y(x) = \\sin x$，精确导数 $\\partial_x E_y = \\cos x$。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表顺序与测试用例相同（例如，\"[v1,v2,v3,v4,v5]\"）。每个值都必须是科学记数法表示的浮点数，并四舍五入到 12 位有效数字。\n\n不应从用户读取任何输入，也不应使用任何外部文件。实现应以通用方式表达，使其适用于任何 $N \\ge 4$ 和任何遵循指定模板的光滑周期函数 $E_y(x)$，但它只应计算并打印上述测试套件的结果。", "solution": "该问题要求对一维周期性网格上的一阶导数，推导、分析并实现一个三点四阶紧致有限差分格式。验证过程确认了该问题具有科学依据、是适定的、客观的，并包含足够的信息以获得唯一解。这是偏微分方程数值分析中的一个标准问题。\n\n**第 1 部分：紧致格式系数的推导**\n\n我们的任务是，在一个网格间距为 $\\Delta x = 2\\pi/N$ 的均匀周期性网格上，为网格点 $x_i = i \\Delta x$（其中 $i = 0, 1, \\dots, N-1$）处的导数 $\\partial_x E_y$ 寻找一个有限差分近似。令 $d_i$ 为 $E_y'(x_i) \\equiv (\\partial_x E_y)(x_i)$ 的数值近似，并令 $E_{y,i}$ 表示 $E_y(x_i)$。\n\n问题指定了紧致格式的形式。在每个节点 $i$ 处，离散导数 $\\{d_j\\}$ 通过一个对称的最近邻模板耦合，而函数值 $\\{E_{y,j}\\}$ 通过一个最近邻反对称模板耦合。这种结构可以表示为：\n$$\n\\alpha d_{i-1} + \\beta d_i + \\alpha d_{i+1} = \\frac{1}{\\Delta x} \\left( c E_{y,i+1} - c E_{y,i-1} \\right)\n$$\n其中 $\\alpha$、$\\beta$ 和 $c$ 是待定系数。左侧（LHS）的对称性要求 $d_{i-1}$ 和 $d_{i+1}$ 的系数相同。右侧（RHS）的反对称性给出了 $E_{y,i+1} - E_{y,i-1}$ 的形式。不失一般性，我们可以将 $d_i$ 的系数归一化为 $\\beta=1$。右侧的因子 $1/\\Delta x$ 对于一阶导数近似是常规做法。为了代数上的方便，我们还将右侧系数重新缩放为 $a/2$，以匹配标准中心差分的形式。该格式变为：\n$$\n\\alpha d_{i-1} + d_i + \\alpha d_{i+1} = \\frac{a}{2\\Delta x} (E_{y,i+1} - E_{y,i-1})\n$$\n\n为了找到能产生四阶精度的系数 $\\alpha$ 和 $a$，我们将所有项替换为它们在点 $x_i$ 附近的泰勒级数展开。我们将 $E_y(x)$ 在 $x_i$ 处的精确导数记为 $E_y'$，$E_y''$ 等。在此误差分析中，我们假设数值导数 $d_j$ 等于精确导数 $E_y'(x_j)$。\n\n$E_y(x)$ 在相邻点 $x_{i\\pm1} = x_i \\pm \\Delta x$ 处的泰勒级数展开为：\n$$\nE_{y,i\\pm1} = E_y \\pm \\Delta x E_y' + \\frac{(\\Delta x)^2}{2!} E_y'' \\pm \\frac{(\\Delta x)^3}{3!} E_y''' + \\frac{(\\Delta x)^4}{4!} E_y^{(4)} \\pm \\frac{(\\Delta x)^5}{5!} E_y^{(5)} + \\mathcal{O}((\\Delta x)^6)\n$$\n导数 $E_y'(x)$ 在相邻点处的泰勒级数展开为：\n$$\nd_{i\\pm1} \\approx E_y'(x_{i\\pm1}) = E_y' \\pm \\Delta x E_y'' + \\frac{(\\Delta x)^2}{2!} E_y''' \\pm \\frac{(\\Delta x)^3}{3!} E_y^{(4)} + \\frac{(\\Delta x)^4}{4!} E_y^{(5)} + \\mathcal{O}((\\Delta x)^5)\n$$\n\n首先，我们展开格式的右侧（RHS）：\n$$\n\\text{RHS} = \\frac{a}{2\\Delta x} (E_{y,i+1} - E_{y,i-1}) = \\frac{a}{2\\Delta x} \\left( 2\\Delta x E_y' + 2\\frac{(\\Delta x)^3}{6} E_y''' + 2\\frac{(\\Delta x)^5}{120} E_y^{(5)} + \\mathcal{O}((\\Delta x)^7) \\right)\n$$\n$$\n\\text{RHS} = a E_y' + \\frac{a(\\Delta x)^2}{6} E_y''' + \\frac{a(\\Delta x)^4}{120} E_y^{(5)} + \\mathcal{O}((\\Delta x)^6)\n$$\n\n接着，我们展开格式的左侧（LHS）：\n$$\n\\text{LHS} = \\alpha (d_{i-1} + d_{i+1}) + d_i \\approx \\alpha (E_y'(x_{i-1}) + E_y'(x_{i+1})) + E_y'(x_i)\n$$\n$$\n\\text{LHS} \\approx \\alpha \\left( 2E_y' + 2\\frac{(\\Delta x)^2}{2} E_y''' + 2\\frac{(\\Delta x)^4}{24} E_y^{(5)} + \\mathcal{O}((\\Delta x)^6) \\right) + E_y'\n$$\n$$\n\\text{LHS} \\approx (1+2\\alpha)E_y' + \\alpha(\\Delta x)^2 E_y''' + \\frac{\\alpha(\\Delta x)^4}{12} E_y^{(5)} + \\mathcal{O}((\\Delta x)^6)\n$$\n\n为了使格式精确，表达式 LHS - RHS 必须尽可能接近于零。我们令等式两边 $E_y$ 各阶导数的系数相等。\n\\begin{itemize}\n    \\item $E_y'$ 的系数：$1+2\\alpha = a$\n    \\item $E_y''$ 的系数：由于对称性，$E_y$ 的奇数阶导数项会消失，这是该中心格式的一个关键特性。\n    \\item $E_y'''$ 的系数：为达到高于二阶的精度，$(\\Delta x)^2$ 项必须抵消。\n    $$ \\alpha(\\Delta x)^2 = \\frac{a(\\Delta x)^2}{6} \\implies \\alpha = \\frac{a}{6} $$\n\\end{itemize}\n\n我们现在得到一个关于两个未知数 $\\alpha$ 和 $a$ 的二元线性方程组：\n1. $a = 1 + 2\\alpha$\n2. $a = 6\\alpha$\n\n将 (2) 代入 (1) 得到 $6\\alpha = 1 + 2\\alpha$，解得 $4\\alpha = 1$，所以 $\\alpha = 1/4$。\n将 $\\alpha=1/4$ 代回 (2) 得到 $a = 6(1/4) = 3/2$。\n\n唯一的系数是 $\\alpha = 1/4$ 和 $a = 3/2$。该格式为：\n$$\n\\frac{1}{4} d_{i-1} + d_i + \\frac{1}{4} d_{i+1} = \\frac{3/2}{2\\Delta x} (E_{y,i+1} - E_{y,i-1}) = \\frac{3}{4\\Delta x} (E_{y,i+1} - E_{y,i-1})\n$$\n\n局部截断误差（LTE）由展开式中第一个非零项决定。我们比较 $(\\Delta x)^4$ 项的系数：\n$$\n\\text{LTE} \\propto \\left( \\frac{\\alpha(\\Delta x)^4}{12} - \\frac{a(\\Delta x)^4}{120} \\right) E_y^{(5)} = \\left( \\frac{1/4}{12} - \\frac{3/2}{120} \\right) (\\Delta x)^4 E_y^{(5)}\n$$\n$$\n= \\left( \\frac{1}{48} - \\frac{3}{240} \\right) (\\Delta x)^4 E_y^{(5)} = \\left( \\frac{5}{240} - \\frac{3}{240} \\right) (\\Delta x)^4 E_y^{(5)} = \\frac{2}{240} (\\Delta x)^4 E_y^{(5)} = \\frac{1}{120} (\\Delta x)^4 E_y^{(5)}\n$$\n误差与 $(\\Delta x)^4$ 成正比，证实了该格式是四阶精度的。截断误差的正式定义是将精确解代入归一化的差分算子后得到的余项。除以归一化因子 $1+2\\alpha = 3/2$ 后，误差为 $T_i = -\\frac{1}{180}(\\Delta x)^4 E_y^{(5)}(x_i) + \\mathcal{O}((\\Delta x)^6)$。\n\n**第 2 部分：线性系统与高效求解器**\n\n该格式必须应用于从 $i=0$ 到 $i=N-1$ 的所有 $N$ 个网格点。这将为 $N$ 个未知导数 $d_0, d_1, \\dots, d_{N-1}$ 生成一个包含 $N$ 个线性方程的方程组。令 $\\mathbf{d} = [d_0, d_1, \\dots, d_{N-1}]^T$ 为离散导数向量。该系统可以写成矩阵形式 $A \\mathbf{d} = \\mathbf{b}$，其中 $A$ 是系数矩阵，$\\mathbf{b}$ 是右端向量。\n\n对于一个通用的内部点 $i$，方程为：\n$$\n(\\frac{1}{4}) d_{i-1} + (1) d_i + (\\frac{1}{4}) d_{i+1} = b_i\n$$\n其中 $b_i = \\frac{3}{4\\Delta x} (E_{y,i+1} - E_{y,i-1})$。\n\n由于周期性边界条件，索引按模 $N$ 计算。对于 $i=0$，$d_{i-1}=d_{-1}$ 变为 $d_{N-1}$。对于 $i=N-1$，$d_{i+1}=d_N$ 变为 $d_0$。这种“环绕”特性赋予矩阵 $A$ 其特征结构：\n$$\nA = \\begin{pmatrix}\n1  & 1/4  & 0  & \\dots  & 0  & 1/4 \\\\\n1/4  & 1  & 1/4  & \\dots  & 0  & 0 \\\\\n0  & 1/4  & 1  & \\dots  & 0  & 0 \\\\\n\\vdots  & \\vdots  & \\ddots  & \\ddots  & \\ddots  & \\vdots \\\\\n0  & 0  & 0  & \\dots  & 1  & 1/4 \\\\\n1/4  & 0  & 0  & \\dots  & 1/4  & 1\n\\end{pmatrix}\n$$\n这是一个对称、三对角、循环矩阵。右端向量 $\\mathbf{b}$ 的分量为 $b_i = \\frac{3}{4\\Delta x} (E_{y,(i+1)\\%N} - E_{y,(i-1+N)\\%N})$。\n\n高效的求解器必须利用这种循环结构。\n一种复杂度为 $\\mathcal{O}(N \\log N)$ 的高效方法是基于离散傅里叶变换（DFT），因为循环矩阵可以被 DFT 对角化。\n1.  令 $\\mathbf{c} = [1, 1/4, 0, \\dots, 0, 1/4]$ 为 $A$ 的第一行。卷积定理指出，对于循环矩阵 $A$，矩阵向量乘积 $A\\mathbf{d}$ 等价于 $\\mathbf{c}$ 和 $\\mathbf{d}$ 的循环卷积。\n2.  对系统 $A\\mathbf{d} = \\mathbf{b}$ 应用 DFT（记作 $\\mathcal{F}$），得到 $\\mathcal{F}(A\\mathbf{d}) = \\mathcal{F}(\\mathbf{b})$。\n3.  这就变成了 $\\mathcal{F}(\\mathbf{c}) \\odot \\mathcal{F}(\\mathbf{d}) = \\mathcal{F}(\\mathbf{b})$，其中 $\\odot$ 表示逐元素乘法。向量 $\\mathbf{\\Lambda} = \\mathcal{F}(\\mathbf{c})$ 包含 $A$ 的特征值。\n4.  该系统通过在频域中进行逐元素除法来求解：$\\mathcal{F}(\\mathbf{d}) = \\mathcal{F}(\\mathbf{b}) / \\mathbf{\\Lambda}$。\n5.  通过应用逆 DFT 来恢复解向量 $\\mathbf{d}$：$\\mathbf{d} = \\mathcal{F}^{-1}(\\mathcal{F}(\\mathbf{b}) / \\mathbf{\\Lambda})$。使用快速傅里叶变换（FFT）算法计算 DFT 及其逆变换使该方法非常快速。$A$ 的特征值由 $\\lambda_j = 1 + (1/4)e^{i 2\\pi j/N} + (1/4)e^{-i 2\\pi j/N} = 1 + (1/2)\\cos(2\\pi j/N)$ 给出，其中 $j=0, \\dots, N-1$。由于 $|\\cos(\\theta)| \\le 1$，所有特征值均为正，确保了矩阵是非奇异的。\n\n另一种高效的 $\\mathcal{O}(N)$ 方法是使用 Sherman-Morrison-Woodbury 公式，提示中提到的“低秩更新”暗示了这一点。矩阵 $A$ 可以写成一个简单的三对角矩阵 $T$ 加上一个针对角元素的秩-2 校正 $U V^T$：$A = T + \\alpha(\\mathbf{e}_0 \\mathbf{e}_{N-1}^T + \\mathbf{e}_{N-1} \\mathbf{e}_0^T)$，其中 $\\alpha=1/4$。然后，通过求解几个三对角系统（使用复杂度为 $\\mathcal{O}(N)$ 的 Thomas 算法）和一个小的 $2 \\times 2$ 系统，可以找到 $A\\mathbf{d} = \\mathbf{b}$ 的解。\n\n**第 3 部分：实现策略**\n\n实现将遵循基于 FFT 的方法，该方法由 `scipy.linalg.solve_circulant` 方便地提供。\n对于指定的每个测试用例：\n1.  设置网格大小 $N$，并定义函数 $E_y(x)$ 及其解析导数。\n2.  构建网格 $x_i = i (2\\pi/N)$，其中 $i=0, \\dots, N-1$。\n3.  在网格上计算该函数值，以创建向量 $\\mathbf{E}_y$。\n4.  使用公式 $b_i = \\frac{3}{4\\Delta x} (E_{y,i+1} - E_{y,i-1})$ 构建右端向量 $\\mathbf{b}$。周期性索引可使用 `numpy.roll` 高效处理。\n5.  定义循环矩阵 $A$ 的第一行：$\\mathbf{c} = [1, 1/4, 0, \\dots, 0, 1/4]$。\n6.  使用 `scipy.linalg.solve_circulant(c, b)` 求解系统 $A\\mathbf{d} = \\mathbf{b}$ 以得到 $\\mathbf{d}$。\n7.  在网格上计算精确导数，得到向量 $\\mathbf{d}_{\\text{exact}}$。\n8.  计算整个网格上的最大绝对误差：$\\max(|\\mathbf{d} - \\mathbf{d}_{\\text{exact}}|)$。\n9.  收集所有测试用例的误差，并将其格式化为所需的输出字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_circulant\n\ndef solve():\n    \"\"\"\n    Derives and implements a fourth-order compact finite difference scheme\n    to compute the first derivative of periodic functions.\n    \"\"\"\n\n    def compact_fourth_order_derivative(Ey_values, N):\n        \"\"\"\n        Computes the derivative using the 4th-order compact scheme.\n\n        Args:\n            Ey_values (np.ndarray): The function values E_y(x_i) on the grid.\n            N (int): The number of grid points.\n\n        Returns:\n            np.ndarray: The numerical derivative d_i at each grid point.\n        \"\"\"\n        # Grid spacing\n        delta_x = 2.0 * np.pi / N\n\n        # Coefficients of the scheme derived from Taylor series analysis.\n        # Scheme: (1/4)d_{i-1} + d_i + (1/4)d_{i+1} = (3/2) / (2*delta_x) * (E_{y,i+1} - E_{y,i-1})\n        alpha = 1.0 / 4.0\n        a = 3.0 / 2.0\n\n        # Construct the right-hand side (RHS) vector b.\n        # np.roll handles the periodic boundary conditions efficiently.\n        Ey_plus_1 = np.roll(Ey_values, -1)\n        Ey_minus_1 = np.roll(Ey_values, 1)\n        \n        rhs_b = (a / (2.0 * delta_x)) * (Ey_plus_1 - Ey_minus_1)\n\n        # Construct the first row of the circulant-cyclic tridiagonal matrix A.\n        # A has 1 on the main diagonal, and alpha on the sub- and super-diagonals,\n        # with cyclic wrap-around.\n        circulant_first_row = np.zeros(N)\n        circulant_first_row[0] = 1.0\n        circulant_first_row[1] = alpha\n        circulant_first_row[N - 1] = alpha  # or circulant_first_row[-1]\n\n        # Solve the linear system A*d = b using the efficient circulant solver,\n        # which is based on FFTs.\n        d_numerical = solve_circulant(circulant_first_row, rhs_b)\n\n        return d_numerical\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64,\n            \"Ey_func\": lambda x: np.sin(3 * x),\n            \"dEy_exact_func\": lambda x: 3 * np.cos(3 * x),\n        },\n        {\n            \"N\": 32,\n            \"Ey_func\": lambda x: np.full_like(x, 5.0),\n            \"dEy_exact_func\": lambda x: np.zeros_like(x),\n        },\n        {\n            \"N\": 128,\n            \"k\": 63, # k = N/2 - 1\n            \"Ey_func\": lambda x, k=63: np.sin(k * x),\n            \"dEy_exact_func\": lambda x, k=63: k * np.cos(k * x),\n        },\n        {\n            \"N\": 100,\n            \"Ey_func\": lambda x: np.exp(np.sin(x)),\n            \"dEy_exact_func\": lambda x: np.cos(x) * np.exp(np.sin(x)),\n        },\n        {\n            \"N\": 4,\n            \"Ey_func\": lambda x: np.sin(x),\n            \"dEy_exact_func\": lambda x: np.cos(x),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        \n        # Create the periodic grid\n        x_grid = np.arange(N) * (2.0 * np.pi / N)\n\n        # Evaluate the function and its exact derivative on the grid\n        Ey_values = case[\"Ey_func\"](x_grid)\n        dEy_exact = case[\"dEy_exact_func\"](x_grid)\n        \n        # Compute the numerical derivative\n        dEy_numerical = compact_fourth_order_derivative(Ey_values, N)\n        \n        # Calculate the maximum absolute error\n        max_abs_error = np.max(np.abs(dEy_numerical - dEy_exact))\n        \n        results.append(max_abs_error)\n\n    # Format output as a comma-separated list of values in scientific notation\n    # with 12 significant digits.\n    formatted_results = [f\"{res:.11e}\" for res in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3307323"}]}