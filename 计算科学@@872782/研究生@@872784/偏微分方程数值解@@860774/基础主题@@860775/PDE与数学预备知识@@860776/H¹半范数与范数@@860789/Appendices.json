{"hands_on_practices": [{"introduction": "掌握 $H^1$ 范数的定义是至关重要的第一步，而通过一个具体的例子从第一性原理手动计算它，则能将抽象概念转化为坚实的理解。本练习将引导你对一个定义在简单三角网格上的分片线性函数计算其 $H^1$ 范数，从而加深对范数定义、分片梯度以及在离散单元上积分的理解。[@problem_id:3402645]", "problem": "考虑两个不重叠三角形的并集 $\\Omega = K_1 \\cup K_2 \\subset \\mathbb{R}^2$，它们构成一个用于有限元方法 (FEM) 以数值求解偏微分方程 (PDEs) 的协调网格 $\\mathcal{T}_h$：\n- $K_1 = \\operatorname{conv}\\{(0,0),(2,0),(0,1)\\}$,\n- $K_2 = \\operatorname{conv}\\{(2,0),(2,2),(0,1)\\}$。\n\n令 $V_h$ 为 $\\mathcal{T}_h$ 上的连续分片仿射（线性）函数空间。通过其在网格顶点处的节点值定义 $u_h \\in V_h$：\n- $u_h(0,0) = 0$,\n- $u_h(2,0) = 2$,\n- $u_h(0,1) = 1$,\n- $u_h(2,2) = 3$。\n\n仅使用第一性原理，即 Sobolev 空间 $H^1(\\Omega)$ 的定义以及单纯形上仿射参考到物理映射的标准性质，计算 $u_h$ 在 $\\Omega$ 上的 $H^1$-范数的精确值，\n$$\n\\|u_h\\|_{H^1(\\Omega)} \\quad \\text{with} \\quad \\|u_h\\|_{H^1(\\Omega)}^2 = \\int_{\\Omega} \\big(u_h(x)\\big)^2 \\,\\mathrm{d}x \\;+\\; \\int_{\\Omega} \\|\\nabla u_h(x)\\|_2^2 \\,\\mathrm{d}x.\n$$\n请用一个精确的封闭形式表达式给出最终答案，不要进行四舍五入。", "solution": "问题陈述是适定的、有科学依据且客观的。这是偏微分方程数值分析中的一个标准练习，特别是在有限元方法领域。所提供的数据是完整且一致的，在一个协调网格上定义了一个唯一的连续分片仿射函数。任务是计算一个标准的 Sobolev 范数，这是一个定义明确的数学运算。因此，该问题是有效的，并且可以推导出解答。\n\n函数 $u_h$ 在域 $\\Omega$ 上的 $H^1$-范数的平方由问题定义为：\n$$\n\\|u_h\\|_{H^1(\\Omega)}^2 = \\int_{\\Omega} \\big(u_h(x)\\big)^2 \\,\\mathrm{d}x \\;+\\; \\int_{\\Omega} \\|\\nabla u_h(x)\\|_2^2 \\,\\mathrm{d}x\n$$\n由于域 $\\Omega$ 是两个不重叠三角形的并集，$\\Omega = K_1 \\cup K_2$，我们可以将总范数分解为来自每个三角形的贡献：\n$$\n\\|u_h\\|_{H^1(\\Omega)}^2 = \\left( \\int_{K_1} u_h^2 \\,d\\mathbf{x} + \\int_{K_2} u_h^2 \\,d\\mathbf{x} \\right) + \\left( \\int_{K_1} \\|\\nabla u_h\\|_2^2 \\,d\\mathbf{x} + \\int_{K_2} \\|\\nabla u_h\\|_2^2 \\,d\\mathbf{x} \\right)\n$$\n其中 $\\mathbf{x}=(x,y)$。函数 $u_h$ 在每个三角形上是仿射的，因此其梯度 $\\nabla u_h$ 在每个三角形上是一个常向量场。\n\n首先，我们分析来自三角形 $K_1 = \\operatorname{conv}\\{(0,0),(2,0),(0,1)\\}$ 的贡献。\n$K_1$ 的顶点是 $V_1=(0,0)$、$V_2=(2,0)$ 和 $V_3=(0,1)$。$u_h$ 在这些顶点处的节点值是 $u_h(V_1)=0$、$u_h(V_2)=2$ 和 $u_h(V_3)=1$。令 $u_h$ 在 $K_1$ 上的限制表示为 $u_1(x,y)=ax+by+c$。我们可以通过施加节点值条件来确定系数 $a$、$b$ 和 $c$：\n$u_1(0,0) = a(0) + b(0) + c = 0 \\implies c=0$。\n$u_1(2,0) = a(2) + b(0) + c = 2 \\implies 2a=2 \\implies a=1$。\n$u_1(0,1) = a(0) + b(1) + c = 1 \\implies b=1$。\n因此，在 $K_1$ 上，函数为 $u_1(x,y) = x+y$。\n$u_1$ 的梯度是常向量 $\\nabla u_1 = (1,1)$。该梯度的欧几里得范数的平方是 $\\|\\nabla u_1\\|_2^2 = 1^2 + 1^2 = 2$。\n$K_1$ 的面积是 $|K_1| = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 2 \\times 1 = 1$。\n因此，在 $K_1$ 上梯度平方的积分为：\n$$\n\\int_{K_1} \\|\\nabla u_1\\|_2^2 \\,d\\mathbf{x} = \\int_{K_1} 2 \\,d\\mathbf{x} = 2 |K_1| = 2(1) = 2.\n$$\n为了计算 $u_1^2$ 的积分，我们使用针对在节点值为 $p_1, p_2, p_3$ 的三角形 $T$ 上的仿射函数 $p$ 的平方的精确求积公式：\n$$\n\\int_T p^2 \\,d\\mathbf{x} = \\frac{|T|}{6} (p_1^2 + p_2^2 + p_3^2 + p_1p_2 + p_1p_3 + p_2p_3).\n$$\n对于在 $K_1$ 上的 $u_1$，其节点值为 $0$、$2$、$1$ 且面积 $|K_1|=1$：\n$$\n\\int_{K_1} u_1^2 \\,d\\mathbf{x} = \\frac{1}{6} \\left(0^2+2^2+1^2 + (0)(2) + (0)(1) + (2)(1)\\right) = \\frac{1}{6} (0+4+1+0+0+2) = \\frac{7}{6}.\n$$\n\n接下来，我们分析来自三角形 $K_2 = \\operatorname{conv}\\{(2,0),(2,2),(0,1)\\}$ 的贡献。\n$K_2$ 的顶点是 $V_2=(2,0)$、$V_4=(2,2)$ 和 $V_3=(0,1)$。节点值是 $u_h(V_2)=2$、$u_h(V_4)=3$ 和 $u_h(V_3)=1$。令 $u_h$ 在 $K_2$ 上的限制为 $u_2(x,y)=dx+ey+f$。我们求解这些系数：\n$u_2(0,1) = d(0)+e(1)+f = 1 \\implies e+f=1$。\n$u_2(2,0) = d(2)+e(0)+f = 2 \\implies 2d+f=2$。\n$u_2(2,2) = d(2)+e(2)+f = 3 \\implies 2d+2e+f=3$。\n将第三个方程减去第二个方程得到 $2e = 1$，所以 $e=1/2$。将此代入第一个方程得出 $f=1-e=1-1/2=1/2$。最后，将 $f$ 代入第二个方程得到 $2d = 2-f = 2-1/2 = 3/2$，所以 $d=3/4$。\n因此，在 $K_2$ 上，函数为 $u_2(x,y) = \\frac{3}{4}x+\\frac{1}{2}y+\\frac{1}{2}$。\n$u_2$ 的梯度是常向量 $\\nabla u_2 = (3/4, 1/2)$。范数的平方是 $\\|\\nabla u_2\\|_2^2 = (3/4)^2+(1/2)^2 = 9/16+4/16 = 13/16$。\n$K_2$ 的面积可以用顶点为 $(2,0)$、$(2,2)$、$(0,1)$ 的鞋带公式计算：\n$|K_2| = \\frac{1}{2} |(2 \\cdot 2 - 0 \\cdot 2) + (2 \\cdot 1 - 2 \\cdot 0) + (0 \\cdot 0 - 1 \\cdot 2)| = \\frac{1}{2} |4+2-2| = 2$。\n在 $K_2$ 上梯度平方的积分为：\n$$\n\\int_{K_2} \\|\\nabla u_2\\|_2^2 \\,d\\mathbf{x} = \\int_{K_2} \\frac{13}{16} \\,d\\mathbf{x} = \\frac{13}{16} |K_2| = \\frac{13}{16}(2) = \\frac{13}{8}.\n$$\n对于 $K_2$ 上的 $L^2$-项，其节点值为 $2$、$3$、$1$ 且面积 $|K_2|=2$：\n$$\n\\int_{K_2} u_2^2 \\,d\\mathbf{x} = \\frac{2}{6} \\left(2^2+3^2+1^2 + (2)(3) + (2)(1) + (3)(1)\\right) = \\frac{1}{3} (4+9+1+6+2+3) = \\frac{25}{3}.\n$$\n\n最后，我们将这四个分量相加，求得总的 $H^1$-范数的平方：\n$$\n\\|u_h\\|_{H^1(\\Omega)}^2 = \\int_{K_1} u_h^2 \\,d\\mathbf{x} + \\int_{K_2} u_h^2 \\,d\\mathbf{x} + \\int_{K_1} \\|\\nabla u_h\\|_2^2 \\,d\\mathbf{x} + \\int_{K_2} \\|\\nabla u_h\\|_2^2 \\,d\\mathbf{x}\n$$\n$$\n\\|u_h\\|_{H^1(\\Omega)}^2 = \\frac{7}{6} + \\frac{25}{3} + 2 + \\frac{13}{8}\n$$\n分别组合 $L^2$ 项和半范数项：\n$$\n\\|u_h\\|_{L^2(\\Omega)}^2 = \\frac{7}{6} + \\frac{50}{6} = \\frac{57}{6} = \\frac{19}{2}.\n$$\n$$\n|u_h|_{H^1(\\Omega)}^2 = 2 + \\frac{13}{8} = \\frac{16}{8} + \\frac{13}{8} = \\frac{29}{8}.\n$$\n总和是：\n$$\n\\|u_h\\|_{H^1(\\Omega)}^2 = \\frac{19}{2} + \\frac{29}{8} = \\frac{76}{8} + \\frac{29}{8} = \\frac{105}{8}.\n$$\n问题要求的是 $H^1$-范数，它是这个值的平方根：\n$$\n\\|u_h\\|_{H^1(\\Omega)} = \\sqrt{\\frac{105}{8}} = \\sqrt{\\frac{105 \\times 2}{16}} = \\frac{\\sqrt{210}}{4}.\n$$\n数字 $210$ 的质因数分解为 $2 \\times 3 \\times 5 \\times 7$，因此它不含平方因子，根式已是最简形式。", "answer": "$$\\boxed{\\frac{\\sqrt{210}}{4}}$$", "id": "3402645"}, {"introduction": "在有限元分析中，我们常常将物理单元上的计算映射到固定的参考单元上，以便于理论分析和程序实现。这个练习将探讨 $H^1$ 范数在这种映射下的变换规律，这对于推导先验误差估计和理解数值方法如何随网格尺寸 $h$ 收敛至关重要。通过这个练习，你将使用链式法则和变量替换等基础工具，来揭示范数在不同尺度域之间的定量关系。[@problem_id:3402638]", "problem": "考虑偏微分方程（PDEs）的数值解背景，其中定义在物理单元上的函数通常被拉回到参考单元上，以分析网格缩放下的稳定性和误差。设参考域为 $\\widehat{\\Omega} = (0,1)^{2}$，物理域为 $\\Omega_{h} = (0,h_{x}) \\times (0,h_{y})$，它由仿射映射 $T_{h} : \\widehat{\\Omega} \\to \\Omega_{h}$ 得到，该映射由 $x = A \\xi$ 给出，其中 $A = \\mathrm{diag}(h_{x}, h_{y})$ 且 $\\xi = (\\xi_{1}, \\xi_{2})^{\\top}$。定义参考函数 $\\widehat{u} : \\widehat{\\Omega} \\to \\mathbb{R}$ 为 $\\widehat{u}(\\xi) = \\xi_{1}^{2} + \\xi_{2}^{3}$，并定义物理函数 $u : \\Omega_{h} \\to \\mathbb{R}$ 为 $u(x) = \\widehat{u}(A^{-1} x)$，因此 $u$ 是 $\\widehat{u}$ 在 $T_{h}$ 映射下的拉回。\n\n从 $L^{2}$ 范数、$H^{1}$ 半范数和 $H^{1}$ 范数的核心定义出发，\n$$\\|u\\|_{L^{2}(\\Omega)}^{2} = \\int_{\\Omega} |u(x)|^{2} \\, dx, \\quad |u|_{H^{1}(\\Omega)}^{2} = \\int_{\\Omega} |\\nabla u(x)|^{2} \\, dx, \\quad \\|u\\|_{H^{1}(\\Omega)}^{2} = \\|u\\|_{L^{2}(\\Omega)}^{2} + |u|_{H^{1}(\\Omega)}^{2},$$\n仅使用链式法则和变量替换等基本工具，推导并以闭式形式计算出 $H^{1}$ 范数的平方 $\\|u\\|_{H^{1}(\\Omega_{h})}^{2}$ 作为 $h_{x}$ 和 $h_{y}$ 的函数的精确解析表达式。\n\n你的最终答案必须是关于 $h_{x}$ 和 $h_{y}$ 的单个闭式表达式。无需四舍五入。", "solution": "该问题要求计算定义在物理域 $\\Omega_{h}$ 上的函数 $u$ 的 $H^{1}$ 范数的平方，其中 $u$ 通过一个仿射变换与定义在参考域 $\\widehat{\\Omega}$ 上的函数 $\\widehat{u}$ 相关联。$H^{1}$ 范数的平方定义为 $L^{2}$ 范数的平方与 $H^{1}$ 半范数的平方之和：\n$$\n\\|u\\|_{H^{1}(\\Omega_{h})}^{2} = \\|u\\|_{L^{2}(\\Omega_{h})}^{2} + |u|_{H^{1}(\\Omega_{h})}^{2}\n$$\n我们将通过把积分从物理域 $\\Omega_{h} = (0,h_{x}) \\times (0,h_{y})$ 变换到参考域 $\\widehat{\\Omega} = (0,1)^{2}$ 来分别计算右侧的每一项。\n\n变换由 $x = T_{h}(\\xi) = A\\xi$ 给出，其中 $x = (x_{1}, x_{2})^{\\top}$，$\\xi = (\\xi_{1}, \\xi_{2})^{\\top}$，且 $A = \\mathrm{diag}(h_{x}, h_{y})$。此变换的雅可比矩阵为 $J = \\frac{\\partial x}{\\partial \\xi} = A$。雅可比行列式为 $\\det(J) = h_{x}h_{y}$。在积分中进行变量替换时，我们使用行列式的绝对值，因此微分面积元变换为 $dx = |\\det(J)| \\, d\\xi = h_{x}h_{y} \\, d\\xi$，假设 $h_{x} > 0$ 和 $h_{y} > 0$，因为它们代表物理尺寸。物理域上的函数 $u$ 与参考域上的函数 $\\widehat{u}$ 的关系为 $u(x) = \\widehat{u}(A^{-1}x)$，这等价于 $u(T_h(\\xi)) = \\widehat{u}(\\xi)$。\n\n首先，我们计算 $L^{2}$ 范数的平方，$\\|u\\|_{L^{2}(\\Omega_{h})}^{2}$。\n根据定义，$\\|u\\|_{L^{2}(\\Omega_{h})}^{2} = \\int_{\\Omega_{h}} |u(x)|^{2} \\, dx$。\n应用变量替换 $x = A\\xi$：\n$$\n\\|u\\|_{L^{2}(\\Omega_{h})}^{2} = \\int_{\\widehat{\\Omega}} |u(A\\xi)|^{2} |\\det(J)| \\, d\\xi = \\int_{\\widehat{\\Omega}} |\\widehat{u}(\\xi)|^{2} (h_{x}h_{y}) \\, d\\xi\n$$\n给定 $\\widehat{u}(\\xi) = \\xi_{1}^{2} + \\xi_{2}^{3}$，我们有 $|\\widehat{u}(\\xi)|^{2} = (\\xi_{1}^{2} + \\xi_{2}^{3})^{2} = \\xi_{1}^{4} + 2\\xi_{1}^{2}\\xi_{2}^{3} + \\xi_{2}^{6}$。\n积分为：\n$$\n\\|u\\|_{L^{2}(\\Omega_{h})}^{2} = h_{x}h_{y} \\int_{0}^{1} \\int_{0}^{1} (\\xi_{1}^{4} + 2\\xi_{1}^{2}\\xi_{2}^{3} + \\xi_{2}^{6}) \\, d\\xi_{1} \\, d\\xi_{2}\n$$\n我们首先对 $\\xi_{1}$ 进行积分：\n$$\n\\int_{0}^{1} (\\xi_{1}^{4} + 2\\xi_{1}^{2}\\xi_{2}^{3} + \\xi_{2}^{6}) \\, d\\xi_{1} = \\left[ \\frac{\\xi_{1}^{5}}{5} + \\frac{2\\xi_{1}^{3}}{3}\\xi_{2}^{3} + \\xi_{1}\\xi_{2}^{6} \\right]_{\\xi_{1}=0}^{1} = \\frac{1}{5} + \\frac{2}{3}\\xi_{2}^{3} + \\xi_{2}^{6}\n$$\n现在我们将结果对 $\\xi_{2}$ 进行积分：\n$$\n\\int_{0}^{1} \\left(\\frac{1}{5} + \\frac{2}{3}\\xi_{2}^{3} + \\xi_{2}^{6}\\right) \\, d\\xi_{2} = \\left[ \\frac{1}{5}\\xi_{2} + \\frac{2}{3}\\frac{\\xi_{2}^{4}}{4} + \\frac{\\xi_{2}^{7}}{7} \\right]_{0}^{1} = \\frac{1}{5} + \\frac{1}{6} + \\frac{1}{7}\n$$\n为了将分数相加，我们找到公分母 $210$：\n$$\n\\frac{1}{5} + \\frac{1}{6} + \\frac{1}{7} = \\frac{42}{210} + \\frac{35}{210} + \\frac{30}{210} = \\frac{107}{210}\n$$\n因此，$L^{2}$ 范数的平方为：\n$$\n\\|u\\|_{L^{2}(\\Omega_{h})}^{2} = \\frac{107}{210}h_{x}h_{y}\n$$\n\n接下来，我们计算 $H^{1}$ 半范数的平方，$|u|_{H^{1}(\\Omega_{h})}^{2}$。\n根据定义，$|u|_{H^{1}(\\Omega_{h})}^{2} = \\int_{\\Omega_{h}} |\\nabla_{x} u(x)|^{2} \\, dx$，其中 $\\nabla_{x}$ 是关于物理坐标 $x = (x_{1}, x_{2})^{\\top}$ 的梯度。\n我们必须将物理梯度 $\\nabla_{x} u$ 与参考梯度 $\\nabla_{\\xi} \\widehat{u}$ 联系起来。使用链式法则，我们有 $\\nabla_{\\xi} \\widehat{u} = J^{\\top} \\nabla_{x} u$。因此，$\\nabla_{x} u = (J^{\\top})^{-1} \\nabla_{\\xi} \\widehat{u}$。\n由于 $J = A = \\mathrm{diag}(h_{x}, h_{y})$，$J$ 是对称的，所以 $J^{\\top} = J = A$。其逆矩阵为 $A^{-1} = \\mathrm{diag}(h_{x}^{-1}, h_{y}^{-1})$。\n所以，$\\nabla_{x} u = A^{-1} \\nabla_{\\xi} \\widehat{u}$。\n参考梯度为 $\\nabla_{\\xi} \\widehat{u} = \\left(\\frac{\\partial \\widehat{u}}{\\partial \\xi_{1}}, \\frac{\\partial \\widehat{u}}{\\partial \\xi_{2}}\\right)^{\\top} = (2\\xi_{1}, 3\\xi_{2}^{2})^{\\top}$。\n那么物理梯度是：\n$$\n\\nabla_{x} u = \\begin{pmatrix} h_{x}^{-1}  0 \\\\ 0  h_{y}^{-1} \\end{pmatrix} \\begin{pmatrix} 2\\xi_{1} \\\\ 3\\xi_{2}^{2} \\end{pmatrix} = \\begin{pmatrix} 2h_{x}^{-1}\\xi_{1} \\\\ 3h_{y}^{-1}\\xi_{2}^{2} \\end{pmatrix}\n$$\n物理梯度的模的平方是：\n$$\n|\\nabla_{x} u|^{2} = (2h_{x}^{-1}\\xi_{1})^{2} + (3h_{y}^{-1}\\xi_{2}^{2})^{2} = 4h_{x}^{-2}\\xi_{1}^{2} + 9h_{y}^{-2}\\xi_{2}^{4}\n$$\n现在我们可以建立半范数的积分，将变量变换到参考域：\n$$\n|u|_{H^{1}(\\Omega_{h})}^{2} = \\int_{\\widehat{\\Omega}} \\left(4h_{x}^{-2}\\xi_{1}^{2} + 9h_{y}^{-2}\\xi_{2}^{4}\\right) |\\det(J)| \\, d\\xi = h_{x}h_{y} \\int_{0}^{1} \\int_{0}^{1} \\left(4h_{x}^{-2}\\xi_{1}^{2} + 9h_{y}^{-2}\\xi_{2}^{4}\\right) \\, d\\xi_{1} \\, d\\xi_{2}\n$$\n我们可以将其分成两个积分：\n$$\n|u|_{H^{1}(\\Omega_{h})}^{2} = h_{x}h_{y} \\left( \\int_{0}^{1} \\int_{0}^{1} 4h_{x}^{-2}\\xi_{1}^{2} \\, d\\xi_{1} \\, d\\xi_{2} + \\int_{0}^{1} \\int_{0}^{1} 9h_{y}^{-2}\\xi_{2}^{4} \\, d\\xi_{1} \\, d\\xi_{2} \\right)\n$$\n第一个积分是：\n$$\n\\int_{0}^{1} \\int_{0}^{1} 4h_{x}^{-2}\\xi_{1}^{2} \\, d\\xi_{1} \\, d\\xi_{2} = 4h_{x}^{-2} \\left(\\int_{0}^{1}\\,d\\xi_2\\right) \\left(\\int_{0}^{1} \\xi_{1}^{2} \\, d\\xi_{1}\\right) = 4h_{x}^{-2} (1) \\left[\\frac{\\xi_{1}^{3}}{3}\\right]_{0}^{1} = \\frac{4}{3}h_{x}^{-2}\n$$\n第二个积分是：\n$$\n\\int_{0}^{1} \\int_{0}^{1} 9h_{y}^{-2}\\xi_{2}^{4} \\, d\\xi_{1} \\, d\\xi_{2} = 9h_{y}^{-2} \\left(\\int_{0}^{1}\\,d\\xi_1\\right) \\left(\\int_{0}^{1} \\xi_{2}^{4} \\, d\\xi_{2}\\right) = 9h_{y}^{-2} (1) \\left[\\frac{\\xi_{2}^{5}}{5}\\right]_{0}^{1} = \\frac{9}{5}h_{y}^{-2}\n$$\n将这些代回半范数的表达式中：\n$$\n|u|_{H^{1}(\\Omega_{h})}^{2} = h_{x}h_{y} \\left( \\frac{4}{3}h_{x}^{-2} + \\frac{9}{5}h_{y}^{-2} \\right) = \\frac{4}{3}h_{x}^{-1}h_{y} + \\frac{9}{5}h_{x}h_{y}^{-1} = \\frac{4}{3}\\frac{h_{y}}{h_{x}} + \\frac{9}{5}\\frac{h_{x}}{h_{y}}\n$$\n\n最后，我们将两个分量相加，得到 $H^{1}$ 范数的平方：\n$$\n\\|u\\|_{H^{1}(\\Omega_{h})}^{2} = \\|u\\|_{L^{2}(\\Omega_{h})}^{2} + |u|_{H^{1}(\\Omega_{h})}^{2} = \\frac{107}{210}h_{x}h_{y} + \\frac{4}{3}\\frac{h_{y}}{h_{x}} + \\frac{9}{5}\\frac{h_{x}}{h_{y}}\n$$\n这是 $\\Omega_{h}$ 上 $u$ 的 $H^{1}$ 范数的平方作为 $h_{x}$ 和 $h_{y}$ 的函数的最终解析表达式。", "answer": "$$\n\\boxed{\\frac{107}{210}h_{x}h_{y} + \\frac{4}{3}\\frac{h_{y}}{h_{x}} + \\frac{9}{5}\\frac{h_{x}}{h_{y}}}\n$$", "id": "3402638"}, {"introduction": "虽然解析计算有助于理解理论，但在实际应用中，我们几乎总是需要通过数值方法来计算积分。本练习要求你编写一个程序，使用高斯-勒让德求积法则来近似计算函数的 $H^1$ 范数和半范数，这是构建任何有限元求解器的核心技能。通过将你的数值结果与解析解或高精度参考解进行比较，你还将学习到如何验证代码的正确性和评估数值误差。[@problem_id:3402666]", "problem": "给定有界利普希茨域 $\\Omega \\subset \\mathbb{R}^{d}$ 上的索博列夫空间 $H^{1}(\\Omega)$，对于一个足够光滑的函数 $u$，$H^{1}$半范数和范数通过勒贝格积分定义如下：\n$$\n|u|_{H^{1}(\\Omega)} = \\left( \\int_{\\Omega} \\|\\nabla u(\\mathbf{x})\\|^{2} \\, \\mathrm{d}\\mathbf{x} \\right)^{1/2}, \\quad \\|u\\|_{H^{1}(\\Omega)} = \\left( \\int_{\\Omega} |u(\\mathbf{x})|^{2} \\, \\mathrm{d}\\mathbf{x} + \\int_{\\Omega} \\|\\nabla u(\\mathbf{x})\\|^{2} \\, \\mathrm{d}\\mathbf{x} \\right)^{1/2}.\n$$\n在偏微分方程（PDE; Partial Differential Equation）的数值求解中，对这些积分的实际计算需要使用数值积分。考虑在单位正方形域 $\\Omega = [0,1]^{2}$ 的一个划分为 $N \\times N$ 个全等矩形的均匀剖分上，使用张量积高斯-勒让德求积法。在每个单元 $K = [x_{i},x_{i+1}] \\times [y_{j},y_{j+1}]$（其中 $x_{i+1}-x_{i} = h_{x}$ 且 $y_{j+1}-y_{j} = h_{y}$）上，函数 $f$ 的积分通过将 $[-1,1]$ 上的 $q$ 点高斯-勒让德节点和权重 $\\{(\\xi_{a},w_{a})\\}_{a=1}^{q}$ 经由仿射映射 $\\Phi(\\xi,\\eta) = (x_{i} + \\tfrac{h_{x}}{2}(\\xi+1),\\, y_{j} + \\tfrac{h_{y}}{2}(\\eta+1))$ 映射到 $K$ 上，然后求和来近似：\n$$\n\\int_{K} f(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y \\approx \\frac{h_{x} h_{y}}{4} \\sum_{a=1}^{q} \\sum_{b=1}^{q} w_{a} w_{b} \\, f\\!\\left( \\Phi(\\xi_{a},\\eta_{b}) \\right).\n$$\n\n任务：实现一个完整的程序，该程序从以上定义和求积原理出发，计算特定测试函数在 $\\Omega = [0,1]^{2}$ 上的 $H^{1}$ 半范数和范数的数值近似值，并报告其与可信值之间的误差。\n\n使用以下函数 $u:\\Omega \\to \\mathbb{R}$ 测试集，其梯度 $\\nabla u$ 在经典意义下定义：\n- 情况 $\\mathbf{1}$ (光滑三角函数): $u_{1}(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n- 情况 $\\mathbf{2}$ (多项式鼓泡函数): $u_{2}(x,y) = x(1-x)y(1-y)$.\n- 情况 $\\mathbf{3}$ (零函数): $u_{3}(x,y) \\equiv 0$.\n- 情况 $\\mathbf{4}$ (光滑指数脊函数): $u_{4}(x,y) = \\exp(\\alpha x y)$，参数 $\\alpha = 7$。\n\n数值规格：\n- 使用 $N = 12$ 的均匀 $N \\times N$ 剖分和 $q = 5$ 阶的张量积高斯-勒让德法则，为 $|u|_{H^{1}(\\Omega)}$ 和 $\\|u\\|_{H^{1}(\\Omega)}$ 生成主要近似值。\n- 对于误差评估，按以下方式进行：\n  - 对于情况 $\\mathbf{1}$ 和 $\\mathbf{2}$，精确值可以通过变量分离和多项式积分解析计算得出；程序必须仅从给定的定义出发，使用数学上合理的方法在内部获得可信值（这两种情况允许进行解析计算）。\n  - 对于情况 $\\mathbf{3}$，$H^{1}$ 半范数和 $H^{1}$ 范数的精确值均为 $0$。\n  - 对于情况 $\\mathbf{4}$，由于所需积分不存在用初等函数表示的闭式原函数，因此通过更精细的求积方法获得高精度参考值：使用 $N_{\\mathrm{ref}} = 48$ 和 $q_{\\mathrm{ref}} = 8$，采用相同的张量积高斯-勒让德方法生成可信值。\n\n误差报告：\n- 对于每个可信值非零的情况，输出半范数和范数的相对误差，其定义为 $E_{\\mathrm{rel}} = \\dfrac{|\\text{approx} - \\text{trusted}|}{\\text{trusted}}$。\n- 对于情况 $\\mathbf{3}$，由于可信值为零，输出半范数和范数的绝对近似值本身（即，使用 $E_{\\mathrm{abs}} = |\\text{approx}|$）。\n- 按以下固定顺序组合所有八个结果：\n  $[E_{1}^{\\mathrm{semi}}, E_{1}^{\\mathrm{norm}}, E_{2}^{\\mathrm{semi}}, E_{2}^{\\mathrm{norm}}, E_{3}^{\\mathrm{semi}}, E_{3}^{\\mathrm{norm}}, E_{4}^{\\mathrm{semi}}, E_{4}^{\\mathrm{norm}}]$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 每个浮点值必须以科学记数法打印，并精确到 $10$ 位有效数字（即小数点前 $1$ 位，小数点后 $9$ 位），例如 $1.234567890\\mathrm{e}{-04}$。\n- 不应打印任何其他文本。\n\n角度单位不适用。物理单位不适用。所有计算都在单位正方形 $\\Omega = [0,1]^{2}$ 上进行，没有额外的缩放。", "solution": "该问题是适定的，其基础是泛函分析和偏微分方程数值方法的原理。它为计算单位正方形上四个不同函数的 $H^{1}$ 半范数和范数的近似值，以及评估这些近似值的准确性，提供了一套完整且一致的规范。因此，该问题是有效的。我们现在开始进行详细的求解。\n\n目标是计算在域 $\\Omega = [0,1]^{2}$ 上定义的函数 $u$ 的 $H^{1}$ 半范数和范数的数值近似值。定义如下：\n$$|u|_{H^{1}(\\Omega)} = \\left( \\int_{\\Omega} \\|\\nabla u(\\mathbf{x})\\|^{2} \\, \\mathrm{d}\\mathbf{x} \\right)^{1/2}$$\n$$\\|u\\|_{H^{1}(\\Omega)} = \\left( \\int_{\\Omega} |u(\\mathbf{x})|^{2} \\, \\mathrm{d}\\mathbf{x} + \\int_{\\Omega} \\|\\nabla u(\\mathbf{x})\\|^{2} \\, \\mathrm{d}\\mathbf{x} \\right)^{1/2} = \\left( \\|u\\|_{L^2(\\Omega)}^2 + |u|_{H^{1}(\\Omega)}^2 \\right)^{1/2}$$\n此处，$\\nabla u$ 是 $u$ 的梯度，$\\|\\cdot\\|$ 表示向量的欧几里得范数。任务的核心是使用数值积分来计算 $\\int_{\\Omega} |u|^{2} \\, \\mathrm{d}\\mathbf{x}$ 和 $\\int_{\\Omega} \\|\\nabla u\\|^{2} \\, \\mathrm{d}\\mathbf{x}$ 这两个积分。\n\n域 $\\Omega = [0,1]^2$ 被剖分为一个由 $N \\times N$ 个矩形单元组成的均匀网格。对于 $N=12$，每个单元 $K_{ij} = [x_i, x_{i+1}] \\times [y_j, y_{j+1}]$（其中 $i,j \\in \\{0, \\dots, N-1\\}$）的尺寸为 $h_x = h_y = h = 1/N = 1/12$。在 $\\Omega$ 上的积分是其在每个单元 $K_{ij}$ 上积分的总和：\n$$\\int_{\\Omega} f(\\mathbf{x}) \\, \\mathrm{d}\\mathbf{x} = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\int_{K_{ij}} f(x,y) \\, \\mathrm{d}x\\mathrm{d}y$$\n\n单个单元 $K$ 上的积分使用 $q$ 点张量积高斯-勒让德求积法则进行近似。这涉及一个从参考正方形 $[-1,1]^2$ 到单元 $K = [x_i, x_{i+1}] \\times [y_j, y_{j+1}]$ 的仿射变量变换。该映射由 $\\mathbf{x} = \\Phi(\\boldsymbol{\\xi})$ 给出，其中 $\\mathbf{x}=(x,y)$ 且 $\\boldsymbol{\\xi}=(\\xi, \\eta)$：\n$$x = x_i + \\frac{h_x}{2}(\\xi+1), \\quad y = y_j + \\frac{h_y}{2}(\\eta+1)$$\n微分面积元的变换关系为 $\\mathrm{d}x\\mathrm{d}y = \\det(D\\Phi) \\, \\mathrm{d}\\xi\\mathrm{d}\\eta$，其中雅可比行列式为 $\\det(D\\Phi) = \\frac{h_x}{2} \\cdot \\frac{h_y}{2} = \\frac{h_x h_y}{4}$。那么在 $K$ 上的积分近似为：\n$$\\int_{K} f(x,y) \\, \\mathrm{d}x\\mathrm{d}y = \\int_{-1}^{1}\\int_{-1}^{1} f(\\Phi(\\xi,\\eta)) \\frac{h_x h_y}{4} \\, \\mathrm{d}\\xi\\mathrm{d}\\eta \\approx \\frac{h_x h_y}{4} \\sum_{a=1}^{q} \\sum_{b=1}^{q} w_a w_b f(\\Phi(\\xi_a, \\xi_b))$$\n其中 $\\{(\\xi_a, w_a)\\}_{a=1}^q$ 是 $[-1,1]$ 上的 $q$ 点高斯-勒让德节点和权重。\n\n整体算法是实现一个通用函数，对于给定的被积函数 $f$、网格剖分数 $N$ 和求积阶数 $q$，执行这种二维数值积分。该函数将用于计算每个测试用例所需的积分。\n\n我们将数值计算的积分记为 $I_h(|u|^2)$ 和 $I_h(\\|\\nabla u\\|^2)$。那么近似的半范数和范数是：\n$$|u|_{H^1, h} = \\sqrt{I_h(\\|\\nabla u\\|^2)}, \\quad \\|u\\|_{H^1, h} = \\sqrt{I_h(|u|^2) + I_h(\\|\\nabla u\\|^2)}$$\n\n我们现在将分析每种情况，以确定被积函数、可信值以及相应的误差。\n\n**情况 1: $u_1(x,y) = \\sin(\\pi x)\\sin(\\pi y)$**\n梯度为 $\\nabla u_1(x,y) = (\\pi\\cos(\\pi x)\\sin(\\pi y), \\pi\\sin(\\pi x)\\cos(\\pi y))$。被积函数为：\n$$|u_1|^2 = \\sin^2(\\pi x)\\sin^2(\\pi y)$$\n$$\\|\\nabla u_1\\|^2 = \\pi^2(\\cos^2(\\pi x)\\sin^2(\\pi y) + \\sin^2(\\pi x)\\cos^2(\\pi y))$$\n可信值通过解析积分获得。使用恒等式 $\\int_0^1 \\sin^2(\\pi z) \\, \\mathrm{d}z = 1/2$ 和 $\\int_0^1 \\cos^2(\\pi z) \\, \\mathrm{d}z = 1/2$：\n$$\\int_{\\Omega} |u_1|^2 \\, \\mathrm{d}\\mathbf{x} = \\left(\\int_0^1 \\sin^2(\\pi x)\\mathrm{d}x\\right)\\left(\\int_0^1 \\sin^2(\\pi y)\\mathrm{d}y\\right) = \\frac{1}{2} \\cdot \\frac{1}{2} = \\frac{1}{4}$$\n$$\\int_{\\Omega} \\|\\nabla u_1\\|^2 \\, \\mathrm{d}\\mathbf{x} = \\pi^2 \\left[ \\left(\\int_0^1 \\cos^2(\\pi x)\\mathrm{d}x\\right)\\left(\\int_0^1 \\sin^2(\\pi y)\\mathrm{d}y\\right) + \\left(\\int_0^1 \\sin^2(\\pi x)\\mathrm{d}x\\right)\\left(\\int_0^1 \\cos^2(\\pi y)\\mathrm{d}y\\right) \\right] = \\pi^2 \\left[ \\frac{1}{2}\\cdot\\frac{1}{2} + \\frac{1}{2}\\cdot\\frac{1}{2} \\right] = \\frac{\\pi^2}{2}$$\n所以，可信值为 $|u_1|_{H^1} = \\sqrt{\\pi^2/2} = \\pi/\\sqrt{2}$ 和 $\\|u_1\\|_{H^1} = \\sqrt{1/4 + \\pi^2/2}$。\n数值近似使用 $N=12, q=5$ 计算。误差是相对误差： $E_{\\mathrm{rel}} = |\\text{approx} - \\text{trusted}|/\\text{trusted}$。\n\n**情况 2: $u_2(x,y) = x(1-x)y(1-y)$**\n梯度为 $\\nabla u_2(x,y) = ((1-2x)y(1-y), x(1-x)(1-2y))$。被积函数为：\n$$|u_2|^2 = x^2(1-x)^2 y^2(1-y)^2$$\n$$\\|\\nabla u_2\\|^2 = (1-2x)^2 y^2(1-y)^2 + x^2(1-x)^2 (1-2y)^2$$\n可信值来自解析积分。我们需要定积分：\n$\\int_0^1 z^2(1-z)^2\\,\\mathrm{d}z = \\int_0^1 (z^2-2z^3+z^4)\\,\\mathrm{d}z = [z^3/3 - z^4/2 + z^5/5]_0^1 = 1/30$。\n$\\int_0^1 (1-2z)^2\\,\\mathrm{d}z = \\int_0^1 (1-4z+4z^2)\\,\\mathrm{d}z = [z - 2z^2 + 4z^3/3]_0^1 = 1/3$。\n$$\\int_{\\Omega} |u_2|^2\\,\\mathrm{d}\\mathbf{x} = \\left(\\int_0^1 x^2(1-x)^2\\mathrm{d}x\\right)\\left(\\int_0^1 y^2(1-y)^2\\mathrm{d}y\\right) = \\frac{1}{30} \\cdot \\frac{1}{30} = \\frac{1}{900}$$\n$$\\int_{\\Omega} \\|\\nabla u_2\\|^2\\,\\mathrm{d}\\mathbf{x} = \\left(\\int_0^1 (1-2x)^2\\mathrm{d}x\\right)\\left(\\int_0^1 y^2(1-y)^2\\mathrm{d}y\\right) + \\left(\\int_0^1 x^2(1-x)^2\\mathrm{d}x\\right)\\left(\\int_0^1 (1-2y)^2\\mathrm{d}y\\right) = \\frac{1}{3} \\cdot \\frac{1}{30} + \\frac{1}{30} \\cdot \\frac{1}{3} = \\frac{2}{90} = \\frac{1}{45}$$\n可信值为：$|u_2|_{H^1} = \\sqrt{1/45}$ 和 $\\|u_2\\|_{H^1} = \\sqrt{1/900 + 1/45} = \\sqrt{21/900} = \\sqrt{21}/30$。\n数值近似使用 $N=12, q=5$ 计算，误差是相对误差。因为 $u_2$ 是关于每个变量的 $4$ 次多项式，所以被积函数 $|u_2|^2$ 和 $\\|\\nabla u_2\\|^2$ 是次数最高为 $8$ 的多项式。一个 $q$ 点高斯法则对于次数最高为 $2q-1$ 的多项式是精确的。当 $q=5$ 时，该法则对于次数最高为 $9$ 的多项式是精确的，所以我们期望数值积分能得到与解析值相等的结果，直到机器精度。\n\n**情况 3: $u_3(x,y) = 0$**\n对于零函数，$u_3=0$ 且 $\\nabla u_3=0$。因此，被积函数 $|u_3|^2$ 和 $\\|\\nabla u_3\\|^2$ 恒为零。精确积分为 $0$。\n可信值为 $|u_3|_{H^1}=0$ 和 $\\|u_3\\|_{H^1}=0$。零函数的数值积分应产生 $0$ 或一个浮点精度量级的值。\n对于这种值为零的情况，误差是绝对误差：$E_{\\text{abs}} = |\\text{approx}| = \\text{approx}$。\n\n**情况 4: $u_4(x,y) = \\exp(\\alpha x y)$，参数 $\\alpha=7$**\n梯度为 $\\nabla u_4(x,y) = (\\alpha y \\exp(\\alpha x y), \\alpha x \\exp(\\alpha x y))$。被积函数为：\n$$|u_4|^2 = \\exp(2\\alpha x y)$$\n$$\\|\\nabla u_4\\|^2 = \\alpha^2(x^2+y^2)\\exp(2\\alpha x y)$$\n这些函数没有初等原函数。按照指示，可信值通过使用 $N_{\\mathrm{ref}}=48$ 和 $q_{\\mathrm{ref}}=8$ 的高精度数值积分获得。主要近似值使用 $N=12$ 和 $q=5$ 计算。误差是相对的。\n\n实现将构建一个计算二维积分的函数，然后为四种情况中的每一种按所述方式应用该函数，按顺序计算并收集八个指定的误差度量。最终结果以要求的格式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes H1 seminorm and norm approximations and errors for four test cases.\n    \"\"\"\n    \n    def integrate_2d(f, N, q_nodes, q_weights):\n        \"\"\"\n        Numerically integrates a function f over the unit square [0,1]^2.\n\n        Args:\n            f: The function to integrate, taking two arguments (x, y).\n            N: The number of grid cells in each direction.\n            q_nodes: 1D Gauss-Legendre quadrature nodes on [-1, 1].\n            q_weights: 1D Gauss-Legendre quadrature weights.\n\n        Returns:\n            The numerical approximation of the integral.\n        \"\"\"\n        h = 1.0 / N\n        q = len(q_nodes)\n        total_integral = 0.0\n\n        for i in range(N):\n            x_i = i * h\n            for j in range(N):\n                y_j = j * h\n                cell_integral = 0.0\n                for a in range(q):\n                    for b in range(q):\n                        xi_a, w_a = q_nodes[a], q_weights[a]\n                        xi_b, w_b = q_nodes[b], q_weights[b]\n                        \n                        # Affine mapping from reference square to cell K_ij\n                        x = x_i + (h / 2.0) * (xi_a + 1.0)\n                        y = y_j + (h / 2.0) * (xi_b + 1.0)\n                        \n                        cell_integral += w_a * w_b * f(x, y)\n                \n                # Add scaled cell integral to total\n                # The factor h*h/4 is the Jacobian determinant of the mapping\n                total_integral += (h * h / 4.0) * cell_integral\n                \n        return total_integral\n\n    results = []\n\n    # --- Case 1: u1(x,y) = sin(pi*x)*sin(pi*y) ---\n    u1_sq = lambda x, y: (np.sin(np.pi * x) * np.sin(np.pi * y))**2\n    grad_u1_norm_sq = lambda x, y: (np.pi**2) * ( (np.cos(np.pi * x) * np.sin(np.pi * y))**2 + (np.sin(np.pi * x) * np.cos(np.pi * y))**2 )\n    \n    # Analytical trusted values\n    trusted_I_u1_sq = 1.0 / 4.0\n    trusted_I_grad_u1_sq = np.pi**2 / 2.0\n    trusted_seminorm1 = np.sqrt(trusted_I_grad_u1_sq)\n    trusted_norm1 = np.sqrt(trusted_I_u1_sq + trusted_I_grad_u1_sq)\n    \n    # Numerical approximation\n    N, q = 12, 5\n    nodes_5, weights_5 = roots_legendre(q)\n    approx_I_u1_sq = integrate_2d(u1_sq, N, nodes_5, weights_5)\n    approx_I_grad_u1_sq = integrate_2d(grad_u1_norm_sq, N, nodes_5, weights_5)\n    approx_seminorm1 = np.sqrt(approx_I_grad_u1_sq)\n    approx_norm1 = np.sqrt(approx_I_u1_sq + approx_I_grad_u1_sq)\n\n    # Errors\n    err_seminorm1 = np.abs(approx_seminorm1 - trusted_seminorm1) / trusted_seminorm1\n    err_norm1 = np.abs(approx_norm1 - trusted_norm1) / trusted_norm1\n    results.extend([err_seminorm1, err_norm1])\n\n    # --- Case 2: u2(x,y) = x(1-x)y(1-y) ---\n    u2_sq = lambda x, y: (x * (1 - x) * y * (1 - y))**2\n    grad_u2_norm_sq = lambda x, y: ((1 - 2*x) * y * (1 - y))**2 + (x * (1 - x) * (1 - 2*y))**2\n\n    # Analytical trusted values\n    trusted_I_u2_sq = 1.0 / 900.0\n    trusted_I_grad_u2_sq = 1.0 / 45.0\n    trusted_seminorm2 = np.sqrt(trusted_I_grad_u2_sq)\n    trusted_norm2 = np.sqrt(trusted_I_u2_sq + trusted_I_grad_u2_sq)\n\n    # Numerical approximation - should be exact up to machine precision\n    approx_I_u2_sq = integrate_2d(u2_sq, N, nodes_5, weights_5)\n    approx_I_grad_u2_sq = integrate_2d(grad_u2_norm_sq, N, nodes_5, weights_5)\n    approx_seminorm2 = np.sqrt(approx_I_grad_u2_sq)\n    approx_norm2 = np.sqrt(approx_I_u2_sq + approx_I_grad_u2_sq)\n\n    # Errors\n    err_seminorm2 = np.abs(approx_seminorm2 - trusted_seminorm2) / trusted_seminorm2\n    err_norm2 = np.abs(approx_norm2 - trusted_norm2) / trusted_norm2\n    results.extend([err_seminorm2, err_norm2])\n\n    # --- Case 3: u3(x,y) = 0 ---\n    u3_sq = lambda x, y: 0.0\n    grad_u3_norm_sq = lambda x, y: 0.0\n\n    # Numerical approximation\n    approx_I_u3_sq = integrate_2d(u3_sq, N, nodes_5, weights_5)\n    approx_I_grad_u3_sq = integrate_2d(grad_u3_norm_sq, N, nodes_5, weights_5)\n    approx_seminorm3 = np.sqrt(approx_I_grad_u3_sq)\n    approx_norm3 = np.sqrt(approx_I_u3_sq + approx_I_grad_u3_sq)\n    \n    # Errors (absolute)\n    err_seminorm3 = np.abs(approx_seminorm3)\n    err_norm3 = np.abs(approx_norm3)\n    results.extend([err_seminorm3, err_norm3])\n\n    # --- Case 4: u4(x,y) = exp(alpha*x*y) with alpha=7 ---\n    alpha = 7.0\n    u4_sq = lambda x, y: np.exp(2.0 * alpha * x * y)\n    grad_u4_norm_sq = lambda x, y: (alpha**2) * (x**2 + y**2) * np.exp(2.0 * alpha * x * y)\n\n    # High-accuracy reference values\n    N_ref, q_ref = 48, 8\n    nodes_8, weights_8 = roots_legendre(q_ref)\n    trusted_I_u4_sq = integrate_2d(u4_sq, N_ref, nodes_8, weights_8)\n    trusted_I_grad_u4_sq = integrate_2d(grad_u4_norm_sq, N_ref, nodes_8, weights_8)\n    trusted_seminorm4 = np.sqrt(trusted_I_grad_u4_sq)\n    trusted_norm4 = np.sqrt(trusted_I_u4_sq + trusted_I_grad_u4_sq)\n\n    # Numerical approximation\n    approx_I_u4_sq = integrate_2d(u4_sq, N, nodes_5, weights_5)\n    approx_I_grad_u4_sq = integrate_2d(grad_u4_norm_sq, N, nodes_5, weights_5)\n    approx_seminorm4 = np.sqrt(approx_I_grad_u4_sq)\n    approx_norm4 = np.sqrt(approx_I_u4_sq + approx_I_grad_u4_sq)\n\n    # Errors\n    err_seminorm4 = np.abs(approx_seminorm4 - trusted_seminorm4) / trusted_seminorm4\n    err_norm4 = np.abs(approx_norm4 - trusted_norm4) / trusted_norm4\n    results.extend([err_seminorm4, err_norm4])\n\n    print(f\"[{','.join(f'{r:.9e}' for r in results)}]\")\n\nsolve()\n```", "id": "3402666"}]}