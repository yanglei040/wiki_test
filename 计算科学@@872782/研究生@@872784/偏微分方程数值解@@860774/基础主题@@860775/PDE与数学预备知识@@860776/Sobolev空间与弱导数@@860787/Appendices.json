{"hands_on_practices": [{"introduction": "在无限维函数空间（如索博列夫空间）中，收敛是一个微妙的概念，分为强收敛和弱收敛。这个练习通过一个具体的计算，构建了一个在 $H^1$ 空间中弱收敛但不强收敛的函数序列，从而帮助你亲手阐明这两种收敛方式的本质区别。理解这一区别对于分析数值格式的稳定性至关重要。[@problem_id:3444217]", "problem": "令 $\\Omega = (0,1)$，并考虑 Sobolev 空间 $H^{1}(\\Omega)$，该空间由弱导数平方可积的函数组成，其范数为 $\\|u\\|_{H^{1}(\\Omega)} = \\left( \\|u\\|_{L^{2}(\\Omega)}^{2} + \\|u'\\|_{L^{2}(\\Omega)}^{2} \\right)^{1/2}$。在偏微分方程 (PDE) 的数值解法中，区分 $H^{1}(\\Omega)$ 中的弱收敛和强收敛对于理解变分格式的稳定性和相容性至关重要。在 $H^{1}_{0}(\\Omega)$ 中定义序列 $(u_{m})_{m \\in \\mathbb{N}}$ 如下：\n$$\nu_{m}(x) = \\frac{1}{m} \\sin(2\\pi m x), \\quad x \\in \\Omega.\n$$\n仅使用 $H^{1}(\\Omega)$ 的基本定义、Hilbert 空间中的弱收敛和强收敛，以及关于有界区间上振荡积分的公认事实，完成以下任务：\n- 证明 $(u_{m})_{m \\in \\mathbb{N}} \\subset H^{1}_{0}(\\Omega)$ 并且在 $H^{1}(\\Omega)$ 中有界。\n- 证明 $u_{m}$ 在 $L^{2}(\\Omega)$ 中强收敛到 $0$。\n- 证明 $u_{m}$ 在 $H^{1}(\\Omega)$ 中弱收敛到 $0$ ($u_{m} \\rightharpoonup 0$)，但在 $H^{1}(\\Omega)$ 中不强收敛到 $0$ ($u_{m} \\not\\to 0$)。\n- 计算极限\n$$\n\\lim_{m \\to \\infty} \\|u_{m}\\|_{H^{1}(\\Omega)}^{2}.\n$$\n将你的最终答案表示为单个精确的解析表达式。不需要四舍五入。", "solution": "该问题要求分析函数序列 $u_{m}(x) = \\frac{1}{m} \\sin(2\\pi m x)$ 在 Sobolev 空间 $H^{1}(\\Omega)$（其中 $\\Omega = (0,1)$）中的收敛性质。我们将按顺序解决问题的每个部分。\n\n首先，我们证明序列 $(u_{m})_{m \\in \\mathbb{N}}$ 包含在空间 $H^{1}_{0}(\\Omega)$ 中，并且是 $H^{1}(\\Omega)$ 中的一个有界序列。\n如果函数 $u$ 及其弱导数 $u'$ 都在 $L^{2}(\\Omega)$ 中，则 $u$ 属于 $H^{1}(\\Omega)$。对于给定的序列，每个函数 $u_m(x)$ 在 $\\Omega$ 上都是无限可微的。因此，其弱导数与经典导数一致。\n\n函数为 $u_{m}(x) = \\frac{1}{m} \\sin(2\\pi m x)$。\n其导数为 $u'_{m}(x) = \\frac{d}{dx} \\left( \\frac{1}{m} \\sin(2\\pi m x) \\right) = \\frac{2\\pi m}{m} \\cos(2\\pi m x) = 2\\pi \\cos(2\\pi m x)$。\n\n为了证明 $u_m \\in H^{1}(\\Omega)$，我们必须计算 $u_m$ 和 $u'_m$ 的 $L^{2}$ 范数。\n$$\n\\|u_{m}\\|_{L^{2}(\\Omega)}^{2} = \\int_{0}^{1} |u_{m}(x)|^{2} dx = \\int_{0}^{1} \\left(\\frac{1}{m} \\sin(2\\pi m x)\\right)^{2} dx = \\frac{1}{m^{2}} \\int_{0}^{1} \\sin^{2}(2\\pi m x) dx.\n$$\n使用恒等式 $\\sin^{2}(\\theta) = \\frac{1 - \\cos(2\\theta)}{2}$，积分变为：\n$$\n\\int_{0}^{1} \\sin^{2}(2\\pi m x) dx = \\int_{0}^{1} \\frac{1 - \\cos(4\\pi m x)}{2} dx = \\left[ \\frac{x}{2} - \\frac{\\sin(4\\pi m x)}{8\\pi m} \\right]_{0}^{1} = \\frac{1}{2} - \\frac{\\sin(4\\pi m)}{8\\pi m} - 0.\n$$\n由于 $m \\in \\mathbb{N}$，$\\sin(4\\pi m) = 0$。因此，积分的值为 $\\frac{1}{2}$。\n所以，$\\|u_{m}\\|_{L^{2}(\\Omega)}^{2} = \\frac{1}{2m^{2}}$。\n\n现在我们计算导数的范数：\n$$\n\\|u'_{m}\\|_{L^{2}(\\Omega)}^{2} = \\int_{0}^{1} |u'_{m}(x)|^{2} dx = \\int_{0}^{1} (2\\pi \\cos(2\\pi m x))^{2} dx = 4\\pi^{2} \\int_{0}^{1} \\cos^{2}(2\\pi m x) dx.\n$$\n使用恒等式 $\\cos^{2}(\\theta) = \\frac{1 + \\cos(2\\theta)}{2}$，积分变为：\n$$\n\\int_{0}^{1} \\cos^{2}(2\\pi m x) dx = \\int_{0}^{1} \\frac{1 + \\cos(4\\pi m x)}{2} dx = \\left[ \\frac{x}{2} + \\frac{\\sin(4\\pi m x)}{8\\pi m} \\right]_{0}^{1} = \\frac{1}{2}.\n$$\n因此，$\\|u'_{m}\\|_{L^{2}(\\Omega)}^{2} = 4\\pi^{2} \\left(\\frac{1}{2}\\right) = 2\\pi^{2}$。\n因为 $\\|u_m\\|_{L^2}^2$ 和 $\\|u'_m\\|_{L^2}^2$ 都是有限的，所以对于所有 $m \\in \\mathbb{N}$，都有 $u_m \\in H^{1}(\\Omega)$。\n\n为了证明 $u_m \\in H^{1}_{0}(\\Omega)$，我们注意到 $H^1_0(\\Omega)$ 是 $C^{\\infty}_{c}(\\Omega)$ 在 $H^1$ 范数下的闭包。对于一个函数 $u \\in H^1(\\Omega) \\cap C(\\bar{\\Omega})$，其属于 $H^1_0(\\Omega)$ 等价于 $u$ 在边界 $\\partial \\Omega = \\{0, 1\\}$ 上为零。\n我们检查 $u_m(x)$ 的边界值：\n$u_{m}(0) = \\frac{1}{m}\\sin(0) = 0$。\n$u_{m}(1) = \\frac{1}{m}\\sin(2\\pi m) = 0$ 因为 $m$ 是整数。\n因此，$u_m$ 满足边界条件，所以 $(u_{m})_{m \\in \\mathbb{N}} \\subset H^{1}_{0}(\\Omega)$。\n\n接下来，为了证明该序列在 $H^1(\\Omega)$ 中有界，我们考察其范数：\n$$\n\\|u_{m}\\|_{H^{1}(\\Omega)}^{2} = \\|u_{m}\\|_{L^{2}(\\Omega)}^{2} + \\|u'_{m}\\|_{L^{2}(\\Omega)}^{2} = \\frac{1}{2m^{2}} + 2\\pi^{2}.\n$$\n对于任何 $m \\in \\mathbb{N}$ 且 $m \\ge 1$，我们有 $0  \\frac{1}{2m^2} \\le \\frac{1}{2}$。\n因此，$2\\pi^2  \\|u_{m}\\|_{H^{1}(\\Omega)}^{2} \\le \\frac{1}{2} + 2\\pi^{2}$。\n这意味着范数序列是有界的，所以序列 $(u_m)$ 在 $H^{1}(\\Omega)$ 中是有界的。\n\n第二，我们证明 $u_{m}$ 在 $L^{2}(\\Omega)$ 中强收敛到 $0$。\n在 $L^2(\\Omega)$ 中强收敛到 $0$ 意味着 $\\lim_{m \\to \\infty} \\|u_m - 0\\|_{L^2(\\Omega)} = 0$。\n根据我们之前的计算，$\\|u_{m}\\|_{L^{2}(\\Omega)}^{2} = \\frac{1}{2m^{2}}$。\n当 $m \\to \\infty$ 时取极限：\n$$\n\\lim_{m \\to \\infty} \\|u_{m}\\|_{L^{2}(\\Omega)}^{2} = \\lim_{m \\to \\infty} \\frac{1}{2m^{2}} = 0.\n$$\n由于范数的平方趋于 $0$，范数本身也必然趋于 $0$。这证实了 $u_m$ 在 $L^{2}(\\Omega)$ 中强收敛到 $0$。\n\n第三，我们证明 $u_{m}$ 在 $H^{1}(\\Omega)$ 中弱收敛到 $0$，但不是强收敛。\n在 Hilbert 空间 $H^1(\\Omega)$ 中弱收敛 $u_m \\rightharpoonup 0$ 意味着对于任何测试函数 $v \\in H^{1}(\\Omega)$，内积 $\\langle u_m, v \\rangle_{H^{1}(\\Omega)}$ 收敛到 $0$。内积定义为：\n$$\n\\langle u_m, v \\rangle_{H^{1}(\\Omega)} = \\int_{0}^{1} u_m(x)v(x) dx + \\int_{0}^{1} u'_m(x)v'(x) dx.\n$$\n我们分别分析每一项。对于第一项，我们使用 Cauchy-Schwarz 不等式：\n$$\n\\left| \\int_{0}^{1} u_m(x)v(x) dx \\right| \\le \\|u_m\\|_{L^2(\\Omega)} \\|v\\|_{L^2(\\Omega)}.\n$$\n因为我们已经证明当 $m \\to \\infty$ 时 $\\|u_m\\|_{L^2(\\Omega)} \\to 0$，而 $\\|v\\|_{L^2(\\Omega)}$ 是一个固定的有限值，所以第一项收敛到 $0$：\n$$\n\\lim_{m \\to \\infty} \\int_{0}^{1} u_m(x)v(x) dx = 0.\n$$\n对于第二项，我们有：\n$$\n\\int_{0}^{1} u'_m(x)v'(x) dx = \\int_{0}^{1} 2\\pi \\cos(2\\pi m x) v'(x) dx.\n$$\n由于 $v \\in H^{1}(\\Omega)$，其弱导数 $v'$ 属于 $L^2(\\Omega)$。在有界域 $\\Omega = (0,1)$ 上，任何 $L^2$ 函数也是 $L^1$ 函数（即 $L^2(\\Omega) \\subset L^1(\\Omega)$）。Riemann-Lebesgue 引理指出，对于任何函数 $f \\in L^1(\\Omega)$，有 $\\lim_{k \\to \\infty} \\int_{\\Omega} f(x) \\cos(kx) dx = 0$。\n将此引理应用于 $f(x) = v'(x)$ 和 $k=2\\pi m$，我们得出结论：\n$$\n\\lim_{m \\to \\infty} \\int_{0}^{1} \\cos(2\\pi m x) v'(x) dx = 0.\n$$\n因此，内积的第二项也收敛到 $0$。\n结合这两个结果，我们已经证明对于任何 $v \\in H^{1}(\\Omega)$：\n$$\n\\lim_{m \\to \\infty} \\langle u_m, v \\rangle_{H^{1}(\\Omega)} = 0 + 0 = 0.\n$$\n这就是弱收敛到 $0$ 的定义，因此 $u_m \\rightharpoonup 0$ 在 $H^1(\\Omega)$ 中。\n\n为了证明收敛不是强收敛，我们必须证明 $\\|u_m - 0\\|_{H^1(\\Omega)}$ 不收敛到 $0$。我们已经计算过这个范数：\n$$\n\\|u_{m}\\|_{H^{1}(\\Omega)}^{2} = \\frac{1}{2m^{2}} + 2\\pi^{2}.\n$$\n当 $m \\to \\infty$ 时取极限：\n$$\n\\lim_{m \\to \\infty} \\|u_{m}\\|_{H^{1}(\\Omega)}^{2} = \\lim_{m \\to \\infty} \\left( \\frac{1}{2m^{2}} + 2\\pi^{2} \\right) = 0 + 2\\pi^{2} = 2\\pi^{2}.\n$$\n由于 $\\lim_{m \\to \\infty} \\|u_{m}\\|_{H^{1}(\\Omega)} = \\sqrt{2\\pi^{2}} = \\pi \\sqrt{2} \\neq 0$，序列 $(u_m)$ 在 $H^{1}(\\Omega)$ 中不强收敛到 $0$。\n\n最后，我们计算极限 $\\lim_{m \\to \\infty} \\|u_{m}\\|_{H^{1}(\\Omega)}^{2}$。这个计算在上一步中作为反证强收敛的一部分已经完成。结果是：\n$$\n\\lim_{m \\to \\infty} \\|u_{m}\\|_{H^{1}(\\Omega)}^{2} = 2\\pi^{2}.\n$$", "answer": "$$\\boxed{2\\pi^{2}}$$", "id": "3444217"}, {"introduction": "当我们使用有限元网格来近似连续函数时，所构建的离散函数空间会获得一些连续空间本身不具备的特殊性质。本练习将探索所谓的“逆估计”，它用较弱的范数来控制较强的范数（例如用函数本身的范数控制其导数的范数），但其常数依赖于网格尺寸 $h$。通过数值计算这些常数，你将深入理解离散化如何影响导数的稳定性，这是有限元方法误差分析的基石。[@problem_id:3444216]", "problem": "考虑区间区域 $\\Omega = (0,1)$ 和一族均匀网格，该网格由 $N \\in \\mathbb{N}$ 个长度相等的单元组成，单元长度为 $h = 1/N$。设 $V_h^k$ 为此网格上由次数为 $k \\in \\mathbb{N}$ 的连续分片多项式函数构成的协调拉格朗日有限元空间。所有范数和半范数均在 $\\Omega$ 上计算。\n\n您的任务是通过基于矩阵的实现，数值计算以下上确界，来量化两个范数等价常数。这两个常数表征了 $V_h^k$ 上的逆估计和嵌入型估计：\n\n1. 对于给定的 $(N,k)$，计算\n$$\nC_{\\nabla,0}(h,k) \\;=\\; \\sup_{u_h \\in V_h^k \\setminus \\{0\\}} \\frac{\\| \\partial_x u_h \\|_{L^2(\\Omega)}}{\\| u_h \\|_{L^2(\\Omega)}} \\, .\n$$\n使用对称刚度矩阵 $K$ 和质量矩阵 $M$（由 $V_h^k$ 的典范节点基组装）的瑞利商表征，可写为\n$$\nC_{\\nabla,0}(h,k) \\;=\\; \\sqrt{ \\lambda_{\\max} } \\quad \\text{其中} \\quad K \\mathbf{u} \\,=\\, \\lambda \\, M \\mathbf{u} \\, ,\n$$\n其中 $\\lambda_{\\max}$ 是最大的广义特征值。通过在每个单元上使用精确（或足够精确）的高斯求积来组装 $K$ 和 $M$。每个单元都从参考区间 $[0,1]$ 映射而来，并使用等距节点上的局部拉格朗日基。\n\n2. 对于 $k=1$（分片线性），计算一个 $L^\\infty$-到-$H^1$ 的嵌入常数\n$$\nC_{\\infty}(h) \\;=\\; \\sup_{u_h \\in V_h^1 \\setminus \\{0\\}} \\frac{\\| u_h \\|_{L^\\infty(\\Omega)}}{\\| u_h \\|_{H^1(\\Omega)}} \\, .\n$$\n利用以下事实：对于 $k=1$，每个单元上 $|u_h|$ 的最大值在端点（节点）处达到，因此\n$$\n\\| u_h \\|_{L^\\infty(\\Omega)} \\;=\\; \\max_i |u_h(x_i)| \\, .\n$$\n使用离散 $H^1$ 内积矩阵 $A = K + M$（刚度矩阵加质量矩阵），$V_h^1$ 上的 Riesz 表示恒等式意味着\n$$\nC_{\\infty}(h) \\;=\\; \\max_{i} \\sqrt{ \\bigl( A^{-1} \\bigr)_{ii} } \\, .\n$$\n计算 $A$，然后通过求解以 $A$ 为系数矩阵的线性系统来获得 $A^{-1}$ 的对角线元素，从而提取 $\\max_i \\sqrt{(A^{-1})_{ii}}$。\n\n使用的基本知识：\n- $\\Omega$ 上索博列夫范数的定义：$\\|u\\|_{L^2(\\Omega)}^2 = \\int_\\Omega |u(x)|^2 \\, dx$，$\\|u\\|_{H^1(\\Omega)}^2 = \\int_\\Omega \\bigl( |u(x)|^2 + |\\partial_x u(x)|^2 \\bigr) \\, dx$。\n- 有限元伽辽金格拉姆矩阵：通过\n$$\nM_{ij} = \\int_\\Omega \\phi_i \\phi_j \\, dx, \\quad K_{ij} = \\int_\\Omega (\\partial_x \\phi_i)(\\partial_x \\phi_j) \\, dx,\n$$\n逐单元组装 $M$ 和 $K$，其中 $\\{\\phi_i\\}$ 是 $V_h^k$ 的全局节点基。\n- 对称广义特征值问题的瑞利商恒等式，给出了由 $K$ 和 $M$ 诱导的算子范数。\n\n数值实现要求：\n- 使用参考单元 $[0,1]$ 进行局部积分；通过标准仿射映射将其映射到每个长度为 $h$ 的物理单元，并包含精确的缩放因子：$M^{\\text{loc}} = h \\, M^{\\text{ref}}$，$K^{\\text{loc}} = \\frac{1}{h} \\, K^{\\text{ref}}$。\n- 在 $[0,1]$ 上，通过求解单项式基中的范德蒙插值系统，在等距节点 $\\xi_j = j/k$，$j=0,\\dots,k$ 处构造局部拉格朗日基 $\\{\\ell_j\\}_{j=0}^k$。在高斯求积点处计算 $\\ell_j$ 和 $\\partial_x \\ell_j$ 的值以组装 $M^{\\text{ref}}$ 和 $K^{\\text{ref}}$。选择一个至少有 $2k+2$ 个点的高斯求积法则，以将基函数及其导数的乘积积分到机器精度。\n- 使用连续单元的标准连接关系组装大小为 $n_{\\text{dof}} \\times n_{\\text{dof}}$ 的全局稠密矩阵 $M$ 和 $K$，其中 $n_{\\text{dof}} = N k + 1$：对于单元索引 $e=0,\\dots,N-1$，局部到全局的映射为 $g(e,j) = e k + j$，其中 $j=0,\\dots,k$。\n\n测试套件：\n- 为以下 $(N,k)$ 计算 $C_{\\nabla,0}(h,k)$：\n  - $(N,k) = (4,1)$,\n  - $(N,k) = (8,1)$,\n  - $(N,k) = (4,3)$,\n  - $(N,k) = (1,1)$.\n- 为以下 $N$ 值计算 $C_{\\infty}(h)$（其中 $k=1$）：\n  - $N = 8$,\n  - $N = 32$.\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按\n$$\n\\bigl[ C_{\\nabla,0}(4,1), \\; C_{\\nabla,0}(8,1), \\; C_{\\nabla,0}(4,3), \\; C_{\\nabla,0}(1,1), \\; C_{\\infty}(8), \\; C_{\\infty}(32) \\bigr].\n$$\n的顺序排列。\n- 每个数字必须以浮点值形式打印。不涉及单位。不涉及角度。不涉及百分比。输出必须只有一行，例如 $[x_1,x_2,x_3,x_4,x_5,x_6]$。", "solution": "该问题经评估是**有效的**。它以数值分析和有限元理论的原理为科学基础。该问题是适定的，提供了一套完整且一致的定义、约束和目标。常数 $C_{\\nabla,0}(h,k)$ 和 $C_{\\infty}(h)$ 的数学公式是标准且正确的。具体来说，将 $C_{\\nabla,0}(h,k)$ 表征为广义特征值问题 $K\\mathbf{u} = \\lambda M\\mathbf{u}$ 的最大特征值的平方根，是算子范数的瑞利商的直接推论。对于分片线性元（$k=1$），$C_{\\infty}(h)$ 的公式是从离散 $H^1(\\Omega)$ 内积空间中点值泛函的 Riesz 表示正确推导出来的。数值实现的细节是具体、明确且算法上合理的，能够导出一个唯一且可验证的数值解。该问题是偏微分方程数值方法这一特定领域内一个相关且非平凡的任务。\n\n求解过程是通过实施指定的数值程序来进行的。其核心思想是将定义在函数空间 $V_h^k$ 上的连续范数和上确界，转换为涉及函数 $u_h \\in V_h^k$ 自由度的矩阵向量运算。\n\n一个函数 $u_h \\in V_h^k$ 由其节点值向量 $\\mathbf{u}$ 表示。$L^2(\\Omega)$ 范数的平方则为 $\\|u_h\\|_{L^2(\\Omega)}^2 = \\mathbf{u}^T M \\mathbf{u}$，$H^1(\\Omega)$ 半范数的平方为 $\\|\\partial_x u_h\\|_{L^2(\\Omega)}^2 = \\mathbf{u}^T K \\mathbf{u}$。此处，$M$ 和 $K$ 分别是全局质量矩阵和刚度矩阵，其元素由 $M_{ij} = \\int_\\Omega \\phi_i \\phi_j \\, dx$ 和 $K_{ij} = \\int_\\Omega (\\partial_x \\phi_i)(\\partial_x \\phi_j) \\, dx$ 给出，其中 $\\{\\phi_i\\}$ 是全局节点基。\n\n计算策略如下：\n1.  **参考单元公式化**：所有计算首先在参考单元，即区间 $[0,1]$ 上执行。在此区间上，我们相对于 $k+1$ 个等距节点 $\\xi_j = j/k$ 定义一个 $k$ 次的局部拉格朗日基 $\\{\\ell_j(\\xi)\\}_{j=0}^k$。每个基多项式 $\\ell_j(\\xi)$ 都是唯一的，满足 $\\ell_j(\\xi_i) = \\delta_{ij}$。这些多项式及其导数 $\\partial_\\xi \\ell_j(\\xi)$ 被构造出来。\n\n2.  **局部矩阵组装**：组装参考单元上的局部质量矩阵 $M^{\\text{ref}}$ 和刚度矩阵 $K^{\\text{ref}}$。它们的元素由以下公式给出：\n    $$\n    M^{\\text{ref}}_{ij} = \\int_0^1 \\ell_i(\\xi) \\ell_j(\\xi) \\, d\\xi, \\quad K^{\\text{ref}}_{ij} = \\int_0^1 (\\partial_\\xi \\ell_i(\\xi)) (\\partial_\\xi \\ell_j(\\xi)) \\, d\\xi\n    $$\n    被积函数是次数最高为 $2k$ 的多项式。为了精确计算这些积分，使用高斯求积法则。按照规定，选择在积分域上至少有 $2k+2$ 个点的法则，这足以进行精确积分。如果 $\\{\\xi_q, w_q\\}_q$ 是 $[0,1]$ 上的求积点和权重，则矩阵元素计算如下：\n    $$\n    M^{\\text{ref}}_{ij} = \\sum_q w_q \\ell_i(\\xi_q) \\ell_j(\\xi_q), \\quad K^{\\text{ref}}_{ij} = \\sum_q w_q (\\partial_\\xi \\ell_i(\\xi_q)) (\\partial_\\xi \\ell_j(\\xi_q))\n    $$\n\n3.  **全局矩阵组装**：为具有 $N$ 个单元的网格组装全局矩阵 $M$ 和 $K$。物理域中的每个单元 $\\Omega_e = [x_e, x_{e+1}]$ 的长度为 $h=1/N$。单元 $e$ 的局部矩阵 $M^{\\text{loc}}$ 和 $K^{\\text{loc}}$ 是通过缩放参考矩阵得到的。使用仿射映射 $x(\\xi) = x_e + h\\xi$，积分中的变量代换产生缩放因子：\n    $$\n    M^{\\text{loc}} = h \\, M^{\\text{ref}}, \\quad K^{\\text{loc}} = \\frac{1}{h} \\, K^{\\text{ref}}\n    $$\n    全局矩阵的大小为 $n_{\\text{dof}} \\times n_{\\text{dof}}$，其中 $n_{\\text{dof}}=Nk+1$，它们被初始化为零。然后，对于每个单元 $e=0, \\dots, N-1$，将 $M^{\\text{loc}}$ 和 $K^{\\text{loc}}$ 的元素加到 $M$ 和 $K$ 中相应的元素上。从单元 $e$ 上的局部节点索引 $j=0, \\dots, k$ 到全局自由度索引的映射由 $g(e,j) = ek+j$ 给出。\n\n4.  **$C_{\\nabla,0}(h,k)$ 的计算**：此常数是 $V_h^k$ 上关于 $L^2(\\Omega)$ 范数的 $\\partial_x$ 算子范数。它通过瑞利商计算：\n    $$\n    C_{\\nabla,0}(h,k)^2 \\;=\\; \\sup_{u_h \\in V_h^k \\setminus \\{0\\}} \\frac{\\| \\partial_x u_h \\|_{L^2(\\Omega)}^2}{\\| u_h \\|_{L^2(\\Omega)}^2} \\;=\\; \\sup_{\\mathbf{u} \\neq \\mathbf{0}} \\frac{\\mathbf{u}^T K \\mathbf{u}}{\\mathbf{u}^T M \\mathbf{u}}\n    $$\n    这就是系统 $K\\mathbf{u} = \\lambda M\\mathbf{u}$ 的最大广义特征值 $\\lambda_{\\max}$。我们数值求解这个对称广义特征值问题以找到 $\\lambda_{\\max}$，然后计算 $C_{\\nabla,0}(h,k) = \\sqrt{\\lambda_{\\max}}$。\n\n5.  **$C_{\\infty}(h)$ 的计算（$k=1$）**：此常数度量了离散 $H^1(\\Omega)$ 范数到 $L^\\infty(\\Omega)$ 范数的嵌入。对于分片线性函数（$k=1$），最大绝对值总是在节点上，所以 $\\|u_h\\|_{L^\\infty(\\Omega)} = \\max_i |u_h(x_i)| = \\|\\mathbf{u}\\|_{\\ell^\\infty}$。$H^1(\\Omega)$ 范数的平方是 $\\|u_h\\|_{H^1(\\Omega)}^2 = \\|u_h\\|_{L^2(\\Omega)}^2 + \\|\\partial_x u_h\\|_{L^2(\\Omega)}^2 = \\mathbf{u}^T(M+K)\\mathbf{u} = \\mathbf{u}^T A \\mathbf{u}$。因此该常数为 $C_{\\infty}(h) = \\sup_{\\mathbf{u} \\neq \\mathbf{0}} \\frac{\\|\\mathbf{u}\\|_{\\ell^\\infty}}{\\sqrt{\\mathbf{u}^T A \\mathbf{u}}}$。如问题所述，这可以被证明等价于\n    $$\n    C_{\\infty}(h) \\;=\\; \\max_{i} \\sqrt{ \\bigl( A^{-1} \\bigr)_{ii} }\n    $$\n    其中 $A = K+M$。矩阵 $A$ 是对称正定的。其逆矩阵的对角线元素 $(A^{-1})_{ii}$ 的计算方法是：首先构造 $A$，然后求解线性方程组 $A\\mathbf{x}_i = \\mathbf{e}_i$（其中 $i=0, \\dots, n_{\\text{dof}}-1$，$\\mathbf{e}_i$ 是典范基向量）。解 $\\mathbf{x}_i$ 是 $A^{-1}$ 的第 $i$ 列，因此 $(A^{-1})_{ii} = (\\mathbf{x}_i)_i$。这可以方便地通过求解 $AX=I$ 得到 $X=A^{-1}$，然后提取 $X$ 的对角线来完成。\n\n将对指定的测试用例实施这些步骤。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\nfrom scipy.interpolate import lagrange\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Computes finite element norm-equivalence constants based on the problem statement.\n    \"\"\"\n    # Cache for reference element matrices to avoid recomputation\n    _local_matrix_cache = {}\n\n    def get_local_matrices(k):\n        \"\"\"\n        Computes the mass and stiffness matrices on the reference element [0,1]\n        for Lagrange polynomials of degree k.\n        \"\"\"\n        if k in _local_matrix_cache:\n            return _local_matrix_cache[k]\n\n        # Use Gaussian quadrature with a number of points sufficient for exactness.\n        # The problem asks for at least 2k+2 points.\n        # For integrating polynomials of degree up to 2k, k+1 points are sufficient.\n        # We follow the problem's generous recommendation.\n        num_quad_points = 2 * k + 2\n        \n        # Quadrature points and weights on [-1,1], scaled to [0,1]\n        quad_points_ref, quad_weights_ref = leggauss(num_quad_points)\n        quad_points = 0.5 * (quad_points_ref + 1)\n        quad_weights = 0.5 * quad_weights_ref\n\n        # Equispaced nodes for Lagrange basis on [0,1]\n        nodes = np.linspace(0, 1, k + 1)\n        \n        # Vandermonde/Lagrange construction of basis functions and their derivatives\n        basis_functions = []\n        basis_derivatives = []\n        for i in range(k + 1):\n            y = np.zeros(k + 1)\n            y[i] = 1.0\n            poly = lagrange(nodes, y)\n            basis_functions.append(poly)\n            basis_derivatives.append(poly.deriv())\n\n        # Evaluate basis functions and derivatives at quadrature points\n        phi = np.array([bf(quad_points) for bf in basis_functions])\n        dphi = np.array([bd(quad_points) for bd in basis_derivatives])\n\n        # Assemble reference matrices using quadrature\n        M_ref = np.zeros((k + 1, k + 1))\n        K_ref = np.zeros((k + 1, k + 1))\n        for i in range(k + 1):\n            for j in range(k + 1):\n                M_ref[i, j] = np.sum(quad_weights * phi[i, :] * phi[j, :])\n                K_ref[i, j] = np.sum(quad_weights * dphi[i, :] * dphi[j, :])\n        \n        _local_matrix_cache[k] = (M_ref, K_ref)\n        return M_ref, K_ref\n\n    def assemble_global_matrices(N, k):\n        \"\"\"\n        Assembles a global mass and stiffness matrix for a uniform mesh.\n        \"\"\"\n        h = 1.0 / N\n        M_ref, K_ref = get_local_matrices(k)\n\n        # Scale reference matrices to local element size\n        M_loc = h * M_ref\n        K_loc = (1.0 / h) * K_ref\n\n        n_dof = N * k + 1\n        M = np.zeros((n_dof, n_dof))\n        K = np.zeros((n_dof, n_dof))\n\n        # Assembly loop over elements\n        for e in range(N):\n            for i_loc in range(k + 1):\n                i_glob = e * k + i_loc\n                for j_loc in range(k + 1):\n                    j_glob = e * k + j_loc\n                    M[i_glob, j_glob] += M_loc[i_loc, j_loc]\n                    K[i_glob, j_glob] += K_loc[i_loc, j_loc]\n    \n        return M, K\n\n    def compute_C_nabla_0(N, k):\n        \"\"\"\n        Computes the constant C_{nabla,0} by solving a generalized eigenvalue problem.\n        \"\"\"\n        if N * k == 0: return 0.0 # Trivial case k=0 or N=0 not in problem scope, but for safety\n        M, K = assemble_global_matrices(N, k)\n        \n        # Solve the generalized eigenvalue problem K*u = lambda*M*u.\n        # eigh returns eigenvalues in ascending order for symmetric matrices.\n        eigenvalues = linalg.eigh(K, M, eigvals_only=True)\n        lambda_max = eigenvalues[-1]\n        \n        return np.sqrt(lambda_max)\n\n    def compute_C_infty(N):\n        \"\"\"\n        Computes the constant C_infty for k=1.\n        \"\"\"\n        k = 1\n        M, K = assemble_global_matrices(N, k)\n        A = K + M\n\n        # To find diag(A_inv), we can solve AX=I for X and take the diagonal.\n        n_dof = N * k + 1\n        I = np.eye(n_dof)\n        A_inv = linalg.solve(A, I)\n        \n        A_inv_diag = np.diag(A_inv)\n        \n        # The formula requires the square root of the diagonal entries.\n        # We must handle potential negative values from numerical noise,\n        # although for SPD matrices they should be positive.\n        return np.max(np.sqrt(np.maximum(0, A_inv_diag)))\n\n    # Test cases from the problem statement\n    test_cases_nabla_0 = [(4, 1), (8, 1), (4, 3), (1, 1)]\n    test_cases_infty = [8, 32]\n\n    results = []\n    \n    # Compute C_{nabla,0}\n    for N_val, k_val in test_cases_nabla_0:\n        results.append(compute_C_nabla_0(N_val, k_val))\n        \n    # Compute C_{infty}\n    for N_val in test_cases_infty:\n        results.append(compute_C_infty(N_val))\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3444216"}]}