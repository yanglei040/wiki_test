{"hands_on_practices": [{"introduction": "在使用任何数值格式之前，我们必须首先从理论上理解其基本性质。这个练习将指导您完成对一维MacCormack格式的冯·诺依曼稳定性分析，这是评估任何有限差分法稳定性的基石。通过推导其放大因子，您不仅将确定该格式的稳定性约束（即库朗数$\\nu$的范围），还将分析其相位误差，从而深入理解该格式在传播不同频率波时的色散特性。[@problem_id:3418392]", "problem": "考虑常波速 $a>0$ 的线性平流方程 $u_{t} + a\\,u_{x} = 0$，定义在一个空间周期性域上。设空间网格为 $x_{j} = j\\,\\Delta x$（$j$ 为整数），时间层为 $t^{n} = n\\,\\Delta t$。定义 Courant 数 $\\nu = a\\,\\Delta t/\\Delta x$。两步 MacCormack 预测-校正格式（对于 $a>0$，在预测步中使用前向空间差分，在校正步中使用后向空间差分）由下式给出\n$$\nu_{j}^{*} = u_{j}^{n} - \\nu\\left(u_{j+1}^{n} - u_{j}^{n}\\right), \\quad\nu_{j}^{n+1} = \\frac{1}{2}\\left(u_{j}^{n} + u_{j}^{*}\\right) - \\frac{\\nu}{2}\\left(u_{j}^{*} - u_{j-1}^{*}\\right).\n$$\n假设平面波解为 $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$，其中无量纲波数为 $\\theta = k\\,\\Delta x \\in [0,\\pi]$，进行 von Neumann (Fourier) 分析。从上述定义和复指数的基本性质出发，完成以下任务：\n\n1) 推导单步更新式 $u_{j}^{n+1} = \\sum_{m=-1}^{1} c_{m}(\\nu)\\,u_{j+m}^{n}$，并由此获得放大因子 $G(\\theta) = \\hat{u}^{n+1}/\\hat{u}^{n}$ 作为 $\\nu$ 和 $\\theta$ 的显式函数。\n\n2) 使用放大因子，通过要求对所有 $\\theta \\in [0,\\pi]$ 都有 $|G(\\theta)| \\leq 1$ 来确定 von Neumann 稳定性的 $\\nu$ 条件。\n\n3) 定义数值相位 $\\phi(\\theta)$ 为 $G(\\theta)$ 的连续辐角，选择使得 $\\phi(0)=0$ 的分支，并设一个时间步长的精确相位为 $\\phi_{\\text{exact}}(\\theta) = -\\nu\\,\\theta$。定义相位误差度量\n$$\nE_{\\text{phase}}(\\nu) = \\sup_{\\theta \\in [0,\\pi]} \\left|\\phi(\\theta) - \\phi_{\\text{exact}}(\\theta)\\right|.\n$$\n确定使 $E_{\\text{phase}}(\\nu)$ 最小的 $\\nu \\in (0,1]$ 的值。将最终答案表示为一个精确的实数。无需四舍五入，也无需单位。", "solution": "该问题是有效的，因为它具有科学依据、良定且客观。它包括对线性平流方程的 MacCormack 格式进行标准的 von Neumann 稳定性和相位误差分析，这是偏微分方程数值解中的一个基本课题。所有定义都是标准的，任务在数学上是严谨的。\n\n我们依次解决问题的三个部分。\n\n### 第一部分：单步更新和放大因子\n\nMacCormack 格式由一对预测-校正方程给出：\n预测步：\n$$\nu_{j}^{*} = u_{j}^{n} - \\nu\\left(u_{j+1}^{n} - u_{j}^{n}\\right)\n\\label{eq:1} \\tag{1}\n$$\n校正步：\n$$\nu_{j}^{n+1} = \\frac{1}{2}\\left(u_{j}^{n} + u_{j}^{*}\\right) - \\frac{\\nu}{2}\\left(u_{j}^{*} - u_{j-1}^{*}\\right)\n\\label{eq:2} \\tag{2}\n$$\n其中 $\\nu = a\\Delta t / \\Delta x$ 是 Courant 数。\n\n为了推导单步更新公式，我们首先将预测步结果式 \\eqref{eq:1} 代入校正步方程，即式 \\eqref{eq:2}。\n首先，让我们用时间层 $n$ 的值来表示 $u_j^*$ 和 $u_{j-1}^*$。\n从式 \\eqref{eq:1}，我们有：\n$$\nu_{j}^{*} = (1+\\nu)u_{j}^{n} - \\nu u_{j+1}^{n}\n$$\n通过将索引 $j$ 移至 $j-1$，我们得到相邻网格点上预测值的表达式：\n$$\nu_{j-1}^{*} = u_{j-1}^{n} - \\nu\\left(u_{j}^{n} - u_{j-1}^{n}\\right) = (1+\\nu)u_{j-1}^{n} - \\nu u_{j}^{n}\n$$\n现在，将这些代入校正步，即式 \\eqref{eq:2}：\n$$\nu_{j}^{n+1} = \\frac{1}{2}\\left(u_{j}^{n} + \\left[(1+\\nu)u_{j}^{n} - \\nu u_{j+1}^{n}\\right]\\right) - \\frac{\\nu}{2}\\left(\\left[(1+\\nu)u_{j}^{n} - \\nu u_{j+1}^{n}\\right] - \\left[(1+\\nu)u_{j-1}^{n} - \\nu u_{j}^{n}\\right]\\right)\n$$\n我们来收集 $u_{j-1}^{n}$、$u_{j}^{n}$ 和 $u_{j+1}^{n}$ 的系数。\n$u_{j-1}^{n}$ 的系数：\n$$\nc_{-1} = -\\frac{\\nu}{2} (-(1+\\nu)) = \\frac{\\nu(1+\\nu)}{2} = \\frac{\\nu^2+\\nu}{2}\n$$\n$u_{j+1}^{n}$ 的系数：\n$$\nc_{1} = \\frac{1}{2}(-\\nu) - \\frac{\\nu}{2}(-\\nu) = -\\frac{\\nu}{2} + \\frac{\\nu^2}{2} = \\frac{\\nu^2-\\nu}{2}\n$$\n$u_{j}^{n}$ 的系数：\n$$\nc_{0} = \\frac{1}{2}(1 + (1+\\nu)) - \\frac{\\nu}{2}((1+\\nu) - (-\\nu)) = \\frac{2+\\nu}{2} - \\frac{\\nu}{2}(1+2\\nu) = 1 + \\frac{\\nu}{2} - \\frac{\\nu}{2} - \\nu^2 = 1-\\nu^2\n$$\n因此，单步更新式为：\n$$\nu_{j}^{n+1} = \\left(\\frac{\\nu^2+\\nu}{2}\\right)u_{j-1}^{n} + (1-\\nu^2)u_{j}^{n} + \\left(\\frac{\\nu^2-\\nu}{2}\\right)u_{j+1}^{n}\n$$\n这具有 $u_{j}^{n+1} = \\sum_{m=-1}^{1} c_{m}(\\nu)\\,u_{j+m}^{n}$ 的形式，其中系数 $c_{-1}$、$c_0$ 和 $c_1$ 已推导得出。\n\n接下来，我们求放大因子 $G(\\theta)$。我们将平面波解 $u_{j}^{n} = \\hat{u}^{n}\\,\\exp(i\\,j\\,\\theta)$ 代入单步公式。注意 $u_{j+m}^{n} = \\hat{u}^{n}\\,\\exp(i\\,(j+m)\\,\\theta) = u_{j}^{n}\\exp(i\\,m\\,\\theta)$。\n$$\n\\hat{u}^{n+1}e^{ij\\theta} = c_{-1}\\hat{u}^{n}e^{i(j-1)\\theta} + c_{0}\\hat{u}^{n}e^{ij\\theta} + c_{1}\\hat{u}^{n}e^{i(j+1)\\theta}\n$$\n两边同除以 $\\hat{u}^{n}e^{ij\\theta}$，我们得到放大因子 $G(\\theta) = \\hat{u}^{n+1}/\\hat{u}^{n}$：\n$$\nG(\\theta) = c_{-1}e^{-i\\theta} + c_{0} + c_{1}e^{i\\theta}\n$$\n代入系数的表达式：\n$$\nG(\\theta) = \\left(\\frac{\\nu^2+\\nu}{2}\\right)e^{-i\\theta} + (1-\\nu^2) + \\left(\\frac{\\nu^2-\\nu}{2}\\right)e^{i\\theta}\n$$\n我们将含有 $\\nu^2$ 和 $\\nu$ 的项分组：\n$$\nG(\\theta) = (1-\\nu^2) + \\frac{\\nu^2}{2}(e^{i\\theta} + e^{-i\\theta}) - \\frac{\\nu}{2}(e^{i\\theta} - e^{-i\\theta})\n$$\n使用 Euler 恒等式 $\\cos\\theta = \\frac{e^{i\\theta} + e^{-i\\theta}}{2}$ 和 $\\sin\\theta = \\frac{e^{i\\theta} - e^{-i\\theta}}{2i}$：\n$$\nG(\\theta) = (1-\\nu^2) + \\nu^2\\cos\\theta - \\nu(i\\sin\\theta)\n$$\n最后，我们得到放大因子作为 $\\nu$ 和 $\\theta$ 的显式函数：\n$$\nG(\\theta) = 1 - \\nu^2(1-\\cos\\theta) - i\\nu\\sin\\theta\n$$\n\n### 第二部分：Von Neumann 稳定性条件\n\n为了使格式在 von Neumann 意义下稳定，放大因子的模必须对所有相关波数满足 $|G(\\theta)| \\le 1$，即对所有 $\\theta \\in [0, \\pi]$。我们分析 $|G(\\theta)|^2$：\n$$\n|G(\\theta)|^2 = (\\operatorname{Re}(G(\\theta)))^2 + (\\operatorname{Im}(G(\\theta)))^2\n$$\n根据第一部分推导的表达式：\n$\\operatorname{Re}(G(\\theta)) = 1 - \\nu^2(1-\\cos\\theta)$\n$\\operatorname{Im}(G(\\theta)) = -\\nu\\sin\\theta$\n所以，\n$$\n|G(\\theta)|^2 = \\left(1 - \\nu^2(1-\\cos\\theta)\\right)^2 + (-\\nu\\sin\\theta)^2\n$$\n$$\n|G(\\theta)|^2 = 1 - 2\\nu^2(1-\\cos\\theta) + \\nu^4(1-\\cos\\theta)^2 + \\nu^2\\sin^2\\theta\n$$\n我们使用恒等式 $\\sin^2\\theta = 1-\\cos^2\\theta$：\n$$\n|G(\\theta)|^2 = 1 - 2\\nu^2 + 2\\nu^2\\cos\\theta + \\nu^4(1-2\\cos\\theta+\\cos^2\\theta) + \\nu^2(1-\\cos^2\\theta)\n$$\n$$\n= (1 - 2\\nu^2 + \\nu^2) + (2\\nu^2\\cos\\theta) + \\nu^4 - 2\\nu^4\\cos\\theta + \\nu^4\\cos^2\\theta - \\nu^2\\cos^2\\theta\n$$\n$$\n= 1 - \\nu^2 + 2\\nu^2(1-\\nu^2)\\cos\\theta - \\nu^2(1-\\nu^2)\\cos^2\\theta\n$$\n这个看起来很复杂。使用半角恒等式的另一种简化方法更为直接。我们使用 $1-\\cos\\theta = 2\\sin^2(\\theta/2)$ 和 $\\sin\\theta = 2\\sin(\\theta/2)\\cos(\\theta/2)$：\n$$\n\\operatorname{Re}(G(\\theta)) = 1 - 2\\nu^2\\sin^2(\\theta/2)\n$$\n$$\n\\operatorname{Im}(G(\\theta)) = -\\nu \\left(2\\sin(\\theta/2)\\cos(\\theta/2)\\right)\n$$\n$$\n|G(\\theta)|^2 = \\left(1 - 2\\nu^2\\sin^2(\\theta/2)\\right)^2 + \\left(-2\\nu\\sin(\\theta/2)\\cos(\\theta/2)\\right)^2\n$$\n$$\n= 1 - 4\\nu^2\\sin^2(\\theta/2) + 4\\nu^4\\sin^4(\\theta/2) + 4\\nu^2\\sin^2(\\theta/2)\\cos^2(\\theta/2)\n$$\n使用 $\\cos^2(\\theta/2) = 1-\\sin^2(\\theta/2)$：\n$$\n= 1 - 4\\nu^2\\sin^2(\\theta/2) + 4\\nu^4\\sin^4(\\theta/2) + 4\\nu^2\\sin^2(\\theta/2)\\left(1-\\sin^2(\\theta/2)\\right)\n$$\n$$\n= 1 - 4\\nu^2\\sin^2(\\theta/2) + 4\\nu^4\\sin^4(\\theta/2) + 4\\nu^2\\sin^2(\\theta/2) - 4\\nu^2\\sin^4(\\theta/2)\n$$\n项 $\\pm 4\\nu^2\\sin^2(\\theta/2)$ 相互抵消：\n$$\n|G(\\theta)|^2 = 1 + 4\\nu^4\\sin^4(\\theta/2) - 4\\nu^2\\sin^4(\\theta/2)\n$$\n$$\n|G(\\theta)|^2 = 1 - 4\\nu^2(1-\\nu^2)\\sin^4(\\theta/2)\n$$\n稳定性条件 $|G(\\theta)|^2 \\le 1$ 转化为：\n$$\n1 - 4\\nu^2(1-\\nu^2)\\sin^4(\\theta/2) \\le 1\n$$\n$$\n-4\\nu^2(1-\\nu^2)\\sin^4(\\theta/2) \\le 0\n$$\n两边除以 -1 并反转不等号：\n$$\n4\\nu^2(1-\\nu^2)\\sin^4(\\theta/2) \\ge 0\n$$\n这个不等式必须对所有 $\\theta \\in [0, \\pi]$ 成立。项 $4$、$\\nu^2$（因为 $\\nu=a\\Delta t/\\Delta x$ 且 $a>0$，所以 $\\nu>0$）和 $\\sin^4(\\theta/2)$ 都是非负的。因此，格式的稳定性仅取决于项 $(1-\\nu^2)$ 的符号。\n我们必须有：\n$$\n1-\\nu^2 \\ge 0 \\implies \\nu^2 \\le 1\n$$\n因为 $\\nu>0$，von Neumann 稳定性条件是 $0  \\nu \\le 1$。\n\n### 第三部分：相位误差最小化\n\n相位误差定义为数值相位 $\\phi(\\theta) = \\arg(G(\\theta))$ 与一个时间步长的精确相位 $\\phi_{\\text{exact}}(\\theta) = -\\nu\\theta$ 之间的差。目标是找到使相位误差度量\n$$\nE_{\\text{phase}}(\\nu) = \\sup_{\\theta \\in [0,\\pi]} \\left|\\phi(\\theta) - \\phi_{\\text{exact}}(\\theta)\\right|.\n$$\n最小的 $\\nu \\in (0,1]$ 的值。\n根据定义，绝对值确保对所有 $\\nu$ 都有 $E_{\\text{phase}}(\\nu) \\geq 0$。此误差度量的最小可能值为 0。如果我们能找到一个 $\\nu \\in (0,1]$ 使得 $E_{\\text{phase}}(\\nu)=0$，那么该值必定是最小值点。\n\n我们来研究 $\\nu=1$ 的特殊情况。第二部分的稳定性分析表明这是稳定性的极限。\n将 $\\nu=1$ 代入放大因子 $G(\\theta)$ 的表达式中：\n$$\nG(\\theta)|_{\\nu=1} = 1 - 1^2(1-\\cos\\theta) - i(1)\\sin\\theta\n$$\n$$\n= 1 - 1 + \\cos\\theta - i\\sin\\theta\n$$\n$$\n= \\cos\\theta - i\\sin\\theta\n$$\n使用 Euler 公式，这可以简化为：\n$$\nG(\\theta)|_{\\nu=1} = \\exp(-i\\theta)\n$$\n数值相位 $\\phi(\\theta)$ 是 $G(\\theta)$ 的辐角。对于 $\\nu=1$：\n$$\n\\phi(\\theta)|_{\\nu=1} = \\arg(\\exp(-i\\theta)) = -\\theta\n$$\n根据问题中 $\\phi(0)=0$ 的约定，这对 $\\theta \\in [0, \\pi]$ 成立。\n现在我们计算 $\\nu=1$ 时的精确相位：\n$$\n\\phi_{\\text{exact}}(\\theta)|_{\\nu=1} = -1 \\cdot \\theta = -\\theta\n$$\n因此，$\\nu=1$ 时的相位误差为：\n$$\n\\left|\\phi(\\theta) - \\phi_{\\text{exact}}(\\theta)\\right|_{\\nu=1} = |(-\\theta) - (-\\theta)| = |0| = 0\n$$\n这对所有 $\\theta \\in [0, \\pi]$ 的值都成立。\n因此，$\\nu=1$ 时的相位误差度量为：\n$$\nE_{\\text{phase}}(1) = \\sup_{\\theta \\in [0,\\pi]} 0 = 0\n$$\n由于对所有 $\\nu$ 都有 $E_{\\text{phase}}(\\nu) \\ge 0$，并且我们已经发现 $E_{\\text{phase}}(1)=0$，这意味着 $\\nu=1$ 导致了最小可能的相位误差。\n对于任何 $\\nu \\in (0,1)$，相位误差不恒为零。对于小的 $\\theta$，可以证明相位误差为 $\\phi(\\theta) - \\phi_{\\text{exact}}(\\theta) \\approx \\frac{\\nu(1-\\nu^2)}{6}\\theta^3$。当 $\\theta \\neq 0$ 和 $\\nu \\in (0,1)$ 时，该值非零，这意味着对于 $\\nu \\in (0,1)$ 有 $E_{\\text{phase}}(\\nu)  0$。\n\n因此，使相位误差度量 $E_{\\text{phase}}(\\nu)$ 最小的 $\\nu \\in (0,1]$ 的值是 1。", "answer": "$$\n\\boxed{1}\n$$", "id": "3418392"}, {"introduction": "理论分析通常在理想化的线性方程上进行，但现实世界的许多问题是非线性的，并且可能产生激波等不连续解。本实践练习将带您从线性平流方程转向非线性的无粘伯格斯方程。您将通过编写代码，亲手实现并对比守恒形式与非守恒形式的MacCormack格式，直观地验证只有守恒格式才能正确捕捉激波的传播速度，这是一个在计算流体动力学中至关重要的实践性结论。[@problem_id:3342598]", "problem": "考虑守恒形式的一维无粘 Burgers 方程 $u_t + \\left(\\frac{u^2}{2}\\right)_x = 0$，其中 $u = u(x,t)$ 表示周期性域上的一个标量速度场，其空间坐标为 $x$。该守恒律在弱解意义下理解，因此可能出现间断解，并遵循由守恒原理推导出的积分平衡。通量函数为 $f(u) = \\frac{u^2}{2}$。对于 $u_L  u_R$ 的 Riemann 型初始数据，该方程允许激波的存在，由 Rankine–Hugoniot 跳跃条件决定的激波速度为 $s = \\frac{f(u_L) - f(u_R)}{u_L - u_R} = \\frac{u_L + u_R}{2}$。\n\nMacCormack 预测-校正格式用于求解双曲型偏微分方程。在守恒律形式下，MacCormack 方法通过对通量使用向前空间差分进行预测，并对预测后的通量使用向后差分进行校正，从而推进求解。一种非守恒变体则使用非守恒微分形式 $u_t + u\\,u_x = 0$ 来推进变量，将向前和向后差分应用于 $u$ 而不是通量 $f(u)$。对于间断解，只有守恒格式才能确保从积分守恒律推导出的正确激波运动，而非守恒格式不保证以正确的速度传播激波。\n\n你的任务是构造一个反例，证明对于无粘 Burgers 方程，与守恒 MacCormack 更新和解析 Rankine–Hugoniot 速度相比，非守恒 MacCormack 更新会产生不正确的激波位置。请按以下步骤操作：\n\n1. 使用长度为 $L = 2$ 的周期性域，对应于区间 $[-1,1)$。设 $N$ 为均匀分布的网格点数，因此 $\\Delta x = L/N$。在单元中心 $x_i = -L/2 + i\\,\\Delta x$（$i = 0,1,\\dots,N-1$）处表示数值。\n\n2. 在时间 $t=0$ 初始化 Riemann 数据，其在 $x = x_0$ 处有一个单个间断，定义为\n   $$\n   u(x,0) = \n   \\begin{cases}\n   u_L,  x  x_0, \\\\\n   u_R,  x \\ge x_0,\n   \\end{cases}\n   $$\n   在区间 $[-1,1)$ 外进行周期性延拓。\n\n3. 实现两种显式 MacCormack 预测-校正格式，使用恒定时间步长 $\\Delta t$，该步长满足基于最大特征速度的 Courant–Friedrichs–Lewy 条件。使用无量纲 Courant 数 $\\text{CFL}$，并设置 $\\Delta t = \\text{CFL}\\,\\Delta x / \\max(|u_L|,|u_R|)$。\n   - 守恒 MacCormack：使用通量函数 $f(u) = \\frac{u^2}{2}$ 的向前和向后差分来应用预测步和校正步，确保离散化与守恒律一致。\n   - 非守恒 MacCormack：在非守恒形式 $u_t + u\\,u_x = 0$ 中，使用原始变量 $u$ 的向前和向后差分来应用预测步和校正步。\n\n4. 将每个格式推进 $n$ 步，其中 $n = \\lceil T/\\Delta t \\rceil$，得到最终时间 $t_{\\text{end}} = n\\,\\Delta t$。\n\n5. 对于每个格式，通过识别解在相邻网格点之间穿过中点值 $m = \\frac{u_L + u_R}{2}$ 的位置 $x$ 来估计在 $t_{\\text{end}}$ 时的数值激波位置，使用单元中心之间的线性插值。如果由于周期性或数值振荡而存在多个穿越点，选择其位置与解析激波位置的周期性距离最小的那个穿越点。如果没有检测到穿越点，则通过离散梯度的最大幅值位置来近似激波位置，然后使用局部插值进行细化。\n\n6. 使用 Rankine–Hugoniot 速度 $s = \\frac{u_L + u_R}{2}$ 计算解析激波位置，即 $x_{\\text{exact}}(t_{\\text{end}}) = x_0 + s\\,t_{\\text{end}}$，将位置对畴域长度 $L$ 取模以保持在 $[-1,1)$ 内。\n\n7. 对于每个测试用例，分别报告守恒和非守恒 MacCormack 格式在 $t_{\\text{end}}$ 时计算出的数值激波位置与解析激波位置之间的绝对周期性距离。\n\n使用以下测试套件，其中包括一个清晰的激波传播、一个中等强度的激波和一个静止激波：\n- Case 1: $u_L = 2.0$, $u_R = 0.0$, $x_0 = 0.0$, $N = 1000$, $T = 0.3$, $\\text{CFL} = 0.4$.\n- Case 2: $u_L = 1.5$, $u_R = 0.5$, $x_0 = -0.2$, $N = 1000$, $T = 0.5$, $\\text{CFL} = 0.4$.\n- Case 3: $u_L = 1.0$, $u_R = -1.0$, $x_0 = 0.3$, $N = 1000$, $T = 0.4$, $\\text{CFL} = 0.4$.\n\n所有量均为无量纲；不需要物理单位。你的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，按每个案例的守恒误差后跟非守恒误差的顺序列出结果，即 $[e_{\\text{cons},1},e_{\\text{noncons},1},e_{\\text{cons},2},e_{\\text{noncons},2},e_{\\text{cons},3},e_{\\text{noncons},3}]$，其中每个 $e$ 是一个浮点数，表示对应格式和案例在最终时刻计算出的激波位置与解析激波位置之间的绝对周期性距离。", "solution": "该问题要求构造一个数值反例，以证明非守恒有限差分格式无法像守恒格式那样计算出无粘 Burgers 方程的正确激波速度。这将通过实现和比较 MacCormack 方法的两种变体来完成。\n\n守恒律形式的一维无粘 Burgers 方程为\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( \\frac{u^2}{2} \\right) = 0\n$$\n其中 $u(x,t)$ 是速度，通量函数为 $f(u) = \\frac{u^2}{2}$。对于导数存在的光滑解，可以应用链式法则得到非守恒形式：\n$$\n\\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} = 0\n$$\n然而，诸如 Burgers 方程之类的双曲守恒律，即使从光滑的初始数据出发，也会发展出间断（激波）。对于间断解，微分形式不是良定义的，必须参考守恒律的积分形式。间断的动力学由 Rankine–Hugoniot 跳跃条件决定，该条件是积分形式的直接推论。对于一个以速度 $s$ 运动、分隔两个常数状态 $u_L$（左）和 $u_R$（右）的激波，该条件为：\n$$\ns = \\frac{f(u_L) - f(u_R)}{u_L - u_R}\n$$\n对于 Burgers 方程，这给出了解析激波速度：\n$$\ns = \\frac{\\frac{1}{2}u_L^2 - \\frac{1}{2}u_R^2}{u_L - u_R} = \\frac{u_L + u_R}{2}\n$$\n一个数值格式必须以“守恒形式”构建，以确保其解收敛到满足此跳跃条件的弱解。非守恒格式不遵守积分平衡，通常会收敛到一个具有不正确激波速度的解。\n\n我们将对长度为 $L=2$ 的空间域 $x \\in [-1, 1)$ 进行离散化，使用 $N$ 个均匀分布的单元中心 $x_i = -L/2 + i \\Delta x$，$i = 0, \\dots, N-1$，其中 $\\Delta x = L/N$。时间步长 $\\Delta t$ 由 Courant–Friedrichs–Lewy (CFL) 条件确定，$\\Delta t = \\text{CFL} \\Delta x / \\max(|u_L|, |u_R|)$，以确保数值稳定性。\n\n初始条件是一个在 $x=x_0$ 处具有阶跃间断的 Riemann 问题：\n$$\nu(x,0) = \n\\begin{cases}\nu_L,  x  x_0, \\\\\nu_R,  x \\ge x_0,\n\\end{cases}\n$$\n我们将解推进到最终时间 $t_{\\text{end}} = n \\Delta t$，其中 $n = \\lceil T/\\Delta t \\rceil$。\n\n这两种 MacCormack 格式实现如下。设 $u_i^n$ 为网格点 $i$ 和时间 $t^n = n \\Delta t$ 处的数值解。\n\n**1. 守恒 MacCormack 格式**\n该格式离散化守恒律 $u_t + f(u)_x=0$。\n*   预测步（对通量使用向前差分）：\n    $$\n    u_i^* = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( f(u_{i+1}^n) - f(u_i^n) \\right)\n    $$\n*   校正步（对预测后的通量使用向后差分）：\n    $$\n    u_i^{n+1} = \\frac{1}{2} \\left( u_i^n + u_i^* - \\frac{\\Delta t}{\\Delta x} \\left( f(u_i^*) - f(u_{i-1}^*) \\right) \\right)\n    $$\n此处，索引按周期性处理，例如 $u_{N} = u_0$ 和 $u_{-1} = u_{N-1}$。该格式是守恒形式的，在网格细化的极限下，预期能计算出正确的激波速度。\n\n**2. 非守恒 MacCormack 格式**\n该格式离散化非守恒形式 $u_t + u u_x=0$。\n*   预测步（对 $u$ 使用向前差分）：\n    $$\n    u_i^* = u_i^n - u_i^n \\frac{\\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n)\n    $$\n*   校正步（对预测后的 $u$ 使用向后差分）：\n    $$\n    u_i^{n+1} = \\frac{1}{2} \\left( u_i^n + u_i^* - u_i^* \\frac{\\Delta t}{\\Delta x} (u_i^* - u_{i-1}^*) \\right)\n    $$\n这种构造方法没有在单元界面上离散化通量差分，因此不强制执行局部守恒属性。结果是，它不能保证捕捉到正确的激波动力学。\n\n在用两种格式将解演化到 $t_{\\text{end}}$后，我们确定数值激波位置。这是通过找到数值解剖面穿过中点值 $m = (u_L + u_R)/2$ 的位置来完成的。我们使用跨越穿越点的两个网格点之间的线性插值。如果由于数值振荡而出现多个穿越点，我们使用域上的周期性距离，选择离解析激波位置 $x_{\\text{analytical}}(t_{\\text{end}}) = x_0 + s \\cdot t_{\\text{end}}$ 最近的那个。在长度为 $L$ 的域上，两点 $p_1$ 和 $p_2$ 之间的绝对周期性距离由 $\\min(|p_1 - p_2|, L - |p_1 - p_2|)$ 给出。\n\n然后，每个格式的误差计算为其计算出的数值激波位置 $x_{\\text{numerical}}$ 与最终时间 $t_{\\text{end}}$ 时的解析激波位置 $x_{\\text{analytical}}$ 之间的绝对周期性距离。三个测试用例的结果将表明，非守恒格式的误差远大于守恒格式的误差，从而证实前者计算出了不正确的激波速度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the 1D inviscid Burgers' equation using conservative and nonconservative\n    MacCormack schemes to demonstrate the importance of conservation form\n    for shock capturing.\n    \"\"\"\n    test_cases = [\n        # (u_L, u_R, x_0, N, T, CFL)\n        (2.0, 0.0, 0.0, 1000, 0.3, 0.4),\n        (1.5, 0.5, -0.2, 1000, 0.5, 0.4),\n        (1.0, -1.0, 0.3, 1000, 0.4, 0.4),\n    ]\n\n    results = []\n\n    for u_L, u_R, x_0, N, T, CFL in test_cases:\n        L = 2.0\n        dx = L / N\n        x = -L/2 + np.arange(N) * dx\n        \n        # CFL condition and time steps\n        max_speed = max(abs(u_L), abs(u_R))\n        if max_speed == 0:\n            # Avoid division by zero if max speed is zero, choose a reasonable dt\n            max_speed = 1.0\n        dt = CFL * dx / max_speed\n        num_steps = math.ceil(T / dt)\n        t_end = num_steps * dt\n\n        # Initial condition\n        u0 = np.full(N, u_R, dtype=np.float64)\n        u0[x  x_0] = u_L\n        \n        u_cons = u0.copy()\n        u_noncons = u0.copy()\n\n        # --- Time evolution ---\n        for _ in range(num_steps):\n            # Conservative MacCormack\n            f = 0.5 * u_cons**2\n            # Predictor\n            u_star_c = u_cons - (dt / dx) * (np.roll(f, -1) - f)\n            # Corrector\n            f_star = 0.5 * u_star_c**2\n            u_cons = 0.5 * (u_cons + u_star_c - (dt / dx) * (f_star - np.roll(f_star, 1)))\n\n            # Nonconservative MacCormack\n            # Predictor\n            u_star_nc = u_noncons - u_noncons * (dt / dx) * (np.roll(u_noncons, -1) - u_noncons)\n            # Corrector\n            u_noncons = 0.5 * (u_noncons + u_star_nc - u_star_nc * (dt / dx) * (u_star_nc - np.roll(u_star_nc, 1)))\n        \n        # --- Analysis ---\n        # Analytical shock location\n        s = (u_L + u_R) / 2.0\n        x_analytical = x_0 + s * t_end\n        # Map to periodic domain [-L/2, L/2)\n        x_analytical = -L/2 + (x_analytical - (-L/2)) % L\n\n        midpoint_val = (u_L + u_R) / 2.0\n        \n        def find_shock_location(u_final, x_grid, L_domain, analytical_pos, dx_grid):\n            \"\"\"\n            Finds the numerical shock location by looking for a crossing of the\n            midpoint value, refined by linear interpolation.\n            \"\"\"\n            crossings = []\n            # Find all crossings of midpoint_val\n            for i in range(N):\n                u_i = u_final[i]\n                u_i_plus_1 = u_final[(i + 1) % N]\n                if (u_i - midpoint_val) * (u_i_plus_1 - midpoint_val) = 0 and u_i != u_i_plus_1:\n                    x_i = x_grid[i]\n                    x_cross = x_i + dx_grid * (midpoint_val - u_i) / (u_i_plus_1 - u_i)\n                    crossings.append(x_cross)\n\n            if crossings:\n                # Find crossing closest to analytical solution\n                min_dist = float('inf')\n                best_pos = crossings[0]\n                for pos in crossings:\n                    dist = abs(pos - analytical_pos)\n                    periodic_dist = min(dist, L_domain - dist)\n                    if periodic_dist  min_dist:\n                        min_dist = periodic_dist\n                        best_pos = pos\n                return best_pos\n            else:\n                # Fallback: max gradient\n                grad = np.abs(np.roll(u_final, -1) - u_final)\n                max_grad_idx = np.argmax(grad)\n                \n                u_a = u_final[max_grad_idx]\n                u_b = u_final[(max_grad_idx + 1) % N]\n                x_a = x_grid[max_grad_idx]\n                \n                if abs(u_b - u_a)  1e-9: # Avoid division by zero\n                    return x_a + dx_grid / 2.0\n                \n                x_pos = x_a + dx_grid * (midpoint_val - u_a) / (u_b - u_a)\n                return x_pos\n\n        def periodic_map(pos, length):\n            \"\"\"Maps a position to the periodic interval [-length/2, length/2).\"\"\"\n            return -length/2 + (pos - (-length/2)) % length\n\n        x_num_cons = find_shock_location(u_cons, x, L, x_analytical, dx)\n        x_num_noncons = find_shock_location(u_noncons, x, L, x_analytical, dx)\n        \n        x_num_cons = periodic_map(x_num_cons, L)\n        x_num_noncons = periodic_map(x_num_noncons, L)\n        \n        def periodic_distance(p1, p2, length):\n            \"\"\"Calculates the absolute periodic distance between two points.\"\"\"\n            dist = abs(p1 - p2)\n            return min(dist, length - dist)\n\n        error_cons = periodic_distance(x_num_cons, x_analytical, L)\n        error_noncons = periodic_distance(x_num_noncons, x_analytical, L)\n\n        results.extend([error_cons, error_noncons])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3342598"}, {"introduction": "在实际工程和科学计算中，我们处理的往往是带有物理边界的有限区域，而非理论分析中常用的周期性边界。边界条件的处理对数值解的全局精度有着决定性影响。本练习将通过“人造解法”（method of manufactured solutions）这一标准的数值验证技术，让您动手探索不同阶数的出流边界处理方式如何影响MacCormack格式的整体收敛阶，并指导您设计和实现一个能够恢复格式二阶精度的边界修正格式。[@problem_id:3418379]", "problem": "考虑线性平流方程 $u_t + a u_x = 0$，其空间域为 $x \\in [0,1]$，时间域为 $t \\in [0,T]$，其中平流速度 $a  0$ 为常数。MacCormack 预测-校正格式是一种两步显式方法，在间距为 $\\Delta x$ 的均匀网格上，通过一个使用空间前向差分的预测步和一个使用空间后向差分的校正步，将离散解 $u_i^n \\approx u(x_i,t^n)$ 从时间 $t^n$ 推进到时间 $t^{n+1} = t^n + \\Delta t$。内部节点使用时间中心更新，当空间和时间离散化均为二阶且在每个阶段一致地应用光滑边界数据时，可达到二阶精度。然而，在没有指定物理边界条件的流出边界处，需要数值封闭格式来更新边界节点并提供预测和校正步骤所需的值。在任一步骤中使用一阶单边封闭格式，即使内部格式是二阶的，也可能将全局精度阶数降低到一阶。\n\n从第一性原理出发，以控制方程 $u_t + a u_x = 0$ ($a  0$) 和用作人造解的光滑精确解 $u(x,t)$ 为起点。利用泰勒展开的一致性，并要求离散近似在所有节点（包括边界）上与连续微分算子的匹配达到指定阶数。在流入边界 $x=0$ 处，使用在适当阶段时间应用的光滑给定边界函数 $g(t) = u(0,t)$ 进行处理。分析一阶流出边界封闭格式如何在 $x=1$ 处引入一个量级为 $\\mathcal{O}(\\Delta x)$ 的局部截断误差，该误差可能主导全局误差。然后，在 $x=1$ 处设计一个边界校正模板，该模板与 MacCormack 时间积分相一致，并使用二阶单边空间导数来更新 $u_N \\approx u(1,t)$，从而使整个格式恢复二阶收敛性。\n\n您的程序必须在具有 $N+1$ 个节点 $x_i = i \\Delta x$（$\\Delta x = 1/N$）的均匀网格上，在 MacCormack 预测-校正框架内，为流出边界 $x=1$ 实现三种变体。设 Courant 数 $\\nu = a \\Delta t/\\Delta x$，$a=1$：\n\n- 变体 A（朴素常数外推）：在预测和校正阶段，均通过 $u_N = u_{N-1}$ 设置流出边界值。\n- 变体 B（一阶后向差分边界更新）：在预测阶段，使用时间 $t^n$ 处 $u_x$ 的一阶后向差分更新 $u_N$，即 $u_N^\\star = u_N^n - a \\Delta t \\, (u_N^n - u_{N-1}^n)/\\Delta x$。在校正阶段，使用带有一阶后向差分的梯形时间平均来更新 $u_N$，即 $u_N^{n+1} = u_N^n + \\tfrac{1}{2} \\Delta t \\, \\left(-a \\frac{u_N^n - u_{N-1}^n}{\\Delta x} - a \\frac{u_N^\\star - u_{N-1}^\\star}{\\Delta x} \\right)$。\n- 变体 C（二阶边界校正模板）：在预测阶段，使用时间 $t^n$ 处 $u_x$ 的二阶后向差分更新 $u_N$，即 $u_N^\\star = u_N^n - a \\Delta t \\, \\left( \\frac{3 u_N^n - 4 u_{N-1}^n + u_{N-2}^n}{2 \\Delta x} \\right)$。在校正阶段，使用带有二阶后向差分的梯形时间平均来更新 $u_N$，即 $u_N^{n+1} = u_N^n + \\tfrac{1}{2} \\Delta t \\, \\left( -a \\frac{3 u_N^n - 4 u_{N-1}^n + u_{N-2}^n}{2 \\Delta x} - a \\frac{3 u_N^\\star - 4 u_{N-1}^\\star + u_{N-2}^\\star}{2 \\Delta x} \\right)$。\n\n对于所有变体，在 $x=0$ 处应用流入边界条件，使用在相应阶段时间的人造精确边界值：$u_0^n = g(t^n)$ 和 $u_0^\\star = g(t^{n+1})$。对于内部节点，预测步使用前向差分，校正步使用后向差分，此为标准的 MacCormack 格式。\n\n使用人造解 $u(x,t) = \\sin(2 \\pi (x - a t))$，其中 $a=1$，该解精确满足齐次平流方程。通过 $u_i^0 = \\sin(2 \\pi x_i)$ 初始化离散解，并通过 $g(t) = \\sin(-2 \\pi t)$ 设置流入边界。使用 Courant 数 $\\nu = 0.8$（无量纲）积分至最终时间 $T=1$。选择时间步长 $\\Delta t$ 以满足 $\\nu \\le 0.8$ 且步数为整数，并如上所述在每个阶段时间 $t^n$ 和 $t^{n+1}$ 强制施加 $x=0$ 处的边界条件。\n\n定义时间 $T$ 时的离散 $\\ell^2$-误差为\n$$\nE(N) = \\left( \\frac{1}{N+1} \\sum_{i=0}^N \\left( u_i^{\\text{final}} - \\sin(2 \\pi (x_i - a T)) \\right)^2 \\right)^{1/2}.\n$$\n对于每个变体，使用 $p = \\log_2\\left( \\frac{E(N)}{E(2N)} \\right)$ 计算两个连续网格细化 $N$ 和 $2N$ 之间的观测精度阶数 $p$。\n\n测试套件规范：\n- 使用网格尺寸 $N \\in \\{64, 128, 256, 512\\}$。\n- 使用平流速度 $a = 1$，Courant 数 $\\nu = 0.8$，最终时间 $T = 1$（无量纲）。\n- 对每个变体，使用最精细的两个网格 $N=256$ 和 $N=512$ 评估观测阶数。\n- 三个测试用例对应于上述定义的变体 A、B 和 C。\n\n您的程序必须输出一行，包含一个由三个浮点数组成的列表 $[p_A, p_B, p_C]$，其中 $p_A$ 是变体 A 的观测阶数，$p_B$ 是变体 B 的观测阶数，$p_C$ 是变体 C 的观测阶数，顺序如此。不涉及单位。该单行必须严格为一个用方括号括起来的逗号分隔列表，除标准格式外无额外空格要求。答案值为浮点数。", "solution": "用户希望分析线性平流方程的 MacCormack 格式，重点关注流出边界条件对全局精度阶数的影响。\n\n### 1. 问题描述\n\n所考虑的问题是一维线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其空间域为 $x \\in [0, 1]$，时间域为 $t \\in [0, T]$，平流速度 $a  0$ 为常数。我们将使用人造解方法来验证数值格式的精度阶数。选定的精确解为 $u(x,t) = \\sin(2 \\pi (x - a t))$，它满足控制方程。这提供了初始条件 $u(x,0) = \\sin(2 \\pi x)$ 和在 $x=0$ 处的流入边界条件 $g(t) = u(0,t) = \\sin(-2 \\pi a t)$。由于 $a0$，特征线在边界 $x=1$ 处流出域外，因此那里没有指定物理边界条件；需要一个数值封闭格式。\n\n该域在具有 $N+1$ 个点 $x_i = i \\Delta x$（$i=0, 1, \\dots, N$，其中 $\\Delta x = 1/N$）的均匀网格上进行离散化。解以大小为 $\\Delta t$ 的时间步推进，其中 $t^n = n \\Delta t$。无量纲的 Courant-Friedrichs-Lewy (CFL) 数定义为 $\\nu = a \\Delta t / \\Delta x$。\n\n### 2. 内部 MacCormack 格式\n\nMacCormack 格式是一种显式、两步预测-校正方法。对于内部节点 $i=1, \\dots, N-1$，格式如下：\n\n**预测步：** 使用 $u_x$ 的前向空间差分进行一次前向欧拉时间步进：\n$$\nu_i^\\star = u_i^n - a \\frac{\\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n)\n$$\n这里，$u_i^n$ 是在 $(x_i, t^n)$ 处的数值解，$u_i^\\star$ 是在一个中间时间的预测值。\n\n**校正步：** 通过平均 $t^n$ 时刻和预测状态下的时间导数来获得新时间层 $t^{n+1} = t^n + \\Delta t$ 的最终值，这类似于梯形法则。此步骤中的空间导数对预测值使用后向差分：\n$$\nu_i^{n+1} = \\frac{1}{2} \\left( u_i^n + u_i^\\star - a \\frac{\\Delta t}{\\Delta x} (u_i^\\star - u_{i-1}^\\star) \\right)\n$$\n对于内部节点，只要解足够光滑，该格式在空间和时间上均为二阶精度，即 $\\mathcal{O}(\\Delta t^2, \\Delta x^2)$。前向差分后跟后向差分的组合对于抵消主阶误差项至关重要，从而获得二阶精度。\n\n### 3. 流出边界条件分析\n\n数值格式的全局精度由计算域中任何位置的局部截断误差 (LTE) 的最低阶数决定。如果数值边界条件的精度阶数低于内部格式，它会污染整个解并降低全局收敛阶。我们分析在流出边界 $x=1$（节点 $i=N$）处的三种不同数值边界条件。\n\n*   **变体 A（朴素常数外推）：** 问题将其描述为“在预测和校正阶段，均通过 $u_N = u_{N-1}$ 设置流出边界值。”我们将其解释为一个程序规则：\n    1.  在计算完内部节点的预测值 $u_i^\\star$ 后，通过外推设置边界处的预测值：$u_N^\\star = u_{N-1}^\\star$。\n    2.  在计算完内部节点的校正值 $u_i^{n+1}$ 后，通过外推设置边界处的最终值：$u_N^{n+1} = u_{N-1}^{n+1}$。\n    这是一个零阶外推，相当于假设 $(\\partial u / \\partial x)_N = 0$。这通常与偏微分方程的解不一致。这在边界处引入了量级为 $\\mathcal{O}(\\Delta x)$ 的局部截断误差。单个点上的一阶局部误差足以将整个格式的全局精度降低到一阶，即 $\\mathcal{O}(\\Delta x)$。\n\n*   **变体 B（一阶后向差分更新）：** 此变体使用与控制方程 $u_t = -a u_x$ 一致的模板来更新边界值 $u_N$，但空间差分为一阶精度。\n    -   预测步：$u_N^\\star = u_N^n - a \\Delta t \\left( \\frac{u_N^n - u_{N-1}^n}{\\Delta x} \\right)$。这是一个采用一阶后向差分计算 $u_x$ 的前向欧拉时间步。\n    -   校正步：$u_N^{n+1} = u_N^n - \\frac{a \\Delta t}{2} \\left[ \\left(\\frac{u_N^n - u_{N-1}^n}{\\Delta x}\\right) + \\left(\\frac{u_N^\\star - u_{N-1}^\\star}{\\Delta x}\\right) \\right]$。这里使用了梯形法则进行时间积分，该法则是二阶精度的。\n    然而，空间离散化仍为一阶精度。MacCormack 格式的二阶精度依赖于前向预测步和后向校正步误差的特定对称抵消。通过在预测阶段使用后向差分（或任何非前向差分的模板），这种误差抵消机制在边界及相邻节点处被破坏。边界附近的局部截断误差结果为 $\\mathcal{O}(\\Delta x^2)$，但抵消机制的破坏通常导致全局误差为一阶，即 $\\mathcal{O}(\\Delta x)$。\n\n*   **变体 C（二阶边界校正模板）：** 为了恢复二阶精度，数值边界条件本身必须至少是二阶精度的。此变体在边界节点 $i=N$ 处使用二阶精度的单边（后向）差分来计算空间导数 $u_x$。该模板由下式给出：\n    $$\n    \\left( \\frac{\\partial u}{\\partial x} \\right)_N \\approx \\frac{3 u_N - 4 u_{N-1} + u_{N-2}}{2 \\Delta x} + \\mathcal{O}(\\Delta x^2)\n    $$\n    此近似用于一个与内部 MacCormack 方法一致的时间积分格式中：\n    -   预测步：$u_N^\\star = u_N^n - a \\Delta t \\left( \\frac{3 u_N^n - 4 u_{N-1}^n + u_{N-2}^n}{2 \\Delta x} \\right)$。\n    -   校正步：$u_N^{n+1} = u_N^n - \\frac{a \\Delta t}{2} \\left[ \\left(\\frac{3 u_N^n - 4 u_{N-1}^n + u_{N-2}^n}{2 \\Delta x}\\right) + \\left(\\frac{3 u_N^\\star - 4 u_{N-1}^\\star + u_{N-2}^\\star}{2 \\Delta x}\\right) \\right]$。\n    由于此边界更新的 LTE 为 $\\mathcal{O}(\\Delta x^2, \\Delta t^2)$，它与内部格式的二阶精度相匹配。因此，整个计算的全局精度阶数预期为二阶，即 $\\mathcal{O}(\\Delta x^2)$。\n\n### 4. 实现与验证\n\n一个 Python 程序将实现这三个变体。对每个变体，在一系列加密的网格尺寸（$N=256, 512$）上运行模拟。在最终时间 $T=1$ 时，通过将数值解与精确的人造解进行比较，计算离散 $\\ell^2$-误差 $E(N)$。然后，使用最精细的两个网格的误差计算观测到的精度阶数 $p$：\n$$\np = \\log_2\\left( \\frac{E(N)}{E(2N)} \\right)\n$$\n我们期望得到 $p_A \\approx 1$、$p_B \\approx 1$ 和 $p_C \\approx 2$。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(N, variant, a, nu, T):\n    \"\"\"\n    Solves the 1D linear advection equation using the MacCormack scheme\n    with specified outflow boundary condition variants.\n\n    Args:\n        N (int): Number of spatial intervals.\n        variant (str): Outflow boundary condition variant ('A', 'B', or 'C').\n        a (float): Advection speed.\n        nu (float): Courant number.\n        T (float): Final time.\n\n    Returns:\n        float: The discrete l2-error at the final time.\n    \"\"\"\n    # 1. Grid and Time Step Setup\n    dx = 1.0 / N\n    dt_ideal = nu * dx / a\n    # Ensure an integer number of steps to reach T exactly\n    num_steps = int(round(T / dt_ideal))\n    dt = T / num_steps\n    # Recalculate Courant number based on adjusted dt\n    nu = a * dt / dx\n\n    x = np.linspace(0.0, 1.0, N + 1)\n\n    # 2. Define Exact Solution and Boundary Conditions\n    def u_exact(x_coords, t_val):\n        return np.sin(2 * np.pi * (x_coords - a * t_val))\n\n    def g(t_val):\n        return np.sin(-2 * np.pi * a * t_val)\n\n    # 3. Initial Condition\n    u = u_exact(x, 0.0)\n    t = 0.0\n\n    # 4. Time-stepping Loop\n    for _ in range(num_steps):\n        u_old = u.copy()\n        t_next = t + dt\n\n        # --- Predictor Stage ---\n        u_star = np.zeros_like(u_old)\n\n        # Inflow boundary condition (i=0) as specified for the predicted state\n        u_star[0] = g(t_next)\n\n        # Interior nodes (i=1 to N-1) using forward difference\n        u_star[1:N] = u_old[1:N] - nu * (u_old[2:] - u_old[1:N])\n\n        # Outflow boundary condition (i=N) for the predictor stage\n        if variant == 'A':\n            # Naive constant extrapolation of the predicted value\n            u_star[N] = u_star[N-1]\n        elif variant == 'B':\n            # First-order backward-difference update\n            u_star[N] = u_old[N] - nu * (u_old[N] - u_old[N-1])\n        elif variant == 'C':\n            # Second-order backward-difference update\n            u_star[N] = u_old[N] - (nu / 2.0) * (3 * u_old[N] - 4 * u_old[N-1] + u_old[N-2])\n\n        # --- Corrector Stage ---\n        u_new = np.zeros_like(u_old)\n\n        # Inflow boundary condition (i=0) for the final state\n        u_new[0] = g(t_next)\n\n        # Interior nodes (i=1 to N-1) using backward difference\n        u_new[1:N] = 0.5 * (u_old[1:N] + u_star[1:N] - nu * (u_star[1:N] - u_star[0:N-1]))\n\n        # Outflow boundary condition (i=N) for the corrector stage\n        if variant == 'A':\n            # Naive constant extrapolation of the final value\n            u_new[N] = u_new[N-1]\n        elif variant == 'B':\n            # First-order trapezoidal update\n            u_new[N] = u_old[N] - (nu / 2.0) * ((u_old[N] - u_old[N-1]) + (u_star[N] - u_star[N-1]))\n        elif variant == 'C':\n            # Second-order trapezoidal update\n            u_new[N] = u_old[N] - (nu / 4.0) * (\n                (3 * u_old[N] - 4 * u_old[N-1] + u_old[N-2]) +\n                (3 * u_star[N] - 4 * u_star[N-1] + u_star[N-2])\n            )\n\n        u = u_new\n        t = t_next\n\n    # 5. Compute Error\n    u_e = u_exact(x, T)\n    error = np.sqrt(np.mean((u - u_e)**2))\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and compute the order of accuracy.\n    \"\"\"\n    # Test Suite Specification\n    a = 1.0\n    nu_target = 0.8\n    T = 1.0\n    variants = ['A', 'B', 'C']\n    Ns = [256, 512]\n    \n    orders = []\n\n    for variant in variants:\n        errors = []\n        for N in Ns:\n            error = run_simulation(N, variant, a, nu_target, T)\n            errors.append(error)\n        \n        # Calculate observed order of accuracy p = log2(E(N) / E(2N))\n        # N=Ns[0], 2N=Ns[1]\n        order = np.log2(errors[0] / errors[1])\n        orders.append(order)\n\n    # Format the final output string\n    result_str = f\"[{orders[0]},{orders[1]},{orders[2]}]\"\n    print(result_str)\n\nsolve()\n```", "id": "3418379"}]}