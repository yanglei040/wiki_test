{"hands_on_practices": [{"introduction": "在数值方法中，代码验证是确保计算结果可靠性的基石。本实践将指导您完成一项基本而关键的任务：通过网格加密研究，凭经验验证求解热方程的有限差分格式的理论收敛阶。您将使用“人造解”方法（Method of Manufactured Solutions）来精确评估误差，这是计算科学中一项必不可少的核心技能，可用于确认您的代码是否按预期工作。[@problem_id:3405925]", "problem": "在二维结构化网格上设计并实现一个网格加密研究，以经验性地验证热方程离散化的二阶收敛性。考虑在单位正方形域 $[0,1] \\times [0,1]$ 上的无量纲热方程，其边界条件为齐次 Dirichlet 边界条件。控制偏微分方程为 $u_t - \\alpha \\Delta u = 0$，其中对于 $(x,y) \\in \\partial([0,1]^2)$ 和 $t \\ge 0$，有 $u(x,y,t) = 0$，且 $\\alpha > 0$ 是一个常数热扩散系数。使用制造解方法，定义一个光滑的精确解 $u_{\\mathrm{exact}}(x,y,t)$，该解满足域上的方程和边界条件。具体来说，使用以下函数族\n$$\nu_{\\mathrm{exact}}(x,y,t) = \\sin(k_x \\pi x)\\sin(k_y \\pi y)\\exp\\!\\left(-\\alpha \\pi^2 (k_x^2 + k_y^2) t\\right),\n$$\n其中 $k_x$ 和 $k_y$ 是正整数且 $(x,y) \\in [0,1]^2$。该 $u_{\\mathrm{exact}}$ 满足单位正方形上的热方程 $u_t - \\alpha \\Delta u = 0$ 以及齐次 Dirichlet 边界条件。\n\n使用均匀结构化网格对空间域进行离散化，每个维度有 $N$ 个区间，从而得到网格间距 $h = 1/N$。内部未知量位于节点 $(x_i, y_j)$ 上，其中 $x_i = i h$，$y_j = j h$，对于 $i,j \\in \\{1,2,\\dots,N-1\\}$。使用二阶中心有限差分和五点模板来近似拉普拉斯算子 $\\Delta u$。使用 Crank-Nicolson (CN) 方法对时间进行离散化，时间步长为均匀的 $\\Delta t$，确保全离散格式在空间和时间上均为二阶精度。用 $u(x,y,0) = u_{\\mathrm{exact}}(x,y,0)$ 初始化数值解，并演化至最终时间 $T > 0$。计算内部节点上的误差 $e(x_i,y_j) = u_{\\mathrm{num}}(x_i,y_j,T) - u_{\\mathrm{exact}}(x_i,y_j,T)$。\n\n定义离散范数如下：\n- 离散 $L^2$ 范数为\n$$\n\\|e\\|_{L^2_h} = \\left(h^2 \\sum_{i=1}^{N-1} \\sum_{j=1}^{N-1} \\left|e(x_i,y_j)\\right|^2\\right)^{1/2}.\n$$\n- 离散 $L^\\infty$ 范数为\n$$\n\\|e\\|_{L^\\infty_h} = \\max_{1 \\le i,j \\le N-1} \\left|e(x_i,y_j)\\right|.\n$$\n\n通过将 $N$ 加倍来进行网格加密，对于每对加密网格 $(N,2N)$，使用以下公式计算每个范数下的观测收敛阶 $p$：\n$$\np = \\frac{\\log\\left(\\frac{E(N)}{E(2N)}\\right)}{\\log(2)},\n$$\n其中 $E(N)$ 表示在分辨率 $N$ 下的误差范数。为保证稳定性和准确性，根据两种策略选择时间步长：\n- 策略 A：$\\Delta t = T/N^2$，确保时间误差与空间误差相比渐进可忽略，并且对于最终时间 $T$，时间步数恰好为 $N^2$。\n- 策略 B（边界情况）：使用与 $N$ 无关的固定时间步数，具体为 50 步，因此 $\\Delta t = T/50$，以展示在不加密时间离散化误差时性能的下降。\n\n在结构化网格上实现离散化，并使用内部节点的字典序来组装有限差分算子。在每个时间步求解由 Crank-Nicolson 方法产生的线性系统。\n\n您的程序必须执行以下测试套件并生成指定的输出：\n- 测试用例 1（正常路径）：$\\alpha = 1.0$, $k_x = 1$, $k_y = 1$, $T = 0.1$, $N \\in \\{8,16,32\\}$，使用策略 A 计算 $\\Delta t$。\n- 测试用例 2（带各向异性的正常路径）：$\\alpha = 0.7$, $k_x = 2$, $k_y = 3$, $T = 0.1$, $N \\in \\{8,16,32\\}$，使用策略 A 计算 $\\Delta t$。\n- 测试用例 3（固定时间步长的边界情况）：$\\alpha = 1.0$, $k_x = 1$, $k_y = 1$, $T = 0.1$, $N \\in \\{8,16,32\\}$，使用策略 B 计算 $\\Delta t$。\n\n对于每个测试用例，计算在离散 $L^2$ 和离散 $L^\\infty$ 范数下，两对加密网格 $(8,16)$ 和 $(16,32)$ 的平均观测收敛阶。最终输出必须是包含六个浮点数的单行，顺序如下：\n$$\n[p^{(1)}_{L^2}, p^{(1)}_{L^\\infty}, p^{(2)}_{L^2}, p^{(2)}_{L^\\infty}, p^{(3)}_{L^2}, p^{(3)}_{L^\\infty}],\n$$\n其中 $p^{(m)}_{\\cdot}$ 表示测试用例 $m \\in \\{1,2,3\\}$ 的平均观测阶。程序必须精确打印一行，包含这个用方括号括起来并以逗号分隔的列表。不需要物理单位；所有量纲均为一。此问题不涉及角度。所有答案必须是浮点数。", "solution": "用户要求设计并实现一个网格加密研究，以验证二维热方程数值解的收敛阶。该问题是有效的，因为它在科学上基于偏微分方程和数值分析的原理，是适定的，并且所有参数和方法都得到了客观和完整的定义。\n\n控制偏微分方程(PDE)是单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上的无量纲热方程：\n$$\n\\frac{\\partial u}{\\partial t} - \\alpha \\Delta u = 0, \\quad (x,y) \\in \\Omega, \\quad t \\ge 0\n$$\n其边界条件为齐次 Dirichlet 边界条件，$u(x,y,t) = 0$，对于 $(x,y) \\in \\partial\\Omega$。这里 $\\alpha > 0$ 是常数热扩散系数。\n\n提供了一个制造解以方便进行误差分析：\n$$\nu_{\\mathrm{exact}}(x,y,t) = \\sin(k_x \\pi x)\\sin(k_y \\pi y)\\exp\\!\\left(-\\alpha \\pi^2 (k_x^2 + k_y^2) t\\right)\n$$\n其中 $k_x$ 和 $k_y$ 是正整数。此函数同时满足偏微分方程和边界条件。数值求解必须从初始条件 $u(x,y,0) = u_{\\mathrm{exact}}(x,y,0)$ 开始。\n\n求解方法包括在空间和时间上离散化偏微分方程，然后进行收敛性研究。\n\n**1. 空间离散化**\n\n该域使用均匀结构化网格进行离散化，每个维度有 $N$ 个区间，网格间距为 $h = 1/N$。这会产生一个 $(N-1) \\times (N-1)$ 的内部节点网格 $(x_j, y_i) = (j h, i h)$，其中 $i,j \\in \\{1, \\ldots, N-1\\}$。在这些节点上解的值表示为 $u_{i,j}(t) \\approx u(x_j, y_i, t)$。\n\n拉普拉斯算子 $\\Delta u = u_{xx} + u_{yy}$，使用二阶中心有限差分格式（一个五点模板）进行近似：\n$$\n(\\Delta u)_{i,j} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} + \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2}\n$$\n由于 Dirichlet 条件，边界上的 $u$ 值为零。\n如果我们将 $(N-1)^2$ 个内部未知数值使用字典序（行主序）排列成一个列向量 $\\mathbf{u}$，半离散系统可以写成一个常微分方程（ODE）系统：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\alpha A_h \\mathbf{u}\n$$\n这里，$A_h$ 是离散拉普拉斯算子的稀疏矩阵表示。对于行主序（其中 $x$ 的索引变化最快），$A_h$ 可以通过一维二阶导数矩阵 $K_{1D}$ 和单位矩阵 $I_{N-1}$ 的 Kronecker 积来构造：\n$$\nA_h = \\frac{1}{h^2} (I_{N-1} \\otimes K_{1D} + K_{1D} \\otimes I_{N-1})\n$$\n其中 $I_{N-1}$ 是大小为 $(N-1) \\times (N-1)$ 的单位矩阵，$K_{1D}$ 是相同大小的三对角矩阵，其对角线上的模板为 $(1, -2, 1)$。\n\n**2. 时间离散化**\n\nCrank-Nicolson 方法是一种隐式的二阶精确格式，用于时间积分。将其应用于半离散系统得到：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{\\alpha}{2} A_h (\\mathbf{u}^{n+1} + \\mathbf{u}^n)\n$$\n其中 $\\mathbf{u}^n$ 是在时间 $t_n = n \\Delta t$ 的解向量。为了求解下一个时间步的解 $\\mathbf{u}^{n+1}$，我们重排该方程：\n$$\n\\left(I - \\frac{\\alpha \\Delta t}{2} A_h\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\alpha \\Delta t}{2} A_h\\right) \\mathbf{u}^n\n$$\n其中 $I$ 是大小为 $(N-1)^2 \\times (N-1)^2$ 的单位矩阵。在每个时间步，该方程形成一个线性方程组 $L \\mathbf{u}^{n+1} = R \\mathbf{u}^n$，必须求解 $\\mathbf{u}^{n+1}$。矩阵 $L$ 和 $R$ 是稀疏的，可以使用高效的稀疏线性求解器。\n\n**3. 收敛性研究**\n\n全离散格式在空间 ($O(h^2)$) 和时间 ($O(\\Delta t^2)$) 上都是二阶的。研究按以下步骤进行：\n- 对于一系列网格分辨率 $N \\in \\{8, 16, 32\\}$，计算数值解 $\\mathbf{u}_{\\mathrm{num}}(T)$ 直到最终时间 $T$。\n- 在内部节点上计算误差向量 $\\mathbf{e} = \\mathbf{u}_{\\mathrm{num}}(T) - \\mathbf{u}_{\\mathrm{exact}}(T)$。\n- 计算误差的离散 $L^2_h$ 和 $L^\\infty_h$ 范数，记为 $E$。\n- 对于每次从 $N$ 到 $2N$ 的加密，使用以下公式计算观测到的收敛阶 $p$：\n$$\np = \\frac{\\log(E(N)/E(2N))}{\\log(2)}\n$$\n- 最终报告的阶数是根据加密对 $(8,16)$ 和 $(16,32)$ 计算出的阶数的平均值。\n\n研究了两种时间步长策略：\n- **策略 A**：$\\Delta t = T/N^2$。由于 $h \\propto 1/N$，这意味着 $\\Delta t \\propto h^2$。时间误差 $O(\\Delta t^2)$ 变为 $O(h^4)$，其阶数高于空间误差 $O(h^2)$。因此，总误差将由空间离散化主导，观测到的收敛阶 $p$ 预计约为 $2$。\n- **策略 B**：$\\Delta t = T/50$（固定步数）。随着 $N$ 的增加，空间误差 $O(h^2)$ 减小，但时间误差 $O(\\Delta t^2)$ 保持不变。总误差将由固定的时间误差主导。因此，误差范数 $E(N)$ 将收敛到一个非零常数，比率 $E(N)/E(2N)$ 将接近 $1$，观测到的阶数 $p$ 将接近 $0$。\n\n实现过程将构造稀疏矩阵，并在时间推进格式的每一步使用稀疏线性求解器。指定测试用例的结果将按要求计算和格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 2D heat equation\n    and print the convergence orders.\n    \"\"\"\n\n    def exact_solution(x, y, t, alpha, kx, ky):\n        \"\"\"\n        Calculates the exact manufactured solution on a grid.\n        x, y can be meshgrid arrays.\n        \"\"\"\n        lambda_term = alpha * np.pi**2 * (kx**2 + ky**2)\n        return np.sin(kx * np.pi * x) * np.sin(ky * np.pi * y) * np.exp(-lambda_term * t)\n\n    def run_simulation(N, alpha, kx, ky, T, policy):\n        \"\"\"\n        Runs a single simulation for a given grid size N and physical parameters.\n        Returns the L2 and L-infinity error norms.\n        \"\"\"\n        M = N - 1\n        h = 1.0 / N\n\n        # Determine time step dt based on the policy\n        if policy == 'A':\n            num_steps = N**2\n        else:  # policy == 'B'\n            num_steps = 50\n        dt = T / num_steps\n\n        # Create grid for interior points. We use row-major (C-style) ordering,\n        # where u_grid[i, j] corresponds to point (x_j, y_i).\n        x = np.linspace(h, 1.0 - h, M)\n        y = np.linspace(h, 1.0 - h, M)\n        xx, yy = np.meshgrid(x, y, indexing='xy')\n\n        # Construct the 2D Laplacian operator A_h for row-major flattening.\n        diags_1d = [np.ones(M - 1), -2 * np.ones(M), np.ones(M - 1)]\n        K_1D = sparse.diags(diags_1d, [-1, 0, 1], format='csc')\n        I_M = sparse.identity(M, format='csc')\n\n        # sparse.kron(I_M, K_1D) handles x-derivatives (fastest index)\n        # sparse.kron(K_1D, I_M) handles y-derivatives (slower index)\n        A_h = (1 / h**2) * (sparse.kron(I_M, K_1D) + sparse.kron(K_1D, I_M))\n\n        # Construct Crank-Nicolson matrices (LHS and RHS).\n        I_M2 = sparse.identity(M**2, format='csc')\n        LHS = I_M2 - (alpha * dt / 2.0) * A_h\n        RHS = I_M2 + (alpha * dt / 2.0) * A_h\n        \n        # Initial condition from exact solution at t=0\n        u0_grid = exact_solution(xx, yy, 0, alpha, kx, ky)\n        u_vec = u0_grid.flatten()  # Row-major flattening by default\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            b_vec = RHS @ u_vec\n            u_vec = linalg.spsolve(LHS, b_vec)\n\n        # Calculate error at final time T\n        u_final_grid = u_vec.reshape((M, M))\n        u_exact_final_grid = exact_solution(xx, yy, T, alpha, kx, ky)\n        \n        error_grid = u_final_grid - u_exact_final_grid\n        \n        # Compute discrete L2 and L-infinity norms\n        error_l2 = h * np.linalg.norm(error_grid.flatten())\n        error_linf = np.max(np.abs(error_grid))\n\n        return error_l2, error_linf\n\n    def run_convergence_study(params):\n        \"\"\"\n        Runs simulations for a range of N and computes the average order of convergence.\n        \"\"\"\n        errors_l2 = []\n        errors_linf = []\n        \n        for N in params['Ns']:\n            l2_err, linf_err = run_simulation(\n                N, params['alpha'], params['kx'], params['ky'], params['T'], params['policy']\n            )\n            errors_l2.append(l2_err)\n            errors_linf.append(linf_err)\n\n        def calculate_avg_order(errors):\n            orders = []\n            for i in range(len(errors) - 1):\n                # Ratio of errors from grid N to 2N\n                ratio = errors[i] / errors[i+1]\n                if ratio > 1e-12:  # Avoid log of zero or negative\n                    order = np.log(ratio) / np.log(2)\n                    orders.append(order)\n            \n            if not orders:\n                return float('nan')\n            return np.mean(orders)\n\n        avg_p_l2 = calculate_avg_order(errors_l2)\n        avg_p_linf = calculate_avg_order(errors_linf)\n\n        return avg_p_l2, avg_p_linf\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path)\n        {'alpha': 1.0, 'kx': 1, 'ky': 1, 'T': 0.1, 'Ns': [8, 16, 32], 'policy': 'A'},\n        # Test case 2 (happy path with anisotropy)\n        {'alpha': 0.7, 'kx': 2, 'ky': 3, 'T': 0.1, 'Ns': [8, 16, 32], 'policy': 'A'},\n        # Test case 3 (edge case with fixed time steps)\n        {'alpha': 1.0, 'kx': 1, 'ky': 1, 'T': 0.1, 'Ns': [8, 16, 32], 'policy': 'B'},\n    ]\n\n    results = []\n    for case in test_cases:\n        p_l2, p_linf = run_convergence_study(case)\n        results.extend([p_l2, p_linf])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3405925"}, {"introduction": "除了标准的同位网格（collocated grid），结构化网格还有一些为特定应用而设计的变体。本实践将向您介绍在计算流体力学（CFD）中至关重要的交错网格（staggered grid），特别是 Marker-and-Cell (MAC) 网格，它能有效避免压力伪振荡。您将实现并验证投影法（projection method）的核心步骤，这是求解不可压缩流体运动的基本算法，同时加深对离散算子（如梯度和散度）及其伴随关系的理解。[@problem_id:3405983]", "problem": "考虑一个二维周期性方形区域，该区域使用 Marker-and-Cell (MAC) 交错网格进行离散化，其中 $x$ 方向有 $N_x$ 个单元，$y$ 方向有 $N_y$ 个单元，物理域长度为 $L_x$ 和 $L_y$，相应的网格间距为 $d_x = L_x / N_x$ 和 $d_y = L_y / N_y$。设标量场 $p$ 存储在单元中心，速度场 $\\boldsymbol{u} = (u_x, u_y)$ 存储在单元面上，其中 $u_x$ 位于垂直面的中心，$u_y$ 位于水平面的中心。两个方向均为周期性边界条件。\n\n定义离散梯度算子 $\\mathcal{G}$，通过前向差分将单元中心的标量映射到面中心的分量：\n$$\n\\left(\\mathcal{G}_x p\\right)_{i,j} = \\frac{p_{i+1,j} - p_{i,j}}{d_x}, \\quad\n\\left(\\mathcal{G}_y p\\right)_{i,j} = \\frac{p_{i,j+1} - p_{i,j}}{d_y},\n$$\n其中索引在两个方向上都进行周期性卷绕。定义离散散度算子 $\\mathcal{D}$，通过后向差分将面中心的速度映射到单元中心的标量：\n$$\n\\left(\\mathcal{D}\\boldsymbol{u}\\right)_{i,j} = \\frac{u_{x, i,j} - u_{x, i-1,j}}{d_x} + \\frac{u_{y, i,j} - u_{y, i,j-1}}{d_y},\n$$\n同样进行周期性卷绕。离散拉普拉斯算子由复合 $\\mathcal{L} = \\mathcal{D}\\mathcal{G}$ 定义，这会产生单元中心上标准的二阶周期性离散拉普拉斯算子。\n\n为单元中心的标量空间配备离散内积：\n$$\n\\langle p, q \\rangle_c = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} p_{i,j} q_{i,j} \\, d_x d_y,\n$$\n并为面中心的速度空间配备离散内积：\n$$\n\\langle \\boldsymbol{u}, \\boldsymbol{v} \\rangle_f = \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} \\left[u_{x,i,j} v_{x,i,j} + u_{y,i,j} v_{y,i,j}\\right] \\, d_x d_y.\n$$\n\n您的任务是在此 MAC 网格上实现一个离散实验，以验证两个属性：\n\n1. 投影至无散度：给定一个中间速度 $\\boldsymbol{u}^\\star$，通过求解周期性泊松方程来计算单元中心的压力 $p$：\n$$\n\\mathcal{L} p = \\frac{1}{\\Delta t} \\, \\mathcal{D}\\boldsymbol{u}^\\star,\n$$\n附加约束条件 $p$ 的平均值恰好为零（以在周期性设置中选择唯一解）。然后形成投影速度：\n$$\n\\boldsymbol{u} = \\boldsymbol{u}^\\star - \\Delta t \\, \\mathcal{G}p,\n$$\n并通过报告所有单元上的最大绝对值，来数值上验证离散散度 $\\mathcal{D}\\boldsymbol{u}$ 在机器精度内恒为零。\n\n2. 离散伴随性：对于随机的 $p$ 和 $\\boldsymbol{u}$，通过计算下式来验证在给定内积下 $\\mathcal{G}$ 和 $\\mathcal{D}$ 是伴随算子：\n$$\n\\epsilon = \\left| \\langle p, \\mathcal{D}\\boldsymbol{u} \\rangle_c + \\langle \\mathcal{G}p, \\boldsymbol{u} \\rangle_f \\right|,\n$$\n由于周期性边界条件下的离散分部求和，其值应在舍入误差范围内为零。\n\n使用快速傅里叶变换 (FFT) 求解单元中心网格上的周期性泊松方程。作用于单元中心的周期性离散拉普拉斯算子的特征值是：\n$$\n\\lambda_{k,\\ell} = \\frac{2 \\left(\\cos\\left(\\frac{2\\pi k}{N_x}\\right) - 1\\right)}{d_x^2} + \\frac{2 \\left(\\cos\\left(\\frac{2\\pi \\ell}{N_y}\\right) - 1\\right)}{d_y^2}, \\quad k \\in \\{0,\\dots,N_x-1\\}, \\ \\ell \\in \\{0,\\dots,N_y-1\\}.\n$$\n使用这些特征值来构建谱解，并通过将 $p$ 的平均值强制为零来处理 $\\lambda_{0,0}=0$ 的零模问题。\n\n实现程序以运行以下测试套件。对于每个案例，使用可复现的随机种子生成 $\\boldsymbol{u}^\\star$，并用另一个种子为伴随性测试独立生成 $p$ 和 $\\boldsymbol{u}$。每个案例报告两个浮点数：投影后的最大绝对散度和伴随性缺陷 $\\epsilon$。\n\n测试套件：\n- 案例 A (理想路径): $N_x = 32$, $N_y = 20$, $L_x = 1$, $L_y = 1$, $\\Delta t = 0.5$, $\\boldsymbol{u}^\\star$ 的种子为 $7$, 伴随性测试场的种子为 $13$。\n- 案例 B (小网格边界条件压力测试): $N_x = 2$, $N_y = 3$, $L_x = 1$, $L_y = 1$, $\\Delta t = 1.3$, $\\boldsymbol{u}^\\star$ 的种子为 $3$, 伴随性测试场的种子为 $5$。\n- 案例 C (各向异性间距): $N_x = 16$, $N_y = 16$, $L_x = 2$, $L_y = 1$, $\\Delta t = 0.75$, $\\boldsymbol{u}^\\star$ 的种子为 $101$, 伴随性测试场的种子为 $202$。\n- 案例 D (非方形、较大网格): $N_x = 17$, $N_y = 29$, $L_x = 3$, $L_y = 2$, $\\Delta t = 2.0$, $\\boldsymbol{u}^\\star$ 的种子为 $42$, 伴随性测试场的种子为 $99$。\n\n您的程序应产生一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个条目对应一个测试案例，并且本身是一个包含两个浮点数的列表，顺序为 $[\\max|\\mathcal{D}\\boldsymbol{u}|, \\epsilon]$。例如，输出格式必须与以下完全一致：\n$$\n\\left[ [r_1, e_1], [r_2, e_2], [r_3, e_3], [r_4, e_4] \\right],\n$$\n浮点数使用标准 Python 格式打印，无附加文本。无需物理单位、角度单位或百分比；报告原始数值。", "solution": "该问题提出了一个针对计算流体力学中常用数值方法的验证任务，具体来说是用于求解二维周期性区域上不可压缩 Navier-Stokes 方程的投影法。离散化采用 Marker-and-Cell (MAC) 交错网格。任务是数值上验证离散算子的两个基本属性：投影步骤在强制执行无散度条件方面的有效性，以及离散梯度和散度算子之间的伴随关系。\n\n首先，我们建立离散框架。区域是一个大小为 $L_x \\times L_y$ 的矩形，离散为 $N_x \\times N_y$ 个单元，得到网格间距 $d_x = L_x / N_x$ 和 $d_y = L_y / N_y$。在此网格上，标量压力场 $p$ 位于单元中心 $(i,j)$，而速度分量 $u_x$ 和 $u_y$ 是交错的，分别位于垂直面 $(i+1/2, j)$ 和水平面 $(i, j+1/2)$ 的中心。所有场索引，如 $p_{i,j}$、$u_{x,i,j}$ 和 $u_{y,i,j}$，其 $i$ 的范围是 $\\{0, \\dots, N_x-1\\}$，$j$ 的范围是 $\\{0, \\dots, N_y-1\\}$。\n\n离散梯度算子 $\\mathcal{G}$ 将单元中心的标量场 $p$ 映射到面中心的矢量分量。它使用前向差分定义，考虑到交错网格的布局，这是很自然的：\n$$\n\\left(\\mathcal{G}_x p\\right)_{i,j} = \\frac{p_{i+1,j} - p_{i,j}}{d_x}\n$$\n$$\n\\left(\\mathcal{G}_y p\\right)_{i,j} = \\frac{p_{i,j+1} - p_{i,j}}{d_y}\n$$\n由于周期性边界条件，索引是卷绕的，例如 $p_{N_x,j} = p_{0,j}$。\n\n离散散度算子 $\\mathcal{D}$ 将面中心的速度场 $\\boldsymbol{u}$ 映射到单元中心的标量。它使用后向差分定义，这种选择与前向差分梯度相结合，对该格式的数学性质至关重要：\n$$\n\\left(\\mathcal{D}\\boldsymbol{u}\\right)_{i,j} = \\frac{u_{x, i,j} - u_{x, i-1,j}}{d_x} + \\frac{u_{y, i,j} - u_{y, i,j-1}}{d_y}\n$$\n同样，索引是周期性卷绕的。这些算子的复合定义了离散拉普拉斯算子 $\\mathcal{L} = \\mathcal{D}\\mathcal{G}$。应用这些定义可以得到笛卡尔网格上拉普拉斯算子的标准 5 点模板：\n$$\n(\\mathcal{L}p)_{i,j} = \\frac{p_{i+1,j} - 2p_{i,j} + p_{i-1,j}}{d_x^2} + \\frac{p_{i,j+1} - 2p_{i,j} + p_{i,j-1}}{d_y^2}\n$$\n\n第一个任务是验证投影步骤。给定一个不一定无散度的中间速度场 $\\boldsymbol{u}^\\star$，投影法通过求解一个泊松方程来计算压力修正 $p$，然后更新速度。\n压力的泊松方程为：\n$$\n\\mathcal{L} p = \\frac{1}{\\Delta t} \\mathcal{D}\\boldsymbol{u}^\\star\n$$\n对于周期性区域，算子 $\\mathcal{L}$ 的零空间由常数场构成。仅当右端项与此零空间正交时，解才存在，这意味着其积分（在离散情况下为求和）必须为零。$(\\mathcal{D}\\boldsymbol{u}^\\star)_{i,j}$ 在所有单元上的总和由于周期性在每个方向上形成一个伸缩求和，因此恒等于零。这保证了 $p$ 的解的存在性。为获得唯一解，我们强制 $p$ 的平均值为零。\n\n使用快速傅里叶变换 (FFT) 可以高效地求得解 $p$。在傅里叶空间中，离散拉普拉斯算子变成与其特征值 $\\lambda_{k,\\ell}$ 的简单乘法。方程变为 $\\lambda_{k,\\ell} \\hat{p}_{k,\\ell} = \\frac{1}{\\Delta t} (\\widehat{\\mathcal{D}\\boldsymbol{u}^\\star})_{k,\\ell}$。因此，压力的傅里叶系数为 $\\hat{p}_{k,\\ell} = \\frac{1}{\\Delta t \\cdot \\lambda_{k,\\ell}} (\\widehat{\\mathcal{D}\\boldsymbol{u}^\\star})_{k,\\ell}$。对于零频模式 $(k,\\ell)=(0,0)$，$\\lambda_{0,0}=0$。对 $p$ 的零均值约束意味着 $\\hat{p}_{0,0}=0$。对于所有其他模式，该除法是良定义的。计算出所有 $\\hat{p}_{k,\\ell}$ 后，逆 FFT 产生压力场 $p$。\n\n一旦 $p$ 已知，投影后的无散度速度场 $\\boldsymbol{u}$ 计算如下：\n$$\n\\boldsymbol{u} = \\boldsymbol{u}^\\star - \\Delta t \\, \\mathcal{G}p\n$$\n为了验证该方法，我们计算新场的散度 $\\mathcal{D}\\boldsymbol{u}$：\n$$\n\\mathcal{D}\\boldsymbol{u} = \\mathcal{D}(\\boldsymbol{u}^\\star - \\Delta t \\, \\mathcal{G}p) = \\mathcal{D}\\boldsymbol{u}^\\star - \\Delta t \\, \\mathcal{D}\\mathcal{G}p = \\mathcal{D}\\boldsymbol{u}^\\star - \\Delta t \\, \\mathcal{L}p\n$$\n代入泊松方程 $\\mathcal{L}p = \\frac{1}{\\Delta t}\\mathcal{D}\\boldsymbol{u}^\\star$，我们发现：\n$$\n\\mathcal{D}\\boldsymbol{u} = \\mathcal{D}\\boldsymbol{u}^\\star - \\Delta t \\left(\\frac{1}{\\Delta t} \\mathcal{D}\\boldsymbol{u}^\\star\\right) = 0\n$$\n这个恒等式应在机器精度内成立。我们将报告 $\\mathcal{D}\\boldsymbol{u}$ 在所有单元上的最大绝对值。\n\n第二个任务是验证 $\\mathcal{G}$ 和 $\\mathcal{D}$ 之间的离散伴随关系。如果 $\\langle p, \\mathcal{D}\\boldsymbol{u} \\rangle_c = \\langle -\\mathcal{G}p, \\boldsymbol{u} \\rangle_f$，或 $\\langle p, \\mathcal{D}\\boldsymbol{u} \\rangle_c + \\langle \\mathcal{G}p, \\boldsymbol{u} \\rangle_f = 0$，则算子是伴随的。该属性是周期性区域分部积分公式 $\\int p (\\nabla \\cdot \\boldsymbol{u}) \\, dV = -\\int (\\nabla p) \\cdot \\boldsymbol{u} \\, dV$ 的离散模拟。我们可以通过分部求和来证明这个关系。考虑 $\\langle \\mathcal{G}p, \\boldsymbol{u} \\rangle_f$ 中涉及 $x$ 分量的项：\n$$\n\\sum_{i,j} (\\mathcal{G}_x p)_{i,j} u_{x,i,j} d_x d_y = \\sum_{i,j} \\frac{p_{i+1,j} - p_{i,j}}{d_x} u_{x,i,j} d_x d_y = \\sum_{i,j} (p_{i+1,j} - p_{i,j}) u_{x,i,j} d_y d_x\n$$\n通过对求和重新索引（在第一项中将 $i \\to i-1$）并利用周期性，这变成：\n$$\n\\sum_{i,j} p_{i,j} u_{x,i-1,j} d_y d_x - \\sum_{i,j} p_{i,j} u_{x,i,j} d_y d_x = \\sum_{i,j} p_{i,j} (u_{x,i-1,j} - u_{x,i,j}) d_y d_x\n$$\n将此与 $y$ 分量的类似项结合，我们得到：\n$$\n\\langle \\mathcal{G}p, \\boldsymbol{u} \\rangle_f = \\sum_{i,j} p_{i,j} \\left( \\frac{u_{x,i-1,j} - u_{x,i,j}}{d_x} + \\frac{u_{y,i,j-1} - u_{y,i,j}}{d_y} \\right) d_x d_y = - \\langle p, \\mathcal{D}\\boldsymbol{u} \\rangle_c\n$$\n因此，对于随机生成的场，量 $\\epsilon = \\left| \\langle p, \\mathcal{D}\\boldsymbol{u} \\rangle_c + \\langle \\mathcal{G}p, \\boldsymbol{u} \\rangle_f \\right|$ 应在浮点舍入误差范围内为零。\n\n以下 Python 实现将为测试套件中的每个指定案例执行这两个验证测试。", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (happy path)\n        (32, 20, 1.0, 1.0, 0.5, 7, 13),\n        # Case B (small grid boundary condition stress test)\n        (2, 3, 1.0, 1.0, 1.3, 3, 5),\n        # Case C (anisotropic spacings)\n        (16, 16, 2.0, 1.0, 0.75, 101, 202),\n        # Case D (non-square, larger grid)\n        (17, 29, 3.0, 2.0, 2.0, 42, 99),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        res_tuple = run_case(*params)\n        all_results.append(list(res_tuple))\n    \n    # Format the output exactly as specified: a list of lists printed on a single line.\n    # The default string representation of a list of lists in Python matches the example.\n    print(all_results)\n\ndef run_case(Nx, Ny, Lx, Ly, dt, seed_u_star, seed_adjoint):\n    \"\"\"\n    Runs the two verification experiments for a single test case.\n    \n    Returns:\n        A tuple (max_abs_div, epsilon) containing the results.\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n    \n    # Define discrete operators\n    def grad(p_cc):\n        \"\"\"Computes discrete gradient of a cell-centered scalar.\"\"\"\n        gpx_fc = (np.roll(p_cc, -1, axis=1) - p_cc) / dx\n        gpy_fc = (np.roll(p_cc, -1, axis=0) - p_cc) / dy\n        return gpx_fc, gpy_fc\n\n    def div(ux_fc, uy_fc):\n        \"\"\"Computes discrete divergence of a face-centered vector.\"\"\"\n        div_cc = (ux_fc - np.roll(ux_fc, 1, axis=1)) / dx + \\\n                 (uy_fc - np.roll(uy_fc, 1, axis=0)) / dy\n        return div_cc\n\n    def poisson_solver_fft(rhs_cc):\n        \"\"\"Solves the periodic Poisson equation using FFTs.\"\"\"\n        rhs_hat = fft.fft2(rhs_cc)\n        \n        k = fft.fftfreq(Nx) * Nx\n        l = fft.fftfreq(Ny) * Ny\n        # Use indexing='ij' to match array layout (Ny, Nx)\n        kk, ll = np.meshgrid(k, l, indexing='ij')\n        \n        lambda_kl = (2 * (np.cos(2 * np.pi * kk / Nx) - 1) / dx**2 +\n                     2 * (np.cos(2 * np.pi * ll / Ny) - 1) / dy**2)\n        \n        p_hat = np.zeros_like(rhs_hat, dtype=np.complex128)\n        non_zero_modes = lambda_kl != 0\n        p_hat[non_zero_modes] = rhs_hat[non_zero_modes] / lambda_kl[non_zero_modes]\n        # The mean of p is set to zero by setting the (0,0) Fourier mode to 0\n        p_hat[0, 0] = 0.0\n\n        p_cc = fft.ifft2(p_hat).real\n        return p_cc\n\n    # --- Task 1: Projection to divergence-free ---\n    rng = np.random.default_rng(seed_u_star)\n    u_star_x = rng.random((Ny, Nx))\n    u_star_y = rng.random((Ny, Nx))\n    \n    div_u_star = div(u_star_x, u_star_y)\n    p_corr = poisson_solver_fft(div_u_star / dt)\n    gp_x, gp_y = grad(p_corr)\n    u_final_x = u_star_x - dt * gp_x\n    u_final_y = u_star_y - dt * gp_y\n    div_u_final = div(u_final_x, u_final_y)\n    max_abs_div = np.max(np.abs(div_u_final))\n\n    # --- Task 2: Discrete adjointness ---\n    rng = np.random.default_rng(seed_adjoint)\n    p_rand = rng.random((Ny, Nx))\n    u_rand_x = rng.random((Ny, Nx))\n    u_rand_y = rng.random((Ny, Nx))\n\n    cell_vol = dx * dy\n    def inner_c(p, q):\n        return np.sum(p * q) * cell_vol\n    \n    def inner_f(ux, uy, vx, vy):\n        return (np.sum(ux * vx) + np.sum(uy * vy)) * cell_vol\n\n    gp_rand_x, gp_rand_y = grad(p_rand)\n    div_u_rand = div(u_rand_x, u_rand_y)\n    term1 = inner_c(p_rand, div_u_rand)\n    term2 = inner_f(gp_rand_x, gp_rand_y, u_rand_x, u_rand_y)\n    epsilon = np.abs(term1 + term2)\n\n    return max_abs_div, epsilon\n\nsolve()\n```", "id": "3405983"}]}