{"hands_on_practices": [{"introduction": "任何数值方法的基石都是其坚实的理论基础。本练习 [@problem_id:3310233] 将指导您使用泰勒级数展开，从第一性原理推导出二维拉普拉斯算子的五点差分格式。通过这个过程，您将深刻理解该差分格式为何具有其特定形式，以及它是如何逼近连续的拉普拉斯算子的。", "problem": "考虑一个二维空间中的稳态扩散模型，该模型由拉普拉斯算子控制，这是许多计算流体动力学 (CFD) 应用中作为典型偏微分方程 (PDE) 出现的一种算子。令 $\\Omega = (0,1)\\times(0,1)$，并设 $\\{(x_i,y_j)\\}$ 为一个均匀的笛卡尔网格，其在两个方向上的间距均为 $h$，因此对于整数 $i$ 和 $j$，有 $x_i = i h$ 和 $y_j = j h$。将网格函数值记为 $u_{i,j} = u(x_i,y_j)$。从拉普拉斯算子的坐标定义 $\\nabla^{2} u = \\frac{\\partial^{2} u}{\\partial x^{2}} + \\frac{\\partial^{2} u}{\\partial y^{2}}$ 出发，并使用关于内部节点 $(x_i,y_j)$ 的多元泰勒级数展开，构建一个在该网格上用于二维拉普拉斯算子的二阶精度五点有限差分格式。然后，使用此近似，推导与泊松形式 $-\\,\\nabla^{2} u = f$ 相关的离散内部节点方程，其中 $f$ 是光滑函数。\n\n你的推导必须仅从拉普拉斯算子的定义和泰勒定理出发，并且不得使用任何预先引用的有限差分公式。作为最终答案，请提供在该均匀网格上内部节点 $(i,j)$ 处的离散拉普拉斯算子 $\\Delta_h u_{i,j}$ 的显式表达式，该表达式仅用 $u_{i,j}$ 及其四个面相邻邻居以及网格间距 $h$ 来表示。最终答案必须是无单位的单个封闭形式解析表达式。", "solution": "该问题要求在一个均匀的笛卡尔网格上，为二维拉普拉斯算子 $\\nabla^{2} u$ 推导二阶精度的五点有限差分格式。推导过程必须从第一性原理出发，使用泰勒级数展开。随后，将使用此格式来写出泊松方程 $-\\nabla^{2} u = f$ 的离散形式。\n\n二维拉普拉斯算子在笛卡尔坐标系中的定义为：\n$$\n\\nabla^{2} u = \\frac{\\partial^{2} u}{\\partial x^{2}} + \\frac{\\partial^{2} u}{\\partial y^{2}}\n$$\n我们将分别在内部网格节点 $(x_i, y_j)$ 处为每个二阶偏导数推导有限差分近似。网格是均匀的，在两个方向上的间距均为 $h$，因此 $x_{i\\pm1} = x_i \\pm h$ 且 $y_{j\\pm1} = y_j \\pm h$。我们使用记号 $u_{i,j} = u(x_i, y_j)$。\n\n首先，考虑关于 $x$ 的偏导数 $\\frac{\\partial^{2} u}{\\partial x^{2}}$。我们使用 $u(x_i+h, y_j)$ 和 $u(x_i-h, y_j)$ 关于点 $(x_i, y_j)$ 的泰勒级数展开。假设函数 $u(x,y)$ 足够光滑，展开式为：\n$$\nu(x_i+h, y_j) = u_{i+1,j} = u_{i,j} + h \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial x^3}\\right)_{i,j} + \\frac{h^4}{4!} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^5)\n$$\n$$\nu(x_i-h, y_j) = u_{i-1,j} = u_{i,j} - h \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} - \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial x^3}\\right)_{i,j} + \\frac{h^4}{4!} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^5)\n$$\n将这两个方程相加，消去奇数阶导数项：\n$$\nu_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h^2 \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\frac{2h^4}{24} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^6)\n$$\n整理此表达式以求解二阶偏导数，得到：\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} - \\frac{h^2}{12} \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + O(h^4)\n$$\n这为 $\\frac{\\partial^{2} u}{\\partial x^{2}}$ 提供了一个有限差分近似。截断误差的主项与 $h^2$ 成正比，这使其成为一个二阶精度的中心差分格式。\n\n对 $y$ 方向采用类似的过程，我们考虑 $u(x_i, y_j+h)$ 和 $u(x_i, y_j-h)$ 的泰勒展开：\n$$\nu(x_i, y_j+h) = u_{i,j+1} = u_{i,j} + h \\left(\\frac{\\partial u}{\\partial y}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} + \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial y^3}\\right)_{i,j} + O(h^4)\n$$\n$$\nu(x_i, y_j-h) = u_{i,j-1} = u_{i,j} - h \\left(\\frac{\\partial u}{\\partial y}\\right)_{i,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} - \\frac{h^3}{3!} \\left(\\frac{\\partial^3 u}{\\partial y^3}\\right)_{i,j} + O(h^4)\n$$\n将这两个展开式相加并整理，得到 $\\frac{\\partial^{2} u}{\\partial y^{2}}$ 的近似：\n$$\n\\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} - \\frac{h^2}{12} \\left(\\frac{\\partial^4 u}{\\partial y^4}\\right)_{i,j} + O(h^4)\n$$\n这也是一个二阶精度的中心差分近似。\n\n现在我们可以通过将两个二阶偏导数的近似相加来构造拉普拉斯算子的近似：\n$$\n(\\nabla^2 u)_{i,j} = \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j}\n$$\n代入推导出的表达式：\n$$\n(\\nabla^2 u)_{i,j} = \\left[ \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} \\right] + \\left[ \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} \\right] + T_{i,j}\n$$\n其中 $T_{i,j}$ 是局部截断误差，由下式给出：\n$$\nT_{i,j} = - \\frac{h^2}{12} \\left[ \\left(\\frac{\\partial^4 u}{\\partial x^4}\\right)_{i,j} + \\left(\\frac{\\partial^4 u}{\\partial y^4}\\right)_{i,j} \\right] + O(h^4)\n$$\n由于误差主项与 $h^2$ 成正比，因此得到的格式是二阶精度的。\n\n通过舍去截断误差项，我们得到作用于网格函数 $u_{i,j}$ 的离散拉普拉斯算子，记为 $\\Delta_h$：\n$$\n(\\nabla^2 u)_{i,j} \\approx \\Delta_h u_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2}\n$$\n该表达式是拉普拉斯算子的五点有限差分格式，因为它涉及中心节点 $(i,j)$ 及其四个面相邻的邻居：$(i+1,j)$、$(i-1,j)$、$(i,j+1)$ 和 $(i,j-1)$。\n\n最后，为了推导泊松形式 $-\\nabla^{2} u = f$ 的离散内部节点方程，我们将连续算子和函数替换为它们在节点 $(x_i, y_j)$ 处的离散对应项：\n$$\n- (\\nabla^2 u)_{i,j} = f(x_i, y_j)\n$$\n代入离散拉普拉斯算子 $\\Delta_h u_{i,j}$ 并令 $f_{i,j}=f(x_i,y_j)$，得到离散方程：\n$$\n- \\left( \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} \\right) = f_{i,j}\n$$\n这是内部节点的离散方程。所要求的最终答案是离散拉普拉斯算子 $\\Delta_h u_{i,j}$ 本身的表达式。", "answer": "$$\n\\boxed{\\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2}}\n$$", "id": "3310233"}, {"introduction": "从理论推导到实际应用是关键的一步。在推导出数值格式后，我们需要验证其在解决实际问题时的性能。本练习 [@problem_id:3453785] 将使用五点差分格式求解泊松方程，并通过网格加密研究来验证其全局二阶收敛精度，这是一种被称为“人造解法”的计算科学核心验证技术。", "problem": "设计并实现一个针对单位正方形上标量泊松问题的加密研究，以验证基于二维拉普拉斯算子五点模板的有限差分格式的二阶收敛性。问题域为 $\\Omega = (0,1)\\times(0,1)$。考虑边界值问题 $- \\Delta u = f$（在 $\\Omega$ 上），其狄利克雷边界条件为 $u|_{\\partial \\Omega} = g$，其中 $g$ 由一个光滑的人工精确解 $u$ 一致地选取。你的任务是：构建并求解由均匀网格上的二阶中心差分产生的离散线性系统，计算一系列网格间距 $h$ 下的离散 $L^2$ 误差，并估计观测到的收敛阶。\n\n从以下基本依据出发：\n- 拉普拉斯算子的定义 $\\Delta u = \\partial^2 u/\\partial x^2 + \\partial^2 u/\\partial y^2$。\n- 通过网格点周围的泰勒展开构造的一维二阶导数的二阶中心差分近似。\n- 均匀网格上间距为 $h$ 的离散 $L^2$ 范数，其定义为 $\\|e_h\\|_{L^2_h} = \\left(h^2 \\sum_{i,j} |e_{i,j}|^2\\right)^{1/2}$，其中误差场 $e_{i,j}$ 在内部网格点上采样。\n\n在推导离散算子时，你不能使用任何预先给出的模板公式；必须从泰勒展开开始，逐维组合一维近似来推导五点模板。\n\n为每个加密级别构建一个均匀的笛卡尔网格，每个方向有 $n$ 个内部点，间距为 $h = 1/(n+1)$。组装对应于离散算子 $- \\Delta$ 的线性系统，并通过将边界值并入右端项来施加狄利克雷边界条件。使用任何稳健的直接线性求解器求解该线性系统以得到内部未知数。\n\n将网格间距为 $h$ 时的离散 $L^2$ 误差定义为\n$$\nE(h) = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\right)^{1/2},\n$$\n其中 $x_i = i h$，$y_j = j h$，$u_h$ 是定义在内部节点上的数值解。对于连续的网格间距 $h$ 和 $h/2$，将观测阶定义为\n$$\np(h \\to h/2) = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)}.\n$$\n\n为下面测试套件中列出的每个人工精确解 $u$ 实现一个加密研究，使用内部网格尺寸序列 $\\{n\\} = \\{7, 15, 31, 63\\}$，这对应于间距 $h \\in \\{1/8, 1/16, 1/32, 1/64\\}$。对于每个 $u$，计算三个加密步骤的误差序列 $\\{E(h)\\}$ 和观测阶序列 $\\{p(h \\to h/2)\\}$。对于每个 $u$，报告基于两个最密层级（即 $h=1/32$ 和 $h=1/64$ 之间）的观测阶，并报告一个布尔值，指示所有三个观测阶是否都位于容差区间 $[1.8, 2.2]$ 内。\n\n测试套件：\n- 情况 $\\mathrm{A}$（零边界数据）：$u(x,y) = \\sin(2\\pi x)\\,\\sin(3\\pi y)$，因此 $f(x,y) = -\\Delta u(x,y) = \\left((2\\pi)^2 + (3\\pi)^2\\right) \\sin(2\\pi x)\\,\\sin(3\\pi y)$ 且 $g$ 是 $u$ 在 $\\partial \\Omega$ 上的限制。\n- 情况 $\\mathrm{B}$（非零边界数据，指数型）：$u(x,y) = e^{x+y}$，因此 $f(x,y) = -\\Delta u(x,y) = -2 e^{x+y}$ 且 $g$ 是 $u$ 在 $\\partial \\Omega$ 上的限制。\n- 情况 $\\mathrm{C}$（多项式，具有混合边界行为）：$u(x,y) = x^2 y^2$，因此 $f(x,y) = -\\Delta u(x,y) = -2(x^2 + y^2)$ 且 $g$ 是 $u$ 在 $\\partial \\Omega$ 上的限制。\n\n你的程序应：\n- 对这三种情况中的每一种，在指定的网格序列上执行加密研究，计算误差序列 $\\{E(h)\\}$，计算观测阶 $\\{p(h \\to h/2)\\}$，从最后一次加密步骤中提取最密层级的观测阶 $p_\\mathrm{fine}$，并检查所有三个观测阶是否都位于 $[1.8, 2.2]$ 内。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含：三个最密层级的观测阶（每种情况一个，为浮点数），后跟三个布尔值（每种情况一个），指示该情况的所有观测阶是否都在 $[1.8, 2.2]$ 内。例如，输出必须采用格式\n$[p_{\\mathrm{A}}, p_{\\mathrm{B}}, p_{\\mathrm{C}}, b_{\\mathrm{A}}, b_{\\mathrm{B}}, b_{\\mathrm{C}}]$，\n其中每个 $p_{\\mathrm{case}}$ 是一个浮点数，每个 $b_{\\mathrm{case}}$ 是 `True` 或 `False`。\n\n所有量都是无量纲的；不需要物理单位。三角函数中出现的角度，单位为弧度。程序必须完全自包含，不接受任何输入，并严格按照指定格式打印一行。", "solution": "该问题要求设计并实现一个数值验证研究，该研究针对应用于单位正方形域 $\\Omega = (0,1) \\times (0,1)$ 上带狄利克雷边界条件 $u|_{\\partial\\Omega} = g$ 的二维泊松方程 $-\\Delta u = f$ 的二阶有限差分格式。任务的核心是推导离散算子，构建并求解由此产生的线性系统，并执行加密研究以确认该方法的理论二阶收敛性。这是通过人工解方法来完成的。\n\n首先，我们推导拉普拉斯算子 $\\Delta = \\partial^2/\\partial x^2 + \\partial^2/\\partial y^2$ 所需的有限差分近似。这是通过使用泰勒级数展开的第一性原理完成的。对于一个足够光滑的一维函数 $u(x)$，在点 $x_i$ 附近步长为 $h$ 的展开式为：\n$$\nu(x_i + h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) + O(h^5)\n$$\n$$\nu(x_i - h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + \\frac{h^4}{24} u^{(4)}(x_i) - O(h^5)\n$$\n将这两个表达式相加可以消去奇数阶导数项，得到：\n$$\nu(x_i + h) + u(x_i - h) = 2u(x_i) + h^2 u''(x_i) + \\frac{h^4}{12} u^{(4)}(x_i) + O(h^6)\n$$\n通过重新整理此方程以分离出二阶导数，我们得到：\n$$\nu''(x_i) = \\frac{u(x_i - h) - 2u(x_i) + u(x_i + h)}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + O(h^4)\n$$\n这就给出了二阶导数的标准二阶中心差分近似，其主截断误差项为 $O(h^2)$。\n\n为了离散化二维拉普拉斯算子，我们在域上建立一个均匀的笛卡尔网格，网格点为 $(x_i, y_j) = (ih, jh)$，其中 $h=1/(n+1)$ 是两个方向上的网格间距，内部点的索引为 $i,j \\in \\{1, 2, \\dots, n\\}$。令 $u_{i,j} = u(x_i, y_j)$。我们在一个通用内部点 $(x_i, y_j)$ 处沿每个坐标轴应用一维近似：\n$$\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{(x_i, y_j)} \\approx \\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h^2}\n$$\n$$\n\\left.\\frac{\\partial^2 u}{\\partial y^2}\\right|_{(x_i, y_j)} \\approx \\frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h^2}\n$$\n拉普拉斯算子是这些偏导数的和。将这些近似值相加，得到众所周知的拉普拉斯算子五点模板：\n$$\n(\\Delta u)_{i,j} \\approx \\frac{u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} - 4u_{i,j}}{h^2}\n$$\n只要解 $u$ 具有足够高阶的连续导数，此近似的局部截断误差为 $O(h^2)$。\n\n将此离散算子代入泊松方程 $-\\Delta u = f$，我们为每个内部网格点 $(x_i, y_j)$ 获得一个线性方程：\n$$\n-\\frac{u_{i-1,j} + u_{i+1,j} + u_{i,j-1} + u_{i,j+1} - 4u_{i,j}}{h^2} \\approx f(x_i, y_j)\n$$\n乘以 $-h^2$ 并重新整理，得到离散方程：\n$$\n4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} \\approx h^2 f_{i,j}\n$$\n这组针对 $N$ 个未知内部值 $u_{i,j}$ 的 $N=n^2$ 个方程构成一个线性系统 $A \\mathbf{u}_h = \\mathbf{b}$。为了显式地构建该系统，我们将二维的未知数网格 $(u_{i,j})$ 映射到一个长度为 $N$ 的一维向量 $\\mathbf{u}_h$。一个标准的选择是行主序，其中网格点 $(i,j)$ 映射到向量索引 $k = (j-1)n + (i-1)$，对于 $i,j \\in \\{1,\\dots,n\\}$。\n\n矩阵 $A$ 代表离散的负拉普拉斯算子。点 $(i,j)$ 处的方程（矩阵的第 $k$ 行）涉及 $u_{i,j}$ 及其四个邻居。这种结构导致一个具有五条非零对角线的 $N \\times N$ 矩阵 $A$：\n- 主对角线（模板中心，系数 $4$）位于偏移量 $0$ 处。\n- 次对角线和超对角线（x-邻居，系数 $-1$）位于偏移量 $\\pm 1$ 处。\n- 远次对角线和远超对角线（y-邻居，系数 $-1$）位于偏移量 $\\pm n$ 处。\n矩阵 $A$ 是稀疏、对称且正定的。\n\n右端向量 $\\mathbf{b}$ 包含了源项 $f$ 和狄利克雷边界条件 $g$。对于以 $(x_i, y_j)$ 为中心的方程，$\\mathbf{b}$ 的相应分量初始为 $h^2 f(x_i, y_j)$。如果模板中的四个邻居中有任何一个位于边界 $\\partial\\Omega$ 上（例如，当 $i=1$ 时的 $u_{i-1,j}$），其值可从边界函数 $g$ 得知（例如，$u_{0,j} = g(0, y_j)$）。这个已知值被移到方程的右侧。对应于点 $(x_i, y_j)$ 的右端项分量的完整表达式是：\n$$\nb_{i,j} = h^2 f(x_i, y_j) + \\delta_{i,1}g(0, y_j) + \\delta_{i,n}g(1, y_j) + \\delta_{j,1}g(x_i, 0) + \\delta_{j,n}g(x_i, 1)\n$$\n其中 $\\delta$ 是克罗内克符号。向量 $\\mathbf{b}$ 是通过将 $b_{i,j}$ 值的网格展平来组装的，保持与 $\\mathbf{u}_h$ 使用的相同的行主序。\n\n加密研究通过求解系统 $A\\mathbf{u}_h=\\mathbf{b}$ 来进行，针对一系列递减的网格间距 $h$，对应于给定的内部网格尺寸 $n \\in \\{7, 15, 31, 63\\}$。对于每个解 $u_h$，我们计算离散 $L^2$ 误差：\n$$\nE(h) = \\left(h^2 \\sum_{i=1}^{n}\\sum_{j=1}^{n}\\left(u_h(x_i,y_j) - u(x_i,y_j)\\right)^2\\right)^{1/2}\n$$\n然后使用以下公式在两次连续加密（例如，间距为 $h$ 和 $h/2$）之间估计观测到的收敛阶 $p$：\n$$\np(h \\to h/2) = \\frac{\\log\\left(E(h)/E(h/2)\\right)}{\\log(2)}\n$$\n对于一个二阶精确的格式，我们预计当 $h \\to 0$ 时，$p$ 将趋近于 $2$。该实现将为每个加密步骤计算此阶数，并检查结果是否落在理论值的指定容差范围内。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\nimport math\n\n# --- Problem Definition ---\n\n# The scalar Poisson problem is -Delta u = f on Omega = (0,1)x(0,1)\n# with Dirichlet boundary conditions u|dOmega = g.\n\n# --- Numerical Scheme ---\n\n# The implementation uses a second-order central finite difference scheme\n# on a uniform Cartesian grid with n interior points per direction.\n# This results in the 5-point stencil for the negative Laplacian. The\n# discrete equation at an interior node (i,j) is:\n#   4*u_ij - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} = h^2 * f_ij\n#\n# This leads to a linear system A*u_h = b, where A is a sparse,\n# symmetric positive-definite matrix. Boundary conditions are incorporated\n# into the right-hand side vector b.\n\ndef run_refinement_study(u_exact, f_source, n_list):\n    \"\"\"\n    Performs a grid refinement study for a given manufactured solution.\n\n    Args:\n        u_exact (callable): The exact solution u(x, y).\n        f_source (callable): The source term f(x, y) = -Delta u.\n        n_list (list of int): A sequence of interior grid sizes.\n\n    Returns:\n        tuple: A tuple containing:\n            - float: The observed order of convergence on the finest grid.\n            - bool: True if all observed orders are within [1.8, 2.2].\n    \"\"\"\n    errors = []\n    g_boundary = u_exact\n\n    for n in n_list:\n        # Total number of interior unknowns\n        N = n * n\n        # Grid spacing\n        h = 1.0 / (n + 1)\n\n        # 1. Construct the sparse matrix A for the negative Laplacian operator.\n        # The matrix has 5 diagonals based on the 5-point stencil.\n        # We use row-major ordering for mapping (i,j) - k.\n        \n        # Main diagonal (coefficient 4)\n        d0 = np.ones(N) * 4\n        \n        # Off-diagonals for x-derivatives (coefficient -1)\n        d1 = np.ones(N - 1) * -1\n        # Set stencil connections at row boundaries to zero.\n        d1[n - 1::n] = 0\n        \n        # Off-diagonals for y-derivatives (coefficient -1)\n        dn = np.ones(N - n) * -1\n        \n        A = diags([d0, d1, d1, dn, dn], [0, 1, -1, n, -n], format='csr')\n\n        # 2. Construct the right-hand side vector b.\n        x_coords = np.linspace(h, 1 - h, n)\n        y_coords = np.linspace(h, 1 - h, n)\n        xx, yy = np.meshgrid(x_coords, y_coords, indexing='ij')\n        \n        # Start with the source term f\n        b_grid = h**2 * f_source(xx, yy)\n        \n        # Add contributions from Dirichlet boundary conditions\n        b_grid[:, 0] += g_boundary(0.0, y_coords)      # Left boundary (i=1)\n        b_grid[:, -1] += g_boundary(1.0, y_coords)     # Right boundary (i=n)\n        b_grid[0, :] += g_boundary(x_coords, 0.0)      # Bottom boundary (j=1)\n        b_grid[-1, :] += g_boundary(x_coords, 1.0)     # Top boundary (j=n)\n        \n        b_vec = b_grid.T.flatten()\n\n        # 3. Solve the linear system A * u_h = b\n        u_h_vec = spsolve(A, b_vec)\n        u_h_grid_flat_T = u_h_vec.reshape((n, n))\n        u_h_grid = u_h_grid_flat_T.T\n\n        # 4. Compute the discrete L2 error\n        u_exact_grid = u_exact(xx, yy)\n        error_grid = u_h_grid - u_exact_grid\n        \n        # E(h) = (h^2 * sum(e_ij^2))^(1/2) = h * ||e_ij||_F\n        l2_error = h * np.linalg.norm(error_grid)\n        errors.append(l2_error)\n\n    # 5. Compute the observed orders of convergence\n    orders = []\n    for i in range(len(errors) - 1):\n        # p = log(E(h)/E(h/2)) / log(2)\n        order = math.log(errors[i] / errors[i+1]) / math.log(2)\n        orders.append(order)\n        \n    finest_order = orders[-1]\n    all_in_tolerance = all(1.8 = o = 2.2 for o in orders)\n    \n    return finest_order, all_in_tolerance\n\n\ndef solve():\n    \"\"\"\n    Main driver function to run the test cases and print the final result.\n    \"\"\"\n    # Define the sequence of interior grid sizes for the refinement study\n    n_list = [7, 15, 31, 63]\n\n    # Test Case A: Smooth trigonometric solution, zero on boundary\n    u_A = lambda x, y: np.sin(2 * np.pi * x) * np.sin(3 * np.pi * y)\n    f_A = lambda x, y: ((2 * np.pi)**2 + (3 * np.pi)**2) * u_A(x, y)\n\n    # Test Case B: Exponential solution, non-zero on boundary\n    u_B = lambda x, y: np.exp(x + y)\n    f_B = lambda x, y: -2.0 * np.exp(x + y)\n    \n    # Test Case C: Polynomial solution\n    u_C = lambda x, y: x**2 * y**2\n    f_C = lambda x, y: -2.0 * (x**2 + y**2)\n\n    test_cases = [\n        {\"u\": u_A, \"f\": f_A},\n        {\"u\": u_B, \"f\": f_B},\n        {\"u\": u_C, \"f\": f_C},\n    ]\n\n    # Store results for final output\n    p_results = []\n    b_results = []\n\n    for case in test_cases:\n        p_fine, b_tol = run_refinement_study(case[\"u\"], case[\"f\"], n_list)\n        p_results.append(p_fine)\n        b_results.append(b_tol)\n    \n    final_output_list = p_results + b_results\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, final_output_list))}]\")\n\nsolve()\n```", "id": "3453785"}, {"introduction": "理论的优雅常常依赖于理想化的假设，但现实世界的问题并不总是“光滑”的。本练习 [@problem_id:3230782] 旨在探索当函数不满足光滑性假设（例如，存在跳跃或尖点）时，五点差分格式的行为。通过分析这些情况，您将对该方法的适用范围和局限性建立更深刻、更具批判性的理解。", "problem": "你将编写一个完整、可运行的程序，研究当底层标量场 $u(x,y)$ 存在不连续性或尖锐扭折时，五点拉普拉斯模板在均匀笛卡尔网格上的数值行为，并将其与光滑基线情况进行对比。该分析必须基于拉普拉斯算子的定义以及在均匀网格上使用二阶中心差分。\n\n基本原理：连续拉普拉斯算子定义为 $\\Delta u = u_{xx} + u_{yy}$。在覆盖矩形域的均匀网格上，二阶中心差分使用相邻网格点的值来近似二阶偏导数。使用这些近似来构造作用于 $u$ 的网格样本的离散算子 $\\Delta_h$。\n\n域和网格：\n- 考虑方形域 $[0,1] \\times [0,1]$。\n- 使用一个包含 $N \\times N$ 个节点的均匀网格，网格间距为 $h = \\frac{1}{N-1}$。\n- 设 $(x_i, y_j)$ 表示网格节点的坐标，其中对于整数 $i,j \\in \\{0,1,\\dots,N-1\\}$，$x_i = i h$ 且 $y_j = j h$。\n- 应用从 $u(x,y)$ 的解析定义中获取的狄利克雷边界值；也就是说，边界网格节点上的 $u$ 值必须根据与内部节点相同的函数进行赋值。\n\n离散算子：\n- 使用均匀网格上 $u_{xx}$ 和 $u_{yy}$ 的二阶中心差分近似，在内部网格节点上构造离散拉普拉斯算子 $\\Delta_h$。不要使用问题陈述中此基本原理之外的任何公式；在你的解法中推导出显式模板。\n\n要计算的指标：\n- 对每个测试用例，计算内部网格节点上的离散拉普拉斯算子 $\\Delta_h u$。然后计算内部节点上的最大绝对值，记为 $\\max_{\\text{interior}} |\\Delta_h u|$。\n- 根据测试套件中指定的 $u$ 中存在的特征类型，对此最大值进行归一化。\n\n测试套件：\n1. 不连续性情况：$u(x,y) = 1$（如果 $x  0.5$）否则 $u(x,y) = 0$，在 $N = 129$ 的网格上。计算内部最大值 $M_{\\text{step}} := h^2 \\cdot \\max_{\\text{interior}} |\\Delta_h u|$。此归一化用于评估在跳跃间断附近预期的 $O(h^{-2})$ 增长。\n2. 尖锐扭折情况：$u(x,y) = |x - 0.5|$，在 $N = 129$ 的网格上。计算内部最大值 $M_{\\text{kink}} := h \\cdot \\max_{\\text{interior}} |\\Delta_h u|$。此归一化用于评估在斜率不连续点附近预期的 $O(h^{-1})$ 增长。\n3. 光滑基线与收敛性：$u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，其解析拉普拉斯算子为 $\\Delta u(x,y) = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$。使用两个网格：$N_1 = 33$ 和 $N_2 = 65$。对于每个 $N$，计算无穷范数误差\n   $$ E_\\infty(h) := \\max_{\\text{interior}} \\left| \\Delta_h u - \\Delta u \\right|. $$\n   然后计算观测到的精度阶\n   $$ p := \\frac{\\log\\left( E_\\infty(h_1) / E_\\infty(h_2) \\right)}{\\log\\left( h_1 / h_2 \\right)}, $$\n   其中对于 $k \\in \\{1,2\\}$，$h_k = \\frac{1}{N_k - 1}$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表：\n  - 列表必须按 $[M_{\\text{step}}, M_{\\text{kink}}, E_\\infty(h_1), E_\\infty(h_2), p]$ 的顺序排列。\n- 所有输出必须是纯浮点数。此问题不涉及单位。\n\n科学真实性与基本原理：\n- 不连续性和扭折是科学计算中的常见特征，所要求的归一化旨在揭示离散算子在非光滑特征附近的尺度不变行为。光滑基线情况通过经验观测阶 $p$ 验证了五点拉普拉斯模板的二阶精度。\n\n你的程序不得要求任何用户输入，并且必须遵守指定的执行环境。它应完全按照上述规定实现计算，并以要求的格式打印单行最终结果。", "solution": "该问题要求对均匀笛卡尔网格上的五点拉普拉斯模板进行数值研究。此任务的核心在于推导离散算子，然后将其应用于三个不同的标量场 $u(x,y)$：一个具有跳跃间断，一个具有尖锐扭折（导数不连续），以及一个光滑场。这使得能够对模板的行为进行全面分析，从其在奇点处不收敛到对光滑函数的二阶精度。\n\n首先，我们建立离散拉普拉斯算子 $\\Delta_h$。连续拉普拉斯算子由 $\\Delta u = u_{xx} + u_{yy}$ 给出，即 $u$ 关于笛卡尔坐标的二阶偏导数之和。在间距为 $h$ 的均匀网格上，我们可以使用二阶中心差分来近似这些导数。对于函数 $f(x)$，其二阶导数 $f''(x)$ 可近似为：\n$$\nf''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2}\n$$\n将此公式应用于网格节点 $(x_i, y_j)$ 处的偏导数 $u_{xx}$ 和 $u_{yy}$，其中 $x_i=ih$ 且 $y_j=jh$，我们得到：\n$$\nu_{xx}(x_i, y_j) \\approx \\frac{u(x_{i+1}, y_j) - 2u(x_i, y_j) + u(x_{i-1}, y_j)}{h^2} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2}\n$$\n$$\nu_{yy}(x_i, y_j) \\approx \\frac{u(x_i, y_{j+1}) - 2u(x_i, y_j) + u(x_i, y_{j-1})}{h^2} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2}\n$$\n这里，我们使用紧凑记法 $u_{i,j} = u(x_i, y_j)$。将这两个表达式相加，得到作用于网格函数值 $u_{i,j}$ 的离散拉普拉斯算子 $\\Delta_h$：\n$$\n(\\Delta_h u)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2}\n$$\n该表达式即为五点拉普拉斯模板。它应用于网格的所有内部节点，即对于 $i,j \\in \\{1, 2, \\dots, N-2\\}$，使用在整个 $N \\times N$ 网格上定义的函数值。\n\n现在我们开始分析三个指定的测试用例。\n\n**测试用例1：跳跃间断**\n标量场定义为 $u(x,y) = 1$（如果 $x  0.5$）否则 $u(x,y) = 0$。网格有 $N = 129$ 个节点，网格间距为 $h = 1/(129-1) = 1/128$。不连续点发生在 $x = 0.5$，该位置与 $x_{64} = 64h = 64/128 = 0.5$ 的网格线重合。由于严格不等式，对于任何 $j$，当 $i \\le 64$ 时，网格值为 $u_{i,j} = 0$；当 $i  64$ 时，网格值为 $u_{i,j} = 1$。\n在函数不可微的点，用于推导模板的泰勒级数展开是无效的。模板的输出并不近似于（未定义的）连续拉普拉斯算子。相反，其量级取决于网格间距。让我们在列 $i=64$ 上的一个内部节点处应用该模板，此处 $u_{64,j}=0$。沿 $x$ 方向的相邻值为 $u_{63,j}=0$ 和 $u_{65,j}=1$。由于 $u$ 关于 $y$ 是常数，所以 $u_{64,j+1}=u_{64,j-1}=0$。\n$$\n(\\Delta_h u)_{64,j} = \\frac{u_{65,j} + u_{63,j} + u_{64,j+1} + u_{64,j-1} - 4u_{64,j}}{h^2} = \\frac{1 + 0 + 0 + 0 - 4(0)}{h^2} = \\frac{1}{h^2}\n$$\n对列 $i=65$ 进行类似计算，得到 $-1/h^2$。因此，最大绝对值为 $\\max_{\\text{interior}}|\\Delta_h u| = 1/h^2$。问题要求计算 $M_{\\text{step}} = h^2 \\cdot \\max_{\\text{interior}}|\\Delta_h u|$，其计算结果为 $h^2 \\cdot (1/h^2) = 1$。这种 $O(h^{-2})$ 的标度关系是模板对跳跃间断响应的典型特征。\n\n**测试用例2：尖锐扭折**\n场为 $u(x,y) = |x - 0.5|$，该函数是连续的，但在 $x=0.5$ 处的一阶导数不连续。网格同样是 $N=129$，$h=1/128$。网格函数为 $u_{i,j} = |x_i - 0.5| = |ih - 64h| = |i-64|h$。\n在扭折处，即列 $i=64$ 上的内部节点应用模板。此处 $u_{64,j} = 0$。相邻点为 $u_{63,j}=h$ 和 $u_{65,j}=h$。函数在 $y$ 方向上是常数，所以 $u_{64,j+1}=u_{64,j-1}=0$。\n$$\n(\\Delta_h u)_{64,j} = \\frac{u_{65,j} + u_{63,j} + u_{64,j+1} + u_{64,j-1} - 4u_{64,j}}{h^2} = \\frac{h + h + 0 + 0 - 4(0)}{h^2} = \\frac{2h}{h^2} = \\frac{2}{h}\n$$\n远离扭折处，$u(x,y)$ 在 $x$ 方向上是线性的，其二阶中心差分恰好为零。因此，离散拉普拉斯算子的最大量级出现在扭折处，其值为 $2/h$。所要求的量是 $M_{\\text{kink}} = h \\cdot \\max_{\\text{interior}}|\\Delta_h u| = h \\cdot (2/h) = 2$。这种 $O(h^{-1})$ 的标度关系是模板对斜率不连续响应的典型特征。\n\n**测试用例3：光滑基线与收敛性**\n场为 $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，这是一个无限光滑的函数。其解析拉普拉斯算子为 $\\Delta u = -2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$。对于光滑函数，当 $h \\to 0$ 时，离散拉普拉斯算子 $\\Delta_h u$ 收敛于连续拉普拉斯算子 $\\Delta u$。对于五点模板，其差值，即截断误差，为 $h^2$ 阶，即 $|\\Delta_h u - \\Delta u| \\approx C h^2$，其中常数 $C$ 取决于 $u$ 的高阶导数。\n为验证这一点，我们在两个网格上计算最大误差 $E_\\infty(h) = \\max_{\\text{interior}} |\\Delta_h u - \\Delta u|$：一个网格为 $N_1 = 33$ ($h_1 = 1/32$)，另一个为 $N_2 = 65$ ($h_2 = 1/64$)。观测到的精度阶 $p$ 由以下关系确定：\n$$\n\\frac{E_\\infty(h_1)}{E_\\infty(h_2)} \\approx \\left(\\frac{h_1}{h_2}\\right)^p\n$$\n解出 $p$ 可得公式：\n$$\np = \\frac{\\log\\left( E_\\infty(h_1) / E_\\infty(h_2) \\right)}{\\log\\left( h_1 / h_2 \\right)}\n$$\n鉴于该模板是二阶精度的， $p$ 的结果应非常接近于 $2$。程序将计算 $E_\\infty(h_1)$、$E_\\infty(h_2)$ 和 $p$ 的数值。\n总体流程包括：首先为每种情况设置完整的 $N \\times N$ 网格值 $u_{i,j}$，然后在 $(N-2) \\times (N-2)$ 内部网格上计算 $(\\Delta_h u)_{i,j}$，最后根据这些结果计算指定的指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef apply_laplacian_5pt(U, h):\n    \"\"\"\n    Applies the 5-point Laplacian stencil to a 2D grid.\n\n    Args:\n        U (np.ndarray): An N x N grid of function values.\n        h (float): The grid spacing.\n\n    Returns:\n        np.ndarray: The discrete Laplacian on the (N-2) x (N-2) interior grid.\n    \"\"\"\n    # Slicing based on matrix indices: U[j, i] corresponds to u(x_i, y_j).\n    # The stencil is (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}) / h^2.\n    lap_U = (U[1:-1, 2:]      # East neighbor u_{i+1,j}\n             + U[1:-1, :-2]   # West neighbor u_{i-1,j}\n             + U[2:, 1:-1]    # North neighbor u_{i,j+1}\n             + U[:-2, 1:-1]   # South neighbor u_{i,j-1}\n             - 4 * U[1:-1, 1:-1]) / (h**2) # Central point u_{i,j}\n    return lap_U\n\ndef solve():\n    \"\"\"\n    Runs the full analysis for the three test cases and prints the final result.\n    \"\"\"\n    # Test Case 1: Discontinuity\n    N_step = 129\n    h_step = 1.0 / (N_step - 1)\n    x_step = np.arange(N_step) * h_step\n    u_1d_step = np.where(x_step > 0.5, 1.0, 0.0)\n    U_step = np.tile(u_1d_step, (N_step, 1))\n    lap_U_step_interior = apply_laplacian_5pt(U_step, h_step)\n    max_abs_lap_step = np.max(np.abs(lap_U_step_interior))\n    M_step = h_step**2 * max_abs_lap_step\n\n    # Test Case 2: Sharp Kink\n    N_kink = 129\n    h_kink = 1.0 / (N_kink - 1)\n    x_kink = np.arange(N_kink) * h_kink\n    u_1d_kink = np.abs(x_kink - 0.5)\n    U_kink = np.tile(u_1d_kink, (N_kink, 1))\n    lap_U_kink_interior = apply_laplacian_5pt(U_kink, h_kink)\n    max_abs_lap_kink = np.max(np.abs(lap_U_kink_interior))\n    M_kink = h_kink * max_abs_lap_kink\n\n    # Test Case 3: Smooth Baseline and Convergence\n    Ns_smooth = [33, 65]\n    errors = []\n    hs = []\n\n    for N in Ns_smooth:\n        h = 1.0 / (N - 1)\n        hs.append(h)\n        \n        # Create grid coordinates and function grid\n        x = np.arange(N) * h\n        y = np.arange(N) * h\n        X, Y = np.meshgrid(x, y, indexing='ij')\n        \n        U_smooth = np.sin(np.pi * X.T) * np.sin(np.pi * Y.T)\n        \n        # Apply discrete Laplacian\n        lap_U_discrete_interior = apply_laplacian_5pt(U_smooth, h)\n        \n        # Compute analytic Laplacian on the interior grid\n        interior_X = X[1:-1, 1:-1]\n        interior_Y = Y[1:-1, 1:-1]\n        lap_U_analytic_interior = -2.0 * np.pi**2 * np.sin(np.pi * interior_X.T) * np.sin(np.pi * interior_Y.T)\n\n        # Compute the infinity-norm error\n        error = np.max(np.abs(lap_U_discrete_interior - lap_U_analytic_interior))\n        errors.append(error)\n        \n    E_inf_h1, E_inf_h2 = errors\n    h1, h2 = hs\n    \n    # Compute the observed order of accuracy\n    p = np.log(E_inf_h1 / E_inf_h2) / np.log(h1 / h2)\n    \n    # Assemble and print the final results\n    results = [M_step, M_kink, E_inf_h1, E_inf_h2, p]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3230782"}]}