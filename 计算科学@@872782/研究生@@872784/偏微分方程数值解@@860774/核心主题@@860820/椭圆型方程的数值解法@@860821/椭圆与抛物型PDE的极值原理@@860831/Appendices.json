{"hands_on_practices": [{"introduction": "对流扩散方程是科学与工程中的一个基本模型，用于描述粒子或能量通过整体运动和随机扩散进行传输的过程。虽然连续问题遵循极值原理，但其数值离散化却可能出人意料地棘手。第一个练习 [@problem_id:3419376] 展示了一个经典的挑战：在对流占主导地位的情况下，中心差分格式会失效，导致非物理振荡。通过将其与稳定的迎风格式进行比较，您将亲手洞察数值黏性的重要性以及维持离散极值原理所需的条件。", "problem": "考虑单位区间上具有常数系数和狄利克雷边界条件的一维稳态对流扩散边界值问题：\n求在 $(0,1)$ 上的函数 $u(x)$，满足\n$- \\epsilon \\, u''(x) + a \\, u'(x) = 0$ for $x \\in (0,1)$，\n边界条件为 $u(0) = 0$ 和 $u(1) = 1$，其中 $\\epsilon > 0$ 是扩散系数，$a \\in \\mathbb{R}$ 是均匀对流速度。对于此连续、一致椭圆算子，连续极值原理成立：$u$ 的最大值和最小值出现在边界上，因此对于所有 $x \\in [0,1]$，都有 $u(x) \\in [0,1]$。\n\n您的任务是通过数值离散化和计算，证明对流项的中心差分格式在高佩克莱数时会违反离散极值原理，而迎风格式可以恢复该原理。\n\n从基本的数值定义出发，按以下步骤进行：\n- 使用一个包含 $n$ 个内部点的均匀网格。设网格尺寸为 $h = 1/(n+1)$，网格节点为 $x_i = i h$，其中 $i=0,1,\\dots,n+1$。未知量为 $u_i \\approx u(x_i)$，$i=1,\\dots,n$，而 $u_0 = 0$ 和 $u_{n+1} = 1$ 由边界值固定。\n- 为内部方程实现两种离散算子：\n  1. 一种中心格式，它对 $u''$ 使用标准的二阶中心差分，对 $u'$ 使用中心一阶差分。\n  2. 一种迎风格式，它对 $u''$ 使用中心差分，对 $u'$ 使用一阶迎风差分，并根据 $a$ 的符号切换方向。\n- 对内部未知数 $u_1,\\dots,u_n$ 组装相应的线性系统（使用给定的狄利克雷数据），求解它们，并重构包括边界在内的完整网格解。\n- 为此齐次源问题（右侧等于 $0$）定义一个离散极值原理检查：离散解必须对所有网格节点 $i=0,1,\\dots,n+1$ 满足 $u_i \\in [0,1]$。如果 $\\min_i u_i  0$ 或 $\\max_i u_i > 1$，则判定为违反。使用数值容差 $\\tau = 10^{-12}$，即如果 $\\min_i u_i  0 - \\tau$ 或 $\\max_i u_i > 1 + \\tau$，则视为违反条件。\n- 对于下面测试套件中的每个测试用例，计算两个布尔值：\n  - $b_{\\mathrm{cent}}$：中心格式是否违反了上述定义的离散极值原理。\n  - $b_{\\mathrm{up}}$：迎风格式是否违反了上述定义的离散极值原理。\n\n测试套件：\n- 用例 $1$：$\\epsilon = 10^{-3}$，$a = 2$，$n = 49$。\n- 用例 $2$：$\\epsilon = 10^{-1}$，$a = 1$，$n = 49$。\n- 用例 $3$：$\\epsilon = 10^{-2}$，$a = 1$，$n = 49$。\n- 用例 $4$：$\\epsilon = 10^{-3}$，$a = -2$，$n = 49$。\n- 用例 $5$：$\\epsilon = 5 \\cdot 10^{-3}$，$a = 20$，$n = 19$。\n\n注：\n- 局部单元佩克莱数是 $Pe = \\dfrac{|a| \\, h}{2 \\epsilon}$。当 $Pe$ 值较高时，预计中心格式会引发违例。\n- 无需报告物理单位；所有量均为无量纲。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个逗号分隔的配对列表，每个测试用例对应一个配对，且没有空格。每个配对必须是 $[b_{\\mathrm{cent}},b_{\\mathrm{up}}]$ 的形式，其中每个布尔值都打印为字面量 $True$ 或 $False$。\n- 例如，包含两个用例的一行输出应如下所示：$[[True,False],[False,False]]$。", "solution": "经评估，用户提供的问题是有效的。这是偏微分方程数值分析领域一个明确定义的任务，它基于既定的数学原理，没有任何矛盾、歧义或无效前提。其目标是通过数值方法证明对流扩散方程有限差分格式的一个已知性质。\n\n该问题要求求解在域 $x \\in (0,1)$ 上的一维稳态对流扩散方程：\n$$-\\epsilon u''(x) + a u'(x) = 0$$\n其狄利克雷边界条件为 $u(0)=0$ 和 $u(1)=1$。此处，$\\epsilon  0$ 是扩散系数，$a \\in \\mathbb{R}$ 是常数对流速度。已知此问题的连续解满足极值原理，即其值受边界数据的最小值和最大值所限制，即 $u(x) \\in [0,1]$。我们将研究该性质对于离散近似是否成立。\n\n我们使用一个包含 $n$ 个内部点的均匀网格来离散化域 $(0,1)$。网格节点为 $x_i = ih$，其中 $i=0, 1, \\dots, n+1$，网格尺寸为 $h = 1/(n+1)$。给定 $u_0=0$ 和 $u_{n+1}=1$。我们寻求内部节点 $i=1, \\dots, n$ 的近似解 $u_i \\approx u(x_i)$。\n\n在任意内部节点 $x_i$ 处，我们使用有限差分来近似导数。二阶导数由标准的二阶中心差分近似：\n$$u''(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$$\n将此代入控制方程，得到离散形式：\n$$-\\epsilon \\left(\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\\right) + a \\cdot (\\text{approx } u'(x_i)) = 0$$\n\n我们现在将分析一阶导数项的两种不同格式。\n\n**1. 中心差分格式**\n\n一阶导数的中心差分近似是二阶精度的：\n$$u'(x_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}$$\n将此代入离散方程并乘以 $h^2$ 可得：\n$$-\\epsilon(u_{i+1} - 2u_i + u_{i-1}) + a \\frac{h}{2}(u_{i+1} - u_{i-1}) = 0$$\n我们重排各项，将未知数 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 组合在一起：\n$$\\left(-\\epsilon - \\frac{ah}{2}\\right)u_{i-1} + (2\\epsilon)u_i + \\left(-\\epsilon + \\frac{ah}{2}\\right)u_{i+1} = 0$$\n此方程对每个内部节点 $i=1, \\dots, n$ 都成立。这为 $n$ 个未知数 $\\boldsymbol{u} = [u_1, u_2, \\dots, u_n]^T$ 构成了一个包含 $n$ 个线性方程的系统。该系统可以写为 $A\\boldsymbol{u} = \\boldsymbol{b}$。矩阵 $A$ 是一个 $n \\times n$ 的三对角矩阵，其第 $i$ 行的元素如下：\n\\begin{itemize}\n    \\item 次对角线 ($j = i-1$)：$A_{i, i-1} = -\\epsilon - \\frac{ah}{2}$\n    \\item 主对角线 ($j = i$)：$A_{i, i} = 2\\epsilon$\n    \\item 超对角线 ($j = i+1$)：$A_{i, i+1} = -\\epsilon + \\frac{ah}{2}$\n\\end{itemize}\n右侧向量 $\\boldsymbol{b}$ 是通过将涉及已知边界值的项移到右边形成的。\n对于 $i=1$：与 $u_0=0$ 相关的项消失。\n对于 $i=n$：涉及 $u_{n+1}=1$ 的项被移到右侧：\n$$A_{n, n-1} u_{n-1} + A_{n,n} u_n = -A_{n,n+1} u_{n+1} = -\\left(-\\epsilon + \\frac{ah}{2}\\right) \\cdot 1 = \\epsilon - \\frac{ah}{2}$$\n因此，$\\boldsymbol{b} = [0, 0, \\dots, 0, \\epsilon - ah/2]^T$。\n\n如果矩阵 $A$ 是一个M矩阵，则离散极值原理得到保证。一个充分条件是 $A$ 是对角占优的，其对角元素为正，非对角元素为非正。对角元素 $2\\epsilon$ 是正的。非对角元素必须为非正：\n$$-\\epsilon - \\frac{ah}{2} \\le 0 \\quad \\text{和} \\quad -\\epsilon + \\frac{ah}{2} \\le 0$$\n这可以简化为 $|ah| \\le 2\\epsilon$，或 $\\frac{|a|h}{2\\epsilon} \\le 1$。量 $Pe = \\frac{|a|h}{2\\epsilon}$ 是单元佩克莱数。如果 $Pe > 1$，其中一个非对角元素会变为正数，矩阵不再保证是M矩阵，可能会出现违反极值原理的伪振荡。\n\n**2. 迎风差分格式**\n\n迎风格式对对流项使用一阶单边差分，其方向根据对流速度 $a$ 的符号来选择。\n\n情况 1：$a \\ge 0$ (向右流动)\n我们使用后向差分：$u'(x_i) \\approx \\frac{u_i - u_{i-1}}{h}$。\n离散后的方程是：\n$$-\\epsilon \\left(\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\\right) + a \\left(\\frac{u_i - u_{i-1}}{h}\\right) = 0$$\n乘以 $h^2$ 并重排：\n$$(-\\epsilon - ah)u_{i-1} + (2\\epsilon + ah)u_i - \\epsilon u_{i+1} = 0$$\n矩阵元素为：$A_{i, i-1} = -\\epsilon - ah$，$A_{i, i} = 2\\epsilon + ah$，$A_{i, i+1} = -\\epsilon$。\n最后一个方程（$i=n$）的右侧变为 $b_n = -A_{n,n+1} u_{n+1} = -(-\\epsilon) \\cdot 1 = \\epsilon$。\n\n情况 2：$a  0$ (向左流动)\n我们使用前向差分：$u'(x_i) \\approx \\frac{u_{i+1} - u_i}{h}$。\n离散后的方程是：\n$$-\\epsilon \\left(\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\\right) + a \\left(\\frac{u_{i+1} - u_i}{h}\\right) = 0$$\n乘以 $h^2$ 并重排：\n$$-\\epsilon u_{i-1} + (2\\epsilon - ah)u_i + (-\\epsilon + ah)u_{i+1} = 0$$\n矩阵元素为：$A_{i, i-1} = -\\epsilon$，$A_{i, i} = 2\\epsilon - ah$，$A_{i, i+1} = -\\epsilon + ah$。\n最后一个方程（$i=n$）的右侧变为 $b_n = -A_{n,n+1} u_{n+1} = -(-\\epsilon + ah) \\cdot 1 = \\epsilon - ah$。\n\n在两种迎风情况下，对于任何 $\\epsilon > 0$ 和 $h > 0$，对角元素都是正的，而非对角元素都是非正的。该矩阵是对角占优的。因此，它是一个M矩阵，离散极值原理总是被满足，与佩克莱数无关。\n\n**数值验证**\n每个测试用例的步骤如下：\n1. 对于一组给定的参数 $(\\epsilon, a, n)$，计算网格尺寸 $h$。\n2. 对于中心格式和迎风格式，分别组装 $n \\times n$ 的三对角矩阵 $A$ 和 $n \\times 1$ 的右侧向量 $\\boldsymbol{b}$。\n3. 求解线性系统 $A\\boldsymbol{u} = \\boldsymbol{b}$，得到内部解向量 $\\boldsymbol{u}$。\n4. 通过前置 $u_0=0$ 和后置 $u_{n+1}=1$ 来构造完整解。\n5. 检查完整解是否违反极值原理：对于容差 $\\tau=10^{-12}$，检查是否有 $\\min(u)  0 - \\tau$ 或 $\\max(u) > 1 + \\tau$。\n6. 记录违例的布尔结果 $b_{\\mathrm{cent}}$ 和 $b_{\\mathrm{up}}$。\n\n对问题陈述中提供的每个测试用例重复此过程，以证明中心格式在高佩克莱数下的失效以及迎风格式的稳健性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef compute_solution_and_check_violation(epsilon, a, n, scheme, tau):\n    \"\"\"\n    Solves the 1D convection-diffusion equation and checks for max principle violation.\n\n    Args:\n        epsilon (float): Diffusion coefficient.\n        a (float): Convection speed.\n        n (int): Number of interior grid points.\n        scheme (str): 'centered' or 'upwind'.\n        tau (float): Numerical tolerance for violation check.\n\n    Returns:\n        bool: True if the maximum principle is violated, False otherwise.\n    \"\"\"\n    # Grid setup\n    h = 1.0 / (n + 1)\n    \n    # Boundary values\n    u0 = 0.0\n    u_np1 = 1.0\n    \n    # Initialize linear system\n    A = np.zeros((n, n))\n    b = np.zeros(n)\n    \n    # Assemble matrix A and vector b based on the scheme\n    if scheme == 'centered':\n        c_sub = -epsilon - a * h / 2.0\n        c_diag = 2.0 * epsilon\n        c_super = -epsilon + a * h / 2.0\n        \n        # Populate diagonals\n        if n > 0:\n            np.fill_diagonal(A, c_diag)\n        if n > 1:\n            np.fill_diagonal(A[1:], c_sub)\n            np.fill_diagonal(A[:, 1:], c_super)\n        \n        # Boundary conditions in RHS\n        # b[0] -= c_sub * u0 is a no-op since u0=0\n        if n > 0:\n            b[n-1] = -c_super * u_np1\n\n    elif scheme == 'upwind':\n        if a >= 0: # Upstream is i-1\n            c_sub = -epsilon - a * h\n            c_diag = 2.0 * epsilon + a * h\n            c_super = -epsilon\n        else: # a  0, upstream is i+1\n            c_sub = -epsilon\n            c_diag = 2.0 * epsilon - a * h\n            c_super = -epsilon + a * h\n            \n        # Populate diagonals\n        if n > 0:\n            np.fill_diagonal(A, c_diag)\n        if n > 1:\n            np.fill_diagonal(A[1:], c_sub)\n            np.fill_diagonal(A[:, 1:], c_super)\n            \n        # Boundary conditions in RHS\n        # b[0] -= c_sub * u0 is a no-op since u0=0\n        if n > 0:\n            b[n-1] = -c_super * u_np1\n    else:\n        raise ValueError(f\"Unknown scheme: {scheme}\")\n        \n    # Solve for interior points\n    if n > 0:\n        u_interior = np.linalg.solve(A, b)\n    else:\n        u_interior = np.array([])\n    \n    # Reconstruct full solution including boundaries\n    u_full = np.concatenate(([u0], u_interior, [u_np1]))\n    \n    # Check for maximum principle violation\n    min_u = np.min(u_full)\n    max_u = np.max(u_full)\n    \n    violation = (min_u  (0.0 - tau)) or (max_u > (1.0 + tau))\n    \n    return violation\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e-3, 2, 49),          # Case 1\n        (1e-1, 1, 49),          # Case 2\n        (10e-3, 1, 49),         # Case 3 (epsilon=10e-3 is 1e-2)\n        (1e-3, -2, 49),         # Case 4\n        (5e-3, 20, 19),         # Case 5\n    ]\n    \n    # Numerical tolerance for checking the violation\n    tau = 1e-12\n\n    results_list = []\n    for case in test_cases:\n        eps, a, n = case\n        \n        # Check violation for centered scheme\n        b_cent = compute_solution_and_check_violation(eps, a, n, 'centered', tau)\n        \n        # Check violation for upwind scheme\n        b_up = compute_solution_and_check_violation(eps, a, n, 'upwind', tau)\n        \n        # Format as string '[Bool,Bool]'\n        results_list.append(f\"[{b_cent},{b_up}]\")\n\n    # Final print statement in the exact required format.\n    # e.g., [[True,False],[False,False]]\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```", "id": "3419376"}, {"introduction": "在探讨了有限差分法的稳定性之后，我们现在将注意力转向有限元法（FEM）。在有限元法中，离散极值原理对于确保解的物理意义同样至关重要，但其成立的条件表现形式有所不同。这个练习 [@problem_id:3419375] 揭示了网格几何形状与稳定性之间的关键联系。您将构建简单的三角剖分来证明，非钝角网格能够保持离散极值原理，而单个钝角的存在就可能破坏其底层的M-矩阵条件，并导致伪影（spurious overshoots），从而为有限元法的几何约束提供一个清晰直观的教训。", "problem": "考虑方形域 $\\Omega = [0,1]\\times [0,1]$ 上带有狄利克雷边界条件的椭圆偏微分方程的标量扩散模型问题。连续模型为：求 $u:\\Omega\\to\\mathbb{R}$ 使得\n$$\n-\\Delta u = f \\quad \\text{在 } \\Omega \\text{ 中}, \\qquad u = g \\quad \\text{在 } \\partial\\Omega \\text{ 上},\n$$\n其中源项为常数 $f(x,y) = -1$，边界数据为 $g(x,y) = x$。强极值原理指出，如果 $-\\Delta u \\le 0$（等价于 $f \\le 0$），则解的最大值在边界上达到。因此，连续解满足 $\\max_{\\Omega} u \\le \\max_{\\partial \\Omega} g = 1$。\n\n我们使用定义在 $\\Omega$ 的三角剖分上的协调分片线性有限元方法（FEM）来离散化该模型。组装过程使用标准的双线性形式，其中局部单元梯度在每个三角形上是常数。对于一个顶点为 $(x_i,y_i)$（$i\\in\\{1,2,3\\}$）的三角形，记其面积为 $A$，局部形函数的梯度为 $\\nabla N_i = \\frac{1}{2A}(b_i,c_i)$，其中 $b_i$ 和 $c_i$ 以常规方式由顶点坐标计算得出。局部刚度系数满足\n$$\nK_e(i,j) = \\int_{T} \\nabla N_i \\cdot \\nabla N_j\\,dx = \\frac{b_i b_j + c_i c_j}{4A},\n$$\n对于常数源项 $f=-1$，局部载荷向量的项为\n$$\nF_e(i) = \\int_{T} N_i f\\,dx = -\\frac{A}{3}.\n$$\n全局组装并强施加狄利克雷边界条件后，得到关于节点值 $u_h$ 的稀疏线性系统 $K u_h = F$。\n\n有限元方法的离散极值原理（DMP）指出，如果全局刚度矩阵是 M-矩阵（对于各向同性扩散，在非钝角三角剖分上这一点可以得到保证），那么当 $f \\le 0$ 时，有 $\\max_{\\Omega_h} u_h \\le \\max_{\\partial\\Omega_h} g$。然而，在包含钝角三角形的剖分上，刚度矩阵的非对角线元可能变为正值，从而违反 M-矩阵结构并可能破坏 DMP，导致解出现超过边界最大值的过冲。\n\n您的任务是：\n- 构建 $\\Omega$ 的特定三角剖分，以说明 FEM DMP 的满足和违反情况。\n- 对每个三角剖分求解离散 FEM 问题。\n- 量化过冲，其定义为\n$$\n\\text{overshoot} := \\max\\left\\{0,\\ \\max_i u_h(i) - \\max_{j\\in\\partial\\Omega} g_j\\right\\},\n$$\n其中边界节点值的最大值为 $\\max_{j\\in\\partial\\Omega} g_j = 1$，因为在 $\\partial\\Omega$ 上 $g(x,y)=x$。\n\n使用的基本假设：\n- 对于 $f\\le 0$ 的椭圆算子，强极值原理意味着在连续情况下，解的上界是其边界最大值。\n- 分片线性（仿射）FEM 的刚度组装在三角形上使用恒定梯度，并采用上述局部公式。\n- 当组装的刚度矩阵是 M-矩阵时，FEM 的离散极值原理成立，这一点在各向同性扩散的非钝角网格上可以得到保证。\n\n三角剖分设计：\n- 使用一个简单的 5 节点网格，由单位正方形的四个角点和一个内部节点组成。将内部节点与所有四个角点连接，形成 4 个三角形。\n- 对于非钝角三角剖分，将内部节点置于中心 $(0.5,0.5)$，这将在内部节点处产生直角。\n- 对于钝角三角剖分，沿坐标轴向边界移动内部节点以引入钝角。通过检查全局组装矩阵中是否存在正的非对角线元，可以确定刚度矩阵是否失去了 M-矩阵性质。\n\n测试套件：\n- 情况 $\\mathbf{A}$（理想情况，DMP 满足）：内部节点位于 $(0.5,0.5)$。\n- 情况 $\\mathbf{B}$（通过垂直移动产生钝角）：沿垂直线 $x=0.5$ 搜索内部节点，找到一个位置 $(0.5,y)$，使得组装的全局刚度矩阵至少有一个正的非对角线元，表明 DMP 被违反。\n- 情况 $\\mathbf{C}$（通过水平移动产生钝角）：沿水平线 $y=0.5$ 搜索内部节点，找到一个位置 $(x,0.5)$，使得某个非对角线元满足相同的正值条件。\n\n算法要求：\n- 使用 $f=-1$ 的局部三角形公式组装全局刚度矩阵 $K$ 和载荷向量 $F$。\n- 通过适当地重置行和列，将边界节点的对角线元设为 1，并将右端项设为这些节点上的边界数据 $g$，来强施加狄利克雷边界条件。\n- 求解 $K u_h = F$。\n- 对每种情况计算如上定义的过冲。\n\n角度单位：如果在概念上使用任何角度来检查钝角性，所有角度都应以度为单位处理；然而，程序将通过非对角线元的符号来数值地检查 M-矩阵条件，而不需要显式地计算角度。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含情况 $\\mathbf{A}$、$\\mathbf{B}$ 和 $\\mathbf{C}$ 的过冲结果，格式为方括号内以逗号分隔的列表（例如，$[r_A,r_B,r_C]$），其中每个 $r_\\cdot$ 是一个浮点数。\n\n不需要外部输入。所有计算都是无量纲的；不涉及物理单位。通过使用双精度算术来确保数值稳定性。", "solution": "用户希望验证并解决一个关于泊松方程 $-\\Delta u = -1$ 的有限元方法（FEM）离散化中的离散极值原理（DMP）的问题。该方程定义在单位正方形 $\\Omega = [0,1]\\times[0,1]$ 上，边界数据为 $u(x,y)=x$。我们的任务是使用分片线性有限元方法来展示离散极值原理的满足和违反情况。\n\nDMP 是连续极值原理的离散模拟。对于给定问题，连续解在其边界上达到最大值，即 $u(x,y) \\le \\max_{\\partial\\Omega} g = 1$。DMP 指出，在某些条件下，离散解 $u_h$ 也满足此性质：$\\max_i u_h(i) \\le \\max_{j \\in \\partial\\Omega_h} g_j$。对于 FEM，DMP 成立的一个充分条件是全局刚度矩阵 $K$ 是一个 M-矩阵。M-矩阵具有正的对角线元和非正的非对角线元。\n\n对于算子 $-\\Delta$，对应于由两个三角形 $T_1$ 和 $T_2$ 共享的内部边 $(i,j)$ 的刚度矩阵非对角线元 $K_{ij}$ 由 $K_{ij} = -\\frac{1}{2}\\left(\\cot\\theta_1 + \\cot\\theta_2\\right)$ 给出，其中 $\\theta_1$ 和 $\\theta_2$ 分别是每个三角形中与边 $(i,j)$ 相对的角。如果三角剖分是非钝角的（所有角 $\\le 90^\\circ$），那么所有的余切值都是非负的，因此所有非对角线元 $K_{ij}$ 都是非正的。这确保了 $K$ 是一个 M-矩阵，并且 DMP 成立。如果一个三角形包含一个钝角（例如 $\\theta_1 > 90^\\circ$），其余切值为负。如果 $|\\cot\\theta_1| > \\cot\\theta_2$，则 $K_{ij}$ 项变为正值，违反了 M-矩阵性质，并可能导致 DMP 失效，从而产生非物理振荡或“过冲”，即数值解超过边界最大值。\n\n我们构建一个 5 节点网格，节点位于单位正方形的角点（索引 0 到 3）和一个内部节点（索引 4）。这形成了四个三角形。自由度是节点值 $u_h(i)$。边界节点（0,1,2,3）处的值由狄利克雷条件 $g(x,y)=x$ 固定。唯一未知的是内部节点处的值 $u_h(4)$。\n\nFEM 离散化产生一个线性系统 $K u_h = F$。组装后，我们施加边界条件。该系统可以划分为内部（$I$）和边界（$B$）节点。内部自由度 $u_I$ 的方程是 $K_{II} u_I = F_I - K_{IB} g_B$。在我们的例子中，$I=\\{4\\}$，因此这简化为一个标量方程：\n$$\nK_{44} u_h(4) = F_4 - \\sum_{j=0}^{3} K_{4j} g(x_j, y_j)\n$$\n边界值为 $g_0 = g(0,0) = 0$，$g_1 = g(1,0) = 1$，$g_2 = g(1,1) = 1$，$g_3 = g(0,1) = 0$。最大边界值为 $\\max_{j\\in\\partial\\Omega} g_j = 1$。过冲计算为 $\\max\\{0, u_h(4) - 1\\}$。\n\n步骤如下：\n1.  为每个测试用例定义节点坐标。\n2.  使用提供的局部公式组装 $5\\times5$ 全局刚度矩阵 $K$ 和 $5\\times1$ 载荷向量 $F$。源项 $f=-1$ 意味着内部节点上的总载荷为 $F_4 = \\sum_e (-A_e/3) = -(\\text{总面积})/3 = -1/3$，这与内部节点的位置无关。\n3.  求解关于 $u_h(4)$ 的标量方程。\n4.  计算过冲。\n\n**情况 A：内部节点位于 $(0.5, 0.5)$**\n四个三角形是全等的等腰直角三角形。角度为 $90^\\circ$ 和 $45^\\circ$。该三角剖分是非钝角的。刚度矩阵 $K$ 将是一个 M-矩阵。DMP 成立，我们预期过冲为零。计算表明 $u_h(4) = 5/12 \\approx 0.4167$，小于 1，因此过冲为 0。\n\n**情况 B：内部节点位于 $(0.5, y)$ 的钝角三角剖分**\n为了违反 M-矩阵性质，我们必须引入一个钝角。将内部节点置于 $(0.5, y)$ 且 $|y|  0.5$ 会使三角形 $(0,1,4)$ 中该节点处的角变为钝角。我们选择 $y=0.1$ 作为一个代表点。这个选择使得 $K$ 的一个非对角线元为正，破坏了 M-矩阵结构，并可能导致过冲。\n\n**情况 C：内部节点位于 $(x, 0.5)$ 的钝角三角剖分**\n与情况 B 对称，我们将内部节点置于 $(x, 0.5)$ 且 $|x|  0.5$。我们选择 $x=0.1$。这使得三角形 $(0,3,4)$ 中内部节点处的角变为钝角，同样违反了 M-矩阵条件。\n\n下面的 Python 代码为这三种情况实现了此过程，并计算了产生的过冲。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef _calculate_local_matrices(coords: np.ndarray):\n    \"\"\"\n    Computes the local stiffness matrix and load vector for a single triangular element.\n\n    Args:\n        coords: A 3x2 numpy array of vertex coordinates (x, y).\n\n    Returns:\n        A tuple (Ke, Fe) where Ke is the 3x3 local stiffness matrix and\n        Fe is the 3-element local load vector.\n    \"\"\"\n    p1, p2, p3 = coords\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n\n    # Area of the triangle using the shoelace formula\n    area = 0.5 * np.abs(x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2))\n    if area  1e-12:\n        raise ValueError(\"Triangle with zero or near-zero area detected.\")\n\n    # b and c coefficients related to the gradients of the P1 basis functions\n    # For a cycle (i,j,k), b_i = y_j - y_k, c_i = x_k - x_j\n    b_coeffs = np.array([y2 - y3, y3 - y1, y1 - y2])\n    c_coeffs = np.array([x3 - x2, x1 - x3, x2 - x1])\n\n    # Local stiffness matrix Ke(i,j) = (b_i*b_j + c_i*c_j) / (4*Area)\n    # This derives from integrating grad(N_i) . grad(N_j) over the triangle.\n    Ke = np.zeros((3, 3), dtype=np.float64)\n    for i in range(3):\n        for j in range(3):\n            Ke[i, j] = (b_coeffs[i] * b_coeffs[j] + c_coeffs[i] * c_coeffs[j]) / (4.0 * area)\n\n    # Local load vector for a constant source f = -1\n    # Fe(i) = integral(N_i * f) dx = f * Area / 3\n    Fe = (-area / 3.0) * np.ones(3, dtype=np.float64)\n\n    return Ke, Fe\n\ndef _calculate_overshoot(interior_node_coords: tuple[float, float]):\n    \"\"\"\n    Assembles the global system for the 5-node mesh, solves for the single \n    interior node, and computes the overshoot.\n\n    Args:\n        interior_node_coords: A tuple (x, y) for the interior node.\n\n    Returns:\n        The computed overshoot value.\n    \"\"\"\n    # 5-node mesh: 4 corners of the unit square and 1 interior node\n    nodes = np.array([\n        [0.0, 0.0],  # Node 0: (0,0)\n        [1.0, 0.0],  # Node 1: (1,0)\n        [1.0, 1.0],  # Node 2: (1,1)\n        [0.0, 1.0],  # Node 3: (0,1)\n        interior_node_coords  # Node 4: interior\n    ], dtype=np.float64)\n\n    # Triangulation: connect interior node to all corners\n    elements = np.array([\n        [0, 1, 4],\n        [1, 2, 4],\n        [2, 3, 4],\n        [3, 0, 4]\n    ])\n\n    num_nodes = len(nodes)\n    K = np.zeros((num_nodes, num_nodes), dtype=np.float64)\n    F = np.zeros(num_nodes, dtype=np.float64)\n\n    # Assemble global stiffness matrix K and load vector F\n    for i, elem_nodes in enumerate(elements):\n        elem_coords = nodes[elem_nodes]\n        Ke, Fe = _calculate_local_matrices(elem_coords)\n        \n        # Add local contributions to global matrices\n        for local_i in range(3):\n            global_i = elem_nodes[local_i]\n            F[global_i] += Fe[local_i]\n            for local_j in range(3):\n                global_j = elem_nodes[local_j]\n                K[global_i, global_j] += Ke[local_i, local_j]\n    \n    # Boundary values g(x,y)=x. Nodes 0,1,2,3 are on the boundary.\n    g_boundary = np.array([\n        nodes[0, 0],  # g(0,0) = 0\n        nodes[1, 0],  # g(1,0) = 1\n        nodes[2, 0],  # g(1,1) = 1\n        nodes[3, 0]   # g(0,1) = 0\n    ], dtype=np.float64)\n\n    # Apply strong Dirichlet BCs by solving for the single interior node (node 4)\n    # The system is K_II * u_I = F_I - K_IB * u_B, where I={4} and B={0,1,2,3}\n    boundary_indices = [0, 1, 2, 3]\n    interior_index = 4\n    \n    # K_IB * u_B part of the equation\n    rhs_boundary_contribution = 0.0\n    for i, b_idx in enumerate(boundary_indices):\n        rhs_boundary_contribution += K[interior_index, b_idx] * g_boundary[i]\n    \n    # Full RHS: F_I - K_IB * u_B\n    rhs_total = F[interior_index] - rhs_boundary_contribution\n    \n    # Solve the 1x1 system for the interior node: K_II * u_I = rhs_total\n    u4 = rhs_total / K[interior_index, interior_index]\n    \n    # Full discrete solution vector\n    u_h = np.zeros(num_nodes, dtype=np.float64)\n    u_h[boundary_indices] = g_boundary\n    u_h[interior_index] = u4\n    \n    # Maximum value of the boundary data g is 1\n    max_g = 1.0\n    \n    # Overshoot is the amount by which the solution maximum exceeds the boundary maximum\n    overshoot = max(0.0, np.max(u_h) - max_g)\n    \n    return overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite from the problem statement.\n    # Locations for Cases B and C are chosen based on analysis to produce\n    # obtuse triangles and violate the M-matrix condition.\n    test_cases = [\n        (0.5, 0.5),  # Case A: Non-obtuse, DMP satisfied\n        (0.5, 0.1),  # Case B: Obtuse via vertical shift, DMP violated\n        (0.1, 0.5),  # Case C: Obtuse via horizontal shift, DMP violated\n    ]\n\n    results = []\n    for case_coords in test_cases:\n        overshoot = _calculate_overshoot(case_coords)\n        results.append(overshoot)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3419375"}, {"introduction": "我们最后的练习将前面探讨的原理融合成一项强大而实用的技能：自动化代码验证。我们将不再是针对特定案例手动检查是否违反离散极值原理，而是使用“制造解方法”（Method of Manufactured Solutions）来构建一个测试框架，系统地检验我们代码的稳健性。在这个练习 [@problem_id:3419390] 中，您将为椭圆型（泊松）和抛物型（热）方程实现测试。这将巩固您在不同背景下对离散极值原理条件的理解，并使您具备创建自动化检查的能力，这对于开发可靠的科学软件至关重要。", "problem": "考虑使用人造解方法对椭圆和抛物型偏微分方程的极值原理进行离散验证。目标是构建一个测试框架，当边界数据和初始条件施加已知的 $L^{\\infty}$ 界时，该框架能自动检测有限差分格式中违反离散极值原理 (DMP) 的情况。所有量均为无量纲。在整个问题中，空间计算域为单位正方形 $\\Omega = [0,1] \\times [0,1]$，网格是均匀且对齐的。假设以下基本事实成立：(i) 拉普拉斯算子的连续弱极值原理指出，如果在 $\\Omega$ 中 $\\Delta u \\ge 0$ 且 $u$ 在 $\\overline{\\Omega}$ 上连续，则 $u$ 在 $\\overline{\\Omega}$ 上的最大值在 $\\partial \\Omega$ 上达到；如果 $\\Delta u \\le 0$，则 $u$ 的最小值在 $\\partial \\Omega$ 上达到；(ii) 对于带有狄利克雷边界条件的热方程 $u_t = \\Delta u$，极值原理指出，对于 $t \\ge 0$，$u$ 在时空中的本质上确界不超过初始数据和边界数据并集的上确界，对于下确界也类似。这些原理为离散格式中的单调性约束提供了理论基础。\n\n您必须实现以下验证任务：\n\n1. 椭圆方程验证（拉普拉斯方程和泊松方程）：\n   - 在大小为 $N \\times N$、网格间距为 $h = 1/(N+1)$ 的均匀内部网格上，对内部索引 $(i,j)$（其中 $i,j \\in \\{1,\\dots,N\\}$）使用算子 $-\\Delta$ 的五点有限差分近似。对于离散拉普拉斯算子，构造一个稀疏矩阵，其对角线元素为 $4/h^2$，四个基本方向上直接相邻的非对角线元素为 $-1/h^2$。通过修改右侧项来引入狄利克雷边界条件（当相邻节点位于边界上时，将已知的边界值乘以 $1/h^2$ 并加到右侧项中）。\n   - 人造边界数据情况（调和边界扩展）：在 $\\partial \\Omega$ 上施加边界数据 $u(x,y) = x$，并在内部节点上求解离散拉普拉斯方程 $-\\Delta_h u_h = 0$。离散极值原理预测 $u_h$ 将被限制在区间 $[0,1]$ 内，因为边界数据的最小值为 $0$，最大值为 $1$。\n   - 人造源项情况（非负强迫项）：在 $\\partial \\Omega$ 上施加齐次狄利克雷边界数据 $u = 0$，并求解离散泊松问题 $-\\Delta_h u_h = f$，其中内部节点上的源项为 $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) \\ge 0$。当矩阵是 $M$-矩阵且 $f \\ge 0$ 时，离散极小值原理预测内部节点上的解 $u_h \\ge 0$。\n   - 对于这两个椭圆方程测试，在内部节点上以 $\\tau = 10^{-12}$ 的容差对相应的 DMP 断言进行数值验证。\n\n2. 抛物线方程验证（热方程的显式前向欧拉格式）：\n   - 考虑热方程 $u_t = \\Delta u$ 的有限差分格式，其在 $\\partial \\Omega$ 上具有狄利克雷边界条件 $u = 0$，并在内部大小为 $N \\times N$、间距为 $h = 1/(N+1)$ 的均匀网格上使用显式前向欧拉方法。令 $r = \\Delta t / h^2$。该格式通过以下方式更新内部节点：\n     $$u_{i,j}^{n+1} = u_{i,j}^{n} + r\\left(u_{i+1,j}^{n} + u_{i-1,j}^{n} + u_{i,j+1}^{n} + u_{i,j-1}^{n} - 4u_{i,j}^{n}\\right)$$\n     - 使用初始条件 $u^0(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，它在内部节点上满足 $u^0 \\ge 0$ 和 $\\|u^0\\|_{\\infty} = 1$，并在所有 $n$ 时刻对 $\\partial \\Omega$ 使用零边界数据 $u^n = 0$。\n     - 在 $T$ 个时间步中，对每个时间步 $n$ 验证离散极值原理断言：具体来说，检查在系数约束 $r \\le 1/4$ 成立的条件下，$u_{i,j}^{n}$ 是否保持在区间 $[0, \\|u^0\\|_{\\infty}]$ 内（容差为 $\\tau = 10^{-12}$）。该约束条件使更新成为相邻值的凸组合，从而保证了格式的单调性。\n     - 通过运行一个 $r > 1/4$ 的案例来演示 DMP 违规的检测；如果在任何步骤中 $u_{i,j}^{n}$ 超出容差范围落在了区间 $[0, \\|u^0\\|_{\\infty}]$ 之外，则标记为违规。\n\n您必须实现一个程序来构建并运行以下测试套件。对于所有测试，使用 $N = 31$，容差 $\\tau = 10^{-12}$，在抛物线方程测试中使用 $T = 50$ 步。每个测试返回一个布尔值，指示 DMP 条件是否得到满足。\n\n- 测试 $\\mathsf{E1}$（椭圆方程，调和边界）：$-\\Delta_h u_h = 0$，边界数据 $u|_{\\partial\\Omega} = x$，断言 $\\min(u_h) \\ge 0 - \\tau$ 和 $\\max(u_h) \\le 1 + \\tau$。\n- 测试 $\\mathsf{E2}$（椭圆方程，非负源项）：$-\\Delta_h u_h = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，边界数据 $u|_{\\partial\\Omega} = 0$，断言 $\\min(u_h) \\ge 0 - \\tau$。\n- 测试 $\\mathsf{P1}$（抛物线方程，稳定时间步）：显式格式，$r = 0.24$，边界数据 $u^n|_{\\partial\\Omega} = 0$，初始条件 $u^0 = \\sin(\\pi x)\\sin(\\pi y)$，在每一步 $n$ 断言 $\\min(u^n) \\ge 0 - \\tau$ 且 $\\max(u^n) \\le 1 + \\tau$。\n- 测试 $\\mathsf{P2}$（抛物线方程，不稳定时间步）：显式格式，$r = 0.26$，边界数据 $u^n|_{\\partial\\Omega} = 0$，初始条件 $u^0 = \\sin(\\pi x)\\sin(\\pi y)$，断言同 $\\mathsf{P1}$；预期会违规。\n- 测试 $\\mathsf{P3}$（抛物线方程，临界时间步）：显式格式，$r = 0.25$，边界数据 $u^n|_{\\partial\\Omega} = 0$，初始条件 $u^0 = \\sin(\\pi x)\\sin(\\pi y)$，断言同 $\\mathsf{P1}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5]”）。每个结果必须是对应测试用例的布尔值，顺序为 $\\mathsf{E1}$、$\\mathsf{E2}$、$\\mathsf{P1}$、$\\mathsf{P2}$、$\\mathsf{P3}$。", "solution": "该验证框架建立在椭圆和抛物型算子的极值原理及其离散模拟之上。其基础是以下一系列原理和性质。\n\n对于椭圆方程，考虑在有界域 $\\Omega$ 上带有狄利克雷边界条件的算子 $L u = -\\Delta u$。连续极值原理和极小值原理指出，如果 $L u \\ge 0$（等价于 $\\Delta u \\le 0$，$u$ 是超调和的），则 $u$ 的最小值在边界 $\\partial \\Omega$ 上达到；如果 $L u \\le 0$（等价于 $\\Delta u \\ge 0$，$u$ 是次调和的），则 $u$ 的最大值在 $\\partial \\Omega$ 上达到。对于五点中心差分格式，在内部节点上得到的线性系统是 $A u = b$，其中矩阵 $A$ 的元素为：对于节点 $p$ 的最近邻节点 $q$，$A_{p,p} = 4/h^2$ 且 $A_{p,q} = -1/h^2$，否则 $A_{p,q} = 0$。右侧项 $b$ 包含了内部强迫项 $f$ 和边界贡献 $\\sum (1/h^2) g$，其中 $g$ 是狄利克雷边界值。这个矩阵 $A$ 是一个 $M$-矩阵：$A$ 是一个 Z-矩阵（非对角线元素 $\\le 0$），对角占优且严格正定，这意味着 $A^{-1} \\ge 0$（逐分量）。因此，如果 $b \\ge 0$（逐分量），例如由于非负的 $f$ 和非负的边界贡献，那么离散解 $u = A^{-1} b$ 是非负的，这与离散极小值原理一致。对于齐次右侧项 $f \\equiv 0$，当格式是单调的时，离散解 $u$ 的最大值和最小值位于边界值的凸包内。在正方形上构造的边界数据 $u|_{\\partial \\Omega} = x$ 产生的值在 $[0,1]$ 区间内，离散解继承了这些界限。\n\n对于抛物线方程，考虑带有狄利克雷边界条件的 $u_t = \\Delta u$。在均匀网格上的显式前向欧拉格式为\n$$u_{i,j}^{n+1} = (1 - 4r) u_{i,j}^{n} + r\\left(u_{i+1,j}^{n} + u_{i-1,j}^{n} + u_{i,j+1}^{n} + u_{i,j-1}^{n}\\right),$$\n其中 $r = \\Delta t / h^2$。如果 $r \\le 1/4$，此更新中的所有系数都是非负的且总和为 $1$，这使得 $u_{i,j}^{n+1}$ 成为当前值和相邻值的凸组合。在非负初始数据和零狄利克雷边界数据的条件下，离散解保持非负性，并保持由初始上确界为上界，这与离散极值原理的模拟相符。如果 $r > 1/4$，中心系数变为负数，破坏了单调性，并可能导致超出或低于极值的波动，从而违反极值原理。\n\n验证框架的算法设计：\n\n1. 离散椭圆方程求解器：\n   - 为内部节点构建稀疏的 $N^2 \\times N^2$ 五点拉普拉斯矩阵 $A$。通过 $p = (i-1) N + (j-1)$ 将 $(i,j)$（其中 $i,j \\in \\{1,\\dots,N\\}$）映射到单个索引。\n   - 通过在内部坐标 $(x_i,y_j) = (i h, j h)$ 处对人造源项 $f(x_i,y_j)$ 进行采样，并加上狄利克雷边界贡献，来计算右侧项 $b$。每个位于内部区域之外的邻居节点向 $b$ 添加 $(1/h^2) g$，其中 $g$ 是该邻居坐标处的边界值。这就得到了表示 $-\\Delta_h u_h = f$ 的离散系统 $A u = b$。\n   - 使用稀疏线性求解器求解该系统。然后检查 DMP 断言：对于调和边界测试（$f \\equiv 0$，边界 $u|_{\\partial \\Omega} = x$），验证 $\\min(u_h) \\ge 0 - \\tau$ 和 $\\max(u_h) \\le 1 + \\tau$。对于非负源项测试（$f \\ge 0$，边界 $u|_{\\partial \\Omega} = 0$），验证 $\\min(u_h) \\ge 0 - \\tau$。\n\n2. 显式抛物线格式：\n   - 在内部节点上初始化 $u^0_{i,j} = \\sin(\\pi x_i)\\sin(\\pi y_j)$，并在所有时间将边界节点设置为零。计算内部初始上确界 $\\|u^0\\|_{\\infty}$。\n   - 对于给定的 $r = \\Delta t / h^2$，对显式更新进行 $T$ 个时间步的迭代。在每一步，强制边界为零。每次更新后，验证 DMP 断言：检查内部的最小值至少为 $0 - \\tau$，最大值不超过 $\\|u^0\\|_{\\infty} + \\tau$。\n   - 对于 $r \\le 1/4$，更新是凸组合，保证了单调性和 DMP 的保持；对于 $r > 1/4$，通过边界检查来检测违规。\n\n测试套件和输出：\n- 测试 $\\mathsf{E1}$：$N = 31$, $h = 1/(N+1)$，边界 $u|_{\\partial \\Omega} = x$，右侧项 $f \\equiv 0$，返回一个布尔值，指示 $\\min(u_h) \\ge 0 - \\tau$ 和 $\\max(u_h) \\le 1 + \\tau$ 是否都成立。\n- 测试 $\\mathsf{E2}$：$N = 31$，边界 $u|_{\\partial \\Omega} = 0$, $f(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$，返回一个布尔值，指示 $\\min(u_h) \\ge 0 - \\tau$ 是否成立。\n- 测试 $\\mathsf{P1}$：$N = 31$, $r = 0.24$, $T = 50$，初始条件 $u^0 = \\sin(\\pi x)\\sin(\\pi y)$，边界为零；返回一个布尔值，指示 DMP 界限在所有步骤中是否都成立。\n- 测试 $\\mathsf{P2}$：$N = 31$, $r = 0.26$, $T = 50$，相同的初始和边界条件；返回一个布尔值，指示 DMP 界限是否成立（预期为假）。\n- 测试 $\\mathsf{P3}$：$N = 31$, $r = 0.25$, $T = 50$，相同的初始和边界条件；返回一个布尔值，指示 DMP 界限是否成立。\n\n最终程序按顺序汇总五个测试结果，并以要求的格式将其打印为单行，确保程序能够独立执行，无需外部输入。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef build_5pt_laplacian_matrix(N, h):\n    \"\"\"\n    Build the sparse matrix A for the 5-point discretization of -Delta on an N x N interior grid.\n    Diagonal entries: 4/h^2\n    Off-diagonal (neighbors): -1/h^2\n    \"\"\"\n    n = N * N\n    A = lil_matrix((n, n))\n    inv_h2 = 1.0 / (h * h)\n    for i in range(N):\n        for j in range(N):\n            p = i * N + j\n            # center\n            A[p, p] = 4.0 * inv_h2\n            # left neighbor\n            if i > 0:\n                A[p, (i - 1) * N + j] = -1.0 * inv_h2\n            # right neighbor\n            if i  N - 1:\n                A[p, (i + 1) * N + j] = -1.0 * inv_h2\n            # down neighbor\n            if j > 0:\n                A[p, i * N + (j - 1)] = -1.0 * inv_h2\n            # up neighbor\n            if j  N - 1:\n                A[p, i * N + (j + 1)] = -1.0 * inv_h2\n    return csr_matrix(A)\n\ndef solve_dirichlet_poisson(N, boundary_func, rhs_func):\n    \"\"\"\n    Solve -Delta_h u = f on an N x N interior grid with Dirichlet boundary conditions.\n    boundary_func(x, y) gives boundary value u on the boundary.\n    rhs_func(x, y) gives f at interior points.\n    Returns u_interior (N x N) array of solution values on interior nodes.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    A = build_5pt_laplacian_matrix(N, h)\n    n = N * N\n    b = np.zeros(n, dtype=float)\n    inv_h2 = 1.0 / (h * h)\n\n    # Coordinates: interior nodes at (i=1..N, j=1..N) mapped to x=i*h, y=j*h\n    # Boundary indices are at i=0 and i=N+1 for x, and j=0 and j=N+1 for y.\n    for i in range(1, N + 1):\n        x_i = i * h\n        for j in range(1, N + 1):\n            y_j = j * h\n            p = (i - 1) * N + (j - 1)\n            # RHS f\n            b[p] = rhs_func(x_i, y_j)\n            # Boundary contributions: check neighbors outside interior domain\n            # left neighbor at i-1\n            if i - 1 == 0:\n                # boundary at x=0, interior y_j\n                g = boundary_func(0.0, y_j)\n                b[p] += inv_h2 * g\n            # right neighbor at i+1\n            if i + 1 == N + 1:\n                # boundary at x=1, interior y_j\n                g = boundary_func(1.0, y_j)\n                b[p] += inv_h2 * g\n            # down neighbor at j-1\n            if j - 1 == 0:\n                # boundary at y=0, interior x_i\n                g = boundary_func(x_i, 0.0)\n                b[p] += inv_h2 * g\n            # up neighbor at j+1\n            if j + 1 == N + 1:\n                # boundary at y=1, interior x_i\n                g = boundary_func(x_i, 1.0)\n                b[p] += inv_h2 * g\n\n    # Solve\n    u_vec = spsolve(A, b)\n    u_interior = u_vec.reshape((N, N))\n    return u_interior\n\ndef test_E1(N, tol):\n    \"\"\"\n    Elliptic test E1: -Delta_h u = 0 with boundary u|_{∂Ω} = x.\n    Check that interior solution lies within [0, 1] up to tolerance.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    def boundary_func(x, y):\n        return x\n    def rhs_func(x, y):\n        return 0.0\n\n    u_interior = solve_dirichlet_poisson(N, boundary_func, rhs_func)\n    umin = np.min(u_interior)\n    umax = np.max(u_interior)\n    ok = (umin >= -tol) and (umax = 1.0 + tol)\n    return ok\n\ndef test_E2(N, tol):\n    \"\"\"\n    Elliptic test E2: -Delta_h u = f with f(x,y) = 2*pi^2*sin(pi x)*sin(pi y), and boundary u=0.\n    Check discrete minimum principle: u_interior >= 0 (within tolerance).\n    \"\"\"\n    pi = np.pi\n    def boundary_func(x, y):\n        return 0.0\n    def rhs_func(x, y):\n        return 2.0 * (pi ** 2) * np.sin(pi * x) * np.sin(pi * y)\n\n    u_interior = solve_dirichlet_poisson(N, boundary_func, rhs_func)\n    umin = np.min(u_interior)\n    ok = (umin >= -tol)\n    return ok\n\ndef run_heat_explicit(N, r, T, tol):\n    \"\"\"\n    Run explicit forward Euler for u_t = Delta u with zero Dirichlet boundary.\n    Initial condition u0 = sin(pi x) sin(pi y).\n    Check DMP at each step: interior u stays within [0, initial_max] within tolerance.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    pi = np.pi\n\n    # Full grid including boundaries: (N+2) x (N+2)\n    u = np.zeros((N + 2, N + 2), dtype=float)\n\n    # Initialize interior\n    for i in range(1, N + 1):\n        x_i = i * h\n        for j in range(1, N + 1):\n            y_j = j * h\n            u[i, j] = np.sin(pi * x_i) * np.sin(pi * y_j)\n\n    initial_max = np.max(u[1:N+1, 1:N+1])\n\n    # Time stepping\n    for n in range(T):\n        u_new = np.copy(u)\n        # Update interior using 5-point Laplacian explicit scheme\n        # zero Dirichlet boundaries remain zero\n        for i in range(1, N + 1):\n            for j in range(1, N + 1):\n                u_new[i, j] = (\n                    u[i, j]\n                    + r * (\n                        u[i + 1, j] + u[i - 1, j] + u[i, j + 1] + u[i, j - 1]\n                        - 4.0 * u[i, j]\n                    )\n                )\n        # Enforce boundary zeros explicitly (optional redundancy)\n        u_new[0, :] = 0.0\n        u_new[N + 1, :] = 0.0\n        u_new[:, 0] = 0.0\n        u_new[:, N + 1] = 0.0\n\n        u = u_new\n\n        # Check DMP bounds on interior\n        umin = np.min(u[1:N+1, 1:N+1])\n        umax = np.max(u[1:N+1, 1:N+1])\n        if not (umin >= -tol and umax = initial_max + tol):\n            return False\n    return True\n\ndef test_P1(N, tol):\n    \"\"\"\n    Parabolic test P1: Explicit scheme with r = 0.24 (stable).\n    \"\"\"\n    r = 0.24\n    T = 50\n    return run_heat_explicit(N, r, T, tol)\n\ndef test_P2(N, tol):\n    \"\"\"\n    Parabolic test P2: Explicit scheme with r = 0.26 (unstable, expect DMP violation).\n    \"\"\"\n    r = 0.26\n    T = 50\n    return run_heat_explicit(N, r, T, tol)\n\ndef test_P3(N, tol):\n    \"\"\"\n    Parabolic test P3: Explicit scheme with r = 0.25 (critical, should preserve DMP).\n    \"\"\"\n    r = 0.25\n    T = 50\n    return run_heat_explicit(N, r, T, tol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    N = 31\n    tol = 1e-12\n    # Run tests E1, E2, P1, P2, P3 in order.\n    results = []\n    results.append(test_E1(N, tol))\n    results.append(test_E2(N, tol))\n    results.append(test_P1(N, tol))\n    results.append(test_P2(N, tol))\n    results.append(test_P3(N, tol))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3419390"}]}