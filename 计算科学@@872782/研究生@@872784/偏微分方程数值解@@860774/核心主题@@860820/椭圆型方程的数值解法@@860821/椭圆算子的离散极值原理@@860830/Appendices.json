{"hands_on_practices": [{"introduction": "在深入研究偏微分方程的数值格式之前，让我们通过一个纯粹的代数练习来建立核心直觉。此练习旨在阐明离散极值原理所需的矩阵属性，特别是揭示了对称正定性本身并不足以保证该原理成立。通过这个反例 [@problem_id:3379754]，我们将理解为什么离散矩阵的符号结构（即非正的非对角元素）是如此关键。", "problem": "考虑一个线性系统，该系统来自于一个在含三个内部节点的一维均匀网格上，对二阶椭圆边值问题使用齐次狄利克雷边界条件进行有限差分法离散化。假设离散算子使用具有正非对角元素的三对角模板，得到矩阵\n$$\nA \\;=\\; \\begin{pmatrix}\n2  1  0 \\\\\n1  2  1 \\\\\n0  1  2\n\\end{pmatrix}.\n$$\n从以下基本定义出发：一个矩阵是对称正定（SPD）的，当且仅当其所有顺序主子式均为正（Sylvester准则）；以及椭圆算子的离散比较原理要求相关的刚度矩阵是一个逆正矩阵（例如，一个具有非正非对角元素的$M$-矩阵），这保证了非负的载荷向量会产生非负的离散解。除了这些基本事实外，不引用任何现成的定理，完成以下任务：\n\n1. 使用Sylvester准则验证$A$是对称正定的。\n2. 计算$A^{-1}$的足够多的元素，以判断$A^{-1}$是否逐项非负。\n3. 根据椭圆算子的离散比较原理来解释你的发现，具体方法是给出一个非负的载荷向量$f$，使得离散解$u = A^{-1} f$有一个负分量，并根据$A$的符号结构解释其失效的机制。\n\n你最终报告的答案必须是$A^{-1}$的(1,2)元素，写成一个无单位的最简分数。不需要四舍五入。", "solution": "该问题要求在椭圆算子离散比较原理的背景下，对矩阵$A$进行多部分分析。分析将按要求分三步进行。\n\n首先，给定的矩阵是：\n$$\nA \\;=\\; \\begin{pmatrix}\n2  1  0 \\\\\n1  2  1 \\\\\n0  1  2\n\\end{pmatrix}\n$$\n问题陈述提供了要使用的定义：如果一个矩阵是对称的，并且其所有顺序主子式都为正，则该矩阵是对称正定的（SPD）（Sylvester准则）。如果一个矩阵是逆正的（其逆矩阵的所有元素都非负），则离散比较原理成立。\n\n1.  **对称正定（SPD）性质的验证**\n\n根据Sylvester准则，一个对称矩阵是正定的，当且仅当其所有顺序主子式都为正。\n\n首先，我们观察到$A$是对称的，因为$A^T = A$。\n\n接下来，我们计算$A$的顺序主子式。设$A_k$为$A$左上角的$k \\times k$子矩阵。\n\n第一个顺序主子式是$A_1$的行列式：\n$$\n\\det(A_1) = \\det \\begin{pmatrix} 2 \\end{pmatrix} = 2\n$$\n由于$2  0$，此条件满足。\n\n第二个顺序主子式是$A_2$的行列式：\n$$\n\\det(A_2) = \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = (2)(2) - (1)(1) = 4 - 1 = 3\n$$\n由于$3  0$，此条件满足。\n\n第三个顺序主子式是$A_3 = A$的行列式：\n$$\n\\det(A_3) = \\det(A) = \\det \\begin{pmatrix}\n2  1  0 \\\\\n1  2  1 \\\\\n0  1  2\n\\end{pmatrix}\n$$\n我们可以通过沿第一行进行代数余子式展开来计算它：\n$$\n\\det(A) = 2 \\cdot \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} - 1 \\cdot \\det \\begin{pmatrix} 1  1 \\\\ 0  2 \\end{pmatrix} + 0 = 2(3) - 1((1)(2) - (1)(0)) = 6 - 2 = 4\n$$\n由于$4  0$，此条件也满足。\n\n对称矩阵$A$的所有顺序主子式（$2$、$3$和$4$）都为正。因此，根据Sylvester准则，矩阵$A$是对称正定的。\n\n2.  **计算$A^{-1}$以检查其逆正性**\n\n为了确定$A$是否是逆正矩阵，我们必须计算其逆矩阵$A^{-1}$。我们可以使用公式 $A^{-1} = \\frac{1}{\\det(A)} \\text{adj}(A)$，其中$\\text{adj}(A)$是$A$的伴随矩阵，也就是代数余子式矩阵$C$的转置。\n\n从上一步可知，$\\det(A) = 4$。\n\n现在，我们计算代数余子式矩阵$C$，其中$C_{ij} = (-1)^{i+j} M_{ij}$，$M_{ij}$是元素$a_{ij}$的子式。\n$$\nC_{11} = (-1)^{1+1} \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = 3\n$$\n$$\nC_{12} = (-1)^{1+2} \\det \\begin{pmatrix} 1  1 \\\\ 0  2 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{13} = (-1)^{1+3} \\det \\begin{pmatrix} 1  2 \\\\ 0  1 \\end{pmatrix} = 1\n$$\n$$\nC_{21} = (-1)^{2+1} \\det \\begin{pmatrix} 1  0 \\\\ 1  2 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{22} = (-1)^{2+2} \\det \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix} = 4\n$$\n$$\nC_{23} = (-1)^{2+3} \\det \\begin{pmatrix} 2  1 \\\\ 0  1 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{31} = (-1)^{3+1} \\det \\begin{pmatrix} 1  0 \\\\ 2  1 \\end{pmatrix} = 1\n$$\n$$\nC_{32} = (-1)^{3+2} \\det \\begin{pmatrix} 2  0 \\\\ 1  1 \\end{pmatrix} = -(2-0) = -2\n$$\n$$\nC_{33} = (-1)^{3+3} \\det \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} = 3\n$$\n所以，代数余子式矩阵是：\n$$\nC = \\begin{pmatrix}\n3  -2  1 \\\\\n-2  4  -2 \\\\\n1  -2  3\n\\end{pmatrix}\n$$\n伴随矩阵是$C$的转置。由于$C$是对称的，所以$\\text{adj}(A) = C^T = C$。\n$$\n\\text{adj}(A) = \\begin{pmatrix}\n3  -2  1 \\\\\n-2  4  -2 \\\\\n1  -2  3\n\\end{pmatrix}\n$$\n最后，逆矩阵是：\n$$\nA^{-1} = \\frac{1}{4} \\begin{pmatrix}\n3  -2  1 \\\\\n-2  4  -2 \\\\\n1  -2  3\n\\end{pmatrix} = \\begin{pmatrix}\n\\frac{3}{4}  -\\frac{1}{2}  \\frac{1}{4} \\\\\n-\\frac{1}{2}  1  -\\frac{1}{2} \\\\\n\\frac{1}{4}  -\\frac{1}{2}  \\frac{3}{4}\n\\end{pmatrix}\n$$\n矩阵$A^{-1}$包含负元素，例如$(A^{-1})_{12} = -1/2$。因此，$A$不是一个逆正矩阵。\n\n3.  **解释与失效说明**\n\n离散比较原理要求离散算子（矩阵）是逆正的。这确保了对于一个非负的载荷向量$f \\ge 0$（逐分量），解$u = A^{-1}f$也是非负的，$u \\ge 0$。由于我们已经证明$A$不是逆正的，所以对于这个算子，比较原理失效。\n\n为了展示这种失效，我们需要找到一个非负向量$f$，使得$u = A^{-1}f$至少有一个负分量。$A^{-1}$中的负元素指导我们的选择。让我们选择一个载荷向量$f$，它能分离出$A^{-1}$中某个负元素的影响。考虑在第二个内部节点施加单位载荷，而在其他地方载荷为零的载荷向量$f$：\n$$\nf = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\n这个向量显然是非负的。那么解$u$由下式给出：\n$$\nu = A^{-1}f = \\begin{pmatrix}\n\\frac{3}{4}  -\\frac{1}{2}  \\frac{1}{4} \\\\\n-\\frac{1}{2}  1  -\\frac{1}{2} \\\\\n\\frac{1}{4}  -\\frac{1}{2}  \\frac{3}{4}\n\\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -\\frac{1}{2} \\\\ 1 \\\\ -\\frac{1}{2} \\end{pmatrix}\n$$\n得到的解向量是$u = (-1/2, 1, -1/2)^T$。尽管载荷向量$f$是非负的，但$u$的第一个和第三个分量是负的。这明确地证明了离散比较原理的失效。\n\n这种失效的机制在于矩阵$A$的符号结构。一个矩阵是逆正矩阵的一个充分条件是它是一个非奇异的$M$-矩阵。如果一个矩阵是一个$Z$-矩阵并具有其他性质（例如，是SPD），那么它就是一个$M$-矩阵。$Z$-矩阵是指其所有非对角元素均为非正的矩阵。\n给定的矩阵$A$具有正的非对角元素，例如$a_{12} = 1  0$和$a_{23} = 1  0$。因此，$A$不是一个$Z$-矩阵，所以它也不可能是一个$M$-矩阵。\n\n对于像$-u''$这样的椭圆算子，标准的有限差分法会得到一个具有正对角元素和负非对角元素的矩阵（例如，模板为$[-1, 2, -1]$的三对角矩阵）。这样的矩阵是一个$Z$-矩阵，并且由于是对角占优的，它也是一个$M$-矩阵，从而保证了离散比较原理的成立。本问题中的矩阵$A$，由于其正的非对角元素，将对应于一个非椭圆算子（例如，与$+u''$相关的算子），对于这样的算子，我们不期望极值/比较原理成立。SPD性质不足以保证逆正性；非对角元素的符号结构是在此被违反的关键因素。\n$A^{-1}$的(1,2)元素是$-\\frac{1}{2}$。", "answer": "$$\\boxed{-\\frac{1}{2}}$$", "id": "3379754"}, {"introduction": "将理论应用于实践，我们现在考察有限差分法。此练习 [@problem_id:3379721] 探讨了在泊松方程中加入一个反应项如何直接影响离散化矩阵的对角元素，进而影响离散极值原理。通过分析不同反应系数下的数值结果，我们将亲手验证算子本身的代数结构是如何决定数值解是否满足物理约束的。", "problem": "考虑一个在单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 上带有齐次狄利克雷边界条件的线性二阶椭圆偏微分方程 (PDE)。我们关注的算子是 $L u = -\\Delta u + c\\,u$，其中 $\\Delta$ 表示拉普拉斯算子，$c$ 是一个实常数。离散极值原理 (DMP) 在其一种常见的离散形式中指出，对于这样一个算子的单调离散化，如果离散右端项是非正的，并且边界数据也是非正的，那么离散解在任何地方都是非正的，并且任何离散最大值都在边界上达到。您的任务是分析并数值验证标准五点有限差分 (FD) 离散化对于算子 $L u$ 何时满足 DMP，并在其失效时给出一个数值反例。\n\n从偏微分方程数值解的基本原理出发：\n- 在每个空间方向上间距为 $h$ 的均匀网格上进行有限差分 (FD) 离散化。\n- 对内部网格点上的拉普拉斯算子使用五点格式。\n- 离散极值原理 (DMP) 的定义以及单调矩阵（也称为具有非正非对角元素且逆矩阵保持非负性的矩阵）的作用。\n\n您必须：\n1. 在一个均匀的 $N\\times N$ 内部网格上，为 $L u = -\\Delta u + c\\,u$ 构建标准的五点 FD 离散化，并在 $\\partial\\Omega$ 上施加齐次狄利克雷边界条件。\n2. 基于第一性原理，解释为什么添加一个非负反应项 ($c\\ge 0$) 会使此离散化保持 DMP，以及为什么一个负反应项 ($c0$) 可能破坏 DMP。\n3. 实现一个程序，对于几个测试用例，组装内部未知量的离散线性系统，求解它，并检查 DMP 的结论是否满足。使用下面每个测试用例指定的离散右端项值和边界值。将 DMP 结论解释为：对于齐次狄利克雷边界数据 $u=0$ 和非正离散右端项，离散解必须满足 $\\max u \\le 0$；等价地，内部最大值不能超过边界最大值。\n\n测试套件：\n- 测试 1：$N=20$, $c=0$，所有内部网格点的离散右端项 $f_{ij}\\equiv -1$；预期 DMP 成立，即内部离散解满足 $\\max u \\le 0$。\n- 测试 2：$N=20$, $c=5$，所有内部网格点的离散右端项 $f_{ij}\\equiv -1$；预期 DMP 成立，即 $\\max u \\le 0$。\n- 测试 3：$N=3$, $c=0$，所有内部网格点的离散右端项 $f_{ij}\\equiv 0$；预期 DMP 在平凡意义下成立，即 $\\max u \\le 0$。\n- 测试 4：$N=10$, $c=-2000$，离散右端项等于中心内部网格点处值为 $+1$ 的点源，其他地方为 $0$（齐次狄利克雷边界）。此设计旨在演示 $c0$ 时的情况：检查 DMP 是否因存在严格为正的内部值而被违反，即是否 $\\max u  0$。\n\n实现细节：\n- 使用一个每个空间维度有 $N$ 个内部点的均匀网格；网格间距为 $h = 1/(N+1)$。\n- 使用标准的五点格式离散化 $-\\Delta$ 算子，并在内部点上使用逐点的反应项 $c\\,u$ 来离散化算子 $L u = -\\Delta u + c\\,u$。\n- 使用二维拉普拉斯算子的标准克罗内克和构造方法，组装对应于内部未知量的稀疏矩阵。\n- 对仅含内部点的系统，以常规方式施加齐次狄利克雷边界条件（当边界数据为零时，右端项没有边界贡献）。\n- 对于每个测试用例，求解内部未知量的线性系统，并根据测试的预期评估离散极值原理。\n\n数值容差和结果类型：\n- 在检查如 $\\max u \\le 0$ 的不等式时，使用 $10^{-12}$ 的数值容差，以避免浮点舍入导致错误的失败。\n- 对于测试 1–3，返回一个布尔值，指示 DMP 是否成立（如果 $\\max u \\le 10^{-12}$ 则为 True，否则为 False）。\n- 对于测试 4，返回一个布尔值，指示 DMP 是否被违反（如果 $\\max u  10^{-12}$ 则为 True，否则为 False）。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，按测试套件的顺序排列结果：$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$，其中每个条目都是一个布尔值。", "solution": "该问题要求分析在单位正方形上具有齐次狄利克雷边界条件的线性椭圆算子 $L u = -\\Delta u + c\\,u$ 的离散极值原理 (DMP)。我们将首先基于有限差分离散化和 M-矩阵的原理提供理论解释，然后对指定的测试用例进行数值验证。\n\n### 步骤 1：算子的离散化\n\n我们考虑在域 $\\Omega = (0,1)\\times(0,1)$ 上的一个均匀网格，每个方向有 $N$ 个内部点。网格间距为 $h = 1/(N+1)$。一个内部网格点表示为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{1, \\dots, N\\}$。该点的解为 $u_{ij} = u(x_i, y_j)$。\n\n算子为 $L u = -\\Delta u + c\\,u$。我们使用标准的五点格式来近似负拉普拉斯算子 $-\\Delta u$：\n$$\n(-\\Delta u)|_{(x_i, y_j)} \\approx -\\frac{u_{i+1,j} - 2u_{ij} + u_{i-1,j}}{h^2} - \\frac{u_{i,j+1} - 2u_{ij} + u_{i,j-1}}{h^2} = \\frac{4u_{ij} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}\n$$\n因此，PDE $L u = f$ 在点 $(x_i, y_j)$ 处的离散形式为：\n$$\n\\frac{4u_{ij} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} + c u_{ij} = f_{ij}\n$$\n齐次狄利克雷边界条件意味着对于任何与边界相邻的点 $(x_i, y_j)$，其在边界点上的 $u$ 值为零。例如，如果 $i=1$，则 $u_{0,j}=0$。\n\n我们可以将 $N^2$ 个内部未知数 $u_{ij}$ 排列成一个大小为 $N^2 \\times 1$ 的向量 $\\mathbf{u}$。离散方程随后形成一个线性系统 $A\\mathbf{u} = \\mathbf{f}$，其中 $A$ 是一个 $N^2 \\times N^2$ 的矩阵。通过重新整理离散方程的各项，我们可以确定矩阵 $A$ 的元素。对应于未知数 $u_{ij}$ 的方程是：\n$$\n\\left(\\frac{4}{h^2} + c\\right)u_{ij} - \\frac{1}{h^2}u_{i-1,j} - \\frac{1}{h^2}u_{i+1,j} - \\frac{1}{h^2}u_{i,j-1} - \\frac{1}{h^2}u_{i,j+1} = f_{ij}\n$$\n由此，我们推断出矩阵 $A$ 的结构：\n- 对角线元素为 $A_{kk} = \\frac{4}{h^2} + c$。\n- 非对角线元素 $A_{kl}$ 若未知数 $l$ 对应于网格上未知数 $k$ 的直接邻居，则等于 $-\\frac{1}{h^2}$，否则为 $0$。\n\n### 步骤 2：离散极值原理与 M-矩阵\n\n离散极值原理与系统矩阵 $A$ 的性质密切相关。具体来说，对于问题中陈述的 DMP 版本（非正强迫项和边界数据意味着非正解），一个充分条件是 $A$ 是一个 **M-矩阵**。\n\n一个 M-矩阵被定义为满足以下条件的矩阵 $A$：\n1. $A$ 是一个 **Z-矩阵**：其所有非对角线元素都是非正的（$A_{kl} \\le 0$ for $k \\ne l$）。\n2. $A$ 的逆矩阵是非负的：$A^{-1} \\ge 0$（逐元素）。\n\n对于 Z-矩阵，条件 $A^{-1} \\ge 0$ 等价于 $A$ 的所有特征值都具有正实部。\n\n让我们分析我们离散化得到的矩阵 $A$。\n1.  **Z-矩阵性质**：非对角线元素要么是 $0$，要么是 $-\\frac{1}{h^2}$。由于 $h^20$，这些元素都是非正的。因此，$A$ 总是一个 Z-矩阵。\n2.  **特征值条件**：矩阵 $A$ 是对称的，所以它的特征值是实数。我们需要确定它的所有特征值何时为正。矩阵 $A$ 可以写成 $A = \\frac{1}{h^2} A_{\\text{lap}} + cI$，其中 $A_{\\text{lap}}$ 是对应于五点格式的矩阵（对角线元素为 $4$，非对角线元素为 $-1$），$I$ 是单位矩阵。$\\frac{1}{h^2}A_{\\text{lap}}$ 的特征值是离散负拉普拉斯算子的特征值，它们都是正的。设这些特征值为 $\\lambda_{k,l}  0$。那么 $A$ 的特征值是 $\\mu_{k,l} = \\lambda_{k,l} + c$。要使 $A$成为 M-矩阵，它的所有特征值都必须为正：\n    $$ \\mu_{k,l} = \\lambda_{k,l} + c  0 \\quad \\text{for all } k, l $$\n    这等价于要求 $c  -\\min_{k,l}(\\lambda_{k,l})$。离散拉普拉斯算子的最小特征值是 $\\lambda_{1,1} = \\frac{4}{h^2}\\left(1 - \\cos\\left(\\frac{\\pi}{N+1}\\right)\\right)$，它是严格为正的。\n\n现在我们可以分析对 $c$ 的条件。\n\n**情况 1：$c \\ge 0$（测试 1, 2, 3）**\n如果 $c \\ge 0$，那么由于所有 $\\lambda_{k,l}  0$，$A$ 的特征值 $\\mu_{k,l} = \\lambda_{k,l} + c$ 必定为正。因此，对于任何 $c \\ge 0$，$A$ 都是一个 M-矩阵。\n系统的解是 $\\mathbf{u} = A^{-1}\\mathbf{f}$。问题指定了齐次狄利克雷边界条件（在 $\\partial\\Omega$ 上 $u=0$）和一个非正的右端项 $\\mathbf{f} \\le 0$。由于 $A$ 是一个 M-矩阵，$A^{-1}$ 的所有元素都是非负的。一个非负矩阵和一个非正向量的乘积产生一个非正向量：$\\mathbf{u} = A^{-1}\\mathbf{f} \\le 0$。\n内部解是非正的。由于边界值为 $0$，离散解在整个域（内部和边界）上的最大值为 $0$。这满足了 DMP 条件 $\\max u \\le 0$。这证实了对测试 1、2 和 3 的预期。\n\n**情况 2：$c  0$（测试 4）**\n如果 $c$ 是负数，DMP 可能会失效。如果 $c \\le -\\lambda_{1,1}$，M-矩阵性质就会丧失。在测试 4 中，$N=10$，所以 $h=1/11$，并且 $\\lambda_{1,1} \\approx 4(11)^2\\left(1 - \\cos(\\pi/11)\\right) \\approx 19.6$。值 $c=-2000$ 远小于 $-\\lambda_{1,1}$，所以 $A$ 有负特征值，不是一个 M-矩阵。\n\n当 $A$ 不是 M-矩阵时，DMP 的结论不一定成立。我们可以使用极值原理的经典证明论证来研究这一点。假设解 $\\mathbf{u}$ 在某个节点 $k$ 处有一个严格为正的内部最大值 $u_{max}  0$。在这个节点上，$u_k = u_{max}$ 并且对于所有相邻节点 $j$，$u_j \\le u_{max}$。节点 $k$ 的方程是：\n$$ \\left(\\frac{4}{h^2} + c\\right)u_k + \\sum_{j \\sim k} \\left(-\\frac{1}{h^2}\\right) u_j = f_k $$\n重新整理得到：\n$$ c u_k + \\frac{1}{h^2}\\left(4u_k - \\sum_{j \\sim k} u_j\\right) = f_k $$\n由于 $u_k$ 是最大值，括号中的项是非负的：$4u_k - \\sum u_j \\ge 0$。\n因此，我们必须有 $f_k \\ge c u_k$。\n\n如果 $c \\ge 0$ 且我们有一个非正的右端项 $f_k \\le 0$，这将导致 $0 \\ge f_k \\ge c u_k \\ge 0$，这意味着 $u_k=0$，与 $u_{max}0$ 矛盾。这证明了对于 $c \\ge 0$ 的 DMP。\n\n然而，如果 $c  0$（如测试 4），这个论证不会导致矛盾。条件变为 $f_k \\ge c u_{max}$。因为 $c0$ 且 $u_{max}0$，右侧 $c u_{max}$ 是负的。对于一个非负的右端项（$f_k \\ge 0$），不等式 $f_k \\ge c u_{max}$ 总是成立的。因此，这个论证并不禁止正内部最大值的存在。测试 4 旨在数值上展示这样一个场景，其中 M-矩阵性质的丧失导致了对 DMP 结论的违反。\n\n### 步骤 3：数值验证\n\n提供的 Python 代码实现了上述逻辑。\n- 它使用克罗内克和的表述方法构建了 $N^2 \\times N^2$ 的稀疏矩阵 $A$，这种方法在计算上是高效的。创建了一维算子矩阵 $A_{1D}$，二维矩阵则形成为 $A = \\frac{1}{h^2}(I \\otimes A_{1D} + A_{1D} \\otimes I) + cI$。\n- 它为每个测试用例设置了相应的右端项向量 $\\mathbf{f}$。\n- 它使用稀疏线性求解器求解线性系统 $A\\mathbf{u}=\\mathbf{f}$。\n- 它找到解向量 $\\mathbf{u}$ 的最大值，并根据 $10^{-12}$ 的容差进行检查，以确定 DMP 是否成立或被违反，如每个测试所指定。\n\n运行代码的结果将证实我们的理论分析：测试 1-3，其中 $c \\ge 0$，将满足 DMP。测试 4，其中 $c$ 是一个大的负数，将显示出违例，尽管边界值为零，但仍会出现严格为正的内部最大值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse import linalg\n\ndef run_test(N, c, f_spec, test_id):\n    \"\"\"\n    Assembles and solves the discrete system for Lu = f and checks the DMP.\n\n    Args:\n        N (int): Number of interior grid points per dimension.\n        c (float): Reaction coefficient in the PDE.\n        f_spec (float or str): Specification for the right-hand side vector.\n                               A float value means a constant RHS.\n                               'point_source' means a central point source.\n        test_id (int): The ID of the test case (1-4).\n\n    Returns:\n        bool: The result of the DMP check for the specific test.\n    \"\"\"\n    # Grid spacing\n    h = 1.0 / (N + 1)\n\n    # 1. Assemble the matrix A\n    # The matrix corresponds to the operator (1/h^2)*(-Delta_h) + c*I\n    \n    # 1D Laplacian matrix (size N x N)\n    diag_1d = np.ones(N) * 2.0\n    offdiag_1d = np.ones(N - 1) * -1.0\n    A_1d = sparse.diags([offdiag_1d, diag_1d, offdiag_1d], [-1, 0, 1], format='csc')\n\n    # 2D Laplacian matrix using Kronecker sum (size N^2 x N^2)\n    # A_2d = I_N kron A_1d + A_1d kron I_N\n    I_n = sparse.identity(N, format='csc')\n    A_lap = sparse.kron(I_n, A_1d) + sparse.kron(A_1d, I_n)\n\n    # Full operator matrix A\n    I_n2 = sparse.identity(N**2, format='csc')\n    A = (1/h**2) * A_lap + c * I_n2\n    A = A.tocsc()\n\n    # 2. Assemble the right-hand side vector f\n    f = np.zeros(N**2)\n    if isinstance(f_spec, (int, float)):\n        f.fill(f_spec)\n    elif f_spec == 'point_source':\n        # Central interior grid point. For even N, there are 4 central points.\n        # We pick one, e.g., (floor(N/2), floor(N/2)) in 1-based indexing.\n        # Convert to 0-based indices:\n        center_i = N // 2\n        center_j = N // 2\n        \n        # Alternative for a more centered point for even N:\n        # center_i = N // 2 -1 for N>=2 else 0\n        # center_j = N // 2 -1 for N>=2 else 0\n\n        linear_index = center_i * N + center_j\n        f[linear_index] = 1.0\n\n    # 3. Solve the linear system Au = f\n    u = linalg.spsolve(A, f)\n\n    # 4. Check the Discrete Maximum Principle\n    max_u = np.max(u)\n    tol = 1.0e-12\n\n    if test_id in [1, 2, 3]:\n        # For non-positive RHS f and zero boundary, DMP holds if max(u) = 0.\n        return max_u = tol\n    elif test_id == 4:\n        # Check if DMP is violated by the presence of a strictly positive interior value.\n        # This means checking if max(u) > 0.\n        return max_u > tol\n    else:\n        raise ValueError(\"Invalid test_id\")\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs them, and prints results.\n    \"\"\"\n    # Test suite: (N, c, f_spec, test_id)\n    test_cases = [\n        (20, 0, -1.0, 1),\n        (20, 5, -1.0, 2),\n        (3, 0, 0.0, 3),\n        (10, -2000, 'point_source', 4)\n    ]\n\n    results = []\n    for N, c, f_spec, test_id in test_cases:\n        result = run_test(N, c, f_spec, test_id)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3379721"}, {"introduction": "最后，我们将目光转向另一种主流的数值方法——有限元法。与有限差分法不同，在有限元法中，离散极值原理的失效往往源于网格的几何特性。这个实践 [@problem_id:3379716] 将引导我们通过构建并扰动一个包含钝角的网格，来直观地观察刚度矩阵中如何出现正的非对角项，并最终导致数值解产生非物理的过冲。", "problem": "考虑单位正方形域 $\\Omega = [0,1]^2$ 上的标量扩散方程 $-\\nabla \\cdot (\\kappa \\nabla u) = f$，其具有齐次 Dirichlet 边界条件 $u|_{\\partial \\Omega} = 0$，其中 $\\kappa(x,y) \\equiv 1$ 且 $f(x,y)$ 是一个给定的源项。其弱形式为：求 $u \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, dx = \\int_{\\Omega} f v \\, dx.\n$$\n令 $\\mathcal{T}_h$ 为 $\\Omega$ 的一个协调三角剖分，并令 $\\{ \\varphi_i \\}$ 为 $\\mathcal{T}_h$ 上与网格节点相关联的标准连续分片线性（帽状）基函数。有限元方法旨在求解 $u_h \\in V_h \\subset H_0^1(\\Omega)$，使得\n$$\n\\sum_{i,j} K_{ij} U_j \\, \\varphi_i = \\sum_i F_i \\, \\varphi_i, \\quad \\text{with} \\quad K_{ij}=\\int_{\\Omega} \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, dx, \\quad F_i=\\int_{\\Omega} f \\varphi_i \\, dx,\n$$\n且 $U_j$ 是 $u_h$ 的节点值。对于常数 $f$，在每个面积为 $|T|$ 的三角形 $T \\in \\mathcal{T}_h$ 上，其局部载荷向量的各项由 $F_i^T = f|_T \\, |T|/3$ 给出，其中 $i$ 对应于 $T$ 中的三个局部顶点。局部单元刚度矩阵 $\\mathbf{K}^T$ 可以由局部基函数的常数梯度组装而成。在施加 Dirichlet 条件后，全局刚度矩阵 $\\mathbf{K}$ 在内部自由度上是对称正定的。\n\n离散极值原理指出，在合适的网格条件下，离散解 $u_h$ 遵守由连续极值原理所引申的符号约束。特别地，对于 $f \\le 0$ 和齐次 Dirichlet 边界条件，当简化刚度矩阵为 M-矩阵（即非对角元为非正且矩阵为弱对角占优）时，我们预期在内部节点处有 $u_h \\le 0$。在包含钝角的网格上，一些非对角元可能变为正数，从而违反 M-矩阵性质，并可能导致内部过冲（即尽管 $u|_{\\partial \\Omega}=0$ 且 $f \\le 0$，在域内部出现 $u_h  0$ 的值）。\n\n你的任务是实现一个程序，该程序能够：\n- 在 $\\Omega$ 上构建结构化三角网格，方法是将域细分为 $n_x \\times n_y$ 个矩形，并对所有整型网格点 $(i,j)$，通过从 $(i,j)$ 到 $(i+1,j+1)$ 的对角线将每个矩形分割成两个三角形。\n- 可选择性地通过一个小的位移向量扰动指定的内部网格节点，以创建带有钝角的三角剖分，同时保持所有节点都在 $\\Omega$ 内部。\n- 使用标准分片线性有限元方法为算子 $-\\Delta$ 和 $f(x,y)=-1$ 组装全局刚度矩阵 $\\mathbf{K}$ 和载荷向量 $\\mathbf{F}$。\n- 在所有满足 $x=0, x=1, y=0$ 或 $y=1$ 的节点上施加齐次 Dirichlet 边界条件，从而得到关于内部自由度的简化线性系统 $\\mathbf{K}_{II} \\mathbf{U}_I = \\mathbf{F}_I$。\n- 为每个网格计算简化系统的两个诊断指标：\n  1. $\\mathbf{K}_{II}$ 中是否存在超过阈值 $\\tau = 10^{-12}$ 的严格为正的非对角元。\n  2. 离散解 $u_h$ 的最大内部节点值是否超过同一阈值 $\\tau$，即 $\\max_{i \\in I} U_i  \\tau$（相对于边界数据 $u=0$ 的内部过冲）。\n- 对每个测试用例，返回这两个诊断指标的逻辑与（logical conjunction）所对应的布尔值，即，当且仅当简化刚度矩阵存在正的非对角元且相应的离散解表现出内部过冲时，它应返回 $true$。\n\n使用以下有限的测试用例集（这构成了评估不同场景的测试套件）：\n\n- 案例 A（基准网格，无扰动；预期总体上为非钝角）：\n  - 参数：$(n_x, n_y) = (3,3)$。\n  - 扰动：无（所有节点位移均为 $(0,0)$）。\n\n- 案例 B（设计用于创建钝角构型；选择能触发两个诊断指标的最小允许尺度）：\n  - 参数：$(n_x, n_y) = (3,3)$。\n  - 扰动模式在网格坐标中的索引 $(i,j)$ 上定义，其中 $i \\in \\{0,\\dots,n_x\\}$, $j \\in \\{0,\\dots,n_y\\}$，具体如下：\n    - 在 $(i,j)=(2,2)$ 处，添加基础位移 $(\\delta x, \\delta y) = (0.28,-0.15)$。\n    - 在 $(i,j)=(1,2)$ 处，添加基础位移 $(\\delta x, \\delta y) = (-0.12,0.09)$。\n    - 所有其他节点的位移均为 $(\\delta x, \\delta y)=(0,0)$。\n  - 令 $\\mathcal{S} = \\{0.2, 0.4, 0.6, 0.8, 1.0\\}$。应用按因子 $s \\in \\mathcal{S}$ 缩放的扰动模式，并选择 $\\mathcal{S}$ 中能使两个诊断指标都满足的最小的 $s$。如果不存在这样的 $s$，则使用 $s = 1.0$。\n  - 报告此选定网格的布尔值。\n\n- 案例 C（接近阈值的扰动，旨在避免违规）：\n  - 参数：$(n_x, n_y) = (3,3)$。\n  - 扰动模式与案例 B 相同，但固定尺度为 $s = 0.15$。\n\n在所有案例中，使用 $f(x,y) = -1$ 和齐次 Dirichlet 边界数据。此问题中没有需要报告的物理单位。您的程序应生成单行输出，其中包含三个案例的结果，格式为方括号内以逗号分隔的列表（例如，“[true,false,true]”），其中每个条目为“True”或“False”，大小写与 Python 编程语言的布尔字面量完全一致。用于确定正性和过冲的数值阈值必须为 $\\tau = 10^{-12}$。期望的最终输出格式仅为一行：\n\"[result_A,result_B,result_C]\"。", "solution": "用户提供的问题是一个有效、适定且科学严谨的偏微分方程数值解练习。它涉及 Poisson 方程的有限元分析及其与离散极值原理的关系。我现在将提供一个全面的解答。\n\n### 1. 问题描述\n所考虑的问题是二维域 $\\Omega$ 上的带有常数源项的标量 Poisson 方程：\n$$\n-\\Delta u = f \\quad \\text{in} \\quad \\Omega = [0,1]^2\n$$\n其服从齐次 Dirichlet 边界条件，即在边界 $\\partial\\Omega$ 上 $u = 0$。源项为常数 $f(x,y) = -1$。该问题的连续弱形式是：求 $u \\in H_0^1(\\Omega)$，使得对于所有测试函数 $v \\in H_0^1(\\Omega)$：\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\mathbf{x} = \\int_{\\Omega} f v \\, d\\mathbf{x}\n$$\n该算子的连续极值原理意味着，如果 $f \\le 0$，那么 $u$ 的最大值必须出现在边界 $\\partial\\Omega$ 上。由于在 $\\partial\\Omega$ 上 $u=0$，这意味着对于所有 $\\mathbf{x} \\in \\Omega$ 都有 $u(\\mathbf{x}) \\le 0$。\n\n### 2. 有限元离散化\n\n#### 2.1. 网格与基函数\n域 $\\Omega$ 使用结构化三角网格进行离散化。首先，生成一个 $(n_x+1) \\times (n_y+1)$ 个节点的均匀网格，其初始坐标为 $P_{i,j} = (i/n_x, j/n_y)$，其中 $i \\in \\{0, \\dots, n_x\\}$ 且 $j \\in \\{0, \\dots, n_y\\}$。这些节点定义了 $n_x \\times n_y$ 个矩形单元。每个由顶点 $(i,j)$, $(i+1,j)$, $(i,j+1)$ 和 $(i+1,j+1)$ 定义的矩形，都通过连接网格点 $(i,j)$ 和 $(i+1,j+1)$ 的对角线被细分为两个三角形。特定的内部节点可能会从其初始位置发生扰动。\n\n有限元空间 $V_h$ 由连续分片线性函数构成。$V_h$ 的基是“帽状”函数集 $\\{\\varphi_k\\}$，其中 $\\varphi_k$ 在节点 $k$ 处等于 $1$，在所有其他节点处等于 $0$。离散解 $u_h$ 表示为这些基函数的线性组合：\n$$\nu_h(\\mathbf{x}) = \\sum_{j} U_j \\varphi_j(\\mathbf{x})\n$$\n其中 $U_j$ 是解的未知节点值。\n\n#### 2.2. 单元刚度矩阵和载荷向量\n有限元方法导出一个线性系统 $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$，其中 $\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{F}$ 是全局载荷向量。它们是通过在每个三角形单元 $T \\in \\mathcal{T}_h$ 上计算局部贡献量并进行组装得到的。\n\n对于具有顶点 $\\mathbf{p}_a, \\mathbf{p}_b, \\mathbf{p}_c$ 的单个三角形 $T$，其 $3 \\times 3$ 局部刚度矩阵 $\\mathbf{K}^T$ 的各项由下式给出：\n$$\nK^T_{ij} = \\int_T \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, d\\mathbf{x} = (\\nabla \\varphi_i \\cdot \\nabla \\varphi_j) |T|\n$$\n其中 $|T|$ 是三角形的面积。线性基函数 $\\varphi_i$ 的梯度在整个三角形上是常数。对于顶点为 $\\mathbf{p}_1=(x_1, y_1)$、$\\mathbf{p}_2=(x_2, y_2)$ 和 $\\mathbf{p}_3=(x_3, y_3)$ 的三角形，相应局部基函数的梯度为：\n$$\n\\nabla \\varphi_1 = \\frac{1}{2|T|} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}, \\quad \\nabla \\varphi_2 = \\frac{1}{2|T|} \\begin{pmatrix} y_3 - y_1 \\\\ x_1 - x_3 \\end{pmatrix}, \\quad \\nabla \\varphi_3 = \\frac{1}{2|T|} \\begin{pmatrix} y_1 - y_2 \\\\ x_2 - x_1 \\end{pmatrix}\n$$\n面积 $|T|$ 可计算为 $|T| = \\frac{1}{2} |x_1(y_2-y_3) + x_2(y_3-y_1) + x_3(y_1-y_2)|$。一个非对角元，例如 $K^T_{12}$，通过余切公式与顶点 $\\mathbf{p}_3$ 处的角 $\\theta_3$ 相关：$K^T_{12} = -\\frac{1}{2}\\cot(\\theta_3)$。如果角 $\\theta_3$ 是钝角，该项将变为正值。\n\n局部载荷向量 $\\mathbf{F}^T$ 的项为 $F_i^T = \\int_T f \\varphi_i \\, d\\mathbf{x}$。对于常数源项 $f$，该积分的计算结果为：\n$$\nF_i^T = f \\frac{|T|}{3}\n$$\n给定 $f=-1$，各项为 $F_i^T = -|T|/3$。\n\n### 3. 系统组装和边界条件\n全局刚度矩阵 $\\mathbf{K}$ 和载荷向量 $\\mathbf{F}$ 是通过遍历网格中的所有三角形，并根据单元顶点的全局索引将局部单元贡献量 $\\mathbf{K}^T$ 和 $\\mathbf{F}^T$ 添加到全局系统中来构建的。\n\n在 $\\partial\\Omega$ 上的齐次 Dirichlet 边界条件 $u=0$ 意味着所有边界节点 $j \\in B$ 的节点值 $U_j$ 都固定为 $0$。线性系统被划分为内部（I）和边界（B）自由度：\n$$\n\\begin{pmatrix} \\mathbf{K}_{II}  \\mathbf{K}_{IB} \\\\ \\mathbf{K}_{BI}  \\mathbf{K}_{BB} \\end{pmatrix}\n\\begin{pmatrix} \\mathbf{U}_I \\\\ \\mathbf{U}_B \\end{pmatrix}\n=\n\\begin{pmatrix} \\mathbf{F}_I \\\\ \\mathbf{F}_B \\end{pmatrix}\n$$\n设 $\\mathbf{U}_B = \\mathbf{0}$，系统简化为求解未知的内部节点值 $\\mathbf{U}_I$：\n$$\n\\mathbf{K}_{II} \\mathbf{U}_I = \\mathbf{F}_I\n$$\n其中 $\\mathbf{K}_{II}$ 是对应于内部-内部相互作用的子矩阵，$\\mathbf{F}_I$ 是内部节点上的载荷子向量。\n\n### 4. 数值诊断与离散极值原理\n如果一个刚度矩阵的非对角元均为非正（$K_{ij} \\le 0$ for $i \\ne j$）并且它是弱对角占优的，则该矩阵是一个 M-矩阵。如果简化刚度矩阵 $\\mathbf{K}_{II}$ 是一个 M-矩阵，那么 $(\\mathbf{K}_{II})^{-1}$ 的所有元素都将是非负的。由于 $\\mathbf{F}_I$ 的元素是非正的（因为 $f=-1$），解 $\\mathbf{U}_I = (\\mathbf{K}_{II})^{-1} \\mathbf{F}_I$ 的元素也将是非正的，从而满足离散极值原理（$U_i \\le 0$）。\n\n三角剖分中钝角的存在可能导致 $\\mathbf{K}_{II}$ 中出现正的非对角元，从而违反 M-矩阵性质。这反过来可能导致离散极值原理被违反，表现为`过冲`（overshoot），即尽管边界条件和外力项表明内部节点值应为非正，但某些内部节点值 $U_i$ 变为正值。该任务要求使用数值容差 $\\tau=10^{-12}$ 检查两个条件：\n1.  **正的非对角元**：是否存在一个元素 $(\\mathbf{K}_{II})_{ij}  \\tau$（其中 $i \\ne j$）。\n2.  **内部过冲**：最大内部节点值 $\\max(\\mathbf{U}_I)$ 是否大于 $\\tau$。\n\n每个测试用例的最终布尔结果是这两个条件的逻辑与。\n\n### 5. 测试用例的计算流程\n每个测试用例的实现将遵循以下步骤：\n1.  为给定的 $(n_x, n_y)$ 生成网格节点坐标，并应用任何指定的扰动。\n2.  基于结构化网格拓扑定义三角形列表。\n3.  识别与内部和边界节点相对应的全局索引。\n4.  通过遍历所有三角形来组装全局刚度矩阵 $\\mathbf{K}$ 和载荷向量 $\\mathbf{F}$。\n5.  提取简化系统 $\\mathbf{K}_{II}$ 和 $\\mathbf{F}_I$。\n6.  求解线性系统 $\\mathbf{K}_{II} \\mathbf{U}_I = \\mathbf{F}_I$ 以得到 $\\mathbf{U}_I$。\n7.  对 $\\mathbf{K}_{II}$ 和 $\\mathbf{U}_I$ 执行两个诊断检查。\n8.  对于案例 B，对指定的缩放因子 $s \\in \\{0.2, 0.4, 0.6, 0.8, 1.0\\}$ 迭代此过程，选择满足两个诊断指标的最小 $s$。如果不存在这样的 $s$，则使用 $s=1.0$ 的结果。\n9.  返回两个诊断布尔值的逻辑与。\n\n此流程在下面的 Python 代码中实现。", "answer": "```python\nimport numpy as np\n\ndef assemble_and_solve(nx, ny, perturbations, f_val, tau):\n    \"\"\"\n    Assembles and solves the FEM system for the Poisson equation.\n\n    Args:\n        nx (int): Number of subdivisions in x-direction.\n        ny (int): Number of subdivisions in y-direction.\n        perturbations (dict): A dict mapping (i,j) grid indices to (dx,dy) perturbations.\n        f_val (float): The constant value of the source term f.\n        tau (float): The numerical threshold for positivity checks.\n\n    Returns:\n        tuple: A tuple of two booleans:\n               (has_positive_off_diagonal, has_overshoot)\n    \"\"\"\n    # 1. Generate node coordinates\n    n_nodes_x = nx + 1\n    n_nodes_y = ny + 1\n    num_nodes = n_nodes_x * n_nodes_y\n    \n    xs = np.linspace(0.0, 1.0, n_nodes_x)\n    ys = np.linspace(0.0, 1.0, n_nodes_y)\n    nodes = np.zeros((num_nodes, 2), dtype=float)\n\n    for j in range(n_nodes_y):\n        for i in range(n_nodes_x):\n            k = i + j * n_nodes_x\n            pert = perturbations.get((i, j), (0.0, 0.0))\n            nodes[k, 0] = xs[i] + pert[0]\n            nodes[k, 1] = ys[j] + pert[1]\n\n    # 2. Generate element connectivity\n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            n00 = i + j * n_nodes_x\n            n10 = (i + 1) + j * n_nodes_x\n            n01 = i + (j + 1) * n_nodes_x\n            n11 = (i + 1) + (j + 1) * n_nodes_x\n            # Split rectangle by diagonal from (i,j) to (i+1,j+1)\n            elements.append((n00, n10, n11))\n            elements.append((n00, n11, n01))\n\n    # 3. Identify interior and boundary nodes\n    interior_nodes_indices = []\n    for j in range(1, ny):\n        for i in range(1, nx):\n            interior_nodes_indices.append(i + j * n_nodes_x)\n    \n    num_interior_nodes = len(interior_nodes_indices)\n\n    # 4. Assemble global stiffness matrix K and load vector F\n    K = np.zeros((num_nodes, num_nodes), dtype=float)\n    F = np.zeros(num_nodes, dtype=float)\n\n    for el_nodes in elements:\n        p1, p2, p3 = nodes[el_nodes[0]], nodes[el_nodes[1]], nodes[el_nodes[2]]\n        \n        # Area of the triangle\n        area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        if area  1e-15: continue\n\n        # Gradients of basis functions\n        b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n        c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n        \n        # Local stiffness matrix\n        K_local = np.zeros((3, 3))\n        for i in range(3):\n            for j in range(3):\n                K_local[i, j] = (b[i] * b[j] + c[i] * c[j]) / (4.0 * area)\n\n        # Local load vector\n        F_local = (f_val * area / 3.0) * np.ones(3)\n\n        # Add to global matrix and vector (assembly)\n        for i in range(3):\n            F[el_nodes[i]] += F_local[i]\n            for j in range(3):\n                K[el_nodes[i], el_nodes[j]] += K_local[i, j]\n\n    # 5. Extract reduced system for interior nodes\n    K_II = K[np.ix_(interior_nodes_indices, interior_nodes_indices)]\n    F_I = F[interior_nodes_indices]\n\n    # 6. Solve the linear system\n    try:\n        U_I = np.linalg.solve(K_II, F_I)\n    except np.linalg.LinAlgError:\n        # Singular matrix, likely due to degenerate elements\n        # For this problem, treat as no overshoot and no positive off-diagonal\n        return (False, False)\n\n    # 7. Perform diagnostics\n    # Diagnostic 1: Check for strictly positive off-diagonal entries in K_II\n    K_II_offdiag = K_II.copy()\n    np.fill_diagonal(K_II_offdiag, 0.0)\n    has_pos_offdiag = np.any(K_II_offdiag > tau)\n    \n    # Diagnostic 2: Check for interior overshoot\n    has_overshoot = np.max(U_I) > tau if U_I.size > 0 else False\n\n    return has_pos_offdiag, has_overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    TAU = 1e-12\n    F_VAL = -1.0\n    NX, NY = 3, 3\n    results = []\n\n    # Case A: Baseline mesh\n    diag1_A, diag2_A = assemble_and_solve(NX, NY, {}, F_VAL, TAU)\n    results.append(diag1_A and diag2_A)\n\n    # Case B: Perturbation with smallest effective scale\n    base_perturbations = {(2, 2): (0.28, -0.15), (1, 2): (-0.12, 0.09)}\n    s_values = [0.2, 0.4, 0.6, 0.8, 1.0]\n    \n    result_B = None\n    result_s1 = None\n\n    for s in s_values:\n        current_perturbations = {\n            node: (s * dx, s * dy) for node, (dx, dy) in base_perturbations.items()\n        }\n        diag1, diag2 = assemble_and_solve(NX, NY, current_perturbations, F_VAL, TAU)\n        \n        current_result_is_true = diag1 and diag2\n        \n        if s == 1.0:\n            result_s1 = current_result_is_true\n        \n        if current_result_is_true and result_B is None:\n            result_B = True # Found smallest s, lock in True\n            \n    if result_B is None: # No s in the list worked\n        result_B = result_s1\n        \n    results.append(result_B if result_B is not None else False)\n\n    # Case C: Near-threshold perturbation\n    s_C = 0.15\n    perturbations_C = {\n        node: (s_C * dx, s_C * dy) for node, (dx, dy) in base_perturbations.items()\n    }\n    diag1_C, diag2_C = assemble_and_solve(NX, NY, perturbations_C, F_VAL, TAU)\n    results.append(diag1_C and diag2_C)\n    \n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3379716"}]}