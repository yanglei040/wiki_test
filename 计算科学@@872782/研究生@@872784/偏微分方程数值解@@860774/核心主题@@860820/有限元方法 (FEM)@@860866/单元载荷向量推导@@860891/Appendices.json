{"hands_on_practices": [{"introduction": "第一个实践是有限元方法中的一个基本练习。它将引导您逐步完成一个简单一维问题中单元载荷向量的推导和组装过程，从而巩固弱形式、形函数和数值积分等核心概念。掌握这个过程对于理解任何有限元模拟中外力如何被表示至关重要。[@problem_id:3383737]", "problem": "考虑在区间 $[0,2]$ 上的标量场 $u(x)$ 的一维边值问题，该问题由二阶线性偏微分方程 (PDE) $-u''(x)=f(x)$ 和齐次狄利克雷边界条件 $u(0)=0$ 及 $u(2)=0$ 控制。从弱形式出发（通过将PDE乘以索博列夫空间 $H_{0}^{1}([0,2])$ 中的任意检验函数 $v(x)$ 并进行分部积分得到），使用有限元法 (FEM) 对问题进行离散化，采用的基函数是定义在网格节点 $x_{0}=0$、$x_{1}=1$ 和 $x_{2}=2$ 上的连续分段线性拉格朗日基函数，从而形成两个单元 $[0,1]$ 和 $[1,2]$。设源项为 $f(x)=1+x$。仅使用弱形式、参考单元形函数以及从参考域到每个物理单元的仿射映射的基本定义，推导单元级右端项的贡献，并将它们组装成全局右端 (RHS) 载荷向量。为计算单元积分，请在标准区间 $[-1,1]$ 上使用能够对这些基函数和此源项产生精确矩的最低阶高斯求积 (GQ)。证明组装后的全局右端向量等于三个全局基函数 $N_{0}(x)$、$N_{1}(x)$ 和 $N_{2}(x)$ 的精确全局矩 $\\int_{0}^{2} f(x) N_{i}(x)\\,\\mathrm{d}x$。以包含三个条目的单行矩阵形式，给出最终组装的全局右端载荷向量。", "solution": "该问题是应用有限元法 (FEM) 求解一维边值问题的一个标准、定义明确的练习。所有必要的组成部分均已提供，并且在科学上和数学上是一致的。该问题是有效的，并且存在唯一可验证的解。\n\n控制微分方程是一维泊松方程：\n$$\n-u''(x) = f(x) \\quad \\text{for } x \\in [0, 2]\n$$\n源项为 $f(x) = 1+x$，齐次狄利克雷边界条件为 $u(0)=0$ 和 $u(2)=0$。\n\n第一步是推导弱形式。我们将方程乘以一个来自求解函数空间 $H_{0}^{1}([0,2])$ 的检验函数 $v(x)$，并在定义域 $\\Omega = [0,2]$ 上积分：\n$$\n-\\int_{0}^{2} u''(x) v(x) \\, \\mathrm{d}x = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x\n$$\n对左端项 (LHS) 应用分部积分，得到：\n$$\n\\int_{0}^{2} u'(x) v'(x) \\, \\mathrm{d}x - [u'(x)v(x)]_{0}^{2} = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x\n$$\n由于检验函数 $v(x) \\in H_{0}^{1}([0,2])$，它必须满足齐次边界条件 $v(0)=0$ 和 $v(2)=0$。因此，边界项 $[u'(x)v(x)]_{0}^{2}$ 为零。问题的弱形式为：求 $u(x) \\in H_{0}^{1}([0,2])$，使得对于所有 $v(x) \\in H_{0}^{1}([0,2])$，都有\n$$\n\\int_{0}^{2} u'(x) v'(x) \\, \\mathrm{d}x = \\int_{0}^{2} f(x) v(x) \\, \\mathrm{d}x \\quad \\forall v(x) \\in H_{0}^{1}([0,2])\n$$\n其形式为 $a(u,v) = L(v)$，其中 $a(u,v)$ 是双线性形式，$L(v)$ 是代表载荷的线性泛函。\n\n在有限元法中，我们离散化定义域，并将解 $u(x)$ 近似为基函数 $N_j(x)$ 的线性组合：$u_h(x) = \\sum_{j=0}^{2} u_j N_j(x)$。问题指定了在网格节点 $x_0=0$、$x_1=1$ 和 $x_2=2$ 上的连续分段线性拉格朗日基函数。这将定义域划分为两个单元：$\\Omega_1 = [0,1]$ 和 $\\Omega_2 = [1,2]$。离散问题通过对每个基函数 $N_i(x)$ 进行检验（即令 $v(x) = N_i(x)$）获得，从而得到一个线性方程组 $\\mathbf{K}\\mathbf{u} = \\mathbf{F}$，其中 $\\mathbf{K}$ 是刚度矩阵，$\\mathbf{F}$ 是全局载荷向量。载荷向量的分量由 $F_i = L(N_i)$ 给出，即：\n$$\nF_i = \\int_{0}^{2} f(x) N_i(x) \\, \\mathrm{d}x\n$$\n问题要求推导该向量 $\\mathbf{F}$ 及其分量 $F_0$、$F_1$ 和 $F_2$。该积分由单元级贡献组装而成：\n$$\nF_i = \\sum_{e=1}^{2} F_i^{(e)} = \\sum_{e=1}^{2} \\int_{\\Omega_e} f(x) N_i(x) \\, \\mathrm{d}x\n$$\n为计算这些积分，我们使用从带有坐标 $\\xi$ 的参考单元 $\\hat{\\Omega} = [-1,1]$ 到每个物理单元 $\\Omega_e = [x_L, x_R]$ 的仿射映射。映射为 $x(\\xi) = x_L + \\frac{h_e}{2}(1+\\xi)$，其中 $h_e = x_R - x_L$ 是单元长度。另一种常见形式是 $x(\\xi) = \\frac{x_R-x_L}{2}\\xi + \\frac{x_R+x_L}{2}$。微分元变换为 $\\mathrm{d}x = J_e \\, \\mathrm{d}\\xi$，其中雅可比为 $J_e = \\frac{\\mathrm{d}x}{\\mathrm{d}\\xi} = \\frac{h_e}{2}$。\n\n在参考单元 $\\hat{\\Omega}=[-1,1]$ 上，与局部节点 $\\xi=-1$ 和 $\\xi=1$ 相关联的线性拉格朗日形函数为：\n$$\n\\hat{N}_a(\\xi) = \\frac{1}{2}(1-\\xi) \\quad \\text{和} \\quad \\hat{N}_b(\\xi) = \\frac{1}{2}(1+\\xi)\n$$\n对于一个通用基函数 $\\hat{N}$，单元积分变为：\n$$\nF^{(e)} = \\int_{x_L}^{x_R} f(x) N(x) \\, \\mathrm{d}x = \\int_{-1}^{1} f(x(\\xi)) \\hat{N}(\\xi) J_e \\, \\mathrm{d}\\xi\n$$\n被积函数为 $I(\\xi) = f(x(\\xi)) \\hat{N}(\\xi) J_e$。由于 $f(x)=1+x$ 是线性多项式，映射 $x(\\xi)$ 是线性的，所以 $f(x(\\xi))$ 是关于 $\\xi$ 的线性多项式。形函数 $\\hat{N}(\\xi)$ 也是关于 $\\xi$ 的线性多项式。雅可比 $J_e$ 是一个常数。因此，被积函数 $I(\\xi)$ 是关于 $\\xi$ 的二次多项式。\n\n一个具有 $n$ 个点的高斯求积法则对于阶数最高为 $2n-1$ 的多项式是精确的。为了精确地积分一个二次多项式（阶数 $m=2$），我们需要 $2n-1 \\ge 2$，这意味着 $n \\ge 1.5$。因此，求积点的最小整数数量是 $n=2$。在 $[-1,1]$ 上的 2 点高斯求积法则使用求积点 $\\xi_{1,2} = \\mp \\frac{1}{\\sqrt{3}}$ 和权重 $w_{1,2} = 1$。\n\n**单元 1: $\\Omega_1 = [0,1]$**\n单元长度为 $h_1 = 1-0=1$。节点为 $x_0=0$ 和 $x_1=1$。\n映射：$x(\\xi) = \\frac{1}{2}\\xi + \\frac{1}{2}$。\n雅可比：$J_1 = \\frac{h_1}{2} = \\frac{1}{2}$。\n源项：$f(x(\\xi)) = 1+x(\\xi) = 1 + (\\frac{1}{2}\\xi + \\frac{1}{2}) = \\frac{3}{2} + \\frac{1}{2}\\xi$。\n局部贡献对应于全局节点 0 和 1。\n$F_0^{(1)} = \\int_0^1 f(x) N_0(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{3}{2} + \\frac{1}{2}\\xi) \\hat{N}_a(\\xi) J_1 \\, \\mathrm{d}\\xi$。被积函数为 $I_0(\\xi) = (\\frac{3}{2} + \\frac{1}{2}\\xi) \\frac{1}{2}(1-\\xi) \\frac{1}{2} = \\frac{1}{8}(3+\\xi)(1-\\xi)$。\n$F_0^{(1)} = \\sum_{k=1}^2 w_k I_0(\\xi_k) = I_0(-\\frac{1}{\\sqrt{3}}) + I_0(\\frac{1}{\\sqrt{3}})$。\n$I_0(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 - \\frac{1}{\\sqrt{3}})(1 + \\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 + \\frac{3}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{8}{3} + \\frac{2}{\\sqrt{3}})$。\n$I_0(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 + \\frac{1}{\\sqrt{3}})(1 - \\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 - \\frac{3}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{8}{3} - \\frac{2}{\\sqrt{3}})$。\n$F_0^{(1)} = \\frac{1}{8}(\\frac{8}{3} + \\frac{2}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{8}{3} - \\frac{2}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{16}{3}) = \\frac{2}{3}$。\n\n$F_1^{(1)} = \\int_0^1 f(x) N_1(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{3}{2} + \\frac{1}{2}\\xi) \\hat{N}_b(\\xi) J_1 \\, \\mathrm{d}\\xi$。被积函数为 $I_1(\\xi) = \\frac{1}{8}(3+\\xi)(1+\\xi)$。\n$F_1^{(1)} = I_1(-\\frac{1}{\\sqrt{3}}) + I_1(\\frac{1}{\\sqrt{3}})$。\n$I_1(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 - \\frac{1}{\\sqrt{3}})(1 - \\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 - \\frac{3}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{10}{3} - \\frac{4}{\\sqrt{3}})$。\n$I_1(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 + \\frac{1}{\\sqrt{3}})(1 + \\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(3 + \\frac{3}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{10}{3} + \\frac{4}{\\sqrt{3}})$。\n$F_1^{(1)} = \\frac{1}{8}(\\frac{10}{3} - \\frac{4}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{10}{3} + \\frac{4}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{20}{3}) = \\frac{5}{6}$。\n\n**单元 2: $\\Omega_2 = [1,2]$**\n单元长度为 $h_2 = 2-1=1$。节点为 $x_1=1$ 和 $x_2=2$。\n映射：$x(\\xi) = \\frac{1}{2}\\xi + \\frac{3}{2}$。\n雅可比：$J_2 = \\frac{h_2}{2} = \\frac{1}{2}$。\n源项：$f(x(\\xi)) = 1+x(\\xi) = 1 + (\\frac{1}{2}\\xi + \\frac{3}{2}) = \\frac{5}{2} + \\frac{1}{2}\\xi$。\n局部贡献对应于全局节点 1 和 2。\n$F_1^{(2)} = \\int_1^2 f(x) N_1(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{5}{2} + \\frac{1}{2}\\xi) \\hat{N}_a(\\xi) J_2 \\, \\mathrm{d}\\xi$。被积函数为 $I_1(\\xi) = \\frac{1}{8}(5+\\xi)(1-\\xi)$。\n$F_1^{(2)} = I_1(-\\frac{1}{\\sqrt{3}}) + I_1(\\frac{1}{\\sqrt{3}})$。\n$I_1(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 - \\frac{1}{\\sqrt{3}})(1 + \\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 + \\frac{5}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{14}{3} + \\frac{4}{\\sqrt{3}})$。\n$I_1(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 + \\frac{1}{\\sqrt{3}})(1 - \\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 - \\frac{5}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} - \\frac{1}{3}) = \\frac{1}{8}(\\frac{14}{3} - \\frac{4}{\\sqrt{3}})$。\n$F_1^{(2)} = \\frac{1}{8}(\\frac{14}{3} + \\frac{4}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{14}{3} - \\frac{4}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{28}{3}) = \\frac{7}{6}$。\n\n$F_2^{(2)} = \\int_1^2 f(x) N_2(x) \\, \\mathrm{d}x = \\int_{-1}^1 (\\frac{5}{2} + \\frac{1}{2}\\xi) \\hat{N}_b(\\xi) J_2 \\, \\mathrm{d}\\xi$。被积函数为 $I_2(\\xi) = \\frac{1}{8}(5+\\xi)(1+\\xi)$。\n$F_2^{(2)} = I_2(-\\frac{1}{\\sqrt{3}}) + I_2(\\frac{1}{\\sqrt{3}})$。\n$I_2(-\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 - \\frac{1}{\\sqrt{3}})(1 - \\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 - \\frac{5}{\\sqrt{3}} - \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{16}{3} - \\frac{6}{\\sqrt{3}})$。\n$I_2(+\\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 + \\frac{1}{\\sqrt{3}})(1 + \\frac{1}{\\sqrt{3}}) = \\frac{1}{8}(5 + \\frac{5}{\\sqrt{3}} + \\frac{1}{\\sqrt{3}} + \\frac{1}{3}) = \\frac{1}{8}(\\frac{16}{3} + \\frac{6}{\\sqrt{3}})$。\n$F_2^{(2)} = \\frac{1}{8}(\\frac{16}{3} - \\frac{6}{\\sqrt{3}}) + \\frac{1}{8}(\\frac{16}{3} + \\frac{6}{\\sqrt{3}}) = \\frac{1}{8}(\\frac{32}{3}) = \\frac{4}{3}$。\n\n**全局右端向量的组装**\n全局载荷向量 $\\mathbf{F}$ 是通过在相应的全局节点索引处将单元贡献相加形成的。\n$F_0 = F_0^{(1)} = \\frac{2}{3}$。\n$F_1 = F_1^{(1)} + F_1^{(2)} = \\frac{5}{6} + \\frac{7}{6} = \\frac{12}{6} = 2$。\n$F_2 = F_2^{(2)} = \\frac{4}{3}$。\n组装后的全局右端向量为 $\\mathbf{F} = \\begin{pmatrix} \\frac{2}{3} & 2 & \\frac{4}{3} \\end{pmatrix}^T$。\n\n**通过精确积分进行验证**\n我们通过直接计算全局矩来验证此结果。全局基函数为：\n$N_0(x) = \\begin{cases} 1-x & x \\in [0,1] \\\\ 0 & \\text{其他} \\end{cases}$\n$N_1(x) = \\begin{cases} x & x \\in [0,1] \\\\ 2-x & x \\in [1,2] \\end{cases}$\n$N_2(x) = \\begin{cases} x-1 & x \\in [1,2] \\\\ 0 & \\text{其他} \\end{cases}$\n\n$F_0 = \\int_0^2 (1+x)N_0(x)\\,\\mathrm{d}x = \\int_0^1 (1+x)(1-x)\\,\\mathrm{d}x = \\int_0^1 (1-x^2)\\,\\mathrm{d}x = [x - \\frac{x^3}{3}]_0^1 = 1 - \\frac{1}{3} = \\frac{2}{3}$。结果匹配。\n\n$F_1 = \\int_0^2 (1+x)N_1(x)\\,\\mathrm{d}x = \\int_0^1 (1+x)x\\,\\mathrm{d}x + \\int_1^2 (1+x)(2-x)\\,\\mathrm{d}x$。\n$\\int_0^1 (x+x^2)\\,\\mathrm{d}x = [\\frac{x^2}{2}+\\frac{x^3}{3}]_0^1 = \\frac{1}{2}+\\frac{1}{3} = \\frac{5}{6}$。\n$\\int_1^2 (2+x-x^2)\\,\\mathrm{d}x = [2x+\\frac{x^2}{2}-\\frac{x^3}{3}]_1^2 = (4+2-\\frac{8}{3}) - (2+\\frac{1}{2}-\\frac{1}{3}) = (\\frac{10}{3}) - (\\frac{13}{6}) = \\frac{20-13}{6} = \\frac{7}{6}$。\n$F_1 = \\frac{5}{6} + \\frac{7}{6} = \\frac{12}{6} = 2$。结果匹配。\n\n$F_2 = \\int_0^2 (1+x)N_2(x)\\,\\mathrm{d}x = \\int_1^2 (1+x)(x-1)\\,\\mathrm{d}x = \\int_1^2 (x^2-1)\\,\\mathrm{d}x = [\\frac{x^3}{3}-x]_1^2 = (\\frac{8}{3}-2) - (\\frac{1}{3}-1) = \\frac{2}{3} - (-\\frac{2}{3}) = \\frac{4}{3}$。结果匹配。\n\n使用高斯求积的计算被证实是精确的，正如理论所预测的那样。最终组装的全局右端载荷向量是正确的。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{2}{3} & 2 & \\frac{4}{3}\n\\end{pmatrix}\n}\n$$", "id": "3383737"}, {"introduction": "在基本原理的基础上，本实践将探讨混合有限元方法背景下的单元载荷向量。通过计算二维三角形上分片常数（$P_0$）单元的载荷贡献，您将了解一般理论如何应用于不同类型的单元空间和几何形状。这个练习突出了在高级格式中常见的低阶单元载荷向量计算的简便性和高效性。[@problem_id:3383766]", "problem": "考虑一个定义在多边形域上的标量椭圆型偏微分方程（PDE）的混合格式，其一阶形式写作 $p + \\nabla u = 0$ 和 $\\nabla \\cdot p = f$，其中 $p$ 是通量，$u$ 是标量势。在混合有限元方法中，设通量 $p$ 在最低阶 Raviart–Thomas 空间 $RT_0$ 中近似，标量场 $u$ 在分片常数空间 $P_0$ 中近似。在单个三角形单元 $K$ 上，与 $P_0$ 检验函数 $v$ 相关的单元右端项（载荷向量）贡献是局部积分 $b_K = \\int_K f\\,v\\,dx$。\n\n假设 $K$ 是一个仿射三角形，其顶点为 $(1,2)$、$(5,3)$ 和 $(2,7)$。在此单元上，设源项为常数 $f(x) \\equiv f_0$（对于所有 $x \\in K$），并选择 $P_0$ 检验函数为常数 $v(x) \\equiv c_K$（对于所有 $x \\in K$）。取 $f_0 = 7$ 和 $c_K = 2$。仅使用第一性原理（弱形式和仿射映射的变量替换），计算单元载荷贡献 $b_K = \\int_K f\\,v\\,dx$ 的精确值。\n\n将最终答案表示为单个实数。无需四舍五入。", "solution": "该问题是有效的。它在偏微分方程数值方法领域内提出了一个清晰、独立且科学上合理的任务。所有必要的数据和定义都已提供，没有矛盾或歧义。\n\n目标是计算单个三角形单元 $K$ 的单元载荷向量贡献 $b_K$。根据问题陈述，该贡献由以下积分定义：\n$$b_K = \\int_K f\\,v\\,dx$$\n其中 $K$ 是三角形单元域，$f$ 是源项，$v$ 是检验函数。\n\n问题规定了以下几点：\n1. 单元 $K$ 是一个三角形，其顶点为 $V_1 = (1,2)$、 $V_2 = (5,3)$ 和 $V_3 = (2,7)$。\n2. 源项 $f(x)$ 在单元 $K$ 上是常数，由 $f(x) \\equiv f_0 = 7$ 给出。\n3. 检验函数 $v(x)$ 来自于分片常数空间 $P_0$。在单元 $K$ 上，它被指定为常数 $v(x) \\equiv c_K = 2$。\n\n将给定的常数函数 $f$ 和 $v$ 代入 $b_K$ 的积分定义中，我们得到：\n$$b_K = \\int_K (f_0)(c_K)\\,dx$$\n由于 $f_0$ 和 $c_K$ 是常数，它们可以从积分中提出：\n$$b_K = f_0 c_K \\int_K 1\\,dx$$\n剩余的积分 $\\int_K 1\\,dx$ 表示三角形单元 $K$ 的面积。我们用 $|K|$ 表示这个面积。因此，$b_K$ 的表达式简化为：\n$$b_K = f_0 c_K |K|$$\n\n这个公式符合有限元方法的第一性原理。通常，该积分是通过仿射映射 $x = F(\\hat{x})$ 将物理单元 $K$ 变换到参考单元 $\\hat{K}$ 来计算的。积分变为 $\\int_{\\hat{K}} f(F(\\hat{x})) v(F(\\hat{x})) |\\det(J_F)| \\,d\\hat{x}$，其中 $|\\det(J_F)|$ 是映射的雅可比行列式。对于仿射映射，该行列式是常数，如果 $\\hat{K}$ 是单位参考三角形（面积为 $\\frac{1}{2}$），则其值等于 $2|K|$。因此，计算 $|K|$ 是核心的几何任务。\n\n我们可以利用三角形 $K$ 的顶点来计算其面积。一种方法是在行列式公式（鞋带公式的一个变种）中使用顶点的坐标。一种等效且物理上直观的方法是，将面积计算为从同一顶点出发的两条边向量的叉积的模的一半。\n\n让我们定义从顶点 $V_1$ 出发张成该三角形的两个向量：\n$$\\vec{a} = V_2 - V_1 = (5-1, 3-2) = (4, 1)$$\n$$\\vec{b} = V_3 - V_1 = (2-1, 7-2) = (1, 5)$$\n\n为了计算叉积，我们将这些向量嵌入到三维空间中，并使其z分量为零：$\\vec{a} = (4, 1, 0)$ 和 $\\vec{b} = (1, 5, 0)$。叉积为：\n$$\\vec{a} \\times \\vec{b} = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ 4 & 1 & 0 \\\\ 1 & 5 & 0 \\end{vmatrix} = \\mathbf{i}(1 \\cdot 0 - 0 \\cdot 5) - \\mathbf{j}(4 \\cdot 0 - 0 \\cdot 1) + \\mathbf{k}(4 \\cdot 5 - 1 \\cdot 1)$$\n$$\\vec{a} \\times \\vec{b} = (0)\\mathbf{i} - (0)\\mathbf{j} + (20 - 1)\\mathbf{k} = 19\\mathbf{k}$$\n所得向量的模为 $\\|\\vec{a} \\times \\vec{b}\\| = |19| = 19$。三角形的面积 $|K|$ 是此模的一半：\n$$|K| = \\frac{1}{2} \\|\\vec{a} \\times \\vec{b}\\| = \\frac{19}{2}$$\n\n现在我们有了计算 $b_K$ 的所有组成部分。将给定值 $f_0 = 7$，$c_K = 2$ 以及计算出的面积 $|K| = \\frac{19}{2}$ 代入我们关于 $b_K$ 的表达式中：\n$$b_K = (7) \\cdot (2) \\cdot \\left(\\frac{19}{2}\\right)$$\n$$b_K = 7 \\cdot 19$$\n$$b_K = 133$$\n因此，单元载荷贡献的精确值为 $133$。", "answer": "$$\\boxed{133}$$", "id": "3383766"}, {"introduction": "最后一个实践为非线性问题中解析推导与现代计算实现之间架起了一座桥梁。您将使用手动推导和自动微分 (AD) 两种方法，实现并验证非线性单元载荷向量的雅可比矩阵。该练习展示了 AD 如何成为一个强大而可靠的工具，用于处理非线性有限元分析中所需的复杂导数计算。[@problem_id:3383773]", "problem": "考虑一个一维非线性强形式偏微分方程 (PDE)，其有限元法 (FEM) 残差包含一个由非线性函数 $f(u)$ 建模的源项。对于在物理坐标 $x_1$ 和 $x_2$ 处有节点的双节点线性单元，单元载荷向量通过标准的伽辽金构造定义为形函数与 $f(u_h)$ 的乘积的积分，其中 $u_h$ 是节点插值。请使用此基础定义和经过充分检验的数值积分方法，来推导、实现并验证单元载荷向量关于节点值的雅可比矩阵。\n\n基本原理：\n- 单元载荷向量分量 $L_i(u)$（其中 $i \\in \\{1,2\\}$）定义为第 $i$ 个形函数与在近似解 $u_h$ 处求值的非线性源函数的乘积在物理单元域上的积分。此过程使用参考区间 $[-1,1]$ 上的标准双节点线性形函数以及到物理单元 $[x_1,x_2]$ 的标准仿射映射。\n- 近似解为 $u_h(x) = N_1(\\xi) u_1 + N_2(\\xi) u_2$，其中 $N_1(\\xi)$ 和 $N_2(\\xi)$ 是参考坐标 $\\xi \\in [-1,1]$ 上的标准线性形函数，仿射映射的雅可比为 $(x_2 - x_1)/2$。\n- 数值积分必须在参考区间 $[-1,1]$ 上使用指定阶数的高斯-勒让德求积法。\n\n您的任务：\n1. 实现前向模式自动微分 (AD)，以计算单元载荷向量 $L(u)$ 的雅可比矩阵（即关于节点值 $u_1$ 和 $u_2$ 的偏导数矩阵）。\n2. 从变分基础出发，独立推导单元载荷向量的线性化，并使用相同的求积规则实现其求值，以获得一个手动推导的雅可比矩阵。\n3. 验证对于以下测试集，由 AD 生成的项 $\\frac{dL_i}{du_j}$ 与通过手动推导的线性化获得的项相匹配。将所有量视为无量纲。\n\n参考单元和映射细节：\n- 参考区间为 $[-1,1]$。\n- 需使用 $[-1,1]$ 上的标准双节点线性形函数。\n- 物理单元映射必须是从 $[-1,1]$ 到 $[x_1,x_2]$ 的唯一仿射映射，其雅可比为 $(x_2 - x_1)/2$。\n\n测试集：\n- 情况 A（一般非线性，中等振幅）：$x_1 = 0$, $x_2 = 1$, $u_1 = 0.3$, $u_2 = -0.2$, $f(u) = \\sin(u) + u^3$，高斯-勒让德阶数为 $5$。\n- 情况 B（小单元长度以测试缩放性）：$x_1 = 0$, $x_2 = 0.01$, $u_1 = -0.5$, $u_2 = 0.8$, $f(u) = \\exp(u) + u^5$，高斯-勒让德阶数为 $5$。\n- 情况 C（零解，导数抵消）：$x_1 = -2$, $x_2 = 2$, $u_1 = 0$, $u_2 = 0$, $f(u) = \\cos(u) + u^3$，高斯-勒让德阶数为 $3$。\n- 情况 D（大振幅，混合非线性）：$x_1 = -0.2$, $x_2 = 1.3$, $u_1 = 5.0$, $u_2 = -4.0$, $f(u) = u \\exp(u) + \\sin(u)$，高斯-勒让德阶数为 $7$。\n\n验证标准：\n- 对于每种情况，通过 AD 和手动推导的线性化计算雅可比矩阵，并使用雅可比矩阵各项之间的最大绝对差值，在 $10^{-12}$ 的数值容差范围内检查其相等性。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个布尔值对应一个测试用例，表示 AD 和手动推导的雅可比矩阵是否在容差范围内匹配（例如，$[\\text{True},\\text{False},\\text{True},\\text{True}]$）。", "solution": "本问题要求对一维双节点线性有限元中的非线性单元载荷向量的雅可比矩阵进行推导和实现。该雅可比矩阵将使用两种不同的方法计算：直接解析推导（手动推导）和前向模式自动微分 (AD)。两种方法的结果必须在一系列测试用例中进行一致性验证。\n\n### 1. 基本公式\n\n设物理单元由区间 $[x_1, x_2]$ 定义。我们使用等参格式，通过仿射变换将由 $\\xi \\in [-1, 1]$ 定义的参考单元映射到物理单元：\n$$\nx(\\xi) = N_1(\\xi) x_1 + N_2(\\xi) x_2\n$$\n其中 $N_1(\\xi)$ 和 $N_2(\\xi)$ 是参考单元上的标准线性形函数：\n$$\nN_1(\\xi) = \\frac{1 - \\xi}{2}, \\quad N_2(\\xi) = \\frac{1 + \\xi}{2}\n$$\n物理坐标与参考坐标之间的微分关系由映射的雅可比 $J$ 给出：\n$$\ndx = \\frac{dx}{d\\xi} d\\xi = J d\\xi\n$$\n其中\n$$\nJ = \\frac{dx}{d\\xi} = \\frac{d}{d\\xi} \\left( \\frac{1 - \\xi}{2} x_1 + \\frac{1 + \\xi}{2} x_2 \\right) = \\frac{x_2 - x_1}{2}\n$$\n单元内的近似解 $u_h$ 使用相同的形函数从节点值 $u_1$ 和 $u_2$ 插值得到：\n$$\nu_h(x) \\rightarrow u_h(\\xi) = N_1(\\xi) u_1 + N_2(\\xi) u_2\n$$\n单元载荷向量 $L$ 源于源项 $f(u)$ 的伽辽金公式。对于双节点单元，它是一个 $2 \\times 1$ 的向量，其分量 $L_i$ 由以下公式给出：\n$$\nL_i(\\mathbf{u}) = \\int_{x_1}^{x_2} N_i(x) f(u_h(x)) \\, dx\n$$\n其中 $\\mathbf{u} = [u_1, u_2]^T$。将该积分变换到参考坐标系，我们得到：\n$$\nL_i(\\mathbf{u}) = \\int_{-1}^{1} N_i(\\xi) f(u_h(\\xi)) J \\, d\\xi, \\quad i \\in \\{1, 2\\}\n$$\n该积分使用含 $n_p$ 个点的高斯-勒让德求积法进行数值计算：\n$$\nL_i \\approx \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f(u_h(\\xi_k)) J\n$$\n其中 $\\xi_k$ 是高斯点，$w_k$ 是相应的权重。\n\n### 2. 手动推导雅可比矩阵\n\n单元载荷向量的雅可比矩阵是一个 $2 \\times 2$ 的矩阵 $K$，其分量为 $K_{ij} = \\frac{\\partial L_i}{\\partial u_j}$。我们通过对 $L_i$ 的积分表达式关于节点值 $u_j$ 求导来推导它。\n$$\nK_{ij} = \\frac{\\partial L_i}{\\partial u_j} = \\frac{\\partial}{\\partial u_j} \\left[ \\int_{-1}^{1} N_i(\\xi) f(u_h(\\xi)) J \\, d\\xi \\right]\n$$\n由于积分域和雅可比 $J$ 独立于 $\\mathbf{u}$，我们可以将导数移到积分内部：\n$$\nK_{ij} = \\int_{-1}^{1} N_i(\\xi) \\frac{\\partial}{\\partial u_j} \\left[ f(u_h(\\xi)) \\right] J \\, d\\xi\n$$\n使用链式法则，我们有 $\\frac{\\partial}{\\partial u_j} [f(u_h)] = f'(u_h) \\frac{\\partial u_h}{\\partial u_j}$，其中 $f'(u_h)$ 是 $f$ 对其参数的导数，在 $u_h$ 处求值。插值解 $u_h$ 对节点值 $u_j$ 的导数就是相应的形函数：\n$$\n\\frac{\\partial u_h(\\xi)}{\\partial u_j} = \\frac{\\partial}{\\partial u_j} \\left[ N_1(\\xi) u_1 + N_2(\\xi) u_2 \\right] = N_j(\\xi)\n$$\n将此代入 $K_{ij}$ 的表达式，得到雅可比矩阵项的解析公式：\n$$\nK_{ij} = \\int_{-1}^{1} N_i(\\xi) f'(u_h(\\xi)) N_j(\\xi) J \\, d\\xi\n$$\n使用高斯-勒让德求积法对该积分进行数值计算的结果是：\n$$\nK_{ij} \\approx \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f'(u_h(\\xi_k)) N_j(\\xi_k) J\n$$\n其中 $u_h(\\xi_k) = N_1(\\xi_k)u_1 + N_2(\\xi_k)u_2$。\n\n### 3. 前向模式自动微分 (AD)\n\n前向模式 AD 通过将中间变量的导数与其值一起传播来计算函数的导数。这是通过定义一个`对偶数`(Dual number)代数来实现的。一个对偶数是一个有序对 $(v, \\dot{v})$，表示值 $v$ 及其导数 $\\dot{v}$。它可以写成 $v + \\dot{v}\\epsilon$ 的形式，其中 $\\epsilon$ 是一个幂零元，满足 $\\epsilon^2 = 0$。\n\n设 $u = (u, \\dot{u})$ 和 $v = (v, \\dot{v})$。算术运算和初等函数被重载如下：\n- 加/减法：$(u, \\dot{u}) \\pm (v, \\dot{v}) = (u \\pm v, \\dot{u} \\pm \\dot{v})$\n- 乘法：$(u, \\dot{u}) \\cdot (v, \\dot{v}) = (uv, u\\dot{v} + v\\dot{u})$\n- 函数应用（例如 $\\sin$）：$\\sin((u, \\dot{u})) = (\\sin(u), \\dot{u}\\cos(u))$\n\n为了计算雅可比矩阵 $K$ 的第 $j$ 列，我们将第 $j$ 个输入变量 $u_j$ 的导数“播种”(seed)为 $1$，所有其他变量的导数播种为 $0$。然后我们使用对偶数算术来计算载荷向量 $L(\\mathbf{u})$。得到的 $L_1$ 和 $L_2$ 的对偶数中的导数部分将构成雅可比矩阵的第 $j$ 列。\n\n例如，为了计算第一列（$\\frac{\\partial L}{\\partial u_1}$），我们将输入设置为：\n$$\nu_1^{\\text{AD}} = (u_1, 1), \\quad u_2^{\\text{AD}} = (u_2, 0)\n$$\n然后我们在求积循环中使用对偶数算术来计算载荷向量的分量：\n$$\nu_h^{\\text{AD}}(\\xi_k) = N_1(\\xi_k) u_1^{\\text{AD}} + N_2(\\xi_k) u_2^{\\text{AD}}\n$$\n$$\nL_i^{\\text{AD}} = \\sum_{k=1}^{n_p} w_k N_i(\\xi_k) f(u_h^{\\text{AD}}(\\xi_k)) J\n$$\n每个分量的结果将是一个对偶数 $L_i^{\\text{AD}} = (L_i, \\frac{\\partial L_i}{\\partial u_1})$。导数部分就是所求的雅可比矩阵项。我们重复此过程，对 $u_2$ 进行播种（即 $u_1^{\\text{AD}} = (u_1, 0), u_2^{\\text{AD}} = (u_2, 1)$），以获得第二列。\n\n只要积分方法保持不变，这个过程就能机械地计算出与手动推导公式完全相同的导数，因此是一个极好的验证工具。实现将遵循此逻辑来处理指定的测试用例。", "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"A simple Dual number class for forward-mode automatic differentiation.\"\"\"\n    def __init__(self, value, deriv=0.0):\n        self.value = value\n        self.deriv = deriv\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.deriv + other.deriv)\n        return Dual(self.value + other, self.deriv)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.deriv - other.deriv)\n        return Dual(self.value - other, self.deriv)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.deriv)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value * other.value, self.deriv * other.value + self.value * other.deriv)\n        return Dual(self.value * other, self.deriv * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __pow__(self, power):\n        val = self.value ** power\n        der = power * (self.value ** (power - 1)) * self.deriv\n        return Dual(val, der)\n    \n    def __repr__(self):\n        return f\"Dual(value={self.value}, deriv={self.deriv})\"\n\n# Overload math functions for Dual numbers\ndef sin(d):\n    return Dual(np.sin(d.value), d.deriv * np.cos(d.value))\n\ndef cos(d):\n    return Dual(np.cos(d.value), -d.deriv * np.sin(d.value))\n\ndef exp(d):\n    return Dual(np.exp(d.value), d.deriv * np.exp(d.value))\n\n\ndef solve():\n    \"\"\"\n    Computes and verifies the Jacobian of a nonlinear element load vector using\n    both hand-derivation and automatic differentiation.\n    \"\"\"\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"x1\": 0.0, \"x2\": 1.0, \"u1\": 0.3, \"u2\": -0.2, \"order\": 5,\n            \"f\": lambda u: np.sin(u) + u**3,\n            \"f_prime\": lambda u: np.cos(u) + 3 * u**2,\n            \"f_ad\": lambda u: sin(u) + u**3\n        },\n        {\n            \"x1\": 0.0, \"x2\": 0.01, \"u1\": -0.5, \"u2\": 0.8, \"order\": 5,\n            \"f\": lambda u: np.exp(u) + u**5,\n            \"f_prime\": lambda u: np.exp(u) + 5 * u**4,\n            \"f_ad\": lambda u: exp(u) + u**5\n        },\n        {\n            \"x1\": -2.0, \"x2\": 2.0, \"u1\": 0.0, \"u2\": 0.0, \"order\": 3,\n            \"f\": lambda u: np.cos(u) + u**3,\n            \"f_prime\": lambda u: -np.sin(u) + 3 * u**2,\n            \"f_ad\": lambda u: cos(u) + u**3\n        },\n        {\n            \"x1\": -0.2, \"x2\": 1.3, \"u1\": 5.0, \"u2\": -4.0, \"order\": 7,\n            \"f\": lambda u: u * np.exp(u) + np.sin(u),\n            \"f_prime\": lambda u: (1 + u) * np.exp(u) + np.cos(u),\n            \"f_ad\": lambda u: u * exp(u) + sin(u)\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x1, x2, u1, u2 = case[\"x1\"], case[\"x2\"], case[\"u1\"], case[\"u2\"]\n        order = case[\"order\"]\n        f_prime = case[\"f_prime\"]\n        f_ad = case[\"f_ad\"]\n        \n        # 1. Common setup\n        J_map = (x2 - x1) / 2.0\n        xi_points, weights = np.polynomial.legendre.leggauss(order)\n        N_vals = np.array([(1 - xi_points) / 2.0, (1 + xi_points) / 2.0]) # Shape functions evaluated at GPs\n\n        # 2. Hand-derived Jacobian\n        K_hand = np.zeros((2, 2))\n        for k in range(order):\n            # Evaluate shape functions at Gauss point k\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            \n            # Evaluate uh at Gauss point k\n            u_h_k = N1_k * u1 + N2_k * u2\n            \n            # Evaluate f'(uh) at Gauss point k\n            f_prime_uh_k = f_prime(u_h_k)\n            \n            # Form outer product of shape functions\n            N_outer = np.outer([N1_k, N2_k], [N1_k, N2_k])\n            \n            # Accumulate contribution to Jacobian\n            K_hand += weights[k] * f_prime_uh_k * N_outer * J_map\n            \n        # 3. Automatic Differentiation Jacobian\n        K_ad = np.zeros((2, 2))\n        \n        # Compute column 1 (derivatives with respect to u1)\n        u1_ad = Dual(u1, 1.0)\n        u2_ad = Dual(u2, 0.0)\n        L_ad = [Dual(0.0, 0.0), Dual(0.0, 0.0)]\n        for k in range(order):\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            u_h_ad_k = N1_k * u1_ad + N2_k * u2_ad\n            f_uh_ad = f_ad(u_h_ad_k)\n            \n            L_ad[0] += N1_k * f_uh_ad * weights[k] * J_map\n            L_ad[1] += N2_k * f_uh_ad * weights[k] * J_map\n        \n        K_ad[0, 0] = L_ad[0].deriv\n        K_ad[1, 0] = L_ad[1].deriv\n        \n        # Compute column 2 (derivatives with respect to u2)\n        u1_ad = Dual(u1, 0.0)\n        u2_ad = Dual(u2, 1.0)\n        L_ad = [Dual(0.0, 0.0), Dual(0.0, 0.0)]\n        for k in range(order):\n            N1_k, N2_k = N_vals[0, k], N_vals[1, k]\n            u_h_ad_k = N1_k * u1_ad + N2_k * u2_ad\n            f_uh_ad = f_ad(u_h_ad_k)\n\n            L_ad[0] += N1_k * f_uh_ad * weights[k] * J_map\n            L_ad[1] += N2_k * f_uh_ad * weights[k] * J_map\n            \n        K_ad[0, 1] = L_ad[0].deriv\n        K_ad[1, 1] = L_ad[1].deriv\n        \n        # 4. Verification\n        max_abs_diff = np.max(np.abs(K_hand - K_ad))\n        is_match = max_abs_diff  1e-12\n        results.append(is_match)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3383773"}]}