{"hands_on_practices": [{"introduction": "在有限元分析中，全局刚度矩阵的构建始于单元层面。单元刚度矩阵的计算精度直接影响着整体解的可靠性。这个实践将引导你通过一个三维线弹性体的计算实验，探索不同的数值积分方案——完全积分（FI）、减缩积分（RI）和选择性减缩积分（SRI）——如何影响刚度矩阵的性质，并揭示体积锁定和沙漏模式等关键数值现象 ([@problem_id:3599220])。通过亲手实现并比较这些方案，你将深刻理解在近不可压缩材料建模中，选择合适的积分方法为何至关重要。", "problem": "考虑一个三维小应变线性弹性固体，占据立方体域 $\\Omega = [0,1] \\times [0,1] \\times [0,1]$（单位 $\\mathrm{m}^3$）。使用 $2 \\times 2 \\times 2$ 个三线性八节点六面体单元 ($H_8$) 的均匀结构化网格对 $\\Omega$ 进行离散化。每个节点有三个平移自由度。在整个面 $\\{(x,y,z) \\in \\Omega \\mid z = 0\\}$ 上施加齐次 Dirichlet 边界条件 $u_x = u_y = u_z = 0$，以消除刚体模式。假设材料为各向同性、均匀的线性弹性体，其杨氏模量为 $E$（单位 $\\mathrm{Pa}$），泊松比为 $\\nu$，Lamé 参数为 $\\lambda = \\dfrac{E \\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu = \\dfrac{E}{2(1+\\nu)}$。设 Voigt 记法下的本构张量是由 $\\lambda$ 和 $\\mu$ 构建的三维各向同性线性弹性的标准 $6 \\times 6$ 矩阵。使用小应变运动学。不施加体力或面力。\n\n从静态、无载荷构型的虚功原理出发，\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{v}) \\, \\mathrm{d}\\Omega = 0,\n$$\n使用常规的有限元 Galerkin 离散化方法和 $H_8$ 形函数，组装全局刚度矩阵 $\\mathbf{K}$。选择性减缩积分 (SRI, Selective Reduced Integration) 策略将本构响应分解为体积部分和偏量部分，并用不同的求积法则对它们进行积分，以缓解闭锁现象，同时避免伪零能模式（沙漏模式）。具体而言，对于单元刚度 $\\mathbf{K}^e$：\n- 偏量项必须使用每个方向 $2$ 个积分点（$2 \\times 2 \\times 2$ 积分）的张量积高斯法则进行积分。\n- 体积项必须使用单元中心的单个积分点（单点积分）进行积分。\n\n相比之下，作为参考和对比：\n- 完全积分 (FI, Full Integration) 在 $2 \\times 2 \\times 2$ 个高斯点上对完整本构响应进行积分。\n- 减缩积分 (RI, Reduced Integration) 在单个单元中心点（单点积分）上对完整本构响应进行积分。\n\n在母单元域 $[-1,1]^3$ 上使用标准等参 $H_8$ 形函数，并使用到物理坐标的精确等参映射。对于 $2 \\times 2 \\times 2$ 高斯法则，使用一维横坐标 $\\{\\pm 1/\\sqrt{3}\\}$（权重为 $1$），通过张量积组合而成。对于单点法则，在每个方向上使用横坐标 $0$（权重为 $2$），通过张量积组合而成。将网格视为单位立方体的均匀划分，因此所有单元映射都是矩形且对齐的。\n\n你的任务是编写一个完整的程序，该程序：\n- 构建具有 $2 \\times 2 \\times 2$ 个单元的单位立方体 $H_8$ 网格，并组装全局刚度矩阵 $\\mathbf{K}$。\n- 通过消除相关的行和列，在面 $z=0$ 上施加齐次 Dirichlet 边界条件。\n- 对于下面指定的参数集，在 FI、RI 和 SRI 三种积分方案下，计算对称半正定矩阵 $\\mathbf{K}$ 的 $k$ 个最小特征值（按升序排列）。特征值必须在施加边界条件后对缩减后的矩阵进行计算，并以 $\\mathrm{N}/\\mathrm{m}$ 为单位报告。\n- 将特征值报告为浮点数。\n\n使用以下测试套件，其中 $k=6$ 且 $E = 10^5$（单位 $\\mathrm{Pa}$）：\n- 情况 1：方案 FI，$\\nu = 0.3$。\n- 情况 2：方案 RI，$\\nu = 0.3$。\n- 情况 3：方案 SRI，$\\nu = 0.3$。\n- 情况 4：方案 FI，$\\nu = 0.4999$。\n- 情况 5：方案 SRI，$\\nu = 0.4999$。\n\n覆盖性设计：\n- 情况 2 应揭示由于在 $H_8$ 上使用单点减缩积分而产生的伪零特征值（沙漏模式）。\n- 情况 1 和 3 应不存在沙漏模式，施加边界条件后，其最小特征值应严格为正。\n- 情况 4 和 5 比较了近不可压缩性时的行为，表明选择性减缩积分在不引入沙漏模式的情况下缓解了体积闭锁。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的 Python 风格列表的列表形式的结果。每个内部列表必须包含一个测试用例的 $k$ 个最小特征值（单位 $\\mathrm{N}/\\mathrm{m}$），按升序排列并四舍五入到 $6$ 位小数。五个内部列表必须按照上述五个情况的顺序排列。例如，输出必须具有以下形式\n$[ [e_{1,1}, e_{1,2}, e_{1,3}, e_{1,4}, e_{1,5}, e_{1,6}], [e_{2,1}, \\dots, e_{2,6}], \\dots, [e_{5,1}, \\dots, e_{5,6}] ]$\n并且全部在单行上，其中 $e_{i,j}$ 表示情况 $i$ 的第 $j$ 个特征值。", "solution": "用户提供的问题被评估为 **有效**。这是一个定义明确、有科学依据的计算固体力学问题，遵循了有限元法 (FEM) 的既定原则。该问题是自洽的，提供了所有必要的数据、边界条件和材料属性。其目标明确，测试用例旨在说明已知的数值现象（体积闭锁和沙漏），这是一个标准的教学练习。\n\n### 基于原理的解决方案设计\n\n该解决方案基于三维线性弹性的有限元法 (FEM)。过程始于虚功原理，对于无外部载荷的静态固体，其表述为：\n$$\n\\delta W = \\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\delta\\mathbf{u}) : \\mathbb{C} : \\boldsymbol{\\varepsilon}(\\mathbf{u}) \\, \\mathrm{d}\\Omega = 0\n$$\n其中 $\\mathbf{u}$ 是位移场，$\\delta\\mathbf{u}$ 是运动学容许的虚位移场，$\\boldsymbol{\\varepsilon}$ 是小应变张量，$\\mathbb{C}$ 是四阶弹性张量，$\\Omega$ 是材料域。\n\n通过将域 $\\Omega = [0,1]^3 \\ \\mathrm{m}^3$ 划分为 $2 \\times 2 \\times 2 = 8$ 个三线性六面体单元 ($H_8$) 的网格，对该连续弱形式进行离散化。在每个单元 $\\Omega_e$ 内，位移场使用等参形函数 $N_i$ 和节点位移 $\\mathbf{d}^e$ 进行近似：\n$$\n\\mathbf{u}(\\boldsymbol{\\xi}) = \\sum_{i=1}^{8} N_i(\\boldsymbol{\\xi}) \\mathbf{u}_i\n$$\n其中 $\\boldsymbol{\\xi} = (\\xi, \\eta, \\zeta)$ 是母单元域 $[-1,1]^3$ 中的坐标。该近似导出了离散的应变-位移关系 $\\boldsymbol{\\varepsilon} = \\mathbf{B} \\mathbf{d}^e$，其中 $\\mathbf{B}$ 是应变-位移矩阵，它依赖于形函数的空间导数。\n\n将有限元近似代入虚功原理，并考虑任意节点虚位移 $\\delta\\mathbf{d}$，可得到离散线性方程组 $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$。由于没有施加外力，该系统是齐次的，我们分析全局刚度矩阵 $\\mathbf{K}$ 的性质。矩阵 $\\mathbf{K}$ 由单元刚度矩阵 $\\mathbf{K}^e$ 组装而成：\n$$\n\\mathbf{K}^e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C} \\mathbf{B} \\, \\mathrm{d}\\Omega\n$$\n其中 $\\mathbf{C}$ 是 Voigt 记法下的本构矩阵。对于各向同性线性弹性，它由 Lamé 参数 $\\lambda$ 和 $\\mu$ 定义。该积分被变换到母单元域，并使用高斯求积进行数值计算：\n$$\n\\mathbf{K}^e = \\int_{-1}^{1}\\int_{-1}^{1}\\int_{-1}^{1} \\mathbf{B}(\\boldsymbol{\\xi})^T \\mathbf{C} \\mathbf{B}(\\boldsymbol{\\xi}) \\det(\\mathbf{J}) \\, \\mathrm{d}\\xi \\, \\mathrm{d}\\eta \\, \\mathrm{d}\\zeta \\approx \\sum_{g} w_g \\mathbf{B}(\\boldsymbol{\\xi}_g)^T \\mathbf{C} \\mathbf{B}(\\boldsymbol{\\xi}_g) \\det(\\mathbf{J}(\\boldsymbol{\\xi}_g))\n$$\n其中 $\\mathbf{J}$ 是从母坐标到物理坐标映射的雅可比矩阵，$w_g$ 和 $\\boldsymbol{\\xi}_g$ 分别是求积权重和求积点。对于给定的均匀网格，$\\det(\\mathbf{J})$ 对所有单元都是常数。\n\n问题要求在三种不同的数值积分方案下，对刚度矩阵 $\\mathbf{K}$ 进行模态分析（特征值计算）：\n\n1.  **完全积分 (FI)**：对 $\\mathbf{K}^e$ 的积分使用 $2 \\times 2 \\times 2$ 高斯求积法则进行计算。该法则足以精确积分矩形单元的刚度矩阵，并且是秩充足的，这意味着它不会引入非物理的零能模式。然而，对于近不可压缩材料（$\\nu \\to 0.5$），它可能导致“体积闭锁”，即单元响应的一种人为刚化现象。\n\n2.  **减缩积分 (RI)**：积分使用单元中心 $(\\xi, \\eta, \\zeta)=(0,0,0)$ 的单个高斯点进行计算。已知该方案可以缓解体积闭锁，但对于 $H_8$ 单元是秩亏的，会导致被称为“沙漏模式”的伪零能模式。即使在刚体运动被约束后，这些模式在刚度矩阵中仍表现为接近零的特征值。\n\n3.  **选择性减缩积分 (SRI)**：这种混合方法旨在结合 FI 和 RI 的优点。本构行为被分解为体积和偏量部分。同样的分解也适用于刚度矩阵：$\\mathbf{K}^e = \\mathbf{K}^e_{\\mathrm{vol}} + \\mathbf{K}^e_{\\mathrm{dev}}$。导致闭锁的刚性体积部分使用减缩（单点）法则进行积分，而偏量部分则使用完全积分（$2 \\times 2 \\times 2$ 法则）。这能同时防止闭锁并控制沙漏模式。本构矩阵的分解为：\n    $$\n    \\mathbf{C} = \\mathbf{C}_{\\mathrm{dev}} + \\mathbf{C}_{\\mathrm{vol}}\n    $$\n    其中 $\\mathbf{C}_{\\mathrm{vol}} = K \\mathbf{m} \\mathbf{m}^T$，其中 $K=\\lambda + \\frac{2}{3}\\mu$ 是体积模量，$\\mathbf{m} = [1, 1, 1, 0, 0, 0]^T$。单元刚度则为：\n    $$\n    \\mathbf{K}^e_{\\mathrm{SRI}} = \\left(\\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C}_{\\mathrm{dev}} \\mathbf{B} \\, \\mathrm{d}\\Omega\\right)_{\\text{FI}} + \\left(\\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{C}_{\\mathrm{vol}} \\mathbf{B} \\, \\mathrm{d}\\Omega\\right)_{\\text{RI}}\n    $$\n\n全局刚度矩阵 $\\mathbf{K}$ 是通过对所有 $8$ 个单元矩阵的贡献求和来组装的。将齐次 Dirichlet 边界条件 ($u_x = u_y = u_z = 0$) 施加在 $z=0$ 的面上。这是通过识别该面上的所有自由度 (DOF)，并从 $\\mathbf{K}$ 中移除相应的行和列，以形成一个缩减后的正定矩阵 $\\mathbf{K}_{\\mathrm{red}}$（RI 情况除外）来实现的。\n\n最后，对对称矩阵 $\\mathbf{K}_{\\mathrm{red}}$ 进行特征值分析。使用 `scipy.linalg.eigh` 计算 $k=6$ 个最小特征值，它们对应于受约束结构的最软变形模式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_B_matrix(xi, eta, zeta, J_inv):\n    \"\"\"\n    Computes the strain-displacement matrix B for an H8 element at a given\n    point in parent coordinates.\n    J_inv is the inverse of the Jacobian matrix.\n    \"\"\"\n    # Parent coordinates of the 8 nodes of a standard H8 element\n    node_parent_coords = np.array([\n        [-1, -1, -1], [ 1, -1, -1], [ 1,  1, -1], [-1,  1, -1],\n        [-1, -1,  1], [ 1, -1,  1], [ 1,  1,  1], [-1,  1,  1]\n    ])\n\n    # Derivatives of shape functions w.r.t. parent coordinates (dNdxi)\n    dNdxi_eta_zeta = np.zeros((3, 8))\n    for i in range(8):\n        xi_i, eta_i, zeta_i = node_parent_coords[i]\n        dNdxi_eta_zeta[0, i] = 0.125 * xi_i * (1 + eta_i * eta) * (1 + zeta_i * zeta)\n        dNdxi_eta_zeta[1, i] = 0.125 * eta_i * (1 + xi_i * xi) * (1 + zeta_i * zeta)\n        dNdxi_eta_zeta[2, i] = 0.125 * zeta_i * (1 + xi_i * xi) * (1 + eta_i * eta)\n\n    # Derivatives of shape functions w.r.t. physical coordinates (dNdX)\n    dNdxyz = J_inv @ dNdxi_eta_zeta\n\n    # Assemble the B matrix (6x24)\n    B = np.zeros((6, 24))\n    for i in range(8):\n        dN_dx_i, dN_dy_i, dN_dz_i = dNdxyz[:, i]\n        B[0, 3*i    ] = dN_dx_i\n        B[1, 3*i + 1] = dN_dy_i\n        B[2, 3*i + 2] = dN_dz_i\n        B[3, 3*i    ] = dN_dy_i; B[3, 3*i + 1] = dN_dx_i\n        B[4, 3*i + 1] = dN_dz_i; B[4, 3*i + 2] = dN_dy_i\n        B[5, 3*i    ] = dN_dz_i; B[5, 3*i + 2] = dN_dx_i\n    return B\n\ndef calculate_element_stiffness(scheme, E, nu):\n    \"\"\"\n    Calculates the element stiffness matrix Ke for an H8 element based on the\n    integration scheme. All elements are identical cubes.\n    \"\"\"\n    h = 0.5  # Element side length\n    detJ = (h/2.0)**3\n    J_inv = np.diag([1.0 / (h / 2.0)] * 3)\n\n    # Material properties (Lamé parameters)\n    lmbda = E * nu / ((1 + nu) * (1 - 2 * nu))\n    mu = E / (2 * (1 + nu))\n\n    # Constitutive matrix C in Voigt notation\n    C = np.zeros((6, 6))\n    C[0, 0] = C[1, 1] = C[2, 2] = lmbda + 2 * mu\n    C[0, 1] = C[1, 0] = C[0, 2] = C[2, 0] = C[1, 2] = C[2, 1] = lmbda\n    C[3, 3] = C[4, 4] = C[5, 5] = mu\n    \n    Ke = np.zeros((24, 24))\n\n    if scheme == 'FI':\n        a = 1.0 / np.sqrt(3)\n        gps = [(x, y, z) for x in [-a, a] for y in [-a, a] for z in [-a, a]]\n        for xi, eta, zeta in gps:\n            B = get_B_matrix(xi, eta, zeta, J_inv)\n            Ke += B.T @ C @ B * 1.0 * detJ\n    elif scheme == 'RI':\n        B = get_B_matrix(0.0, 0.0, 0.0, J_inv)\n        Ke += B.T @ C @ B * 8.0 * detJ\n    elif scheme == 'SRI':\n        # Decompose C into deviatoric and volumetric parts\n        K_bulk = lmbda + 2.0/3.0 * mu\n        m = np.array([1, 1, 1, 0, 0, 0]).reshape(6, 1)\n        C_vol = K_bulk * (m @ m.T)\n        C_dev = C - C_vol\n\n        # Deviatoric part integrated with 2x2x2 rule\n        a = 1.0 / np.sqrt(3)\n        gps_dev = [(x, y, z) for x in [-a, a] for y in [-a, a] for z in [-a, a]]\n        for xi, eta, zeta in gps_dev:\n            B_dev = get_B_matrix(xi, eta, zeta, J_inv)\n            Ke += B_dev.T @ C_dev @ B_dev * 1.0 * detJ\n            \n        # Volumetric part integrated with 1-point rule\n        B_vol = get_B_matrix(0.0, 0.0, 0.0, J_inv)\n        Ke += B_vol.T @ C_vol @ B_vol * 8.0 * detJ\n    return Ke\n\ndef run_fem_analysis(scheme, E, nu, k):\n    \"\"\"\n    Runs the full FEM analysis: mesh, assembly, BCs, and eigenvalue solution.\n    \"\"\"\n    # Mesh properties\n    nx, ny, nz = 2, 2, 2\n    num_nodes_x, num_nodes_y, num_nodes_z = nx + 1, ny + 1, nz + 1\n    total_nodes = num_nodes_x * num_nodes_y * num_nodes_z\n    total_dofs = total_nodes * 3\n    \n    K_global = np.zeros((total_dofs, total_dofs))\n\n    # Pre-calculate the element stiffness matrix (all elements are identical)\n    Ke = calculate_element_stiffness(scheme, E, nu)\n\n    # Assemble the global stiffness matrix\n    for k_el in range(nz):\n        for j_el in range(ny):\n            for i_el in range(nx):\n                # Global node indices for this element\n                conn = np.array([\n                    (i_el)   + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el+1) + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el+1) + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el)   + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el),\n                    (i_el)   + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el+1) + num_nodes_x*(j_el)   + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el+1) + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el+1),\n                    (i_el)   + num_nodes_x*(j_el+1) + num_nodes_x*num_nodes_y*(k_el+1)\n                ], dtype=int)\n                \n                # Map element DOFs to global DOFs\n                dof_map = np.empty(24, dtype=int)\n                for i_node in range(8):\n                    dof_map[i_node*3 : i_node*3+3] = conn[i_node]*3 + np.arange(3)\n                \n                # Add element stiffness to global matrix\n                K_global[np.ix_(dof_map, dof_map)] += Ke\n\n    # Apply homogeneous Dirichlet boundary conditions on z=0 face\n    constrained_nodes = []\n    # k_node = 0 for the z=0 face\n    for j_node in range(num_nodes_y):\n        for i_node in range(num_nodes_x):\n            constrained_nodes.append(i_node + num_nodes_x * j_node)\n    \n    constrained_dofs = []\n    for node_idx in constrained_nodes:\n        constrained_dofs.extend([node_idx * 3, node_idx * 3 + 1, node_idx * 3 + 2])\n    \n    all_dofs = np.arange(total_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs, assume_unique=True)\n    \n    K_reduced = K_global[np.ix_(free_dofs, free_dofs)]\n    \n    # Solve the eigenvalue problem for the k smallest eigenvalues\n    eigenvalues = eigh(K_reduced, eigvals_only=True, subset_by_index=[0, k-1])\n    \n    return eigenvalues\n\ndef solve():\n    test_cases = [\n        {'scheme': 'FI', 'nu': 0.3},\n        {'scheme': 'RI', 'nu': 0.3},\n        {'scheme': 'SRI', 'nu': 0.3},\n        {'scheme': 'FI', 'nu': 0.4999},\n        {'scheme': 'SRI', 'nu': 0.4999},\n    ]\n\n    E = 1e5\n    k = 6\n    \n    all_results = []\n    for case in test_cases:\n        eigenvalues = run_fem_analysis(case['scheme'], E, case['nu'], k)\n        rounded_eigs = [round(eig, 6) for eig in eigenvalues]\n        all_results.append(rounded_eigs)\n\n    # Format the output string to match the required format exactly\n    # repr() will create the string representation, then remove spaces\n    output_str = repr(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "3599220"}, {"introduction": "当全局刚度矩阵组装完成后，我们有时可以通过代数方法简化求解问题。静态凝聚是一种强大的技术，它通过消除部分自由度（例如，子结构内部的自由度）来减小系统的规模。这个过程会产生一个作用于余下自由度的更小、更稠密的系统，其核心是舒尔补（Schur complement）矩阵 ([@problem_id:3437062])。本练习将带你一步步推导一个一维问题的舒尔补，让你从第一性原理理解这一核心操作，并体会它在子结构分析和多物理场耦合中的应用价值。", "problem": "考虑一维空间区间 $[0,1]$ 上的标量扩散边值问题：求解 $u$ 使得 $-(a(x) u^{\\prime}(x))^{\\prime} = 0$ 在 $(0,1)$ 上成立，其中传导系数 $a(x)$ 是分段常数，具体为在 $[0,\\tfrac{1}{3}]$ 上 $a(x) = 2$，在 $[\\tfrac{1}{3},\\tfrac{2}{3}]$ 上 $a(x) = 3$，在 $[\\tfrac{2}{3},1]$ 上 $a(x) = 5$。使用标准连续分段线性有限元法 (FEM) 在均匀剖分（节点为 $x_0 = 0, x_1 = \\tfrac{1}{3}, x_2 = \\tfrac{2}{3}, x_3 = 1$）和相应的节点基函数 $\\{\\varphi_0,\\varphi_1,\\varphi_2,\\varphi_3\\}$ 上对弱形式进行离散化。组装全局刚度矩阵 $K \\in \\mathbb{R}^{4 \\times 4}$，其元素为 $K_{ij} = \\int_0^1 a(x) \\varphi_i^{\\prime}(x) \\varphi_j^{\\prime}(x)\\,dx$。将自由度划分为边界索引 $b = \\{0,3\\}$ 和内部索引 $i = \\{1,2\\}$，使得矩阵呈分块形式：\n$$\nK = \\begin{pmatrix}\nK_{bb}  & K_{bi} \\\\\nK_{ib}  & K_{ii}\n\\end{pmatrix}.\n$$\n仅使用 Galerkin 方法和分块高斯消元的基本原理，执行静态凝聚以消去内部未知数，并推导出作用于边界自由度的 Schur 补 $S = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}$。所有量均为无量纲。以精确算术计算凝聚矩阵中耦合端点 $x_0$ 和 $x_3$ 的非对角元，即当边界索引排序为 $(0,3)$ 时，$S$ 的 $(1,2)$ 元。请以最简分数形式给出最终答案。不要四舍五入。", "solution": "用户需要求解一个由有限元法 (FEM) 离散化的一维扩散问题的 Schur 补矩阵中的一个特定元素。\n\n**步骤 1：问题定义与设置**\n问题是在区间 $[0,1]$ 上求解 $-(a(x) u^{\\prime}(x))^{\\prime} = 0$。\n区域被节点 $x_0=0, x_1=\\frac{1}{3}, x_2=\\frac{2}{3}, x_3=1$ 划分为三个单元。令 $h = \\frac{1}{3}$ 为均匀单元长度。\n单元为 $E_1 = [0, \\frac{1}{3}]$, $E_2 = [\\frac{1}{3}, \\frac{2}{3}]$ 和 $E_3 = [\\frac{2}{3}, 1]$。\n传导系数 $a(x)$ 是分段常数：在 $E_1$ 上 $a_1 = 2$，在 $E_2$ 上 $a_2 = 3$，在 $E_3$ 上 $a_3 = 5$。\n离散化使用标准的连续分段线性 (P1) 基函数，记为 $\\varphi_i(x)$，其中 $\\varphi_i(x_j) = \\delta_{ij}$。基函数 $\\varphi_i'(x)$ 的导数是分段常数。在单元 $[x_{k-1}, x_k]$ 上，只有 $\\varphi_{k-1}$ 和 $\\varphi_k$ 的基函数导数非零。具体来说，在 $(x_{k-1}, x_k)$ 上：\n$\\varphi_{k-1}'(x) = -\\frac{1}{h} = -3$\n$\\varphi_k'(x) = \\frac{1}{h} = 3$\n\n**步骤 2：单元刚度矩阵**\n全局刚度矩阵 $K$ 的元素为 $K_{ij} = \\int_0^1 a(x) \\varphi_i^{\\prime}(x) \\varphi_j^{\\prime}(x)\\,dx$。我们可以通过单元刚度矩阵 $K^{(e)}$ 组装 $K$。对于长度为 $h_e$、传导系数为常数 $a_e$ 的一般单元，其单元刚度矩阵为\n$$K^{(e)} = \\frac{a_e}{h_e} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix}$$\n\n对于本问题，所有单元的 $h_e = h = \\frac{1}{3}$。\n单元 1 ($E_1=[0, \\frac{1}{3}]$, 节点 $0, 1$): $a_1 = 2$。\n$K^{(1)} = \\frac{2}{1/3} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = 6 \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = \\begin{pmatrix} 6  & -6 \\\\ -6  & 6 \\end{pmatrix}$。\n\n单元 2 ($E_2=[\\frac{1}{3}, \\frac{2}{3}]$, 节点 $1, 2$): $a_2 = 3$。\n$K^{(2)} = \\frac{3}{1/3} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = 9 \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = \\begin{pmatrix} 9  & -9 \\\\ -9  & 9 \\end{pmatrix}$。\n\n单元 3 ($E_3=[\\frac{2}{3}, 1]$, 节点 $2, 3$): $a_3 = 5$。\n$K^{(3)} = \\frac{5}{1/3} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = 15 \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix} = \\begin{pmatrix} 15  & -15 \\\\ -15  & 15 \\end{pmatrix}$。\n\n**步骤 3：全局刚度矩阵组装**\n$4 \\times 4$ 的全局刚度矩阵 $K$ 是通过将每个单元矩阵的贡献相加组装而成的。\n$K_{00} = K^{(1)}_{11} = 6$\n$K_{01} = K^{(1)}_{12} = -6$\n$K_{11} = K^{(1)}_{22} + K^{(2)}_{11} = 6 + 9 = 15$\n$K_{12} = K^{(2)}_{12} = -9$\n$K_{22} = K^{(2)}_{22} + K^{(3)}_{11} = 9 + 15 = 24$\n$K_{23} = K^{(3)}_{12} = -15$\n$K_{33} = K^{(3)}_{22} = 15$\n根据对称性，$K_{ji}=K_{ij}$。所有其他元素均为零。\n矩阵为：\n$$\nK = \\begin{pmatrix}\n6  & -6  & 0  & 0 \\\\\n-6  & 15  & -9  & 0 \\\\\n0  & -9  & 24  & -15 \\\\\n0  & 0  & -15  & 15\n\\end{pmatrix}\n$$\n\n**步骤 4：矩阵分块**\n自由度被划分为边界索引 $b = \\{0,3\\}$ 和内部索引 $i = \\{1,2\\}$。我们根据索引顺序 $(0,3,1,2)$ 对矩阵重新排序，以获得分块形式\n$$\n\\tilde{K} = \\begin{pmatrix}\nK_{bb}  & K_{bi} \\\\\nK_{ib}  & K_{ii}\n\\end{pmatrix}\n$$\n从 $K$ 中提取分块：\n$K_{bb} = \\begin{pmatrix} K_{00}  & K_{03} \\\\ K_{30}  & K_{33} \\end{pmatrix} = \\begin{pmatrix} 6  & 0 \\\\ 0  & 15 \\end{pmatrix}$\n$K_{bi} = \\begin{pmatrix} K_{01}  & K_{02} \\\\ K_{31}  & K_{32} \\end{pmatrix} = \\begin{pmatrix} -6  & 0 \\\\ 0  & -15 \\end{pmatrix}$\n$K_{ib} = \\begin{pmatrix} K_{10}  & K_{13} \\\\ K_{20}  & K_{23} \\end{pmatrix} = \\begin{pmatrix} -6  & 0 \\\\ 0  & -15 \\end{pmatrix}$\n$K_{ii} = \\begin{pmatrix} K_{11}  & K_{12} \\\\ K_{21}  & K_{22} \\end{pmatrix} = \\begin{pmatrix} 15  & -9 \\\\ -9  & 24 \\end{pmatrix}$\n注意 $K_{ib} = K_{bi}^T$，正如预期。\n\n**步骤 5：Schur 补计算**\nSchur 补由公式 $S = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib}$ 给出。\n首先，我们求 $K_{ii}$ 的逆矩阵。\n$\\det(K_{ii}) = (15)(24) - (-9)(-9) = 360 - 81 = 279$。\n逆矩阵为：\n$$\nK_{ii}^{-1} = \\frac{1}{\\det(K_{ii})} \\begin{pmatrix} 24  & 9 \\\\ 9  & 15 \\end{pmatrix} = \\frac{1}{279} \\begin{pmatrix} 24  & 9 \\\\ 9  & 15 \\end{pmatrix}\n$$\n接下来，我们计算乘积 $K_{bi} K_{ii}^{-1} K_{ib}$。\n$$\nK_{bi} K_{ii}^{-1} = \\begin{pmatrix} -6  & 0 \\\\ 0  & -15 \\end{pmatrix} \\frac{1}{279} \\begin{pmatrix} 24  & 9 \\\\ 9  & 15 \\end{pmatrix} = \\frac{1}{279} \\begin{pmatrix} -144  & -54 \\\\ -135  & -225 \\end{pmatrix}\n$$\n$$\n(K_{bi} K_{ii}^{-1}) K_{ib} = \\frac{1}{279} \\begin{pmatrix} -144  & -54 \\\\ -135  & -225 \\end{pmatrix} \\begin{pmatrix} -6  & 0 \\\\ 0  & -15 \\end{pmatrix} = \\frac{1}{279} \\begin{pmatrix} (-144)(-6)  & (-54)(-15) \\\\ (-135)(-6)  & (-225)(-15) \\end{pmatrix}\n$$\n计算所得矩阵乘积的元素：\n元素 $(1,1)$: $(-144)(-6) = 864$。\n元素 $(1,2)$: $(-54)(-15) = 810$。\n元素 $(2,1)$: $(-135)(-6) = 810$。\n元素 $(2,2)$: $(-225)(-15) = 3375$。\n所以，\n$$\nK_{bi} K_{ii}^{-1} K_{ib} = \\frac{1}{279} \\begin{pmatrix} 864  & 810 \\\\ 810  & 3375 \\end{pmatrix}\n$$\n现在，将此代入 Schur 补公式：\n$$\nS = K_{bb} - K_{bi} K_{ii}^{-1} K_{ib} = \\begin{pmatrix} 6  & 0 \\\\ 0  & 15 \\end{pmatrix} - \\frac{1}{279} \\begin{pmatrix} 864  & 810 \\\\ 810  & 3375 \\end{pmatrix}\n$$\n$$\nS = \\begin{pmatrix} 6 - \\frac{864}{279}  & -\\frac{810}{279} \\\\ -\\frac{810}{279}  & 15 - \\frac{3375}{279} \\end{pmatrix}\n$$\n\n**步骤 6：提取最终答案**\n问题要求的是耦合节点 $x_0$ 和 $x_3$ 的非对角元。这对应于 $2 \\times 2$ 矩阵 $S$ 的第一行第二列的元素，其中行和列按索引 $(0,3)$ 排序。这是我们矩阵的 $S_{12}$ 元。\n$$S_{12} = -\\frac{810}{279}$$\n为了化简分数，我们注意到分子和分母的各位数字之和都可以被 $9$ 整除。\n$810 = 9 \\times 90$。\n$279 = 270 + 9 = 9 \\times 30 + 9 = 9 \\times 31$。\n$$S_{12} = -\\frac{9 \\times 90}{9 \\times 31} = -\\frac{90}{31}$$\n由于 $31$ 是一个质数，并且不是 $90$ 的因子，因此该分数已是最简形式。\n为了完整起见，我们可以计算整个 $S$ 矩阵：\n$S_{11} = 6 - \\frac{864}{279} = 6 - \\frac{9 \\times 96}{9 \\times 31} = 6 - \\frac{96}{31} = \\frac{186 - 96}{31} = \\frac{90}{31}$。\n$S_{22} = 15 - \\frac{3375}{279} = 15 - \\frac{9 \\times 375}{9 \\times 31} = 15 - \\frac{375}{31} = \\frac{465 - 375}{31} = \\frac{90}{31}$。\n$S_{21} = -\\frac{810}{279} = -\\frac{90}{31}$。\n所以，$S = \\frac{90}{31} \\begin{pmatrix} 1  & -1 \\\\ -1  & 1 \\end{pmatrix}$。\n所求的非对角元（第 1 行，第 2 列）确实是 $-\\frac{90}{31}$。", "answer": "$$\n\\boxed{-\\frac{90}{31}}\n$$", "id": "3437062"}, {"introduction": "对于由偏微分方程离散化得到的大型稀疏线性系统，直接求解器（如Cholesky分解）的计算效率在很大程度上取决于未知量的排列顺序。一个好的排序可以显著减少计算过程中的“填充”（fill-in）和内存需求，从而大幅提升求解速度。本实践将引导你通过编程实现，研究不同排序策略——自然排序、逆卡斯尔-麦基（RCM）排序和随机排序——对刚度矩阵的带宽和Cholesky分解填充量的影响 ([@problem_id:3437048])。通过这个练习，你将获得优化大型有限元系统求解过程的宝贵实践经验。", "problem": "考虑一个由齐次狄利克雷泊松问题的标准离散化产生的对称正定全局刚度矩阵。设 $\\Omega = (0,1) \\times (0,1)$，并考虑边值问题 $-\\Delta u = f$ 在 $\\Omega$ 中，且在 $\\partial \\Omega$ 上 $u=0$。使用一个均匀的笛卡尔网格对 $\\Omega$ 进行离散化，该网格由 $m$ 行和 $n$ 列内部点组成，并对拉普拉斯算子使用标准的 $5$ 点模板（此离散化等价于在均匀网格上使用经典协调 $\\mathcal{P}_1$ 有限元方法所得的双线性形式，其中扩散系数为分片常数，且最终的代数系统与 $5$ 点有限差分格式相同）。未知数按字典序行主序进行索引，使得每个内部节点 $(i,j)$（其中 $i \\in \\{0,\\dots,m-1\\}$ 且 $j \\in \\{0,\\dots,n-1\\}$）映射到一个全局索引 $k = i n + j$。得到的全局刚度矩阵 $K \\in \\mathbb{R}^{N \\times N}$（其中 $N = m n$）的元素为：当节点 $k$ 和 $l$ 是网格上直接的 $4$-邻居（上、下、左、右）时，$K_{kk} = 4$ 且 $K_{kl} = -1$；否则 $K_{kl} = 0$。该矩阵 $K$ 是对称且正定的。\n\n将索引 $\\{0,1,\\dots,N-1\\}$ 的一个置换（重排序）$\\pi$ 定义为一个双射。设 $P \\in \\mathbb{R}^{N \\times N}$ 是相应的置换矩阵，并考虑重排序后的矩阵 $K^\\pi = P K P^\\top$。$K^\\pi$ 的对称带宽定义为\n$$\nB(K^\\pi) = \\max_{\\substack{i,j \\in \\{0,\\dots,N-1\\} \\\\ K^\\pi_{ij} \\neq 0}} |i - j| + 1.\n$$\n考虑 Cholesky 分解 $K^\\pi = L L^\\top$，其中 $L$ 是一个对角线元素为正的下三角矩阵。将严格下三角填充定义为满足 $i > j$ 且 $L_{ij} \\neq 0$ 但 $K^\\pi_{ij} = 0$ 的位置 $(i,j)$ 的数量。在具体计算中，将绝对值小于一个很小阈值的元素视为数值上的零。\n\n从泊松问题的变分形式和离散双线性形式的相容性出发，推导并实现算法来：\n- 根据给定的整数 $m$ 和 $n$，如上所述构造全局刚度矩阵 $K$。\n- 构建 $K$ 的邻接图（忽略对角线上的自环），并利用图结构计算 Reverse Cuthill–McKee (RCM) 置换，记为 $\\pi_{\\mathrm{RCM}}$。\n- 应用给定的置换 $\\pi$ 来形成 $K^\\pi$。\n- 计算如上定义的 $B(K^\\pi)$。\n- 计算由 $K^\\pi$ 的 Cholesky 分解引起的严格下三角填充数。\n\n您的程序必须实现以下重排序选择：\n- \"natural\"：单位置换（无重排序），即 $\\pi(i) = i$。\n- \"rcm\"：从 $K$ 的邻接关系计算出的 Reverse Cuthill–McKee 置换。\n- \"random\"：使用固定种子 $42$ 计算的随机置换，以保证可复现性。\n\n当判断一个实值矩阵元素是否为零时，使用数值零阈值 $\\varepsilon = 10^{-12}$。\n\n测试套件：\n在以下每种情况下，计算重排序后刚度矩阵的完整对称带宽 $B(K^\\pi)$ 和严格下三角填充数：\n- 情况 1：$m=1$, $n=1$, 排序 \"natural\"。\n- 情况 2：$m=4$, $n=4$, 排序 \"natural\"。\n- 情况 3：$m=4$, $n=4$, 排序 \"rcm\"。\n- 情况 4：$m=8$, $n=4$, 排序 \"natural\"。\n- 情况 5：$m=8$, $n=4$, 排序 \"rcm\"。\n- 情况 6：$m=10$, $n=10$, 排序 \"rcm\"。\n- 情况 7：$m=10$, $n=10$, 排序 \"random\"，种子为 $42$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个双元素列表 $[B, F]$，其中 $B$ 是完整对称带宽，$F$ 是严格下三角填充数。因此，最终输出必须如下所示：\n$$\n\\big[\\,[B_1,F_1], [B_2,F_2], \\dots, [B_7,F_7]\\,\\big].\n$$\n不得打印任何额外的文本。", "solution": "用户提供的问题定义严谨且科学合理，涉及求解偏微分方程的数值线性代数中的一个标准课题。所有参数、定义和任务都以足够的清晰度和精确度进行了规定，从而能够得到唯一且可验证的解。因此，该问题被认为是有效的。\n\n解决方案系统地完成了所要求的任务：构造全局刚度矩阵，应用指定的置换，以及计算置换后矩阵的性质——带宽和 Cholesky 分解的填充。\n\n### 1. 全局刚度矩阵 $K$ 的构造\n\n问题考虑的是单位正方形 $\\Omega = (0,1) \\times (0,1)$ 上的泊松方程 $-\\Delta u = f$ 及齐次狄利克雷边界条件。该区域通过一个包含 $m$ 行和 $n$ 列内部节点的均匀笛卡尔网格进行离散化。未知数的总数为 $N = mn$。未知数使用行主序字典序进行索引，其中网格位置 $(i,j)$（$i \\in \\{0, \\dots, m-1\\}$ 且 $j \\in \\{0, \\dots, n-1\\}$）对应于唯一的全局索引 $k = i n + j$。\n\n负拉普拉斯算子 $-\\Delta u$ 在内部节点 $(x_{i,j}, y_{i,j})$ 的标准 $5$ 点有限差分模板由下式给出：\n$$\n-\\Delta u \\approx \\frac{4 u_{i,j} - u_{i-1, j} - u_{i+1, j} - u_{i, j-1} - u_{i, j+1}}{h^2}\n$$\n其中 $h$ 是均匀网格间距。忽略缩放因子 $1/h^2$，全局刚度矩阵 $K$ 中对应于内部节点 $k$ 的行，其对角线上为 $4$，而在对应其四个直接网格邻居的列上为 $-1$。具体来说，对于对应网格点 $(i,j)$ 的节点 $k$：\n- 对角线元素为 $K_{kk} = 4$。\n- 与右邻居 $(i, j+1)$（如果 $j  n-1$）的连接，其全局索引为 $l = i n + (j+1)$，导致 $K_{kl} = -1$。\n- 与下邻居 $(i+1, j)$（如果 $i  m-1$）的连接，其全局索引为 $l' = (i+1)n + j$，导致 $K_{kl'} = -1$。\n\n由于算子的对称性，矩阵 $K$ 是对称的，即 $K_{lk} = K_{kl}$。所有其他非对角线元素均为 $0$。通过遍历所有 $N$ 个节点并设置这些非零元素来构造该矩阵。\n\n### 2. 矩阵重排序与置换\n\n对于稀疏矩阵 $K$，其带宽和分解过程中的填充等属性取决于其行和列的排序。索引 $\\{0, \\dots, N-1\\}$ 的一个置换 $\\pi$ 定义了一种重排序。如果 $P$ 是与 $\\pi$ 相关联的置换矩阵，则重排序后的矩阵为 $K^\\pi = P K P^\\top$。在实现中，如果 $\\pi$ 是一个包含置換后索引的数组，这对应于 `K[pi, :][:, pi]`。\n\n问题要求分析三种排序：\n- **自然排序**：单位置换，$\\pi(i)=i$。这是基准的字典序排序。\n- **Reverse Cuthill–McKee (RCM) 排序**：一种著名的启发式算法，旨在减小稀疏矩阵的轮廓或包络。较小的轮廓通常会导致 Cholesky 等分解过程中的填充较少。该算法通过从矩阵邻接图的一个外围节点构建层次集，然后反转得到的排序来实现。我们使用 `scipy.sparse.csgraph.reverse_cuthill_mckee` 提供的标准实现。\n- **随机排序**：一种随机置换，此处用作对照，以展示破坏结构的排序的效果。预期它会产生较差的结果（大带宽和多填充）。\n\n### 3. 带宽和填充的计算\n\n对置换后的矩阵 $K^\\pi$ 计算两个度量指标。\n\n- **对称带宽**：问题将其定义为 $B(K^\\pi) = \\max_{i,j : K^\\pi_{ij} \\neq 0} |i - j| + 1$。其实现方式是：找到 $K^\\pi$ 的所有非零元素（高于数值阈值 $\\varepsilon = 10^{-12}$），计算其行和列索引的绝对差，然后取这些差值的最大值再加一。\n\n- **严格下三角填充**：在 Cholesky 分解 $K^\\pi = LL^\\top$ 过程中，在因子 $L$ 中可能会出现新的非零元素，称为“填充”，这些位置在 $K^\\pi$ 中原本是零。填充计数就是这类位置的数量。其计算方法是：使用 `scipy.linalg.cholesky` 对 $K^\\pi$ 进行 Cholesky 分解得到 $L$，然后计算满足 $i > j$ 且 $|L_{ij}|> \\varepsilon$ 但 $|K^\\pi_{ij}| \\le \\varepsilon$ 的数对 $(i,j)$ 的数量。\n\n### 4. 算法流程\n\n该解决方案包含一个主函数，它会遍历所有指定的测试用例。对于每个用例 $(m, n, \\text{ordering})$：\n1. 使用自然排序构造 $mn \\times mn$ 的刚度矩阵 $K$。\n2. 根据指定的排序类型生成置換数组 $\\pi$。\n3. 应用置換得到 $K^\\pi = K[\\pi, :][:, \\pi]$。\n4. 计算带宽 $B(K^\\pi)$。\n5. 计算 $K^\\pi$ 的 Cholesky 因子 $L$。\n6. 通过比较 $K^\\pi$ 和 $L$ 的结构来计算填充数 $F$。\n7. 存储配对 $[B, F]$ 并继续处理下一个用例。\n最后，将收集到的结果格式化为指定的字符串格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import reverse_cuthill_mckee\nfrom scipy.linalg import cholesky\n\ndef construct_stiffness_matrix(m, n):\n    \"\"\"\n    Constructs the global stiffness matrix K for an m x n grid.\n    \n    Args:\n        m (int): Number of rows of interior grid points.\n        n (int): Number of columns of interior grid points.\n        \n    Returns:\n        numpy.ndarray: The NxN global stiffness matrix, where N = m*n.\n    \"\"\"\n    N = m * n\n    if N == 0:\n        return np.array([[]])\n    \n    K = np.zeros((N, N), dtype=np.float64)\n    \n    for i in range(m):\n        for j in range(n):\n            k = i * n + j\n            \n            # Diagonal entry\n            K[k, k] = 4\n            \n            # Off-diagonal entries for 4-neighbors\n            # Right neighbor\n            if j  n - 1:\n                l = i * n + (j + 1)\n                K[k, l] = -1.0\n                K[l, k] = -1.0\n            \n            # Bottom neighbor\n            if i  m - 1:\n                l = (i + 1) * n + j\n                K[k, l] = -1.0\n                K[l, k] = -1.0\n                \n    return K\n\ndef compute_bandwidth(matrix, epsilon=1e-12):\n    \"\"\"\n    Computes the symmetric bandwidth of a matrix as per the problem definition.\n    B(A) = max |i-j| + 1 for A_ij != 0.\n    \n    Args:\n        matrix (numpy.ndarray): The input matrix.\n        epsilon (float): Threshold to consider an entry as non-zero.\n        \n    Returns:\n        int: The symmetric bandwidth.\n    \"\"\"\n    if matrix.shape[0] = 1:\n        return matrix.shape[0]\n\n    rows, cols = np.nonzero(np.abs(matrix) > epsilon)\n    \n    if rows.size == 0:\n        return 1\n        \n    return np.max(np.abs(rows - cols)) + 1\n\ndef compute_fill_in(original_matrix, cholesky_factor, epsilon=1e-12):\n    \"\"\"\n    Computes the strictly lower-triangular fill-in count.\n    \n    Args:\n        original_matrix (numpy.ndarray): The permuted stiffness matrix K_pi.\n        cholesky_factor (numpy.ndarray): The lower triangular Cholesky factor L.\n        epsilon (float): Threshold for non-zero entries.\n        \n    Returns:\n        int: The number of fill-in entries.\n    \"\"\"\n    if original_matrix.shape[0] = 1:\n        return 0\n        \n    # Create masks for the strictly lower triangular part\n    k_pi_lower_is_zero = np.abs(np.tril(original_matrix, k=-1)) = epsilon\n    l_lower_is_nonzero = np.abs(np.tril(cholesky_factor, k=-1)) > epsilon\n    \n    fill_in_count = np.sum(np.logical_and(k_pi_lower_is_zero, l_lower_is_nonzero))\n    \n    return int(fill_in_count)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (m, n, ordering_type)\n        (1, 1, \"natural\"),\n        (4, 4, \"natural\"),\n        (4, 4, \"rcm\"),\n        (8, 4, \"natural\"),\n        (8, 4, \"rcm\"),\n        (10, 10, \"rcm\"),\n        (10, 10, \"random\"),\n    ]\n\n    epsilon = 1e-12\n    results = []\n\n    for m, n, ordering in test_cases:\n        N = m * n\n        K = construct_stiffness_matrix(m, n)\n\n        pi = None\n        if ordering == \"natural\":\n            pi = np.arange(N)\n        elif ordering == \"rcm\":\n            if N > 0:\n                # The CSR graph representation is needed for the RCM algorithm.\n                graph = csr_matrix(K)\n                pi = reverse_cuthill_mckee(graph)\n            else:\n                pi = np.array([], dtype=int)\n        elif ordering == \"random\":\n            rng = np.random.default_rng(seed=42)\n            pi = rng.permutation(N)\n\n        if N > 0:\n            # Apply the permutation to get the reordered matrix K_pi\n            K_pi = K[pi, :][:, pi]\n            \n            # Compute bandwidth\n            B = compute_bandwidth(K_pi, epsilon)\n            \n            # Compute Cholesky factorization and fill-in\n            # The matrix is SPD, so Cholesky factorization will succeed.\n            L = cholesky(K_pi, lower=True)\n            F = compute_fill_in(K_pi, L, epsilon)\n        else:\n            B, F = 0, 0\n            \n        results.append([B, F])\n\n    # Format the final output string exactly as required, without extra spaces.\n    formatted_results = [f\"[{b},{f}]\" for b, f in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3437048"}]}