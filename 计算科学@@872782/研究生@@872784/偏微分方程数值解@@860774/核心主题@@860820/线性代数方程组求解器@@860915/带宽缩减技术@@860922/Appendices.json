{"hands_on_practices": [{"introduction": "像Cuthill-McKee这样的排序算法的有效性在很大程度上取决于起始节点的选择。一个好的起点通常是图的“外围”节点，即一个远离图“中心”的节点，因为它能生成一个窄而深的广度优先搜索（BFS）层级结构。本练习将通过一个常用启发式算法——伪外围节点检测算法，让您亲手实践如何找到这样的节点。[@problem_id:3365607]", "problem": "考虑一个稀疏线性系统，该系统由单位正方形上泊松方程在大小为 $6\\times 6$ 的均匀网格上采用狄利克雷边界条件的标准五点有限差分格式产生。所得矩阵的邻接结构是一个图 $G$，其顶点对应于网格点 $\\{(i,j): i,j\\in\\{1,2,3,4,5,6\\}\\}$，其边连接在且仅在一个坐标上相差恰好为一的顶点对。这就是 $6\\times 6$ 网格图，它是诸如 Reverse Cuthill–McKee 算法等带宽缩减技术的典型测试平台。\n\n实践中常用的一种带宽缩减启发式方法是从一个所谓的伪外围节点开始进行 Reverse Cuthill–McKee 排序，该节点通过伪外围检测过程获得：从一个初始顶点 $s_{0}$ 开始，计算以 $s_{0}$ 为根的广度优先搜索 (BFS) 层级结构；然后从最后一个非空层级中选取一个顶点 $s_{1}$，重新计算以 $s_{1}$ 为根的 BFS 层级，并重复此过程，每当层级数严格增加时，就用新结构最后一层的一个顶点替换 $s_{k}$；当层级数不再增加时，该过程终止，并将当前根节点声明为伪外围节点。以 $s$ 为根的 BFS 层级数等于 $s$ 的离心率加一，其中离心率是 $s$ 到图 $G$ 中任意顶点的最大图距离。\n\n从内部节点 $s_{0}=(3,4)$ 开始，执行伪外围检测过程直至终止（通过对网格几何的精确推理进行符号化操作），并确定终止时的 BFS 层级数 $L_{\\mathrm{pp}}$。另外，确定当根为角节点 $(1,1)$ 时的 BFS 层级数 $L_{\\mathrm{corner}}$，以及当根为内部“中心”节点 $(3,3)$ 时的 BFS 层级数 $L_{\\mathrm{center}}$。\n\n计算标量差\n$$\n\\Delta L \\equiv L_{\\mathrm{pp}} - L_{\\mathrm{center}}.\n$$\n答案以无单位的精确整数形式给出。无需四舍五入。在你的推理中，从关于网格图的第一性原理出发，证明你报告的 BFS 层级数为何正确，以及为什么伪外围检测在此图上于所声称的节点处终止。你可以假定图距离、离心率和广度优先搜索 (BFS) 的基本定义，但不要假定超出这些定义之外的任何快捷公式。", "solution": "该问题要求分析一个特定的图并执行一个顶点排序算法。我们首先来形式化问题设定。\n\n图 $G=(V, E)$ 是 $6 \\times 6$ 网格图。顶点集为 $V = \\{(i,j) : i,j \\in \\{1, 2, 3, 4, 5, 6\\}\\}$。两个顶点 $(i_1, j_1)$ 和 $(i_2, j_2)$ 之间存在一条边，当且仅当 $|i_1 - i_2| + |j_1 - j_2| = 1$。两个顶点 $v_1 = (i_1, j_1)$ 和 $v_2 = (i_2, j_2)$ 之间的图距离 $d(v_1, v_2)$ 是它们之间最短路径的长度，在网格图上由曼哈顿距离给出：\n$$\nd(v_1, v_2) = |i_1 - i_2| + |j_1 - j_2|\n$$\n顶点 $v \\in V$ 的离心率，记为 $e(v)$，是 $v$ 到图中任何其他顶点的最大距离：\n$$\ne(v) = \\max_{u \\in V} d(v,u)\n$$\n对于网格图，距离 $v=(i,j)$ 最远的顶点 $u$ 必定是四个角顶点之一：$(1,1)$、$(1,6)$、$(6,1)$ 或 $(6,6)$。这是因为距离函数 $d((i,j),(i',j')) = |i-i'| + |j-j'|$ 的最大化可以通过独立地最大化 $|i-i'|$ 和 $|j-j'|$ 这两项来实现。使 $|i-i'|$ 最大化的 $i'$ 的值是 $1$ 或 $6$，对于 $j'$ 也是如此。因此，$e(v) = \\max\\{d(v,(1,1)), d(v,(1,6)), d(v,(6,1)), d(v,(6,6))\\}$。\n\n以顶点 $v$ 为根的广度优先搜索 (BFS) 的层级数由 $L(v) = e(v) + 1$ 给出，因为层级的索引从 $0$ 到 $e(v)$。\n\n我们现在从 $s_0 = (3,4)$ 开始执行伪外围检测过程。\n\n**步骤 0：** 初始根为 $s_0 = (3,4)$。我们计算其离心率 $e(s_0)$。\n$d(s_0, (1,1)) = |3-1| + |4-1| = 2+3 = 5$。\n$d(s_0, (1,6)) = |3-1| + |4-6| = 2+2 = 4$。\n$d(s_0, (6,1)) = |3-6| + |4-1| = 3+3 = 6$。\n$d(s_0, (6,6)) = |3-6| + |4-6| = 3+2 = 5$。\n这些距离中的最大值为 $6$。所以，$e(s_0) = 6$。\n初始的 BFS 层级数为 $L_0 = L(s_0) = e(s_0) + 1 = 6+1=7$。\n距离 $s_0$ 为 $6$ 的最后一个 BFS 层级，由单个顶点 $(6,1)$ 组成。\n\n**步骤 1：** 我们从以 $s_0$ 为根的 BFS 的最后一层中选择一个顶点。唯一的选择是 $s_1 = (6,1)$。我们现在计算其离心率 $e(s_1)$。\n$d(s_1, (1,1)) = |6-1| + |1-1| = 5+0 = 5$。\n$d(s_1, (1,6)) = |6-1| + |1-6| = 5+5 = 10$。\n$d(s_1, (6,6)) = |6-6| + |1-6| = 0+5 = 5$。\n最大距离为 $10$。所以，$e(s_1) = 10$。\n以 $s_1$ 为根的 BFS 层级数为 $L_1 = L(s_1) = e(s_1) + 1 = 10+1=11$。\n由于 $L_1 = 11 > L_0 = 7$，层级数严格增加。过程继续，$s_1$ 成为新的当前根。以 $s_1$ 为根、距离为 $10$ 的最后一个 BFS 层级由单个顶点 $(1,6)$ 组成。\n\n**步骤 2：** 我们从以 $s_1$ 为根的 BFS 的最后一层中选择顶点，即 $s_2 = (1,6)$。我们计算其离心率 $e(s_2)$。\n$d(s_2, (1,1)) = |1-1| + |6-1| = 0+5 = 5$。\n$d(s_2, (6,1)) = |1-6| + |6-1| = 5+5 = 10$。\n$d(s_2, (6,6)) = |1-6| + |6-6| = 5+0 = 5$。\n最大距离为 $10$。所以，$e(s_2) = 10$。\n以 $s_2$ 为根的 BFS 层级数为 $L_2 = L(s_2) = e(s_2) + 1 = 10+1=11$。\n我们将此与之前的层级数 $L_1 = 11$进行比较。由于 $L_2=11$ 并不严格大于 $L_1=11$，继续的条件未满足。过程终止。终止时的当前根是 $s_1=(6,1)$，它被声明为伪外围节点。与此终止状态相关联的 BFS 层级数对应于最后一次成功更新的层级数，即 $L_1$。因此，终止时的 BFS 层级数是 $L_{\\mathrm{pp}} = L_1 = 11$。\n\n接下来，我们确定指定的角节点和中心节点的 BFS 层级数。\n\n对于角节点 $(1,1)$，我们计算其离心率 $e((1,1))$：\n$d((1,1), (1,6)) = |1-1| + |1-6| = 0+5=5$。\n$d((1,1), (6,1)) = |1-6| + |1-1| = 5+0=5$。\n$d((1,1), (6,6)) = |1-6| + |1-6| = 5+5=10$。\n最大距离为 $10$，所以 $e((1,1)) = 10$。\nBFS 层级数为 $L_{\\mathrm{corner}} = L((1,1)) = e((1,1)) + 1 = 10+1=11$。\n\n对于中心节点 $(3,3)$，我们计算其离心率 $e((3,3))$：\n$d((3,3), (1,1)) = |3-1| + |3-1| = 2+2=4$。\n$d((3,3), (1,6)) = |3-1| + |3-6| = 2+3=5$。\n$d((3,3), (6,1)) = |3-6| + |3-1| = 3+2=5$。\n$d((3,3), (6,6)) = |3-6| + |3-6| = 3+3=6$。\n最大距离为 $6$，所以 $e((3,3)) = 6$。\nBFS 层级数为 $L_{\\mathrm{center}} = L((3,3)) = e((3,3)) + 1 = 6+1=7$。\n\n最后，我们计算所需的差值 $\\Delta L$。\n$$\n\\Delta L = L_{\\mathrm{pp}} - L_{\\mathrm{center}}\n$$\n代入我们计算出的值：\n$$\n\\Delta L = 11 - 7 = 4\n$$\n标量差为 $4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3365607"}, {"introduction": "在上一个练习的基础上，我们已经了解了如何寻找一个好的起始节点，现在这个练习将量化地展示其带来的巨大差异。通过对同一个图应用Cuthill-McKee (CM) 算法，但分别从两个不同的节点（一个外围节点和一个中心节点）开始，您将能直接计算并比较最终的带宽。这个对比将清晰地揭示为何在带宽缩减中，选择正确的起点至关重要。[@problem_id:3365677]", "problem": "在偏微分方程的数值解法中，稀疏对称正定矩阵产生于网格上的离散化。对于直接求解器而言，一个经典的预处理步骤是使用 Cuthill–McKee (CM) 算法来减小矩阵带宽。对于一个简单无向图 $G=(V,E)$，其标号 $\\pi:V\\to\\{1,\\dots,|V|\\}$ 的带宽定义为 $b(\\pi)=\\max_{(i,j)\\in E}|\\pi(i)-\\pi(j)|$。从一个选定的起始顶点 $s$ 开始的 Cuthill–McKee (CM) 排序是通过广度优先搜索 (BFS) 获得的，该搜索按度数非递减的顺序访问邻接点，若度数相同则选择顶点索引较小的点。对于 $s$ 的一个很好的实践选择是一个伪外围节点。伪外围节点是一个离心率（即到任何其他顶点的最大图距离）接近图直径的顶点，它可以通过重复的 BFS 层扩展启发式地找到。\n\n考虑下面这个显式构造的图 $G$，它模拟了在自适应有限元离散化中出现的分层二叉细化树。设 $V=\\{1,2,\\dots,15\\}$ 且 $E$ 是高度为 $3$、根为 $1$ 的满二叉树的边集，即\n$$(1,2),(1,3),(2,4),(2,5),(3,6),(3,7),(4,8),(4,9),(5,10),(5,11),(6,12),(6,13),(7,14),(7,15)。$$\n该树的直径为 $6$，是在任意两个位于相对子树中的叶节点之间达到的。根节点 $1$ 的离心率为 $3$，因此是非外围节点。而任何深度为 $3$ 的叶节点（例如 $8$）都是外围节点，因此可以作为伪外围起始点。\n\n使用上述精确的 CM 访问规则（邻接点按度数非递减严格排序，若度数相同则选择索引较小的点），计算：\n- 从非外围节点 $1$ 开始的 CM 排序 $\\pi_{1}$ 及其带宽 $b(\\pi_{1})$，\n- 从伪外围节点 $8$ 开始的 CM 排序 $\\pi_{8}$ 及其带宽 $b(\\pi_{8})$，\n\n然后报告精确的带宽差\n$$\\Delta b = b(\\pi_{1}) - b(\\pi_{8})。$$\n将 $\\Delta b$ 的最终结果以单个整数形式提供，不带单位。无需四舍五入。", "solution": "问题要求计算给定图从两个不同顶点开始的两种 Cuthill-McKee (CM) 排序之间的带宽差。该过程包括三个主要步骤：\n$1$。 计算从顶点 $s=1$ 开始的 CM 排序 $\\pi_1$ 及其带宽 $b(\\pi_1)$。\n$2$。 计算从顶点 $s=8$ 开始的 CM 排序 $\\pi_8$ 及其带宽 $b(\\pi_8)$。\n$3$。 计算差值 $\\Delta b = b(\\pi_1) - b(\\pi_8)$。\n\n图 $G=(V, E)$ 是一个高度为 $3$ 的满二叉树。\n顶点集为 $V = \\{1, 2, \\dots, 15\\}$。\n边集 $E$ 由以下给出：\n$(1,2), (1,3), (2,4), (2,5), (3,6), (3,7), (4,8), (4,9), (5,10), (5,11), (6,12), (6,13), (7,14), (7,15)$。\n\nCM 算法是一种广度优先搜索 (BFS)，其中顶点的邻接点按度数非递减的顺序被访问。若度数相同，则选择索引较小的顶点。\n\n首先，我们确定图 $G$ 中每个顶点的度数：\n- 根节点，顶点 $1$，度数为 $\\deg(1)=2$。\n- 第 $1$ 层和第 $2$ 层的内部节点，即顶点 $\\{2, 3, 4, 5, 6, 7\\}$，每个的度数都为 $3$。\n- 叶节点，即顶点 $\\{8, 9, 10, 11, 12, 13, 14, 15\\}$，每个的度数都为 $1$。\n\n**第1部分：从 $s=1$ 开始的 CM 排序 $\\pi_1$**\n\n我们从顶点 $1$ 开始执行 BFS。顶点的排序将用序列 $P_1$ 表示，其中 $P_1[k]$是被赋予新标号 $k$ 的顶点。标号 $\\pi_1$是其逆映射，即 $\\pi_1(P_1[k])=k$。\n\n$1$。 初始化：队列 $Q=[1]$，新排序 $P_1=[1]$，已访问集合 $S=\\{1\\}$，标号计数器 $k=1$。\n$2$。 出队 $1$。邻接点为 $\\{2, 3\\}$。二者度数均为 $3$。根据顶点索引大小决定顺序：$2, 3$。因此，先访问 $2$，再访问 $3$。\n   - $2$ 入队，$P_1=[1, 2]$，$S=\\{1,2\\}$，$k=2$。\n   - $3$ 入队，$P_1=[1, 2, 3]$，$S=\\{1,2,3\\}$，$k=3$。\n   - 现在 $Q$ 为 $[2, 3]$。\n$3$。 出队 $2$。未访问的邻接点为 $\\{4, 5\\}$。二者度数均为 $3$。根据索引大小决定顺序：$4, 5$。先访问 $4$ 再访问 $5$。\n   - $4$ 入队，$P_1=[1, \\dots, 3, 4]$，$S=\\{1,2,3,4\\}$，$k=4$。\n   - $5$ 入队，$P_1=[1, \\dots, 4, 5]$，$S=\\{1,2,3,4,5\\}$，$k=5$。\n   - 现在 $Q$ 为 $[3, 4, 5]$。\n$4$。 出队 $3$。未访问的邻接点为 $\\{6, 7\\}$。二者度数均为 $3$。根据索引大小决定顺序：$6, 7$。先访问 $6$ 再访问 $7$。\n   - $6$ 入队，$P_1=[1, \\dots, 5, 6]$，$S=\\{...,6\\}$，$k=6$。\n   - $7$ 入队，$P_1=[1, \\dots, 6, 7]$，$S=\\{...,7\\}$，$k=7$。\n   - 现在 $Q$ 为 $[4, 5, 6, 7]$。\n$5$。 出队 $4$。未访问的邻接点为 $\\{8, 9\\}$。二者度数均为 $1$。根据索引大小决定顺序：$8, 9$。先访问 $8$ 再访问 $9$。\n   - $8$ 入队，$P_1=[1, \\dots, 7, 8]$，$S=\\{...,8\\}$，$k=8$。\n   - $9$ 入队，$P_1=[1, \\dots, 8, 9]$，$S=\\{...,9\\}$，$k=9$。\n   - 现在 $Q$ 为 $[5, 6, 7, 8, 9]$。\n$6$。 这个过程逐层继续。对于每个父节点，由于其子节点的度数相同，它们将按顶点索引递增的顺序被访问。\n   - 出队 $5$，访问邻接点 $10, 11$。$P_1$ 中追加 $10, 11$。\n   - 出队 $6$，访问邻接点 $12, 13$。$P_1$ 中追加 $12, 13$。\n   - 出队 $7$，访问邻接点 $14, 15$。$P_1$ 中追加 $14, 15$。\n最终的顶点排序序列为 $P_1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]$。\n这意味着标号 $\\pi_1$ 是恒等映射：对所有 $i \\in V$，$\\pi_1(i) = i$。\n\n带宽 $b(\\pi_1)$ 为 $\\max_{(i,j)\\in E} |\\pi_1(i) - \\pi_1(j)| = \\max_{(i,j)\\in E} |i - j|$。我们检查所有边：\n- $|1-2|=1$, $|1-3|=2$\n- $|2-4|=2$, $|2-5|=3$\n- $|3-6|=3$, $|3-7|=4$\n- $|4-8|=4$, $|4-9|=5$\n- $|5-10|=5$, $|5-11|=6$\n- $|6-12|=6$, $|6-13|=7$\n- $|7-14|=7$, $|7-15|=8$\n最大差值为 $8$。因此，$b(\\pi_1) = 8$。\n\n**第2部分：从 $s=8$ 开始的 CM 排序 $\\pi_8$**\n\n我们从外围顶点 $8$ 开始执行 BFS。\n$1$。 初始化：$Q=[8]$，$P_8=[8]$，$S=\\{8\\}$，$k=1$。\n$2$。 出队 $8$。邻接点为 $\\{4\\}$。访问 $4$。\n   - $4$ 入队，$P_8=[8, 4]$，$S=\\{8,4\\}$，$k=2$。$Q=[4]$。\n$3$。 出队 $4$。未访问的邻接点为 $\\{2, 9\\}$。我们有 $\\deg(9)=1$ 和 $\\deg(2)=3$。按度数非递减排序：先访问 $9$ 再访问 $2$。\n   - $9$ 入队，$P_8=[8, 4, 9]$，$S=\\{8,4,9\\}$，$k=3$。\n   - $2$ 入队，$P_8=[8, 4, 9, 2]$，$S=\\{8,4,9,2\\}$，$k=4$。\n   - 现在 $Q$ 为 $[9, 2]$。\n$4$。 出队 $9$。邻接点 $\\{4\\}$ 已被访问。$Q=[2]$。\n$5$。 出队 $2$。未访问的邻接点为 $\\{1, 5\\}$。我们有 $\\deg(1)=2$ 和 $\\deg(5)=3$。按度数排序：先访问 $1$ 再访问 $5$。\n   - $1$ 入队，$P_8=[8, 4, 9, 2, 1]$，$S=\\{...,1\\}$，$k=5$。\n   - $5$ 入队，$P_8=[8, 4, 9, 2, 1, 5]$，$S=\\{...,5\\}$，$k=6$。\n   - 现在 $Q$ 为 $[1, 5]$。\n$6$。 出队 $1$。未访问的邻接点为 $\\{3\\}$。访问 $3$。\n   - $3$ 入队，$P_8=[... ,1, 5, 3]$，$S=\\{...,3\\}$，$k=7$。$Q=[5, 3]$。\n$7$。 出队 $5$。未访问的邻接点为 $\\{10, 11\\}$。二者度数均为 $1$。根据索引大小决定顺序：$10, 11$。先访问 $10$ 再访问 $11$。\n   - $10$ 入队，$P_8=[..., 5, 3, 10]$，$S=\\{...,10\\}$，$k=8$。\n   - $11$ 入队，$P_8=[..., 3, 10, 11]$，$S=\\{...,11\\}$，$k=9$。\n   - 现在 $Q$ 为 $[3, 10, 11]$。\n$8$。 出队 $3$。未访问的邻接点为 $\\{6, 7\\}$。二者度数均为 $3$。根据索引大小决定顺序：$6, 7$。先访问 $6$ 再访问 $7$。\n   - $6$ 入队，$P_8=[..., 10, 11, 6]$，$S=\\{...,6\\}$，$k=10$。\n   - $7$ 入队，$P_8=[..., 11, 6, 7]$，$S=\\{...,7\\}$，$k=11$。\n   - 现在 $Q$ 为 $[10, 11, 6, 7]$。\n$9$。 出队 $10$ 和 $11$。它们唯一的邻接点 $\\{5\\}$ 已被访问。$Q=[6, 7]$。\n$10$。 出队 $6$。未访问的邻接点 $\\{12, 13\\}$。二者度数均为 $1$。根据索引大小决定顺序：$12, 13$。先访问 $12$ 再访问 $13$。\n   - $12, 13$ 入队。$P_8$ 中追加 $12, 13$。$k=13$。$Q=[7, 12, 13]$。\n$11$。 出队 $7$。未访问的邻接点 $\\{14, 15\\}$。二者度数均为 $1$。根据索引大小决定顺序：$14, 15$。先访问 $14$ 再访问 $15$。\n   - $14, 15$ 入队。$P_8$ 中追加 $14, 15$。$k=15$。$Q=[12, 13, 14, 15]$。\n$12$。 出队剩余的叶节点 $12, 13, 14, 15$。它们没有未访问的邻接点。\n\n最终的顶点排序序列为 $P_8 = [8, 4, 9, 2, 1, 5, 3, 10, 11, 6, 7, 12, 13, 14, 15]$。\n标号 $\\pi_8$ 将一个顶点映射到它在此序列中的位置（标号）：\n$\\pi_8(8)=1$, $\\pi_8(4)=2$, $\\pi_8(9)=3$, $\\pi_8(2)=4$, $\\pi_8(1)=5$, $\\pi_8(5)=6$, $\\pi_8(3)=7$, $\\pi_8(10)=8$, $\\pi_8(11)=9$, $\\pi_8(6)=10$, $\\pi_8(7)=11$, $\\pi_8(12)=12$, $\\pi_8(13)=13$, $\\pi_8(14)=14$, $\\pi_8(15)=15$。\n\n带宽 $b(\\pi_8)$ 为 $\\max_{(i,j)\\in E} |\\pi_8(i) - \\pi_8(j)|$。我们检查所有边：\n- $(1,2): |\\pi_8(1)-\\pi_8(2)| = |5-4|=1$\n- $(1,3): |\\pi_8(1)-\\pi_8(3)| = |5-7|=2$\n- $(2,4): |\\pi_8(2)-\\pi_8(4)| = |4-2|=2$\n- $(2,5): |\\pi_8(2)-\\pi_8(5)| = |4-6|=2$\n- $(3,6): |\\pi_8(3)-\\pi_8(6)| = |7-10|=3$\n- $(3,7): |\\pi_8(3)-\\pi_8(7)| = |7-11|=4$\n- $(4,8): |\\pi_8(4)-\\pi_8(8)| = |2-1|=1$\n- $(4,9): |\\pi_8(4)-\\pi_8(9)| = |2-3|=1$\n- $(5,10): |\\pi_8(5)-\\pi_8(10)| = |6-8|=2$\n- $(5,11): |\\pi_8(5)-\\pi_8(11)| = |6-9|=3$\n- $(6,12): |\\pi_8(6)-\\pi_8(12)| = |10-12|=2$\n- $(6,13): |\\pi_8(6)-\\pi_8(13)| = |10-13|=3$\n- $(7,14): |\\pi_8(7)-\\pi_8(14)| = |11-14|=3$\n- $(7,15): |\\pi_8(7)-\\pi_8(15)| = |11-15|=4$\n最大差值为 $4$。因此，$b(\\pi_8) = 4$。\n\n**第3部分：带宽差**\n\n最后，我们计算差值 $\\Delta b$：\n$$ \\Delta b = b(\\pi_1) - b(\\pi_8) = 8 - 4 = 4. $$\n选择伪外围节点作为 Cuthill-McKee 算法的起始顶点，显著减小了矩阵的带宽。", "answer": "$$\\boxed{4}$$", "id": "3365677"}, {"introduction": "没有任何启发式算法是万能的，理解其局限性与优势同等重要。本练习旨在挑战您去研究一些特殊情况，在这些情况下，反向Cuthill-McKee (RCM) 算法实际上可能*增加*矩阵的带宽。通过分析像“哑铃”型网格这样的特定图结构，您将对该算法的行为及其与图拓扑（特别是瓶颈和割点）的关系有更深刻、更具批判性的理解。[@problem_id:3365697]", "problem": "本任务要求您探索排序算法在二维泊松方程离散化产生的稀疏矩阵上的行为，重点关注带宽缩减。考虑在网格（可视为图）上对二维泊松方程进行标准的线性有限差分或线性有限元离散化，这会产生一个对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其稀疏模式由网格的邻接关系确定。方阵 $A$ 的带宽 $b(A)$ 定义为\n$$\nb(A) = \\max\\{|i - j| \\mid A_{ij} \\neq 0 \\},\n$$\n对于给定的索引排列（排序）$p \\in \\{0,1,\\dots,n-1\\}^n$，置换后的带宽是矩阵 $PAP^\\top$ 的带宽，其中 $P$ 是与 $p$ 关联的排列矩阵。\n\n逆卡斯尔-麦基（Reverse Cuthill–McKee, RCM）技术是一种旨在缩减带宽的启发式算法。该算法从一个指定的根节点开始对图进行广度优先遍历，逐层访问顶点，在每一层内按度的非递减顺序对顶点排序，然后将得到的顺序反转。在实践中，有不同的根节点选择启发式方法；为完成此任务，您必须使用以下明确定义的变体：\n- 按如下方式选择一个起始顶点 $s$：如果图存在关节点（割点），则从中选择度最小的那个；如果存在多个这样的顶点，则选择索引最小的那个。如果不存在关节点，则选择度最小且索引最小的顶点。\n- 从 $s$ 开始执行广度优先搜索（BFS），按度的非递减顺序访问邻居（若度相同，则按索引从小到大排序）。\n- 如果图是非连通的，则对任何剩余的未访问分量重复上述过程（在每个阶段，按照相同的规则在未访问的顶点中选择新的根节点）。\n- 将连接起来的BFS顺序反转，以生成最终的RCM排列 $p_{\\mathrm{RCM}}$。\n\n从基本定义（从网格导出的图邻接关系、矩阵带宽定义和广度优先遍历）出发，构建确定性的网格，以揭示RCM在相对于初始几何排序时可能无法缩减带宽的情况，并对该失效机制提供一个几何特征描述。\n\n具体而言：\n1. 为规则网格构建离散拉普拉斯矩阵的邻接关系：一个大小为 $W \\times H$ 的矩形网格，其中网格点通过四邻接（曼哈顿距离等于 $1$）连接。使用初始排序 $p_{\\mathrm{geo}}$，该排序按 $x$ 非递减然后 $y$ 非递减的顺序扫描（即几何字典序）。\n2. 构建一个“哑铃形”网格，该网格由两列垂直的节点通过一个中心通道节点连接而成。具体来说，定义坐标集：\n   - 左列：$(0,0)$, $(0,1)$, $(0,2)$,\n   - 通道：$(1,1)$,\n   - 右列：$(2,0)$, $(2,1)$, $(2,2)$,\n   采用四邻接。使用初始排序 $p_{\\mathrm{geo}}$，该排序按以下顺序排列节点：所有左列节点（从 $(0,0)$ 到 $(0,2)$），然后是通道节点 $(1,1)$，最后是所有右列节点（从 $(2,0)$ 到 $(2,2)$）。对于这些坐标，该排序与几何字典序一致。\n3. 构建一个一维链式网格（一条直线路径）：坐标为 $(0,0), (1,0), (2,0), (3,0), (4,0)$，其中仅连续点之间存在邻接关系。使用初始排序 $p_{\\mathrm{geo}}$，该排序按 $x$ 非递减的顺序列出节点。\n\n对每个网格，计算：\n- 在初始几何排序 $p_{\\mathrm{geo}}$ 下的带宽 $b_{\\mathrm{geo}} = b(P_{\\mathrm{geo}} A P_{\\mathrm{geo}}^\\top)$。\n- 在上面定义的RCM排序 $p_{\\mathrm{RCM}}$ 下的带宽 $b_{\\mathrm{RCM}} = b(P_{\\mathrm{RCM}} A P_{\\mathrm{RCM}}^\\top)$。\n- 报告整数差值 $\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}}$。\n\n您必须严格按照上面 $b(A)$ 的定义来实现矩阵带宽的计算。您必须通过连接 $\\ell_1$ 范数下坐标差恰好为1的节点，从网格坐标构建邻接关系 $A$。您不需要计算数值有限差分系数；仅非零结构是必需的。通过遵守所述的离散化模式和定义，确保科学上的真实性。\n\n基于定义进行推导，解释为什么在所述的RCM变体下，“哑铃形”网格会导致带宽增加，并根据网格的图论属性（例如，割点和瓶颈）来描述导致此失效的几何特征。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与上述三个测试网格的描述完全一致。期望的输出类型为整数。例如，生成一行形如\n$$\n[\\Delta b_{\\mathrm{grid}}, \\Delta b_{\\mathrm{dumbbell}}, \\Delta b_{\\mathrm{chain}}].\n$$\n\n测试套件参数：\n- 网格：$W = 4$, $H = 4$ (RCM相对于几何排序不应增加带宽的理想情况)。\n- 哑铃形网格：上面指定的坐标 (RCM相对于给定几何排序增加带宽的反例候选)。\n- 链式网格：上面指定的坐标 (带宽已是最小的边界情况)。\n\n本问题不涉及物理单位或角度。请将每个数值结果以指定的列表格式表示为整数。", "solution": "用户提供的问题陈述已经过验证，被确定为是合理、适定且客观的。它在数值线性代数和图论领域提出了一个明确的任务，并提供了所有必要的定义、常数和约束。该问题要求实现并分析一种用于稀疏矩阵带宽缩减的逆卡斯尔-麦基（RCM）算法的特定变体。我们将给出一个完整的解决方案。\n\n### 带宽缩减简介\n在使用有限差分或有限元等方法对偏微分方程（PDE）进行数值求解时，得到的线性方程组 $Ax=b$ 通常涉及一个稀疏、对称且正定的矩阵 $A$。对此类方程组，直接求解器（例如，LU或Cholesky分解）的效率高度依赖于矩阵的结构。一个关键的结构特性是**带宽**，对于矩阵 $A$ 定义为：\n$$\nb(A) = \\max_{i,j} \\{|i - j| \\mid A_{ij} \\neq 0\\}\n$$\n较小的带宽意味着所有非零元素都聚集在主对角线周围。在分解过程中，可以利用这种结构来减少内存存储和计算工作量。重排序算法旨在找到矩阵行和列的一个排列 $p$，使得置换后的矩阵 $P A P^\\top$（其中 $P$ 是对应于 $p$ 的排列矩阵）的带宽显著小于原始矩阵 $A$。\n\n逆卡斯尔-麦基（RCM）算法是为此目的广泛使用的一种启发式算法。它基于对与矩阵稀疏模式相关联的图进行广度优先搜索（BFS）。本分析研究RCM的一种特定的、确定性的变体，并检验其在三种不同网格类型上的性能，其中包括一个旨在揭示该启发式算法失效模式的案例。\n\n### 方法论\n对每个网格，我们执行以下步骤：\n1.  **图的构建**：我们构建一个无向图 $G=(V, E)$，其中顶点 $V$ 对应于网格节点，边 $E$ 连接曼哈顿距离（$\\ell_1$ 范数）恰好为 $1$ 的节点。该图的邻接矩阵与离散拉普拉斯矩阵 $A$ 具有相同的非零模式。\n2.  **几何排序 ($p_{\\mathrm{geo}}$)**：我们为每个网格建立指定的初始“几何”排序 $p_{\\mathrm{geo}}$。这作为我们的基准。\n3.  **带宽计算 ($b_{\\mathrm{geo}}$)**：我们计算与几何排序对应的矩阵的带宽。原始节点 $u$ 和 $v$ 之间的一条边对带宽的贡献为 $|p_{\\mathrm{geo}}^{-1}(u) - p_{\\mathrm{geo}}^{-1}(v)|$，其中 $p_{\\mathrm{geo}}^{-1}(k)$ 是原始节点 $k$ 的新索引。\n4.  **RCM排序 ($p_{\\mathrm{RCM}}$)**：我们实现问题中定义的RCM算法：\n    a.  **根节点选择**：如果存在关节点，则根节点是度最小的那个（索引最小者作为决胜条件）。否则，它是全局度最小的顶点（索引最小者作为决胜条件）。\n    b.  **遍历**：从根节点开始执行BFS。在访问一个节点的邻居时，按度的非递减顺序处理它们（索引最小者作为决胜条件）。\n    c.  **反转**：最终的排列 $p_{\\mathrm{RCM}}$ 是BFS遍历顺序的反转。\n5.  **带宽计算 ($b_{\\mathrm{RCM}}$)**：我们计算经RCM置换后的矩阵的带宽。\n6.  **比较**：我们计算差值 $\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}}$。\n\n### 测试案例分析\n\n#### 1. 网格 ($4 \\times 4$)\n构建一个具有 $n=WH$ 个节点的 $W \\times H$ 网格图。几何排序 $p_{\\mathrm{geo}}$ 是字典序，其中节点 $(x,y)$ 被赋予索引 $i = xH + y$。对于 $4 \\times 4$ 网格，$H=4$。\n*   **几何带宽 ($b_{\\mathrm{geo}}$)**：最大索引差出现在垂直相邻的节点之间。一个索引为 $i = 4x+y$ 的节点 $(x,y)$ 与索引为 $j = 4(x+1)+y$ 的节点 $(x+1, y)$ 相连。差值为 $|j-i| = 4$。因此，$b_{\\mathrm{geo}} = 4$。\n*   **RCM带宽 ($b_{\\mathrm{RCM}}$)**：该网格没有关节点。度最小的节点是四个角点（度为 $2$）。根节点是角点 $(0,0)$（原始索引为 $0$），其索引最小。RCM从此角点开始执行BFS，创建以波前形式扩展的层集。反转此顺序会将远离根节点的节点放在排列的开头。这是RCM的典型应用，通常表现良好。计算得出结果带宽 $b_{\\mathrm{RCM}}$ 为 $4$。\n*   **结果**：$\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}} = 4 - 4 = 0$。在这种情况下，RCM没有使带宽恶化。\n\n#### 2. 哑铃形网格\n该网格由 $7$ 个节点组成，形成两个三节点的瓣，由一个中心节点连接。几何排序为 $p_{\\mathrm{geo}} = (0, 1, 2, 3, 4, 5, 6)$，其中节点 $0, 1, 2$ 构成左瓣，$3$ 是通道，$4, 5, 6$ 构成右瓣。\n*   **几何带宽 ($b_{\\mathrm{geo}}$)**：图的边为 $(0,1), (1,2), (1,3), (3,5), (4,5), (5,6)$。我们检查每条边的索引差：\n    *   $|p_{\\mathrm{geo}}^{-1}(1) - p_{\\mathrm{geo}}^{-1}(0)| = |1-0|=1$\n    *   $|p_{\\mathrm{geo}}^{-1}(2) - p_{\\mathrm{geo}}^{-1}(1)| = |2-1|=1$\n    *   $|p_{\\mathrm{geo}}^{-1}(3) - p_{\\mathrm{geo}}^{-1}(1)| = |3-1|=2$\n    *   $|p_{\\mathrm{geo}}^{-1}(5) - p_{\\mathrm{geo}}^{-1}(3)| = |5-3|=2$\n    *   $|p_{\\mathrm{geo}}^{-1}(5) - p_{\\mathrm{geo}}^{-1}(4)| = |5-4|=1$\n    *   $|p_{\\mathrm{geo}}^{-1}(6) - p_{\\mathrm{geo}}^{-1}(5)| = |6-5|=1$\n    最大差值为 $2$。因此，$b_{\\mathrm{geo}} = 2$。\n*   **RCM带宽 ($b_{\\mathrm{RCM}}$)**：我们遵循指定的RCM步骤：\n    1.  **寻找关节点 (APs)**：节点 $1, 3, 5$ 是关节点。\n    2.  **选择根节点**：它们的度分别为 $\\text{deg}(1)=3, \\text{deg}(3)=2, \\text{deg}(5)=3$。度最小的关节点是节点 $3$。它成为根节点。\n    3.  **BFS遍历**：\n        *   从根节点开始：$\\{3\\}$\n        *   $3$ 的邻居是 $\\{1, 5\\}$。两者度都为 $3$。以较小索引决胜：先访问 $1$ 再访问 $5$。队列：$\\{1, 5\\}$。\n        *   $1$ 的邻居是 $\\{0, 2\\}$。两者度都为 $1$。以索引决胜：先访问 $0$ 再访问 $2$。队列：$\\{5, 0, 2\\}$。\n        *   $5$ 的邻居是 $\\{4, 6\\}$。两者度都为 $1$。以索引决胜：先访问 $4$ 再访问 $6$。队列：$\\{0, 2, 4, 6\\}$。\n        Cuthill-McKee (CM) 顺序为 $p_{\\mathrm{CM}} = (3, 1, 5, 0, 2, 4, 6)$。\n    4.  **反转顺序**：$p_{\\mathrm{RCM}} = (6, 4, 2, 0, 5, 1, 3)$。\n    5.  **计算带宽**：我们找到每个节点的新索引 $p_{\\mathrm{RCM}}^{-1}$ 并检查边的差值。边 $(5,6)$ 是一个很好的例子。它的原始节点是 $5$ 和 $6$。它们的新索引是 $p_{\\mathrm{RCM}}^{-1}(5)=4$ 和 $p_{\\mathrm{RCM}}^{-1}(6)=0$。差值为 $|4-0|=4$。完整的计算证实了 $b_{\\mathrm{RCM}} = 4$。\n*   **结果**：$\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}} = 4 - 2 = 2$。带宽增加了。\n\n#### 3. 链式网格\n一个 $5$ 节点的路径图。原始节点索引为 $0, 1, 2, 3, 4$。$p_{\\mathrm{geo}}$ 就是这个自然排序。\n*   **几何带宽 ($b_{\\mathrm{geo}}$)**：边是 $(i, i+1)$。索引差始终为 $1$。因此，$b_{\\mathrm{geo}} = 1$。这是最优带宽。\n*   **RCM带宽 ($b_{\\mathrm{RCM}}$)**：\n    1.  **寻找关节点**：节点 $1, 2, 3$ 是关节点。\n    2.  **选择根节点**：所有关节点的度都为 $2$。索引最小的是节点 $1$。\n    3.  **BFS遍历**：从根节点 $1$ 开始：访问邻居 $0$（度为 $1$），然后是邻居 $2$（度为 $2$）。然后从 $2$ 访问 $3$，从 $3$ 访问 $4$。CM顺序是 $p_{\\mathrm{CM}} = (1, 0, 2, 3, 4)$。\n    4.  **反转顺序**：$p_{\\mathrm{RCM}} = (4, 3, 2, 0, 1)$。\n    5.  **计算带宽**：考虑边 $(1,2)$。新索引是 $p_{\\mathrm{RCM}}^{-1}(1)=4$ 和 $p_{\\mathrm{RCM}}^{-1}(2)=2$。差值为 $|4-2|=2$。完整的计算得出 $b_{\\mathrm{RCM}} = 2$。\n*   **结果**：$\\Delta b = b_{\\mathrm{RCM}} - b_{\\mathrm{geo}} = 2 - 1 = 1$。带宽增加了。\n\n### RCM失效的特征描述\n哑铃形网格是RCM的一个典型失效模式的例证。性能的下降不是随机的，而是图的拓扑结构与算法的根节点选择启发式方法之间相互作用的直接结果。\n\n导致此问题的几何特征是**瓶颈**结构，即两个或多个相对稠密的子图通过少数顶点或边连接。在哑铃形网格中，节点 $3$（“通道”）充当连接两个瓣的低度关节点。\n\n指定的RCM变体优先选择低度关节点作为根节点。通过选择中心的瓶颈节点 $3$ 作为根，随后的BFS遍历会同时向两个瓣扩展。BFS的层集（例如，第1层包含节点 $\\{1, 5\\}$）将拓扑上相距较远但在图距离上与中心根节点等距的节点组合在一起。\n\nRCM的最后一步是反转这个顺序。这将图的末端节点（例如，节点 $6, 4, 2, 0$）放置在新排列的开头。关键是，它将原本在同一瓣内相邻的节点分散开。例如，相邻的节点 $5$ 和 $6$ 被赋予了新的索引 $4$ 和 $0$，导致了 $4$ 这样大的索引差。相比之下，几何排序保持了每个瓣内节点的连续性，从而获得了较小的带宽。\n\n总而言之，当RCM的根节点选择策略选中山一个结构性瓶颈上的顶点时，该启发式算法就会失效。这会导致BFS排序交错地排列来自图的不同区域的节点，而最终的反转会破坏局部连通性，从而增加矩阵带宽。一个理想的起始顶点应该是位于图外围的低度节点（如节点 $0$ 或 $6$），这样会产生一个尊重图的几何布局的层结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the bandwidth analysis for the three specified meshes.\n    \"\"\"\n\n    def _find_articulation_points(n, adj):\n        \"\"\"\n        Finds all articulation points in a graph using a DFS-based algorithm.\n        This is a standard algorithm related to Tarjan's bridge-finding algorithm.\n        \"\"\"\n        timer_ref = [0]\n        tin = [-1] * n\n        low = [-1] * n\n        parent = [-1] * n\n        ap_set = set()\n\n        def dfs(u):\n            tin[u] = low[u] = timer_ref[0]\n            timer_ref[0] += 1\n            children = 0\n\n            for v in adj[u]:\n                if v == parent[u]:\n                    continue\n                if tin[v] != -1:\n                    low[u] = min(low[u], tin[v])\n                else:\n                    children += 1\n                    parent[v] = u\n                    dfs(v)\n                    low[u] = min(low[u], low[v])\n                    if parent[u] == -1 and children > 1:\n                        ap_set.add(u)\n                    if parent[u] != -1 and low[v] >= tin[u]:\n                        ap_set.add(u)\n\n        for i in range(n):\n            if tin[i] == -1:\n                dfs(i)\n        \n        return list(ap_set)\n\n    def select_root(degrees, aps, visited):\n        \"\"\"\n        Selects a root for BFS according to the problem's specific heuristic.\n        \"\"\"\n        unvisited_nodes = [i for i, v in enumerate(visited) if not v]\n        \n        unvisited_aps = [ap for ap in aps if not visited[ap]]\n        \n        candidate_nodes = []\n        if unvisited_aps:\n            min_deg_ap = min(degrees[ap] for ap in unvisited_aps)\n            candidate_nodes = [ap for ap in unvisited_aps if degrees[ap] == min_deg_ap]\n        else:\n            min_deg = min(degrees[i] for i in unvisited_nodes)\n            candidate_nodes = [i for i in unvisited_nodes if degrees[i] == min_deg]\n            \n        return min(candidate_nodes)\n\n    def get_rcm_permutation(adj):\n        \"\"\"\n        Computes the Reverse Cuthill-McKee permutation for a given graph.\n        \"\"\"\n        n = len(adj)\n        if n == 0:\n            return []\n        degrees = [len(a) for a in adj]\n        aps = _find_articulation_points(n, adj)\n        \n        cm_order = []\n        visited = [False] * n\n        \n        while len(cm_order)  n:\n            root = select_root(degrees, aps, visited)\n            \n            # BFS starting from the selected root\n            component_order = []\n            q = [root]\n            visited[root] = True\n            \n            head = 0\n            while head  len(q):\n                u = q[head]\n                component_order.append(u)\n                \n                # Sort neighbors by non-decreasing degree, breaking ties with smaller index\n                neighbors = sorted(adj[u], key=lambda v: (degrees[v], v))\n                \n                for v in neighbors:\n                    if not visited[v]:\n                        visited[v] = True\n                        q.append(v)\n                head += 1\n            \n            cm_order.extend(component_order)\n\n        return cm_order[::-1]\n\n    def compute_bandwidth(adj, p):\n        \"\"\"\n        Computes the bandwidth of a matrix permuted by permutation p.\n        \"\"\"\n        n = len(p)\n        if n == 0:\n            return 0\n        p_inv = [0] * n\n        for i, original_index in enumerate(p):\n            p_inv[original_index] = i\n            \n        max_diff = 0\n        for u in range(n):\n            for v in adj[u]:\n                if u  v: # Process each edge once\n                    diff = abs(p_inv[u] - p_inv[v])\n                    if diff > max_diff:\n                        max_diff = diff\n        return max_diff\n\n    def build_graph_from_coords(coords):\n        \"\"\"\n        Builds a graph based on 4-neighbor adjacency (Manhattan distance = 1).\n        \"\"\"\n        n = len(coords)\n        adj = [[] for _ in range(n)]\n        coords_np = [np.array(c) for c in coords]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if np.linalg.norm(coords_np[i] - coords_np[j], ord=1) == 1.0:\n                    adj[i].append(j)\n                    adj[j].append(i)\n        return adj\n\n    # Define the test cases from the problem statement.\n    W, H = 4, 4\n    grid_coords = [(x, y) for y in range(H) for x in range(W)] # The problem statement implies column-major, but let's recheck.\n    # The problem says \"x non-decreasing then y non-decreasing\". This is typically row-major if x is the row index.\n    # Let's assume standard matrix indexing where (x,y) -> (row, col)\n    # The geometric order is lexicographic. Let's use (x,y) with x being \"row\" and y being \"col\".\n    # This means order is (0,0), (0,1), (0,2), (0,3), (1,0), ... This matches the grid test case logic.\n    grid_coords_lex = [(x, y) for x in range(W) for y in range(H)]\n    \n    dumbbell_coords = [(0,0), (0,1), (0,2), (1,1), (2,0), (2,1), (2,2)]\n    \n    chain_coords = [(x, 0) for x in range(5)]\n    \n    test_cases = [\n        {\n            \"name\": \"grid\",\n            \"coords\": grid_coords_lex,\n            \"p_geo\": list(range(len(grid_coords_lex))) # Already in lexicographic order\n        },\n        {\n            \"name\": \"dumbbell\",\n            \"coords\": dumbbell_coords,\n            \"p_geo\": list(range(len(dumbbell_coords))) # Already in specified order\n        },\n        {\n            \"name\": \"chain\",\n            \"coords\": chain_coords,\n            \"p_geo\": list(range(len(chain_coords))) # Already in specified order\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Create a mapping from coordinate to original index (0 to n-1)\n        coord_to_idx = {coord: i for i, coord in enumerate(case[\"coords\"])}\n        idx_to_coord = {i: coord for i, coord in enumerate(case[\"coords\"])}\n        \n        # Build adjacency list using original indices\n        adj = [[] for _ in range(len(case[\"coords\"]))]\n        coords_np = [np.array(c) for c in case[\"coords\"]]\n        for i in range(len(case[\"coords\"])):\n            for j in range(i + 1, len(case[\"coords\"])):\n                if np.linalg.norm(coords_np[i] - coords_np[j], ord=1) == 1.0:\n                    adj[i].append(j)\n                    adj[j].append(i)\n\n        # Geometric ordering is based on the given coordinate order, which we encoded as index 0..n-1\n        p_geo = list(range(len(case[\"coords\"])))\n        b_geo = compute_bandwidth(adj, p_geo)\n        \n        # RCM ordering\n        p_rcm = get_rcm_permutation(adj)\n        b_rcm = compute_bandwidth(adj, p_rcm)\n        \n        delta_b = b_rcm - b_geo\n        results.append(delta_b)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3365697"}]}