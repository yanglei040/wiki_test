{"hands_on_practices": [{"introduction": "预处理技术的核心思想是用一个“近似”且易于求解的算子来转化原问题。不完全 Cholesky 分解（IC(0)）是针对对称正定（SPD）矩阵最经典和基础的预处理方法之一。通过这个实践 [@problem_id:3434371]，你将亲手为离散拉普拉斯算子这一典型 SPD 矩阵构建 IC(0) 预处理器，并计算预处理后迭代矩阵的谱半径，从而直观地理解预处理是如何通过改善系统的谱特性来加速收敛的。", "problem": "构建一个程序，该程序针对由离散拉普拉斯算子产生的对称正定（SPD）稀疏矩阵，构建零填充不完全 Cholesky 分解（记为 IC(0)），并用其计算预处理误差传播算子的谱半径。推导和算法必须基于基本定义和经过充分检验的事实：\n\n- 从二维 $N \\times N$ 内部网格上带均匀狄利克雷边界条件的五点离散拉普拉斯算子的定义开始。每个内部节点的标准未缩放五点模板产生一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$（其中 $n = N^2$），该矩阵是 SPD 矩阵。其中每个内部行对应的对角线元素为 $4$，以及最多四个对应于最近邻居的非对角线元素为 $-1$。\n- 使用 SPD 矩阵的 Cholesky 分解定义：对于 SPD 矩阵 $A$，存在唯一的具有正对角元的下三角矩阵 $L$，使得 $A = LL^\\top$。不完全 Cholesky 分解 IC(0) 是一种强制 $L$ 的稀疏模式与 $A$ 的严格下三角部分（加上对角线）相匹配的分解，并丢弃超出该模式的填充（fill-in）。\n- 定义从 IC(0) 获得的左预处理器 $M = LL^\\top$。预处理算子为 $M^{-1}A$，相应的线性定常误差传播算子为 $E = I - M^{-1}A$，其中 $I$ 是单位矩阵。谱半径为 $\\rho(E) = \\max_i |\\lambda_i(E)|$，其中 $\\lambda_i(E)$ 是 $E$ 的特征值。\n\n你的程序必须：\n\n1. 使用标准未缩放模板，为二维 $N \\times N$ 内部网格上的带均匀狄利克雷边界条件的五点拉普拉斯算子构建矩阵 $A$。除非指定了置换，否则对网格节点使用字典序。\n2. 构建 IC(0) 预处理器 $M = LL^\\top$，其中 $L$ 的稀疏模式是 $A$ 的下三角部分（包括对角线）。你必须通过强制零填充约束来计算 $L$：仅当 $A_{ij} \\neq 0$ 时才计算每个元素 $L_{ij}$（对于 $i > j$），并且求和仅使用与此稀疏模式一致的索引。\n3. 通过使用 $L$ 和 $L^\\top$ 进行前向和后向三角求解，将 $M^{-1}$ 应用于 $A$ 的每一列，从而计算 $\\rho(I - M^{-1}A)$。\n4. 可选地，在计算 IC(0) 之前，对 $A$ 应用 Reverse Cuthill–McKee (RCM) 置换（用向量 $p$ 表示置换，用 $P$ 表示置换矩阵），形式为 $A_p = P^\\top A P$。当应用置换时，所有计算，包括 IC(0) 和谱半径，都必须在置换后的系统 $A_p$ 上执行。\n\n不涉及物理单位或角度。所有数值答案必须以浮点值形式返回。程序的最终输出必须是单行文本，包含一个 Python 列表，其中按下方测试套件的顺序列出浮点谱半径，每个值四舍五入到小数点后八位。\n\n测试套件：\n- 情况 1：$N = 5$，无重排。\n- 情况 2：$N = 3$，无重排。\n- 情况 3：$N = 5$，在构建 IC(0) 之前对 $A$ 应用 Reverse Cuthill–McKee 重排。\n- 情况 4：$N = 1$，无重排。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。例如，如果有两个结果 $r_1$ 和 $r_2$，程序将精确打印“[r_1,r_2]”。对于本问题，请打印“[r_1,r_2,r_3,r_4]”，其中 $r_k$ 是情况 $k$ 的谱半径，每个值格式化为小数点后八位数字。", "solution": "本问题要求为表示二维离散拉普拉斯算子的矩阵构建并分析零填充不完全 Cholesky 分解（记为 IC(0)）。目标是针对几种网格配置，计算与 IC(0) 预处理器相关的误差传播算子的谱半径。\n\n求解过程分为四个主要步骤：\n1.  构建离散拉普拉斯矩阵 $A$。\n2.  使用 Reverse Cuthill–McKee (RCM) 算法对 $A$ 进行可选的重排。\n3.  计算 IC(0) 因子 $L$。\n4.  计算迭代矩阵 $E = I - M^{-1}A$ 的谱半径，其中 $M = LL^\\top$。\n\n### 1. 矩阵构建\n问题设置在一个 $N \\times N$ 的内部节点网格上。我们使用从零开始的字典序，其中网格坐标 $(i, j)$（$0 \\le i, j  N$）处的节点被映射到单个索引 $k = iN + j$。这会产生一个大小为 $n \\times n$ 的方阵 $A$，其中 $n = N^2$。\n\n矩阵 $A$ 源自拉普拉斯算子 $-\\Delta u$ 的标准五点模板。在每个内部节点 $k$（对应网格点 $(i, j)$），离散方程为：\n$$4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} = f_{i,j}$$\n均匀狄利克雷边界条件意味着边界上任何点 $(x,y)$ 处的项 $u_{x,y}$ 均为零。这种结构转化为矩阵 $A$：\n-   对角线元素为 $A_{kk} = 4$。\n-   如果节点 $l$ 是网格上节点 $k$ 的直接北、南、东或西邻居，则非对角线元素 $A_{kl}$ 为 $-1$。否则，对于 $k \\neq l$，$A_{kl} = 0$。\n\n最终得到的矩阵 $A$ 是稀疏、对称且正定的（SPD）。它具有块三对角结构。\n\n### 2. Reverse Cuthill–McKee (RCM) 重排\n对于某些测试用例，矩阵 $A$ 会被重排以减小其带宽和轮廓。Reverse Cuthill–McKee 算法找到一个置换向量 $p$，当应用于矩阵时，该置换倾向于将非零元素集中在对角线附近。置换后的矩阵由 $A_p = P^\\top A P$ 给出，其中 $P$ 是对应于 $p$ 的置换矩阵。所有后续计算，包括 IC(0) 和谱半径计算，都在置换后的矩阵 $A_p$ 上执行。\n\n### 3. 不完全 Cholesky 分解 (IC(0))\n对于任何 SPD 矩阵 $A$，标准的 Cholesky 分解会找到一个唯一的具有正对角线元素的下三角矩阵 $L$，使得 $A = LL^\\top$。$L$ 的元素通过以下递推关系计算：\n$$ L_{jj} = \\sqrt{A_{jj} - \\sum_{k=0}^{j-1} L_{jk}^2} $$\n$$ L_{ij} = \\frac{1}{L_{jj}} \\left( A_{ij} - \\sum_{k=0}^{j-1} L_{ik}L_{jk} \\right) \\quad \\text{for } i > j $$\n这个过程通常会引入“填充”（fill-in），即即使 $A_{ij}$ 为零，$L_{ij}$ 也可能非零。\n\nIC(0) 分解通过强制施加稀疏性约束来防止这种情况：$L$ 的稀疏模式必须是 $A$ 的稀疏模式的子集。具体来说，我们计算一个近似因子 $\\tilde{L}$，使得当 $i > j$ 且 $A_{ij} = 0$ 时，$\\tilde{L}_{ij} = 0$。算法修改如下：\n令 $S = \\{(i,j) \\mid i>j, A_{ij} \\neq 0\\}$ 为对应于 $A$ 的严格下三角非零元素的索引对集合。\n$$ \\tilde{L}_{jj} = \\sqrt{A_{jj} - \\sum_{k=0, (j,k) \\in S}^{j-1} \\tilde{L}_{jk}^2} $$\n$$ \\tilde{L}_{ij} = \\frac{1}{\\tilde{L}_{jj}} \\left( A_{ij} - \\sum_{k=0, (i,k) \\in S, (j,k) \\in S}^{j-1} \\tilde{L}_{ik}\\tilde{L}_{jk} \\right) \\quad \\text{for } (i,j) \\in S $$\n此过程通过迭代矩阵的行和列并仅对存在于 $A$ 稀疏模式中的索引应用这些公式来实现。对于一个 SPD 矩阵 $A$，通过此算法进行的 IC(0) 分解保证存在，并能生成一个具有正对角线元素的下三角矩阵 $\\tilde{L}$。下文中，我们将 $\\tilde{L}$ 记为 $L$。\n\n### 4. 谱半径计算\nIC(0) 分解提供了一个预处理器 $M = LL^\\top$。我们关心的是定常迭代矩阵 $E = I - M^{-1}A$ 的谱特性。谱半径 $\\rho(E)$ 控制着预处理理查森迭代（Richardson iteration）的收敛速度。\n$$ \\rho(E) = \\max_i |\\lambda_i(E)| $$\n其中 $\\lambda_i(E)$ 是 $E$ 的特征值。\n\n为了计算 $\\rho(E)$，我们首先构造稠密矩阵 $E$，然后求其特征值。$E$ 的第 $j$ 列，记为 $e_j - (M^{-1}A)_j$，是通过首先计算向量 $y_j = M^{-1}a_j$ 来得到的，其中 $a_j$ 是 $A$ 的第 $j$ 列。$y_j$ 的计算通过求解系统 $My_j = a_j$（即 $LL^\\top y_j = a_j$）来完成。这可以通过前向和后向替换高效完成，而无需对 $L$ 求逆：\n1.  **前向求解：** 求解 $Lz_j = a_j$ 得到 $z_j$。\n2.  **后向求解：** 求解 $L^\\top y_j = z_j$ 得到 $y_j$。\n\n对每一列 $j = 0, \\dots, n-1$ 重复此过程，以构造矩阵 $M^{-1}A$ 的所有列。然后形成矩阵 $E$，并使用标准的数值库例程计算其特征值。谱半径是这些特征值绝对值的最大值。\n\n特殊情况：对于 $N=1$，网格只有一个内部点。矩阵 $A$ 是 $1 \\times 1$ 矩阵 $[4]$。IC(0) 因子是 $L = [\\sqrt{4}] = [2]$。预处理器是 $M=LL^\\top = [4]$。因此，$M=A$，误差传播矩阵为 $E = I - M^{-1}A = I - A^{-1}A = I - I = [0]$。其唯一的特征值是 $0$，所以谱半径为 $\\rho(E) = 0$。", "answer": "```python\nimport numpy as np\nimport scipy.sparse\nfrom scipy.sparse.csgraph import reverse_cuthill_mckee\nfrom scipy.sparse.linalg import spsolve_triangular\n\ndef construct_laplacian(N):\n    \"\"\"\n    Constructs the 2D discrete Laplacian matrix A for an N x N grid.\n    Uses a 5-point stencil with homogeneous Dirichlet boundary conditions.\n    \"\"\"\n    if N == 0:\n        return scipy.sparse.csr_matrix((0, 0))\n    n = N * N\n    \n    # Use DOK format for easy construction of the sparse matrix\n    A = scipy.sparse.dok_matrix((n, n), dtype=np.float64)\n\n    for i in range(N):\n        for j in range(N):\n            k = i * N + j\n            A[k, k] = 4.0\n            # West neighbor\n            if j > 0:\n                A[k, k - 1] = -1.0\n            # East neighbor\n            if j  N - 1:\n                A[k, k + 1] = -1.0\n            # North neighbor\n            if i > 0:\n                A[k, k - N] = -1.0\n            # South neighbor\n            if i  N - 1:\n                A[k, k + N] = -1.0\n                \n    return A.tocsr()\n\ndef ic0(A_csr):\n    \"\"\"\n    Computes the Incomplete Cholesky factorization with zero fill-in (IC(0)).\n    Input A must be a symmetric positive definite sparse matrix in CSR format.\n    Returns the lower triangular factor L in CSR format.\n    \"\"\"\n    n = A_csr.shape[0]\n    # LIL format is efficient for incremental construction\n    L = scipy.sparse.lil_matrix((n, n), dtype=np.float64)\n    A_dok = A_csr.todok()\n\n    for i in range(n):\n        # Compute off-diagonal entries L[i,j] for j  i\n        # The sparsity pattern of L is the same as the lower triangle of A\n        # We can iterate through relevant column indices from A\n        row_indices = sorted([c for r, c in A_dok.keys() if r == i and c  i])\n\n        for j in row_indices:\n            s = 0.0\n            # Sum over common predecessors: sum(L[i,k] * L[j,k] for k  j)\n            # L.rows[i] gives a list of column indices of non-zero elements in row i\n            L_i_cols = L.rows[i]\n            L_j_cols = L.rows[j]\n            \n            # This can be slow, but is fine for the small matrices in this problem\n            common_cols = set(L_i_cols).intersection(L_j_cols)\n            for k in common_cols:\n                if k  j:\n                    s += L[i,k] * L[j,k]\n            \n            L[i,j] = (A_dok[i,j] - s) / L[j,j]\n\n        # Compute diagonal entry L[i,i]\n        s_diag = 0.0\n        # Sum squares of L[i,j] for j  i which are now computed\n        for j in L.rows[i]:\n             if j  i:\n                s_diag += L[i,j]**2\n\n        diag_val = A_dok[i,i] - s_diag\n        if diag_val = 0:\n            raise ValueError(f\"Matrix is not positive-definite enough for IC(0) at index {i}.\")\n        L[i,i] = np.sqrt(diag_val)\n\n    return L.tocsr()\n\ndef calculate_spectral_radius(A, L):\n    \"\"\"\n    Calculates the spectral radius of the error propagation matrix E = I - (LL^T)^-1 * A.\n    \"\"\"\n    n = A.shape[0]\n    if n == 0:\n        return 0.0\n\n    # The case N=1 is trivial and could be handled separately, but the general\n    # code works as well. A=[[4]], L=[[2]], M=A, M_inv_A=I, E=0, rho=0.\n    \n    L_T = L.transpose().tocsr()\n    \n    # Build the matrix E = I - M_inv_A\n    M_inv_A = np.zeros((n, n), dtype=np.float64)\n    \n    for j in range(n):\n        a_j = A[:, j].toarray()\n        \n        # Solve M * y_j = a_j => LL^T * y_j = a_j\n        # 1. Forward solve: L * z_j = a_j\n        z_j = spsolve_triangular(L, a_j, lower=True)\n        # 2. Backward solve: L^T * y_j = z_j\n        y_j = spsolve_triangular(L_T, z_j, lower=False) # upper triangular system\n        \n        M_inv_A[:, j] = y_j.flatten()\n\n    E = np.identity(n) - M_inv_A\n    eigenvalues = np.linalg.eigvals(E)\n    spectral_radius = np.max(np.abs(eigenvalues))\n    \n    return spectral_radius\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (5, False),  # Case 1\n        (3, False),  # Case 2\n        (5, True),   # Case 3\n        (1, False),  # Case 4\n    ]\n\n    results = []\n    for N, use_rcm in test_cases:\n        A = construct_laplacian(N)\n        \n        # Apply RCM permutation if specified\n        if use_rcm:\n            # RCM for a 1x1 matrix is trivial, but scipy handles it\n            if A.shape[0] > 0:\n                perm = reverse_cuthill_mckee(A, symmetric_mode=False)\n                A = A[perm, :][:, perm]\n        \n        L = ic0(A)\n        \n        rho = calculate_spectral_radius(A, L)\n        \n        results.append(f\"{rho:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3434371"}, {"introduction": "许多重要的科学与工程问题，如流体力学中的斯托克斯（Stokes）方程，会产生具有鞍点结构的线性系统。这类系统通常是“不定”的，无法直接使用为对称正定问题设计的预处理器。这个练习 [@problem_id:3434325] 将指导你为离散斯托克斯方程构建一个分块三角预处理器，这是一种针对鞍点问题的高效策略。你将探索如何通过近似系统中的关键物理模块——速度矩阵 $K$ 和压力舒尔补 $S$——来构造一个有效的预处理器，并分析其对系统特征值分布的影响。", "problem": "考虑在单位正方形上使用 Marker-And-Cell (MAC) 网格离散的稳态二维不可压缩 Stokes 方程，其中速度采用齐次 Dirichlet 边界条件，压力为零均值。设得到的离散线性代数系统为鞍点矩阵 $$A = \\begin{pmatrix} K  B^{\\top} \\\\ B  0 \\end{pmatrix},$$ 其中 $K \\in \\mathbb{R}^{n_u \\times n_u}$ 是速度的对称正定离散向量拉普拉斯算子，$B \\in \\mathbb{R}^{n_p \\times n_u}$ 是将速度自由度映射到压力自由度的离散散度算子，而 $0$ 块对应于不可压缩性约束。压力块的 Schur 补为 $$S = B K^{-1} B^{\\top}.$$\n\n块三角预条件子定义为 $$M = \\begin{pmatrix} \\hat{K}  0 \\\\ B  -\\hat{S} \\end{pmatrix},$$ 其中 $\\hat{K}$ 和 $\\hat{S}$ 分别是 $K$ 和 $S$ 的计算成本更低的近似。预处理后的矩阵则为 $$M^{-1} A.$$\n\n您的任务是实现一个独立的程序，该程序：\n- 为给定数量的压力单元 $N_x \\times N_y$，构建离散 MAC 网格 Stokes 矩阵 $K$ 和 $B$，其中网格间距均匀，为 $h_x = 1/N_x$ 和 $h_y = 1/N_y$，粘度 $\\mu  0$，速度采用齐次 Dirichlet 边界条件，并通过移除一个压力自由度来强制实现零均值压力。\n- 使用对 $K$ 的直接求解来形成精确的 Schur 补 $S = B K^{-1} B^{\\top}$。\n- 使用指定的 $\\hat{K}$ 和 $\\hat{S}$ 选项构建块三角预条件子 $M$，可比较的选项有：\n  - 对 $\\hat{K}$：使用精确的 $K$ 或 Jacobi 近似 $\\operatorname{diag}(K)$。\n  - 对 $\\hat{S}$：使用精确的 $S$、其对角线 $\\operatorname{diag}(S)$，或各向同性缩放 $\\alpha I$，其中 $\\alpha = \\frac{1}{n_p} \\sum_{i=1}^{n_p} S_{ii}$。\n- 通过将 $M^{-1}$ 应用于 $A$ 的列，或使用关于 $K$, $B$, $\\hat{K}^{-1}$ 和 $\\hat{S}^{-1}$ 的块代数，来形成 $M^{-1} A$ 的稠密矩阵表示。\n- 计算 $M^{-1} A$ 的全谱（所有特征值），并为每个测试用例报告两个量：\n  1. 特征值与 $1$ 的最大绝对偏差，定义为 $\\max_i \\lvert \\lambda_i - 1 \\rvert$，其中 $\\{\\lambda_i\\}$ 是 $M^{-1} A$ 的特征值。\n  2. 一个布尔值，指示所有特征值是否满足 $\\lvert \\lambda_i - 1 \\rvert \\leq 10^{-8}$。\n\n从基本原理开始：定义 MAC 网格未知数、具有齐次 Dirichlet 边界条件的离散向量拉普拉斯算子以及离散散度。解释 Schur 补是如何从块消元中产生的，以及为什么块三角预条件子是一个自然的选择。当使用精确的 Schur 补和精确的速度块时，推导 $M^{-1} A$ 的结构，并用此来推断在使用近似选项时谱在 $1$ 附近的预期聚类情况。\n\n需遵循的实现细节：\n- 设压力自由度为 $N_x N_y$ 个单元中心，其中一个自由度被移除以强制零均值压力。\n- 设水平速度自由度为内部垂直面（索引 $i=1,\\dots,N_x-1$, $j=1,\\dots,N_y$），垂直速度自由度为内部水平面（索引 $i=1,\\dots,N_x$, $j=1,\\dots,N_y-1$）。离散向量拉普拉斯算子 $K$ 在这两个速度网格上是块对角的，带有五点模板，并按粘度 $\\mu$ 进行缩放。\n- 离散散度 $B$ 通过有限差分作用于速度：对于每个压力单元 $(i,j)$，$$\\left(B \\begin{bmatrix} \\mathbf{u} \\\\ \\mathbf{v} \\end{bmatrix}\\right)_{ij} = \\frac{u_{i,j} - u_{i-1,j}}{h_x} + \\frac{v_{i,j} - v_{i,j-1}}{h_y},$$ 其中落在物理边界上的索引对应于零 Dirichlet 速度值，并从未知数中省略。\n\n测试套件和输出规范：\n- 使用以下五个测试用例，通过 $M^{-1} A$ 的谱来比较 $\\hat{K}$ 和 $\\hat{S}$ 的选择：\n  1. $N_x = 3$, $N_y = 3$, $\\mu = 1.0$, $\\hat{K} = K$, $\\hat{S} = S$.\n  2. $N_x = 3$, $N_y = 3$, $\\mu = 1.0$, $\\hat{K} = \\operatorname{diag}(K)$, $\\hat{S} = S$.\n  3. $N_x = 5$, $N_y = 4$, $\\mu = 1.0$, $\\hat{K} = K$, $\\hat{S} = \\operatorname{diag}(S)$.\n  4. $N_x = 5$, $N_y = 4$, $\\mu = 1.0$, $\\hat{K} = \\operatorname{diag}(K)$, $\\hat{S} = \\alpha I$，其中 $\\alpha$ 等于 $S$ 对角线元素的均值。\n  5. $N_x = 4$, $N_y = 4$, $\\mu = 0.1$, $\\hat{K} = K$, $\\hat{S} = \\operatorname{diag}(S)$.\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个 $[\\text{max\\_dev}, \\text{all\\_close}]$ 形式的列表。例如，输出应类似于 $[[0.0,\\text{True}],[0.1234,\\text{False}],\\dots]$。不需要物理单位，因为输出是无量纲的谱量。角度单位不适用。百分比不适用。", "solution": "该问题要求对离散不可压缩 Stokes 方程的块三角预条件子进行分析。我们首先验证问题陈述，然后进行详细的理论推导和实现策略。\n\n### 问题验证\n\n根据指定的验证标准对问题进行评估。\n\n**1. 提取的已知条件：**\n- **方程：** 单位正方形上的二维稳态不可压缩 Stokes 方程。\n- **离散化：** Marker-And-Cell (MAC) 网格，均匀间距为 $h_x = 1/N_x$ 和 $h_y = 1/N_y$。\n- **边界条件：** 速度的齐次 Dirichlet 边界条件。\n- **压力约束：** 零均值压力，通过移除一个压力自由度来强制实现。\n- **代数系统：** 鞍点矩阵 $A = \\begin{pmatrix} K  B^{\\top} \\\\ B  0 \\end{pmatrix}$，其中 $K$ 是对称正定离散向量拉普拉斯算子，$B$ 是离散散度算子。\n- **Schur 补：** $S = B K^{-1} B^{\\top}$。\n- **预条件子：** 块三角矩阵 $M = \\begin{pmatrix} \\hat{K}  0 \\\\ B  -\\hat{S} \\end{pmatrix}$，其中 $\\hat{K}$ 和 $\\hat{S}$ 是对 $K$ 和 $S$ 的近似。\n- **未知数配置：**\n    - 压力 ($p$)：$N_x N_y$ 个单元中心，移除一个自由度（DOF）（$n_p = N_x N_y - 1$）。\n    - 水平速度 ($u$)：内部垂直面，$n_{u,x} = (N_x-1)N_y$ 个自由度。\n    - 垂直速度 ($v$)：内部水平面，$n_{u,y} = N_x(N_y-1)$ 个自由度。\n    - 总速度自由度：$n_u = n_{u,x} + n_{u,y}$。\n- **算子定义：**\n    - $K$：由 $u$ 和 $v$ 网格的五点模板组成的块对角矩阵，按粘度 $\\mu  0$ 缩放。\n    - $B$：由有限差分公式 $\\left(B [\\mathbf{u};\\mathbf{v}]\\right)_{ij} = \\frac{u_{i,j} - u_{i-1,j}}{h_x} + \\frac{v_{i,j} - v_{i,j-1}}{h_y}$ 定义。\n- **近似选项：**\n    - $\\hat{K}$：精确块 $K$ 或其对角线 $\\operatorname{diag}(K)$。\n    - $\\hat{S}$：精确 Schur 补 $S$、其对角线 $\\operatorname{diag}(S)$，或各向同性缩放 $\\alpha I$，其中 $\\alpha$ 是 $S$ 对角线元素的均值。\n- **任务：** 对于几个测试用例，构建矩阵，形成预处理矩阵 $M^{-1} A$，计算其谱 $\\{\\lambda_i\\}$，并报告 $\\max_i \\lvert \\lambda_i - 1 \\rvert$ 以及所有特征值是否满足 $\\lvert \\lambda_i - 1 \\rvert \\leq 10^{-8}$。\n\n**2. 验证结论：**\n- 该问题是**有科学依据的**，涉及数值分析和计算流体力学中标准且成熟的方法。\n- 它是**适定的**，为构建矩阵和执行分析提供了清晰完整的规范。测试用例的规模在计算上是可行的。通过移除一个自由度来强制零均值压力约束是确保压力相关算子可逆性的标准技术。\n- 它是**客观的**，用精确的数学和算法语言表述。\n- 其设置在内部是**一致且完整的**。提供了所有必要的参数和定义。\n\n问题被判定为**有效**。我们继续进行求解。\n\n### 基于原理的解决方案\n\n稳态不可压缩 Stokes 方程模拟缓慢的粘性流体流动，其形式如下：\n$$ -\\mu \\Delta \\mathbf{u} + \\nabla p = \\mathbf{f} $$\n$$ \\nabla \\cdot \\mathbf{u} = 0 $$\n其中 $\\mathbf{u}$ 是速度， $p$ 是压力，$\\mu$ 是动力粘度，$\\mathbf{f}$ 是体积力（此处假定为零）。\n\n**1. MAC 网格上的离散化**\n离散化使用交错网格（MAC 网格）。在单位正方形 $[0,1] \\times [0,1]$ 上的 $N_x \\times N_y$ 单元网格上：\n- 压力 $p_{i,j}$ 定义在单元中心 $( (i-1/2)h_x, (j-1/2)h_y )$，其中 $i=1,\\dots,N_x, j=1,\\dots,N_y$。\n- 水平速度 $u_{i,j}$ 定义在垂直面上 $( ih_x, (j-1/2)h_y )$，其中 $i=1,\\dots,N_x-1, j=1,\\dots,N_y$。\n- 垂直速度 $v_{i,j}$ 定义在水平面上 $( (i-1/2)h_x, jh_y )$，其中 $i=1,\\dots,N_x, j=1,\\dots,N_y-1$。\n\n施加齐次 Dirichlet 边界条件 $\\mathbf{u}|_{\\partial\\Omega} = \\mathbf{0}$。在*内部*面上选择自由度自然地在垂直边界上施加了 $u=0$，在水平边界上施加了 $v=0$。在水平边界上 $u=0$ 和在垂直边界上 $v=0$ 的条件被整合到离散算子中。\n\n得到的离散系统是一个鞍点线性系统 $A \\begin{pmatrix} \\mathbf{x_u} \\\\ \\mathbf{x_p} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{f_d} \\\\ \\mathbf{0} \\end{pmatrix}$，其中 $\\mathbf{x_u}$ 和 $\\mathbf{x_p}$ 分别是速度和压力自由度的向量。系统矩阵为 $A = \\begin{pmatrix} K  B^{\\top} \\\\ B  0 \\end{pmatrix}$。\n\n**2. 离散算子的构造**\n\n- **离散向量拉普拉斯算子 $K$**：矩阵 $K$ 代表负向量拉普拉斯算子 $-\\mu\\Delta$ 在速度向量上的作用。它是块对角的：$K = \\mu \\begin{pmatrix} K_u  0 \\\\ 0  K_v \\end{pmatrix}$。\n  - $K_u$ 是大小为 $(N_x-1) \\times N_y$ 的 $u$-速度网格的离散拉普拉斯算子。\n  - $K_v$ 是大小为 $N_x \\times (N_y-1)$ 的 $v$-速度网格的离散拉普拉斯算子。\n  在具有齐次 Dirichlet 边界条件的 $M \\times N$ 笛卡尔网格上，使用标准的中心差分五点模板来表示负拉普拉斯算子，离散算子可以通过克罗内克积构造：$L_{M \\times N} = I_N \\otimes \\frac{1}{h_x^2} L_M + \\frac{1}{h_y^2} L_N \\otimes I_M$，其中 $L_k$ 是 $k \\times k$ 的一维拉普拉斯矩阵 $[2, -1, \\dots, -1]$。\n  - $K_u = \\mu(I_{N_y} \\otimes \\frac{1}{h_x^2}L_{N_x-1} + \\frac{1}{h_y^2} L_{N_y} \\otimes I_{N_x-1})$\n  - $K_v = \\mu(\\frac{1}{h_x^2}L_{N_x} \\otimes I_{N_y-1} + I_{N_x} \\otimes \\frac{1}{h_y^2}L_{N_y-1})$\n  这种构造确保了 $K$ 是对称正定（SPD）的。\n\n- **离散散度算子 $B$**：矩阵 $B$ 代表散度算子，将速度向量映射到以单元为中心的压力网格。对应于压力单元 $(i,j)$ 的 $B$ 的一行由以下公式构造：\n  $$ (\\nabla \\cdot \\mathbf{u})_{i,j} \\approx \\frac{u_{i,j} - u_{i-1,j}}{h_x} + \\frac{v_{i,j} - v_{i,j-1}}{h_y} $$\n  索引落在物理边界 $\\partial\\Omega$ 上的速度项为零并被省略。\n  压力仅在相差一个常数的情况下是确定的，这表现为 $B^\\top$ 的一个零向量（常数向量）。为了获得唯一的压力解，需要一个约束，如零均值压力。这通过移除一个压力自由度（例如，最后一个）来实现，这对应于从 $B$ 中移除一行，从 $B^\\top$ 中移除一列。得到的 $B$ 有 $n_p = N_x N_y - 1$ 行。\n\n**3. 块预处理**\n\n由于其鞍点结构，直接求解带 $A$ 的系统具有挑战性。块消元产生了 Schur 补 $S = B K^{-1} B^\\top$，它是 SPD 且稠密的。求解该系统可以重构为：\n1. 求解 $S \\mathbf{x_p} = B K^{-1} \\mathbf{f_d}$。\n2. 求解 $K \\mathbf{x_u} = \\mathbf{f_d} - B^\\top \\mathbf{x_p}$。\n\n主要的计算成本在于处理 $K^{-1}$。预处理旨在用一个更廉价的操作来替代这个昂贵的操作。块三角预条件子 $M = \\begin{pmatrix} \\hat{K}  0 \\\\ B  -\\hat{S} \\end{pmatrix}$ 的动机来自于对 $A$ 的近似块-LU 分解：\n$$ A = \\begin{pmatrix} K  B^\\top \\\\ B  0 \\end{pmatrix} = \\begin{pmatrix} I  0 \\\\ B K^{-1}  I \\end{pmatrix} \\begin{pmatrix} K  B^\\top \\\\ 0  -S \\end{pmatrix} $$\n$M$ 通过用 $\\hat{K}$ 替换 $K$ 和用 $\\hat{S}$ 替换 $S$ 来近似这个分解。$M$ 的逆很容易计算：\n$$ M^{-1} = \\begin{pmatrix} \\hat{K}^{-1}  0 \\\\ \\hat{S}^{-1} B \\hat{K}^{-1}  -\\hat{S}^{-1} \\end{pmatrix} $$\n预处理后的矩阵是 $M^{-1} A$：\n$$ M^{-1}A = \\begin{pmatrix} \\hat{K}^{-1} K  \\hat{K}^{-1} B^\\top \\\\ \\hat{S}^{-1} B (\\hat{K}^{-1} K - I)  \\hat{S}^{-1} B \\hat{K}^{-1} B^\\top \\end{pmatrix} $$\n\n**4. 预处理矩阵的谱分析**\n\n预条件子的有效性由预处理矩阵 $M^{-1}A$ 的谱特性决定。一个理想的预条件子将导致 $M^{-1}A = I$，其特征值全部为 1。\n\n- **理想情况：** 如果我们选择 $\\hat{K} = K$ 和 $\\hat{S} = S = B K^{-1} B^\\top$，预处理后的矩阵简化为：\n$$ M^{-1}A = \\begin{pmatrix} I  K^{-1} B^\\top \\\\ S^{-1} B (I - I)  S^{-1} (B K^{-1} B^\\top) \\end{pmatrix} = \\begin{pmatrix} I  K^{-1} B^\\top \\\\ 0  I \\end{pmatrix} $$\n这是一个上三角矩阵，所有对角线元素都等于 1。因此，它的所有特征值都为 1。像 GMRES 这样的迭代求解器将在一次迭代中收敛（在精确算术下）。\n\n- **近似情况：** 当 $\\hat{K}$ 和 $\\hat{S}$ 是近似时，$M^{-1}A$ 的特征值将偏离 1。\n  - 如果 $\\hat{K} = K$ 但 $\\hat{S} \\approx S$（例如 $\\hat{S} = \\operatorname{diag}(S)$），矩阵变为 $\\begin{pmatrix} I  K^{-1} B^\\top \\\\ 0  \\hat{S}^{-1} S \\end{pmatrix}$。特征值为 1（来自速度块）和 $\\hat{S}^{-1}S$ 的特征值（来自压力块）。谱在 1 附近的聚集程度取决于 $\\hat{S}$ 对 $S$ 的近似程度。\n  - 如果 $\\hat{K} \\approx K$（例如 $\\hat{K} = \\operatorname{diag}(K)$），$(2,1)$ 块 $\\hat{S}^{-1} B (\\hat{K}^{-1} K - I)$ 将变为非零，特征值会更复杂。与 1 的偏差将取决于两种近似的误差，即 $\\hat{K}^{-1}K$ 和 $\\hat{S}^{-1}(B \\hat{K}^{-1} B^\\top)$ 与单位矩阵的接近程度。\n\n任务是计算给定测试用例的这些谱，并量化与理想值 1 的偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import block_diag\n\ndef laplacian_1d(n):\n    \"\"\"Constructs a 1D Laplacian matrix of size n x n with Dirichlet boundary conditions.\"\"\"\n    L = 2 * np.eye(n)\n    if n > 1:\n        L += -1 * np.eye(n, k=1)\n        L += -1 * np.eye(n, k=-1)\n    return L\n\ndef build_stokes_matrices(Nx, Ny, mu):\n    \"\"\"\n    Constructs the discrete Stokes matrices K and B for a given MAC grid.\n    \"\"\"\n    hx = 1.0 / Nx\n    hy = 1.0 / Ny\n\n    # --- Velocity DOFs ---\n    n_ux = (Nx - 1) * Ny\n    n_uy = Nx * (Ny - 1)\n    n_u = n_ux + n_uy\n\n    # --- Construct K matrix (discrete vector Laplacian) ---\n    # K_u for horizontal velocities\n    Lx_u = laplacian_1d(Nx - 1) / (hx * hx)\n    Ly_u = laplacian_1d(Ny) / (hy * hy)\n    Ku = mu * (np.kron(np.eye(Ny), Lx_u) + np.kron(Ly_u, np.eye(Nx - 1)))\n    \n    # K_v for vertical velocities\n    Lx_v = laplacian_1d(Nx) / (hx * hx)\n    Ly_v = laplacian_1d(Ny - 1) / (hy * hy)\n    Kv = mu * (np.kron(np.eye(Ny - 1), Lx_v) + np.kron(Ly_v, np.eye(Nx)))\n\n    K = block_diag(Ku, Kv)\n\n    # --- Construct B matrix (discrete divergence) ---\n    n_p_full = Nx * Ny\n    B_full = np.zeros((n_p_full, n_u))\n\n    # Mapping from 2D grid indices to 1D vector indices\n    u_idx = lambda i, j: (j - 1) * (Nx - 1) + (i - 1)\n    v_idx = lambda i, j: (j - 1) * Nx + (i - 1)\n    \n    for j_p in range(1, Ny + 1):\n        for i_p in range(1, Nx + 1):\n            p_row_idx = (j_p - 1) * Nx + (i_p - 1)\n\n            # Contribution from (u_{i,j} - u_{i-1,j}) / hx\n            if i_p = Nx - 1:  # u(i_p, j_p) is a DOF\n                col_idx = u_idx(i_p, j_p)\n                B_full[p_row_idx, col_idx] = 1.0 / hx\n            if i_p >= 2:  # u(i_p-1, j_p) is a DOF\n                col_idx = u_idx(i_p - 1, j_p)\n                B_full[p_row_idx, col_idx] = -1.0 / hx\n\n            # Contribution from (v_{i,j} - v_{i,j-1}) / hy\n            v_col_offset = n_ux\n            if j_p = Ny - 1:  # v(i_p, j_p) is a DOF\n                col_idx = v_col_offset + v_idx(i_p, j_p)\n                B_full[p_row_idx, col_idx] = 1.0 / hy\n            if j_p >= 2:  # v(i_p, j_p-1) is a DOF\n                col_idx = v_col_offset + v_idx(i_p, j_p - 1)\n                B_full[p_row_idx, col_idx] = -1.0 / hy\n    \n    # Enforce mean-zero pressure by removing one pressure DOF\n    B = B_full[:-1, :]\n    n_p = n_p_full - 1\n    \n    return K, B, n_u, n_p\n\ndef run_case(Nx, Ny, mu, Khat_choice, Shat_choice):\n    \"\"\"\n    Runs a single test case for the block preconditioner analysis.\n    \"\"\"\n    # 1. Build discrete operators\n    K, B, n_u, n_p = build_stokes_matrices(Nx, Ny, mu)\n    \n    # 2. Form the full saddle-point matrix A\n    A = np.block([\n        [K, B.T],\n        [B, np.zeros((n_p, n_p))]\n    ])\n\n    # 3. Form exact Schur complement S\n    K_inv = np.linalg.inv(K)\n    S = B @ K_inv @ B.T\n    \n    # 4. Construct approximation Khat\n    if Khat_choice == 'exact':\n        Khat = K\n    elif Khat_choice == 'diag':\n        Khat = np.diag(np.diag(K))\n    else:\n        raise ValueError(f\"Unknown Khat_choice: {Khat_choice}\")\n\n    # 5. Construct approximation Shat\n    if Shat_choice == 'exact':\n        Shat = S\n    elif Shat_choice == 'diag':\n        Shat = np.diag(np.diag(S))\n    elif Shat_choice == 'alpha_I':\n        # Need to handle case where S is 1x1 or empty\n        if S.shape[0] > 0:\n            alpha = np.mean(np.diag(S))\n        else:\n            alpha = 1.0\n        Shat = alpha * np.eye(n_p)\n    else:\n        raise ValueError(f\"Unknown Shat_choice: {Shat_choice}\")\n\n    # 6. Construct inverse of preconditioner M\n    Khat_inv = np.linalg.inv(Khat)\n    Shat_inv = np.linalg.inv(Shat) if n_p > 0 else np.array([[]])\n    \n    M_inv_top = np.hstack([Khat_inv, np.zeros((n_u, n_p))])\n    if n_p > 0:\n        M_inv_bot = np.hstack([Shat_inv @ B @ Khat_inv, -Shat_inv])\n        M_inv = np.vstack([M_inv_top, M_inv_bot])\n    else:\n        M_inv = M_inv_top\n\n    # 7. Form preconditioned matrix and find eigenvalues\n    preconditioned_A = M_inv @ A\n    eigvals = np.linalg.eigvals(preconditioned_A)\n    \n    # 8. Compute metrics\n    max_dev = np.max(np.abs(eigvals - 1.0))\n    all_close = bool(max_dev = 1e-8)\n    \n    return [max_dev, all_close]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        (3, 3, 1.0, 'exact', 'exact'),\n        (3, 3, 1.0, 'diag', 'exact'),\n        (5, 4, 1.0, 'exact', 'diag'),\n        (5, 4, 1.0, 'diag', 'alpha_I'),\n        (4, 4, 0.1, 'exact', 'diag'),\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        Nx, Ny, mu, Khat_choice, Shat_choice = case\n        result = run_case(Nx, Ny, mu, Khat_choice, Shat_choice)\n        # Python's bool __str__ method correctly produces 'True' or 'False'\n        results.append(f\"[{result[0]:.8e},{str(result[1])}]\")\n\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nsolve()\n\n```", "id": "3434325"}, {"introduction": "在求解大规模偏微分方程时，区域分解法是实现并行计算和算法可扩展性的关键。两层加性 Schwarz 方法是一种经典的区域分解预处理器，其性能在很大程度上取决于“粗空间”的设计。这个实践 [@problem_id:3434344] 让你通过数值实验来比较两种不同的粗空间设计对预处理共轭梯度法（PCG）收敛性的影响。通过观察当子区域尺寸（$H/h$）增长时迭代次数的变化，你将深入理解一个设计良好的粗空间校正对于确保预处理器可扩展性的至关重要的作用。", "problem": "考虑单位正方形 $\\Omega = (0,1)\\times(0,1)$ 上的标量泊松问题 $-\\Delta u = f$，其齐次狄利克雷边界条件为 $u=0$ on $\\partial\\Omega$。使用一个在 $x$ 方向有 $N_x$ 个点、在 $y$ 方向有 $N_y$ 个点的均匀笛卡尔内部网格对 $\\Omega$ 进行离散化，并用标准的五点有限差分格式来近似 $-\\Delta$。这将产生一个维度为 $N = N_x N_y$ 的对称正定线性系统 $A u = b$，其中 $A \\in \\mathbb{R}^{N \\times N}$ 且 $b \\in \\mathbb{R}^{N}$。\n\n将区域划分为 $n_x \\times n_y$ 个矩形子域，每个子域在每个空间方向上包含 $m$ 个细网格点，因此 $N_x = n_x m$ 且 $N_y = n_y m$。定义一个以细网格层为单位的固定重叠量 $\\delta$，并为每个子域构建其重叠索引集，方法是将其内部向所有方向延伸 $\\delta$ 个网格点（限制在全局内部索引范围内）。对于每个重叠子域索引集 $S_i$，将局部子域矩阵 $A_i$ 定义为通过限制于 $S_i$ 中的索引而从 $A$ 获得的主子矩阵。考虑对称的两级加性 Schwarz 预条件子\n$$\nM^{-1} = R_0^\\top A_0^{-1} R_0 + \\sum_{i=1}^{N_s} R_i^\\top A_i^{-1} R_i,\n$$\n其中 $N_s = n_x n_y$，$R_i$ 是从全局向量空间到局部子域索引集 $S_i$ 的限制（注入）算子，$A_0$ 是一个粗糙算子，由伽辽金投影 $A_0 = R_0 A R_0^\\top$ 定义到一个下面指定的精心选择的粗糙空间上。\n\n您将比较两种模拟自 Balancing Neumann–Neumann 和 Finite Element Tearing and Interconnecting—Dual-Primal (FETI–DP) 的粗糙约束的粗糙空间设计，比较的标准是当重叠量固定时，预条件共轭梯度 (PCG) 的迭代次数如何随网格比 $H/h$ 变化：\n- 仅角点约束：粗糙空间由对应于子域划分交叉点（角点）的基函数张成。交叉点集由笛卡尔网格线定义，其在 $x$ 方向上的索引为 $k m$（其中 $k \\in \\{0,1,\\dots,n_x\\}$），在 $y$ 方向上的索引为 $\\ell m$（其中 $\\ell \\in \\{0,1,\\dots,n_y\\}$），并被限制在有效的内部索引范围 $\\{0,1,\\dots,N_x-1\\}$ 和 $\\{0,1,\\dots,N_y-1\\}$ 内。每个粗糙基函数是在全局索引中对应角点节点的单位向量。\n- 角点加边约束：粗糙空间包括上述的角点，并且额外为每个划分界面线增加一个边平均约束。对于每个在 $x$ 索引为 $k m$（其中 $k \\in \\{1,2,\\dots,n_x-1\\}$）的垂直界面线，包含一个粗糙基函数，该函数在整列内部节点上为常数，其权重被归一化为单位欧几里得范数。对于每个在 $y$ 索引为 $\\ell m$（其中 $\\ell \\in \\{1,2,\\dots,n_y-1\\}$）的水平界面线，包含一个粗糙基函数，该函数在整行内部节点上为常数，其权重被归一化为单位欧几里得范数。这些额外的边平均粗糙基函数模拟了对偶-原始边约束。\n\nPCG 方法必须应用于 $A u = b$，使用预条件子 $M^{-1}$，初始猜测为 $u_0 = 0$，右端项 $b$ 定义为全一向量，停止准则为 $\\lVert r_k \\rVert_2 \\leq 10^{-8} \\lVert b \\rVert_2$，其中 $r_k$ 是 $k$ 次迭代后的残差。求解器必须使用与 $A$ 的精确矩阵向量乘积，以及所定义的预条件子 $M^{-1}$ 的精确应用。\n\n将网格比 $H/h$ 定义为子域的粗细网格比 $H/h = m$。固定重叠量 $\\delta = 1$。对于一个固定的划分为 $n_x = 2$ 和 $n_y = 2$，跟踪当 $H/h$ 增长时，每种粗糙空间选择的 PCG 迭代次数如何变化。使用以下指定 $(m, n_x, n_y, \\delta)$ 的测试套件：\n- 测试用例 1：$(m, n_x, n_y, \\delta) = (4, 2, 2, 1)$。\n- 测试用例 2：$(m, n_x, n_y, \\delta) = (8, 2, 2, 1)$。\n- 测试用例 3：$(m, n_x, n_y, \\delta) = (16, 2, 2, 1)$。\n- 测试用例 4：$(m, n_x, n_y, \\delta) = (24, 2, 2, 1)$。\n\n对于每个测试用例，运行 PCG 两次：一次使用仅角点粗糙空间，另一次使用角点加边粗糙空间。每次运行的可量化输出是整数形式的 PCG 迭代次数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。列表中的每个元素对应一个测试用例，并且本身是一个双元素列表，顺序为 $[\\text{iterations}_{\\text{corners}}, \\text{iterations}_{\\text{corners+edges}}]$。例如，一个包含四个测试用例的输出必须如下所示\n$[[i_1^{\\text{corners}}, i_1^{\\text{edges}}],[i_2^{\\text{corners}}, i_2^{\\text{edges}}],[i_3^{\\text{corners}}, i_3^{\\text{edges}}],[i_4^{\\text{corners}}, i_4^{\\text{edges}}]]$.\n该问题不涉及任何物理单位，如果存在任何角度，都将以弧度为单位进行测量，但这里没有出现角度。所有输出都必须是整数。", "solution": "用户要求进行一个数值实验，以比较两种不同粗糙空间在一个两级加性 Schwarz 预条件子上的性能。该问题针对单位正方形上的标量泊松方程提出，使用五点有限差分格式进行离散化。性能指标是预条件共轭梯度 (PCG) 方法收敛所需的迭代次数。\n\n### 问题验证\n问题陈述根据指定标准进行验证。\n\n- **已知条件提取**：所有参数都已明确说明：偏微分方程 (PDE) ($-\\Delta u = f$)、域 ($\\Omega = (0,1)\\times(0,1)$)、边界条件 ($u=0$ on $\\partial\\Omega$)、离散化方法（均匀网格上的五点有限差分）、线性系统结构 ($Au=b$)、域分解参数 ($m, n_x, n_y, \\delta$)、加性 Schwarz 预条件子的数学定义 ($M^{-1} = R_0^\\top A_0^{-1} R_0 + \\sum_{i=1}^{N_s} R_i^\\top A_i^{-1} R_i$)、两种独立粗糙空间（'仅角点'和'角点加边'）的详细构造，以及 PCG 求解器的全套参数（初始猜测 $u_0=0$、右端项 $b=\\mathbf{1}$、停止准则 $\\lVert r_k \\rVert_2 \\leq 10^{-8} \\lVert b \\rVert_2$）。测试用例以元组列表 $(m, n_x, n_y, \\delta)$ 的形式指定。\n\n- **验证检查**：\n  - **科学基础**：该问题是数值分析领域的一个标准、成熟的基准问题，特别是在迭代求解器和域分解方法的研究中。所使用的所有概念都是该学科的基础。\n  - **适定性**：该问题是适定的。由带狄利克雷边界条件的负拉普拉斯算子的有限差分法离散化得到的系统矩阵 $A$ 是对称正定的 (SPD)。预条件子 $M^{-1}$ 的构造也使其成为对称正定。PCG 算法对于带有 SPD 预条件子的 SPD 系统保证收敛。达到给定容差所需的迭代次数是一个唯一定义的、确定性的量。\n  - **客观性**：问题以精确、客观的数学语言陈述。待计算的量（迭代次数）是明确且可测量的。\n  - 对于给定的参数，该问题是完整的、一致的并且计算上是可行的。不存在科学上不健全、模糊不清或依赖无法验证的说法等缺陷。\n\n- **结论**：该问题是**有效的**。\n\n### 算法解决方案设计\n\n该解决方案需要实现一个由两级加性 Schwarz 方法预条件的 PCG 求解器。关键步骤如下：\n\n1.  **系统矩阵构造**：矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 代表了在 $N_x \\times N_y$ 个内部点的均匀网格上的五点有限差分格式，其中 $N=N_x N_y$。采用字典序对网格点进行排序，矩阵 $A$ 具有块三对角结构。它可以通过两个一维拉普拉斯矩阵的克罗内克和 (`kronsum`) 来优雅地构造。设 $T_k$ 是一个 $k \\times k$ 的三对角矩阵，其对角线上为 $2$，次对角线上为 $-1$。则系统矩阵为 $A = \\text{kronsum}(T_{N_y}, T_{N_x})$。\n\n2.  **域分解**：将 $N_x \\times N_y$ 个点的全局域划分为 $n_x \\times n_y$ 个子域，每个子域的大小为 $m \\times m$ 个内部网格点，其中 $N_x = n_x m$ 且 $N_y = n_y m$。对于每个子域 $i$，通过将子域向各个方向延伸 $\\delta$ 个网格点来构建一个重叠索引集 $S_i$，并将其限制在全局内部网格的边界内。局部矩阵 $A_i$ 是矩阵 $A$ 限制在索引集 $S_i$ 上的主子矩阵。限制算子 $R_i$ 是相应的注入矩阵。\n\n3.  **粗糙空间构造**：粗糙空间由一组基函数定义，这些基函数构成了限制矩阵 $R_0$ 的行。\n    -   **仅角点**：基函数是与子域角点处的网格点相对应的单位向量。对于一个 $n_x \\times n_y$ 的划分，存在 $(n_x+1)(n_y+1)$ 个这样的角点，其索引被限制在有效的内部网格范围内。\n    -   **角点加边**：该空间包括角点基函数以及为子域间界面添加的附加函数。对于每个界面线（例如，在 $x$ 索引为 $k \\cdot m$ 处），创建一个基函数，该函数在该线上所有节点上具有常数值，在其他地方为零。选择该常数以使基向量的欧几里得范数为 $1$。\n\n4.  **预条件子应用 ($z = M^{-1}r$)**：预条件子对残差向量 $r$ 的作用计算为一个粗糙校正和局部子域校正之和：\n    $$ z = R_0^\\top A_0^{-1} (R_0 r) + \\sum_{i=1}^{N_s} R_i^\\top A_i^{-1} (R_i r) $$\n    -   粗糙算子 $A_0$ 通过伽辽金投影形成：$A_0 = R_0 A R_0^\\top$。由于 $A_0$ 很小，它的逆可以通过一个稠密线性求解器直接计算。\n    -   局部子域求解，$A_i^{-1}(R_i r)$，通过在每个预先计算的局部矩阵 $A_i$ 上使用直接求解器（例如，LU 分解）来执行。然后将结果延拓回去（通过 $R_i^\\top$）并求和。\n\n5.  **预条件共轭梯度 (PCG)**：实现一个标准的 PCG 算法来求解 $Au=b$。它需要一个函数来计算矩阵向量乘积 $A \\cdot p$ 和另一个函数来应用预条件子 $z = M^{-1}r$。从 $u_0 = 0$ 开始，迭代进行直到相对残差范数满足 $\\lVert r_k \\rVert_2 / \\lVert b \\rVert_2 \\leq 10^{-8}$。\n\n主程序遍历指定的测试用例，并对每个用例，为两种粗糙空间类型配置并运行模拟，记录每次运行的最终迭代次数。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nimport scipy.sparse.linalg\n\ndef construct_laplacian_2d(Nx, Ny):\n    \"\"\"\n    Constructs the 2D Laplacian matrix A for an Nx x Ny grid\n    using a 5-point finite difference stencil.\n    \"\"\"\n    T_y = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(Ny, Ny), format='csr')\n    T_x = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(Nx, Nx), format='csr')\n    # Using lexicographical ordering k = i*Ny + j, where i is the x-index (slow)\n    # and j is the y-index (fast).\n    A = sparse.kronsum(T_y, T_x)\n    return A.tocsr()\n\ndef get_subdomain_data(A, Nx, Ny, nx, ny, m, delta):\n    \"\"\"\n    Computes subdomain index sets and pre-factorizes local matrices.\n    \"\"\"\n    subdomain_indices = []\n    subdomain_solvers = []\n    global_indices_grid = np.arange(Nx * Ny).reshape((Nx, Ny))\n\n    for ix in range(nx):\n        for iy in range(ny):\n            x_start = max(0, ix * m - delta)\n            x_end = min(Nx, (ix + 1) * m + delta)\n            \n            y_start = max(0, iy * m - delta)\n            y_end = min(Ny, (iy + 1) * m + delta)\n\n            indices = global_indices_grid[x_start:x_end, y_start:y_end].flatten()\n            subdomain_indices.append(indices)\n\n            A_local = A[indices, :][:, indices].tocsc()\n            subdomain_solvers.append(scipy.sparse.linalg.splu(A_local))\n            \n    return subdomain_indices, subdomain_solvers\n\ndef build_coarse_space(Nx, Ny, nx, ny, m, space_type):\n    \"\"\"\n    Builds the coarse space restriction operator R0.\n    \"\"\"\n    N = Nx * Ny\n    basis_vectors = []\n\n    # Corners-only space\n    x_lines = [k * m for k in range(nx + 1)]\n    y_lines = [l * m for l in range(ny + 1)]\n    \n    x_coords = sorted(list(set([min(idx, Nx - 1) for idx in x_lines])))\n    y_coords = sorted(list(set([min(idx, Ny - 1) for idx in y_lines])))\n\n    for xc in x_coords:\n        for yc in y_coords:\n            global_idx = xc * Ny + yc\n            vec = sparse.csc_matrix(([1.0], ([0], [global_idx])), shape=(1, N))\n            basis_vectors.append(vec)\n\n    # Corners-plus-edges space\n    if space_type == 'corners+edges':\n        # Vertical edge functions\n        for k in range(1, nx):\n            x_idx = k * m\n            nodes_on_edge = [x_idx * Ny + j for j in range(Ny)]\n            data = np.full(Ny, 1.0 / np.sqrt(Ny))\n            rows = np.zeros(Ny, dtype=int)\n            cols = np.array(nodes_on_edge)\n            vec = sparse.csc_matrix((data, (rows, cols)), shape=(1, N))\n            basis_vectors.append(vec)\n\n        # Horizontal edge functions\n        for l in range(1, ny):\n            y_idx = l * m\n            nodes_on_edge = [i * Ny + y_idx for i in range(Nx)]\n            data = np.full(Nx, 1.0 / np.sqrt(Nx))\n            rows = np.zeros(Nx, dtype=int)\n            cols = np.array(nodes_on_edge)\n            vec = sparse.csc_matrix((data, (rows, cols)), shape=(1, N))\n            basis_vectors.append(vec)\n            \n    return sparse.vstack(basis_vectors, format='csr')\n\ndef pcg(A, b, precon_func, tol=1e-8):\n    \"\"\"\n    Preconditioned Conjugate Gradient solver.\n    \"\"\"\n    n = A.shape[0]\n    x = np.zeros(n)\n    r = b.copy()\n    \n    norm_b = np.linalg.norm(b)\n    if norm_b == 0:\n        return 0\n\n    if np.linalg.norm(r) / norm_b = tol:\n        return 0\n\n    z = precon_func(r)\n    p = z.copy()\n    rs_old = np.dot(r, z)\n\n    for i in range(n): \n        Ap = A.dot(p)\n        alpha = rs_old / np.dot(p, Ap)\n\n        x += alpha * p\n        r -= alpha * Ap\n\n        if np.linalg.norm(r) / norm_b = tol:\n            return i + 1\n\n        z = precon_func(r)\n        rs_new = np.dot(r, z)\n\n        beta = rs_new / rs_old\n        p = z + beta * p\n        rs_old = rs_new\n        \n    return n\n\ndef solve():\n    test_cases = [\n        (4, 2, 2, 1),\n        (8, 2, 2, 1),\n        (16, 2, 2, 1),\n        (24, 2, 2, 1),\n    ]\n\n    all_results = []\n    \n    for m, nx, ny, delta in test_cases:\n        Nx = nx * m\n        Ny = ny * m\n        N = Nx * Ny\n\n        A = construct_laplacian_2d(Nx, Ny)\n        \n        subdomain_indices, subdomain_solvers = get_subdomain_data(A, Nx, Ny, nx, ny, m, delta)\n        \n        case_results = []\n        for space_type in ['corners', 'corners+edges']:\n            R0 = build_coarse_space(Nx, Ny, nx, ny, m, space_type)\n            A0 = (R0 @ A @ R0.T).toarray()\n            A0_inv = np.linalg.inv(A0)\n            \n            def apply_preconditioner(r):\n                z = np.zeros(N)\n                \n                # Coarse correction\n                r0 = R0 @ r\n                w0 = A0_inv @ r0\n                z += R0.T @ w0\n                \n                # Local corrections (Additive Schwarz)\n                for i in range(len(subdomain_solvers)):\n                    indices = subdomain_indices[i]\n                    r_local = r[indices]\n                    w_local = subdomain_solvers[i].solve(r_local)\n                    z[indices] += w_local\n                    \n                return z\n            \n            b = np.ones(N)\n            iterations = pcg(A, b, apply_preconditioner, tol=1e-8)\n            case_results.append(iterations)\n        \n        all_results.append(case_results)\n\n    # Format the final output string to be exactly as required (no spaces)\n    print(repr(all_results).replace(' ', ''))\n\nsolve()\n```", "id": "3434344"}]}