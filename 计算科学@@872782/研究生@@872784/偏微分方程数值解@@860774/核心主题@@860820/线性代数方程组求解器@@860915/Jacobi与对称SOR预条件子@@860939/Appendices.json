{"hands_on_practices": [{"introduction": "我们从一个最简单的情景开始：将雅可比（Jacobi）预处理应用于一维泊松方程。这个练习作为一个至关重要的基准，通过直接的特征值分析，揭示了雅可比方法的基本原理和局限性。理解这个简单的案例 [@problem_id:3412279] 有助于阐明为什么对于偏微分方程（PDE）离散化问题，我们通常需要更复杂的预处理技术。", "problem": "考虑区间 $(0,1)$ 上的一维泊松方程 $-u''(x) = f(x)$，其边界条件为狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。用 $n$ 个内部网格点对区间进行离散化，网格点位置为 $x_i = i h$，其中 $i=1,2,\\dots,n$，$h = \\frac{1}{n+1}$。使用 $-u''(x)$ 的标准二阶中心有限差分近似，可以得到一个线性系统 $A \\, \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} \\in \\mathbb{R}^{n}$，$A \\in \\mathbb{R}^{n \\times n}$ 是一个三对角矩阵，其元素为 $A_{ii} = \\frac{2}{h^{2}}$ 和 $A_{i,i\\pm1} = -\\frac{1}{h^{2}}$。令 $D$ 表示 $A$ 的对角部分。定义 Jacobi 预处理算子为 $D^{-1} A$。\n\n从第一性原理出发——即 $A$ 的有限差分构造以及线性算子的特征值和特征向量的定义——推导 $A$ 和 $D^{-1} A$ 的特征值。然后，利用这些特征值来评估 Jacobi 预处理对渐近2-范数条件数的影响。具体而言，计算下式的精确值：\n$$\n\\lim_{n \\to \\infty} \\frac{\\kappa_{2}\\!\\left(D^{-1} A\\right)}{\\kappa_{2}(A)} \\, ,\n$$\n其中 $\\kappa_{2}$ 表示对称正定矩阵的2-范数条件数，定义为最大特征值与最小特征值之比。\n\n将你的最终答案表示为一个实数。无需四舍五入。", "solution": "对问题陈述进行验证。\n\n### 第1步：提取已知条件\n-   **方程**：区间 $(0,1)$ 上的一维泊松方程 $-u''(x) = f(x)$。\n-   **边界条件**：狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。\n-   **离散化**：$n$ 个内部网格点，位置为 $x_i = i h$，其中 $i=1,2,\\dots,n$，网格间距为 $h = \\frac{1}{n+1}$。\n-   **有限差分近似**：对 $-u''(x)$ 使用标准二阶中心有限差分。\n-   **线性系统**：$A \\, \\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} \\in \\mathbb{R}^{n}$ 且 $A \\in \\mathbb{R}^{n \\times n}$。\n-   **矩阵A**：三对角矩阵，其元素为 $A_{ii} = \\frac{2}{h^{2}}$ 和 $A_{i,i\\pm1} = -\\frac{1}{h^{2}}$。\n-   **预处理器**：$D$ 定义为 $A$ 的对角部分。\n-   **预处理算子**：$D^{-1} A$。\n-   **条件数**：对于对称正定矩阵 $M$，$\\kappa_{2}(M)$ 定义为其最大特征值与最小特征值之比，即 $\\frac{\\lambda_{\\max}(M)}{\\lambda_{\\min}(M)}$。\n-   **目标**：计算极限 $\\lim_{n \\to \\infty} \\frac{\\kappa_{2}(D^{-1} A)}{\\kappa_{2}(A)}$ 的精确值。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学依据，根植于偏微分方程数值分析的基本原理。泊松方程的有限差分离散化是该领域的典型例子。题目设置是自洽的，提供了所有必要的定义和数据。矩阵 $A$ 是一个众所周知的对称正定（SPD）矩阵，因此其特征值是实数且为正，其条件数是良定义的。对角矩阵 $D$ 的元素为正，因此它是可逆的。预处理矩阵 $D^{-1}A$ 是 $D^{-1} = \\frac{h^2}{2}I$（一个SPD矩阵）和 $A$（一个SPD矩阵）的乘积。我们将看到，$D^{-1}A$ 是 $A$ 的一个标量倍数，因此它也是SPD的。该问题是适定的、客观的，并且没有违反任何无效标准。\n\n### 第3步：结论与行动\n问题是有效的。将提供一个完整且有理有据的解法。\n\n行动方案是推导矩阵 $A$ 和预处理矩阵 $D^{-1}A$ 的特征值，计算它们各自的条件数，并评估其比值的极限。\n\n首先，我们确定矩阵 $A$ 的特征值。矩阵 $A$ 是由负二阶导数算子的有限差分近似定义的。对于在点 $x_j$ 上定义的网格函数 $v_j$，特征值问题 $A\\mathbf{v} = \\lambda \\mathbf{v}$ 对应于以下差分方程组：\n$$\n\\frac{1}{h^2}(-v_{j-1} + 2v_j - v_{j+1}) = \\lambda v_j, \\quad \\text{for } j = 1, 2, \\dots, n.\n$$\n狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$ 意味着特征向量 $\\mathbf{v}$ 的分量满足 $v_0 = 0$ 和 $v_{n+1}=0$。该差分方程可以重写为：\n$$\n2v_j - (v_{j-1} + v_{j+1}) = (\\lambda h^2) v_j.\n$$\n我们寻求形式为 $v_j = \\sin(j\\theta)$ 的解，其中 $\\theta$ 是某个参数。这种形式自动满足边界条件 $v_0=0$。将此形式代入差分方程，得到：\n$$\n2\\sin(j\\theta) - (\\sin((j-1)\\theta) + \\sin((j+1)\\theta)) = (\\lambda h^2) \\sin(j\\theta).\n$$\n使用三角和差化积恒等式 $\\sin(\\alpha - \\beta) + \\sin(\\alpha + \\beta) = 2\\sin(\\alpha)\\cos(\\beta)$，该表达式化简为：\n$$\n2\\sin(j\\theta) - 2\\sin(j\\theta)\\cos(\\theta) = (\\lambda h^2) \\sin(j\\theta).\n$$\n对于非平凡特征向量，$\\sin(j\\theta)$ 不恒为零，因此我们可以两边同除以它，以获得关于特征值 $\\lambda$ 的关系式：\n$$\n2(1 - \\cos(\\theta)) = \\lambda h^2.\n$$\n使用半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\frac{\\theta}{2})$，上式变为：\n$$\n4\\sin^2\\left(\\frac{\\theta}{2}\\right) = \\lambda h^2.\n$$\n第二个边界条件 $v_{n+1}=0$ 要求 $\\sin((n+1)\\theta) = 0$。这意味着 $(n+1)\\theta = k\\pi$，其中 $k$ 是一个整数。为了获得 $n$ 个线性无关的特征向量，我们取 $k = 1, 2, \\dots, n$。这将参数 $\\theta$ 量化为值 $\\theta_k = \\frac{k\\pi}{n+1}$。\n代入这些 $\\theta_k$ 的值，可以得到 $A$ 的 $n$ 个不同特征值：\n$$\n\\lambda_k(A) = \\frac{4}{h^2} \\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right), \\quad \\text{for } k=1, 2, \\dots, n.\n$$\n由于当 $x \\in (0, \\pi/2]$ 时 $\\sin^2(x)  0$，所有特征值都是正的，这证实了 $A$ 是正定的。\n\n条件数 $\\kappa_2(A)$ 是最大特征值与最小特征值之比。正弦函数在 $[0, \\pi/2]$ 上是单调递增的。对于 $k=1, \\dots, n$，自变量 $\\frac{k\\pi}{2(n+1)}$ 都在这个范围内。\n最小特征值 $\\lambda_{\\min}(A)$ 对应于 $k=1$：\n$$\n\\lambda_{\\min}(A) = \\lambda_1(A) = \\frac{4}{h^2} \\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right).\n$$\n最大特征值 $\\lambda_{\\max}(A)$ 对应于 $k=n$：\n$$\n\\lambda_{\\max}(A) = \\lambda_n(A) = \\frac{4}{h^2} \\sin^2\\left(\\frac{n\\pi}{2(n+1)}\\right).\n$$\n因此，$A$ 的条件数为：\n$$\n\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)} = \\frac{\\frac{4}{h^2} \\sin^2\\left(\\frac{n\\pi}{2(n+1)}\\right)}{\\frac{4}{h^2} \\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right)} = \\frac{\\sin^2\\left(\\frac{n\\pi}{2(n+1)}\\right)}{\\sin^2\\left(\\frac{\\pi}{2(n+1)}\\right)}.\n$$\n\n接下来，我们分析预处理矩阵 $D^{-1}A$。矩阵 $D$ 是 $A$ 的对角部分。根据问题陈述，$A$ 的所有对角线元素都是相同的：$A_{ii} = \\frac{2}{h^2}$。因此，$D$ 是单位矩阵 $I_n$ 的一个标量倍数：\n$$\nD = \\frac{2}{h^2} I_n.\n$$\n它的逆矩阵就是：\n$$\nD^{-1} = \\left(\\frac{2}{h^2} I_n\\right)^{-1} = \\frac{h^2}{2} I_n.\n$$\n预处理矩阵是：\n$$\nD^{-1}A = \\left(\\frac{h^2}{2} I_n\\right) A = \\frac{h^2}{2} A.\n$$\n由于 $D^{-1}A$ 是 $A$ 的一个标量倍数，它的特征向量与 $A$ 的特征向量相同。如果 $\\mathbf{v}_k$ 是 $A$ 的一个特征向量，其对应的特征值为 $\\lambda_k(A)$，那么：\n$$\n(D^{-1}A)\\mathbf{v}_k = \\left(\\frac{h^2}{2}A\\right)\\mathbf{v}_k = \\frac{h^2}{2}(A\\mathbf{v}_k) = \\frac{h^2}{2}\\lambda_k(A)\\mathbf{v}_k.\n$$\n$D^{-1}A$ 的特征值（我们记为 $\\mu_k$）是 $\\mu_k = \\frac{h^2}{2}\\lambda_k(A)$。\n$D^{-1}A$ 的最大和最小特征值是：\n$$\n\\lambda_{\\min}(D^{-1}A) = \\mu_1 = \\frac{h^2}{2}\\lambda_{\\min}(A).\n$$\n$$\n\\lambda_{\\max}(D^{-1}A) = \\mu_n = \\frac{h^2}{2}\\lambda_{\\max}(A).\n$$\n预处理矩阵 $D^{-1}A$ 的条件数是：\n$$\n\\kappa_2(D^{-1}A) = \\frac{\\lambda_{\\max}(D^{-1}A)}{\\lambda_{\\min}(D^{-1}A)} = \\frac{\\frac{h^2}{2}\\lambda_{\\max}(A)}{\\frac{h^2}{2}\\lambda_{\\min}(A)} = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)} = \\kappa_2(A).\n$$\n这表明，对于由具有常系数的一维泊松问题产生的特定矩阵 $A$，Jacobi 预处理器对条件数没有影响。原因在于 $A$ 的对角线是常数，这使得预处理器只是对系统进行简单的缩放。\n\n最后，我们计算所要求的极限。题目要求我们计算：\n$$\n\\lim_{n \\to \\infty} \\frac{\\kappa_{2}(D^{-1} A)}{\\kappa_{2}(A)}.\n$$\n由于我们已经确定对于任何 $n \\ge 1$ 都有 $\\kappa_2(D^{-1}A) = \\kappa_2(A)$，该比值恒等于 $1$：\n$$\n\\frac{\\kappa_{2}(D^{-1} A)}{\\kappa_{2}(A)} = 1.\n$$\n常数序列的极限就是常数本身。因此：\n$$\n\\lim_{n \\to \\infty} \\frac{\\kappa_{2}(D^{-1} A)}{\\kappa_{2}(A)} = \\lim_{n \\to \\infty} 1 = 1.\n$$", "answer": "$$\n\\boxed{1}\n$$", "id": "3412279"}, {"introduction": "在分析了简单的预处理器之后，本练习将进入一个更真实也更复杂的场景：二维泊松问题。您将通过计算实现对称逐次超松弛（SSOR）预处理器，并研究一个影响其性能的关键因素——节点排序。通过比较标准的字典序与红黑排序 [@problem_id:3412295]，您将获得关于实施选择如何显著影响迭代求解器收敛性的实践经验。", "problem": "考虑单位正方形 $(0,1)^2$ 上的二维泊松方程 $-\\Delta u = f$，带有齐次狄利克雷边界条件。在 $n \\times n$ 内部点的均匀网格上，使用标准中心有限差分格式离散化算子 $-\\Delta$，得到一个对称正定线性系统 $A_n u = b$，其中 $A_n \\in \\mathbb{R}^{N \\times N}$ 且 $N = n^2$。矩阵 $A_n$ 具有众所周知的五点模板结构，可以通过一维三对角矩阵 $T_n \\in \\mathbb{R}^{n \\times n}$ 构建，$T_n$ 的对角线元素为 $2/h^2$，第一条次对角线和超对角线元素为 $-1/h^2$，其中 $h = 1/(n+1)$。构建方式为克罗内克和 $A_n = I_n \\otimes T_n + T_n \\otimes I_n$，其中 $I_n$ 是 $n \\times n$ 单位矩阵，$\\otimes$ 表示克罗内克积。\n\n通过将网格点 $(i,j)$（其中 $i,j \\in \\{0,1,\\dots,n-1\\}$）映射到线性索引 $k = i n + j$，定义自然字典序。通过一个置换定义红黑排序，该置换首先列出所有 $(i+j)$ 为偶数（红色）的索引，然后是所有 $(i+j)$ 为奇数（黑色）的索引。对于任意排序，定义矩阵分裂 $A = D - L - U$，其中 $D$ 是 $A$ 的对角部分，$L$ 和 $U$ 分别是 $-A$ 的严格下三角和严格上三角部分，因此 $L$ 和 $U$ 的元素非负。带有松弛因子 $\\omega \\in (0,2)$ 的对称逐次超松弛（SSOR）预条件子是与执行一次前向逐次超松弛（SOR）扫描后跟一次后向 SOR 扫描相关联的对称正定矩阵。令 $M_{\\omega}$ 表示此 SSOR 预条件子。\n\n对于给定的排序和松弛因子 $\\omega$，预处理谱是满足 $A x = \\lambda M_{\\omega} x$ 的广义特征值 $\\lambda$ 的集合。该广义谱与对称预处理算子 $M_{\\omega}^{-1/2} A M_{\\omega}^{-1/2}$ 的普通谱以及左预处理算子 $M_{\\omega}^{-1} A$ 的谱重合。\n\n任务：\n- 为每个指定的 $n$ 构建 $A_n$。\n- 对于每个 $n$ 和 $\\omega$，在自然排序下构建 $M_{\\omega}$，并计算 $(A_n, M_{\\omega})$ 的最小和最大广义特征值，以及它们的比率（广义特征值问题的条件数），定义为 $\\kappa_{\\mathrm{nat}} = \\lambda_{\\max}/\\lambda_{\\min}$。\n- 构建红黑置换，在红黑排序下形成置换后的系统 $A_{n,\\mathrm{rb}}$，相应地构建 $M_{\\omega,\\mathrm{rb}}$，并计算 $(A_{n,\\mathrm{rb}}, M_{\\omega,\\mathrm{rb}})$ 的最小和最大广义特征值及其比率 $\\kappa_{\\mathrm{rb}} = \\lambda_{\\max}/\\lambda_{\\min}$。\n- 对每个测试用例，将输出聚合为三元组 $[\\kappa_{\\mathrm{nat}}, \\kappa_{\\mathrm{rb}}, \\kappa_{\\mathrm{nat}}/\\kappa_{\\mathrm{rb}}]$，其中第三个条目量化了红黑排序相对于自然排序的改进因子。\n\n使用以下参数值测试套件：\n- 情况 1：$n = 8$, $\\omega = 1.0$。\n- 情况 2：$n = 8$, $\\omega = 1.5$。\n- 情况 3：$n = 16$, $\\omega = 1.9$。\n- 情况 4：$n = 4$, $\\omega = 1.2$。\n\n您的程序必须：\n- 计算每种情况下的三个浮点数。\n- 将报告的每个浮点数四舍五入到六位小数。\n- 生成单行输出，其中包含用逗号分隔并用方括号括起来的结果，每个案例的三元组本身也是一个用方括号括起来的逗号分隔列表，顺序与测试套件相同。例如，输出格式必须为 $[[a_1,b_1,c_1],[a_2,b_2,c_2],\\dots]$，所有数值条目都四舍五入到六位小数。\n\n输出不涉及物理单位或角度单位。不得使用百分比；比率必须以小数形式报告。", "solution": "我们从二维泊松方程的离散模型开始。在 $(0,1)^2$ 上带有齐次狄利克雷边界条件的连续算子 $-\\Delta$ 产生一个对称正定算子。在步长为 $h = 1/(n+1)$ 的 $n \\times n$ 内部点均匀网格上，使用中心有限差分进行离散化，可得到矩阵 $A_n \\in \\mathbb{R}^{N \\times N}$，其中 $N = n^2$，且具有标准的五点模板。一种稳定且广泛使用的构建方法是通过克罗内克和\n$$\nA_n = I_n \\otimes T_n + T_n \\otimes I_n,\n$$\n其中 $I_n$ 是 $n \\times n$ 单位矩阵，$T_n \\in \\mathbb{R}^{n \\times n}$ 是三对角矩阵，对角线元素为 $2/h^2$，紧邻的次对角线元素为 $-1/h^2$。此矩阵 $A_n$ 是对称正定的。\n\n为了讨论对称逐次超松弛（SSOR）预条件子，回顾矩阵分裂\n$$\nA = D - L - U,\n$$\n其中 $D$ 是 $A$ 的对角部分，$L$ 和 $U$ 分别是 $-A$ 的严格下三角和严格上三角部分，因此 $L$ 和 $U$ 的元素非负。用松弛因子 $\\omega \\in (0,2)$ 求解 $A x = b$ 的逐次超松弛（SOR）迭代包括使用 $(D - \\omega L)$ 的前向三角扫描和使用 $(D - \\omega U)$ 的后向三角扫描。SSOR 预条件子 $M_{\\omega}$ 是通过组合前向和后向 SOR 步骤并进行适当缩放而形成的对称正定矩阵。根据 SOR 的基本定义，一个标准的推导得出 SSOR 预条件子为\n$$\nM_{\\omega} = \\frac{1}{\\omega (2 - \\omega)} (D - \\omega L) D^{-1} (D - \\omega U).\n$$\n这可以通过将前向 SOR 步骤解释为求解 $(D - \\omega L) y = r$，将后向 SOR 步骤解释为求解 $(D - \\omega U) z = D y$，然后组合并缩放以获得一个近似于 $A$ 并保持共轭梯度兼容性的对称正定算子来理解。对于 $0  \\omega  2$，$M_{\\omega}$ 是对称正定的。\n\n当使用左预条件子 $M_{\\omega}$ 时，研究广义特征值问题\n$$\nA x = \\lambda M_{\\omega} x,\n$$\n其特征值 $\\lambda$ 等于对称预处理算子 $M_{\\omega}^{-1/2} A M_{\\omega}^{-1/2}$ 的特征值，也等于 $M_{\\omega}^{-1} A$ 的谱。因为 $A$ 是对称正定的，$M_{\\omega}$ 也是对称正定的，所以广义特征值是实数且为正，广义特征值问题的条件数为\n$$\n\\kappa = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}}.\n$$\n一个较小的 $\\kappa$ 表示谱更紧密地聚集，这对于克雷洛夫方法是有利的。\n\n排序影响严格三角分量 $L$ 和 $U$，因此也影响 SSOR 预条件子。在自然字典序中，索引沿一个方向然后下一个方向递增；在红黑排序中，根据 $(i+j)$ 的奇偶性用两种颜色为网格着色，首先放置所有红色节点，然后是所有黑色节点。红黑排序使网格图的邻接模式块对角化，这反过来又改变了 $L$ 和 $U$ 的结构，并且对于椭圆问题，通常会改善 SSOR 预条件子的谱特性。\n\n算法步骤：\n- 使用克罗内克和 $A_n = I_n \\otimes T_n + T_n \\otimes I_n$ 构建 $A_n$。\n- 在自然排序下，形成 $D = \\operatorname{diag}(A)$、$L = -\\operatorname{tril}(A,-1)$、$U = -\\operatorname{triu}(A,1)$，并计算\n$$\nM_{\\omega} = \\frac{1}{\\omega (2 - \\omega)} (D - \\omega L) D^{-1} (D - \\omega U).\n$$\n- 求解广义特征值问题 $A x = \\lambda M_{\\omega} x$ 以获得 $\\lambda_{\\min}$ 和 $\\lambda_{\\max}$；计算 $\\kappa_{\\mathrm{nat}} = \\lambda_{\\max}/\\lambda_{\\min}$。\n- 构建红黑置换，方法是先列出所有 $(i+j)$ 为偶数的索引 $(i,j)$，然后是 $(i+j)$ 为奇数的索引。将此置换应用于 $A_n$ 以获得 $A_{n,\\mathrm{rb}}$，并根据置换后的 $A_{n,\\mathrm{rb}}$ 通过相同的 SSOR 公式构建 $M_{\\omega,\\mathrm{rb}}$。\n- 求解广义特征值问题 $A_{n,\\mathrm{rb}} x = \\lambda M_{\\omega,\\mathrm{rb}} x$ 以获得 $\\lambda_{\\min}$ 和 $\\lambda_{\\max}$；计算 $\\kappa_{\\mathrm{rb}} = \\lambda_{\\max}/\\lambda_{\\min}$。\n- 对于每个测试用例，报告三元组 $[\\kappa_{\\mathrm{nat}}, \\kappa_{\\mathrm{rb}}, \\kappa_{\\mathrm{nat}}/\\kappa_{\\mathrm{rb}}]$，每个浮点数四舍五入到六位小数。\n\n数值考虑：\n- 矩阵是稀疏且对称正定的；使用稀疏线性代数以提高效率和数值稳定性。\n- 在实践中，由于浮点舍入，通过 $(M_{\\omega} + M_{\\omega}^{\\top})/2$ 显式地对称化 $M_{\\omega}$ 可以帮助确保广义对称特征值求解器所需的对称性。\n- 最小和最大广义特征值可以使用对称特征值求解器高效地计算，该求解器用于广义问题 $A x = \\lambda M x$，其中 $A$ 对称，$M$ 对称正定，并返回极端特征值。\n\n下面的实现构建了矩阵，执行了广义特征值计算，并为指定的测试套件打印了要求的输出。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron, tril, triu, csr_matrix\nfrom scipy.sparse.linalg import eigsh\n\ndef build_2d_poisson(n: int) - csr_matrix:\n    \"\"\"\n    Build the 2D Poisson (negative Laplacian) matrix with Dirichlet boundary conditions\n    on an n x n grid of interior points using the 5-point stencil.\n    A = kron(I, T) + kron(T, I), where T is 1D tridiagonal with [ -1, 2, -1 ] scaled by 1/h^2.\n    \"\"\"\n    h = 1.0 / (n + 1)\n    main = (2.0 / (h * h)) * np.ones(n)\n    off = (-1.0 / (h * h)) * np.ones(n - 1)\n    T = diags([off, main, off], offsets=[-1, 0, 1], format='csr')\n    I = identity(n, format='csr')\n    A = kron(I, T) + kron(T, I)\n    return A.tocsr()\n\ndef ssor_preconditioner(A: csr_matrix, omega: float) - csr_matrix:\n    \"\"\"\n    Construct the SSOR preconditioner M_omega = 1/(omega(2-omega)) * (D - omega L) * D^{-1} * (D - omega U),\n    where A = D - L - U with L = -tril(A,-1), U = -triu(A,1).\n    \"\"\"\n    if not (0.0  omega  2.0):\n        raise ValueError(\"omega must be in (0,2) for SSOR preconditioner.\")\n    # Diagonal and strictly lower/upper parts\n    diagA = A.diagonal()\n    D = diags(diagA, format='csr')\n    L = -tril(A, k=-1).tocsr()\n    U = -triu(A, k=1).tocsr()\n    # Inverse of diagonal\n    D_inv = diags(1.0 / diagA, format='csr')\n    # Assemble SSOR\n    S1 = (D - omega * L).tocsr()\n    S2 = (D - omega * U).tocsr()\n    denom = omega * (2.0 - omega)\n    M = (S1 @ D_inv @ S2) * (1.0 / denom)\n    # Ensure symmetry numerically\n    M = ((M + M.T) * 0.5).tocsr()\n    return M\n\ndef red_black_permutation(n: int) - np.ndarray:\n    \"\"\"\n    Construct red-black ordering permutation indices for an n x n grid.\n    Red: (i+j) even; Black: (i+j) odd. Return permutation list mapping\n    old indices to new order [reds, blacks].\n    \"\"\"\n    red = []\n    black = []\n    for i in range(n):\n        for j in range(n):\n            idx = i * n + j\n            if ((i + j) % 2) == 0:\n                red.append(idx)\n            else:\n                black.append(idx)\n    return np.array(red + black, dtype=int)\n\ndef generalized_extremal_eigs(A: csr_matrix, M: csr_matrix) - tuple[float, float]:\n    \"\"\"\n    Compute smallest and largest generalized eigenvalues of A x = lambda M x.\n    A must be symmetric; M must be symmetric positive definite.\n    \"\"\"\n    # Smallest algebraic eigenvalue\n    lam_min = eigsh(A, k=1, M=M, which='SA', return_eigenvectors=False, tol=1e-10)[0]\n    # Largest algebraic eigenvalue\n    lam_max = eigsh(A, k=1, M=M, which='LA', return_eigenvectors=False, tol=1e-10)[0]\n    # Guard against any tiny negative due to roundoff\n    lam_min = float(lam_min)\n    lam_max = float(lam_max)\n    if lam_min = 0:\n        lam_min = max(lam_min, 1e-14)\n    return lam_min, lam_max\n\ndef compute_condition_numbers(n: int, omega: float) - tuple[float, float, float]:\n    \"\"\"\n    For given n and omega, compute condition numbers for natural ordering and red-black ordering SSOR\n    preconditioned generalized eigenvalue problems, and their improvement ratio.\n    Returns (kappa_nat, kappa_rb, improvement).\n    \"\"\"\n    # Build A for natural ordering\n    A_nat = build_2d_poisson(n)\n    # SSOR for natural ordering\n    M_nat = ssor_preconditioner(A_nat, omega)\n    lam_min_nat, lam_max_nat = generalized_extremal_eigs(A_nat, M_nat)\n    kappa_nat = lam_max_nat / lam_min_nat\n\n    # Red-black permuted system\n    perm = red_black_permutation(n)\n    # Apply permutation to A: A_rb = P^T A P, achieved by indexing rows and cols\n    A_rb = A_nat[perm, :][:, perm]\n    # SSOR for red-black ordered matrix\n    M_rb = ssor_preconditioner(A_rb, omega)\n    lam_min_rb, lam_max_rb = generalized_extremal_eigs(A_rb, M_rb)\n    kappa_rb = lam_max_rb / lam_min_rb\n\n    improvement = kappa_nat / kappa_rb\n    return kappa_nat, kappa_rb, improvement\n\ndef format_results(results: list[tuple[float, float, float]]) - str:\n    \"\"\"\n    Format the list of triples into the required single-line string with six decimal places\n    and no extra spaces: [[a,b,c],[...],...]\n    \"\"\"\n    parts = []\n    for triple in results:\n        a, b, c = triple\n        parts.append(f\"[{a:.6f},{b:.6f},{c:.6f}]\")\n    return f\"[{','.join(parts)}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (n, omega)\n    test_cases = [\n        (8, 1.0),\n        (8, 1.5),\n        (16, 1.9),\n        (4, 1.2),\n    ]\n\n    results = []\n    for n, omega in test_cases:\n        kappa_nat, kappa_rb, improvement = compute_condition_numbers(n, omega)\n        results.append((kappa_nat, kappa_rb, improvement))\n\n    # Final print statement in the exact required format.\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3412295"}, {"introduction": "最后的这个练习将我们的视野从有限差分法扩展到有限元法（FEM）。它介绍了“集中”（lumping）这一在有限元法中常见的技术，并将其作为雅可比预处理的一种变体。通过在一个反应扩散问题上，针对不同的网格几何形状，实现并比较标准雅可比预处理器与其行和集中（row-sum lumped）对应方法 [@problem_id:3412341]，您将探索离散化技术、矩阵性质和预处理效率之间的深层联系。", "problem": "考虑在二维域上具有齐次 Dirichlet 边界条件的反应扩散模型：求 $u \\in H_0^1(\\Omega)$，使得\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, \\mathrm{d}x + \\alpha \\int_{\\Omega} u v \\, \\mathrm{d}x \\;=\\; \\int_{\\Omega} f v \\, \\mathrm{d}x \\quad \\text{对于所有 } v \\in H_0^1(\\Omega),\n$$\n其中反应系数 $\\alpha  0$。设 $\\Omega$ 是单位正方形在可逆线性映射 $F(\\xi) = P \\, \\xi$ 下的像，其中 $P \\in \\mathbb{R}^{2 \\times 2}$ 是非奇异矩阵，且 $\\xi \\in [0,1]^2$。在参数域 $[0,1]^2$ 中，分别沿 $\\xi_1$ 和 $\\xi_2$ 方向使用 $n_x$ 和 $n_y$ 个子区间的均匀张量积网格来离散化 $\\Omega$，并将每个参数网格单元沿从左下角到右上角的参数对角线分割成两个三角形。在每个三角形上使用线性 Lagrange 基函数，并通过消除边界自由度来施加齐次 Dirichlet 边界条件。\n\nGalerkin 有限元方法产生对称正定线性系统\n$$\nA \\, \\mathbf{u} = \\mathbf{b}, \\quad A = K + \\alpha M,\n$$\n其中 $K$ 是全局刚度矩阵，其元素为 $K_{ij} = \\sum_{T} \\int_{T} \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, \\mathrm{d}x$，$M$ 是全局质量矩阵，其元素为 $M_{ij} = \\sum_{T} \\int_{T} \\varphi_i \\varphi_j \\, \\mathrm{d}x$，而 $\\{\\varphi_i\\}$ 是限制在内部节点上的全局节点基函数。\n\n为 $A$ 定义两个对角预条件子 $D_{\\mathrm{std}}$ 和 $D_{\\mathrm{lump}}$ 如下：\n- 标准 Jacobi：$D_{\\mathrm{std}}$ 的对角元素为 $(D_{\\mathrm{std}})_{ii} = A_{ii}$。\n- 行和集中 Jacobi：$D_{\\mathrm{lump}}$ 的对角元素为 $(D_{\\mathrm{lump}})_{ii} = \\sum_{j} A_{ij}$。\n\n对于任何对称正定矩阵 $D$，其相对于 $A$ 的谱等价常数定义为\n$$\nc_{\\min}(D) := \\min_{\\mathbf{x} \\neq \\mathbf{0}} \\frac{\\mathbf{x}^\\top A \\mathbf{x}}{\\mathbf{x}^\\top D \\mathbf{x}}, \\qquad\nc_{\\max}(D) := \\max_{\\mathbf{x} \\neq \\mathbf{0}} \\frac{\\mathbf{x}^\\top A \\mathbf{x}}{\\mathbf{x}^\\top D \\mathbf{x}}.\n$$\n这些常数界定了 Rayleigh 商，并量化了 $A$ 和 $D$ 之间的谱等价性。\n\n您的任务是实现一个程序，该程序：\n- 使用上述过程，在三角形上使用线性单元来构造 $A = K + \\alpha M$。对于每个顶点为 $(x_1,y_1)$, $(x_2,y_2)$, $(x_3,y_3)$ 的三角形，使用标准的常梯度单元公式，对于质量矩阵，使用经过充分测试的单元级公式 $M_e = \\frac{|T|}{12} \\begin{bmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{bmatrix}$，其中 $|T|$ 是三角形的面积。\n- 通过消除参数域 $[0,1]^2$ 边界上节点对应的所有边界自由度来施加齐次 Dirichlet 边界条件。\n- 从内部节点系统矩阵 $A$ 构造 $D_{\\mathrm{std}}$ 和 $D_{\\mathrm{lump}}$。\n- 通过对称矩阵 $D^{-1/2} A D^{-1/2}$ 的极值特征值计算 $D \\in \\{D_{\\mathrm{std}}, D_{\\mathrm{lump}}\\}$ 的 $c_{\\min}(D)$ 和 $c_{\\max}(D)$。\n\n对所有测试用例使用以下固定参数：\n- 反应系数 $\\alpha = 1$。\n- 均匀子区间数 $n_x = 10$ 和 $n_y = 10$。\n\n使用以下产生各种单元形状的形状矩阵 $P$ 测试套件：\n1. $P_1 = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$。\n2. $P_2 = \\begin{bmatrix} 1  0 \\\\ 0.5  1 \\end{bmatrix}$。\n3. $P_3 = \\begin{bmatrix} 1  0 \\\\ 0  0.25 \\end{bmatrix}$。\n4. $P_4 = \\begin{bmatrix} 1  0.6 \\\\ 0.3  1 \\end{bmatrix}$。\n\n对于每个 $P_k$，在映射后的网格上组装 $A$，构造 $D_{\\mathrm{std}}$ 和 $D_{\\mathrm{lump}}$，并计算四个数值 $c_{\\min}(D_{\\mathrm{std}})$, $c_{\\max}(D_{\\mathrm{std}})$, $c_{\\min}(D_{\\mathrm{lump}})$, $c_{\\max}(D_{\\mathrm{lump}})$。将所有输出表示为四舍五入到六位小数的浮点数。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，结果按以下顺序排列\n$$\n[\\; c_{\\min}(D_{\\mathrm{std}}; P_1), \\; c_{\\max}(D_{\\mathrm{std}}; P_1), \\; c_{\\min}(D_{\\mathrm{lump}}; P_1), \\; c_{\\max}(D_{\\mathrm{lump}}; P_1), \\; \\dots, \\; c_{\\min}(D_{\\mathrm{std}}; P_4), \\; c_{\\max}(D_{\\mathrm{std}}; P_4), \\; c_{\\min}(D_{\\mathrm{lump}}; P_4), \\; c_{\\max}(D_{\\mathrm{lump}}; P_4) \\;].\n$$\n此问题中没有需要报告的物理单位。角度（在单元几何中隐式出现）由网格映射内在处理，不需要显式单位。确保所有数值输出在打印前都四舍五入到六位小数。", "solution": "目标是分析两种 Jacobi 型预条件子相对于由反应扩散方程的有限元离散化产生的系统矩阵的谱等价性。该分析涉及计算预处理后系统的最小和最大特征值，这些特征值界定了谱范围并决定了预处理迭代求解器的性能。\n\n对于每个指定的变换矩阵 $P_k$，执行以下步骤：\n\n**1. 域离散化与坐标变换**\n物理域 $\\Omega$ 被定义为参数单位正方形 $[0,1]^2$ 在线性变换 $F(\\xi) = P\\xi$ 下的像。首先在参数域 $[\\xi_1, \\xi_2] \\in [0,1]^2$ 中构建一个均匀张量积网格。该网格由 $(n_x+1) \\times (n_y+1)$ 个节点组成，节点坐标为 $\\xi_{ij} = (i/n_x, j/n_y)$，其中 $i \\in \\{0, \\dots, n_x\\}$ 且 $j \\in \\{0, \\dots, n_y\\}$，$n_x=10$ 且 $n_y=10$。然后，这 $(n_x+1)(n_y+1)$ 个参数节点被映射到 $\\Omega$ 中的相应物理坐标 $\\mathbf{x}_{ij} = P\\xi_{ij}$。\n\n通过首先将参数域划分为 $n_x \\times n_y$ 个方形单元，然后对域进行三角剖分。每个单元（其顶点对应于网格索引 $(i,j)$、$(i+1,j)$、$(i,j+1)$ 和 $(i+1, j+1)$）随后沿连接其左下角和右上角的对角线被分割成两个三角形。这样就得到了物理域 $\\Omega$ 的结构化三角剖分。\n\n**2. 有限元公式与单元矩阵**\n控制反应扩散方程在生成的三角形网格上使用分片线性 Lagrange 基函数（$\\mathcal{P}_1$ 单元）通过 Galerkin 有限元方法进行离散化。对于网格中的每个三角形 $T$，我们计算 $3 \\times 3$ 的单元刚度矩阵 $K_e$ 和单元质量矩阵 $M_e$。\n\n单元刚度矩阵的元素由 $(K_e)_{ij} = \\int_T \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, \\mathrm{d}x$ 给出。对于 $\\mathcal{P}_1$ 单元，基函数的梯度是常数。设三角形 $T$ 的顶点为 $\\mathbf{x}_1=(x_1, y_1)$、$\\mathbf{x}_2=(x_2, y_2)$ 和 $\\mathbf{x}_3=(x_3, y_3)$。基函数梯度的矩阵可以表示为：\n$$\nB = \\frac{1}{2|T|} \\begin{bmatrix} y_2 - y_3  x_3 - x_2 \\\\ y_3 - y_1  x_1 - x_3 \\\\ y_1 - y_2  x_2 - x_1 \\end{bmatrix}\n$$\n其中 $|T|$ 是三角形的面积。然后，单元刚度矩阵计算为 $K_e = |T| B B^\\top$。\n\n单元质量矩阵的元素为 $(M_e)_{ij} = \\int_T \\varphi_i \\varphi_j \\, \\mathrm{d}x$。问题指定使用线性三角形的标准公式：\n$$\nM_e = \\frac{|T|}{12} \\begin{bmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{bmatrix}\n$$\n算子 $-\\Delta u + \\alpha u$ 的完整单元矩阵是 $A_e = K_e + \\alpha M_e$。对于此问题，$\\alpha=1$。\n\n**3. 全局系统组装**\n通过遍历网格中的所有三角形来组装全局系统矩阵 $A$。对于每个单元，其局部矩阵 $A_e$ 的元素被加到全局矩阵 $A$ 的相应元素上。完整全局矩阵的大小为 $N \\times N$，其中 $N = (n_x+1)(n_y+1)$ 是节点的总数。\n\n**4. 施加齐次 Dirichlet 边界条件**\n通过消除与域边界上的节点相关的自由度来施加齐次 Dirichlet 边界条件。根据规定，如果一个节点的相应参数坐标位于单位正方形 $[0,1]^2$ 的边界上，则该节点被视为边界节点。这些是网格索引为 $(i,j)$ 的节点，其中 $i=0$、$i=n_x$、$j=0$ 或 $j=n_y$。最终的系统矩阵，记作 $A_{\\mathrm{int}}$，是由仅对应于内部节点的行和列构成的 $A$ 的子矩阵。对于 $n_x=10$ 和 $n_y=10$，有 $(n_x-1)(n_y-1) = 81$ 个内部节点，因此 $A_{\\mathrm{int}}$ 是一个 $81 \\times 81$ 的对称正定矩阵。\n\n**5. 预条件子构造**\n从内部矩阵 $A_{\\mathrm{int}}$ 构造两个对角预条件子：\n- **标准 Jacobi ($D_{\\mathrm{std}}$):** 对角元素与 $A_{\\mathrm{int}}$ 的对角线相同，即 $(D_{\\mathrm{std}})_{ii} = (A_{\\mathrm{int}})_{ii}$。该预条件子保留了刚度矩阵和质量矩阵贡献的对角部分。\n- **行和集中 Jacobi ($D_{\\mathrm{lump}}$):** 对角元素是 $A_{\\mathrm{int}}$ 的行和，即 $(D_{\\mathrm{lump}})_{ii} = \\sum_{j} (A_{\\mathrm{int}})_{ij}$。对于从 $\\mathcal{P}_1$ 单元导出的刚度矩阵 $K$，对应于任何内部节点的行和为零。因此，$A_{\\mathrm{int}} = K_{\\mathrm{int}} + \\alpha M_{\\mathrm{int}}$ 的行和简化为仅质量矩阵项的行和：$\\sum_{j} (A_{\\mathrm{int}})_{ij} = \\alpha \\sum_{j} (M_{\\mathrm{int}})_{ij}$。这种技术被称为质量集中（mass lumping）。\n\n**6. 谱等价常数的计算**\n谱等价常数 $c_{\\min}(D)$ 和 $c_{\\max}(D)$ 是 Rayleigh 商 $\\frac{\\mathbf{x}^\\top A_{\\mathrm{int}} \\mathbf{x}}{\\mathbf{x}^\\top D \\mathbf{x}}$ 的最小值和最大值。这些值等价于广义特征值问题 $A_{\\mathrm{int}}\\mathbf{x} = \\lambda D \\mathbf{x}$ 的极值特征值。一种数值稳健的计算方法，如题所述，是找到对称预处理矩阵 $S = D^{-1/2} A_{\\mathrm{int}} D^{-1/2}$ 的特征值。由于 $A_{\\mathrm{int}}$ 和 $D$ 是对称正定的，因此 $S$ 也是对称的，其特征值为实数且为正。$S$ 的最小和最大特征值直接得到 $c_{\\min}(D)$ 和 $c_{\\max}(D)$。这些特征值是使用针对对称矩阵的标准数值库例程计算的。对每个变换矩阵 $P_k$ 重复此整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigvalsh\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem, calculate spectral constants for all test cases,\n    and print the results in the specified format.\n    \"\"\"\n    \n    # Define the fixed parameters from the problem statement.\n    nx = 10\n    ny = 10\n    alpha = 1.0\n\n    # Define the test cases (shape matrices P) from the problem statement.\n    test_cases = [\n        np.array([[1.0, 0.0], [0.0, 1.0]]),\n        np.array([[1.0, 0.0], [0.5, 1.0]]),\n        np.array([[1.0, 0.0], [0.0, 0.25]]),\n        np.array([[1.0, 0.6], [0.3, 1.0]]),\n    ]\n\n    results = []\n    for P in test_cases:\n        # Calculate the four spectral constants for the current P matrix.\n        c_min_std, c_max_std, c_min_lump, c_max_lump = calculate_constants(P, nx, ny, alpha)\n        \n        # Append results for this case to the main list.\n        results.extend([c_min_std, c_max_std, c_min_lump, c_max_lump])\n\n    # Format the results to six decimal places and print in the required format.\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_constants(P, nx, ny, alpha):\n    \"\"\"\n    Performs FEM assembly and spectral analysis for a given transformation P.\n    \n    Args:\n        P (np.ndarray): The 2x2 linear transformation matrix.\n        nx (int): Number of subdivisions in the xi_1 direction.\n        ny (int): Number of subdivisions in the xi_2 direction.\n        alpha (float): The reaction coefficient.\n        \n    Returns:\n        tuple: A tuple containing the four computed spectral constants:\n               (c_min_std, c_max_std, c_min_lump, c_max_lump).\n    \"\"\"\n    \n    # 1. MESH GENERATION\n    num_nodes_x = nx + 1\n    num_nodes_y = ny + 1\n    num_nodes_total = num_nodes_x * num_nodes_y\n\n    # Generate nodes in the parametric domain [0,1]^2\n    xi_coords = np.linspace(0, 1, num_nodes_x)\n    eta_coords = np.linspace(0, 1, num_nodes_y)\n    xi_grid, eta_grid = np.meshgrid(xi_coords, eta_coords)\n    param_nodes = np.vstack([xi_grid.ravel(), eta_grid.ravel()]).T\n\n    # Map parametric nodes to physical nodes using matrix P\n    phys_nodes = param_nodes @ P.T\n\n    # Generate element connectivity (list of triangles)\n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            v_ll = i + j * num_nodes_x\n            v_lr = (i + 1) + j * num_nodes_x\n            v_ul = i + (j + 1) * num_nodes_x\n            v_ur = (i + 1) + (j + 1) * num_nodes_x\n            elements.append([v_ll, v_lr, v_ur])\n            elements.append([v_ll, v_ur, v_ul])\n\n    # 2. GLOBAL MATRIX ASSEMBLY\n    A = np.zeros((num_nodes_total, num_nodes_total))\n    for el_indices in elements:\n        p1, p2, p3 = phys_nodes[el_indices]\n        \n        area = 0.5 * abs(p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1]))\n        if area  1e-15:\n            continue\n        \n        # Element stiffness matrix (Ke)\n        b_coeffs = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n        c_coeffs = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n        Ke = (1.0 / (4.0 * area)) * (np.outer(b_coeffs, b_coeffs) + np.outer(c_coeffs, c_coeffs))\n\n        # Element mass matrix (Me)\n        Me = (area / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n        \n        Ae = Ke + alpha * Me\n        \n        ix = np.ix_(el_indices, el_indices)\n        A[ix] += Ae\n\n    # 3. APPLY BOUNDARY CONDITIONS\n    interior_indices = [i + j * num_nodes_x for j in range(1, ny) for i in range(1, nx)]\n    A_int = A[np.ix_(interior_indices, interior_indices)]\n\n    # 4. COMPUTE SPECTRAL CONSTANTS\n    \n    # Standard Jacobi Preconditioner\n    d_std = np.diag(A_int)\n    inv_sqrt_d_std = 1.0 / np.sqrt(d_std)\n    S_std = A_int * np.outer(inv_sqrt_d_std, inv_sqrt_d_std)\n    evals_std = eigvalsh(S_std)\n    c_min_std, c_max_std = np.min(evals_std), np.max(evals_std)\n\n    # Row-sum Lumped Jacobi Preconditioner\n    d_lump = A_int.sum(axis=1)\n    inv_sqrt_d_lump = 1.0 / np.sqrt(d_lump)\n    S_lump = A_int * np.outer(inv_sqrt_d_lump, inv_sqrt_d_lump)\n    evals_lump = eigvalsh(S_lump)\n    c_min_lump, c_max_lump = np.min(evals_lump), np.max(evals_lump)\n\n    return c_min_std, c_max_std, c_min_lump, c_max_lump\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3412341"}]}