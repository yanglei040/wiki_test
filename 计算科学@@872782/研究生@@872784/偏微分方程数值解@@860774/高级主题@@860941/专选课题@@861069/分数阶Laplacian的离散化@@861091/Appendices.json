{"hands_on_practices": [{"introduction": "在傅里叶空间中定义和离散化分数阶拉普拉斯算子 $(-\\Delta)^s$，尤其对于周期性函数，是最直接的方法。这个练习将引导你亲手实现这一定义，让你能够深入探索混叠误差这一基本概念，这是理解谱方法精髓的关键一步。通过将算子应用于简单的平面波并观察其在离散傅里叶变换下的行为，你将对谱方法的准确性和其局限性有更清晰的认识。[@problem_id:3381273]", "problem": "实现一个完整的程序，该程序在周期性域 $\\Omega = [0,2\\pi]^d$ 上构建分数阶拉普拉斯算子的伪谱傅里叶离散化，将其应用于在每个空间方向上具有 $N$ 个点的均匀网格上采样的复平面波 $u(\\boldsymbol{x}) = e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$，并量化作为 $\\boldsymbol{k}$、$s$ 和 $N$ 的函数的混叠误差。角度必须以弧度为单位。程序不得读取任何输入，并且必须仅按末尾描述的必需格式打印单行输出。\n\n在您的设计中使用的基本原理：\n- 环面上分数阶拉普拉斯算子的定义：$(-\\Delta)^s$ 的特征函数是傅里叶模式 $e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$，其中波矢量 $\\boldsymbol{k}\\in\\mathbb{Z}^d$ 为整数，特征值为 $|\\boldsymbol{k}|^{2s}$，$|\\boldsymbol{k}|$ 表示欧几里得范数。\n- 均匀网格上的离散傅里叶变换 (DFT)：在网格 $\\{ \\boldsymbol{x}_{\\boldsymbol{j}} = 2\\pi\\,\\boldsymbol{j}/N : \\boldsymbol{j}\\in\\{0,1,\\dots,N-1\\}^d \\}$ 上对周期性指数函数 $e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$进行采样，会产生一个离散谱。该谱支撑于对应于 $\\boldsymbol{k}$ 的频率仓，其中 $\\boldsymbol{k}$ 被模 $N$ 约简到主集 $\\{-\\lfloor N/2\\rfloor,\\dots,\\lceil N/2\\rceil-1\\}^d$ 中。当 $\\boldsymbol{k}$ 的任何分量位于该主集之外时，这种约简会导致混叠。\n\n您的程序必须：\n1. 对于每个测试用例，在 $\\Omega = [0,2\\pi]^d$ 上构建每个轴有 $N$ 个点的网格 $\\{ \\boldsymbol{x}_{\\boldsymbol{j}} \\}$。\n2. 在该网格上对 $u(\\boldsymbol{x}) = e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$进行采样。\n3. 应用伪谱分数阶拉普拉斯算子：计算样本的 $d$ 维DFT，将每个傅里叶系数乘以符号 $|\\boldsymbol{\\xi}|^{2s}$（其中 $\\boldsymbol{\\xi}$ 是与该DFT仓相关联的整数波矢量），然后进行逆DFT以获得网格函数。\n4. 通过将采样的 $u$ 乘以标量 $|\\boldsymbol{k}|^{2s}$，形成 $(-\\Delta)^s u$ 的精确网格函数。\n5. 将混叠误差量化为相对 $\\ell^\\infty$ 误差\n$$\nE_{\\infty}^{\\mathrm{rel}} = \\frac{\\max_{\\boldsymbol{j}} \\left| u_{\\mathrm{num}}(\\boldsymbol{x}_{\\boldsymbol{j}}) - u_{\\mathrm{exact}}(\\boldsymbol{x}_{\\boldsymbol{j}}) \\right|}{\\max_{\\boldsymbol{j}} \\left| u_{\\mathrm{exact}}(\\boldsymbol{x}_{\\boldsymbol{j}}) \\right|},\n$$\n并遵循约定：如果分母为 $0$，则定义 $E_{\\infty}^{\\mathrm{rel}}$ 为 $0$。\n\n测试套件：\n- 用例1（理想情况，一维无混叠）：$d=1$, $N=64$, $s=0.75$, $\\boldsymbol{k}=(10)$。\n- 用例2（一维奈奎斯特边界）：$d=1$, $N=64$, $s=1.0$, $\\boldsymbol{k}=(32)$。\n- 用例3（一维混叠）：$d=1$, $N=64$, $s=1.3$, $\\boldsymbol{k}=(50)$。\n- 用例4（二维无混叠）：$d=2$, $N=48$, $s=0.3$, $\\boldsymbol{k}=(10,22)$。\n- 用例5（二维混叠）：$d=2$, $N=32$, $s=0.8$, $\\boldsymbol{k}=(20,5)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含五个测试用例的结果，格式为方括号内以逗号分隔的浮点数列表，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是相应测试用例的相对 $\\ell^\\infty$ 误差 $E_{\\infty}^{\\mathrm{rel}}$。", "solution": "用户要求编写一个程序，用于计算作用于复平面波 $u(\\boldsymbol{x}) = e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$ 上的分数阶拉普拉斯算子 $(-\\Delta)^s$ 的伪谱近似误差。计算在周期性域 $\\Omega = [0, 2\\pi]^d$ 上进行。主要目标是量化由该数值离散化产生的混叠误差，该误差是算子幂次 $s$、波矢量 $\\boldsymbol{k}$ 和网格点数 $N$ 的函数。\n\n在 $d$ 维环面 $\\mathbb{T}^d$（等效于周期性域 $[0, 2\\pi]^d$）上的分数阶拉普拉斯算子 $(-\\Delta)^s$ 最方便通过其在傅里叶空间中的作用来定义。复指数函数 $e^{i\\,\\boldsymbol{m}\\cdot\\boldsymbol{x}}$（其中 $\\boldsymbol{m} \\in \\mathbb{Z}^d$ 是整数波矢量）是标准拉普拉斯算子 $-\\Delta$ 的特征函数，其对应的特征值为 $|\\boldsymbol{m}|^2 = \\sum_{l=1}^d m_l^2$。分数阶算子 $(-\\Delta)^s$ 共享这些特征函数，其特征值由 $|\\boldsymbol{m}|^{2s}$ 给出：\n$$\n(-\\Delta)^s e^{i\\,\\boldsymbol{m}\\cdot\\boldsymbol{x}} = |\\boldsymbol{m}|^{2s} e^{i\\,\\boldsymbol{m}\\cdot\\boldsymbol{x}}\n$$\n问题中给定的函数 $u(\\boldsymbol{x}) = e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$ 是该算子的一个特征函数。因此，应用 $(-\\Delta)^s$ 的精确结果是对原函数的简单缩放：\n$$\nu_{\\mathrm{exact}}(\\boldsymbol{x}) = (-\\Delta)^s u(\\boldsymbol{x}) = |\\boldsymbol{k}|^{2s} u(\\boldsymbol{x}) = |\\boldsymbol{k}|^{2s} e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}\n$$\n其中 $|\\boldsymbol{k}|$ 是指定波矢量 $\\boldsymbol{k}$ 的欧几里得范数。\n\n将要实现的数值过程是在均匀网格上使用伪谱法，我们概述如下。\n\n1.  **离散化**：将连续域 $\\Omega = [0, 2\\pi]^d$ 离散化为一个包含 $N^d$ 个点的均匀笛卡尔网格。网格点定义为\n    $$\n    \\boldsymbol{x}_{\\boldsymbol{j}} = \\frac{2\\pi}{N} \\boldsymbol{j}, \\quad \\text{for } \\boldsymbol{j} = (j_1, \\dots, j_d) \\in \\{0, 1, \\dots, N-1\\}^d\n    $$\n    在这些离散点上对连续函数 $u(\\boldsymbol{x})$ 进行采样，得到网格函数 $U_{\\boldsymbol{j}} = u(\\boldsymbol{x}_{\\boldsymbol{j}})$。当在该网格上求值时，精确解为 $U_{\\text{exact}, \\boldsymbol{j}} = |\\boldsymbol{k}|^{2s} U_{\\boldsymbol{j}}$。\n\n2.  **伪谱算子**：作用于网格函数 $U$ 的 $(-\\Delta)^s$ 的数值近似涉及傅里叶空间中的一系列操作：\n    a.  首先，对网格函数 $U$ 应用 $d$ 维离散傅里叶变换 (DFT)，得到一组傅里叶系数 $\\hat{U}_{\\boldsymbol{\\xi}}$：\n    $$\n    \\hat{U} = \\text{DFT}_d(U)\n    $$\n    b.  DFT的离散频率由属于主集 $K_N = \\{-\\lfloor N/2\\rfloor, \\dots, \\lceil N/2\\rceil-1\\}^d$ 的整数波矢量 $\\boldsymbol{\\xi}$ 表示。然后将每个傅里叶系数 $\\hat{U}_{\\boldsymbol{\\xi}}$ 乘以算子的符号，即 $|\\boldsymbol{\\xi}|^{2s}$。此步骤表示微分算子在傅里叶空间中的作用。\n    $$\n    \\hat{U}_{\\text{num}, \\boldsymbol{\\xi}} = |\\boldsymbol{\\xi}|^{2s} \\hat{U}_{\\boldsymbol{\\xi}}\n    $$\n    c.  最后，对修改后的系数应用 $d$ 维逆离散傅里叶变换 (IDFT)，将结果转换回物理网格，得到数值解 $U_{\\text{num}}$。\n    $$\n    U_{\\text{num}} = \\text{IDFT}_d(\\hat{U}_{\\text{num}})\n    $$\n\n3.  **混叠误差**：此问题的一个关键方面是混叠。当连续函数 $u(\\boldsymbol{x}) = e^{i\\,\\boldsymbol{k}\\cdot \\boldsymbol{x}}$ 在离散网格上采样时，它变得无法与任何其他平面波 $e^{i\\,\\boldsymbol{k}'\\cdot \\boldsymbol{x}}$ 区分开来，只要波矢量 $\\boldsymbol{k}'$ 满足对于所有网格点 $\\boldsymbol{x}_{\\boldsymbol{j}}$ 都有 $(\\boldsymbol{k} - \\boldsymbol{k}') \\cdot \\boldsymbol{x}_{\\boldsymbol{j}} \\in 2\\pi\\mathbb{Z}$。如果 $\\boldsymbol{k} - \\boldsymbol{k}'$ 的每个分量都是 $N$ 的整数倍，则此条件成立。DFT算法会隐式地将任何波矢量 $\\boldsymbol{k}$ 映射到其在 $K_N$ 中的唯一别名 $\\boldsymbol{k}_{\\text{alias}}$，使得对于每个分量 $l=1, \\dots, d$，都有 $k_l \\equiv (k_{\\text{alias}})_l \\pmod{N}$。\n\n    由于这种混叠，采样函数 $U$ 的DFT是位于对应于 $\\boldsymbol{k}_{\\text{alias}}$ 频率处的离散德尔塔函数。因此，数值方法应用的是特征值 $|\\boldsymbol{k}_{\\text{alias}}|^{2s}$，而不是正确的特征值 $|\\boldsymbol{k}|^{2s}$。因此，网格上的数值解为：\n    $$\n    U_{\\text{num}, \\boldsymbol{j}} = |\\boldsymbol{k}_{\\text{alias}}|^{2s} U_{\\boldsymbol{j}}\n    $$\n    这是该问题中伪谱法误差的根本来源。\n\n4.  **误差量化**：误差使用指定的相对 $\\ell^\\infty$ 范数进行量化：\n    $$\n    E_{\\infty}^{\\mathrm{rel}} = \\frac{\\max_{\\boldsymbol{j}} \\left| u_{\\mathrm{num}}(\\boldsymbol{x}_{\\boldsymbol{j}}) - u_{\\mathrm{exact}}(\\boldsymbol{x}_{\\boldsymbol{j}}) \\right|}{\\max_{\\boldsymbol{j}} \\left| u_{\\mathrm{exact}}(\\boldsymbol{x}_{\\boldsymbol{j}}) \\right|} = \\frac{\\max_{\\boldsymbol{j}} \\left| |\\boldsymbol{k}_{\\text{alias}}|^{2s} U_{\\boldsymbol{j}} - |\\boldsymbol{k}|^{2s} U_{\\boldsymbol{j}} \\right|}{\\max_{\\boldsymbol{j}} \\left| |\\boldsymbol{k}|^{2s} U_{\\boldsymbol{j}} \\right|}\n    $$\n    由于对所有 $\\boldsymbol{j}$ 都有 $|U_{\\boldsymbol{j}}| = |e^{i\\,\\boldsymbol{k}\\cdot\\boldsymbol{x}_{\\boldsymbol{j}}}| = 1$，表达式简化为：\n    $$\n    E_{\\infty}^{\\mathrm{rel}} = \\frac{\\left| |\\boldsymbol{k}_{\\text{alias}}|^{2s} - |\\boldsymbol{k}|^{2s} \\right|}{\\left| |\\boldsymbol{k}|^{2s} \\right|} = \\left| \\left(\\frac{|\\boldsymbol{k}_{\\text{alias}}|}{|\\boldsymbol{k}|}\\right)^{2s} - 1 \\right|\n    $$\n    如果波矢量 $\\boldsymbol{k}$ 完全位于主频率集 $K_N$ 内，则不会发生混叠，$\\boldsymbol{k}_{\\text{alias}} = \\boldsymbol{k}$，误差为 $0$（在机器精度范围内）。如果 $\\boldsymbol{k}$ 的任何分量超出此范围，则会发生混叠，导致 $\\boldsymbol{k}_{\\text{alias}} \\neq \\boldsymbol{k}$ 和非零误差（前提是 $s \\neq 0$）。值得注意的是，对于位于奈奎斯特频率的分量（例如，对于偶数 $N$，$k_l=N/2$），其别名为 $(k_{\\text{alias}})_l=-N/2$，因此 $|k_l| = |(k_{\\text{alias}})_l|$。如果所有分量要么没有混叠，要么处于奈奎斯特频率，则范数保持不变，即 $|\\boldsymbol{k}_{\\text{alias}}| = |\\boldsymbol{k}|$，误差仍为 $0$。\n\n下面的程序实现了这整个过程，通过遍历提供的测试用例来计算每个用例的混叠误差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs a pseudo-spectral Fourier discretization of the fractional Laplacian,\n    applies it to a complex plane wave, and quantifies the aliasing error.\n    \"\"\"\n    test_cases = [\n        # Case 1: d=1, N=64, s=0.75, k=(10) -> No aliasing\n        {'d': 1, 'N': 64, 's': 0.75, 'k_vec': np.array([10], dtype=float)},\n        # Case 2: d=1, N=64, s=1.0, k=(32) -> Nyquist boundary\n        {'d': 1, 'N': 64, 's': 1.0, 'k_vec': np.array([32], dtype=float)},\n        # Case 3: d=1, N=64, s=1.3, k=(50) -> Aliasing\n        {'d': 1, 'N': 64, 's': 1.3, 'k_vec': np.array([50], dtype=float)},\n        # Case 4: d=2, N=48, s=0.3, k=(10, 22) -> No aliasing\n        {'d': 2, 'N': 48, 's': 0.3, 'k_vec': np.array([10, 22], dtype=float)},\n        # Case 5: d=2, N=32, s=0.8, k=(20, 5) -> Aliasing\n        {'d': 2, 'N': 32, 's': 0.8, 'k_vec': np.array([20, 5], dtype=float)},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        d = case['d']\n        N = case['N']\n        s = case['s']\n        k_vec = case['k_vec']\n\n        # 1. Construct the grid\n        grid_1d_coords = np.arange(N) * (2 * np.pi / N)\n        # Create a list of 1D coordinate arrays for meshgrid\n        coords = [grid_1d_coords] * d\n        # `indexing='ij'` ensures meshgrid output matches matrix indexing\n        grid_coords = np.meshgrid(*coords, indexing='ij')\n\n        # 2. Sample u(x) = exp(i * k.x) on the grid\n        k_dot_x = np.zeros([N] * d)\n        for i in range(d):\n            k_dot_x += k_vec[i] * grid_coords[i]\n        u_grid = np.exp(1j * k_dot_x)\n\n        # 3. Apply the pseudo-spectral fractional Laplacian\n        # a) Compute d-dimensional DFT\n        u_hat = np.fft.fftn(u_grid)\n\n        # b) Construct the grid of Fourier wavevectors (xi)\n        freq_1d = np.fft.fftfreq(N) * N\n        freq_coords = [freq_1d] * d\n        xi_coords = np.meshgrid(*freq_coords, indexing='ij')\n\n        # c) Compute the symbol |xi|^(2s)\n        xi_norm_sq = np.zeros([N] * d)\n        for i in range(d):\n            xi_norm_sq += xi_coords[i]**2\n        \n        # Avoid taking sqrt of 0 and then raising to a power, use properties of exponents.\n        # symbol = |xi|^(2s) = (|xi|^2)^s\n        # Handle the case where xi is the zero vector, symbol should be 0.\n        symbol = np.power(xi_norm_sq, s, where=(xi_norm_sq > 0), out=np.zeros_like(xi_norm_sq))\n\n        # d) Multiply Fourier coefficients by the symbol\n        u_num_hat = symbol * u_hat\n\n        # e) Invert the DFT\n        u_num_grid = np.fft.ifftn(u_num_hat)\n\n        # 4. Form the exact grid function for (-Delta)^s u\n        k_norm = np.linalg.norm(k_vec)\n        \n        # The eigenvalue is 0 if k_vec is the zero vector.\n        if k_norm == 0:\n            exact_eigenvalue = 0.0\n        else:\n            exact_eigenvalue = k_norm**(2 * s)\n            \n        u_exact_grid = exact_eigenvalue * u_grid\n        \n        # 5. Quantify the aliasing error\n        numerator = np.max(np.abs(u_num_grid - u_exact_grid))\n        denominator = np.max(np.abs(u_exact_grid))\n\n        # As per problem, if denominator is 0, error is 0.\n        # This happens if k_vec=0, where exact_eigenvalue=0.\n        if np.isclose(denominator, 0.0):\n            error = 0.0\n        else:\n            error = numerator / denominator\n            \n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3381273"}, {"introduction": "从周期性问题过渡到更常见的带狄利克雷（Dirichlet）边界条件的有界域问题，需要使用不同的工具集，即正弦基函数和离散正弦变换（DST）。本练习旨在让你比较两种相关但有细微差异的离散化策略，更重要的是，它引入了收敛性分析。通过估计误差随网格尺寸 $h$ 减小而降低的速率，你将实践验证数值方法有效性的基本技能。[@problem_id:3381295]", "problem": "考虑在具有齐次狄利克雷边界条件的 $d$ 维开放单位超立方体 $\\Omega=(0,1)^d$ 上的谱分数阶拉普拉斯算子，记为 $(-\\Delta)^s$。狄利克雷拉普拉斯算子分数次幂的谱定义源于标准狄利克雷拉普拉斯算子的标准正交特征基。设 $u:\\Omega\\to\\mathbb{R}$ 是平方可积的，并假设 $u$ 可展开为正弦特征函数。$(-\\Delta)^s$ 的作用定义为在该展开式中将相应的狄利克雷拉普拉斯算子特征值提升至 $s$ 次幂。\n\n您的任务是设计并实现作用于 $u$ 在 $\\Omega=(0,1)^d$ 内部网格上的格点样本的 $(-\\Delta)^s$ 的两种相容离散化方法。两种离散化方法都必须仅依赖于基本定义和经过充分检验的数值事实，从狄利克雷拉普拉斯算子的谱定义出发，并利用内部网格上的正交正弦基。\n\n离散化方法 A（基于连续谱）：\n- 使用内部网格上的标准正交正弦基，通过离散正弦变换（DST）将 $u$ 映射为正弦系数。\n- 通过将每个正弦系数乘以提升至 $s$ 次幂的相应连续狄利克雷拉普拉斯算子特征值来应用分数阶算子，然后进行逆变换以返回物理空间。\n- 该离散化方法由连续狄利克雷特征对构造，并且根据其构造方式与谱定义相容。\n\n离散化方法 B（有限差分谱矩阵幂）：\n- 在内部网格上使用相同的正弦基；但是，不使用连续特征值，而是使用内部网格上标准中心差分狄利克雷离散拉普拉斯矩阵的特征值。\n- 在正弦基中将这些离散特征值提升至 $s$ 次幂来应用分数阶算子，然后进行逆变换。\n\n基准测试套件设置：\n- 使用测试函数 $u(x)=\\prod_{j=1}^d \\sin(\\pi x_j)$，它是 $(0,1)^d$ 上狄利克雷拉普拉斯算子的单个正弦特征函数。\n- 根据谱定义和 $(0,1)^d$ 上狄利克雷拉普拉斯算子特征对的特性，推导出 $(-\\Delta)^s$ 作用于 $u$ 的精确结果。使用此精确结果作为参考解，以计算两种离散化方法在内部网格上的误差。\n- 对于每个测试用例，构建一个每个坐标方向有 $N$ 个点的内部均匀网格。内部网格节点为 $x_i=i/(N+1)$，其中在每个维度上 $i=1,\\dots,N$，网格间距为 $h=1/(N+1)$。\n- 计算离散化方法 A 的误差，其定义为在最精细网格上其输出与精确参考解之间的最大绝对逐点差。\n- 对于离散化方法 B，计算三种网格尺寸下的相对 $\\ell^2$ 误差 $\\|e\\|_2/\\|f\\|_2$，其中 $e$ 是离散输出与网格上精确参考解之差，$f$ 是精确参考解。根据这三个误差及其相关的网格间距，通过对 $\\log_{10}(\\text{误差})$ 与 $\\log_{10}(h)$ 进行最小二乘拟合来估计观测到的收敛阶。\n- 离散正弦变换（DST）指的是在遵循 $(0,1)^d$ 上狄利克雷边界条件的网格上，基于快速傅里叶变换（FFT）的正弦展开的标准正交实现。\n\n测试套件：\n- 维度 $d\\in\\{1,2\\}$。\n- 分数阶 $s\\in\\{0.25,0.5,0.75\\}$。\n- 对于每对 $(d,s)$，使用内部网格尺寸 $N\\in\\{15,31,63\\}$ 来计算误差并估计离散化方法 B 的观测收敛率。同时计算离散化方法 A 在最精细网格 $N=63$ 上的最大绝对误差。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。该列表必须按顺序包含：\n    1. 首先，对于每个 $(d,s)$ 对（其中 $d$ 递增，在每个 $d$ 内，$s$ 按升序排列），离散化方法 B 的观测收敛率，四舍五入到三位小数。共有六个这样的收敛率（两个维度乘以三个分数阶）。\n    2. 然后，按相同的 $(d,s)$ 顺序，离散化方法 A 在 $N=63$ 时的最大绝对逐点误差，四舍五入到十二位小数。共有六个这样的误差。\n- 为清晰起见，输出因此将包含十二个浮点数。不涉及单位。不涉及角度，也不使用百分比；所有值都是无单位的纯实数。\n- 输出格式示例（使用占位符数字）：“[r11,r12,r13,r21,r22,r23,e11,e12,e13,e21,e22,e23]”，其中 $r_{ij}$ 表示维度 $i$ 和分数阶索引 $j$ 的收敛率，$e_{ij}$ 表示在最精细网格上对应的离散化方法 A 的误差。\n\n您的实现必须是一个完整、可运行的程序，能够执行所述计算，无需任何外部输入或文件，并打印出所要求的单行输出。", "solution": "问题陈述经评估有效。它在科学上基于偏微分方程和数值分析理论，特别是关于分数阶拉普拉斯算子的谱定义和数值近似。该问题是适定的，提供了明确的目标、一套完整的定义、一个具体的测试用例以及一组精确定义的所需输出和误差度量。所有术语都得到了正式定义并被一致地使用，且该任务在计算上是可行的。\n\n问题的核心是在域 $\\Omega=(0,1)^d$ 上离散化谱分数阶拉普拉斯算子 $(-\\Delta)^s$。该算子通过标准狄利克雷拉普拉斯算子 $-\\Delta$ 的谱分解来定义。\n\n首先，我们建立分析基础。在具有齐次狄利克雷边界条件的 $\\Omega=(0,1)^d$ 上，$-\\Delta$ 的特征函数和特征值由下式给出\n$$ \\phi_{\\mathbf{k}}(x) = \\prod_{j=1}^{d} \\sqrt{2} \\sin(k_j \\pi x_j), \\quad \\lambda_{\\mathbf{k}} = \\sum_{j=1}^{d} (k_j \\pi)^2 = \\pi^2 \\|\\mathbf{k}\\|_2^2 $$\n其中 $\\mathbf{k} = (k_1, \\dots, k_d) \\in (\\mathbb{Z}^+)^d$ 是一个正整数多重索引。根据谱定义，$(-\\Delta)^s$ 作用于一个特征函数的结果是 $(-\\Delta)^s \\phi_{\\mathbf{k}} = (\\lambda_{\\mathbf{k}})^s \\phi_{\\mathbf{k}}$。\n\n指定的测试函数是 $u(x) = \\prod_{j=1}^d \\sin(\\pi x_j)$。该函数与对应于多重索引 $\\mathbf{k}=(1,\\dots,1)$ 的第一个特征函数 $\\phi_{(1,\\dots,1)}(x)$ 成正比。相关的特征值为 $\\lambda_{(1,\\dots,1)} = \\sum_{j=1}^d (1 \\cdot \\pi)^2 = d\\pi^2$。\n因此，分数阶算子作用于 $u$ 的精确结果是一个简单的缩放：\n$$ f(x) = (-\\Delta)^s u(x) = (\\lambda_{(1,\\dots,1)})^s u(x) = (d\\pi^2)^s \\prod_{j=1}^d \\sin(\\pi x_j) $$\n这个函数 $f(x)$ 作为精确的参考解。我们在网格点上对其求值，以获得用于误差计算的参考网格函数 $f_{grid}$。\n\n问题要求在每个 $d$ 维度上有 $N$ 个点的均匀内部网格上进行离散化。网格点为 $\\mathbf{x}_{\\mathbf{i}} = (i_1 h, \\dots, i_d h)$，其中多重索引 $\\mathbf{i}=(i_1, \\dots, i_d)$ 满足 $i_j \\in \\{1,\\dots,N\\}$。网格间距为 $h = 1/(N+1)$。\n\n两种提议的离散化方法都利用了离散正弦变换（DST）。标准正交的I型DST对应于向离散正弦函数 $\\psi_{\\mathbf{k}}(\\mathbf{i}) \\propto \\prod_{j=1}^d \\sin(\\pi k_j i_j / (N+1))$ 的基变换，这些函数是内部网格上标准中心差分离散拉普拉斯算子的精确特征向量。因此，DST可对角化离散算子，使其成为连续正弦级数展开的数值模拟。我们使用 `scipy.fft` 库的 `dstn` 和 `idstn` 函数，并设置 `type=1` 和 `norm='ortho'`。\n\n离散化方法 A（基于连续谱）：\n此方法通过在离散基中应用连续谱来近似 $(-\\Delta)^s u$。算法如下：\n1.  通过在网格节点上对 $u(x)$ 求值来计算网格函数 $u_{grid}$。\n2.  计算 $u_{grid}$ 的 $d$ 维DST以获得系数 $\\hat{u}_{\\mathbf{k}}$。\n3.  构建一个 $d$ 维连续特征值网格，其中索引 $\\mathbf{k}$ 处的条目是 $(\\lambda_{\\mathbf{k}})^s = (\\pi^2 \\|\\mathbf{k}\\|_2^2)^s$，对于模式 $\\mathbf{k}=(k_1,\\dots,k_d)$，有 $k_j \\in \\{1,\\dots,N\\}$。\n4.  将系数乘以相应的谱乘子：$\\hat{f}_{A,\\mathbf{k}} = (\\lambda_{\\mathbf{k}})^s \\hat{u}_{\\mathbf{k}}$。\n5.  计算 $\\hat{f}_{A,\\mathbf{k}}$ 的逆DST以获得数值解 $f_{A,grid}$。\n对于给定的测试函数 $u(x)$，网格样本 $u_{grid}$ 精确地与第一个离散正弦基向量 $\\psi_{(1,\\dots,1)}$ 成正比。这意味着其DST变换 $\\hat{u}_{\\mathbf{k}}$ 是一个离散的狄拉克δ函数。由于该模式也是连续算子的一个特征函数，并且该方法对此模式使用了精确的连续特征值，因此得到的近似解 $f_{A,grid}$ 预计将与精确解 $f_{grid}$ 在机器精度范围内相同。因此，最大绝对误差 $\\max |f_{A,grid} - f_{grid}|$ 应接近于零。\n\n离散化方法 B（有限差分谱矩阵幂）：\n此方法使用离散拉普拉斯矩阵本身的光谱。算法如下：\n1.  计算 $u_{grid}$ 的DST以获得系数 $\\hat{u}_{\\mathbf{k}}$。\n2.  $d$ 维中心差分离散拉普拉斯算子的特征值为 $\\mu_{\\mathbf{k}} = \\sum_{j=1}^d \\mu_{k_j}$，其中一维特征值为 $\\mu_{k_j} = \\frac{4}{h^2}\\sin^2(\\frac{k_j \\pi h}{2})$。\n3.  构建这些离散特征值的网格，并计算谱乘子 $(\\mu_{\\mathbf{k}})^s$。\n4.  将系数相乘：$\\hat{f}_{B,\\mathbf{k}} = (\\mu_{\\mathbf{k}})^s \\hat{u}_{\\mathbf{k}}$。\n5.  计算逆DST以获得数值解 $f_{B,grid}$。\n此方法的误差来源于用离散特征值 $\\mu_{\\mathbf{k}}$ 近似连续特征值 $\\lambda_{\\mathbf{k}}$。对于小的 $h$，泰勒级数展开表明 $\\mu_k = (k\\pi)^2 - \\frac{(k\\pi)^4}{12}h^2 + O(h^4) = \\lambda_k(1 - \\frac{(k\\pi)^2}{12}h^2 + O(h^4))$。特征值的误差为 $O(h^2)$ 阶。因此，最终解的相对误差 $\\|f_{B,grid}-f_{grid}\\|_2/\\|f_{grid}\\|_2$ 也应为 $O(h^2)$ 阶。通过对 $\\log_{10}(\\text{误差})$ 与 $\\log_{10}(h)$ 进行最小二乘拟合估计出的收敛阶应约等于 $2$。\n\n实现将遍历指定的维度 $d$ 和分数阶 $s$。对于每一对，它将计算最精细网格（$N=63$）上离散化方法 A 的误差，以及三种网格尺寸（$N=15, 31, 63$）下离散化方法 B 的误差。后者用于计算离散化方法 B 的观测收敛率。最终结果被收集并按规定格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import dstn, idstn\n\ndef solve():\n    \"\"\"\n    Computes errors and convergence rates for two discretizations\n    of the fractional Laplacian.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases_ds = [(d, s) for d in [1, 2] for s in [0.25, 0.5, 0.75]]\n    Ns = [15, 31, 63]\n\n    rates_B = []\n    errors_A_final = []\n\n    for d, s in test_cases_ds:\n        errors_B_case = []\n        hs_B_case = []\n\n        for N in Ns:\n            # Grid setup\n            h = 1.0 / (N + 1)\n            \n            # Create a list of 1D axes for grid creation\n            axes = [np.arange(1, N + 1)] * d\n            # Create indexing grids for coordinates and modes\n            # `ij` indexing aligns with scipy.fft output for separable transforms\n            indices = np.meshgrid(*axes, indexing='ij')\n\n            # Physical grid coordinates\n            grid_coords = [idx * h for idx in indices]\n\n            # Evaluate test function u(x) on the grid\n            sin_parts_u = [np.sin(np.pi * coord) for coord in grid_coords]\n            u_grid = np.prod(sin_parts_u, axis=0)\n\n            # Evaluate exact solution f(x) on the grid\n            # The continuous eigenvalue for u(x) is d * pi^2\n            lambda_u_continuous = d * np.pi**2\n            f_grid = (lambda_u_continuous**s) * u_grid\n\n            # Perform DST on the grid function\n            # Use Type-I orthonormal DST, which corresponds to the sine expansion\n            # for homogeneous Dirichlet boundary conditions.\n            u_hat = dstn(u_grid, type=1, norm='ortho')\n\n            # --- Discretization B (Finite-difference spectral matrix power) ---\n            \n            # Grid of eigenvalues for discrete Laplacian\n            # Mode indices `k` are captured by `indices`\n            sin_sq_parts_mu = [np.sin(k * np.pi * h / 2.0)**2 for k in indices]\n            sum_sin_sq = np.sum(sin_sq_parts_mu, axis=0)\n            mu_discrete_grid = (4.0 / h**2) * sum_sin_sq\n            \n            # Apply fractional operator in spectral domain\n            f_B_hat = u_hat * (mu_discrete_grid**s)\n            \n            # Inverse DST to return to physical space\n            f_B_grid = idstn(f_B_hat, type=1, norm='ortho')\n            \n            # Compute relative l2 error for Discretization B\n            error_vec_B = f_B_grid - f_grid\n            norm_e = np.linalg.norm(error_vec_B)\n            norm_f = np.linalg.norm(f_grid)\n            \n            relative_l2_error_B = norm_e / norm_f if norm_f > 0 else 0.0\n            \n            errors_B_case.append(relative_l2_error_B)\n            hs_B_case.append(h)\n            \n            # --- Discretization A (Continuous-spectrum-based, only for finest grid) ---\n            if N == Ns[-1]:\n                # Grid of eigenvalues for continuous Laplacian\n                sq_k_parts = [k**2 for k in indices]\n                sum_sq_k = np.sum(sq_k_parts, axis=0)\n                lambda_continuous_grid = np.pi**2 * sum_sq_k\n                \n                # Apply fractional operator\n                f_A_hat = u_hat * (lambda_continuous_grid**s)\n                \n                # Inverse DST\n                f_A_grid = idstn(f_A_hat, type=1, norm='ortho')\n                \n                # Compute maximum absolute error for Discretization A\n                max_abs_error_A = np.max(np.abs(f_A_grid - f_grid))\n                errors_A_final.append(max_abs_error_A)\n\n        # After looping through N, compute convergence rate for B\n        log_h = np.log10(np.array(hs_B_case))\n        log_err = np.log10(np.array(errors_B_case))\n        \n        # Fit a line to log(error) vs log(h) to find the slope (rate)\n        # polyfit returns [slope, intercept]\n        rate_B, _ = np.polyfit(log_h, log_err, 1)\n        rates_B.append(rate_B)\n\n    # Format the results for the final output string\n    # Rates are rounded to 3 decimal places\n    # Errors are rounded to 12 decimal places\n    formatted_rates_B = [f\"{r:.3f}\" for r in rates_B]\n    formatted_errors_A = [f\"{e:.12f}\" for e in errors_A_final]\n    \n    # Combine the lists in the specified order: rates first, then errors\n    all_results = formatted_rates_B + formatted_errors_A\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3381295"}, {"introduction": "掌握了如何离散化算子之后，下一个实际问题是如何高效地求解由此产生的线性系统，例如 $A^s u = f$。这个练习将处理分数阶问题中一个关键的挑战：算子离散后产生的矩阵通常是病态的。通过探索使用标准拉普拉斯算子作为预条件子，并通过经验性地测量条件数随网格尺寸的变化规律，你将深入理解如何提高大规模分数阶偏微分方程迭代求解器的效率。[@problem_id:3381280]", "problem": "要求您研究在一维空间单位区间上，对带有齐次狄利克雷边界条件的分数阶拉普拉斯算子，使用局部拉普拉斯算子作为预条件子的有效性。工作应完全在纯数学和算法的环境中进行，不涉及物理单位。当需要时，所有角度都必须视为三角函数的无量纲参数。任务是设计并实现一个程序，为两种离散化族构建离散算子，并根据网格尺寸和分数阶数，凭经验估计预处理后系统的条件数的增长率。\n\n从以下基础定义和事实出发。\n\n1. 对于一个对称正定矩阵算子 $A$，其谱分数阶幂 $A^{s}$（其中 $s \\in \\mathbb{R}$）通过其谱分解定义：如果 $A \\varphi_{i} = \\lambda_{i} \\varphi_{i}$，其中 $\\{\\varphi_{i}\\}$ 是标准正交特征向量，$\\{\\lambda_{i}\\} \\subset (0,\\infty)$ 是特征值，则 $A^{s} \\varphi_{i} = \\lambda_{i}^{s} \\varphi_{i}$，并线性扩展。\n\n2. 对称正定矩阵 $B$ 关于欧几里得范数的条件数是 $\\kappa(B) = \\lambda_{\\max}(B)/\\lambda_{\\min}(B)$，其中 $\\lambda_{\\max}(B)$ 和 $\\lambda_{\\min}(B)$ 分别是 $B$ 的最大和最小特征值。\n\n3. 考虑在 $x=0$ 和 $x=1$ 处带有齐次狄利克雷边界条件的一维区间 $(0,1)$。拉普拉斯算子的两种标准离散化方法是：\n   - 使用标准三点差分格式在间距为 $h$ 的均匀内部点网格上的有限差分法。\n   - 使用连续分段线性基函数在元素大小为 $h$ 的均匀网格上的有限元法，其组装后的刚度矩阵为 $K$，质量矩阵为 $M$。\n\n4. 对于有限差分离散化，令 $A$ 表示对称正定离散拉普拉斯矩阵。对于有限元离散化，考虑广义特征值问题 $K \\phi_{i} = \\lambda_{i} M \\phi_{i}$，其中 $K$ 是刚度矩阵，$M$ 是质量矩阵。\n\n您的任务如下。\n\nA. 对于有限差分离散化：\n   - 在 $n$ 个内部网格点上，使用标准三点差分格式构建在 $(0,1)$ 上带有齐次狄利克雷边界条件的离散拉普拉斯算子 $A$，网格间距为 $h = 1/(n+1)$。\n   - 对 $s \\in (0,1]$，通过谱方法定义分数阶算子 $A^{s}$。\n   - 考虑用 $A$ 对线性系统 $A^{s} u = f$ 进行预处理，形成预处理算子 $A^{-1} A^{s}$。\n   - 理论尺度分析预测，当 $h \\to 0$ 时，$\\kappa(A^{-1} A^{s})$ 会渐近地以 $h^{-p(s)}$ 的形式增长，其中指数 $p(s)$ 依赖于 $s$。\n   - 实现一个程序，对于固定的 $s$，计算多个 $n$ 值（以及对应的 $h$ 值）下的 $\\kappa(A^{-1} A^{s})$，并通过对 $\\log \\kappa$ 与 $\\log h$ 进行最小二乘线性拟合来估计指数 $p(s)$。\n\nB. 对于有限元离散化：\n   - 为覆盖 $(0,1)$ 且在端点处具有齐次狄利克雷边界条件的 $N_{e}$ 个单元的均匀网格，组装连续分段线性有限元的刚度矩阵 $K$ 和质量矩阵 $M$。内部自由度的数量为 $N = N_{e} - 1$，网格尺寸为 $h = 1/N_{e}$。\n   - 考虑满足 $K \\phi_{i} = \\lambda_{i} M \\phi_{i}$ 且 $\\lambda_{i} > 0$ 的广义特征对 $(\\lambda_{i}, \\phi_{i})$。\n   - 通过广义特征对定义离散谱分数阶算子 $K^{s}$，并考虑用 $K$ 对线性系统 $K^{s} u = f$（在一致的离散意义上解释）进行预处理，形成算子 $K^{-1} K^{s}$。\n   - 实现一个程序，对于固定的 $s$，计算多个 $N_{e}$ 值（以及对应的 $h$ 值）下确定 $\\kappa(K^{-1} K^{s})$ 所需的广义极端特征值，并通过对 $\\log \\kappa$ 与 $\\log h$ 进行最小二乘线性拟合来估计指数 $p(s)$。\n\nC. 对于A和B部分中的两种离散化方法，以及对于 $s \\in \\{0.25, 0.5, 0.75, 1.0\\}$ 中的每个值，从三个网格尺寸估计增长指数 $p(s)$。网格尺寸必须是：\n   - 对于有限差分法，使用 $n \\in \\{63, 127, 255\\}$ 个内部点，其中 $h = 1/(n+1)$。\n   - 对于有限元法，使用 $N_{e} \\in \\{64, 128, 256\\}$ 个单元，其中 $h = 1/N_{e}$。\n\nD. 待测试的理论预期：在一维情况下，对于均匀网格和标准的协调构造，局部拉普拉斯离散化的特征值按 $h^{-2}$ 的比例缩放。利用这一事实和分数阶幂的谱定义，当用 $(-\\Delta)$ 对 $(-\\Delta)^{s}$ 进行预处理时，两种离散化方法的理论预测指数均为 $p_{\\mathrm{th}}(s) = 2 (1 - s)$。\n\nE. 实现一个程序，执行上述过程，并对以下八个测试用例中的每一个，返回经验估计的指数 $p_{\\mathrm{est}}(s)$ 是否在 $\\pm 0.3$ 的容差范围内与理论指数 $p_{\\mathrm{th}}(s)$ 相匹配：\n   - 有限差分法，$s = 0.25$。\n   - 有限差分法，$s = 0.5$。\n   - 有限差分法，$s = 0.75$。\n   - 有限差分法，$s = 1.0$。\n   - 有限元法，$s = 0.25$。\n   - 有限元法，$s = 0.5$。\n   - 有限元法，$s = 0.75$。\n   - 有限元法，$s = 1.0$。\n\n您的程序应生成单行输出，其中包含这八个案例的结果，形式为一个用方括号括起来的逗号分隔的布尔值列表（例如，“[True,False,True,True,False,True,True,True]”）。列表中结果的顺序必须与上面列出的完全一致。程序不应读取任何输入，也不涉及任何单位。三角函数中使用的角度应解释为无量纲量。所有计算必须仅基于此处指定的定义和过程即可复现。", "solution": "该问题要求对一个预处理后的分数阶拉普拉斯系统的谱特性进行经验性研究。具体来说，我们需要估计系统 $(-\\Delta)^{-1}(-\\Delta)^s$ 的条件数随网格尺寸 $h$ 变化的增长率，其中 $(-\\Delta)$ 是在区间 $(0,1)$ 上带有齐次狄利克雷边界条件的标准一维拉普拉斯算子。我们将分析两种常见的离散化方案：有限差分法 (FDM) 和有限元法 (FEM)。\n\n分析的核心在于分数阶矩阵幂的谱定义。对于一个具有特征值 $\\lambda_i$ 和相应特征向量 $\\varphi_i$ 的对称正定 (SPD) 矩阵算子 $A$，算子 $A^s$ 通过其在相同特征向量上的作用来定义：$A^s \\varphi_i = \\lambda_i^s \\varphi_i$。预条件子是非分数阶算子 $A$ 本身。因此，预处理后的算子是 $P = A^{-1}A^s$。由于 $A^{-1}$ 和 $A^s$ 都是 $A$ 的函数，它们可以交换，并共享相同的特征向量 $\\varphi_i$。因此，预处理算子 $P$ 的特征值为 $\\mu_i = \\lambda_i^{-1} \\lambda_i^s = \\lambda_i^{s-1}$。\n\n对称正定矩阵 $B$ 的条件数是 $\\kappa(B) = \\lambda_{\\max}(B)/\\lambda_{\\min}(B)$。对于我们的预处理算子 $P$，我们必须确定其极端特征值。分数阶 $s$ 在范围 $(0,1]$ 内，因此指数 $s-1$ 在 $(-1,0]$ 内。这意味着，如果 $\\lambda_i$ 是 $A$ 的按升序排列的特征值，$\\lambda_{\\min}(A) \\le \\lambda_i \\le \\lambda_{\\max}(A)$，那么 $P$ 的特征值 $\\mu_i = \\lambda_i^{s-1}$ 将会是逆序的：$\\mu_{\\max}(P) = (\\lambda_{\\min}(A))^{s-1}$ 且 $\\mu_{\\min}(P) = (\\lambda_{\\max}(A))^{s-1}$。预处理后系统的条件数是：\n$$\n\\kappa(P) = \\frac{\\mu_{\\max}(P)}{\\mu_{\\min}(P)} = \\frac{(\\lambda_{\\min}(A))^{s-1}}{(\\lambda_{\\max}(A))^{s-1}} = \\left(\\frac{\\lambda_{\\min}(A)}{\\lambda_{\\max}(A)}\\right)^{s-1} = \\left(\\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}\\right)^{1-s}\n$$\n问题指出，对于一维拉普拉斯算子的标准离散化，当网格尺寸 $h \\to 0$ 时，其特征值缩放为 $\\lambda_{\\min}(A) \\approx C_1$（一个常数）和 $\\lambda_{\\max}(A) \\approx C_2 h^{-2}$。将此代入条件数的表达式中，可得到预期的渐近行为：\n$$\n\\kappa(P) \\approx \\left(\\frac{C_2 h^{-2}}{C_1}\\right)^{1-s} \\propto (h^{-2})^{1-s} = h^{-2(1-s)}\n$$\n对两边取对数，得到一个线性关系：$\\log(\\kappa) = -2(1-s)\\log(h) + \\text{const}$。因此，理论增长指数为 $p_{\\mathrm{th}}(s) = 2(1-s)$。我们的任务是对于几个 $s$ 值以及 FDM 和 FEM 两种离散化方法，数值地估计这个指数 $p(s)$。\n\n数值估计过程如下：对于给定的离散化方法和固定的 $s$ 值，我们计算三个指定网格尺寸 $h$ 下的条件数 $\\kappa$。这给了我们三个数据点 $(\\log(h_i), \\log(\\kappa_i))$。然后我们对这些点进行线性最小二乘拟合，找到最佳拟合直线 $\\log(\\kappa) = m \\log(h) + c$ 的斜率 $m$。估计的指数为 $p_{\\mathrm{est}}(s) = -m$。\n\n**A部分：有限差分法 (FDM)**\n对于FDM，我们在具有 $n$ 个内部点的均匀网格上离散化算子 $-d^2/dx^2$。网格间距为 $h = 1/(n+1)$。标准三点中心差分格式导出 $n \\times n$ 对称三对角矩阵：\n$$\nA = \\frac{1}{h^2}\n\\begin{pmatrix}\n2 & -1 & & \\mathbf{0} \\\\\n-1 & 2 & -1 & \\\\\n& \\ddots & \\ddots & \\ddots \\\\\n& & -1 & 2 & -1 \\\\\n\\mathbf{0} & & & -1 & 2\n\\end{pmatrix}\n$$\n对于每个 $n \\in \\{63, 127, 255\\}$，我们构造此矩阵 $A$，计算其最小和最大特征值 $\\lambda_{\\min}(A)$ 和 $\\lambda_{\\max}(A)$，计算 $\\kappa = (\\lambda_{\\max}(A)/\\lambda_{\\min}(A))^{1-s}$，并记录点 $(\\log(h), \\log(\\kappa))$。对这三点进行线性拟合，即可得到 $p_{\\mathrm{est}}(s)$。\n\n**B部分：有限元法 (FEM)**\n对于FEM，我们在包含 $N_e$ 个单元的均匀网格上使用连续分段线性基函数。这产生 $N = N_e - 1$ 个内部自由度。网格尺寸为 $h = 1/N_e$。该离散化导出一个广义特征值问题 $K\\phi = \\lambda M\\phi$，其中 $K$ 是刚度矩阵，$M$ 是质量矩阵。这些 $N \\times N$ 矩阵是：\n$$\nK = \\frac{1}{h}\n\\begin{pmatrix}\n2 & -1 & & \\mathbf{0} \\\\\n-1 & 2 & -1 & \\\\\n& \\ddots & \\ddots & \\ddots \\\\\n& & -1 & 2 & -1 \\\\\n\\mathbf{0} & & & -1 & 2\n\\end{pmatrix}\n\\quad , \\quad\nM = \\frac{h}{6}\n\\begin{pmatrix}\n4 & 1 & & \\mathbf{0} \\\\\n1 & 4 & 1 & \\\\\n& \\ddots & \\ddots & \\ddots \\\\\n& & 1 & 4 & 1 \\\\\n\\mathbf{0} & & & 1 & 4\n\\end{pmatrix}\n$$\n预处理后系统的条件数同样为 $\\kappa = (\\lambda_{\\max}/\\lambda_{\\min})^{1-s}$，其中 $\\lambda_{\\min}$ 和 $\\lambda_{\\max}$ 是矩阵对 $(K, M)$ 的最小和最大广义特征值。对于每个 $N_e \\in \\{64, 128, 256\\}$，我们构造 $K$ 和 $M$，求解极端广义特征值，计算 $\\kappa$，并记录 $(\\log(h), \\log(\\kappa))$。线性拟合提供 $p_{\\mathrm{est}}(s)$。\n\n**C, D, E部分：最终比较**\n对于八个测试用例中的每一个（FDM/FEM，其中 $s \\in \\{0.25, 0.5, 0.75, 1.0\\}$），我们计算理论指数 $p_{\\mathrm{th}}(s) = 2(1-s)$。然后我们检查经验估计的指数 $p_{\\mathrm{est}}(s)$ 是否落在指定的容差范围内：$|p_{\\mathrm{est}}(s) - p_{\\mathrm{th}}(s)| \\le 0.3$。每个案例的此检查的布尔结果构成了最终输出。对于 $s=1.0$ 的特殊情况，$p_{\\mathrm{th}}(1.0) = 0$，且预处理算子是单位矩阵，因此 $\\kappa=1$ 且 $\\log(\\kappa)=0$，这应精确地得出 $p_{\\mathrm{est}}(1.0)=0$，为实现提供了一个有用的健全性检查。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef estimate_p_fdm(s, n_values):\n    \"\"\"\n    Estimates the exponent p(s) for the Finite Difference Method.\n\n    Args:\n        s (float): The fractional order.\n        n_values (list of int): List of numbers of interior grid points.\n\n    Returns:\n        float: The estimated exponent p_est(s).\n    \"\"\"\n    log_h_vals = []\n    log_kappa_vals = []\n\n    for n in n_values:\n        h = 1.0 / (n + 1)\n        \n        # For s=1.0, the preconditioned operator is the identity, kappa=1.\n        if s == 1.0:\n            kappa = 1.0\n        else:\n            # Construct the FDM Laplacian matrix A.\n            # A = (1/h^2) * tridiag(-1, 2, -1)\n            main_diag = 2.0 * np.ones(n)\n            off_diag = -1.0 * np.ones(n - 1)\n            A = (1 / h**2) * (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1))\n            \n            # Eigenvalues of A. eigvalsh is efficient for symmetric matrices.\n            eigenvalues = np.linalg.eigvalsh(A)\n            lambda_min = eigenvalues[0]\n            lambda_max = eigenvalues[-1]\n            \n            # Condition number of the preconditioned operator.\n            kappa = (lambda_max / lambda_min)**(1.0 - s)\n        \n        log_h_vals.append(np.log(h))\n        log_kappa_vals.append(np.log(kappa))\n        \n    # Perform linear least-squares fit: log(kappa) = m * log(h) + c\n    # The slope m is -p_est.\n    coeffs = np.polyfit(log_h_vals, log_kappa_vals, 1)\n    p_est = -coeffs[0]\n    \n    return p_est\n\ndef estimate_p_fem(s, Ne_values):\n    \"\"\"\n    Estimates the exponent p(s) for the Finite Element Method.\n\n    Args:\n        s (float): The fractional order.\n        Ne_values (list of int): List of numbers of elements.\n\n    Returns:\n        float: The estimated exponent p_est(s).\n    \"\"\"\n    log_h_vals = []\n    log_kappa_vals = []\n\n    for Ne in Ne_values:\n        N = Ne - 1\n        if N = 0: continue\n        h = 1.0 / Ne\n        \n        if s == 1.0:\n            kappa = 1.0\n        else:\n            # Construct the stiffness matrix K and mass matrix M.\n            # K = (1/h) * tridiag(-1, 2, -1)\n            main_diag_K = 2.0 * np.ones(N)\n            off_diag_K = -1.0 * np.ones(N - 1)\n            K = (1 / h) * (np.diag(main_diag_K) + np.diag(off_diag_K, k=1) + np.diag(off_diag_K, k=-1))\n            \n            # M = (h/6) * tridiag(1, 4, 1)\n            main_diag_M = 4.0 * np.ones(N)\n            off_diag_M = 1.0 * np.ones(N - 1)\n            M = (h / 6.0) * (np.diag(main_diag_M) + np.diag(off_diag_M, k=1) + np.diag(off_diag_M, k=-1))\n            \n            # Solve the generalized eigenvalue problem K*v = lambda*M*v.\n            # eigh is suitable for symmetric/Hermitian matrices.\n            eigenvalues = eigh(K, M, eigvals_only=True)\n            lambda_min = eigenvalues[0]\n            lambda_max = eigenvalues[-1]\n            \n            # Condition number of the preconditioned operator.\n            kappa = (lambda_max / lambda_min)**(1.0 - s)\n            \n        log_h_vals.append(np.log(h))\n        log_kappa_vals.append(np.log(kappa))\n        \n    # Perform linear least-squares fit.\n    coeffs = np.polyfit(log_h_vals, log_kappa_vals, 1)\n    p_est = -coeffs[0]\n    \n    return p_est\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (method, s_value, mesh_sizes)\n        (\"FDM\", 0.25, [63, 127, 255]),\n        (\"FDM\", 0.50, [63, 127, 255]),\n        (\"FDM\", 0.75, [63, 127, 255]),\n        (\"FDM\", 1.00, [63, 127, 255]),\n        (\"FEM\", 0.25, [64, 128, 256]),\n        (\"FEM\", 0.50, [64, 128, 256]),\n        (\"FEM\", 0.75, [64, 128, 256]),\n        (\"FEM\", 1.00, [64, 128, 256]),\n    ]\n    \n    tolerance = 0.3\n    results = []\n\n    for method, s, meshes in test_cases:\n        p_th = 2.0 * (1.0 - s)\n        \n        if method == \"FDM\":\n            p_est = estimate_p_fdm(s, meshes)\n        elif method == \"FEM\":\n            p_est = estimate_p_fem(s, meshes)\n        else:\n            # This case should not be reached with the current test_cases setup.\n            raise ValueError(\"Unknown method specified.\")\n            \n        match = abs(p_est - p_th) = tolerance\n        results.append(match)\n\n    # Final print statement in the exact required format.\n    # str(True) -> 'True', str(False) -> 'False' which is correct for boolean values in the output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3381280"}]}