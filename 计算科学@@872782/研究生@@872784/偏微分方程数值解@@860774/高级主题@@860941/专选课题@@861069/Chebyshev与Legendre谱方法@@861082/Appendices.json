{"hands_on_practices": [{"introduction": "谱方法的核心在于用一组正交多项式（如切比雪夫多项式）来表示函数。这个练习旨在通过一个具体函数 $f(x) = e^x$ 来实践这一基本思想，你将从第一性原理出发，计算其切比雪夫谱展开的系数 [@problem_id:3370275]。通过对比解析解与数值积分结果，本练习将加深你对谱系数定义及其计算方法的理解。", "problem": "考虑在区间 $[-1,1]$ 上定义的第一类切比雪夫多项式 $T_n(x) = \\cos(n \\arccos x)$。对于一个足够光滑的函数 $f:[-1,1]\\to\\mathbb{R}$，其切比雪夫谱展开为级数\n$$\nf(x) \\sim \\frac{\\hat{f}_0}{2} + \\sum_{n=1}^{\\infty} \\hat{f}_n T_n(x),\n$$\n其中切比雪夫系数 $\\hat{f}_n$ 由 $\\cos(n\\theta)$ 在 $[0,\\pi]$ 上的正交性定义，并由以下积分表示给出\n$$\n\\hat{f}_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} f(\\cos\\theta)\\,\\cos(n\\theta)\\,d\\theta, \\quad n\\ge 0,\n$$\n其中角度 $\\theta$ 以弧度为单位。在切比雪夫谱方法中，阶数为 $N$ 的截断展开\n$$\nf_N(x) := \\frac{\\hat{f}_0}{2} + \\sum_{n=1}^{N} \\hat{f}_n T_n(x),\n$$\n被用作 $f(x)$ 的一个高阶近似。\n\n要求您计算特定函数 $f(x)=e^x$ 的切比雪夫系数，构建截断级数 $f_{10}(x)$，并在指定场景下评估与 $f(x)$ 的逐点误差。您的推导和算法必须从上述基本定义出发，并且只使用经过充分检验的数学事实，而非快捷公式。\n\n角度单位说明：所有角度都必须以弧度处理。\n\n实现一个完整、可运行的程序，执行以下计算：\n\n1. 使用从第一性原理出发的最精确推导，计算函数 $f(x)=e^x$ 在 $n=0,1,\\dots,10$ 时的切比雪夫系数 $\\hat{f}_n$，构建 $f_{10}(x)$，并计算绝对逐点误差 $|f(0.5)-f_{10}(0.5)|$。\n\n2. 对于 $n=0,1,\\dots,10$，使用复合梯形法则对定义积分进行数值积分，以近似计算 $f(x)=e^x$ 的切比雪夫系数 $\\hat{f}_n$。积分区间为 $\\theta\\in[0,\\pi]$，使用 $M=16384$ 个等距子区间（即 $M+1$ 个节点）。使用这些近似系数构建 $f_{10}(x)$，并计算绝对逐点误差 $|f(0.5)-f_{10}(0.5)|$。\n\n3. 使用第1项中最精确的系数，计算 $f_{10}(x)$ 在 $[-1,1]$ 上的上确界范数误差，该误差定义为 $\\max_{x\\in[-1,1]} |f(x)-f_{10}(x)|$。通过在 $[-1,1]$ 上的一个包含 $K=20001$ 个点的均匀网格上评估误差，并取其最大绝对值来计算。\n\n测试套件和答案规范：\n- 测试用例1（正常路径）：如上文第1项所述，输出一个浮点数，其值为在 $x=0.5$ 处的绝对误差。\n- 测试用例2（数值积分覆盖）：如上文第2项所述，输出一个浮点数，其值为在 $x=0.5$ 处的绝对误差。\n- 测试用例3（通过密集网格上的上确界范数进行边界覆盖）：如上文第3项所述，输出一个浮点数，其值为计算出的最大绝对误差。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号内以逗号分隔的列表，顺序为 [测试用例1结果, 测试用例2结果, 测试用例3结果]。例如，\n$$\n[\\text{result1},\\text{result2},\\text{result3}]\n$$\n其中每个条目都是一个浮点数。", "solution": "问题陈述经核实具有科学依据，问题定义明确且客观。这是一个关于切比雪夫谱方法应用的数值分析标准问题。它自成体系，没有矛盾或含糊之处。\n\n该问题要求分析函数 $f(x) = e^x$ 在区间 $x \\in [-1, 1]$ 上的切比雪夫谱近似。阶数为 $N$ 的切比雪夫级数近似由下式给出\n$$\nf_N(x) = \\frac{\\hat{f}_0}{2} + \\sum_{n=1}^{N} \\hat{f}_n T_n(x)\n$$\n其中 $T_n(x)$ 是第一类切比雪夫多项式，$\\hat{f}_n$ 是切比雪夫系数。这些系数由积分定义\n$$\n\\hat{f}_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} f(\\cos\\theta)\\,\\cos(n\\theta)\\,d\\theta, \\quad n \\ge 0.\n$$\n\n对于特定函数 $f(x) = e^x$，被积函数变为 $f(\\cos\\theta) = e^{\\cos\\theta}$。因此，系数的表达式为\n$$\n\\hat{f}_n = \\frac{2}{\\pi}\\int_{0}^{\\pi} e^{\\cos\\theta}\\cos(n\\theta)\\,d\\theta.\n$$\n这个积分与第一类修正贝塞尔函数 $I_n(z)$ 的一个标准积分表示直接相关，对于整数阶 $n$，其表达式为\n$$\nI_n(z) = \\frac{1}{\\pi} \\int_0^\\pi e^{z \\cos\\theta} \\cos(n\\theta) d\\theta.\n$$\n通过令 $z=1$，我们可以在 $e^x$ 的切比雪夫系数和修正贝塞尔函数的值之间建立直接关系。\n$$\n\\hat{f}_n = 2 \\left( \\frac{1}{\\pi} \\int_0^\\pi e^{1 \\cdot \\cos\\theta} \\cos(n\\theta) d\\theta \\right) = 2 I_n(1).\n$$\n这为测试用例1和3中所需的“精确”系数提供了一个解析表达式。使用标准的科学计算库可以高精度地计算这些值。\n\n为评估截断级数 $f_N(x)$，我们采用Clenshaw算法，这是一种稳定而高效的方法，用于对满足三项递推关系的多项式级数求和。切比雪夫多项式满足以下递推关系\n$$\nT_0(x) = 1, \\quad T_1(x) = x, \\quad T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x) \\text{ for } n \\ge 1.\n$$\n设待求和的级数为 $S(x) = \\sum_{k=0}^{N} c'_k T_k(x)$，其中 $c'_0 = \\hat{f}_0/2 = I_0(1)$ 且对于 $k \\ge 1$ 有 $c'_k = \\hat{f}_k = 2I_k(1)$。Clenshaw算法的步骤如下：\n初始化 $b_{N+2} = 0$ 和 $b_{N+1} = 0$。\n然后，对于 $k = N, N-1, \\dots, 1$，计算\n$$\nb_k = c'_k + 2x b_{k+1} - b_{k+2}.\n$$\n级数的值则由 $S(x) = c'_0 + x b_1 - b_2$ 给出。\n\n**测试用例1：使用解析推导系数的逐点误差**\n对于 $n=0, 1, \\dots, 10$，切比雪夫系数 $\\hat{f}_n$ 使用恒等式 $\\hat{f}_n = 2 I_n(1)$ 计算。$I_n(1)$ 的数值通过 `scipy.special.iv` 函数获得。这些系数用于构建Clenshaw系数数组 $c'$。然后使用Clenshaw算法在 $x=0.5$ 处评估多项式 $f_{10}(x)$。绝对误差计算为 $|e^{0.5} - f_{10}(0.5)|$。\n\n**测试用例2：使用数值积分系数的逐点误差**\n对于 $n=0, 1, \\dots, 10$，通过对定义积分进行数值计算来近似切比雪夫系数 $\\hat{f}_n$。将复合梯形法则应用于在均匀 $\\theta$ 值网格上的积分 $\\int_{0}^{\\pi} e^{\\cos\\theta}\\cos(n\\theta)\\,d\\theta$。区间 $[0, \\pi]$ 被划分为 $M=16384$ 个子区间，创建 $M+1$ 个节点 $\\theta_j = j\\pi/M$（$j=0, \\dots, M$）。函数 $g(\\theta)$ 的积分 $I$ 近似为\n$$\nI \\approx h \\left( \\frac{g(\\theta_0) + g(\\theta_M)}{2} + \\sum_{j=1}^{M-1} g(\\theta_j) \\right),\n$$\n其中 $h = \\pi/M$ 是步长。对于每个 $n$，使用相应的被积函数 $g_n(\\theta) = e^{\\cos\\theta}\\cos(n\\theta)$。然后，使用得到的近似系数 $\\hat{f}_n^{(\\text{num})}$ 构建一个新的多项式近似 $f_{10}^{(\\text{num})}(x)$。在 $x=0.5$ 处评估该多项式，并计算绝对误差 $|e^{0.5} - f_{10}^{(\\text{num})}(0.5)|$。\n\n**测试用例3：上确界范数误差**\n该测试用例要求计算误差的上确界范数的近似值，定义为 $\\max_{x\\in[-1,1]} |f(x)-f_{10}(x)|$。通过在一个覆盖区间 $[-1, 1]$ 的、包含 $K=20001$ 个点的密集均匀网格上评估误差来找到该近似值。多项式 $f_{10}(x)$ 使用测试用例1中解析推导的系数构建。使用Clenshaw算法的向量化版本可以高效地同时在所有网格点 $x_j$ 上评估 $f_{10}(x_j)$。对每个点计算绝对误差 $|e^{x_j} - f_{10}(x_j)|$，并报告这些误差中的最大值作为结果。", "answer": "```python\nimport numpy as np\nfrom scipy.special import iv\n\ndef clenshaw_eval(x, c_prime):\n    \"\"\"\n    Evaluates a Chebyshev series using Clenshaw's algorithm.\n    Can handle both scalar and NumPy array inputs for x.\n    \n    Args:\n        x (float or np.ndarray): The point(s) at which to evaluate the series.\n        c_prime (np.ndarray): The coefficients of the series, where c_prime[k]\n                             is the coefficient of T_k(x). The series is\n                             assumed to be sum_{k=0 to N} c_prime[k] T_k(x).\n\n    Returns:\n        float or np.ndarray: The value(s) of the Chebyshev series.\n    \"\"\"\n    N = len(c_prime) - 1\n    if N  0:\n        return 0.0 if not isinstance(x, np.ndarray) else np.zeros_like(x)\n\n    # Ensure x is a NumPy array for vectorized operations\n    is_scalar = not isinstance(x, np.ndarray)\n    if is_scalar:\n        x_arr = np.array([x])\n    else:\n        x_arr = x\n\n    # Initialize b_{N+2} and b_{N+1}\n    b_k_plus_2 = np.zeros_like(x_arr)\n    b_k_plus_1 = np.zeros_like(x_arr)\n\n    # Recurrence loop\n    for k in range(N, 0, -1):\n        b_k = c_prime[k] + 2 * x_arr * b_k_plus_1 - b_k_plus_2\n        b_k_plus_2 = b_k_plus_1\n        b_k_plus_1 = b_k\n    \n    # Final value calculation\n    # val = c_prime[0] * T_0(x) + b_1 * T_1(x) - b_2 * T_0(x)\n    val = c_prime[0] + x_arr * b_k_plus_1 - b_k_plus_2\n    \n    return val.item() if is_scalar else val\n\ndef solve():\n    \"\"\"\n    Solves the three test cases as described in the problem statement.\n    \"\"\"\n    results = []\n    \n    # --- Parameters from the problem statement ---\n    N_degree = 10\n    M_panels = 16384\n    K_points = 20001\n    x_eval_point = 0.5\n\n    # --- Test Case 1: Pointwise error with analytically derived coefficients ---\n\n    # n = 0, 1, ..., N\n    n_values = np.arange(0, N_degree + 1)\n\n    # Exact coefficients f_hat_n = 2 * I_n(1)\n    f_hat_exact = 2 * iv(n_values, 1.0)\n    \n    # Create coefficients for Clenshaw's algorithm (c'_0 = f_hat_0 / 2)\n    c_prime_exact = np.copy(f_hat_exact)\n    c_prime_exact[0] /= 2.0\n    \n    # Evaluate at x = 0.5\n    f_val_exact_pt = np.exp(x_eval_point)\n    f10_val_exact_pt = clenshaw_eval(x_eval_point, c_prime_exact)\n    \n    error1 = np.abs(f_val_exact_pt - f10_val_exact_pt)\n    results.append(error1)\n\n    # --- Test Case 2: Pointwise error with numerically integrated coefficients ---\n    \n    theta = np.linspace(0, np.pi, M_panels + 1)\n    exp_cos_theta = np.exp(np.cos(theta))\n    \n    f_hat_num = np.zeros(N_degree + 1)\n    for n in n_values:\n        integrand = exp_cos_theta * np.cos(n * theta)\n        integral = np.trapz(integrand, theta)\n        f_hat_num[n] = (2.0 / np.pi) * integral\n    \n    # Create coefficients for Clenshaw's algorithm\n    c_prime_num = np.copy(f_hat_num)\n    c_prime_num[0] /= 2.0\n    \n    # Evaluate at x = 0.5\n    f10_val_num_pt = clenshaw_eval(x_eval_point, c_prime_num)\n    \n    error2 = np.abs(f_val_exact_pt - f10_val_num_pt)\n    results.append(error2)\n\n    # --- Test Case 3: Supremum norm error ---\n    \n    x_grid = np.linspace(-1.0, 1.0, K_points)\n    \n    # Use exact coefficients from Test Case 1\n    f10_on_grid = clenshaw_eval(x_grid, c_prime_exact)\n    f_on_grid = np.exp(x_grid)\n    \n    error3 = np.max(np.abs(f_on_grid - f10_on_grid))\n    results.append(error3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3370275"}, {"introduction": "谱方法在求解微分方程中的威力很大程度上源于其对导数的高精度近似。本练习将指导你从基本原理出发，为切比雪夫和勒让德节点构建谱微分矩阵，这是将微分算子离散化为矩阵向量乘法的关键步骤 [@problem_id:3370324]。掌握这一技能是应用谱方法解决实际物理和工程问题的基础。", "problem": "考虑在区间 $[-1,1]$ 上对一个光滑函数进行多项式谱方法微分。令 $N$ 表示多项式次数，并用 $\\{x_j\\}_{j=0}^{N}$ 表示 $N+1$ 个插值节点。与这些节点相关的 Lagrange 基多项式 $\\{\\ell_j(x)\\}_{j=0}^{N}$ 由条件 $\\ell_j(x_k)=\\delta_{jk}$ 定义，其中 $\\delta_{jk}$ 是 Kronecker delta 符号。谱微分矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 是通过在节点处计算基多项式的导数来定义的，因此，插值多项式 $p(x)=\\sum_{j=0}^{N} u_j \\ell_j(x)$ 在节点处的导数值向量为 $Dp$，其中每个元素由 $\\sum_{j=0}^{N} u_j \\ell_j'(x_i)$ 构成。\n\n此构造的基础是多项式插值及其 Lagrange 形式的基本定义：任何次数至多为 $N$ 且插值于数据 $\\{(x_j, u_j)\\}_{j=0}^{N}$ 的多项式都可以唯一地表示为 $p(x)=\\sum_{j=0}^{N} u_j \\ell_j(x)$，并且根据微分的线性性质，有 $p'(x)=\\sum_{j=0}^{N} u_j \\ell_j'(x)$。因此，在节点处的导数值由矩阵 $D$ 决定，其元素为 $D_{ij}=\\ell_j'(x_i)$。你必须直接根据这些原理构造矩阵 $D$，不得对任何特殊节点集使用预先制定的封闭形式公式。\n\n你将使用两种经典的谱方法网格：\n- 第一类 Chebyshev–Gauss–Lobatto (CGL) 节点：$x_j=\\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,1,\\dots,N$。\n- Legendre–Gauss–Lobatto (LGL) 节点：$x_0=-1$，$x_N=1$，内部节点 $\\{x_j\\}_{j=1}^{N-1}$ 是 $N$ 次 Legendre 多项式导数 $P_N'(x)=0$ 在 $(-1,1)$ 内的 $N-1$ 个不同根。使用 Legendre 微分方程设计一个 Newton 迭代法，用于优化这些内部根的初始猜测值。Legendre 微分方程为 $(1-x^2)P_N''(x)-2xP_N'(x)+N(N+1)P_N(x)=0$。你必须利用此关系式来获得 Newton 更新步骤，且不得依赖于预先制定的根的公式。\n\n对于目标函数 $u(x)=\\sin(5x)$（角度以弧度为单位），通过将谱微分矩阵 $D$ 应用于 $u(x)$ 的节点值来近似计算 $u'(x)$ 在节点处的值，并将此近似值与在相同节点处的精确导数 $u'(x)=5\\cos(5x)$ 进行比较。对于每种情况，计算定义为\n$$\nE_{\\infty}=\\max_{0\\le i\\le N} \\left| (Du)_i - u'(x_i) \\right|\n$$\n的 $\\ell^\\infty$ 误差。\n\n你的程序必须从第一性原理出发，通过计算 Lagrange 基在节点处的导数来实现 $D$ 的构造（允许使用通用的重心 Lagrange 机制，但不得使用任何针对特定节点族的显式封闭形式微分矩阵）。对于 Legendre–Gauss–Lobatto 节点，应使用 Chebyshev–Gauss–Lobatto 节点来初始化内部根的 Newton 迭代，并使用 Legendre 微分方程推导 Newton 更新步骤。\n\n使用以下测试套件，其中节点族和次数均有变化：\n1. CGL，$N=8$。\n2. CGL，$N=32$。\n3. CGL，$N=64$。\n4. LGL，$N=8$。\n5. LGL，$N=32$。\n6. LGL，$N=64$。\n\n对于每个测试用例，输出必须是单个浮点数 $E_{\\infty}$。你的程序应生成单行输出，其中包含用方括号括起来的六个结果，并以逗号分隔（例如，“[e1,e2,e3,e4,e5,e6]”）。不应打印任何其他文本。所有角度均以弧度为单位。不涉及物理单位。", "solution": "该问题要求为 Chebyshev 和 Legendre 网格构建谱微分矩阵，并应用它们来近似给定函数的导数。构建过程必须从第一性原理出发，不得借助已知的微分矩阵封闭形式表达式。问题的核心在于正确实现节点生成算法，特别是 Legendre–Gauss–Lobatto 节点的生成，以及随后利用 Lagrange 插值的一般性质来构建微分矩阵。\n\n### 1. 谱微分矩阵的一般公式\n\n给定区间 $[-1, 1]$ 上的 $N+1$ 个不同插值节点 $\\{x_j\\}_{j=0}^{N}$，任何次数至多为 $N$ 的多项式 $p(x)$ 都可以使用 Lagrange 基多项式 $\\{\\ell_j(x)\\}_{j=0}^{N}$ 唯一地表示为：\n$$\np(x) = \\sum_{j=0}^{N} u_j \\ell_j(x)\n$$\n其中 $u_j = p(x_j)$ 是函数在节点处的值，且基多项式满足属性 $\\ell_j(x_k) = \\delta_{jk}$。该多项式的导数由基多项式导数的线性组合给出：\n$$\np'(x) = \\sum_{j=0}^{N} u_j \\ell_j'(x)\n$$\n在插值节点 $x_i$ 处计算此导数可得：\n$$\np'(x_i) = \\sum_{j=0}^{N} u_j \\ell_j'(x_i)\n$$\n此关系可以表示为矩阵-向量乘积 $\\boldsymbol{u}' = D\\boldsymbol{u}$，其中 $\\boldsymbol{u}$ 是节点值向量 $[u_0, u_1, \\dots, u_N]^T$，$\\boldsymbol{u}'$ 是节点处导数值的向量 $[p'(x_0), \\dots, p'(x_N)]^T$，而 $D$ 是谱微分矩阵。该矩阵的元素由下式给出：\n$$\nD_{ij} = \\ell_j'(x_i)\n$$\n该问题禁止对特定节点族使用预先计算的 $D_{ij}$ 公式，但允许使用通用的重心插值机制。Lagrange 基多项式定义为 $\\ell_j(x) = \\prod_{k=0, k \\neq j}^{N} \\frac{x-x_k}{x_j-x_k}$。一种计算其在节点处导数的通用且稳定的方法涉及重心权重。\n\n每个节点 $x_j$ 的重心权重 $w_j$ 从第一性原理定义为：\n$$\nw_j = \\frac{1}{\\prod_{k=0, k \\neq j}^{N} (x_j - x_k)}\n$$\n使用这些权重，微分矩阵的元素可以表示为：\n$$\nD_{ij} = \\frac{w_j/w_i}{x_i - x_j} \\quad \\text{当 } i \\neq j\n$$\n对于对角线元素 $D_{ii}$，可以使用公式 $D_{ii} = \\sum_{k=0, k \\neq i}^{N} \\frac{1}{x_i-x_k}$。然而，一种数值上更稳健的方法是利用常数导数必须为零的性质。常数函数 $f(x)=1$ 可以被 $p(x)=1$ 精确插值，这对应于节点值向量 $\\boldsymbol{u} = [1, 1, \\dots, 1]^T$。其导数处处为零，这意味着 $D\\boldsymbol{1} = \\boldsymbol{0}$。这意味着微分矩阵的每行之和必须为零：\n$$\n\\sum_{j=0}^{N} D_{ij} = 0 \\quad \\text{对于每个 } i = 0, \\dots, N\n$$\n根据此属性，我们可以将对角线元素计算为同一行中非对角线元素的和的负值：\n$$\nD_{ii} = - \\sum_{j=0, j \\neq i}^{N} D_{ij}\n$$\n这套公式为任何一组不同的节点构造 $D$ 提供了通用算法。\n\n### 2. 节点生成与矩阵构造\n\n我们将把此通用过程应用于两组特定的节点。\n\n#### 2.1. Chebyshev–Gauss–Lobatto (CGL) 节点\nCGL 节点是第一类 Chebyshev 多项式 $T_N(x)$ 的极值点。它们由显式公式给出：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{其中 } j=0, 1, \\dots, N\n$$\n对于给定的次数 $N$，我们首先生成这 $N+1$ 个节点。然后，我们使用基本的乘积定义计算每个节点的重心权重 $w_j$。最后，我们使用 $D_{ij}$ 的通用重心公式构造 CGL 微分矩阵 $D^{\\text{CGL}}$。\n\n#### 2.2. Legendre–Gauss–Lobatto (LGL) 节点\nLGL 节点包括区间的端点 $x_0 = -1$ 和 $x_N = 1$。$N-1$ 个内部节点 $\\{x_j\\}_{j=1}^{N-1}$ 是 $N$ 次 Legendre 多项式 $P_N(x)$ 的导数 $P_N'(x)$ 的根。\n\n问题要求通过 Newton 方法找到这些根，并使用 CGL 内部节点作为初始猜测值。对于函数 $f(x)$，求根的 Newton 迭代法是 $x_{k+1} = x_k - f(x_k)/f'(x_k)$。在我们的例子中，$f(x) = P_N'(x)$，因此迭代公式为：\n$$\nx_{k+1} = x_k - \\frac{P_N'(x_k)}{P_N''(x_k)}\n$$\n我们必须使用 Legendre 微分方程推导更新项的表达式：\n$$\n(1-x^2)P_N''(x) - 2xP_N'(x) + N(N+1)P_N(x) = 0\n$$\n解出 $P_N''(x)$ 可得：\n$$\nP_N''(x) = \\frac{2xP_N'(x) - N(N+1)P_N(x)}{1-x^2}\n$$\n将此式代入 Newton 迭代公式，得到更新步骤：\n$$\nx_{k+1} = x_k - \\frac{P_N'(x_k)}{\\frac{2x_k P_N'(x_k) - N(N+1)P_N(x_k)}{1-x_k^2}} = x_k - \\frac{(1-x_k^2)P_N'(x_k)}{2x_k P_N'(x_k) - N(N+1)P_N(x_k)}\n$$\n为了实现此迭代，我们需要计算 $P_N(x)$ 和 $P_N'(x)$。Legendre 多项式 $P_k(x)$ 的值可以使用三项递推关系或标准库函数计算。导数 $P_N'(x)$ 可以使用恒等式高效地求出：\n$$\n(1-x^2)P_N'(x) = N(P_{N-1}(x) - xP_N(x))\n$$\n生成 LGL 节点的步骤如下：\n1. 设置端点 $x_0 = -1$ 和 $x_N = 1$。\n2. 对于内部节点，取初始猜测值 $x_j^{(0)} = \\cos(\\frac{\\pi j}{N})$，其中 $j=1, \\dots, N-1$。\n3. 对每个猜测值，使用推导出的 Newton 更新公式进行迭代，直到根收敛到所需容差。这需要在每一步计算 $P_N(x)$ 和 $P_{N-1}(x)$。\n4. 收集端点和收敛的内部根，形成 LGL 节点集 $\\{x_j\\}_{j=0}^{N}$。\n5. 确定节点后，使用与 CGL 情况相同的通用重心方法构造 LGL 微分矩阵 $D^{\\text{LGL}}$。\n\n### 3. 误差计算\n\n对于每个测试用例（一个节点族和一个次数 $N$）：\n1.  生成相应的节点集 $\\{x_j\\}$。\n2.  构造对应的微分矩阵 $D$。\n3.  在节点处计算目标函数 $u(x) = \\sin(5x)$，形成向量 $\\boldsymbol{u}$。\n4.  通过矩阵-向量乘积 $\\boldsymbol{u}'_{approx} = D\\boldsymbol{u}$ 计算节点处导数的数值近似值。\n5.  在节点处计算精确导数 $u'(x) = 5\\cos(5x)$，形成向量 $\\boldsymbol{u}'_{exact}$。\n6.  $\\ell^\\infty$ 误差计算为近似导数值与精确导数值之间的最大绝对差：\n    $$\n    E_{\\infty} = \\max_{0\\le i\\le N} \\left| (\\boldsymbol{u}'_{approx})_i - (\\boldsymbol{u}'_{exact})_i \\right|\n    $$\n对所有指定的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import eval_legendre\n\ndef get_cgl_nodes(N):\n    \"\"\"Generates Chebyshev-Gauss-Lobatto nodes.\"\"\"\n    if N == 0:\n        return np.array([0.0])\n    j = np.arange(N + 1)\n    nodes = np.cos(np.pi * j / N)\n    return nodes\n\ndef get_lgl_nodes(N, tol=1e-15, max_iter=100):\n    \"\"\"\n    Generates Legendre-Gauss-Lobatto nodes.\n    The interior nodes are the roots of P_N'(x), found via Newton's method.\n    \"\"\"\n    if N == 0:\n        return np.array([0.0])\n    if N == 1:\n        return np.array([-1.0, 1.0])\n    \n    nodes = np.zeros(N + 1)\n    nodes[0] = -1.0\n    nodes[N] = 1.0\n    \n    # Initial guesses for interior roots are interior CGL nodes\n    j_int = np.arange(1, N)\n    guesses = np.cos(np.pi * j_int / N)\n    \n    for i in range(len(guesses)):\n        x_k = guesses[i]\n        \n        for _ in range(max_iter):\n            # The formulas are valid for x in (-1, 1).\n            # Newton iteration may push x_k slightly outside, clip it.\n            if abs(x_k) > 1.0:\n                x_k = np.sign(x_k)\n\n            # Evaluate Legendre polynomials P_N(x) and P_{N-1}(x)\n            PN_val = eval_legendre(N, x_k)\n            PN_minus_1_val = eval_legendre(N - 1, x_k)\n            \n            # Derivative P_N'(x) using relation (1-x^2)P_N'(x) = N(P_{N-1}(x) - xP_N(x))\n            dPN_val = N * (PN_minus_1_val - x_k * PN_val) / (1 - x_k**2)\n\n            # Newton update for a root of P_N'(x), derived from Legendre DE.\n            # update = (1-x^2)P_N'(x) / (2xP_N'(x) - N(N+1)P_N(x))\n            numerator = (1 - x_k**2) * dPN_val\n            denominator = 2 * x_k * dPN_val - N * (N + 1) * PN_val\n            \n            if abs(denominator)  1e-14:\n                # This may happen if the guess is already a root of the denominator.\n                # In such cases, the iteration is stuck; we just break.\n                break\n                \n            update = numerator / denominator\n            x_k -= update\n            \n            if abs(update)  tol:\n                break\n        \n        nodes[i + 1] = x_k\n        \n    nodes.sort() # Ensure nodes are in descending order (or ascending)\n    return nodes\n\ndef build_diff_matrix(nodes):\n    \"\"\"\n    Constructs the spectral differentiation matrix from first principles\n    using the barycentric formulation for any set of nodes.\n    \"\"\"\n    N = len(nodes) - 1\n    if N == 0:\n        return np.array([[0.0]])\n        \n    D = np.zeros((N + 1, N + 1))\n    \n    # Calculate barycentric weights from their fundamental definition\n    weights = np.zeros(N + 1)\n    for j in range(N + 1):\n        # Create an array of differences (x_j - x_k) for k != j\n        diffs = nodes[j] - np.delete(nodes, j)\n        weights[j] = 1.0 / np.prod(diffs)\n\n    # Off-diagonal entries using D_ij = (w_j/w_i) / (x_i - x_j)\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i != j:\n                D[i, j] = (weights[j] / weights[i]) / (nodes[i] - nodes[j])\n    \n    # Diagonal entries using the row-sum property: D_ii = -sum(D_ij) for j != i\n    for i in range(N + 1):\n        D[i, i] = -np.sum(D[i, :])\n        \n    return D\n\ndef compute_error(node_type, N):\n    \"\"\"\n    Main logic to compute the l-infinity error for a given case.\n    \"\"\"\n    if node_type == 'cgl':\n        nodes = get_cgl_nodes(N)\n    elif node_type == 'lgl':\n        nodes = get_lgl_nodes(N)\n    else:\n        raise ValueError(\"Unknown node type\")\n\n    D = build_diff_matrix(nodes)\n    \n    # Target function u(x) and its exact derivative u'(x)\n    u_func = lambda x: np.sin(5 * x)\n    du_exact_func = lambda x: 5 * np.cos(5 * x)\n    \n    # Evaluate at the nodes\n    u_vals = u_func(nodes)\n    du_exact_vals = du_exact_func(nodes)\n    \n    # Approximate derivative using the differentiation matrix\n    du_approx_vals = D @ u_vals\n    \n    # Compute the L-infinity error\n    error = np.max(np.abs(du_approx_vals - du_exact_vals))\n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ('cgl', 8),\n        ('cgl', 32),\n        ('cgl', 64),\n        ('lgl', 8),\n        ('lgl', 32),\n        ('lgl', 64),\n    ]\n\n    results = []\n    for case in test_cases:\n        node_type, N = case\n        error = compute_error(node_type, N)\n        results.append(f\"{error:.15e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3370324"}, {"introduction": "在谱方法中处理非线性项时，一个常见且微妙的挑战是混叠误差（aliasing error）。该误差源于在配置点上对高频分量的错误表示。本练习通过分析函数 $u(x) = T_N(x)$ 的平方，提供了一个清晰的案例，让你能够精确地量化和理解混叠现象，这对于开发稳健的非线性问题谱方法求解器至关重要 [@problem_id:3370334]。", "problem": "考虑第一类切比雪夫多项式，其定义为 $T_n(x) = \\cos(n \\arccos x)$，其中 $x \\in [-1,1]$。令加权内积定义为 $\\langle f, g \\rangle_w = \\int_{-1}^{1} f(x) g(x) w(x) \\, dx$，权重为 $w(x) = (1 - x^2)^{-1/2}$。对于 $[-1,1]$ 上在此权重下具有有限能量的任意函数 $f$，其切比雪夫模态系数 $\\{a_k\\}_{k \\ge 0}$ 由正交关系定义：$a_0 = \\frac{1}{\\pi} \\int_{-1}^{1} f(x) w(x) \\, dx$，对于 $k \\ge 1$，$a_k = \\frac{2}{\\pi} \\int_{-1}^{1} f(x) T_k(x) w(x) \\, dx$，因此在 $L^2_w([-1,1])$ 的意义下，$f(x) = \\sum_{k=0}^{\\infty} a_k T_k(x)$。$f$ 的 $N$-模态投影是截断 $P_N f(x) = \\sum_{k=0}^{N} a_k T_k(x)$。\n\n定义由 $N+1$ 个节点组成的切比雪夫-洛巴托配置网格，节点为 $x_j = \\cos(\\theta_j)$，其中 $\\theta_j = \\pi j / N$，对于 $j = 0,1,\\dots,N$（当 $N=0$ 时，将其解释为单个节点 $x_0 = 1$）。给定函数 $v$，其 $N$ 次切比雪夫配置插值多项式 $I_N v$ 是次数至多为 $N$ 的唯一多项式，满足对于所有网格节点，$I_N v(x_j) = v(x_j)$。如果 $v$ 是一个次数大于 $N$ 的多项式，那么与模态投影 $P_N v$ 相比，插值多项式 $I_N v$ 在模态空间中会产生混叠误差。\n\n构建一个数值示例，其中 $u(x) = T_N(x)$，非线性乘积为 $f(x) = u(x)^2$。通过构建节点样本 $f_j = f(x_j)$ 并通过求解方形线性系统 $\\sum_{k=0}^{N} \\hat{a}_k T_k(x_j) = f_j$（对于 $j=0,1,\\dots,N$）来求解切比雪夫基中的插值系数 $\\{\\hat{a}_k\\}_{k=0}^{N}$，从而计算配置乘积。同时，仅使用第一性原理（$T_n$ 的定义性质、内积和三角恒等式）确定 $f$ 的精确 $N$-模态投影系数 $\\{a_k\\}_{k=0}^{N}$。定义模态 $k$ 中的混叠误差为 $e_k = \\hat{a}_k - a_k$（对于 $k=0,1,\\dots,N$），并定义模态误差 $2$-范数为 $\\|e\\|_2 = \\left( \\sum_{k=0}^{N} e_k^2 \\right)^{1/2}$。\n\n您的程序必须以数值方式实现此过程，并为每个测试用例报告两个量：零阶模态系数的绝对误差 $|e_0|$ 和模态误差 $2$-范数 $\\|e\\|_2$。此问题中没有物理单位。所有角度均默认使用弧度。测试套件是多项式次数的集合 $N \\in \\{0, 1, 7, 16, 31\\}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个包含五个项目的列表，每个项目是对应于上述指定顺序的 $N$ 值的 $2$-元列表 $[|e_0|, \\|e\\|_2]$。该行必须是这些 $2$-元列表的单个方括号逗号分隔列表，不含任何附加文本。例如，语法上有效的输出形式为 $[[a,b],[c,d],[\\dots],\\dots]$，其中每个符号代表一个实数。", "solution": "## 问题验证\n\n### 步骤 1：提取已知信息\n- **切比雪夫多项式**：$T_n(x) = \\cos(n \\arccos x)$，对于 $x \\in [-1,1]$。\n- **加权内积**：$\\langle f, g \\rangle_w = \\int_{-1}^{1} f(x) g(x) w(x) \\, dx$，权重为 $w(x) = (1 - x^2)^{-1/2}$。\n- **切比雪夫模态系数**：对于函数 $f(x) = \\sum_{k=0}^{\\infty} a_k T_k(x)$：\n  - $a_0 = \\frac{1}{\\pi} \\int_{-1}^{1} f(x) w(x) \\, dx$\n  - 对于 $k \\ge 1$，$a_k = \\frac{2}{\\pi} \\int_{-1}^{1} f(x) T_k(x) w(x) \\, dx$。\n- **N-模态投影**：$P_N f(x) = \\sum_{k=0}^{N} a_k T_k(x)$。\n- **切比雪夫-洛巴托配置网格**：$x_j = \\cos(\\theta_j)$，其中 $\\theta_j = \\pi j / N$，对于 $j = 0,1,\\dots,N$。对于 $N=0$，网格为单个节点 $x_0 = 1$。\n- **配置插值多项式**：$I_N v$ 是次数至多为 $N$ 的唯一多项式，满足对于所有节点 $x_j$，$I_N v(x_j) = v(x_j)$。\n- **问题设置**：\n  - 基函数：$u(x) = T_N(x)$。\n  - 非线性乘积：$f(x) = u(x)^2 = T_N(x)^2$。\n- **任务**：\n  1. 确定 $f(x)$ 的精确 $N$-模态投影系数 $\\{a_k\\}_{k=0}^{N}$。\n  2. 通过在节点 $x_j$ 处计算 $f(x)$ 得到 $f_j=f(x_j)$，并求解线性系统 $\\sum_{k=0}^{N} \\hat{a}_k T_k(x_j) = f_j$（对于 $j=0,1,\\dots,N$）来确定配置插值系数 $\\{\\hat{a}_k\\}_{k=0}^{N}$。\n  3. 定义混叠误差：$e_k = \\hat{a}_k - a_k$（对于 $k=0,1,\\dots,N$）。\n  4. 定义模态误差 $2$-范数：$\\|e\\|_2 = \\left( \\sum_{k=0}^{N} e_k^2 \\right)^{1/2}$。\n  5. 报告零阶模态系数的绝对误差 $|e_0|$ 和模态误差 $2$-范数 $\\|e\\|_2$。\n- **测试用例**：$N \\in \\{0, 1, 7, 16, 31\\}$。\n- **输出格式**：一个单行，包含一个由五个 $2$-元列表 $[|e_0|, \\|e\\|_2]$ 组成的列表，分别对应于测试用例。\n\n### 步骤 2：使用提取的已知信息进行验证\n该问题是数值分析领域的一个标准练习，特别是关于求解偏微分方程的谱方法。问题的核心是分析使用配置方法计算非线性项时的混叠误差。\n\n- **科学依据**：该问题完全基于切比雪夫多项式和多项式插值的成熟数学理论。所有定义和性质都是标准的，并且在事实上是正确的。\n- **适定性**：问题定义清晰。函数 $f(x)$ 已指定，寻找精确投影系数 ($a_k$) 和插值系数 ($\\hat{a}_k$) 的过程明确无误，并且所需的输出有精确定义。存在唯一、稳定且有意义的解。\n- **客观性**：语言精确且数学化，没有任何主观性或意见。\n- **无缺陷**：该问题不违反任何无效性标准。它是自洽、一致的，并且可以使用数值分析和线性代数的方法求解。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解决方案。\n\n## 解决方案\n该问题要求我们分析在使用切比雪夫-洛巴托网格上的配置方法计算切比雪夫多项式的平方 $f(x) = T_N(x)^2$ 时发生的混叠误差。我们将首先确定 $f(x)$ 投影的精确模态系数，然后是 $f(x)$ 插值多项式的系数，最后计算它们之间的误差。\n\n**1. 精确的模态投影系数 ($a_k$)**\n\n函数为 $f(x) = T_N(x)^2$。根据定义，$T_N(x) = \\cos(N \\arccos x)$。令 $x = \\cos(\\theta)$，则 $\\theta = \\arccos(x)$。\n函数变为 $f(x) = (\\cos(N\\theta))^2$。使用三角降幂恒等式 $\\cos^2(\\alpha) = \\frac{1}{2}(1 + \\cos(2\\alpha))$，我们得到：\n$$ f(x) = \\frac{1}{2}(1 + \\cos(2N\\theta)) $$\n将 $\\theta = \\arccos(x)$ 代回：\n$$ f(x) = \\frac{1}{2}(1 + \\cos(2N \\arccos x)) $$\n根据定义 $T_0(x) = 1$ 和 $T_{2N}(x) = \\cos(2N \\arccos x)$，我们得到 $f(x)$ 的精确切比雪夫级数展开：\n$$ f(x) = \\frac{1}{2} T_0(x) + \\frac{1}{2} T_{2N}(x) $$\n模态投影 $P_N f(x)$ 是此级数到 $N$ 次的截断：$P_N f(x) = \\sum_{k=0}^{N} a_k T_k(x)$。我们考虑 $N$ 的两种情况。\n\n情况 $N  0$：\n项 $T_{2N}(x)$ 的次数为 $2N$，大于 $N$。因此，它不属于 $N$-模态投影。投影为：\n$$ P_N f(x) = \\frac{1}{2} T_0(x) $$\n通过比较系数，精确的投影系数为：\n$$ a_0 = \\frac{1}{2}, \\quad a_k = 0 \\quad \\text{对于 } k = 1, 2, \\dots, N $$\n\n情况 $N = 0$：\n函数为 $f(x) = T_0(x)^2 = 1^2 = 1$。在切比雪夫基中，这简化为 $f(x) = T_0(x)$。投影 $P_0 f(x)$ 是 $a_0 T_0(x)$。因此，通过直接比较：\n$$ a_0 = 1 $$\n\n**2. 配置插值系数 ($\\hat{a}_k$)**\n\n配置插值多项式 $I_N f(x) = \\sum_{k=0}^{N} \\hat{a}_k T_k(x)$ 是次数至多为 $N$ 的唯一多项式，它在切比雪夫-洛巴托节点 $x_j = \\cos(\\frac{\\pi j}{N})$（对于 $j=0, \\dots, N$）处与 $f(x)$ 相匹配。\n我们计算 $f(x)$ 在这些节点处的值：\n$$ f(x_j) = T_N(x_j)^2 = \\left( T_N\\left(\\cos\\left(\\frac{\\pi j}{N}\\right)\\right) \\right)^2 $$\n使用 $T_N(x)$ 的定义：\n$$ T_N\\left(\\cos\\left(\\frac{\\pi j}{N}\\right)\\right) = \\cos\\left(N \\arccos\\left(\\cos\\left(\\frac{\\pi j}{N}\\right)\\right)\\right) = \\cos\\left(N \\frac{\\pi j}{N}\\right) = \\cos(\\pi j) = (-1)^j $$\n因此，节点处的函数值为：\n$$ f_j = f(x_j) = ((-1)^j)^2 = 1 \\quad \\text{对于所有 } j = 0, 1, \\dots, N $$\n插值多项式 $I_N f(x)$ 必须是一个次数至多为 $N$ 的多项式，在所有 $N+1$ 个不同节点处取值为 1。唯一满足此条件的多项式是常数函数 $p(x) = 1$。在切比雪夫基中，这就是 $T_0(x)$。\n所以，对于任何 $N \\ge 0$：\n$$ I_N f(x) = 1 = T_0(x) $$\n通过将 $I_N f(x) = \\sum_{k=0}^{N} \\hat{a}_k T_k(x)$ 与 $T_0(x)$ 比较，我们通过唯一性找到插值系数：\n$$ \\hat{a}_0 = 1, \\quad \\hat{a}_k = 0 \\quad \\text{对于 } k = 1, 2, \\dots, N $$\n这展示了混叠现象：高频分量 $T_{2N}(x)$ 在网格上与 $T_0(x)$ 无法区分（因为 $T_{2N}(x_j) = \\cos(2\\pi j) = 1 = T_0(x_j)$），其能量完全混叠到零阶模态上。\n\n**3. 混叠误差与范数**\n\n混叠误差为 $e_k = \\hat{a}_k - a_k$。\n\n情况 $N  0$：\n$e_0 = \\hat{a}_0 - a_0 = 1 - \\frac{1}{2} = \\frac{1}{2}$\n$e_k = \\hat{a}_k - a_k = 0 - 0 = 0$ 对于 $k = 1, \\dots, N$。\n所需的度量为：\n- 零阶系数的绝对误差：$|e_0| = \\frac{1}{2}$。\n- 模态误差 $2$-范数：$\\|e\\|_2 = \\left( \\sum_{k=0}^{N} e_k^2 \\right)^{1/2} = \\sqrt{e_0^2 + \\sum_{k=1}^{N} e_k^2} = \\sqrt{\\left(\\frac{1}{2}\\right)^2 + 0} = \\frac{1}{2}$。\n\n情况 $N = 0$：\n$e_0 = \\hat{a}_0 - a_0 = 1 - 1 = 0$。\n所需的度量为：\n- 零阶系数的绝对误差：$|e_0| = 0$。\n- 模态误差 $2$-范数：$\\|e\\|_2 = \\sqrt{e_0^2} = 0$。\n\n**测试用例总结**\n对于测试套件 $N \\in \\{0, 1, 7, 16, 31\\}$：\n- 对于 $N=0$：结果是 $[0.0, 0.0]$。\n- 对于 $N \\in \\{1, 7, 16, 31\\}$：结果是 $[0.5, 0.5]$。\n\n数值实现将构建并求解关于 $\\hat{a}_k$ 的线性系统，以验证这些分析结果。该系统为 $M \\mathbf{\\hat{a}} = \\mathbf{f}$，其中 $M_{jk} = T_k(x_j) = \\cos(k \\pi j / N)$ 且 $f_j = 1$。其解应在数值上得到 $\\mathbf{\\hat{a}} \\approx [1, 0, \\dots, 0]^T$，直至机器精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aliasing error for the collocation product of T_N(x)^2.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 7, 16, 31]\n\n    results = []\n    for N in test_cases:\n        # The problem asks to set up and solve the linear system numerically.\n        # This implementation follows that prescription.\n\n        # Handle the N=0 case separately to avoid division by zero.\n        if N == 0:\n            # Analytical result for N=0:\n            # f(x) = T_0(x)^2 = 1^2 = 1 = T_0(x).\n            # The projection is P_0 f(x) = T_0(x), so a_0 = 1.\n            # The grid is x_0=1, f(x_0)=1. The interpolant is I_0 f(x) = 1 = T_0(x), so a_hat_0 = 1.\n            # The error e_0 = a_hat_0 - a_0 = 1 - 1 = 0.\n            results.append([0.0, 0.0])\n            continue\n\n        # For N > 0:\n\n        # 1. Determine the exact N-mode modal projection coefficients, {a_k}.\n        # f(x) = T_N(x)^2 = 0.5 * T_0(x) + 0.5 * T_2N(x).\n        # The N-mode projection P_N f(x) truncates modes > N. Since N > 0, 2N > N.\n        # P_N f(x) = 0.5 * T_0(x).\n        # So, a_0 = 0.5 and a_k = 0 for k > 0.\n        a_k_exact = np.zeros(N + 1)\n        a_k_exact[0] = 0.5\n\n        # 2. Determine the collocation interpolant coefficients, {a_hat_k}.\n        # Define the Chebyshev-Lobatto grid nodes.\n        j_indices = np.arange(N + 1)\n        x_j = np.cos(np.pi * j_indices / N)\n\n        # Evaluate the function f(x) = T_N(x)^2 at the nodes.\n        # Analytically, f(x_j) = T_N(cos(pi*j/N))^2 = (cos(pi*j))^2 = 1 for all j.\n        # We compute this numerically as requested by the problem structure.\n        # Note: np.arccos(x_j) will numerically recover pi*j/N.\n        u_vals_at_nodes = np.cos(N * np.arccos(x_j))\n        f_vals_at_nodes = u_vals_at_nodes**2\n        # Due to floating point arithmetic, f_vals_at_nodes will be very close to 1.0.\n        # Using the exact analytical result f_j=1 is cleaner and avoids floating point noise\n        # in the RHS vector, which is consistent with the problem's analytical nature.\n        f_j = np.ones(N + 1)\n\n        # Construct the square linear system: sum_{k=0 to N} a_hat_k * T_k(x_j) = f_j\n        # The matrix M has entries M_jk = T_k(x_j).\n        k_indices = np.arange(N + 1)\n        # M_jk = cos(k * arccos(x_j)) = cos(k * pi*j/N)\n        M = np.cos(np.pi * np.outer(j_indices, k_indices) / N)\n\n        # Solve the system M * a_hat = f for the coefficients a_hat.\n        a_hat_k = np.linalg.solve(M, f_j)\n\n        # 3. Compute the aliasing error e_k = a_hat_k - a_k_exact.\n        e_k = a_hat_k - a_k_exact\n\n        # 4. Calculate the required metrics.\n        abs_error_mode_0 = np.abs(e_k[0])\n        modal_error_2_norm = np.linalg.norm(e_k)\n\n        results.append([abs_error_mode_0, modal_error_2_norm])\n    \n    # helper to format the output string correctly\n    def format_list(item):\n        return f\"[{item[0]},{item[1]}]\"\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(format_list, results))}]\")\n\nsolve()\n```", "id": "3370334"}]}