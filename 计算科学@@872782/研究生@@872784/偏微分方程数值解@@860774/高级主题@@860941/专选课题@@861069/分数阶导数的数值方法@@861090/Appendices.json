{"hands_on_practices": [{"introduction": "理解不同数值格式的精度对于选择和设计可靠的求解器至关重要。本练习 [@problem_id:3426262] 直接比较了用于Caputo导数的两种常用格式：L1格式和更高阶的Alikhanov格式，这两种格式是时间分数阶建模的基石。通过推导过程，您将对截断误差的来源和量级有一个具体而深刻的理解。", "problem": "考虑阶数为 $0  \\alpha  1$ 的时间分数阶Caputo导数，它出现在例如时间分数阶扩散偏微分方程 (PDE) 的时间离散化中。对于一个足够光滑的函数 $u(t)$，其Caputo导数定义为\n$$\n(\\prescript{C}{}{D}_{t}^{\\alpha} u)(t) \\;=\\; \\frac{1}{\\Gamma(1-\\alpha)} \\int_{0}^{t} (t-s)^{-\\alpha}\\, u'(s)\\, ds,\n$$\n其中 $\\Gamma(\\cdot)$ 表示欧拉伽马函数。设均匀时间网格为 $t_{n}=n\\tau$，步长为 $\\tau0$。在第一个时间层级上，$(\\prescript{C}{}{D}_{t}^{\\alpha} u)(t)$ 的两种经典近似方法是：\n\n- L1格式：在 $[0,\\tau]$ 上，通过数据点 $\\{(0,u(0)),(\\tau,u(\\tau))\\}$ 的分段线性插值的斜率来近似 $u'(s)$，然后将此近似代入 $t=\\tau$ 处的Caputo积分中。\n\n- Alikhanov格式（时间上二阶）：在 $[0,2\\tau]$ 上，通过数据点 $\\{(0,u(0)),(\\tau,u(\\tau)),(2\\tau,u(2\\tau))\\}$ 的二次拉格朗日插值来近似 $u(s)$，对该插值求导以获得在 $[0,\\tau]$ 上对 $u'(s)$ 的近似，然后将此导数代入 $t=\\tau$ 处的Caputo积分中。\n\n仅使用上述定义以及欧拉贝塔函数和伽马函数的标准性质，将两种格式应用于人造解 $u(t)=t^3$ 在 $t=\\tau$ 处。将L1近似和Alikhanov近似的绝对第一步误差 $E_{\\mathrm{L1}}(\\alpha,\\tau)$ 和 $E_{\\mathrm{A}}(\\alpha,\\tau)$ 分别定义为在 $t=\\tau$ 处，精确Caputo导数与每种格式的近似值之差的绝对值。\n\n推导比率的闭式解析表达式，并尽可能简化\n$$\nR(\\alpha)\\;=\\;\\lim_{\\tau\\to 0^{+}} \\frac{E_{\\mathrm{L1}}(\\alpha,\\tau)}{E_{\\mathrm{A}}(\\alpha,\\tau)},\n$$\n仅用 $\\alpha$ 的函数表示。\n\n你的最终答案必须是关于 $\\alpha$ 的单个简化解析表达式。不需要进行数值舍入。", "solution": "该问题被认为是有效的，因为它具有科学依据、问题明确且客观。它为推导解析表达式提供了一套清晰、独立的定义和说明，这是分数阶微分方程数值分析中的一项标准任务。\n\n求解过程分为四个主要步骤：\n1.  计算给定函数 $u(t)=t^3$ 在 $t=\\tau$ 处的精确Caputo导数。\n2.  推导L1近似及其相关误差 $E_{\\mathrm{L1}}(\\alpha,\\tau)$。\n3.  推导Alikhanov近似及其相关误差 $E_{\\mathrm{A}}(\\alpha,\\tau)$。\n4.  计算误差之比并评估当 $\\tau \\to 0^{+}$ 时的极限。\n\n**1. 精确Caputo导数**\n\n函数为 $u(t) = t^3$，所以其一阶导数为 $u'(t) = 3t^2$。在时间 $t=\\tau$ 处，阶数为 $\\alpha$ 的精确Caputo导数由下式给出：\n$$\n(\\prescript{C}{}{D}_{t}^{\\alpha} u)(\\tau) = \\frac{1}{\\Gamma(1-\\alpha)} \\int_{0}^{\\tau} (\\tau-s)^{-\\alpha} u'(s) ds\n$$\n代入 $u'(s) = 3s^2$：\n$$\n(\\prescript{C}{}{D}_{t}^{\\alpha} u)(\\tau) = \\frac{3}{\\Gamma(1-\\alpha)} \\int_{0}^{\\tau} (\\tau-s)^{-\\alpha} s^{2} ds\n$$\n为了计算该积分，我们进行变量替换 $s = \\tau y$，这意味着 $ds = \\tau dy$。积分上下限变为 $0$ 到 $1$。\n$$\n\\int_{0}^{\\tau} (\\tau-s)^{-\\alpha} s^{2} ds = \\int_{0}^{1} (\\tau-\\tau y)^{-\\alpha} (\\tau y)^{2} (\\tau dy) = \\tau^{3-\\alpha} \\int_{0}^{1} y^{2} (1-y)^{-\\alpha} dy\n$$\n所得积分为欧拉贝塔函数 $B(x,y) = \\int_{0}^{1} t^{x-1}(1-t)^{y-1} dt$。此处，$x-1=2$ 且 $y-1=-\\alpha$，所以 $x=3$ 且 $y=1-\\alpha$。\n$$\n\\int_{0}^{1} y^{2} (1-y)^{-\\alpha} dy = B(3, 1-\\alpha) = \\frac{\\Gamma(3)\\Gamma(1-\\alpha)}{\\Gamma(3+1-\\alpha)} = \\frac{2! \\Gamma(1-\\alpha)}{\\Gamma(4-\\alpha)} = \\frac{2\\Gamma(1-\\alpha)}{\\Gamma(4-\\alpha)}\n$$\n将此结果代回Caputo导数的表达式中：\n$$\n(\\prescript{C}{}{D}_{t}^{\\alpha} u)(\\tau) = \\frac{3}{\\Gamma(1-\\alpha)} \\tau^{3-\\alpha} \\frac{2\\Gamma(1-\\alpha)}{\\Gamma(4-\\alpha)} = \\frac{6}{\\Gamma(4-\\alpha)} \\tau^{3-\\alpha}\n$$\n\n**2. L1格式近似与误差**\n\nL1格式在 $[0, \\tau]$ 上用通过 $(0, u(0))$ 和 $(\\tau, u(\\tau))$ 的线性插值的恒定斜率来近似 $u'(s)$。对于 $u(t)=t^3$，这些点是 $(0, 0)$ 和 $(\\tau, \\tau^3)$。\n斜率为 $\\frac{u(\\tau)-u(0)}{\\tau-0} = \\frac{\\tau^3-0}{\\tau} = \\tau^2$。\nL1近似（我们记作 $D_{\\mathrm{L1}}^{\\alpha} u(\\tau)$）为：\n$$\nD_{\\mathrm{L1}}^{\\alpha} u(\\tau) = \\frac{1}{\\Gamma(1-\\alpha)} \\int_{0}^{\\tau} (\\tau-s)^{-\\alpha} (\\tau^{2}) ds = \\frac{\\tau^{2}}{\\Gamma(1-\\alpha)} \\left[ -\\frac{(\\tau-s)^{1-\\alpha}}{1-\\alpha} \\right]_{s=0}^{s=\\tau}\n$$\n$$\nD_{\\mathrm{L1}}^{\\alpha} u(\\tau) = \\frac{\\tau^{2}}{\\Gamma(1-\\alpha)} \\left( 0 - \\left(-\\frac{\\tau^{1-\\alpha}}{1-\\alpha}\\right) \\right) = \\frac{\\tau^{3-\\alpha}}{(1-\\alpha)\\Gamma(1-\\alpha)}\n$$\n使用性质 $\\Gamma(z+1)=z\\Gamma(z)$，我们有 $(1-\\alpha)\\Gamma(1-\\alpha) = \\Gamma(2-\\alpha)$。\n$$\nD_{\\mathrm{L1}}^{\\alpha} u(\\tau) = \\frac{1}{\\Gamma(2-\\alpha)} \\tau^{3-\\alpha}\n$$\n绝对第一步误差 $E_{\\mathrm{L1}}(\\alpha,\\tau)$ 为：\n$$\nE_{\\mathrm{L1}}(\\alpha,\\tau) = \\left| (\\prescript{C}{}{D}_{t}^{\\alpha} u)(\\tau) - D_{\\mathrm{L1}}^{\\alpha} u(\\tau) \\right| = \\left| \\frac{6}{\\Gamma(4-\\alpha)} - \\frac{1}{\\Gamma(2-\\alpha)} \\right| \\tau^{3-\\alpha}\n$$\n使用 $\\Gamma(4-\\alpha) = (3-\\alpha)(2-\\alpha)\\Gamma(2-\\alpha)$：\n$$\nE_{\\mathrm{L1}}(\\alpha,\\tau) = \\left| \\frac{6}{(3-\\alpha)(2-\\alpha)\\Gamma(2-\\alpha)} - \\frac{(3-\\alpha)(2-\\alpha)}{(3-\\alpha)(2-\\alpha)\\Gamma(2-\\alpha)} \\right| \\tau^{3-\\alpha}\n$$\n$$\nE_{\\mathrm{L1}}(\\alpha,\\tau) = \\left| \\frac{6 - (6 - 5\\alpha + \\alpha^{2})}{(3-\\alpha)(2-\\alpha)\\Gamma(2-\\alpha)} \\right| \\tau^{3-\\alpha} = \\frac{|\\alpha(5-\\alpha)|}{(3-\\alpha)(2-\\alpha)\\Gamma(2-\\alpha)} \\tau^{3-\\alpha}\n$$\n因为 $0  \\alpha  1$，项 $\\alpha(5-\\alpha)$ 是正的。因此，不需要绝对值符号。\n$$\nE_{\\mathrm{L1}}(\\alpha,\\tau) = \\frac{\\alpha(5-\\alpha)}{(3-\\alpha)(2-\\alpha)\\Gamma(2-\\alpha)} \\tau^{3-\\alpha}\n$$\n\n**3. Alikhanov格式近似与误差**\n\nAlikhanov格式通过点 $(0, u(0))$、$(\\tau, u(\\tau))$ 和 $(2\\tau, u(2\\tau))$ 的二次拉格朗日插值多项式 $P_2(s)$ 来近似 $u(s)$。对于 $u(t)=t^3$，这些点是 $(0, 0)$、$(\\tau, \\tau^3)$ 和 $(2\\tau, 8\\tau^3)$。插值多项式为 $P_2(s) = u(s) - \\frac{u'''(\\xi)}{3!}s(s-\\tau)(s-2\\tau)$。因为 $u'''(s)=6$，这给出 $P_2(s) = s^3 - s(s-\\tau)(s-2\\tau) = s^3 - (s^3-3\\tau s^2+2\\tau^2s) = 3\\tau s^2 - 2\\tau^2s$。\n该格式用 $P_2'(s) = 6\\tau s - 2\\tau^2$ 来近似 $u'(s)$。\nAlikhanov近似 $D_{\\mathrm{A}}^{\\alpha} u(\\tau)$ 为：\n$$\nD_{\\mathrm{A}}^{\\alpha} u(\\tau) = \\frac{1}{\\Gamma(1-\\alpha)} \\int_{0}^{\\tau} (\\tau-s)^{-\\alpha} (6\\tau s - 2\\tau^{2}) ds\n$$\n$$\nD_{\\mathrm{A}}^{\\alpha} u(\\tau) = \\frac{6\\tau}{\\Gamma(1-\\alpha)} \\int_{0}^{\\tau} s(\\tau-s)^{-\\alpha} ds - \\frac{2\\tau^{2}}{\\Gamma(1-\\alpha)} \\int_{0}^{\\tau} (\\tau-s)^{-\\alpha} ds\n$$\n第一个积分是 $\\tau^{2-\\alpha} B(2, 1-\\alpha) = \\tau^{2-\\alpha} \\frac{\\Gamma(2)\\Gamma(1-\\alpha)}{\\Gamma(3-\\alpha)} = \\tau^{2-\\alpha} \\frac{\\Gamma(1-\\alpha)}{\\Gamma(3-\\alpha)}$。第二个积分是 $\\frac{\\tau^{1-\\alpha}}{1-\\alpha}$。\n$$\nD_{\\mathrm{A}}^{\\alpha} u(\\tau) = \\frac{6\\tau}{\\Gamma(1-\\alpha)} \\left(\\tau^{2-\\alpha} \\frac{\\Gamma(1-\\alpha)}{\\Gamma(3-\\alpha)}\\right) - \\frac{2\\tau^{2}}{\\Gamma(1-\\alpha)} \\frac{\\tau^{1-\\alpha}}{1-\\alpha}\n$$\n$$\nD_{\\mathrm{A}}^{\\alpha} u(\\tau) = \\frac{6\\tau^{3-\\alpha}}{\\Gamma(3-\\alpha)} - \\frac{2\\tau^{3-\\alpha}}{\\Gamma(2-\\alpha)} = \\left( \\frac{6}{\\Gamma(3-\\alpha)} - \\frac{2(2-\\alpha)}{\\Gamma(3-\\alpha)} \\right) \\tau^{3-\\alpha}\n$$\n$$\nD_{\\mathrm{A}}^{\\alpha} u(\\tau) = \\frac{6-4+2\\alpha}{\\Gamma(3-\\alpha)} \\tau^{3-\\alpha} = \\frac{2(1+\\alpha)}{\\Gamma(3-\\alpha)} \\tau^{3-\\alpha}\n$$\n绝对第一步误差 $E_{\\mathrm{A}}(\\alpha,\\tau)$ 为：\n$$\nE_{\\mathrm{A}}(\\alpha,\\tau) = \\left| (\\prescript{C}{}{D}_{t}^{\\alpha} u)(\\tau) - D_{\\mathrm{A}}^{\\alpha} u(\\tau) \\right| = \\left| \\frac{6}{\\Gamma(4-\\alpha)} - \\frac{2(1+\\alpha)}{\\Gamma(3-\\alpha)} \\right| \\tau^{3-\\alpha}\n$$\n使用 $\\Gamma(4-\\alpha) = (3-\\alpha)\\Gamma(3-\\alpha)$：\n$$\nE_{\\mathrm{A}}(\\alpha,\\tau) = \\left| \\frac{6}{(3-\\alpha)\\Gamma(3-\\alpha)} - \\frac{2(1+\\alpha)(3-\\alpha)}{(3-\\alpha)\\Gamma(3-\\alpha)} \\right| \\tau^{3-\\alpha}\n$$\n$$\nE_{\\mathrm{A}}(\\alpha,\\tau) = \\left| \\frac{6 - 2(3+2\\alpha-\\alpha^{2})}{(3-\\alpha)\\Gamma(3-\\alpha)} \\right| \\tau^{3-\\alpha} = \\frac{|-4\\alpha+2\\alpha^{2}|}{(3-\\alpha)\\Gamma(3-\\alpha)} \\tau^{3-\\alpha} = \\frac{|2\\alpha(\\alpha-2)|}{(3-\\alpha)\\Gamma(3-\\alpha)} \\tau^{3-\\alpha}\n$$\n因为 $0  \\alpha  1$，$\\alpha-2$ 是负的。因此，$|\\alpha-2| = 2-\\alpha$。\n$$\nE_{\\mathrm{A}}(\\alpha,\\tau) = \\frac{2\\alpha(2-\\alpha)}{(3-\\alpha)\\Gamma(3-\\alpha)} \\tau^{3-\\alpha}\n$$\n\n**4. 误差之比**\n\n误差之比为：\n$$\n\\frac{E_{\\mathrm{L1}}(\\alpha,\\tau)}{E_{\\mathrm{A}}(\\alpha,\\tau)} = \\frac{\\frac{\\alpha(5-\\alpha)}{(3-\\alpha)(2-\\alpha)\\Gamma(2-\\alpha)} \\tau^{3-\\alpha}}{\\frac{2\\alpha(2-\\alpha)}{(3-\\alpha)\\Gamma(3-\\alpha)} \\tau^{3-\\alpha}}\n$$\n我们消去公因子 $\\tau^{3-\\alpha}$、$\\alpha$ 和 $(3-\\alpha)$：\n$$\n\\frac{E_{\\mathrm{L1}}(\\alpha,\\tau)}{E_{\\mathrm{A}}(\\alpha,\\tau)} = \\frac{\\frac{5-\\alpha}{(2-\\alpha)\\Gamma(2-\\alpha)}}{\\frac{2(2-\\alpha)}{\\Gamma(3-\\alpha)}}\n$$\n使用 $\\Gamma(3-\\alpha) = (2-\\alpha)\\Gamma(2-\\alpha)$：\n$$\n\\frac{E_{\\mathrm{L1}}(\\alpha,\\tau)}{E_{\\mathrm{A}}(\\alpha,\\tau)} = \\frac{\\frac{5-\\alpha}{(2-\\alpha)\\Gamma(2-\\alpha)}}{\\frac{2(2-\\alpha)}{(2-\\alpha)\\Gamma(2-\\alpha)}} = \\frac{\\frac{5-\\alpha}{(2-\\alpha)\\Gamma(2-\\alpha)}}{\\frac{2}{\\Gamma(2-\\alpha)}} = \\frac{5-\\alpha}{2-\\alpha} \\cdot \\frac{1}{2} = \\frac{5-\\alpha}{2(2-\\alpha)}\n$$\n该比率与 $\\tau$ 无关。因此，极限就是该表达式本身。\n$$\nR(\\alpha) = \\lim_{\\tau\\to 0^{+}} \\frac{E_{\\mathrm{L1}}(\\alpha,\\tau)}{E_{\\mathrm{A}}(\\alpha,\\tau)} = \\frac{5-\\alpha}{2(2-\\alpha)} = \\frac{5-\\alpha}{4-2\\alpha}\n$$", "answer": "$$\\boxed{\\frac{5-\\alpha}{4-2\\alpha}}$$", "id": "3426262"}, {"introduction": "将理论分析付诸实践是掌握数值方法的关键一步。本练习 [@problem_id:3426234] 将指导您为一个简单分数阶常微分方程编写时间步进求解器。通过考察当分数阶导数阶次 $\\alpha$ 趋近于零时格式的行为，本练习将着重揭示正确处理Caputo导数初始条件的关键性，并诊断出一种常见的天真实现方式中的陷阱。", "problem": "考虑一个源于时间分数阶偏微分方程背景的分数阶常微分方程初值问题，写成Caputo形式：求一个函数 $u:[0,T]\\to\\mathbb{R}$ 使得\n$$\nD_t^\\alpha u(t) = f(t), \\quad t\\in(0,T], \\quad u(0)=u_0\n$$\n其中 $D_t^\\alpha$ 表示 $\\alpha\\in(0,1)$ 阶的Caputo分数阶导数，而 $f$ 是一个给定的源项。Caputo分数阶导数是通过将 $1-\\alpha$ 阶的Riemann–Liouville积分应用于一阶导数来定义的，\n$$\nD_t^\\alpha u(t) := I^{1-\\alpha} u'(t), \\qquad I^\\beta v(t) := \\frac{1}{\\Gamma(\\beta)}\\int_0^t (t-s)^{\\beta-1} v(s)\\,\\mathrm{d}s, \\quad \\beta>0.\n$$\n一个经过充分检验的事实是，对于足够正则的 $u$，极限 $\\alpha\\to 0^+$ 会得到\n$$\n\\lim_{\\alpha\\to 0^+} D_t^\\alpha u(t) = u(t)-u(0) \\quad \\text{for } t>0,\n$$\n这意味着，形式上，$D_t^\\alpha u = f$ 的解在 $\\alpha\\to 0^+$ 时满足 $u(t)\\to u_0+f(t)$（对于 $t0$）。\n\n你的任务是从第一性原理出发，推导一个能够正确捕捉 $\\alpha\\to 0^+$ 极限的稳定且相容的时间步进格式，并将其实现。此外，还要实现一个错误处理极限记忆的朴素离散化方法，并诊断其失效的原因。从以下基本概念出发：\n- Caputo导数 $D_t^\\alpha u$ 基于 $I^{1-\\alpha} u'(t)$ 的定义（对于 $\\alpha\\in(0,1)$）。\n- 用于一阶导数的经典后向欧拉方法以及卷积求积（Convolution Quadrature, CQ）的概念。对于一个生成函数为 $\\delta(z)$ 的线性多步法，CQ通过 $\\delta(z)^\\alpha$ 的幂级数产生离散卷积权重。\n- Caputo初值修正，即在分数阶算子内部用 $u-u(0)$ 替换 $u$，从而在 $t=0$ 处一致地施加初始条件。\n\n在均匀网格 $t_n = n\\tau$, $n=0,1,\\dots,N$（其中 $\\tau = T/N$）上设计以下两种全离散时间格式：\n- 一种基于后向欧拉卷积求积（CQ）的Caputo相容格式，该格式包含Caputo初值修正，使得当 $\\alpha\\to 0^+$ 时，格式恢复为 $u^n \\approx u_0 + f(t_n)$（对于 $n\\ge 1$）。\n- 一种朴素的Grünwald型格式，该格式省略了Caputo初值修正，因此无法恢复正确的极限，而是在 $\\alpha\\to 0^+$ 时趋向于 $u^n \\approx f(t_n)$。\n\n然后，对于每个离散时间层级 $n\\in\\{1,2,\\dots,N\\}$，将每种格式得到的 $u^n$ 与极限目标 $u_0+f(t_n)$ 进行比较，并计算在正时间 $t_n0$ 上的最大绝对偏差：\n$$\nE_{\\mathrm{cap}} := \\max_{1\\le n\\le N} \\big|u^n_{\\mathrm{cap}} - (u_0+f(t_n))\\big|, \\qquad E_{\\mathrm{naive}} := \\max_{1\\le n\\le N} \\big|u^n_{\\mathrm{naive}} - (u_0+f(t_n))\\big|.\n$$\n\n角度单位要求：当使用三角函数时，其参数应解释为弧度。\n\n测试套件。使用以下测试用例来评估这两种格式。对于每个测试，报告如上指定的两个实数 $E_{\\mathrm{cap}}$ 和 $E_{\\mathrm{naive}}$。\n- 测试 1：$\\alpha=10^{-2}$，$u_0=1.3$，$T=1$，$N=200$，$f(t)=\\sin(t)$，参数单位为弧度。\n- 测试 2：$\\alpha=10^{-6}$，$u_0=-0.7$，$T=1$，$N=200$，$f(t)=\\mathrm{e}^{-t}$。\n- 测试 3：$\\alpha=10^{-3}$，$u_0=0$，$T=1$，$N=20$，$f(t)=t^2$。\n- 测试 4：$\\alpha=5\\times 10^{-2}$，$u_0=2$，$T=2$，$N=400$，$f(t)=\\cos(3t)$，参数单位为弧度。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$\n[E_{\\mathrm{cap}}^{(1)},E_{\\mathrm{naive}}^{(1)},E_{\\mathrm{cap}}^{(2)},E_{\\mathrm{naive}}^{(2)},E_{\\mathrm{cap}}^{(3)},E_{\\mathrm{naive}}^{(3)},E_{\\mathrm{cap}}^{(4)},E_{\\mathrm{naive}}^{(4)}],\n$\n其中上标表示测试编号。所有输出都必须是实数（浮点数）。不应打印任何其他文本。", "solution": "目标是在均匀网格 $t_n = n\\tau$（$n=0, 1, \\dots, N$，步长 $\\tau = T/N$）上数值求解初值问题\n$$\nD_t^\\alpha u(t) = f(t), \\quad t\\in(0,T], \\qquad u(0)=u_0,\n$$\n我们将 $u(t_n)$ 的数值近似表示为 $u^n$，将 $f(t_n)$ 表示为 $f_n$。\n\n该方法的核心是使用基于后向欧拉方法的卷积求积（CQ）来离散化Caputo导数算子 $D_t^\\alpha$。连续算子 $D_t^\\alpha$ 的拉普拉斯符号是 $s^\\alpha$。对于后向欧拉方法，一阶导数近似为 $\\frac{v(t) - v(t-\\tau)}{\\tau}$，这在 $z$ 变换域中对应于将微分算子 $\\partial_t$ 替换为 $\\delta(z)/\\tau = (1-z^{-1})/\\tau$。我们将使用生成函数 $\\delta(\\zeta)=1-\\zeta$。因此，与 $s^\\alpha$ 对应的离散算子是 $(\\delta(\\zeta)/\\tau)^\\alpha = \\tau^{-\\alpha}(1-\\zeta)^\\alpha$。\n\n离散卷积权重的生成函数 $(1-\\zeta)^\\alpha$ 使用广义二项式定理展开：\n$$\n(1-\\zeta)^\\alpha = \\sum_{j=0}^\\infty \\binom{\\alpha}{j} (-\\zeta)^j =: \\sum_{j=0}^\\infty g_j \\zeta^j.\n$$\n卷积权重为 $g_j = (-1)^j \\binom{\\alpha}{j}$。这些权重可以通过递推关系高效计算：\n$$\ng_0 = 1, \\qquad g_j = \\left(1 - \\frac{\\alpha+1}{j}\\right) g_{j-1} \\quad \\text{for } j \\ge 1.\n$$\n一个时间索引序列 $\\{v^k\\}_{k=0}^N$ 的离散分数阶导数，记为 $(\\partial_\\tau^\\alpha v)^n$，则定义为离散卷积：\n$$\n(\\partial_\\tau^\\alpha v)^n := \\tau^{-\\alpha} \\sum_{j=0}^n g_j v^{n-j}.\n$$\n\n正如问题中所强调的，关键方面是如何处理初始条件 $u(0) = u_0$。这导致了两种不同的格式。\n\n**格式 1：Caputo相容格式**\n\n该格式包含了“初值修正”。其动机是恒等式 $D_t^\\alpha u(t) = D_t^\\alpha (u(t) - u_0)$，该恒等式成立是因为常数的导数为零。我们将离散分数阶算子应用于函数 $v(t) = u(t) - u_0$，该函数具有零初值 $v(0)=0$。离散序列为 $v^n = u^n - u_0$，其中 $v^0 = u^0 - u_0 = 0$。\n\n在 $t=t_n$ 处的离散方程是 $(\\partial_\\tau^\\alpha v)^n = f_n$，展开后为：\n$$\n\\tau^{-\\alpha} \\sum_{j=0}^n g_j v^{n-j} = f_n \\implies \\tau^{-\\alpha} \\sum_{j=0}^n g_j (u^{n-j} - u_0) = f_n.\n$$\n重新整理各项以求解 $u^n$：\n$$\n\\sum_{j=0}^n g_j u^{n-j} - u_0 \\sum_{j=0}^n g_j = \\tau^\\alpha f_n.\n$$\n从第一个和式中分离出 $j=0$ 的项（因为 $g_0=1$）：\n$$\ng_0 u^n + \\sum_{j=1}^n g_j u^{n-j} = \\tau^\\alpha f_n + u_0 \\sum_{j=0}^n g_j.\n$$\n$$\nu^n = \\tau^\\alpha f_n + u_0 \\sum_{j=0}^n g_j - \\sum_{j=1}^n g_j u^{n-j}.\n$$\n这定义了Caputo相容格式 $u^n_{\\mathrm{cap}}$ 的时间步进规则。\n让我们分析其在 $\\alpha \\to 0^+$ 时的行为。对于固定的 $j \\ge 1$，权重 $g_j = (-1)^j \\binom{\\alpha}{j} = O(\\alpha) \\to 0$。权重之和 $\\sum_{j=0}^n g_j$ 是 $(1-1)^\\alpha=0$ 的级数的部分和，但被截断了。对于任意 $z \\in (-1,1)$，$\\sum_{j=0}^\\infty g_j z^j = (1-z)^\\alpha$。当 $\\alpha \\to 0^+$ 时，$(1-z)^\\alpha \\to 1$。直观上，这表明当 $\\alpha \\to 0^+$ 时 $\\sum_{j=0}^n g_j \\to 1$（因为 $g_0=1$ 且对于 $j \\ge 1$ 有 $g_j \\to 0$）。同样，我们有 $\\tau^\\alpha \\to 1$。\n格式变为：\n$$\nu^n_{\\mathrm{cap}} \\to 1 \\cdot f_n + u_0 \\cdot 1 - \\sum_{j=1}^n (0) \\cdot u^{n-j}_{\\mathrm{cap}} = u_0 + f_n.\n$$\n这正确地捕捉了所期望的极限行为。\n\n**格式 2：朴素格式**\n\n该格式省略了初值修正，并将离散算子直接应用于序列 $\\{u^n\\}$，该序列不从零开始（$u^0=u_0$）。\n离散方程为 $(\\partial_\\tau^\\alpha u)^n = f_n$：\n$$\n\\tau^{-\\alpha} \\sum_{j=0}^n g_j u^{n-j} = f_n.\n$$\n分离出 $j=0$ 的项以求解 $u^n$：\n$$\ng_0 u^n + \\sum_{j=1}^n g_j u^{n-j} = \\tau^\\alpha f_n.\n$$\n$$\nu^n = \\tau^\\alpha f_n - \\sum_{j=1}^n g_j u^{n-j}.\n$$\n这定义了朴素格式 $u^n_{\\mathrm{naive}}$ 的时间步进规则。\n让我们分析其在 $\\alpha \\to 0^+$ 时的行为。和之前一样，对于 $j \\ge 1$ 有 $g_j \\to 0$ 且 $\\tau^\\alpha \\to 1$。更新规则简化为：\n$$\nu^n_{\\mathrm{naive}} \\to 1 \\cdot f_n - \\sum_{j=1}^n (0) \\cdot u^{n-j}_{\\mathrm{naive}} = f_n.\n$$\n该格式未能恢复初始条件的贡献，趋向于 $f_n$ 而不是 $u_0 + f_n$。\n\n**实现方案总结**\n\n对于 $n=1, 2, \\dots, N$，且 $u^0 = u_0$：\n- **Caputo相容格式：**\n  $u^n_{\\mathrm{cap}} = \\tau^\\alpha f_n + u_0 S_n - \\sum_{j=1}^n g_j u^{n-j}_{\\mathrm{cap}}$，其中 $S_n = \\sum_{j=0}^n g_j$。\n- **朴素格式：**\n  $u^n_{\\mathrm{naive}} = \\tau^\\alpha f_n - \\sum_{j=1}^n g_j u^{n-j}_{\\mathrm{naive}}$。\n\n实现时将预先计算权重 $g_j$ 及其累加和 $S_n$，然后进行时间步进循环，在每一步计算卷积和。最后，通过将数值解与极限目标解 $u_0 + f(t_n)$（对于 $n \\ge 1$）进行比较，来计算误差 $E_{\\mathrm{cap}}$ 和 $E_{\\mathrm{naive}}$。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(alpha, u0, T, N, f_func):\n    \"\"\"\n    Solves the fractional ODE using two schemes and computes their error.\n\n    Args:\n        alpha (float): The order of the fractional derivative.\n        u0 (float): The initial condition u(0).\n        T (float): The final time.\n        N (int): The number of time steps.\n        f_func (callable): The source function f(t).\n\n    Returns:\n        tuple[float, float]: A tuple containing E_cap and E_naive.\n    \"\"\"\n    # 1. Setup grid and parameters\n    tau = T / N\n    t = np.linspace(0, T, N + 1)\n    f_vals = f_func(t)\n\n    # 2. Precompute convolution weights g_j and their cumulative sum S_j\n    # The weights g_j are related to the coefficients of (1-zeta)^alpha.\n    # g_j = (-1)^j * binom(alpha, j)\n    # The recurrence g_j = g_{j-1} * (1 - (alpha + 1) / j) is used.\n    g = np.zeros(N + 1)\n    g[0] = 1.0\n    for j in range(1, N + 1):\n        g[j] = g[j - 1] * (1 - (alpha + 1) / j)\n\n    S = np.cumsum(g)\n\n    # 3. Initialize solution arrays\n    u_cap = np.zeros(N + 1)\n    u_naive = np.zeros(N + 1)\n    u_cap[0] = u0\n    u_naive[0] = u0\n\n    tau_alpha = tau**alpha\n\n    # 4. Time-stepping loop\n    for n in range(1, N + 1):\n        # Convolution sum: sum_{j=1 to n} g_j * u_{n-j}\n        # u_cap[n-1::-1] is (u_{n-1}, u_{n-2}, ..., u_0)\n        # g[1:n+1] is (g_1, g_2, ..., g_n)\n        conv_cap = np.dot(g[1:n + 1], u_cap[n - 1::-1])\n        conv_naive = np.dot(g[1:n + 1], u_naive[n - 1::-1])\n\n        # Caputo-consistent scheme update\n        u_cap[n] = tau_alpha * f_vals[n] + u0 * S[n] - conv_cap\n\n        # Naive scheme update\n        u_naive[n] = tau_alpha * f_vals[n] - conv_naive\n\n    # 5. Calculate errors against the limiting target solution u0 + f(t)\n    target_solution = u0 + f_vals\n    \n    # Error is max absolute difference for t_n  0 (i.e., n = 1)\n    E_cap = np.max(np.abs(u_cap[1:] - target_solution[1:]))\n    E_naive = np.max(np.abs(u_naive[1:] - target_solution[1:]))\n    \n    return E_cap, E_naive\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {'alpha': 1e-2, 'u0': 1.3, 'T': 1, 'N': 200, 'f': lambda t: np.sin(t)},\n        {'alpha': 1e-6, 'u0': -0.7, 'T': 1, 'N': 200, 'f': lambda t: np.exp(-t)},\n        {'alpha': 1e-3, 'u0': 0.0, 'T': 1, 'N': 20, 'f': lambda t: t**2},\n        {'alpha': 5e-2, 'u0': 2.0, 'T': 2, 'N': 400, 'f': lambda t: np.cos(3*t)},\n    ]\n\n    results = []\n    for case in test_cases:\n        E_cap, E_naive = run_simulation(case['alpha'], case['u0'], case['T'], case['N'], case['f'])\n        results.append(E_cap)\n        results.append(E_naive)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3426234"}, {"introduction": "将注意力从时间分数阶问题转移到空间分数阶问题，本练习 [@problem_id:3426256] 介绍了谱分数阶拉普拉斯算子，并引入了在科学计算中至关重要的代码验证技术——“人造解”方法。您将实现一个求解器，并数值化地验证其收敛速度，这是开发可靠科学计算软件的一项基本技能。", "problem": "考虑具有齐次 Dirichlet 边界条件的一维有界域 $(0,1)$。令 $-\\Delta$ 表示与二阶导数相关的经典 Laplacian 算子，并令 $(-\\Delta)^s$（其中 $s \\in (0,1)$）表示在 $(0,1)$ 上通过关于 Dirichlet 边界条件下 $-\\Delta$ 的特征基的泛函演算定义的光谱分数阶 Laplacian。构造解方法通过构造一个具有已知右端项的精确解来验证数值方法。在本问题中，选择构造解 $u(x) = \\sin(m\\pi x)$（其中 $m$ 为正整数），并定义 $f(x)$，使得分数阶 Poisson 问题\n$$\n(-\\Delta)^s u(x) = f(x), \\quad x \\in (0,1), \\quad u(0)=u(1)=0,\n$$\n精确满足。您可以假设在 $(0,1)$ 上带有齐次 Dirichlet 边界条件的 $(-\\Delta)^s$ 的谱定义是基于经典 Dirichlet Laplacian 的特征函数和特征值。三角函数中的角度必须以弧度为单位。\n\n从以下基本前提开始：\n- $(0,1)$ 上的经典 Dirichlet Laplacian $-\\Delta$ 具有一组完备的正交归一特征函数，其特征值为实正数。\n- 谱分数阶 Laplacian $(-\\Delta)^s$ 是通过在其谱分解中将分数次幂 $s$ 应用于 $-\\Delta$ 的特征值来定义的。\n- 用于均匀网格上经典 Dirichlet Laplacian 的有限差分法 (FDM) 产生一个近似该算子的对称正定矩阵。\n\n设计一个数值方法，该方法：\n- 使用标准的二阶中心 FDM，在具有 $N$ 个内部点的均匀网格上构建离散 Dirichlet Laplacian 矩阵。\n- 通过其特征分解计算该矩阵的谱分数次幂。\n- 针对从所选 $u(x)$ 和 $(-\\Delta)^s$ 的谱定义获得的构造右端项 $f(x)$，求解离散分数阶 Poisson 问题。\n- 在内部网格点处评估数值解 $u_h$，并将其与相同网格点处的精确解样本 $u(x_i)$ 进行比较。\n- 使用由下式定义的离散 $L^2$ 误差\n$$\nE(N) = \\left( h \\sum_{i=1}^{N} \\left| u_h(x_i) - u(x_i) \\right|^2 \\right)^{1/2},\n$$\n其中 $h = \\frac{1}{N+1}$ 且 $x_i = i h$ 是内部网格点。\n\n通过计算在两次连续的网格加密 $N \\to 2N$ 下的量\n$$\n\\rho(N \\to 2N) = \\frac{\\log\\left(E(N)/E(2N)\\right)}{\\log(2)}.\n$$\n来估计观测到的收敛率。\n对于每个测试用例，报告一个浮点数，该浮点数等于在三个网格尺寸 $N_1  N_2  N_3$ 下两次连续加密率 $\\rho(N_1 \\to N_2)$ 和 $\\rho(N_2 \\to N_3)$ 的平均值。\n\n测试套件：\n- 用例 1：$s = 0.25$, $m = 1$, $N_1 = 50$, $N_2 = 100$, $N_3 = 200$。\n- 用例 2：$s = 0.50$, $m = 1$, $N_1 = 50$, $N_2 = 100$, $N_3 = 200$。\n- 用例 3：$s = 0.75$, $m = 3$, $N_1 = 50$, $N_2 = 100$, $N_3 = 200$。\n- 用例 4：$s = 0.99$, $m = 1$, $N_1 = 50$, $N_2 = 100$, $N_3 = 200$。\n\n$\\sin$ 中的所有角度均以弧度为单位。不涉及物理单位。您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是第 $k$ 个测试用例的两次连续加密率的平均值。每个列表元素必须是浮点数。", "solution": "用户提供了一个问题陈述，要求使用构造解来验证一维分数阶 Poisson 问题的数值方法。该问题在科学上是合理的、适定的，并包含获得唯一解所需的所有信息。因此，我们可以继续进行完整的解答。\n\n### 1. 数学公式\n\n所考虑的问题是在域 $\\Omega = (0,1)$ 上具有齐次 Dirichlet 边界条件的分数阶 Poisson 方程：\n$$\n\\begin{cases}\n(-\\Delta)^s u(x) = f(x),  x \\in (0,1) \\\\\nu(0) = u(1) = 0\n\\end{cases}\n$$\n其中 $s \\in (0,1)$ 是分数阶。算子 $(-\\Delta)^s$ 是谱分数阶 Laplacian。\n\n在 $(0,1)$ 上具有齐次 Dirichlet 边界条件的经典 Laplacian 算子 $-\\Delta = -d^2/dx^2$ 有一组已知的特征值 $\\lambda_k$ 和相应的正交归一特征函数 $\\phi_k(x)$：\n$$\n\\lambda_k = (k\\pi)^2, \\quad \\phi_k(x) = \\sqrt{2}\\sin(k\\pi x), \\quad k = 1, 2, 3, \\dots\n$$\n适当函数空间中的任何函数 $g(x)$ 都可以通过其特征函数展开式 $g(x) = \\sum_{k=1}^{\\infty} c_k \\phi_k(x)$ 表示，其中 $c_k = \\int_0^1 g(x) \\phi_k(x) dx$。谱分数阶 Laplacian 通过其在此展开式上的作用来定义：\n$$\n(-\\Delta)^s g(x) = \\sum_{k=1}^{\\infty} c_k \\lambda_k^s \\phi_k(x)\n$$\n问题指定了一个构造解 $u(x) = \\sin(m\\pi x)$，其中 $m$ 是某个正整数。这个选择很方便，因为 $u(x)$ 与第 $m$ 个特征函数 $\\phi_m(x)$ 成正比：$u(x) = \\frac{1}{\\sqrt{2}}\\phi_m(x)$。\n将分数阶算子应用于 $u(x)$，我们得到：\n$$\n(-\\Delta)^s u(x) = (-\\Delta)^s \\left( \\frac{1}{\\sqrt{2}}\\phi_m(x) \\right) = \\frac{1}{\\sqrt{2}} \\lambda_m^s \\phi_m(x)\n$$\n代入 $\\lambda_m$ 和 $\\phi_m(x)$ 的表达式：\n$$\n(-\\Delta)^s u(x) = \\frac{1}{\\sqrt{2}} ((m\\pi)^2)^s (\\sqrt{2}\\sin(m\\pi x)) = (m\\pi)^{2s} \\sin(m\\pi x)\n$$\n因此，为了用构造解 $u(x)$ 满足该方程，右端项函数 $f(x)$ 必须是：\n$$\nf(x) = (m\\pi)^{2s} \\sin(m\\pi x)\n$$\n\n### 2. 数值离散化\n\n连续域 $(0,1)$ 使用具有 $N$ 个内部点的均匀网格进行离散化。设网格间距为 $h = 1/(N+1)$。网格点为 $x_i = i h$，其中 $i = 0, 1, \\dots, N+1$。内部点为 $\\{x_i\\}_{i=1}^N$。令 $u_h$ 为 $u(x)$ 在这些内部点处的数值近似向量，即 $u_h = [u(x_1), u(x_2), \\dots, u(x_N)]^T$。\n\n经典 Laplacian $-\\Delta$ 使用二阶中心有限差分格式进行近似：\n$$\n-\\frac{d^2u}{dx^2}\\bigg|_{x=x_i} \\approx \\frac{-u(x_{i-1}) + 2u(x_i) - u(x_{i+1})}{h^2}\n$$\n结合边界条件 $u(x_0)=u(0)=0$ 和 $u(x_{N+1})=u(1)=0$，该离散化导出一个 $N \\times N$ 的矩阵系统。离散 Laplacian 算子，记作 $A_h$，是一个对称正定矩阵：\n$$\nA_h = \\frac{1}{h^2}\n\\begin{pmatrix}\n2   -1  0  \\dots  0 \\\\\n-1  2  -1  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots    -1  2  -1 \\\\\n0  \\dots  0  -1  2\n\\end{pmatrix}\n$$\n\n### 3. 求解离散分数阶系统\n\n该数值方法是谱定义的离散模拟。离散分数阶 Laplacian $A_h^s$ 是通过 $A_h$ 的特征分解来计算的。设 $A_h$ 的特征分解为：\n$$\nA_h = V \\Lambda V^T\n$$\n其中 $\\Lambda$ 是一个包含 $A_h$ 特征值 $\\mu_k$ 的对角矩阵，而 $V$ 是一个正交矩阵，其列是相应的特征向量 $v_k$。矩阵幂 $A_h^s$ 则定义为：\n$$\nA_h^s = V \\Lambda^s V^T\n$$\n其中 $\\Lambda^s$ 是对角元素为 $\\mu_k^s$ 的对角矩阵。\n\n分数阶 Poisson 问题的离散形式是线性系统：\n$$\nA_h^s u_h = f_h\n$$\n其中 $f_h = [f(x_1), f(x_2), \\dots, f(x_N)]^T$ 是在内部网格点上求值的右端项函数向量。数值近似解 $u_h$ 由下式给出：\n$$\nu_h = (A_h^s)^{-1} f_h = (V \\Lambda^s V^T)^{-1} f_h = V \\Lambda^{-s} V^T f_h\n$$\n这提供了一个计算上稳定且高效的算法：\n1.  构建矩阵 $A_h$。\n2.  使用可靠的数值库函数（例如，`scipy.linalg.eigh`）计算其特征值 $\\Lambda$ 和特征向量 $V$。\n3.  构建向量 $f_h$。\n4.  将 $f_h$ 转换到 $A_h$ 的特征基中：$\\hat{f}_h = V^T f_h$。\n5.  在特征基中缩放分量：$\\hat{u}_h(k) = \\mu_k^{-s} \\hat{f}_h(k)$。这是一个逐分量的乘法。\n6.  将结果转换回标准基：$u_h = V \\hat{u}_h$。\n\n### 4. 误差分析与收敛率\n\n为验证该方法，我们将数值解 $u_h$ 与在网格点上采样的精确解 $u(x)$ 进行比较。精确解值向量为 $u_{exact} = [u(x_1), u(x_2), \\dots, u(x_N)]^T$。\n\n误差使用离散 $L^2$ 范数进行量化：\n$$\nE(N) = \\left( h \\sum_{i=1}^{N} | u_h(x_i) - u(x_i) |^2 \\right)^{1/2} = \\sqrt{h} \\|u_h - u_{exact}\\|_2\n$$\n其中 $\\|\\cdot\\|_2$ 表示标准欧几里得向量范数。\n\n收敛阶 $\\rho$ 通过加密网格来估计。如果误差表现为 $E(N) \\approx C h^\\rho = C (N+1)^{-\\rho}$（其中 $C$ 为某个常数），那么对于两个网格尺寸 $N$ 和 $2N$，误差比近似为 $E(N)/E(2N) \\approx ((N+1)^{-1} / (2N+1)^{-1})^\\rho \\approx 2^\\rho$。取对数可得到观测收敛率的公式：\n$$\n\\rho(N \\to 2N) = \\frac{\\log(E(N)/E(2N))}{\\log(2)}\n$$\n问题要求计算两次连续加密（$N_1 \\to N_2$ 和 $N_2 \\to N_3$）的这个率（其中并未假设 $N_2=2N_1$ 和 $N_3=2N_2$，但这在测试用例中是成立的），并报告这两个率的平均值。这为渐近收敛率提供了一个更稳定的估计。对于光滑的构造解，该方法的预期收敛率是 $\\rho=2$，因为主要误差来源于 Laplacian 算子的二阶有限差分近似。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (s, m, (N1, N2, N3))\n        {'s': 0.25, 'm': 1, 'N_grid': (50, 100, 200)},\n        {'s': 0.50, 'm': 1, 'N_grid': (50, 100, 200)},\n        {'s': 0.75, 'm': 3, 'N_grid': (50, 100, 200)},\n        {'s': 0.99, 'm': 1, 'N_grid': (50, 100, 200)},\n    ]\n\n    results = []\n    for case in test_cases:\n        mean_rate = compute_mean_convergence_rate(case['s'], case['m'], case['N_grid'])\n        results.append(mean_rate)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_mean_convergence_rate(s, m, N_grid_sizes):\n    \"\"\"\n    Computes the mean convergence rate for a given set of parameters.\n\n    Args:\n        s (float): The fractional order of the Laplacian.\n        m (int): The mode number for the manufactured solution.\n        N_grid_sizes (tuple): A tuple of three integers (N1, N2, N3) for grid sizes.\n\n    Returns:\n        float: The mean of two successive convergence rates.\n    \"\"\"\n    errors = []\n    for N in N_grid_sizes:\n        h = 1.0 / (N + 1)\n        \n        # 1. Define interior grid points\n        x = np.linspace(h, 1.0 - h, N)\n        \n        # 2. Construct the discrete Laplacian matrix A_h\n        main_diag = np.full(N, 2.0)\n        off_diag = np.full(N - 1, -1.0)\n        A_h = (np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)) / (h**2)\n        \n        # 3. Compute the eigendecomposition of A_h.\n        # eigh is used for symmetric matrices.\n        eigenvalues, eigenvectors = eigh(A_h)\n        \n        # 4. Construct the right-hand side vector f_h\n        # f(x) = (m*pi)^(2s) * sin(m*pi*x)\n        f_h = (m * np.pi)**(2 * s) * np.sin(m * np.pi * x)\n        \n        # 5. Solve the linear system A_h^s * u_h = f_h using the spectral method\n        # u_h = V * Lambda^(-s) * V^T * f_h\n        # Step 5.1: Transform f_h to the eigenbasis\n        f_hat = eigenvectors.T @ f_h\n        # Step 5.2: Scale by Lambda^(-s)\n        u_hat = f_hat * (eigenvalues**(-s))\n        # Step 5.3: Transform back to the standard basis\n        u_h = eigenvectors @ u_hat\n        \n        # 6. Compute the exact solution vector u_exact\n        u_exact = np.sin(m * np.pi * x)\n        \n        # 7. Calculate the discrete L2 error E(N)\n        error_norm_sq = np.sum((u_h - u_exact)**2)\n        error_L2 = np.sqrt(h * error_norm_sq)\n        errors.append(error_L2)\n        \n    # 8. Calculate convergence rates\n    E1, E2, E3 = errors\n    \n    # Check for grid refinement ratio. Assume it is 2 for simplicity.\n    grid_ratio1 = N_grid_sizes[1] / N_grid_sizes[0]\n    grid_ratio2 = N_grid_sizes[2] / N_grid_sizes[1]\n\n    rate1 = np.log(E1 / E2) / np.log(grid_ratio1)\n    rate2 = np.log(E2 / E3) / np.log(grid_ratio2)\n    \n    mean_rate = (rate1 + rate2) / 2.0\n    \n    return mean_rate\n\nsolve()\n\n```", "id": "3426256"}]}