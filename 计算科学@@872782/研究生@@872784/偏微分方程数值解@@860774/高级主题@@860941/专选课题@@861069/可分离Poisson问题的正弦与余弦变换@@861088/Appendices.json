{"hands_on_practices": [{"introduction": "在实现快速求解器之前，我们必须理解其背后的理论基础。本练习将引导您完成一维离散拉普拉斯算子在狄利克雷（Dirichlet）边界条件下的特征值与特征向量的基本推导。通过证明离散正弦函数确实是其特征向量，您将精确地理解离散正弦变换（DST）为何是实现系统对角化和求解的自然工具 [@problem_id:3443413]。", "problem": "考虑将区间 $[0,1]$ 均匀剖分为 $n+2$ 个点 $x_j=jh$，其中 $j=0,1,\\dots,n+1$ 且 $h=1/(n+1)$。施加齐次狄利克雷边界条件 $u_0=0$ 和 $u_{n+1}=0$，并考虑作用于内部未知量 $\\mathbf{u}=(u_1,\\dots,u_n)^{\\top}$ 的离散负拉普拉斯（二阶差分）算子\n$$(A\\mathbf{u})_j=\\frac{-u_{j-1}+2u_j-u_{j+1}}{h^2},\\quad j=1,\\dots,n,$$\n其中边界值 $u_0$ 和 $u_{n+1}$ 固定为零。从线性算子的特征值和特征向量的定义出发，并仅使用线性性、三角恒等式以及满足齐次狄利克雷条件的可分离模式的特性等基础事实，确定由 $k\\in\\{1,2,\\dots,n\\}$ 索引的 $A$ 的特征值 $\\lambda_k$ 的闭式表达式。将你的推理与离散正弦变换 (DST) 在对角化 $A$ 中的作用联系起来，但不要假定任何预先制定的变换对。\n\n请以关于 $h$、$n$ 和 $k$ 的单个解析表达式的形式给出你的最终答案。不需要数值近似，也不涉及单位。", "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 区域剖分：区间 $[0, 1]$ 被 $n+2$ 个点 $x_j=jh$ 剖分，其中 $j=0, 1, \\dots, n+1$。\n- 步长：$h=1/(n+1)$。\n- 边界条件：齐次狄利克雷条件 $u_0=0$ 和 $u_{n+1}=0$。\n- 未知量：内部值的向量 $\\mathbf{u}=(u_1, u_2, \\dots, u_n)^{\\top}$。\n- 算子：离散负拉普拉斯（二阶差分）算子 $A$ 定义为它对 $\\mathbf{u}$ 的作用，如下：\n$$(A\\mathbf{u})_j = \\frac{-u_{j-1} + 2u_j - u_{j+1}}{h^2}, \\quad \\text{for } j=1, 2, \\dots, n.$$\n- 任务：确定算子 $A$ 的特征值 $\\lambda_k$ 的闭式表达式，其中 $k \\in \\{1, 2, \\dots, n\\}$。\n- 方法论约束：推导必须从特征值和特征向量的定义出发，仅使用基础原理。结果应与离散正弦变换（DST）联系起来，但不假定其属性。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题是数值分析中的一个基本课题，特别是在求解偏微分方程的有限差分法中。离散拉普拉斯算子是一个标准的、经过充分研究的数学对象。该问题是科学上合理的。\n- **适定性**：该问题要求一个特定的 $n \\times n$ 矩阵的特征值。一个 $n \\times n$ 矩阵总有一组 $n$ 个特征值（计算重数），因此解存在且唯一。该问题是适定的。\n- **客观性**：问题以精确、形式化的数学语言陈述，没有主观性或歧义。\n\n问题陈述是自洽的、一致的，并遵循既定的科学和数学原理。它不违反任何无效性标准。\n\n### 步骤 3：结论与行动\n问题是有效的。将提供完整解答。\n\n### 求解推导\n\n线性算子 $A$ 的特征值 $\\lambda$ 和相应的特征向量 $\\mathbf{v} \\neq \\mathbf{0}$ 由方程 $A\\mathbf{v} = \\lambda\\mathbf{v}$ 定义。对于给定的离散负拉普拉斯算子 $A$，这个方程对于一个特征向量 $\\mathbf{v} = (v_1, v_2, \\dots, v_n)^{\\top}$ 可以按分量写为：\n$$ (A\\mathbf{v})_j = \\frac{-v_{j-1} + 2v_j - v_{j+1}}{h^2} = \\lambda v_j, \\quad \\text{for } j=1, 2, \\dots, n. $$\n算子的定义使用了边界值 $v_0$ 和 $v_{n+1}$，这些值与原始变量 $u$ 一样，必须满足齐次狄利克雷条件 $v_0 = 0$ 和 $v_{n+1} = 0$。\n\n问题提示我们考虑满足这些边界条件的可分离模式。其连续模拟是 $[0,1]$ 上的 Sturm-Liouville 问题 $-u''(x) = \\lambda u(x)$，其中 $u(0)=u(1)=0$，其特征函数形式为 $\\sin(k\\pi x)$。这启发我们为特征向量 $\\mathbf{v}$ 的分量提出一个离散模拟：\n$$ v_j = C \\sin(\\alpha x_j) = C \\sin(\\alpha j h) $$\n其中 $C$ 和 $\\alpha$ 是某个常数。由于特征向量的定义允许缩放一个标量倍数，我们可以设置 $C=1$。\n\n我们必须首先确保这种形式满足边界条件：\n1.  对于 $j=0$：$v_0 = \\sin(\\alpha \\cdot 0 \\cdot h) = \\sin(0) = 0$。这个条件自动满足。\n2.  对于 $j=n+1$：$v_{n+1} = \\sin(\\alpha(n+1)h) = 0$。给定 $h=1/(n+1)$，这变为 $\\sin(\\alpha(n+1)\\frac{1}{n+1}) = \\sin(\\alpha) = 0$。\n\n条件 $\\sin(\\alpha)=0$ 意味着 $\\alpha$ 必须是 $\\pi$ 的整数倍。令 $\\alpha = k\\pi$，其中 $k$ 为某个整数。因此，提出的特征向量分量是：\n$$ v_j^{(k)} = \\sin(k\\pi j h) $$\n我们需要找到 $n$ 个线性无关的特征向量。让我们来研究整数 $k$ 的选择：\n- 如果 $k=0$，$v_j^{(0)} = \\sin(0) = 0$ 对所有 $j$ 成立，这是平凡的零向量，不是一个特征向量。\n- 对于 $k \\in \\{1, 2, \\dots, n\\}$，向量 $\\mathbf{v}^{(k)}$ 是非平凡的，并且已知它们是线性无关的。\n- 如果 $k=n+1$，$v_j^{(n+1)} = \\sin((n+1)\\pi j h) = \\sin(\\pi j (n+1)/(n+1)) = \\sin(j\\pi) = 0$ 对所有整数 $j$ 成立。这又是零向量。\n- 对于 $k$ 的其他整数值，向量会变得冗余（例如，$\\mathbf{v}^{(k)} = -\\mathbf{v}^{(-k)}$ 和 $\\mathbf{v}^{(k)} = (-1)^{m} \\mathbf{v}^{(k+m(n+1))}$）。\n\n因此，我们可以通过选择 $k=1, 2, \\dots, n$ 来生成所有 $n$ 个不同的特征向量。现在，我们将第 $k$ 个特征向量的形式 $v_j = \\sin(k\\pi jh)$ 代入特征值方程。设 $\\lambda_k$ 是与特征向量 $\\mathbf{v}^{(k)}$ 对应的特征值。\n$$ \\frac{-\\sin(k\\pi(j-1)h) + 2\\sin(k\\pi jh) - \\sin(k\\pi(j+1)h)}{h^2} = \\lambda_k \\sin(k\\pi jh) $$\n我们来关注分子部分。使用和差化积恒等式 $\\sin(A-B) + \\sin(A+B) = 2\\sin(A)\\cos(B)$，我们可以简化项 $\\sin(k\\pi(j-1)h) + \\sin(k\\pi(j+1)h)$。令 $A = k\\pi jh$ 和 $B = k\\pi h$。\n$$ \\sin(k\\pi jh - k\\pi h) + \\sin(k\\pi jh + k\\pi h) = 2\\sin(k\\pi jh)\\cos(k\\pi h) $$\n特征值方程左侧的分子变为：\n$$ 2\\sin(k\\pi jh) - \\big( \\sin(k\\pi(j-1)h) + \\sin(k\\pi(j+1)h) \\big) = 2\\sin(k\\pi jh) - 2\\sin(k\\pi jh)\\cos(k\\pi h) $$\n$$ = 2\\sin(k\\pi jh) \\big( 1 - \\cos(k\\pi h) \\big) $$\n将此代回特征值方程：\n$$ \\frac{2\\sin(k\\pi jh) (1 - \\cos(k\\pi h))}{h^2} = \\lambda_k \\sin(k\\pi jh) $$\n由于 $\\mathbf{v}^{(k)}$ 是一个非零向量，我们可以找到一个 $j$ 使得 $\\sin(k\\pi jh) \\neq 0$。因此，我们可以将方程两边同除以 $\\sin(k\\pi jh)$ 来求解特征值 $\\lambda_k$：\n$$ \\lambda_k = \\frac{2(1 - \\cos(k\\pi h))}{h^2} $$\n为了得到一个更常见的形式，我们使用半角三角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$。当 $\\theta = k\\pi h$ 时，可得：\n$$ \\lambda_k = \\frac{2(2\\sin^2(k\\pi h/2))}{h^2} = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi h}{2}\\right) $$\n问题要求用 $h$、$n$ 和 $k$ 表示该表达式。我们可以使用定义 $h=1/(n+1)$ 来用 $n$ 表示正弦函数的参数。\n$$ \\lambda_k = \\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right) $$\n此表达式对每个 $k = 1, 2, \\dots, n$ 都有效。\n\n最后，我们将此结果与离散正弦变换（DST）联系起来。第 $k$ 个特征向量的分量是 $v_j^{(k)} = \\sin(k \\pi j h) = \\sin\\left(\\frac{k j \\pi}{n+1}\\right)$。一个矩阵 $S$，其 $(j,k)$ 项与此值成正比，即 $S_{jk} = \\sqrt{\\frac{2}{n+1}}\\sin\\left(\\frac{kj\\pi}{n+1}\\right)$，是 DST（具体来说是 DST-I）的矩阵。该矩阵 $S$ 的列是离散拉普拉斯矩阵 $A$ 的标准正交化的特征向量。这种特征基的存在意味着矩阵 $A$ 可被 DST 矩阵 $S$ 对角化。也就是说，$S^{-1}AS = \\Lambda$ 或 $S^{\\top}AS = \\Lambda$，其中 $\\Lambda$ 是一个对角矩阵，其对角线上的元素是特征值 $\\lambda_k$。这就是为什么基于变换的方法在求解均匀网格上的涉及离散拉普拉斯算子的线性系统时异常高效的根本原因。该变换将方程组解耦为变换域中的 $n$ 个独立的标量方程，这些方程可以轻易求解。", "answer": "$$\n\\boxed{\\frac{4}{h^2}\\sin^2\\left(\\frac{k\\pi}{2(n+1)}\\right)}\n$$", "id": "3443413"}, {"introduction": "在建立理论基础之后，我们转向动手实现。这项综合性练习要求您从第一性原理出发，通过对数据进行适当的对称延拓，利用更通用的快速傅里叶变换（FFT）来构建离散正弦和余弦变换（DST/DCT）。接着，您将使用这些自定义的变换函数，为齐次狄利克雷（Dirichlet）和齐次诺伊曼（Neumann）边界条件构建完整的二维快速泊松求解器，从而深入理解诸如零空间处理和边界数据嵌入所产生的光谱效应等关键细节 [@problem_id:3443474]。", "problem": "要求您实现通过快速傅里叶变换（FFT）和基于对称性的扩展来实现的离散正弦和余弦变换，并使用它们在单位正方形上求解具有齐次狄利克雷和齐次诺伊曼边界条件的可分离泊松问题。您还必须量化当非周期性边界数据通过补零或保持对称性的镜像扩展嵌入到周期性 FFT 中时产生的混叠和谱泄漏。您的实现必须是自洽的、基于第一性原理的，并且不得假定除标准 FFT 之外的任何专用变换例程。\n\n基本原理：\n- 考虑均匀网格上拉普拉斯算子的一维二阶中心有限差分近似。对于齐次狄利克雷边界条件，内部网格上的一维离散拉普拉斯算子具有由正弦基给出的特征向量；对于包含端点的网格上的齐次诺伊曼边界条件，它具有由余弦基给出的特征向量。这些是在可分离椭圆问题的变量分离法中使用的经过充分检验的事实。\n- 对于大小为 $N$、间距为 $h$ 的内部网格上的齐次狄利克雷边界条件，一维二阶差分算子的离散特征值为\n$$\n\\lambda_k^{(D)} = \\frac{4}{h^2} \\sin^2\\!\\left(\\frac{\\pi k}{2\\,(N+1)}\\right), \\quad k=1,2,\\dots,N.\n$$\n对于包含 $N$ 个节点、间距为 $h$ 的网格上的齐次诺伊曼边界条件，特征值为\n$$\n\\lambda_k^{(N)} = \\frac{4}{h^2} \\sin^2\\!\\left(\\frac{\\pi k}{2\\,(N-1)}\\right), \\quad k=0,1,\\dots,N-1,\n$$\n其中零模态 $\\lambda_0^{(N)}=0$ 对应于常数零空间。\n\n基于这些原理的核心实现要求：\n- 实现 I 型离散正弦变换（DST-I），用于处理长度为 $N$ 的向量，该向量对应于内部狄利克雷数据。这需要使用奇镜像扩展将其扩展为长度为 $M=2\\,(N+1)$ 的周期序列，并使用快速傅里叶变换（FFT）。通过构造适当的扩展序列并提取或组合相关的傅里叶模态，实现正变换和逆变换。\n- 实现 I 型离散余弦变换（DCT-I），用于处理长度为 $N$ 的向量，该向量对应于诺伊曼边界条件下包含端点的网格上的数据。这需要使用偶镜像扩展将其扩展为长度为 $M=2\\,(N-1)$ 的周期序列，并使用 FFT。类似地实现正变换和逆变换。\n\n需要构建的可分离泊松求解器：\n- $(0,1)^2$ 上的二维齐次狄利克雷泊松问题：\n  - 设 $N \\in \\mathbb{N}$ 为每个坐标方向的内部点数。设 $h=1/(N+1)$，内部网格点为 $x_i=i\\,h$, $y_j=j\\,h$，其中 $i=1,\\dots,N$，$j=1,\\dots,N$。\n  - 求解以下问题的有限差分格式\n  $$\n  \\Delta u(x,y) = f(x,y), \\quad u=0 \\text{ on } \\partial(0,1)^2,\n  $$\n  使用由二维 DST-I 对角化的可分离方案。使用一维特征值 $\\lambda_k^{(D)}$ 构成二维特征值 $\\lambda_{k_x}^{(D)}+\\lambda_{k_y}^{(D)}$，并相应地对变换后的右侧项进行除法运算，然后进行逆变换。\n  - 使用人造解 $u(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ 进行测试，此时 $f(x,y)=-2\\,\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$。报告内部网格上的相对离散 $\\ell^2$ 误差：\n  $$\n  \\frac{\\|u_h - u_{\\text{exact}}\\|_2}{\\|u_{\\text{exact}}\\|_2},\n  $$\n  其中 $\\|\\cdot\\|_2$ 是网格值上的欧几里得范数。\n\n- $[0,1]^2$ 上的二维齐次诺伊曼泊松问题：\n  - 设 $N \\in \\mathbb{N}$ 为每个坐标方向上包含边界的网格点数，间距为 $h=1/(N-1)$，网格点为 $x_i=i\\,h$, $y_j=j\\,h$，其中 $i=0,\\dots,N-1$，$j=0,\\dots,N-1$。\n  - 求解以下问题的有限差分格式\n  $$\n  \\Delta u(x,y) = f(x,y), \\quad \\partial_n u = 0 \\text{ on } \\partial[0,1]^2,\n  $$\n  使用由二维 DCT-I 对角化的可分离方案。使用一维特征值 $\\lambda_k^{(N)}$ 构成二维特征值 $\\lambda_{k_x}^{(N)}+\\lambda_{k_y}^{(N)}$。通过对解强制施加零均值来处理零模态，即将 $(k_x,k_y)=(0,0)$ 系数设置为零。相应地对变换后的右侧项进行除法运算，然后进行逆变换。\n  - 使用人造解 $u(x,y)=\\cos(2\\,\\pi x)+\\cos(2\\,\\pi y)$ 进行测试，此时 $f(x,y)=-4\\,\\pi^2(\\cos(2\\,\\pi x)+\\cos(2\\,\\pi y))$。在从数值解和精确解中减去空间平均值以解决常数零空间问题后，报告全网格上的相对离散 $\\ell^2$ 误差：\n  $$\n  \\frac{\\| (u_h-\\overline{u_h}) - (u_{\\text{exact}}-\\overline{u_{\\text{exact}}}) \\|_2}{\\|u_{\\text{exact}}-\\overline{u_{\\text{exact}}}\\|_2}.\n  $$\n\n通过 FFT 嵌入量化混叠和泄漏：\n- 设函数 $g(x)=e^x$ 定义在 $[0,1]$ 上，在 $N$ 个内部狄利克雷点 $x_j=j\\,h$（其中 $h=1/(N+1)$，$j=1,\\dots,N$）上采样。考虑在进行 FFT 之前，将其嵌入到长度为 $M=2\\,(N+1)$ 的周期序列的两种方法：\n  - 奇镜像扩展（与齐次狄利克雷边界兼容）：定义一个奇的 $2\\,(N+1)$ 周期序列 $y$，其中 $y[0]=0$，$y[j]=g(x_j)$ for $j=1,\\dots,N$，$y[N+1]=0$，以及 $y[N+1+\\ell]=-g(x_{N+1-\\ell})$ for $\\ell=1,\\dots,N$。\n  - 补零扩展：定义一个序列 $z$，其中 $z[j]=g(x_j)$ for $j=1,\\dots,N$，其他位置 $z[j]=0$，总长度为 $M=2\\,(N+1)$。\n- 对于每种扩展，计算离散傅里叶变换，并定义在索引 $k=0,1,\\dots,N+1$ 上的半谱能量，\n  $$\n  E_{\\text{half}} = \\sum_{k=0}^{N+1} |Y[k]|^2,\n  $$\n  以及在正弦谐波仓 $k=1,2,\\dots,N$ 中的能量，\n  $$\n  E_{\\text{sine}} = \\sum_{k=1}^{N} |Y[k]|^2.\n  $$\n  定义泄漏率\n  $$\n  L = 1 - \\frac{E_{\\text{sine}}}{E_{\\text{half}}}.\n  $$\n  对于奇镜像扩展，理想情况下 $L \\approx 0$，而对于补零扩展，由于向非正弦仓的混叠/泄漏，$L$ 应该显著更大。\n\n测试套件和要求的输出：\n- 测试 1（理想路径，狄利克雷）：对上述二维狄利克雷泊松问题使用 $N=32$；输出一个浮点数，等于相对离散 $\\ell^2$ 误差。\n- 测试 2（诺伊曼，零空间处理）：对上述二维诺伊曼泊松问题使用 $N=33$；输出一个浮点数，等于去除均值后的相对离散 $\\ell^2$ 误差。\n- 测试 3（混叠/泄漏，边界嵌入）：对 $g(x)=e^x$ 的一维泄漏实验使用 $N=64$；按顺序输出一个包含两个浮点数的列表 $[L_{\\text{mirror}}, L_{\\text{zeropad}}]$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含测试 1-3 的结果，形式为一个用方括号括起来的逗号分隔列表，其中第三个条目本身是一个包含两个浮点数的列表。例如，一个语法上有效的输出形状是\n$$\n[\\text{err\\_D},\\text{err\\_N},[\\text{L\\_mirror},\\text{L\\_zeropad}]].\n$$\n本问题不涉及单位，内部使用的任何角度都必须是弧度制。", "solution": "所提出的问题要求实现基于离散正弦和余弦变换（DST/DCT）的快速泊松求解器，这些变换通过快速傅里叶变换（FFT）实现。分析进一步扩展到量化由不同周期性嵌入策略引起的谱伪影。解决方案按规定从第一性原理出发进行开发。\n\n### 1. 通过快速傅里叶变换实现正弦和余弦变换\n\n快速求解器的核心在于能够使用正弦基函数对角化离散拉普拉斯算子。DST 和 DCT 代表向这些基的变换，可以通过将数据嵌入到一个更大的对称序列中并应用标准 FFT 来高效计算。\n\n#### 1.1. I 型离散正弦变换 (DST-I)\n\nDST-I 与在边界处为零的函数在大小为 $N$ 的内部网格上的二阶中心差分矩阵的特征向量相关联。\n\n**正变换 (DST-I):** 对于数据向量 $u = (u_1, \\dots, u_N)$，未归一化的 DST-I 由下式给出：\n$$\n\\hat{u}_k = \\sum_{j=1}^{N} u_j \\sin\\left(\\frac{\\pi j k}{N+1}\\right), \\quad k=1, \\dots, N\n$$\n为了使用 FFT 计算它，我们构造一个长度为 $M=2(N+1)$ 且具有奇对称性的扩展序列 $y$。设实现中的输入向量是长度为 $N$ 的零索引数组 `u`。扩展序列 `y` 为：\n$$\ny_j =\n\\begin{cases}\n0  & j=0, N+1 \\\\\nu_{j-1} & j=1, \\dots, N \\\\\n-u_{N+1-j} & j=N+2, \\dots, 2N+1\n\\end{cases}\n$$\n这个实奇序列 $y$ 的 FFT 结果是一个纯虚、共轭反对称的谱 $Y_k$。它与 DST-I 和的关系是：\n$$\nY_k = \\text{FFT}(y)_k = \\sum_{j=0}^{M-1} y_j e^{-2\\pi i j k / M} = -2i \\sum_{j=1}^{N} u_{j-1} \\sin\\left(\\frac{\\pi j k}{N+1}\\right) = -2i \\, \\hat{u}_k\n$$\n因此，可以从 FFT 结果中提取正变换 DST-I 的系数：\n$$\n\\hat{u}_k = -\\frac{1}{2} \\text{Im}(Y_k)\n$$\n其中代码中的 `u` 索引为 $0, \\dots, N-1$，对应物理点 $1, \\dots, N$，而 $\\hat{u}$ 的索引为 $0, \\dots, N-1$，对应模态 $k=1, \\dots, N$。\n\n**逆变换 (IDST-I):** DST-I 的变换矩阵 $S_{kj} = \\sin(\\frac{\\pi k j}{N+1})$ 满足 $S^2 = \\frac{N+1}{2}I$。这意味着逆变换与正变换成正比：$S^{-1} = \\frac{2}{N+1}S$。因此，逆 DST-I 可以通过应用正 DST-I 例程并对结果进行缩放来实现：\n$$\nu = \\text{IDST-I}(\\hat{u}) = \\frac{2}{N+1} \\text{DST-I}(\\hat{u})\n$$\n这个优雅的性质简化了实现，因为一个核心例程足以同时用于正变换和逆变换。\n\n#### 1.2. I 型离散余弦变换 (DCT-I)\n\nDCT-I 源于在包含端点的大小为 $N$ 的网格上，具有齐次诺伊曼边界条件的离散拉普拉斯算子的特征向量。\n\n**正变换 (DCT-I):** 对于数据 $u = (u_0, \\dots, u_{N-1})$，未归一化的 DCT-I 是：\n$$\n\\hat{u}_k = u_0 + (-1)^k u_{N-1} + 2\\sum_{j=1}^{N-2} u_j \\cos\\left(\\frac{\\pi j k}{N-1}\\right), \\quad k=0, \\dots, N-1\n$$\n这通过 FFT 计算，方法是构造一个长度为 $M=2(N-1)$ 且具有偶对称性的扩展序列 $y$：\n$$\ny_j =\n\\begin{cases}\nu_j & j=0, \\dots, N-1 \\\\\nu_{2(N-1)-j} & j=N, \\dots, 2N-3\n\\end{cases}\n$$\n这个实偶序列 $y$ 的 FFT 产生一个实偶谱 $Y_k$，它恰好对应于 DCT-I 系数：\n$$\nY_k = \\text{FFT}(y)_k = \\hat{u}_k\n$$\n因此，正 DCT-I 就是扩展序列 FFT 结果的前 $N$ 个分量的实部。\n\n**逆变换 (IDCT-I):** 正变换将信号 $u$ 映射到 FFT 系数 $Y_k = \\text{FFT}(\\text{extend}(u))_k$。逆运算涉及从 $N$ 个 DCT-I 系数 $\\hat{u}$ 使用偶对称性重构完整的 FFT 谱 $Y$，然后应用逆 FFT。由于 `ifft(fft(y)) = y`，这个过程完美地恢复了扩展序列 $y$，从中可以提取原始数据 $u$。如果使用标准的 `fft`/`ifft` 对，其中逆变换包含 $1/M$ 归一化因子，则不需要额外缩放。\n\n### 2. 可分离泊松求解器\n\n在具有可分离边界条件的矩形域上，二维泊松方程 $\\Delta u = f$ 可以通过沿每个坐标方向应用一维变换来高效求解。\n\n#### 2.1. 齐次狄利克雷问题\n问题是在 $(0,1)^2$ 上求解 $\\Delta u = f$，边界上 $u=0$。在 $N \\times N$ 内部网格上的有限差分近似为 $(L_x + L_y)U = F$，其中 $L_x$ 和 $L_y$ 是一维离散拉普拉斯算子。二维 DST-I 对角化了这个系统。算法如下：\n1.  计算源项矩阵 $F$ 的二维 DST-I：$\\hat{\\hat{F}} = \\text{DST2D}(F)$。这是通过对 $F$ 的每一列应用一维 DST-I，然后对结果的每一行应用一维 DST-I 来完成的。\n2.  变换后的方程是代数方程：$\\Lambda_{k_x, k_y} \\hat{\\hat{U}}_{k_x, k_y} = \\hat{\\hat{F}}_{k_x, k_y}$。二维算子的特征值是一维特征值的和：$\\Lambda_{k_x, k_y} = \\lambda_{k_x}^{(D)} + \\lambda_{k_y}^{(D)}$。\n3.  求解变换后的解：$\\hat{\\hat{U}}_{k_x, k_y} = \\hat{\\hat{F}}_{k_x, k_y} / \\Lambda_{k_x, k_y}$。\n4.  通过应用二维逆 DST-I 计算解 $U$：$U = \\text{IDST2D}(\\hat{\\hat{U}})$。\n\n#### 2.2. 齐次诺伊曼问题\n问题是在 $[0,1]^2$ 上求解 $\\Delta u = f$，边界上 $\\partial_n u = 0$。仅当满足相容性条件 $\\int f dA = 0$ 时，解才存在。解在相差一个加性常数的意义下是唯一的。二维 DCT-I 对角化了这个离散系统。\n1.  计算源项矩阵 $F$ 的二维 DCT-I：$\\hat{\\hat{F}} = \\text{DCT2D}(F)$。\n2.  特征值 $\\Lambda_{0,0} = \\lambda_0^{(N)} + \\lambda_0^{(N)} = 0$。这对应于常数零空间。\n3.  求解变换后的解，处理零模态：\n    $$\n    \\hat{\\hat{U}}_{k_x, k_y} =\n    \\begin{cases}\n    0 & (k_x,k_y)=(0,0) \\\\\n    \\hat{\\hat{F}}_{k_x, k_y} / \\Lambda_{k_x, k_y} & \\text{otherwise}\n    \\end{cases}\n    $$\n    设置 $\\hat{\\hat{U}}_{0,0} = 0$ 强制解 $U$ 的空间平均值为零。相容性条件确保 $\\hat{\\hat{F}}_{0,0} = \\sum F_{ij} \\approx 0$。\n4.  通过应用二维逆 DCT-I 计算解 $U$：$U = \\text{IDCT2D}(\\hat{\\hat{U}})$。\n\n### 3. 混叠和泄漏量化\n\n当使用假定周期性的 DFT/FFT 分析非周期信号时，谱能量会从信号的真实频率“泄漏”到其他频率仓中。这是一种混叠形式。\n- **保持对称性的扩展**：对于要用正弦级数表示的信号 $g(x_j)$（意味着 $g(0)=0, g(1)=0$），奇镜像扩展会创建一个光滑（在周期意义上）的信号，其能量集中在 FFT 的与正弦相关的频率仓中。泄漏率 $L$ 应该接近于 $0$。\n- **补零扩展**：将信号嵌入到一个零数组中会在信号的端点处产生急剧的不连续点。这个信号的 FFT 在所有频率仓中都表现出显著的谱泄漏，因为需要大量的正弦波来表示这些不连续点。泄漏率 $L$ 将显著大于 $0$。\n泄漏率 $L = 1 - E_{\\text{sine}} / E_{\\text{half}}$ 量化了目标（正弦）谐波仓之外的能量分数。\n\n现在使用这些原理执行所提供的测试用例。\n- **测试 1**：求解 $N=32$ 的狄利克雷问题。\n- **测试 2**：求解 $N=33$ 的诺伊曼问题。\n- **测试 3**：计算 $N=64$ 时 $g(x)=e^x$ 的泄漏率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests fast Poisson solvers and spectral analysis\n    based on custom FFT-based Discrete Sine and Cosine Transforms.\n    \"\"\"\n\n    # =========================================================================\n    # Part 1: Discrete Sine/Cosine Transforms via FFT\n    # =========================================================================\n\n    def dst1(u):\n        \"\"\"\n        Computes the Discrete Sine Transform of type I (DST-I).\n        The unnormalized DST-I sum is Sum_{j=0..N-1} u[j] * sin(pi*(j+1)*k/(N+1)) for k=1..N.\n        This implementation returns DST-I_sum(u).\n        \"\"\"\n        N = len(u)\n        M = 2 * (N + 1)\n        y = np.zeros(M)\n        y[1:N + 1] = u\n        y[N + 2:] = -u[::-1]\n        \n        Y_fft = np.fft.fft(y)\n        \n        # From derivation, Y_k = -2i * DST_I_sum(u)_k.\n        # We extract the coefficients for k=1,...,N.\n        return -np.imag(Y_fft[1:N + 1])\n\n    def idst1(u_hat):\n        \"\"\"\n        Computes the Inverse Discrete Sine Transform of type I (IDST-I).\n        The transform matrix S for DST-I satisfies S^2 = (N+1)/2 * I.\n        Thus, S_inv = (2/(N+1)) * S.\n        \"\"\"\n        N = len(u_hat)\n        # Apply the forward transform and scale appropriately.\n        # The dst1 implementation above returns Sum, not 2*Sum as scipy.\n        # So the result of dst1(u_hat) is (N+1)/2 * u.\n        # We need to scale by 2/(N+1).\n        return dst1(u_hat) * 2.0 / (N + 1)\n\n    def dct1(u):\n        \"\"\"\n        Computes the Discrete Cosine Transform of type I (DCT-I).\n        This is implemented via an even extension and FFT.\n        \"\"\"\n        N = len(u)\n        M = 2 * (N - 1)\n        y = np.zeros(M)\n        y[0:N] = u\n        y[N:] = u[1:N - 1][::-1]\n        \n        Y_fft = np.fft.fft(y)\n        \n        # The DCT-I coefficients are the real part of the FFT of this sequence.\n        return np.real(Y_fft[0:N])\n\n    def idct1(u_hat):\n        \"\"\"\n        Computes the Inverse Discrete Cosine Transform of type I (IDCT-I).\n        This is the exact inverse of the dct1 function implemented above.\n        \"\"\"\n        N = len(u_hat)\n        if N = 1: return u_hat.copy()\n        M = 2 * (N - 1)\n        # Reconstruct the full, even FFT spectrum from DCT-I coeffs.\n        Y_hat = np.zeros(M, dtype=complex)\n        Y_hat[0:N] = u_hat\n        Y_hat[N:] = u_hat[1:N-1][::-1]\n        \n        # The inverse FFT recovers the extended signal.\n        y_reco = np.fft.ifft(Y_hat)\n        \n        # Return the first N points, which is the original signal.\n        return np.real(y_reco[0:N])\n\n    # --- 2D Transform Wrappers ---\n    def dst2(F):\n        # The factor of 1/2 in dst1 is part of the transform, not the sum.\n        # Standard implementation of 2D transform is to apply 1D transforms.\n        # My dst1 returns the pure sum, so this is correct.\n        F_hat = np.apply_along_axis(dst1, 0, F)\n        return np.apply_along_axis(dst1, 1, F_hat)\n\n    def idst2(F_hat):\n        F_cols = np.apply_along_axis(idst1, 1, F_hat)\n        return np.apply_along_axis(idst1, 0, F_cols)\n\n    def dct2(F):\n        F_hat = np.apply_along_axis(dct1, 0, F)\n        return np.apply_along_axis(dct1, 1, F_hat)\n\n    def idct2(F_hat):\n        F_cols = np.apply_along_axis(idct1, 1, F_hat)\n        return np.apply_along_axis(idct1, 0, F_cols)\n\n    # =========================================================================\n    # Part 2: Poisson Solvers and Leakage Analysis\n    # =========================================================================\n    \n    def solve_poisson_dirichlet(N):\n        \"\"\"Test Case 1: 2D Dirichlet Poisson problem.\"\"\"\n        h = 1.0 / (N + 1)\n        x = np.arange(1, N + 1) * h\n        xx, yy = np.meshgrid(x, x, indexing='ij')\n\n        u_exact = np.sin(np.pi * xx) * np.sin(np.pi * yy)\n        f_rhs = -2.0 * np.pi**2 * u_exact\n        \n        # This is -h^2 Delta_h u. We need Delta_h u.\n        # The problem asks for Delta u = f, not -Delta u = f.\n        # Wait, problem says \"solvers for ... -Delta_h u = f_h\". Oh, it is minus.\n        # But then the eigenvalues would be negative.\n        # The problem text gives lambda for the *second difference operator*, not *minus* the operator.\n        # Ok, the problem asks to solve Delta u = f, my code will solve -Delta u = -f\n        # Eigenvalues for -Delta_h are positive.\n        k = np.arange(1, N + 1)\n        lambda_d = (4.0 / h**2) * np.sin(np.pi * k / (2.0 * (N + 1)))**2\n        Lambda_2d = lambda_d[:, None] + lambda_d[None, :]\n\n        # My solver solves -Delta u = f. The test case is Delta u = f.\n        # So I solve -Delta u = -f.\n        f_hat = dst2(-f_rhs)\n        u_hat = f_hat / Lambda_2d\n        u_h = idst2(u_hat)\n\n        error = np.linalg.norm(u_h - u_exact) / np.linalg.norm(u_exact)\n        return error\n\n    def solve_poisson_neumann(N):\n        \"\"\"Test Case 2: 2D Neumann Poisson problem.\"\"\"\n        h = 1.0 / (N - 1)\n        x = np.arange(0, N) * h\n        xx, yy = np.meshgrid(x, x, indexing='ij')\n\n        u_exact = np.cos(2 * np.pi * xx) + np.cos(2 * np.pi * yy)\n        f_rhs = -4.0 * np.pi**2 * u_exact\n\n        k = np.arange(0, N)\n        lambda_n = (4.0 / h**2) * np.sin(np.pi * k / (2.0 * (N - 1)))**2\n        Lambda_2d = lambda_n[:, None] + lambda_n[None, :]\n\n        # Again, solve -Delta u = -f\n        f_hat = dct2(-f_rhs)\n        u_hat = np.zeros_like(f_hat)\n        \n        non_zero_mode = Lambda_2d != 0\n        u_hat[non_zero_mode] = f_hat[non_zero_mode] / Lambda_2d[non_zero_mode]\n        u_hat[0, 0] = 0.0\n\n        u_h = idct2(u_hat)\n\n        u_h_mean_removed = u_h - np.mean(u_h)\n        u_exact_mean_removed = u_exact - np.mean(u_exact)\n        \n        norm_u_exact_mean_removed = np.linalg.norm(u_exact_mean_removed)\n        if norm_u_exact_mean_removed == 0:\n            return 0.0\n        \n        error = np.linalg.norm(u_h_mean_removed - u_exact_mean_removed) / norm_u_exact_mean_removed\n        return error\n\n    def quantify_leakage(N):\n        \"\"\"Test Case 3: Spectral leakage analysis.\"\"\"\n        h = 1.0 / (N + 1)\n        x_grid = np.arange(1, N + 1) * h\n        g_data = np.exp(x_grid)\n        \n        M = 2 * (N + 1)\n        \n        # Odd mirror extension\n        y_mirror = np.zeros(M)\n        y_mirror[1:N + 1] = g_data\n        y_mirror[N + 2:] = -g_data[::-1]\n        Y_mirror = np.fft.fft(y_mirror)\n        \n        E_half_mirror = np.sum(np.abs(Y_mirror[0:N + 2])**2)\n        # Sine energy is in imaginary part of FFT of odd extension.\n        # Y_k = -2i * DST_sum. |Y_k|^2 = 4 |DST_sum_k|^2.\n        # The dst1 func returns DST_sum.\n        dst_coeffs = dst1(g_data)\n        # Let's stick to the problem description, use Y[k]\n        E_sine_mirror = np.sum(np.abs(Y_mirror[1:N + 1])**2)\n        L_mirror = 1.0 - E_sine_mirror / E_half_mirror if E_half_mirror != 0 else 0.0\n\n        # Zero-padding extension\n        y_zeropad = np.zeros(M)\n        y_zeropad[1:N + 1] = g_data\n        Y_zeropad = np.fft.fft(y_zeropad)\n\n        E_half_zeropad = np.sum(np.abs(Y_zeropad[0:N + 2])**2)\n        E_sine_zeropad = np.sum(np.abs(Y_zeropad[1:N + 1])**2)\n        L_zeropad = 1.0 - E_sine_zeropad / E_half_zeropad if E_half_zeropad != 0 else 0.0\n        \n        return [L_mirror, L_zeropad]\n\n    # =========================================================================\n    # Part 3: Execute Test Suite and Format Output\n    # =========================================================================\n    \n    test_cases = [\n        # (function, parameter)\n        (solve_poisson_dirichlet, 32),\n        (solve_poisson_neumann, 33),\n        (quantify_leakage, 64)\n    ]\n\n    results = []\n    # My dst1 returns -Im(Y_fft)/2, not the pure sum. Let me fix that.\n    # The derivation Y_k = -2i * Sum implies Sum = Im(Y_k)/2. And dst1 returns -Im(Y_k)/2.\n    # So dst1(u) = -Sum. This is fine, it's just a sign convention.\n    # Then idst1(u_hat) = dst1(u_hat) * 2/(N+1) = -Sum(u_hat) * 2/(N+1).\n    # If u_hat = -Sum(u), then Sum(u_hat) = Sum(-Sum(u)) = -Sum(Sum(u)) = -(N+1)/2 * u.\n    # So idst1(-Sum(u)) = - (-(N+1)/2 * u) * 2/(N+1) = u. It works.\n    \n    # Let me re-read dst1 again. Y_k = -2i * sum_j u_{j-1} sin(...)\n    # sum_j = Im(Y_k)/2. The code returns -Im(Y_k)/2. So dst1(u) = -sum_j... which is a valid transform.\n    # But then in idst1, dst1(u_hat) = dst1(-sum) = -sum(-sum) = sum(sum) = (N+1)/2 * u.\n    # so idst1 result is (N+1)/2 * u * 2/(N+1) = u. The logic seems correct. I will remove my previous edit.\n    \n    for func, param in test_cases:\n        result = func(param)\n        results.append(result)\n    \n    # Final print statement in the exact required format.\n    err_D, err_N, leakage_ratios = results\n    print(f\"[{err_D},{err_N},[{leakage_ratios[0]},{leakage_ratios[1]}]]\")\n\nsolve()\n\n```", "id": "3443474"}, {"introduction": "本练习在可分离变换概念的基础上，聚焦于高性能科学计算的一个关键方面：在多维情况下的高效实现。您将开发一个二维泊松求解器，它通过顺序应用一维变换来工作，但其核心关注点是通过在变换步骤之间置换数据数组来优化内存布局和缓存效率。这个练习展示了如何在有效利用优化库函数的同时，兼顾底层硬件架构以实现最佳性能 [@problem_id:3443478]。", "problem": "考虑一个在矩形上的、带有齐次狄利克雷边界条件的可分离泊松问题：求 $u(x,y)$ 使得\n$$ -\\frac{\\partial^2 u}{\\partial x^2}(x,y) - \\frac{\\partial^2 u}{\\partial y^2}(x,y) = f(x,y), \\quad (x,y) \\in (0,L_x)\\times(0,L_y), $$\n且在矩形边界上 $u(x,y)=0$。使用一个均匀的张量积网格对区域内部进行离散化，该网格在 $x$ 和 $y$ 方向上分别有 $N_x$ 和 $N_y$ 个内部点，网格间距分别为 $h_x = \\frac{L_x}{N_x+1}$ 和 $h_y = \\frac{L_y}{N_y+1}$。令 $u_{j,i} \\approx u(x_i,y_j)$ 表示在内部节点 $x_i = i h_x$（$i=1,\\dots,N_x$）和 $y_j = j h_y$（$j=1,\\dots,N_y$）处的网格函数。使用中心二阶有限差分，作用于内部网格函数 $u$ 的离散拉普拉斯算子 $\\Delta_h$ 为\n$$ (\\Delta_h u)_{j,i} = \\frac{u_{j,i-1} - 2 u_{j,i} + u_{j,i+1}}{h_x^2} + \\frac{u_{j-1,i} - 2 u_{j,i} + u_{j+1,i}}{h_y^2}, $$\n并约定将内部索引范围之外的值设为零，以施加齐次狄利克雷边界条件。离散问题为：求内部网格函数 $u$ 使得\n$$ -\\Delta_h u = f_h, $$\n其中 $f_h$ 是 $f$ 在内部网格上的采样。\n\n一个经过充分检验的事实是，对应于带有齐次狄利克雷边界条件的二阶导数的一维离散算子，可以被I型离散正弦变换 (DST-I) 对角化，其特征值为\n$$ \\lambda^{(x)}_k = \\frac{4}{h_x^2} \\sin^2\\!\\left(\\frac{k\\pi}{2(N_x+1)}\\right), \\quad k=1,\\dots,N_x, $$\n$y$ 方向也类似，其特征值为\n$$ \\lambda^{(y)}_\\ell = \\frac{4}{h_y^2} \\sin^2\\!\\left(\\frac{\\ell\\pi}{2(N_y+1)}\\right), \\quad \\ell=1,\\dots,N_y. $$\n根据可分离性，二维算子 $-\\Delta_h$ 可以通过沿行和列应用一维变换来对角化。\n\n您的任务是实现一个求解 $-\\Delta_h u = f_h$ 的二维求解器，该求解器基于分别沿行和列应用的一维变换。您必须：\n- 根据上述定义和事实，推导出如何使用具有正交归一化的I型离散正弦变换 (DST-I) 对角化二维算子，并由此获得计算变换后解系数的谱公式。\n- 通过仅沿最后一个轴执行一维变换，然后置换轴以将另一个空间维度移到最后位置，并重复此过程，来实现二维变换的应用。这是为了在每次变换调用中保持连续的内存访问（缓存效率）。您可以使用来自标准科学库、带有显式类型和归一化参数的离散正弦变换 (DST) 和离散余弦变换 (DCT)，但不得使用任何直接的二维变换例程。\n- 实现一个函数，通过如上所述对边界进行补零来计算内部的离散拉普拉斯算子 $\\Delta_h$。使用此函数从已知（采样）的精确内部解 $u$ 生成右端项 $f_h$，以便数值求解器的输出可以与精确离散解进行比较。\n- 除了基于正弦变换的泊松求解器，还为给定类型和归一化方式的二维离散余弦变换 (DCT) 实现类似的“两遍”辅助函数，同样通过在两次传递之间使用置换步骤、沿最后一个轴进行变换来实现。\n\n角度必须以弧度为单位。不存在物理单位。所有数值答案必须按下面指定的方式报告为浮点数或布尔值。\n\n测试套件：\n实现您的程序以评估以下五个测试用例，并按规定格式生成输出。\n\n$1$. 齐次狄利克雷，矩形网格（理想情况）：\n- 参数：$N_x=32$, $N_y=20$, $L_x=1$, $L_y=1$，精确内部解 $u(x,y) = \\sin(3\\pi x/L_x)\\sin(5\\pi y/L_y)$。\n- 通过在内部节点采样 $u$ 来构造 $u_{j,i}$，计算 $f_h = -\\Delta_h u$，求解 $-\\Delta_h \\tilde{u} = f_h$，并返回相对离散 $\\ell^2$ 误差\n$$ \\frac{\\| \\tilde{u} - u \\|_2}{\\|u\\|_2}, $$\n其中范数是内部网格值上的欧几里得范数。\n\n$2$. 齐次狄利克雷，边长不等的矩形域：\n- 参数：$N_x=29$, $N_y=37$, $L_x=2.0$, $L_y=0.5$，精确内部解 $u(x,y) = \\sin(2\\pi x/L_x)\\sin(9\\pi y/L_y)$。\n- 返回相对离散 $\\ell^2$ 误差，定义同案例1。\n\n$3$. 齐次狄利克雷， $N_x=1$ 的边界情况：\n- 参数：$N_x=1$, $N_y=17$, $L_x=1.0$, $L_y=1.0$，精确内部解 $u(x,y) = \\sin(\\pi x/L_x)\\sin(7\\pi y/L_y)$。\n- 返回相对离散 $\\ell^2$ 误差，定义同案例1。\n\n$4$. DST的两遍变换等效性：\n- 使用固定的种子生成一个固定的随机数组 $A \\in \\mathbb{R}^{23\\times 17}$。用两种方法计算具有正交归一化的二维DST-I：\n  (a) 沿最后一个轴应用一维变换，交换轴，再沿最后一个轴进行变换；以及\n  (b) 直接沿轴1变换，然后沿轴0变换，不进行交换。\n- 如果两个结果之间的最大绝对差小于或等于 $10^{-10}$，则返回布尔值 $true$，否则返回 $false$。\n\n$5$. DCT的两遍变换等效性：\n- 使用与案例4中相同的固定种子生成一个固定的随机数组 $B \\in \\mathbb{R}^{16\\times 10}$。使用与案例4中相同的两种方法计算具有正交归一化的二维DCT-II。\n- 如果两个结果之间的最大绝对差小于或等于 $10^{-10}$，则返回布尔值 $true$，否则返回 $false$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例1到5的顺序排列，例如，格式为\n$[r_1,r_2,r_3,b_4,b_5]$,\n其中 $r_1$、$r_2$ 和 $r_3$ 是浮点数，$b_4$、$b_5$ 是表示为 $True$ 或 $False$ 的布尔值。", "solution": "用户提供的问题已经过分析并被认为是有效的。它具有科学依据、良定、客观，并包含唯一解所需的所有信息。我现在将着手提供一个完整的解决方案。\n\n### 谱泊松求解器的推导\n\n问题是在矩形网格上用齐次狄利克雷边界条件求解离散泊松方程 $-\\Delta_h u = f_h$。设网格函数 $u$ 由一个 $N_y \\times N_x$ 矩阵 $U = [u_{j,i}]$ 表示，其中 $j \\in \\{1, \\dots, N_y\\}$ 是行索引，$i \\in \\{1, \\dots, N_x\\}$ 是列索引。右端项 $f_h$ 同样由一个矩阵 $F = [f_{j,i}]$ 表示。\n\n离散拉普拉斯算子 $\\Delta_h$ 是可分离的，意味着它可以表示为沿每个坐标方向作用的一维算子之和：\n$$ \\Delta_h = D_{xx} + D_{yy} $$\n其中 $(D_{xx} U)_{j,i} = \\frac{u_{j,i-1} - 2u_{j,i} + u_{j,i+1}}{h_x^2}$ 作用于 $U$ 的行，而 $(D_{yy} U)_{j,i} = \\frac{u_{j-1,i} - 2u_{j,i} + u_{j+1,i}}{h_y^2}$ 作用于 $U$ 的列。\n\n令 $A_x$ 为表示 $x$ 方向二阶导数的一维有限差分算子的 $N_x \\times N_x$ 矩阵， $A_y$ 为对应的 $y$ 方向的 $N_y \\times N_y$ 矩阵。这些是对称三对角矩阵：\n$$ A_x = \\frac{1}{h_x^2} \\begin{pmatrix} -2  1   \\\\ 1  -2  1 \\\\   \\ddots  \\ddots  \\ddots \\\\     1  -2 \\end{pmatrix}_{N_x \\times N_x} $$\n$A_y$ 也类似。$D_{xx}$ 的作用对应于右乘 $A_x$，$D_{yy}$ 的作用对应于左乘 $A_y$。离散泊松方程的矩阵形式是：\n$$ -(A_y U + U A_x) = F $$\n\n问题陈述指出，一维算子被I型离散正弦变换 (DST-I) 对角化。令 $S_x$ 和 $S_y$ 分别为大小为 $N_x \\times N_x$ 和 $N_y \\times N_y$ 的正交DST-I变换矩阵。它们的元素由 $(S_x)_{k,i} = \\sqrt{\\frac{2}{N_x+1}} \\sin\\left(\\frac{ki\\pi}{N_x+1}\\right)$ 给出，其中 $k,i=1,\\dots,N_x$，$S_y$ 也类似。这些矩阵是对称的 ($S_x^T = S_x$) 和正交的 ($S_x S_x = I_x$，其中 $I_x$ 是 $N_x \\times N_x$ 的单位矩阵)。\n\n算子 $-A_x$ 和 $-A_y$ 被 $S_x$ 和 $S_y$ 对角化：\n$$ -A_x = S_x \\Lambda_x S_x \\quad \\text{和} \\quad -A_y = S_y \\Lambda_y S_y $$\n其中 $\\Lambda_x$ 和 $\\Lambda_y$ 是包含问题陈述中提供的特征值的对角矩阵：\n$$ (\\Lambda_x)_{k,k} = \\lambda_k^{(x)} = \\frac{4}{h_x^2} \\sin^2\\left(\\frac{k\\pi}{2(N_x+1)}\\right), \\quad k=1,\\dots,N_x $$\n$$ (\\Lambda_y)_{\\ell,\\ell} = \\lambda_\\ell^{(y)} = \\frac{4}{h_y^2} \\sin^2\\left(\\frac{\\ell\\pi}{2(N_y+1)}\\right), \\quad \\ell=1,\\dots,N_y $$\n\n为求解该矩阵方程，我们对其应用二维DST-I。令 $\\hat{U} = S_y U S_x$ 为变换后的解，$\\hat{F} = S_y F S_x$ 为变换后的右端项。我们在方程左侧预乘 $S_y$ 并在右侧后乘 $S_x$：\n$$ S_y ((-A_y U) + (U (-A_x))) S_x = S_y F S_x $$\n$$ (S_y (-A_y)) U S_x + S_y U ((-A_x) S_x) = \\hat{F} $$\n代入对角化表达式：\n$$ (S_y (S_y \\Lambda_y S_y)) U S_x + S_y U ((S_x \\Lambda_x S_x) S_x) = \\hat{F} $$\n利用正交性 ($S_y S_y = I_y$, $S_x S_x = I_x$):\n$$ (I_y \\Lambda_y S_y) U S_x + S_y U (S_x \\Lambda_x I_x) = \\hat{F} $$\n$$ \\Lambda_y (S_y U S_x) + (S_y U S_x) \\Lambda_x = \\hat{F} $$\n这在谱域中得到方程：\n$$ \\Lambda_y \\hat{U} + \\hat{U} \\Lambda_x = \\hat{F} $$\n由于 $\\Lambda_x$ 和 $\\Lambda_y$ 是对角矩阵，这是一个关于变换后矩阵 $\\hat{U}$ 的系数 $\\hat{U}_{\\ell,k}$ 的逐元素代数方程：\n$$ \\lambda_\\ell^{(y)} \\hat{U}_{\\ell,k} + \\hat{U}_{\\ell,k} \\lambda_k^{(x)} = \\hat{F}_{\\ell,k} $$\n$$ (\\lambda_\\ell^{(y)} + \\lambda_k^{(x)}) \\hat{U}_{\\ell,k} = \\hat{F}_{\\ell,k} $$\n因此，变换后系数的解为：\n$$ \\hat{U}_{\\ell,k} = \\frac{\\hat{F}_{\\ell,k}}{\\lambda_\\ell^{(y)} + \\lambda_k^{(x)}} $$\n\n### 算法实现\n\n求解过程包括以下步骤：\n1.  给定右端项网格函数 $F$，计算其二维DST-I, $\\hat{F} = S_y F S_x$。\n2.  构造二维算子的特征值矩阵，$(\\Lambda_{2D})_{\\ell,k} = \\lambda_\\ell^{(y)} + \\lambda_k^{(x)}$。\n3.  通过逐元素除法计算变换后的解系数 $\\hat{U}$：$\\hat{U} = \\hat{F} ./ \\Lambda_{2D}$。\n4.  通过对 $\\hat{U}$ 应用逆二维DST-I来计算最终解 $U$，对于正交DST-I，逆变换就是其本身：$U = S_y \\hat{U} S_x$。\n\n二维变换作为一维变换的两遍来实现。按要求，为提高缓存效率，使用了基于置换的方法。对于一个 $N_y \\times N_x$ 的数组 `data`，二维变换的计算方法如下：\n1.  沿最后一个轴（`axis=-1`）应用一维变换。\n2.  转置结果矩阵（`data.T`）。\n3.  沿新的最后一个轴再次应用一维变换。\n4.  将结果转置回来。\n\n此过程将在辅助函数 `dst1_2d_permute` (用于DST-I) 和 `dct2_2d_permute` (用于DCT-II) 中实现。\n\n对于测试案例1-3，右端项 $f_h$ 是通过 $f_h = -\\Delta_h u$ 从已知的精确解 $u$ 生成的。离散拉普拉斯算子 $\\Delta_h$ 的实现方法是，首先将 $N_y \\times N_x$ 的内部网格函数 $u$ 用一层零填充，创建一个 $(N_y+2) \\times (N_x+2)$ 的数组，表示齐次狄利克雷边界条件。然后将中心有限差分公式应用于此填充后的数组，以计算内部网格上的拉普拉斯算子。\n\n对于测试案例4和5，将检查基于置换的二维变换与直接沿 `axis=1` 然后沿 `axis=0` 应用一维变换的等效性，以验证两遍辅助函数的实现。\n\n最终的数值解 $\\tilde{u}$ 将与已知的精确离散解 $u$ 通过计算相对离散 $\\ell^2$ 误差进行比较：$\\frac{\\| \\tilde{u} - u \\|_2}{\\|u\\|_2}$。对于所选的精确解（它们是离散算子的特征函数），该误差预计会接近机器精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef discrete_laplacian(u, hx, hy):\n    \"\"\"\n    Computes the discrete Laplacian of an interior grid function u\n    with homogeneous Dirichlet boundary conditions.\n    \n    Args:\n        u (np.ndarray): A 2D numpy array of shape (Ny, Nx) representing the grid function.\n        hx (float): Grid spacing in the x-direction.\n        hy (float): Grid spacing in the y-direction.\n        \n    Returns:\n        np.ndarray: A 2D numpy array of shape (Ny, Nx) representing the discrete Laplacian of u.\n    \"\"\"\n    Ny, Nx = u.shape\n    u_padded = np.zeros((Ny + 2, Nx + 2))\n    u_padded[1:-1, 1:-1] = u\n    \n    lap_u = (u_padded[1:-1, 0:-2] - 2 * u_padded[1:-1, 1:-1] + u_padded[1:-1, 2:]) / (hx**2)\n    lap_u += (u_padded[0:-2, 1:-1] - 2 * u_padded[1:-1, 1:-1] + u_padded[2:, 1:-1]) / (hy**2)\n    \n    return lap_u\n\ndef dst1_2d_permute(data):\n    \"\"\"Computes 2D DST-I using 1D transforms on last axis with permutation.\"\"\"\n    temp = fft.dst(data, type=1, axis=-1, norm='ortho')\n    temp = fft.dst(temp.T, type=1, axis=-1, norm='ortho')\n    return temp.T\n\ndef dct2_2d_permute(data):\n    \"\"\"Computes 2D DCT-II using 1D transforms on last axis with permutation.\"\"\"\n    temp = fft.dct(data, type=2, axis=-1, norm='ortho')\n    temp = fft.dct(temp.T, type=2, axis=-1, norm='ortho')\n    return temp.T\n\ndef poisson_solve_dst(f_h, Lx, Ly):\n    \"\"\"\n    Solves the discrete Poisson equation -Delta_h u = f_h using the DST.\n    \n    Args:\n        f_h (np.ndarray): A 2D array of shape (Ny, Nx) for the right-hand side.\n        Lx (float): Length of the domain in x-direction.\n        Ly (float): Length of the domain in y-direction.\n        \n    Returns:\n        np.ndarray: The solution grid function u of shape (Ny, Nx).\n    \"\"\"\n    Ny, Nx = f_h.shape\n    hx = Lx / (Nx + 1)\n    hy = Ly / (Ny + 1)\n    \n    f_hat = dst1_2d_permute(f_h)\n    \n    k = np.arange(1, Nx + 1).reshape(1, -1)\n    l = np.arange(1, Ny + 1).reshape(-1, 1)\n\n    lambda_x = (4 / hx**2) * np.sin(k * np.pi / (2 * (Nx + 1)))**2\n    lambda_y = (4 / hy**2) * np.sin(l * np.pi / (2 * (Ny + 1)))**2\n    \n    lambda_2d = lambda_y + lambda_x\n    \n    u_hat = f_hat / lambda_2d\n    \n    u_solution = dst1_2d_permute(u_hat)\n    \n    return u_solution\n\ndef run_poisson_test(params):\n    \"\"\"Runs a single Poisson solver test case.\"\"\"\n    Nx, Ny, Lx, Ly, m, n = params\n    \n    hx = Lx / (Nx + 1)\n    hy = Ly / (Ny + 1)\n    \n    # Handle the 1D case for meshgrid\n    if Nx == 1:\n        x = np.array([hx])\n    else:\n        x = np.arange(1, Nx + 1) * hx\n    \n    if Ny == 1:\n        y = np.array([hy])\n    else:\n        y = np.arange(1, Ny + 1) * hy\n        \n    xx, yy = np.meshgrid(x, y)\n    \n    u_exact = np.sin(m * np.pi * xx / Lx) * np.sin(n * np.pi * yy / Ly)\n\n    f_h = -discrete_laplacian(u_exact, hx, hy)\n    \n    u_tilde = poisson_solve_dst(f_h, Lx, Ly)\n    \n    norm_diff = np.linalg.norm(u_tilde - u_exact)\n    norm_exact = np.linalg.norm(u_exact)\n    \n    if norm_exact == 0:\n        return 0.0 if norm_diff == 0 else np.inf\n        \n    return norm_diff / norm_exact\n\ndef test_dst_equivalence():\n    \"\"\"Tests equivalence of two methods for 2D DST-I.\"\"\"\n    np.random.seed(42)\n    A = np.random.rand(23, 17)\n    \n    res_permute = dst1_2d_permute(A)\n    \n    temp_direct = fft.dst(A, type=1, axis=1, norm='ortho')\n    res_direct = fft.dst(temp_direct, type=1, axis=0, norm='ortho')\n    \n    max_diff = np.max(np.abs(res_permute - res_direct))\n    return max_diff = 1e-10\n\ndef test_dct_equivalence():\n    \"\"\"Tests equivalence of two methods for 2D DCT-II.\"\"\"\n    np.random.seed(42)\n    B = np.random.rand(16, 10)\n    \n    res_permute = dct2_2d_permute(B)\n    \n    temp_direct = fft.dct(B, type=2, axis=1, norm='ortho')\n    res_direct = fft.dct(temp_direct, type=2, axis=0, norm='ortho')\n    \n    max_diff = np.max(np.abs(res_permute - res_direct))\n    return max_diff = 1e-10\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Poisson solver tests: (Nx, Ny, Lx, Ly, m, n)\n        (32, 20, 1.0, 1.0, 3, 5),\n        (29, 37, 2.0, 0.5, 2, 9),\n        (1, 17, 1.0, 1.0, 1, 7),\n    ]\n\n    results = []\n    \n    # Cases 1, 2, 3\n    for case_params in test_cases:\n        error = run_poisson_test(case_params)\n        results.append(error)\n        \n    # Case 4\n    results.append(test_dst_equivalence())\n    \n    # Case 5\n    results.append(test_dct_equivalence())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3443478"}]}