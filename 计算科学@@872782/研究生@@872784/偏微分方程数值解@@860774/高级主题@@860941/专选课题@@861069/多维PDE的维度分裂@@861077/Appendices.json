{"hands_on_practices": [{"introduction": "检验数值方法有效性的基本步骤之一是使用精确解（或称“人造解”）来验证其收敛阶。本练习将指导您为二维热方程实现一阶精度的李分裂（Lie splitting）和二阶精度的斯特朗分裂（Strang splitting）方法。通过这个过程，您将通过数值实验，亲手验证这些分裂格式在时间上的收敛阶，从而巩固对分裂法核心思想的理解，并获得宝贵的数值验证经验。[@problem_id:3377992]", "problem": "考虑单位正方形上的二维热方程，其边界条件为齐次狄利克雷边界条件，其中给定的精确人造解为 $u(x,y,t)=\\sin(\\pi x)\\sin(\\pi y)\\mathrm{e}^{-2\\pi^2 t}$。其控制偏微分方程为 $\\frac{\\partial u}{\\partial t}=\\frac{\\partial^2 u}{\\partial x^2}+\\frac{\\partial^2 u}{\\partial y^2}$，其中 $(x,y)\\in(0,1)\\times(0,1)$ 且 $t\\ge 0$。初始条件为 $u(x,y,0)=\\sin(\\pi x)\\sin(\\pi y)$，并且对于所有 $t\\ge 0$，在边界 $\\partial\\Omega$ 上 $u=0$。您的任务是基于交替求解一维演化子问题，构建一个维数分裂求解器，并通过将时间步长 $\\Delta t$ 减半来经验性地确定时间上的观测精度阶，同时通过采用足够小的空间网格尺寸 $h$ 来确保空间离散误差可以忽略不计。\n\n请在纯粹的数学和算法环境下进行操作：使用一个内部网格尺寸为 $M\\times M$、间距为 $h=1/(M+1)$ 的均匀笛卡尔网格来离散化 $(0,1)^2$。使用 $M=128$，此时 $h=1/129$。维数分裂必须通过在同一网格上交替求解子问题 $v_t=v_{xx}$ 和 $w_t=w_{yy}$ 来进行，并遵守齐次狄利克雷边界条件。每个一维子问题必须使用沿相应网格线应用的二阶精确且无条件稳定的方法在时间上进行推进。结合一维子求解器以产生一个完整的时间步，可使用一阶 Lie 分裂（先应用一个大小为 $\\Delta t$ 的 $x$ 方向步，然后应用一个大小为 $\\Delta t$ 的 $y$ 方向步）或二阶 Strang 分裂（先应用一个大小为 $\\Delta t/2$ 的 $x$ 方向步，然后应用一个大小为 $\\Delta t$ 的 $y$ 方向步，最后再应用一个大小为 $\\Delta t/2$ 的 $x$ 方向步）。使用精确初始条件在 $t=0$ 处初始化数值解，将其推进到最终时间 $T$，并计算在 $t=T$ 时与精确人造解的离散 $\\ell^2$ 误差，其定义为\n$$\nE(\\Delta t):=\\left(h^2\\sum_{i=1}^{M}\\sum_{j=1}^{M}\\left(u_{i,j}^{\\mathrm{num}}(T)-u\\!\\left(x_i,y_j,T\\right)\\right)^2\\right)^{1/2},\n$$\n其中 $x_i=ih$ 和 $y_j=jh$ 表示内部网格点。\n\n为量化时间上的观测精度阶，请使用一组三个减半的时间步长 $\\Delta t,\\,\\Delta t/2,\\,\\Delta t/4$（其中 $T$ 是这些时间步中每一个的整数倍）。计算误差 $E(\\Delta t)$、$E(\\Delta t/2)$ 和 $E(\\Delta t/4)$，然后计算两个观测阶，\n$$\np_1=\\frac{\\log\\big(E(\\Delta t)/E(\\Delta t/2)\\big)}{\\log(2)},\\quad p_2=\\frac{\\log\\big(E(\\Delta t/2)/E(\\Delta t/4)\\big)}{\\log(2)},\n$$\n并为每个测试用例输出平均值 $\\bar{p}=(p_1+p_2)/2$ 作为单个浮点数。\n\n请实现您的求解器，并为以下三个共同构成测试套件的测试用例生成数值结果：\n- 用例 1：一阶 Lie 分裂，最终时间 $T=0.1$，基础时间步长 $\\Delta t=0.025$（因此减半后的步长为 $0.0125$ 和 $0.00625$）。\n- 用例 2：二阶 Strang 分裂，最终时间 $T=0.1$，基础时间步长 $\\Delta t=0.025$。\n- 用例 3：二阶 Strang 分裂，最终时间 $T=0.2$，基础时间步长 $\\Delta t=0.05$。\n\n在所有用例中，每个空间方向使用 $M=128$ 个内部点，设置 $h=1/129$，并强制施加齐次狄利克雷边界条件。三角函数中的角度必须以弧度为单位。要求的最终输出格式为单行，其中包含一个逗号分隔的 Python 风格列表，列表内是三个用例的浮点平均值 $\\bar{p}$，按上述顺序列出，并用方括号括起来。例如，您的程序应打印类似“[1.0,2.0,2.0]”的内容，但使用为这三个用例实际计算出的浮点值。", "solution": "用户希望解决一个涉及二维热方程的数值分析问题。\n\n## 1. 数学公式\n\n所考虑的问题是单位正方形 $\\Omega = (0,1) \\times (0,1)$ 上的二维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = (\\Delta_x + \\Delta_y) u\n$$\n满足初始条件 $u(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)$ 和齐次狄利克雷边界条件 $u(x,y,t) = 0$，其中 $(x,y) \\in \\partial\\Omega$。给定的人造解为 $u(x,y,t) = \\sin(\\pi x)\\sin(\\pi y)e^{-2\\pi^2 t}$，它满足该偏微分方程和辅助条件。\n\n## 2. 数值方法：算子分裂\n\n为了数值求解此方程，我们采用算子分裂（或维数分裂）技术。其核心思想是将二维拉普拉斯算子 $\\Delta = \\Delta_x + \\Delta_y$ 分解为两个一维算子。然后，通过求解一系列更简单的一维问题来近似解在时间步 $\\Delta t$ 内的演化。\n\n令 $\\mathcal{L}_x = \\Delta_x$ 且 $\\mathcal{L}_y = \\Delta_y$。该偏微分方程为 $\\frac{\\partial u}{\\partial t} = (\\mathcal{L}_x + \\mathcal{L}_y)u$。其形式解为 $u(t) = e^{t(\\mathcal{L}_x + \\mathcal{L}_y)}u(0)$。算子分裂法通过近似矩阵指数 $e^{\\Delta t(\\mathcal{L}_x + \\mathcal{L}_y)}$ 来进行计算。\n\n### 2.1. Lie 分裂（一阶）\n\n一阶 Lie-Trotter 分裂将演化近似为一维演化算子的顺序应用：\n$$\ne^{\\Delta t(\\mathcal{L}_x + \\mathcal{L}_y)} \\approx e^{\\Delta t \\mathcal{L}_y} e^{\\Delta t \\mathcal{L}_x}\n$$\n这种近似引入了量级为 $O(\\Delta t)$ 的分裂误差。将解从时间 $t_n$ 处的 $U^n$ 推进到 $t_{n+1} = t_n + \\Delta t$ 处的 $U^{n+1}$ 的数值格式是一个两步过程：\n1.  求解 $\\frac{\\partial u^*}{\\partial t} = \\mathcal{L}_x u^*$，步长为 $\\Delta t$，初始条件为 $u^*(t_n) = U^n$。设结果为 $U^* = \\mathcal{S}_x(\\Delta t) U^n$。\n2.  求解 $\\frac{\\partial u^{**}}{\\partial t} = \\mathcal{L}_y u^{**}$，步长为 $\\Delta t$，初始条件为 $u^{**}(t_n) = U^*$。最终结果为 $U^{n+1} = \\mathcal{S}_y(\\Delta t) U^* = \\mathcal{S}_y(\\Delta t) \\mathcal{S}_x(\\Delta t) U^n$。\n\n### 2.2. Strang 分裂（二阶）\n\n二阶 Strang 分裂提供了一种更精确的对称近似：\n$$\ne^{\\Delta t(\\mathcal{L}_x + \\mathcal{L}_y)} \\approx e^{\\frac{\\Delta t}{2} \\mathcal{L}_x} e^{\\Delta t \\mathcal{L}_y} e^{\\frac{\\Delta t}{2} \\mathcal{L}_x}\n$$\n这种近似引入了量级为 $O(\\Delta t^2)$ 的分裂误差。其数值格式是一个三步过程：\n1.  在 $x$ 方向求解半个步长：$U^* = \\mathcal{S}_x(\\Delta t/2) U^n$。\n2.  在 $y$ 方向求解一个完整步长：$U^{**} = \\mathcal{S}_y(\\Delta t) U^*$。\n3.  在 $x$ 方向再求解半个步长：$U^{n+1} = \\mathcal{S}_x(\\Delta t/2) U^{**}$。\n\n## 3. 离散化与一维求解器：Crank-Nicolson 方法\n\n该区域使用 $M \\times M$ 个内部点的均匀网格进行离散化，空间步长为 $h = 1/(M+1)$。网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{1, \\dots, M\\}$。\n\n每个一维子问题，例如 $\\frac{\\partial v}{\\partial t} = \\frac{\\partial^2 v}{\\partial x^2}$，都必须使用二阶精确且无条件稳定的方法求解。Crank-Nicolson 方法是标准的选择。对于一维网格上的值 $V_i^n \\approx v(x_i, t_n)$，Crank-Nicolson 离散格式为：\n$$\n\\frac{V_i^{n+1} - V_i^n}{\\Delta \\tau} = \\frac{1}{2} \\left( \\frac{V_{i+1}^n - 2V_i^n + V_{i-1}^n}{h^2} + \\frac{V_{i+1}^{n+1} - 2V_i^{n+1} + V_{i-1}^{n+1}}{h^2} \\right)\n$$\n其中 $\\Delta \\tau$ 是一维求解的时间步长（可以是 $\\Delta t$ 或 $\\Delta t/2$）。设扩散数为 $\\alpha = \\frac{\\Delta \\tau}{2h^2}$。整理各项后，我们得到一个关于未知值 $V_i^{n+1}$ 的线性方程组：\n$$\n-\\alpha V_{i-1}^{n+1} + (1+2\\alpha)V_i^{n+1} - \\alpha V_{i+1}^{n+1} = \\alpha V_{i-1}^n + (1-2\\alpha)V_i^n + \\alpha V_{i+1}^n\n$$\n对于 $i=1, \\dots, M$。边界条件 $V_0 = V_{M+1} = 0$ 已被纳入。这就形成了一个三对角方程组 $A \\mathbf{V}^{n+1} = B \\mathbf{V}^n$，其中 $\\mathbf{V}^n$ 是时间 $t_n$ 的值向量。矩阵 $A$ 是三对角矩阵，其对角元素为 $(1+2\\alpha)$，非对角元素为 $-\\alpha$。该系统可以使用三对角矩阵算法（例如 Thomas 算法）高效地求解 $\\mathbf{V}^{n+1}$。\n\n## 4. 算法实现\n\n对于三个测试用例中的每一个，都执行以下流程：\n1.  设置参数：分裂方法类型、最终时间 $T$、基础时间步长 $\\Delta t_{base}$ 和网格尺寸 $M=128$。\n2.  为精度测试定义三个时间步长：$\\Delta t_1 = \\Delta t_{base}$、$\\Delta t_2 = \\Delta t_{base}/2$、$\\Delta t_3 = \\Delta t_{base}/4$。\n3.  对于每个时间步长 $\\Delta t_k$：\n    a. 使用初始条件 $u(x,y,0)$ 在内部网格点上的值初始化一个 $M \\times M$ 的矩阵 $U$。\n    b. 计算时间步数 $N_k = T/\\Delta t_k$。\n    c. 通过迭代 $N_k$ 次，将解从 $t=0$ 演化到 $t=T$：\n        i. 在每次迭代中，应用所选的分裂格式（Lie 或 Strang）。\n        ii. 每次应用一维求解器 $\\mathcal{S}_x(\\tau)$ 或 $\\mathcal{S}_y(\\tau)$ 时，分别需要遍历当前数据矩阵的所有行或列，并使用 Crank-Nicolson 方法求解生成的三对角系统。对于按列操作，先将矩阵转置，然后应用按行求解器，最后将结果转置回来。\n    d. 在最终时间 $T$，计算网格点上的精确解矩阵 $U_{exact}$。\n    e. 计算离散 $\\ell^2$ 误差：\n       $$\n       E(\\Delta t_k) = \\left(h^2\\sum_{i=1}^{M}\\sum_{j=1}^{M}\\left(U_{ij}^{\\mathrm{num}}(T) - U_{ij}^{\\mathrm{exact}}(T)\\right)^2\\right)^{1/2} = h \\cdot \\|U^{\\mathrm{num}}(T) - U^{\\mathrm{exact}}(T)\\|_{\\text{F}}\n       $$\n       其中 $\\|\\cdot\\|_{\\text{F}}$ 是 Frobenius 范数。\n4. 计算出三个误差 $E_1, E_2, E_3$ 后，计算观测到的收敛阶：\n   $$\n   p_1 = \\frac{\\log(E_1/E_2)}{\\log(2)}, \\quad p_2 = \\frac{\\log(E_2/E_3)}{\\log(2)}\n   $$\n5. 该测试用例的最终结果是平均观测阶 $\\bar{p} = (p_1+p_2)/2$。\n\n此过程为三个指定的测试用例中的每一个都产生一个 $\\bar{p}$ 值。Lie 分裂预计会显示出一阶收敛性（$\\bar{p} \\approx 1.0$），而 Strang 分裂应显示出二阶收敛性（$\\bar{p} \\approx 2.0$），前提是时间分裂误差主导空间离散误差，这一点由较小的 $h=1/129$ 值保证。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef cn_step(u_in, dt_1d, h, M):\n    \"\"\"\n    Performs one step of the Crank-Nicolson method for the 1D heat equation.\n    u_t = u_xx with homogeneous Dirichlet boundary conditions. The method solves\n    the tridiagonal system (I - alpha*A_lap) u_new = (I + alpha*A_lap) u_in.\n\n    Args:\n        u_in (np.ndarray): The 1D array of solution values at the current time.\n        dt_1d (float): The time step for this 1D solve.\n        h (float): The spatial grid spacing.\n        M (int): The number of interior grid points.\n\n    Returns:\n        np.ndarray: The updated 1D array of solution values.\n    \"\"\"\n    alpha = dt_1d / (2.0 * h**2)\n\n    # Construct the right-hand side vector: b = (I + alpha*A_lap) * u_in\n    b = np.zeros(M)\n    b[0] = (1.0 - 2.0 * alpha) * u_in[0] + alpha * u_in[1]\n    b[M-1] = alpha * u_in[M-2] + (1.0 - 2.0 * alpha) * u_in[M-1]\n    b[1:-1] = alpha * u_in[:-2] + (1.0 - 2.0 * alpha) * u_in[1:-1] + alpha * u_in[2:]\n\n    # Construct the banded matrix for the left-hand side: A_lhs = (I - alpha*A_lap)\n    # The `ab` matrix for solve_banded has shape (3, M) for a tridiagonal system.\n    ab = np.zeros((3, M))\n    ab[0, 1:] = -alpha          # Super-diagonal\n    ab[1, :] = 1.0 + 2.0 * alpha  # Main diagonal\n    ab[2, :-1] = -alpha         # Sub-diagonal\n\n    # Solve the tridiagonal system A_lhs * u_out = b.\n    # (1, 1) specifies one sub-diagonal and one super-diagonal.\n    u_out = solve_banded((1, 1), ab, b)\n    return u_out\n\ndef run_simulation(splitting_type, T, dt_base, M):\n    \"\"\"\n    Runs the full simulation for a given case to find the order of accuracy.\n    It computes the solution for three time steps (dt_base, dt_base/2, dt_base/4)\n    and uses the resulting errors to calculate the observed order of convergence.\n\n    Args:\n        splitting_type (str): 'Lie' or 'Strang'.\n        T (float): The final simulation time.\n        dt_base (float): The base time step.\n        M (int): The number of interior grid points per dimension.\n\n    Returns:\n        float: The average observed order of accuracy.\n    \"\"\"\n    h = 1.0 / (M + 1.0)\n    x = h * np.arange(1, M + 1)\n    xx, yy = np.meshgrid(x, x, indexing='ij')\n\n    dts = [dt_base, dt_base / 2.0, dt_base / 4.0]\n    errors = []\n\n    for dt in dts:\n        # Initialize the solution matrix with the initial condition\n        U = np.sin(np.pi * xx) * np.sin(np.pi * yy)\n        num_steps = int(round(T / dt))\n\n        for _ in range(num_steps):\n            if splitting_type == 'Lie':\n                # --- Lie Splitting Step ---\n                # X-sweep (full dt)\n                U_star = np.zeros_like(U)\n                for i in range(M):\n                    U_star[i, :] = cn_step(U[i, :], dt, h, M)\n                \n                # Y-sweep (full dt)\n                U_next = np.zeros_like(U)\n                for j in range(M):\n                    U_next[:, j] = cn_step(U_star[:, j], dt, h, M)\n                U = U_next\n\n            elif splitting_type == 'Strang':\n                # --- Strang Splitting Step ---\n                dt_half = dt / 2.0\n                \n                # X-sweep (dt/2)\n                U_star = np.zeros_like(U)\n                for i in range(M):\n                    U_star[i, :] = cn_step(U[i, :], dt_half, h, M)\n\n                # Y-sweep (full dt)\n                U_dstar = np.zeros_like(U)\n                for j in range(M):\n                    U_dstar[:, j] = cn_step(U_star[:, j], dt, h, M)\n\n                # X-sweep (dt/2)\n                U_next = np.zeros_like(U)\n                for i in range(M):\n                    U_next[i, :] = cn_step(U_dstar[i, :], dt_half, h, M)\n                U = U_next\n\n        # Compute the L2 error at the final time T\n        U_exact = np.sin(np.pi * xx) * np.sin(np.pi * yy) * np.exp(-2.0 * np.pi**2 * T)\n        # The error is defined as h * ||U_num - U_exact||_F\n        error = h * np.linalg.norm(U - U_exact)\n        errors.append(error)\n\n    E1, E2, E3 = errors\n    p1 = np.log(E1 / E2) / np.log(2.0)\n    p2 = np.log(E2 / E3) / np.log(2.0)\n\n    p_avg = (p1 + p2) / 2.0\n    return p_avg\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the simulation for all test cases\n    and prints the final result in the specified format.\n    \"\"\"\n    # Define the problem-specific parameters\n    M = 128\n\n    test_cases = [\n        # Case 1: Lie splitting, T=0.1, base dt=0.025\n        {'type': 'Lie', 'T': 0.1, 'dt_base': 0.025, 'M': M},\n        \n        # Case 2: Strang splitting, T=0.1, base dt=0.025\n        {'type': 'Strang', 'T': 0.1, 'dt_base': 0.025, 'M': M},\n        \n        # Case 3: Strang splitting, T=0.2, base dt=0.05\n        {'type': 'Strang', 'T': 0.2, 'dt_base': 0.05, 'M': M}\n    ]\n\n    results = []\n    for case in test_cases:\n        p_avg = run_simulation(case['type'], case['T'], case['dt_base'], case['M'])\n        results.append(p_avg)\n\n    # Print the results in the required format: [p1,p2,p3]\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3377992"}, {"introduction": "从抛物型方程转向双曲型方程后，我们需要关注一个至关重要的新问题：物理量的守恒。对于守恒律方程，例如描述物质输运的对流方程，数值格式能否保持总质量（或其他守恒量）不变是衡量其可靠性的关键。本练习将对比一种“朴素的”非守恒分裂格式和一种基于通量的守恒分裂格式 [@problem_id:3377962]。您将发现，在处理可压缩流场时，前者会人为地产生或消减质量，而后者则能精确地维持质量守恒，从而深刻理解为何在设计数值格式时必须将守恒性放在首位。", "problem": "考虑在周期性方形区域 $[0,1] \\times [0,1]$ 上的二维偏微分方程 (PDE) $\\frac{\\partial u}{\\partial t} + \\nabla \\cdot (\\mathbf{b}(x,y) u) = 0$，其中 $\\mathbf{b}(x,y) = (b_x(x,y), b_y(x,y))$ 是一个可压缩漂移场，而 $u(x,y,t)$ 是一个标量密度。在该区域上的守恒积分形式意味着，对于光滑解和周期性边界条件，总质量 $M(t) = \\int_0^1 \\int_0^1 u(x,y,t) \\, dx \\, dy$ 必须满足 $\\frac{dM}{dt} = -\\int_{\\partial \\Omega} (\\mathbf{b} u) \\cdot \\mathbf{n} \\, ds = 0$，因此 $M(t)$ 不随时间变化。\n\n在一个具有 $N_x$ 个 $x$方向单元和 $N_y$ 个 $y$方向单元的均匀笛卡尔网格上，设计并实现两种带有周期性边界条件的分步数值格式：\n- 一种朴素的维度分裂格式，该格式在每次扫描中以输运形式处理偏微分方程，通过在 $x$ 方向扫描中使用 $\\frac{\\partial u}{\\partial t} \\approx -b_x \\frac{\\partial u}{\\partial x}$ 和在 $y$ 方向扫描中使用 $\\frac{\\partial u}{\\partial t} \\approx -b_y \\frac{\\partial u}{\\partial y}$ 进行更新，采用基于单元中心 $b_x$ 和 $b_y$ 的一阶迎风有限差分，并忽略可压缩源项 $u \\, \\nabla \\cdot \\mathbf{b}$。该格式在 $x$ 方向扫描中必须使用单元中心速度和一维迎风格式 $u_{i,j} \\gets u_{i,j} - \\frac{\\Delta t}{\\Delta x} \\left[a_{i,j}^+ (u_{i,j} - u_{i-1,j}) + a_{i,j}^- (u_{i+1,j} - u_{i,j})\\right]$，其中 $a_{i,j} = b_x(x_i,y_j)$，$a^+ = \\max(a,0)$，$a^- = \\min(a,0)$，对于 $y$ 方向扫描也是类似的。\n- 一种守恒的维度分裂格式，该格式在每次扫描中以通量形式更新，$x$ 方向扫描为 $u_{i,j} \\gets u_{i,j} - \\frac{\\Delta t}{\\Delta x} \\left[F_{i+1/2,j} - F_{i-1/2,j}\\right]$，其中 $F_{i+1/2,j} = b_x(x_{i+1/2}, y_j) \\, u^{\\text{up}}_{i+1/2,j}$ 是在面 $(x_{i+1/2}, y_j)$ 上乘积 $b_x u$ 的迎风面通量，而 $u^{\\text{up}}_{i+1/2,j}$ 根据 $b_x(x_{i+1/2}, y_j)$ 的符号从左侧或右侧相邻单元中选择。对 $y$ 方向扫描使用类似的通量形式，面通量为 $G_{i,j+1/2} = b_y(x_i, y_{j+1/2}) \\, u^{\\text{up}}_{i,j+1/2}$。该格式必须使用面中心速度和乘积 $b u$ 的迎风格式，确保在周期性边界下每次扫描的离散质量守恒。\n\n从基本守恒律 $\\frac{\\partial u}{\\partial t} + \\nabla \\cdot (\\mathbf{b} u)=0$ 出发，推导离散更新公式，说明所需的假设，并阐明输运形式和守恒形式之间的区别。从数学上证明，当 $\\mathbf{b}(x,y)$ 在空间上变化（可压缩漂移）时，由于输运形式分裂中离散乘积法则的失效，朴素分步法会在网格单元角点附近引入人为的质量源。然后，推导一种基于通量的更新修正，通过通量差的伸缩求和来强制实现每次扫描的质量守恒。\n\n实现这两种格式，并在一个完整的、由一次 $x$ 方向扫描和一次 $y$ 方向扫描组成的时间步后，比较它们的离散质量误差。使用 Courant–Friedrichs–Lewy (CFL) 条件来选择 $\\Delta t$，即 $\\Delta t = \\text{CFL} \\cdot \\min\\left(\\frac{\\Delta x}{\\max |b_x|}, \\frac{\\Delta y}{\\max |b_y|}\\right)$，其中 $\\text{CFL} = 0.4$。使用初始条件 $u(x,y,0) = \\exp\\left(-\\frac{(x-x_0)^2 + (y-y_0)^2}{2 \\sigma^2}\\right)$，其中 $x_0 = 0.3$，$y_0 = 0.7$，$\\sigma = 0.05$。网格由单元中心 $x_i = (i + \\tfrac{1}{2}) \\Delta x$，$y_j = (j + \\tfrac{1}{2}) \\Delta y$（其中 $i = 0, \\dots, N_x-1$ 和 $j = 0, \\dots, N_y-1$）以及单元面 $x_{i+1/2} = (i+1) \\Delta x$，$y_{j+1/2} = (j+1) \\Delta y$ 定义。\n\n测试套件：\n- 情况 1 (理想情况，无散度漂移): $N_x = 64$, $N_y = 64$, $b_x(x,y) = \\cos(2\\pi y)$, $b_y(x,y) = -\\cos(2\\pi x)$。\n- 情况 2 (可压缩漂移): $N_x = 64$, $N_y = 64$, $b_x(x,y) = 2\\pi \\sin(2\\pi x) \\left[1 + 0.5 \\cos(2\\pi y)\\right]$, $b_y(x,y) = 2\\pi \\sin(2\\pi y) \\left[1 - 0.5 \\cos(2\\pi x)\\right]$。\n- 情况 3 (具有急剧符号变化和角点伪影的边缘情况): $N_x = 32$, $N_y = 32$, $b_x(x,y) = 2\\pi \\tanh\\left(4 \\sin(2\\pi x) \\cos(2\\pi y)\\right)$, $b_y(x,y) = 2\\pi \\tanh\\left(4 \\cos(2\\pi x) \\sin(2\\pi y)\\right)$。\n\n对于每种情况，运行一个完整的分步，并报告两个浮点数：\n- 朴素格式的绝对质量误差 $|M^{\\text{naive}} - M^0|$，其中 $M^0$ 是初始质量，$M^{\\text{naive}}$ 是朴素分步后的质量。\n- 守恒格式的绝对质量误差 $|M^{\\text{cons}} - M^0|$，其中 $M^{\\text{cons}}$ 是守恒分步后的质量。\n\n最终输出格式：您的程序应生成一行输出，其中包含六个结果，以逗号分隔列表的形式包含在方括号内，顺序为 [情况1朴素误差, 情况1守恒误差, 情况2朴素误差, 情况2守恒误差, 情况3朴素误差, 情况3守恒误差]。", "solution": "所提出的问题是有效的。这是一个适定的、有科学依据的偏微分方程数值方法领域的问题，专门探讨了守恒律的守恒和非守恒离散格式之间的关键差异。它包含了获得唯一解所需的所有必要信息和定义。\n\n该问题的核心是守恒形式的二维平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + \\nabla \\cdot (\\mathbf{b} u) = 0\n$$\n其中 $u(x,y,t)$ 是一个标量密度，$\\mathbf{b}(x,y) = (b_x(x,y), b_y(x,y))$ 是一个给定的速度场。这个方程表达了量 $u$ 的守恒。在区域 $\\Omega = [0,1] \\times [0,1]$ 内的总质量，定义为 $M(t) = \\int_{0}^{1}\\int_{0}^{1} u(x,y,t) \\,dx\\,dy$，是一个守恒量。在周期性边界条件下应用散度定理可以证实这一点：\n$$\n\\frac{dM}{dt} = \\int_{\\Omega} \\frac{\\partial u}{\\partial t} \\,dx\\,dy = -\\int_{\\Omega} \\nabla \\cdot (\\mathbf{b} u) \\,dx\\,dy = -\\int_{\\partial\\Omega} (\\mathbf{b} u) \\cdot \\mathbf{n} \\,ds = 0\n$$\n由于周期性，边界 $\\partial\\Omega$ 上的积分消失。理想情况下，一个数值格式应该保持此性质的离散模拟。\n\n使用乘积法则，该偏微分方程可以展开为所谓的“输运”或“非守恒”形式：\n$$\n\\frac{\\partial u}{\\partial t} + \\mathbf{b} \\cdot \\nabla u + u(\\nabla \\cdot \\mathbf{b}) = 0\n$$\n当速度场是可压缩的，即 $\\nabla \\cdot \\mathbf{b} \\neq 0$ 时，项 $u(\\nabla \\cdot \\mathbf{b})$ 充当源项或汇项。\n\n维度分裂或算子分裂通过求解一系列一维方程来近似二维方程的解。对于一阶 Lie-Trotter 分裂，我们通过首先求解 $x$ 方向的偏微分方程一个时间步 $\\Delta t$，然后将结果作为初始条件来求解 $y$ 方向的偏微分方程一个时间步 $\\Delta t$，从而完成一个完整时间步的求解。\n\n**格式 1：输运形式的朴素维度分裂**\n\n该格式基于对偏微分方程的不正确分裂。它分裂了平流算子 $\\mathbf{b} \\cdot \\nabla u = b_x \\frac{\\partial u}{\\partial x} + b_y \\frac{\\partial u}{\\partial y}$，并忽略了源项 $u(\\nabla \\cdot \\mathbf{b})$。\n\n$x$ 方向扫描求解：$\\frac{\\partial u}{\\partial t} + b_x \\frac{\\partial u}{\\partial x} = 0$。\n$y$ 方向扫描求解：$\\frac{\\partial u}{\\partial t} + b_y \\frac{\\partial u}{\\partial y} = 0$。\n\n这种方法仅在 $\\nabla \\cdot \\mathbf{b}=0$（不可压缩流）并且分裂操作谨慎执行时才有效。对于一般的可压缩场，这种提法是根本错误的，因为它忽略了一个物理源项。\n\n问题指定了在具有单元中心 $(x_i, y_j)$ 的网格上对 $x$ 方向扫描采用一阶迎风离散化，使用单元中心速度 $a_{i,j} = b_x(x_i, y_j)$：\n$$\n\\frac{u_{i,j}^{*} - u_{i,j}^{n}}{\\Delta t} = - \\left[ a_{i,j}^+ \\frac{u_{i,j}^n - u_{i-1,j}^n}{\\Delta x} + a_{i,j}^- \\frac{u_{i+1,j}^n - u_{i,j}^n}{\\Delta x} \\right]\n$$\n其中 $a^+ = \\max(a,0)$ 且 $a^- = \\min(a,0)$。这与所提供的更新规则等价。对 $y$ 方向扫描执行类似的步骤。\n\n为了证明质量不守恒，我们对给定行 $j$ 的所有单元 $i=0, \\dots, N_x-1$ 的单元值变化求和。该行质量的变化与 $\\sum_{i} (u_{i,j}^{*} - u_{i,j}^{n}) \\Delta x$ 成正比。为简单起见，我们假设对所有 $i$ 都有 $a_{i,j}>0$。更新规则简化为 $u_{i,j}^{*} = u_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x} a_{i,j} (u_{i,j}^{n} - u_{i-1,j}^{n})$。变化的总和为：\n$$\n\\sum_{i=0}^{N_x-1} (u_{i,j}^{*} - u_{i,j}^{n}) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i=0}^{N_x-1} a_{i,j} (u_{i,j}^{n} - u_{i-1,j}^{n})\n$$\n通过重新索引求和（在第二项中令 $k=i-1$）并应用周期性边界条件（$u_{-1,j} = u_{N_x-1,j}$，$a_{N_x,j}=a_{0,j}$）：\n$$\n\\sum_{i} (u_{i,j}^{*} - u_{i,j}^{n}) = -\\frac{\\Delta t}{\\Delta x} \\left( \\sum_{i} a_{i,j} u_{i,j}^n - \\sum_{i} a_{i,j} u_{i-1,j}^n \\right) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i} (a_{i,j} - a_{i+1,j}) u_{i,j}^n\n$$\n如果 $a_{i,j} = b_x(x_i, y_j)$ 随 $x$ 变化，即 $\\frac{\\partial b_x}{\\partial x} \\neq 0$，则此和不为零。因此，该格式会人为地产生或破坏质量，违反了基本守恒原理。如果 $b_y$ 随 $y$ 变化，则对 $y$ 方向扫描同样成立。\n\n**格式 2：通量形式的守恒维度分裂**\n\n该格式正确地分裂了偏微分方程的守恒形式。\n$x$ 方向扫描求解：$\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}(b_x u) = 0$。\n$y$ 方向扫描求解：$\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial y}(b_y u) = 0$。\n\n这是一种有限体积法。我们将 $x$ 方向扫描的偏微分方程在一个控制体积 $V_{i,j} = [x_{i-1/2}, x_{i+1/2}] \\times [y_{j-1/2}, y_{j+1/2}]$ 上积分。我们可以一次只考虑一个维度。单元 $i$ 中的平均值为 $u_{i,j}(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x, y_j, t) \\,dx$。积分后的偏微分方程变为：\n$$\n\\frac{d u_{i,j}}{dt} \\Delta x + \\left[ (b_x u)|_{x_{i+1/2}, y_j} - (b_x u)|_{x_{i-1/2}, y_j} \\right] = 0\n$$\n我们定义数值通量 $F_{i+1/2,j}$ 来近似单元界面 $x_{i+1/2}$ 处的真实通量 $(b_x u)$。前向欧拉时间离散化得到：\n$$\nu_{i,j}^{*} = u_{i,j}^{n} - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2,j}^n - F_{i-1/2,j}^n \\right)\n$$\n对于一阶迎风格式，通量由面上的速度符号决定，$b_{x, i+1/2, j} = b_x(x_{i+1/2}, y_j)$：\n$$\nF_{i+1/2,j} = \n\\begin{cases} \nb_{x, i+1/2, j} \\, u_{i,j}  \\text{if } b_{x, i+1/2, j} \\geq 0 \\\\\nb_{x, i+1/2, j} \\, u_{i+1,j}  \\text{if } b_{x, i+1/2, j}  0\n\\end{cases}\n= b_{x, i+1/2, j}^+ u_{i,j} + b_{x, i+1/2, j}^- u_{i+1,j}\n$$\n为了验证离散质量守恒，我们将更新规则对所有 $i$ 求和：\n$$\n\\sum_{i=0}^{N_x-1} (u_{i,j}^{*} - u_{i,j}^{n}) = -\\frac{\\Delta t}{\\Delta x} \\sum_{i=0}^{N_x-1} (F_{i+1/2,j} - F_{i-1/2,j})\n$$\n右侧的和是一个伸缩级数：\n$$\n\\sum_{i=0}^{N_x-1} (F_{i+1/2,j} - F_{i-1/2,j}) = (F_{1/2,j} - F_{-1/2,j}) + (F_{3/2,j} - F_{1/2,j}) + \\dots + (F_{N_x-1/2,j} - F_{N_x-3/2,j})\n$$\n由于周期性边界条件，面 $x_{-1/2}$ 处的通量与面 $x_{N_x-1/2}$ 处的通量相同。因此，和抵消为零。每行 $j$ 的总质量 $\\sum_i u_{i,j} \\Delta x$ 在机器精度内是守恒的。类似的论证也适用于 $y$ 方向扫描。\n\n非守恒离散化与分裂误差的结合，可能导致朴素格式中显著的误差累积。该分裂误差与 $x$ 和 $y$ 算子的交换子成正比，并涉及混合导数，常在速度场散度最大的地方表现为伪影。守恒格式通过将每个分裂步骤正确地表述为守恒律，避免了主要的误差源，只剩下分裂误差，该误差影响解的准确性，但不影响其总质量。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares a naive and a conservative dimensional splitting scheme\n    for the 2D advection equation, reporting the mass conservation error for each.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"Nx\": 64, \"Ny\": 64,\n            \"bx_func\": lambda x, y: np.cos(2 * np.pi * y),\n            \"by_func\": lambda x, y: -np.cos(2 * np.pi * x)\n        },\n        {\n            \"Nx\": 64, \"Ny\": 64,\n            \"bx_func\": lambda x, y: 2 * np.pi * np.sin(2 * np.pi * x) * (1 + 0.5 * np.cos(2 * np.pi * y)),\n            \"by_func\": lambda x, y: 2 * np.pi * np.sin(2 * np.pi * y) * (1 - 0.5 * np.cos(2 * np.pi * x))\n        },\n        {\n            \"Nx\": 32, \"Ny\": 32,\n            \"bx_func\": lambda x, y: 2 * np.pi * np.tanh(4 * np.sin(2 * np.pi * x) * np.cos(2 * np.pi * y)),\n            \"by_func\": lambda x, y: 2 * np.pi * np.tanh(4 * np.cos(2 * np.pi * x) * np.sin(2 * np.pi * y))\n        }\n    ]\n\n    results = []\n    CFL = 0.4\n    x0, y0, sigma = 0.3, 0.7, 0.05\n\n    for case in test_cases:\n        Nx, Ny = case[\"Nx\"], case[\"Ny\"]\n        bx_func, by_func = case[\"bx_func\"], case[\"by_func\"]\n\n        # Grid setup\n        dx = 1.0 / Nx\n        dy = 1.0 / Ny\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        x_faces = np.arange(Nx) * dx  # Faces are at 0, dx, 2dx ... (Nx-1)dx\n        y_faces = np.arange(Ny) * dy\n        \n        # Correct face grid for periodic domain [0,1]\n        x_faces_full = np.arange(Nx + 1) * dx\n        y_faces_full = np.arange(Ny + 1) * dy\n\n\n        XX_cen, YY_cen = np.meshgrid(y_centers, x_centers, indexing='ij')\n        XX_xf, YY_xf = np.meshgrid(y_centers, x_faces_full, indexing='ij')\n        XX_yf, YY_yf = np.meshgrid(y_faces_full, x_centers, indexing='ij')\n        \n\n        # Initial condition\n        u0 = np.exp(-((XX_cen - x0)**2 + (YY_cen - y0)**2) / (2 * sigma**2))\n        initial_mass = np.sum(u0) * dx * dy\n\n        # Time step calculation\n        bx_vals = bx_func(XX_cen, YY_cen).flatten()\n        by_vals = by_func(XX_cen, YY_cen).flatten()\n\n        max_bx = np.max(np.abs(bx_vals)) if bx_vals.size > 0 else 0\n        max_by = np.max(np.abs(by_vals)) if by_vals.size > 0 else 0\n        \n        dt = CFL * min(dx / (max_bx + 1e-9), dy / (max_by + 1e-9))\n        \n        # --- Scheme 1: Naive Splitting ---\n        u_naive = np.copy(u0)\n\n        # X-sweep (naive)\n        bx_center = bx_func(XX_cen, YY_cen)\n        bx_p = np.maximum(bx_center, 0)\n        bx_m = np.minimum(bx_center, 0)\n        u_im1 = np.roll(u_naive, 1, axis=1)\n        u_ip1 = np.roll(u_naive, -1, axis=1)\n        u_star = u_naive - (dt / dx) * (bx_p * (u_naive - u_im1) + bx_m * (u_ip1 - u_naive))\n        \n        # Y-sweep (naive)\n        by_center = bx_func(XX_cen, YY_cen)\n        by_p = np.maximum(by_center, 0)\n        by_m = np.minimum(by_center, 0)\n        u_jm1 = np.roll(u_star, 1, axis=0)\n        u_jp1 = np.roll(u_star, -1, axis=0)\n        u_final_naive = u_star - (dt / dy) * (by_p * (u_star - u_jm1) + by_m * (u_jp1 - u_star))\n        \n        mass_naive = np.sum(u_final_naive) * dx * dy\n        error_naive = np.abs(mass_naive - initial_mass)\n        results.append(error_naive)\n\n        # --- Scheme 2: Conservative Splitting ---\n        u_cons = np.copy(u0)\n\n        # X-sweep (conservative)\n        # Face velocities: Need to define faces correctly for periodic domain\n        x_faces_coords = np.arange(Nx) * dx\n        XX_face_x, YY_face_x = np.meshgrid(y_centers, x_faces_coords, indexing='ij')\n        bx_face = bx_func(XX_face_x, YY_face_x)\n\n        bx_face_p = np.maximum(bx_face, 0)\n        bx_face_m = np.minimum(bx_face, 0)\n        \n        u_im1 = np.roll(u_cons, 1, axis=1)\n        flux_x = bx_face_p * u_im1 + bx_face_m * u_cons\n        flux_x_ip1 = np.roll(flux_x, -1, axis=1)\n        \n        u_star_cons = u_cons - (dt / dx) * (flux_x_ip1 - flux_x)\n\n        # Y-sweep (conservative)\n        y_faces_coords = np.arange(Ny) * dy\n        XX_face_y, YY_face_y = np.meshgrid(y_faces_coords, x_centers, indexing='ij')\n        by_face = by_func(XX_face_y, YY_face_y)\n        \n        by_face_p = np.maximum(by_face, 0)\n        by_face_m = np.minimum(by_face, 0)\n\n        u_jm1 = np.roll(u_star_cons, 1, axis=0)\n        flux_y = by_face_p * u_jm1 + by_face_m * u_star_cons\n        flux_y_jp1 = np.roll(flux_y, -1, axis=0)\n        \n        u_final_cons = u_star_cons - (dt / dy) * (flux_y_jp1 - flux_y)\n\n        mass_cons = np.sum(u_final_cons) * dx * dy\n        error_cons = np.abs(mass_cons - initial_mass)\n        results.append(error_cons)\n\n    # Print results in the specified format\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "3377962"}, {"introduction": "维度分裂法不仅可以作为直接求解器，其思想在构建迭代求解器的预条件子时也同样强大，尤其是在处理包含混合导数的复杂各向异性问题时。本练习将带您进入一个更高级的应用场景：为多孔介质流中的各向异性扩散方程构建一个交替方向隐式（ADI）预条件子 [@problem_id:3377961]。通过计算和分析预条件处理后系统的特征值分布，您将探索预条件子的性能如何依赖于问题的物理属性（如各向异性方向），从而理解如何利用分裂思想来加速复杂问题的求解。", "problem": "考虑多孔介质流动的各向异性扩散算子，由单位正方形域 $[0,1]\\times[0,1]$ 上的散度形式偏微分方程 $-\\nabla\\cdot\\left(K(x,y)\\nabla p(x,y,t)\\right)=q(x,y,t)$ 给出，边界条件为齐次 Dirichlet 条件 $p=0$ on $\\partial\\Omega$。在时间步长为 $\\Delta t$ 的后向隐式瞬态格式中，每个时间步都需要求解一个形式为 $(I-\\Delta t\\,L)\\,p^{n+1}=b^n$ 的线性系统，其中 $I$ 是单位算子，$L$ 是 $-\\nabla\\cdot\\left(K\\nabla\\cdot\\right)$ 的空间离散，而 $b^n$ 是已知的右端项。交替方向隐式 (ADI) 分裂引入了一个由 $L$ 的方向分量构建的预条件子 $M$。\n\n您的任务是为瞬态步中的椭圆求解构建一个维度分裂 ADI 预条件子，并研究预处理算子的特征值聚集如何随各向异性张量的方向变化。请使用以下科学标准基础：\n\n- 各向异性张量 $K$ 在空间上是常数，由 $K=R(\\theta)\\,\\mathrm{diag}(k_\\parallel,k_\\perp)\\,R(\\theta)^\\top$ 给出，其中 $R(\\theta)=\\begin{pmatrix}\\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta\\end{pmatrix}$ 是旋转矩阵，$k_\\parallel\\ge k_\\perp0$ 是主扩散系数，$\\theta$ 是以弧度为单位的方向角。\n- 对于常系数，算子简化为 $-\\nabla\\cdot(K\\nabla p)=-(K_{xx}\\,\\frac{\\partial^2 p}{\\partial x^2}+2K_{xy}\\,\\frac{\\partial^2 p}{\\partial x \\partial y}+K_{yy}\\,\\frac{\\partial^2 p}{\\partial y^2})$，其中 $K_{xx}$、$K_{xy}$ 和 $K_{yy}$ 是 $K$ 在坐标系下的分量。\n- 在均匀网格上使用二阶中心有限差分，每个坐标方向有 $N$ 个内部点，网格间距为 $h=1/(N+1)$，并采用齐次 Dirichlet 边界条件。离散化：\n  1. 将一维二阶导数离散化为一个三对角矩阵 $D_{xx}\\in\\mathbb{R}^{N\\times N}$，其对角线元素为 $-2/h^2$，非对角线元素为 $1/h^2$。\n  2. 将一维一阶导数离散化为一个三对角矩阵 $D_x\\in\\mathbb{R}^{N\\times N}$，其上对角线元素为 $1/(2h)$，下对角线元素为 $-1/(2h)$（在缺失邻点处的元素隐式地乘以零边界值）。\n- 通过 Kronecker 积构建二维离散算子：\n  1. $A_{xx}=-K_{xx}\\,(D_{xx}\\otimes I_N)$,\n  2. $A_{yy}=-K_{yy}\\,(I_N\\otimes D_{xx})$,\n  3. $A_{xy}=-2K_{xy}\\,(D_x\\otimes D_x)$,\n  其中 $I_N$ 是 $N\\times N$ 单位矩阵，$\\otimes$ 表示 Kronecker 积。完整的离散算子为 $A=A_{xx}+A_{yy}+A_{xy}\\in\\mathbb{R}^{N^2\\times N^2}$。\n- 构建瞬态步矩阵 $S=I_{N^2}-\\Delta t\\,A$ 和 ADI 分裂预条件子 $M=(I_{N^2}-\\Delta t\\,A_x)(I_{N^2}-\\Delta t\\,A_y)$，其中 $A_x=A_{xx}$ 且 $A_y=A_{yy}$（从预条件子中排除混合导数项的贡献）。\n- 通过计算矩阵束 $(S,M)$ 的广义特征值 $\\{\\lambda_i\\}$ 来量化特征值聚集，该矩阵束由 $(I_{N^2}-\\Delta t\\,A)\\,v_i=\\lambda_i\\,M\\,v_i$ 定义，然后以单个标量形式报告聚集半径 $R=\\max_i|\\lambda_i-1|$。\n\n实现一个完整、可运行的程序，该程序：\n- 根据上述规范构建 $S$ 和 $M$。\n- 计算广义特征值和聚集半径 $R$。\n- 在以下测试套件上评估 $R$，角度以弧度指定：\n  1. $(N,\\Delta t,k_\\parallel,k_\\perp,\\theta)=(12,10^{-5},10,1,0)$,\n  2. $(12,10^{-5},10,1,\\pi/4)$,\n  3. $(12,10^{-5},1,1,\\pi/6)$,\n  4. $(12,10^{-5},100,1,\\pi/8)$,\n  5. $(12,10^{-5},10,1,\\pi/2)$,\n  6. $(12,10^{-5},10,1,0.01)$.\n您的程序应生成单行输出，其中包含每个测试用例的聚集半径，形式为用方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数（无单位）。\n\n您的答案必须是一个用 Python 编写的完整、可运行的程序，使用指定的数值库实现上述算法。最终输出格式必须严格为“[r1,r2,r3,r4,r5,r6]”。", "solution": "用户要求构建和分析用于各向异性扩散方程的维度分裂交替方向隐式 (ADI) 预条件子。分析涉及量化预处理算子的特征值聚集情况。\n\n### 步骤 1：问题验证\n\n首先将根据所需标准对问题陈述进行验证。\n\n#### 步骤 1.1：提取已知条件\n\n-   **偏微分方程 (PDE)**: $-\\nabla\\cdot\\left(K(x,y)\\nabla p(x,y,t)\\right)=q(x,y,t)$ 位于 $[0,1]\\times[0,1]$ 上。\n-   **边界条件**: 齐次 Dirichlet, $p=0$ on $\\partial\\Omega$。\n-   **瞬态格式**: 后向隐式，需要求解 $(I-\\Delta t\\,L)\\,p^{n+1}=b^n$。\n-   **各向异性张量**: $K=R(\\theta)\\,\\mathrm{diag}(k_\\parallel,k_\\perp)\\,R(\\theta)^\\top$，其中 $R(\\theta)=\\begin{pmatrix}\\cos\\theta  -\\sin\\theta\\\\\\sin\\theta  \\cos\\theta\\end{pmatrix}$。$K$ 在空间上是常数。\n-   **空间算子展开**: $L = -\\nabla\\cdot(K\\nabla\\cdot) = -(K_{xx}\\,\\frac{\\partial^2 p}{\\partial x^2}+2K_{xy}\\,\\frac{\\partial^2 p}{\\partial x \\partial y}+K_{yy}\\,\\frac{\\partial^2 p}{\\partial y^2})$。\n-   **离散网格**: 均匀网格，每个方向有 $N$ 个内部点，网格间距 $h=1/(N+1)$。\n-   **一维离散算子**:\n    -   二阶导数: $D_{xx} \\in \\mathbb{R}^{N\\times N}$ 是三对角矩阵，对角线元素为 $-2/h^2$，非对角线元素为 $1/h^2$。\n    -   一阶导数: $D_x \\in \\mathbb{R}^{N\\times N}$ 是三对角矩阵，上对角线元素为 $1/(2h)$，下对角线元素为 $-1/(2h)$。\n-   **二维离散算子**: 通过与 $I_N$（$N\\times N$ 单位矩阵）的 Kronecker 积 $\\otimes$ 形成。\n    -   $A_{xx}=-K_{xx}\\,(D_{xx}\\otimes I_N)$\n    -   $A_{yy}=-K_{yy}\\,(I_N\\otimes D_{xx})$\n    -   $A_{xy}=-2K_{xy}\\,(D_x\\otimes D_x)$\n    -   完整离散算子: $A=A_{xx}+A_{yy}+A_{xy} \\in \\mathbb{R}^{N^2\\times N^2}$。\n-   **瞬态系统矩阵**: $S=I_{N^2}-\\Delta t\\,A$。\n-   **ADI 预条件子**: $M=(I_{N^2}-\\Delta t\\,A_x)(I_{N^2}-\\Delta t\\,A_y)$，其中 $A_x=A_{xx}$ 且 $A_y=A_{yy}$。\n-   **分析指标**: 聚集半径 $R=\\max_i|\\lambda_i-1|$，其中 $\\{\\lambda_i\\}$ 是来自矩阵束 $(S,M)$ 的广义特征值，求解 $(I_{N^2}-\\Delta t\\,A)\\,v_i=\\lambda_i\\,M\\,v_i$。\n-   **测试套件**:\n    1.  $(N,\\Delta t,k_\\parallel,k_\\perp,\\theta)=(12,10^{-5},10,1,0)$\n    2.  $(12,10^{-5},10,1,\\pi/4)$\n    3.  $(12,10^{-5},1,1,\\pi/6)$\n    4.  $(12,10^{-5},100,1,\\pi/8)$\n    5.  $(12,10^{-5},10,1,\\pi/2)$\n    6.  $(12,10^{-5},10,1,0.01)$\n\n#### 步骤 1.2：使用提取的已知条件进行验证\n\n1.  **科学依据充分**：该问题牢固地基于偏微分方程数值方法的标准理论。各向异性扩散方程、后向欧拉时间步进、有限差分离散化、二维算子的 Kronecker 积构造以及 ADI 预处理都是计算科学与工程中的经典主题。\n2.  **适定的**：该问题是适定的。所有参数、矩阵和过程都已明确定义，从而为每个测试用例带来唯一的数值结果。所涉及的矩阵是良定义的，对于给定的参数，它们将是非奇异的，从而确保广义特征值问题有解。\n3.  **客观的**：该问题使用精确、客观的数学语言陈述。没有主观或基于观点的论断。\n4.  **完整且一致的**：该问题是自洽的。所有必要信息，包括数学公式、离散化细节、参数值以及用于分析的精确指标，都已提供。没有矛盾之处。\n5.  **主题相关性**：该问题完全属于*多维偏微分方程的维度分裂*这一指定主题。\n\n#### 步骤 1.3：结论与行动\n\n该问题是有效的。它是一个定义明确、科学上合理的数值实验。我将继续构建解决方案。\n\n### 步骤 2：解决方案构建\n\n解决方案涉及为每个测试用例实现指定的矩阵构建和特征值分析。该方法的核心是将连续算子转换为离散矩阵形式，然后分析所得预处理系统的谱特性。\n\n对于每个由元组 $(N, \\Delta t, k_\\parallel, k_\\perp, \\theta)$ 指定的测试用例：\n\n1.  **设置离散化参数**：网格间距为 $h = 1/(N+1)$。内部网格点总数为 $N^2$。\n\n2.  **构建一维有限差分矩阵**： - 矩阵 $D_{xx}$ 离散化二阶导数 $\\frac{\\partial^2}{\\partial x^2}$。对于一个 $N \\times N$ 矩阵，其元素为 $(D_{xx})_{i,j} = (1/h^2)(\\delta_{i,j-1} - 2\\delta_{i,j} + \\delta_{i,j+1})$，其中 $\\delta$ 是 Kronecker delta 符号。这对应于指定的三对角矩阵。 - 矩阵 $D_x$ 使用中心差分格式离散化一阶导数 $\\frac{\\partial}{\\partial x}$。其元素为 $(D_x)_{i,j} = (1/(2h))(\\delta_{i,j+1} - \\delta_{i,j-1})$。这对应于指定的双对角矩阵（主对角线为零）。\n\n3.  **计算各向异性张量分量**：常数张量 $K$ 的分量由主扩散系数 $k_\\parallel, k_\\perp$ 和方向角 $\\theta$ 计算得出。\n    $$K=R(\\theta)\\begin{pmatrix}k_\\parallel  0\\\\0  k_\\perp\\end{pmatrix}R(\\theta)^\\top = \\begin{pmatrix} k_\\parallel c^2 + k_\\perp s^2  (k_\\parallel - k_\\perp) sc \\\\ (k_\\parallel - k_\\perp) sc  k_\\parallel s^2 + k_\\perp c^2 \\end{pmatrix}$$\n    其中 $c = \\cos\\theta$ 且 $s = \\sin\\theta$。由此，我们确定 $K_{xx}$、$K_{yy}$ 和 $K_{xy}$。\n\n4.  **构建二维算子矩阵**：在按字典序排列的未知数网格向量上的二维算子是使用 Kronecker 积形成的。 - 离散拉普拉斯分量为 $L_{xx} = D_{xx} \\otimes I_N$ 和 $L_{yy} = I_N \\otimes D_{xx}$。 - 混合导数项为 $L_{xy} = D_x \\otimes D_x$。 - 完整的空间算子矩阵为 $A = -K_{xx}L_{xx} - K_{yy}L_{yy} - 2K_{xy}L_{xy}$。符号为负是因为瞬态方程中的算子 $L$ 定义为 $L = -\\nabla\\cdot(K\\nabla\\cdot)$。\n\n5.  **构建瞬态系统和预条件子**： - 用于后向隐式步的矩阵是 $S = I_{N^2} - \\Delta t A$。 - ADI 预条件子通过将 $A$ 分裂为其方向分量 $A_x = -K_{xx}L_{xx}$ 和 $A_y = -K_{yy}L_{yy}$，并忽略混合导数项 $A_{xy}$ 来构建。预条件子是 $M = (I_{N^2} - \\Delta t A_x)(I_{N^2} - \\Delta t A_y)$。这种因式分解在实践中应用起来很高效，因为它只涉及求解三对角系统。\n\n6.  **分析特征值聚集**：通过检查预处理算子 $M^{-1}S$ 的特征值 $\\lambda_i$ 来研究 $M$ 作为 $S$ 的预条件子的有效性。这些是广义特征值问题 $S v_i = \\lambda_i M v_i$ 的解。聚集半径 $R = \\max_i |\\lambda_i-1|$ 衡量这些特征值与 1 的最大偏差。较小的 $R$ 表示特征值更紧密地聚集在 1 附近，这通常会导致像 GMRES 这样的 Krylov 子空间求解器收敛更快。广义特征值使用标准数值库函数计算。\n\n最终的 Python 代码为所有指定的测试用例实现了此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, Δt, k_parallel, k_perp, θ in radians)\n        (12, 1e-5, 10, 1, 0),\n        (12, 1e-5, 10, 1, np.pi/4),\n        (12, 1e-5, 1, 1, np.pi/6),\n        (12, 1e-5, 100, 1, np.pi/8),\n        (12, 1e-5, 10, 1, np.pi/2),\n        (12, 1e-5, 10, 1, 0.01),\n    ]\n\n    results = []\n    for N, dt, k_parallel, k_perp, theta in test_cases:\n        # ---- Discretization setup ----\n        # Grid spacing h for N interior points on [0,1]\n        h = 1.0 / (N + 1)\n        N_sq = N**2\n\n        # ---- Build 1D finite difference matrices ----\n        # D_xx for second derivative: [1, -2, 1]/h^2\n        diag_xx = -2.0 / h**2 * np.ones(N)\n        offdiag_xx = 1.0 / h**2 * np.ones(N - 1)\n        D_xx = np.diag(diag_xx) + np.diag(offdiag_xx, k=1) + np.diag(offdiag_xx, k=-1)\n\n        # D_x for first derivative: [-1, 0, 1]/(2h)\n        offdiag_x_upper = 1.0 / (2.0 * h) * np.ones(N - 1)\n        offdiag_x_lower = -1.0 / (2.0 * h) * np.ones(N - 1)\n        D_x = np.diag(offdiag_x_upper, k=1) + np.diag(offdiag_x_lower, k=-1)\n\n        I_N = np.eye(N)\n        I_N2 = np.eye(N_sq)\n\n        # ---- Calculate anisotropy tensor K components ----\n        c, s = np.cos(theta), np.sin(theta)\n        K_xx = k_parallel * c**2 + k_perp * s**2\n        K_yy = k_parallel * s**2 + k_perp * c**2\n        K_xy = (k_parallel - k_perp) * s * c\n\n        # ---- Build 2D operator matrices via Kronecker products ----\n        # The operator is L = -(K_xx*d_xx + 2*K_xy*d_xy + K_yy*d_yy)\n        # So A is the discretization of L.\n        A_xx_op = -K_xx * np.kron(D_xx, I_N)\n        A_yy_op = -K_yy * np.kron(I_N, D_xx)\n        A_xy_op = -2 * K_xy * np.kron(D_x, D_x)\n        A = A_xx_op + A_yy_op + A_xy_op\n\n        # ---- Build transient matrix S and ADI preconditioner M ----\n        S = I_N2 - dt * A\n        \n        # M is built from the ADI splitting, ignoring the mixed-derivative term\n        # The split operators Ax and Ay are defined as Axx and Ayy in the prompt.\n        M = (I_N2 - dt * A_xx_op) @ (I_N2 - dt * A_yy_op)\n\n        # ---- Compute generalized eigenvalues and clustering radius ----\n        # Solves the generalized eigenvalue problem S v = λ M v for eigenvalues λ\n        lambdas = eig(S, M, right=False)\n\n        # The clustering radius R = max|λ_i - 1|\n        R = np.max(np.abs(lambdas - 1.0))\n        results.append(R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3377961"}]}