{"hands_on_practices": [{"introduction": "谱方法的核心思想是用全局函数（如多项式或三角函数）来逼近未知解，其关键在于如何精确地计算这些全局函数在配置点上的导数。本练习 [@problem_id:3446562] 将指导你从第一性原理出发，构建谱方法中最基本的工具——切比雪夫微分矩阵。通过这个过程，你不仅能掌握其背后的数学原理，还能深入理解保证数值稳定性的重心坐标法等关键技术。", "problem": "构建一个完整的程序，该程序针对区间 $[-1,1]$ 上的切比雪夫谱配置法，使用高斯-洛巴托点和全局基函数，构建一阶和二阶微分矩阵，并估算其谱范数作为 $N$ 的函数。高斯-洛巴托点定义为 $x_j = \\cos\\left(\\pi j / N\\right)$，其中 $j = 0,1,\\dots,N$。切比雪夫一阶微分矩阵 $D^{(1)} \\in \\mathbb{R}^{(N+1)\\times(N+1)}$ 定义为 $D^{(1)}_{j,k} = \\ell_k'(x_j)$，其中 $\\ell_k$ 是在节点 $\\{x_j\\}_{j=0}^N$ 处的拉格朗日基多项式。使用重心坐标公式，通过权重 $w_j$ 和恒等式 $D^{(1)}_{j,k} = \\frac{w_k}{w_j}\\frac{1}{x_j - x_k}$（当 $j \\neq k$ 时）以及 $D^{(1)}_{j,j} = -\\sum_{k\\neq j} D^{(1)}_{j,k}$ 来推导和实现 $D^{(1)}$。对于切比雪夫高斯-洛巴托点，选择与第一类切比雪夫多项式网格一致的重心权重。然后构造二阶微分矩阵 $D^{(2)} = D^{(1)}D^{(1)}$，它表示对多项式插值函数应用两次一阶导数。\n\n矩阵 $A$ 的谱范数，记作 $\\|A\\|_2$，是由欧几里得范数诱导的算子范数，等于 $A$ 的最大奇异值。您必须使用奇异值分解（Singular Value Decomposition, SVD）来计算 $\\|D^{(1)}\\|_2$ 和 $\\|D^{(2)}\\|_2$。\n\n您的推导必须从多项式插值、拉格朗日基函数和导数的重心坐标表示等基本定义开始。避免使用跳过这些推导步骤的现成公式。清晰地论证每一步为何正确，以及它如何从使用全局基函数的谱配置法基本原理推导得出。\n\n使用以下参数值测试套件来实现算法：\n- $N \\in \\{1,2,8,32,128\\}$。\n\n对于测试套件中的每个 $N$，返回一对浮点数值 $[\\|D^{(1)}\\|_2,\\|D^{(2)}\\|_2]$，保留 $10$ 位小数。最终输出必须将所有给定测试用例的结果汇总到单行中。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如， $[[r_1^{(1)},r_1^{(2)}],[r_2^{(1)},r_2^{(2)}],\\dots]$），其中每个内部对按指定顺序 $[1,2,8,32,128]$ 对应一个 $N$ 值，每个 $r_i^{(\\cdot)}$ 是一个保留 $10$ 位小数的浮点数。本问题不要求物理单位或角度单位，所有输出必须是无量纲的实数。", "solution": "该问题要求在切比雪夫-高斯-洛巴托网格上构建切比雪夫一阶和二阶微分矩阵 $D^{(1)}$ 和 $D^{(2)}$，并计算它们的谱范数。推导过程必须从多项式插值的基本原理开始。\n\n### 1. 多项式插值与微分矩阵\n假设函数 $u(x)$ 定义在区间 $[-1, 1]$ 上。我们用一个次数至多为 $N$ 的唯一多项式 $p(x)$ 来近似 $u(x)$，该多项式在 $N+1$ 个不同的配置点 $\\{x_j\\}_{j=0}^N$ 处对 $u(x)$ 进行插值。该插值多项式可以用拉格朗日形式表示：\n$$\np(x) = \\sum_{k=0}^{N} u_k \\ell_k(x)\n$$\n其中 $u_k = u(x_k)$ 是在配置点处的函数值，$\\ell_k(x)$ 是拉格朗日基多项式。它们由属性 $\\ell_k(x_j) = \\delta_{kj}$ 定义，其中 $\\delta_{kj}$ 是克罗内克δ函数。\n\n插值多项式 $p(x)$ 的导数由下式给出：\n$$\np'(x) = \\sum_{k=0}^{N} u_k \\ell'_k(x)\n$$\n为了求出多项式在配置点处的导数，我们在每个 $x_j$ 处计算 $p'(x)$ 的值：\n$$\np'(x_j) = \\sum_{k=0}^{N} u_k \\ell'_k(x_j)\n$$\n这个方程可以表示为矩阵-向量乘积。设 $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$ 是网格点上函数值的向量，$\\mathbf{u'} = [p'(x_0), p'(x_1), \\dots, p'(x_N)]^T$ 是导数值的向量。那么，$\\mathbf{u'} = D^{(1)} \\mathbf{u}$，其中 $D^{(1)}$ 是一阶微分矩阵，其元素为：\n$$\nD^{(1)}_{j,k} = \\ell'_k(x_j)\n$$\n这是谱微分矩阵的基本定义。\n\n### 2. 为提高数值稳定性的重心坐标公式\n直接从标准拉格朗日公式 $\\ell_k(x) = \\prod_{i \\neq k} \\frac{x-x_i}{x_k-x_i}$ 计算 $\\ell'_k(x_j)$ 在数值上是不稳定的。一种更稳健的方法是重心坐标公式。\n\n设 $L(x)$ 为节点多项式，定义为 $L(x) = \\prod_{i=0}^{N}(x-x_i)$。拉格朗日基多项式 $\\ell_k(x)$ 可以写成：\n$$\n\\ell_k(x) = \\frac{L(x)}{(x-x_k)L'(x_k)}\n$$\n我们将重心权重 $w_k$ 定义为：\n$$\nw_k = \\frac{1}{L'(x_k)} = \\frac{1}{\\prod_{i \\neq k}(x_k-x_i)}\n$$\n使用这些权重，拉格朗日多项式变为 $\\ell_k(x) = w_k \\frac{L(x)}{x-x_k}$。\n\n### 3. 微分矩阵元素的推导\n\n**非对角线元素 ($j \\neq k$):**\n为了求出当 $j \\neq k$ 时的元素 $D^{(1)}_{j,k} = \\ell'_k(x_j)$，我们对 $\\ell_k(x)$ 的重心坐标形式进行微分：\n$$\n\\ell'_k(x) = w_k \\left( \\frac{L'(x)(x-x_k) - L(x)}{(x-x_k)^2} \\right)\n$$\n现在，我们在 $x=x_j$ 处计算该表达式的值。由于对任何 $j$，$x_j$ 都是节点多项式 $L(x)$ 的一个根，所以我们有 $L(x_j)=0$。\n$$\n\\ell'_k(x_j) = w_k \\left( \\frac{L'(x_j)(x_j-x_k) - 0}{(x_j-x_k)^2} \\right) = w_k \\frac{L'(x_j)}{x_j-x_k}\n$$\n根据重心权重 $w_j = 1/L'(x_j)$ 的定义，我们有 $L'(x_j) = 1/w_j$。将此代入 $\\ell'_k(x_j)$ 的表达式中，得到 $D^{(1)}$ 的非对角线元素的公式：\n$$\nD^{(1)}_{j,k} = \\frac{w_k}{w_j} \\frac{1}{x_j-x_k} \\quad \\text{for } j \\neq k\n$$\n\n**对角线元素 ($j = k$):**\n为了求出对角线元素 $D^{(1)}_{j,j}$，我们利用微分矩阵必须能精确微分常数函数的性质。设 $u(x) = c$ 是一个常数函数。这是一个 $0$ 次多项式，对于 $N \\ge 0$，它可以被我们的插值多项式精确表示。函数值的向量是 $\\mathbf{u} = [c, c, \\dots, c]^T$。其导数为 $u'(x) = 0$，因此导数值的向量必须是 $\\mathbf{u'} = \\mathbf{0}$。\n由 $\\mathbf{u'} = D^{(1)}\\mathbf{u}$，我们有 $D^{(1)}[c, \\dots, c]^T = [0, \\dots, 0]^T$。这意味着微分矩阵的每一行之和必须为零：\n$$\n\\sum_{k=0}^{N} D^{(1)}_{j,k} = 0 \\quad \\text{for each } j = 0, 1, \\dots, N\n$$\n由此，我们可以解出对角线元素 $D^{(1)}_{j,j}$：\n$$\nD^{(1)}_{j,j} = - \\sum_{k \\neq j} D^{(1)}_{j,k}\n$$\n这个推导过程证实了问题陈述中提供的公式。\n\n### 4. 网格点与重心权重\n该问题指定了切比雪夫-高斯-洛巴托点，它们是 $N$ 次第一类切比雪夫多项式 $T_N(x)$ 的极值点。这些点由下式给出：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{for } j = 0, 1, \\dots, N\n$$\n对于这组特定的点，其重心权重已知为：\n$$\nw_j = (-1)^j \\delta_j\n$$\n其中，当 $j=0$ 和 $j=N$ 时 $\\delta_j = 1/2$，当 $j=1, 2, \\dots, N-1$ 时 $\\delta_j=1$。这些权重的任何常数倍数也都是有效的，因为该常数在 $D^{(1)}_{j,k}$ 的公式中会被消去。为方便起见，我们选择以下特定形式：\n$$\nw_0 = \\frac{1}{2}, \\quad w_j = (-1)^j \\text{ for } 1 \\le j \\le N-1, \\quad w_N = \\frac{(-1)^N}{2}\n$$\n\n### 5. 二阶微分矩阵\n二阶微分矩阵 $D^{(2)}$ 表示应用两次一阶导数算子。在次数至多为 $N$ 的多项式空间上，这等价于一阶微分矩阵的平方：\n$$\nD^{(2)} = (D^{(1)})^2 = D^{(1)}D^{(1)}\n$$\n我们通过对已构造的 $D^{(1)}$ 进行矩阵乘法来计算 $D^{(2)}$。\n\n### 6. 谱范数计算\n矩阵 $A$ 的谱范数，记为 $\\|A\\|_2$，定义为 $A$ 的最大奇异值 $\\sigma_{\\max}(A)$。$A$ 的奇异值是半正定矩阵 $A^H A$（对于实矩阵则是 $A^T A$）的特征值的平方根。我们使用标准的奇异值分解（SVD）算法计算 $D^{(1)}$ 和 $D^{(2)}$ 的奇异值，并取每种情况下的最大值来求得谱范数。\n\n### 算法总结\n对于每个给定的 $N$ 值：\n1.  生成 $N+1$ 个切比雪夫-高斯-洛巴托点 $x_j = \\cos(\\pi j / N)$。\n2.  生成对应的 $N+1$ 个重心权重 $w_j = (-1)^j \\delta_j$。\n3.  构造 $(N+1) \\times (N+1)$ 矩阵 $D^{(1)}$：\n    a. 对于 $j \\neq k$，计算 $D^{(1)}_{j,k} = \\frac{w_k}{w_j}\\frac{1}{x_j - x_k}$。\n    b. 对于对角线元素，计算 $D^{(1)}_{j,j} = - \\sum_{k \\neq j} D^{(1)}_{j,k}$。\n4.  计算 $D^{(2)} = D^{(1)} @ D^{(1)}$。\n5.  计算 $D^{(1)}$ 的奇异值，并找出最大值以获得 $\\|D^{(1)}\\|_2$。\n6.  计算 $D^{(2)}$ 的奇异值，并找出最大值以获得 $\\|D^{(2)}\\|_2$。\n7.  存储数值对 $[\\left\\|D^{(1)}\\right\\|_2, \\left\\|D^{(2)}\\right\\|_2]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries outside the Python standard library, numpy, or scipy are permitted.\n# Note: scipy is permitted but not necessary for this solution.\n\ndef build_chebyshev_diff_matrices(N):\n    \"\"\"\n    Constructs the Chebyshev first and second differentiation matrices.\n\n    Args:\n        N (int): The degree of the polynomial interpolant. The grid will have N+1 points.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the first (D1) and second (D2)\n                                       differentiation matrices.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.]]), np.array([[0.]])\n    \n    # Grid points (Chebyshev-Gauss-Lobatto)\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n\n    # Barycentric weights\n    w = (-1.0)**j\n    w[0] *= 0.5\n    w[-1] *= 0.5\n\n    # Construct the first differentiation matrix D1\n    N_plus_1 = N + 1\n    D1 = np.zeros((N_plus_1, N_plus_1))\n    \n    # Off-diagonal entries using broadcasting\n    # w_k / w_j term\n    w_ratio = w[np.newaxis, :] / w[:, np.newaxis]\n    # x_j - x_k term\n    x_diff = x[:, np.newaxis] - x[np.newaxis, :]\n\n    # To avoid division by zero on the diagonal, we temporarily set diagonal of x_diff to 1.\n    # The diagonal of D1 will be correctly computed later.\n    np.fill_diagonal(x_diff, 1)\n    D1 = w_ratio / x_diff\n    \n    # Correct the diagonal of D1, which was filled with temporary values.\n    # We set it to 0 before summing the rows.\n    np.fill_diagonal(D1, 0)\n    \n    # Diagonal entries: D1_jj = -sum(D1_jk for k!=j)\n    # The sum of each row must be zero.\n    row_sums = np.sum(D1, axis=1)\n    np.fill_diagonal(D1, -row_sums)\n    \n    # Second differentiation matrix\n    D2 = D1 @ D1\n\n    return D1, D2\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 8, 32, 128]\n\n    results = []\n    for N in test_cases:\n        # Build the differentiation matrices for the current N.\n        D1, D2 = build_chebyshev_diff_matrices(N)\n        \n        # Compute the spectral norm (largest singular value) for D1.\n        # np.linalg.svd returns singular values in descending order.\n        # Using compute_uv=False is more efficient as we only need singular values.\n        s1 = np.linalg.svd(D1, compute_uv=False)\n        norm_D1 = s1[0] if len(s1) > 0 else 0.0\n\n        # Compute the spectral norm for D2.\n        s2 = np.linalg.svd(D2, compute_uv=False)\n        norm_D2 = s2[0] if len(s2) > 0 else 0.0\n\n        # Store the rounded results.\n        results.append((norm_D1, norm_D2))\n\n    # Format the final output string exactly as required.\n    # Each float must be formatted to 10 decimal places.\n    output_pairs = []\n    for res_pair in results:\n        norm1_str = f\"{res_pair[0]:.10f}\"\n        norm2_str = f\"{res_pair[1]:.10f}\"\n        output_pairs.append(f\"[{norm1_str},{norm2_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(output_pairs)}]\")\n\nsolve()\n```", "id": "3446562"}, {"introduction": "在构建了微分矩阵之后，下一步便是应用它来求解微分方程，这通常会转化为一个线性代数系统。然而，如何正确地施加边界条件或内部约束是决定谱方法成败的关键一步，处理不当会导致系统奇异或解不唯一。本练习 [@problem_id:3446566] 让你通过比较两种不同的约束施加方法，亲身体验和分析它们对解的精度和线性系统条件数的影响，从而掌握处理约束的实用技巧。", "problem": "考虑在区间 $[-1,1]$ 上的线性常微分方程 (ODE) $u^{\\prime}(x) = g(x)$，其内部约束为 $u(0) = 0$。令未知数 $u(x)$ 由一个 $N$ 次多项式的全局第一类 Chebyshev 级数近似，即 $u_N(x) = \\sum_{k=0}^{N} a_k T_k(x)$，其中 $T_k(x)$ 表示第 $k$ 个第一类 Chebyshev 多项式。右侧项由 $g(x) = e^x + \\sin(3x)$ 指定。与该约束一致的精确解为 $u(x) = \\int_{0}^{x} g(s)\\, ds = e^x - 1 + \\frac{1 - \\cos(3x)}{3}$。\n\n您的任务是比较在 Chebyshev 基下两种施加内部约束的谱方法，重点关注其准确性和线性系统的条件数：\n\n1.  通过丢弃常数模态来修改基：从未知数中消除常数系数 $a_0$，并使用 Chebyshev 系数空间中的导数方程 $u^{\\prime}(x) = g(x)$ 为剩余系数求解一个降阶的方阵系统。求解后，设置 $a_0 = 0$。此方法不直接使用内部约束，而是依赖于移除与常数相关的零空间。\n\n2.  通过约束替换进行 Tau 校正：在 Chebyshev 系数空间中构建一个方阵系统，该系统使 $u^{\\prime}(x)$ 的 Chebyshev 系数与 $g(x)$ 的系数相等，然后用线性约束 $u(0) = 0$ 替换其中一个方程（一行）。该约束在系数空间中可以写作 $\\sum_{k=0}^{N} a_k T_k(0) = 0$，其中 $T_k(0) = \\cos(k \\pi / 2)$。\n\n使用以下基本事实和定义从第一性原理设计您的算法：\n\n- 第一类 Chebyshev 多项式满足 $T_k(\\cos \\theta) = \\cos(k \\theta)$。\n- 一个 $N$ 次全局 Chebyshev 级数近似为 $u_N(x) = \\sum_{k=0}^{N} a_k T_k(x)$。\n- 系数空间中的微分是线性的：如果 $a = (a_0,\\dots,a_N)^{\\top}$ 是 $u$ 的系数，则存在一个矩阵 $M \\in \\mathbb{R}^{(N+1)\\times(N+1)}$，使得 $u^{\\prime}$ 的 Chebyshev 系数 $b = (b_0,\\dots,b_N)^{\\top}$ 满足 $b = M a$。算子 $M$ 有一个对应于常数的一维零空间。\n- 内部约束在系数上是线性的：$u(0) = \\sum_{k=0}^{N} a_k \\cos(k \\pi/2) = 0$。\n- I 型离散余弦变换 (DCT) 在 Chebyshev–Lobatto 网格 $x_j = \\cos(\\pi j/N)$，$j = 0,\\dots,N$ 上实现了 $T_k$ 的离散正交性，从而允许在函数值和 Chebyshev 系数之间进行转换。如果 $y_j = f(x_j)$，则 $N$ 次插值式的 Chebyshev 系数 $(\\hat{f}_k)_{k=0}^{N}$ 满足 $\\hat{f} = c/N$，并进行端点校正 $\\hat{f}_0 \\leftarrow \\hat{f}_0/2$，$\\hat{f}_N \\leftarrow \\hat{f}_N/2$，其中 $c$ 是 $y$ 的 DCT-I。\n\n算法要求：\n\n- 通过将导数的 Chebyshev 系数的精确递推关系应用于基向量来构建系数空间微分算子 $M$：\n  - 如果 $u(x) = \\sum_{k=0}^{N} a_k T_k(x)$，通过 Chebyshev 级数的标准微分递推关系定义 $b = (b_k)_{k=0}^{N}$，这会产生一个线性映射 $b = M a$。实现此映射，并通过将其应用于 $\\mathbb{R}^{N+1}$ 中的每个规范基向量来组装 $M$。\n- 通过在 Chebyshev–Lobatto 点上对 $g$ 进行采样，并使用 I 型离散余弦变换 (DCT) 将函数值转换为系数（如上所述），来获取 $g$ 的 Chebyshev 系数。\n- 方法 1（基修改）：从 $M$ 中移除与 $a_0$ 对应的列以获得 $M_{\\text{red}} \\in \\mathbb{R}^{(N+1)\\times N}$。为了获得一个方阵系统，移除一个方程行（选择最后一行）以得到 $\\tilde{M}_{\\text{red}} \\in \\mathbb{R}^{N \\times N}$，并将前 $N$ 个结果方程与 $g$ 系数向量的相应条目匹配。求解 $(a_1,\\dots,a_N)$ 并设置 $a_0 = 0$。\n- 方法 2（tau 校正）：构建 $M$ 并用系数空间中写为 $c^{\\top} a = 0$ 的约束 $u(0) = 0$ 替换一个方程行（选择最后一行），其中 $c_k = \\cos(k \\pi/2)$。求解得到的方阵系统以获得 $(a_0,\\dots,a_N)$。\n\n准确性和条件数度量：\n\n- 对于每种方法，使用 Chebyshev 级数在 Chebyshev–Lobatto 网格上重构近似解，并计算最大绝对误差 $E_{\\infty} = \\max_{0 \\leq j \\leq N} |u_N(x_j) - u(x_j)|$，其中 $u(x)$ 是上面给出的精确解。\n- 对于每个线性系统，报告 2-范数条件数 $\\kappa_2(A)$，其中 $A$ 是该方法中实际求解的方阵。\n\n所有三角函数的角度单位必须是弧度。\n\n您的程序必须实现这两种方法，并为以下多项式次数的测试套件生成结果：\n- $N = 8$（粗分辨率），\n- $N = 16$（理想情况），\n- $N = 33$（奇数次，在 $x=0$ 处无网格点），\n- $N = 64$（更精细的分辨率）。\n\n对于上述顺序中的每个 $N$，计算并输出四元组 $[E_{\\infty}^{\\text{basis}}, E_{\\infty}^{\\text{tau}}, \\kappa_2^{\\text{basis}}, \\kappa_2^{\\text{tau}}]$，其中误差和条件数均为浮点数。将所有结果按测试套件指定的顺序汇总到一个扁平列表中，并打印包含此列表的一行，格式为逗号分隔并用方括号括起，例如 $[r_1,r_2,\\dots]$，不带任何额外文本。不涉及物理单位，所有角度必须是弧度。", "solution": "所提供的问题是使用谱方法数值求解常微分方程的一个有效练习。它指导了对一阶 ODE 施加内部点约束的两种不同公式的比较。该问题是适定的，在科学上基于数值分析和逼近理论的原理，并且其求解所需的所有组件都已明确定义。\n\n问题的核心是在域 $x \\in [-1, 1]$ 上求解线性常微分方程 $u^{\\prime}(x) = g(x)$，并满足内部值约束 $u(0) = 0$。右侧项由 $g(x) = e^x + \\sin(3x)$ 给出。同时满足微分方程和约束的解析解是 $u(x) = e^x - 1 + \\frac{1 - \\cos(3x)}{3}$。\n\n我们采用基于全局多项式逼近的谱方法。未知函数 $u(x)$ 由第一类 Chebyshev 多项式的截断级数近似，即 $u_N(x) = \\sum_{k=0}^{N} a_k T_k(x)$，其中 $a_k$ 是未知的谱系数。\n\n**谱离散化**\n\n第一步是将连续的微分方程转换为关于系数 $a_k$ 的代数方程组。微分算子 $\\frac{d}{dx}$ 在多项式空间上作为线性算子作用。如果向量 $a = [a_0, a_1, \\dots, a_N]^\\top$ 包含 $u_N(x)$ 的 Chebyshev 系数，那么其导数 $u_N^{\\prime}(x) = \\sum_{k=0}^{N} b_k T_k(x)$ 的系数由线性变换 $b = Ma$ 给出。这里，$M$ 是系数空间中 $(N+1) \\times (N+1)$ 的 Chebyshev 微分矩阵。$M$ 的条目由 Chebyshev 级数导数系数的递推关系导出。具体来说，$M$ 的第 $j$ 列由第 $j$ 个基函数 $T_j^{\\prime}(x)$ 的导数的 Chebyshev 系数构成。\n\n右侧函数 $g(x)$ 也用 Chebyshev 基表示，其系数为 $\\hat{g} = [\\hat{g}_0, \\hat{g}_1, \\dots, \\hat{g}_N]^\\top$。这些系数可以通过在 $N+1$ 个 Chebyshev-Lobatto 点 $x_j = \\cos(\\pi j / N)$（$j = 0, \\dots, N$）上对 $g(x)$进行采样，然后应用按比例缩放的 I 型离散余弦变换 (DCT-I) 来高效计算，如问题陈述中所指定。\n\n微分方程的离散形式是线性系统 $Ma = \\hat{g}$。然而，微分算子有一个对应于常数函数的一维零空间（因为常数的导数为零）。因此，矩阵 $M$ 是奇异的，系统 $Ma = \\hat{g}$ 没有唯一解。需要内部约束 $u(0)=0$ 从可能解的族 $u(x) = C + \\int_0^x g(s) ds$ 中选择出唯一的正确解。\n\n我们比较两种引入此约束的方法。\n\n**方法 1：基修改**\n\n此方法通过修改逼近空间本身来强制唯一性。它寻求形式为 $u_N(x) = \\sum_{k=1}^{N} a_k T_k(x)$ 的解，这等同于强制系数 $a_0$ 为零。系数 $a_0$ 与函数的加权平均值成正比，$a_0 \\propto \\int_{-1}^1 u(x) (1-x^2)^{-1/2} dx$。因此，设置 $a_0=0$ 施加的是一个积分约束，而不是点约束 $u(0)=0$。因此，预计此方法会产生一个对于此问题来说根本不正确的解，从而导致较大的误差。\n\n在算法上，其实现如下：\n1. 移除 $M$ 中与 $a_0$ 对应的列，得到一个矩形矩阵 $M_{\\text{red}} \\in \\mathbb{R}^{(N+1)\\times N}$。系统变为 $M_{\\text{red}} [a_1, \\dots, a_N]^\\top = \\hat{g}$。\n2. 这是一个有 $N+1$ 个方程和 $N$ 个未知数的超定系统。为创建一个方阵系统，我们舍弃一个方程。根据问题的指示，我们移除最后一个方程（对应于最高频率模态 $T_N$）。这产生一个方阵系统 $\\tilde{M}_{\\text{red}} [a_1, \\dots, a_N]^\\top = [\\hat{g}_0, \\dots, \\hat{g}_{N-1}]^\\top$，其中 $\\tilde{M}_{\\text{red}} \\in \\mathbb{R}^{N\\times N}$。\n3. 求解该系统以获得系数 $[a_1, \\dots, a_N]^\\top$。然后将完整的系数向量与 $a_0=0$ 组合起来。\n\n**方法 2：Tau 校正**\n\n这种方法是 Tau 方法的一个变体，它使用完整的逼近空间 $u_N(x) = \\sum_{k=0}^{N} a_k T_k(x)$，并将约束直接纳入代数系统中。\n1. 从完整的奇异系统 $Ma = \\hat{g}$ 开始。\n2. 内部约束 $u(0)=0$ 是关于系数的线性方程：$\\sum_{k=0}^{N} a_k T_k(0) = 0$。由于 $T_k(0) = \\cos(k\\pi/2)$，该方程为 $\\sum_{k=0}^{N} a_k \\cos(k\\pi/2) = 0$。\n3. 为了使系统非奇异并引入约束，将 $Ma = \\hat{g}$ 中的一个原始方程替换为约束方程。选择替换哪个方程是 Tau 方法的一个关键方面；一个常见且有效的选择是替换对应于最高频率模态的方程，因为其对整体准确度的贡献通常是最小的。按照问题的要求，我们将系统的最后一行 $(Ma)_N = \\hat{g}_N$ 替换为约束行。\n4. 这会产生一个新的、非奇异的方阵系统 $A_{\\text{tau}} a = \\hat{g}_{\\text{tau}}$，求解该系统可得到完整的系数向量 $a$。此方法正确地施加了指定的约束，并预期具有高准确度。\n\n**比较指标**\n\n这两种方法基于以下几点进行评估：\n1. **准确性**：在 Chebyshev-Lobatto 网格上评估的最大绝对误差 $E_{\\infty} = \\max_{j} |u_N(x_j) - u(x_j)|$。\n2. **条件数**：每种方法中求解的最终线性系统矩阵 $A$ 的 2-范数条件数 $\\kappa_2(A)$。大的条件数表示对扰动的敏感性以及潜在的数值不稳定性。\n\n实施过程将为每个指定的多项式次数 $N$ 构建必要的矩阵和向量，并求解相应的线性系统以找出误差和条件数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import dct\n\ndef solve():\n    \"\"\"\n    Implements and compares two spectral methods for solving u'(x) = g(x) with u(0)=0.\n    1. Basis modification: assumes a_0=0, solves a reduced system.\n    2. Tau correction: replaces the highest-frequency equation with the constraint u(0)=0.\n    \"\"\"\n\n    def g_func(x):\n        \"\"\"The right-hand side function of the ODE.\"\"\"\n        return np.exp(x) + np.sin(3 * x)\n\n    def u_exact(x):\n        \"\"\"The exact solution of the ODE with the given constraint.\"\"\"\n        return np.exp(x) - 1.0 + (1.0 - np.cos(3 * x)) / 3.0\n\n    def get_cheb_diff_matrix(N):\n        \"\"\"\n        Constructs the (N+1)x(N+1) Chebyshev differentiation matrix M.\n        The j-th column of M contains the Chebyshev coefficients of T_j'(x).\n        \"\"\"\n        M = np.zeros((N + 1, N + 1))\n        # Apply differentiation to each basis vector T_j(x)\n        for j in range(N + 1):\n            a = np.zeros(N + 1)\n            a[j] = 1.0  # Coefficients of T_j(x)\n            \n            # Compute coefficients of the derivative using the standard recurrence.\n            # If u(x) = sum(a_k T_k(x)), u'(x) = sum(b_k T_k(x)) where\n            # b_k = (2/c_k) * sum_{p=k+1, p-k odd}^N p * a_p with c_0=2, c_k=1 else.\n            b = np.zeros(N + 1)\n            for k in range(N - 1, -1, -1):\n                s = 0.0\n                for p in range(k + 1, N + 1, 2):\n                    s += p * a[p]\n                \n                ck = 2.0 if k == 0 else 1.0\n                b[k] = (2.0 / ck) * s\n            M[:, j] = b\n        return M\n\n    def get_g_coeffs(N):\n        \"\"\"\n        Computes Chebyshev coefficients of g(x) on an (N+1)-point Lobatto grid\n        using the specified DCT-I based algorithm.\n        \"\"\"\n        x = np.cos(np.pi * np.arange(N + 1) / N)\n        y = g_func(x)\n        \n        # Following the recipe in the problem statement\n        c = dct(y, type=1)\n        ghat = c / N\n        ghat[0] /= 2.0\n        ghat[N] /= 2.0\n        return ghat\n\n    def reconstruct_from_coeffs(N, a):\n        \"\"\"\n        Reconstructs function values on the Lobatto grid from Chebyshev coefficients\n        using direct summation: u(x_j) = sum_k a_k T_k(x_j).\n        \"\"\"\n        j_indices = np.arange(N + 1).reshape(-1, 1)\n        k_indices = np.arange(N + 1)\n        # T_k(x_j) = cos(k*pi*j/N)\n        eval_matrix = np.cos(np.pi * j_indices * k_indices / N)\n        return eval_matrix @ a\n\n    test_cases = [8, 16, 33, 64]\n    all_results = []\n\n    for N in test_cases:\n        # --- Common Setup for degree N ---\n        lobatto_points = np.cos(np.pi * np.arange(N + 1) / N)\n        u_exact_vals = u_exact(lobatto_points)\n        \n        M = get_cheb_diff_matrix(N)\n        ghat = get_g_coeffs(N)\n\n        # --- Method 1: Basis Modification ---\n        # System for [a_1, ..., a_N] after removing a_0\n        M_red = M[:, 1:]  # Shape: (N+1) x N\n        # Make square by removing last equation row\n        tilde_M_red = M[:N, 1:] # Shape: N x N\n        g_red = ghat[:N] # Corresponding RHS\n\n        kappa_basis = np.linalg.cond(tilde_M_red, 2)\n        try:\n            a_tail = np.linalg.solve(tilde_M_red, g_red)\n            a_basis = np.concatenate(([0.0], a_tail))\n            u_basis_vals = reconstruct_from_coeffs(N, a_basis)\n            E_inf_basis = np.max(np.abs(u_basis_vals - u_exact_vals))\n        except np.linalg.LinAlgError:\n            E_inf_basis = np.inf\n            kappa_basis = np.inf\n\n\n        # --- Method 2: Tau Correction ---\n        A_tau = M.copy()\n        g_tau = ghat.copy()\n        \n        # Constraint row: c^T a = 0, where c_k = T_k(0) = cos(k*pi/2)\n        constraint_row = np.cos(np.pi * np.arange(N + 1) / 2.0)\n        \n        # Replace last row of system with the constraint\n        A_tau[-1, :] = constraint_row\n        g_tau[-1] = 0.0\n        \n        kappa_tau = np.linalg.cond(A_tau, 2)\n        try:\n            a_tau = np.linalg.solve(A_tau, g_tau)\n            u_tau_vals = reconstruct_from_coeffs(N, a_tau)\n            E_inf_tau = np.max(np.abs(u_tau_vals - u_exact_vals))\n        except np.linalg.LinAlgError:\n            E_inf_tau = np.inf\n            kappa_tau = np.inf\n\n        all_results.extend([E_inf_basis, E_inf_tau, kappa_basis, kappa_tau])\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3446566"}, {"introduction": "从一维问题迈向多维是数值求解的必经之路，这要求我们根据问题的几何与边界特性选择合适的基函数组合。对于周期与非周期混合的区域，傅里叶-切比雪夫谱方法是一种极为高效的策略。本练习 [@problem_id:3446498] 聚焦于一个二维偏微分方程的“快速直接求解器”，引导你分析其计算复杂度，学会根据问题规模评估算法的效率与可扩展性，这是设计大规模数值模拟的核心能力。", "problem": "考虑一个在条形区域上提出的二维屏蔽泊松方程，该区域在一个方向上是周期的，在另一个方向上是非周期的，并在非周期边界上具有齐次狄利克雷边界条件。具体来说，令 $u(x,y)$ 满足\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{\\partial^2 u}{\\partial y^2}(x,y) - \\alpha\\,u(x,y) = f(x,y),\n$$\n其中 $(x,y) \\in [0,2\\pi) \\times [-1,1]$，对于所有 $x$，$u(x,-1) = 0$ 且 $u(x,1) = 0$，并在 $x$ 方向上具有周期 $2\\pi$。假设 $\\alpha > 0$ 是一个固定的常数。\n\n设计一个快速直接求解器，该求解器在周期性的 $x$ 方向上使用快速傅里叶变换 (FFT)，在 $y$ 方向的切比雪夫全局基下使用带状求解器，并遵循以下原则和约束：\n\n- 在周期方向上，使用全局傅里叶基函数进行展开，并通过变换到傅里叶空间来对角化二阶导数 $\\frac{\\partial^2}{\\partial x^2}$，从而将偏微分方程简化为一组由傅里叶波数索引的、在 $y$ 方向上解耦的常微分方程。\n- 在非周期方向上，使用第一类切比雪夫多项式 $T_n(y)$ 在 $y$ 定义域 $[-1,1]$ 上，并结合切比雪夫-高斯-洛巴托点进行离散化，并强制施加齐次狄利克雷边界条件。采用一种表示和算法设计，使得每个傅里叶模态都能产生一个带状线性系统，其带宽与截断大小无关，因此可以使用带状直接求解器，其复杂度与每个模态的未知数数量成线性关系。\n\n您必须从以下基本基础出发：\n- 在 $[0,2\\pi)$ 上周期函数的傅里叶级数表示，以及傅里叶变换在周期方向上对角化常系数线性微分算子的性质。\n- 在 $[-1,1]$ 上的全局切比雪夫多项式基，其配置点为 $y_j = \\cos\\left(\\frac{\\pi j}{N_y-1}\\right)$，其中 $j=0,1,\\ldots,N_y-1$，以及一个原理，即对于类切比雪夫基，当在系数空间中表示时，适当选择的超球或等效公式可以为常系数微分方程产生带状算子。\n- 经过充分检验的复杂度事实：在 $N$ 个点上的快速傅里叶变换需要 $\\mathcal{O}(N \\log N)$ 次算术运算，而在一个大小为 $M$、具有固定上下带宽 $\\beta_u$ 和 $\\beta_\\ell$ 的带状线性系统上进行直接高斯消元法需要 $\\mathcal{O}\\!\\left(M(\\beta_u+\\beta_\\ell)^2\\right)$ 次算术运算。\n\n您的实现任务是编写一个程序，在给定周期性傅里叶方向的截断大小 $N_x$ 和非周期性切比雪夫方向的截断大小 $N_y$ 的情况下，根据 $N_x$ 和 $N_y$ 预测所设计的快速直接求解器的归一化算术运算次数。您必须使用以下归一化复杂度模型：\n- 对所有 $N_y$ 个配置行，沿 $x$ 方向的 FFT 阶段成本，以归一化单位计，为 $C_{\\mathrm{FFT}}(N_x,N_y) = N_x\\,N_y\\,\\log_2(N_x)$。\n- 对所有 $N_x$ 个傅里叶模态的带状直接求解阶段，每个模态在切比雪夫系数空间中产生一个 $N_y \\times N_y$ 的带状系统，其成本以归一化单位计为 $C_{\\mathrm{band}}(N_x,N_y) = N_x\\,N_y\\,(\\beta_u+\\beta_\\ell)^2$，其中 $(\\beta_u+\\beta_\\ell)$ 是由所选全局基带状公式产生的切比雪夫方向算子的固定总半带宽。\n- 那么，总的归一化算术运算次数为 $C_{\\mathrm{total}}(N_x,N_y) = C_{\\mathrm{FFT}}(N_x,N_y) + C_{\\mathrm{band}}(N_x,N_y)$。\n\n假设在切比雪夫方向上使用常系数算子和标准的超球型构造，得到一个固定的总半带宽 $(\\beta_u+\\beta_\\ell) = 2$。这表示算子结构中有两条不随 $N_y$ 增长的次对角线。\n\n您的程序必须为以下截断大小的测试套件计算 $C_{\\mathrm{total}}(N_x,N_y)$：\n- 测试用例 1：$N_x = 64$, $N_y = 65$。\n- 测试用例 2：$N_x = 1$, $N_y = 33$。\n- 测试用例 3：$N_x = 1024$, $N_y = 257$。\n- 测试用例 4：$N_x = 2$, $N_y = 2$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），每个结果是对应测试用例的总归一化算术运算次数 $C_{\\mathrm{total}}(N_x,N_y)$，表示为浮点数。不涉及物理单位。如果存在角度，必须以弧度为单位；但是，此问题不要求在输出中指定角度。此问题中不使用百分比。\n\n程序必须是自包含的，并且不需要用户输入。", "solution": "该问题已经过验证，并被确定为是合理的。它具有科学依据、问题明确且客观。计算指定的算术运算次数所需的所有必要数据和定义均已提供。该问题描述了一种在圆柱形域上求解屏蔽泊松方程的标准傅里叶-切比雪夫谱方法，并且为快速傅里叶变换和带状线性系统求解器提供的复杂度模型是数值分析中的标准模型。对于切比雪夫离散化，实现一个固定带宽算子的前提是高等谱方法中的一个已知结果，这使得该设置与既定理论相符。\n\n问题要求计算用于求解二维屏蔽泊松方程的快速直接求解器的总归一化算术运算次数 $C_{\\mathrm{total}}(N_x, N_y)$：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{\\partial^2 u}{\\partial y^2}(x,y) - \\alpha\\,u(x,y) = f(x,y)\n$$\n在域 $(x,y) \\in [0,2\\pi) \\times [-1,1]$ 上。边界条件在 $x$ 方向上是周期的，在 $y$ 方向上是齐次狄利克雷条件，即 $u(x,-1) = 0$ 和 $u(x,1) = 0$。常数 $\\alpha$ 是正数。\n\n求解器策略包括两个主要阶段：\n$1$. 在周期性的 $x$ 方向上应用傅里叶谱方法。解 $u(x,y)$ 和源项 $f(x,y)$ 被展开成傅里叶级数：\n$$\nu(x,y) = \\sum_{k=-(N_x/2-1)}^{N_x/2} \\hat{u}_k(y) e^{ikx}\n$$\n其中 $N_x$ 是傅里叶模态的数量。算子 $\\frac{\\partial^2}{\\partial x^2}$ 通过傅里叶变换被对角化，在第 $k$ 个模态上相当于乘以 $(ik)^2 = -k^2$。这将二维偏微分方程 (PDE) 简化为关于傅里叶系数 $\\hat{u}_k(y)$ 的一组 $N_x$ 个解耦的一维常微分方程 (ODE)：\n$$\n\\frac{d^2 \\hat{u}_k}{d y^2}(y) - k^2 \\hat{u}_k(y) - \\alpha \\hat{u}_k(y) = \\hat{f}_k(y)\n$$\n可简化为：\n$$\n\\frac{d^2 \\hat{u}_k}{d y^2}(y) - (k^2 + \\alpha) \\hat{u}_k(y) = \\hat{f}_k(y)\n$$\n对于每个波数 $k$。边界条件变为 $\\hat{u}_k(-1) = 0$ 和 $\\hat{u}_k(1) = 0$。\n\n$2$. 这 $N_x$ 个常微分方程中的每一个都使用切比雪夫配置法在 $N_y$ 个切比雪夫-高斯-洛巴托点上求解。问题陈述指出，所选的公式会为每个 $\\hat{u}_k(y)$ 的切比雪夫系数产生一个带状线性系统。\n\n总复杂度是傅里叶变换阶段和带状求解器阶段成本的总和。\n\n傅里叶变换阶段的成本 $C_{\\mathrm{FFT}}$ 涉及对 $N_y$ 个配置行中的每一行沿 $x$ 方向应用快速傅里叶变换 (FFT)。归一化的复杂度由以下公式给出：\n$$\nC_{\\mathrm{FFT}}(N_x, N_y) = N_x\\,N_y\\,\\log_2(N_x)\n$$\n\n带状求解器阶段的成本 $C_{\\mathrm{band}}$ 涉及求解 $N_x$ 个独立的带状线性系统，每个傅里叶模态 $k$ 对应一个。每个系统的大小约为 $N_y$。问题为此阶段提供了总的归一化复杂度：\n$$\nC_{\\mathrm{band}}(N_x, N_y) = N_x\\,N_y\\,(\\beta_u+\\beta_\\ell)^2\n$$\n其中 $(\\beta_u+\\beta_\\ell)$ 是总半带宽。问题指定该值固定为 $(\\beta_u+\\beta_\\ell) = 2$。因此，公式变为：\n$$\nC_{\\mathrm{band}}(N_x, N_y) = N_x\\,N_y\\,(2)^2 = 4\\,N_x\\,N_y\n$$\n\n总归一化算术运算次数是这两个成本之和：\n$$\nC_{\\mathrm{total}}(N_x, N_y) = C_{\\mathrm{FFT}}(N_x, N_y) + C_{\\mathrm{band}}(N_x, N_y) \\\\\nC_{\\mathrm{total}}(N_x, N_y) = N_x\\,N_y\\,\\log_2(N_x) + 4\\,N_x\\,N_y \\\\\nC_{\\mathrm{total}}(N_x, N_y) = N_x\\,N_y\\,(\\log_2(N_x) + 4)\n$$\n我们现在将此公式应用于给定的测试用例。\n\n测试用例 1：$N_x = 64$，$N_y = 65$。\n$\\log_2(64) = 6$。\n$C_{\\mathrm{total}}(64, 65) = 64 \\times 65 \\times (\\log_2(64) + 4) = 4160 \\times (6 + 4) = 4160 \\times 10 = 41600$。\n\n测试用例 2：$N_x = 1$，$N_y = 33$。\n$\\log_2(1) = 0$。\n$C_{\\mathrm{total}}(1, 33) = 1 \\times 33 \\times (\\log_2(1) + 4) = 33 \\times (0 + 4) = 33 \\times 4 = 132$。\n\n测试用例 3：$N_x = 1024$，$N_y = 257$。\n$\\log_2(1024) = 10$。\n$C_{\\mathrm{total}}(1024, 257) = 1024 \\times 257 \\times (\\log_2(1024) + 4) = 263168 \\times (10 + 4) = 263168 \\times 14 = 3684352$。\n\n测试用例 4：$N_x = 2$，$N_y = 2$。\n$\\log_2(2) = 1$。\n$C_{\\mathrm{total}}(2, 2) = 2 \\times 2 \\times (\\log_2(2) + 4) = 4 \\times (1 + 4) = 4 \\times 5 = 20$。\n\n这些值将由程序计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the normalized arithmetic operation count for a fast direct solver\n    on the 2D screened Poisson equation using a Fourier-Chebyshev spectral method.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is of the form (N_x, N_y).\n    test_cases = [\n        (64, 65),\n        (1, 33),\n        (1024, 257),\n        (2, 2),\n    ]\n\n    results = []\n    \n    # The total half-bandwidth is given as a fixed constant.\n    total_half_bandwidth = 2.0\n\n    for case in test_cases:\n        Nx, Ny = case\n        \n        # The cost formula for the FFT stage is given as:\n        # C_FFT = Nx * Ny * log2(Nx)\n        # Note: log2(1) = 0, which is correctly handled by np.log2.\n        # If Nx is not a power of 2, the FFT is still well-defined,\n        # though practical implementations might be more efficient for powers of 2.\n        # The formula given must be used as is.\n        c_fft = float(Nx) * float(Ny) * np.log2(float(Nx))\n        \n        # The cost formula for the banded solver stage is given as:\n        # C_band = Nx * Ny * (beta_u + beta_l)^2\n        c_band = float(Nx) * float(Ny) * (total_half_bandwidth**2)\n        \n        # The total normalized arithmetic operation count is the sum of the two.\n        c_total = c_fft + c_band\n        \n        results.append(c_total)\n\n    # Final print statement in the exact required format.\n    # The output format must be \"[result1,result2,result3,result4]\" with floating-point numbers.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3446498"}]}