{"hands_on_practices": [{"introduction": "本练习将带你回归基础，从离散傅里叶变换 ($DFT$) 的第一性原理出发，探索混淆现象的本质。通过对一个包含高频和低频分量的简单函数进行采样和变换，你将亲手推导出高频信号在离散网格上如何“伪装”成低频信号，从而深刻理解采样率不足导致信息失真的根本原因。[@problem_id:3362811]", "problem": "考虑周期函数 $u(x) = \\sin(3x) + \\sin(9x)$，它在区间 $[0,2\\pi)$ 上，于 $N=8$ 个等距网格点 $x_j = \\frac{2\\pi j}{N}$（$j=0,1,\\dots,N-1$）上进行采样。设离散傅里叶变换 (DFT) 定义为\n$$\n\\hat{u}_k \\;=\\; \\sum_{j=0}^{N-1} u(x_j)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right), \\quad k=0,1,\\dots,N-1,\n$$\n其逆变换由下式给出\n$$\nu(x_j) \\;=\\; \\frac{1}{N}\\sum_{k=0}^{N-1} \\hat{u}_k\\,\\exp\\!\\left(\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right).\n$$\n从这些定义以及关于周期采样和三角恒等式的第一性原理出发，当 $N=8$ 时，推导 $k=0,1,\\dots,N-1$ 的精确 DFT 系数 $\\hat{u}_k$。在你的推导中，对于两个分量 $\\sin(3x)$ 和 $\\sin(9x)$，请指明哪些离散索引携带非零能量，并解释由于在 $N=8$ 上采样，哪个高频分量以何种复振幅混淆到哪个索引。最后，将 $\\hat{u}_k$（对于 $k=0,1,\\dots,7$）的完整向量写成单行的形式。不需要进行数值四舍五入。以精确形式表示所有数学量。", "solution": "问题要求推导函数 $u(x) = \\sin(3x) + \\sin(9x)$ 在 $N=8$ 个点的网格上采样后的离散傅里叶变换 (DFT) 系数 $\\hat{u}_k$。\n\n给定函数为 $u(x) = \\sin(3x) + \\sin(9x)$。采样点为 $x_j = \\frac{2\\pi j}{N}$，$j=0, 1, \\dots, N-1$。采样序列 $u(x_j)$ 的 DFT 由下式给出\n$$\n\\hat{u}_k \\;=\\; \\sum_{j=0}^{N-1} u(x_j)\\,\\exp\\!\\left(-\\mathrm{i}\\,\\frac{2\\pi k j}{N}\\right), \\quad k=0,1,\\dots,N-1.\n$$\n为了从第一性原理出发，我们使用欧拉公式 $\\sin(\\theta) = \\frac{1}{2\\mathrm{i}}(e^{\\mathrm{i}\\theta} - e^{-\\mathrm{i}\\theta})$ 来表示正弦函数。\n函数 $u(x)$ 可以写成四个复指数项的和：\n$$\nu(x) = \\frac{1}{2\\mathrm{i}}\\left(e^{\\mathrm{i}3x} - e^{-\\mathrm{i}3x}\\right) + \\frac{1}{2\\mathrm{i}}\\left(e^{\\mathrm{i}9x} - e^{-\\mathrm{i}9x}\\right)\n$$\n根据 DFT 的线性性质，我们可以分别求出每个分量的变换，然后将结果相加。让我们分析一个一般复指数项 $f_m(x) = e^{\\mathrm{i}mx}$ 在网格上采样后的 DFT，其中 $m$ 是一个整数波数。在网格点 $x_j$ 上，这变为 $f_m(x_j) = e^{\\mathrm{i}m(2\\pi j/N)} = \\exp(\\frac{2\\pi \\mathrm{i} m j}{N})$。\n\n该序列的 DFT 是\n$$\n\\hat{f}_{m,k} = \\sum_{j=0}^{N-1} \\exp\\left(\\frac{2\\pi \\mathrm{i} m j}{N}\\right) \\exp\\left(-\\frac{2\\pi \\mathrm{i} k j}{N}\\right) = \\sum_{j=0}^{N-1} \\exp\\left(\\frac{2\\pi \\mathrm{i} (m-k) j}{N}\\right)\n$$\n这是一个几何级数。根据离散复指数的正交性，这个和的值为：\n$$\n\\sum_{j=0}^{N-1} \\left(\\exp\\left(\\frac{2\\pi \\mathrm{i} (m-k)}{N}\\right)\\right)^j =\n\\begin{cases}\nN & \\text{若 } m-k \\text{ 是 } N \\text{ 的整数倍} \\\\\n0 & \\text{否则}\n\\end{cases}\n$$\n由于 DFT 索引 $k$ 的范围是 $\\{0, 1, \\dots, N-1\\}$，条件“$m-k$ 是 $N$ 的整数倍”简化为 $k \\equiv m \\pmod N$。对于任意整数波数 $m$，在此范围内都存在一个唯一的索引 $k$ 满足该同余关系。\n\n我们现在将这个结果应用于 $u(x)$ 中的四个指数项，其中 $N=8$。\n\n分量 1: $\\frac{1}{2\\mathrm{i}}e^{\\mathrm{i}3x}$。这里，波数为 $m=3$。同余关系 $k \\equiv 3 \\pmod 8$ 由 $k=3$ 满足。这一项对 DFT 系数 $\\hat{u}_3$ 有贡献。其贡献是其振幅乘以 $N$：$\\frac{1}{2\\mathrm{i}} \\times N = \\frac{N}{2\\mathrm{i}} = -\\frac{\\mathrm{i}N}{2}$。\n\n分量 2: $-\\frac{1}{2\\mathrm{i}}e^{-\\mathrm{i}3x}$。这里，波数为 $m=-3$。同余关系 $k \\equiv -3 \\pmod 8$ 由 $k=-3+8=5$ 满足。这一项对 $\\hat{u}_5$ 有贡献。其贡献是其振幅乘以 $N$：$-\\frac{1}{2\\mathrm{i}} \\times N = -\\frac{N}{2\\mathrm{i}} = \\frac{\\mathrm{i}N}{2}$。\n因此，$\\sin(3x)$ 分量的能量位于索引 $k=3$ 和 $k=5$ 处。\n\n分量 3: $\\frac{1}{2\\mathrm{i}}e^{\\mathrm{i}9x}$。这里，波数为 $m=9$。这里发生了混淆。对于 $N=8$ 个点的网格，奈奎斯特频率对应的波数为 $N/2=4$。由于 $|m|=9 > 4$，这个频率被混淆了。我们从同余关系 $k \\equiv 9 \\pmod 8$ 中找到其混淆后的索引 $k$。因为 $9=1 \\times 8 + 1$，所以我们有 $k=1$。在离散网格上，这个高频分量与波数为 $m=1$ 的分量无法区分。它对 DFT 的贡献在索引 $\\hat{u}_1$ 处。振幅为 $\\frac{1}{2\\mathrm{i}}$，所以贡献是 $\\frac{1}{2\\mathrm{i}} \\times N = -\\frac{\\mathrm{i}N}{2}$。\n\n分量 4: $-\\frac{1}{2\\mathrm{i}}e^{-\\mathrm{i}9x}$。这里，波数为 $m=-9$。同余关系为 $k \\equiv -9 \\pmod 8$。因为 $-9=-2 \\times 8 + 7$，所以我们有 $k=7$。（或者，$-9 \\equiv -1 \\pmod 8$，对应于索引 $k=N-1=7$）。这个分量混淆到波数为 $m=-1$ 的模式。它对 DFT 的贡献在索引 $\\hat{u}_7$ 处。振幅为 $-\\frac{1}{2\\mathrm{i}}$，所以贡献是 $-\\frac{1}{2\\mathrm{i}} \\times N = \\frac{\\mathrm{i}N}{2}$。\n高频分量 $\\sin(9x)$ 在网格上混淆为低频分量 $\\sin(x)$，因为 $e^{\\mathrm{i}9x_j}=e^{\\mathrm{i}9(2\\pi j/8)}=e^{\\mathrm{i}(8+1)(2\\pi j/8)}=e^{\\mathrm{i}2\\pi j}e^{\\mathrm{i}1(2\\pi j/8)}=e^{\\mathrm{i}x_j}$。类似地，$e^{-\\mathrm{i}9x_j}=e^{-\\mathrm{i}x_j}$。$\\sin(9x)$ 分量的能量混淆到了索引 $k=1$ 和 $k=7$。\n\n我们通过将 $N=8$ 时每个索引 $k \\in \\{0, 1, \\dots, 7\\}$ 处的贡献相加，来组合成 DFT 系数 $\\hat{u}_k$ 的完整向量。\n- $\\hat{u}_0 = 0$，因为没有零频率（常数）项。\n- $\\hat{u}_1$: 来自混淆的 $e^{\\mathrm{i}9x}$ 项的贡献: $-\\frac{\\mathrm{i}N}{2} = -\\frac{8\\mathrm{i}}{2} = -4\\mathrm{i}$。\n- $\\hat{u}_2 = 0$。\n- $\\hat{u}_3$: 来自 $e^{\\mathrm{i}3x}$ 项的贡献: $-\\frac{\\mathrm{i}N}{2} = -\\frac{8\\mathrm{i}}{2} = -4\\mathrm{i}$。\n- $\\hat{u}_4 = 0$。\n- $\\hat{u}_5$: 来自 $e^{-\\mathrm{i}3x}$ 项的贡献: $\\frac{\\mathrm{i}N}{2} = \\frac{8\\mathrm{i}}{2} = 4\\mathrm{i}$。(索引 $k=5 = 8-3$)。\n- $\\hat{u}_6 = 0$。\n- $\\hat{u}_7$: 来自混淆的 $e^{-\\mathrm{i}9x}$ 项的贡献: $\\frac{\\mathrm{i}N}{2} = \\frac{8\\mathrm{i}}{2} = 4\\mathrm{i}$。(索引 $k=7 = 8-1$)。\n\nDFT系数的完整向量是 $(\\hat{u}_0, \\hat{u}_1, \\hat{u}_2, \\hat{u}_3, \\hat{u}_4, \\hat{u}_5, \\hat{u}_6, \\hat{u}_7)$。\n代入计算出的值得到：\n$$\n(0, -4\\mathrm{i}, 0, -4\\mathrm{i}, 0, 4\\mathrm{i}, 0, 4\\mathrm{i})\n$$\n这个结果反映了这样一个性质：对于一个实值输入信号 $u(x_j)$，其 DFT 系数必须满足共轭对称性质 $\\hat{u}_k = \\overline{\\hat{u}_{N-k}}$（对于 $k=1, \\dots, N-1$）。\n我们来检验一下：\n$\\hat{u}_1 = -4\\mathrm{i}$, $\\hat{u}_{8-1}=\\hat{u}_7 = 4\\mathrm{i}$。$\\overline{\\hat{u}_7} = -4\\mathrm{i} = \\hat{u}_1$。正确。\n$\\hat{u}_2 = 0$, $\\hat{u}_{8-2}=\\hat{u}_6 = 0$。$\\overline{\\hat{u}_6} = 0 = \\hat{u}_2$。正确。\n$\\hat{u}_3 = -4\\mathrm{i}$, $\\hat{u}_{8-3}=\\hat{u}_5 = 4\\mathrm{i}$。$\\overline{\\hat{u}_5} = -4\\mathrm{i} = \\hat{u}_3$。正确。\n$\\hat{u}_4=0$, $\\hat{u}_{8-4}=\\hat{u}_4=0$。这个系数必须是实数，它确实是。正确。\n推导是一致的。", "answer": "$$\n\\boxed{\\pmatrix{0 & -4\\mathrm{i} & 0 & -4\\mathrm{i} & 0 & 4\\mathrm{i} & 0 & 4\\mathrm{i}}}\n$$", "id": "3362811"}, {"introduction": "理解了混淆的成因后，下一步是学习如何有效抑制它。本练习将指导你通过数值实验来验证一种关键的去混淆技术——“$3/2$ 填充规则”。你将编写代码来计算一个二次非线性项，并证明使用该规则得到的结果与精确的、无混淆的卷积结果一致，从而掌握谱方法中处理非线性项的核心技巧。[@problem_id:3362836]", "problem": "考虑一个一维、$2\\pi$-周期函数，该函数在一个包含 $N$ 个点的均匀网格上表示，并考虑其离散傅里叶变换（DFT）。设 DFT 的约定与标准数值库使用的约定一致：网格函数 $u_j$（其中 $j=0,\\dots,N-1$）的正向 DFT 由下式给出\n$$\n\\hat{u}_k = \\sum_{j=0}^{N-1} u_j \\, e^{-2\\pi i j k / N},\n$$\n其逆 DFT 由下式给出\n$$\nu_j = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{u}_k \\, e^{2\\pi i j k / N}.\n$$\n物理空间中的逐点乘法对应于谱空间中的循环卷积。具体来说，对于乘积 $w_j = u_j v_j$，有\n$$\n\\widehat{w}_k = \\frac{1}{N} \\sum_{p=0}^{N-1} \\hat{u}_p \\, \\hat{v}_{(k-p) \\bmod N}.\n$$\n混淆的产生是因为谱卷积是模 $N$ 运算。当输入谱带限于 $|k| \\le K_{\\max}$，并且我们感兴趣的是 $|k| \\le K_{\\max}$ 的乘积谱时，将谱补零至更长的长度 $M$（其中 $M \\ge \\frac{3}{2} N$，即所谓的“三分之二规则”），并在此更高分辨率下执行伪乘积，可以防止解析频带的卷积中出现环绕，从而消除二次非线性项的混淆。\n\n您的任务是针对 $N=12$ 和输入谱支撑集在 $|k| \\le 4$ 内的情况，实现一个计算，以验证以下论述：\n对于所有解析模式 $|k| \\le 4$，三分之二规则补零（补零至 $M = \\frac{3}{2} N = 18$）产生的谱系数 $\\widehat{(uv)}_k$ 与精确、非混淆卷积\n$$\n\\widehat{(uv)}_k^{\\mathrm{exact}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\, \\hat{v}_{k-p},\n$$\n的结果相同，其中 $k-p$ 在 $[-4,4]$ 范围之外的项被视为零。换句话说，当 $u$ 和 $v$ 的谱在 $|k| \\le 4$ 之外为零，且乘积通过长度为 $M=18$ 的逆 DFT、在物理空间中进行乘法、再通过正向 DFT 形成时，对于所有 $|k| \\le 4$ 的模式，其结果为\n$$\n\\widehat{(uv)}_k^{\\mathrm{pad}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\, \\hat{v}_{k-p}\n$$\n并且没有任何循环环绕影响这些模式。\n\n实现一个程序，该程序：\n- 在 $N=12$ 的网格上，为支撑集在 $|k| \\le 4$ 内的谱 $\\hat{u}_k$ 和 $\\hat{v}_k$ 构建测试数据。表示方法使用偶数 $N$ 的 $N$ 点 DFT 频点约定：整数波数 $k$ 对应于 DFT 频点，其中 $k=0,1,\\dots,5,-6,-5,\\dots,-1$ 分别映射到索引 $0,1,\\dots,5,6,7,\\dots,11$。\n- 构建长度为 $M=18$ 的补零谱，方法是将相同的 $\\hat{u}_k$ 和 $\\hat{v}_k$ 值放置在 $k=-4,-3,\\dots,4$ 对应的 $M$ 点 DFT 频点上（对于偶数 $M$，频点对应于 $k=0,1,\\dots,8,-9,-8,\\dots,-1$ 映射到索引 $0,1,\\dots,8,9,10,\\dots,17$）。\n- 计算补零伪乘积，方法是：进行长度为 $M$ 的逆 DFT 到物理空间，进行逐点乘法，然后进行正向 DFT 回到谱空间，从而从 $M$ 点变换中得到 $|k| \\le 4$ 的 $\\widehat{(uv)}_k^{\\mathrm{pad}}$。\n- 计算 $|k| \\le 4$ 的精确、非混淆卷积系数 $\\widehat{(uv)}_k^{\\mathrm{exact}}$，使用上面显示的带有因子 $\\frac{1}{M}$ 的线性（非模）和，并将 $p$ 或 $q$ 位于 $[-4,4]$ 之外的 $\\hat{u}_p$ 和 $\\hat{v}_{q}$ 视为零。\n- 对每个测试用例，报告最大绝对差异\n$$\n\\max_{|k| \\le 4} \\left| \\widehat{(uv)}_k^{\\mathrm{pad}} - \\widehat{(uv)}_k^{\\mathrm{exact}} \\right|.\n$$\n\n设计一个包含四种情况的测试套件，以检验不同方面：\n1. 一般情况：在 $k=-4,\\dots,4$ 范围内，$\\hat{u}_k$ 和 $\\hat{v}_k$ 使用随机复系数，并使用固定的随机种子以保证可复现性。\n2. 边界情况：只有最高解析模式非零，即 $\\hat{u}_{\\pm 4}$ 和 $\\hat{v}_{\\pm 4}$ 非零，所有其他系数为零。\n3. 实值函数情况：$\\hat{u}_k$ 满足厄米对称性 $\\hat{u}_{-k} = \\overline{\\hat{u}_k}$ 且 $\\hat{u}_0$ 为实数，而 $\\hat{v}_k$ 为一般复数，两者支撑集都在 $|k| \\le 4$ 内。\n4. 常数乘以带限情况：$\\hat{u}_0$ 非零，所有其他 $\\hat{u}_k=0$，而 $\\hat{v}_k$ 是支撑集在 $|k| \\le 4$ 内的一般复数。\n\n对于每种情况，您的程序应计算上述指定的最大差异。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如：\n$$\n[\\text{e}_1,\\text{e}_2,\\text{e}_3,\\text{e}_4]\n$$\n其中每个 $\\text{e}_i$ 是一个浮点数。不涉及物理单位或角度单位。所有四个输出都必须是浮点数。预期结果是每个 $\\text{e}_i$ 都在机器精度的数量级上，从而证明在给定条件下，三分之二规则补零能够为解析频带 $|k| \\le 4$ 再现精确、非混淆的卷积。", "solution": "问题陈述要求在谱方法背景下，对二次非线性的三分之二 ($3/2$) 去混淆规则进行数值验证。该问题在科学上是合理的、适定的，并且为其求解提供了所有必要的参数和定义。这是理解谱变换机制和混淆控制的一个典型练习。\n\n被测试的基本原理是，物理空间中两个函数 $u(x)$ 和 $v(x)$ 的逐点乘法对应于谱空间中它们的谱 $\\hat{u}_k$ 和 $\\hat{v}_k$ 的卷积。当在 $N$ 个点的有限网格上使用离散傅里叶变换（DFT）时，这种卷积变成循环的（即模 $N$）。这种循环性可能导致乘积的高频分量“环绕”并污染低频分量，这种效应称为混淆。\n\n三分之二规则是为消除这种混淆而采用的更通用的补零或填充方法的一种特定形式。如果输入函数 $u$ 和 $v$ 是带限的，其谱仅在波数 $|k| \\le K_{\\max}$ 范围内非零，那么它们的乘积 $w = uv$ 的谱将带限于 $|k| \\le 2K_{\\max}$。为防止在原始解析频带（$|k| \\le K_{\\max}$）中发生混淆，我们必须在足够大的网格上执行计算，以确保不会发生环绕。对于二次非线性，其去混淆条件是补零后的网格大小 $M$ 必须满足 $M > 3K_{\\max}$。\n\n在这个问题中，给定 $N=12$，输入谱带限于 $K_{\\max}=4$。三分之二规则建议补零到 $M = \\frac{3}{2}N = 18$。这满足去混淆条件，因为 $M=18 > 3K_{\\max} = 3 \\times 4 = 12$。任务是证明对于解析模式 $|k| \\le 4$，这种补零计算的结果与精确的、非混淆的卷积和相同。\n\n解决方案通过实现和比较乘积谱 $\\widehat{(uv)}_k$ 的两种计算路径来进行。\n\n**路径1：补零伪谱乘积 $\\widehat{(uv)}_k^{\\mathrm{pad}}$**\n\n此路径模拟了谱代码中使用的数值过程。\n1.  **谱表示**：为每个测试用例生成输入谱系数 $\\hat{u}_k$ 和 $\\hat{v}_k$（对于 $|k| \\le 4$）。\n2.  **补零**：将两个长度为 $M=18$ 的复值数组初始化为零。将输入系数 $\\hat{u}_k$ 和 $\\hat{v}_k$ 放置到这些数组中，其索引对应于各自的波数 $k \\in [-4, 4]$。从波数 $k$ 到给定变换大小的 DFT 数组索引的映射由标准库函数提供，例如 `numpy.fft.fftfreq`。对于 $M=18$，整数波数的顺序为 $k=0, 1, \\dots, 8, -9, -8, \\dots, -1$。\n3.  **变换到物理空间**：对每个补零谱数组 $\\hat{u}^{\\mathrm{pad}}$ 和 $\\hat{v}^{\\mathrm{pad}}$ 应用大小为 $M$ 的逆 DFT，以获得在补零物理网格上的相应函数 $u_j$ 和 $v_j$（对于 $j=0, \\dots, M-1$）。遵循给定的标准约定，逆 DFT 包含一个 $1/M$ 的归一化因子：\n    $$u_j = \\frac{1}{M} \\sum_{k} \\hat{u}^{\\mathrm{pad}}_k e^{2\\pi i j k / M}$$\n4.  **逐点乘法**：在 $M$ 点物理网格上对函数进行逐点相乘：$w_j = u_j v_j$。\n5.  **变换到谱空间**：对乘积 $w_j$ 应用大小为 $M$ 的正向 DFT，以获得其谱 $\\widehat{(uv)}_k^{\\mathrm{pad}}$。\n\n**路径2：精确非混淆卷积 $\\widehat{(uv)}_k^{\\mathrm{exact}}$**\n\n此路径计算数学上精确的线性卷积和，作为基准真值。DFT 的卷积定理指出，补零过程产生：\n$$ \\widehat{(uv)}_k^{\\mathrm{pad}} = \\frac{1}{M} \\sum_{p} \\hat{u}^{\\mathrm{pad}}_p \\hat{v}^{\\mathrm{pad}}_{(k-p) \\pmod M} $$\n如前所述，对于 $|k| \\le 4$、$|p| \\le 4$ 和 $M=18$，波数之和 $p+(k-p)$ 不会混淆到感兴趣的范围内。因此，模运算是无关紧要的，结果应与线性卷积匹配。我们直接计算这个和：\n$$ \\widehat{(uv)}_k^{\\mathrm{exact}} = \\frac{1}{M} \\sum_{p=-4}^{4} \\hat{u}_p \\hat{v}_{k-p} $$\n其中，如果输入系数 $\\hat{u}_p$ 和 $\\hat{v}_{k-p}$ 对应的波数超出了 $[-4, 4]$ 范围，则它们被视为零。对每个目标波数 $k \\in [-4, 4]$ 计算此和。\n\n**比较与验证**\n\n对于四个测试用例中的每一个，程序都会计算原始解析频带 $|k| \\le 4$ 中所有波数的 $\\widehat{(uv)}_k^{\\mathrm{pad}}$ 和 $\\widehat{(uv)}_k^{\\mathrm{exact}}$。然后计算两条路径结果之间的最大绝对差：\n$$ \\max_{|k| \\le 4} \\left| \\widehat{(uv)}_k^{\\mathrm{pad}} - \\widehat{(uv)}_k^{\\mathrm{exact}} \\right| $$\n正如理论所预测的，这个差异应该在机器浮点精度的数量级上，从而数值上证明三分之二补零规则成功地消除了解析谱模式的混淆误差。这四个测试用例旨在探究不同情景（一般、边界、实值、常数），以确保该结论的鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_discrepancy(u_hat_coeffs, v_hat_coeffs, M, K_max):\n    \"\"\"\n    Calculates the maximum discrepancy between the padded pseudospectral product\n    and the exact non-aliased convolution.\n\n    Args:\n        u_hat_coeffs (dict): Coefficients for u_hat, mapping k -> value.\n        v_hat_coeffs (dict): Coefficients for v_hat, mapping k -> value.\n        M (int): Padded grid size.\n        K_max (int): Maximum wavenumber for inputs.\n\n    Returns:\n        float: The maximum absolute discrepancy.\n    \"\"\"\n    # Define the wavenumbers we are interested in for both input and output.\n    wavenumbers_of_interest = list(range(-K_max, K_max + 1))\n\n    # --- Path 1: Padded Pseudospectral Product ---\n\n    # Map integer wavenumbers to their indices in the M-point DFT array.\n    k_vals_M = np.fft.fftfreq(M, 1/M)\n    k_map_M = {int(round(k)): i for i, k in enumerate(k_vals_M)}\n\n    # Create M-length spectral arrays and populate them (zero-padding).\n    u_hat_M = np.zeros(M, dtype=complex)\n    v_hat_M = np.zeros(M, dtype=complex)\n    \n    for k in wavenumbers_of_interest:\n        # Check if the wavenumber k is representable on the M-grid\n        if k in k_map_M:\n            idx = k_map_M[k]\n            u_hat_M[idx] = u_hat_coeffs.get(k, 0)\n            v_hat_M[idx] = v_hat_coeffs.get(k, 0)\n\n    # IFFT to physical space, pointwise multiply, then FFT back to spectral space.\n    # numpy's ifft includes the 1/M normalization factor as per the problem.\n    u_M = np.fft.ifft(u_hat_M)\n    v_M = np.fft.ifft(v_hat_M)\n    w_M = u_M * v_M\n    w_hat_padded = np.fft.fft(w_M)\n\n    # --- Path 2: Exact Non-Aliased Convolution ---\n\n    w_hat_exact = {}\n    for k in wavenumbers_of_interest:\n        conv_sum = 0.0 + 0.0j\n        # Sum over p from -K_max to K_max\n        for p in wavenumbers_of_interest:\n            u_p = u_hat_coeffs.get(p, 0)\n            # v_q where q = k-p. .get() handles cases where k-p is out of band.\n            v_k_minus_p = v_hat_coeffs.get(k - p, 0)\n            conv_sum += u_p * v_k_minus_p\n        \n        w_hat_exact[k] = (1 / M) * conv_sum\n\n    # --- Comparison ---\n\n    max_discrepancy = 0.0\n    for k in wavenumbers_of_interest:\n        # Get the coefficient from the padded product result array.\n        idx = k_map_M[k]\n        val_padded = w_hat_padded[idx]\n        \n        # Get the coefficient from the exact convolution calculation.\n        val_exact = w_hat_exact[k]\n        \n        discrepancy = np.abs(val_padded - val_exact)\n        if discrepancy > max_discrepancy:\n            max_discrepancy = discrepancy\n\n    return max_discrepancy\n\ndef solve():\n    \"\"\"\n    Main function to run the four test cases and print results.\n    \"\"\"\n    # Define problem parameters\n    N = 12\n    M = int(N * 3 / 2)  # M = 18\n    K_max = 4\n\n    wavenumbers = list(range(-K_max, K_max + 1))\n    \n    # --- Test Case Generation ---\n\n    # Case 1: General case with random complex coefficients\n    rng1 = np.random.default_rng(seed=123)\n    u_hat_1 = {k: rng1.uniform(-1, 1) + 1j * rng1.uniform(-1, 1) for k in wavenumbers}\n    v_hat_1 = {k: rng1.uniform(-1, 1) + 1j * rng1.uniform(-1, 1) for k in wavenumbers}\n\n    # Case 2: Boundary case where only the highest resolved modes are nonzero\n    rng2 = np.random.default_rng(seed=456)\n    u_hat_2 = {\n        4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1),\n        -4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1)\n    }\n    v_hat_2 = {\n        4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1),\n        -4: rng2.uniform(-1, 1) + 1j * rng2.uniform(-1, 1)\n    }\n\n    # Case 3: Real-valued function u (Hermitian symmetry)\n    rng3 = np.random.default_rng(seed=789)\n    u_hat_3 = {}\n    u_hat_3[0] = rng3.uniform(-1, 1)  # u_0 must be real\n    for k in range(1, K_max + 1):\n        val = rng3.uniform(-1, 1) + 1j * rng3.uniform(-1, 1)\n        u_hat_3[k] = val\n        u_hat_3[-k] = np.conj(val)\n    v_hat_3 = {k: rng3.uniform(-1, 1) + 1j * rng3.uniform(-1, 1) for k in wavenumbers}\n\n    # Case 4: Constant times band-limited case (u has only k=0 mode)\n    rng4 = np.random.default_rng(seed=101)\n    u_hat_4 = {0: rng4.uniform(-1, 1) + 1j * rng4.uniform(-1, 1)}\n    v_hat_4 = {k: rng4.uniform(-1, 1) + 1j * rng4.uniform(-1, 1) for k in wavenumbers}\n    \n    test_cases = [\n        (u_hat_1, v_hat_1),\n        (u_hat_2, v_hat_2),\n        (u_hat_3, v_hat_3),\n        (u_hat_4, v_hat_4),\n    ]\n\n    results = []\n    for u_coeffs, v_coeffs in test_cases:\n        discrepancy = calculate_discrepancy(u_coeffs, v_coeffs, M, K_max)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362836"}, {"introduction": "本练习将理论付诸实践，让你在一个更复杂的动态系统——伯格斯方程中，直面混淆的实际影响。通过设计一个伪谱方法模拟，你将量化在有无去混淆处理两种情况下，非线性相互作用向低波数模式注入的虚假能量。这个实践将揭示为何在科学计算中，严格的去混淆对于保证模拟结果的物理保真度至关重要。[@problem_id:3362824]", "problem": "考虑一维粘性 Burgers 方程，其定义在周期性域上，角度以弧度为单位，\n$$\nu_t + \\frac{1}{2}\\partial_x\\left(u^2\\right) = \\nu\\, u_{xx}, \\quad x \\in [0,2\\pi], \\quad t \\ge 0,\n$$\n其中 $u(x,t)$ 是一个标量场，$\\nu \\ge 0$ 是粘性系数，且在 $x=0$ 和 $x=2\\pi$ 处施加周期性边界条件。伪谱法利用快速傅里叶变换 (FFT) 对 $u(x,t)$ 的傅里叶系数 $\\hat{u}_k(t)$ 进行演化，并在物理空间中计算诸如 $u^2$之类的乘积。非线性项在谱空间中的离散卷积可能导致混淆：未解析的三元组 $(k_1,k_2,k_3)$（满足 $k_3=k_1+k_2$）会超出最高可解析波数，并折返到低波数模态中，从而虚假地注入能量。一种标准的缓解方法是三分之二去混淆规则，对于二次非线性项，该规则将非线性项中所有满足 $|k| > \\lfloor N/3 \\rfloor$ 的傅里叶模态置零，其中 $N$ 是网格点数和傅里叶模态数。\n\n设计并实现一个数值实验，通过比较无去混淆情况与使用三分之二规则的情况，经验性地描绘出由粘性 Burgers 方程的伪谱离散化中的混淆所引起的向低模态的能量转移。使用以下基本依据：\n\n- 在 $[0,2\\pi]$ 上的傅里叶级数为 $u(x,t) = \\sum_{k=-\\infty}^{\\infty} \\hat{u}_k(t) e^{\\mathrm{i}k x}$，在一个包含 $N$ 个点的离散网格上，可解析的波数为 $k \\in \\{-N/2+1,\\dots,-1,0,1,\\dots,N/2\\}$。\n- 伪谱法在物理空间中计算 $u^2$，然后变换到傅里叶空间，从而得到 $\\widehat{u^2}_k$ 的离散卷积。\n- 对于任意信号 $u$，离散网格上的 Parseval 恒等式意味着 $\\sum_{j=0}^{N-1} |u(x_j,t)|^2 = \\frac{1}{N} \\sum_{k} |\\hat{u}_k(t)|^2$，其中 $x_j$ 是网格点。\n- 仅由非线性项 $\\mathcal{N}[u] = -\\frac{1}{2}\\partial_x(u^2)$ 引起的、向一组低模态 $\\mathcal{K}_\\ell = \\{k: |k| \\le k_\\ell\\}$ 的模态能量转移率定义为\n$$\n\\dot{E}_\\ell(t) = \\frac{1}{N}\\sum_{k \\in \\mathcal{K}_\\ell} \\Re\\left\\{\\hat{u}_k^*(t)\\,\\widehat{\\mathcal{N}[u]}_k(t)\\right\\}.\n$$\n这衡量了在时间 $t$ 时，由非线性相互作用流入低模态频带的能量速率。在 $[0,T]$ 上的累积注入能量为 $I = \\int_0^T \\dot{E}_\\ell(t)\\,\\mathrm{d}t$。\n\n你的程序必须：\n\n1. 为 $u_t = -\\frac{1}{2}\\partial_x(u^2) + \\nu\\,u_{xx}$ 实现一个伪谱时间积分器，该积分器在傅里叶空间中维持状态，在物理空间中计算非线性项，并使用四阶 Runge–Kutta 格式。谱空间中的微分算子为 $\\partial_x \\leftrightarrow \\mathrm{i}k$ 和 $\\partial_{xx} \\leftrightarrow -k^2$。\n2. 在每个时间步，根据相同的当前状态 $u(\\cdot,t)$ 计算非线性项两次：\n   - 无去混淆：$\\widehat{\\mathcal{N}}^{\\mathrm{unal}}_k(t) = -\\frac{1}{2}\\mathrm{i}k\\,\\widehat{u^2}_k(t)$，不进行滤波。\n   - 使用三分之二规则：$\\widehat{\\mathcal{N}}^{2/3}_k(t) = -\\frac{1}{2}\\mathrm{i}k\\,\\left[\\widehat{u^2}_k(t)\\,\\mathbf{1}_{\\{|k|\\le \\lfloor N/3 \\rfloor\\}}\\right]$，其中 $\\mathbf{1}_{\\{|k|\\le \\lfloor N/3 \\rfloor\\}}$ 是指示函数，将 $|k|$ 超过截止值的模态置零。\n3. 使用滤波后的非线性项 $\\widehat{\\mathcal{N}}^{2/3}_k(t)$ 与粘性项相结合来对 $u$ 进行时间演化，以确保在实验进行过程中状态不受混淆污染。\n4. 在每个时间步，使用上述定义测量两种情况下的低模态能量转移率 $\\dot{E}_\\ell$，即 $\\dot{E}_\\ell^{\\mathrm{unal}}(t)$ 和 $\\dot{E}_\\ell^{2/3}(t)$。通过黎曼和 $I \\approx \\sum_n \\dot{E}_\\ell(t_n)\\,\\Delta t$ 来近似累积注入能量。\n5. 对每个测试用例，报告标量值 $D = I^{\\mathrm{unal}} - I^{2/3}$，该值量化了由混淆引起的额外累积低模态能量注入。\n\n使用确定性初始条件\n$$\nu(x,0) = A_1\\sin(m_1 x) + A_2\\cos(m_2 x + \\phi) + A_3\\sin(m_3 x),\n$$\n其中 $A_1=1.0$，$A_2=0.8$，$A_3=0.5$，$\\phi=0.3$，并且\n$$\nm_1 = \\left\\lfloor \\frac{N}{4} \\right\\rfloor,\\quad m_2 = \\left\\lfloor \\frac{N}{5} \\right\\rfloor,\\quad m_3 = \\left\\lfloor \\frac{N}{3} \\right\\rfloor - 1.\n$$\n基于 Courant–Friedrichs–Lewy (CFL) 约束 $ \\Delta t = \\alpha\\,\\Delta x/\\max_x |u(x,0)|$（其中 $\\alpha=0.2$，网格间距 $\\Delta x = 2\\pi/N$）来选择时间步长，并将步数向上取整为整数，以确保精确达到最终时间。\n\n你的程序应使用以下测试套件，以确保覆盖不同场景：\n\n- 测试 1 (正常路径)：$N=64$，$\\nu=10^{-3}$，$T=0.5$，$k_\\ell=4$。\n- 测试 2 (中等粘性，更多模态)：$N=96$，$\\nu=5\\times 10^{-3}$，$T=0.4$，$k_\\ell=8$。\n- 测试 3 (边缘情况，低分辨率和零粘性，短时间)：$N=32$，$\\nu=0$，$T=0.2$，$k_\\ell=3$。\n- 测试 4 (更高分辨率，更强粘性)：$N=128$，$\\nu=10^{-2}$，$T=0.3$，$k_\\ell=6$。\n\n对每个测试用例，计算如上定义的标量 $D$。你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。所有量均为无量纲；角度以弧度为单位，你必须以不带单位的普通十进制数报告输出。", "solution": "用户提供的问题是有效的。它针对偏微分方程计算解这一标准课题，提出了一个适定且科学合理的数值实验。所有必要的参数和定义都已提供，并且不存在会妨碍唯一解的内部矛盾或模糊之处。\n\n问题要求量化在一维粘性 Burgers 方程 $u_t + \\frac{1}{2}\\partial_x\\left(u^2\\right) = \\nu\\, u_{xx}$（定义于周期性域 $x \\in [0, 2\\pi]$）的伪谱模拟中混淆效应的影响。任务的核心是比较在施加和不施加三分之二去混淆规则两种情况下，非线性项向低波数模态转移的能量。\n\n该解法实现为一个在傅里叶空间中演化系统的伪谱求解器。系统在任意时间 $t$ 的状态由一组傅里叶系数 $\\hat{u}_k(t)$ 表示，其中 $u(x,t) = \\sum_k \\hat{u}_k(t) e^{\\mathrm{i}k x}$。在一个包含 $N$ 个点的离散网格上，波数 $k$ 在由 $N$ 决定的范围内取整数值，通常约为 $-N/2$ 到 $N/2$。\n\n傅里叶空间中的 Burgers 方程表示为：\n$$\n\\frac{d\\hat{u}_k}{dt} = \\widehat{\\mathcal{N}[u]}_k + \\widehat{\\mathcal{L}[u]}_k\n$$\n其中 $\\widehat{\\mathcal{L}[u]}_k$ 是线性（粘性）项，$\\widehat{\\mathcal{N}[u]}_k$ 是非线性（平流）项。利用微分变为乘以 $\\mathrm{i}k$ 的性质，线性项在谱空间中被精确计算为 $\\widehat{\\mathcal{L}[u]}_k = \\nu \\widehat{u_{xx}}_k = -\\nu k^2 \\hat{u}_k$。\n\n非线性项 $\\mathcal{N}[u] = -\\frac{1}{2}\\partial_x(u^2)$ 采用伪谱方法处理，以避免在傅里叶空间中进行计算成本高昂的卷积。其步骤如下：\n1. 将状态变换到物理空间：$u(x_j) = \\text{iFFT}(\\hat{u}_k)$。\n2. 在物理空间中计算二次乘积：$u^2(x_j)$。\n3. 将乘积变换回傅里叶空间：$\\widehat{u^2}_k = \\text{FFT}(u^2(x_j))$。\n4. 应用谱微分：$\\widehat{\\mathcal{N}[u]}_k = -\\frac{1}{2}(\\mathrm{i}k) \\widehat{u^2}_k$。\n\n这个过程会引入混淆误差。两个带限于 $|k| \\le K_{\\max}$ 的信号相乘，会产生频率高达 $|k| \\le 2K_{\\max}$ 的信号。在可解析高达 $|k| \\approx N/2$ 的离散网格上，任何超出此限制生成的频率内容都会发生混淆，或“折返”到可解析的波数范围内，表现为对低模态的虚假贡献。对于二次非线性，三分之二去混淆规则可以缓解此问题。它涉及截断傅里叶变换后的乘积项 $\\widehat{u^2}_k$，将所有 $|k| > \\lfloor N/3 \\rfloor$ 的模态置零。这确保了所得非线性项中的最高波数 $2\\lfloor N/3 \\rfloor$ 小于 $N - \\lfloor N/3 \\rfloor$，从而防止混淆模态污染保留的模态 $|k| \\le \\lfloor N/3 \\rfloor$。\n\n该数值实验旨在隔离和测量混淆误差。系统的状态 $\\hat{u}_k(t)$ 使用四阶 Runge-Kutta (RK4) 格式进行演化。关键的是，时间演化步骤始终使用去混淆的非线性项 $\\widehat{\\mathcal{N}}^{2/3}_k$，以确保参考状态不受污染。在每个时间步 $t_n$，在进行 RK4 更新之前，当前状态 $\\hat{u}_k(t_n)$ 用于计算向低模态带 $\\mathcal{K}_\\ell = \\{k : |k| \\le k_\\ell\\}$ 的瞬时能量转移率。该速率定义为 $\\dot{E}_\\ell(t) = \\frac{1}{N}\\sum_{k \\in \\mathcal{K}_\\ell} \\Re\\left\\{\\hat{u}_k^*(t)\\,\\widehat{\\mathcal{N}[u]}_k(t)\\right\\}$。我们针对两种情况计算它：\n1. $\\dot{E}_\\ell^{\\mathrm{unal}}(t_n)$，使用原始的、有混淆的非线性项 $\\widehat{\\mathcal{N}}^{\\mathrm{unal}}_k$。\n2. $\\dot{E}_\\ell^{2/3}(t_n)$，使用去混淆的非线性项 $\\widehat{\\mathcal{N}}^{2/3}_k$。\n\n在积分时间 $[0, T]$ 内注入低模态带的累积能量通过黎曼和近似，$I \\approx \\sum_n \\dot{E}_\\ell(t_n) \\Delta t$。最终报告的量 $D = I^{\\mathrm{unal}} - I^{2/3}$ 代表了由于混淆而虚假注入低模态的总过剩能量。\n\n实现细节如下。初始条件直接在谱空间中构造，以避免采样带来的离散化误差。时间步长 $\\Delta t$ 根据基于初始最大速度的 CFL 条件确定，并调整步数以确保精确达到最终时间 $T$。该算法使用 Python 实现，并利用 `numpy` 库进行高效的 FFT 计算和数组操作。求解器遍历所有提供的测试用例，为每个用例计算 $D$，并报告结果。", "answer": "```python\nimport numpy as np\nfrom scipy import __version__ as scipy_version\nimport sys\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for all test cases.\n    \"\"\"\n\n    def solve_case(N, nu, T, k_ell):\n        \"\"\"\n        Solves one test case for the Burgers equation aliasing problem.\n        \n        Args:\n            N (int): Number of grid points.\n            nu (float): Viscosity coefficient.\n            T (float): Total integration time.\n            k_ell (int): Cutoff wavenumber for low-mode energy measurement.\n\n        Returns:\n            float: The scalar quantity D, representing excess aliased energy.\n        \"\"\"\n        # Grid and wavenumbers\n        # We use the standard numpy.fft.fftfreq convention {-N/2, ..., N/2-1} for even N.\n        # This is required for compatibility with numpy's FFT algorithms.\n        dx = 2 * np.pi / N\n        k = np.fft.fftfreq(N, d=1.0 / N)  # Integer wavenumbers for domain [0, 2pi]\n\n        # Initial condition parameters\n        A1, A2, A3, phi = 1.0, 0.8, 0.5, 0.3\n        m1 = int(np.floor(N / 4))\n        m2 = int(np.floor(N / 5))\n        m3 = int(np.floor(N / 3)) - 1\n        \n        # Construct initial condition in spectral space\n        u_hat0 = np.zeros(N, dtype=np.complex128)\n        k_indices = {int(ki): i for i, ki in enumerate(k)}\n\n        # A1*sin(m1*x) = A1 * (e^{im1x} - e^{-im1x}) / 2i\n        if m1 in k_indices: u_hat0[k_indices[m1]] += A1 * N / (2j)\n        if -m1 in k_indices: u_hat0[k_indices[-m1]] -= A1 * N / (2j)\n        \n        # A2*cos(m2*x + phi) = A2 * (e^{i(m2x+phi)} + e^{-i(m2x+phi)}) / 2\n        if m2 in k_indices: u_hat0[k_indices[m2]] += A2 * N / 2 * np.exp(1j * phi)\n        if -m2 in k_indices: u_hat0[k_indices[-m2]] += A2 * N / 2 * np.exp(-1j * phi)\n\n        # A3*sin(m3*x)\n        if m3 in k_indices: u_hat0[k_indices[m3]] += A3 * N / (2j)\n        if -m3 in k_indices: u_hat0[k_indices[-m3]] -= A3 * N / (2j)\n\n        # Time step calculation\n        u_phys0 = np.fft.ifft(u_hat0)\n        u_max = np.max(np.abs(u_phys0))\n        alpha = 0.2\n        \n        if u_max > 1e-9:\n            dt_cfl = alpha * dx / u_max\n        else:\n            # Fallback for zero initial condition, though not expected here\n            dt_cfl = 1e-3 \n\n        num_steps = int(np.ceil(T / dt_cfl))\n        dt = T / num_steps\n        \n        # Masks for dealiasing and energy measurement\n        dealias_cutoff = int(np.floor(N / 3))\n        dealias_mask = (np.abs(k) <= dealias_cutoff).astype(int)\n        low_mode_mask = (np.abs(k) <= k_ell).astype(int)\n        \n        # RK4 right-hand-side function (evolves with dealiasing)\n        def rhs(u_hat_in):\n            u_phys = np.fft.ifft(u_hat_in)\n            u_sq_phys = u_phys**2\n            u_sq_hat = np.fft.fft(u_sq_phys)\n            \n            # Apply 2/3 dealiasing rule\n            u_sq_hat_dealiased = u_sq_hat * dealias_mask\n            \n            nonlinear_term = -0.5j * k * u_sq_hat_dealiased\n            viscous_term = -nu * (k**2) * u_hat_in\n            return nonlinear_term + viscous_term\n\n        # Initialize state and cumulative energy sums\n        u_hat = u_hat0.copy()\n        I_unal = 0.0\n        I_23 = 0.0\n        \n        # Time integration loop\n        for _ in range(num_steps):\n            # Measure energy transfer rate at the start of the step\n            u_phys = np.fft.ifft(u_hat)\n            u_sq_phys = u_phys**2\n            u_sq_hat = np.fft.fft(u_sq_phys)\n            \n            # Unaliased nonlinear term\n            N_hat_unal = -0.5j * k * u_sq_hat\n            # Dealiased nonlinear term\n            N_hat_23 = N_hat_unal * dealias_mask\n\n            # Energy transfer rates into low modes\n            Edot_unal = (1/N) * np.real(np.sum(np.conj(u_hat) * N_hat_unal * low_mode_mask))\n            Edot_23 = (1/N) * np.real(np.sum(np.conj(u_hat) * N_hat_23 * low_mode_mask))\n            \n            # Accumulate energy injection (Riemann sum)\n            I_unal += Edot_unal * dt\n            I_23 += Edot_23 * dt\n            \n            # Evolve state using RK4\n            k1 = rhs(u_hat)\n            k2 = rhs(u_hat + dt / 2 * k1)\n            k3 = rhs(u_hat + dt / 2 * k2)\n            k4 = rhs(u_hat + dt * k3)\n            u_hat += dt / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n            \n        D = I_unal - I_23\n        return D\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 1e-3, 0.5, 4),    # Test 1\n        (96, 5e-3, 0.4, 8),    # Test 2\n        (32, 0.0, 0.2, 3),     # Test 3\n        (128, 1e-2, 0.3, 6),   # Test 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, nu, T, k_ell = case\n        result = solve_case(N, nu, T, k_ell)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3362824"}]}