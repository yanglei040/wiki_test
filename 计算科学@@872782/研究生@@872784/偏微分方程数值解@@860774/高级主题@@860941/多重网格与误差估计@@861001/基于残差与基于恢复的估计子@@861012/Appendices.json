{"hands_on_practices": [{"introduction": "基于残差的估计量旨在做到“可靠”，即它们为真实误差提供一个有保证的上限。这种可靠性并非凭空而来，而是源于严谨的数学推导，该推导将估计量的各个项与底层的偏微分方程及泛函不等式联系起来。本练习将指导您完成该推导的一个关键部分，特别是如何处理诺伊曼（Neumann）边界条件。通过这个过程，您将理解为何估计量包含带有特定缩放因子（如网格尺寸 $h_E$）的特定项，从而揭示这些强大工具的理论基础。[@problem_id:3439898]", "problem": "考虑在有界 Lipschitz 域 $\\Omega \\subset \\mathbb{R}^{2}$ 上具有混合 Dirichlet–Neumann 边界条件的二阶线性椭圆边值问题：\n$$\n-\\nabla \\cdot (\\boldsymbol{A} \\nabla u) = f \\quad \\text{in } \\Omega, \\qquad u = 0 \\quad \\text{on } \\Gamma_{D}, \\qquad \\boldsymbol{A}\\nabla u \\cdot \\boldsymbol{n} = g \\quad \\text{on } \\Gamma_{N},\n$$\n其中 $\\partial\\Omega = \\overline{\\Gamma_{D}} \\cup \\overline{\\Gamma_{N}}$，$\\Gamma_{D} \\cap \\Gamma_{N} = \\emptyset$，$\\boldsymbol{n}$ 是 $\\partial\\Omega$ 上的单位外法向量，$f \\in L^{2}(\\Omega)$，$g \\in L^{2}(\\Gamma_{N})$，且 $\\boldsymbol{A}(x)$ 是一个一致有界且一致强制的对称正定 (SPD) 矩阵场，其关于 $\\Omega$ 的一个协调、形状正则的单纯三角剖分 $\\mathcal{T}_{h}$ 是分片常数的。令 $u_{h} \\in V_{h} \\subset H^{1}_{0}(\\Omega; \\Gamma_{D})$ 为协调分片线性 Galerkin 有限元逼近。\n\n按如下方式定义单元和边上的标准残差量。对于一个单元 $K \\in \\mathcal{T}_{h}$，令\n$$\nr_{K} := f + \\nabla \\cdot (\\boldsymbol{A}\\nabla u_{h}) \\in L^{2}(K).\n$$\n对于一个内部边 $E \\in \\mathcal{E}_{h}^{\\mathrm{int}}$，令 $J_{E} := \\llbracket \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n}_{E} \\rrbracket$ 表示法向通量跨过 $E$ 的跳跃。对于一个 Neumann 边界边 $E \\subset \\Gamma_{N}$，定义边界残差\n$$\nR_{E} := g - \\boldsymbol{A}\\nabla u_{h}\\cdot \\boldsymbol{n} \\in L^{2}(E).\n$$\n令 $h_{K}$ 表示 $K$ 的直径，$h_{E}$ 表示 $E$ 的长度。考虑能量范数下的残差型后验误差估计子\n$$\n\\eta^{2} := \\sum_{K \\in \\mathcal{T}_{h}} h_{K}^{2}\\,\\|r_{K}\\|_{0,K}^{2} \\;+\\; \\sum_{E \\in \\mathcal{E}_{h}^{\\mathrm{int}}} h_{E}\\,\\|J_{E}\\|_{0,E}^{2} \\;+\\; \\sum_{E \\subset \\Gamma_{N}} h_{E}^{\\beta}\\,\\|R_{E}\\|_{0,E}^{2},\n$$\n其中 $\\beta > 0$ 是一个待定指数。由 $\\boldsymbol{A}$ 导出的能量半范数为\n$$\n\\|v\\|_{\\boldsymbol{A}}^{2} := \\int_{\\Omega} \\boldsymbol{A}\\nabla v \\cdot \\nabla v \\, dx.\n$$\n假设在每个单元 $K$ 及其边 $E \\subset \\partial K$ 上，边界迹不等式成立：\n$$\n\\|w\\|_{0,E}^{2} \\le C_{\\mathrm{tr}} \\left( h_{E}^{-1}\\,\\|w\\|_{0,K}^{2} + h_{E}\\,\\|\\nabla w\\|_{0,K}^{2} \\right) \\quad \\text{for all } w \\in H^{1}(K),\n$$\n其中常数 $C_{\\mathrm{tr}}$ 仅依赖于 $\\mathcal{T}_{h}$ 的形状正则性，且与 $h$ 无关。从弱形式出发，并仅使用上述假设，推导 Neumann 边界残差贡献项的缩放比例，以确保可靠性界\n$$\n\\|u - u_{h}\\|_{\\boldsymbol{A}}^{2} \\;\\lesssim\\; \\eta^{2},\n$$\n成立，其中隐藏常数与网格尺寸无关。具体来说，确定指数 $\\beta$ 的值，使得为了通过边界迹不等式获得可靠性界，估计子中的边界残差项必须按 $h_{E}^{\\beta}\\,\\|R_{E}\\|_{0,E}^{2}$ 的形式缩放。你的最终答案必须是 $\\beta$ 的精确值，作为一个数字。", "solution": "我们从模型问题的变分形式开始。精确解 $u \\in H^{1}_{0}(\\Omega; \\Gamma_{D})$ 满足\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla u \\cdot \\nabla v \\, dx \\;=\\; \\int_{\\Omega} f\\, v \\, dx \\;+\\; \\int_{\\Gamma_{N}} g\\, v \\, ds \\quad \\text{for all } v \\in H^{1}_{0}(\\Omega; \\Gamma_{D}).\n$$\nGalerkin 有限元解 $u_{h} \\in V_{h} \\subset H^{1}_{0}(\\Omega; \\Gamma_{D})$ 满足\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla u_{h} \\cdot \\nabla v_{h} \\, dx \\;=\\; \\int_{\\Omega} f\\, v_{h} \\, dx \\;+\\; \\int_{\\Gamma_{N}} g\\, v_{h} \\, ds \\quad \\text{for all } v_{h} \\in V_{h}.\n$$\n令 $e := u - u_{h} \\in H^{1}_{0}(\\Omega; \\Gamma_{D})$ 表示误差。对于任意 $v \\in H^{1}_{0}(\\Omega; \\Gamma_{D})$，将两个弱形式相减可得\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla e \\cdot \\nabla v \\, dx \\;=\\; \\int_{\\Omega} f\\, v \\, dx \\;+\\; \\int_{\\Gamma_{N}} g\\, v \\, ds \\;-\\; \\int_{\\Omega} \\boldsymbol{A}\\nabla u_{h} \\cdot \\nabla v \\, dx.\n$$\n我们现在对每个 $K \\in \\mathcal{T}_{h}$ 进行逐单元分部积分。利用 $\\boldsymbol{A}$ 是分片常数且 $v$ 是连续的，我们得到\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla u_{h} \\cdot \\nabla v \\, dx\n= \\sum_{K \\in \\mathcal{T}_{h}} \\left( - \\int_{K} \\nabla \\cdot (\\boldsymbol{A}\\nabla u_{h})\\, v \\, dx + \\int_{\\partial K} \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n}_{K}\\, v \\, ds \\right).\n$$\n类似地，由于 $u$ 是精确解，我们有\n$$\n\\int_{\\Omega} f\\, v \\, dx = \\sum_{K \\in \\mathcal{T}_{h}} \\int_{K} f\\, v \\, dx, \\qquad \\int_{\\Gamma_{N}} g\\, v \\, ds = \\sum_{E \\subset \\Gamma_{N}} \\int_{E} g\\, v \\, ds.\n$$\n综合这些表达式，并利用内部边上法向通量的抵消，我们得到标准残差分解：\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla e \\cdot \\nabla v \\, dx\n= \\sum_{K \\in \\mathcal{T}_{h}} \\int_{K} \\big( f + \\nabla \\cdot (\\boldsymbol{A}\\nabla u_{h}) \\big)\\, v \\, dx\n+ \\sum_{E \\in \\mathcal{E}_{h}^{\\mathrm{int}}} \\int_{E} \\llbracket \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n}_{E} \\rrbracket \\, v \\, ds\n+ \\sum_{E \\subset \\Gamma_{N}} \\int_{E} \\big( g - \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n} \\big)\\, v \\, ds.\n$$\n记 $r_{K} := f + \\nabla \\cdot (\\boldsymbol{A}\\nabla u_{h})$，$J_{E} := \\llbracket \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n}_{E} \\rrbracket$，以及 $R_{E} := g - \\boldsymbol{A}\\nabla u_{h} \\cdot \\boldsymbol{n}$，我们有\n$$\n\\int_{\\Omega} \\boldsymbol{A}\\nabla e \\cdot \\nabla v \\, dx\n= \\sum_{K \\in \\mathcal{T}_{h}} \\int_{K} r_{K}\\, v \\, dx\n+ \\sum_{E \\in \\mathcal{E}_{h}^{\\mathrm{int}}} \\int_{E} J_{E}\\, v \\, ds\n+ \\sum_{E \\subset \\Gamma_{N}} \\int_{E} R_{E}\\, v \\, ds.\n$$\n可靠性估计是通过将右侧的每一项用局部贡献乘以 $\\|\\nabla v\\|_{0,K}$ 来进行界定，然后对 $v$ 取关于能量半范数 $\\|v\\|_{\\boldsymbol{A}}$ 的上确界来获得的。我们关注 Neumann 边界项。根据 $E$ 上的 Cauchy–Schwarz 不等式，\n$$\n\\left| \\int_{E} R_{E}\\, v \\, ds \\right|\n\\le \\|R_{E}\\|_{0,E}\\, \\|v\\|_{0,E}.\n$$\n在具有边 $E \\subset \\partial K$ 的单元 $K$ 上的边界迹不等式断言，对于每个 $w \\in H^{1}(K)$，\n$$\n\\|w\\|_{0,E}^{2} \\le C_{\\mathrm{tr}} \\left( h_{E}^{-1}\\,\\|w\\|_{0,K}^{2} + h_{E}\\,\\|\\nabla w\\|_{0,K}^{2} \\right).\n$$\n为了将其与能量半范数联系起来，我们在 $K$ 上使用一个局部 Poincaré 不等式，该不等式适用于均值为零或在 $\\partial K$ 的一部分上为零的函数（这是形状正则性和残差可靠性证明中局部测试函数构造的标准推论）：存在一个与 $h$ 无关的常数 $C_{\\mathrm{P}}$，使得\n$$\n\\|v\\|_{0,K} \\le C_{\\mathrm{P}}\\, h_{K}\\, \\|\\nabla v\\|_{0,K}.\n$$\n将此代入迹不等式，并利用对于 $E \\subset \\partial K$ 的形状正则性等价关系 $h_{K} \\simeq h_{E}$，我们得到\n$$\n\\|v\\|_{0,E}^{2}\n\\le C_{\\mathrm{tr}} \\left( h_{E}^{-1}\\, C_{\\mathrm{P}}^{2} h_{E}^{2}\\, \\|\\nabla v\\|_{0,K}^{2} + h_{E}\\, \\|\\nabla v\\|_{0,K}^{2} \\right)\n\\le C\\, h_{E}\\, \\|\\nabla v\\|_{0,K}^{2},\n$$\n其中 $C := C_{\\mathrm{tr}}(C_{\\mathrm{P}}^{2} + 1)$ 与网格尺寸无关。取平方根可得\n$$\n\\|v\\|_{0,E} \\le C^{1/2}\\, h_{E}^{1/2}\\, \\|\\nabla v\\|_{0,K}.\n$$\n因此，\n$$\n\\left| \\int_{E} R_{E}\\, v \\, ds \\right|\n\\le C^{1/2}\\, h_{E}^{1/2}\\, \\|R_{E}\\|_{0,E}\\, \\|\\nabla v\\|_{0,K}.\n$$\n令 $\\alpha_{0}, \\alpha_{1} > 0$ 为 $\\boldsymbol{A}$ 的强制性和有界性常数，即对于所有 $\\xi \\in \\mathbb{R}^{2}$ 和几乎所有 $x$，有 $\\alpha_{0}\\, |\\xi|^{2} \\le \\xi^{\\top}\\boldsymbol{A}(x)\\,\\xi \\le \\alpha_{1}\\, |\\xi|^{2}$。那么\n$$\n\\alpha_{0}\\, \\|\\nabla v\\|_{0,K}^{2} \\le \\int_{K} \\boldsymbol{A}\\nabla v \\cdot \\nabla v \\, dx \\le \\alpha_{1}\\, \\|\\nabla v\\|_{0,K}^{2},\n$$\n所以 $\\|\\nabla v\\|_{0,K} \\lesssim \\|v\\|_{\\boldsymbol{A},K}$，其中 $\\|v\\|_{\\boldsymbol{A},K}^{2} := \\int_{K} \\boldsymbol{A}\\nabla v \\cdot \\nabla v \\, dx$。因此，\n$$\n\\left| \\int_{E} R_{E}\\, v \\, ds \\right| \\lesssim h_{E}^{1/2}\\, \\|R_{E}\\|_{0,E}\\, \\|v\\|_{\\boldsymbol{A},K}.\n$$\n将此界在所有 Neumann 边 $E \\subset \\Gamma_{N}$ 上求和，并应用 Cauchy–Schwarz 不等式，可得\n$$\n\\sum_{E \\subset \\Gamma_{N}} \\left| \\int_{E} R_{E}\\, v \\, ds \\right|\n\\lesssim \\left( \\sum_{E \\subset \\Gamma_{N}} h_{E}\\, \\|R_{E}\\|_{0,E}^{2} \\right)^{1/2} \\left( \\sum_{E \\subset \\Gamma_{N}} \\|v\\|_{\\boldsymbol{A},K(E)}^{2} \\right)^{1/2},\n$$\n其中 $K(E)$ 表示与 $E$ 相邻的单元。根据形状正则网格中边片元的有限重叠性，$\\sum_{E \\subset \\Gamma_{N}} \\|v\\|_{\\boldsymbol{A},K(E)}^{2} \\lesssim \\|v\\|_{\\boldsymbol{A}}^{2}$。因此，\n$$\n\\sum_{E \\subset \\Gamma_{N}} \\left| \\int_{E} R_{E}\\, v \\, ds \\right| \\lesssim \\left( \\sum_{E \\subset \\Gamma_{N}} h_{E}\\, \\|R_{E}\\|_{0,E}^{2} \\right)^{1/2} \\|v\\|_{\\boldsymbol{A}}.\n$$\n对 $v \\in H^{1}_{0}(\\Omega; \\Gamma_{D})$ 且 $v \\neq 0$ 取上确界，并使用能量半范数通过对偶性的刻画，\n$$\n\\|e\\|_{\\boldsymbol{A}} \\;=\\; \\sup_{0 \\neq v \\in H^{1}_{0}(\\Omega; \\Gamma_{D})} \\frac{\\int_{\\Omega} \\boldsymbol{A}\\nabla e \\cdot \\nabla v \\, dx}{\\|v\\|_{\\boldsymbol{A}}},\n$$\n我们看到 Neumann 边界残差对可靠性界的贡献恰好通过量 $\\sum_{E \\subset \\Gamma_{N}} h_{E}\\, \\|R_{E}\\|_{0,E}^{2}$。因此，为确保\n$$\n\\|u - u_{h}\\|_{\\boldsymbol{A}}^{2} \\;\\lesssim\\; \\sum_{K \\in \\mathcal{T}_{h}} h_{K}^{2}\\,\\|r_{K}\\|_{0,K}^{2} \\;+\\; \\sum_{E \\in \\mathcal{E}_{h}^{\\mathrm{int}}} h_{E}\\,\\|J_{E}\\|_{0,E}^{2} \\;+\\; \\sum_{E \\subset \\Gamma_{N}} h_{E}^{\\beta}\\,\\|R_{E}\\|_{0,E}^{2},\n$$\n指数必须为 $\\beta = 1$，这样 Neumann 边项的缩放比例就如同 $h_{E}\\,\\|R_{E}\\|_{0,E}^{2}$。这个选择直接源于迹界在线性形式层面的因子 $h_{E}^{1/2}$，该因子在估计子中平方后变为 $h_{E}$。", "answer": "$$\\boxed{1}$$", "id": "3439898"}, {"introduction": "虽然基于残差的估计量提供了数学上的保证，但像Zienkiewicz-Zhu（ZZ）方法这样的基于恢复的估计量，在实践中由于一种称为“超收敛”的特性，通常更高效、更精确。然而，这种精确性是启发式的，并且可能会失效。这个动手实践问题要求您编写一个数值实验，亲眼见证这种失效。您将在解的光滑极值点附近创建一个非均匀网格场景，这是ZZ估计量的一个已知弱点。[@problem_id:3439906] 通过将ZZ估计量的输出与一个稳健的基于残差的估计量进行比较，您将对这两种方法之间的权衡获得实际的理解，并学会批判性地评估启发式方法在何时可能会产生误导。", "problem": "考虑单位区间上带有齐次狄利克雷边界条件的稳态泊松方程的一维模型问题：寻找一个函数 $u \\in H_0^1(0,1)$，使得对于所有检验函数 $v \\in H_0^1(0,1)$，\n$$\n\\int_{0}^{1} u'(x)\\,v'(x)\\,dx = \\int_{0}^{1} f(x)\\,v(x)\\,dx,\n$$\n其中源项由人造解 $u(x) = \\sin(2\\pi x)$ 给出，因此 $f(x) = -u''(x) = (2\\pi)^2 \\sin(2\\pi x)$。该数据在 $x = \\tfrac{1}{4}$ 和 $x = \\tfrac{3}{4}$ 处产生平滑极值，且在这些点处 $u'(x) = 0$。\n\n设 $u_h$ 表示在给定区间 $[0,1]$ 的一个剖分（网格）上的协调分片线性连续伽辽金有限元近似解。该剖分由单元 $K_i = [x_i, x_{i+1}]$ 组成，节点为 $0 = x_0 < x_1 < \\dots < x_n = 1$，单元长度为 $h_i = x_{i+1} - x_i$。在每个单元 $K_i$ 上，定义分片常数的有限元梯度为 $g_i = \\dfrac{u_h(x_{i+1}) - u_h(x_i)}{h_i}$。考虑两种标准的后验误差估计子：\n\n1. 一种有保证的基于残差的估计子。对每个单元 $K_i$，定义局部残差指示子为\n$$\n\\eta_i^2 = h_i^2 \\int_{K_i} f(x)^2\\,dx + \\frac{1}{2}\\,h_i\\,J_i^2 + \\frac{1}{2}\\,h_i\\,J_{i+1}^2,\n$$\n其中内部节点 $x_j$ 处的内部通量跳跃为 $J_j = g_j - g_{j-1}$（对于 $1 \\le j \\le n-1$），而在狄利克雷边界处 $J_0 = J_n = 0$。全局残差估计子为 $\\eta = \\left(\\sum_{i=0}^{n-1} \\eta_i^2 \\right)^{1/2}$，已知在标准形状正则性条件下，它在一维情况下能以一个与网格无关的常数来界定误差的能量范数。\n\n2. 一种 Zienkiewicz–Zhu (ZZ) 基于恢复的估计子。通过节点平均恢复一个连续的梯度场：对于内部节点 $1 \\le i \\le n-1$，设置\n$$\ng_i^{\\mathrm{rec}} = \\frac{h_{i-1}\\,g_{i-1} + h_i\\,g_i}{h_{i-1} + h_i},\n$$\n在边界处设置 $g_0^{\\mathrm{rec}} = g_0$ 和 $g_n^{\\mathrm{rec}} = g_{n-1}$。在每个单元 $K_i$ 上，将恢复梯度定义为线性插值 $g^{\\mathrm{rec}}(x) = g_i^{\\mathrm{rec}}\\,\\lambda_i(x) + g_{i+1}^{\\mathrm{rec}}\\,\\lambda_{i+1}(x)$，其中局部帽函数为 $\\lambda_i(x) = \\dfrac{x_{i+1} - x}{h_i}$ 和 $\\lambda_{i+1}(x) = \\dfrac{x - x_i}{h_i}$。局部 ZZ 指示子为\n$$\n\\zeta_i^2 = \\int_{K_i} \\left(g^{\\mathrm{rec}}(x) - g_i\\right)^2\\,dx,\n$$\n全局 ZZ 估计子为 $\\zeta = \\left(\\sum_{i=0}^{n-1} \\zeta_i^2 \\right)^{1/2}$。\n\n已知在某些对称性和正则性条件下，ZZ 恢复梯度可以表现出超收敛性，在内部点附近将精度提高一个数量级。然而，在非均匀或非对称网格上，这种超收敛性可能会丧失，尤其是在真梯度为零并改变符号的平滑极值附近。在这种情况下，与有保证的基于残差的估计子相比，ZZ 估计子可能会过度加密（即产生人为的大局部指示子）。\n\n您的任务是构建并分析一个反例，以证明由于超收敛性的丧失，ZZ 估计子在平滑极值附近会发生过度加密。在 $[0,1]$ 上使用以下网格测试套件，并采用人造源项 $f(x) = (2\\pi)^2 \\sin(2\\pi x)$：\n\n- 测试用例 1 (均匀网格，基准)：$n = 64$ 个单元，节点为 $x_i = \\dfrac{i}{n}$，其中 $i = 0,\\dots,64$。\n\n- 测试用例 2 (在极值点 $x^\\ast = \\tfrac{1}{4}$ 附近的交替扰动片区)：$n = 64$，基础单元尺寸为 $h = \\dfrac{1}{n}$。令 $i^\\ast = \\lfloor n x^\\ast \\rfloor = 16$。对于包含十个单元的片区 $i \\in \\{i^\\ast-5, i^\\ast-4, \\dots, i^\\ast+4\\}$，对于偶数偏移量 $(i - (i^\\ast-5))$ 指定交替的长度 $h_i = 0.3\\,h$，对于奇数偏移量则为 $h_i = 1.7\\,h$；对于所有其他单元，使用 $h_i = h$。这种构造保持了总长度为 1。\n\n- 测试用例 3 (在 $x^\\ast = \\tfrac{1}{4}$ 附近的强梯度对称片区)：$n = 64$，基础尺寸为 $h = \\dfrac{1}{n}$。令 $m = 21$ 和 $r = 2$。定义一个以索引 $i^\\ast$ 为中心的包含 $m$ 个单元的片区，其长度为\n$$\nh_i = a\\,r^{\\left|i - i^\\ast\\right|}, \\quad \\text{对于 } i \\in \\{i^\\ast - \\tfrac{m-1}{2}, \\dots, i^\\ast + \\tfrac{m-1}{2}\\},\n$$\n其中 $a$ 的选择使得这 $m$ 个长度的总和等于 $m\\,h$，即 $a = \\dfrac{m\\,h}{\\sum_{j=-\\frac{m-1}{2}}^{\\frac{m-1}{2}} r^{|j|}}$。在该片区之外，设置 $h_i = h$。这会产生一个高度渐变的网格，其中最小的单元位于极值点。\n\n对于每个测试用例：\n- 装配分片线性有限元解 $u_h$。\n- 按上述定义计算单元残差估计子 $\\eta_i$ 和 ZZ 估计子 $\\zeta_i$。\n- 确定“极值单元”索引 $i_{\\mathrm{ext}}$，其中心点最接近 $x^\\ast = 0.25$。确定一个“远离单元”索引 $i_{\\mathrm{far}}$，其中心点最接近 $x = 0.6$。\n- 计算比率 $R_{\\mathrm{ext}} = \\dfrac{\\zeta_{i_{\\mathrm{ext}}}}{\\eta_{i_{\\mathrm{ext}}}}$ 和 $R_{\\mathrm{far}} = \\dfrac{\\zeta_{i_{\\mathrm{far}}}}{\\eta_{i_{\\mathrm{far}}}}$。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个条目本身是一个包含两个条目的列表 $[R_{\\mathrm{ext}}, R_{\\mathrm{far}}]$。例如，输出格式必须为：\n$$\n[\\,[R_{\\mathrm{ext}}^{(1)},R_{\\mathrm{far}}^{(1)}],[R_{\\mathrm{ext}}^{(2)},R_{\\mathrm{far}}^{(2)}],[R_{\\mathrm{ext}}^{(3)},R_{\\mathrm{far}}^{(3)}]\\,].\n$$\n所有值都是纯实数；不适用任何物理单位或角度单位。该测试套件旨在揭示异常行为：在测试用例 2 和测试用例 3 中，极值点附近的比率应显著超过远离极值点的比率，这与基准的均匀网格情况形成对比。", "solution": "所述问题是有效的。它在科学上基于偏微分方程的数值分析，特别是有限元法和后验误差估计。定义在数学上是精确的，测试用例是明确指定的，所需的计算在计算上是可行的。不存在矛盾、歧义或事实错误。因此，我们可以着手求解。\n\n问题的核心是数值求解一维泊松方程，然后计算并比较两种类型的后验误差指示子在不同网格配置下的表现。目标是展示 Zienkiewicz-Zhu (ZZ) 误差估计子一个已知的缺陷，即在非均匀网格上，当其底层的超收敛性质丧失时，它在平滑极值点附近倾向于过度报告误差（过度加密）。\n\n整个过程可以分解为以下步骤，并将对三个测试用例中的每一个实施这些步骤。\n\n1.  **网格生成：** 对于每个测试用例，我们首先构建计算网格，即一组 $n+1$ 个节点坐标 $x_0, x_1, \\dots, x_n$，它们定义了 $n$ 个单元 $K_i = [x_i, x_{i+1}]$。单元长度表示为 $h_i = x_{i+1} - x_i$。问题指定了 $n=64$，并为三种情况（均匀网格、局部扰动网格和局部渐变网格）分别提供了构造单元长度向量 $\\{h_i\\}_{i=0}^{n-1}$ 的明确规则。\n\n2.  **有限元离散化：** 我们使用带有分片线性基函数（$P_1$ 单元）的连续伽辽金法来求解该问题。弱形式为：求 $u \\in H_0^1(0,1)$，使得对所有 $v \\in H_0^1(0,1)$，有 $a(u,v) = L(v)$，其中双线性形式为 $a(u,v) = \\int_0^1 u'(x)v'(x)dx$，线性泛函为 $L(v) = \\int_0^1 f(x)v(x)dx$。\n\n    有限元近似解 $u_h(x)$ 表示为节点基（帽）函数 $\\phi_j(x)$ 的线性组合：$u_h(x) = \\sum_{j=0}^{n} U_j \\phi_j(x)$，其中 $U_j = u_h(x_j)$ 是待确定的节点值。施加齐次狄利克雷边界条件 $u(0)=u(1)=0$ 可设定 $U_0 = 0$ 和 $U_n = 0$。\n\n    将此代入弱形式，并对每个内部基函数 $\\phi_k(x)$（其中 $k=1, \\dots, n-1$）进行测试，得到一个关于内部节点值向量 $\\mathbf{U} = [U_1, \\dots, U_{n-1}]^T$ 的线性代数方程组 $A \\mathbf{U} = \\mathbf{b}$。\n\n    $(n-1) \\times (n-1)$ 的刚度矩阵 $A$ 是对称、正定且三对角的，其元素由下式给出：\n    $$\n    A_{k,j} = a(\\phi_j, \\phi_k) = \\int_0^1 \\phi_j'(x) \\phi_k'(x) dx.\n    $$\n    对于 $k, j \\in \\{1, \\dots, n-1\\}$，这得出：\n    $$\n    A_{k,k} = \\frac{1}{h_{k-1}} + \\frac{1}{h_k}, \\quad A_{k, k-1} = -\\frac{1}{h_{k-1}} \\text{ for } k>1, \\quad A_{k, k+1} = -\\frac{1}{h_k} \\text{ for } k<n-1.\n    $$\n    载荷向量 $\\mathbf{b}$ 的元素为 $b_k = \\int_0^1 f(x)\\phi_k(x)dx$。对于 $k=1, \\dots, n-1$，这需要计算\n    $$\n    b_k = \\int_{x_{k-1}}^{x_k} f(x) \\frac{x-x_{k-1}}{h_{k-1}} dx + \\int_{x_k}^{x_{k+1}} f(x) \\frac{x_{k+1}-x}{h_k} dx.\n    $$\n    这些积分使用数值求积（例如高斯求积）来计算。\n\n3.  **估计子计算：** 求解线性系统得到节点值 $\\mathbf{U}$ 后，我们便拥有了有限元解 $u_h(x)$。然后我们计算每个单元 $K_i$ 上的有限元梯度 $g_i = (U_{i+1}-U_i)/h_i$。\n    - **基于残差的估计子 $\\eta_i$：**\n        - 通量跳跃 $J_j = g_j - g_{j-1}$ 在每个内部节点 $x_j$ 处计算。在边界处 $J_0 = J_n = 0$。\n        - 单元指示子 $\\eta_i^2$ 由问题中给出的公式计算，需要数值计算 $\\int_{K_i} f(x)^2 dx$。\n    - **ZZ 估计子 $\\zeta_i$：**\n        - 在每个内部节点 $x_i$ 处计算恢复梯度 $g_i^{\\mathrm{rec}}$，它是由相邻单元的梯度进行长度加权平均得到的。\n        - 在边界节点处，$g_0^{\\mathrm{rec}}$ 和 $g_n^{\\mathrm{rec}}$ 如问题所述进行设置（一种简单的外推）。\n        - 在每个单元 $K_i$ 内，恢复梯度场 $g^{\\mathrm{rec}}(x)$ 是通过对节点值 $g_i^{\\mathrm{rec}}$ 和 $g_{i+1}^{\\mathrm{rec}}$ 进行线性插值得到的。\n        - 局部指示子 $\\zeta_i^2 = \\int_{K_i} (g^{\\mathrm{rec}}(x) - g_i)^2 dx$ 可以被精确积分，因为被积函数是一个二次多项式。\n\n4.  **比率分析：** 对于每个测试用例，我们识别出中心最接近 $x=0.25$（极值）和 $x=0.6$（远离）的单元。然后，我们计算并存储每个单元的估计子比率 $R = \\zeta_i / \\eta_i$。\n\n5.  **输出：** 最后，我们将所有测试用例的比率对 `[R_ext, R_far]` 收集起来，并按照问题指定的格式 `[[R_ext^(1),R_far^(1)],[R_ext^(2),R_far^(2)],[R_ext^(3),R_far^(3)]]` 打印。\n\n通过执行这个过程，我们将能够数值地验证这一论点：在均匀网格（测试用例1）上，两种估计子的比率应该大致相当，这反映了 ZZ 估计子的渐近精确性。然而，在非均匀网格（测试用例2和3）上，极值点附近的超收敛性会丧失，导致 $g_i$ 和 $g^{\\mathrm{rec}}$ 之间出现很大的伪差异，从而使 $\\zeta_{i_{\\mathrm{ext}}}$ 相对于 $\\eta_{i_{\\mathrm{ext}}}$ 被夸大。因此，我们预期 $R_{\\mathrm{ext}}^{(2)} \\gg R_{\\mathrm{far}}^{(2)}$ 和 $R_{\\mathrm{ext}}^{(3)} \\gg R_{\\mathrm{far}}^{(3)}$，而 $R_{\\mathrm{ext}}^{(1)} \\approx R_{\\mathrm{far}}^{(1)}$。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print the results.\n    \"\"\"\n    \n    # Define source term f(x) and its square\n    f = lambda x: (2 * np.pi)**2 * np.sin(2 * np.pi * x)\n    f_squared = lambda x: f(x)**2\n    \n    n = 64\n    h_base = 1.0 / n\n    x_star_ext = 0.25\n    x_star_far = 0.6\n\n    # Test Case 1: Uniform mesh\n    h_vec1 = np.full(n, h_base)\n\n    # Test Case 2: Alternating perturbed patch\n    h_vec2 = np.full(n, h_base)\n    i_star = int(np.floor(n * x_star_ext))  # 16\n    patch_start_idx = i_star - 5 # 11\n    patch_end_idx = i_star + 4   # 20\n    for i in range(patch_start_idx, patch_end_idx + 1):\n        offset = i - patch_start_idx\n        if offset % 2 == 0:\n            h_vec2[i] = 0.3 * h_base\n        else:\n            h_vec2[i] = 1.7 * h_base\n    # Rescale to ensure total length is exactly 1\n    h_vec2 *= 1.0 / np.sum(h_vec2)\n\n    # Test Case 3: Strongly graded symmetric patch\n    h_vec3 = np.full(n, h_base)\n    i_star = int(np.floor(n * x_star_ext)) # 16\n    m = 21\n    r = 2.0\n    patch_half_width = (m - 1) // 2 # 10\n    patch_start_idx = i_star - patch_half_width # 6\n    patch_end_idx = i_star + patch_half_width   # 26\n    \n    # Sum for scaling factor 'a'\n    sum_geom = 1.0 + 2.0 * np.sum([r**j for j in range(1, patch_half_width + 1)])\n    a = (m * h_base) / sum_geom\n    \n    for i in range(patch_start_idx, patch_end_idx + 1):\n        h_vec3[i] = a * (r**np.abs(i - i_star))\n    \n    # Rescale to ensure total length is exactly 1\n    h_vec3 *= 1.0 / np.sum(h_vec3)\n\n    test_cases = [h_vec1, h_vec2, h_vec3]\n    \n    results = []\n    for h_vec in test_cases:\n        ratios = _compute_for_case(n, h_vec, f, f_squared, x_star_ext, x_star_far)\n        results.append(ratios)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _compute_for_case(n, h_vec, f, f_squared, x_star_ext, x_star_far):\n    \"\"\"\n    Computes the estimator ratios for a single mesh configuration.\n    \"\"\"\n    # 1. Mesh Generation\n    x_nodes = np.zeros(n + 1)\n    x_nodes[1:] = np.cumsum(h_vec)\n\n    # 2. Finite Element Solution\n    # Assemble stiffness matrix A and load vector b for interior nodes\n    A_banded = np.zeros((3, n - 1))\n    b = np.zeros(n - 1)\n\n    # Main diagonal\n    A_banded[1, :] = 1.0 / h_vec[:-1] + 1.0 / h_vec[1:]\n    # Upper diagonal\n    A_banded[0, 1:] = -1.0 / h_vec[1:-1]\n    # Lower diagonal\n    A_banded[2, :-1] = -1.0 / h_vec[1:-1]\n\n    # Assemble load vector b\n    for k in range(1, n):\n        # Integral over [x_{k-1}, x_k]\n        integrand1 = lambda x: f(x) * (x - x_nodes[k-1]) / h_vec[k-1]\n        b[k-1] += quad(integrand1, x_nodes[k-1], x_nodes[k])[0]\n        # Integral over [x_k, x_{k+1}]\n        integrand2 = lambda x: f(x) * (x_nodes[k+1] - x) / h_vec[k]\n        b[k-1] += quad(integrand2, x_nodes[k], x_nodes[k+1])[0]\n\n    # Solve for interior nodal values U\n    U_interior = solve_banded((1, 1), A_banded, b)\n    U = np.concatenate(([0], U_interior, [0]))\n\n    # 3. Compute Estimators\n    # FEM gradient g_i on each element K_i\n    g = (U[1:] - U[:-1]) / h_vec\n    \n    # --- Residual Estimator ---\n    eta_sq = np.zeros(n)\n    # Flux jumps J_j at each interior node x_j\n    Jumps = np.zeros(n + 1)\n    Jumps[1:n] = g[1:] - g[:-1]\n    \n    for i in range(n):\n        # Element residual term\n        term1 = h_vec[i]**2 * quad(f_squared, x_nodes[i], x_nodes[i+1])[0]\n        # Jump residual term\n        term2 = 0.5 * h_vec[i] * (Jumps[i]**2 + Jumps[i+1]**2)\n        eta_sq[i] = term1 + term2\n\n    # --- ZZ Estimator ---\n    zeta_sq = np.zeros(n)\n    # Recovered gradient g_rec at nodes\n    g_rec = np.zeros(n + 1)\n    g_rec[0] = g[0]\n    g_rec[n] = g[n-1]\n    g_rec[1:n] = (h_vec[:-1] * g[:-1] + h_vec[1:] * g[1:]) / (h_vec[:-1] + h_vec[1:])\n\n    for i in range(n):\n        # Integral of (g_rec(x) - g_i)^2 over K_i\n        A = g_rec[i+1] - g_rec[i]\n        B = g_rec[i] - g[i]\n        zeta_sq[i] = h_vec[i] * (A**2 / 3.0 + A * B + B**2)\n\n    # 4. Analysis\n    midpoints = (x_nodes[:-1] + x_nodes[1:]) / 2.0\n    i_ext = np.argmin(np.abs(midpoints - x_star_ext))\n    i_far = np.argmin(np.abs(midpoints - x_star_far))\n    \n    zeta_i_ext = np.sqrt(zeta_sq[i_ext])\n    eta_i_ext = np.sqrt(eta_sq[i_ext])\n    \n    zeta_i_far = np.sqrt(zeta_sq[i_far])\n    eta_i_far = np.sqrt(eta_sq[i_far])\n    \n    R_ext = zeta_i_ext / eta_i_ext\n    R_far = zeta_i_far / eta_i_far\n\n    return [R_ext, R_far]\n\nsolve()\n```", "id": "3439906"}, {"introduction": "基于残差和基于恢复的估计背后的理念，其应用远不止于为偏微分方程加密网格，它们代表了自适应计算的通用策略。本练习将这两种理念应用于一个不同的挑战：使用自适应求积法精确计算一个定积分。您将实现一个由局部误差指示器（求积法则的“残差”）驱动的自适应方案，以及另一个由被积函数的光滑梯度（一种“恢复”方法）驱动的方案。[@problem_id:3439836] 这种实践展示了这些概念的多功能性，鼓励您不将它们视为固定的公式，而是看作有效分配计算资源的灵活解题范式。", "problem": "考虑一维空间中的标量椭圆偏微分方程 (PDE) 模型，其能量密度被积函数无需求解控制方程即可进行分析。设精确状态由定义在区间 $[0,1]$ 上的光滑函数 $u(x) = \\sin(20\\pi x) + x^2$ 定义，并设 $a(x)$ 为一个给定的正系数函数，用于模拟空间变化的材料属性。将能量密度被积函数定义为 $g(x) = a(x)\\left(u'(x)\\right)^2$，其中 $u'(x)$ 是 $u(x)$ 关于 $x$ 的导数。目标是使用自适应求积法则精确近似能量积分 $I = \\int_0^1 g(x)\\,dx$。必须实现两种自适应策略：\n\n- 基于残差的自适应：使用分层的两点高斯-勒让德求积指示器。在每个子区间 $K = [x_i,x_{i+1}]$ 上，使用两点高斯-勒让德法则计算一个粗略求积近似值 $Q_K$，并通过将 $K$ 分成两个相等的一半并在每半上应用相同的两点高斯-勒让德法则求和，来计算一个精细化近似值 $Q_{K}^{\\mathrm{ref}}$。将局部基于残差的指示器定义为 $r_K = \\left|Q_{K}^{\\mathrm{ref}} - Q_K\\right|$。从一个均匀剖分开始，迭代地分割具有最大 $r_K$ 的子区间，直到达到固定的子区间数量。最终的求积值是在自适应网格上对所有子区间应用两点高斯-勒让德法则求和的结果。\n\n- 基于恢复的自适应：使用梯度恢复来驱动求积节点的重新分布。在包含 $M$ 个点的均匀网格上对 $g(x)$ 进行采样。通过中心差分（在边界处使用单边差分）计算 $g'(x)$ 的离散近似。通过将 $\\left|g'(x)\\right|$ 与一个奇数宽度为 $w$ 的均匀平均核进行卷积，恢复出平滑后的梯度幅值，从而获得一个正密度函数 $\\rho(x)$。通过等分布原则构建节点重分布：选择 $N$ 个子区间的端点 $x_0=0,x_1,\\dots,x_N=1$，使得 $\\rho(x)$ 的累积积分 $S(x)=\\int_0^x \\rho(s)\\,ds$ 被等分，即对 $i=0,\\dots,N$ 满足 $S(x_i)=\\frac{i}{N}S(1)$。在这个重分布的网格上，对每个子区间使用两点高斯-勒让德法则计算能量积分。最终的求积值是所有子区间结果的总和。\n\n您的推导和算法设计应基于数值求积、高斯-勒让德法则、分层误差指示器以及使用离散微分和平滑的梯度恢复等基本定义。除这些原则外，不得假设任何预先推导的结果。\n\n作为参考，使用一种高精度方法计算积分 $I$，确保绝对误差容限不超过 $10^{-12}$。如果 $a(x)$ 是分段定义的且跳跃点位置已知，则在这些跳跃点处分割定义域，并将各段上的高精度积分值相加。如果 $a(x)$ 是光滑的，则直接在 $[0,1]$ 上积分。\n\n实现以下系数函数 $a(x)$ 的测试套件，每个函数都配有一个固定的总子区间数 $N$、一个初始均匀剖分大小 $N_0$、一个恢复采样大小 $M$ 和一个平滑窗口宽度 $w$：\n\n- 测试用例1：具有中等跳跃的分段常数系数。设 $a(x)=v_1$ 对于 $x\\in[0,e_1)$，$a(x)=v_2$ 对于 $x\\in[e_1,e_2)$，以及 $a(x)=v_3$ 对于 $x\\in[e_2,1]$，其中 $(e_1,e_2)=(0.3,0.6)$ 且 $(v_1,v_2,v_3)=(1.0,3.0,0.5)$。使用 $N=64$，$N_0=8$，$M=1001$ 和 $w=31$。\n\n- 测试用例2：具有强跳跃对比度的分段常数系数。设 $(e_1,e_2)=(0.3,0.6)$ 且 $(v_1,v_2,v_3)=(1.0,50.0,0.1)$。使用 $N=64$，$N_0=8$，$M=1001$ 和 $w=31$。\n\n- 测试用例3：具有窄高斯边界层的光滑系数。设 $a(x)=1 + A \\exp\\left(-\\left(\\frac{x-c}{\\sigma}\\right)^2\\right)$，其中 $A=9.0$，$c=0.84$ 且 $\\sigma=0.02$。使用 $N=64$，$N_0=8$，$M=2001$ 和 $w=41$。\n\n- 测试用例4：光滑振荡系数。设 $a(x)=1 + \\alpha \\sin(80\\pi x)$，其中 $\\alpha=0.8$。使用 $N=64$，$N_0=8$，$M=2001$ 和 $w=41$。\n\n您的程序必须：\n\n- 对于每个测试用例，构建 $g(x)=a(x)\\left(u'(x)\\right)^2$，其中 $u'(x)=20\\pi\\cos(20\\pi x) + 2x$。\n\n- 计算积分 $I$ 的高精度参考值 $I_{\\mathrm{ref}}$。\n\n- 使用 $N$ 个子区间计算基于残差的自适应求积近似值 $I_{\\mathrm{res}}$，从 $N_0$ 个均匀子区间开始，不断分割具有最大残差指示器 $r_K$ 的子区间，直到达到预算 $N$。\n\n- 通过使用恢复的梯度幅值密度 $\\rho(x)$（参数 $M$ 和 $w$ 按各测试指定）重新分布节点，然后在重分布的网格上使用两点高斯-勒让德法则进行积分，从而计算基于恢复的自适应求积近似值 $I_{\\mathrm{rec}}$。\n\n- 对于每个测试用例，将比率 $R=\\frac{\\left|I_{\\mathrm{res}}-I_{\\mathrm{ref}}\\right|}{\\left|I_{\\mathrm{rec}}-I_{\\mathrm{ref}}\\right|}$ 作为浮点数报告。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含所有测试用例的比率 $R$，格式为方括号内以逗号分隔的列表（例如，“[$r_1$,$r_2$,$r_3$,$r_4$]”），其中每个 $r_i$ 是对应于测试用例 $i$ 的比率 $R$。\n\n本问题不涉及物理单位，角度（若有）以弧度表示。测试套件中的所有数值参数均为无量纲。程序必须完全自包含，且不得读取外部输入。", "solution": "该问题要求实现并比较两种自适应求积策略，用于计算能量积分 $I = \\int_0^1 g(x)\\,dx$，其中被积函数定义为 $g(x) = a(x)\\left(u'(x)\\right)^2$。函数 $u(x)$ 已给定，并为不同测试用例指定了系数 $a(x)$ 的几种形式。\n\n首先，我们定义核心数学组件。状态函数为 $u(x) = \\sin(20\\pi x) + x^2$。其关于 $x$ 的导数为 $u'(x) = 20\\pi\\cos(20\\pi x) + 2x$。因此，被积函数为 $g(x) = a(x)(20\\pi\\cos(20\\pi x) + 2x)^2$。\n\n两种自适应策略的数值积分均基于两点高斯-勒让德求积法则。对于区间 $[x_L, x_R]$（长度为 $h = x_R - x_L$）上的一个通用函数 $f(x)$，该法则由以下公式给出：\n$$\nQ(f, [x_L, x_R]) = \\frac{h}{2} \\left[ f\\left(\\frac{x_L+x_R}{2} - \\frac{h}{2\\sqrt{3}}\\right) + f\\left(\\frac{x_L+x_R}{2} + \\frac{h}{2\\sqrt{3}}\\right) \\right]\n$$\n该法则对最高为3次的多项式是精确的。\n\n为评估自适应方法的准确性，我们计算了积分的高精度参考值 $I_{\\mathrm{ref}}$。我们使用一个标准的数值求积库程序（具体为 `scipy.integrate.quad`），其绝对误差容限要求非常严格，为 $10^{-12}$。对于系数 $a(x)$ 是分段常数的测试用例，积分域 $[0, 1]$ 在不连续点处被分割。这可以防止积分器试图处理跳跃，否则会降低其准确性和性能。总积分是这些子域上积分的总和。对于光滑的 $a(x)$，则直接在 $[0, 1]$ 上计算积分。\n\n该问题指定了两种截然不同的自适应策略：\n\n**1. 基于残差的自适应**\n\n这种方法通常称为h-自适应，它通过在估计误差较高的区域增加节点来加密网格。该过程是迭代的：\n- 从覆盖 $[0, 1]$ 的 $N_0$ 个子区间的粗糙均匀网格开始。\n- 在每次迭代中，对于当前网格中的每个子区间 $K = [x_i, x_{i+1}]$，我们计算一个局部误差指示器。该指示器基于比较一个粗略和一个精细化的求积近似。\n    - 粗略近似 $Q_K$：在整个子区间 $K$ 上应用两点高斯-勒让德法则。\n    - 精细化近似 $Q_{K}^{\\mathrm{ref}}$：在 $K$ 的中点 $x_m = (x_i+x_{i+1})/2$ 处将其分割为两半。对每一半 $[x_i, x_m]$ 和 $[x_m, x_{i+1}]$ 应用两点法则，然后将结果相加。\n- 局部误差指示器定义为差值的绝对值：$r_K = \\left|Q_{K}^{\\mathrm{ref}} - Q_K\\right|$。该值可作为真实局部积分误差的代理。\n- 找出具有最大指示器 $r_{K^*}$ 的子区间 $K^*$。\n- 通过二等分 $K^*$ 来加密网格，即用其两半替换它。这将使子区间的总数增加一。\n- 这个识别误差最大子区间并进行分割的过程会重复 $N - N_0$ 次，直到最终网格包含总共 $N$ 个子区间。\n- 最终的近似值 $I_{\\mathrm{res}}$ 是通过对最终自适应网格中的所有 $N$ 个子区间上的粗略（两点）求积值求和得到的：$I_{\\mathrm{res}} = \\sum_{K \\in \\mathcal{T}_N} Q_K$。\n\n**2. 基于恢复的自适应**\n\n这种方法是r-自适应的一种形式，它不改变节点数量，而是重新定位节点以更好地捕捉被积函数的特征。这是一个一次性过程，而非迭代加密。\n- **步骤1：梯度采样。** 首先，在横跨 $[0, 1]$ 的 $M$ 个点的精细均匀网格 $\\{z_j\\}_{j=0}^{M-1}$ 上对被积函数 $g(x)$ 进行采样。然后，使用有限差分在这些点上计算其导数 $g'(x)$ 的近似值。内部点使用中心差分，而边界点 $x=0$ 和 $x=1$ 则使用单边差分（前向/后向）。\n- **步骤2：密度形成。** 目标是创建一个正密度函数 $\\rho(x)$，在网格应该加密的地方该函数值较大。$g(x)$ 变化迅速的区域是加密的候选区域。这种密度的一个常见选择是基于梯度的幅值 $|g'(x)|$。为产生更平滑的密度并减少数值噪声的影响，将离散值 $|g'(z_j)|$ 与指定奇数宽度 $w$ 的均匀平均核进行卷积。此操作对应于一个移动平均滤波器，产生平滑后的密度 $\\rho(z_j)$。\n- **步骤3：通过等分布进行节点重分布。** 此方法的核心是等分布原则，其目的是将一种“难度”度量均匀地分配到所有子区间中。在这里，难度由密度函数 $\\rho(x)$ 的积分表示。我们首先计算密度的累积积分 $S(x) = \\int_0^x \\rho(s)\\,ds$。这是通过在采样密度值 $\\rho(z_j)$ 上使用梯形法则进行数值计算的。设总积分为 $S_{\\mathrm{total}} = S(1)$。然后，我们将范围 $[0, S_{\\mathrm{total}}]$ 分割成 $N$ 个相等的段。选择新的网格节点 $\\{x_i\\}_{i=0}^N$，使它们映射到累积密度空间中的这些等距点上：\n$$S(x_i) = \\frac{i}{N} S_{\\mathrm{total}} \\quad \\text{for } i=0, 1, \\dots, N$$\n在实践中，这些新的节点位置 $x_i$ 是通过使用线性插值对离散累积函数 $S(z_j)$ 进行反算来找到的。\n- **步骤4：最终积分。** 有了新的非均匀网格 $\\{x_i\\}_{i=0}^N$，最终的近似值 $I_{\\mathrm{rec}}$ 是通过对 $N$ 个重分布的子区间 $[x_i, x_{i+1}]$ 中的每一个应用两点高斯-勒让德法则求和来计算的。\n\n最后，对于每个测试用例，通过计算两种方法相对于参考积分的绝对误差之比来比较它们的性能：\n$$\nR = \\frac{\\left|I_{\\mathrm{res}} - I_{\\mathrm{ref}}\\right|}{\\left|I_{\\mathrm{rec}} - I_{\\mathrm{ref}}\\right|}\n$$\n比率 $R  1$ 表明，对于给定的参数，基于恢复的方法比基于残差的方法得出了更准确的结果，反之亦然。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases for comparing adaptive quadrature methods.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"id\": 1,\n            \"a_func\": lambda x: 1.0 if x  0.3 else (3.0 if x  0.6 else 0.5),\n            \"a_type\": \"piecewise\",\n            \"jumps\": [0.3, 0.6],\n            \"N\": 64, \"N0\": 8, \"M\": 1001, \"w\": 31\n        },\n        {\n            \"id\": 2,\n            \"a_func\": lambda x: 1.0 if x  0.3 else (50.0 if x  0.6 else 0.1),\n            \"a_type\": \"piecewise\",\n            \"jumps\": [0.3, 0.6],\n            \"N\": 64, \"N0\": 8, \"M\": 1001, \"w\": 31\n        },\n        {\n            \"id\": 3,\n            \"a_func\": lambda x: 1.0 + 9.0 * np.exp(-((x - 0.84) / 0.02)**2),\n            \"a_type\": \"smooth\",\n            \"jumps\": [],\n            \"N\": 64, \"N0\": 8, \"M\": 2001, \"w\": 41\n        },\n        {\n            \"id\": 4,\n            \"a_func\": lambda x: 1.0 + 0.8 * np.sin(80 * np.pi * x),\n            \"a_type\": \"smooth\",\n            \"jumps\": [],\n            \"N\": 64, \"N0\": 8, \"M\": 2001, \"w\": 41\n        }\n    ]\n\n    results = []\n\n    # Common functions and constants\n    u_prime = lambda x: 20 * np.pi * np.cos(20 * np.pi * x) + 2 * x\n    sqrt3_inv = 1.0 / np.sqrt(3.0)\n\n    def gauss2(func, a, b):\n        h = b - a\n        mid = (a + b) / 2.0\n        p1 = mid - (h / 2.0) * sqrt3_inv\n        p2 = mid + (h / 2.0) * sqrt3_inv\n        return (h / 2.0) * (func(p1) + func(p2))\n\n    for case in test_cases:\n        N = case[\"N\"]\n        N0 = case[\"N0\"]\n        M = case[\"M\"]\n        w = case[\"w\"]\n        \n        # Ensure a_func is vectorized for numpy arrays\n        a_func_case = np.vectorize(case[\"a_func\"])\n        g = lambda x: a_func_case(x) * (u_prime(x)**2)\n\n        # 1. Compute High-Accuracy Reference Integral I_ref\n        I_ref = 0.0\n        if case[\"a_type\"] == \"piecewise\":\n            points = [0] + case[\"jumps\"] + [1]\n            for i in range(len(points) - 1):\n                res, _ = integrate.quad(g, points[i], points[i+1], epsabs=1e-13, limit=200)\n                I_ref += res\n        else:\n            I_ref, _ = integrate.quad(g, 0, 1, epsabs=1e-13, limit=200)\n\n        # 2. Compute Residual-based Adaptive Quadrature I_res\n        mesh = np.linspace(0, 1, N0 + 1)\n        intervals = list(zip(mesh[:-1], mesh[1:]))\n        \n        num_refinements = N - N0\n        for _ in range(num_refinements):\n            indicators = []\n            for i, (a, b) in enumerate(intervals):\n                q_coarse = gauss2(g, a, b)\n                mid = (a + b) / 2.0\n                q_refined = gauss2(g, a, mid) + gauss2(g, mid, b)\n                indicators.append(abs(q_refined - q_coarse))\n            \n            idx_to_split = np.argmax(indicators)\n            a, b = intervals.pop(idx_to_split)\n            mid = (a + b) / 2.0\n            intervals.insert(idx_to_split, (mid, b))\n            intervals.insert(idx_to_split, (a, mid))\n\n        I_res = sum(gauss2(g, a, b) for a, b in intervals)\n\n        # 3. Compute Recovery-based Adaptive Quadrature I_rec\n        # Step A: Sample and Differentiate\n        z = np.linspace(0, 1, M)\n        g_vals = g(z)\n        dg_dx = np.gradient(g_vals, z[1] - z[0])\n\n        # Step B: Smooth to get Density\n        abs_dg_dx = np.abs(dg_dx)\n        kernel = np.ones(w) / w\n        rho = np.convolve(abs_dg_dx, kernel, mode='same')\n        \n        # Add small constant to prevent rho from being zero everywhere\n        if np.all(rho  1e-9):\n            rho += 1e-9\n\n        # Step C: Equidistribution\n        S = integrate.cumulative_trapezoid(rho, z, initial=0)\n        S_total = S[-1]\n        target_S_vals = np.linspace(0, S_total, N + 1)\n        \n        # Invert S(x) to find new mesh points x_i\n        x_new = np.interp(target_S_vals, S, z)\n        x_new[0], x_new[-1] = 0.0, 1.0 # Enforce boundaries\n\n        # Step D: Integrate on New Mesh\n        I_rec = sum(gauss2(g, x_new[i], x_new[i+1]) for i in range(N))\n        \n        # 4. Compute Ratio\n        err_res = abs(I_res - I_ref)\n        err_rec = abs(I_rec - I_ref)\n        \n        if err_rec  1e-15:  # Avoid division by zero\n            # If both are nearly zero, ratio is 1. If only denominator is, ratio is large.\n            ratio = 1.0 if err_res  1e-15 else np.inf\n        else:\n            ratio = err_res / err_rec\n        \n        results.append(ratio)\n\n    # Final print statement\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3439836"}]}