{"hands_on_practices": [{"introduction": "在混合有限元方法中，某些速度-压力单元对的选择会导致数值不稳定性，其根源在于违反了 Ladyzhenskaya–Babuška–Brezzi (LBB) 条件。本练习旨在揭示一个经典不稳定现象的根本原因：棋盘格压力模式。通过为 $Q_1-Q_1$ 等阶单元构造一个非零的离散压力场，并证明其对于任何离散速度场，散度耦合项 $b(v_h, q_h)$ 均为零，你将深刻理解 LBB 条件失效的具体机制，并为该单元对的不稳定性提供一个严格的数学证明。[@problem_id:3414772]", "problem": "考虑在方形区域 $\\Omega=(0,1)^{2}$ 上的不可压缩斯托克斯方程，速度满足齐次狄利克雷边界条件。设 $\\mathcal{T}_{h}$ 是一个均匀、轴对齐、协调的四边形网格，有 $n_{x}\\times n_{y}$ 个顶点，其中 $n_{x}$ 和 $n_{y}$ 是偶数，网格尺寸为 $h=1/\\max\\{n_{x}-1,n_{y}-1\\}$。设 $S_{h}$ 表示 $\\mathcal{T}_{h}$ 上的连续分片双线性 ($Q_{1}$) 函数构成的标量空间。定义离散速度和压力空间为\n$$\nV_{h}=\\left\\{v_{h}=(u_{h},w_{h}) : u_{h}\\in S_{h},\\ w_{h}\\in S_{h},\\ v_{h}|_{\\partial\\Omega}=0\\right\\},\\qquad\nQ_{h}=\\left\\{q_{h}\\in S_{h} : \\int_{\\Omega} q_{h}\\,dx=0\\right\\}。\n$$\n混合格式通过双线性形式将速度和压力耦合起来\n$$\nb(v_{h},q_{h})=-\\int_{\\Omega} q_{h}\\,\\nabla\\cdot v_{h}\\,dx。\n$$\nLadyzhenskaya–Babuška–Brezzi (LBB) 稳定性条件要求存在一个离散的 inf–sup 常数\n$$\n\\beta_{h}=\\inf_{q_{h}\\in Q_{h}\\setminus\\{0\\}}\\ \\sup_{v_{h}\\in V_{h}\\setminus\\{0\\}}\\ \\frac{b(v_{h},q_{h})}{\\|v_{h}\\|_{H^{1}(\\Omega)}\\,\\|q_{h}\\|_{L^{2}(\\Omega)}}>0,\n$$\n且该常数与 $h$ 无关。\n\n仅使用上述定义和张量积 $Q_{1}$ 基函数的基本性质，构造一个非零的“棋盘格”压力 $q_{h}\\in Q_{h}$，其节点值在整个网格上符号交替，并严格证明对于该均匀四边形网格上所有的 $v_{h}\\in V_{h}$，都有 $b(v_{h},q_{h})=0$。由此，计算在 $\\mathcal{T}_{h}$ 上的等阶 $Q_{1}$–$Q_{1}$ 对的离散 inf-sup 常数 $\\beta_{h}$。将您的最终答案表示为一个实数。无需四舍五入，也不涉及物理单位。", "solution": "该问题是有效的。这是一个在偏微分方程数值分析领域中提法恰当、有科学依据的问题。所有定义都是标准的，前提条件也是一致的。\n\n求解过程分三步：\n1.  构造一个特定的非零压力函数 $q_h$，并验证它属于离散压力空间 $Q_h$。\n2.  严格证明对于这个 $q_h$，双线性形式 $b(v_h, q_h)$ 对于离散速度空间 $V_h$ 中的所有函数 $v_h$ 都为零。\n3.  根据前面的结果推导出离散 inf-sup 常数 $\\beta_h$ 的值。\n\n设均匀四边形网格 $\\mathcal{T}_h$ 的节点记为 $(x_i, y_j)$，其中 $x_i = i h_x$（$i \\in \\{0, 1, \\dots, n_x-1\\}$），$y_j = j h_y$（$j \\in \\{0, 1, \\dots, n_y-1\\}$）。单元尺寸为 $h_x = 1/(n_x-1)$ 和 $h_y = 1/(n_y-1)$。\n\n步骤 1：构造棋盘格压力模式 $q_h$。\n我们通过指定其节点值来定义一个函数 $q_h \\in S_h$。设 $\\phi_{ij}(x,y)$ 是与节点 $(x_i, y_j)$ 相关联的标准 $Q_1$ 基函数。我们定义 $q_h$ 为：\n$$\nq_h(x,y) = \\sum_{i=0}^{n_x-1} \\sum_{j=0}^{n_y-1} (-1)^{i+j} \\phi_{ij}(x,y).\n$$\n$q_h$ 在 $(x_i, y_j)$ 处的节点值因此是 $(-1)^{i+j}$。由于并非所有节点值都为零，所以 $q_h$ 是 $S_h$ 中的一个非零函数。\n\n为了证明 $q_h \\in Q_h$，我们必须验证其在 $\\Omega$ 上的积分为零。我们将证明一个更强的结果：$q_h$ 在任意单个单元 $K \\in \\mathcal{T}_h$ 上的积分为零。\n考虑一个任意单元 $K_{kl} = [x_k, x_{k+1}] \\times [y_l, y_{l+1}]$，其中 $k \\in \\{0, \\dots, n_x-2\\}$ 且 $l \\in \\{0, \\dots, n_y-2\\}$。在此单元上，$q_h$ 是一个由其四个角点上的节点值决定的双线性多项式：\n$q_h(x_k, y_l) = (-1)^{k+l}$\n$q_h(x_{k+1}, y_l) = (-1)^{k+1+l} = -(-1)^{k+l}$\n$q_h(x_k, y_{l+1}) = (-1)^{k+l+1} = -(-1)^{k+l}$\n$q_h(x_{k+1}, y_{l+1}) = (-1)^{k+1+l+1} = (-1)^{k+l}$。\n设 $(\\xi, \\eta)$ 是参考单元 $[0,1]^2$ 上的局部坐标，其中 $\\xi = (x-x_k)/h_x$ 且 $\\eta = (y-y_l)/h_y$。在 $K_{kl}$ 上，函数 $q_h$可以写成：\n$$\nq_h(\\xi, \\eta) = (-1)^{k+l} \\left[ (1-\\xi)(1-\\eta) - \\xi(1-\\eta) - (1-\\xi)\\eta + \\xi\\eta \\right] = (-1)^{k+l} (1-2\\xi)(1-2\\eta).\n$$\n$q_h$ 在 $K_{kl}$ 上的积分为：\n$$\n\\int_{K_{kl}} q_h \\,dx\\,dy = \\int_0^1 \\int_0^1 (-1)^{k+l} (1-2\\xi)(1-2\\eta) h_x h_y \\,d\\xi\\,d\\eta.\n$$\n这个积分可以分离：\n$$\n\\int_{K_{kl}} q_h \\,dx\\,dy = (-1)^{k+l} h_x h_y \\left( \\int_0^1 (1-2\\xi) \\,d\\xi \\right) \\left( \\int_0^1 (1-2\\eta) \\,d\\eta \\right).\n$$\n每个积分的值为 $\\int_0^1 (1-2t) \\,dt = [t-t^2]_0^1 = 1-1=0$。\n因此，$\\int_{K_{kl}} q_h \\,dx\\,dy = 0$。由于这对每个单元 $K_{kl} \\in \\mathcal{T}_h$ 都成立，我们有：\n$$\n\\int_{\\Omega} q_h \\,dx = \\sum_{K \\in \\mathcal T_h} \\int_K q_h \\,dx = 0.\n$$\n因此，$q_h$ 是 $Q_h$ 中的一个非零函数。请注意，这个结果与 $n_x$ 和 $n_y$ 是偶数的条件无关。\n\n步骤 2：证明对于所有 $v_h \\in V_h$，$b(v_h, q_h) = 0$。\n双线性形式为 $b(v_h, q_h) = -\\int_{\\Omega} q_h \\nabla \\cdot v_h \\,dx$。应用分部积分（格林第一恒等式）：\n$$\nb(v_h, q_h) = -\\int_{\\partial\\Omega} q_h (v_h \\cdot n) \\,ds + \\int_{\\Omega} \\nabla q_h \\cdot v_h \\,dx.\n$$\n由于 $v_h \\in V_h$，我们有 $v_h|_{\\partial\\Omega}=0$，所以边界积分为零。我们只需证明 $\\int_{\\Omega} \\nabla q_h \\cdot v_h \\,dx = 0$。\n任何函数 $v_h = (u_h, w_h) \\in V_h$ 都可以表示为向量基函数的线性组合。$V_h$ 的基由 $\\{ (\\phi_{ij}, 0), (0, \\phi_{ij}) \\}_{i,j \\text{ interior}}$ 给出，其中 $(i,j \\text{ interior})$ 表示 $i \\in \\{1,\\dots,n_x-2\\}$ 且 $j \\in \\{1,\\dots,n_y-2\\}$。根据线性性，我们只需证明该积分对每一个基函数都为零即可。\n\n我们首先检验内部节点 $(i,j)$ 的基函数 $(\\phi_{ij}, 0)$：\n$$\nb((\\phi_{ij}, 0), q_h) = \\int_{\\Omega} \\frac{\\partial q_h}{\\partial x} \\phi_{ij} \\,dx\\,dy.\n$$\n基函数 $\\phi_{ij}$ 的支集是交于节点 $(x_i, y_j)$ 的四个单元的并集：$K_{i-1,j-1}$、$K_{i,j-1}$、$K_{i-1,j}$ 和 $K_{i,j}$。我们计算在每个单元上的积分。\n在一个单元 $K_{kl}$ 上，我们得到 $\\frac{\\partial q_h}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ (-1)^{k+l}(1-2\\xi)(1-2\\eta) \\right] = (-1)^{k+l} (-2/h_x) (1-2\\eta)$。\n积分在局部坐标 $(\\xi, \\eta) \\in [0,1]^2$ 中计算。\n\n- 在 $K_{i,j}$ 上（节点 $(i,j)$ 是左下角）：$\\phi_{ij}$ 对应于 $(1-\\xi)(1-\\eta)$。\n$$ \\int_{K_{i,j}}\\!\\! \\frac{\\partial q_h}{\\partial x} \\phi_{ij} \\,dxdy = \\int_0^1\\!\\!\\int_0^1 \\! \\frac{-2(-1)^{i+j}}{h_x}(1-2\\eta) (1-\\xi)(1-\\eta) h_x h_y d\\xi d\\eta = -2(-1)^{i+j}h_y (\\int_0^1 (1-\\xi)d\\xi)(\\int_0^1 (1-2\\eta)(1-\\eta)d\\eta) = -2(-1)^{i+j}h_y(\\frac{1}{2})(\\frac{1}{6}) = -\\frac{(-1)^{i+j}h_y}{6}. $$\n- 在 $K_{i-1,j}$ 上（节点 $(i,j)$ 是右下角）：$\\phi_{ij}$ 对应于 $\\xi(1-\\eta)$。\n$$ \\int_{K_{i-1,j}}\\!\\! \\frac{\\partial q_h}{\\partial x} \\phi_{ij} \\,dxdy = \\int_0^1\\!\\!\\int_0^1 \\! \\frac{-2(-1)^{i-1+j}}{h_x}(1-2\\eta) \\xi(1-\\eta) h_x h_y d\\xi d\\eta = -2(-1)^{i-1+j}h_y (\\int_0^1 \\xi d\\xi)(\\int_0^1 (1-2\\eta)(1-\\eta)d\\eta) = -2(-1)^{i-1+j}h_y(\\frac{1}{2})(\\frac{1}{6}) = +\\frac{(-1)^{i+j}h_y}{6}. $$\n- 在 $K_{i,j-1}$ 上（节点 $(i,j)$ 是左上角）：$\\phi_{ij}$ 对应于 $(1-\\xi)\\eta$。\n$$ \\int_{K_{i,j-1}}\\!\\! \\frac{\\partial q_h}{\\partial x} \\phi_{ij} \\,dxdy = \\int_0^1\\!\\!\\int_0^1 \\! \\frac{-2(-1)^{i+j-1}}{h_x}(1-2\\eta) (1-\\xi)\\eta h_x h_y d\\xi d\\eta = -2(-1)^{i+j-1}h_y (\\int_0^1 (1-\\xi)d\\xi)(\\int_0^1 (1-2\\eta)\\eta d\\eta) = -2(-1)^{i+j-1}h_y(\\frac{1}{2})(-\\frac{1}{6}) = -\\frac{(-1)^{i+j}h_y}{6}. $$\n- 在 $K_{i-1,j-1}$ 上（节点 $(i,j)$ 是右上角）：$\\phi_{ij}$ 对应于 $\\xi\\eta$。\n$$ \\int_{K_{i-1,j-1}}\\!\\! \\frac{\\partial q_h}{\\partial x} \\phi_{ij} \\,dxdy = \\int_0^1\\!\\!\\int_0^1 \\! \\frac{-2(-1)^{i-1+j-1}}{h_x}(1-2\\eta) \\xi\\eta h_x h_y d\\xi d\\eta = -2(-1)^{i+j}h_y (\\int_0^1 \\xi d\\xi)(\\int_0^1 (1-2\\eta)\\eta d\\eta) = -2(-1)^{i+j}h_y(\\frac{1}{2})(-\\frac{1}{6}) = +\\frac{(-1)^{i+j}h_y}{6}. $$\n将四个单元的贡献相加：\n$$ b((\\phi_{ij}, 0), q_h) = \\sum_{K} \\int_K \\frac{\\partial q_h}{\\partial x} \\phi_{ij} \\,dx\\,dy = (-1)^{i+j}h_y \\left(-\\frac{1}{6} + \\frac{1}{6} - \\frac{1}{6} + \\frac{1}{6}\\right) = 0. $$\n根据问题的对称性，对基函数 $(0, \\phi_{ij})$ 进行类似的计算可得 $b((0, \\phi_{ij}), q_h) = \\int_{\\Omega} \\frac{\\partial q_h}{\\partial y} \\phi_{ij} \\,dx\\,dy = 0$。\n由于 $b(v, q_h)$ 对 $V_h$ 的所有基函数都为零，根据线性性，它对所有 $v_h \\in V_h$ 都为零。\n\n步骤 3：计算离散 inf-sup 常数 $\\beta_h$。\n离散 inf-sup 常数定义为：\n$$\n\\beta_h = \\inf_{p_h \\in Q_h \\setminus \\{0\\}} \\sup_{v_h \\in V_h \\setminus \\{0\\}} \\frac{b(v_h,p_h)}{\\|v_h\\|_{H^1(\\Omega)}\\,\\|p_h\\|_{L^2(\\Omega)}}.\n$$\n下确界是在离散压力空间 $Q_h$ 中所有非零函数上取。我们已经构造了一个特定的非零函数，即棋盘格模式 $q_h$，它属于 $Q_h$。因此，下确界必须小于或等于该表达式对这个特定的 $q_h$ 的值：\n$$\n\\beta_h \\le \\sup_{v_h\\in V_h\\setminus\\{0\\}}\\ \\frac{b(v_h, q_h)}{\\|v_h\\|_{H^{1}(\\Omega)}\\,\\|q_h\\|_{L^{2}(\\Omega)}}.\n$$\n在步骤 2 中，我们证明了对于所有 $v_h \\in V_h$，$b(v_h, q_h) = 0$。将此代入上述表达式：\n$$\n\\sup_{v_h\\in V_h\\setminus\\{0\\}}\\ \\frac{0}{\\|v_h\\|_{H^{1}(\\Omega)}\\,\\|q_h\\|_{L^{2}(\\Omega)}} = 0.\n$$\n这表明 $\\beta_h \\le 0$。\n根据定义，对于任何 $p_h \\in Q_h$，项 $b(v_h, p_h)$ 可以是正数或负数，但上确界 $\\sup_{v_h} b(v_h, p_h)$ 将是非负的（我们总可以选择 $v_h$ 使其具有“正确”的符号，或者 $v_h=0$）。更正式地说，下确界内的项是一个上确界与范数的商，它必须是非负的。一组非负数的下确界也必须是非负的。因此，$\\beta_h \\ge 0$。\n\n结合两个不等式 $\\beta_h \\le 0$ 和 $\\beta_h \\ge 0$，我们不得不得出结论 $\\beta_h = 0$。这证明了用于斯托克斯方程的等阶 $Q_1-Q_1$ 有限元对是不稳定的。", "answer": "$$\\boxed{0}$$", "id": "3414772"}, {"introduction": "理论分析虽然能够揭示不稳定性的存在，但在工程实践中，我们更需要一种量化的方法来评估和比较不同有限元配对的稳定性。LBB 常数 $\\beta_h$ 并非纯粹的理论概念，它完全可以通过求解一个广义特征值问题来精确计算，该问题关联了离散散度算子、速度刚度矩阵和压力质量矩阵。这个编程练习将连接抽象的稳定性理论与具体的数值实现，你将开发一个强大的工具来评估任意有限元配对的稳定性，并亲眼见证稳定的 Taylor-Hood ($P_2/P_1$) 单元与不稳定的等阶 ($P_1/P_1$) 单元在其计算结果上的显著差异。[@problem_id:3414744]", "problem": "考虑在单位正方形域上不可压缩斯托克斯型系统的混合有限元离散化，其中离散 inf-sup (Ladyzhenskaya–Babuška–Brezzi (LBB)) 常数 $\\beta_h$ 对于离散速度和压力空间 $(V_h,Q_h)$ 由瑞利商表征定义\n$$\n\\beta_h \\;=\\; \\inf_{q_h \\in Q_h\\setminus\\{0\\}} \\; \\sup_{v_h \\in V_h\\setminus\\{0\\}} \\; \\frac{b(v_h,q_h)}{\\|v_h\\|_V\\,\\|q_h\\|_Q},\n$$\n其中双线性形式 $b(v_h,q_h) = \\int_\\Omega \\nabla q_h \\cdot v_h \\, d\\Omega$，速度范数 $\\|v_h\\|_V$ 由 $H^1$ 内积诱导，压力范数 $\\|q_h\\|_Q$ 由 $L^2$ 内积诱导。假设速度满足齐次狄利克雷边界条件，因此 $H^1$ 半范数在 $V_h$ 上定义了一个真范数。\n\n在一个协调三角网格上进行计算，该网格通过将均匀笛卡尔网格的每个四边形单元以一致的方向分裂成两个三角形生成。令压力空间 $Q_h$ 为在三角形顶点上连续的分片线性函数。令速度空间 $V_h$ 为以下两种之一：\n- 等阶分片线性（记作 $\\text{P1}/\\text{P1}$），其速度基函数与顶点上的压力基函数相同，并通过消除边界自由度使边界上的速度为零；\n- Taylor–Hood ($\\text{P2}/\\text{P1}$），其速度基函数为定义在三角形顶点和边中点节点上的二次函数，压力如上所述，并通过消除与边界顶点和边界边相关的速度自由度使边界上的速度为零。\n\n从离散的角度来看，双线性形式 $b(v_h,q_h)$ 通过以下方式诱导出离散散度算子 $B \\in \\mathbb{R}^{n_p \\times n_v}$：\n$$\nq_h^\\top\\, B \\, v_h \\;=\\; b(v_h,q_h) \\;=\\; \\int_\\Omega \\nabla q_h \\cdot v_h \\, d\\Omega,\n$$\n其中 $n_p$ 和 $n_v$ 分别是压力和速度自由度的数量。速度 $H^1$ 内积诱导出对称正定刚度矩阵 $K \\in \\mathbb{R}^{n_v \\times n_v}$，其元素为\n$$\nK_{ij} \\;=\\; \\int_\\Omega \\nabla \\phi_i \\cdot \\nabla \\phi_j \\, d\\Omega,\n$$\n其中 $\\phi_i$ 是单个分量的标量速度基函数，完整的速度矩阵是两个相同副本的块对角矩阵。压力 $L^2$ 内积诱导出对称正定质量矩阵 $M_p \\in \\mathbb{R}^{n_p \\times n_p}$，其元素为\n$$\n(M_p)_{ij} \\;=\\; \\int_\\Omega \\psi_i \\, \\psi_j \\, d\\Omega,\n$$\n其中 $\\psi_i$ 是压力基函数。\n\n从基本表征出发，即关于 $v_h$ 的上确界可以通过速度范数中的 Riesz 表示来表达，推导并实现离散广义特征值问题\n$$\nB\\,K^{-1}\\,B^\\top\\, q \\;=\\; \\lambda \\, M_p \\, q,\n$$\n并证明离散 LBB 常数满足\n$$\n\\beta_h \\;=\\; \\sqrt{\\lambda_{\\min}^+},\n$$\n其中 $\\lambda_{\\min}^+$ 是矩阵对 $(B\\,K^{-1}\\,B^\\top,\\, M_p)$ 的最小严格正广义特征值。\n\n实现细节与约束：\n- 网格：单位正方形上的一个均匀 $(n_x \\times n_y)$ 网格，每个单元分裂成两个三角形。压力在三角形顶点上使用基于顶点的连续分片线性基。速度则使用顶点上的分片线性基 ($\\text{P1}/\\text{P1}$) 或顶点和边中点节点上的二次基 ($\\text{P2}/\\text{P1}$)。消除边界上的速度自由度以强制施加齐次狄利克雷条件。\n- 形函数：\n  - 对于 $\\text{P1}$，使用重心坐标 $\\lambda_1,\\lambda_2,\\lambda_3$，其在每个三角形上的梯度为常数。\n  - 对于 $\\text{P2}$，使用以重心坐标表示的三角形上六个标准的二次拉格朗日形函数：\n    $N_1=\\lambda_1(2\\lambda_1-1)$, $N_2=\\lambda_2(2\\lambda_2-1)$, $N_3=\\lambda_3(2\\lambda_3-1)$, $N_4=4\\lambda_1\\lambda_2$, $N_5=4\\lambda_2\\lambda_3$, $N_6=4\\lambda_3\\lambda_1$，其梯度通过链式法则从 $\\lambda_i$ 的常梯度计算得出。\n- 求积：在三角形上使用三点二次对称求积法则，重心坐标分别为 $(\\frac{2}{3},\\frac{1}{6},\\frac{1}{6})$、$(\\frac{1}{6},\\frac{2}{3},\\frac{1}{6})$、$(\\frac{1}{6},\\frac{1}{6},\\frac{2}{3})$，对于面积为 $A$ 的三角形，每个点的权重为 $\\frac{A}{3}$。\n- 组装：\n  - 从 $\\int \\nabla \\phi_i \\cdot \\nabla \\phi_j$ 组装 $K$（对于单个分量）；完整的速度刚度矩阵是两个相同副本的块对角矩阵。\n  - 从 $\\int \\psi_i \\psi_j$ 组装 $M_p$。\n  - 对于 $\\alpha \\in \\{x,y\\}$，从 $\\int \\partial_\\alpha \\psi_i \\, \\phi_j$ 组装 $B$，将分量块水平拼接以形成 $B \\in \\mathbb{R}^{n_p \\times 2 n_v^{\\text{base}}}$。\n- 特征问题：计算 $(B K^{-1} B^\\top, M_p)$ 的广义特征值，舍弃低于小容差（例如 $10^{-8}$）的特征值，并取 $\\beta_h$ 为剩余最小特征值的平方根。\n\n您的程序必须为以下参数值测试套件（单元族，$n_x$, $n_y$）实现此组装和特征分析：\n1. $\\text{P1}/\\text{P1}$，$n_x=2$，$n_y=2$。\n2. $\\text{P2}/\\text{P1}$，$n_x=2$，$n_y=2$。\n3. $\\text{P1}/\\text{P1}$，$n_x=3$，$n_y=2$。\n4. $\\text{P2}/\\text{P1}$，$n_x=3$，$n_y=3$。\n\n所有角度纯粹是几何的，不需要单位。此问题中没有物理单位。您的程序应生成单行输出，其中包含以逗号分隔的浮点数列表形式的结果，四舍五入到六位小数，并用方括号括起来，顺序与上述测试套件一致（例如，“[0.123456,0.234567,0.345678,0.456789]”）。", "solution": "该问题是有效的，因为它在科学上基于混合有限元方法的理论，是适定的、客观的，并为其实现提供了一套完整且一致的规范。我们将首先从离散 LBB 常数的定义中推导出指定的广义特征值问题，然后进行数值实现。\n\n离散 LBB（或 inf-sup）常数 $\\beta_h$ 由一个类瑞利商的结构定义：\n$$\n\\beta_h = \\inf_{q_h \\in Q_h\\setminus\\{0\\}} \\sup_{v_h \\in V_h\\setminus\\{0\\}} \\frac{b(v_h, q_h)}{\\|v_h\\|_V \\|q_h\\|_Q}\n$$\n其中 $b(v_h, q_h) = \\int_\\Omega \\nabla q_h \\cdot v_h \\, d\\Omega$。速度空间 $V_h$ 是一个希尔伯特空间，赋以内积 $\\langle u_h, v_h \\rangle_V = \\int_\\Omega \\nabla u_h \\cdot \\nabla v_h \\, d\\Omega$，它诱导了范数 $\\|v_h\\|_V = \\sqrt{\\langle v_h, v_h \\rangle_V}$。压力空间 $Q_h$ 是一个希尔伯特空间，赋以内积 $\\langle p_h, q_h \\rangle_Q = \\int_\\Omega p_h q_h \\, d\\Omega$，它诱导了范数 $\\|q_h\\|_Q = \\sqrt{\\langle q_h, q_h \\rangle_Q}$。\n\n对于一个固定的非零压力函数 $q_h \\in Q_h$，我们来分析内部的上确界项：\n$$\n\\sup_{v_h \\in V_h\\setminus\\{0\\}} \\frac{b(v_h, q_h)}{\\|v_h\\|_V} = \\sup_{v_h \\in V_h\\setminus\\{0\\}} \\frac{\\int_\\Omega \\nabla q_h \\cdot v_h \\, d\\Omega}{\\|v_h\\|_V}\n$$\n分子 $L_{q_h}(v_h) = \\int_\\Omega \\nabla q_h \\cdot v_h \\, d\\Omega$ 是希尔伯特空间 $V_h$ 上的一个有界线性泛函。根据 Riesz 表示定理，对于任意这样的泛函，存在唯一元素 $w_{q_h} \\in V_h$ 使得对于所有 $v_h \\in V_h$：\n$$\nL_{q_h}(v_h) = \\langle w_{q_h}, v_h \\rangle_V \\quad \\implies \\quad \\int_\\Omega \\nabla q_h \\cdot v_h \\, d\\Omega = \\int_\\Omega \\nabla w_{q_h} \\cdot \\nabla v_h \\, d\\Omega\n$$\n当 $v_h$ 被选择为与 $w_{q_h}$ 成比例时，上确界就达到了，并且根据柯西-施瓦茨不等式，其值就是 Riesz 表示子的范数：\n$$\n\\sup_{v_h \\in V_h\\setminus\\{0\\}} \\frac{\\langle w_{q_h}, v_h \\rangle_V}{\\|v_h\\|_V} = \\|w_{q_h}\\|_V\n$$\n现在，我们用离散矩阵算子来表示这种关系。令 $q$ 为压力函数 $q_h = \\sum_i q_i \\psi_i$ 的系数向量，并令 $v$ 和 $w_q$ 分别为速度函数 $v_h$ 和 $w_{q_h}$ 的系数向量。给定的矩阵定义是：\n- $q^\\top B v = b(v_h,q_h)$\n- $v^\\top K v = \\|v_h\\|_V^2$\n- $q^\\top M_p q = \\|q_h\\|_Q^2$\n\nRiesz 表示恒等式 $\\int_\\Omega \\nabla q_h \\cdot v_h \\, d\\Omega = \\int_\\Omega \\nabla w_{q_h} \\cdot \\nabla v_h \\, d\\Omega$ 对所有系数向量 $v$ 转化为离散形式：\n$$\nq^\\top B v = w_q^\\top K v\n$$\n由于这对任意 $v$ 都成立，我们必然有 $q^\\top B = w_q^\\top K$。对两边进行转置得到 $B^\\top q = K^\\top w_q$。由于速度刚度矩阵 $K$ 是对称的 ($K = K^\\top$)，我们有 $B^\\top q = K w_q$。由于 $V_h$ 由在边界上为零的函数组成，$H^1$ 半范数是一个真范数，因此得到的刚度矩阵 $K$ 是对称正定且可逆的。我们可以求解 Riesz 表示子的系数向量：\n$$\nw_q = K^{-1} B^\\top q\n$$\n此表示子的范数平方为：\n$$\n\\|w_{q_h}\\|_V^2 = w_q^\\top K w_q = (K^{-1} B^\\top q)^\\top K (K^{-1} B^\\top q) = q^\\top B (K^{-1})^\\top K K^{-1} B^\\top q\n$$\n利用 $K$ 的对称性（这意味着 $K^{-1}$ 也对称，即 $(K^{-1})^\\top = K^{-1}$），上式简化为：\n$$\n\\|w_{q_h}\\|_V^2 = q^\\top B K^{-1} B^\\top q\n$$\n将此代回 $\\beta_h$ 的定义中，我们得到：\n$$\n\\beta_h^2 = \\inf_{q_h \\in Q_h\\setminus\\{0\\}} \\frac{\\|w_{q_h}\\|_V^2}{\\|q_h\\|_Q^2} = \\inf_{q \\neq 0} \\frac{q^\\top (B K^{-1} B^\\top) q}{q^\\top M_p q}\n$$\n这是矩阵束 $(A, M)$ 的瑞利商的最小值定义，其中 $A = B K^{-1} B^\\top$ 且 $M=M_p$。因此，下确界是问题\n$$\nB K^{-1} B^\\top q = \\lambda M_p q\n$$\n的最小广义特征值 $\\lambda$。\n需要特别考虑离散散度算子 $B^\\top$ 的零空间。对于任意常数压力函数 $q_h = c$，其梯度为零，即 $\\nabla q_h = 0$。这意味着对所有 $v_h$ 都有 $b(v_h, q_h)=0$。在离散设置中，对应于常数压力的系数向量 $q_c$ 位于 $B^\\top$ 的零空间中，即 $B^\\top q_c = 0$。因此，$B K^{-1} B^\\top q_c = 0$，这意味着 $\\lambda = 0$ 始终是一个广义特征值。这个特征值是物理（压力仅在相差一个常数的情况下确定）上的一个产物，并不反映离散化对于非常数压力的稳定性。LBB 条件关注的是压力空间中不在此零空间内的部分的耦合稳定性。因此，我们必须寻找最小的严格正特征值 $\\lambda_{\\min}^+$。\n取平方根得到最终关系式：\n$$\n\\beta_h = \\sqrt{\\lambda_{\\min}^+}\n$$\n推导至此完成。实现将接下来构造矩阵 $K$、B 和 $M_p$，并求解此广义特征值问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef compute_lbb(family, nx, ny):\n    \"\"\"\n    Computes the LBB constant for a given finite element family and mesh size.\n    \"\"\"\n    # 1. MESH and DOF GENERATION\n    \n    # Pressure DOFs (P1) are always at the vertices of the coarse grid\n    p_nodes_x = nx + 1\n    p_nodes_y = ny + 1\n    n_p = p_nodes_x * p_nodes_y\n    p_coords = np.array([[i / nx, j / ny] for j in range(p_nodes_y) for i in range(p_nodes_x)])\n\n    if family == 'P1/P1':\n        v_type = 'P1'\n        num_v_basis_per_elem = 3\n        v_coords = p_coords\n        v_nodes_x = p_nodes_x\n        v_nodes_y = p_nodes_y\n        \n        # Internal velocity P1 DOFs (at vertices)\n        v_dof_map = -np.ones(v_nodes_x * v_nodes_y, dtype=int)\n        dof = 0\n        for j in range(1, v_nodes_y - 1):\n            for i in range(1, v_nodes_x - 1):\n                v_dof_map[i + j * v_nodes_x] = dof\n                dof += 1\n        n_v_base = dof\n\n    elif family == 'P2/P1':\n        v_type = 'P2'\n        num_v_basis_per_elem = 6\n        v_nodes_x = 2 * nx + 1\n        v_nodes_y = 2 * ny + 1\n        v_coords = np.array([[i / (2 * nx), j / (2 * ny)] for j in range(v_nodes_y) for i in range(v_nodes_x)])\n\n        # Internal velocity P2 DOFs (at vertices and edge midpoints)\n        v_dof_map = -np.ones(v_nodes_x * v_nodes_y, dtype=int)\n        dof = 0\n        for j in range(1, v_nodes_y - 1):\n            for i in range(1, v_nodes_x - 1):\n                v_dof_map[i + j * v_nodes_x] = dof\n                dof += 1\n        n_v_base = dof\n\n    # Triangles (elements of the mesh)\n    elements = []\n    for j in range(ny):\n        for i in range(nx):\n            p0 = i + j * p_nodes_x\n            p1 = (i + 1) + j * p_nodes_x\n            p2 = i + (j + 1) * p_nodes_x\n            p3 = (i + 1) + (j + 1) * p_nodes_x\n            elements.append((p0, p1, p3))  # Bottom-left to top-right diagonal\n            elements.append((p0, p3, p2))\n\n    # 2. MATRIX ASSEMBLY\n\n    # Quadrature rule on reference triangle\n    quad_points = np.array([[2/3, 1/6, 1/6], [1/6, 2/3, 1/6], [1/6, 1/6, 2/3]]) # Barycentric coords\n    quad_weights = np.array([1/3, 1/3, 1/3])\n\n    # Initialize global matrices\n    K_base = np.zeros((n_v_base, n_v_base))\n    M_p = np.zeros((n_p, n_p))\n    B_x = np.zeros((n_p, n_v_base))\n    B_y = np.zeros((n_p, n_v_base))\n\n    for el_nodes_p in elements:\n        # Physical coordinates of the element's vertices\n        v_coords_p = p_coords[np.array(el_nodes_p)]\n        \n        # Geometric properties\n        edge1 = v_coords_p[1] - v_coords_p[0]\n        edge2 = v_coords_p[2] - v_coords_p[0]\n        area = 0.5 * np.abs(edge1[0] * edge2[1] - edge1[1] * edge2[0])\n        \n        # Gradients of P1 basis functions (barycentric coordinates)\n        J_inv_T = (1 / (2 * area)) * np.array([[v_coords_p[1, 1] - v_coords_p[2, 1], v_coords_p[2, 0] - v_coords_p[1, 0]],\n                                               [v_coords_p[2, 1] - v_coords_p[0, 1], v_coords_p[0, 0] - v_coords_p[2, 0]],\n                                               [v_coords_p[0, 1] - v_coords_p[1, 1], v_coords_p[1, 0] - v_coords_p[0, 0]]])\n        grads_p = J_inv_T\n\n        if v_type == 'P1':\n            el_nodes_v = el_nodes_p\n            grads_v = grads_p\n        elif v_type == 'P2':\n            i0, j0 = el_nodes_p[0] % p_nodes_x, el_nodes_p[0] // p_nodes_x\n            i1, j1 = el_nodes_p[1] % p_nodes_x, el_nodes_p[1] // p_nodes_x\n            i3, j3 = el_nodes_p[2] % p_nodes_x, el_nodes_p[2] // p_nodes_x\n            v_idx0, v_idx1, v_idx3 = 2*i0+2*j0*v_nodes_x, 2*i1+2*j1*v_nodes_x, 2*i3+2*j3*v_nodes_x\n            m_idx01 = (i0+i1) + (j0+j1)*v_nodes_x\n            m_idx13 = (i1+i3) + (j1+j3)*v_nodes_x\n            m_idx03 = (i0+i3) + (j0+j3)*v_nodes_x\n            el_nodes_v = [v_idx0, v_idx1, v_idx3, m_idx01, m_idx13, m_idx03]\n\n        p_global_dofs = list(el_nodes_p)\n        v_global_dofs = [v_dof_map[idx] for idx in el_nodes_v]\n\n        for i in range(len(quad_points)):\n            lmbda = quad_points[i]\n            w = quad_weights[i] * area\n\n            # Evaluate basis functions\n            vals_p = lmbda\n            if v_type == 'P1':\n                vals_v = lmbda\n            elif v_type == 'P2':\n                vals_v = np.array([lmbda[0]*(2*lmbda[0]-1), lmbda[1]*(2*lmbda[1]-1), lmbda[2]*(2*lmbda[2]-1),\n                                   4*lmbda[0]*lmbda[1], 4*lmbda[1]*lmbda[2], 4*lmbda[2]*lmbda[0]])\n                \n                # Evaluate P2 velocity gradients\n                grad_lmbda = J_inv_T\n                grads_v = np.zeros((6, 2))\n                grads_v[0, :] = (4 * lmbda[0] - 1) * grad_lmbda[0]\n                grads_v[1, :] = (4 * lmbda[1] - 1) * grad_lmbda[1]\n                grads_v[2, :] = (4 * lmbda[2] - 1) * grad_lmbda[2]\n                grads_v[3, :] = 4 * (lmbda[1] * grad_lmbda[0] + lmbda[0] * grad_lmbda[1])\n                grads_v[4, :] = 4 * (lmbda[2] * grad_lmbda[1] + lmbda[1] * grad_lmbda[2])\n                grads_v[5, :] = 4 * (lmbda[0] * grad_lmbda[2] + lmbda[2] * grad_lmbda[0])\n\n            # Assemble local contributions\n            for r in range(3): # pressure basis functions\n                pr = p_global_dofs[r]\n                for s in range(3):\n                    ps = p_global_dofs[s]\n                    M_p[pr, ps] += vals_p[r] * vals_p[s] * w\n\n                for s in range(num_v_basis_per_elem):\n                    vs = v_global_dofs[s]\n                    if vs != -1:\n                        B_x[pr, vs] += grads_p[r, 0] * vals_v[s] * w\n                        B_y[pr, vs] += grads_p[r, 1] * vals_v[s] * w\n            \n            for r in range(num_v_basis_per_elem):\n                vr = v_global_dofs[r]\n                if vr != -1:\n                    for s in range(num_v_basis_per_elem):\n                        vs = v_global_dofs[s]\n                        if vs != -1:\n                            K_base[vr, vs] += np.dot(grads_v[r], grads_v[s]) * w\n\n    # 3. CONSTRUCT FULL MATRICES AND SOLVE EIGENPROBLEM\n    if n_v_base == 0:\n        return 0.0\n\n    K = linalg.block_diag(K_base, K_base)\n    B = np.hstack([B_x, B_y])\n\n    # K is small enough for direct inversion\n    K_inv = linalg.inv(K)\n    A_mat = B @ K_inv @ B.T\n\n    # Solve the generalized eigenvalue problem A*q = lambda*M_p*q\n    eigenvalues = linalg.eigh(A_mat, M_p, eigvals_only=True)\n\n    # Find the smallest strictly positive eigenvalue\n    tol = 1e-8\n    positive_eigenvalues = eigenvalues[eigenvalues > tol]\n    \n    if len(positive_eigenvalues) == 0:\n      return 0.0\n      \n    lambda_min_plus = np.min(positive_eigenvalues)\n    beta_h = np.sqrt(lambda_min_plus)\n\n    return beta_h\n\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print results.\n    \"\"\"\n    test_cases = [\n        ('P1/P1', 2, 2),\n        ('P2/P1', 2, 2),\n        ('P1/P1', 3, 2),\n        ('P2/P1', 3, 3),\n    ]\n\n    results = []\n    for family, nx, ny in test_cases:\n        result = compute_lbb(family, nx, ny)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3414744"}]}