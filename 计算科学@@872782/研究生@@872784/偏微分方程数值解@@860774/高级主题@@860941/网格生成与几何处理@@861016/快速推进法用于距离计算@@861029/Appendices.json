{"hands_on_practices": [{"introduction": "快速行进法 (Fast Marching Method, FMM) 的核心在于其局部更新规则，该规则智能地决定了如何推进波前。本练习聚焦于推导和应用这一关键逻辑 [@problem_id:3391176]。通过为一个单一节点计算一个试验性的到达时间，你将具体理解迎风原则以及区分一维和二维传播的因果性条件。", "problem": "考虑各向同性的Eikonal方程 $|\\nabla T(\\mathbf{x})| = 1/f(\\mathbf{x})$，其中 $T$ 是以速度 $f(\\mathbf{x})$ 传播的波前的到达时间。在快速行进法（FMM）中，网格节点 $(i,j)$ 处的试探性更新值是使用迎风Godunov离散格式计算的，该网格在两个方向上的间距均为 $h$，并且基于沿坐标轴已接受的相邻节点的到达时间。设沿 $x$ 轴和 $y$ 轴方向的最小已接受到达时间分别为 $a$ 和 $b$。假设试探性更新必须满足单调性约束 $T \\geq \\max\\{a,b\\}$。\n\n从Eikonal方程出发，利用迎风原理，推导 $T$ 必须满足的关于 $a$、$b$、$h$ 和 $f$ 的局部离散关系，并由此关系推导出决定二维更新或一维更新是否可行的决策逻辑。然后，应用您的逻辑，使用数值 $a=0.35$、$b=0.50$、$h=0.01$ 和恒定速度 $f=1.8$ 计算该节点的试探性更新值 $T$。将您的最终答案表示为单个数字。无需四舍五入。", "solution": "该问题陈述经评估具有科学依据、提法恰当且客观。这是一个偏微分方程数值解领域的标准问题，具体涉及求解Eikonal方程的快速行进法。所提供的数据充分且一致，足以得到唯一解。因此，该问题被认为是有效的，下面将给出完整解答。\n\n各向同性Eikonal方程为\n$$ |\\nabla T(\\mathbf{x})|^2 = \\frac{1}{f(\\mathbf{x})^2} $$\n其中 $T(\\mathbf{x})$ 是在位置 $\\mathbf{x}$ 的到达时间，$f(\\mathbf{x})$ 是传播速度。在具有均匀间距 $h$ 的二维笛卡尔网格中，该方程可以写成\n$$ \\left(\\frac{\\partial T}{\\partial x}\\right)^2 + \\left(\\frac{\\partial T}{\\partial y}\\right)^2 = \\frac{1}{f^2} $$\n快速行进法（FMM）使用迎风Godunov格式来离散化空间导数。迎风原理确保信息从较小的到达时间传播到较大的到达时间。在一个我们希望计算试探性到达时间 $T$ 的网格节点 $(i,j)$ 处，我们使用其邻居节点已接受的到达时间。设 $a$ 和 $b$ 分别是沿 $x$ 和 $y$ 坐标方向的最小已接受到达时间。偏导数的迎风离散化基于这样的思想：为了使波前前进，新的时间 $T$ 必须大于波前传播来源的邻居节点的时间。一阶迎风离散化的一般形式是：\n$$ \\left(\\max\\left(0, \\frac{T-a}{h}\\right)\\right)^2 + \\left(\\max\\left(0, \\frac{T-b}{h}\\right)\\right)^2 = \\frac{1}{f^2} $$\n在这里，我们通过直接使用 $a$ 和 $b$ 作为相关的迎风邻居值来简化表示法。问题陈述了单调性约束 $T \\ge \\max\\{a, b\\}$，这意味着 $(T-a)$ 和 $(T-b)$ 都应为非负数。\n\n首先，我们假设二维（2D）更新是可行的，并推导局部离散关系。这个假设意味着波前使用来自 $x$ 和 $y$ 两个方向的信息传播到节点 $(i,j)$。在这种情况下，$\\max$ 函数内的两项都是正的，方程简化为：\n$$ \\left(\\frac{T-a}{h}\\right)^2 + \\left(\\frac{T-b}{h}\\right)^2 = \\frac{1}{f^2} $$\n这个方程是 $T$ 在二维更新中必须满足的局部离散关系。我们可以解这个关于 $T$ 的二次方程：\n$$ (T-a)^2 + (T-b)^2 = \\frac{h^2}{f^2} $$\n$$ T^2 - 2aT + a^2 + T^2 - 2bT + b^2 = \\frac{h^2}{f^2} $$\n$$ 2T^2 - 2(a+b)T + \\left(a^2 + b^2 - \\frac{h^2}{f^2}\\right) = 0 $$\n使用二次方程求根公式 $T = \\frac{-B \\pm \\sqrt{B^2 - 4AC}}{2A}$，其中 $A=2$，$B=-2(a+b)$，以及 $C = a^2+b^2 - (h/f)^2$：\n$$ T = \\frac{2(a+b) \\pm \\sqrt{4(a+b)^2 - 8\\left(a^2+b^2 - \\frac{h^2}{f^2}\\right)}}{4} $$\n$$ T = \\frac{a+b \\pm \\sqrt{(a+b)^2 - 2(a^2+b^2) + \\frac{2h^2}{f^2}}}{2} $$\n$$ T = \\frac{a+b \\pm \\sqrt{a^2+2ab+b^2 - 2a^2-2b^2 + \\frac{2h^2}{f^2}}}{2} $$\n$$ T = \\frac{a+b \\pm \\sqrt{\\frac{2h^2}{f^2} - (a-b)^2}}{2} $$\n因为我们需要 $T \\ge \\max\\{a, b\\}$，我们必须选择较大的根，即对应于 `+` 号的解：\n$$ T_{2D} = \\frac{a+b + \\sqrt{\\frac{2h^2}{f^2} - (a-b)^2}}{2} $$\n这是二维更新的候选解。\n\n接下来，我们推导决策逻辑。$T_{2D}$ 的实数解存在的条件是判别式为非负：$\\frac{2h^2}{f^2} - (a-b)^2 \\ge 0$，这意味着 $|a-b| \\le \\frac{\\sqrt{2}h}{f}$。更重要的是，这个二维更新有效的假设取决于结果是否满足单调性约束 $T \\ge \\max\\{a,b\\}$。不失一般性，我们假设 $b \\ge a$，因此 $\\max\\{a,b\\}=b$。有效性条件是 $T_{2D} \\ge b$。\n$$ \\frac{a+b + \\sqrt{\\frac{2h^2}{f^2} - (a-b)^2}}{2} \\ge b $$\n$$ a+b + \\sqrt{\\frac{2h^2}{f^2} - (a-b)^2} \\ge 2b $$\n$$ \\sqrt{\\frac{2h^2}{f^2} - (a-b)^2} \\ge b-a $$\n由于 $b-a \\ge 0$，我们可以对两边平方：\n$$ \\frac{2h^2}{f^2} - (a-b)^2 \\ge (b-a)^2 $$\n$$ \\frac{2h^2}{f^2} \\ge 2(a-b)^2 $$\n$$ \\frac{h^2}{f^2} \\ge (a-b)^2 \\implies \\frac{h}{f} \\ge |a-b| $$\n这就提供了决策逻辑。二维更新是可行的，当且仅当 $|a-b| \\le \\frac{h}{f}$。\n\n如果不满足此条件，即 $|a-b|  \\frac{h}{f}$，那么二维公式将得出 $T_{2D}  \\max\\{a,b\\}$，这违反了因果性原则。这意味着我们最初的假设是错误的；具体来说，更新不受两个邻居节点的影响。必须使用一般的离散方程，其中一个 $\\max$ 项变为零。如果 $b \\ge a$ 且 $|a-b|  h/f$，那么 $T  b$，所以 $\\max(0, (T-b)/h) = 0$。控制方程简化为由到达时间较小的邻居（本例中为 $a$）决定的一维（1D）更新：\n$$ \\left(\\frac{T-a}{h}\\right)^2 + 0 = \\frac{1}{f^2} $$\n解出 $T$ 得：\n$$ T_{1D} = a + \\frac{h}{f} $$\n更一般地，一维更新使用邻居值中的最小值：$T = \\min(a,b) + \\frac{h}{f}$。\n\n决策逻辑如下：\n1.  计算 $|a-b|$ 和 $\\frac{h}{f}$。\n2.  如果 $|a-b| \\le \\frac{h}{f}$，则更新是二维的，且 $T = \\frac{a+b + \\sqrt{2(h/f)^2 - (a-b)^2}}{2}$。\n3.  如果 $|a-b|  \\frac{h}{f}$，则更新是一维的，且 $T = \\min(a,b) + \\frac{h}{f}$。\n\n现在，我们将此逻辑应用于给定值：$a=0.35$，$b=0.50$，$h=0.01$ 和 $f=1.8$。\n我们将这些值表示为精确分数以避免舍入误差：\n$a = 0.35 = \\frac{35}{100} = \\frac{7}{20}$\n$b = 0.50 = \\frac{50}{100} = \\frac{1}{2}$\n$h = 0.01 = \\frac{1}{100}$\n$f = 1.8 = \\frac{18}{10} = \\frac{9}{5}$\n\n首先，我们检查决策逻辑的条件：\n$$ |a-b| = \\left|\\frac{7}{20} - \\frac{1}{2}\\right| = \\left|\\frac{7}{20} - \\frac{10}{20}\\right| = \\left|-\\frac{3}{20}\\right| = \\frac{3}{20} $$\n$$ \\frac{h}{f} = \\frac{1/100}{9/5} = \\frac{1}{100} \\cdot \\frac{5}{9} = \\frac{5}{900} = \\frac{1}{180} $$\n现在我们比较 $|a-b|$ 和 $\\frac{h}{f}$：\n$$ \\frac{3}{20} \\quad \\text{vs.} \\quad \\frac{1}{180} $$\n为了比较，我们可以使用公分母或交叉相乘：\n$$ 3 \\times 180 = 540 $$\n$$ 20 \\times 1 = 20 $$\n因为 $540 > 20$，我们有 $\\frac{3}{20} > \\frac{1}{180}$。\n条件 $|a-b| \\le \\frac{h}{f}$ 不成立。\n\n因此，一维（1D）更新是可行的。试探性更新值 $T$ 是使用两个邻居值中较小的一个来计算的，即 $T_{\\min} = \\min(a,b) = a = \\frac{7}{20}$。\n$$ T = T_{\\min} + \\frac{h}{f} $$\n$$ T = \\frac{7}{20} + \\frac{1}{180} $$\n为了将这些分数相加，我们找到一个公分母，即 $180$：\n$$ T = \\frac{7 \\times 9}{20 \\times 9} + \\frac{1}{180} = \\frac{63}{180} + \\frac{1}{180} = \\frac{64}{180} $$\n最后，我们简化分数：\n$$ T = \\frac{64 \\div 4}{180 \\div 4} = \\frac{16}{45} $$\n节点处到达时间 $T$ 的试探性更新值为 $\\frac{16}{45}$。", "answer": "$$ \\boxed{\\frac{16}{45}} $$", "id": "3391176"}, {"introduction": "对算法的理论理解必须通过实现与测试来验证。本实践将指导你构建一个完整的快速行进法求解器，并进行网格加密研究——这是数值分析的基石之一 [@problem_id:3391181]。通过在逐渐加密的网格上将数值解与精确解进行比较，你将凭经验确定该方法的精度阶，并培养算法验证的基本技能。", "problem": "考虑各向同性程函方程（Eikonal equation），这是一种哈密顿-雅可比（Hamilton–Jacobi）偏微分方程，用于模拟以空间变化的速率进行的前沿传播。未知的到达时场 $T(x)$ 满足方程 $|\\nabla T(x)| = \\frac{1}{f(x)}$，其中 $f(x)$ 表示局部前沿速度。对于恒定速度 $f(x) \\equiv f_0$ 和位于 $x_s$ 的单一点源，解是径向对称的，并由最短路径的几何形状确定。在此设定下，设计并实施一个网格加密研究，以评估快速行进法（Fast Marching Method, FMM）对均匀二维网格上的程函方程进行离散化后的数值精度和观测到的精度阶。\n\n您的任务是编写一个完整的程序，该程序：\n- 在方形域 $[0,1] \\times [0,1]$ 上，使用间距为 $h$ 的均匀笛卡尔网格，通过一阶迎风、单调离散格式实现二维快速行进法。该离散格式必须从程函方程导出，并通过一个从较小到达时向较大到达时推进的接受机制来遵循因果关系。\n- 使用恒定速度 $f(x) \\equiv f_0$ 和一个到达时为零的单一点源，该点源精确位于网格节点上以避免亚网格投影误差。源点位置的选择必须确保其在测试套件的所有网格分辨率上都存在。\n- 对于恒速点源情况，从控制方程和最短路径的几何形状推导出解析解 $T_{\\text{exact}}(x)$，并用它来计算基于网格的误差范数。\n\n网格加密研究必须遵循以下要求：\n- 网格：使用均匀网格，每个维度上的点数为 $N \\in \\{33,65,129,257\\}$，因此网格间距为 $h = \\frac{1}{N-1}$。这确保了当 $N$ 为奇数时，坐标 $x = 0.5$ 始终是网格节点。\n- 误差范数：对于每个 $N$，计算数值解 $T_h$ 与解析解 $T_{\\text{exact}}$ 在所有网格节点上的离散 $L_1$、$L_2$ 和 $L_\\infty$ 误差范数。使用与积分范数一致的离散近似：\n  - $L_1$ 误差： $E_{1}(h) = h^2 \\sum_{i,j} |T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j})|$。\n  - $L_2$ 误差： $E_{2}(h) = \\sqrt{h^2 \\sum_{i,j} (T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j}))^2}$。\n  - $L_\\infty$ 误差： $E_{\\infty}(h) = \\max_{i,j} |T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j})|$。\n- 观测到的精度阶：对于一系列网格间距 $h_1  h_2  \\dots$，通过在对数-对数空间中计算连续网格级别之间误差趋势的斜率来定义观测阶 $p$：\n  $$p_{k} = \\frac{\\log\\left(\\frac{E(h_{k+1})}{E(h_{k})}\\right)}{\\log\\left(\\frac{h_{k+1}}{h_{k}}\\right)}.$$\n  对于每种范数，通过取测试套件中所有连续网格对的 $\\{p_{k}\\}$ 的中位数，报告一个鲁棒性增强的估计值。\n\n测试套件规范：\n- 案例A（理想情况）：$f_0 = 1$，源点位于域中心 $x_s = (0.5,0.5)$。\n- 案例B（速度变化）：$f_0 = 2$，源点位于域中心 $x_s = (0.5,0.5)$。\n- 案例C（几何边界情况）：$f_0 = 1$，源点位于域角落 $x_s = (0,0)$。\n\n解析解要求：您必须根据程函方程和最短路径的几何形状，从第一性原理出发确定恒定 $f_0$ 和单个源点 $x_s$ 的 $T_{\\text{exact}}(x)$。此解析解必须用于误差计算。\n\n最终输出格式：\n- 对于每个案例，计算三种范数 $L_1$、$L_2$ 和 $L_\\infty$ 在四个网格上的中位数观测阶。将三个案例的结果汇总为一个包含九个浮点数的列表，顺序为 $[p_{L_1}^{\\text{A}}, p_{L_2}^{\\text{A}}, p_{L_\\infty}^{\\text{A}}, p_{L_1}^{\\text{B}}, p_{L_2}^{\\text{B}}, p_{L_\\infty}^{\\text{B}}, p_{L_1}^{\\text{C}}, p_{L_2}^{\\text{C}}, p_{L_\\infty}^{\\text{C}}]$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[result_1,result_2,\\dots,result_9]$）。\n所有量均为无量纲；不需要物理单位。不涉及角度。将所有最终数值输出表示为浮点数。", "solution": "该问题要求实施一个网格加密研究，以确定求解程函方程的一阶快速行进法（FMM）的观测精度阶。该研究将在二维方形域上针对恒定波速和单一点源进行。\n\n### 1. 基本原理与解析解\n\n控制方程是各向同性程函方程：\n$$\n|\\nabla T(x)| = \\frac{1}{f(x)}\n$$\n其中 $T(x)$ 是传播前沿的到达时场，$f(x)$ 是前沿的局部速度。在这个问题中，速度是恒定的，$f(x) \\equiv f_0$。该方程描述了从源区域出发的最短传播时间。在恒定速度 $f_0$ 下，介质是均匀的，两点之间的最短路径是直线。走完此路径所需的时间是其欧几里得长度除以速度。\n\n给定位于 $x_s$ 处、初始到达时为 $T(x_s) = 0$ 的单一点源，任意其他点 $x$ 的到达时由从 $x_s$ 到 $x$ 的最短路径长度决定。对于恒定速度，该路径是连接它们的直线段。因此，解析解是源点到该点的欧几里得距离，再按慢度 $S_0 = 1/f_0$ 进行缩放：\n$$\nT_{\\text{exact}}(x) = \\frac{\\|x - x_s\\|_2}{f_0}\n$$\n对于点 $x = (x, y)$ 和源点 $x_s = (x_s, y_s)$，其显式表达式为：\n$$\nT_{\\text{exact}}(x, y) = \\frac{\\sqrt{(x-x_s)^2 + (y-y_s)^2}}{f_0}\n$$\n该精确解将作为计算数值误差的基准。除了在源点 $x=x_s$ 处存在一个锥形奇点外，它在所有地方都是光滑的。\n\n### 2. 数值离散与快速行进法\n\n我们使用在每个维度上有 $N$ 个点的均匀笛卡尔网格来离散化域 $[0,1] \\times [0,1]$，网格间距为 $h = 1/(N-1)$。令 $T_{i,j}$ 为 $T(ih, jh)$ 的数值近似值。\n\n程函方程平方后为 $(\\frac{\\partial T}{\\partial x})^2 + (\\frac{\\partial T}{\\partial y})^2 = S^2$，其中 $S = 1/f_0$ 是恒定慢度。必须使用一阶迎风、单调离散格式。这意味着 $T_{i,j}$ 的值仅使用其具有更小到达时的邻居节点的值来计算。FMM算法自然地强制执行了这种因果关系。偏导数的迎风离散格式为：\n$$\n\\left(\\max\\left(\\frac{T_{i,j}-T_{i-1,j}}{h}, -\\frac{T_{i+1,j}-T_{i,j}}{h}, 0\\right)\\right)^2 + \\left(\\max\\left(\\frac{T_{i,j}-T_{i,j-1}}{h}, -\\frac{T_{i,j+1}-T_{i,j}}{h}, 0\\right)\\right)^2 = S^2\n$$\n在FMM框架内，当更新 $T_{i,j}$ 时，其迎风邻居节点已被赋予其最终的、更小的到达时。令 $T_x = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_y = \\min(T_{i,j-1}, T_{i,j+1})$。根据两种情况，$T_{i,j}$ 的方程可以简化：\n\n1.  **一维更新**：如果前沿主要从一个方向（例如，$x$方向）到达 $(i,j)$，则更新模拟一个一维问题。这种情况发生在 $|T_x - T_y| \\ge hS$ 时。在这种情况下，更新公式为：\n    $$\n    T_{i,j} = \\min(T_x, T_y) + hS\n    $$\n\n2.  **二维更新**：如果前沿从一个同时包含 $x$ 和 $y$分量的方向到达，则必须求解一个二次方程。这种情况发生在 $|T_x - T_y|  hS$ 时。其基本方程是 $(T_{i,j} - T_x)^2 + (T_{i,j} - T_y)^2 = (hS)^2$。解出 $T_{i,j}$ 并取较大的根（对应于粘性解）可得：\n    $$\n    T_{i,j} = \\frac{T_x + T_y + \\sqrt{2(hS)^2 - (T_x - T_y)^2}}{2}\n    $$\n\n**快速行进法（FMM）**是一种按正确顺序求解离散化程函方程的高效算法。它使用一个最小优先队列，系统地将前沿从较小的到达时推进到较大的到达时。\n- **节点状态**：每个网格节点处于以下三种状态之一：`KNOWN`（已知，已计算最终时间）、`TRIAL`（试验，已计算暂定时间，位于传播前沿上）或 `UNSEEN`（未知，远离前沿）。\n- **初始化**：所有节点均为 `UNSEEN`，其 $T=\\infty$，除了源节点，其 $T=0$ 并标记为 `TRIAL`。\n- **算法**：\n    1. 一个最小优先队列存储所有按到达时排序的 `TRIAL` 节点。\n    2. 重复地从队列中提取具有最小到达时的 `TRIAL` 节点 $(i,j)$。\n    3. 将此节点标记为 `KNOWN`。\n    4. 对于 $(i,j)$ 的每个 `UNSEEN` 或 `TRIAL` 邻居，使用上述迎风离散格式计算新的到达时。\n    5. 如果新计算的时间小于邻居当前的时间，则更新邻居的时间并将其添加到优先队列中。\n\n### 3. 网格加密研究与误差分析\n\n执行网格加密研究以评估数值精度。理论精度阶 $p$ 通过 $E(h) \\approx C h^p$ 将误差 $E$ 与网格间距 $h$ 联系起来。通过在一系列连续加密的网格上计算误差，我们可以估计 $p$。\n\n- **网格**：在每个维度上有 $N \\in \\{33, 65, 129, 257\\}$ 个点的均匀网格，产生的网格间距 $h_k = 1/(N_k-1)$ 逐次减半。\n- **误差范数**：对于每个网格，通过比较数值解 $T_h$ 和在网格节点上求值的解析解 $T_{\\text{exact}}$ 来计算离散的 $L_1$、$L_2$ 和 $L_\\infty$ 误差范数。\n    - $L_1$ 误差： $E_{1}(h) = h^2 \\sum_{i,j} |T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j})|$\n    - $L_2$ 误差： $E_{2}(h) = \\sqrt{h^2 \\sum_{i,j} (T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j}))^2}$\n    - $L_\\infty$ 误差： $E_{\\infty}(h) = \\max_{i,j} |T_h(x_{i,j}) - T_{\\text{exact}}(x_{i,j})|$\n- **观测到的精度阶**：对于每种范数，在连续的网格级别 $h_k$ 和 $h_{k+1}$ 之间计算阶数 $p_k$：\n    $$\n    p_{k} = \\frac{\\log\\left(E(h_{k+1})/E(h_{k})\\right)}{\\log\\left(h_{k+1}/h_{k}\\right)}\n    $$\n由于 $h_{k+1}/h_k = 1/2$，这可以简化为 $p_k = -\\log_2(E(h_{k+1})/E(h_k))$。通过取序列 $\\{p_k\\}$ 的中位数，可以获得一个对阶数 $p$ 的鲁棒估计。对所有三个指定的测试案例执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef fast_marching(N, h, f0, source_idx):\n    \"\"\"\n    Implements the Fast Marching Method on a 2D uniform grid.\n\n    Args:\n        N (int): Number of grid points per dimension.\n        h (float): Grid spacing.\n        f0 (float): Constant wave speed.\n        source_idx (tuple): (row, col) indices of the source point.\n\n    Returns:\n        numpy.ndarray: A (N, N) array of arrival times.\n    \"\"\"\n    # 1. Initialization\n    T = np.full((N, N), np.inf, dtype=np.float64)\n    # States: 0=UNSEEN, 1=TRIAL, 2=KNOWN\n    states = np.zeros((N, N), dtype=np.uint8)\n    UNSEEN, TRIAL, KNOWN = 0, 1, 2\n    \n    pq = []  # Min-priority queue\n\n    slowness_h = h / f0\n\n    # Set source node\n    isrc, jsrc = source_idx\n    T[isrc, jsrc] = 0.0\n    states[isrc, jsrc] = TRIAL\n    heapq.heappush(pq, (0.0, isrc, jsrc))\n\n    # 2. Main loop\n    while pq:\n        time, i, j = heapq.heappop(pq)\n\n        # If a better time has been found since this entry was added, skip.\n        if time  T[i, j]:\n            continue\n\n        states[i, j] = KNOWN\n\n        # 3. Update neighbors\n        # Iterate over neighbors (_ni, _nj) of the current node (i, j)\n        for _ni, _nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            # Check if neighbor is within grid and not already finalized\n            if 0 = _ni  N and 0 = _nj  N and states[_ni, _nj] != KNOWN:\n                \n                # Calculate new tentative time for the neighbor (_ni, _nj)\n                # by solving its local Eikonal equation.\n                \n                # Get minimum arrival time from x-direction neighbors of (_ni, _nj)\n                t_x_min = np.inf\n                if _ni  0:\n                    t_x_min = min(t_x_min, T[_ni - 1, _nj])\n                if _ni  N - 1:\n                    t_x_min = min(t_x_min, T[_ni + 1, _nj])\n                \n                # Get minimum arrival time from y-direction neighbors of (_ni, _nj)\n                t_y_min = np.inf\n                if _nj  0:\n                    t_y_min = min(t_y_min, T[_ni, _nj - 1])\n                if _nj  N - 1:\n                    t_y_min = min(t_y_min, T[_ni, _nj + 1])\n                \n                # If neither neighbor has a finite time, we can't update yet.\n                if not (np.isfinite(t_x_min) or np.isfinite(t_y_min)):\n                    continue\n\n                # Determine whether to use 1D or 2D update\n                if abs(t_x_min - t_y_min) = slowness_h:\n                    t_new = min(t_x_min, t_y_min) + slowness_h\n                else:\n                    # Quadratic update\n                    discriminant = 2 * slowness_h**2 - (t_x_min - t_y_min)**2\n                    # Discriminant should be non-negative due to the condition above,\n                    # but floating point arithmetic may cause small negative values.\n                    discriminant = max(0, discriminant)\n                    t_new = (t_x_min + t_y_min + np.sqrt(discriminant)) / 2.0\n\n                # If the new time is an improvement, update and add to queue\n                if t_new  T[_ni, _nj]:\n                    T[_ni, _nj] = t_new\n                    if states[_ni, _nj] == UNSEEN:\n                        states[_ni, _nj] = TRIAL\n                    heapq.heappush(pq, (t_new, _ni, _nj))\n    \n    return T\n\ndef run_refinement_study(f0, source_coords):\n    \"\"\"\n    Performs a grid refinement study for a given case.\n\n    Args:\n        f0 (float): Constant wave speed.\n        source_coords (tuple): (x, y) coordinates of the source.\n\n    Returns:\n        list: A list of three median observed orders for L1, L2, Linf norms.\n    \"\"\"\n    grid_sizes = [33, 65, 129, 257]\n    errors = { \"l1\": [], \"l2\": [], \"linf\": [] }\n    h_values = []\n\n    for N in grid_sizes:\n        h = 1.0 / (N - 1)\n        h_values.append(h)\n\n        # Create grid\n        x = np.linspace(0.0, 1.0, N)\n        y = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(x, y, indexing='ij')\n\n        # Source index must be exactly on a node\n        isrc = int(round(source_coords[0] / h))\n        jsrc = int(round(source_coords[1] / h))\n\n        # Compute numerical solution\n        T_numerical = fast_marching(N, h, f0, (isrc, jsrc))\n        \n        # Compute analytic solution\n        T_analytic = np.sqrt((xx - source_coords[0])**2 + (yy - source_coords[1])**2) / f0\n        \n        # Compute errors\n        diff = np.abs(T_numerical - T_analytic)\n        \n        # L_infinity error\n        errors[\"linf\"].append(np.max(diff))\n        \n        # L1 error\n        errors[\"l1\"].append(h**2 * np.sum(diff))\n        \n        # L2 error\n        errors[\"l2\"].append(np.sqrt(h**2 * np.sum(diff**2)))\n\n    # Compute observed orders of accuracy\n    orders = []\n    log_h_ratio = np.log(0.5)\n    for norm in [\"l1\", \"l2\", \"linf\"]:\n        p_k = []\n        for i in range(len(grid_sizes) - 1):\n            # p_k = log(E_k+1 / E_k) / log(h_k+1 / h_k)\n            # handle cases where error is zero\n            if errors[norm][i+1]  0 and errors[norm][i]  0:\n                log_err_ratio = np.log(errors[norm][i+1] / errors[norm][i])\n                p_k.append(log_err_ratio / log_h_ratio)\n        \n        if not p_k:\n             # This can happen if error is consistently zero, implying perfect accuracy\n             # on the test grids. The theoretical order is then irrelevant.\n             # Or if there are not enough data points.\n             orders.append(np.nan)\n        else:\n             orders.append(np.median(p_k))\n\n    return orders\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite specification\n    test_cases = [\n        {'f0': 1.0, 'source_coords': (0.5, 0.5)},  # Case A\n        {'f0': 2.0, 'source_coords': (0.5, 0.5)},  # Case B\n        {'f0': 1.0, 'source_coords': (0.0, 0.0)},  # Case C\n    ]\n\n    all_results = []\n    for case in test_cases:\n        orders = run_refinement_study(case['f0'], case['source_coords'])\n        all_results.extend(orders)\n    \n    # Format a string for the final output\n    result_str = \",\".join([f\"{r:.7f}\" for r in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3391181"}, {"introduction": "在科学计算中，确保算法的正确性与算法本身同样重要。这项高级练习将挑战你为快速行进法的实现配备诊断工具，以检测对其基本原则（如因果性和堆序）的违反 [@problem_id:3391170]。学习构建这些检查，甚至有意复现失败，是开发稳健可靠的数值软件的关键技能。", "problem": "您需要为应用于程函偏微分方程（PDE）的快速行进法（FMM）实现诊断程序，以检测对因果关系和优先队列排序的违背。程函PDE定义了一个走时场 $T(x,y)$，它满足 $|\\nabla T(x,y)| \\, F(x,y) = 1$，其中 $F(x,y)$ 是一个正速度函数。快速行进法（FMM）是一种单程、迎风、标签设置算法，它从源点开始传播波前，按照估计到达时间的非递减顺序冻结网格节点。在此上下文中，因果关系意味着一旦一个节点被冻结，其值不应小于任何先前已冻结的值，并且局部更新必须遵守迎风约束。\n\n您的任务是生成一个单一、完整的程序，该程序：\n- 实现一个二维网格离散化，具有 $4$-连通性、均匀间距 $h = 1$ 和均匀速度 $F(x,y) \\equiv 1$。\n- 使用带有二叉最小堆以管理窄带的快速行进法（FMM）循环，从给定的源节点计算 $T$ 的离散近似。\n- 为该方法配备诊断程序以检测：\n  1. 堆序违背：当一个弹出节点的试探时间严格大于弹出时堆中存在的最小键值。\n  2. 局部更新中的非因果性：当为一个邻居新计算的试探时间严格小于其已接受邻居值中的最大值时（违背了迎风因果性）。\n  3. 非单调接受：当冻结值的序列不是非递减时（即，一个后面冻结的值严格小于一个前面冻结的值）。\n- 提供两个开关来复现故障：\n  - 一个堆损坏开关，启用时，会从堆中弹出一个非最小元素，以强制产生堆序违背。\n  - 一个更新损坏开关，启用时，会有意计算一个违背迎风因果性约束的试探时间，以强制产生非因果性。\n\n基于以下基本原理进行工作：\n- 程函PDE $|\\nabla T| \\, F = 1$，其中 $F(x,y)  0$。\n- 标签设置方法的迎风单调性要求：冻结值必须是非递减的。\n- 类Dijkstra标签设置方法的优先队列语义：节点必须按试探到达时间的非递减顺序进行冻结。\n\n您的实现不得依赖任何预先提供的公式。相反，您应基于这些原则推导并实现正确的迎风更新逻辑以计算试探时间，并添加仪器检查，以便在上述违规行为发生时标记它们。\n\n网格规格：\n- 使用一个大小为 $n \\times n$ 的方形网格，其中 $n \\ge 3$ 为整数，索引为 $(i,j)$，其中 $i,j \\in \\{0,1,\\dots,n-1\\}$。\n- 连通性为4邻域（轴对齐）。\n- 均匀网格间距 $h = 1$。\n- 均匀速度 $F(x,y) \\equiv 1$。\n\n状态：\n- 每个节点处于以下三种状态之一：`Far` (远) ($0$)、`Narrow` (窄) ($1$) 或 `Accepted` (已接受) ($2$)。\n\n诊断：\n- 设 $\\varepsilon = 10^{-12}$ 为诊断容差。如果满足以下任一条件，则记录一次违规：\n  1. 堆序违背：在一次弹出操作中，弹出的试探时间 $t_{\\text{pop}}$ 比最小堆键值 $t_{\\min}$ 大超过 $\\varepsilon$，即 $t_{\\text{pop}}  t_{\\min} + \\varepsilon$。\n  2. 局部非因果性：对于一个至少有一个已接受邻居的节点，其计算出的新试探值 $t_{\\text{new}}$ 严格小于其已接受邻居的最大值 $t_{\\max}$ 超过 $\\varepsilon$，即 $t_{\\text{new}}  t_{\\max} - \\varepsilon$。\n  3. 非单调接受：当冻结一个节点时，其值 $t_{\\text{pop}}$ 严格小于前一个冻结节点的值 $t_{\\text{prev}}$ 超过 $\\varepsilon$，即 $t_{\\text{pop}}  t_{\\text{prev}} - \\varepsilon$。\n\n复现性开关：\n- 堆损坏开关：启用时，弹出内部堆存储的最后一个元素而不是最小元素，以产生堆序违背。\n- 更新损坏开关：启用时，只要至少存在一个已接受的邻居，就将邻居的试探时间计算为 $t_{\\text{new}} = \\min(a,b) - \\tfrac{1}{2}$，其中 $a$ 和 $b$ 分别表示沿水平和垂直轴的最小已接受邻居值（仅使用可用轴）。这种构造会强制产生局部非因果性。\n\n测试套件：\n在以下四种情况下执行程序。每种情况返回一个布尔值三元组 $[b_{\\text{heap}}, b_{\\text{causal}}, b_{\\text{mono}}]$，指示是否检测到每种诊断条件。将结果汇总为单行，形式为这些三元组的列表。\n\n- 案例 1（常规正确路径）：\n  - $n = 21$。\n  - 源点：$(10,10)$。\n  - 堆损坏：禁用。\n  - 更新损坏：禁用。\n  - 预期行为：无违背。\n\n- 案例 2（堆序违背复现）：\n  - $n = 21$。\n  - 源点：$(10,10)$。\n  - 堆损坏：启用。\n  - 更新损坏：禁用。\n  - 预期行为：检测到堆序违背，并可能检测到非单调接受。\n\n- 案例 3（最小非因果性复现）：\n  - $n = 3$。\n  - 源点：$(1,1)$。\n  - 堆损坏：禁用。\n  - 更新损坏：启用。\n  - 预期行为：检测到非因果性和非单调接受。\n\n- 案例 4（多源点平局处理，正确）：\n  - $n = 9$。\n  - 源点：$(0,0)$ 和 $(8,8)$。\n  - 堆损坏：禁用。\n  - 更新损坏：禁用。\n  - 预期行为：无违背。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，每个元素是按案例1到4的精确顺序排列的诊断三元组，例如，$[[b_{1,\\text{heap}},b_{1,\\text{causal}},b_{1,\\text{mono}}],[b_{2,\\text{heap}},b_{2,\\text{causal}},b_{2,\\text{mono}}],[b_{3,\\text{heap}},b_{3,\\text{causal}},b_{3,\\text{mono}}],[b_{4,\\text{heap}},b_{4,\\text{causal}},b_{4,\\text{mono}}]]$。", "solution": "所提出的问题是有效的。这是一个定义明确的计算任务，来自偏微分方程数值解领域，具体涉及用于程函方程的快速行进法（FMM）。该问题在科学上是合理的、自洽的且客观的。所有必要的参数、边界条件和诊断标准都得到了精确的规定，从而可以进行唯一且可验证的实现。该任务需要对FMM算法进行非平凡的实现，包括一个优先队列和特定的诊断检查，使其成为科学计算中的一个实质性练习。\n\n解决方案首先推导程函方程的数值格式，然后将其嵌入到快速行进法中。诊断程序被整合进来，以在执行期间监控算法的内部一致性。\n\n### 基于原理的FMM更新规则推导\n\n程函方程是一个非线性偏微分方程，形式如下：\n$$\n|\\nabla T(x,y)| F(x,y) = 1\n$$\n其中 $T(x,y)$ 是未知的到达时间场，$F(x,y)  0$ 是给定的速度函数。对于本问题，给定均匀速度 $F(x,y) \\equiv 1$ 和均匀网格间距 $h=1$。方程简化为 $|\\nabla T| = 1$。\n\n我们将域离散化到节点为 $(i,j)$ 的网格上，其中 $T_{i,j}$ 表示该节点的到达时间。FMM的核心是一种迎风、标签设置格式。“迎风”意味着值 $T_{i,j}$ 仅使用来自具有更小到达时间的邻近节点的信息来计算，这对应于波前到达的方向。\n\n为了近似 $|\\nabla T|^2 = (\\frac{\\partial T}{\\partial x})^2 + (\\frac{\\partial T}{\\partial y})^2 = 1$，我们使用一阶、单边有限差分。对于节点 $(i,j)$，梯度分量近似为：\n$$\n\\frac{\\partial T}{\\partial x} \\approx \\frac{T_{i,j} - T_{x, \\text{min}}}{h} \\quad \\text{和} \\quad \\frac{\\partial T}{\\partial y} \\approx \\frac{T_{i,j} - T_{y, \\text{min}}}{h}\n$$\n其中 $T_{x, \\text{min}} = \\min(T_{i-1,j}, T_{i+1,j})$ 和 $T_{y, \\text{min}} = \\min(T_{i,j-1}, T_{i,j+1})$ 分别是沿每个轴的已计算（`Accepted`）邻居中的最小到达时间。我们分别用 $a$ 和 $b$ 表示这些最小值。当 $h=1$ 时，离散化的程函方程变为：\n$$\n(T_{i,j} - a)^2 + (T_{i,j} - b)^2 = 1\n$$\n这是一个关于未知时间 $T \\equiv T_{i,j}$ 的二次方程：\n$$\n2T^2 - 2(a+b)T + (a^2+b^2-1) = 0\n$$\n使用二次公式求解 $T$ 得：\n$$\nT = \\frac{2(a+b) \\pm \\sqrt{4(a+b)^2 - 8(a^2+b^2-1)}}{4} = \\frac{a+b \\pm \\sqrt{2 - (a-b)^2}}{2}\n$$\n为确保信息向前传播（$T  a$ 且 $T  b$），我们必须选择较大的根（`+`号）。这个二维更新仅在判别式为非负时有效，即 $2 - (a-b)^2 \\ge 0$，或 $|a-b| \\le \\sqrt{2}$。如果不满足此条件，则意味着提供解的特征线仅源于一个方向（对应于 $a$ 和 $b$ 中较小的那个）。在这种情况下，更新退化为一维形式，只有较近的已接受邻居有贡献：\n$$\n|\\nabla T| \\approx \\frac{T - \\min(a,b)}{h} = \\frac{1}{F} \\implies T = \\min(a,b) + \\frac{h}{F}\n$$\n当 $h=1$ 和 $F=1$ 时，即为 $T = \\min(a,b) + 1$。如果已接受的邻居仅存在于一个轴上，也必须使用类似的一维更新。一个节点的试探时间 $T_{new}$ 的最终迎风更新规则是：\n1.  确定x轴（$a$）和y轴（$b$）上最小的已接受邻居时间。\n2.  如果只有一个可用，比如 $a$（$b=\\infty$），则 $T_{new} = a + 1$。\n3.  如果两者都可用，计算判别式 $\\Delta = 2 - (a-b)^2$。\n4.  如果 $\\Delta  0$，更新退化：$T_{new} = \\min(a,b) + 1$。\n5.  如果 $\\Delta \\ge 0$，计算二次方程解 $T_{quad} = \\frac{a+b+\\sqrt{\\Delta}}{2}$。如果 $T_{quad}  \\max(a,b)$，则 $T_{new} = T_{quad}$。否则，二次形式违背了因果原理，我们必须再次使用更简单的更新 $T_{new} = \\min(a,b) + 1$。\n\n### 快速行进算法与诊断\n\nFMM在全局范围内协调这些局部更新。它类似于用于在图上寻找最短路径的Dijkstra算法。\n-   **状态**：每个网格节点处于以下三种状态之一：`Far`（未知时间）、`Narrow`（有试探时间）或 `Accepted`（时间已确定）。\n-   **数据结构**：一个`T`数组存储到达时间，初始化为无穷大。一个`states`数组跟踪节点状态。一个二叉最小堆，用作优先队列，存储`Narrow`带中的节点，按其试探到达时间排序。\n-   **初始化**：源节点被赋值 $T=0$，其状态设为`Narrow`，并被添加到堆中。所有其他节点都是`Far`。\n-   **迭代**：算法重复地从堆中提取具有最小时间的节点，通过将其状态设置为`Accepted`来冻结其值，并使用推导出的迎风规则更新其`Far`或`Narrow`邻居的试探时间。如果一个邻居的时间得到改进（减小），它将被添加（或在堆中更新）。\n\n诊断程序被集成到这个循环中：\n1.  **堆序违背**：从堆中弹出之前，记下最小键值 $t_{min}$。然后将弹出的键值 $t_{pop}$ 与之比较。如果 $t_{pop}  t_{min} + \\varepsilon$，则发生违背。这由 `heap_corruption` 开关测试，该开关强制弹出一个非最小元素。\n2.  **非单调接受**：一个变量 $t_{prev}$ 跟踪最后一个已接受节点的时间。每次一个新节点以时间 $t_{pop}$ 被接受时，如果 $t_{pop}  t_{prev} - \\varepsilon$，则标记一个违背。这样的事件是违背类Dijkstra接受顺序的直接后果，这可能是由堆序违背或不正确（非因果）的局部时间更新引起的。\n3.  **局部非因果性**：当为邻居计算新的试探时间 $t_{new}$ 时，我们还找到其所有已接受邻居中的最大时间 $t_{max}$。如果 $t_{new}  t_{max} - \\varepsilon$，则标记一个违背。这意味着计算出的时间与到达时间必须沿特征曲线非递减的原则不一致。这由 `update_corruption` 开关测试，该开关计算一个被人为减小的时间。\n\n这些诊断提供了一种鲁棒的方法，用于验证快速行进法的基本算法不变量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\n# This program must not rely on any libraries outside the specified environment.\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: n=21, source=(10,10), correct execution\n        {'n': 21, 'sources': [(10, 10)], 'heap_corrupt': False, 'update_corrupt': False},\n        # Case 2: n=21, source=(10,10), heap corruption\n        {'n': 21, 'sources': [(10, 10)], 'heap_corrupt': True, 'update_corrupt': False},\n        # Case 3: n=3, source=(1,1), update corruption\n        {'n': 3, 'sources': [(1, 1)], 'heap_corrupt': False, 'update_corrupt': True},\n        # Case 4: n=9, sources=(0,0), (8,8), multi-source correct\n        {'n': 9, 'sources': [(0, 0), (8, 8)], 'heap_corrupt': False, 'update_corrupt': False},\n    ]\n\n    results = []\n    for case in test_cases:\n        fmm_runner = FastMarcher(\n            n=case['n'],\n            sources=case['sources'],\n            heap_corrupt=case['heap_corrupt'],\n            update_corrupt=case['update_corrupt']\n        )\n        diag_results = fmm_runner.run()\n        results.append(diag_results)\n    \n    # Final print statement in the exact required format.\n    # e.g., [[True,False,False],[False,True,True],...]\n    result_str = '[' + ','.join(f'[{v[0]},{v[1]},{v[2]}]' for v in results) + ']'\n    print(result_str.replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\n\nclass FastMarcher:\n    \"\"\"\n    Implements the Fast Marching Method with diagnostic checks.\n    \"\"\"\n    def __init__(self, n, sources, heap_corrupt, update_corrupt):\n        self.n = n\n        self.sources = sources\n        self.heap_corrupt = heap_corrupt\n        self.update_corrupt = update_corrupt\n        \n        self.h = 1.0  # Grid spacing\n        self.F = 1.0  # Speed\n        self.eps = 1e-12\n\n        # State constants\n        self.FAR = 0\n        self.NARROW = 1\n        self.ACCEPTED = 2\n        \n        # Initialize grid data\n        self.T = np.full((n, n), np.inf, dtype=np.float64)\n        self.states = np.full((n, n), self.FAR, dtype=np.int8)\n        self.narrow_band = []  # Min-heap\n\n        # Diagnostic flags\n        self.b_heap = False\n        self.b_causal = False\n        self.b_mono = False\n        \n        # For non-monotone check\n        self.t_prev = -1.0\n\n    def _calculate_tentative_time(self, i, j):\n        \"\"\"\n        Calculates the tentative arrival time at node (i, j) using upwind neighbors.\n        \"\"\"\n        accepted_neighbors_times = []\n        x_vals, y_vals = [], []\n        \n        neighbors = [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]\n        x_dir_neighbors = [(i - 1, j), (i + 1, j)]\n        \n        for ni, nj in neighbors:\n            if 0 = ni  self.n and 0 = nj  self.n and self.states[ni, nj] == self.ACCEPTED:\n                t_neighbor = self.T[ni, nj]\n                accepted_neighbors_times.append(t_neighbor)\n                if (ni, nj) in x_dir_neighbors:\n                    x_vals.append(t_neighbor)\n                else:\n                    y_vals.append(t_neighbor)\n        \n        a = min(x_vals) if x_vals else np.inf\n        b = min(y_vals) if y_vals else np.inf\n\n        # --- Update Corruption Toggle ---\n        if self.update_corrupt and accepted_neighbors_times:\n            t_new = min(a, b) - 0.5\n        else:\n            # --- Standard Upwind Update Rule ---\n            if a == np.inf and b == np.inf:\n                 return np.inf # Should not be reachable from an accepted node\n            \n            if a == np.inf or b == np.inf: # 1D update\n                t_new = min(a, b) + self.h / self.F\n            else: # 2D update\n                # Discriminant of the quadratic equation\n                delta = (self.h / self.F)**2 * 2 - (a - b)**2\n                if delta  0:\n                    t_new = min(a, b) + self.h / self.F\n                else:\n                    t_quad = (a + b + np.sqrt(delta)) / 2.0\n                    if t_quad  max(a, b):\n                        t_new = t_quad\n                    else:\n                        t_new = min(a, b) + self.h / self.F\n\n        # --- Local Non-causality Diagnostic ---\n        if accepted_neighbors_times:\n            t_max = max(accepted_neighbors_times)\n            if t_new  t_max - self.eps:\n                self.b_causal = True\n        \n        return t_new\n\n    def run(self):\n        \"\"\"\n        Executes the FMM algorithm.\n        \"\"\"\n        # Initialization\n        for si, sj in self.sources:\n            self.T[si, sj] = 0.0\n            self.states[si, sj] = self.NARROW\n            heapq.heappush(self.narrow_band, (0.0, (si, sj)))\n\n        # Main loop\n        while self.narrow_band:\n            # --- Heap-order Violation Diagnostic ---\n            if self.heap_corrupt and len(self.narrow_band)  1:\n                t_min_in_heap = self.narrow_band[0][0]\n                # Pop a non-minimum element (last in internal storage)\n                t_pop, (i_pop, j_pop) = self.narrow_band.pop()\n                if t_pop  t_min_in_heap + self.eps:\n                    self.b_heap = True\n            else:\n                t_pop, (i_pop, j_pop) = heapq.heappop(self.narrow_band)\n\n            if self.states[i_pop, j_pop] == self.ACCEPTED:\n                continue\n            \n            self.states[i_pop, j_pop] = self.ACCEPTED\n\n            # --- Non-monotone Acceptance Diagnostic ---\n            if self.t_prev = 0 and t_pop  self.t_prev - self.eps:\n                self.b_mono = True\n            self.t_prev = t_pop\n\n            # Update neighbors\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                i_n, j_n = i_pop + di, j_pop + dj\n\n                if not (0 = i_n  self.n and 0 = j_n  self.n):\n                    continue\n                \n                if self.states[i_n, j_n] == self.ACCEPTED:\n                    continue\n\n                t_new = self._calculate_tentative_time(i_n, j_n)\n\n                if t_new  self.T[i_n, j_n]:\n                    self.T[i_n, j_n] = t_new\n                    self.states[i_n, j_n] = self.NARROW\n                    # Add to heap even if it's an update (standard FMM practice with vanilla heapq)\n                    heapq.heappush(self.narrow_band, (t_new, (i_n, j_n)))\n        \n        return [self.b_heap, self.b_causal, self.b_mono]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3391170"}]}