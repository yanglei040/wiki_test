{"hands_on_practices": [{"introduction": "在解决一个数值问题时，首要步骤是能够可靠地诊断它。本练习提供了一种动手实践的方法，用以量化标准有限元中的体积锁定现象[@problem_id:3418041]。通过比较一种纯位移列式和一种稳定的混合位移-压力列式，您将看到后者如何正确地施加不可压缩性约束，从而切实地展示为何需要更高级的列式。", "problem": "考虑单位正方形域 $[0,1]\\times[0,1]$ 上的平面应变线性弹性边值问题，其单位外法线为 $\\boldsymbol{n}$，在整个边界上施加均匀静水牵引力 $-p_0\\,\\boldsymbol{n}$。其强形式由平衡方程和本构关系组成\n$$\n-\\nabla\\cdot\\boldsymbol{\\sigma}=\\boldsymbol{0}\\quad\\text{在 }[0,1]^2\\text{ 内},\\qquad \\boldsymbol{\\sigma}=2\\mu\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})+\\lambda\\,\\nabla\\cdot\\boldsymbol{u}\\,\\boldsymbol{I},\n$$\n其中 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u})=\\tfrac{1}{2}(\\nabla \\boldsymbol{u}+\\nabla \\boldsymbol{u}^\\top)$ 为小应变张量，$\\mu>0$ 为剪切模量，$\\lambda\\ge 0$ 为拉梅参数，$\\kappa=\\lambda+\\frac{2\\mu}{3}$ 为体积模量，且在 $\\partial([0,1]^2)$ 上有诺伊曼边界条件 $\\boldsymbol{\\sigma}\\boldsymbol{n}=-p_0\\,\\boldsymbol{n}$。假设采用无量纲单位（无需进行物理单位转换），并设置 $\\mu=1$。\n\n在连续问题中，受均匀静水载荷作用时，体积应变 $\\nabla\\cdot\\boldsymbol{u}$ 在空间上是均匀的，等于 $-\\tfrac{p_0}{\\kappa}$，当 $\\kappa\\to\\infty$ 时趋于 $0$。然而，在数值离散化中，纯位移格式会表现出体积锁定现象：在网格尺寸固定的情况下，当 $\\kappa\\to\\infty$ 时，离散散度 $\\nabla\\cdot\\boldsymbol{u}_h$ 无法趋近于 $0$。而适当的混合格式能更稳健地施加近不可压缩约束。\n\n您的任务是在一个包含 $n\\times n$ 个双线性 ($\\mathsf{Q}_1$) 单元的结构化四边形网格上，实现两种有限元法 (FEM) 离散格式：\n- 一种纯位移格式，使用平面应变中各向同性弹性的标准对称双线性形式。在采用工程剪应变 $\\gamma_{xy}=2\\varepsilon_{xy}$ 的 Voigt 记法中，该双线性形式使用的矩阵条目为 $D_{11}=\\lambda+2\\mu$、$D_{12}=\\lambda$ 和 $D_{33}=\\mu$。\n- 一种稳定化混合位移-压力格式，其中位移和压力采用同阶的双线性 ($\\mathsf{Q}_1$) 离散空间。其弱形式分为偏量部分和对散度的约束：\n$$\n\\text{求 }(\\boldsymbol{u}_h,p_h)\\text{ 使得}\\quad\n2\\mu\\int\\boldsymbol{\\varepsilon}(\\boldsymbol{u}_h):\\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h)\\,\\mathrm{d}x\n-\\int p_h\\,\\nabla\\cdot \\boldsymbol{v}_h\\,\\mathrm{d}x\n+\\int q_h\\,\\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x\n-\\frac{1}{\\kappa}\\int p_h\\,q_h\\,\\mathrm{d}x\n+\\gamma h^2\\int \\nabla p_h\\cdot\\nabla q_h\\,\\mathrm{d}x\n= \\int_{\\partial\\Omega}(-p_0\\,\\boldsymbol{n})\\cdot\\boldsymbol{v}_h\\,\\mathrm{d}s,\n$$\n对所有测试对 $(\\boldsymbol{v}_h,q_h)$ 成立，其中 $h=1/n$ 且 $\\gamma>0$ 是一个小的稳定化参数。纯偏量刚度使用 $D_{11}=2\\mu$、$D_{12}=0$ 和 $D_{33}=\\mu$。\n\n对于两种格式，都通过线积分在整个边界上施加静水诺伊曼牵引力 $-p_0\\,\\boldsymbol{n}$，并通过在左下角节点约束位移 $\\boldsymbol{u}_h=\\boldsymbol{0}$ 和在右下角节点约束竖向位移分量为零来移除刚体模态。在混合格式中，不要约束压力场。\n\n基于局部质量守恒定义用于判断锁定的诊断量：对于网格中的每个单元 $K$，使用 $2\\times 2$ 高斯积分计算单元体积变化\n$$\nI_K = \\int_K \\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x,\n$$\n对于静水载荷下的完全不可压缩响应，$I_K$ 对所有 $K$ 都应为 $0$。如果当 $\\kappa\\to\\infty$ 时，在固定的 $h$ 下，集合 $\\{I_K\\}$ 未能一致趋近于 $0$，则称该方法发生锁定。如果当 $\\kappa$ 很大时，随着网格加密，$I_K$ 以 $\\mathcal{O}(h)$ 的速率衰减，则该方法为非锁定方法。\n\n实现这两种离散格式，使用稀疏线性代数方法组装并求解线性系统，然后计算诊断聚合量\n$$\nA = \\frac{1}{N_{\\mathrm{el}}}\\sum_{K} |I_K|,\n$$\n其中 $N_{\\mathrm{el}}=n^2$ 是单元数量。使用无量纲数，并将 $A$ 表示为浮点数。\n\n您的程序必须评估以下测试套件：\n- 测试用例 1：纯位移格式，$n=4$，$\\kappa=10^6$，$p_0=1$。\n- 测试用例 2：混合格式，$n=4$，$\\kappa=10^6$，$p_0=1$，稳定化参数 $\\gamma=10^{-3}$。\n- 测试用例 3：混合格式，$n=8$，$\\kappa=10^6$，$p_0=1$，稳定化参数 $\\gamma=10^{-3}$。\n- 测试用例 4：纯位移格式，$n=8$，$\\kappa=10^6$，$p_0=1$。\n- 测试用例 5：纯位移格式，$n=4$，$\\kappa=10^3$，$p_0=1$。\n\n对于每个测试用例，计算并返回上述定义的聚合量 $A$。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”），每个结果都格式化为标准 Python 浮点数。", "solution": "用户的请求是一个有效的计算力学问题。它要求实现两种不同的有限元法 (FEM) 格式，用于解决一个平面应变线性弹性问题，以研究体积锁定现象。该问题具有科学依据、是适定的，并且为获得唯一解提供了所有必要的参数和条件。\n\n### 1. 问题描述\n\n该问题定义在单位正方形域 $\\Omega = [0,1]^2$ 上。控制方程为线性弹性方程：\n$$\n-\\nabla\\cdot\\boldsymbol{\\sigma}=\\boldsymbol{0}\\quad\\text{在 }\\Omega\\text{ 内}\n$$\n应力张量 $\\boldsymbol{\\sigma}$ 通过各向同性材料的本构律与位移场 $\\boldsymbol{u}$ 相关联：\n$$\n\\boldsymbol{\\sigma} = 2\\mu\\,\\boldsymbol{\\varepsilon}(\\boldsymbol{u})+\\lambda\\,\\nabla\\cdot\\boldsymbol{u}\\,\\boldsymbol{I}\n$$\n其中 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u})=\\tfrac{1}{2}(\\nabla \\boldsymbol{u}+\\nabla \\boldsymbol{u}^\\top)$ 是小应变张量，$\\mu$ 是剪切模量，$\\lambda$ 是第一个拉梅参数。材料在整个边界 $\\partial\\Omega$ 上受到均匀静水压力 $p_0$ 的作用，这对应于一个诺伊曼边界条件 $\\boldsymbol{\\sigma}\\boldsymbol{n}=-p_0\\,\\boldsymbol{n}$。\n\n给定 $\\mu=1$ 以及体积模量 $\\kappa = \\lambda + \\frac{2\\mu}{3}$。这使我们能够用给定的 $\\kappa$ 和 $\\mu$ 来表示 $\\lambda$：$\\lambda = \\kappa - \\frac{2}{3}$。该问题考虑近不可压缩极限，即 $\\kappa \\to \\infty$，这意味着 $\\lambda \\to \\infty$。\n\n为了确保解的唯一性，必须抑制刚体运动（二维中的两种平移和一种旋转）。这通过施加狄利克雷边界条件来实现：$\\boldsymbol{u}(0,0) = \\boldsymbol{0}$ 和 $u_y(1,0) = 0$。\n\n### 2. 有限元离散化\n\n该区域被离散化为一个由 $n \\times n$ 个四边形单元组成的结构化网格。所有场变量都使用双线性形函数 ($\\mathsf{Q}_1$)。对于一个通用单元 $K$，位移场被插值为 $\\boldsymbol{u}_h(\\boldsymbol{x}) = \\sum_{i=1}^{4} N_i(\\boldsymbol{x}) \\boldsymbol{d}_i$，其中 $N_i$ 是形函数，$\\boldsymbol{d}_i$ 是节点位移向量。\n\n#### 2.1. 格式1：纯位移\n\n从虚功原理推导出的标准弱形式是：找到 $\\boldsymbol{u}_h$，使得对于所有容许虚位移 $\\boldsymbol{v}_h$：\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma}(\\boldsymbol{u}_h) : \\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h) \\, \\mathrm{d}x = \\int_{\\partial\\Omega} (-p_0\\boldsymbol{n}) \\cdot \\boldsymbol{v}_h \\, \\mathrm{d}s\n$$\n这导出了一个线性方程组 $[K]\\{U\\} = \\{F\\}$，其中 $\\{U\\}$ 是全局节点位移向量。单元刚度矩阵 $K_e$ 通过在单元域上积分计算得出：\n$$\nK_e = \\int_{K} B^T D B \\, \\mathrm{d}x\n$$\n其中 $B$ 是离散应变-位移矩阵，$D$ 是平面应变的材料本构矩阵。在应力 $\\{\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}\\}$ 和工程应变 $\\{\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}\\}$ 的 Voigt 记法中，$D$ 矩阵为：\n$$\nD = \\begin{bmatrix} \\lambda+2\\mu  \\lambda  0 \\\\ \\lambda  \\lambda+2\\mu  0 \\\\ 0  0  \\mu \\end{bmatrix}\n$$\n力向量 $\\{F\\}$ 由边界单元上的线积分组装而成。\n\n#### 2.2. 格式2：稳定化混合位移-压力 (u-p)\n\n该格式引入一个独立的压力场 $p_h$ 来施加不可压缩约束。位移场和压力场使用相同的双线性 ($\\mathsf{Q}_1$) 基进行近似。由于这种选择不满足 Ladyzhenskaya-Babuška-Brezzi (LBB) inf-sup 条件，因此需要添加一个稳定项。指定的弱形式为：找到 $(\\boldsymbol{u}_h, p_h)$，使得对于所有测试函数 $(\\boldsymbol{v}_h, q_h)$：\n$$\n2\\mu\\int\\boldsymbol{\\varepsilon}(\\boldsymbol{u}_h):\\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h)\\,\\mathrm{d}x\n-\\int p_h\\,\\nabla\\cdot \\boldsymbol{v}_h\\,\\mathrm{d}x\n+\\int q_h\\,\\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x\n-\\frac{1}{\\kappa}\\int p_h\\,q_h\\,\\mathrm{d}x\n+\\gamma h^2\\int \\nabla p_h\\cdot\\nabla q_h\\,\\mathrm{d}x\n= \\int_{\\partial\\Omega}(-p_0\\,\\boldsymbol{n})\\cdot\\boldsymbol{v}_h\\,\\mathrm{d}s\n$$\n这会导出一个更大的鞍点线性系统，形式如下：\n$$\n\\begin{bmatrix} K_{uu}  -G^T \\\\ G  -\\frac{1}{\\kappa}M_p + K_{stab} \\end{bmatrix}\n\\begin{Bmatrix} U \\\\ P \\end{Bmatrix}\n= \\begin{Bmatrix} F_u \\\\ 0 \\end{Bmatrix}\n$$\n矩阵块对应于：\n- $K_{uu}$：来自 $2\\mu\\int\\boldsymbol{\\varepsilon}(\\boldsymbol{u}_h):\\boldsymbol{\\varepsilon}(\\boldsymbol{v}_h)$ 项的刚度。\n- $G$：来自 $\\int q_h\\,\\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x$ 的梯度/散度耦合矩阵。\n- $M_p$：来自 $\\int p_h\\,q_h\\,\\mathrm{d}x$ 的压力质量矩阵。\n- $K_{stab}$：压力稳定化矩阵（一个缩放的拉普拉斯算子），来自 $\\int \\nabla p_h\\cdot\\nabla q_h\\,\\mathrm{d}x$。\n\n### 3. 实现细节\n\n- **积分**：所有单元积分（用于刚度矩阵、质量矩阵和力向量）都在参考单元 $[-1,1]^2$ 上使用 $2 \\times 2$ 高斯积分进行数值计算。边界牵引力的线积分使用 2 点一维高斯积分进行计算。\n- **组装**：计算单元级矩阵和向量，然后将它们组装成全局稀疏矩阵（`scipy.sparse.lil_matrix`）和向量。\n- **线性求解**：通过将系统划分为自由和固定自由度来施加狄利克雷约束。使用 `scipy.sparse.linalg.spsolve` 求解得到的自由度缩减系统。\n- **诊断量**：求解位移场 $\\boldsymbol{u}_h$ 后，对每个单元 $K$ 使用 $2 \\times 2$ 高斯积分计算单元体积变化 $I_K = \\int_K \\nabla\\cdot\\boldsymbol{u}_h\\,\\mathrm{d}x$。最终的诊断量是这些变化的绝对值的平均值，$A = \\frac{1}{N_{\\mathrm{el}}}\\sum_{K} |I_K|$。\n\n预计纯位移格式会表现出锁定现象，即对于固定的网格，随着 $\\kappa$ 的增加，$A$ 保持较大值。混合格式旨在减轻此问题，$A$ 值应显著减小，并表现出更好的收敛特性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef get_quadrature_2d():\n    \"\"\"Returns 2x2 Gauss quadrature points and weights on [-1,1]^2.\"\"\"\n    points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    weights = [1.0, 1.0]\n    quad_points = np.array([(p, q) for q in points for p in points])\n    quad_weights = np.array([w * v for v in weights for w in weights])\n    return quad_points, quad_weights\n\ndef get_quadrature_1d():\n    \"\"\"Returns 2-point Gauss quadrature points and weights on [-1,1].\"\"\"\n    points = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    weights = [1.0, 1.0]\n    return points, weights\n\ndef get_shape_functions(xi, eta):\n    \"\"\"Returns Q1 shape functions and their gradients on the reference element.\"\"\"\n    N = 0.25 * np.array([(1.0 - xi) * (1.0 - eta),\n                         (1.0 + xi) * (1.0 - eta),\n                         (1.0 + xi) * (1.0 + eta),\n                         (1.0 - xi) * (1.0 + eta)])\n    dN_dxi = 0.25 * np.array([-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)])\n    dN_deta = 0.25 * np.array([-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)])\n    return N, dN_dxi, dN_deta\n\ndef run_fem_analysis(formulation, n, kappa, p0, gamma=0.0, mu=1.0):\n    \"\"\"Main FEM analysis function for both displacement-only and mixed formulations.\"\"\"\n    # 1. Mesh Generation\n    h = 1.0 / n\n    num_nodes = (n + 1)**2\n    num_elems = n**2\n    nodes = np.array([[i * h, j * h] for j in range(n + 1) for i in range(n + 1)], dtype=float)\n    elements = np.array([[j * (n + 1) + i, j * (n + 1) + i + 1, (j + 1) * (n + 1) + i + 1, (j + 1) * (n + 1) + i]\n                         for j in range(n) for i in range(n)], dtype=int)\n\n    # 2. DOF and Matrix Setup\n    num_u_dofs = 2 * num_nodes\n    if formulation == 'displacement':\n        total_dofs = num_u_dofs\n    elif formulation == 'mixed':\n        total_dofs = 3 * num_nodes\n    else:\n        raise ValueError(\"Unknown formulation\")\n\n    K_global = lil_matrix((total_dofs, total_dofs))\n    F_global = np.zeros(total_dofs)\n\n    # 3. Material and quadrature setup\n    if formulation == 'displacement':\n        lam = kappa - 2.0 * mu / 3.0\n        D = np.array([[lam + 2 * mu, lam, 0.0],\n                      [lam, lam + 2 * mu, 0.0],\n                      [0.0, 0.0, mu]])\n    else:  # mixed\n        D_dev = np.array([[2 * mu, 0.0, 0.0],\n                          [0.0, 2 * mu, 0.0],\n                          [0.0, 0.0, mu]])\n    \n    quad_points_2d, quad_weights_2d = get_quadrature_2d()\n\n    # 4. Assembly loop over elements\n    for el_nodes_indices in elements:\n        el_coords = nodes[el_nodes_indices]\n        u_dofs = np.ravel([[2 * i, 2 * i + 1] for i in el_nodes_indices])\n\n        # Displacement-only formulation assembly\n        if formulation == 'displacement':\n            Ke = np.zeros((8, 8))\n            for qp, qw in zip(quad_points_2d, quad_weights_2d):\n                _, dN_dxi, dN_deta = get_shape_functions(qp[0], qp[1])\n                J = np.dot(np.array([dN_dxi, dN_deta]), el_coords)\n                detJ = np.linalg.det(J)\n                dN_dxy = np.linalg.solve(J.T, np.array([dN_dxi, dN_deta]))\n                \n                B = np.zeros((3, 8))\n                for i in range(4):\n                    B[0, 2 * i] = dN_dxy[0, i]\n                    B[1, 2 * i + 1] = dN_dxy[1, i]\n                    B[2, 2 * i] = dN_dxy[1, i]\n                    B[2, 2 * i + 1] = dN_dxy[0, i]\n                \n                Ke += qw * (B.T @ D @ B) * detJ\n            K_global[np.ix_(u_dofs, u_dofs)] += Ke\n\n        # Mixed formulation assembly\n        elif formulation == 'mixed':\n            p_dofs = el_nodes_indices\n            global_p_dofs = num_u_dofs + p_dofs\n            \n            Kuu_e = np.zeros((8, 8))\n            G_e = np.zeros((4, 8))\n            Mp_e = np.zeros((4, 4))\n            Ks_e = np.zeros((4, 4))\n\n            for qp, qw in zip(quad_points_2d, quad_weights_2d):\n                N, dN_dxi, dN_deta = get_shape_functions(qp[0], qp[1])\n                J = np.dot(np.array([dN_dxi, dN_deta]), el_coords)\n                detJ = np.linalg.det(J)\n                dN_dxy = np.linalg.solve(J.T, np.array([dN_dxi, dN_deta]))\n\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    B[0, 2 * i] = dN_dxy[0, i]\n                    B[1, 2 * i + 1] = dN_dxy[1, i]\n                    B[2, 2 * i] = dN_dxy[1, i]\n                    B[2, 2 * i + 1] = dN_dxy[0, i]\n                \n                Kuu_e += qw * (B.T @ D_dev @ B) * detJ\n                \n                for i in range(4):\n                    for j in range(4):\n                        G_e[i, 2*j]   += qw * N[i] * dN_dxy[0, j] * detJ\n                        G_e[i, 2*j+1] += qw * N[i] * dN_dxy[1, j] * detJ\n                \n                Mp_e += qw * np.outer(N, N) * detJ\n                Ks_e += qw * (dN_dxy.T @ dN_dxy) * detJ\n\n            K_global[np.ix_(u_dofs, u_dofs)] += Kuu_e\n            K_global[np.ix_(u_dofs, global_p_dofs)] -= G_e.T\n            K_global[np.ix_(global_p_dofs, u_dofs)] += G_e\n            \n            pp_block = (-1.0/kappa) * Mp_e + gamma * (h**2) * Ks_e\n            K_global[np.ix_(global_p_dofs, global_p_dofs)] += pp_block\n\n    # 5. Assemble Force Vector from Neumann BC\n    F_u = np.zeros(num_u_dofs)\n    q1d_pts, q1d_wts = get_quadrature_1d()\n\n    for j in range(n):\n        for i in range(n):\n            el_nodes = elements[j * n + i]\n            el_dofs = np.ravel([[2 * k, 2 * k + 1] for k in el_nodes])\n            \n            # Bottom edge (y=0)\n            if j == 0:\n                load = np.array([0., p0])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(qp, -1.0)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n            # Top edge (y=1)\n            if j == n - 1:\n                load = np.array([0., -p0])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(qp, 1.0)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n            # Left edge (x=0)\n            if i == 0:\n                load = np.array([p0, 0.])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(-1.0, qp)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n            # Right edge (x=1)\n            if i == n - 1:\n                load = np.array([-p0, 0.])\n                for qp, qw in zip(q1d_pts, q1d_wts):\n                    N, _, _ = get_shape_functions(1.0, qp)\n                    for k in range(4): F_u[el_dofs[2*k:2*k+2]] += qw * N[k] * load * (h / 2.0)\n    F_global[:num_u_dofs] = F_u\n\n    # 6. Apply Displacement Constraints and Solve\n    fixed_dofs = np.array([0, 1, 2 * n + 1])\n    all_dofs = np.arange(total_dofs)\n    free_dofs = np.setdiff1d(all_dofs, fixed_dofs)\n\n    K_free = K_global[np.ix_(free_dofs, free_dofs)].tocsr()\n    F_free = F_global[free_dofs]\n\n    Sol_free = spsolve(K_free, F_free)\n\n    Sol = np.zeros(total_dofs)\n    Sol[free_dofs] = Sol_free\n    U = Sol[:num_u_dofs]\n\n    # 7. Post-processing: Compute Diagnostic A\n    total_vol_change_abs_sum = 0.0\n    for el_nodes_indices in elements:\n        el_coords = nodes[el_nodes_indices]\n        el_u_dofs = np.ravel([[2 * i, 2 * i + 1] for i in el_nodes_indices])\n        el_U = U[el_u_dofs]\n        \n        I_K = 0.0\n        for qp, qw in zip(quad_points_2d, quad_weights_2d):\n            _, dN_dxi, dN_deta = get_shape_functions(qp[0], qp[1])\n            J = np.dot(np.array([dN_dxi, dN_deta]), el_coords)\n            detJ = np.linalg.det(J)\n            dN_dxy = np.linalg.solve(J.T, np.array([dN_dxi, dN_deta]))\n            \n            div_u_h = 0.0\n            for i in range(4):\n                div_u_h += dN_dxy[0, i] * el_U[2*i] + dN_dxy[1, i] * el_U[2*i+1]\n            I_K += qw * div_u_h * detJ\n        \n        total_vol_change_abs_sum += np.abs(I_K)\n        \n    A = total_vol_change_abs_sum / num_elems\n    return A\n\ndef solve():\n    test_cases = [\n        {'formulation': 'displacement', 'n': 4, 'kappa': 1e6, 'p0': 1.0},\n        {'formulation': 'mixed', 'n': 4, 'kappa': 1e6, 'p0': 1.0, 'gamma': 1e-3},\n        {'formulation': 'mixed', 'n': 8, 'kappa': 1e6, 'p0': 1.0, 'gamma': 1e-3},\n        {'formulation': 'displacement', 'n': 8, 'kappa': 1e6, 'p0': 1.0},\n        {'formulation': 'displacement', 'n': 4, 'kappa': 1e3, 'p0': 1.0},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_fem_analysis(**params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3418041"}, {"introduction": "在了解了混合方法如何解决锁定问题之后，我们现在将探索一种流行且计算效率更高的替代方法：选择性减缩积分。本练习将引导您进行谱分析，以理解该技术的工作原理，同时揭示其潜在的副作用——产生非物理的“沙漏”模式[@problem_id:3418037]。这项练习对于培养对许多数值稳定技术固有权衡的批判性眼光至关重要。", "problem": "考虑在单位正方形域上的平面应变二维线性弹性问题，材料为各向同性，其参数为杨氏模量 $E$ 和泊松比 $\\nu$。使用标准的 $Q_1$（双线性）有限元离散，网格为 $N_x \\times N_y$ 个单元的结构化矩形网格。控制方程源自最小势能原理：寻找使总势能最小化的位移场 $\\boldsymbol{u}$\n$$\n\\Pi(\\boldsymbol{u}) = \\int_{\\Omega} \\left( \\mu \\, \\boldsymbol{\\epsilon}_{\\text{dev}} : \\boldsymbol{\\epsilon}_{\\text{dev}} + \\tfrac{1}{2} \\kappa \\, (\\operatorname{tr}(\\boldsymbol{\\epsilon}))^2 \\right)\\, \\mathrm{d}\\Omega \\;-\\; \\int_{\\Omega} \\boldsymbol{b}\\cdot \\boldsymbol{u}\\,\\mathrm{d}\\Omega \\;-\\; \\int_{\\Gamma_N} \\boldsymbol{t}\\cdot \\boldsymbol{u}\\,\\mathrm{d}\\Gamma,\n$$\n其中 $\\boldsymbol{\\epsilon} = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^\\top)$ 是小应变张量，$\\boldsymbol{\\epsilon}_{\\text{dev}} = \\boldsymbol{\\epsilon} - \\tfrac{1}{3}(\\operatorname{tr}(\\boldsymbol{\\epsilon}))\\boldsymbol{I}$ 是其偏量部分，$\\mu = \\dfrac{E}{2(1+\\nu)}$ 是剪切模量，$\\kappa = \\lambda + \\dfrac{2}{3}\\mu$ 是体积模量，其中 Lamé 参数 $\\lambda = \\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$。在基于位移的平面应变 $Q_1$ 离散中，使用工程剪应变 $\\gamma_{xy}$ 的 Voigt 形式本构矩阵为\n$$\n\\boldsymbol{C} = \\begin{bmatrix} \\lambda + 2\\mu  \\lambda  0 \\\\ \\lambda  \\lambda + 2\\mu  0 \\\\ 0  0  \\mu \\end{bmatrix}.\n$$\n当 $\\nu \\to 0.5$ 时，一种常用的、基于数值积分的缓解体积自锁的技术是选择性减缩积分，该技术对偏量和体积贡献部分采用不同的积分法则。具体而言，定义\n$$\n\\boldsymbol{C}_{\\mu} = \\mu \\,\\operatorname{diag}(2,2,1), \\qquad \\boldsymbol{C}_{\\lambda} = \\lambda \\begin{bmatrix} 1  1  0 \\\\ 1  1  0 \\\\ 0  0  0 \\end{bmatrix},\n$$\n使得 $\\boldsymbol{C} = \\boldsymbol{C}_{\\mu} + \\boldsymbol{C}_{\\lambda}$。单元刚度贡献为\n$$\n\\boldsymbol{K}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\mu} \\boldsymbol{B}\\, \\mathrm{d}\\Omega + \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\lambda} \\boldsymbol{B}\\, \\mathrm{d}\\Omega,\n$$\n其中 $\\boldsymbol{B}$ 是平面应变中标准的 $Q_1$ 应变-位移矩阵，使用工程剪切应变 $\\gamma_{xy} = \\dfrac{\\partial u}{\\partial y} + \\dfrac{\\partial v}{\\partial x}$。\n\n您的任务是对组装后的离散刚度矩阵进行谱分析，以评估关于当 $\\nu \\to 0.5$ 时 $Q_1$ 单元中自锁现象的两个论断：\n\n- 论断 A：选择性减缩积分，定义为对偏量部分使用完全 $2\\times 2$ Gauss 积分，对体积部分使用减缩 $1\\times 1$ Gauss 积分，能够消除体积自锁，即在固定载荷下，位移响应对 $\\nu$ 趋近于 $0.5$ 不敏感。\n\n- 论断 B：选择性减缩积分不会引入伪零能模式（沙漏模式），即离散刚度矩阵不会获得超出本质边界条件所消除的零特征值之外的额外零特征值。\n\n您必须设计并实现一个程序，该程序能组装全局刚度矩阵，并在三种积分方案下检查其谱：\n\n- 方案 F (完全积分): 在参考正方形上，对 $\\boldsymbol{C}_{\\mu}$ 和 $\\boldsymbol{C}_{\\lambda}$ 均使用 $2\\times 2$ Gauss 法则进行积分，其横坐标为 $\\pm 1/\\sqrt{3}$，权重为 $1$，总共四个点，总权重为 $4$。\n\n- 方案 S (选择性减缩积分): 对 $\\boldsymbol{C}_{\\mu}$ 使用 $2\\times 2$ Gauss 法则积分，对 $\\boldsymbol{C}_{\\lambda}$ 在 $(0,0)$ 点使用权重为 $4$ 的 $1\\times 1$ Gauss 法则积分。\n\n- 方案 R (完全减缩积分): 对 $\\boldsymbol{C}_{\\mu}$ 和 $\\boldsymbol{C}_{\\lambda}$ 均使用 $1\\times 1$ Gauss 法则积分。\n\n在 $\\Omega = [0,1]\\times[0,1]$ 上使用一个 $N_x = 8, N_y = 8$ 的结构化 $Q_1$ 网格，并设单位厚度。通过在左边界 $x=0$ 处固定 $u = 0$ 和 $v = 0$ 来施加齐次本质边界条件。对于加载测试，施加一个单位面积上的均布体力 $\\boldsymbol{b} = (1,0)$，无 Neumann 牵引力，并使用 $2\\times 2$ Gauss 法则组装一致节点力向量。使用 $E=1$ 和泊松比 $\\nu \\in \\{0.3, 0.49, 0.4999\\}$。\n\n定义以下定量测试：\n\n- 在 $\\nu = 0.4999$ 下的谱零模态测试：对于方案 S 和 R，构造约束后的刚度矩阵并计算所有特征值。令 $\\lambda_{\\max}$ 为最大特征值。用 $\\tau = 10^{-8}$ 计算严格小于 $\\tau \\lambda_{\\max}$ 的特征值数量，记为 $n_{\\text{near-}0}$。报告方案 S 和方案 R 的 $n_{\\text{near-}0}$。同时报告方案 S 的最小特征值，记为 $\\lambda_{\\min}^{(S)}$。\n\n- 体力作用下的自锁敏感性测试：对于方案 F 和 S，求解体力加载下约束问题的线性系统，并计算位移向量的欧几里得范数 $\\|\\boldsymbol{u}\\|_2$。令 $r_F = \\dfrac{\\|\\boldsymbol{u}\\|_2(\\nu=0.4999)}{\\|\\boldsymbol{u}\\|_2(\\nu=0.3)}$ 和 $r_S = \\dfrac{\\|\\boldsymbol{u}\\|_2(\\nu=0.4999)}{\\|\\boldsymbol{u}\\|_2(\\nu=0.3)}$ 分别为方案 F 和 S 的比率。一个远小于 $1$ 的 $r$ 值表明存在自锁，而一个接近 $1$ 的值则表明自锁得到了缓解。\n\n您的程序必须：\n\n- 使用方案 F、S 和 R 指定的积分分解来组装全局刚度矩阵。\n\n- 通过消除被固定的自由度并构建缩减后的系统来施加边界条件。\n\n- 在需要进行谱测试时，计算缩减后刚度矩阵的完整谱。\n\n- 使用直接线性求解器求解用于加载测试的缩减后线性系统。\n\n测试套件和输出规范：\n\n- 使用 $N_x = 8$, $N_y = 8$, $E = 1$ 和 $\\nu \\in \\{0.3, 0.49, 0.4999\\}$。\n\n- 单位面积上的体力 $\\boldsymbol{b} = (1,0)$。\n\n- 在 $\\nu = 0.4999$ 下进行谱零模态测试，容差因子 $\\tau = 10^{-8}$。\n\n- 程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  1. $\\nu = 0.4999$ 时的 $\\lambda_{\\min}^{(S)}$ (浮点数)。\n  2. $\\nu = 0.4999$ 时方案 S 的 $n_{\\text{near-}0}$ (整数)。\n  3. $\\nu = 0.4999$ 时方案 R 的 $n_{\\text{near-}0}$ (整数)。\n  4. $r_F$ (浮点数)。\n  5. $r_S$ (浮点数)。\n\n所有角度（如果相关）均以弧度为单位；然而，本问题中不需要角度量。最终答案中不需要物理单位，因为 $E$ 和几何形状已作无量纲化处理。输出必须采用所述的精确列表格式，例如 $[\\text{val}_1,\\text{val}_2,\\text{val}_3,\\text{val}_4,\\text{val}_5]$。", "solution": "已对用户的问题陈述进行了分析和验证。它构成了偏微分方程有限元分析领域内一个适定的、有科学依据的计算任务。该问题是自包含的，所有必要的物理参数、几何规格、边界条件和数值程序都已明确定义。目标是定量的且明确的。因此，该问题被认为是有效的，下面提供了完整的解决方案。\n\n这个问题的核心是实现一个用于平面应变条件下线性弹性的二维有限元模型。目标是研究数值自锁，这是在处理近不可压缩材料（即泊松比 $\\nu \\to 0.5$）时，低阶单元中常见的一种病态问题。该研究的核心是比较用于计算单元刚度矩阵 $\\boldsymbol{K}^{(e)}$ 的三种不同数值积分方案，并分析它们对全局刚度矩阵谱和解对 $\\nu$ 的敏感性的影响。\n\n该方法包括以下步骤：\n1.  **离散化与公式化**：单位正方形域 $\\Omega = [0,1]^2$ 使用一个包含 $N_x \\times N_y = 8 \\times 8$ 个双线性四边形 ($Q_1$) 单元的结构化网格进行离散。每个节点有两个自由度 (DOF)，分别对应水平 ($u$) 和垂直 ($v$) 位移。总节点数为 $(N_x+1)(N_y+1) = 81$，产生 $162$ 个自由度。\n\n2.  **单元级计算**：对于每个 $Q_1$ 单元，我们计算单元刚度矩阵 $\\boldsymbol{K}^{(e)}$ 和一致节点力向量 $\\boldsymbol{f}^{(e)}$。\n    单元刚度矩阵由单元域 $\\Omega_e$ 上的积分给出：\n    $$\n    \\boldsymbol{K}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C} \\boldsymbol{B}\\, \\mathrm{d}\\Omega\n    $$\n    其中 $\\boldsymbol{B}$ 是将节点位移与应变联系起来的应变-位移矩阵，$\\boldsymbol{C}$ 是平面应变的本构矩阵。该积分在参考单元 $[-1,1] \\times [-1,1]$ 上使用 Gauss 积分进行数值计算。从参考坐标到物理坐标的变换雅可比行列式 $\\det(\\boldsymbol{J})$ 必须包含在被积函数中。对于尺寸为 $h_x \\times h_y$ 的矩形单元，$\\det(\\boldsymbol{J}) = h_x h_y / 4$。\n\n    问题指定将 $\\boldsymbol{C}$ 分解为一个偏量部分 ($\\boldsymbol{C}_\\mu$) 和一个体积部分 ($\\boldsymbol{C}_\\lambda$)，其中 $\\mu = \\frac{E}{2(1+\\nu)}$ 和 $\\lambda = \\frac{E\\nu}{(1+\\nu)(1-2\\nu)}$ 是 Lamé 参数。\n    $$\n    \\boldsymbol{C}_{\\mu} = \\mu \\,\\begin{bmatrix} 2  0  0 \\\\ 0  2  0 \\\\ 0  0  1 \\end{bmatrix}, \\qquad \\boldsymbol{C}_{\\lambda} = \\lambda \\begin{bmatrix} 1  1  0 \\\\ 1  1  0 \\\\ 0  0  0 \\end{bmatrix}\n    $$\n    单元刚度随后被计算为两个独立的积分，每个积分可能使用不同的积分法则：\n    $$\n    \\boldsymbol{K}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\mu} \\boldsymbol{B}\\, \\mathrm{d}\\Omega + \\int_{\\Omega_e} \\boldsymbol{B}^\\top \\boldsymbol{C}_{\\lambda} \\boldsymbol{B}\\, \\mathrm{d}\\Omega\n    $$\n    三种方案是：\n    *   **方案 F (完全)**：对两项都使用 $2 \\times 2$ Gauss 积分。\n    *   **方案 S (选择性减缩)**：对 $\\boldsymbol{C}_\\mu$ 项使用 $2 \\times 2$ 积分，对 $\\boldsymbol{C}_\\lambda$ 项使用 $1 \\times 1$ 积分。\n    *   **方案 R (完全减缩)**：对两项都使用 $1 \\times 1$ 积分。\n\n    由体力 $\\boldsymbol{b}$ 引起的单元力向量为：\n    $$\n    \\boldsymbol{f}^{(e)} = \\int_{\\Omega_e} \\boldsymbol{N}^\\top \\boldsymbol{b} \\, \\mathrm{d}\\Omega\n    $$\n    其中 $\\boldsymbol{N}$ 是形函数矩阵。该积分使用 $2 \\times 2$ Gauss 法则计算。\n\n3.  **组装与边界条件**：单元矩阵和向量被组装成一个全局线性方程组 $\\boldsymbol{K}\\boldsymbol{d} = \\boldsymbol{f}$。齐次本质边界条件 ($u=v=0$) 被施加在左边界 ($x=0$) 上的所有节点。这是通过识别与这些节点对应的自由度，并从全局系统中消除相应的行和列来完成的，从而得到一个缩减系统 $\\boldsymbol{K}_{\\text{red}}\\boldsymbol{d}_{\\text{red}} = \\boldsymbol{f}_{\\text{red}}$。\n\n4.  **谱分析**：对于 $\\nu=0.4999$ 下的方案 S 和 R，计算缩减刚度矩阵 $\\boldsymbol{K}_{\\text{red}}$ 的特征值。伪零能模式（沙漏模式）表现为 $\\boldsymbol{K}_{\\text{red}}$ 中的零或近零特征值。我们计算满足 $\\lambda_i  \\tau \\lambda_{\\max}$ 的特征值数量 $\\lambda_i$，其中 $\\tau=10^{-8}$ 是一个小容差。对于一个稳定的方案，这个计数应该为零，并且最小特征值 $\\lambda_{\\min}$ 应该严格为正。\n\n5.  **自锁分析**：对于方案 F 和 S，求解 $\\nu=0.3$ 和 $\\nu=0.4999$ 下的缩减线性系统以获得位移向量 $\\boldsymbol{d}_{\\text{red}}$。体积自锁的特征是当 $\\nu \\to 0.5$ 时出现人为的刚性响应。这通过比率 $r = \\|\\boldsymbol{d}\\|_2(\\nu=0.4999) / \\|\\boldsymbol{d}\\|_2(\\nu=0.3)$ 来量化，其中 $\\|\\cdot\\|_2$ 是完整位移向量的欧几里得范数。一个远小于 $1$ 的比率表明存在自锁，而一个接近 $1$ 的比率则表明该方案成功地缓解了自锁。\n\n该实现将这些步骤封装到一个单一的 Python 脚本中。为单元级计算和系统组装定义了辅助函数。脚本的主要部分协调了针对不同方案和泊松比所需的分析，并按规定格式化最终结果。", "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Performs a spectral and locking analysis of Q1 finite elements for plane strain elasticity.\n    \"\"\"\n    # ------------------\n    # --- Parameters ---\n    # ------------------\n    Nx, Ny = 8, 8\n    E = 1.0\n    nu_spectral = 0.4999\n    nu_locking = [0.3, 0.4999]\n    tau = 1e-8\n    body_force_vec = np.array([1.0, 0.0])\n\n    # ------------------------\n    # --- Mesh and DOF Setup ---\n    # ------------------------\n    hx, hy = 1.0 / Nx, 1.0 / Ny\n    num_nodes_x = Nx + 1\n    num_nodes_y = Ny + 1\n    num_nodes = num_nodes_x * num_nodes_y\n    num_dofs = 2 * num_nodes\n    \n    # -------------------------------------\n    # --- Boundary Condition Definition ---\n    # -------------------------------------\n    clamped_node_indices = [iy * num_nodes_x for iy in range(num_nodes_y)]\n    clamped_dofs = []\n    for node_idx in clamped_node_indices:\n        clamped_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, clamped_dofs, assume_unique=True)\n\n    # ------------------------------\n    # --- FEM Helper Functions ---\n    # ------------------------------\n    # Quadrature points and weights for reference element [-1, 1]^2\n    p = 1.0 / np.sqrt(3.0)\n    gp_2x2 = [(-p, -p, 1.0), (p, -p, 1.0), (p, p, 1.0), (-p, p, 1.0)]\n    gp_1x1 = [(0.0, 0.0, 4.0)]\n\n    def get_B_matrix(xi, eta):\n        # Derivatives of shape functions w.r.t. xi, eta for nodes 0-3 (CCW from bottom-left)\n        dN_d_xi_eta = 0.25 * np.array([\n            [-(1.0 - eta), -(1.0 - xi)],\n            [ (1.0 - eta), -(1.0 + xi)],\n            [ (1.0 + eta),  (1.0 + xi)],\n            [-(1.0 + eta),  (1.0 - xi)]\n        ])\n        \n        B = np.zeros((3, 8))\n        for i in range(4):\n            dNi_dx = dN_d_xi_eta[i, 0] * 2.0 / hx\n            dNi_dy = dN_d_xi_eta[i, 1] * 2.0 / hy\n            \n            B[0, 2 * i]     = dNi_dx\n            B[1, 2 * i + 1] = dNi_dy\n            B[2, 2 * i]     = dNi_dy\n            B[2, 2 * i + 1] = dNi_dx\n        return B\n\n    def get_element_matrices(nu, scheme):\n        # Material properties\n        mu = E / (2.0 * (1.0 + nu))\n        lmbda = E * nu / ((1.0 + nu) * (1.0 - 2.0 * nu))\n        \n        C_mu = mu * np.array([[2.0, 0.0, 0.0], [0.0, 2.0, 0.0], [0.0, 0.0, 1.0]])\n        C_lambda = lmbda * np.array([[1.0, 1.0, 0.0], [1.0, 1.0, 0.0], [0.0, 0.0, 0.0]])\n\n        quad_map = {'F': (gp_2x2, gp_2x2), 'S': (gp_2x2, gp_1x1), 'R': (gp_1x1, gp_1x1)}\n        quad_mu, quad_lambda = quad_map[scheme]\n        \n        detJ = (hx * hy) / 4.0\n        \n        Ke_mu = np.zeros((8, 8))\n        for xi, eta, w in quad_mu:\n            B = get_B_matrix(xi, eta)\n            Ke_mu += B.T @ C_mu @ B * w * detJ\n\n        Ke_lambda = np.zeros((8, 8))\n        for xi, eta, w in quad_lambda:\n            B = get_B_matrix(xi, eta)\n            Ke_lambda += B.T @ C_lambda @ B * w * detJ\n        \n        Ke = Ke_mu + Ke_lambda\n        \n        fe = np.zeros(8)\n        # Force vector is always computed with 2x2 quadrature\n        for xi, eta, w in gp_2x2:\n            N_vals = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n            N_matrix = np.zeros((2, 8))\n            N_matrix[0, 0::2] = N_vals\n            N_matrix[1, 1::2] = N_vals\n            fe += N_matrix.T @ body_force_vec * w * detJ\n        \n        return Ke, fe\n\n    def assemble(nu, scheme):\n        K_global = np.zeros((num_dofs, num_dofs))\n        F_global = np.zeros(num_dofs)\n        \n        # Optimization: Ke and fe are the same for all elements in a structured mesh\n        Ke, fe = get_element_matrices(nu, scheme)\n        \n        for ey in range(Ny):\n            for ex in range(Nx):\n                node_indices = [\n                    ey * num_nodes_x + ex,\n                    ey * num_nodes_x + ex + 1,\n                    (ey + 1) * num_nodes_x + ex + 1,\n                    (ey + 1) * num_nodes_x + ex\n                ]\n                \n                dof_map = np.empty(8, dtype=int)\n                for i in range(4):\n                    dof_map[2*i]   = 2 * node_indices[i]\n                    dof_map[2*i+1] = 2 * node_indices[i] + 1\n                \n                ix_ = np.ix_(dof_map, dof_map)\n                K_global[ix_] += Ke\n                F_global[dof_map] += fe\n\n        return K_global, F_global\n\n    # -----------------------\n    # --- Main Analysis ---\n    # -----------------------\n\n    # --- Part 1: Spectral Zero-Mode Test (nu = 0.4999) ---\n    \n    # Scheme S\n    K_global_S, _ = assemble(nu=nu_spectral, scheme='S')\n    K_reduced_S = K_global_S[np.ix_(free_dofs, free_dofs)]\n    eigvals_S = linalg.eigh(K_reduced_S, eigvals_only=True)\n    lambda_min_S = eigvals_S[0]\n    n_near_0_S = np.sum(eigvals_S  tau * eigvals_S[-1])\n\n    # Scheme R\n    K_global_R, _ = assemble(nu=nu_spectral, scheme='R')\n    K_reduced_R = K_global_R[np.ix_(free_dofs, free_dofs)]\n    eigvals_R = linalg.eigh(K_reduced_R, eigvals_only=True)\n    n_near_0_R = np.sum(eigvals_R  tau * eigvals_R[-1])\n\n    # --- Part 2: Locking Sensitivity Test ---\n    u_norms = {}\n    for scheme in ['F', 'S']:\n        for nu in nu_locking:\n            K_global, F_global = assemble(nu=nu, scheme=scheme)\n\n            K_reduced = K_global[np.ix_(free_dofs, free_dofs)]\n            F_reduced = F_global[free_dofs]\n            \n            u_reduced = linalg.solve(K_reduced, F_reduced, assume_a='sym')\n            \n            u_full = np.zeros(num_dofs)\n            u_full[free_dofs] = u_reduced\n            u_norm = linalg.norm(u_full)\n            u_norms[(scheme, nu)] = u_norm\n            \n    r_F = u_norms[('F', 0.4999)] / u_norms[('F', 0.3)]\n    r_S = u_norms[('S', 0.4999)] / u_norms[('S', 0.3)]\n\n    # --- Part 3: Format and Print Output ---\n    results = [lambda_min_S, int(n_near_0_S), int(n_near_0_R), r_F, r_S]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3418037"}, {"introduction": "在非均质材料的场景中，锁定现象变得尤为深刻。本练习将研究一个仅在部分区域施加不可压缩约束的案例，从而揭示罚方法的一个关键弱点[@problem_id:3418018]。通过实施一个局部拉格朗日乘子，您将演示如何恰当地限制该约束，防止非物理的“刚化”效应传播到可压缩区域，并对混合法的局部特性获得更深的理解。", "problem": "您被要求设计并实现一个数值实验，该实验旨在揭示当仅在部分域上施加类不可压缩性约束时，有限元法（FEM）在线性弹性问题中出现的锁定现象。该数值实验必须比较纯位移法和一种混合法，后者在单元子集上通过局部拉格朗日乘子强制施加体积约束。您的程序必须计算定量指标，以验证锁定现象是否已将体积约束传播到无约束区域，以及局部拉格朗日乘子强制法是否能阻止这种非物理的全局扩散。\n\n推导的基本依据必须是最小势能原理以及标准的小应变弹性理论的线性化运动学和本构方程。在平面应变条件下，小应变张量定义为 $\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\tfrac{1}{2}(\\nabla \\boldsymbol{u} + \\nabla \\boldsymbol{u}^{\\top})$，柯西应力为 $\\boldsymbol{\\sigma} = 2\\mu \\boldsymbol{\\varepsilon} + \\lambda \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\boldsymbol{I}$，其中 $\\mu$ 和 $\\lambda$ 是拉梅参数。仅含位移的列式（displacement-only formulation）的弱形式源于弹性势能和表面牵引力功的一阶变分，而混合法则引入一个标量压力场 $p$ 作为拉格朗日乘子，以仅在指定单元上强制执行不可压缩约束 $\\operatorname{tr}(\\boldsymbol{\\varepsilon}) = 0$。\n\n计算域为矩形 $\\Omega = [0,L]\\times[0,H]$，其中 $L = 1$ 和 $H = 1$。它被离散为两个水平排列的双线性四边形单元：左单元覆盖 $[0,L/2]\\times[0,H]$，右单元覆盖 $[L/2,L]\\times[0,H]$。共有 $(3)\\times(2) = 6$ 个节点，每个节点带有两个位移自由度（分量 $u_x$ 和 $u_y$）。左边界 $\\{x=0\\}$ 被夹紧：$u_x = 0$ 和 $u_y = 0$。在右边界 $\\{x=L\\}$ 上施加均匀牵引力 $\\boldsymbol{t} = (t_x,0)$。上下边界为无牵引力边界。所有量均以无量纲单位处理。\n\n您必须实现：\n- 一个仅含位移的有限元法，其单元刚度由双线性等参映射和 $2\\times 2$ 高斯积分导出。通过为左单元选择一个非常大的 $\\lambda$（体积刚度）使其接近不可压缩，而右单元则使用一个适中的 $\\lambda$ 保持可压缩性。剪切模量 $\\mu$ 是均匀的。\n- 一个混合有限元法，通过为每个受约束单元引入一个压力自由度和一个拉格朗日乘子约束 $\\int_{\\text{left element}}(\\partial_x u_x + \\partial_y u_y)\\,\\mathrm{d}\\Omega = 0$，仅在左单元上局部强制不可压缩性。在受约束单元中，位移刚度必须排除体积部分（设置 $\\lambda = 0$），只保留剪切贡献。在无约束单元中，使用具有规定 $\\lambda$ 和 $\\mu$ 的标准可压缩刚度。\n\n从第一性原理出发，始于带表面牵引力的平衡变分陈述，使用双线性形函数离散位移场，为平面应变构建单元应变-位移矩阵 $B$ 和材料刚度矩阵 $D$，为两种列式组装全局刚度矩阵，通过消除固定自由度的方式施加狄利克雷边界条件，并求解线性系统。对于混合列式，组装鞍点系统\n$$\n\\begin{bmatrix}\n\\boldsymbol{K}_{uu}  \\boldsymbol{G}^{\\top} \\\\\n\\boldsymbol{G}  \\boldsymbol{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\boldsymbol{u} \\\\\n\\boldsymbol{p}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\boldsymbol{f} \\\\\n\\boldsymbol{0}\n\\end{bmatrix},\n$$\n其中耦合矩阵 $\\boldsymbol{G}$ 包含在受约束单元上使用相同高斯积分的 $\\nabla\\cdot\\boldsymbol{u}$ 的积分系数，$\\boldsymbol{p}$ 是单元级压力拉格朗日乘子。\n\n对于每个测试用例，计算以下定量输出：\n- 在仅含位移（罚函数）的列式中，端点位移 $u_{\\text{tip}}^{\\text{pen}}$，定义为两个右边缘节点的平均 $x$-位移。\n- 在对左单元使用局部拉格朗日乘子的混合列式中，端点位移 $u_{\\text{tip}}^{\\text{mix}}$。\n- 在仅含位移的列式中，积分散度 $\\mathcal{D}_{\\text{right}}^{\\text{pen}} = \\int_{\\text{right element}} (\\partial_x u_x + \\partial_y u_y)\\,\\mathrm{d}\\Omega$。\n- 在混合列式中，积分散度 $\\mathcal{D}_{\\text{right}}^{\\text{mix}}$。\n- 一个布尔泄漏指示器 $\\beta$，如果 $|\\mathcal{D}_{\\text{right}}^{\\text{pen}}|  \\frac{1}{2}|\\mathcal{D}_{\\text{right}}^{\\text{mix}}|$，则其值为 $\\text{True}$，这证明了体积约束在仅含位移的方法中非物理地传播到了无约束的右单元（锁定），否则为 $\\text{False}$。\n\n您的程序必须实现以下测试套件，涵盖一个通用情况、一个近不可压缩边界情况以及一个无约束的边缘情况：\n- 情况 A（通用）：$\\lambda_{\\text{left}} = 10^{4}$，$\\lambda_{\\text{right}} = 10^{-1}$，$\\mu = 1$，$t_x = 1$，在混合列式中左单元受约束。\n- 情况 B（近不可压缩）：$\\lambda_{\\text{left}} = 10^{7}$，$\\lambda_{\\text{right}} = 10^{-1}$，$\\mu = 1$，$t_x = 1$，在混合列式中左单元受约束。\n- 情况 C（边缘情况）：$\\lambda_{\\text{left}} = 10^{-1}$，$\\lambda_{\\text{right}} = 10^{-1}$，$\\mu = 1$，$t_x = 1$，在混合列式中无受约束单元。\n\n所有输出必须以无量纲单位表示。您的程序应生成单行输出，其中包含所有测试用例的结果，格式为方括号内包含的逗号分隔列表，每个测试用例的结果本身也是一个方括号内包含的逗号分隔列表，顺序为 $[u_{\\text{tip}}^{\\text{pen}}, u_{\\text{tip}}^{\\text{mix}}, \\mathcal{D}_{\\text{right}}^{\\text{pen}}, \\mathcal{D}_{\\text{right}}^{\\text{mix}}, \\beta]$。例如，格式必须类似于 $[[a_1,a_2,a_3,a_4,b_1],[c_1,c_2,c_3,c_4,b_2],[\\dots]]$。", "solution": "该问题陈述构成了一个在计算固体力学领域中有效且适定的数值实验。它在科学上基于线性弹性理论和有限元法（FEM），其表述客观，并提供了一套完整的参数和条件来复现指定的分析。任务是演示低阶有限元中体积锁定的现象以及如何使用混合法来缓解该现象。\n\n我们将首先建立纯位移法（罚函数法）和混合法共有的理论框架。然后，我们将详细说明每种方法的具体细节，包括单元矩阵的构建、全局系统的组装、边界条件的应用以及所需输出指标的计算。\n\n### 1. 线性弹性基本方程（平面应变）\n\n该分析基于最小势能原理。对于占据域 $\\Omega$ 的线性弹性体，其平衡位移场 $\\boldsymbol{u} = (u_x, u_y)$ 是使总势能 $\\Pi(\\boldsymbol{u})$ 最小化的位移场。该问题在平面应变条件（$\\varepsilon_{zz} = 0$）下进行考虑。\n\n应变-位移关系由位移场的对称梯度给出：\n$$ \\boldsymbol{\\varepsilon}(\\boldsymbol{u}) = \\frac{1}{2}(\\nabla \\boldsymbol{u} + (\\nabla \\boldsymbol{u})^{\\top}) $$\n使用Voigt符号表示应变向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\top}$，其中 $\\gamma_{xy} = 2\\varepsilon_{xy}$。\n\n关联应力向量 $\\boldsymbol{\\sigma} = [\\sigma_{xx}, \\sigma_{yy}, \\sigma_{xy}]^{\\top}$ 与应变向量的本构关系为 $\\boldsymbol{\\sigma} = \\boldsymbol{D}\\boldsymbol{\\varepsilon}$。对于平面应变下的各向同性材料，材料刚度矩阵 $\\boldsymbol{D}$ 为：\n$$\n\\boldsymbol{D} =\n\\begin{bmatrix}\n\\lambda+2\\mu  \\lambda  0 \\\\\n\\lambda  \\lambda+2\\mu  0 \\\\\n0  0  \\mu\n\\end{bmatrix}\n$$\n其中 $\\mu$ 和 $\\lambda$ 是拉梅参数。\n\n### 2. 有限元离散化\n\n域 $\\Omega = [0,L]\\times[0,H]$（$L=1$, $H=1$）被离散为两个矩形双线性四边形单元。节点编号如下：\n- 节点 1: $(0, 0)$\n- 节点 2: $(L/2, 0)$\n- 节点 3: $(L, 0)$\n- 节点 4: $(0, H)$\n- 节点 5: $(L/2, H)$\n- 节点 6: $(L, H)$\n\n左单元 $\\Omega_1$ 由节点 $(1, 2, 5, 4)$ 组成。右单元 $\\Omega_2$ 由节点 $(2, 3, 6, 5)$ 组成。6个节点中的每一个都有两个位移自由度（DOF），即 $u_x$ 和 $u_y$，总共有12个自由度。\n\n在每个单元内，位移场 $\\boldsymbol{u}$ 使用局部等参坐标系 $(\\xi, \\eta) \\in [-1, 1]\\times[-1, 1]$ 中的双线性形函数 $N_a(\\xi, \\eta)$ 进行近似：\n$$ \\boldsymbol{u}^h(\\xi, \\eta) = \\sum_{a=1}^{4} N_a(\\xi, \\eta) \\boldsymbol{d}_a $$\n其中 $\\boldsymbol{d}_a = [u_{ax}, u_{ay}]^{\\top}$ 是单元四个节点的节点位移。形函数为 $N_a(\\xi, \\eta) = \\frac{1}{4}(1+\\xi_a\\xi)(1+\\eta_a\\eta)$，其中 $(\\xi_a, \\eta_a)$ 是节点的局部坐标。\n\n离散的应变-位移关系为 $\\boldsymbol{\\varepsilon} = \\boldsymbol{B}\\boldsymbol{d}^e$，其中 $\\boldsymbol{d}^e$ 是单元节点自由度的 $8\\times 1$ 向量。应变-位移矩阵 $\\boldsymbol{B}$ 是一个 $3 \\times 8$ 的矩阵，由形函数的空间导数构成：\n$$ \\boldsymbol{B}_a = \\begin{bmatrix} \\frac{\\partial N_a}{\\partial x}  0 \\\\ 0  \\frac{\\partial N_a}{\\partial y} \\\\ \\frac{\\partial N_a}{\\partial y}  \\frac{\\partial N_a}{\\partial x} \\end{bmatrix}, \\quad \\boldsymbol{B} = [\\boldsymbol{B}_1, \\boldsymbol{B}_2, \\boldsymbol{B}_3, \\boldsymbol{B}_4] $$\n相对于全局坐标 $(x,y)$ 的导数是通过使用等参映射的雅可比矩阵 $\\boldsymbol{J}$ 的链式法则获得的：\n$$ \\begin{Bmatrix} \\frac{\\partial N_a}{\\partial x} \\\\ \\frac{\\partial N_a}{\\partial y} \\end{Bmatrix} = \\boldsymbol{J}^{-1} \\begin{Bmatrix} \\frac{\\partial N_a}{\\partial \\xi} \\\\ \\frac{\\partial N_a}{\\partial \\eta} \\end{Bmatrix} $$\n对于本问题中的矩形单元，$\\boldsymbol{J} = \\text{diag}(L/4, H/2)$ 且其行列式为 $\\det(\\boldsymbol{J}) = LH/8$。\n\n### 3. 纯位移法（罚函数法）\n\n单元刚度矩阵 $\\boldsymbol{K}^e$ 由应变能导出，并通过在单元域上积分计算：\n$$ \\boldsymbol{K}^e = \\int_{\\Omega^e} \\boldsymbol{B}^{\\top} \\boldsymbol{D} \\boldsymbol{B} \\, \\mathrm{d}\\Omega $$\n该积分使用 $2 \\times 2$ 高斯积分进行数值计算。单元刚度矩阵被组装成一个大小为 $12 \\times 12$ 的全局刚度矩阵 $\\boldsymbol{K}$。\n\n外力来自于在右边界 $\\{x=L, 0 \\le y \\le H\\}$ 上的牵引力 $\\boldsymbol{t} = (t_x, 0)$。该边界对应于右单元节点3和节点6之间的边。一致节点力向量 $\\boldsymbol{f}^e$ 为：\n$$ \\boldsymbol{f}^e = \\int_{\\Gamma_t^e} \\boldsymbol{N}^{\\top} \\boldsymbol{t} \\, \\mathrm{d}S $$\n积分表明，该牵引力在节点3和节点6的 $x$ 方向上产生大小为 $t_x H / 2$ 的力。对于 $t_x=1$ 和 $H=1$，这些力为 $0.5$。全局力向量 $\\boldsymbol{F}$ 包含这两个非零项。\n\n狄利克雷边界条件施加在固定的左边界 ($x=0$)，其中节点1和4的位移被固定为零（$u_{1x}=u_{1y}=u_{4x}=u_{4y}=0$）。这些自由度从全局系统中消除，得到一个简化的系统 $\\boldsymbol{K}_{red}\\boldsymbol{d}_{free} = \\boldsymbol{F}_{free}$，求解该系统可得到未知的节点位移 $\\boldsymbol{d}_{free}$。\n\n在该列式中，左单元的近不可压缩性通过为 $\\lambda_{\\text{left}}$ 使用一个非常大的值来建模，该值作为体积应变 $\\operatorname{tr}(\\boldsymbol{\\varepsilon})$ 的罚参数。\n\n### 4. 混合法\n\n为了缓解锁定，引入了混合法。引入一个分片常数压力场 $p$ 作为拉格朗日乘子，以仅在指定的受约束单元上强制执行不可压缩约束 $\\operatorname{tr}(\\boldsymbol{\\varepsilon})=0$。对于本问题，为左单元引入单个压力自由度 $p_1$。\n\n势能泛函被修改为一个鞍点泛函：\n$$ \\Pi(\\boldsymbol{u}, p_1) = \\int_{\\Omega} \\frac{1}{2}\\boldsymbol{\\sigma}(\\boldsymbol{u}):\\boldsymbol{\\varepsilon}(\\boldsymbol{u}) \\, \\mathrm{d}\\Omega - \\int_{\\Gamma_t} \\boldsymbol{t}\\cdot\\boldsymbol{u} \\, \\mathrm{d}S - \\int_{\\Omega_1} p_1 \\operatorname{tr}(\\boldsymbol{\\varepsilon}(\\boldsymbol{u})) \\, \\mathrm{d}\\Omega $$\n对于受约束的单元（$\\Omega_1$），通过将其 $\\lambda$ 设置为0，从内能项中移除了刚度的体积部分。对于无约束的单元（$\\Omega_2$），使用标准的可压缩刚度。\n\n离散化导致以下分块矩阵系统：\n$$\n\\begin{bmatrix}\n\\boldsymbol{K}_{uu}  \\boldsymbol{G}^{\\top} \\\\\n\\boldsymbol{G}  \\boldsymbol{0}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\boldsymbol{u} \\\\\n\\boldsymbol{p}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\boldsymbol{F} \\\\\n\\boldsymbol{0}\n\\end{bmatrix}\n$$\n- $\\boldsymbol{K}_{uu}$ 是由单元贡献组装而成的全局刚度矩阵。对于受约束的左单元，$\\boldsymbol{D}$ 在 $\\lambda=0$ 的条件下计算。对于无约束的右单元，使用标准的 $\\boldsymbol{D}$。\n- $\\boldsymbol{p}$ 是压力自由度的向量，这里只是标量 $p_1$。\n- $\\boldsymbol{G}$ 是离散梯度算子（耦合矩阵），由约束项导出。对于单元 $\\Omega_1$ 上的单个约束：\n$$ \\boldsymbol{G}_{1,j} \\boldsymbol{u}_j = p_1 \\int_{\\Omega_1} \\operatorname{tr}(\\boldsymbol{\\varepsilon}(\\boldsymbol{u}^h)) \\, \\mathrm{d}\\Omega $$\n行向量 $\\boldsymbol{G}$（在问题描述中记为 $B$）计算如下：\n$$ \\boldsymbol{G} = \\int_{\\Omega_1} [1, 1, 0] \\boldsymbol{B} \\, \\mathrm{d}\\Omega $$\n该积分也使用 $2 \\times 2$ 高斯积分进行计算。\n\n完整的系统（对于情况A和B，大小为 $13 \\times 13$）被组装起来。通过消除自由度来施加边界条件，并求解得到的简化系统以获得自由位移自由度和压力 $p_1$。对于情况C，由于没有约束，该列式与纯位移法相同。\n\n### 5. 输出指标\n\n在求解得到两种列式的节点位移（$\\boldsymbol{d}^{\\text{pen}}$ 和 $\\boldsymbol{d}^{\\text{mix}}$）后，我们计算所需的输出：\n- **端点位移** $u_{\\text{tip}}$：右边缘节点（节点3和6）的 $x$ 向位移的平均值。\n$$ u_{\\text{tip}} = \\frac{1}{2}(u_{3x} + u_{6x}) $$\n- **积分散度** $\\mathcal{D}_{\\text{right}}$：右单元上体积应变的积分。\n$$ \\mathcal{D}_{\\text{right}} = \\int_{\\Omega_2} \\operatorname{tr}(\\boldsymbol{\\varepsilon}) \\, \\mathrm{d}\\Omega = \\left(\\int_{\\Omega_2} [1, 1, 0] \\boldsymbol{B} \\, \\mathrm{d}\\Omega \\right) \\boldsymbol{d}^e_{\\text{right}} $$\n其中 $\\boldsymbol{d}^e_{\\text{right}}$ 是右单元的节点位移。该量针对两种列式都进行计算。\n- **泄漏指示器** $\\beta$：一个布尔值，指示罚函数法是否在无约束单元上引起显著的伪体积约束。\n$$ \\beta = (|\\mathcal{D}_{\\text{right}}^{\\text{pen}}|  \\frac{1}{2}|\\mathcal{D}_{\\text{right}}^{\\text{mix}}|) $$\n在罚函数法中（情况A和B），预计会发生锁定，这将表现为一个人为偏小的 $u_{\\text{tip}}^{\\text{pen}}$ 和一个接近于零的 $\\mathcal{D}_{\\text{right}}^{\\text{pen}}$。混合法应该能缓解这种情况，产生一个更大的端点位移和一个物理上合理、非零的 $\\mathcal{D}_{\\text{right}}^{\\text{mix}}$。这将导致 $\\beta = \\text{True}$。情况C作为一个基准，其中两种方法应产生相同的结果，且 $\\beta = \\text{False}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as linsolve\n\ndef get_shape_fns_and_derivs(xi, eta):\n    \"\"\"\n    Computes bilinear shape functions and their derivatives in local coords.\n    Nodes are ordered anti-clockwise from bottom-left (-1, -1).\n    \"\"\"\n    # Shape functions\n    N = 0.25 * np.array([\n        (1 - xi) * (1 - eta),\n        (1 + xi) * (1 - eta),\n        (1 + xi) * (1 + eta),\n        (1 - xi) * (1 + eta)\n    ])\n    # Derivatives w.r.t. local coordinates (xi, eta)\n    dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n    dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n    return N, dN_dxi, dN_deta\n\ndef assemble_fem_matrices(lambda_val, mu, elem_width, elem_height):\n    \"\"\"\n    Computes element stiffness matrix Ke, coupling vector G.\n    \"\"\"\n    elem_dofs = 8\n    Ke = np.zeros((elem_dofs, elem_dofs))\n    G = np.zeros(elem_dofs) # for mixed formulation\n    \n    # 2x2 Gaussian quadrature\n    gp_locs = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gp_weights = [1.0, 1.0]\n    \n    # Plane strain material stiffness matrix D\n    D = np.array([\n        [lambda_val + 2 * mu, lambda_val, 0],\n        [lambda_val, lambda_val + 2 * mu, 0],\n        [0, 0, mu]\n    ])\n\n    for i, wi in enumerate(gp_weights):\n        for j, wj in enumerate(gp_weights):\n            xi, eta = gp_locs[j], gp_locs[i]\n            _, dN_dxi, dN_deta = get_shape_fns_and_derivs(xi, eta)\n            \n            # Jacobian matrix for an axis-aligned rectangular element\n            # J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]]\n            J = np.array([\n                [elem_width / 2.0, 0],\n                [0, elem_height / 2.0]\n            ])\n            detJ = np.linalg.det(J)\n            invJ = np.linalg.inv(J)\n            \n            # Derivatives w.r.t. global coordinates (x,y)\n            dN_dxy = invJ @ np.vstack((dN_dxi, dN_deta))\n            dN_dx = dN_dxy[0, :]\n            dN_dy = dN_dxy[1, :]\n            \n            # Strain-displacement matrix B\n            B = np.zeros((3, elem_dofs))\n            for k in range(4):\n                B[0, 2*k] = dN_dx[k]\n                B[1, 2*k+1] = dN_dy[k]\n                B[2, 2*k] = dN_dy[k]\n                B[2, 2*k+1] = dN_dx[k]\n            \n            # Integrate for stiffness matrix\n            Ke += B.T @ D @ B * detJ * wi * wj\n            \n            # Integrate for coupling vector G\n            g_vec = np.array([1, 1, 0])\n            G += g_vec @ B * detJ * wi * wj\n            \n    return Ke, G\n\ndef solve_case(lambda_left, lambda_right, mu, tx, constrained):\n    L, H = 1.0, 1.0\n    num_nodes = 6\n    total_dofs = num_nodes * 2\n\n    elem_connectivity = [\n        [0, 1, 4, 3],  # Left element (nodes 1, 2, 5, 4)\n        [1, 2, 5, 4]   # Right element (nodes 2, 3, 6, 5)\n    ]\n    \n    # ----- Displacement-only (Penalty) Formulation -----\n    K_pen = np.zeros((total_dofs, total_dofs))\n    \n    # Assemble left element\n    Ke_left_pen, _ = assemble_fem_matrices(lambda_left, mu, L/2.0, H)\n    dof_map_left = np.array([[2*i, 2*i+1] for i in elem_connectivity[0]]).flatten()\n    K_pen[np.ix_(dof_map_left, dof_map_left)] += Ke_left_pen\n\n    # Assemble right element\n    Ke_right_pen, G_right_pen_elem = assemble_fem_matrices(lambda_right, mu, L/2.0, H)\n    dof_map_right = np.array([[2*i, 2*i+1] for i in elem_connectivity[1]]).flatten()\n    K_pen[np.ix_(dof_map_right, dof_map_right)] += Ke_right_pen\n\n    F_pen = np.zeros(total_dofs)\n    F_pen[2*2 + 0] += tx * H / 2.0  # Force on node 3 (x-dir)\n    F_pen[2*5 + 0] += tx * H / 2.0  # Force on node 6 (x-dir)\n\n    # Apply BCs\n    fixed_dofs = [0, 1, 6, 7] # DOFs for nodes 1 and 4\n    free_dofs = np.setdiff1d(np.arange(total_dofs), fixed_dofs)\n    \n    K_red_pen = K_pen[np.ix_(free_dofs, free_dofs)]\n    F_red_pen = F_pen[free_dofs]\n    \n    u_red_pen = linsolve(K_red_pen, F_red_pen)\n    \n    u_pen = np.zeros(total_dofs)\n    u_pen[free_dofs] = u_red_pen\n\n    # ----- Mixed Formulation -----\n    num_pressure_dofs = 1 if constrained else 0\n    sys_size = total_dofs + num_pressure_dofs\n    A_mix = np.zeros((sys_size, sys_size))\n    b_mix = np.zeros(sys_size)\n\n    # Assemble K_uu part\n    lambda_left_mix = 0.0 if constrained else lambda_left\n    Ke_left_mix, G_left_mix_elem = assemble_fem_matrices(lambda_left_mix, mu, L/2.0, H)\n    A_mix[np.ix_(dof_map_left, dof_map_left)] += Ke_left_mix\n    \n    Ke_right_mix, G_right_mix_elem = assemble_fem_matrices(lambda_right, mu, L/2.0, H)\n    A_mix[np.ix_(dof_map_right, dof_map_right)] += Ke_right_mix\n\n    # Assemble G part if constrained\n    if constrained:\n        pressure_dof_idx = total_dofs\n        A_mix[pressure_dof_idx, dof_map_left] = G_left_mix_elem\n        A_mix[dof_map_left, pressure_dof_idx] = G_left_mix_elem\n\n    b_mix[:total_dofs] = F_pen # Force vector is same\n\n    # Apply BCs for mixed system\n    all_sys_dofs = np.arange(sys_size)\n    free_sys_dofs = np.setdiff1d(all_sys_dofs, fixed_dofs)\n    \n    A_red_mix = A_mix[np.ix_(free_sys_dofs, free_sys_dofs)]\n    b_red_mix = b_mix[free_sys_dofs]\n\n    # Solve\n    sol_red_mix = linsolve(A_red_mix, b_red_mix)\n    \n    u_mix = np.zeros(total_dofs)\n    u_mix[free_dofs] = sol_red_mix[:len(free_dofs)]\n\n    # ----- Compute Outputs -----\n    u_tip_pen = (u_pen[2*2 + 0] + u_pen[2*5 + 0]) / 2.0\n    u_tip_mix = (u_mix[2*2 + 0] + u_mix[2*5 + 0]) / 2.0\n    \n    u_elem_right_pen = u_pen[dof_map_right]\n    D_right_pen = G_right_pen_elem @ u_elem_right_pen\n\n    u_elem_right_mix = u_mix[dof_map_right]\n    D_right_mix = G_right_mix_elem @ u_elem_right_mix\n    \n    beta = False\n    if abs(D_right_mix) > 1e-15: # Avoid division by zero\n        if abs(D_right_pen)  0.5 * abs(D_right_mix):\n            beta = True\n\n    return [u_tip_pen, u_tip_mix, D_right_pen, D_right_mix, beta]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (general)\n        {'lambda_left': 1e4, 'lambda_right': 1e-1, 'mu': 1.0, 'tx': 1.0, 'constrained': True},\n        # Case B (near-incompressible)\n        {'lambda_left': 1e7, 'lambda_right': 1e-1, 'mu': 1.0, 'tx': 1.0, 'constrained': True},\n        # Case C (edge case)\n        {'lambda_left': 1e-1, 'lambda_right': 1e-1, 'mu': 1.0, 'tx': 1.0, 'constrained': False},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(**case)\n        results.append(result)\n\n    # Format output as specified a list of lists.\n    # e.g., [[val1, val2, ...], [val1, val2, ...]]\n    output_str = \"[\" + \",\".join([\n        \"[\" + \",\".join([f\"{v:.6f}\" if isinstance(v, float) else str(v) for v in res]) + \"]\"\n        for res in results\n    ]) + \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "3418018"}]}