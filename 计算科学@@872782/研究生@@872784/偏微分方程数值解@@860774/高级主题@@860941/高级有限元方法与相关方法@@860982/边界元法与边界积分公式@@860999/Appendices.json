{"hands_on_practices": [{"introduction": "边界元方法（BEM）的核心思想是将偏微分方程的求解从区域内部转移到其边界上。本练习将引导你通过双层势表示法，为二维外部拉普拉斯问题推导出经典的边界积分方程。掌握这一过程对于理解BEM如何降低问题的维度，并为其数值实现奠定理论基础至关重要。[@problem_id:3367596]", "problem": "设 $\\Omega \\subset \\mathbb{R}^{2}$ 是一个具有 $C^{2}$ 类边界 $\\Gamma$ 的有界域。令 $\\boldsymbol{n}$ 表示 $\\Gamma$ 上的单位法向量，指向 $\\Omega$ 的外部（并进入外部区域 $\\Omega^{\\mathrm{ext}} := \\mathbb{R}^{2} \\setminus \\overline{\\Omega}$）。考虑拉普拉斯方程的外部狄利克雷问题：寻找一个调和函数 $u : \\Omega^{\\mathrm{ext}} \\to \\mathbb{R}$，使得在 $\\Omega^{\\mathrm{ext}}$ 中 $\\Delta u = 0$，对于给定的连续边界数据 $g \\in C(\\Gamma)$，迹 $u|_{\\Gamma} = g$，以及当 $|\\boldsymbol{x}| \\to \\infty$ 时满足衰减条件 $u(\\boldsymbol{x}) = \\mathcal{O}(|\\boldsymbol{x}|^{-1})$。以格林恒等式和拉普拉斯算子的二维基本解为基础，考虑在外部区域中对 $u$ 使用双层位势 ansatz，其未知密度为 $\\psi \\in C(\\Gamma)$，\n$$\nu(\\boldsymbol{x}) = \\int_{\\Gamma} \\frac{\\partial G(\\boldsymbol{x},\\boldsymbol{y})}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} \\, \\psi(\\boldsymbol{y}) \\, \\mathrm{d}s_{\\boldsymbol{y}}, \\quad \\boldsymbol{x} \\in \\Omega^{\\mathrm{ext}},\n$$\n其中 $G(\\boldsymbol{x},\\boldsymbol{y})$ 是拉普拉斯算子的二维基本解。从格林第二恒等式和层位势的定义出发，推导由 $u$ 在 $\\Gamma$ 上的外迹所满足的边界积分方程，该方程用与双层核相关的边界积分算子 $K$ 表示，并包含正确的跳跃项。假设当存在奇点时，所有必要的积分都在柯西主值的意义下进行解释，并通过在边界点处进行与所选向外法线方向一致的局部分析，来证明跳跃项的出现及其符号的正确性。\n\n最后，对于二维情况，其中\n$$\nG(\\boldsymbol{x},\\boldsymbol{y}) = -\\frac{1}{2\\pi} \\ln |\\boldsymbol{x}-\\boldsymbol{y}|,\n$$\n确定由\n$$\n(K\\psi)(\\boldsymbol{x}) := \\mathrm{p.v.} \\int_{\\Gamma} k(\\boldsymbol{x},\\boldsymbol{y}) \\, \\psi(\\boldsymbol{y}) \\, \\mathrm{d}s_{\\boldsymbol{y}}, \\quad \\boldsymbol{x} \\in \\Gamma.\n$$\n定义的边界积分算子 $K$ 的核函数 $k(\\boldsymbol{x},\\boldsymbol{y})$ 的显式解析表达式。\n你的最终答案必须是 $k(\\boldsymbol{x},\\boldsymbol{y})$ 的单个闭式表达式。在最终的方框答案中不要包含任何等号或不等号。无需四舍五入。", "solution": "该问题要求使用双层位势 ansatz 推导拉普拉斯方程外部狄利克雷问题的边界积分方程（BIE），并求出相关积分算子核函数的显式形式。推导过程需要仔细分析位势在边界附近的行为。\n\n设 $\\Omega \\subset \\mathbb{R}^{2}$ 为一个具有 $C^{2}$ 边界 $\\Gamma$ 的有界域。$\\Gamma$ 上的单位法向量 $\\boldsymbol{n}$ 指向外部区域 $\\Omega^{\\mathrm{ext}} = \\mathbb{R}^{2} \\setminus \\overline{\\Omega}$。我们寻求在 $\\Omega^{\\mathrm{ext}}$ 中满足 $\\Delta u = 0$ 的调和函数 $u$，其边界条件为 $u|_{\\Gamma} = g$，衰减条件为当 $|\\boldsymbol{x}| \\to \\infty$ 时 $u(\\boldsymbol{x}) = \\mathcal{O}(|\\boldsymbol{x}|^{-1})$。\n\n提出的解的 ansatz 是一个具有未知密度函数 $\\psi \\in C(\\Gamma)$ 的双层位势：\n$$\nu(\\boldsymbol{x}) = (W\\psi)(\\boldsymbol{x}) := \\int_{\\Gamma} \\frac{\\partial G(\\boldsymbol{x},\\boldsymbol{y})}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} \\, \\psi(\\boldsymbol{y}) \\, \\mathrm{d}s_{\\boldsymbol{y}}, \\quad \\boldsymbol{x} \\in \\Omega^{\\mathrm{ext}}\n$$\n这里，$G(\\boldsymbol{x},\\boldsymbol{y})$ 是二维拉普拉斯方程的基本解，$G(\\boldsymbol{x},\\boldsymbol{y}) = -\\frac{1}{2\\pi} \\ln |\\boldsymbol{x}-\\boldsymbol{y}|$。积分的核函数是 $\\frac{\\partial G(\\boldsymbol{x},\\boldsymbol{y})}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} = \\nabla_{\\boldsymbol{y}} G(\\boldsymbol{x},\\boldsymbol{y}) \\cdot \\boldsymbol{n}_{\\boldsymbol{y}}$。对于任何 $\\boldsymbol{x} \\notin \\Gamma$，该位势 $u(\\boldsymbol{x})$ 都是调和的，并且在无穷远处满足所需的衰减条件。\n\n为了找到 $\\psi$ 的积分方程，我们必须施加边界条件 $u|_{\\Gamma}=g$。这需要取 $u(\\boldsymbol{x})$ 在 $\\boldsymbol{x}$ 从外部区域 $\\Omega^{\\text{ext}}$ 趋近于一点 $\\boldsymbol{x}_0 \\in \\Gamma$ 时的极限。已知双层位势在边界 $\\Gamma$ 上具有跳跃间断。我们必须推导这个跳跃条件。\n\n设 $\\boldsymbol{x}_0 \\in \\Gamma$。$u$ 的外迹由以下极限给出：\n$$\nu|_{\\Gamma}(\\boldsymbol{x}_0) = \\lim_{\\substack{\\boldsymbol{x} \\to \\boldsymbol{x}_0 \\\\ \\boldsymbol{x} \\in \\Omega^{\\mathrm{ext}}}} (W\\psi)(\\boldsymbol{x})\n$$\n$(W\\psi)(\\boldsymbol{x})$ 定义中的积分在 $\\boldsymbol{x} \\to \\boldsymbol{x}_0$ 时变得奇异。通常通过考虑其柯西主值（p.v.）和来自奇点的贡献来评估该极限。边界积分算子 $K$ 由这个主值积分定义：\n$$\n(K\\psi)(\\boldsymbol{x}_0) := \\mathrm{p.v.} \\int_{\\Gamma} \\frac{\\partial G(\\boldsymbol{x}_0,\\boldsymbol{y})}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} \\, \\psi(\\boldsymbol{y}) \\, \\mathrm{d}s_{\\boldsymbol{y}}\n$$\n对于足够光滑的边界 $\\Gamma$ 和密度 $\\psi$，双层位势的跳跃关系表明：\n$$\n\\lim_{\\substack{\\boldsymbol{x} \\to \\boldsymbol{x}_0 \\\\ \\boldsymbol{x} \\in \\Omega^{\\mathrm{ext}}}} (W\\psi)(\\boldsymbol{x}) = (K\\psi)(\\boldsymbol{x}_0) + \\frac{1}{2}\\psi(\\boldsymbol{x}_0)\n$$\n$$\n\\lim_{\\substack{\\boldsymbol{x} \\to \\boldsymbol{x}_0 \\\\ \\boldsymbol{x} \\in \\Omega}} (W\\psi)(\\boldsymbol{x}) = (K\\psi)(\\boldsymbol{x}_0) - \\frac{1}{2}\\psi(\\boldsymbol{x}_0)\n$$\n我们被要求通过局部分析来证明第一个关系。让我们分析当 $\\boldsymbol{x}$ 从 $\\Omega^{\\text{ext}}$ 趋近于 $\\boldsymbol{x}_0$ 时积分的行为。我们可以写成：\n$$\n(W\\psi)(\\boldsymbol{x}) = \\int_{\\Gamma} \\frac{\\partial G(\\boldsymbol{x},\\boldsymbol{y})}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} (\\psi(\\boldsymbol{y}) - \\psi(\\boldsymbol{x}_0)) \\, \\mathrm{d}s_{\\boldsymbol{y}} + \\psi(\\boldsymbol{x}_0) \\int_{\\Gamma} \\frac{\\partial G(\\boldsymbol{x},\\boldsymbol{y})}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} \\, \\mathrm{d}s_{\\boldsymbol{y}}\n$$\n第一个积分的核是弱奇异的，其在 $\\boldsymbol{x} \\to \\boldsymbol{x}_0$ 时的极限给出了密度为 $\\psi(\\boldsymbol{y}) - \\psi(\\boldsymbol{x}_0)$ 的主值积分。跳跃行为包含在第二个积分中。对于 $\\boldsymbol{x} \\in \\Omega^{\\text{ext}}$，通过对 $\\Omega$ 中的 $G(\\boldsymbol{x}, \\cdot)$ 应用散度定理（或格林第一恒等式），我们有 $\\int_{\\Gamma} \\frac{\\partial G(\\boldsymbol{x},\\boldsymbol{y})}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} \\, \\mathrm{d}s_{\\boldsymbol{y}} = \\int_{\\Omega} \\Delta_{\\boldsymbol{y}} G(\\boldsymbol{x},\\boldsymbol{y}) \\, \\mathrm{d}A_{\\boldsymbol{y}} = 0$，因为 $\\boldsymbol{x} \\notin \\Omega$。该恒等式对 $\\boldsymbol{x} \\notin \\Gamma$ 成立，但当 $\\boldsymbol{x} \\to \\boldsymbol{x}_0$ 时的极限是非平凡的。\n\n一个更直接的局部分析如下。设 $\\boldsymbol{x}_0 \\in \\Gamma$。我们分析当 $h \\to 0^+$ 时，对于 $\\boldsymbol{x} = \\boldsymbol{x}_0 + h \\boldsymbol{n}(\\boldsymbol{x}_0)$，$(W\\psi)(\\boldsymbol{x})$ 的极限。对于小的 $\\epsilon > 0$，我们将 $\\Gamma$ 上的积分分解为 $\\Gamma_\\epsilon = \\Gamma \\cap B(\\boldsymbol{x}_0, \\epsilon)$ 和 $\\Gamma \\setminus \\Gamma_\\epsilon$ 两部分。当 $\\epsilon \\to 0$ 和 $\\boldsymbol{x} \\to \\boldsymbol{x}_0$ 时，$\\Gamma \\setminus \\Gamma_\\epsilon$ 上的积分收敛到主值积分 $(K\\psi)(\\boldsymbol{x}_0)$。关键部分是来自 $\\Gamma_\\epsilon$ 的局部贡献：\n$$ \\lim_{\\boldsymbol{x}\\to\\boldsymbol{x}_0} \\int_{\\Gamma_\\epsilon} \\frac{\\partial G(\\boldsymbol{x},\\boldsymbol{y})}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} \\, \\psi(\\boldsymbol{y}) \\, \\mathrm{d}s_{\\boldsymbol{y}} $$\n根据连续性，对于 $\\boldsymbol{y} \\in \\Gamma_\\epsilon$，有 $\\psi(\\boldsymbol{y}) \\approx \\psi(\\boldsymbol{x}_0)$。对于 $C^2$ 边界，我们可以用一条线段（其在 $\\boldsymbol{x}_0$ 处的切线）来近似 $\\Gamma_\\epsilon$，用 $\\boldsymbol{n}(\\boldsymbol{x}_0)$ 来近似 $\\boldsymbol{n}_{\\boldsymbol{y}}$。让我们建立一个局部坐标系，原点在 $\\boldsymbol{x}_0$，切线沿 $y_1$ 轴，外法线 $\\boldsymbol{n}(\\boldsymbol{x}_0)$ 沿 $y_2$ 轴。那么 $\\boldsymbol{x}_0 = \\boldsymbol{0}$，$\\boldsymbol{x} = (0,h)$ 其中 $h>0$，切线上的点 $\\boldsymbol{y}$ 为 $(y_1, 0)$。法线为 $\\boldsymbol{n}_{\\boldsymbol{y}} \\approx (0,1)$。核函数为 $\\frac{\\partial G}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} = \\nabla_{\\boldsymbol{y}} G \\cdot \\boldsymbol{n}_{\\boldsymbol{y}}$。\n$$ \\nabla_{\\boldsymbol{y}} G(\\boldsymbol{x},\\boldsymbol{y}) = -\\frac{1}{2\\pi} \\frac{\\boldsymbol{y}-\\boldsymbol{x}}{|\\boldsymbol{y}-\\boldsymbol{x}|^2} = -\\frac{1}{2\\pi} \\frac{(y_1, -h)}{y_1^2 + h^2} $$\n$$ \\frac{\\partial G}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} \\approx -\\frac{1}{2\\pi} \\frac{(y_1, -h) \\cdot (0,1)}{y_1^2 + h^2} = \\frac{1}{2\\pi} \\frac{h}{y_1^2 + h^2} $$\n局部积分变为：\n$$ \\lim_{h \\to 0^+} \\psi(\\boldsymbol{x}_0) \\int_{-\\epsilon}^{\\epsilon} \\frac{1}{2\\pi} \\frac{h}{y_1^2+h^2} \\, \\mathrm{d}y_1 $$\n我们来计算这个积分。使用换元法 $y_1 = h \\tan\\theta$, $\\mathrm{d}y_1 = h \\sec^2\\theta \\, \\mathrm{d}\\theta$：\n$$ \\int \\frac{h}{y_1^2+h^2} \\, \\mathrm{d}y_1 = \\int \\frac{h}{h^2\\tan^2\\theta+h^2} (h \\sec^2\\theta) \\, \\mathrm{d}\\theta = \\int \\mathrm{d}\\theta = \\theta = \\arctan\\left(\\frac{y_1}{h}\\right) $$\n所以，定积分为：\n$$ \\frac{\\psi(\\boldsymbol{x}_0)}{2\\pi} \\left[ \\arctan\\left(\\frac{y_1}{h}\\right) \\right]_{-\\epsilon}^{\\epsilon} = \\frac{\\psi(\\boldsymbol{x}_0)}{2\\pi} \\left( \\arctan\\left(\\frac{\\epsilon}{h}\\right) - \\arctan\\left(\\frac{-\\epsilon}{h}\\right) \\right) = \\frac{\\psi(\\boldsymbol{x}_0)}{\\pi} \\arctan\\left(\\frac{\\epsilon}{h}\\right) $$\n取 $h \\to 0^+$ 的极限（从外部沿法线方向逼近）：\n$$ \\lim_{h\\to 0^+} \\frac{\\psi(\\boldsymbol{x}_0)}{\\pi} \\arctan\\left(\\frac{\\epsilon}{h}\\right) = \\frac{\\psi(\\boldsymbol{x}_0)}{\\pi} \\cdot \\frac{\\pi}{2} = \\frac{1}{2}\\psi(\\boldsymbol{x}_0) $$\n正号是从 $\\Omega^{\\text{ext}}$ 逼近的直接结果，这也是法向量指向的方向。将此项加到主值积分上，就得到了外迹。\n因此，通过取 ansatz $u(\\boldsymbol{x})=(W\\psi)(\\boldsymbol{x})$ 的外迹，并使其等于给定的边界数据 $g$，我们得到 BIE：\n$$ g(\\boldsymbol{x}) = \\frac{1}{2}\\psi(\\boldsymbol{x}) + (K\\psi)(\\boldsymbol{x}) $$\n它可以显式地写为：\n$$ g(\\boldsymbol{x}) = \\frac{1}{2}\\psi(\\boldsymbol{x}) + \\mathrm{p.v.} \\int_{\\Gamma} \\frac{\\partial G(\\boldsymbol{x},\\boldsymbol{y})}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} \\, \\psi(\\boldsymbol{y}) \\, \\mathrm{d}s_{\\boldsymbol{y}}, \\quad \\boldsymbol{x} \\in \\Gamma $$\n这是一个关于未知密度 $\\psi$ 的第二类 Fredholm 积分方程。\n\n最后，我们确定算子 $K$ 的核函数 $k(\\boldsymbol{x},\\boldsymbol{y})$ 的显式表达式。根据定义，\n$$ (K\\psi)(\\boldsymbol{x}) = \\mathrm{p.v.} \\int_{\\Gamma} k(\\boldsymbol{x},\\boldsymbol{y}) \\, \\psi(\\boldsymbol{y}) \\, \\mathrm{d}s_{\\boldsymbol{y}} $$\n将其与积分方程进行比较，我们确定核函数为：\n$$ k(\\boldsymbol{x},\\boldsymbol{y}) = \\frac{\\partial G(\\boldsymbol{x},\\boldsymbol{y})}{\\partial \\boldsymbol{n}_{\\boldsymbol{y}}} $$\n该导数是关于变量 $\\boldsymbol{y}$ 在点 $\\boldsymbol{y} \\in \\Gamma$ 处沿法线 $\\boldsymbol{n}_{\\boldsymbol{y}}$ 方向的导数。\n$$ k(\\boldsymbol{x},\\boldsymbol{y}) = \\nabla_{\\boldsymbol{y}} G(\\boldsymbol{x},\\boldsymbol{y}) \\cdot \\boldsymbol{n}_{\\boldsymbol{y}} $$\n给定 $G(\\boldsymbol{x},\\boldsymbol{y}) = -\\frac{1}{2\\pi} \\ln |\\boldsymbol{x}-\\boldsymbol{y}|$，我们首先计算关于 $\\boldsymbol{y}$ 的梯度：\n$$ \\nabla_{\\boldsymbol{y}} (\\ln |\\boldsymbol{x}-\\boldsymbol{y}|) = \\frac{1}{|\\boldsymbol{x}-\\boldsymbol{y}|} \\nabla_{\\boldsymbol{y}} (|\\boldsymbol{x}-\\boldsymbol{y}|) = \\frac{1}{|\\boldsymbol{x}-\\boldsymbol{y}|} \\frac{\\boldsymbol{y}-\\boldsymbol{x}}{|\\boldsymbol{x}-\\boldsymbol{y}|} = \\frac{\\boldsymbol{y}-\\boldsymbol{x}}{|\\boldsymbol{x}-\\boldsymbol{y}|^2} $$\n因此，基本解的梯度是：\n$$ \\nabla_{\\boldsymbol{y}} G(\\boldsymbol{x},\\boldsymbol{y}) = -\\frac{1}{2\\pi} \\nabla_{\\boldsymbol{y}} (\\ln |\\boldsymbol{x}-\\boldsymbol{y}|) = -\\frac{1}{2\\pi} \\frac{\\boldsymbol{y}-\\boldsymbol{x}}{|\\boldsymbol{x}-\\boldsymbol{y}|^2} $$\n然后通过与 $\\boldsymbol{n}_{\\boldsymbol{y}}$ 作点积得到核函数：\n$$ k(\\boldsymbol{x},\\boldsymbol{y}) = \\left( -\\frac{1}{2\\pi} \\frac{\\boldsymbol{y}-\\boldsymbol{x}}{|\\boldsymbol{x}-\\boldsymbol{y}|^2} \\right) \\cdot \\boldsymbol{n}_{\\boldsymbol{y}} = \\frac{1}{2\\pi} \\frac{(\\boldsymbol{x}-\\boldsymbol{y}) \\cdot \\boldsymbol{n}_{\\boldsymbol{y}}}{|\\boldsymbol{x}-\\boldsymbol{y}|^2} $$\n这就是二维拉普拉斯方程的双层边界积分算子核函数的显式解析表达式。", "answer": "$$\\boxed{\\frac{1}{2\\pi} \\frac{(\\boldsymbol{x}-\\boldsymbol{y}) \\cdot \\boldsymbol{n}_{\\boldsymbol{y}}}{|\\boldsymbol{x}-\\boldsymbol{y}|^2}}$$", "id": "3367596"}, {"introduction": "在离散化求解边界积分方程时，一个关键的实际挑战是如何精确计算积分，尤其是当场点靠近积分单元时出现的“近奇异”情况。本练习将通过一个具体的编码任务，让你掌握一种名为“解析减法”的强大技术来攻克这一难题。通过将积分分解为可解析求解的部分和光滑的数值计算部分，你将能显著提升边界元方法的计算精度和稳定性。[@problem_id:3367567]", "problem": "考虑二维拉普拉斯方程及其在使用单层势表示于直边界元上的边界积分方程 (BIE) 形式。拉普拉斯方程在二维中的基本解由 $G(\\boldsymbol{x},\\boldsymbol{y}) = -\\dfrac{1}{2\\pi} \\log \\|\\boldsymbol{x}-\\boldsymbol{y}\\|$ 给出，其中 $\\|\\cdot\\|$ 表示欧几里得范数。在边界元法 (BEM, Boundary Element Method) 的离散化中，当场点靠近积分单元时，核函数的近奇异行为会导致较大的求积误差。\n\n关注模型积分\n$$\nI(L,x_0,y_0) = \\int_{-L}^{L} \\varphi(s)\\, \\log\\left(\\sqrt{(s-x_0)^2 + y_0^2}\\right)\\, \\mathrm{d}s,\n$$\n它对应于单层势在沿 $x$ 轴、由 $s \\in [-L,L]$ 参数化的直线上的一部分核函数。场点位于 $(x_0,y_0)$，其中 $y_0 > 0$。设边界密度为二次函数\n$$\n\\varphi(s) = 1 + s + \\tfrac{1}{2}\\, s^2.\n$$\n\n从拉普拉斯方程的边界积分公式和标准微积分的基本原理出发，设计并实现一种近奇异求积策略，通过对数奇异性的解析减去法来减小 $y_0$ 很小时的误差。具体而言：\n- 使用场点在单元上的最近点投影 $s^\\star$，定义为 $s^\\star = \\min\\{\\max\\{x_0,-L\\},L\\}$。\n- 在 $s^\\star$ 处构造密度的局部线性近似，由 $p(s) = \\varphi(s^\\star) + \\varphi'(s^\\star)\\,(s - s^\\star)$ 给出，其中 $\\varphi'(s) = \\dfrac{\\mathrm{d}\\varphi}{\\mathrm{d}s}$。\n- 将积分分解为一个可解析计算的部分和一个数值上光滑的余项：\n$$\nI(L,x_0,y_0) = \\underbrace{\\int_{-L}^{L} p(s)\\, \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s}_{\\text{analytic}} \\;+\\; \\underbrace{\\int_{-L}^{L} \\big(\\varphi(s)-p(s)\\big)\\, \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s}_{\\text{smooth remainder}}.\n$$\n- 仅使用初等微积分推导所需原函数的闭式表达式，从而精确计算解析部分。\n- 使用标准的高斯-勒让德 (Gauss–Legendre) 求积法计算光滑余项。\n- 作为对比，也对原始被积函数计算未使用减去法的朴素高斯-勒让德求积。\n\n为评估精度，定义一个参考值 $I_{\\text{ref}}(L,x_0,y_0)$，通过对原始积分进行高精度自适应积分计算得出。对于每个测试用例，报告绝对误差\n$$\ne_{\\text{std}} = \\big|I_{\\text{GL}} - I_{\\text{ref}}\\big|, \\qquad e_{\\text{sub}} = \\big|I_{\\text{sub}} - I_{\\text{ref}}\\big|,\n$$\n其中 $I_{\\text{GL}}$ 是朴素高斯-勒让德求积的结果，$I_{\\text{sub}}$ 是解析减去法的结果。\n\n您的程序必须实现以上内容，并为以下参数值测试套件生成结果：\n- 情况 A (近奇异，内部投影): $L = 1$, $x_0 = 0$, $y_0 = 10^{-6}$。\n- 情况 B (近奇异，端点投影): $L = 1$, $x_0 = 1$, $y_0 = 10^{-6}$。\n- 情况 C (中度近奇异，靠近端点的内部投影): $L = 1$, $x_0 = 0.9$, $y_0 = 10^{-4}$。\n- 情况 D (场点远离): $L = 1$, $x_0 = 0$, $y_0 = 10^{-1}$。\n- 情况 E (较长板，近奇异，内部投影): $L = 2$, $x_0 = -1.5$, $y_0 = 10^{-7}$。\n\n这个问题是纯数学问题，不涉及物理单位。当角度出现在解析原函数中时，必须以弧度为单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目对应一个测试用例，并且本身必须是 $[e_{\\text{std}}, e_{\\text{sub}}]$ 顺序的双元素列表。例如，输出格式应类似于\n$[[e_{\\text{std},A},e_{\\text{sub},A}],[e_{\\text{std},B},e_{\\text{sub},B}],\\dots]$。\n\n最终程序必须是自包含的，无需用户输入。对于朴素求积和余项求積，它必须使用一个合理的固定高斯-勒让德阶数（例如，$N=16$），并对参考值使用高精度自适应积分。", "solution": "带有单层势的二维拉普拉斯方程的边界积分方程涉及对数核 $G(\\boldsymbol{x},\\boldsymbol{y}) = -\\dfrac{1}{2\\pi} \\log \\|\\boldsymbol{x}-\\boldsymbol{y}\\|$。当场点 $(x_0,y_0)$ 靠近边界元时，被积函数的对数部分会变得非常尖锐，导致求积误差增大。一种基于原理的补救方法是解析地减去奇异行为，留下一个光滑的余项进行数值积分。\n\n我们考虑模型积分\n$$\nI(L,x_0,y_0) = \\int_{-L}^{L} \\varphi(s)\\, \\log\\left(\\sqrt{(s-x_0)^2 + y_0^2}\\right)\\, \\mathrm{d}s,\n$$\n其密度为\n$$\n\\varphi(s) = 1 + s + \\tfrac{1}{2}\\, s^2, \\quad \\varphi'(s) = 1 + s,\n$$\n在直线段 $s \\in [-L,L]$ 上。近奇异性由 $\\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)$ 在 $y_0 \\to 0$ 时的行为决定，该项是可积的，但在数值上具有挑战性。\n\n基于原理的设计：\n1. 识别线段上距离场点最近的点 $s^\\star$。鉴于线段与 $x$ 轴对齐，$s^\\star = \\min\\{\\max\\{x_0,-L\\},L\\}$。\n2. 在 $s^\\star$ 处形成密度的局部线性近似：\n$$\np(s) = \\varphi(s^\\star) + \\varphi'(s^\\star)\\,(s - s^\\star).\n$$\n这是 $\\varphi(s)$ 在 $s^\\star$ 附近的一阶泰勒展开。其目的是捕捉在 $s \\approx x_0$ 的峰值周围，密度与对数核之间的主要耦合作用。\n3. 将积分分解为\n$$\nI(L,x_0,y_0) = I_{\\text{analytic}} + I_{\\text{smooth}},\n$$\n其中\n$$\nI_{\\text{analytic}} = \\int_{-L}^{L} p(s)\\, \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s,\n\\quad\nI_{\\text{smooth}} = \\int_{-L}^{L} \\big(\\varphi(s)-p(s)\\big)\\, \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s.\n$$\n根据构造，$\\varphi(s)-p(s)$ 在 $s=s^\\star$ 处为零，当 $x_0$ 位于单元内或其附近时，这会极大地减弱近奇异尖峰。余项是光滑的，适合使用标准高斯求积法。\n\n为了精确计算 $I_{\\text{analytic}}$，我们观察到它是由以下形式的积分的线性组合构成的\n$$\n\\int_{-L}^{L} \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s\n\\quad \\text{和} \\quad\n\\int_{-L}^{L} s\\, \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s.\n$$\n引入换元 $t = s - x_0$，因此 $s = t + x_0$，积分界限映射为 $t \\in [a,b]$，其中 $a = -L - x_0$，$b = L - x_0$。\n\n我们需要从初等微积分推导出的闭式反导数。\n\n第一个原函数：\n定义\n$$\nF_0(t) = \\tfrac{1}{2}\\, t \\, \\log(t^2 + y_0^2) \\;-\\; t \\;+\\; y_0 \\, \\arctan\\!\\left(\\frac{t}{y_0}\\right).\n$$\n那么\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} F_0(t) = \\tfrac{1}{2} \\log(t^2 + y_0^2) = \\log\\left(\\sqrt{t^2 + y_0^2}\\right),\n$$\n所以\n$$\n\\int \\log\\left(\\sqrt{t^2 + y_0^2}\\right)\\, \\mathrm{d}t = F_0(t) + C, \\quad\n\\int_{a}^{b} \\log\\left(\\sqrt{t^2 + y_0^2}\\right)\\, \\mathrm{d}t = F_0(b) - F_0(a).\n$$\n\n第二个原函数：\n可以通过分部积分和代数变换得到 $t \\log\\left(\\sqrt{t^2+y_0^2}\\right)$ 的一个紧凑反导数，得出\n$$\nF_t(t) = \\tfrac{1}{4}\\, (t^2 + y_0^2)\\, \\log(t^2 + y_0^2) \\;-\\; \\tfrac{1}{4}\\, t^2,\n$$\n它满足\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t} F_t(t) = t \\log\\left(\\sqrt{t^2 + y_0^2}\\right).\n$$\n因此，\n$$\n\\int t \\log\\left(\\sqrt{t^2 + y_0^2}\\right)\\, \\mathrm{d}t = F_t(t) + C, \\quad\n\\int_{a}^{b} t \\log\\left(\\sqrt{t^2 + y_0^2}\\right)\\, \\mathrm{d}t = F_t(b) - F_t(a).\n$$\n\n由此，我们得到所需的定积分：\n- 标量积分：\n$$\nI_0(L,x_0,y_0) = \\int_{-L}^{L} \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s\n= \\int_{a}^{b} \\log\\left(\\sqrt{t^2+y_0^2}\\right)\\, \\mathrm{d}t = F_0(b) - F_0(a).\n$$\n- 线性积分：\n\\begin{align*}\nI_1(L,x_0,y_0) = \\int_{-L}^{L} s\\, \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s\n= \\int_{a}^{b} (t+x_0)\\, \\log\\left(\\sqrt{t^2+y_0^2}\\right)\\, \\mathrm{d}t \\\\\n= \\underbrace{\\int_{a}^{b} t \\log\\left(\\sqrt{t^2+y_0^2}\\right)\\, \\mathrm{d}t}_{F_t(b)-F_t(a)} \\;+\\; x_0\\, \\underbrace{\\int_{a}^{b} \\log\\left(\\sqrt{t^2+y_0^2}\\right)\\, \\mathrm{d}t}_{F_0(b)-F_0(a)} \\\\\n= \\big(F_t(b) - F_t(a)\\big) + x_0\\, \\big(F_0(b) - F_0(a)\\big).\n\\end{align*}\n\n有了这些，解析部分可以组合为\n$$\nI_{\\text{analytic}} = \\varphi(s^\\star)\\, I_0(L,x_0,y_0) \\;+\\; \\varphi'(s^\\star)\\, \\int_{-L}^{L} (s - s^\\star)\\, \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s,\n$$\n最后的积分为\n$$\n\\int_{-L}^{L} (s - s^\\star)\\, \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s\n= I_1(L,x_0,y_0) \\;-\\; s^\\star\\, I_0(L,x_0,y_0).\n$$\n因此，\n$$\nI_{\\text{analytic}} = \\varphi(s^\\star)\\, I_0 \\;+\\; \\varphi'(s^\\star)\\, \\big( I_1 - s^\\star I_0 \\big),\n$$\n其中 $I_0$ 和 $I_1$ 分别是 $I_0(L,x_0,y_0)$ 和 $I_1(L,x_0,y_0)$ 的简写。\n\n光滑余项\n$$\nI_{\\text{smooth}} = \\int_{-L}^{L} \\big(\\varphi(s)-p(s)\\big)\\, \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)\\, \\mathrm{d}s\n$$\n使用固定阶数 $N$ 的高斯-勒让德求积在 $[-L,L]$ 上进行数值积分：\n$$\n\\int_{-L}^{L} f(s)\\, \\mathrm{d}s \\approx \\sum_{i=1}^{N} w_i\\, f(s_i), \\quad s_i = L \\xi_i, \\quad w_i = L \\omega_i,\n$$\n其中 $\\{\\xi_i,\\omega_i\\}_{i=1}^{N}$ 是 $[-1,1]$ 上的节点和权重，雅可比行列式 $L$ 将 $[-1,1]$ 映射到 $[-L,L]$。\n\n作为对比，朴素高斯-勒让德近似 $I_{\\text{GL}}$ 是通过将高斯-勒让德求积直接应用于原始被积函数 $\\varphi(s)\\, \\log\\left(\\sqrt{(s-x_0)^2+y_0^2}\\right)$ 来计算的。参考值 $I_{\\text{ref}}$ 是通过对原始积分进行高精度自适应积分来近似计算的，使用足够严格的绝对和相对容差（例如，$10^{-12}$），以确保参考误差相对于报告的误差可以忽略不计。\n\n每个测试用例 $(L,x_0,y_0)$ 的算法步骤：\n- 计算 $s^\\star = \\min\\{\\max\\{x_0,-L\\},L\\}$。\n- 计算 $\\varphi(s^\\star)$ 和 $\\varphi'(s^\\star)$。\n- 使用闭式表达式 $F_0$ 和 $F_t$ 计算 $I_0$ 和 $I_1$。\n- 通过 $I_0$ 和 $I_1$ 的线性组合构成 $I_{\\text{analytic}}$。\n- 使用阶数为 $N$ 的高斯-勒让德求积法计算余项被积函数的 $I_{\\text{smooth}}$。\n- 组合 $I_{\\text{sub}} = I_{\\text{analytic}} + I_{\\text{smooth}}$。\n- 使用阶数为 $N$ 的高斯-勒让德求积法计算原始被积函数的 $I_{\\text{GL}}$。\n- 通过对原始被积函数进行自适应积分计算 $I_{\\text{ref}}$。\n- 报告 $e_{\\text{std}} = |I_{\\text{GL}} - I_{\\text{ref}}|$ 和 $e_{\\text{sub}} = |I_{\\text{sub}} - I_{\\text{ref}}|$。\n\n基本原理：\n- 解析减去法分离了主要的近奇异结构并精确计算它，从而从数值求积中移除了陡峭的峰值，并在 $y_0$ 很小时极大地减小了误差。\n- 余项是光滑的，因为 $\\varphi(s)-p(s)$ 在最近点处为零且变化缓慢，这使得标准高斯求积法能够表现良好。\n\n预期结果：\n- 对于非常小的 $y_0$，$e_{\\text{sub}}$ 将显著小于 $e_{\\text{std}}$。\n- 对于较大的 $y_0$，两种方法的性能应相似，$e_{\\text{sub}}$ 不会比 $e_{\\text{std}}$ 差。\n\n程序为指定的测试用例实现了这些步骤，并打印包含所需格式的 $[e_{\\text{std}}, e_{\\text{sub}}]$ 对列表的单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\n# Density and its derivative\ndef phi(s):\n    # phi(s) = 1 + s + 0.5 s^2\n    return 1.0 + s + 0.5 * s**2\n\ndef dphi(s):\n    # dphi(s) = 1 + s\n    return 1.0 + s\n\n# Analytic primitives for integrals over [-L, L] with t = s - x0\ndef I0(L, x0, y):\n    # I0 = ∫_{-L}^{L} ln( sqrt( (s - x0)^2 + y^2 ) ) ds\n    a = -L - x0\n    b = L - x0\n    def F0(t):\n        # F0'(t) = 0.5 * ln(t^2 + y^2) = ln(sqrt(t^2 + y^2))\n        return 0.5 * t * np.log(t*t + y*y) - t + y * np.arctan(t / y)\n    return F0(b) - F0(a)\n\ndef I1(L, x0, y):\n    # I1 = ∫_{-L}^{L} s * ln( sqrt( (s - x0)^2 + y^2 ) ) ds\n    a = -L - x0\n    b = L - x0\n    def Ft(t):\n        # Ft'(t) = t * ln( sqrt(t^2 + y^2) )\n        # Compact antiderivative: 0.25*(t^2 + y^2)*ln(t^2 + y^2) - 0.25*t^2\n        return 0.25 * (t*t + y*y) * np.log(t*t + y*y) - 0.25 * t*t\n    def F0(t):\n        return 0.5 * t * np.log(t*t + y*y) - t + y * np.arctan(t / y)\n    It = Ft(b) - Ft(a)\n    I0_val = F0(b) - F0(a)\n    return It + x0 * I0_val\n\n# Gauss-Legendre quadrature on [-L, L]\ndef gauss_legendre_integral(L, x0, y, N, integrand):\n    # Nodes and weights on [-1,1]\n    xi, wi = np.polynomial.legendre.leggauss(N)\n    # Map to [-L, L]: s = L * xi, ds = L\n    s = L * xi\n    w = L * wi\n    vals = integrand(s, x0, y)\n    return np.dot(w, vals)\n\n# Original integrand\ndef integrand_original(s, x0, y):\n    return phi(s) * np.log(np.sqrt((s - x0)**2 + y**2))\n\n# Remainder integrand after analytic subtraction\ndef integrand_remainder(s, x0, y, L):\n    s_star = np.clip(x0, -L, L)\n    p = phi(s_star) + dphi(s_star) * (s - s_star)\n    return (phi(s) - p) * np.log(np.sqrt((s - x0)**2 + y**2))\n\n# Reference via adaptive integration\ndef reference_integral(L, x0, y):\n    f = lambda s: phi(s) * np.log(np.sqrt((s - x0)**2 + y**2))\n    # Tight tolerances for high accuracy\n    val, _ = quad(f, -L, L, epsabs=1e-12, epsrel=1e-12, limit=500)\n    return val\n\n# Analytic subtraction method\ndef analytic_subtraction_integral(L, x0, y, N):\n    s_star = np.clip(x0, -L, L)\n    alpha = phi(s_star)\n    beta = dphi(s_star)\n    I0_val = I0(L, x0, y)\n    I1_val = I1(L, x0, y)\n    analytic_part = alpha * I0_val + beta * (I1_val - s_star * I0_val)\n    # Smooth remainder by Gauss-Legendre\n    rem_integrand = lambda s, x0_, y_: integrand_remainder(s, x0_, y_, L)\n    remainder_part = gauss_legendre_integral(L, x0, y, N, rem_integrand)\n    return analytic_part + remainder_part\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (L, x0, y0)\n    test_cases = [\n        (1.0, 0.0, 1e-6),   # Case A: near-singular, interior projection\n        (1.0, 1.0, 1e-6),   # Case B: near-singular, endpoint projection\n        (1.0, 0.9, 1e-4),   # Case C: moderately near-singular, near endpoint\n        (1.0, 0.0, 1e-1),   # Case D: well-separated field point\n        (2.0, -1.5, 1e-7),  # Case E: longer panel, near-singular, interior\n    ]\n    N = 16  # Gauss-Legendre order\n\n    results = []\n    for L, x0, y0 in test_cases:\n        # Reference\n        I_ref = reference_integral(L, x0, y0)\n        # Naive Gauss-Legendre\n        I_gl = gauss_legendre_integral(L, x0, y0, N, integrand_original)\n        # Analytic subtraction\n        I_sub = analytic_subtraction_integral(L, x0, y0, N)\n        # Errors\n        e_std = abs(I_gl - I_ref)\n        e_sub = abs(I_sub - I_ref)\n        results.append([e_std, e_sub])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join('[' + ','.join(map(str, r)) + ']' for r in results)}]\")\n\nsolve()\n```", "id": "3367567"}, {"introduction": "边界积分方程的理论性质，尤其是其积分算子的特性，直接决定了数值求解的成败。本练习将理论分析与数值实践相结合，带你探究为何在光滑边界上，双层势算子是一个保证数值方法稳定性的“紧算子”，而在带有尖点的非光滑边界上却会失效。通过亲手实现并对比两种边界的数值结果，你将直观地理解边界正则性对Fredholm理论和BEM稳定性的重要意义。[@problem_id:3367622]", "problem": "考虑一个有界域外部的二维拉普拉斯方程的狄利克雷问题，该有界域的边界 $\\Gamma \\subset \\mathbb{R}^2$ 是一条 $C^{2}$ 类的简单闭合曲线。该问题的基本理论是拉普拉斯方程的经典位势论，特别是 Green 表示公式和层位势的跳跃关系。设 $u$ 在无界外部区域满足 $\\Delta u = 0$，在 $\\Gamma$ 上给定 $u = g$，且当 $\\|\\mathbf{x}\\| \\to \\infty$ 时 $u(\\mathbf{x}) \\to 0$。可以使用密度为 $\\mu$ 的双层位势来表示 $u$，形式如下\n$$\nu(\\mathbf{x}) = \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x},\\mathbf{y})}{\\partial n(\\mathbf{y})} \\mu(\\mathbf{y}) \\, \\mathrm{d}s(\\mathbf{y}) \\quad \\text{对于外部区域中的 } \\mathbf{x},\n$$\n其中 $G(\\mathbf{x},\\mathbf{y}) = -\\frac{1}{2\\pi} \\log \\|\\mathbf{x}-\\mathbf{y}\\|$ 是二维自由空间 Green 函数，$\\partial/\\partial n(\\mathbf{y})$ 表示在 $\\mathbf{y} \\in \\Gamma$ 处沿外法线方向的导数。定义双层位势的积分算子已知在边界上具有极限迹，该迹由跳跃关系给出。基于此基本理论，为边界 $\\Gamma$ 上的未知密度 $\\mu$ 建立第二类边界积分方程，形式如下\n$$\n\\left(\\frac{1}{2}I + K\\right)\\mu = g \\quad \\text{在 } \\Gamma \\text{ 上},\n$$\n其中 $K$ 是核函数为\n$$\nK(\\mathbf{x},\\mathbf{y}) = \\frac{\\partial G(\\mathbf{x},\\mathbf{y})}{\\partial n(\\mathbf{y})} = \\frac{1}{2\\pi} \\frac{(\\mathbf{x}-\\mathbf{y}) \\cdot \\mathbf{n}(\\mathbf{y})}{\\|\\mathbf{x}-\\mathbf{y}\\|^2},\n$$\n的边界积分算子，该积分在 Cauchy 主值意义下理解。你的任务是：\n\n- 仅使用位势论基础和光滑流形上弱奇异算子的映射性质，证明当 $\\Gamma$ 是 $C^2$ 类时，为何 $K$ 是在 $\\Gamma$ 上适当的 Sobolev 空间中的紧线性算子，并由此证明为何 $\\frac{1}{2}I + K$ 是指标为 $0$ 的 Fredholm 算子。\n\n- 通过将 $\\Gamma$ 替换为一条带尖点、非 $C^{1}$ 的闭合曲线来构造一个反例，使得 $K$ 的紧性失效。基于核函数在尖点附近的领先阶行为，给出一个局部论证，从泛函分析层面解释紧性为何失效。\n\n- 通过 Nyström 格式的边界元法 (BEM) 离散化，量化其数值后果。使用以下离散设置：用一个 $2\\pi$ 周期的光滑映射 $\\mathbf{x}(t)$（其中 $t \\in [0,2\\pi)$）来参数化 $\\Gamma$，令 $\\Delta t = 2\\pi/N$，在弧度单位下采样 $t_j = (j+\\tfrac{1}{2})\\Delta t$（$j=0,\\dots,N-1$），定义 $\\mathbf{x}_j = \\mathbf{x}(t_j)$、$\\mathbf{t}_j = \\mathbf{x}'(t_j)$、$\\mathbf{n}_j = \\frac{(\\mathbf{t}_j)_y, -(\\mathbf{t}_j)_x}{\\|\\mathbf{t}_j\\|}$（切线顺时针旋转得到单位外法线），以及求积权重 $w_j = \\|\\mathbf{t}_j\\|\\Delta t$。用一个 $N \\times N$ 矩阵 $K_N$ 来近似 $K$，其元素为\n$$\n(K_N)_{ij} =\n\\begin{cases}\n\\frac{1}{2\\pi} \\frac{(\\mathbf{x}_i - \\mathbf{x}_j) \\cdot \\mathbf{n}_j}{\\|\\mathbf{x}_i - \\mathbf{x}_j\\|^2} \\, w_j,  i \\neq j, \\\\\n0,  i=j,\n\\end{cases}\n$$\n以及 $A_N = \\frac{1}{2} I + K_N$。对于光滑的 $\\Gamma$，$A_N$ 离散化了一个第二类 Fredholm 积分方程，随着 $N$ 增大应表现为良态的，而对于带尖点的 $\\Gamma$，离散算子预计会表现出恶化的条件数和非衰减的奇异值。\n\n- 实现一个独立的程序，为两种参数化边界组装 $K_N$ 和 $A_N$：\n  - 光滑边界：单位圆，参数化为 $\\mathbf{x}(t) = (\\cos t, \\sin t)$，$t \\in [0,2\\pi)$。\n  - 带尖点的边界：心形线，在 $t=\\pi$ 处有尖点，极坐标形式参数化为 $r(t) = 1 + \\cos t$，且 $\\mathbf{x}(t) = (r(t)\\cos t, r(t)\\sin t)$，$t \\in [0,2\\pi)$。\n  在两种情况下，都取 $t_j = (j+\\tfrac{1}{2})\\Delta t$ 以避免在尖点处精确采样。\n\n- 对于测试套件中的每个边界和每个 $N$ 值，计算：\n  - 谱 $2$-范数条件数 $\\kappa_2(A_N)$。\n  - 紧性代理指标 $R_{0.9}(K_N)$，定义为 $R_{0.9}(K_N) = \\sigma_{\\lfloor 0.9 N \\rfloor}(K_N)/\\sigma_1(K_N)$，其中 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots$ 是 $K_N$ 的非增奇异值。对于紧算子，随着 $N$ 的增长，该比率应趋近于 $0$；而对于非紧算子，则不应如此。\n\n- 测试套件（所有角度单位均为弧度）：\n  - 光滑单位圆，$N=64$。\n  - 光滑单位圆，$N=128$。\n  - 带尖点的心形线，$N=64$。\n  - 带尖点的心形线，$N=128$。\n\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  [圆（$N=64$）的 $\\kappa_2(A_N)$，圆（$N=64$）的 $R_{0.9}(K_N)$，圆（$N=128$）的 $\\kappa_2(A_N)$，圆（$N=128$）的 $R_{0.9}(K_N)$，心形线（$N=64$）的 $\\kappa_2(A_N)$，心形线（$N=64$）的 $R_{0.9}(K_N)$，心形线（$N=128$）的 $\\kappa_2(A_N)$，心形线（$N=128$）的 $R_{0.9}(K_N)$]。\n\n预期输出为浮点数。不涉及物理单位。所有角度必须使用弧度。实现必须是鲁棒的，即通过使用中点 $t_j = (j+\\tfrac{1}{2})\\Delta t$ 来避免在尖点处进行精确求值。", "solution": "该问题是适定的，且在科学上是合理的，其基础是椭圆偏微分方程的经典位势论和边界积分方程理论。所有给定的定义、条件和任务都是一致且数学上严谨的。因此，我们可以着手给出一个完整的解答。\n\n解答分为三部分。首先，我们为光滑域上边界积分算子的性质提供理论证明。其次，我们分析这些性质在带尖点的域上如何失效。第三，我们描述为验证这些理论预测而设计的数值实现。\n\n### 1. 光滑域上的算子性质\n\n问题要求证明为何当 $\\Gamma$ 是一条 $C^2$ 闭合曲线时，双层位势算子\n$$\n(K\\mu)(\\mathbf{x}) = \\int_{\\Gamma} K(\\mathbf{x},\\mathbf{y}) \\mu(\\mathbf{y}) \\, \\mathrm{d}s(\\mathbf{y}), \\quad \\text{核函数为 } K(\\mathbf{x},\\mathbf{y}) = \\frac{1}{2\\pi} \\frac{(\\mathbf{x}-\\mathbf{y}) \\cdot \\mathbf{n}(\\mathbf{y})}{\\|\\mathbf{x}-\\mathbf{y}\\|^2}\n$$\n是在 $\\Gamma$ 上某个合适的函数空间中的紧算子。\n\n积分算子的紧性取决于其核函数的光滑性。对于 $\\mathbf{x} \\neq \\mathbf{y}$，核函数 $K(\\mathbf{x}, \\mathbf{y})$ 是无穷可微的。关键行为发生在 $\\mathbf{y} \\to \\mathbf{x}$ 时。设 $\\Gamma$ 由一个 $C^2$ 函数 $\\mathbf{z}(t)$ 参数化，其中 $t$ 可取为弧长参数，因此 $\\|\\mathbf{z}'(t)\\| = 1$。令 $\\mathbf{x} = \\mathbf{z}(t_0)$ 且 $\\mathbf{y} = \\mathbf{z}(t)$。对于 $t_0$ 附近的 $t$，我们使用 $\\mathbf{z}(t)$ 在 $t_0$ 处的 Taylor 展开：\n$$\n\\mathbf{z}(t) = \\mathbf{z}(t_0) + (t-t_0)\\mathbf{z}'(t_0) + \\frac{(t-t_0)^2}{2}\\mathbf{z}''(t_0) + O((t-t_0)^3)\n$$\n切向量为 $\\mathbf{T}(t_0) = \\mathbf{z}'(t_0)$，法向量为 $\\mathbf{N}(t_0)$。根据 $\\mathbb{R}^2$ 中的 Frenet-Serret 公式，有 $\\mathbf{z}''(t_0) = \\kappa(t_0) \\mathbf{N}(t_0)$，其中 $\\kappa(t_0)$ 是在 $\\mathbf{z}(t_0)$ 处的曲率。从 $\\mathbf{y}$ 到 $\\mathbf{x}$ 的向量是：\n$$\n\\mathbf{x} - \\mathbf{y} = \\mathbf{z}(t_0) - \\mathbf{z}(t) \\approx -(t-t_0)\\mathbf{T}(t_0) - \\frac{(t-t_0)^2}{2}\\kappa(t_0)\\mathbf{N}(t_0)\n$$\n该向量的范数平方为：\n$$\n\\|\\mathbf{x}-\\mathbf{y}\\|^2 \\approx \\|-(t-t_0)\\mathbf{T}(t_0)\\|^2 = (t-t_0)^2\\|\\mathbf{T}(t_0)\\|^2 = (t-t_0)^2\n$$\n法向量 $\\mathbf{n}(\\mathbf{y}) = \\mathbf{N}(t)$ 也可以展开：\n$$\n\\mathbf{n}(\\mathbf{y}) = \\mathbf{N}(t) \\approx \\mathbf{N}(t_0) + (t-t_0)\\mathbf{N}'(t_0) = \\mathbf{N}(t_0) - (t-t_0)\\kappa(t_0)\\mathbf{T}(t_0)\n$$\n核函数分子中的点积为：\n$$\n(\\mathbf{x}-\\mathbf{y}) \\cdot \\mathbf{n}(\\mathbf{y}) \\approx \\left(-(t-t_0)\\mathbf{T}(t_0) - \\frac{(t-t_0)^2}{2}\\kappa(t_0)\\mathbf{N}(t_0)\\right) \\cdot \\left(\\mathbf{N}(t_0) - (t-t_0)\\kappa(t_0)\\mathbf{T}(t_0)\\right)\n$$\n利用正交性 $\\mathbf{T}(t_0) \\cdot \\mathbf{N}(t_0) = 0$ 和单位性 $\\|\\mathbf{T}(t_0)\\|=\\|\\mathbf{N}(t_0)\\|=1$，点积简化为：\n$$\n(\\mathbf{x}-\\mathbf{y}) \\cdot \\mathbf{n}(\\mathbf{y}) \\approx (-(t-t_0))(-(t-t_0)\\kappa(t_0))\\|\\mathbf{T}(t_0)\\|^2 - \\frac{(t-t_0)^2}{2}\\kappa(t_0)\\|\\mathbf{N}(t_0)\\|^2 = (t-t_0)^2\\kappa(t_0) - \\frac{(t-t_0)^2}{2}\\kappa(t_0) = \\frac{(t-t_0)^2}{2}\\kappa(t_0)\n$$\n因此，当 $\\mathbf{y} \\to \\mathbf{x}$（即 $t \\to t_0$）时，核函数的行为是：\n$$\nK(\\mathbf{x},\\mathbf{y}) \\to \\frac{1}{2\\pi} \\frac{\\frac{(t-t_0)^2}{2}\\kappa(t_0)}{(t-t_0)^2} = \\frac{\\kappa(t_0)}{4\\pi}\n$$\n由于核函数有一个明确定义的有限极限，该奇点是可去的。对于一个 $C^2$ 边界 $\\Gamma$，核函数 $K(\\mathbf{x}, \\mathbf{y})$ 是 $\\Gamma \\times \\Gamma$ 上的连续函数。在一个紧域（如闭合有界曲线 $\\Gamma$）上，具有连续核的积分算子是在诸如 $C(\\Gamma)$ 或 $L^2(\\Gamma)$ 等空间上的紧算子。\n\n算子 $\\frac{1}{2}I + K$ 具有 $\\lambda I - A$ 的形式，其中 $\\lambda = 1/2$，$A = -K$。由于 $K$ 是紧的，所以 $A$ 也是紧的。根据 Fredholm-Riesz-Schauder 理论，形如 $I - (\\text{紧算子})$ 的算子是指标为 $0$ 的 Fredholm 算子。我们的算子可以写成 $\\frac{1}{2}(I + 2K)$，由于 $2K$ 是紧的，$I+2K$ 是指标为 $0$ 的 Fredholm 算子。该性质在乘以非零常数 $\\frac{1}{2}$ 后保持不变。因此，$\\frac{1}{2}I + K$ 是一个指标为 $0$ 的 Fredholm 算子。\n\n### 2. 对于带尖点的几何形状，紧性的失效\n\n我们现在使用心形线构造一个反例，其极坐标参数化为 $r(t) = 1+\\cos t$，$t \\in [0, 2\\pi)$。该曲线在原点处有一个尖点，对应于 $t=\\pi$。在该点，曲线不是 $C^1$ 的，因为切向量 $\\mathbf{x}'(t)$ 为零。\n\n$K$ 的紧性是一种平滑性质，它依赖于核函数 $K(\\mathbf{x}, \\mathbf{y})$ 相对于其自变量的“一致性”行为。边界 $\\Gamma$ 的光滑性对此至关重要。在尖点处，几何形状急剧变化。具体来说，单位外法向量 $\\mathbf{n}(\\mathbf{y})$ 是不连续的。当点 $\\mathbf{y}$ 从曲线的一侧（例如 $t \\to \\pi^-$）趋近尖点时，其法向量 $\\mathbf{n}(\\mathbf{y})$ 趋近于一个极限 $\\mathbf{n}_-$。当它从另一侧（$t \\to \\pi^+$）趋近时，法向量趋近于另一个不同的极限 $\\mathbf{n}_+$。对于心形线的尖点，有 $\\mathbf{n}_- = -\\mathbf{n}_+$。\n核函数 $K(\\mathbf{x}, \\mathbf{y})$ 直接依赖于 $\\mathbf{n}(\\mathbf{y})$。法向量的这种不连续性被核函数所继承。对于任何不在尖点的固定点 $\\mathbf{x}$，函数 $\\mathbf{y} \\mapsto K(\\mathbf{x}, \\mathbf{y})$ 在尖点处是不连续的。泛函分析中的一个标准结果指出，要使积分算子在 $C(\\Gamma)$ 上是紧的，函数族 $\\{K(\\cdot, \\mathbf{y}) : \\mathbf{y} \\in \\Gamma\\}$ 必须是等度连续的。尖点处的不连续性违反了这一条件，使得算子在 $C(\\Gamma)$ 上不是紧的。一个类似但技术上更复杂的论证也表明它在 $L^2(\\Gamma)$ 上也失去紧性。缺少紧性意味着该算子不再是“单位算子 + 紧算子”的形式，Fredholm 择一性原理也不再适用。该方程不再是第二类 Fredholm 积分方程。\n\n### 3. 数值研究与后果\n\n我们使用 Nyström 离散化格式将积分算子 $K$ 转换为矩阵 $K_N$，并将积分方程转换为线性系统。\n$$\n\\left(\\frac{1}{2}I + K_N\\right)\\boldsymbol{\\mu} = \\mathbf{g}\n$$\n其中 $\\boldsymbol{\\mu}$ 和 $\\mathbf{g}$ 是在 $\\Gamma$ 上 $N$ 个配置点集 $\\{\\mathbf{x}_j\\}_{j=0}^{N-1}$ 上的函数值向量。\n\n计算两个度量指标来量化离散算子的性质：\n1.  **条件数 $\\kappa_2(A_N)$**：系统矩阵 $A_N = \\frac{1}{2}I + K_N$ 的谱条件数。对于一个适定的第二类 Fredholm 方程，离散系统应该是良态的，即当 $N \\to \\infty$ 时 $\\kappa_2(A_N)$ 保持有界。对于紧性失效的问题，我们预计 $\\kappa_2(A_N)$ 会随 $N$ 增长，表明数值不稳定。\n2.  **紧性代理指标 $R_{0.9}(K_N)$**：定义为 $R_{0.9}(K_N) = \\sigma_{\\lfloor 0.9 N \\rfloor}(K_N)/\\sigma_1(K_N)$，该比率衡量 $K_N$ 的奇异值衰减的速度。对于紧算子，有限秩近似可以达到任意精度，这反映在奇异值快速衰减至零。因此，对于光滑圆，我们预计当 $N \\to \\infty$ 时 $R_{0.9}(K_N) \\to 0$。对于心形线上的非紧算子，奇异值衰减要慢得多，我们预计 $R_{0.9}(K_N)$ 会趋于一个非零常数。\n\n该实现将为单位圆（一个 $C^\\infty$ 边界）和心形线（一个带尖点的非 $C^1$ 边界）在 $N=64$ 和 $N=128$ 的情况下计算这些量。预期结果将证实理论预测：对于圆，条件数稳定且较小，奇异值快速衰减；而对于心形线，条件数增长，奇异值衰减缓慢。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to execute the BEM analysis for the specified test cases.\n    \"\"\"\n    test_cases = [\n        ('circle', 64),\n        ('circle', 128),\n        ('cardioid', 64),\n        ('cardioid', 128),\n    ]\n\n    results = []\n    for boundary_type, N in test_cases:\n        # 1. Set up discretization\n        dt = 2.0 * np.pi / N\n        # Use midpoints to avoid evaluating at t=pi (the cusp)\n        t = (np.arange(N) + 0.5) * dt\n\n        # 2. Define geometry and its derivatives\n        if boundary_type == 'circle':\n            # Parameterization for the unit circle\n            x_coords = np.cos(t)\n            y_coords = np.sin(t)\n            # Derivatives for tangent vector computation\n            xp = -np.sin(t)\n            yp = np.cos(t)\n        elif boundary_type == 'cardioid':\n            # Parameterization for the cardioid\n            r = 1.0 + np.cos(t)\n            x_coords = r * np.cos(t)\n            y_coords = r * np.sin(t)\n            # Derivatives for tangent vector computation\n            xp = -np.sin(t) * (1.0 + 2.0 * np.cos(t))\n            yp = np.cos(t) + np.cos(2.0 * t)\n        \n        # Collocation points (N x 2 array)\n        x_j = np.vstack((x_coords, y_coords)).T\n        \n        # Tangent vectors (N x 2 array)\n        t_j = np.vstack((xp, yp)).T\n        \n        # Norms of tangent vectors (length N array)\n        norm_t_j = np.linalg.norm(t_j, axis=1)\n        \n        # Outward unit normal vectors (N x 2 array)\n        # Normal is a clockwise 90-degree rotation of the tangent\n        n_j = np.vstack((t_j[:, 1], -t_j[:, 0])).T / norm_t_j[:, np.newaxis]\n        \n        # Quadrature weights\n        w_j = norm_t_j * dt\n\n        # 3. Assemble the kernel matrix K_N\n        K_N = np.zeros((N, N))\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    # Diagonal entries are set to zero as per the Nyström scheme definition\n                    K_N[i, j] = 0.0\n                else:\n                    diff = x_j[i, :] - x_j[j, :]\n                    norm_diff_sq = np.dot(diff, diff)\n                    dot_prod = np.dot(diff, n_j[j, :])\n                    K_N[i, j] = (1.0 / (2.0 * np.pi)) * (dot_prod / norm_diff_sq) * w_j[j]\n\n        # 4. Form the system matrix A_N\n        A_N = 0.5 * np.eye(N) + K_N\n\n        # 5. Compute metrics\n        # a) Condition number of A_N\n        cond_A_N = np.linalg.cond(A_N, 2)\n        \n        # b) Compactness proxy for K_N\n        # Compute singular values of K_N, sorted in non-increasing order\n        s = linalg.svd(K_N, compute_uv=False)\n        \n        # The problem asks for sigma_k, where k = floor(0.9*N). This implies 1-based\n        # indexing for sigma. NumPy s is 0-indexed. So s[k-1] corresponds to sigma_k.\n        k = int(np.floor(0.9 * N))\n        compactness_proxy_index = k - 1\n        \n        if len(s) > compactness_proxy_index and s[0] > 1e-15:\n            R_09_K_N = s[compactness_proxy_index] / s[0]\n        else:\n            R_09_K_N = 0.0 # Handle cases where K_N is nearly zero or rank-deficient\n\n        results.append(cond_A_N)\n        results.append(R_09_K_N)\n\n    # Convert results to string for the final output format\n    result_str = ','.join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3367622"}]}