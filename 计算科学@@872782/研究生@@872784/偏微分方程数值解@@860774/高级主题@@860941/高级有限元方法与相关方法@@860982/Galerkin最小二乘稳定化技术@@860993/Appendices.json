{"hands_on_practices": [{"introduction": "要真正掌握一种数值方法，关键在于理解其数学构造的底层细节。本练习将引导你从最基本的变分形式出发，为一维对流扩散问题推导流线迎风/彼得罗夫-伽辽金（SUPG）方法的离散格式。通过亲手构建修正后的单元刚度矩阵和组装全局线性系统，你将揭开稳定化方法看似神秘的面纱，为后续的理论分析和编程实践打下坚实的数学基础 [@problem_id:3397671]。", "problem": "考虑开区间 $\\Omega=(0,L)$ 上的齐次狄利克雷边界条件 $u(0)=0$ 和 $u(L)=0$ 的一维稳态对流扩散边界值问题，\n$$\n-\\epsilon\\,u''(x) + a\\,u'(x) = f(x), \\quad x\\in(0,L),\n$$\n其中 $\\epsilon>0$ 和 $a\\in\\mathbb{R}\\setminus\\{0\\}$ 是常系数，$f(x)$ 是一个给定的源项。用 $N$ 个长度为 $h=L/N$ 的单元组成的均匀网格对 $\\Omega$ 进行离散化，并令 $V_h$ 表示从属于该网格且在 $x=0$ 和 $x=L$ 处为零的连续分片线性（$P_1$）函数空间。考虑流线迎风/Petrov–Galerkin (SUPG) 稳定格式，该格式在基于残差的伽辽金/最小二乘意义下解释，其中检验空间通过逐单元添加一个与沿对流场的方向导数成正比的流线项来进行修正。具体来说，对于一个任意但单元上为常数的稳定化参数 $\\tau>0$（该参数可能依赖于 $h$、$a$ 和 $\\epsilon$），使用形式为 $v_h + \\tau\\,a\\,v_h'$ 的检验函数，其中 $v_h\\in V_h$。\n\n从标准弱形式和基于残差的SUPG增广出发，在分片线性试探函数（因此单元上的二阶导数为零）的假设下，根据局部帽子函数 $\\varphi_1$ 和 $\\varphi_2$ 及其导数，推导在一个一般单元 $K=[x_i,x_{i+1}]$ 上的显式 $2\\times 2$ 单元矩阵，然后为内部节点组装全局线性系统。只处理双线性（左手边）的贡献，并假设 $a$ 和 $\\epsilon$ 在 $\\Omega$ 上是常数。你的推导必须从弱形式和SUPG残差的定义开始，并通过使用 $P_1$ 基函数的性质来计算精确的单元积分。\n\n最后，对于与内部节点方程相关的组装好的三对角系统，将节点 $i$ 处的三个非零系数——次对角系数 $\\ell$（耦合 $u_{i-1}$）、对角系数 $d$（耦合 $u_i$）和主对角系数 $u$（耦合 $u_{i+1}$）——完全用 $\\epsilon$、$a$、$h$ 和 $\\tau$ 来表示。将你的最终答案以包含这三个闭式解析表达式的单行矩阵 $\\begin{pmatrix}\\ell & d & u\\end{pmatrix}$ 的形式给出。不需要进行数值计算，也不应进行四舍五入。", "solution": "所述问题具有科学依据、是适定的、客观的，并包含获得唯一可验证解所需的所有信息。因此，我们可以进行推导。\n\n出发点是定义域 $\\Omega=(0,L)$ 上的一维稳态对流扩散方程的强形式：\n$$\n-\\epsilon\\,u''(x) + a\\,u'(x) = f(x)\n$$\n带有齐次狄利克雷边界条件 $u(0)=0$ 和 $u(L)=0$。系数 $\\epsilon>0$ 和 $a\\in\\mathbb{R}\\setminus\\{0\\}$ 是常数。\n\n标准的伽辽金弱形式寻求一个解 $u_h$，它来自有限维试探空间 $V_h$，使得对于所有检验函数 $v_h \\in V_h$：\n$$\n\\int_0^L (-\\epsilon\\,u_h'' + a\\,u_h') v_h \\,dx = \\int_0^L f v_h \\,dx\n$$\n对二阶项进行分部积分，并应用边界条件 $v_h(0)=v_h(L)=0$，得到双线性形式 $B(u_h, v_h)$：\n$$\nB(u_h, v_h) = \\int_0^L \\left(\\epsilon\\,u_h' v_h' + a\\,u_h' v_h\\right) dx\n$$\n\n流线迎风/Petrov–Galerkin (SUPG) 方法将检验函数修正为 $w_h = v_h + \\delta_h$，其中 $\\delta_h$ 是为增强稳定性而选择的扰动项。按照规定，检验函数的形式为 $v_h + \\tau a v_h'$，其中 $\\tau>0$ 是在每个单元上为常数的稳定化参数。SUPG弱形式是寻找 $u_h \\in V_h$，使得对于所有 $v_h \\in V_h$：\n$$\n\\int_0^L (-\\epsilon u_h'' + a u_h' - f) (v_h + \\tau a v_h') \\,dx = 0\n$$\n这是一种基于残差的方法，我们要求残差 $R(u_h) = -\\epsilon u_h'' + a u_h' - f$ 与修正后的检验空间正交。关注双线性形式（左手边），我们有：\n$$\nB_{SUPG}(u_h, v_h) = \\int_0^L (-\\epsilon u_h'' + a u_h') (v_h + \\tau a v_h') \\,dx\n$$\n展开此表达式得到：\n$$\nB_{SUPG}(u_h, v_h) = \\int_0^L (-\\epsilon u_h'' + a u_h') v_h \\,dx + \\int_0^L (-\\epsilon u_h'' + a u_h') (\\tau a v_h') \\,dx\n$$\n第一项在分部积分后是标准的伽辽金双线性形式 $B(u_h, v_h)$。第二项是稳定项。问题指定对 $V_h$ 使用连续分片线性（$P_1$）基函数。对于此类函数，二阶导数 $u_h''$ 在每个单元 $K$ 内部为零。应用此简化后，稳定项变为：\n$$\n\\int_0^L (a u_h') (\\tau a v_h') \\,dx = \\sum_{K} \\int_K \\tau a^2 u_h' v_h' \\,dx\n$$\n结合伽辽金部分和稳定部分，完整的SUPG双线性形式是：\n$$\nB_{SUPG}(u_h, v_h) = \\int_0^L \\left(\\epsilon u_h' v_h' + a u_h' v_h\\right) dx + \\sum_{K} \\int_K \\tau a^2 u_h' v_h' \\,dx\n$$\n由于积分可以逐单元计算，我们可以将来自长度为 $h = x_{i+1} - x_i$ 的单个一般单元 $K=[x_i, x_{i+1}]$ 的贡献写为：\n$$\nB_{SUPG}^K(u_h, v_h) = \\int_K \\left[(\\epsilon + \\tau a^2) u_h' v_h' + a u_h' v_h\\right] dx\n$$\n为了推导单元矩阵，我们通过映射 $\\xi = (x - x_i)/h$ 在参考单元 $[0,1]$ 上使用局部线性基函数（“帽子函数”）。局部基函数为：\n$$\n\\varphi_1(\\xi) = 1 - \\xi \\quad \\text{和} \\quad \\varphi_2(\\xi) = \\xi\n$$\n它们关于 $x$ 的导数是：\n$$\n\\frac{d\\varphi_1}{dx} = \\frac{d\\varphi_1}{d\\xi}\\frac{d\\xi}{dx} = (-1)\\frac{1}{h} = -\\frac{1}{h}\n$$\n$$\n\\frac{d\\varphi_2}{dx} = \\frac{d\\varphi_2}{d\\xi}\\frac{d\\xi}{dx} = (1)\\frac{1}{h} = \\frac{1}{h}\n$$\n$2\\times 2$ 单元矩阵 $A^K$ 的元素为 $A^K_{jk} = B_{SUPG}^K(\\varphi_k, \\varphi_j)$，其中 $j$ 是检验函数的索引，$k$ 是试探函数的索引。使用变量代换 $dx = h\\,d\\xi$：\n$$\nA^K_{jk} = \\int_{x_i}^{x_{i+1}} \\left[(\\epsilon + \\tau a^2) \\varphi_k' \\varphi_j' + a \\varphi_k' \\varphi_j\\right] dx = \\frac{\\epsilon + \\tau a^2}{h} \\int_0^1 \\frac{d\\varphi_k}{d\\xi}\\frac{d\\varphi_j}{d\\xi} d\\xi + a \\int_0^1 \\frac{d\\varphi_k}{d\\xi} \\varphi_j d\\xi\n$$\n我们计算两个积分矩阵。首先是“刚度”部分：$S_{jk} = \\int_0^1 \\frac{d\\varphi_j}{d\\xi}\\frac{d\\varphi_k}{d\\xi} d\\xi$。\n$$\nS = \\begin{pmatrix} \\int_0^1(-1)(-1)d\\xi  \\int_0^1(-1)(1)d\\xi \\\\ \\int_0^1(1)(-1)d\\xi  \\int_0^1(1)(1)d\\xi \\end{pmatrix} = \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n其次是“对流”部分：$C_{jk} = \\int_0^1 \\varphi_j \\frac{d\\varphi_k}{d\\xi} d\\xi$。\n$$\nC_{11} = \\int_0^1 (1-\\xi)(-1)d\\xi = -\\frac{1}{2}, \\quad C_{12} = \\int_0^1 (1-\\xi)(1)d\\xi = \\frac{1}{2}\n$$\n$$\nC_{21} = \\int_0^1 (\\xi)(-1)d\\xi = -\\frac{1}{2}, \\quad C_{22} = \\int_0^1 (\\xi)(1)d\\xi = \\frac{1}{2}\n$$\n所以，矩阵 $C$ 是 $C = \\begin{pmatrix} -1/2  1/2 \\\\ -1/2  1/2 \\end{pmatrix}$。\n因此，单元矩阵 $A^K$ 为：\n$$\nA^K = \\frac{\\epsilon + \\tau a^2}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} + a \\begin{pmatrix} -1/2  1/2 \\\\ -1/2  1/2 \\end{pmatrix} = \\begin{pmatrix} \\frac{\\epsilon + \\tau a^2}{h} - \\frac{a}{2}  -\\frac{\\epsilon + \\tau a^2}{h} + \\frac{a}{2} \\\\ -\\frac{\\epsilon + \\tau a^2}{h} - \\frac{a}{2}  \\frac{\\epsilon + \\tau a^2}{h} + \\frac{a}{2} \\end{pmatrix}\n$$\n我们为内部节点 $i$ 组装全局系统。未知量 $u_i$ 的方程是通过将检验函数设为全局基函数 $\\phi_i$ 来形成的。节点 $i$ 通过单元 $K_{i-1}=[x_{i-1}, x_i]$ 和 $K_i=[x_i, x_{i+1}]$ 与节点 $i-1$ 和 $i+1$ 相连。\n$u_{i-1}$ 的系数（次对角，$\\ell$）是试探函数 $\\phi_{i-1}$ 和检验函数 $\\phi_i$ 之间的耦合。这发生在单元 $K_{i-1}$ 上，其中 $\\phi_{i-1}$ 是第一个局部基函数（$\\varphi_1$），$\\phi_i$ 是第二个局部基函数（$\\varphi_2$）。该系数为 $A^K_{21}$。\n$$\n\\ell = A^K_{21} = -\\frac{\\epsilon + \\tau a^2}{h} - \\frac{a}{2}\n$$\n$u_{i+1}$ 的系数（主对角，$u$）是试探函数 $\\phi_{i+1}$ 和检验函数 $\\phi_i$ 之间的耦合。这发生在单元 $K_i$ 上，其中 $\\phi_i$ 是第一个局部基函数（$\\varphi_1$），$\\phi_{i+1}$ 是第二个局部基函数（$\\varphi_2$）。该系数为 $A^K_{12}$。\n$$\nu = A^K_{12} = -\\frac{\\epsilon + \\tau a^2}{h} + \\frac{a}{2}\n$$\n$u_i$ 的系数（对角，$d$）是 $\\phi_i$ 与自身的耦合。它从 $K_{i-1}$ 获得一个贡献，其中 $\\phi_i$ 是第二个局部基函数（$\\varphi_2$），贡献为 $A^K_{22}$。它还从 $K_i$ 获得一个贡献，其中 $\\phi_i$ 是第一个局部基函数（$\\varphi_1$），贡献为 $A^K_{11}$。总系数是二者之和。\n$$\nd = A^K_{11} + A^K_{22} = \\left(\\frac{\\epsilon + \\tau a^2}{h} - \\frac{a}{2}\\right) + \\left(\\frac{\\epsilon + \\tau a^2}{h} + \\frac{a}{2}\\right) = \\frac{2(\\epsilon + \\tau a^2)}{h}\n$$\n因此，内部节点 $i$ 处方程的三个非零系数被完全确定。", "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{\\epsilon + \\tau a^2}{h} - \\frac{a}{2} & \\frac{2(\\epsilon + \\tau a^2)}{h} & -\\frac{\\epsilon + \\tau a^2}{h} + \\frac{a}{2} \\end{pmatrix}}\n$$", "id": "3397671"}, {"introduction": "理解了SUPG方法的数学构造后，下一个自然的问题是：我们为什么需要它？这个编程练习旨在直观且定量地回答这个问题。你将通过编写代码，直接比较标准伽辽金方法和SUPG方法在求解对流占优问题时的表现，并计算由数值解产生的伪振荡的幅度。这项实践将理论与可见的结果联系起来，让你深刻体会到稳定化技术在确保解的物理真实性方面的关键作用 [@problem_id:3397663]。", "problem": "考虑单位区间上的稳态一维平流-扩散边界值问题，其形式如下：求一个标量场 $u(x)$ 满足\n$$\n-\\varepsilon \\, u''(x) + a \\, u'(x) = 0 \\quad \\text{for } x \\in (0,1),\n$$\n边界条件为狄利克雷（Dirichlet）边界条件\n$$\nu(0) = 1, \\quad u(1) = 0,\n$$\n其中 $\\varepsilon > 0$ 是扩散系数，$a \\neq 0$ 是恒定的平流速度。您将使用连续的分段线性有限元，在具有 $N$ 个单元的均匀网格上离散化此问题，并采用两种公式：\n- 标准的 Bubnov-Galerkin 方法（记作 \"Galerkin\"），\n- 流线迎风 Petrov-Galerkin (SUPG) 稳定化方法，它是 Galerkin/最小二乘法族的一员，其单元稳定化参数为常数 $\\tau = \\frac{h}{2 |a|}$，其中 $h = \\frac{1}{N}$ 是均匀的单元尺寸。\n\n从强形式出发，使用标准的变分框架来推导每个离散公式。然后通过从单元贡献组装全局矩阵来显式地实现两个离散算子。对于均匀网格和常系数上的线性形函数，您可以依赖于从双线性形式的定义中派生出的规范局部贡献，但您必须精确保留由变分形式产生的非对称平流算子。\n\n将离散解 $u_h$ 的“类吉布斯振荡幅值”定义为超出上边界值的过冲量与低于下边界值的下冲量之和：\n$$\n\\mathcal{A}(u_h) \\;=\\; \\max\\!\\big(0, \\max_{x \\in [0,1]} u_h(x) - 1 \\big) \\;+\\; \\max\\!\\big(0, 0 - \\min_{x \\in [0,1]} u_h(x) \\big).\n$$\n在均匀网格上，于节点值处评估 $\\mathcal{A}(u_h)$。\n\n您的任务是实现一个完整的程序，该程序：\n- 为 Galerkin 和 SUPG 公式组装并求解线性系统，\n- 为两种公式计算 $\\mathcal{A}(u_h)$，\n- 报告 SUPG 相对于 Galerkin 实现的振荡定量减少量。\n\n使用以下参数集 $(N, \\varepsilon, a)$ 的测试套件：\n- 情况 #1：$(N, \\varepsilon, a) = (40, 10^{-2}, 1)$，\n- 情况 #2：$(N, \\varepsilon, a) = (80, 10^{-4}, 1)$，\n- 情况 #3：$(N, \\varepsilon, a) = (40, 10^{-6}, 1)$。\n\n对于每种情况，计算三个浮点数：\n- $A_G = \\mathcal{A}(u_h^{\\text{Galerkin}})$，\n- $A_S = \\mathcal{A}(u_h^{\\text{SUPG}})$，\n- $\\Delta = A_G - A_S$。\n\n最终的程序输出必须是以下格式的单行：\n$$\n\\big[ A_G^{(1)}, A_S^{(1)}, \\Delta^{(1)}, A_G^{(2)}, A_S^{(2)}, \\Delta^{(2)}, A_G^{(3)}, A_S^{(3)}, \\Delta^{(3)} \\big],\n$$\n即一个 Python 风格的列表，按顺序列出三种情况的九个结果，条目之间用逗号分隔，无附加文本。所有计算都是无量纲的；不需要物理单位。不使用角度。不使用百分比：所有结果都是实数。请确保您的实现对于指定的 $(N, \\varepsilon, a)$ 是通用的，并且组装和边界条件强制执行在数学上与所述的离散化方法一致。", "solution": "该问题被验证为具有科学依据、适定且客观。它是偏微分方程数值分析中的一个标准基准问题，包含了唯一解所需的所有数据和定义。所选参数旨在突出 Bubnov-Galerkin 方法在平流主导情况下已知的缺陷，以及 SUPG 稳定化技术的有效性。\n\n问题是在域 $x \\in (0,1)$上求解稳态一维平流-扩散方程：\n$$\n-\\varepsilon u''(x) + a u'(x) = 0\n$$\n满足狄利克雷边界条件 $u(0) = 1$ 和 $u(1) = 0$。这里，$\\varepsilon > 0$ 是扩散系数，$a \\neq 0$ 是恒定的平流速度。\n\n为了推导有限元公式，我们首先建立问题的弱（变分）形式。我们将控制方程乘以一个来自合适的函数空间 $W$ 的检验函数 $v(x)$，并在域 $\\Omega = (0,1)$ 上积分：\n$$\n\\int_0^1 (-\\varepsilon u'' + a u') v \\, dx = 0\n$$\n对二阶扩散项进行分部积分，$-\\int_0^1 \\varepsilon u'' v \\, dx = \\int_0^1 \\varepsilon u' v' \\, dx - [\\varepsilon u' v]_0^1$，得到：\n$$\n\\int_0^1 (\\varepsilon u' v' + a u' v) \\, dx - [\\varepsilon u' v]_0^1 = 0\n$$\n为了处理 $u$ 上的本质边界条件，我们在一个试验空间 $V$ 中寻找解 $u$，该空间的成员满足这些条件。检验函数 $v$ 从一个空间 $W_0$ 中选取，其中函数在指定狄利克雷条件的边界处为零，即 $v(0) = v(1) = 0$。这个选择消除了边界项 $[\\varepsilon u' v]_0^1$。弱形式于是为：求 $u \\in V$ 使得 $u(0)=1, u(1)=0$，对所有 $v \\in W_0$ 满足：\n$$\nB(u, v) = \\int_0^1 (\\varepsilon u' v' + a u' v) \\, dx = 0\n$$\n项 $B(u, v)$ 是一个双线性形式。该问题使用有限元方法在具有 $N$ 个单元的均匀网格上进行离散化，单元尺寸为 $h=1/N$。节点位于 $x_i = i h$，$i=0, 1, \\dots, N$。解 $u(x)$ 由一个连续的分段线性函数 $u_h(x) = \\sum_{j=0}^N U_j \\phi_j(x)$ 来近似，其中 $U_j$ 是解的节点值，$\\phi_j(x)$ 是标准的线性“帽”状基函数。\n\nBubnov-Galerkin 公式对试验函数和检验函数使用相同的空间，因此 $v_h(x)$ 也是基函数 $\\phi_j(x)$ 的线性组合。离散系统由单元级贡献组装而成。在一个长度为 $h$ 的通用单元 $\\Omega_e = [x_e, x_{e+1}]$ 上，局部基函数为 $N_1(x) = (x_{e+1}-x)/h$ 和 $N_2(x) = (x-x_e)/h$，其导数为 $N_1'(x) = -1/h$ 和 $N_2'(x) = 1/h$。$2 \\times 2$ 的单元刚度矩阵 $\\mathbf{k}^e_G$ 的项为 $k^e_{ij} = B(\\phi_j, \\phi_i)|_{\\Omega_e}$，使用局部坐标表示为 $k^e_{\\alpha\\beta} = \\int_{\\Omega_e} (\\varepsilon N_\\beta' N_\\alpha' + a N_\\beta' N_\\alpha) \\, dx$，其中 $\\alpha, \\beta \\in \\{1,2\\}$。\n扩散部分为 $\\mathbf{k}^e_{diff} = \\frac{\\varepsilon}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$。\n平流部分为 $\\mathbf{k}^e_{adv} = \\frac{a}{2} \\begin{pmatrix} -1  1 \\\\ -1  1 \\end{pmatrix}$。\nGalerkin 单元矩阵是它们的和：\n$$\n\\mathbf{k}^e_G = \\frac{\\varepsilon}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} + \\frac{a}{2} \\begin{pmatrix} -1  1 \\\\ -1  1 \\end{pmatrix} = \\begin{pmatrix} \\frac{\\varepsilon}{h} - \\frac{a}{2}  -\\frac{\\varepsilon}{h} + \\frac{a}{2} \\\\ -\\frac{\\varepsilon}{h} - \\frac{a}{2}  \\frac{\\varepsilon}{h} + \\frac{a}{2} \\end{pmatrix}\n$$\n这个矩阵在组装后，会导致对平流项的中心差分近似，这在平流主导扩散时（即单元佩克莱数 $Pe_h = |a|h/(2\\varepsilon) > 1$ 时）容易产生伪振荡。\n\n流线迎风 Petrov-Galerkin (SUPG) 方法在弱形式中引入一个稳定项来解决这些振荡。修正后的弱形式为：\n$$\nB(u_h, v_h) + \\sum_{e=0}^{N-1} \\int_{\\Omega_e} \\mathcal{R}(u_h) \\, \\mathcal{P}(v_h) \\, dx = 0\n$$\n其中 $\\mathcal{R}(u_h) = -\\varepsilon u_h'' + a u_h'$ 是强形式的残差，$\\mathcal{P}(v_h)$ 是对检验函数的扰动。对于 SUPG 稳定化，扰动与流线方向对齐，$\\mathcal{P}(v_h) = \\tau a v_h'$。由于 $u_h$ 是分段线性的，其二阶导数 $u_h''$ 在每个单元内部为零。稳定项简化为：\n$$\nB_{stab}(u_h, v_h) = \\sum_{e=0}^{N-1} \\int_{\\Omega_e} (a u_h') (\\tau a v_h') \\, dx\n$$\n稳定化参数给定为 $\\tau = \\frac{h}{2|a|}$。单元稳定化矩阵 $\\mathbf{k}^e_{stab}$ 的项为 $k^e_{stab, \\alpha\\beta} = \\int_{\\Omega_e} \\tau (a N_\\beta') (a N_\\alpha') dx = \\tau a^2 \\int_{\\Omega_e} N_\\alpha' N_\\beta' dx$。这与扩散矩阵成正比：\n$$\n\\mathbf{k}^e_{stab} = \\tau a^2 \\left( \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\right) = \\frac{h}{2|a|} a^2 \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} = \\frac{|a|}{2} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n总的 SUPG 单元矩阵为 $\\mathbf{k}^e_S = \\mathbf{k}^e_G + \\mathbf{k}^e_{stab}$。对于 $a > 0$ 的情况，即 $|a|=a$，这变为：\n$$\n\\mathbf{k}^e_S = \\left( \\frac{\\varepsilon}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} + \\frac{a}{2} \\begin{pmatrix} -1  1 \\\\ -1  1 \\end{pmatrix} \\right) + \\frac{a}{2} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} = \\frac{\\varepsilon}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} + a \\begin{pmatrix} 0  0 \\\\ -1  1 \\end{pmatrix}\n$$\n这些单元矩阵的组装产生了一个全局线性方程组 $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$，其规模为 $(N-1) \\times (N-1)$，用于求解未知的内部节点值 $\\mathbf{U} = [U_1, \\dots, U_{N-1}]^T$。边界条件 $U_0=1$ 和 $U_N=0$ 通过修改完整系统的第一个和最后一个方程来施加，将已知量移到右端向量 $\\mathbf{F}$。对于内部节点 $i$，线性系统的组装行由单元矩阵的系数决定。对于 Galerkin 方法，方程为 $(-\\frac{\\varepsilon}{h} - \\frac{a}{2})U_{i-1} + (\\frac{2\\varepsilon}{h})U_i + (-\\frac{\\varepsilon}{h} + \\frac{a}{2})U_{i+1} = 0$。对于 SUPG ($a>0$)，它变为 $(-\\frac{\\varepsilon}{h}-a)U_{i-1} + (\\frac{2\\varepsilon}{h}+a)U_i + (-\\frac{\\varepsilon}{h})U_{i+1} = 0$。右端向量 $\\mathbf{F}$ 仅在其第一个条目中非零，这是由 $x=0$ 处的边界条件造成的。对于节点 $i=1$，涉及 $U_0=1$ 的项被移到右侧。节点 $1$ 的方程中 $U_0$ 的系数是 $K_{1,0}$，它对应于单元矩阵项 $k^e_{1,0}$，其中单元 $0$ 的局部节点 $1$ 是全局节点 $0$，局部节点 $2$ 是全局节点 $1$。这对应于使用检验函数 $\\phi_1$ 和试验函数 $\\phi_0$。该项是 $k^e_{21}$。所以，$F_1 = -K_{1,0} U_0 = -k^e_{21} \\cdot 1$。对于 Galerkin 方法，$F_1 = \\frac{\\varepsilon}{h} + \\frac{a}{2}$。对于 SUPG 方法，$F_1=\\frac{\\varepsilon}{h}+a$。\n\n类吉布斯振荡幅值 $\\mathcal{A}(u_h)$ 从节点解向量 $\\mathbf{U}_{full} = [1, U_1, \\dots, U_{N-1}, 0]^T$ 使用以下公式计算：\n$$\n\\mathcal{A}(u_h) = \\max(0, \\max(\\mathbf{U}_{full}) - 1) + \\max(0, 0 - \\min(\\mathbf{U}_{full}))\n$$\n该算法通过为每个测试案例，首先对 Galerkin 方法然后对 SUPG 方法实施此组装和求解过程，来计算各自的振荡幅值 $A_G$ 和 $A_S$，以及它们的差值 $\\Delta = A_G - A_S$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_fem_1d(N, epsilon, a, method='Galerkin'):\n    \"\"\"\n    Solves the 1D advection-diffusion problem using linear finite elements.\n\n    Args:\n        N (int): Number of elements.\n        epsilon (float): Diffusion coefficient.\n        a (float): Advection speed.\n        method (str): 'Galerkin' or 'SUPG'.\n\n    Returns:\n        numpy.ndarray: The full nodal solution vector U of size (N+1).\n    \"\"\"\n    h = 1.0 / N\n    num_unknowns = N - 1\n\n    if num_unknowns == 0:\n        # Handle trivial case N=1\n        return np.array([1.0, 0.0])\n\n    # Initialize the (N-1)x(N-1) system matrix K and RHS vector F\n    K_red = np.zeros((num_unknowns, num_unknowns))\n    F_red = np.zeros(num_unknowns)\n\n    # Define element matrices based on the chosen method\n    k_diff = (epsilon / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n    k_adv = (a / 2.0) * np.array([[-1.0, 1.0], [-1.0, 1.0]])\n\n    if method == 'Galerkin':\n        k_elem = k_diff + k_adv\n    elif method == 'SUPG':\n        if a == 0:\n            k_stab = np.zeros((2, 2))\n        else:\n            # Stabilization matrix contribution with tau = h / (2 * |a|)\n            k_stab = (abs(a) / 2.0) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n        k_elem = k_diff + k_adv + k_stab\n    else:\n        raise ValueError(\"Method must be 'Galerkin' or 'SUPG'\")\n\n    # Assemble the reduced tridiagonal system for interior nodes\n    lower_diag = k_elem[1, 0]\n    main_diag = k_elem[0, 0] + k_elem[1, 1]\n    upper_diag = k_elem[0, 1]\n\n    np.fill_diagonal(K_red, main_diag)\n    if num_unknowns > 1:\n        # Use np.diag_indices_from and slicing for robust diagonal filling\n        rows, cols = np.diag_indices_from(K_red)\n        K_red[rows[1:], cols[:-1]] = lower_diag\n        K_red[rows[:-1], cols[1:]] = upper_diag\n\n    # Apply boundary conditions\n    # u(0) = 1 (affects the first equation for U_1)\n    # The term k_elem[1,0] * U_0 is moved to the RHS\n    F_red[0] = -k_elem[1, 0] * 1.0\n    \n    # u(N) = 0 (affects the last equation for U_{N-1})\n    # The term k_elem[0,1] * U_N is moved to the RHS. Since U_N=0, this is 0.\n    # No modification needed for F_red[num_unknowns-1] as it is already 0.\n\n    # Solve the linear system for interior nodes\n    U_internal = np.linalg.solve(K_red, F_red)\n\n    # Construct the full solution vector including boundary nodes\n    U_full = np.zeros(N + 1)\n    U_full[0] = 1.0\n    U_full[N] = 0.0\n    U_full[1:N] = U_internal\n\n    return U_full\n\ndef compute_oscillation_amplitude(u_h):\n    \"\"\"\n    Computes the Gibbs-like oscillation amplitude for a nodal solution.\n    \"\"\"\n    overshoot = np.max([0.0, np.max(u_h) - 1.0])\n    undershoot = np.max([0.0, 0.0 - np.min(u_h)])\n    return overshoot + undershoot\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (40, 1e-2, 1.0),\n        (80, 1e-4, 1.0),\n        (40, 1e-6, 1.0),\n    ]\n\n    results = []\n    for N, epsilon, a in test_cases:\n        # Solve using Bubnov-Galerkin method\n        U_G = solve_fem_1d(N, epsilon, a, method='Galerkin')\n        A_G = compute_oscillation_amplitude(U_G)\n\n        # Solve using SUPG method\n        U_S = solve_fem_1d(N, epsilon, a, method='SUPG')\n        A_S = compute_oscillation_amplitude(U_S)\n\n        # Compute reduction in oscillation\n        Delta = A_G - A_S\n        \n        results.extend([A_G, A_S, Delta])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3397663"}, {"introduction": "前面的练习中使用的是一个简单的、静态的稳定化参数 $\\tau$。然而，在更复杂的瞬态问题中，稳定化参数的选择需要同时考虑空间和时间尺度。本练习将挑战你推导一个基于算子谱半径的动态稳定化参数 $\\tau_{\\text{dyn}}$。这个高级实践不仅展示了伽辽金最小二乘（GLS）方法理论的深度和灵活性，也为你将来在尖端应用中如何通过优化参数选择来提升数值模拟的精度和稳定性提供了宝贵的思路 [@problem_id:3397666]。", "problem": "考虑在一维空间区间上的瞬态标量平流偏微分方程（PDE），其具有齐次狄利克雷流入边界条件，\n$$\n\\frac{\\partial u}{\\partial t} + \\beta \\frac{\\partial u}{\\partial x} = 0,\n$$\n其中 $u(x,t)$ 是未知标量场，$\\beta \\in \\mathbb{R}$ 是一个恒定的对流速度，$x \\in [0,1]$ 且 $t \\ge 0$。在一个连续伽辽金（Galerkin）基于残差的最小二乘稳定化框架中，一个稳定化参数 $\\,\\tau\\,$ 对添加到变分形式中的最小二乘一致性项进行加权。在瞬态模拟中，$\\,\\tau\\,$ 应同时反映空间对流和时间演化。在对流主导的情况下，一个经典的静态选择是 $\\,\\tau_{\\text{classic}} \\sim h/(2|\\beta|)\\,$，其中 $\\,h\\,$ 是单元尺寸，$\\,|\\beta|\\,$ 是对流速度的大小。\n\n你的任务是，从第一性原理出发，基于单元对流算子和时间算子的局部谱半径，推导出一个动态稳定化参数 $\\,\\tau_{\\text{dyn}}\\,$，然后实现一个程序，对给定的一组测试参数，计算 $\\,\\tau_{\\text{dyn}}\\,$ 并将其与经典的 $\\,\\tau_{\\text{classic}}\\,$ 进行比较。对于每个测试用例，该程序必须生成一个单一的浮点比率 $\\,r = \\tau_{\\text{dyn}} / \\tau_{\\text{classic}}\\,$。\n\n从以下经过充分测试的数值分析基础开始：\n- 在单元上使用标准 $\\,L^2\\,$ 内积的 PDE 的弱（变分）形式。\n- 在长度为 $\\,h\\,$ 的单元上的一维线性有限元（分段线性，$\\,\\mathbb{P}_1\\,$）基，其形函数为 $\\,N_1(x)\\,$ 和 $\\,N_2(x)\\,$，并且在每个单元上的梯度为常数 $\\,\\partial_x N_1 = -1/h\\,$ 和 $\\,\\partial_x N_2 = 1/h\\,$。\n- 局部单元 $\\,L^2\\,$ 质量矩阵 $\\,M_e = \\int_e N_i N_j \\, dx\\,$ 和作用于试探函数的残差算子 $\\,\\mathcal{L} = \\beta \\,\\partial/\\partial x\\,$。\n- 后向欧拉时间离散，被视为一个为残差平衡贡献时间尺度 $\\,\\Delta t\\,$ 的线性算子。\n\n使用这些，按以下步骤进行：\n1. 通过在由 $\\,\\{N_1, N_2\\}\\,$ 张成的空间中的非零 $\\,v\\,$ 上，最大化 $\\,\\|\\mathcal{L} v\\|_{L^2(e)}\\,$ 相对于 $\\,\\|v\\|_{L^2(e)}\\,$ 的瑞利商，来推导单个 $\\,\\mathbb{P}_1\\,$ 单元上对流算子 $\\,\\mathcal{L}\\,$ 的局部谱半径，其中 $\\,e\\,$ 表示单个单元。将得到的谱半径 $\\,\\rho_{\\text{conv}}(h,\\beta)\\,$ 用 $\\,h\\,$ 和 $\\,\\beta\\,$ 显式表示。\n2. 将时间贡献建模为与后向欧拉方法在 $\\,u_t\\,$ 的残差尺度上相关的谱半径 $\\,\\rho_{\\text{time}}(\\Delta t)\\,$，并证明其显式形式的合理性。\n3. 通过算子尺度的范数等价聚合，将这两个贡献组合成一个单一的动态稳定化参数，\n$$\n\\tau_{\\text{dyn}}(h,\\beta,\\Delta t) = \\frac{1}{\\sqrt{\\rho_{\\text{conv}}(h,\\beta)^2 + \\rho_{\\text{time}}(\\Delta t)^2}}.\n$$\n4. 定义经典稳定化参数，\n$$\n\\tau_{\\text{classic}}(h,\\beta) = \\frac{h}{2|\\beta|}.\n$$\n5. 对于下面测试套件中的每组参数，计算并返回比率\n$$\nr(h,\\beta,\\Delta t) = \\frac{\\tau_{\\text{dyn}}(h,\\beta,\\Delta t)}{\\tau_{\\text{classic}}(h,\\beta)}.\n$$\n\n实现一个完整的、可运行的程序，该程序针对以下测试套件，输出一行包含逗号分隔的 $\\,r\\,$ 值 Python 列表，每个值四舍五入到八位小数：\n- 测试用例 $\\,1\\,$：$\\,h = 0.1\\,$, $\\,\\beta = 1.0\\,$, $\\,\\Delta t = 0.01\\,$.\n- 测试用例 $\\,2\\,$：$\\,h = 0.1\\,$, $\\,\\beta = 0.001\\,$, $\\,\\Delta t = 0.01\\,$.\n- 测试用例 $\\,3\\,$：$\\,h = 0.01\\,$, $\\,\\beta = 10.0\\,$, $\\,\\Delta t = 0.001\\,$.\n- 测试用例 $\\,4\\,$：$\\,h = 0.05\\,$, $\\,\\beta = 2.0\\,$, $\\,\\Delta t = 0.0001\\,$.\n- 测试用例 $\\,5\\,$：$\\,h = 0.2\\,$, $\\,\\beta = 10^{-8}\\,$, $\\,\\Delta t = 0.05\\,$.\n\n对于此问题，所有量均为无量纲。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4,r_5]$）。每个 $\\,r_i\\,$ 必须是四舍五入到八位小数的浮点数。", "solution": "该问题要求为瞬态标量平流方程推导动态稳定化参数 $\\tau_{\\text{dyn}}$，并将其与经典参数 $\\tau_{\\text{classic}}$ 进行比较。推导过程如前所述，从第一性原理出发。\n\n控制偏微分方程为：\n$$\n\\frac{\\partial u}{\\partial t} + \\beta \\frac{\\partial u}{\\partial x} = 0\n$$\n对于 $x \\in [0,1]$ 和 $t \\ge 0$，其中 $\\beta \\in \\mathbb{R}$ 为恒定对流速度。\n\n动态稳定化参数 $\\tau_{\\text{dyn}}$ 被表达为：\n$$\n\\tau_{\\text{dyn}}(h,\\beta,\\Delta t) = \\frac{1}{\\sqrt{\\rho_{\\text{conv}}(h,\\beta)^2 + \\rho_{\\text{time}}(\\Delta t)^2}}\n$$\n其中 $\\rho_{\\text{conv}}$ 和 $\\rho_{\\text{time}}$ 分别是长度为 $h$ 的一维线性有限元（$\\mathbb{P}_1$）上对流算子和时间算子的谱半径。\n\n**步骤 1：对流谱半径 $\\rho_{\\text{conv}}(h,\\beta)$ 的推导**\n\n对流算子为 $\\mathcal{L} = \\beta \\frac{\\partial}{\\partial x}$。我们寻求其在长度为 $h$ 的单个单元 $e$ 上的 $\\mathbb{P}_1$ 函数空间中的谱半径。谱半径的平方 $\\rho_{\\text{conv}}^2$ 是瑞利商的最大值：\n$$\n\\rho_{\\text{conv}}^2 = \\sup_{v_h \\neq 0} \\frac{\\|\\mathcal{L} v_h\\|_{L^2(e)}^2}{\\|v_h\\|_{L^2(e)}^2} = \\sup_{v_h \\neq 0} \\frac{\\int_e (\\beta \\frac{\\partial v_h}{\\partial x})^2 dx}{\\int_e v_h^2 dx}\n$$\n其中 $v_h$ 是局部 $\\mathbb{P}_1$ 空间中的一个函数。单元上的函数 $v_h$ 可以写为 $v_h(x) = \\sum_{j=1}^2 c_j N_j(x)$，其中 $N_j$ 是线性形函数，$\\mathbf{c} = [c_1, c_2]^T$ 是节点值的向量。\n\n分子可以表示为二次型 $\\mathbf{c}^T \\mathbf{A}_e \\mathbf{c}$，分母可以表示为 $\\mathbf{c}^T \\mathbf{M}_e \\mathbf{c}$。该问题等价于求解广义特征值问题 $\\mathbf{A}_e \\mathbf{c} = \\lambda \\mathbf{M}_e \\mathbf{c}$ 的最大特征值 $\\lambda$。\n\n设单元定义在区间 $[0, h]$ 上。形函数为 $N_1(x) = 1 - x/h$ 和 $N_2(x) = x/h$。它们的导数为常数：$N_1'(x) = -1/h$ 和 $N_2'(x) = 1/h$。\n\n单元质量矩阵 $\\mathbf{M}_e$ 的分量为 $M_{ij} = \\int_0^h N_i N_j dx$：\n$$\n\\mathbf{M}_e = \\int_0^h \\begin{pmatrix} (1-x/h)^2  (1-x/h)(x/h) \\\\ (x/h)(1-x/h)  (x/h)^2 \\end{pmatrix} dx = \\frac{h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}\n$$\n与分子相关的矩阵 $\\mathbf{A}_e$ 的分量为 $A_{ij} = \\int_0^h (\\beta N_i')(\\beta N_j') dx = \\beta^2 \\int_0^h N_i' N_j' dx$：\n$$\n\\mathbf{A}_e = \\beta^2 \\int_0^h \\begin{pmatrix} (-1/h)^2  (-1/h)(1/h) \\\\ (1/h)(-1/h)  (1/h)^2 \\end{pmatrix} dx = \\frac{\\beta^2}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n我们求解 $\\det(\\mathbf{A}_e - \\lambda \\mathbf{M}_e) = 0$：\n$$\n\\det\\left( \\frac{\\beta^2}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} - \\lambda \\frac{h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} \\right) = 0\n$$\n$$\n\\det \\begin{pmatrix} \\frac{\\beta^2}{h} - \\frac{2\\lambda h}{6}  -\\frac{\\beta^2}{h} - \\frac{\\lambda h}{6} \\\\ -\\frac{\\beta^2}{h} - \\frac{\\lambda h}{6}  \\frac{\\beta^2}{h} - \\frac{2\\lambda h}{6} \\end{pmatrix} = 0\n$$\n令 $A = \\beta^2/h$ 且 $B = \\lambda h/6$，则行列式为 $(A - 2B)^2 - (-A - B)^2 = 0$。这可以简化为 $(A-2B - (-A-B))(A-2B + (-A-B)) = 0$，从而得到 $(2A - B)(-3B) = 0$。\n$B$ 的解为 $B=0$ 或 $B=2A$。因为 $B = \\lambda h/6$，所以特征值为 $\\lambda_1 = 0$ 和 $\\lambda_2 = 12A/h = 12(\\beta^2/h)/h = 12\\beta^2/h^2$。\n最大特征值为 $\\lambda_{\\max} = 12\\beta^2/h^2$。这就是 $\\rho_{\\text{conv}}^2$。\n因此，对流算子的谱半径为：\n$$\n\\rho_{\\text{conv}}(h, \\beta) = \\sqrt{\\lambda_{\\max}} = \\sqrt{\\frac{12\\beta^2}{h^2}} = \\frac{2\\sqrt{3}|\\beta|}{h}\n$$\n\n**步骤 2：时间谱半径 $\\rho_{\\text{time}}(\\Delta t)$ 的合理性证明**\n\n时间算子是 $\\frac{\\partial}{\\partial t}$。采用后向欧拉时间离散，这被近似为 $\\frac{u^n - u^{n-1}}{\\Delta t}$。此表达式中作用于当前时间步未知解 $u^n$ 的部分是 $\\frac{1}{\\Delta t} u^n$。我们将对残差算子的贡献建模为 $\\mathcal{L}_{\\text{time}} = \\frac{1}{\\Delta t} \\mathrm{Id}$，其中 $\\mathrm{Id}$ 是单位算子。\n\n遵循与对流算子相同的原则，我们通过最大化瑞利商来求谱半径：\n$$\n\\rho_{\\text{time}}^2 = \\sup_{v_h \\neq 0} \\frac{\\| \\frac{1}{\\Delta t} v_h \\|_{L^2(e)}^2}{\\|v_h\\|_{L^2(e)}^2} = \\sup_{v_h \\neq 0} \\frac{\\frac{1}{(\\Delta t)^2} \\int_e v_h^2 dx}{\\int_e v_h^2 dx} = \\frac{1}{(\\Delta t)^2}\n$$\n因此，时间算子的谱半径为：\n$$\n\\rho_{\\text{time}}(\\Delta t) = \\sqrt{\\frac{1}{(\\Delta t)^2}} = \\frac{1}{\\Delta t}\n$$\n这一选择与用于 $\\rho_{\\text{conv}}$ 的方法论一致，并代表了由一阶时间离散格式引入的特征尺度。\n\n**步骤 3：组合成动态稳定化参数 $\\tau_{\\text{dyn}}$**\n\n将推导出的谱半径代入给定的 $\\tau_{\\text{dyn}}$ 公式：\n$$\n\\tau_{\\text{dyn}}(h,\\beta,\\Delta t) = \\frac{1}{\\sqrt{\\rho_{\\text{conv}}^2 + \\rho_{\\text{time}}^2}} = \\frac{1}{\\sqrt{\\left(\\frac{2\\sqrt{3}|\\beta|}{h}\\right)^2 + \\left(\\frac{1}{\\Delta t}\\right)^2}} = \\frac{1}{\\sqrt{\\frac{12\\beta^2}{h^2} + \\frac{1}{(\\Delta t)^2}}}\n$$\n\n**步骤 4：定义经典稳定化参数 $\\tau_{\\text{classic}}$**\n\n问题为了比较，显式定义了经典稳定化参数为：\n$$\n\\tau_{\\text{classic}}(h,\\beta) = \\frac{h}{2|\\beta|}\n$$\n该公式是用于对流主导的稳态问题的一个众所周知的启发式公式。\n\n**步骤 5：比率 $r$ 的计算**\n\n最终任务是计算比率 $r = \\tau_{\\text{dyn}} / \\tau_{\\text{classic}}$：\n$$\nr(h,\\beta,\\Delta t) = \\frac{\\tau_{\\text{dyn}}}{\\tau_{\\text{classic}}} = \\frac{ \\frac{1}{\\sqrt{\\frac{12\\beta^2}{h^2} + \\frac{1}{(\\Delta t)^2}}} }{ \\frac{h}{2|\\beta|} }\n$$\n简化表达式：\n$$\nr = \\frac{2|\\beta|}{h} \\frac{1}{\\sqrt{\\frac{12\\beta^2(\\Delta t)^2 + h^2}{h^2 (\\Delta t)^2}}} = \\frac{2|\\beta|}{h} \\frac{h \\Delta t}{\\sqrt{12\\beta^2 (\\Delta t)^2 + h^2}}\n$$\n$$\nr(h,\\beta,\\Delta t) = \\frac{2|\\beta|\\Delta t}{\\sqrt{12 \\beta^2 (\\Delta t)^2 + h^2}}\n$$\n这就是将在程序中实现以评估测试用例的最终表达式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the ratio r = tau_dyn / tau_classic for a series of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1: h = 0.1, beta = 1.0, delta_t = 0.01\n        (0.1, 1.0, 0.01),\n        # Test case 2: h = 0.1, beta = 0.001, delta_t = 0.01\n        (0.1, 0.001, 0.01),\n        # Test case 3: h = 0.01, beta = 10.0, delta_t = 0.001\n        (0.01, 10.0, 0.001),\n        # Test case 4: h = 0.05, beta = 2.0, delta_t = 0.0001\n        (0.05, 2.0, 0.0001),\n        # Test case 5: h = 0.2, beta = 1e-8, delta_t = 0.05\n        (0.2, 1e-8, 0.05),\n    ]\n\n    results = []\n    for h, beta, delta_t in test_cases:\n        # Derived formula for the ratio r:\n        # r = (2 * |beta| * delta_t) / sqrt(12 * beta^2 * delta_t^2 + h^2)\n\n        abs_beta = np.abs(beta)\n        \n        # Numerator of the ratio formula\n        numerator = 2.0 * abs_beta * delta_t\n        \n        # Denominator of the ratio formula\n        denominator_squared = 12.0 * (abs_beta * delta_t)**2 + h**2\n        denominator = np.sqrt(denominator_squared)\n        \n        if denominator == 0:\n            # This case should not occur with the given problem constraints\n            # (h > 0), but it's good practice to handle it.\n            # If both numerator and denominator are zero, the limit is subject to\n            # how they approach zero. If only denominator is zero, it's an infinity.\n            # For this problem's physics, h > 0 implies denominator > 0.\n            r = np.inf\n        else:\n            r = numerator / denominator\n        \n        # Format the result to exactly eight decimal places.\n        # Using a format string is more reliable for specific decimal place\n        # representation than round() for printing purposes.\n        formatted_r = \"{:.8f}\".format(r)\n        results.append(formatted_r)\n\n    # The final output must be a single string representing a Python list.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3397666"}]}