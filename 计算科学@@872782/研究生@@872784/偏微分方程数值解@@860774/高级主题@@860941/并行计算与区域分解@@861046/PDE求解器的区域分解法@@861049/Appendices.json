{"hands_on_practices": [{"introduction": "为了从根本上理解区域分解法的工作原理，我们从一个基础的计算练习开始。这个练习将带你手动完成加性Schwarz预处理共轭梯度法（PCG）的单步迭代。通过显式地计算一个小型一维泊松问题中的所有组成部分——包括限制算子、子区域求解和预处理后的残差——你将对该方法的内部机制有一个具体而清晰的认识。这个练习是掌握更复杂区域分解技巧的必要第一步。[@problem_id:3382438]", "problem": "考虑一个由均匀网格上具有齐次狄利克雷边界条件的泊松方程的一维（1D）有限元（FE）离散化产生的对称正定线性系统 $A x = b$。刚度矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$ 由下式给出\n$$\nA \\;=\\; \\begin{pmatrix}\n2  -1  0  0 \\\\\n-1  2  -1  0 \\\\\n0  -1  2  -1 \\\\\n0  0  -1  2\n\\end{pmatrix}.\n$$\n我们考虑一个具有两个重叠子域的加性 Schwarz (AS) 预条件子。限制矩阵 $R_{1} \\in \\mathbb{R}^{3 \\times 4}$ 和 $R_{2} \\in \\mathbb{R}^{3 \\times 4}$ 分别通过选择子域自由度 $\\{1,2,3\\}$ 和 $\\{2,3,4\\}$ 来定义：\n$$\nR_{1} \\;=\\; \\begin{pmatrix}\n1  0  0  0\\\\\n0  1  0  0\\\\\n0  0  1  0\n\\end{pmatrix},\n\\qquad\nR_{2} \\;=\\; \\begin{pmatrix}\n0  1  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}.\n$$\n局部子域算子为 $A_{1} \\;=\\; R_{1} A R_{1}^{\\top}$ 和 $A_{2} \\;=\\; R_{2} A R_{2}^{\\top}$，加性 Schwarz 预条件子为\n$$\nM^{-1} \\;=\\; R_{1}^{\\top} A_{1}^{-1} R_{1} \\;+\\; R_{2}^{\\top} A_{2}^{-1} R_{2}.\n$$\n使用左预处理共轭梯度（CG）方法，初始值设为 $x^{(0)} = 0$，残差为 $r^{(0)} = b - A x^{(0)} = b$，预处理残差为 $z^{(0)} = M^{-1} r^{(0)}$，搜索方向为 $p^{(0)} = z^{(0)}$，步长为\n$$\n\\alpha_{0} \\;=\\; \\frac{(r^{(0)}, z^{(0)})}{(p^{(0)}, A p^{(0)})},\n$$\n其中 $(\\cdot,\\cdot)$ 是 $\\mathbb{R}^{4}$ 上的标准欧几里得内积。取右端项为\n$$\nb \\;=\\; \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}.\n$$\n计算此次加性 Schwarz 预处理 CG 迭代的第一步步长 $\\alpha_{0}$ 的精确值。请以精确实数形式给出答案（不要四舍五入）。", "solution": "该问题经验证是自洽的、有科学依据且适定的。这是数值线性代数和区域分解方法领域的一个标准计算。我将继续进行求解。\n\n目标是计算预处理共轭梯度（CG）方法的第一步步长 $\\alpha_{0}$。$\\alpha_{0}$ 的公式由下式给出：\n$$\n\\alpha_{0} \\;=\\; \\frac{(r^{(0)}, z^{(0)})}{(p^{(0)}, A p^{(0)})}\n$$\n其中 $(\\cdot,\\cdot)$ 表示标准欧几里得内积。这可以用向量转置写成：\n$$\n\\alpha_{0} \\;=\\; \\frac{(r^{(0)})^{\\top} z^{(0)}}{(p^{(0)})^{\\top} (A p^{(0)})}\n$$\n我们将逐步计算此表达式中的每一项。\n\n首先，我们确定初始残差 $r^{(0)}$。给定初始猜测 $x^{(0)} = 0$ 和右端向量 $b$ 为 $\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$，我们有：\n$$\nr^{(0)} \\;=\\; b - A x^{(0)} \\;=\\; b - A \\cdot 0 \\;=\\; b \\;=\\; \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n\n接下来，我们计算预处理残差 $z^{(0)} = M^{-1} r^{(0)}$。这需要构造加性 Schwarz 预条件子 $M^{-1}$。\n该预条件子定义为：\n$$\nM^{-1} \\;=\\; R_{1}^{\\top} A_{1}^{-1} R_{1} \\;+\\; R_{2}^{\\top} A_{2}^{-1} R_{2}\n$$\n其中 $A_{1} \\;=\\; R_{1} A R_{1}^{\\top}$ 且 $A_{2} \\;=\\; R_{2} A R_{2}^{\\top}$。\n\n我们来计算子域刚度矩阵 $A_{1}$ 和 $A_{2}$。\n矩阵 $A$ 由下式给出：\n$$\nA \\;=\\; \\begin{pmatrix}\n2  -1  0  0 \\\\\n-1  2  -1  0 \\\\\n0  -1  2  -1 \\\\\n0  0  -1  2\n\\end{pmatrix}\n$$\n限制矩阵为：\n$$\nR_{1} \\;=\\; \\begin{pmatrix}\n1  0  0  0\\\\\n0  1  0  0\\\\\n0  0  1  0\n\\end{pmatrix},\n\\qquad\nR_{2} \\;=\\; \\begin{pmatrix}\n0  1  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n运算 $R_{1} A R_{1}^{\\top}$ 提取了 $A$ 中对应于前三个索引的主子矩阵。\n$$\nA_1 \\;=\\; R_{1} A R_{1}^{\\top} \\;=\\; \\begin{pmatrix}\n2  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  2\n\\end{pmatrix}\n$$\n类似地，运算 $R_{2} A R_{2}^{\\top}$ 提取了 $A$ 中对应于后三个索引（索引 $2, 3, 4$）的主子矩阵。\n$$\nA_2 \\;=\\; R_{2} A R_{2}^{\\top} \\;=\\; \\begin{pmatrix}\n2  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  2\n\\end{pmatrix}\n$$\n我们观察到 $A_{1} = A_{2}$。我们将这个 $3 \\times 3$ 矩阵记为 $A_{sub}$。我们需要计算它的逆矩阵 $A_{sub}^{-1}$。\n$A_{sub}$ 的行列式为：\n$$\n\\det(A_{sub}) \\;=\\; 2(2 \\cdot 2 - (-1)(-1)) - (-1)(-1 \\cdot 2 - (-1) \\cdot 0) \\;=\\; 2(3) - 2 \\;=\\; 4\n$$\n逆矩阵由 $A_{sub}^{-1} = \\frac{1}{\\det(A_{sub})} \\text{adj}(A_{sub})$ 给出。伴随矩阵是代数余子式矩阵的转置。\n$A_{sub}$ 的代数余子式矩阵 $C$ 为：\n$$\nC \\;=\\; \\begin{pmatrix}\n(4-1)  -(-2-0)  (1-0) \\\\\n-(-2-0)  (4-0)  -(-2-0) \\\\\n(1-0)  -(-2-0)  (4-1)\n\\end{pmatrix} \\;=\\; \\begin{pmatrix}\n3  2  1 \\\\\n2  4  2 \\\\\n1  2  3\n\\end{pmatrix}\n$$\n由于 $C$ 是对称的，$\\text{adj}(A_{sub}) = C^{\\top} = C$。因此：\n$$\nA_{1}^{-1} \\;=\\; A_{2}^{-1} \\;=\\; A_{sub}^{-1} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n3  2  1 \\\\\n2  4  2 \\\\\n1  2  3\n\\end{pmatrix}\n$$\n现在我们组装预条件子 $M^{-1}$。项 $R_{1}^{\\top} A_{1}^{-1} R_{1}$ 将 $A_{1}^{-1}$ 嵌入到一个 $4 \\times 4$ 零矩阵的左上角 $3 \\times 3$ 子块中。项 $R_{2}^{\\top} A_{2}^{-1} R_{2}$ 将 $A_{2}^{-1}$ 嵌入到一个 $4 \\times 4$ 零矩阵的右下角 $3 \\times 3$ 子块（索引为 $2,3,4$）中。\n$$\nR_{1}^{\\top} A_{1}^{-1} R_{1} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n3  2  1  0 \\\\\n2  4  2  0 \\\\\n1  2  3  0 \\\\\n0  0  0  0\n\\end{pmatrix}\n$$\n$$\nR_{2}^{\\top} A_{2}^{-1} R_{2} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n0  0  0  0 \\\\\n0  3  2  1 \\\\\n0  2  4  2 \\\\\n0  1  2  3\n\\end{pmatrix}\n$$\n将这两个矩阵相加得到 $M^{-1}$：\n$$\nM^{-1} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n3  2  1  0 \\\\\n2  4+3  2+2  1 \\\\\n1  2+2  3+4  2 \\\\\n0  1  2  3\n\\end{pmatrix} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n3  2  1  0 \\\\\n2  7  4  1 \\\\\n1  4  7  2 \\\\\n0  1  2  3\n\\end{pmatrix}\n$$\n现在我们可以计算 $z^{(0)}$：\n$$\nz^{(0)} \\;=\\; M^{-1} r^{(0)} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n3  2  1  0 \\\\\n2  7  4  1 \\\\\n1  4  7  2 \\\\\n0  1  2  3\n\\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} \\;=\\; \\frac{1}{4} \\begin{pmatrix} 3 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix}\n$$\n我们现在可以计算 $\\alpha_{0}$ 的分子：\n$$\n(r^{(0)})^{\\top} z^{(0)} \\;=\\; \\begin{pmatrix} 1  0  0  0 \\end{pmatrix} \\left( \\frac{1}{4} \\begin{pmatrix} 3 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix} \\right) \\;=\\; \\frac{3}{4}\n$$\n接下来，我们计算分母。初始搜索方向为 $p^{(0)} = z^{(0)}$。因此，我们需要计算 $(p^{(0)})^{\\top} (A p^{(0)})$。\n首先，我们计算乘积 $A p^{(0)}$：\n$$\nA p^{(0)} \\;=\\; A z^{(0)} \\;=\\; \\begin{pmatrix}\n2  -1  0  0 \\\\\n-1  2  -1  0 \\\\\n0  -1  2  -1 \\\\\n0  0  -1  2\n\\end{pmatrix} \\left( \\frac{1}{4} \\begin{pmatrix} 3 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix} \\right) \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n2(3) - 1(2) \\\\\n-1(3) + 2(2) - 1(1) \\\\\n-1(2) + 2(1) \\\\\n-1(1)\n\\end{pmatrix} \\;=\\; \\frac{1}{4} \\begin{pmatrix}\n4 \\\\ 0 \\\\ 0 \\\\ -1\n\\end{pmatrix}\n$$\n现在，我们计算分母的内积：\n$$\n(p^{(0)})^{\\top} (A p^{(0)}) \\;=\\; (z^{(0)})^{\\top} (A z^{(0)}) \\;=\\; \\left( \\frac{1}{4} \\begin{pmatrix} 3 \\\\ 2 \\\\ 1 \\\\ 0 \\end{pmatrix} \\right)^{\\top} \\left( \\frac{1}{4} \\begin{pmatrix} 4 \\\\ 0 \\\\ 0 \\\\ -1 \\end{pmatrix} \\right)\n$$\n$$\n(p^{(0)})^{\\top} (A p^{(0)}) \\;=\\; \\frac{1}{16} \\begin{pmatrix} 3  2  1  0 \\end{pmatrix} \\begin{pmatrix} 4 \\\\ 0 \\\\ 0 \\\\ -1 \\end{pmatrix} \\;=\\; \\frac{1}{16} (3 \\cdot 4 + 2 \\cdot 0 + 1 \\cdot 0 + 0 \\cdot (-1)) \\;=\\; \\frac{12}{16} \\;=\\; \\frac{3}{4}\n$$\n最后，我们通过计算分子和分母的比值来计算 $\\alpha_{0}$：\n$$\n\\alpha_{0} \\;=\\; \\frac{(r^{(0)})^{\\top} z^{(0)}}{(p^{(0)})^{\\top} (A p^{(0)})} \\;=\\; \\frac{3/4}{3/4} \\;=\\; 1\n$$\n第一步步长的精确值为 $1$。", "answer": "$$\n\\boxed{1}\n$$", "id": "3382438"}, {"introduction": "单层Schwarz方法虽然直观，但其收敛性会随着子区域数量的增加而退化。为了构建可扩展的求解器，引入“粗空间校正”是至关重要的。这个编程练习旨在通过实践来验证两层Schwarz方法的可扩展性。你将为一个一维问题构建一个代数粗空间，并编写代码来数值验证预处理后系统的条件数如何不依赖于子区域的剖分尺度。这个练习将理论与实践相结合，突显了粗空间在现代高性能区域分解求解器中的核心作用。[@problem_id:3382437]", "problem": "考虑单位区间上具有齐次 Dirichlet 边界条件的一维泊松方程，其强形式为 $-u''(x)=f(x)$，$x\\in(0,1)$，且 $u(0)=u(1)=0$。使用有限差分法 (FDM) 在 $N$ 个内部点上对该问题进行离散化，网格间距均匀，为 $h=1/(N+1)$，从而得到一个对称正定 (SPD) 线性系统 $A u = b$，其中 $A\\in\\mathbb{R}^{N\\times N}$ 是标准的三对角刚度矩阵，其元素为 $A_{ii}=\\frac{2}{h^2}$ 和 $A_{i,i\\pm 1}=-\\frac{1}{h^2}$。\n\n将 $N$ 个自由度划分为 $m$ 个构成一维链的连续子域，并为每个子域定义一个重叠的局部索引集，重叠部分包含 $p$ 个细网格点。对每个子域，设 $R_i\\in\\mathbb{R}^{n_i\\times N}$ 为限制算子，用于提取与重叠子域索引集相对应的局部未知量，并定义局部 SPD 矩阵 $A_i=R_i A R_i^T$。构建一个形式如下的两层加性 Schwarz 预条件子 $M^{-1}$\n$$\nM^{-1} \\;=\\; \\sum_{i=1}^m R_i^T A_i^{-1} R_i \\;+\\; R_0^T A_0^{-1} R_0,\n$$\n其中 $R_0\\in\\mathbb{R}^{(m-1)\\times N}$ 是一个粗糙限制算子，它由一个基于一维子域链上的分段线性基向量的代数粗糙空间构建。具体而言，定义粗糙网格点为 $x_j=jH$，$j=0,1,\\dots,m$，其中 $H=1/m$。构造 $(m-1)$ 个支撑在 $[x_{j-1},x_{j+1}]$ 上的帽函数 $\\{\\phi_j\\}_{j=1}^{m-1}$，每个函数满足 $\\phi_j(x_j)=1$ 和 $\\phi_j(x_{j\\pm 1})=0$，并在 $[x_{j-1},x_j]$ 和 $[x_j,x_{j+1}]$ 上呈线性变化。在细网格点 $x_k=(k+1)h$（$k=0,\\dots,N-1$）上计算这些基函数的值，以组装 $R_0$，使得 $(R_0)_{j,k}=\\phi_j(x_k)$。组装粗糙矩阵 $A_0=R_0 A R_0^T$。\n\n从上述定义以及 SPD 算子和加性 Schwarz 方法的性质出发，推导一个程序化步骤来：\n- 从 FDM 离散化构建 $A$。\n- 将自由度划分为 $m$ 个大小均衡的连续子域，并构建重叠为 $p$ 的重叠索引集。\n- 组装局部限制算子 $R_i$ 和局部矩阵 $A_i$。\n- 使用基于子域端点构成的粗糙网格上的分段线性基向量，构建代数粗糙限制算子 $R_0$，并组装 $A_0$。\n- 形成两层加性 Schwarz 预条件子 $M^{-1}$ 的显式稠密矩阵表示，并评估 $M^{-1}A$ 的谱。\n- 计算谱条件数 $\\kappa(M^{-1}A)=\\lambda_{\\max}/\\lambda_{\\min}$，其中 $\\lambda_{\\max}$ 和 $\\lambda_{\\min}$ 表示 $M^{-1}A$ 的最大和最小特征值。\n\n使用以下参数值测试套件 $(N,m,p)$，其中 $N$ 是内部点数，$m$ 是子域数，$p$ 是细网格点的重叠数：\n1. $(N,m,p)=(120,6,1)$\n2. $(N,m,p)=(240,6,1)$\n3. $(N,m,p)=(480,6,1)$\n4. $(N,m,p)=(96,12,2)$\n\n对每个测试用例，计算 $\\kappa(M^{-1}A)$ 并将结果四舍五入到六位小数。输出不需要物理单位。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，\"[3.142000,3.142000,3.142000,3.142000]\"）。", "solution": "该问题为构建一维泊松方程的两层加性 Schwarz 预条件子并分析其性能提供了一套完整且适定的指令。任务是根据这些指令推导出一个程序化步骤，并为一组给定的参数计算预处理矩阵的谱条件数。该步骤如下。\n\n**步骤 1：有限差分离散化**\n\n在区间 $(0,1)$ 上具有齐次 Dirichlet 边界条件 $u(0)=u(1)=0$ 的一维泊松方程 $-u''(x)=f(x)$ 使用中心差分格式进行离散化。将域 $(0,1)$ 分为 $N+1$ 个等长的子区间，宽度为 $h = 1/(N+1)$。网格点为 $x_k = (k+1)h$，其中 $k=0, 1, \\dots, N-1$。点 $x_k$ 处的二阶导数近似为 $u''(x_k) \\approx \\frac{u(x_{k-1}) - 2u(x_k) + u(x_{k+1})}{h^2}$。将此代入泊松方程，得到线性方程组 $Au = b$，其中 $u \\in \\mathbb{R}^N$ 是未知量 $u_k \\approx u(x_k)$ 的向量，$A$ 是 $N \\times N$ 的刚度矩阵。矩阵 $A$ 是对称、正定且三对角的，其元素由下式给出：\n$$\nA_{ij} = \\frac{1}{h^2} \\begin{cases}\n2,  \\text{if } i=j \\\\\n-1,  \\text{if } |i-j|=1 \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n该矩阵是为给定数量的内部点 $N$ 构建的。\n\n**步骤 2：子域划分与局部算子**\n\n将 $N$ 个全局索引的集合 $\\{0, 1, \\dots, N-1\\}$ 划分为 $m$ 个大小均衡、连续且不重叠的基础子域。设子域 $i$ 的基础索引集为 $I_i^{\\text{base}}$，$i=1, \\dots, m$。然后为每个子域创建一个重叠索引集 $I_i$，方法是在每个方向上将 $I_i^{\\text{base}}$ 扩展 $p$ 个网格点，同时保持在全局索引边界 $[0, N-1]$ 内。\n\n对于每个子域 $i$，定义一个限制算子 $R_i \\in \\mathbb{R}^{n_i \\times N}$，其中 $n_i$ 是重叠集 $I_i$ 中的索引数量。$R_i$ 将全局未知量向量映射到子域 $i$ 的局部向量。在实现中，这对应于选择行和列。每个子域的局部刚度矩阵 $A_i$ 是一个通过 Galerkin 投影 $A_i = R_i A R_i^T$ 获得的小型、稠密且 SPD 的矩阵。这等同于提取 $A$ 中与 $I_i$ 中索引对应的子矩阵。\n\n**步骤 3：粗糙空间构建**\n\n引入一个粗糙空间来处理全局信息传播，这对于预条件子的可扩展性至关重要。该粗糙空间是代数定义的。在 $[0,1]$ 上定义一个粗糙网格，包含 $m+1$ 个点 $x_j^{\\text{coarse}} = jH$，$j=0, 1, \\dots, m$，其中 $H=1/m$。该粗糙空间由 $m-1$ 个分段线性“帽”基函数 $\\{\\phi_j\\}_{j=1}^{m-1}$ 张成。每个函数 $\\phi_j$ 的支撑集在粗糙区间 $[x_{j-1}^{\\text{coarse}}, x_{j+1}^{\\text{coarse}}]$ 上，并满足 $\\phi_j(x_j^{\\text{coarse}})=1$ 以及当 $k \\neq j$ 时 $\\phi_j(x_{k}^{\\text{coarse}})=0$。\n\n粗糙限制算子 $R_0 \\in \\mathbb{R}^{(m-1) \\times N}$ 是通过在细网格点 $x_k = (k+1)h$ 上计算这些基函数的值来组装的。$R_0$ 的元素由 $(R_0)_{j-1, k} = \\phi_j(x_k)$ 给出，$j=1, \\dots, m-1$，$k=0, \\dots, N-1$。具体来说，对于一个细网格点 $x_k$：\n$$\n\\phi_j(x_k) = \\begin{cases}\n(x_k - x_{j-1}^{\\text{coarse}})/H,  \\text{if } x_{j-1}^{\\text{coarse}} \\le x_k \\le x_j^{\\text{coarse}} \\\\\n(x_{j+1}^{\\text{coarse}} - x_k)/H,  \\text{if } x_j^{\\text{coarse}}  x_k \\le x_{j+1}^{\\text{coarse}} \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n然后使用 Galerkin 投影 $A_0 = R_0 A R_0^T$ 形成粗糙矩阵 $A_0 \\in \\mathbb{R}^{(m-1) \\times (m-1)}$。与局部矩阵一样，$A_0$ 也是 SPD 矩阵。\n\n**步骤 4：加性 Schwarz 预条件子组装**\n\n两层加性 Schwarz 预条件子 $M^{-1}$ 是通过将局部子问题和粗糙问题的贡献相加来构建的。其公式为：\n$$\nM^{-1} \\;=\\; \\sum_{i=1}^m R_i^T A_i^{-1} R_i \\;+\\; R_0^T A_0^{-1} R_0\n$$\n每一项 $R_i^T A_i^{-1} R_i$ 表示在局部子域上进行一次求解，然后通过延拓（扩展）回到全局网格。这是一个 $N \\times N$ 矩阵，仅在与索引 $I_i$ 对应的块中非零。项 $R_0^T A_0^{-1} R_0$ 表示粗糙网格校正。在计算上，这涉及对小型矩阵 $A_i$ 和 $A_0$ 求逆，然后通过将所有这些分量矩阵相加来组装完整的 $N \\times N$ 稠密矩阵 $M^{-1}$。\n\n**步骤 5：谱条件数计算**\n\n预条件子的有效性通过预处理矩阵 $M^{-1}A$ 的谱条件数来评估。$M^{-1}A$ 的特征值是实数且为正。条件数定义为最大特征值与最小特征值的比值：\n$$\n\\kappa(M^{-1}A) = \\frac{\\lambda_{\\max}(M^{-1}A)}{\\lambda_{\\min}(M^{-1}A)}\n$$\n较小的条件数（理想情况下接近 1 且与问题规模 $N$ 无关）表示预条件子更有效，能使像共轭梯度法这样的迭代求解器收敛更快。为了计算这个值，我们首先形成稠密矩阵乘积 $P = M^{-1}A$，然后使用数值库找到其特征值，最后计算这些特征值实部的最大值与最小值的比率。", "answer": "```python\nimport numpy as np\n\ndef compute_kappa(N, m, p):\n    \"\"\"\n    Computes the condition number of the two-level additive Schwarz preconditioned system.\n\n    Args:\n        N (int): Number of interior grid points.\n        m (int): Number of subdomains.\n        p (int): Overlap size in grid points.\n\n    Returns:\n        float: The spectral condition number kappa(M^{-1}A).\n    \"\"\"\n    # Step 1: Construct the global stiffness matrix A\n    h = 1.0 / (N + 1)\n    d = np.full(N, 2.0 / h**2)\n    e = np.full(N - 1, -1.0 / h**2)\n    A = np.diag(d) + np.diag(e, k=1) + np.diag(e, k=-1)\n\n    # Initialize the preconditioner M_inv\n    M_inv = np.zeros((N, N))\n\n    # Step 2: Define subdomains and assemble local contributions to M_inv\n    # Partition the N degrees of freedom into m balanced, contiguous subdomains\n    base_indices = np.array_split(np.arange(N), m)\n    \n    for i in range(m):\n        # Create overlapping index set\n        start = base_indices[i][0]\n        end = base_indices[i][-1]\n        \n        # Extend by p points on each side, respecting boundaries\n        overlap_start = max(0, start - p)\n        overlap_end = min(N - 1, end + p)\n        \n        local_indices = np.arange(overlap_start, overlap_end + 1)\n        \n        # Extract local matrix A_i = R_i A R_i^T\n        A_i = A[np.ix_(local_indices, local_indices)]\n        \n        # Compute A_i^{-1}\n        A_i_inv = np.linalg.inv(A_i)\n        \n        # Add local contribution to M_inv: R_i^T A_i^{-1} R_i\n        M_inv[np.ix_(local_indices, local_indices)] += A_i_inv\n\n    # Step 3: Construct the coarse space and its contribution\n    if m > 1:\n        # Define fine and coarse grids\n        fine_grid_x = np.linspace(h, 1.0 - h, N)\n        coarse_grid_x = np.linspace(0, 1.0, m + 1)\n        H = 1.0 / m\n        \n        # Assemble coarse restriction operator R_0\n        num_coarse_basis = m - 1\n        R_0 = np.zeros((num_coarse_basis, N))\n        \n        for j in range(1, m):  # Loop over hat functions phi_j, j=1,...,m-1\n            # Support of phi_j is [x_{j-1}, x_{j+1}]\n            x_j_minus_1 = coarse_grid_x[j-1]\n            x_j = coarse_grid_x[j]\n            x_j_plus_1 = coarse_grid_x[j+1]\n            \n            for k in range(N): # Loop over fine grid points x_k\n                x_k = fine_grid_x[k]\n                if x_j_minus_1 = x_k = x_j:\n                    R_0[j-1, k] = (x_k - x_j_minus_1) / H\n                elif x_j  x_k = x_j_plus_1:\n                    R_0[j-1, k] = (x_j_plus_1 - x_k) / H\n        \n        # Assemble coarse matrix A_0 = R_0 A R_0^T\n        A_0 = R_0 @ A @ R_0.T\n        \n        # Compute A_0^{-1}\n        A_0_inv = np.linalg.inv(A_0)\n        \n        # Add coarse contribution to M_inv: R_0^T A_0^{-1} R_0\n        coarse_contribution = R_0.T @ A_0_inv @ R_0\n        M_inv += coarse_contribution\n\n    # Step 4: Compute the preconditioned matrix and its eigenvalues\n    preconditioned_matrix = M_inv @ A\n    eigenvalues = np.linalg.eigvals(preconditioned_matrix)\n    \n    # Eigenvalues should be real and positive; take real part to handle numerical noise\n    real_eigenvalues = eigenvalues.real\n    \n    # Step 5: Compute the condition number\n    lambda_max = np.max(real_eigenvalues)\n    lambda_min = np.min(real_eigenvalues)\n    \n    kappa = lambda_max / lambda_min\n    return kappa\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        (120, 6, 1),\n        (240, 6, 1),\n        (480, 6, 1),\n        (96, 12, 2)\n    ]\n\n    results = []\n    for N, m, p in test_cases:\n        kappa = compute_kappa(N, m, p)\n        # Round the result to six decimal places\n        results.append(f\"{kappa:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3382437"}, {"introduction": "除了重叠型Schwarz方法，另一大类高效的区域分解技术是子结构方法，其中以BDDC（约束平衡区域分解）为代表。这类方法在不重叠的子区域上操作，并通过约束来保证界面上的连续性。本练习通过一个简化的模型，揭示了BDDC方法构造其粗空间的核心思想。你将学习如何通过选择原始约束（例如角点自由度）来定义局部粗基函数，并组装全局粗矩阵，这是保证BDDC方法可扩展性的关键所在。[@problem_id:3382497]", "problem": "考虑单位正方形区域 $\\Omega = [0,1] \\times [0,1]$ 上的标量泊松问题 $-\\Delta u = f$，边界 $\\partial \\Omega$ 上具有齐次狄利克雷边界条件 $u=0$。用直线 $x = \\frac{1}{2}$ 和 $y = \\frac{1}{2}$ 将 $\\Omega$ 剖分为 $2 \\times 2$ 个相等的正方形子区域。假设在每个子区域上采用一个简化离散模型，其中唯一的自由度是四个子区域的角点值，局部能量定义为沿子区域边界用单位刚度边连接这四个角点（即一个长度为4、权重为单位1的循环图）。在此简化模型中，按照（西南、东南、东北、西北）的角点节点排序，局部子区域刚度矩阵 $K^{(s)} \\in \\mathbb{R}^{4 \\times 4}$ 为\n$$\nK^{(s)} \\;=\\;\n\\begin{pmatrix}\n2  -1  0  -1 \\\\\n-1  2  -1  0 \\\\\n0  -1  2  -1 \\\\\n-1  0  -1  2\n\\end{pmatrix},\n$$\n这对应于子区域边界自由度上的离散狄利克雷能量 $\\frac{1}{2} u^{\\top} K^{(s)} u$。\n\n采用约束平衡区域分解（BDDC）方法，并选择角点约束，使得原始粗网格自由度恰好是子结构剖分的唯一角点。由于 $\\partial \\Omega$ 上的齐次狄利克雷边界条件，唯一的非零原始粗网格自由度是位于几何中心 $(\\frac{1}{2}, \\frac{1}{2})$ 的内部子区域顶点，该顶点为所有四个子区域所共享。\n\n在每个子区域上，与中心角点关联的BDDC局部粗网格基函数被定义为离散调和延拓，它在中心角点处值为 $1$、在其他三个子区域角点处值为 $0$ 的约束条件下，最小化局部狄利克雷能量。使用上述简化离散模型，此基函数就是在局部角点节点排序中，中心角点索引位置上的单位向量。\n\n使用这些定义：\n- 为 $(\\frac{1}{2}, \\frac{1}{2})$ 处的单个粗网格自由度，在四个子区域上分别构建局部粗网格基函数。\n- 通过对与该粗网格自由度相关的局部贡献求和，组装全局BDDC粗网格矩阵 $A_{c} \\in \\mathbb{R}^{1 \\times 1}$。\n- 对于标量粗网格右端项 $r_{c} = 5$，通过应用BDDC粗网格预条件子计算标量预处理残差值，即计算 $z_{c} = A_{c}^{-1} r_{c}$。\n\n将最终答案表示为一个精确数。无需四舍五入。", "solution": "约束平衡区域分解（BDDC）中的粗网格矩阵是由粗网格基函数的局部能量贡献组装而成的。该问题定义了一个简化设定，其中只有一个原始粗网格自由度（DoF），并为子区域物理模型提供了一个简化模型。\n\n单位正方形区域 $\\Omega = [0,1] \\times [0,1]$ 被剖分为四个相等的正方形子区域，我们标记如下：\n- $\\Omega^{(1)}$: 西南, $[0, \\frac{1}{2}] \\times [0, \\frac{1}{2}]$\n- $\\Omega^{(2)}$: 东南, $[\\frac{1}{2}, 1] \\times [0, \\frac{1}{2}]$\n- $\\Omega^{(3)}$: 东北, $[\\frac{1}{2}, 1] \\times [\\frac{1}{2}, 1]$\n- $\\Omega^{(4)}$: 西北, $[0, \\frac{1}{2}] \\times [\\frac{1}{2}, 1]$\n\n单个原始粗网格自由度对应于唯一的内部顶点 $v_c = (\\frac{1}{2}, \\frac{1}{2})$，该顶点为所有四个子区域共享。边界 $\\partial \\Omega$ 上的所有其他角点根据齐次狄利克雷条件被固定为0，并且不是粗网格自由度。\n\n对于每个子区域，局部自由度是四个角点的值，按（西南、东南、东北、西北）的顺序排列。局部刚度矩阵如下所示：\n$$\nK^{(s)} = K =\n\\begin{pmatrix}\n2  -1  0  -1 \\\\\n-1  2  -1  0 \\\\\n0  -1  2  -1 \\\\\n-1  0  -1  2\n\\end{pmatrix}\n$$\n问题陈述，对于粗网格顶点 $v_c$ 的局部粗网格基函数是一个向量，其在对应于 $v_c$ 的索引处值为1，在其他三个角点索引处值为0。让我们用 $\\Psi_c^{(s)} \\in \\mathbb{R}^4$ 表示子区域 $\\Omega^{(s)}$ 上的局部粗网格基函数。我们必须确定每个子区域中 $v_c$ 的局部索引。\n\n1.  对于 $\\Omega^{(1)}$ (西南)：角点为 $(0,0)$、$(\\frac{1}{2},0)$、$(\\frac{1}{2}, \\frac{1}{2})$、$(0,\\frac{1}{2})$。在指定的（西南、东南、东北、西北）排序中，$v_c = (\\frac{1}{2}, \\frac{1}{2})$ 是东北角，即第3个索引。\n    因此，$\\Psi_c^{(1)} = \\begin{pmatrix} 0  0  1  0 \\end{pmatrix}^T$。\n\n2.  对于 $\\Omega^{(2)}$ (东南)：角点为 $(\\frac{1}{2},0)$、$(1,0)$、$(1,\\frac{1}{2})$、$(\\frac{1}{2},\\frac{1}{2})$。$v_c$ 是西北角，即第4个索引。\n    因此，$\\Psi_c^{(2)} = \\begin{pmatrix} 0  0  0  1 \\end{pmatrix}^T$。\n\n3.  对于 $\\Omega^{(3)}$ (东北)：角点为 $(\\frac{1}{2},\\frac{1}{2})$、$(1,\\frac{1}{2})$、$(1,1)$、$(\\frac{1}{2},1)$。$v_c$ 是西南角，即第1个索引。\n    因此，$\\Psi_c^{(3)} = \\begin{pmatrix} 1  0  0  0 \\end{pmatrix}^T$。\n\n4.  对于 $\\Omega^{(4)}$ (西北)：角点为 $(0,\\frac{1}{2})$、$(\\frac{1}{2},\\frac{1}{2})$、$(\\frac{1}{2},1)$、$(0,1)$。$v_c$ 是东南角，即第2个索引。\n    因此，$\\Psi_c^{(4)} = \\begin{pmatrix} 0  1  0  0 \\end{pmatrix}^T$。\n\n全局BDDC粗网格矩阵 $A_c$ 是通过对所有子区域上的局部粗网格基函数的能量求和来组装的。由于只有一个粗网格自由度，$A_c$ 是一个 $1 \\times 1$ 矩阵（一个标量）。其值由下式给出：\n$$\nA_c = \\sum_{s=1}^{4} \\left(\\Psi_c^{(s)}\\right)^T K^{(s)} \\Psi_c^{(s)}\n$$\n每一项 $\\left(\\Psi_c^{(s)}\\right)^T K^{(s)} \\Psi_c^{(s)}$ 是一个二次型，它从矩阵 $K$ 中提取一个对角线元素。具体来说，如果 $\\Psi_c^{(s)}$ 是第 $k$ 个标准基向量 $e_k$，那么乘积就是对角线元素 $K_{kk}$。\n\n-   来自 $\\Omega^{(1)}$ 的贡献：$\\left(\\Psi_c^{(1)}\\right)^T K \\Psi_c^{(1)} = K_{33} = 2$。\n-   来自 $\\Omega^{(2)}$ 的贡献：$\\left(\\Psi_c^{(2)}\\right)^T K \\Psi_c^{(2)} = K_{44} = 2$。\n-   来自 $\\Omega^{(3)}$ 的贡献：$\\left(\\Psi_c^{(3)}\\right)^T K \\Psi_c^{(3)} = K_{11} = 2$。\n-   来自 $\\Omega^{(4)}$ 的贡献：$\\left(\\Psi_c^{(4)}\\right)^T K \\Psi_c^{(4)} = K_{22} = 2$。\n\n粗网格矩阵 $A_c$ 是这些贡献的总和：\n$$\nA_c = 2 + 2 + 2 + 2 = 8\n$$\n问题要求计算预处理残差 $z_c = A_c^{-1} r_c$，给定粗网格右端项 $r_c = 5$。由于 $A_c$ 是一个标量，其逆就是 $A_c^{-1} = \\frac{1}{8}$。\n因此，预处理残差为：\n$$\nz_c = A_c^{-1} r_c = \\frac{1}{8} \\times 5 = \\frac{5}{8}\n$$\n最终结果是一个精确数，符合要求。", "answer": "$$\n\\boxed{\\frac{5}{8}}\n$$", "id": "3382497"}]}