{"hands_on_practices": [{"introduction": "任何Newmark方法的实际应用，第一步都是将其定义方程重组为一个可解的线性系统。这个基础练习将引导你完成必要的代数步骤，以推导出“有效系统”，它将下一时间步的未知加速度 $\\ddot{q}_{n+1}$ 表示为一个标准矩阵方程的解。掌握这一推导过程对于理解积分器如何在结构动力学计算软件中应用至关重要。[@problem_id:3424180]", "problem": "考虑一个线性弹性动力学偏微分方程 (PDE) 经过空间离散化后得到的半离散形式，它产生了一个二阶常微分方程 (ODE)\n$$\nM \\ddot{q}(t) + C \\dot{q}(t) + K q(t) = f(t),\n$$\n其中 $M$、$C$ 和 $K$ 分别是质量、阻尼和刚度矩阵，$q(t)$ 是广义位移向量。假设 $M$ 是对称正定的，$C$ 是对称半正定的，$K$ 是对称半正定的，并且 $f(t)$ 是足够光滑的。设时间网格为 $t_{n} = t_{0} + n\\,\\Delta t$，时间步长 $\\Delta t > 0$。Newmark 时间积分方法族通过参数 $\\beta$ 和 $\\gamma$ 定义了如下的更新关系\n$$\nq_{n+1} = q_{n} + \\Delta t\\,\\dot{q}_{n} + \\Delta t^{2}\\left(\\tfrac{1}{2} - \\beta\\right)\\ddot{q}_{n} + \\Delta t^{2}\\beta\\,\\ddot{q}_{n+1},\n$$\n$$\n\\dot{q}_{n+1} = \\dot{q}_{n} + \\Delta t\\,(1 - \\gamma)\\,\\ddot{q}_{n} + \\Delta t\\,\\gamma\\,\\ddot{q}_{n+1}.\n$$\n在时间 $t_{n+1}$，半离散平衡方程为\n$$\nM \\ddot{q}_{n+1} + C \\dot{q}_{n+1} + K q_{n+1} = f_{n+1},\n$$\n其中 $f_{n+1} := f(t_{n+1})$。从上述基本关系出发，不假设任何额外的简化公式，推导关于未知加速度 $\\ddot{q}_{n+1}$ 的等效线性系统，其形式为\n$$\nM_{\\text{eff}}\\,\\ddot{q}_{n+1} = f_{\\text{eff}},\n$$\n并明确指出等效质量 $M_{\\text{eff}}$、与 Newmark 参数 $\\gamma$ 和时间步长 $\\Delta t$ 相关的等效阻尼贡献，以及等效右端项 $f_{\\text{eff}}$。这些量需要用 $\\beta$、$\\gamma$ 和 $\\Delta t$ 以及已知量 $q_{n}$、$\\dot{q}_{n}$、$\\ddot{q}_{n}$ 和 $f_{n+1}$ 来表示。以闭合形式给出这些表达式。您的最终答案必须是以解析表达式表示的计算结果。不需要进行四舍五入，也不应代入任何数值。使用 LaTeX 的 $pmatrix$ 环境将这三个所求的表达式呈现在单行中。", "solution": "该问题是有效的，因为它基于计算力学的科学原理，是适定、客观且自洽的。任务是为 Newmark 时间积分方法族推导等效线性系统。\n\n推导的起点包括三个基本方程。首先，是在时间 $t_{n+1}$ 处计算的半离散运动方程：\n$$\nM \\ddot{q}_{n+1} + C \\dot{q}_{n+1} + K q_{n+1} = f_{n+1}\n$$\n第二和第三，是 Newmark 的位移和速度更新法则，它们将时间 $t_{n+1}$ 的状态与时间 $t_n$ 的已知状态以及未知的加速度 $\\ddot{q}_{n+1}$ 联系起来：\n$$\nq_{n+1} = q_{n} + \\Delta t\\,\\dot{q}_{n} + \\Delta t^{2}\\left(\\frac{1}{2} - \\beta\\right)\\ddot{q}_{n} + \\Delta t^{2}\\beta\\,\\ddot{q}_{n+1}\n$$\n$$\n\\dot{q}_{n+1} = \\dot{q}_{n} + \\Delta t\\,(1 - \\gamma)\\,\\ddot{q}_{n} + \\Delta t\\,\\gamma\\,\\ddot{q}_{n+1}\n$$\n这里，$q_n, \\dot{q}_n, \\ddot{q}_n$ 是时间 $t_n$ 的已知位移、速度和加速度向量，而 $q_{n+1}, \\dot{q}_{n+1}, \\ddot{q}_{n+1}$ 是时间 $t_{n+1}$ 的对应向量。参数 $\\beta$ 和 $\\gamma$ 定义了 Newmark 方法族中的具体方法。目标是得到一个形如 $M_{\\text{eff}}\\,\\ddot{q}_{n+1} = f_{\\text{eff}}$ 的方程，该方程只涉及未知量 $\\ddot{q}_{n+1}$ 和已知量。\n\n为此，我们将 Newmark 更新法则代入时间 $t_{n+1}$ 的运动方程中。我们可以将依赖于未知量 $\\ddot{q}_{n+1}$ 的项与从前一个时间步已明确知道的项分离开。让我们将更新法则重写为：\n$$\nq_{n+1} = \\tilde{q}_{n+1} + \\Delta t^{2}\\beta\\,\\ddot{q}_{n+1}\n$$\n$$\n\\dot{q}_{n+1} = \\tilde{\\dot{q}}_{n+1} + \\Delta t\\,\\gamma\\,\\ddot{q}_{n+1}\n$$\n其中 $\\tilde{q}_{n+1}$ 和 $\\tilde{\\dot{q}}_{n+1}$ 是仅依赖于 $t_n$ 时刻状态的预测量：\n$$\n\\tilde{q}_{n+1} := q_{n} + \\Delta t\\,\\dot{q}_{n} + \\Delta t^{2}\\left(\\frac{1}{2} - \\beta\\right)\\ddot{q}_{n}\n$$\n$$\n\\tilde{\\dot{q}}_{n+1} := \\dot{q}_{n} + \\Delta t\\,(1 - \\gamma)\\,\\ddot{q}_{n}\n$$\n现在，将 $q_{n+1}$ 和 $\\dot{q}_{n+1}$ 的表达式代入运动方程：\n$$\nM \\ddot{q}_{n+1} + C \\left( \\tilde{\\dot{q}}_{n+1} + \\Delta t\\,\\gamma\\,\\ddot{q}_{n+1} \\right) + K \\left( \\tilde{q}_{n+1} + \\Delta t^{2}\\beta\\,\\ddot{q}_{n+1} \\right) = f_{n+1}\n$$\n将矩阵 $C$ 和 $K$ 分配进去：\n$$\nM \\ddot{q}_{n+1} + C \\tilde{\\dot{q}}_{n+1} + \\Delta t\\,\\gamma\\,C \\ddot{q}_{n+1} + K \\tilde{q}_{n+1} + \\Delta t^{2}\\beta\\,K \\ddot{q}_{n+1} = f_{n+1}\n$$\n接下来，我们重排这个方程，将所有包含未知向量 $\\ddot{q}_{n+1}$ 的项收集到左侧，并将所有其他已知项移到右侧。\n$$\nM \\ddot{q}_{n+1} + \\Delta t\\,\\gamma\\,C \\ddot{q}_{n+1} + \\Delta t^{2}\\beta\\,K \\ddot{q}_{n+1} = f_{n+1} - C \\tilde{\\dot{q}}_{n+1} - K \\tilde{q}_{n+1}\n$$\n在左侧提出公因子 $\\ddot{q}_{n+1}$，得到：\n$$\n\\left( M + \\gamma \\Delta t C + \\beta \\Delta t^{2} K \\right) \\ddot{q}_{n+1} = f_{n+1} - C \\tilde{\\dot{q}}_{n+1} - K \\tilde{q}_{n+1}\n$$\n这个方程就是我们所期望的形式 $M_{\\text{eff}}\\,\\ddot{q}_{n+1} = f_{\\text{eff}}$。由此，我们可以明确地识别出所求的表达式。\n\n等效质量矩阵 $M_{\\text{eff}}$ 是 $\\ddot{q}_{n+1}$ 的矩阵系数：\n$$\nM_{\\text{eff}} = M + \\gamma \\Delta t C + \\beta \\Delta t^{2} K\n$$\n问题特别要求“与 Newmark 参数 $\\gamma$ 和时间步长 $\\Delta t$ 相关的等效阻尼贡献”。这对应于 $M_{\\text{eff}}$ 中包含阻尼矩阵 $C$ 和参数 $\\gamma$ 的项。该项是：\n$$\n\\gamma \\Delta t C\n$$\n等效右端项 $f_{\\text{eff}}$ 是重排后方程的整个右侧。将预测量 $\\tilde{q}_{n+1}$ 和 $\\tilde{\\dot{q}}_{n+1}$ 的完整表达式代回：\n$$\nf_{\\text{eff}} = f_{n+1} - C \\left( \\dot{q}_{n} + \\Delta t\\,(1 - \\gamma)\\,\\ddot{q}_{n} \\right) - K \\left( q_{n} + \\Delta t\\,\\dot{q}_{n} + \\Delta t^{2}\\left(\\frac{1}{2} - \\beta\\right)\\ddot{q}_{n} \\right)\n$$\n这三个表达式就是所求的结果，它们是直接从 Newmark 方法的基本关系推导出来的。", "answer": "$$\n\\boxed{\\begin{pmatrix} M + \\gamma \\Delta t C + \\beta \\Delta t^{2} K  \\gamma \\Delta t C  f_{n+1} - C \\left( \\dot{q}_{n} + (1 - \\gamma) \\Delta t \\ddot{q}_{n} \\right) - K \\left( q_{n} + \\Delta t \\dot{q}_{n} + \\left(\\frac{1}{2} - \\beta\\right) \\Delta t^{2} \\ddot{q}_{n} \\right) \\end{pmatrix}}\n$$", "id": "3424180"}, {"introduction": "数值积分器可能会引入人为的能量耗散或增长，从而影响长期模拟的物理真实性。本练习提出了一个逆向问题：我们能否设计一个Newmark积分器，使其遵循一个特定的、预定义的能量耗散定律？通过这个思想实验，你将揭示Newmark族方法在能量守恒方面的一个深层原理，并理解为何参数选择 $(\\gamma, \\beta) = (1/2, 1/4)$ 对无阻尼线性系统如此特殊。[@problem_id:3424131]", "problem": "考虑无阻尼线性弹性动力学偏微分方程 (PDE) 经过空间离散化后得到的半离散形式，$M \\ddot{u}(t) + K u(t) = 0$，其中 $M \\in \\mathbb{R}^{n \\times n}$ 和 $K \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵，$u(t) \\in \\mathbb{R}^{n}$ 是位移向量，$\\ddot{u}(t)$ 表示对时间的二阶导数。将速度记为 $v(t) = \\dot{u}(t)$。设在时间步 $n$ 的离散能量为 $E_n = \\tfrac{1}{2} v_n^{\\top} M v_n + \\tfrac{1}{2} u_n^{\\top} K u_n$，$M$-范数由 $\\|v\\|_{M}^{2} = v^{\\top} M v$ 定义。假设时间积分采用 Newmark 方法族，其参数为 $(\\gamma, \\beta)$，时间步长为均匀的 $\\Delta t > 0$。\n\n关注与 $(K, M)$ 的一个广义特征对相关联的一个不变模态子空间，使得动力学简化为单自由度系统 $m \\ddot{q}(t) + k q(t) = 0$，其中 $m > 0$，$k > 0$，速度为 $v(t) = \\dot{q}(t)$，角频率为 $\\omega^{2} = k/m$。在此子空间中，设 $E_n = \\tfrac{1}{2} m v_n^{2} + \\tfrac{1}{2} k q_n^{2}$。\n\n从上述基本定律和定义出发，推导由 Newmark 更新所隐含的离散能量增量 $E_{n+1} - E_n$，并提出以下逆向设计问题：对于所选模态子空间中的所有初始状态，以及在一个包含 $\\Delta t = 0$ 的非空区间内的所有时间步长 $\\Delta t$，强制执行一个目标步进能量定律 $E_{n+1} - E_n = - \\eta \\|v_{n+1}\\|_{M}^{2}$。判断是否存在参数 $(\\gamma, \\beta)$ 和一个常数 $\\eta$（独立于状态和 $\\Delta t$）可以实现该定律。如果可以实现，计算能够达到的唯一标量 $\\eta$；如果唯一可能的实现强制要求一个特定的 $\\eta$，则报告该值。将最终答案表示为一个无单位的实数，无需四舍五入。", "solution": "用户希望确定是否存在一组用于 Newmark 时间积分方法族的参数 $(\\gamma, \\beta)$ 和一个常数 $\\eta$，使得对于一个线性无阻尼单自由度 (SDOF) 振子，一个特定的能量耗散定律得以满足。\n\n### 步骤 1：问题验证\n\n问题陈述已经过验证，被认为是具有科学依据、良定、客观且自洽的。它涉及偏微分方程数值分析中的一个标准课题（特别是半离散系统的时间积分），并使用了已确立的定义和形式体系。未发现任何缺陷。该问题有效，可以求解。\n\n### 步骤 2：形式推导\n\n分析是在由模态分解得到的单自由度 (SDOF) 系统上进行的。运动方程为：\n$$m \\ddot{q}(t) + k q(t) = 0$$\n其中 $m > 0$，$k > 0$，自然角频率为 $\\omega = \\sqrt{k/m}$。我们将时间步 $t_n$ 的状态记为 $(q_n, v_n)$，其中 $v_n = \\dot{q}(t_n)$。加速度为 $a_n = \\ddot{q}(t_n) = - (k/m) q_n = -\\omega^2 q_n$。\n\nNewmark 方法族为位移 $q$ 和速度 $v$ 在一个时间步长 $\\Delta t$ 内提供了以下更新规则：\n$$q_{n+1} = q_n + \\Delta t v_n + \\Delta t^2 \\left[ \\left(\\frac{1}{2} - \\beta\\right) a_n + \\beta a_{n+1} \\right] \\quad (1)$$\n$$v_{n+1} = v_n + \\Delta t \\left[ (1 - \\gamma) a_n + \\gamma a_{n+1} \\right] \\quad (2)$$\n运动方程在时间步 $t_{n+1}$ 也必须成立，因此 $a_{n+1} = -\\omega^2 q_{n+1}$。\n\n在时间步 $n$ 的离散能量由 $E_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k q_n^2$ 给出。问题假设了一个目标步进能量定律：\n$$E_{n+1} - E_n = - \\eta \\|v_{n+1}\\|_{M}^{2}$$\n对于单自由度系统，质量矩阵 $M$ 对应于标量质量 $m$，因此 $\\|v_{n+1}\\|_{M}^{2} = m v_{n+1}^2$。目标定律变为：\n$$E_{n+1} - E_n = - \\eta m v_{n+1}^2$$\n代入能量的定义，我们有：\n$$\\left(\\frac{1}{2} m v_{n+1}^2 + \\frac{1}{2} k q_{n+1}^2\\right) - \\left(\\frac{1}{2} m v_n^2 + \\frac{1}{2} k q_n^2\\right) = - \\eta m v_{n+1}^2$$\n这个方程可以被重新整理，以定义一个在每一步都应守恒的修正的类能量：\n$$\\left(\\frac{1}{2} + \\eta\\right) m v_{n+1}^2 + \\frac{1}{2} k q_{n+1}^2 = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k q_n^2 \\quad (3)$$\n对于所有初始状态 $(q_n, v_n)$ 和在一个包含 $\\Delta t = 0$ 的非空区间内的所有时间步长 $\\Delta t$，该关系必须成立。\n\n为了分析方程 $(3)$，我们首先将 $q_{n+1}$ 和 $v_{n+1}$ 表示为 $q_n$ 和 $v_n$ 的函数。\n将 $a_n = -\\omega^2 q_n$ 和 $a_{n+1} = -\\omega^2 q_{n+1}$ 代入方程 $(1)$ 和 $(2)$。令 $\\Omega = \\omega \\Delta t$。\n由 $(1)$ 得：\n$q_{n+1} = q_n + \\Delta t v_n + \\Delta t^2 \\left[ -\\left(\\frac{1}{2} - \\beta\\right) \\omega^2 q_n - \\beta \\omega^2 q_{n+1} \\right]$\n$q_{n+1} (1 + \\beta \\Omega^2) = q_n (1 - (\\frac{1}{2} - \\beta) \\Omega^2) + v_n \\Delta t$\n$$q_{n+1} = \\frac{1}{1 + \\beta \\Omega^2} \\left[ \\left(1 - \\left(\\frac{1}{2} - \\beta\\right) \\Omega^2\\right) q_n + \\Delta t v_n \\right] \\quad (4)$$\n由 $(2)$ 得：\n$v_{n+1} = v_n + \\Delta t \\left[ -(1-\\gamma)\\omega^2 q_n - \\gamma \\omega^2 q_{n+1} \\right]$\n$$v_{n+1} = v_n - \\frac{\\Omega^2}{\\Delta t} \\left( (1-\\gamma)q_n + \\gamma q_{n+1} \\right) \\quad (5)$$\n\n将方程 $(4)$ 和 $(5)$ 代入目标定律 $(3)$，得到一个关于 $q_n$ 和 $v_n$ 的二次型，该二次型必须是一个恒等式。\n$A q_n^2 + B v_n^2 + C q_n v_n = \\frac{1}{2} k q_n^2 + \\frac{1}{2} m v_n^2$\n要使此式对所有 $q_n, v_n$ 成立，等式两边 $q_n^2$、$v_n^2$ 和 $q_n v_n$ 的系数必须相等。特别是，交叉项 $q_n v_n$ 的系数必须为零。让我们分析这个特定约束。\n$(3)$ 式的左边会产生一个交叉项：\n$$(1+2\\eta) m v_{n+1} v_{n+1} \\text{'s cross-term} + k q_{n+1} q_{n+1} \\text{'s cross-term} = 0$$\n其中我们只考虑乘积中对 $q_n v_n$ 项有贡献的部分。\n令 $q_{n+1} = D_q q_n + D_v v_n$ 且 $v_{n+1} = C_q q_n + C_v v_n$。交叉项系数方程为：\n$$(1+2\\eta) m (2 C_q C_v) + k (2 D_q D_v) = 0 \\implies (1+2\\eta) m C_q C_v + k D_q D_v = 0 \\quad (6)$$\n从 $(4)$ 式，我们确定：\n$D_q = \\frac{1 - (\\frac{1}{2} - \\beta) \\Omega^2}{1 + \\beta \\Omega^2}$\n$D_v = \\frac{\\Delta t}{1 + \\beta \\Omega^2}$\n将 $(4)$ 式代入 $(5)$ 式并合并同类项后，我们得到：\n$C_v = \\frac{1 + (\\beta - \\gamma) \\Omega^2}{1 + \\beta \\Omega^2}$\n$C_q = -\\frac{\\Omega^2}{\\Delta t} \\frac{1 + (\\beta - \\frac{\\gamma}{2})\\Omega^2}{1 + \\beta \\Omega^2} = -\\frac{k}{m} \\frac{\\Delta t (1 + (\\beta - \\frac{\\gamma}{2})\\Omega^2)}{1 + \\beta \\Omega^2}$\n\n将这些代入方程 $(6)$：\n$$ (1+2\\eta) m \\left(-\\frac{k}{m} \\frac{\\Delta t (1 + (\\beta - \\frac{\\gamma}{2})\\Omega^2)}{1 + \\beta \\Omega^2}\\right) \\left(\\frac{1 + (\\beta - \\gamma) \\Omega^2}{1 + \\beta \\Omega^2}\\right) + k \\left(\\frac{1 - (\\frac{1}{2} - \\beta) \\Omega^2}{1 + \\beta \\Omega^2}\\right) \\left(\\frac{\\Delta t}{1 + \\beta \\Omega^2}\\right) = 0 $$\n我们可以两边同除以 $k \\Delta t$ 并乘以 $(1 + \\beta \\Omega^2)^2$，假设 $\\Delta t \\neq 0$：\n$$ -(1+2\\eta) \\left(1 + \\left(\\beta - \\frac{\\gamma}{2}\\right)\\Omega^2\\right) \\left(1 + (\\beta - \\gamma) \\Omega^2\\right) + \\left(1 - \\left(\\frac{1}{2} - \\beta\\right) \\Omega^2\\right) = 0 \\quad (7)$$\n这个方程是一个关于 $\\Omega^2$ 的多项式，并且必须在 0 的一个邻域内对所有 $\\Omega$ 成立。根据连续性，它必须对 $\\Omega = 0$（即 $\\Delta t = 0$）成立。在方程 $(7)$ 中令 $\\Omega=0$：\n$$ -(1+2\\eta) (1)(1) + (1) = 0 $$\n$$ -(1+2\\eta) + 1 = 0 $$\n$$ -2\\eta = 0 $$\n这意味着 $\\eta = 0$。\n\n该定律必须在包含 $\\Delta t = 0$ 的一个区间内对所有 $\\Delta t$ 成立，这是一个强有力的约束。在极限点 $\\Delta t = 0$ 处的求值强制 $\\eta$ 为零。因此，如果在给定条件下可以实现所提出的能量定律，则常数 $\\eta$ 必须唯一地为 $0$。\n\n为了完整性，可以验证存在一个 $(\\gamma, \\beta)$ 的选择。如果我们在方程 $(7)$ 中设置 $\\eta=0$，它就变成一个关于 $\\Omega^2$ 的多项式，该多项式必须恒等于零。这意味着它的所有系数都必须为零。展开多项式可以得到关于 $\\gamma$ 和 $\\beta$ 的条件。满足所有系数方程的唯一解是 $(\\gamma, \\beta) = (1/2, 1/4)$，这对应于平均加速度法。已知该方法对于线性系统是能量守恒的，即 $E_{n+1} - E_n = 0$。这与我们的目标定律 $E_{n+1} - E_n = -\\eta m v_{n+1}^2$ 一致，当且仅当 $\\eta = 0$（对于 $v_{n+1} \\neq 0$ 的非平凡运动）。\n\n因此，一种实现是可能的，且 $\\eta$ 的唯一值为 $0$。", "answer": "$$\\boxed{0}$$", "id": "3424131"}, {"introduction": "尽管线性系统为分析数值方法提供了一个清晰的背景，但许多现实世界中的物理现象本质上是是非线性的。这个综合性练习将挑战你将Newmark方法应用于非线性Klein-Gordon方程——一个用于描述相对论性粒子的模型。你不仅需要实现该积分器，还将探索数值模拟的一个关键方面：在非线性系统中，守恒量（如能量）的长期漂移现象，以及如何设计校正措施来恢复物理守恒行为。[@problem_id:3424207]", "problem": "考虑在一维空间上、长度为 $2\\pi$ 的区间内、具有周期性边界条件的非线性克莱因-戈登方程：\n$$\nu_{tt} - c^2 u_{xx} + \\lambda u^3 = 0,\n$$\n该方程可以写成一个二阶哈密顿系统，其哈密顿量（总能量）为\n$$\n\\mathcal{E}(u,v) = \\int_0^{2\\pi} \\left( \\tfrac{1}{2} v^2 + \\tfrac{c^2}{2} u_x^2 + \\tfrac{\\lambda}{4} u^4 \\right)\\,dx,\n$$\n其中 $v = u_t$。在使用快速傅里叶变换（FFT）进行谱精度空间离散化后，该偏微分方程简化为以下形式的常微分方程组：\n$$\n\\mathbf{u}'' + \\mathbf{L}\\,\\mathbf{u} + \\lambda\\,\\mathbf{u}^{\\circ 3} = \\mathbf{0},\n$$\n其中 $\\mathbf{u}$ 汇集了空间网格点上的值，$\\mathbf{L}$ 是在 FFT 表示下对应于 $-c^2\\partial_{xx}$ 的离散、对称、半正定算子，而 $\\mathbf{u}^{\\circ 3}$ 表示按元素进行的三次非线性运算。\n\n对于二阶系统，Newmark 方法族由参数 $(\\gamma,\\beta)$ 定义，其更新 $(\\mathbf{u}_{n+1},\\mathbf{v}_{n+1})$ 的方式如下：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t\\,\\mathbf{v}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\mathbf{a}_n + \\beta \\Delta t^2 \\mathbf{a}_{n+1},\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t \\left((1-\\gamma)\\mathbf{a}_n + \\gamma \\mathbf{a}_{n+1}\\right),\n$$\n其中 $\\mathbf{a}_n$ 是由运动方程定义的加速度，$\\mathbf{a}_n = -\\mathbf{L}\\,\\mathbf{u}_n - \\lambda\\,\\mathbf{u}_n^{\\circ 3}$。对于一般的 $(\\gamma,\\beta)$，该方法是隐式的，因为 $\\mathbf{a}_{n+1}$ 依赖于 $\\mathbf{u}_{n+1}$，这导致在每一步都需要求解一个非线性系统。\n\n您的任务如下，从哈密顿结构和半离散系统出发：\n- 针对半离散系统，为一般的 $(\\gamma,\\beta)$ 推导 Newmark 更新方程，并强调 $\\mathbf{L}$ 和非线性项如何进入隐式步骤。\n- 设计一种谱精度且计算高效的方法，使用快速傅里叶变换（FFT）来计算 $\\mathbf{L}\\,\\mathbf{u}$ 和 $\\int u_x^2\\,dx$，以确保离散能量的计算与空间离散化保持一致。\n- 在弱非线性情况下（$\\lambda$ 较小），分析在固定时间步长和最终时间下，由最大相对能量误差衡量的长期能量漂移：\n$$\n\\max_{0 \\leq n \\leq N}\\frac{\\left|\\mathcal{E}(\\mathbf{u}_n,\\mathbf{v}_n)-\\mathcal{E}(\\mathbf{u}_0,\\mathbf{v}_0)\\right|}{\\mathcal{E}(\\mathbf{u}_0,\\mathbf{v}_0)},\n$$\n从第一性原理出发，解释为什么不同的 $(\\gamma,\\beta)$ 选择会在非线性情况下导致性质上不同的长期行为。\n- 提出并实现一个最小化的修正，以在弱非线性情况下恢复哈密顿量的近似守恒，而不显著改变核心的 Newmark 步骤。该修正必须从哈密顿观点进行论证。一种可行的方法是能量投影，即在每一步重新缩放速度以匹配初始能量，同时保持新的位移不变。\n\n实现以下程序要求：\n- 使用长度为 $2\\pi$ 的一维周期性域，包含 $N=64$ 个等距点，波速 $c=1$，初始条件为 $u(x,0) = A\\sin(x)$，$v(x,0)=0$，其中 $A = 0.1$。所有积分为无量纲，无需进行物理单位转换。\n- 使用 FFT 计算与 $-c^2\\partial_{xx}$ 对应的算子 $\\mathbf{L}$ 以及能量计算所需的导数 $u_x$。\n- 对于隐式 Newmark 情况（所有 $\\beta > 0$ 的情况），在每一步中通过不动点迭代求解非线性系统，其中线性算子被隐式处理，而三次非线性项则使用前一次迭代的值进行滞后处理。具体来说，在每个时间步求解：\n$$\n\\left(\\mathbf{I} + \\alpha \\mathbf{L}\\right)\\mathbf{u}_{n+1} = \\mathbf{r} - \\alpha \\lambda\\,\\mathbf{u}_{n+1}^{\\circ 3},\n$$\n其中 $\\alpha = \\beta\\Delta t^2$，$\\mathbf{r}$ 是由 Newmark 预测子构造的已知右端项。求解时，对右端项的三次项使用最新迭代值进行迭代，并使用逐模式的谱反演处理左端项。\n- 实现所提议的修正：在每一步结束时进行能量投影，将 $\\mathbf{v}_{n+1}$ 重新缩放为 $s\\,\\mathbf{v}_{n+1}$，其中标量 $s$ 的选择需满足离散能量等于初始能量。如果所需的动能变为非正值或速度为零，则保持 $\\mathbf{v}_{n+1}$ 不变。\n\n测试套件和输出规范：\n- 使用以下五个测试用例，每个用例指定为 $(\\gamma,\\beta,\\lambda,\\text{corrected},\\Delta t,T)$，其中布尔值 $\\text{corrected}$ 指示是否应用能量投影：\n    - 用例 1：$(\\tfrac{1}{2}, \\tfrac{1}{4}, 0, \\text{False}, 0.05, 50)$。\n    - 用例 2：$(\\tfrac{1}{2}, \\tfrac{1}{4}, 10^{-2}, \\text{False}, 0.05, 50)$。\n    - 用例 3：$(\\tfrac{1}{2}, \\tfrac{1}{6}, 10^{-2}, \\text{False}, 0.05, 50)$。\n    - 用例 4：$(\\tfrac{1}{2}, 0, 10^{-2}, \\text{False}, 0.02, 50)$。\n    - 用例 5：$(\\tfrac{1}{2}, \\tfrac{1}{4}, 10^{-1}, \\text{True}, 0.05, 50)$。\n- 对每个用例，计算在整个积分区间内的最大相对能量漂移，定义为：\n$$\n\\max_{0\\le n\\le N}\\frac{|\\mathcal{E}(\\mathbf{u}_n,\\mathbf{v}_n)-\\mathcal{E}(\\mathbf{u}_0,\\mathbf{v}_0)|}{\\mathcal{E}(\\mathbf{u}_0,\\mathbf{v}_0)}.\n$$\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表项按上述用例顺序排列。每个条目必须是标准十进制表示的浮点数。例如，输出格式为 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。", "solution": "该问题要求对半离散化的非线性克莱因-戈登方程的 Newmark 时间积分方法族进行综合分析和实现。这包括推导更新方程、讨论谱方法空间离散化、分析不同积分器的长期能量行为，以及实现一种能量守恒修正。\n\n### 问题陈述的有效性验证\n该问题在科学上和数学上都是合理的。它涉及数学物理中的一个标准模型（克莱因-戈登方程）和用于求解该模型的一个经典数值方法族（Newmark 方法）。对于具有周期性边界条件的问题，使用谱方法（FFT）进行空间离散化是一种标准且高度精确的技术。所有参数和初始条件都已提供，使得问题自成体系且适定。各项任务逻辑结构清晰，从理论推导引导到数值实现和分析。关于能量守恒的问题是研究哈密顿系统数值积分器的核心。该问题是有效的。\n\n### 基于原理的解决方案\n\n#### 任务1：Newmark 更新方程的推导\n对于形如 $\\mathbf{u}'' = \\mathbf{a}(t, \\mathbf{u}, \\mathbf{u}')$ 的二阶常微分方程组，Newmark 方法族由两个参数 $\\gamma$ 和 $\\beta$ 定义。从时间步 $n$ 到 $n+1$ 的更新由下式给出：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t\\,\\mathbf{v}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\mathbf{a}_n + \\beta \\Delta t^2 \\mathbf{a}_{n+1}\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\Delta t \\left((1-\\gamma)\\mathbf{a}_n + \\gamma \\mathbf{a}_{n+1}\\right)\n$$\n其中 $\\mathbf{u}_n \\approx \\mathbf{u}(t_n)$，$\\mathbf{v}_n \\approx \\mathbf{u}'(t_n)$，且 $\\mathbf{a}_n = \\mathbf{u}''(t_n)$。对于给定的半离散克莱因-戈登系统，加速度是位移 $\\mathbf{u}$ 的函数：\n$$\n\\mathbf{a}(\\mathbf{u}) = -\\mathbf{L}\\,\\mathbf{u} - \\lambda\\,\\mathbf{u}^{\\circ 3}\n$$\n因此，$\\mathbf{a}_n = \\mathbf{a}(\\mathbf{u}_n)$ 且 $\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{u}_{n+1})$。如果 $\\beta \\neq 0$，$\\mathbf{u}_{n+1}$ 的方程依赖于 $\\mathbf{a}_{n+1}$，而后者又依赖于 $\\mathbf{u}_{n+1}$。这使得方法是隐式的。为了明确地看到这一点，我们将 $\\mathbf{a}_{n+1}$ 的表达式代入位移更新方程：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t\\,\\mathbf{v}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\mathbf{a}_n - \\beta \\Delta t^2 \\left(\\mathbf{L}\\,\\mathbf{u}_{n+1} + \\lambda\\,\\mathbf{u}_{n+1}^{\\circ 3}\\right)\n$$\n整理各项，将未知数 $\\mathbf{u}_{n+1}$ 分离到左侧，得到一个在每个时间步都需要求解的非线性代数系统：\n$$\n\\mathbf{u}_{n+1} + \\beta \\Delta t^2 \\mathbf{L}\\,\\mathbf{u}_{n+1} + \\beta \\Delta t^2 \\lambda\\,\\mathbf{u}_{n+1}^{\\circ 3} = \\mathbf{u}_n + \\Delta t\\,\\mathbf{v}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\mathbf{a}_n\n$$\n令 $\\alpha = \\beta\\Delta t^2$，并将由第 $n$ 步的已知量构成的右侧定义为 $\\mathbf{r} = \\mathbf{u}_n + \\Delta t\\,\\mathbf{v}_n + \\Delta t^2\\left(\\tfrac{1}{2}-\\beta\\right)\\mathbf{a}_n$，我们得到：\n$$\n(\\mathbf{I} + \\alpha \\mathbf{L})\\mathbf{u}_{n+1} = \\mathbf{r} - \\alpha \\lambda\\,\\mathbf{u}_{n+1}^{\\circ 3}\n$$\n这正是问题中指定的非线性系统。它可以使用诸如牛顿法之类的迭代方法求解，或者如建议的那样，使用不动点迭代，其中右侧的非线性项使用前一次迭代的值进行计算。\n\n#### 任务2：使用 FFT 进行谱精度计算\n对于 $[0, 2\\pi]$ 上的周期函数，使用傅里叶级数表示的谱方法非常有效。网格 $x_j = j(2\\pi/N)$ 上的函数 $u(x)$ 由其值向量 $\\mathbf{u}$ 表示。\n1.  **计算 $\\mathbf{L}\\,\\mathbf{u}$**：算子 $\\mathbf{L}$ 对应于 $-c^2\\partial_{xx}$。在傅里叶空间中，微分 $\\partial_{xx}$ 对应于乘以 $(ik)^2 = -k^2$，其中 $k$ 是整数波数。因此，算子 $\\mathbf{L}$ 对应于在傅里叶空间中乘以 $c^2k^2$。其步骤是：\n    *   计算 $\\mathbf{u}$ 的傅里叶系数：$\\hat{\\mathbf{u}} = \\text{FFT}(\\mathbf{u})$。\n    *   令 $\\mathbf{k}$ 为对应于离散傅里叶模式的整数波数向量。离散算子 $\\mathbf{L}$ 的特征值为 $\\{c^2k^2\\}$。按元素相乘：$\\widehat{\\mathbf{L}\\,\\mathbf{u}} = (c^2\\mathbf{k}^{\\circ 2}) \\odot \\hat{\\mathbf{u}}$。\n    *   变换回物理空间：$\\mathbf{L}\\,\\mathbf{u} = \\text{IFFT}(\\widehat{\\mathbf{L}\\,\\mathbf{u}})$。这种方法的计算复杂度为 $O(N \\log N)$，并避免了构造稠密矩阵 $\\mathbf{L}$。\n\n2.  **求解隐式步骤**：不动点迭代需要在每次迭代中求解一个形如 $(\\mathbf{I} + \\alpha \\mathbf{L})\\mathbf{w} = \\mathbf{f}$ 的线性系统。这也可以在傅里叶空间中高效完成。对该方程应用 FFT 得到：\n    $$\n    (\\mathbf{I} + \\alpha \\text{diag}(c^2\\mathbf{k}^{\\circ 2})) \\hat{\\mathbf{w}} = \\hat{\\mathbf{f}}\n    $$\n    这个对角系统可以逐元素求解，得到解的傅里叶系数：$\\hat{w}_k = \\hat{f}_k / (1 + \\alpha c^2 k^2)$。然后通过 IFFT 找到解 $\\mathbf{w}$。\n\n3.  **离散能量计算**：哈密顿量 $\\mathcal{E}$ 是一个积分，我们使用谱精度的求积法（周期网格上的梯形法则）来近似它。离散能量为：\n    $$\n    \\mathcal{E}(\\mathbf{u},\\mathbf{v}) = \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} \\left( \\tfrac{1}{2} v_j^2 + \\tfrac{c^2}{2} (u_x)_j^2 + \\tfrac{\\lambda}{4} u_j^4 \\right)\n    $$\n    为保持一致性，空间导数项 $\\mathbf{u}_x$ 也采用谱方法计算：$\\mathbf{u}_x = \\text{IFFT}(i\\mathbf{k} \\odot \\text{FFT}(\\mathbf{u}))$。然后所有项都在物理空间中计算并求和。\n\n#### 任务3：长期能量漂移分析\n数值方法应用于哈密顿系统时的长期行为与其几何性质，特别是辛性（symplecticity），密切相关。一个辛积分器能精确保持相空间的辛结构，这导致对修正后的哈密顿量有极好的长期保持性，且原始哈密顿量的误差有界。\n\n*   **用例 4：$(\\gamma, \\beta) = (1/2, 0)$ (Störmer-Verlet)**：此方法是显式的。对于可分的哈密顿量 $H=T(v)+P(u)$，此方法是辛的。克莱因-戈登方程具有这种结构。因此，Störmer-Verlet 方法有望表现出优越的长期能量行为。数值能量不会漂移，而是在初始能量附近以小振幅振荡。这是几何积分器的一个标志。\n\n*   **用例 1 和 2：$(\\gamma, \\beta) = (1/2, 1/4)$ (梯形法则/Crank-Nicolson)**：这是一种隐式的二阶方法。对于线性哈密顿系统（$\\lambda=0$，用例 1），它既是辛的，又能精确守恒二次能量。因此，对于用例 1，能量误差应达到机器精度水平。对于非线性系统（$\\lambda \\ne 0$，用例 2），它不再是辛的。虽然它是 A-稳定的，并且通常被认为具有良好的守恒性质，但在长时间内，它会表现出缓慢的、累积的能量漂移。\n\n*   **用例 3：$(\\gamma, \\beta) = (1/2, 1/6)$ (线性加速度法)**：这是另一种二阶隐式方法。与梯形法则一样，它对非线性问题不是辛的。已知该方法会引入少量的数值耗散，这通常会导致总能量随时间衰减。我们预期与梯形法则相比，它会表现出更显著和系统性的能量漂移（衰减）。\n\n总之，$(\\gamma, \\beta)$ 的选择决定了积分器的几何性质。只有特定的选择，如显式 Störmer-Verlet 格式，对此类问题是辛的，从而导致性质上更优的长期能量守恒。\n\n#### 任务4：能量投影修正\n由于一般的 Newmark 方法对非线性问题不是能量守恒的，人们可以采用事后强制能量守恒的方法。所提议的修正是一种投影法。在标准的 Newmark 步骤计算出 $(\\tilde{\\mathbf{u}}_{n+1}, \\tilde{\\mathbf{v}}_{n+1})$ 后，我们修改状态，使其位于初始能量曲面 $\\mathcal{E}(\\mathbf{u}, \\mathbf{v}) = \\mathcal{E}_0$ 上。所提议的投影保持位移固定，$\\mathbf{u}_{n+1} = \\tilde{\\mathbf{u}}_{n+1}$，并重新缩放速度，$\\mathbf{v}_{n+1} = s \\tilde{\\mathbf{v}}_{n+1}$。\n\n离散能量为 $\\mathcal{E} = K(\\mathbf{v}) + P(\\mathbf{u})$，其中 $K(\\mathbf{v}) = \\frac{\\pi}{N} ||\\mathbf{v}||_2^2$ 是总动能，$P(\\mathbf{u})$ 是总势能。我们强制执行以下条件：\n$$\n\\mathcal{E}(\\mathbf{u}_{n+1}, s \\tilde{\\mathbf{v}}_{n+1}) = K(s \\tilde{\\mathbf{v}}_{n+1}) + P(\\mathbf{u}_{n+1}) = \\mathcal{E}_0\n$$\n由于 $K(s \\tilde{\\mathbf{v}}_{n+1}) = s^2 K(\\tilde{\\mathbf{v}}_{n+1})$，我们可以解出缩放因子 $s$：\n$$\ns^2 K(\\tilde{\\mathbf{v}}_{n+1}) = \\mathcal{E}_0 - P(\\mathbf{u}_{n+1}) \\implies s = \\sqrt{\\frac{\\mathcal{E}_0 - P(\\mathbf{u}_{n+1})}{K(\\tilde{\\mathbf{v}}_{n+1})}}\n$$\n仅当目标动能 $\\mathcal{E}_0 - P(\\mathbf{u}_{n+1})$ 为非负且当前动能 $K(\\tilde{\\mathbf{v}}_{n+1})$ 为正时，才应用此修正。该方法通过构造强制离散能量在每一步都守恒，从而消除任何漂移。对于非线性相对较大的用例 5，此投影将抵消底层梯形法则的漂移，从而使能量误差接近机器精度。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear Klein-Gordon equation using the Newmark family of methods\n    and analyzes energy conservation for different parameter choices.\n    \"\"\"\n    test_cases = [\n        # (gamma, beta, lambda, corrected, dt, T)\n        (0.5, 0.25, 0.0, False, 0.05, 50),\n        (0.5, 0.25, 1e-2, False, 0.05, 50),\n        (0.5, 1/6, 1e-2, False, 0.05, 50),\n        (0.5, 0.0, 1e-2, False, 0.02, 50),\n        (0.5, 0.25, 1e-1, True, 0.05, 50),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        gamma, beta, lam, corrected, dt, T = case\n\n        # --- Setup ---\n        N = 64\n        L = 2 * np.pi\n        c = 1.0\n        A = 0.1\n        dx = L / N\n        \n        x = np.arange(N) * dx\n        # Integer wavenumbers for a domain of length 2*pi\n        k = fftfreq(N) * N\n        \n        # Initial conditions\n        u = A * np.sin(x)\n        v = np.zeros(N)\n\n        # L operator eigenvalues in Fourier space for L = -c^2 * d_xx\n        L_op_fourier = (c * k)**2\n\n        # --- Energy Helper Functions ---\n        def get_potential_energy(u_vec):\n            # Spectral derivative for u_x\n            ux = np.real(ifft(1j * k * fft(u_vec)))\n            # Potential energy from u_x^2 and u^4 terms\n            pot_energy_L = 0.5 * c**2 * np.sum(ux**2)\n            pot_energy_NL = 0.25 * lam * np.sum(u_vec**4)\n            return (pot_energy_L + pot_energy_NL) * dx\n\n        def get_kinetic_energy(v_vec):\n            return 0.5 * np.sum(v_vec**2) * dx\n\n        def get_total_energy(u_vec, v_vec):\n            return get_potential_energy(u_vec) + get_kinetic_energy(v_vec)\n\n        # --- Time Stepping Loop ---\n        num_steps = int(T / dt)\n        energy_history = []\n        u_n, v_n = u, v\n        \n        E0 = get_total_energy(u_n, v_n)\n        # Avoid division by zero if initial energy is zero\n        E0_denom = np.abs(E0) if np.abs(E0) > 1e-15 else 1.0\n        energy_history.append(E0)\n\n        for _ in range(num_steps):\n            # 1. Calculate acceleration at step n\n            # L*u_n is computed spectrally\n            Lu_n = np.real(ifft(L_op_fourier * fft(u_n)))\n            a_n = -Lu_n - lam * u_n**3\n\n            # 2. Find displacement u_{n+1}\n            if beta == 0:  # Explicit method (Störmer-Verlet)\n                u_np1 = u_n + dt * v_n + 0.5 * dt**2 * a_n\n            else:  # Implicit method\n                alpha = beta * dt**2\n                r = u_n + dt * v_n + (0.5 - beta) * dt**2 * a_n\n                \n                # Fixed-point iteration to solve for u_{n+1}\n                u_np1_iter = u_n # Initial guess\n                lin_solver_denom = 1.0 + alpha * L_op_fourier\n                \n                for _ in range(5): # 5 iterations is sufficient for weak nonlinearity\n                    rhs = r - alpha * lam * u_np1_iter**3\n                    u_np1_iter = np.real(ifft(fft(rhs) / lin_solver_denom))\n                \n                u_np1 = u_np1_iter\n\n            # 3. Calculate acceleration at step n+1\n            Lu_np1 = np.real(ifft(L_op_fourier * fft(u_np1)))\n            a_np1 = -Lu_np1 - lam * u_np1**3\n            \n            # 4. Find velocity v_{n+1} (tentative)\n            v_np1_tilde = v_n + dt * ((1 - gamma) * a_n + gamma * a_np1)\n            \n            # 5. Apply energy projection if enabled\n            if corrected:\n                P_np1 = get_potential_energy(u_np1)\n                K_target = E0 - P_np1\n                \n                K_tilde = get_kinetic_energy(v_np1_tilde)\n                \n                if K_target >= 0.0 and K_tilde > 1e-15:\n                    s = np.sqrt(K_target / K_tilde)\n                    v_np1 = s * v_np1_tilde\n                else:\n                    v_np1 = v_np1_tilde # Leave unchanged if conditions not met\n            else:\n                v_np1 = v_np1_tilde\n\n            # Update state for next step\n            u_n, v_n = u_np1, v_np1\n\n            current_E = get_total_energy(u_n, v_n)\n            energy_history.append(current_E)\n        \n        # --- Post-processing ---\n        energy_history = np.array(energy_history)\n        relative_error = np.abs(energy_history - E0) / E0_denom\n        max_relative_error = np.max(relative_error)\n        results.append(max_relative_error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3424207"}]}