{"hands_on_practices": [{"introduction": "交换相关（XC）泛函的选择是任何密度泛函理论计算的核心。不同的泛函在基础物理层面有所不同，尤其是在它们包含的精确 Hartree-Fock 交换的比例上，这直接影响了计算的准确性。本练习 [@problem_id:3698588] 提供了一个动手实践模型，用以探究精确交换比例如何系统地修正简单泛函中常见的过度束缚误差，从而改进对振动频率的预测。", "problem": "您的任务是设计并实现一个程序，该程序通过从坚实的物理原理出发，为不同的密度泛函理论（DFT）交换相关近似模拟红外（IR）羰基伸缩振动频率预测。请使用玻恩–奥本海默近似和势能面极小点附近的谐振子近似作为您的基本基础，并基于力常数（定义为势能相对于键位移的曲率）的定义以及振动频率与折合质量之间的关系进行推导。您的目标是构建一个定量模型，该模型能够捕捉由于自相互作用误差引起的系统性过结合，以及在杂化泛函中通过一部分精确交换来缓解这种误差的效应。该程序必须计算并比较羰基在以下泛函下的红外波数（单位为 $\\mathrm{cm}^{-1}$）：Perdew–Burke–Ernzerhof (PBE)、Becke, $3$-parameter, Lee–Yang–Parr (B3LYP) 和 PBE0，并额外报告两个边界情况下的值以测试模型行为。\n\n使用的建模指令和常数：\n- 假设单个羰基键被视为一个双原子振子，其中碳的质量为 $12$ 原子质量单位（atomic mass unit (amu)），氧的质量为 $16$ 原子质量单位。\n- 使用原子质量单位 $1\\,\\mathrm{amu} = 1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$。\n- 使用光速 $c = 2.99792458\\times 10^{10}\\,\\mathrm{cm/s}$。\n- 取参考（目标，无自相互作用误差）羰基波数为 $\\tilde{\\nu}_{\\mathrm{ref}} = 1715\\,\\mathrm{cm}^{-1}$，代表在没有系统性过结合情况下的典型有机羰基伸缩振动。\n- 定义碳和氧的折合质量 $\\mu$，并通过从这些基础出发进行适当的推导，将预测的谐振波数 $\\tilde{\\nu}$ 与力常数曲率 $k$ 和 $\\mu$ 联系起来。\n- 通过一个单调递减的偏置项来模拟精确交换分数 $\\alpha$ 对曲率的影响，该偏置项表示当 $\\alpha = 0$ 时的残余过结合，并随着 $\\alpha$ 的增加而减小。使用以下曲率模型形式：\n  - $k(\\alpha) = k_{\\mathrm{ref}}\\left[1 + \\delta_{0}\\exp\\!\\left(-\\dfrac{\\alpha}{\\alpha_{0}}\\right)\\right]$,\n  其中 $k_{\\mathrm{ref}}$ 是与 $\\tilde{\\nu}_{\\mathrm{ref}}$ 一致的曲率，$\\delta_{0} = 0.12$ 是零精确交换时的分数过结合幅度，$\\alpha_{0} = 0.10$ 表征了随精确交换增加而衰减的特性。\n- 计算以下精确交换分数 $\\alpha$ 测试套件的预测红外波数（单位 $\\mathrm{cm}^{-1}$）：\n  - PBE: $\\alpha = 0.00$\n  - B3LYP: $\\alpha = 0.20$\n  - PBE0: $\\alpha = 0.25$\n  - 边界情况（更高杂化成分）：$\\alpha = 0.50$\n  - 边界情况（类哈特里-福克极限）：$\\alpha = 1.00$\n- 将所有最终波数结果以 $\\mathrm{cm}^{-1}$ 表示，并四舍五入到小数点后一位。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表用方括号括起来（例如 $[\\text{result1},\\text{result2},\\text{result3},\\dots]$）。该列表必须按照上面指定的精确顺序包含为测试套件计算的五个波数。不应打印任何其他文本。", "solution": "所述问题具有科学依据，提法得当，且内部一致。所有必要的物理常数、模型参数和理论框架都已提供，足以构建一个唯一的、可验证的解。其基础模型是一个基于物理动机的（尽管是唯象的）表述，描述了密度泛函理论(DFT)中自相互作用误差对振动频率的影响，这是计算化学中的一个标准课题。因此，该问题是有效的，可以构建出解决方案。\n\n目标是计算在不同DFT交换相关泛函下，一个被建模为双原子谐振子的羰基的预测红外（IR）伸缩振动波数 $\\tilde{\\nu}$。每个泛函的影响由其精确交换的分数 $\\alpha$ 来参数化。\n\n分析始于谐振子的基本关系。角频率 $\\omega$ 与力常数 $k$（势能面的曲率）和折合质量 $\\mu$ 的关系为：\n$$\n\\omega = \\sqrt{\\frac{k}{\\mu}}\n$$\n振动频率 $\\nu$ 为 $\\nu = \\omega / (2\\pi)$。在光谱学中，通常使用波数 $\\tilde{\\nu}$，其定义为 $\\tilde{\\nu} = \\nu/c$，其中 $c$ 是光速。结合这些定义，得到振动波数的核心方程：\n$$\n\\tilde{\\nu} = \\frac{1}{2\\pi c}\\sqrt{\\frac{k}{\\mu}}\n$$\n问题将羰基 C=O 建模为一个双原子体系。给定的质量为 $m_C = 12\\,\\mathrm{amu}$ 和 $m_O = 16\\,\\mathrm{amu}$。折合质量 $\\mu$ 计算如下：\n$$\n\\mu = \\frac{m_C m_O}{m_C + m_O} = \\frac{(12\\,\\mathrm{amu})(16\\,\\mathrm{amu})}{12\\,\\mathrm{amu} + 16\\,\\mathrm{amu}} = \\frac{192}{28}\\,\\mathrm{amu} = \\frac{48}{7}\\,\\mathrm{amu}\n$$\n尽管提供了将原子质量单位转换为千克的常数（$1\\,\\mathrm{amu} = 1.66053906660\\times 10^{-27}\\,\\mathrm{kg}$），但我们可以设计一个更简洁的解决方案，首先确定与指定参考波数 $\\tilde{\\nu}_{\\mathrm{ref}} = 1715\\,\\mathrm{cm}^{-1}$ 对应的参考力常数 $k_{\\mathrm{ref}}$。这个参考值代表了理想的、无自相互作用误差的结果。\n\n重排波数方程，我们可以用力常数 $k$ 表示 $\\tilde{\\nu}$、$c$ 和 $\\mu$：\n$$\nk = (2\\pi c \\tilde{\\nu})^2 \\mu\n$$\n因此，参考力常数为：\n$$\nk_{\\mathrm{ref}} = (2\\pi c \\tilde{\\nu}_{\\mathrm{ref}})^2 \\mu\n$$\n问题提出了一个关于预测力常数 $k(\\alpha)$ 作为精确交换分数 $\\alpha$ 的函数模型。该模型捕捉了与纯广义梯度近似（GGA）泛函（其中 $\\alpha=0$）相关的系统性过结合（更大的力常数）以及随着精确交换的混入而减小的效应：\n$$\nk(\\alpha) = k_{\\mathrm{ref}}\\left[1 + \\delta_{0}\\exp\\!\\left(-\\frac{\\alpha}{\\alpha_{0}}\\right)\\right]\n$$\n这里，$\\delta_{0} = 0.12$ 表示在 $\\alpha=0$ 时力常数的分数过高估计，而 $\\alpha_{0} = 0.10$ 是一个衰减常数，表征了这种过高估计随 $\\alpha$ 增加而得到修正的速度。\n\n现在，通过将 $k(\\alpha)$ 的表达式代入基本波数方程，可以写出预测的波数 $\\tilde{\\nu}(\\alpha)$：\n$$\n\\tilde{\\nu}(\\alpha) = \\frac{1}{2\\pi c}\\sqrt{\\frac{k(\\alpha)}{\\mu}} = \\frac{1}{2\\pi c}\\sqrt{\\frac{k_{\\mathrm{ref}}\\left[1 + \\delta_{0}\\exp\\!\\left(-\\frac{\\alpha}{\\alpha_{0}}\\right)\\right]}{\\mu}}\n$$\n我们可以将此表达式分解为：\n$$\n\\tilde{\\nu}(\\alpha) = \\left(\\frac{1}{2\\pi c}\\sqrt{\\frac{k_{\\mathrm{ref}}}{\\mu}}\\right) \\sqrt{1 + \\delta_{0}\\exp\\!\\left(-\\frac{\\alpha}{\\alpha_{0}}\\right)}\n$$\n括号中的项根据定义就是参考波数 $\\tilde{\\nu}_{\\mathrm{ref}}$。这导出了一个简化的、计算上直接的最终表达式，从而巧妙地避免了以千克为单位显式计算 $\\mu$ 或以国际单位制（SI）计算 $k_{\\mathrm{ref}}$ 的需要：\n$$\n\\tilde{\\nu}(\\alpha) = \\tilde{\\nu}_{\\mathrm{ref}} \\sqrt{1 + \\delta_{0}\\exp\\!\\left(-\\frac{\\alpha}{\\alpha_{0}}\\right)}\n$$\n使用给定的值 $\\tilde{\\nu}_{\\mathrm{ref}} = 1715\\,\\mathrm{cm}^{-1}$，$\\delta_{0} = 0.12$ 和 $\\alpha_{0} = 0.10$，我们可以为指定的 $\\alpha$ 值测试套件计算波数。\n\n测试套件是：\n1.  PBE: $\\alpha = 0.00$\n    $$\n    \\tilde{\\nu}(0.00) = 1715 \\sqrt{1 + 0.12 \\exp(0)} = 1715 \\sqrt{1.12} \\approx 1815.018\\,\\mathrm{cm}^{-1}\n    $$\n2.  B3LYP: $\\alpha = 0.20$\n    $$\n    \\tilde{\\nu}(0.20) = 1715 \\sqrt{1 + 0.12 \\exp\\left(-\\frac{0.20}{0.10}\\right)} = 1715 \\sqrt{1 + 0.12 e^{-2}} \\approx 1728.828\\,\\mathrm{cm}^{-1}\n    $$\n3.  PBE0: $\\alpha = 0.25$\n    $$\n    \\tilde{\\nu}(0.25) = 1715 \\sqrt{1 + 0.12 \\exp\\left(-\\frac{0.25}{0.10}\\right)} = 1715 \\sqrt{1 + 0.12 e^{-2.5}} \\approx 1723.411\\,\\mathrm{cm}^{-1}\n    $$\n4.  边界情况（更高杂化成分）：$\\alpha = 0.50$\n    $$\n    \\tilde{\\nu}(0.50) = 1715 \\sqrt{1 + 0.12 \\exp\\left(-\\frac{0.50}{0.10}\\right)} = 1715 \\sqrt{1 + 0.12 e^{-5}} \\approx 1715.693\\,\\mathrm{cm}^{-1}\n    $$\n5.  边界情况（类哈特里-福克极限）：$\\alpha = 1.00$\n    $$\n    \\tilde{\\nu}(1.00) = 1715 \\sqrt{1 + 0.12 \\exp\\left(-\\frac{1.00}{0.10}\\right)} = 1715 \\sqrt{1 + 0.12 e^{-10}} \\approx 1715.005\\,\\mathrm{cm}^{-1}\n    $$\n这些结果必须四舍五入到小数点后一位作为最终输出。以下程序实现了此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes predicted IR wavenumbers for a carbonyl group based on a model\n    of DFT self-interaction error as a function of exact exchange fraction.\n    \"\"\"\n    \n    # Define model parameters and the reference value from the problem statement.\n    nu_ref_cm_inv = 1715.0  # Reference wavenumber in cm^-1\n    delta_0 = 0.12          # Zero-exchange fractional overbinding magnitude\n    alpha_0 = 0.10          # Decay constant for exact exchange correction\n\n    # Define the test suite of exact exchange fractions (alpha)\n    # The order corresponds to PBE, B3LYP, PBE0, high-hybrid, HF-limit.\n    alpha_values = [\n        0.00,  # PBE\n        0.20,  # B3LYP\n        0.25,  # PBE0\n        0.50,  # Boundary case 1\n        1.00   # Boundary case 2\n    ]\n\n    results = []\n    \n    # The core model equation relates the predicted wavenumber to the reference\n    # wavenumber and the fraction of exact exchange, alpha.\n    # nu_pred(alpha) = nu_ref * sqrt(1 + delta_0 * exp(-alpha / alpha_0))\n    for alpha in alpha_values:\n        # Calculate the argument of the square root\n        correction_term = delta_0 * np.exp(-alpha / alpha_0)\n        \n        # Calculate the predicted wavenumber\n        nu_pred = nu_ref_cm_inv * np.sqrt(1 + correction_term)\n        \n        # Round the result to one decimal place as required\n        rounded_result = round(nu_pred, 1)\n        results.append(rounded_result)\n\n    # Format the final output as a comma-separated list in square brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n\n```", "id": "3698588"}, {"introduction": "选定泛函后，研究者必须选择一组基函数来表示分子轨道，这一选择对结果的准确性至关重要。本练习 [@problem_id:3698611] 旨在分离和研究由基组不完备性引起的误差，展示其如何独立地影响分子力和电子性质的计算。通过比较一个小基组和一个大基组，您将对基组质量如何影响预测的红外频率和强度获得定量的理解。", "problem": "您必须编写一个完整的程序，在谐波近似下，使用两种不同的轨道基组比较预测的一氧化碳伸缩振动频率和红外强度，并在密度泛函理论 (DFT) 振动分析中定量地归因于基组相关误差的主要来源。程序必须实现以下模型，为提供的测试套件计算所要求的量，并以指定的单行格式生成最终结果。\n\n使用以下基本和核心定义。\n\n1) Born–Oppenheimer 分离与谐波近似：在平衡键长附近，双原子分子的势能近似为键位移坐标的二次函数。在平衡几何构型下评估的 Hessian 矩阵（势能对键长的二阶导数）即为力常数。在谐波近似下，振动角频率由下式给出：\n$$\\omega = \\sqrt{\\frac{k}{\\mu}},$$\n其中 $k$ 是谐波力常数，$\\mu$ 是约化质量。\n\n2) 波数转换：可观测的谐波波数（以倒易厘米为单位）为：\n$$\\tilde{\\nu} = \\frac{\\omega}{2\\pi c} = \\frac{1}{2\\pi c}\\sqrt{\\frac{k}{\\mu}},$$\n其中 $c$ 是光速，单位为 $\\mathrm{cm\\,s^{-1}}$。所有波数都必须以 $\\mathrm{cm^{-1}}$ 表示。\n\n3) 双谐波近似下的红外 (IR) 强度：基频振动跃迁的积分强度与永久偶极矩对简正坐标的导数的平方成正比。对于具有单一简正模式的双原子分子，质量加权简正坐标 $Q$ 与键长 $r$ 的关系为 $Q=\\sqrt{\\mu}\\,\\Delta r$（相差一个不重要的相位）。因此，\n$$\\left(\\frac{\\partial \\mu}{\\partial Q}\\right) = \\frac{1}{\\sqrt{\\mu}}\\left(\\frac{\\partial \\mu}{\\partial r}\\right),$$\n因此，在固定的 $\\mu$ 下，红外强度中的任何基组误差都源于 $\\partial\\mu/\\partial r$ 的误差。为消除单位依赖性并确保目标值无量纲，将归一化红外强度定义为比率：\n$$I_{\\mathrm{rel}} = \\left(\\frac{(\\partial\\mu/\\partial r)_{\\mathrm{pred}}}{(\\partial\\mu/\\partial r)_{\\mathrm{ref}}}\\right)^2,$$\n此值为无量纲。\n\n4) 基组误差模型：将基组不完备性误差表示为相对于固定的高水平参考值的力常数和偶极矩导数的相对微扰：\n$$k_{\\mathrm{pred}} = k_{\\mathrm{ref}}\\left(1 + \\delta_k\\right),\\qquad \\left(\\frac{\\partial \\mu}{\\partial r}\\right)_{\\mathrm{pred}} = \\left(\\frac{\\partial \\mu}{\\partial r}\\right)_{\\mathrm{ref}}\\left(1 + \\delta_d\\right),$$\n其中 $\\delta_k$ 和 $\\delta_d$ 是与所选基组相关的无量纲相对误差。\n\n所有计算中使用的常数和参考值：\n\n- 原子质量单位：$u = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$。\n- 原子质量：$m_{\\mathrm{C}} = 12.000000\\ u$, $m_{\\mathrm{O}} = 15.99491461957\\ u$。\n- 约化质量：$\\mu = \\frac{m_{\\mathrm{C}} m_{\\mathrm{O}}}{m_{\\mathrm{C}} + m_{\\mathrm{O}}}$，单位为 $\\mathrm{kg}$。\n- 光速：$c = 2.99792458\\times 10^{10}\\ \\mathrm{cm\\,s^{-1}}$。\n- 参考 CO 谐波波数：$\\tilde{\\nu}_{\\mathrm{ref}} = 2143.27\\ \\mathrm{cm^{-1}}$。\n- 由波数和约化质量隐式定义的参考力常数：\n$$k_{\\mathrm{ref}} = \\mu \\left(2\\pi c \\tilde{\\nu}_{\\mathrm{ref}}\\right)^2\\ \\mathrm{N\\,m^{-1}}.$$\n- 参考偶极矩导数（为模型的完整性，在归一化强度中会消掉）：$\\left(\\frac{\\partial \\mu}{\\partial r}\\right)_{\\mathrm{ref}} = 0.20$，单位为一致的任意单位；仅使用比率。\n\n对于给定的配对 $\\left(\\delta_k,\\delta_d\\right)$，计算：\n- 预测的谐波波数，以倒易厘米为单位，\n$$\\tilde{\\nu}_{\\mathrm{pred}} = \\frac{1}{2\\pi c}\\sqrt{\\frac{k_{\\mathrm{ref}}(1+\\delta_k)}{\\mu}},$$\n四舍五入到小数点后两位，并以 $\\mathrm{cm^{-1}}$ 表示。\n- 归一化红外强度 $I_{\\mathrm{rel}}=\\left(1+\\delta_d\\right)^2$，四舍五入到小数点后五位（无量纲）。\n- 绝对波数误差 $|\\tilde{\\nu}_{\\mathrm{pred}} - \\tilde{\\nu}_{\\mathrm{ref}}|$，单位为 $\\mathrm{cm^{-1}}$，四舍五入到小数点后两位。\n- 绝对归一化强度偏差 $|I_{\\mathrm{rel}}-1|$（无量纲），四舍五入到小数点后五位。\n\n为确定每个可观测量与基组相关的误差的主要来源，将总误差分解为分别扰动每个主要量的贡献：\n- 频率敏感性：计算仅扰动 $k$ 时的波数，$\\tilde{\\nu}_{k\\text{-only}}=\\frac{1}{2\\pi c}\\sqrt{\\frac{k_{\\mathrm{ref}}(1+\\delta_k)}{\\mu}}$，以及仅扰动 $\\partial\\mu/\\partial r$ 时的波数，$\\tilde{\\nu}_{d\\text{-only}}=\\frac{1}{2\\pi c}\\sqrt{\\frac{k_{\\mathrm{ref}}}{\\mu}}=\\tilde{\\nu}_{\\mathrm{ref}}$。定义贡献 $\\Delta\\tilde{\\nu}_{k}=|\\tilde{\\nu}_{k\\text{-only}}-\\tilde{\\nu}_{\\mathrm{ref}}|$ 和 $\\Delta\\tilde{\\nu}_{d}=|\\tilde{\\nu}_{d\\text{-only}}-\\tilde{\\nu}_{\\mathrm{ref}}|$，并设置一个布尔标志以判断力常数的贡献是否占主导地位：$\\mathrm{isKdom} = \\Delta\\tilde{\\nu}_{k} \\ge \\Delta\\tilde{\\nu}_{d}$。\n- 强度敏感性：计算 $I_{\\mathrm{rel},k\\text{-only}}=1$ 和 $I_{\\mathrm{rel},d\\text{-only}}=\\left(1+\\delta_d\\right)^2$，然后定义 $\\Delta I_k=|I_{\\mathrm{rel},k\\text{-only}}-1|$ 和 $\\Delta I_d=|I_{\\mathrm{rel},d\\text{-only}}-1|$，并设置一个布尔标志以判断偶极矩导数的贡献是否占主导地位：$\\mathrm{isDdom} = \\Delta I_d \\ge \\Delta I_k$。\n\n测试套件。评估以下五个案例：\n- 案例 1 (6-31G(d)): $\\delta_k=-0.05$, $\\delta_d=-0.10$。\n- 案例 2 (correlation-consistent polarized valence triple-zeta, cc-pVTZ): $\\delta_k=-0.01$, $\\delta_d=-0.03$。\n- 案例 3 (理想/无误差): $\\delta_k=0.00$, $\\delta_d=0.00$。\n- 案例 4 (仅力常数误差): $\\delta_k=+0.02$, $\\delta_d=0.00$。\n- 案例 5 (仅偶极矩导数误差): $\\delta_k=0.00$, $\\delta_d=+0.15$。\n\n此外，通过提供绝对误差的比率，报告案例 1 和案例 2 中两种基组之间的定量比较：\n- 绝对波数误差的比率，$R_{\\nu} = \\frac{|\\tilde{\\nu}_{\\mathrm{pred}}^{(1)} - \\tilde{\\nu}_{\\mathrm{ref}}|}{|\\tilde{\\nu}_{\\mathrm{pred}}^{(2)} - \\tilde{\\nu}_{\\mathrm{ref}}|}$，四舍五入到小数点后五位。\n- 绝对归一化强度偏差的比率，$R_{I} = \\frac{|I_{\\mathrm{rel}}^{(1)}-1|}{|I_{\\mathrm{rel}}^{(2)}-1|}$，四舍五入到小数点后五位。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个列表，其元素按顺序为五个案例各自的结果，后跟一个包含两个元素的比较列表。每个案例的结果本身必须是一个包含六个条目的列表，顺序如下：\n[$\\tilde{\\nu}_{\\mathrm{pred}}$，单位 $\\mathrm{cm^{-1}}$ (四舍五入到两位小数)，$I_{\\mathrm{rel}}$ (四舍五入到五位小数)，$|\\tilde{\\nu}_{\\mathrm{pred}}-\\tilde{\\nu}_{\\mathrm{ref}}|$，单位 $\\mathrm{cm^{-1}}$ (四舍五入到两位小数)，$|I_{\\mathrm{rel}}-1|$ (四舍五入到五位小数)，$\\mathrm{isKdom}$ (布尔值)，$\\mathrm{isDdom}$ (布尔值)]。\n\n具体来说，打印的行应看起来像一个有效的、带有嵌套方括号的逗号分隔列表，例如：\n[[nu1,I1,dnu1,dI1,True,True],[nu2,I2,dnu2,dI2,True,True],...,[Rnu,RI]]\n\n所有波数都必须以 $\\mathrm{cm^{-1}}$ 为单位，并四舍五入到小数点后两位。所有归一化强度和比率都必须是无量纲小数，并四舍五入到小数点后五位。不使用角度。百分比必须表示为小数（例如，百分之十表示为 0.10）。不应打印任何额外文本。", "solution": "用户提供了一个定义明确的计算问题，其基础是理论光谱学的原理。该问题在科学上是合理的、自洽的，并要求实现一个清晰的物理模型。所有必需的常数、参考值和解析表达式均已提供。目标明确，可以计算出唯一、可验证的解。因此，该问题被认定为有效。\n\n求解过程首先建立必要的物理常数和派生的参考值。随后，对于基组误差参数 $(\\delta_k, \\delta_d)$ 的每个指定案例，计算一系列量：预测的振动波数、归一化的红外强度、它们各自与参考值的偏差，以及指示每个可观测量主要误差来源的标志。最后，对两个特定基组之间的误差进行定量比较。\n\n首先，我们定义物理常数和参考值。\n原子质量单位是 $u = 1.66053906660\\times 10^{-27}\\ \\mathrm{kg}$。\n原子质量是 $m_{\\mathrm{C}} = 12.000000\\ u$ 和 $m_{\\mathrm{O}} = 15.99491461957\\ u$。\n一氧化碳分子的约化质量 $\\mu$ 计算如下：\n$$\n\\mu = \\frac{m_{\\mathrm{C}} m_{\\mathrm{O}}}{m_{\\mathrm{C}} + m_{\\mathrm{O}}} = \\frac{(12.000000)(15.99491461957)}{12.000000 + 15.99491461957} u \\approx 6.856209\\ u\n$$\n转换为国际单位制 (SI units)，$\\mu \\approx 1.138500 \\times 10^{-26}\\ \\mathrm{kg}$。\n光速是 $c = 2.99792458\\times 10^{10}\\ \\mathrm{cm\\,s^{-1}}$。\n参考谐波波数是 $\\tilde{\\nu}_{\\mathrm{ref}} = 2143.27\\ \\mathrm{cm^{-1}}$。\n\n参考力常数 $k_{\\mathrm{ref}}$ 由谐振子模型隐式定义：\n$$\n\\tilde{\\nu}_{\\mathrm{ref}} = \\frac{1}{2\\pi c}\\sqrt{\\frac{k_{\\mathrm{ref}}}{\\mu}}\n$$\n求解 $k_{\\mathrm{ref}}$ 可得 $k_{\\mathrm{ref}} = \\mu (2\\pi c \\tilde{\\nu}_{\\mathrm{ref}})^2$。虽然这个值可以进行数值计算，但如下所示，使用比率来处理会更简洁和精确。\n\n问题的核心在于评估相对误差 $\\delta_k$ 和 $\\delta_d$ 对预测的可观测量的影响。预测的力常数是 $k_{\\mathrm{pred}} = k_{\\mathrm{ref}}(1 + \\delta_k)$。\n\n预测的谐波波数 $\\tilde{\\nu}_{\\mathrm{pred}}$ 由下式给出：\n$$\n\\tilde{\\nu}_{\\mathrm{pred}} = \\frac{1}{2\\pi c}\\sqrt{\\frac{k_{\\mathrm{pred}}}{\\mu}} = \\frac{1}{2\\pi c}\\sqrt{\\frac{k_{\\mathrm{ref}}(1+\\delta_k)}{\\mu}}\n$$\n通过代入 $\\tilde{\\nu}_{\\mathrm{ref}}$ 的表达式，上式可简化为：\n$$\n\\tilde{\\nu}_{\\mathrm{pred}} = \\left(\\frac{1}{2\\pi c}\\sqrt{\\frac{k_{\\mathrm{ref}}}{\\mu}}\\right) \\sqrt{1+\\delta_k} = \\tilde{\\nu}_{\\mathrm{ref}}\\sqrt{1+\\delta_k}\n$$\n这种简化形式避免了对 $k_{\\mathrm{ref}}$ 和 $\\mu$ 的显式计算，从而降低了浮点精度损失的风险。\n\n预测的归一化红外强度 $I_{\\mathrm{rel}}$ 取决于偶极矩导数的相对误差 $\\delta_d$：\n$$\nI_{\\mathrm{rel}} = \\left(\\frac{(\\partial\\mu/\\partial r)_{\\mathrm{pred}}}{(\\partial\\mu/\\partial r)_{\\mathrm{ref}}}\\right)^2 = \\left(\\frac{(\\partial\\mu/\\partial r)_{\\mathrm{ref}}(1+\\delta_d)}{(\\partial\\mu/\\partial r)_{\\mathrm{ref}}}\\right)^2 = (1+\\delta_d)^2\n$$\n\n对于每个案例，我们必须计算四个主要量：\n1. 预测的波数 $\\tilde{\\nu}_{\\mathrm{pred}}$，四舍五入到小数点后两位。\n2. 归一化红外强度 $I_{\\mathrm{rel}}$，四舍五入到小数点后五位。\n3. 绝对波数误差 $|\\tilde{\\nu}_{\\mathrm{pred}} - \\tilde{\\nu}_{\\mathrm{ref}}|$，四舍五入到小数点后两位。\n4. 绝对归一化强度偏差 $|I_{\\mathrm{rel}}-1|$，四舍五入到小数点后五位。\n\n接下来，我们进行敏感性分析。目标是确定力常数 ($k$) 的误差或偶极矩导数 ($d$) 的误差是否是每个可观测量误差的主要来源。\n\n对于波数，误差贡献定义为：\n$\\Delta\\tilde{\\nu}_{k} = |\\tilde{\\nu}_{k\\text{-only}} - \\tilde{\\nu}_{\\mathrm{ref}}|$，其中 $\\tilde{\\nu}_{k\\text{-only}} = \\tilde{\\nu}_{\\mathrm{ref}}\\sqrt{1+\\delta_k}$。\n$\\Delta\\tilde{\\nu}_{d} = |\\tilde{\\nu}_{d\\text{-only}} - \\tilde{\\nu}_{\\mathrm{ref}}|$，其中 $\\tilde{\\nu}_{d\\text{-only}} = \\tilde{\\nu}_{\\mathrm{ref}}$。\n因此，$\\Delta\\tilde{\\nu}_{k} = |\\tilde{\\nu}_{\\mathrm{ref}}\\sqrt{1+\\delta_k} - \\tilde{\\nu}_{\\mathrm{ref}}|$ 且 $\\Delta\\tilde{\\nu}_{d} = 0$。\n布尔标志是 $\\mathrm{isKdom} = (\\Delta\\tilde{\\nu}_{k} \\ge \\Delta\\tilde{\\nu}_{d})$。由于 $\\Delta\\tilde{\\nu}_{k}$ 是一个绝对值，因此始终为非负数，而 $\\Delta\\tilde{\\nu}_{d}$ 始终为 $0$，所以此条件始终为真。这正确地反映出，在这个解耦模型中，只有力常数影响频率。\n\n对于归一化强度，误差贡献是：\n$\\Delta I_k = |I_{\\mathrm{rel},k\\text{-only}}-1|$，其中 $I_{\\mathrm{rel},k\\text{-only}} = (1+0)^2=1$。\n$\\Delta I_d = |I_{\\mathrm{rel},d\\text{-only}}-1|$，其中 $I_{\\mathrm{rel},d\\text{-only}} = (1+\\delta_d)^2$。\n因此，$\\Delta I_k = 0$ 且 $\\Delta I_d = |(1+\\delta_d)^2 - 1|$。\n布尔标志是 $\\mathrm{isDdom} = (\\Delta I_d \\ge \\Delta I_k)$。由于 $\\Delta I_d$ 是一个绝对值，因此始终为非负数，而 $\\Delta I_k$ 始终为 $0$，所以此条件也始终为真。这正确地反映出，在此模型中，只有偶极矩导数影响红外强度。\n\n最后，我们计算案例 1 $(\\delta_k^{(1)}, \\delta_d^{(1)})$ 与案例 2 $(\\delta_k^{(2)}, \\delta_d^{(2)})$ 的绝对误差之比。\n绝对波数误差之比为：\n$$\nR_{\\nu} = \\frac{|\\tilde{\\nu}_{\\mathrm{pred}}^{(1)} - \\tilde{\\nu}_{\\mathrm{ref}}|}{|\\tilde{\\nu}_{\\mathrm{pred}}^{(2)} - \\tilde{\\nu}_{\\mathrm{ref}}|} = \\frac{\\tilde{\\nu}_{\\mathrm{ref}}|\\sqrt{1+\\delta_k^{(1)}} - 1|}{\\tilde{\\nu}_{\\mathrm{ref}}|\\sqrt{1+\\delta_k^{(2)}} - 1|} = \\frac{|\\sqrt{1+\\delta_k^{(1)}} - 1|}{|\\sqrt{1+\\delta_k^{(2)}} - 1|}\n$$\n绝对归一化强度偏差之比为：\n$$\nR_{I} = \\frac{|I_{\\mathrm{rel}}^{(1)}-1|}{|I_{\\mathrm{rel}}^{(2)}-1|} = \\frac{|(1+\\delta_d^{(1)})^2-1|}{|(1+\\delta_d^{(2)})^2-1|}\n$$\n这些比率需四舍五入到小数点后五位。\n\n程序将对五个测试案例执行这些计算，收集每个案例的六个指定结果，计算两个最终的比率指标，并根据问题规范将所有结果格式化为单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes predicted spectroscopic properties and error contributions for CO\n    based on a DFT error model.\n    \"\"\"\n    \n    # Define constants and reference values from the problem statement.\n    NU_REF_CM = 2143.27  # Reference wavenumber in cm^-1\n\n    # Define the test suite. Each tuple is (delta_k, delta_d).\n    test_cases = [\n        (-0.05, -0.10),   # Case 1: 6-31G(d)\n        (-0.01, -0.03),   # Case 2: cc-pVTZ\n        (0.00, 0.00),     # Case 3: Ideal/no error\n        (0.02, 0.00),     # Case 4: Force-constant-only error\n        (0.00, 0.15),     # Case 5: Dipole-derivative-only error\n    ]\n\n    all_case_results = []\n    case_abs_errors = []\n\n    for delta_k, delta_d in test_cases:\n        # --- Core Calculations ---\n        # The predicted wavenumber simplifies to nu_ref * sqrt(1 + delta_k).\n        nu_pred = NU_REF_CM * np.sqrt(1 + delta_k)\n        \n        # The normalized IR intensity.\n        i_rel = (1 + delta_d)**2\n        \n        # --- Error and Deviation Calculations ---\n        # Absolute wavenumber error.\n        d_nu = abs(nu_pred - NU_REF_CM)\n        \n        # Absolute normalized intensity deviation.\n        d_i = abs(i_rel - 1)\n        \n        # Store unrounded absolute errors for Cases 1 and 2 for the final ratio calculation.\n        case_abs_errors.append((d_nu, d_i))\n\n        # --- Sensitivity Analysis ---\n        # Wavenumber sensitivity.\n        # As derived, a change in dipole derivative (d) does not affect the wavenumber.\n        delta_nu_k = abs(NU_REF_CM * np.sqrt(1 + delta_k) - NU_REF_CM)\n        delta_nu_d = 0.0\n        is_k_dom = delta_nu_k >= delta_nu_d # Will always be True\n\n        # Intensity sensitivity.\n        # As derived, a change in force constant (k) does not affect the normalized intensity.\n        delta_i_k = 0.0\n        delta_i_d = abs((1 + delta_d)**2 - 1)\n        is_d_dom = delta_i_d >= delta_i_k # Will always be True\n\n        # --- Rounding for Output ---\n        nu_pred_rounded = round(nu_pred, 2)\n        i_rel_rounded = round(i_rel, 5)\n        d_nu_rounded = round(d_nu, 2)\n        d_i_rounded = round(d_i, 5)\n\n        # Collect results for the current case.\n        case_result = [\n            nu_pred_rounded, \n            i_rel_rounded, \n            d_nu_rounded, \n            d_i_rounded, \n            is_k_dom, \n            is_d_dom\n        ]\n        all_case_results.append(case_result)\n        \n    # --- Quantitative Comparison (Case 1 vs Case 2) ---\n    # Retrieve the unrounded absolute errors for Case 1 and Case 2.\n    d_nu1, d_i1 = case_abs_errors[0]\n    d_nu2, d_i2 = case_abs_errors[1]\n    \n    # Calculate ratios. Denominators are non-zero for Case 2.\n    r_nu = d_nu1 / d_nu2\n    r_i = d_i1 / d_i2\n    \n    # Round ratios and form the comparison list.\n    comparison_results = [round(r_nu, 5), round(r_i, 5)]\n\n    # --- Final Output Formatting ---\n    # Construct the final list containing all case results and the comparison.\n    final_list = all_case_results + [comparison_results]\n\n    # Convert each sublist to a string and remove spaces for compactness.\n    list_strs = [str(item).replace(\" \", \"\") for item in final_list]\n    \n    # Join the string representations of the lists with commas and enclose in brackets.\n    # The final element (comparison list) must be added after the case results.\n    # The f-string joins the first 5 elements and then appends the 6th.\n    case_strs = ','.join(list_strs[:-1])\n    comp_str = list_strs[-1]\n    final_output_string = f\"[{case_strs},{comp_str}]\"\n    \n    print(final_output_string)\n\nsolve()\n```", "id": "3698611"}, {"introduction": "除了泛函和基组这些核心理论选择之外，DFT 结果的可靠性还取决于控制计算精度的数值参数。这最后一个练习 [@problem_id:3698610] 将研究预测的光谱性质（如红外强度和核磁共振化学屏蔽）对数值积分格点密度和自洽场（SCF）收敛标准的敏感性。这将阐明在实际的 DFT 应用中，计算成本与数值精度之间的关键权衡。", "problem": "您需要实现一个完整的、可运行的程序，该程序模拟由密度泛函理论（DFT）预测的光谱性质相对于积分网格密度和自洽场（SCF）收敛阈值的数值敏感性。该程序必须对一个代表性的有机分子进行网格收斂性研究，并报告红外（IR）强度和核磁共振（NMR）屏蔽对这些数值设置的敏感性。程序必须使用一个纯粹的数学模型，该模型源自 Kohn–Sham DFT 的第一性原理以及对求积和迭代方法的数值分析，并且必须产生适合自动化测试的定量结果。\n\n从以下基础开始：\n\n- Kohn–Sham 密度泛函理论（DFT）定义了一个电子密度的能量泛函，而响应性质（例如，红外强度和核磁共振屏蔽）是作为该能量相对于外部扰动的基态或线性响应导数来计算的。对于红外光谱，模式 $k$ 的强度（表示为 $I_k$）与偶极矩 $\\mu$ 相对于简正模式坐标 $Q_k$ 的导数的平方成正比，即 $I_k \\propto \\left(\\partial \\mu / \\partial Q_k\\right)^2$。对于核磁共振，原子核 $j$ 的绝对屏蔽 $\\sigma_j$ 源于对外加磁场的诱导电子流密度响应，并可以通过能量相对于磁场分量的二阶导数来表示。\n- 在 DFT 中，交换相关贡献和相关性质积分的数值评估采用以原子为中心的求积网格；对于足够光滑的被积函数，主导积分误差与总网格点数 $M$ 的负幂成比例，即误差项与 $M^{-\\alpha}$ 成正比，其中指数 $\\alpha > 0$ 由求积的收敛阶数确定。\n- 自洽场（SCF）过程迭代地求解 Kohn–Sham 方程。一个有限的 SCF 收敛阈值 $\\tau$ 意味着存在一个残余电子密度误差 $\\delta \\rho$，在固定的预处理和阻尼条件下，其范数与 $\\tau$ 成正比，并导致计算性质中的线性误差传播，从而在典型条件下产生与 $\\tau^{\\beta}$ 成正比的误差项，其中 $\\beta \\approx 1$。\n\n基于上述基础，为一个具有三个红外活性简正模式和三个核磁共振活性原子核的代表性有机分子构建以下数学性质误差模型：\n- 设“真实”（渐近收敛）的红外强度为向量 $\\mathbf{I}^{\\mathrm{true}} = [220.0, 480.0, 35.0]$，单位为 $\\mathrm{km/mol}$，对应于三个不同的振动模式。\n- 设“真实”的核磁共振屏蔽为向量 $\\boldsymbol{\\sigma}^{\\mathrm{true}} = [31.5, 180.0, 85.0]$，单位为 $\\mathrm{ppm}$，对应于三个不同的原子核位点。\n- 对于给定的总网格点数 $M$ 和 SCF 阈值 $\\tau$，定义预测的红外强度\n$$\nI_k(M,\\tau) = I_k^{\\mathrm{true}} + a_{I,k} \\, M^{-\\alpha_I} + b_{I,k} \\, \\tau^{\\beta_I},\n$$\n和预测的核磁共振屏蔽\n$$\n\\sigma_j(M,\\tau) = \\sigma_j^{\\mathrm{true}} + a_{\\sigma,j} \\, M^{-\\alpha_\\sigma} + b_{\\sigma,j} \\, \\tau^{\\beta_\\sigma}.\n$$\n对该代表性分子使用以下固定的、依赖于模式/位点的常数：\n- 红外误差幅度 $\\mathbf{a}_I = [5.0 \\times 10^6, 6.0 \\times 10^6, 1.5 \\times 10^6]$ (单位与 $\\mathrm{km/mol}$ 一致),\n- 红外 SCF 敏感性系数 $\\mathbf{b}_I = [5000.0, 8000.0, 2000.0]$ (单位与 $\\mathrm{km/mol}$ 一致),\n- 红外指数 $\\alpha_I = 1.6$ 和 $\\beta_I = 1.0$,\n- 核磁共振误差幅度 $\\mathbf{a}_\\sigma = [5.0 \\times 10^6, 7.0 \\times 10^6, 4.0 \\times 10^6]$ (单位与 $\\mathrm{ppm}$ 一致),\n- 核磁共振 SCF 敏感性系数 $\\mathbf{b}_\\sigma = [300.0, 500.0, 400.0]$ (单位与 $\\mathrm{ppm}$ 一致),\n- 核磁共振指数 $\\alpha_\\sigma = 1.8$ 和 $\\beta_\\sigma = 1.0$。\n\n在 $M_{\\mathrm{ref}} = 1{,}000{,}000$ 和 $\\tau_{\\mathrm{ref}} = 1.0 \\times 10^{-12}$ 处定义一个高精度参考，并计算相应的参考红外强度 $\\mathbf{I}^{\\mathrm{ref}} = \\mathbf{I}(M_{\\mathrm{ref}},\\tau_{\\mathrm{ref}})$ 和参考核磁共振屏蔽 $\\boldsymbol{\\sigma}^{\\mathrm{ref}} = \\boldsymbol{\\sigma}(M_{\\mathrm{ref}},\\tau_{\\mathrm{ref}})$。\n\n对于每个测试对 $(M,\\tau)$，计算两个敏感性指标：\n1.  最大相对红外强度偏差（无单位，表示为小数），定义为\n$$\nS_{\\mathrm{IR}}(M,\\tau) = \\max_k \\left( \\frac{ \\left| I_k(M,\\tau) - I_k^{\\mathrm{ref}} \\right| }{ \\left| I_k^{\\mathrm{ref}} \\right| } \\right).\n$$\n2.  最大绝对核磁共振屏蔽偏差（单位为 $\\mathrm{ppm}$），定义为\n$$\nS_{\\mathrm{NMR}}(M,\\tau) = \\max_j \\left( \\left| \\sigma_j(M,\\tau) - \\sigma_j^{\\mathrm{ref}} \\right| \\right).\n$$\n\n物理单位：\n- 在相关处以 $\\mathrm{km/mol}$ 为单位报告红外强度；敏感性 $S_{\\mathrm{IR}}$ 是无单位的，必须表示为小数。\n- 以 $\\mathrm{ppm}$ 为单位报告核磁共振屏蔽；敏感性 $S_{\\mathrm{NMR}}$ 必须以 $\\mathrm{ppm}$ 为单位表示。\n\n角度单位在此不适用。不允许使用百分比；$S_{\\mathrm{IR}}$ 必须表示为小数。\n\n实现您的程序以评估以下 $(M,\\tau)$ 值的测试套件，这些值涵盖了理想路径、粗糙网格/宽松SCF、精细网格/紧凑SCF、超紧凑SCF 和非常粗糙网格的情况：\n- 测试用例 $1$：$M = 50000$, $\\tau = 1.0 \\times 10^{-6}$。\n- 测试用例 $2$：$M = 5000$, $\\tau = 1.0 \\times 10^{-4}$。\n- 测试用例 $3$：$M = 200000$, $\\tau = 1.0 \\times 10^{-8}$。\n- 测试用例 $4$：$M = 30000$, $\\tau = 1.0 \\times 10^{-10}$。\n- 测试用例 $5$：$M = 2000$, $\\tau = 1.0 \\times 10^{-8}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个双元素列表 $[S_{\\mathrm{IR}}, S_{\\mathrm{NMR}}]$。例如，$[[s_1^{\\mathrm{IR}},s_1^{\\mathrm{NMR}}],[s_2^{\\mathrm{IR}},s_2^{\\mathrm{NMR}}],\\dots]$。", "solution": "此问题在科学上是合理的，定义明确，并且在内部是一致的。它要求实现一个数学模型，该模型模拟了密度泛函理论（DFT）计算中预测的光谱性质（红外强度和核磁共振屏蔽）对两个关键数值参数——积分网格点数（M）和自洽场（SCF）收敛阈值（τ）——的敏感性。所有必要的方程、常数和模型参数都已提供，足以构建一个唯一的、可验证的解。\n\n解决方案的实施遵循一个直接的、分步的过程，该过程在提供的 Python 代码中实现。\n\n**1. 定义模型和常数**\n程序首先定义模型的所有参数。这包括“真实”的（即完全收敛的）红外强度向量 `I_true` 和核磁共振屏蔽向量 `sigma_true`。此外，还定义了与网格误差（`a_I`, `a_sigma`, `alpha_I`, `alpha_sigma`）和 SCF 收敛误差（`b_I`, `b_sigma`, `beta_I`, `beta_sigma`）相关的模式/位点特定的误差幅度和指数。\n\n**2. 计算高精度参考值**\n为了评估数值精度较低的计算所产生的偏差，我们首先需要一个“黄金标准”参考值。该参考值通过使用极高精度的数值参数（`M_ref = 1,000,000`，`tau_ref = 1.0e-12`）代入问题的数学误差模型来计算。\n预测的红外强度由下式给出：\n$$\nI_k(M,\\tau) = I_k^{\\mathrm{true}} + a_{I,k} \\, M^{-\\alpha_I} + b_{I,k} \\, \\tau^{\\beta_I}\n$$\n预测的核磁共振屏蔽由下式给出：\n$$\n\\sigma_j(M,\\tau) = \\sigma_j^{\\mathrm{true}} + a_{\\sigma,j} \\, M^{-\\alpha_\\sigma} + b_{\\sigma,j} \\, \\tau^{\\beta_\\sigma}\n$$\n将参考参数代入这些方程，我们得到参考强度向量 $\\mathbf{I}^{\\mathrm{ref}}$ 和参考屏蔽向量 $\\boldsymbol{\\sigma}^{\\mathrm{ref}}$。\n\n**3. 评估测试用例并计算敏感性指标**\n接下来，程序会迭代问题中指定的五个测试用例 `(M, τ)`。对于每个测试用例：\na. 使用与计算参考值相同的误差模型方程，计算预测的性质向量 $\\mathbf{I}(M,\\tau)$ 和 $\\boldsymbol{\\sigma}(M,\\tau)$。\nb. 然后，计算两个敏感性指标：\n   - **最大相对红外强度偏差 ($S_{\\mathrm{IR}}$)**：计算每个振动模式的相对偏差 `|I_k - I_k^ref| / |I_k^ref|`，然后取所有模式中的最大值。这量化了在给定数值设置下，红外强度预测值与高精度参考值之间的最坏情况下的相对误差。\n   $$\n   S_{\\mathrm{IR}}(M,\\tau) = \\max_k \\left( \\frac{ \\left| I_k(M,\\tau) - I_k^{\\mathrm{ref}} \\right| }{ \\left| I_k^{\\mathrm{ref}} \\right| } \\right)\n   $$\n   - **最大绝对核磁共振屏蔽偏差 ($S_{\\mathrm{NMR}}$)**：计算每个原子核的绝对偏差 `|σ_j - σ_j^ref|`，然后取所有原子核中的最大值。这量化了在相同设置下，核磁共振屏蔽预测值的最坏情况下的绝对误差，单位为 ppm。\n   $$\n   S_{\\mathrm{NMR}}(M,\\tau) = \\max_j \\left( \\left| \\sigma_j(M,\\tau) - \\sigma_j^{\\mathrm{ref}} \\right| \\right)\n   $$\n\n**4. 格式化输出**\n对于每个测试用例，计算出的两个敏感性指标 $[S_{\\mathrm{IR}}, S_{\\mathrm{NMR}}]$ 被收集到一个列表中。最后，所有测试用例的结果列表被组合成一个单一的、逗号分隔的列表，并用方括号括起来，以满足问题指定的输出格式。提供的 Python 代码精确地执行了此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Models the numerical sensitivity of DFT-predicted spectral properties\n    with respect to integration grid density and SCF convergence threshold.\n    \"\"\"\n\n    # Define the model parameters and constants from the problem statement.\n    # \"True\" (asymptotically converged) property values\n    I_true = np.array([220.0, 480.0, 35.0])\n    sigma_true = np.array([31.5, 180.0, 85.0])\n\n    # IR error model constants\n    a_I = np.array([5.0e6, 6.0e6, 1.5e6])\n    b_I = np.array([5000.0, 8000.0, 2000.0])\n    alpha_I = 1.6\n    beta_I = 1.0\n\n    # NMR error model constants\n    a_sigma = np.array([5.0e6, 7.0e6, 4.0e6])\n    b_sigma = np.array([300.0, 500.0, 400.0])\n    alpha_sigma = 1.8\n    beta_sigma = 1.0\n\n    # High-accuracy reference parameters\n    M_ref = 1_000_000\n    tau_ref = 1.0e-12\n\n    # Test suite of (M, tau) values\n    test_cases = [\n        (50000, 1.0e-6),  # Test case 1\n        (5000, 1.0e-4),   # Test case 2\n        (200000, 1.0e-8),  # Test case 3\n        (30000, 1.0e-10), # Test case 4\n        (2000, 1.0e-8),   # Test case 5\n    ]\n\n    def calculate_properties(M, tau):\n        \"\"\"\n        Calculates predicted IR intensities and NMR shieldings based on the error model.\n        \n        Args:\n            M (int): Total number of grid points.\n            tau (float): SCF convergence threshold.\n            \n        Returns:\n            tuple: A tuple containing the predicted IR intensities and NMR shieldings as numpy arrays.\n        \"\"\"\n        # Calculate grid and SCF error contributions\n        grid_error_I = a_I * (M ** (-alpha_I))\n        scf_error_I = b_I * (tau ** beta_I)\n        \n        grid_error_sigma = a_sigma * (M ** (-alpha_sigma))\n        scf_error_sigma = b_sigma * (tau ** beta_sigma)\n        \n        # Calculate predicted properties\n        I_predicted = I_true + grid_error_I + scf_error_I\n        sigma_predicted = sigma_true + grid_error_sigma + scf_error_sigma\n        \n        return I_predicted, sigma_predicted\n\n    # Step 1: Compute the reference properties\n    I_ref, sigma_ref = calculate_properties(M_ref, tau_ref)\n\n    # List to store the results for all test cases\n    results = []\n    \n    # Step 2: Loop through each test case\n    for M_test, tau_test in test_cases:\n        # Calculate predicted properties for the current test case\n        I_pred, sigma_pred = calculate_properties(M_test, tau_test)\n        \n        # Step 3: Calculate sensitivity metrics\n        \n        # S_IR: Maximum relative IR intensity deviation\n        # Absolute difference between predicted and reference IR intensities\n        abs_diff_I = np.abs(I_pred - I_ref)\n        # Relative difference, avoiding division by zero if I_ref_k is zero (not the case here)\n        rel_diff_I = abs_diff_I / np.abs(I_ref)\n        S_IR = np.max(rel_diff_I)\n        \n        # S_NMR: Maximum absolute NMR shielding deviation\n        # Absolute difference between predicted and reference NMR shieldings\n        abs_diff_sigma = np.abs(sigma_pred - sigma_ref)\n        S_NMR = np.max(abs_diff_sigma)\n        \n        results.append([S_IR, S_NMR])\n\n    # Step 4: Format the output string as specified\n    # Creates a list of strings like \"['[val1,val2]', '[val3,val4]']\"\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    # Joins them with a comma and encloses in brackets for the final format \"[[val1,val2],[val3,val4]]\"\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3698610"}]}