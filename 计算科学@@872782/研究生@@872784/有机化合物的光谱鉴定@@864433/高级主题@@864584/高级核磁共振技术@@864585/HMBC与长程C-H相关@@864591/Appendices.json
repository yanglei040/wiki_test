{"hands_on_practices": [{"introduction": "为了在HMBC实验中取得高质量的数据，对实验参数进行优化至关重要。本练习引导您深入探究HMBC脉冲序列中一个核心参数——演化延迟时间$\\tau$的优化。通过对相干演化和横向弛豫这两个相互竞争的物理过程进行数学建模，您将推导出最大化远程磁化转移效率的最佳延迟时间$\\tau^{\\star}$[@problem_id:3707084]。这项练习不仅能加深您对自旋动力学背后物理原理的理解，也为您在实际工作中设置和优化NMR实验提供了坚实的理论基础。", "problem": "在异核多键相关谱 (HMBC) 实验中，通过远程碳-氢标量耦合，在质子和碳核之间进行的有效磁化转移受标量耦合哈密顿量下的相干演化控制，并因横向弛豫而衰减。考虑一个大小为 $J_{LR}$ 的主要远程碳-氢标量耦合，以及演化中的异核相干的横向弛豫时间常数 $T_2$。假设单键碳-氢耦合被适当的滤波器元件抑制，因此转移受限于远程耦合和弛豫。\n\n从核磁共振中经过充分检验的事实出发：(i) 在大小为 $J$ 的标量耦合作用下，反相相干的建立与演化延迟 $\\tau$ 呈正弦依赖关系；(ii) 横向弛豫以时间常数 $T_2$ 指数地衰减横向磁化强度。请推导出一个解析表达式，用于描述使远程转移效率最大化的演化延迟 $\\tau^{\\star}$。然后，对于 $J_{LR} = 8.0 \\ \\mathrm{Hz}$ 和 $T_2 = 0.180 \\ \\mathrm{s}$，计算最佳延迟。将最终数值答案以毫秒表示，并四舍五入到 $4$ 位有效数字。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于核磁共振 (NMR) 波谱学的原理，特别是关于异核多键相关谱 (HMBC) 实验中异核相干的动力学。该问题是适定的、客观的，并包含推导唯一且有意义解所需的所有信息。\n\n目标是找到使磁化转移效率最大化的最佳演化延迟 $\\tau^{\\star}$。这个效率，我们记作 $\\eta(\\tau)$，由两个竞争过程决定：标量耦合下的反相磁化的相干演化和由于横向弛豫引起的非相干衰减。\n\n根据问题陈述中的事实 (i)，在标量耦合 $J_{LR}$ 作用下，持续时间为 $\\tau$ 时，从同相相干生成反相相干遵循正弦依赖关系。在乘积算符形式的背景下，这种依赖关系可以精确地由一个与 $\\sin(\\pi J_{LR} \\tau)$ 成正比的项来描述。当自变量是 $\\frac{\\pi}{2}$ 的奇数倍时，该项达到最大值，但这种理想情况会因弛豫而改变。\n\n根据事实 (ii)，信号同时因横向弛豫而衰减，这是一个时间常数为 $T_2$ 的指数衰减过程。这为转移效率的表达式引入了一个因子 $\\exp(-\\frac{\\tau}{T_2})$。\n\n结合这两种效应，在给定的演化时间 $\\tau$ 下，转移效率 $\\eta(\\tau)$ 可以被建模为与建立函数和衰减函数的乘积成正比。我们可以将此关系写为：\n$$\n\\eta(\\tau) = C \\sin(\\pi J_{LR} \\tau) \\exp\\left(-\\frac{\\tau}{T_2}\\right)\n$$\n其中 $C$ 是一个正常数，它依赖于旋磁比和初始极化等因素，但与 $\\tau$ 无关。我们感兴趣的是在 $\\tau  0$ 的情况下使 $\\eta(\\tau)$ 最大化的 $\\tau$ 值。\n\n为了找到函数 $\\eta(\\tau)$ 的最大值，我们必须计算它关于 $\\tau$ 的一阶导数并令其为零。\n$$\n\\frac{d\\eta}{d\\tau} = 0\n$$\n使用微分的乘法法则 $(uv)' = u'v + uv'$，其中 $u(\\tau) = \\sin(\\pi J_{LR} \\tau)$ 和 $v(\\tau) = \\exp(-\\frac{\\tau}{T_2})$，我们得到：\n$$\n\\frac{du}{d\\tau} = \\pi J_{LR} \\cos(\\pi J_{LR} \\tau)\n$$\n$$\n\\frac{dv}{d\\tau} = -\\frac{1}{T_2} \\exp\\left(-\\frac{\\tau}{T_2}\\right)\n$$\n$\\eta(\\tau)$ 的导数是：\n$$\n\\frac{d\\eta}{d\\tau} = C \\left[ \\left(\\pi J_{LR} \\cos(\\pi J_{LR} \\tau)\\right) \\exp\\left(-\\frac{\\tau}{T_2}\\right) + \\sin(\\pi J_{LR} \\tau) \\left(-\\frac{1}{T_2} \\exp\\left(-\\frac{\\tau}{T_2}\\right)\\right) \\right]\n$$\n将导数设为零：\n$$\nC \\exp\\left(-\\frac{\\tau}{T_2}\\right) \\left[ \\pi J_{LR} \\cos(\\pi J_{LR} \\tau) - \\frac{1}{T_2} \\sin(\\pi J_{LR} \\tau) \\right] = 0\n$$\n由于 $C  0$ 且对于有限的 $\\tau$，$\\exp(-\\frac{\\tau}{T_2})$ 永远不为零，因此方括号中的项必须为零，才会出现极值。\n$$\n\\pi J_{LR} \\cos(\\pi J_{LR} \\tau) - \\frac{1}{T_2} \\sin(\\pi J_{LR} \\tau) = 0\n$$\n重新整理这个方程得到：\n$$\n\\pi J_{LR} \\cos(\\pi J_{LR} \\tau) = \\frac{1}{T_2} \\sin(\\pi J_{LR} \\tau)\n$$\n两边同除以 $\\cos(\\pi J_{LR} \\tau)$（假设它不为零，这是有效的，因为如果它为零，右边将不为零，导致矛盾）得到：\n$$\n\\tan(\\pi J_{LR} \\tau) = \\pi J_{LR} T_2\n$$\n满足此方程的 $\\tau$ 值即为最佳延迟 $\\tau^{\\star}$。我们可以通过对两边取反正切来求解 $\\tau^{\\star}$。\n$$\n\\pi J_{LR} \\tau^{\\star} = \\arctan(\\pi J_{LR} T_2)\n$$\n反正切函数是多值的；其通解为 $\\arctan(x) + n\\pi$，其中 $n$ 为任意整数。然而，我们寻求的是使函数最大化的第一个正 $\\tau$ 值，这对应于反正切的主值（即 $n=0$），因为它将对应于阻尼正弦波的第一个峰值。\n因此，最佳延迟的解析表达式为：\n$$\n\\tau^{\\star} = \\frac{1}{\\pi J_{LR}} \\arctan(\\pi J_{LR} T_2)\n$$\n现在，我们代入给定的数值：$J_{LR} = 8.0 \\ \\mathrm{Hz}$ 和 $T_2 = 0.180 \\ \\mathrm{s}$。$J_{LR}$ 的单位是 $\\mathrm{s}^{-1}$。\n首先，我们计算反正切函数的无量纲自变量：\n$$\n\\pi J_{LR} T_2 = \\pi \\times (8.0 \\ \\mathrm{s}^{-1}) \\times (0.180 \\ \\mathrm{s}) \\approx 4.52389\n$$\n现在我们以秒为单位计算最佳延迟 $\\tau^{\\star}$：\n$$\n\\tau^{\\star} = \\frac{1}{\\pi \\times 8.0 \\ \\mathrm{s}^{-1}} \\arctan(4.52389)\n$$\n反正切的值必须以弧度为单位：\n$$\n\\arctan(4.52389) \\approx 1.35306 \\ \\mathrm{rad}\n$$\n将此值代回 $\\tau^{\\star}$ 的表达式中：\n$$\n\\tau^{\\star} \\approx \\frac{1.35306}{25.13274 \\ \\mathrm{s}^{-1}} \\approx 0.053835 \\ \\mathrm{s}\n$$\n题目要求答案以毫秒为单位，并四舍五入到 $4$ 位有效数字。\n$$\n\\tau^{\\star} \\approx 0.053835 \\ \\mathrm{s} \\times \\frac{1000 \\ \\mathrm{ms}}{1 \\ \\mathrm{s}} = 53.835 \\ \\mathrm{ms}\n$$\n四舍五入到 $4$ 位有效数字，我们得到：\n$$\n\\tau^{\\star} = 53.84 \\ \\mathrm{ms}\n$$", "answer": "$$\n\\boxed{53.84}\n$$", "id": "3707084"}, {"introduction": "解析HMBC谱图本质上是在分子骨架上解决一个连接性的难题，尤其对于复杂分子而言，这需要一种高度系统化的方法。本练习将HMBC谱图解析这一化学任务，转化为一个基于图论的算法决策过程[@problem_id:3707090]。您需要将关于HMBC相关性（如2键和3键相关、1键抑制、共轭效应增强等）的经验规则形式化，并编写一个程序来验证观测到的相关信号。这项实践将化学直觉与计算思维相结合，极大地锻炼了您处理复杂结构解析问题的逻辑能力，并让您一窥自动化结构解析软件背后的算法思想。", "problem": "您的任务是将异核多键相关 (Heteronuclear Multiple Bond Correlation, HMBC) 连通性形式化为一个图论决策过程，以便于算法实现。HMBC 通过化学键路径检测氢核与碳核之间的远程耦合。在图论形式化中，一个分子被表示为一个无向标记图，其中节点代表原子，边代表化学键。\n\n请从以下基本依据开始：\n- HMBC 主要检测通过 $2$ 或 $3$ 个化学键路径的质子-碳连通性，对于 $4$ 键路径，其可检测性显著降低，但可能因共轭效应而增强。直接的单键质子-碳连通性（$d=1$）已被 HMBC 脉冲序列设计排除。\n- 远程标量自旋-自旋耦合的强度根据经验随中间化学键数量的增加而减小，并可能受到路径上键级和共轭的调节。\n\n定义以下图模型：\n- 设 $G=(V,E)$ 是一个无向图。每个节点 $v \\in V$ 由集合 $\\{\\mathrm{C},\\mathrm{H}\\}$ 中的一种原子类型标记。定义子集 $C \\subset V$ 和 $H \\subset V$ 分别表示碳节点和氢节点。\n- 设 $B$ 是一个维度为 $|V| \\times |V|$ 的加权邻接矩阵，其元素 $b_{ij} \\in \\{0,1,2\\}$ 等于节点 $i$ 和 $j$ 之间的键级，若无键相连则 $b_{ij}=0$。相应的无权邻接矩阵 $A$ 中，如果 $b_{ij}0$，则 $a_{ij}=1$，否则 $a_{ij}=0$。\n- 从氢节点 $h \\in H$到碳节点 $c \\in C$ 的一条简单路径 $P$ 是一个由不同节点组成的有序序列 $(v_0=h,v_1,\\dots,v_d=c)$，使得对于 $k=0,\\dots,d-1$，都有 $a_{v_{k}v_{k+1}}=1$。路径的键长为 $d$，路径上的键级和为 $s(P)=\\sum_{k=0}^{d-1} b_{v_k v_{k+1}}$。\n\n为了构建一个与基本事实一致的决策规则，请对给定长度为 $d$ 且键级和为 $s(P)$ 的路径 $P$ 采用以下可检测性模型：\n- 表观交叉峰幅度被建模为 $A(d,s)=\\exp(-\\alpha d)\\,\\bigl(1+\\gamma\\,(s-d)\\bigr)$，其中 $\\alpha0$ 和 $\\gamma \\ge 0$ 是分别代表每键衰减和共轭增强效应的参数，$s$ 是路径的键级和。该模型捕捉了可检测性随 $d$ 增加而降低，以及对于总键级相对于步数更高的路径，其可检测性增强的特点。\n- 对 $A(d,s)$ 应用一个 HMBC 决策阈值 $\\tau0$。\n\n当且仅当存在一条从 $h$ 到 $c$ 的简单路径 $P$ 满足以下所有条件时，氢-碳对 $(h,c)$ 被接受为 HMBC 相关：\n1. $d \\in \\{2,3\\}$ 且 $A(d,s(P)) \\ge \\tau$，或 $d=4$，$s(P) \\ge d+1$ 且 $A(d,s(P)) \\ge \\tau$。\n2. 直接的单键情况 $d=1$ 被排除，无论 $A(d,s)$ 值如何。\n\n您必须实现一个程序，在每个测试案例中，根据上述规则评估所有观测到的氢-碳对。对于每一对，考虑所有长度为 $d \\in \\{2,3,4\\}$ 的简单路径；只要至少有一条路径满足条件，该对应关系即可接受。如果该对是直接成键的（$d=1$），则必须被拒绝。每个测试案例的结果是一个布尔值：如果所有观测对都被接受，则为 $\\,\\mathrm{True}\\,$，否则为 $\\,\\mathrm{False}\\,$。\n\n每个测试案例的输入表示如下：\n- 一个长度为 $n$ 的节点列表，以字符串 $\\mathrm{\"C\"}$ 或 $\\mathrm{\"H\"}$ 给出索引从 $0$ 到 $n-1$ 的原子类型。\n- 一个形状为 $n \\times n$ 的键级邻接矩阵 $B$，其元素为整数集合 $\\{0,1,2\\}$ 中的值，矩阵对称，对角线元素为零。\n- 一个观测对列表，形式为有序元组 $(c\\_\\mathrm{index}, h\\_\\mathrm{index})$，其中 $c\\_\\mathrm{index} \\in C$，$h\\_\\mathrm{index} \\in H$。\n- 标量 $\\alpha$、$\\gamma$ 和 $\\tau$。\n\n您的程序必须实现该决策规则并评估以下测试套件。索引为零基索引，所有化学键都是无向的：\n\n测试案例 1（顺利通过，边界在阈值相等处）：\n- 节点：$[\\,\\mathrm{H},\\mathrm{C},\\mathrm{C},\\mathrm{C},\\mathrm{H}\\,]$，对应索引 $[\\,0,1,2,3,4\\,]$。\n- 键（$b_{ij}=1$ 的位置）：$(0,1)$、$(1,2)$、$(2,3)$、$(3,4)$；所有其他 $b_{ij}=0$。\n- 观测对：$[(2,0),(3,0)]$。\n- 参数：$\\alpha=1$，$\\gamma=0$，$\\tau=0.049787$（约等于 $\\exp(-3)$）。\n- 预期：$(2,0)$ 有一条长度为 $d=2$ 的路径，其 $A(2,s)\\approx \\exp(-2)$；$(3,0)$ 有一条长度为 $d=3$ 的路径，其 $A(3,s)\\approx \\exp(-3)$；在相等时接受。\n\n测试案例 2（明确排除 HMBC 的单键情况）：\n- 节点：$[\\,\\mathrm{H},\\mathrm{C}\\,]$，对应索引 $[\\,0,1\\,]$。\n- 键：$(0,1)$，其中 $b_{01}=1$。\n- 观测对：$[(1,0)]$。\n- 参数：$\\alpha=1$，$\\gamma=0$，$\\tau=0.2$。\n- 预期：只存在一条 $d=1$ 的直接路径；拒绝。\n\n测试案例 3（接受四键共轭路径）：\n- 节点：$[\\,\\mathrm{H},\\mathrm{C},\\mathrm{C},\\mathrm{C},\\mathrm{C}\\,]$，对应索引 $[\\,0,1,2,3,4\\,]$，对应于 $(\\mathrm{H}_4,\\mathrm{C}_4,\\mathrm{C}_3,\\mathrm{C}_2,\\mathrm{C}_1)$。\n- 键：$(0,1)$ 的 $b=1$，$(1,2)$ 的 $b=2$，$(2,3)$ 的 $b=1$，$(3,4)$ 的 $b=2$；所有其他 $b_{ij}=0$。\n- 观测对：$[(4,0)]$。\n- 参数：$\\alpha=1$，$\\gamma=0.5$，$\\tau=0.03$。\n- 预期：存在一条路径，其 $d=4$ 且 $s=6$，得出 $A(4,6)=\\exp(-4)\\,\\bigl(1+0.5\\,(6-4)\\bigr)=\\exp(-4)\\cdot 2$，高于阈值；$s\\ge d+1$ 成立，因此接受。\n\n测试案例 4（拒绝四键非共轭路径）：\n- 节点：$[\\,\\mathrm{H},\\mathrm{C},\\mathrm{C},\\mathrm{C},\\mathrm{C}\\,]$，对应索引 $[\\,0,1,2,3,4\\,]$。\n- 键：$(0,1)$、$(1,2)$、$(2,3)$、$(3,4)$ 均有 $b=1$；所有其他 $b_{ij}=0$。\n- 观测对：$[(4,0)]$。\n- 参数：$\\alpha=1$，$\\gamma=0$，$\\tau=0.02$。\n- 预期：唯一的路径有 $d=4$ 和 $s=4$；$A(4,4)=\\exp(-4)$ 低于阈值，且 $s", "solution": "将异核多键相关（HMBC）连通性形式化为图论决策过程是一个有效的任务。它在科学上基于核磁共振波谱学原理，问题设定良好，目标明确，数据充分，并且被构建为一个可解的计算问题。所有提供的信息都是自洽和一致的，可以直接实现。\n\n解决方案涉及将 HMBC 波谱的化学原理转化为基于图论的计算模型。一个分子被表示为一个无向图 $G=(V,E)$，其中节点集 $V$ 代表原子，边集 $E$ 代表化学键。每个节点 $v \\in V$ 都被标记为碳（$\\mathrm{C}$）或氢（$\\mathrm{H}$）。化学键由其键级（单键、双键）进行加权，这体现在一个加权邻接矩阵 $B$ 中，其中元素 $b_{ij}$ 可以是 $0$、$1$ 或 $2$。\n\n问题的核心是，对于一组“观测到”的质子-碳对 $(h, c)$，判断它们的观测结果是否与所提供的 HMBC 可检测性模型一致。对于给定的分子结构和观测对集合，当且仅当集合中的每一对都通过模型验证时，结果为 $\\mathrm{True}$。\n\n如果图上对应的节点之间至少存在一条简单路径 $P$ 满足一组基于其长度 $d$（键数）和总键级和 $s(P) = \\sum_{k=0}^{d-1} b_{v_k v_{k+1}}$ 的条件，则该对 $(h, c)$ 被视为“已接受”。简单路径是指不重复任何节点的路径。\n\n验证单个对 $(h,c)$ 的算法如下：\n1.  在分子图中搜索质子 $h$ 节点和碳 $c$ 节点之间的所有简单路径。\n2.  鉴于 HMBC 的约束，我们只对长度为 $d \\in \\{2, 3, 4\\}$ 的路径感兴趣。长度为 $d=1$ 的路径对应于直接的单键连通性，这种连通性被 HMBC 实验明确抑制，因此不被考虑为接受的原因。\n3.  递归的深度优先搜索（DFS）算法是寻找这些路径的有效方法。搜索从节点 $h$ 开始，探索邻居节点，逐步构建路径。为确保路径是简单的，需要维护一个已访问节点的集合。对于长度超过 $d=4$ 的路径进行剪枝。\n4.  对于找到的每一条从 $h$ 到 $c$ 的简单路径 $P$，我们根据决策规则对其进行评估：\n    -   计算路径长度 $d$ 和键级和 $s(P)$。\n    -   计算建模的交叉峰幅度 $A(d,s)=\\exp(-\\alpha d)\\,\\bigl(1+\\gamma\\,(s-d)\\bigr)$，其中 $\\alpha$、$\\gamma$ 是给定的参数。\n    -   应用接受标准：\n        -   如果 $d \\in \\{2,3\\}$ 且 $A(d,s(P)) \\ge \\tau$，则路径有效，该对 $(h,c)$ 被接受。\n        -   如果 $d=4$，则仅当路径是共轭体系的一部分（由 $s(P) \\ge d+1$ 作为代理）且其幅度高于阈值（$A(d,s(P)) \\ge \\tau$）时，路径才有效。\n5.  如果从 $h$ 到 $c$ 的任何一条路径满足这些标准，该对即被接受。对此对的搜索可以终止。如果搜索完成仍未找到此类路径，则该对被拒绝。\n\n整个程序的结构是遍历每个测试案例。对于每个案例，它会遍历所有指定的 `observed_pairs`。如果任何一对被拒绝，该测试案例的结果即为 $\\mathrm{False}$。如果所有对都被接受，结果则为 $\\mathrm{True}$。最终输出是这些布尔结果的列表。整个过程是确定性的，并直接实现了问题陈述中描述的形式化模型。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the HMBC decision rule problem.\n    \"\"\"\n\n    def check_paths_recursive(\n        current_node, target_node, bond_order_matrix, alpha, gamma, tau, \n        path, visited, current_bond_sum\n    ):\n        \"\"\"\n        Recursively explores simple paths from current_node to target_node using DFS,\n        and checks if any path satisfies the HMBC acceptance criteria.\n        \"\"\"\n        # Base case: Path reaches the target node\n        if current_node == target_node:\n            d = len(path) - 1\n            s = current_bond_sum\n\n            # Rule exclusion: d=1 paths are not considered for acceptance.\n            # Only paths with d in {2, 3, 4} are evaluated.\n            if d not in [2, 3, 4]:\n                return False\n\n            # Calculate amplitude\n            amplitude = np.exp(-alpha * d) * (1 + gamma * (s - d))\n\n            # Apply acceptance rules based on path length d\n            if d in [2, 3]:\n                if amplitude = tau:\n                    return True  # Accepted\n            elif d == 4:\n                # 4-bond paths have an extra condition on bond-order sum\n                if s = d + 1 and amplitude = tau:\n                    return True  # Accepted\n            \n            return False # This path did not lead to acceptance\n\n        # Pruning: Stop if path length exceeds maximum relevant distance (d=4)\n        if len(path) - 1 = 4:\n            return False\n\n        # Recursive step: Explore neighbors\n        num_nodes = bond_order_matrix.shape[0]\n        for neighbor in range(num_nodes):\n            # Check for a bond and ensure the path remains simple (no cycles)\n            if bond_order_matrix[current_node, neighbor]  0 and neighbor not in visited:\n                path.append(neighbor)\n                visited.add(neighbor)\n                new_bond_sum = current_bond_sum + bond_order_matrix[current_node, neighbor]\n\n                if check_paths_recursive(\n                    neighbor, target_node, bond_order_matrix, alpha, gamma, tau,\n                    path, visited, new_bond_sum\n                ):\n                    return True  # An acceptable path was found down this branch\n\n                # Backtrack\n                visited.remove(neighbor)\n                path.pop()\n        \n        return False # No acceptable path found from this node\n\n    def is_pair_accepted(h_idx, c_idx, B, alpha, gamma, tau):\n        \"\"\"\n        Checks if an observed (h, c) pair is accepted by finding at least one valid path.\n        \"\"\"\n        path = [h_idx]\n        visited = {h_idx}\n        return check_paths_recursive(\n            h_idx, c_idx, B, alpha, gamma, tau, \n            path, visited, 0\n        )\n\n    def evaluate_test_case(nodes, B, observed_pairs, alpha, gamma, tau):\n        \"\"\"\n        Evaluates a full test case. Returns True if all observed pairs are accepted.\n        \"\"\"\n        for c_idx, h_idx in observed_pairs:\n            if not is_pair_accepted(h_idx, c_idx, B, alpha, gamma, tau):\n                return False  # If any pair is rejected, the whole case fails\n        return True # All pairs were accepted\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"nodes\": ['H', 'C', 'C', 'C', 'H'],\n            \"B\": np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 1, 0, 0],\n                [0, 1, 0, 1, 0],\n                [0, 0, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ]),\n            \"observed_pairs\": [(2, 0), (3, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.0,\n            \"tau\": 0.049787\n        },\n        {\n            \"nodes\": ['H', 'C'],\n            \"B\": np.array([\n                [0, 1],\n                [1, 0]\n            ]),\n            \"observed_pairs\": [(1, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.0,\n            \"tau\": 0.2\n        },\n        {\n            \"nodes\": ['H', 'C', 'C', 'C', 'C'],\n            \"B\": np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 2, 0, 0],\n                [0, 2, 0, 1, 0],\n                [0, 0, 1, 0, 2],\n                [0, 0, 0, 2, 0]\n            ]),\n            \"observed_pairs\": [(4, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.5,\n            \"tau\": 0.03\n        },\n        {\n            \"nodes\": ['H', 'C', 'C', 'C', 'C'],\n            \"B\": np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 1, 0, 0],\n                [0, 1, 0, 1, 0],\n                [0, 0, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ]),\n            \"observed_pairs\": [(4, 0)],\n            \"alpha\": 1.0,\n            \"gamma\": 0.0,\n            \"tau\": 0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = evaluate_test_case(\n            case[\"nodes\"], case[\"B\"], case[\"observed_pairs\"],\n            case[\"alpha\"], case[\"gamma\"], case[\"tau\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3707090"}]}