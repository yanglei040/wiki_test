{"hands_on_practices": [{"introduction": "在基因组学中，$k$-mer 计数是一项基本任务，但数据集的大小常常超过计算机的内存容量。这项练习将向您展示一种强大的分治策略，通过划分*问题空间*（所有可能的 $k$-mer）而非数据本身来处理海量数据。通过实现该算法，您将学会如何在严格的内存限制下设计算法，这是处理生物信息学大数据时一项至关重要的技能 [@problem_id:2386106]。", "problem": "给定一个脱氧核糖核酸（DNA）字符串的多重集，这些字符串由字母表 $\\Sigma=\\{\\text{A,C,G,T}\\}$ 中的字符构成。对于一个整数 $k \\ge 1$，一个 $k$-mer 是指任意一个长度为 $k$、仅由 $\\Sigma$ 中字符组成的连续子串。包含任何不在 $\\Sigma$ 中字符的子串不被视为有效的 $k$-mer，必须被忽略。对于一个 DNA 字符串集合，设 $\\mathcal{K}_k$ 表示在该集合中至少一个字符串里出现过的所有有效 $k$-mer 的集合。您的任务是在模拟随机存取存储器（RAM）的严格内存预算下，精确计算 $|\\mathcal{K}_k|$。内存预算被形式化如下：在任何时刻，您的程序不允许同时在内存中持有超过 $B$ 个不同的 $k$-mer 键。您可以假设 $B \\ge 1$ 是一个整数。\n\n设计并实现一个程序，给定几组参数集 $(\\text{sequences}, k, B)$，为每组参数返回 $|\\mathcal{K}_k|$ 的精确值，同时确保在任何时候，您方法中的任何数据结构都不会同时存储超过 $B$ 个不同的 $k$-mer。全部输入可能大于可用 RAM；因此，您的方法必须通过构建计算过程来确保在不超出并发存储的不同键的既定约束下获得最终的精确结果。输入序列应被视为只读字符串；不要假设有任何专门的预处理索引可用。\n\n在您的程序中使用以下参数值测试套件。在下面的每个项目中，都给出了值 $k$ 和预算 $B$，后面是 DNA 字符串列表。在所有情况下，忽略包含 $\\Sigma$ 之外字符的子串。\n\n- 测试用例 1：$k=3$, $B=2$, 序列 = [\"ACGTACGT\",\"TACG\"]。\n- 测试用例 2：$k=2$, $B=4$, 序列 = [\"AAAAAA\"]。\n- 测试用例 3：$k=2$, $B=1$, 序列 = [\"NNNNN\",\"ACNGT\",\"ACGTTN\"]。\n- 测试用例 4：$k=4$, $B=1$, 序列 = [\"ATATATATAT\",\"TATATATATA\"]。\n- 测试用例 5：$k=1$, $B=1$, 序列 = [\"ACGTACGT\",\"GGGG\",\"TTTT\",\"CCCC\",\"AAAA\"]。\n- 测试用例 6：$k=3$, $B=2$, 序列 = [\"AC\",\"G\"]。\n\n您的程序必须为每个测试用例计算整数 $|\\mathcal{K}_k|$，其中 $\\mathcal{K}_k$ 的定义如上。要求的最终输出格式是一行，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与上面列出的测试用例相同，例如 \"[x1,x2,x3,x4,x5,x6]\"，其中每个 $x_i$ 是测试用例 $i$ 的 $|\\mathcal{K}_k|$ 的整数值。", "solution": "问题陈述经过严格验证。\n\n**步骤 1：提取已知信息**\n-   **字母表**：$\\Sigma=\\{\\text{A,C,G,T}\\}$\n-   **$k$-mer**：一个长度为 $k \\ge 1$ 的连续子串，仅由 $\\Sigma$ 中的字符组成。\n-   **无效子串**：包含不在 $\\Sigma$ 中字符的子串将被忽略。\n-   **输入**：一个字符串多重集，表示为 `sequences`。\n-   **输入参数 $k$**：一个整数，即 $k$-mer 的长度，其中 $k \\ge 1$。\n-   **输入参数 $B$**：一个整数，即内存预算，表示可并发存储的不同 $k$-mer 键的最大数量。给定 $B \\ge 1$。\n-   **目标**：计算 $|\\mathcal{K}_k|$，即输入 `sequences` 中存在的所有唯一的、有效的 $k$-mer 集合 $\\mathcal{K}_k$ 的基数。\n-   **约束**：算法在任何给定时间内存中存储的不同 $k$-mer 不得超过 $B$ 个。\n-   **测试用例**：\n    -   测试用例 1：$k=3$, $B=2$, 序列 = [\"ACGTACGT\",\"TACG\"]。\n    -   测试用例 2：$k=2$, $B=4$, 序列 = [\"AAAAAA\"]。\n    -   测试用例 3：$k=2$, $B=1$, 序列 = [\"NNNNN\",\"ACNGT\",\"ACGTTN\"]。\n    -   测试用例 4：$k=4$, $B=1$, 序列 = [\"ATATATATAT\",\"TATATATATA\"]。\n    -   测试用例 5：$k=1$, $B=1$, 序列 = [\"ACGTACGT\",\"GGGG\",\"TTTT\",\"CCCC\",\"AAAA\"]。\n    -   测试用例 6：$k=3$, $B=2$, 序列 = [\"AC\",\"G\"]。\n\n**步骤 2：使用提取的已知信息进行验证**\n-   **科学依据**：该问题在计算生物学和生物信息学中有坚实的基础。$k$-mer 计数是基因组组装、序列比对和宏基因组学分析等应用的一项基本任务。使用字母表 $\\Sigma=\\{\\text{A,C,G,T}\\}$ 以及忽略非标准字符（如 'N'）的概念是标准惯例。该问题是流式算法中“不同元素问题”的一个变体，应用于特定内存模型下的生物信息学。它在科学上和计算上都是合理的。\n-   **适定性**：该问题是适定的。目标是计算一个唯一定义的集合 $\\mathcal{K}_k$ 的基数。输入和约束都已明确指定。对于任何有效的输入集，都存在一个唯一的整数解。\n-   **客观性**：该问题使用精确、客观和形式化的数学语言进行陈述。它没有歧义、主观性或基于意见的主张。\n\n**步骤 3：结论与行动**\n该问题是 **有效的**。这是一个标准的、定义明确的计算问题，具有清晰的约束和目标。继续进行求解。\n\n**基于原则的解决方案**\n\n这个问题的核心挑战是严格的内存预算 $B$，这使得朴素的方法不可行。一个直接的解决方案，例如遍历所有序列，提取所有 $k$-mer，并将它们插入一个单一的哈希集合中，如果不同的 $k$-mer 总数 $|\\mathcal{K}_k|$ 超过 $B$，这种方法就会失败。因此，该问题要求一种能够在数据量大于可用内存的情况下运行的算法，通常称为“外存”或“核外”算法。\n\n解决此类问题的指导原则是 **分治**。然而，我们不能对输入数据（序列）进行分区，因为它们是只读的，所以我们必须对问题空间本身进行分区。问题空间是字母表 $\\Sigma$ 上所有可能的 $4^k$ 个 $k$-mer 的集合。通过将这个空间划分为不相交的子集，我们可以独立地计算每个子集内不同的 $k$-mer 的数量，然后将结果相加。分区的不相交性质确保了没有 $k$-mer 被重复计数。\n\n这里最有效的分区策略是基于前缀对 $k$-mer 空间进行递归分区。我们定义一个函数 $\\text{Count}(\\rho)$，它计算输入序列中以给定前缀 $\\rho$ 开头的不同 $k$-mer 的数量。那么，不同 $k$-mer 的总数就是 $\\text{Count}(\\text{\"\"})$，其中 $\\text{\"\"}$ 是空前缀。\n\n该算法被构建为一个递归函数，试图在内存预算 $B$ 内解决 $\\text{Count}(\\rho)$ 问题。\n\n1. **尝试计数**：为了计算 $\\text{Count}(\\rho)$，我们遍历所有输入序列。对于找到的每个有效 $k$-mer，我们检查它是否以前缀 $\\rho$ 开头。如果是，我们将其添加到一个内存中的集合，称之为 $S_{\\rho}$。\n\n2. **内存预算检查**：在此过程中，我们持续监控集合的大小 $|S_{\\rho}|$。\n    - 如果整个数据集被处理完毕且 $|S_{\\rho}|$ 从未超过 $B$，我们就成功地对该分区中的不同 $k$-mer 进行了计数。函数返回 $|S_{\\rho}|$。这构成了我们递归的基线条件。\n    - 如果在任何时候 $|S_{\\rho}|$ 变得大于 $B$，这意味着由前缀 $\\rho$ 定义的分区太大，无法在内存限制内处理。我们必须“溢出”，在此上下文中，这意味着放弃当前计数并细分问题。\n\n3. **递归细分（分治步骤）**：一旦发生“溢出”，我们将对应于前缀 $\\rho$ 的分区根据下一个字符细分为四个更小的、不相交的分区。四个新前缀将是 $\\rho+\\text{'A'}$、$\\rho+\\text{'C'}$、$\\rho+\\text{'G'}$ 和 $\\rho+\\text{'T'}$。前缀 $\\rho$ 的总计数就是这些更小分区的计数之和。这可以递归地表示为：\n$$ \\text{Count}(\\rho) = \\text{Count}(\\rho+\\text{'A'}) + \\text{Count}(\\rho+\\text{'C'}) + \\text{Count}(\\rho+\\text{'G'}) + \\text{Count}(\\rho+\\text{'T'}) $$\n这个递归调用有效地启动了对数据的新遍历，每次遍历都集中于一个更具体的 $k$-mer 子集。\n\n4. **终止**：递归保证会终止。随着前缀长度的增加，对应的 $k$-mer 空间分区会变小。在极限情况下，前缀长度变为 $k$。对于长度为 $k$ 的前缀的分区，最多只能包含一个唯一的 $k$-mer（即前缀本身）。由于预算 $B \\ge 1$，对于由长度为 $k$ 的前缀定义的分区，不可能发生溢出。因此，递归深度最多为 $k$，并且总能达到基线条件（在预算内成功计数）。\n\n这种基于前缀的递归分治策略，在计算的每个阶段都严格遵守内存约束，从而正确计算出不同 $k$-mer 的精确数量。遵守内存限制的代价是计算时间的增加，因为可能需要多次扫描输入序列。\n\n在处理之前，必须处理任何不在 $\\Sigma = \\{\\text{A, C, G, T}\\}$ 中的字符。一个稳健的方法是把它们当作分隔符，将每个输入序列分割成一组仅由有效字符组成的连续子串。然后，$k$-mer 的提取逻辑仅应用于这些有效的子串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the k-mer counting problem for the predefined test suite.\n    \"\"\"\n    \n    test_cases = [\n        # (sequences, k, B)\n        ([\"ACGTACGT\", \"TACG\"], 3, 2),\n        ([\"AAAAAA\"], 2, 4),\n        ([\"NNNNN\", \"ACNGT\", \"ACGTTN\"], 2, 1),\n        ([\"ATATATATAT\", \"TATATATATA\"], 4, 1),\n        ([\"ACGTACGT\", \"GGGG\", \"TTTT\", \"CCCC\", \"AAAA\"], 1, 1),\n        ([\"AC\", \"G\"], 3, 2),\n    ]\n\n    results = []\n    for sequences, k, B in test_cases:\n        result = count_distinct_kmers(sequences, k, B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef count_distinct_kmers(sequences, k, B):\n    \"\"\"\n    Main entry point for the k-mer counting algorithm. It initializes\n    the recursive counting process.\n\n    Args:\n        sequences (list[str]): The list of DNA sequences.\n        k (int): The length of the k-mer.\n        B (int): The memory budget (max number of distinct k-mers).\n\n    Returns:\n        int: The total count of distinct k-mers.\n    \"\"\"\n    if k == 0:\n        return 0\n\n    valid_chars = {'A', 'C', 'G', 'T'}\n    \n    # Pre-process sequences to handle invalid characters like 'N'.\n    # This creates a list of substrings containing only valid DNA characters.\n    valid_substrings = []\n    for seq in sequences:\n        current_sub = []\n        for char in seq:\n            if char in valid_chars:\n                current_sub.append(char)\n            else:\n                if current_sub:\n                    valid_substrings.append(\"\".join(current_sub))\n                    current_sub = []\n        if current_sub:\n            valid_substrings.append(\"\".join(current_sub))\n\n    return _count_recursive(valid_substrings, k, B, \"\", np.array(list(valid_chars)))\n\ndef _count_recursive(valid_substrings, k, B, prefix, alphabet):\n    \"\"\"\n    Recursively counts distinct k-mers using a divide-and-conquer approach.\n\n    Args:\n        valid_substrings (list[str]): A list of DNA segments with no invalid characters.\n        k (int): The k-mer length.\n        B (int): The memory budget.\n        prefix (str): The current prefix defining the k-mer partition to count.\n        alphabet (np.ndarray): The characters of the DNA alphabet.\n\n    Returns:\n        int: The count of distinct k-mers for the given partition.\n    \"\"\"\n    kmers_in_partition = set()\n    has_spilled = False\n\n    for sub_seq in valid_substrings:\n        if len(sub_seq)  k:\n            continue\n        for i in range(len(sub_seq) - k + 1):\n            # Potential k-mer\n            kmer = sub_seq[i:i+k]\n            if kmer.startswith(prefix):\n                kmers_in_partition.add(kmer)\n                if len(kmers_in_partition) > B:\n                    has_spilled = True\n                    break  # from inner loop\n        if has_spilled:\n            break  # from outer loop\n    \n    if has_spilled:\n        # Memory budget exceeded. Subdivide the problem and recurse.\n        # This logical branch should not be reachable if len(prefix) == k\n        # because the set would contain at most 1 element, and B >= 1.\n        # The check is an assertion of this logic.\n        if len(prefix) >= k:\n             # This indicates a logical error or an invalid state (e.g., B=0).\n             # Given problem constraints B>=1, this is unreachable.\n             return 1\n             \n        sub_count = 0\n        for char in alphabet:\n            new_prefix = prefix + char\n            sub_count += _count_recursive(valid_substrings, k, B, new_prefix, alphabet)\n        return sub_count\n    else:\n        # Base case: Succeeded in counting k-mers for this partition within the budget.\n        return len(kmers_in_partition)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2386106"}, {"introduction": "反向互补回文序列是 DNA 中重要的生物学基序，在染色体规模的数据中高效地寻找它们是一项常见的计算任务。本练习将分治思想以二分搜索的形式应用，从而在任意给定位置快速确定最长的可能回文序列。您将把分治策略与字符串哈希技术相结合，开发出一个高效的算法，从而锻炼您在算法优化和数据结构应用方面的能力 [@problem_id:2386095]。", "problem": "您的任务是设计并实现一个分治（DC）算法，来寻找脱氧核糖核酸（DNA）染色体中的所有反向互补回文子串。一个DNA染色体将被建模为一个由字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 构成的有限字符串。使用标准的碱基配对规则：$\\text{A}$ 与 $\\text{T}$ 配对，$\\text{C}$ 与 $\\text{G}$ 配对。对于任意DNA字符串 $s$，通过逐字符应用这些配对规则来定义其互补串 $\\operatorname{comp}(s)$，并通过反转 $\\operatorname{comp}(s)$ 来定义其反向互补串 $\\operatorname{rc}(s)$。如果一个字符串 $w$ 满足 $w=\\operatorname{rc}(w)$，则它是一个反向互补回文串。对于索引，使用基于 $0$ 的索引。对于子串 $s[i:j]$（包含 $i$ 但不包含 $j$），其长度为 $j-i$。\n\n从字符串子串和DNA互补规则的基本定义出发，并利用二分搜索是每步将搜索区间减半的经典分治策略这一公认事实，设计一个算法，该算法：\n- 在固定编码下，预处理染色体以实现常数时间的子串相等性查询。\n- 对每个可能的回文中心，使用分治策略（对半径进行二分搜索）来找到最大半径，使得对应的子串等于其反向互补串。\n- 枚举所有长度至少为 $k$ 的反向互补回文子串。\n\n该算法必须纯粹以数学和逻辑术语来构建，并且可用任何现代编程语言实现。不涉及任何生物湿实验步骤。所有答案都是无单位的。您必须将所有满足标准的子串以 $[i,\\ell]$ 对的形式输出，其中 $i$ 是起始索引，$\\ell$ 是长度， $i$ 采用基于 $0$ 的索引。对于每个染色体，按 $i$ 的升序对这些配对进行排序，如果 $i$ 相等，则按 $\\ell$ 排序。由于在标准的DNA碱基配对规则下，没有核苷酸是自身的互补，因此只可能存在偶数长度的反向互补回文串；您的方法应该通过回文性测试从第一性原理发现这一点，而不是依赖于硬编码的特例。\n\n您必须将该算法实现为一个单一、完整、可运行的程序，为以下测试套件生成结果。对于每个案例，计算所有长度至少为 $k$ 的反向互补回文子串：\n\n- 测试用例 1：染色体 $s=\\text{\"ATCGAT\"}$，$k=4$。\n- 测试用例 2：染色体 $s=\\text{\"AAAAAA\"}$，$k=3$。\n- 测试用例 3：染色体 $s=\\text{\"CGAATTCG\"}$，$k=4$。\n- 测试用例 4：染色体 $s=\\text{\"AT\"}$，$k=2$。\n- 测试用例 5：染色体 $s=\\text{\"ATAT\"}$，$k=2$。\n\n最终输出格式：您的程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个元素对应一个测试用例，其本身就是一个 $[i,\\ell]$ 对的列表。例如，通用结构为 $[[[i_1,\\ell_1],[i_2,\\ell_2],\\dots],[],\\dots]$。输出行中不得有任何空格。", "solution": "该问题要求设计并实现一个分治算法，以识别给定脱氧核糖核酸（DNA）序列中所有满足最小长度约束的反向互补回文子串。该问题定义明确，其科学基础根植于分子生物学和计算字符串分析的原理，并包含了获得唯一解所需的所有必要信息。\n\n首先，我们对定义进行形式化。一个DNA序列 $s$ 是一个由字母表 $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 构成的字符串。互补规则定义了一个函数 $c: \\Sigma \\to \\Sigma$，其中 $c(\\text{A})=\\text{T}$，$c(\\text{T})=\\text{A}$，$c(\\text{C})=\\text{G}$，以及 $c(\\text{G})=\\text{C}$。对于一个字符串 $s = s_0s_1\\dots s_{n-1}$，其互补串是 $\\operatorname{comp}(s) = c(s_0)c(s_1)\\dots c(s_{n-1})$，其反向串是 $\\operatorname{rev}(s) = s_{n-1}\\dots s_1s_0$。反向互补串定义为 $\\operatorname{rc}(s) = \\operatorname{rev}(\\operatorname{comp}(s))$。如果一个子串 $w$ 满足条件 $w = \\operatorname{rc}(w)$，则它是一个反向互补回文串。我们的任务是找到给定染色体 $s$ 中所有这样的子串 $w$，其中 $w$ 的长度（表示为 $|w|$）至少为给定的整数 $k$。\n\n一个关键的观察，按要求从第一性原理推导，关系到这类回文串可能的长度。一个奇数长度的回文串 $w$（比如 $|w| = 2r+1$，对于某个整数 $r \\ge 0$）有一个中心字符 $w_r$。回文条件 $w = \\operatorname{rc}(w)$ 意味着对于所有 $i \\in \\{0, \\dots, 2r\\}$ 都有 $w_i = c(w_{2r-i})$。对于位于 $i=r$ 的中心字符，这给出 $w_r = c(w_r)$。然而，对于标准的DNA碱基，没有碱基是自身的互补：对于任何 $x \\in \\Sigma$ 都有 $c(x) \\neq x$。因此，没有字符能满足中心条件，所以不存在奇数长度的反向互补回文串。所有这类回文串的长度必须是偶数，即 $|w| = 2r$，其中 $r \\ge 1$。\n\n一个偶数长度的回文串的中心位于两个字符之间。对于一个长度为 $N$ 的字符串 $s$，偶数长度回文串有 $N-1$ 个可能的中心，位于索引 $i-1$ 和 $i$ 之间，其中 $i \\in \\{1, \\dots, N-1\\}$。对于一个给定的中心 $i$，一个半径为 $r \\ge 1$ 的回文串是子串 $s[i-r : i+r]$，其长度为 $2r$。该子串成为反向互补回文串的条件是，对于所有 $k' \\in \\{1, \\dots, r\\}$，都有 $s[i-k'] = c(s[i+k'-1])$。\n\n该指定算法的核心是一种分治策略。对于每个潜在的中心，我们必须找到使回文性质成立的最大半径 $R_{max}$。该中心的所有有效回文串就是那些半径 $r \\in \\{1, \\dots, R_{max}\\}$ 的回文串。回文的性质是单调的：如果它对半径 $r$ 成立，那么它对任何更小的半径 $r'  r$ 也必然成立。这种结构允许使用二分搜索——一种经典的分治技术——来高效地找到 $R_{max}$。对于一个中心 $i$，半径 $r$ 的搜索空间是区间 $[0, \\min(i, N-i)]$。\n\n为了高效地执行二分搜索，每次对回文性质的检查都必须在常数时间 $O(1)$ 内完成。对于半径 $r$，朴素的逐字符比较将花费 $O(r)$ 时间，导致总体复杂度为 $O(N^2)$。问题要求通过预处理来实现 $O(1)$ 的子串相等性查询。多项式滚动哈希是实现此目的的标准方法。在中心 $i$ 处，半径为 $r$ 的回文条件 $s[i-k'] = c(s[i+k'-1])$（其中 $k'=1, \\dots, r$）等价于字符串相等性 $s[i-r : i] = \\operatorname{rev}(\\operatorname{comp}(s[i : i+r]))$。\n\n为了使用哈希实现此检查，我们预先计算两个字符串的哈希值：原始字符串 $s$ 及其完整的反向互补串 $s_{rc} = \\operatorname{rc}(s)$。设 $|s| = N$。子串 $s[i-r:i]$ 是 $s$ 的一个简单子串。子串 $\\operatorname{rev}(\\operatorname{comp}(s[i : i+r]))$ 等价于 $s_{rc}$ 的一个特定子串。$s[i:i+r]$ 的反向互补串对应于 $s_{rc}$ 中从索引 $N-(i+r)$ 开始、长度为 $r$ 的子串，即 $s_{rc}[N-i-r : N-i]$。因此，对于中心 $i$ 和半径 $r$ 的回文检查简化为比较 $s[i-r : i]$ 的哈希值与 $s_{rc}[N-i-r : N-i]$ 的哈希值。通过对 $s$ 和 $s_{rc}$ 的前缀哈希进行预计算，此比较耗时 $O(1)$。为了最小化哈希冲突，采用了使用两个独立的（基数、模数）对的双哈希方案。\n\n完整的算法流程如下：\n1.  **预处理（$O(N)$ 时间）**：\n    a. 给定长度为 $N$ 的输入字符串 $s$。\n    b. 构建其反向互补串 $s_{rc}$。\n    c. 对于 $s$ 和 $s_{rc}$，使用两个不同的（基数、模数）对，预先计算两组前缀哈希值和基数的幂。\n\n2.  **回文搜索（$O(N \\log N)$ 时间）**：\n    a. 初始化一个空列表 `results`，用于存储找到的回文串。\n    b. 遍历每个潜在的中心 $i \\in \\{1, \\dots, N-1\\}$。\n    c. 对每个中心 $i$，确定最大可能半径 $r_{lim} = \\min(i, N-i)$。\n    d. 对半径 $r \\in [1, r_{lim}]$ 进行二分搜索，以找到使得 $s[i-r:i]$ 和 $\\operatorname{rev}(\\operatorname{comp}(s[i:i+r]))$ 相等的最大半径 $R_{max}$。此检查通过比较 $s[i-r:i]$ 和 $s_{rc}[N-i-r:N-i]$ 的双哈希值在 $O(1)$ 时间内完成。\n    e. 找到 $R_{max}$ 后，以 $i$ 为中心、半径从 $1$ 到 $R_{max}$ 的所有子串都是反向互补回文串。它们的长度为 $2, 4, \\dots, 2R_{max}$。\n\n3.  **结果枚举与格式化**：\n    a. 对于每个中心 $i$ 及其找到的 $R_{max}$，遍历半径 $r$ 从 $\\lceil k/2 \\rceil$ 到 $R_{max}$。对于每个这样的 $r$，就找到了一个有效的回文串。其长度为 $\\ell = 2r$，起始索引为 $j = i-r$。将对 $[j, \\ell]$ 添加到 `results` 列表中。\n    b. 遍历所有中心后，按起始索引 $j$ 的升序对 `results` 列表进行排序，若 $j$ 相等，则按长度 $\\ell$ 排序。\n    c. 按指定格式化最终输出。\n\n该算法的总时间复杂度由搜索步骤主导，为 $O(N \\log N)$。空间复杂度为 $O(N)$，用于存储字符串及其哈希表。此方法符合问题陈述的所有要求。", "answer": "```python\nimport numpy as np\n\n# No scipy is used in this solution.\n\nclass DualStringHasher:\n    \"\"\"\n    Computes and provides rolling hashes for a string using two different\n    (base, modulus) pairs to minimize collisions.\n    \"\"\"\n    def __init__(self, s: str):\n        self.n = len(s)\n        self.p1, self.m1 = 31, 10**9 + 7\n        self.p2, self.m2 = 37, 10**9 + 9\n        \n        char_map = {'A': 1, 'C': 2, 'G': 3, 'T': 4}\n        # Using .get with a default value handles potential invalid characters\n        s_int = [char_map.get(c, 0) for c in s]\n\n        self.powers1 = [1] * (self.n + 1)\n        self.hashes1 = [0] * (self.n + 1)\n        self.powers2 = [1] * (self.n + 1)\n        self.hashes2 = [0] * (self.n + 1)\n\n        for i in range(self.n):\n            self.powers1[i+1] = (self.powers1[i] * self.p1) % self.m1\n            self.hashes1[i+1] = (self.hashes1[i] * self.p1 + s_int[i]) % self.m1\n            self.powers2[i+1] = (self.powers2[i] * self.p2) % self.m2\n            self.hashes2[i+1] = (self.hashes2[i] * self.p2 + s_int[i]) % self.m2\n\n    def get_hash_pair(self, i: int, j: int) -> tuple[int, int]:\n        \"\"\"\n        Returns the hash pair for the substring s[i:j].\n        \"\"\"\n        length = j - i\n        if length = 0:\n            return (0, 0)\n        h1 = (self.hashes1[j] - (self.hashes1[i] * self.powers1[length]) % self.m1 + self.m1) % self.m1\n        h2 = (self.hashes2[j] - (self.hashes2[i] * self.powers2[length]) % self.m2 + self.m2) % self.m2\n        return (h1, h2)\n\ndef find_palindromes(s: str, k: int) -> list[list[int]]:\n    \"\"\"\n    Finds all reverse-complement palindromic substrings of length at least k.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return []\n\n    comp_map = str.maketrans(\"ACGT\", \"TGCA\")\n    s_comp = s.translate(comp_map)\n    s_rc = s_comp[::-1]\n\n    hasher_s = DualStringHasher(s)\n    hasher_rc = DualStringHasher(s_rc)\n    \n    results = []\n\n    # Iterate through all possible centers for even-length palindromes.\n    # Center is between index i-1 and i.\n    for i in range(1, n):\n        # Binary search for the maximum radius r.\n        low, high = 0, min(i, n - i)\n        max_r = 0\n        \n        while low = high:\n            r = (low + high) // 2\n            if r == 0:\n                low = r + 1\n                continue\n\n            # Substring s[i-r:i]\n            hash1 = hasher_s.get_hash_pair(i - r, i)\n            # The reverse complement of s[i:i+r] is found in s_rc\n            # at index n-(i+r) with length r => s_rc[n-i-r : n-i]\n            hash2 = hasher_rc.get_hash_pair(n - i - r, n - i)\n\n            if hash1 == hash2:\n                max_r = r\n                low = r + 1\n            else:\n                high = r - 1\n        \n        # Collect all valid palindromes for this center\n        if max_r > 0:\n            # We need length 2r >= k, so r >= k/2\n            min_r_for_k = (k + 1) // 2\n            for r in range(min_r_for_k, max_r + 1):\n                start_index = i - r\n                length = 2 * r\n                results.append([start_index, length])\n    \n    # Sort results by start index, then by length\n    results.sort()\n    \n    return results\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the provided test suite.\n    \"\"\"\n    test_cases = [\n        (\"ATCGAT\", 4),\n        (\"AAAAAA\", 3),\n        (\"CGAATTCG\", 4),\n        (\"AT\", 2),\n        (\"ATAT\", 2),\n    ]\n\n    all_results = []\n    for s, k in test_cases:\n        case_result = find_palindromes(s, k)\n        all_results.append(case_result)\n\n    # Format the output string exactly as required, with no spaces.\n    # str(all_results) would introduce spaces, so we build it manually.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2386095"}, {"introduction": "设计一套最优的聚合酶链式反应（PCR）引物来覆盖整个基因组，是分子生物学中一个复杂的现实世界设计任务。这个高级问题挑战您将分治思想应用于一个多阶段优化问题，而这类问题通常通过动态规划——一种与分治密切相关的技术——来最优雅地解决。解决这个问题将加深您对如何将复杂生物学问题建模为最短路径问题的理解，并体会分治法与动态规划之间的深刻联系 [@problem_id:2386122]。", "problem": "给定一个环状脱氧核糖核酸（DNA）质粒，您可以在位置 $0$ 将其线性化，以获得一个长度为 $N$ 的线性序列 $S$，其字母表为 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$。您需要设计一个分治算法，选择一系列聚合酶链式反应（PCR）扩增子，以覆盖从位置 $0$ 到位置 $N-1$ 的整个线性化序列，并在符合生物学动机的引物有效性约束下，实现最小的总重叠。\n\n引物是长度固定为 $k_p$（单位：核苷酸）的连续子序列。如果 $k_p$-mer $S[p:p+k_p]$ 满足以下所有条件，则位置 $p$ 是一个有效的引物起始位点：\n1. 鸟嘌呤/胞嘧啶（GC）含量，定义为 $(\\#\\text{G}+\\#\\text{C})/k_p$，位于闭区间 $[g_{\\min}, g_{\\max}]$ 内。\n2. 根据 Wallace 法则计算的解链温度 $T_m$，定义为 $T_m = 2(\\#\\text{A}+\\#\\text{T}) + 4(\\#\\text{G}+\\#\\text{C})$，位于闭区间 $[t_{\\min}, t_{\\max}]$ 内（单位：摄氏度；所有内部温度均以摄氏度表示）。\n3. 该 $k_p$-mer 中的最大同聚物运行长度（即相同连续核苷酸的最大数量）最多为 $h_{\\max}$。\n\n我们定义两组有效的引物起始位点：有效正向引物起始位点集合 $F$ 和有效反向引物起始位点集合 $R$。在本计算模型中，对 $R$ 的有效性检查使用与 $F$ 相同的序列 $S$ 和相同的标准，这在科学上是合理的，因为 GC 含量、同聚物运行长度和基于 Wallace 法则的解链温度在反向互补操作下是不变的。\n\n一个扩增子由一对 $(a,b)$ 定义，其中 $a \\in F$，$b \\in R$，且 $a  b$，它跨越的索引范围为 $[a, b + k_p - 1]$（包含两端）。其长度（单位：核苷酸）为 $L = (b + k_p) - a$。只允许长度 $L$ 位于闭区间 $[A_{\\min}, A_{\\max}]$ 内的扩增子。\n\n一个扩增子的覆盖集是一个有序列表 $((a_1,b_1), \\dots, (a_m,b_m))$，满足：\n- $a_1 = 0$ 且 $b_m = N - k_p$，\n- 对于每个 $i \\in \\{1, \\dots, m-1\\}$，下一个扩增子的起始位置不晚于当前扩增子的结束位置，即 $a_{i+1} \\le b_i + k_p$，并且严格前进，即 $a_{i+1} \\ge a_i + 1$（无停滞），\n- 每个 $L_i = (b_i + k_p) - a_i$ 均位于 $[A_{\\min}, A_{\\max}]$ 内。\n\n连续扩增子 $i$ 和 $i+1$ 之间的重叠定义为 $\\max\\{0, (b_i + k_p) - a_{i+1}\\}$。目标是最小化总重叠，即所有连续扩增子对的重叠之和。\n\n您的任务是实现一个分治算法，该算法在给定 $S$ 和相关参数的情况下，计算出一个能实现最小总重叠的扩增子覆盖集，并输出正向引物起始位点列表 $(a_1, a_2, \\dots, a_m)$。如果存在多个最优解，则返回字典序最小的正向引物起始位点列表。如果不存在有效的覆盖集，则返回空列表。\n\n程序必须是独立完整的，仅依赖于给定的参数和下方的测试序列。所有内部温度计算必须以摄氏度为单位；输出中不需要其他物理单位或角度。最终输出是整数列表（正向引物起始位点），每个测试用例对应一个列表。\n\n测试套件：\n- 用例 1：\n  - $S =$ 将 $\\text{ATGC}$ 重复恰好 $30$ 次形成的字符串，因此 $N = 120$。\n  - $k_p = 8$。\n  - $g_{\\min} = 0.5$, $g_{\\max} = 0.5$。\n  - $t_{\\min} = 24$, $t_{\\max} = 24$。\n  - $h_{\\max} = 3$。\n  - $A_{\\min} = 40$, $A_{\\max} = 40$。\n- 用例 2：\n  - $S =$ 将 $\\text{ATGC}$ 重复 $15$ 次，然后是 $\\text{AAAAAA}$，再将 $\\text{ATGC}$ 重复 $5$ 次所串联成的字符串。这得到 $N = 86$。\n  - $k_p = 8$。\n  - $g_{\\min} = 0.5$, $g_{\\max} = 0.5$。\n  - $t_{\\min} = 24$, $t_{\\max} = 24$。\n  - $h_{\\max} = 2$。\n  - $A_{\\min} = 28$, $A_{\\max} = 32$。\n- 用例 3：\n  - $S =$ 将 $\\text{A}$ 重复 $26$ 次形成的字符串，因此 $N = 26$。\n  - $k_p = 8$。\n  - $g_{\\min} = 0.5$, $g_{\\max} = 0.6$。\n  - $t_{\\min} = 20$, $t_{\\max} = 40$。\n  - $h_{\\max} = 2$。\n  - $A_{\\min} = 24$, $A_{\\max} = 30$。\n\n最终输出格式：\n您的程序应生成单行文本，其中包含所有用例的结果，格式为用方括号括起来的逗号分隔列表。每个用例的结果本身也是一个用方括号括起来的整数列表（可能为空）。例如，一个有效的格式是 `[[0,40,80],[0,29,58],[]]`。\n\n您的程序必须计算并以上述确切的单行格式输出测试套件中三个用例的最优正向引物起始位点列表。不应打印任何其他文本。", "solution": "用户提出了一个计算生物学问题，要求设计一个分治算法来寻找一个最优的 PCR 扩增子集，以覆盖一个线性 DNA 序列。最优性由最小化连续扩增子之间的总重叠来定义，同时受一系列生化和物理约束的限制。\n\n在继续之前，需要对问题陈述进行关键的验证。\n\n### 步骤 1：提取给定信息\n- **序列：** 一个长度为 $N$ 的线性 DNA 序列 $S$，字母表为 $\\{\\text{A, C, G, T}\\}$。\n- **引物长度：** 一个固定的整数 $k_p$。\n- **引物有效性约束：** 从位置 $p$ 开始的引物（即 $k_p$-mer $S[p:p+k_p]$）若有效，必须满足：\n    1.  其鸟嘌呤-胞嘧啶（GC）含量在 $[g_{\\min}, g_{\\max}]$ 范围内。\n    2.  其解链温度 $T_m = 2(\\#\\text{A}+\\#\\text{T}) + 4(\\#\\text{G}+\\#\\text{C})$ 在 $[t_{\\min}, t_{\\max}]$ 范围内。\n    3.  其最大同聚物运行长度最多为 $h_{\\max}$。\n- **引物集：** $F$（正向引物起始位点）和 $R$（反向引物起始位点）是引物有效的位置 $p$ 的集合。问题陈述表明，对两者应用相同的标准，这对于给定的指标在科学上是合理的。\n- **扩增子定义：** 一个扩增子是一对 $(a, b)$，其中 $a \\in F$, $b \\in R$, $a  b$。它跨越的索引范围是 $[a, b+k_p-1]$。其长度 $L = (b+k_p)-a$ 必须在 $[A_{\\min}, A_{\\max}]$ 范围内。\n- **覆盖集：** 一个有序的扩增子列表 $((a_1, b_1), \\dots, (a_m, b_m))$ 必须满足：\n    1.  $a_1 = 0$ 且 $b_m = N-k_p$。\n    2.  连续的扩增子必须连接并前进：$a_{i+1} \\in [a_i+1, b_i+k_p]$。\n- **目标：** 最小化总重叠，定义为 $\\sum_{i=1}^{m-1} \\max\\{0, (b_i+k_p) - a_{i+1}\\}$。\n- **输出：** 正向引物起始位点列表 $(a_1, \\dots, a_m)$。\n- **平局打破规则：** 如果多个解具有相同的最小重叠，则返回字典序最小的正向引物起始位点列表。\n- **无解情况：** 如果不存在有效的覆盖，则返回一个空列表。\n- **算法约束：** 算法必须是“分治”策略。\n\n### 步骤 2：使用提取的给定信息进行验证\n1.  **科学依据：** 该问题在分子生物学概念上有充分的依据。PCR、引物、扩增子、GC 含量、解链温度（通过 Wallace 法则）和同聚物约束是引物设计的基础。该模型是一个简化，但对于一个计算问题来说，在科学上是合理的。\n2.  **良态性与完备性：** 该问题在数学上是明确定义的。它指定了输入、所有约束、一个明确的目标函数，以及用于平局打破和无解情况的规则。这是一个经典的优化问题，可以建模为在有向无环图（DAG）上寻找最短路径。\n3.  **算法约束分析：** 问题要求使用“分治”（DC）策略。然而，像这样寻找一个最小化成本总和的最优路径的问题，通常使用动态规划（DP）来解决。标准的分治算法依赖于解决不重叠的子问题，但这在这里并不自然适用，因为子问题（例如，覆盖序列的一个片段）的最优解依赖于其边界上的状态，这打破了子问题的独立性。然而，动态规划可以看作是分治法的一种扩展，它使用记忆化或制表法来处理重叠的子问题。一个 DP 解的递归、记忆化实现直接遵循了分治结构。因此，将该指令解释为允许使用动态规划解法是合理且正确的。我们将继续采用 DP 解法，这符合“分治”指令的精神。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它有科学依据，定义明确，并且提供了所有必要的信息。我们将采用基于动态规划的解决方案。\n\n### 解决方案设计\n该问题可以建模为在 DAG 中寻找最短路径。图的节点是有效的正向引物起始位点。如果一个始于 $u$ 的有效扩增子可以覆盖到或超过 $v$ 的序列，从而允许一个新的扩增子在 $v$ 处开始，则存在一条从节点 $u$ 到节点 $v$ 的边。边的权重是重叠部分。\n\n**1. 预计算有效引物位点**\n首先，我们识别出所有可以作为有效引物起始位点的 $p \\in [0, N-k_p]$。我们定义一个函数 `is_valid_primer`，用于检查给定 $k_p$-mer 的 GC 含量、解链温度和同聚物运行约束。我们遍历 $S$ 中所有可能的起始位置，并构建一个这些有效位点的排序列表，我们称之为 $P_{\\text{valid}}$。如果 $0 \\notin P_{\\text{valid}}$ 或 $N-k_p \\notin P_{\\text{valid}}$，则不可能有解。\n\n**2. 动态规划公式**\n我们将使用动态规划来寻找总重叠最小的路径。令 $C[v]$ 为用一个扩增子链覆盖序列所需的最小总重叠，其中最后一个正向引物始于 $v \\in P_{\\text{valid}}$。令 $\\Pi[v]$ 存储相应的正向引物起始位点列表 $(a_1, \\dots, a_k=v)$。\n\n- **初始化：**\n  对于起始位置为 $a_1=0$ 的引物：\n  - $C[0] = 0$\n  - $\\Pi[0] = [0]$\n  对于所有其他 $v \\in P_{\\text{valid}}$，$v>0$：\n  - $C[v] = \\infty$\n  - $\\Pi[v] = []$\n\n- **递推：**\n  我们按升序遍历有效引物位点 $u \\in P_{\\text{valid}}$。对于每个我们已找到有效路径的 $u$（即 $C[u]  \\infty$），我们探索所有可能的下一个正向引物 $v \\in P_{\\text{valid}}$，其中 $v > u$。\n  对于每一对 $(u, v)$，我们必须计算转换的最小可能重叠。这需要选择一个反向引物 $b \\in P_{\\text{valid}}$ 来形成一个扩增子 $(u, b)$，使得：\n  1. 扩增子有效：其长度 $L=(b+k_p)-u$ 在 $[A_{\\min}, A_{\\max}]$ 范围内。\n  2. 下一个引物起始位点 $v$ 可达：$u  v \\le b+k_p$。\n  为了最小化从 $u$ 到 $v$ 的转换重叠，即 $(b+k_p)-v$，我们必须选择满足所有约束的最小有效 $b$。\n  \n  对于从 $u$ 到 $v$ 的转换，对 $b$ 的约束是：\n  - $b \\in P_{\\text{valid}}$\n  - $b > u$\n  - 来自扩增子长度：$u+A_{\\min}-k_p \\le b \\le u+A_{\\max}-k_p$\n  - 来自 $v$ 的可达性：$b \\ge v-k_p$\n\n  令 $b^*$ 为 $P_{\\text{valid}}$ 中满足这些条件的最小值。如果存在这样的 $b^*$，则重叠为 $\\text{cost}(u,v) = (b^*+k_p) - v$。通过 $u$ 到达 $v$ 的总成本为 $C_{\\text{new}} = C[u] + \\text{cost}(u,v)$，新路径为 $\\Pi_{\\text{new}} = \\Pi[u] + [v]$。\n\n- **带平局打破规则的更新步骤：**\n  如果新路径更优，我们更新 $v$ 的条目。如果路径成本更低，或者成本相同但字典序更小，则路径更优。\n  如果 $(C_{\\text{new}}  C[v])$ 或 $(C_{\\text{new}} == C[v]$ 且 $\\Pi_{\\text{new}}  \\Pi[v])$:\n  $C[v] = C_{\\text{new}}$\n  $\\Pi[v] = \\Pi_{\\text{new}}$\n\n**3. 最终解的重构**\n在计算完所有可达节点的成本和路径后，我们必须识别出完整的路径。一个有效的覆盖必须以一个扩增子 $(a_m, b_m)$ 结束，其中 $b_m = N-k_p$。最后一个正向引物 $a_m$ 必须满足：\n1. $a_m \\in P_{\\text{valid}}$\n2. 扩增子 $(a_m, N-k_p)$ 有效。其长度必须在 $[A_{\\min}, A_{\\max}]$ 范围内，这意味着 $N-A_{\\max} \\le a_m \\le N-A_{\\min}$。\n\n我们找到所有这样有效的最终位置 $a_m$，这些位置存在路径（$C[a_m]  \\infty$）。在这些候选项中，我们选择对应于最小总重叠 $C[a_m]$ 的那一个。如果成本出现平局，我们选择其路径 $\\Pi[a_m]$ 字典序最小的候选项。如果无法到达任何这样的有效最终位置，则不存在解。\n\n这种 DP 方法系统地探索了所有有效的扩增子链，并保证能根据指定的标准找到最优解。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"S\": \"ATGC\" * 30, \"k_p\": 8, \"g_min\": 0.5, \"g_max\": 0.5,\n            \"t_min\": 24, \"t_max\": 24, \"h_max\": 3, \"A_min\": 40, \"A_max\": 40\n        },\n        # Case 2\n        {\n            \"S\": \"ATGC\" * 15 + \"AAAAAA\" + \"ATGC\" * 5, \"k_p\": 8, \"g_min\": 0.5, \"g_max\": 0.5,\n            \"t_min\": 24, \"t_max\": 24, \"h_max\": 2, \"A_min\": 28, \"A_max\": 32\n        },\n        # Case 3\n        {\n            \"S\": \"A\" * 26, \"k_p\": 8, \"g_min\": 0.5, \"g_max\": 0.6,\n            \"t_min\": 20, \"t_max\": 40, \"h_max\": 2, \"A_min\": 24, \"A_max\": 30\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = find_optimal_covering(**params)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[0,40,80],[0,28,56],[]]\n    result_strs = []\n    for res in results:\n        result_strs.append('[' + ','.join(map(str, res)) + ']')\n    \n    print(f\"[{','.join(result_strs)}]\")\n\ndef get_homopolymer_run(seq):\n    \"\"\"Calculates the maximum length of a homopolymer run in a sequence.\"\"\"\n    if not seq:\n        return 0\n    max_run = 0\n    current_run = 0\n    current_char = ''\n    for char in seq:\n        if char == current_char:\n            current_run += 1\n        else:\n            max_run = max(max_run, current_run)\n            current_char = char\n            current_run = 1\n    max_run = max(max_run, current_run)\n    return max_run\n\ndef is_valid_primer(subsequence, k_p, g_min, g_max, t_min, t_max, h_max):\n    \"\"\"Checks if a given k-mer subsequence is a valid primer.\"\"\"\n    gc_count = subsequence.count('G') + subsequence.count('C')\n    gc_frac = gc_count / k_p\n    if not (g_min = gc_frac = g_max):\n        return False\n    \n    at_count = k_p - gc_count\n    tm = 2 * at_count + 4 * gc_count\n    if not (t_min = tm = t_max):\n        return False\n        \n    hp_run = get_homopolymer_run(subsequence)\n    if hp_run > h_max:\n        return False\n        \n    return True\n\ndef find_optimal_covering(S, k_p, g_min, g_max, t_min, t_max, h_max, A_min, A_max):\n    \"\"\"\n    Implements the dynamic programming algorithm to find the optimal amplicon covering.\n    \"\"\"\n    N = len(S)\n    \n    # Step 1: Pre-compute valid primer sites\n    valid_sites_list = []\n    for p in range(N - k_p + 1):\n        sub = S[p : p + k_p]\n        if is_valid_primer(sub, k_p, g_min, g_max, t_min, t_max, h_max):\n            valid_sites_list.append(p)\n    \n    valid_sites = np.array(valid_sites_list)\n    valid_sites_set = set(valid_sites_list)\n    \n    # Check if start and end conditions are even possible\n    if 0 not in valid_sites_set or (N - k_p) not in valid_sites_set:\n        return []\n\n    # Step 2: Dynamic Programming\n    costs = {p: float('inf') for p in valid_sites_list}\n    paths = {p: [] for p in valid_sites_list}\n    \n    costs[0] = 0\n    paths[0] = [0]\n    \n    # Main DP loop\n    for u in valid_sites_list:\n        if costs[u] == float('inf'):\n            continue\n            \n        # Iterate over all possible next forward primers v\n        v_start_idx = np.searchsorted(valid_sites, u, side='right')\n        for v in valid_sites[v_start_idx:]:\n            # Calculate minimum overlap for transition u -> v\n            # Find the best reverse primer b*\n            b_min_req = max(u + 1, u + A_min - k_p, v - k_p)\n            b_max_req = u + A_max - k_p\n            \n            # Find smallest b in valid_sites within [b_min_req, b_max_req]\n            b_start_idx = np.searchsorted(valid_sites, b_min_req, side='left')\n            \n            if b_start_idx  len(valid_sites):\n                b_star = valid_sites[b_start_idx]\n                if b_star = b_max_req:\n                    overlap = (b_star + k_p) - v\n                    new_cost = costs[u] + overlap\n                    new_path = paths[u] + [v]\n                    \n                    # Update DP table if a better path is found (cost or lexicographical)\n                    if new_cost  costs[v] or (new_cost == costs[v] and new_path  paths[v]):\n                        costs[v] = new_cost\n                        paths[v] = new_path\n\n    # Step 3: Reconstruct final solution\n    best_final_path = []\n    min_final_cost = float('inf')\n    \n    # Find all valid candidates for the last forward primer a_m\n    b_m = N - k_p\n    a_m_min = N - A_max\n    a_m_max = N - A_min\n    \n    final_candidates = []\n    for a_m in valid_sites_list:\n        if a_m_min = a_m = a_m_max and a_m  b_m and costs[a_m] != float('inf'):\n            final_candidates.append(a_m)\n\n    if not final_candidates:\n        return []\n\n    # Find the minimum cost among all valid final paths\n    for a_m in final_candidates:\n        min_final_cost = min(min_final_cost, costs[a_m])\n\n    if min_final_cost == float('inf'):\n        return []\n    \n    # Among all paths with minimum cost, find the lexicographically smallest one\n    best_paths_for_min_cost = []\n    for a_m in final_candidates:\n        if costs[a_m] == min_final_cost:\n            best_paths_for_min_cost.append(paths[a_m])\n\n    return min(best_paths_for_min_cost)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2386122"}]}