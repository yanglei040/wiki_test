{"hands_on_practices": [{"introduction": "在生物信息学中，分析生物网络或其它标度现象时，拟合幂律模型是一项常见任务。本练习将指导你分析一个包含对数转换和线性回归的典型数据分析流程的计算成本。通过这个实践，你将学会如何将一个复杂问题分解为多个顺序执行的步骤，并加总它们的复杂度，这是算法分析中的一项基本技能。[@problem_id:2372946]", "problem": "在计算物理学中，标度律的分析通常通过将形式为 $y = C x^{\\alpha}$ 的幂律模型与实验或模拟数据进行拟合来完成。一种常见的方法是对数进行线性回归：定义 $z_i = \\ln(x_i)$ 和 $w_i = \\ln(y_i)$（其中 $i = 1, 2, \\dots, N$），并使用普通最小二乘法拟合线性模型 $w_i \\approx \\beta_0 + \\beta_1 z_i$。假设存在以下实际的计算模型：每次浮点加法、减法、乘法、除法，以及每次自然对数 $\\,\\ln(\\cdot)\\,$ 和指数函数 $\\,\\exp(\\cdot)\\,$ 的求值，都具有与 $N$ 无关的常数时间成本；输入数据已在内存中；线性回归的求解器是一种标准的数值稳定方法，该方法或者计算充分统计量并求解一个 $2 \\times 2$ 系统，或者对一个 $N \\times 2$ 的设计矩阵执行 Householder-QR 分解，其中 $2$ 与 $N$ 无关。请仅使用基本定义，不借助任何现成的复杂度结论，推导执行此幂律拟合（包括对数变换和线性回归求解）的渐进时间复杂度，并将其表示为 $N$ 的函数。将您的最终答案表示为关于 $N$ 的单个大O表达式。最终表达式中不需要数值舍入，也不需要物理单位。", "solution": "问题陈述经过严格验证，被认为是有效的。这是一个数值分析和计算物理学中的适定问题，具有科学依据，并以客观、精确的语言表述。所有进行严谨推导所需的信息均已提供。\n\n我们的目标是推导将幂律模型 $y = C x^{\\alpha}$ 拟合到数据集 $\\{(x_i, y_i)\\}_{i=1}^N$ 的渐进时间复杂度，并将其表示为数据点数量 $N$ 的函数。指定的流程包括两个相继的阶段：对数数据变换，然后是使用普通最小二乘法（OLS）求解的线性回归。我们将分别分析每个阶段的计算成本，然后将它们相加以求得总复杂度。\n\n**阶段1：对数数据变换**\n\n通过对等式两边取自然对数，幂律关系 $y = C x^{\\alpha}$ 被线性化，得到一个线性方程：\n$$ \\ln(y) = \\ln(C x^{\\alpha}) = \\ln(C) + \\alpha \\ln(x) $$\n此变换应用于 $N$ 个数据点中的每一个。对于每个点 $(x_i, y_i)$，我们计算一个新点 $(z_i, w_i)$，定义如下：\n$$ z_i = \\ln(x_i) $$\n$$ w_i = \\ln(y_i) $$\n需要拟合的最终线性模型是 $w_i \\approx \\beta_0 + \\beta_1 z_i$，其中参数对应于 $\\beta_0 = \\ln(C)$ 和 $\\beta_1 = \\alpha$。\n\n根据问题的计算模型，自然对数函数 $\\ln(\\cdot)$ 的求值具有常数时间成本。设此成本为 $c_{log}$。对于 $N$ 个数据点中的每一个，我们执行两次这样的求值。因此，变换阶段所需的总时间 $T_{transform}$ 为：\n$$ T_{transform}(N) = \\sum_{i=1}^{N} (c_{log} + c_{log}) = N \\cdot (2 c_{log}) $$\n在渐进复杂度方面，这是关于 $N$ 线性的。\n$$ T_{transform}(N) = O(N) $$\n\n**阶段2：普通最小二乘线性回归**\n\n变换之后，我们必须确定线性模型 $w_i \\approx \\beta_0 + \\beta_1 z_i$ 的参数 $\\beta_0$ 和 $\\beta_1$。OLS 通过最小化残差平方和 $S(\\beta_0, \\beta_1)$ 来实现这一目标：\n$$ S(\\beta_0, \\beta_1) = \\sum_{i=1}^{N} (w_i - (\\beta_0 + \\beta_1 z_i))^2 $$\n问题陈述指出使用了一种标准的数值稳定方法，并给出了两个例子：通过充分统计量求解正规方程组，或使用 Householder-QR 分解。我们分析这两种方法以确认它们的复杂度。\n\n**方法A：求解正规方程组**\n对 $S$ 的最小化会得到一个被称为正规方程组的 $2 \\times 2$ 线性方程组：\n$$ \\begin{pmatrix} N  \\sum_{i=1}^{N} z_i \\\\ \\sum_{i=1}^{N} z_i  \\sum_{i=1}^{N} z_i^2 \\end{pmatrix} \\begin{pmatrix} \\beta_0 \\\\ \\beta_1 \\end{pmatrix} = \\begin{pmatrix} \\sum_{i=1}^{N} w_i \\\\ \\sum_{i=1}^{N} z_i w_i \\end{pmatrix} $$\n为了建立这个系统，我们必须首先计算所需的四个总和（充分统计量）。每个总和都是对 $N$ 个变换后的数据点计算的。\n- $\\sum_{i=1}^{N} z_i$：需要 $N-1$ 次加法，即 $O(N)$。\n- $\\sum_{i=1}^{N} w_i$：需要 $N-1$ 次加法，即 $O(N)$。\n- $\\sum_{i=1}^{N} z_i^2$：需要 $N$ 次乘法和 $N-1$ 次加法，即 $O(N)$。\n- $\\sum_{i=1}^{N} z_i w_i$：需要 $N$ 次乘法和 $N-1$ 次加法，即 $O(N)$。\n\n这些总和都可以在对数据的一次遍历中计算出来，每个数据点需要常数次的算术运算。因此，计算矩阵系数和右侧向量的总成本为 $O(N)$。\n一旦构建完成，我们就必须求解这个 $2 \\times 2$ 的线性系统。该系统的大小是常数，与 $N$ 无关。求解一个固定大小的系统需要常数次操作，其复杂度为 $O(1)$。\n该方法的总复杂度是这两个步骤成本的总和：$T_{reg-A}(N) = O(N) + O(1) = O(N)$。\n\n**方法B：Householder-QR 分解**\n另外，该问题可以表示为矩阵形式，即最小化 $\\|A\\beta - W\\|_2^2$，其中 $W$ 是由 $w_i$ 值构成的 $N \\times 1$ 向量，$\\beta = (\\beta_0, \\beta_1)^T$，而 $A$ 是 $N \\times 2$ 的设计矩阵：\n$$ A = \\begin{pmatrix} 1  z_1 \\\\ 1  z_2 \\\\ \\vdots  \\vdots \\\\ 1  z_N \\end{pmatrix} $$\n使用 QR 分解的解法涉及将 $A$ 分解为 $A = QR$，其中 $Q$ 是一个 $N \\times N$ 的正交矩阵，$R$ 是一个 $N \\times 2$ 的上梯形矩阵。对于一个 $N \\times 2$ 的矩阵，基于 Householder 的 QR 分解需要进行 2 次 Householder 变换。\n1. 构建第一个 Householder 反射，以将第一列对角线以下的 $N-1$ 个元素置零。这涉及对长度为 $N$ 的向量进行范数计算和减法运算，成本为 $O(N)$。将此反射应用于第二列的额外成本也是 $O(N)$。\n2. 第二个反射作用于一个 $(N-1) \\times 1$ 的子问题，成本为 $O(N-1) = O(N)$。\n获得 QR 分解的总成本为 $O(N) + O(N) = O(N)$。\n接下来，问题转化为求解 $R\\beta = Q^T W$。乘积 $Q^T W$ 是通过将两次反射应用于 $W$ 来计算的，成本为 $O(N) + O(N-1) = O(N)$。最后，我们通过回代法求解得到的 $2 \\times 2$ 上三角系统以得到 $\\beta$，这需要 $O(1)$ 的时间。\n该方法的总复杂度同样是各步骤成本的总和：$T_{reg-B}(N) = O(N) + O(N) + O(1) = O(N)$。\n\n**总复杂度**\n\n线性回归阶段的两种标准方法的时间复杂度均为 $O(N)$。整个算法是变换和回归两个阶段的序列。总时间复杂度 $T_{total}(N)$ 是它们复杂度的总和：\n$$ T_{total}(N) = T_{transform}(N) + T_{regression}(N) = O(N) + O(N) $$\n根据大O表示法的基本规则，这可以简化为：\n$$ T_{total}(N) = O(N) $$\n执行幂律拟合的总时间随数据点数量线性增长。", "answer": "$$ \\boxed{O(N)} $$", "id": "2372946"}, {"introduction": "算法的理论最坏情况复杂度不仅仅是抽象的数学概念，它也可能被特定的数据模式触发。本练习为你提供了一个亲身实践的机会，通过为广泛使用的快速排序（Quicksort）算法构建一个“恶意”输入，迫使其表现出其令人望而生畏的 $O(N^2)$ 性能。这项练习旨在通过动手构建，加深你对算法与数据结构之间关键相互作用的直觉理解。[@problem_id:2372995]", "problem": "给定一个在计算物理学中为局部敏感操作（如邻居搜索）排列粒子数据时出现的、形式化的空间排序任务。考虑三维空间中的 $N$ 个粒子集合，其位置为 $\\mathbf{r}_i = (x_i,y_i,z_i) \\in \\mathbb{R}^3$。每个粒子被映射到一个空间键 $K(\\mathbf{r}_i) = (x_i,y_i,z_i)$，并且键按字典序进行全序排列：对于任意的 $\\mathbf{a} = (x_a,y_a,z_a)$ 和 $\\mathbf{b} = (x_b,y_b,z_b)$，定义 $K(\\mathbf{a}) \\le K(\\mathbf{b})$ 当且仅当 $x_a  x_b$，或 $x_a = x_b$ 且 $y_a  y_b$，或 $x_a = x_b$，$y_a = y_b$ 且 $z_a \\le z_b$。\n\n定义一个排序算法，该算法对一个空间键数组 $A$ 进行操作，并使用以最后一个元素为主元的确定性快速排序和 Lomuto 分区方案，按非递减字典序对其进行排序。对于子数组 $A[\\ell..r]$，分区过程将主元设为 $p = A[r]$，初始化 $i = \\ell - 1$，然后对于从 $\\ell$到 $r-1$ 的每个 $j$ 执行一次形式为 $A[j] \\le p$ 的键比较；如果比较为真，则将 $i$ 递增并交换 $A[i]$ 和 $A[j]$。循环结束后，交换 $A[i+1]$ 和 $A[r]$，并返回主元索引 $i+1$。然后，当 $\\ell  r$ 时，快速排序对 $A[\\ell..i]$ 和 $A[i+2..r]$ 进行递归操作。“键比较”精确地指在分区循环内部对 $K(\\cdot) \\le K(\\cdot)$ 形式关系的一次求值；不计算任何其他操作。\n\n你的任务是为下面的每个测试案例设计一个具体的粒子分布（即一个遵守所述约束的位置 $\\mathbf{r}_i$ 的有序列表），当将上述排序算法应用于你的粒子的空间键时，能够触发该算法的最坏情况 $\\mathcal{O}(N^2)$ 行为。对于每个测试案例，你必须将所定义的算法应用于你构建的分布，并报告在整个排序过程中执行的键比较的确切次数。\n\n测试套件（每个案例指定了 $N$ 以及对允许的粒子坐标的约束）：\n\n- 案例 1：$N = 1$。约束：位置 $\\mathbf{r}_i$ 可以是任何实值三元组；无额外限制。\n- 案例 2：$N = 2$。约束：空间键 $K(\\mathbf{r}_i)$ 必须两两不同。\n- 案例 3：$N = 10$。约束：空间键 $K(\\mathbf{r}_i)$ 必须两两不同，并且对所有 $i$ 满足 $y_i = 0$ 和 $z_i = 0$，其中 $x_i \\in \\{0,1,2,3,4,5,6,7,8,9\\}$。\n- 案例 4：$N = 10$。约束：所有空间键都相同，即 $K(\\mathbf{r}_1) = K(\\mathbf{r}_2) = \\dots = K(\\mathbf{r}_{10})$。\n- 案例 5：$N = 9$。约束：对所有 $i$ 满足 $x_i = 0$ 和 $z_i = 0$，而 $y_i$ 是两两不同的实数。\n\n对于每个案例，构建一个有效的粒子分布，使其在指定算法下达到最坏情况行为，并计算快速排序执行的键比较的总确切次数。你的程序应产生单行输出，其中包含一个方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中 $r_k$ 是案例 $k$ 的键比较次数的整数值，顺序为 $k=1,2,3,4,5$。", "solution": "所提出的问题是有效的。这是一个在算法分析领域中定义明确的练习，其背景是计算物理学，所有术语和过程都经过了严格定义。没有科学上的不一致、逻辑上的矛盾或含糊不清之处。我将继续进行解答。\n\n任务是确定特定快速排序算法实现的最大键比较次数，并构建触发此最坏情况行为的输入分布。该算法是使用最后一个元素作为主元和 Lomuto 分区方案的确定性快速排序。键比较被定义为在分区循环内对 $A[j] \\le p$ 的一次求值。\n\n快速排序的最坏情况时间复杂度为 $\\mathcal{O}(N^2)$，它发生在分区过程持续产生最不平衡的分割时。对于大小为 $n$ 的子数组，Lomuto 分区过程恰好执行 $n-1$ 次键比较。一次最大程度不平衡的分割会将大小为 $n$ 的数组划分为一个大小为 $n-1$ 的子问题和一个大小为 $0$ 的子问题。如果在每个递归步骤中都发生这种情况，对于大小为 $N$ 的初始数组，总比较次数（表示为 $C(N)$）遵循以下递推关系：\n$$\nC(n) = (n-1) + C(n-1)\n$$\n递归的基线条件是 $C(1) = 0$，因为递归的条件 $\\ell  r$ 未被满足。展开这个递推式得到：\n$$\nC(N) = (N-1) + (N-2) + \\dots + C(1) = \\sum_{k=1}^{N-1} k = \\frac{(N-1)N}{2}\n$$\n这是最大键比较次数的公式。\n\n我们的目标是为每个测试案例构建一个初始空间键数组，以确保在每个步骤中都发生这种最坏情况的分区。Lomuto 分区，当主元 $p = A[r]$ 是子数组 $A[\\ell..r]$ 中的最小或最大元素时，会实现最坏情况的分割。这是因为所有其他元素都将被放置在主元最终位置的一侧。保证每个递归调用都满足此条件的一个简单方法是提供一个已经排序的初始数组（按非递减或非递增字典序）。\n\n让我们分析一个非递减有序数组的情况。初始主元是 $A[N-1]$，即最大元素。在 `partition` 函数中，对于所有从 $0$ 到 $N-2$ 的 $j$，比较 $A[j] \\le p$ 都将为真。这导致 $N-1$ 次比较。分区将主元放置在索引 $N-1$ 处，从而导致对子数组 $A[0..N-2]$ 的递归调用，而该子数组本身也是有序的。这种模式会重复，从而产生最坏情况的比较次数。类似的分析也适用于所有元素都相同的数组（因为条件 $A[j] \\le p$ 始终为真），以及逆序排序的数组（其中主元始终是最小值）。\n\n我们现在将此原则应用于每个测试案例。\n\n**案例 1**：$N=1$\n输入是一个大小为1的数组。对快速排序的初始调用 `quicksort(A, 0, 0)` 不满足条件 $\\ell  r$（因为 $0 \\not 0$）。因此，不会发生分区，也不会进行比较。\n一个有效的粒子分布是 $\\mathbf{r}_1 = (0,0,0)$。\n比较次数：$C(1) = \\frac{1(0)}{2} = 0$。\n\n**案例 2**：$N=2$\n约束是键必须两两不同。为了触发最坏情况，我们构建一个已排序的键数组。例如：\n$\\mathbf{r}_1 = (0,0,0)$ 和 $\\mathbf{r}_2 = (1,0,0)$。键为 $K_1=(0,0,0)$ 和 $K_2=(1,0,0)$，它们是按字典序排序的。\n比较次数：$C(2) = \\frac{2(1)}{2} = 1$。\n\n**案例 3**：$N=10$\n约束是 $y_i=0$，$z_i=0$，且 $x_i \\in \\{0,1,2,3,4,5,6,7,8,9\\}$ 是不同的。字典序完全由 $x_i$ 坐标决定。我们构建一个已排序的分布：\n$\\mathbf{r}_i = (i-1, 0, 0)$ 对于 $i=1, \\dots, 10$。这会产生已排序的键数组 $A = [(0,0,0), (1,0,0), \\dots, (9,0,0)]$。\n比较次数：$C(10) = \\frac{10(9)}{2} = 45$。\n\n**案例 4**：$N=10$\n约束是所有键都相同。例如，$\\mathbf{r}_i = (0,0,0)$ 对于所有 $i=1, ..., 10$。输入数组包含10个相同的键。如前所述，当对所有元素都相同的子数组 $A[\\ell..r]$ 进行分区时，主元 $p=A[r]$ 等于所有其他元素。比较 $A[j] \\le p$ 始终为真。这会导致与有序数组相同的最大程度不平衡分区。\n比较次数：$C(10) = \\frac{10(9)}{2} = 45$。\n\n**案例 5**：$N=9$\n约束是 $x_i=0$，$z_i=0$，且 $y_i$ 坐标是不同的。字典序完全由 $y_i$ 坐标决定。我们构建一个已排序的分布：\n$\\mathbf{r}_i = (0, i-1, 0)$ 对于 $i=1, \\dots, 9$。这会得到已排序的键数组 $A = [(0,0,0), (0,1,0), \\dots, (0,8,0)]$。\n比较次数：$C(9) = \\frac{9(8)}{2} = 36$。\n\n最终结果是为每个案例计算出的比较次数：$[0, 1, 45, 45, 36]$。以下程序实现了指定的算法，并在构建的最坏情况输入上验证了这些计数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\nclass QuickSortAnalyzer:\n    \"\"\"\n    A class to encapsulate the specified Quicksort algorithm and count key comparisons.\n    \"\"\"\n    def __init__(self):\n        self.comparisons = 0\n\n    def _compare_keys(self, key1, key2):\n        \"\"\"\n        Performs a single lexicographical comparison and increments the counter.\n        Python's tuple comparison is lexicographical, matching the problem's definition.\n        K(a) = K(b) => (xa,ya,za) = (xb,yb,zb)\n        \"\"\"\n        self.comparisons += 1\n        return key1 = key2\n\n    def _partition(self, arr, low, high):\n        \"\"\"\n        Lomuto partition scheme using the last element as pivot.\n        \"\"\"\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if self._compare_keys(arr[j], pivot):\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        \n        # Place pivot in its final sorted position\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def _quicksort(self, arr, low, high):\n        \"\"\"\n        Recursive Quicksort algorithm as defined in the problem.\n        \"\"\"\n        if low  high:\n            # pi is the partitioning index, arr[pi] is now at the right place.\n            pi = self._partition(arr, low, high)\n\n            # Recursively sort elements before and after partition\n            self._quicksort(self, arr, low, pi - 1)\n            self._quicksort(self, arr, pi + 1, high)\n\n    def run_and_count(self, particle_distribution):\n        \"\"\"\n        Runs the Quicksort on a given particle distribution and returns the comparison count.\n        \"\"\"\n        self.comparisons = 0\n        keys = list(particle_distribution) # Make a mutable copy\n        n = len(keys)\n        if n > 0:\n            self._quicksort(self, keys, 0, n - 1)\n        return self.comparisons\n\ndef solve():\n    \"\"\"\n    Main function to construct test cases and compute the results.\n    \"\"\"\n    \n    # Each test case is a list of particle positions (tuples) constructed to\n    # trigger the worst-case behavior of the specified Quicksort algorithm,\n    # while adhering to the problem's constraints. The worst-case is triggered\n    # by inputs that are already sorted, reverse-sorted, or have all equal elements.\n    \n    test_cases = [\n        # Case 1: N = 1. Trivial case. sorted.\n        [(0.0, 0.0, 0.0)],\n        \n        # Case 2: N = 2. Pairwise distinct keys. Constructed as sorted.\n        [(0.0, 0.0, 0.0), (1.0, 0.0, 0.0)],\n        \n        # Case 3: N = 10. Distinct keys with y_i=z_i=0, x_i in {0..9}. Constructed as sorted.\n        [(float(i), 0.0, 0.0) for i in range(10)],\n        \n        # Case 4: N = 10. All keys identical. This also triggers the worst-case.\n        [(0.0, 0.0, 0.0)] * 10,\n        \n        # Case 5: N = 9. Distinct keys with x_i=z_i=0. Constructed by sorting y_i.\n        [(0.0, float(i), 0.0) for i in range(9)]\n    ]\n\n    analyzer = QuickSortAnalyzer()\n    results = []\n    \n    for case_data in test_cases:\n        count = analyzer.run_and_count(case_data)\n        results.append(count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372995"}, {"introduction": "现在，我们将从通用算法转向一个核心的生物信息学应用：读段比对（read mapping）。这个问题挑战你以“攻击者”的视角思考，找出哪些真实的生物学特征——具体来说是基因组序列的类型——会导致一个标准的、基于后缀树的比对算法效率显著下降。这项练习突显了为什么理解算法复杂度对于处理大规模且通常具有高度重复性的生物数据至关重要。[@problem_id:2370310]", "problem": "一个基于后缀树的精确读段匹配器构建在长度为 $N$、字母表为 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 的参考脱氧核糖核酸（DNA）字符串 $T$ 之上。对于一个长度为 $L$ 的查询读段（模式）$P$，该匹配器遵循标准的后缀树遍历来查找 $P$ 在 $T$ 中的所有精确出现，并报告 $P$ 出现的每一个起始位置。假设 $1 \\le L \\le N/2$。你可以对抗性地选择参考基因组序列 $T$（长度为 $N$），作为 $N$ 的函数。\n\n以下哪些基因组 $T_N$ 的族，会迫使任何报告所有出现次数的、基于后缀树的精确匹配器的单次查询运行时间达到 $\\Theta(L+N)$？所谓“迫使”，是指对于每一个 $1 \\le L \\le N/2$ 的 $L$，都存在某个长度为 $L$ 的读段 $P$，其在 $T_N$ 上的查询需要 $\\Theta(L+N)$ 的时间。请选择所有适用项。\n\nA. $T_N$ 是由 $N$ 个重复的 $\\text{A}$ 组成的同聚物字符串。\n\nB. $T_N$ 是字母表 $\\Sigma$ 上的一个 $k=\\lfloor \\log_{4} N \\rfloor$ 阶 De Bruijn 序列（因此每个长度为 $k$ 的 $\\Sigma$ 上的字符串都作为子串恰好出现一次）。\n\nC. $T_N$ 是通过从 $\\Sigma$ 中均匀随机抽样生成的，字符是独立同分布（i.i.d.）的。\n\nD. $T_N$ 是周期为 2 的串联重复序列 $T_N = (\\text{AC})^{\\lfloor N/2 \\rfloor}$（如有必要，截断至长度 $N$）。\n\nE. $T_N$ 是周期为 4 的串联重复序列 $T_N = (\\text{ACGT})^{\\lfloor N/4 \\rfloor}$（如有必要，截断至长度 $N$）。", "solution": "用户提出了一个关于基于后缀树的精确读段匹配的最坏情况时间复杂度的问题。在进行解答之前，需要对问题陈述进行全面验证。\n\n### 步骤 1：提取已知条件\n\n*   **算法**：基于后缀树的精确读段匹配器。\n*   **参考字符串**：$T$，一个长度为 $N$ 的脱氧核糖核酸（DNA）字符串。\n*   **字母表**：$\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$。\n*   **查询读段**：$P$，一个长度为 $L$ 的模式。\n*   **任务**：查找 $P$ 在 $T$ 中的所有精确出现，并报告每一个起始位置。\n*   **对 $L$ 的约束**：$1 \\le L \\le N/2$。\n*   **对抗性条件**：可以对抗性地选择参考基因组 $T$（作为 $N$ 的函数，记为 $T_N$）。\n*   **问题**：识别出哪些基因组 $T_N$ 的族会迫使*任何*此类匹配器的单次查询运行时间达到 $\\Theta(L+N)$。所谓“迫使”的条件是：对于 $1 \\le L \\le N/2$ 范围内的每一个 $L$，都必须存在某个长度为 $L$ 的读段 $P$，其在 $T_N$ 上的查询时间为 $\\Theta(L+N)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n*   **科学依据**：该问题植根于算法设计、字符串学和生物信息学等成熟领域。后缀树是字符串匹配的标准数据结构，其复杂度分析是计算机科学的核心内容。DNA序列、字母表和读段匹配的概念是生物信息学的核心。该问题在科学上和数学上都是合理的。\n*   **适定性**：该问题是适定的。它要求找出能够引发标准算法已知最坏情况性能的特定输入类别（$T_N$）。性能指标（$\\Theta(L+N)$）及其必须满足的条件都得到了精确定义。基于标准的算法分析，存在一组唯一的正确选项。\n*   **客观性**：问题陈述使用客观、技术性的语言表达。没有主观或模糊的术语。\n*   **结论**：问题陈述是自洽、一致且科学有效的。它没有违反任何无效问题的标准。\n\n### 步骤 3：判定与行动\n\n问题陈述是**有效的**。将推导完整解法。\n\n### 解法推导\n\n使用为 $T$ 预先构建的后缀树，在长度为 $N$ 的参考字符串 $T$ 中查找长度为 $L$ 的模式 $P$ 的所有出现，其时间复杂度包括两个部分：\n1.  **匹配阶段**：从根节点开始遍历后缀树以匹配 $P$ 的字符。此过程耗时与模式长度成正比，即 $O(L)$。\n2.  **报告阶段**：如果找到模式 $P$，遍历会结束于树中的一个特定节点（例如 $u$）。以 $u$ 为根的子树中的每个叶节点都对应 $P$ 在 $T$ 中出现的一个起始位置。设 $z$ 为 $P$ 的总出现次数。要报告所有这些出现，必须访问 $u$ 的子树中的所有 $z$ 个叶节点。这可以通过对子树进行简单遍历（例如深度优先搜索）在 $O(z)$ 时间内完成。\n\n因此，一次查询的总时间复杂度为 $O(L+z)$。问题要求找出使该复杂度变为 $\\Theta(L+N)$ 的情况。这要求出现次数 $z$ 与 $N$ 同阶，即 $z = \\Omega(N)$。由于 $z$ 最多为 $N-L+1$，所以 $z$ 也是 $O(N)$。因此，条件简化为：找到这样的基因组 $T_N$，使得对于给定范围内的任何 $L$，都存在一个长度为 $L$ 的模式 $P$，其出现次数 $z = \\Theta(N)$。\n\n我们现在逐一分析每个选项。\n\n**A. $T_N$ 是由 $N$ 个重复的 $\\text{A}$ 组成的同聚物字符串。**\n\n设 $T_N = \\text{A}^N$。我们必须证明，对于任何给定的 $1 \\le L \\le N/2$ 的 $L$，存在一个长度为 $L$ 的模式 $P$，其出现次数为 $\\Theta(N)$。我们选择模式 $P = \\text{A}^L$。该模式由 $L$ 个连续的 'A' 字符组成。这个模式在 $T_N$ 中从位置 $1, 2, \\dots, N-L+1$ 开始出现。总出现次数为 $z = N - L + 1$。因为给定条件 $L \\le N/2$，我们有 $z = N - L + 1 \\ge N - N/2 + 1 = N/2 + 1$。因此，$z = \\Theta(N)$。查询时间为 $\\Theta(L+z) = \\Theta(L+N)$。这对于我们为任何有效的 $L$ 选择的 $P$ 都成立。因此，该选项满足对抗性条件。\n\n**结论：正确。**\n\n**B. $T_N$ 是字母表 $\\Sigma$ 上的一个 $k=\\lfloor \\log_{4} N \\rfloor$ 阶 De Bruijn 序列。**\n\n一个在大小为 $|\\Sigma|=4$ 的字母表上的 $k$ 阶 De Bruijn 序列 $T_N$ 的长度为 $N=4^k$。根据定义，$\\Sigma$ 上每个可能的长度为 $k$ 的字符串（一个 $k$-mer）在 $T_N$ 中作为子串恰好出现一次。问题要求*对于每个*在 $1 \\le L \\le N/2$ 范围内的 $L$，都有一个出现次数为 $\\Theta(N)$ 的模式 $P$。我们用 $L=k=\\lfloor \\log_4 N \\rfloor$ 来测试。对于 $N \\ge 4$，$k = \\lfloor \\log_4 N \\rfloor \\le \\log_4 N \\le N/2$，所以这是一个有效的 $L$ 选择。对于任何长度为 $L=k$ 的模式 $P$，$T_N$ 中的出现次数恰好为 $z=1$。查询时间为 $\\Theta(L+z) = \\Theta(k+1) = \\Theta(\\log_4 N)$。这不等于 $\\Theta(L+N) = \\Theta(k+N) = \\Theta(N)$。由于该条件在 $L=k$ 时不成立，De Bruijn 序列不会对所有指定的 $L$ 值强制产生最坏情况的运行时间。\n\n**结论：不正确。**\n\n**C. $T_N$ 是通过从 $\\Sigma$ 中均匀随机抽样生成的，字符是独立同分布（i.i.d.）的。**\n\n对于一个随机字符串 $T_N$，我们可以分析一个模式 $P$ 的期望出现次数。对于一个长度为 $L$ 的固定模式 $P$，其在任何给定位置出现的概率是 $(1/4)^L$。期望出现次数为 $E[z] = (N-L+1)(1/4)^L$。对抗性条件要求对于*每个* $L \\in [1, N/2]$，我们能找到*某个*长度为 $L$ 的模式 $P$，其出现次数为 $\\Theta(N)$。我们选择一个较大的 $L$，例如 $L = \\lceil \\log_4 N \\rceil + 1$。对于足够大的 $N$，这个 $L$ 在 $[1, N/2]$ 的范围内。对于这个 $L$，任何单个模式 $P$ 的期望出现次数是 $E[z] \\approx N \\cdot (1/4)^{\\log_4 N + 1} = N \\cdot (1/N \\cdot 1/4) = 1/4$。根据期望的线性性质，所有 $4^L$ 种可能模式的总期望出现次数也很小。以非常高的概率，对于大的 $L$，没有长度为 $L$ 的子串会重复很多次，当然也不会是 $\\Theta(N)$ 次。随机字符串的特点是重复性低，这与触发最坏情况时间复杂度所需的情况相反。该条件不成立。\n\n**结论：不正确。**\n\n**D. $T_N$ 是周期为 2 的串联重复序列 $T_N = (\\text{AC})^{\\lfloor N/2 \\rfloor}$（如有必要，截断至长度 $N$）。**\n\n设 $T_N = \\text{ACACAC}\\dots$。我们必须证明，对于任何 $1 \\le L \\le N/2$ 的 $L$，存在一个长度为 $L$ 且出现次数为 $\\Theta(N)$ 的模式 $P$。对于任何给定的 $L$，我们选择 $P$ 为 $T_N$ 的长度为 $L$ 的前缀，即 $P = T_N[1..L]$。这个模式是 'A' 和 'C' 的交替序列。这个模式将在 $T_N$ 中每隔两个位置重新出现一次，具体来说，是在位置 $1, 3, 5, \\dots$ 开始，只要起始字符匹配。出现次数 $z$ 大约为 $(N-L)/2 \\approx N/2$。由于 $L \\le N/2$，我们有 $z \\ge (N-N/2)/2 = N/4$。因此，$z=\\Theta(N)$。查询时间为 $\\Theta(L+z) = \\Theta(L+N)$。这对于任何有效的 $L$ 都成立。\n\n**结论：正确。**\n\n**E. $T_N$ 是周期为 4 的串联重复序列 $T_N = (\\text{ACGT})^{\\lfloor N/4 \\rfloor}$（如有必要，截断至长度 $N$）。**\n\n逻辑与选项 D 相同。设 $T_N = \\text{ACGTACGT}\\dots$。对于任何给定的 $1 \\le L \\le N/2$ 的 $L$，我们选择模式 $P$ 为 $T_N$ 的长度为 $L$ 的前缀，即 $P = T_N[1..L]$。这个模式是重复单元 'ACGT' 的子串。这个模式将在 $T_N$ 中每隔 4 个位置重新出现一次，从位置 $1, 5, 9, \\dots$ 开始。出现次数 $z$ 大约为 $(N-L)/4 \\approx N/4$。由于 $L \\le N/2$，我们有 $z \\ge (N-N/2)/4 = N/8$。因此，$z=\\Theta(N)$。查询时间为 $\\Theta(L+z) = \\Theta(L+N)$。这对于任何有效的 $L$ 都成立。\n\n**结论：正确。**", "answer": "$$\\boxed{ADE}$$", "id": "2370310"}]}