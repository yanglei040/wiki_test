{"hands_on_practices": [{"introduction": "核心启动子内的不同DNA基序组合是如何共同决定其强度的？本练习运用统计热力学的基本原理来建立一个定量模型。通过计算不同启动子结构的相对转录起始概率，您将亲身体验生物物理模型如何将DNA序列特征转化为可预测的生物学活性。", "problem": "RNA聚合酶II的转录起始关键依赖于起始前复合物（PIC）的组装，该复合物由转录因子II D（TFIID）在核心启动子上成核。典型的核心启动子基序，如TATA盒（TATA）、起始子（Inr）和下游启动子元件（DPE），可调节TFIID的亲和力。考虑一个热力学平衡模型，在该模型中，启动子组装起始前复合物（PIC）的概率与TFIID结合到可用基序构型的玻尔兹曼权重成正比。假设遵循以下建模原则：\n- 当多个基序同时出现时，单个基序对TFIID结合的自由能贡献是可加的，因此总结合自由能是各基序特异性自由能的总和。\n- 不同启动子类别组装PIC的相对概率由其玻尔兹曼权重的比值决定，这与平衡统计力学一致。\n- 对于结合自由能为 $\\Delta G$ 的状态，使用玻尔兹曼因子 $\\exp\\left(-\\Delta G/(R T)\\right)$，其中 $R$ 是气体常数， $T$ 是绝对温度。\n\n比较两类启动子：\n- A类：包含TATA和Inr（记为TATA+Inr）。\n- B类：包含Inr和DPE（记为Inr+DPE）。\n\n给定在温度 $T=300\\,\\text{K}$ 时，各基序特异性的结合自由能：\n- $\\Delta G_{\\text{TATA}}=-7\\,\\text{kcal}\\,\\text{mol}^{-1}$，\n- $\\Delta G_{\\text{Inr}}=-3\\,\\text{kcal}\\,\\text{mol}^{-1}$，\n- $\\Delta G_{\\text{DPE}}=-2\\,\\text{kcal}\\,\\text{mol}^{-1}$。\n\n使用气体常数 $R=1.987\\times 10^{-3}\\,\\text{kcal}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}$。在上述假设下，计算PIC组装的相对概率，定义为比值 $P_{\\text{PIC}}(\\text{TATA}+\\text{Inr})/P_{\\text{PIC}}(\\text{Inr}+\\text{DPE})$。将最终结果四舍五入至三位有效数字。以单个无量纲数（小数或科学记数法，不带百分号）报告您的答案。", "solution": "任务是计算两类启动子（我们表示为A (TATA+Inr) 和 B (Inr+DPE)）的PIC组装相对概率。这个相对概率是它们各自概率 $P_A$ 和 $P_B$ 的比值。根据问题陈述，给定状态的概率与其玻尔兹曼因子成正比。因此，概率之比就是其玻尔兹曼因子之比：\n$$ \\frac{P_A}{P_B} = \\frac{P_{\\text{PIC}}(\\text{TATA}+\\text{Inr})}{P_{\\text{PIC}}(\\text{Inr}+\\text{DPE})} = \\frac{k \\cdot \\exp\\left(-\\frac{\\Delta G_A}{RT}\\right)}{k \\cdot \\exp\\left(-\\frac{\\Delta G_B}{RT}\\right)} $$\n比例常数 $k$ 被约去，我们可以合并指数项：\n$$ \\frac{P_A}{P_B} = \\exp\\left(-\\frac{\\Delta G_A}{RT} + \\frac{\\Delta G_B}{RT}\\right) = \\exp\\left(-\\frac{\\Delta G_A - \\Delta G_B}{RT}\\right) $$\n此处，$\\Delta G_A$ 和 $\\Delta G_B$ 分别是启动子类别A和B的总结合自由能。\n\n根据自由能的可加性原则，具有多个基序的启动子的总结合自由能是单个基序能量的总和。\n对于启动子类别A (TATA+Inr)，总结合自由能为：\n$$ \\Delta G_A = \\Delta G_{\\text{TATA}} + \\Delta G_{\\text{Inr}} $$\n代入给定值：\n$$ \\Delta G_A = (-7\\,\\text{kcal}\\,\\text{mol}^{-1}) + (-3\\,\\text{kcal}\\,\\text{mol}^{-1}) = -10\\,\\text{kcal}\\,\\text{mol}^{-1} $$\n对于启动子类别B (Inr+DPE)，总结合自由能为：\n$$ \\Delta G_B = \\Delta G_{\\text{Inr}} + \\Delta G_{\\text{DPE}} $$\n代入给定值：\n$$ \\Delta G_B = (-3\\,\\text{kcal}\\,\\text{mol}^{-1}) + (-2\\,\\text{kcal}\\,\\text{mol}^{-1}) = -5\\,\\text{kcal}\\,\\text{mol}^{-1} $$\n现在，我们计算总结合自由能的差值，$\\Delta G_A - \\Delta G_B$：\n$$ \\Delta G_A - \\Delta G_B = (-10\\,\\text{kcal}\\,\\text{mol}^{-1}) - (-5\\,\\text{kcal}\\,\\text{mol}^{-1}) = -5\\,\\text{kcal}\\,\\text{mol}^{-1} $$\n接下来，我们计算热能项 $RT$：\n$$ RT = (1.987 \\times 10^{-3}\\,\\text{kcal}\\,\\text{mol}^{-1}\\,\\text{K}^{-1}) \\times (300\\,\\text{K}) = 0.5961\\,\\text{kcal}\\,\\text{mol}^{-1} $$\n现在我们可以计算比值表达式中的指数：\n$$ -\\frac{\\Delta G_A - \\Delta G_B}{RT} = -\\frac{-5\\,\\text{kcal}\\,\\text{mol}^{-1}}{0.5961\\,\\text{kcal}\\,\\text{mol}^{-1}} = \\frac{5}{0.5961} \\approx 8.387854 $$\n最后，我们通过取该值的指数来计算相对概率比：\n$$ \\frac{P_A}{P_B} = \\exp\\left(\\frac{5}{0.5961}\\right) \\approx \\exp(8.387854) \\approx 4393.35 $$\n将结果四舍五入到三位有效数字，我们得到 $4390$ 或 $4.39 \\times 10^3$。这个结果表明，在该热力学模型的假设下，与具有Inr和DPE基序的启动子相比，具有TATA和Inr基序的启动子组装PIC的可能性大约高出 $4390$ 倍。", "answer": "$$\\boxed{4.39 \\times 10^{3}}$$", "id": "2802123"}, {"introduction": "基因调控不仅仅取决于静态的DNA序列；像DNA甲基化这样的表观遗传修饰也扮演着至关重要的角色。本练习挑战您扩展经典的位置权重矩阵（PWM）模型，以纳入甲基化对转录因子结合的影响。通过量化结合分数的预期变化，您将学习如何用计算方法来模拟遗传信息和表观遗传信息之间的动态相互作用。", "problem": "一个调控 CpG 岛内调控启动子的转录因子 (TF) 根据具有对数几率分数的“位置权重矩阵”(PWM; position weight matrix) 模型结合 DNA。在此模型中，对于长度为 $L$ 的候选位点，其对数几率分数为\n$$\nS \\;=\\; \\sum_{i=1}^{L} \\ln\\!\\left(\\frac{p_{i}(b_{i})}{b(b_{i})}\\right),\n$$\n其中 $p_{i}(x)$ 是位置 $i$ 处碱基 $x \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 的位置特异性概率，$b(x)$ 是碱基 $x$ 的基因组背景频率，$\\ln$ 表示自然对数。考虑以下长度为 6 的基序，其位置特异性概率向量（按 $\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}$ 顺序）如下：\n- 位置 $1$：$(0.5,\\,0.1,\\,0.3,\\,0.1)$\n- 位置 $2$：$(0.1,\\,0.6,\\,0.2,\\,0.1)$\n- 位置 $3$：$(0.2,\\,0.1,\\,0.6,\\,0.1)$\n- 位置 $4$：$(0.1,\\,0.5,\\,0.3,\\,0.1)$\n- 位置 $5$：$(0.1,\\,0.1,\\,0.7,\\,0.1)$\n- 位置 $6$：$(0.2,\\,0.1,\\,0.3,\\,0.4)$\n\n该 CpG 岛内的背景碱基频率为 $b(\\mathrm{A})=0.2$, $b(\\mathrm{C})=0.3$, $b(\\mathrm{G})=0.3$, $b(\\mathrm{T})=0.2$。调控启动子内的一个候选结合位点是序列 $S=\\mathrm{ACGCGT}$（位置 1 到 6），其中包含位于位置 $(2,3)$ 和 $(4,5)$ 的两个 CpG 二核苷酸。\n\n该 TF 是甲基化敏感的：当 CpG 上下文中位置 $i$ 的一个胞嘧啶被甲基化时，该位置胞嘧啶的 PWM 条目将乘以一个因子 $\\alpha_{i} \\in (0,1)$ 进行惩罚，并且整个列被重新归一化以使总和为 $1$。具体来说，如果甲基化发生在位置 $i$，那么\n$$\np_{i}^{(\\mathrm{meth})}(\\mathrm{C}) \\;=\\; \\frac{\\alpha_{i}\\,p_{i}(\\mathrm{C})}{Z_{i}}, \n\\qquad \np_{i}^{(\\mathrm{meth})}(x\\neq \\mathrm{C}) \\;=\\; \\frac{p_{i}(x)}{Z_{i}},\n\\qquad \nZ_{i} \\;=\\; 1 - (1-\\alpha_{i})\\,p_{i}(\\mathrm{C}).\n$$\n假设甲基化只发生在 CpG 二核苷酸中的胞嘧啶上。对于序列 $S$ 中的两个 CpG 胞嘧啶，其乘法惩罚因子和甲基化概率如下：\n- 位置 $2$：$\\alpha_{2}=0.4$，甲基化概率 $m_{2}=0.7$。\n- 位置 $4$：$\\alpha_{4}=0.2$，甲基化概率 $m_{4}=0.5$。\n\n所有其他位置不受影响。使用上述带有自然对数的 PWM 对数几率模型，计算在所述甲基化模型下序列 $S$ 的对数几率分数的期望变化 $\\mathbb{E}[S_{\\mathrm{meth}}-S]$。将您的答案四舍五入到 4 位有效数字。以自然对数单位 (nats) 表示最终的分数变化。", "solution": "问题要求在概率性甲基化模型下，计算给定 DNA 序列的对数几率分数的期望变化 $\\mathbb{E}[S_{\\mathrm{meth}}-S]$。\n\n长度为 $L$ 的候选位点的对数几率分数 $S$ 是所有位置上分数的总和：\n$$\nS = \\sum_{i=1}^{L} S_i \\quad \\text{其中} \\quad S_i = \\ln\\left(\\frac{p_{i}(b_{i})}{b(b_{i})}\\right)\n$$\n此处，$L=6$，序列为 $S_{\\mathrm{seq}} = \\mathrm{ACGCGT}$。碱基分别为 $b_1=\\mathrm{A}$，$b_2=\\mathrm{C}$，$b_3=\\mathrm{G}$，$b_4=\\mathrm{C}$，$b_5=\\mathrm{G}$，$b_6=\\mathrm{T}$。\n\n题目说明甲基化只发生在 CpG 二核苷酸中的胞嘧啶上。在序列 $\\mathrm{ACGCGT}$ 中，CpG 二核苷酸位于位置 $(2,3)$ 和 $(4,5)$。因此，只有位置 $i=2$ 和 $i=4$ 的胞嘧啶会发生甲基化。对于所有其他位置 $i \\in \\{1, 3, 5, 6\\}$，分数贡献 $S_i$ 不受甲基化影响，即 $S_{i, \\mathrm{meth}} = S_i$。\n\n分数的总变化 $\\Delta S = S_{\\mathrm{meth}} - S$ 是每个位置上变化的总和。由于只有位置 2 和 4 受影响，这可以简化为：\n$$\n\\Delta S = (S_{2, \\mathrm{meth}} - S_2) + (S_{4, \\mathrm{meth}} - S_4)\n$$\n我们需要计算 $\\Delta S$ 的期望值。根据期望的线性性质，我们有：\n$$\n\\mathbb{E}[\\Delta S] = \\mathbb{E}[S_{2, \\mathrm{meth}} - S_2] + \\mathbb{E}[S_{4, \\mathrm{meth}} - S_4]\n$$\n让我们分析单个受影响位置 $i$ 的期望变化。位置 $i$ 的甲基化是一个随机事件，发生的概率为 $m_i$。如果发生甲基化，分数变化为 $S_{i, \\mathrm{meth}} - S_i$。如果不发生（概率为 $1-m_i$），变化为 0。因此，位置 $i$ 的期望变化为：\n$$\n\\mathbb{E}[S_{i, \\mathrm{meth}} - S_i] = m_i \\cdot (S_{i, \\mathrm{meth}} - S_i) + (1-m_i) \\cdot 0 = m_i (S_{i, \\mathrm{meth}} - S_i)\n$$\n分数的总期望变化是这些期望贡献的总和：\n$$\n\\mathbb{E}[\\Delta S] = m_2(S_{2, \\mathrm{meth}} - S_2) + m_4(S_{4, \\mathrm{meth}} - S_4)\n$$\n在碱基为胞嘧啶 ($\\mathrm{C}$) 的位置 $i$，分数的变化由下式给出：\n$$\nS_{i, \\mathrm{meth}} - S_i = \\ln\\left(\\frac{p_i^{(\\mathrm{meth})}(\\mathrm{C})}{b(\\mathrm{C})}\\right) - \\ln\\left(\\frac{p_i(\\mathrm{C})}{b(\\mathrm{C})}\\right) = \\ln\\left(\\frac{p_i^{(\\mathrm{meth})}(\\mathrm{C})}{p_i(\\mathrm{C})}\\right)\n$$\n使用提供的甲基化模型，$p_i^{(\\mathrm{meth})}(\\mathrm{C}) = \\frac{\\alpha_i p_i(\\mathrm{C})}{Z_i}$，变化简化为：\n$$\nS_{i, \\mathrm{meth}} - S_i = \\ln\\left(\\frac{\\alpha_i p_i(\\mathrm{C})/Z_i}{p_i(\\mathrm{C})}\\right) = \\ln\\left(\\frac{\\alpha_i}{Z_i}\\right)\n$$\n其中归一化因子为 $Z_i = 1 - (1-\\alpha_i)p_i(\\mathrm{C})$。\n\n现在我们将对每个受影响的位置进行计算。\n\n**位置 $i=2$**：\n碱基是 $b_2=\\mathrm{C}$。给定参数为 $p_2(\\mathrm{C})=0.6$，$\\alpha_2=0.4$，甲基化概率 $m_2=0.7$。\n首先，我们计算归一化因子 $Z_2$：\n$$\nZ_2 = 1 - (1-\\alpha_2)p_2(\\mathrm{C}) = 1 - (1-0.4)(0.6) = 1 - (0.6)(0.6) = 1 - 0.36 = 0.64\n$$\n位置 2 甲基化后的分数变化是：\n$$\nS_{2, \\mathrm{meth}} - S_2 = \\ln\\left(\\frac{\\alpha_2}{Z_2}\\right) = \\ln\\left(\\frac{0.4}{0.64}\\right) = \\ln\\left(\\frac{5}{8}\\right)\n$$\n\n**位置 $i=4$**：\n碱基是 $b_4=\\mathrm{C}$。给定参数为 $p_4(\\mathrm{C})=0.5$，$\\alpha_4=0.2$，甲基化概率 $m_4=0.5$。\n首先，我们计算归一化因子 $Z_4$：\n$$\nZ_4 = 1 - (1-\\alpha_4)p_4(\\mathrm{C}) = 1 - (1-0.2)(0.5) = 1 - (0.8)(0.5) = 1 - 0.4 = 0.6\n$$\n位置 4 甲基化后的分数变化是：\n$$\nS_{4, \\mathrm{meth}} - S_4 = \\ln\\left(\\frac{\\alpha_4}{Z_4}\\right) = \\ln\\left(\\frac{0.2}{0.6}\\right) = \\ln\\left(\\frac{1}{3}\\right)\n$$\n\n**总期望变化**：\n我们将这些结果结合起来，求出分数的总期望变化：\n$$\n\\mathbb{E}[\\Delta S] = m_2 \\left(S_{2, \\mathrm{meth}} - S_2\\right) + m_4 \\left(S_{4, \\mathrm{meth}} - S_4\\right) = 0.7 \\ln\\left(\\frac{5}{8}\\right) + 0.5 \\ln\\left(\\frac{1}{3}\\right)\n$$\n现在我们计算数值：\n$$\n\\ln\\left(\\frac{5}{8}\\right) = \\ln(0.625) \\approx -0.4700036\n$$\n$$\n\\ln\\left(\\frac{1}{3}\\right) = -\\ln(3) \\approx -1.0986123\n$$\n$$\n\\mathbb{E}[\\Delta S] \\approx 0.7 \\times (-0.4700036) + 0.5 \\times (-1.0986123)\n$$\n$$\n\\mathbb{E}[\\Delta S] \\approx -0.32900252 - 0.54930615 = -0.87830867\n$$\n将最终结果四舍五入到 4 位有效数字，我们得到 -0.8783。", "answer": "$$\\boxed{-0.8783}$$", "id": "2802152"}, {"introduction": "计算生物学的一项核心任务是构建能从序列预测生物学功能的模型，并利用这些模型来模拟进化或与疾病相关的场景。这个综合性的编码练习将指导您构建一个完整的增强子*计算机模拟*（*in silico*）模型，该模型整合了激活因子和抑制因子的结合位点来预测基因表达。通过实现一个“诱变器”来模拟随机突变，您将直接体验计算实验如何揭示顺式调控逻辑及其稳健性的原理。", "problem": "给定一个理想化的生物物理评分框架，用于通过改变转录因子结合位点来近似评估顺式调控DNA增强子的变化如何影响基因表达。假设遵循分子生物学中心法则（DNA到RNA到蛋白质）以及转录调控的标准热力学占有模型：转录因子对调控DNA的占有调节启动子活性，该活性通过一个单调连接函数映射到可测量的表达水平。\n\n基本碱基与建模假设：\n- 一个转录因子识别由一个长度为 $L$ 的位置权重矩阵（PWM; Position Weight Matrix）所概括的DNA序列特征，该矩阵包含在位置 $i \\in \\{1,\\dots,L\\}$ 上碱基 $b \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 的逐位分类概率 $p_{i,b}$，以及一个独立的背景碱基频率 $f_b$（假设 $f_{\\text{A}}=f_{\\text{C}}=f_{\\text{G}}=f_{\\text{T}}=0.25$）。\n- 一个长度为 $L$、碱基为 $b_1,\\dots,b_L$ 的窗口 $w$ 的对数优势比分数为\n$$\ns(w) \\;=\\; \\sum_{i=1}^{L} \\ln\\left(\\frac{p_{i,b_i}}{f_{b_i}}\\right)\n$$\n其中 $\\ln(\\cdot)$ 表示自然对数。\n- 序列的最佳位点分数取为正链和反向互补链上所有窗口的最大对数优势比分数。如果序列长度小于 $L$，则最佳位点分数定义为 $0$。负的最佳位点分数在进入表达模型前被截断为 $0$。\n- 令 $S_{\\text{A}}$ 为激活子PWM的最佳位点分数，$S_{\\text{R}}$ 为阻遏子PWM的最佳位点分数。表达通过逻辑斯蒂连接进行映射\n$$\nE \\;=\\; \\frac{1}{1 + \\exp\\!\\left(-\\left(w_{\\text{A}}\\,S_{\\text{A}} - w_{\\text{R}}\\,S_{\\text{R}} + b\\right)\\right)}\n$$\n其中权重为 $w_{\\text{A}}$ 和 $w_{\\text{R}}$，偏置为 $b$。\n\n从共有序列构建PWM：\n- 激活子PWM：长度 $L_{\\text{A}}=6$，共有序列 $c^{\\text{A}}=$ \"ACGTAC\"。在每个位置 $i$，共有碱基的概率为 $p_{i,c^{\\text{A}}_i}=0.7$，其余三个碱基均分剩余的概率，即 $p_{i,b\\neq c^{\\text{A}}_i}=0.1$。\n- 阻遏子PWM：长度 $L_{\\text{R}}=6$，共有序列 $c^{\\text{R}}=$ \"TGCACC\"。在每个位置 $i$，共有碱基的概率为 $p_{i,c^{\\text{R}}_i}=0.65$，其余三个碱基均分剩余的概率，即 $p_{i,b\\neq c^{\\text{R}}_i}=\\frac{0.35}{3}$。\n- 在两个PWM中，对所有碱基使用相同的背景频率 $f_b=0.25$。\n\n表达谱映射参数：\n- 使用 $w_{\\text{A}}=1.0$，$w_{\\text{R}}=1.2$ 和 $b=-2.0$。\n\n诱变器模型：\n- DNA字母表为 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$。\n- 一个“诱变器”对一个序列应用 $n$ 个编辑事件。每个事件根据点突变、插入和删除的概率 $(p_{\\text{point}}, p_{\\text{ins}}, p_{\\text{del}})$ 独立抽样，其中 $p_{\\text{point}}+p_{\\text{ins}}+p_{\\text{del}}=1$。\n- 点突变：在所有位置中均匀随机选择一个位置，并将该碱基替换为一个均匀随机选择的不同碱基。\n- 插入：从 $\\{0,\\dots,|\\text{seq}|\\}$ 中均匀随机选择一个位置，从 $\\{1,\\dots,L_{\\max}^{\\text{ins}}\\}$ 中均匀随机选择一个插入长度 $\\ell_{\\text{ins}}$，并插入一个由独立均匀随机碱基组成的长度为 $\\ell_{\\text{ins}}$ 的随机片段（$\\ell_{\\text{ins}}$-mer）。\n- 删除：从 $\\{0,\\dots,|\\text{seq}|-1\\}$ 中均匀随机选择一个起始位置，从 $\\{1,\\dots,L_{\\max}^{\\text{del}}\\}$ 中均匀随机选择一个删除长度 $\\ell_{\\text{del}}$，并从起始位置开始删除碱基，直到达到所选长度，如有必要，则在当前序列末尾处截断。如果序列变为空，后续的删除操作为空操作。\n- 随机性必须由一个使用给定整数种子初始化的伪随机数生成器产生，以确保可复现性。\n\n基线增强子序列：\n- 使用以下长度为 $80$ 个核苷酸的基线序列：\n\"ATGCGTACGATCGATGACGTACGTACTTGACCTGAACTGCGTATCGATCGTGCACCGATTACAAGCTTAGGCTAATCGAA\"\n\n任务：\n- 实现一个程序，该程序：\n    1. 根据给定的共有序列和概率构建激活子和阻遏子PWM，使用背景频率 $f_b=0.25$ 将它们转换为对数优势比，并如上所述扫描DNA序列的两条链以获得 $S_{\\text{A}}$ 和 $S_{\\text{R}}$。\n    2. 实现具有三种事件类型的诱变器。所有随机性必须源自一个可设定种子的生成器。\n    3. 计算给定基线序列的基线表达 $E_0$ 和应用指定数量的编辑事件后的突变表达 $E_1$。报告下面每个测试用例的表达变化 $\\Delta E = E_1 - E_0$。\n- 扫描两条链意味着在寻找最大对数优势比分数时，您还必须考虑每个窗口的反向互补序列。\n\n测试套件：\n- 对于每个元组 $(\\text{seed}, n, p_{\\text{point}}, p_{\\text{ins}}, p_{\\text{del}}, L_{\\max}^{\\text{ins}}, L_{\\max}^{\\text{del}})$，从基线序列开始，使用给定的种子初始化随机生成器，应用 $n$ 个具有给定概率和最大事件长度的事件，并输出结果 $\\Delta E$ 作为浮点数。使用以下五个测试用例，它们探测了典型行为、无操作边界、删除极端情况以及仅插入的创建效应：\n    1. $(42, 0, 1.0, 0.0, 0.0, 3, 3)$\n    2. $(7, 1, 1.0, 0.0, 0.0, 3, 3)$\n    3. $(123, 2, 0.5, 0.25, 0.25, 4, 4)$\n    4. $(999, 3, 0.0, 0.0, 1.0, 3, 50)$\n    5. $(2024, 2, 0.0, 1.0, 0.0, 6, 3)$\n\n答案格式要求：\n- 对于每个测试用例，您的程序必须计算 $\\Delta E$ 并将其四舍五入到小数点后六位。\n- 您的程序应生成单行输出，其中包含五个四舍五入后的结果，形式为逗号分隔的列表并用方括号括起来，例如 $[\\Delta E_1,\\Delta E_2,\\Delta E_3,\\Delta E_4,\\Delta E_5]$，其中每个 $\\Delta E_i$ 的格式为小数点后六位。", "solution": "本问题的解决方案需要系统地实现所描述的生物物理模型和诱变过程。以下是实现该解决方案的步骤和相应的Python代码。\n\n1.  **构建PWM和对数优势比矩阵**：为激活子和阻遏子构建概率矩阵，然后将其转换为对数优势比评分矩阵。\n\n2.  **序列扫描与分数计算**：创建一个函数，用于计算给定DNA序列和对数优势比矩阵的最佳结合位点分数。该函数需要扫描正向链和反向互补链，找到所有窗口中的最高分，并根据规则（序列过短或分数为负时）进行处理。\n\n3.  **表达水平计算**：使用逻辑斯蒂函数，根据激活子和阻遏子的结合分数计算基因表达水平。\n\n4.  **诱变模拟**：实现一个函数来执行诱变过程。该函数使用指定的种子初始化一个伪随机数生成器，以确保结果的可复现性。然后，它根据给定的概率分布（点突变、插入、删除）和参数，对序列进行指定次数的随机编辑。\n\n5.  **主执行流程**：首先，计算初始基线序列的表达水平 $E_0$。然后，对每个测试用例，运行诱变模拟器以生成突变序列，计算其表达水平 $E_1$，并记录表达变化 $\\Delta E = E_1 - E_0$。最后，将所有结果格式化为所需的输出。\n\n以下是实现上述逻辑的Python代码：\n```python\nimport numpy as np\n\ndef build_log_odds_pwm(length, consensus, p_consensus, p_other, bg_freq, base_map):\n    \"\"\"Constructs a log-odds scoring matrix from PWM specifications.\"\"\"\n    log_odds_matrix = np.zeros((length, 4))\n    for i in range(length):\n        for base, idx in base_map.items():\n            prob = p_consensus if base == consensus[i] else p_other\n            log_odds_matrix[i, idx] = np.log(prob / bg_freq)\n    return log_odds_matrix\n\ndef get_reverse_complement(seq):\n    \"\"\"Computes the reverse-complement of a DNA sequence.\"\"\"\n    complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n    return \"\".join(complement_map[base] for base in reversed(seq))\n\ndef find_best_site_score(sequence, log_odds_pwm, base_map):\n    \"\"\"Finds the maximum log-odds score for a sequence, scanning both strands.\"\"\"\n    pwm_len = log_odds_pwm.shape[0]\n    if len(sequence)  pwm_len:\n        return 0.0\n\n    max_score = -np.inf\n    \n    sequences_to_scan = [sequence, get_reverse_complement(sequence)]\n\n    for seq in sequences_to_scan:\n        for i in range(len(seq) - pwm_len + 1):\n            window = seq[i:i+pwm_len]\n            current_score = 0.0\n            for j in range(pwm_len):\n                base = window[j]\n                current_score += log_odds_pwm[j, base_map[base]]\n            max_score = max(max_score, current_score)\n\n    return max(0.0, max_score if np.isfinite(max_score) else 0.0)\n\ndef calculate_expression(s_a, s_r, w_a, w_r, b):\n    \"\"\"Calculates gene expression using the logistic link function.\"\"\"\n    exponent = -(w_a * s_a - w_r * s_r + b)\n    return 1.0 / (1.0 + np.exp(exponent))\n\ndef mutagenizer(sequence, seed, n, p_point, p_ins, p_del, l_max_ins, l_max_del):\n    \"\"\"Applies a series of mutations to a DNA sequence.\"\"\"\n    rng = np.random.default_rng(seed)\n    current_seq = sequence\n    bases = np.array(list('ACGT'))\n\n    for _ in range(n):\n        event_type = rng.choice(['point', 'ins', 'del'], p=[p_point, p_ins, p_del])\n        \n        seq_len = len(current_seq)\n        \n        if event_type == 'point':\n            if seq_len == 0: continue\n            pos = rng.integers(0, seq_len)\n            original_base = current_seq[pos]\n            new_base = rng.choice([b for b in bases if b != original_base])\n            current_seq = current_seq[:pos] + new_base + current_seq[pos+1:]\n        \n        elif event_type == 'ins':\n            pos = rng.integers(0, seq_len + 1)\n            length = rng.integers(1, l_max_ins + 1)\n            insert_seq = \"\".join(rng.choice(bases, size=length))\n            current_seq = current_seq[:pos] + insert_seq + current_seq[pos:]\n            \n        elif event_type == 'del':\n            if seq_len == 0: continue\n            start_pos = rng.integers(0, seq_len)\n            length = rng.integers(1, l_max_del + 1)\n            end_pos = start_pos + length\n            current_seq = current_seq[:start_pos] + current_seq[end_pos:]\n            \n    return current_seq\n\ndef solve():\n    \"\"\"Main function to execute the problem logic.\"\"\"\n    BASE_SEQ = \"ATGCGTACGATCGATGACGTACGTACTTGACCTGAACTGCGTATCGATCGTGCACCGATTACAAGCTTAGGCTAATCGAA\"\n    BASE_MAP = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    BG_FREQ = 0.25\n\n    L_A, CONSENSUS_A, P_CONS_A, P_OTHER_A = 6, \"ACGTAC\", 0.7, 0.1\n    log_pwm_A = build_log_odds_pwm(L_A, CONSENSUS_A, P_CONS_A, P_OTHER_A, BG_FREQ, BASE_MAP)\n\n    L_R, CONSENSUS_R, P_CONS_R, P_OTHER_R = 6, \"TGCACC\", 0.65, 0.35 / 3.0\n    log_pwm_R = build_log_odds_pwm(L_R, CONSENSUS_R, P_CONS_R, P_OTHER_R, BG_FREQ, BASE_MAP)\n    \n    W_A, W_R, B = 1.0, 1.2, -2.0\n\n    test_cases = [\n        (42, 0, 1.0, 0.0, 0.0, 3, 3),\n        (7, 1, 1.0, 0.0, 0.0, 3, 3),\n        (123, 2, 0.5, 0.25, 0.25, 4, 4),\n        (999, 3, 0.0, 0.0, 1.0, 3, 50),\n        (2024, 2, 0.0, 1.0, 0.0, 6, 3),\n    ]\n\n    s_a0 = find_best_site_score(BASE_SEQ, log_pwm_A, BASE_MAP)\n    s_r0 = find_best_site_score(BASE_SEQ, log_pwm_R, BASE_MAP)\n    e0 = calculate_expression(s_a0, s_r0, W_A, W_R, B)\n    \n    results = []\n    for case in test_cases:\n        seed, n, p_point, p_ins, p_del, l_max_ins, l_max_del = case\n        \n        mutated_seq = mutagenizer(BASE_SEQ, seed, n, p_point, p_ins, p_del, l_max_ins, l_max_del)\n        \n        s_a1 = find_best_site_score(mutated_seq, log_pwm_A, BASE_MAP)\n        s_r1 = find_best_site_score(mutated_seq, log_pwm_R, BASE_MAP)\n        e1 = calculate_expression(s_a1, s_r1, W_A, W_R, B)\n        \n        delta_e = e1 - e0\n        results.append(f\"{delta_e:.6f}\")\n\n    return f\"[{','.join(results)}]\"\n\n# The final answer is generated by running the solve function.\n# print(solve())\n```", "answer": "[0.000000,0.000000,0.017770,0.056338,-0.006509]", "id": "2419851"}]}