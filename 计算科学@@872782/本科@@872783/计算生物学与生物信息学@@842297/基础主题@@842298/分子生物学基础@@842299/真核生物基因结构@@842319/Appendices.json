{"hands_on_practices": [{"introduction": "在分析一个潜在基因时，首要任务是定位其蛋白质编码区，即开放阅读框（ORF）。这个过程始于寻找起始密码子（$\\text{ATG}$），并终于相应的终止密码子。此外，在真核生物中，起始密码子周围的序列背景——特别是科扎克序列（Kozak sequence）——对翻译起始的效率至关重要。本练习 [@problem_id:2036732] 将引导你亲手实践这项基础而关键的生物信息学技能，通过分析一段DNA序列来识别最长的ORF及其翻译起始信号。", "problem": "在合成生物学中，为在真核宿主中表达而设计基因时，需要仔细考虑其DNA序列。一个关键步骤是识别一个有效的开放阅读框 (ORF)，并确保其具有适当的翻译起始信号。\n\n给定以下45个核苷酸的DNA序列，该序列代表非模板链（编码链），按5'至3'方向书写：\n\n`5'-GCAATGTGAGGCACCATGGCATCAGCTGCAGCTGCACTAGCATAA-3'`\n\n在您的分析中，请使用以下标准定义：\n- 起始密码子是 $\\text{ATG}$。\n- 终止密码子是 $\\text{TAA}$、$\\text{TAG}$ 和 $\\text{TGA}$。\n- 开放阅读框 (ORF) 是一个连续的密码子序列，它以一个起始密码子开始，并以同一阅读框中的一个终止密码子结束。\n- ORF的长度定义为从起始密码子的第一个碱基（含）到紧邻终止密码子之前的密码子的最后一个碱基（含）的核苷酸数量。\n- 如果-3位置的碱基是腺嘌呤 (A) 或鸟嘌呤 (G)，并且+4位置的碱基是鸟嘌呤 (G)，则认为存在一个强Kozak共有序列。位置是相对于$\\text{ATG}$密码子中的A（定义为+1位置）而言的。\n\n请在所有三个正向阅读框中找出最长的可能ORF，并确定其对应的起始密码子是否前导一个强Kozak共有序列。根据您的分析，从以下选项中选择正确的陈述。\n\nA. 最长的ORF长度为27个核苷酸，且存在强Kozak序列。\n\nB. 最长的ORF长度为27个核苷酸，且不存在强Kozak序列。\n\nC. 最长的ORF长度为24个核苷酸，且存在强Kozak序列。\n\nD. 最长的ORF长度为24个核苷酸，且不存在强Kozak序列。\n\nE. 最长的ORF长度为0个核苷酸，且不存在强Kozak序列。", "solution": "给定45个核苷酸的编码链序列 5'-GCAATGTGAGGCACCATGGCATCAGCTGCAGCTGCACTAGCATAA-3'，扫描三个正向阅读框以寻找起始密码子$\\text{ATG}$和框内终止密码子$\\text{TAA}$、$\\text{TAG}$、$\\text{TGA}$。\n\n通过滑动一个3个核苷酸的窗口来识别所有$\\text{ATG}$的出现位置：\n- $\\text{ATG}$位于第4–6位。\n- $\\text{ATG}$位于第16–18位。\n在第2和第3阅读框中没有其他$\\text{ATG}$。\n\n列举第1阅读框的密码子（位置1–3, 4–6, 7–9, ...）：\n- 1–3: GCA\n- 4–6: ATG (起始)\n- 7–9: TGA (终止)\n- 10–12: GGC\n- 13–15: ACC\n- 16–18: ATG (起始)\n- 19–21: GCA\n- 22–24: TCA\n- 25–27: GCT\n- 28–30: GCA\n- 31–33: GCT\n- 34–36: GCA\n- 37–39: CTA\n- 40–42: GCA\n- 43–45: TAA (终止)\n\n根据ORF从$\\text{ATG}$开始并紧邻框内终止密码子之前结束的定义，确定第1阅读框中的ORF：\n- 从第4–6位开始的ORF紧随其后的是位于第7–9位的终止密码子。其长度使用终止密码子前的最后一个碱基（第6位碱基）和起始密码子的第一个碱基（第4位碱基）通过公式 $L = b_{\\text{end}} - b_{\\text{start}} + 1$ 计算得出，即 $L = 6 - 4 + 1 = 3$ 个核苷酸。\n- 从第16–18位开始的ORF，其下一个框内终止密码子位于第43–45位。终止密码子前的最后一个碱基在第42位，所以长度为 $L = 42 - 16 + 1 = 27$ 个核苷酸。\n\n检查第2和第3阅读框中是否有$\\text{ATG}$：\n- 第2阅读框密码子 (2–4, 5–7, ...): 没有$\\text{ATG}$出现。\n- 第3阅读框密码子 (3–5, 6–8, ...): 没有$\\text{ATG}$出现。\n因此，在第2和第3阅读框中不存在ORF。\n\n因此，最长的ORF是从第16–18位开始的那个，长度为 $27$ 个核苷酸。\n\n评估这个最长ORF的Kozak上下文。对于位于第16–18位的$\\text{ATG}$，将$\\text{ATG}$中的A定义为+1位置：\n- -3位置对应序列的第13位，该碱基为A（满足A/G标准）。\n- +4位置对应序列的第19位，该碱基为G（满足所要求的G）。\n一个强Kozak共有序列要求同时满足 $-3 \\in \\{\\text{A}, \\text{G}\\}$ 且 $+4 = \\text{G}$。由于两个条件均满足，因此存在强Kozak序列。\n\n因此，正确的陈述是，最长的ORF长度为27个核苷酸，且存在强Kozak序列。", "answer": "$$\\boxed{A}$$", "id": "2036732"}, {"introduction": "真核基因的表达不仅依赖于编码序列本身，还依赖于转录后精确的加工过程，其中最重要的环节之一是剪接。剪接体通过识别内含子-外显子边界上的保守序列，准确地切除内含子。本练习 [@problem_id:2036728] 聚焦于3'剪接位点，通过一个假设的基因工程场景，让你判断哪种单点突变最可能破坏其功能，从而加深你对剪接信号序列重要性的理解。", "problem": "一位合成生物学家正在设计一种虚构的真核基因 `syn-2` 的突变，以改变其最终产物。目标是迫使细胞的剪接机制跳过一整个外显子，从而产生更短的信使核糖核酸（mRNA）和截短的蛋白质。在真核基因表达中，剪接过程基于对内含子-外显子边界上特定序列的识别来移除内含子。标志着内含子末端的 3' 剪接位点（受体位点）通常包含一个多嘧啶序列，其后紧跟着一个在外显子开始前几乎不变的$\\text{AG}$二核苷酸。\n\n`syn-2` 在内含子1和外显子2边界处的 pre-mRNA 序列如下所示。核苷酸已编号以供参考。竖线 `|` 表示剪接点。\n\n`5'-...UUCCUUACAG|GUAAGU...-3'`\n序列片段：`U(1) U(2) C(3) C(4) U(5) U(6) A(7) C(8) A(9) G(10) | G(11) U(12) A(13) A(14) G(15) U(16)`\n\n为确保外显子2被跳过，该生物学家必须引入一个单点突变，以最大程度地破坏此 3' 剪接受体位点的功能，从而导致剪接体使用下游的下一个可用受体位点。根据剪接位点识别的原理，下列哪个单点突变最有可能实现这一结果？\n\nA. U5C\n\nB. A7G\n\nC. G10A\n\nD. G11C\n\nE. C4G", "solution": "我们的目标是破坏内含子-外显子边界处的 3' 剪接受体位点，以迫使外显子2被跳过。在真核生物的 pre-mRNA 剪接中，3' 受体位点由一个多嘧啶序列组成，其后紧跟着一个几乎不变的二核苷酸 $\\text{AG}$，该二核苷酸位于内含子最后两个核苷酸位置，相对于外显子起始位置为-2和-1。外显子通常在+1位置开始，通常是$G$，但其保守性不如 $\\text{AG}$。\n\n在给定的序列中：\n5'-... U U C C U U A C A G | G U A A G U ...-3'\n编号为 U(1) U(2) C(3) C(4) U(5) U(6) A(7) C(8) A(9) G(10) | G(11) U(12) A(13) A(14) G(15) U(16)，\n不变的受体 $\\text{AG}$ 位于 A(9) 和 G(10) 位置，紧邻外显子起始位点 G(11) 的上游。\n\n为了最大程度地破坏 3' 受体并迫使剪接体使用下游的下一个受体位点，最佳策略是破坏这个不变的 $\\text{AG}$。在这些选项中：\n\n- U5C：将多嘧啶序列中的一个嘧啶转换为另一个嘧啶；影响极小。\n- A7G：将序列中的一个嘌呤变为另一个嘌呤；没有消除关键的 $\\text{AG}$，其破坏性小于突变不变的二核苷酸。\n- G10A：将位置 9–10 处不变的 $\\text{AG}$ 转换为 $\\text{AA}$，从而破坏了剪接体（包括 U2AF35）识别所必需的 $\\text{AG}$，这最有可能阻止该受体位点的使用。\n- G11C：改变外显子的第一个核苷酸（+1位置）。虽然+1位置的$G$很常见，但它不是不变的；上游的 $\\text{AG}$ 仍然完整，因此该位点很可能仍会被使用。\n- C4G：在多嘧啶序列中引入一个嘌呤，削弱了该序列，但其严重程度不如破坏不变的 $\\text{AG}$。\n\n因此，突变G10A（选项C）最直接地破坏了 3' 剪接受体位点处的不变的 $\\text{AG}$，最有可能通过将剪接体重新定向到下游的下一个受体来迫使外显子跳过。", "answer": "$$\\boxed{C}$$", "id": "2036728"}, {"introduction": "对于基因组规模的序列数据，手动分析基因结构是不现实的。生物信息学家们开发了强大的计算工具，其中隐马尔可夫模型（HMM）是基因识别和序列注释的基石。本练习 [@problem_id:2388400] 提供了一个简化的HMM，让你通过编程实现维特比算法（Viterbi algorithm）来解码最可能的隐藏状态序列，从而在DNA序列中自动识别外显子、内含子和剪接位点等特征。这有助于你理解如何运用概率模型解决复杂的生物学问题。", "problem": "给定一个概率序列模型的形式化规约，用于标记字母表 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 上的脱氧核糖核酸核苷酸字符串，其隐状态表示外显子样背景、内含子样背景和隐蔽剪接位点位置。该模型是一个隐马尔可夫模型 (Hidden Markov Model (HMM))，其隐状态集 $Q=\\{X,I,D_1,D_2,A_1,A_2\\}$ 定义如下：$X$ 表示外显子样背景，$I$ 表示内含子样背景，$D_1$ 和 $D_2$ 是隐蔽供体剪接位点基序的第一个和第二个位置，$A_1$ 和 $A_2$ 是隐蔽受体剪接位点基序的第一个和第二个位置。初始状态分布由 $\\pi(X)=0.5$, $\\pi(I)=0.5$ 以及 $\\pi(D_1)=\\pi(D_2)=\\pi(A_1)=\\pi(A_2)=0$ 给出。\n\n在以隐状态为条件的假设下，发射是独立同分布的。对于 $s\\in Q$，在 $\\Sigma$ 上的发射概率规定如下。对于 $X$：$P(\\text{A}\\mid X)=0.15$, $P(\\text{C}\\mid X)=0.35$, $P(\\text{G}\\mid X)=0.35$, $P(\\text{T}\\mid X)=0.15$。对于 $I$：$P(\\text{A}\\mid I)=0.35$, $P(\\text{C}\\mid I)=0.15$, $P(\\text{G}\\mid I)=0.15$, $P(\\text{T}\\mid I)=0.35$。对于 $D_1$：$P(\\text{G}\\mid D_1)=0.9$，对于 $b\\in\\{\\text{A},\\text{C},\\text{T}\\}$，$P(b\\mid D_1)=\\frac{1-0.9}{3}$。对于 $D_2$：$P(\\text{T}\\mid D_2)=0.9$，对于 $b\\in\\{\\text{A},\\text{C},\\text{G}\\}$，$P(b\\mid D_2)=\\frac{1-0.9}{3}$。对于 $A_1$：$P(\\text{A}\\mid A_1)=0.9$，对于 $b\\in\\{\\text{C},\\text{G},\\text{T}\\}$，$P(b\\mid A_1)=\\frac{1-0.9}{3}$。对于 $A_2$：$P(\\text{G}\\mid A_2)=0.9$，对于 $b\\in\\{\\text{A},\\text{C},\\text{T}\\}$，$P(b\\mid A_2)=\\frac{1-0.9}{3}$。\n\n基线转移结构强制了生物学上一致的剪接流。令 $p_X$ 表示从 $X$ 启动一个隐蔽供体的基线概率，令 $p_I$ 表示从 $I$ 启动一个隐蔽受体的基线概率。非零基线转移如下：\n- 从 $X$：$P(X\\to X)=1-p_X$, $P(X\\to D_1)=p_X$。\n- 从 $D_1$：$P(D_1\\to D_2)=1$。\n- 从 $D_2$：$P(D_2\\to I)=1$。\n- 从 $I$：$P(I\\to I)=1-p_I$, $P(I\\to A_1)=p_I$。\n- 从 $A_1$：$P(A_1\\to A_2)=1$。\n- 从 $A_2$：$P(A_2\\to X)=1$。\n所有其他转移的概率为 $0$。基线值为 $p_X=0.02$ 和 $p_I=0.02$。\n\n一个应激调制因子 $m\\ge 1$ 仅修改转移 $X\\to D_1$ 和 $I\\to A_1$，方法是将这些基线概率乘以 $m$，然后将每个受影响的出向分布重新归一化以使其和为 $1$。具体来说，对于状态 $X$，其到 $\\{X,\\,D_1\\}$ 的出向基线概率为 $\\{1-p_X,\\,p_X\\}$，则应激调制的概率 $\\{P_m(X\\to X),\\,P_m(X\\to D_1)\\}$ 为\n$$\nP_m(X\\to D_1)=\\frac{m\\,p_X}{(1-p_X)+m\\,p_X},\\qquad\nP_m(X\\to X)=\\frac{1-p_X}{(1-p_X)+m\\,p_X}.\n$$\n对于状态 $I$，其到 $\\{I,\\,A_1\\}$ 的出向基线概率为 $\\{1-p_I,\\,p_I\\}$，则应激调制的概率 $\\{P_m(I\\to I),\\,P_m(I\\to A_1)\\}$ 为\n$$\nP_m(I\\to A_1)=\\frac{m\\,p_I}{(1-p_I)+m\\,p_I},\\qquad\nP_m(I\\to I)=\\frac{1-p_I}{(1-p_I)+m\\,p_I}.\n$$\n\n对于一个观测序列 $x_0x_1\\ldots x_{n-1}$（其中 $x_t\\in\\Sigma$）和一个指定的 $m$，将 $Q^n$ 中的最大概率隐状态路径 $q_0q_1\\ldots q_{n-1}$ 定义为在上述应激调制的转移概率和发射概率下，使联合概率 $P(q_0)\\,\\prod_{t=1}^{n-1}P(q_t\\mid q_{t-1})\\cdot\\prod_{t=0}^{n-1}P(x_t\\mid q_t)$ 最大化的任何路径。如果存在多个最大化路径，则通过在候选路径首次出现差异的位置应用全序 $X\\lt I\\lt D_1\\lt D_2\\lt A_1\\lt A_2$，选择字典序最小的路径来打破平局。\n\n你的任务是，对于每个提供的测试用例，计算上述模型下的唯一最大概率隐状态路径，并返回隐蔽剪接位点激活的索引集合。具体来说，对于每个序列和应激因子 $m$，输出所有满足 $q_t\\in\\{D_1,A_1\\}$ 的从零开始的索引 $t$ 的列表。\n\n测试套件。使用以下四个测试用例，每个用例包含一个 $\\Sigma$ 上的核苷酸字符串和一个应激因子 $m$：\n- 用例 1：序列 $s_1=\\text{\"CCCCCCCCCCCC\"}$, $m=3$。\n- 用例 2：序列 $s_2=\\text{\"GCCGTAAATTTAGCG\"}$, $m=2$。\n- 用例 3：序列 $s_3=\\text{\"GCCGTAAATTTAGCG\"}$, $m=1$。\n- 用例 4：序列 $s_4=\\text{\"ACGTGTATATAGG\"}$, $m=3$。\n\n最终输出格式。你的程序应该生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的列表组成的列表，不含空格。每个内部列表按给定顺序对应一个测试用例，并包含按严格递增顺序排列的从零开始的索引。例如，一个输出可能看起来像 $[\\,[0,5],[\\,],[2]\\,]$，但具体的列表由上述计算针对指定的测试套件确定。", "solution": "所提出的问题是计算生物学中一个定义明确的任务，要求对于给定的观测核苷酸序列，确定隐马尔可夫模型 (HMM) 中最可能的隐状态序列。这是一个使用 Viterbi 算法解决的经典问题。问题陈述是完整的、有科学依据的，并且内部一致。它提供了 HMM 所需的所有参数，包括状态集、初始状态概率、发射概率以及一个调制转移概率的规则。它还指定了一个明确的目标和一个确定性的平局打破程序，从而保证了唯一解的存在。因此，该问题是有效的，我们将继续进行形式化的求解。\n\n解法的核心是 Viterbi 算法，这是一种动态规划方法，旨在找到能够生成一个观测序列的单一最可能的隐状态路径，即所谓的 Viterbi 路径。为了避免在乘以许多小概率时常见的数值下溢问题，所有计算都将在对数空间中进行。目标是找到路径 $\\mathbf{q} = q_0, q_1, \\ldots, q_{n-1}$，使得联合对数概率最大化：\n$$ \\log P(\\mathbf{q}, \\mathbf{x}) = \\log \\pi(q_0) + \\sum_{t=1}^{n-1} \\log P(q_t \\mid q_{t-1}) + \\sum_{t=0}^{n-1} \\log P(x_t \\mid q_t) $$\n其中 $\\mathbf{x} = x_0, x_1, \\ldots, x_{n-1}$ 是观测序列，$\\pi$ 是初始状态分布，$P(q_t \\mid q_{t-1})$ 是转移概率，$P(x_t \\mid q_t)$ 是发射概率。\n\n设状态集为 $Q = \\{X, I, D_1, D_2, A_1, A_2\\}$，我们将其分别映射到整数索引 $\\{0, 1, 2, 3, 4, 5\\}$，并保留指定的字典序。算法流程如下：\n\n首先，我们根据问题规约，在对数空间中建立 HMM 参数。\n初始对数概率为每个状态 $s \\in Q$ 的 $\\log \\pi_s$。发射对数概率为每个状态 $s \\in Q$ 和每个核苷酸 $b \\in \\Sigma$ 的 $\\log e_s(b) = \\log P(b \\mid s)$。转移对数概率 $\\log a_{s' \\to s} = \\log P(s \\mid s')$，对于受影响的转移（$X \\to X, X \\to D_1, I \\to I, I \\to A_1$）使用应激调制因子 $m$ 计算，而其他转移则是固定的。概率 $0$ 在对数空间中变为 $-\\infty$。\n\n我们为动态规划过程定义两个表格：\n1. $\\delta_t(s)$：在时间 $t$ 以状态 $s$ 结束，并已生成观测序列前缀 $x_0, \\ldots, x_t$ 的任何路径的最大对数概率。\n2. $\\psi_t(s)$：在时间 $t-1$ 的状态，它使得在时间 $t$ 到达状态 $s$ 的概率最大化。这是用于路径重构的回溯指针。\n\nViterbi 算法包含三个步骤：初始化、递推以及终止与回溯。\n\n**1. 初始化 ($t=0$):**\n对于每个状态 $s \\in Q$，我们计算观测到第一个字符 $x_0$ 的初始对数概率：\n$$ \\delta_0(s) = \\log \\pi_s + \\log e_s(x_0) $$\n在 $t=0$ 时的回溯指针是未定义的。\n\n**2. 递推 ($t=1, \\ldots, n-1$):**\n对于序列中的每个后续位置 $t$ 和每个状态 $s \\in Q$，我们根据前一步 $t-1$ 的值计算 $\\delta_t(s)$ 和 $\\psi_t(s)$：\n$$ \\delta_t(s) = \\log e_s(x_t) + \\max_{s' \\in Q} (\\delta_{t-1}(s') + \\log a_{s' \\to s}) $$\n$$ \\psi_t(s) = \\arg\\max_{s' \\in Q} (\\delta_{t-1}(s') + \\log a_{s' \\to s}) $$\n问题指定了一个平局打破规则：如果多个前驱状态 $s'$ 产生相同的最大概率，则必须选择字典序最小（即整数索引最小）的那个。这可以通过对按索引 $\\{0, 1, \\dots, 5\\}$ 排序的状态评估 $\\arg\\max$ 并选择第一个达到最大值的状态来解决。\n\n**3. 终止与路径重构:**\n在填完表格直到最终位置 $t=n-1$ 后，最可能路径的对数概率是 $\\max_{s \\in Q} \\delta_{n-1}(s)$。该路径的最终状态 $q_{n-1}^*$ 通过以下方式找到：\n$$ q_{n-1}^* = \\arg\\max_{s \\in Q} \\delta_{n-1}(s) $$\n再次应用平局打破规则。最优路径的其余部分通过使用存储的回溯指针从这个最终状态开始回溯来找到：\n$$ q_{t-1}^* = \\psi_t(q_t^*) \\quad \\text{for } t = n-1, \\ldots, 1 $$\n\n最后，在重构出唯一最大概率路径 $q_0^*, \\ldots, q_{n-1}^*$ 后，我们遍历该路径并收集所有状态 $q_t^*$ 为 $D_1$ 或 $A_1$ 的从零开始的索引 $t$。这些索引按递增顺序排序，构成给定测试用例的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the HMM problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        (\"CCCCCCCCCCCC\", 3),\n        (\"GCCGTAAATTTAGCG\", 2),\n        (\"GCCGTAAATTTAGCG\", 1),\n        (\"ACGTGTATATAGG\", 3),\n    ]\n\n    results = []\n    for sequence, m in test_cases:\n        result = run_viterbi(sequence, m)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef run_viterbi(sequence, m):\n    \"\"\"\n    Computes the most probable hidden state path for a sequence using the Viterbi algorithm.\n\n    Args:\n        sequence (str): The observed nucleotide sequence.\n        m (float): The stress modulation factor.\n\n    Returns:\n        list: A sorted list of zero-based indices where the path state is D1 or A1.\n    \"\"\"\n    # Define HMM parameters\n    states = {'X': 0, 'I': 1, 'D1': 2, 'D2': 3, 'A1': 4, 'A2': 5}\n    num_states = len(states)\n    alphabet = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    n = len(sequence)\n\n    # Initial Probabilities (pi)\n    pi = np.array([0.5, 0.5, 0.0, 0.0, 0.0, 0.0])\n    with np.errstate(divide='ignore'):\n        log_pi = np.log(pi)\n\n    # Emission Probabilities (E)\n    p_other = (1.0 - 0.9) / 3.0\n    emission_probs = np.array([\n        [0.15, 0.35, 0.35, 0.15],         # X\n        [0.35, 0.15, 0.15, 0.35],         # I\n        [p_other, p_other, 0.9, p_other],  # D1\n        [p_other, p_other, p_other, 0.9],  # D2\n        [0.9, p_other, p_other, p_other],  # A1\n        [p_other, p_other, 0.9, p_other]   # A2\n    ])\n    with np.errstate(divide='ignore'):\n        log_emission = np.log(emission_probs)\n\n    # Transition Probabilities (A)\n    p_X, p_I = 0.02, 0.02\n    \n    denom_X = (1 - p_X) + m * p_X\n    p_X_to_D1_m = (m * p_X) / denom_X\n    p_X_to_X_m = (1 - p_X) / denom_X\n\n    denom_I = (1 - p_I) + m * p_I\n    p_I_to_A1_m = (m * p_I) / denom_I\n    p_I_to_I_m = (1 - p_I) / denom_I\n\n    transition_probs = np.zeros((num_states, num_states))\n    transition_probs[states['X'], states['X']] = p_X_to_X_m\n    transition_probs[states['X'], states['D1']] = p_X_to_D1_m\n    transition_probs[states['D1'], states['D2']] = 1.0\n    transition_probs[states['D2'], states['I']] = 1.0\n    transition_probs[states['I'], states['I']] = p_I_to_I_m\n    transition_probs[states['I'], states['A1']] = p_I_to_A1_m\n    transition_probs[states['A1'], states['A2']] = 1.0\n    transition_probs[states['A2'], states['X']] = 1.0\n    \n    with np.errstate(divide='ignore'):\n        log_transition = np.log(transition_probs)\n\n    # Viterbi Algorithm\n    delta = np.full((n, num_states), -np.inf)\n    psi = np.zeros((n, num_states), dtype=int)\n\n    # Initialization (t=0)\n    obs_idx_0 = alphabet[sequence[0]]\n    for s in range(num_states):\n        delta[0, s] = log_pi[s] + log_emission[s, obs_idx_0]\n\n    # Recurrence (t=1 to n-1)\n    for t in range(1, n):\n        obs_idx = alphabet[sequence[t]]\n        for s in range(num_states):\n            probs_from_prev = delta[t - 1, :] + log_transition[:, s]\n            max_prob = np.max(probs_from_prev)\n            \n            if max_prob == -np.inf:\n                # This path is impossible, delta remains -inf\n                continue\n            \n            # Tie-breaking: np.where returns sorted indices, [0] selects the smallest\n            best_prev_state = np.where(probs_from_prev == max_prob)[0][0]\n            \n            delta[t, s] = max_prob + log_emission[s, obs_idx]\n            psi[t, s] = best_prev_state\n\n    # Termination and Backtracking\n    path = np.zeros(n, dtype=int)\n    final_state_probs = delta[n - 1, :]\n    max_final_prob = np.max(final_state_probs)\n    # Tie-breaking for the final state\n    path[n - 1] = np.where(final_state_probs == max_final_prob)[0][0]\n\n    for t in range(n - 2, -1, -1):\n        path[t] = psi[t + 1, path[t + 1]]\n\n    # Extract splice site activation indices\n    D1_idx = states['D1']\n    A1_idx = states['A1']\n    splice_indices = [t for t, state_idx in enumerate(path) if state_idx in (D1_idx, A1_idx)]\n    \n    return splice_indices\n\nsolve()\n```", "id": "2388400"}]}