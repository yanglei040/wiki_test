{"hands_on_practices": [{"introduction": "转录过程始于转录因子（TF）在浩瀚的基因组中寻找其特异性的DNA结合位点。本练习将这一复杂的生物过程简化为一个可计算的模型，即沿着DNA链的一维随机游走。通过构建和求解一个连续时间马尔可夫链模型，您将计算转录因子在从DNA上解离之前成功找到其靶点的概率和平均时间 [@problem_id:2436198]。这项实践旨在帮助您深入理解分子事件的随机性，并掌握分析蛋白质-DNA相互作用的基础生物物理建模方法。", "problem": "一个沿脱氧核糖核酸（DNA）聚合物扫描的转录因子可以被理想化为在一个离散的格点 $\\{0,1,\\dots,L-1\\}$ 上的连续时间一维随机行走。在索引 $s^{\\star}$ 处有一个唯一的靶标位点；当转录因子到达 $s^{\\star}$ 时，搜索成功终止。从任何非靶标位点 $i$，该因子尝试以速率 $k_{\\ell}$ 向左移动一个位点，以速率 $k_{r}$ 向右移动一个位点，并且它能以速率 $k_{\\mathrm{off}}$ 从DNA上不可逆地解离（脱离）。位于 $i=0$ 和 $i=L-1$ 的边界是反射的：在 $i=0$ 处向左的移动尝试不会改变位置，在 $i=L-1$ 处向右的移动尝试也不会改变位置；这些反射的移动不会发生，应被建模为这些跃迁的缺失，而非自跃迁。靶标位点 $s^{\\star}$ 是成功的吸收位点，意味着一旦到达，过程立即停止，此后不再发生解离。所有速率均为常数，单位为 $\\mathrm{s}^{-1}$，时间必须以秒为单位报告。\n\n对于一个给定的起始位点 $i_{0}$，定义以下两个量：\n- 概率 $p(i_{0})$，指过程在解离前到达 $s^{\\star}$ 的概率。\n- 条件平均搜索时间 $m(i_{0}) = \\mathbb{E}[T \\mid \\text{在解离前到达 } s^{\\star}, X(0)=i_{0}]$，其中 $T$ 是到达 $s^{\\star}$ 的时间， $X(0)$ 是初始位置。如果 $p(i_{0})=0$，则定义 $m(i_{0})=0$。\n\n假设在下述所有测试用例中，滑动速率是对称的 $k_{\\ell}=k_{r}=k$。你的程序必须为每个测试用例计算一对实数 $\\big(p(i_{0}), m(i_{0})\\big)$，其中 $m(i_{0})$ 以秒表示。每个实数必须四舍五入到小数点后六位。\n\n测试套件参数如下，每个都以元组 $(L, s^{\\star}, i_{0}, k, k_{\\mathrm{off}})$ 的形式指定，所有整数和实数都明确给出：\n- 用例 A（一般内部靶标）：$(L,s^{\\star},i_{0},k,k_{\\mathrm{off}}) = (21, 10, 0, 100.0, 1.0)$。\n- 用例 B（从靶标开始）：$(L,s^{\\star},i_{0},k,k_{\\mathrm{off}}) = (21, 10, 10, 100.0, 1.0)$。\n- 用例 C（强解离下的远距离靶标）：$(L,s^{\\star},i_{0},k,k_{\\mathrm{off}}) = (21, 20, 0, 50.0, 50.0)$。\n- 用例 D（无解离的最小格点）：$(L,s^{\\star},i_{0},k,k_{\\mathrm{off}}) = (2, 1, 0, 2.0, 0.0)$。\n\n你的程序应该生成单行输出，按顺序包含汇总的结果，形式为用方括号括起的逗号分隔列表，无空格。列表必须按上述顺序列出每个测试用例的两个浮点数，即 $[p(\\text{A}), m(\\text{A}), p(\\text{B}), m(\\text{B}), p(\\text{C}), m(\\text{C}), p(\\text{D}), m(\\text{D})]$，其中每个浮点数都四舍五入到小数点后六位。", "solution": "在尝试任何解决方案之前，对问题陈述进行有效性评估。\n\n步骤 1：提取给定条件\n- 过程：连续时间一维随机行走。\n- 状态空间：离散格点 $\\mathcal{S} = \\{0, 1, \\dots, L-1\\}$。\n- 靶标位点：唯一的吸收位点 $s^{\\star} \\in \\mathcal{S}$。\n- 起始位点：$i_{0} \\in \\mathcal{S}$。\n- 从任意非靶标位点 $i$ 的跃迁速率：\n    - 到位点 $i-1$：速率 $k_{\\ell}$。\n    - 到位点 $i+1$：速率 $k_{r}$。\n    - 解离（失败）：速率 $k_{\\mathrm{off}}$。\n- 非靶标边界的边界条件：\n    - 在 $i=0$ 处：反射。向左的移动尝试不会发生。总出射速率为 $k_r + k_{\\mathrm{off}}$。\n    - 在 $i=L-1$ 处：反射。向右的移动尝试不会发生。总出射速率为 $k_\\ell + k_{\\mathrm{off}}$。\n- 特殊条件：对称滑动，$k_{\\ell} = k_{r} = k$。\n- 待计算的量：\n    - $p(i_{0})$：从 $i_{0}$ 出发，在解离前到达 $s^{\\star}$ 的概率。\n    - $m(i_{0})$：在搜索成功的前提下，到达 $s^{\\star}$ 的条件平均搜索时间。\n- 特殊定义：如果 $p(i_{0})=0$，则 $m(i_{0})=0$。\n- 测试用例 $(L, s^{\\star}, i_{0}, k, k_{\\mathrm{off}})$：\n    - A: $(21, 10, 0, 100.0, 1.0)$\n    - B: $(21, 10, 10, 100.0, 1.0)$\n    - C: $(21, 20, 0, 50.0, 50.0)$\n    - D: $(2, 1, 0, 2.0, 0.0)$\n\n步骤 2：使用提取的给定条件进行验证\n- **科学依据**：该问题描述了一个带“杀戮”的连续时间马尔可夫链，这是统计物理和计算生物学中的一个标准和基础模型，用于研究如蛋白质-DNA靶标搜索（Berg-von Hippel模型）等过程。它是科学上合理的。\n- **适定性**：该问题要求计算成功概率和到达吸收态的条件平均首达时间。对于一个有限态马尔可夫过程，这些量是良定义的，并能导出一个唯一的、稳定的解，该解可通过求解一个线性方程组获得。\n- **客观性**：问题陈述使用了精确、无歧义的数学和物理术语。参数均被明确提供。\n\n步骤 3：结论与行动\n- **结论**：该问题是有效的。它是生物物理建模中的一个标准的、适定的问题。未发现任何缺陷。\n- **行动**：继续进行完整、合理的求解。\n\n我们现在将推导控制任意起始位点 $i \\in \\mathcal{S}$ 的成功概率 $p(i)$ 和条件平均搜索时间 $m(i)$ 的线性方程组。\n\n**1. 成功概率 $p(i)$**\n\n设 $p_i$ 表示从位点 $i$ 出发最终到达靶标位点 $s^{\\star}$ 的概率。根据定义，如果过程从靶标开始，则已成功，因此我们有边界条件 $p_{s^{\\star}} = 1$。对于任意非靶标位点 $i \\neq s^{\\star}$，我们可以基于第一步的结果写出 $p_i$ 的主方程。离开位点 $i$ 的总速率为 $\\lambda_i$。\n- 对于内部位点 $i \\in \\{1, \\dots, L-2\\}$，$\\lambda_i = k+k+k_{\\mathrm{off}} = 2k+k_{\\mathrm{off}}$。\n- 对于边界位点 $i \\in \\{0, L-1\\}$，$\\lambda_i = k+k_{\\mathrm{off}}$。\n\n以第一步的移动为条件，$p_i$ 是从后续位点出发的成功概率的加权平均值：\n$p_i = \\sum_{j} \\frac{k_{i \\to j}}{\\lambda_i} p_j$。\n跃迁到解离态的成功概率为 $0$。\n\n对于内部位点 $i \\in \\{1, \\dots, L-2\\}$ (其中 $i \\neq s^{\\star}$):\n$$ (2k+k_{\\mathrm{off}})p_i = k p_{i-1} + k p_{i+1} $$\n对于边界 $i=0$ (如果 $0 \\neq s^{\\star}$):\n$$ (k+k_{\\mathrm{off}})p_0 = k p_1 $$\n对于边界 $i=L-1$ (如果 $L-1 \\neq s^{\\star}$):\n$$ (k+k_{\\mathrm{off}})p_{L-1} = k p_{L-2} $$\n\n这些关系构成了一个包含 $L-1$ 个线性方程的方程组，用于求解 $L-1$ 个未知概率 $\\{p_i\\}_{i \\in \\mathcal{S} \\setminus \\{s^{\\star}\\}}$。该系统可以写成矩阵形式 $A\\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{p}$ 是未知概率的向量。矩阵 $A$ 是三对角的，向量 $\\mathbf{b}$ 包含来自于向已知状态 $p_{s^\\star}=1$ 的跃迁项。一个特殊情况是当 $k_{\\mathrm{off}}=0$ 时；在这种情况下，解离不可能发生，所以粒子最终必然找到靶标，得到对所有 $i$ 都有 $p_i = 1$。\n\n**2. 条件平均搜索时间 $m(i)$**\n\n设 $m_i$ 为从 $i$ 出发，在搜索成功的前提下，到达 $s^{\\star}$ 的条件平均时间。根据定义，$m_{s^{\\star}}=0$。为了进行严格的推导，首先求解未归一化的条件平均时间 $M_i = p_i m_i$ 会比较方便。这个量遵循一个相似的线性方程组，但带有一个与每个位点的平均停留时间相关的非齐次源项。\n\n对于任意位点 $i \\neq s^{\\star}$，$M_i$ 的控制方程是：\n$$ \\lambda_i M_i = p_i + \\sum_{j \\text{ (neighbor)}} k_{i \\to j} M_j $$\n该方程表明，一个状态的“成功时间”流出量等于停留在该状态的贡献（平均停留时间 $1/\\lambda_i$，由成功概率 $p_i$ 加权）加上从邻近状态流入的成功时间通量。\n\n对于内部位点 $i \\in \\{1, \\dots, L-2\\}$ (其中 $i \\neq s^{\\star}$):\n$$ (2k+k_{\\mathrm{off}})M_i = p_i + k M_{i-1} + k M_{i+1} \\implies k M_{i-1} - (2k+k_{\\mathrm{off}})M_i + k M_{i+1} = -p_i $$\n对于边界 $i=0$ (如果 $0 \\neq s^{\\star}$):\n$$ (k+k_{\\mathrm{off}})M_0 = p_0 + k M_1 \\implies -(k+k_{\\mathrm{off}})M_0 + k M_1 = -p_0 $$\n对于边界 $i=L-1$ (如果 $L-1 \\neq s^{\\star}$):\n$$ (k+k_{\\mathrm{off}})M_{L-1} = p_{L-1} + k M_{L-2} \\implies k M_{L-2} - (k+k_{\\mathrm{off}})M_{L-1} = -p_{L-1} $$\n\n这是一个包含 $L-1$ 个线性方程的方程组，用于求解未知量 $\\{M_i\\}_{i \\in \\mathcal{S} \\setminus \\{s^{\\star}\\}}$。关键地是，左侧的系数矩阵与概率计算中的矩阵 $A$ 相同。右侧的向量现在就是解向量 $\\mathbf{p}$（对于相应的未知位点）的负值。边界条件是 $M_{s^{\\star}} = p_{s^{\\star}}m_{s^{\\star}} = 1 \\cdot 0 = 0$。\n\n**算法**\n求解 $(p(i_0), m(i_0))$ 的步骤如下：\n1.  对于给定的测试用例 $(L, s^{\\star}, i_{0}, k, k_{\\mathrm{off}})$，检查平凡的起始条件 $i_{0} = s^{\\star}$。若成立，则结果为 $(1.0, 0.0)$。\n2.  如果 $k_{\\mathrm{off}} = 0$，则设置所有 $p_i = 1$。否则，针对概率 $\\{p_i\\}_{i \\neq s^{\\star}}$ 构建 $(L-1) \\times (L-1)$ 矩阵 $A$ 和右侧向量 $\\mathbf{b}_p$。求解线性系统 $A\\mathbf{p} = \\mathbf{b}_p$。\n3.  使用计算出的未知位点的概率构建右侧向量 $\\mathbf{b}_M = -\\mathbf{p}$。\n4.  求解线性系统 $A\\mathbf{M} = \\mathbf{b}_M$ 以求得未归一化时间 $\\{M_i\\}_{i \\neq s^{\\star}}$。矩阵 $A$ 与步骤2中的相同。\n5.  对于指定的起始位点 $i_{0}$，计算条件平均搜索时间 $m(i_{0}) = M_{i_0} / p(i_{0})$。如果 $p(i_0)=0$，则根据定义 $m(i_0)=0$。\n6.  返回数对 $(p(i_{0}), m(i_{0}))$。\n\n此过程将为每个测试用例实现。", "answer": "```python\nimport numpy as np\n\ndef _calculate_pair(L, s_star, i0, k, k_off):\n    \"\"\"\n    Calculates the success probability and conditional mean search time for a given\n    set of parameters by solving the corresponding systems of linear equations.\n\n    Args:\n        L (int): The number of sites on the DNA lattice, {0, 1, ..., L-1}.\n        s_star (int): The index of the target site.\n        i0 (int): The index of the starting site.\n        k (float): The symmetric hopping rate (k_l = k_r = k).\n        k_off (float): The dissociation rate.\n\n    Returns:\n        tuple[float, float]: A pair (p(i0), m(i0)) containing the success probability\n                             and the conditional mean search time.\n    \"\"\"\n    # Trivial case: starting at the target site.\n    if i0 == s_star:\n        return 1.0, 0.0\n\n    # Define the set of sites with unknown probabilities and times.\n    unknown_sites = [i for i in range(L) if i != s_star]\n    site_to_idx = {site: i for i, site in enumerate(unknown_sites)}\n    N = len(unknown_sites)\n\n    # =========================================================================\n    # Step 1: Solve for success probabilities p_i\n    # =========================================================================\n    p_vec_full = np.zeros(L)\n    \n    # Case with no dissociation: success is guaranteed.\n    if k_off == 0:\n        p_vec_full.fill(1.0)\n    else:\n        # Construct the linear system A*p = b for p_i where i != s_star.\n        A = np.zeros((N, N))\n        b = np.zeros(N)\n\n        for i in unknown_sites:\n            j = site_to_idx[i]\n            \n            # The diagonal element is the negative total rate of leaving site i.\n            rate_out = k_off\n            if i > 0: rate_out += k\n            if i  L - 1: rate_out += k\n            A[j, j] = -rate_out\n\n            # Off-diagonal elements represent transitions from neighbors.\n            # If a neighbor is the target, its contribution (k*p_s_star) goes to the RHS.\n            if i  0:\n                pred = i - 1\n                if pred == s_star:\n                    b[j] -= k\n                else:\n                    A[j, site_to_idx[pred]] = k\n            \n            if i  L - 1:\n                succ = i + 1\n                if succ == s_star:\n                    b[j] -= k\n                else:\n                    A[j, site_to_idx[succ]] = k\n\n        p_sol = np.linalg.solve(A, b)\n\n        # Populate the full probability vector.\n        p_vec_full[s_star] = 1.0\n        for i, val in zip(unknown_sites, p_sol):\n            p_vec_full[i] = val\n    \n    p_i0 = p_vec_full[i0]\n    # If success is impossible, mean time is 0 by definition.\n    if p_i0 == 0:\n        return 0.0, 0.0\n\n    # =========================================================================\n    # Step 2: Solve for unnormalized mean times M_i = p_i * m_i\n    # =========================================================================\n    # The matrix A is identical to the one for probabilities.\n    # Re-construct it if it wasn't built (for k_off=0 case).\n    if k_off  0:\n        pass  # A is already built\n    else:\n        A = np.zeros((N, N))\n        for i in unknown_sites:\n            j = site_to_idx[i]\n            rate_out = 0.0\n            if i  0: rate_out += k\n            if i  L - 1: rate_out += k\n            A[j, j] = -rate_out\n            if i  0 and (i - 1) != s_star: A[j, site_to_idx[i-1]] = k\n            if i  L - 1 and (i + 1) != s_star: A[j, site_to_idx[i+1]] = k\n\n    # The RHS is -p_i for each unknown site.\n    p_unknowns = np.array([p_vec_full[i] for i in unknown_sites])\n    b_M = -p_unknowns\n\n    M_sol = np.linalg.solve(A, b_M)\n\n    M_vec_full = np.zeros(L)\n    # M_s_star = 0 by definition.\n    for i, val in zip(unknown_sites, M_sol):\n        M_vec_full[i] = val\n\n    # =========================================================================\n    # Step 3: Calculate conditional mean times m_i = M_i / p_i\n    # =========================================================================\n    m_i0 = M_vec_full[i0] / p_i0\n    \n    return p_i0, m_i0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: (L, s_star, i0, k, k_off)\n        (21, 10, 0, 100.0, 1.0),\n        # Case B\n        (21, 10, 10, 100.0, 1.0),\n        # Case C\n        (21, 20, 0, 50.0, 50.0),\n        # Case D\n        (2, 1, 0, 2.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, s_star, i0, k, k_off = case\n        p, m = _calculate_pair(L, s_star, i0, k, k_off)\n        results.extend([p, m])\n\n    # Format output as a list of strings rounded to 6 decimal places.\n    formatted_results = [f\"{x:.6f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2436198"}, {"introduction": "在转录因子成功结合并招募RNA聚合酶II（Pol II）后，Pol II必须“清空”启动子区域以开始有效的延伸。在转录活跃的基因上，这个步骤常常成为一个瓶颈，导致Pol II分子在启动子附近排起长队。本练习将运用排队论这一强大的数学工具，将Pol II的到达和启动子清空过程分别看作顾客的到达和服务，从而将该过程抽象为一个M/M/1排队模型 [@problem_id:2436273]。通过解决这个问题，您将学会如何量化这种转录“交通堵塞”的概率，并洞察决定转录效率的动力学原理。", "problem": "一个高度活跃的真核基因表现出启动子近端暂停和清除现象，这为核糖核酸（RNA）聚合酶II造成了瓶颈。将启动子近端区域建模为一个单一服务通道，该通道一次只允许一个聚合酶进入有效延伸阶段。此模型基于以下假设，将转录动力学与一个经典排队模型联系起来。聚合酶的起始尝试遵循泊松过程，其速率为 $\\lambda$（每分钟到达数）。一个已结合的聚合酶的启动子近端清除时间服从指数分布，其速率为 $\\mu$（每分钟服务数）。当启动子近端位点被占据时，到达的聚合酶会在启动子近端区域排成一个先进先出的队列；这个启动子近端系统中的聚合酶数量（包括正在清除的一个和正在等待的其他聚合酶）被建模为一个时齐连续时间马尔可夫链，其对于所有状态出生率恒为 $\\lambda$，对于所有状态 $n \\ge 1$ 死亡率恒为 $\\mu$。假设系统在稳态下运行，且满足 $\\lambda  \\mu$。\n\n将“交通堵塞”定义为在随机选择的时刻，启动子近端系统（包括正在清除的那个）中至少有 $k$ 个聚合酶的事件。从生灭过程的基本定义和该系统的稳态（细致）平衡出发，推导交通堵塞的稳态概率作为 $\\lambda$、$\\mu$ 和 $k$ 的函数的解析表达式。然后，使用生物学上合理的参数 $\\lambda = 3.5$ min$^{-1}$、$\\mu = 4.0$ min$^{-1}$ 和 $k = 6$ 计算该表达式的值。将最终答案表示为无单位的小数，并四舍五入到四位有效数字。", "solution": "在尝试任何解答之前，对提出的问题进行严格验证。\n\n逐字提取已知条件如下：\n1.  系统是一个单一服务通道，代表真核基因的启动子近端区域。\n2.  聚合酶起始尝试是一个速率为 $\\lambda$ 的泊松过程。\n3.  启动子近端清除时间服从速率为 $\\mu$ 的指数分布。\n4.  当位点被占据时，形成一个先进先出的队列。\n5.  系统被建模为一个时齐连续时间马尔可夫链。\n6.  对所有状态，出生率是恒定的 $\\lambda$。\n7.  对所有状态 $n \\ge 1$，死亡率是恒定的 $\\mu$。\n8.  系统处于稳态。\n9.  满足稳定性条件 $\\lambda  \\mu$。\n10. “交通堵塞”被定义为系统中至少有 $k$ 个聚合酶的事件。\n11. 任务是推导交通堵塞的稳态概率作为 $\\lambda$、$\\mu$ 和 $k$ 的函数。\n12. 任务包括使用特定参数 $\\lambda = 3.5$ min$^{-1}$、$\\mu = 4.0$ min$^{-1}$ 和 $k = 6$ 计算该表达式的值。最终数值答案必须四舍五入到四位有效数字。\n\n验证结论：\n问题有效。它描述了一个经典的 M/M/1 排队模型，这是统计物理学和计算生物学中用于建模随机过程的一个标准且有科学依据的工具。该问题是良定的，因为唯一稳态的条件（$\\lambda  \\mu$）已明确给出。所有术语都以数学上的精确性进行了定义，问题设定是自洽且一致的，并且提供了所需的参数。没有科学或逻辑上的缺陷。我们可以继续进行解答。\n\n所描述的系统是一个在状态空间 $S = \\{0, 1, 2, \\dots\\}$ 上的生灭过程，其中状态 $n$ 表示启动子近端系统（正在清除或等待）中的 RNA 聚合酶II分子的数量。出生率 $\\lambda_n$（到达）和死亡率 $\\mu_n$（服务）如下：\n$$ \\lambda_n = \\lambda \\quad \\text{for } n = 0, 1, 2, \\dots $$\n$$ \\mu_n = \\mu \\quad \\text{for } n = 1, 2, 3, \\dots $$\n其中 $\\mu_0 = 0$。\n\n在稳态下，进入任何状态 $n$ 的速率必须等于离开状态 $n$ 的速率。生灭过程的这一细致平衡原理得出以下方程组，其中 $P_n$ 是处于状态 $n$ 的稳态概率：\n$$ \\lambda_{n-1} P_{n-1} = \\mu_n P_n \\quad \\text{for } n \\ge 1 $$\n代入给定的速率：\n$$ \\lambda P_{n-1} = \\mu P_n \\quad \\text{for } n \\ge 1 $$\n我们可以写出 $P_n$ 的递推关系：\n$$ P_n = \\left(\\frac{\\lambda}{\\mu}\\right) P_{n-1} $$\n让我们定义交通强度 $\\rho = \\frac{\\lambda}{\\mu}$。问题陈述了 $\\lambda  \\mu$，这确保了 $\\rho  1$。递推关系变为：\n$$ P_n = \\rho P_{n-1} $$\n通过重复应用，我们可以将每个 $P_n$ 用 $P_0$（系统为空的概率）表示：\n$$ P_1 = \\rho P_0 $$\n$$ P_2 = \\rho P_1 = \\rho^2 P_0 $$\n...\n$$ P_n = \\rho^n P_0 $$\n为了确定 $P_0$，我们使用归一化条件，即所有概率之和必须等于 $1$：\n$$ \\sum_{n=0}^{\\infty} P_n = 1 $$\n$$ \\sum_{n=0}^{\\infty} \\rho^n P_0 = P_0 \\sum_{n=0}^{\\infty} \\rho^n = 1 $$\n该求和是一个几何级数。由于 $\\rho  1$，级数收敛：\n$$ \\sum_{n=0}^{\\infty} \\rho^n = \\frac{1}{1-\\rho} $$\n将此结果代回归一化方程，得到：\n$$ P_0 \\left( \\frac{1}{1-\\rho} \\right) = 1 \\implies P_0 = 1-\\rho $$\n因此，系统中聚合酶数量的稳态概率分布是一个几何分布：\n$$ P_n = (1-\\rho) \\rho^n \\quad \\text{for } n \\ge 0 $$\n“交通堵塞”定义为系统中至少有 $k$ 个聚合酶的事件。该事件的概率，我们记为 $P_{jam}$，是从 $k$ 到无穷大的所有状态的概率之和：\n$$ P_{jam} = P(N \\ge k) = \\sum_{n=k}^{\\infty} P_n $$\n使用补集法则可以更有效地计算此概率：\n$$ P(N \\ge k) = 1 - P(N  k) = 1 - \\sum_{n=0}^{k-1} P_n $$\n$$ P(N \\ge k) = 1 - \\sum_{n=0}^{k-1} (1-\\rho) \\rho^n = 1 - (1-\\rho) \\sum_{n=0}^{k-1} \\rho^n $$\n项 $\\sum_{n=0}^{k-1} \\rho^n$ 是一个有限几何级数，其和为 $\\frac{1-\\rho^k}{1-\\rho}$。代入此式，我们得到：\n$$ P(N \\ge k) = 1 - (1-\\rho) \\left( \\frac{1-\\rho^k}{1-\\rho} \\right) = 1 - (1-\\rho^k) = \\rho^k $$\n因此，交通堵塞概率的解析表达式就是 $\\rho^k$。\n$$ P_{jam}(\\lambda, \\mu, k) = \\left(\\frac{\\lambda}{\\mu}\\right)^k $$\n这是所要求推导的第一部分。现在，我们必须使用给定的参数计算此表达式的值：$\\lambda = 3.5$ min$^{-1}$，$\\mu = 4.0$ min$^{-1}$，以及 $k = 6$。\n首先，计算交通强度 $\\rho$：\n$$ \\rho = \\frac{\\lambda}{\\mu} = \\frac{3.5}{4.0} = \\frac{7}{8} = 0.875 $$\n接下来，计算发生交通堵塞的概率，$P(N \\ge 6)$：\n$$ P(N \\ge 6) = \\rho^k = (0.875)^6 $$\n数值计算得出：\n$$ (0.875)^6 = 0.4487955322265625 $$\n问题要求将此结果四舍五入到四位有效数字。前四位有效数字是 $4, 4, 8, 7$。第五位数字是 $9$，大于或等于 $5$，所以我们将第四位数字向上取整。\n$$ P(N \\ge 6) \\approx 0.4488 $$", "answer": "$$\\boxed{0.4488}$$", "id": "2436273"}, {"introduction": "从理论模型转向实验数据是计算生物学家的日常工作。染色质免疫共沉淀测序（ChIP-seq）是研究转录因子和Pol II在全基因组范围内结合位置的关键技术，但其原始数据包含了必须被校正的系统性偏差。本练习将指导您完成一个至关重要的生物信息学任务：数据归一化 [@problem_id:2436218]。您将实现一个考虑了测序深度和DNA拷贝数变异（这在癌细胞中尤为常见）的归一化公式，这是从原始测序数据中获得精确、可信的蛋白结合信息的关键一步。", "problem": "您将执行一个与染色质免疫沉淀测序 (ChIP-seq) 相关的模型驱动归一化任务，目标是从第一性原理计算基因组区段的拷贝数感知转录相关占有分数。在转录过程中，来自转录机器（例如，RNA聚合酶II的占有情况）的染色质免疫沉淀测序 (ChIP-seq) 信号会受到拷贝数变异的干扰，这些变异会调节DNA片段的背景可用性。假设存在以下生成模型：对于区段索引 $i \\in \\{1,\\dots,m\\}$，在没有超出背景的特异性富集的无效模型下，经文库大小归一化的ChIP组分 $\\frac{X_i}{T_X}$ 预期与经文库大小归一化的Input组分 $\\frac{Y_i}{T_Y}$ 以及相对于基线倍性的局部拷贝数因子 $\\frac{n_i}{n_0}$ 均呈线性相关。为稳定离散的零计数，在取对数之前，在分子和分母上都加上一个小的正伪计数 $\\delta$。\n\n形式上，对于每个区段 $i$，定义拷贝数感知的归一化分数\n$$\nS_i \\;=\\; \\log_2\\!\\left(\\frac{\\frac{X_i}{T_X} + \\delta}{\\left(\\frac{Y_i}{T_Y}\\right)\\left(\\frac{n_i}{n_0}\\right) + \\delta}\\right),\n$$\n其中 $X_i \\in \\mathbb{N}_0$ 和 $Y_i \\in \\mathbb{N}_0$ 是在ChIP和Input文库中观测到的区段 $i$ 的非负整数读数计数，$T_X = \\sum_{j=1}^m X_j$ 和 $T_Y = \\sum_{j=1}^m Y_j$ 是所考虑区段集合的ChIP和Input文库大小，$n_i \\in \\mathbb{R}_{\\ge 0}$ 是局部绝对拷贝数，$n_0 \\in \\mathbb{R}_{0}$ 是基线倍性，$\\delta \\in \\mathbb{R}_{0}$ 是一个固定的伪计数。\n\n您的程序必须精确实现此定义，并将其应用于以下测试套件。对于每个测试用例，使用提供的数据计算每个区段 $i$ 的 $S_i$，并将每个 $S_i$ 四舍五入到 $6$ 位小数。使用 $n_0 = 2$ 和 $\\delta = 10^{-9}$。\n\n测试套件：\n- 测试用例 $1$ (基线二倍体，信号变化):\n  - $X = [120,80,40,60]$\n  - $Y = [100,90,30,80]$\n  - $n = [2,2,2,2]$\n- 测试用例 $2$ (区域扩增):\n  - $X = [300,100,50,50]$\n  - $Y = [200,100,50,50]$\n  - $n = [4,4,4,4]$\n- 测试用例 $3$ (区域缺失，含零覆盖区段):\n  - $X = [50,25,25,0]$\n  - $Y = [100,50,25,0]$\n  - $n = [1,1,1,1]$\n- 测试用例 $4$ (混合拷贝数，包括纯合缺失，含零值):\n  - $X = [0,10,200,50]$\n  - $Y = [0,5,150,200]$\n  - $n = [0,1,2,5]$\n\n最终输出格式：\n- 生成单行输出，包含一个无空格的类JSON列表的列表，其中每个内部列表对应一个测试用例，并按区段顺序包含该测试用例的四舍五入后的 $S_i$ 值。例如，打印的字符串必须类似于 $[[s_{1,1},s_{1,2},\\dots],[s_{2,1},\\dots],\\dots]$，每个实数都写为四舍五入到 $6$ 位小数的十进制数，并且字符串中不含任何空格。", "solution": "所提供的问题已经过严格验证，并被确定为有效。它在科学上植根于计算基因组学的原理，特别是染色质免疫沉淀测序 (ChIP-seq) 数据的分析。该问题是适定的，所有变量、常数和函数都有明确定义，确保存在唯一且可计算的解。所提供的数据是符合实际的，数学公式是一致且无歧义的。使用伪计数 $\\delta$ 正确地解决了潜在的数值不稳定性问题，例如除以零或对零取对数，这些是测序数据分析中的常见问题。\n\n任务是为一组基因组区段计算拷贝数感知的转录相关占有分数 $S_i$。ChIP-seq数据分析测量蛋白质-DNA相互作用，必须考虑几个混杂因素才能产生生物学上有意义的结果。所提供的 $S_i$ 公式将这种归一化的有原则的方法进行了形式化。\n\n每个区段 $i$ 的分数定义为：\n$$ S_i \\;=\\; \\log_2\\!\\left(\\frac{\\frac{X_i}{T_X} + \\delta}{\\left(\\frac{Y_i}{T_Y}\\right)\\left(\\frac{n_i}{n_0}\\right) + \\delta}\\right) $$\n该公式的每个组成部分都有其独特的目的：\n1.  **ChIP信号 ($X_i$) 与文库大小归一化 ($T_X$)**：项 $\\frac{X_i}{T_X}$ 表示落入区段 $i$ 的总ChIP读数 ($T_X = \\sum_{j=1}^m X_j$) 的比例。通过总文库大小进行归一化是一个标准且必要的步骤，以便在可能测序深度不同的不同实验或样本之间使读数计数具有可比性。\n2.  **背景信号 ($Y_i$) 与文库大小归一化 ($T_Y$)**：项 $\\frac{Y_i}{T_Y}$ 是来自对照实验的相应归一化信号，通常是全细胞提取物“Input”文库。此项模拟了来自每个基因组区域的片段生成的背景速率，该速率可能受到染色质可及性和序列特异性剪切偏好等因素的影响。\n3.  **拷贝数校正 ($\\frac{n_i}{n_0}$)**：因子 $\\frac{n_i}{n_0}$ 根据局部DNA拷贝数 $n_i$ 相对于基线倍性 $n_0$（例如，对于二倍体生物，$n_0=2$）来调整背景期望。在基因组扩增区域 ($n_i  n_0$)，有更多的模板DNA可用，导致背景读数成比例增加。相反，在缺失区域 ($n_i  n_0$)，模板DNA较少。这种校正对于准确解释具有非整倍性或体细胞拷贝数改变（如在癌症中）的基因组中的信号至关重要。\n4.  **对数比与伪计数 ($\\log_2$, $\\delta$)**：分数 $S_i$ 是归一化ChIP信号与归一化且经拷贝数校正的背景期望之比的以2为底的对数。$\\log_2$ 变换是常规做法，因为它使倍数变化围绕零对称（例如，2倍富集为+1，2倍耗竭为-1）。小的正伪计数 $\\delta$ 被加到分子和分母上，以防止当读数计数（$X_i$或$Y_i$）为零时出现奇异点。\n\n为每个测试用例计算分数的算法如下：\n1.  对于每个测试用例，输入包括ChIP计数 ($X$)、Input计数 ($Y$) 和局部拷贝数 ($n$) 的数组。常数给定为基线倍性 $n_0 = 2$ 和伪计数 $\\delta = 10^{-9}$。\n2.  计算总文库大小 $T_X = \\sum_i X_i$ 和 $T_Y = \\sum_i Y_i$。\n3.  对于每个区段 $i$，通过直接应用公式计算分数 $S_i$。使用数组的向量化操作可以最有效地执行此操作。设 $\\mathbf{X}$、$\\mathbf{Y}$ 和 $\\mathbf{n}$ 为计数和拷贝数的向量。分数向量 $\\mathbf{S}$ 可计算如下：\n    $$ \\mathbf{S} = \\log_2\\left(\\frac{\\frac{\\mathbf{X}}{T_X} + \\delta}{\\left(\\frac{\\mathbf{Y}}{T_Y}\\right) \\odot \\left(\\frac{\\mathbf{n}}{n_0}\\right) + \\delta}\\right) $$\n    其中所有除法和加法都是逐元素的，$\\odot$ 表示逐元素乘法。\n4.  按规定将每个计算出的分数 $S_i$ 四舍五入到 $6$ 位小数。\n5.  所有测试用例的最终结果被汇总并格式化为单个无空格的类JSON字符串以供输出。\n现在将实施此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the copy-number-aware transcription-associated occupancy score\n    for a suite of test cases according to the specified formula.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {'X': [120, 80, 40, 60], 'Y': [100, 90, 30, 80], 'n': [2, 2, 2, 2]},\n        # Test case 2\n        {'X': [300, 100, 50, 50], 'Y': [200, 100, 50, 50], 'n': [4, 4, 4, 4]},\n        # Test case 3\n        {'X': [50, 25, 25, 0], 'Y': [100, 50, 25, 0], 'n': [1, 1, 1, 1]},\n        # Test case 4\n        {'X': [0, 10, 200, 50], 'Y': [0, 5, 150, 200], 'n': [0, 1, 2, 5]},\n    ]\n\n    # Define constants\n    n0 = 2.0\n    delta = 1e-9\n\n    all_results = []\n    for case in test_cases:\n        X = np.array(case['X'], dtype=float)\n        Y = np.array(case['Y'], dtype=float)\n        n = np.array(case['n'], dtype=float)\n\n        # Calculate total library sizes\n        T_X = np.sum(X)\n        T_Y = np.sum(Y)\n\n        # To avoid division by zero if a library size is 0, though not present in tests.\n        # If T_X is 0, all X_i are 0. chip_norm should be all 0s.\n        # If T_Y is 0, all Y_i are 0. input_norm should be all 0s.\n        chip_norm = X / T_X if T_X  0 else np.zeros_like(X)\n        input_norm = Y / T_Y if T_Y  0 else np.zeros_like(Y)\n        \n        cn_factor = n / n0\n\n        # Calculate the numerator and denominator of the log argument\n        numerator = chip_norm + delta\n        denominator = (input_norm * cn_factor) + delta\n\n        # Calculate the scores S_i\n        # np.log2 handles the logarithm for the entire array.\n        S = np.log2(numerator / denominator)\n\n        all_results.append(S)\n\n    # Format the output string exactly as required, with no spaces.\n    # Each S_i value is rounded and formatted to 6 decimal places.\n    formatted_cases = []\n    for case_result in all_results:\n        # Using f-string formatting to ensure 6 decimal places, e.g., 0.0 - \"0.000000\"\n        formatted_numbers = [f\"{val:.6f}\" for val in case_result]\n        formatted_cases.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2436218"}]}