{"hands_on_practices": [{"introduction": "早期的二级结构预测方法依赖于从已知蛋白质结构中提取的统计信息。Garnier-Osguthorpe-Robson (GOR) 方法就是一个经典的例子。这个练习提供了一个亲手计算GOR方法核心组成部分——信息含量分数——的机会，展示了如何汇总局部序列信息来对单个残基的结构进行预测 [@problem_id:2421464]。", "problem": "考虑用于蛋白质二级结构预测的 Garnier–Osguthorpe–Robson (GOR) 方法。对于一个以残基索引 $i$ 为中心、宽度为 $17$ 的固定窗口，将中心残基分配给结构 $s \\in \\{H,E,C\\}$ 的信息含量定义为\n$$\nI(s) \\;=\\; \\sum_{k=-8}^{+8} w_{s}\\!\\left(a_{i+k},\\,k\\right),\n$$\n其中 $a_{i+k}$ 是距离中心位置相对偏移量为 $k$ 的氨基酸，而 $w_{s}(a,k)$ 是在中心状态为 $s$ 的情况下，在偏移量 $k$ 处观察到氨基酸 $a$ 的以2为底的对数优势比贡献（单位为比特）。窗口中观察到的残基的 $w_{s}(a,k)$ 值如下所示。\n\n这个包含17个残基的肽段窗口（从 $k=-8$ 到 $k=+8$）是：\nV, A, G, L, E, K, P, V, A, E, L, G, I, S, D, T, P\n因此中心残基（$k=0$）是 A。\n\n使用以下在每个相对位置 $k$ 处观察到的残基的信息贡献（单位为比特）：\n- $k=-8$, V: $w_{H}=-0.15$, $w_{E}=+0.30$, $w_{C}=-0.05$\n- $k=-7$, A: $w_{H}=+0.25$, $w_{E}=-0.10$, $w_{C}=-0.05$\n- $k=-6$, G: $w_{H}=-0.20$, $w_{E}=-0.10$, $w_{C}=+0.30$\n- $k=-5$, L: $w_{H}=+0.30$, $w_{E}=+0.05$, $w_{C}=-0.15$\n- $k=-4$, E: $w_{H}=+0.30$, $w_{E}=-0.10$, $w_{C}=-0.10$\n- $k=-3$, K: $w_{H}=+0.25$, $w_{E}=-0.10$, $w_{C}=-0.10$\n- $k=-2$, P: $w_{H}=-0.30$, $w_{E}=-0.10$, $w_{C}=+0.40$\n- $k=-1$, V: $w_{H}=-0.10$, $w_{E}=+0.25$, $w_{C}=-0.05$\n- $k=0$, A: $w_{H}=+0.40$, $w_{E}=-0.20$, $w_{C}=-0.10$\n- $k=+1$, E: $w_{H}=+0.35$, $w_{E}=-0.15$, $w_{C}=-0.10$\n- $k=+2$, L: $w_{H}=+0.35$, $w_{E}=+0.00$, $w_{C}=-0.20$\n- $k=+3$, G: $w_{H}=-0.25$, $w_{E}=-0.10$, $w_{C}=+0.35$\n- $k=+4$, I: $w_{H}=-0.10$, $w_{E}=+0.30$, $w_{C}=-0.05$\n- $k=+5$, S: $w_{H}=-0.10$, $w_{E}=-0.05$, $w_{C}=+0.15$\n- $k=+6$, D: $w_{H}=-0.15$, $w_{E}=-0.10$, $w_{C}=+0.25$\n- $k=+7$, T: $w_{H}=-0.05$, $w_{E}=+0.05$, $w_{C}=+0.05$\n- $k=+8$, P: $w_{H}=-0.35$, $w_{E}=-0.10$, $w_{C}=+0.45$\n\n根据上述定义，计算中心残基的 $I(H)$、$I(E)$ 和 $I(C)$。以比特为单位表示每个值。不要四舍五入；报告精确的总和。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于计算生物学的原理，特别是 Garnier–Osguthorpe–Robson (GOR) 方法。该问题定义明确、客观，并为得出唯一解提供了所有必要数据。这是一个基于给定公式和数据集的直接计算练习。\n\n任务是计算三种二级结构状态 $s \\in \\{H, E, C\\}$ 中每一种的信息含量 $I(s)$，其中 H 表示 α-螺旋，E 表示 β-折叠，C 表示无规卷曲。信息含量定义为以目标残基为中心的宽度为17的对称窗口中，每个残基的对数优势比贡献的总和。控制方程为：\n$$\nI(s) = \\sum_{k=-8}^{+8} w_{s}(a_{i+k}, k)\n$$\n其中 $w_{s}(a_{i+k}, k)$ 是在中心残基处于状态 $s$ 的条件下，在相对于中心的位置 $k$ 处观察到氨基酸 $a_{i+k}$ 时所提供的信息贡献（以比特为单位）。\n\n我们将使用提供的权重表分别为每种状态执行求和。\n\n对于 α-螺旋状态（$H$）：\n$$\nI(H) = \\sum_{k=-8}^{+8} w_{H}(a_{i+k}, k)\n$$\n代入给定值：\n$$\n\\begin{aligned}\nI(H) =  (-0.15) + (0.25) + (-0.20) + (0.30) + (0.30) + (0.25) + (-0.30) \\\\\n + (-0.10) + (0.40) + (0.35) + (0.35) + (-0.25) + (-0.10) + (-0.10) \\\\\n + (-0.15) + (-0.05) + (-0.35)\n\\end{aligned}\n$$\n正数项的总和是：\n$0.25 + 0.30 + 0.30 + 0.25 + 0.40 + 0.35 + 0.35 = 2.20$\n负数项的总和是：\n$(-0.15) + (-0.20) + (-0.30) + (-0.10) + (-0.25) + (-0.10) + (-0.10) + (-0.15) + (-0.05) + (-0.35) = -1.75$\n因此，螺旋状态的总信息含量为：\n$$\nI(H) = 2.20 - 1.75 = 0.45 \\text{ bits}\n$$\n\n对于 β-折叠状态（$E$）：\n$$\nI(E) = \\sum_{k=-8}^{+8} w_{E}(a_{i+k}, k)\n$$\n代入给定值：\n$$\n\\begin{aligned}\nI(E) =  (0.30) + (-0.10) + (-0.10) + (0.05) + (-0.10) + (-0.10) + (-0.10) \\\\\n + (0.25) + (-0.20) + (-0.15) + (0.00) + (-0.10) + (0.30) + (-0.05) \\\\\n + (-0.10) + (0.05) + (-0.10)\n\\end{aligned}\n$$\n正数项的总和是：\n$0.30 + 0.05 + 0.25 + 0.00 + 0.30 + 0.05 = 0.95$\n负数项的总和是：\n$(-0.10) + (-0.10) + (-0.10) + (-0.10) + (-0.10) + (-0.20) + (-0.15) + (-0.10) + (-0.05) + (-0.10) + (-0.10) = -1.20$\n因此，折叠状态的总信息含量为：\n$$\nI(E) = 0.95 - 1.20 = -0.25 \\text{ bits}\n$$\n\n对于无规卷曲状态（$C$）：\n$$\nI(C) = \\sum_{k=-8}^{+8} w_{C}(a_{i+k}, k)\n$$\n代入给定值：\n$$\n\\begin{aligned}\nI(C) =  (-0.05) + (-0.05) + (0.30) + (-0.15) + (-0.10) + (-0.10) + (0.40) \\\\\n + (-0.05) + (-0.10) + (-0.10) + (-0.20) + (0.35) + (-0.05) + (0.15) \\\\\n + (0.25) + (0.05) + (0.45)\n\\end{aligned}\n$$\n正数项的总和是：\n$0.30 + 0.40 + 0.35 + 0.15 + 0.25 + 0.05 + 0.45 = 1.95$\n负数项的总和是：\n$(-0.05) + (-0.05) + (-0.15) + (-0.10) + (-0.10) + (-0.05) + (-0.10) + (-0.10) + (-0.20) + (-0.05) = -0.95$\n因此，无规卷曲状态的总信息含量为：\n$$\nI(C) = 1.95 - 0.95 = 1.00 \\text{ bits}\n$$\n计算出的值为 $I(H) = 0.45$，$I(E) = -0.25$ 和 $I(C) = 1.00$。GOR 方法会预测具有最高信息含量的状态，在本例中即为无规卷曲状态（$C$）。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.45  -0.25  1.00\n\\end{pmatrix}\n}\n$$", "id": "2421464"}, {"introduction": "我们可以采用更复杂的统计模型来超越仅仅关注残基倾向性的方法。这个练习将二级结构序列本身作为研究对象，引入了一阶马尔可夫链的概念来捕捉从一个结构状态转换到另一个状态（例如，从螺旋到卷曲）的可能性。这是许多现代生物信息学算法中的一个基本概念 [@problem_id:2421171]。", "problem": "给定一组基于蛋白质二级结构状态有限字母表 $\\{H, E, C\\}$ 的序列，其中 $H$ 代表 $\\alpha$-螺旋，$E$ 代表 $\\beta$-折叠，$C$ 代表无规卷曲。将这些序列建模为由一个状态空间为 $S = \\{H, E, C\\}$ 的时间同质一阶马尔可夫链生成。对于每个有序对 $(i, j) \\in S \\times S$，令 $n_{ij}$ 表示通过扫描所有序列，并将序列中每一对相邻状态计为一次转移，所得到的从状态 $i$ 到状态 $j$ 的相邻转移总次数。一个长度为 $L$ 的序列恰好贡献 $L-1$ 次转移，每个相邻对贡献一次；没有起始或结束标记。\n\n对于给定的非负平滑参数 $\\alpha \\in \\mathbb{R}_{\\ge 0}$，通过拉普拉斯（add-$\\alpha$）平滑定义的估计转移概率为\n$$\n\\hat{P}(j \\mid i) \\;=\\; \\frac{n_{ij} + \\alpha}{\\sum_{k \\in S} n_{ik} + \\alpha \\, |S|},\n$$\n其中 $|S| = 3$。当 $\\alpha = 0$ 时，这简化为基于相对频率的最大似然估计。所有概率值必须表示为精确到 $6$ 位小数的小数。\n\n测试套件。对于以下每种情况，给定：\n- 一个基于 $\\{H,E,C\\}$ 的序列列表，\n- 一个平滑参数 $\\alpha$，\n- 一个有序查询对 $(i,j)$，\n\n您必须计算单个值 $\\hat{P}(j \\mid i)$。\n\n- 情况 A:\n  - 序列: [\"HEHEHE\"]\n  - $\\alpha = 0$\n  - 查询对 $(i,j) = (E, H)$\n- 情况 B:\n  - 序列: [\"HHHH\"]\n  - $\\alpha = 0.5$\n  - 查询对 $(i,j) = (H, E)$\n- 情况 C:\n  - 序列: [\"HH\", \"CC\"]\n  - $\\alpha = 1.0$\n  - 查询对 $(i,j) = (E, H)$\n- 情况 D:\n  - 序列: [\"HHHEECCC\", \"HECHHEE\", \"CCCEEEHHH\"]\n  - $\\alpha = 0$\n  - 查询对 $(i,j) = (C, C)$\n- 情况 E:\n  - 序列: [\"EE\"]\n  - $\\alpha = 0.25$\n  - 查询对 $(i,j) = (E, H)$\n\n最终输出格式。您的程序应生成单行输出，按顺序包含情况 A 到 E 的结果，形式为用方括号括起来的逗号分隔列表。每个条目必须是 $\\hat{P}(j \\mid i)$ 的小数值，四舍五入到小数点后 $6$ 位。例如，一个有效的格式是“[rA,rB,rC,rD,rE]”，其中每个 rX 是一个四舍五入到 $6$ 位的小数。不应打印任何额外的字符或行。", "solution": "该问题是有效的。它在科学上基于概率序列建模的原理，特别是使用一阶马尔可夫链，这是计算生物学中的一种标准方法。该问题是适定的、客观的，并提供了计算每个测试用例唯一解所需的所有信息。拉普拉斯平滑的公式表述正确，并且测试用例在计算上是可行的。\n\n目标是计算状态空间为 $S = \\{H, E, C\\}$ 的一阶马尔可夫链的估计转移概率 $\\hat{P}(j \\mid i)$。状态空间大小为 $|S| = 3$。该估计根据以下公式使用 add-$\\alpha$ 平滑进行：\n$$\n\\hat{P}(j \\mid i) \\;=\\; \\frac{n_{ij} + \\alpha}{\\sum_{k \\in S} n_{ik} + \\alpha \\, |S|}\n$$\n其中 $n_{ij}$ 表示从状态 $i$ 到状态 $j$ 观测到的转移次数，$\\alpha \\ge 0$ 是平滑参数。\n\n每个测试用例的步骤如下：\n1.  构建一个 $3 \\times 3$ 的转移计数矩阵 $N$，其中条目 $n_{ij}$ 存储从状态 $i$ 到状态 $j$ 的转移次数。这通过扫描所有提供的序列来完成。长度为 $L$ 的序列中的每一对相邻字符贡献一次转移，每个序列总共贡献 $L-1$ 次转移。\n2.  确定查询对 $(i,j)$ 和平滑参数 $\\alpha$。\n3.  从矩阵 $N$ 中提取特定计数 $n_{ij}$。\n4.  计算从状态 $i$ 开始的总转移次数，即矩阵 $N$ 的第 $i$ 行之和：$\\sum_{k \\in S} n_{ik}$。\n5.  将这些值代入给定公式以计算 $\\hat{P}(j \\mid i)$。\n6.  将最终概率四舍五入到小数点后 $6$ 位。\n\n**情况 A:**\n- 序列: `[\"HEHEHE\"]`\n- $\\alpha = 0$\n- 查询: $(i,j) = (E, H)$\n\n单个长度为 $L=6$ 的序列 \"HEHEHE\" 提供了 $L-1=5$ 次转移：$H \\to E$、$E \\to H$、$H \\to E$、$E \\to H$、$H \\to E$。转移计数为 $n_{HE} = 3$ 和 $n_{EH} = 2$。所有其他计数 $n_{ij}$ 均为 $0$。\n查询的是 $\\hat{P}(H \\mid E)$，所以起始状态是 $i=E$。从状态 $E$ 开始的总转移次数是 $\\sum_{k \\in S} n_{Ek} = n_{EE} + n_{EH} + n_{EC} = 0 + 2 + 0 = 2$。对于转移 $E \\to H$ 的特定计数是 $n_{EH} = 2$。\n使用公式：\n$$ \\hat{P}(H \\mid E) = \\frac{n_{EH} + \\alpha}{\\sum_{k \\in S} n_{Ek} + \\alpha |S|} = \\frac{2 + 0}{2 + 0 \\cdot 3} = \\frac{2}{2} = 1.0 $$\n结果是 $1.000000$。\n\n**情况 B:**\n- 序列: `[\"HHHH\"]`\n- $\\alpha = 0.5$\n- 查询: $(i,j) = (H, E)$\n\n长度为 $L=4$ 的序列 \"HHHH\" 提供了 $3$ 次转移，均为 $H \\to H$。因此，$n_{HH} = 3$，所有其他 $n_{ij} = 0$。\n查询的是 $\\hat{P}(E \\mid H)$，所以 $i=H$。从 $H$ 开始的总转移次数为 $\\sum_{k \\in S} n_{Hk} = n_{HH} + n_{HE} + n_{HC} = 3 + 0 + 0 = 3$。对于 $H \\to E$ 的特定计数是 $n_{HE} = 0$。\n使用公式：\n$$ \\hat{P}(E \\mid H) = \\frac{n_{HE} + \\alpha}{\\sum_{k \\in S} n_{Hk} + \\alpha |S|} = \\frac{0 + 0.5}{3 + 0.5 \\cdot 3} = \\frac{0.5}{3 + 1.5} = \\frac{0.5}{4.5} = \\frac{1}{9} \\approx 0.11111111... $$\n结果四舍五入到小数点后 $6$ 位是 $0.111111$。\n\n**情况 C:**\n- 序列: `[\"HH\", \"CC\"]`\n- $\\alpha = 1.0$\n- 查询: $(i,j) = (E, H)$\n\n序列 \"HH\" 贡献一次转移 $H \\to H$。序列 \"CC\" 贡献一次转移 $C \\to C$。所以，$n_{HH} = 1$，$n_{CC} = 1$，所有其他 $n_{ij}=0$。\n查询的是 $\\hat{P}(H \\mid E)$，所以 $i=E$。从 $E$ 开始的总转移次数为 $\\sum_{k \\in S} n_{Ek} = n_{EE} + n_{EH} + n_{EC} = 0 + 0 + 0 = 0$。对于 $E \\to H$ 的特定计数是 $n_{EH} = 0$。\n使用公式：\n$$ \\hat{P}(H \\mid E) = \\frac{n_{EH} + \\alpha}{\\sum_{k \\in S} n_{Ek} + \\alpha |S|} = \\frac{0 + 1.0}{0 + 1.0 \\cdot 3} = \\frac{1.0}{3.0} = \\frac{1}{3} \\approx 0.33333333... $$\n结果四舍五入到小数点后 $6$ 位是 $0.333333$。\n\n**情况 D:**\n- 序列: `[\"HHHEECCC\", \"HECHHEE\", \"CCCEEEHHH\"]`\n- $\\alpha = 0$\n- 查询: $(i,j) = (C, C)$\n\n我们汇总所有三个序列的转移计数：\n- \"HHHEECCC\": $n_{HH}=2$, $n_{HE}=1$, $n_{EE}=1$, $n_{EC}=1$, $n_{CC}=2$。\n- \"HECHHEE\": $n_{HE}=2$, $n_{EC}=1$, $n_{CH}=1$, $n_{HH}=1$, $n_{EE}=1$。\n- \"CCCEEEHHH\": $n_{CC}=2$, $n_{CE}=1$, $n_{EE}=2$, $n_{EH}=1$, $n_{HH}=2$。\n总计数为：$n_{HH} = 5$, $n_{HE} = 3$, $n_{HC} = 0$, $n_{EH} = 1$, $n_{EE} = 4$, $n_{EC} = 2$, $n_{CH} = 1$, $n_{CE} = 1$, $n_{CC} = 4$。\n查询的是 $\\hat{P}(C \\mid C)$，所以 $i=C$。从 $C$ 开始的总转移次数为 $\\sum_{k \\in S} n_{Ck} = n_{CH} + n_{CE} + n_{CC} = 1 + 1 + 4 = 6$。对于 $C \\to C$ 的特定计数是 $n_{CC} = 4$。\n使用公式：\n$$ \\hat{P}(C \\mid C) = \\frac{n_{CC} + \\alpha}{\\sum_{k \\in S} n_{Ck} + \\alpha |S|} = \\frac{4 + 0}{6 + 0 \\cdot 3} = \\frac{4}{6} = \\frac{2}{3} \\approx 0.66666666... $$\n结果四舍五入到小数点后 $6$ 位是 $0.666667$。\n\n**情况 E:**\n- 序列: `[\"EE\"]`\n- $\\alpha = 0.25$\n- 查询: $(i,j) = (E, H)$\n\n长度为 $L=2$ 的序列 \"EE\" 提供了 $1$ 次转移，$E \\to E$。因此，$n_{EE} = 1$，所有其他 $n_{ij}=0$。\n查询的是 $\\hat{P}(H \\mid E)$，所以 $i=E$。从 $E$ 开始的总转移次数为 $\\sum_{k \\in S} n_{Ek} = n_{EE} + n_{EH} + n_{EC} = 1 + 0 + 0 = 1$。对于 $E \\to H$ 的特定计数是 $n_{EH} = 0$。\n使用公式：\n$$ \\hat{P}(H \\mid E) = \\frac{n_{EH} + \\alpha}{\\sum_{k \\in S} n_{Ek} + \\alpha |S|} = \\frac{0 + 0.25}{1 + 0.25 \\cdot 3} = \\frac{0.25}{1 + 0.75} = \\frac{0.25}{1.75} = \\frac{1}{7} \\approx 0.14285714... $$\n结果四舍五入到小数点后 $6$ 位是 $0.142857$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates smoothed transition probabilities for a series of test cases\n    based on a first-order Markov chain model of protein secondary structures.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (sequences, alpha, query_pair)\n        ({\"sequences\": [\"HEHEHE\"], \"alpha\": 0.0, \"query\": ('E', 'H')}),       # Case A\n        ({\"sequences\": [\"HHHH\"], \"alpha\": 0.5, \"query\": ('H', 'E')}),       # Case B\n        ({\"sequences\": [\"HH\", \"CC\"], \"alpha\": 1.0, \"query\": ('E', 'H')}),      # Case C\n        ({\"sequences\": [\"HHHEECCC\", \"HECHHEE\", \"CCCEEEHHH\"], \"alpha\": 0.0, \"query\": ('C', 'C')}), # Case D\n        ({\"sequences\": [\"EE\"], \"alpha\": 0.25, \"query\": ('E', 'H')}),        # Case E\n    ]\n\n    # Define the state space and its mapping to indices.\n    states = {'H': 0, 'E': 1, 'C': 2}\n    num_states = len(states)\n    \n    results = []\n    \n    for case in test_cases:\n        sequences = case[\"sequences\"]\n        alpha = case[\"alpha\"]\n        query_pair = case[\"query\"]\n        \n        # Initialize a 3x3 transition count matrix with zeros.\n        n_counts = np.zeros((num_states, num_states), dtype=int)\n        \n        # Count all transitions by iterating through sequences.\n        for seq in sequences:\n            # A sequence of length L has L-1 transitions.\n            if len(seq) > 1:\n                for i in range(len(seq) - 1):\n                    from_state_char = seq[i]\n                    to_state_char = seq[i+1]\n                    \n                    # Get state indices and increment the corresponding count.\n                    from_idx = states[from_state_char]\n                    to_idx = states[to_state_char]\n                    n_counts[from_idx, to_idx] += 1\n        \n        from_q_str, to_q_str = query_pair\n        from_q_idx = states[from_q_str]\n        to_q_idx = states[to_q_str]\n        \n        # Extract the specific count n_ij for the query transition.\n        n_ij = n_counts[from_q_idx, to_q_idx]\n        \n        # Calculate the sum of all transitions from the origin state i.\n        sum_nik = np.sum(n_counts[from_q_idx, :])\n        \n        # Apply the add-alpha smoothing formula.\n        numerator = n_ij + alpha\n        denominator = sum_nik + alpha * num_states\n        \n        # The problem statement ensures the denominator is never zero for these cases.\n        probability = numerator / denominator\n        \n        # Format the result to exactly 6 decimal places.\n        results.append(f\"{probability:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2421171"}]}