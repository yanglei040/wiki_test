{"hands_on_practices": [{"introduction": "在生物信息学中，分析分类数据以发现变量之间的关联是一项基本任务，例如，探究特定基因突变是否与某种疾病相关。本练习将指导您使用经典的卡方检验（Chi-squared test）来解决此类问题。通过亲手构建列联表并计算卡方统计量，您将深入理解假设检验的核心逻辑：将观测数据与虚无假设下的期望进行比较，从而评估关联的显著性。[@problem_id:2398945]", "problem": "一家医院的微生物实验室正在监测从血流感染中分离出的细菌菌种的抗生素耐药性。对于一种感兴趣的抗生素，分离株按细菌菌种和药敏试验的表型结果（耐药或敏感）进行分类。在一个月内，记录了以下计数：\n- Escherichia coli：$40$ 例耐药，$60$ 例敏感。\n- Staphylococcus aureus：$25$ 例耐药，$75$ 例敏感。\n- Pseudomonas aeruginosa：$35$ 例耐药，$15$ 例敏感。\n\n将这些数据视为来自类别变量“菌种”和“耐药状态”的联合分布的大小为 $N$ 的单个随机样本。在耐药状态与菌种无关的原假设下，使用数据所隐含的 $3 \\times 2$ 列联表，确定用于独立性检验的皮尔逊卡方检验统计量。\n\n仅提供检验统计量的值。将您的答案四舍五入到四位有效数字。", "solution": "问题陈述已经过评估，被认为是有效的。它具有科学依据，提法明确，客观，并为得出唯一解提供了所有必要信息。这是统计假设检验在计算生物学中的一个标准应用。我们将继续进行解答。\n\n该问题要求计算用于列联表独立性检验的皮尔逊卡方检验统计量，记为 $\\chi^2$。数据涉及三种细菌菌种的抗生素耐药性。\n\n首先，我们必须将所提供的计数整理成一个观测频率列联表，记为 $O_{ij}$。设行 $i$ 代表细菌菌种，列 $j$ 代表耐药状态（耐药，敏感）。\n\n观测频率如下：\n\\begin{itemize}\n    \\item \\textit{Escherichia coli}：$O_{11} = 40$ 耐药，$O_{12} = 60$ 敏感。\n    \\item \\textit{Staphylococcus aureus}：$O_{21} = 25$ 耐药，$O_{22} = 75$ 敏感。\n    \\item \\textit{Pseudomonas aeruginosa}：$O_{31} = 35$ 耐药，$O_{32} = 15$ 敏感。\n\\end{itemize}\n\n我们构建 $3 \\times 2$ 列联表，并计算行合计 ($R_i$)、列合计 ($C_j$) 和总计 ($N$)。\n\n观测频率 $O_{ij}$ 的表格如下：\n$$\n\\begin{array}{c|cc|c}\n\\text{菌种}  \\text{耐药}  \\text{敏感}  \\text{行合计 } (R_i) \\\\\n\\hline\n\\text{E. coli}  40  60  100 \\\\\n\\text{S. aureus}  25  75  100 \\\\\n\\text{P. aeruginosa}  35  15  50 \\\\\n\\hline\n\\text{列合计 } (C_j)  100  150  250\n\\end{array}\n$$\n行合计为 $R_1 = 40 + 60 = 100$，$R_2 = 25 + 75 = 100$ 和 $R_3 = 35 + 15 = 50$。\n列合计为 $C_1 = 40 + 25 + 35 = 100$ 和 $C_2 = 60 + 75 + 15 = 150$。\n总计为 $N = 100 + 100 + 50 = 250$。\n\n原假设 $H_0$ 指出，耐药状态与细菌菌种无关。在此假设下，每个单元格的期望频率 $E_{ij}$ 使用以下公式计算：\n$$ E_{ij} = \\frac{R_i \\times C_j}{N} $$\n\n我们现在计算每个单元格的期望频率：\n\\begin{itemize}\n    \\item $E_{11} = \\frac{R_1 \\times C_1}{N} = \\frac{100 \\times 100}{250} = \\frac{10000}{250} = 40$\n    \\item $E_{12} = \\frac{R_1 \\times C_2}{N} = \\frac{100 \\times 150}{250} = \\frac{15000}{250} = 60$\n    \\item $E_{21} = \\frac{R_2 \\times C_1}{N} = \\frac{100 \\times 100}{250} = \\frac{10000}{250} = 40$\n    \\item $E_{22} = \\frac{R_2 \\times C_2}{N} = \\frac{100 \\times 150}{250} = \\frac{15000}{250} = 60$\n    \\item $E_{31} = \\frac{R_3 \\times C_1}{N} = \\frac{50 \\times 100}{250} = \\frac{5000}{250} = 20$\n    \\item $E_{32} = \\frac{R_3 \\times C_2}{N} = \\frac{50 \\times 150}{250} = \\frac{7500}{250} = 30$\n\\end{itemize}\n\n皮尔逊卡方检验统计量的计算方法是，对表中所有单元格，将观测频率与期望频率之差的平方除以期望频率，然后求和：\n$$ \\chi^2 = \\sum_{i=1}^{r} \\sum_{j=1}^{c} \\frac{(O_{ij} - E_{ij})^2}{E_{ij}} $$\n其中 $r=3$ 是行数，$c=2$ 是列数。\n\n我们计算每个单元格对 $\\chi^2$ 统计量的贡献：\n\\begin{itemize}\n    \\item 单元格 $(1,1)$: $\\frac{(40 - 40)^2}{40} = \\frac{0}{40} = 0$\n    \\item 单元格 $(1,2)$: $\\frac{(60 - 60)^2}{60} = \\frac{0}{60} = 0$\n    \\item 单元格 $(2,1)$: $\\frac{(25 - 40)^2}{40} = \\frac{(-15)^2}{40} = \\frac{225}{40} = 5.625$\n    \\item 单元格 $(2,2)$: $\\frac{(75 - 60)^2}{60} = \\frac{(15)^2}{60} = \\frac{225}{60} = 3.75$\n    \\item 单元格 $(3,1)$: $\\frac{(35 - 20)^2}{20} = \\frac{(15)^2}{20} = \\frac{225}{20} = 11.25$\n    \\item 单元格 $(3,2)$: $\\frac{(15 - 30)^2}{30} = \\frac{(-15)^2}{30} = \\frac{225}{30} = 7.5$\n\\end{itemize}\n\n总的 $\\chi^2$ 统计量是这些值的总和：\n$$ \\chi^2 = 0 + 0 + 5.625 + 3.75 + 11.25 + 7.5 = 28.125 $$\n\n问题要求答案四舍五入到四位有效数字。数值 $28.125$ 四舍五入到四位有效数字是 $28.13$。", "answer": "$$\n\\boxed{28.13}\n$$", "id": "2398945"}, {"introduction": "当处理基因表达水平等数值型数据时，选择正确的统计检验至关重要，因为真实的生物学数据往往充满噪音和异常值。本练习通过一个编程任务，清晰地揭示了参数检验（如依赖数据正态分布假设的$t$检验）与非参数检验（如更为稳健的Wilcoxon秩和检验）之间的关键差异。您将亲眼见证一个异常值如何影响检验结果，从而学会根据数据特性选择最合适的统计工具。[@problem_id:2398972]", "problem": "构建一个程序，对于在两种生物学条件下通过核糖核酸测序（RNA-seq）测量的某个特定基因，计算双样本 Welch $t$-检验和 Wilcoxon 秩和检验（也称为 Mann–Whitney $U$ 检验）的双边 p 值，并在一个指定的测试套件上汇总结果。假设每种条件为该基因生成独立的重复计数，并将提供的计数视为观测值。两种检验的原假设均为两种条件的中心趋势相等，表述为 $H_0$：两种条件下的样本来自具有相等均值的总体（Welch $t$-检验）或相等的连续分布的总体（Wilcoxon 秩和检验）。不对计数进行任何变换。所有检验都必须是双边的。\n\n您的程序必须处理以下测试套件，其中每一项指定了条件 $A$ 和条件 $B$ 的计数：\n\n- 测试用例 $1$（基线，无离群值，分布可比较）：\n  - 条件 $A$：$\\left(43, 50, 39, 61, 55, 47\\right)$\n  - 条件 $B$：$\\left(45, 52, 41, 58, 53, 49\\right)$\n\n- 测试用例 $2$（条件 $B$ 中有单个极端高值离群值）：\n  - 条件 $A$：$\\left(43, 50, 39, 61, 55, 47\\right)$\n  - 条件 $B$：$\\left(45, 52, 41, 58, 53, 1000\\right)$\n\n- 测试用例 $3$（小样本量，条件 $B$ 中有单个极端高值离群值）：\n  - 条件 $A$：$\\left(20, 22, 25\\right)$\n  - 条件 $B$：$\\left(19, 21, 400\\right)$\n\n- 测试用例 $4$（位置偏移，条件 $B$ 中有单个极端低值离群值）：\n  - 条件 $A$：$\\left(15, 16, 18, 20, 19, 17\\right)$\n  - 条件 $B$：$\\left(28, 30, 27, 29, 31, 0\\right)$\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算：\n- $p_{t,i}$：比较条件 $A$ 和条件 $B$ 的双样本 Welch $t$-检验得到的双边 p 值。\n- $p_{w,i}$：比较条件 $A$ 和条件 $B$ 的 Wilcoxon 秩和检验得到的双边 p 值。\n\n您的程序必须生成单行输出，包含一个由方括号括起来的逗号分隔列表。该列表必须包含 $8$ 个浮点数，按 $\\left[p_{t,1}, p_{w,1}, p_{t,2}, p_{w,2}, p_{t,3}, p_{w,3}, p_{t,4}, p_{w,4}\\right]$ 的顺序排列，每个数字四舍五入到 $6$ 位小数。不应打印任何其他文本。所有数字都是无量纲的，必须表示为小数（例如，$0.012345$），而不是百分比。", "solution": "该问题要求计算两种不同统计假设检验——Welch 双样本 $t$-检验和 Wilcoxon 秩和检验——的 p 值，这些检验应用于来自两种条件的 RNA 测序计数数据。其目的是比较参数检验与非参数检验的性能，尤其是在存在离群值的情况下，这在生物学数据集中很常见。在进行计算求解之前，我们必须为每种检验建立理论基础。\n\n**1. Welch 双样本 $t$-检验**\n\nWelch $t$-检验是一种用于比较两个独立样本（此处表示为条件 $A$ 和条件 $B$）均值的统计工具。它是 Student $t$-检验的一种改编，当两个样本方差不相等时（即 Behrens-Fisher 问题），它被认为更可靠。原假设 $H_0$ 假定总体均值相等，即 $H_0: \\mu_A = \\mu_B$。\n\n检验统计量 $t$ 的计算方法是样本均值之差除以该差值的标准误：\n$$\nt = \\frac{\\bar{x}_A - \\bar{x}_B}{\\sqrt{\\frac{s_A^2}{n_A} + \\frac{s_B^2}{n_B}}}\n$$\n其中：\n- $\\bar{x}_A$ 和 $\\bar{x}_B$ 分别是条件 $A$ 和 $B$ 的样本均值。\n- $s_A^2$ 和 $s_B^2$ 是无偏样本方差。\n- $n_A$ 和 $n_B$ 是样本量。\n\n与 Student $t$-检验不同，Welch 检验的自由度 $\\nu$ 并非简单地为 $n_A + n_B - 2$。相反，它使用 Welch-Satterthwaite 方程进行近似计算：\n$$\n\\nu \\approx \\frac{\\left( \\frac{s_A^2}{n_A} + \\frac{s_B^2}{n_B} \\right)^2}{\\frac{(s_A^2/n_A)^2}{n_A - 1} + \\frac{(s_B^2/n_B)^2}{n_B - 1}}\n$$\n然后，根据具有 $\\nu$ 自由度的 Student $t$-分布确定 p 值。对于双边检验，p 值为 $2 \\cdot P(T_\\nu > |t|)$，其中 $T_\\nu$ 是一个服从 $t$-分布的随机变量。\n\n$t$-检验的一个关键假设是两个样本中的数据都近似服从正态分布。当数据严重偏离正态性时，例如存在偏度或重尾分布，$t$-检验的性能会下降。至关重要的是，样本均值 $(\\bar{x})$ 和方差 $(s^2)$ 对极端值（离群值）高度敏感，这些值可能对 $t$-统计量产生不成比例的影响，从而导致错误的结论。\n\n**2. Wilcoxon 秩和（Mann-Whitney U）检验**\n\nWilcoxon 秩和检验是 $t$-检验的一种非参数替代方法。它不假设数据的特定分布，因此更为稳健。该检验的原假设是，对于从两个总体中随机选取的数值 $X$ 和 $Y$，$X$ 大于 $Y$ 的概率等于 $Y$ 大于 $X$ 的概率。更一般地，它检验两个样本是否来自具有相同分布的总体。\n\n其过程如下：\n1. 将所有 $n_A + n_B$ 个观测值合并到一个排序列表中。如果存在结（ties），则分配本应分配的秩的平均值。\n2. 计算其中一个样本（例如样本 $A$）的秩总和，记为 $R_A$。\n3. 检验统计量 $U$ 根据此秩和计算得出。对于样本 $A$，统计量 $U_A$ 为：\n   $$\n   U_A = R_A - \\frac{n_A(n_A + 1)}{2}\n   $$\n   检验统计量 $U$ 通常取为 $U = \\min(U_A, U_B)$，其中 $U_B$ 对样本 $B$ 进行类似计算。\n4. p 值由原假设下已知的 $U$ 统计量分布确定。对于小样本量，使用精确分布。对于较大样本，则采用带连续性校正的正态近似。\n\n因为 Wilcoxon 检验是基于秩而不是原始数据值进行操作，所以其统计量不受离群值大小的影响，只受其序数位置的影响。一个极端值仅被视为最高（或最低）的秩，其具体数值不会进一步影响检验统计量。这一特性赋予了该检验对离群值的强大稳健性。\n\n**3. 测试用例的应用与解释**\n\n所提供的测试用例旨在突显这两种检验的不同敏感性。\n- **测试用例 1**：分布相似且无离群值。预计两种检验都将产生较高的 p 值，表明没有显著差异。\n- **测试用例 2 和 3**：在条件 $B$ 中引入了一个极端高值离群值。预计 $t$-检验的 p 值将受到显著影响，因为该离群值会夸大条件 $B$ 的均值和方差。相比之下，Wilcoxon 检验应相对不受影响，从而对中心趋势的偏移提供更稳定的评估。\n- **测试用例 4**：在条件 $B$ 中引入了一个极端低值离群值，而条件 $B$ 的其他成员的值相较于条件 $A$ 有所升高。这个离群值会拉低条件 $B$ 的均值，可能掩盖 $t$-检验所应检测到的真实位置偏移。然而，秩和检验更能够检测到两个样本大部分数据之间的一致秩差异。\n\n计算实现将使用 `scipy.stats` 库，具体是 `ttest_ind` 函数（参数 `equal_var=False`）来执行 Welch $t$-检验，以及 `mannwhitneyu` 函数（参数 `alternative='two-sided'`）来执行 Wilcoxon 秩和检验。将为每个测试用例系统地计算结果，并按要求进行格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import ttest_ind, mannwhitneyu\n\ndef solve():\n    \"\"\"\n    Computes and prints p-values for Welch's t-test and Wilcoxon rank-sum test\n    for a suite of RNA-seq count data test cases.\n    \"\"\"\n\n    # Define the test suite as specified in the problem statement.\n    test_cases = [\n        # Test case 1: baseline, no outlier, comparable distributions\n        (np.array([43, 50, 39, 61, 55, 47]), np.array([45, 52, 41, 58, 53, 49])),\n        # Test case 2: single extreme high outlier in condition B\n        (np.array([43, 50, 39, 61, 55, 47]), np.array([45, 52, 41, 58, 53, 1000])),\n        # Test case 3: small sample size with a single extreme high outlier in condition B\n        (np.array([20, 22, 25]), np.array([19, 21, 400])),\n        # Test case 4: location shift with a single extreme low outlier in condition B\n        (np.array([15, 16, 18, 20, 19, 17]), np.array([28, 30, 27, 29, 31, 0])),\n    ]\n\n    results = []\n    for cond_a, cond_b in test_cases:\n        # Perform Welch's two-sample t-test.\n        # The `equal_var=False` argument specifies that we should perform Welch's t-test,\n        # which does not assume equal population variance.\n        # The test is two-sided by default.\n        t_stat, p_t = ttest_ind(cond_a, cond_b, equal_var=False)\n        results.append(p_t)\n\n        # Perform the Wilcoxon rank-sum test (Mann-Whitney U test).\n        # We explicitly specify a two-sided test.\n        # The 'auto' method for p-value calculation is used by default,\n        # which chooses between an exact test and a normal approximation\n        # based on sample size and presence of ties.\n        u_stat, p_w = mannwhitneyu(cond_a, cond_b, alternative='two-sided')\n        results.append(p_w)\n\n    # Format the results as a comma-separated list of floating-point numbers\n    # rounded to 6 decimal places, enclosed in square brackets.\n    formatted_results = [f\"{p:.6f}\" for p in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2398972"}, {"introduction": "在科研前沿，我们常会定义新颖而复杂的统计量，但其理论分布是未知的，这使得传统的“教科书式”检验方法无能为力。本练习将带您进入计算统计学的核心领域，学习使用蒙特卡洛模拟来凭经验构建任意检验统计量的零分布，并以此计算$p$值。掌握这项技能意味着您将能够为复杂的基因组学问题量身定制假设检验方法，极大地拓展您解决问题的能力。[@problem_id:2398987]", "problem": "您正在研究两个个体是否在某条染色体上共享异常长的同态（identical-by-state）片段。检验统计量是等位基因匹配的最长连续标记区块的长度（以碱基对为单位），其测量方法是该区块末端标记与起始标记物理位置之差。在两个个体无亲缘关系的零假设下，每个标记匹配被建模为一个独立的伯努利试验，具有给定的逐标记匹配概率。由于对于真实的标记布局和异构的匹配概率，最大连续片段长度的零分布在解析上是难解的，您将通过蒙特卡洛模拟来近似它。\n\n您的任务是实现一个程序，针对多个测试用例，使用模拟的零数据来估计观测到的最长匹配片段长度的蒙特卡洛p值。请遵循以下科学原理和定义作为您设计的基础：\n\n- 令 $M_i \\in \\{0,1\\}$ 表示标记 $i$ 处的匹配指示符，其中 $M_i = 1$ 表示匹配，$M_i = 0$ 表示不匹配。在无亲缘关系的零假设 $\\mathcal{H}_0$ 下，假设 $\\{M_i\\}_{i=0}^{n-1}$ 是独立的伯努利随机变量，其匹配概率或为共同的 $p$，或为逐标记的 $p_i$。\n- 令 $x_i$ 表示标记 $i$ 的物理位置（以碱基对为单位），且位置严格递增 $x_0  x_1  \\dots  x_{n-1}$。\n- 定义检验统计量 $T(M, x)$ 为所有 $M_i = 1$ 的连续片段中，片段长度（计算为 $x_{j} - x_{i}$，其中片段始于索引 $i$ 终于索引 $j \\ge i$）的最大值。根据定义，长度为一个标记的片段，其片段长度为 $0$ 碱基对。\n- 给定一个观测到的统计量 $T_{\\text{obs}}$，使用从零模型中进行的 $B$ 次独立模拟来近似蒙特卡洛p值。在每次模拟 $b \\in \\{1,\\dots,B\\}$ 中，从伯努利模型中生成一个独立的序列 $M^{(b)}$，计算 $T^{(b)} = T(M^{(b)}, x)$，并估计\n$$\n\\widehat{p} \\;=\\; \\frac{1 + \\sum_{b=1}^{B} \\mathbf{1}\\{T^{(b)} \\ge T_{\\text{obs}}\\}}{B+1},\n$$\n这是标准的蒙特卡洛p值，带有一个 $+1$ 的连续性校正以避免估计值为零。大数强定律保证在 $\\mathcal{H}_0$ 下，当 $B \\to \\infty$ 时，$\\widehat{p}$ 几乎必然收敛于真实的p值。\n\n实现要求：\n\n- 使用固定的伪随机数生成器种子 $20231011$ 以确保可复现性。\n- 对每个测试用例，模拟 $B$ 次零假设下的重复，按上述方法计算 $\\widehat{p}$ 并报告。\n- 所有模拟的标记匹配在给定其概率的情况下必须是独立的。如果提供的是标量 $p$，则对所有 $i$ 使用 $M_i \\sim \\text{Bernoulli}(p)$。如果提供的是向量 $(p_0,\\dots,p_{n-1})$，则独立地使用 $M_i \\sim \\text{Bernoulli}(p_i)$。\n- 统计量必须使用提供的 $x_i$ 位置以碱基对为单位进行计算。输出中没有单位转换；输出是p值，必须是无量纲的小数（无百分号）。\n\n测试套件：\n\n请实现您的程序，为以下四种情况计算 $\\widehat{p}$。在每种情况下，索引为 $i \\in \\{0,1,\\dots,n-1\\}$。\n\n- 情况1（理想情况，长数组，中等匹配概率）：\n  - $n = 1000$。\n  - 位置：$x_i = 10000 \\cdot i$（以碱基对为单位）。\n  - 匹配概率：标量 $p = 0.25$。\n  - 观测统计量：$T_{\\text{obs}} = 180000$（以碱基对为单位）。\n  - 模拟次数：$B = 5000$。\n\n- 情况2（不规则间距，较高匹配概率）：\n  - $n = 200$。\n  - 位置：$x_i = 1000 \\cdot i + 5000 \\cdot \\left\\lfloor \\dfrac{i}{50} \\right\\rfloor$（以碱基对为单位），在索引 $50$、$100$ 和 $150$ 处引入了额外的间隙。\n  - 匹配概率：标量 $p = 0.5$。\n  - 观测统计量：$T_{\\text{obs}} = 100000$（以碱基对为单位）。\n  - 模拟次数：$B = 5000$。\n\n- 情况3（小数组，稀疏匹配，边界观测统计量）：\n  - $n = 50$。\n  - 位置：$x_i = 20000 \\cdot i$（以碱基对为单位）。\n  - 匹配概率：标量 $p = 0.1$。\n  - 观测统计量：$T_{\\text{obs}} = 0$（以碱基对为单位）。\n  - 模拟次数：$B = 5000$。\n\n- 情况4（位置相关的大间隙，异构的逐标记概率）：\n  - $n = 300$。\n  - 位置：$x_i = 500 \\cdot i + 20000 \\cdot \\left\\lfloor \\dfrac{i}{75} \\right\\rfloor$（以碱基对为单位），在索引 $75$、$150$ 和 $225$ 处引入了更大的间隙。\n  - 匹配概率：逐标记概率 $p_i = 0.05 + 0.45 \\cdot \\dfrac{i}{n-1}$，对于 $i=0,\\dots,n-1$。\n  - 观测统计量：$T_{\\text{obs}} = 50000$（以碱基对为单位）。\n  - 模拟次数：$B = 5000$。\n\n最终输出规格：\n\n- 您的程序应产生单行输出，其中包含按情况1到4顺序排列的四个蒙特卡洛p值，格式为用方括号括起来的逗号分隔列表，每个值四舍五入到 $6$ 位小数（例如，$[0.123456,0.000200,1.000000,0.042314]$）。", "solution": "我们将共享基因组片段的假设检验表述如下。零假设 $\\mathcal{H}_0$ 假定两个个体无亲缘关系，因此沿着一个标记组的匹配指示符表现为独立的伯努利随机变量，具有给定的逐标记匹配概率。令 $M_i \\in \\{0,1\\}$ 表示标记 $i$ 处的匹配指示符，并令有序的物理位置（以碱基对为单位）为 $x_0  x_1  \\dots  x_{n-1}$。一个匹配的连续区块（或称游程）是一个最大的索引区间 $[i,j]$，其中对于所有的 $k \\in \\{i,i+1,\\dots,j\\}$ 都有 $M_k = 1$，并且要么 $i=0$ 要么 $M_{i-1}=0$，要么 $j=n-1$ 要么 $M_{j+1}=0$。\n\n定义检验统计量 $T(M,x)$ 为所有此类游程中片段长度（以碱基对为单位，计算为 $x_j - x_i$）的最大值。一个长度为一个标记的游程产生的片段长度为 $0$，因为在相邻的不同标记之间没有跨度。将观测到的统计量 $T_{\\text{obs}}$ 与 $T(M,x)$ 的零分布进行比较。\n\n挑战在于，对于真实的 $x$ 和异构的概率，最大游程长度的精确零分布没有封闭形式的解。因此，我们通过蒙特卡洛模拟来近似它，其基础是以下原则：\n\n- 在 $\\mathcal{H}_0$ 下，匹配指示符是独立的伯努利试验：如果指定了共同概率 $p$，则 $M_i \\sim \\text{Bernoulli}(p)$；或者如果概率 $p_i$ 可能变化，则 $M_i \\sim \\text{Bernoulli}(p_i)$。这些是经过充分检验的、用于独立二元结果的概率模型。\n- 大数强定律指出，随着样本数量的增加，独立同分布的可积随机变量的经验平均几乎必然收敛于其期望值。尽管跨模拟的指示符 $\\mathbf{1}\\{T^{(b)} \\ge T_{\\text{obs}}\\}$ 是独立同分布的伯努利随机变量，其均值等于真实的p值，但当 $B \\to \\infty$ 时，它们的平均值几乎必然收敛于该真实均值。\n- 带有 $+1$ 校正的蒙特卡洛p值为\n$$\n\\widehat{p} \\;=\\; \\frac{1 + \\sum_{b=1}^{B} \\mathbf{1}\\{T^{(b)} \\ge T_{\\text{obs}}\\}}{B+1},\n$$\n这是一个标准的、保守的估计量，它避免了在有限 $B$ 下出现零估计，并且根据大数强定律是一致的。\n\n算法设计：\n\n1. 输入标记位置 $x \\in \\mathbb{R}^n$（以碱基对为单位）、匹配概率（标量 $p$ 或向量 $p_i$）、观测到的统计量 $T_{\\text{obs}}$ 以及模拟次数 $B$。\n2. 定义一个函数，在给定布尔向量 $M$ 和位置 $x$ 的情况下计算 $T(M,x)$：\n   - 初始化 $t_{\\max} \\leftarrow 0$。\n   - 从 $0$ 到 $n-1$ 扫描 $i$。当一个由1组成的游程开始时，记录其起始索引 $s$。前进 $i$ 直到该游程在索引 $e$ 处结束。计算游程长度 $x_e - x_s$，如果更大则更新 $t_{\\max}$。\n   - 得到的 $t_{\\max}$ 是以碱基对为单位的最长连续匹配片段长度。\n   每次评估的时间复杂度为 $\\mathcal{O}(n)$，因为每个索引最多被访问两次（一次用于检测游程开始，一次作为游程的一部分）。\n3. 对于 $b = 1$ 到 $B$，模拟一次零假设下的重复：\n   - 如果提供的是标量 $p$，则通过抽取 $U_i \\sim \\text{Uniform}(0,1)$ 并设置 $M^{(b)}_i = \\mathbf{1}\\{U_i  p\\}$，为 $i=0,\\dots,n-1$ 独立生成 $M^{(b)}_i \\sim \\text{Bernoulli}(p)$。\n   - 如果提供的是向量 $(p_0,\\dots,p_{n-1})$，则通过 $U_i \\sim \\text{Uniform}(0,1)$ 和 $M^{(b)}_i = \\mathbf{1}\\{U_i  p_i\\}$ 独立生成 $M^{(b)}_i \\sim \\text{Bernoulli}(p_i)$。\n   - 计算 $T^{(b)} = T(M^{(b)}, x)$。\n4. 计数 $C = \\sum_{b=1}^{B} \\mathbf{1}\\{T^{(b)} \\ge T_{\\text{obs}}\\}$ 并报告\n$$\n\\widehat{p} \\;=\\; \\frac{1+C}{B+1}.\n$$\n5. 对每个测试用例重复此过程，使用相同的伪随机数生成器（种子为 $20231011$）以确保可复现性。由于每个情况都是独立的，顺序使用一个单一的有种子的生成器就足够了。\n\n正确性原理：\n\n- 在 $\\mathcal{H}_0$ 下，模拟的 $M^{(b)}$ 与零假设下的数据生成过程具有相同的分布。因此，$T^{(b)}$ 是从 $T$ 的零分布中抽取的独立同分布样本。\n- 指示变量 $\\mathbf{1}\\{T^{(b)} \\ge T_{\\text{obs}}\\}$ 是独立的伯努利变量，其均值等于在 $T_{\\text{obs}}$ 处的真实零假设下的尾部概率。它们的和 $C$ 除以 $B$ 估计了这个均值。$+1$ 校正产生了一个保守的有限样本估计量，当 $B \\to \\infty$ 时收敛于真实的p值。\n- 该实现通过将片段长度计算为以碱基对为单位测量的 $x$ 的差值来尊重单位；报告的p值是无量纲的，并以小数形式表示。\n\n所提供测试套件中的边界情况：\n\n- 情况3使用 $T_{\\text{obs}} = 0$，这确保 $C = B$，因此 $\\widehat{p} = \\dfrac{1+B}{B+1} = 1$ 精确成立。\n- 情况1和2探测了极端尾部，其观测到的片段相对于零假设下的典型行为而言很长，而情况4引入了 $p_i$ 的异构性和位置相关的大间隙，检验了通用的模拟逻辑。\n\n最终程序完全按照定义构建指定的位置数组和概率，将种子设置为 $20231011$，为每种情况运行 $B=5000$ 次模拟，计算四个 $\\widehat{p}$ 值，将每个值四舍五入到6位小数，并以所需的列表格式打印单行结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef longest_segment_bp(matches: np.ndarray, positions: np.ndarray) - int:\n    \"\"\"\n    Compute the longest contiguous run of True values in 'matches',\n    measured in base pairs as positions[end] - positions[start].\n    A run of length 1 has length 0.\n    \"\"\"\n    n = matches.size\n    max_len = 0\n    i = 0\n    # Ensure boolean array\n    m = matches.astype(bool, copy=False)\n    while i  n:\n        if m[i]:\n            start = i\n            # advance until the run ends\n            while i + 1  n and m[i + 1]:\n                i += 1\n            end = i\n            seg_len = int(positions[end] - positions[start])\n            if seg_len > max_len:\n                max_len = seg_len\n        i += 1\n    return max_len\n\ndef monte_carlo_pvalue(positions, probs, T_obs, B, rng) - float:\n    \"\"\"\n    Estimate Monte Carlo p-value: (1 + count[T_sim = T_obs]) / (B + 1)\n    positions: 1D array of increasing integers (base pairs)\n    probs: scalar in [0,1] or 1D array of per-marker probabilities in [0,1]\n    T_obs: observed longest segment length (base pairs)\n    B: number of simulations\n    rng: numpy Generator for reproducibility\n    \"\"\"\n    positions = np.asarray(positions, dtype=np.int64)\n    n = positions.size\n\n    count_ge = 0\n    # Prepare probability vector\n    if np.isscalar(probs):\n        p_vec = float(probs)\n        for _ in range(B):\n            matches = rng.random(n)  p_vec\n            T_sim = longest_segment_bp(matches, positions)\n            if T_sim >= T_obs:\n                count_ge += 1\n    else:\n        p_arr = np.asarray(probs, dtype=float)\n        assert p_arr.shape == (n,), \"Per-marker probability vector must match number of positions.\"\n        for _ in range(B):\n            matches = rng.random(n)  p_arr\n            T_sim = longest_segment_bp(matches, positions)\n            if T_sim >= T_obs:\n                count_ge += 1\n\n    pval = (1.0 + count_ge) / (B + 1.0)\n    return pval\n\ndef solve():\n    # Fixed random seed as specified\n    rng = np.random.default_rng(20231011)\n\n    # Test Case 1\n    n1 = 1000\n    positions1 = 10000 * np.arange(n1, dtype=np.int64)\n    p1 = 0.25\n    T_obs1 = 180000  # base pairs\n    B1 = 5000\n\n    # Test Case 2: irregular spacing with extra gaps at indices 50, 100, 150\n    n2 = 200\n    idx2 = np.arange(n2, dtype=np.int64)\n    positions2 = 1000 * idx2 + 5000 * (idx2 // 50)\n    p2 = 0.5\n    T_obs2 = 100000  # base pairs\n    B2 = 5000\n\n    # Test Case 3: small array, sparse matches, boundary observed value\n    n3 = 50\n    positions3 = 20000 * np.arange(n3, dtype=np.int64)\n    p3 = 0.1\n    T_obs3 = 0  # base pairs\n    B3 = 5000\n\n    # Test Case 4: large gaps at 75, 150, 225; heterogeneous probabilities\n    n4 = 300\n    idx4 = np.arange(n4, dtype=np.int64)\n    positions4 = 500 * idx4 + 20000 * (idx4 // 75)\n    p4 = 0.05 + 0.45 * (idx4.astype(float) / (n4 - 1))\n    T_obs4 = 50000  # base pairs\n    B4 = 5000\n\n    test_cases = [\n        (positions1, p1, T_obs1, B1),\n        (positions2, p2, T_obs2, B2),\n        (positions3, p3, T_obs3, B3),\n        (positions4, p4, T_obs4, B4),\n    ]\n\n    results = []\n    for positions, probs, T_obs, B in test_cases:\n        pval = monte_carlo_pvalue(positions, probs, T_obs, B, rng)\n        results.append(pval)\n\n    # Final print statement in the exact required format, rounded to 6 decimals.\n    formatted = \"[\" + \",\".join(f\"{r:.6f}\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2398987"}]}