{"hands_on_practices": [{"introduction": "在分子生物学和生物技术中，许多过程（如DNA合成或测序）都由一系列独立的事件组成。这个练习探讨了如何使用二项分布来为这些过程的保真度建模。通过计算在寡核苷酸合成过程中获得一个完美序列的概率，你将掌握一个评估多步骤生物过程中成功率的基本技能 [@problem_id:2381059]。", "problem": "在高通量化学合成一条长度为$100$的寡核苷酸时，每个核苷酸的掺入事件都是独立的，并且在每个位置上发生错误掺入（错误）的概率为$1/500$。仅当寡核苷酸的整个长度上都没有发生错误掺入时，才认为该寡核苷酸是完美的。\n\n在这些假设下，合成的100个核苷酸长度的寡核苷酸（$100$-mer）是完美的概率是多少？请以小数形式提供答案，并四舍五入到$4$位有效数字。", "solution": "首先对问题陈述进行严格验证。\n\n逐字提取的已知条件如下：\n1.  寡核苷酸长度：$100$。\n2.  每个核苷酸掺入事件都是独立的。\n3.  每个位置上错误掺入的概率：$1/500$。\n4.  仅当没有发生错误掺入时，寡核苷酸才被认为是完美的。\n5.  最终答案必须是四舍五入到$4$位有效数字的小数。\n\n验证评估：\n-   **科学依据充分：** 该问题为寡核苷酸合成中的错误提供了一个简化但标准且科学上有效的模型。给出的参数是符合实际的。\n-   **问题定义明确：** 该问题定义清晰。给出的条件充分且一致，足以计算出唯一的概率。\n-   **客观性：** 语言是定量的、精确的，没有任何主观或模棱两可的术语。\n\n该问题被认为是有效的，因为它科学依据充分、定义明确、客观，并且没有违反任何无效标准。我们可以继续进行求解。\n\n设 $L$ 为寡核苷酸的长度，则 $L=100$。\n设 $p_{error}$ 为在任何单个位置上发生错误掺入的概率。已知 $p_{error} = \\frac{1}{500}$。\n在 $L$ 个位置上各自的掺入事件是独立的。\n要使一个寡核苷酸是完美的，每个位置上都必须发生正确的掺入。\n设 $p_{correct}$ 为在单个位置上发生正确掺入的概率。由于这是错误掺入的互补事件，其概率为：\n$$p_{correct} = 1 - p_{error} = 1 - \\frac{1}{500} = \\frac{499}{500}$$\n要使整个100聚体是完美的，必须有100个独立的正确掺入。一系列独立事件的概率是它们各自概率的乘积。\n设 $P(\\text{perfect})$ 为合成的100聚体是完美的概率。这要求在位置1发生正确掺入，并且在位置2，...，并且在位置100都发生正确掺入。\n因此，$P(\\text{perfect})$ 是 $p_{correct}$ 自乘 $L$ 次的积：\n$$P(\\text{perfect}) = (p_{correct})^{L}$$\n代入给定值：\n$$P(\\text{perfect}) = \\left(\\frac{499}{500}\\right)^{100}$$\n这个问题也可以用二项分布来正式描述。设 $X$ 为一个长度为 $L=100$ 的序列中错误掺入次数的随机变量。那么 $X$ 服从二项分布 $X \\sim B(n, p)$，其中试验次数为 $n=L=100$，“成功”（这里定义为一次错误掺入）的概率为 $p=p_{error}=\\frac{1}{500}$。\n观察到恰好 $k$ 次错误掺入的概率由概率质量函数给出：\n$$P(X=k) = \\binom{n}{k} p^k (1-p)^{n-k}$$\n一个完美的寡核苷酸对应于发生零次错误掺入的情况，即 $k=0$。\n$$P(X=0) = \\binom{100}{0} \\left(\\frac{1}{500}\\right)^{0} \\left(1-\\frac{1}{500}\\right)^{100-0}$$\n使用恒等式 $\\binom{n}{0} = 1$ 和对于任何非零 $x$ 都有 $x^0 = 1$，上式可简化为：\n$$P(X=0) = 1 \\cdot 1 \\cdot \\left(\\frac{499}{500}\\right)^{100} = \\left(\\frac{499}{500}\\right)^{100}$$\n这证实了最初的推理。我们现在计算其数值。\n$$P(\\text{perfect}) = (0.998)^{100}$$\n计算这个值得到：\n$$P(\\text{perfect}) \\approx 0.8185852503...$$\n问题要求答案四舍五入到$4$位有效数字。前四位有效数字是$8$、$1$、$8$和$5$。第五位有效数字是$8$，大于或等于$5$，所以我们必须将第四位有效数字向上取整。\n$$P(\\text{perfect}) \\approx 0.8186$$\n这就是最终的概率。", "answer": "$$\\boxed{0.8186}$$", "id": "2381059"}, {"introduction": "许多生物学性状，如基因长度或蛋白质表达水平，可以被建模为连续变量。这个练习将向你介绍如何应用正态分布（一种在生物统计学中无处不在的工具）来描述这些性状。通过计算一个基因长度小于特定值的概率，你将学会使用标准化（z-score）来量化群体中的变异，并确定观察到特定值的可能性 [@problem_id:2381054]。", "problem": "在一项细菌物种的比较基因组学分析中，假设随机选择的一个基因的长度（单位：碱基对）被建模为一个连续随机变量 $L$，该变量服从均值为 $\\mu$、方差为 $\\sigma^{2}$ 的正态分布。具体来说，假设 $L \\sim \\mathcal{N}(\\mu,\\sigma^{2})$，其中 $\\mu = 950$ 且 $\\sigma = 300$。请仅使用正态分布的定义、线性变换的性质以及标准正态分布的累积分布函数（CDF），确定长度小于 $500$ 碱基对（bp）的基因所占的比例。请将最终结果表示为小数，并四舍五入到 $4$ 位有效数字。", "solution": "所提出的问题是有效的且有科学依据的，尽管对于像基因长度这样的严格正值量使用正态分布是一种常见的理论简化。在该模型下，出现非物理的负长度的可能性可以忽略不计，因为均值 $\\mu = 950$ 相对于标准差 $\\sigma = 300$ 足够大 ($\\mu/\\sigma \\approx 3.17$)。我们现在开始进行正式求解。\n\n基因的长度，由连续随机变量 $L$ 表示，被建模为正态分布 $L \\sim \\mathcal{N}(\\mu, \\sigma^2)$。给定的参数是均值 $\\mu = 950$ 和标准差 $\\sigma = 300$。我们的目标是计算长度小于 $500$ 碱基对的基因比例，即概率 $P(L  500)$。\n\n问题明确要求使用线性变换来标准化该变量。这是一个正确且标准的步骤。任何服从均值为 $\\mu$、方差为 $\\sigma^2$ 的正态分布的随机变量 $X$，都可以通过以下变换转换为标准正态随机变量 $Z \\sim \\mathcal{N}(0, 1)$：\n$$Z = \\frac{X - \\mu}{\\sigma}$$\n将此变换应用于随机变量 $L$，我们可以用 $Z$ 来表示所求的概率。事件 $L  500$ 等价于涉及 $Z$ 的事件：\n$$P(L  500) = P\\left(\\frac{L - \\mu}{\\sigma}  \\frac{500 - \\mu}{\\sigma}\\right)$$\n代入 $\\mu$ 和 $\\sigma$ 的给定值：\n$$P(L  500) = P\\left(Z  \\frac{500 - 950}{300}\\right)$$\n我们对标准化值（通常称为z分数）进行算术计算：\n$$z = \\frac{500 - 950}{300} = \\frac{-450}{300} = -1.5$$\n因此，问题简化为求标准正态随机变量 $Z$ 小于 $-1.5$ 的概率：\n$$P(L  500) = P(Z  -1.5)$$\n根据定义，这个概率是标准正态分布的累积分布函数（CDF），记为 $\\Phi(z)$，在 $z = -1.5$ 处的值。\n$$P(L  500) = \\Phi(-1.5)$$\n$\\Phi(-1.5)$ 的值必须从标准正态概率表或可靠的计算源中获取。其值约为：\n$$\\Phi(-1.5) \\approx 0.0668072$$\n问题要求将此结果四舍五入到 $4$ 位有效数字。$0.0668072$ 的前四位有效数字是 $6$、$6$、$8$ 和 $0$。第五位有效数字是 $7$，大于或等于 $5$，因此我们将第四位有效数字向上取整。\n$$0.0668072 \\approx 0.06681$$\n因此，长度小于 $500$ 碱基对的基因比例约为 $0.06681$。", "answer": "$$\\boxed{0.06681}$$", "id": "2381054"}, {"introduction": "计算生物学中的许多复杂问题需要整合多种概率模型来捕捉动态过程。这个高级编程练习挑战你为一个微生物种群的生长建立一个随机模型。通过在一个统一的框架内结合使用多项分布、正态近似和泊松过程，你将体验如何将基本的概率分布作为构建模块，来模拟从细胞增殖到生态系统动态的复杂生物系统 [@problem_id:2381044]。", "problem": "一个微生物种群以离散的时间步长演化。在每一步中，每个细胞独立地经历三种互斥结果之一：以概率 $p_d$ 分裂成两个细胞，以概率 $p_m$ 死亡，或以概率 $1 - p_d - p_m$ 保持为单个细胞。在当前时间步的条件下，所有细胞的行为彼此独立，且与过去无关。令 $N_0$ 表示一个步骤开始时的细胞数量，$N_1$ 表示该步骤结束时的细胞数量。除非另有说明，所有概率必须以四舍五入到六位小数的小数形式报告。\n\n基于此模型，计算下列参数集的所求概率。每个部分是一个独立的测试用例；最终的程序输出必须按下列顺序列出汇总结果。\n\n测试套件：\n\n- 案例 A（精确计算，固定初始规模）：给定初始细胞数为 $N_0 = n_0$，其中 $n_0 = 10$，$p_d = 0.3$，$p_m = 0.2$，计算一步之后细胞总数恰好为 $k_A = 12$ 的精确概率。\n\n- 案例 B（大种群近似）：给定初始细胞数为 $N_0 = n_0$，其中 $n_0 = 3000$，$p_d = 0.02$，$p_m = 0.015$。将一步之后的总数近似建模为高斯分布，其参数由模型所蕴含的单细胞结果分布和独立性决定。在此近似下，计算细胞总数小于或等于 $k_B = 3050$ 的概率。将高斯近似解释为实数线上的连续分布，并且不使用连续性校正。\n\n- 案例 C（泊松初始种群，净变化）：假设 $N_0$ 是一个均值为 $\\lambda_0 = 200$ 的泊松随机变量。当 $p_d = 0.04$，$p_m = 0.06$ 时，计算一步之内细胞数量的净变化 $\\Delta = N_1 - N_0 = r_C = -5$ 的精确概率。\n\n- 案例 D（无分裂的边缘情况）：给定初始细胞数为 $N_0 = n_0$，其中 $n_0 = 25$，$p_d = 0$，$p_m = 0.1$，计算一步之后细胞总数恰好为 $k_D = 22$ 的精确概率。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{案例 A 结果}, \\text{案例 B 结果}, \\text{案例 C 结果}, \\text{案例 D 结果}]$。例如，输出应类似于 $[x_A,x_B,x_C,x_D]$，其中每个 $x_\\cdot$ 都是四舍五入到六位小数的小数。", "solution": "问题陈述已经过严格验证。所描述的模型是一个标准的离散时间分支过程，这是随机建模中的一个基本构造。所有参数都已提供，问题在数学上是精确的，并且框架在科学上是合理的。不存在矛盾、模糊或事实不准确之处。该问题被视为有效，现将提供完整解答。\n\n模型的核心是单个细胞在一个时间步内的结果集。一个细胞可以分裂成 $2$ 个，存活为 $1$ 个，或死亡变成 $0$ 个细胞。令随机变量 $X$ 表示由单个祖细胞在一个步骤结束时产生的细胞数量。$X$ 的概率质量函数为：\n$$\nP(X=k) = \n\\begin{cases} \np_d  \\text{若 } k=2 \\\\\np_m  \\text{若 } k=0 \\\\\n1 - p_d - p_m  \\text{若 } k=1 \n\\end{cases}\n$$\n如果初始种群规模为 $N_0 = n_0$，则一步之后的种群规模 $N_1$ 是 $n_0$ 个独立同分布的随机变量 $X_i$ 的总和，每个 $X_i$ 的分布都与 $X$ 相同：\n$$ N_1 = \\sum_{i=1}^{n_0} X_i $$\n此框架将应用于每个案例。\n\n案例 A：初始种群固定为 $N_0 = n_0 = 10$。概率为 $p_d = 0.3$ 和 $p_m = 0.2$，这意味着存活概率为 $p_s = 1 - 0.3 - 0.2 = 0.5$。我们必须计算 $N_1 = k_A = 12$ 的精确概率。\n\n令 $d$、$m$ 和 $s$ 分别表示在初始的 $n_0=10$ 个细胞中分裂、死亡和存活的细胞数量。这些数字必须满足 $d+m+s=10$。一步之后的细胞总数为 $N_1 = 2d + 1s + 0m$。给定条件为 $N_1=12$。\n我们可以通过代入 $s = n_0 - d - m$ 将 $N_1$ 表示为 $d$、$m$ 和 $n_0$ 的函数：\n$$N_1 = 2d + (n_0 - d - m) = n_0 + d - m$$\n对于本案例，我们有 $12 = 10 + d - m$，简化为条件 $d - m = 2$。\n我们必须找到所有满足约束条件 $d-m=2$ 和 $d+m \\le 10$ 的非负整数对 $(d,m)$。可能的数对为 $(d,m) \\in \\{(2,0), (3,1), (4,2), (5,3), (6,4)\\}$。\n任何特定配置 $(d,m,s)$ 的概率由多项式概率质量函数给出：\n$$P(D=d, M=m, S=s) = \\frac{n_0!}{d!m!s!} p_d^d p_m^m p_s^s$$\n总概率是对所有有效配置求和：\n$$P(N_1=12) = \\sum_{(d,m,s)} \\frac{10!}{d!m!s!} (0.3)^d (0.2)^m (0.5)^s$$\n该和是基于从 $d-m=2$ 推导出的五种组合：\n\\begin{itemize}\n    \\item $(d,m,s)=(2,0,8)$: $\\frac{10!}{2!0!8!}(0.3)^2(0.2)^0(0.5)^8 \\approx 0.015800$\n    \\item $(d,m,s)=(3,1,6)$: $\\frac{10!}{3!1!6!}(0.3)^3(0.2)^1(0.5)^6 = 0.070875$\n    \\item $(d,m,s)=(4,2,4)$: $\\frac{10!}{4!2!4!}(0.3)^4(0.2)^2(0.5)^4 = 0.063788$\n    \\item $(d,m,s)=(5,3,2)$: $\\frac{10!}{5!3!2!}(0.3)^5(0.2)^3(0.5)^2 = 0.012247$\n    \\item $(d,m,s)=(6,4,0)$: $\\frac{10!}{6!4!0!}(0.3)^6(0.2)^4(0.5)^0 \\approx 0.000246$\n\\end{itemize}\n将这些概率相加得到 $P(N_1=12) \\approx 0.162956$。\n\n案例 B：初始种群规模较大，$N_0 = n_0 = 3000$，且 $p_d = 0.02$，$p_m = 0.015$。存活概率为 $p_s = 1 - 0.02 - 0.015 = 0.965$。我们需使用高斯近似来计算 $N_1$ 以求得 $P(N_1 \\le k_B = 3050)$。\n根据中心极限定理，对于大的 $n_0$，$N_1 = \\sum_{i=1}^{n_0} X_i$ 的分布趋近于一个正态分布 $\\mathcal{N}(\\mu_{N_1}, \\sigma^2_{N_1})$。其参数由单细胞结果分布 $X$ 的均值和方差决定。\n$X$ 的均值为 $E[X] = 2 \\cdot p_d + 1 \\cdot p_s + 0 \\cdot p_m = 2(0.02) + 1(0.965) = 1.005$。\n$N_1$ 的均值为 $\\mu_{N_1} = n_0 E[X] = 3000 \\cdot 1.005 = 3015$。\n为求方差，我们首先计算 $E[X^2] = 2^2 \\cdot p_d + 1^2 \\cdot p_s + 0^2 \\cdot p_m = 4(0.02) + 1(0.965) = 1.045$。\n$X$ 的方差为 $Var(X) = E[X^2] - (E[X])^2 = 1.045 - (1.005)^2 = 1.045 - 1.010025 = 0.034975$。\n$N_1$ 的方差为 $\\sigma^2_{N_1} = n_0 Var(X) = 3000 \\cdot 0.034975 = 104.925$。\n标准差为 $\\sigma_{N_1} = \\sqrt{104.925} \\approx 10.24329$。\n我们寻求 $P(N_1 \\le 3050)$，其中 $N_1 \\sim \\mathcal{N}(3015, 104.925)$。我们将值 $3050$ 标准化：\n$$Z = \\frac{3050 - \\mu_{N_1}}{\\sigma_{N_1}} = \\frac{3050 - 3015}{\\sqrt{104.925}} = \\frac{35}{10.24329} \\approx 3.41680$$\n所求概率是标准正态累积分布函数 $\\Phi(Z)$ 的值：\n$$P(N_1 \\le 3050) = \\Phi(3.41680) \\approx 0.999685$$\n\n案例 C：初始种群 $N_0$ 是一个均值为 $\\lambda_0 = 200$ 的泊松随机变量。概率为 $p_d=0.04$ 和 $p_m=0.06$，因此 $p_s=0.9$。我们必须计算净变化 $\\Delta = N_1 - N_0 = r_C = -5$ 的精确概率。\n泊松过程的一个关键性质指出，如果一个服从泊松分布的个体数量被独立地进行多项式分类，那么每个结果类别中的个体数量是独立的泊松随机变量。\n令 $N_d$、$N_m$ 和 $N_s$ 分别为分裂、死亡和存活的初始细胞数量。那么：\n$N_d \\sim \\text{Poisson}(\\lambda_d = \\lambda_0 p_d = 200 \\cdot 0.04 = 8)$\n$N_m \\sim \\text{Poisson}(\\lambda_m = \\lambda_0 p_m = 200 \\cdot 0.06 = 12)$\n$N_s \\sim \\text{Poisson}(\\lambda_s = \\lambda_0 p_s = 200 \\cdot 0.9 = 180)$\n总种群规模为 $N_0 = N_d + N_m + N_s$ 和 $N_1 = 2N_d + 1N_s + 0N_m$。\n净变化为 $\\Delta = N_1 - N_0 = (2N_d + N_s) - (N_d + N_m + N_s) = N_d - N_m$。\n我们需要计算 $P(N_d - N_m = -5)$。两个独立泊松随机变量之差服从斯凯拉姆分布（Skellam distribution）。令 $Y = N_d - N_m$。则 $Y \\sim \\text{Skellam}(\\mu_1=\\lambda_d, \\mu_2=\\lambda_m)$。\n我们要求参数为 $\\mu_1 = 8$ 和 $\\mu_2 = 12$ 时的概率 $P(Y = -5)$。斯凯拉姆分布的概率质量函数是 $P(Y=k) = e^{-(\\mu_1+\\mu_2)} (\\frac{\\mu_1}{\\mu_2})^{k/2} I_{|k|}(2\\sqrt{\\mu_1\\mu_2})$，其中 $I_{|k|}$ 是第一类修正贝塞尔函数。使用计算库对 $k=-5$, $\\mu_1=8$ 和 $\\mu_2=12$ 计算该函数，得到 $P(\\Delta = -5) \\approx 0.064560$。\n\n案例 D：初始种群为 $N_0 = n_0 = 25$，且 $p_d=0$，$p_m=0.1$。存活概率为 $p_s = 1 - 0 - 0.1 = 0.9$。我们必须计算 $N_1 = k_D = 22$ 的精确概率。\n由于 $p_d=0$，没有细胞分裂。一个细胞要么存活（概率为 $0.9$），要么死亡（概率为 $0.1$）。最终的种群规模 $N_1$ 就是存活的细胞数量。这是一个经典的二项试验问题。存活的细胞数量 $S$ 服从二项分布：\n$$S \\sim \\text{Binomial}(n=n_0, p=p_s) = \\text{Binomial}(n=25, p=0.9)$$\n我们需要计算 $P(N_1=22) = P(S=22)$。使用二项分布的概率质量函数：\n$$P(S=k) = \\binom{n}{k} p^k (1-p)^{n-k}$$\n$$P(S=22) = \\binom{25}{22} (0.9)^{22} (1-0.9)^{25-22} = \\frac{25 \\cdot 24 \\cdot 23}{3 \\cdot 2 \\cdot 1} (0.9)^{22} (0.1)^3$$\n$$P(S=22) = 2300 \\cdot (0.9)^{22} \\cdot (0.001) \\approx 0.226498$$\n至此，所有案例的推导均已完成。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, skellam, binom\nfrom scipy.special import comb\n\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n#   - name: scipy\n#     version: 1.11.4\n\ndef solve_case_a(n0, pd, pm, kA):\n    \"\"\"\n    Computes the exact probability P(N1=kA) for a fixed initial population size.\n    This involves summing probabilities over all state configurations (d, m, s)\n    that result in the target population size.\n    \"\"\"\n    ps = 1 - pd - pm\n    # We require N1 = n0 + d - m = kA, which means d - m = kA - n0.\n    delta = kA - n0\n\n    total_prob = 0.0\n    # Iterate through all possible numbers of deaths 'm'\n    for m in range(n0 + 1):\n        # From d - m = delta, we get d = m + delta\n        d = m + delta\n        # The numbers of divisions and deaths must be non-negative\n        if d  0:\n            continue\n        # The sum of cells undergoing any fate cannot exceed the initial population\n        if d + m > n0:\n            break\n        \n        s = n0 - d - m\n        \n        # Multinomial coefficient: n! / (d! * m! * s!)\n        # Calculated as comb(n,d) * comb(n-d,m) to avoid large numbers in factorial\n        coeff = comb(n0, d, exact=True) * comb(n0 - d, m, exact=True)\n        prob = coeff * (pd ** d) * (pm ** m) * (ps ** s)\n        total_prob += prob\n        \n    return total_prob\n\ndef solve_case_b(n0, pd, pm, kB):\n    \"\"\"\n    Computes P(N1 = kB) using a Gaussian approximation for the final population size.\n    \"\"\"\n    ps = 1 - pd - pm\n    # Mean and variance of the number of offspring from a single cell (X)\n    mu_x = 2 * pd + 1 * ps\n    e_x_sq = 4 * pd + 1 * ps\n    var_x = e_x_sq - mu_x**2\n    \n    # Mean and variance of the total final population (N1)\n    mu_n1 = n0 * mu_x\n    var_n1 = n0 * var_x\n    \n    # Use the CDF of the normal distribution\n    return norm.cdf(kB, loc=mu_n1, scale=np.sqrt(var_n1))\n\ndef solve_case_c(lambda0, pd, pm, rC):\n    \"\"\"\n    Computes the exact probability that the net change N1 - N0 is rC,\n    when the initial population N0 is a Poisson random variable.\n    \"\"\"\n    # The number of dividing and dying cells are independent Poisson variables\n    lambda_d = lambda0 * pd\n    lambda_m = lambda0 * pm\n    \n    # The net change N1 - N0 is the difference between the number of divisions \n    # and the number of deaths, which follows a Skellam distribution.\n    return skellam.pmf(rC, lambda_d, lambda_m)\n\ndef solve_case_d(n0, pd, pm, kD):\n    \"\"\"\n    Computes the exact probability P(N1=kD) in the case of no divisions (pd=0).\n    This simplifies to a binomial probability.\n    \"\"\"\n    ps = 1 - pd - pm\n    # With no divisions, N1 is the number of surviving cells, which follows\n    # a binomial distribution.\n    return binom.pmf(kD, n0, ps)\n\ndef solve():\n    \"\"\"\n    Solves all test cases and prints the results in the required format.\n    \"\"\"\n    # Define test case parameters.\n    # Case A: (n0, pd, pm, kA)\n    # Case B: (n0, pd, pm, kB)\n    # Case C: (lambda0, pd, pm, rC)\n    # Case D: (n0, pd, pm, kD)\n    test_cases = {\n        'A': (10, 0.3, 0.2, 12),\n        'B': (3000, 0.02, 0.015, 3050),\n        'C': (200, 0.04, 0.06, -5),\n        'D': (25, 0.0, 0.1, 22),\n    }\n\n    # Calculate results for each case\n    result_a = solve_case_a(*test_cases['A'])\n    result_b = solve_case_b(*test_cases['B'])\n    result_c = solve_case_c(*test_cases['C'])\n    result_d = solve_case_d(*test_cases['D'])\n\n    results = [result_a, result_b, result_c, result_d]\n\n    # Format results to six decimal places and print\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2381044"}]}