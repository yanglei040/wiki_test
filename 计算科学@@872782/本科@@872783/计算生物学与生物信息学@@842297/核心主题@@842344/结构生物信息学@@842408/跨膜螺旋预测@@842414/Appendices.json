{"hands_on_practices": [{"introduction": "跨膜螺旋的预测严重依赖于我们如何量化氨基酸的疏水性。这个练习探讨了一个核心问题：不同的疏水性/亲水性标度是否会得出相同的结论？通过设计一个在不同标度下表现迥异的“变色龙”肽段，你将亲身体会到模型参数选择对预测结果的决定性影响，并锻炼你使用数学不等式解决生物信息学问题的分析能力。[@problem_id:2415773]", "problem": "一个长度为 $21$ 的肽段，使用两种不同的残基属性标度来评估其跨膜螺旋倾向：Kyte–Doolittle (KD) 疏水性标度和 Hopp–Woods (HW) 亲水性标度。假设该肽段仅由亮氨酸 ($\\mathrm{L}$) 和赖氨酸 ($\\mathrm{K}$) 组成。使用以下标度值：\n- KD 疏水性指数：$\\mathrm{L}: 3.8$, $\\mathrm{K}: -3.9$。\n- HW 亲水性指数：$\\mathrm{L}: -1.8$, $\\mathrm{K}: 3.0$。\n\n对于等于整个肽段长度（$21$个残基）的窗口，分类标准定义如下：\n- 使用 Kyte–Doolittle (KD) 疏水性标度，如果平均 KD 疏水性至少为 $1.6$，则该肽段被预测为跨膜螺旋。\n- 使用 Hopp–Woods (HW) 亲水性标度，如果平均 HW 亲水性严格小于 $-0.5$，则该肽段被预测为跨膜螺旋；否则不被预测为跨膜螺旋。\n\n这里的“变色龙”序列是指根据 KD 标准被预测为跨膜螺旋，但根据 HW 标准不被预测为跨膜螺旋的序列。\n\n设 $n_{\\mathrm{L}}$ 和 $n_{\\mathrm{K}}$ 分别表示 $\\mathrm{L}$ 和 $\\mathrm{K}$ 的数量，且 $n_{\\mathrm{L}} + n_{\\mathrm{K}} = 21$。确定所需的赖氨酸 $n_{\\mathrm{K}}$ 的最小数量，使得至少存在一个这样的 $21$-聚体（仅由 $\\mathrm{L}$ 和 $\\mathrm{K}$ 组成），根据上述标准，它被 KD 预测为跨膜螺旋，但 HW 不这么预测。请以整数形式表达您的答案。无需四舍五入。", "solution": "该问题要求确定在一个长度为 $21$、仅由亮氨酸 ($\\mathrm{L}$) 和赖氨酸 ($\\mathrm{K}$) 组成的肽段中，赖氨酸 ($\\mathrm{K}$) 残基的最小数量（表示为 $n_{\\mathrm{K}}$），使得该肽段根据 Kyte–Doolittle (KD) 标度被分类为跨膜螺旋，但根据 Hopp–Woods (HW) 标度不被分类为跨膜螺旋。\n\n首先，我们将问题形式化。设 $n_{\\mathrm{L}}$ 和 $n_{\\mathrm{K}}$ 分别是亮氨酸和赖氨酸残基的数量。肽段的总长度给定为 $N = 21$。\n组成约束为：\n$$ n_{\\mathrm{L}} + n_{\\mathrm{K}} = 21 $$\n这使我们可以将 $n_{\\mathrm{L}}$ 用 $n_{\\mathrm{K}}$ 表示为 $n_{\\mathrm{L}} = 21 - n_{\\mathrm{K}}$。\n\n残基属性指数如下：\n- Kyte–Doolittle (KD) 疏水性：$H_{KD}(\\mathrm{L}) = 3.8$, $H_{KD}(\\mathrm{K}) = -3.9$。\n- Hopp–Woods (HW) 亲水性：$H_{HW}(\\mathrm{L}) = -1.8$, $H_{HW}(\\mathrm{K}) = 3.0$。\n\n给定标度的平均得分是残基得分之和除以肽段长度。\n平均 KD 疏水性 $\\overline{H_{KD}}$ 为：\n$$ \\overline{H_{KD}} = \\frac{n_{\\mathrm{L}} H_{KD}(\\mathrm{L}) + n_{\\mathrm{K}} H_{KD}(\\mathrm{K})}{N} = \\frac{(21 - n_{\\mathrm{K}})(3.8) + n_{\\mathrm{K}}(-3.9)}{21} $$\n平均 HW 亲水性 $\\overline{H_{HW}}$ 为：\n$$ \\overline{H_{HW}} = \\frac{n_{\\mathrm{L}} H_{HW}(\\mathrm{L}) + n_{\\mathrm{K}} H_{HW}(\\mathrm{K})}{N} = \\frac{(21 - n_{\\mathrm{K}})(-1.8) + n_{\\mathrm{K}}(3.0)}{21} $$\n\n一个“变色龙”序列必须同时满足两个条件：\n1. 根据 KD 标准被预测为跨膜螺旋：$\\overline{H_{KD}} \\ge 1.6$。\n2. 根据 HW 标准*不*被预测为跨膜螺旋。HW 对跨膜螺旋的预测标准是 $\\overline{H_{HW}}  -0.5$。因此，*不*是跨膜螺旋的条件是 $\\overline{H_{HW}} \\ge -0.5$。\n\n我们必须为整数变量 $n_{\\mathrm{K}}$ 求解这两个不等式组成的方程组。\n\n让我们分析第一个不等式（KD 标准）：\n$$ \\frac{(21 - n_{\\mathrm{K}})(3.8) + n_{\\mathrm{K}}(-3.9)}{21} \\ge 1.6 $$\n两边同乘以 $21$：\n$$ (21 - n_{\\mathrm{K}})(3.8) - 3.9 n_{\\mathrm{K}} \\ge 1.6 \\times 21 $$\n$$ 79.8 - 3.8 n_{\\mathrm{K}} - 3.9 n_{\\mathrm{K}} \\ge 33.6 $$\n$$ 79.8 - 7.7 n_{\\mathrm{K}} \\ge 33.6 $$\n整理各项以求解 $n_{\\mathrm{K}}$：\n$$ 79.8 - 33.6 \\ge 7.7 n_{\\mathrm{K}} $$\n$$ 46.2 \\ge 7.7 n_{\\mathrm{K}} $$\n$$ n_{\\mathrm{K}} \\le \\frac{46.2}{7.7} $$\n$$ n_{\\mathrm{K}} \\le 6 $$\n\n接下来，我们分析第二个不等式（HW 标准）：\n$$ \\frac{(21 - n_{\\mathrm{K}})(-1.8) + n_{\\mathrm{K}}(3.0)}{21} \\ge -0.5 $$\n两边同乘以 $21$：\n$$ (21 - n_{\\mathrm{K}})(-1.8) + 3.0 n_{\\mathrm{K}} \\ge -0.5 \\times 21 $$\n$$ -37.8 + 1.8 n_{\\mathrm{K}} + 3.0 n_{\\mathrm{K}} \\ge -10.5 $$\n$$ -37.8 + 4.8 n_{\\mathrm{K}} \\ge -10.5 $$\n整理各项：\n$$ 4.8 n_{\\mathrm{K}} \\ge 37.8 - 10.5 $$\n$$ 4.8 n_{\\mathrm{K}} \\ge 27.3 $$\n$$ n_{\\mathrm{K}} \\ge \\frac{27.3}{4.8} $$\n$$ n_{\\mathrm{K}} \\ge 5.6875 $$\n\n要使一个“变色龙”序列存在，$n_{\\mathrm{K}}$ 必须同时满足这两个推导出的条件。由于 $n_{\\mathrm{K}}$ 必须是代表残基数量的整数，我们必须找到位于两个解集交集中的 $n_{\\mathrm{K}}$ 的整数值：\n$$ n_{\\mathrm{K}} \\le 6 \\quad \\text{and} \\quad n_{\\mathrm{K}} \\ge 5.6875 $$\n唯一同时满足这两个不等式的整数是 $n_{\\mathrm{K}} = 6$。\n这意味着“变色龙”序列只在包含恰好 $6$ 个赖氨酸残基（因此有 $21 - 6 = 15$ 个亮氨酸残基）时才可能存在。\n问题要求赖氨酸的*最小*数量。由于 $n_{\\mathrm{K}} = 6$ 是唯一可能的整数值，它必然是最小值。任何小于 $6$ 的整数 $n_{\\mathrm{K}}$ 都会违反第二个条件，而任何大于 $6$ 的整数 $n_{\\mathrm{K}}$ 都会违反第一个条件。\n因此，所需的赖氨酸最小数量是 $6$。", "answer": "$$\\boxed{6}$$", "id": "2415773"}, {"introduction": "现实中的蛋白质预测不仅仅是计算整个序列的平均性质，而是要识别其中的局部特征。这个练习将指导你实现一个完整且经典的滑动窗口算法，将氨基酸序列视为一种数字信号。你将学习如何通过与一个特定形状的核（汉宁窗）进行卷积来平滑疏水性信号，并最终根据阈值和长度标准识别出潜在的跨膜螺旋。[@problem_id:2415771]", "problem": "给定一个由标准$20$字母字母表构成的有限氨基酸序列，要求您通过将序列建模为实值离散信号并应用形状匹配评分规则，来预测序列中跨膜（TM）螺旋的位置。每个氨基酸$a$使用Kyte–Doolittle（KD）标度映射到一个实值亲水性指数$h(a)$。要使用的KD值定义如下：$h(\\mathrm{I}) = 4.5$, $h(\\mathrm{V}) = 4.2$, $h(\\mathrm{L}) = 3.8$, $h(\\mathrm{F}) = 2.8$, $h(\\mathrm{C}) = 2.5$, $h(\\mathrm{M}) = 1.9$, $h(\\mathrm{A}) = 1.8$, $h(\\mathrm{G}) = -0.4$, $h(\\mathrm{T}) = -0.7$, $h(\\mathrm{S}) = -0.8$, $h(\\mathrm{W}) = -0.9$, $h(\\mathrm{Y}) = -1.3$, $h(\\mathrm{P}) = -1.6$, $h(\\mathrm{H}) = -3.2$, $h(\\mathrm{E}) = -3.5$, $h(\\mathrm{Q}) = -3.5$, $h(\\mathrm{D}) = -3.5$, $h(\\mathrm{N}) = -3.5$, $h(\\mathrm{K}) = -3.9$, $h(\\mathrm{R}) = -4.5$。\n\n设氨基酸序列为$x[0], x[1], \\dots, x[N-1]$，其中整数$N \\ge 1$。定义亲水性信号$H[n] = h(x[n])$，其中$n \\in \\{0,1,\\dots,N-1\\}$。设$L$为一个正奇数窗口长度，并定义一个长度为$L$的非负对称核$K[j]$，其由升余弦（Hann）轮廓给出\n$$\nW[j] = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(\\tfrac{2\\pi j}{L-1}\\right), \\quad j = 0,1,\\dots,L-1,\n$$\n并归一化使其和为1，\n$$\nK[j] = \\frac{W[j]}{\\sum_{m=0}^{L-1} W[m]}, \\quad j = 0,1,\\dots,L-1.\n$$\n为每个有效位置$i \\in \\{0,1,\\dots,N-L\\}$定义窗口化亲水性分数\n$$\nS[i] = \\sum_{j=0}^{L-1} K[j] \\, H[i+j].\n$$\n给定一个阈值$\\theta \\in \\mathbb{R}$，定义高于阈值的窗口起始点集合\n$$\n\\mathcal{I} = \\{\\, i \\in \\{0,1,\\dots,N-L\\} \\mid S[i] \\ge \\theta \\,\\}.\n$$\n将$\\mathcal{I}$划分为索引空间中的最大连续运行区间。对于每个具有最小索引$i_{\\min}$和最大索引$i_{\\max}$的运行区间，定义一个预测的TM螺旋片段为包含性残基索引区间$[i_{\\min}, \\, i_{\\max} + L - 1]$。从所有这些区间的集合中，丢弃任何长度（定义为$1 + \\text{end} - \\text{start}$）小于最小长度$L_{\\min} \\in \\mathbb{N}$的区间。最终预测的TM螺旋集合是剩余区间的集合，每个区间表示为一对整数$[\\text{start}, \\text{end}]$，使用从零开始的索引和包含性端点。\n\n在所有计算中使用以下固定参数：窗口长度 $L = 19$，阈值 $\\theta = 1.6$，最小长度 $L_{\\min} = 17$。\n\n测试套件。对于下面的每个序列，根据上述定义计算预测的TM螺旋片段。\n\n- Case $1$: $x = \\text{\"MKTLLLVLALLAVVVVVVVVVVVVVVVAGGQ\"}$。\n- Case $2$: $x = \\text{\"LLLLLLLLLLLLLLLLLLLLNNNNNKKQ\"}$。\n- Case $3$: $x = \\text{\"NNNNNKKQLLLLLLLLLLLLLLLLLLL\"}$。\n- Case $4$: $x = \\text{\"GSDNSTQEKHPRYTNQDSKE\"}$。\n- Case $5$: $x = \\text{\"AAAAALLLLLLLLLLLLLLLAAAAAAKKKKKLLLLLLLLLLLLLLLLAAAAA\"}$。\n- Case $6$: $x = \\text{\"ACDEFGHIK\"}$。\n\n答案规范。对于每种情况，输出必须是一个区间列表$[\\text{start},\\text{end}]$，其中$\\text{start}$和$\\text{end}$都是整数。如果没有预测到TM螺旋，则为该情况输出空列表$[\\,]$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。第$k$个元素对应于情况$k$，并且其本身必须是如上指定的区间列表，例如，对于两个预测的螺旋为$[[0,18],[25,43]]$，如果没有则为$[]$。不涉及角度，也不需要物理单位。所有索引都必须使用从零开始的包含性端点报告。最终打印的行必须具有$[r_1,r_2,\\dots,r_6]$的形式，其中每个$r_k$是情况$k$的区间列表。", "solution": "用户提交了一个关于预测氨基酸序列中跨膜螺旋的问题。在继续之前，我将首先验证问题陈述的科学合理性和清晰度。\n\n### 第1步：提取已知信息\n-   **氨基酸亲水性**：20种标准氨基酸中的每一种$a$都被映射到一个Kyte-Doolittle亲水性指数$h(a)$。具体数值已提供。\n-   **输入**：一个长度为$N \\ge 1$的氨基酸序列$x[0], x[1], \\dots, x[N-1]$。\n-   **信号生成**：序列被转换为一个亲水性信号$H[n] = h(x[n])$。\n-   **核定义**：为$j \\in \\{0, 1, \\dots, L-1\\}$定义了一个长度为$L$的归一化Hann窗核$K[j]$。\n    -   升余弦轮廓：$W[j] = \\frac{1}{2} - \\frac{1}{2}\\cos\\left(\\frac{2\\pi j}{L-1}\\right)$。\n    -   归一化：$K[j] = W[j] / \\sum_{m=0}^{L-1} W[m]$。\n-   **评分**：对于每个有效的起始位置$i \\in \\{0, 1, \\dots, N-L\\}$，通过将信号$H$与核$K$进行卷积来计算窗口化分数$S[i]$：$S[i] = \\sum_{j=0}^{L-1} K[j] H[i+j]$。\n-   **阈值处理**：形成一个窗口索引集合$\\mathcal{I}$，其中分数超过阈值$\\theta$：$\\mathcal{I} = \\{ i \\mid S[i] \\ge \\theta \\}$。\n-   **螺旋定义**：集合$\\mathcal{I}$被划分为最大连续运行区间。每个具有最小索引$i_{\\min}$和最大索引$i_{\\max}$的运行区间定义了一个预测的螺旋区间为$[i_{\\min}, i_{\\max} + L - 1]$。\n-   **筛选**：如果预测的螺旋长度$1 + \\text{end} - \\text{start}$小于最小长度$L_{\\min}$，则将其丢弃。\n-   **参数**：问题指定了固定参数：窗口长度$L = 19$，阈值$\\theta = 1.6$，最小螺旋长度$L_{\\min} = 17$。\n-   **测试用例**：提供了六个特定的氨基酸序列进行分析。\n-   **输出规范**：为每种情况报告一个由零开始、包含端点的整数区间$[\\text{start}, \\text{end}]$的列表。最终输出必须是包含这些结果列表的单行。\n\n### 第2步：使用提取的已知信息进行验证\n-   **科学依据**：该方法是生物信息学中用于识别跨膜结构域的一种成熟技术。其原理是跨膜螺旋主要由疏水性氨基酸组成。Kyte-Doolittle标度是亲水性的标准度量，而使用滑动窗口（特别是Hann窗）进行平滑是标准的信号处理技术。该方法在科学上是有效的。\n-   **适定性**：问题以数学精度进行表述。所有参数和程序都已明确定义，确保可以为任何给定的输入序列计算出唯一且稳定的解。\n-   **客观性**：问题陈述客观，没有歧义或主观论断。定义的算法是确定性的。\n\n### 第3步：结论与行动\n问题陈述是有效的。它具有科学依据、适定性和客观性。我现在将着手提供一个完整的解决方案。\n\n### 算法解决方案\n任务是实现一个信号处理流程，以检测蛋白质序列中的疏水区域，这些区域是跨膜（TM）螺旋的特征。该算法分几个不同阶段进行。\n\n1.  **信号转换**：初始输入，即一个符号化的氨基酸序列，被转换为一个实值离散信号。这是通过将长度为$N$的输入序列中的每个氨基酸$x[n]$映射到其对应的Kyte-Doolittle亲水性指数$h(x[n])$来实现的，从而产生数值信号$H[n]$，其中$n \\in \\{0, 1, \\dots, N-1\\}$。正值表示疏水性，而负值表示亲水性。\n\n2.  **基于核的平滑**：跨膜螺旋是伸展结构，通常跨越17到25个残基。为了识别这些区域，必须对局部亲水性值进行平均。这是通过将亲水性信号$H$与一个平滑核$K$进行卷积来完成的。问题指定了19个残基的窗口长度$L=19$，这与TM螺旋的典型长度相匹配。核函数由一个Hann窗轮廓导出，公式为\n    $$\n    W[j] = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(\\tfrac{2\\pi j}{L-1}\\right), \\quad j = 0,1,\\dots,L-1.\n    $$\n    该窗函数赋予窗口中心的残基更多权重，而边缘的残基权重较小。核$K[j]$被归一化使其和为1，即$\\sum_{j=0}^{L-1} K[j] = 1$，通过将$W[j]$除以其总和$\\sum_{m=0}^{L-1} W[m] = (L-1)/2$来实现。对于$L=19$，这个总和是9。然后，每个窗口起始位置$i$的平滑亲水性分数计算如下：\n    $$\n    S[i] = \\sum_{j=0}^{L-1} K[j] H[i+j].\n    $$\n    此操作对所有有效的窗口位置$i \\in \\{0, 1, \\dots, N-L\\}$执行。在计算上，这是信号$H$与对称核$K$（$K[j] = K[L-1-j]$）的离散卷积。\n\n3.  **疏水核心的识别**：分数$S[i]$代表从索引$i$开始的长度为$L$的窗口的平均疏水性。高分表明可能存在一个TM螺旋片段。通过应用阈值$\\theta=1.6$来识别这些片段。所有满足$S[i] \\ge \\theta$的窗口起始索引$i$被收集到一个集合$\\mathcal{I}$中。\n\n4.  **螺旋边界的划定**：集合$\\mathcal{I}$包含了所有被认为足够疏水的窗口的起始索引。一个连续的此类窗口段被推断为属于单个TM螺旋。因此，$\\mathcal{I}$被划分为最大连续索引运行区间。对于每个运行区间，我们确定其最小和最大索引$i_{\\min}$和$i_{\\max}$。该运行区间表示一个从残基$i_{\\min}$到残基$i_{\\max} + L - 1$的疏水核心区域。预测螺旋的起始点是运行区间中第一个窗口的起始点（$i_{\\min}$），而螺旋的终点是运行区间中最后一个窗口的终点（$i_{\\max} + L - 1$）。\n\n5.  **长度筛选**：在生物物理学上，一个TM螺旋必须具有一定的最小长度才能跨越细胞膜。问题通过指定最小长度$L_{\\min}=17$来施加此约束。任何长度为$1 + \\text{end} - \\text{start}  L_{\\min}$的预测螺旋区间$[\\text{start}, \\text{end}]$都将被丢弃，因为这在生物学上是不合理的。\n\n最终输出是所有满足长度约束的预测螺旋区间的集合。下面的Python代码实现了这个完整的流程。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Predicts transmembrane helices in amino acid sequences based on a\n    hydropathy scoring algorithm.\n    \"\"\"\n    # Define the Kyte-Doolittle hydropathy scale.\n    KD_SCALE = {\n        'I': 4.5, 'V': 4.2, 'L': 3.8, 'F': 2.8, 'C': 2.5,\n        'M': 1.9, 'A': 1.8, 'G': -0.4, 'T': -0.7, 'S': -0.8,\n        'W': -0.9, 'Y': -1.3, 'P': -1.6, 'H': -3.2, 'E': -3.5,\n        'Q': -3.5, 'D': -3.5, 'N': -3.5, 'K': -3.9, 'R': -4.5\n    }\n    \n    # Define fixed parameters from the problem statement.\n    L = 19       # Window length\n    THETA = 1.6  # Hydropathy score threshold\n    L_MIN = 17   # Minimal helix length\n\n    # Pre-compute the normalized Hann window kernel.\n    # The sum of numpy.hanning window weights is (L-1)/2 for L > 1.\n    W = 0.5 - 0.5 * np.cos(2 * np.pi * np.arange(L) / (L - 1))\n    K = W / np.sum(W)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"MKTLLLVLALLAVVVVVVVVVVVVVVVAGGQ\",\n        \"LLLLLLLLLLLLLLLLLLLLNNNNNKKQ\",\n        \"NNNNNKKQLLLLLLLLLLLLLLLLLLL\",\n        \"GSDNSTQEKHPRYTNQDSKE\",\n        \"AAAAALLLLLLLLLLLLLLLAAAAAAKKKKKLLLLLLLLLLLLLLLLAAAAA\",\n        \"ACDEFGHIK\",\n    ]\n\n    all_results = []\n    for seq in test_cases:\n        N = len(seq)\n\n        # If the sequence is shorter than the window length, no analysis is possible.\n        if N  L:\n            all_results.append([])\n            continue\n\n        # 1. Convert the amino acid sequence to a hydropathy signal H.\n        H = np.array([KD_SCALE[aa] for aa in seq])\n\n        # 2. Calculate the windowed hydropathy score S by convolving H with K.\n        # numpy.convolve with mode='valid' computes the required sum S[i].\n        S = np.convolve(H, K, mode='valid')\n\n        # 3. Find all window start indices where the score is above the threshold.\n        above_threshold_indices = np.where(S = THETA)[0]\n\n        if len(above_threshold_indices) == 0:\n            all_results.append([])\n            continue\n\n        # 4. Partition the indices into maximal contiguous runs.\n        # This is done by splitting the array where the difference between adjacent elements is > 1.\n        runs = np.split(above_threshold_indices, np.where(np.diff(above_threshold_indices)  1)[0] + 1)\n\n        predicted_helices = []\n        for run in runs:\n            if len(run) == 0:\n                continue\n\n            # 5. Define the helix interval from the run's start and end indices.\n            i_min = run[0]\n            i_max = run[-1]\n            \n            start_res = i_min\n            end_res = i_max + L - 1\n\n            # 6. Filter out helices that are shorter than the minimum length.\n            length = end_res - start_res + 1\n            if length = L_MIN:\n                predicted_helices.append([int(start_res), int(end_res)])\n        \n        all_results.append(predicted_helices)\n\n    # Format the final results into the specified single-line string format.\n    # Example: [[[0,18],[25,43]],[],...]\n    formatted_results = []\n    for res_list in all_results:\n        if not res_list:\n            formatted_results.append(\"[]\")\n        else:\n            intervals_str = \",\".join([f\"[{s},{e}]\" for s, e in res_list])\n            formatted_results.append(f\"[{intervals_str}]\")\n    \n    # Final print statement in the exact required format.\n    # print(f\"[{','.join(formatted_results)}]\") # This is for running locally. The return value is the final answer string.\n    return f\"[{','.join(formatted_results)}]\"\n\n# To generate the answer, we call the function.\n# final_answer = solve()\n```", "answer": "[[[4,28]],[[0,19]],[[8,28]],[],[[5,25],[31,51]],[]]", "id": "2415771"}, {"introduction": "超越简单的滑动窗口，隐马尔可夫模型（HMM）为结构预测提供了更强大的概率框架，它能够模拟区域间的转换和特征的典型长度。本练习不仅要求你应用维特比算法来解码最可能的蛋白质结构，更重要的是，通过将一个为α螺旋设计的HMM应用于一个β桶蛋白序列，你将学会如何通过分析模型的“错误”输出来洞察其内在的偏见和局限性。这是理解任何计算模型适用范围的关键一步。[@problem_id:2415695]", "problem": "跨膜螺旋（TM）预测模型被形式化为一个离散的隐马尔可夫模型（HMM），其中隐藏状态代表生物区域：内环、螺旋和外环。您将评估这个面向螺旋的模型在被迫解释包含类似β-桶交替模式的氨基酸序列时的行为。目标是通过计算给定模型下每个序列最可能的隐藏状态路径的特定、明确定义的统计数据来量化模型的偏差。\n\n模型定义。设隐藏状态集为 $S=\\{I,H,O\\}$，分别对应内环 $I$、跨膜螺旋 $H$ 和外环 $O$。初始分布为 $\\pi(I)=1$ 和 $\\pi(H)=\\pi(O)=0$。状态转移矩阵 $A=(a_{uv})_{u,v\\in S}$ 由下式给出\n$$\na_{II}=0.95,\\;\\;a_{IH}=0.05,\\;\\;a_{IO}=0,\\quad\na_{HH}=0.95,\\;\\;a_{HO}=0.05,\\;\\;a_{HI}=0,\\quad\na_{OO}=0.95,\\;\\;a_{OI}=0.05,\\;\\;a_{OH}=0.\n$$\n这施加了大约 $1/(1-0.95)=20$ 个残基的预期螺旋长度，并强制执行一个 $I\\to H\\to O\\to I$ 的循环。\n\n发射概率是根据 Kyte–Doolittle 亲水性标度 $h(r)$ 定义的，适用于标准20字母表 $\\mathcal{A}=\\{\\text{A},\\text{C},\\text{D},\\text{E},\\text{F},\\text{G},\\text{H},\\text{I},\\text{K},\\text{L},\\text{M},\\text{N},\\text{P},\\text{Q},\\text{R},\\text{S},\\text{T},\\text{V},\\text{W},\\text{Y}\\}$ 中的每个氨基酸 $r\\in\\mathcal{A}$。亲水性值如下：\n$$\nh(\\text{I})=4.5,\\;h(\\text{V})=4.2,\\;h(\\text{L})=3.8,\\;h(\\text{F})=2.8,\\;h(\\text{C})=2.5,\\;h(\\text{M})=1.9,\\;h(\\text{A})=1.8,\\;h(\\text{G})=-0.4,\\\\\nh(\\text{T})=-0.7,\\;h(\\text{S})=-0.8,\\;h(\\text{W})=-0.9,\\;h(\\text{Y})=-1.3,\\;h(\\text{P})=-1.6,\\;h(\\text{H})=-3.2,\\;h(\\text{E})=-3.5,\\\\\nh(\\text{Q})=-3.5,\\;h(\\text{D})=-3.5,\\;h(\\text{N})=-3.5,\\;h(\\text{K})=-3.9,\\;h(\\text{R})=-4.5.\n$$\n设 $\\lambda=0.5$。发射分布由玻尔兹曼型权重定义，该权重有利于疏水性残基出现在螺旋中，而不利于它们出现在环中：\n$$\nb_H(r)=\\frac{\\exp(\\lambda\\,h(r))}{Z_H},\\qquad b_I(r)=b_O(r)=\\frac{\\exp(-\\lambda\\,h(r))}{Z_L},\n$$\n其中 $Z_H=\\sum_{a\\in\\mathcal{A}}\\exp(\\lambda\\,h(a))$ 和 $Z_L=\\sum_{a\\in\\mathcal{A}}\\exp(-\\lambda\\,h(a))$ 确保了归一化。\n\n对于一个观测到的氨基酸序列 $x_{1:L}\\in\\mathcal{A}^L$，将最可能的状态路径 $\\hat{q}_{1:L}\\in S^L$ 定义为在 $\\pi$、$A$ 和发射分布 $b_s(\\cdot)$ 下，使联合概率 $\\Pr(q_{1:L},x_{1:L})$ 最大化的任何序列。从 $\\hat{q}_{1:L}$ 中，计算以下统计数据：\n- $N_H$：螺旋片段的数量，定义为 $\\hat{q}_{1:L}$ 中状态 $H$ 的最大连续运行次数。\n- $L_{\\max}$：最长螺旋片段的长度（以残基为单位）。\n- $f_{\\text{charged}\\to H}$：被分配到状态 $H$ 的带电残基的比例（以小数表示），其中带电残基为 $\\{\\text{D},\\text{E},\\text{K},\\text{R},\\text{H}\\}$。如果序列不含带电残基，按惯例将此比例定义为 $0$。\n- $\\ell$：每个残基的平均对数联合概率，定义为 $\\ell=\\frac{1}{L}\\log \\Pr(\\hat{q}_{1:L},x_{1:L})$，使用自然对数。\n\n测试套件。对以下四个序列评估上述内容：\n- 案例 $1$（螺旋片段）: $x^{(1)}=\\text{\"MKK\"}+\\text{\"L\"}^{30}+\\text{\"A\"}^{5}+\\text{\"KK\"}$。\n- 案例 $2$（类似β-桶的交替模式）: $x^{(2)}=(\\text{\"VT\"})^{60}$。\n- 案例 $3$（高度可溶性）: $x^{(3)}=(\\text{\"DEKQNST\"})^{20}$。\n- 案例 $4$（接近螺旋长度先验的短疏水性运行）: $x^{(4)}=\\text{\"N\"}^{7}+\\text{\"L\"}^{12}+\\text{\"N\"}^{7}+\\text{\"L\"}^{8}+\\text{\"N\"}^{7}$。\n\n答案规范。对于每个案例 $i\\in\\{1,2,3,4\\}$，您的程序必须输出列表 $[N_H^{(i)},L_{\\max}^{(i)},f_{\\text{charged}\\to H}^{(i)},\\ell^{(i)}]$，其中实值量 $f_{\\text{charged}\\to H}^{(i)}$ 和 $\\ell^{(i)}$ 四舍五入到小数点后三位。您的程序应生成单行输出，其中包含按案例1到4的顺序排列的结果，结果为用方括号括起来的逗号分隔列表，每个案例的结果本身也是一个用方括号括起来的逗号分隔列表。例如，两个假设案例的输出将如下所示：$[[1,20,0.125,-1.234],[0,0,0.000,-2.718]]$。\n\n最终输出必须严格遵守此格式，并包含如上所述的四个案例摘要。", "solution": "该问题要求对给定隐马尔可夫模型（HMM）在几个氨基酸序列上进行分析。解决方案涉及使用维特比（Viterbi）算法为每个序列找到最可能的隐藏状态路径，然后从此路径计算一组指定的统计数据。\n\nHMM 由以下部分定义：\n- 一个包含 $3$ 个隐藏状态的集合 $S=\\{I, H, O\\}$，分别对应内环、跨膜螺旋和外环。\n- 初始状态分布 $\\pi$，其中 $\\pi(I)=1$ 且 $\\pi(H)=\\pi(O)=0$。\n- 一个状态转移矩阵 $A=(a_{uv})$。\n- 一组发射分布 $b_s(r)$，适用于每个状态 $s \\in S$ 和氨基酸 $r \\in \\mathcal{A}$。\n\n维特比（Viterbi）算法是寻找最可能隐藏状态序列 $\\hat{q}_{1:L} = (\\hat{q}_1, ..., \\hat{q}_L)$ 的标准方法，该序列导致给定的观测序列 $x_{1:L} = (x_1, ..., x_L)$。该路径使联合概率 $\\Pr(q_{1:L}, x_{1:L})$ 最大化。该算法通过动态规划工作，并且为了防止长序列的数值下溢，计算在对数空间中进行。\n\n首先，我们以对数形式预先计算必要的参数。\n\n**1. 对数空间中的 HMM 参数**\n\n发射概率由下式给出：\n$$b_H(r)=\\frac{\\exp(\\lambda\\,h(r))}{Z_H}, \\quad b_I(r)=b_O(r)=\\frac{\\exp(-\\lambda\\,h(r))}{Z_L}$$\n其中 $\\lambda=0.5$。归一化常数 $Z_H$ 和 $Z_L$ 是对字母表 $\\mathcal{A}$ 中所有20个氨基酸的求和：\n$$Z_H=\\sum_{a\\in\\mathcal{A}}\\exp(\\lambda\\,h(a)), \\qquad Z_L=\\sum_{a\\in\\mathcal{A}}\\exp(-\\lambda\\,h(a))$$\n使用提供的亲水性值 $h(r)$，这些常数计算得出 $Z_H \\approx 53.0031$ 和 $Z_L \\approx 35.1311$。\n\n对数发射概率为：\n$$\\log b_H(r) = \\lambda h(r) - \\log Z_H$$\n$$\\log b_I(r) = \\log b_O(r) = -\\lambda h(r) - \\log Z_L$$\n\n对数转移概率 $\\log a_{uv}$ 从给定的矩阵 $A$ 计算得出。概率为 $0$ 的转移其对数概率为 $-\\infty$。\n$$\n\\log A =\\begin{pmatrix}\n\\log(0.95)  \\log(0.05)  -\\infty \\\\\n-\\infty  \\log(0.95)  \\log(0.05) \\\\\n\\log(0.05)  -\\infty  \\log(0.95)\n\\end{pmatrix}\n\\approx\n\\begin{pmatrix}\n-0.0513  -2.9957  -\\infty \\\\\n-\\infty  -0.0513  -2.9957 \\\\\n-2.9957  -\\infty  -0.0513\n\\end{pmatrix}\n$$\n\n初始对数概率为 $\\log \\pi = (\\log(1), \\log(0), \\log(0)) = (0, -\\infty, -\\infty)$。\n\n**2. 维特比（Viterbi）算法**\n\n设 $V_t(s)$ 为任何长度为 $t$、以状态 $s \\in S$ 结束并发出前缀 $x_{1:t}$ 的路径的最大对数概率。我们还维护一个用于重构路径的回溯指针矩阵 $ptr_t(s)$。\n\n- **初始化 ($t=1$)：**对于每个状态 $s \\in S$，\n$$V_1(s) = \\log \\pi(s) + \\log b_s(x_1)$$\n给定初始分布，这简化为 $V_1(I) = \\log b_I(x_1)$ 和 $V_1(H) = V_1(O) = -\\infty$。\n\n- **递归 ($t=2, \\dots, L$)：**对于每个状态 $s \\in S$，\n$$V_t(s) = \\log b_s(x_t) + \\max_{u \\in S} \\{ V_{t-1}(u) + \\log a_{us} \\}$$\n$$ptr_t(s) = \\arg\\max_{u \\in S} \\{ V_{t-1}(u) + \\log a_{us} \\}$$\n\n- **终止：**最可能路径的对数概率是维特比矩阵最后一列中的最大概率：\n$$\\log \\Pr(\\hat{q}_{1:L}, x_{1:L}) = \\max_{s \\in S} \\{ V_L(s) \\}$$\n路径的最终状态是：\n$$\\hat{q}_L = \\arg\\max_{s \\in S} \\{ V_L(s) \\}$$\n\n- **路径回溯：**通过从末尾开始跟踪回溯指针来找到路径的其余部分：\n$$\\hat{q}_t = ptr_{t+1}(\\hat{q}_{t+1}) \\quad \\text{for } t = L-1, \\dots, 1$$\n\n**3. 所需统计数据的计算**\n\n一旦确定了最优路径 $\\hat{q}_{1:L}$，就为每个序列计算以下四个统计数据：\n\n- $N_H$：螺旋片段的数量。通过计算路径 $\\hat{q}_{1:L}$ 中状态 $H$ 的最大连续块的数量来计算。\n- $L_{\\max}$：最长螺旋片段的长度。这是路径 $\\hat{q}_{1:L}$ 中任何状态 $H$ 的连续块的最大长度。如果没有 $H$ 状态存在，则为 $0$。\n- $f_{\\text{charged}\\to H}$：被分配到状态 $H$ 的带电残基（$\\{\\text{D},\\text{E},\\text{K},\\text{R},\\text{H}\\}$）的比例。计算方式如下：\n$$f_{\\text{charged}\\to H} = \\frac{|\\{ i \\mid x_i \\in \\{\\text{D},\\text{E},\\text{K},\\text{R},\\text{H}\\} \\text{ and } \\hat{q}_i=H\\}|}{|\\{ i \\mid x_i \\in \\{\\text{D},\\text{E},\\text{K},\\text{R},\\text{H}\\}\\}|}$$\n如果分母为 $0$，则该比例定义为 $0$。\n- $\\ell$：每个残基的平均对数联合概率，计算方式如下：\n$$\\ell = \\frac{1}{L} \\max_{s \\in S} \\{ V_L(s) \\}$$\n\n通过实现维特比算法和统计计算程序，我们处理 4 个测试序列中的每一个以获得最终结果。\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the HMM Viterbi path and statistics problem.\n    \"\"\"\n    \n    # 1. Model Definition\n    states = ['I', 'H', 'O']\n    state_map = {s: i for i, s in enumerate(states)}\n\n    # Hydropathy scale\n    h_vals = {\n        'A': 1.8, 'R': -4.5, 'N': -3.5, 'D': -3.5, 'C': 2.5,\n        'Q': -3.5, 'E': -3.5, 'G': -0.4, 'H': -3.2, 'I': 4.5,\n        'L': 3.8, 'K': -3.9, 'M': 1.9, 'F': 2.8, 'P': -1.6,\n        'S': -0.8, 'T': -0.7, 'W': -0.9, 'Y': -1.3, 'V': 4.2\n    }\n    amino_acids = sorted(h_vals.keys())\n    aa_map = {aa: i for i, aa in enumerate(amino_acids)}\n\n    lambda_val = 0.5\n    \n    # Emission probabilities\n    Z_H = sum(np.exp(lambda_val * val) for val in h_vals.values())\n    Z_L = sum(np.exp(-lambda_val * val) for val in h_vals.values())\n\n    log_emissions = np.zeros((len(amino_acids), len(states)))\n    for aa, i in aa_map.items():\n        h = h_vals[aa]\n        log_emissions[i, state_map['I']] = -lambda_val * h - np.log(Z_L)\n        log_emissions[i, state_map['H']] =  lambda_val * h - np.log(Z_H)\n        log_emissions[i, state_map['O']] = -lambda_val * h - np.log(Z_L)\n\n    # Transition probabilities\n    # I-I: 0.95, I-H: 0.05\n    # H-H: 0.95, H-O: 0.05\n    # O-O: 0.95, O-I: 0.05\n    log_transitions = np.full((len(states), len(states)), -np.inf)\n    log_transitions[state_map['I'], state_map['I']] = np.log(0.95)\n    log_transitions[state_map['I'], state_map['H']] = np.log(0.05)\n    log_transitions[state_map['H'], state_map['H']] = np.log(0.95)\n    log_transitions[state_map['H'], state_map['O']] = np.log(0.05)\n    log_transitions[state_map['O'], state_map['O']] = np.log(0.95)\n    log_transitions[state_map['O'], state_map['I']] = np.log(0.05)\n\n    # Initial probabilities\n    log_initial = np.array([np.log(1.0), -np.inf, -np.inf])\n\n    # 2. Viterbi Algorithm Implementation\n    def viterbi(sequence):\n        L = len(sequence)\n        num_states = len(states)\n        \n        V = np.full((L, num_states), -np.inf)\n        ptr = np.zeros((L, num_states), dtype=int)\n\n        # Initialization\n        first_aa_idx = aa_map[sequence[0]]\n        V[0, :] = log_initial + log_emissions[first_aa_idx, :]\n\n        # Recurrence\n        for t in range(1, L):\n            aa_idx = aa_map[sequence[t]]\n            for s in range(num_states):\n                prev_V = V[t - 1, :] + log_transitions[:, s]\n                V[t, s] = np.max(prev_V) + log_emissions[aa_idx, s]\n                ptr[t, s] = np.argmax(prev_V)\n        \n        # Termination\n        log_prob = np.max(V[L - 1, :])\n        path = np.zeros(L, dtype=int)\n        path[L - 1] = np.argmax(V[L - 1, :])\n        \n        # Backtracking\n        for t in range(L - 2, -1, -1):\n            path[t] = ptr[t + 1, path[t + 1]]\n            \n        return [states[i] for i in path], log_prob\n\n    # 3. Statistics Calculation\n    def calculate_stats(sequence, path, log_prob):\n        L = len(sequence)\n        \n        # N_H: Number of helix segments\n        N_H = 0\n        in_helix = False\n        for state in path:\n            if state == 'H' and not in_helix:\n                N_H += 1\n                in_helix = True\n            elif state != 'H':\n                in_helix = False\n\n        # L_max: Length of longest helix segment\n        L_max = 0\n        current_len = 0\n        for state in path:\n            if state == 'H':\n                current_len += 1\n            else:\n                L_max = max(L_max, current_len)\n                current_len = 0\n        L_max = max(L_max, current_len)\n\n        # f_charged_to_H: Fraction of charged residues in H state\n        charged_aas = {'D', 'E', 'K', 'R', 'H'}\n        total_charged = 0\n        charged_in_H = 0\n        for i, aa in enumerate(sequence):\n            if aa in charged_aas:\n                total_charged += 1\n                if path[i] == 'H':\n                    charged_in_H += 1\n        \n        f_charged_to_H = 0.0 if total_charged == 0 else charged_in_H / total_charged\n        \n        # l: Average log joint probability per residue\n        l = log_prob / L if L  0 else 0.0\n        \n        return [N_H, L_max, round(f_charged_to_H, 3), round(l, 3)]\n\n    # 4. Test Suite\n    test_cases = [\n        \"MKK\" + \"L\" * 30 + \"A\" * 5 + \"KK\",\n        (\"VT\") * 60,\n        (\"DEKQNST\") * 20,\n        \"N\" * 7 + \"L\" * 12 + \"N\" * 7 + \"L\" * 8 + \"N\" * 7\n    ]\n    \n    all_results = []\n    for seq in test_cases:\n        path, log_p = viterbi(seq)\n        stats = calculate_stats(seq, path, log_p)\n        all_results.append(stats)\n        \n    # Format the final output string\n    case_strings = []\n    for result in all_results:\n        # Format floats to 3 decimal places\n        f_charged_str = f\"{result[2]:.3f}\"\n        l_str = f\"{result[3]:.3f}\"\n        case_strings.append(f\"[{result[0]},{result[1]},{f_charged_str},{l_str}]\")\n    \n    # print(f\"[{','.join(case_strings)}]\") # For local running\n    return f\"[{','.join(case_strings)}]\"\n# final_answer = solve()\n```", "answer": "[[1,30,0.000,-1.066],[30,2,0.000,-1.868],[0,0,0.000,-1.957],[2,12,0.000,-2.259]]", "id": "2415695"}]}