{"hands_on_practices": [{"introduction": "均方根偏差（RMSD）是总结两种结构之间平均差异的强大指标。然而，平均值有时可能会产生误导。本练习是一个思想实验，旨在挑战您探索整体RMSD与单个原子最大可能偏差之间的关系，从而帮助您对RMSD值的真实含义建立更深刻的直觉。[@problem_id:2431541]", "problem": "两种相同蛋白质的构象，每个构象包含 $100$ 个残基，仅使用α-碳（$\\mathrm{C}\\alpha$）原子通过刚体叠合进行最优比对。在 $N=100$ 个匹配的 $\\mathrm{C}\\alpha$ 原子上测得的均方根偏差 (RMSD) 为 $3.0$ Å。根据定义，$N$ 个原子的均方根偏差 (RMSD) 为\n$$\n\\mathrm{RMSD} \\equiv \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\|\\Delta \\mathbf{r}_{i}\\|^{2}},\n$$\n其中 $\\Delta \\mathbf{r}_{i}$ 是最优叠合后原子 $i$ 在两种构象之间的位移矢量，$\\|\\cdot\\|$ 表示欧几里得范数。在不假设除上述定义之外任何额外约束的情况下，确定与给定 RMSD 一致的单个原子 $j$ 的 $\\|\\Delta \\mathbf{r}_{j}\\|$ 的理论最大可能值。给出精确值并以埃 (Å) 为单位表示您的答案。最终答案中不要包含单位。", "solution": "必须首先对问题陈述进行严格验证。\n\n第1步：提取已知条件。\n已知条件如下：\n- 残基数量为 $100$。\n- 用于叠合和 RMSD 计算的原子是α-碳（$\\mathrm{C}\\alpha$）原子。\n- 用于 RMSD 计算的匹配原子数为 $N=100$。\n- 测得的均方根偏差为 $\\mathrm{RMSD} = 3.0$ Å。\n- RMSD 的定义为 $\\mathrm{RMSD} \\equiv \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\|\\Delta \\mathbf{r}_{i}\\|^{2}}$，其中 $\\Delta \\mathbf{r}_{i}$ 是原子 $i$ 的位移矢量。\n- 任务是求单个任意原子 $j$ 的 $\\|\\Delta \\mathbf{r}_{j}\\|$ 的理论最大可能值。\n- 问题陈述我们不得假设除所提供定义之外的任何额外约束。\n\n第2步：使用提取的已知条件进行验证。\n根据验证标准对问题进行评估。\n- **具有科学依据：**该问题基于均方根偏差 (RMSD) 的标准定义，这是结构生物信息学中比较大分子结构的一个基本概念。所提供的值（$N=100$ 个原子，$\\mathrm{RMSD}=3.0$ Å）在物理上是现实的。\n- **适定的：**该问题是一个适定的数学极值问题。它要求在给定整个集合的均方根约束下，求集合中一个分量的最大值。存在唯一解。\n- **客观性：**问题以精确、客观的语言陈述。没有歧义。\n\n该问题不存在任何导致其无效的缺陷。它是科学上合理、可形式化、完整且适定的。“最优叠合”的条件确立了测量 RMSD 的背景，但问题的核心是一个关于 RMSD 度量本身属性的数学问题，正如约束“在不假设除上述定义之外任何额外约束的情况下”所明确指出的。\n\n第3步：结论与行动。\n问题有效。将推导出解决方案。\n\n解答从 RMSD 的定义开始。我们已知：\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} d_{i}^{2}}\n$$\n为简化记法，我们定义 $d_{i} \\equiv \\|\\Delta \\mathbf{r}_{i}\\|$ 为原子 $i$ 位移的标量大小。我们已知 $N=100$ 且 $\\mathrm{RMSD}=3.0$。\n\n将已知值代入定义中：\n$$\n3.0 = \\sqrt{\\frac{1}{100}\\sum_{i=1}^{100} d_{i}^{2}}\n$$\n为分析该和式，我们将方程两边平方：\n$$\n(3.0)^{2} = \\frac{1}{100}\\sum_{i=1}^{100} d_{i}^{2}\n$$\n$$\n9.0 = \\frac{1}{100}\\sum_{i=1}^{100} d_{i}^{2}\n$$\n这对位移平方和提供了一个固定约束：\n$$\n\\sum_{i=1}^{100} d_{i}^{2} = 9.0 \\times 100 = 900\n$$\n该量的单位是 Å$^{2}$。\n\n我们的目标是确定单个位移大小的理论最大可能值，我们将其表示为任意原子 $j$ 的 $d_{j}$。我们可以从和式中分离出 $d_{j}^{2}$ 项：\n$$\n\\sum_{i=1}^{100} d_{i}^{2} = d_{j}^{2} + \\sum_{i \\neq j} d_{i}^{2}\n$$\n将此代回我们的约束方程中：\n$$\nd_{j}^{2} + \\sum_{i \\neq j} d_{i}^{2} = 900\n$$\n为了最大化 $d_{j}$ 的值，并因此最大化 $d_{j}^{2}$（因为 $d_{j}$ 是一个非负的大小），我们必须最小化从常数 $900$ 中减去的项的值。也就是说，我们必须最小化所有其他原子的位移平方和 $\\sum_{i \\neq j} d_{i}^{2}$。\n\n根据定义，矢量的大小 $d_{i} = \\|\\Delta \\mathbf{r}_{i}\\|$ 必须是非负的，$d_{i} \\ge 0$。因此，其大小的平方也必须是非负的，$d_{i}^{2} \\ge 0$。每一项 $d_{i}^{2}$ 的最小可能值为 $0$。这对应于原子 $i$ 的位移为零的物理情境。\n\n当和式中的每一项都取其最小值时，和式 $\\sum_{i \\neq j} d_{i}^{2}$ 达到其最小值。因此，我们对所有 $i \\neq j$ 设定 $d_{i}^{2} = 0$。\n$$\n\\min\\left(\\sum_{i \\neq j} d_{i}^{2}\\right) = \\sum_{i \\neq j} 0 = 0\n$$\n将此最小值代回 $d_{j}^{2}$ 的方程中：\n$$\n(d_{j}^{2})_{\\max} + 0 = 900\n$$\n$$\n(d_{j}^{2})_{\\max} = 900\n$$\n取平方根以求得最大可能位移大小 $(d_{j})_{\\max}$：\n$$\n(d_{j})_{\\max} = \\sqrt{900} = 30\n$$\n这个结果对应于这样一种情景：其中 $N-1=99$ 个原子完全叠合（对于 $i \\neq j$，$d_i=0$），而整个偏差平方和完全由单个原子 $j$ 贡献。在给定的整体 RMSD 下，这是任何单个原子偏差的理论上限。该值为 $30$ Å。", "answer": "$$\n\\boxed{30}\n$$", "id": "2431541"}, {"introduction": "许多蛋白质以对称寡聚体（如均二聚体）的形式发挥功能，其中的亚基是相同的。在比较这类蛋白质的两种结构时，会出现一个模糊性：我们应该将亚基A映射到A、B映射到B，还是将A映射到B、B映射到A？这个动手编程练习将指导您实现一个稳健的比较方法来解决这种对称性问题，这是分析寡聚体蛋白质结构的一项关键技能。[@problem_id:2431556]", "problem": "您将实现一个程序，用于计算两个蛋白质同源二聚体构象在刚体叠合下的最小均方根偏差 (RMSD)。比较时必须考虑到相同亚基的模糊性：对于每次同源二聚体的比较，您必须评估直接对应（亚基$A$映射到亚基$A$，亚基$B$映射到亚基$B$）和交换对应（亚基$A$映射到亚基$B$，亚基$B$映射到亚基$A$）两种情况，并报告这两种可能性中的最小RMSD。\n\n使用以下基本基础和定义。刚体叠合旨在寻找一个行列式为 $\\det(\\mathbf{R}) = +1$ 的 $3 \\times 3$ 旋转矩阵 $\\mathbf{R}$ 和一个平移向量 $\\mathbf{t} \\in \\mathbb{R}^3$，以最小化对应点之间的欧几里得距离的均方值。给定 $N$ 个对应点 $\\{\\mathbf{x}_i\\}_{i=1}^N$（参考）和 $\\{\\mathbf{y}_i\\}_{i=1}^N$（目标），目标是最小化\n$$\n\\frac{1}{N} \\sum_{i=1}^N \\left\\| \\mathbf{x}_i - \\left(\\mathbf{y}_i\\,\\mathbf{R} + \\mathbf{t}\\right) \\right\\|_2^2\n$$\n遍历所有允许的 $\\mathbf{R}$ 和 $\\mathbf{t}$。均方根偏差 (RMSD) 即为该最小均方值的平方根：\n$$\n\\mathrm{RMSD} \\;=\\; \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N \\left\\| \\mathbf{x}_i - \\left(\\mathbf{y}_i\\,\\mathbf{R} + \\mathbf{t}\\right) \\right\\|_2^2 }.\n$$\n您必须使用标准线性代数和 $\\mathbf{R}$ 的正交性（无非刚性形变，无反射），从第一性原理出发确定最优剛体叠合，然后计算RMSD。\n\n对于每个测试用例，每个同源二聚体由两个含有相同数量原子的亚基组成。将参考同源二聚体表示为有序亚基 $\\mathcal{A}_{\\mathrm{ref}} = \\{\\mathbf{a}_k\\}_{k=1}^{n}$ 和 $\\mathcal{B}_{\\mathrm{ref}} = \\{\\mathbf{b}_k\\}_{k=1}^{n}$，目标同源二聚体表示为有序亚基 $\\mathcal{A}_{\\mathrm{tar}} = \\{\\mathbf{a}'_k\\}_{k=1}^{n}$ 和 $\\mathcal{B}_{\\mathrm{tar}} = \\{\\mathbf{b}'_k\\}_{k=1}^{n}$。您必须评估两种对应关系：\n- 直接对应：$\\left(\\mathcal{A}_{\\mathrm{ref}} \\parallel \\mathcal{A}_{\\mathrm{tar}}\\right)$ 与 $\\left(\\mathcal{B}_{\\mathrm{ref}} \\parallel \\mathcal{B}_{\\mathrm{tar}}\\right)$ 串联。\n- 交换对应：$\\left(\\mathcal{A}_{\\mathrm{ref}} \\parallel \\mathcal{B}_{\\mathrm{tar}}\\right)$ 与 $\\left(\\mathcal{B}_{\\mathrm{ref}} \\parallel \\mathcal{A}_{\\mathrm{tar}}\\right)$ 串联。\n对于每种对应关系，对串联后的点集执行一次最优刚体叠合，并计算RMSD。报告两个RMSD中较小的一个。\n\n角度单位：下面给出的所有角度均以弧度为单位。不涉及物理单位。您的程序必须将报告的每个RMSD四舍五入到小数点后恰好$6$位。所有向量均为$3$维行向量。\n\n测试套件。实现以下五个测试用例。所有向量均为$3$维行向量。定义含有 $n = 5$ 个原子的基础亚基 $\\mathcal{A}_{\\mathrm{base}}$ 如下\n- $\\mathbf{p}_1 = (\\,2.0,\\, 0.5,\\, 0.0\\,)$,\n- $\\mathbf{p}_2 = (\\,2.5,\\,-0.5,\\, 0.5\\,)$,\n- $\\mathbf{p}_3 = (\\,1.5,\\, 0.2,\\,-0.3\\,)$,\n- $\\mathbf{p}_4 = (\\,2.2,\\, 1.0,\\, 0.7\\,)$,\n- $\\mathbf{p}_5 = (\\,1.8,\\,-0.8,\\,-0.6\\,)$.\n\n令 $\\mathcal{A}_{\\mathrm{base}} = [\\mathbf{p}_1,\\mathbf{p}_2,\\mathbf{p}_3,\\mathbf{p}_4,\\mathbf{p}_5]$ 并定义绕 $z$ 轴旋转角度 $\\theta$ 的旋转为\n$$\n\\mathbf{R}_z(\\theta) \\;=\\;\n\\begin{bmatrix}\n\\cos\\theta  -\\sin\\theta  0\\\\\n\\sin\\theta  \\cos\\theta  0\\\\\n0  0  1\n\\end{bmatrix}.\n$$\n类似地，定义绕 $x$ 轴旋转角度 $\\phi$ 的旋转为\n$$\n\\mathbf{R}_x(\\phi) \\;=\\;\n\\begin{bmatrix}\n1  0  0\\\\\n0  \\cos\\phi  -\\sin\\phi\\\\\n0  \\sin\\phi  \\cos\\phi\n\\end{bmatrix}.\n$$\n\n按如下方式为每个测试用例构建参考和目标二聚体。\n\n- 测试用例 1（完美的 $C_2$ 对称同源二聚体，目标二聚体与之相同）：\n  - 参考：$\\mathcal{A}_{\\mathrm{ref}} = \\mathcal{A}_{\\mathrm{base}}$，$\\mathcal{B}_{\\mathrm{ref}} = \\mathcal{A}_{\\mathrm{base}}\\,\\mathbf{R}_z(\\pi)$。\n  - 目标：$\\mathcal{A}_{\\mathrm{tar}} = \\mathcal{A}_{\\mathrm{ref}}$，$\\mathcal{B}_{\\mathrm{tar}} = \\mathcal{B}_{\\mathrm{ref}}$。\n\n- 测试用例 2（完美的 $C_2$ 对称同源二聚体，目标二聚体亚基交换，并附加全局刚体运动）：\n  - 参考：与测试用例 1 相同。\n  - 令 $\\mathbf{R}_g = \\mathbf{R}_z(\\pi/4)$ 且 $\\mathbf{t}_g = (\\,1.25,\\,-0.75,\\,0.5\\,)$。\n  - 全局运动前的目标：交换亚基，即 $\\tilde{\\mathcal{A}}_{\\mathrm{tar}} = \\mathcal{B}_{\\mathrm{ref}}$，$\\tilde{\\mathcal{B}}_{\\mathrm{tar}} = \\mathcal{A}_{\\mathrm{ref}}$。\n  - 全局运动后的目标：对于 $\\tilde{\\mathcal{A}}_{\\mathrm{tar}}$ 和 $\\tilde{\\mathcal{B}}_{\\mathrm{tar}}$ 中的每个点 $\\mathbf{q}$，设置 $\\mathbf{q} \\leftarrow \\mathbf{q}\\,\\mathbf{R}_g + \\mathbf{t}_g$，以获得 $\\mathcal{A}_{\\mathrm{tar}}$ 和 $\\mathcal{B}_{\\mathrm{tar}}$。\n\n- 测试用例 3（对称、亚基交换的目标，附加小的确定性扰动）：\n  - 从测试用例 2 的目标 $(\\mathcal{A}_{\\mathrm{tar}}, \\mathcal{B}_{\\mathrm{tar}})$ 开始。\n  - 对每个亚基独立地，对于原子索引 $k \\in \\{0,1,2,3,4\\}$（每个亚基内从零开始计数），添加一个扰动向量\n    $$\n    \\boldsymbol{\\delta}_k \\;=\\; \\varepsilon \\cdot \\big(\\cos k,\\; \\sin k,\\; \\cos(2k)\\big)\n    $$\n    其中 $\\varepsilon = 10^{-2}$。将此扰动应用于 $\\mathcal{A}_{\\mathrm{tar}}$ 和 $\\mathcal{B}_{\\mathrm{tar}}$ 中对应的原子，以获得受扰动后的目标亚基。\n\n- 测试用例 4（非对称同源二聚体；未交换亚基的目标，附加不同的全局刚体运动）：\n  - 参考：$\\mathcal{A}_{\\mathrm{ref}} = \\mathcal{A}_{\\mathrm{base}}$，且 $\\mathcal{B}_{\\mathrm{ref}} = \\mathcal{A}_{\\mathrm{base}}\\,\\mathbf{R}_z(2\\pi/3) + \\mathbf{d}$，其中 $\\mathbf{d} = (\\,0.3,\\,-0.4,\\,0.2\\,)$。\n  - 令 $\\mathbf{R}_g' = \\mathbf{R}_x(\\pi/6)$ 且 $\\mathbf{t}_g' = (\\,-0.5,\\,0.2,\\,-0.1\\,)$。\n  - 目标：将相同的全局运动应用于两个亚基而不进行交换：$\\mathcal{A}_{\\mathrm{tar}} = \\mathcal{A}_{\\mathrm{ref}}\\,\\mathbf{R}_g' + \\mathbf{t}_g'$，$\\mathcal{B}_{\\mathrm{tar}} = \\mathcal{B}_{\\mathrm{ref}}\\,\\mathbf{R}_g' + \\mathbf{t}_g'$。\n\n- 测试用例 5（退化几何构型：共线原子；对称、亚基交换的目标，附加全局旋转）：\n  - 定义含有 $n=4$ 个原子的 $\\mathcal{A}_{\\mathrm{line}}$：\n    - $\\mathbf{u}_1 = (\\,0.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{u}_2 = (\\,1.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{u}_3 = (\\,2.0,\\,0.0,\\,0.0\\,)$,\n    - $\\mathbf{u}_4 = (\\,3.0,\\,0.0,\\,0.0\\,)$.\n  - 参考：$\\mathcal{A}_{\\mathrm{ref}} = \\mathcal{A}_{\\mathrm{line}}$，$\\mathcal{B}_{\\mathrm{ref}} = \\mathcal{A}_{\\mathrm{line}}\\,\\mathbf{R}_z(\\pi)$。\n  - 令 $\\mathbf{R}_g'' = \\mathbf{R}_z(\\pi/2)$ 且 $\\mathbf{t}_g'' = (\\,0.0,\\,0.0,\\,0.0\\,)$。\n  - 目标：交换亚基并应用全局旋转：$\\mathcal{A}_{\\mathrm{tar}} = \\mathcal{B}_{\\mathrm{ref}}\\,\\mathbf{R}_g'' + \\mathbf{t}_g''$，$\\mathcal{B}_{\\mathrm{tar}} = \\mathcal{A}_{\\mathrm{ref}}\\,\\mathbf{R}_g'' + \\mathbf{t}_g''$。\n\n实现要求：\n- 对于每个测试用例，按照描述为直接对应和交换对应构建串联的点集，确定最小化均方距离的最优刚体叠合，为每种对应关系计算RMSD，并保留较小的RMSD。\n- 您的程序必须输出一行，其中包含五个RMSD值，按测试用例 $1$到$5$的顺序，四舍五入到小数点后恰好$6$位，格式为方括号内以逗号分隔的列表（例如，“[0.000000,0.000000,0.012345,0.000000,0.000000]”）。", "solution": "用户提供了一个在计算结构生物学领域中定义明确的问题。任务是计算两个同源二聚体蛋白质构象之间的最小均方根偏差 (RMSD)。问题的核心在于识别和处理亚基对应关系中固有的模糊性。对于同源二聚体，必须同时考虑亚基的直接映射和交换映射，最终答案是两种情况下得到的RMSD值的最小值。\n\n该问题在科学和数学上是合理的，基于线性代数和刚体力学的原理。它要求实现一个算法，以找到两组 $N$ 个点 $\\{\\mathbf{x}_i\\}_{i=1}^N$ 和 $\\{\\mathbf{y}_i\\}_{i=1}^N$ 之间的最优刚体叠合。问题规定点表示为行向量，变换通过后乘（post-multiplication）应用（例如，$\\mathbf{p}' = \\mathbf{p}\\mathbf{R} + \\mathbf{t}$）。目标是找到一个 $3 \\times 3$ 旋转矩阵 $\\mathbf{R}$（满足 $\\det(\\mathbf{R})=+1$）和一个三维平移向量 $\\mathbf{t}$，以最小化均方误差：\n$$\nE(\\mathbf{R}, \\mathbf{t}) = \\frac{1}{N} \\sum_{i=1}^N \\left\\| \\mathbf{x}_i - \\left(\\mathbf{y}_i\\mathbf{R} + \\mathbf{t}\\right) \\right\\|_2^2\n$$\nRMSD是该误差函数最小值的平方根。该解法源于第一性原理，通常称为Kabsch算法。\n\n**第1步：最优平移**\n\n最优平移向量 $\\mathbf{t}^*$ 可以通过最小化 $E$ 相对于 $\\mathbf{t}$ 来找到。这可以通过将梯度 $\\nabla_{\\mathbf{t}} E$ 设为零来实现：\n$$\n\\nabla_{\\mathbf{t}} E = \\frac{1}{N} \\sum_{i=1}^N 2 \\left( (\\mathbf{y}_i\\mathbf{R} + \\mathbf{t}) - \\mathbf{x}_i \\right) = \\mathbf{0}\n$$\n$$\nN\\mathbf{t} + (\\sum_{i=1}^N \\mathbf{y}_i)\\mathbf{R} - \\sum_{i=1}^N \\mathbf{x}_i = \\mathbf{0}\n$$\n定义质心 $\\bar{\\mathbf{x}} = \\frac{1}{N}\\sum \\mathbf{x}_i$ 和 $\\bar{\\mathbf{y}} = \\frac{1}{N}\\sum \\mathbf{y}_i$，我们得到作为旋转函数的最优平移：\n$$\n\\mathbf{t}^* = \\bar{\\mathbf{x}} - \\bar{\\mathbf{y}}\\mathbf{R}\n$$\n此结果表明，最优平移将旋转后的目标点集的质心与参考点集的质心对齐。将 $\\mathbf{t}^*$ 代回误差函数，我们可以从问题中消除平移。现在的优化只针对 $\\mathbf{R}$，并应用于中心化坐标 $\\mathbf{x}'_i = \\mathbf{x}_i - \\bar{\\mathbf{x}}$ 和 $\\mathbf{y}'_i = \\mathbf{y}_i - \\bar{\\mathbf{y}}$：\n$$\n\\min_{\\mathbf{R}} \\sum_{i=1}^N \\left\\| \\mathbf{x}'_i - \\mathbf{y}'_i\\mathbf{R} \\right\\|^2\n$$\n\n**第2步：最优旋转**\n\n展开平方和，我们得到：\n$$\n\\sum_{i=1}^N \\left( \\left\\|\\mathbf{x}'_i\\right\\|^2 - 2(\\mathbf{x}'_i \\cdot \\mathbf{y}'_i\\mathbf{R}) + \\left\\|\\mathbf{y}'_i\\mathbf{R}\\right\\|^2 \\right)\n$$\n由于 $\\mathbf{R}$ 是一个旋转矩阵，它是保长的，所以 $\\|\\mathbf{y}'_i\\mathbf{R}\\| = \\|\\mathbf{y}'_i\\|$。因此，最小化问题等价于最大化项 $\\sum_{i=1}^N (\\mathbf{x}'_i \\cdot \\mathbf{y}'_i\\mathbf{R})$。这可以用迹算子表示：\n$$\n\\max_{\\mathbf{R}} \\text{Tr}\\left( \\mathbf{R}^T \\mathbf{Y}'^T \\mathbf{X}' \\right)\n$$\n其中 $\\mathbf{X}'$ 和 $\\mathbf{Y}'$ 是 $N \\times 3$ 的矩阵，其行分别是中心化向量 $\\mathbf{x}'_i$ 和 $\\mathbf{y}'_i$。令 $3 \\times 3$ 协方差矩阵为 $\\mathbf{H} = \\mathbf{Y}'^T \\mathbf{X}'$。我们需要最大化 $\\text{Tr}(\\mathbf{R}^T\\mathbf{H})$。\n\n我们对协方差矩阵 $\\mathbf{H}$ 进行奇异值分解 (SVD)：\n$$\n\\mathbf{H} = \\mathbf{U}\\mathbf{S}\\mathbf{V}^T\n$$\n其中 $\\mathbf{U}$ 和 $\\mathbf{V}$ 是 $3 \\times 3$ 的正交矩阵，$\\mathbf{S}$ 是一个具有非负奇异值的对角矩阵。迹项变为 $\\text{Tr}(\\mathbf{R}^T\\mathbf{U}\\mathbf{S}\\mathbf{V}^T)$。根据矩阵理论的一个已知结果，当 $\\mathbf{R}^T\\mathbf{U}$ 等于 $\\mathbf{V}$ 时，即 $\\mathbf{R}^T = \\mathbf{V}\\mathbf{U}^T$ 时，该迹达到最大值，从而得出最优旋转矩阵：\n$$\n\\mathbf{R}^* = \\mathbf{U}\\mathbf{V}^T\n$$\n\n**第3步：处理反射**\n\n问题要求纯旋转，即 $\\det(\\mathbf{R}) = +1$。SVD可能产生一个行列式为 $\\det(\\mathbf{R}^*) = -1$ 的矩阵 $\\mathbf{R}^*$，这对应于一个旋转反射。如果两个结构具有相反的手性，就会发生这种情况。如果 $\\det(\\mathbf{U}\\mathbf{V}^T) = -1$，我们必须找到最佳的旋转。这可以通过翻转对应于最小奇异值的分量的符号来实现。标准的SVD库按降序返回奇异值，因此我们按如下方式修改 $\\mathbf{R}^*$ 的计算：\n令 $\\mathbf{D} = \\text{diag}(1, 1, \\det(\\mathbf{U}\\mathbf{V}^T))$。则正常的旋转矩阵为：\n$$\n\\mathbf{R}_{\\text{opt}} = \\mathbf{U}\\mathbf{D}\\mathbf{V}^T\n$$\n这确保了 $\\det(\\mathbf{R}_{\\text{opt}}) = +1$。如果检测到反射，这对应于在矩阵乘法之前翻转 $\\mathbf{U}$ 的最后一列的符号。\n\n**第4步：同源二聚体RMSD算法**\n\n单个测试用例的完整算法如下：\n1.  为参考亚基（$\\mathcal{A}_{\\mathrm{ref}}, \\mathcal{B}_{\\mathrm{ref}}$）和目标亚基（$\\mathcal{A}_{\\mathrm{tar}}, \\mathcal{B}_{\\mathrm{tar}}$）构建坐标矩阵。\n2.  定义参考点集 $\\mathbf{X} = \\text{vstack}(\\mathcal{A}_{\\mathrm{ref}}, \\mathcal{B}_{\\mathrm{ref}})$。\n3.  **直接对应**：\n    -   定义目标点集 $\\mathbf{Y}_{\\text{direct}} = \\text{vstack}(\\mathcal{A}_{\\mathrm{tar}}, \\mathcal{B}_{\\mathrm{tar}})$。\n    -   使用第1-3步中描述的Kabsch算法计算 $\\text{RMSD}_1 = \\text{RMSD}(\\mathbf{X}, \\mathbf{Y}_{\\text{direct}})$。\n4.  **交换对应**：\n    -   定义目标点集 $\\mathbf{Y}_{\\text{swapped}} = \\text{vstack}(\\mathcal{B}_{\\mathrm{tar}}, \\mathcal{A}_{\\mathrm{tar}})$。\n    -   计算 $\\text{RMSD}_2 = \\text{RMSD}(\\mathbf{X}, \\mathbf{Y}_{\\text{swapped}})$。\n5.  该测试用例的最终结果是 $\\min(\\text{RMSD}_1, \\text{RMSD}_2)$。\n\n对问题陈述中定义的五个测试用例中的每一个都实施此过程。按規定生成坐标，并收集和格式化最终的RMSD值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the homodimer RMSD problem for all specified test cases.\n    \"\"\"\n\n    def kabsch_rmsd(X, Y):\n        \"\"\"\n        Calculates the minimal RMSD between two sets of N points (row vectors)\n        using the Kabsch algorithm.\n        X: (N, 3) numpy array for reference coordinates.\n        Y: (N, 3) numpy array for target coordinates to be superimposed.\n        \"\"\"\n        N = X.shape[0]\n\n        # 1. Center the point clouds\n        centroid_X = np.mean(X, axis=0)\n        centroid_Y = np.mean(Y, axis=0)\n        X_c = X - centroid_X\n        Y_c = Y - centroid_Y\n\n        # 2. Compute the covariance matrix H = Y_c.T @ X_c\n        H = Y_c.T @ X_c\n\n        # 3. SVD of H\n        U, _, Vt = np.linalg.svd(H)\n\n        # 4. Calculate rotation matrix R = U @ Vt\n        R = U @ Vt\n\n        # 5. Handle reflections (det(R) = -1)\n        if np.linalg.det(R)  0:\n            # The standard correction is to flip the sign of the component\n            # corresponding to the smallest singular value.\n            # This is equivalent to U_corr = U @ diag(1, 1, -1)\n            # R_corr = U_corr @ Vt\n            U_prime = U.copy()\n            U_prime[:, -1] *= -1\n            R = U_prime @ Vt\n\n        # 6. Calculate optimal translation\n        t = centroid_X - (centroid_Y @ R)\n        \n        # 7. Apply transformation and compute RMSD\n        Y_superimposed = (Y @ R) + t\n        rmsd = np.sqrt(np.sum((X - Y_superimposed)**2) / N)\n\n        return rmsd\n    \n    # Base subunit definition\n    A_base = np.array([\n        [2.0, 0.5, 0.0],\n        [2.5, -0.5, 0.5],\n        [1.5, 0.2, -0.3],\n        [2.2, 1.0, 0.7],\n        [1.8, -0.8, -0.6]\n    ])\n\n    # Rotation matrix definitions (for row vector post-multiplication: p' = p @ R)\n    def get_R_z(theta):\n        c, s = np.cos(theta), np.sin(theta)\n        return np.array([\n            [c, -s, 0],\n            [s,  c, 0],\n            [0,  0, 1]\n        ]).T # Transpose for row vector convention as p' = p R\n\n    def get_R_x(phi):\n        c, s = np.cos(phi), np.sin(phi)\n        return np.array([\n            [1, 0,   0],\n            [0, c, -s],\n            [0, s,  c]\n        ]).T # Transpose for row vector convention\n\n    test_case_params = list(range(1, 6))\n    results = []\n\n    for test_id in test_case_params:\n        if test_id == 1:\n            # Test case 1\n            A_ref = A_base\n            B_ref = A_base @ get_R_z(np.pi)\n            A_tar, B_tar = A_ref, B_ref\n\n        elif test_id == 2:\n            # Test case 2\n            A_ref = A_base\n            B_ref = A_base @ get_R_z(np.pi)\n            \n            R_g = get_R_z(np.pi / 4)\n            t_g = np.array([1.25, -0.75, 0.5])\n\n            A_tar = (B_ref @ R_g) + t_g\n            B_tar = (A_ref @ R_g) + t_g\n\n        elif test_id == 3:\n            # Test case 3\n            A_ref = A_base\n            B_ref = A_base @ get_R_z(np.pi)\n            \n            R_g = get_R_z(np.pi / 4)\n            t_g = np.array([1.25, -0.75, 0.5])\n            A_tar_base = (B_ref @ R_g) + t_g\n            B_tar_base = (A_ref @ R_g) + t_g\n\n            epsilon = 1e-2\n            perturbations = np.array([\n                epsilon * np.array([np.cos(k), np.sin(k), np.cos(2*k)]) \n                for k in range(5)\n            ])\n            A_tar = A_tar_base + perturbations\n            B_tar = B_tar_base + perturbations\n\n        elif test_id == 4:\n            # Test case 4\n            A_ref = A_base\n            B_ref = (A_base @ get_R_z(2 * np.pi / 3)) + np.array([0.3, -0.4, 0.2])\n            \n            R_g_prime = get_R_x(np.pi / 6)\n            t_g_prime = np.array([-0.5, 0.2, -0.1])\n\n            A_tar = (A_ref @ R_g_prime) + t_g_prime\n            B_tar = (B_ref @ R_g_prime) + t_g_prime\n        \n        elif test_id == 5:\n            # Test case 5\n            A_line = np.array([\n                [0.0, 0.0, 0.0],\n                [1.0, 0.0, 0.0],\n                [2.0, 0.0, 0.0],\n                [3.0, 0.0, 0.0]\n            ])\n            A_ref = A_line\n            B_ref = A_line @ get_R_z(np.pi)\n\n            R_g_double_prime = get_R_z(np.pi / 2)\n            t_g_double_prime = np.array([0.0, 0.0, 0.0])\n            \n            A_tar = (B_ref @ R_g_double_prime) + t_g_double_prime\n            B_tar = (A_ref @ R_g_double_prime) + t_g_double_prime\n\n        # Concatenate subunits to form the full dimer structures\n        X = np.vstack((A_ref, B_ref))\n        Y_direct = np.vstack((A_tar, B_tar))\n        Y_swapped = np.vstack((B_tar, A_tar))\n\n        # Calculate RMSD for both correspondences\n        rmsd_direct = kabsch_rmsd(X, Y_direct)\n        rmsd_swapped = kabsch_rmsd(X, Y_swapped)\n\n        # The result for the test case is the minimum of the two\n        min_rmsd = min(rmsd_direct, rmsd_swapped)\n        results.append(min_rmsd)\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"{r:.6f}\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2431556"}, {"introduction": "蛋白质通常由一个稳定的、保守的结构核心和一些更灵活的区域（如环区）组成。比较两种构象时，全局RMSD可能会因为这些柔性部分的移动而变得很高，从而掩盖了核心区域的相似性。这个高级实践介绍了一种强大的算法，用于识别能够以高保真度进行叠合的最大原子子集，使您能够分离并分析结构上的保守核心。[@problem_id:2431533]", "problem": "实现一个程序，对于每一对给定的一一对应的三维点集，找出一个匹配原子索引的子集，使其大小最大化，且存在一种刚体叠合，使得在该子集上的均方根偏差（RMSD）小于或等于一个给定的阈值。刚体叠合定义为一个行列式为 $+1$ 的标准正交矩阵（无反射或缩放）所表示的旋转，随后进行一次平移。两个大小相等的子集 $\\{ \\mathbf{x}_i \\}_{i \\in S}$ 和 $\\{ \\mathbf{y}_i \\}_{i \\in S}$ 在旋转 $\\mathbf{R}$ 和平移 $\\mathbf{t}$ 下的均方根偏差（RMSD）为\n$$\n\\mathrm{RMSD}(\\mathbf{R},\\mathbf{t};S) \\;=\\; \\sqrt{\\frac{1}{|S|} \\sum_{i \\in S} \\left\\| \\mathbf{x}_i\\,\\mathbf{R} + \\mathbf{t} - \\mathbf{y}_i \\right\\|_2^2 } \\,.\n$$\n您的任务是为每个测试用例确定一个索引子集 $S^\\star$，在满足 $\\min_{\\mathbf{R},\\mathbf{t}} \\mathrm{RMSD}(\\mathbf{R},\\mathbf{t};S) \\le \\tau$ 的条件下最大化 $|S|$。其中 $\\tau$ 是给定的阈值，$\\mathbf{R}$ 是一个 $\\det(\\mathbf{R}) = +1$ 的旋转矩阵，$\\mathbf{t}$ 是 $\\mathbb{R}^3$ 中的一个平移向量。在所有具有最大基数的子集中，选择能达到最小可能 RMSD 的那一个；如果仍然存在平局，则选择具有字典序最小的有序索引元组的子集。角度以弧度为单位。坐标以埃（ångström）为单位，RMSD 必须以埃为单位报告，并精确到 $6$ 位小数。阈值约束使用“小于或等于”条件。\n\n所有输入数据均在本问题内部固定；无需外部输入。设基础结构 $A$ 由 $N$ 个原子组成，索引为 $0,1,\\dots,N-1$，笛卡尔坐标为 $\\mathbf{x}_i \\in \\mathbb{R}^3$。相应的结构 $B$ 具有相同索引的坐标 $\\mathbf{y}_i \\in \\mathbb{R}^3$。\n\n用于所有测试用例的基础结构 $A$ 的定义：\n- $N = 8$ 个原子，坐标以埃为单位：\n  - 索引 $0$：$(0.0,\\,0.0,\\,0.0)$\n  - 索引 $1$：$(1.0,\\,0.0,\\,0.0)$\n  - 索引 $2$：$(0.0,\\,1.0,\\,0.0)$\n  - 索引 $3$：$(0.0,\\,0.0,\\,1.0)$\n  - 索引 $4$：$(1.0,\\,1.0,\\,0.0)$\n  - 索引 $5$：$(1.0,\\,0.0,\\,1.0)$\n  - 索引 $6$：$(0.0,\\,1.0,\\,1.0)$\n  - 索引 $7$：$(1.0,\\,1.0,\\,1.0)$\n\n定义以下旋转矩阵（角度以弧度为单位）：\n- $\\theta_z = \\pi/6$，$\\theta_x = \\pi/9$。\n- $\\mathbf{R}_z(\\theta_z) = \\begin{bmatrix}\n\\cos\\theta_z  -\\sin\\theta_z  0\\\\\n\\sin\\theta_z  \\cos\\theta_z  0\\\\\n0  0  1\n\\end{bmatrix}$，\n$\\mathbf{R}_x(\\theta_x) = \\begin{bmatrix}\n1  0  0\\\\\n0  \\cos\\theta_x  -\\sin\\theta_x\\\\\n0  \\sin\\theta_x  \\cos\\theta_x\n\\end{bmatrix}$，\n以及复合旋转 $\\mathbf{R} = \\mathbf{R}_x(\\theta_x)\\,\\mathbf{R}_z(\\theta_z)$。\n定义平移 $\\mathbf{t} = (0.5,\\,-0.3,\\,0.8)$。\n\n按如下方式构建测试套件：\n- 测试用例 1（理想路径）：设 $B^{(1)}$ 是通过对 $A$ 应用刚性变换 $\\mathbf{R}$ 和 $\\mathbf{t}$ 得到的，即对于每个索引 $i$，$\\mathbf{y}^{(1)}_i = \\mathbf{R}\\,\\mathbf{x}_i + \\mathbf{t}$。阈值 $\\tau_1 = 10^{-8}$ 埃。\n- 测试用例 2（存在离群值）：从 $B^{(1)}$ 出发，通过仅对索引为 $1$ 和 $6$ 的原子添加一个位移向量 $\\mathbf{d} = (3.0,\\,-2.0,\\,1.5)$ 埃来定义 $B^{(2)}$：对于 $i \\in \\{1,6\\}$，设置 $\\mathbf{y}^{(2)}_i = \\mathbf{y}^{(1)}_i + \\mathbf{d}$，而对于所有其他索引 $i$，设置 $\\mathbf{y}^{(2)}_i = \\mathbf{y}^{(1)}_i$。阈值 $\\tau_2 = 0.05$ 埃。\n- 测试用例 3（退化的小集合）：定义一个包含两个原子（索引为 $0,1$）的结构 $A^{(3)}$，其坐标分别为 $(0.0,\\,0.0,\\,0.0)$ 和 $(2.0,\\,0.0,\\,0.0)$ 埃。通过应用与上述相同的 $\\mathbf{R}$ 和 $\\mathbf{t}$ 来定义 $B^{(3)}$：对于 $i \\in \\{0,1\\}$，$\\mathbf{y}^{(3)}_i = \\mathbf{R}\\,\\mathbf{x}^{(3)}_i + \\mathbf{t}$。阈值 $\\tau_3 = 10^{-8}$ 埃。\n\n对于每个测试用例，您的程序必须：\n- 确定最大尺寸的子集 $S^\\star$，使得在 $S^\\star$ 上存在一个刚体叠合，其 $\\mathrm{RMSD} \\le \\tau$。\n- 在所有最大尺寸的子集中，选择 RMSD 最小的一个；如果仍有平局，则选择字典序最小的有序索引元组。\n\n最终输出格式：\n- 对于每个测试用例 $j \\in \\{1,2,3\\}$，输出一个数对 $[k_j, r_j]$，其中 $k_j = |S^\\star|$ 是一个整数，$r_j$ 是在 $S^\\star$ 上可实现的最小 RMSD，并四舍五入到恰好 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含按测试用例 $1,2,3$ 顺序排列的结果，格式为方括号括起来的逗号分隔列表。例如：$[[k_1,r_1],[k_2,r_2],[k_3,r_3]]$。", "solution": "所述问题是有效的。这是一个在计算结构生物学领域中定义明确、有科学依据的问题，没有矛盾或歧义。所有必要的数据和约束都已提供，足以得出一个唯一且可验证的解。因此，我们将着手推导并实现一个解决方案。\n\n问题要求我们找到一个原子索引子集 $S^\\star$，使其大小最大化，并且存在一种刚体叠合（旋转 $\\mathbf{R}$ 和平移 $\\mathbf{t}$），能将两个对应的点集 $\\{\\mathbf{x}_i\\}_{i \\in S^\\star}$ 和 $\\{\\mathbf{y}_i\\}_{i \\in S^\\star}$ 进行叠合，使得均方根偏差（RMSD）不大于给定的阈值 $\\tau$。形式上，我们必须找到解决以下优化问题的 $S^\\star$：\n$$ S^\\star = \\arg\\max_{S \\subseteq \\{0, ..., N-1\\}} |S| \\quad \\text{subject to} \\quad \\min_{\\mathbf{R},\\mathbf{t}} \\mathrm{RMSD}(\\mathbf{R},\\mathbf{t};S) \\le \\tau $$\n其中 $\\det(\\mathbf{R})=+1$。指定了平局决胜规则：在最大尺寸的子集中，选择 RMSD 最小的那个，然后选择字典序最小的排序索引元组。\n\n此问题是一个寻找最优子集的组合搜索问题。在一般情况下，这是一个 NP-难问题，等价于在一个图中寻找最大团（maximum clique），其中顶点代表原子，边连接在给定容差内可相互叠合的原子对。然而，对于测试用例中给出的小数量原子（$N=8$ 和 $N=2$），对所有可能的子集进行穷举搜索在计算上是可行的。\n\n因此，我们的策略如下：\n1.  按降序遍历所有可能的子集大小 $k$，从 $N$ 到 $1$。\n2.  对于给定的大小 $k$，生成该大小的所有索引子集。\n3.  对于每个子集，计算相应点集之间的最小可能 RMSD。\n4.  如果计算出的 RMSD 小于或等于阈值 $\\tau$，则该子集是一个有效的候选者。\n5.  由于我们从最大的 $k$ 向下迭代，我们找到任何有效候选者的第一个大小 $k$ 就是最大可能的基数 $|S^\\star|$。然后我们收集该大小 $k$ 的所有有效候选者。\n6.  从这个最大尺寸候选者的集合中，我们选择满足平局决胜标准的那一个：最小 RMSD，然后是字典序最小的索引元组。\n\n该策略的核心部分是为给定的一对点集计算最小 RMSD。这是一个经典问题，可以通过寻找最优刚体变换的 Kabsch 算法解决。\n\n设给定大小为 $k$ 的子集 $S$ 的两组坐标为 $\\{\\mathbf{x}_i\\}_{i \\in S}$ 和 $\\{\\mathbf{y}_i\\}_{i \\in S}$。Kabsch 算法的步骤如下：\n\n首先，RMSD 的最小化可以解耦。最优平移 $\\mathbf{t}$ 取决于最优旋转 $\\mathbf{R}$。通过首先将两个点集中心化到原点来最小化 RMSD 的平方。我们计算质心：\n$$ \\mathbf{c}_x = \\frac{1}{k} \\sum_{i \\in S} \\mathbf{x}_i \\quad \\text{and} \\quad \\mathbf{c}_y = \\frac{1}{k} \\sum_{i \\in S} \\mathbf{y}_i $$\n中心化后的坐标向量为 $\\mathbf{x}'_i = \\mathbf{x}_i - \\mathbf{c}_x$ 和 $\\mathbf{y}'_i = \\mathbf{y}_i - \\mathbf{c}_y$。问题简化为寻找旋转 $\\mathbf{R}$，以最小化平方误差之和 $\\sum_{i \\in S} \\|\\mathbf{R}\\mathbf{x}'_i - \\mathbf{y}'_i\\|^2$。\n\n其次，我们构建 $3 \\times 3$ 协方差矩阵 $H$。在矩阵表示法中，设 $X'$ 和 $Y'$ 是 $k \\times 3$ 的矩阵，其行分别是中心化后的坐标向量 $\\{\\mathbf{x}'_i\\}$ 和 $\\{\\mathbf{y}'_i\\}$。协方差矩阵由下式给出：\n$$ H = (X')^T Y' $$\n\n第三，我们对协方差矩阵 $H$ 进行奇异值分解（SVD）：\n$$ H = U \\Sigma V^T $$\n其中 $U$ 和 $V$ 是 $3 \\times 3$ 的正交矩阵，$\\Sigma$ 是一个非负奇异值的对角矩阵。\n\n第四，最优旋转矩阵由 SVD 的分量确定。最大化重叠（从而最小化 RMSD）的旋转是 $\\mathbf{R} = VU^T$。需要进行一个关键检查，以确保这是一个真旋转（即无反射），如条件 $\\det(\\mathbf{R})=+1$ 所规定。如果 $\\det(VU^T) = -1$，计算出的矩阵表示一个旋转反射。为了获得最接近的真旋转，我们必须对此进行修正。标准修正是，在重新计算 $\\mathbf{R}$ 之前，反转 $V$ 中对应于最小奇异值的列的符号。这确保了 $\\det(\\mathbf{R}) = +1$。设这个修正后的旋转为 $\\mathbf{R}^\\star$。\n\n最后，确定了最优旋转 $\\mathbf{R}^\\star$ 后，最优平移由 $\\mathbf{t}^\\star = \\mathbf{c}_y - \\mathbf{R}^\\star\\mathbf{c}_x$ 给出。然后可以使用其定义直接计算最小 RMSD：\n$$ \\mathrm{RMSD}_{\\min} = \\sqrt{\\frac{1}{k} \\sum_{i \\in S} \\|\\mathbf{R}^\\star\\mathbf{x}_i + \\mathbf{t}^\\star - \\mathbf{y}_i\\|^2} $$\n\n此过程将被实现并应用于所有子集，如总体策略中所述，以找到每个测试用例的解。需要特别注意点数较少（$k3$）的情况。对于 $k=1$ 或 $k=2$，最小 RMSD 总是 $0.0$，因为一个或两个点总是可以完美叠合（假设点间距离保持不变，这在问题设置中是成立的）。通用的 Kabsch 实现对这些情况具有鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the test cases and prints the final result.\n    \"\"\"\n\n    def calculate_rmsd(P, Q):\n        \"\"\"\n        Calculates the minimum RMSD for two sets of points P and Q using the Kabsch algorithm.\n        This implementation finds the rotation R to optimally superimpose P onto Q.\n        i.e., it minimizes || P @ R.T - Q ||^2\n        P and Q are numpy arrays of shape (k, 3), where k is the number of points.\n        The problem statement implies R should be applied to P (x_i), and Q (y_i) is the reference.\n        It uses column vector convention R*x, but the code will use row vectors x*R.\n        This implementation is for row vectors, superimposing P onto Q.\n        \"\"\"\n        k = P.shape[0]\n        if k == 0:\n            return 0.0\n\n        # Center the point sets\n        c_P = np.mean(P, axis=0)\n        c_Q = np.mean(Q, axis=0)\n        P_c = P - c_P\n        Q_c = Q - c_Q\n        \n        # Compute the covariance matrix. H = P_c.T @ Q_c\n        H = P_c.T @ Q_c\n\n        # Perform Singular Value Decomposition\n        try:\n            U, _, Vt = np.linalg.svd(H)\n        except np.linalg.LinAlgError:\n            return np.sqrt(np.mean(np.sum((P - Q)**2, axis=1)))\n\n        V = Vt.T\n\n        # Calculate the optimal rotation matrix\n        # For H = P^T Q, optimal R to minimize ||PR-Q||^2 is R = UV^T\n        # Here we use R = U @ Vt\n        R = U @ Vt\n\n        # Check for and correct reflection (improper rotation)\n        if np.linalg.det(R)  0:\n            # Flip the sign of the last column of U\n            U_prime = U.copy()\n            U_prime[:, -1] *= -1\n            R = U_prime @ Vt\n        \n        # Apply the rotation to the centered P point cloud\n        P_rot = P_c @ R\n\n        # Calculate the RMSD\n        diff = P_rot - Q_c\n        rmsd = np.sqrt(np.sum(diff ** 2) / k)\n\n        return rmsd\n\n    def solve_case(A, B, tau):\n        \"\"\"\n        Finds the largest subset of atoms with RMSD = tau.\n        A is the mobile structure, B is the reference.\n        \"\"\"\n        N = A.shape[0]\n\n        # Iterate from the largest possible subset size down to 1\n        for k in range(N, 0, -1):\n            candidate_subsets = []\n            \n            # Generate all combinations of indices of size k\n            for indices in combinations(range(N), k):\n                P = A[list(indices)]\n                Q = B[list(indices)]\n                \n                # The problem statement has R x + t - y, so A is mobile (P), B is reference (Q)\n                rmsd = calculate_rmsd(P, Q)\n                \n                if rmsd = tau:\n                    candidate_subsets.append({'rmsd': rmsd, 'indices': indices})\n            \n            # If we found any valid subsets of size k, this is the maximal size.\n            if candidate_subsets:\n                # Sort candidates: first by RMSD (ascending), then by lexicographical order of indices\n                candidate_subsets.sort(key=lambda x: (x['rmsd'], x['indices']))\n                \n                best_candidate = candidate_subsets[0]\n                best_k = k\n                best_rmsd = best_candidate['rmsd']\n                \n                # Return the result for this test case\n                return [best_k, best_rmsd]\n\n        # This part should be unreachable as a subset of size 1 always has an RMSD of 0.\n        return [0, 0.0]\n\n    # --- SETUP ---\n    # Define rigid transformation parameters\n    theta_z = math.pi / 6.0\n    theta_x = math.pi / 9.0\n    \n    cos_tz, sin_tz = math.cos(theta_z), math.sin(theta_z)\n    cos_tx, sin_tx = math.cos(theta_x), math.sin(theta_x)\n\n    Rz = np.array([\n        [cos_tz, -sin_tz, 0],\n        [sin_tz,  cos_tz, 0],\n        [0,       0,      1]\n    ])\n    Rx = np.array([\n        [1, 0,       0],\n        [0, cos_tx, -sin_tx],\n        [0, sin_tx,  cos_tx]\n    ])\n    \n    # Composite rotation for column vectors R = Rx @ Rz\n    R_col = Rx @ Rz\n    t_col = np.array([0.5, -0.3, 0.8])\n\n    # Base structure A for test cases 1 and 2 (vertices of a unit cube)\n    A1_A2 = np.array([\n        [0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0],\n        [1.0, 1.0, 0.0], [1.0, 0.0, 1.0], [0.0, 1.0, 1.0], [1.0, 1.0, 1.0]\n    ])\n\n    results = []\n\n    # --- Test Case 1 ---\n    # Structure B is a perfect rigid transformation of A.\n    # Problem statement implies column vector math: y = R*x + t\n    B1 = (R_col @ A1_A2.T).T + t_col\n    tau1 = 1e-8\n    k1, r1 = solve_case(A1_A2, B1, tau1)\n    results.append([k1, round(r1, 6)])\n\n    # --- Test Case 2 ---\n    # Structure B has two outliers.\n    d = np.array([3.0, -2.0, 1.5])\n    B2 = np.copy(B1)\n    B2[1] += d\n    B2[6] += d\n    tau2 = 0.05\n    k2, r2 = solve_case(A1_A2, B2, tau2)\n    results.append([k2, round(r2, 6)])\n\n    # --- Test Case 3 ---\n    # A small, two-atom structure.\n    A3 = np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0]])\n    B3 = (R_col @ A3.T).T + t_col\n    tau3 = 1e-8\n    k3, r3 = solve_case(A3, B3, tau3)\n    results.append([k3, round(r3, 6)])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r).replace(' ', '') for r in results)}]\")\n\nsolve()\n```", "id": "2431533"}]}