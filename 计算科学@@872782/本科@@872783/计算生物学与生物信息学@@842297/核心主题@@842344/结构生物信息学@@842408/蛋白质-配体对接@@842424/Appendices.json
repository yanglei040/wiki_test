{"hands_on_practices": [{"introduction": "打分函数是分子对接的核心，但它们是物理现实的简化模型。这项练习 ([@problem_id:2422880]) 让你扮演批判者的角色，通过设计一个“恶意”配体来利用打分函数的弱点，从而加深你对打分函数局限性的理解。你将构建一个分子，它在简化的经验打分函数下得分很高，但在更真实的物理模型中却是一个不良结合物。", "problem": "给定一个简化但科学上合理的蛋白质-配体对接情景设置，旨在研究针对经验性评分函数的对抗性行为。一个受体由三维空间中用于氢键作用的特征点（单位：埃）描述：受体供体和受体受体。一个配体同样由配体供体和配体受体来描述。当一对特征点中一个是供体，另一个是受体，且两点间的欧几里得距离在指定的截断值范围内时，它们就构成一个氢键接触。经验性评分中不考虑角度依赖性，也没有尺寸惩罚。距离必须以埃为单位处理。能量必须以千卡/摩尔为单位处理。\n\n为任何构建的配体和固定的受体定义以下内容：\n\n- 经验性评分（将被利用）：\n  - 经验性氢键接触数是距离小于或等于截断值 $d_{\\mathrm{hb}}$ 的供体-受体对的总数。\n  - 经验性冲突数是距离任何受体特征点（供体或受体）小于冲突距离 $d_{\\mathrm{clash}}$ 的配体特征点（供体或受体）的总数。\n  - 经验性评分为\n  $$S = w_{\\mathrm{hb}} \\cdot N_{\\mathrm{hb}} - w_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash}}.$$\n\n- 物理上合理的质量代理（用于检测不良结合物）：\n  - 对于受体和配体之间的每一对供体-受体，设距离为 $r$。定义一个软性的距离依赖接触权重\n  $$g(r) = \\exp\\left(-\\frac{(r - r_0)^2}{2\\sigma^2}\\right).$$\n  - 物理能量代理为\n  $$E_{\\mathrm{true}} = - e_{\\mathrm{hb}} \\cdot \\sum_{\\text{所有受体-配体供体-受体对}} g(r) + p_{\\mathrm{polar}} \\cdot n_{\\mathrm{polar}} + p_{\\mathrm{rot}} \\cdot \\max(n_{\\mathrm{atoms}} - 1, 0) + p_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash,true}},$$\n  其中 $n_{\\mathrm{polar}}$ 是配体供体和受体的数量（全部计为极性原子），$n_{\\mathrm{atoms}}$ 是配体供体和受体的总数，而 $N_{\\mathrm{clash,true}}$ 与 $N_{\\mathrm{clash}}$ 相同，但用于物理惩罚项。\n  较低的 $E_{\\mathrm{true}}$ 表示更好的结合物；在这里，“不良结合物”是指 $E_{\\mathrm{true}}$ 超过指定阈值的配体。所有能量必须以千卡/摩尔表示。\n\n任务。对于每个测试用例，您必须构建一个配体，该配体明确利用经验性评分 $S$ 使其尽可能高，即使物理代理 $E_{\\mathrm{true}}$ 很差。您的程序必须为每个测试用例生成一个布尔值，指示您是否成功生成了一个“恶意”配体。恶意配体的定义是同时满足\n- $S \\ge S_{\\mathrm{target}}$ 和\n- $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$\n的配体，其中 $S_{\\mathrm{target}}$ 和 $E_{\\mathrm{bad}}$ 在下文的每个测试用例中指定。\n\n使用的基本原理：\n- 用于对接的经验性评分通常计算截断距离内的接触数量，而不考虑角度项。这是带有硬性距离截断值 $d_{\\mathrm{hb}}$ 的 $N_{\\mathrm{hb}}$ 的基础。\n- 氢键的真实物理有利性在优选距离 $r_0$ 附近是距离敏感的，并且会受到与极性基团数量和柔性自由度成比例的去溶剂化和构象熵成本的惩罚。这是高斯函数 $g(r)$、每个极性基团的惩罚 $p_{\\mathrm{polar}}$ 和每个可旋转键的代理 $p_{\\mathrm{rot}}$ 的基础。\n\n几何与单位：\n- 所有坐标均以埃为单位给出；您构建的配体坐标也必须以埃为单位。\n- 所有能量必须以千卡/摩尔为单位计算。\n- 此问题不使用角度。\n\n对于所有测试用例，使用标准欧几里得度量计算距离，“在截断值内”定义为小于或等于截断值。\n\n测试套件。对于每个测试用例，都指定了受体特征、参数和阈值。受体供体和受体以 $[x,y,z]$ 坐标（埃）列表的形式给出。在这个简化的设置中没有受体疏水基团。\n\n- 测试用例 1（对抗性成功的理想路径）：\n  - 受体受体：\n    - $[0.0, 0.0, 0.0]$, $[4.0, 0.0, 0.0]$, $[0.0, 4.0, 0.0]$, $[0.0, 0.0, 4.0]$, $[3.0, 3.0, 0.0]$。\n  - 受体供体：无。\n  - 经验性评分参数：$d_{\\mathrm{hb}} = 3.5$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$。\n  - 物理代理参数：$r_0 = 2.8$, $\\sigma = 0.30$, $e_{\\mathrm{hb}} = 3.0$, $p_{\\mathrm{polar}} = 2.5$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$。\n  - 阈值：$S_{\\mathrm{target}} = 5$, $E_{\\mathrm{bad}} = 5.0$。\n\n- 测试用例 2（利用行为应无法满足‘不良结合物’标准的边界情况）：\n  - 受体受体：\n    - $[0.0, 0.0, 0.0]$, $[5.0, 0.0, 0.0]$。\n  - 受体供体：\n    - $[0.0, 5.0, 0.0]$。\n  - 经验性评分参数：$d_{\\mathrm{hb}} = 2.8$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$。\n  - 物理代理参数：$r_0 = 2.8$, $\\sigma = 0.30$, $e_{\\mathrm{hb}} = 3.0$, $p_{\\mathrm{polar}} = 2.5$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$。\n  - 阈值：$S_{\\mathrm{target}} = 3$, $E_{\\mathrm{bad}} = 2.0$。\n\n- 测试用例 3（混合特征，更大截断值，明显的对抗性成功）：\n  - 受体受体：\n    - $[0.0, 0.0, 0.0]$, $[2.0, 0.0, 0.0]$, $[0.0, 2.0, 0.0]$。\n  - 受体供体：\n    - $[1.0, 1.0, 0.0]$, $[1.0, -1.0, 0.0]$, $[3.0, 1.0, 0.0]$。\n  - 经验性评分参数：$d_{\\mathrm{hb}} = 3.8$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$。\n  - 物理代理参数：$r_0 = 2.8$, $\\sigma = 0.35$, $e_{\\mathrm{hb}} = 2.8$, $p_{\\mathrm{polar}} = 2.0$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$。\n  - 阈值：$S_{\\mathrm{target}} = 6$, $E_{\\mathrm{bad}} = 8.0$。\n\n您的程序必须为每个测试用例构建一个配体（供体和受体坐标集），旨在通过将互补的配体特征放置在尽可能多的受体特征的氢键截断距离内来最大化经验性评分 $S$，同时在可行的情况下避免经验性冲突，对配体原子数量没有其他限制。然后按上文定义计算 $S$ 和 $E_{\\mathrm{true}}$，并返回是否满足恶意成功的标准。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表（例如，'[$\\mathrm{True},\\mathrm{False},\\mathrm{True}$]'）。这三个布尔值必须按顺序分别对应于测试用例 1、测试用例 2 和测试用例 3。不得打印任何其他文本。", "solution": "用户提出了一个计算生物学问题，涉及构建对抗性配体，旨在最大化简化的经验性对接评分 $S$，同时使其具有较差的、基于物理动机的结合特性，该特性通过代理能量 $E_{\\mathrm{true}}$ 来衡量。如果配体对于给定的阈值同时满足 $S \\ge S_{\\mathrm{target}}$ 和 $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$，则被视为‘恶意的’。\n\n首先对问题的科学合理性和逻辑一致性进行验证。\n\n**步骤 1：提取已知条件**\n- **受体/配体特征**：由氢键供体和受体的空间坐标定义。\n- **经验性评分, $S$**：$S = w_{\\mathrm{hb}} \\cdot N_{\\mathrm{hb}} - w_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash}}$。\n  - $N_{\\mathrm{hb}}$：距离 $r \\le d_{\\mathrm{hb}}$ 的供体-受体对的数量。\n  - $N_{\\mathrm{clash}}$：距离任何受体特征点小于 $d_{\\mathrm{clash}}$ 的配体特征点的数量。\n- **物理能量代理, $E_{\\mathrm{true}}$**：$E_{\\mathrm{true}} = - e_{\\mathrm{hb}} \\cdot \\sum g(r) + p_{\\mathrm{polar}} \\cdot n_{\\mathrm{polar}} + p_{\\mathrm{rot}} \\cdot \\max(n_{\\mathrm{atoms}} - 1, 0) + p_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash,true}}$。\n  - $g(r) = \\exp\\left(-\\frac{(r - r_0)^2}{2\\sigma^2}\\right)$ 是供体-受体对的软接触权重。\n  - $n_{\\mathrm{polar}}$：配体极性原子（供体/受体）的数量。\n  - $n_{\\mathrm{atoms}}$：配体特征点的总数。\n  - $N_{\\mathrm{clash,true}}$：与 $N_{\\mathrm{clash}}$ 相同。\n- **任务**：对于每个测试用例，构建一个配体以最大化 $S$，然后确定它是否满足‘恶意’标准：$S \\ge S_{\\mathrm{target}}$ 和 $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$。\n- **测试用例**：提供了三个不同的测试用例，每个都有特定的受体几何形状、评分参数和阈值。\n\n**步骤 2：问题陈述验证**\n该问题具有科学依据，模拟了简单对接评分函数中的一个已知漏洞，即相互作用是通过硬性距离截断来建模的。物理代理能量 $E_{\\mathrm{true}}$ 正确地引入了诸如最佳相互作用距离 ($r_0$)、去溶剂化惩罚（与 $p_{\\mathrm{polar}}$ 相关）和构象熵成本（与 $p_{\\mathrm{rot}}$ 相关）等概念。该问题是适定的，提供了所有必要的定义、常数和数据。各项都有数学定义且是客观的。不存在矛盾或逻辑缺陷。\n\n**结论**：该问题有效且可以解决。\n\n**步骤 3：解决方案设计**\n目标是构建一个具有对抗性的配体。这意味着需要一个策略来最大化经验性评分 $S$，同时使物理能量代理 $E_{\\mathrm{true}}$ 尽可能差（高）。\n\n**评分分析：**\n- 为了最大化 $S = w_{\\mathrm{hb}} N_{\\mathrm{hb}} - w_{\\mathrm{clash}} N_{\\mathrm{clash}}$，我们必须最大化 $N_{\\mathrm{hb}}$ 并最小化 $N_{\\mathrm{clash}}$。$N_{\\mathrm{hb}}$ 的最大可能值对应于与受体上的每个特征点形成一个氢键。一个旨在实现此目的的简单配体构建方法是为每个受体原子放置一个互补的配体原子。为避免惩罚项，每个配体原子必须放置在距离所有受体原子 $r \\ge d_{\\mathrm{clash}}$ 的位置。\n- 为了最大化 $E_{\\mathrm{true}}$，我们必须使有利的能量项 $- e_{\\mathrm{hb}} \\sum g(r)$ 尽可能小（接近于零）。函数 $g(r)$ 是一个在 $r=r_0$ 处达到峰值的高斯函数，因此要使其值最小化，相互作用距离 $r$ 应尽可能远离 $r_0$。涉及 $p_{\\mathrm{polar}}$、$p_{\\mathrm{rot}}$ 和 $p_{\\mathrm{clash}}$ 的惩罚项应被最大化。\n\n**对抗性构建策略：**\n一个合理的对抗性策略结合了这些目标：\n1.  **配体组成**：对于受体上的 $N$ 个特征点（供体和受体）中的每一个，我们构建一个带有一个互补特征点的配体。这将 $n_{\\mathrm{atoms}} = n_{\\mathrm{polar}} = N$。这最大化了 $N_{\\mathrm{hb}}$ 的潜力。\n2.  **配体原子放置**：为了同时满足高 $S$ 和高 $E_{\\mathrm{true}}$ 的条件，我们应将每个配体原子放置在其目标受体原子的一定距离 $r$ 处，使得：\n    a. $d_{\\mathrm{clash}} \\le r \\le d_{\\mathrm{hb}}$（以便计入 $N_{\\mathrm{hb}}$ 并避免 $S$ 的经验性冲突）。\n    b. $|r - r_0|$ 最大化（以最小化对 $E_{\\mathrm{true}}$ 的有利贡献）。这意味着在允许区间的边界之一选择 $r$，即 $r = d_{\\mathrm{clash}}$ 或 $r = d_{\\mathrm{hb}}$。对于所有提供的测试用例，都有 $|d_{\\mathrm{clash}} - r_0| > |d_{\\mathrm{hb}} - r_0|$，这使得 $r = d_{\\mathrm{clash}}$ 成为对抗性放置的最佳选择。\n    c. 放置的配体原子不得与任何其他受体原子发生冲突。如果受体原子紧密堆积，沿固定轴（例如 x 轴）的简单位移可能会导致意外冲突。一种更稳健的方法是测试几个正交位移向量，并选择第一个不会与任何受体原子发生冲突的向量。\n\n**算法实现：**\n对于每个测试用例：\n1.  构建配体。对于每个受体特征点 $\\vec{p}_i$，为其互补的配体原子找到一个有效位置。如果位置 $\\vec{p}'_i = \\vec{p}_i + \\vec{\\delta}$ 到任何受体原子 $\\vec{p}_j$ 的距离大于或等于 $d_{\\mathrm{clash}}$，则该位置是有效的。我们测试一系列大小为 $d_{\\mathrm{clash}}$ 的正交位移向量 $\\vec{\\delta}$（例如 $(d_{\\mathrm{clash}}, 0, 0), (0, d_{\\mathrm{clash}}, 0), \\dots, (0, 0, -d_{\\mathrm{clash}})$），并使用第一个产生有效、无冲突位置的向量。\n2.  计算所构建配体的评分。\n    a. 根据上述策略确定所有配体供体和受体的坐标。\n    b. 通过计算所有距离 $\\le d_{\\mathrm{hb}}$ 的（受体供体，配体受体）和（受体受体，配体供体）对的数量来计算 $N_{\\mathrm{hb}}$。\n    c. 对同一组对计算 $\\sum g(r)$。\n    d. 通过检查每个配体原子与任何受体原子的最小距离是否小于 $d_{\\mathrm{clash}}$ 来计算 $N_{\\mathrm{clash}}$。\n    e. 将这些值代入 $S$ 和 $E_{\\mathrm{true}}$ 的方程。\n3.  评估恶意标准：检查是否 $S \\ge S_{\\mathrm{target}}$ 和 $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$。记录布尔结果。\n4.  最终输出是所有测试用例的这些布尔结果的列表。这个系统化的过程确保了根据问题的定义，以一致且合乎逻辑的方法来构建对抗性配体并评估其属性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adversarial ligand construction problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            \"rec_acceptors\": np.array([\n                [0.0, 0.0, 0.0], [4.0, 0.0, 0.0], [0.0, 4.0, 0.0],\n                [0.0, 0.0, 4.0], [3.0, 3.0, 0.0]\n            ]),\n            \"rec_donors\": np.empty((0, 3)),\n            \"params\": {\n                \"d_hb\": 3.5, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.30, \"e_hb\": 3.0, \"p_polar\": 2.5,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 5, \"E_bad\": 5.0}\n        },\n        # Test case 2\n        {\n            \"rec_acceptors\": np.array([[0.0, 0.0, 0.0], [5.0, 0.0, 0.0]]),\n            \"rec_donors\": np.array([[0.0, 5.0, 0.0]]),\n            \"params\": {\n                \"d_hb\": 2.8, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.30, \"e_hb\": 3.0, \"p_polar\": 2.5,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 3, \"E_bad\": 2.0}\n        },\n        # Test case 3\n        {\n            \"rec_acceptors\": np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 2.0, 0.0]]),\n            \"rec_donors\": np.array([[1.0, 1.0, 0.0], [1.0, -1.0, 0.0], [3.0, 1.0, 0.0]]),\n            \"params\": {\n                \"d_hb\": 3.8, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.35, \"e_hb\": 2.8, \"p_polar\": 2.0,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 6, \"E_bad\": 8.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ligand_donors, ligand_acceptors = construct_adversarial_ligand(case)\n        S, E_true = calculate_scores(\n            ligand_donors, ligand_acceptors,\n            case[\"rec_donors\"], case[\"rec_acceptors\"],\n            case[\"params\"]\n        )\n        \n        is_malicious = (S >= case[\"thresholds\"][\"S_target\"] and \n                        E_true >= case[\"thresholds\"][\"E_bad\"])\n        results.append(str(is_malicious))\n\n    print(f\"[{','.join(results)}]\")\n\ndef construct_adversarial_ligand(case_data):\n    \"\"\"\n    Constructs a ligand by placing complementary atoms near receptor features.\n    The placement strategy is adversarial: place at a distance d_clash\n    from the target atom in a direction that does not clash with other receptor atoms.\n    \"\"\"\n    params = case_data[\"params\"]\n    d_clash = params[\"d_clash\"]\n    \n    rec_acceptors = case_data[\"rec_acceptors\"]\n    rec_donors = case_data[\"rec_donors\"]\n    \n    all_rec_pts = []\n    if rec_acceptors.shape[0] > 0:\n        all_rec_pts.append(rec_acceptors)\n    if rec_donors.shape[0] > 0:\n        all_rec_pts.append(rec_donors)\n    \n    if not all_rec_pts:\n        return np.empty((0,3)), np.empty((0,3))\n\n    all_rec_pts = np.vstack(all_rec_pts)\n\n    deltas = np.array([\n        [d_clash, 0, 0], [0, d_clash, 0], [0, 0, d_clash],\n        [-d_clash, 0, 0], [0, -d_clash, 0], [0, 0, -d_clash]\n    ])\n\n    def find_non_clashing_pos(target_rec_pt, all_rec_pts, deltas):\n        for delta in deltas:\n            candidate_pos = target_rec_pt + delta\n            is_clashing = False\n            # Check candidate against all receptor points\n            distances = np.linalg.norm(all_rec_pts - candidate_pos, axis=1)\n            if np.any(distances  d_clash):\n                is_clashing = True\n            \n            if not is_clashing:\n                return candidate_pos\n        # Fallback if no non-clashing position is found (unlikely for these test cases)\n        return target_rec_pt + deltas[0]\n\n    ligand_donors = []\n    for rec_acc in rec_acceptors:\n        pos = find_non_clashing_pos(rec_acc, all_rec_pts, deltas)\n        ligand_donors.append(pos)\n\n    ligand_acceptors = []\n    for rec_don in rec_donors:\n        pos = find_non_clashing_pos(rec_don, all_rec_pts, deltas)\n        ligand_acceptors.append(pos)\n        \n    return np.array(ligand_donors), np.array(ligand_acceptors)\n\n\ndef calculate_scores(lig_donors, lig_acceptors, rec_donors, rec_acceptors, params):\n    \"\"\"\n    Calculates the empirical score (S) and physical energy proxy (E_true).\n    \"\"\"\n    # Unpack parameters\n    d_hb = params[\"d_hb\"]\n    d_clash = params[\"d_clash\"]\n    w_hb = params[\"w_hb\"]\n    w_clash = params[\"w_clash\"]\n    r0 = params[\"r0\"]\n    sigma = params[\"sigma\"]\n    e_hb = params[\"e_hb\"]\n    p_polar = params[\"p_polar\"]\n    p_rot = params[\"p_rot\"]\n    p_clash = params[\"p_clash\"]\n    \n    # Ligand properties\n    n_atoms = len(lig_donors) + len(lig_acceptors)\n    n_polar = n_atoms\n    \n    # Calculate N_hb and sum of g(r)\n    N_hb = 0\n    sum_g_r = 0.0\n\n    def g(r, r0, sigma):\n        return np.exp(-((r - r0)**2) / (2 * sigma**2))\n\n    # Receptor Acceptors vs Ligand Donors\n    if rec_acceptors.shape[0] > 0 and lig_donors.shape[0] > 0:\n        for lig_d in lig_donors:\n            for rec_a in rec_acceptors:\n                dist = np.linalg.norm(lig_d - rec_a)\n                if dist = d_hb:\n                    N_hb += 1\n                sum_g_r += g(dist, r0, sigma)\n\n    # Receptor Donors vs Ligand Acceptors\n    if rec_donors.shape[0] > 0 and lig_acceptors.shape[0] > 0:\n        for lig_a in lig_acceptors:\n            for rec_d in rec_donors:\n                dist = np.linalg.norm(lig_a - rec_d)\n                if dist = d_hb:\n                    N_hb += 1\n                sum_g_r += g(dist, r0, sigma)\n                \n    # Calculate N_clash\n    N_clash = 0\n    \n    all_rec_pts = []\n    if rec_acceptors.shape[0] > 0: all_rec_pts.append(rec_acceptors)\n    if rec_donors.shape[0] > 0: all_rec_pts.append(rec_donors)\n    all_rec_pts = np.vstack(all_rec_pts) if all_rec_pts else np.empty((0,3))\n\n    all_lig_pts = []\n    if lig_donors.shape[0] > 0: all_lig_pts.append(lig_donors)\n    if lig_acceptors.shape[0] > 0: all_lig_pts.append(lig_acceptors)\n    all_lig_pts = np.vstack(all_lig_pts) if all_lig_pts else np.empty((0,3))\n\n    if all_rec_pts.shape[0] > 0:\n        for lig_pt in all_lig_pts:\n            min_dist = np.min(np.linalg.norm(all_rec_pts - lig_pt, axis=1))\n            if min_dist  d_clash:\n                N_clash += 1\n\n    # Final score calculations\n    S = w_hb * N_hb - w_clash * N_clash\n    \n    E_true = -e_hb * sum_g_r \\\n             + p_polar * n_polar \\\n             + p_rot * max(n_atoms - 1, 0) \\\n             + p_clash * N_clash\n             \n    return S, E_true\n\nsolve()\n```", "id": "2422880"}, {"introduction": "除了结合亲和力打分，预测结合构象的几何准确性也至关重要。本练习 ([@problem_id:2422916]) 聚焦于评估构象准确性的关键指标：均方根偏差 (RMSD)。你将通过对两个分子结构进行最佳几何叠合，一步步计算出药效团 RMSD，从而掌握这一基本评估方法的具体操作。", "problem": "一个配体呈现出三个药效团特征：一个氢键（H-bond）供体，一个氢键（H-bond）受体，以及一个芳香环中心。给定它们在晶体学参考构象和对接构象下的三维（3D）笛卡尔坐标，单位为埃（Å）。基于药效团的均方根偏差（RMSD）定义为：在应用了最小化所选特征上RMSD的最优刚体叠合（一次旋转和一次平移）之后，仅对这些药效团特征位置计算的RMSD。\n\n晶体构象特征坐标（Å）：\n- 供体：$\\left(1,\\,0,\\,0\\right)$\n- 受体：$\\left(0,\\,1,\\,0\\right)$\n- 芳香环中心：$\\left(-1,\\,-1,\\,0\\right)$\n\n对接构象特征坐标（Å）：\n- 供体：$\\left(0,\\,1,\\,0\\right)$\n- 受体：$\\left(-1,\\,0,\\,0\\right)$\n- 芳香环中心：$\\left(1.1,\\,-1,\\,0\\right)$\n\n假设对应关系为：供体 $\\leftrightarrow$ 供体，受体 $\\leftrightarrow$ 受体，芳香环中心 $\\leftrightarrow$ 芳香环中心。使用RMSD的标准定义，\n$$\\mathrm{RMSD} \\;=\\; \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left\\|\\mathbf{r}_{i}-\\mathbf{s}_{i}\\right\\|^{2}},$$\n其中 $N$ 是匹配特征的数量，$\\mathbf{r}_{i},\\mathbf{s}_{i}$ 是相应特征经过最优叠合后的坐标，计算对接构象和晶体构象之间的基于药效团的RMSD。对这三个特征执行最小化RMSD的最优刚体叠合。\n\n将您的最终答案表示为一个以埃为单位的精确解析表达式。不要四舍五入。最终报告的值必须是单个精确表达式。", "solution": "该问题要求计算配体的晶体构象和对接构象之间基于药效团的均方根偏差（RMSD）。RMSD需要在对三个指定的特征点进行最优刚体叠合后计算。\n\n设晶体构象的坐标集为 $P = \\{\\mathbf{p}_1, \\mathbf{p}_2, \\mathbf{p}_3\\}$，对接构象的坐标集为 $Q = \\{\\mathbf{q}_1, \\mathbf{q}_2, \\mathbf{q}_3\\}$。对应关系如下：\n$\\mathbf{p}_1 = (1, 0, 0)$ (供体) $\\leftrightarrow$ $\\mathbf{q}_1 = (0, 1, 0)$ (供体)\n$\\mathbf{p}_2 = (0, 1, 0)$ (受体) $\\leftrightarrow$ $\\mathbf{q}_2 = (-1, 0, 0)$ (受体)\n$\\mathbf{p}_3 = (-1, -1, 0)$ (芳香环) $\\leftrightarrow$ $\\mathbf{q}_3 = (1.1, -1, 0)$ (芳香环)\n\n特征点的数量为 $N=3$。RMSD由下式给出：\n$$ \\mathrm{RMSD} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\|\\mathbf{r}_i - \\mathbf{s}_i\\|^2} $$\n其中 $\\mathbf{r}_i$ 和 $\\mathbf{s}_i$ 是最优叠合后相应特征的坐标。这通过找到旋转矩阵 $R$ 和平移向量 $\\mathbf{t}$ 来实现，以最小化平方距离之和 $D^2 = \\sum_{i=1}^{N} \\| R\\mathbf{q}_i + \\mathbf{t} - \\mathbf{p}_i \\|^2$。\n\n标准步骤（Kabsch算法）包括以下几个步骤：\n1.  **将两个点集平移到它们的质心。**\n    晶体构象特征的质心 $\\mathbf{p}_c$ 为：\n    $$ \\mathbf{p}_c = \\frac{1}{3}(\\mathbf{p}_1 + \\mathbf{p}_2 + \\mathbf{p}_3) = \\frac{1}{3}\\left((1,0,0) + (0,1,0) + (-1,-1,0)\\right) = \\frac{1}{3}(0,0,0) = (0,0,0) $$\n    对接构象特征的质心 $\\mathbf{q}_c$ 为：\n    $$ \\mathbf{q}_c = \\frac{1}{3}(\\mathbf{q}_1 + \\mathbf{q}_2 + \\mathbf{q}_3) = \\frac{1}{3}\\left((0,1,0) + (-1,0,0) + (1.1, -1, 0)\\right) = \\frac{1}{3}(0.1, 0, 0) = \\left(\\frac{1}{30}, 0, 0\\right) $$\n    最优平移向量 $\\mathbf{t}$ 叠合了质心：$\\mathbf{t} = \\mathbf{p}_c - R\\mathbf{q}_c$。问题随后简化为为中心化坐标寻找最优旋转 $R$。\n    中心化坐标为 $\\mathbf{x}_i = \\mathbf{p}_i - \\mathbf{p}_c$ 和 $\\mathbf{y}_i = \\mathbf{q}_i - \\mathbf{q}_c$。\n    由于 $\\mathbf{p}_c = (0,0,0)$，我们有 $\\mathbf{x}_i = \\mathbf{p}_i$：\n    $$ \\mathbf{x}_1 = (1, 0, 0), \\quad \\mathbf{x}_2 = (0, 1, 0), \\quad \\mathbf{x}_3 = (-1, -1, 0) $$\n    对接构象的中心化坐标为：\n    $$ \\mathbf{y}_1 = (0, 1, 0) - \\left(\\frac{1}{30}, 0, 0\\right) = \\left(-\\frac{1}{30}, 1, 0\\right) $$\n    $$ \\mathbf{y}_2 = (-1, 0, 0) - \\left(\\frac{1}{30}, 0, 0\\right) = \\left(-\\frac{31}{30}, 0, 0\\right) $$\n    $$ \\mathbf{y}_3 = (1.1, -1, 0) - \\left(\\frac{1}{30}, 0, 0\\right) = \\left(\\frac{11}{10} - \\frac{1}{30}, -1, 0\\right) = \\left(\\frac{32}{30}, -1, 0\\right) $$\n\n2.  **计算最小平方误差和。**\n    平方误差和的最小值 $D^2_{\\min}$ 由下式给出：\n    $$ D^2_{\\min} = \\sum_{i=1}^{N} \\|\\mathbf{x}_i\\|^2 + \\sum_{i=1}^{N} \\|\\mathbf{y}_i\\|^2 - 2 \\sum_{k=1}^{3} \\sigma'_k $$\n    其中 $\\sigma'_k$ 是协方差矩阵 $C = \\sum_{i=1}^{N} \\mathbf{x}_i \\mathbf{y}_i^T$ 的奇异值，如果最优变换是反射，则最小奇异值的符号需要翻转。\n\n    首先，我们计算中心化向量的范数平方和：\n    $$ \\sum_{i=1}^{3} \\|\\mathbf{x}_i\\|^2 = (1^2+0^2+0^2) + (0^2+1^2+0^2) + ((-1)^2+(-1)^2+0^2) = 1 + 1 + 2 = 4 $$\n    $$ \\sum_{i=1}^{3} \\|\\mathbf{y}_i\\|^2 = \\left(\\left(-\\frac{1}{30}\\right)^2 + 1^2\\right) + \\left(\\left(-\\frac{31}{30}\\right)^2\\right) + \\left(\\left(\\frac{32}{30}\\right)^2 + (-1)^2\\right) $$\n    $$ = \\frac{1}{900} + 1 + \\frac{961}{900} + \\frac{1024}{900} + 1 = 2 + \\frac{1+961+1024}{900} = 2 + \\frac{1986}{900} = 2 + \\frac{331}{150} = \\frac{631}{150} $$\n\n3.  **构建协方差矩阵并求其奇异值之和。**\n    所有给定的坐标都位于 $z=0$ 平面上，使之成为一个二维问题。我们使用 $\\mathbf{x}_i$ 和 $\\mathbf{y}_i$ 的 $x$ 和 $y$ 分量构建 $2 \\times 2$ 协方差矩阵 $C'$：\n    $$ C' = \\sum_{i=1}^{3} \\begin{pmatrix} x_{i,1} \\\\ x_{i,2} \\end{pmatrix} \\begin{pmatrix} y_{i,1}  y_{i,2} \\end{pmatrix} $$\n    $$ C'_{jk} = \\sum_{i=1}^3 x_{i,j} y_{i,k} $$\n    $$ C'_{11} = (1)\\!\\left(-\\frac{1}{30}\\right) + (0)\\!\\left(-\\frac{31}{30}\\right) + (-1)\\!\\left(\\frac{32}{30}\\right) = -\\frac{1}{30}-\\frac{32}{30} = -\\frac{33}{30} = -\\frac{11}{10} $$\n    $$ C'_{12} = (1)(1) + (0)(0) + (-1)(-1) = 1+1=2 $$\n    $$ C'_{21} = (0)\\!\\left(-\\frac{1}{30}\\right) + (1)\\!\\left(-\\frac{31}{30}\\right) + (-1)\\!\\left(\\frac{32}{30}\\right) = -\\frac{31}{30}-\\frac{32}{30} = -\\frac{63}{30} = -\\frac{21}{10} $$\n    $$ C'_{22} = (0)(1) + (1)(0) + (-1)(-1) = 1 $$\n    所以，二维协方差矩阵为：\n    $$ C' = \\begin{pmatrix} -11/10  2 \\\\ -21/10  1 \\end{pmatrix} $$\n    带符号奇异值之和 $\\sum \\sigma'_k$ 对应于 $\\mathrm{tr}(RC')$ 的最大值，其中 $R$ 是一个旋转矩阵。对于一个二维旋转 $R(\\theta) = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}$，迹为：\n    $$ \\mathrm{tr}(R(\\theta)C') = (C'_{11}+C'_{22})\\cos\\theta + (C'_{21}-C'_{12})\\sin\\theta $$\n    设 $A = C'_{11}+C'_{22} = -11/10 + 1 = -1/10$ 且 $B = C'_{21}-C'_{12} = -21/10 - 2 = -41/10$。\n    $A\\cos\\theta+B\\sin\\theta$ 的最大值为 $\\sqrt{A^2+B^2}$。该值等于奇异值之和 $\\sigma_1 + \\sigma_2$，因为 $\\det(C') = (-11/10)(1) - (2)(-21/10) = -11/10 + 42/10 = 31/10  0$，这确保了最优变换是一个正常旋转。\n    $$ \\sum_{k=1}^2 \\sigma_k = \\sqrt{\\left(-\\frac{1}{10}\\right)^2 + \\left(-\\frac{41}{10}\\right)^2} = \\sqrt{\\frac{1}{100} + \\frac{1681}{100}} = \\sqrt{\\frac{1682}{100}} = \\frac{\\sqrt{1682}}{10} $$\n    由于 $1682 = 2 \\times 841 = 2 \\times 29^2$，和为：\n    $$ \\sum_{k=1}^2 \\sigma_k = \\frac{\\sqrt{2 \\times 29^2}}{10} = \\frac{29\\sqrt{2}}{10} $$\n    第三个奇异值 $\\sigma_3$ 为 $0$，因为问题是平面的。\n\n4.  **计算RMSD。**\n    现在我们将这些值代入RMSD公式中：\n    $$ (\\mathrm{RMSD})^2 = \\frac{1}{N} D^2_{\\min} = \\frac{1}{3} \\left( \\sum \\|\\mathbf{x}_i\\|^2 + \\sum \\|\\mathbf{y}_i\\|^2 - 2\\sum \\sigma_k \\right) $$\n    $$ (\\mathrm{RMSD})^2 = \\frac{1}{3} \\left( 4 + \\frac{631}{150} - 2\\left(\\frac{29\\sqrt{2}}{10}\\right) \\right) = \\frac{1}{3} \\left( \\frac{600}{150} + \\frac{631}{150} - \\frac{29\\sqrt{2}}{5} \\right) $$\n    $$ (\\mathrm{RMSD})^2 = \\frac{1}{3} \\left( \\frac{1231}{150} - \\frac{29\\sqrt{2} \\times 30}{5 \\times 30} \\right) = \\frac{1}{3} \\left( \\frac{1231 - 870\\sqrt{2}}{150} \\right) $$\n    $$ (\\mathrm{RMSD})^2 = \\frac{1231 - 870\\sqrt{2}}{450} $$\n    最终的RMSD是该值的平方根：\n    $$ \\mathrm{RMSD} = \\sqrt{\\frac{1231 - 870\\sqrt{2}}{450}} $$\n    平方根内的参数是正的，因为 $870\\sqrt{2} \\approx 870 \\times 1.414 = 1230.18  1231$。", "answer": "$$ \\boxed{\\sqrt{\\frac{1231 - 870\\sqrt{2}}{450}}} $$", "id": "2422916"}, {"introduction": "在虚拟筛选中，我们需要分析大量化合物的数据，而不仅仅是单个配体。本练习 ([@problem_id:2422882]) 将带你从单分子分析扩展到数据集分析，并引入“配体效率”(LE) 这一在先导化合物优化中的关键指标。通过对假设的数据集进行统计检验，你将学会如何从对接结果中发掘配体结构与活性之间的潜在关系。", "problem": "您将获得多个独立的配体对接实验数据集。对于每个数据集，您会得到一个对接分数列表以及每个配体对应的重原子数量列表。对于每个数据集，通过逐元素公式 $L_i = S_i / N_i$ 定义配体效率序列，其中 $S_i$ 是配体索引 $i$ 的对接分数，$N_i$ 是同一配体索引 $i$ 的重原子数。设 $n$ 为一个数据集中的配体数量。对于每个数据集，您必须检验原假设 $H_0: \\rho = 0$ 与双侧备择假设 $H_1: \\rho \\neq 0$。其中 $\\rho$ 是向量 $(S_i)_{i=1}^n$ 和 $(L_i)_{i=1}^n$ 之间的总体皮尔逊相关性。使用以下决策规则：计算样本皮尔逊相关系数 $r$ 和在原假设下对应的双侧 $p$ 值，该值使用具有 $n - 2$ 个自由度的学生t分布及以下统计量得出\n$$\nt = r \\sqrt{\\frac{n - 2}{1 - r^2}} \\quad \\text{for } |r| \\neq 1,\n$$\n当且仅当 $p  \\alpha$ 时，做出拒绝 $H_0$ 的决策，其中 $\\alpha = 0.05$。如果 $(S_i)_{i=1}^n$ 或 $(L_i)_{i=1}^n$ 中任意一个的样本标准差为零（因此 $r$ 未定义），则决策必须为不拒绝 $H_0$。所有计算都是无量纲的；没有需要报告的物理单位。\n\n测试组。对于每个数据集 $k \\in \\{1, 2, 3, 4\\}$，您将获得长度为 $n$ 的等长数组，包括对接分数 $S^{(k)}$ 和重原子数 $N^{(k)}$，具体如下：\n- 数据集 1：$S^{(1)} = \\{-6.0, -7.2, -5.5, -8.1, -6.8, -7.6\\}$ 和 $N^{(1)} = \\{20, 20, 20, 20, 20, 20\\}$。\n- 数据集 2：$S^{(2)} = \\{-4.1, -5.8, -6.95, -8.55, -9.6, -11.3, -12.55, -14.05\\}$ 和 $N^{(2)} = \\{12, 16, 20, 24, 28, 32, 36, 40\\}$。\n- 数据集 3：$S^{(3)} = \\{-8.0, -7.5, -7.0, -6.5, -6.0, -5.5, -5.2, -4.8\\}$ 和 $N^{(3)} = \\{20, 22, 24, 26, 28, 30, 32, 34\\}$。\n- 数据集 4：$S^{(4)} = \\{-7.0, -7.0, -7.0, -7.0, -7.0, -7.0\\}$ 和 $N^{(4)} = \\{12, 14, 16, 18, 20, 22\\}$。\n\n角度单位和物理单位在此不适用。所有值均为实数。\n\n您的程序必须为每个数据集 $k$ 计算布尔决策值，定义为：如果 $p_k  \\alpha$，则 $\\text{reject}_k = \\text{True}$；否则 $\\text{reject}_k = \\text{False}$。其中 $p_k$ 是 $S^{(k)}$ 和 $L^{(k)}$ 相关性检验的双侧 $p$ 值。如果任一序列的方差为零导致相关系数未定义，则设置 $\\text{reject}_k = \\text{False}$。最终输出必须是一行，包含按 $k = 1, 2, 3, 4$ 顺序排列的四个布尔决策值，格式为方括号内以逗号分隔的列表，例如 $[\\text{True},\\text{False},\\text{True},\\text{False}]$。", "solution": "任务是就来自配体对接实验的四个不同数据集执行一系列假设检验。对于每个数据集，我们必须检验原假设 $H_0: \\rho = 0$ 与双侧备择假设 $H_1: \\rho \\neq 0$，其中 $\\rho$ 是对接分数 $(S_i)$ 与相应配体效率 $(L_i)$ 之间的总体皮尔逊相关系数。配体效率定义为 $L_i = S_i / N_i$，其中 $N_i$ 是重原子数。决策规则是：如果计算出的 $p$ 值小于显著性水平 $\\alpha = 0.05$，则拒绝 $H_0$。$p$ 值由样本皮尔逊相关系数 $r$ 确定，使用一个服从具有 $n-2$ 个自由度的学生t分布的检验统计量。一个特殊条件规定，如果 $(S_i)$ 或 $(L_i)$ 序列的样本标准差为零，则相关性未定义，决策为不拒绝 $H_0$。\n\n我们按部就班地分析每个数据集。\n\n**数据集 1:**\n给定数据为对接分数 $S^{(1)} = \\{-6.0, -7.2, -5.5, -8.1, -6.8, -7.6\\}$ 和重原子数 $N^{(1)} = \\{20, 20, 20, 20, 20, 20\\}$。样本量为 $n_1 = 6$。\n配体效率序列 $L^{(1)}$ 通过逐元素除法 $L^{(1)}_i = S^{(1)}_i / N^{(1)}_i$ 计算得出。由于 $N^{(1)}$ 是一个所有元素都等于 $20$ 的常数向量，因此 $L^{(1)}_i = S^{(1)}_i / 20$。\n这意味着 $L^{(1)}$ 是 $S^{(1)}$ 的一个直接正线性变换。一个变量与其正线性变换之间的样本皮尔逊相关系数 $r$ 精确为 $1$。因此，$r_1 = 1$。\n$S^{(1)}$ 和 $L^{(1)}$ 的标准差均非零。\n对于完全相关（其中 $|r| = 1$），反对零相关性原假设的证据是最大的。因此，相应的 $p$ 值 $p_1$ 为 $0$。\n通过将 $p_1$ 与 $\\alpha = 0.05$ 进行比较来做出决策。由于 $p_1 = 0  0.05$，我们拒绝原假设 $H_0$。决策为 $\\text{True}$。\n\n**数据集 2:**\n数据为 $S^{(2)} = \\{-4.1, -5.8, -6.95, -8.55, -9.6, -11.3, -12.55, -14.05\\}$ 和 $N^{(2)} = \\{12, 16, 20, 24, 28, 32, 36, 40\\}$。样本量为 $n_2 = 8$。\n配体效率序列为 $L^{(2)}_i = S^{(2)}_i / N^{(2)}_i$。这得出 $L^{(2)} \\approx \\{-0.3417, -0.3625, -0.3475, -0.3563, -0.3429, -0.3531, -0.3486, -0.3513\\}$。\n$S^{(2)}$ 和 $L^{(2)}$ 的标准差均非零。\n我们计算 $S^{(2)}$ 和 $L^{(2)}$ 之间的样本皮尔逊相关系数，得到 $r_2 \\approx 0.5256$。\n$t$ 检验的自由度为 $df_2 = n_2 - 2 = 8 - 2 = 6$。\n检验统计量计算如下 $t_2 = r_2 \\sqrt{\\frac{n_2 - 2}{1 - r_2^2}} \\approx 0.5256 \\sqrt{\\frac{6}{1 - (0.5256)^2}} \\approx 1.516$。\n双侧 $p$ 值 $p_2$ 是概率 $P(|T_{df=6}| > |t_2|) \\approx P(|T_{df=6}| > 1.516)$，其计算结果约为 $0.1818$。\n由于 $p_2 \\approx 0.1818 > 0.05$，我们未能拒绝原假设 $H_0$。决策为 $\\text{False}$。\n\n**数据集 3:**\n数据为 $S^{(3)} = \\{-8.0, -7.5, -7.0, -6.5, -6.0, -5.5, -5.2, -4.8\\}$ 和 $N^{(3)} = \\{20, 22, 24, 26, 28, 30, 32, 34\\}$。样本量为 $n_3 = 8$。\n配体效率序列为 $L^{(3)}_i = S^{(3)}_i / N^{(3)}_i$。这得出 $L^{(3)} \\approx \\{-0.4000, -0.3409, -0.2917, -0.2500, -0.2143, -0.1833, -0.1625, -0.1412\\}$。\n$S^{(3)}$ 和 $L^{(3)}$ 的标准差均非零。\n样本皮尔逊相关系数为 $r_3 \\approx 0.9926$。这表明存在非常强的正线性关系。\n自由度为 $df_3 = n_3 - 2 = 6$。\n检验统计量为 $t_3 = r_3 \\sqrt{\\frac{n_3 - 2}{1 - r_3^2}} \\approx 0.9926 \\sqrt{\\frac{6}{1 - (0.9926)^2}} \\approx 20.08$。\n双侧 $p$ 值 $p_3$ 是 $P(|T_{df=6}| > |t_3|) \\approx P(|T_{df=6}| > 20.08)$，其计算结果约为 $1.055 \\times 10^{-5}$。\n由于 $p_3 \\approx 1.055 \\times 10^{-5}  0.05$，我们拒绝原假设 $H_0$。决策为 $\\text{True}$。\n\n**数据集 4:**\n数据为 $S^{(4)} = \\{-7.0, -7.0, -7.0, -7.0, -7.0, -7.0\\}$ 和 $N^{(4)} = \\{12, 14, 16, 18, 20, 22\\}$。\n对接分数序列 $S^{(4)}$ 是一个常数向量。因此，其样本标准差精确为零。\n问题陈述明确规定了这种情况下的规则：“如果 $(S_i)_{i=1}^n$ 或 $(L_i)_{i=1}^n$ 中任意一个的样本标准差为零（因此 $r$ 未定义），则决策必须为不拒绝 $H_0$”。\n遵循此规则，我们无需计算 $L^{(4)}$ 或进行任何进一步的统计检验。\n决策为不拒绝 $H_0$。决策为 $\\text{False}$。\n\n总而言之，四个数据集的决策分别为：`True`、`False`、`True`、`False`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import pearsonr\n\ndef solve():\n    \"\"\"\n    Computes for each dataset whether to reject the null hypothesis of zero correlation\n    between docking scores and ligand efficiencies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            [-6.0, -7.2, -5.5, -8.1, -6.8, -7.6],\n            [20, 20, 20, 20, 20, 20]\n        ),\n        (\n            [-4.1, -5.8, -6.95, -8.55, -9.6, -11.3, -12.55, -14.05],\n            [12, 16, 20, 24, 28, 32, 36, 40]\n        ),\n        (\n            [-8.0, -7.5, -7.0, -6.5, -6.0, -5.5, -5.2, -4.8],\n            [20, 22, 24, 26, 28, 30, 32, 34]\n        ),\n        (\n            [-7.0, -7.0, -7.0, -7.0, -7.0, -7.0],\n            [12, 14, 16, 18, 20, 22]\n        )\n    ]\n\n    alpha = 0.05\n    results = []\n\n    for s_list, n_list in test_cases:\n        s_vec = np.array(s_list, dtype=np.float64)\n        n_vec = np.array(n_list, dtype=np.float64)\n        \n        # Calculate ligand efficiency sequence L = S / N\n        l_vec = np.divide(s_vec, n_vec)\n        \n        # Per problem specification, if the standard deviation of either sequence is zero,\n        # the correlation is undefined and we do not reject H0.\n        # np.std returns exactly 0.0 for constant arrays, so direct comparison is safe.\n        if np.std(s_vec, ddof=1) == 0.0 or np.std(l_vec, ddof=1) == 0.0:\n            results.append(False)\n            continue\n            \n        # Calculate the sample Pearson correlation coefficient and the p-value.\n        # scipy.stats.pearsonr computes the r-statistic and the two-sided p-value\n        # for a hypothesis test whose null hypothesis is that two sets of data are\n        # uncorrelated. This function correctly implements the specified t-test.\n        _r, p_value = pearsonr(s_vec, l_vec)\n        \n        # Apply the decision rule: reject H0 if p  alpha\n        reject_h0 = p_value  alpha\n        results.append(reject_h0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2422882"}]}