{"hands_on_practices": [{"introduction": "折叠识别中的许多评分函数并非源于物理学的第一性原理，而是从已知蛋白质结构的数据库中推断出来的统计“势”。本练习将指导您完成此过程的简化版本，您将通过求解基于观测数据的线性方程组，来反向工程化疏水和极性残基之间的相互作用能量参数 [@problem_id:2391489]。这项实践揭示了许多生物信息学工具以数据驱动的本质，并锻炼您的分析问题解决能力。", "problem": "在基于模板的穿线法折叠识别中，假设氨基酸被粗略地分为两个物理化学类别：疏水性$\\mathrm{(H)}$和极性$\\mathrm{(P)}$。在一个简单的成对接触势下，给定序列穿线到候选结构上的总比对能量$E_{\\text{tot}}$被假定为在天然分子内接触上是可加的，并且在残基类型上是对称的：\n$$\nE_{\\text{tot}} \\;=\\; C_{\\mathrm{HH}}\\,E_{\\mathrm{HH}} \\;+\\; C_{\\mathrm{HP}}\\,E_{\\mathrm{HP}} \\;+\\; C_{\\mathrm{PP}}\\,E_{\\mathrm{PP}},\n$$\n其中$C_{\\mathrm{XY}}$是$\\mathrm{X}$-$\\mathrm{Y}$类型（$\\mathrm{X},\\mathrm{Y}\\in\\{\\mathrm{H},\\mathrm{P}\\}$）的唯一残基-残基接触数，$E_{\\mathrm{XY}}=E_{\\mathrm{YX}}$是$\\mathrm{X}$-$\\mathrm{Y}$类型的（未知）接触能量。所有能量都以$k_B T$为单位表示，其中$k_B$是Boltzmann常数，$T$是绝对温度。\n\n现给出三个不同的、经过实验验证的正确序列-结构比对，每个比对都由其接触数和总能量总结如下：\n- 比对1：$C_{\\mathrm{HH}}=8$, $C_{\\mathrm{HP}}=12$, $C_{\\mathrm{PP}}=5$, 其$E_{\\text{tot}}^{(1)}=-25.5$。\n- 比对2：$C_{\\mathrm{HH}}=3$, $C_{\\mathrm{HP}}=10$, $C_{\\mathrm{PP}}=12$, 其$E_{\\text{tot}}^{(2)}=-10$。\n- 比对3：$C_{\\mathrm{HH}}=15$, $C_{\\mathrm{HP}}=3$, $C_{\\mathrm{PP}}=2$, 其$E_{\\text{tot}}^{(3)}=-32$。\n\n假设这三个比对都基于相同的成对接触势$\\{E_{\\mathrm{HH}},E_{\\mathrm{HP}},E_{\\mathrm{PP}}\\}$，请确定疏水-极性接触能量$E_{\\mathrm{HP}}$。请给出精确值，不要四舍五入。答案需以上文指定的$k_B T$为单位表示。", "solution": "在尝试任何解答之前，必须先确立问题陈述的有效性。\n\n步骤1：提取已知条件。\n问题提供了以下信息：\n- 比对的总能量由线性模型给出：$E_{\\text{tot}} = C_{\\mathrm{HH}} E_{\\mathrm{HH}} + C_{\\mathrm{HP}} E_{\\mathrm{HP}} + C_{\\mathrm{PP}} E_{\\mathrm{PP}}$。\n- 变量$C_{\\mathrm{XY}}$表示$\\mathrm{X}$-$\\mathrm{Y}$类型的接触数，其中$\\mathrm{X}, \\mathrm{Y} \\in \\{\\mathrm{H}, \\mathrm{P}\\}$。\n- 参数$E_{\\mathrm{XY}}$是未知的接触能量，且是对称的，即$E_{\\mathrm{XY}} = E_{\\mathrm{YX}}$。能量单位为$k_B T$。\n- 提供了三个不同比对的数据：\n  - 比对1：$C_{\\mathrm{HH}}=8$, $C_{\\mathrm{HP}}=12$, $C_{\\mathrm{PP}}=5$, 其$E_{\\text{tot}}^{(1)}=-25.5$。\n  - 比对2：$C_{\\mathrm{HH}}=3$, $C_{\\mathrm{HP}}=10$, $C_{\\mathrm{PP}}=12$, 其$E_{\\text{tot}}^{(2)}=-10$。\n  - 比对3：$C_{\\mathrm{HH}}=15$, $C_{\\mathrm{HP}}=3$, $C_{\\mathrm{PP}}=2$, 其$E_{\\text{tot}}^{(3)}=-32$。\n- 目标是确定疏水-极性接触能量$E_{\\mathrm{HP}}$的值。\n\n步骤2：使用提取的已知条件进行验证。\n该问题具有科学依据。使用简化的双字母表(H/P)和成对接触势是计算蛋白质生物物理学中用于折叠识别（称为穿线法）的一种标准且有效的粗粒化技术。其数学模型是一个线性系统，这是一种合适的形式化表达。\n\n如果所提供的数据能导出未知数$\\{E_{\\mathrm{HH}}, E_{\\mathrm{HP}}, E_{\\mathrm{PP}}\\}$的唯一且有意义的解，那么该问题是适定的。给定的三个比对可以得到一个包含三个变量的三个线性方程组：\n$$\n\\begin{cases}\n    8 E_{\\mathrm{HH}} + 12 E_{\\mathrm{HP}} + 5 E_{\\mathrm{PP}}  = -25.5 \\\\\n    3 E_{\\mathrm{HH}} + 10 E_{\\mathrm{HP}} + 12 E_{\\mathrm{PP}}  = -10 \\\\\n    15 E_{\\mathrm{HH}} + 3 E_{\\mathrm{HP}} + 2 E_{\\mathrm{PP}}  = -32\n\\end{cases}\n$$\n该系统可以写成矩阵形式$A \\mathbf{x} = \\mathbf{b}$，其中$\\mathbf{x} = \\begin{pmatrix} E_{\\mathrm{HH}} \\\\ E_{\\mathrm{HP}} \\\\ E_{\\mathrm{PP}} \\end{pmatrix}$，$\\mathbf{b} = \\begin{pmatrix} -25.5 \\\\ -10 \\\\ -32 \\end{pmatrix}$，而$A$是系数矩阵：\n$$\nA = \\begin{pmatrix} 8  12  5 \\\\ 3  10  12 \\\\ 15  3  2 \\end{pmatrix}\n$$\n当且仅当系数矩阵$A$的行列式不为零时，存在唯一解。我们来计算该行列式：\n$$\n\\det(A) = 8(10 \\cdot 2 - 12 \\cdot 3) - 12(3 \\cdot 2 - 12 \\cdot 15) + 5(3 \\cdot 3 - 10 \\cdot 15)\n$$\n$$\n\\det(A) = 8(20 - 36) - 12(6 - 180) + 5(9 - 150)\n$$\n$$\n\\det(A) = 8(-16) - 12(-174) + 5(-141)\n$$\n$$\n\\det(A) = -128 + 2088 - 705 = 1255\n$$\n由于$\\det(A) = 1255 \\neq 0$，该方程组有唯一解。因此，该问题在科学上是合理的、客观的且适定的。它没有违反任何指定的无效标准。\n\n步骤3：结论与行动。\n问题是有效的。下面将推导解答。\n\n为了求出$E_{\\mathrm{HP}}$的值，我们可以使用Cramer法则。第二个变量$E_{\\mathrm{HP}}$的值由以下行列式的比值给出：\n$$\nE_{\\mathrm{HP}} = \\frac{\\det(A_{E_{\\mathrm{HP}}})}{\\det(A)}\n$$\n其中$A_{E_{\\mathrm{HP}}}$是将$A$的第二列替换为常数向量$\\mathbf{b}$后形成的矩阵：\n$$\nA_{E_{\\mathrm{HP}}} = \\begin{pmatrix} 8  -25.5  5 \\\\ 3  -10  12 \\\\ 15  -32  2 \\end{pmatrix}\n$$\n现在，我们计算$A_{E_{\\mathrm{HP}}}$的行列式。为方便计算，我们使用分数形式$-25.5 = -\\frac{51}{2}$。\n$$\n\\det(A_{E_{\\mathrm{HP}}}) = 8(-10 \\cdot 2 - 12 \\cdot (-32)) - (-25.5)(3 \\cdot 2 - 12 \\cdot 15) + 5(3 \\cdot (-32) - (-10) \\cdot 15)\n$$\n$$\n\\det(A_{E_{\\mathrm{HP}}}) = 8(-20 + 384) + 25.5(6 - 180) + 5(-96 + 150)\n$$\n$$\n\\det(A_{E_{\\mathrm{HP}}}) = 8(364) + 25.5(-174) + 5(54)\n$$\n$$\n\\det(A_{E_{\\mathrm{HP}}}) = 2912 - 4437 + 270\n$$\n$$\n\\det(A_{E_{\\mathrm{HP}}}) = 3182 - 4437 = -1255\n$$\n最后，我们计算$E_{\\mathrm{HP}}$：\n$$\nE_{\\mathrm{HP}} = \\frac{-1255}{1255} = -1\n$$\n疏水-极性接触能量$E_{\\mathrm{HP}}$为$-1$（单位为$k_B T$）。\n为完整起见，我们可以确定全套参数：$E_{\\mathrm{HH}} = -2$，$E_{\\mathrm{HP}} = -1$，$E_{\\mathrm{PP}} = 0.5$。这证实了疏水-疏水相互作用最有利，极性-极性相互作用相对于其他作用是弱排斥的，而混合的疏水-极性相互作用是中等有利的，这在物理上是合理的。导出$E_{\\mathrm{HP}}$的计算过程是自洽且正确的。", "answer": "$$\n\\boxed{-1}\n$$", "id": "2391489"}, {"introduction": "蛋白质结构的一个基本原则是，疏水残基倾向于隐藏在远离水分子的地方，而亲水残基则暴露于表面。本练习将这一生物物理原理转化为一个一维穿线模型的计算评分函数，您将根据溶剂暴露谱来评估一个序列与一个模板的匹配程度 [@problem_id:2391514]。通过实现这种“负向穿线”评分，您将亲身体验折叠识别中最重要的能量项之一。", "problem": "给定一个固定长度的穿线评估设置，该设置根据已知的溶剂暴露倾向，对氨基酸残基在结构模板上的放置进行评分。目标是为每个测试用例计算一个单一的“负穿线分数”，使得放置在表面暴露位置的亲水残基产生更有利的（更负的）贡献，而放置在埋藏位置的亲水残基则产生惩罚（正贡献）。疏水残基产生相反的模式。最终的分数是所有位置分数的总和，不考虑任何缺口或插入。\n\n定义和设置：\n- 设序列长度为 $n \\in \\mathbb{N}$，由位置 $i \\in \\{1,\\dots,n\\}$ 索引。\n- 结构模板为每个位置 $i$ 提供一个溶剂暴露值 $e_i \\in [0,1]$，其中 $e_i = 1$ 表示完全表面暴露，$e_i = 0$ 表示完全埋藏。\n- 设 $\\mathcal{A}$ 是 $20$ 种标准氨基酸的集合。定义亲水子集 $\\mathcal{H} = \\{ \\mathrm{D}, \\mathrm{E}, \\mathrm{K}, \\mathrm{R}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{H}, \\mathrm{S}, \\mathrm{T}, \\mathrm{Y} \\}$，并将 $\\mathcal{A} \\setminus \\mathcal{H}$ 中的所有残基视为疏水残基。任何不在 $\\mathcal{A}$ 中的残基在其位置上的贡献为零。\n- 定义亲水性指示符，如果 $a \\in \\mathcal{H}$，则 $h(a) = 1$；如果 $a \\in \\mathcal{A} \\setminus \\mathcal{H}$，则 $h(a) = 0$。对于 $a \\notin \\mathcal{A}$，将其在每个位置的贡献设置为零。\n- 使用两个正权重：$\\lambda_{h} = 2$ 和 $\\lambda_{hp} = 1$。\n- 对于位置 $i$ 处暴露值为 $e_i$ 的残基 $a_i$，其每个位置的分数为\n$$\ns_i = \\lambda_h \\, h(a_i)\\,(1 - 2 e_i) \\;+\\; \\lambda_{hp} \\, \\bigl(1 - h(a_i)\\bigr)\\,(2 e_i - 1).\n$$\n- 总负穿线分数为\n$$\nS = \\sum_{i=1}^{n} s_i.\n$$\n根据构造，如果 $h(a_i) = 1$ 且 $e_i$ 较大，则 $s_i$ 为负（有利）；而如果 $h(a_i) = 1$ 且 $e_i$ 较小，则 $s_i$ 为正（惩罚）。反之，如果 $h(a_i) = 0$（疏水）且 $e_i$ 较小（埋藏），则 $s_i$ 为负（有利）；而如果 $e_i$ 较大（表面），则 $s_i$ 为正（惩罚）。\n\n任务：\n实现一个程序，为以下每个测试用例计算 $S$。在每个案例中，序列长度等于暴露值的数量。暴露值是无单位的，并且属于 $[0,1]$ 区间。\n\n测试套件：\n- 案例1：序列 = \"DEKR\"，暴露值 = $[1.0, 0.8, 0.2, 0.2]$。\n- 案例2：序列 = \"VVIL\"，暴露值 = $[0.1, 0.3, 0.8, 1.0]$。\n- 案例3：序列 = \"DKVA\"，暴露值 = $[1.0, 0.2, 0.8, 0.2]$。\n- 案例4：序列 = \"AXZX\"，暴露值 = $[1.0, 0.0, 1.0, 0.0]$。\n- 案例5：序列 = \"STYW\"，暴露值 = $[0.5, 0.5, 0.5, 0.5]$。\n\n要求：\n- 为每个案例精确计算如上定义的总分 $S$。如果任何残基不在 $\\mathcal{A}$ 中，则无论 $e_i$ 为何值，其在该位置的贡献都被定义为 $0$。\n- 生成单行输出，其中包含一个列表，按案例顺序包含 $5$ 个总分。每个分数必须是精确到小数点后三位的小数（浮点数）值。列表必须用方括号括起来，并包含逗号分隔的值，且无空格。例如，包含三个值的输出必须形如 $[x_1,x_2,x_3]$，其中每个 $x_j$ 在小数点后恰好有三位数字。", "solution": "问题陈述已经过严格验证，被认为是具有科学依据、良定且客观的。它为蛋白质折叠识别（计算生物学中的一个有效课题）提供了一个简化但连贯的模型。所有参数、函数和测试用例都得到了明确和一致的定义，从而可以得到唯一且可验证的解。因此，我们可以进行推导。\n\n目标是为五个给定的测试用例计算总负穿线分数 $S$。该分数评估蛋白质序列 $a_1 a_2 \\dots a_n$ 对于由一系列溶剂暴露值 $e_1, e_2, \\dots, e_n$ 定义的结构模板的适应性。\n\n分数定义为各位置分数的总和，$S = \\sum_{i=1}^{n} s_i$。对于位置 $i$ 处暴露值为 $e_i$ 的残基 $a_i$，其每个位置的分数 $s_i$ 由下式给出：\n$$\ns_i = \\lambda_h \\, h(a_i)\\,(1 - 2 e_i) \\;+\\; \\lambda_{hp} \\, \\bigl(1 - h(a_i)\\bigr)\\,(2 e_i - 1)\n$$\n其中 $h(a_i)$ 是亲水性指示符，如果 $a_i$ 是亲水性的，则 $h(a_i) = 1$；如果 $a_i$ 是疏水性的，则 $h(a_i) = 0$。权重给定为 $\\lambda_h = 2$ 和 $\\lambda_{hp} = 1$。对于不属于 $20$ 种标准氨基酸 ($\\mathcal{A}$) 的任何残基 $a_i$，其贡献 $s_i$ 被规定为 $0$。\n\n我们可以通过注意到 $(2e_i - 1) = -(1 - 2e_i)$ 来简化 $s_i$ 的表达式。将此代入公式可得：\n$$\ns_i = \\lambda_h \\, h(a_i)\\,(1 - 2 e_i) \\;-\\; \\lambda_{hp} \\, \\bigl(1 - h(a_i)\\bigr)\\,(1 - 2 e_i)\n$$\n提取公因式 $(1 - 2e_i)$：\n$$\ns_i = (1 - 2e_i) \\left[ \\lambda_h h(a_i) - \\lambda_{hp}(1 - h(a_i)) \\right]\n$$\n对于 $a_i \\in \\mathcal{A}$ 的两种残基类型，可以对该表达式进行求值：\n1.  如果残基 $a_i$ 是亲水性的 ($a_i \\in \\mathcal{H}$)，则 $h(a_i) = 1$。方括号中的项变为 $\\lambda_h \\cdot 1 - \\lambda_{hp}(1-1) = \\lambda_h$。分数为 $s_i = \\lambda_h (1 - 2e_i) = 2(1 - 2e_i)$。\n2.  如果残基 $a_i$ 是疏水性的 ($a_i \\in \\mathcal{A} \\setminus \\mathcal{H}$)，则 $h(a_i) = 0$。方括号中的项变为 $\\lambda_h \\cdot 0 - \\lambda_{hp}(1-0) = -\\lambda_{hp}$。分数为 $s_i = -\\lambda_{hp}(1 - 2e_i) = \\lambda_{hp}(2e_i - 1) = 1(2e_i - 1)$。\n\n现在，我们将应用这些简化公式来计算每个测试用例的总分 $S$。亲水性集合为 $\\mathcal{H} = \\{ \\mathrm{D}, \\mathrm{E}, \\mathrm{K}, \\mathrm{R}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{H}, \\mathrm{S}, \\mathrm{T}, \\mathrm{Y} \\}$。\n\n**案例1：** 序列 = \"DEKR\"，暴露值 = $[1.0, 0.8, 0.2, 0.2]$\n所有残基均为亲水性。\n$s_1(\\mathrm{D}, e_1=1.0) = 2(1 - 2 \\cdot 1.0) = 2(-1) = -2.0$\n$s_2(\\mathrm{E}, e_2=0.8) = 2(1 - 2 \\cdot 0.8) = 2(-0.6) = -1.2$\n$s_3(\\mathrm{K}, e_3=0.2) = 2(1 - 2 \\cdot 0.2) = 2(0.6) = 1.2$\n$s_4(\\mathrm{R}, e_4=0.2) = 2(1 - 2 \\cdot 0.2) = 2(0.6) = 1.2$\n总分 $S_1 = -2.0 - 1.2 + 1.2 + 1.2 = -0.8$。\n\n**案例2：** 序列 = \"VVIL\"，暴露值 = $[0.1, 0.3, 0.8, 1.0]$\n所有残基均为疏水性。\n$s_1(\\mathrm{V}, e_1=0.1) = (2 \\cdot 0.1 - 1) = -0.8$\n$s_2(\\mathrm{V}, e_2=0.3) = (2 \\cdot 0.3 - 1) = -0.4$\n$s_3(\\mathrm{I}, e_3=0.8) = (2 \\cdot 0.8 - 1) = 0.6$\n$s_4(\\mathrm{L}, e_4=1.0) = (2 \\cdot 1.0 - 1) = 1.0$\n总分 $S_2 = -0.8 - 0.4 + 0.6 + 1.0 = 0.4$。\n\n**案例3：** 序列 = \"DKVA\"，暴露值 = $[1.0, 0.2, 0.8, 0.2]$\n残基 D, K 为亲水性；V, A 为疏水性。\n$s_1(\\mathrm{D}, e_1=1.0) = 2(1 - 2 \\cdot 1.0) = -2.0$\n$s_2(\\mathrm{K}, e_2=0.2) = 2(1 - 2 \\cdot 0.2) = 1.2$\n$s_3(\\mathrm{V}, e_3=0.8) = (2 \\cdot 0.8 - 1) = 0.6$\n$s_4(\\mathrm{A}, e_4=0.2) = (2 \\cdot 0.2 - 1) = -0.6$\n总分 $S_3 = -2.0 + 1.2 + 0.6 - 0.6 = -0.8$。\n\n**案例4：** 序列 = \"AXZX\"，暴露值 = $[1.0, 0.0, 1.0, 0.0]$\n残基 A 为疏水性。残基 X 和 Z 不在标准集合 $\\mathcal{A}$ 中。\n$s_1(\\mathrm{A}, e_1=1.0) = (2 \\cdot 1.0 - 1) = 1.0$\n$s_2(\\mathrm{X}, e_2=0.0) = 0$ (非标准)\n$s_3(\\mathrm{Z}, e_3=1.0) = 0$ (非标准)\n$s_4(\\mathrm{X}, e_4=0.0) = 0$ (非标准)\n总分 $S_4 = 1.0 + 0 + 0 + 0 = 1.0$。\n\n**案例5：** 序列 = \"STYW\"，暴露值 = $[0.5, 0.5, 0.5, 0.5]$\n残基 S, T, Y 为亲水性；W 为疏水性。所有位置的暴露值为 $e_i=0.5$。\n$s_1(\\mathrm{S}, e_1=0.5) = 2(1 - 2 \\cdot 0.5) = 2(0) = 0$\n$s_2(\\mathrm{T}, e_2=0.5) = 2(1 - 2 \\cdot 0.5) = 2(0) = 0$\n$s_3(\\mathrm{Y}, e_3=0.5) = 2(1 - 2 \\cdot 0.5) = 2(0) = 0$\n$s_4(\\mathrm{W}, e_4=0.5) = (2 \\cdot 0.5 - 1) = 0$\n总分 $S_5 = 0 + 0 + 0 + 0 = 0.0$。这是预料之中的，因为 $e_i=0.5$ 的暴露值代表一个中性环境，对任何一种残基类型都没有能量上的偏好。\n\n结果摘要：\n$S_1 = -0.8$\n$S_2 = 0.4$\n$S_3 = -0.8$\n$S_4 = 1.0$\n$S_5 = 0.0$\n\n这些结果将被格式化为小数点后三位，用于最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the negative threading score for a set of protein sequences\n    based on a simplified solvent exposure model.\n    \"\"\"\n\n    # Define problem parameters as per the statement.\n    lambda_h = 2.0\n    lambda_hp = 1.0\n    hydrophilic_residues = {'D', 'E', 'K', 'R', 'N', 'Q', 'H', 'S', 'T', 'Y'}\n    standard_amino_acids = {\n        'A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L',\n        'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y'\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"DEKR\", [1.0, 0.8, 0.2, 0.2]),\n        (\"VVIL\", [0.1, 0.3, 0.8, 1.0]),\n        (\"DKVA\", [1.0, 0.2, 0.8, 0.2]),\n        (\"AXZX\", [1.0, 0.0, 1.0, 0.0]),\n        (\"STYW\", [0.5, 0.5, 0.5, 0.5])\n    ]\n\n    results = []\n    # Iterate through each test case to calculate its total score.\n    for sequence, exposures in test_cases:\n        total_score = 0.0\n        # Iterate through each position in the sequence.\n        for i, residue in enumerate(sequence):\n            # The contribution is zero for non-standard amino acids.\n            if residue not in standard_amino_acids:\n                s_i = 0.0\n            else:\n                e_i = exposures[i]\n                is_hydrophilic = residue in hydrophilic_residues\n                \n                # Apply the appropriate scoring formula based on hydrophilicity.\n                if is_hydrophilic:\n                    # s_i = lambda_h * (1 - 2*e_i) for hydrophilic residues.\n                    s_i = lambda_h * (1.0 - 2.0 * e_i)\n                else:  # The residue is hydrophobic.\n                    # s_i = lambda_hp * (2*e_i - 1) for hydrophobic residues.\n                    s_i = lambda_hp * (2.0 * e_i - 1.0)\n            \n            total_score += s_i\n            \n        results.append(total_score)\n\n    # Format the results to exactly three decimal places as required.\n    formatted_results = [f\"{score:.3f}\" for score in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2391514"}, {"introduction": "现实世界中的序列-结构比对必须考虑插入和缺失（空位），以及结构数据中的不完美之处，如残基缺失或链断裂。这项高级练习要求您实现一个完整的动态规划穿线算法，该算法包含一个复杂的、对模板结构上下文敏感的仿射空位罚分模型 [@problem_id:2391490]。掌握这个问题将使您对现代穿线方法的核心算法有深刻的理解。", "problem": "设计并实现一个程序，给定一个查询氨基酸序列和一个源自蛋白质数据库 (PDB) 文件、可能存在残基缺失和链断裂的模板，该程序能够根据一个精确定义的评分模型计算出最大的全局穿线得分。程序必须计算每个测试用例的结果，并按照下述规定将它们汇总到单行输出中。\n\n公式化。设氨基酸字母表为一个有限集合，表示为 $\\mathcal{A}$。查询序列是一个有限字符串 $Q = q_1 q_2 \\dots q_n$，其中 $q_i \\in \\mathcal{A}$。模板由一个原始字符串 $T^{\\mathrm{orig}} = t^{\\mathrm{orig}}_1 t^{\\mathrm{orig}}_2 \\dots t^{\\mathrm{orig}}_m$（其中 $t^{\\mathrm{orig}}_j \\in \\mathcal{A}$）、一个存在掩码 $U = (u_1, u_2, \\dots, u_m)$（其中 $u_j \\in \\{0,1\\}$，用于指示位置 $j$ 的残基是否在结构中被观测到 ($u_j = 1$) 或缺失 ($u_j = 0$)）以及一组链断裂 $B \\subseteq \\{1,2,\\dots,m-1\\}$（其中 $j \\in B$ 表示在原始索引的位置 $j$ 和 $j+1$ 之间存在共价链断裂）给出。\n\n定义观测索引集 $J = \\{ j \\in \\{1,2,\\dots,m\\} : u_j = 1 \\}$，其自然递增顺序为 $j_1  j_2  \\dots  j_{m'}$。用于穿线的有效模板序列是 $T = t_1 t_2 \\dots t_{m'}$，其中 $t_\\ell = t^{\\mathrm{orig}}_{j_\\ell}$。在有效模板上定义一个断裂指示符如下：对于每个 $\\ell \\in \\{1,2,\\dots,m'-1\\}$，在 $t_\\ell$ 和 $t_{\\ell+1}$ 之间设置一个断裂，当且仅当 $j_{\\ell+1} = j_\\ell + 1$ 且 $j_\\ell \\in B$。这将 $T$ 划分为由断裂分隔的连续片段。设 $\\mathrm{segstart}(\\ell)$ 为指示位置 $\\ell$ 是否是 $T$ 中一个片段起始位置的指示符；根据定义，$\\mathrm{segstart}(1) = 1$，且对于 $\\ell \\ge 2$，如果 $t_{\\ell-1}$ 和 $t_\\ell$ 之间存在断裂，则 $\\mathrm{segstart}(\\ell) = 1$，否则 $\\mathrm{segstart}(\\ell) = 0$。\n\n$Q$ 和 $T$ 之间的一个比对是一个全局比对，它将 $Q$ 的每个字符和 $T$ 的每个字符与另一个字符串中的一个字符（匹配或错配）或一个空位配对，并保持顺序。一个比对的总分定义为以下几个组成部分的总和：\n- 替换得分：对于每个比对上的对 $(q_i, t_\\ell)$，加上 $\\sigma(q_i,t_\\ell)$，其中\n  $\n  \\sigma(a,b) =\n  \\begin{cases}\n  +2,  \\text{如果 } a=b,\\\\\n  -1,  \\text{如果 } a\\ne b.\n  \\end{cases}\n  $\n- 插入罚分（模板中的空位，即 $Q$ 中的未配对字符）：对于 $Q$ 中每个长度为 $L \\ge 1$ 的连续未配对字符的最大连续段，加上罚分 $-(o_I + (L-1)e_I)$，其中 $o_I = 3$ 且 $e_I = 1$。\n- 删除罚分（序列中的空位，即 $T$ 中的未配对位置）：考虑在单个片段内 $T$ 中每个连续未配对位置的最大连续段。对于一个从模板位置 $\\ell$ 开始、长度为 $K \\ge 1$ 的连续段，加上罚分 $-(o_D^{\\mathrm{eff}}(\\ell) + (K-1)e_D)$，其中 $e_D = 1$ 且\n  $\n  o_D^{\\mathrm{eff}}(\\ell) =\n  \\begin{cases}\n  0,  \\text{如果 } \\mathrm{segstart}(\\ell) = 1,\\\\\n  3,  \\text{如果 } \\mathrm{segstart}(\\ell) = 0.\n  \\end{cases}\n  $\n  如果一个删除跨越多个片段，它将被分解为多个独立的连续段，每个片段内一个，并且上述罚分规则将独立应用于每个连续段。跨越链断裂的替换得分没有其他修改。原始模板中所有缺失的残基（$u_j = 0$）都从 $T$ 中排除，并且不对得分或罚分做出贡献。\n\n目标。对于每个测试用例，根据上述规则，计算 $Q$ 和有效模板 $T$ 之间所有全局比对可能的最大总分。\n\n测试套件。使用以下六个测试用例。在每个用例中，字母表为大写英文字母，数据如下：\n- 用例 1：$Q = \\text{\"ACDE\"}$；$T^{\\mathrm{orig}} = \\text{\"ACDE\"}$；$U = [\\,1,1,1,1\\,]$；$B = \\varnothing$。\n- 用例 2：$Q = \\text{\"ADE\"}$；$T^{\\mathrm{orig}} = \\text{\"ACDE\"}$；$U = [\\,1,0,1,1\\,]$；$B = \\varnothing$。\n- 用例 3：$Q = \\text{\"ABD\"}$；$T^{\\mathrm{orig}} = \\text{\"ABCD\"}$；$U = [\\,1,1,1,1\\,]$；$B = \\{\\,2\\,\\}$。\n- 用例 4：$Q = \\text{\"AAA\"}$；$T^{\\mathrm{orig}} = \\text{\"TTTT\"}$；$U = [\\,0,0,0,0\\,]$；$B = \\varnothing$。\n- 用例 5：$Q = \\text{\"AD\"}$；$T^{\\mathrm{orig}} = \\text{\"ABCD\"}$；$U = [\\,1,1,1,1\\,]$；$B = \\varnothing$。\n- 用例 6：$Q = \\text{\"AD\"}$；$T^{\\mathrm{orig}} = \\text{\"ABCD\"}$；$U = [\\,1,1,1,1\\,]$；$B = \\{\\,1\\,\\}$。\n\n答案类型。对于每个测试用例，答案是等于最大得分的单个整数。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按用例 1 到 6 的顺序排列结果，不含空格，例如 $[\\text{结果}_1,\\text{结果}_2,\\dots,\\text{结果}_6]$。", "solution": "该问题要求计算一个查询氨基酸序列与一个结构模板之间的最大全局穿线得分。该模板可能存在残基缺失和链断裂。这是带有仿射空位罚分的经典全局序列比对问题的一个变体，可以使用动态规划高效解决。特定的评分模型引入了一条新的删除罚分规则，该规则取决于从链断裂派生出的模板分段结构。\n\n解决方案主要分两个阶段进行：首先，预处理模板以派生其有效序列和片段信息；其次，应用一个自定义的动态规划算法来找到最优比对得分。\n\n**1. 模板预处理**\n\n设查询序列为 $Q$，长度为 $n$；原始模板序列为 $T^{\\mathrm{orig}}$，长度为 $m$。\n首先，我们构建有效模板序列 $T$。该序列仅包含结构中存在的残基，由存在掩码 $U=(u_1, \\dots, u_m)$ 指示。\n原始模板中已观测残基的索引集为 $J = \\{j \\in \\{1,\\dots,m\\} : u_j=1\\}$。设这些索引按升序排列为 $j_1  j_2  \\dots  j_{m'}$。\n有效模板 $T$ 则是长度为 $m'$ 的字符串 $t_1 t_2 \\dots t_{m'}$，其中 $t_\\ell = t^{\\mathrm{orig}}_{j_\\ell}$。\n\n接下来，我们在 $T$ 内部识别片段边界。如果有效模板位置 $t_\\ell$ 和 $t_{\\ell+1}$ 对应的原始索引是相邻的（$j_{\\ell+1} = j_\\ell + 1$），并且在该原始位置指定了断裂（$j_\\ell \\in B$），则定义在它们之间存在链断裂。\n我们定义一个长度为 $m'$ 的指示符数组 $\\mathrm{segstart}$。对于每个位置 $\\ell \\in \\{1, \\dots, m'\\}$，如果 $t_\\ell$ 是一个片段的第一个残基，则 $\\mathrm{segstart}(\\ell) = 1$，否则为 $0$。根据定义，$\\mathrm{segstart}(1)=1$。对于 $\\ell > 1$，如果 $t_{\\ell-1}$ 和 $t_\\ell$ 之间存在断裂，则 $\\mathrm{segstart}(\\ell)=1$。\n\n此片段信息对于计算删除罚分至关重要。在 $T$ 中位置 $\\ell$ 开始的删除的开口罚分，表示为 $o_D^{\\mathrm{eff}}(\\ell)$，定义如下：\n$$\no_D^{\\mathrm{eff}}(\\ell) =\n\\begin{cases}\n0,  \\text{如果 } \\mathrm{segstart}(\\ell) = 1, \\\\\n3,  \\text{如果 } \\mathrm{segstart}(\\ell) = 0.\n\\end{cases}\n$$\n删除的延伸罚分 $e_D$ 是一个常量 $1$。\n\n**2. 动态规划公式化**\n\n该问题可以使用类似于 Gotoh 算法处理仿射空位罚分的动态规划方法来解决。我们使用三个大小为 $(n+1) \\times (m'+1)$ 的矩阵（或表格）$M$、$I$ 和 $D$。这些表格中的每个条目 $(i, j)$ 存储了前缀 $Q[1..i]$ 和 $T[1..j]$ 在不同结束条件下的最优比对得分：\n- $M(i,j)$：$q_i$ 与 $t_j$ 比对（匹配或错配）的对齐得分。\n- $I(i,j)$：$q_i$ 与空位比对（在 $T$ 中插入）的对齐得分。\n- $D(i,j)$：$t_j$ 与空位比对（从 $T$ 中删除）的对齐得分。\n\n评分常数为：替换得分 $\\sigma(a,b)$ 对于匹配为 $+2$，对于错配为 $-1$；插入罚分 $o_I=3, e_I=1$；以及删除罚分 $e_D=1$ 与位置相关的 $o_D^{\\mathrm{eff}}(\\ell)$。\n\n**初始化：**\n表格初始化假设全局比对从空前缀开始。\n- $M(0,0) = 0$。所有表格中的所有其他条目初始化为 $-\\infty$。\n- 第一列 ($j=0$)：这对应于将前缀 $Q[1..i]$ 与空模板对齐，即连续 $i$ 次插入。\n  $$ I(i,0) = -(o_I + (i-1)e_I) \\quad \\text{对于 } i \\ge 1. $$\n- 第一行 ($i=0$)：这对应于将前缀 $T[1..j]$ 与空查询对齐，即一系列删除。得分根据片段结构累积。\n  $$ D(0,j) = D(0,j-1) - \\begin{cases} o_D^{\\mathrm{eff}}(j)  \\text{如果 } \\mathrm{segstart}(j)=1 \\\\ e_D  \\text{如果 } \\mathrm{segstart}(j)=0 \\text{ 且前一个操作也是删除} \\end{cases} $$\n  这是一个简化的表示，正确的初始化需要在片段边界处重置罚分。\n\n**递推关系：**\n对于 $i$ 从 $1$ 到 $n$，$j$ 从 $1$ 到 $m'$，我们填充表格：\n- **匹配/错配矩阵 $M$**：以 $(q_i, t_j)$ 结尾的比对必须跟在前缀 $Q[1..i-1]$ 和 $T[1..j-1]$ 的比对之后。\n  $$ M(i,j) = \\sigma(q_i, t_j) + \\max\\{M(i-1,j-1), I(i-1,j-1), D(i-1,j-1)\\} $$\n- **插入矩阵 $I$**：以在 $q_i$ 处插入结尾的比对可以开始一个新的插入连续段，也可以扩展一个现有的。\n  $$ I(i,j) = \\max \\begin{cases} \\max\\{M(i-1,j), D(i-1,j)\\} - o_I, \\\\ I(i-1,j) - e_I \\end{cases} $$\n- **删除矩阵 $D$**：这是自定义部分。对 $t_j$ 的删除可以开始一个新的连续段或扩展一个现有的。\n  $$ D(i,j) = \\max \\begin{cases} \\max\\{M(i,j-1), I(i,j-1)\\} - o_D^{\\mathrm{eff}}(j), \\\\ D(i,j-1) - e_D \\quad (\\text{仅当 } \\mathrm{segstart}(j)=0 \\text{ 时允许}) \\end{cases} $$\n  如果 $\\mathrm{segstart}(j)=1$，则不允许从 $D(i,j-1)$ 转移，因为这会跨越一个片段边界。\n\n**最终得分：**\n填满所有表格后，完整序列 $Q$ 和 $T$ 的最大全局比对得分是最后一个单元格 $(n, m')$ 中的最大值。\n$$ \\text{得分} = \\max\\{M(n,m'), I(n,m'), D(n,m')\\} $$\n这种系统性的计算确保我们能根据指定的规则找到所有可能的全局比对中的最大得分。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the protein threading problem for all test cases.\n    \"\"\"\n    \n    # Define constants from the problem statement.\n    SIGMA_MATCH = 2\n    SIGMA_MISMATCH = -1\n    O_I = 3\n    E_I = 1\n    O_D = 3\n    E_D = 1\n    \n    def _solve_case(Q, T_orig, U, B):\n        \"\"\"\n        Computes the maximum global threading score for a single test case using dynamic programming.\n        \"\"\"\n        n = len(Q)\n\n        # Step 1: Construct the effective template T and associated data.\n        T_list = []\n        orig_indices = []\n        for j, char in enumerate(T_orig):\n            if U[j] == 1:\n                T_list.append(char)\n                orig_indices.append(j + 1)\n        \n        T = \"\".join(T_list)\n        m_prime = len(T)\n\n        if m_prime == 0:\n            return -(O_I + (n - 1) * E_I) if n > 0 else 0\n\n        # Step 2: Compute segstart and o_D_eff arrays for the effective template.\n        segstart = np.zeros(m_prime, dtype=int)\n        segstart[0] = 1\n        \n        B_set = set(B)\n        for l in range(m_prime - 1):\n            j_l = orig_indices[l]\n            j_l_plus_1 = orig_indices[l+1]\n            if j_l_plus_1 == j_l + 1 and j_l in B_set:\n                segstart[l + 1] = 1\n                \n        o_D_eff = np.full(m_prime, O_D)\n        o_D_eff[segstart == 1] = 0\n\n        # Step 3: Initialize DP tables.\n        M = np.full((n + 1, m_prime + 1), -np.inf, dtype=float)\n        I = np.full((n + 1, m_prime + 1), -np.inf, dtype=float)\n        D = np.full((n + 1, m_prime + 1), -np.inf, dtype=float)\n\n        M[0, 0] = 0\n\n        # Step 4: Initialize the first row and column.\n        if n > 0:\n            I[1, 0] = -O_I\n            for i in range(2, n + 1):\n                I[i, 0] = I[i - 1, 0] - E_I\n\n        if m_prime > 0:\n            D[0, 1] = -o_D_eff[0]\n            for j in range(2, m_prime + 1):\n                if segstart[j - 1] == 1:\n                    D[0, j] = D[0, j - 1] - o_D_eff[j - 1]\n                else:\n                    D[0, j] = D[0, j - 1] - E_D\n\n        # Step 5: Fill DP tables.\n        for i in range(1, n + 1):\n            for j in range(1, m_prime + 1):\n                subst_score = SIGMA_MATCH if Q[i - 1] == T[j - 1] else SIGMA_MISMATCH\n                prev_M = max(M[i - 1, j - 1], I[i - 1, j - 1], D[i - 1, j - 1])\n                M[i, j] = subst_score + prev_M\n\n                open_I = max(M[i - 1, j], D[i - 1, j]) - O_I\n                extend_I = I[i - 1, j] - E_I\n                I[i, j] = max(open_I, extend_I)\n\n                open_D = max(M[i, j - 1], I[i, j - 1]) - o_D_eff[j - 1]\n                if segstart[j - 1] == 1:\n                    D[i, j] = open_D\n                else:\n                    extend_D = D[i, j - 1] - E_D\n                    D[i, j] = max(open_D, extend_D)\n\n        final_score = max(M[n, m_prime], I[n, m_prime], D[n, m_prime])\n        return int(round(final_score))\n\n    test_cases = [\n        {\"Q\": \"ACDE\", \"T_orig\": \"ACDE\", \"U\": [1, 1, 1, 1], \"B\": []},\n        {\"Q\": \"ADE\", \"T_orig\": \"ACDE\", \"U\": [1, 0, 1, 1], \"B\": []},\n        {\"Q\": \"ABD\", \"T_orig\": \"ABCD\", \"U\": [1, 1, 1, 1], \"B\": [2]},\n        {\"Q\": \"AAA\", \"T_orig\": \"TTTT\", \"U\": [0, 0, 0, 0], \"B\": []},\n        {\"Q\": \"AD\", \"T_orig\": \"ABCD\", \"U\": [1, 1, 1, 1], \"B\": []},\n        {\"Q\": \"AD\", \"T_orig\": \"ABCD\", \"U\": [1, 1, 1, 1], \"B\": [1]},\n    ]\n    \n    results = [_solve_case(**case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2391490"}]}