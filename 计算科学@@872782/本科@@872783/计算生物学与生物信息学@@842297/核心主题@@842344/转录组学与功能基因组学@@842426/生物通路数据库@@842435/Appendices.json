{"hands_on_practices": [{"introduction": "生物通路数据库（如KEGG）不仅仅是路线图，它们是包含化学计量信息的详细蓝图。这使我们能够进行精确的代谢核算，例如计算合成复杂生物分子所需的能量。在本练习中，您将利用通路信息来计算合成一个GTP分子（一种关键的细胞组分）所消耗的总ATP成本，从而巩固您定量解读通路数据的能力。[@problem_id:2375344]", "problem": "一名研究人员使用京都基因与基因组百科全书（KEGG）的嘌呤代谢途径来计算一种细菌中从头合成鸟苷三磷酸（GTP）的能量成本。从5-磷酸核糖（R5P）开始，该生物合成途径经过磷酸核糖焦磷酸（PRPP）、次黄苷酸（IMP）、鸟苷酸（GMP）、鸟苷二磷酸（GDP），最终生成GTP。假设以下标准化的化学计量特征，这些特征与KEGG对细菌途径的整理一致，并且所有激酶的磷酸供体均为三磷酸腺苷（ATP）：\n\n- R5P到PRPP：PRPP合成酶使用ATP生成一磷酸腺苷（AMP），这计为$2$个三磷酸腺苷当量。\n- PRPP到IMP：需要ATP的步骤包括甘氨酰胺核糖核苷酸（GAR）合成酶、甲酰甘氨脒核糖核苷酸（FGAM）合成酶、5-氨基咪唑核糖核苷酸（AIR）合成酶、N$5$-羧基氨基咪唑核糖核苷酸（N$5$-CAIR）合成酶以及琥珀酰氨基咪唑甲酰胺核糖核苷酸（SAICAR）合成酶。这些步骤中的每一步都将ATP转化为二磷酸腺苷（ADP），并计为$1$个三磷酸腺苷当量。\n- IMP到GMP：次黄苷酸脱氢酶使用烟酰胺腺嘌呤二核苷酸（$\\text{NAD}^+$），无ATP成本；鸟苷酸合成酶使用ATP生成AMP，计为$2$个三磷酸腺苷当量。\n- GMP到GDP：鸟苷酸激酶将ATP转化为ADP，计为$1$个三磷酸腺苷当量。\n- GDP到GTP：核苷二磷酸激酶将ATP转化为ADP，计为$1$个三磷酸腺苷当量。\n\n将每次ATP到ADP的转化计为$1$个三磷酸腺苷当量，每次ATP到AMP的转化计为$2$个三磷酸腺苷当量。忽略任何来自无机焦磷酸酶的能量贡献以及诸如四氢叶酸或$\\text{NAD}^+$等辅因子的再生成本。在这些假设下，从R5P开始合成一个GTP分子需要的三磷酸腺苷当量总数是多少？请以单个整数形式提供您的答案，不带单位。", "solution": "对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- **过程：** 从5-磷酸核糖（R5P）从头合成鸟苷三磷酸（GTP）。\n- **途径：** R5P $\\rightarrow$ PRPP $\\rightarrow$ IMP $\\rightarrow$ GMP $\\rightarrow$ GDP $\\rightarrow$ GTP。\n- **起始材料：** $1$个5-磷酸核糖（R5P）分子。\n- **最终产物：** $1$个鸟苷三磷酸（GTP）分子。\n- **成本定义：**\n    - 三磷酸腺苷（ATP）到二磷酸腺苷（ADP）的转化：$1$个ATP当量。\n    - ATP到一磷酸腺苷（AMP）的转化：$2$个ATP当量。\n- **具体步骤成本：**\n    - **R5P到PRPP：** $1$个反应（PRPP合成酶），将ATP转化为AMP，成本为$2$个ATP当量。\n    - **PRPP到IMP：** $5$个不同的酶促步骤（GAR合成酶、FGAM合成酶、AIR合成酶、N$5$-CAIR合成酶、SAICAR合成酶），每个步骤将ATP转化为ADP，成本为每个步骤$1$个ATP当量。\n    - **IMP到GMP：** $1$个反应（GMP合成酶），将ATP转化为AMP，成本为$2$个ATP当量。另一个步骤（IMPDH）没有ATP成本。\n    - **GMP到GDP：** $1$个反应（鸟苷酸激酶），将ATP转化为ADP，成本为$1$个ATP当量。\n    - **GDP到GTP：** $1$个反应（核苷二磷酸激酶），将ATP转化为ADP，成本为$1$个ATP当量。\n- **排除项：** 忽略无机焦磷酸酶的能量贡献和辅因子（例如$\\text{NAD}^+$）的再生成本。\n\n**第2步：使用提取的已知条件进行验证**\n根据既定标准对问题进行评估。\n- **科学依据：** 问题描述了经典的嘌呤从头生物合成途径，这是生物化学和计算生物学中的一个基本主题。指定的酶、中间产物以及计算ATP当量（其中ATP $\\rightarrow$ AMP因AMP随后磷酸化为ADP而耗费$2$个当量）的惯例都具有科学合理性和标准性。\n- **问题明确：** 问题提供了一个明确的起点（R5P）、一个明确的终点（GTP），以及所有相关耗能步骤及其具体成本的详尽列表。问题清晰无歧义，要求计算一个可计算的单一数值。\n- **客观性：** 问题使用精确、客观的科学术语进行陈述。没有主观或比喻性元素。\n\n**第3步：结论与行动**\n该问题被判定为 **有效**。它科学合理、问题明确、客观，并包含获得唯一解所需的所有必要信息。可以进行求解过程。\n\n以三磷酸腺苷（ATP）当量计算的总能量成本是指定生物合成途径中每个阶段成本的总和。设 $C_{total}$ 为ATP当量的总数。我们可以将其表示为途径中每个部分成本的总和：\n\n$$\nC_{total} = C_{R5P \\rightarrow PRPP} + C_{PRPP \\rightarrow IMP} + C_{IMP \\rightarrow GMP} + C_{GMP \\rightarrow GDP} + C_{GDP \\rightarrow GTP}\n$$\n\n现在我们根据所提供的数据计算每个部分的成本。\n\n1.  **将R5P转化为PRPP的成本 ($C_{R5P \\rightarrow PRPP}$):**\n    从5-磷酸核糖（R5P）合成磷酸核糖焦磷酸（PRPP）由PRPP合成酶催化。该反应将一个ATP分子转化为AMP。根据问题陈述，这需要消耗$2$个ATP当量。\n    $$\n    C_{R5P \\rightarrow PRPP} = 2\n    $$\n\n2.  **将PRPP转化为IMP的成本 ($C_{PRPP \\rightarrow IMP}$):**\n    该途径的这一部分涉及几个步骤。问题明确列出了五个需要ATP的酶促反应，每个反应都将ATP转化为ADP。每次这样的转化消耗$1$个ATP当量。\n    - GAR合成酶：$1$个ATP当量。\n    - FGAM合成酶：$1$个ATP当量。\n    - AIR合成酶：$1$个ATP当量。\n    - N$5$-CAIR合成酶：$1$个ATP当量。\n    - SAICAR合成酶：$1$个ATP当量。\n    该部分的总成本是这些单独成本的总和。\n    $$\n    C_{PRPP \\rightarrow IMP} = 1 + 1 + 1 + 1 + 1 = 5\n    $$\n\n3.  **将IMP转化为GMP的成本 ($C_{IMP \\rightarrow GMP}$):**\n    此转化涉及两个酶促步骤。第一步由次黄苷酸脱氢酶催化，使用$\\text{NAD}^+$，没有相关的ATP成本。第二步由鸟苷酸合成酶催化，将ATP转化为AMP。这被定义为消耗$2$个ATP当量。\n    $$\n    C_{IMP \\rightarrow GMP} = 2\n    $$\n\n4.  **将GMP转化为GDP的成本 ($C_{GMP \\rightarrow GDP}$):**\n    此磷酸化反应由鸟苷酸激酶催化。该反应将一个ATP分子转化为ADP，消耗$1$个ATP当量。\n    $$\n    C_{GMP \\rightarrow GDP} = 1\n    $$\n\n5.  **将GDP转化为GTP的成本 ($C_{GDP \\rightarrow GTP}$):**\n    最后的磷酸化反应由核苷二磷酸激酶催化。该反应同样将一个ATP分子转化为ADP，消耗$1$个ATP当量。\n    $$\n    C_{GDP \\rightarrow GTP} = 1\n    $$\n\n最后，我们将所有部分的成本相加，得到总成本 $C_{total}$：\n$$\nC_{total} = 2 + 5 + 2 + 1 + 1\n$$\n$$\nC_{total} = 11\n$$\n因此，在给定的假设下，从R5P合成一个GTP分子总共需要$11$个ATP当量。", "answer": "$$\\boxed{11}$$", "id": "2375344"}, {"introduction": "除了简单的核算，我们还可以使用通路数据库来模拟物质在代谢过程中的动态流动。一项关键技术是原子追踪，它跟踪单个原子在一系列生物化学反应中被重排的过程。本练习将让您把糖酵解通路的逻辑转化为一个计算脚本，以追踪一个特定的碳原子从葡萄糖到丙酮酸的命运，这提供了一个具体的例子，说明抽象的通路规则如何能够模拟具体的生化转变。[@problem_id:2375342]", "problem": "您需要实现一个完整、可运行的程序，该程序根据京都基因与基因组百科全书 (Kyoto Encyclopedia of Genes and Genomes, KEGG) 中整理的糖酵解途径核心反应，执行单原子追踪。目标是利用第一性原理的原子守恒和已确立的反应特异性原子映射，追踪一个标记的碳原子从葡萄糖到丙酮酸的过程，并计算该标记原子在丙酮酸中的最终碳索引。\n\n基本原理：\n- 生物化学反应中的原子守恒定律指出，原子既不被创造也不被消灭；它们的身份可以通过反应进行追踪。\n- 糖酵解将一个含有$6$个碳原子的葡萄糖分子转化为两个各含有$3$个碳原子的丙酮酸分子。\n- 早期的磷酸化和异构化步骤（葡萄糖 $\\to$ 6-磷酸葡萄糖 $\\to$ 6-磷酸果糖 $\\to$ 1,6-二磷酸果糖）不会破坏碳骨架；因此，一个随每个碳原子移动的骨架索引在这些步骤中得以保留。\n- 醛缩酶 (Aldolase) 在碳$3$和碳$4$之间裂解1,6-二磷酸果糖，形成两个丙糖：磷酸二羟丙酮 (DHAP) 接收对应于骨架位置$1$到$3$的片段，而3-磷酸甘油醛 (GAP) 接收对应于骨架位置$4$到$6$的片段。\n- 磷酸丙糖异构酶 (Triose Phosphate Isomerase, TPI) 通过交换末端碳原子，同时保持中心碳原子不变，将DHAP转化为GAP，即这个三碳片段内的碳映射为 $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$。\n- 糖酵解的后半部分（GAP $\\to$ 1,3-二磷酸甘油酸 $\\to$ 3-磷酸甘油酸 $\\to$ 2-磷酸甘油酸 $\\to$ 磷酸烯醇式丙酮酸 $\\to$ 丙酮酸）保留了三碳骨架的顺序，因此从GAP碳索引到丙酮酸碳索引的映射是恒等映射：$1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$。\n\n表示方法：\n- 用从$1$到$6$的有序索引表示葡萄糖碳骨架，这些索引随每个碳原子在途径中移动。\n- 对于醛缩酶裂解，将两个丙糖表示为独立的有序片段：DHAP接收索引$1,2,3$（来自葡萄糖位置$1,2,3$），GAP接收索引$1,2,3$（来自葡萄糖位置$4,5,6$）。\n- 将TPI映射 $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$ 应用于DHAP片段，将其转换为GAP坐标。\n- 应用从GAP到丙酮酸的恒等映射：$1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$。\n\n计算任务：\n- 实现一个函数，输入一个整数 $g$ 代表葡萄糖中标记碳的索引 ($g \\in \\{1,2,3,4,5,6\\}$)，并返回标记原子在其丙糖分支产生的丙酮酸中的最终整数碳索引 $p \\in \\{1,2,3\\}$。如果 $g$ 不在有效范围内，则返回$-1$。\n- 映射必须通过组合上述分步映射来计算；不要在代码中未展示中间逻辑的情况下硬编码最终配对。\n- 此问题的输出不涉及物理单位。\n- 此问题不涉及角度。\n- 此问题不涉及百分比。\n\n测试套件：\n您的程序必须在以下标记葡萄糖位置上评估该函数：\n- 覆盖所有有效位置的正常路径：$[1,2,3,4,5,6]$。\n- 边界情况：无效标签 $0$ 和 $7$。\n\n答案规范：\n- 对于每个输入标签 $g$，输出一个单一整数结果：$p \\in \\{1,2,3\\}$，如果无效则为-1。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如，$\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$），结果顺序与完整测试套件 $[1,2,3,4,5,6,0,7]$ 的输入顺序相同。", "solution": "对问题陈述进行严格验证。\n\n步骤1：提取已知条件\n- **目标**：实现一个程序，用于根据KEGG整理的糖酵解核心反应（葡萄糖到丙酮酸），进行单原子追踪。\n- **基本原理**：\n    - 原子守恒。\n    - 糖酵解将一个$6$碳葡萄糖转化为两个$3$碳丙酮酸分子。\n    - 葡萄糖骨架在1,6-二磷酸果糖 (FBP) 之前保持完整。\n    - 醛缩酶在FBP的碳$3$和碳$4$之间进行裂解。\n    - 磷酸二羟丙酮 (DHAP) 由FBP的碳$1, 2, 3$形成。\n    - 3-磷酸甘油醛 (GAP) 由FBP的碳$4, 5, 6$形成。\n    - 磷酸丙糖异构酶 (TPI) 将DHAP转化为GAP，其在丙糖片段内的特定碳映射为：$1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$。\n    - 糖酵解的后半部分（GAP到丙酮酸）保留了碳骨架顺序，为恒等映射：$1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$。\n- **表示方法**：\n    - 葡萄糖碳的索引为$1$到$6$。\n    - DHAP片段从葡萄糖位置$1, 2, 3$获得局部索引$1, 2, 3$。\n    - GAP片段从葡萄糖位置$4, 5, 6$获得局部索引$1, 2, 3$。\n    - TPI映射应用于源自DHAP的片段。\n    - GAP到丙酮酸的映射是恒等映射。\n- **计算任务**：\n    - 编写一个函数，输入一个葡萄糖碳索引 $g \\in \\{1, 2, 3, 4, 5, 6\\}$，返回相应的丙酮酸碳索引 $p \\in \\{1, 2, 3\\}$。\n    - 如果 $g$ 超出有效范围，则返回$-1$。\n    - 实现必须组合分步映射。\n- **测试套件**：\n    - 输入标签：$[1, 2, 3, 4, 5, 6, 0, 7]$。\n- **输出格式**：\n    - 一行，包含一个用方括号括起来的逗号分隔的整数结果列表。\n\n步骤2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据**：该问题描述了一个简化但正确的糖酵解中碳原子命运的模型。醛缩酶的裂解位点和磷酸丙糖异构酶的作用是生物化学中的标准概念。所提供的原子映射是该代谢途径公认的教科书表示法。该问题牢固地建立在科学原理之上。\n- **良构性**：该问题是良构的。它有明确定义的输入集 ($g \\in \\mathbb{Z}$)、指定的转换逻辑和精确定义的输出格式 ($p \\in \\{1, 2, 3\\}$ 或 $-1$)。对于每个有效输入 $g$，所描述的转换序列都会产生一个唯一且有意义的结果。\n- **客观性**：该问题使用客观、技术性的语言表述。没有主观或基于意见的陈述。原子映射的规则是明确且无歧义的。\n\n该问题不存在任何无效性缺陷。它在科学上是合理的、可形式化的、完整的、可行的且结构良好。\n\n步骤3：结论与行动\n该问题是**有效的**。将构建一个解决方案。\n\n解决方案推导\n任务是实现一个函数，我们称之为 $f(g)$，它将一个初始的葡萄糖碳索引 $g$ 映射到一个最终的丙酮酸碳索引 $p$。有效输入的域是 $g \\in \\{1, 2, 3, 4, 5, 6\\}$。对于此集合之外的任何 $g$，函数必须返回-1。\n\n该途径由不同的阶段组成，每个阶段对应一个数学映射。我们将组合这些映射来找到最终结果。\n\n1.  **输入验证**：第一步是检查输入 $g$ 是否有效。\n    $$\n    f(g) = -1 \\quad \\text{if } g \\notin \\{1, 2, 3, 4, 5, 6\\}\n    $$\n\n2.  **醛缩酶裂解**：葡萄糖（$6$C）的衍生物，1,6-二磷酸果糖，被裂解成两个磷酸丙糖（$3$C）。标记碳的去向取决于其初始位置。\n    - 如果 $g \\in \\{1, 2, 3\\}$，该原子成为磷酸二羟丙酮（DHAP）分子的一部分。在这个3碳片段内的局部索引被保留。我们将局部索引表示为 $i_{local}$。\n      $$\n      i_{local} = g \\quad \\text{for } g \\in \\{1, 2, 3\\}\n      $$\n    - 如果 $g \\in \\{4, 5, 6\\}$，该原子成为3-磷酸甘油醛（GAP）分子的一部分。局部索引是相对于该片段的起始（葡萄糖的碳$4$）。\n      $$\n      i_{local} = g - 3 \\quad \\text{for } g \\in \\{4, 5, 6\\}\n      $$\n\n3.  **磷酸丙糖异构酶（TPI）作用**：所有进入糖酵解后半部分的碳都必须以GAP的形式存在。由葡萄糖的碳$1,2,3$形成的DHAP被异构化为GAP。此步骤涉及碳的重新排序。直接由葡萄糖的碳$4,5,6$形成的GAP无需异构化即可继续进行反应。我们将统一的GAP池中的索引定义为 $i_{GAP}$。\n    - 对于源自DHAP的原子（$g \\in \\{1, 2, 3\\}$），我们将其局部索引 $i_{local}$ 应用TPI映射 $M_{TPI}$：\n      $$\n      M_{TPI}(i) =\n      \\begin{cases}\n        3  \\text{if } i = 1 \\\\\n        2  \\text{if } i = 2 \\\\\n        1  \\text{if } i = 3\n      \\end{cases}\n      $$\n      因此，对于 $g \\in \\{1, 2, 3\\}$，在生成的GAP分子中的索引是：\n      $$\n      i_{GAP} = M_{TPI}(i_{local}) = M_{TPI}(g)\n      $$\n    - 对于源自第一个GAP分子的原子（$g \\in \\{4, 5, 6\\}$），没有异构化。索引保持不变。\n      $$\n      i_{GAP} = i_{local} = g - 3\n      $$\n\n4.  **糖酵解后半段（GAP到丙酮酸）**：从GAP到丙酮酸的最终反应序列保留了碳骨架的顺序。这对应于一个恒等映射，$M_{final}(i) = i$。因此，最终的丙酮酸碳索引 $p$ 等于索引 $i_{GAP}$。\n    $$\n    p = i_{GAP}\n    $$\n\n通过组合这些步骤，我们可以构建完整的函数 $f(g)$：\n- **情况1**：$g \\in \\{1, 2, 3\\}$（DHAP分支）\n  $p = f(g) = M_{TPI}(g)$。这得出：\n  - $f(1) = M_{TPI}(1) = 3$\n  - $f(2) = M_{TPI}(2) = 2$\n  - $f(3) = M_{TPI}(3) = 1$\n- **情况2**：$g \\in \\{4, 5, 6\\}$（GAP分支）\n  $p = f(g) = g - 3$。这得出：\n  - $f(4) = 4 - 3 = 1$\n  - $f(5) = 5 - 3 = 2$\n  - $f(6) = 6 - 3 = 3$\n\n实现将遵循这种基于情况的逻辑，它直接反映了所描述的生化途径的分支特性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed or permitted.\n\ndef solve():\n    \"\"\"\n    Solves the glycolysis carbon tracing problem for a given test suite.\n    \"\"\"\n\n    def trace_carbon_atom(g: int) -> int:\n        \"\"\"\n        Traces a labeled carbon atom from glucose to pyruvate.\n\n        This function implements the stepwise atom mapping for the core glycolysis pathway\n        as described in the problem statement. The logic explicitly follows the fate\n        of the carbon atom through the key reaction steps.\n\n        Args:\n            g: The initial 1-based index of the labeled carbon atom in glucose.\n\n        Returns:\n            The final 1-based index of the labeled atom in a pyruvate molecule,\n            or -1 if the input glucose index is invalid.\n        \"\"\"\n        # Step 1: Input validation. Glucose has 6 carbons, indexed 1 through 6.\n        if not (1 <= g <= 6):\n            return -1\n\n        # Step 2: Aldolase cleavage of Fructose-1,6-bisphosphate.\n        # This step determines which triose phosphate receives the labeled carbon.\n        if 1 <= g <= 3:\n            # Carbons 1, 2, 3 of glucose form Dihydroxyacetone Phosphate (DHAP).\n            # The local index within the 3-carbon DHAP fragment is the same as g.\n            # E.g., glucose carbon 1 becomes DHAP carbon 1.\n            dhap_local_index = g\n\n            # Step 3: Triose Phosphate Isomerase (TPI) action on DHAP.\n            # DHAP is isomerized to Glyceraldehyde-3-Phosphate (GAP).\n            # The problem defines a specific atom mapping for this conversion:\n            # 1 -> 3, 2 -> 2, 3 -> 1.\n            tpi_map = {1: 3, 2: 2, 3: 1}\n            gap_index = tpi_map[dhap_local_index]\n\n        else:  # This branch handles g in {4, 5, 6}\n            # Carbons 4, 5, 6 of glucose form Glyceraldehyde-3-Phosphate (GAP) directly.\n            # The local index is relative to the start of this fragment (glucose carbon 4).\n            # E.g., glucose carbon 4 becomes GAP carbon 1.\n            gap_local_index = g - 3\n            gap_index = gap_local_index\n\n        # Step 4: Lower Glycolysis (GAP to Pyruvate).\n        # The carbon backbone is preserved from GAP to pyruvate.\n        # This is an identity mapping: 1 -> 1, 2 -> 2, 3 -> 3.\n        pyruvate_index = gap_index\n\n        return pyruvate_index\n\n    # Define the test cases from the problem statement.\n    # Happy path: [1, 2, 3, 4, 5, 6]\n    # Edge cases: [0, 7]\n    test_cases = [1, 2, 3, 4, 5, 6, 0, 7]\n\n    # Calculate the results for all test cases.\n    results = []\n    for glucose_label in test_cases:\n        result = trace_carbon_atom(glucose_label)\n        results.append(result)\n\n    # Format the results into the required single-line string format.\n    # Example: [3,2,1,1,2,3,-1,-1]\n    # np.array is used to satisfy the problem's library requirements, although a list would suffice.\n    result_array = np.array(results, dtype=int)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, result_array))}]\")\n\nsolve()\n```", "id": "2375342"}, {"introduction": "生物通路并非孤立运作，而是形成了一个巨大且相互连接的网络。通过将此系统表示为图，我们可以应用强大的分析方法来揭示其系统性属性。本练习介绍了酶“关键节点”（chokepoint）的概念——一个移除后会导致网络分裂的关键节点——并挑战您通过计算来识别这些节点，这项技能在药物靶点识别和代谢工程等领域至关重要。[@problem_id:2375339]", "problem": "给定一个代谢超通路的形式化抽象，该抽象与京都基因与基因组百科全书（KEGG）和Reactome通路数据库（Reactome）中捕获通路的方式一致。设该网络为一个有向、酶标记的反应图 $G = (V,R)$，其中 $V = \\{1,2,\\dots,N\\}$ 是一个有限的代谢物集合，而 $R \\subseteq V \\times V \\times \\mathbb{Z}$ 是一个有限的有向反应集合。每个反应都是一个三元组 $(u,v,e)$，表示由酶标识符 $e \\in \\mathbb{Z}$ 催化的从代谢物 $u$ 到代谢物 $v$ 的有向转化。为了分析连通性，我们考虑其底层的无向简单图 $G^\\ast = (V,E^\\ast)$，其定义如下：对于任意 $u \\ne v$ 的无序对 $\\{u,v\\} \\subseteq V$，无向边 $\\{u,v\\}$ 属于 $E^\\ast$ 当且仅当存在至少一个反应 $(u,v,e) \\in R$ 或 $(v,u,e) \\in R$。在 $E^\\ast$ 中，相同代谢物之间的多个反应和不同方向的反应被合并为一条无向边；然而，每条无向边 $\\{u,v\\}$ 都携带一个多重集，该多重集包含 $R$ 中所有连接 $u$ 和 $v$ 的有向反应上的酶标识符。\n\n对于任意单个酶标识符 $x \\in \\mathbb{Z}$，定义移除该酶后的反应集 $R^{(-x)} = \\{(u,v,e) \\in R \\mid e \\ne x\\}$ 以及相应的底层无向简单图 $G^{\\ast(-x)} = (V,E^{\\ast(-x)})$，其中 $\\{u,v\\} \\in E^{\\ast(-x)}$ 当且仅当在 $R^{(-x)}$ 中存在至少一个连接 $u$ 和 $v$ 的反应。令 $C(H)$ 表示无向图 $H$ 的连通分量数量。如果 $C(G^{\\ast(-x)}) > C(G^\\ast)$，则称酶标识符 $x$ 为一个瓶颈酶（chokepoint）。\n\n任务：对于下方的每个测试用例，计算瓶颈酶的集合，并将其作为一个严格递增的整数列表输出。您的程序必须将所有测试用例的结果汇总到单行输出中，该输出包含一个由方括号括起来的逗号分隔列表（例如，$[ [a_1,a_2], [\\,], [b_1] ]$）。本问题不涉及物理单位。\n\n测试套件（每个反应是一个三元组 $(u,v,e)$，其中 $u,v \\in \\{1,\\dots,N\\}$ 且酶标识符为 $e \\in \\mathbb{Z}$）：\n\n- 测试用例 1：\n  - $N = 5$。\n  - $R = \\{(1,2,10), (2,3,20), (3,2,21), (3,4,30), (4,5,40)\\}$.\n\n- 测试用例 2：\n  - $N = 4$。\n  - $R = \\{(1,2,1), (3,4,2)\\}$.\n\n- 测试用例 3：\n  - $N = 4$。\n  - $R = \\{(1,2,5), (2,3,6), (3,1,7), (1,4,8)\\}$.\n\n- 测试用例 4：\n  - $N = 6$。\n  - $R = \\{(1,2,11), (2,3,12), (3,1,13), (3,4,99), (5,6,14)\\}$.\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，第 $i$ 个元素是测试用例 $i$ 的瓶颈酶标识符列表，按严格递增顺序排序。例如，一个有效的输出可能看起来像 $[[x_1,x_2],[y_1],[\\,],[z_1,z_2]]$。", "solution": "所提出的问题是计算网络分析领域一个定义明确的练习，其基础是应用于生物信息学的图论形式化方法。该问题科学严谨、客观，并包含了获得唯一解所需的所有信息。我们将着手解决此问题。\n\n核心任务是识别给定代谢网络中的“瓶颈”酶。其定义是形式化且精确的：如果从网络中移除某个酶 $x$ 会导致其代谢网络的底层无向图表示中连通分量的数量增加，那么该酶 $x$ 就是一个瓶颈酶。这本质上是一个识别关键边或边集的问题，这些边或边集如同桥梁一样，连接着网络中原本不相连的部分。底层图中的一条边 $\\{u,v\\}$ 由催化代谢物 $u$ 和 $v$ 之间所有反应的酶的多重集所维持。只有当酶 $x$ 是负责它们之间所有反应的*唯一*酶时，移除该酶才会切断 $u$ 和 $v$ 之间的连接。\n\n解决此问题的算法是演绎和系统性的，包含以下步骤：\n\n1.  **建立基线连通性**：首先，我们必须描述网络的初始状态。我们构建完整的底层无向图，记为 $G^\\ast = (V, E^\\ast)$。顶点集 $V$ 已给出，为 $\\{1, 2, \\dots, N\\}$。如果集合 $R$ 中存在至少一个在任一方向上连接代谢物 $u$ 和 $v$ 的反应，则 $E^\\ast$ 中存在一条无向边 $\\{u,v\\}$。构建完 $G^\\ast$ 后，我们计算其连通分量的数量 $C(G^\\ast)$。该值作为我们进行连通性比较的基线参考。连通分量的计算是图论中的一个标准程序，通常使用图遍历算法（如深度优先搜索（DFS）或广度优先搜索（BFS））来执行。\n\n2.  **迭代扰动与评估**：我们必须逐个测试每种酶的关键性。我们首先从给定的反应集 $R$ 中识别出所有唯一的酶标识符，构成集合 $\\mathcal{E}$。对于每个唯一的酶 $x \\in \\mathcal{E}$，我们模拟移除它的过程。\n\n    a.  **构建扰动图**：我们定义一个新的反应集 $R^{(-x)}$，它包含 $R$ 中除由酶 $x$ 催化的反应之外的所有反应。基于这个简化的反应集，我们构建一个新的底层无向图 $G^{\\ast(-x)} = (V, E^{\\ast(-x)})$。当且仅当 $R^{(-x)}$ 中仍然存在至少一个连接 $u$ 和 $v$ 的反应时，$E^{\\ast(-x)}$ 中才存在边 $\\{u,v\\}$。\n\n    b.  **计算扰动后连通性**：使用相同的连通分量计数算法，我们计算扰动图中的连通分量数量 $C(G^{\\ast(-x)})$。\n\n    c.  **识别瓶颈酶**：应用瓶颈酶的定义条件。如果扰动图中的分量数量严格大于原始图中的分量数量，即 $C(G^{\\ast(-x)}) > C(G^\\ast)$，则酶 $x$ 被归类为瓶颈酶。\n\n3.  **汇总和报告结果**：将上一步中识别出的瓶颈酶为每个测试用例收集起来。根据问题规范，这组酶标识符必须以严格递增的顺序排列并以列表形式呈现。\n\n在实现方面，图可以使用邻接表来表示。然而，考虑到指定的计算环境，更直接的方法是构建图的稀疏矩阵表示，并利用 `scipy.sparse.csgraph.connected_components` 函数。该函数能高效地确定由邻接矩阵表示的图的连通分量数量，从而简化了步骤1和2b的实现。整体逻辑保持不变。对于每个测试用例，我们首先计算完整图的连通分量数，然后遍历每一种唯一的酶，重新计算缺少该酶催化反应的图的连通分量数，并通过比较这些数量来识别瓶颈酶。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Solves the chokepoint enzyme identification problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"N\": 5,\n            \"R\": [(1, 2, 10), (2, 3, 20), (3, 2, 21), (3, 4, 30), (4, 5, 40)]\n        },\n        # Test case 2\n        {\n            \"N\": 4,\n            \"R\": [(1, 2, 1), (3, 4, 2)]\n        },\n        # Test case 3\n        {\n            \"N\": 4,\n            \"R\": [(1, 2, 5), (2, 3, 6), (3, 1, 7), (1, 4, 8)]\n        },\n        # Test case 4\n        {\n            \"N\": 6,\n            \"R\": [(1, 2, 11), (2, 3, 12), (3, 1, 13), (3, 4, 99), (5, 6, 14)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        R = case[\"R\"]\n        chokepoints = find_chokepoints(N, R)\n        results.append(chokepoints)\n\n    # The final print statement must follow the specified format exactly.\n    # The str() representation of a list in Python matches the required format\n    # for the inner lists, including spaces, e.g., '[10, 30, 40]'.\n    # The join function concatenates these string representations with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef count_components(num_nodes, reactions):\n    \"\"\"\n    Counts the number of connected components in the undirected graph\n    derived from a set of reactions.\n    \n    Args:\n        num_nodes (int): The number of metabolites (nodes) in the graph, N.\n        reactions (list): A list of reaction triples (u, v, e).\n\n    Returns:\n        int: The number of connected components.\n    \"\"\"\n    if not reactions:\n        return num_nodes\n\n    row_indices = []\n    col_indices = []\n\n    for u, v, _ in reactions:\n        # Using 0-based indexing for matrix\n        row_indices.append(u - 1)\n        col_indices.append(v - 1)\n\n    # An undirected graph's adjacency matrix is symmetric.\n    # We add edges in both directions.\n    full_row = row_indices + col_indices\n    full_col = col_indices + row_indices\n    data = np.ones(len(full_row), dtype=int)\n\n    # Create a compressed sparse row (CSR) matrix representation of the graph.\n    graph_matrix = csr_matrix((data, (full_row, full_col)), shape=(num_nodes, num_nodes))\n    \n    # Use SciPy to find connected components.\n    n_components, _ = connected_components(csgraph=graph_matrix, directed=False, return_labels=True)\n    \n    return n_components\n\ndef find_chokepoints(N, R):\n    \"\"\"\n    Identifies chokepoint enzymes for a given metabolic network.\n    \n    Args:\n        N (int): The number of metabolites.\n        R (list): The list of reactions.\n\n    Returns:\n        list: A sorted list of chokepoint enzyme identifiers.\n    \"\"\"\n    if not R:\n        return []\n\n    # Find the set of all unique enzyme identifiers\n    unique_enzymes = sorted(list(set(e for _, _, e in R)))\n\n    # Calculate the number of connected components in the original graph G*\n    base_components = count_components(N, R)\n\n    chokepoints = []\n    for enzyme_to_remove in unique_enzymes:\n        # Construct the enzyme-removed reaction set R^(-x)\n        r_removed = [(u, v, e) for u, v, e in R if e != enzyme_to_remove]\n        \n        # Calculate components in the perturbed graph G*(-x)\n        num_components_removed = count_components(N, r_removed)\n        \n        # Check the chokepoint condition\n        if num_components_removed > base_components:\n            chokepoints.append(enzyme_to_remove)\n            \n    return chokepoints\n\n# Execute the main function\nsolve()\n```", "id": "2375339"}]}