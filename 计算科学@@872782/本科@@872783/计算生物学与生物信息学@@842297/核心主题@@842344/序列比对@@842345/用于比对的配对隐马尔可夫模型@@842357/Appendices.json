{"hands_on_practices": [{"introduction": "为了真正掌握配对隐马尔可夫模型（Pair HMM）的工作原理，亲自动手处理其底层的概率计算是至关重要的。第一个练习 [@problem_id:2411573] 将引导你对一个明确定义的小型模型进行具体计算。通过手动枚举所有可能的比对路径及其相关概率，你将计算出插入事件的期望数量，从而为理解模型如何权衡不同的比对方案建立核心直觉。", "problem": "考虑一个用于全局比对的配对隐马尔可夫模型 (pair HMM)，该模型有五个状态：一个开始状态 $B$、一个匹配状态 $M$、两个插入状态 $I_{x}$ 和 $I_{y}$（分别从序列 $X$ 或 $Y$ 发出一个符号，并与另一个序列中的一个空位对齐），以及一个结束状态 $E$。字母表为 $\\{A,C\\}$。只允许如下所列的转移，其概率已给出；所有其他转移的概率为 $0$。\n\n- 从 $B$ 出发：$B \\to M$ 的概率为 $0.7$，$B \\to I_{x}$ 的概率为 $0.25$，$B \\to I_{y}$ 的概率为 $0.05$。\n- 从 $M$ 出发：$M \\to M$ 的概率为 $0.4$，$M \\to I_{x}$ 的概率为 $0.3$，$M \\to I_{y}$ 的概率为 $0.1$，$M \\to E$ 的概率为 $0.2$。\n- 从 $I_{x}$ 出发：$I_{x} \\to I_{x}$ 的概率为 $0.5$，$I_{x} \\to M$ 的概率为 $0.25$，$I_{x} \\to I_{y}$ 的概率为 $0.05$，$I_{x} \\to E$ 的概率为 $0.2$。\n- 从 $I_{y}$ 出发：$I_{y} \\to I_{y}$ 的概率为 $0.5$，$I_{y} \\to M$ 的概率为 $0.25$，$I_{y} \\to I_{x}$ 的概率为 $0.05$，$I_{y} \\to E$ 的概率为 $0.2$。\n\n发射概率如下。在匹配状态 $M$ 中，以概率 $P_{M}(A,A)=0.5$、$P_{M}(A,C)=0.1$、$P_{M}(C,A)=0.2$、$P_{M}(C,C)=0.2$ 发射一对符号 $(x,y) \\in \\{A,C\\} \\times \\{A,C\\}$。\n在插入状态 $I_{x}$ 中，以 $P_{I_{x}}(A)=0.6$、$P_{I_{x}}(C)=0.4$ 的概率发出来自 $\\{A,C\\}$ 的单个符号 $x$。\n在插入状态 $I_{y}$ 中，以 $P_{I_{y}}(A)=0.7$、$P_{I_{y}}(C)=0.3$ 的概率发出来自 $\\{A,C\\}$ 的单个符号 $y$。\n\n给定两个观测序列：$X=AC$ 和 $Y=A$。一条状态路径从 $B$ 开始，根据状态发射及其消耗规则（状态 $M$ 从每个序列消耗一个符号，状态 $I_{x}$ 仅从 $X$ 消耗一个符号，状态 $I_{y}$ 仅从 $Y$ 消耗一个符号）按顺序精确地发射给定的序列，然后转移到 $E$。对于一条状态路径，将“插入数”定义为在插入状态下产生的发射总数，即路径上来自 $I_{x}$ 的发射数加上来自 $I_{y}$ 的发射数。\n\n计算在给定模型和观测序列的条件下，插入数的后验期望值，即在以发射 $X$ 和 $Y$ 为条件的所有有效状态路径的分布下，该计数的期望值。请以精确的最简分数形式给出你的答案。不要包含任何单位。", "solution": "该问题要求计算在给定一个特定的配对隐马尔可夫模型 (HMM) 的情况下，序列 $X=AC$ 和 $Y=A$ 比对的插入数的后验期望值。\n\n首先，我们将问题形式化。令 $\\Pi$ 为所有从开始状态 $B$ 开始、生成序列 $X$ 和 $Y$、并在结束状态 $E$ 终止的有效状态路径的集合。对于任何给定的路径 $\\pi \\in \\Pi$，令 $P(\\pi, X, Y)$ 为该路径和观测序列的联合概率。观测到序列的总概率为 $P(X, Y) = \\sum_{\\pi \\in \\Pi} P(\\pi, X, Y)$。\n令 $\\text{ins}(\\pi)$ 表示路径 $\\pi$ 的插入数，其定义为来自状态 $I_x$ 和 $I_y$ 的发射总数。插入数的后验期望值由下式给出：\n$$E[\\text{ins} | X, Y] = \\sum_{\\pi \\in \\Pi} \\text{ins}(\\pi) P(\\pi | X, Y) = \\frac{\\sum_{\\pi \\in \\Pi} \\text{ins}(\\pi) P(\\pi, X, Y)}{P(X, Y)}$$\n\n一条路径必须消耗 $X$ 和 $Y$ 的所有符号。令 $|X|=L_x=2$ 和 $|Y|=L_y=1$。令 $n_M$、$n_{I_x}$ 和 $n_{I_y}$ 分别为路径访问状态 $M$、$I_x$ 和 $I_y$ 的次数。状态 $M$ 从每个序列中消耗一个符号。状态 $I_x$ 从 $X$ 中消耗一个符号。状态 $I_y$ 从 $Y$ 中消耗一个符号。对于全局比对，我们必须有：\n$$n_M + n_{I_x} = L_x = 2$$\n$$n_M + n_{I_y} = L_y = 1$$\n由于 $n_M, n_{I_x}, n_{I_y}$ 必须是非负整数，我们可以确定它们的可能值。从第二个方程可知，$n_{I_y} = 1 - n_M$，这意味着 $n_M$ 只能是 $0$ 或 $1$。\n\n情况1：$n_M = 1$。\n这意味着 $n_{I_y} = 1 - 1 = 0$ 且 $n_{I_x} = 2 - 1 = 1$。\n此类中任何路径的插入数为 $\\text{ins} = n_{I_x} + n_{I_y} = 1 + 0 = 1$。\n\n情况2：$n_M = 0$。\n这意味着 $n_{I_y} = 1 - 0 = 1$ 且 $n_{I_x} = 2 - 0 = 2$。\n此类中任何路径的插入数为 $\\text{ins} = n_{I_x} + n_{I_y} = 2 + 1 = 3$。\n\n令 $P_1$ 为所有包含1次插入的路径的总概率，令 $P_3$ 为所有包含3次插入的路径的总概率。则 $P(X, Y) = P_1 + P_3$。期望值为：\n$$E[\\text{ins} | X, Y] = \\frac{1 \\cdot P_1 + 3 \\cdot P_3}{P_1 + P_3}$$\n\n我们现在为每种情况枚举所有可能的路径并计算它们的概率。令 $a_{kl}$ 为从状态 $k$ 到状态 $l$ 的转移概率，令 $P_k(\\cdot)$ 为状态 $k$ 的发射概率。序列为 $X=x_1x_2=AC$ 和 $Y=y_1=A$。\n\n计算 $P_1$（$n_M=1$, $n_{I_x}=1$, $n_{I_y}=0$ 的路径）：\n发射状态 $\\{M, I_x\\}$ 有两种可能的排列顺序：\n路径 1a：发射状态序列为 $(M, I_x)$。完整路径为 $B \\to M \\to I_x \\to E$。\n此路径必须从状态 $M$ 发射 $(x_1, y_1) = (A, A)$，并从状态 $I_x$ 发射 $x_2 = C$。\n概率为 $P_{1a} = a_{BM} \\cdot P_M(A,A) \\cdot a_{MI_x} \\cdot P_{I_x}(C) \\cdot a_{I_xE}$。\n$P_{1a} = (0.7) \\cdot (0.5) \\cdot (0.3) \\cdot (0.4) \\cdot (0.2) = \\frac{7}{10} \\cdot \\frac{1}{2} \\cdot \\frac{3}{10} \\cdot \\frac{2}{5} \\cdot \\frac{1}{5} = \\frac{42}{5000} = \\frac{21}{2500}$。\n\n路径 1b：发射状态序列为 $(I_x, M)$。完整路径为 $B \\to I_x \\to M \\to E$。\n此路径必须从状态 $I_x$ 发射 $x_1 = A$，并从状态 $M$ 发射 $(x_2, y_1) = (C, A)$。\n概率为 $P_{1b} = a_{BI_x} \\cdot P_{I_x}(A) \\cdot a_{I_xM} \\cdot P_M(C,A) \\cdot a_{ME}$。\n$P_{1b} = (0.25) \\cdot (0.6) \\cdot (0.25) \\cdot (0.2) \\cdot (0.2) = \\frac{1}{4} \\cdot \\frac{3}{5} \\cdot \\frac{1}{4} \\cdot \\frac{1}{5} \\cdot \\frac{1}{5} = \\frac{3}{2000}$。\n\n情况1的总概率：$P_1 = P_{1a} + P_{1b} = \\frac{21}{2500} + \\frac{3}{2000} = \\frac{84}{10000} + \\frac{15}{10000} = \\frac{99}{10000}$。\n\n计算 $P_3$（$n_M=0$, $n_{I_x}=2$, $n_{I_y}=1$ 的路径）：\n发射状态 $\\{I_x, I_x, I_y\\}$ 有 $\\binom{3}{1}=3$ 种可能的排列顺序。\n路径 2a：状态序列为 $(I_x, I_x, I_y)$。路径：$B \\to I_x \\to I_x \\to I_y \\to E$。\n发射：第一个 $I_x$ 发射 $x_1=A$，第二个 $I_x$ 发射 $x_2=C$，$I_y$ 发射 $y_1=A$。\n$P_{2a} = a_{BI_x} \\cdot P_{I_x}(A) \\cdot a_{I_xI_x} \\cdot P_{I_x}(C) \\cdot a_{I_xI_y} \\cdot P_{I_y}(A) \\cdot a_{I_yE}$。\n$P_{2a} = (0.25)(0.6)(0.5)(0.4)(0.05)(0.7)(0.2) = \\frac{1}{4}\\frac{3}{5}\\frac{1}{2}\\frac{2}{5}\\frac{1}{20}\\frac{7}{10}\\frac{1}{5} = \\frac{42}{200000} = \\frac{21}{100000}$。\n\n路径 2b：状态序列为 $(I_x, I_y, I_x)$。路径：$B \\to I_x \\to I_y \\to I_x \\to E$。\n发射：第一个 $I_x$ 发射 $x_1=A$，$I_y$ 发射 $y_1=A$，第二个 $I_x$ 发射 $x_2=C$。\n$P_{2b} = a_{BI_x} \\cdot P_{I_x}(A) \\cdot a_{I_xI_y} \\cdot P_{I_y}(A) \\cdot a_{I_yI_x} \\cdot P_{I_x}(C) \\cdot a_{I_xE}$。\n$P_{2b} = (0.25)(0.6)(0.05)(0.7)(0.05)(0.4)(0.2) = \\frac{1}{4}\\frac{3}{5}\\frac{1}{20}\\frac{7}{10}\\frac{1}{20}\\frac{2}{5}\\frac{1}{5} = \\frac{42}{2000000} = \\frac{21}{1000000}$。\n\n路径 2c：状态序列为 $(I_y, I_x, I_x)$。路径：$B \\to I_y \\to I_x \\to I_x \\to E$。\n发射：$I_y$ 发射 $y_1=A$，第一个 $I_x$ 发射 $x_1=A$，第二个 $I_x$ 发射 $x_2=C$。\n$P_{2c} = a_{BI_y} \\cdot P_{I_y}(A) \\cdot a_{I_yI_x} \\cdot P_{I_x}(A) \\cdot a_{I_xI_x} \\cdot P_{I_x}(C) \\cdot a_{I_xE}$。\n$P_{2c} = (0.05)(0.7)(0.05)(0.6)(0.5)(0.4)(0.2) = \\frac{1}{20}\\frac{7}{10}\\frac{1}{20}\\frac{3}{5}\\frac{1}{2}\\frac{2}{5}\\frac{1}{5} = \\frac{42}{1000000} = \\frac{21}{500000}$。\n\n情况2的总概率：$P_3 = P_{2a} + P_{2b} + P_{2c} = \\frac{21}{100000} + \\frac{21}{1000000} + \\frac{42}{1000000} = \\frac{210}{1000000} + \\frac{21}{1000000} + \\frac{42}{1000000} = \\frac{273}{1000000}$。\n\n现在我们可以计算期望值。\n分子：$1 \\cdot P_1 + 3 \\cdot P_3 = \\frac{99}{10000} + 3 \\cdot \\frac{273}{1000000} = \\frac{9900}{1000000} + \\frac{819}{1000000} = \\frac{10719}{1000000}$。\n分母：$P_1 + P_3 = \\frac{99}{10000} + \\frac{273}{1000000} = \\frac{9900}{1000000} + \\frac{273}{1000000} = \\frac{10173}{1000000}$。\n\n$E[\\text{ins} | X, Y] = \\frac{\\frac{10719}{1000000}}{\\frac{10173}{1000000}} = \\frac{10719}{10173}$。\n\n为了化简分数，我们求分子和分母的最大公约数。\n$10719$ 的各位数字之和为 $1+0+7+1+9 = 18$，因此它可以被 $9$ 整除。\n$10173$ 的各位数字之和为 $1+0+1+7+3 = 12$，因此它可以被 $3$ 整除，但不能被 $9$ 整除。\n我们可以将两者都除以 $3$。\n$10719 \\div 3 = 3573$。\n$10173 \\div 3 = 3391$。\n分数变为 $\\frac{3573}{3391}$。\n使用欧几里得算法计算 $\\text{gcd}(3573, 3391)$：\n$3573 = 1 \\cdot 3391 + 182$\n$3391 = 18 \\cdot 182 + 115$\n$182 = 1 \\cdot 115 + 67$\n$115 = 1 \\cdot 67 + 48$\n$67 = 1 \\cdot 48 + 19$\n$48 = 2 \\cdot 19 + 10$\n$19 = 1 \\cdot 10 + 9$\n$10 = 1 \\cdot 9 + 1$\n最大公约数是 $1$。因此，分数 $\\frac{3573}{3391}$ 是最简分数。", "answer": "$$\\boxed{\\frac{3573}{3391}}$$", "id": "2411573"}, {"introduction": "虽然分析一个预先定义好的隐马尔可夫模型很有用，但这些模型真正的威力在于从数据中学习其参数。这个实践练习 [@problem_id:2411616] 让你扮演算法设计者的角色，任务是实现 Baum-Welch 训练过程中的一个关键部分：最大化步骤（M-step）。你将看到从数据中收集的期望计数如何被用来更新模型的发射概率，从而直接了解隐马尔可夫模型是如何学习的。", "problem": "给定一个用于双序列比对的配对隐马尔可夫模型 (pair-HMM)，该模型包含三个状态：匹配状态 $M$、在 $x$ 中插入的状态 $I_x$ 以及在 $y$ 中插入的状态 $I_y$。其发射过程如下：状态 $M$ 发射一对符号，状态 $I_x$ 从序列 $x$ 中发射一个符号并与序列 $y$ 中的一个空位配对，状态 $I_y$ 在序列 $x$ 中发射一个空位并与序列 $y$ 中的一个符号配对。考虑脱氧核糖核酸 (DNA) 字母表 $\\Sigma=\\{A,C,G,T\\}$。\n\n在使用 Baum-Welch 方法对隐马尔可夫模型 (HMMs) 进行一次期望最大化 (EM) 迭代后，您将获得从状态 $I_x$ 发射 $\\Sigma$ 中每个符号的期望发射计数。将这些非负期望计数表示为 $n_A$、$n_C$、$n_G$ 和 $n_T$。您需要根据以下规范计算发射概率 $e_{I_x}(A)$ 的简化 M 步更新：\n\n- $I_x$ 在 $\\Sigma$ 上的更新后发射分布必须在满足约束条件 $\\sum_{b\\in\\Sigma} e_{I_x}(b)=1$ 和对所有 $b\\in\\Sigma$ 都有 $e_{I_x}(b)\\ge 0$ 的情况下，最大化期望完全数据对数似然。\n- 在 $n_A+n_C+n_G+n_T=0$ 的特殊情况下，将更新后的发射分布设置为在 $\\Sigma$ 上均匀分布。\n\n您的任务是编写一个程序，针对下面的每个测试用例，根据上述规范计算单个浮点数值 $e_{I_x}(A)$。每个输出必须四舍五入到小数点后恰好 $6$ 位。\n\n测试套件（每个测试用例是一个四元组 $(n_A,n_C,n_G,n_T)$）：\n\n- 用例 1：$(3,1,1,1)$。\n- 用例 2：$(0,0,0,0)$。\n- 用例 3：$(10,0,0,0)$。\n- 用例 4：$(0,5,5,0)$。\n- 用例 5：$\\left(1\\times 10^{-12},2\\times 10^{-12},3\\times 10^{-12},4\\times 10^{-12}\\right)$。\n\n您的程序必须生成单行输出，其中包含上述用例的结果，按顺序排列，形式为方括号内以逗号分隔的列表。例如，输出格式必须类似于 [r1,r2,r3,r4,r5]，其中每个 $r_i$ 是一个四舍五入到小数点后恰好 $6$ 位的浮点数。", "solution": "对问题陈述进行验证。\n\n**第 1 步：提取已知信息**\n- **模型**：一个配对隐马尔可夫模型 (pair-HMM)，包含三个状态：匹配状态 $M$、在 $x$ 中插入的状态 $I_x$ 以及在 $y$ 中插入的状态 $I_y$。\n- **字母表**：脱氧核糖核酸 (DNA) 字母表 $\\Sigma=\\{A,C,G,T\\}$。\n- **数据**：从状态 $I_x$ 发射 $\\Sigma$ 中每个符号的非负期望发射计数，表示为 $n_A, n_C, n_G, n_T$。\n- **目标**：计算发射概率 $e_{I_x}(A)$ 的 M 步更新。\n- **优化准则**：最大化期望完全数据对数似然。\n- **约束条件**：$\\sum_{b\\in\\Sigma} e_{I_x}(b)=1$ 和对所有 $b\\in\\Sigma$ 都有 $e_{I_x}(b)\\ge 0$。\n- **特殊条件**：如果 $n_A+n_C+n_G+n_T=0$，更新后的发射分布在 $\\Sigma$ 上是均匀的。\n- **测试用例**：\n    - 用例 1：$(3,1,1,1)$\n    - 用例 2：$(0,0,0,0)$\n    - 用例 3：$(10,0,0,0)$\n    - 用例 4：$(0,5,5,0)$\n    - 用例 5：$(1\\times 10^{-12},2\\times 10^{-12},3\\times 10^{-12},4\\times 10^{-12})$\n\n**第 2 步：使用提取的已知信息进行验证**\n- **科学依据**：问题描述了 Baum-Welch 算法的 M 步，这是一种用于隐马尔可夫模型的标准参数估计算法。这是计算生物学和机器学习中一个基础且成熟的程序。该问题具有科学合理性。\n- **良定性**：问题明确了清晰的目标（最大化一个已定义的函数）、一套完整的约束条件，并明确处理了总计数为零的边界情况。这种结构确保了对于任何有效输入，都存在唯一、稳定且有意义的解。\n- **客观性**：问题使用精确、无歧义的数学和科学术语进行陈述。它不含主观或推测性内容。\n\n**第 3 步：结论与行动**\n问题是有效的。这是一个生物信息学中的标准、良定问题。将提供解答。\n\nBaum-Welch 算法的 M 步更新模型参数，以最大化在 E 步中构建的期望完全数据对数似然。设当前参数集为 $\\theta^{(t)}$。目标是找到新的参数集 $\\theta$ 来最大化 $Q(\\theta|\\theta^{(t)})$，即完全数据对数似然的期望值。\n\n我们只关心状态 $I_x$ 的发射概率，表示为集合 $\\{e_{I_x}(b) | b \\in \\Sigma\\}$。期望完全数据对数似然函数中依赖于这些参数的部分由下式给出：\n$$ L(e_{I_x}) = \\sum_{b \\in \\Sigma} E[\\text{count of emissions of } b \\text{ from state } I_x] \\cdot \\log(e_{I_x}(b)) $$\n问题给出了从状态 $I_x$ 发射的期望计数为 $n_A, n_C, n_G, n_T$。因此，我们的目标是最大化以下函数：\n$$ L(e_{I_x}) = n_A \\log(e_{I_x}(A)) + n_C \\log(e_{I_x}(C)) + n_G \\log(e_{I_x}(G)) + n_T \\log(e_{I_x}(T)) $$\n该最大化受制于随机性约束：\n$$ \\sum_{b \\in \\Sigma} e_{I_x}(b) = 1 \\quad \\text{和} \\quad e_{I_x}(b) \\ge 0 \\;\\; \\forall b \\in \\Sigma $$\n这是一个标准的约束优化问题，可以使用拉格朗日乘数法求解。拉格朗日函数 $\\mathcal{L}$ 为：\n$$ \\mathcal{L}(e_{I_x}, \\lambda) = \\left( \\sum_{b \\in \\Sigma} n_b \\log(e_{I_x}(b)) \\right) - \\lambda \\left( \\left( \\sum_{b \\in \\Sigma} e_{I_x}(b) \\right) - 1 \\right) $$\n为求极值，我们计算 $\\mathcal{L}$ 对每个 $e_{I_x}(b')$（其中 $b' \\in \\Sigma$）的偏导数，并令其为零：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial e_{I_x}(b')} = \\frac{n_{b'}}{e_{I_x}(b')} - \\lambda = 0 $$\n这意味着 $n_{b'} = \\lambda e_{I_x}(b')$。对所有符号 $b' \\in \\Sigma$求和：\n$$ \\sum_{b' \\in \\Sigma} n_{b'} = \\sum_{b' \\in \\Sigma} \\lambda e_{I_x}(b') = \\lambda \\sum_{b' \\in \\Sigma} e_{I_x}(b') $$\n应用约束 $\\sum_{b' \\in \\Sigma} e_{I_x}(b') = 1$，我们求得拉格朗日乘数 $\\lambda$ 的值：\n$$ \\lambda = \\sum_{b' \\in \\Sigma} n_{b'} = n_A+n_C+n_G+n_T $$\n令 $N = n_A+n_C+n_G+n_T$ 为总期望计数。那么，任意符号 $b$ 的更新后发射概率为：\n$$ e_{I_x}(b) = \\frac{n_b}{\\lambda} = \\frac{n_b}{N} $$\n这一结果在 $N > 0$ 的条件下有效。需要计算的具体量是 $e_{I_x}(A)$：\n$$ e_{I_x}(A) = \\frac{n_A}{n_A + n_C + n_G + n_T} $$\n问题定义了 $N = 0$ 时的特殊情况。在这种情况下，更新后的发射分布在字母表 $\\Sigma = \\{A, C, G, T\\}$（其大小为 $|\\Sigma| = 4$）上是均匀的。因此，对于任意符号 $b \\in \\Sigma$：\n$$ e_{I_x}(b) = \\frac{1}{|\\Sigma|} = \\frac{1}{4} = 0.25 $$\n这同样适用于 $e_{I_x}(A)$。\n\n我们现在将此逻辑应用于提供的测试用例。\n\n用例 1：$(n_A, n_C, n_G, n_T) = (3, 1, 1, 1)$\n总计数 $N = 3+1+1+1 = 6$。\n由于 $N > 0$，$e_{I_x}(A) = \\frac{n_A}{N} = \\frac{3}{6} = 0.5$。\n\n用例 2：$(n_A, n_C, n_G, n_T) = (0, 0, 0, 0)$\n总计数 $N = 0+0+0+0 = 0$。\n这是特殊情况。分布是均匀的。\n$e_{I_x}(A) = 0.25$。\n\n用例 3：$(n_A, n_C, n_G, n_T) = (10, 0, 0, 0)$\n总计数 $N = 10+0+0+0 = 10$。\n由于 $N > 0$，$e_{I_x}(A) = \\frac{n_A}{N} = \\frac{10}{10} = 1.0$。\n\n用例 4：$(n_A, n_C, n_G, n_T) = (0, 5, 5, 0)$\n总计数 $N = 0+5+5+0 = 10$。\n由于 $N > 0$，$e_{I_x}(A) = \\frac{n_A}{N} = \\frac{0}{10} = 0.0$。\n\n用例 5：$(n_A, n_C, n_G, n_T) = (1\\times 10^{-12}, 2\\times 10^{-12}, 3\\times 10^{-12}, 4\\times 10^{-12})$\n总计数 $N = (1+2+3+4) \\times 10^{-12} = 10 \\times 10^{-12} = 1 \\times 10^{-11}$。\n由于 $N > 0$，$e_{I_x}(A) = \\frac{n_A}{N} = \\frac{1\\times 10^{-12}}{10\\times 10^{-12}} = \\frac{1}{10} = 0.1$。\n\n结果必须格式化为 $6$ 位小数。\n- 用例 1：$0.500000$\n- 用例 2：$0.250000$\n- 用例 3：$1.000000$\n- 用例 4：$0.000000$\n- 用例 5：$0.100000$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the M-step update for the emission probability e_{I_x}(A)\n    for a series of test cases based on expected emission counts.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of expected counts (n_A, n_C, n_G, n_T).\n    test_cases = [\n        (3.0, 1.0, 1.0, 1.0),\n        (0.0, 0.0, 0.0, 0.0),\n        (10.0, 0.0, 0.0, 0.0),\n        (0.0, 5.0, 5.0, 0.0),\n        (1e-12, 2e-12, 3e-12, 4e-12),\n    ]\n\n    results = []\n    for case in test_cases:\n        # The expected count n_A is the first element of the tuple.\n        n_A = case[0]\n        \n        # Calculate the total expected count. Using np.sum is robust for\n        # floating-point arithmetic and sums the elements of the tuple.\n        total_count = np.sum(case)\n        \n        # The M-step update rule for emission probabilities is derived from\n        # maximizing the expected complete-data log-likelihood.\n        # The updated probability e_{I_x}(b) is the normalized expected count: n_b / sum(n_i).\n        \n        # A special case is defined for when the total expected count is zero.\n        # In this situation, the updated distribution is uniform. For an alphabet\n        # of size 4 (A, C, G, T), each probability becomes 1/4 = 0.25.\n        if total_count == 0.0:\n            e_Ix_A = 0.25\n        else:\n            # For non-zero total counts, apply the standard formula.\n            e_Ix_A = n_A / total_count\n            \n        # The problem requires the output to be rounded to exactly 6 digits\n        # after the decimal point. We use an f-string for this formatting.\n        results.append(f\"{e_Ix_A:.6f}\")\n\n    # Final print statement in the exact required format: [r1,r2,r3,r4,r5]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2411616"}, {"introduction": "配对隐马尔可夫模型的参数不仅仅是分配概率，它们还定义了序列比对的“规则”。最后一个练习 [@problem_id:2411626] 提出了一个思想实验来探索这一概念，重点关注维特比（Viterbi）算法。通过将一个转移概率设置为零，我们将观察到这个简单的改变如何对最可能的比对施加一种特定且不明显的结构性约束，从而突显模型拓扑与比对特征之间的深层联系。", "problem": "考虑一个用于双序列比对的标准配对隐马尔可夫模型 (pair-HMM)，该模型具有三个发射状态：匹配状态 $M$、在序列 $x$ 中的插入状态（表示为 $I_x$）以及在序列 $y$ 中的插入状态（表示为 $I_y$）。匹配状态 $M$ 发射一对符号 $(x_i,y_j)$，状态 $I_x$ 发射一个与序列 $y$ 中空位对齐的单个符号 $x_i$，状态 $I_y$ 发射一个与序列 $x$ 中空位对齐的单个符号 $y_j$。此外，还有沉默的起始状态 $B$ 和结束状态 $E$，它们只在比对的开始和结束时出现。设 $a_{s,t}$ 表示从状态 $s$ 到状态 $t$ 的转移概率，设 $e_M(x_i,y_j)$、$e_{I_x}(x_i)$ 和 $e_{I_y}(y_j)$ 表示相应状态下的发射概率。假设对于每个发射状态 $s \\in \\{M, I_x, I_y\\}$，其出射转移概率满足 $\\sum_{t \\in \\{M, I_x, I_y, E\\}} a_{s,t} = 1$，并且所有有效符号的发射概率都严格为正。假设从匹配状态到其自身的转移概率被设置为 $a_{M,M} = 0$，而 $\\{M, I_x, I_y\\}$ 之间的所有其他转移以及从这些状态到 $E$ 的转移保持严格为正且不变。\n\n在这些条件下，这对两个给定序列之间的维特比比对（即最大后验状态路径及其隐含的比对）有何影响？\n\nA. 维特比路径将永远不会进入匹配状态 $M$，因此比对只包含空位，不能比对任何符号对。\n\nB. 维特比路径中匹配状态 $M$ 的任何出现都必须是孤立的；不可能出现连续两次匹配，因此任何两个比对上的符号对都必须被至少一个空位状态隔开。\n\nC. 维特比比对不受影响，因为当发射概率占主导时，最可能的路径会忽略自转移概率。\n\nD. 该模型仍然可以通过将沉默的起始或结束状态作为桥梁来产生连续匹配的运行，因此连续匹配仍然是可能的。\n\nE. 由于零转移，维特比动态规划变得不适定，因此无法计算最优路径。", "solution": "在尝试任何解决方案之前，必须首先验证问题陈述的正确性和清晰性。\n\n### 步骤 1：提取已知条件\n该问题描述了一个用于双序列比对的配对隐马尔可夫模型 (pair-HMM)，具有以下组件和条件：\n- **状态**：三个发射状态：匹配 ($M$)、在序列 $x$ 中的插入 ($I_x$) 和在序列 $y$ 中的插入 ($I_y$)。两个沉默状态：起始 ($B$) 和结束 ($E$)。\n- **发射**：\n    - 状态 $M$ 发射一对符号 $(x_i, y_j)$。发射概率为 $e_M(x_i,y_j)$。\n    - 状态 $I_x$ 发射一个符号 $x_i$（与空位对齐）。发射概率为 $e_{I_x}(x_i)$。\n    - 状态 $I_y$ 发射一个符号 $y_j$（与空位对齐）。发射概率为 $e_{I_y}(y_j)$。\n- **转移**：\n    - 从状态 $s$ 到状态 $t$ 的转移概率表示为 $a_{s,t}$。\n    - 对于每个发射状态 $s \\in \\{M,I_x,I_y\\}$，其出射转移概率之和为一：$\\sum_{t \\in \\{M,I_x,I_y,E\\}} a_{s,t} = 1$。\n- **概率约束**：\n    - 所有有效符号的发射概率都严格为正。\n    - 从匹配状态到其自身的转移概率被设置为零：$a_{M,M} = 0$。\n    - 在 $\\{M,I_x,I_y\\}$ 之间的所有其他转移以及从这些状态到 $E$ 的转移都保持严格为正。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题陈述进行评估。\n- **科学依据**：该问题基于标准的配对 HMM 框架，这是计算生物学和生物信息学中用于序列比对的基石。所描述的模型是一个简化但标准的版本（例如，“三状态配对 HMM”）。这个前提在科学上是合理的。\n- **适定性**：该问题要求特定参数变化（$a_{M,M} = 0$）对维特比算法输出的影响。这是一个定义明确的问题，在 HMM 框架内具有唯一的逻辑结果。\n- **客观性**：语言精确，没有主观性。所有术语都是该领域的标准术语。\n- **完整性和一致性**：模型得到了充分的描述。约束 $a_{M,M}=0$ 是对一个标准模型的特定、一致的修改。其他转移保持为正的事实确保了模型不会变得微不足道或不连通。\n- **现实性**：将转移概率设置为零是一种有效的建模选择，通常用于强制执行比对的某些结构性约束。这是一个现实的理论练习。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。这是一个关于标准生物信息学算法属性的、适定的、有科学依据的问题。我将继续推导解决方案。\n\n###\n### 解决方案的推导\n维特比算法寻找可能生成给定序列对 $(x_1...x_L, y_1...y_N)$ 的最可能状态路径（维特比路径）。特定路径 $\\pi = (\\pi_1, \\pi_2, ..., \\pi_K)$ 和相应观测序列的概率由以下公式给出：\n$$P(\\text{sequences}, \\pi) = a_{B,\\pi_1} \\prod_{k=1}^{K-1} a_{\\pi_k, \\pi_{k+1}} \\prod_{k=1}^{K} P(\\text{emission}_k | \\pi_k)$$\n其中最后的转移是到结束状态 $E$，即 $\\pi_K \\rightarrow E$。为简洁起见，这可以写成 $a_{\\pi_K, E}$。\n\n维特比算法使用动态规划来找到最大化此概率的路径 $\\pi^*$。令 $V_s(i, j)$ 为生成前缀 $x_1...x_i$ 和 $y_1...y_j$ 后，以状态 $s \\in \\{M, I_x, I_y\\}$ 结束的最可能路径的概率。这些分数的递推关系如下：\n\n对于位置 $(i,j)$ 处的匹配状态 $M$：\n$$V_M(i,j) = e_M(x_i, y_j) \\times \\max \\begin{cases} V_M(i-1, j-1) \\cdot a_{M,M} \\\\ V_{I_x}(i-1, j-1) \\cdot a_{I_x,M} \\\\ V_{I_y}(i-1, j-1) \\cdot a_{I_y,M} \\end{cases}$$\n\n对于位置 $(i,j)$ 处的空位状态 $I_x$：\n$$V_{I_x}(i,j) = e_{I_x}(x_i) \\times \\max \\begin{cases} V_M(i-1, j) \\cdot a_{M,I_x} \\\\ V_{I_x}(i-1, j) \\cdot a_{I_x,I_x} \\\\ V_{I_y}(i-1, j) \\cdot a_{I_y,I_x} \\end{cases}$$\n\n对于位置 $(i,j)$ 处的空位状态 $I_y$：\n$$V_{I_y}(i,j) = e_{I_y}(y_j) \\times \\max \\begin{cases} V_M(i, j-1) \\cdot a_{M,I_y} \\\\ V_{I_x}(i, j-1) \\cdot a_{I_x,I_y} \\\\ V_{I_y}(i, j-1) \\cdot a_{I_y,I_y} \\end{cases}$$\n计算从初始状态 $V_B(0,0)=1$ 开始。\n\n问题陈述指出，匹配状态的自转移概率为零：$a_{M,M} = 0$。我们必须分析这个约束对维特比路径的影响。\n\n让我们检查 $V_M(i,j)$ 的递推关系：\n$$V_M(i,j) = e_M(x_i, y_j) \\times \\max \\begin{cases} V_M(i-1, j-1) \\cdot 0 \\\\ V_{I_x}(i-1, j-1) \\cdot a_{I_x,M} \\\\ V_{I_y}(i-1, j-1) \\cdot a_{I_y,M} \\end{cases}$$\n项 $V_M(i-1, j-1) \\cdot a_{M,M}$ 变为 $V_M(i-1, j-1) \\cdot 0 = 0$。这意味着通过在 $(i-1, j-1)$ 处的状态 $M$ 到达在 $(i,j)$ 处的状态 $M$ 的路径，其概率贡献总是为 $0$。\n\n维特比算法旨在最大化路径概率。除非所有进入状态 $M$ 的可能路径的概率都为零（事实并非如此，因为 $a_{I_x,M} > 0$ 且 $a_{I_y,M} > 0$），否则该算法永远不会选择从 $M$ 到 $M$ 的转移作为最优路径的一部分。最可能的路径，即维特比路径，是一个状态序列 $\\pi^* = (\\pi_1^*, \\pi_2^*, ... , \\pi_K^*)$。条件 $a_{M,M}=0$ 意味着此路径中任何两个连续状态都不可能都是 $M$，即 $\\pi_k^*=M$ 和 $\\pi_{k+1}^*=M$ 不能同时发生。\n\n就比对而言，状态 $M$ 对应于一对对齐的符号。连续两次匹配的序列将对应于子路径 $M \\to M$。由于此转移的概率为 $0$，任何包含它的路径的总概率都为 $0$。维特比算法将丢弃此类路径，而选择任何存在非零概率的路径。\n\n因此，维特比路径中匹配状态 $M$ 的任何出现都必须由不同的状态前后相随。其他发射状态是 $I_x$ 和 $I_y$，它们对应于比对中的空位。这意味着任何两个比对上的符号对都必须被至少一个空位插入或删除隔开。\n\n### 选项评估\n\n**A. 维特比路径将永远不会进入匹配状态 $M$，因此比对只包含空位，不能比对任何符号对。**\n这是**不正确**的。模型可以从状态 $I_x$ 或 $I_y$ 转移到状态 $M$，因为问题陈述指出 $a_{I_x,M}$ 和 $a_{I_y,M}$ 严格为正。例如，路径片段 $... \\to I_x \\to M \\to I_y \\to ...$ 是可能的，并且可能是最优的。这将产生一个带有孤立匹配对的比对。因此，路径永远不会进入状态 $M$ 的说法是错误的。\n\n**B. 维特比路径中匹配状态 $M$ 的任何出现都必须是孤立的；不可能出现连续两次匹配，因此任何两个比对上的符号对都必须被至少一个空位状态隔开。**\n这是**正确**的。如上所述，条件 $a_{M,M} = 0$ 使得任何包含从状态 $M$ 到状态 $M$ 的转移的路径的总概率为 $0$。如果存在任何具有正概率的路径，维特比算法将不会选择这样的路径。这禁止了状态 $M$ 的连续出现。在比对中，状态 $M$ 代表对齐的符号对，状态 $I_x$ 和 $I_y$ 代表空位。因此，任何两个对齐的符号对都必须被至少一个空位隔开。\n\n**C. 维特比比对不受影响，因为当发射概率占主导时，最可能的路径会忽略自转移概率。**\n这是**不正确**的。这种说法表明对维特比算法有根本性的误解。路径概率是发射概率和转移概率的乘积。无论发射概率有多大，零转移概率都会迫使乘积为零。维特比算法不会“忽略”任何概率；它严格计算完整的路径概率。设置 $a_{M,M}=0$ 肯定会影响比对。\n\n**D. 该模型仍然可以通过将沉默的起始或结束状态作为桥梁来产生连续匹配的运行，因此连续匹配仍然是可能的。**\n这是**不正确**的。沉默状态 $B$ 和 $E$ 有特定的作用。起始状态 $B$ 是任何路径的唯一起点，在处理任何符号之前（在索引 $(0,0)$ 处）。结束状态 $E$ 是唯一的终止点，只有在处理完一个或两个序列中所有期望的符号后才能进入。它们不能在比对中间用作中间的“桥梁”状态。动态规划表的结构强制通过序列索引进行单调递增，使得这种路由不可能实现。\n\n**E. 由于零转移，维特比动态规划变得不适定，因此无法计算最优路径。**\n这是**不正确**的。零概率是概率模型中参数的有效值。维特比算法及其动态规划递推关系是完全适定的，可以毫无问题地执行。涉及 $a_{M,M}$ 的项简单地计算为 $0$，`max` 操作照常进行。可以并且将会计算出一条最优路径；它只是被限制在不包含 $M \\to M$ 转移的路径上。", "answer": "$$\\boxed{B}$$", "id": "2411626"}]}