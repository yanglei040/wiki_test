{"hands_on_practices": [{"introduction": "在生物信息学中，选择正确的评分方案对于获得有生物学意义的比对结果至关重要。一个评分矩阵并非放之四海而皆准；我们是选择一个简单的单位矩阵（匹配得分+1，错配得分-1），还是一个更复杂的取代矩阵（如 BLOSUM），这完全取决于我们试图检验的生物学假设。这个练习 [@problem_id:2395031] 将通过一个具体的思想实验来挑战你，探讨在特定功能基序（如 RGD 序列）需要精确保守的情况下，不同评分方案如何影响全局比对的结果，从而突显出算法参数选择背后的生物学逻辑。", "problem": "序列分析中的一个核心原则是，全局比对的生物学相关性取决于哪些特征处于选择压力之下：某些特征只有在精确残基对齐时才被保守，而其他区域可能容忍保守性替换。考虑两个肽序列 $X$ 和 $Y$，它们都含有一个整合素结合三肽基序 RGD，该基序通常在强大的功能性约束下需要被精确保守。这两个序列是：\n\n- $X$: I L V I L V R G D I L\n- $Y$: I I L V I L V A R G D\n\n假设我们将使用带有线性罚分模型的 Needleman–Wunsch 算法来计算全局比对。给出两种备选的评分系统：\n\n- 同一性评分：如果 $a=b$，则 $s(a,b)=+1$；如果 $a\\neq b$，则 $s(a,b)=-1$；每个空位符号的线性空位罚分为 $g=-1$。\n- 一个类似BLOSUM的复杂替换矩阵方案 $s'(a,b)$，其线性空位罚分为 $g'=-6$，定义在此处出现的残基子集上，具体如下：\n  - $s'(a,a)=+4$ (精确匹配)。\n  - $\\{\\mathrm{I},\\mathrm{L},\\mathrm{V}\\}$ 之间的保守性疏水替换得分为 $+3$：$s'(\\mathrm{I},\\mathrm{L})=s'(\\mathrm{L},\\mathrm{I})=s'(\\mathrm{I},\\mathrm{V})=s'(\\mathrm{V},\\mathrm{I})=s'(\\mathrm{L},\\mathrm{V})=s'(\\mathrm{V},\\mathrm{L})=+3$。\n  - 特定的非保守性配对：$s'(\\mathrm{R},\\mathrm{V})=s'(\\mathrm{V},\\mathrm{R})=-3$，$s'(\\mathrm{D},\\mathrm{R})=s'(\\mathrm{R},\\mathrm{D})=-2$，$s'(\\mathrm{L},\\mathrm{D})=s'(\\mathrm{D},\\mathrm{L})=-3$。\n  - 中性配对：$s'(\\mathrm{G},\\mathrm{A})=s'(\\mathrm{A},\\mathrm{G})=0$，$s'(\\mathrm{I},\\mathrm{G})=s'(\\mathrm{G},\\mathrm{I})=0$。\n  - 任何其他未指定的错配得分为 $-1$。\n\n生物学背景。对于这两种蛋白质，已知RGD基序必须精确对齐（R对R，G对G，D对D）以保持整合素结合能力；疏水背景中的保守性替换通常可以被容忍但并非功能上的决定性因素。因此，一个具有生物学相关性的全局比对是那种能够精确对齐RGD三肽的比对，即使这需要在附近的低复杂度疏水区域引入空位。\n\n基本原理。在线性罚分模型下，前缀 $X[1..i]$ 和 $Y[1..j]$ 的全局比对得分遵循 Needleman–Wunsch 动态规划递推式\n$$\nF(i,j) \\;=\\; \\max\\big\\{\\, F(i-1,j-1) + s(x_i,y_j),\\;\\; F(i-1,j)+g,\\;\\; F(i,j-1)+g \\,\\big\\}\n$$\n经过适当的初始化，其中 $s$ 是替换得分，$g$ 是空位罚分（对于类似BLOSUM的方案，则相应地使用 $s'$ 和 $g'$）。一个最优全局比对对应于此动态规划中的一条最优路径。\n\n任务。在不构建完整动态规划表的情况下，根据递推式和评分定义进行推理，以确定每种评分方案会在这两种天然的竞争性比对结构中偏好哪一种：\n- 一种“无空位”比对，它使长疏水区块保持在对角线上对齐，并且不重新对齐RGD基序（导致其偏移并大部分错配）。\n- 一种“基序对齐”比对，它在疏水区块内部引入空位以滑动序列，从而使RGD精确对齐。\n\n哪种说法是正确的？\n\nA. 在同一性评分下，最优比对引入2个空位以精确对齐RGD，并获得比最佳无空位比对更高的分数；在带有 $g'=-6$ 的类似BLOSUM方案下，最优比对避免了空位，保持疏水区块对齐，并使RGD错位，因为这样能产生更高的分数。因此，同一性评分的比对更具生物学相关性。\n\nB. 两种评分方案都选择了相同的、精确对齐RGD的最优比对；两种方案都没有提供优势。\n\nC. 在同一性评分下，最优比对避免了空位并使RGD错位；在类似BLOSUM的方案下，最优比对即使必须引入空位也会精确对齐RGD。因此，类似BLOSUM的方案更具生物学相关性。\n\nD. 两种方案都无法区分对齐RGD和错位RGD的备选方案，因为在这两种方案下它们的得分相同。", "solution": "首先将对问题陈述进行严格验证。\n\n### 步骤1：提取已知信息\n\n提供的已知信息如下：\n- **序列 $X$**：$\\text{I L V I L V R G D I L}$ (长度 $N_X = 11$)\n- **序列 $Y$**：$\\text{I I L V I L V A R G D}$ (长度 $N_Y = 11$)\n- **算法**：带有线性罚分模型的 Needleman–Wunsch 全局比对。\n- **递推关系**：$F(i,j) = \\max\\{ F(i-1,j-1) + s(x_i,y_j), F(i-1,j)+g, F(i,j-1)+g \\}$。\n- **评分系统1（同一性）**：\n  - 替换得分：如果 $a=b$，则 $s(a,b)=+1$；如果 $a\\neq b$，则 $s(a,b)=-1$。\n  - 空位罚分：$g=-1$。\n- **评分系统2（类似BLOSUM）**：\n  - 替换得分 $s'(a,b)$:\n    - $s'(a,a)=+4$ (匹配)。\n    - $s'(\\mathrm{I},\\mathrm{L})=s'(\\mathrm{I},\\mathrm{V})=s'(\\mathrm{L},\\mathrm{V})=+3$ (及其对称配对)。\n    - $s'(\\mathrm{R},\\mathrm{V})=-3$ (及其对称配对)。\n    - $s'(\\mathrm{D},\\mathrm{R})=-2$ (及其对称配对)。\n    - $s'(\\mathrm{L},\\mathrm{D})=-3$ (及其对称配对)。\n    - $s'(\\mathrm{G},\\mathrm{A})=0$ (及其对称配对)。\n    - $s'(\\mathrm{I},\\mathrm{G})=0$ (及其对称配对)。\n    - $s'(a,b)=-1$ 对于所有其他未指定的错配。\n  - 空位罚分：$g'=-6$。\n- **竞争性比对**：\n  1. **“无空位”比对**：一个没有空位的完全对角线比对。\n  2. **“基序对齐”比对**：一个引入空位以对齐 $X$ 的 $\\text{RGD}$ 基序与 $Y$ 的 $\\text{RGD}$ 基序的比对。\n- **生物学背景**：如果 $\\text{RGD}$ 三肽被精确保守，则认为比对是“具有生物学相关性”的。\n\n### 步骤2：使用提取的已知信息进行验证\n\n根据既定原则对问题进行验证。\n- **科学依据**：该问题是生物信息学中的一个标准练习，涉及用于全局序列比对的基本Needleman-Wunsch算法。评分方案，包括简化的同一性矩阵和类似BLOSUM的矩阵，都是标准工具。$\\text{RGD}$ 基序是一个经典的、有充分文档记载的功能受限短线性基序的例子。该问题牢固地建立在成熟的计算生物学基础上。\n- **定义明确**：该问题提供了两个特定的序列、两个独特且定义明确的评分系统，以及两种清晰描述的竞争性比对结构。任务是计算和比较这些比对的得分，这是一个确定性且定义明确的数学过程。可以得出一个唯一的、有意义的答案。\n- **客观性**：该问题使用精确、客观的语言和定量数据（序列、得分）进行陈述。它不包含主观或基于观点的论断。\n\n该问题没有表现出科学上不健全、不完整、矛盾或模棱两可等缺陷。两个序列的长度相同 ($11$)，这简化了“无空位”的情况，但要求仔细构建“基序对齐”的情况，因为移位必须通过相等数量的插入和删除来完成。这是全局比对问题的一个标准特征。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。现在将通过计算并比较两种指定比对结构在两种评分系统下的得分来得出解决方案。\n\n### 求解推导\n\n任务是确定两种评分系统各自偏好哪种比对结构。我们必须首先明确构建这两种比对。\n\n**比对1：“无空位”比对**\n由于序列 $X$ 和 $Y$ 的长度均为 $11$，无空位全局比对是残基的直接逐列配对：\n$$\n\\begin{array}{lllllllllll}\nX:  \\text{I}  \\text{L}  \\text{V}  \\text{I}  \\text{L}  \\text{V}  \\text{R}  \\text{G}  \\text{D}  \\text{I}  \\text{L} \\\\\nY:  \\text{I}  \\text{I}  \\text{L}  \\text{V}  \\text{I}  \\text{L}  \\text{V}  \\text{A}  \\text{R}  \\text{G}  \\text{D}\n\\end{array}\n$$\n\n**比对2：“基序对齐”比对**\nRGD基序在 $X$ 中的索引为 7-9，在 $Y$ 中的索引为 9-11。要对齐它们，需要2个位置的移位。对于两个等长序列的全局比对，一个序列中的任何插入都必须由另一个序列中的插入来平衡。要将 $X[7..9]$ 与 $Y[9..11]$ 对齐，前缀 $X[1..6]$（长度6）必须与前缀 $Y[1..8]$（长度8）对齐，这需要在 $X$ 中引入2个空位。后缀 $X[10..11]$（长度2）必须与 $Y$ 的一个空后缀对齐，这需要在 $Y$ 中引入2个空位。最终的比对共有4个空位，长度为13。\n$$\n\\begin{array}{lllllllllllll}\nX:  \\text{I}  \\text{L}  \\text{V}  \\text{I}  \\text{L}  \\text{V}  -  -  \\text{R}  \\text{G}  \\text{D}  \\text{I}  \\text{L} \\\\\nY:  \\text{I}  \\text{I}  \\text{L}  \\text{V}  \\text{I}  \\text{L}  \\text{V}  \\text{A}  \\text{R}  \\text{G}  \\text{D}  -  -\n\\end{array}\n$$\n\n我们现在计算两种评分系统下每种比对的得分。\n\n**使用同一性评分进行分析 ($s(a,b)=\\pm1, g=-1$)**\n\n- **比对1（无空位）的得分**：\n  我们计算匹配和错配的数量。\n  - 匹配：位置1处的 $(\\text{I},\\text{I})$。总计：1个匹配。\n  - 错配：所有其他10个位置。总计：10个错配。\n  - 得分 $= 1 \\times (+1) + 10 \\times (-1) = 1 - 10 = -9$。\n\n- **比对2（基序对齐）的得分**：\n  我们计算13个比对列中的匹配、错配和空位。\n  - 匹配：$(\\text{I},\\text{I})$、$(\\text{R},\\text{R})$、$(\\text{G},\\text{G})$、$(\\text{D},\\text{D})$。总计：4个匹配。\n  - 错配：$(\\text{L},\\text{I})$、$(\\text{V},\\text{L})$、$(\\text{I},\\text{V})$、$(\\text{L},\\text{I})$、$(\\text{V},\\text{L})$。总计：5个错配。\n  - 空位：$(-, \\text{V})$、$(-, \\text{A})$、$(\\text{I}, -)$、$(\\text{L}, -)$。总计：4个空位。\n  - 得分 $= 4 \\times (+1) + 5 \\times (-1) + 4 \\times (-1) = 4 - 5 - 4 = -5$。\n\n- **比较**：得分(无空位) = -9。得分(基序对齐) = -5。\n  由于 $-5 > -9$，同一性评分方案偏好基序对齐的结构。\n\n**使用类似BLOSUM的评分进行分析 ($s'(a,b)$, $g'=-6$)**\n\n- **比对1（无空位）的得分**：\n  `I/I`: $s'(\\text{I},\\text{I})=+4$。\n  `L/I`: $s'(\\text{L},\\text{I})=+3$。\n  `V/L`: $s'(\\text{V},\\text{L})=+3$。\n  `I/V`: $s'(\\text{I},\\text{V})=+3$。\n  `L/I`: $s'(\\text{L},\\text{I})=+3$。\n  `V/L`: $s'(\\text{V},\\text{L})=+3$。\n  `R/V`: $s'(\\text{R},\\text{V})=-3$。\n  `G/A`: $s'(\\text{G},\\text{A})=0$。\n  `D/R`: $s'(\\text{D},\\text{R})=-2$。\n  `I/G`: $s'(\\text{I},\\text{G})=0$。\n  `L/D`: $s'(\\text{L},\\text{D})=-3$。\n  总分 $= (4+3+3+3+3+3) - 3 + 0 - 2 + 0 - 3 = 19 - 8 = +11$。\n\n- **比对2（基序对齐）的得分**：\n  这个比对包含替换配对和4个空位。空位罚分很严苛：$g'=-6$。\n  - 替换得分：\n    - 前缀 `ILVILV` vs `IILVIL`: $s'(\\text{I},\\text{I}) + s'(\\text{L},\\text{I}) + s'(\\text{V},\\text{L}) + s'(\\text{I},\\text{V}) + s'(\\text{L},\\text{I}) + s'(\\text{V},\\text{L}) = 4+3+3+3+3+3 = +19$。\n    - 基序 `RGD` vs `RGD`: $s'(\\text{R},\\text{R}) + s'(\\text{G},\\text{G}) + s'(\\text{D},\\text{D}) = 4+4+4 = +12$。\n  - 4个空位的总罚分：$4 \\times g' = 4 \\times (-6) = -24$。\n  总分 = (总替换得分) + (总空位罚分) = $(19 + 12) - 24 = 31 - 24 = +7$。\n\n- **比较**：得分(无空位) $=+11$。得分(基序对齐) $=+7$。\n  由于 $+11 > +7$，类似BLOSUM的方案偏好无空位比对。高昂的空位罚分 ($g'=-6$) 使得引入空位的代价过高，即使是为了对齐高分的RGD匹配也是如此。\n\n### 结论与选项评估\n\n- **同一性评分**：基序对齐结构（得分-5）优于无空位结构（得分-9）。\n- **类似BLOSUM的评分**：无空位结构（得分+11）优于基序对齐结构（得分+7）。\n- **生物学相关性**：问题陈述指出，生物学相关性要求对齐RGD基序。因此，在这种特定情况下，同一性评分系统产生了更具生物学相关性的比对，而具有高空位罚分的类似BLOSUM方案则未能做到这一点。\n\n我们现在基于此分析评估给出的选项。\n\n- **A.** “在同一性评分下，最优比对引入空位以精确对齐RGD，并获得比最佳无空位比对更高的分数；在带有 $g'=-6$ 的类似BLOSUM方案下，最优比对避免了空位，保持疏水区块对齐，并使RGD错位，因为这样能产生更高的分数。因此，同一性评分的比对更具生物学相关性。”\n  该陈述与我们的发现完全一致。第一部分是正确的（同一性评分偏好基序对齐）。第二部分是正确的（类似BLOSUM的评分偏好无空位）。关于生物学相关性的结论也基于问题的定义是正确的。此选项**正确**。\n\n- **B.** “两种评分方案都选择了相同的、精确对齐RGD的最优比对；两种方案都没有提供优势。”\n  这是错误的。两种方案偏好不同的比对结构。此选项**不正确**。\n\n- **C.** “在同一性评分下，最优比对避免了空位并使RGD错位；在类似BLOSUM的方案下，最优比对即使必须引入空位也会精确对齐RGD。因此，类似BLOSUM的方案更具生物学相关性。”\n  该陈述与我们对两种评分系统的发现完全相反。此选项**不正确**。\n\n- **D.** “两种方案都无法区分对齐RGD和错位RGD的备选方案，因为在这两种方案下它们的得分相同。”\n  在两种情况下分数都不相同（$-5 \\neq -9$ 且 $+7 \\neq +11$）。此选项**不正确**。\n\n唯一正确的陈述是A。", "answer": "$$\\boxed{A}$$", "id": "2395031"}, {"introduction": "我们通常使用 Needleman-Wunsch 算法来寻找两条序列之间的“最佳”比对，即得分最高的比对。但反向思考一下会怎样？这个练习 [@problem_id:2395055] 提出了一个有趣的问题：如何修改算法来找到“最差”的比对，即得分最低的比对？解决这个问题不仅需要你灵活运用动态规划的原理，还将加深你对评分系统背后概率解释（对数优势比）的理解，揭示“最差”比对分数在评估序列是否具有同源性方面的独特意义。", "problem": "给定两个基于字母表 $\\Sigma$（例如，核苷酸或氨基酸）的生物序列 $S$ 和 $T$。考虑采用加性评分方案的全局比对：每一对对齐的字符 $(a,b)\\in\\Sigma\\cup\\{-\\}$，当 $a,b\\in\\Sigma$ 时，贡献一个替换得分 $s(a,b)$；当一个字符与一个空位符号 $-$ 对齐时，贡献一个空位罚分 $g(a,-)=g(-,a)$，且不允许空位-空位对齐。Needleman–Wunsch (NW) 算法利用全局比对的最优子结构，在 $S$ 和 $T$ 的所有比对中，找到一个能优化总比对得分 $S(\\mathcal{A})$ 的比对，该总得分定义为所有比对列贡献的总和。假设 $s(a,b)$ 使得匹配是有利的（例如，$s(a,a)>0$），而错配和空位是不利的（例如，当 $a\\neq b$ 时 $s(a,b)<0$ 以及 $g(a,-)<0$），因此标准做法是最大化 $S(\\mathcal{A})$。\n\n现在要求您修改该过程，以在相同的加性模型下获得尽可能不相似的比对，即找到一个比对 $\\mathcal{A}_{\\mathrm{worst}}$，它在原始的 $s$ 和 $g$ 下最小化总得分，或者等效地，最大化不相似性。此外，在替换得分是对数几率（log-odds），由一个同源模型与一个背景模型推导出来的常见假设下，从生物学或信息论的角度解释得到的极值得分。\n\n哪个选项最准确地描述了正确的修改方法和有效的解释？\n\n- A. 将所有替换得分和空位罚分取反，得到 $s'(a,b)=-s(a,b)$ 和 $g'(a,-)=-g(a,-)$，然后运行标准的 Needleman–Wunsch (NW) 最大化算法来计算 $\\max_{\\mathcal{A}} \\sum s' + g'$，这等于 $-\\min_{\\mathcal{A}} \\sum s + g$。在对数几率评分 $s(a,b)=\\log \\frac{Q(a,b)}{P(a)P(b)}$ 和表示为插入-缺失模型的对数几率的空位罚分下，所得的最大不相似性值等于同源性的最优对数几率支持度的负值，并且可以解读为在该模型下反对 $S$ 和 $T$ 之间同源性的最强证据。\n- B. 保持得分不变，但在动态规划中将每个最大化操作替换为最小化操作以获得最差比对；对于任何评分方案，所得的目标值都等于 Levenshtein 编辑距离，因此通常定义了一个满足三角不等式的度量。\n- C. 仅将匹配得分 $s(a,a)$ 取反，同时保持错配和空位罚分不变，然后用 Needleman–Wunsch (NW) 进行最大化；所得值近似于 $S$ 和 $T$ 的氨基酸组成之间的 Kullback–Leibler 散度，从而在组成层面上量化不相似性。\n- D. 保持原始得分并仍然执行最大化，但强制动态规划在每个递推步骤中选择局部最差的选项；所得的目标值提供了 $S$ 和 $T$ 之间突变数量的一个上界，且该上界与评分参数的选择无关。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n-   两个基于字母表 $\\Sigma$ 的生物序列 $S$ 和 $T$。\n-   使用加性评分方案的全局比对。\n-   替换得分：$s(a,b)$，其中 $a,b \\in \\Sigma$。\n-   空位罚分：$g(a,-)=g(-,a)$，其中 $a \\in \\Sigma$，此处记为 $g$。为简单起见，我们假设一个常见的恒定空位罚分，尽管该逻辑对仿射或其他方案也成立。\n-   比对 $\\mathcal{A}$ 的得分：$S(\\mathcal{A}) = \\sum_{\\text{列}} \\text{得分}(\\text{列})$。\n-   标准的 Needleman-Wunsch (NW) 算法最大化 $S(\\mathcal{A})$。\n-   评分方案的假设属性：\n    -   匹配是有利的：$s(a,a) > 0$。\n    -   错配是不利的：当 $a \\neq b$ 时 $s(a,b) < 0$。\n    -   空位是不利的：$g < 0$。\n-   主要目标：修改过程以找到一个使总得分最小化的比对 $\\mathcal{A}_{\\mathrm{worst}}$，即找到 $\\min_{\\mathcal{A}} S(\\mathcal{A})$。\n-   次要目标：在得分是对数几率（即 $s(a,b) = \\log \\frac{Q(a,b)}{P(a)P(b)}$，其中 $Q$ 是同源概率模型，$P$ 是背景概率模型）的假设下，解释得到的极值得分。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  科学依据：该问题牢固地植根于计算生物学和生物信息学。它涉及公认的 Needleman-Wunsch 算法、加性评分方案及其作为对数几率得分的标准概率解释。所有概念都是该领域的基础。\n2.  适定性：该问题是适定的。它要求对一个标准算法进行修改，以解决一个不同但相关的优化问题（最小化而非最大化），并为结果提供理论解释。目标明确且存在解决方案。\n3.  客观性：语言正式、精确，没有主观或含糊的术语。\n4.  一致性和完整性：问题陈述是自洽且内部一致的。它提供了构建解决方案所需的所有必要背景。\n\n### 步骤 3：结论和行动\n问题陈述是有效的。这是生物信息学理论中一个标准且表述良好的问题。我将继续推导解决方案并评估各个选项。\n\n### 解题推导\n\n目标是计算两个序列 $S$ 和 $T$ 之间可能的最小比对得分。设任意比对 $\\mathcal{A}$ 的得分为 $S(\\mathcal{A})$。我们寻求找到 $\\mathcal{A}_{\\mathrm{worst}}$，使得 $S(\\mathcal{A}_{\\mathrm{worst}}) = \\min_{\\mathcal{A}} S(\\mathcal{A})$。\n\nNeedleman-Wunsch 算法是一种用于寻找 $\\max_{\\mathcal{A}} S(\\mathcal{A})$ 的动态规划算法。得分矩阵 $F(i,j)$ 的递推关系为：\n$$F(i,j) = \\max \\begin{cases} F(i-1, j-1) + s(S_i, T_j)  \\text{(对角移动)} \\\\ F(i-1, j) + g  \\text{(垂直移动, 在 } T \\text{ 中有空位)} \\\\ F(i, j-1) + g  \\text{(水平移动, 在 } S \\text{ 中有空位)} \\end{cases}$$\n最大得分即为 $F(|S|, |T|)$。\n\n为了找到最小得分，我们可以利用优化的一个基本性质：对于定义域 $X$ 上的任何函数 $f(x)$，以下恒等式成立：\n$$\\min_{x \\in X} f(x) = - \\max_{x \\in X} (-f(x))$$\n\n在我们的情境中，$x$ 是一个比对 $\\mathcal{A}$，$f(x)$ 是得分 $S(\\mathcal{A})$。我们通过将原始得分取反来定义一个新的评分方案 $s'$ 和 $g'$：\n$$s'(a,b) = -s(a,b)$$\n$$g' = -g$$\n在此新方案下，比对 $\\mathcal{A}$ 的得分 $S'(\\mathcal{A})$ 为：\n$$S'(\\mathcal{A}) = \\sum_{\\text{列 } c \\in \\mathcal{A}} \\text{得分}'(c) = \\sum_{\\text{列 } c \\in \\mathcal{A}} (-\\text{得分}(c)) = - \\left( \\sum_{\\text{列 } c \\in \\mathcal{A}} \\text{得分}(c) \\right) = -S(\\mathcal{A})$$\n因此，在原始方案下寻找最小得分，等同于在取反的方案下寻找最大得分，然后将结果取反：\n$$\\min_{\\mathcal{A}} S(\\mathcal{A}) = - \\max_{\\mathcal{A}} (-S(\\mathcal{A})) = - \\max_{\\mathcal{A}} S'(\\mathcal{A})$$\n量 $\\max_{\\mathcal{A}} S'(\\mathcal{A})$ 可以使用标准的 Needleman-Wunsch 最大化算法和新的得分 $s'$ 和 $g'$ 来计算。这为找到最小比对得分提供了一个正确的过程。\n\n或者，可以直接修改递推关系，用最小化代替最大化：\n$$F_{\\min}(i,j) = \\min \\begin{cases} F_{\\min}(i-1, j-1) + s(S_i, T_j) \\\\ F_{\\min}(i-1, j) + g \\\\ F_{\\min}(i, j-1) + g \\end{cases}$$\n结果 $F_{\\min}(|S|, |T|)$ 将直接得出 $\\min_{\\mathcal{A}} S(\\mathcal{A})$。这在算法上等同于取反方法。\n\n现在来解释。原始的评分方案基于对数几率比。一个比对的得分 $S(\\mathcal{A}) = \\sum \\log \\frac{P(\\text{列}|\\text{同源})}{P(\\text{列}|\\text{随机})}$，是在同源模型与随机背景模型下整个比对的对数似然比。最优得分 $\\max_{\\mathcal{A}} S(\\mathcal{A})$ 代表了序列 $S$ 和 $T$ 之间存在同源性的最强证据。对称地，最小得分 $\\min_{\\mathcal{A}} S(\\mathcal{A})$ 代表了使同源性看起来最不可能的比对。因此，这个得分可以被解释为在给定模型下反对同源性的最强证据，或最大不相似性的度量。\n\n### 逐项分析选项\n\n**A. 将所有替换得分和空位罚分取反，得到 $s'(a,b)=-s(a,b)$ 和 $g'(a,-)=-g(a,-)$，然后运行标准的 Needleman–Wunsch (NW) 最大化算法来计算 $\\max_{\\mathcal{A}} \\sum s' + g'$，这等于 $-\\min_{\\mathcal{A}} \\sum s + g$。在对数几率评分 $s(a,b)=\\log \\frac{Q(a,b)}{P(a)P(b)}$ 和表示为插入-缺失模型的对数几率的空位罚分下，所得的最大不相似性值等于同源性的最优对数几率支持度的负值，并且可以解读为在该模型下反对 $S$ 和 $T$ 之间同源性的最强证据。**\n\n-   **方法：** 所提出的方法是将所有得分取反并使用标准的最大化算法。如上所述，这正确地计算了 $\\max_{\\mathcal{A}} S'(\\mathcal{A}) = -\\min_{\\mathcal{A}} S(\\mathcal{A})$。该方法的描述在数学上是合理的。\n-   **解释：**\n    1.  “……可以解读为反对同源性的最强证据……”：最小得分 $\\min_{\\mathcal{A}} S(\\mathcal{A})$ 确实是最差情况比对的对数似然比，代表了反对同源性的最强证据。这部分解释是正确的。\n    2.  “……所得的最大不相似性值等于同源性的最优对数几率支持度的负值……”：这个陈述断言 $\\min_{\\mathcal{A}} S(\\mathcal{A}) = - \\max_{\\mathcal{A}} S(\\mathcal{A})$。这通常是错误的。所有可能比对的得分分布并非围绕零对称。例如，对于两个相关的序列，最大得分将是一个大的正数，而最小得分可能是一个非常大的负数，且有 $|\\min S| \\gg |\\max S|$。因此，这部分解释是不正确的。\n-   **结论：** 方法是正确的。定性解释是正确且相关的。然而，它包含一个错误的特定量化声明。在给定的选项中，这是最合理的。\n\n**B. 保持得分不变，但在动态规划中将每个最大化操作替换为最小化操作以获得最差比对；对于任何评分方案，所得的目标值都等于 Levenshtein 编辑距离，因此通常定义了一个满足三角不等式的度量。**\n\n-   **方法：** 如推导所示，将递推关系中的 `max` 替换为 `min` 是计算最小得分的有效方法。方法部分是正确的。\n-   **解释：** 解释完全错误。Levenshtein 距离对应于一种非常特定的评分方案（例如，错配罚分1，插入/删除罚分1，匹配得分0），用于计算编辑操作数。问题中描述的通用评分方案（$s(a,a)>0$ 等）不会产生 Levenshtein 距离。因此，声称结果是一个满足三角不等式的度量的说法，对于通用评分函数来说，是没有根据且不正确的。\n-   **结论：** 不正确。虽然方法有效，但解释存在根本性缺陷。\n\n**C. 仅将匹配得分 $s(a,a)$ 取反，同时保持错配和空位罚分不变，然后用 Needleman–Wunsch (NW) 进行最大化；所得值近似于 $S$ 和 $T$ 的氨基酸组成之间的 Kullback–Leibler 散度，从而在组成层面上量化不相似性。**\n\n-   **方法：** 仅将匹配得分取反的方法定义了一个新的目标函数，它不等同于最小化原始得分。例如，最小化 $A+B$ 并非通过最大化 $-A+B$ 来实现。此方法不能解决所述问题。\n-   **解释：** 解释也是不正确的。比对得分对字符顺序敏感，与组成之间的 Kullback-Leibler 散度没有直接关系，后者是衡量频率分布之间差异的度量，对顺序不敏感。\n-   **结论：** 不正确。方法和解释都有缺陷。\n\n**D. 保持原始得分并仍然执行最大化，但强制动态规划在每个递推步骤中选择局部最差的选项；所得的目标值提供了 $S$ 和 $T$ 之间突变数量的一个上界，且该上界与评分参数的选择无关。**\n\n-   **方法：** 这描述了对动态规划算法的一个无意义的修改。作为动态规划基础的最优性原则，要求每一步的选择都是相对于子问题最优解的最优选择。做出“局部最差”选择破坏了这一原则，并且不能保证找到任何全局最优解（无论是最大值还是最小值）。该方法定义不清且对于解决该问题是不正确的。\n-   **解释：** 解释毫无根据。这种被破坏的算法的输出没有明确的意义。声称它提供了突变数量的上界并且与评分参数无关的说法是显而易见的错误，因为该过程明确使用了得分。\n-   **结论：** 不正确。所提出的方法不是一个有效的算法，其解释也毫无意义。\n\n### 总结\n选项 A 提供了一个正确的算法流程。其解释正确地指出了最小得分的含义，即作为反对同源性的最强证据。它包含一个不准确的量化陈述，但其总体描述远优于选项 B、C 和 D，后者在方法、解释或两者上都存在根本性错误。因此，选项 A 是可用的最准确的描述。", "answer": "$$\\boxed{A}$$", "id": "2395055"}, {"introduction": "从理论到实践是计算生物学研究的核心环节。本练习 [@problem_id:2395091] 将引导你完成这一过程，你需要编写程序来实现一个更接近真实应用的全局比对算法，该算法使用仿射罚分模型（affine gap penalty），它对打开一个缺口的罚分要高于延长一个缺口的罚分。更重要的是，你将学习如何通过统计学方法来评估比对分数的显著性。通过将原始序列的比对分数与大量随机重排序列的比对分数分布进行比较并计算 Z-score，你将能够亲身体验生物信息学家如何从随机背景中识别出有意义的生物学信号。", "problem": "给定两个脱氧核糖核酸 (DNA) 字母表 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 上的有限字符串 $s$ 和 $t$。$s$ 和 $t$ 的一个比对是通过在 $s$ 和 $t$ 中插入间隙符号 $-$（不改变原始符号的顺序）得到的，使得结果字符串 $\\hat{s}$ 和 $\\hat{t}$ 的长度相等，为 $L$，并且对于每个 $k\\in\\{1,\\dots,L\\}$，$\\hat{s}_k$ 或 $\\hat{t}_k$ 中至少有一个在 $\\Sigma$ 中。一个比对的分数定义为替换分数和仿射间隙罚分之和。替换分数由一个函数 $\\sigma:\\Sigma\\times\\Sigma\\to\\mathbb{R}$ 给出，定义为：如果 $x=y$，则 $\\sigma(x,y)=m$；如果 $x\\neq y$，则 $\\sigma(x,y)=u$。仿射间隙罚分的定义是：在 $\\hat{s}$ 或 $\\hat{t}$ 中，每个长度为 $l\\in\\mathbb{N}$ 的最大连续间隙段都会产生 $g_{\\text{open}}+g_{\\text{extend}}\\cdot l$ 的罚分。总比对分数是所有 $\\hat{s}_k,\\hat{t}_k\\in\\Sigma$ 的位置上的替换分数之和，加上所有间隙段的罚分之和。最优全局比对分数 $S^\\star(s,t)$ 是 $s$ 和 $t$ 所有比对中比对分数的最大值。\n\n对于一个固定的对 $(s,t)$，定义以下随机化分析。固定一个正整数 $K$ 和一个非负整数种子 $z$。考虑 $K$ 个独立的随机字符串 $t^{(1)},\\dots,t^{(K)}$，它们是通过对 $t$ 的字符多重集进行均匀随机排列得到的，每个副本都如此操作。使用由 $z$ 确定性初始化的伪随机数生成器以确保可复现性。对于每个 $k\\in\\{1,\\dots,K\\}$，计算最优全局比对分数 $S^\\star\\!\\left(s,t^{(k)}\\right)$。令 $\\mu$ 表示算术平均值\n$$\n\\mu=\\frac{1}{K}\\sum_{k=1}^{K} S^\\star\\!\\left(s,t^{(k)}\\right),\n$$\n并令总体标准差为\n$$\n\\sigma_{\\text{pop}}=\\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}\\left(S^\\star\\!\\left(s,t^{(k)}\\right)-\\mu\\right)^2}.\n$$\n将原始对的 $z$-分数定义为\n$$\nZ=\\begin{cases}\n\\frac{S^\\star(s,t)-\\mu}{\\sigma_{\\text{pop}}}, & \\text{如果 }\\sigma_{\\text{pop}}>0, \\\\\n0, & \\text{如果 }\\sigma_{\\text{pop}}=0.\n\\end{cases}\n$$\n\n您的任务是编写一个完整的程序，对下面指定的每个测试用例，根据上述定义计算四元组 $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$，并使用所提供的确切参数。对于每个测试，使用相同的评分方案，其中 $m=2$，$u=-1$，$g_{\\text{open}}=-2$，$g_{\\text{extend}}=-1$。对于每个测试，使用指定的 $K$ 和种子 $z$ 来生成 $t$ 的 $K$ 个洗牌副本。\n\n测试集：\n- 用例 1：$s=\\text{\"ACGTCG\"}$，$t=\\text{\"ACTCG\"}$，$K=200$，$z=314159$。\n- 用例 2：$s=\\text{\"AAAAAA\"}$，$t=\\text{\"AAA\"}$，$K=200$，$z=271828$。\n- 用例 3：$s=\\text{\"GATTACA\"}$，$t=\\text{\"GATTACA\"}$，$K=200$，$z=161803$。\n- 用例 4：$s=\\text{\"\"}$ (空字符串)，$t=\\text{\"ACGT\"}$，$K=200$，$z=42$。\n\n答案规格：\n- 对于每个用例，将 $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$ 作为实数计算。\n- 使用标准四舍五入将每个实数保留到小数点后 $6$ 位。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个子列表对应一个测试用例，子列表中的顺序为 $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$，并用方括号括起来。例如，一个有效的输出格式是 $\\left[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],\\dots\\right]$，不含任何额外文本。", "solution": "对问题陈述进行验证。\n\n### 第 1 步：提取给定信息\n\n- **字符串**：字母表 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 上的两个有限字符串 $s$ 和 $t$。\n- **比对定义**：在 $s$ 和 $t$ 中插入间隙符号（$-$）以形成等长 $L$ 的 $\\hat{s}$ 和 $\\hat{t}$，使得在任何位置 $k$，$\\hat{s}_k$ 或 $\\hat{t}_k$ 中至少有一个不是间隙。\n- **评分方案**：\n    - **替换分数**：如果 $x=y$，则 $\\sigma(x,y)=m$；如果 $x \\neq y$，则 $\\sigma(x,y)=u$。\n    - **仿射间隙罚分**：一个长度为 $l$ 的最大连续间隙段产生的罚分为 $g_{\\text{open}}+g_{\\text{extend}}\\cdot l$。\n    - **总分数**：替换分数和间隙罚分之和。\n- **最优分数**：$S^\\star(s,t)$ 是可能的最大比对分数。\n- **随机化分析**：\n    - 一个固定的正整数 $K$ 和一个非负整数种子 $z$。\n    - 通过对 $t$ 的字符进行均匀随机排列生成 $K$ 个随机字符串 $t^{(k)}$。\n    - **平均分**：$\\mu=\\frac{1}{K}\\sum_{k=1}^{K} S^\\star\\!\\left(s,t^{(k)}\\right)$。\n    - **总体标准差**：$\\sigma_{\\text{pop}}=\\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}\\left(S^\\star\\!\\left(s,t^{(k)}\\right)-\\mu\\right)^2}$。\n    - **Z-分数**：如果 $\\sigma_{\\text{pop}}>0$，则 $Z=\\frac{S^\\star(s,t)-\\mu}{\\sigma_{\\text{pop}}}$；如果 $\\sigma_{\\text{pop}}=0$，则 $Z=0$。\n- **任务参数**：\n    - **评分常数**：$m=2$，$u=-1$，$g_{\\text{open}}=-2$，$g_{\\text{extend}}=-1$。\n- **测试集**：\n    - 用例 1：$s=\\text{\"ACGTCG\"}$，$t=\\text{\"ACTCG\"}$，$K=200$，$z=314159$。\n    - 用例 2：$s=\\text{\"AAAAAA\"}$，$t=\\text{\"AAA\"}$，$K=200$，$z=271828$。\n    - 用例 3：$s=\\text{\"GATTACA\"}$，$t=\\text{\"GATTACA\"}$，$K=200$，$z=161803$。\n    - 用例 4：$s=\\text{\"\"}$，$t=\\text{\"ACGT\"}$，$K=200$，$z=42$。\n- **输出规格**：对于每个测试用例，计算四元组 $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$，每个值四舍五入到小数点后 $6$ 位。\n\n### 第 2 步：使用提取的给定信息进行验证\n\n- **科学依据**：该问题描述了使用仿射间隙罚分模型计算最优全局比对分数。这是一个生物信息学中的标准基础问题，可以使用一种成熟的动态规划算法——Needleman-Wunsch算法的一个变种来解决。后续使用z-score对洗牌序列的背景分布进行统计分析，是评估比对生物学意义的标准方法。该问题具有科学合理性。\n- **定义明确**：该问题定义明确。仿射间隙罚分的动态规划算法提供了一个唯一的最优分数。使用由特定种子初始化的确定性伪随机数生成器确保了洗牌序列的生成是可复现的，从而得到一组唯一的 $\\mu$、$\\sigma_{\\text{pop}}$ 和 $Z$ 值。\n- **客观性**：该问题在数学和算法上都精确定义。所有术语都有清晰的定义，所有参数都已提供。不存在主观性或歧义。\n- **完整性与一致性**：该问题是自包含的。每个测试用例都提供了所有必要的数据，包括字符串、评分参数（$m, u, g_{\\text{open}}, g_{\\text{extend}}$）和统计参数（$K, z$）。没有矛盾之处。\n\n### 第 3 步：结论与行动\n该问题有效。它有科学依据、定义明确、客观且完整。可以计算出确定的解。\n\n---\n\n### 解法\n\n解决此问题需要两个部分：首先，一种用于计算两个序列之间带仿射间隙罚分的最优全局比对分数的算法；其次，一个用于评估该分数显著性的统计框架。\n\n**1. 带仿射间隙罚分的最优全局比对**\n\n最优比对分数 $S^\\star(s,t)$ 的计算是一个经典的动态规划问题。仿射间隙罚分区分了打开间隙（$g_{\\text{open}}$）和扩展间隙（$g_{\\text{extend}}$），需要比更简单的线性间隙罚分模型更复杂的状态空间。我们使用三个大小为 $(|s|+1) \\times (|t|+1)$ 的动态规划矩阵 $M$、$I_x$ 和 $I_y$。设 $s_i$ 是 $s$ 的第 $i$ 个字符，$t_j$ 是 $t$ 的第 $j$ 个字符。\n\n对于 $i \\in \\{1,\\dots,|s|\\}$ 和 $j \\in \\{1,\\dots,|t|\\}$，这些矩阵定义如下：\n- $M(i,j)$：前缀 $s[1..i]$ 和 $t[1..j]$ 的最佳比对分数，其中 $s_i$ 与 $t_j$ 对齐。\n- $I_x(i,j)$：$s[1..i]$ 和 $t[1..j]$ 的最佳比对分数，其中 $s_i$ 与一个间隙对齐。\n- $I_y(i,j)$：$s[1..i]$ 和 $t[1..j]$ 的最佳比对分数，其中 $t_j$ 与一个间隙对齐。\n\n这些矩阵使用以下递推关系填充：\n\n$$\nM(i,j) = \\sigma(s_i, t_j) + \\max \\begin{cases} M(i-1, j-1) \\\\ I_x(i-1, j-1) \\\\ I_y(i-1, j-1) \\end{cases}\n$$\n该递推式表明，对齐字符 $s_i$ 和 $t_j$（分数为 $\\sigma(s_i, t_j)$）可以跟在一个以匹配/错配 ($M$)、在 $t$ 中有间隙 ($I_x$) 或在 $s$ 中有间隙 ($I_y$) 结尾的比对之后。\n\n$$\nI_x(i,j) = \\max \\begin{cases} M(i-1, j) + g_{\\text{open}} + g_{\\text{extend}}  \\text{（在 } t \\text{ 中打开间隙）} \\\\ I_x(i-1, j) + g_{\\text{extend}}  \\text{（在 } t \\text{ 中扩展间隙）} \\end{cases}\n$$\n这捕捉了将 $s_i$ 与间隙对齐的分数。这个状态可以通过在 $t$ 中打开一个新的间隙（从一个以匹配/错配结尾的比对）或扩展 $t$ 中现有的间隙来达到。\n\n$$\nI_y(i,j) = \\max \\begin{cases} M(i, j-1) + g_{\\text{open}} + g_{\\text{extend}}  \\text{（在 } s \\text{ 中打开间隙）} \\\\ I_y(i, j-1) + g_{\\text{extend}}  \\text{（在 } s \\text{ 中扩展间隙）} \\end{cases}\n$$\n这与 $I_x(i,j)$ 对称，表示将 $t_j$ 与间隙对齐的分数。\n\n矩阵的初始化条件至关重要：\n- 基本情况：$M(0,0)=0$。$M$ 矩阵的第 $0$ 行和第 $0$ 列中的所有其他条目都设置为 $-\\infty$，以禁止以匹配/错配开始的比对。\n- 初始间隙：将字符串的前缀与空字符串对齐。\n  - 对于 $i > 0$，$I_x(i,0) = g_{\\text{open}} + i \\cdot g_{\\text{extend}}$。对于 $i=0$ 或 $j=0$ 的其他 $I_x(i,j)$ 为 $-\\infty$。\n  - 对于 $j > 0$，$I_y(0,j) = g_{\\text{open}} + j \\cdot g_{\\text{extend}}$。对于 $i=0$ 或 $j=0$ 的其他 $I_y(i,j)$ 为 $-\\infty$。\n\n填充矩阵后，长度为 $n = |s|$ 和 $m = |t|$ 的字符串 $s$ 和 $t$ 的最优全局比对分数是三种可能的最终状态中的最大值：\n\n$$\nS^\\star(s,t) = \\max \\{ M(n,m), I_x(n,m), I_y(n,m) \\}\n$$\n\n提供的参数是 $m=2$，$u=-1$，$g_{\\text{open}}=-2$ 和 $g_{\\text{extend}}=-1$。\n\n**2. 统计显著性分析**\n\n为了评估分数 $S^\\star(s,t)$ 是否显著高，我们将其与 $s$ 和随机序列比对得分的背景分布进行比较。随机序列 $t^{(k)}$（其中 $k=1,\\dots,K$）是通过随机排列原始字符串 $t$ 的字符生成的。这保留了 $t$ 的长度和字符组成，这两者是比对分数的重要决定因素。对伪随机数生成器使用固定的种子 $z$ 确保了此过程是确定性和可复现的。\n\n对于 $K$ 个洗牌后的字符串 $t^{(k)}$ 中的每一个，我们使用上述相同的算法计算最优比对分数 $S^\\star(s,t^{(k)})$。从这 $K$ 个分数的集合中，我们计算两个统计量：\n\n- 算术平均值：$\\mu = \\frac{1}{K}\\sum_{k=1}^{K} S^\\star(s,t^{(k)})$。\n- 总体标准差：$\\sigma_{\\text{pop}} = \\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}(S^\\star(s,t^{(k)}) - \\mu)^2}$。\n\n最后，计算 z-分数 $Z$。它衡量原始分数 $S^\\star(s,t)$ 与洗牌序列分数的平均值相差多少个标准差。\n\n$$\nZ=\\begin{cases}\n\\dfrac{S^\\star(s,t)-\\mu}{\\sigma_{\\text{pop}}},  & \\text{如果 }\\sigma_{\\text{pop}}>0, \\\\\n0, & \\text{如果 }\\sigma_{\\text{pop}}=0.\n\\end{cases}\n$$\n当所有洗牌序列产生完全相同的比对分数时，会出现 $\\sigma_{\\text{pop}}=0$ 的情况，这使得基于标准差的比较变得微不足道。\n\n程序将在一个函数中实现动态规划算法。该函数将对原始对 $(s,t)$ 调用一次，然后对 $(s, t^{(k)})$ 对调用 $K$ 次。收集结果以计算最终的四元组 $[\\![S^\\star(s,t), \\mu, \\sigma_{\\text{pop}}, Z]\\!]$，其中每个元素四舍五入到小数点后 $6$ 位。", "answer": "```python\nimport numpy as np\n\ndef compute_optimal_score(s: str, t: str, match: float, mismatch: float, gap_open: float, gap_extend: float) -> float:\n    \"\"\"\n    Computes the optimal global alignment score with affine gap penalties.\n    \"\"\"\n    n = len(s)\n    m = len(t)\n    \n    if n == 0 and m == 0:\n        return 0.0\n    if n == 0:\n        return gap_open + m * gap_extend\n    if m == 0:\n        return gap_open + n * gap_extend\n\n    neg_inf = -np.inf\n\n    # Initialization of DP matrices\n    M = np.full((n + 1, m + 1), neg_inf, dtype=float)\n    Ix = np.full((n + 1, m + 1), neg_inf, dtype=float)\n    Iy = np.full((n + 1, m + 1), neg_inf, dtype=float)\n\n    M[0, 0] = 0.0\n\n    for i in range(1, n + 1):\n        Ix[i, 0] = gap_open + i * gap_extend\n    for j in range(1, m + 1):\n        Iy[0, j] = gap_open + j * gap_extend\n\n    # Fill DP matrices\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # Substitution score\n            sub_score = match if s[i-1] == t[j-1] else mismatch\n            \n            # M(i,j) - alignment ends with s[i-1] vs t[j-1]\n            prev_m = M[i-1, j-1]\n            prev_ix = Ix[i-1, j-1]\n            prev_iy = Iy[i-1, j-1]\n            M[i, j] = sub_score + max(prev_m, prev_ix, prev_iy)\n\n            # Ix(i,j) - alignment ends with s[i-1] vs gap\n            open_gap_x = M[i-1, j] + gap_open + gap_extend\n            extend_gap_x = Ix[i-1, j] + gap_extend\n            Ix[i, j] = max(open_gap_x, extend_gap_x)\n            \n            # Iy(i,j) - alignment ends with gap vs t[j-1]\n            open_gap_y = M[i, j-1] + gap_open + gap_extend\n            extend_gap_y = Iy[i, j-1] + gap_extend\n            Iy[i, j] = max(open_gap_y, extend_gap_y)\n\n    # Final score is the max of the three states at the bottom-right corner\n    final_score = max(M[n, m], Ix[n, m], Iy[n, m])\n    return final_score\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\"s\": \"ACGTCG\", \"t\": \"ACTCG\", \"K\": 200, \"z\": 314159},\n        {\"s\": \"AAAAAA\", \"t\": \"AAA\", \"K\": 200, \"z\": 271828},\n        {\"s\": \"GATTACA\", \"t\": \"GATTACA\", \"K\": 200, \"z\": 161803},\n        {\"s\": \"\", \"t\": \"ACGT\", \"K\": 200, \"z\": 42},\n    ]\n\n    # Scoring parameters\n    m_score = 2.0\n    u_score = -1.0\n    g_open = -2.0\n    g_extend = -1.0\n    \n    all_results = []\n\n    for case in test_cases:\n        s, t, K, z = case[\"s\"], case[\"t\"], case[\"K\"], case[\"z\"]\n\n        # 1. Compute score for the original pair (s, t)\n        original_score = compute_optimal_score(s, t, m_score, u_score, g_open, g_extend)\n\n        # 2. Generate K shuffled sequences and compute their scores\n        rng = np.random.default_rng(z)\n        t_chars = list(t)\n        shuffled_scores = []\n        if len(t_chars) > 0:\n            for _ in range(K):\n                shuffled_t_chars = rng.permutation(t_chars)\n                shuffled_t = \"\".join(shuffled_t_chars)\n                score = compute_optimal_score(s, shuffled_t, m_score, u_score, g_open, g_extend)\n                shuffled_scores.append(score)\n        else: # If t is empty, all \"shuffled\" versions are also empty\n             shuffled_scores = [original_score] * K\n\n\n        shuffled_scores = np.array(shuffled_scores)\n\n        # 3. Compute statistics\n        mu = np.mean(shuffled_scores)\n        sigma_pop = np.std(shuffled_scores, ddof=0) # Population standard deviation\n\n        # 4. Compute Z-score\n        if sigma_pop > 0:\n            z_score = (original_score - mu) / sigma_pop\n        else:\n            z_score = 0.0\n\n        # 5. Round results and append\n        rounded_results = [\n            round(original_score, 6),\n            round(mu, 6),\n            round(sigma_pop, 6),\n            round(z_score, 6)\n        ]\n        all_results.append(rounded_results)\n\n    # Format and print the final output\n    # e.g., [[-1.23, 2.34, 3.45, 4.56],[...]]\n    print(f\"[[{all_results[0][0]},{all_results[0][1]},{all_results[0][2]},{all_results[0][3]}],[{all_results[1][0]},{all_results[1][1]},{all_results[1][2]},{all_results[1][3]}],[{all_results[2][0]},{all_results[2][1]},{all_results[2][2]},{all_results[2][3]}],[{all_results[3][0]},{all_results[3][1]},{all_results[3][2]},{all_results[3][3]}]]\")\n\nsolve()\n```", "id": "2395091"}]}