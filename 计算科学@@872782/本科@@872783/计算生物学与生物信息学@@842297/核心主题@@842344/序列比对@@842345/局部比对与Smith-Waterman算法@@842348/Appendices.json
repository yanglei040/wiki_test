{"hands_on_practices": [{"introduction": "Smith-Waterman算法的强大之处不仅在于其数学框架，还在于其对评分参数的敏感性。不同的匹配得分、错配罚分和空位罚分组合会引导算法发现不同类型的局部相似性。这个练习旨在培养你对评分方案如何影响比对结果的直觉，通过推理而不是计算，你将探索一个特定的参数设置（匹配得分低于空位罚分）如何从根本上改变算法的行为，从而加深对局部比对核心权衡的理解。[@problem_id:2401676]", "problem": "在使用 Smith–Waterman (SW) 算法进行局部比对时，两条序列被比对以最大化一对连续子串的总分，当得分降至零以下时，动态规划 (DP) 状态允许重置为零以开始新的局部比对。考虑一个标准的得分模型，该模型具有替换得分函数 $s(\\cdot,\\cdot)$ 和线性空位罚分，其中每个空位字符贡献 $-g$ 的罚分，且 $g0$。设相同残基的匹配奖励为 $s(a,a)=m$ 且 $m0$，不同残基的错配惩罚为 $s(a,b)=-\\mu$ (对于 $a\\neq b$) 且 $\\mu\\ge 0$。假设匹配奖励小于每个残基的空位成本，即 $m  g$。", "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n**步骤 1：提取已知条件**\n-   算法：用于局部比对的 Smith–Waterman (SW) 算法。\n-   核心特性：如果动态规划 (DP) 得分降至 0 以下，可以重置为 $0$。\n-   得分模型：线性空位罚分。\n    -   每个字符的空位罚分：$-g$，其中 $g  0$。\n    -   相同残基的匹配得分：$s(a,a) = m$，其中 $m  0$。\n    -   不同残基的错配罚分：$s(a,b) = -\\mu$，其中 $\\mu \\ge 0$。\n-   主导条件：$m  g$。\n-   问题：确定在 $m  g$ 条件下，SW 算法偏好的比对类别。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题定义明确且科学合理。它描述了 Smith-Waterman 算法的标准配置，该算法是生物信息学的基石。参数 $m$、$\\mu$ 和 $g$ 是常见的仿射空位罚分模型（此处简化为线性模型，这是一个特例）的标准组成部分。条件 $m  g$ 代表了一个特定的、有效的参数体系，在实践中常用于寻找高度保守的区块。该问题是自洽、一致的，并提出了一个可以通过算法原理进行逻辑推导来回答的问题。未检测到任何缺陷。\n\n**步骤 3：结论与行动**\n问题是有效的。将推导出一个严谨的解。\n\n**从第一性原理推导**\n\nSmith-Waterman 算法计算在序列 $S_1$ 的位置 $i$ 和序列 $S_2$ 的位置 $j$ 结束的最优局部比对的得分 $H(i, j)$。线性空位罚分的递推关系是：\n$$\nH(i, j) = \\max\n\\begin{cases}\n0 \\\\\nH(i-1, j-1) + s(S_1[i], S_2[j]) \\\\\nH(i, j-1) - g \\\\\nH(i-1, j) - g\n\\end{cases}\n$$\n最大化中的 $0$ 是“归零”特性，它允许新的局部比对在任何点开始。最佳局部比对的最终得分是整个 DP 矩阵 $H$ 中的最大值。\n\n我们必须分析给定条件 $m  g$ 的后果。\n考虑一个具有正分数的现有局部比对，比如说在单元格 $(i, j)$ 处。我们希望扩展它。\n1.  **通过匹配进行扩展**：如果 $S_1[i+1]$ 和 $S_2[j+1]$ 相同，得分增加 $+m$。得分增加，从而增强了该比对。\n2.  **通过错配进行扩展**：得分变化 $-\\mu$。得分减少（如果 $\\mu=0$ 则保持不变），这削弱了该比对。\n3.  **通过空位进行扩展**：要将 $S_1[i+1]$ 与一个空位对齐，得分变为 $H(i+1, j) = H(i, j) - g$。这是一个显著的罚分。\n\n关键的见解来自于比较空位的成本和匹配的奖励。让我们分析引入一个空位然后找到一个匹配后得分的净变化。假设我们通过先在序列 $S_2$ 中引入一个空位（路径到 $(i, j-1)$），然后进行一次匹配（路径到 $(i+1, j)$）来扩展一个结束于 $(i-1, j-1)$ 的比对。在 $(i+1, j)$ 处的得分将通过一系列操作与在 $(i-1, j-1)$ 处的得分相关联。更简单地说，考虑任何包含一个空位和一个匹配的路径段。这两次操作对得分的净变化是 $m - g$。\n\n鉴于问题的条件 $m  g$，可以得出 $m - g  0$。这意味着在比对中引入的任何单个空位的成本都超过了任何单个匹配所能弥补的。在引入一个空位后，为了仅仅使得分收支平衡，将需要至少 $k = \\lceil g/m \\rceil$ 个连续匹配的序列。由于 $m  g$，所以 $g/m  1$，这意味着 $k \\ge 2$。\n\nSW 算法在每一步都选择最大化局部得分的路径。引入空位的路径会立即遭受 $g$ 的得分下降。如果这个下降是显著的，得到的得分 $H(i', j') - g$ 可能会低于替代路径的得分，甚至低于零。如果得分变为负数，归零特性 $H(i,j) = \\max\\{0, ...\\}$ 会将得分重置为 $0$。这有效地终止了有空位的比对路径，并开始搜索一个新的、可能得分更高的比对。\n\n因此，在 $m  g$ 的条件下，该算法强烈倾向于不引入空位。比对路径将通过将匹配连接在一起来累积正分。一旦需要空位，得分就会急剧下降，并且难以恢复。最可能的结果是，算法将在需要这样一个代价高昂的空位之前找到最优比对的终点。这导致算法偏爱高相似度的连续、无空位的片段（通常称为“连续段”或“区块”）。这些比对会更短，因为它们在需要空位的区域被终止，而不是被扩展。\n\n**逐项分析**\n\n-   **A. 由连续匹配组成的简短、连续、无空位的局部比对，因为任何空位的成本都超过单个匹配所能弥补的。**\n    该陈述与我们的推导完全一致。条件 $m  g$ 使得空位相对于单个匹配的奖励而言极其昂贵。因此，SW 的归零机制将倾向于在引入空位之前终止比对，从而导致发现更短、高度保守、无空位的区域。\n    **结论：正确。**\n\n-   **B. 插入许多空位以避免错配的长比对，因为支付空位成本可以在之后实现更多的匹配。**\n    这是不正确的。在 $m  g$ 的条件下，支付空位成本是一个可行策略的前提是有缺陷的。一个空位会招致 $-g$ 的罚分，其量级大于一个匹配的奖励 $+m$。插入“许多空位”将导致比对得分快速而严重地下降，使其触及零底线而被丢弃。该算法不会偏爱这样的路径。\n    **结论：不正确。**\n\n-   **C. 长的有空位的比对，其中每个空位后面都至少跟着 $k=\\lceil g/m\\rceil$ 个连续匹配，因为只有这样得分才能增加。**\n    需要 $k=\\lceil g/m\\rceil$ 次匹配来补偿一个空位的推理在数学上是合理的。然而，算法将偏爱具有这种结构的*长的有空位的比对*这一结论是不正确的。SW 算法在每个 DP 步骤都是一个贪婪的局部最大化器。与简单地重置为 $0$ 相比，空位的巨大即时罚分使得该路径选择非常不利。该算法缺乏为了潜在的未来收益而接受巨大即时罚分的远见。它会优先选择终止比对（通过归零机制），而不是走代价高昂的空位路径。选项 A 更好地描述了这种涌现行为。\n    **结论：不正确。**\n\n-   **D. 不会报告任何比对，因为在 $m  g$ 的条件下，比对得分无法累积。**", "answer": "$$\\boxed{A}$$", "id": "2401676"}, {"introduction": "在真实的生物序列比对中，相比于引入多个独立的空位，延长一个已有的空位通常更符合生物进化的现实。为了模拟这一现象，研究人员开发了仿射空位罚分模型（affine gap penalty model），它对开启一个新空位和延长一个旧空位施加不同的惩罚。这个实践任务要求你将这一重要的理论模型转化为实际代码，通过明确地实现三状态动态规划，你将掌握实现带有仿射空位罚分的Smith-Waterman算法的标准方法，这是生物信息学工具箱中的一项核心技能。[@problem_id:2401701]", "problem": "您需要实现一个局部序列比对算法，该算法遵循 Smith–Waterman 动态规划范式，并采用通过三个动态规划状态矩阵实现的仿射罚分模型。对于有限字母表上的两个输入字符串，状态定义如下：$M_{i,j}$ 表示在第一个字符串的位置 $i$ 和第二个字符串的位置 $j$ 结束，且字符 $x_i$ 和 $y_j$ 相互对齐（匹配或错配）的最优局部比对的分数；$I_{x,i,j}$ 表示在位置 $i$ 和 $j$ 结束，且在第一个字符串中存在一个延伸的空位（即，位置 $x_i$ 与一个空位对齐，对应于在第二个字符串中的一次插入）的最优局部比对的分数；$I_{y,i,j}$ 表示在位置 $i$ 和 $j$ 结束，且在第二个字符串中存在一个延伸的空位（即，位置 $y_j$ 与一个空位对齐，对应于在第一个字符串中的一次插入）的最优局部比对的分数。\n\n该算法必须基于以下基础进行设计：\n- 动态规划（DP）的最优性原则：当问题表现出最优子结构时，一个问题实例的最优解可以由其子问题的最优解构成。\n- 局部比对的定义：得分最高的一对子串的分数，其中比对计分在任何位置都不能降至 $0$ 以下，从而允许比对在局部重新开始。\n- 仿射罚分模型：一个长度为 $L$ 的连续空位的罚分为 $g_o + L \\cdot g_e$，其中 $g_o$ 是空位开放罚分，$g_e$ 是每个符号的空位延伸罚分。当空位被打开或延伸时，$g_o$ 和 $g_e$ 都是从比对分数中减去的非负值。\n\n实现一个程序，给定多对序列和标量计分参数，使用上述三状态仿射罚分模型计算最优的 Smith–Waterman 局部比对分数。您的实现必须显式维护三个状态矩阵 $M$、$I_x$ 和 $I_y$，并且必须通过允许任何状态在所有传入转换的值均为非正数时重置为 $0$ 来强制执行局部比对属性。假设一个简单的字符替换计分函数 $s(a,b)$，定义为：如果 $a=b$，则 $s(a,b) = s_{\\text{match}}$；如果 $a \\neq b$，则 $s(a,b) = s_{\\text{mismatch}}$。\n\n您的程序应处理以下五个测试用例。每个用例由一对字符串以及参数 $s_{\\text{match}}$、$s_{\\text{mismatch}}$、$g_o$ 和 $g_e$ 指定：\n- 情况 1：$x = \\text{\"GATTACA\"}$，$y = \\text{\"GCATGCU\"}$，$s_{\\text{match}} = 2$，$s_{\\text{mismatch}} = -1$，$g_o = 3$，$g_e = 1$。\n- 情况 2：$x = \\text{\"\"}$，$y = \\text{\"\"}$，$s_{\\text{match}} = 2$，$s_{\\text{mismatch}} = -1$，$g_o = 3$，$g_e = 1$。\n- 情况 3：$x = \\text{\"\"}$，$y = \\text{\"ACGT\"}$，$s_{\\text{match}} = 2$，$s_{\\text{mismatch}} = -1$，$g_o = 3$，$g_e = 1$。\n- 情况 4：$x = \\text{\"AAAA\"}$，$y = \\text{\"TTTT\"}$，$s_{\\text{match}} = 2$，$s_{\\text{mismatch}} = -1$，$g_o = 3$，$g_e = 1$。\n- 情况 5：$x = \\text{\"AAAACCCCGGGG\"}$，$y = \\text{\"AAAAGGGG\"}$，$s_{\\text{match}} = 2$，$s_{\\text{mismatch}} = -1$，$g_o = 3$，$g_e = 1$。\n\n对于每个用例，所要求的输出是指定模型和参数下的单个最优局部比对分数（一个整数）。您的程序应生成单行输出，其中包含五个测试用例的结果，形式为方括号内以逗号分隔的列表，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。此问题不涉及物理单位。\n\n限制与说明：\n- 设字符串的长度分别为 $n$ 和 $m$，其中 $n \\ge 0$ 且 $m \\ge 0$。\n- 您的动态规划算法必须在 $\\mathcal{O}(n \\cdot m)$ 时间和 $\\mathcal{O}(n \\cdot m)$ 空间内运行。\n- 所有矩阵索引和中间值均为整数；返回所有位置和所有三种状态下的最大值。\n- 确保长度为 $L$ 的空位的仿射罚分累积为 $g_o + L \\cdot g_e$，与您推导出的状态转换语义一致。", "solution": "该问题要求使用仿射罚分模型实现 Smith-Waterman 局部序列比对算法。这个问题在科学上是合理的、定义明确的，并且基于计算生物学的基本原理。我将首先根据所述原则推导出必要的动态规划递推关系。\n\n设两个序列为 $x = x_1x_2...x_n$（长度为 $n$）和 $y = y_1y_2...y_m$（长度为 $m$）。计分参数为 $s_{\\text{match}}$（字符匹配）、$s_{\\text{mismatch}}$（错配）、$g_o$（空位开放）和 $g_e$（空位延伸）。长度为 $L$ 的空位的罚分为 $g_o + L \\cdot g_e$。注意，罚分是从分数中减去的。\n\n该算法的核心在于最优性原则。在位置 $i$ 和 $j$ 结束的比对的最优分数是根据更小子问题的最优分数计算得出的。仿射罚分模型要求在动态规划网格的每个位置 $(i,j)$ 都有三个状态，对应于比对结束的三种可能方式：\n\n1.  $M_{i,j}$：以 $x_i$ 与 $y_j$ 对齐结束的最佳局部比对分数。\n2.  $I_{x,i,j}$：以 $x_i$ 与一个空位字符 ('-') 对齐结束的最佳局部比对分数。\n3.  $I_{y,i,j}$：以一个空位字符 ('-') 与 $y_j$ 对齐结束的最佳局部比对分数。\n\n比对的局部性是 Smith-Waterman 算法的一个关键特征，它是通过允许在任何位置开始新的比对来实现的。这是通过确保动态规划矩阵中的分数永远不低于 $0$ 来实现的。如果所有将比对延伸到给定单元格的可能方式都会导致非正分数，则该单元格的分数被设置为 $0$，表示一个新的潜在局部比对的开始。\n\n我们将构建三个 $(n+1) \\times (m+1)$ 大小的矩阵，每个状态一个。索引 $i$ 的范围从 $0$ 到 $n$，索引 $j$ 的范围从 $0$ 到 $m$。\n\n**初始化**\n对于局部比对，任何比对都可以从任何地方开始。因此，动态规划矩阵的初始化应使得开始一个新的比对不产生任何成本。这对应于将所有三个矩阵的第一行和第一列都设置为 $0$。\n$$ M_{i,0} = I_{x,i,0} = I_{y,i,0} = 0 \\quad \\text{for } i \\in [0, n] $$\n$$ M_{0,j} = I_{x,0,j} = I_{y,0,j} = 0 \\quad \\text{for } j \\in [0, m] $$\n\n**递推关系**\n对于从 $1$ 到 $n$ 的 $i$ 和从 $1$ 到 $m$ 的 $j$，矩阵单元格按以下方式填充。设 $s(x_i, y_j)$ 为替换分数，如果 $x_i = y_j$，则为 $s_{\\text{match}}$，否则为 $s_{\\text{mismatch}}$。\n\n1.  **状态 $M_{i,j}$ (匹配/错配状态):**\n    一个以 $x_i$ 匹配 $y_j$ 结束的比对必须跟随一个在 $(i-1, j-1)$ 结束的比对。前一个状态可能是匹配/错配 ($M_{i-1,j-1}$)、$y$ 中的空位 ($I_{x,i-1,j-1}$) 或 $x$ 中的空位 ($I_{y,i-1,j-1}$)。我们取这些可能性的最大值，加上替换分数 $s(x_i, y_j)$，并应用局部比对条件。\n    $$ M_{i,j} = \\max\\left(0, \\ s(x_i, y_j) + \\max\\left(M_{i-1,j-1}, I_{x,i-1,j-1}, I_{y,i-1,j-1}\\right)\\right) $$\n\n2.  **状态 $I_{x,i,j}$ ($y$ 中的空位 / $x$ 中的插入):**\n    一个以 $x_i$ 对一个空位结束的比对必须延伸一个在 $(i-1, j)$ 结束的前一个比对。这可以通过两种方式发生：\n    a) 打开一个新空位：到 $(i-1, j)$ 为止的比对以匹配/错配 ($M_{i-1,j}$) 结束。打开一个长度为 $1$ 的空位的罚分是 $g_o + 1 \\cdot g_e$。\n    b) 延伸一个现有空位：到 $(i-1, j)$ 为止的比对已经以 $x_{i-1}$ 对一个空位结束 ($I_{x,i-1,j}$)。延伸该空位的罚分是 $g_e$。\n    递推关系结合了这些可能性，同样带有局部比对的置零条件。\n    $$ I_{x,i,j} = \\max\\left(0, \\max\\left(M_{i-1,j} - (g_o + g_e), \\ I_{x,i-1,j} - g_e\\right)\\right) $$\n\n3.  **状态 $I_{y,i,j}$ ($x$ 中的空位 / $y$ 中的插入):**\n    对称地，一个以 $y_j$ 对一个空位结束的比对必须延伸一个在 $(i, j-1)$ 结束的前一个比对。\n    a) 打开一个新空位：从状态 $M_{i,j-1}$ 转换而来，罚分为 $g_o + g_e$。\n    b) 延伸一个现有空位：从状态 $I_{y,i,j-1}$ 转换而来，罚分为 $g_e$。\n    递推关系是：\n    $$ I_{y,i,j} = \\max\\left(0, \\max\\left(M_{i,j-1} - (g_o + g_e), \\ I_{y,i,j-1} - g_e\\right)\\right) $$\n\n**最终得分**\n最优局部比对的分数是在所有位置 $(i,j)$ 上，三个矩阵中找到的最大值。\n$$ \\text{Score} = \\max_{0 \\le i \\le n, \\ 0 \\le j \\le m} \\{M_{i,j}, I_{x,i,j}, I_{y,i,j}\\} $$\n\n这个过程耗时 $\\mathcal{O}(n \\cdot m)$，因为它需要填充三个大小为 $(n+1) \\times (m+1)$ 的矩阵，并且每个单元格的计算是常数时间操作。空间复杂度也是 $\\mathcal{O}(n \\cdot m)$，用于存储这三个矩阵。现在将遵循此形式化推导进行实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    This program computes the optimal local alignment score for pairs of sequences\n    using the Smith-Waterman algorithm with an affine gap penalty.\n    \"\"\"\n\n    def smith_waterman_affine(x: str, y: str, s_match: int, s_mismatch: int, g_o: int, g_e: int) - int:\n        \"\"\"\n        Computes the Smith-Waterman local alignment score with an affine gap penalty.\n\n        Args:\n            x (str): The first sequence.\n            y (str): The second sequence.\n            s_match (int): The score for a character match.\n            s_mismatch (int): The score for a character mismatch (a penalty, so usually negative).\n            g_o (int): The gap opening penalty (non-negative).\n            g_e (int): The gap extension penalty (non-negative).\n\n        Returns:\n            int: The optimal local alignment score.\n        \"\"\"\n        n = len(x)\n        m = len(y)\n\n        # The three dynamic programming matrices for the states\n        # M: score ending in a match/mismatch\n        # Ix: score ending in a gap in y (insertion relative to x)\n        # Iy: score ending in a gap in x (insertion relative to y)\n        m_matrix = np.zeros((n + 1, m + 1), dtype=int)\n        ix_matrix = np.zeros((n + 1, m + 1), dtype=int)\n        iy_matrix = np.zeros((n + 1, m + 1), dtype=int)\n\n        max_score = 0\n        \n        # Penalty for opening a gap, combining g_o and the first g_e\n        gap_open_penalty = g_o + g_e\n        gap_extend_penalty = g_e\n\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                # Calculate substitution score for x[i-1] and y[j-1]\n                sub_score = s_match if x[i-1] == y[j-1] else s_mismatch\n\n                # Recurrence for M_i,j\n                prev_score_m = max(m_matrix[i-1, j-1], ix_matrix[i-1, j-1], iy_matrix[i-1, j-1])\n                m_matrix[i, j] = max(0, prev_score_m + sub_score)\n\n                # Recurrence for Ix_i,j (gap in y)\n                score_open_x = m_matrix[i-1, j] - gap_open_penalty\n                score_extend_x = ix_matrix[i-1, j] - gap_extend_penalty\n                ix_matrix[i, j] = max(0, score_open_x, score_extend_x)\n\n                # Recurrence for Iy_i,j (gap in x)\n                score_open_y = m_matrix[i, j-1] - gap_open_penalty\n                score_extend_y = iy_matrix[i, j-1] - gap_extend_penalty\n                iy_matrix[i, j] = max(0, score_open_y, score_extend_y)\n\n                # The optimal local score is the maximum found anywhere in the matrices\n                current_max = max(m_matrix[i, j], ix_matrix[i, j], iy_matrix[i, j])\n                if current_max  max_score:\n                    max_score = current_max\n        \n        return max_score\n\n    test_cases = [\n        # Case 1\n        {\"x\": \"GATTACA\", \"y\": \"GCATGCU\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 2\n        {\"x\": \"\", \"y\": \"\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 3\n        {\"x\": \"\", \"y\": \"ACGT\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 4\n        {\"x\": \"AAAA\", \"y\": \"TTTT\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 5\n        {\"x\": \"AAAACCCCGGGG\", \"y\": \"AAAAGGGG\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        score = smith_waterman_affine(\n            case[\"x\"],\n            case[\"y\"],\n            case[\"s_match\"],\n            case[\"s_mismatch\"],\n            case[\"g_o\"],\n            case[\"g_e\"]\n        )\n        results.append(score)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2401701"}, {"introduction": "Smith-Waterman算法保证能找到最优的局部比对得分，但通常可能存在多个不同的比对能达到这同一个最高分。仅仅找到其中一个最优比对可能会忽略其他同样具有生物学意义的替代方案。这个高级练习挑战你超越标准算法，去设计一个能够枚举所有等价最优比对的程序。通过修改回溯（traceback）过程以处理得分并列的情况，并结合递归和备忘录（memoization）技术进行计数，你将对动态规划的解空间以及如何系统地探索它有更深刻的认识。[@problem_id:2401709]", "problem": "考虑脱氧核糖核酸 (DNA) 字母表上的两个序列和一个局部比对计分方案。目标是根据最优性原理进行推理，设计一个动态规划程序，该程序既能计算最优局部比对得分，又能在关键之处修改回溯过程，通过在得分相同时进行分支来枚举所有同等最优的局部比对。您的程序必须实现此过程，并为每个提供的测试用例返回两个整数：最优局部比对得分和如下定义的同等最优局部比对的数量。按规定将所有结果汇总到单行中。\n\n基本原理。请使用以下出发点。两个序列 $A$ 和 $B$ 之间的局部比对，是指 $A$ 的一个连续子串与 $B$ 的一个连续子串的任意比对，通过替换函数和空位罚分进行评分，其中比对得分不允许低于 $0$；最优局部比对得分是所有此类比对中的最大值。根据动态规划 (DP) 的最优性原理，结束于某个单元格的最优比对的得分，仅取决于结束于其前驱单元格的最优子比对以及用于扩展它们的直接操作。您必须从此基础出发推导出一个递推关系，不得假定任何快捷公式。\n\n计分模型。设 $A$ 和 $B$ 是长度分别为 $n$ 和 $m$ 的序列，其字母表为 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$。定义替换得分函数 $\\sigma(x,y)$，当 $x=y$ 时 $\\sigma(x,y)=s_{\\mathrm{match}}$，否则 $\\sigma(x,y)=s_{\\mathrm{mismatch}}$。对于插入单个空位符号，使用线性罚分 $g$。所有三个参数固定为 $s_{\\mathrm{match}}=+2$，$s_{\\mathrm{mismatch}}=-1$ 和 $g=-1$。\n\n感知得分相同的回溯与枚举。在局部比对 DP 表 $H$ 中，对于每个单元格 $(i,j)$，您除了记录其得分外，还必须根据您推导的递推关系，记录下得到该单元格值的前驱方向集合。当多个前驱产生相同的最大值时，必须记录所有这些方向。局部比对的回溯从 $H$ 中值等于全局最大值的任意单元格 $(i,j)$ 开始，并通过重复移动到已记录的前驱方向来进行。当回溯到达一个值为 $0$ 的单元格时终止，该单元格标记了局部比对的开始；不要越过值为 $0$ 的单元格继续进行。不同的回溯路径被视为不同的比对。如果全局最大值为 $0$，则定义同等最优局部比对的数量为 $0$（即，忽略得分为 $0$ 的空比对）。\n\n必需输出。对每个测试用例，计算：\n- 最优局部比对得分（一个非负整数），以及\n- 在回溯过程中对所有得分相同的前驱方向进行完全分支所获得的不同、同等最优局部比对的数量，该数量是所有具有全局最大值得分值的结束单元格的路径数之和。\n\n您的程序必须生成单行输出，其中包含测试套件的所有结果，格式为方括号括起来的逗号分隔列表，顺序为 $[\\text{score}_1,\\text{count}_1,\\text{score}_2,\\text{count}_2,\\dots]$。\n\n测试套件。使用以下五个测试用例；全部使用 $s_{\\mathrm{match}}=+2$、$s_{\\mathrm{mismatch}}=-1$ 和 $g=-1$：\n- 用例 1：$A=\\text{\"AA\"}$，$B=\\text{\"AA\"}$。\n- 用例 2：$A=\\text{\"AG\"}$，$B=\\text{\"GA\"}$。\n- 用例 3：$A=\\text{\"ACA\"}$，$B=\\text{\"AAA\"}$。\n- 用例 4：$A=\\text{\"C\"}$，$B=\\text{\"A\"}$。\n- 用例 5：$A=\\text{\"AAA\"}$，$B=\\text{\"AA\"}$。\n\n您的程序应生成单行输出，其中包含以方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。不涉及物理单位。所有输出都必须是整数。", "solution": "问题要求设计并实现一个动态规划程序，用于计算两个 DNA 序列的最优局部比对得分，并枚举所有不同的、同等最优的比对。推导过程必须遵循最优性原理。\n\n设两个序列分别为 $A = a_1a_2...a_n$ 和 $B = b_1b_2...b_m$，长度分别为 $n$ 和 $m$。计分方案由匹配得分 $s_{\\mathrm{match}}=+2$、错配得分 $s_{\\mathrm{mismatch}}=-1$ 和线性罚分 $g=-1$ 定义。\n\n该解决方案的基础是 Smith-Waterman 算法，它是动态规划在局部序列比对中的直接应用。最优性原理指出，一个最优解可以由其子问题的最优解构建而成。设 $H(i,j)$ 为结束于序列 $A$ 的位置 $i$ 和序列 $B$ 的位置 $j$ 的得分最高的局部比对的得分。结束于 $(i,j)$ 的比对可以通过以下三种方式之一形成：\n1. 通过比对字符 $a_i$ 和 $b_j$。得分为结束于 $(i-1, j-1)$ 的最优比对得分与替换得分 $\\sigma(a_i, b_j)$ 之和。这得到 $H(i-1, j-1) + \\sigma(a_i, b_j)$。\n2. 通过将字符 $a_i$ 与一个空位比对。得分为结束于 $(i-1, j)$ 的最优比对得分与罚分 $g$ 之和。这得到 $H(i-1, j) + g$。\n3. 通过将字符 $b_j$ 与一个空位比对。得分为结束于 $(i, j-1)$ 的最优比对得分与罚分 $g$ 之和。这得到 $H(i, j-1) + g$。\n\n由于是局部比对，它可以从任何位置开始。这是通过在所有其他可能性得分都为负时允许得分为 $0$ 来处理的，这实际上是开始一个新的比对。综合这些情况，$H(i,j)$ 的递推关系为：\n$$\nH(i,j) = \\max \\left\\{\n    0, \\\\\n    H(i-1, j-1) + \\sigma(a_i, b_j), \\\\\n    H(i-1, j) + g, \\\\\n    H(i, j-1) + g\n\\right\\}\n$$\n对于 $1 \\leq i \\leq n$ 和 $1 \\leq j \\leq m$。DP 矩阵 $H$ 的维度为 $(n+1) \\times (m+1)$。边界条件是，对于所有 $i$ 从 $0$ 到 $n$，$H(i,0) = 0$；对于所有 $j$ 从 $0$ 到 $m$，$H(0,j) = 0$。这些初始化确保了比对可以从任何位置开始，而不会因末端空位而产生罚分。\n\n最优局部比对得分 $\\text{score}_{\\text{opt}}$ 是在矩阵 $H$ 中找到的最大值：\n$$\n\\text{score}_{\\text{opt}} = \\max_{0 \\le i \\le n, 0 \\le j \\le m} H(i,j)\n$$\n\n为了枚举所有同等最优的比对，我们必须扩展该程序。首先，我们需要为每个单元格记录得分的来源。我们定义一个与 $H$ 维度相同的指针结构 $P$。每个元素 $P(i,j)$ 将存储一个方向集合，对应于产生得分 $H(i,j)$ 的前驱。\n- 如果 $H(i,j) = H(i-1, j-1) + \\sigma(a_i, b_j)$，则将方向 `DIAGONAL`（对角）添加到 $P(i,j)$。\n- 如果 $H(i,j) = H(i-1, j) + g$，则将方向 `UP`（向上）添加到 $P(i,j)$。\n- 如果 $H(i,j) = H(i, j-1) + g$，则将方向 `LEFT`（向左）添加到 $P(i,j)$。\n如果有多种情况为 $H(i,j)$ 产生相同的最大值，则记录所有对应的方向。$H(i,j)=0$ 的情况对应于比对的开始，没有前驱。\n\n枚举过程如下：\n1. 在矩阵 $H$ 中识别所有单元格 $(i_{end}, j_{end})$，其中 $H(i_{end}, j_{end}) = \\text{score}_{\\text{opt}}$。这些是所有最优局部比对的终止点。\n2. 如果 $\\text{score}_{\\text{opt}} = 0$，问题定义比对计数为 $0$。\n3. 对于每个识别出的结束单元格，我们必须计算到得分为 $0$ 的单元格的不同回溯路径的数量。一条路径是遵循存储在 $P$ 中的方向，从一个单元格移动到另一个单元格的序列。比对总数是源自所有这些最大得分单元格的路径数之和。\n\n为了在不因重复探索共享子路径而导致指数级复杂度的前提下计算这些路径，我们采用另一种动态规划技术：记忆化。我们定义一个递归函数 $\\text{count\\_paths}(i, j)$，用于计算结束于单元格 $(i, j)$ 的不同路径数量。\n设 $C(i,j)$ 是从一个得分为 $0$ 的单元格到单元格 $(i,j)$ 构成最优子比对的路径数量。\n$C(i,j)$ 的递推关系是：\n- **基本情况：** 如果 $H(i,j) = 0$，则 $C(i,j) = 1$。这表示从该点开始的一条路径。\n- **递归步骤：** 对于 $H(i,j)  0$，路径数是其记录在 $P(i,j)$ 中的所有前驱的路径数之和：\n  $$\n  C(i,j) = \\sum_{(i', j') \\in \\text{predecessors}(i,j)} C(i',j')\n  $$\n这可以实现为一个带有记忆化表的递归函数，用以存储 $C(i,j)$ 的结果并避免重复计算。\n\n整体算法如下：\n1. 初始化一个 $(n+1) \\times (m+1)$ 的得分矩阵 $H$ 为零，以及一个同样大小、带有空集合/列表的指针结构 $P$。\n2. 通过从 $i=1...n$ 和 $j=1...m$ 迭代，应用递推关系并记录所有使得分最大化的前驱方向，来填充 $H$ 和 $P$。\n3. 找到 $\\text{score}_{\\text{opt}} = \\max(H)$。\n4. 如果 $\\text{score}_{\\text{opt}} = 0$，返回 $(0, 0)$。\n5. 否则，找到所有满足 $H(i_{end}, j_{end}) = \\text{score}_{\\text{opt}}$ 的单元格 $(i_{end}, j_{end})$。\n6. 为路径计数初始化一个 $(n+1) \\times (m+1)$ 的记忆化表。\n7. 将总比对计数初始化为 $0$。对于每个 $(i_{end}, j_{end})$，使用带记忆化的递归函数计算 $\\text{count\\_paths}(i_{end}, j_{end})$，并将结果加到总计数中。\n8. 返回序对 $(\\text{score}_{\\text{opt}}, \\text{total count})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the alignment problem for all test cases.\n    \"\"\"\n    \n    # scoring model is fixed for all test cases\n    s_match = 2\n    s_mismatch = -1\n    g = -1\n    \n    # Test suite from the problem statement\n    test_cases = [\n        (\"AA\", \"AA\"),        # Case 1\n        (\"AG\", \"GA\"),        # Case 2\n        (\"ACA\", \"AAA\"),      # Case 3\n        (\"C\", \"A\"),          # Case 4\n        (\"AAA\", \"AA\"),       # Case 5\n    ]\n    \n    all_results = []\n    for seq_a, seq_b in test_cases:\n        score, count = smith_waterman_enumerator(seq_a, seq_b, s_match, s_mismatch, g)\n        all_results.extend([score, count])\n        \n    # Format the final output string exactly as specified.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef smith_waterman_enumerator(seq_a, seq_b, s_match, s_mismatch, g):\n    \"\"\"\n    Computes the optimal local alignment score and enumerates all equally optimal alignments.\n\n    Args:\n        seq_a (str): The first sequence.\n        seq_b (str): The second sequence.\n        s_match (int): The score for a match.\n        s_mismatch (int): The score for a mismatch.\n        g (int): The linear gap penalty.\n\n    Returns:\n        tuple[int, int]: A tuple containing the optimal score and the number of optimal alignments.\n    \"\"\"\n    n = len(seq_a)\n    m = len(seq_b)\n\n    # DP score matrix H\n    H = np.zeros((n + 1, m + 1), dtype=int)\n    \n    # Pointer matrix P to store traceback directions for tied scores\n    P = [[[] for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Substitution score function\n    def sigma(char_a, char_b):\n        return s_match if char_a == char_b else s_mismatch\n\n    # Fill the DP matrices H and P\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            score_diag = H[i-1, j-1] + sigma(seq_a[i-1], seq_b[j-1])\n            score_up = H[i-1, j] + g\n            score_left = H[i, j-1] + g\n            \n            max_score = max(0, score_diag, score_up, score_left)\n            H[i, j] = max_score\n            \n            if max_score  0:\n                if max_score == score_diag:\n                    P[i][j].append('D') # Diagonal\n                if max_score == score_up:\n                    P[i][j].append('U') # Up\n                if max_score == score_left:\n                    P[i][j].append('L') # Left\n\n    # Find the optimal score and its location(s)\n    optimal_score = np.max(H)\n    \n    # Per problem statement, if max score is 0, count is 0\n    if optimal_score == 0:\n        return 0, 0\n    \n    max_indices = np.argwhere(H == optimal_score)\n    \n    # Memoization table for path counting, initialized with -1 (unvisited)\n    counts_memo = np.full((n + 1, m + 1), -1, dtype=int)\n\n    def count_paths(i, j):\n        \"\"\"Recursively count paths with memoization.\"\"\"\n        if counts_memo[i, j] != -1:\n            return counts_memo[i, j]\n        \n        # Base case: traceback terminates at a cell with score 0\n        if H[i, j] == 0:\n            return 1\n            \n        current_count = 0\n        for direction in P[i][j]:\n            if direction == 'D':\n                current_count += count_paths(i - 1, j - 1)\n            elif direction == 'U':\n                current_count += count_paths(i - 1, j)\n            elif direction == 'L':\n                current_count += count_paths(i, j - 1)\n        \n        counts_memo[i, j] = current_count\n        return current_count\n\n    total_alignments = 0\n    for idx_pair in max_indices:\n        i_end, j_end = idx_pair\n        total_alignments += count_paths(i_end, j_end)\n        \n    return int(optimal_score), total_alignments\n\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2401709"}]}