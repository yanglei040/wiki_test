{"hands_on_practices": [{"introduction": "理论是重要的，但真正的理解来自于实践。让我们从一个基础计算开始，来掌握基于一致性比对的核心机制。这个练习将向你展示，如何利用一个中间序列（“桥梁”）的信息来加强另外两个序列之间特定残基对比的得分，即使它们最初的比对得分很低 [@problem_id:2381688]。这个简单的计算是 T-Coffee 等复杂算法的基石。", "problem": "在基于一致性的多序列比对方法“基于树的一致性目标函数用于比对评估 (Tree-based Consistency Objective Function For Alignment Evaluation, T-Coffee)”中，通过在三元序列组之间强制传递一致性来扩展配对比对得分库。考虑三个序列，分别表示为 $A$、$B$ 和 $C$，并设 $S(X_{i},Y_{j})$ 表示序列 $X$ 中第 $i$ 个残基位置与序列 $Y$ 中第 $j$ 个残基位置之间的初始文库权重（配对比对得分）。基于一致性的文库扩展通过根据以下公式累积来自序列 $B$ 中介位置的支持，定义了一个更新后的得分 $S'(A_{i},C_{k})$：\n$$\nS'(A_{i},C_{k}) \\equiv S(A_{i},C_{k}) + \\sum_{j} \\min\\!\\big(S(A_{i},B_{j}),\\, S(B_{j},C_{k})\\big).\n$$\n假设只有一个具有非零贡献的中介 $B_{j}$，且给定的初始得分为 $S(A_{i},B_{j})=10$ 和 $S(B_{j},C_{k})=10$，而原始的直接得分为 $S(A_{i},C_{k})=0$。在这些假设下，计算更新后的一致性得分 $S'(A_{i},C_{k})$。请以一个无单位的实数形式给出你的答案，无需四舍五入。", "solution": "题目要求在 T-Coffee 算法的框架内计算一个更新后的一致性得分，记为 $S'(A_{i},C_{k})$。该方法通过整合来自配对比对库的信息并强制传递一致性来优化多序列比对。\n\n用于基于一致性的文库扩展的控制方程如下：\n$$ S'(A_{i},C_{k}) \\equiv S(A_{i},C_{k}) + \\sum_{j} \\min\\!\\big(S(A_{i},B_{j}),\\, S(B_{j},C_{k})\\big) $$\n在此表达式中，$S(X_{i}, Y_{j})$ 是序列 $X$ 中残基 $i$ 与序列 $Y$ 中残基 $j$ 比对的初始文库权重或得分。更新后的得分 $S'(A_{i},C_{k})$ 是通过将直接比对得分 $S(A_{i},C_{k})$ 与一致性贡献的总和相加来计算的。总和中的每一项代表了通过第三个序列 $B$ 中的残基 $B_j$ 介导的对 $A_i$ 和 $C_k$ 比对的支持。该支持被量化为形成路径的两个配对得分 $S(A_{i},B_{j})$ 和 $S(B_{j},C_{k})$ 的最小值。\n\n题目给出了具体的约束条件和初始值：\n1.  初始直接比对得分给定为 $S(A_{i},C_{k}) = 0$。\n2.  存在“恰好一个具有非零贡献的中介 $B_{j}$”。这是一个关键的简化。让我们将这个唯一中介残基的索引表示为 $j_0$。这意味着对于任何其他残基索引 $j \\neq j_0$，项 $\\min\\!\\big(S(A_{i},B_{j}),\\, S(B_{j},C_{k})\\big)$ 等于 $0$。\n3.  涉及单个活性中介 $B_{j_0}$ 的路径得分为 $S(A_{i},B_{j_0}) = 10$ 和 $S(B_{j_0},C_{k}) = 10$。\n\n在这些条件下，对序列 $B$ 中所有可能的中介位置 $j$ 的求和简化为仅针对索引 $j_0$ 的单个非零项：\n$$ \\sum_{j} \\min\\!\\big(S(A_{i},B_{j}),\\, S(B_{j},C_{k})\\big) = \\min\\!\\big(S(A_{i},B_{j_0}),\\, S(B_{j_0},C_{k})\\big) + \\sum_{j \\neq j_0} 0 $$\n$$ = \\min\\!\\big(S(A_{i},B_{j_0}),\\, S(B_{j_0},C_{k})\\big) $$\n将这个简化的和代入更新后得分的原始方程中，我们得到：\n$$ S'(A_{i},C_{k}) = S(A_{i},C_{k}) + \\min\\!\\big(S(A_{i},B_{j_0}),\\, S(B_{j_0},C_{k})\\big) $$\n现在，我们可以将给定的数值代入这个表达式中。我们已知 $S(A_{i},C_{k}) = 0$，$S(A_{i},B_{j_0}) = 10$ 和 $S(B_{j_0},C_{k}) = 10$。\n\n首先，我们计算两个中介得分的最小值：\n$$ \\min(10, 10) = 10 $$\n这个值代表了从 $A_i$ 经过 $B_{j_0}$ 到 $C_k$ 的一致性路径的强度。\n\n最后，我们将此一致性贡献加到初始直接得分上，以求得更新后的得分 $S'(A_{i},C_{k})$：\n$$ S'(A_{i},C_{k}) = 0 + 10 $$\n因此，更新后的一致性得分为：\n$$ S'(A_{i},C_{k}) = 10 $$\n这个计算例证了 T-Coffee 方法如何能够基于两个残基与第三个中介残基的强一致性比对，来建立或加强这两个残基之间的比对得分，即使它们的初始直接比对得分为零。", "answer": "$$ \\boxed{10} $$", "id": "2381688"}, {"introduction": "理解了得分如何通过一致性得到加强后，下一个关键问题是：这种机制有什么实际优势？这个思想实验探讨了基于一致性方法最强大的功能之一：从充满噪声的数据中识别出可靠的信号 [@problem_id:2381633]。通过思考当一个序列集包含一个不相关的“冒名顶替者”时会发生什么，你将深入理解为什么一致性是构建鲁棒多序列比对的关键。", "problem": "给定一组蛋白质序列，表示为 $S_1, S_2, \\dots, S_{N}$，其中 $N \\geq 3$。序列 $S_1, \\dots, S_{N-1}$ 是进化上相关的同源序列。序列 $S_N$ 是通过取 $S_1$ 并对其残基进行随机排列而构建的，因此 $S_1$ 的所有残基在 $S_N$ 中都恰好出现一次，但顺序是随机的；因此，$S_N$ 保留了氨基酸组成，但破坏了位置同源性。\n\n考虑在这些序列上运行 T-Coffee。T-Coffee 首先通过比对所有序列对来构建一个由残基-残基配对约束组成的主库 $L$，并收集比对上的残基对，其初始权重反映了它们在成对比对中的支持度。然后它执行一个一致性扩展步骤：对于来自两个序列的任意一对残基 $x$ 和 $y$，如果存在第三个序列中的残基 $z$ 支持 $x \\sim z$ 和 $z \\sim y$，则 $x \\sim y$ 的权重会相应增加。最终的多序列比对是通过优先选择库权重较高的残基-残基对并惩罚冲突来生成的。\n\n哪个陈述最能描述置换序列引入的伪（spurious）残基-残基对对最终多序列比对的预期影响及其处理方式？\n\nA. 置换序列 $S_N$ 产生了许多不正确的残基-残基对，这些配对在一致性扩展过程中因为可以通过多个序列连接起来而得到强力加强，从而传播错误并显著降低 $S_1, \\dots, S_{N-1}$ 的比对质量。\n\nB. 涉及 $S_N$ 的不正确残基-残基对缺乏来自其他同源序列的传递性支持，因此在一致性扩展后权重较低；结果是，$S_1, \\dots, S_{N-1}$ 的比对在很大程度上保持稳定，而 $S_N$ 则被放置在有许多空位或支持度较弱的列中。\n\nC. 由于 $S_N$ 保留了残基组成，它与 $S_1$ 的全局比对几乎完美，并且一致性扩展放大了这些匹配，从而使 $S_N$ 最终与 $S_1$ 以及集合中的其余序列的比对几乎完全相同。\n\nD. T-Coffee 确定性地识别出 $S_N$ 是 $S_1$ 的一个置换，并在库构建之前将 $S_N$ 从分析中移除，因此最终的比对与从 $S_1, \\dots, S_{N-1}$ 生成的比对完全相同。\n\nE. 一致性扩展为所有残基-残基对分配统一的高权重以避免偏差，因此包含 $S_N$ 的影响仅取决于指导树而不是库。", "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n**步骤 1：提取已知条件**\n- 给定一组蛋白质序列，表示为 $S_1, S_2, \\dots, S_{N}$，其中 $N \\geq 3$。\n- 序列 $S_1, \\dots, S_{N-1}$ 是进化上相关的同源序列。\n- 序列 $S_N$ 是 $S_1$ 残基的一个随机置换。\n- $S_N$ 的属性：保留 $S_1$ 的氨基酸组成，但与 $S_1$ 或其他序列没有位置同源性。\n- T-Coffee 算法描述：\n    1. 通过所有成对比对构建一个由残基-残基配对约束组成的主库 $L$。初始权重反映了在这些比对中的支持度。\n    2. 执行一个一致性扩展步骤：对于一对残基 $x$ 和 $y$，如果存在另一个残基 $z$ 使得 $x \\sim z$ 和 $z \\sim y$ 得到支持，则对 $x \\sim y$ 的权重会增加。\n    3. 最终的多序列比对（MSA）是通过优先选择库权重高的配对来构建的。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题描述了 T-Coffee（Tree-based Consistency Objective Function for alignment Evaluation）算法的核心逻辑，这是一种在计算生物学中广泛使用且成熟的多序列比对方法。同源性、序列置换、成对比对和基于一致性的库扩展等概念都是标准的，并且描述准确。这个场景是一个精心设计的测试，用以考察对该算法抗噪声能力的理解。该问题在科学上是合理的。\n- **适定性**：问题陈述清晰。它提供了一组特定的输入并描述了算法的机制，要求预测预期的结果。这种结构允许得出一个唯一的、合乎逻辑的结论。\n- **客观性**：问题以精确、技术性的语言陈述，没有主观性或歧义。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。它具有科学依据、适定性好且客观。将根据 T-Coffee 算法的原理推导出解决方案。\n\n**解决方案推导**\nT-Coffee 算法分几个不同阶段运行，我们将在给定序列集的背景下分析这些阶段。\n\n1.  **主库构建**：T-Coffee 首先对输入序列 $\\{S_1, S_2, \\dots, S_N\\}$ 进行所有可能的成对比对。\n    -   **同源序列间的比对（$S_i$ vs $S_j$，其中 $i, j \\le N-1$）**：由于这些序列在进化上相关，它们的成对比对（例如，使用像 Needleman-Wunsch 或 Smith-Waterman 这样的动态规划算法）将具有高质量。它们将正确识别大量的直系同源残基对。这些配对将被添加到主库 $L$ 中，并具有相对较高的初始权重，反映了这些成对比对的高分。\n    -   **涉及置换序列的比对（$S_i$ vs $S_N$，其中 $i \\leq N-1$）**：序列 $S_N$ 是 $S_1$ 的一个随机置换。它与 $S_1$ 共享氨基酸组成，但没有位置同源性。$S_N$ 与任何其他序列 $S_i$（包括 $S_1$）的成对比对质量将非常差。比对算法会找到一些数学上的最优比对，但这将基于偶然的匹配和局部组成偏好，而不是真正的进化对应关系。由此产生的比对分数会很低，生成的残基-残基对将是伪的（即从生物学角度看是不正确的）。这些伪配对将被添加到库 $L$ 中，但初始权重非常低。\n\n2.  **一致性扩展**：这是区分 T-Coffee 的关键步骤。该算法评估库中每一对配对的一致性。对于给定的一对残基 $(x \\in S_i, y \\in S_j)$，其权重根据来自其他序列的传递性证据进行更新。新权重是所有可能的中间残基 $z \\in S_k$（其中 $k \\neq i, j$）所构成的配对 $(x, z)$ 和 $(z, y)$ 权重之和。\n    -   **对于一个正确的配对 $(x \\in S_i, y \\in S_j)$，其中 $i, j \\le N-1$**：因为序列 $S_1, \\dots, S_{N-1}$ 是同源的，对于大多数这样的正确配对，会存在一个相应的残基 $z \\in S_k$（其中 $k \\le N-1, k \\neq i, j$）也是同源的。因此，配对 $(x, z)$ 和 $(z, y)$ 将以高初始权重存在于主库中。对所有这些中间同源序列求和将导致原始配对 $(x, y)$ 的权重得到显著加强。真正的同源关系在同源序列集中是相互加强的。\n    -   **对于一个伪配对 $(x \\in S_i, w \\in S_N)$，其中 $i \\le N-1$**：要增加这个配对的权重，必须通过某个中间残基 $z \\in S_k$ 获得传递性支持。让我们考虑所需的支持配对：$(x, z)$ 和 $(z, w)$。\n        - 如果 $k \\le N-1$，配对 $(x, z)$ 可能是一个有效的、高权重的同源配对。然而，配对 $(z, w)$ 涉及置换序列 $S_N$。如前所述，涉及 $S_N$ 的配对是伪的，并且初始权重很低。\n        - 在不同的、不相关的成对比对中，仅凭纯粹的偶然机会找到一个与 $x$ 和 $w$ 都强力比对的残基 $z$ 的概率极低。\n        - 因此，任何涉及 $S_N$ 的伪配对的传递性支持将是微乎其微或不存在的。一致性扩展步骤将无法为这些配对找到一个强有力的证据网络。它们的权重将保持很低。\n\n3.  **最终 MSA 构建**：T-Coffee 使用最终的、扩展的加权配对库来指导多序列比对的构建，通常通过渐进式比对策略。其目标是构建一个能使所包含的残基配对权重之和最大化的 MSA。\n    -   对应于 $S_1, \\dots, S_{N-1}$ 之间真实同源关系的配对被赋予了非常高的权重。算法将极力优先满足这些约束。这意味着同源子集 $S_1, \\dots, S_{N-1}$ 的比对将是高质量的，并且在很大程度上不受 $S_N$ 存在的影响。\n    -   涉及 $S_N$ 的伪配对权重非常低。强行将 $S_N$ 与核心同源块对齐将需要打破该块内的许多高权重配对。算法会避免这种情况。相反，它会发现得分最高的比对是能有效隔离 $S_N$ 的比对，即在同源序列的比对良好列中为 $S_N$ 插入许多空位。$S_N$ 的比对将反映出它在库中缺乏一致的支持。\n\n**逐项分析**\n\n**A. 置换序列 $S_N$ 产生了许多不正确的残基-残基对，这些配对在一致性扩展过程中因为可以通过多个序列连接起来而得到强力加强，从而传播错误并显著降低 $S_1, \\dots, S_{N-1}$ 的比对质量。**\n该陈述不正确。一致性扩展的核心原则正是为了过滤掉这类噪声。伪配对缺乏从相关序列网络中获得的传递性支持，而这种支持是强力加强所必需的。因此，它们被降权，而不是被放大。\n\n**B. 涉及 $S_N$ 的不正确残基-残基对缺乏来自其他同源序列的传递性支持，因此在一致性扩展后权重较低；结果是，$S_1, \\dots, S_{N-1}$ 的比对在很大程度上保持稳定，而 $S_N$ 则被放置在有许多空位或支持度较弱的列中。**\n该陈述正确。它准确地描述了整个过程。涉及 $S_N$ 的伪配对缺乏传递性支持是关键机制。这导致这些配对的最终权重较低。因此，真正的同源序列 $S_1, \\dots, S_{N-1}$ 之间的高权重配对在最终比对构建中占主导地位，从而保持了它们的比对质量。$S_N$ 无法在不引入惩罚的情况下被整合，因此在最终的 MSA 中被边缘化，通常是通过引入许多空位来实现。\n\n**C. 由于 $S_N$ 保留了残基组成，它与 $S_1$ 的全局比对几乎完美，并且一致性扩展放大了这些匹配，从而使 $S_N$ 最终与 $S_1$ 以及集合中的其余序列的比对几乎完全相同。**\n该陈述不正确。序列比对依赖于位置保守性，而不仅仅是残基组成。一个随机置换将导致与原始序列的成对比对质量非常低。将没有强烈的初始匹配可供放大。\n\n**D. T-Coffee 确定性地识别出 $S_N$ 是 $S_1$ 的一个置换，并在库构建之前将 $S_N$ 从分析中移除，因此最终的比对与从 $S_1, \\dots, S_{N-1}$ 生成的比对完全相同。**\n该陈述不正确。T-Coffee 是一个基于成对信息处理多序列比对通用问题的算法。它不包含一个特定的、启发式的预处理步骤来检测序列间的置换或其他特殊情况关系。它通过其标准工作流程处理所有作为输入的序列。\n\n**E. 一致性扩展为所有残基-残基对分配统一的高权重以避免偏差，因此包含 $S_N$ 的影响仅取决于指导树而不是库。**\n该陈述不正确。它从根本上歪曲了一致性扩展步骤。该步骤的目的恰恰是根据库内部的支持程度来分配差异化的权重。权重库是整个 T-Coffee 方法的核心，包括最终的比对阶段。统一加权与 T-Coffee 的理念背道而驰。", "answer": "$$\\boxed{B}$$", "id": "2381633"}, {"introduction": "现在，你已经掌握了基本计算和核心概念，是时候将所有知识整合起来，亲手构建一个简化的预测模型了。这个编程练习将指导你从零开始，实现一个基于一致性的比对预测器，模拟 T-Coffee 算法的关键步骤 [@problem_id:2381655]。通过这个过程，你不仅能将理论转化为代码，还能通过具体的案例观察到，在某些情况下，即使是基于一致性的方法也可能被误导，从而对该技术的优势和局限性有更深刻的认识。", "problem": "基于 T-Coffee（Tree-based Consistency Objective Function For alignment Evaluation，基于树的一致性比对评估目标函数）方法的核心思想，从头开始设计并实现一个针对三条序列的、最小化的、基于一致性的多序列比对预测器。您的程序将使用成对全局比对来构建一个残基-残基库，然后通过一个中间序列应用单步一致性投影，以预测一个保守基序在两条目标序列间的位置。\n\n您必须遵循以下基础和定义进行操作：\n\n- 成对全局比对使用 Needleman–Wunsch 动态规划递推式计算，采用线性空位罚分。对于两条序列 $X = x_1 x_2 \\dots x_{L_X}$ 和 $Y = y_1 y_2 \\dots y_{L_Y}$，定义动态规划矩阵 $F$ 如下：\n$$\nF(0,0)=0,\\quad F(i,0)=i \\cdot g,\\quad F(0,j)=j \\cdot g,\n$$\n对于 $i \\ge 1$, $j \\ge 1$：\n$$\nF(i,j) = \\max\\left\\{\n\\begin{array}{l}\nF(i-1,j-1) + s(x_i,y_j),\\\\\nF(i-1,j) + g,\\\\\nF(i,j-1) + g\n\\end{array}\n\\right.\n$$\n计分方式为：若 $a=b$，则 $s(a,b)=+2$，否则 $s(a,b)=-1$；线性空位罚分 $g=-2$。在回溯过程中选择最大化前驱时，如果出现平局，您必须按照以下顺序确定性地打破平局：对角、然后向上、然后向左。\n\n- 根据 $X$ 和 $Y$ 的最优全局比对，构建一个形状为 $L_X \\times L_Y$ 的二元残基-残基权重矩阵 $w_{XY}$，其中当且仅当残基 $x_i$ 和 $y_j$ 在所选的最优比对中相互比对时（即，一个对角回溯步骤将它们对齐），$w_{XY}(i,j)=1$，否则 $w_{XY}(i,j)=0$。\n\n- 给定三条序列 $A$、$B$、$C$，定义从 $A$ 经由 $B$ 到 $C$ 的单步一致性投影分数为矩阵 $S$：\n$$\nS(i,j) = \\sum_{k=1}^{L_B} w_{AB}(i,k)\\cdot w_{BC}(k,j).\n$$\n\n- 假设一个长度为 $m$ 的保守基序 $M$ 在 $A$ 中出现一次，在 $C$ 中也恰好出现一次。设 $i_0$ 是 $M$ 在 $A$ 中的基于1的起始索引，$j^\\star$ 是 $M$ 在 $C$ 中的基于1的起始索引。定义将基序起始位置置于 $C$ 中位置 $j$ 的区块投影分数为：\n$$\nF_{\\text{block}}(j) = \\sum_{t=0}^{m-1} S(i_0+t,\\; j+t),\n$$\n适用于所有有效的 $j$，使得 $1 \\le j \\le L_C - m + 1$。预测的起始位置 $\\hat{j}$ 是使 $F_{\\text{block}}(j)$ 最大化的 $j$；如果出现平局，则选择最小的 $j$。\n\n- 定义错位指示符：如果 $\\hat{j} \\ne j^\\star$，则为 $1$，否则为 $0$。\n\n本问题中所有序列的长度均为 $L_A=L_B=L_C=10$（十个残基）。角度和物理单位不适用。所有输出均为无单位整数。\n\n请实现上述算法并评估以下测试集。每个测试用例提供长度为 $10$ 的序列 $A$、$B$、$C$ 和一个长度为 $m=3$ 的基序字符串 $M$，该基序将从 $A$ 经由 $B$ 投影到 $C$。对于每个用例，计算上面定义的错位指示符。\n\n- 用例 1（通过 $B$ 产生有意的误导性一致性）：\n  - $A=$ \"KKKWGYLLLQ\"\n  - $B=$ \"KKKRRRLLLQ\"\n  - $C=$ \"AAAWGYRRRR\"\n  - $M=$ \"WGY\"\n  - 原理：$A$ 和 $C$ 在其真实位置共享完全相同的基序 $M$，但 $B$ 引入了一个高分替代路径，可能将该基序投影到 $C$ 的一个错误区域。\n\n- 用例 2（理想情况，一致性与真实基序位置相符）：\n  - $A=$ \"KKKWGYLLLQ\"\n  - $B=$ \"KKKWGYLLLQ\"\n  - $C=$ \"AAAWGYRRRR\"\n  - $M=$ \"WGY\"\n\n- 用例 3（边界条件，基序位于起始位置）：\n  - $A=$ \"WGYLLLLLLL\"\n  - $B=$ \"WGYLLLLLLL\"\n  - $C=$ \"WGYRRRRRRR\"\n  - $M=$ \"WGY\"\n\n您的程序应生成单行输出，其中包含一个逗号分隔的整数列表，并用方括号括起来，结果按上述用例的顺序排列；例如，形如 \"[r1,r2,r3]\" 的输出，其中每个 $r_i \\in \\{0,1\\}$ 是用例 $i$ 的错位指示符。", "solution": "该问题是有效的，因为它在计算生物学原理上具有科学依据，所有必要的参数和打破平局的规则都已明确定义，且其表述是客观的。它要求实现一个受 T-Coffee 算法启发的、简化的一致性比对方法。\n\n解决方案的核心在于为每个测试用例执行一个多步骤过程，涉及表示为 $A$、$B$ 和 $C$ 的三个序列。\n\n首先，我们必须建立一个成对残基比对库。这通过使用 Needleman-Wunsch 动态规划算法对序列对 $(A, B)$ 和 $(B, C)$ 进行全局比对来实现。对于两个序列 $X = x_1 x_2 \\dots x_{L_X}$ 和 $Y = y_1 y_2 \\dots y_{L_Y}$，该算法计算一个大小为 $(L_X+1) \\times (L_Y+1)$ 的分数矩阵 $F$。该矩阵初始化为 $F(0,0)=0$，$F(i,0)=i \\cdot g$（对于 $i>0$），以及 $F(0,j)=j \\cdot g$（对于 $j>0$），其中 $g=-2$ 是线性空位罚分。对于 $i \\ge 1, j \\ge 1$ 的递推关系是：\n$$\nF(i,j) = \\max\\left\\{\n\\begin{array}{l}\nF(i-1,j-1) + s(x_i,y_j)\\\\\nF(i-1,j) + g\\\\\nF(i,j-1) + g\n\\end{array}\n\\right.\n$$\n计分函数 $s(a,b)$ 定义为：匹配（$a=b$）时为 $+2$，错配（$a \\ne b$）时为 $-1$。在计算过程中，我们还存储指针以确定每个单元格最大分数的来源，这用于回溯阶段。指定的中断平局规则（对角、然后向上、然后向左）确保了唯一的最优比对。\n\n其次，从通过自 $F(L_X, L_Y)$ 回溯得到的最优比对路径中，我们构建一个二元残基-残基权重矩阵 $w_{XY}$。这个形状为 $L_X \\times L_Y$ 的矩阵是比对的简明表示。如果残基 $x_i$ 与残基 $y_j$ 在最优比对中对齐（对应于回溯中的对角移动），则条目 $w_{XY}(i,j)$ 设置为 $1$；否则，$w_{XY}(i,j)=0$。为两个序列对都生成这些矩阵，得到 $w_{AB}$ 和 $w_{BC}$。\n\n第三，我们应用单步一致性原则。T-Coffee 方法利用来自多个成对比对的信息来指导多序列比对。在这个简化模型中，我们将来自序列对 $(A, B)$ 和 $(B, C)$ 的比对信息进行投影，以推断 $A$ 和 $C$ 之间的关系。一致性投影分数矩阵 $S$ 计算为两个权重矩阵的乘积：\n$$\nS(i,j) = \\sum_{k=1}^{L_B} w_{AB}(i,k) \\cdot w_{BC}(k,j)\n$$\n值 $S(i,j)$ 表示在序列 $B$ 中，在其各自的成对比对中同时与残基 $A_i$ 和残基 $C_j$ 比对的残基数量。非零分数意味着存在一条从 $A_i$ 到 $C_j$ 经由序列 $B$ 的一致比对路径。\n\n第四，我们使用一致性矩阵 $S$ 来预测一个长度为 $m$ 的保守基序 $M$ 的位置。给定该基序在序列 $A$ 中的已知起始位置 $i_0$，我们评估该基序在序列 $C$ 中每个可能位置 $j$ 开始的可能性。这是通过计算一个区块投影分数 $F_{\\text{block}}(j)$ 来完成的，该分数对基序长度范围内的所有一致性分数求和：\n$$\nF_{\\text{block}}(j) = \\sum_{t=0}^{m-1} S(i_0+t, j+t)\n$$\n这个计算针对 $C$ 中所有有效的起始位置 $j$（从 $1$ 到 $L_C - m + 1$）进行。较高的 $F_{\\text{block}}(j)$ 表示有更强的一致性证据支持将基序的起始位置放在 $j$ 处。\n\n最后，在 $C$ 中预测的基序起始位置，记为 $\\hat{j}$，是使 $F_{\\text{block}}(j)$ 最大化的位置 $j$。如果出现平局，则选择最小的 $j$。然后将这个预测值 $\\hat{j}$ 与基序的真实起始位置 $j^\\star$进行比较。如果 $\\hat{j} \\ne j^\\star$，则错位指示符设置为 $1$；如果它们相等，则设置为 $0$。对每个提供的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It implements a simplified T-Coffee consistency-based prediction.\n    \"\"\"\n\n    # --- Algorithm Parameters ---\n    MATCH_SCORE = 2\n    MISMATCH_SCORE = -1\n    GAP_PENALTY = -2\n\n    def get_score(res1, res2):\n        \"\"\"Calculates match/mismatch score.\"\"\"\n        return MATCH_SCORE if res1 == res2 else MISMATCH_SCORE\n\n    def needleman_wunsch_traceback(seq1, seq2):\n        \"\"\"\n        Performs global alignment using Needleman-Wunsch and returns a list of\n        1-based index pairs for aligned residues.\n        \"\"\"\n        L1, L2 = len(seq1), len(seq2)\n        F = np.zeros((L1 + 1, L2 + 1))\n        # Pointer matrix: 0=diagonal, 1=up, 2=left\n        P = np.zeros((L1 + 1, L2 + 1), dtype=int)\n\n        # Initialize DP matrix\n        for i in range(L1 + 1):\n            F[i, 0] = i * GAP_PENALTY\n        for j in range(L2 + 1):\n            F[0, j] = j * GAP_PENALTY\n            \n        # Fill DP and Pointer matrices\n        for i in range(1, L1 + 1):\n            for j in range(1, L2 + 1):\n                s_val = get_score(seq1[i - 1], seq2[j - 1])\n                diag_score = F[i - 1, j - 1] + s_val\n                up_score = F[i - 1, j] + GAP_PENALTY\n                left_score = F[i, j - 1] + GAP_PENALTY\n                \n                max_score = max(diag_score, up_score, left_score)\n                F[i, j] = max_score\n                \n                # Tie-breaking rule: diagonal > up > left\n                if diag_score == max_score:\n                    P[i, j] = 0\n                elif up_score == max_score:\n                    P[i, j] = 1\n                else:\n                    P[i, j] = 2\n        \n        # Traceback to find aligned pairs\n        aligned_pairs = []\n        i, j = L1, L2\n        while i > 0 and j > 0:\n            ptr = P[i, j]\n            if ptr == 0:  # Diagonal move\n                aligned_pairs.append((i, j))\n                i -= 1\n                j -= 1\n            elif ptr == 1:  # Up move\n                i -= 1\n            else:  # Left move\n                j -= 1\n        \n        return aligned_pairs\n\n    def build_weight_matrix(seq1_len, seq2_len, aligned_pairs):\n        \"\"\"Builds the binary residue-residue weight matrix from aligned pairs.\"\"\"\n        w = np.zeros((seq1_len, seq2_len), dtype=int)\n        for i_1based, j_1based in aligned_pairs:\n            # Convert 1-based alignment indices to 0-based matrix indices\n            w[i_1based - 1, j_1based - 1] = 1\n        return w\n\n    def solve_case(A, B, C, M):\n        \"\"\"\n        Solves for a single test case and returns the incorrect placement indicator.\n        \"\"\"\n        L_A, L_B, L_C = len(A), len(B), len(C)\n        m = len(M)\n\n        # 1. Compute pairwise alignments and corresponding weight matrices\n        aligned_pairs_AB = needleman_wunsch_traceback(A, B)\n        w_AB = build_weight_matrix(L_A, L_B, aligned_pairs_AB)\n        \n        aligned_pairs_BC = needleman_wunsch_traceback(B, C)\n        w_BC = build_weight_matrix(L_B, L_C, aligned_pairs_BC)\n\n        # 2. Compute the consistency projection score matrix S\n        S = np.dot(w_AB, w_BC)\n\n        # 3. Find true motif locations (1-based)\n        i_0 = A.find(M) + 1\n        j_star = C.find(M) + 1\n\n        # 4. Compute block projection scores F_block(j) for all possible starts in C\n        f_block_scores = []\n        # j is the 1-based start position in C. Loop from 1 to L_C - m + 1\n        possible_j_starts = range(1, L_C - m + 2)\n        \n        for j_1based in possible_j_starts:\n            score = 0\n            for t in range(m):\n                # Convert 1-based formula indices to 0-based matrix indices\n                idx_A = (i_0 + t) - 1\n                idx_C = (j_1based + t) - 1\n                score += S[idx_A, idx_C]\n            f_block_scores.append(score)\n\n        # 5. Find predicted start j_hat\n        # list.index finds the first occurrence of max, fulfilling the tie-breaking rule\n        max_score = max(f_block_scores) if f_block_scores else -1\n        # The index in the scores list corresponds to a 1-based j\n        # Index 0 -> j=1, Index 1 -> j=2, etc.\n        predicted_idx = f_block_scores.index(max_score)\n        j_hat = predicted_idx + 1\n\n        # 6. Compute and return the incorrect placement indicator\n        indicator = 1 if j_hat != j_star else 0\n        return indicator\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"KKKWGYLLLQ\", \"KKKRRRLLLQ\", \"AAAWGYRRRR\", \"WGY\"),\n        (\"KKKWGYLLLQ\", \"KKKWGYLLLQ\", \"AAAWGYRRRR\", \"WGY\"),\n        (\"WGYLLLLLLL\", \"WGYLLLLLLL\", \"WGYRRRRRRR\", \"WGY\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, B, C, M = case\n        result = solve_case(A, B, C, M)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2381655"}]}