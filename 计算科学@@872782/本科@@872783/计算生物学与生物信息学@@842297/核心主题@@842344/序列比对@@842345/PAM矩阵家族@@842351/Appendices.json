{"hands_on_practices": [{"introduction": "PAM 矩阵中的分值并非凭空产生，它们深刻地反映了演化的基本过程。本练习将引导你探索遗传密码结构与氨基酸替换频率之间的内在联系。通过分析单个核苷酸突变的可及性，你将亲手验证一个核心的演化原则：更容易发生的突变是否真的对应着更高的 PAM 替换分数。[@problem_id:2411854]", "problem": "点接受突变 (PAM) 家族中的氨基酸替换评分矩阵，量化了在接受点突变的进化模型下，观察到两个氨基酸之间发生替换的对数几率。标准遗传密码的结构限制了哪些氨基酸变化可以通过密码子中的单核苷酸点突变实现。\n\n考虑以下四种氨基酸及其在标准遗传密码中的密码子集（使用 DNA 字母表）：\n- Tryptophan (W): TGG\n- Cysteine (C): TGT, TGC\n- Lysine (K): AAA, AAG\n- Phenylalanine (F): TTT, TTC\n\n如果第一个氨基酸的至少一个密码子与第二个氨基酸的至少一个密码子仅在一个核苷酸位置上不同（汉明距离为 $1$），则定义这两个氨基酸是单核苷酸可达的。\n\n给定一个对称的、源自 PAM1 的对数几率评分矩阵 $S$，该矩阵仅限于这四种氨基酸（只列出非对角线元素；$S$ 是对称的，且此处不使用 $S(a,a)$）：\n- $S(\\mathrm{W},\\mathrm{C})=-0.3$\n- $S(\\mathrm{C},\\mathrm{F})=0.2$\n- $S(\\mathrm{W},\\mathrm{F})=-0.8$\n- $S(\\mathrm{W},\\mathrm{K})=-1.4$\n- $S(\\mathrm{C},\\mathrm{K})=-1.0$\n- $S(\\mathrm{K},\\mathrm{F})=-0.7$\n\n令 $\\mathcal{P}$ 为来自 $\\{\\mathrm{W},\\mathrm{C},\\mathrm{K},\\mathrm{F}\\}$ 的所有无序氨基酸对的集合，因此 $|\\mathcal{P}|=6$。将 $\\mathcal{P}$ 划分为 $\\mathcal{R}$（单核苷酸可达的对）和 $\\mathcal{N}$（不可达的对）。对无序对使用相等权重，定义平均得分为\n$$\\mu_{\\mathcal{R}}=\\frac{1}{|\\mathcal{R}|}\\sum_{(a,b)\\in\\mathcal{R}} S(a,b), \\quad \\mu_{\\mathcal{N}}=\\frac{1}{|\\mathcal{N}|}\\sum_{(a,b)\\in\\mathcal{N}} S(a,b)。$$\n计算差值\n$$\\Delta=\\mu_{\\mathcal{R}}-\\mu_{\\mathcal{N}}.$$\n\n报告 $\\Delta$ 的值，四舍五入到四位有效数字。不需要单位。", "solution": "问题陈述已经过严格验证，并被认定为有效。它具有科学依据，问题设定良好，客观且内部一致。我们将着手进行解答。\n\n问题要求我们将氨基酸 $\\{\\mathrm{W}, \\mathrm{C}, \\mathrm{K}, \\mathrm{F}\\}$ 的所有无序对集合划分为两个不相交的子集：$\\mathcal{R}$，包含单核苷酸可达的氨基酸对；以及 $\\mathcal{N}$，包含不可达的氨基酸对。随后，我们必须计算这两个集合的平均对数几率得分之差。\n\n首先，我们必须确定哪些对是单核苷酸可达的。定义指出，如果两种氨基酸各自至少有一个密码子，其汉明距离恰好为 $1$，则它们是单核苷酸可达的。给定的氨基酸及其在标准 DNA 遗传密码中的密码子如下：\n- Tryptophan ($\\mathrm{W}$): $\\mathrm{TGG}$\n- Cysteine ($\\mathrm{C}$): $\\mathrm{TGT}$, $\\mathrm{TGC}$\n- Lysine ($\\mathrm{K}$): $\\mathrm{AAA}$, $\\mathrm{AAG}$\n- Phenylalanine ($\\mathrm{F}$): $\\mathrm{TTT}$, $\\mathrm{TTC}$\n\n我们检查 $\\binom{4}{2} = 6$ 个无序对中的每一个：\n\n1.  **对 ($\\mathrm{W}, \\mathrm{C}$):**\n    - W 的密码子：$\\mathrm{TGG}$。\n    - C 的密码子：$\\mathrm{TGT}$、$\\mathrm{TGC}$。\n    - 比较 $\\mathrm{TGG}$ 和 $\\mathrm{TGT}$，汉明距离为 $1$（在第 $3$ 个位置上不同）。\n    - 因此，对 $(\\mathrm{W, C})$ 是单核苷酸可达的。$(\\mathrm{W, C}) \\in \\mathcal{R}$。\n\n2.  **对 ($\\mathrm{W}, \\mathrm{K}$):**\n    - W 的密码子：$\\mathrm{TGG}$。\n    - K 的密码子：$\\mathrm{AAA}$、$\\mathrm{AAG}$。\n    - 比较 $\\mathrm{TGG}$ 和 $\\mathrm{AAA}$，汉明距离为 $3$。\n    - 比较 $\\mathrm{TGG}$ 和 $\\mathrm{AAG}$，汉明距离为 $2$。\n    - 因此，对 $(\\mathrm{W, K})$ 不是单核苷酸可达的。$(\\mathrm{W, K}) \\in \\mathcal{N}$。\n\n3.  **对 ($\\mathrm{W}, \\mathrm{F}$):**\n    - W 的密码子：$\\mathrm{TGG}$。\n    - F 的密码子：$\\mathrm{TTT}$、$\\mathrm{TTC}$。\n    - 比较 $\\mathrm{TGG}$ 和 $\\mathrm{TTT}$，汉明距离为 $2$。\n    - 比较 $\\mathrm{TGG}$ 和 $\\mathrm{TTC}$，汉明距离为 $2$。\n    - 因此，对 $(\\mathrm{W, F})$ 不是单核苷酸可达的。$(\\mathrm{W, F}) \\in \\mathcal{N}$。\n\n4.  **对 ($\\mathrm{C}, \\mathrm{K}$):**\n    - C 的密码子：$\\mathrm{TGT}$、$\\mathrm{TGC}$。\n    - K 的密码子：$\\mathrm{AAA}$、$\\mathrm{AAG}$。\n    - 所有密码子比较得到的汉明距离都为 $2$ 或 $3$。例如，$\\mathrm{TGT}$ 与 $\\mathrm{AAG}$ 的距离为 $2$。\n    - 因此，对 $(\\mathrm{C, K})$ 不是单核苷酸可达的。$(\\mathrm{C, K}) \\in \\mathcal{N}$。\n\n5.  **对 ($\\mathrm{C}, \\mathrm{F}$):**\n    - C 的密码子：$\\mathrm{TGT}$、$\\mathrm{TGC}$。\n    - F 的密码子：$\\mathrm{TTT}$、$\\mathrm{TTC}$。\n    - 比较 $\\mathrm{TGT}$ 和 $\\mathrm{TTT}$，汉明距离为 $1$（在第 $2$ 个位置上不同）。\n    - 因此，对 $(\\mathrm{C, F})$ 是单核苷酸可达的。$(\\mathrm{C, F}) \\in \\mathcal{R}$。\n\n6.  **对 ($\\mathrm{K}, \\mathrm{F}$):**\n    - K 的密码子：$\\mathrm{AAA}$、$\\mathrm{AAG}$。\n    - F 的密码子：$\\mathrm{TTT}$、$\\mathrm{TTC}$。\n    - 所有密码子比较得到的汉明距离都为 $2$ 或 $3$。例如，$\\mathrm{AAG}$ 与 $\\mathrm{TTC}$ 的距离为 $2$。\n    - 因此，对 $(\\mathrm{K, F})$ 不是单核苷酸可达的。$(\\mathrm{K, F}) \\in \\mathcal{N}$。\n\n根据此分析，划分如下：\n- $\\mathcal{R} = \\{(\\mathrm{W}, \\mathrm{C}), (\\mathrm{C}, \\mathrm{F})\\}$，所以 $|\\mathcal{R}| = 2$。\n- $\\mathcal{N} = \\{(\\mathrm{W}, \\mathrm{K}), (\\mathrm{W}, \\mathrm{F}), (\\mathrm{C}, \\mathrm{K}), (\\mathrm{K}, \\mathrm{F})\\}$，所以 $|\\mathcal{N}| = 4$。\n\n接下来，我们使用给定的评分矩阵 $S$ 计算平均得分 $\\mu_{\\mathcal{R}}$ 和 $\\mu_{\\mathcal{N}}$。\n在 $\\mathcal{R}$ 中可达对的得分是 $S(\\mathrm{W},\\mathrm{C}) = -0.3$ 和 $S(\\mathrm{C},\\mathrm{F}) = 0.2$。\n$\\mathcal{R}$ 的平均得分为：\n$$ \\mu_{\\mathcal{R}} = \\frac{1}{|\\mathcal{R}|} \\sum_{(a,b)\\in\\mathcal{R}} S(a,b) = \\frac{1}{2} (S(\\mathrm{W},\\mathrm{C}) + S(\\mathrm{C},\\mathrm{F})) = \\frac{1}{2} (-0.3 + 0.2) = \\frac{-0.1}{2} = -0.05 $$\n\n在 $\\mathcal{N}$ 中不可达对的得分是 $S(\\mathrm{W},\\mathrm{K}) = -1.4$、$S(\\mathrm{W},\\mathrm{F}) = -0.8$、$S(\\mathrm{C},\\mathrm{K}) = -1.0$ 和 $S(\\mathrm{K},\\mathrm{F}) = -0.7$。\n$\\mathcal{N}$ 的平均得分为：\n$$ \\mu_{\\mathcal{N}} = \\frac{1}{|\\mathcal{N}|} \\sum_{(a,b)\\in\\mathcal{N}} S(a,b) = \\frac{1}{4} (S(\\mathrm{W},\\mathrm{K}) + S(\\mathrm{W},\\mathrm{F}) + S(\\mathrm{C},\\mathrm{K}) + S(\\mathrm{K},\\mathrm{F})) $$\n$$ \\mu_{\\mathcal{N}} = \\frac{1}{4} (-1.4 - 0.8 - 1.0 - 0.7) = \\frac{1}{4} (-3.9) = -0.975 $$\n\n最后，我们计算差值 $\\Delta = \\mu_{\\mathcal{R}} - \\mu_{\\mathcal{N}}$：\n$$ \\Delta = (-0.05) - (-0.975) = -0.05 + 0.975 = 0.925 $$\n\n题目要求答案四舍五入到四位有效数字。数值 $0.925$ 有三位有效数字。为了将其表示为四位有效数字，我们在末尾添加一个零。\n$$ \\Delta \\approx 0.9250 $$\n这一结果表明，平均而言，在该数据集中，可通过单核苷酸突变到达的氨基酸对的对数几率得分显著高于不可达的氨基酸对，这与单步突变比多步突变更可能发生的进化原理相一致。", "answer": "$$\\boxed{0.9250}$$", "id": "2411854"}, {"introduction": "从 $PAM_1$ 矩阵推导远距离演化的 $PAM_N$ 矩阵是序列比对中的一个常见任务，但当 $N$ 很大时，直接进行矩阵乘法不仅效率低下，还可能导致数值不稳定。本练习将带你实践一种更优雅且高效的计算方法——矩阵特征分解。通过这项练习，你将掌握如何利用线性代数的强大工具，来精确计算长时间尺度下的演化概率。[@problem_id:2411821]", "problem": "给定一个在简化的氨基酸字母表上的离散时间、时齐马尔可夫链。该字母表包含四个类别，根据物理化学相似性对氨基酸进行分组。记为一个演化步骤的单次接受突变转移概率矩阵 $M \\in \\mathbb{R}^{4 \\times 4}$，具体如下：\n$$\nM \\;=\\;\n\\begin{bmatrix}\n0.99  0.002  0.004  0.004\\\\\n0.002  0.99  0.004  0.004\\\\\n0.004  0.004  0.99  0.002\\\\\n0.004  0.004  0.002  0.99\n\\end{bmatrix}.\n$$\n在点接受突变 (Point Accepted Mutation, PAM) 替换矩阵家族中，$N$ 步替换概率矩阵定义为：\n$$\nPAM_{N} \\;=\\; M^{N},\n$$\n其中 $N \\in \\mathbb{N}$ 是单步接受突变区间的数量。\n\n任务：对于每个指定的 $N$，以数值稳定的方式计算 $PAM_{N}$ 的左上角元素（第一行，第一列）。将每个报告值使用标准四舍五入到小数点后 $10$ 位。\n\n指数测试集：\n- $N = 0$,\n- $N = 1$,\n- $N = 2$,\n- $N = 10$,\n- $N = 500$.\n\n答案规格：\n- 对于上述顺序中的每个 $N$，输出 $PAM_{N}$ 的左上角元素，作为一个四舍五入到小数点后 $10$ 位的浮点数。\n- 你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表。例如，如果结果是 $x_{0}, x_{1}, \\dots, x_{k}$，则输出格式必须是：\n$$\n[x_{0},x_{1},\\dots,x_{k}].\n$$\n不应打印任何其他文本。", "solution": "该问题已经过验证，被确定为是合理的。它在科学上基于应用于分子演化的马尔可夫链理论，在数学上是适定的，并且其所有术语和条件都得到了客观且无矛盾的规定。\n\n问题的核心是为一个给定的 $4 \\times 4$ 转移概率矩阵 $M$ 和几个整数指数 $N$ 计算矩阵的幂 $M^N$。任务是找出结果矩阵的左上角元素 $(M^N)_{11}$。一种通过将 $M$ 自身迭代乘以 $N-1$ 次的朴素方法，对于大的 $N$（例如 $N=500$）而言计算效率低下，并且可能导致浮点误差的累积。要求“以数值稳定的方式”计算表明需要一种更复杂、更稳健的方法。计算矩阵幂的首选方法是特征分解。\n\n给定的转移矩阵是\n$$\nM \\;=\\;\n\\begin{bmatrix}\n0.99  0.002  0.004  0.004\\\\\n0.002  0.99  0.004  0.004\\\\\n0.004  0.004  0.99  0.002\\\\\n0.004  0.004  0.002  0.99\n\\end{bmatrix}.\n$$\n这个矩阵是对称的。对于对称矩阵，存在一个正交矩阵 $P$ 和一个对角矩阵 $D$，使得 $M = PDP^T$。$P$ 的列是 $M$ 的标准正交特征向量，$D$ 的对角线元素是对应的特征值。矩阵的幂 $M^N$ 随后可以高效地计算为：\n$$\nM^N = (PDP^T)^N = PD(P^T P)D(P^T P) \\dots D P^T = PD^N P^T.\n$$\n由于 $D$ 是对角矩阵，$D^N$ 可以通过将其对角线元素（即特征值）提升到 $N$ 次幂来简单求得。\n\n首先，我们求出 $M$ 的特征值和特征向量。设该矩阵表示为\n$$\nM =\n\\begin{bmatrix}\na  b  c  c\\\\\nb  a  c  c\\\\\nc  c  a  b\\\\\nc  c  b  a\n\\end{bmatrix}\n$$\n其中 $a = 0.99$, $b = 0.002$, and $c = 0.004$。特征方程是 $\\det(M - \\lambda I)=0$。由于矩阵的结构，我们可以通过观察来确定特征向量。\n特征值 $\\lambda_i$ 和一组对应的正交特征向量基 $v_i$ 是：\n\\begin{enumerate}\n    \\item 对于 $\\lambda_1 = a+b+2c = 0.99 + 0.002 + 2(0.004) = 1$，特征向量是 $v_1 = [1, 1, 1, 1]^T$。\n    \\item 对于特征值 $\\lambda_2 = a-b = 0.99 - 0.002 = 0.988$（重数为2），其特征空间由正交向量 $v_2 = [1, -1, 0, 0]^T$ 和 $v_3 = [0, 0, 1, -1]^T$ 张成。\n    \\item 对于 $\\lambda_4 = a+b-2c = 0.99 + 0.002 - 2(0.004) = 0.984$，特征向量是 $v_4 = [1, 1, -1, -1]^T$。\n\\end{enumerate}\n将这些特征向量归一化，得到一组标准正交基 $\\{u_1, u_2, u_3, u_4\\}$：\n$u_1 = \\frac{1}{2}[1, 1, 1, 1]^T$\n$u_2 = \\frac{1}{\\sqrt{2}}[1, -1, 0, 0]^T$\n$u_3 = \\frac{1}{\\sqrt{2}}[0, 0, 1, -1]^T$\n$u_4 = \\frac{1}{2}[1, 1, -1, -1]^T$\n\n$M^N$ 的谱分解由下式给出：\n$$\nM^N = \\lambda_1^N P_1 + \\lambda_2^N P_2 + \\lambda_4^N P_4\n$$\n其中 $P_i$ 是到特征空间上的投影矩阵。\n对于非简并特征值 $\\lambda_1=1$ 和 $\\lambda_4=0.984$，投影算子为 $P_1 = u_1 u_1^T$ 和 $P_4 = u_4 u_4^T$。\n对于简并特征值 $\\lambda_2=0.988$，投影算子为 $P_2 = u_2 u_2^T + u_3 u_3^T$。\n\n我们需要求元素 $(M^N)_{11}$，即第一个标准基向量 $e_1=[1,0,0,0]^T$ 与 $M^N e_1$ 的点积。\n$$\n(M^N)_{11} = e_1^T M^N e_1 = \\lambda_1^N (e_1^T u_1 u_1^T e_1) + \\lambda_2^N (e_1^T (u_2 u_2^T + u_3 u_3^T) e_1) + \\lambda_4^N (e_1^T u_4 u_4^T e_1).\n$$\n这可以简化为\n$$\n(M^N)_{11} = \\lambda_1^N (u_{1,1})^2 + \\lambda_2^N ((u_{2,1})^2 + (u_{3,1})^2) + \\lambda_4^N (u_{4,1})^2,\n$$\n其中 $u_{i,1}$ 是特征向量 $u_i$ 的第一个分量。\n代入分量：\n$u_{1,1} = 1/2$\n$u_{2,1} = 1/\\sqrt{2}$\n$u_{3,1} = 0$\n$u_{4,1} = 1/2$\n\n因此，我们得到解析表达式：\n$$\n(M^N)_{11} = (1)^N \\left(\\frac{1}{2}\\right)^2 + (0.988)^N \\left( \\left(\\frac{1}{\\sqrt{2}}\\right)^2 + 0^2 \\right) + (0.984)^N \\left(\\frac{1}{2}\\right)^2\n$$\n$$\n(M^N)_{11} = 0.25 \\cdot (1)^N + 0.5 \\cdot (0.988)^N + 0.25 \\cdot (0.984)^N\n$$\n这个公式为计算任何 $N$ 所需的值提供了一种直接、高效且数值稳定的方法。问题陈述 $N \\in \\mathbb{N}$，且测试用例包括 $N=0$。我们假定自然数的标准定义包含零（$\\mathbb{N} = \\{0, 1, 2, \\ldots\\}$）。\n\n现在我们将此公式应用于指定的 $N$ 值：\n\\begin{itemize}\n    \\item 对于 $N=0$：$(M^0)_{11} = 0.25 + 0.5 + 0.25 = 1.0$。这是正确的，因为 $M^0$ 是单位矩阵 $I$。\n    \\item 对于 $N=1$：$(M^1)_{11} = 0.25 + 0.5(0.988) + 0.25(0.984) = 0.25 + 0.494 + 0.246 = 0.99$。正确。\n    \\item 对于 $N=2$：$(M^2)_{11} = 0.25 + 0.5(0.988)^2 + 0.25(0.984)^2 = 0.25 + 0.5(0.976144) + 0.25(0.968256) = 0.980136$。\n    \\item 对于 $N=10$：$(M^{10})_{11} = 0.25 + 0.5(0.988)^{10} + 0.25(0.984)^{10} \\approx 0.9057967600$。\n    \\item 对于 $N=500$：$(M^{500})_{11} = 0.25 + 0.5(0.988)^{500} + 0.25(0.984)^{500} \\approx 0.2512842902$。\n\\end{itemize}\n当 $N \\to \\infty$ 时，由于对于 $i=2,4$ 有 $|\\lambda_i|  1$，项 $(0.988)^N$ 和 $(0.984)^N$ 趋近于 $0$。因此，$\\lim_{N \\to \\infty} (M^N)_{11} = 0.25$。这对应于马尔可夫链的平稳分布，该分布是均匀的，即 $\\pi = [0.25, 0.25, 0.25, 0.25]$。\n\n最终值使用推导出的公式计算，并四舍五入到小数点后 $10$ 位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the top-left entry of the N-step substitution probability matrix PAM_N.\n    \"\"\"\n    # Test suite of exponents as specified in the problem statement.\n    test_cases = [0, 1, 2, 10, 500]\n\n    # The analytical formula for the (1,1) entry of M^N is derived from the\n    # eigendecomposition of the matrix M. The formula is:\n    # (M^N)_11 = 0.25 * (1)^N + 0.5 * (0.988)^N + 0.25 * (0.984)^N\n    # This is numerically stable and computationally efficient.\n    \n    # Eigenvalues from the derivation\n    lambda_2 = 0.988\n    lambda_4 = 0.984\n\n    results = []\n    for N in test_cases:\n        # Calculate the value using the derived analytical formula.\n        # The term with eigenvalue 1 simplifies to 0.25.\n        value = 0.25 + 0.5 * (lambda_2 ** N) + 0.25 * (lambda_4 ** N)\n        \n        # Format the result to 10 decimal places as specified.\n        # The f-string format specifier handles standard rounding correctly.\n        results.append(f\"{value:.10f}\")\n\n    # Final print statement in the exact required format.\n    # The output is a single line with a comma-separated list in brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2411821"}, {"introduction": "在掌握了基本原理和计算技巧之后，是时候将所有知识融会贯通，构建一个完整的、可用于任意演化距离的氨基酸替换评分系统了。本练习模拟了现代生物信息学中从头构建评分矩阵的完整流程，从定义基础的替换速率矩阵 $\\mathbf{Q}$ 到校准 PAM 时间单位，再到最终生成任意距离 $d$ 下的对数优势比分矩阵 $S_{ij}(d)$。完成这项挑战将让你对演化模型的构建和应用有更深刻的理解。[@problem_id:2411852]", "problem": "给定一个有限的氨基酸字母表和一个连续时间、时齐性、可逆的氨基酸替换马尔可夫模型。目标是对于任意正实值 PAM 距离 $d  0$，计算以比特为单位的对数几率评分矩阵 $PAM_d$。$PAM_d$ 矩阵的元素 $S_{ij}(d)$ 量化了在 PAM 距离为 $d$ 时，给定起始氨基酸 $i$ 的情况下，在同源位置观察到氨基酸 $j$ 的对数几率（以 2 为底），该几率是相对于随机比对背景而言的。\n\n使用以下设置。\n\n- 字母表顺序和背景频率（总和为 $1$）：\n  $$\\Sigma = [A, R, N, D, C], \\quad \\mathbf{p} = [0.30, 0.20, 0.20, 0.20, 0.10].$$\n\n- 对称可交换性矩阵 $\\mathbf{R}$（其中 $R_{ii} = 0$ 且当 $i \\neq j$ 时 $R_{ij} = R_{ji}$）。行和列的顺序与 $\\Sigma$ 匹配：\n  $$\n  \\mathbf{R} =\n  \\begin{bmatrix}\n  0  1.0  0.7  0.5  0.05 \\\\\n  1.0  0  0.8  0.4  0.05 \\\\\n  0.7  0.8  0  1.2  0.05 \\\\\n  0.5  0.4  1.2  0  0.02 \\\\\n  0.05  0.05  0.05  0.02  0\n  \\end{bmatrix}.\n  $$\n\n- 使用详细平衡条件以及 $\\mathbf{p}$ 和 $\\mathbf{R}$ 构建瞬时速率矩阵 $\\mathbf{Q}$：\n  $$q_{ij} = R_{ij}\\,p_j \\quad \\text{for } i \\neq j, \\qquad q_{ii} = -\\sum_{j \\neq i} q_{ij}.$$\n\n- 将 $\\mathbf{Q}$ 校准至百分比可接受突变 (PAM) 时间单位，使得每个位点在单位 PAM 距离内发生的预期可接受替换数为 $0.01$。令\n  $$\\rho = -\\sum_{i=1}^{5} p_i\\, q_{ii}, \\quad \\text{并定义缩放后的速率矩阵 } \\tilde{\\mathbf{Q}} = \\frac{0.01}{\\rho}\\,\\mathbf{Q}。$$\n\n- 对于任意实数 $d > 0$，将在 PAM 距离 $d$ 处的替换概率矩阵定义为矩阵指数\n  $$\\mathbf{P}(d) = \\exp\\big(\\tilde{\\mathbf{Q}}\\, d\\big)。$$\n\n- 将以比特为单位的对数几率评分矩阵定义为\n  $$S_{ij}(d) = \\log_2 \\left( \\frac{P_{ij}(d)}{p_j} \\right), \\quad \\text{for all } i,j \\in \\{1,\\dots,5\\}.$$\n\n您的任务是根据上述定义，实现一个程序来构建适用于任何实数 $d > 0$ 的 $PAM_d = \\big[S_{ij}(d)\\big]$ 矩阵。\n\n测试集：\n对于下方的每个测试用例，请使用字母表顺序 $\\Sigma = [A,R,N,D,C]$，返回指定 $d$ 和有序氨基酸对 $(i,j)$ 的单个条目 $S_{ij}(d)$。不涉及角度或物理单位。将每个数值答案报告为四舍五入到小数点后六位的浮点数。\n\n- 测试 1 (近同一性区间): $d = 0.01$，配对 $(A,A)$。\n- 测试 2 (中等距离，错配): $d = 1.0$，配对 $(A,R)$。\n- 测试 3 (长距离，收敛): $d = 250.0$，配对 $(N,C)$。\n- 测试 4 (边界，极小距离): $d = 10^{-6}$，配对 $(D,D)$。\n- 测试 5 (中等距离，典型错配): $d = 50.0$，配对 $(R,N)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按测试 1 到 5 的顺序排列的结果，结果为逗号分隔的列表，并用方括号括起来。例如，\n$$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5],$$\n其中每个 $\\text{result}_k$ 都是按规定四舍五入到小数点后六位的浮点数。", "solution": "所述问题是有效的。这是一个适定且有科学依据的计算生物学练习，基于序列进化的连续时间马尔可夫模型的既定原理。所有必要的数据和定义都已提供，并且它们内部是一致的。任务是实现指定的数学过程。\n\n解决方案按以下计算顺序进行。\n\n1.  **构建瞬时速率矩阵 $\\mathbf{Q}$**：\n    速率矩阵 $\\mathbf{Q}$ 的元素由对称可交换性矩阵 $\\mathbf{R}$ 和背景频率 $\\mathbf{p} = [p_A, p_R, p_N, p_D, p_C]^T = [0.30, 0.20, 0.20, 0.20, 0.10]^T$ 确定。非对角线元素由 $q_{ij} = R_{ij} p_j$（$i \\neq j$）给出。对角线元素被设定为使每行之和为零：$q_{ii} = -\\sum_{j \\neq i} q_{ij}$。对于字母表 $\\Sigma = [A, R, N, D, C]$，使用所提供的 $\\mathbf{R}$ 和 $\\mathbf{p}$，可得到以下矩阵：\n    $$\n    \\mathbf{Q} =\n    \\begin{bmatrix}\n    -0.445  0.200  0.140  0.100  0.005 \\\\\n     0.300  -0.545  0.160  0.080  0.005 \\\\\n     0.210  0.160  -0.615  0.240  0.005 \\\\\n     0.150  0.080  0.240  -0.472  0.002 \\\\\n     0.015  0.010  0.010  0.004  -0.039\n    \\end{bmatrix}\n    $$\n    该矩阵满足详细平衡条件 $p_i q_{ij} = p_j q_{ji}$，这证实了 $\\mathbf{p}$ 是由 $\\mathbf{Q}$ 所描述的马尔可夫过程的平稳分布。\n\n2.  **校准至 PAM 时间单位**：\n    矩阵 $\\mathbf{Q}$ 必须进行缩放，以符合百分比可接受突变 (PAM) 距离的定义，其中 1 个 PAM 单位对应每个位点预期发生 0.01 次替换。由 $\\mathbf{Q}$ 控制的过程的平均替换速率计算为 $\\rho = -\\sum_{i} p_i q_{ii}$。\n    使用给定值：\n    $$ \\rho = - (0.30(-0.445) + 0.20(-0.545) + 0.20(-0.615) + 0.20(-0.472) + 0.10(-0.039)) $$\n    $$ \\rho = -(-0.1335 - 0.1090 - 0.1230 - 0.0944 - 0.0039) = 0.4638 $$\n    然后通过缩放 $\\mathbf{Q}$ 以使平均替换率为 $0.01$ 来获得校准后的速率矩阵 $\\tilde{\\mathbf{Q}}$：\n    $$ \\tilde{\\mathbf{Q}} = \\frac{0.01}{\\rho} \\mathbf{Q} = \\frac{0.01}{0.4638} \\mathbf{Q} \\approx 0.02156101768... \\times \\mathbf{Q} $$\n\n3.  **计算替换概率矩阵 $\\mathbf{P}(d)$**：\n    对于给定的 PAM 距离 $d  0$，替换概率矩阵 $\\mathbf{P}(d)$ 通过计算缩放后速率矩阵与距离的乘积的矩阵指数来得到：\n    $$ \\mathbf{P}(d) = \\exp(\\tilde{\\mathbf{Q}} d) $$\n    此计算使用标准的数值库函数执行，特别是使用 `scipy.linalg.expm` 来计算矩阵指数。\n\n4.  **计算对数几率分数 $S_{ij}(d)$**：\n    最后，计算在 PAM 距离 $d$ 处氨基酸 $i$ 与氨基酸 $j$ 比对的对数几率分数。该分数以比特为单位，量化了观察到的替换 $P_{ij}(d)$ 的可能性相对于随机观察到氨基酸 $j$ 的背景概率 $p_j$ 的比值。\n    $$ S_{ij}(d) = \\log_2 \\left( \\frac{P_{ij}(d)}{p_j} \\right) $$\n\n该过程被实现并应用于五个指定的测试用例。氨基酸 $[A, R, N, D, C]$ 的索引分别为 $[0, 1, 2, 3, 4]$。为每个测试用例计算所需的值 $S_{ij}(d)$，并按照问题陈述的要求进行格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes log-odds scores for a continuous-time Markov model of amino acid substitution.\n    \"\"\"\n    # Define the problem parameters as specified.\n    alphabet = ['A', 'R', 'N', 'D', 'C']\n    p = np.array([0.30, 0.20, 0.20, 0.20, 0.10])\n    R = np.array([\n        [0.0, 1.0, 0.7, 0.5, 0.05],\n        [1.0, 0.0, 0.8, 0.4, 0.05],\n        [0.7, 0.8, 0.0, 1.2, 0.05],\n        [0.5, 0.4, 1.2, 0.0, 0.02],\n        [0.05, 0.05, 0.05, 0.02, 0.0]\n    ])\n    \n    # Create a mapping from amino acids to matrix indices.\n    aa_to_idx = {aa: i for i, aa in enumerate(alphabet)}\n    \n    # Step 1: Construct the instantaneous rate matrix Q.\n    n_states = len(alphabet)\n    Q = np.zeros((n_states, n_states))\n    \n    # Off-diagonal elements are q_{ij} = R_{ij} * p_j.\n    for i in range(n_states):\n        for j in range(n_states):\n            if i != j:\n                Q[i, j] = R[i, j] * p[j]\n    \n    # Diagonal elements are set so that rows sum to zero.\n    for i in range(n_states):\n        Q[i, i] = -np.sum(Q[i, :])\n        \n    # Step 2: Calibrate Q to the PAM time unit.\n    # The average rate of substitution is rho = -sum(p_i * q_ii).\n    rho = -np.dot(p, np.diag(Q))\n    \n    # The scaled rate matrix ensures 0.01 expected substitutions per PAM unit.\n    Q_tilde = (0.01 / rho) * Q\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'d': 0.01, 'pair': ('A', 'A')},    # Test 1\n        {'d': 1.0, 'pair': ('A', 'R')},     # Test 2\n        {'d': 250.0, 'pair': ('N', 'C')},   # Test 3\n        {'d': 1e-6, 'pair': ('D', 'D')},    # Test 4\n        {'d': 50.0, 'pair': ('R', 'N')}     # Test 5\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        d = case['d']\n        i_char, j_char = case['pair']\n        i = aa_to_idx[i_char]\n        j = aa_to_idx[j_char]\n        \n        # Step 3: Compute the substitution probability matrix P(d) = exp(Q_tilde * d).\n        P_d = expm(Q_tilde * d)\n        \n        # Step 4: Calculate the log-odds score S_ij(d) in bits.\n        P_ij_d = P_d[i, j]\n        p_j = p[j]\n        \n        score = np.log2(P_ij_d / p_j)\n        results.append(score)\n        \n    # Format the final output as a comma-separated list of floating-point numbers\n    # rounded to six decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2411852"}]}