{"hands_on_practices": [{"introduction": "自动注释的可靠性很少能通过单一证据来判断。一个更稳健的方法是整合来自不同数据源的信号，例如序列同源性、蛋白质结构域和酶学分类。本练习将指导你设计一个量化的不一致性评分系统，通过加权组合多种证据来自动标记那些与大部分可用信息相矛盾的注释，从而有效地将它们提交给专家进行审查。[@problem_id:2383758]", "problem": "您正在评估一个自动化蛋白质功能注释的可靠性，其背景是人工校正注释与自动化注释的对比。对于每个蛋白质，您会获得从数据库中提取的抽象证据，这些证据可以表示为数值和集合论对象。请根据基本原则定义一个定量的非一致性分数，并决定是否应将该自动化注释标记出来以供校正者审查。此外，请提供一个最小化的理由代码列表，以指明哪些证据流独立地支持标记该注释的决定。\n\n设自动化标签表示为 $\\mathcal{L}_a$（除了等价性比较外，不使用 $\\mathcal{L}_a$ 的任何特定结构）。对于每个蛋白质实例，您将获得以下输入：\n\n- 加权同源性一致性列表：$N = [(w_1,a_1),\\ldots,(w_k,a_k)]$，其中每个 $w_i \\in [0,1]$ 且 $\\sum_{i=1}^k w_i = 1$，而 $a_i \\in \\{0,1\\}$ 表示第 $i$ 个最近同源物的校正功能是否与 $\\mathcal{L}_a$ 一致（$a_i=1$）或不一致（$a_i=0$）。\n- 类InterPro结构域支持计数：$(s_{\\text{supp}}, s_{\\text{conf}}) \\in \\mathbb{N}_0 \\times \\mathbb{N}_0$，其中 $s_{\\text{supp}}$ 是支持 $\\mathcal{L}_a$ 的结构域数量，而 $s_{\\text{conf}}$ 是与 $\\mathcal{L}_a$ 矛盾的结构域数量。\n- 酶学委员会（EC）证据集：$A$ 是自动化流程预测的EC标识符集合；$C$ 是在严格标准下，在校正数据库中观察到的同源物的EC标识符集合。每个EC标识符是一个整数四元组，例如 $(1,1,1,1)$。\n- 定位不匹配指示符：$l \\in \\{0,1\\}$，如果预测的亚细胞定位与用 $\\mathcal{L}_a$ 注释的蛋白质的校正定位分布不一致，则 $l=1$，否则 $l=0$。\n- 分类学约束违规：$t \\in \\{0,1\\}$，如果 $\\mathcal{L}_a$ 违反了已知的分类学约束（例如，该功能在给定的谱系中未知），则 $t=1$，否则 $t=0$。\n- 基于名称的警示标志：$n \\in \\{0,1\\}$，如果自动化名称包含校正者在特定功能注释中避免使用的术语（例如，当声称一个非常具体的 $\\mathcal{L}_a$ 时，却使用“hypothetical protein”或“putative”），则 $n=1$，否则 $n=0$。\n\n根据基本原则定义以下量：\n\n1. 加权同源性不一致性：\n$$\nh \\;=\\; \\sum_{i=1}^{k} w_i \\cdot (1 - a_i).\n$$\n\n2. 结构域矛盾比率：\n$$\nd \\;=\\; \\begin{cases}\n0,  \\text{if } s_{\\text{supp}} + s_{\\text{conf}} = 0, \\\\[6pt]\n\\dfrac{s_{\\text{conf}}}{s_{\\text{supp}} + s_{\\text{conf}}},  \\text{otherwise}.\n\\end{cases}\n$$\n\n3. 酶学委员会不匹配度（EC标识符集合上的Jaccard距离）：\n$$\ne \\;=\\; \\begin{cases}\n0,  \\text{if } |A \\cup C| = 0, \\\\[6pt]\n1 \\;-\\; \\dfrac{|A \\cap C|}{|A \\cup C|},  \\text{otherwise}.\n\\end{cases}\n$$\n\n4. 使用如上定义的 $l$、$t$ 和 $n$。\n\n将非一致性分数 $S$ 定义为这些项的凸组合：\n$$\nS \\;=\\; \\alpha h + \\beta d + \\gamma e + \\delta l + \\zeta t + \\eta n,\n$$\n权重固定为\n$$\n\\alpha = 0.3,\\quad \\beta = 0.25,\\quad \\gamma = 0.2,\\quad \\delta = 0.1,\\quad \\zeta = 0.1,\\quad \\eta = 0.05.\n$$\n\n决策规则：当且仅当自动化注释满足以下条件时，将其标记为可能错误：\n$$\nS \\;\\ge\\; \\tau,\n$$\n阈值为 $\\tau = 0.5$。\n\n理由代码：提供一个最小的整数代码集合 $J$，用以指明哪些独立的证据流各自支持标记，使用以下标准：\n\n- 代码 $1$：如果 $h \\ge 0.5$ 则包含。\n- 代码 $2$：如果 $d \\ge 0.5$ 则包含。\n- 代码 $3$：如果 $e \\ge 0.5$ 则包含。\n- 代码 $4$：如果 $l = 1$ 则包含。\n- 代码 $5$：如果 $t = 1$ 则包含。\n- 代码 $6$：如果 $n = 1$ 则包含。\n\n您的任务是为下面的每个测试用例计算三元组 $[s,f,j]$，其中 $s$ 是四舍五入到四位小数的 $S$ 值，$f$ 是根据上述规则的布尔决策， $j$ 是按升序排列的理由代码列表。不涉及物理单位。不使用角度。所有数值答案必须是十进制数。布尔值必须打印为字面量 True 或 False。\n\n测试套件（五个用例）：\n\n- 用例 $1$：\n  - $N = [(0.4,0),(0.3,0),(0.2,1),(0.1,0)]$。\n  - $(s_{\\text{supp}}, s_{\\text{conf}}) = (1,3)$。\n  - $A = \\{(1,1,1,1)\\}$, $C = \\{(2,7,1,1),(1,1,1,2)\\}$。\n  - $l = 1$, $t = 1$, $n = 0$。\n\n- 用例 $2$：\n  - $N = [(0.5,1),(0.2,1),(0.2,1),(0.1,1)]$。\n  - $(s_{\\text{supp}}, s_{\\text{conf}}) = (4,0)$。\n  - $A = \\{(3,5,1,4)\\}$, $C = \\{(3,5,1,4)\\}$。\n  - $l = 0$, $t = 0$, $n = 0$。\n\n- 用例 $3$：\n  - $N = [(0.6,1),(0.4,0)]$。\n  - $(s_{\\text{supp}}, s_{\\text{conf}}) = (0,0)$。\n  - $A = \\varnothing$, $C = \\varnothing$。\n  - $l = 1$, $t = 0$, $n = 0$。\n\n- 用例 $4$：\n  - $N = [(0.5,0),(0.3,1),(0.2,1)]$。\n  - $(s_{\\text{supp}}, s_{\\text{conf}}) = (3,2)$。\n  - $A = \\{(1,2,3,4),(2,3,4,5),(3,4,5,6)\\}$,\n    $C = \\{(1,2,3,4),(2,3,4,5),(3,4,5,6),(9,9,9,9)\\}$。\n  - $l = 1$, $t = 1$, $n = 0$。\n\n- 用例 $5$：\n  - $N = [(0.7,1),(0.2,1),(0.1,1)]$。\n  - $(s_{\\text{supp}}, s_{\\text{conf}}) = (0,5)$。\n  - $A = \\{(1,1,1,1),(2,2,2,2)\\}$, $C = \\{(1,1,1,1),(2,2,2,3)\\}$。\n  - $l = 1$, $t = 0$, $n = 1$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，输出三元组 $[s,f,j]$，其中 $s$ 四舍五入到四位小数，$f$ 是一个布尔字面量，$j$ 是按升序排列的理由代码列表。例如，总输出必须看起来像 $[[s_1,f_1,j_1],[s_2,f_2,j_2],\\ldots,[s_5,f_5,j_5]]$，在单行中，无任何附加文本。", "solution": "问题陈述需经过验证。\n\n**步骤1：提取给定信息**\n\n给定信息如下：\n- 加权同源性一致性列表 $N = [(w_1,a_1),\\ldots,(w_k,a_k)]$，其中 $w_i \\in [0,1]$，$\\sum_{i=1}^k w_i = 1$，且 $a_i \\in \\{0,1\\}$。\n- 结构域支持计数 $(s_{\\text{supp}}, s_{\\text{conf}}) \\in \\mathbb{N}_0 \\times \\mathbb{N}_0$。\n- 酶学委员会（EC）证据集 $A$ 和 $C$，其元素为整数四元组。\n- 定位不匹配（$l$）、分类学违规（$t$）和基于名称的警示标志（$n$）的二进制指示符，均在 $\\{0,1\\}$ 中。\n- 中间分数的定义：\n  - 加权同源性不一致性：$h = \\sum_{i=1}^{k} w_i \\cdot (1 - a_i)$。\n  - 结构域矛盾比率：如果 $s_{\\text{supp}} + s_{\\text{conf}} \\neq 0$，则 $d = \\frac{s_{\\text{conf}}}{s_{\\text{supp}} + s_{\\text{conf}}}$，否则 $d=0$。\n  - 酶学委员会不匹配度（Jaccard距离）：如果 $|A \\cup C| \\neq 0$，则 $e = 1 - \\frac{|A \\cap C|}{|A \\cup C|}$，否则 $e=0$。\n- 总非一致性分数 $S$ 是一个凸组合：$S = \\alpha h + \\beta d + \\gamma e + \\delta l + \\zeta t + \\eta n$。\n- 权重是固定的：$\\alpha = 0.3$，$\\beta = 0.25$，$\\gamma = 0.2$，$\\delta = 0.1$，$\\zeta = 0.1$，$\\eta = 0.05$。它们的总和为 $1$。\n- 决策规则是如果 $S \\ge \\tau$，则标记该注释，阈值 $\\tau = 0.5$。\n- 理由代码列表 $J$ 是一个最小的代码集 $\\{1,2,3,4,5,6\\}$，对应于满足各自阈值的单个证据流：$h \\ge 0.5$，$d \\ge 0.5$，$e \\ge 0.5$，$l=1$，$t=1$，$n=1$。\n- 提供了五个具体的测试用例，包含所有必要的输入数据。\n\n**步骤2：使用提取的给定信息进行验证**\n\n根据验证标准对问题进行评估：\n- **科学依据**：该问题基于生物信息学中用于蛋白质功能注释的标准证据类型（同源性、蛋白质结构域、EC编号、定位、分类学）构建了一个启发式评分模型。其数学公式使用了加权和与Jaccard距离，这是此类模型的常规且适当的方法。这是一个简化但科学上合理的抽象。\n- **良构的**：该问题是确定性的和自包含的。所有变量、常量、函数和决策规则都得到了明确的定义。每个测试用例的输入都是完整的。这确保可以计算出唯一且稳定的解。\n- **客观性**：该问题以精确的数学和逻辑术语陈述，没有主观性或歧义。\n\n该问题没有缺陷。它在科学上不是不合理的，也不是非形式化的、不完整的、矛盾的、不切实际的或不良构的。\n\n**步骤3：结论与行动**\n\n该问题是**有效的**。将提供一个完整的解决方案。\n\n**解题过程**\n\n任务是为五个测试用例中的每一个计算三元组 $[s, f, j]$，其中 $s$ 是四舍五入到小数点后四位的分数 $S$，$f$ 是布尔标记决策，$j$ 是排序后的理由代码列表。每个用例的计算过程如下。\n\n**用例 1：**\n- 输入：$N = [(0.4,0),(0.3,0),(0.2,1),(0.1,0)]$，$(s_{\\text{supp}}, s_{\\text{conf}}) = (1,3)$，$A = \\{(1,1,1,1)\\}$, $C = \\{(2,7,1,1),(1,1,1,2)\\}$，$l = 1$, $t = 1$, $n = 0$。\n- $h = 0.4(1-0) + 0.3(1-0) + 0.2(1-1) + 0.1(1-0) = 0.4 + 0.3 + 0.0 + 0.1 = 0.8$。\n- $d = \\frac{3}{1+3} = 0.75$。\n- $A \\cap C = \\varnothing$，因此 $|A \\cap C| = 0$。$A \\cup C = \\{(1,1,1,1), (2,7,1,1), (1,1,1,2)\\}$，因此 $|A \\cup C| = 3$。\n- $e = 1 - \\frac{0}{3} = 1.0$。\n- $S = 0.3(0.8) + 0.25(0.75) + 0.2(1.0) + 0.1(1) + 0.1(1) + 0.05(0) = 0.24 + 0.1875 + 0.2 + 0.1 + 0.1 = 0.8275$。\n- $s = 0.8275$。因为 $S=0.8275 \\ge 0.5$，所以 $f=\\text{True}$。\n- 理由代码：$h=0.8 \\ge 0.5$ (代码 $1$)，$d=0.75 \\ge 0.5$ (代码 $2$)，$e=1.0 \\ge 0.5$ (代码 $3$)，$l=1$ (代码 $4$)，$t=1$ (代码 $5$) 。$j = [1, 2, 3, 4, 5]$。\n- 结果：$[0.8275, \\text{True}, [1, 2, 3, 4, 5]]$。\n\n**用例 2：**\n- 输入：$N = [(0.5,1),(0.2,1),(0.2,1),(0.1,1)]$，$(s_{\\text{supp}}, s_{\\text{conf}}) = (4,0)$，$A = \\{(3,5,1,4)\\}$, $C = \\{(3,5,1,4)\\}$，$l = 0$, $t = 0$, $n = 0$。\n- 所有 $a_i=1$，所以 $h = 0$。\n- $s_{\\text{conf}}=0$，所以 $d = \\frac{0}{4+0} = 0$。\n- $A \\cap C = A = C$，所以 $|A \\cap C|=1$ 且 $|A \\cup C|=1$。\n- $e = 1 - \\frac{1}{1} = 0$。\n- $l=0$, $t=0$, $n=0$。\n- 所有项均为 $0$，因此 $S = 0$。\n- $s = 0.0000$。因为 $S=0  0.5$，所以 $f=\\text{False}$。\n- 理由代码：没有一个标准被满足。$j = []$。\n- 结果：$[0.0000, \\text{False}, []]$。\n\n**用例 3：**\n- 输入：$N = [(0.6,1),(0.4,0)]$，$(s_{\\text{supp}}, s_{\\text{conf}}) = (0,0)$，$A = \\varnothing$, $C = \\varnothing$，$l = 1$, $t = 0$, $n = 0$。\n- $h = 0.6(1-1) + 0.4(1-0) = 0.4$。\n- $s_{\\text{supp}} + s_{\\text{conf}} = 0$，所以 $d=0$。\n- $|A \\cup C| = 0$，所以 $e=0$。\n- $S = 0.3(0.4) + 0.25(0) + 0.2(0) + 0.1(1) + 0.1(0) + 0.05(0) = 0.12 + 0.1 = 0.22$。\n- $s = 0.2200$。因为 $S=0.22  0.5$，所以 $f=\\text{False}$。\n- 理由代码：只有 $l=1$ 满足其标准（代码 $4$）。$j = [4]$。\n- 结果：$[0.2200, \\text{False}, [4]]$。\n\n**用例 4：**\n- 输入：$N = [(0.5,0),(0.3,1),(0.2,1)]$，$(s_{\\text{supp}}, s_{\\text{conf}}) = (3,2)$，$A = \\{(1,2,3,4),(2,3,4,5),(3,4,5,6)\\}$, $C = \\{(1,2,3,4),(2,3,4,5),(3,4,5,6),(9,9,9,9)\\}$，$l = 1$, $t = 1$, $n = 0$。\n- $h = 0.5(1-0) + 0.3(1-1) + 0.2(1-1) = 0.5$。\n- $d = \\frac{2}{3+2} = 0.4$。\n- $|A|=3$，$|C|=4$。$A \\subset C$。所以 $|A \\cap C| = 3$ 且 $|A \\cup C|=4$。\n- $e = 1 - \\frac{3}{4} = 0.25$。\n- $S = 0.3(0.5) + 0.25(0.4) + 0.2(0.25) + 0.1(1) + 0.1(1) + 0.05(0) = 0.15 + 0.1 + 0.05 + 0.1 + 0.1 = 0.5$。\n- $s = 0.5000$。因为 $S=0.5 \\ge 0.5$，所以 $f=\\text{True}$。\n- 理由代码：$h=0.5 \\ge 0.5$ (代码 $1$)，$l=1$ (代码 $4$)，$t=1$ (代码 $5$) 。$j = [1, 4, 5]$。\n- 结果：$[0.5000, \\text{True}, [1, 4, 5]]$。\n\n**用例 5：**\n- 输入：$N = [(0.7,1),(0.2,1),(0.1,1)]$，$(s_{\\text{supp}}, s_{\\text{conf}}) = (0,5)$，$A = \\{(1,1,1,1),(2,2,2,2)\\}$, $C = \\{(1,1,1,1),(2,2,2,3)\\}$，$l = 1$, $t = 0$, $n = 1$。\n- 所有 $a_i=1$，所以 $h = 0$。\n- $d = \\frac{5}{0+5} = 1.0$。\n- $A \\cap C = \\{(1,1,1,1)\\}$，所以 $|A \\cap C| = 1$。$A \\cup C = \\{(1,1,1,1),(2,2,2,2),(2,2,2,3)\\}$，所以 $|A \\cup C|=3$。\n- $e = 1 - \\frac{1}{3} \\approx 0.3333...$\n- $S = 0.3(0) + 0.25(1.0) + 0.2(1/3) + 0.1(1) + 0.1(0) + 0.05(1) = 0.25 + 0.0666... + 0.1 + 0.05 = 0.4 + 1/15 \\approx 0.4666...$\n- $s = 0.4667$。因为 $S \\approx 0.4667  0.5$，所以 $f=\\text{False}$。\n- 理由代码：$d=1.0 \\ge 0.5$ (代码 $2$)，$l=1$ (代码 $4$)，$n=1$ (代码 $6$) 。$j = [2, 4, 6]$。\n- 结果：$[0.4667, \\text{False}, [2, 4, 6]]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of evaluating automated protein function annotation reliability.\n    \"\"\"\n    \n    # Weights for the inconsistency score\n    weights = {\n        'alpha': 0.3,\n        'beta': 0.25,\n        'gamma': 0.2,\n        'delta': 0.1,\n        'zeta': 0.1,\n        'eta': 0.05\n    }\n    \n    # Decision threshold\n    tau = 0.5\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            'N': [(0.4, 0), (0.3, 0), (0.2, 1), (0.1, 0)],\n            's_counts': (1, 3),\n            'A': {(1, 1, 1, 1)},\n            'C': {(2, 7, 1, 1), (1, 1, 1, 2)},\n            'l': 1, 't': 1, 'n': 0\n        },\n        # Case 2\n        {\n            'N': [(0.5, 1), (0.2, 1), (0.2, 1), (0.1, 1)],\n            's_counts': (4, 0),\n            'A': {(3, 5, 1, 4)},\n            'C': {(3, 5, 1, 4)},\n            'l': 0, 't': 0, 'n': 0\n        },\n        # Case 3\n        {\n            'N': [(0.6, 1), (0.4, 0)],\n            's_counts': (0, 0),\n            'A': set(),\n            'C': set(),\n            'l': 1, 't': 0, 'n': 0\n        },\n        # Case 4\n        {\n            'N': [(0.5, 0), (0.3, 1), (0.2, 1)],\n            's_counts': (3, 2),\n            'A': {(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)},\n            'C': {(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6), (9, 9, 9, 9)},\n            'l': 1, 't': 1, 'n': 0\n        },\n        # Case 5\n        {\n            'N': [(0.7, 1), (0.2, 1), (0.1, 1)],\n            's_counts': (0, 5),\n            'A': {(1, 1, 1, 1), (2, 2, 2, 2)},\n            'C': {(1, 1, 1, 1), (2, 2, 2, 3)},\n            'l': 1, 't': 0, 'n': 1\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # 1. Weighted homology disagreement (h)\n        h = sum(w * (1 - a) for w, a in case['N'])\n\n        # 2. Domain contradiction ratio (d)\n        s_supp, s_conf = case['s_counts']\n        s_total = s_supp + s_conf\n        d = s_conf / s_total if s_total > 0 else 0\n\n        # 3. Enzyme Commission mismatch (e)\n        A, C = case['A'], case['C']\n        union_size = len(A.union(C))\n        intersection_size = len(A.intersection(C))\n        e = 1 - (intersection_size / union_size) if union_size > 0 else 0\n\n        # 4. Other indicators (l, t, n)\n        l, t, n = case['l'], case['t'], case['n']\n\n        # Calculate inconsistency score S\n        S = (weights['alpha'] * h +\n             weights['beta'] * d +\n             weights['gamma'] * e +\n             weights['delta'] * l +\n             weights['zeta'] * t +\n             weights['eta'] * n)\n\n        # Decision rule\n        f = S >= tau\n        \n        # Justification codes\n        j = []\n        if h >= 0.5:\n            j.append(1)\n        if d >= 0.5:\n            j.append(2)\n        if e >= 0.5:\n            j.append(3)\n        if l == 1:\n            j.append(4)\n        if t == 1:\n            j.append(5)\n        if n == 1:\n            j.append(6)\n        \n        # Store the result triple\n        s = round(S, 4)\n        results.append([s, f, j])\n\n    # Final print statement in the exact required format.\n    result_strings = []\n    for s_val, f_val, j_val in results:\n        # Format the float to 4 decimal places even if integer-like (e.g., 0.5000)\n        s_str = f\"{s_val:.4f}\"\n        result_strings.append(f\"[{s_str},{f_val},{j_val}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2383758"}, {"introduction": "生物功能并非随机出现，而是受到生物体进化历史的深刻制约。本练习将运用系统发育的核心概念——简约性原则——来识别那些在生物学上不合理的注释。你将学习如何利用物种树来评估一项注释是否需要额外的、不简约的进化事件才能成立，从而标记出像“在动物中进行光合作用”这样不合逻辑的断言。[@problem_id:2383796]", "problem": "一个自动注释流程将一个人类蛋白质赋予了功能字符串“叶绿素生物合成”。请设计并实现一个基于系统发育的健全性检查算法，该算法仅使用有根物种树上经过审定的功能存在集，以及在该树上最小化状态变化的简约性原则，来标记此类功能分配为不合理。\n\n使用的基本事实：共同血缘进化意味着性状和基因功能沿物种树继承；分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质）约束了基因功能映射到生物体的能力；简约性原则（奥卡姆剃刀）假定，在多种进化重构方案中，状态变化较少的方案更优。不假设使用其他专门公式。\n\n数学形式化：令有根树表示为 $T$，其叶节点用物种名称标记。对于一个生物学功能 $f$，令 $P_f \\subseteq L(T)$ 表示经专家审定已知拥有功能 $f$ 的叶节点的集合。通过将状态 $1$ 分配给 $P_f$ 中的叶节点，状态 $0$ 分配给所有其他叶节点，在 $L(T)$ 上定义一个二元性状。对于任何此类分配，令 $C(P_f)$ 表示在 Fitch 简约性分析下，解释 $T$ 上观察到的状态所需的状态变化（获得或丢失）的最小数量。对于一个声称物种 $q \\in L(T)$ 拥有功能 $f$ 的提议注释，定义系统发育不一致性分数\n$$D(q,f) = C\\big(P_f \\cup \\{q\\}\\big) - C(P_f).$$\n直观地看，$D(q,f)$ 是为了容纳该声明，树必须承受的额外变化数量。健全性检查规则是：当且仅当 $D(q,f) \\ge \\tau$（阈值 $\\tau = 1$）时，将该注释标记为不合理。\n\n您的任务是：实现一个完整的程序，给定树 $T$、多个功能的审定存在集 $P_f$ 以及一个查询注释列表 $(q,f)$，通过 Fitch 简约性分析计算 $D(q,f)$，并根据上述规则为每个查询返回一个布尔标记。\n\n树拓扑 $T$（有根，从父节点指向子节点，叶节点是没有子节点的节点）：\n\n- “root” 的子节点是 “bacteria”、“archaea”、“eukaryota”。\n- “bacteria” 的子节点是 “cyanobacteria”、“e_coli”。\n- “archaea” 的子节点是 “methanoarchaea”。\n- “eukaryota” 的子节点是 “opisthokonta”、“archaeplastida”、“excavata”。\n- “opisthokonta” 的子节点是 “human”、“mouse”、“yeast”。\n- “archaeplastida” 的子节点是 “arabidopsis”。\n- “excavata” 的子节点是 “euglena”。\n\n审定存在集 $P_f$：\n\n- 对于功能 “chlorophyll_biosynthesis”：$P_{\\mathrm{chlorophyll\\_biosynthesis}} = \\{\\text{\"arabidopsis\"}, \\text{\"cyanobacteria\"}, \\text{\"euglena\"}\\}$。\n- 对于功能 “photosystem_II”：$P_{\\mathrm{photosystem\\_II}} = \\{\\text{\"arabidopsis\"}, \\text{\"cyanobacteria\"}, \\text{\"euglena\"}\\}$。\n- 对于功能 “heme_biosynthesis”：$P_{\\mathrm{heme\\_biosynthesis}} = \\{\\text{\"human\"}, \\text{\"yeast\"}, \\text{\"arabidopsis\"}, \\text{\"e_coli\"}\\}$。\n- 对于功能 “methanogenesis”：$P_{\\mathrm{methanogenesis}} = \\{\\text{\"methanoarchaea\"}\\}$。\n\n实现要求：\n\n- 使用标准的 Fitch 简约性算法在树 $T$ 上计算二元性状的 $C(\\cdot)$，允许内部节点为多分枝。如果叶节点在 $P_f$ 中，其状态为 $\\{1\\}$，否则为 $\\{0\\}$。对于一个拥有子节点状态集 $S_1, S_2, \\dots, S_k$ 的内部节点，通过重复应用以下规则来合并它们：如果当前累加器 $A$ 与下一个 $S_i$ 相交，则设置 $A \\leftarrow A \\cap S_i$；否则设置 $A \\leftarrow A \\cup S_i$ 并将变化计数加 $1$。在所有内部节点上聚合的总变化计数等于 $C(\\cdot)$。\n- 对于每个查询 $(q,f)$，按上述定义计算 $D(q,f)$，并在 $D(q,f) \\ge \\tau$ 且 $\\tau = 1$ 时标记为不合理。\n\n测试套件：使用以下有序查询列表；您的程序必须为每个查询计算一个布尔值，以指示其是否被标记为不合理。\n\n- $(\\text{\"human\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"arabidopsis\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"cyanobacteria\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"human\"}, \\text{\"heme_biosynthesis\"})$\n- $(\\text{\"yeast\"}, \\text{\"methanogenesis\"})$\n- $(\\text{\"euglena\"}, \\text{\"chlorophyll_biosynthesis\"})$\n- $(\\text{\"human\"}, \\text{\"photosystem_II\"})$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，无空格，且顺序与测试套件相同（例如，$[\\text{True},\\text{False},\\dots]$）。", "solution": "问题陈述经过严格验证，并被认定为有效。它在科学上基于进化生物学和生物信息学的原理，问题设定良好，具有清晰的数学形式化，并且语言客观。为获得唯一解所需的所有数据和定义均已提供。该问题是将系统发育比较方法直接且形式化地应用于生物学注释质量控制这一实际任务。\n\n目标是设计并实现一种算法，作为自动蛋白质功能注释的健全性检查。此检查的核心是简约性原则，这是系统发育学中的一个基本概念，它指出最优的进化情景是需要最少状态变化（例如，功能的获得或丢失）的情景。我们的任务是为一个提议的注释——即物种 $q$ 拥有功能 $f$——计算一个“系统发育不一致性分数”，记为 $D(q, f)$。\n\n该分数定义为：\n$$D(q,f) = C\\big(P_f \\cup \\{q\\}\\big) - C(P_f)$$\n此处，$P_f$ 是经专家审定已知拥有功能 $f$ 的物种集合。术语 $C(S)$ 代表给定存在集 $S$ 的简约性分数，即在物种树 $T$ 上解释该功能在叶节点间分布所需的最少进化变化次数（从状态 $0$ 到 $1$ 或从 $1$ 到 $0$）。如果此分数达到或超过阈值 $\\tau = 1$，则提议的注释 $(q,f)$ 被标记为不合理。$D(q,f) \\ge 1$ 的分数意味着容纳新注释需要在树上至少增加一个额外的进化事件，从而增加了其复杂性并降低了其简约性。\n\n简约性分数 $C(\\cdot)$ 的计算是使用 Fitch 简约性算法完成的。该算法在概念上分两遍遍历树 $T$，但为了计算分数，只需要第一遍（上行遍历）。算法流程如下：\n\n1.  **状态初始化：** 在树的叶节点 $L(T)$ 上定义一个二元性状。对于给定的存在集 $S$，如果叶节点 $l \\in S$，则为其分配状态集 $\\{1\\}$，否则分配 $\\{0\\}$。\n\n2.  **上行遍历（后序遍历）：** 算法从叶节点向根节点遍历树。对于每个有子节点 $v_1, v_2, \\dots, v_k$ 的内部节点 $u$，我们计算其假设的状态集 $S_u$ 和发生在通往其子节点的分支上的变化数 $c_u$。\n    *   子节点的状态集 $S_{v_1}, S_{v_2}, \\dots, S_{v_k}$ 是通过递归确定的。\n    *   状态集 $S_u$ 和变化计数 $c_u$ 是通过迭代子节点的状态集来计算的。我们初始化一个累加器集合 $A = S_{v_1}$ 和一个局部变化计数 $c_u = 0$。\n    *   对于每个后续的子节点 $v_i$（从 $i=2$ 到 $k$）：\n        *   如果交集 $A \\cap S_{v_i}$ 非空，则累加器更新为此交集：$A \\leftarrow A \\cap S_{v_i}$。这代表从父节点 $u$ 继承的共享状态。\n        *   如果交集 $A \\cap S_{v_i}$ 为空，则累加器更新为并集 $A \\leftarrow A \\cup S_{v_i}$，并且变化计数增加：$c_u \\leftarrow c_u + 1$。这表示在所涉及的一个分支上发生了必要的状态变化（趋同或丢失）。\n    *   节点 $u$ 的最终状态集是 $A$ 的最终值，节点 $u$ 处的代价是 $c_u$ 的最终值。\n\n3.  **总简约性分数：** 总简约性分数 $C(S)$ 是树中所有内部节点的变化计数之和：\n    $$C(S) = \\sum_{u \\in \\text{InternalNodes}(T)} c_u$$\n\n为实现该解决方案，首先将提供的树拓扑表示为有向图，例如，使用一个将父节点映射到其子节点列表的字典。然后设计一个递归函数来执行后序遍历，在从叶节点到根节点的进程中计算状态集和变化计数。\n\n对于测试套件中的每个查询 $(q,f)$：\n1.  使用审定存在集 $P_f$ 计算基线简约性分数 $C(P_f)$。\n2.  如果查询物种 $q$ 已经存在于 $P_f$ 中，那么 $P_f \\cup \\{q\\} = P_f$，这意味着 $C(P_f \\cup \\{q\\}) = C(P_f)$。因此，$D(q,f) = 0$，该注释不会被标记。\n3.  如果 $q \\notin P_f$，则形成一个新的存在集 $P'_f = P_f \\cup \\{q\\}$。\n4.  为这个新集合计算简约性分数 $C(P'_f)$。\n5.  计算不一致性分数 $D(q,f) = C(P'_f) - C(P_f)$。\n6.  将结果与阈值 $\\tau=1$ 进行比较。如果 $D(q,f) \\ge 1$，则该查询被标记为不合理（布尔值 `True`），否则为合理（布尔值 `False`）。\n\n将此过程应用于提供的测试套件中的每个查询，以生成最终输出。", "answer": "```python\nimport numpy as np\nfrom functools import lru_cache\n\ndef solve():\n    \"\"\"\n    Solves the phylogenetic sanity-check problem.\n    \"\"\"\n    \n    # Define the species tree topology as a parent-to-children dictionary.\n    TREE = {\n        \"root\": [\"bacteria\", \"archaea\", \"eukaryota\"],\n        \"bacteria\": [\"cyanobacteria\", \"e_coli\"],\n        \"archaea\": [\"methanoarchaea\"],\n        \"eukaryota\": [\"opisthokonta\", \"archaeplastida\", \"excavata\"],\n        \"opisthokonta\": [\"human\", \"mouse\", \"yeast\"],\n        \"archaeplastida\": [\"arabidopsis\"],\n        \"excavata\": [\"euglena\"],\n    }\n    \n    # Identify all nodes and leaf nodes from the tree structure.\n    all_nodes = set(TREE.keys())\n    for children in TREE.values():\n        all_nodes.update(children)\n    LEAVES = all_nodes - set(TREE.keys())\n\n    # Define the curated presence sets for each function.\n    CURATED_SETS = {\n        \"chlorophyll_biosynthesis\": {\"arabidopsis\", \"cyanobacteria\", \"euglena\"},\n        \"photosystem_II\": {\"arabidopsis\", \"cyanobacteria\", \"euglena\"},\n        \"heme_biosynthesis\": {\"human\", \"yeast\", \"arabidopsis\", \"e_coli\"},\n        \"methanogenesis\": {\"methanoarchaea\"},\n    }\n\n    # Define the test suite of queries (species, function).\n    QUERIES = [\n        (\"human\", \"chlorophyll_biosynthesis\"),\n        (\"arabidopsis\", \"chlorophyll_biosynthesis\"),\n        (\"cyanobacteria\", \"chlorophyll_biosynthesis\"),\n        (\"human\", \"heme_biosynthesis\"),\n        (\"yeast\", \"methanogenesis\"),\n        (\"euglena\", \"chlorophyll_biosynthesis\"),\n        (\"human\", \"photosystem_II\"),\n    ]\n\n    def fitch_parsimony_score(presence_set):\n        \"\"\"\n        Calculates the total Fitch parsimony score for a given presence set.\n        \n        Args:\n            presence_set (frozenset): A set of leaf names that possess the function (state 1).\n        \n        Returns:\n            int: The minimum number of state changes on the tree.\n        \"\"\"\n        \n        # Memoization to avoid recomputing for the same node and presence set.\n        @lru_cache(maxsize=None)\n        def post_order_traversal(node, p_set):\n            \"\"\"\n            Performs a post-order traversal to compute state sets and change counts.\n\n            Args:\n                node (str): The current node name.\n                p_set (frozenset): The presence set for this calculation.\n            \n            Returns:\n                tuple[set, int]: A tuple containing the state set for the node and the\n                                 cumulative change count for the subtree rooted at this node.\n            \"\"\"\n            # Base Case: Leaf node\n            if node in LEAVES:\n                state_set = {1} if node in p_set else {0}\n                return state_set, 0\n\n            # Recursive Step: Internal node\n            children = TREE.get(node, [])\n            if not children: # Should not happen for internal nodes\n                return set(), 0\n\n            # Get state sets and costs from all children\n            child_results = [post_order_traversal(child, p_set) for child in children]\n            \n            # Initialize accumulator and total cost for this subtree\n            # Start with the first child\n            running_state_set, total_subtree_cost = child_results[0]\n            # Make a copy to modify\n            running_state_set = set(running_state_set)\n            \n            # The change count at this specific node\n            node_cost = 0\n\n            # Sequentially merge the rest of the children\n            for i in range(1, len(child_results)):\n                child_state_set, child_cost = child_results[i]\n                total_subtree_cost += child_cost\n                \n                intersection = running_state_set.intersection(child_state_set)\n                \n                if intersection:\n                    running_state_set = intersection\n                else:\n                    running_state_set.update(child_state_set)\n                    node_cost += 1\n            \n            total_subtree_cost += node_cost\n            return running_state_set, total_subtree_cost\n\n        # Start the traversal from the root node.\n        # The presence_set is converted to a frozenset to be hashable for lru_cache.\n        _, total_cost = post_order_traversal(\"root\", frozenset(presence_set))\n        return total_cost\n\n    results = []\n    tau = 1\n\n    for q, f in QUERIES:\n        p_f = CURATED_SETS[f]\n        \n        # If the queried species is already in the curated set, the score change is 0.\n        if q in p_f:\n            d_qf = 0\n        else:\n            # Calculate score without the query\n            c_pf = fitch_parsimony_score(p_f)\n            \n            # Calculate score with the query\n            p_f_union_q = p_f.union({q})\n            c_pf_union_q = fitch_parsimony_score(p_f_union_q)\n            \n            d_qf = c_pf_union_q - c_pf\n        \n        # Flag as implausible if the score change is >= tau\n        is_implausible = d_qf >= tau\n        results.append(is_implausible)\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "2383796"}, {"introduction": "生物数据库是动态变化的，基因标识符会随着研究的深入而被合并、拆分甚至删除。这个练习旨在解决一个常见的数据维护挑战：“僵尸注释”，即那些引用了已过时或已删除基因的注释记录。你将实现一个系统来追踪标识符的演变历史，以识别并标记这些过时的记录，从而确保下游数据库的完整性与准确性。[@problem_id:2383787]", "problem": "您将处理一个形式化的整合任务，该任务旨在模拟检测下游生物学数据库中的“僵尸注释”。僵尸注释是指一个注释记录，它引用的基因标识符在权威来源中已被替代品（例如通过合并）取代或已被删除，但在下游数据库中仍然存在且未被修正。任务是从第一性原理出发定义一个决策规则，并实现一个程序，将该规则应用于一组有限的测试用例。\n\n定义和设置：\n- 设 $U$ 是基因标识符的有限全集。设 $C \\subseteq U$ 是在一个固定的权威参考版本 $R^\\ast$ 中当前有效的标识符集合。\n- 设 $E \\subseteq U \\times \\left(U \\cup \\{\\bot\\}\\right)$ 是一个编码标识符演化过程的二元关系，其中 $(x,y) \\in E$ 且 $y \\in U$ 表示标识符 $x$ 被 $y$ 替代（例如，通过合并），而 $(x,\\bot) \\in E$ 表示标识符 $x$ 被删除且无替代。特殊符号 $\\bot$ 表示删除终结符。\n- 对于任意 $x \\in U$，将在版本 $R^\\ast$ 下的规范化函数 $c(x)$ 定义如下：\n  - 如果 $x \\in C$ 且不存在 $(x,y) \\in E$，则 $c(x) = x$。\n  - 如果 $(x,y) \\in E$ 且 $y \\in U$，则 $c(x) = c(y)$。\n  - 如果 $(x,\\bot) \\in E$，则 $c(x) = \\bot$。\n  - 如果 $x \\notin C$ 且不存在 $(x,y) \\in E$，则 $c(x) = \\bot$。\n  - 如果在由 $E$ 在 $U$ 上导出的图中存在一个从 $x$ 可达的有向环，则 $c(x) = \\bot$。\n- 一个注释记录是一个序对 $(x,s)$，其中 $x \\in U$ 且 $s \\in \\{\\mathsf{curated}, \\mathsf{automated}\\}$。给定 $c(x)$，将僵尸指示符 $z(x)$ 定义为\n  - 如果 $c(x) = \\bot$ 或 $c(x) \\neq x$，则 $z(x) = 1$，\n  - 如果 $c(x) = x$，则 $z(x) = 0$。\n- 对于一个注释记录的多重集 $A = \\{(x_i,s_i)\\}_{i=1}^{n}$，定义：\n  - $Z = \\sum_{i=1}^{n} z(x_i)$，僵尸注释的总数。\n  - $Z_C = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{curated}] \\cdot z(x_i)$，人工策展记录中的僵尸注释数量。\n  - $Z_A = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{automated}] \\cdot z(x_i)$，自动生成记录中的僵尸注释数量。\n  - $N_C = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{curated}]$，人工策展记录的总数。\n  - $N_A = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{automated}]$，自动生成记录的总数。\n  - $r_C = \\begin{cases} Z_C / N_C  \\text{if } N_C \\neq 0 \\\\ 0  \\text{if } N_C = 0 \\end{cases}$，人工策展的僵尸注释率，以小数形式表示。\n  - $r_A = \\begin{cases} Z_A / N_A  \\text{if } N_A \\neq 0 \\\\ 0  \\text{if } N_A = 0 \\end{cases}$，自动生成的僵尸注释率，以小数形式表示。\n\n测试套件：\n您必须将上述定义应用于以下三个测试用例。在每个用例中，$U$ 隐式地是出现在 $C$、$E$ 的定义域和值域以及注释记录 $A$ 中的所有标识符的并集。\n\n- 测试用例 1：\n  - 当前标识符 $C = \\{g\\_3, g\\_4\\}$。\n  - 演化关系 $E = \\{(g\\_1,g\\_2),(g\\_2,g\\_3),(g\\_5,\\bot)\\}$。\n  - 注释记录 $A = [(g\\_1,\\mathsf{curated}),(g\\_2,\\mathsf{automated}),(g\\_3,\\mathsf{curated}),(g\\_5,\\mathsf{automated}),(g\\_4,\\mathsf{automated})]$。\n\n- 测试用例 2：\n  - 当前标识符 $C = \\{h\\_1, h\\_2\\}$。\n  - 演化关系 $E = \\varnothing$。\n  - 注释记录 $A = [(h\\_1,\\mathsf{curated}),(h\\_2,\\mathsf{automated})]$。\n\n- 测试用例 3：\n  - 当前标识符 $C = \\{a\\_3, c\\_1\\}$。\n  - 演化关系 $E = \\{(a\\_0,a\\_1),(a\\_1,a\\_3),(a\\_2,a\\_3),(b\\_1,\\bot)\\}$。\n  - 注释记录 $A = [(a\\_2,\\mathsf{curated}),(a\\_3,\\mathsf{automated}),(b\\_1,\\mathsf{automated}),(x\\_{999},\\mathsf{curated}),(a\\_0,\\mathsf{automated})]$。\n\n要求输出：\n- 对于每个测试用例，计算如上定义的 5 元组 $[Z, Z_C, Z_A, r_C, r_A]$，其中 $Z$、$Z_C$ 和 $Z_A$ 是整数，$r_C$ 和 $r_A$ 是小数。\n- 您的程序应生成单行输出，其中包含汇总了 3 个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，列表中的每个元素本身是该测试用例的 5 元组，也用方括号括起来并以逗号分隔。例如，格式必须严格遵循 $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot]]$ 的形式，不含任何空白字符。", "solution": "我们通过引用一个规范化函数来形式化僵尸注释的检测，该函数在可能的情况下，将每个标识符解析为权威参考版本中的当前形式。\n\n设 $U$ 为标识符全集，$C \\subseteq U$ 为当前标识符集合，$E \\subseteq U \\times \\left(U \\cup \\{\\bot\\}\\right)$ 为演化关系。通过结构递归定义 $c: U \\to U \\cup \\{\\bot\\}$：\n- 基本情况：\n  - 如果 $x \\in C$ 且不存在 $(x,y) \\in E$，则 $c(x) = x$。这是一个不动点，代表一个最新的标识符。\n  - 如果 $(x,\\bot) \\in E$，则 $c(x) = \\bot$。这代表删除。\n  - 如果 $x \\notin C$ 且不存在 $(x,y) \\in E$，则设 $c(x) = \\bot$。这涵盖了相对于权威版本而言未知或无效的标识符。\n- 递归情况：\n  - 如果 $(x,y) \\in E$ 且 $y \\in U$，则定义 $c(x) = c(y)$，这会沿着替代链进行，直到满足某个基本情况。\n- 环处理：\n  - 如果在递归评估期间再次遇到先前见过的标识符，则在可达子图中存在有向环，因此 $c(x)$ 在自然意义上是未定义的；我们定义 $c(x) = \\bot$，以保守地将涉及环的标识符视为不可解析的，并因此视为僵尸。在人工策展的来源中，预计不会出现此类环，但该规则仍然是良定义的。\n\n将僵尸指示符 $z(x)$ 定义为：如果 $c(x) = \\bot$ 或 $c(x) \\neq x$，则 $z(x) = 1$，否则 $z(x) = 0$。这既捕获了被删除的标识符（其中 $c(x) = \\bot$），也捕获了本应更新为其规范替代品的过时标识符（其中 $c(x) \\neq x$）。该规则与来源无关；它同样适用于人工策展和自动生成的记录，从而可以在不同来源之间比较僵尸注释率。\n\n对于一个注释记录的多重集 $A = \\{(x_i,s_i)\\}_{i=1}^{n}$，定义\n- $Z = \\sum_{i=1}^{n} z(x_i)$,\n- $Z_C = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{curated}] \\cdot z(x_i)$,\n- $Z_A = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{automated}] \\cdot z(x_i)$,\n- $N_C = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{curated}]$,\n- $N_A = \\sum_{i=1}^{n} \\mathbf{1}[s_i = \\mathsf{automated}]$,\n- $r_C = Z_C / N_C$ if $N_C \\neq 0$ and $r_C = 0$ if $N_C = 0$,\n- $r_A = Z_A / N_A$ if $N_A \\neq 0$ and $r_A = 0$ if $N_A = 0$.\n\n我们现在将这些定义应用于测试套件。\n\n测试用例 1：\n- $C = \\{g\\_3,g\\_4\\}$,\n- $E = \\{(g\\_1,g\\_2),(g\\_2,g\\_3),(g\\_5,\\bot)\\}$,\n- $A = [(g\\_1,\\mathsf{curated}),(g\\_2,\\mathsf{automated}),(g\\_3,\\mathsf{curated}),(g\\_5,\\mathsf{automated}),(g\\_4,\\mathsf{automated})]$.\n规范化：\n- $c(g\\_1) = c(g\\_2) = c(g\\_3) = g\\_3$，因此 $z(g\\_1) = 1$，$z(g\\_2) = 1$，$z(g\\_3) = 0$。\n- $c(g\\_5) = \\bot$，因此 $z(g\\_5) = 1$。\n- $c(g\\_4) = g\\_4$，因此 $z(g\\_4) = 0$。\n计数和比率：\n- $Z = 3$，\n- $Z_C = 1$（只有 $(g\\_1,\\mathsf{curated})$ 是僵尸），\n- $Z_A = 2$（$(g\\_2,\\mathsf{automated})$ 和 $(g\\_5,\\mathsf{automated})$ 都是僵尸），\n- $N_C = 2$, $N_A = 3$,\n- $r_C = 1/2 = 0.5$,\n- $r_A = 2/3 \\approx 0.6666666666666666$.\n\n测试用例 2：\n- $C = \\{h\\_1,h\\_2\\}$,\n- $E = \\varnothing$,\n- $A = [(h\\_1,\\mathsf{curated}),(h\\_2,\\mathsf{automated})]$.\n规范化：\n- $c(h\\_1) = h\\_1$，$c(h\\_2) = h\\_2$，因此 $z(h\\_1) = 0$，$z(h\\_2) = 0$。\n计数和比率：\n- $Z = 0$,\n- $Z_C = 0$, $Z_A = 0$,\n- $N_C = 1$, $N_A = 1$,\n- $r_C = 0$, $r_A = 0$.\n\n测试用例 3：\n- $C = \\{a\\_3,c\\_1\\}$,\n- $E = \\{(a\\_0,a\\_1),(a\\_1,a\\_3),(a\\_2,a\\_3),(b\\_1,\\bot)\\}$,\n- $A = [(a\\_2,\\mathsf{curated}),(a\\_3,\\mathsf{automated}),(b\\_1,\\mathsf{automated}),(x\\_{999},\\mathsf{curated}),(a\\_0,\\mathsf{automated})]$.\n规范化：\n- $c(a\\_2) = c(a\\_3) = a\\_3$，因此 $z(a\\_2) = 1$，$z(a\\_3) = 0$。\n- $c(b\\_1) = \\bot$，因此 $z(b\\_1) = 1$。\n- $x\\_{999} \\notin C$ 且在 $E$ 中没有出边，因此 $c(x\\_{999}) = \\bot$ 且 $z(x\\_{999}) = 1$。\n- $c(a\\_0) = c(a\\_1) = c(a\\_3) = a\\_3$，因此 $z(a\\_0) = 1$。\n计数和比率：\n- $Z = 4$,\n- $Z_C = 2$（$(a\\_2,\\mathsf{curated})$ 和 $(x\\_{999},\\mathsf{curated})$ 都是僵尸），\n- $Z_A = 2$（$(b\\_1,\\mathsf{automated})$ 和 $(a\\_0,\\mathsf{automated})$ 都是僵尸），\n- $N_C = 2$, $N_A = 3$,\n- $r_C = 2/2 = 1.0$,\n- $r_A = 2/3 \\approx 0.6666666666666666$.\n\n因此，每个测试用例所需的输出是以下 5 元组：\n- 测试用例 1：$[3, 1, 2, 0.5, 0.6666666666666666]$。\n- 测试用例 2：$[0, 0, 0, 0.0, 0.0]$。\n- 测试用例 3：$[4, 2, 2, 1.0, 0.6666666666666666]$。\n\n程序必须将这三个列表汇总成一个单一的方括号列表，在单行上输出，且不含任何空白字符。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef canonical(id_, current, edges):\n    \"\"\"\n    Compute canonical identifier for id_ given:\n    - current: set of current valid identifiers\n    - edges: dict mapping obsolete id -> replacement id (string) or None for deletion\n    Returns:\n        - the canonical current id as a string, if resolvable and current\n        - None if deleted, unknown, or cycle detected\n    \"\"\"\n    visited = set()\n    x = id_\n    while True:\n        if x in visited:\n            # Cycle detected\n            return None\n        visited.add(x)\n        if x in edges:\n            y = edges[x]\n            if y is None:\n                return None\n            x = y\n            continue\n        # No outgoing edge from x\n        if x in current:\n            return x\n        else:\n            # Unknown or invalid w.r.t. current/edges\n            return None\n\ndef analyze_case(current_ids, evolution_edges, annotations):\n    \"\"\"\n    current_ids: set of strings\n    evolution_edges: dict {old: new or None}\n    annotations: list of tuples (id, source) where source is 'curated' or 'automated'\n    Returns list: [Z, Z_C, Z_A, r_C, r_A]\n    \"\"\"\n    # Compute zombies\n    total_zombies = 0\n    curated_zombies = 0\n    automated_zombies = 0\n    n_curated = 0\n    n_automated = 0\n\n    for gene_id, source in annotations:\n        canon = canonical(gene_id, current_ids, evolution_edges)\n        is_zombie = (canon is None) or (canon != gene_id)\n        if is_zombie:\n            total_zombies += 1\n        if source == 'curated':\n            n_curated += 1\n            if is_zombie:\n                curated_zombies += 1\n        elif source == 'automated':\n            n_automated += 1\n            if is_zombie:\n                automated_zombies += 1\n        else:\n            # Unknown source label; for robustness, ignore counts (not expected in test suite)\n            pass\n\n    r_c = (curated_zombies / n_curated) if n_curated != 0 else 0.0\n    r_a = (automated_zombies / n_automated) if n_automated != 0 else 0.0\n\n    return [total_zombies, curated_zombies, automated_zombies, r_c, r_a]\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case 1\n    current_1 = {'g_3', 'g_4'}\n    edges_1 = {\n        'g_1': 'g_2',\n        'g_2': 'g_3',\n        'g_5': None  # deletion\n    }\n    annotations_1 = [\n        ('g_1', 'curated'),\n        ('g_2', 'automated'),\n        ('g_3', 'curated'),\n        ('g_5', 'automated'),\n        ('g_4', 'automated'),\n    ]\n\n    # Test case 2\n    current_2 = {'h_1', 'h_2'}\n    edges_2 = {}\n    annotations_2 = [\n        ('h_1', 'curated'),\n        ('h_2', 'automated'),\n    ]\n\n    # Test case 3\n    current_3 = {'a_3', 'c_1'}\n    edges_3 = {\n        'a_0': 'a_1',\n        'a_1': 'a_3',\n        'a_2': 'a_3',\n        'b_1': None,  # deletion\n    }\n    annotations_3 = [\n        ('a_2', 'curated'),\n        ('a_3', 'automated'),\n        ('b_1', 'automated'),\n        ('x_999', 'curated'),\n        ('a_0', 'automated'),\n    ]\n\n    test_cases = [\n        (current_1, edges_1, annotations_1),\n        (current_2, edges_2, annotations_2),\n        (current_3, edges_3, annotations_3),\n    ]\n\n    results = []\n    for current, edges, annotations in test_cases:\n        results.append(analyze_case(current, edges, annotations))\n\n    # Build exact output format: no spaces, list of lists\n    # Convert each inner list to a string without spaces\n    def list_to_compact_str(lst):\n        # Elements are ints or floats\n        elems = []\n        for v in lst:\n            if isinstance(v, float):\n                elems.append(repr(v))\n            else:\n                elems.append(str(v))\n        return \"[\" + \",\".join(elems) + \"]\"\n\n    out = \"[\" + \",\".join(list_to_compact_str(r) for r in results) + \"]\"\n    print(out)\n\nsolve()\n```", "id": "2383787"}]}