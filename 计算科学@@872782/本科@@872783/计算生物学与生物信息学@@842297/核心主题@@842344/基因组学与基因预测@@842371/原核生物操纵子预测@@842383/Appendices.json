{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解来自于实践。在本章节中，我们将通过一系列动手练习，将操纵子预测的生物学原理和计算方法付诸实践。我们的第一个练习将引导您完成一个完整的模型改进周期。您将首先实现一个基于基因间距离的简单规则预测器，分析其在区分操纵子和非操纵子基因对时的局限性，特别是假阳性（false positives）和假阴性（false negatives）的权衡。接着，您将构建一个更强大的朴素贝叶斯（Naive Bayes）分类器，该分类器能够整合多种生物学证据（如基因方向、距离和表达相关性），从而显著提升预测性能[@problem_id:2410867]。", "problem": "给定一个二元分类任务，旨在模拟原核生物基因组中连续基因之间的操纵子邻近关系预测。任务目标是分析一个基于距离的简单操纵子预测器（作为流行的基于规则的操纵子预测器的代表）所产生的假阳性和假阴性，并基于概率论和生物学上合理的特征建模，实现一种有原则的算法改进。\n\n请从以下基本基础出发：分子生物学的中心法则指出，DNA被转录成RNA，在原核生物中，多个基因可以作为一个称为操纵子的单一转录单元被共转录；因此，同一操纵子内的相邻基因往往位于同一条链上，并由较短的基因间距离分隔。经验研究表明，同一操纵子内的相邻基因通常表现出协同表达，这可以通过在不同条件下的皮尔逊相关系数（PCC）来捕捉。根据概率论，贝叶斯定理将后验概率、先验概率和似然性关联起来，即 $P(Y \\mid X) \\propto P(X \\mid Y) P(Y)$，并且在条件独立性假设下，$P(X \\mid Y) = \\prod_{k} P(X_k \\mid Y)$。\n\n任务说明：\n- 每个相邻基因对的特征定义如下：\n  - $S \\in \\{0,1\\}$：同链指示符，若两个基因位于同一DNA链上，则$S=1$，否则$S=0$（无单位）。\n  - $d \\in \\mathbb{Z}$：基因间距离，以碱基对（bp）为单位，负值表示重叠（以bp为单位）。\n  - $r \\in (-1,1)$：跨多个条件的表达谱的皮尔逊相关系数（PCC）（无单位）。\n  - $y \\in \\{0,1\\}$：真实标签，若基因对位于同一操纵子内，则$y=1$，否则$y=0$（无单位）。\n- 基线预测器：当且仅当$S=1$且$d \\le T$时，预测$\\hat{y}=1$，否则预测$\\hat{y}=0$，其中阈值$T$以碱基对（bp）为单位。\n- 改进型预测器：使用贝叶斯定理，并基于以下生成模型假设推导决策规则：\n  - 对$r$应用Fisher $z$变换：$z = \\operatorname{atanh}(r)$。\n  - 以类别$y \\in \\{0,1\\}$为条件，并假设条件独立：\n    - $d \\mid y \\sim \\mathcal{N}(\\mu_{y}^{(d)}, (\\sigma_{y}^{(d)})^2)$，\n    - $z \\mid y \\sim \\mathcal{N}(\\mu_{y}^{(z)}, (\\sigma_{y}^{(z)})^2)$，\n    - $S \\mid y \\sim \\operatorname{Bernoulli}(\\theta_y)$，\n    - 类别先验概率为 $\\pi_y = P(y)$。\n  - 估计协议必须是留一法：对于每个测试对$i$，仅使用其余的$n-1$个基因对来估计所有参数$\\{\\mu_{y}^{(d)}, \\sigma_{y}^{(d)}, \\mu_{y}^{(z)}, \\sigma_{y}^{(z)}, \\theta_y, \\pi_y\\}$。对高斯参数使用最大似然估计，对于伯努利参数和类别先验，使用加性（Laplace）平滑，其对称Beta先验的强度为$\\alpha$，即 $\\theta_y = \\dfrac{k + \\alpha}{m + 2\\alpha}$，其中$k$是类别$y$样本中$S=1$的计数，$m$是类别$y$的样本数，所有这些都在$n-1$个基因对上计算。对$\\pi_y$使用相同的方案，但使用类别的计数。通过根据需要为每个方差估计值添加一个小的$\\varepsilon$来确保方差严格为正。\n  - 如果后验概率$P(y=1 \\mid S,d,z)$超过$0.5$，则预测$\\hat{y}=1$，否则预测$\\hat{y}=0$。\n\n数据集（测试套件）：\n- 您必须严格使用以下$n=16$个相邻基因对，每个基因对以$(S, d, r, y)$的形式提供，其中$d$的单位是碱基对（bp），$r$无单位：\n  - 案例 $1$：$(1, -5, 0.85, 1)$\n  - 案例 $2$：$(1, 10, 0.80, 1)$\n  - 案例 $3$：$(1, 30, 0.75, 1)$\n  - 案例 $4$：$(1, 55, 0.88, 1)$\n  - 案例 $5$：$(1, 95, 0.90, 1)$\n  - 案例 $6$：$(1, 0, 0.70, 1)$\n  - 案例 $7$：$(1, 40, 0.65, 1)$\n  - 案例 $8$：$(1, 20, 0.60, 1)$\n  - 案例 $9$：$(1, 15, 0.10, 0)$\n  - 案例 $10$：$(0, 20, 0.05, 0)$\n  - 案例 $11$：$(1, 150, 0.20, 0)$\n  - 案例 $12$：$(0, -10, -0.05, 0)$\n  - 案例 $13$：$(1, 300, 0.40, 0)$\n  - 案例 $14$：$(0, 80, 0.30, 0)$\n  - 案例 $15$：$(1, 5, 0.00, 0)$\n  - 案例 $16$：$(0, 400, 0.20, 0)$\n\n评估与输出：\n- 对于基线预测器，在三个阈值$T \\in \\{20, 60, 120\\}$（单位为bp）下评估假阳性和假阴性。对于每个阈值$T$，计算：\n  - $\\mathrm{FP}(T)$：$y=0$且$\\hat{y}=1$的基因对计数，\n  - $\\mathrm{FN}(T)$：$y=1$且$\\hat{y}=0$的基因对计数。\n- 对于改进型预测器，使用留一法参数估计协议，对称平滑强度$\\alpha = 0.5$，方差下限$\\varepsilon = 10^{-6}$，计算：\n  - $\\mathrm{FP}_{\\mathrm{imp}}$：$y=0$且$\\hat{y}=1$的基因对计数，\n  - $\\mathrm{FN}_{\\mathrm{imp}}$：$y=1$且$\\hat{y}=0$的基因对计数。\n- 要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  - $[\\mathrm{FP}(20), \\mathrm{FN}(20), \\mathrm{FP}(60), \\mathrm{FN}(60), \\mathrm{FP}(120), \\mathrm{FN}(120), \\mathrm{FP}_{\\mathrm{imp}}, \\mathrm{FN}_{\\mathrm{imp}}]$。\n- 单位：基因间距离$d$和阈值$T$的单位是碱基对（bp）。所有其他量均为无单位量。输出本身由整数组成，不得包含单位。\n\n设计约束：\n- 通用性：基于上述定义和假设，以纯数学和算法术语构建您的解决方案。\n- 科学真实性：数据和建模假设反映了真实的操纵子生物学；$S$、$d$和$r$的定义如上，其中$r$严格介于$-1$和$1$之间。\n- 测试套件和覆盖范围：三个阈值$T \\in \\{20, 60, 120\\}$用于测试基线预测器在从严格到宽松的距离截止值下的行为。数据包含边缘案例，例如负$d$（重叠）、反向链（$S=0$）、非操纵子对的同链小距离（具有挑战性的假阳性）以及操纵子对的长距离（具有挑战性的假阴性）。", "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于分子生物学和概率论的原理，定义和数据完整且一致，问题阐述清晰，并且表述客观。我们将着手解决此问题。\n\n任务是实现并评估两种用于预测基因对之间操纵子邻近关系的预测器。第一种是基于简单规则的基线预测器，第二种是基于朴素贝叶斯分类器的改进型预测器。\n\n首先，我们分析基线预测器。预测规则定义为：当且仅当基因对位于同一链上（$S=1$）且基因间距离$d$小于或等于阈值$T$（单位为碱基对，bp）时，预测$\\hat{y}=1$。否则，预测为$\\hat{y}=0$。我们针对三个阈值$T \\in \\{20, 60, 120\\}$评估此规则。对于每个阈值，我们必须计算假阳性（$\\mathrm{FP}(T)$）的数量，即非操纵子对（$y=0$）被错误分类为操纵子对（$\\hat{y}=1$），以及假阴性（$\\mathrm{FN}(T)$）的数量，即操纵子对（$y=1$）被错误分类为非操纵子对（$\\hat{y}=0$）。\n\n所提供的数据集包含$n=16$个基因对，其中8个是操纵子对（$y=1$），8个是非操纵子对（$y=0$）。所有8个操纵子对都具有$S=1$。\n\n对于$T=20$ bp：\n正向预测的条件是$S=1$且$d \\le 20$。\n- 操纵子对（$y=1$）：案例3（$d=30$）、案例4（$d=55$）、案例5（$d=95$）和案例7（$d=40$）的$d > 20$。它们被错误分类，导致$\\mathrm{FN}(20)=4$。\n- 非操纵子对（$y=0$）：案例9（$S=1, d=15$）和案例15（$S=1, d=5$）满足条件。它们被错误分类，导致$\\mathrm{FP}(20)=2$。\n\n对于$T=60$ bp：\n正向预测的条件是$S=1$且$d \\le 60$。\n- 操纵子对（$y=1$）：只有案例5（$d=95$）的$d > 60$。它被错误分类，导致$\\mathrm{FN}(60)=1$。\n- 非操纵子对（$y=0$）：案例9（$S=1, d=15$）和案例15（$S=1, d=5$）继续满足条件。它们被错误分类，导致$\\mathrm{FP}(60)=2$。\n\n对于$T=120$ bp：\n正向预测的条件是$S=1$且$d \\le 120$。\n- 操纵子对（$y=1$）：所有操纵子对的$d \\le 95$，因此全被正确分类。这导致$\\mathrm{FN}(120)=0$。\n- 非操纵子对（$y=0$）：案例9（$S=1, d=15$）和案例15（$S=1, d=5$）仍被错误分类。这导致$\\mathrm{FP}(120)=2$。\n\n基线预测器展示了一个典型的权衡：增加距离阈值$T$可以减少假阴性，但代价是无法解决根本性的假阳性问题，这些假阳性是由那些在链和距离上模仿操纵子对、但在其他生物信号（如表达协同性）上不相似的非操纵子基因对引起的。\n\n接下来，我们构建改进型预测器，即一个朴素贝叶斯分类器。该模型引入了一个额外特征——皮尔逊相关系数$r$，并使用概率框架进行决策。决策规则是：如果后验概率$P(y=1 \\mid S, d, r)$大于$0.5$，则预测$\\hat{y}=1$。\n\n该模型基于贝叶斯定理：$P(y \\mid X) \\propto P(X \\mid y)P(y)$，其中$X$代表特征向量。在条件独立的朴素假设下，类条件似然为$P(X \\mid y) = P(S \\mid y)P(d \\mid y)P(z \\mid y)$，其中$z = \\operatorname{atanh}(r)$是经过Fisher变换后的相关系数。\n\n决策规则$P(y=1 \\mid X) > P(y=0 \\mid X)$等价于比较未归一化的后验概率，$P(X \\mid y=1)P(y=1) > P(X \\mid y=0)P(y=0)$。为了数值稳定性，我们比较对数后验得分：\n$$ \\log P(y=1|X) > \\log P(y=0|X) $$\n其中类别$y \\in \\{0, 1\\}$的对数后验概率由下式给出：\n$$ \\log S_y = \\log \\pi_y + \\log P(S \\mid y) + \\log P(d \\mid y) + \\log P(z \\mid y) $$\n各组成部分建模如下：\n- 类别先验$\\pi_y = P(y)$。\n- $S \\mid y \\sim \\operatorname{Bernoulli}(\\theta_y)$，因此其对数似然为$S \\log \\theta_y + (1-S) \\log(1-\\theta_y)$。\n- $d \\mid y \\sim \\mathcal{N}(\\mu_{y}^{(d)}, (\\sigma_{y}^{(d)})^2)$，其对数似然为$-\\frac{1}{2} \\log\\left(2\\pi (\\sigma_{y}^{(d)})^2\\right) - \\frac{(d - \\mu_{y}^{(d)})^2}{2(\\sigma_{y}^{(d)})^2}$。\n- $z \\mid y \\sim \\mathcal{N}(\\mu_{y}^{(z)}, (\\sigma_{y}^{(z)})^2)$，其对数似然为$-\\frac{1}{2} \\log\\left(2\\pi (\\sigma_{y}^{(z)})^2\\right) - \\frac{(z - \\mu_{y}^{(z)})^2}{2(\\sigma_{y}^{(z)})^2}$。\n\n参数估计使用留一法（LOO）协议进行。对于$n=16$个基因对中的每一个，将其作为测试案例留出，并从其余$n-1=15$个基因对中估计模型参数。设$n_y$为类别$y$中的训练样本数，且$n_{\\text{train}} = n_0+n_1 = 15$。\n- 先验概率$\\pi_y$和伯努利参数$\\theta_y$使用加性（Laplace）平滑进行估计，其中$\\alpha=0.5$。\n    - $\\pi_y = \\dfrac{n_y + \\alpha}{n_{\\text{train}} + 2\\alpha} = \\dfrac{n_y + 0.5}{15 + 1.0} = \\dfrac{n_y + 0.5}{16}$。\n    - $\\theta_y = P(S=1 \\mid y) = \\dfrac{k_y + \\alpha}{n_y + 2\\alpha} = \\dfrac{k_y + 0.5}{n_y + 1.0}$，其中$k_y$是类别$y$中$S=1$样本的计数。\n- 高斯参数使用最大似然估计（MLE）在每个类别$y$的训练数据上进行估计：\n    - 均值：$\\mu_y^{(f)} = \\frac{1}{n_y} \\sum_{i=1}^{n_y} f_i$，对于特征$f \\in \\{d, z\\}$。\n    - 方差：$(\\sigma_y^{(f)})^2 = \\left(\\frac{1}{n_y} \\sum_{i=1}^{n_y} (f_i - \\mu_y^{(f)})^2\\right) + \\varepsilon$，其中问题指定添加$\\varepsilon=10^{-6}$以确保严格为正。\n\n对于每个留出的测试案例，我们使用从相应训练集导出的参数计算对数后验得分$\\log S_1$和$\\log S_0$。如果$\\log S_1 > \\log S_0$，则预测为$\\hat{y}=1$，否则为$\\hat{y}=0$。通过在所有16次留一法（LOO）迭代中将这些预测与真实标签进行比较，我们累积$\\mathrm{FP}_{\\mathrm{imp}}$和$\\mathrm{FN}_{\\mathrm{imp}}$的总数。\n\n此过程的实现（详见最终答案代码）将得出完成评估所需的计数。最终的结果向量是两种预测器性能指标的汇总。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the operon prediction problem by implementing and evaluating\n    a baseline predictor and an improved Naive Bayes classifier.\n    \"\"\"\n    # Define the dataset as provided in the problem statement.\n    # Each tuple is (S, d, r, y).\n    data_raw = [\n        (1, -5, 0.85, 1), (1, 10, 0.80, 1), (1, 30, 0.75, 1), (1, 55, 0.88, 1),\n        (1, 95, 0.90, 1), (1, 0, 0.70, 1), (1, 40, 0.65, 1), (1, 20, 0.60, 1),\n        (1, 15, 0.10, 0), (0, 20, 0.05, 0), (1, 150, 0.20, 0), (0, -10, -0.05, 0),\n        (1, 300, 0.40, 0), (0, 80, 0.30, 0), (1, 5, 0.00, 0), (0, 400, 0.20, 0)\n    ]\n    \n    # Use a structured numpy array for clear feature access.\n    # The Fisher z-transform is pre-calculated for all data points.\n    data = np.array(\n        [(s, d, r, np.arctanh(r), y) for s, d, r, y in data_raw],\n        dtype=[('S', 'i4'), ('d', 'i4'), ('r', 'f8'), ('z', 'f8'), ('y', 'i4')]\n    )\n    \n    n_total = len(data)\n    results = []\n\n    # --- Part 1: Baseline Predictor Evaluation ---\n    thresholds_T = [20, 60, 120]\n    for T in thresholds_T:\n        FP_T, FN_T = 0, 0\n        for i in range(n_total):\n            sample = data[i]\n            y_true = sample['y']\n            \n            # Baseline prediction rule: y_hat = 1 iff S=1 and d = T\n            y_pred = 1 if sample['S'] == 1 and sample['d'] = T else 0\n            \n            if y_pred == 1 and y_true == 0:\n                FP_T += 1\n            if y_pred == 0 and y_true == 1:\n                FN_T += 1\n        results.extend([FP_T, FN_T])\n\n    # --- Part 2: Improved Naive Bayes Predictor Evaluation ---\n    FP_imp, FN_imp = 0, 0\n    alpha = 0.5  # Smoothing parameter\n    epsilon = 1e-6 # Variance floor\n    \n    # Leave-one-out cross-validation loop\n    for i in range(n_total):\n        test_sample = data[i]\n        train_samples = np.delete(data, i, axis=0)\n        \n        # Separate training data by class\n        train_1 = train_samples[train_samples['y'] == 1]\n        train_0 = train_samples[train_samples['y'] == 0]\n        \n        n_train = len(train_samples)\n        n1 = len(train_1)\n        n0 = len(train_0)\n        \n        # --- Parameter Estimation from Training Data ---\n        \n        # 1. Class priors (pi_y) with Laplace smoothing\n        pi_1 = (n1 + alpha) / (n_train + 2 * alpha)\n        pi_0 = (n0 + alpha) / (n_train + 2 * alpha)\n        \n        # 2. Bernoulli parameters (theta_y) for feature S with Laplace smoothing\n        k1_s = np.sum(train_1['S'])\n        theta_1 = (k1_s + alpha) / (n1 + 2 * alpha)\n        \n        k0_s = np.sum(train_0['S'])\n        theta_0 = (k0_s + alpha) / (n0 + 2 * alpha)\n\n        # 3. Gaussian parameters (mu, sigma^2) for features d and z\n        # Class y=1\n        mu1_d = np.mean(train_1['d'])\n        var1_d = np.var(train_1['d']) + epsilon\n        mu1_z = np.mean(train_1['z'])\n        var1_z = np.var(train_1['z']) + epsilon\n        \n        # Class y=0\n        mu0_d = np.mean(train_0['d'])\n        var0_d = np.var(train_0['d']) + epsilon\n        mu0_z = np.mean(train_0['z'])\n        var0_z = np.var(train_0['z']) + epsilon\n        \n        # --- Prediction on Test Sample ---\n        # Calculate log posterior scores for each class\n        \n        # Log Priors\n        log_prior_1 = np.log(pi_1)\n        log_prior_0 = np.log(pi_0)\n        \n        # Log Likelihood for S\n        s_test = test_sample['S']\n        log_p_S_1 = s_test * np.log(theta_1) + (1 - s_test) * np.log(1 - theta_1)\n        log_p_S_0 = s_test * np.log(theta_0) + (1 - s_test) * np.log(1 - theta_0)\n        \n        # Log Likelihood for d\n        d_test = test_sample['d']\n        log_p_d_1 = norm.logpdf(d_test, loc=mu1_d, scale=np.sqrt(var1_d))\n        log_p_d_0 = norm.logpdf(d_test, loc=mu0_d, scale=np.sqrt(var0_d))\n        \n        # Log Likelihood for z\n        z_test = test_sample['z']\n        log_p_z_1 = norm.logpdf(z_test, loc=mu1_z, scale=np.sqrt(var1_z))\n        log_p_z_0 = norm.logpdf(z_test, loc=mu0_z, scale=np.sqrt(var0_z))\n        \n        # Total log posterior scores\n        log_score_1 = log_prior_1 + log_p_S_1 + log_p_d_1 + log_p_z_1\n        log_score_0 = log_prior_0 + log_p_S_0 + log_p_d_0 + log_p_z_0\n        \n        # Prediction\n        y_pred = 1 if log_score_1 > log_score_0 else 0\n        y_true = test_sample['y']\n        \n        if y_pred == 1 and y_true == 0:\n            FP_imp += 1\n        if y_pred == 0 and y_true == 1:\n            FN_imp += 1\n\n    results.extend([FP_imp, FN_imp])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2410867"}, {"introduction": "在掌握了构建和评估基本概率分类器的流程后，我们来挑战一个更全面、更真实的场景。这个练习将要求您构建一个朴素贝叶斯分类器，但这次处理的特征集更为丰富，包括基因间距离、功能关联性得分、内部启动子和终止子信号的存在，以及基因邻近关系的保守性。每种特征都由不同的概率分布（如正态分布、贝塔分布、伯努利分布和二项分布）来建模，这能让您练习如何将多源异构数据整合进一个统一的预测框架中[@problem_id:2410831]，这正是生物信息学日常工作中的核心技能之一。", "problem": "一个原核生物基因组包含许多在同一条链上相邻的基因对，其转录组织方式不明确。一对基因可能是一个真正的操纵子（一个单一的转录单元，从脱氧核糖核酸（DNA）上的多个编码序列产生一个多顺反子核糖核酸（RNA）），也可能只是两个独立转录单元的保守同线性邻接。考虑以下正式的二元分类问题。对于每个保守的、同向的基因对，定义类别标签 $Y \\in \\{0,1\\}$，其中 $Y=1$ 表示真正的操纵子对，$Y=0$ 表示两个独立的转录单元。\n\n每个基因对由一个特征向量 $X=(d,r,p,t,c)$ 表示，其分量如下：\n- $d \\in \\mathbb{Z}$ 是以碱基对（bp）为单位测量的基因间距离，其中正值 $d$ 表示间隙，负值 $d$ 表示重叠。距离以 bp 为单位提供；不要进行任何单位转换。\n- $r \\in (0,1)$ 是两个基因之间的实值功能相关性得分。\n- $p \\in \\{0,1\\}$ 表示在两个基因之间是否存在（$p=1$）或不存在（$p=0$）预测的内部启动子基序。\n- $t \\in (0,1)$ 是为基因间区域计算的实值内源性终止子得分。\n- $c \\in \\{0,1,2,\\dots,20\\}$ 是在20个参考基因组中，邻接性和同向性得到保守的基因组数量。\n\n假设 $(X,Y)$ 的生成模型和先验如下：\n- 先验类别概率 $P(Y=1)=0.5$ 和 $P(Y=0)=0.5$。\n- 给定类别下特征的条件独立性，即 $P(X \\mid Y)=P(d\\mid Y)\\,P(r\\mid Y)\\,P(p\\mid Y)\\,P(t\\mid Y)\\,P(c\\mid Y)$。\n- 基因间距离：对于 $Y=1$，$d \\sim \\mathcal{N}(\\mu_1,\\sigma_1^2)$，其中 $\\mu_1=20$ 且 $\\sigma_1=35$；对于 $Y=0$，$d \\sim \\mathcal{N}(\\mu_0,\\sigma_0^2)$，其中 $\\mu_0=220$ 且 $\\sigma_0=90$。\n- 功能相关性：对于 $Y=1$，$r \\sim \\mathrm{Beta}(\\alpha_{r1},\\beta_{r1})$，其中 $\\alpha_{r1}=5$ 且 $\\beta_{r1}=2$；对于 $Y=0$，$r \\sim \\mathrm{Beta}(\\alpha_{r0},\\beta_{r0})$，其中 $\\alpha_{r0}=2$ 且 $\\beta_{r0}=5$。\n- 内部启动子基序：对于 $Y=1$，$p \\sim \\mathrm{Bernoulli}(\\pi_{p1})$，其中 $\\pi_{p1}=0.1$；对于 $Y=0$，$p \\sim \\mathrm{Bernoulli}(\\pi_{p0})$，其中 $\\pi_{p0}=0.7$。\n- 终止子得分：对于 $Y=1$，$t \\sim \\mathrm{Beta}(\\alpha_{t1},\\beta_{t1})$，其中 $\\alpha_{t1}=1.5$ 且 $\\beta_{t1}=5$；对于 $Y=0$，$t \\sim \\mathrm{Beta}(\\alpha_{t0},\\beta_{t0})$，其中 $\\alpha_{t0}=3.5$ 且 $\\beta_{t0}=2$。\n- 保守邻接计数：对于 $Y=1$，$c \\sim \\mathrm{Binomial}(n,\\pi_{c1})$，其中 $n=20$ 且 $\\pi_{c1}=0.6$；对于 $Y=0$，$c \\sim \\mathrm{Binomial}(n,\\pi_{c0})$，其中 $n=20$ 且 $\\pi_{c0}=0.2$。\n\n对于每个提供的测试用例特征向量 $X$，您的程序必须计算上述模型所隐含的后验概率 $P(Y=1\\mid X)$ 和 $P(Y=0\\mid X)$，并返回由下式定义的预测类别 $\\hat{Y}$\n$$\n\\hat{Y}=\\begin{cases}\n1  \\text{if } P(Y=1\\mid X)\\ge 0.5,\\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\n\n测试套件（每个元组为 $(d,r,p,t,c)$，其中 $d$ 的单位是碱基对，$r$ 和 $t$ 是在 $(0,1)$ 区间内的无量纲值，$p$ 在 $\\{0,1\\}$ 中，$c$ 是一个整数计数）：\n- 案例 $1$：$(12,\\,0.85,\\,0,\\,0.12,\\,15)$\n- 案例 $2$：$(310,\\,0.18,\\,1,\\,0.74,\\,3)$\n- 案例 $3$：$(75,\\,0.55,\\,0,\\,0.35,\\,9)$\n- 案例 $4$：$(-4,\\,0.40,\\,1,\\,0.80,\\,5)$\n- 案例 $5$：$(180,\\,0.92,\\,0,\\,0.05,\\,16)$\n- 案例 $6$：$(0,\\,0.01,\\,0,\\,0.99,\\,0)$\n\n您的程序应生成单行输出，其中包含案例1到6的六个整数预测，按顺序排列，形式为方括号括起来的逗号分隔列表，例如 $[y_1,y_2,y_3,y_4,y_5,y_6]$。每个 $y_i$ 唯一可接受的输出是整数 $0$ 或 $1$；输出中不需要任何物理单位。", "solution": "所呈现的问题是关于原核生物基因对的二元分类任务。需要确定一个基因对是构成一个真正的操纵子（用类别标签 $Y=1$ 表示），还是两个独立的转录单元（用类别标签 $Y=0$ 表示）。此分类将使用基于所提供生成模型的朴素贝叶斯分类器来执行。\n\n首先，评估问题陈述的有效性。\n\n**步骤1：提取的既定条件**\n- **类别标签**：$Y \\in \\{0, 1\\}$，其中 $Y=1$ 表示操纵子对，$Y=0$ 表示独立单元。\n- **特征向量**：$X=(d,r,p,t,c)$。\n- **特征定义**：\n    - $d \\in \\mathbb{Z}$：基因间距离，单位为碱基对 (bp)。\n    - $r \\in (0,1)$：功能相关性得分。\n    - $p \\in \\{0,1\\}$：是否存在（$1$）或不存在（$0$）内部启动子。\n    - $t \\in (0,1)$：内源性终止子得分。\n    - $c \\in \\{0,1,2,\\dots,20\\}$：在20个参考基因组中保守的邻接计数。\n- **模型假设**：\n    - **先验概率**：$P(Y=1)=0.5$ 和 $P(Y=0)=0.5$。\n    - **条件独立性**：$P(X \\mid Y)=P(d\\mid Y)\\,P(r\\mid Y)\\,P(p\\mid Y)\\,P(t\\mid Y)\\,P(c\\mid Y)$。\n- **$Y=1$（操纵子）的条件分布**：\n    - $d \\mid Y=1 \\sim \\mathcal{N}(\\mu_1=20, \\sigma_1^2=35^2)$。\n    - $r \\mid Y=1 \\sim \\mathrm{Beta}(\\alpha_{r1}=5, \\beta_{r1}=2)$。\n    - $p \\mid Y=1 \\sim \\mathrm{Bernoulli}(\\pi_{p1}=0.1)$。\n    - $t \\mid Y=1 \\sim \\mathrm{Beta}(\\alpha_{t1}=1.5, \\beta_{t1}=5)$。\n    - $c \\mid Y=1 \\sim \\mathrm{Binomial}(n=20, \\pi_{c1}=0.6)$。\n- **$Y=0$（独立单元）的条件分布**：\n    - $d \\mid Y=0 \\sim \\mathcal{N}(\\mu_0=220, \\sigma_0^2=90^2)$。\n    - $r \\mid Y=0 \\sim \\mathrm{Beta}(\\alpha_{r0}=2, \\beta_{r0}=5)$。\n    - $p \\mid Y=0 \\sim \\mathrm{Bernoulli}(\\pi_{p0}=0.7)$。\n    - $t \\mid Y=0 \\sim \\mathrm{Beta}(\\alpha_{t0}=3.5, \\beta_{t0}=2)$。\n    - $c \\mid Y=0 \\sim \\mathrm{Binomial}(n=20, \\pi_{c0}=0.2)$。\n- **分类规则**：\n$$\n\\hat{Y}=\\begin{cases}\n1  \\text{if } P(Y=1\\mid X)\\ge 0.5,\\\\\n0  \\text{otherwise.}\n\\end{cases}\n$$\n- **测试套件**：\n    - 案例 $1$：$(12,\\,0.85,\\,0,\\,0.12,\\,15)$\n    - 案例 $2$：$(310,\\,0.18,\\,1,\\,0.74,\\,3)$\n    - 案例 $3$：$(75,\\,0.55,\\,0,\\,0.35,\\,9)$\n    - 案例 $4$：$(-4,\\,0.40,\\,1,\\,0.80,\\,5)$\n    - 案例 $5$：$(180,\\,0.92,\\,0,\\,0.05,\\,16)$\n    - 案例 $6$：$(0,\\,0.01,\\,0,\\,0.99,\\,0)$\n\n**步骤2：使用提取的既定条件进行验证**\n根据验证标准对问题进行评估。\n- **科学依据**：该问题设置在计算生物学领域，涉及操纵子预测，这是生物信息学中的一个标准课题。所选的特征——基因间距离、功能相关性、启动子和终止子信号以及系统发育保守性——都是已确立的、与生物学相关的操纵子结构预测因子。所选择的概率分布（正态分布、Beta分布、伯努利分布、二项分布）是相应特征的恰当模型。参数化反映了已知的生物学趋势（例如，操纵子基因彼此靠近、功能相关，并且缺少内部启动子/终止子）。该问题在科学上是合理的。\n- **适定性**：该问题被构建为一个标准的贝叶斯分类任务。所有必要的输入、参数以及一个清晰、明确的分类规则都已提供。对于每个测试用例，都存在一个唯一、稳定且有意义的解，并且可以计算出来。\n- **客观性**：该问题使用精确的数学和生物学术语进行陈述。它不含主观、模糊或基于观点的语言。\n\n**步骤3：结论与行动**\n该问题是有效的。它在科学上是合理的、适定的和客观的。没有矛盾、信息缺失或其他不合格的缺陷。将开发一个完整的解决方案。\n\n**求解推导**\n\n目标是将一个给定的基因对（由其特征向量 $X=(d,r,p,t,c)$ 表示）分类到两个类别之一，$Y=1$（操纵子）或 $Y=0$（独立单元）。我们的任务是实现一个朴素贝叶斯分类器。\n\n决策规则是，如果后验概率 $P(Y=1 \\mid X)$ 大于或等于 $0.5$，则预测 $\\hat{Y}=1$。使用贝叶斯定理，后验概率为：\n$$ P(Y=1 \\mid X) = \\frac{P(X \\mid Y=1) P(Y=1)}{P(X)} $$\n其中证据 $P(X)$ 由全概率定律给出：\n$$ P(X) = P(X \\mid Y=1) P(Y=1) + P(X \\mid Y=0) P(Y=0) $$\n决策规则 $P(Y=1 \\mid X) \\ge 0.5$ 可以改写为：\n$$ \\frac{P(X \\mid Y=1) P(Y=1)}{P(X \\mid Y=1) P(Y=1) + P(X \\mid Y=0) P(Y=0)} \\ge 0.5 $$\n鉴于先验概率相等，$P(Y=1) = P(Y=0) = 0.5$，这简化为对类条件似然的比较：\n$$ P(X \\mid Y=1) \\ge P(X \\mid Y=0) $$\n由于特征条件独立性的假设，类别 $Y=k$（其中 $k \\in \\{0, 1\\}$）的似然是各个特征概率的乘积：\n$$ P(X \\mid Y=k) = P(d \\mid Y=k) \\cdot P(r \\mid Y=k) \\cdot P(p \\mid Y=k) \\cdot P(t \\mid Y=k) \\cdot P(c \\mid Y=k) $$\n为了避免因乘以多个小概率而导致的数值下溢，在计算上最好使用对数概率之和。决策规则等效于比较对数似然：\n$$ \\log P(X \\mid Y=1) \\ge \\log P(X \\mid Y=0) $$\n类别 $k$ 的总对数似然为：\n$$ \\mathcal{L}_k = \\log P(X \\mid Y=k) = \\log P(d \\mid Y=k) + \\log P(r \\mid Y=k) + \\log P(p \\mid Y=k) + \\log P(t \\mid Y=k) + \\log P(c \\mid Y=k) $$\n我们必须为每个测试用例计算 $\\mathcal{L}_1$ 和 $\\mathcal{L}_0$，如果 $\\mathcal{L}_1 \\ge \\mathcal{L}_0$，则预测 $\\hat{Y}=1$，否则预测 $\\hat{Y}=0$。所需的概率密度/质量函数是：\n- **$d$ 的正态分布**：对于 $d \\sim \\mathcal{N}(\\mu_k, \\sigma_k^2)$，其对数概率密度函数 (log-PDF) 为 $\\log f(d; \\mu_k, \\sigma_k^2)$。\n- **$r$ 和 $t$ 的 Beta 分布**：对于变量 $x \\sim \\mathrm{Beta}(\\alpha_{xk}, \\beta_{xk})$，其对数概率密度函数 (log-PDF) 为 $\\log f(x; \\alpha_{xk}, \\beta_{xk})$。\n- **$p$ 的伯努利分布**：对于 $p \\sim \\mathrm{Bernoulli}(\\pi_{pk})$，其对数概率质量函数 (log-PMF) 为 $\\log P(p; \\pi_{pk})$。\n- **$c$ 的二项分布**：对于 $c \\sim \\mathrm{Binomial}(n, \\pi_{ck})$，其对数概率质量函数 (log-PMF) 为 $\\log P(c; n, \\pi_{ck})$。\n\n对于每个测试用例 $X_i=(d_i, r_i, p_i, t_i, c_i)$，我们计算：\n$$ \\mathcal{L}_{1,i} = \\log P(d=d_i \\mid Y=1) + \\log P(r=r_i \\mid Y=1) + \\log P(p=p_i \\mid Y=1) + \\log P(t=t_i \\mid Y=1) + \\log P(c=c_i \\mid Y=1) $$\n$$ \\mathcal{L}_{0,i} = \\log P(d=d_i \\mid Y=0) + \\log P(r=r_i \\mid Y=0) + \\log P(p=p_i \\mid Y=0) + \\log P(t=t_i \\mid Y=0) + \\log P(c=c_i \\mid Y=0) $$\n然后，测试用例 $i$ 的预测为：\n$$ \\hat{Y}_i = \\begin{cases} 1  \\text{if } \\mathcal{L}_{1,i} \\ge \\mathcal{L}_{0,i} \\\\ 0  \\text{otherwise} \\end{cases} $$\n最终的实现将把此逻辑应用于所提供的测试套件。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm, beta, bernoulli, binom\n\ndef solve():\n    \"\"\"\n    Solves the operon prediction problem using a Naive Bayes classifier.\n    \"\"\"\n\n    # Define the parameters of the generative model for each class.\n    # Class Y=1 (operon)\n    params_1 = {\n        'd': {'loc': 20, 'scale': 35},      # Normal(mu, sigma)\n        'r': {'a': 5, 'b': 2},            # Beta(a, b)\n        'p': {'p': 0.1},                  # Bernoulli(p)\n        't': {'a': 1.5, 'b': 5},            # Beta(a, b)\n        'c': {'n': 20, 'p': 0.6}           # Binomial(n, p)\n    }\n\n    # Class Y=0 (separate transcription units)\n    params_0 = {\n        'd': {'loc': 220, 'scale': 90},     # Normal(mu, sigma)\n        'r': {'a': 2, 'b': 5},            # Beta(a, b)\n        'p': {'p': 0.7},                  # Bernoulli(p)\n        't': {'a': 3.5, 'b': 2},            # Beta(a, b)\n        'c': {'n': 20, 'p': 0.2}           # Binomial(n, p)\n    }\n\n    # Test cases: (d, r, p, t, c)\n    test_cases = [\n        (12, 0.85, 0, 0.12, 15),\n        (310, 0.18, 1, 0.74, 3),\n        (75, 0.55, 0, 0.35, 9),\n        (-4, 0.40, 1, 0.80, 5),\n        (180, 0.92, 0, 0.05, 16),\n        (0, 0.01, 0, 0.99, 0)\n    ]\n\n    results = []\n    for case in test_cases:\n        d, r, p, t, c = case\n\n        # Calculate the log-likelihood for class Y=1\n        log_likelihood_1 = (\n            norm.logpdf(d, **params_1['d']) +\n            beta.logpdf(r, **params_1['r']) +\n            bernoulli.logpmf(p, **params_1['p']) +\n            beta.logpdf(t, **params_1['t']) +\n            binom.logpmf(c, **params_1['c'])\n        )\n\n        # Calculate the log-likelihood for class Y=0\n        log_likelihood_0 = (\n            norm.logpdf(d, **params_0['d']) +\n            beta.logpdf(r, **params_0['r']) +\n            bernoulli.logpmf(p, **params_0['p']) +\n            beta.logpdf(t, **params_0['t']) +\n            binom.logpmf(c, **params_0['c'])\n        )\n\n        # Classify based on the comparison of log-likelihoods.\n        # This is equivalent to comparing posterior probabilities since priors are equal.\n        prediction = 1 if log_likelihood_1 >= log_likelihood_0 else 0\n        results.append(prediction)\n\n    # Format the final output string as required.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2410831"}, {"introduction": "虽然朴素贝叶斯分类器是一个通用的强大工具，但有时针对特定的生物学现象，我们需要更具针对性的模型。这个练习将聚焦于一个有趣的特殊情况：基因重叠。在原核生物基因组中，相邻基因的编码区发生重叠是它们属于同一个操纵子的强烈信号。您将使用逻辑回归（logistic regression）模型来精确量化重叠长度和读码框关系对操纵子概率的影响。通过这个练习[@problem_id:2410891]，您不仅能学会一种新的分类方法，还能体会到如何为独特的生物学问题量身定制计算模型。", "problem": "给定一个概率模型，用于估计原核生物基因组中同一条链上两个相邻基因属于同一操纵子的概率，该概率以负的基因间距离（IGD）为条件，其中负IGD表示重叠。设以核苷酸为单位的重叠长度用 $L$ 表示，定义为 $L = -\\mathrm{IGD}$，其中 $\\mathrm{IGD}  0$。设阅读框偏移用 $r \\in \\{0,1,2\\}$ 表示，定义为下游基因相对于上游基因的编码框差异模3。定义框类型指示符 $F$，如果 $r=0$（同框重叠），则 $F=1$，否则（移码重叠）$F=0$。\n\n该模型假定，这两个基因在同一操纵子中的概率，记为 $P(O=1 \\mid L, F)$，服从逻辑斯谛形式，\n$$\nP(O=1 \\mid L, F) \\;=\\; \\sigma\\!\\big(\\theta_0 + \\theta_1 L + \\theta_2 F + \\theta_3 L F\\big),\n$$\n其中 $\\sigma(x) = \\dfrac{1}{1+e^{-x}}$，且 $\\theta_0,\\theta_1,\\theta_2,\\theta_3$ 是实值参数。等价地，发生比满足\n$$\n\\frac{P(O=1 \\mid L,F)}{1 - P(O=1 \\mid L,F)} \\;=\\; \\exp\\!\\big(\\theta_0 + \\theta_1 L + \\theta_2 F + \\theta_3 L F\\big).\n$$\n\n参数将根据下面给出的四个规范约束进行校准。所有数值量均为无单位的概率或发生比乘数：\n1. 重叠长度 $L=1$ 时的基线移码情况：$P(O=1 \\mid L=1, F=0) = p_{\\mathrm{fs},1}$，其中 $p_{\\mathrm{fs},1} = 0.2$。\n2. 移码重叠的发生比的每核苷酸乘法变化为 $k_{\\mathrm{fs}} = 1.04$，意味着对于 $F=0$，当 $L$ 每增加一个单位时，长度为 $L$ 的发生比乘以 $k_{\\mathrm{fs}}$。\n3. 在 $L=1$ 时的同框优势是相对于 $L=1$ 时的移码重叠的发生比率 $\\rho_1 = 3.0$，意味着 $\\dfrac{\\text{odds}(L=1,F=1)}{\\text{odds}(L=1,F=0)} = \\rho_1$。\n4. 同框重叠的发生比的每核苷酸乘法变化为 $k_{\\mathrm{if}} = 1.12$，意味着对于 $F=1$，当 $L$ 每增加一个单位时，长度为 $L$ 的发生比乘以 $k_{\\mathrm{if}}$。\n\n根据这些约束，参数必须满足\n$$\n\\theta_1 = \\ln k_{\\mathrm{fs}}, \\quad\n\\theta_0 = \\ln\\!\\left(\\frac{p_{\\mathrm{fs},1}}{1 - p_{\\mathrm{fs},1}}\\right) - \\theta_1, \\quad\n\\theta_3 = \\ln k_{\\mathrm{if}} - \\theta_1, \\quad\n\\theta_2 = \\ln \\rho_1 - \\theta_3.\n$$\n\n你的任务是实现一个程序，该程序：\n- 对于每个 $\\mathrm{IGD}  0$ 的测试用例，计算 $L = -\\mathrm{IGD}$（单位：核苷酸）。\n- 如果 $r=0$，则计算 $F=1$，否则 $F=0$。\n- 使用校准后的参数 $\\theta_0, \\theta_1, \\theta_2, \\theta_3$ 为每个测试用例计算 $P(O=1 \\mid L,F)$。\n- 将每个所得概率四舍五入到六位小数。\n\n使用以下 $(\\mathrm{IGD}, r)$ 对的测试套件，其中 $\\mathrm{IGD}$ 的单位是核苷酸，而 $r$ 是无量纲的：\n- 案例 1：$\\mathrm{IGD} = -1$, $r = 1$。\n- 案例 2：$\\mathrm{IGD} = -1$, $r = 0$。\n- 案例 3：$\\mathrm{IGD} = -4$, $r = 1$。\n- 案例 4：$\\mathrm{IGD} = -4$, $r = 0$。\n- 案例 5：$\\mathrm{IGD} = -25$, $r = 0$。\n- 案例 6：$\\mathrm{IGD} = -25$, $r = 2$。\n\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5,result6]”），其中每个“result”是对应于上面列出的测试用例的四舍五入后的概率 $P(O=1 \\mid L,F)$，顺序相同。输出是四舍五入到六位小数的无单位浮点数。", "solution": "我们使用一个以重叠长度和框类型为条件的逻辑斯谛模型，来形式化两个具有负基因间距离的相邻基因位于同一操纵子中的概率。设基因间距离（IGD）为同一链上上游开放阅读框（ORF）末端与下游ORF起始点之间的核苷酸距离，负值表示重叠。定义 $L = -\\mathrm{IGD}$，因此 $L \\in \\mathbb{Z}_{0}$ 是以核苷酸为单位的重叠长度。定义阅读框偏移 $r \\in \\{0,1,2\\}$，以及框类型指示符 $F$，如果 $r=0$（同框），则 $F=1$，否则（移码）$F=0$。\n\n逻辑斯谛模型为\n$$\nP(O=1 \\mid L,F) = \\sigma\\!\\big(\\theta_0 + \\theta_1 L + \\theta_2 F + \\theta_3 L F\\big), \\quad \\sigma(x)=\\frac{1}{1+e^{-x}}.\n$$\n等价地，对数发生比（logit）在特征 $L$、$F$ 和 $L F$ 上是线性的。为了从第一性原理确定参数，我们将给定的校准约束编码为关于发生比的关系。设 $p_{\\mathrm{fs},1}$ 为移码重叠在 $L=1$ 时的基线概率，而 $k_{\\mathrm{fs}}$ 为移码重叠的每核苷酸发生比乘数。那么对于 $F=0$，\n$$\n\\log\\frac{P}{1-P} = \\theta_0 + \\theta_1 L \\quad \\Rightarrow \\quad \\theta_1 = \\ln k_{\\mathrm{fs}}, \\;\\; \\theta_0 + \\theta_1 \\cdot 1 = \\ln\\!\\left(\\frac{p_{\\mathrm{fs},1}}{1-p_{\\mathrm{fs},1}}\\right),\n$$\n所以\n$$\n\\theta_1 = \\ln k_{\\mathrm{fs}}, \\quad \\theta_0 = \\ln\\!\\left(\\frac{p_{\\mathrm{fs},1}}{1-p_{\\mathrm{fs},1}}\\right) - \\theta_1.\n$$\n对于同框重叠，每核苷酸发生比乘数为 $k_{\\mathrm{if}}$，且在 $L=1$ 时的同框优势是相对于 $L=1$ 时移码的发生比率 $\\rho_1$。对于 $F=1$ 我们有\n$$\n\\log\\frac{P}{1-P} = (\\theta_0 + \\theta_2) + (\\theta_1 + \\theta_3) L,\n$$\n所以每核苷酸乘数条件意味着 $\\theta_1 + \\theta_3 = \\ln k_{\\mathrm{if}}$，即\n$$\n\\theta_3 = \\ln k_{\\mathrm{if}} - \\ln k_{\\mathrm{fs}}.\n$$\n在 $L=1$ 时的发生比率为\n$$\n\\rho_1 = \\frac{\\exp\\big(\\theta_0 + \\theta_1 \\cdot 1 + \\theta_2 + \\theta_3 \\cdot 1\\big)}{\\exp\\big(\\theta_0 + \\theta_1 \\cdot 1\\big)} = \\exp(\\theta_2 + \\theta_3),\n$$\n因此\n$$\n\\theta_2 = \\ln \\rho_1 - \\theta_3.\n$$\n\n使用提供的数值 $p_{\\mathrm{fs},1} = 0.2$，$k_{\\mathrm{fs}} = 1.04$，$\\rho_1 = 3.0$ 和 $k_{\\mathrm{if}} = 1.12$，我们得到\n$$\n\\theta_1 = \\ln(1.04), \\quad\n\\theta_0 = \\ln\\!\\left(\\frac{0.2}{0.8}\\right) - \\ln(1.04), \\quad\n\\theta_3 = \\ln(1.12) - \\ln(1.04), \\quad\n\\theta_2 = \\ln(3.0) - \\theta_3.\n$$\n这些常数完全确定了该模型。\n\n对于每个测试用例 $(\\mathrm{IGD}, r)$，计算 $L = -\\mathrm{IGD}$，并且如果 $r=0$ 则 $F=1$，否则 $F=0$。然后计算对数发生比 $z = \\theta_0 + \\theta_1 L + \\theta_2 F + \\theta_3 L F$，转换为发生比 $o = e^{z}$，最后通过 $P = \\dfrac{o}{1+o}$ 转换为概率。将每个 $P$ 四舍五入到六位小数。\n\n将此过程应用于六个指定的测试用例，会产生六个无单位的概率，对应于校准模型下的操纵子成员资格概率，按相同顺序报告，并格式化为单行上的一个列表。在给定校准的情况下，计算是确定性的，并且不需要外部数据。程序将精确执行这些步骤，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nimport numpy as np  # Allowed library; not strictly required but imported per environment spec.\n\ndef sigmoid(x: float) -> float:\n    # Numerically stable logistic function for moderate x.\n    if x >= 0:\n        z = math.exp(-x)\n        return 1.0 / (1.0 + z)\n    else:\n        z = math.exp(x)\n        return z / (1.0 + z)\n\ndef calibrate_parameters(p_fs1: float, k_fs: float, rho1: float, k_if: float):\n    \"\"\"\n    Compute theta0, theta1, theta2, theta3 from the calibration constraints:\n    theta1 = ln(k_fs)\n    theta0 = ln(p_fs1/(1-p_fs1)) - theta1\n    theta3 = ln(k_if) - theta1\n    theta2 = ln(rho1) - theta3\n    \"\"\"\n    theta1 = math.log(k_fs)\n    # avoid division by zero (not applicable here because p_fs1 in (0,1))\n    odds_fs1 = p_fs1 / (1.0 - p_fs1)\n    theta0 = math.log(odds_fs1) - theta1\n    theta3 = math.log(k_if) - theta1\n    theta2 = math.log(rho1) - theta3\n    return theta0, theta1, theta2, theta3\n\ndef operon_probability(igd: int, r: int, thetas):\n    \"\"\"\n    Compute P(O=1 | L, F) where L = -IGD (IGD  0), F = 1 if r % 3 == 0 else 0.\n    \"\"\"\n    theta0, theta1, theta2, theta3 = thetas\n    if igd >= 0:\n        raise ValueError(\"IGD must be negative for overlaps\")\n    L = -int(igd)\n    F = 1 if (r % 3 == 0) else 0\n    z = theta0 + theta1 * L + theta2 * F + theta3 * L * F\n    p = sigmoid(z)\n    return p\n\ndef solve():\n    # Calibration constants\n    p_fs1 = 0.2     # Baseline probability at L=1 for frameshift overlaps\n    k_fs  = 1.04    # Per-nucleotide odds multiplier for frameshift overlaps\n    rho1  = 3.0     # Odds ratio (in-frame vs frameshift) at L=1\n    k_if  = 1.12    # Per-nucleotide odds multiplier for in-frame overlaps\n\n    # Calibrate model parameters\n    thetas = calibrate_parameters(p_fs1, k_fs, rho1, k_if)\n\n    # Define the test cases from the problem statement: (IGD, r)\n    test_cases = [\n        (-1, 1),   # Case 1\n        (-1, 0),   # Case 2\n        (-4, 1),   # Case 3\n        (-4, 0),   # Case 4\n        (-25, 0),  # Case 5\n        (-25, 2),  # Case 6\n    ]\n\n    results = []\n    for igd, r in test_cases:\n        p = operon_probability(igd, r, thetas)\n        # Round to six decimal places as required\n        p_rounded = float(f\"{p:.6f}\")\n        results.append(p_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{v:.6f}' for v in results)}]\")\n\nsolve()\n```", "id": "2410891"}]}