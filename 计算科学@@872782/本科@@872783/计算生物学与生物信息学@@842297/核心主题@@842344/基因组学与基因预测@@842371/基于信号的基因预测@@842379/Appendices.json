{"hands_on_practices": [{"introduction": "在深入研究基因预测的计算模型之前，我们首先需要理解其所要解决问题的巨大规模。一个基因并非只能产生一种蛋白质，通过可变剪接机制，它可以生成多种不同的信使核糖核酸（mRNA）转录本。这项练习将通过一个思想实验，帮助你量化这种由可变剪接带来的组合复杂性，从而体会到为何我们需要强大的计算工具来解析基因的潜在结构。[@problem_id:2429057]", "problem": "一个基于信号的基因预测模型会为真核基因中的每个外显子边界分配有效的剪接供体和受体信号。考虑一个具有固定启动子和固定多聚腺苷酸化位点的基因，其转录区域由两个组成型外显子组成，这两个外显子侧翼连接着一个包含 $N$ 个盒式外显子的片段。此处的盒式外显子定义为可以被包含在成熟信使核糖核酸（mRNA）中，或通过剪接被省略的外显子，而不改变外显子的顺序或组成型外显子的位置。假设在存在剪接信号的条件下，每个盒式外显子的包含或跳过是剪接机制做出的独立决定，并且所有产生的剪接转录本在外显子组成上都是不同的。忽略任何阅读框架限制、无义介导的降解或其他下游选择效应。\n\n在这些假设下，可以从该基因产生的不同剪接后mRNA转录本变体的总数是多少？请用一个关于 $N$ 的闭式解析表达式来表示你的答案。无需四舍五入。", "solution": "首先将对问题陈述进行严格的验证过程。\n\n步骤1：提取已知条件\n以下是逐字从问题陈述中列出的已知条件：\n- 一个基因具有“固定启动子和固定多聚腺苷酸化位点”。\n- 转录区域由“两个组成型外显子组成，这两个外显子侧翼连接着一个包含 $N$ 个盒式外显子的片段”。\n- 盒式外显子是“可以被包含在成熟信使核糖核酸（mRNA）中，或通过剪接被省略”的外显子。\n- “每个盒式外显子的包含或跳过是独立的决定”。\n- “所有产生的剪接转录本在外显子组成上都是不同的”。\n- 问题要求忽略“任何阅读框架限制、无义介导的降解或其他下游选择效应”。\n- 目标是找到“不同剪接后mRNA转录本变体的总数”，并以“关于 $N$ 的闭式解析表达式”表示。\n\n步骤2：使用提取的已知条件进行验证\n根据既定的有效性标准对问题进行评估。\n\n- **科学基础**：该问题具有科学基础。启动子、多聚腺苷酸化、组成型外显子、盒式外显子和可变剪接等概念是分子生物学和生物信息学中的基本原理。所提出的模型是一种简化但标准的组合方法，用于模拟可变剪接的结果。它没有违反既定的科学事实。\n- **适定性**：该问题是适定的。它定义了一组离散的组件（$N$ 个盒式外显子）和每个组件的二元选择（包含或排除）。独立性假设将问题简化为一个标准的组合计数练习，该练习具有唯一且有意义的解。\n- **客观性**：问题以客观、正式的语言陈述。它没有主观断言或模糊不清之处。\n- **完整性和一致性**：问题是自洽的。假设（例如，独立性、忽略下游效应）被明确陈述，为构建解决方案提供了所有必要信息。没有内部矛盾。\n\n该问题没有表现出任何会使其无效的缺陷。它是一个可形式化的、相关的、结构良好的计算生物学问题。\n\n步骤3：结论与行动\n该问题被判定为**有效**。将推导出一个解决方案。\n\n该问题要求计算一个具有特定结构的基因可以产生的不同mRNA转录本的总数。这是一个组合数学问题。基因的结构涉及两种类型的外显子：组成型外显子和盒式外显子。\n\n根据定义，两个组成型外显子总是存在于从该基因产生的任何成熟mRNA转录本中。我们将上游的组成型外显子表示为 $E_{C1}$，下游的表示为 $E_{C2}$。由于它们的包含是强制性的，因此它们对转录本群体的变异性没有贡献。对于这些外显子中的每一个，只有一种可能性：包含。因此，转录本组成部分的选项数量为 $1 \\times 1 = 1$。\n\n组成型外显子之间的片段包含 $N$ 个盒式外显子。我们将这些外显子表示为 $E_{K1}, E_{K2}, \\dots, E_{KN}$。盒式外显子被定义为一个可选单元；它既可以被包含在最终的转录本中，也可以被排除（跳过）。因此，对于每个盒式外显子 $E_{Ki}$，其中 $i \\in \\{1, 2, \\dots, N\\}$，恰好有 $2$ 种可能的结果：\n1. 外显子 $E_{Ki}$ 被包含。\n2. 外显子 $E_{Ki}$ 被排除。\n\n问题陈述指出，每个盒式外显子的剪接决定是一个“独立的决定”。这是一条关键信息。在组合数学中，一系列独立事件的总结果数是每个独立事件结果数的乘积。这被称为乘法原理或乘积法则。\n\n将此原理应用于 $N$ 个盒式外显子：\n- 对于外显子 $E_{K1}$，有 $2$ 个选择。\n- 对于外显子 $E_{K2}$，有 $2$ 个选择，无论对 $E_{K1}$ 的选择如何。\n- 这种模式对所有 $N$ 个盒式外显子都适用。\n- 对于外显子 $E_{KN}$，有 $2$ 个选择，无论对前面 $N-1$ 个外显子的选择如何。\n\n包含和排除盒式外显子的不同组合总数是 $N$ 个外显子中每个外显子选择数的乘积。\n令 $T$ 为不同转录本变体的总数。\n$$T = \\underbrace{2 \\times 2 \\times \\dots \\times 2}_{N \\text{ 次}}$$\n\n这个乘积等于 $2$ 的 $N$ 次方。\n$$T = 2^{N}$$\n\n问题还指出，“所有产生的剪接转录本在外显子组成上都是不同的”。这证实了每个唯一的外显子包含/排除选择组合都会产生一个唯一的转录本变体，因此没有两种组合是冗余的。固定的组成型外显子的存在不会改变这个计数，因为它们在所有这 $2^{N}$ 个变体中都构成了一个恒定的背景。\n\n因此，以盒式外显子数量 $N$ 的函数表示的不同剪接后mRNA转录本变体的总数是 $2^{N}$。这是所要求的闭式解析表达式。", "answer": "$$\\boxed{2^{N}}$$", "id": "2429057"}, {"introduction": "位置权重矩阵（PWM）是识别和量化如剪接位点等DNA信号强度的核心工具。然而，一个信号的得分高低仅仅是故事的一部分；更重要的是了解信号的哪些位置最为关键，以及它对突变的敏感程度。本练习将指导你进行一次“虚拟定点突变”分析，通过系统性地改变剪接位点周围的每个碱基并计算得分变化量（$ \\Delta S $），来识别信号中的功能核心，并深入理解信号的稳健性。[@problem_id:2429077]", "problem": "给定一个有限字母表 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 和一个围绕假定剪接位点的长度为 $L$ 的窗口序列模型。对于 $\\Sigma$ 上的一个长度为 $L$ 的序列 $s$，其在位置权重矩阵 (PWM) 模型下的得分 $S(s)$ 定义为\n$$\nS(s) \\;=\\; \\sum_{i=1}^{L} \\ln\\!\\left(\\frac{P_{i,b_i}}{Q_{b_i}}\\right),\n$$\n其中 $b_i \\in \\Sigma$ 是 $s$ 中位置 $i$ 处的碱基，$P_{i,\\cdot}$ 是位置 $i$ 上 $\\Sigma$ 的位置特异性多项分布，$Q_{\\cdot}$ 是 $\\Sigma$ 上的背景多项分布，$\\ln(\\cdot)$ 表示自然对数。任何向量内核苷酸的顺序固定为 $[\\text{A},\\text{C},\\text{G},\\text{T}]$。\n\n对于每个位置 $i \\in \\{1,\\dots,L\\}$ 以及每个将参考碱基 $r_i$ 替换为不同碱基 $b \\in \\Sigma \\setminus \\{r_i\\}$ 的可能点突变，定义单点突变分数变化为\n$$\n\\Delta S(i,b) \\;=\\; S\\big(s^{(i \\rightarrow b)}\\big) \\;-\\; S(s),\n$$\n其中 $s^{(i \\rightarrow b)}$ 是一个序列，它与 $s$ 相同，只是在位置 $i$ 处的碱基是 $b$ 而不是 $r_i$。对于每个位置 $i$，将位置敏感性定义为最有害的单点突变变化\n$$\n\\Delta S_{\\min}(i) \\;=\\; \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\Delta S(i,b).\n$$\n\n您的任务是计算下面每个测试用例中所有位置 $i$ 的 $\\Delta S_{\\min}(i)$，并将每个值四舍五入到 $6$ 位小数。\n\n测试套件（所有概率均按 $[\\text{A},\\text{C},\\text{G},\\text{T}]$ 的顺序给出）：\n\n- 测试用例 $1$（供体样 PWM，在剪接点周围位置具有强 $\\text{G}\\text{T}$）：\n  - 长度 $L = 9$。\n  - 背景分布 $Q = [\\,0.30,\\,0.20,\\,0.20,\\,0.30\\,]$。\n  - 参考序列 $s = \\text{\"CAGGTAAGT\"}$。\n  - $i=1,\\dots,9$ 的 PWM 概率 $P$（以行 $P_{i,\\cdot}$ 表示）：\n    - $i=1$: $[\\,0.35,\\,0.25,\\,0.25,\\,0.15\\,]$\n    - $i=2$: $[\\,0.40,\\,0.20,\\,0.25,\\,0.15\\,]$\n    - $i=3$: $[\\,0.45,\\,0.15,\\,0.25,\\,0.15\\,]$\n    - $i=4$: $[\\,0.07,\\,0.07,\\,0.80,\\,0.06\\,]$\n    - $i=5$: $[\\,0.06,\\,0.07,\\,0.07,\\,0.80\\,]$\n    - $i=6$: $[\\,0.30,\\,0.25,\\,0.25,\\,0.20\\,]$\n    - $i=7$: $[\\,0.60,\\,0.15,\\,0.15,\\,0.10\\,]$\n    - $i=8$: $[\\,0.20,\\,0.20,\\,0.50,\\,0.10\\,]$\n    - $i=9$: $[\\,0.20,\\,0.20,\\,0.10,\\,0.50\\,]$\n\n- 测试用例 $2$（PWM 和背景与测试用例 $1$ 相同，参考序列不同）：\n  - 长度 $L = 9$。\n  - 背景分布 $Q = [\\,0.30,\\,0.20,\\,0.20,\\,0.30\\,]$。\n  - 参考序列 $s = \\text{\"TAGGTGAGT\"}$。\n  - PWM 概率 $P$ 与测试用例 $1$ 中的相同。\n\n- 测试用例 $3$（无信息 PWM 等于背景，边缘情况）：\n  - 长度 $L = 6$。\n  - 背景分布 $Q = [\\,0.25,\\,0.25,\\,0.25,\\,0.25\\,]$。\n  - 参考序列 $s = \\text{\"ACGTAC\"}$。\n  - PWM 概率 $P$ 的每一行都等于 $[\\,0.25,\\,0.25,\\,0.25,\\,0.25\\,]$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的嵌套列表。每个内部列表对应一个测试用例，并按位置顺序 $i=1$ 到 $i=L$ 包含 $L$ 个 $\\Delta S_{\\min}(i)$ 的浮点值。例如，一个包含三个测试用例的输出必须类似于 $[[x_{1,1},\\dots,x_{1,L_1}],[x_{2,1},\\dots,x_{2,L_2}],[x_{3,1},\\dots,x_{3,L_3}]]$，其中每个 $x_{t,i}$ 都四舍五入到 $6$ 位小数。不涉及单位，也不应打印任何附加文本。", "solution": "问题陈述已经过严格验证，并被确定为是合理的。它在科学上基于生物信息学和统计序列分析的原理，问题提出得很好，提供了所有必要的信息，并使用精确的数学定义进行了客观的阐述。没有发现任何缺陷。我们可以继续进行解答。\n\n该问题要求计算给定核苷酸序列 $s$ 中每个位置 $i$ 的位置敏感性 $\\Delta S_{\\min}(i)$。该敏感性定义为在该位置发生单点突变所导致的序列得分 $S(s)$ 的最有害变化。得分本身基于位置权重矩阵 (PWM) 模型，这是序列基序的一种常见表示方法。\n\n序列 $s = b_1 b_2 \\dots b_L$ 的得分 $S(s)$ 是一个对数似然比，由下式给出：\n$$\nS(s) = \\sum_{i=1}^{L} \\ln\\left(\\frac{P_{i,b_i}}{Q_{b_i}}\\right)\n$$\n在这里，$P_{i,b_i}$ 是根据基序模型在位置 $i$ 观察到碱基 $b_i$ 的概率，而 $Q_{b_i}$ 是根据背景模型观察到碱基 $b_i$ 的概率。该得分量化了序列 $s$ 在基序模型下相对于背景模型的可能性高出多少。\n\n我们被要求找出当单个位置 $i$ 处的参考碱基 $r_i$ 突变为新碱基 $b \\in \\Sigma \\setminus \\{r_i\\}$ 时分数的改变量 $\\Delta S(i,b)$。原始序列是 $s$，突变后的序列是 $s^{(i \\rightarrow b)}$。得分的变化是：\n$$\n\\Delta S(i,b) = S\\big(s^{(i \\rightarrow b)}\\big) - S(s)\n$$\n\n让我们展开这个表达式。原始序列 $s$ 的得分，其在每个位置 $j$ 的参考碱基为 $r_j$，是：\n$$\nS(s) = \\sum_{j=1}^{L} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right) = \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{j,r_j}}\\right)\n$$\n突变序列 $s^{(i \\rightarrow b)}$ 的得分，它仅在位置 $i$ 处不同，是：\n$$\nS\\big(s^{(i \\rightarrow b)}\\big) = \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right)\n$$\n当我们计算差值 $\\Delta S(i,b)$ 时，代表所有未改变位置贡献的总和项完全抵消了。这大大简化了计算：\n$$\n\\Delta S(i,b) = \\left( \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right) \\right) - \\left( \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right) + \\sum_{j \\neq i} \\ln\\left(\\frac{P_{j,r_j}}{Q_{r_j}}\\right) \\right)\n$$\n$$\n\\Delta S(i,b) = \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) - \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right)\n$$\n这表明，由于位置 $i$ 的突变而导致的总分变化仅取决于为该特定位置定义的概率。让我们将位置 $i$ 处碱基 $x$ 的对数优势比分数定义为 $L_i(x) = \\ln(P_{i,x}/Q_x)$。那么，$\\Delta S(i,b) = L_i(b) - L_i(r_i)$。\n\n位置敏感性 $\\Delta S_{\\min}(i)$ 是在位置 $i$ 处所有可能突变中这种变化的最小值。\n$$\n\\Delta S_{\\min}(i) = \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\Delta S(i,b)\n$$\n代入我们简化的 $\\Delta S(i,b)$ 表达式：\n$$\n\\Delta S_{\\min}(i) = \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\left( \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) - \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right) \\right)\n$$\n由于项 $\\ln(P_{i,r_i}/Q_{r_i})$ 相对于最小化变量 $b$ 是恒定的，我们可以写成：\n$$\n\\Delta S_{\\min}(i) = \\left( \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} \\ln\\left(\\frac{P_{i,b}}{Q_b}\\right) \\right) - \\ln\\left(\\frac{P_{i,r_i}}{Q_{r_i}}\\right)\n$$\n\n计算每个位置 $i=1, \\dots, L$ 的 $\\Delta S_{\\min}(i)$ 的算法如下：\n1.  对于参考序列 $s$ 中的每个位置 $i$，识别参考碱基 $r_i$。\n2.  使用提供的 PWM $P$ 和背景分布 $Q$，计算参考碱基的对数优势比分数：$L_i(r_i) = \\ln(P_{i,r_i}/Q_{r_i})$。\n3.  对于三个可能的突变碱基 $b \\in \\Sigma \\setminus \\{r_i\\}$ 中的每一个，计算其相应的对数优势比分数：$L_i(b) = \\ln(P_{i,b}/Q_b)$。\n4.  在三个突变体对数优势比分数中找到最小值：$L_{i, \\text{min\\_mut}} = \\min_{b \\in \\Sigma \\setminus \\{r_i\\}} L_i(b)$。\n5.  位置敏感性是最小突变体得分与参考得分之间的差值：$\\Delta S_{\\min}(i) = L_{i, \\text{min\\_mut}} - L_i(r_i)$。\n6.  对每个测试用例的所有位置 $i=1, \\dots, L$ 重复此过程。结果四舍五入到 $6$ 位小数。\n\n对于 PWM 无信息且等于背景分布的特殊情况（即，对于所有 $i, b$，$P_{i,b} = Q_b$），任何位置上任何碱基的对数优势比分数都是 $\\ln(1) = 0$。因此，对于所有突变，$\\Delta S(i,b) = 0 - 0 = 0$，从而对于所有位置，$\\Delta S_{\\min}(i) = 0$。这一点由测试用例 3 的计算得到证实。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the positional sensitivity problem for the given test suite.\n    \"\"\"\n    \n    # Define a mapping from nucleotide characters to array indices.\n    base_to_idx = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    idx_to_base = ['A', 'C', 'G', 'T']\n    \n    # Define the test cases from the problem statement.\n    p_matrix_tc1 = np.array([\n        [0.35, 0.25, 0.25, 0.15],\n        [0.40, 0.20, 0.25, 0.15],\n        [0.45, 0.15, 0.25, 0.15],\n        [0.07, 0.07, 0.80, 0.06],\n        [0.06, 0.07, 0.07, 0.80],\n        [0.30, 0.25, 0.25, 0.20],\n        [0.60, 0.15, 0.15, 0.10],\n        [0.20, 0.20, 0.50, 0.10],\n        [0.20, 0.20, 0.10, 0.50]\n    ])\n    \n    p_matrix_tc3 = np.array([\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n        [0.25, 0.25, 0.25, 0.25],\n    ])\n\n    test_cases = [\n        {\n            \"L\": 9,\n            \"Q\": np.array([0.30, 0.20, 0.20, 0.30]),\n            \"s\": \"CAGGTAAGT\",\n            \"P\": p_matrix_tc1\n        },\n        {\n            \"L\": 9,\n            \"Q\": np.array([0.30, 0.20, 0.20, 0.30]),\n            \"s\": \"TAGGTGAGT\",\n            \"P\": p_matrix_tc1\n        },\n        {\n            \"L\": 6,\n            \"Q\": np.array([0.25, 0.25, 0.25, 0.25]),\n            \"s\": \"ACGTAC\",\n            \"P\": p_matrix_tc3\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        L = case[\"L\"]\n        Q = case[\"Q\"]\n        s = case[\"s\"]\n        P = case[\"P\"]\n        \n        positional_sensitivities = []\n        for i in range(L):\n            # Identify reference base and its index\n            ref_base = s[i]\n            ref_idx = base_to_idx[ref_base]\n            \n            # Get the PWM probabilities for the current position\n            p_row = P[i]\n            \n            # Calculate log-odds score for the reference base\n            ref_log_odds = np.log(p_row[ref_idx] / Q[ref_idx])\n\n            # Calculate log-odds scores for all possible mutations\n            mutant_log_odds = []\n            for b_idx in range(4): # 4 bases in the alphabet\n                if b_idx != ref_idx:\n                    log_odds = np.log(p_row[b_idx] / Q[b_idx])\n                    mutant_log_odds.append(log_odds)\n            \n            # Find the minimum (most deleterious) mutant score\n            min_mutant_log_odds = min(mutant_log_odds)\n\n            # Calculate positional sensitivity delta_S_min(i)\n            delta_s_min = min_mutant_log_odds - ref_log_odds\n            \n            # Round to 6 decimal places and append\n            positional_sensitivities.append(round(delta_s_min, 6))\n            \n        all_results.append(positional_sensitivities)\n\n    # Format the final output string as a nested list string.\n    # The str() representation of a Python list is exactly the format required.\n    # Whitespace must be removed for exact match.\n    output_str = f\"[{','.join(str(res).replace(' ', '') for res in all_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "2429077"}, {"introduction": "真正的基因预测任务远不止是找到孤立的信号。它要求我们将这些信号——启动子、起始密码子、剪接位点和终止密码子——组装成一个语法正确且生物学上合理的完整基因结构。这项高级练习将基因预测问题巧妙地转化为一个图论中的路径寻找问题。在这个框架下，你的目标是找到一条“最短路径”，它对应于总成本最低（或得分最高）的基因模型，这个过程将让你体验到动态规划在解决这类复杂组合优化问题时的强大威力。[@problem_id:2429125]", "problem": "给定一个基于信号的基因预测的形式化模型，该模型将基因解码视为一个在有向无环图上的约束最小化问题，图的节点是候选的基因组信号。每个候选信号是脱氧核糖核酸（DNA）序列上的一个推定生物信号，例如启动子、起始密码子、剪接供体位点、剪接受体位点或终止密码子。位置以碱基对（bp）为单位进行测量。您将获得候选信号、它们的位置以及它们的非负信号成本。目标是选择这些候选信号的一个有序子集，形成一个总成本最小的有效基因结构。总成本结合了所选信号的成本以及外显子和内含子的长度模型惩罚。\n\n定义与符号：\n- 设 $S$ 为一个长度为 $N$ 碱基对（bp）的DNA序列。\n- 每个候选信号 $j$ 具有：\n  - 一个类型 $t_j \\in \\{\\text{P}, \\text{S}, \\text{D}, \\text{A}, \\text{T}\\}$，分别表示启动子（P）、起始密码子（S）、剪接供体（D）、剪接受体（A）和终止密码子（T）。\n  - 一个基因组位置 $p_j \\in \\{1,2,\\dots,N\\}$，单位为 bp。\n  - 一个非负信号成本 $c_j \\ge 0$。\n- 一个有效的基因结构是一个有序的候选序列，其类型遵循以下模式：\n  - 一个启动子 $\\rightarrow$ 一个起始密码子 $\\rightarrow$ 零次或多次重复的（供体 $\\rightarrow$ 受体）对 $\\rightarrow$ 一个终止密码子。\n  - 沿所选序列，位置必须严格递增：如果候选信号 $i$ 和 $k$ 在序列中是连续的，则 $p_i  p_k$。\n- 启动子到起始密码子的距离必须满足一个约束：如果启动子位于 $p_{\\text{P}}$，起始密码子位于 $p_{\\text{S}}$，则距离 $d = p_{\\text{S}} - p_{\\text{P}}$ 必须满足 $D_{\\min} \\le d \\le D_{\\max}$。\n- 外显子片段是以下两者之间的连续编码区：\n  - 起始密码子 $\\rightarrow$ 供体，\n  - 受体 $\\rightarrow$ 供体（对于内部外显子），\n  - 受体 $\\rightarrow$ 终止密码子，\n  - 起始密码子 $\\rightarrow$ 终止密码子（对于没有内含子的单外显子基因）。\n- 内含子片段是供体 $\\rightarrow$ 受体之间的连续非编码区。\n- 设 $L$ 表示一个片段的长度，单位为 bp。外显子长度会产生惩罚 $f_{\\text{exon}}(L)$，内含子长度会产生惩罚 $f_{\\text{intron}}(L)$，其中\n  $$f_{\\text{exon}}(L) = \\frac{(L - \\mu_{\\text{e}})^2}{2 \\sigma_{\\text{e}}^2}, \\quad f_{\\text{intron}}(L) = \\frac{(L - \\mu_{\\text{i}})^2}{2 \\sigma_{\\text{i}}^2}.$$\n  这里 $\\mu_{\\text{e}}$ 和 $\\sigma_{\\text{e}}$ 分别是外显子长度的均值和标准差，$\\mu_{\\text{i}}$ 和 $\\sigma_{\\text{i}}$ 分别是内含子长度的均值和标准差。\n- 对于一个选择了有序信号序列 $(j_1, j_2, \\dots, j_m)$ 且位置严格递增 $(p_{j_1}  p_{j_2}  \\dots  p_{j_m})$ 的有效基因结构，其总成本 $C$ 是以下各项之和：\n  - 所有信号成本 $\\sum_{r=1}^{m} c_{j_r}$，\n  - 加上每个外显子片段的外显子惩罚 $f_{\\text{exon}}(L)$，\n  - 加上每个内含子片段的内含子惩罚 $f_{\\text{intron}}(L)$，\n  其中，连接位置为 $p_{u}  p_{v}$ 的连续信号的片段长度 $L$ 定义为 $L = p_{v} - p_{u} - 1$ bp。\n\n所有测试用例的全局常量：\n- 外显子长度参数：$\\mu_{\\text{e}} = 150$，$\\sigma_{\\text{e}} = 30$ (bp)。\n- 内含子长度参数：$\\mu_{\\text{i}} = 200$，$\\sigma_{\\text{i}} = 40$ (bp)。\n- 启动子到起始密码子的距离约束：$D_{\\min} = 20$， $D_{\\max} = 1000$ (bp)。\n\n有效性约束：\n- 只允许以下连续的信号类型转换：\n  - $\\text{P} \\rightarrow \\text{S}$，带有启动子到起始密码子的距离约束 $D_{\\min} \\le p_{\\text{S}} - p_{\\text{P}} \\le D_{\\max}$，且无片段惩罚。\n  - $\\text{S} \\rightarrow \\text{D}$，带有外显子惩罚 $f_{\\text{exon}}(p_{\\text{D}} - p_{\\text{S}} - 1)$。\n  - $\\text{A} \\rightarrow \\text{D}$，带有外显子惩罚 $f_{\\text{exon}}(p_{\\text{D}} - p_{\\text{A}} - 1)$。\n  - $\\text{D} \\rightarrow \\text{A}$，带有内含子惩罚 $f_{\\text{intron}}(p_{\\text{A}} - p_{\\text{D}} - 1)$。\n  - $\\S \\rightarrow \\text{T}$，带有外显子惩罚 $f_{\\text{exon}}(p_{\\text{T}} - p_{\\S} - 1)$。\n  - $\\text{A} \\rightarrow \\text{T}$，带有外显子惩罚 $f_{\\text{exon}}(p_{\\text{T}} - p_{\\text{A}} - 1)$。\n- 所选序列必须包含恰好一个启动子、一个起始密码子、一个终止密码子，以及零个或多个正确排序的供体-受体对，所有信号的位置都必须严格递增。\n\n目标：\n- 在所有有效的基因结构中，找到使总成本 $C$ 最小化的那一个。\n\n输出规范：\n- 对每个测试用例，按顺序将所选信号的基因组位置（整数，单位为bp）作为一个列表输出：$[\\text{启动子}, \\text{起始密码子}, (\\text{供体}, \\text{受体})^*, \\text{终止密码子}]$。\n- 如果多个有效结构达到相同的最小成本（在 $\\varepsilon = 10^{-9}$ 的容差范围内），选择其位置列表字典序最小的那个。\n- 您的程序应生成单行输出，包含一个由逗号分隔并用方括号括起来的列表（例如：\"[[...],[...],[...]]\"），其中不含空格。所有位置必须是以碱基对（bp）为单位的整数。\n\n测试套件（三个独立案例）。对于每个案例，$N$ 是序列长度（bp），后跟候选信号及其类型、位置 $p$ 和成本 $c$：\n\n- 案例 1：\n  - $N = 1000$。\n  - 候选信号：\n    - 启动子：$(\\text{P}, p=100, c=0.5)$, $(\\text{P}, p=300, c=0.2)$。\n    - 起始密码子：$(\\text{S}, p=350, c=0.2)$, $(\\text{S}, p=600, c=0.4)$。\n    - 供体：$(\\text{D}, p=500, c=0.25)$, $(\\text{D}, p=650, c=0.45)$。\n    - 受体：$(\\text{A}, p=720, c=0.25)$, $(\\text{A}, p=800, c=0.5)$。\n    - 终止密码子：$(\\text{T}, p=900, c=0.2)$。\n- 案例 2：\n  - $N = 500$。\n  - 候选信号：\n    - 启动子：$(\\text{P}, p=30, c=0.15)$。\n    - 起始密码子：$(\\text{S}, p=100, c=0.25)$。\n    - 供体：$(\\text{D}, p=200, c=0.3)$。\n    - 受体：$(\\text{A}, p=150, c=0.2)$。\n    - 终止密码子：$(\\text{T}, p=480, c=0.25)$。\n- 案例 3：\n  - $N = 1200$。\n  - 候选信号：\n    - 启动子：$(\\text{P}, p=101, c=0.1)$, $(\\text{P}, p=100, c=0.22)$, $(\\text{P}, p=80, c=0.4)$。\n    - 起始密码子：$(\\text{S}, p=120, c=0.2)$。\n    - 供体：$(\\text{D}, p=270, c=0.28)$, $(\\text{D}, p=300, c=0.3)$。\n    - 受体：$(\\text{A}, p=440, c=0.31)$, $(\\text{A}, p=470, c=0.35)$。\n    - 终止密码子：$(\\text{T}, p=700, c=0.25)$。\n\n最终输出格式：\n- 您的程序必须打印一行，代表一个包含三个列表的列表，每个案例一个，没有空格。每个内部列表是所选信号的有序整数位置（以bp为单位），例如：\"[[p1,p2,...],[q1,q2,...],[r1,r2,...]]\"。", "solution": "所提出的问题是通过最小化一个总成本函数，从一组候选基因组信号中识别出最优的基因结构。该成本函数是信号特定成本与推断出的外显子和内含子片段的长度依赖性惩罚的聚合。这是一个经典的优化问题，可以使用动态规划进行严格求解。该问题是有效的，科学上基于计算基因发现的原理，并且在数学上是适定的。\n\n我们将此问题建模为在有向无环图（DAG）中寻找最小成本路径。图的节点是输入中提供的候选信号，按其基因组位置排序。当且仅当从一个候选信号到另一个的转换被基因结构规则（例如，P $\\rightarrow$ S，D $\\rightarrow$ A）所允许，并且目标信号的位置大于源信号的位置时，一条带权重的有向边存在。边的权重是目标信号的成本加上任何适用的片段长度惩罚。目标是找到一条从启动子（P）到终止密码子（T）的路径，其总成本最小。\n\n我们将采用动态规划来解决这个最短路径问题。设所有候选信号按其基因组位置排序。我们为每个候选信号 $k$ 计算 $C(k)$（到达该信号的最小成本）和 $\\Pi(k)$（到达该信号的最优路径）。\n\n递推关系根据候选信号 $k$ 的类型定义：\n\n1.  **对于一个启动子信号 (P)**：作为路径的起点，其成本就是它自身的信号成本 $c_k$。路径是 `[p_k]`。\n\n2.  **对于一个起始密码子信号 (S)**：它必须由一个位置更早的启动子信号 $j$ 引导。我们遍历所有符合条件的启动子前驱（$p_j  p_k$ 且满足距离约束），计算每个的总成本（前驱成本 $C(j)$ + 当前信号成本 $c_k$），并选择使总成本最小的那个前驱。\n\n3.  **对于一个供体信号 (D)**：它必须由一个位置更早的起始密码子 (S) 或受体 (A) 信号 $j$ 引导。我们遍历所有符合条件的 S 或 A 前驱，计算每个的总成本（前驱成本 $C(j)$ + 当前信号成本 $c_k$ + 外显子长度惩罚），并选择成本最小的那个。\n\n4.  **对于一个受体信号 (A)**：它必须由一个位置更早的供体 (D) 信号 $j$ 引导。我们遍历所有符合条件的 D 前驱，计算每个的总成本（前驱成本 $C(j)$ + 当前信号成本 $c_k$ + 内含子长度惩罚），并选择成本最小的那个。\n\n5.  **对于一个终止密码子信号 (T)**：它必须由一个位置更早的起始密码子 (S) 或受体 (A) 信号 $j$ 引导。计算方式与供体信号类似，也包含外显子长度惩罚。\n\n在为所有候选信号计算完最小成本和路径后，我们检查所有终止密码子信号，并选择总成本最低的那一个。该信号对应的路径就是最优的基因结构。如果出现成本平局，则选择字典序最小的位置列表。这种方法确保了对所有有效基因结构进行详尽搜索，并保证找到最优解。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the gene prediction problem for the given test cases using dynamic programming.\n    \"\"\"\n    # Global constants\n    MU_E, SIGMA_E = 150.0, 30.0\n    MU_I, SIGMA_I = 200.0, 40.0\n    D_MIN, D_MAX = 20, 1000\n    EPSILON = 1e-9\n\n    def f_exon(L):\n        \"\"\"Calculates exon length penalty.\"\"\"\n        return (L - MU_E)**2 / (2 * SIGMA_E**2)\n\n    def f_intron(L):\n        \"\"\"Calculates intron length penalty.\"\"\"\n        return (L - MU_I)**2 / (2 * SIGMA_I**2)\n\n    test_cases_data = [\n        # Case 1\n        [\n            ('P', 100, 0.5), ('P', 300, 0.2),\n            ('S', 350, 0.2), ('S', 600, 0.4),\n            ('D', 500, 0.25), ('D', 650, 0.45),\n            ('A', 720, 0.25), ('A', 800, 0.5),\n            ('T', 900, 0.2)\n        ],\n        # Case 2\n        [\n            ('P', 30, 0.15),\n            ('S', 100, 0.25),\n            ('D', 200, 0.3),\n            ('A', 150, 0.2),\n            ('T', 480, 0.25)\n        ],\n        # Case 3\n        [\n            ('P', 101, 0.1), ('P', 100, 0.22), ('P', 80, 0.4),\n            ('S', 120, 0.2),\n            ('D', 270, 0.28), ('D', 300, 0.3),\n            ('A', 440, 0.31), ('A', 470, 0.35),\n            ('T', 700, 0.25)\n        ]\n    ]\n\n    results = []\n    \n    for case_data in test_cases_data:\n        # Sort candidates by position, with type as secondary for stability\n        candidates = sorted(case_data, key=lambda x: (x[1], x[0]))\n        num_candidates = len(candidates)\n        \n        # dp[i] stores a tuple (minimum_cost, path_list) to reach candidate i\n        dp = [(float('inf'), []) for _ in range(num_candidates)]\n\n        for i in range(num_candidates):\n            cand_i_type, cand_i_pos, cand_i_cost = candidates[i]\n\n            # Base case: Promoter\n            if cand_i_type == 'P':\n                dp[i] = (cand_i_cost, [cand_i_pos])\n                continue\n\n            # Iterate through all preceding candidates to find valid predecessors\n            for j in range(i):\n                cand_j_type, cand_j_pos, _ = candidates[j]\n                \n                # If predecessor path is invalid, skip\n                if dp[j][0] == float('inf'):\n                    continue\n\n                new_cost = -1\n                pred_cost, pred_path = dp[j]\n\n                if cand_i_type == 'S' and cand_j_type == 'P':\n                    dist = cand_i_pos - cand_j_pos\n                    if D_MIN = dist = D_MAX:\n                        new_cost = pred_cost + cand_i_cost\n                \n                elif cand_i_type == 'D' and cand_j_type in ['S', 'A']:\n                    length = cand_i_pos - cand_j_pos - 1\n                    penalty = f_exon(length)\n                    new_cost = pred_cost + cand_i_cost + penalty\n                \n                elif cand_i_type == 'A' and cand_j_type == 'D':\n                    length = cand_i_pos - cand_j_pos - 1\n                    penalty = f_intron(length)\n                    new_cost = pred_cost + cand_i_cost + penalty\n\n                elif cand_i_type == 'T' and cand_j_type in ['S', 'A']:\n                    length = cand_i_pos - cand_j_pos - 1\n                    penalty = f_exon(length)\n                    new_cost = pred_cost + cand_i_cost + penalty\n                \n                if new_cost != -1:\n                    new_path = pred_path + [cand_i_pos]\n                    \n                    # Update DP table with tie-breaking\n                    current_cost, current_path = dp[i]\n                    if new_cost  current_cost - EPSILON:\n                        dp[i] = (new_cost, new_path)\n                    elif abs(new_cost - current_cost) = EPSILON:\n                        if not current_path or new_path  current_path:\n                            dp[i] = (new_cost, new_path)\n\n        # Find the best path among all stop codons\n        best_overall_cost = float('inf')\n        best_overall_path = []\n\n        for i in range(num_candidates):\n            if candidates[i][0] == 'T':\n                cost, path = dp[i]\n                if path: # Ensure a valid path was found\n                    if cost  best_overall_cost - EPSILON:\n                        best_overall_cost = cost\n                        best_overall_path = path\n                    elif abs(cost - best_overall_cost) = EPSILON:\n                        if not best_overall_path or path  best_overall_path:\n                             best_overall_path = path\n        \n        results.append(best_overall_path)\n\n    # Format final output as a single line string\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{','.join(map(str, res))}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2429125"}]}