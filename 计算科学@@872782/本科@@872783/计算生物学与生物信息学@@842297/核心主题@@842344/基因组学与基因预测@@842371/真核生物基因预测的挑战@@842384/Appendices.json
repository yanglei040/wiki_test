{"hands_on_practices": [{"introduction": "蛋白质编码区的一个关键信号是其特有的密码子使用模式，这与非编码DNA中的三联体频率有显著不同。本练习将让您使用对数似然比来量化这一差异，这是生物信息学中用于信号检测的基本工具。通过这个练习[@problem_id:2377823]，您将亲身体验如何从统计上区分真实的编码序列和随机背景噪声。", "problem": "在真核生物基因组中，内含子、可变剪接和非均一的核苷酸组成的存在，使得识别基因的正确编码链和读码框变得复杂。考虑一个简化情景：一个来自未知基因的短而连续的外显子嵌入在一个缺乏注释特征的基因组区域内。给定一个长度为 $18$ 个核苷酸的脱氧核糖核酸（DNA）片段：\nATGGCTGAACGTTTACGT\n设三个正向读码框分别表示为 $+0$、$+1$ 和 $+2$，对应于分别从位置 $1$、$2$ 和 $3$ 开始的非重叠三联体分组。仅关注读码框 $+0$，并考虑该读码框中的前 $6$ 个密码子（忽略其他位置的任何终止密码子）。在此读码框中，密码子为：\nATG, GCT, GAA, CGT, TTA, CGT。\n假设存在以下生成模型。在一个真实的编码框中，密码子从一个关于有义密码子的物种特异性密码子使用频率分布 $p(c)$ 中独立抽取。在非编码背景中，三联体从背景密码子分布 $q(c)$ 中独立生成。在本练习中，假设背景分布是所有 $64$ 种可能三联体的均匀分布，即对于每个三联体 $c$，$q(c)=\\frac{1}{64}$。上述密码子的物种特异性密码子使用概率为：\n- $p(\\mathrm{ATG})=0.022$,\n- $p(\\mathrm{GCT})=0.018$,\n- $p(\\mathrm{GAA})=0.031$,\n- $p(\\mathrm{CGT})=0.004$,\n- $p(\\mathrm{TTA})=0.007$.\n从独立抽取的概率定义和似然函数出发，定义一个读码框 $f$（其密码子序列为 $c_{1},\\dots,c_{n}$）的对数似然比（LLR）得分，该得分用于对比编码模型与背景模型。然后，使用上面列出的 $6$ 个密码子以及给定的 $p(c)$ 和 $q(c)$，计算读码框 $+0$ 的这个得分。使用自然对数 $\\ln$。将您的最终数值答案保留到四位有效数字。", "solution": "问题陈述已经过严格评估，并被确定为有效。它在科学上基于计算基因预测的原理，特别是使用统计模型来区分编码DNA与非编码DNA。该问题提法明确，为求得唯一解提供了所有必要的数据和定义。其语言客观、正式。因此，我们将着手推导解答。\n\n任务是计算给定候选外显子的对数似然比（LLR）得分。该得分对比了在“编码”模型下观察到该序列的概率与在“背景”非编码模型下观察到该序列的概率。\n\n设给定读码框中的 $n$ 个密码子序列表示为 $C = (c_1, c_2, \\dots, c_n)$。我们构建两个互斥的假设：\n$H_{1}$：该序列由编码区生成。\n$H_{0}$：该序列由背景区生成。\n\n在编码模型 $H_{1}$ 下，假设密码子是从物种特异性密码子使用频率分布 $p(c)$ 中独立抽取的。在此模型下观察到序列 $C$ 的似然函数是每个密码子概率的乘积：\n$$L(C|H_{1}) = P(C|H_{1}) = \\prod_{i=1}^{n} p(c_i)$$\n\n在背景模型 $H_{0}$ 下，假设三联体是从背景分布 $q(c)$ 中独立生成的。在此模型下观察到序列 $C$ 的似然函数为：\n$$L(C|H_{0}) = P(C|H_{0}) = \\prod_{i=1}^{n} q(c_i)$$\n\n似然比（LR）定义为这两个似然函数的比值：\n$$LR = \\frac{L(C|H_{1})}{L(C|H_{0})} = \\frac{\\prod_{i=1}^{n} p(c_i)}{\\prod_{i=1}^{n} q(c_i)} = \\prod_{i=1}^{n} \\frac{p(c_i)}{q(c_i)}$$\n\n对数似然比（LLR）是LR的自然对数。取对数将乘积转换为和，这在计算上更稳定、更方便。这就是密码子序列为 $c_1, \\dots, c_n$ 的读码框的LLR得分的通用定义：\n$$LLR(C) = \\ln(LR) = \\ln\\left(\\prod_{i=1}^{n} \\frac{p(c_i)}{q(c_i)}\\right) = \\sum_{i=1}^{n} \\ln\\left(\\frac{p(c_i)}{q(c_i)}\\right)$$\n\n现在，我们必须使用所提供的具体数据来计算这个得分。DNA片段为 $\\mathrm{ATGGCTGAACGTTTACGT}$。对于读码框 $+0$，给定的 $n=6$ 个密码子的序列为：\n$c_1 = \\mathrm{ATG}$, $c_2 = \\mathrm{GCT}$, $c_3 = \\mathrm{GAA}$, $c_4 = \\mathrm{CGT}$, $c_5 = \\mathrm{TTA}$, $c_6 = \\mathrm{CGT}$。\n\n在编码模型下，概率 $p(c)$ 如下：\n- $p(\\mathrm{ATG}) = 0.022$\n- $p(\\mathrm{GCT}) = 0.018$\n- $p(\\mathrm{GAA}) = 0.031$\n- $p(\\mathrm{CGT}) = 0.004$\n- $p(\\mathrm{TTA}) = 0.007$\n\n背景模型是所有 $4^3 = 64$ 个可能密码子上的均匀分布，因此对于任何密码子 $c$：\n$$q(c) = \\frac{1}{64}$$\n\n我们现在可以计算这 $6$ 个密码子序列的LLR。注意密码子 $\\mathrm{CGT}$ 出现了两次。\n$$LLR = \\sum_{i=1}^{6} \\ln\\left(\\frac{p(c_i)}{q(c_i)}\\right)$$\n$$LLR = \\ln\\left(\\frac{p(\\mathrm{ATG})}{q(\\mathrm{ATG})}\\right) + \\ln\\left(\\frac{p(\\mathrm{GCT})}{q(\\mathrm{GCT})}\\right) + \\ln\\left(\\frac{p(\\mathrm{GAA})}{q(\\mathrm{GAA})}\\right) + \\ln\\left(\\frac{p(\\mathrm{CGT})}{q(\\mathrm{CGT})}\\right) + \\ln\\left(\\frac{p(\\mathrm{TTA})}{q(\\mathrm{TTA})}\\right) + \\ln\\left(\\frac{p(\\mathrm{CGT})}{q(\\mathrm{CGT})}\\right)$$\n代入 $p(c)$ 和 $q(c) = 1/64$ 的值：\n$$LLR = \\ln\\left(\\frac{0.022}{1/64}\\right) + \\ln\\left(\\frac{0.018}{1/64}\\right) + \\ln\\left(\\frac{0.031}{1/64}\\right) + 2 \\cdot \\ln\\left(\\frac{0.004}{1/64}\\right) + \\ln\\left(\\frac{0.007}{1/64}\\right)$$\n$$LLR = \\ln(64 \\cdot 0.022) + \\ln(64 \\cdot 0.018) + \\ln(64 \\cdot 0.031) + 2 \\cdot \\ln(64 \\cdot 0.004) + \\ln(64 \\cdot 0.007)$$\n$$LLR = \\ln(1.408) + \\ln(1.152) + \\ln(1.984) + 2 \\cdot \\ln(0.256) + \\ln(0.448)$$\n我们现在计算自然对数的数值：\n$$LLR \\approx 0.34215 + 0.14154 + 0.68512 + 2 \\cdot (-1.36257) + (-0.80296)$$\n$$LLR \\approx 0.34215 + 0.14154 + 0.68512 - 2.72514 - 0.80296$$\n将这些值相加得到：\n$$LLR \\approx 1.16881 - 3.52810$$\n$$LLR \\approx -2.35929$$\n问题要求将最终答案保留到四位有效数字。前四位有效数字是 $2$、$3$、$5$ 和 $9$。第五位有效数字是 $2$，小于 $5$，因此我们向下舍入（即截断）。\n$$LLR \\approx -2.359$$\n负的LLR得分表明，根据此模型和所提供的数据，该密码子序列更有可能是由背景模型而非编码模型生成的。", "answer": "$$\\boxed{-2.359}$$", "id": "2377823"}, {"introduction": "外显子不仅包含编码信息，还含有指导剪接机制的调控基序，如外显子剪接增强子 (Exonic Splicing Enhancers, ESEs) 和外显子剪接沉默子 (Exonic Splicing Silencers, ESSs)。这项练习[@problem_id:2377813]将向您展示如何根据这些关键剪接信号的密度建立一个统计模型，来为一个潜在的外显子打分。这个练习有助于理解基因预测程序如何整合多种证据来提高其准确性。", "problem": "在真核生物基因预测中，由于影响剪接的短调控基序呈现上下文依赖的分布，区分真实的蛋白质编码外显子和非编码的伪序列变得复杂。考虑一种外显子评分方法，该方法使用候选外显子内观测到的外显子剪接增强子 (ESE) 基序和外显子剪接沉默子 (ESS) 基序的密度。\n\n假设存在以下生成模型。对于一个长度为 $L$ 个核苷酸的片段，预测的 ESE 和 ESS 基序匹配数是独立的泊松随机变量，其均值等于每核苷酸率乘以 $L$。在片段是真实外显子的假设 $H_{\\mathrm{exon}}$下，每核苷酸率分别为 $\\lambda_{\\mathrm{ESE}}^{\\mathrm{ex}}$ 和 $\\lambda_{\\mathrm{ESS}}^{\\mathrm{ex}}$。在片段是非外显子的备择假设 $H_{\\mathrm{non}}$下，每核苷酸率分别为 $\\lambda_{\\mathrm{ESE}}^{\\mathrm{non}}$ 和 $\\lambda_{\\mathrm{ESS}}^{\\mathrm{non}}$。将外显子得分 $S$ 定义为自然对数似然比：\n$$\nS \\equiv \\ln\\!\\big(P(\\text{data}\\mid H_{\\mathrm{exon}})\\big) - \\ln\\!\\big(P(\\text{data}\\mid H_{\\mathrm{non}})\\big).\n$$\n\n一个长度为 $L = 180$ 的候选片段被观测到有 $n_{\\mathrm{ESE}} = 7$ 个预测的 ESE 基序匹配和 $n_{\\mathrm{ESS}} = 1$ 个预测的 ESS 基序匹配。使用以下经验估计的率（每核苷酸）：\n- 在 $H_{\\mathrm{exon}}$ 下：$\\lambda_{\\mathrm{ESE}}^{\\mathrm{ex}} = 0.04$, $\\lambda_{\\mathrm{ESS}}^{\\mathrm{ex}} = 0.006$。\n- 在 $H_{\\mathrm{non}}$ 下：$\\lambda_{\\mathrm{ESE}}^{\\mathrm{non}} = 0.015$, $\\lambda_{\\mathrm{ESS}}^{\\mathrm{non}} = 0.03$。\n\n使用自然对数计算得分 $S$，并将最终结果表示为单个实数。将您的答案四舍五入到四位有效数字。", "solution": "所述问题经过严格验证，被证实是有效的。它在科学上是连贯的，在数学上是适定的，并且没有主观或模糊的元素。因此，将推导出解决方案。\n\n问题的核心在于统计假设检验。数据包括观测到的外显子剪接增强子 (ESE) 和外显子剪接沉默子 (ESS) 基序的计数，我们分别记为 $n_{\\mathrm{ESE}}$ 和 $n_{\\mathrm{ESS}}$。模型指定这些计数是从独立的泊松分布中抽取的。一个均值为 $\\mu$ 的泊松随机变量取值为 $k$ 的概率质量函数 (PMF) 由下式给出：\n$$\nP(k; \\mu) = \\frac{\\mu^k \\exp(-\\mu)}{k!}\n$$\n\n数据是计数 $\\{n_{\\mathrm{ESE}}, n_{\\mathrm{ESS}}\\}$。两个假设是 $H_{\\mathrm{exon}}$ (该片段是外显子) 和 $H_{\\mathrm{non}}$ (它不是)。由于 ESE 和 ESS 计数被指定为独立的，因此在给定假设 $H$ 下数据的似然是各个概率的乘积：\n$$\nP(\\text{data}\\mid H) = P(n_{\\mathrm{ESE}} \\mid H) \\times P(n_{\\mathrm{ESS}} \\mid H)\n$$\n\n得分 $S$ 定义为自然对数似然比：\n$$\nS = \\ln\\big(P(\\text{data}\\mid H_{\\mathrm{exon}})\\big) - \\ln\\big(P(\\text{data}\\mid H_{\\mathrm{non}})\\big)\n$$\n利用对数的性质，这可以写成：\n$$\nS = \\left[ \\ln\\big(P(n_{\\mathrm{ESE}}\\mid H_{\\mathrm{exon}})\\big) + \\ln\\big(P(n_{\\mathrm{ESS}}\\mid H_{\\mathrm{exon}})\\big) \\right] - \\left[ \\ln\\big(P(n_{\\mathrm{ESE}}\\mid H_{\\mathrm{non}})\\big) + \\ln\\big(P(n_{\\mathrm{ESS}}\\mid H_{\\mathrm{non}})\\big) \\right]\n$$\n泊松 PMF 的自然对数是：\n$$\n\\ln\\big(P(k; \\mu)\\big) = k \\ln(\\mu) - \\mu - \\ln(k!)\n$$\n将此代入 $S$ 的表达式可以得到显著的简化。让我们考虑 ESE 基序的得分分量 $S_{\\mathrm{ESE}}$：\n$$\nS_{\\mathrm{ESE}} = \\ln\\big(P(n_{\\mathrm{ESE}}\\mid H_{\\mathrm{exon}})\\big) - \\ln\\big(P(n_{\\mathrm{ESE}}\\mid H_{\\mathrm{non}})\\big)\n$$\n设 $\\mu_{\\mathrm{ESE}}^{\\mathrm{ex}}$ 和 $\\mu_{\\mathrm{ESE}}^{\\mathrm{non}}$ 分别为在 $H_{\\mathrm{exon}}$ 和 $H_{\\mathrm{non}}$ 假设下 ESE 的平均计数。\n$$\nS_{\\mathrm{ESE}} = \\left[ n_{\\mathrm{ESE}} \\ln(\\mu_{\\mathrm{ESE}}^{\\mathrm{ex}}) - \\mu_{\\mathrm{ESE}}^{\\mathrm{ex}} - \\ln(n_{\\mathrm{ESE}}!) \\right] - \\left[ n_{\\mathrm{ESE}} \\ln(\\mu_{\\mathrm{ESE}}^{\\mathrm{non}}) - \\mu_{\\mathrm{ESE}}^{\\mathrm{non}} - \\ln(n_{\\mathrm{ESE}}!) \\right]\n$$\n项 $\\ln(n_{\\mathrm{ESE}}!)$ 被消掉了，这是对此分布族的对数似然比检验的一个基本性质。剩下：\n$$\nS_{\\mathrm{ESE}} = n_{\\mathrm{ESE}} \\ln\\left(\\frac{\\mu_{\\mathrm{ESE}}^{\\mathrm{ex}}}{\\mu_{\\mathrm{ESE}}^{\\mathrm{non}}}\\right) - (\\mu_{\\mathrm{ESE}}^{\\mathrm{ex}} - \\mu_{\\mathrm{ESE}}^{\\mathrm{non}})\n$$\n对于 ESS 分量 $S_{\\mathrm{ESS}}$，也存在一个相同的表达式。总得分是 $S = S_{\\mathrm{ESE}} + S_{\\mathrm{ESS}}$。\n\n我们得到以下数据：\n- 片段长度: $L = 180$ 个核苷酸。\n- 观测到的 ESE 匹配数: $n_{\\mathrm{ESE}} = 7$。\n- 观测到的 ESS 匹配数: $n_{\\mathrm{ESS}} = 1$。\n- 每核苷酸率:\n  - $\\lambda_{\\mathrm{ESE}}^{\\mathrm{ex}} = 0.04$, $\\lambda_{\\mathrm{ESS}}^{\\mathrm{ex}} = 0.006$\n  - $\\lambda_{\\mathrm{ESE}}^{\\mathrm{non}} = 0.015$, $\\lambda_{\\mathrm{ESS}}^{\\mathrm{non}} = 0.03$\n\n首先，我们计算每个假设下的平均计数（$\\mu = \\lambda \\times L$）：\n对于 $H_{\\mathrm{exon}}$:\n- $\\mu_{\\mathrm{ESE}}^{\\mathrm{ex}} = \\lambda_{\\mathrm{ESE}}^{\\mathrm{ex}} \\times L = 0.04 \\times 180 = 7.2$\n- $\\mu_{\\mathrm{ESS}}^{\\mathrm{ex}} = \\lambda_{\\mathrm{ESS}}^{\\mathrm{ex}} \\times L = 0.006 \\times 180 = 1.08$\n对于 $H_{\\mathrm{non}}$:\n- $\\mu_{\\mathrm{ESE}}^{\\mathrm{non}} = \\lambda_{\\mathrm{ESE}}^{\\mathrm{non}} \\times L = 0.015 \\times 180 = 2.7$\n- $\\mu_{\\mathrm{ESS}}^{\\mathrm{non}} = \\lambda_{\\mathrm{ESS}}^{\\mathrm{non}} \\times L = 0.03 \\times 180 = 5.4$\n\n现在，我们计算得分的两个分量。\n对于 ESEs：\n$$\nS_{\\mathrm{ESE}} = 7 \\ln\\left(\\frac{7.2}{2.7}\\right) - (7.2 - 2.7) = 7 \\ln\\left(\\frac{8}{3}\\right) - 4.5\n$$\n对于 ESSs：\n$$\nS_{\\mathrm{ESS}} = 1 \\ln\\left(\\frac{1.08}{5.4}\\right) - (1.08 - 5.4) = \\ln\\left(\\frac{1}{5}\\right) - (-4.32) = -\\ln(5) + 4.32\n$$\n总得分 $S$ 是其和：\n$$\nS = S_{\\mathrm{ESE}} + S_{\\mathrm{ESS}} = \\left( 7 \\ln\\left(\\frac{8}{3}\\right) - 4.5 \\right) + \\left( -\\ln(5) + 4.32 \\right)\n$$\n$$\nS = 7 \\ln\\left(\\frac{8}{3}\\right) - \\ln(5) - 0.18\n$$\n我们进行数值计算：\n$$\nS \\approx 7 \\times (0.980829) - 1.609438 - 0.18\n$$\n$$\nS \\approx 6.865803 - 1.609438 - 0.18\n$$\n$$\nS \\approx 5.256365 - 0.18\n$$\n$$\nS \\approx 5.076365\n$$\n题目要求结果四舍五入到四位有效数字。正的得分表明，观测数据在片段是真实外显子 ($H_{\\mathrm{exon}}$) 的假设下，比在它是非编码片段 ($H_{\\mathrm{non}}$) 的假设下更可能出现。", "answer": "$$\n\\boxed{5.076}\n$$", "id": "2377813"}, {"introduction": "基因表达有时会涉及复杂的调控事件，例如程序性核糖体移码，它由特定的RNA二级结构控制。这项高级练习[@problem_id:2377799]要求您将一个移码信号的生物学模型转化为一个具体的算法。您需要结合模式匹配和结构搜索来评估潜在的移码位点，从而深入了解如何为非标准但至关重要的基因特征设计计算工具。", "problem": "给定一个核糖核酸（RNA）字母表上的有限字符串，该字母表为集合 $\\Sigma=\\{\\mathtt{A},\\mathtt{C},\\mathtt{G},\\mathtt{U}\\}$。对于一个长度为 $n$ 的字符串 $S \\in \\Sigma^{n}$，我们定义一个移码得分，该得分基于两个组成部分：与一个理想滑移序列的局部匹配，以及一个下游的假结样碱基配对潜能。理想滑移序列是长度为7的基序 $M=\\mathtt{UUUAAAC}$。允许的碱基对集合是 $P=\\{(\\mathtt{A},\\mathtt{U}),(\\mathtt{U},\\mathtt{A}),(\\mathtt{G},\\mathtt{C}),(\\mathtt{C},\\mathtt{G}),(\\mathtt{G},\\mathtt{U}),(\\mathtt{U},\\mathtt{G})\\}$。\n\n对于每个索引 $i \\in \\{0,1,\\dots,n-7\\}$，将位置 $i$ 的滑移得分定义为\n$$\nS_{\\mathrm{slip}}(i) \\;=\\; 7 - d\\big(S[i:i+7], M\\big),\n$$\n其中 $d(\\cdot,\\cdot)$ 是汉明距离（两个等长字符串之间不匹配位置的数量），$S[i:i+7]$ 表示从索引 $i$ 开始的长度为7的子字符串。\n\n对于相同的索引 $i$，定义 $j_0 = i+7$ 和一个下游假结样得分 $S_{\\mathrm{pk}}(i)$，其计算方式为：在 $j_0$ 之后一个大小为 $W$ 核苷酸的固定搜索窗口内，寻找两个长度为 $\\ell_1$ 和 $\\ell_2$ 的完美茎，并满足以下约束：\n- 选择整数 $\\ell_1 \\in \\{3,4,5\\}$ 和 $\\ell_2 \\in \\{3,4,5\\}$。\n- 选择环的长度 $a \\in \\{1,2,\\dots,8\\}$ 和 $b \\in \\{1,2,\\dots,8\\}$。\n- 设第一个茎的左侧片段为 $S[j_0 : j_0+\\ell_1)$，其右侧片段起始于 $r_1$，其中\n$$\nr_1 \\;=\\; j_0 + \\ell_1 + a + \\ell_2 + b.\n$$\n- 设第二个茎的左侧片段为 $S[j_0+\\ell_1+a : j_0+\\ell_1+a+\\ell_2)$，其右侧片段起始于 $r_2$，其中\n$$\nr_2 \\;=\\; r_1 + \\ell_1.\n$$\n- 所有使用的索引必须严格位于搜索窗口内，即 $r_2 + \\ell_2 \\le \\min\\{n,\\, j_0 + W\\}$。\n\n一个长度为 $\\ell$ 的茎，其左侧片段从 $L$ 开始，右侧片段从 $R$ 开始，是完美的当且仅当对于每个 $t \\in \\{0,1,\\dots,\\ell-1\\}$，碱基对 $\\big(S[L+t],\\, S[R+(\\ell-1-t)]\\big)$ 都属于 $P$。位置 $i$ 的假结样得分定义为\n$$\nS_{\\mathrm{pk}}(i) \\;=\\; \\max \\{\\;\\ell_1 + \\ell_2\\;\\},\n$$\n其中最大值取自所有能产生满足约束条件的两个完美茎的 $\\ell_1,\\ell_2,a,b$ 的选择。如果不存在有效的选择，则 $S_{\\mathrm{pk}}(i)=0$。\n\n位置 $i$ 的总得分为\n$$\nS_{\\mathrm{tot}}(i) \\;=\\; S_{\\mathrm{slip}}(i) \\;+\\; S_{\\mathrm{pk}}(i).\n$$\n序列级别的移码潜能得分是在所有有效 $i$ 上的最大值，\n$$\nS(S) \\;=\\; \\max_{i \\in \\{0,\\dots,n-7\\}} S_{\\mathrm{tot}}(i).\n$$\n如果 $n  7$，则定义 $S(S)=0$。\n\n使用固定的窗口大小 $W=60$。\n\n您的任务是编写一个程序，对下方测试套件中的每个输入RNA字符串计算其 $S(S)$ 的整数值。该程序必须精确实现上述定义，使用指定的参数值，并将所有字符串视为字母表 $\\Sigma$ 上的大写字母。\n\n测试套件（每一项都是一个RNA字符串 $S$）：\n- 测试 1：$S=\\mathtt{GGGUUUAAACGGCAAAUACCGCCUAUAAA}$\n- 测试 2：$S=\\mathtt{CCCUUUAAACAAAAAAAAAAAAAAAAAAAAA}$\n- 测试 3：$S=\\mathtt{ACGACGACGGCGCGAAAUAUCCCGCGCUAUA}$\n- 测试 4：$S=\\mathtt{AUG}$\n\n答案规格：\n- 对于每个测试，输出是单个整数，等于所定义的 $S(S)$。\n- 最终的程序输出必须是单行，包含所有四个结果，按顺序以逗号分隔列表的形式置于方括号内，即形式为 $[\\;x_1,x_2,x_3,x_4\\;]$，其中每个 $x_k$ 都是一个整数。", "solution": "问题陈述是计算生物学中一个有效的练习。它具有科学依据，模拟了一种已知的生物机制——“-1程序性核糖体移码”的简化版本。该模型的组成部分——一个滑移位点和一个下游假结——是基于病毒和细胞移码信号的公认特征。所有参数、变量和约束都具有数学上的精确性并自洽。这确保了该问题是适定的、客观的，并允许一个唯一的可计算解。不存在逻辑谬误、歧义或信息缺失。可以直接进行算法实现。\n\n目标是计算给定RNA序列 $S$ 的序列级别移码潜能 $S(S)$。这是在一个7核苷酸滑移位点的所有有效起始位置 $i$ 上的最大总得分 $S_{\\mathrm{tot}}(i)$。索引 $i$ 处的总得分是滑移得分 $S_{\\mathrm{slip}}(i)$ 和假结样得分 $S_{\\mathrm{pk}}(i)$ 的和。\n\n整体算法如下。首先，我们处理基本情况：如果序列长度 $n$ 小于7，则不可能存在7核苷酸的滑移位点，因此 $S(S)$ 定义为0。对于长度 $n \\ge 7$ 的序列，我们遍历滑移位点的所有可能起始索引 $i$，从 $i=0$ 到 $i=n-7$。在每次迭代中，我们计算总得分 $S_{\\mathrm{tot}}(i)$，并保持在所有 $i$ 上找到的最大得分。\n\n1.  **滑移得分 $S_{\\mathrm{slip}}(i)$ 的计算**：\n    对于每个索引 $i \\in \\{0, \\dots, n-7\\}$，滑移得分衡量子字符串 $S[i:i+7]$ 与理想基序 $M = \\mathtt{UUUAAAC}$ 的相似性。该得分由公式 $S_{\\mathrm{slip}}(i) = 7 - d(S[i:i+7], M)$ 给出，其中 $d(\\cdot, \\cdot)$ 是汉明距离（不匹配位置的数量）。完美匹配得到7分，而每个不匹配会使得分减少1。\n\n2.  **假结样得分 $S_{\\mathrm{pk}}(i)$ 的计算**：\n    该得分量化了从索引 $j_0 = i+7$ 开始的下游序列形成特定假结结构的潜能。得分是可以在一组几何约束条件下形成的两个茎的最大组合长度 $\\ell_1 + \\ell_2$。寻找最优结构需要遍历一个由茎长 $\\ell_1, \\ell_2 \\in \\{3,4,5\\}$ 和环长 $a, b \\in \\{1, \\dots, 8\\}$ 定义的有限参数空间。\n\n    为固定 $i$ 计算 $S_{\\mathrm{pk}}(i)$ 的过程是一个系统性搜索：\n    a. 初始化一个变量 `max_pk_score` 为 $0$。此变量将存储找到的 $\\ell_1+\\ell_2$ 的最大值。\n    b. 使用四个嵌套循环遍历参数 $(\\ell_1, \\ell_2, a, b)$ 的所有 $3 \\times 3 \\times 8 \\times 8 = 576$ 种组合。\n    c. 对于每个参数组合，我们计算两个茎的右侧片段的起始位置 $r_1$ 和 $r_2$：\n    $$r_1 = j_0 + \\ell_1 + a + \\ell_2 + b$$\n    $$r_2 = r_1 + \\ell_1$$\n    d. 我们首先验证几何结构。整个结构必须位于序列 $S$ 的边界内，并且也要在从 $j_0$ 开始的大小为 $W=60$ 核苷酸的搜索窗口内。这通过约束 $r_2 + \\ell_2 \\le \\min(n, j_0 + W)$ 来强制执行。如果违反此约束，则当前参数集无效，我们继续处理下一个组合。\n    e. 如果几何结构有效，我们必须测试两个茎是否都是“完美的”。一个长度为 $\\ell$ 的茎，其左侧片段从 $L$ 开始，右侧片段从 $R$ 开始，是完美的，如果对于所有 $t \\in \\{0, \\dots, \\ell-1\\}$，核苷酸对 $(S[L+t], S[R + (\\ell-1-t)])$ 都是允许的碱基对集合 $P = \\{(\\mathtt{A},\\mathtt{U}),(\\mathtt{U},\\mathtt{A}),(\\mathtt{G},\\mathtt{C}),(\\mathtt{C},\\mathtt{G}),(\\mathtt{G},\\mathtt{U}),(\\mathtt{U},\\mathtt{G})\\}$ 的成员。对两个茎都执行此检查。\n    f. 茎1的左侧片段从 $L_1 = j_0$ 开始，右侧片段从 $R_1=r_1$ 开始，长度为 $\\ell_1$。\n    g. 茎2的左侧片段从 $L_2 = j_0 + \\ell_1 + a$ 开始，右侧片段从 $R_2=r_2$ 开始，长度为 $\\ell_2$。\n    h. 当且仅当两个茎都被发现是完美的，该参数组合才有效。然后我们更新 `max_pk_score = max(max_pk_score, \\ell_1 + \\ell_2)`。\n    i. 在用尽所有参数组合后，`max_pk_score` 的最终值就是得分 $S_{\\mathrm{pk}}(i)$。如果没有找到有效的组合，则 $S_{\\mathrmpk}(i)$ 保持为 $0$。\n\n最后，位置 $i$ 的总得分计算为 $S_{\\mathrm{tot}}(i) = S_{\\mathrm{slip}}(i) + S_{\\mathrm{pk}}(i)$。序列级别得分 $S(S)$ 是这些总得分在所有有效索引 $i$ 上的最大值。实现将对 $P$ 使用集合数据结构，以确保高效的 $O(1)$ 碱基对有效性查找。这个完整的过程将应用于测试套件中的每个输入字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def compute_frameshifting_potential(rna_string: str) - int:\n        \"\"\"\n        Computes the sequence-level frameshifting potential score S(S) for a single RNA string.\n        \"\"\"\n        n = len(rna_string)\n        if n  7:\n            return 0\n\n        # Define constants from the problem statement\n        MOTIF = \"UUUAAAC\"\n        # Using a set for efficient O(1) average time complexity for lookups\n        ALLOWED_PAIRS = {\n            ('A', 'U'), ('U', 'A'),\n            ('G', 'C'), ('C', 'G'),\n            ('G', 'U'), ('U', 'G')\n        }\n        WINDOW_SIZE_W = 60\n        \n        # A helper function to check for a perfect stem\n        def is_perfect_stem(s: str, L: int, R: int, length: int) - bool:\n            \"\"\"\n            Checks if a stem of a given length between two segments is perfect.\n            \"\"\"\n            for t in range(length):\n                base1 = s[L + t]\n                base2 = s[R + length - 1 - t]\n                if (base1, base2) not in ALLOWED_PAIRS:\n                    return False\n            return True\n\n        max_total_score = 0\n        # Iterate over all possible slippery site start positions\n        for i in range(n - 7 + 1):\n            # --- Calculate slippery score S_slip(i) ---\n            sub = rna_string[i:i+7]\n            hamming_dist = sum(c1 != c2 for c1, c2 in zip(sub, MOTIF))\n            s_slip_i = 7 - hamming_dist\n            \n            # --- Calculate pseudoknot score S_pk(i) ---\n            j0 = i + 7\n            max_pk_score = 0\n            window_end = min(n, j0 + WINDOW_SIZE_W)\n\n            # Iterate over all parameter combinations for the pseudoknot\n            for l1 in range(3, 6):\n                for l2 in range(3, 6):\n                    for a in range(1, 9):\n                        for b in range(1, 9):\n                            # Calculate geometry of the pseudoknot\n                            r1 = j0 + l1 + a + l2 + b\n                            r2 = r1 + l1\n\n                            # Check geometric constraint: structure must fit in the window\n                            if r2 + l2  window_end:\n                                continue\n\n                            # Check for perfect stems\n                            # Stem 1 check\n                            if is_perfect_stem(rna_string, j0, r1, l1):\n                                # Stem 2 check\n                                if is_perfect_stem(rna_string, j0 + l1 + a, r2, l2):\n                                    current_pk_score = l1 + l2\n                                    if current_pk_score  max_pk_score:\n                                        max_pk_score = current_pk_score\n            \n            s_pk_i = max_pk_score\n            total_score_i = s_slip_i + s_pk_i\n            \n            if total_score_i  max_total_score:\n                max_total_score = total_score_i\n\n        return max_total_score\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"GGGUUUAAACGGCAAAUACCGCCUAUAAA\",\n        \"CCCUUUAAACAAAAAAAAAAAAAAAAAAAAA\",\n        \"ACGACGACGGCGCGAAAUAUCCCGCGCUAUA\",\n        \"AUG\",\n    ]\n\n    results = []\n    for s_rna in test_cases:\n        result = compute_frameshifting_potential(s_rna)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2377799"}]}