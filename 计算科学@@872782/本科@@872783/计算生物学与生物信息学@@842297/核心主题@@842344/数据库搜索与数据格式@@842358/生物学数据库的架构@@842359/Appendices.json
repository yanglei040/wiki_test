{"hands_on_practices": [{"introduction": "生物数据库是动态的，其中的注释会随着新研究的出现而不断更新。为了确保依赖这些数据的下游分析（如变异效应预测）能够稳定运行，一个系统性的版本控制方案至关重要。本练习 [@problem_id:2373018] 挑战您将软件工程中广泛使用的“语义化版本”（Semantic Versioning）原则，应用于基因注释这一具体且复杂的生物数据场景中，要求您深入思考何种变化对用户构成“不兼容的重大变更”。", "problem": "您正在为一个经过审编的二级生物学数据库设计基因注释记录的版本控制方案，该数据库建立在一个一级档案库之上。一级数据库存储提交的原始序列和经过最少处理的特征注释，而二级数据库则整合、交叉引用和精炼来自不同来源的注释，旨在提供稳定的标识符和一致的模型。审编团队希望采用语义化版本控制（SemVer），其中记录的版本号写作 $M.m.p$，并且 MAJOR、MINOR 和 PATCH 标签必须映射到基因注释中特定类别的更改。考虑到下游用户依赖稳定的基因标识符和编码序列来进行诸如变异效应预测、蛋白质功能分析和跨数据库映射等流程。\n\n以下哪项策略最恰当地将 MAJOR、MINOR 和 PATCH 映射到二级数据库中基因注释记录的更改，并遵循 SemVer 原则，即 MAJOR 对应于向后不兼容的更改，MINOR 对应于向后兼容的新增功能，而 PATCH 对应于向后兼容的修复？\n\nA. MAJOR：当基因标识符更改、基因被拆分或合并、基因边界的移动改变了编码序列、参考基因组或坐标系的重新映射使先前的坐标失效，或基因类型发生改变从而影响可解释性时；MINOR：当添加新的转录本亚型或交叉引用而不改变现有转录本标识符或编码序列时；PATCH：当仅更正元数据，如描述文本、同义词、发表文献链接或证据代码，而不改变任何序列、坐标或标识符时。\n\nB. MAJOR：当功能描述文本或首选基因符号更改时；MINOR：当编码序列或蛋白质序列更改但基因标识符保持不变时；PATCH：当添加或删除新的转录本亚型时。\n\nC. MAJOR：仅当整个存储库的数据库模式或文件格式更改时；MINOR：当任何特征坐标更改，包括非翻译区的微小移动，但编码序列保持相同时；PATCH：当更正元数据以及添加新的交叉引用或本体论注释时。\n\nD. MAJOR：当向外部资源添加新的交叉引用时；MINOR：当基因边界移动或转录本模型被废弃时；PATCH：当更正参考编码序列以修复一个错误的氨基酸时，因为这对蛋白质来说是一个小改动，但保持了标识符的稳定。", "solution": "问题陈述要求为经过审编的二级生物学数据库中的基因注释记录制定一个版本控制策略，并使用语义化版本控制（SemVer）的原则。核心任务是将版本增量——MAJOR、MINOR 和 PATCH——映射到基因注释记录中特定类型的更改。\n\n首先，让我们将语义化版本控制（SemVer）的原则形式化，对于 $M.m.p$ 形式的版本标识符：\n1.  **主版本号 ($M$)**: 因向后不兼容的更改而增加。旧版本的用户不一定能在不修改其依赖代码或分析流程的情况下切换到新版本。“API”已被破坏。\n2.  **次版本号 ($m$)**: 因以向后兼容的方式添加新功能而增加。现有功能保持不变，用户可以安全升级。\n3.  **修订号 ($p$)**: 因进行向后兼容的错误修复而增加。这些是不会添加新功能或破坏现有功能的更正。\n\n问题指出，该系统将应用于二级数据库中的基因注释记录。下游用户依赖于稳定的基因标识符和编码序列（CDS）。因此，基因注释记录的“API”由其稳定标识符、基因组坐标、定义的特征（外显子、CDS）以及从这些特征派生出的序列（例如，转录本和蛋白质序列）构成。一个“向后不兼容”的更改是指会破坏或使依赖于这些核心数据元素的分析失效的更改。\n\n基于这些首要原则，我们可以开始验证问题陈述。\n\n### 问题验证\n\n**步骤1：提取已知信息**\n-   **系统**：基因注释记录的版本控制。\n-   **数据库类型**：经过审编的二级生物学数据库，建立在一级档案库之上。\n-   **数据库功能**：整合、交叉引用、精炼注释；提供稳定标识符和一致模型。\n-   **版本控制方案**：语义化版本控制（SemVer），格式为 $M.m.p$。\n-   **SemVer 定义**：\n    -   MAJOR：向后不兼容的更改。\n    -   MINOR：向后兼容的新增功能。\n    -   PATCH：向后兼容的修复。\n-   **用户依赖项**：稳定的基因标识符和编码序列。\n-   **用户应用**：变异效应预测、蛋白质功能分析、跨数据库映射。\n\n**步骤2：使用提取的已知信息进行验证**\n该问题在科学上和逻辑上都是合理的。\n-   **科学基础**：一级（如 GenBank/ENA）和二级审编数据库（如 RefSeq、Ensembl/GENCODE）之间的区别是生物信息学中的一个基本概念。对注释进行版本控制并为下游用户保持稳定性的挑战是该领域真实而关键的问题。语义化版本控制是软件工程中广为接受的标准，将其应用于数据版本控制是一个合乎逻辑的延伸。\n-   **定义明确**：问题定义清晰。它提供了版本控制框架（SemVer）、数据背景（基因注释）以及构成破坏性更改的标准（下游用户的依赖性）。任务是在给定选项中找到最合适的映射，这是一个可解且明确的问题。\n-   **客观性**：该问题是客观的，基于 SemVer 的正式定义和生物信息学流程的具体要求。\n\n**步骤3：结论与行动**\n问题陈述是有效的。这是一个计算生物学中定义明确的问题，需要严格应用既定原则。我们现在将通过评估每个选项来继续解决问题。\n\n### 逐项分析\n\n**选项A：**\n-   **MAJOR**：`当基因标识符更改、基因被拆分或合并、基因边界的移动改变了编码序列、参考基因组或坐标系的重新映射使先前的坐标失效，或基因类型发生改变从而影响可解释性时`\n    -   基因标识符的更改是最明确的向后不兼容更改，因为它会破坏任何直接查找。\n    -   拆分或合并基因从根本上改变了基因模型，使所有先前关于该基因座的假设失效。\n    -   编码序列（CDS）的更改也是一个关键的破坏性更改。变异效应预测或蛋白质分析的流程依赖于精确的参考 CDS；更改它会使以前的分析无效。\n    -   重新映射到新的基因组或坐标系会使所有先前的坐标过时。\n    -   更改基因类型（例如，从 `protein_coding` 到 `pseudogene`）是一次重大的重新解释，它破坏了任何专注于蛋白质功能分析的假设。\n    -   这种映射正确地识别了对于指定的下游应用而言是向后不兼容的更改。这与 MAJOR 版本增量的目的相符。\n-   **MINOR**：`当添加新的转录本亚型或交叉引用而不改变现有转录本标识符或编码序列时`\n    -   添加新的亚型或新的交叉引用在不使现有稳定数据失效或改变的情况下，用新信息丰富了记录。对已有转录本感兴趣的用户仍然可以找到它并且其内容未变。这是向后兼容地添加功能的定义。这与 MINOR 版本增量相符。\n-   **PATCH**：`当仅更正元数据，如描述文本、同义词、发表文献链接或证据代码，而不改变任何序列、坐标或标识符时`\n    -   更正描述中的拼写错误、更新 URL 或精炼证据代码都是提高记录质量的修复，但不会影响计算流程所依赖的核心结构或序列数据。这些是向后兼容的修复。这与 PATCH 版本增量相符。\n\n**对A的结论**：该选项正确且精确地将 SemVer 的原则映射到基因注释版本控制的上下文中。**正确**。\n\n**选项B：**\n-   **MAJOR**：`当功能描述文本或首选基因符号更改时`\n    -   更改文本描述是一个次要的更正，而不是 MAJOR 级别的破坏性更改。基因符号的更改可能会造成干扰，但通常通过同义词列表来处理；它不像 CDS 更改那样严重，尤其是在维持一个稳定的主 ID 的情况下。这对 MAJOR 更改来说是一个糟糕的映射。\n-   **MINOR**：`当编码序列或蛋白质序列更改但基因标识符保持不变时`\n    -   这是对向后兼容性的灾难性误解。编码序列的更改是一个根本性的、破坏性的更改，会使大多数下游分析失效。将其标记为 MINOR 级的、向后兼容的更改在科学上是危险的，并且违背了版本控制的目的。\n-   **PATCH**：`当添加或删除新的转录本亚型时`\n    -   添加新的亚型是功能增加（MINOR）。*删除*一个亚型是破坏性更改（MAJOR）。将这些操作，特别是删除，仅仅归类为 PATCH 是不正确的。\n\n**对B的结论**：该策略存在根本性缺陷，并错误地描述了关键数据更改的影响。**不正确**。\n\n**选项C：**\n-   **MAJOR**：`仅当整个存储库的数据库模式或文件格式更改时`\n    -   这将单个数据记录的版本控制与整个数据库系统的版本控制混淆了。一个记录可以发生破坏性更改（例如，CDS 更新），而与全局数据库模式无关。该策略过于严格，未能捕捉到记录级别的破坏性更改。\n-   **MINOR**：`当任何特征坐标更改，包括非翻译区的微小移动，但编码序列保持相同时`\n    -   这对于 MINOR 或 PATCH 更改来说是一个合理的定义，但整个策略存在缺陷。\n-   **PATCH**：`当更正元数据以及添加新的交叉引用或本体论注释时`\n    -   这将两种不同类型的更改混为一谈。元数据更正是 PATCH。添加像交叉引用或注释这样的新功能是 MINOR 更改。将它们混在一起是不精确的。\n\n**对C的结论**：该策略错误地应用了版本控制的范围，并混淆了 PATCH 和 MINOR 更改。**不正确**。\n\n**选项D：**\n-   **MAJOR**：`当向外部资源添加新的交叉引用时`\n    -   添加交叉引用是一个非破坏性的功能增加。这应该是 MINOR 更改。将其分配给 MAJOR 是对 SemVer 的完全误解。\n-   **MINOR**：`当基因边界移动或转录本模型被废弃时`\n    -   废弃一个转录本模型是一个向后不兼容的更改，因为任何依赖于它的分析都会失败。这必须是 MAJOR 更改。移动基因边界如果改变了 CDS，也可能是 MAJOR 更改。\n-   **PATCH**：`当更正参考编码序列以修复一个错误的氨基酸时，因为这对蛋白质来说是一个小改动，但保持了标识符的稳定`\n    -   与选项 B 一样，这是一个危险且不正确的分类。对 CDS 的更正如果改变了最终的蛋白质序列，那么无论这个改动看起来多么“小”，它都是一个向后不兼容的更改。这是一个错误修复，但它是一个破坏性的修复，因此需要增加 MAJOR 版本号。\n\n**对D的结论**：该策略表明对 SemVer 原则存在根本性的不理解，错误地对每种更改的严重性进行了分类。**不正确**。\n\n总之，只有选项A为基因注释记录提供了一个逻辑一致、科学合理且在实践上有用的语义化版本控制应用方案，正确地优先考虑了对下游生物信息学研究至关重要的标识符和序列的稳定性。", "answer": "$$\\boxed{A}$$", "id": "2373018"}, {"introduction": "在管理了单个数据条目的版本之后，我们需要将视角提升到整个数据库的层面。一个高质量的数据库不仅在于单个条目的准确性，还在于其整体的一致性、完整性和可靠性。本练习 [@problem_id:2373027] 引导您构建一个综合性的质量评估指标，通过一个假设的“能量函数”$E_{PDB}$，将冗余度、交叉引用冲突、元数据缺失和结构分辨率等多种数据缺陷量化为统一的分数，从而学会如何宏观地评估一个大型生物数据库的健康状况。", "problem": "一级数据库汇总了实验测定的生物大分子结构，而二级数据库则对源自一级档案库的结构进行分类和注释。以蛋白质数据库（PDB; Protein Data Bank）为一级数据库，它与二级分类资源如扩展的蛋白质结构分类数据库（SCOPe; Structural Classification of Proteins—extended）和CATH数据库（CATH; Class, Architecture, Topology, Homologous superfamily）交叉引用。将整个PDB建模为一个包含 $N$ 个条目的单一系统，并定义一个无量纲的“能量函数”$E_{PDB}$，其值越低表示数据质量和一致性越高。该函数是四个惩罚项的加权和，这些惩罚项反映了一级和二级数据库的架构特性：\n- 冗余度惩罚 $R$：设 $U$ 是从PDB条目到UniProt（通用蛋白质资源）登录号的唯一映射数量。定义 $R = \\dfrac{N - U}{N}$。\n- 交叉引用不一致性惩罚 $C$：设 $X$ 是同时具有SCOPe和CATH注释但其顶级类别分配不一致的PDB条目数量。定义 $C = \\dfrac{X}{N}$。\n- 元数据缺失惩罚 $M$：考虑每个条目所需的四个元数据字段：实验方法、生物分类、UniProt交叉引用和提交日期。设 $T$ 是所有条目中缺失字段实例的总数。定义 $M = \\dfrac{T}{4N}$。\n- 结构分辨率惩罚 $S$：对于一个分辨率为 $r_i$（单位为埃）的X射线晶体学条目，定义每个条目的惩罚 $s_i = \\max\\!\\left(0, \\dfrac{r_i - r_0}{r_0}\\right)$，其中阈值为 $r_0$。对于非X射线条目，使用一个恒定的单条目惩罚 $s_O$。定义 $S = \\dfrac{1}{N}\\sum_{i=1}^{N} s_i$。给定了足以计算 $S$ 的汇总计数：在X射线条目中，有 $G$ 个条目的 $r_i \\le r_0$，有 $B$ 个条目的 $r_i > r_0$，且后者的平均分辨率为 $\\bar{r}_B$。非X射线条目有 $N_O$ 个，每个条目的惩罚为 $s_O$。\n\n设总能量函数为\n$$\nE_{PDB} \\;=\\; w_r R \\;+\\; w_c C \\;+\\; w_m M \\;+\\; w_s S,\n$$\n其中权重 $w_r, w_c, w_m, w_s$ 为非负数。\n\n使用以下数据集级别参数计算 $E_{PDB}$：\n- 总条目数 $N = 200000$，唯一UniProt映射数 $U = 150000$。\n- SCOPe和CATH分类不一致的条目数 $X = 5000$。\n- 四个必需字段中缺失的元数据字段实例总数 $T = 60000$。\n- 分辨率阈值 $r_0 = 2.5$；X射线条目计数：$r_i \\le r_0$ 的有 $G = 120000$ 个，$r_i > r_0$ 的有 $B = 40000$ 个；后者的平均分辨率为 $\\bar{r}_B = 3.1$。\n- 非X射线条目数 $N_O = 40000$，恒定惩罚为 $s_O = 0.15$。\n- 权重 $w_r = 0.4$, $w_c = 0.2$, $w_m = 0.2$, $w_s = 0.2$。\n\n将最终能量表示为单个无量纲十进制数。将答案四舍五入到四位有效数字。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于生物信息学和数据库架构的原理，定量上是适定的，具有充分且一致的数据，并且是客观地构建的。不存在违反科学原理、逻辑不一致或含糊不清之处，因而可以得出严谨、唯一的解。该模型虽然是一个简化模型，但却是评估数据库质量的一个合理框架。因此，我们将继续进行计算。\n\n该问题要求计算蛋白质数据库（PDB）的无量纲“能量函数”$E_{PDB}$，该函数定义为四个惩罚项的加权和：\n$$\nE_{PDB} = w_r R + w_c C + w_m M + w_s S\n$$\n给定的权重为 $w_r = 0.4$, $w_c = 0.2$, $w_m = 0.2$ 和 $w_s = 0.2$。它们的和为 $0.4 + 0.2 + 0.2 + 0.2 = 1.0$，这是自洽的。我们必须使用所提供的数据来计算每个惩罚项 $R$、$C$、$M$ 和 $S$。\n\n1.  **冗余度惩罚, $R$**\n    该惩罚定义为 $R = \\dfrac{N - U}{N}$，其中 $N$ 是总条目数，$U$ 是唯一UniProt映射的数量。\n    给定的数据为 $N = 200000$ 和 $U = 150000$。\n    代入这些值：\n    $$\n    R = \\frac{200000 - 150000}{200000} = \\frac{50000}{200000} = \\frac{1}{4} = 0.25\n    $$\n\n2.  **交叉引用不一致性惩罚, $C$**\n    该惩罚定义为 $C = \\dfrac{X}{N}$，其中 $X$ 是SCOPe和CATH分类不一致的条目数。\n    给定的数据为 $X = 5000$ 和 $N = 200000$。\n    代入这些值：\n    $$\n    C = \\frac{5000}{200000} = \\frac{5}{200} = \\frac{1}{40} = 0.025\n    $$\n\n3.  **元数据缺失惩罚, $M$**\n    该惩罚定义为 $M = \\dfrac{T}{4N}$，其中 $T$ 是所有 $N$ 个条目中，4个必需元数据字段的缺失实例总数。\n    给定的数据为 $T = 60000$ 和 $N = 200000$。\n    代入这些值：\n    $$\n    M = \\frac{60000}{4 \\times 200000} = \\frac{60000}{800000} = \\frac{6}{80} = \\frac{3}{40} = 0.075\n    $$\n\n4.  **结构分辨率惩罚, $S$**\n    该惩罚是每个条目惩罚的平均值，$S = \\dfrac{1}{N}\\sum_{i=1}^{N} s_i$。为了进行此计算，将 $N = 200000$ 个条目的总群体分为三组：\n    -   第1组：$G = 120000$ 个X射线条目，其分辨率 $r_i \\le r_0$，其中 $r_0 = 2.5$ 埃。对于这些条目，惩罚为 $s_i = \\max(0, \\frac{r_i - r_0}{r_0}) = 0$，因为 $\\frac{r_i - r_0}{r_0} \\le 0$。来自该组的总惩罚为 $0$。\n    -   第2组：$B = 40000$ 个X射线条目，其分辨率 $r_i > r_0$。惩罚为 $s_i = \\frac{r_i - r_0}{r_0}$。该组的总惩罚为 $\\sum_{j=1}^{B} s_j$。鉴于该组的平均分辨率为 $\\bar{r}_B = 3.1$，我们可以将总和写为：\n        $$\n        \\sum_{j=1}^{B} \\frac{r_j - r_0}{r_0} = \\frac{1}{r_0} \\left( \\left( \\sum_{j=1}^{B} r_j \\right) - B r_0 \\right) = \\frac{1}{r_0} (B \\bar{r}_B - B r_0) = \\frac{B(\\bar{r}_B - r_0)}{r_0}\n        $$\n        代入数值 $B = 40000$, $\\bar{r}_B = 3.1$ 和 $r_0 = 2.5$：\n        $$\n        \\text{第2组的总和} = \\frac{40000(3.1 - 2.5)}{2.5} = \\frac{40000 \\times 0.6}{2.5} = \\frac{24000}{2.5} = 9600\n        $$\n    -   第3组：$N_O = 40000$ 个非X射线条目，每个条目被分配一个恒定的惩罚 $s_O = 0.15$。该组的总惩罚为：\n        $$\n        N_O s_O = 40000 \\times 0.15 = 6000\n        $$\n    所有 $N$ 个条目的总惩罚是这三组贡献的总和：$\\sum_{i=1}^{N} s_i = 0 + 9600 + 6000 = 15600$。\n    因此，平均惩罚 $S$ 为：\n    $$\n    S = \\frac{1}{N} \\sum_{i=1}^{N} s_i = \\frac{15600}{200000} = \\frac{156}{2000} = \\frac{78}{1000} = 0.078\n    $$\n    条目数量加总正确：$G + B + N_O = 120000 + 40000 + 40000 = 200000 = N$。\n\n5.  **$E_{PDB}$ 的最终计算**\n    现在我们将所有计算出的惩罚值和给定的权重代入能量函数表达式：\n    $$\n    E_{PDB} = w_r R + w_c C + w_m M + w_s S\n    $$\n    $$\n    E_{PDB} = (0.4)(0.25) + (0.2)(0.025) + (0.2)(0.075) + (0.2)(0.078)\n    $$\n    $$\n    E_{PDB} = 0.1000 + 0.0050 + 0.0150 + 0.0156\n    $$\n    $$\n    E_{PDB} = 0.1356\n    $$\n题目要求将答案四舍五入到四位有效数字。计算出的值 $0.1356$ 已经恰好是四位有效数字。因此，无需进一步四舍五入。", "answer": "$$\n\\boxed{0.1356}\n$$", "id": "2373027"}, {"introduction": "数据库架构的最终目的是支持高效且有意义的数据查询。本练习 [@problem_id:2373039] 将焦点从数据质量控制转向数据建模与利用。您需要将一个生态系统（食物网）抽象为图模型，并实现一个算法来回答特定的生物学问题，这直接模拟了专业生物数据库的核心功能：如何组织数据以揭示其内在的生物学关系。", "problem": "给定一个生态生物学数据库的概念架构，它包含两个层次：一个主数据库和一个次级数据库。主数据库 (PD) 以有向图中的有向边的形式存储直接的营养相互作用，而次级数据库 (SD) 存储派生的注释，例如与初级生产者的营养距离。初级生产者是指不消耗任何其他生物的生物体。目标是形式化一个对次级数据库的查询：找出所有与任一初级生产者相距恰好三个营养级步骤的生物体，其中“营养级步骤”定义为一个沿着从资源（猎物）到消费者（捕食者）方向的有向捕食链接。\n\n形式上，设食物网表示为一个有向图 $G=(V,E)$，其中 $V$ 是生物体标识符的有限集合，$E \\subseteq V \\times V$ 是一组有序对 $(u,v)$，表示生物体 $u$ 被生物体 $v$ 直接消耗。设 $S \\subseteq V$ 是已识别的初级生产者集合。对于 $s \\in S$ 和 $v \\in V$，将 $d(s,v)$ 定义为从 $s$ 到 $v$ 的最短有向路径的长度（以有向边的数量计），如果该路径存在；否则 $d(s,v)$ 未定义。对于一个生产者集合 $S$，将节点 $v$ 相对于生产者的营养距离定义为\n$$\n\\delta_S(v) = \\min_{s \\in S} d(s,v),\n$$\n只要至少有一个 $d(s,v)$ 有定义。所需的查询结果是集合\n$$\nD_3(S)=\\{\\, v \\in V \\mid \\delta_S(v)=3 \\,\\}.\n$$\n\n您的任务是编写一个完整的程序，对以下每个独立的测试用例，计算并返回 $D_3(S)$ 中排序后的生物体标识符列表。\n\n解释与要求：\n- 每个测试用例提供一个有向边列表 $E$ 和一个初级生产者集合 $S$。\n- 有向边从资源指向消费者。单个捕食者可能有多个资源，并且图中可能存在环。\n- 对于每个测试用例，计算集合 $D_3(S)$，该集合包含所有与生产者集合 $S$ 的最短有向距离等于 $3$ 的节点，并按升序输出节点标识符。\n- 如果 $D_3(S)$ 为空，则为该测试用例输出一个空列表。\n- 所有生物体标识符都是正整数，您必须输出整数，而不是字符串。\n\n测试套件：\n- 测试用例 1：\n  - $E_1 = \\{(1,2),(1,3),(2,4),(3,4),(4,5),(5,6),(2,7)\\}$\n  - $S_1 = \\{1\\}$\n- 测试用例 2：\n  - $E_2 = \\{(1,2),(2,3),(3,4),(8,9),(9,10),(10,11),(2,5),(5,6),(6,4)\\}$\n  - $S_2 = \\{1,8\\}$\n- 测试用例 3：\n  - $E_3 = \\{(1,2),(2,3),(3,2),(3,4),(4,5),(5,3)\\}$\n  - $S_3 = \\{1\\}$\n- 测试用例 4：\n  - $E_4 = \\{(1,2),(2,1)\\}$\n  - $S_4 = \\{1\\}$\n- 测试用例 5：\n  - $E_5 = \\{(1,2)\\}$\n  - $S_5 = \\{10\\}$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有五个测试用例的结果，格式为一个用方括号括起来的逗号分隔列表。此外部列表的每个元素必须是对应测试用例的内部已排序（按升序）的整数列表。例如，包含三个测试用例的输出可能看起来像 $[[1,4],[3],[]]$。", "solution": "我们将生态食物网的主数据库和次级生物学数据库的架构形式化如下。主数据库 (PD) 保存原始的实体-关系数据：生物体作为节点，直接的营养相互作用作为从资源到消费者的有向边。这很自然地被建模为一个有向图 $G=(V,E)$，其中 $E \\subseteq V \\times V$。次级数据库 (SD) 从 PD 派生注释，例如与初级生产者的营养距离。概念上，SD 存储由 $\\delta_S(v)=\\min_{s \\in S} d(s,v)$ 定义的函数 $\\delta_S: V \\to \\mathbb{N}$，其中 $d(s,v)$ 是在图 $G$ 中从 $s$ 到 $v$ 的最短有向路径的长度。查询“与初级生产者相距恰好三个营养级的生物体”被形式化为从 SD 中检索 $D_3(S)=\\{ v \\in V \\mid \\delta_S(v)=3\\}$。\n\n根据图论的基本原理，在有向无权图中，从一个源集合 $S$ 到所有可达节点的最短路径长度（以边数计算）可以通过执行广度优先搜索 (BFS) 获得，该搜索从整个集合 $S$（距离为 0）开始。BFS 按路径长度的非递减顺序逐层探索，并且首次发现一个节点时就确定了其最短路径距离。因此，要计算 $D_3(S)$，只需：\n- 为所有 $s \\in S$ 初始化距离 $\\text{dist}(s)=0$，而其他节点的 $\\text{dist}(v)$ 则为未定义。\n- 使用队列按递增的距离逐层遍历图，从节点 $u$ 传播到所有出邻居 $v$，并在 $\\text{dist}(v)$ 尚未分配时设置 $\\text{dist}(v)=\\text{dist}(u)+1$。\n- 在距离超过 $3$ 时停止探索，因为最短距离大于 $3$ 的节点不可能对 $D_3(S)$ 有贡献。\n- 收集所有 $\\text{dist}(v)=3$ 的节点。\n\n因为 PD 提供的边 $(u,v)$ 是从资源指向消费者的，所以边的连续应用恰好对应于连续的营养级步骤。BFS 通过其性质自然地处理了环和多个生产者的情况：一个节点首次被分配距离时，是通过来自 $S$ 中最近的生产者的最短有向路径；随后的更长替代路径会被忽略。\n\n我们现在通过分析有向可达性和路径长度，来计算所提供测试套件的预期结果。\n\n- 测试用例 1：\n  - $E_1 = \\{(1,2),(1,3),(2,4),(3,4),(4,5),(5,6),(2,7)\\}$, $S_1=\\{1\\}$。\n  - 从 $1$ 出发，距离为 $1$ 的节点是 $\\{2,3\\}$。距离为 $2$ 的是 $\\{4,7\\}$。距离为 $3$ 的只有 $\\{5\\}$（通过 $1 \\to 2 \\to 4 \\to 5$ 或 $1 \\to 3 \\to 4 \\to 5$）。因此，按升序排列，$D_3(S_1)=[5]$。\n\n- 测试用例 2：\n  - $E_2 = \\{(1,2),(2,3),(3,4),(8,9),(9,10),(10,11),(2,5),(5,6),(6,4)\\}$, $S_2=\\{1,8\\}$。\n  - 从 $1$ 出发：距离为 $1$ 的是 $\\{2\\}$，距离为 $2$ 的是 $\\{3,5\\}$，距离为 $3$ 的是 $\\{4,6\\}$。从 $8$ 出发：距离为 $1$ 的是 $\\{9\\}$，距离为 $2$ 的是 $\\{10\\}$，距离为 $3$ 的是 $\\{11\\}$。与任一生产者距离恰好为 $3$ 的节点的并集为 $\\{4,6,11\\}$，所以 $D_3(S_2)=[4,6,11]$。\n\n- 测试用例 3：\n  - $E_3 = \\{(1,2),(2,3),(3,2),(3,4),(4,5),(5,3)\\}$, $S_3=\\{1\\}$。\n  - 在 $\\{2,3,5\\}$ 之间存在一个环，但从 $1$ 出发的最短距离是：$\\text{dist}(2)=1$，$\\text{dist}(3)=2$，$\\text{dist}(4)=3$，$\\text{dist}(5)=4$。因此 $D_3(S_3)=[4]$。\n\n- 测试用例 4：\n  - $E_4 = \\{(1,2),(2,1)\\}$, $S_4=\\{1\\}$。\n  - $\\text{dist}(2)=1$，$\\text{dist}(1)=0$。没有节点的最短距离为 $3$，因为重新访问环不会改变最短距离。因此 $D_3(S_4)=[\\,]$（空列表）。\n\n- 测试用例 5：\n  - $E_5 = \\{(1,2)\\}$, $S_5=\\{10\\}$。\n  - 在给定的图中，节点 $10$ 没有出边。没有节点可以从 $10$ 到达，所以 $D_3(S_5)=[\\,]$。\n\n从算法上讲，对于每个测试用例，为图 $G$ 构建一个邻接表，从 $S$ 中的所有源点同时运行一次 BFS，分配最长为 $3$ 的最短距离，并收集距离恰好为 $3$ 的节点，然后按升序排序。最终输出是聚合了五个内部列表的外部列表，按指定格式打印在单行上。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef nodes_at_exact_distance_three(edges, producers):\n    # Build adjacency list from edges (u -> v)\n    adj = {}\n    nodes = set()\n    for u, v in edges:\n        nodes.add(u)\n        nodes.add(v)\n        if u not in adj:\n            adj[u] = []\n        adj[u].append(v)\n    # Ensure producers appear in adjacency even if they have no outgoing edges\n    for s in producers:\n        if s not in adj:\n            adj[s] = []\n        nodes.add(s)\n\n    # Multi-source BFS up to depth 3\n    from collections import deque\n    dist = {}\n    q = deque()\n\n    # Initialize queue with all producers at distance 0\n    for s in producers:\n        if s not in dist:\n            dist[s] = 0\n            q.append(s)\n\n    # BFS\n    while q:\n        u = q.popleft()\n        du = dist[u]\n        if du == 3:\n            # Do not expand further from nodes already at depth 3\n            continue\n        for v in adj.get(u, []):\n            if v not in dist:\n                dist[v] = du + 1\n                # Only enqueue if we have not exceeded depth 3\n                if dist[v] = 3:\n                    q.append(v)\n\n    # Collect nodes at exact distance 3\n    result = sorted([v for v, d in dist.items() if d == 3])\n    return result\n\ndef format_list_of_lists_no_spaces(lol):\n    # Formats e.g., [[5],[4,6,11],[4],[],[]] without spaces\n    inner = []\n    for lst in lol:\n        inner.append(\"[\" + \",\".join(str(x) for x in lst) + \"]\")\n    return \"[\" + \",\".join(inner) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"edges\": [(1,2),(1,3),(2,4),(3,4),(4,5),(5,6),(2,7)],\n            \"producers\": [1],\n        },\n        # Test case 2\n        {\n            \"edges\": [(1,2),(2,3),(3,4),(8,9),(9,10),(10,11),(2,5),(5,6),(6,4)],\n            \"producers\": [1,8],\n        },\n        # Test case 3\n        {\n            \"edges\": [(1,2),(2,3),(3,2),(3,4),(4,5),(5,3)],\n            \"producers\": [1],\n        },\n        # Test case 4\n        {\n            \"edges\": [(1,2),(2,1)],\n            \"producers\": [1],\n        },\n        # Test case 5\n        {\n            \"edges\": [(1,2)],\n            \"producers\": [10],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        edges = case[\"edges\"]\n        producers = case[\"producers\"]\n        result = nodes_at_exact_distance_three(edges, producers)\n        results.append(result)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_list_of_lists_no_spaces(results))\n\nsolve()\n```", "id": "2373039"}]}