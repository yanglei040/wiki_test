{"hands_on_practices": [{"introduction": "BLAST的惊人速度源于其巧妙的“种子”策略，即快速识别短而完全匹配的序列片段。这个练习将带你深入探讨该策略的统计学基础，通过计算在一个随机数据库中找到特定种子的概率。理解这一点有助于建立对“统计显著性”的直观感受，并明白为何一个短的精确匹配可以作为一个有意义的信号，从而启动更耗时的比对扩展 [@problem_id:2434603]。", "problem": "在基础局部比对搜索工具（BLAST）的种子阶段，一个种子是一个固定长度的连续字。考虑一个长度为 $w$ 的固定种子，其字母表为大小是 $|\\Sigma|$ 的有限字母表 $\\Sigma$。假设一个数据库被建模为一个长度为 $D$ 的单一序列，其中每个位置都是从 $\\Sigma$ 上的均匀分布中独立同分布地抽取的。定义一次命中为种子与数据库中长度为 $w$ 的连续子串的精确匹配。将 $D - w + 1$ 个可能的长度为 $w$ 的子串的起始位置视为独立的试验。在此模型下，数据库中包含至少一次种子命中的概率的闭式表达式是什么？请用 $D$、$w$ 和 $|\\Sigma|$ 来表示你的答案。不要进行近似或四舍五入；请提供精确表达式。", "solution": "在尝试进行任何求解之前，将首先对问题陈述进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n- **领域**：基础局部比对搜索工具（BLAST），种子阶段。\n- **种子**：一个固定长度 $w$ 的连续字。\n- **字母表**：一个大小为 $|\\Sigma|$ 的有限集合 $\\Sigma$。\n- **数据库**：一个长度为 $D$ 的单一序列。\n- **概率模型**：数据库中的每个位置都是从 $\\Sigma$ 上的均匀分布中独立同分布（i.i.d.）地随机抽取的。\n- **命中的定义**：种子与数据库中一个长度为 $w$ 的连续子串的精确匹配。\n- **明确假设**：数据库中 $D - w + 1$ 个可能的长度为 $w$ 的子串的起始位置应被视为独立的试验。\n- **目标**：推导数据库中包含至少一次命中的概率的闭式表达式。表达式必须用 $D$、$w$ 和 $|\\Sigma|$ 来表示。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据有效性标准对问题进行评估。\n\n1.  **科学依据**：该问题描述了一个用于分析序列比对统计的简化但标准的概率模型。BLAST 算法及其基于种子的启发式方法是计算生物学中的基本概念。将序列建模为独立同分布的随机变量是该领域中常用的一阶近似。该问题具有科学依据。\n2.  **适定性**：该问题是适定的。它要求在一个完全指定的模型下计算一个特定的概率。所有必要的参数（$D$、$w$、 $|\\Sigma|$）都以符号形式提供。目标是明确的。明确指示假设试验独立，虽然这是对重叠子串真实世界场景的简化，但它消除了歧义，使问题变得唯一可解。这个假设是要分析的模型的一个特征，而不是问题陈述中的缺陷。\n3.  **客观性**：该问题以精确、客观和数学的语言陈述。它不含主观或基于意见的内容。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。这是一个基于生物信息学中标准简化模型的自洽、一致且适定的问题。开始求解。\n\n目标是找到在一个长度为 $D$ 的数据库序列中，观察到一个长度为 $w$ 的固定种子的至少一次精确匹配的概率。\n\n设 $A$ 为数据库中包含至少一次命中的事件。首先计算其补事件 $A^c$（即数据库中没有命中）的概率，在计算上更为直接。然后，所求概率由关系式 $P(A) = 1 - P(A^c)$ 给出。\n\n数据库序列的长度为 $D$。一个长度为 $w$ 的连续子串可以从位置 $1$ 到 $D - w + 1$ 的任何位置开始。我们假设 $D \\geq w$，否则不存在长度为 $w$ 的子串，命中的概率显然为 $0$。我们将视为试验的、可能的长度为 $w$ 的子串的起始位置总数为 $N = D - w + 1$。\n\n让我们首先确定单次试验中命中的概率。一次试验包括将固定种子与数据库的一个特定长度为 $w$ 的子串进行比较。设种子为 $s_1 s_2 \\dots s_w$，数据库子串为 $d_1 d_2 \\dots d_w$。如果对于所有 $i \\in \\{1, 2, \\dots, w\\}$ 都有 $s_i = d_i$，则发生一次命中。\n\n根据模型，数据库中的每个字符 $d_i$ 都是从大小为 $|\\Sigma|$ 的字母表 $\\Sigma$ 中独立且均匀地抽取的。单个字符 $d_i$ 与固定种子的相应字符 $s_i$ 匹配的概率是 $\\frac{1}{|\\Sigma|}$。\n\n由于数据库子串中的字符是独立抽取的，因此子串的所有 $w$ 个字符都与种子匹配的概率是各个字符匹配概率的乘积。设 $p$ 为单次试验中命中的概率。\n$$p = \\left(\\frac{1}{|\\Sigma|}\\right) \\times \\left(\\frac{1}{|\\Sigma|}\\right) \\times \\dots \\times \\left(\\frac{1}{|\\Sigma|}\\right) \\quad (w \\text{ 次})$$\n$$p = \\left(\\frac{1}{|\\Sigma|}\\right)^{w} = \\frac{1}{|\\Sigma|^w}$$\n\n事件 $A^c$ 是在所有 $N$ 个可能的起始位置上都没有命中的事件。问题明确指出，这 $N$ 次试验应被视为独立的。设 $E_i$ 为在第 $i$ 个起始位置发生命中的事件。我们要求的是 $P(\\bigcap_{i=1}^{N} E_i^c)$。\n由于试验的独立性：\n$$P(A^c) = P(\\text{试验 1 未命中 且 试验 2 未命中 } \\dots \\text{ 且 试验 } N \\text{ 未命中})$$\n$$P(A^c) = \\prod_{i=1}^{N} P(E_i^c)$$\n\n在任何单次试验中没有命中的概率是 $P(E_i^c) = 1 - P(E_i) = 1 - p$。\n$$P(E_i^c) = 1 - \\frac{1}{|\\Sigma|^w}$$\n由于所有起始位置的概率模型都相同，所以对于所有的 $i$，$P(E_i^c)$ 都是相同的。因此，在 $N$ 次试验中没有任何命中的概率是：\n$$P(A^c) = (1 - p)^N = \\left(1 - \\frac{1}{|\\Sigma|^w}\\right)^{N}$$\n代入 $N = D - w + 1$：\n$$P(A^c) = \\left(1 - \\frac{1}{|\\Sigma|^w}\\right)^{D-w+1}$$\n\n最后，至少有一次命中的概率 $P(A)$ 是：\n$$P(A) = 1 - P(A^c) = 1 - \\left(1 - \\frac{1}{|\\Sigma|^w}\\right)^{D-w+1}$$\n这是在指定的模型及其独立性简化假设下，数据库包含至少一次命中的概率的闭式表达式。该表达式对 $D \\ge w$ 有效。如果 $D  w$，那么 $D-w+1 \\le 0$，这意味着有 $0$ 次试验。在 $0$ 次试验中事件发生的概率为 $0$。我们的公式在 $D-w+1=0$ 的情况下正确地给出 $1 - (\\dots)^0 = 1 - 1 = 0$。", "answer": "$$\\boxed{1 - \\left(1 - \\frac{1}{|\\Sigma|^{w}}\\right)^{D-w+1}}$$", "id": "2434603"}, {"introduction": "尽管种子启发式算法非常强大，但它并非万无一失，这正是其速度的代价。这个练习旨在挑战你对BLAST局限性的批判性思考，通过寻找一个特定的序列对，该序列对可以被更严谨的Smith-Waterman算法比对上，但却因为其种子长度的限制而被BLAST错过 [@problem_id:2434642]。这个实践将清晰地揭示生物信息学中速度与灵敏度之间的经典权衡。", "problem": "您正在比较两种局部序列比对方法：Smith–Waterman (SW) 动态规划算法和基本局部比对搜索工具 (BLAST)。考虑核苷酸BLAST (BLASTN)，其配置了以下固定的体系结构和参数用于种子、延伸和评估阶段：种子阶段要求在正链上至少有一个长度为 $k=11$ 的精确词匹配（单次命中种子法；无邻近词）；延伸仅从此类种子开始；如果从未出现种子，则评估阶段无关紧要。低复杂度过滤已禁用。SW算法通过动态规划计算最优局部比对得分，不使用任何种子启发式算法。使用仿射罚分方案：匹配 $+1$，错配 $-1$，空位开放 $-2$，空位延伸 $-1$。\n\n您的任务是识别出这样一个候选对，它由一个查询序列和一个数据库序列组成，Smith–Waterman算法会对这对序列给出正的局部分数，但BLAST会因为其种子启发式算法在两个序列之间找不到共享的精确11-mer（长度为11的子串）而错过它。\n\n假设：\n- 所有比较仅在正链上进行（不考虑反向互补）。\n- BLAST严格使用上述固定的单次命中精确词种子法，词大小为 $k=11$。\n\n只选择一个选项。\n\nA. \n- 查询 $Q_A$: 5'- ACGTACGTACGTACG -3' \n- 数据库 $D_A$: 5'- ACGTACGAACGTACG -3'\n\nB.\n- 查询 $Q_B$: 5'- TTGATTACAGATTCC -3'\n- 数据库 $D_B$: 5'- AAGATTACAGATTGG -3'\n\nC.\n- 查询 $Q_C$: 5'- CGTACGTAGCTAGGTT -3'\n- 数据库 $D_C$: 5'- CGTACGTAGCTAAATT -3'\n\nD.\n- 查询 $Q_D$: 5'- GCAAATTTCCCGGG -3'\n- 数据库 $D_D$: 5'- GCAAATTTCCCAGG -3'\n\n哪个选项满足Smith–Waterman算法会对比对给出正的局部分数，但BLAST会因种子启发式算法而错过它的要求？", "solution": "任务是识别出一对序列，即一个查询序列 $Q$ 和一个数据库序列 $D$，它们同时满足两个不同的条件：\n$1$。由Smith–Waterman (SW) 算法计算出的最优局部比对得分为正。\n$2$。配置了词大小为 $k=11$ 的基本局部比对搜索工具 (BLAST) 因没有长度为 $k=11$ 的精确共享子串作为种子而未能找到比对。\n\n我们给定的仿射罚分方案是：匹配得分 $+1$，错配得分 $-1$，空位开放罚分 $-2$，空位延伸罚分 $-1$。我们将根据这两个条件分析每个提供的选项。\n\n**选项 A：**\n查询 $Q_A$：5'-ACGTACGTACGTACG-3'\n数据库 $D_A$：5'-ACGTACGAACGTACG-3'\n\n**条件2 (BLAST种子)：**\n两个序列的长度都是15个核苷酸。我们比较 $Q_A$ 和 $D_A$ 来寻找最长公共子串。\n$Q_A$: `ACGTACG` `T` `ACGTACG`\n$D_A$: `ACGTACG` `A` `ACGTACG`\n这两个序列仅在位置8处不同。任何包含位置8的子串都不可能是两个序列之间的精确匹配。可能的最长共享子串是不跨越这个错配的子串。错配前的最长共享子串是 `ACGTACG`，其长度为7。错配后的最长共享子串也是 `ACGTACG`，长度也为7。\n因此，对于序列对 $(Q_A, D_A)$，最长公共子串的长度为7。由于要求的种子长度是 $k=11$，且 $7  11$，因此不存在长度为11的精确词匹配。因此，BLAST的种子启发式算法会失败，BLAST会错过这个比对。该选项满足第二个条件。\n\n**条件1 (Smith–Waterman得分)：**\n现在我们必须验证最优局部比对得分是否为正。Smith–Waterman算法寻找得分最高的局部比对。只要证明存在*任何*一个得分为正的局部比对就足够了，因为最优得分必须大于或等于这个值。考虑在整个序列长度上的简单无空位比对：\n5'-ACGTACGTACGTACG-3'\n5'-ACGTACGAACGTACG-3'\n这个比对包含14个匹配对和1个错配。使用给定的评分方案（匹配 $= +1$，错配 $= -1$），这个比对的得分是 $(14 \\times (+1)) + (1 \\times (-1)) = 14 - 1 = 13$。\n既然我们找到了一个得分为13的局部比对，并且 $13 > 0$，那么Smith–Waterman找到的最优局部比对得分必须至少为13，因此为正。该选项满足第一个条件。\n\n**对A的结论：** 该选项满足两个条件。**正确**。\n\n**选项 B：**\n查询 $Q_B$：5'-TTGATTACAGATTCC-3'\n数据库 $D_B$：5'-AAGATTACAGATTGG-3'\n\n**条件2 (BLAST种子)：**\n我们搜索长度为 $k=11$ 的公共子串。\n$Q_B$: `TT` `GATTACAGATT` `CC`\n$D_B$: `AA` `GATTACAGATT` `GG`\n子串 `GATTACAGATT` 存在于两个序列中。其长度为11。这个精确匹配可以作为BLAST的有效种子。因此，BLAST不会错过这个比对。\n\n**对B的结论：** 该选项不满足第二个条件。**错误**。\n\n**选项 C：**\n查询 $Q_C$：5'-CGTACGTAGCTAGGTT-3'\n数据库 $D_C$：5'-CGTACGTAGCTAAATT-3'\n\n**条件2 (BLAST种子)：**\n我们搜索长度为 $k=11$ 的公共子串。\n$Q_C$: `CGTACGTAGCTA` `GGTT`\n$D_C$: `CGTACGTAGCTA` `AATT`\n子串 `CGTACGTAGCTA` 在两个序列中是共有的，长度为12。由于 $12 \\ge k=11$，因此存在至少一个长度为11的共享词（例如，前缀 `CGTACGTAGCT`）。BLAST会找到这个种子并继续进行比对。\n\n**对C的结论：** 该选项不满足第二个条件。**错误**。\n\n**选项 D：**\n查询 $Q_D$：5'-GCAAATTTCCCGGG-3'\n数据库 $D_D$：5'-GCAAATTTCCCAGG-3'\n\n**条件2 (BLAST种子)：**\n我们搜索长度为 $k=11$ 的公共子串。\n$Q_D$: `GCAAATTTCCC` `GGG`\n$D_D$: `GCAAATTTCCC` `AGG`\n子串 `GCAAATTTCCC` 在两个序列中是共有的，长度正好为11。这是一个有效的种子词。BLAST会从这个种子开始比对。\n\n**对D的结论：** 该选项不满足第二个条件。**错误**。\n\n根据分析，只有选项A中的序列对会被Smith–Waterman算法赋予正分，但由于其种子启发式算法的失败而被指定的BLAST配置所错过。", "answer": "$$\\boxed{A}$$", "id": "2434642"}, {"introduction": "BLAST的架构是一个各部分紧密耦合的精密系统，从字母表到打分矩阵，每个组件都扮演着至关重要的角色。本练习将通过一个真实世界中可能出现的用户错误场景，来检验你对系统内部依赖关系的理解 [@problem_id:2434631]。通过预测使用不匹配的打分矩阵会产生何种后果，你将体会到为何整个比对流程的完整性依赖于正确的初始参数设置。", "problem": "一个用户试图在命令行中指定一个自定义矩阵文件，以使用核苷酸评分矩阵（例如 NUC.4.4）来运行蛋白质基础局部比对搜索工具 (BLAST) (blastp)。考虑基础局部比对搜索工具 (BLAST) 的种子-扩展-评估架构。在 BLAST 中，评分系统由一个字母表 $\\mathcal{A}$ 上的替换矩阵 $S(a,b)$ 定义，其中对于蛋白质比对，$\\mathcal{A}_{\\mathrm{aa}}$ 的大小为 $|\\mathcal{A}_{\\mathrm{aa}}| = 20$，对于核苷酸比对，$\\mathcal{A}_{\\mathrm{nt}}$ 的大小为 $|\\mathcal{A}_{\\mathrm{nt}}| = 4$。种子阶段根据来自 $S(a,b)$ 的得分构建长度为 $w$ 的词的邻域，扩展阶段累积得分 $\\sum_i S(x_i, y_i)$ 以增长高分片段对，评估阶段则在 Karlin–Altschul 理论下估计 $E$ 值，这需要为所选的 $S(a,b)$ 和背景频率定义参数 $\\lambda$ 和 $K$，并满足通常的条件（包括负的期望得分）。\n\n预测在 blastp 中尝试使用 NUC.4.4 的操作后果。假设没有未记录的自动强制转换；软件必须能够在 $\\mathcal{A}_{\\mathrm{aa}} \\times \\mathcal{A}_{\\mathrm{aa}}$ 上定义 $S(a,b)$，并为评估阶段计算有效的统计参数。\n\n以下哪种结果与 BLAST 架构及其统计基础最一致？\n\nA. blastp 通过内部将 $4 \\times 4$ 矩阵扩展为 $20 \\times 20$ 矩阵，为所有未定义的氨基酸对分配零分来正常完成，这会增加高分片段对的数量并产生偏低的 $E$ 值。\n\nB. blastp 运行，但种子阶段只接纳由 $\\{A,C,G,T\\}$ 中残基组成的词，因此灵敏度下降；尽管如此，扩展和评估仍会进行，并且仍然能找到一些真正的同源物。\n\nC. blastp 在初始化时拒绝该矩阵，因为替换矩阵的字母表和维度（$4 \\times 4$ 对比 $20 \\times 20$）与 $\\mathcal{A}_{\\mathrm{aa}}$ 不兼容；因此，无法定义邻域词生成、扩展评分和 Karlin–Altschul 参数，运行因错误而终止，不产生任何比对。\n\nD. blastp 静默地回退到默认的蛋白质矩阵（例如 BLOSUM62）并继续执行，可能会发出警告，因此结果与标准运行相比基本不变。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **程序**：蛋白质基础局部比对搜索工具 (`blastp`)。\n- **用户操作**：尝试在 `blastp` 中使用核苷酸评分矩阵（例如 `NUC.4.4`）。\n- **BLAST 架构**：包括三个阶段：种子、扩展、评估。\n- **评分系统**：由字母表 $\\mathcal{A}$ 上的替换矩阵 $S(a,b)$ 定义。\n- **蛋白质字母表**：$\\mathcal{A}_{\\mathrm{aa}}$，大小为 $|\\mathcal{A}_{\\mathrm{aa}}| = 20$。\n- **核苷酸字母表**：$\\mathcal{A}_{\\mathrm{nt}}$，大小为 $|\\mathcal{A}_{\\mathrm{nt}}| = 4$。\n- **种子阶段**：使用来自 $S(a,b)$ 的得分构建长度为 $w$ 的词的邻域。\n- **扩展阶段**：通过求和 $\\sum_i S(x_i, y_i)$ 为高分片段对 (HSP) 累积得分。\n- **评估阶段**：使用 Karlin–Altschul 理论估计 $E$ 值，这需要从 $S(a,b)$ 和背景残基频率中推导出统计参数 $\\lambda$ 和 $K$。\n- **Karlin–Altschul 先决条件**：随机比对的期望得分必须为负。\n- **问题约束**：\n    1.  “假设没有未记录的自动强制转换”。\n    2.  软件应能在 $\\mathcal{A}_{\\mathrm{aa}} \\times \\mathcal{A}_{\\mathrm{aa}}$ 上定义 $S(a,b)$。\n    3.  软件应能为评估阶段计算有效的统计参数。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题描述了一个涉及使用 BLAST 软件的具体的、技术上合理的情景。问题要求预测为蛋白质搜索提供不匹配输入（即核苷酸矩阵）的操作后果。此问题植根于计算生物学算法的实际应用和理论基础。\n\n- **科学依据**：该问题正确地描述了 `blastp` 程序、其三阶段架构（种子-扩展-评估）、替换矩阵 $S(a,b)$ 的作用、蛋白质 ($\\mathcal{A}_{\\mathrm{aa}}$) 和核苷酸 ($\\mathcal{A}_{\\mathrm{nt}}$) 的字母表，以及 Karlin–Altschul 理论的统计基础。这些都是生物信息学中的既定事实。\n- **表述清晰**：问题陈述清晰，要求根据已知架构和约束预测程序的行为。它提供了足够的信息来推导出合乎逻辑的结果。\n- **客观性**：该问题不含主观语言，提出了一个纯粹的技术问题。\n\n### 步骤 3：结论和行动\n问题陈述是有效的。这是一个关于标准生物信息学算法在错误但明确定义的条件下行为的表述良好的问题。我们将进行全面分析。\n\n### 求解推导\n\n问题的核心是一个根本的类型不匹配。`blastp` 程序设计用于操作蛋白质序列，这些序列是基于大小为 20 的氨基酸字母表 $\\mathcal{A}_{\\mathrm{aa}}$ 的字符串。其所有核心操作都基于一个为所有配对 $(a,b) \\in \\mathcal{A}_{\\mathrm{aa}} \\times \\mathcal{A}_{\\mathrm{aa}}$ 定义的评分矩阵 $S(a,b)$ 的存在，即一个 $20 \\times 20$ 的矩阵。用户提供的是一个核苷酸矩阵，如 `NUC.4.4`，它是一个在字母表 $\\mathcal{A}_{\\mathrm{nt}}$ 上定义的 $4 \\times 4$ 矩阵。虽然这些字母表的典型表示法之间共享一些字母（例如，'A' 代表丙氨酸和腺嘌呤，'C' 代表半胱氨酸和胞嘧啶等），但这只是一种表面上的歧义。从根本上说，所提供的矩阵仅为 `blastp` 期望处理的 20 种实体中的 4 种指定了定义。\n\n一个稳健且正确实现的科学程序必须在启动计算之前验证其输入。让我们假设程序在初始化时没有停止，来分析这种不匹配对 BLAST 算法每个阶段的后果。\n\n1.  **初始化和参数化**：在搜索开始之前，必须配置 BLAST。这包括加载替换矩阵 $S(a,b)$ 并确定统计参数 $\\lambda$ 和 $K$。\n    -   **矩阵加载**：程序期望一个 $20 \\times 20$ 的矩阵。当它读取用户提供的 `NUC.4.4` 文件时，会发现一个 $4 \\times 4$ 的矩阵。这种维度不匹配是一个关键的失败条件。矩阵 $S(a,b)$ 对于像（亮氨酸，脯氨酸）这样的配对或任何涉及不在集合 $\\{A, C, G, T\\}$ 中的 16 种氨基酸的配对根本没有定义。用给定的输入不可能满足软件‘必须能够在 $\\mathcal{A}_{\\mathrm{aa}} \\times \\mathcal{A}_{\\mathrm{aa}}$ 上定义 $S(a,b)$’的要求。\n    -   **统计参数**：$\\lambda$ 和 $K$ 的计算需要求解一个涉及期望得分 $E = \\sum_{i \\in \\mathcal{A}_{\\mathrm{aa}}} \\sum_{j \\in \\mathcal{A}_{\\mathrm{aa}}} p_i p_j S(i,j)$ 的方程，其中 $p_i$ 是氨基酸 $i$ 的背景频率。由于 $S(i,j)$ 对大多数配对是未定义的，这个总和无法计算。负期望得分的先决条件无法验证。因此，无法计算有效的统计参数。\n\n2.  **种子阶段**：此阶段识别短的高分词对（种子）。为此，对于查询序列中每个长度为 $w$ 的词，BLAST 会生成一个“邻域”，其中包含与查询词比对时得分高于阈值 $T$ 的词。此评分是使用 $S(a,b)$ 执行的。如果查询词包含除丙氨酸、半胱氨酸、甘氨酸或苏氨酸（与核苷酸共享单字母代码的氨基酸）之外的任何氨基酸，则其与任何其他词的得分都无法计算。对于典型蛋白质序列的绝大部分，种子生成机制将无法操作。\n\n3.  **扩展阶段**：此阶段扩展种子以生成 HSP。比对的得分是来自 $S(a,b)$ 的替换得分的总和。如果比对包含一对 $S(a,b)$ 未定义的残基，则扩展无法进行。\n\n4.  **评估阶段**：此阶段取决于 HSP 的成功生成以及 $\\lambda$ 和 $K$ 的预先计算。由于这两个先决条件都失败了，因此该阶段无法达到。\n\n唯一合乎逻辑的结论是，一个设计合理的程序会在一开始——在初始化和验证阶段——就检测到这种根本的不兼容性，并因错误而终止。它无法进入任何搜索阶段。\n\n### 逐项分析选项\n\n**A. blastp 通过内部将 $4 \\times 4$ 矩阵扩展为 $20 \\times 20$ 矩阵，为所有未定义的氨基酸对分配零分来正常完成，这会增加高分片段对的数量并产生偏低的 $E$ 值。**\n\n这个提议不合逻辑，并且与问题约束相矛盾。分配得分 0 是一个任意选择，而非‘中性’选择。此行为将构成一种‘未记录的自动强制转换’，而问题陈述禁止我们做此假设。此外，一个大量填充零的矩阵很可能会违反 Karlin-Altschul 的负期望得分条件，从而使任何统计评估无效。关于‘偏低的 E 值’的说法是毫无根据的推测。该选项描述的是鲁莽的程序行为，而不是一个有效的操作后果。**不正确**。\n\n**B. blastp 运行，但种子阶段只接纳由 $\\{A,C,G,T\\}$ 中残基组成的词，因此灵敏度下降；尽管如此，扩展和评估仍会进行，并且仍然能找到一些真正的同源物。**\n\n这描述了一种与 BLAST 设计不一致的残缺执行。该算法旨在处理整个序列。它不会选择性地忽略它无法评分的查询和数据库部分。一旦遇到第一对得分未定义的氨基酸——这对于任何典型的蛋白质几乎会立即发生——程序将面临一个致命的执行错误。关于扩展和评估可以‘进行’的说法是错误的，因为必要的组件（一个完整的评分矩阵和统计参数）缺失。**不正确**。\n\n**C. blastp 在初始化时拒绝该矩阵，因为替换矩阵的字母表和维度（$4 \\times 4$ 对比 $20 \\times 20$）与 $\\mathcal{A}_{\\mathrm{aa}}$ 不兼容；因此，无法定义邻域词生成、扩展评分和 Karlin–Altschul 参数，运行因错误而终止，不产生任何比对。**\n\n这个结果是唯一符合健全的软件工程原则和 BLAST 算法理论要求的结果。程序必须验证其输入。所提供的矩阵与 `blastp` 的要求根本不兼容。这种维度和字母表的不兼容性使得为蛋白质比对定义评分函数成为不可能，这反过来又阻止了统计参数的计算、种子邻域的生成以及扩展的评分。对程序来说，唯一正确和安全的做法是报告错误并在初始化时终止。**正确**。\n\n**D. blastp 静默地回退到默认的蛋白质矩阵（例如 BLOSUM62）并继续执行，可能会发出警告，因此结果与标准运行相比基本不变。**\n\n在用户明确提供了自定义输入后，“静默地”回退到默认设置是一种危险的糟糕设计。它颠覆了用户的意图，可能导致对结果的严重误解。虽然程序可能会在*发出清晰且显著的警告后*回退，但对于这种性质的无效输入，最稳健的行为是硬性失败。建议“静默”回退的选项尤其恶劣，也构成了一种“强制转换”。因此，这不是一个设计良好的科学工具的预期行为。**不正确**。", "answer": "$$\\boxed{C}$$", "id": "2434631"}]}