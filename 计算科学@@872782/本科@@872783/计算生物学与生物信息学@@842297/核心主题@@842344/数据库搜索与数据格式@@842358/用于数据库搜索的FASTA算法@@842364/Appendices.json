{"hands_on_practices": [{"introduction": "FASTA 算法的核心优势在于其速度，这主要归功于第一步中用于快速识别“种子”（即短的完全匹配片段）的查找表。这个练习将引导你分析该查找表的内存占用，这是一个基础但至关重要的数据结构问题。通过这个计算 [@problem_id:2435282]，你将亲身体会到参数 $k$（字长）和 $A$（字母表大小）如何以指数方式影响内存需求，这是设计序列搜索算法时必须面对的一个核心限制。", "problem": "在用于数据库搜索的快速全局比对（FASTA）算法中，查询索引步骤会构建一个直接寻址查找表。该表将由大小为 $A$ 的有限字母表构成的每个可能的长度为 $k$ 的连续词（一个 $k$-元组）映射到一个固定大小的记录。\n\n假设查找表使用以下模型：它是一个完全分配的数组，为每个可能的 $k$-元组都设有一个条目，并且每个条目精确存储 $b$ 字节（例如，一个指针或偏移量），没有压缩、池化或延迟分配。无论查询内容如何，该表的构建方式都完全相同。\n\n仅使用这些假设和基本的计数原理，确定查找表的预期总内存使用量，并以 $A$、$k$ 和 $b$ 的闭式函数表示。请用字节表示最终答案。无需四舍五入，最终结果必须是单个解析表达式。", "solution": "经评估，该问题陈述有效。它具有科学依据，定义明确且客观。它描述了直接寻址查找表的一个简化但有效的模型，这是计算机科学中的一种基本数据结构，应用于FASTA算法的上下文中。求解所需的所有参数——字母表大小 $A$、词长 $k$ 以及每个条目的内存大小 $b$——都已明确给出。该问题是基本计数原理的直接应用。\n\n目标是确定查找表的总内存使用量。对于一个完全分配的类数组数据结构，其所需的总内存 $M$ 等于总条目数 $N$ 与每个条目所需内存（给定为 $b$ 字节）的乘积。\n\n$$M = N \\times b$$\n\n问题陈述指出，每个条目的内存大小是固定的 $b$ 字节。\n\n问题的核心是确定查找表中的总条目数 $N$。问题指明，该表为每个可以由大小为 $A$ 的字母表构成的可能的 $k$-元组都设有“一个条目”。一个 $k$-元组是一个长度为 $k$ 的连续词。\n\n我们可以使用基本计数原理——乘法法则，来确定唯一 $k$-元组的数量。一个长度为 $k$ 的词由 $k$ 个位置组成。对于每个位置，都可以从字母表中选择 $A$ 个可能的字符。由于每个位置的选择与其他所有位置的选择是独立的，所以唯一词的总数是 $k$ 个位置上选择数量的乘积。\n\n$$N = \\underbrace{A \\times A \\times \\dots \\times A}_{k \\text{ times}}$$\n\n这个乘积等价于 $A$ 的 $k$ 次方。\n\n$$N = A^{k}$$\n\n问题陈述要求的是*预期*总内存使用量。然而，所提供的模型是确定性的。该表是“完全分配的”，并且其构建方式“无论查询内容如何都完全相同”。这意味着表的大小是固定的，不依赖于任何随机变量或特定的输入查询序列。因此，预期内存使用量就是其实际计算出的内存使用量。\n\n将条目数 $N$ 的表达式代入总内存 $M$ 的方程，我们得到最终的表达式。\n\n$$M = A^{k} \\times b$$\n\n根据 $b$ 的定义，单位是字节。查找表总内存使用量的最终表达式是给定参数 $A$、$k$ 和 $b$ 的一个闭式函数。", "answer": "$$\\boxed{b A^{k}}$$", "id": "2435282"}, {"introduction": "在了解了用于识别种子的数据结构后，下一个关键问题是：在庞大的数据库中，我们期望偶然发现多少匹配？本练习通过一个简化的概率模型来解决这个问题，帮助你量化数据库搜索中的“背景噪音”。通过推导 [@problem_id:2435300] 中的公式，你将从统计学的角度理解为什么选择一个合适的字长 $k$ 对于在检测真实信号（灵敏度）和避免随机匹配（特异性）之间取得平衡至关重要。", "problem": "一种基于词的数据库搜索算法将初始“命中”识别为查询序列与数据库序列之间长度为 $k$ 的词（$k$-元组）的精确匹配。考虑一个长度为 $m$ 的查询序列和一个长度为 $N$ 的单个连续数据库序列。假设字母表 $\\mathcal{A}$ 的大小为 $s$，其中的字母根据概率 $\\{p_1, p_2, \\ldots, p_s\\}$ 进行独立同分布（i.i.d.）抽样，其中 $\\sum_{j=1}^{s} p_j = 1$。一个 $k$-元组匹配被定义为两个长度为 $k$ 的子串，一个来自查询序列，一个来自数据库序列，它们逐个字母完全相同。\n\n假设：\n- $m \\ge k$ 且 $N \\ge k$。\n- 两个序列中的所有字母都根据给定构成进行独立同分布抽样。\n- 对于不同的 $k$-元组对（一个来自查询序列，一个来自数据库序列），其结果是相互独立的。\n\n在这些假设下，建立一个模型来计算查询序列和数据库序列在其整个长度上存在至少一个精确 $k$-元组匹配的概率。请以 $m$、$N$、$k$ 和 $\\{p_j\\}_{j=1}^{s}$ 的形式，给出一个单一的闭式解析表达式作为最终结果。不要进行数值简化。", "solution": "对所提出的问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 查询序列长度：$m$\n- 数据库序列长度：$N$\n- 匹配词长：$k$\n- 字母表大小：$s$\n- 字母的概率分布：$\\{p_1, p_2, \\ldots, p_s\\}$，其中 $\\sum_{j=1}^{s} p_j = 1$。\n- 约束条件：$m \\ge k$ 且 $N \\ge k$。\n- 假设1：两个序列中的所有字母都是独立同分布（i.i.d.）的。\n- 假设2：不同的 $k$-元组对（一个来自查询序列，一个来自数据库序列）的结果是相互独立的。\n\n**步骤2：使用提取的已知条件进行验证**\n根据所需标准对问题进行评估。\n- **科学基础：** 该问题使用了一个简化的概率模型（独立同分布序列），这在生物信息学导论中常用于分析算法性能。虽然生物序列表现出更复杂的统计特性，但这种类伯努利模型是一个标准的理论出发点。在此建模背景下，它是科学合理的。\n- **良构性：** 问题提供了所有必要的参数（$m, N, k, \\{p_j\\}$）和明确的条件，以推导出所要求概率的唯一数学表达式。\n- **客观性：** 语言正式且无歧义。\n- **缺陷分析：** 问题没有违反任何指定的缺陷条件。关于所有 $k$-元组对结果相互独立的假设是一个很强的简化，它偏离了重叠 $k$-元组会产生依赖关系的实际情况。然而，这是对模型的一个明确指令，而不是问题陈述本身的缺陷。因此，该问题在其陈述下是内部一致且可解的。\n\n**步骤3：结论与行动**\n问题被判定为**有效**。将根据所提供的框架推导解决方案。\n\n目标是计算至少存在一个精确 $k$-元组匹配的概率。更直接的方法是首先计算其互补事件——即零匹配——的概率，然后用 1 减去这个概率。\n\n令 $E$ 为至少有一次匹配的事件。我们要求解 $P(E) = 1 - P(E^c)$，其中 $E^c$ 是没有匹配的事件。\n\n首先，我们确定从查询序列中任意选择的一个 $k$-元组与从数据库序列中任意选择的一个 $k$-元组之间发生匹配的概率。将此概率表示为 $p_{match}$。\n\n两个 $k$-元组之间的匹配要求所有 $k$ 对相应位置的字符都相同。由于字母的独立同分布假设，我们可以首先计算单个字符从查询序列中与从数据库序列中的字符相同的概率，记为 $P_{iden}$。这种情况发生在两个字符都是字母表中的第一个字母，或者都是第二个字母，依此类推。\n给定字母概率 $\\{p_j\\}$ 以及两个序列的独立性，该概率为：\n$$P_{iden} = \\sum_{j=1}^{s} P(\\text{query char is } j \\text{ and db char is } j) = \\sum_{j=1}^{s} P(\\text{query char is } j) \\times P(\\text{db char is } j)$$\n$$P_{iden} = \\sum_{j=1}^{s} p_j \\cdot p_j = \\sum_{j=1}^{s} p_j^2$$\n\n由于每个 $k$-元组内的字母也是独立同分布的，因此两个 $k$-元组相同的概率是 $k$ 个位置各自独立匹配的概率的乘积。\n$$p_{match} = (P_{iden})^k = \\left(\\sum_{j=1}^{s} p_j^2\\right)^k$$\n\n接下来，我们必须计算此类比较的总次数。\n长度为 $m$ 的查询序列有 $(m-k+1)$ 个可能的 $k$-元组起始位置。\n长度为 $N$ 的数据库序列有 $(N-k+1)$ 个可能的 $k$-元组起始位置。\n因此，（来自查询的 $k$-元组，来自数据库的 $k$-元组）的不同配对总数为：\n$$C = (m-k+1)(N-k+1)$$\n\n问题陈述指出，这 $C$ 个不同配对的结果是相互独立的。这使我们可以将整个搜索过程建模为一系列 $C$ 次独立的伯努利试验。每次试验是单个 $k$-元组对的比较，其“成功”（匹配）概率为 $p_{match}$。\n\n事件 $E^c$（无匹配）对应于经历 $C$ 次连续的“失败”。单次失败（给定配对不匹配）的概率是 $(1 - p_{match})$。由于独立性，所有 $C$ 次试验都失败的概率是：\n$$P(E^c) = (1 - p_{match})^C = \\left(1 - \\left(\\sum_{j=1}^{s} p_j^2\\right)^k\\right)^{(m-k+1)(N-k+1)}$$\n\n最后，通过互补法则求得至少有一次匹配的概率 $P(E)$：\n$$P(E) = 1 - P(E^c) = 1 - \\left(1 - \\left(\\sum_{j=1}^{s} p_j^2\\right)^k\\right)^{(m-k+1)(N-k+1)}$$\n\n这是在所述假设下推导出的最终解析表达式。", "answer": "$$\n\\boxed{1 - \\left(1 - \\left(\\sum_{j=1}^{s} p_j^2\\right)^k\\right)^{(m-k+1)(N-k+1)}}\n$$", "id": "2435300"}, {"introduction": "前面的练习分别探讨了 FASTA 算法的空间复杂度和其种子匹配的统计基础。现在，是时候将这些概念融合成一个可执行的计算模型了。在这个编程练习 [@problem_id:2435286] 中，你将亲手实现 FASTA 初始阶段的简化逻辑，包括种子识别、对角线评分和基于阈值的筛选。通过调节评分阈值 $\\tau$ 等参数，你将能够直观地观察到算法如何在灵敏度（保留真实同源信号）和计算成本（需要处理的对角线数量）之间做出权衡，从而深刻理解启发式算法的设计精髓。", "problem": "构建一个完整、可运行的程序，该程序在下述理想化但数学上精确的设定下，模拟快速比对搜索工具 (FASTA) 在初始对角线得分（记为 $init1$）阈值与必须存储和连接的对角线数量之间的权衡。所有计算均为纯符号和组合计算，不涉及任何物理单位。\n\n定义和设置：\n\n- 设核苷酸字母表为 $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$。序列是 $\\Sigma$ 上的有限字符串。\n- 设查询序列为 $Q$，长度为 $L_Q$，其索引从零开始，为 $i\\in\\{0,1,\\dots,L_Q-1\\}$。设主题（数据库）序列为 $S$，长度为 $L_S$，其索引从零开始，为 $j\\in\\{0,1,\\dots,L_S-1\\}$。\n- 固定一个词长 $k\\in\\mathbb{Z}_{\\ge 1}$。一个 $k$-mer 是任意长度为 $k$ 的连续子串。对于任意 $i\\in\\{0,1,\\dots,L_Q-k\\}$ 和 $j\\in\\{0,1,\\dots,L_S-k\\}$，当且仅当 $k$-mer 完全相等时，即 $Q[i:i+k]=S[j:j+k]$，在配对 $(i,j)$ 处出现一个种子（seed）。\n- 定义对角线偏移量 $d=i-j$。对于一个固定的对角线 $d\\in\\mathbb{Z}$，设 $M_d=\\{i\\in\\{0,1,\\dots,L_Q-k\\}\\mid \\exists j \\text{ with } j=i-d \\text{ and } 0\\le j\\le L_S-k \\text{ such that } Q[i:i+k]=S[j:j+k]\\}$ 是在对角线 $d$ 上参与形成种子的查询索引集合。设 $|M_d|$ 表示其基数。\n- 固定一个种子奖励 $s_m\\in\\mathbb{Z}_{\\ge 1}$。定义初始对角线得分为 $init1(d)=s_m\\cdot |M_d|$。\n- 给定一个阈值 $\\tau\\in\\mathbb{Z}_{\\ge 0}$，保留（存储）的对角线集合为 $D_{\\tau}=\\{d\\in\\mathbb{Z}\\mid init1(d)\\ge \\tau\\}$，存储的对角线数量为 $|D_{\\tau}|$。\n- 固定一个邻近参数 $\\delta\\in\\mathbb{Z}_{\\ge 0}$。对于每个保留的对角线 $d\\in D_{\\tau}$，将其集合 $M_d$ 的元素按升序排序为 $i_1  i_2  \\dots  i_{t_d}$，其中 $t_d=|M_d|$。对于此对角线，其连接数 $J_d$ 定义为满足 $i_{\\ell+1} - i_\\ell \\le \\delta$ 的相邻索引对 $(i_\\ell, i_{\\ell+1})$ 的数量。总连接数 $J$ 是所有保留对角线上连接数的总和：$J = \\sum_{d \\in D_{\\tau}} J_d$。\n- 最后，设 $D^\\star$ 是一个已知的“真实”同源对角线的集合。我们定义一个布尔值 $B$，当且仅当所有真实同源对角线都被我们的筛选过程保留下来时，$B$ 为真，即 $D^\\star \\subseteq D_{\\tau}$。\n\n你的任务是：对于下面给出的每个测试用例，计算并输出一个包含三个元素的三元组：$[|D_{\\tau}|, J, B]$。", "solution": "问题陈述是对 FASTA 算法初始阶段简化模型的一个有效、适定且有科学依据的阐述。它提供了一套清晰、客观且完整的定义和参数，用以计算灵敏度（保留真实同源对角线）与计算成本（存储的对角线数量和连接操作数）之间的权衡。所有术语都得到了严格定义，且测试用例的数据是自洽和一致的。因此，我将继续提供完整的解决方案。\n\n该解决方案通过实现一个严格遵循问题陈述中定义的计算程序来构建。该算法针对每个测试用例执行，以计算所需的三元组 $[|D_{\\tau}|, J, B]$。整个过程分为四个主要的逻辑步骤。\n\n首先，我们必须识别长度为 $L_Q$ 的查询序列 $Q$ 和长度为 $L_S$ 的主题序列 $S$ 之间的所有种子匹配。一个种子是 $Q$ 中的一个 $k$-mer 与 $S$ 中的一个 $k$-mer 之间的完美匹配。为了高效地完成此任务，我们首先构建一个查找表（哈希映射或字典），将主题序列 $S$ 中存在的每个唯一 $k$-mer 映射到其起始索引 $j$ 的列表。然后我们遍历查询序列 $Q$，提取从索引 $i \\in \\{0, 1, \\dots, L_Q - k\\}$ 开始的每个 $k$-mer。对于每个查询 $k$-mer，我们使用查找表找到 $S$ 中所有匹配的 $k$-mer。对于在查询 $k$-mer（起始于 $i$）和主题 $k$-mer（起始于 $j$）之间找到的每个匹配，我们计算对角线偏移量 $d = i - j$。我们将一个主数据结构填充起来，这是一个映射，其中键是对角线偏移量 $d$，值是为该对角线贡献种子的查询索引 $i$ 的列表。这个结构代表了集合的集合 $\\{M_d\\}_{d\\in\\mathbb{Z}}$。\n\n其次，在构建了 `diagonal_matches` 映射后，我们计算每个对角线的初始得分，并根据阈值 $\\tau$ 对它们进行筛选。对于每个至少有一个种子的对角线 $d$，其得分由 $init1(d) = s_m \\cdot |M_d|$ 给出，其中 $|M_d|$ 是该对角线上的种子数量，$s_m$ 是种子奖励。然后我们形成保留的对角线集合 $D_{\\tau} = \\{d \\in \\mathbb{Z} \\mid init1(d) \\ge \\tau\\}$。我们输出的第一个组成部分是这个集合的基数 $|D_{\\tau}|$。\n\n第三，我们计算总连接操作数 $J$。这个计算只在集合 $D_{\\tau}$ 中保留的对角线上执行。对于每个这样的对角线 $d \\in D_{\\tau}$，我们检索其贡献的查询索引列表 $M_d$。这个列表必须按升序排序以分析邻近性：$i_1  i_2  \\dots  i_{t_d}$，其中 $t_d = |M_d|$。这个单条对角线的连接数 $J_d$ 是差值在邻近参数 $\\delta$ 内的相邻索引对 $(i_\\ell, i_{\\ell+1})$ 的数量，即 $i_{\\ell+1} - i_\\ell \\le \\delta$。总连接数 $J$ 是这些计数在所有保留对角线上的总和：$J = \\sum_{d \\in D_{\\tau}} J_d$。这是我们输出的第二个组成部分。\n\n第四，我们对已知的同源区域进行验证检查。问题提供了一组真实同源对角线 $D^\\star$。我们必须确定我们的筛选过程是否成功保留了所有这些关键的对角线。这通过检查 $D^\\star$ 是否是我们计算出的保留集合 $D_{\\tau}$ 的子集来形式化。如果 $D^\\star \\subseteq D_{\\tau}$，布尔变量 $B$ 设置为 True，否则为 False。这个布尔值是我们输出三元组的第三个也是最后一个组成部分。\n\n通过对每个提供的测试用例执行这四个步骤，我们可以为每个案例生成所需的输出列表 $[|D_{\\tau}|, J, B]$，并按照指定格式进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to solve the FASTA trade-off problem for all test cases.\n    \"\"\"\n\n    def compute_fasta_metrics(Q, S, k, s_m, tau, delta, D_star):\n        \"\"\"\n        Computes the required metrics for a single FASTA test case.\n\n        Args:\n            Q (str): The query sequence.\n            S (str): The subject sequence.\n            k (int): The k-mer length.\n            s_m (int): The seed reward.\n            tau (int): The initial diagonal score threshold.\n            delta (int): The proximity parameter for joining.\n            D_star (list): The list of true homologous diagonals.\n\n        Returns:\n            list: A list containing [|D_tau|, J, B].\n        \"\"\"\n        L_Q = len(Q)\n        L_S = len(S)\n\n        # Step 1: Find all seeds and populate diagonal_matches.\n        # Create a lookup table for k-mer positions in the subject sequence S.\n        kmer_positions_s = defaultdict(list)\n        if L_S >= k:\n            for j in range(L_S - k + 1):\n                kmer = S[j : j + k]\n                kmer_positions_s[kmer].append(j)\n\n        # Find matches by iterating through k-mers in the query sequence Q.\n        diagonal_matches = defaultdict(list)\n        if L_Q >= k:\n            for i in range(L_Q - k + 1):\n                kmer = Q[i : i + k]\n                if kmer in kmer_positions_s:\n                    for j in kmer_positions_s[kmer]:\n                        d = i - j\n                        diagonal_matches[d].append(i)\n\n        # Step 2: Compute initial scores and filter diagonals.\n        D_tau = set()\n        retained_matches = {}\n        for d, M_d in diagonal_matches.items():\n            init1_score = s_m * len(M_d)\n            if init1_score >= tau:\n                D_tau.add(d)\n                retained_matches[d] = M_d\n        \n        num_stored_diagonals = len(D_tau)\n\n        # Step 3: Calculate total number of joins (J).\n        total_joins = 0\n        for d in D_tau:\n            M_d = retained_matches[d]\n            M_d.sort()  # Ensure indices are sorted for proximity check.\n            \n            joins_d = 0\n            if len(M_d) > 1:\n                for idx in range(len(M_d) - 1):\n                    if M_d[idx + 1] - M_d[idx] = delta:\n                        joins_d += 1\n            total_joins += joins_d\n\n        # Step 4: Check for homologous diagonals.\n        D_star_set = set(D_star)\n        B = D_star_set.issubset(D_tau)\n\n        return [num_stored_diagonals, total_joins, B]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Q\": \"ACGTGACCTGATCGTACGTA\",\n            \"S\": \"TTTTACGTGACCTGATCGTACGTACCCC\",\n            \"k\": 4, \"s_m\": 1, \"tau\": 8, \"delta\": 5,\n            \"D_star\": [-4]\n        },\n        {\n            \"Q\": \"ACGTGACCTGATCGTACGTA\",\n            \"S\": \"TTTTACGTGACCTGATCGTACGTACCCC\",\n            \"k\": 4, \"s_m\": 1, \"tau\": 18, \"delta\": 5,\n            \"D_star\": [-4]\n        },\n        {\n            \"A\": \"ACGTCGATGCTAGTCA\",\n            \"B_seq\": \"TGACCTGATCGTAGCA\",\n            \"Q\": \"ACGTCGATGCTAGTCA\" + \"GGGG\" + \"TGACCTGATCGTAGCA\",\n            \"S\": \"TT\" + \"ACGTCGATGCTAGTCA\" + \"TTTTTT\" + \"TGACCTGATCGTAGCA\" + \"CC\",\n            \"k\": 4, \"s_m\": 1, \"tau\": 10, \"delta\": 5,\n            \"D_star\": [-2, -4]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_fasta_metrics(\n            case[\"Q\"], case[\"S\"], case[\"k\"], case[\"s_m\"], \n            case[\"tau\"], case[\"delta\"], case[\"D_star\"]\n        )\n        results.append(result)\n\n    # Convert results to a string representation for the final output.\n    # The boolean True/False needs to be capitalized as per Python's str() behavior.\n    result_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(result_str)\n\nsolve()\n```", "id": "2435286"}]}