{"hands_on_practices": [{"introduction": "理解算法的第一步是亲手实现它。本练习将指导你将间隔种子哈希的形式化定义转化为一个可执行的程序。通过这个过程，你将巩固对如何选择特定的DNA位置并将其编码为单个哈希值的理解 ([@problem_id:2441094])。", "problem": "给定脱氧核糖核酸 (DNA) 字母表 $\\{A,C,G,T\\}$ 上的间隔种子哈希的形式化定义。间隔种子模式是一个长度为 $L$ 且至少包含一个 $1$ 的二进制字符串 $s$；$s$ 中符号 $1$ 的数量是字长参数 $w$。对于一个长度为 $n \\geq L$ 的 DNA 字符串 $x$，考虑其每个长度为 $L$ 的连续子串（窗口）$x[i\\,..\\,i+L-1]$，其中 $i \\in \\{0,1,\\dots,n-L\\}$。将匹配位置的索引集合定义为 $P = \\{j \\in \\{0,1,\\dots,L-1\\} \\mid s[j] = 1\\}$，并按严格递增顺序列出为 $P = (p_0,p_1,\\dots,p_{w-1})$。定义一个符号到数字的映射 $\\phi:\\{A,C,G,T\\} \\to \\{0,1,2,3\\}$，具体为 $\\phi(A)=0, \\phi(C)=1, \\phi(G)=2, \\phi(T)=3$。窗口 $x[i\\,..\\,i+L-1]$ 相对于 $s$ 的间隔种子哈希是一个4进制整数\n$$\nH_s\\big(x[i\\,..\\,i+L-1]\\big) \\;=\\; \\sum_{t=0}^{w-1} \\phi\\big(x[i+p_t]\\big)\\cdot 4^{\\,w-1-t}.\n$$\n所有字符串将只包含字母 $A$、$C$、$G$ 和 $T$。所有索引都是从0开始的。所有算术运算都在整数上进行。\n\n任务：实现一个程序，对下面的每个测试用例，使用上述定义，按 $i$ 递增的顺序计算每个窗口 $x[i\\,..\\,i+L-1]$ 的间隔种子哈希值 $H_s$ 列表。\n\n测试套件：\n- 用例 1（一般情况）：$s=\\text{\"10101\"}$（因此 $L=5$），$x=\\text{\"ACGTACGTAC\"}$（因此 $n=10$）。\n- 用例 2（大量非匹配位置）：$s=\\text{\"100000010000001\"}$（因此 $L=15$），$x=\\text{\"ACGTACGTACGTACGTACGT\"}$（因此 $n=20$）。\n- 用例 3（单个匹配位置，边界情况）：$s=\\text{\"0001000\"}$（因此 $L=7$），$x=\\text{\"TTACGGAAC\"}$（因此 $n=9$）。\n- 用例 4（全为匹配位置，密集种子）：$s=\\text{\"1111\"}$（因此 $L=4$），$x=\\text{\"AGCTAG\"}$（因此 $n=6$）。\n\n对于每个用例，要求的结果是整数列表 $[H_s(x[0\\,..\\,L-1]), H_s(x[1\\,..\\,L]), \\dots, H_s(x[n-L\\,..\\,n-1])]$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。每个结果都必须是一个用方括号括起来、逗号分隔且不含空格的整数列表。例如，一个有效的输出结构是 “[[a,b],[c,d],[e,f,g],[h]]”，其中 $a,b,c,d,e,f,g,h$ 是按规定计算的整数。输出行中不允许有额外的文本或空白字符。", "solution": "问题陈述已经过验证，被认定为有效。它具有科学依据、定义明确且客观。它为间隔种子哈希函数这一计算生物学中的标准概念提供了形式化、完整且一致的定义。任务是实现此函数并将其应用于一组给定的测试用例。可以系统地构建一个分步解决方案。\n\n目标是为长度为 $n$ 的较长 DNA 序列 $x$ 中的每个长度为 $L$ 的可能连续子串（窗口）计算间隔种子哈希值 $H_s$。该过程是确定性的，可以分解为以下步骤。\n\n首先，必须处理间隔种子模式 $s$。模式的长度用 $L$ 表示。从 $s$ 中，我们必须确定*匹配位置*集合 $P$，即模式字符串 $s$ 中包含字符 '1' 的从0开始的索引。将这些索引收集到一个有序列表 $P = (p_0, p_1, \\dots, p_{w-1})$ 中，其中索引按严格递增顺序排序。匹配位置的数量 $w = |P|$ 是种子的字长。\n\n其次，提供的符号到数字的映射 $\\phi:\\{A,C,G,T\\} \\to \\{0,1,2,3\\}$ 定义为 $\\phi(A)=0, \\phi(C)=1, \\phi(G)=2, \\phi(T)=3$。此映射将相关的 DNA 字符转换为其数值表示。\n\n第三，我们遍历 DNA 序列 $x$。序列 $x$ 的长度为 $n$。窗口是长度为 $L$ 的子串。第一个窗口是 $x[0\\,..\\,L-1]$，第二个是 $x[1\\,..\\,L]$，依此类推，直到最后一个可能的窗口 $x[n-L\\,..\\,n-1]$。迭代遍历窗口的起始索引 $i$，其中 $i \\in \\{0, 1, \\dots, n-L\\}$。\n\n对于从索引 $i$ 开始的每个窗口，我们计算哈希值 $H_s\\big(x[i\\,..\\,i+L-1]\\big)$。提供的定义是：\n$$\nH_s\\big(x[i\\,..\\,i+L-1]\\big) \\;=\\; \\sum_{t=0}^{w-1} \\phi\\big(x[i+p_t]\\big)\\cdot 4^{\\,w-1-t}\n$$\n这个公式表示一个4进制整数的构建过程。该数的“位数”是当前窗口内匹配位置上字符对应的值 $\\phi\\big(x[i+p_t]\\big)$。字符串 $x$ 中绝对索引为 $i+p_t$ 的字符对应于种子模式的第 $t$ 个匹配位置，其中 $t$ 的范围从 $0$ 到 $w-1$。项 $4^{w-1-t}$ 为4进制系统中的每一位提供了正确的位置权重。\n\n一个计算上高效的求和方法是使用霍纳法则。我们可以将哈希值 $H$ 初始化为 $0$。然后，对于从 $0$ 到 $w-1$ 的每个 $t$，我们使用以下规则更新哈希值：\n$$\nH_{\\text{new}} = H_{\\text{old}} \\cdot 4 + \\phi\\big(x[i+p_t]\\big)\n$$\n这个迭代过程避免了在每一步中显式计算 $4$ 的幂。为清晰起见，我们将其展开。\n当 $t=0$ 时：$H = \\phi\\big(x[i+p_0]\\big)$。\n当 $t=1$ 时：$H = \\big(\\phi\\big(x[i+p_0]\\big)\\big) \\cdot 4 + \\phi\\big(x[i+p_1]\\big)$。\n当 $t=2$ 时：$H = \\big(\\phi\\big(x[i+p_0]\\big) \\cdot 4 + \\phi\\big(x[i+p_1]\\big)\\big) \\cdot 4 + \\phi\\big(x[i+p_2]\\big) = \\phi\\big(x[i+p_0]\\big) \\cdot 4^2 + \\phi\\big(x[i+p_1]\\big) \\cdot 4^1 + \\phi\\big(x[i+p_2]\\big) \\cdot 4^0$。\n这表明迭代更新正确地计算了指定的求和。\n\n对从 $i=0$ 到 $i=n-L$ 的每个窗口都执行这整个过程。将得到的整数哈希值按其对应窗口索引 $i$ 的顺序收集到一个列表中。然后对问题陈述中提供的每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to drive the solution. It defines the test cases and computes\n    the spaced-seed hashes for each, then prints the results in the specified format.\n    \"\"\"\n    \n    # Define the symbol-to-digit mapping phi\n    phi = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general case)\n        (\"10101\", \"ACGTACGTAC\"),\n        # Case 2 (large number of do-not-care positions)\n        (\"100000010000001\", \"ACGTACGTACGTACGTACGT\"),\n        # Case 3 (single care position, boundary case)\n        (\"0001000\", \"TTACGGAAC\"),\n        # Case 4 (all care positions, dense seed)\n        (\"1111\", \"AGCTAG\"),\n    ]\n\n    all_results = []\n    for s, x in test_cases:\n        hashes = calculate_spaced_seed_hashes(s, x, phi)\n        all_results.append(hashes)\n    \n    # Format the final output according to the problem specification.\n    # e.g., \"[[r1_1,r1_2],[r2_1,r2_2,r2_3]]\"\n    formatted_results = []\n    for result_list in all_results:\n        # Convert each integer list to a comma-separated string without spaces.\n        formatted_list = f\"[{','.join(map(str, result_list))}]\"\n        formatted_results.append(formatted_list)\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\ndef calculate_spaced_seed_hashes(s, x, phi):\n    \"\"\"\n    Computes the list of spaced-seed hash values for a given seed pattern and DNA string.\n\n    Args:\n        s (str): The spaced seed pattern (binary string).\n        x (str): The DNA sequence.\n        phi (dict): The symbol-to-digit mapping.\n\n    Returns:\n        list[int]: A list of calculated hash values for each window.\n    \"\"\"\n    L = len(s)\n    n = len(x)\n    \n    # Determine the care positions and the word size w\n    care_positions = [j for j, char in enumerate(s) if char == '1']\n    w = len(care_positions)\n    \n    # Check for the edge case where the seed has no care positions, although\n    # the problem statement guarantees at least one '1'.\n    if w == 0:\n        return [0] * (n - L + 1) if n >= L else []\n\n    hash_results = []\n    \n    # Iterate through all possible windows in the DNA sequence x\n    for i in range(n - L + 1):\n        # For each window, compute the spaced-seed hash\n        current_hash = 0\n        \n        # Iteratively build the base-4 hash value\n        # This is equivalent to Horner's method for polynomial evaluation\n        # and avoids costly exponentiation inside the loop.\n        for p_t in care_positions:\n            # Get the character at the care position within the current window\n            char_at_pos = x[i + p_t]\n            # Map character to its digit value\n            digit = phi[char_at_pos]\n            # Update hash: H = H * 4 + digit\n            current_hash = current_hash * 4 + digit\n            \n        hash_results.append(current_hash)\n        \n    return hash_results\n\nsolve()\n```", "id": "2441094"}, {"introduction": "既然我们知道了如何生成哈希值，那么为一个像人类这样的大型基因组存储这些哈希值需要什么呢？这项练习提供了一个真实世界的背景，要求你计算人类基因组索引所需的内存 ([@problem_id:2441116])。这个计算突出了种子参数（如权重 $W$）与计算资源之间的关键权衡。", "problem": "您正在为单倍体人类参考基因组构建一个间隔种子索引，以支持种子-延伸比对。间隔种子由一个跨度为 $S$、权重为 $W$ 的二进制掩码定义，该掩码在一个由 $S$ 个核苷酸组成的窗口内选择 $W$ 个信息位置。对于本问题，该掩码的权重 $W=12$，跨度 $S=18$。要构建的索引是一个直接地址哈希索引，其规格如下：\n\n- 单倍体人类基因组的长度为 $L=3.2\\times 10^{9}$ 个碱基。假设基因组中没有任何不明确的核苷酸 ($N$)。\n- 对于从 $1$ 到 $L-S+1$ 的每个基因组偏移量 $t$，在窗口 $[t, t+S-1]$ 处提取由掩码定义的间隔种子。只考虑正链。\n- 每个间隔种子由 $2W$ 位（每个核苷酸两位）编码，总共产生 $4^{W}$ 个可能的键。\n- 该索引由两个数组组成：\n  1. 一个主直接地址数组，长度为 $4^{W}$，由种子的 $2W$ 位代码作为键。对于每个键，存储两个无符号 32 位整数：该键在位置数组中的起始偏移量和位置计数。不存储其他元数据。\n  2. 一个位置数组，每个有效窗口包含一个无符号 32 位整数，存储每次间隔种子出现的基因组起始坐标 $t$。条目的布局方式是，将同一键的所有位置连续分组（键的顺序任意）。\n- 忽略操作系统或内存分配器带来的任何内存开销；只计算这些数组的原始字节大小。\n- 使用千兆字节 (Gigabyte, GB) 的十进制定义（$1$ GB $=10^{9}$ 字节）。\n\n在这些假设下，存储完整索引所需的总内存是多少（以千兆字节为单位）？将您的答案四舍五入到三位有效数字。", "solution": "问题陈述需经验证。\n\n**第 1 步：提取已知信息**\n- 间隔种子掩码跨度: $S=18$\n- 间隔种子掩码权重: $W=12$\n- 单倍体人类基因组长度: $L=3.2 \\times 10^{9}$ 个碱基\n- 核苷酸编码: 每个核苷酸 $2$ 位\n- 种子键编码: $2W$ 位\n- 可能的键总数: $4^{W}$\n- 索引结构:\n    1. 主直接地址数组:\n        - 长度: $4^{W}$\n        - 条目内容: 两个无符号 32 位整数\n    2. 位置数组:\n        - 内容: 每个有效窗口一个无符号 32 位整数\n        - 有效窗口: 基因组偏移量 $t$ 从 $1$ 到 $L-S+1$\n- 数据类型: 无符号 32 位整数\n- 内存开销 (操作系统, 分配器): 忽略\n- 单位定义: $1$ 千兆字节 (GB) $= 10^9$ 字节\n- 输出要求: 总内存, 单位为 GB, 四舍五入到三位有效数字。\n\n**第 2 步：使用提取的已知信息进行验证**\n根据指定标准对问题进行评估。\n- **科学依据**：该问题描述了间隔种子索引的构建，这是生物信息学中用于序列比对的一种基础且广泛使用的数据结构。给定的参数（$L, S, W$）对于索引人类基因组是切合实际的。该概念是合理的。\n- **定义明确**：问题规范清晰。所有必要的参数和定义都已提供，用以计算构成索引的两个数组的大小。存在唯一的数值解。\n- **客观性**：语言精确且量化。没有主观或模棱两可的陈述。\n- **完整性与一致性**：问题是自包含的。数据类型（无符号 32 位整数）足以存储所需信息；一个 32 位整数可以容纳高达 $2^{32}-1 \\approx 4.29 \\times 10^9$ 的值，这大于最大基因组偏移量 $L-S+1 \\approx 3.2 \\times 10^9$。约束条件是一致的。\n\n**第 3 步：结论与行动**\n问题是有效的。它具有科学依据，定义明确且完整。将推导求解。\n\n总内存需求，表示为 $M_{\\text{total}}$，是主直接地址数组所需内存 $M_{\\text{primary}}$ 和位置数组所需内存 $M_{\\text{pos}}$ 的总和。\n$$M_{\\text{total}} = M_{\\text{primary}} + M_{\\text{pos}}$$\n\n首先，我们计算主直接地址数组的大小， $M_{\\text{primary}}$。\n该数组由所有可能的间隔种子键索引。可能的键的数量，$N_{\\text{keys}}$，由种子权重 $W$ 决定。对于一个包含 $4$ 个核苷酸的字母表和一个权重为 $W$ 的种子，不同键的数量为：\n$$N_{\\text{keys}} = 4^{W}$$\n给定 $W=12$：\n$$N_{\\text{keys}} = 4^{12} = (2^2)^{12} = 2^{24} = 16,777,216$$\n此数组中的每个条目包含两个无符号 32 位整数。一个无符号 32 位整数占用 $32$ 位，即 $\\frac{32}{8} = 4$ 字节。因此，每个条目的大小是 $2 \\times 4 = 8$ 字节。\n主数组的总大小是条目数乘以每个条目的大小：\n$$M_{\\text{primary}} = N_{\\text{keys}} \\times (\\text{一个条目的大小})$$\n$$M_{\\text{primary}} = 16,777,216 \\times 8 \\text{ 字节} = 134,217,728 \\text{ 字节}$$\n\n接下来，我们计算位置数组的大小，$M_{\\text{pos}}$。\n该数组为基因组中的每个有效窗口存储一个条目。有效窗口的数量，$N_{\\text{windows}}$，对应于长度为 $L$ 的基因组内跨度为 $S$ 的种子的可能起始位置 $t$ 的数量。起始位置的范围是从 $t=1$ 到 $t=L-S+1$。\n$$N_{\\text{windows}} = (L-S+1) - 1 + 1 = L-S+1$$\n代入给定值 $L=3.2 \\times 10^9$ 和 $S=18$：\n$$N_{\\text{windows}} = 3.2 \\times 10^9 - 18 + 1 = 3.2 \\times 10^9 - 17$$\n$$N_{\\text{windows}} = 3,200,000,000 - 17 = 3,199,999,983$$\n位置数组中的每个条目是一个无符号 32 位整数，即 $4$ 字节。\n位置数组的总大小是窗口数乘以每个条目的大小：\n$$M_{\\text{pos}} = N_{\\text{windows}} \\times (\\text{一个条目的大小})$$\n$$M_{\\text{pos}} = (3.2 \\times 10^9 - 17) \\times 4 \\text{ 字节}$$\n$$M_{\\text{pos}} = 3,199,999,983 \\times 4 \\text{ 字节} = 12,799,999,932 \\text{ 字节}$$\n\n现在，我们通过将两个数组的大小相加来计算总内存需求：\n$$M_{\\text{total}} = M_{\\text{primary}} + M_{\\text{pos}}$$\n$$M_{\\text{total}} = 134,217,728 \\text{ 字节} + 12,799,999,932 \\text{ 字节}$$\n$$M_{\\text{total}} = 12,934,217,660 \\text{ 字节}$$\n\n问题要求答案以千兆字节 (GB) 为单位，使用定义 $1 \\text{ GB} = 10^9 \\text{ 字节}$。\n$$M_{\\text{total}} (\\text{单位 GB}) = \\frac{12,934,217,660}{10^9} = 12.934217660 \\text{ GB}$$\n\n最后，我们将结果四舍五入到三位有效数字。这个数字是 $12.9342...$。前三位有效数字是 $1$、$2$ 和 $9$。第四位有效数字是 $3$，小于 $5$，所以我们向下舍入。\n$$M_{\\text{total}} (\\text{单位 GB}) \\approx 12.9$$", "answer": "$$\\boxed{12.9}$$", "id": "2441116"}, {"introduction": "单个种子可能不足以灵敏地发现所有同源序列。本练习将探讨使用多个种子的策略性设计，特别是如何创建一个能够检测到第一个种子所错过的匹配的“互补”种子 ([@problem_id:2441164])。这有助于我们理解如何通过精心设计来最大化整体搜索的灵敏度。", "problem": "您正在为脱氧核糖核酸 (DNA) 设计一种使用间隔种子的种子延伸同源性搜索。间隔种子由一个长度（跨度）为 $s$ 的模式指定，该模式由必需匹配符号和通配符组成；如果一个种子的模式中所有标记为必需匹配的位置都完全匹配，则该种子命中一个窗口。这里的字长参数 $k$ 定义为种子权重 $w$，即模式中必需匹配位置的数量。\n\n假设您的第一个种子 $S_{1}$ 的跨度 $s = 11$，权重 $w = 5$，其必需匹配位置位于索引集 $R_{1} = \\{1, 3, 5, 8, 11\\}$（为清晰起见，该模式可写作 $\\# - \\# - \\# - - \\# - - \\#$，其中 $\\#$ 表示必需匹配，$-$ 表示通配符）。您计划添加第二个种子 $S_{2}$，其跨度同样为 $s = 11$，权重为 $w = 5$，以提高灵敏度。\n\n假设一个简单的同源比对模型，其中真实同源窗口内的每个位置都以概率 $\\pi \\in (0, 1)$ 独立匹配，以概率 $1 - \\pi$ 错配，并且窗口内各位置之間是独立的。您的目标是设计 $S_{2}$ 以“补充” $S_{1}$，即它倾向于在 $S_{1}$ 因一个或多个必需匹配位置错配而错过的同源窗口中找到命中。\n\n在所述模型下，同时保持 $s$ 和 $w$ 不变，下列哪种 $S_{2}$ 的设计策略最能实现这一目标？\n\nA. 将 $S_{2}$ 的必需匹配位置完全置于 $S_{1}$ 的通配符位置内，即选择一个索引集 $R_{2} \\subseteq \\{1, 2, \\dots, 11\\} \\setminus R_{1}$ 且 $|R_{2}| = 5$，并根据需要将它们分布在整个跨度上。\n\nB. 使 $S_{2}$ 与 $S_{1}$ 相同，但在跨度内向右移动 $1$ 个位置（必要时进行环绕），这样大多数必需位置会重叠但不会完全重叠。\n\nC. 在相同的跨度 $s = 11$ 下，将 $S_{2}$ 的权重增加到 $w = 7$ 以减少假阳性，接受每个种子更少的匹配。\n\nD. 为 $S_{2}$ 使用一个连续字种子，其 $k = w = 5$（即在跨度内的任何位置有五个连续的必需匹配位置），并保持相同的跨度 $s = 11$。", "solution": "首先对问题陈述进行验证。\n\n**步驟1：提取已知信息**\n- 任务：为DNA同源性搜索设计第二个间隔种子 $S_2$，以补充第一个种子 $S_1$。\n- 间隔种子的定义：一个跨度为 $s$ 的模式，包含必需匹配位置和通配符位置。如果所有必需匹配位置都匹配，则种子命中。\n- 字长 $k$：定义为种子权重 $w$，即必需匹配位置的数量。\n- 第一个种子 $S_1$：跨度 $s = 11$，权重 $w = 5$，必需匹配位置 $R_1 = \\{1, 3, 5, 8, 11\\}$。\n- 第二个种子 $S_2$：待设计，跨度 $s = 11$，权重 $w = 5$。\n- 同源模型：每个位置以概率 $\\pi \\in (0, 1)$ 独立匹配。\n- 目标：设计 $S_2$ 以“补充” $S_1$，即它倾向于在 $S_1$ 错过的同源窗口中找到命中。\n\n**步骤2：使用提取的已知信息进行验证**\n- **科学基础**：该问题基于生物信息学中用于序列比对的成熟概念——间隔种子，这是计算生物学的核心课题。概率模型是用于理论分析的标准简化模型。\n- **良置性**：设计一个“互补”种子的目标在概率模型中得到了清晰的定义，从而可以在给定选项中确定一个唯一的最优策略。\n- **客观性**：问题陈述使用精确、技术性的语言，不含主观因素。\n- **完整性和一致性**：问题提供了设计 $S_2$ 所需的所有参数（$s$、$w$、$R_1$、$\\pi$）和约束条件。没有内部矛盾。\n- **可行性**：这些参数对于间隔种子设计是现实的。\n\n**步骤3：结论与行动**\n问题有效。将推导解决方案。\n\n**原理推导**\n\n设 $H_1$ 是种子 $S_1$ 命中一个同源窗口的事件， $H_2$ 是种子 $S_2$ 命中同一窗口的事件。问题要求我们通过设计 $S_2$ 来提高灵敏度，使其与 $S_1$ 互补。这在数学上可以解释为最大化至少有一个种子命中的概率，即 $P(H_1 \\cup H_2)$。\n\n设 $R_1$ 和 $R_2$ 分别是种子 $S_1$ 和 $S_2$ 的必需匹配位置集合。根据问题陈述，我们有 $|R_1| = w = 5$ 和 $|R_2| = w = 5$。\n在独立匹配的假设下，单个权重为 $w$ 的种子命中的概率是：\n$$ P(H_1) = \\pi^{|R_1|} = \\pi^w $$\n$$ P(H_2) = \\pi^{|R_2|} = \\pi^w $$\n\n两个种子都命中的概率是在它们必需匹配位置的并集 $R_1 \\cup R_2$ 中的所有位置都匹配的概率：\n$$ P(H_1 \\cap H_2) = \\pi^{|R_1 \\cup R_2|} $$\n使用集合大小的容斥原理，我们有 $|R_1 \\cup R_2| = |R_1| + |R_2| - |R_1 \\cap R_2| = 2w - |R_1 \\cap R_2|$。\n因此，$P(H_1 \\cap H_2) = \\pi^{2w - |R_1 \\cap R_2|}$。\n\n总体灵敏度，即至少有一次命中的概率，由以下公式给出：\n$$ P(H_1 \\cup H_2) = P(H_1) + P(H_2) - P(H_1 \\cap H_2) $$\n$$ P(H_1 \\cup H_2) = 2\\pi^w - \\pi^{2w - |R_1 \\cap R_2|} $$\n为了最大化该灵敏度，我们必须最大化函数 $f(x) = 2\\pi^w - \\pi^{2w - x}$，其中 $x = |R_1 \\cap R_2|$ 是两个种子之間重叠的必需位置数。\n由于 $2\\pi^w$ 是一个相对于 $S_2$ 设计的常数，我们需要最大化 $-\\pi^{2w - x}$，这等价于最小化项 $\\pi^{2w - x}$。\n鉴于指数的底数是 $\\pi \\in (0, 1)$，函数 $y=\\pi^z$ 是 $z$ 的严格递减函数。因此，为了最小化 $\\pi^{2w - x}$，我们必须最大化其指数 $2w - x$。\n最大化 $2w - x$ 等价于最小化 $x$，即重叠度 $|R_1 \\cap R_2|$。\n\n因此，最优策略是设计 $S_2$，使其与 $S_1$ 共享的必需匹配位置数量最小化。可能的最小重叠是 $|R_1 \\cap R_2| = 0$，这发生在必需位置集合不相交时，即 $R_1 \\cap R_2 = \\emptyset$。\n\n我们已知 $R_1 = \\{1, 3, 5, 8, 11\\}$。跨度 $s=11$ 内的位置集合是 $\\{1, 2, ..., 11\\}$。\n$S_1$ 不需要的位置（通配符位置）是 $\\{1, 2, ..., 11\\} \\setminus R_1 = \\{2, 4, 6, 7, 9, 10\\}$。这个集合包含 $6$ 个位置。\n为了实现最小重叠 $|R_1 \\cap R_2| = 0$，$S_2$ 的 $5$ 个必需位置必须从这 $6$ 个通配符位置中选择。这是一项可行的任务。\n\n**逐项分析**\n\nA. **将 $S_{2}$ 的必需匹配位置完全置于 $S_{1}$ 的通配符位置内，即选择一个索引集 $R_{2} \\subseteq \\{1, 2, \\dots, 11\\} \\setminus R_{1}$ 且 $|R_{2}| = 5$，并根据需要将它们分布在整个跨度上。**\n该策略建议从集合 $\\{2, 4, 6, 7, 9, 10\\}$ 中选择 $R_2$。由于我们需要 $|R_2| = 5$，我们可以选择，例如，$R_2 = \\{2, 4, 6, 7, 9\\}$。通过这种选择，$R_1 \\cap R_2 = \\emptyset$，所以重叠度 $|R_1 \\cap R_2| = 0$。根据我们的推导，这实现了理论上的最小重叠，从而最大化了灵敏度。\n结论：**正确**。\n\nB. **使 $S_{2}$ 与 $S_{1}$ 相同，但在跨度内向右移动 $1$ 个位置（必要时进行环绕），这样大多数必需位置会重叠但不会完全重叠。**\n初始位置集是 $R_1 = \\{1, 3, 5, 8, 11\\}$。將每个位置 $+1$ 移动，并将位置 $12$ 环绕回 $1$，得到新的集合 $R_2 = \\{2, 4, 6, 9, 1\\}$。与 $R_1$ 的重叠是 $R_1 \\cap R_2 = \\{1\\}$。因此，$|R_1 \\cap R_2| = 1$。由于 $1 > 0$，与选项 A 中的策略相比，该策略是次优的。非零重叠降低了互补性和总体灵敏度。\n结论：**不正确**。\n\nC. **在相同的跨度 $s = 11$ 下，将 $S_{2}$ 的权重增加到 $w = 7$ 以减少假阳性，接受每个种子更少的匹配。**\n该策略违反了问题的一个约束条件，即设计第二个种子 $S_2$ 时保持权重 $w$ 不变（即 $w=5$）。此外，将权重增加到 $w=7$ 会使 $S_2$ 的灵敏度降低（$P(H_2) = \\pi^7  \\pi^5 = P(H_1)$），这与通过捕获 $S_1$ 错过的命中来提高总体灵敏度的目标相矛盾。\n结论：**不正确**。\n\nD. **为 $S_{2}$ 使用一个连续字种子，其 $k = w = 5$（即在跨度内的任何位置有五个连续的必需匹配位置），并保持相同的跨度 $s = 11$。**\n一个连续种子将具有像 $R_2 = \\{i, i+1, i+2, i+3, i+4\\}$ 这样的必需位置，对于某个起始位置 $i$。我们必须检查是否有任何这样的种子可以实现零重叠。$S_1$ 的通配符区域位于索引 $\\{2\\}$, $\\{4\\}$, $\\{6, 7\\}$ 和 $\\{9, 10\\}$。最大的连续通配符块长度为 $2$。不可能在不与 $R_1 = \\{1, 3, 5, 8, 11\\}$ 中的至少一个位置重叠的情况下放置 $5$ 个连续的必需匹配位置。例如，将连续种子放置在位置 $R_2 = \\{6, 7, 8, 9, 10\\}$ 会导致重叠 $|R_1 \\cap R_2| = |\\{8\\}| = 1$。这是在这种情况下连续种子可实现的最小重叠。由于 $1$ 的重叠大于选项 A 中可实现的 $0$ 的重叠，因此该策略是次优的。\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "2441164"}]}