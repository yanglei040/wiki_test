{"hands_on_practices": [{"introduction": "第一个练习将序列掩蔽的实际操作与信息论的基本原理联系起来。你将量化当软掩蔽区域被转换为硬掩蔽区域时发生的“信息损失”。[@problem_id:2390141] 这项练习有助于巩固一个核心概念：序列中的每个核苷酸都携带特定量的信息，其大小取决于它的预期频率。这为理解在过滤过程中究竟损失了什么提供了一个定量的基础。", "problem": "给定脱氧核糖核酸（DNA）序列，其中软屏蔽区域由小写字母表示，未屏蔽位置由大写字母表示，两种情况都只使用字母表 {A, C, G, T}。序列的硬屏蔽版本通过将每个小写字符替换为大写字母 N，并保持每个大写字符 A, C, G 或 T 不变来获得。设核苷酸 A, C, G, T 的背景分布由概率 $p_A, p_C, p_G, p_T$ 指定，其中 $p_A + p_C + p_G + p_T = 1$ 且每个 $p_X \\in (0,1)$。\n\n对于长度为 $n$ 的序列 $s$，在给定的背景分布下，符号 $x \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的自信息定义为 $I(x) = -\\log_2 p_x$。将原始序列的总信息定义为\n$$\nI(s) = \\sum_{i=1}^{n} I\\big(x_i\\big),\n$$\n其中 $x_i$ 是序列 $s$ 中位置 $i$ 处字符的大写形式。将 $s$ 转换为其硬屏蔽版本所产生的信息损失（以比特为单位）定义为\n$$\nL(s) = \\sum_{i \\in \\mathcal{M}} I\\big(x_i\\big),\n$$\n其中 $\\mathcal{M}$ 是序列 $s$ 中具有小写字母的索引集合（即在硬屏蔽序列中变为 N 的位置）。换句话说，每个软屏蔽位置贡献的损失是其在给定背景模型下实际核苷酸身份的自信息。$I(\\cdot)$、$I(s)$ 和 $L(s)$ 的单位是比特。\n\n您的任务是编写一个完整的程序，对下面的每个测试用例，将提供的软屏蔽序列转换为硬屏蔽序列（通过将小写的 a, c, g, t 替换为 N），并计算信息损失 $L(s)$，以比特表示，四舍五入到小数点后恰好 $6$ 位。\n\n测试套件：\n1. 序列：\"ACgtACgt\"，背景概率：$(p_A, p_C, p_G, p_T) = (0.25, 0.25, 0.25, 0.25)$。\n2. 序列：\"aCgTaCgT\"，背景概率：$(p_A, p_C, p_G, p_T) = (0.10, 0.20, 0.30, 0.40)$。\n3. 序列：\"acgt\"，背景概率：$(p_A, p_C, p_G, p_T) = (0.25, 0.25, 0.25, 0.25)$。\n4. 序列：\"ACGTACGT\"，背景概率：$(p_A, p_C, p_G, p_T) = (0.25, 0.25, 0.25, 0.25)$。\n5. 序列：\"aaCCggTT\"，背景概率：$(p_A, p_C, p_G, p_T) = (0.70, 0.10, 0.10, 0.10)$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果与测试用例的顺序相同。列表中的每个元素都必须是等于 $L(s)$（以比特为单位）的浮点数，四舍五入到小数点后恰好 $6$ 位。例如：\"[x1,x2,x3,x4,x5]\"。", "solution": "问题陈述已经过严格验证。\n\n给定条件如下：\n1.  一组包含大写（`A`, `C`, `G`, `T`）和小写（`a`, `c`, `g`, `t`）字符的 DNA 序列。小写字母表示软屏蔽区域。\n2.  一种硬屏蔽程序，其中小写字母被替换为 `N`。\n3.  每个序列的背景概率分布 $(p_A, p_C, p_G, p_T)$，其中 $p_X \\in (0,1)$ 且 $\\sum p_X = 1$。\n4.  核苷酸 $x \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 的自信息定义为 $I(x) = -\\log_2 p_x$。\n5.  硬屏蔽时的信息损失 $L(s)$ 定义为软屏蔽区域中核苷酸的自信息之和：$L(s) = \\sum_{i \\in \\mathcal{M}} I(x_i)$，其中 $\\mathcal{M}$ 是小写字符的索引集合，$x_i$ 是索引 $i$ 处字符的大写等效形式。\n6.  一个包含五个案例的测试套件，每个案例都有一个序列和一个概率分布。\n7.  要求为每个案例计算 $L(s)$，四舍五入到六位小数，并在概念上执行硬屏蔽转换。\n\n根据所需标准对问题进行验证：\n1.  **科学依据**：该问题基于生物信息学和信息论中标准的、成熟的概念。序列屏蔽是处理重复或低复杂度区域的常用技术。应用自信息来量化屏蔽时的数据损失是信息论原理的有效和直接的应用。该问题在科学上是合理的。\n2.  **适定性**：该问题以数学精度进行了规定。所有必要的输入（序列、概率）都已提供。定义清晰明确，所需的计算也得到了清楚的描述。每个测试用例都存在唯一的解，并且可以通过算法确定。该问题是适定的。\n3.  **客观性**：该问题以形式化的、定量的术语陈述，没有任何主观性或意见。该问题是客观的。\n\n结论：问题有效。将提供一个完整且合理的解决方案。\n\n任务是计算当软屏蔽的 DNA 序列转换为硬屏蔽表示时发生的信息损失。该损失使用信息论的原理进行量化。\n\n软屏蔽序列使用小写字母来表示低复杂度或重复区域。虽然核苷酸的身份是已知的，但它被标记为对于某些分析来说不太可靠或不太重要。硬屏蔽是一个更严格的数据削减步骤，其中这些核苷酸被通用符号 `N` 替换，从而完全掩盖了它们的原始身份。信息损失是在此过程中丢弃的信息量，以比特为单位度量。\n\n基本量是核苷酸 $x$ 的自信息（或称意外度），由 $I(x) = -\\log_2 p_x$ 给出。它衡量在背景模型下观察到核苷酸 $x$ 的信息内容，其中 $x$ 以概率 $p_x$ 出现。稀有核苷酸（低 $p_x$）具有高自信息，而常见核苷酸（高 $p_x$）具有低自信息。\n\n序列 $s$ 的总信息损失，表示为 $L(s)$，是所有被软屏蔽的核苷酸的自信息之和。设 $s = s_1s_2...s_n$ 为长度为 $n$ 的序列。设 $\\mathcal{M}$ 为索引 $i$ 的集合，使得 $s_i$ 是一个小写字母。设 $x_i$ 为 $s_i$ 的大写版本。信息损失精确地为：\n$$\nL(s) = \\sum_{i \\in \\mathcal{M}} I(x_i) = \\sum_{i \\in \\mathcal{M}} (-\\log_2 p_{x_i})\n$$\n\n解决该问题的算法如下：\n1.  对于每个给定的测试用例，包含一个序列 $s$ 和一个概率图 $\\{p_A, p_C, p_G, p_T\\}$。\n2.  初始化一个变量 `total_loss` 为 $0.0$。\n3.  遍历序列 $s$ 中的每个字符 $c$。\n4.  检查 $c$ 是否为小写字母。\n5.  如果是，将 $c$ 转换为其大写等效形式 $x$。从给定的分布中找到相应的概率 $p_x$。\n6.  计算自信息 $- \\log_2 p_x$ 并将其加到 `total_loss` 中。\n7.  遍历完整个序列后，`total_loss` 的最终值就是信息损失 $L(s)$。\n8.  该值必须格式化为六位小数。\n\n作为一个说明性示例，让我们考虑测试用例 2：\n- 序列 $s = \\text{\"aCgTaCgT\"}$。\n- 背景概率：$p_A = 0.10, p_C = 0.20, p_G = 0.30, p_T = 0.40$。\n\n软屏蔽位置包含字符 `a`, `g`, `a`, `g`。相应的大写核苷酸是 `A`, `G`, `A`, `G`。信息损失是这四个核苷酸的自信息之和。\n$$\nL(s) = I(\\text{A}) + I(\\text{G}) + I(\\text{A}) + I(\\text{G}) = 2 \\cdot I(\\text{A}) + 2 \\cdot I(\\text{G})\n$$\n使用提供的概率：\n$$\nI(\\text{A}) = -\\log_2(p_A) = -\\log_2(0.10)\n$$\n$$\nI(\\text{G}) = -\\log_2(p_G) = -\\log_2(0.30)\n$$\n总损失为：\n$$\nL(s) = 2 \\cdot (-\\log_2(0.10)) + 2 \\cdot (-\\log_2(0.30))\n$$\n使用换底公式 $\\log_2(x) = \\frac{\\ln(x)}{\\ln(2)}$：\n$$\n-\\log_2(0.10) \\approx -(-3.321928) \\approx 3.321928 \\text{ 比特}\n$$\n$$\n-\\log_2(0.30) \\approx -(-1.736966) \\approx 1.736966 \\text{ 比特}\n$$\n因此，总信息损失为：\n$$\nL(s) \\approx 2 \\cdot (3.321928) + 2 \\cdot (1.736966) = 6.643856 + 3.473932 = 10.117788 \\text{ 比特}\n$$\n四舍五入到六位小数，结果是 $10.117788$。相应的硬屏蔽序列将是 `\"NCGNCNGT\"`，但最终输出只需要数值损失值。对所有测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the information loss problem for a suite of test cases.\n    For each case, it computes the information loss incurred when converting a\n    soft-masked DNA sequence to a hard-masked one.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (sequence, probability_dict)\n    test_cases = [\n        (\n            \"ACgtACgt\",\n            {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25}\n        ),\n        (\n            \"aCgTaCgT\",\n            {'A': 0.10, 'C': 0.20, 'G': 0.30, 'T': 0.40}\n        ),\n        (\n            \"acgt\",\n            {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25}\n        ),\n        (\n            \"ACGTACGT\",\n            {'A': 0.25, 'C': 0.25, 'G': 0.25, 'T': 0.25}\n        ),\n        (\n            \"aaCCggTT\",\n            {'A': 0.70, 'C': 0.10, 'G': 0.10, 'T': 0.10}\n        ),\n    ]\n\n    results = []\n    for seq, probs in test_cases:\n        information_loss = 0.0\n        \n        # This part conceptually builds the hard-masked sequence,\n        # but is not strictly needed for the final output value.\n        # hard_masked_seq_list = []\n\n        # Iterate through each character of the sequence.\n        for char in seq:\n            # Check if the character is lowercase (soft-masked).\n            if 'a' = char = 'z':\n                # This is a soft-masked position.\n                nucleotide = char.upper()\n                \n                # Get the background probability of this nucleotide.\n                p = probs[nucleotide]\n                \n                # Calculate self-information I(x) = -log2(p) and add to total loss.\n                if p > 0:\n                    information_loss -= np.log2(p)\n\n                # For hard-masking, this position becomes 'N'.\n                # hard_masked_seq_list.append('N')\n            # else:\n                # Unmasked characters remain unchanged.\n                # hard_masked_seq_list.append(char)\n        \n        # The hard-masked sequence would be: \"\".join(hard_masked_seq_list)\n        \n        results.append(f\"{information_loss:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2390141"}, {"introduction": "在信息概念的基础上，这项练习将挑战你实现著名SEG算法的一个简化版本，用于检测蛋白质序列中的低复杂度区域。你将使用一种更复杂的方法，该方法涉及滑动窗口和基于香农熵的双阈值（触发和延伸）系统。[@problem_id:2390180] 这项实践让你深入地动手理解真实世界的生物信息学工具如何比简单方法更稳定、更准确地识别低复杂度区域。", "problem": "您将实现一个简化的、自包含的 SEG（Segment）算法变体，用于检测蛋白质序列中的低复杂度区域。该实现必须基于基本原理：通过香农信息测量的局部成分变异性和滑动窗口分析。您的程序将使用固定的氨基酸字母表大小和窗口长度参数，以及一个双阈值触发-延伸机制。程序必须能够直接运行，并为提供的测试套件打印结果。\n\n基本原理和定义：\n- 将蛋白质序列视为一个字符串 $S$，该字符串基于标准氨基酸字母表 $\\mathcal{A}$，其大小为 $A = 20$。令 $|S| = L$ 表示序列的长度。\n- 对于一个固定的窗口长度 $W$，定义有效的窗口起始索引集合为 $s \\in \\{0, 1, \\dots, L - W\\}$。起始于 $s$ 的窗口覆盖索引为 $\\{s, s+1, \\dots, s+W-1\\}$ 的残基。\n- 对于每个窗口，令 $c_i(s)$ 为起始于 $s$ 的窗口中氨基酸 $i \\in \\{1,\\dots,A\\}$ 的计数。定义经验频率 $p_i(s) = c_i(s)/W$。该窗口的香农熵为\n$$\nH(s) = -\\sum_{i=1}^{A} p_i(s)\\,\\log_2 p_i(s),\n$$\n并约定 $0\\log_2 0 = 0$。此 $H(s)$ 的界限为 $0 \\le H(s) \\le \\log_2 W$，当窗口的成分变得更加单一或重复时，该值会减小。\n- 简化的 SEG 逻辑使用两个阈值：$\\tau_1$（触发）和 $\\tau_2$（延伸），且 $\\tau_1 \\le \\tau_2$。如果 $H(s) \\le \\tau_1$，则窗口索引 $s$ 是一个触发点。如果对于所有 $s \\in [a,b]$ 都有 $H(s) \\le \\tau_2$，则一个最大的连续窗口索引块 $[a,b]$ 是可延伸的。一个低复杂度区域由任何满足以下条件的最大的块 $[a,b]$ 构成：该块包含至少一个触发索引 $t \\in [a,b]$（因此 $H(t) \\le \\tau_1$），并且无法在不违反 $H \\le \\tau_2$ 的情况下向左或向右进一步延伸。\n- 将窗口映射到残基：任何连续的窗口块 $[a,b]$ 都会映射到一个单一的连续残基区间 $[r_{\\min}, r_{\\max}] = [a, b+W-1]$。被屏蔽的残基索引集是所有合格块对应区间的并集。在枚举索引之前，必须将重叠的残基区间合并为单个区间。\n\n算法任务：\n- 输入是隐式的：您的代码必须使用包含 $20$ 种标准氨基酸的固定氨基酸字母表 $\\mathcal{A}$，使用以 2 为底的对数计算 $H(s)$，并应用如上定义的双阈值触发-延伸方案。\n- 边界情况：如果 $L  W$，则没有有效的窗口，因此屏蔽集为空。如果没有 $H(s)$ 低于 $\\tau_1$，则即使某些 $H(s) \\le \\tau_2$，也不会报告任何区域。\n- 每个测试用例的输出是在合并重叠区间并对所有合格块取并集后，得到的已排序的被屏蔽残基索引列表（从零开始）。如果没有残基被屏蔽，则输出空列表。\n\n测试套件：\n使用以下固定的测试用例，每个用例由 $(S, W, \\tau_1, \\tau_2)$ 定义：\n- 测试用例 1：$S =$ \"ACDEFGHIKLMAAAAAAAAAAACDEFGHIKLM\", $W = 12$, $\\tau_1 = 1.8$, $\\tau_2 = 2.2$.\n- 测试用例 2：$S =$ \"ACDEFGHIKLMNPQRSTVWY\", $W = 12$, $\\tau_1 = 1.8$, $\\tau_2 = 2.2$.\n- 测试用例 3：$S =$ \"AAAAACCCCC\", $W = 12$, $\\tau_1 = 1.8$, $\\tau_2 = 2.2$.\n- 测试用例 4：$S =$ \"AAAAAAAAAAAACDEFGHIKLMN\", $W = 12$, $\\tau_1 = 1.8$, $\\tau_2 = 2.2$.\n- 测试用例 5：$S =$ \"ACDEFGHIKLMKKKKKKKKKKCDEFGHIKLMAAAAAAAA\", $W = 12$, $\\tau_1 = 1.8$, $\\tau_2 = 2.2$.\n\n要求与约束：\n- 在计数 $c_i(s)$ 时，仅使用大小为 $A=20$ 的标准氨基酸字母表 $\\mathcal{A}$；计数时忽略任何不在 $\\mathcal{A}$ 中的字符，但提供的序列仅使用标准氨基酸。\n- 使用以 2 为底的对数计算 $H(s)$，并使用实数算术进行计算。\n- 在构建低复杂度区域时，识别满足 $H(s) \\le \\tau_2$ 并且包含至少一个触发点 $t$（$H(t) \\le \\tau_1$）的最大的连续窗口块 $[a,b]$。每个这样的块映射到一个残基区间 $[a, b+W-1]$。合并重叠的残基区间，并将并集输出为排序的索引列表。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，每个元素本身是对应测试用例的、用方括号括起来的、以逗号分隔的被屏蔽的从零开始的索引列表，且不含任何空格。例如，如果两个测试用例产生的屏蔽索引为 $[0,1]$ 和 $[]$，则单行输出将是 \"[[0,1],[]]\"。", "solution": "我们从一个基本原理出发：局部序列复杂度可以通过香农熵来捕捉，这是信息论中一个经过充分检验的不确定性度量。对于一个大小为 $A$ 的字母表上的离散分布 $(p_1,\\dots,p_A)$，香农熵定义为\n$$\nH = -\\sum_{i=1}^{A} p_i \\log_2 p_i,\n$$\n并约定 $0\\log_2 0 = 0$。在生物序列窗口中，$p_i$ 是在该窗口内观察到的残基类型 $i$ 的经验分数。重复或成分有偏的窗口具有较低的 $H$ 值，而成分多样的窗口的 $H$ 值则会趋近于较高的值，如果最多有 $W$ 个不同的符号在一个长度为 $W$ 的窗口中均匀出现，其 $H$ 值最高可达 $\\log_2 W$。\n\nSEG 的核心机制是一个双阈值决策，用以稳定区域检测：一个较低的触发阈值 $\\tau_1$ 在窗口复杂度 $H(s)$ 足够低时开始屏蔽，而一个较高的延伸阈值 $\\tau_2$ 允许区域通过中等低复杂度的窗口进行扩展，而不会频繁地开启和关闭。这种类似迟滞的设计可以防止当局部波动发生在单一阈值附近时出现碎片化的检测。\n\n算法推导：\n1.  将序列 $S$ 表示为基于标准氨基酸字母表 $\\mathcal{A}$（$A = 20$）的字符串。令 $|S| = L$。\n2.  固定窗口长度 $W$。有效的窗口起始点为 $s \\in \\{0,1,\\dots,L-W\\}$。对于每个 $s$，计算在索引 $\\{s,\\dots,s+W-1\\}$ 范围内各氨基酸 $i \\in \\{1,\\dots,A\\}$ 的计数 $c_i(s)$。定义 $p_i(s) = c_i(s)/W$。\n3.  使用以下公式计算每个窗口的熵：\n    $$\n    H(s) = -\\sum_{i=1}^{A} p_i(s)\\log_2 p_i(s).\n    $$\n    只有 $p_i(s)  0$ 的项对结果有贡献。\n4.  识别所有最大的连续窗口索引块 $[a,b]$，使得对于所有 $s \\in [a,b]$ 都有 $H(s) \\le \\tau_2$，并且存在至少一个触发索引 $t \\in [a,b]$ 满足 $H(t) \\le \\tau_1$。“最大”意味着我们不能将 $[a,b]$ 延伸至 $[a-1,b]$ 或 $[a,b+1]$ 而不违反 $H \\le \\tau_2$ 或超出范围。\n5.  将每个窗口块 $[a,b]$ 映射到相应的残基区间 $[r_{\\min}, r_{\\max}] = [a, b + W - 1]$。这是因为窗口集合 $\\{[s, s+W-1] : s \\in [a,b]\\}$ 的并集恰好是从最小的起始点 $a$ 到最大的结束点 $b+W-1$ 的区间。形式上，对于任何 $x \\in [a, b+W-1]$，都存在一个 $s \\in [a,b]$ 使得 $x \\in [s, s+W-1]$，从而证明了集合的相等性。\n6.  合并所有合格块的重叠或相邻的残基区间，形成它们的并集。将结果集枚举为已排序的从零开始的索引列表，以获得该序列的屏蔽区域。\n7.  边界情况：如果 $L  W$，则没有有效的窗口，结果为空集。\n\n为何阈值是合适的：\n- 对于 $W = 12$，可能的最大熵受限于 $\\log_2 W \\approx 3.585$。选择 $\\tau_1 = 1.8$ 和 $\\tau_2 = 2.2$ 将触发阈值置于远低于典型高复杂度窗口的位置，而延伸阈值则允许对中等变异性有一定的容忍度。由一两种残基主导的窗口的 $H(s)$ 值将轻松低于 $\\tau_1$，确保了可靠的触发。而包含许多不同残基的窗口的 $H(s)$ 值将高于 $\\tau_2$，防止了错误的延伸。\n\n计算考量：\n- 一个朴素的逐窗口计数方法是每个窗口 $\\mathcal{O}(A W)$，在整个序列上产生 $\\mathcal{O}(A W (L-W+1))$ 的复杂度。对于所提供的小型测试用例，这种方法高效且清晰。通过滑动更新进行优化是可能的，但不是必需的。\n- 区间合并可以在 $\\mathcal{O}(K \\log K)$ 时间内实现，其中 $K$ 是区间数量，在此处该值很小。\n\n应用于测试套件：\n- 测试用例 1 包含一个内部包含许多 A 残基的片段；跨越此片段的窗口具有较低的 $H(s)$ 并满足 $H(s) \\le \\tau_1$，触发了屏蔽和延伸，直到在侧翼处 $H(s)  \\tau_2$，从而在序列内部产生一个连续的屏蔽段。\n- 测试用例 2 广泛地分布着不同的氨基酸；窗口中的熵接近 $\\log_2 12$，超过了 $\\tau_2$，因此没有窗口满足触发条件，结果为空。\n- 测试用例 3 中 $L  W$，因此不存在窗口，结果为空。\n- 测试用例 4 在起始处放置了一个低复杂度区域；最早的几个窗口具有非常低的 $H(s)$ 并触发了屏蔽，然后随着 $H(s)$ 增加，延伸停止。\n- 测试用例 5 包含两个分离的低复杂度片段（一个 K 残基的片段和一个 A 残基的片段），在合并每个片段内的窗口后，产生两个屏蔽区间。\n\n最终程序为每个窗口计算 $H(s)$，通过双阈值机制识别块，将其映射到残基区间，合并重叠部分，并为每个测试用例打印被屏蔽的索引列表。输出是单行字符串，表示所有测试用例的嵌套列表，不含任何空格，如规范所述。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom typing import List, Tuple\n\nAA_ALPHABET = \"ACDEFGHIKLMNPQRSTVWY\"\nAA_INDEX = {aa: i for i, aa in enumerate(AA_ALPHABET)}\nA = 20  # size of amino acid alphabet\n\ndef shannon_entropy_window(window: str, W: int) - float:\n    # Count only standard amino acids\n    counts = [0] * A\n    for ch in window:\n        idx = AA_INDEX.get(ch, None)\n        if idx is not None:\n            counts[idx] += 1\n    H = 0.0\n    for c in counts:\n        if c > 0:\n            p = c / W\n            H -= p * math.log2(p)\n    return H\n\ndef compute_window_entropies(S: str, W: int) - List[float]:\n    L = len(S)\n    if L  W:\n        return []\n    Hs = []\n    for s in range(L - W + 1):\n        win = S[s:s+W]\n        Hs.append(shannon_entropy_window(win, W))\n    return Hs\n\ndef find_blocks(Hs: List[float], tau1: float, tau2: float) - List[Tuple[int, int]]:\n    blocks = []\n    n = len(Hs)\n    s = 0\n    while s  n:\n        if Hs[s] = tau2:\n            a = s\n            has_trigger = (Hs[s] = tau1)\n            s += 1\n            while s  n and Hs[s] = tau2:\n                if Hs[s] = tau1:\n                    has_trigger = True\n                s += 1\n            b = s - 1\n            if has_trigger:\n                blocks.append((a, b))\n        else:\n            s += 1\n    return blocks\n\ndef merge_intervals(intervals: List[Tuple[int, int]]) - List[Tuple[int, int]]:\n    if not intervals:\n        return []\n    intervals.sort()\n    merged = [intervals[0]]\n    for start, end in intervals[1:]:\n        last_start, last_end = merged[-1]\n        if start = last_end + 1:\n            merged[-1] = (last_start, max(last_end, end))\n        else:\n            merged.append((start, end))\n    return merged\n\ndef blocks_to_residue_intervals(blocks: List[Tuple[int, int]], W: int) - List[Tuple[int, int]]:\n    # Each window-block [a,b] maps to residue interval [a, b+W-1]\n    res_intervals = [(a, b + W - 1) for (a, b) in blocks]\n    return merge_intervals(res_intervals)\n\ndef intervals_to_indices(intervals: List[Tuple[int, int]]) - List[int]:\n    indices = []\n    for a, b in intervals:\n        indices.extend(range(a, b + 1))\n    return indices\n\ndef seg_mask_indices(S: str, W: int, tau1: float, tau2: float) - List[int]:\n    L = len(S)\n    if L  W:\n        return []\n    Hs = compute_window_entropies(S, W)\n    blocks = find_blocks(Hs, tau1, tau2)\n    residue_intervals = blocks_to_residue_intervals(blocks, W)\n    indices = intervals_to_indices(residue_intervals)\n    return indices\n\ndef serialize_no_spaces(obj) - str:\n    # Serialize lists of ints (possibly nested) with no spaces\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(serialize_no_spaces(x) for x in obj) + \"]\"\n    elif isinstance(obj, bool):\n        return \"true\" if obj else \"false\"\n    elif isinstance(obj, (int, float)):\n        # For floats, ensure a consistent representation (not used here)\n        return str(obj)\n    else:\n        # Fallback for other simple types\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each case: (S, W, tau1, tau2)\n        (\"ACDEFGHIKLMAAAAAAAAAAACDEFGHIKLM\", 12, 1.8, 2.2),\n        (\"ACDEFGHIKLMNPQRSTVWY\", 12, 1.8, 2.2),\n        (\"AAAAACCCCC\", 12, 1.8, 2.2),\n        (\"AAAAAAAAAAAACDEFGHIKLMN\", 12, 1.8, 2.2),\n        (\"ACDEFGHIKLMKKKKKKKKKKCDEFGHIKLMAAAAAAAA\", 12, 1.8, 2.2),\n    ]\n\n    results = []\n    for S, W, tau1, tau2 in test_cases:\n        masked = seg_mask_indices(S, W, tau1, tau2)\n        results.append(masked)\n\n    # Final print statement in the exact required format (no spaces).\n    print(serialize_no_spaces(results))\n\nsolve()\n```", "id": "2390180"}, {"introduction": "在实现了一个低复杂度区域检测器之后，理解其在更宏大的分析流程中的策略性应用至关重要。这个问题提出了一个在序列相似性搜索中常见的场景，并要求你评估处理一个完全由低复杂度区域组成的序列的最佳策略。[@problem_id:2390181] 这项练习将磨练你的批判性思维，让你能更好地权衡在维持统计严谨性和保留潜在关键生物信息之间的利弊。", "problem": "一个提交到通用序列相似性流程的蛋白质序列完全是一个低复杂性区域（Low-Complexity Region (LCR)），例如一个纯粹的、无中断的多聚谷氨酰胺序列。该流程在索引和搜索之前应用一个低复杂性过滤器来控制假阳性。对于这样一个完全由LCR组成的序列，哪种处理策略最合适，既能在相似性搜索中保持统计严谨性，又不会丢弃可能用于其他分析的相关生物学信息？\n\nA. 对整个序列进行硬屏蔽（hard-mask），用 $X$ 替换所有残基，并将其从所有相似性搜索和所有下游分析中排除，因为它没有信息含量。\n\nB. 不应用任何屏蔽，因为屏蔽会移除可能具有功能的重复内容；在搜索的所有阶段都像对待任何其他序列一样对待该序列。\n\nC. 应用软屏蔽（soft-masking），使得完全由LCR组成的序列在通用相似性搜索中不能启动种子（seed），并明确地将其标记为“完全低复杂性”，以便为LCR设计的专门工具可以在未屏蔽的序列上操作，但通用的种子生成和数据库索引则将其视为已屏蔽。\n\nD. 只屏蔽每隔一个的残基，以减少成分偏好，同时保留一半的位点用于种子生成。\n\nE. 将序列压缩为单个代表性的 $k$-mer 来概括重复序列，并仅索引该代表，以实现公平评分。", "solution": "对提出的问题陈述进行验证。\n\n**步骤1：提取已知条件**\n\n*   **输入序列：** 一个完全是低复杂性区域（LCR）的蛋白质序列。例如：一个纯粹的多聚谷氨酰胺序列。\n*   **过程：** 该序列被提交到一个通用的序列相似性流程。\n*   **流程特点：** 该流程在索引和搜索之前应用一个低复杂性过滤器。\n*   **过滤器目的：** 控制假阳性。\n*   **解决方案所需属性：** 处理策略必须同时实现两个目标：\n    1.  在相似性搜索中保持统计严谨性。\n    2.  不丢弃可能用于其他分析的相关生物学信息。\n\n**步骤2：使用提取的已知条件进行验证**\n\n这个问题具有科学依据。低复杂性区域是分子生物学和生物信息学中一个被充分理解的现象。它们的偏好性成分对序列比对的统计学构成了重大挑战，正如像BLAST（基础局部比对搜索工具）这样的算法所例证的。由于成分偏好而产生统计上伪高分比对的问题是真实存在的，并且是进行LCR过滤的主要动机。关于LCR也可能包含“可能相关的生物学信息”的说法也是正确的；例如，多聚谷氨酰胺序列的扩张是几种神经退行性疾病的致病原因，这使得它们的长度和背景至关重要。\n\n这个问题提得很好。它要求从一组选项中选择最合适的策略，并根据该领域清晰和标准的准则进行判断：统计有效性和信息保存。所使用的术语（屏蔽、种子生成、索引、假阳性）在计算生物学中是标准的。\n\n**步骤3：结论和行动**\n\n问题陈述是有效的。这是一个关于生物信息学中标准程序的、提得很好且科学上合理的 问题。我将进行全面的推导和分析。\n\n**原理推导**\n\n这个问题的核心在于序列相似性分数的统计基础。例如，由BLAST计算的期望值（E-value）量化了在搜索特定大小的数据库时，偶然出现具有给定分数的比对的数量。这些统计数据依赖于一个假设，即序列（查询序列和数据库序列）可以被建模为随机序列，其中的氨基酸是从特定的概率分布（例如，Robinson-Robinson频率）中抽取的。\n\n低复杂性区域灾难性地违反了这一假设。像 `QQQQQQQQQQQQQQQQQQQQ` 这样的序列具有最大程度的偏好性成分。当将其与数据库进行比对时，它会与任何其他同样含有富含谷氨酰胺区域的序列产生极高的分数，这不一定是因为共同的祖先（同源性），而仅仅是由于其重复性和偏好性成分。这导致了大量的高分片段对（HSPs），这些HSPs在生物学上是无意义的，但在一个朴素的模型下统计上是显著的，从而淹没了真实的、较弱的同源性。这些就是问题中提到的“假阳性”。\n\n为了保持统计严谨性，必须阻止LCR启动比对。在现代搜索算法中，比对从短的、完全或几乎完全匹配的词（称为“种子”）开始。标准方法是对查询和/或数据库中的LCR进行“屏蔽”，这意味着在初始的种子生成阶段会忽略这些区域。\n\n然而，LCR可能具有功能。一个多聚丙氨酸序列可能形成一个跨膜结构域，而一个多聚谷氨酰胺序列在一些转录因子中是功能性的反式激活域。完全切除这些信息是不可接受的。\n\n因此，理想的策略必须：\n1.  阻止LCR形成种子。\n2.  允许在非LCR区域产生种子的比对延伸*进入*LCR区域，并使用真实的序列来计算延伸部分的分数。\n3.  为其他可能专门关注LCR属性（例如，重复计数、功能域注释）的分析类型保留原始的、未屏蔽的序列。\n\n这套要求恰好被“软屏蔽”的概念所满足。\n\n**逐项分析**\n\n**A. 对整个序列进行硬屏蔽（hard-mask），用 $X$ 替换所有残基，并将其从所有相似性搜索和所有下游分析中排除，因为它没有信息含量。**\n该策略涉及用占位符符号（如 $X$）替换每个氨基酸。这被称为“硬屏蔽”。虽然这能有效防止序列产生任何匹配，从而控制假阳性，但它在两个关键点上失败了。首先，断言LCR“没有信息含量”是根本不正确的。LCR的长度、成分和位置通常具有生物学意义。其次，将序列从“所有下游分析”中排除，直接违反了问题中不丢弃可能相关生物学信息的要求。\n**结论：不正确。**\n\n**B. 不应用任何屏蔽，因为屏蔽会移除可能具有功能的重复内容；在搜索的所有阶段都像对待任何其他序列一样对待该序列。**\n该策略建议忽略成分偏好的问题。如果一个完全由LCR组成的序列在不进行屏蔽的情况下用作查询，它将产生大量的统计上虚假的比对，使得搜索结果无法用于发现真正的同源物。其提供的理由——即屏蔽会移除功能性内容——是对现代屏蔽技术目的和功能的误解。主要目标是纠正一个统计上的假象，而不是宣布该区域在生物学上不相关。这种方法完全未能保持统计严谨性。\n**结论：不正确。**\n\n**C. 应用软屏蔽（soft-masking），使得完全由LCR组成的序列在通用相似性搜索中不能启动种子（seed），并明确地将其标记为“完全低复杂性”，以便为LCR设计的专门工具可以在未屏蔽的序列上操作，但通用的种子生成和数据库索引则将其视为已屏蔽。**\n该策略描述了带有正确数据处理的“软屏蔽”。在软屏蔽中（例如，用小写字母表示被屏蔽的残基），被过滤的区域在种子寻找阶段被忽略。对于一个完全由LCR组成的序列，这意味着序列本身不会产生任何种子，从而正确地防止它启动虚假的比对。关键是，原始序列信息被保留了下来。如果一个在其他地方启动的比对延伸到软屏蔽区域，仍然可以计算比对分数（尽管这不适用于一个完全是LCR的*查询*，但这是软屏蔽的一般原则）。将序列标记为“完全低复杂性”并为专门工具保留原始序列，完美地满足了为其他分析保留生物学信息的要求。该策略展示了对所涉权衡的复杂而正确的理解。它在保持通用搜索的统计严谨性的同时，也保留了原始数据的完整性。\n**结论：正确。**\n\n**D. 只屏蔽每隔一个的残基，以减少成分偏好，同时保留一半的位点用于种子生成。**\n这是一个武断且无原则的方法。虽然它可能会稍微改变序列的成分，但一个由谷氨酰胺和 $X$ 交替组成的序列（例如，$QXQXQX...$）仍然是极度低复杂性和成分偏好的。它没有解决统计学上的问题。由剩余残基形成的种子仍然会高度重复并导致虚假的匹配。在序列比对的统计学中，没有任何理论基础表明这是一种有效控制假阳性的方法。这是一个毫无意义的折衷方案。\n**结论：不正确。**\n\n**E. 将序列压缩为单个代表性的 $k$-mer 来概括重复序列，并仅索引该代表，以实现公平评分。**\n该策略提出了一种严重且有损的数据转换。对于一个长度为 $N=100$ 的多聚谷氨酰胺序列，将其压缩为单个 $k$-mer（例如，当 $k=3$ 时为 $QQQ$）会丢弃最关键的信息：重复长度 $N$。用单个 $k$-mer 进行搜索不再是序列比对，而是一个简单的模式搜索，并且完全不清楚这在序列同源性的背景下如何能实现“公平评分”。这种方法丢弃了太多的信息，并从根本上改变了分析的性质。它未能满足保存生物学信息的要求。\n**结论：不正确。**", "answer": "$$\\boxed{C}$$", "id": "2390181"}]}