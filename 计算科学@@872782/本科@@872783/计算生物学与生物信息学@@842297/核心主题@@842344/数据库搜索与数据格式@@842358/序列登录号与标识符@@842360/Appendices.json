{"hands_on_practices": [{"introduction": "在理想情况下，所有数据都是完美的，但现实世界中的数据往往充满瑕疵，例如手动转录时产生的拼写错误（如将 '0' 误记为 'O'）。这项练习将引导您超越精确匹配的范畴，进入容错识别的领域。您将学习并实现一个基于自定义编辑距离的“模糊搜索”算法，该算法能够根据视觉上的相似性为不同类型的错误分配不同成本，从而即便在查询字符串存在错误时，也能智能地从候选列表中找到最可能的正确标识符。[@problem_id:2428373]", "problem": "创建一个程序，为若干可能包含转录错误的查询字符串，从一个固定的候选集中选出最合理的标准序列登录标识符。在此设定中，登录标识符是一个由大写字母、数字以及下划线和句点符号组成的字母表上的有限字符串。设有序候选集表示为 $S = (s_0, s_1, \\dots, s_{n-1})$，查询集表示为 $Q = (q_0, q_1, \\dots, q_{m-1})$。\n\n定义一个视觉上易混淆的对称字符对集合 $H$ 为\n$$\nH = \\{(O,0),(I,1),(l,1),(S,5),(Z,2),(B,8),(G,6)\\},\n$$\n这些被解释为无序对，因此当且仅当 $(b,a) \\in H$ 时，$(a,b) \\in H$。\n\n定义替换成本函数 $c: \\Sigma \\times \\Sigma \\to \\mathbb{R}_{\\ge 0}$ 为\n$$\nc(x,y) = \\begin{cases}\n0  \\text{若 } x=y,\\\\\n\\frac{1}{2}  \\text{若 } \\{x,y\\} \\in H,\\\\\n1  \\text{其他情况。}\n\\end{cases}\n$$\n定义两个字符串 $q$ 和 $s$ 之间的差异度 $d(q,s)$ 为，将 $q$ 转换为 $s$ 的所有单字符插入、删除和替换操作序列中的最小总成本，其中每次插入的成本为 $1$，每次删除的成本为 $1$，字符 $x$ 替换为 $y$ 的成本为 $c(x,y)$。对于任何 $q$，定义所选索引 $\\operatorname{idx}(q)$ 如下。对所有 $i \\in \\{0,1,\\dots,n-1\\}$ 计算 $d(q,s_i)$，找到最小值 $d_{\\min}(q) = \\min_i d(q,s_i)$，并令 $I(q)$ 为达到该最小值的索引集合，\n$$\nI(q) = \\{\\, i \\mid d(q,s_i) = d_{\\min}(q) \\,\\}.\n$$\n固定容忍阈值 $T=2$。如果 $d_{\\min}(q) \\le T$，则将 $\\operatorname{idx}(q)$ 设置为 $I(q)$ 中的最小索引（即 $I(q)$ 中没有比它更小的索引的那个唯一索引 $i$），否则将 $\\operatorname{idx}(q)$ 设置为 $-1$。\n\n使用以下长度为 $n=10$ 的有序候选集 $S$（索引从0开始）：\n- $s_0 = \\text{NM\\_000546.6}$\n- $s_1 = \\text{NP\\_000537.3}$\n- $s_2 = \\text{NC\\_000001.11}$\n- $s_3 = \\text{AY123456}$\n- $s_4 = \\text{ABO123456}$\n- $s_5 = \\text{GCF\\_000001405.39}$\n- $s_6 = \\text{ENST00000335137.4}$\n- $s_7 = \\text{XM\\_021893495.1}$\n- $s_8 = \\text{LRG\\_199}$\n- $s_9 = \\text{ENST00000335137.5}$\n\n在以下 $m=9$ 个查询字符串上评估您的程序：\n- $q_0 = \\text{AY123456}$\n- $q_1 = \\text{AB0123456}$\n- $q_2 = \\text{NM\\_000546.7}$\n- $q_3 = \\text{NC\\_00001.11}$\n- $q_4 = \\text{XM021893495.1}$\n- $q_5 = \\text{ENST00000335137.6}$\n- $q_6 = \\text{XYZ123}$\n- $q_7 = \\text{LRG\\_I99}$\n- $q_8 = \\text{NM0005466}$\n\n您的程序必须为每个 $j \\in \\{0,1,\\dots,8\\}$ 计算 $\\operatorname{idx}(q_j)$，并生成单行输出，其中包含一个用逗号分隔并用方括号括起来的整数列表（例如，$[\\dots]$）。整个测试套件的最终输出是列表\n$$\n\\bigl[\\operatorname{idx}(q_0),\\operatorname{idx}(q_1),\\dots,\\operatorname{idx}(q_8)\\bigr].\n$$\n不涉及物理单位。不涉及角度。所有比率（如有）必须表示为实数，而不是百分比。每个测试用例唯一允许的输出是如上所述的整数。", "solution": "所提出的问题在科学上是合理的、定义明确的，并包含了确定性解所需的所有必要信息。这是一个应用字符串学（计算机科学的一个子领域）中的问题，在生物信息学中有直接应用。因此，我们可以直接着手构建解决方案。\n\n核心任务是为每个查询字符串 $q$，从给定的候选集 $S$ 中识别出最合理的标准登录标识符 $s_i$。选择基于差异度分数 $d(q,s)$ 和一个阈值标准。\n\n差异度 $d(q,s)$ 被定义为一种广义编辑距离，具体来说是带有自定义替换成本的 Levenshtein 距离。将字符串 $q$ 转换为字符串 $s$ 的成本是一系列基本操作（插入、删除和替换）的最小成本总和。\n成本定义如下：\n-   单个字符的删除：成本为 $1$。\n-   单个字符的插入：成本为 $1$。\n-   字符 $x$ 替换为字符 $y$：成本由函数 $c(x,y)$ 给出。\n\n替换成本函数 $c(x,y)$ 指定为：\n$$\nc(x,y) = \\begin{cases}\n0  \\text{若 } x=y,\\\\\n\\frac{1}{2}  \\text{若 } \\{x,y\\} \\in H,\\\\\n1  \\text{其他情况。}\n\\end{cases}\n$$\n视觉上易混淆的字符对集合 $H$ 由 $H = \\{(O,0),(I,1),(l,1),(S,5),(Z,2),(B,8),(G,6)\\}$ 给出。值得注意的是，问题将标准标识符的字母表定义为由大写字母、数字以及符号 `_` 和 `.` 组成。包含小写字母的字符对 $(l,1)$ 是对替换成本函数定义域的形式扩展。由于所提供的查询字符串不包含小写字母，这个特定的字符对不会影响给定数据的输出结果，但一个鲁棒的实现必须正确解析此定义。\n\n差异度 $d(q, s)$ 的计算是一个经典的动态规划问题，可以使用 Wagner-Fischer 算法高效求解。设 $q$ 是长度为 $m$ 的字符串，$s$ 是长度为 $n$ 的字符串。我们构建一个大小为 $(m+1) \\times (n+1)$ 的矩阵 $D$，其中 $D_{i,j}$ 存储将前缀 $q[1\\dots i]$ 转换为前缀 $s[1\\dots j]$ 的最小成本。该矩阵根据以下递推关系填充：\n\n初始化：\n-   $D_{i,0} = i$，对于 $i \\in [0, m]$（从 $q$ 中删除 $i$ 个字符的成本）。\n-   $D_{0,j} = j$，对于 $j \\in [0, n]$（插入 $j$ 个字符以形成 $s$ 的成本）。\n\n对于 $i > 0$ 和 $j > 0$ 的递推关系：\n$$\nD_{i,j} = \\min \\begin{cases}\nD_{i-1,j} + 1  \\text{(删除 } q_i\\text{)}\\\\\nD_{i,j-1} + 1  \\text{(插入 } s_j\\text{)}\\\\\nD_{i-1,j-1} + c(q_i, s_j)  \\text{(替换 } q_i \\text{ 为 } s_j\\text{)}\n\\end{cases}\n$$\n最终的差异度 $d(q,s)$ 由值 $D_{m,n}$ 给出。\n\n对于每个查询字符串 $q_j \\in Q$，选择过程如下：\n$1$. 对所有候选字符串 $s_i \\in S$（其中 $i \\in \\{0, 1, \\dots, n-1\\}$），计算差异度 $d(q_j, s_i)$。\n$2$. 确定最小差异度，$d_{\\min}(q_j) = \\min_{i} d(q_j, s_i)$。\n$3$. 识别达到此最小值的索引集合：$I(q_j) = \\{\\, k \\mid d(q_j, s_k) = d_{\\min}(q_j) \\,\\}$。\n$4$. 应用阈值和决胜规则。给定阈值 $T=2$：\n    - 如果 $d_{\\min}(q_j) \\le T$，所选索引为 $\\operatorname{idx}(q_j) = \\min(I(q_j))$。通过在产生最小距离的索引中选择最小的索引来打破平局。\n    - 如果 $d_{\\min}(q_j) > T$，则未找到合适的候选者，索引被设置为 $\\operatorname{idx}(q_j) = -1$。\n\n这个完整、明确的过程为每个查询字符串实现。将得到的索引收集到一个列表中，形成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sequence identifier matching problem.\n    \"\"\"\n    \n    # Define the candidate set S as specified in the problem statement.\n    s_candidates = [\n        \"NM_000546.6\",       # s0\n        \"NP_000537.3\",       # s1\n        \"NC_000001.11\",      # s2\n        \"AY123456\",          # s3\n        \"ABO123456\",         # s4\n        \"GCF_000001405.39\",  # s5\n        \"ENST00000335137.4\", # s6\n        \"XM_021893495.1\",    # s7\n        \"LRG_199\",           # s8\n        \"ENST00000335137.5\"  # s9\n    ]\n\n    # Define the query set Q as specified in the problem statement.\n    q_queries = [\n        \"AY123456\",          # q0\n        \"AB0123456\",         # q1\n        \"NM_000546.7\",       # q2\n        \"NC_00001.11\",       # q3\n        \"XM021893495.1\",     # q4\n        \"ENST00000335137.6\", # q5\n        \"XYZ123\",            # q6\n        \"LRG_I99\",           # q7\n        \"NM0005466\"          # q8\n    ]\n\n    # Define the set H of visually confusable character pairs.\n    # We use a set of frozensets for efficient, order-independent lookup.\n    H = {\n        frozenset({'O', '0'}), frozenset({'I', '1'}), frozenset({'l', '1'}),\n        frozenset({'S', '5'}), frozenset({'Z', '2'}), frozenset({'B', '8'}),\n        frozenset({'G', '6'})\n    }\n\n    # Define the tolerance threshold T.\n    T = 2.0\n\n    def substitution_cost(c1, c2):\n        \"\"\"\n        Calculates the substitution cost c(x, y) based on the problem definition.\n        \"\"\"\n        if c1 == c2:\n            return 0.0\n        if frozenset({c1, c2}) in H:\n            return 0.5\n        return 1.0\n\n    def dissimilarity(q_str, s_str):\n        \"\"\"\n        Calculates the dissimilarity d(q, s) using the Wagner-Fischer algorithm\n        with custom substitution costs.\n        \"\"\"\n        m, n = len(q_str), len(s_str)\n        \n        # Initialize the DP matrix using numpy for efficiency.\n        dp = np.zeros((m + 1, n + 1))\n\n        # Initialize first row and column (insertion/deletion costs).\n        for i in range(m + 1):\n            dp[i, 0] = i\n        for j in range(n + 1):\n            dp[0, j] = j\n\n        # Fill the DP matrix using the recurrence relation.\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                cost = substitution_cost(q_str[i-1], s_str[j-1])\n                dp[i, j] = min(dp[i-1, j] + 1,        # Deletion\n                               dp[i, j-1] + 1,        # Insertion\n                               dp[i-1, j-1] + cost)   # Substitution/Match\n        \n        return dp[m, n]\n\n    results = []\n    for q_str in q_queries:\n        distances = [dissimilarity(q_str, s_str) for s_str in s_candidates]\n        \n        d_min = min(distances)\n        \n        if d_min = T:\n            # Find the smallest index i where d(q, s_i) == d_min.\n            # The problem guarantees I(q) is non-empty here.\n            # We iterate to find the first such index, which is the minimum.\n            best_idx = -1\n            for i, dist in enumerate(distances):\n                if dist == d_min:\n                    best_idx = i\n                    break\n            results.append(best_idx)\n        else:\n            results.append(-1)\n            \n    # Format the final output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2428373"}, {"introduction": "在生物信息学中，同一个生物实体（如一个特定的蛋白质）可能被多种标识符所指代，包括基因符号、已弃用的旧版ID以及来自不同数据库的登录号，它们共同构成了一个复杂的标识符网络。这项综合性练习模拟了一项关键的数据整合任务：构建一个解析器，将这些多样化的输入映射到一个统一的、现代的规范序列上。通过实现一个分步的、有优先级的解析逻辑，您将能深刻理解在构建复杂生物信息学流程时，处理标识符异构性和版本迭代的重要性。[@problem_id:2428399]", "problem": "您将获得一个有限的、自包含的注册表，该注册表模拟了在主流序列数据库使用的现实约定下，遗留的生物标识符如何映射到现代的规范蛋白质序列。您的任务是实现一个程序，对于每个输入令牌，将其解析为现代规范蛋白质序列，然后报告一个可量化的结果以供验证。\n\n基础和定义：\n- 分子生物学的中心法则指出，脱氧核糖核酸（DNA）被转录为核糖核酸（RNA），后者被翻译为蛋白质。在经过整理的数据库中，蛋白质表示为固定字母表（标准的二十种氨基酸）上的氨基酸序列，可以视为有限集合上的字符串。\n- 登录号标识符作为稳定的引用。在参考序列（RefSeq）系统中，像 NP_abcdef 这样的登录号与一个版本号 $v \\in \\mathbb{N}$ 配对，写作 NP_abcdef.$v$。其不变性在于，根部分 NP_abcdef 对于记录是稳定的，而当底层序列发生变化时，版本号 $v$ 会递增；因此，从一个根登录号到蛋白质概念的映射是版本无关的。\n- 来自国家生物技术信息中心（NCBI）的 GenInfo 标识符（GI）号是已弃用的遗留标识符，它们确定性地映射到带特定版本的 RefSeq 登录号。因此，一个 GI 号通过去除版本，引出一个到 RefSeq 根的映射。\n- 通用蛋白质资源（UniProt）登录号包括一个主登录号和可能的一个或多个次级登录号。次级登录号与单个主登录号双射，并为向后兼容而保留。\n- 在 UniProt 中，异构体由“-i”形式的后缀表示，其中 $i \\in \\mathbb{N}$。我们采用的规范异构体约定是：如果一个主登录号存在异构体“-1”，则它就是规范异构体；否则，规范异构体是注册表中存在的具有最小异构体索引的那个。\n\n您的程序必须实现这些规则，以将每个查询解析为所提供注册表中的一个唯一的、规范的蛋白质序列，不使用任何外部资源。为了产生可数值验证的输出，对于每个解析出的序列，计算其长度 $L \\in \\mathbb{N}$ 及其无符号 $64$ 位 FNV-1a 哈希值 $H \\in \\{0,1,\\dots,2^{64}-1\\}$。该哈希值是对序列以美国信息交换标准代码（ASCII）字节编码计算的，使用偏移基数 $1469598103934665603$ 和素数 $1099511628211$。FNV-1a 递推关系如下：\n- 初始化 $h \\leftarrow 1469598103934665603$。\n- 对于序列的每个字节 $b$：$h \\leftarrow (h \\oplus b) \\times 1099511628211 \\mod 2^{64}$。\n- 最终的 $h$ 即为 $H$。\n\n注册表：\n- 主 UniProt 登录号和异构体序列（键为“ACC-isoformIndex”）：\n  - P04637-1: MEEPQSDPSVEPPLSQETFSDLWKLL\n  - P04637-2: MEEPQSDPSVEPPLSQETFSDLWKL\n  - P38398-1: MDLSALRVEEVQNVINAMQKILECPICLE\n  - P01106-1: MPLNVSFTNRNYDLDYDSVQPY\n  - P01106-2: MPLNVSFTNRNYDLDYDSVQP\n  - Q9Y243-1: MSSILPFTPPVKRLLGWKHPGKQL\n- 次级 UniProt 到主登录号的映射：\n  - Q13616 → P04637\n  - Q65484 → P38398\n  - P12524 → P01106\n  - O15162 → Q9Y243\n- RefSeq 根到主 UniProt 登录号的映射：\n  - NP_000537 → P04637\n  - NP_009225 → P38398\n  - NP_002458 → P01106\n  - NP_123456 → Q9Y243\n- GenInfo 标识符（GI）到带版本的 RefSeq 登录号的映射：\n  - gi|4557321 → NP_000537.2\n  - gi|8404561 → NP_009225.1\n  - gi|3154298 → NP_002458.1\n  - gi|15726711 → NP_123456.1\n- 基因符号和同义词到主 UniProt 登录号的映射（不区分大小写）：\n  - TP53, P53, TRP53 → P04637\n  - BRCA1, BRCC1 → P38398\n  - MYC, C-MYC → P01106\n  - SMAD7, MADH7 → Q9Y243\n\n要实现的解析逻辑：\n- 设输入令牌为字符串 $t$。通过修剪空白字符来规范化 $t$。\n- 按以下优先级识别令牌类型：\n  1. 如果 $t$ 匹配 GI 模式 “gi|d”，其中 d 是非空数字序列，则通过 GI 表将其映射到带版本的 RefSeq 登录号，然后去掉版本以获得 RefSeq 根，再将该根映射到主 UniProt 登录号。\n  2. 否则，如果 $t$ 匹配 “NP_digits.version” 形式的 RefSeq 模式，则将 RefSeq 根（点之前的部分）映射到主 UniProt 登录号。\n  3. 否则，如果 $t$ 匹配带有异构体后缀“-i”的类 UniProt 模式：将其基础登录号映射到主登录号（如果它是次级登录号，则首先将次级映射到主登录号），然后按照上述定义为该主登录号选择规范异构体。\n  4. 否则，如果 $t$ 匹配不带异构体后缀的类 UniProt 登录号：如果它是次级登录号，则映射到主登录号；如果它已经是主登录号，则按原样使用。\n  5. 否则，将 $t$ 视为基因符号或同义词；不区分大小写地映射到主登录号。\n- 在获得主登录号后，为该主登录号选择规范异构体，规则如下：如果存在 “ACC-1”，则选择它；否则，选择注册表键中存在的具有最小 $i$ 的异构体 “ACC-i”。\n- 如果在任何阶段映射失败（缺少键），则该测试用例的结果为“not found”。\n\n可量化的输出：\n- 对于每个输入令牌，输出以下任一内容：\n  - 一个双元素列表 $[L,H]$，其中 $L$ 是整数序列长度，$H$ 是以 10 为基数的无符号 64 位 FNV-1a 哈希值，或者\n  - 如果令牌无法解析到任何注册表条目，则为双元素列表 $[-1,-1]$。\n\n测试套件：\n- 按顺序使用以下输入令牌：\n  - \"TP53\"\n  - \"Q65484\"\n  - \"NP_002458.1\"\n  - \"gi|15726711\"\n  - \"P04637-2\"\n  - \"p53\"\n  - \"gi|99999999\"\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为一个逗号分隔的双元素列表的列表，并用方括号括起来（例如，“[[L1,H1],[L2,H2],...]”，其中每个 $L_i$ 和 $H_i$ 都是以 10 为基数的整数）。不应打印额外的空白或文本。", "solution": "提供的问题陈述已经过严格评估，并被认为是有效的。它在科学上基于生物信息学和分子生物学的原理，问题定义良好，具有确定性的解析逻辑，并使用客观、明确的语言表达。任务是基于一个已定义的、自包含的注册表和一套明确的规则，实现一个生物标识符的解析算法。我们现在将进行正式的解决方案。\n\n该解决方案分为三个主要部分：数据结构组织、FNV-1a 哈希函数的实现以及标识符解析算法。\n\n首先，我们必须以可计算访问的格式表示所提供的注册表数据。字典或关联数组是这些键值映射的合适数据结构。我们将定义以下结构：\n\n1.  `ISOFORM_SEQUENCES`：映射一个形式为 \"ACC-isoformIndex\" 的复合键（例如，`P04637-1`）到其氨基酸序列字符串。\n2.  `UNIPROT_SECONDARY_TO_PRIMARY`：映射一个次级 UniProt 登录号到其对应的主登录号。\n3.  `REFSEQ_TO_UNIPROT`：映射一个 RefSeq 根登录号到一个主 UniProt 登录号。\n4.  `GI_TO_REFSEQ`：映射一个 GenInfo (GI) 标识符到其完整的 RefSeq 登录号，包括版本。\n5.  `GENE_TO_UNIPROT`：映射基因符号及其同义词到一个主 UniProt 登录号。为满足不区分大小写的要求，此结构中的所有键都必须进行规范化，例如，转换为大写，并且查找操作必须在输入令牌的大写版本上执行。\n\n其次，必须实现用于无符号 64 位整数空间的 FNV-1a 哈希函数。FNV-1a 算法由以下针对哈希值 $h$ 和字节序列 $b_1, b_2, \\dots, b_L$ 的递推关系定义：\n- 初始化：$h_0 = \\text{offset\\_basis} = 14695981039346656037$\n- 递推：$h_i = (h_{i-1} \\oplus b_i) \\times \\text{prime} \\pmod{2^{64}}$，对于 $i=1, \\dots, L$。\n\n常数是 64 位 FNV 素数 $p = 1099511628211$ 和 64 位 FNV 偏移基数。操作（异或 $\\oplus$，乘法 $\\times$）使用无符号 64 位算术执行，其中溢出按模 $2^{64}$ 回绕。这是一个标准且确定性的过程。最终的哈希值是 $H = h_L$。\n\n第三，问题的核心是标识符解析逻辑。这是一个根据严格的规则层次处理输入令牌 $t$ 以找到规范蛋白质序列的算法。让我们将该过程形式化。\n\n1.  **规范化**：输入令牌 $t$ 的任何前导或尾随空白字符都将被剥离。\n\n2.  **类型识别和解析为主登录号**：通过按固定优先顺序检查令牌与模式的匹配情况来派生主 UniProt 登录号。\n    -   **类型 1 (GI)**：如果 $t$ 匹配模式 `gi|d`，其中 d 是数字序列，我们在 `GI_TO_REFSEQ` 映射中查找 `t`。如果成功，这将产生一个带版本的 RefSeq 登录号（例如，`NP_000537.2`）。然后我们通过移除 `.version` 后缀来提取根部分（例如，`NP_000537`）。然后将此根用作 `REFSEQ_TO_UNIPROT` 映射中的键以获取主 UniProt 登录号。如果任何查找失败，则此令牌的解析终止。\n    -   **类型 2 (RefSeq)**：如果 $t$ 不是 GI 号但匹配模式 `NP_digits.version`，我们提取根并按上一步的后半部分进行操作，通过 `REFSEQ_TO_UNIPROT` 将 RefSeq 根映射到主 UniProt 登录号。\n    -   **类型 3 (UniProt with Isoform)**：如果 $t$ 匹配模式 `ACC-i`，我们提取基础登录号 `ACC`。我们必须将 `ACC` 解析为主登录号。如果 `ACC` 是次级登录号（即 `UNIPROT_SECONDARY_TO_PRIMARY` 中的键），我们将其映射到其主登录号。否则，我们假设 `ACC` 本身就是主登录号。\n    -   **类型 4 (UniProt without Isoform)**：如果 $t$ 是一个不匹配先前模式的字符串，我们检查它是否为 UniProt 登录号。如果在 `UNIPROT_SECONDARY_TO_PRIMARY` 中找到 `t` 作为键，我们将其映射到其主登录号。否则，我们假设 `t` 是主登录号。\n    -   **类型 5 (Gene Symbol)**：如果所有先前的检查都失败，我们将 `t` 视为基因符号。我们将 `t` 转换为大写并在 `GENE_TO_UNIPROT` 映射中查找它以找到主 UniProt 登录号。\n\n3.  **规范异构体选择**：在成功识别出主 UniProt 登录号（我们称之为 $P$）后，我们必须从 `ISOFORM_SEQUENCES` 注册表中选择相应的规范异构体序列。规则如下：\n    -   如果注册表中存在键为 `$P$-1` 的条目，则其序列为规范序列。\n    -   否则，我们识别 $P$ 的所有现有异构体（即所有以 `$P$-` 开头的键）。从此集合中，我们选择具有最小异构体索引 $i$ 的那个。\n    -   如果在注册表中找不到 $P$ 的异构体，则解析失败。\n\n4.  **最终计算和输出**：如果成功解析出规范序列，则计算其长度 $L$ 及其 FNV-1a 哈希值 $H$。结果为对 $[L, H]$。如果在任何时候解析失败（例如，在映射中未找到键），则结果定义为 $[-1, -1]$。\n\n例如，考虑输入令牌 `\"P04637-2\"`。\n- 它匹配类型 3。基础登录号是 `P04637`。这是一个主登录号。\n- 下一步是找到 `P04637` 的规范异构体。\n- 注册表包含 `P04637-1`。根据规则，由于异构体“-1”存在，它就是规范异构体。\n- 因此，解析出的序列是与 `P04637-1` 相关联的序列，即 `MEEPQSDPSVEPPLSQETFSDLWKLL`。\n- 长度为 $L=26$，并将计算其 FNV-1a 哈希值 $H$。输入中指定的异构体“-2”被选择规范异构体的规则所取代。\n\n此过程是确定性的，并保证对于给定的注册表，每个输入令牌都有唯一的结果。实现必须精确地遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport re\n\ndef solve():\n    # Registry data defined as per the problem statement\n    ISOFORM_SEQUENCES = {\n        \"P04637-1\": \"MEEPQSDPSVEPPLSQETFSDLWKLL\",\n        \"P04637-2\": \"MEEPQSDPSVEPPLSQETFSDLWKL\",\n        \"P38398-1\": \"MDLSALRVEEVQNVINAMQKILECPICLE\",\n        \"P01106-1\": \"MPLNVSFTNRNYDLDYDSVQPY\",\n        \"P01106-2\": \"MPLNVSFTNRNYDLDYDSVQP\",\n        \"Q9Y243-1\": \"MSSILPFTPPVKRLLGWKHPGKQL\",\n    }\n    \n    UNIPROT_SECONDARY_TO_PRIMARY = {\n        \"Q13616\": \"P04637\", \"Q65484\": \"P38398\", \"P12524\": \"P01106\", \"O15162\": \"Q9Y243\",\n    }\n    \n    REFSEQ_TO_UNIPROT = {\n        \"NP_000537\": \"P04637\", \"NP_009225\": \"P38398\", \"NP_002458\": \"P01106\", \"NP_123456\": \"Q9Y243\",\n    }\n    \n    GI_TO_REFSEQ = {\n        \"gi|4557321\": \"NP_000537.2\", \"gi|8404561\": \"NP_009225.1\", \"gi|3154298\": \"NP_002458.1\", \"gi|15726711\": \"NP_123456.1\",\n    }\n\n    # Gene symbol mapping is case-insensitive. We store keys in uppercase.\n    GENE_TO_UNIPROT = {\n        \"TP53\": \"P04637\", \"P53\": \"P04637\", \"TRP53\": \"P04637\",\n        \"BRCA1\": \"P38398\", \"BRCC1\": \"P38398\",\n        \"MYC\": \"P01106\", \"C-MYC\": \"P01106\",\n        \"SMAD7\": \"Q9Y243\", \"MADH7\": \"Q9Y243\",\n    }\n\n    # FNV-1a hash parameters\n    FNV_PRIME = np.uint64(1099511628211)\n    FNV_OFFSET_BASIS = np.uint64(1469598103934665603)\n\n    def fnv1a_hash(sequence_str):\n        \"\"\"Computes the 64-bit FNV-1a hash of a string.\"\"\"\n        h = FNV_OFFSET_BASIS\n        for byte in sequence_str.encode('ascii'):\n            h ^= np.uint64(byte)\n            h *= FNV_PRIME\n        return int(h)\n\n    def get_canonical_isoform_key(primary_acc):\n        \"\"\"Finds the canonical isoform for a given primary UniProt accession.\"\"\"\n        key_iso1 = f\"{primary_acc}-1\"\n        if key_iso1 in ISOFORM_SEQUENCES:\n            return key_iso1\n        \n        isoform_indices = []\n        for key in ISOFORM_SEQUENCES:\n            if key.startswith(f\"{primary_acc}-\"):\n                try:\n                    index_part = key.split('-')[1]\n                    isoform_indices.append(int(index_part))\n                except (ValueError, IndexError):\n                    continue\n        \n        if not isoform_indices:\n            return None\n        \n        min_index = min(isoform_indices)\n        return f\"{primary_acc}-{min_index}\"\n\n    def resolve_token(token):\n        \"\"\"Resolves an input token to a primary UniProt accession.\"\"\"\n        token = token.strip()\n        \n        # Rule 1: GI pattern\n        if token.startswith(\"gi|\") and token.split('|')[1].isdigit():\n            refseq_ver = GI_TO_REFSEQ.get(token)\n            if refseq_ver:\n                refseq_root = refseq_ver.split('.')[0]\n                return REFSEQ_TO_UNIPROT.get(refseq_root)\n            return None\n\n        # Rule 2: RefSeq pattern\n        if re.match(r\"^NP_\\d+\\.\\d+$\", token):\n            refseq_root = token.split('.')[0]\n            return REFSEQ_TO_UNIPROT.get(refseq_root)\n\n        # Rule 3: UniProt with isoform pattern\n        match = re.match(r\"^([A-Z0-9]+)-(\\d+)$\", token)\n        if match:\n            base_acc = match.group(1)\n            return UNIPROT_SECONDARY_TO_PRIMARY.get(base_acc, base_acc)\n\n        # Rule 4: UniProt without isoform\n        # A simple heuristic: if it's alphanumeric and in one of the relevant DBs\n        if re.match(r\"^[A-Z0-9]+$\", token):\n             # Check if it's secondary\n            if token in UNIPROT_SECONDARY_TO_PRIMARY:\n                return UNIPROT_SECONDARY_TO_PRIMARY[token]\n            # Check if it's a known primary through its isoforms\n            for key in ISOFORM_SEQUENCES:\n                if key.startswith(token + '-'):\n                    return token\n\n        # Rule 5: Gene symbol\n        primary_acc = GENE_TO_UNIPROT.get(token.upper())\n        if primary_acc:\n            return primary_acc\n\n        return None\n\n    def get_result(token):\n        \"\"\"Main logic to process one token and return the result.\"\"\"\n        primary_acc = resolve_token(token)\n        if not primary_acc:\n            return [-1, -1]\n        \n        canonical_key = get_canonical_isoform_key(primary_acc)\n        if not canonical_key:\n            return [-1, -1]\n            \n        sequence = ISOFORM_SEQUENCES.get(canonical_key)\n        if not sequence:\n            return [-1, -1]\n            \n        length = len(sequence)\n        hash_val = fnv1a_hash(sequence)\n        \n        return [length, hash_val]\n\n    # Test suite from the problem description\n    test_cases = [\n        \"TP53\",\n        \"Q65484\",\n        \"NP_002458.1\",\n        \"gi|15726711\",\n        \"P04637-2\",\n        \"p53\",\n        \"gi|99999999\"\n    ]\n\n    results = []\n    for case in test_cases:\n        result = get_result(case)\n        results.append(str(result).replace(\" \", \"\"))\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2428399"}]}