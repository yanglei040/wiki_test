{"hands_on_practices": [{"introduction": "基因组序列中充满了重复元件，这给序列比对带来了巨大挑战。BLAST 提供了软屏蔽 (soft masking) 和硬屏蔽 (hard masking) 等工具来应对这些重复序列。此练习 [@problem_id:2376028] 旨在检验您对这两种屏蔽方式如何影响 BLAST 算法核心阶段（即种子生成和序列延伸）的理解，从而帮助您在处理复杂基因组时设计出更有效的搜索策略。", "problem": "一位研究人员使用BLASTN（Basic Local Alignment Search Tool nucleotide search）将一个基因组查询序列与一个大型脊椎动物基因组数据库进行比对。该查询序列包含一个内部片段，该片段是一种常见的灵长类短散在核元件（Alu）。研究人员进行了两次搜索，唯一的区别在于如何处理查询序列中的这个Alu片段：在搜索$\\mathrm{S}_{\\mathrm{soft}}$中，Alu被软屏蔽（soft masked，字母转换成小写）；在搜索$\\mathrm{S}_{\\mathrm{hard}}$中，Alu被硬屏蔽（hard masked，字母被替换为模糊代码，以致它们不参与比对）。Alu两侧的侧翼区域是数据库中仅出现一次的、唯一的、可比对的序列。请思考BLASTN如何通过使用长度为$w$的短的精确或近乎精确的词（word）进行种子生成（seeding），然后进行无空位和有空位延伸，以形成高分片段对（HSP），以及屏蔽（masking）如何与这些阶段相互作用。哪个选项最能描述$\\mathrm{S}_{\\mathrm{soft}}$和$\\mathrm{S}_{\\mathrm{hard}}$在以下方面的预期差异：(i) 种子的来源位置，(ii) 延伸是否可以穿过重复序列以产生单个跨越式的HSP，(iii) 仅由重复序列产生的伪命中的普遍程度，以及 (iv) 对跨越Alu的真实比对的期望值（E-value）的典型影响？\n\nA. 在$\\mathrm{S}_{\\mathrm{soft}}$中，种子不会从Alu中产生，但一旦在唯一的侧翼区域找到种子，有空位延伸可以穿过Alu，因此可以报告一个跨越该重复序列的单一HSP；仅由重复序列产生的伪命中被抑制。在$\\mathrm{S}_{\\mathrm{hard}}$中，Alu在种子生成和延伸阶段都被有效移除，因此延伸无法穿过它，本可以跨越该重复序列的HSP会变得被截断或分裂；两种方法都减少了仅由重复序列产生的伪命中，但硬屏蔽通常会缩短真实比对的长度，并可能相对于软屏蔽提高其E-value。\n\nB. 在$\\mathrm{S}_{\\mathrm{soft}}$中，种子生成和延伸在Alu中都被禁止，从而阻止任何HSP跨越该重复序列；在$\\mathrm{S}_{\\mathrm{hard}}$中，种子不会在Alu中产生，但延伸可以穿过它，因此跨越该重复序列的HSP仍会被报告；仅由重复序列产生的伪命中不受影响。\n\nC. 在$\\mathrm{S}_{\\mathrm{hard}}$中，硬屏蔽会增加对Alu实例的伪命中，因为被屏蔽的字母充当通配符，在许多位置产生种子，而$\\mathrm{S}_{\\mathrm{soft}}$中的软屏蔽只适度减少此类伪命中；两种方法都保留了跨越重复序列的真实比对的长度和E-value。\n\nD. 在BLASTN中，软屏蔽的字母在评分时权重被降低，因此任何穿过软屏蔽Alu的HSP的得分都比未屏蔽时低，E-value更高；硬屏蔽不改变评分，但会阻止在Alu中进行种子生成，对延伸是否能穿过重复序列没有影响。\n\nE. $\\mathrm{S}_{\\mathrm{soft}}$和$\\mathrm{S}_{\\mathrm{hard}}$都允许种子在Alu内部产生，但依赖于比对后的低复杂度过滤器来丢弃仅由重复序列产生的命中；因此，两者为真实比对产生的跨越式HSP和E-value相似，产生的仅由重复序列产生的伪匹配数量也相似。", "solution": "用户提供了一个关于计算生物学中基本局部比对搜索工具（BLAST）操作的问题。我现在将开始验证问题陈述。\n\n### 步骤1：提取已知信息\n- **工具**：BLASTN（Basic Local Alignment Search Tool nucleotide search）。\n- **查询序列**：一个基因组序列，包含一个作为常见灵长类短散在核元件（Alu）的内部片段。\n- **数据库**：一个大型脊椎动物基因组数据库。\n- **侧翼区域**：查询序列中Alu元件两侧的区域是唯一的、可比对的，在数据库中仅出现一次。\n- **搜索 $\\mathrm{S}_{\\mathrm{soft}}$**：Alu片段被软屏蔽（字母转换为小写）。\n- **搜索 $\\mathrm{S}_{\\mathrm{hard}}$**：Alu片段被硬屏蔽（字母被替换为模糊代码，以致它们不参与比对）。\n- **BLASTN机制**：该工具使用长度为$w$的短的精确或近乎精确的词（word）进行种子生成（seeding），然后进行无空位和有空位延伸，以形成高分片段对（HSP）。\n- **问题**：比较搜索$\\mathrm{S}_{\\mathrm{soft}}$和$\\mathrm{S}_{\\mathrm{hard}}$在以下方面的差异：(i) 种子来源，(ii) 延伸是否能穿过重复序列，(iii) 仅由重复序列产生的伪命中的普遍程度，以及 (iv) 对真实比对的期望值（E-value）的影响。\n\n### 步骤2：使用提取的已知信息进行验证\n1.  **科学依据**：该问题在生物信息学和计算生物学原理上有充分的依据。BLAST、Alu元件、软屏蔽、硬屏蔽、种子生成、延伸、HSP和E-value都是标准的、定义明确的概念。所描述的场景是序列分析中一个常见且实际的任务。\n2.  **问题的适定性**：该问题是适定的。它要求基于四个具体、可回答的标准，对两种明确定义的方法（$\\mathrm{S}_{\\mathrm{soft}}$和$\\mathrm{S}_{\\mathrm{hard}}$）进行定性比较。基于BLAST算法的已知机制，存在一个唯一、正确的描述。\n3.  **客观性**：所用语言是技术性的、精确的和客观的。“软屏蔽”、“硬屏蔽”、“种子生成”和“延伸”在BLAST的语境中具有具体、明确的含义。\n4.  **无缺陷**：问题陈述没有违反任何科学原理，不是比喻性的，是完整的，是现实的，并且不是不适定的。将硬屏蔽描述为用模糊代码替换字母“以致它们不参与比对”，准确地捕捉了其功能性结果，即延伸算法由于高错配罚分而无法通过这些区域。\n\n### 步骤3：结论与行动\n问题陈述被判定为**有效**。我将继续推导解决方案并评估选项。\n\n### 求解推导\n\n该问题需要分析软屏蔽和硬屏蔽如何影响BLASTN算法的结果。该算法可以理解为两个主要阶段：种子生成和延伸。\n\n1.  **种子生成（Seeding）**：BLASTN首先在查询序列和数据库之间识别出长度为$w$的短的、完全或近乎完全匹配的“词”。这些词作为潜在比对的种子。像Alu这样的重复元件在数据库中以高拷贝数存在。如果使用一个包含未屏蔽Alu的查询序列，它将通过匹配数据库中无数的Alu元件而产生大量的种子，导致大量的伪比对和计算成本高昂的搜索。屏蔽是缓解这一问题的主要策略。\n\n2.  **软屏蔽（$\\mathrm{S}_{\\mathrm{soft}}$）**：在软屏蔽中，重复的Alu区域中的核苷酸碱基被转换为小写（例如，`atgc...` 而非 `ATGC...`）。\n    - **对种子生成的影响**：默认情况下，BLAST程序被配置为在种子生成阶段忽略查询序列的软屏蔽（小写）区域。因此，在搜索$\\mathrm{S}_{\\mathrm{soft}}$中，不会有种子从Alu片段中产生。种子只能从非屏蔽的、唯一的侧翼区域生成。\n    - **对延伸的影响**：一旦在唯一的侧翼区域找到种子，比对延伸过程就开始了。在这个有空位延伸阶段，软屏蔽的字母被当作常规核苷酸处理，并使用标准评分矩阵进行评分。这使得比对能够*穿过*软屏蔽的Alu区域，连接两个唯一的侧翼。结果是形成一个单一的、长的、跨越整个查询区域（包括Alu）的高分片段对（HSP）。\n    - **对伪命中的影响**：由于从查询序列的Alu生成种子的功能被禁用，BLASTN不会与数据库中大量的其他Alu元件启动比对。这有效地抑制了仅由重复序列产生的伪命中的报告。\n    - **对E-value的影响**：生成一个单一的长HSP。由于其长度，比对得分（$S$）会很高。期望值（E-value），衡量随机情况下可能出现的命中数，与得分的关系为 $E = Kmn e^{-\\lambda S}$，其中$K$和$\\lambda$是统计参数，$m$和$n$是查询和数据库的长度。较高的得分$S$会导致指数级更低（更显著）的E-value。\n\n3.  **硬屏蔽（$\\mathrm{S}_{\\mathrm{hard}}$）**：在硬屏蔽中，重复的Alu区域中的碱基被替换为模糊字符，通常是'N'。问题陈述这使得字母“不参与比对”。\n    - **对种子生成的影响**：与软屏蔽类似，含有'N'的区域不用于生成种子。因此，不会有种子从硬屏蔽的Alu片段中产生。\n    - **对延伸的影响**：在延伸阶段，序列中的'N'代表完全未知。在BLASTN的评分系统中，将'N'与任何标准碱基（A, C, G, T）甚至另一个'N'进行比对通常会产生显著的罚分。这个罚分通常大到足以终止延伸过程。因此，在一个侧翼区域启动的比对无法穿过硬屏蔽的Alu到达另一个侧翼。\n    - **对伪命中的影响**：与软屏蔽一样，硬屏蔽阻止了从查询序列的Alu区域生成种子，从而抑制了仅由重复序列产生的伪命中。\n    - **对E-value的影响**：由于延伸在硬屏蔽区域的边界处停止，原本单一的真实比对被分割。结果将是两个较短的HSP（每个侧翼一个）或一个截断的HSP（如果只有一个侧翼找到种子并延伸），而不是来自$\\mathrm{S}_{\\mathrm{soft}}$的单一长HSP。这些较短的HSP与$\\mathrm{S}_{\\mathrm{soft}}$的单一长HSP相比，得分（$S$）会更低。较低的得分会导致较高（不太显著）的E-value。\n\n### 逐项分析\n\n**A. 在$\\mathrm{S}_{\\mathrm{soft}}$中，种子不会从Alu中产生，但一旦在唯一的侧翼区域找到种子，有空位延伸可以穿过Alu，因此可以报告一个跨越该重复序列的单一HSP；仅由重复序列产生的伪命中被抑制。在$\\mathrm{S}_{\\mathrm{hard}}$中，Alu在种子生成和延伸阶段都被有效移除，因此延伸无法穿过它，本可以跨越该重复序列的HSP会变得被截断或分裂；两种方法都减少了仅由重复序列产生的伪命中，但硬屏蔽通常会缩短真实比对的长度，并可能相对于软屏蔽提高其E-value。**\n- 这个选项准确地描述了$\\mathrm{S}_{\\mathrm{soft}}$和$\\mathrm{S}_{\\mathrm{hard}}$在所有四个比较点上的情况。它正确地指出软屏蔽阻止在Alu中生成种子但允许延伸穿过它，从而产生一个单一的跨越式HSP并抑制伪命中。它也正确地指出硬屏蔽在Alu中同时阻止了种子生成和延伸，导致HSP被截断/分裂。最后，它正确地得出结论，硬屏蔽缩短比对长度导致比软屏蔽更高的（更差的）E-value。\n- **结论：正确。**\n\n**B. 在$\\mathrm{S}_{\\mathrm{soft}}$中，种子生成和延伸在Alu中都被禁止，从而阻止任何HSP跨越该重复序列；在$\\mathrm{S}_{\\mathrm{hard}}$中，种子不会在Alu中产生，但延伸可以穿过它，因此跨越该重复序列的HSP仍会被报告；仅由重复序列产生的伪命中不受影响。**\n- 关于$\\mathrm{S}_{\\mathrm{soft}}$的陈述是不正确的；延伸在软屏蔽区域*并非*被禁止。关于$\\mathrm{S}_{\\mathrm{hard}}$的陈述也是不正确的；延伸*不能*穿过硬屏蔽区域。这个选项颠倒了两种屏蔽类型对延伸阶段的影响。声称伪命中不受影响也是不正确的。\n- **结论：不正确。**\n\n**C. 在$\\mathrm{S}_{\\mathrm{hard}}$中，硬屏蔽会增加对Alu实例的伪命中，因为被屏蔽的字母充当通配符，在许多位置产生种子，而$\\mathrm{S}_{\\mathrm{soft}}$中的软屏蔽只适度减少此类伪命中；两种方法都保留了跨越重复序列的真实比对的长度和E-value。**\n- 这从根本上是错误的。屏蔽（两种类型）的目的和效果是*阻止*在重复区域中生成种子，从而*减少*伪命中。'N's并不充当种子生成的通配符。此外，硬屏蔽并*不*保留真实比对的长度和E-value；它会缩短比对并使E-value变差。\n- **结论：不正确。**\n\n**D. 在BLASTN中，软屏蔽的字母在评分时权重被降低，因此任何穿过软屏蔽Alu的HSP的得分都比未屏蔽时低，E-value更高；硬屏蔽不改变评分，但会阻止在Alu中进行种子生成，对延伸是否能穿过重复序列没有影响。**\n- 第一部分不是标准行为。软屏蔽的字母在延伸时通常是正常评分的，它们仅在种子生成时被忽略。声称这会导致更高的E-value在过滤重复序列的背景下是不合逻辑的。关于硬屏蔽的部分是不正确的；它对延伸有决定性影响，会阻止延伸。\n- **结论：不正确。**\n\n**E. $\\mathrm{S}_{\\mathrm{soft}}$和$\\mathrm{S}_{\\mathrm{hard}}$都允许种子在Alu内部产生，但依赖于比对后的低复杂度过滤器来丢弃仅由重复序列产生的命中；因此，两者为真实比对产生的跨越式HSP和E-value相似，产生的仅由重复序列产生的伪匹配数量也相似。**\n- 这个陈述从一开始就是不正确的。屏蔽的主要功能是*阻止*种子在被屏蔽区域内产生。因此，下游的结论，即它们产生相似的跨越式HSP和E-value，也是错误的。$\\mathrm{S}_{\\mathrm{hard}}$不会产生跨越式HSP。\n- **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "2376028"}, {"introduction": "BLAST 是一种启发式算法，它在设计上优先考虑速度而非保证找到最优比对。这种权衡意味着在某些特定情况下，BLAST 可能会错过一个真实的同源关系，而像 Smith-Waterman 这样的精确算法却能检测到它。通过分析这些启发式算法可能失败的场景 [@problem_id:2376082]，您将更深刻地理解 BLAST 的内部机制，并学会识别其结果可能不完整的各种情况。", "problem": "要求您推断在何种情况下，精确的动态规划局部比对在比较蛋白质时，其性能会显著优于种子启发式算法。请仅使用以下基本依据：(i) 分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质），这意味着蛋白质序列是由编码序列衍生的氨基酸串；(ii) 局部比对的定义，即在所有子串上进行优化，以最大化替换得分之和减去空位罚分；以及 (iii) 基础局部比对搜索工具 (BLAST) 家族的设计，它是一种播种-扩展启发式算法，能识别短的高分词并对其进行扩展，通常带有低复杂度区域过滤器和基于成分的得分调整。\n\n考虑默认的蛋白质-蛋白质搜索，其中 Smith–Waterman 局部比对在固定的替换矩阵和仿射空位罚分下计算最优得分，而 BLASTP（蛋白质-蛋白质 BLAST）使用长度为 $w$ 的短词种子，并设有邻域阈值 $T$，对查询序列可选地进行低复杂度屏蔽，进行基于成分的得分调整，并在扩展过程中使用 $X$ 分值下降标准。您需要寻找一对真实的蛋白质，其中最优的 Smith–Waterman 比对得分显著高于 BLASTP 报告的得分，并且必须解释为什么 BLASTP 启发式算法在这种情况下会失效。假设使用常规的蛋白质替换矩阵（例如，BLOSUM 家族矩阵）和标准的仿射空位罚分。\n\n哪个（些）选项最可能确定了这样一对蛋白质，并正确解释了 BLASTP 启发式算法的失效机制？\n\nA. 两种蛋白质共享一个长的卷曲螺旋片段，这是它们唯一的保守区域。该片段是低复杂度的，且有成分偏向性（富含少数几种疏水性残基），因此默认的低复杂度屏蔽会在播种前将其从 BLASTP 查询序列中移除。未使用屏蔽的 Smith–Waterman 算法会比对该卷曲螺旋，并累积许多正向的疏水-疏水匹配，从而产生高分；BLASTP 报告的分数很低或没有分数，因为实际上没有种子可以扩展。\n\nB. 两种蛋白质各自包含许多形式为 “PxxP” 的富含脯氨酸的重复序列，这些序列散布在各处，导致大量相同的短词。BLASTP 产生多个高分种子，这些种子扩展成强大的局部比对，因此其得分与 Smith–Waterman 的得分相匹配或超过它；因此，在这种情况下，Smith–Waterman 不会显著优于 BLASTP。\n\nC. 使用 BLASTP 的默认参数将一个蛋白质与一个核苷酸编码序列进行比较。蛋白质空间上的动态规划仍应能找到最优比对，但 BLASTP 表现不佳，因为翻译搜索会更合适。因此，Smith–Waterman 得分要高得多。\n\nD. 两种同源蛋白质共享一个保守结构域，其中的相似性被频繁的短插入和缺失所中断：在真实比对中，每隔几个残基就会出现空位，从而阻止了长的连续匹配。在仿射空位罚分下，Smith–Waterman 为每个空位支付一次空位开放罚分，并在整个结构域累积许多正向的保守替换，从而产生一个高的局部得分。BLASTP 要求至少有一个长度为 $w$ 的、超过阈值的、无空位比对的种子，并且在扩展初期得分要快速增长；频繁的中断会导致扩展未能满足 $X$ 分值下降标准，因此报告的 BLASTP 得分很低。\n\nE. 两种蛋白质是同源的，但具有极端的成分偏向性（例如，富含赖氨酸/精氨酸的区域）。BLASTP 应用基于成分的得分矩阵调整，该调整会降低与偏向背景一致的匹配的权重，从而使种子得分和高分片段对的增长低于报告阈值。使用固定替换矩阵且没有基于成分调整的 Smith–Waterman 算法会累积许多正分，从而产生一个显著更高的最优局部比对得分。\n\n选择所有适用选项。", "solution": "该问题要求确定在哪些情景下，精确的动态规划局部比对算法（特别是 Smith-Waterman 算法）为一对蛋白质产生的得分会显著高于 BLASTP 启发式算法。分析必须基于这些算法的基本机制。\n\nSmith-Waterman 算法保证在给定的评分系统（替换矩阵和空位罚分）下，找到一对序列的最优局部比对得分。它是一种基于动态规划的、详尽的、最优的方法。\n\nBLASTP 算法是一种为速度而设计的启发式算法。其核心策略是“播种-扩展”。\n1. **播种 (Seeding)**：它首先识别长度为 $w$（蛋白质通常为 $w=3$）的、得分满足阈值 $T$ 的、短的、高分的、无空位的词对。查询序列通常会经过预处理，以屏蔽低复杂度区域。\n2. **扩展 (Extension)**：然后，这些种子在两个方向上进行扩展，最初也是无空位的。扩展过程会累积得分。如果得分从该扩展迄今为止看到的最高得分下降超过一个值 $X$（即 $X$ 分值下降标准），则终止扩展。只有对于得分高的初始结果，才会尝试有空位的比对。\n3. **调整 (Adjustments)**：现代 BLAST 版本加入了基于成分的统计数据来调整替换得分，以减轻具有相似但非同源成分偏向性的序列之间产生的伪高分。\n\nBLASTP 未能找到 Smith-Waterman 能找到的高分比对，其原因必定源于这些启发式步骤中的某一个失败。我们现在将评估每个选项。\n\n**A. 两种蛋白质共享一个长的卷曲螺旋片段，这是它们唯一的保守区域。该片段是低复杂度的，且有成分偏向性（富含少数几种疏水性残基），因此默认的低复杂度屏蔽会在播种前将其从 BLASTP 查询序列中移除。未使用屏蔽的 Smith–Waterman 算法会比对该卷曲螺旋，并累积许多正向的疏水-疏水匹配，从而产生高分；BLASTP 报告的分数很低或没有分数，因为实际上没有种子可以扩展。**\n\n此选项描述了 BLASTP 在预处理阶段的失败。\n- **BLASTP 机制**：低复杂度区域（LCRs），例如富含少数几种残基类型（如亮氨酸）的卷曲螺旋，在 BLASTP 中通常会被默认过滤（例如，使用 SEG 程序）。这意味着查询序列中这些区域的字母被替换为占位符（如 'X'），并且不用于生成种子。如果唯一真正的相似性区域是一个 LCR，那么在屏蔽之后，将无法找到对应于该区域的种子。\n- **Smith-Waterman 机制**：按照规定，Smith-Waterman 算法在运行时没有屏蔽。它将评估卷曲螺旋区域的比对。鉴于这些区域是保守的，比对将包含许多相同或相似的疏水性残基的匹配。在标准的替换矩阵如 BLOSUM$62$ 中，这些匹配（例如 L-L、I-I、V-V）具有很高的正分。这些分数的总和将导致一个高的最优局部比对得分。\n- **结论**：Smith-Waterman 的得分会很高，而 BLASTP 的得分将接近于零，因为启发式算法实际上忽略了唯一具有相似性的区域。这种情况是现实的，并且对失效机制的解释是正确的。\n- **评定**：**正确**。\n\n**B. 两种蛋白质各自包含许多形式为 “PxxP” 的富含脯氨酸的重复序列，这些序列散布在各处，导致大量相同的短词。BLASTP 产生多个高分种子，这些种子扩展成强大的局部比对，因此其得分与 Smith–Waterman 的得分相匹配或超过它；因此，在这种情况下，Smith–Waterman 不会显著优于 BLASTP。**\n\n此选项描述了一种重复序列的情景。\n- **BLASTP 机制**：大量相同的短词（例如，来自 'PxxP' 重复序列）的存在将导致生成许多种子。BLASTP 在查找和扩展此类种子上非常有效。该选项正确地指出，这将导致 BLASTP 找到强大的局部比对。\n- **比较**：“其得分与 Smith–Waterman 的得分相匹配或超过它”这一陈述存在逻辑错误。一个启发式算法的得分不可能超过像 Smith-Waterman 这样的精确算法在使用等效评分系统时找到的最优得分。然而，该选项的主要观点是 BLASTP 在这种情况下*表现良好*。问题要求的是 Smith-Waterman *优于* BLASTP 的情景。此选项描述的恰恰相反。\n- **结论**：此选项描述了 BLASTP 启发式算法的一个成功案例，而不是失败案例。\n- **评定**：**不正确**。\n\n**C. 使用 BLASTP 的默认参数将一个蛋白质与一个核苷酸编码序列进行比较。蛋白质空间上的动态规划仍应能找到最优比对，但 BLASTP 表现不佳，因为翻译搜索会更合适。因此，Smith–Waterman 得分要高得多。**\n\n此选项描述了对指定生物信息学工具的误用。\n- **科学有效性**：BLASTP 是为蛋白质-蛋白质比较而设计的。它使用蛋白质替换矩阵（例如 BLOSUM$62$）来为比对评分。核苷酸序列数据库由字母表 {A, C, G, T} 组成。这与蛋白质查询序列 {A, C, D, ..., Y} 和蛋白质评分矩阵在根本上是不兼容的。试图以这种方式运行 BLASTP 是用户错误，并且会产生无意义的结果。合适的工具应该是 TBLASTN，它会将核苷酸数据库在所有 $6$ 个阅读框中进行翻译，然后执行蛋白质-蛋白质比较。\n- **前提无效**：问题假设是比较一对“蛋白质对”。一个蛋白质和一个核苷酸序列不构成一个蛋白质对。这里的失败不是算法在有效上下文中的启发式限制，而是对工具的不正确应用。\n- **结论**：该选项基于一个无意义的前提，并且没有描述一个可以用来判断算法相对性能的有效比较情景。\n- **评定**：**不正确**。\n\n**D. 两种同源蛋白质共享一个保守结构域，其中的相似性被频繁的短插入和缺失所中断：在真实比对中，每隔几个残基就会出现空位，从而阻止了长的连续匹配。在仿射空位罚分下，Smith–Waterman 为每个空位支付一次空位开放罚分，并在整个结构域累积许多正向的保守替换，从而产生一个高的局部得分。BLASTP 要求至少有一个长度为 $w$ 的、超过阈值的、无空位比对的种子，并且在扩展初期得分要快速增长；频繁的中断会导致扩展未能满足 $X$ 分值下降标准，因此报告的 BLASTP 得分很低。**\n\n此选项描述了由于相似性碎片化导致的失败。\n- **BLASTP 机制**：这种情况对 BLASTP 提出了两个挑战。\n    $1$. **播种**：BLASTP 需要一个长度为 $w$（例如，$w=3$）的连续、无空位的种子。如果相似性被每隔几个残基的空位所打断，那么可能不存在任何长度为 $w$ 的高分词对，从而阻止任何种子的发现。\n    $2$. **扩展**：即使找到了一个短种子，扩展过程也会立即遇到需要空位的区域。引入一个空位会招致罚分，导致比对得分下降。在频繁出现空位的情况下，得分将反复难以增加，并且很可能从其运行最大值下降超过 $X$ 分值下降值，导致扩展过早终止。\n- **Smith-Waterman 机制**：带有仿射空位罚分（$G_{open} + L \\times G_{extend}$）的 Smith-Waterman 算法非常适合解决这个问题。它将系统地找到通过动态规划矩阵的最优路径。如果空位之间的匹配残基所带来的正分足以抵消空位开放罚分的总和，它将正确识别整个保守结构域并报告一个高分。\n- **结论**：这是一个经典的例子，说明了播种-扩展启发式算法在何处会失败。真实的比对存在，但它过于碎片化，以至于 BLAST 对连续种子和扩展期间持续得分增加的要求无法检测到它。\n- **评定**：**正确**。\n\n**E. 两种蛋白质是同源的，但具有极端的成分偏向性（例如，富含赖氨酸/精氨酸的区域）。BLASTP 应用基于成分的得分矩阵调整，该调整会降低与偏向背景一致的匹配的权重，从而使种子得分和高分片段对的增长低于报告阈值。使用固定替换矩阵且没有基于成分调整的 Smith–Waterman 算法会累积许多正分，从而产生一个显著更高的最优局部比对得分。**\n\n此选项描述了由于 BLASTP 的一个特定纠正功能而导致的失败。\n- **BLASTP 机制**：BLAST 引入了基于成分的统计数据以提高特异性。对于具有偏向性成分的序列（例如，许多带电荷的残基），标准矩阵可能仅仅因为偶然就会为非同源比对产生高分。调整程序会重新调整替换矩阵的得分，使其更适用于观察到的残基频率。这会系统地降低在偏向性上下文中常见的匹配的得分（例如，在富含赖氨酸的序列中的 K-K 匹配）。这可能导致潜在种子的得分被降低到阈值 $T$ 以下，并可能减缓或停止扩展过程中的得分累积。\n- **Smith-Waterman 机制**：问题指定 Smith-Waterman 在运行时使用固定的替换矩阵（例如，标准的 BLOSUM$62$）而没有此调整。在这种情况下，它将比对富含赖氨酸/精氨酸的区域，并从矩阵中累加 K-K、R-R 和 K-R 匹配的高正分，从而得到一个高的总分。\n- **结论**：这描述了一个有效的情景。BLASTP 在这种情况下被特意设计为保守的，以避免假阳性，但同样的机制可能导致它错过一个本应获得高分的真实同源关系。如所述的比较（带调整的 BLASTP vs. 不带调整的 SW）将导致巨大的得分差异。\n- **评定**：**正确**。\n\n综上所述，选项 A、D 和 E 描述了基于充分理解的机制的、貌似合理且现实的情景，在这些情景中，BLASTP 启发式算法将无法找到最优的 Smith-Waterman 算法能够识别的高分比对。", "answer": "$$\\boxed{ADE}$$", "id": "2376082"}, {"introduction": "检测远缘进化关系（即处于序列身份“模糊区”的同源序列）是生物信息学中的一个重大挑战，这通常需要我们超越默认参数，对搜索策略进行精细调整。这个动手编程挑战 [@problem_id:2376047] 要求您从第一性原理出发，实现一个简化的 BLASTP 算法。通过调整评分矩阵和种子词大小等关键参数，您将学习如何成功识别远缘相关蛋白之间的同源性，从而将理论知识转化为解决实际问题的能力。", "problem": "您将实现一个完整的、可运行的程序，该程序模拟蛋白质基本局部比对搜索工具（BLASTP）的简化版本。目标是自动选择一个非默认参数配置，以揭示序列一致性处于所谓“暮光区”（约为 $0.25$ 的分数）的氨基酸序列之间的同源性。该程序必须采用基于分子生物学中心法则和经过充分检验的局部比对统计公式的有原则、第一性原理的设计。您的程序不得读取任何输入；它必须能直接运行，并产生单行输出。\n\n您需要实现一个检测器，该检测器采用种子-延伸启发式方法，结合局部比对评分和统计显著性估计，并遵循以下基本规则：\n\n1. 中心法则与同源性。蛋白质序列由编码DNA翻译而来，同源性意味着共同的祖先，这一点通过保守位置得以证明。您的算法应依赖局部比对来检测指示同源性的保守区域，而不假设全局相似性。\n\n2. 对数优势评分和替换家族。蛋白质使用源自对数优势原理的替换矩阵进行评分。您将实现三个定性上模仿BLOSUM行为的替换家族：\n   - 一个基于标准 $20$ 种氨基酸字母表 $\\mathcal{A}$ 的简化化学基团模型将 $\\mathcal{A}$ 划分为以下五个组：\n     - 疏水性：$\\{ \\mathrm{A}, \\mathrm{V}, \\mathrm{I}, \\mathrm{L}, \\mathrm{M}, \\mathrm{F}, \\mathrm{W}, \\mathrm{Y} \\}$\n     - 极性不带电：$\\{ \\mathrm{S}, \\mathrm{T}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{C} \\}$\n     - 酸性：$\\{ \\mathrm{D}, \\mathrm{E} \\}$\n     - 碱性：$\\{ \\mathrm{K}, \\mathrm{R}, \\mathrm{H} \\}$\n     - 特殊：$\\{ \\mathrm{G}, \\mathrm{P} \\}$\n   - 通过一个评分函数 $s_{\\mathrm{family}}(x,y)$ 定义三个矩阵，其中 $x,y \\in \\mathcal{A}$：\n     - LOOSE：完全匹配得分 $+5$，同组非相同匹配得分 $+2$，不同组匹配得分 $-2$。\n     - MEDIUM：完全匹配得分 $+4$，同组非相同匹配得分 $+1$，不同组匹配得分 $-3$。\n     - STRICT：完全匹配得分 $+6$，同组非相同匹配得分 $0$，不同组匹配得分 $-4$。\n\n3. 播种（词命中）。使用蛋白质种子-延伸启发式方法：\n   - 词长 $w \\in \\{2,3\\}$。\n   - 对于查询序列和目标序列中的每一对位置 $(i,j)$，计算 $w$-mer 的种子分数为 $\\sum_{k=0}^{w-1} s_{\\mathrm{family}}(q_{i+k}, t_{j+k})$，前提是索引在范围内。\n   - 如果种子分数至少达到一个依赖于家族和 $w$ 的阈值 $T(\\mathrm{family},w)$，则宣告发现一个种子：\n     - 对于 LOOSE：$T(\\mathrm{LOOSE},2)=6$, $T(\\mathrm{LOOSE},3)=10$。\n     - 对于 MEDIUM：$T(\\mathrm{MEDIUM},2)=8$, $T(\\mathrm{MEDIUM},3)=12$。\n     - 对于 STRICT：$T(\\mathrm{STRICT},2)=10$, $T(\\mathrm{STRICT},3)=15$。\n   - 如果不存在种子，则宣告“无命中”并跳过延伸步骤。\n\n4. 通过带仿射空位罚分的局部比对进行延伸。如果存在至少一个种子，则使用带有仿射空位代价的 Smith–Waterman 算法计算最优局部比对分数 $S$：\n   - 空位开放罚分 $g_o \\in \\{9,11\\}$。\n   - 空位延伸罚分 $g_e \\in \\{1,2\\}$。\n   - 匹配/错配使用与上述相同的 $s_{\\mathrm{family}}$。\n\n5. 统计显著性（Karlin–Altschul 统计）。对于蛋白质BLAST，使用 Karlin–Altschul 经过充分检验的局部比对分数结果。给定查询序列长度 $m$、数据库有效长度 $n$ 以及最大局部比对分数 $S$，计算比特分数 $S'$ 和期望计数值 $E$：\n   - 使用家族特定的常数 $(\\lambda, K)$:\n     - LOOSE: $\\lambda=0.27$, $K=0.07$。\n     - MEDIUM: $\\lambda=0.318$, $K=0.13$。\n     - STRICT: $\\lambda=0.35$, $K=0.16$。\n   - 通过 $S' = (\\lambda S - \\ln K)/\\ln 2$ 将原始分数转换为比特分数。\n   - 期望计数值为 $E = mn\\, 2^{-S'}$。等效地 $E = K\\, m n \\, e^{-\\lambda S}$。\n   - 如果 $E \\le \\tau$，则命中被认为是显著的，其中 $\\tau=0.01$（一个纯数字，无单位）。\n\n6. 基于成分的统计标志。包含一个布尔参数 $c \\in \\{0,1\\}$，代表基于成分的统计（关闭/开启）。对于此简化模型，$c$ 不直接改变评分或统计；它作为参数元组的一部分被跟踪，以强制执行“非默认”选择。\n\n7. 参数枚举与默认值。按字典序列举参数元组：\n   - family $\\in [\\mathrm{LOOSE}, \\mathrm{MEDIUM}, \\mathrm{STRICT}]$,\n   - $w \\in [2,3]$,\n   - $g_o \\in [9,11]$,\n   - $g_e \\in [1,2]$,\n   - $c \\in [0,1]$。\n   设类似BLASTP的默认元组为 $(\\mathrm{MEDIUM},3,11,1,1)$，对应于家族 MEDIUM、词长 $w=3$、$g_o=11$、$g_e=1$、$c=1$。默认值包含在枚举中，但绝不能被选为答案。\n\n8. 选择规则。对于给定的查询-目标对和数据库有效长度 $n$，在所有声明了至少一个种子且产生 $E \\le \\tau$ 的非默认参数元组中，选择与默认元组差异字段最少的那个元组（每个字段同等计数）。如有并列，则根据第7项中的枚举规则选择字典序最小的元组。如果没有非默认元组产生显著命中，则返回无解。\n\n您的程序必须实现上述检测器，并将其应用于以下测试套件。每个测试用例提供一个查询序列、一个目标序列和一个数据库有效长度。所有氨基酸序列都是字母表 $\\mathcal{A}$ 上的大写字符串。没有物理单位。\n\n测试套件（四个案例）：\n- 案例A（暮光区同源物，约 $0.25$ 一致性）：\n  - 查询序列 $q_A$: \"MAVKDLGATYVAGLSERAGADVVVVNTDAGKSTLLNQLAGLDKTTELWAVDAGHNTMPNVIAGLKMKDGKKLSALDAGADLLSVTNPADKVIAGLEGA\"\n  - 目标序列 $t_A$: \"LVIRDLGCTFIAGLTERTGVDIIVVNKDAGKSALLSQLSGIDETTELYAVDSGHNTLPNVVSGIKMREGKKLTALDAGKDLLTITNPKDKILAGMEGS\"\n  - 数据库有效长度 $n_A = 10^6$。\n- 案例B（不相关序列；应不显著）：\n  - 查询序列 $q_B$: \"WQFPCHMNRTYGPADKSVYHCRWTQGPNTRHACDYKMPLWQHTRNYGACDPKTYRH\"\n  - 目标序列 $t_B$: \"IVLVMAGTALLLVALGLTGATAAAVVLVALGLTVAIVGLALVVVVLAIVVVLVVV\"\n  - 数据库有效长度 $n_B = 10^6$。\n- 案例C（中等相似度；高于暮光区）：\n  - 查询序列 $q_C$: \"ADKQLVQKAKLAEQAERYDDMAAAMKAVTEQGHELSNEERNLLSVAYKNVVGARRSSWR\"\n  - 目标序列 $t_C$: \"AEKQLVQRAKLAEQAERYDEMAEALKKVTEQGHELSNDEKDLLSVAYKNVVNARRATWR\"\n  - 数据库有效长度 $n_C = 10^6$。\n- 案例D（短蛋白质；$w=3$ 可能过于严格的边界情况）：\n  - 查询序列 $q_D$: \"GPWKVVVVAGHGISDLGKTKAVAI\"\n  - 目标序列 $t_D$: \"GSWKIIVVAGHGITDLGKSRAIAL\"\n  - 数据库有效长度 $n_D = 10^6$。\n\n输出规范：\n- 对于每个案例，计算所选参数元组在第7项描述的完整枚举顺序中的零基索引（即，计数中包括默认元组），如果没有任何非默认元组产生显著命中，则输出 $-1$。\n- 您的程序应生成单行输出，包含四个结果，格式为方括号内的逗号分隔列表，例如，“[i_A,i_B,i_C,i_D]”。\n- 所有值必须是整数。\n\n注：\n- 没有物理单位；期望计数值 $E$ 是一个纯数。分数 $0.01$ 是一个阈值，必须严格按照给定值使用。\n- 不涉及角度。\n- 百分比必须作为分数处理，这就是为什么暮光区使用 $0.25$ 来描述。", "solution": "所述问题经过了严格的验证。\n\n**第一步：提取已知信息**\n\n- **氨基酸字母表 ($\\mathcal{A}$):** 标准的 $20$ 种氨基酸。\n- **氨基酸组：**\n  - 疏水性：$\\{ \\mathrm{A}, \\mathrm{V}, \\mathrm{I}, \\mathrm{L}, \\mathrm{M}, \\mathrm{F}, \\mathrm{W}, \\mathrm{Y} \\}$\n  - 极性不带电：$\\{ \\mathrm{S}, \\mathrm{T}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{C} \\}$\n  - 酸性：$\\{ \\mathrm{D}, \\mathrm{E} \\}$\n  - 碱性：$\\{ \\mathrm{K}, \\mathrm{R}, \\mathrm{H} \\}$\n  - 特殊：$\\{ \\mathrm{G}, \\mathrm{P} \\}$\n- **评分家族 ($s_{\\mathrm{family}}(x,y)$):**\n  - LOOSE：完全匹配 $+5$，同组非相同匹配 $+2$，不同组匹配 $-2$。\n  - MEDIUM：完全匹配 $+4$，同组非相同匹配 $+1$，不同组匹配 $-3$。\n  - STRICT：完全匹配 $+6$，同组非相同匹配 $0$，不同组匹配 $-4$。\n- **播种：**\n  - 词长 $w \\in \\{2, 3\\}$。\n  - 种子分数：$\\sum_{k=0}^{w-1} s_{\\mathrm{family}}(q_{i+k}, t_{j+k})$。\n  - 种子阈值 $T$：$T(\\mathrm{LOOSE},2)=6$, $T(\\mathrm{LOOSE},3)=10$；$T(\\mathrm{MEDIUM},2)=8$, $T(\\mathrm{MEDIUM},3)=12$；$T(\\mathrm{STRICT},2)=10$, $T(\\mathrm{STRICT},3)=15$。\n- **延伸（带仿射空位的局部比对）：**\n  - 空位开放罚分 $g_o \\in \\{9, 11\\}$。\n  - 空位延伸罚分 $g_e \\in \\{1, 2\\}$。\n- **统计显著性 (Karlin-Altschul):**\n  - 查询序列长度 $m$，数据库有效长度 $n$。\n  - 统计常数 $(\\lambda, K)$：LOOSE ($\\lambda=0.27, K=0.07$)，MEDIUM ($\\lambda=0.318, K=0.13$)，STRICT ($\\lambda=0.35, K=0.16$)。\n  - 比特分数 $S' = (\\lambda S - \\ln K)/\\ln 2$。\n  - 期望计数值 $E = mn\\, 2^{-S'} = Kmn \\, e^{-\\lambda S}$。\n  - 显著性阈值 $\\tau=0.01$。如果 $E \\le \\tau$，则命中是显著的。\n- **基于成分的统计标志：** $c \\in \\{0, 1\\}$。\n- **参数枚举（字典序）：** family $\\in [\\mathrm{LOOSE}, \\mathrm{MEDIUM}, \\mathrm{STRICT}]$, $w \\in [2,3]$, $g_o \\in [9,11]$, $g_e \\in [1,2]$, $c \\in [0,1]$。\n- **默认参数元组：** $(\\mathrm{MEDIUM}, 3, 11, 1, 1)$。\n- **选择规则：** 对于给定的查询/目标对，从所有找到种子且产生 $E \\le \\tau$ 的非默认参数元组中，选择与默认元组差异字段最少的那个。使用最小字典序索引来打破平局。如果不存在这样的元组，则结果为“无解”。\n- **测试套件：**\n  - 案例A：$q_A=$ \"MAVKDLGATYVAGLSERAGADVVVVNTDAGKSTLLNQLAGLDKTTELWAVDAGHNTMPNVIAGLKMKDGKKLSALDAGADLLSVTNPADKVIAGLEGA\", $t_A=$ \"LVIRDLGCTFIAGLTERTGVDIIVVNKDAGKSALLSQLSGIDETTELYAVDSGHNTLPNVVSGIKMREGKKLTALDAGKDLLTITNPKDKILAGMEGS\", $n_A = 10^6$。\n  - 案例B：$q_B=$ \"WQFPCHMNRTYGPADKSVYHCRWTQGPNTRHACDYKMPLWQHTRNYGACDPKTYRH\", $t_B=$ \"IVLVMAGTALLLVALGLTGATAAAVVLVALGLTVAIVGLALVVVVLAIVVVLVVV\", $n_B = 10^6$。\n  - 案例C：$q_C=$ \"ADKQLVQKAKLAEQAERYDDMAAAMKAVTEQGHELSNEERNLLSVAYKNVVGARRSSWR\", $t_C=$ \"AEKQLVQRAKLAEQAERYDEMAEALKKVTEQGHELSNDEKDLLSVAYKNVVNARRATWR\", $n_C = 10^6$。\n  - 案例D：$q_D=$ \"GPWKVVVVAGHGISDLGKTKAVAI\", $t_D=$ \"GSWKIIVVAGHGITDLGKSRAIAL\", $n_D = 10^6$。\n- **输出：** 一个包含四个零基整数索引的单行列表，例如 `[i_A,i_B,i_C,i_D]`。索引为 $-1$ 表示未找到解决方案。\n\n**第二步：使用提取的已知信息进行验证**\n\n该问题具有科学依据，定义明确且客观。它提供了一个简化但正确的BLASTP算法模型，其根植于生物信息学的既定原则，如对数优势评分矩阵、种子-延伸启发式方法、通过动态规划（Smith–Waterman）进行的局部比对以及用于显著性估计的Karlin–Altschul统计。所有必需的数据、参数和算法都得到了明确无误的规定。选择规则是确定性的，确保了唯一解。对于给定的序列长度，计算任务量大但可行。该问题未违反任何无效标准。\n\n**第三步：结论与行动**\n\n问题有效。将构建一个解决方案。\n\n**基于原则的设计**\n\n任务是实现一个简化的类BLASTP同源性搜索工具，并用它来为几个测试用例找到一个最优的非默认参数配置以检测同源性。解决方案将通过系统地评估一个离散的参数空间，对每个参数集应用完整的种子-延伸比对程序，并根据一个明确定义的规则选择最佳集合来推进。\n\n首先，我们建立参数空间。有 $3$ 个评分家族、$2$ 个词长、$2$ 个空位开放罚分、$2$ 个空位延伸罚分和 $2$ 个基于成分的统计标志。这总共产生了 $3 \\times 2 \\times 2 \\times 2 \\times 2 = 48$ 个参数元组。这些元组按字典序枚举：(family, $w$, $g_o$, $g_e$, $c$)。默认元组指定为 $(\\mathrm{MEDIUM}, 3, 11, 1, 1)$。\n\n对于每个测试用例（一个查询序列 $q$、一个目标序列 $t$ 和一个有效数据库大小 $n$），我们遍历所有 $48$ 个参数元组。设 $m$ 为查询序列的长度。对于每个非默认元组，执行以下过程：\n\n**1. 播种：**\n算法首先搜索“词命中”或种子。大小为 $w$ 的词是序列的短子串。我们考虑来自查询序列的所有 $w$-mer 和来自目标序列的所有 $w$-mer。对于每对 $w$-mer，一个来自查询序列 ($q_{i...i+w-1}$)，一个来自目标序列 ($t_{j...j+w-1}$)，计算种子分数为比对的氨基酸的替换分数之和：$\\sum_{k=0}^{w-1} s_{\\mathrm{family}}(q_{i+k}, t_{j+k})$。替换分数 $s_{\\mathrm{family}}(x, y)$ 由当前激活的评分家族（LOOSE、MEDIUM 或 STRICT）确定。如果此种子分数达到或超过指定的阈值 $T(\\mathrm{family}, w)$，则找到了一个种子。如果在整个序列对中没有找到种子，则丢弃此参数元组，我们继续下一个。\n\n**2. 使用带仿射空位的Smith-Waterman算法进行延伸：**\n如果找到了至少一个种子，我们继续寻找完整查询序列和目标序列之间的最优局部比对分数 $S$。这是通过使用Smith-Waterman动态规划算法实现的，该算法为仿射空位罚分进行了修改。仿射空位罚分模型对开放一个空位使用较高的代价 ($g_o$)，而对延伸它使用较低的代价 ($g_e$)。这使用三个动态规划矩阵实现：$H(i,j)$ 表示在 $(i,j)$ 处结束（无论是匹配/错配还是关闭空位）的最佳分数， $E(i,j)$ 表示以查询序列中的空位结束的最佳分数， $F(i,j)$ 表示以目标序列中的空位结束的最佳分数。\n设 $q_i$ 和 $t_j$ 分别是查询序列和目标序列在位置 $i$ 和 $j$ 的氨基酸。递推关系如下，对于 $i=1...m$ 和 $j=1...|t|$：\n$$F(i,j) = \\max \\left\\{ H(i-1, j) - g_o, F(i-1, j) - g_e \\right\\}$$\n$$E(i,j) = \\max \\left\\{ H(i, j-1) - g_o, E(i, j-1) - g_e \\right\\}$$\n$$H(i,j) = \\max \\left\\{ H(i-1, j-1) + s(q_i, t_j), E(i,j), F(i,j), 0 \\right\\}$$\n基本情况是对于所有 $i,j$，$H(0,j) = H(i,0) = 0$。最终的局部比对分数 $S$ 是在 $H$ 矩阵中找到的最大值：$S = \\max_{i,j} H(i,j)$。\n\n**3. 统计显著性：**\n使用Karlin-Altschul E值公式评估原始分数 $S$ 的统计显著性：\n$$E = K m n e^{-\\lambda S}$$\n这里，$m$ 是查询序列长度，$n$ 是有效数据库长度，$\\lambda$ 和 $K$ 是特定于评分系统的统计参数。如果一个结果的E值 $E$ 小于或等于阈值 $\\tau$（给定为 $0.01$），则该结果被认为是统计显著的。\n\n**4. 参数选择：**\n收集所有通过播种阶段并产生显著E值（$E \\le 0.01$）的非默认参数元组。在这些成功的元组中，我们应用选择规则：\n- 首先，为每个成功的元组计算“差异”，定义为与默认元组 $(\\mathrm{MEDIUM}, 3, 11, 1, 1)$ 不同的字段数。\n- 确定在所有成功元组中找到的最小差异。\n- 最终选择的元组是那个达到此最小差异且在所有并列项中具有最小字典序索引的元组。如果没有非默认元组产生显著命中，则该测试用例的结果为 $-1$。\n\n对所提供的四个测试用例中的每一个都重复此整个过程，并将所选参数元组的零基索引记录为该案例的最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements a simplified BLASTP model to find optimal parameters for homology detection.\n    \"\"\"\n\n    # --- Problem Definition  Constants ---\n\n    AA_GROUPS = {\n        'A': 'Hydrophobic', 'V': 'Hydrophobic', 'I': 'Hydrophobic', 'L': 'Hydrophobic',\n        'M': 'Hydrophobic', 'F': 'Hydrophobic', 'W': 'Hydrophobic', 'Y': 'Hydrophobic',\n        'S': 'Polar uncharged', 'T': 'Polar uncharged', 'N': 'Polar uncharged',\n        'Q': 'Polar uncharged', 'C': 'Polar uncharged',\n        'D': 'Acidic', 'E': 'Acidic',\n        'K': 'Basic', 'R': 'Basic', 'H': 'Basic',\n        'G': 'Special', 'P': 'Special'\n    }\n\n    # Parameter space definition\n    FAMILIES = ['LOOSE', 'MEDIUM', 'STRICT']\n    WORD_SIZES = [2, 3]\n    GAP_OPENS = [9, 11]\n    GAP_EXTENDS = [1, 2]\n    COMP_STATS = [0, 1]\n\n    # Generate parameter space in lexicographic order\n    param_space = []\n    for family in FAMILIES:\n        for w in WORD_SIZES:\n            for g_o in GAP_OPENS:\n                for g_e in GAP_EXTENDS:\n                    for c in COMP_STATS:\n                        param_space.append((family, w, g_o, g_e, c))\n\n    DEFAULT_PARAMS = ('MEDIUM', 3, 11, 1, 1)\n\n    SCORING_RULES = {\n        'LOOSE': {'match': 5, 'same_group': 2, 'diff_group': -2},\n        'MEDIUM': {'match': 4, 'same_group': 1, 'diff_group': -3},\n        'STRICT': {'match': 6, 'same_group': 0, 'diff_group': -4},\n    }\n\n    SEED_THRESHOLDS = {\n        ('LOOSE', 2): 6, ('LOOSE', 3): 10,\n        ('MEDIUM', 2): 8, ('MEDIUM', 3): 12,\n        ('STRICT', 2): 10, ('STRICT', 3): 15,\n    }\n\n    STAT_CONSTANTS = {\n        'LOOSE': {'lambda': 0.27, 'K': 0.07},\n        'MEDIUM': {'lambda': 0.318, 'K': 0.13},\n        'STRICT': {'lambda': 0.35, 'K': 0.16},\n    }\n\n    E_VALUE_THRESHOLD = 0.01\n\n    test_cases = [\n        (\"MAVKDLGATYVAGLSERAGADVVVVNTDAGKSTLLNQLAGLDKTTELWAVDAGHNTMPNVIAGLKMKDGKKLSALDAGADLLSVTNPADKVIAGLEGA\",\n         \"LVIRDLGCTFIAGLTERTGVDIIVVNKDAGKSALLSQLSGIDETTELYAVDSGHNTLPNVVSGIKMREGKKLTALDAGKDLLTITNPKDKILAGMEGS\",\n         10**6),\n        (\"WQFPCHMNRTYGPADKSVYHCRWTQGPNTRHACDYKMPLWQHTRNYGACDPKTYRH\",\n         \"IVLVMAGTALLLVALGLTGATAAAVVLVALGLTVAIVGLALVVVVLAIVVVLVVV\",\n         10**6),\n        (\"ADKQLVQKAKLAEQAERYDDMAAAMKAVTEQGHELSNEERNLLSVAYKNVVGARRSSWR\",\n         \"AEKQLVQRAKLAEQAERYDEMAEALKKVTEQGHELSNDEKDLLSVAYKNVVNARRATWR\",\n         10**6),\n        (\"GPWKVVVVAGHGISDLGKTKAVAI\",\n         \"GSWKIIVVAGHGITDLGKSRAIAL\",\n         10**6),\n    ]\n\n    # --- Helper Functions ---\n\n    memoized_score_funcs = {}\n    def get_score_func(family):\n        if family in memoized_score_funcs:\n            return memoized_score_funcs[family]\n\n        rules = SCORING_RULES[family]\n        \n        memoized_scores = {}\n        all_aas = list(AA_GROUPS.keys())\n        for i in range(len(all_aas)):\n            for j in range(i, len(all_aas)):\n                aa1, aa2 = all_aas[i], all_aas[j]\n                if aa1 == aa2:\n                    score = rules['match']\n                elif AA_GROUPS[aa1] == AA_GROUPS[aa2]:\n                    score = rules['same_group']\n                else:\n                    score = rules['diff_group']\n                memoized_scores[(aa1, aa2)] = score\n                memoized_scores[(aa2, aa1)] = score\n        \n        def score_func(aa1, aa2):\n            return memoized_scores[(aa1, aa2)]\n            \n        memoized_score_funcs[family] = score_func\n        return score_func\n\n    def check_seeding(query, subject, w, score_func, T):\n        len_q, len_s = len(query), len(subject)\n        for i in range(len_q - w + 1):\n            for j in range(len_s - w + 1):\n                seed_score = sum(score_func(query[i + k], subject[j + k]) for k in range(w))\n                if seed_score >= T:\n                    return True\n        return False\n\n    def smith_waterman_affine(query, subject, score_func, g_o, g_e):\n        m, n = len(query), len(subject)\n        H = np.zeros((m + 1, n + 1), dtype=np.int32)\n        E = np.zeros((m + 1, n + 1), dtype=np.int32)\n        F = np.zeros((m + 1, n + 1), dtype=np.int32)\n        \n        max_score = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # Gap in subject (deletion in query)\n                F[i, j] = max(H[i - 1, j] - g_o, F[i - 1, j] - g_e)\n                # Gap in query (insertion in subject)\n                E[i, j] = max(H[i, j - 1] - g_o, E[i, j - 1] - g_e)\n                \n                match_score = H[i - 1, j - 1] + score_func(query[i - 1], subject[j - 1])\n                H[i, j] = max(0, match_score, E[i, j], F[i, j])\n                \n                if H[i, j] > max_score:\n                    max_score = H[i, j]\n        \n        return int(max_score)\n\n    def calculate_diff_from_default(params):\n        diff = 0\n        for i in range(len(params)):\n            if params[i] != DEFAULT_PARAMS[i]:\n                diff += 1\n        return diff\n\n    # --- Main Logic ---\n\n    final_results = []\n    for query, subject, n_eff in test_cases:\n        m = len(query)\n        successful_params = []\n\n        for i, params in enumerate(param_space):\n            if params == DEFAULT_PARAMS:\n                continue\n\n            family, w, g_o, g_e, c = params\n            \n            score_func = get_score_func(family)\n            T = SEED_THRESHOLDS[(family, w)]\n\n            has_seed = check_seeding(query, subject, w, score_func, T)\n            if not has_seed:\n                continue\n            \n            S = smith_waterman_affine(query, subject, score_func, g_o, g_e)\n            \n            if S == 0:\n                continue\n\n            stat_p = STAT_CONSTANTS[family]\n            lambda_val, K_val = stat_p['lambda'], stat_p['K']\n            \n            # E = K * m * n * e^(-lambda * S)\n            try:\n                # Use high precision for intermediate exponent calculation\n                exponent = -lambda_val * float(S)\n                if exponent < -700: # Avoid underflow with math.exp\n                    e_value = 0.0\n                else:\n                    e_value = K_val * m * n_eff * math.exp(exponent)\n            except OverflowError:\n                continue\n\n            if e_value <= E_VALUE_THRESHOLD:\n                diff = calculate_diff_from_default(params)\n                successful_params.append({'index': i, 'diff': diff})\n\n        if not successful_params:\n            final_results.append(-1)\n        else:\n            min_diff = min(p['diff'] for p in successful_params)\n            \n            # Find the first one (lexicographically smallest index) with min_diff\n            best_param = next(p for p in successful_params if p['diff'] == min_diff)\n            final_results.append(best_param['index'])\n            \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "2376047"}]}