{"hands_on_practices": [{"introduction": "系统发育似然值的计算是分子进化的核心引擎。这项练习将带你深入了解Felsenstein剪枝算法的内部工作原理，通过一个具体的数值计算 [@problem_id:2747174]，展示单个位点的特定速率 $r$ 如何直接修改分支长度，并最终决定父节点的偏好似然值得分。这是一个理解速率异质性如何在最基础层面影响系统发育推断的绝佳实践。", "problem": "考虑一个在二叉系统发育树上，根据 Jukes–Cantor 1969 (JC69) 核苷酸替换模型演化的单个位点。设一个内部节点 $v$ 有两个子节点 $c_{1}$ 和 $c_{2}$，它们通过长度相等的边相连，边长为 $t = 0.2$（单位为每个位点的期望替换数）。假设位点间的速率异质性通过一个具有相对速率的有限类别混合模型进行建模，并且该位点属于相对速率为 $r = 1.5$ 的类别。对于 JC69 模型，沿着长度为 $t$ 的边的转移概率由下式给出\n$$\nP_{xy}(t) \\;=\\; \\frac{1}{4} \\;+\\; \\left(\\delta_{xy} - \\frac{1}{4}\\right)\\exp\\!\\left(-\\frac{4t}{3}\\right),\n$$\n其中 $\\delta_{xy}$ 是克罗内克 δ (Kronecker delta)。对于相对速率 $r$，有效分支长度会按 $r$ 进行缩放，即用 $rt$ 代替 $t$。\n\n假设在子节点处，针对该位点和该类别评估的部分似然向量为\n$$\n\\boldsymbol{L}^{(1)} \\;=\\; \\big(L^{(1)}_{A},L^{(1)}_{C},L^{(1)}_{G},L^{(1)}_{T}\\big) \\;=\\; (0.8,\\,0.1,\\,0.05,\\,0.05),\n$$\n$$\n\\boldsymbol{L}^{(2)} \\;=\\; \\big(L^{(2)}_{A},L^{(2)}_{C},L^{(2)}_{G},L^{(2)}_{T}\\big) \\;=\\; (0.2,\\,0.3,\\,0.4,\\,0.1),\n$$\n核苷酸顺序为 $(A,C,G,T)$。\n\n使用核苷酸上的连续时间同质马尔可夫链的剪枝递归算法，\n$$\nL_{v}(x) \\;=\\; \\prod_{i=1}^{2}\\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{xy}(rt)\\,L^{(i)}_{y}\\right),\n$$\n数值计算父节点的部分似然 $L_{v}(A)$。将最终答案四舍五入至六位有效数字。将答案表示为不带单位的纯数。", "solution": "经评估，问题陈述有效。其科学基础为分子系统发育学原理，问题适定、客观且内部一致。所有必要的数据和公式均已提供，可用于计算唯一的、有意义的解。因此，我们可以进行计算。\n\n目标是根据内部节点 $v$ 的两个子节点 $c_{1}$ 和 $c_{2}$ 的部分似然，计算节点 $v$ 的部分似然 $L_{v}(A)$。节点 $v$ 的状态被指定为核苷酸 $A$。\n\n提供的剪枝递归公式为：\n$$\nL_{v}(x) \\;=\\; \\prod_{i=1}^{2}\\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{xy}(rt)\\,L^{(i)}_{y}\\right)\n$$\n对于特定状态 $x=A$，该公式变为：\n$$\nL_{v}(A) \\;=\\; \\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(1)}_{y}\\right) \\times \\left(\\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(2)}_{y}\\right)\n$$\n让我们将乘积中的两项表示为 $S_{1}$ 和 $S_{2}$：\n$$\nS_{1} \\;=\\; \\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(1)}_{y}\n$$\n$$\nS_{2} \\;=\\; \\sum_{y\\in\\{A,C,G,T\\}} P_{Ay}(rt)\\,L^{(2)}_{y}\n$$\n所以，$L_{v}(A) = S_{1} \\times S_{2}$。\n\n首先，我们计算有效分支长度。给定的分支长度为 $t = 0.2$，特定位点的相对速率为 $r = 1.5$。因此，有效分支长度为：\n$$\nt_{\\text{eff}} \\;=\\; rt \\;=\\; 1.5 \\times 0.2 \\;=\\; 0.3\n$$\n接下来，我们确定在此有效分支长度下，Jukes-Cantor (JC69) 模型的转移概率。通用公式为：\n$$\nP_{xy}(t_{\\text{eff}}) \\;=\\; \\frac{1}{4} \\;+\\; \\left(\\delta_{xy} - \\frac{1}{4}\\right)\\exp\\!\\left(-\\frac{4t_{\\text{eff}}}{3}\\right)\n$$\n其中 $\\delta_{xy}$ 是克罗内克 δ (Kronecker delta)。我们关心的是从状态 $A$ 到状态 $y \\in \\{A,C,G,T\\}$ 的转移。\n\n指数函数的参数为：\n$$\n-\\frac{4t_{\\text{eff}}}{3} \\;=\\; -\\frac{4 \\times 0.3}{3} \\;=\\; -0.4\n$$\n对于从 $A$ 到 $A$ 的转移（匹配），$\\delta_{AA} = 1$：\n$$\nP_{AA}(0.3) \\;=\\; \\frac{1}{4} \\;+\\; \\left(1 - \\frac{1}{4}\\right)\\exp(-0.4) \\;=\\; 0.25 \\;+\\; 0.75\\exp(-0.4)\n$$\n对于从 $A$ 到任何其他核苷酸 $y \\in \\{C,G,T\\}$ 的转移（错配），$\\delta_{Ay} = 0$：\n$$\nP_{Ay}(0.3) \\;=\\; \\frac{1}{4} \\;+\\; \\left(0 - \\frac{1}{4}\\right)\\exp(-0.4) \\;=\\; 0.25 \\;-\\; 0.25\\exp(-0.4)\n$$\n让我们用 $P_{A \\to A} = P_{AA}(0.3)$ 表示匹配概率，用 $P_{A \\to \\text{mismatch}} = P_{Ay}(0.3)$ 表示错配概率（对于 $y \\ne A$）。\n\n现在我们计算 $S_{1}$ 和 $S_{2}$。子节点 $c_{1}$ 的部分似然向量为 $\\boldsymbol{L}^{(1)} = (0.8,\\,0.1,\\,0.05,\\,0.05)$。\n$$\nS_{1} \\;=\\; P_{AA}(0.3)L^{(1)}_{A} \\;+\\; P_{AC}(0.3)L^{(1)}_{C} \\;+\\; P_{AG}(0.3)L^{(1)}_{G} \\;+\\; P_{AT}(0.3)L^{(1)}_{T}\n$$\n$$\nS_{1} \\;=\\; P_{A \\to A} \\cdot L^{(1)}_{A} \\;+\\; P_{A \\to \\text{mismatch}} \\cdot (L^{(1)}_{C} + L^{(1)}_{G} + L^{(1)}_{T})\n$$\n代入数值：\n$L^{(1)}_{A} = 0.8$，且 $L^{(1)}_{C} + L^{(1)}_{G} + L^{(1)}_{T} = 0.1 + 0.05 + 0.05 = 0.2$。\n$$\nS_{1} \\;=\\; \\left(0.25 + 0.75\\exp(-0.4)\\right) \\times 0.8 \\;+\\; \\left(0.25 - 0.25\\exp(-0.4)\\right) \\times 0.2\n$$\n$$\nS_{1} \\;=\\; 0.2 + 0.6\\exp(-0.4) \\;+\\; 0.05 - 0.05\\exp(-0.4)\n$$\n$$\nS_{1} \\;=\\; 0.25 \\;+\\; 0.55\\exp(-0.4)\n$$\n子节点 $c_{2}$ 的部分似然向量为 $\\boldsymbol{L}^{(2)} = (0.2,\\,0.3,\\,0.4,\\,0.1)$。\n$$\nS_{2} \\;=\\; P_{A \\to A} \\cdot L^{(2)}_{A} \\;+\\; P_{A \\to \\text{mismatch}} \\cdot (L^{(2)}_{C} + L^{(2)}_{G} + L^{(2)}_{T})\n$$\n代入数值：\n$L^{(2)}_{A} = 0.2$，且 $L^{(2)}_{C} + L^{(2)}_{G} + L^{(2)}_{T} = 0.3 + 0.4 + 0.1 = 0.8$。\n$$\nS_{2} \\;=\\; \\left(0.25 + 0.75\\exp(-0.4)\\right) \\times 0.2 \\;+\\; \\left(0.25 - 0.25\\exp(-0.4)\\right) \\times 0.8\n$$\n$$\nS_{2} \\;=\\; 0.05 + 0.15\\exp(-0.4) \\;+\\; 0.2 - 0.2\\exp(-0.4)\n$$\n$$\nS_{2} \\;=\\; 0.25 \\;-\\; 0.05\\exp(-0.4)\n$$\n现在，我们计算最终的部分似然 $L_{v}(A) = S_{1} \\times S_{2}$：\n$$\nL_{v}(A) \\;=\\; \\left(0.25 + 0.55\\exp(-0.4)\\right) \\times \\left(0.25 - 0.05\\exp(-0.4)\\right)\n$$\n展开这个乘积：\n$$\nL_{v}(A) \\;=\\; 0.25^{2} \\;-\\; 0.25 \\times 0.05\\exp(-0.4) \\;+\\; 0.55\\exp(-0.4) \\times 0.25 \\;-\\; 0.55\\exp(-0.4) \\times 0.05\\exp(-0.4)\n$$\n$$\nL_{v}(A) \\;=\\; 0.0625 \\;+\\; \\left(0.1375 - 0.0125\\right)\\exp(-0.4) \\;-\\; 0.0275\\exp(-0.8)\n$$\n$$\nL_{v}(A) \\;=\\; 0.0625 \\;+\\; 0.125\\exp(-0.4) \\;-\\; 0.0275\\exp(-0.8)\n$$\n现在我们代入指数项的数值。\n$$\n\\exp(-0.4) \\approx 0.6703200458\n$$\n$$\n\\exp(-0.8) \\approx 0.4493289641\n$$\n将这些值代入 $L_{v}(A)$ 的表达式中：\n$$\nL_{v}(A) \\approx 0.0625 \\;+\\; 0.125 \\times 0.6703200458 \\;-\\; 0.0275 \\times 0.4493289641\n$$\n$$\nL_{v}(A) \\approx 0.0625 \\;+\\; 0.0837900057 \\;-\\; 0.0123565465\n$$\n$$\nL_{v}(A) \\approx 0.1462900057 \\;-\\; 0.0123565465\n$$\n$$\nL_{v}(A) \\approx 0.1339334592\n$$\n题目要求将答案四舍五入到六位有效数字。前六位有效数字是 $1, 3, 3, 9, 3, 3$。第七位数字是 $4$，小于 $5$，因此我们向下舍入。\n$$\nL_{v}(A) \\approx 0.133933\n$$", "answer": "$$\n\\boxed{0.133933}\n$$", "id": "2747174"}, {"introduction": "理解一个生成模型的最好方法之一就是亲手实现它。这项练习 [@problem_id:2747214] 指导你构建一个考虑了位点间速率异质性的序列演化模拟器。通过这个过程，你将直观地看到抽象的$\\Gamma$分布如何转化为具体的DNA序列比对数据，并学会如何验证模拟过程的准确性，从而加深对演化过程随机性的理解。", "problem": "你需要实现一个完整且可复现的算法，该算法使用 Jukes–Cantor $1969$ (JC$69$) 模型，在具有均值为一、跨位点伽马分布速率异质性（记为 JC$69$+$\\Gamma$）的条件下，模拟固定有根树下的 DNA 序列演化。然后，你需要验证所实现的位点速率分布。该实现必须遵循连续时间马尔可夫链的构建方式。\n\n从以下基础开始：\n- 一个在有限状态空间上的连续时间马尔可夫链，其瞬时速率矩阵为 $Q$，沿着长度为 $t$ 的分支演化，其转移概率矩阵为 $P(t) = \\exp(Qt)$，其中 $\\exp$ 表示矩阵指数。\n- JC$69$ 模型的稳态碱基频率相等，即对于 $i \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 有 $\\pi_i = 1/4$，其瞬时速率矩阵 $Q$ 满足：当 $i \\neq j$ 时，$Q_{ij} = \\mu$；当 $i = j$ 时，$Q_{ii} = -3\\mu$。该矩阵经过缩放，使得平均替换率为 $1$，即 $\\sum_i \\pi_i (-Q_{ii}) = 1$，这意味着 $\\mu = 1/3$。\n- 在 JC$69$ 模型下，沿时间 $t$ 的转移概率有一个闭式解：当 $i=j$ 时，$P_{ii}(t) = 1/4 + 3/4 \\exp(-4t/3)$；当 $i \\neq j$ 时，$P_{ij}(t) = 1/4 - 1/4 \\exp(-4t/3)$。\n- 对于跨位点伽马分布的速率异质性，特定位点的速率 $r$ 从一个伽马分布中抽样，其形状参数为 $\\alpha$，尺度参数为 $\\theta$，使得均值为一，即 $\\mathbb{E}[r] = \\alpha \\theta = 1$。设定 $\\theta = 1/\\alpha$，因此 $\\operatorname{Var}(r) = \\alpha \\theta^2 = 1/\\alpha$。\n\n算法规格：\n- 状态空间设为 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$，编码为 $\\{0,1,2,3\\}$。\n- 对每个位点 $s \\in \\{1,\\dots,S\\}$，从 $\\text{Gamma}(\\alpha, \\theta)$（其中 $\\theta = 1/\\alpha$）中抽样一个速率 $r_s$。\n- 对每个位点独立地，通过从稳态分布 $(1/4,1/4,1/4,1/4)$ 中抽样来分配根节点的状态。\n- 对于每个分支长度为 $t_{uv}$ 且给定站点速率为 $r_s$ 的有向边 $(u \\to v)$，通过从在有效时间 $r_s t_{uv}$（即 $P(r_s t_{uv})$）下计算的 JC$69$ 转移矩阵的对应行中抽样，将状态从父节点 $u$ 传播到子节点 $v$。\n- 对于任何长度为 $t=0$ 的分支，强制 $P(0)$ 等于单位矩阵，因此子节点必须以概率 $1$ 继承父节点的状态。\n\n树与参数：\n- 使用一个有根树，其节点集为 $\\{0,1,2,3,4\\}$，根节点为 $0$，有向边包括长度为 $t_{01} = 0.1$ 的 $(0 \\to 1)$，长度为 $t_{12} = 0.3$ 的 $(1 \\to 2)$，长度为 $t_{13} = 0.3$ 的 $(1 \\to 3)$，以及长度为 $t_{04} = 0.2$ 的 $(0 \\to 4)$。叶节点为 $\\{2,3,4\\}$。所有分支长度均以在均值速率为 $1$ 的情况下每个位点的预期替换数来衡量。\n- 对所有随机抽样使用固定的伪随机数生成器种子 $20231105$，以确保可复现性。\n\n实现的速率分布的验证：\n- 给定 $S$ 个抽样速率 $\\{r_s\\}_{s=1}^S$，计算样本均值 $\\bar r = \\frac{1}{S}\\sum_{s=1}^S r_s$ 和无偏样本方差 $s^2 = \\frac{1}{S-1}\\sum_{s=1}^S (r_s - \\bar r)^2$。\n- 对于给定的 $\\alpha$，使用绝对误差容忍度 $\\varepsilon_{\\text{mean}}$ 和 $\\varepsilon_{\\text{var}}$，将 $\\bar r$ 与理论均值 $1$ 进行比较，将 $s^2$ 与理论方差 $1/\\alpha$ 进行比较。\n- 此外，通过检查以下条件来验证 JC$69$ 转移矩阵的构造：对于任意正速率 $r$ 和时间 $t$，$P(rt)$ 的每一行之和在一个小的容忍度范围内为 $1$；并且 $P(0)$ 在一个小的容忍度范围内是单位矩阵。\n\n你的程序必须实现上述算法，并生成一个单行输出，该输出将以下测试套件的结果汇总为一个用方括号括起来的逗号分隔列表：\n\n- 测试 1（速率验证，高异质性）：$\\alpha = 0.5$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.01$，$\\varepsilon_{\\text{var}} = 0.05$。输出一个布尔值，指示 $|\\bar r - 1| \\le 0.01$ 和 $|s^2 - 2.0| \\le 0.05$ 是否同时成立。\n- 测试 2（速率验证，低异质性）：$\\alpha = 5.0$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.005$，$\\varepsilon_{\\text{var}} = 0.01$。输出一个布尔值，指示 $|\\bar r - 1| \\le 0.005$ 和 $|s^2 - 0.2| \\le 0.01$ 是否同时成立。\n- 测试 3（转移矩阵随机性）：对于 $N = 25$ 对独立抽样的 $(r,t)$，其中 $r$ 在 $[0,3]$ 上均匀分布，$t$ 在 $[0,2]$ 上均匀分布，计算 $P(rt)$ 并检查行和与 $1$ 的最大绝对偏差是否最多为 $\\varepsilon_{\\text{row}} = 10^{-12}$。输出一个布尔值，指示此条件是否在所有 $N$ 次抽样中都成立。\n- 测试 4（零分支单位矩阵）：对于 $N = 25$ 个在 $[0,3]$ 上均匀分布的独立抽样速率 $r$，检查 $P(0)$ 是否等于单位矩阵，且最大逐项绝对偏差最多为 $\\varepsilon_{\\text{id}} = 10^{-12}$。输出一个布尔值，指示此条件是否在所有 $N$ 次抽样中都成立。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中按顺序包含四个测试用例的布尔结果，格式为用方括号括起来的逗号分隔列表（例如，`[true,false,true,true]`，但使用 Python 的布尔值格式）。不应产生任何其他输出。", "solution": "我们根据连续时间马尔可夫链的基本原理以及 Jukes–Cantor $1969$ (JC$69$) 模型和伽马分布的性质来设计算法和验证方法。\n\n1. JC$69$ 速率矩阵缩放与转移概率：\n   - 在 JC$69$ 模型中，瞬时速率矩阵 $Q$ 的非对角线元素为 $Q_{ij} = \\mu$（当 $i \\neq j$），对角线元素为 $Q_{ii} = -3\\mu$。稳态分布是均匀的，即 $\\pi = (1/4,1/4,1/4,1/4)$。\n   - 在稳态下的平均替换率为 $\\sum_{i=1}^4 \\pi_i (-Q_{ii}) = \\sum_{i=1}^4 (1/4) \\cdot 3\\mu = 3\\mu$。为了强制单位时间的平均替换率为 $1$，我们设定 $3\\mu = 1$，因此 $\\mu = 1/3$。\n   - JC$69$ 模型的转移概率矩阵 $P(t) = \\exp(Qt)$ 有一个闭式解：\n     - 当 $i=j$ 时，$P_{ii}(t) = 1/4 + 3/4 \\exp(-4t/3)$。\n     - 当 $i \\neq j$ 时，$P_{ij}(t) = 1/4 - 1/4 \\exp(-4t/3)$。\n     这可以从 $Q$ 的谱分解中得出，其中有一个特征值为 $0$，其特征向量为 $\\mathbf{1}$，在正交子空间上有三个相同的特征值 $-4/3$，从而得到上述表达式。\n\n2. 通过伽马分布实现跨位点速率异质性：\n   - 令 $r$ 表示特定位点的相对速率。为模拟异质性，我们从 $\\text{Gamma}(\\alpha, \\theta)$ 分布中抽样 $r$，其中 $\\alpha$ 为形状参数，$\\theta$ 为尺度参数。\n   - 我们选择 $\\theta = 1/\\alpha$，使得 $\\mathbb{E}[r] = \\alpha \\theta = \\alpha \\cdot (1/\\alpha) = 1$，即平均速率为一。\n   - 方差为 $\\operatorname{Var}(r) = \\alpha \\theta^2 = \\alpha \\cdot (1/\\alpha^2) = 1/\\alpha$，这是验证的关键理论目标。\n\n3. 沿树逐位点的连续时间马尔可夫链演化：\n   - 对每个位点 $s \\in \\{1,\\dots,S\\}$：\n     - 从 $\\text{Gamma}(\\alpha, 1/\\alpha)$ 中抽样 $r_s$。\n     - 从 $\\pi = (1/4,1/4,1/4,1/4)$ 中抽样根节点的状态。\n     - 对于每个长度为 $t_{uv}$ 的分支 $(u \\to v)$，计算有效时间 $\\tau_{uv,s} = r_s t_{uv}$，并使用上述闭式解构建 JC$69$ 转移矩阵 $P(\\tau_{uv,s})$。然后，根据父节点状态索引的 $P(\\tau_{uv,s})$ 的行所给出的分类分布，对子节点 $v$ 的状态进行抽样。\n   - 这个过程与连续时间马尔可夫链的时间变换性质是一致的：沿每个分支将时间按 $r_s$ 缩放，等同于将生成元按 $r_s$ 缩放，这正是使用特定位点速率的效果。\n\n4. 实现的速率分布的验证：\n   - 给定抽样的速率 $\\{r_s\\}$，计算样本均值 $\\bar r = \\frac{1}{S}\\sum_{s=1}^{S} r_s$ 和无偏样本方差 $s^2 = \\frac{1}{S-1}\\sum_{s=1}^{S} (r_s - \\bar r)^2$。\n   - 对于指定的 $\\alpha$，将 $\\bar r$ 与理论均值 $1$ 进行比较，将 $s^2$ 与理论方差 $1/\\alpha$ 进行比较。我们指定绝对误差容忍度 $\\varepsilon_{\\text{mean}}$ 和 $\\varepsilon_{\\text{var}}$，并要求 $|\\bar r - 1| \\le \\varepsilon_{\\text{mean}}$ 和 $|s^2 - 1/\\alpha| \\le \\varepsilon_{\\text{var}}$ 同时满足才能通过。\n   - 额外的算法验证可以加强其正确性：\n     - 随机性：对于任意 $r \\ge 0$ 和 $t \\ge 0$，计算出的 $P(rt)$ 的行和必须为 $1$。由于闭式解的构造强制了当 $i \\neq j$ 时，$P_{ii} = 1/4 + 3/4 e^{-4rt/3}$ 和 $P_{ij} = 1/4 - 1/4 e^{-4rt/3}$，因此在精确算术中，每行的和恰好为 $(1/4 + 3/4 e) + 3(1/4 - 1/4 e) = 1$。在浮点运算中，我们要求偏差不超过一个小的容忍度 $\\varepsilon_{\\text{row}}$。\n     - 零分支长度下的单位矩阵：对于任何速率 $r$，$P(r \\cdot 0) = P(0)$ 必须等于单位矩阵，即 $\\exp(Q \\cdot 0) = I$。从闭式解来看，代入 $t=0$ 得到 $e^{-4 \\cdot 0/3} = 1$，因此当 $i \\neq j$ 时，$P_{ii}(0) = 1/4 + 3/4 \\cdot 1 = 1$ 且 $P_{ij}(0) = 1/4 - 1/4 \\cdot 1 = 0$。我们在一个容忍度 $\\varepsilon_{\\text{id}}$ 内检查这一点。\n\n5. 测试套件设计与输出：\n   - 测试 1：$\\alpha = 0.5$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.01$，$\\varepsilon_{\\text{var}} = 0.05$。理论方差为 $1/\\alpha = 2.0$。输出一个布尔值的通过/失败结果。\n   - 测试 2：$\\alpha = 5.0$，$S = 200000$，$\\varepsilon_{\\text{mean}} = 0.005$，$\\varepsilon_{\\text{var}} = 0.01$。理论方差为 $1/\\alpha = 0.2$。输出一个布尔值的通过/失败结果。\n   - 测试 3：抽样 $N = 25$ 对 $(r,t)$，其中 $r \\sim \\text{Uniform}[0,3]$，$t \\sim \\text{Uniform}[0,2]$。对每一对，计算 $P(rt)$ 并检查行和与 $1$ 的最大绝对偏差是否最多为 $\\varepsilon_{\\text{row}} = 10^{-12}$。输出一个布尔值，指示所有抽样是否都通过。\n   - 测试 4：抽样 $N = 25$ 个速率 $r \\sim \\text{Uniform}[0,3]$，并验证 $P(0)$ 在 $\\varepsilon_{\\text{id}} = 10^{-12}$ 的容忍度内等于单位矩阵。输出一个布尔值，指示所有抽样是否都通过。\n\n实现说明：\n- 使用固定的伪随机数种子 $20231105$ 以使结果具有确定性。\n- 在序列模拟程序中使用给定的带有分支长度的有根树；虽然分布验证不需要模拟序列，但必须按照描述实现序列模拟函数以反映该算法。\n- 最终程序必须打印单行，其中包含四个用方括号括起来并用逗号分隔的布尔结果，不含任何其他文本。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Fixed RNG for reproducibility as mandated by the problem statement.\nRNG = np.random.default_rng(20231105)\n\n# State mapping: 0,1,2,3 correspond to A,C,G,T (any consistent mapping suffices for JC69).\nNUM_STATES = 4\n\ndef draw_gamma_rates(n_sites: int, alpha: float, rng: np.random.Generator) - np.ndarray:\n    \"\"\"\n    Draw n_sites rates from Gamma(shape=alpha, scale=1/alpha) so that E[r]=1 and Var[r]=1/alpha.\n    \"\"\"\n    scale = 1.0 / alpha\n    return rng.gamma(shape=alpha, scale=scale, size=n_sites)\n\ndef jc69_transition_matrix(effective_time: float) - np.ndarray:\n    \"\"\"\n    Construct the JC69 transition matrix P(t) at time 'effective_time' = r * t.\n    JC69 scaling uses mu=1/3 so that average rate is 1, giving exponent -4 t / 3.\n    \"\"\"\n    e = np.exp(-4.0 * effective_time / 3.0)\n    P = np.full((NUM_STATES, NUM_STATES), 0.25 - 0.25 * e, dtype=float)\n    # Set diagonal entries\n    diag_val = 0.25 + 0.75 * e\n    for i in range(NUM_STATES):\n        P[i, i] = diag_val\n    return P\n\ndef simulate_sequences_on_tree(n_sites: int,\n                               alpha: float,\n                               edges: list[tuple[int, int, float]],\n                               root: int,\n                               rng: np.random.Generator) - dict[int, np.ndarray]:\n    \"\"\"\n    Simulate sequences under JC69+Gamma on a rooted directed tree.\n    edges: list of (parent, child, branch_length) with branch lengths in expected substitutions/site.\n    Returns a dictionary mapping node - sequence array of length n_sites with states in {0,1,2,3}.\n    \"\"\"\n    # Prepare adjacency and topological order from root.\n    children = {}\n    parents = {}\n    nodes = set([root])\n    for u, v, t in edges:\n        children.setdefault(u, []).append((v, t))\n        parents[v] = u\n        nodes.add(u); nodes.add(v)\n    # Derive a topological order (BFS from root suffices as edges are directed away from root).\n    topo_order = []\n    queue = [root]\n    visited = set()\n    while queue:\n        u = queue.pop(0)\n        if u in visited:\n            continue\n        visited.add(u)\n        topo_order.append(u)\n        for (v, _) in children.get(u, []):\n            queue.append(v)\n\n    # Draw site-specific rates.\n    rates = draw_gamma_rates(n_sites, alpha, rng)\n\n    # Initialize sequences per node.\n    seqs = {node: np.empty(n_sites, dtype=np.int8) for node in nodes}\n\n    # Root states sampled from stationary distribution (uniform over 4 states).\n    seqs[root] = rng.integers(low=0, high=NUM_STATES, size=n_sites, endpoint=False, dtype=np.int8)\n\n    # Propagate down the tree per site.\n    for u in topo_order:\n        for (v, t) in children.get(u, []):\n            parent_states = seqs[u]\n            child_states = np.empty(n_sites, dtype=np.int8)\n            if t == 0.0:\n                # Identity transition: child copies parent.\n                child_states[:] = parent_states\n            else:\n                # For each site, compute P(r*t) and sample child state conditional on parent state.\n                # To keep memory low, process in chunks.\n                chunk = 4096\n                for start in range(0, n_sites, chunk):\n                    end = min(start + chunk, n_sites)\n                    parent_chunk = parent_states[start:end]\n                    rates_chunk = rates[start:end]\n                    # For each site in chunk, compute P and sample.\n                    for idx in range(end - start):\n                        tau = rates_chunk[idx] * t\n                        P = jc69_transition_matrix(tau)\n                        p_row = P[parent_chunk[idx], :]\n                        # Sample according to probabilities in p_row.\n                        # Use choice with p; ensure numerical stability by normalizing.\n                        p_row = p_row / p_row.sum()\n                        child_states[start + idx] = rng.choice(NUM_STATES, p=p_row)\n            seqs[v] = child_states\n    return seqs\n\ndef sample_mean_and_unbiased_variance(x: np.ndarray) - tuple[float, float]:\n    \"\"\"\n    Return sample mean and unbiased sample variance (denominator n-1).\n    \"\"\"\n    mean = float(np.mean(x))\n    # Unbiased sample variance\n    var = float(np.var(x, ddof=1))\n    return mean, var\n\ndef test_rate_validation(alpha: float, n_sites: int, tol_mean: float, tol_var: float, rng: np.random.Generator) - bool:\n    \"\"\"\n    Draw rates and validate that sample mean and sample variance match 1 and 1/alpha within tolerances.\n    \"\"\"\n    rates = draw_gamma_rates(n_sites, alpha, rng)\n    mean, var = sample_mean_and_unbiased_variance(rates)\n    target_mean = 1.0\n    target_var = 1.0 / alpha\n    return (abs(mean - target_mean) = tol_mean) and (abs(var - target_var) = tol_var)\n\ndef test_stochasticity_row_sums(n_trials: int, tol_row: float, rng: np.random.Generator) - bool:\n    \"\"\"\n    Randomly draw rates and times, compute P(r*t), and check row sums within tolerance.\n    \"\"\"\n    max_dev = 0.0\n    for _ in range(n_trials):\n        r = rng.uniform(0.0, 3.0)\n        t = rng.uniform(0.0, 2.0)\n        P = jc69_transition_matrix(r * t)\n        row_sums = P.sum(axis=1)\n        dev = float(np.max(np.abs(row_sums - 1.0)))\n        if dev > max_dev:\n            max_dev = dev\n        if dev > tol_row:\n            return False\n    return True\n\ndef test_identity_zero_branch(n_trials: int, tol_id: float, rng: np.random.Generator) - bool:\n    \"\"\"\n    For random rates, check that P(0) equals identity within tolerance.\n    \"\"\"\n    I = np.eye(NUM_STATES)\n    for _ in range(n_trials):\n        _ = rng.uniform(0.0, 3.0)  # rate r (unused because t=0 forces tau=0)\n        P0 = jc69_transition_matrix(0.0)\n        if np.max(np.abs(P0 - I)) > tol_id:\n            return False\n    return True\n\ndef solve():\n    results = []\n\n    # Test 1: alpha=0.5, n_sites=200000, tol_mean=0.01, tol_var=0.05\n    res1 = test_rate_validation(alpha=0.5, n_sites=200000, tol_mean=0.01, tol_var=0.05, rng=RNG)\n    results.append(res1)\n\n    # Test 2: alpha=5.0, n_sites=200000, tol_mean=0.005, tol_var=0.01\n    res2 = test_rate_validation(alpha=5.0, n_sites=200000, tol_mean=0.005, tol_var=0.01, rng=RNG)\n    results.append(res2)\n\n    # Test 3: stochasticity of transition matrices, N=25, tol_row=1e-12\n    res3 = test_stochasticity_row_sums(n_trials=25, tol_row=1e-12, rng=RNG)\n    results.append(res3)\n\n    # Test 4: identity at zero branch length, N=25, tol_id=1e-12\n    res4 = test_identity_zero_branch(n_trials=25, tol_id=1e-12, rng=RNG)\n    results.append(res4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Implement the tree structure and simulation functions as required by the problem statement.\n# Although not directly used in the tests above (which focus on rate validation and matrix checks),\n# the following demonstrates the sequence simulation algorithm on the specified rooted tree.\ndef _demo_sequence_simulation():\n    # Rooted tree as specified: nodes {0,1,2,3,4}, root=0, edges with lengths.\n    root = 0\n    edges = [\n        (0, 1, 0.1),\n        (1, 2, 0.3),\n        (1, 3, 0.3),\n        (0, 4, 0.2),\n    ]\n    # Simulate a small alignment to verify procedure (not printed).\n    _ = simulate_sequences_on_tree(n_sites=10, alpha=0.5, edges=edges, root=root, rng=RNG)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2747214"}, {"introduction": "在实际的系统发育分析中，我们通常不知道哪个演化模型最适合我们的数据。这项练习 [@problem_id:2424572] 模拟了一个关键的生物信息学任务：模型选择。你将学习如何运用赤池信息准则（AIC）和贝叶斯信息准则（BIC）来权衡模型的拟合度和复杂性，从而在包括了速率异质性在内的多个模型中做出明智的选择。", "problem": "对于一个 DNA 序列比对，给定一个固定的无根系统发育树拓扑结构和支长，以及五个嵌套的时间可逆核苷酸替换模型：Jukes–Cantor (JC)、Hasegawa–Kishino–Yano (HKY)、带 Γ-分布位点速率异质性的 HKY (HKY+$\\Gamma$)、通用时间可逆 (GTR)，以及带 Γ-分布位点速率异质性和不变位点比例的 GTR (GTR+$\\Gamma$+I)。数据字母表大小为 $4$ (A, C, G, T)。用于近似 Γ 分布的离散类别数量已事先固定。模型复杂度仅计算替换过程的参数；树拓扑结构、支长和固定的 Γ 速率类别数量不计入其中。\n\n用于参数计数的模型定义：\n- JC：所有碱基频率相等，所有交换率相等。\n- HKY：不同的转换/颠换速率比和自由的稳态碱基频率。\n- GTR：完全通用的时间可逆交换率和自由的稳态碱基频率。\n- $\\Gamma$：由带有一个自由形状参数 $\\alpha$ 的 Γ 分布建模的连续位点速率异质性。\n- I：一个自由的不变位点比例 $p_I$。\n\n使用以下模型编码：\n- $0$: JC\n- $1$: HKY\n- $2$: HKY+$\\Gamma$\n- $3$: GTR\n- $4$: GTR+$\\Gamma$+I\n\n对于下面的每个数据集，给定比对长度 $n$（位点数）和在同一固定树上、五个模型下（按模型编码顺序 $0,1,2,3,4$）获得的最大化似然自然对数 $\\ln \\mathcal{L}$。您必须基于第一性原理，为每个数据集确定哪个模型最小化 Akaike 信息准则 (AIC)，哪个模型最小化贝叶斯信息准则 (BIC)。如果准则值完全相等，选择自由替换过程参数 $k$ 较少的模型；如果 $k$ 也相等，则选择较小的模型编码。\n\n测试套件（比对长度 $n$ 和模型 $0$ 到 $4$ 的对数似然向量 $(\\ln \\mathcal{L}_0,\\ln \\mathcal{L}_1,\\ln \\mathcal{L}_2,\\ln \\mathcal{L}_3,\\ln \\mathcal{L}_4)$）：\n- 数据集 $1$：$n = 500$，$( -1650.0,\\ -1585.0,\\ -1568.0,\\ -1565.0,\\ -1560.5 )$。\n- 数据集 $2$：$n = 50$，$( -540.0,\\ -505.0,\\ -500.0,\\ -499.2,\\ -493.0 )$。\n- 数据集 $3$：$n = 200$，$( -700.0,\\ -650.0,\\ -650.0,\\ -649.5,\\ -649.5 )$。\n- 数据集 $4$：$n = 10$，$( -120.0,\\ -120.0,\\ -120.0,\\ -120.0,\\ -120.0 )$。\n\n你的程序必须：\n- 基于第一性原理，根据给定的 $4$ 态字母表，推断每个模型的自由替换过程参数数量 $k$，并考虑稳态碱基频率概率和为 $1$ 的约束以及时间可逆模型中整体速率尺度的可识别性约束。当存在 $\\Gamma$ 时，为 Γ 形状 $\\alpha$ 计 $1$ 个参数；当存在 I 时，为不变位点比例 $p_I$ 计 $1$ 个参数。\n- 对每个数据集，计算最小化 AIC 的模型编码和最小化 BIC 的模型编码。\n- 应用指定的平局决胜规则。\n\n最终输出格式：\n你的程序应该生成一行输出，包含一个列表中的 $8$ 个整数，按顺序对应数据集 $1$ 到 $4$ 的结果，并且每个数据集先报告最小化 AIC 的模型编码，然后报告最小化 BIC 的模型编码。该行必须是一个用方括号括起来的逗号分隔列表，没有空格，例如 $[a_1,b_1,a_2,b_2,a_3,b_3,a_4,b_4]$，其中 $a_i$ 是数据集 $i$ 的最小化 AIC 的模型编码，$b_i$ 是数据集 $i$ 的最小化 BIC 的模型编码。", "solution": "我们从第一性原理出发。对于一个 $4$ 态字母表上的时间可逆核苷酸替换模型，自由参数来自三个来源：可逆速率矩阵的交换率参数、稳态碱基频率，以及任何位点速率异质性参数，例如 Γ 形状参数 $\\alpha$ 或不变位点比例 $p_I$。\n\n稳态碱基频率：有 $4$ 个频率，其和为 $1$，因此当碱基频率自由时，产生 $4-1=3$ 个自由参数。在 JC 模型中，碱基频率被约束为相等，贡献 $0$ 个自由参数。\n\n交换率：对于 $4$ 态上的完全通用时间可逆速率矩阵 (GTR)，有 $\\binom{4}{2}=6$ 个交换率，但一个整体速率尺度因子是不可识别的（它可以被吸收到支长中），剩下 $6-1=5$ 个自由交换率参数。在 HKY 模型中，有两个交换率类别（转换与颠换），但同样的可识别性约束移除了整体尺度，剩下 $2-1=1$ 个自由交换率参数（转换/颠换速率比）。在 JC 模型中，所有交换率都被约束为相等，贡献 $0$ 个自由参数。\n\nΓ 位点速率异质性：用于位点间速率异质性的连续 Γ 分布在存在时贡献一个自由形状参数 $\\alpha$。用于近似 Γ 分布的离散类别数量是固定的，不改变模型复杂度。不变位点：比例 $p_I$ 在存在时是一个单一的自由参数。\n\n因此，每个模型的自由替换过程参数 $k$ 的数量为：\n- JC: $k = 0 \\ (\\text{无自由碱基频率，无自由交换率，无异质性参数})$。\n- HKY: $k = 1 \\ (\\text{交换率}) + 3 \\ (\\text{碱基频率}) = 4$。\n- HKY+$\\Gamma$: $k = 4 + 1 \\ (\\alpha) = 5$。\n- GTR: $k = 5 \\ (\\text{交换率}) + 3 \\ (\\text{碱基频率}) = 8$。\n- GTR+$\\Gamma$+I: $k = 8 + 1 \\ (\\alpha) + 1 \\ (p_I) = 10$。\n\n信息准则根据最大化自然对数似然 $\\ln \\mathcal{L}$ 和自由参数数量 $k$ 的定义如下：\n- Akaike 信息准则：$\\mathrm{AIC} = 2k - 2 \\ln \\mathcal{L}$。\n- 贝叶斯信息准则：$\\mathrm{BIC} = k \\ln n - 2 \\ln \\mathcal{L}$，其中 $n$ 是独立观测的数量（此处为位点数）。\n\n对于每个数据集，我们使用提供的 $\\ln \\mathcal{L}$ 值和 $n$ 计算所有五个模型的 $\\mathrm{AIC}$ 和 $\\mathrm{BIC}$，并选择准则值最小的模型，通过较小的 $k$ 打破平局，然后通过较小的模型编码打破平局。\n\n计算结果：\n\n数据集 $1$：$n=500$，$\\ln n \\approx 6.2146081$。\n- JC: $k=0$, $-2\\ln \\mathcal{L} = 3300.0$; $\\mathrm{AIC}=3300.0$, $\\mathrm{BIC}=3300.0$。\n- HKY: $k=4$, $-2\\ln \\mathcal{L} = 3170.0$; $\\mathrm{AIC}=3178.0$, $\\mathrm{BIC}\\approx 3170.0 + 4 \\times 6.2146081 \\approx 3194.858$。\n- HKY+$\\Gamma$: $k=5$, $-2\\ln \\mathcal{L} = 3136.0$; $\\mathrm{AIC}=3146.0$, $\\mathrm{BIC}\\approx 3167.073$。\n- GTR: $k=8$, $-2\\ln \\mathcal{L} = 3130.0$; $\\mathrm{AIC}=3146.0$, $\\mathrm{BIC}\\approx 3179.717$。\n- GTR+$\\Gamma$+I: $k=10$, $-2\\ln \\mathcal{L} = 3121.0$; $\\mathrm{AIC}=3141.0$, $\\mathrm{BIC}\\approx 3183.146$。\n最小 $\\mathrm{AIC}$ 值为 GTR+$\\Gamma$+I (编码 $4$) 。最小 $\\mathrm{BIC}$ 值为 HKY+$\\Gamma$ (编码 $2$) 。\n\n数据集 $2$：$n=50$，$\\ln n \\approx 3.9120230$。\n- JC: $k=0$, $-2\\ln \\mathcal{L} = 1080.0$; $\\mathrm{AIC}=1080.0$, $\\mathrm{BIC}=1080.0$。\n- HKY: $k=4$, $-2\\ln \\mathcal{L} = 1010.0$; $\\mathrm{AIC}=1018.0$, $\\mathrm{BIC}\\approx 1025.648$。\n- HKY+$\\Gamma$: $k=5$, $-2\\ln \\mathcal{L} = 1000.0$; $\\mathrm{AIC}=1010.0$, $\\mathrm{BIC}\\approx 1019.560$。\n- GTR: $k=8$, $-2\\ln \\mathcal{L} = 998.4$; $\\mathrm{AIC}=1014.4$, $\\mathrm{BIC}\\approx 1029.696$。\n- GTR+$\\Gamma$+I: $k=10$, $-2\\ln \\mathcal{L} = 986.0$; $\\mathrm{AIC}=1006.0$, $\\mathrm{BIC}\\approx 1025.120$。\n最小 $\\mathrm{AIC}$ 值为 GTR+$\\Gamma$+I (编码 $4$) 。最小 $\\mathrm{BIC}$ 值为 HKY+$\\Gamma$ (编码 $2$) 。\n\n数据集 $3$：$n=200$，$\\ln n \\approx 5.2983174$。\n- JC: $k=0$, $-2\\ln \\mathcal{L} = 1400.0$; $\\mathrm{AIC}=1400.0$, $\\mathrm{BIC}=1400.0$。\n- HKY: $k=4$, $-2\\ln \\mathcal{L} = 1300.0$; $\\mathrm{AIC}=1308.0$, $\\mathrm{BIC}\\approx 1321.192$。\n- HKY+$\\Gamma$: $k=5$, $-2\\ln \\mathcal{L} = 1300.0$; $\\mathrm{AIC}=1310.0$, $\\mathrm{BIC}\\approx 1326.492$。\n- GTR: $k=8$, $-2\\ln \\mathcal{L} = 1299.0$; $\\mathrm{AIC}=1315.0$, $\\mathrm{BIC}\\approx 1341.386$。\n- GTR+$\\Gamma$+I: $k=10$, $-2\\ln \\mathcal{L} = 1299.0$; $\\mathrm{AIC}=1319.0$, $\\mathrm{BIC}\\approx 1351.983$。\n最小 $\\mathrm{AIC}$ 和 $\\mathrm{BIC}$ 值均为 HKY (编码 $1$) 。\n\n数据集 $4$：$n=10$，$\\ln n \\approx 2.3025851$；所有 $\\ln \\mathcal{L} = -120.0$，所以 $-2 \\ln \\mathcal{L} = 240.0$ 对所有模型均成立。\n- JC: $k=0$; $\\mathrm{AIC}=240.0$, $\\mathrm{BIC}=240.0$。\n- HKY: $k=4$; $\\mathrm{AIC}=248.0$, $\\mathrm{BIC}\\approx 249.210$。\n- HKY+$\\Gamma$: $k=5$; $\\mathrm{AIC}=250.0$, $\\mathrm{BIC}\\approx 251.513$。\n- GTR: $k=8$; $\\mathrm{AIC}=256.0$, $\\mathrm{BIC}\\approx 258.421$。\n- GTR+$\\Gamma$+I: $k=10$; $\\mathrm{AIC}=260.0$, $\\mathrm{BIC}\\approx 263.026$。\n最小 $\\mathrm{AIC}$ 和 $\\mathrm{BIC}$ 值均为 JC (编码 $0$) 。\n\n因此，所需的输出是包含 $8$ 个整数的扁平列表：\n$[4,2,4,2,1,1,0,0]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_free_parameters(model_code: int) - int:\n    \"\"\"\n    Compute the number of free substitution-process parameters k for a 4-state\n    time-reversible nucleotide model, excluding topology/branch lengths and\n    the fixed number of gamma categories.\n\n    Model codes:\n      0: JC\n      1: HKY\n      2: HKY+Gamma\n      3: GTR\n      4: GTR+Gamma+I\n    \"\"\"\n    # Base frequency degrees of freedom: 3 when free, 0 for JC (equal)\n    if model_code == 0:\n        basefreq_df = 0  # JC has equal base frequencies\n        exch_df = 0      # JC has all exchangeabilities equal\n        gamma_shape = 0\n        pinv = 0\n    elif model_code == 1:\n        basefreq_df = 3  # HKY: free base frequencies\n        exch_df = 1      # HKY: transitions vs transversions, minus overall scale\n        gamma_shape = 0\n        pinv = 0\n    elif model_code == 2:\n        basefreq_df = 3\n        exch_df = 1\n        gamma_shape = 1  # Gamma shape alpha\n        pinv = 0\n    elif model_code == 3:\n        basefreq_df = 3\n        exch_df = 5      # GTR: 6 exchangeabilities minus one overall scale\n        gamma_shape = 0\n        pinv = 0\n    elif model_code == 4:\n        basefreq_df = 3\n        exch_df = 5\n        gamma_shape = 1\n        pinv = 1         # Proportion invariant sites\n    else:\n        raise ValueError(\"Unknown model code\")\n    return basefreq_df + exch_df + gamma_shape + pinv\n\ndef aic(k: int, logL: float) - float:\n    return 2.0 * k - 2.0 * logL\n\ndef bic(k: int, logL: float, n: int) - float:\n    return k * float(np.log(n)) - 2.0 * logL\n\ndef select_min(values, ks, tol=0.0):\n    \"\"\"\n    Select the index of the minimal value with tie-breaking:\n    1) smaller k (model complexity), 2) smaller index.\n    tol allows treating near-equalities as ties; default exact.\n    \"\"\"\n    best_idx = None\n    best_val = None\n    best_k = None\n    for idx, (v, k) in enumerate(zip(values, ks)):\n        if best_idx is None:\n            best_idx = idx\n            best_val = v\n            best_k = k\n            continue\n        if v  best_val - tol:\n            best_idx = idx\n            best_val = v\n            best_k = k\n        elif abs(v - best_val) = tol:\n            if k  best_k:\n                best_idx = idx\n                best_val = v\n                best_k = k\n            elif k == best_k and idx  best_idx:\n                best_idx = idx\n                best_val = v\n                best_k = k\n    return best_idx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each entry: (n, [logL_model0, logL_model1, logL_model2, logL_model3, logL_model4])\n    test_cases = [\n        (500, [-1650.0, -1585.0, -1568.0, -1565.0, -1560.5]),\n        (50,  [-540.0,  -505.0,  -500.0,  -499.2,  -493.0]),\n        (200, [-700.0,  -650.0,  -650.0,  -649.5,  -649.5]),\n        (10,  [-120.0,  -120.0,  -120.0,  -120.0,  -120.0]),\n    ]\n\n    model_codes = [0, 1, 2, 3, 4]\n    ks = [count_free_parameters(m) for m in model_codes]\n\n    results = []\n    for n, logLs in test_cases:\n        aics = [aic(ks[i], logLs[i]) for i in range(5)]\n        bics = [bic(ks[i], logLs[i], n) for i in range(5)]\n        best_aic_model = select_min(aics, ks, tol=0.0)\n        best_bic_model = select_min(bics, ks, tol=0.0)\n        results.append(best_aic_model)\n        results.append(best_bic_model)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2424572"}]}