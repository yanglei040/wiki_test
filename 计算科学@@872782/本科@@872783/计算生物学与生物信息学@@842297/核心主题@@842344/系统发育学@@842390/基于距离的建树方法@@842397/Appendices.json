{"hands_on_practices": [{"introduction": "为了打下坚实的基础，我们从一个UPGMA算法的直接应用开始。这个练习 [@problem_id:2385869] 将引导你逐步完成聚类分类单元、计算节点高度和更新距离矩阵的迭代过程。通过这个实例，你将对UPGMA的操作方式获得具体的理解，并亲身体会到为什么一致的平局打破规则对于获得确定且可复现的树拓扑至关重要。", "problem": "考虑四个分类单元 $A$、$B$、$C$ 和 $D$，其成对非相似性 $d(i,j)$ 由以下对称矩阵给出（行和列的顺序为 $A,B,C,D$）：\n$$\nD \\;=\\;\n\\begin{pmatrix}\n0  1  1  \\frac{8}{5} \\\\\n1  0  \\frac{26}{5}  \\frac{17}{5} \\\\\n1  \\frac{26}{5}  0  \\frac{22}{5} \\\\\n\\frac{8}{5}  \\frac{17}{5}  \\frac{22}{5}  0\n\\end{pmatrix}.\n$$\n使用非加权配对算术平均法 (UPGMA) 构建一个有根超度量系统发育树。在任何步骤中，当两个或多个聚类间距离相等且为最小值时，通过选择分类单元标签按字母顺序构成字典序最小的有序对来打破僵局（例如，选择 $(A,B)$ 而非 $(A,C)$）。使用此规则，计算所得树中分类单元 $B$ 和 $C$ 之间的超度量距离。以精确数值形式给出答案，不带单位。", "solution": "问题要求使用非加权配对算术平均法 (UPGMA) 算法，根据给定的成对非相似性矩阵 $D$，为四个分类单元 $A$、$B$、$C$ 和 $D$ 构建一个有根超度量系统发育树。最终目标是计算所得树中分类单元 $B$ 和 $C$ 之间的超度量距离。\n\nUPGMA 算法是一种层次凝聚聚类方法。步骤如下：\n1. 将 $n$ 个分类单元中的每一个初始化为一个单独的聚类。\n2. 迭代地找到具有最小非相似性 $d(u,v)$ 的一对聚类，比如 $u$ 和 $v$。\n3. 将 $u$ 和 $v$ 合并成一个新的聚类 $(uv)$。在树中创建一个新节点来表示这次合并，并将其置于高度 $h_{(uv)} = \\frac{d(u,v)}{2}$ 处。连接这个新节点到 $u$ 和 $v$ 节点的树枝的长度应使得从根到任何叶子的总路径长度保持恒定。\n4. 新的复合聚类 $(uv)$ 到任何其他聚类 $k$ 的距离计算为加权平均值：\n$$ d((uv), k) = \\frac{|u|d(u,k) + |v|d(v,k)}{|u| + |v|} $$\n其中 $|u|$ 和 $|v|$ 分别是聚类 $u$ 和 $v$ 中分类单元的数量（基数）。\n5. 重复此过程，直到只剩下一个聚类，该聚类代表树的根。\n\n所得树中两个分类单元 $i$ 和 $j$ 之间的超度量距离 $d_{tree}(i,j)$ 定义为它们最近共同祖先 (MRCA) 高度的两倍，记为 $h_{MRCA(i,j)}$：\n$$ d_{tree}(i,j) = 2 \\times h_{MRCA(i,j)} $$\n\n我们现在将此过程应用于所提供的数据。\n\n**初始步骤：**\n初始聚类为 $\\{A\\}$、$\\{B\\}$、$\\{C\\}$ 和 $\\{D\\}$，每个聚类的基数为 $1$。给定的对称非相似性矩阵为：\n$$\nD_0 \\;=\\;\n\\begin{pmatrix}\n0  1  1  \\frac{8}{5} \\\\\n1  0  \\frac{26}{5}  \\frac{17}{5} \\\\\n1  \\frac{26}{5}  0  \\frac{22}{5} \\\\\n\\frac{8}{5}  \\frac{17}{5}  \\frac{22}{5}  0\n\\end{pmatrix}\n$$\n行和列对应于分类单元的顺序 $A, B, C, D$。\n\n**迭代 1：**\n我们在 $D_0$ 中找出最小的非零距离。该值为 $1$，出现在两对中：$d(A,B) = 1$ 和 $d(A,C) = 1$。问题提供了打破僵局的规则：选择其分类单元标签构成字典序最小有序对的那一对。比较 $(A,B)$ 和 $(A,C)$，我们确定 $(A,B)$ 的字典序更小。因此，我们将聚类 $\\{A\\}$ 和 $\\{B\\}$ 合并成一个新的聚类 $(AB)$。\n\n新聚类的基数为 $|(AB)| = |A| + |B| = 1 + 1 = 2$。\n代表这次合并的节点的高度为 $h_{(AB)} = \\frac{d(A,B)}{2} = \\frac{1}{2}$。\n\n接下来，我们更新距离矩阵。新聚类 $(AB)$ 到剩余聚类 $\\{C\\}$ 和 $\\{D\\}$ 的距离计算如下：\n$$ d((AB), C) = \\frac{|A|d(A,C) + |B|d(B,C)}{|A|+|B|} = \\frac{1 \\cdot 1 + 1 \\cdot \\frac{26}{5}}{1+1} = \\frac{1 + \\frac{26}{5}}{2} = \\frac{\\frac{31}{5}}{2} = \\frac{31}{10} $$\n$$ d((AB), D) = \\frac{|A|d(A,D) + |B|d(B,D)}{|A|+|B|} = \\frac{1 \\cdot \\frac{8}{5} + 1 \\cdot \\frac{17}{5}}{1+1} = \\frac{\\frac{25}{5}}{2} = \\frac{5}{2} $$\n新的聚类集合是 $\\{(AB), C, D\\}$。更新后的距离矩阵 $D_1$ 为：\n$$ D_1 =\n\\begin{pmatrix}\n  (AB)  C  D \\\\\n(AB)  0  \\frac{31}{10}  \\frac{5}{2} \\\\\nC  \\frac{31}{10}  0  \\frac{22}{5} \\\\\nD  \\frac{5}{2}  \\frac{22}{5}  0\n\\end{pmatrix}\n$$\n\n**迭代 2：**\n我们在 $D_1$ 中找到最小的非零距离。这些距离是 $\\frac{31}{10} = 3.1$，$\\frac{5}{2} = 2.5$ 和 $\\frac{22}{5} = 4.4$。最小值是 $d((AB), D) = \\frac{5}{2}$。我们将聚类 $(AB)$ 和 $\\{D\\}$ 合并成一个新的聚类 $((AB)D)$。\n\n基数为 $|((AB)D)| = |(AB)| + |D| = 2 + 1 = 3$。\n这个新节点的高度是 $h_{((AB)D)} = \\frac{d((AB),D)}{2} = \\frac{5/2}{2} = \\frac{5}{4}$。\n\n我们计算 $((AB)D)$ 到唯一剩余的聚类 $\\{C\\}$ 的距离：\n$$ d(((AB)D), C) = \\frac{|(AB)|d((AB),C) + |D|d(D,C)}{|(AB)|+|D|} = \\frac{2 \\cdot \\frac{31}{10} + 1 \\cdot \\frac{22}{5}}{2+1} = \\frac{\\frac{31}{5} + \\frac{22}{5}}{3} = \\frac{\\frac{53}{5}}{3} = \\frac{53}{15} $$\n\n**迭代 3：**\n最后剩下的两个聚类是 $\\{((AB)D)\\}$ 和 $\\{C\\}$。我们将它们合并以形成树的根。\n根节点的高度是 $h_{root} = \\frac{d(((AB)D),C)}{2} = \\frac{53/15}{2} = \\frac{53}{30}$。\n\n树的最终拓扑结构是 $(((A,B),D),C)$。我们需要找到分类单元 $B$ 和 $C$ 之间的超度量距离。这需要确定它们的最近共同祖先。\n- 从叶节点 $B$ 开始的谱系上升到节点 $(AB)$，然后到节点 $((AB)D)$，最后到根节点。\n- 从叶节点 $C$ 开始的谱系直接上升到根节点。\n因此，$B$ 和 $C$ 的最近共同祖先 (MRCA) 是树的根节点。\n\n此 MRCA 的高度是根节点的高度，即 $h_{root} = \\frac{53}{30}$。\n所得树中 $B$ 和 $C$ 之间的超度量距离计算如下：\n$$ d_{tree}(B, C) = 2 \\times h_{MRCA(B,C)} = 2 \\times h_{root} = 2 \\times \\frac{53}{30} = \\frac{53}{15} $$\n这符合要求，是一个精确的数值。", "answer": "$$\\boxed{\\frac{53}{15}}$$", "id": "2385869"}, {"introduction": "掌握了UPGMA的机械操作后，我们将注意力转向邻接法(NJ)的特性。这个思维实验 [@problem_id:2385856] 不再是简单的程序性计算，而是挑战你分析当输入距离被统一缩放时，算法的公式会如何表现。这个练习揭示了NJ算法一个关键的理论特性，并展示了理解一个方法的数学结构如何能为我们提供关于其鲁棒性和行为的深刻见解。", "problem": "考虑一组 $n \\ge 3$ 个分类单元，其对称距离矩阵为 $D = \\big(d(i,j)\\big)_{1 \\le i,j \\le n}$，满足对所有 $i,j$ 都有 $d(i,i)=0$ 和 $d(i,j)=d(j,i)$。在邻接法（Neighbor Joining, NJ）中，配对选择准则为\n$$\nQ(i,j) \\equiv (n-2)\\,d(i,j) - \\sum_{k=1}^{n} d(i,k) - \\sum_{k=1}^{n} d(j,k).\n$$\n设 $c>0$ 并定义一个新的距离矩阵 $D'=\\big(d'(i,j)\\big)$，其中对所有 $i,j$ 都有 $d'(i,j)=c\\,d(i,j)$。令 $Q'(i,j)$ 表示根据 $D'$ 计算出的 NJ 准则，其计算方式与根据 $D$ 计算 $Q(i,j)$ 的方式相同。假设在整个 NJ 凝聚过程中，$Q(i,j)$ 的值没有并列情况（因此所选配对的序列是唯一确定的）。\n\n推导 $Q'(i,j)$ 关于 $Q(i,j)$ 和上述常数的显式表达式，并确定由 $D'$ 推断出的最终 NJ 树中每条分支的长度相对于由 $D$ 推断出的树的分支长度变化的乘法因子。将您的最终答案以一个二元行向量 $\\big(Q'(i,j),\\ \\text{分支长度的缩放因子}\\big)$ 的形式给出。无需四舍五入。", "solution": "首先必须验证问题陈述的科学合理性、适定性和客观性。\n\n**步骤 1：提取已知条件**\n- 一组 $n \\ge 3$ 个分类单元。\n- 一个对称距离矩阵 $D = \\big(d(i,j)\\big)_{1 \\le i,j \\le n}$，满足 $d(i,i)=0$ 和 $d(i,j)=d(j,i)$。\n- 邻接法 (NJ) 的配对选择准则：$Q(i,j) \\equiv (n-2)\\,d(i,j) - \\sum_{k=1}^{n} d(i,k) - \\sum_{k=1}^{n} d(j,k)$。\n- 一个常数 $c>0$。\n- 一个新的距离矩阵 $D'=\\big(d'(i,j)\\big)$，定义为对所有 $i,j$ 都有 $d'(i,j)=c\\,d(i,j)$。\n- $Q'(i,j)$ 是从 $D'$ 计算出的 NJ 准则。\n- 假设在整个 NJ 凝聚过程中，$Q(i,j)$ 的值没有并列情况。\n- 任务是推导 $Q'(i,j)$ 关于 $Q(i,j)$ 的表达式，并确定由 $D'$ 推断的树的分支长度相对于由 $D$ 推断的树的分支长度的乘法因子。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据。邻接算法是计算生物学和生物信息学中一种标准的、成熟的方法，用于从距离数据推断系统发育树。所提供的 $Q$ 准则公式是正确的。该问题是适定的；它询问输入距离矩阵的线性缩放所产生的影响，这是一个数学上可解的问题。“无并列”的假设确保了凝聚过程是唯一的，使得两个结果树之间的比较明确无误。语言客观而精确。该问题没有违反任何科学或数学逻辑原理，不基于错误的假设，并包含了求解所需的所有必要信息。\n\n**步骤 3：结论与行动**\n该问题被认定为有效。将推导解答。\n\n解答包括两部分：首先，推导 $Q'(i,j)$ 和 $Q(i,j)$ 之间的关系；其次，确定分支长度的缩放因子。\n\n**第一部分：$Q'(i,j)$ 的推导**\n\nNJ 选择准则 $Q'(i,j)$ 是使用距离矩阵 $D'$ 计算的。根据定义，对于一组 $n$ 个分类单元，它为：\n$$\nQ'(i,j) = (n-2)\\,d'(i,j) - \\sum_{k=1}^{n} d'(i,k) - \\sum_{k=1}^{n} d'(j,k)\n$$\n已知对所有配对 $(i,j)$，有 $d'(i,j) = c\\,d(i,j)$。我们将此关系代入 $Q'(i,j)$ 的表达式中：\n$$\nQ'(i,j) = (n-2)\\,[c\\,d(i,j)] - \\sum_{k=1}^{n} [c\\,d(i,k)] - \\sum_{k=1}^{n} [c\\,d(j,k)]\n$$\n由于 $c$ 是一个常数，可以从求和项以及整个表达式中提取出来：\n$$\nQ'(i,j) = c\\,(n-2)\\,d(i,j) - c\\,\\sum_{k=1}^{n} d(i,k) - c\\,\\sum_{k=1}^{n} d(j,k)\n$$\n$$\nQ'(i,j) = c \\left( (n-2)\\,d(i,j) - \\sum_{k=1}^{n} d(i,k) - \\sum_{k=1}^{n} d(j,k) \\right)\n$$\n括号内的表达式根据定义即为原始的选择准则 $Q(i,j)$。因此，我们得到显式关系：\n$$\nQ'(i,j) = c\\,Q(i,j)\n$$\n\n**第二部分：分支长度缩放因子的确定**\n\nNJ 算法是一个迭代过程。在每一步中，它会找出 $Q$ 值最小的一对分类单元 $(i,j)$。在我们的例子中，使用矩阵 $D$ 运行的算法会选择配对 $(i^*, j^*)$，使得：\n$$\n(i^*, j^*) = \\arg\\min_{i,j} Q(i,j)\n$$\n对于使用矩阵 $D'$ 运行的算法，选择是基于最小化 $Q'(i,j)$：\n$$\n(i'^*, j'^*) = \\arg\\min_{i,j} Q'(i,j) = \\arg\\min_{i,j} [c\\,Q(i,j)]\n$$\n由于已知 $c > 0$，将所有 $Q(i,j)$ 值乘以一个正常数 $c$ 不会改变产生最小值的配对。问题陈述中没有并列情况，因此最小值是唯一的。因此，两种情况下选择的配对是相同的：\n$$\n(i'^*, j'^*) = (i^*, j^*)\n$$\n因为对于距离矩阵 $D$ 和 $D'$，算法的每一步连接的节点对都是相同的，所以最终得到的系统发育树的拓扑结构在两种情况下是相同的。\n\n现在，我们必须检查分支长度。当一对 $(i,j)$ 被连接时，会创建一个新节点 $u$。计算连接到 $i$ 和 $j$ 的新分支的长度。连接分类单元 $i$ 到新节点 $u$ 的分支长度，我们称之为 $b(i,u)$，由以下公式给出：\n$$\nb(i,u) = \\frac{1}{2}d(i,j) + \\frac{1}{2(n-2)} \\left( \\sum_{k=1}^{n} d(i,k) - \\sum_{k=1}^{n} d(j,k) \\right)\n$$\n对于缩放后的矩阵 $D'$，相应的分支长度 $b'(i,u)$ 使用相同的公式计算，但使用的是距离 $d'(i,j)$：\n$$\nb'(i,u) = \\frac{1}{2}d'(i,j) + \\frac{1}{2(n-2)} \\left( \\sum_{k=1}^{n} d'(i,k) - \\sum_{k=1}^{n} d'(j,k) \\right)\n$$\n代入 $d'(x,y) = c\\,d(x,y)$：\n$$\nb'(i,u) = \\frac{1}{2}[c\\,d(i,j)] + \\frac{1}{2(n-2)} \\left( \\sum_{k=1}^{n} c\\,d(i,k) - \\sum_{k=1}^{n} c\\,d(j,k) \\right)\n$$\n提取出常数 $c$：\n$$\nb'(i,u) = c \\left[ \\frac{1}{2}d(i,j) + \\frac{1}{2(n-2)} \\left( \\sum_{k=1}^{n} d(i,k) - \\sum_{k=1}^{n} d(j,k) \\right) \\right]\n$$\n方括号中的表达式恰好是 $b(i,u)$。因此：\n$$\nb'(i,u) = c \\cdot b(i,u)\n$$\n类似的推导表明 $b'(j,u) = c \\cdot b(j,u)$。\n\n在将 $(i,j)$ 连接形成 $u$ 之后，更新距离矩阵以进行下一次迭代。任何其他分类单元 $m$ 到新节点 $u$ 的距离定义为：\n$$\nd(m,u) = \\frac{1}{2} \\left[ d(i,m) + d(j,m) - d(i,j) \\right]\n$$\n对于缩放后的情况，新的距离 $d'(m,u)$ 将是：\n$$\nd'(m,u) = \\frac{1}{2} \\left[ d'(i,m) + d'(j,m) - d'(i,j) \\right]\n$$\n代入 $d'(x,y) = c\\,d(x,y)$：\n$$\nd'(m,u) = \\frac{1}{2} \\left[ c\\,d(i,m) + c\\,d(j,m) - c\\,d(i,j) \\right] = c \\left[ \\frac{1}{2} \\left( d(i,m) + d(j,m) - d(i,j) \\right) \\right]\n$$\n这可以简化为：\n$$\nd'(m,u) = c \\cdot d(m,u)\n$$\n这表明，在迭代过程的每一步，缩放问题的整个距离矩阵就是原始问题距离矩阵的 $c$ 倍。由于所有后续的分支长度计算都是当前距离矩阵中各项的线性函数，因此在整个算法中计算的每个分支长度都将被缩放因子 $c$ 缩放。\n\n这适用于在凝聚过程中创建的所有分支，包括连接最后三个剩余节点的最后三个分支。因此，从 $D'$ 推断出的最终树中的每个分支长度都恰好是从 $D$ 推断出的树中相应分支长度的 $c$ 倍。分支长度的乘法缩放因子是 $c$。\n\n结合这两个结果，我们得到了 $Q'(i,j)$ 的表达式和分支长度的缩放因子。这些将以一个二元行向量的形式呈现。", "answer": "$$\n\\boxed{\\begin{pmatrix} c\\,Q(i,j)  c \\end{pmatrix}}\n$$", "id": "2385856"}, {"introduction": "在分别探讨了UPGMA和NJ之后，我们现在在一个精心构建的场景中对它们进行直接比较。这个问题 [@problem_id:2385846] 探究了两种最常见的基于距离的方法如何应对数据集中存在的相同分类单元。通过分析它们的不同结果，你将揭示其底层逻辑的根本区别，并对算法选择的重要性获得更细致的理解。", "problem": "在基于距离的系统发育重建中，假设您有一个关于一组分类单元的对称相異性矩阵，其中两个分类单元（称它们为 $x$ 和 $x'$）是完全重复的，即 $d_{xx'}=0$，并且对于任何其他分类单元 $k$，都有 $d_{xk}=d_{x'k}$。考虑在该矩阵上运行非加权配对算术平均法 (UPGMA) 和邻接法 (NJ) 算法。\n\n哪个陈述最能描述包含重复分类单元 $x'$ 对所生成树的影响？\n\nA. 在UPGMA下，$x$ 和 $x'$ 将形成一个分支长度为 $0$ 的即时簇，并且在将那个长度为 $0$ 的“樱桃”结构收缩为单个叶尖后，非重复分类单元间的其余有根拓扑结构和节点高度与移除 $x'$ 的情况相同；在NJ下，添加 $x'$ 可以通过 $Q$ 准则改变凝聚的顺序，因此可以改变非重复分类单元间的无根拓扑结构，尽管 $x$ 和 $x'$ 最终将通过长度为 $0$ 的分支连接到它们的共同父节点。\n\nB. 在UPGMA和NJ下，$x$ 和 $x'$ 都将作为一个长度为 $0$ 的“樱桃”结构连接，并且它们的存在不会改变拓扑结构的任何其他部分；关于非重复分类单元的树对于添加 $x'$ 是不变的。\n\nC. 在UPGMA下，添加 $x'$ 通常会改变簇间平均值，因此可以改变非重复分类单元间的拓扑结构；在NJ下，$Q$ 准则仅使用两两之间的距离，因此对于添加 $x'$ 是不变的。\n\nD. 在NJ中，$x$ 和 $x'$ 必须是第一对接合的配对，因为 $d_{xx'}=0$ 保证了最小的 $Q$ 值；在UPGMA中，它们可能首先接合，也可能不首先接合，这取决于其他距离。", "solution": "该问题要求分析两种基于距离的系统发育树构建算法——UPGMA和邻接法 (NJ)——在处理包含两个相同分类单元的距离矩阵时的行为。\n\n设分类单元的集合为 $S$。设两个重复的分类单元为 $x$ 和 $x'$，它们是 $S$ 的元素。这些重复单元的属性由给定的对称相异性矩阵 $D$（其条目为 $d_{ij}$）定义：\n1. 重复单元之间的距离为零：$d_{xx'} = 0$。由于距离是非负的，这是可能的最小距离。\n2. 重复单元与任何其他分类单元 $k$ 的距离相等：对于每个 $k \\in S \\setminus \\{x, x'\\}$，我们有 $d_{xk} = d_{x'k}$。\n\n我们现在将分析，假设我们已经有了分类单元 $x$，包含分类单元 $x'$ 对UPGMA和NJ的建树过程有何影响。\n\n**UPGMA（非加权配对算术平均法）分析**\n\nUPGMA是一种凝聚型层次聚类算法。在每一步，它执行以下操作：\n1. 找到距离 $d(C_i, C_j)$ 最小的一对簇 $(C_i, C_j)$。最初，每个分类单元都是其自身的簇。\n2. 将这对簇合并成一个新的簇 $C_u = C_i \\cup C_j$。\n3. 将连接 $C_i$ 和 $C_j$ 的节点置于高度 $d(C_i, C_j) / 2$ 处。\n4. 通过计算新簇 $C_u$ 到所有其他簇 $C_k$ 的距离来更新距离矩阵。簇间距离的公式是算术平均值：\n    $$d(C_u, C_k) = \\frac{1}{|C_u| |C_k|} \\sum_{a \\in C_u, b \\in C_k} d_{ab}$$\n\n让我们追踪UPGMA在给定矩阵上的第一步。算法搜索整个矩阵中的最小距离。我们已知 $d_{xx'} = 0$。由于所有距离都是非负的，$d_{ij} \\ge 0$，所以距离 $d_{xx'}$ 保证是矩阵中的一个最小值。因此，在第一步中，UPGMA必须连接对 $(x, x')$。\n\n形成一个新簇，我们称之为 $u$，其中 $u = \\{x, x'\\}$。连接 $x$ 和 $x'$ 的节点被置于高度 $d_{xx'} / 2 = 0 / 2 = 0$ 处。将此父节点连接到叶 $x$ 和 $x'$ 的分支长度均为 $0$。这种结构是一个“长度为0的樱桃结构”。\n\n接下来，算法更新距离矩阵。簇 $u$ 取代了 $x$ 和 $x'$。从 $u$到任何其他分类单元（簇）$k$ 的距离计算如下：\n$$d(u, k) = d(\\{x, x'\\}, \\{k\\}) = \\frac{1}{2 \\cdot 1} (d_{xk} + d_{x'k})$$\n根据问题陈述，我们知道 $d_{xk} = d_{x'k}$。将此代入方程得到：\n$$d(u, k) = \\frac{1}{2} (d_{xk} + d_{xk}) = d_{xk}$$\n这是一个关键的结果。包含簇 $u$ 和其余分类单元的新距离矩阵，与我们只从分类单元 $x$ 开始而从未包含 $x'$ 的距离矩阵在数值上是相同的。任何两个分类单元 $i, j \\in S \\setminus \\{x, x'\\}$ 之间的距离保持不变，并且任何这样的分类单元 $k$ 到新簇 $u$ 的距离与其最初到 $x$ 的距离完全相同。\n\n因此，UPGMA算法的所有后续步骤将与在排除了 $x'$ 的较小数据集上完全一样地进行。由此产生的有根拓扑结构和所有其他节点的高度将是相同的。最终的树只会在原本单个分类单元 $x$ 的位置上有一个 $x$ 和 $x'$ 组成的长度为0的“樱桃”结构。\n\n**邻接法 (NJ) 分析**\n\nNJ也是一种凝聚算法，但它使用不同的准则来选择要连接的配对。它旨在找到总分支长度最小的树。在每一步中，对于一组 $n$ 个当前分类单元，它计算 $Q$ 矩阵，其中：\n$$Q_{ij} = (n-2)d_{ij} - r_i - r_j$$\n且 $r_i = \\sum_{k=1}^n d_{ik}$ 是从分类单元 $i$ 到所有其他分类单元的距离之和。该算法连接使 $Q_{ij}$ 最小的配对 $(i, j)$。\n\n让我们分析添加重复分类单元 $x'$ 的影响。设 $S'$ 是不含 $x'$ 的分类单元集合，而 $S = S' \\cup \\{x'\\}$ 是完整集合。设 $n'$ 是 $S'$ 中分类单元的数量，$n = n'+1$ 是 $S$ 中分类单元的数量。\n\n考虑对来自 $S' \\setminus \\{x\\}$ 的任何一对非重复分类单元 $(i, j)$ 计算 $Q$ 矩阵。\n在没有 $x'$ 的情况下，准则为 $Q'_{ij} = (n'-2)d_{ij} - r'_i - r'_j$，其中 $r'_i = \\sum_{k \\in S'} d_{ik}$。\n当添加 $x'$ 时，准则变为 $Q_{ij} = (n-2)d_{ij} - r_i - r_j$。分类单元 $i$ 的新距离总和为：\n$$r_i = \\sum_{k \\in S} d_{ik} = \\left(\\sum_{k \\in S'} d_{ik}\\right) + d_{ix'} = r'_i + d_{ix}$$\n（因为 $d_{ix'} = d_{ix}$）。\n新的 $Q$ 值则为：\n$$Q_{ij} = ((n'+1)-2)d_{ij} - (r'_i + d_{ix}) - (r'_j + d_{jx}) = (n'-1)d_{ij} - (r'_i + d_{ix}) - (r'_j + d_{jx})$$\n$Q$ 值的变化是：\n$$Q_{ij} - Q'_{ij} = [(n'-1)d_{ij} - r'_i - r'_j - d_{ix} - d_{jx}] - [(n'-2)d_{ij} - r'_i - r'_j]$$\n$$Q_{ij} - Q'_{ij} = d_{ij} - d_{ix} - d_{jx}$$\n这个差值 $d_{ij} - d_{ix} - d_{jx}$ 对所有配对 $(i, j)$ 来说不是一个常数。对于另一对 $(i, l)$，差值将是 $d_{il} - d_{ix} - d_{lx}$。由于这个值是依赖于配对的，非重复分类单元的 $Q$ 值的相对顺序可以改变。最小化 $Q'$ 的配对可能不会最小化 $Q$。因此，添加重复的分类单元 $x'$ 可以改变凝聚的顺序，从而改变 resulting 非重复分类单元间的无根拓扑结构。\n\n此外，与UPGMA不同，NJ不保证在第一步就连接配对 $(x, x')$。准則是最小化 $Q_{ij}$，而不是 $d_{ij}$。尽管 $d_{xx'} = 0$ 使得 $Q_{xx'}$ 的第一项为零，但另一对 $(i, j)$ 有可能具有更负的 $Q$ 值。例如，對於一組四個分類單元 $\\{x, x', a, b\\}$，距離為 $d_{xx'}=0, d_{xa}=d_{x'a}=2, d_{xb}=d_{x'b}=2, d_{ab}=10$，我们发现 $Q_{xa}$ 是 $Q$ 矩阵中的最小值，而不是 $Q_{xx'}$。\n\n然而，每当配对 $(x, x')$ 最终被连接形成一个新节点 $u$ 时，会计算从 $u$到 $x$ 和 $x'$ 的分支长度。从 $u$ 到 $x$ 的分支长度由以下公式给出：\n$$L_{xu} = \\frac{1}{2}d_{xx'} + \\frac{1}{2(n-2)} (r_x - r_{x'})$$\n鉴于 $d_{xx'} = 0$ 且对于所有 $k$ 都有 $d_{xk} = d_{x'k}$，因此 $r_x = \\sum_k d_{xk} = \\sum_k d_{x'k} = r_{x'}$。因此，第二项也为零。\n$$L_{xu} = 0 + 0 = 0$$\n另一个分支长度是 $L_{x'u} = d_{xx'} - L_{xu} = 0 - 0 = 0$。所以，无论它们何时被连接， $x$ 和 $x'$ 在最终的NJ树中都将形成一个长度为0的“樱桃”结构。\n\n**选项评估**\n\n*   **A. 在UPGMA下，$x$ 和 $x'$ 将形成一个分支长度为 $0$ 的即时簇，并且在将那个长度为 $0$ 的“樱桃”结构收缩为单个叶尖后，非重复分类单元间的其余有根拓拓扑结构和节点高度与移除 $x'$ 的情况相同；在NJ下，添加 $x'$ 可以通过 $Q$ 准则改变凝聚的顺序，因此可以改变非重复分类单元间的无根拓扑结构，尽管 $x$ 和 $x'$ 最终将通过长度为 $0$ 的分支连接到它们的共同父节点。**\n    这个陈述准确地反映了我们对UPGMA和NJ的推导。对UPGMA的分析显示了 $(x, x')$ 必须在第一步连接，以及后续拓扑结构的不变性。对NJ的分析显示，由于对 $Q$ 准则的非均匀影响，拓扑结构可能改变，并且 $(x, x')$ 将形成一个长度为0的“樱桃”结构。这个陈述是**正确的**。\n\n*   **B. 在UPGMA和NJ下，$x$ 和 $x'$ 都将作为一个长度为 $0$ 的“樱桃”结构连接，并且它们的存在不会改变拓扑结构的任何其他部分；关于非重复分类单元的树对于添加 $x'$ 是不变的。**\n    这个陈述是不正确的，因为如对NJ的分析所示，重复分类单元 $x'$ 的存在可以改变非重复分类单元的树的拓扑结构。关于NJ不变性的说法是错误的。这个陈述是**不正确的**。\n\n*   **C. 在UPGMA下，添加 $x'$ 通常会改变簇间平均值，因此可以改变非重复分类单元间的拓扑结构；在NJ下，$Q$ 准则仅使用两两之间的距离，因此对于添加 $x'$ 是不变的。**\n    这个陈述的两个论点都不正确。对于UPGMA，非重复分类单元的拓扑结构不会改变。对于NJ，$Q$ 准则不是不变的，因为它依赖于到所有分类单元的距离之和 ($r_i$)，而这会受到添加 $x'$ 的影响。这个陈述是**不正确的**。\n\n*   **D. 在NJ中，$x$ 和 $x'$ 必须是第一对接合的配对，因为 $d_{xx'}=0$ 保证了最小的 $Q$ 值；在UPGMA中，它们可能首先接合，也可能不首先接合，这取决于其他距离。**\n    这个陈述颠倒了事实。在UPGMA中，配对 $(x, x')$ *必须*首先连接，因为 $d_{xx'}=0$ 是最小距离。在NJ中，准則是最小化 $Q_{ij}$，我们通过一个反例证明了 $(x, x')$ 不一定是首先连接的配对。这个陈述是**不正确的**。\n\n基于详细的分析，只有选项A为两种算法的行为提供了科学上正确的描述。", "answer": "$$\\boxed{A}$$", "id": "2385846"}]}