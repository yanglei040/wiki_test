{"hands_on_practices": [{"introduction": "要真正掌握维特比算法，首先必须亲手演练其内部机制。本练习将指导您针对一个轮廓HMM（profile HMM）来计算一个蛋白质序列的维特比路径。通过手动填充动态规划表，您将对概率如何传播以及如何回溯最优路径获得具体而深入的理解。[@problem_id:2436882]", "problem": "一个用于蛋白质家族的轮廓隐马尔可夫模型 (HMM) 长度为 $2$，具有标准轮廓拓扑结构，包括起始 ($B$)、匹配 ($M_{1}, M_{2}$)、插入 ($I_{0}, I_{1}, I_{2}$)、删除 ($D_{1}, D_{2}$) 和结束 ($E$) 状态。氨基酸字母表为 $\\{A, C, D\\}$。删除状态不发射任何符号。插入和匹配状态根据下面指定的概率进行发射。所有未明确列出的转移概率均为 $0$。\n\n非零转移概率：\n- $B \\to M_{1}: \\; \\frac{3}{4}$，$B \\to D_{1}: \\; \\frac{1}{4}$，$B \\to I_{0}: \\; 0$。\n- $I_{0} \\to I_{0}: \\; \\frac{1}{2}$，$I_{0} \\to M_{1}: \\; \\frac{1}{2}$，$I_{0} \\to D_{1}: \\; 0$。\n- $M_{1} \\to M_{2}: \\; \\frac{4}{5}$，$M_{1} \\to I_{1}: \\; \\frac{1}{10}$，$M_{1} \\to D_{2}: \\; \\frac{1}{10}$。\n- $D_{1} \\to M_{2}: \\; \\frac{1}{2}$，$D_{1} \\to D_{2}: \\; \\frac{1}{2}$，$D_{1} \\to I_{1}: \\; 0$。\n- $I_{1} \\to I_{1}: \\; \\frac{1}{2}$，$I_{1} \\to M_{2}: \\; \\frac{1}{2}$，$I_{1} \\to D_{2}: \\; 0$。\n- $M_{2} \\to E: \\; \\frac{9}{10}$，$M_{2} \\to I_{2}: \\; \\frac{1}{10}$。\n- $D_{2} \\to E: \\; 1$。\n- $I_{2} \\to I_{2}: \\; \\frac{1}{2}$，$I_{2} \\to E: \\; \\frac{1}{2}$。\n\n发射概率：\n- 在 $M_{1}$ 中：$P(A)=\\frac{1}{2}$，$P(C)=\\frac{1}{3}$，$P(D)=\\frac{1}{6}$。\n- 在 $M_{2}$ 中：$P(A)=\\frac{1}{5}$，$P(C)=\\frac{1}{5}$，$P(D)=\\frac{3}{5}$。\n- 在 $I_{0}, I_{1}, I_{2}$ 中：均匀分布，$P(A)=P(C)=P(D)=\\frac{1}{3}$。\n\n考虑蛋白质序列 $X = A\\,D\\,A$。应用 Viterbi 解码来确定通过该模型发射出 $X$ 的唯一最可能状态路径，以及 $X$ 与该模型两个匹配列的相应有间隙比对。然后计算该 Viterbi 路径概率的自然对数 $\\ln$。\n\n最终答案仅给出 $\\ln(\\text{Viterbi 路径概率})$ 的数值。将你的答案四舍五入到四位有效数字。", "solution": "该问题要求找到给定序列 $X = A\\,D\\,A$ 通过一个指定的轮廓隐马尔可夫模型 (HMM) 的最可能状态路径（Viterbi 路径），然后计算该路径概率的自然对数。解法将使用 Viterbi 算法推导得出，这是一种用于此任务的动态规划方法。\n\n设给定序列为 $X = x_1x_2x_3$，其中 $x_1=A$，$x_2=D$，且 $x_3=A$。序列的长度为 $N=3$。该 HMM 的长度为 $L=2$。该模型的状态包括起始状态 $B$、匹配状态 $M_1, M_2$、插入状态 $I_0, I_1, I_2$、删除状态 $D_1, D_2$ 和结束状态 $E$。\n\nViterbi 算法的核心是计算 $v_k(i)$，即生成长度为 $i$ 的序列前缀 $x_1...x_i$ 并结束于状态 $k$ 的最可能路径的概率。我们还将维护反向指针以重构路径。\n\n轮廓 HMM 的递推关系如下，其中 $a_{k,l}$ 是从状态 $k$ 到状态 $l$ 的转移概率，$e_k(c)$ 是从状态 $k$ 发射字符 $c$ 的发射概率：\n对于匹配状态 $M_j$，$j \\in \\{1, 2\\}$：\n$$v_{M_j}(i) = e_{M_j}(x_i) \\cdot \\max \\begin{cases} v_{M_{j-1}}(i-1) \\cdot a_{M_{j-1}, M_j} \\\\ v_{I_{j-1}}(i-1) \\cdot a_{I_{j-1}, M_j} \\\\ v_{D_{j-1}}(i-1) \\cdot a_{D_{j-1}, M_j} \\end{cases}$$\n对于插入状态 $I_j$，$j \\in \\{0, 1, 2\\}$：\n$$v_{I_j}(i) = e_{I_j}(x_i) \\cdot \\max \\begin{cases} v_{M_j}(i-1) \\cdot a_{M_j, I_j} \\\\ v_{I_j}(i-1) \\cdot a_{I_j, I_j} \\end{cases}$$\n对于删除状态 $D_j$，$j \\in \\{1, 2\\}$：\n$$v_{D_j}(i) = \\max \\begin{cases} v_{M_{j-1}}(i) \\cdot a_{M_{j-1}, D_j} \\\\ v_{D_{j-1}}(i) \\cdot a_{D_{j-1}, D_j} \\end{cases}$$\n对于 $j=1$ 的情况，通过考虑起始状态 $B$ 来处理 $M$ 和 $D$ 状态的索引 $j-1$。对于 $I_j$，其前一状态是 $M_j$ 或 $I_j$ 本身。状态 $I_0$ 是一个特例。\n\n一个关键的观察是状态 $I_0$ 是不可达的。唯一指定进入 $I_0$ 的转移来自其自身（$I_0 \\to I_0$）。从起始状态 $B$ 到 $I_0$ 的转移概率为 $0$。没有其他状态转移到 $I_0$。因此，任何涉及状态 $I_0$ 的路径概率都为 $0$，我们可以忽略此状态。\n\n我们现在构建 $v_k(i)$ 的动态规划表。\n\n**初始化 ($i=0$):**\n此步骤对应于不发射任何字符的路径。我们从起始状态 $B$ 开始，概率为 $1$。路径然后可以移动到不发射符号的删除状态。\n$v_{D_1}(0) = a_{B,D_1} = \\frac{1}{4}$。反向指针指向 $B$。\n$v_{D_2}(0) = v_{D_1}(0) \\cdot a_{D_1,D_2} = \\frac{1}{4} \\cdot \\frac{1}{2} = \\frac{1}{8}$。反向指针指向 $D_1(0)$。\n所有其他状态的 $v_k(0)$ 均为 $0$，因为它们是发射状态。\n\n**迭代 1 ($i=1$, $x_1=A$):**\n我们计算发射第一个字符 $A$ 的路径的概率。\n$v_{M_1}(1) = e_{M_1}(A) \\cdot a_{B,M_1} = \\frac{1}{2} \\cdot \\frac{3}{4} = \\frac{3}{8}$。反向指针：$B$。\n$v_{M_2}(1) = e_{M_2}(A) \\cdot (v_{D_1}(0) \\cdot a_{D_1,M_2}) = \\frac{1}{5} \\cdot (\\frac{1}{4} \\cdot \\frac{1}{2}) = \\frac{1}{40}$。反向指针：$D_1(0)$。\n插入状态的概率为 $0$，因为它们必须从前一步（$i=0$）的某个状态进入，而在 $i=0$ 时没有发射状态具有非零概率。\n$v_{I_1}(1) = 0$, $v_{I_2}(1) = 0$。\n发射一个字符后结束于删除状态的概率：\n$v_{D_2}(1) = v_{M_1}(1) \\cdot a_{M_1,D_2} = \\frac{3}{8} \\cdot \\frac{1}{10} = \\frac{3}{80}$。反向指针：$M_1(1)$。\n$D_1$ 只能从 $B$ 到达，这不涉及发射，所以对于 $i>0$，$v_{D_1}(i)=0$。\n\n**迭代 2 ($i=2$, $x_2=D$):**\n我们计算发射前两个字符 $A,D$ 的路径的概率。\n$v_{M_1}(2) = 0$，因为在第一个字符之后，$M_1$ 只能从 $I_0$ 到达，而 $I_0$ 是不可达的。\n$v_{I_1}(2) = e_{I_1}(D) \\cdot \\max \\{ v_{M_1}(1) \\cdot a_{M_1,I_1}, v_{I_1}(1) \\cdot a_{I_1,I_1} \\} = \\frac{1}{3} \\cdot \\max\\{\\frac{3}{8} \\cdot \\frac{1}{10}, 0 \\} = \\frac{1}{80}$。反向指针：$M_1(1)$。\n$v_{M_2}(2) = e_{M_2}(D) \\cdot \\max \\{ v_{M_1}(1) \\cdot a_{M_1,M_2}, v_{I_1}(1) \\cdot a_{I_1,M_2} \\} = \\frac{3}{5} \\cdot \\max \\{ \\frac{3}{8} \\cdot \\frac{4}{5}, 0 \\} = \\frac{3}{5} \\cdot \\frac{3}{10} = \\frac{9}{50}$。反向指针：$M_1(1)$。\n$v_{I_2}(2) = e_{I_2}(D) \\cdot \\max \\{ v_{M_2}(1) \\cdot a_{M_2,I_2}, v_{I_2}(1) \\cdot a_{I_2,I_2} \\} = \\frac{1}{3} \\cdot \\max \\{ \\frac{1}{40} \\cdot \\frac{1}{10}, 0 \\} = \\frac{1}{1200}$。反向指针：$M_2(1)$。\n对于 $i=2$ 时的删除状态：$v_{D_1}(2)=0$，$v_{D_2}(2)=0$。\n\n**迭代 3 ($i=3$, $x_3=A$):**\n我们计算发射完整序列 $A,D,A$ 的路径的概率。\n$v_{M_1}(3) = 0$。\n$v_{I_1}(3) = e_{I_1}(A) \\cdot (v_{I_1}(2) \\cdot a_{I_1,I_1}) = \\frac{1}{3} \\cdot (\\frac{1}{80} \\cdot \\frac{1}{2}) = \\frac{1}{480}$。反向指针：$I_1(2)$。\n$v_{M_2}(3) = e_{M_2}(A) \\cdot (v_{I_1}(2) \\cdot a_{I_1,M_2}) = \\frac{1}{5} \\cdot (\\frac{1}{80} \\cdot \\frac{1}{2}) = \\frac{1}{800}$。反向指针：$I_1(2)$。\n$v_{I_2}(3) = e_{I_2}(A) \\cdot \\max \\{ v_{M_2}(2) \\cdot a_{M_2,I_2}, v_{I_2}(2) \\cdot a_{I_2,I_2} \\} = \\frac{1}{3} \\cdot \\max\\{\\frac{9}{50} \\cdot \\frac{1}{10}, \\frac{1}{1200} \\cdot \\frac{1}{2}\\} = \\frac{1}{3} \\cdot \\max\\{\\frac{9}{500}, \\frac{1}{2400}\\} = \\frac{1}{3} \\cdot \\frac{9}{500} = \\frac{3}{500}$。反向指针：$M_2(2)$。\n对于 $i=3$ 时的删除状态：$v_{D_1}(3)=0$，$v_{D_2}(3)=0$。\n\n**终止：**\n最可能路径的概率 $P^*$ 是通过考虑从 $i=3$ 时的最终状态到结束状态 $E$ 的转移来找到的。\n$$P^* = \\max \\begin{cases} v_{M_2}(3) \\cdot a_{M_2,E} \\\\ v_{D_2}(3) \\cdot a_{D_2,E} \\\\ v_{I_2}(3) \\cdot a_{I_2,E} \\end{cases}$$\n$v_{D_2}(3) = 0$，所以我们比较另外两项。\n结束于 $M_2$ 的路径：$v_{M_2}(3) \\cdot a_{M_2,E} = \\frac{1}{800} \\cdot \\frac{9}{10} = \\frac{9}{8000}$。\n结束于 $I_2$ 的路径：$v_{I_2}(3) \\cdot a_{I_2,E} = \\frac{3}{500} \\cdot \\frac{1}{2} = \\frac{3}{1000} = \\frac{24}{8000}$。\n最大概率为 $\\frac{3}{1000}$，由结束于状态 $I_2$ 的路径达到。\nViterbi 路径概率为 $P^* = \\frac{3}{1000}$。\n\n通过从 $i=3$ 时的状态 $I_2$ 回溯反向指针：\n- $i=3$ 时的状态是 $I_2$，它来自 $i=2$ 时的 $M_2$。\n- $i=2$ 时的状态是 $M_2$，它来自 $i=1$ 时的 $M_1$。\n- $i=1$ 时的状态是 $M_1$，它来自起始状态 $B$。\n唯一最可能的状态路径是 $\\pi^* = (B, M_1, M_2, I_2, E)$。\n该路径从 $M_1$ 发射 $x_1=A$，从 $M_2$ 发射 $x_2=D$，从 $I_2$ 发射 $x_3=A$。\n序列 $X$ 与模型匹配列的有间隙比对如下：\n模型列：$1, 2$\n序列：    $A, D, A$\n序列字符 $A$ 与匹配列 $1$ 对齐，$D$ 与匹配列 $2$ 对齐，最后的 $A$ 对应于列 $2$ 之后的一次插入。\n\n问题要求计算 Viterbi 路径概率的自然对数，并四舍五入到四位有效数字。\n$P^* = \\frac{3}{1000} = 0.003$。\n$$\\ln(P^*) = \\ln(0.003) = \\ln(3) - \\ln(1000) \\approx 1.098612 - 6.907755 \\approx -5.809143$$\n将此值四舍五入到四位有效数字得到 $-5.809$。", "answer": "$$\\boxed{-5.809}$$", "id": "2436882"}, {"introduction": "现实世界的生物数据很少是完美的，缺失观测值是一个常见的挑战。这个实践问题要求您调整算法以处理带有缺失数据点的序列，从而展示了维特比算法的灵活性。您将学习如何通过边缘化的方法来修改发射概率的计算，这是一种对于稳健的生物信息学分析至关重要的、统计上合理的方法。[@problem_id:2436943]", "problem": "给定一个离散的隐马尔可夫模型 (HMM)，它具有有限的状态空间和有限的发射字母表，常用于计算生物学中的序列标注任务，例如基因查找。该 HMM 由以下几个部分定义：状态上的初始状态分布 $\\boldsymbol{\\pi}$、状态转移矩阵 $\\mathbf{A}$ 和发射概率矩阵 $\\mathbf{B}$。时间 $t$ 的状态为 $S_t \\in \\{0,1,\\dots,N-1\\}$，时间 $t$ 观测到的符号为 $Y_t \\in \\{0,1,\\dots,M-1\\}$。根据马尔可夫假设和条件独立性假设，联合分布可分解为\n$$\nP(S_{1:T}, Y_{1:T}) \\;=\\; \\pi_{S_1}\\,\\prod_{t=2}^{T} A_{S_{t-1},S_t} \\;\\prod_{t=1}^{T} B_{S_t, Y_t},\n$$\n其中 $T$ 是序列长度。在许多生物学场景中，某些观测值会缺失，例如由于覆盖率低或碱基调用不明确。我们用哨兵值 $-1$ 表示缺失的观测值，对于这样的时间点，通过对所有可能的符号进行边缘化来定义其发射贡献：\n$$\n\\text{if } Y_t = -1,\\quad \\text{use the factor } \\sum_{x=0}^{M-1} B_{S_t, x}.\n$$\n\n您的任务是实现一个程序，在最大后验 (MAP) 准则下，通过选择最可能的状态路径 $\\hat{s}_{1:T}$ 来执行解码，\n$$\n\\hat{s}_{1:T} \\in \\arg\\max_{s_{1:T}} P(S_{1:T} = s_{1:T} \\mid Y_{1:T} = y_{1:T}),\n$$\n这等价于最大化联合概率 $P(S_{1:T} = s_{1:T}, Y_{1:T} = y_{1:T})$，因为观测值的边际似然相对于路径是恒定的。您的实现必须在对数空间中使用动态规划以确保数值稳定性，并且必须通过在指定时间点对发射字母表进行正确的边缘化来处理缺失的观测值。所有对数都必须是自然对数。\n\n使用以下具体的 HMM 和测试套件。字母表是脱氧核糖核酸 (DNA) 核苷酸，通过 $\\{0 \\mapsto \\text{A},\\, 1 \\mapsto \\text{C},\\, 2 \\mapsto \\text{G},\\, 3 \\mapsto \\text{T}\\}$ 映射为整数。该模型有 $N=2$ 个状态，标记为 $0$ 和 $1$，其初始分布、转移和发射由以下给出：\n- 初始分布 $\\boldsymbol{\\pi} = [\\,0.6,\\, 0.4\\,]$。\n- 转移矩阵\n$$\n\\mathbf{A} \\;=\\;\n\\begin{bmatrix}\n0.9  0.1 \\\\\n0.2  0.8\n\\end{bmatrix}.\n$$\n- 发射矩阵\n$$\n\\mathbf{B} \\;=\\;\n\\begin{bmatrix}\n0.30  0.20  0.20  0.30 \\\\\n0.15  0.35  0.35  0.15\n\\end{bmatrix},\n$$\n其中第 $i$ 行给出 $P(Y_t = x \\mid S_t = i)$，对于 $x \\in \\{0,1,2,3\\}$。\n\n实现满足以下条件的解码算法：\n- 仅基于上述 HMM 定义和独立性假设，使用动态规划最大化状态路径的后验概率。\n- 在对数空间中工作。\n- 对于观测到的符号 $y_t \\in \\{0,1,2,3\\}$，使用发射对数因子 $\\log B_{i,y_t}$。\n- 对于缺失的符号 $y_t = -1$，对每个状态 $i$ 使用发射对数因子 $\\log\\left(\\sum_{x=0}^{3} B_{i,x}\\right)$，这对应于对未观测符号的边缘化。\n\n您的程序必须将此解码器应用于以下观测序列的测试套件（每个序列是一个整数列表，其中 $-1$ 表示缺失的观测值）：\n- 测试 1（正常路径，无缺失）：$[\\,0,\\,1,\\,2,\\,3,\\,1\\,]$。\n- 测试 2（间歇性缺失）：$[\\,0,\\, -1,\\, 2,\\, -1,\\, 3\\,]$。\n- 测试 3（全部缺失）：$[\\, -1,\\, -1,\\, -1,\\, -1\\,]$。\n- 测试 4（边界情况，单个缺失）：$[\\, -1\\,]$。\n- 测试 5（边界情况，单个观测）：$[\\, 3\\,]$。\n\n每个测试用例所需的输出是解码后的最可能状态序列，形式为长度为 $T$ 的整数列表。您的程序应生成单行输出，其中包含五个测试用例的结果，格式为一个用方括号括起来的逗号分隔列表，其中每个元素本身就是一个解码后的路径列表。例如，输出格式必须与以下完全相同：\n[ [s11,s12,...,s1T1], [s21,s22,...], [s31,...], [s41], [s51] ]\n其中每个 $s_{ij}$ 是一个整数状态索引。不得打印任何额外的文本。此问题不涉及任何物理单位、角度或百分比，因此输出中不应包含这些内容。程序必须完全自包含，且不得读取任何输入。", "solution": "首先对问题进行验证。\n\n步骤 1：提取给定信息\n-   一个隐马尔可夫模型 (HMM)，具有 $N$ 个状态 $S_t \\in \\{0, 1, \\dots, N-1\\}$ 和 $M$ 个发射符号 $Y_t \\in \\{0, 1, \\dots, M-1\\}$。\n-   初始状态分布：$\\boldsymbol{\\pi}$，一个包含 $N$ 个元素的向量。\n-   状态转移矩阵：$\\mathbf{A}$，一个 $N \\times N$ 矩阵，其中 $A_{ij} = P(S_t = j \\mid S_{t-1} = i)$。\n-   发射概率矩阵：$\\mathbf{B}$，一个 $N \\times M$ 矩阵，其中 $B_{ix} = P(Y_t = x \\mid S_t = i)$。\n-   联合概率分布：$P(S_{1:T}, Y_{1:T}) = \\pi_{S_1} \\prod_{t=2}^{T} A_{S_{t-1},S_t} \\prod_{t=1}^{T} B_{S_t, Y_t}$。\n-   缺失观测值：由值 $-1$ 表示。\n-   缺失观测值的处理：对于 $Y_t = -1$，发射因子为 $\\sum_{x=0}^{M-1} B_{S_t, x}$。\n-   任务：通过最大化后验概率 $P(S_{1:T} \\mid Y_{1:T})$ 来找到最可能的状态路径 $\\hat{s}_{1:T}$，这等价于最大化联合概率 $P(S_{1:T}, Y_{1:T})$。\n-   约束：实现必须在对数空间（自然对数）中使用动态规划。\n-   发射的对数因子：对于观测到的符号 $y_t$，使用 $\\log B_{i,y_t}$。对于缺失的符号 $y_t = -1$，使用 $\\log\\left(\\sum_{x=0}^{M-1} B_{i,x}\\right)$。\n-   HMM 参数：\n    -   $N=2$ 个状态，$M=4$ 个符号（A, C, G, T 映射到 $0, 1, 2, 3$）。\n    -   $\\boldsymbol{\\pi} = [\\,0.6,\\, 0.4\\,]$。\n    -   $\\mathbf{A} = \\begin{bmatrix} 0.9  0.1 \\\\ 0.2  0.8 \\end{bmatrix}$。\n    -   $\\mathbf{B} = \\begin{bmatrix} 0.30  0.20  0.20  0.30 \\\\ 0.15  0.35  0.35  0.15 \\end{bmatrix}$。\n-   测试用例：\n    1.  $[\\,0,\\,1,\\,2,\\,3,\\,1\\,]$\n    2.  $[\\,0,\\, -1,\\, 2,\\, -1,\\, 3\\,]$\n    3.  $[\\, -1,\\, -1,\\, -1,\\, -1\\,]$\n    4.  $[\\, -1\\,]$\n    5.  $[\\, 3\\,]$\n-   输出格式：表示整数列表的列表的单行字符串，例如 `[ [s11,...], [s21,...] ]`。\n\n步骤 2：使用提取的给定信息进行验证\n对问题陈述进行有效性分析。\n-   **科学依据**：该问题基于标准的隐马尔可夫模型框架和用于解码的维特比算法。这是计算生物学、生物信息学和信号处理中一个基础且广泛使用的方法论。指定的通过对可能的发射进行边缘化来处理缺失数据的方法是一种统计上合理且标准的方法。该问题在科学上是有效的。\n-   **适定性**：该问题要求找出单一的最可能状态路径。维特比算法是一个确定性过程，保证能找到这样一条路径。所有必要的参数（$\\boldsymbol{\\pi}, \\mathbf{A}, \\mathbf{B}$）和条件都已提供，使得问题是自包含且可解的。\n-   **客观性**：该问题以精确的数学和算法术语陈述，没有任何主观或模棱两可的语言。\n\n该问题没有表现出任何诸如科学上不健全、不完整、矛盾或不可行之类的缺陷。参数是有效的概率，维度是一致的。\n\n步骤 3：结论与行动\n问题有效。将提供一个解决方案。\n\n任务是给定一个观测序列 $y_{1:T} = (y_1, \\dots, y_T)$，找到最可能的隐状态序列 $\\hat{s}_{1:T} = (\\hat{s}_1, \\dots, \\hat{s}_T)$。这通过最大化联合概率 $P(s_{1:T}, y_{1:T})$ 来完成。由于该概率是乘积形式，对于长序列，直接计算容易出现数值下溢。因此，我们使用对数概率。目标变为：\n$$\n\\hat{s}_{1:T} = \\arg\\max_{s_{1:T}} \\left( \\log \\pi_{s_1} + \\sum_{t=2}^{T} \\log A_{s_{t-1},s_t} + \\sum_{t=1}^{T} \\log P(y_t \\mid s_t) \\right)\n$$\n这个优化问题具有最优子结构，可以使用动态规划，特别是维特比算法来高效求解。我们定义一个递归量 $\\delta_t(i)$，表示在给定前 $t$ 个观测值的情况下，任何长度为 $t$ 且结束于状态 $i$ 的状态路径的最大对数概率：\n$$\n\\delta_t(i) = \\max_{s_{1:t-1}} \\log P(s_1, \\dots, s_{t-1}, s_t=i, y_1, \\dots, y_t)\n$$\n为了能够重构路径，我们还在一个表 $\\psi_t(i)$ 中存储回溯指针，该表记录了在时间 $t$ 结束于状态 $i$ 的路径的最可能前驱状态。\n\n该算法分三个阶段进行：初始化、递归和回溯。\n\n**1. 初始化 ($t=1$)**\n对于每个状态 $i \\in \\{0, \\dots, N-1\\}$，初始对数概率是初始概率 $\\pi_i$ 的对数与给定状态 $i$ 时第一个观测值 $y_1$ 的对数概率之和。\n$$\n\\delta_1(i) = \\log \\pi_i + \\log P(y_1 \\mid s_1=i)\n$$\n观测对数概率项 $\\log P(y_t \\mid s_t=i)$ 定义为：\n$$\n\\log P(y_t \\mid s_t=i) =\n\\begin{cases}\n    \\log B_{i, y_t}  & \\text{if } y_t \\neq -1 \\\\\n    \\log \\left( \\sum_{x=0}^{M-1} B_{i,x} \\right)  & \\text{if } y_t = -1\n\\end{cases}\n$$\n对于给定的发射矩阵 $\\mathbf{B}$，每一行的和为 1.0，因为它是一个有效的概率分布。因此，对于缺失的观测值 ($y_t = -1$)，对于任何状态 $i$，项 $\\sum_{x=0}^{M-1} B_{i,x} = 1$，其对数为 $\\log(1) = 0$。这意味着缺失的观测值不提供任何偏向某个状态的证据，决策完全依赖于转移概率和初始概率。\n\n回溯指针表 $\\psi_1(i)$ 不需要设置，因为这是路径的起点。\n\n**2. 递归 ($t=2, \\dots, T$)**\n对于每个后续时间步 $t$ 和每个状态 $j \\in \\{0, \\dots, N-1\\}$，我们通过从时间 $t-1$ 扩展最可能的路径来计算 $\\delta_t(j)$。在时间 $t$ 到达状态 $j$ 的路径必须来自时间 $t-1$ 的某个状态 $i$。我们对所有可能的前驱状态 $i$ 进行最大化：\n$$\n\\delta_t(j) = \\left( \\max_{i=0,\\dots,N-1} \\left( \\delta_{t-1}(i) + \\log A_{ij} \\right) \\right) + \\log P(y_t \\mid s_t=j)\n$$\n在时间 $t$ 状态 $j$ 的回溯指针存储了达到此最大值的前驱状态 $i$：\n$$\n\\psi_t(j) = \\arg\\max_{i=0,\\dots,N-1} \\left( \\delta_{t-1}(i) + \\log A_{ij} \\right)\n$$\n这个过程对所有时间步直到 $T$ 重复进行，填充大小为 $T \\times N$ 的 $\\delta$ 和 $\\psi$ 表。\n\n**3. 终止和路径回溯**\n前向传递完成后，单一最可能路径的对数概率是 $\\delta$ 表最后一列中的最大值：\n$$\n\\log P(\\hat{s}_{1:T}, y_{1:T}) = \\max_{i=0,\\dots,N-1} \\delta_T(i)\n$$\n最优路径的最终状态是达到此最大值的状态：\n$$\n\\hat{s}_T = \\arg\\max_{i=0,\\dots,N-1} \\delta_T(i)\n$$\n路径的其余部分通过使用存储在 $\\psi$ 表中的指针从这个最终状态回溯来恢复：\n$$\n\\hat{s}_{t-1} = \\psi_t(\\hat{s}_t) \\quad \\text{for } t = T, T-1, \\dots, 2\n$$\n此过程产生完整的最可能状态序列 $\\hat{s}_{1:T}$。实现将把此算法应用于每个提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the HMM decoding problem for the specified test cases.\n    \"\"\"\n\n    # Define HMM parameters as per the problem statement.\n    pi = np.array([0.6, 0.4])\n    A = np.array([\n        [0.9, 0.1],\n        [0.2, 0.8]\n    ])\n    B = np.array([\n        [0.30, 0.20, 0.20, 0.30],\n        [0.15, 0.35, 0.35, 0.15]\n    ])\n\n    # Define the test suite of observation sequences.\n    test_cases = [\n        [0, 1, 2, 3, 1],\n        [0, -1, 2, -1, 3],\n        [-1, -1, -1, -1],\n        [-1],\n        [3],\n    ]\n\n    def viterbi_log_decode(y_seq, pi, A, B):\n        \"\"\"\n        Performs Viterbi decoding in log-space for an HMM, handling missing observations.\n\n        Args:\n            y_seq (list[int]): Sequence of observations. -1 denotes a missing observation.\n            pi (np.ndarray): Initial state distribution.\n            A (np.ndarray): State transition matrix.\n            B (np.ndarray): Emission matrix.\n\n        Returns:\n            list[int]: The most likely sequence of hidden states.\n        \"\"\"\n        T = len(y_seq)\n        if T == 0:\n            return []\n        \n        N, M = B.shape\n\n        # Precompute log probabilities to work in log-space for numerical stability.\n        # Add a small epsilon to avoid log(0) if any probabilities were zero.\n        # Although not needed for this problem's parameters.\n        epsilon = 1e-10\n        log_pi = np.log(pi + epsilon)\n        log_A = np.log(A + epsilon)\n        log_B = np.log(B + epsilon)\n\n        # For missing observations, the factor is sum(P(y|s)) over all y.\n        # Since B rows sum to 1, this is log(1) = 0.\n        log_B_missing = np.log(np.sum(B, axis=1))\n\n        # Initialize DP tables\n        # delta[t, i]: max log-probability of a path of length t ending in state i\n        delta = np.zeros((T, N))\n        # psi[t, i]: most likely predecessor state for a path of length t to state i\n        psi = np.zeros((T, N), dtype=int)\n\n        # Initialization step (t=0)\n        y_0 = y_seq[0]\n        log_emissions_0 = log_B[:, y_0] if y_0 != -1 else log_B_missing\n        delta[0, :] = log_pi + log_emissions_0\n\n        # Recursion step (t=1..T-1)\n        for t in range(1, T):\n            y_t = y_seq[t]\n            log_emissions_t = log_B[:, y_t] if y_t != -1 else log_B_missing\n            \n            # Vectorized computation of scores for all transitions\n            # scores[i, j] = delta[t-1, i] + log_A[i, j]\n            scores = delta[t-1, :, np.newaxis] + log_A\n\n            delta[t, :] = np.max(scores, axis=0) + log_emissions_t\n            psi[t, :] = np.argmax(scores, axis=0)\n\n        # Termination and backtracking\n        path = np.zeros(T, dtype=int)\n        path[T-1] = np.argmax(delta[T-1, :])\n\n        for t in range(T-2, -1, -1):\n            path[t] = psi[t+1, path[t+1]]\n            \n        return path.tolist()\n\n    results = []\n    for y_seq in test_cases:\n        decoded_path = viterbi_log_decode(y_seq, pi, A, B)\n        results.append(decoded_path)\n    \n    # Format the output as specified: list of lists, with spaces after commas.\n    # The expected output format is [[...], [...], ...], without extra spaces.\n    # Using str(results) produces Python's default representation, which might have spaces.\n    # To match the example `[ [s11,s12,...], ... ]` we will build it manually.\n    result_str = \"[\" + \", \".join(str(p) for p in results) + \"]\"\n    print(result_str.replace(\" \", \"\"))\n\n\nsolve()\n```", "id": "2436943"}, {"introduction": "先进的HMM架构，例如用于基因发现的HMM，通常包含可以形成环路的“沉默”（非发射）状态。这些环路可能导致一个朴素的维特比算法实现陷入无限循环。这个问题挑战您像算法设计者一样思考，通过考虑模型的底层图结构，确定处理这些环路的正确且严谨的策略，以确保算法的终止性和准确性。[@problem_id:2436893]", "problem": "您正在实现维特比（Viterbi）算法，用于在一个用于蛋白质结构域检测的轮廓模型（profile model）的隐马尔可夫模型（HMM）中解码最可能的状态路径。该模型包含一个静默状态（非发射状态）的子集，这些状态可以相互转移，并可能形成有向循环（例如，删除状态链）。所有转移概率都是有效的，即每个状态的出向转移概率之和为$1$，且每个单独的转移概率都在$[0,1]$范围内。您在对数空间（log-space）中工作，因此转移概率被映射为$\\le 0$的对数权重。如果静默状态可以被无限次地重访，那么一种沿着静默转移重复松弛直到没有变化被观察到的朴素实现可能会无法终止。\n\n哪一种单一策略既能 (i) 保证对于任何具有循环静默状态转移的此类模型，解码过程都能终止，又能 (ii) 在原始模型下保留精确的最大概率维特比解码结果？\n\nA. 对每个静默转移添加一个小的惩罚$\\epsilon>0$（即从每个对数权重中减去$\\epsilon$），以使任何静默循环的总对数权重都严格为负，然后运行常规的维特比算法。\n\nB. 通过将每个强连通分量收缩成一个元状态来预处理静默状态子图，计算每个分量内其入口点和出口点之间的最佳纯静默连接值（因为循环对数权重$\\le 0$，所以不需要任何循环），从而获得一个关于静默元状态的有向无环图，然后在每个观测位置对静默转移进行单次拓扑排序遍历来运行维特比算法。\n\nC. 对连续的静默转移施加一个最多$K$次的硬性上限（其中$K$为一个选定的较大值），并中止任何试图超过$K$次连续静默转移的路径。\n\nD. 在解码前从模型中移除所有静默到静默的转移，只留下从静默到发射或从发射到静默状态的转移。\n\nE. 在维特比算法执行期间，每当一条部分路径试图重新进入一个已经存在于该部分路径当前堆栈中的静默状态时，就剪除该更新并继续，从而使同一部分路径不会连续两次访问任何静默状态。", "solution": "问题陈述提出了一个关于为包含静默（非发射）状态的隐马尔可夫模型（HMM）实现维特比（Viterbi）算法的疑问。其中一个关键挑战是，由于这些静默状态之间存在有向循环，可能导致算法无法终止。任务是确定一种策略，既能解决这个不终止的问题，又能保持维特比解码的精确性。\n\n首先，我们必须验证问题陈述的有效性。\n\n**步骤1：提取已知条件**\n- **算法**：用于HMM解码的维特比（Viterbi）算法。\n- **模型**：用于蛋白质结构域检测的轮廓HMM。\n- **状态**：包含一个静默（非发射）状态的子集。\n- **转移**：静默状态可以转移到其他静默状态，可能形成有向循环。\n- **概率**：所有转移概率都有效，即对任何状态，其出向转移概率之和为$1$，且每个单独的概率$p$满足$0 \\le p \\le 1$。\n- **计算空间**：计算在对数空间中进行。转移概率$p$被映射为对数权重$\\log(p) \\le 0$。\n- **问题**：针对静默转移的朴素迭代松弛方法在静默状态可以通过循环被无限重访时可能无法终止。\n- **目标**：找到一个单一策略，该策略能保证解码过程终止，并保留原始模型的精确最大概率维特比路径。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在计算生物学和生物信息学领域有充分的依据。轮廓HMM、静默状态（例如，删除状态）、维特בי算法以及对数概率的使用都是标准组成部分。静默状态之间的循环问题是HMM软件（例如，HMMER，SAM）中一个已知且重要的实现细节。\n- **适定性**：这个问题是适定的。它描述了一种特定的算法病理——因循环导致的不终止——并寻求一个满足两个明确、客观标准（保证终止和精确性）的解决方案。\n- **一致性和完整性**：问题陈述是自洽的。对数权重$\\le 0$这一事实直接源于转移概率$\\le 1$。不终止问题特别出现在总对数权重为$0$的循环中（即所有组成转移的概率都为$1$），这在HMM中是一个有效但可能是边缘的情况。该设定足以评估所提出的策略。\n\n**步骤3：结论与行动**\n问题陈述是有效的。它在科学上是合理的，是适定的，并且内部一致。我们可以继续推导解决方案并评估所提供的选项。\n\n维特比算法在观测索引$i$处对于状态$k$的核心，是计算在观测到前缀$x_1...x_i$后，结束于状态$k$的路径的最大对数概率。这被记为$v_k(i)$。对于一个发射状态$k$，其递推公式为：\n$$v_k(i) = \\log e_k(x_i) + \\max_{j} \\left( v_j(i-1) + \\log a_{jk} \\right)$$\n其中$a_{jk}$是从状态$j$到状态$k$的转移概率，$e_k(x_i)$是发射概率。\n\n对于一个静默状态$s$，没有观测值被消耗。因此，更新必须相对于*相同*观测索引$i$处的其他状态概率来计算。设$v_s(i)$为在处理完观测$x_i$*后*到达静默状态$s$的维特比分数。该分数由从那些其分数已在索引$i-1$（如果是发射状态）或$i$（如果是静默状态）最终确定的状态转移而来。\n$$v_s(i) = \\max \\left( \\max_{j \\in \\text{emitting}} \\left(v_j(i-1) + \\log a_{js} \\right), \\max_{s' \\in \\text{silent}} \\left( v_{s'}(i) + \\log a_{s's} \\right) \\right)$$\n右侧$v_{s'}(i)$项的存在表明在索引$i$处的静默状态之间存在一个依赖系统。如果静默到静默的转移图包含循环，这就变成了一个必须求解的方程组。这等价于在静默状态子图中寻找最长路径，其中初始路径分数由前一个维特比列（索引$i-1$）的转移提供。\n\n由于所有转移的对数权重$\\log(a_{s's})$都是非正的（$\\le 0$），该子图中的任何循环的总权重都为非正。只有当存在总权重为$0$的循环时，朴素的迭代松弛才会无法终止。一个正确的算法必须能处理这种可能性。\n\n我们现在评估每个选项。\n\n**A. 对每个静默转移添加一个小的惩罚$\\epsilon>0$（即从每个对数权重中减去$\\epsilon$），以使任何静默循环的总对数权重都严格为负，然后运行常规的维特比算法。**\n该策略确保静默状态子图中的每个循环都有严格为负的对数权重。基于松弛的方法（如解决无正权重环图中最长路径问题的Bellman-Ford算法）现在保证能够终止。因此，条件(i)，即终止性，得到满足。\n然而，这种方法修改了HMM的参数。通过从对数权重中减去$\\epsilon$，我们实际上是将原始概率乘以$e^{-\\epsilon} < 1$。得到的维特比路径是对于*修改后*的模型的最优路径，而不一定是对于*原始*模型的最优路径。这将比原始模型更重地惩罚具有许多静默到静默转移的路径，可能改变最优路径。因此，该策略未能满足条件(ii)，即保留精确的解码结果。\n**结论：不正确。**\n\n**B. 通过将每个强连通分量收缩成一个元状态来预处理静默状态子图，计算每个分量内其入口点和出口点之间的最佳纯静默连接值（因为循环对数权重$\\le 0$，所以不需要任何循环），从而获得一个关于静默元状态的有向无环图，然后在每个观测位置对静默转移进行单次拓扑排序遍历来运行维特比算法。**\n该策略基于一个合理的图论分解。\n1.  静默到静默的转移图被分解为其强连通分量（SCCs）。根据定义，SCCs构成的图是一个有向无环图（DAG）。\n2.  在每个SCC内部，我们必须找到从任何具有来自SCC外部的入边（“入口点”）的节点到任何具有通往SCC外部的出边（“出口点”）的节点的最大权重路径。因为所有循环权重都是非正的，所以SCC中任意两点之间的最长路径是明确定义的，并且可以通过所有对最短路径算法（例如，适用于最长路径的Floyd-Warshall算法）或从每个入口点运行单源算法来找到。这正确地计算了遍历SCC内任何片段的最大对数概率。选项措辞中的“不需要任何循环”这一说法略有不精确；最佳路径的计算隐含地考虑了所有可能的路径，包括带循环的路径，但最优路径本身不会遍历负权重循环，而遍历零权重循环并不会改善分数。核心思想是最佳路径分数是可计算的。\n3.  原始的静默状态子图（带循环）被一个等效的元状态（SCCs）和单个状态组成的DAG结构所取代。\n4.  在每个维特比步骤$i$中，静默状态的分数可以根据这个新DAG的拓扑排序进行单次遍历计算。这保证了算法的终止。\n这个过程是精确的。它将通过静默状态子图的所有可能路径（包括循环路径）的净效应正确地总结为DAG中的等效直接转移。修改后的DAG结构中的最大概率路径与原始模型中的最大概率路径完全对应。条件(i)和(ii)都得到满足。这是理论上正确且在实践中被应用的解决方案。\n**结论：正确。**\n\n**C. 对连续的静默转移施加一个最多$K$次的硬性上限（其中$K$为一个选定的较大值），并中止任何试图超过$K$次连续静默转移的路径。**\n该策略保证终止，因为通过静默状态的路径长度不能超过$K$。然而，它是一种临时的启发式方法。真正的最大概率路径可能需要一个长于$K$的静默状态序列（例如，为了模拟蛋白质序列中的长删除）。通过施加一个任意的上限，该算法可能无法找到真正的最优路径。这违反了条件(ii)。\n**结论：不正确。**\n\n**D. 在解码前从模型中移除所有静默到静默的转移，只留下从静默到发射或从发射到静默状态的转移。**\n这种修改将静默状态的图简化为一组孤立的节点，从而轻易地打破所有循环并保证终止。然而，这是对HMM的剧烈且不正确的改变。例如，在轮廓HMM中，删除状态链（$D_k \\to D_{k+1}$）对于模拟多个残基的删除至关重要。移除这些转移会使模型无法表示此类生物学事件，从而从根本上改变其语义。这未能保留原始的解码结果，因此违反了条件(ii)。\n**结论：不正确。**\n\n**E. 在维特比算法执行期间，每当一条部分路径试图重新进入一个已经存在于该部分路径当前堆栈中的静默状态时，就剪除该更新并继续，从而使同一部分路径不会连续两次访问任何静默状态。**\n该策略强制要求任何通过静默状态的路径都必须是*简单路径*（没有重复的顶点）。这保证了终止，因为任何简单路径的长度都受限于静默状态的数量。然而，这在一般情况下是不正确的。在具有非正权重循环的图中，两点之间的最长路径不一定是简单路径。如果存在总对数权重为$0$的循环，最优路径可能会遍历它。例如，一条路径可以进入一个SCC，遍历一个零权重循环，然后退出。该策略会错误地禁止此类路径。选项B通过计算最佳路径成本正确地处理了这种情况（这可能涉及遍历此类循环），而此选项错误地剪除了有效的、且可能是最优的路径片段。这违反了条件(iiii)。\n**结论：不正确。**\n\n总而言之，只有策略B提供了一种既能从算法上保证终止，又能在形式上被证明与在原始、未修改模型上运行维特比（Viterbi）算法产生完全相同结果的解决方案。", "answer": "$$\\boxed{B}$$", "id": "2436893"}]}