{"hands_on_practices": [{"introduction": "要真正理解端到端预测模型，我们必须探究它们如何解释进化信息。这项关于嵌合蛋白的思维实验是探索模型“推理”过程的绝佳方式 [@problem_id:2387803]。它清晰地展示了模型如何利用多重序列比对（MSA）中的共进化信号来折叠各个结构域，但在缺少结构域间共进化联系的情况下，模型将无法确定它们之间的相对位置。", "problem": "一个整合了多重序列比对 (MSA) 和模板搜索的端到端蛋白质结构预测器，会生成一个三维原子模型以及置信度诊断信息，包括逐残基置信度分数（例如，预测的局部距离差异测试 (pLDDT)）和一个预测对齐误差 (PAE) 矩阵。考虑以下输入：一个单链嵌合氨基酸序列 $S$，它通过将一个可溶性蛋白质 $X$ 的 N端 $L_X/2$ 个残基与一个不相关的可溶性蛋白质 $Y$ 的 C端 $L_Y/2$ 个残基直接连接而构建，中间没有任何设计的连接子。假设每个片段分别存在天然同源序列（即，许多序列与 $X$ 的 N端一半相似，许多序列与 $Y$ 的 C端一半相似），但没有天然序列在单链中同时包含这两个片段。这两种来源蛋白质 $X$ 和 $Y$ 在进化上不相关，并且在自然界中不相互作用。\n\n当 $S$ 被提交给这样一个端到端预测器时，哪种结果最有可能出现？\n\nA. 模型生成一个单一的、紧凑的新型折叠，将两半的残基紧密混合在一起，报告整个链上一致的高逐残基置信度和一致的低 PAE，因为端到端架构强制实现全局一致性。\n\nB. 模型产生两个对应于每一半的类结构域单元，具有高的逐残基置信度和低的结构域内 PAE，但具有高的结构域间 PAE 和任意的相对取向；连接点附近的残基可能具有与柔性连接子一致的低置信度。\n\nC. 模型拒绝做出任何预测，因为没有 MSA 跨越整个嵌合体长度，并且模板搜索没有返回全长匹配。\n\nD. 模型自动将 $S$ 分割成两条独立的多肽链，并输出两个独立的结构，忽略了跨连接点的共价连续性。\n\nE. 模型预测两半都完全无序，整个序列的逐残基置信度都很低，因为该嵌合序列没有天然的进化历史。", "solution": "必须首先确定问题陈述的有效性。\n\n**步骤1：提取已知条件**\n-   输入序列：一个单链嵌合氨基酸序列 $S$。\n-   序列组成：$S$ 是通过将一个可溶性蛋白质 $X$ 的 N端 $L_X/2$ 个残基与一个不相关的可溶性蛋白质 $Y$ 的 C端 $L_Y/2$ 个残基连接而成。\n-   连接处：片段被直接连接，没有设计的连接子。\n-   进化信息：每个片段（$X$-半部分和 $Y$-半部分）分别存在同源序列。没有天然序列在单链中同时包含这两个片段。\n-   来源蛋白质：$X$ 和 $Y$ 在进化上不相关，并且在自然界中不相互作用。\n-   预测器模型：一个使用多重序列比对 (MSA) 和模板搜索的端到端蛋白质结构预测器。\n-   预测器输出：一个三维原子模型，一个逐残基置信度分数（例如 pLDDT），以及一个预测对齐误差 (PAE) 矩阵。\n-   问题：将 $S$ 提交给这个预测器最可能的结果是什么？\n\n**步骤2：使用提取的已知条件进行验证**\n问题陈述是科学合理的、定义明确的且客观的。\n-   **科学合理**：该场景描述了蛋白质生物信息学中的一个标准计算实验。所提及的工具和概念——端到端预测器（如 AlphaFold2 或 RoseTTAFold）、MSA、模板搜索、pLDDT 和 PAE——都是蛋白质结构预测领域的既定核心内容。构建嵌合蛋白是一种常见的做法。\n-   **定义明确**：问题清晰地定义了特定的输入 ($S$) 和特定的计算系统（预测器）。它要求的是“最可能的结果”，基于这些深度学习模型的已知架构和功能，这个问题有一个确定性的答案。\n-   **客观**：所用术语在该领域内是精确和标准的。没有歧义或主观框架。\n\n这个问题是有效的，因为它不满足任何无效的标准。这是一个关于一类已知计算算法行为的表述清晰的问题。\n\n**步骤3：推导解决方案**\n问题的核心是理解最先进的结构预测器如何处理一个人工嵌合序列。这些预测器严重依赖于从 MSA 中推导出的共进化信息。\n\n1.  **MSA 构建**：对于嵌合序列 $S$，MSA 搜索工具会找到大量与前半部分（$X$ 片段）比对良好的同源序列，以及大量与后半部分（$Y$ 片段）比对良好的其他序列。然而，如前所述，没有天然序列能够跨越 $S$ 的全长进行比对。最终得到的 MSA 在本质上将是“块对角”的：\n    -   N端一半的密集比对块。\n    -   C端一半的密集比对块。\n    -   连接两个块的信息非常稀疏或没有信息。\n    这意味着模型可以提取 $X$ 片段 *内部* 和 $Y$ 片段 *内部* 的强烈共进化信号（指示残基-残基接触），但不能提取它们 *之间* 的信号。\n\n2.  **信息处理与结构预测**：预测器的神经网络（通常是基于注意力机制的架构）会处理这个 MSA。\n    -   **结构域内结构**：强烈的结构域内共进化信号为模型提供了足够的信息，使其能够将嵌合体的每一半精确地折叠成其类天然构象。因此，我们预期会看到两个定义明确的、分别对应于 $X$ 和 $Y$ 片段的结构域。\n    -   **结构域间排布**：由于两个片段之间缺乏共进化信号，模型没有信息来约束它们的相对取向。蛋白质 $X$ 和 $Y$ 不相关且不相互作用，因此没有任何进化压力来形成任何特定的界面。模型没有被训练在缺乏证据的情况下发明新的相互作用。因此，两个结构域的相对位置和取向将是任意且不确定的。\n\n3.  **置信度度量**：模型会报告其自身的置信度，这反映了它所拥有的信息。\n    -   **pLDDT (逐残基置信度)**：这个分数衡量对局部原子环境的置信度。对于每个折叠结构域深处的残基，MSA 为其提供了丰富信息，pLDDT 将会很高（通常 > 90）。在人工连接处，序列上下文被破坏，局部环境是非天然的。模型可能会报告这些少数残基的较低置信度（例如，pLDDT  70），这与柔性或无序区域一致。\n    -   **PAE (预测对齐误差)**：这个矩阵对于理解结构域关系至关重要。对于长度为 $L = L_X/2 + L_Y/2$ 的序列 $S$，其 PAE 图将显示：\n        -   **低 PAE**（暗色块）对应于残基对 $(i, j)$，其中 $i$ 和 $j$ 都在第一个结构域内 ($1 \\le i, j \\le L_X/2$) 或都在第二个结构域内 ($L_X/2  i, j \\le L$)。这表明对每个结构域的内部结构有很高的置信度。\n        -   **高 PAE**（浅色块）对应于残基对 $(i, j)$，其中 $i$ 在第一个结构域内 ($1 \\le i \\le L_X/2$) 而 $j$ 在第二个结构域内 ($L_X/2  j \\le L$)。这表明对两个结构域的相对定位置信度低。\n\n这一详细分析预测了两个独立的、折叠良好的结构域的形成，它们之间具有未定义的相对取向，这一点会被模型的置信度度量精确地报告出来。\n\n**步骤4：逐项分析选项**\n\nA. 模型生成一个单一的、紧凑的新型折叠，将两半的残基紧密混合在一起，报告整个链上一致的高逐残基置信度和一致的低 PAE，因为端到端架构强制实现全局一致性。\n**错误**。模型不会在没有来自 MSA 或模板的证据的情况下发明相互作用。PAE 不会一致地低；在对应于结构域间位置的非对角块中，PAE 会很高，反映出缺乏关于它们相对布局的信息。\n\nB. 模型产生两个对应于每一半的类结构域单元，具有高的逐残基置信度和低的结构域内 PAE，但具有高的结构域间 PAE 和任意的相对取向；连接点附近的残基可能具有与柔性连接子一致的低置信度。\n**正确**。该选项精确地描述了上面推导出的预期结果。它正确地预测了两个结构域的形成，pLDDT 中高低置信度的模式，以及 PAE 矩阵的块状结构，这反映了可信的结构域内折叠，但结构域间的排布不受约束。\n\nC. 模型拒绝做出任何预测，因为没有 MSA 跨越整个嵌合体长度，并且模板搜索没有返回全长匹配。\n**错误**。现代预测器是鲁棒的，被设计用来处理不完整的信息。序列部分存在的强信号足以让模型继续进行并生成一个结构，并通过置信度分数来表达其不确定性，而不是完全失败。\n\nD. 模型自动将 $S$ 分割成两条独立的多肽链，并输出两个独立的结构，忽略了跨连接点的共价连续性。\n**错误**。输入是一个单一的连续序列，模型会尊重这种共价拓扑结构。它将生成一个单一的多肽链结构。结构域之间缺乏约束是它们预测的空间关系的一个属性，而不是一级序列的断裂。\n\nE. 模型预测两半都完全无序，整个序列的逐残基置信度都很低，因为该嵌合序列没有天然的进化历史。\n**错误**。虽然整个嵌合体是人工的，但其组成部分有清晰的进化历史，并且作为可溶性蛋白质的一部分，很可能是有结构的。预测器将利用每一半可用的强大 MSA 信息，将它们预测为折叠的结构域。因此，大多数残基的置信度会很高，而不是整体都很低。", "answer": "$$\\boxed{B}$$", "id": "2387803"}, {"introduction": "在理解了模型的高层逻辑之后，我们来审视一个关键的中间步骤：距离图（distogram）的生成。这项练习引入了一种评估预测距离图几何自洽性的方法，即通过检查其是否违反了三角不等式 [@problem_id:2387757]。较低的违规分数意味着模型预测的距离图在几何上是合理的，更有可能折叠成一个有效的三维结构。", "problem": "你的任务是形式化一个用于预测的蛋白质残基间距离（“distogram”近似）的逐残基局部质量度量，通过量化对三角不等式的违反程度来实现。三角不等式是三维欧几里得空间中欧氏距离的一个基本性质。在像欧几里得 $\\mathbb{R}^3$ 这样的度量空间中，任意三点 $i$、$j$ 和 $k$ 之间的距离函数 $d(\\cdot,\\cdot)$ 必须满足三角不等式 $d(i,k) \\le d(i,j) + d(j,k)$。对于蛋白质结构，使用 $\\alpha$-碳原子之间的距离时，这个不等式对于真实结构必须严格成立。然而，预测的 distogram 可能会表现出局部不一致性，即对于某些三元组存在 $d(i,k)  d(i,j) + d(j,k)$ 的情况，这为围绕残基 $j$ 的预测提供了一个局部质量度量的基础。\n\n以欧几里得空间中的三角不等式为基础，并基于“预测的 distogram 近似于真实的度量距离但可能违反度量公理”这一概念，设计并实现一个算法来计算每个残基索引 $j$ 的局部违反分数。该分数定义为：当 $j$ 作为所有满足 $i \\ne j$、$k \\ne j$ 和 $i  k$ 的无序对 $(i,k)$ 之间的中间节点时，三角不等式被违反的平均幅度。", "solution": "所提出的问题陈述是有效的。它具有科学依据、定义明确且客观。任务是为一个预测的蛋白质残基间距离矩阵（称为 distogram）形式化并计算一个逐残基的局部质量分数。该度量的基础是三角不等式，这是任何度量空间（包括蛋白质结构所在的$\\mathbb{R}^3$三维欧几里得空间）的基本公理。一个预测的 distogram 可能无法完美嵌入到 $\\mathbb{R}^3$ 中，从而导致对该不等式的违反。量化这些违反情况，可直接衡量预测结构中的局部几何不一致性。\n\n该问题形式化如下。设残基索引的集合为 $\\mathcal{R} = \\{0, 1, \\dots, n-1\\}$，其中 $n$ 是残基数。输入是一个大小为 $n \\times n$ 的对称距离矩阵 $D$，其中元素 $D_{ij}$ 代表残基 $i$ 和 $j$ 之间的预测距离 $d(i,j)$。根据定义，对于所有 $i, j \\in \\mathcal{R}$，有 $D_{ii} = 0$ 和 $D_{ij} = D_{ji}$。\n\n对于任意三点 $i, j, k$ 的三角不等式指出，任意两点之间的距离不大于这两点分别到第三点的距离之和。对于任何残基三元组，这可以表示为三种方式：\n$$ d(i,k) \\le d(i,j) + d(j,k) $$\n$$ d(i,j) \\le d(i,k) + d(k,j) $$\n$$ d(j,k) \\le d(j,i) + d(i,k) $$\n该问题通过将特定残基 $j$ 视为不等式中的中间点来定义其局部质量分数。如果直接距离 $d(i,k)$ 大于通过 $j$ 的路径，即 $d(i,k)  d(i,j) + d(j,k)$，则发生违反。\n\n对于以 $j$ 为中间残基的三元组 $(i,j,k)$，单个违反的幅度定义为差值的正数部分：\n$$ v_{ijk} = \\max\\left(0, D_{ik} - (D_{ij} + D_{jk})\\right) $$\n仅当三角不等式被违反时，该值才非零。\n\n残基 $j$ 的逐残基局部违反分数（我们记作 $V_j$）定义为在外部对 $(i,k)$ 的所有可能选择上这些违反幅度的平均值。对于一个固定的 $j$，其他残基形成一个集合 $\\mathcal{R}_j = \\mathcal{R} \\setminus \\{j\\}$，其大小为 $n-1$。从这个集合中可以形成的唯一无序对 $\\{i,k\\}$ 的数量由二项式系数 $\\binom{n-1}{2}$ 给出。因此，分数 $V_j$ 为：\n$$ V_j = \\frac{1}{\\binom{n-1}{2}} \\sum_{\\{i,k\\} \\subset \\mathcal{R}_j, i  k} v_{ijk} $$\n其中，求和遍历所有 $\\{i,k\\}$ 无序对，条件是 $i$ 和 $k$ 都不等于 $j$。如果 $n  3$，则 $\\binom{n-1}{2}$ 未定义或为0，因此无法形成任何三元组。在这种情况下，违反分数为零。该算法涉及对每个残基 $j$ 迭代所有其他残基对 $(i,k)$，计算违反幅度，并将它们相加，最后除以对的总数。\n\n此计算的伪代码如下：\n1.  输入一个 $n \\times n$ 的距离矩阵 $D$。\n2.  初始化一个长度为 $n$ 的分数数组 $V$ 为全零。\n3.  如果 $n  3$，返回 $V$。\n4.  计算对的数量： `num_pairs = (n - 1) * (n - 2) / 2`。\n5.  对于从 $0$ 到 $n-1$ 的每个残基 $j$：\n    a.  初始化 `total_violation = 0`。\n    b.  对于从 $0$ 到 $n-1$ 的每个残基 $i$：\n        c.  对于从 $i+1$ 到 $n-1$ 的每个残基 $k$：\n            i.  如果 $i \\ne j$ 且 $k \\ne j$：\n                -   `violation = D[i, k] - (D[i, j] + D[j, k])`\n                -   如果 `violation > 0`，则 `total_violation += violation`。\n    d.  `V[j] = total_violation / num_pairs`。\n6.  返回 $V$。", "answer": "```python\nimport numpy as np\n\ndef compute_violation_scores(dist_matrix: np.ndarray) - list[float]:\n    \"\"\"\n    Computes the per-residue local violation score for a given distance matrix.\n\n    Args:\n        dist_matrix: A symmetric n x n numpy array representing the distance matrix.\n\n    Returns:\n        A list of per-residue violation scores, rounded to 6 decimal places.\n    \"\"\"\n    D = np.array(dist_matrix, dtype=np.float64)\n    n = D.shape[0]\n    \n    if n  3:\n        # If n  3, no triangles can be formed. The number of pairs is 0.\n        # The score is defined as 0 in this case.\n        return [0.0] * n\n\n    scores = np.zeros(n, dtype=np.float64)\n    num_pairs = (n - 1) * (n - 2) // 2\n\n    # Iterate over each residue j, which will serve as the intermediate point.\n    for j in range(n):\n        total_violation = 0.0\n        \n        # Create a list of indices excluding j.\n        other_indices = [idx for idx in range(n) if idx != j]\n        \n        # Iterate over all unique pairs (i, k) from the remaining indices.\n        for idx_i in range(len(other_indices)):\n            for idx_k in range(idx_i + 1, len(other_indices)):\n                i = other_indices[idx_i]\n                k = other_indices[idx_k]\n                \n                # Retrieve distances for the triplet (i, j, k).\n                # D_ik is the direct distance.\n                # D_ij + D_jk is the path length through the intermediate residue j.\n                d_ik = D[i, k]\n                d_ij = D[i, j]\n                d_jk = D[k, j] # Using D[k,j] since matrix is symmetric.\n                \n                # Calculate the violation of the triangle inequality: d(i,k) = d(i,j) + d(j,k)\n                violation = d_ik - (d_ij + d_jk)\n                \n                # Accumulate only positive violations.\n                if violation > 0:\n                    total_violation += violation\n        \n        # The score for residue j is the average violation over all pairs (i, k).\n        scores[j] = total_violation / num_pairs\n        \n    return list(scores)\n\ndef solve():\n    \"\"\"\n    Solves the problem for all given test cases and prints the result.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [\n            [0, 1.0, 3.0, 1.41421356237],\n            [1.0, 0, 1.2, 1.0],\n            [3.0, 1.2, 0, 1.562049935],\n            [1.41421356237, 1.0, 1.562049935, 0]\n        ],\n        # Test case 2\n        [\n            [0, 1, 3, 6],\n            [1, 0, 2, 5],\n            [3, 2, 0, 3],\n            [6, 5, 3, 0]\n        ],\n        # Test case 3\n        [\n            [0, 1, 3],\n            [1, 0, 1],\n            [3, 1, 0]\n        ],\n        # Test case 4\n        [\n            [0, 1.0, 2.0, 1.414213562373, 5.0],\n            [1.0, 0, 1.0, 1.0, 2.2360679775],\n            [2.0, 1.0, 0, 3.0, 2.0],\n            [1.414213562373, 1.0, 3.0, 0, 1.414213562373],\n            [5.0, 2.2360679775, 2.0, 1.414213562373, 0]\n        ]\n    ]\n\n    results = []\n    for D_matrix in test_cases:\n        result_vector = compute_violation_scores(D_matrix)\n        results.append(result_vector)\n\n    # Format the final output string as a list of lists without spaces.\n    formatted_vectors = []\n    for vec in results:\n        # Round each score to 6 decimal places.\n        rounded_vec = [round(v, 6) for v in vec]\n        # Format as a string \"[v1,v2,...]\"\n        str_vec = f\"[{','.join(f'{v:.6f}' for v in rounded_vec)}]\"\n        formatted_vectors.append(str_vec)\n    \n    # Final output format: [[...],[...],...]\n    print(f\"[{','.join(formatted_vectors)}]\")\n\nsolve()\n```", "id": "2387757"}, {"introduction": "最后，我们来评估模型的最终输出——三维原子坐标。这项练习介绍了结构比较的黄金标准——均方根偏差（Root-Mean-Square Deviation, RMSD），它需要将两个结构进行最佳叠合。通过将此方法应用于具有两种不同天然折叠状态的“变构蛋白”（metamorphic protein），我们将在一个更复杂、更贴近现实的场景中实践结构评估 [@problem_id:2387752]。", "problem": "您将执行一项针对变构蛋白的端到端蛋白质结构预测模型的正式评估任务。一个变构蛋白可以采取两种不同的稳定折叠形式。对于一个给定的预测三维坐标集 $\\mathbf{P} \\in \\mathbb{R}^{N \\times 3}$（每行代表一个残基，解释为α-碳原子坐标）以及同一序列的两个天然折叠 $\\mathbf{A} \\in \\mathbb{R}^{N \\times 3}$ 和 $\\mathbf{B} \\in \\mathbb{R}^{N \\times 3}$，定义 $\\mathbf{P}$ 与一个天然结构 $\\mathbf{X} \\in \\{\\mathbf{A}, \\mathbf{B}\\}$ 之间的均方根偏差 (RMSD) 为对 $\\mathbf{P}$ 进行所有正常刚体变换后的最小值：\n$$\n\\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{X}) \\triangleq \\min_{\\mathbf{R},\\,\\mathbf{t}} \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| \\mathbf{R}\\,\\mathbf{p}_i + \\mathbf{t} - \\mathbf{x}_i \\right\\|_2^2}\n$$\n其中 $\\mathbf{R} \\in \\mathrm{SO}(3)$（三维空间中的特殊正交旋转群，即 $\\mathbf{R}^{\\top}\\mathbf{R} = \\mathbf{I}$ 且 $\\det(\\mathbf{R}) = 1$）且 $\\mathbf{t} \\in \\mathbb{R}^3$。这里，$\\mathbf{p}_i$ 和 $\\mathbf{x}_i$ 分别表示 $\\mathbf{P}$ 和 $\\mathbf{X}$ 的第 $i$ 行。定义变构评估分数为\n$$\ns(\\mathbf{P}; \\mathbf{A}, \\mathbf{B}) \\triangleq \\min\\left( \\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{A}), \\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{B}) \\right).\n$$\n设接受阈值为 $\\tau = 1.0$ 埃 (Å)。如果 $s(\\mathbf{P}; \\mathbf{A}, \\mathbf{B}) \\le \\tau$，则认为对变构蛋白的预测是正确的。所有 RMSD 值必须以 Å 为单位表示，并在最终输出中四舍五入到三位小数。\n\n测试套件。对于每个测试用例 $k \\in \\{1,2,3\\}$，给定序列长度 $N_k$ 和两个天然折叠 $\\mathbf{A}^{(k)}$ 和 $\\mathbf{B}^{(k)}$。您必须按照上述定义，针对 $\\mathbf{A}^{(k)}$ 和 $\\mathbf{B}^{(k)}$ 评估一个指定的预测结构 $\\mathbf{P}^{(k)}$。下文出现的角度以弧度为单位。\n\n- 测试用例 1（理想情况；预测结果与第一个折叠形式在刚体变换下匹配）：\n  - $N_1 = 5$。\n  - $\\mathbf{A}^{(1)}$ 的各行为\n    $$\n    (0,0,0),\\ (3.8,0,0),\\ (7.6,0,0),\\ (11.4,0,0),\\ (15.2,0,0).\n    $$\n  - 定义 $\\delta \\triangleq \\frac{3.8}{\\sqrt{2}}$。$\\mathbf{B}^{(1)}$ 的各行为\n    $$\n    (0,0,0),\\ (\\delta,\\delta,0),\\ (2\\delta,0,0),\\ (3\\delta,\\delta,0),\\ (4\\delta,0,0).\n    $$\n  - 设 $\\theta = \\pi/6$ 且 $\\mathbf{t}^{(1)} = (1.1,-2.3,0.5)$。令 $\\mathbf{R}_z(\\theta)$ 表示绕 $z$ 轴旋转 $\\theta$ 角度的旋转，其矩阵为\n    $$\n    \\mathbf{R}_z(\\theta) = \\begin{bmatrix}\n    \\cos\\theta  -\\sin\\theta  0\\\\\n    \\sin\\theta  \\cos\\theta  0\\\\\n    0  0  1\n    \\end{bmatrix}.\n    $$\n    预测结构为\n    $$\n    \\mathbf{P}^{(1)} = \\mathbf{A}^{(1)} \\mathbf{R}_z(\\theta)^{\\top} + \\mathbf{1}\\, (\\mathbf{t}^{(1)})^{\\top},\n    $$\n    其中 $\\mathbf{1} \\in \\mathbb{R}^{N_1 \\times 1}$ 是全一列向量，加法是逐行进行的。\n\n- 测试用例 2（预测结果与第二个折叠形式在刚体变换下匹配）：\n  - $N_2 = 6$。\n  - $\\mathbf{A}^{(2)}$ 的各行为\n    $$\n    (0,0,0),\\ (0,3.8,0),\\ (0,7.6,0),\\ (0,11.4,0),\\ (0,15.2,0),\\ (0,19.0,0).\n    $$\n  - $\\mathbf{B}^{(2)}$ 的各行为\n    $$\n    (0,0,0),\\ (3.8,0,0),\\ (7.6,0,0),\\ (7.6,3.8,0),\\ (7.6,7.6,0),\\ (7.6,11.4,0).\n    $$\n  - 设 $\\phi = -\\pi/3$ 且 $\\mathbf{t}^{(2)} = (0.2,-0.5,1.0)$。预测结构为\n    $$\n    \\mathbf{P}^{(2)} = \\mathbf{B}^{(2)} \\mathbf{R}_z(\\phi)^{\\top} + \\mathbf{1}\\, (\\mathbf{t}^{(2)})^{\\top}.\n    $$\n\n- 测试用例 3（边缘情况；一个无法通过正常旋转匹配的镜像预测）：\n  - $N_3 = 5$。\n  - 通过累加以下长度为 $3.8$ 的步长向量来构建 $\\mathbf{A}^{(3)}$：\n    $$\n    \\mathbf{s}_1 = \\left(3.8\\cos\\left(\\frac{\\pi}{3}\\right),\\ 3.8\\sin\\left(\\frac{\\pi}{3}\\right),\\ 0\\right),\n    $$\n    $$\n    \\mathbf{s}_2 = \\left(\\sqrt{3.8^2-1.0^2}\\cos\\left(-\\frac{\\pi}{3}\\right),\\ \\sqrt{3.8^2-1.0^2}\\sin\\left(-\\frac{\\pi}{3}\\right),\\ 1.0\\right),\n    $$\n    $$\n    \\mathbf{s}_3 = \\left(\\sqrt{3.8^2-0.7^2}\\cos\\left(\\frac{\\pi}{9}\\right),\\ \\sqrt{3.8^2-0.7^2}\\sin\\left(\\frac{\\pi}{9}\\right),\\ -0.7\\right),\n    $$\n    $$\n    \\mathbf{s}_4 = \\left(\\sqrt{3.8^2-0.9^2}\\cos\\left(-\\frac{13\\pi}{18}\\right),\\ \\sqrt{3.8^2-0.9^2}\\sin\\left(-\\frac{13\\pi}{18}\\right),\\ 0.9\\right).\n    $$\n    令第一行为 $(0,0,0)$，随后的每一行是 $(0,0,0)$ 与前 $j$ 个步长向量之和，其中 $j \\in \\{1,2,3,4\\}$。因此 $\\mathbf{A}^{(3)}$ 有 5 行。\n  - 令 $\\mathbf{B}^{(3)}$ 与测试用例 1 中的 $\\mathbf{B}^{(1)}$ 相同（重用 $\\delta$）。\n  - 定义反射矩阵\n    $$\n    \\mathbf{F} = \\mathrm{diag}(-1,\\,1,\\,1),\n    $$\n    它将 $x \\mapsto -x$ 沿 $yz$ 平面进行镜像。预测结构为\n    $$\n    \\mathbf{P}^{(3)} = \\mathbf{A}^{(3)} \\mathbf{F}^{\\top}.\n    $$\n\n对于每个测试用例 $k$，计算\n- $r_A^{(k)} = \\operatorname{RMSD}^{\\star}(\\mathbf{P}^{(k)}, \\mathbf{A}^{(k)})$，\n- $r_B^{(k)} = \\operatorname{RMSD}^{\\star}(\\mathbf{P}^{(k)}, \\mathbf{B}^{(k)})$，\n- $r^{(k)} = \\min(r_A^{(k)}, r_B^{(k)})$，\n- 如果 $r_A^{(k)} \\le r_B^{(k)}$，则 $m^{(k)} = 1$，否则 $m^{(k)} = 2$，\n- 如果 $r^{(k)} \\le \\tau$，则 $c^{(k)} = \\text{True}$，否则 $c^{(k)} = \\text{False}$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含三个测试用例的结果，形式为逗号分隔的三元组列表，不含空格，并用方括号括起来。每个三元组的形式必须为 $[r^{(k)},m^{(k)},c^{(k)}]$，其中 $r^{(k)}$ 是以 Å 为单位的最小 RMSD，四舍五入到三位小数，$m^{(k)}$ 是整数折叠索引 1 或 2，$c^{(k)}$ 是一个布尔值。例如，输出必须看起来像\n$$\n\\big[ [\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot], [\\cdot,\\cdot,\\cdot] \\big]\n$$\n但要使用实际计算出的值，不含多余空格，且数值按指定格式表示。", "solution": "问题陈述已经过验证，被确定为计算结构生物学中一个定义明确、有科学依据的任务。它为获得唯一且可验证的解提供了所有必要的定义和数据。该问题要求实现一个标准算法，用于计算两组三维坐标之间的均方根偏差 (RMSD)，并将其应用于评估一个蛋白质结构预测相对于一个变构蛋白的两种可能的天然折叠。\n\n问题的核心是计算 $\\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{X})$，它被定义为对预测结构 $\\mathbf{P}$ 进行所有可能的刚体变换后得到的最小 RMSD。刚体变换由一个旋转 $\\mathbf{R}$ 和一个平移 $\\mathbf{t}$ 组成。最小化问题由以下公式给出：\n$$\n\\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{X}) = \\min_{\\mathbf{R} \\in \\mathrm{SO}(3), \\mathbf{t} \\in \\mathbb{R}^3} \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| (\\mathbf{R}\\,\\mathbf{p}_i + \\mathbf{t}) - \\mathbf{x}_i \\right\\|_2^2}\n$$\n这是结构比对中的一个经典问题，其解法可使用 Kabsch 算法或基于奇异值分解 (SVD) 的数值等效方法求得。该过程包括以下步骤：\n\n1.  **坐标中心化**：可以证明，最优平移 $\\mathbf{t}$ 会将旋转后的集合 $\\mathbf{R}\\mathbf{P}$ 的质心叠加到参考集合 $\\mathbf{X}$ 的质心上。因此，第一步是平移两个坐标集，使它们的质心位于原点。设 $\\mathbf{P}$ 和 $\\mathbf{X}$ 为 $N \\times 3$ 的坐标矩阵。质心计算如下：\n    $$\n    \\bar{\\mathbf{p}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{p}_i, \\quad \\bar{\\mathbf{x}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf{x}_i\n    $$\n    然后，通过从每个点减去各自的质心来获得中心化后的坐标矩阵 $\\mathbf{P}'$ 和 $\\mathbf{X}'$：\n    $$\n    \\mathbf{p}'_i = \\mathbf{p}_i - \\bar{\\mathbf{p}}, \\quad \\mathbf{x}'_i = \\mathbf{x}_i - \\bar{\\mathbf{x}}\n    $$\n    中心化后，问题简化为寻找最优旋转 $\\mathbf{R}$，以最小化 $\\mathbf{P}'$ 的变换点与 $\\mathbf{X}'$ 的点之间的距离。\n\n2.  **协方差矩阵**：最优旋转是通过考虑中心化坐标的协方差矩阵来找到的。对于表示为 $N \\times 3$ 矩阵（每行为一个点）的点集，其 $3 \\times 3$ 协方差矩阵 $\\mathbf{H}$ 计算如下：\n    $$\n    \\mathbf{H} = (\\mathbf{P}')^{\\top} \\mathbf{X}'\n    $$\n\n3.  **奇异值分解 (SVD)**：我们对协方差矩阵 $\\mathbf{H}$ 进行 SVD 分解：\n    $$\n    \\mathbf{H} = \\mathbf{U} \\mathbf{\\Sigma} \\mathbf{V}^{\\top}\n    $$\n    此处，$\\mathbf{U}$ 和 $\\mathbf{V}$ 是 $3 \\times 3$ 的正交矩阵，$\\mathbf{\\Sigma}$ 是一个 $3 \\times 3$ 的奇异值对角矩阵。\n\n4.  **最优旋转矩阵**：最大化重叠（从而最小化 RMSD）的最优旋转矩阵 $\\mathbf{R}$ 由以下公式给出：\n    $$\n    \\mathbf{R} = \\mathbf{V} \\mathbf{U}^{\\top}\n    $$\n\n5.  **反射处理**：问题规定旋转 $\\mathbf{R}$ 必须是正常旋转，即它必须属于特殊正交群 $\\mathrm{SO}(3)$，这要求其行列式为 $+1$。上面计算出的矩阵 $\\mathbf{R}$ 的行列式可能为 $-1$。如果一个坐标集是另一个坐标集的镜像（对映体），就会发生这种情况。为确保是正常旋转，我们检查其行列式：\n    $$\n    d = \\det(\\mathbf{R}) = \\det(\\mathbf{V} \\mathbf{U}^{\\top})\n    $$\n    如果 $d = -1$，则最优变换是反射。为了找到最佳的*正常*旋转，我们必须修正 $\\mathbf{R}$。标准方法是反转与最小奇异值相对应的旋转分量。这通过在计算 $\\mathbf{R}$ 之前翻转 $\\mathbf{V}$ 的最后一列的符号来实现：\n    $$\n    \\text{如果 } \\det(\\mathbf{V} \\mathbf{U}^{\\top}) = -1, \\text{ 则设置 } \\mathbf{R} = \\mathbf{V} \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  -1 \\end{pmatrix} \\mathbf{U}^{\\top}\n    $$\n    这种修正保证了 $\\det(\\mathbf{R}) = +1$，并给出了在 $\\mathrm{SO}(3)$ 内的最优解。此检查对于测试用例 3 至关重要，其中预测的结构是天然折叠的显式镜像。\n\n6.  **RMSD 计算**：找到最优正常旋转 $\\mathbf{R}$ 后，对 $\\mathbf{P}'$ 的坐标进行旋转，并使用中心化坐标计算 RMSD：\n    $$\n    \\operatorname{RMSD}^{\\star}(\\mathbf{P}, \\mathbf{X}) = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left\\| \\mathbf{p}'_i \\mathbf{R} - \\mathbf{x}'_i \\right\\|_2^2}\n    $$\n    请注意，对于行向量 $\\mathbf{p}'_i$，旋转应用为 $\\mathbf{p}'_i \\mathbf{R}$。\n\n对于每个测试用例 $k \\in \\{1,2,3\\}$，此过程应用两次：首先计算 $r_A^{(k)} = \\operatorname{RMSD}^{\\star}(\\mathbf{P}^{(k)}, \\mathbf{A}^{(k)})$，其次计算 $r_B^{(k)} = \\operatorname{RMSD}^{\\star}(\\mathbf{P}^{(k)}, \\mathbf{B}^{(k)})$。然后根据这两个 RMSD 值和接受阈值 $\\tau = 1.0$ 来确定变构分数 $r^{(k)}$、匹配折叠索引 $m^{(k)}$ 和正确性标志 $c^{(k)}$。\n\n对于测试用例 1 和 2，预测结构 $\\mathbf{P}^{(k)}$ 是通过对其中一个天然折叠（分别为 $\\mathbf{A}^{(1)}$ 和 $\\mathbf{B}^{(2)}$）应用正常的刚体变换而构建的。因此，与该特定折叠计算出的 RMSD 预计在数值上为零，并且变构分数 $r^{(k)}$ 将为 $0.000$。\n\n对于测试用例 3，$\\mathbf{P}^{(3)}$ 是 $\\mathbf{A}^{(3)}$ 的一个镜像。计算 $\\operatorname{RMSD}^{\\star}(\\mathbf{P}^{(3)}, \\mathbf{A}^{(3)})$ 将触发反射处理步骤，导致一个非零的 RMSD，因为正常旋转无法将一个结构完美地叠加到其镜像上。最终分数将取决于两个非零 RMSD 值 $r_A^{(3)}$ 或 $r_B^{(3)}$ 中哪个更小。", "answer": "```python\nimport numpy as np\n\ndef calculate_rmsd(P, X):\n    \"\"\"\n    Calculates the Root-Mean-Square Deviation (RMSD) between two sets of\n    3D coordinates P and X, minimized over rigid-body transformations.\n\n    This function implements the Kabsch algorithm.\n\n    Args:\n        P (np.ndarray): An N x 3 matrix of coordinates to be aligned.\n        X (np.ndarray): An N x 3 matrix of reference coordinates.\n\n    Returns:\n        float: The RMSD value in the same units as the input coordinates.\n    \"\"\"\n    # Number of points\n    N = P.shape[0]\n\n    # 1. Center the coordinate sets\n    centroid_P = np.mean(P, axis=0)\n    centroid_X = np.mean(X, axis=0)\n    P_centered = P - centroid_P\n    X_centered = X - centroid_X\n\n    # 2. Compute the covariance matrix H = P_centered.T @ X_centered\n    H = P_centered.T @ X_centered\n\n    # 3. Singular Value Decomposition\n    U, S, Vt = np.linalg.svd(H)\n\n    # 4. Compute the optimal rotation matrix R\n    R = Vt.T @ U.T\n\n    # 5. Handle reflection case (det(R) = -1)\n    if np.linalg.det(R)  0:\n        # Flip the sign of the column of V corresponding to the smallest singular value\n        Vt_corrected = Vt.copy()\n        Vt_corrected[-1, :] *= -1\n        R = Vt_corrected.T @ U.T\n\n    # 6. Apply rotation to P_centered\n    # For row vectors, the transformation is P_centered @ R\n    P_rotated = P_centered @ R\n\n    # 7. Calculate RMSD\n    diff = P_rotated - X_centered\n    rmsd = np.sqrt(np.sum(diff**2) / N)\n\n    return rmsd\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating predicted structures against native folds\n    for three test cases.\n    \"\"\"\n    tau = 1.0\n    results = []\n\n    # --- Test Case 1 ---\n    N1 = 5\n    A1 = np.array([[3.8 * i, 0, 0] for i in range(N1)], dtype=float)\n\n    delta = 3.8 / np.sqrt(2)\n    B1 = np.array([\n        [0.0, 0.0, 0.0],\n        [delta, delta, 0.0],\n        [2 * delta, 0.0, 0.0],\n        [3 * delta, delta, 0.0],\n        [4 * delta, 0.0, 0.0]\n    ], dtype=float)\n    \n    theta = np.pi / 6\n    t1 = np.array([1.1, -2.3, 0.5])\n    Rz1_T = np.array([\n        [np.cos(theta), np.sin(theta), 0],\n        [-np.sin(theta), np.cos(theta), 0],\n        [0, 0, 1]\n    ])\n    P1 = A1 @ Rz1_T + t1\n\n    rA1 = calculate_rmsd(P1, A1)\n    rB1 = calculate_rmsd(P1, B1)\n    \n    if rA1 = rB1:\n        r1, m1 = rA1, 1\n    else:\n        r1, m1 = rB1, 2\n    c1 = r1 = tau\n    results.append(f\"[{r1:.3f},{m1},{str(c1)}]\")\n\n    # --- Test Case 2 ---\n    N2 = 6\n    A2 = np.array([[0, 3.8 * i, 0] for i in range(N2)], dtype=float)\n    B2 = np.array([\n        [0.0, 0.0, 0.0],\n        [3.8, 0.0, 0.0],\n        [7.6, 0.0, 0.0],\n        [7.6, 3.8, 0.0],\n        [7.6, 7.6, 0.0],\n        [7.6, 11.4, 0.0]\n    ], dtype=float)\n    \n    phi = -np.pi / 3\n    t2 = np.array([0.2, -0.5, 1.0])\n    Rz2_T = np.array([\n        [np.cos(phi), np.sin(phi), 0],\n        [-np.sin(phi), np.cos(phi), 0],\n        [0, 0, 1]\n    ])\n    P2 = B2 @ Rz2_T + t2\n    \n    rA2 = calculate_rmsd(P2, A2)\n    rB2 = calculate_rmsd(P2, B2)\n\n    if rA2 = rB2:\n        r2, m2 = rA2, 1\n    else:\n        r2, m2 = rB2, 2\n    c2 = r2 = tau\n    results.append(f\"[{r2:.3f},{m2},{str(c2)}]\")\n\n    # --- Test Case 3 ---\n    N3 = 5\n    s_vecs = []\n    # s1\n    s_vecs.append(np.array([3.8 * np.cos(np.pi/3), 3.8 * np.sin(np.pi/3), 0.0]))\n    # s2\n    len_s2 = np.sqrt(3.8**2 - 1.0**2)\n    s_vecs.append(np.array([len_s2 * np.cos(-np.pi/3), len_s2 * np.sin(-np.pi/3), 1.0]))\n    # s3\n    len_s3 = np.sqrt(3.8**2 - 0.7**2)\n    s_vecs.append(np.array([len_s3 * np.cos(np.pi/9), len_s3 * np.sin(np.pi/9), -0.7]))\n    # s4\n    len_s4 = np.sqrt(3.8**2 - 0.9**2)\n    s_vecs.append(np.array([len_s4 * np.cos(-13*np.pi/18), len_s4 * np.sin(-13*np.pi/18), 0.9]))\n    \n    A3_coords = [np.zeros(3)]\n    for i in range(len(s_vecs)):\n        A3_coords.append(np.sum(s_vecs[:i+1], axis=0))\n    A3 = np.array(A3_coords)\n    \n    B3 = B1  # Re-use B1\n    \n    F = np.diag([-1., 1., 1.])\n    P3 = A3 @ F\n    \n    rA3 = calculate_rmsd(P3, A3)\n    rB3 = calculate_rmsd(P3, B3)\n\n    if rA3 = rB3:\n        r3, m3 = rA3, 1\n    else:\n        r3, m3 = rB3, 2\n    c3 = r3 = tau\n    results.append(f\"[{r3:.3f},{m3},{str(c3)}]\")\n    \n    # Final print statement\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2387752"}]}