{"hands_on_practices": [{"introduction": "本练习旨在通过一个高度简化的思想实验，揭示支持向量机（SVM）与径向基函数（RBF）核函数协同工作的核心机制。通过手动计算一个对称训练集（仅包含两个点）的决策函数，您可以亲身体验SVM如何利用核函数评估新数据点与支持向量之间的相似性。这个基础计算练习将帮助您巩固对SVM决策过程的理解，并直观地感受RBF核函数参数 $\\gamma$ 如何塑造特征空间中的几何关系。[@problem_id:2433176]", "problem": "一个细菌学实验室构建了一个二元分类器，使用带有径向基函数 (RBF) 核的支持向量机 (SVM) 来区分致病和共生细菌种类。每种细菌的特征表示是源自基因组衍生的汇总统计数据的一个 $2$ 维空间中的点。训练集由恰好 $2$ 个带标签的样本组成：一个位于 $\\mathbf{x}_{1} = (1, 1)$ 的致病菌，其标签为 $y_{1} = +1$；以及一个位于 $\\mathbf{x}_{2} = (-1, -1)$ 的共生菌，其标签为 $y_{2} = -1$。该 SVM 使用 RBF 核\n$$\nK(\\mathbf{x}, \\mathbf{z}) = \\exp\\!\\big(-\\gamma \\|\\mathbf{x} - \\mathbf{z}\\|^{2}\\big),\n$$\n其中核参数 $\\gamma > 0$，并采用标准硬间隔公式（即在诱导的特征空间中是可分情况）。设得到的决策函数为\n$$\nf(\\mathbf{x}) = \\sum_{i=1}^{2} \\alpha_{i} y_{i} K(\\mathbf{x}_{i}, \\mathbf{x}) + b,\n$$\n其中对偶变量 $\\alpha_{i}$ 和偏置 $b$ 由硬间隔 SVM 优化确定。\n\n计算决策函数在查询点 $\\mathbf{x}_{\\ast} = (0, 0)$ 处的精确值，结果表示为关于 $\\gamma$ 的闭式解析表达式。请将最终答案提供为单个简化表达式。不需要四舍五入，也不涉及单位。", "solution": "对于二元标签 $y_{i} \\in \\{-1, +1\\}$ 和核函数 $K$，硬间隔支持向量机 (SVM) 的对偶优化问题为\n$$\n\\max_{\\boldsymbol{\\alpha} \\in \\mathbb{R}^{2}} \\; W(\\boldsymbol{\\alpha}) = \\sum_{i=1}^{2} \\alpha_{i} - \\frac{1}{2} \\sum_{i=1}^{2} \\sum_{j=1}^{2} \\alpha_{i} \\alpha_{j} y_{i} y_{j} K(\\mathbf{x}_{i}, \\mathbf{x}_{j}),\n$$\n约束条件为对所有 $i$，$\\alpha_{i} \\ge 0$，以及等式约束\n$$\n\\sum_{i=1}^{2} \\alpha_{i} y_{i} = 0.\n$$\n决策函数为\n$$\nf(\\mathbf{x}) = \\sum_{i=1}^{2} \\alpha_{i} y_{i} K(\\mathbf{x}_{i}, \\mathbf{x}) + b,\n$$\n其中 $b$ 由 Karush–Kuhn–Tucker (KKT) 条件确定，在硬间隔情况下，该条件要求对于任何支持向量 $\\mathbf{x}_{i}$，\n$$\ny_{i} f(\\mathbf{x}_{i}) = 1.\n$$\n\n计算核矩阵元素。对于参数为 $\\gamma > 0$ 的径向基函数 (RBF) 核，\n$$\nK(\\mathbf{x}_{1}, \\mathbf{x}_{1}) = \\exp\\!\\big(-\\gamma \\|\\mathbf{x}_{1} - \\mathbf{x}_{1}\\|^{2}\\big) = \\exp(0) = 1,\n$$\n$$\nK(\\mathbf{x}_{2}, \\mathbf{x}_{2}) = \\exp\\!\\big(-\\gamma \\|\\mathbf{x}_{2} - \\mathbf{x}_{2}\\|^{2}\\big) = 1.\n$$\n$\\mathbf{x}_{1} = (1, 1)$ 与 $\\mathbf{x}_{2} = (-1, -1)$ 之间的平方距离为\n$$\n\\|\\mathbf{x}_{1} - \\mathbf{x}_{2}\\|^{2} = (1 - (-1))^{2} + (1 - (-1))^{2} = 2^{2} + 2^{2} = 8,\n$$\n所以\n$$\nK(\\mathbf{x}_{1}, \\mathbf{x}_{2}) = K(\\mathbf{x}_{2}, \\mathbf{x}_{1}) = \\exp(-8 \\gamma).\n$$\n\n根据等式约束 $\\sum_{i=1}^{2} \\alpha_{i} y_{i} = 0$ 和问题的对称性，最优解满足 $\\alpha_{1} = \\alpha_{2} = a$，其中某个 $a \\ge 0$。代入对偶目标函数：\n\\begin{align*}\nW(a) = \\alpha_{1} + \\alpha_{2} - \\frac{1}{2}\\Big( \\alpha_{1}^{2} y_{1}^{2} K_{11} + 2 \\alpha_{1} \\alpha_{2} y_{1} y_{2} K_{12} + \\alpha_{2}^{2} y_{2}^{2} K_{22} \\Big) \\\\\n= 2 a - \\frac{1}{2}\\Big( a^{2} \\cdot 1 \\cdot 1 + 2 a^{2} \\cdot (+1)(-1) K_{12} + a^{2} \\cdot 1 \\cdot 1 \\Big) \\\\\n= 2 a - \\frac{1}{2}\\Big( a^{2} + a^{2} - 2 a^{2} K_{12} \\Big) \\\\\n= 2 a - a^{2} \\big(1 - K_{12}\\big),\n\\end{align*}\n其中 $K_{12} = \\exp(-8 \\gamma)$。对 $a$ 求导并令其为零：\n$$\n\\frac{\\mathrm{d} W}{\\mathrm{d} a} = 2 - 2 a \\big(1 - K_{12}\\big) = 0 \\quad \\Longrightarrow \\quad a = \\frac{1}{1 - K_{12}} = \\frac{1}{1 - \\exp(-8 \\gamma)}.\n$$\n因此，\n$$\n\\alpha_{1} = \\alpha_{2} = \\frac{1}{1 - \\exp(-8 \\gamma)}.\n$$\n\n根据间隔条件确定 $b$。使用 $y_{1} f(\\mathbf{x}_{1}) = 1$ 和 $y_{2} f(\\mathbf{x}_{2}) = 1$：\n\\begin{align*}\n1 = y_{1} f(\\mathbf{x}_{1}) = (+1)\\Big( \\alpha_{1} y_{1} K_{11} + \\alpha_{2} y_{2} K_{21} + b \\Big) = a \\big( 1 - K_{12} \\big) + b, \\\\\n1 = y_{2} f(\\mathbf{x}_{2}) = (-1)\\Big( \\alpha_{1} y_{1} K_{12} + \\alpha_{2} y_{2} K_{22} + b \\Big) = a \\big( 1 - K_{12} \\big) - b.\n\\end{align*}\n将这两个方程相加得到\n$$\n2 = 2 a \\big(1 - K_{12}\\big) \\quad \\Longrightarrow \\quad a \\big(1 - K_{12}\\big) = 1,\n$$\n这与 $a = 1/(1 - K_{12})$ 一致，相减得到 $b = 0$。\n\n现在计算决策函数在 $\\mathbf{x}_{\\ast} = (0, 0)$ 处的值。计算核函数值：\n\\begin{align*}\n\\|\\mathbf{x}_{1} - \\mathbf{x}_{\\ast}\\|^{2} = (1 - 0)^{2} + (1 - 0)^{2} = 1^{2} + 1^{2} = 2, \\\\\n\\|\\mathbf{x}_{2} - \\mathbf{x}_{\\ast}\\|^{2} = (-1 - 0)^{2} + (-1 - 0)^{2} = 1^{2} + 1^{2} = 2,\n\\end{align*}\n所以\n$$\nK(\\mathbf{x}_{1}, \\mathbf{x}_{\\ast}) = \\exp(-2 \\gamma), \\quad K(\\mathbf{x}_{2}, \\mathbf{x}_{\\ast}) = \\exp(-2 \\gamma).\n$$\n因此，\n\\begin{align*}\nf(\\mathbf{x}_{\\ast}) = \\alpha_{1} y_{1} K(\\mathbf{x}_{1}, \\mathbf{x}_{\\ast}) + \\alpha_{2} y_{2} K(\\mathbf{x}_{2}, \\mathbf{x}_{\\ast}) + b \\\\\n= a \\big( +1 \\cdot \\exp(-2 \\gamma) \\big) + a \\big( -1 \\cdot \\exp(-2 \\gamma) \\big) + 0 \\\\\n= a \\exp(-2 \\gamma) - a \\exp(-2 \\gamma) \\\\\n= 0.\n\\end{align*}\n因此，对于所有 $\\gamma > 0$，决策函数在 $\\mathbf{x}_{\\ast} = (0, 0)$ 处的精确值恒为零。", "answer": "$$\\boxed{0}$$", "id": "2433176"}, {"introduction": "在将机器学习模型应用于实际生物学数据时，一个常见挑战是过拟合，即模型在训练数据上表现完美，但在未见过的数据上表现糟糕。本练习模拟了一个典型的生物信息学场景：一个用于蛋白质功能预测的SVM模型表现出严重的过拟合。通过分析这个问题，您将深入理解RBF核函数的宽度参数 $\\gamma$ 如何直接影响模型的复杂度和泛化能力，从而学会诊断和解释模型训练中的关键问题。[@problem_id:2433181]", "problem": "一个研究团队正在构建一个支持向量机（SVM）分类器，以根据序列衍生的特征（如$k$-mer频率、预测的二级结构比例和Pfam域计数）来预测蛋白质功能。数据集包含$n=2000$个蛋白质，被划分为一个类别均衡的分层训练/测试集。一个带有径向基函数（RBF）核的SVM在使用标准特征缩放后进行训练。该模型在训练集上达到了$99\\%$的准确率，但在测试集上仅有$50\\%$的准确率。\n\n根据支持向量机（SVM）的基本定义，带有松弛变量的SVM会最小化一个在最大化间隔和减少训练误差之间进行权衡的目标函数：\n$$\n\\min_{\\mathbf{w},b,\\boldsymbol{\\xi}} \\ \\frac{1}{2}\\lVert \\mathbf{w}\\rVert^2 + C \\sum_{i=1}^{n} \\xi_i \n\\quad \\text{subject to} \\quad y_i\\left(\\mathbf{w}^\\top \\phi(\\mathbf{x}_i) + b\\right) \\ge 1 - \\xi_i,\\ \\xi_i \\ge 0,\n$$\n并且核技巧将内积$\\langle \\phi(\\mathbf{x}), \\phi(\\mathbf{x}') \\rangle$替换为一个核函数$k(\\mathbf{x},\\mathbf{x}')$，其中RBF核定义为：\n$$\nk(\\mathbf{x},\\mathbf{x}') = \\exp\\!\\left(-\\gamma \\lVert \\mathbf{x} - \\mathbf{x}' \\rVert^2\\right),\n$$\n请针对此生物信息学任务，从泛化能力与训练拟合的角度进行论证。\n\n哪个超参数最可能是造成所观察到的性能差距的原因？为什么？\n\nA. 正则化参数$C$过大，导致模型严重惩罚训练误差，缩小了间隔并过拟合了训练数据。\n\nB. 正则化参数$C$过小，导致模型欠拟合；这解释了99%的训练准确率，但50%的测试准确率。\n\nC. RBF核的宽度参数$\\gamma$过大，导致$k(\\mathbf{x},\\mathbf{x}')$变得高度局部化，决策函数变得过于复杂，实际上是记忆了训练集。\n\nD. RBF核的宽度参数$\\gamma$过小，导致核函数范围过宽且近乎线性；这解释了99%的训练准确率，但50%的测试准确率。", "solution": "对问题陈述进行验证。\n\n**第一步：提取已知信息**\n- 机器学习任务：用于蛋白质功能预测的支持向量机（SVM）分类器。\n- 特征：$k$-mer频率、预测的二级结构比例、Pfam域计数。\n- 数据集大小：$n=2000$个蛋白质。\n- 数据划分：类别均衡的分层训练/测试集划分。\n- 模型：带有径向基函数（RBF）核的SVM，使用标准特征缩放。\n- 性能：训练集准确率$99\\%$，测试集准确率$50\\%$。\n- SVM目标函数：$\\min_{\\mathbf{w},b,\\boldsymbol{\\xi}} \\ \\frac{1}{2}\\lVert \\mathbf{w}\\rVert^2 + C \\sum_{i=1}^{n} \\xi_i$。\n- SVM约束条件：$y_i\\left(\\mathbf{w}^\\top \\phi(\\mathbf{x}_i) + b\\right) \\ge 1 - \\xi_i$ 和 $\\xi_i \\ge 0$。\n- 核技巧：内积$\\langle \\phi(\\mathbf{x}), \\phi(\\mathbf{x}') \\rangle$被核函数$k(\\mathbf{x},\\mathbf{x}')$替代。\n- RBF核定义：$k(\\mathbf{x},\\mathbf{x}') = \\exp\\!\\left(-\\gamma \\lVert \\mathbf{x} - \\mathbf{x}' \\rVert^2\\right)$。\n- 问题：确定最可能导致所观察到的性能差距的超参数，并解释原因。\n\n**第二步：使用提取的已知信息进行验证**\n该问题具有科学依据，描述了计算生物学和机器学习中一个标准且现实的场景。SVM目标函数和RBF核的定义在数学上是正确的。所观察到的现象——训练准确率（$99\\%$）和测试准确率（$50\\%$）之间的巨大差异——是严重过拟合的典型案例。对于一个均衡的二元分类任务，50%的测试准确率等同于随机猜测，表明模型完全未能泛化。该问题设定良好，要求基于超参数$C$和$\\gamma$的作用，对这种过拟合的原因进行合理论证。问题陈述是自洽、客观且内部一致的。\n\n**第三步：结论与行动**\n该问题有效。将推导解答。\n\n问题的核心是训练准确率（$99\\%$）与测试准确率（$50\\%$）之间的巨大差距。这是一个教科书式的严重过拟合案例，模型完美地学习了训练数据（包括噪声），以至于无法泛化到未见过的数据。在类别均衡的情况下，50%的测试准确率表明模型在新数据上的预测能力不比随机猜测好。我们必须分析两个超参数$C$和$\\gamma$的作用，以确定最可能的原因。\n\n参数$C$是正则化参数。它控制着在最大化间隔和最小化训练集分类误差之间的权衡。\n- 大的$C$会对被误分类的训练样本（即那些$\\xi_i > 0$的样本）施加高额惩罚。这迫使优化器去寻找一个能够正确分类尽可能多训练样本的决策边界，即使这需要一个复杂的边界和一个较小的间隔。因此，大的$C$会助长过拟合。\n- 小的$C$会施加较小的惩罚，允许更多的训练样本被误分类，以换取更大的间隔。这会导致一个更简单、更“软”的决策边界，如果$C$过小，则可能导致欠拟合。\n\nRBF核$k(\\mathbf{x},\\mathbf{x}') = \\exp(-\\gamma \\lVert \\mathbf{x} - \\mathbf{x}' \\rVert^2)$中的参数$\\gamma$定义了单个训练样本的影响范围。\n- 小的$\\gamma$会导致每个支持向量具有较大的影响半径，因为核函数值随距离的增加而缓慢减小。由此产生的决策边界是平滑的，其行为类似于线性分类器。一个非常小的$\\gamma$可能导致欠拟合。\n- 大的$\\gamma$会导致非常小的影响半径。即使对于离支持向量中等距离的点，核函数值也会迅速下降到接近零。这意味着决策函数只受支持向量紧邻区域内的点的影响。由此产生的决策边界变得高度复杂和非线性，本质上是以训练样本为中心的一系列小的决策区域“孤岛”。这使得模型能够“记忆”训练集，从而导致极端过拟合。\n\n鉴于性能指标——近乎完美的训练准确率和随机猜测水平的测试准确率——模型不仅是过拟合，而且是完全未能学习到可泛化的模式。虽然大的$C$通过惩罚训练误差来促进过拟合，但一个非常大的$\\gamma$为观察到的极端“记忆”行为提供了机制。当$\\gamma$很大时，每个训练点都可以成为其自身的支持向量，在自己周围创建一个局部化的决策区域。这完美地解释了模型如何在训练集上达到99%的准确率，而对于那些没有落在某个训练点极近位置的测试点却毫无预测能力。因此，对于这种特定的、灾难性的失效模式，一个过大的$\\gamma$是最直接、最有说服力的解释。\n\n对选项的评估：\n\nA. 正则化参数$C$过大，导致模型严重惩罚训练误差，缩小了间隔并过拟合了训练数据。\n这个陈述在事实上是正确的。大的$C$确实会导致过拟合。然而，它不像$\\gamma$的影响那样，能直接解释性能崩溃到50%（随机猜测）的极端情况。它是一个促成因素，但可能不是导致这一特定结果的主要或最具影响力的原因。\n\nB. 正则化参数$C$过小，导致模型欠拟合；这解释了99%的训练准确率，但50%的测试准确率。\n这个陈述是矛盾的。小的$C$会导致欠拟合，这会表现为低的训练准确率，而不是99%。因此，该选项是**错误的**。\n\nC. RBF核的宽度参数$\\gamma$过大，导致$k(\\mathbf{x},\\mathbf{x}')$变得高度局部化，决策函数变得过于复杂，实际上是记忆了训练集。\n这个陈述准确地描述了大的$\\gamma$的影响。高度局部化导致模型能够完美拟合训练数据的特定排列，从而获得近乎完美的训练准确率。同样是这种复杂性导致了泛化能力的完全丧失，产生的测试准确率不比随机猜测好。这是对观察到的性能最精确的解释。该选项是**正确的**。\n\nD. RBF核的宽度参数$\\gamma$过小，导致核函数范围过宽且近乎线性；这解释了99%的训练准确率，但50%的测试准确率。\n这个陈述是矛盾的。小的$\\gamma$会导致一个更简单、近乎线性的模型，如果真实边界是复杂的，这将导致欠拟合。它将无法在复杂的数据集上达到99%的训练准确率。因此，该选项是**错误的**。\n\n比较A和C，选项C为观察到的极端过拟合情况提供了更强大、更具体的解释。由大$\\gamma$引起的“记忆”效应是泛化能力完全崩溃至随机猜测水平的最可能原因。", "answer": "$$\\boxed{C}$$", "id": "2433181"}, {"introduction": "支持向量机和核技巧最强大的能力之一，是允许我们为复杂的结构化数据（如DNA序列）设计定制的相似性度量。本练习将引导您超越标准核函数，亲手构建一个为剪接位点预测任务量身定制的加权字符串核函数。您需要将生物学先验知识（外显子与内含子的不同重要性）编码到核函数的设计中，这不仅能锻炼您的编程和数学建模能力，更能让您深刻体会到核工程在解决特定生物信息学问题中的创造性和威力。[@problem_id:2433200]", "problem": "给定一个与计算生物学中剪接位点预测相关的二元分类场景，该场景使用核技巧为支持向量机 (SVM) 建模。考虑字母表 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 上的 DNA 序列，以及字母表 $\\{\\text{E}, \\text{I}\\}$ 上一个等长的注释掩码，分别指示外显子和内含子位置。定义一个加权 $k$-谱字符串核，该核对完全出现在外显子区域内的匹配项增加权重，定义如下。\n\n设 $k \\in \\mathbb{N}$ 为一固定值。对于长度为 $n$ 的序列 $s$ 及其长度为 $n$ 的掩码 $m$，对每个起始位置 $p \\in \\{0,1,\\dots,n-k\\}$，定义 $k$-mer 窗口 $s[p:p+k]$ 及其窗口掩码 $m[p:p+k]$。定义一个位置窗口权重\n$$\ng_{(s,m)}(p) \\;=\\;\n\\begin{cases}\nw_E  \\text{如果 } m[p:p+k] \\text{ 的所有符号都是 } \\text{E},\\\\\nw_I  \\text{如果 } m[p:p+k] \\text{ 的所有符号都是 } \\text{I},\\\\\n0  \\text{其他情况}。\n\\end{cases}\n$$\n对于任意 $k$-mer $u \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}^k$，定义加权特征图分量\n$$\n\\phi_u(s,m) \\;=\\; \\sum_{p=0}^{n-k} g_{(s,m)}(p)\\,\\mathbf{1}\\!\\left[s[p:p+k] = u\\right],\n$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。两个带注释序列 $(s,m)$ 和 $(t,n)$ 之间的核是内积\n$$\nK\\big((s,m),(t,n)\\big) \\;=\\; \\sum_{u \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}^k} \\phi_u(s,m)\\,\\phi_u(t,n).\n$$\n\n使用固定的参数值 $k=2$、$w_E=2$ 和 $w_I=1$。考虑以下等长的带注释 DNA 序列，每个序列以 $(\\text{序列}, \\text{掩码})$ 对的形式给出：\n- $A$: $($\"ACGTAC\"$,$ \"EEEIII\"$)$，\n- $B$: $($\"ACGTTC\"$,$ \"EEIIII\"$)$，\n- $C$: $($\"TTGTAC\"$,$ \"IIIIEE\"$)$，\n- $D$: $($\"AAAAAA\"$,$ \"IIIIII\"$)$，\n- $E$: $($\"AAAAAA\"$,$ \"EEEEEE\"$)$。\n\n你的任务是：\n- 计算核函数值 $K(A,A)$、$K(A,B)$、$K(B,C)$ 和 $K(D,E)$。\n- 为集合 $\\{A,B,C\\}$ 构建 Gram 矩阵 $G$，其元素为 $G_{ij} = K(S_i,S_j)$，其中 $S_1=A$、$S_2=B$、$S_3=C$，并确定 $G$ 是否为半正定，即其所有特征值都大于或等于 $0$（在标准浮点舍入误差范围内）。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，并严格按照以下顺序：\n$[$$K(A,A)$$,$$K(A,B)$$,$$K(B,C)$$,$$K(D,E)$$,$$\\text{is\\_PSD}$$$]$，其中 $\\text{is\\_PSD}$ 是一个布尔值。例如，输出格式必须类似于 $[$$x$$,$$y$$,$$z$$,$$u$$,$$\\text{True}$$]$，不含空格。所有数值答案均无单位。测试套件包括上述指定的四个核函数值计算和对 $\\{A,B,C\\}$ 的 Gram 矩阵的半正定性检查，涵盖了典型情况、跨外显子/内含子交互、全内含子与全外显子对比以及矩阵级别的有效性检查。", "solution": "该问题具有科学依据，定义明确且客观。它提出了一个基于机器学习和生物信息学既定原则的有效计算任务。所有必要的数据和定义都已提供，没有矛盾或含糊之处。我们将开始进行解答。\n\n问题的核心是计算一个加权 $k$-谱字符串核。两个带注释序列 $(s, m)$ 和 $(t, n')$ 之间的核 $K$ 定义为其特征向量的内积，即 $K\\big((s,m),(t,n')\\big) = \\langle \\phi(s,m), \\phi(t,n') \\rangle$。这可以写成：\n$$\nK\\big((s,m),(t,n')\\big) = \\sum_{u \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}^k} \\phi_u(s,m)\\,\\phi_u(t,n')\n$$\n其中 $\\phi_u(s, m)$ 是根据掩码 $m$ 计算的 $k$-mer $u$ 在序列 $s$ 中的加权计数。一个更直接、计算效率更高的公式可以避免对所有可能的 $k$-mer $u$ 进行显式枚举，其形式如下：\n$$\nK\\big((s,m),(t,n')\\big) = \\sum_{p=0}^{|s|-k} \\sum_{q=0}^{|t|-k} g_{(s,m)}(p) g_{(t,n')}(q) \\mathbf{1}\\!\\left[s[p:p+k] = t[q:q+k]\\right]\n$$\n我们将使用特征图求和的方法，因为它在概念上清晰且等价。给定的固定参数为 $k=2$、$w_E=2$ 和 $w_I=1$。所有序列的长度为 $n=6$，因此每个序列中 $2$-mer 的数量为 $n-k+1 = 6-2+1=5$，起始位置为 $p \\in \\{0, 1, 2, 3, 4\\}$。\n\n首先，我们必须为每个带注释的序列 $S \\in \\{A, B, C, D, E\\}$ 计算其特征图 $\\phi(S)$。对于一个 $2$-mer $u$，特征图分量 $\\phi_u(S)$ 是其在序列中所有出现位置的位置权重 $g(p)$ 的总和。\n\n**1. 特征图计算**\n\n对于每个序列，我们列出其 $2$-mer、对应的掩码窗口以及由此产生的位置权重 $g(p)$。\n\n- **序列 A**: $s_A = \\text{\"ACGTAC\"}$, $m_A = \\text{\"EEEIII\"}$\n  - $p=0$: $s_A[0:2]$=\"AC\", $m_A[0:2]$=\"EE\" (全为 'E') $\\implies g_A(0) = w_E = 2$。\n  - $p=1$: $s_A[1:2]$=\"CG\", $m_A[1:2]$=\"EE\" (全为 'E') $\\implies g_A(1) = w_E = 2$。\n  - $p=2$: $s_A[2:4]$=\"GT\", $m_A[2:4]$=\"EI\" (混合) $\\implies g_A(2) = 0$。\n  - $p=3$: $s_A[3:5]$=\"TA\", $m_A[3:5]$=\"II\" (全为 'I') $\\implies g_A(3) = w_I = 1$。\n  - $p=4$: $s_A[4:6]$=\"AC\", $m_A[4:6]$=\"II\" (全为 'I') $\\implies g_A(4) = w_I = 1$。\n  特征图 $\\phi(A)$ 的非零分量为：\n  $\\phi_{\\text{AC}}(A) = g_A(0) + g_A(4) = 2 + 1 = 3$。\n  $\\phi_{\\text{CG}}(A) = g_A(1) = 2$。\n  $\\phi_{\\text{TA}}(A) = g_A(3) = 1$。\n\n- **序列 B**: $s_B = \\text{\"ACGTTC\"}$, $m_B = \\text{\"EEIIII\"}$\n  - $p=0$: \"AC\", \"EE\" (全为 'E') $\\implies g_B(0) = w_E = 2$。\n  - $p=1$: \"CG\", \"EI\" (混合) $\\implies g_B(1) = 0$。\n  - $p=2$: \"GT\", \"II\" (全为 'I') $\\implies g_B(2) = w_I = 1$。\n  - $p=3$: \"TT\", \"II\" (全为 'I') $\\implies g_B(3) = w_I = 1$。\n  - $p=4$: \"TC\", \"II\" (全为 'I') $\\implies g_B(4) = w_I = 1$。\n  $\\phi(B)$ 的非零分量为：\n  $\\phi_{\\text{AC}}(B) = 2$, $\\phi_{\\text{GT}}(B) = 1$, $\\phi_{\\text{TT}}(B) = 1$, $\\phi_{\\text{TC}}(B) = 1$。\n\n- **序列 C**: $s_C = \\text{\"TTGTAC\"}$, $m_C = \\text{\"IIIIEE\"}$\n  - $p=0$: \"TT\", \"II\" (全为 'I') $\\implies g_C(0) = w_I = 1$。\n  - $p=1$: \"TG\", \"II\" (全为 'I') $\\implies g_C(1) = w_I = 1$。\n  - $p=2$: \"GT\", \"II\" (全为 'I') $\\implies g_C(2) = w_I = 1$。\n  - $p=3$: \"TA\", \"IE\" (混合) $\\implies g_C(3) = 0$。\n  - $p=4$: \"AC\", \"EE\" (全为 'E') $\\implies g_C(4) = w_E = 2$。\n  $\\phi(C)$ 的非零分量为：\n  $\\phi_{\\text{TT}}(C) = 1$, $\\phi_{\\text{TG}}(C) = 1$, $\\phi_{\\text{GT}}(C) = 1$, $\\phi_{\\text{AC}}(C) = 2$。\n\n- **序列 D**: $s_D = \\text{\"AAAAAA\"}$, $m_D = \\text{\"IIIIII\"}$\n  - 对于所有 $p \\in \\{0, 1, 2, 3, 4\\}$，$2$-mer 是 \"AA\"，掩码窗口是 \"II\"。\n  - 因此，对于所有 $p$，$g_D(p) = w_I = 1$。\n  $\\phi(D)$ 唯一的非零分量是：\n  $\\phi_{\\text{AA}}(D) = \\sum_{p=0}^4 1 = 5$。\n\n- **序列 E**: $s_E = \\text{\"AAAAAA\"}$, $m_E = \\text{\"EEEEEE\"}$\n  - 对于所有 $p \\in \\{0, 1, 2, 3, 4\\}$，$2$-mer 是 \"AA\"，掩码窗口是 \"EE\"。\n  - 因此，对于所有 $p$，$g_E(p) = w_E = 2$。\n  $\\phi(E)$ 唯一的非零分量是：\n  $\\phi_{\\text{AA}}(E) = \\sum_{p=0}^4 2 = 10$。\n\n**2. 核函数值计算**\n\n我们现在计算指定的核函数值。\n\n- $K(A,A) = \\langle\\phi(A), \\phi(A)\\rangle = \\sum_u (\\phi_u(A))^2 = (\\phi_{\\text{AC}}(A))^2 + (\\phi_{\\text{CG}}(A))^2 + (\\phi_{\\text{TA}}(A))^2 = 3^2 + 2^2 + 1^2 = 9 + 4 + 1 = 14$。\n\n- $K(A,B) = \\langle\\phi(A), \\phi(B)\\rangle = \\sum_u \\phi_u(A)\\phi_u(B)$。唯一具有非零权重的共同 $2$-mer 是 \"AC\"。\n  $K(A,B) = \\phi_{\\text{AC}}(A)\\phi_{\\text{AC}}(B) = 3 \\times 2 = 6$。\n\n- $K(B,C) = \\langle\\phi(B), \\phi(C)\\rangle$。共同的 $2$-mer 有 \"AC\"、\"GT\" 和 \"TT\"。\n  $K(B,C) = \\phi_{\\text{AC}}(B)\\phi_{\\text{AC}}(C) + \\phi_{\\text{GT}}(B)\\phi_{\\text{GT}}(C) + \\phi_{\\text{TT}}(B)\\phi_{\\text{TT}}(C) = (2 \\times 2) + (1 \\times 1) + (1 \\times 1) = 4 + 1 + 1 = 6$。\n\n- $K(D,E) = \\langle\\phi(D), \\phi(E)\\rangle$。唯一共同的 $2$-mer 是 \"AA\"。\n  $K(D,E) = \\phi_{\\text{AA}}(D)\\phi_{\\text{AA}}(E) = 5 \\times 10 = 50$。\n\n**3. Gram 矩阵与半正定性检查**\n\n集合 $\\{A, B, C\\}$ 的 Gram 矩阵 $G$ 是一个 $3 \\times 3$ 的对称矩阵，其元素为 $G_{ij} = K(S_i, S_j)$，其中 $S_1=A, S_2=B, S_3=C$。我们已经计算了非对角线元素 $K(A,B)=6$ 和 $K(B,C)=6$。我们需要计算 $K(A,C)$、$K(B,B)$ 和 $K(C,C)$。\n\n- $K(A,C) = \\langle\\phi(A), \\phi(C)\\rangle$。唯一共同的 $2$-mer 是 \"AC\"。\n  $K(A,C) = \\phi_{\\text{AC}}(A)\\phi_{\\text{AC}}(C) = 3 \\times 2 = 6$。\n\n- $K(B,B) = \\langle\\phi(B), \\phi(B)\\rangle = \\sum_u (\\phi_u(B))^2 = (\\phi_{\\text{AC}}(B))^2 + (\\phi_{\\text{GT}}(B))^2 + (\\phi_{\\text{TT}}(B))^2 + (\\phi_{\\text{TC}}(B))^2 = 2^2 + 1^2 + 1^2 + 1^2 = 4 + 1 + 1 + 1 = 7$。\n\n- $K(C,C) = \\langle\\phi(C), \\phi(C)\\rangle = \\sum_u (\\phi_u(C))^2 = (\\phi_{\\text{AC}}(C))^2 + (\\phi_{\\text{GT}}(C))^2 + (\\phi_{\\text{TT}}(C))^2 + (\\phi_{\\text{TG}}(C))^2 = 2^2 + 1^2 + 1^2 + 1^2 = 4 + 1 + 1 + 1 = 7$。\n\n因此，Gram 矩阵为：\n$$\nG = \\begin{pmatrix} K(A,A)  K(A,B)  K(A,C) \\\\ K(B,A)  K(B,B)  K(B,C) \\\\ K(C,A)  K(C,B)  K(C,C) \\end{pmatrix} = \\begin{pmatrix} 14  6  6 \\\\ 6  7  6 \\\\ 6  6  7 \\end{pmatrix}\n$$\n要确定 $G$ 是否为半正定 (PSD)，我们必须检查其所有特征值 $\\lambda$ 是否为非负。我们求解特征方程 $\\det(G - \\lambda I) = 0$。\n$$\n\\det \\begin{pmatrix} 14-\\lambda  6  6 \\\\ 6  7-\\lambda  6 \\\\ 6  6  7-\\lambda \\end{pmatrix} = 0\n$$\n$$\n(14-\\lambda)((7-\\lambda)^2 - 36) - 6(6(7-\\lambda) - 36) + 6(36 - 6(7-\\lambda)) = 0\n$$\n这可以简化为特征多项式 $(\\lambda-1)(\\lambda-5)(\\lambda-22)=0$。\n特征值为 $\\lambda_1 = 1$、$\\lambda_2 = 5$ 和 $\\lambda_3 = 22$。由于所有特征值都严格为正，G 不仅是半正定的，而且是正定的。这是符合预期的，因为任何定义为特征空间中内积的核都是一个有效的 Mercer 核，并且总会产生一个半正定的 Gram 矩阵。`is_PSD` 的结果是 `True`。\n\n结果总结：\n- $K(A,A) = 14$\n- $K(A,B) = 6$\n- $K(B,C) = 6$\n- $K(D,E) = 50$\n- `is_PSD` = `True`", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes specified kernel values and checks the positive semidefiniteness \n    of a Gram matrix for a custom weighted k-spectrum string kernel.\n    \"\"\"\n    \n    # Define fixed parameters from the problem statement.\n    k = 2\n    w_E = 2.0\n    w_I = 1.0\n\n    # Define the annotated DNA sequences.\n    sequences = {\n        'A': (\"ACGTAC\", \"EEEIII\"),\n        'B': (\"ACGTTC\", \"EEIIII\"),\n        'C': (\"TTGTAC\", \"IIIIEE\"),\n        'D': (\"AAAAAA\", \"IIIIII\"),\n        'E': (\"AAAAAA\", \"EEEEEE\"),\n    }\n\n    def get_phi(seq_tuple, k, w_E, w_I):\n        \"\"\"\n        Computes the feature map phi for a given annotated sequence.\n        The map is a dictionary from k-mers to their weighted counts.\n        \"\"\"\n        s, m = seq_tuple\n        n = len(s)\n        phi = {}\n        for p in range(n - k + 1):\n            kmer = s[p:p + k]\n            mask_window = m[p:p + k]\n            weight = 0.0\n            \n            if all(char == 'E' for char in mask_window):\n                weight = w_E\n            elif all(char == 'I' for char in mask_window):\n                weight = w_I\n            \n            if weight > 0:\n                phi[kmer] = phi.get(kmer, 0.0) + weight\n        return phi\n\n    def kernel(phi_X, phi_Y):\n        \"\"\"\n        Computes the kernel value K(X, Y) as the inner product of their feature maps.\n        \"\"\"\n        val = 0.0\n        # Iterate over the smaller dictionary for efficiency.\n        if len(phi_X) > len(phi_Y):\n            phi_X, phi_Y = phi_Y, phi_X\n        \n        for kmer, value_X in phi_X.items():\n            value_Y = phi_Y.get(kmer, 0.0)\n            val += value_X * value_Y\n        return val\n\n    # Pre-compute all feature maps.\n    phis = {name: get_phi(data, k, w_E, w_I) for name, data in sequences.items()}\n\n    # Compute the four required kernel values.\n    k_AA = kernel(phis['A'], phis['A'])\n    k_AB = kernel(phis['A'], phis['B'])\n    k_BC = kernel(phis['B'], phis['C'])\n    k_DE = kernel(phis['D'], phis['E'])\n    \n    # Construct the Gram matrix G for the set {A, B, C}.\n    gram_keys = ['A', 'B', 'C']\n    N = len(gram_keys)\n    gram_matrix = np.zeros((N, N))\n    for i in range(N):\n        for j in range(i, N):\n            # Kernel function is symmetric, K(X, Y) = K(Y, X).\n            val = kernel(phis[gram_keys[i]], phis[gram_keys[j]])\n            gram_matrix[i, j] = val\n            gram_matrix[j, i] = val\n            \n    # Check if G is positive semidefinite by checking if all eigenvalues are non-negative.\n    # A small tolerance is used for floating-point arithmetic inaccuracies.\n    # np.linalg.eigvalsh is numerically stable and efficient for symmetric matrices.\n    eigenvalues = np.linalg.eigvalsh(gram_matrix)\n    is_psd = np.all(eigenvalues >= -1e-9)\n\n    # Assemble the final results list.\n    # Convert floats to integers if they are whole numbers.\n    results = [\n        int(k_AA) if k_AA == int(k_AA) else k_AA,\n        int(k_AB) if k_AB == int(k_AB) else k_AB,\n        int(k_BC) if k_BC == int(k_BC) else k_BC,\n        int(k_DE) if k_DE == int(k_DE) else k_DE,\n        is_psd\n    ]\n    \n    # Print the results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2433200"}]}